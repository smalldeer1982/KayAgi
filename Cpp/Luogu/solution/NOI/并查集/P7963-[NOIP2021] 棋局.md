# [NOIP2021] 棋局

## 题目背景

在输了一晚上的麻将之后，小 z 和小 c 卸掉了手机上的所有牌类游戏。不过这怎么可能阻挡得了他们上课颓废的决心呢？现在他们的目光盯在了棋类游戏上，但他们两个除了天天下飞行棋以外，几乎所有棋类游戏都只懂个大概规则。

“既然我们都会玩但只能玩一点点，不如我们自己搞个缝合怪出来吧！”

于是，在他们的精心脑洞之下，一个融合了围棋、象棋与军棋的奇妙游戏诞生了……

## 题目描述

游戏在一张长 $n$ 行宽 $m$ 列的网格形棋盘上进行，棋子落在网格的交叉点上，我们不妨记左上角的交叉点的坐标为 $(1,1)$，右下角的交叉点坐标为 $(n,m)$。

棋子分为黑白两色，对局双方各执一方棋子。

每个棋子除了颜色以外还有等级，不妨设 $\mathit{col}_i$ 为棋子 $i$ 的颜色，$\mathit{lv}_i$ 为棋子 $i$ 的等级。另外，棋盘上的网格线共有 $4$ 种状态，对于第 $i$ 条网格线，设其状态为 $\mathit{opt}_i$。

轮到每方下棋时，他可以选择棋盘上的一个己方棋子沿网格线进行移动到另一个交叉点，称为走子。形式化定义走子的过程如下：选择一个坐标序列 $(x_0,y_0),(x_1,y_1),\ldots,(x_k,y_k)$，其中 $k$ 是任意选定的正整数，$(x_0,y_0)$ 是棋子初始的位置，$(x_k,y_k)$ 是棋子最终走到的位置，需要满足：

- 对于任意 $i=0,1,\ldots,k-1$，坐标 $(x_i,y_i)$ 和 $(x_{i+1},y_{i+1})$ 之间必须有网格线直接相连，也就是说**走子必须沿着网格线走**；
- 对于任意 $i\not=j$，必须有 $(x_i,y_i)\ne(x_j,y_j)$，也就是说走子过程中不能经过重复位置，特别地 $(x_0,y_0)\ne(x_k,y_k)$，也就是说**不能原地不动（或走回原地）**；
- 对于任意 $i=1,\ldots,k-1$，坐标 $(x_i,y_i)$ 上必须没有棋子，也就是说**走子时不能越过已有的棋子**；
- 若 $(x_k,y_k)$ 上没有棋子，称为普通走子，否则称为吃子。在吃子过程中，设正在走的棋子颜色为 $\mathit{col}_1$，等级为 $\mathit{lv}_1$，被吃的棋子颜色为 $\mathit{col}_2$，等级为 $\mathit{lv}_2$，则必须满足 $\mathit{col}_1\ne\mathit{col}_2,\mathit{lv}_1\geq\mathit{lv}_2$，换句话说**只能吃与自己颜色不同，且等级不高于自己等级的棋子**。

需要注意的是，由上述定义可以得出，不允许棋子在吃子后继续向前走。

网格线的状态含义如下所述：

- 如果 $\mathit{opt}_i=0$，代表此路不通，走子时不能经过这条网格线；
- 如果 $\mathit{opt}_i=1$，代表这条网格线是一条“普通道路”，每次走子时棋子最多只能经过 $1$ 条普通道路。
- 如果 $\mathit{opt}_i=2$，代表这条网格线是一条“直行道路”，每次走子时棋子可以经过任意条直行道路，但只能**一直沿横向或一直沿纵向走，不能转弯**。如沿直行道路从 $(1,1)$ 经过 $(1,2)$ 走到 $(1,3)$ 是可以的，但是从 $(1,1)$ 经过 $(1,2)$ 走到 $(2,2)$ 不行。
- 如果 $\mathit{opt}_i=3$，代表这条网格线是一条“互通道路”，每次走子时棋子可以经过任意条互通道路，且中途可任意转弯。

同时规定在一次走子过程中，**棋子经过的网格线的状态必须全部相同**，比如从 $(1,1)$ 经过直行道路走到 $(1,2)$ 再经过互通道路走到 $(1,3)$ 是不允许的。

至于如何判断胜负等其它细节，与本题无关，故略去。

小 z 和小 c 开发出这款棋类游戏后，为了提升水平，想了一个训练的策略：一开始棋盘是空的，然后小 c 会每次往棋盘的某个空交叉点上放一枚棋子，小 z 需要快速计算出：若选择这枚新放上的棋子进行一次走子，棋盘上一共有多少个位置是能被走到的？注意：因为这只是思维训练，他们并不会真的走这枚棋子。

可怜的小 z 发现他的计算力不足以算出这个问题，只好向你求助。

## 说明/提示

**【样例解释 #1】**

放置棋子 $1$ 后，它能走到的位置为 $(2, 1),(2, 2),(3, 2),(3, 3)$。

放置棋子 $2$ 后，它能走到的位置为 $(2, 2),(2, 3),(3, 1)$。

放置棋子 $3$ 后，它能走到的位置为 $(1, 1),(1, 3),(2, 2)$。

放置棋子 $4$ 后，它能走到的位置为 $(2, 2),(3, 1),(3, 3)$。

放置棋子 $5$ 后，它能走到的位置为 $(2, 3),(3, 2)$。


**【数据范围】**

| 测试点编号 | $n \times m \le$ | $q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $100$ | $50$ | 无 |
| $3 \sim 6$ | $5000$ | $2000$ | 无 |
| $7 \sim 8$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路”与“互通道路” |
| $9 \sim 11$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“互通道路” |
| $12 \sim 14$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路” |
| $15 \sim 16$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = i$ |
| $17 \sim 18$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = q - i + 1$ |
| $19 \sim 21$ | $2 \times {10}^5$ | $2000$ | $n, m \le 1000$ |
| $22 \sim 25$ | $2 \times {10}^5$ | ${10}^5$ | 无 |

对于 $100 \%$ 的数据，$1 \le T \le 5$，$2 \le n, m \le {10}^5$，$4 \le n \times m \le 2 \times {10}^5$，$1 \le q \le \min \{ {10}^5, n \times m \}$，$1 \le \mathit{lv}_i \le q$，$1 \le x_i \le n$，$1 \le y_i \le m$，$\mathit{col}_i \in \{ 0, 1 \}$。

注：由于本题输入输出规模较大，建议使用较为快速的输入输出方式。

## 样例 #1

### 输入

```
1
3 3 5
13
22
23
010
233
0 1 2 3
1 2 2 1
1 3 1 2
0 2 3 2
1 3 2 2
```

### 输出

```
4
3
3
3
2
```

## 样例 #2

### 输入

```
2
2 3 4
22
33
123
0 2 1 2
0 1 2 1
1 2 1 3
0 3 2 2
3 2 3
3
1
3
32
32
0 2 1 2
1 2 3 2
0 1 2 2
```

### 输出

```
3
4
4
2
5
5
1
```

## 样例 #3

### 输入

```
见附件中的 chess/chess3.in```

### 输出

```
见附件中的 chess/chess3.ans```

## 样例 #4

### 输入

```
见附件中的 chess/chess4.in```

### 输出

```
见附件中的 chess/chess4.ans```

# 题解

## 作者：破壁人五号 (赞：75)

棋子会将棋盘分开为若个部分，分裂过程不好维护。故先离线所有询问，将添加棋子改为删除棋子。

为了方便，我们略微更改棋子的等级，使其两两不同。

我们首先考虑 3 类边。我们维护三类边组成的连通块，每个连通块需要维护四个数据结构：
- 其连到的白子的等级（我们需要查询等级小于等于给定值的棋子个数）；
- 其连到的黑子的等级（我们需要查询等级小于等于给定值的棋子个数）；
- 空位，同一行的空位应当连续（我们需要查询一行的某一段中包含多少空位）；
- 空位，同一列的空位应当连续（我们需要查询一列的某一段中包含多少空位）；

同时我们还需要支持合并两个连通块、删除一个棋子。其可以用并查集+线段树合并实现。

接着考虑 2 类边。我们直接维护两个（横向与纵向的）并查集，分别维护 2 类边构成的连通块。为了不与 3 类边算重，我们要去掉：
- 2 类连通块两端的棋子，如果出现在 3 类连通块中；
- 2 类连通块内的空白段，将这个段放到 3 类连通块内查询。

最后考虑 1 类边，我们依次检查其相邻的几个位置，如果它们没有在 2 或 3 类边中统计过，则加进答案中。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5;
#define x first
#define y second
#define pii pair<int,int>
int n,m,q,idlim;
int idh(int x,int y){ return x*(m+2)+y; }
pii hdi(int id){ return pii(id/(m+2),id%(m+2)); }
int idv(int x,int y){ return y*(n+2)+x; }
pii vdi(int id){ return pii(id%(n+2),id/(n+2)); }
template<class T>
struct array2d{
	T a[N];
	int n,m;
	void init(int val=0){
		memset(a,val,sizeof(a));
	}
	void set_size(int n,int m,int val=0){
		this->n=n;
		this->m=m;
		init(val);
	}
	T* operator[](int i){
		return a+i*(m+2);
	}
	const T* operator[](int i)const{
		return a+i*(m+2);
	}
	T& operator[](pii p){
		return a[p.x*(m+2)+p.y];
	}
	const T& operator[](pii p)const{
		return a[p.x*(m+2)+p.y];
	}
};
array2d<int> v,h,col,lv,tim;
vector<pii> piece;

struct node{
	int ch[2],sz;
};
node t[N*30];int cnt;
void pushup(int x){
	t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz;
}
void insert(int p,int &x,int l,int r){
	if(!x)x=++cnt;
	if(l==r){ t[x].sz=1;return; }
	int mid=(l+r)>>1;
	if(p<=mid)insert(p,t[x].ch[0],l,mid);
	else insert(p,t[x].ch[1],mid+1,r);
	pushup(x);
}
void erase(int p,int &x,int l,int r){
	if(!x)return;
	if(l==r){ t[x].sz=0;return; }
	int mid=(l+r)>>1;
	if(p<=mid)erase(p,t[x].ch[0],l,mid);
	else erase(p,t[x].ch[1],mid+1,r);
	pushup(x);
}
int merge(int x,int y){
	if(!(x&&y))return x+y;
	t[x].ch[0]=merge(t[x].ch[0],t[y].ch[0]);
	t[x].ch[1]=merge(t[x].ch[1],t[y].ch[1]);
	if(t[x].ch[0]||t[x].ch[1])pushup(x);
	else t[x].sz|=t[y].sz;
	return x;
}
int query_rk(int v,int x,int l,int r){
	if(!t[x].sz)return 0;
	if(l==r)return t[x].sz;
	int mid=(l+r)>>1;
	if(v<=mid)return query_rk(v,t[x].ch[0],l,mid);
	else return t[t[x].ch[0]].sz+query_rk(v,t[x].ch[1],mid+1,r);
}
bool exist(int v,int x,int l,int r){
	if(!t[x].sz)return 0;
	if(l==r)return 1;
	int mid=(l+r)>>1;
	if(v<=mid)return exist(v,t[x].ch[0],l,mid);
	else return exist(v,t[x].ch[1],mid+1,r);
}

struct DSU_with_lr{
	int l[N],r[N],f[N];
	int _(int x){ return f[x]==x?x:f[x]=_(f[x]); }
	void merge(int x,int y){
		x=_(x),y=_(y);
		if(x==y)return;
		f[x]=y;
		l[y]=min(l[y],l[x]);
		r[y]=max(r[y],r[x]);
	}
	int getl(int id){ return l[_(id)]; }
	int getr(int id){ return r[_(id)]; }
	bool check(int x,int y){ return _(x)==_(y); }
};
DSU_with_lr hseg,vseg;

struct block{
	int rt0,rt1,rth,rtv;
	void merge(block &y){
		rt0=::merge(rt0,y.rt0);
		rt1=::merge(rt1,y.rt1);
		rth=::merge(rth,y.rth);
		rtv=::merge(rtv,y.rtv);
	}
	int get0(int v){ return query_rk(v,rt0,1,q); }
	void ins0(int v){ insert(v,rt0,1,q); }
	void era0(int v){ erase(v,rt0,1,q); }
	int get1(int v){ return query_rk(v,rt1,1,q); }
	void ins1(int v){ insert(v,rt1,1,q); }
	void era1(int v){ erase(v,rt1,1,q); }
	void ins01(int col,int v){ col?ins1(v):ins0(v); }
	void era01(int col,int v){ col?era1(v):era0(v); }
	void insp(int x,int y){
		insert(idh(x,y),rth,1,idlim);
		insert(idv(x,y),rtv,1,idlim);
	}
	int getsz(int col,int lv){
		return t[rth].sz+(1-col?get1(lv):get0(lv));
	}
	int geth(int x,int y1,int y2,int colx,int lvx){
		auto check=[&](int p,int q){
			return col[p][q]==1-colx&&lv[p][q]<=lvx&&exist(lv[p][q],1-colx?rt1:rt0,1,::q);
		};
		return query_rk(idh(x,y2),rth,1,idlim)-query_rk(idh(x,y1-1),rth,1,idlim)
			  +(h[x][y1-1]==2&&check(x,y1-1))+(h[x][y2]==2&&check(x,y2+1));
	}
	int getv(int x1,int x2,int y,int colx,int lvx){
		auto check=[&](int p,int q){
			return col[p][q]==1-colx&&lv[p][q]<=lvx&&exist(lv[p][q],1-colx?rt1:rt0,1,::q);
		};
		return query_rk(idv(x2,y),rtv,1,idlim)-query_rk(idv(x1-1,y),rtv,1,idlim)
			  +(v[x1-1][y]==2&&check(x1-1,y))+(v[x2][y]==2&&check(x2+1,y));
	}
};
template<class T>
struct DSU_array2d{
	array2d<T>a;
	array2d<pii>f;
	void init(int val=0){
		a.init(val);
	}
	void set_size(int n,int m,int val=0){
		a.set_size(n,m,val);
		f.set_size(n,m,val);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				f[i][j]={i,j};
	}
	pii _(pii x){ return x==f[x]?x:f[x]=_(f[x]); }
	T& operator[](pii p){
		return a[_(p)];
	}
	void merge(pii x,pii y){
		x=_(x),y=_(y);
		if(x==y)return;
		a[x].merge(a[y]);
		f[y]=x;
	}
};
DSU_array2d<block> b;

int qsum=0;
int ans[N];
int lvcnt[N];
void mian(){
	cin>>n>>m>>q;
	v.set_size(n,m);
	h.set_size(n,m);
	col.set_size(n,m,-1);
	lv.set_size(n,m);
	tim.set_size(n,m);
	piece.clear();
	memset(t,0,sizeof(t));
	memset(&hseg,0,sizeof(hseg));
	memset(&vseg,0,sizeof(vseg));
	memset(lvcnt,0,sizeof(lvcnt));
	b.set_size(n,m);
	for(int i=0;i<N;i++)hseg.l[i]=hseg.r[i]=hseg.f[i]=i;
	for(int i=0;i<N;i++)vseg.l[i]=vseg.r[i]=vseg.f[i]=i;
	idlim=(n+3)*(m+3);

	cnt=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<m;j++){
			char c;cin>>c;
			h[i][j]=c-'0';
		}
	for(int i=1;i<n;i++)
		for(int j=1;j<=m;j++){
			char c;cin>>c;
			v[i][j]=c-'0';
		}
	for(int i=1;i<=q;i++){
		int colx,lvx,x,y;
		cin>>colx>>lvx>>x>>y;
		col[x][y]=colx;
		lv[x][y]=lvx;
		++lvcnt[lvx];
		tim[x][y]=i;
		piece.push_back(pii(x,y));
	}
	for(int i=1;i<=q;i++)lvcnt[i]+=lvcnt[i-1];
	for(int i=q-1;i>=0;--i)lv[piece[i].x][piece[i].y]=lvcnt[lv[piece[i].x][piece[i].y]]--;
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			if(h[i][j]==2&&!lv[i][j]&&!lv[i][j+1])hseg.merge(idh(i,j),idh(i,j+1));
			if(h[i][j]==3&&!lv[i][j]&&!lv[i][j+1])b.merge({i,j},{i,j+1});
			if(h[i][j]==3&&lv[i][j]&&!lv[i][j+1]){
				b[{i,j+1}].ins01(col[i][j],lv[i][j]);
			}
			if(h[i][j]==3&&!lv[i][j]&&lv[i][j+1]){
				b[{i,j}].ins01(col[i][j+1],lv[i][j+1]);
			}
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			if(v[i][j]==2&&!lv[i][j]&&!lv[i+1][j])vseg.merge(idv(i,j),idv(i+1,j));
			if(v[i][j]==3&&!lv[i][j]&&!lv[i+1][j])b.merge({i,j},{i+1,j});
			if(v[i][j]==3&&lv[i][j]&&!lv[i+1][j]){
				b[{i+1,j}].ins01(col[i][j],lv[i][j]);
			}
			if(v[i][j]==3&&!lv[i][j]&&lv[i+1][j]){
				b[{i,j}].ins01(col[i+1][j],lv[i+1][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!lv[i][j]){
				b[{i,j}].insp(i,j);
			}
		}
	}
	for(int i=q-1;i>=0;--i){
		int ans=-1;
		int x=piece[i].x,y=piece[i].y;
		int lvx=lv[x][y],colx=col[x][y];
		lv[x][y]=0; col[x][y]=-1;

		if(h[x][y]==2&&!lv[x][y]&&!lv[x][y+1])hseg.merge(idh(x,y),idh(x,y+1));
		if(h[x][y-1]==2&&!lv[x][y-1]&&!lv[x][y])hseg.merge(idh(x,y-1),idh(x,y));
		pii l=hdi(hseg.getl(idh(x,y))),r=hdi(hseg.getr(idh(x,y)));
		ans+=r.y-l.y+1;

		if(v[x][y]==2&&!lv[x][y]&&!lv[x+1][y])vseg.merge(idv(x,y),idv(x+1,y));
		if(v[x-1][y]==2&&!lv[x-1][y]&&!lv[x][y])vseg.merge(idv(x-1,y),idv(x,y));
		pii u=vdi(vseg.getl(idv(x,y))),d=vdi(vseg.getr(idv(x,y)));
		ans+=d.x-u.x+1;

		b[{x,y}].insp(x,y);
		if(h[x][y]==3){
			if(!lv[x][y+1])b.merge({x,y},{x,y+1});
			else b[{x,y}].ins01(col[x][y+1],lv[x][y+1]);
		}
		if(h[x][y-1]==3){
			if(!lv[x][y-1])b.merge({x,y-1},{x,y});
			else b[{x,y}].ins01(col[x][y-1],lv[x][y-1]);
		}
		if(v[x][y]==3){
			if(!lv[x+1][y])b.merge({x,y},{x+1,y});
			else b[{x,y}].ins01(col[x+1][y],lv[x+1][y]);
		}
		if(v[x-1][y]==3){
			if(!lv[x-1][y])b.merge({x-1,y},{x,y});
			else b[{x,y}].ins01(col[x-1][y],lv[x-1][y]);
		}
		b[{x,y}].era01(colx,lvx);
		ans+=b[{x,y}].getsz(colx,lvx);
		ans-=b[{x,y}].geth(l.x,l.y,r.y,colx,lvx);
		ans-=b[{x,y}].getv(u.x,d.x,u.y,colx,lvx);

		if(col[l.x][l.y-1]==1-colx&&h[l.x][l.y-1]==2&&lv[l.x][l.y-1]<=lvx)++ans,--l.y;
		if(col[r.x][r.y+1]==1-colx&&h[r.x][r.y  ]==2&&lv[r.x][r.y+1]<=lvx)++ans,++r.y;
		if(col[u.x-1][u.y]==1-colx&&v[u.x-1][u.y]==2&&lv[u.x-1][u.y]<=lvx)++ans,--u.x;
		if(col[d.x+1][d.y]==1-colx&&v[d.x  ][d.y]==2&&lv[d.x+1][d.y]<=lvx)++ans,++d.x;
		
		auto check=[&](int p,int q){
			return !lv[p][q]||(col[p][q]==1-colx&&lv[p][q]<=lvx);
		};
		auto vis=[&](int p,int q){
			if(b._({p,q})==b._({x,y}))return 1;
			if(lv[p][q]&&exist(lv[p][q],col[p][q]?b[{x,y}].rt1:b[{x,y}].rt0,1,::q))return 1;
			return 0;
		};
		if(h[x][y]==1&&check(x,y+1)&&!vis(x,y+1))++ans;
		if(v[x][y]==1&&check(x+1,y)&&!vis(x+1,y))++ans;
		if(h[x][y-1]==1&&check(x,y-1)&&!vis(x,y-1))++ans;
		if(v[x-1][y]==1&&check(x-1,y)&&!vis(x-1,y))++ans;
		::ans[i]=ans;
	}
	for(int i=0;i<q;i++)cout<<ans[i]<<"\n";
	qsum+=q;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T;cin>>T;
	while(T--){
		mian();
	}
}
```


---

## 作者：liuzhangfeiabc (赞：59)

题目大意：给定 $n\times m$ 的棋盘，棋盘上有 $4$ 种类型的边，分别代表不可通行、只能走一步、只能一直沿一个方向往前走和可以任意走。棋子有两种颜色和等级，棋子间可以吃子，规定只能吃颜色不同且等级不高于自己的棋子，且吃完子后不能继续向前走。同时规定每次走子时经过的边类型必须相同。初始棋盘是空的，有 $q$ 次操作，每次往棋盘上放一个棋子，问这个棋子能走到多少个格子。

题解：先在不考虑吃子的情况下看一个棋子能走到哪些空格子。此时可以把之前已经放上的棋子当作障碍，那么对于第一类边，只需要考虑上下左右 $4$ 个格子；对于第二类边，只需要考虑沿着上下左右 $4$ 个方向延伸出去的一条线段；对于第三类边，只需要考虑第三类边形成的连通块。

我们发现放一个棋子相当于删掉图中的一个点，删点维护图的连通性这件事太蛋疼了，于是我们不妨把问题反过来：假设一开始所有的棋子都是在棋盘上的，我们要每次删去一个棋子，删之前问它能走到多少个格子。

显然加点维护连通性是相对容易的，在不需要维护特殊信息的情况下只需要并查集就能搞定；即使需要维护集合，我们也有启发式合并、线段树合并等一堆合并集合的数据结构和算法。这为我们进一步分析题目提供了很好的技术支持。

首先，对于一类边，只有有限个点的情况总是好处理的：在别的情况都处理完之后，只需要暴力查询一下这几个点是否能被以其他方式走到即可。用并查集自然就可以做到。

对于二类边，我们可以在每个点上维护它向 $4$ 个方向最远能沿着二类边走到哪。这件事也可以用并查集来维护，就是连续一段横向或纵向的二类边串起来的点分别用并查集维护起来，并查集中再顺手维护一个集合的编号最小/最大的点总是容易的。

对于三类边，我们好像也可以直接拿并查集维护所有点在三类边下的连通性，维护每个连通块的大小即可。

做完了吗？没有，最麻烦之处在于：如果一个点通过二类边和三类边都能走到，怎么去重？

此时要注意到一个性质：我们可以让二类边串起来的一排点的编号是连续的。如果我们把点按照横坐标第一关键字、纵坐标第二关键字排序的话，那么横向的二类边连通块对应编号连续的集合；反之，如果纵坐标第一关键字、横坐标第二关键字，编号连续的就是纵向的二类边连通块了。

所以，如果我们能在一个三类边连通块里查询编号位于某个区间内的点的数量，就可以实现去重了。

回过头来，我们发现简单地用并查集维护三类边的连通块似乎是行不通的，因为去重操作意味着我们还需要实打实地把每个连通块中的点记录下来。这就要用到我们先前提到的集合合并了：我们对每个三类边连通块开两个集合，分别存储其中的点按照两种编号方式的编号。合并连通块时，将两个集合对应合并，查询时在集合中区间查询即可。这里推荐使用线段树合并，因为复杂度为 $1$ 个 $\log$ 且线段树天生支持区间查询。

最后还要处理吃子的情况。我们发现能通过一、二类边吃到的子每个方向上最多一个，因此也留到最后暴力处理即可；而通过三类边能吃到的子可能很多，在当前这个三类边连通块里，如果某个点又向外连了一条三类边而且恰好遇到了一个棋子，它就要被纳入考虑。

具体而言，我们要在每个三类边连通块上同时绑定与其直接通过三类边相邻的棋子集合，当然肯定要分黑白两色维护；合并连通块时，需要把两个集合分别合并，同时注意一个棋子可能同时在两个三类边连通块的集合中，因此还要去重（这里推荐先离散化使得每个棋子的等级均不同，以便于去重）。查询时，只需查询与当前棋子颜色相反的集合中，等级不超过它自身的棋子有多少个即可，这相当于一个前缀查询操作。显然这也是线段树合并就能解决的任务。对于一、二类边的特判，只需将涉及到的棋子在线段树中查询一下是否存在即可。

总结：倒序操作+合并连通块+维护集合，支持合并、区间查询+线段树合并，总复杂度 $O((nm+q) \log (nm+q))$ 。

最后码长大约6KB多的样子，能在场上写出来调过的人请深受我一拜orz。实际上，如果不去写正解的话，至少前 $32$ 分是可以直接模拟+bfs简单通过的，中间“没有三类边”的部分可以如上述题解所述用并查集维护二类边连通块，最后 $n,m\leq 1000,q\leq 2000$ 的部分只需要用并查集维护三类边连通块的大小，而一、二类边以及可能的吃子均不超过 $O(n+m+q)$ 级别，可以枚举+暴力判断，复杂度 $O(nm+q(n+m+q))$（不过据我所知场上真正写了这档的人好像很少的样子qwq）。如上至少 $56$ 分是可以不用写大数据结构即可实现的。~~有人说T4部分分是乱给的，他可不是乱给的啊~~

```cpp
#include<bits/stdc++.h>
#define gc getchar()
#define pc putchar
#define li long long
#define md int mid = (l + r) >> 1
#define ln ls[q],l,mid
#define rn rs[q],mid + 1,r
using namespace std;
inline void file(char *s){
	char c[50];
	sprintf(c,"%s.in",s);
	freopen(c,"r",stdin);
	sprintf(c,"%s.out",s);
	freopen(c,"w",stdout);
}
int t,n,m,q;
int e[4][200010],ans[100010],qz[200010];

struct node{
	int col,lv,x,y,id;
}a[100010],aa[100010];
inline bool operator < (node x,node y){
	return x.lv == y.lv ? x.id < y.id : x.lv < y.lv;
}
char ch[200010];
#define pos(x,y) (((x) - 1) * m + (y))
#define pos2(x,y) (((y) - 1) * n + (x))
#define tox(x) (((x) - 1) / m + 1)
#define toy(x) (((x) - 1) % m + 1)
void mgg(int,int);
struct bcj{
	int f[200010],sz[200010],mx[200010],mn[200010];
	inline int getf(int x){
		return f[x] == x ? x : f[x] = getf(f[x]);
	}
	inline void mg(int u,int v,bool fg = 0){
		u = getf(u),v = getf(v);
		if(u == v) return;
		if(sz[u] > sz[v]) swap(u,v);
		sz[v] += sz[u];f[u] = v;
		mx[v] = max(mx[v],mx[u]);
		mn[v] = min(mn[v],mn[u]);
		if(fg) mgg(u,v);
	}
	inline void init(int p){
		for(int i = 1;i <= p;++i) f[i] = mx[i] = mn[i] = i,sz[i] = 1;
	}
	inline int chksz(int x){return sz[getf(x)];}
	inline int chkmx(int x){return mx[getf(x)];}
	inline int chkmn(int x){return mn[getf(x)];}
}bc[3];
struct xds{
	int rt[200010],ls[8000010],rs[8000010],sz[8000010],cnt;
	inline void init(){
		memset(rt,0,sizeof(rt));
		for(int i = 1;i <= cnt;++i) ls[i] = rs[i] = sz[i] = 0; 
		cnt = 0;
	}
	int ins(int q,int l,int r,int x,int v = 1){
		if(!q) q = ++cnt;
		if(l == r){
			if(v == -1) return 0;
			if(!sz[q]) ++sz[q]; 
			return q;
		}
		md;
		if(mid >= x) ls[q] = ins(ln,x,v);
		else rs[q] = ins(rn,x,v);
		sz[q] = sz[ls[q]] + sz[rs[q]];
		return sz[q] ? q : 0;
	}
	int mg(int p,int q,int l,int r,int op = -1){
		if(!p || !sz[p]) return q;
		if(!q || !sz[q]) return p;
		if(l == r){
			sz[q] = min(1,sz[q] + sz[p]);
			return q;
		}
		md;
		ls[q] = mg(ls[p],ln,op);
		rs[q] = mg(rs[p],rn,op);
		sz[q] = sz[ls[q]] + sz[rs[q]];
		return q;
	}
	int qy(int q,int l,int r,int x){
		if(!q || !x) return 0;
		if(l == r) return sz[q];
		md;
		if(mid >= x) return qy(ln,x);
		return sz[ls[q]] + qy(rn,x);
	}
	int qy2(int q,int l,int r,int x){
		if(!q || !x) return 0;
		if(l == r) return sz[q];
		md;
		if(mid >= x) return qy2(ln,x);
		return qy2(rn,x);
	}
	int cx(int q,int l,int r){
		return qy(rt[q],1,n * m,r) - qy(rt[q],1,n * m,l - 1);
	}
}xd[4];
void mgg(int u,int v){
	xd[0].rt[v] = xd[0].mg(xd[0].rt[u],xd[0].rt[v],1,q);
	xd[1].rt[v] = xd[1].mg(xd[1].rt[u],xd[1].rt[v],1,q);
	xd[2].rt[v] = xd[2].mg(xd[2].rt[u],xd[2].rt[v],1,n * m);
	xd[3].rt[v] = xd[3].mg(xd[3].rt[u],xd[3].rt[v],1,n * m);
}

inline void init(){
	memset(e,0,sizeof(e));
	memset(qz,0,sizeof(qz));
	memset(ans,0,sizeof(ans));
	for(int i = 0;i < 3;++i) bc[i].init(n * m);
	for(int i = 0;i < 4;++i) xd[i].init();
}
int dx[4] = {-1,0,1,0},dy[4] = {0,-1,0,1};
inline bool caneat(int x,int y){
	if(!y || y >= x) return 0;
	node ax = a[x],ay = a[y];
	return ax.col != ay.col && ax.lv >= ay.lv;
}
int main(){
	//file("chess");
	int i,j,k,id,tx,ty,nxt;
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d",&n,&m,&q);
		init();
		for(i = 1;i <= n;++i){
			scanf("%s",ch + 1);
			for(j = 1;j < m;++j){
				e[1][pos(i,j + 1)] = e[3][pos(i,j)] = ch[j] - '0';
			}  
		}
		for(i = 1;i < n;++i){
			scanf("%s",ch + 1);
			for(j = 1;j <= m;++j){
				e[0][pos(i + 1,j)] = e[2][pos(i,j)] = ch[j] - '0';
			} 
		}
		for(i = 1;i <= q;++i){
			scanf("%d%d%d%d",&a[i].col,&a[i].lv,&a[i].x,&a[i].y);
			a[i].id = i;
		}
		sort(a + 1,a + q + 1);
		for(i = 1;i <= q;++i) a[i].lv = i;
		for(i = 1;i <= q;++i) aa[a[i].id] = a[i];
		for(i = 1;i <= q;++i) a[i] = aa[i];
		for(i = 1;i <= q;++i) qz[pos(a[i].x,a[i].y)] = i;
		for(i = 1;i <= n;++i){
			for(j = 1;j <= m;++j){
				id = pos(i,j);
				for(k = 0;k < 4;++k) if(e[k][id] > 1){
					tx = i + dx[k];ty = j + dy[k];nxt = pos(tx,ty);
					if(!qz[id] && !qz[nxt]) bc[e[k][id] == 3 ? 0 : k % 2 + 1].mg(id,nxt);
				}
			}
		}
		for(i = 1;i <= n;++i){
			for(j = 1;j <= m;++j){
				id = pos(i,j);int iid = bc[0].getf(id);
				xd[2].rt[iid] = xd[2].ins(xd[2].rt[iid],1,n * m,pos2(i,j));
				xd[3].rt[iid] = xd[3].ins(xd[3].rt[iid],1,n * m,id);
				for(k = 0;k < 4;++k) if(e[k][id] == 3){
					tx = i + dx[k];ty = j + dy[k];nxt = pos(tx,ty);
					if(qz[nxt]){
						int tmp = a[qz[nxt]].col;
						xd[tmp].rt[iid] = xd[tmp].ins(xd[tmp].rt[iid],1,q,a[qz[nxt]].lv);
					}
				}
			}
		}
		
		for(i = q;i;--i){
			id = pos(a[i].x,a[i].y);
			int tmp = a[i].col,px = a[i].x,py = a[i].y;
			
			//opt=3
			for(j = 0;j < 4;++j) if(e[j][id] == 3){
				tx = px + dx[j];ty = py + dy[j];nxt = pos(tx,ty);
				nxt = bc[0].getf(nxt);
				xd[tmp].rt[nxt] = xd[tmp].ins(xd[tmp].rt[nxt],1,q,a[i].lv,-1);
			}
			for(j = 0;j < 4;++j) if(e[j][id] == 3){
				tx = px + dx[j];ty = py + dy[j];nxt = pos(tx,ty);
				if(qz[nxt] && qz[nxt] < i) continue;
				bc[0].mg(id,nxt,1);
			}
			int iid = bc[0].getf(id);
			ans[i] = bc[0].chksz(id) + xd[!tmp].qy(xd[!tmp].rt[iid],1,q,a[i].lv);
			
			//opt=2
			for(j = 0;j < 4;++j) if(e[j][id] == 2){
				tx = px + dx[j];ty = py + dy[j];nxt = pos(tx,ty);
				if(qz[nxt] && qz[nxt] < i) continue;
				bc[j % 2 + 1].mg(id,nxt);
			} 
			int mx1 = bc[1].chkmx(id),mx2 = bc[2].chkmx(id);
			int mn1 = bc[1].chkmn(id),mn2 = bc[2].chkmn(id);
			ans[i] += mx2 - mn2 + 1 + (mx1 - mn1) / m + 1;
			
			//all
			int dmx = pos2(tox(mx1),toy(mx1)),dmn = pos2(tox(mn1),toy(mn1));
			ans[i] -= xd[2].cx(iid,dmn,dmx) + xd[3].cx(iid,mn2,mx2);
			if(e[0][mn1] == 2 && caneat(i,qz[mn1 - m])){
				if(!xd[!tmp].qy2(xd[!tmp].rt[iid],1,q,a[qz[mn1 - m]].lv)) ++ans[i];
			} 
			if(e[1][mn2] == 2 && caneat(i,qz[mn2 - 1])){
				if(!xd[!tmp].qy2(xd[!tmp].rt[iid],1,q,a[qz[mn2 - 1]].lv)) ++ans[i];
			} 
			if(e[2][mx1] == 2 && caneat(i,qz[mx1 + m])){
				if(!xd[!tmp].qy2(xd[!tmp].rt[iid],1,q,a[qz[mx1 + m]].lv)) ++ans[i];
			} 
			if(e[3][mx2] == 2 && caneat(i,qz[mx2 + 1])){
				if(!xd[!tmp].qy2(xd[!tmp].rt[iid],1,q,a[qz[mx2 + 1]].lv)) ++ans[i];
			} 
			
			//opt=1
			for(j = 0;j < 4;++j) if(e[j][id] == 1){
				tx = px + dx[j];ty = py + dy[j];nxt = pos(tx,ty);
				if(qz[nxt] && qz[nxt] < i){
					if(caneat(i,qz[nxt]) && !xd[!tmp].qy2(xd[!tmp].rt[iid],1,q,a[qz[nxt]].lv)) ++ans[i];
				}
				else if(bc[0].getf(id) != bc[0].getf(nxt)) ++ans[i];
			}
			--ans[i];
		}
		for(i = 1;i <= q;++i){
			printf("%d\n",ans[i]);
		} 
	}
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：21)

- 多写题解从我做起。
- 勿做斜杠青年从我做起。
- 希望作者不要爆零。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P7963)。
- 一个 $n\times m$ 的网格。
- 每个格点除了向边缘没有网格线以外上下左右四个方向都有四条网格线。
- 每个棋子有且仅有三种走子方式：**只**通过**一条**标号为 $1$ 的网格线走一步，**只**通过标号为 $2$ 的网格往**同一个方向**一直走，**只**通过标号为 $3$ 的网格走。
- 每个棋子在通往其它格点时可能会遇到棋子阻碍，这时一定不能**穿过**该棋子，但是如果该棋子与本棋子颜色不同且等级不高于走子的等级，则可以到达该棋子所在的位置，否则不可以。
- 给出棋盘以及所有网格线的标号，在棋盘上按顺序放 $q$ 个棋子，你要对于每个棋子输出**当前**它能够走到的格点数量（但不需要走子）。
- 多测，数据组数不超过 $5$，$1\le q\le n\times m\le 2\times 10^5$，$q\le 10^5$，保证每个棋子的等级都是 $1$ 到 $q$ 的整数，且只有白子和黑子。

**暴力**
- 别看到这题如此要求复杂连暴力都不会打了。
- ~~下次就应该多做大模拟。~~
- 这里主要要注意的是三种走法是可能经过重复的节点的（比如走法 $1$ 和走法 $3$ 重合了），这里不能草率地用一个数组记录有没有跑过。
- [暴力代码](https://www.luogu.com.cn/paste/a9szfy92)，得分 $32$。
- 打完它后笔者表示怀疑人生。
- 接下来还有更怀疑人生的：看着 $\text{1.00GB}$ 的空间我们大胆猜测它是一个数据结构题……
- 所以我们赶快来水分吧！水完分再去学数据结构。
- [这是作者开（正在更新的）的线段树专题](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/xian-duan-shu)。
- 下面是作者的水分挑战。（作者将会给出下面代码实现的时间开始到结束）

**暴力**
- 作者觉得自己暴力打得太烂了于是决定重新打一遍暴力！
- 作者将一些实现的细节记录：我靠作者的位移惯性打成短整型，我靠作者忘记判断是否越界就读取数据！
- 虽然打了 $2$ 小时但代码只有 $1.6\text{KB}$ 还是可以的。
- [代码实现](https://www.luogu.com.cn/paste/5beweyjc)。
- 时间复杂度 $O(nmq)$，空间复杂度 $O(nm+q)$，由于某组织的数据太水这个可以拿 $44$ 分，即通过编号为 $1$ 至 $11$ 的测试点。


**不存在互通道路**
- 这里重点讨论直行道路的情况。
- 使用并查集即可维护每个点上下左右所到达的最远的棋子，然后就可以计算（不愧是并查集）。
- 由于某组织的数据太水导致暴力的代码就可以水到该部分分所以这里不给出代码。

**不存在直行道路**
- 也就是只需要维护互通道路的情况外加四个点的特判。
- 考虑离线从后往前跑。（这是一个直觉：连边比删边好维护）
- 使用一个并查集维护连通性，用两棵动态开点权值线段树分别维护棋子黑色和白色的棋子有哪些，暴力删点，暴力线段树合并即可。
- 水分代码打线段树合并……真是非人哉。
- 时间复杂度 $O(\max(n,m)\alpha(nm)q+nm\lg(nm))$，空间复杂度 $O(nm\lg(nm)+q)$。
- 注意实现有个小细节，棋子可能会被不同的连通块盯上，所以我们在合并信息的时候要对棋子进行去重操作，这个时候可以通过离散化重新标记每个棋子的级别使得棋子级别两两不同便于操作。
- 作者打了很久，但是自测有点像暴力？~~原来是作者与或不清写假了。~~
- [代码实现](https://www.luogu.com.cn/paste/xofzw4ew)，能够得到 $56$ 分的~~好~~成绩。
- 打了 $6$ 小时（其实中途空缺了），代码 $3.7\text{KB}$（死人啦），线段树合并部分的代码其实并不长。

**一般情况**
- 必须处理掉那个“直行道路”。
- ~~其实到现在我们都没有考察到底有什么性质。~~
- 在并查集维护最远点的基础上，我们主要就是希望知道能走到的路径中有多少已经在 $3$ 路径之内。
- 简单来讲就是查询某个连通块内横/纵坐标为 $x$ 的点在区间 $[l,r]$ 有多少个。
- 树套树是一个直观的想法~~树套树合并吗~~，~~虽然如果正确实现时空复杂度也是对的~~但显然过于复杂。
- 完全没有用到连通块是横纵坐标连续的性质呢，我们对坐标 $(x,y)$ 分别标号为 $mx+y$ 和 $ny+x$，然后查询相当于查询一个区间的点有多少个，用最朴素的线段树合并即可。
- $4$ 类线段树，$3$ 类并查集，时间复杂度 $O(nm\lg(nm)+q\lg q)$，空间复杂度 $O(nm\lg(nm)+q)$ ~~实在是太好打了呢~~。
- [代码实现](https://www.luogu.com.cn/paste/gtojy7s8)。
- 打了两天（中途有空缺），代码长度 $4.3\text{KB}$（我靠怎么这么长）。
- 做一些细节上的提示：判断标号为 $1$ 的网格线需要的判断语句较长，推荐使用宏定义。
- 注意四类线段树全都是用来维护 $3$ 号网格线的，而上下的最值信息才是 $2$ 号网格线维护的。
- 感觉线段树合并并不是最困难的，维护才是最困难的，考场上很容易写挂。
- 还有感觉题目的样例真的不错，过了样例基本上程序就没错了。

---

## 作者：lory1608 (赞：8)

由于存在相对颜色大小关系，我们考虑线段树合并来维护这个结构。

为了后续的讨论的方便，我们将`lv`进行离散化。

这里的离散化是在对统计不产生影响时，将所有的值都变得不同。

对于每个连通块我们维护四颗线段树分别表示表示：

- 与这个连通块相邻的黑色点的权值。
- 与这个连通块相邻的白色点的权值。
- 这个连通块的所有空格点按照列连续编号的对应序号。
- 这个连通块的所有空格点按照列行连续的对应序号。

同时维护两个是为了之后处理直行道路时好处理。

初始化时，我们将每个点的相邻的有`互通道路`且没有点的直接`merge`起来，对于旁边有邻居的点，我们就在对应线段树上的该点对应的值设为`1`。

对于所有直行道路，我们预处理出每个点像上下左右最远能走到哪里，以及是否是因为一个放上棋子的点而停止，若是以一个放上棋子的点而停止，那么额外记录一下这个点的位置。

**注意：这里的处理点是从前向后不断加入的。**

回答问题部分，我们先删去这个点的贡献：

1. 对四周由`互通道路`连起来的连通块的该点对应`lv`的贡献置为`0`。
2. 对该点所在连通块该位置的值设为`1`。
3. 对旁边没有放棋子的点`merge`起来。

然后再回答询问，答案分为个部分：

设当前询问点为 $u$ 。

1. `+`所有在 $u$ 联通块的`空格`的个数。
2. `+`所有与 $u$ 联通块相邻的`可以被吃掉的棋子`的个数。
3. `+`行和列的`空格`贡献的个数。
4. `-`行和列的`空格`中在互通道路中记录的个数。
5. `+`这上面，我们在`1`中对 $u$ 算了一次，在`3,4`中分别减了 $u$ 一次，所以答案还要`+1`。
6. `+`对于普通道路，我们判断他是否是棋子
   - 若是棋子，判断它是否和 $u$ 所在连通块中 `互通道路` 的空格相邻。
   - 若是空格，判断它是否在 $u$ 所在连通块中 `互通道路` 中统计过。
7. `+`对于因为是一个棋子摆在直行道路的最后而结束的直行道路，我们要判断判断它是否和 $u$ 所在连通块中 `互通道路` 的空格相邻。

然后就没了。

细心一点，一点一点讨论，写出这道题的正解的思路还是很清晰的。

复杂度 $O(n\log n)$ 。

代码：

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define pb push_back
#define sz(x) (int)(x.size())
#define ll long long
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
using namespace std;
char buf[100000],*p1=buf,*p2=buf;
inline int gi()
{
	int x=0,f=1;char ch=gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc;}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=gc;}
	return (f==1)?x:-x;
}
const int maxn=2e5+5;
const int dr[4]={1,-1,0,0};
const int dc[4]={0,0,1,-1};
char tmp[maxn];
int n,m,q;
vector<vector<int>>s,t;
int col[maxn],lv[maxn],x[maxn],y[maxn];
int id[maxn],fa[maxn],ans[maxn];
//vector<int>nodes_row[maxn],nodes_column[maxn];///空格
vector<pair<int,int>>neighbors[maxn];
vector<int>nvis;
vector<int>lef[maxn],rig[maxn],up[maxn],down[maxn];
///up and down 是对应线段树的column
///lef and rig 对应的是线段树的row
///注意先merge在查询，查询时注意这个点要剪掉1 
set<int>nowr[maxn],nowc[maxn];
pair<int,int>qcol[maxn],qrow[maxn];
vector<int>special[maxn]; 
vector<vector<int>>vis,ncol;
///vis,nvis->leval
struct segmentree///线段树合并 
{
	static const int maxm=8e6+5;
	int rt[maxn],tot;
	int ls[maxm],rs[maxm],sum[maxm];
	inline void clear()
	{
		memset(rt,0,sizeof(rt));
		memset(ls,0,sizeof(int)*(tot+1));
		memset(rs,0,sizeof(int)*(tot+1));
		memset(sum,0,sizeof(int)*(tot+1));
		tot=0;
	}
	inline void pushup(int u)
	{
		sum[u]=sum[ls[u]]+sum[rs[u]];
	}
	inline void update(int &u,int l,int r,int x,int v)
	{
		if(!u)u=++tot;
		if(l==r)return sum[u]=v,void();
		int mid=(l+r)>>1;
		if(x<=mid)update(ls[u],l,mid,x,v);
		else update(rs[u],mid+1,r,x,v);
		pushup(u);
	}
	inline int query(int u,int l,int r,int x,int y)
	{
		if(!u)return 0;
		if(x<=l&&y>=r)return sum[u];
		int mid=(l+r)>>1,ret=0;
		if(x<=mid)ret=query(ls[u],l,mid,x,y);
		if(y>mid)ret+=query(rs[u],mid+1,r,x,y);
		return ret;
	}
	inline int merge(int u,int v,int l,int r)
	{
		if(!u||!v)return u+v;
		if(l==r)return sum[u]=sum[u]|sum[v],u;
		int mid=(l+r)>>1;
		ls[u]=merge(ls[u],ls[v],l,mid);
		rs[u]=merge(rs[u],rs[v],mid+1,r);
		pushup(u);
		return u;
	}
	///直接合并，如果有点=1 
}tree[2],row,column;
///分别按行列去统计该连通块的点在直行道路的情况 
inline int index_row(int x,int y){return (x-1)*m+y;}
inline int index_column(int x,int y){return (y-1)*n+x;}
inline int get(int x)
{
	if(x==fa[x])return x;
	return fa[x]=get(fa[x]);
}
inline void init()
{
	memset(tmp,0,sizeof(tmp));
	memset(col,0,sizeof(col));
	memset(lv,0,sizeof(lv));
	memset(x,0,sizeof(x));
	memset(y,0,sizeof(y));
	memset(id,0,sizeof(id));
	memset(fa,0,sizeof(fa));
//	memset(cnt,0,sizeof(cnt));
	memset(ans,0,sizeof(ans));
	memset(qrow,0,sizeof(qrow));
	memset(qcol,0,sizeof(qcol));
	s.clear(),t.clear();
//	FOR(i,1,n*m)nodes_row[i].clear();
//	FOR(i,1,n*m)nodes_column[i].clear();
	FOR(i,1,n*m)neighbors[i].clear();
	FOR(i,1,n*m)special[i].clear();
	FOR(i,1,max(n,m))nowr[i].clear(),lef[i].clear(),rig[i].clear();
	FOR(i,1,max(n,m))nowc[i].clear(),up[i].clear(),down[i].clear();
	tree[0].clear(),tree[1].clear();
	row.clear(),column.clear(),nvis.clear();
	vis.clear(),ncol.clear();
}
inline void merge(int u,int v)
{
	u=get(u),v=get(v);
	if(u==v)return ;
	fa[u]=v;
	tree[0].rt[v]=tree[0].merge(tree[0].rt[u],tree[0].rt[v],1,n*m);
	tree[1].rt[v]=tree[1].merge(tree[1].rt[u],tree[1].rt[v],1,n*m);
	row.rt[v]=row.merge(row.rt[u],row.rt[v],1,n*m);
	column.rt[v]=column.merge(column.rt[u],column.rt[v],1,n*m);
}
inline void read(char *s)
{
	char ch=gc;
	while(ch<'0'||ch>'3')ch=gc;
	while(ch>='0'&&ch<='3')*s++=ch,ch=gc;
	*s='\0';
} 
inline void input()
{
	n=gi(),m=gi(),q=gi();
	nvis.resize(n*m+1);
	s.resize(n+2);
	FOR(i,0,n)s[i].resize(m+2);
	t.resize(n+2);
	FOR(i,0,n)t[i].resize(m+2);
	vector<pair<int,int>>ord;
	FOR(i,1,n)
	{
		read(tmp+1);
//		scanf("%s",tmp+1);
		FOR(j,1,m-1)s[i][j]=tmp[j]-'0';
	}
	FOR(i,1,n-1)
	{
		read(tmp+1);
//		scanf("%s",tmp+1);
		FOR(j,1,m)t[i][j]=tmp[j]-'0';
	}
	FOR(i,1,q)
	{
		col[i]=gi(),lv[i]=gi(),x[i]=gi(),y[i]=gi();
		ord.pb({lv[i],i});
	}
	sort(ord.begin(),ord.end());
	FOR(i,0,sz(ord)-1)
	{
		int id=i+1;
		lv[ord[i].second]=id;
	}
	vis.resize(n+1),ncol.resize(n+1);
	FOR(i,0,n)vis[i].resize(m+1),ncol[i].resize(m+1);
	FOR(i,1,q)vis[x[i]][y[i]]=lv[i],ncol[x[i]][y[i]]=col[i];
	FOR(i,1,n)FOR(j,1,m)
	{
		int u=index_row(i,j);
		FOR(k,0,3)
		{
			int tx=i+dr[k],ty=j+dc[k];
			if(tx<1||tx>n||ty<1||ty>m)continue;
			int typ=0;
			if(k==0)typ=t[i][j];
			else if(k==1)typ=t[i-1][j];
			else if(k==2)typ=s[i][j];
			else typ=s[i][j-1];
			neighbors[index_row(i,j)].pb({index_row(tx,ty),typ});
			int c=ncol[tx][ty];
			if(vis[tx][ty]&&typ==3)tree[c].update(tree[c].rt[u],1,n*m,vis[tx][ty],1);
		}
		column.update(column.rt[u],1,n*m,index_column(i,j),1);
		row.update(row.rt[u],1,n*m,index_row(i,j),1);
		int c=ncol[i][j],v=vis[i][j];
		if(v)tree[c].update(tree[c].rt[u],1,n*m,v,1);
		if(v)nvis[u]=v;
	}
	FOR(i,1,n*m)fa[i]=i;
//	FOR(i,1,n)FOR(j,1,m)
//	{
//		int x=index_row(i,j);
//		printf("ans[%d][%d][0]=%d,ans[%d][%d][1]=%d\n",i,j,tree[0].query(tree[0].rt[get(x)],1,n*m,1,n*m),
//		i,j,tree[1].query(tree[1].rt[get(x)],1,n*m,1,n*m));
//	}
	FOR(i,1,n*m)
	{
		for(auto x:neighbors[i])
		{
			int v=x.first,typ=x.second;
			if(typ!=3)continue;
			if(!nvis[i]&&!nvis[v])merge(i,v);
		}
	}
}
inline void solve()
{
	FOR(i,1,n)lef[i].resize(m+1),rig[i].resize(m+1),up[i].resize(m+1),down[i].resize(m+1);
	FOR(i,1,n)FOR(j,1,m)lef[i][j]=rig[i][j]=j,up[i][j]=down[i][j]=i;
	FOR(i,1,n)
	{
		FOR(j,2,m)if(s[i][j-1]==2)lef[i][j]=lef[i][j-1];
		for(int j=m-1;j>=1;--j)if(s[i][j]==2)rig[i][j]=rig[i][j+1];
	}
	FOR(j,1,m)
	{
		FOR(i,2,n)if(t[i-1][j]==2)up[i][j]=up[i-1][j];
		for(int i=n-1;i>=1;--i)if(t[i][j]==2)down[i][j]=down[i+1][j];
	}
	///特判普通道路以及直行道路的尽头的颜色 
	FOR(i,1,q)
	{
		int u=index_row(x[i],y[i]);
		qrow[i]={index_row(x[i],lef[x[i]][y[i]]),index_row(x[i],rig[x[i]][y[i]])};
		qcol[i]={index_column(up[x[i]][y[i]],y[i]),index_column(down[x[i]][y[i]],y[i])};
		auto it=nowr[x[i]].lower_bound(y[i]);
		if(it!=nowr[x[i]].end()&&(*it)<=rig[x[i]][y[i]])
		{
			qrow[i].second=index_row(x[i],(*it)-1);
			special[u].pb(index_row(x[i],*it));
		}
		if(it!=nowr[x[i]].begin()&&*(--it)>=lef[x[i]][y[i]])
		{
			qrow[i].first=index_row(x[i],(*it)+1);
			special[u].pb(index_row(x[i],*it));
		}
		it=nowc[y[i]].lower_bound(x[i]);
		if(it!=nowc[y[i]].end()&&(*it)<=down[x[i]][y[i]])
		{
			qcol[i].second=index_column((*it)-1,y[i]);
			special[u].pb(index_row(*it,y[i]));
		}
		if(it!=nowc[y[i]].begin()&&*(--it)>=up[x[i]][y[i]])
		{
			qcol[i].first=index_column((*it)+1,y[i]);
			special[u].pb(index_row(*it,y[i]));
		}
		nowr[x[i]].insert(y[i]);
		nowc[y[i]].insert(x[i]);
	}
	for(int i=q;i>=1;--i)
	{
		///del it
		int u=index_row(x[i],y[i]);
//		cerr<<x[i]<<' '<<y[i]<<endl;
		for(auto x:neighbors[u])
		{
			int v=x.first,typ=x.second;
			if(typ==3&&nvis[v])tree[col[i]].update(tree[col[i]].rt[get(v)],1,n*m,lv[i],0);
			if(typ!=3||nvis[v])continue;
			merge(u,v);
		}
		nvis[u]=0;
//		for(auto x:neighbors[u])
//		{
//			int v=x.first,typ=x.second;
//			if(typ!=3||!nvis[v])continue;
//			tree[nvis[v]].update(tree[nvis[v]].rt[get(u)],1,n*m,nvis[v],1);
//		}
		u=get(u);
		tree[col[i]].update(tree[col[i]].rt[u],1,n*m,lv[i],0);
		ans[i]=tree[col[i]^1].query(tree[col[i]^1].rt[u],1,n*m,1,lv[i]);
		ans[i]+=column.sum[column.rt[u]];
		///注意这里column和row的情况没处理完 
		ans[i]+=qcol[i].second-qcol[i].first;
		ans[i]+=qrow[i].second-qrow[i].first;
		ans[i]-=column.query(column.rt[u],1,n*m,qcol[i].first,qcol[i].second);
		ans[i]-=row.query(row.rt[u],1,n*m,qrow[i].first,qrow[i].second);
		ans[i]++;
		int v=index_row(x[i],y[i]); 
		for(int x:special[v])
		{
			int r=(x-1)/m+1,c=(x-1)%m+1;
			if(vis[r][c]<=lv[i]&&ncol[r][c]!=col[i])
			{
				ans[i]++;
				if(tree[col[i]^1].query(tree[col[i]^1].rt[u],1,n*m,nvis[x],nvis[x]))ans[i]--;
			}
		}
		for(auto x:neighbors[v])
		{
			int v=x.first,typ=x.second;
			if(typ!=1)continue;
			if(nvis[v])
			{
				int r=(v-1)/m+1,c=(v-1)%m+1;
				if(vis[r][c]<=lv[i]&&ncol[r][c]!=col[i])
				{
					ans[i]++;
					if(tree[ncol[r][c]].query(tree[ncol[r][c]].rt[u],1,n*m,nvis[v],nvis[v]))ans[i]--;
				}
			}
			else
			{
				ans[i]++;
				if(row.query(row.rt[u],1,n*m,v,v))ans[i]--;
			}
		}
	}
	FOR(i,1,q)printf("%d\n",ans[i]);
} 
int main()
{
	freopen("chess.in","r",stdin);
	freopen("chess.out","w",stdout);
	int T=gi();
	while(T--)
	{
		init();
		input();
		solve();
	}
	return 0;
}
```

---

## 作者：2018ljw (赞：6)

一个复杂度较劣，但写起来没那么难受的做法。

分析复杂度时，记 $S=n\times m$，即棋盘总点数。

题目让维护的是一个类似于连通块大小的东西，但是带删。这东西删除看起来很不可做，所以时光倒流转化为加点。然后分四步处理。

### 普通道路

不难发现只能走一步，维护每个位置的棋子暴力处理就好。

### 直行道路

不难发现走直行道路能到的一定是竖直或水平的一段，如果遇到棋子的话单独判一下能不能吃就好。等价于对每一行列维护若干区间，找一个位置在区间内左右第一个障碍物或区间终点。

对于这两类，我们可以直接处理出来。

然后每次操作，**维护该位置向四个方向统计答案的长度**，作用过会说明。

### 互通道路

互通道路走出来的应该是一个连通块，所以对于每个由互通道路构成的连通块，我们将其染色。

不吃子的情况下，问题等价于某种颜色的数量，直接维护就好。

维护每种颜色块沿互通道路能走到的棋子，对黑白分别开一个线段树维护等级的前缀和即可处理吃子。

不难发现棋子数与连通块点数最坏情况下大致同阶，大多时候远小于连通块点数，所以合并时候分别 dsu 就好，使用 map 去重，复杂度 $O(S\log^2S)$。

### 去重

直行和普通肯定不会重复的，我们已经对这两类维护了它们能走到的区间。只需要考虑它们和互通的重复。

记新加入的棋子在此时所在互通连通块的颜色为 $c$。

#### 吃子

等价于问该时刻下被吃的棋子是否在 $c$ 的相邻块中。

直接用维护的 map 查询即可。

#### 行走

等价于该时刻下，问四次某段区间里颜色为 $c$ 的点的个数。

乍一看这东西很不可做，毕竟主席树不支持带修。

首先要明确 dsu 对颜色的修改次数为 $O(n\log n)$ 级别。

另一个很好的事情是我们可以离线。

离线，将 $q$ 次询问按颜色分组，每次处理询问颜色相同的组。

那么修改就变成几类：$0$ 变 $0$、$0$ 变 $1$ 和 $1$ 变 $0$。

$0$ 变 $0$ 的修改我们需要忽略掉，对于剩下的，竖直方向的询问开 $m$ 个线段树维护这些修改即可，水平方向同理。

仔细分析一下，$1$ 变 $0$ 的操作是没有意义的。因为如果位置 $(x,y)$ 以 $c$ 颜色对棋子位置 $p$ 产生贡献，那么 $(x,y)$ 颜色改变的时候 $p$ 也一定随之改变，也就是它能产生的贡献都已经算过了。

每个修改只会生效一次，复杂度 $O(S\log S\log(n+m))$。

总复杂度 $O(S\log^2S)$。

一些细节：

1. 一类边处理完后，做二类边的时候注意不要再往一类边的方向更新答案。
2. 去重部分线段树清空的时候 root 不能暴力全清，要记录哪些位置 root 被用过单独清理这些。
3. 上一条记录位置的时候 umap 去重会因为神秘力量被卡。

处理第二类边写的非常粗糙，尤其表现在水平竖直两个方向分别写了一个函数。

去掉注释和基本复制粘贴的部分后应该是 AC 代码相对较短的（6.5k）。

花絮：这份代码包含注释后恰好 $400$ 行。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<map>
#define rz(x) x.resize(0)
#define pb(x) x.push_back(0)
#define ls(k) tr[k].ls
#define rs(k) tr[k].rs
const int fx[4]={-1,1,0,0};
const int fy[4]={0,0,-1,1};
//0 上 1 下 2 左 3 右 
using namespace std;
struct cgs{
	int x,y,tms;
};
//修改位置、时间。 
struct qz{
	int col,lv;
	int x,y;
}a[100001];
struct rc{
	int col,id;
}h[100001];
bool operator<(rc x,rc y){return x.col==y.col?x.id>y.id:x.col>y.col;}
//第三类边的去重，棋子编号及颜色 
vector<int>t[4][200001];
//位置 (x,y) 往四个方向的连边 
vector<int>f[4],cz[4];
//第 q 次询问往四方向只走 1,2 类边能到哪 
//第 q 次询问往四方向吃子是谁（没有为 0） 
vector<int>mp[4][200001];
//从 (x,y) 往四方向只走直行边最远能到哪 
vector<cgs>g[200001];
//颜色 i 从 0 变 1 的修改 
vector<int>qp[200001],qc[200001];
//棋盘棋子状态；棋盘染色状态 
int ccz[200001],clo;
//每种颜色点数；染了几种颜色 
map<int,bool>xl[200001];
//颜色 i 的相邻棋子
int n,m,q,ans[100001];
int rt[400001],cnt;
struct tree{
	int ls,rs,sum;
}tr[50000001];
namespace SGT{
	void insert(int &k,int l,int r,int x){
		if(!k)k=++cnt;
		tr[k].sum++;
		if(l==r)return;
		int mid=l+r>>1;
		if(x<=mid)insert(ls(k),l,mid,x);
		else insert(rs(k),mid+1,r,x);
	}
	void change(int k,int l,int r,int x){
		tr[k].sum--;
		if(l==r)return;
		int mid=l+r>>1;
		if(x<=mid)change(ls(k),l,mid,x);
		else change(rs(k),mid+1,r,x);
	}
	int qsum(int k,int l,int r,int x,int y){
		if(!k)return 0;
		if(l>=x&&r<=y)return tr[k].sum;
		int mid=l+r>>1,res=0;
		if(x<=mid)res+=qsum(ls(k),l,mid,x,y);
		if(mid<y)res+=qsum(rs(k),mid+1,r,x,y);
		return res;
	}
	void clr(){
		int i;
		for(i=1;i<=cnt;i++)tr[i]={0,0,0};
		for(i=0;i<=n*m*2;i++)rt[i]=0;
		cnt=0;
	}
}
using namespace SGT;
//线段树（单点加减1 区间 sum） 
namespace prework{
	char s[200002];
	void build(){
		int i,j,k;
		for(i=0;i<4;i++)rz(f[i]),rz(cz[i]);
		for(j=0;j<4;j++)for(i=0;i<=q;i++)pb(f[j]),pb(cz[j]);
		for(i=1;i<=n||i<=m;i++){
			for(j=0;j<4;j++)rz(t[j][i]),rz(mp[j][i]);
			rz(qp[i]);rz(qc[i]);
		}
		for(i=1;i<=n;i++){
			for(j=0;j<4;j++)for(k=0;k<=m;k++)pb(t[j][i]),pb(mp[j][i]);
			for(k=0;k<=m;k++)pb(qp[i]),pb(qc[i]);
		}
		clr();
		for(i=1;i<=clo;i++)rz(g[i]),xl[i].clear(),ccz[i]=0;
		for(i=1;i<=q;i++)ans[i]=0;
		clo=0;
	}
	void read(){
		int i,j;
		scanf("%d%d%d",&n,&m,&q);
		build();
		for(i=1;i<=n;i++){
			scanf("%s",s+1);
			for(j=1;j<m;j++){
				int x=s[j]-'0';
				t[2][i][j+1]=x;
				t[3][i][j]=x;
			}
		}
		for(i=1;i<n;i++){
			scanf("%s",s+1);
			for(j=1;j<=m;j++){
				int x=s[j]-'0';
				t[0][i+1][j]=x;
				t[1][i][j]=x;
			}
		}
		for(i=1;i<=q;i++)scanf("%d%d%d%d",&a[i].col,&a[i].lv,&a[i].x,&a[i].y);
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				if(t[0][i][j]==2)mp[0][i][j]=mp[0][i-1][j];
				else mp[0][i][j]=i;
				if(t[2][i][j]==2)mp[2][i][j]=mp[2][i][j-1];
				else mp[2][i][j]=j;
			}
		}
		for(i=n;i;i--){
			for(j=m;j;j--){
				if(t[1][i][j]==2)mp[1][i][j]=mp[1][i+1][j];
				else mp[1][i][j]=i;
				if(t[3][i][j]==2)mp[3][i][j]=mp[3][i][j+1];
				else mp[3][i][j]=j;
			}
		}
	}
	void init(){
		//读完后顺手把 1 类边处理了 
		read();
		int i,j,k;
		for(i=1;i<=q;i++){
			int x=a[i].x,y=a[i].y,col=a[i].col,lv=a[i].lv;
			for(j=0;j<4;j++){
				if(t[j][x][y]!=1)continue;
				int d=qp[x+fx[j]][y+fy[j]];
				int np;
				if(j<2)np=x+fx[j];
				else np=y+fy[j];
				if(!d)f[j][i]=np,ans[i]++;
				else{
					np-=fx[j]+fy[j];
					f[j][i]=np;
					if(a[d].col!=col&&a[d].lv<=lv)ans[i]++,cz[j][i]=d;
				}
			}
			qp[x][y]=i;
		}
		for(i=1;i<=n;i++)for(j=1;j<=m;j++)qp[i][j]=0;
	}
}
namespace type2{
	void solve01(){
		//竖直方向
		//这里实现的比较粗糙 
		clr();
		int i,j;
		for(i=1;i<=q;i++){
			int x=a[i].x,y=a[i].y,col=a[i].col,lv=a[i].lv;
			int l=mp[0][x][y],r=x-1,res=x;
			if(t[0][x][y]!=1){
				while(l<=r){
					int mid=l+r>>1;
					if(qsum(rt[y],1,n,mid,x))l=mid+1;
					else r=mid-1,res=mid;
				}
				ans[i]+=x-res;f[0][i]=res;
				if(res!=mp[0][x][y]){
					int d=qp[res-1][y];
					if(a[d].col!=col&&a[d].lv<=lv){
						ans[i]++;
						cz[0][i]=d;
					}
				}
			}
			if(t[1][x][y]!=1){
				l=x+1,r=mp[1][x][y],res=x;
				while(l<=r){
					int mid=l+r>>1;
					if(qsum(rt[y],1,n,x,mid))r=mid-1;
					else l=mid+1,res=mid;
				}
				ans[i]+=res-x;f[1][i]=res;
				if(res!=mp[1][x][y]){
					int d=qp[res+1][y];
					if(a[d].col!=col&&a[d].lv<=lv){
						ans[i]++;
						cz[1][i]=d;
					}
				}
			}
			insert(rt[y],1,n,x);
			qp[x][y]=i; 
		}
		for(i=1;i<=n;i++)for(j=1;j<=m;j++)qp[i][j]=0;
	}
	void solve23(){
		//水平方向
		clr();
		int i,j;
		for(i=1;i<=q;i++){
			int x=a[i].x,y=a[i].y,col=a[i].col,lv=a[i].lv;
			int l=mp[2][x][y],r=y-1,res=y;
			if(t[2][x][y]!=1){
				while(l<=r){
					int mid=l+r>>1;
					if(qsum(rt[x],1,m,mid,y))l=mid+1;
					else r=mid-1,res=mid;
				}
				ans[i]+=y-res;f[2][i]=res;
				if(res!=mp[2][x][y]){
					int d=qp[x][res-1];
					if(a[d].col!=col&&a[d].lv<=lv){
						ans[i]++;
						cz[2][i]=d;
					}
				}
			}
			l=y+1,r=mp[3][x][y],res=y;
			if(t[3][x][y]!=1){
				while(l<=r){
					int mid=l+r>>1;
					if(qsum(rt[x],1,m,y,mid))r=mid-1;
					else l=mid+1,res=mid;
				}
				ans[i]+=res-y;f[3][i]=res;
				if(res!=mp[3][x][y]){
					int d=qp[x][res+1];
					if(a[d].col!=col&&a[d].lv<=lv){
						ans[i]++;
						cz[3][i]=d;
					}
				}
			}
			insert(rt[x],1,m,y);
			qp[x][y]=i;
		}
		//不重置了，一会直接做 3 的初始染色。 
	}
	void solve2(){
		solve01();
		solve23();
		clr();
	}
}
namespace type3{
	void dfs(int x,int y,int cl,int op){
		//染色
		if(qc[x][y]==cl)return;
		//访问过 
		if(qp[x][y]){
			//遇到棋子 
			int d=qp[x][y];
			if(!xl[cl][d]){
				xl[cl][d]=1;
				insert(rt[cl+a[d].col*n*m],1,n*m,a[d].lv);
				// 1-nm 存的是白子在某颜色里 lv 前缀和 
				// nm+1-2nm 存的是黑子 
			}
			return;
		}
		g[cl].push_back({x,y,op});
		int rl=qc[x][y];
		if(rl&&ccz[rl]){
			xl[rl].clear();
			ccz[rl]=0;
		}
		qc[x][y]=cl;ccz[cl]++;
		int i;
		for(i=0;i<4;i++){
			if(t[i][x][y]!=3)continue;
			dfs(x+fx[i],y+fy[i],cl,op);
		}
	}
	void merge(int d){
		//删去 d 棋子 
		int x=a[d].x,y=a[d].y;
		int mxz=0,mxc=0,i;
		bool nw=0; 
		for(i=0;i<4;i++){
			if(t[i][x][y]!=3)continue;
			int d=qc[x+fx[i]][y+fy[i]];
			if(ccz[d]>mxz)mxz=ccz[d],mxc=d;
		}
		qp[x][y]=0;
		if(!mxc)mxc=++clo,nw=1;
		h[d]={mxc,d};
		dfs(x,y,mxc,d);
		xl[mxc][d]=0;
		if(!nw)change(rt[mxc+a[d].col*n*m],1,n*m,a[d].lv);
	}
	void bld(){
		//处理出最终图 
		int i,j;
		for(i=1;i<=q;i++)qp[a[i].x][a[i].y]=i;
		for(i=1;i<=n;i++)for(j=1;j<=m;j++)qc[i][j]=0;
		for(i=1;i<=clo;i++)ccz[i]=0,xl[i].clear();
		clo=0;
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				if(!qp[i][j]&&!qc[i][j])dfs(i,j,++clo,q+1);
			}
		}
	}
	void solve3(){
		int i,j;
		bld();
		for(i=q;i;i--){
			int x=a[i].x,y=a[i].y,col=a[i].col,lv=a[i].lv;
			merge(i);
			int lc=qc[x][y];
			ans[i]+=ccz[lc]-1;
			ans[i]+=qsum(rt[lc+(col^1)*n*m],1,n*m,1,lv);
			for(j=0;j<4;j++){
				int x=cz[j][i];
				if(!x)continue;
				if(xl[lc][x])ans[i]--;
			}
			//去重-吃子 
		}
		clr();
	}
}
namespace type4{
	//去重-行走 
	//首先排序把颜色不同的分段
	//同种颜色按时间戳从大到小处理
	//这里清线段树不能暴力的清 root 了
	//开 vector 存一下涉及到的 root 位置
	//1-n 存水平方向修改，n+1-m 存竖直方向修改 
	vector<int>bz;
	bool usd[1000001];
	void solve4(){
		int i,j,k,lst=0;
		sort(h+1,h+q+1);
		for(i=1;i<=q;i++){
			if(i!=q&&h[i].col==h[i+1].col)continue;
			int p=0,r=h[i].col;
			for(j=0;j<bz.size();j++){
				int x=bz[j];
				rt[x]=0;usd[x]=0;
			}
			for(j=1;j<=cnt;j++)tr[j]={0,0,0};
			cnt=0;
			bz.resize(0);
			for(j=lst+1;j<=i;j++){
				while(p<g[r].size()){
					cgs tt=g[r][p];
					if(tt.tms<h[j].id)break;
					p++;
					if(!usd[tt.x])usd[tt.x]=1,bz.push_back(tt.x);
					if(!usd[tt.y+n])usd[tt.y+n]=1,bz.push_back(tt.y+n);
					insert(rt[tt.x],1,m,tt.y);
					insert(rt[tt.y+n],1,n,tt.x);
				}
				int d=h[j].id;
				for(k=0;k<4;k++){
					int pl=f[k][d];
					if(k<2&&pl==a[d].x)continue;
					if(k>=2&&pl==a[d].y)continue;
					if(k==0)ans[d]-=qsum(rt[a[d].y+n],1,n,pl,a[d].x-1);
					if(k==1)ans[d]-=qsum(rt[a[d].y+n],1,n,a[d].x+1,pl);
					if(k==2)ans[d]-=qsum(rt[a[d].x],1,m,pl,a[d].y-1);
					if(k==3)ans[d]-=qsum(rt[a[d].x],1,m,a[d].y+1,pl);
				}
			}
			lst=i;
		}
	}
}
void solve(){
	int i;
	prework::init();
	type2::solve2();
	type3::solve3();
	type4::solve4();
	for(i=1;i<=q;i++)printf("%d\n",ans[i]);
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--)solve();
}
/*
1
2 2 1
3
3
31
1 1 2 2
*/
```

---

## 作者：_SeeleVollerei_ (赞：5)

昨天信誓旦旦地和 MC 说今天要做这题，结果在地铁上就会了。

普通道路太简单，直行道路大概就是往四个方向去找第一个点，然后判一下这个点就行了。这玩意可以并查集维护。

考虑互通道路是一个类似集合的东西，但是插入点的过程是一个分裂的过程，是不好做的，所以考虑离线下来反着做，变成一个加点的过程，就变成了合并。

然后就是吃子的限制了，可以对每个集合开一个数据结构存一个集合边界被哪些点堵着。因为异色所以两种颜色各开一个，然后以等级为下标，然后就是查询一个前后缀的和了。合并的时候就线段树合并即可。

考虑不同的道路之间会有重复的，普通道路直接枚举四个点看看在别的道路是否会出现即可。对于直行道路在互通道路里的重复，可以对一个集合的每一行都开一个线段树，那么直行道路的生成区间就是线段树上的一段，列同理。事实上可以将 $(x,y)$ 编号为 $(x-1)m+y$，然后把这个编号作为线段树的下标，那么行的一段就是一个区间了。列同理。

这样下来只需要维护 5 个并查集和 4 个动态开点的线段树即可。

感觉这个做法十分暴力，但是因为全是线段树所以非常好写，只是单纯的代码量比较大。

然而学校的键盘太难受了，所以回家再写吧。

upd 一个很可能出现的错误。

因为两个集合可能会共享一个边界上被吃的子，所以线段树合并**不能用加的形式，要用或的形式**。但是有一个线段树是以等级为下标的，所以这要求我们对等级重新分配，使得两两不同。具体分配方式是**以题目等级为第一关键字，以时间为第二关键字**。

放一下代码吧，感觉很丑。

```cpp
#include<cstdio>
#include<cassert>
#include<algorithm>
using namespace std;
const int N=2e5+5;
const int Z=4;
const int dx[]={-1,0,0,1},
		  dy[]={0,-1,1,0};
//dir:
//0:up 1:left 2:right 3:down
int val[N][Z];
int n,m,q;
int col[N],lv[N],tim[N];
bool flg[N];
int xx[N],yy[N];
int gx[N],gy[N];
int id[N];
inline int Read(){
	char ch;
	int f=1;
	while((ch=getchar())<'0'||ch>'9')
		if(ch=='-') f=-1;
	int x=ch^48;
	while((ch=getchar())>='0'&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
inline void print(int x){
	if(x>=10) print(x/10);
	putchar(x%10+48);
	return ;
}
inline void Print(int x,char ch='\n'){
	if(x<0){
		putchar('-');
		print(-x);
	}
	else print(x);
	putchar(ch);
	return ;
}
inline int Get(int x,int y){
	return (x-1)*m+y;
}
inline int GetR(int x,int y){
	return (x-1)*m+y;
}
inline int GetC(int x,int y){
	return x+(y-1)*n;
}
struct DSU{
	int fa[N],siz[N];
	inline void Clear(){
		for(int i=1;i<=n*m;i++){
			fa[i]=i;
			siz[i]=1;
		}
		return ;
	}
	inline int Find(int u){
		return fa[u]==u?u:fa[u]=Find(fa[u]);
	}
}stra[Z],fre;
struct SGT{
	int sum[N<<7],lc[N<<7],rc[N<<7],tot;
	int root[N];
	inline void Clear(){
		for(int i=1;i<=n*m;i++)
			root[i]=0;
		tot=0;
		return ;
	}
	inline int NewNode(){
		++tot;
		sum[tot]=0;
		lc[tot]=0;
		rc[tot]=0;
		return tot;
	}
	inline void Update(int u){
		sum[u]=sum[lc[u]]+sum[rc[u]];
	}
	inline void Change(int&u,int ll,int rr,int p,int value){
		if(!u) u=NewNode();
		if(ll==rr){
			sum[u]+=value;
			return ;
		}
		int mid=ll+rr>>1;
		if(mid>=p) Change(lc[u],ll,mid,p,value);
		else Change(rc[u],mid+1,rr,p,value);
		return Update(u);
	}
	inline int Query(int u,int ll,int rr,int ql,int qr){
		if(!u) return 0;
		if(ll>=ql&&rr<=qr) return sum[u];
		int mid=ll+rr>>1,ss=0;
		if(mid>=ql) ss+=Query(lc[u],ll,mid,ql,qr);
		if(mid<qr) ss+=Query(rc[u],mid+1,rr,ql,qr);
		return ss;
	}
	inline int Merge(int u,int v,int ll,int rr){
		if(!u||!v) return u+v;
		int uu=NewNode();
		if(ll==rr) sum[uu]=sum[u]||sum[v];
		else{
			int mid=ll+rr>>1;
			lc[uu]=Merge(lc[u],lc[v],ll,mid);
			rc[uu]=Merge(rc[u],rc[v],mid+1,rr);
			Update(uu);
		}
		return uu;
	}
}str[2],fr[2];
//edge:
//0:none 1:only one 2:straight 3:fre
inline int Del(int ux,int uy){
	//printf("del ux=%d uy=%d\n",ux,uy);
	int u=Get(ux,uy);
	int ur=GetR(ux,uy),uc=GetC(ux,uy);
	for(int i=0;i<Z;i++){
		int vx=ux+dx[i],vy=uy+dy[i];
		if(vx<1||vx>n||vy<1||vy>m) continue ;
		int v=Get(vx,vy);
		int vr=GetR(vx,vy),vc=GetC(vx,vy);
		if(val[u][i]<=1) continue ;
		if(val[u][i]==2){
			stra[i].fa[u]=v;
			if(lv[v]) continue ;
			stra[3-i].fa[v]=u;
			continue ;
		}
		if(lv[v]){
			if(str[0].Query(str[0].root[u],1,n*m,v,v)) continue ;
			//printf("u=%d v=%d lv=%d\n",u,v,lv[v]);
			fr[col[v]].Change(fr[col[v]].root[u],1,n*m,lv[v],1);
			str[0].Change(str[0].root[u],1,n*m,vr,1);
			str[1].Change(str[1].root[u],1,n*m,vc,1);
			continue ;
		}
		int fv=fre.Find(v);
		if(u==fv) continue ;
		fre.fa[fv]=u;
		fre.siz[u]+=fre.siz[fv];
		fr[col[u]].Change(fr[col[u]].root[fv],1,n*m,lv[u],-1);
		str[0].Change(str[0].root[fv],1,n*m,ur,-1);
		str[1].Change(str[1].root[fv],1,n*m,uc,-1);
		fr[0].root[u]=fr[0].Merge(fr[0].root[u],fr[0].root[fv],1,n*m);
		fr[1].root[u]=fr[1].Merge(fr[1].root[u],fr[1].root[fv],1,n*m);
		str[0].root[u]=str[0].Merge(str[0].root[u],str[0].root[fv],1,n*m);
		str[1].root[u]=str[1].Merge(str[1].root[u],str[1].root[fv],1,n*m);
	}
	str[0].Change(str[0].root[u],1,n*m,ur,1);
	str[1].Change(str[1].root[u],1,n*m,uc,1);
	/*for(int i=1;i<=n*m;i++){
		assert(str[0].Query(str[0].root[u],1,n*m,i,i)<=1);
		assert(str[1].Query(str[1].root[u],1,n*m,i,i)<=1);
	}*/
	//puts("del finish");
	int ss=0;
	ss+=fre.siz[u]-1;
	assert(fre.Find(u)==u);
	//printf("after free ans=%d\n",ss);
	ss+=fr[col[u]^1].Query(fr[col[u]^1].root[u],1,n*m,1,lv[u]);
	//printf("after free eat ans=%d\n",ss);
	int vx,vy,v;
	v=stra[0].Find(u);
	vx=gx[v],vy=gy[v];
	//printf("up vx=%d vy=%d\n",vx,vy);
	if(v!=u){
		int vc=GetC(vx,vy);
		ss+=uc-vc;
		if(vc+1<=uc-1) ss-=str[1].Query(str[1].root[u],1,n*m,vc+1,uc-1);
		if((lv[v]&&col[u]==col[v])||lv[v]>lv[u]) ss--;
		else ss-=str[1].Query(str[1].root[u],1,n*m,vc,vc);
	}
	//printf("after up ans=%d\n",ss);
	v=stra[1].Find(u);
	vx=gx[v],vy=gy[v];
	//printf("left vx=%d vy=%d\n",vx,vy);
	if(v!=u){
		int vr=GetR(vx,vy);
		//printf("vr=%d ur=%d\n",vr,ur);
		ss+=ur-vr;
		//printf("now ans=%d\n",ss);
		if(vr+1<=ur-1) ss-=str[0].Query(str[0].root[u],1,n*m,vr+1,ur-1);
		//printf("after query ans=%d\n",ss);
		if((lv[v]&&col[u]==col[v])||lv[v]>lv[u]) ss--;
		else ss-=str[0].Query(str[0].root[u],1,n*m,vr,vr);
	}
	//printf("after left ans=%d\n",ss);
	v=stra[2].Find(u);
	vx=gx[v],vy=gy[v];
	//printf("right vx=%d vy=%d\n",vx,vy);
	if(v!=u){
		int vr=GetR(vx,vy);
		ss+=vr-ur;
		if(ur+1<=vr-1) ss-=str[0].Query(str[0].root[u],1,n*m,ur+1,vr-1);
		if((lv[v]&&col[u]==col[v])||lv[v]>lv[u]) ss--;
		else ss-=str[0].Query(str[0].root[u],1,n*m,vr,vr);
	}
	//printf("after right ans=%d\n",ss);
	v=stra[3].Find(u);
	vx=gx[v],vy=gy[v];
	//printf("down vx=%d vy=%d\n",vx,vy);
	if(v!=u){
		int vc=GetC(vx,vy);
		ss+=vc-uc;
		if(uc+1<=vc-1) ss-=str[1].Query(str[1].root[u],1,n*m,uc+1,vc-1);
		if((lv[v]&&col[u]==col[v])||lv[v]>lv[u]) ss--;
		else ss-=str[1].Query(str[1].root[u],1,n*m,vc,vc);
	}
	//printf("after down ans=%d\n",ss);
	for(int i=0;i<Z;i++){
		vx=ux+dx[i],vy=uy+dy[i];
		if(vx<1||vx>n||vy<1||vy>m) continue ;
		if(val[u][i]!=1) continue ;
		v=Get(vx,vy);
		if((lv[v]&&col[v]==col[u])||lv[v]>lv[u]) continue ;
		if(!str[0].Query(str[0].root[u],1,n*m,v,v)) ss++;
	}
	//puts("get ans finish");
	//printf("ans=%d\n",ss);
	lv[u]=0;
	return ss;
}
inline bool Cmp(int x,int y){
	return lv[x]<lv[y]||(lv[x]==lv[y]&&tim[x]<tim[y]);
}
inline void Init(){
	n=Read(),m=Read();
	q=Read();
	str[0].Clear(),str[1].Clear();
	fr[0].Clear(),fr[1].Clear();
	stra[0].Clear(),stra[1].Clear(),stra[2].Clear(),stra[3].Clear();
	fre.Clear();
	for(int x=1;x<=n;x++)
		for(int y=1;y<=m;y++){
			int u=Get(x,y);
			gx[u]=x,gy[u]=y;
			lv[u]=1,flg[u]=0;
			tim[u]=0;
			id[u]=u;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<m;j++){
			char ch;
			while((ch=getchar())<'0'||ch>'9');
			int u=Get(i,j);
			val[u][2]=val[u+1][1]=ch-'0';
		}
	for(int i=1;i<n;i++)
		for(int j=1;j<=m;j++){
			char ch;
			while((ch=getchar())<'0'||ch>'9');
			int u=Get(i,j);
			val[u][3]=val[u+m][0]=ch-'0';
		}
	for(int i=1;i<=q;i++){
		int co=Read(),lvv=Read();
		xx[i]=Read();
		yy[i]=Read();
		int u=Get(xx[i],yy[i]);
		tim[u]=i;
		col[u]=co,lv[u]=lvv;
		flg[u]=1;
	}
	sort(id+1,id+n*m+1,Cmp);
	for(int i=1;i<=n*m;i++)
		lv[id[i]]=i;
	for(int x=1;x<=n;x++)
		for(int y=1;y<=m;y++)
			if(!flg[Get(x,y)]) Del(x,y);
	//puts("init finish");
	return ;
}
int qans[N];
inline void Solve(){
	for(int i=q;i;i--)
		qans[i]=Del(xx[i],yy[i]);
	for(int i=1;i<=q;i++)
		Print(qans[i]);
	return ;
}
int T;
int main(){
	//freopen("chess4.in","r",stdin);
	//freopen("chess.out","w",stdout);
	for(T=Read();T;T--){
		Init();
		Solve();
	}
	return 0;
}
```

---

## 作者：HBWH_zzz (赞：5)

# P7963 [NOIP2021] 棋局

给定 $n\times m$ 的棋盘，连有横纵 $2$ 种无向边，有 $3$ 种类型的边：

1. 只允许按照这条边走 $1$ 步
2. 允许继续走边权为 $2$ 的边，但不允许改变方向
3. 允许继续走边权为 $3$ 的边，可以改变方向

走到不同颜色等级 $\leq$ 自己等级的棋子时可以吃掉棋子并停下，求先后放下 $q$ 个棋子时每个棋子最多能走到的位置。

$n\times m \leq 2\times 10^5,q\leq 10^5$

------

感谢[这篇博客](https://www.luogu.com.cn/blog/user45775/solution-p7963)让我 $2$ 天做懂了这道神仙题。（写下这篇题解也算是对于 TA 的题解进行补充）

首先肯定会想到维护棋盘上格子的连通性，可以将所有 $2$ 号道路连成的连续一条（行/列）维护在同一并查集内（所以需要 $2$ 个并查集），将所有 $3$ 号道路连成的连通块维护在同一并查集内。然而问题是放上棋子的过程就是断开连通性的过程，实在难以维护，想到的对策是离线所有询问，然后从后往前扫一遍，一边将连通性还原，一边统计答案。

吃子呢？首先 $1,2$ 号道路好想，只用判断道路末端是否有棋子，若有则判断能否吃掉，如果能吃掉就计入答案。 $3$ 号道路需要用一个数据结构来维护道路可抵达的所有棋子等级（其实是 $2$ 个，分别维护 $2$ 种颜色），然后查询某一连通块内指定颜色的比查询棋子等级小的元素个数（代码中的 $query1$ ）。因为是维护每个并查集，所以还要涉及到合并操作，所以这里选择动态开点权值线段树的合并。

但是仅仅这样统计答案是不行的，比如

![](https://cdn.luogu.com.cn/upload/image_hosting/wzvsjen8.png)

那么 $1$ 号点就会被算 $2$ 次。（既在 $3$ 号并查集内，又在 $2$ 号横向并查集内）

既然有重复的，那么就判重。利用 $2$ 号边构成并查集内元素的连续性，可以在并查集中额外加入 $maxn,minn$ 来得到这一段区间的最大值最小值，然后再额外创建 $2$ 个线段树来维护横/竖的元素个数，然后可以通过查询区间和来得到被算重的元素个数（实际实现时通过前面提到的查询前缀函数 $query1(r)-query1(l-1)$ 来实现区间和)。

然后是吃子的问题，所有的 $1,2$ 道路的吃子都需要查询是否在 $3$ 道路的吃子中，然而仅凭借等级是无法确定唯一棋子的，所以需要采取一种高级的离散化方法，让所有棋子的等级全部不同而不改变比大小的原则。具体的，让不同等级的棋子依然按照原顺序，而相同等级的棋子按照输入的先后顺序排序，这样之前的棋子就会比之后的棋子小，依然满足比大小的原则，而离散化之后可以通过唯一的等级确定某一棋子是否在线段树内。

最后是一些细节，比如通过用 $e[i][j]$ 表示标号为 $j$ 的棋子在 $i$ 方向上的边权，用 $val[i]$ 来记录 $i$ 标号上的点是否有棋子，若有则为输入的顺序，线段树插入时多带一个 $flag$ ，为 $1$ 是插入，为 $-1$ 是删除，还有一些都写在注释里了（震惊，我还会写注释）。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mp std::make_pair
#define pii std::pair<int,int>
#define chkmin(_A,_B) (_A=std::min(_A,_B))
#define chkmax(_A,_B) (_A=std::max(_A,_B))

int t,n,m;
int e[4][200005],ans[100005],val[200005];
//val用来存储每个点是否有棋子，若有则val[i]表示位置上的点在棋盘上被放上去的顺序（输入的顺序）
//e[i][j]表示编号j的棋子在i方向上的边的权值
int dx[4]={-1,0,1,0};
int dy[4]={0,-1,0,1};
char s[200005];
struct chess{
    int col,lv,x,y,id;
}a[100005];
inline bool cmp_lv(const chess &A,const chess &B){return (A.lv==B.lv)?(A.id<B.id):(A.lv<B.lv);}
//等级相同按照来到棋盘上的顺序排序，可以实现相同等级来到棋盘早的可以被来到棋盘晚的吃到
inline bool cmp_id(const chess &A,const chess &B){return A.id<B.id;}
inline int pos1(int x,int y){return (x-1)*m+y;}
inline int pos2(int x,int y){return (y-1)*n+x;}
inline pii getxy(int pos)   {return mp((pos-1)/m+1,(pos-1)%m+1);}
void merge_All_ST(int,int);
//--------------------DSU--------------------//
struct DSU{
    int f[200005],sz[200005],maxn[200005],minn[200005];
    //maxn和minn用于处理同一并查集内元素的最大编号和最小编号
    int getfa(const int &x){
        return (f[x]==x)?x:f[x]=getfa(f[x]);
    }
    inline void merge(int x,int y,int flag=0){
        x=getfa(x),y=getfa(y);
        if(x==y)
            return;
        if(sz[x]<=sz[y])
            std::swap(x,y);
        sz[x]+=sz[y];
        f[y]=x;
        chkmax(maxn[x],maxn[y]);
        chkmin(minn[x],minn[y]);
        if(flag)
            merge_All_ST(x,y);
    }
    inline void init(const int &p){
        for(int i=0;i<=p;++i){
            f[i]=maxn[i]=minn[i]=i;
            sz[i]=1;
        }
    }
    inline int getmaxn(const int &x){return maxn[getfa(x)];}
    inline int getminn(const int &x){return minn[getfa(x)];}
    inline int getsize(const int &x){return sz[getfa(x)];}
}dsu[3];
//dsu[0]用来处理类型为3的道路，dsu[1/2]用来处理横竖两个方向的合并情况

//--------------------SegmentTree--------------------//
struct SegmentTree{
    struct node{
        int ls,rs,sz;
    }nd[8000005];
    int root[200005],ncnt;
    #define ls(_p) (nd[_p].ls)
    #define rs(_p) (nd[_p].rs)
    void init(){
        memset(root,0,sizeof root);
        for(int i=0;i<=8000000;++i){
            nd[i].ls=nd[i].rs=nd[i].sz=0;
        }
        ncnt=0;
    }
    int ins(int p,const int &l,const int &r,const int &x,const int &flag=1){
        //flag=1,添加;flag=-1,删除
        if(p==0)
            p=++ncnt;
        if(l==r){
            if(flag==-1)
                return 0;
            if(nd[p].sz==0)
                nd[p].sz++;
            return p;
        }
        int mid=(l+r)>>1;
        if(x<=mid)
            ls(p)=ins(ls(p),l,mid,x,flag);
        else
            rs(p)=ins(rs(p),mid+1,r,x,flag);
        nd[p].sz=nd[ls(p)].sz+nd[rs(p)].sz;
        return (nd[p].sz)?p:0;
    }
    int merge(const int &p,const int &q,const int &l,const int &r){
        if(p==0 || q==0)
            return p+q;
        if(l==r){
            nd[p].sz=std::min(nd[p].sz+nd[q].sz,1);
            return p;
        }
        int mid=(l+r)>>1;
        ls(p)=merge(ls(p),ls(q),l,mid);
        rs(p)=merge(rs(p),rs(q),mid+1,r);
        nd[p].sz=nd[ls(p)].sz+nd[rs(p)].sz;
        return p;
    }
    int query1(const int &p,const int &l,const int &r,const int &x){
        //查询小于等于某一元素的元素个数
        if(p==0 || x==0)
            return 0;
        if(l==r)
            return nd[p].sz;
        int mid=(l+r)>>1;
        if(x<=mid)
            return query1(ls(p),l,mid,x);
        else
            return nd[ls(p)].sz+query1(rs(p),mid+1,r,x);
    }
    int query2(const int &p,const int &l,const int &r,const int &x){
        //查询某一元素是否在并查集内
        if(p==0 || x==0)
            return 0;
        if(l==r)
            return nd[p].sz;
        int mid=(l+r)>>1;
        if(x<=mid)
            return query2(ls(p),l,mid,x);
        else
            return query2(rs(p),mid+1,r,x);
    }
    int querynum(const int &p,const int &l,const int &r){
        //查询[l,r]内在这一并查集内的元素个数
        return query1(root[p],1,n*m,r)-query1(root[p],1,n*m,l-1);
    }
}st[4];
//st[0/1]存储等级，st[2/3]存储行/列中的元素个数
int q;
void merge_All_ST(int x,int y){
    //将x,y并查集对应的线段树进行合并（并查集是y合并到x，所以线段树也是y合并到x）
    st[0].root[x]=st[0].merge(st[0].root[x],st[0].root[y],1,q);
    st[1].root[x]=st[1].merge(st[1].root[x],st[1].root[y],1,q);
    st[2].root[x]=st[2].merge(st[2].root[x],st[2].root[y],1,n*m);
    st[3].root[x]=st[3].merge(st[3].root[x],st[3].root[y],1,n*m);
}

inline bool caneat(const int &x,const int &y){
    if(y==0 || y>=x)
        return 0;
    return (a[x].col!=a[y].col && a[x].lv>=a[y].lv);
}

int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d %d %d",&n,&m,&q);
        memset(e,0,sizeof e);
        memset(val,0,sizeof val);
        memset(ans,0,sizeof ans);
        dsu[0].init(n*m);
        dsu[1].init(n*m);
        dsu[2].init(n*m);
        st[0].init();
        st[1].init();
        st[2].init();
        st[3].init();
        for(int i=1;i<=n;++i){
            scanf("%s",s+1);
            for(int j=1;j<m;++j)
                e[1][pos1(i,j+1)]=e[3][pos1(i,j)]=s[j]-'0';
        }
        for(int i=1;i<n;++i){
            scanf("%s",s+1);
            for(int j=1;j<=m;++j)
                e[0][pos1(i+1,j)]=e[2][pos1(i,j)]=s[j]-'0';
        }
        for(int i=1;i<=q;++i){
			scanf("%d %d %d %d",&a[i].col,&a[i].lv,&a[i].x,&a[i].y);
			a[i].id=i;
		}
        std::sort(a+1,a+q+1,cmp_lv);
        for(int i=1;i<=q;++i)
            a[i].lv=i;
        std::sort(a+1,a+q+1,cmp_id);
        for(int i=1;i<=q;++i)
            val[pos1(a[i].x,a[i].y)]=i;   
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                //先将同一连通块上的并查集维护，再维护线段树信息，可以省去合并线段树的复杂度
                int id=pos1(i,j);
                for(int k=0;k<4;++k){
                    if(e[k][id]>1){
                        int nxt=pos1(i+dx[k],j+dy[k]);
                        if(val[id]==0 && val[nxt]==0){
                            dsu[(e[k][id]==3)?0:(k%2+1)].merge(id,nxt);
                        }
                    }
                }
            }
        }
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                //维护线段树信息，包括自己所在的行列和可以到达的棋子的等级
                int id=pos1(i,j);
                int idfa=dsu[0].getfa(id);
                st[2].root[idfa]=st[2].ins(st[2].root[idfa],1,n*m,pos2(i,j));
                st[3].root[idfa]=st[3].ins(st[3].root[idfa],1,n*m,id);
                for(int k=0;k<4;++k){
                    if(e[k][id]==3){
                        int nxt=pos1(i+dx[k],j+dy[k]);
                        if(val[nxt]){
                            int col=a[val[nxt]].col;
                            st[col].root[idfa]=st[col].ins(st[col].root[idfa],1,q,a[val[nxt]].lv);
                        }
                    }
                }
            }
        }
        for(int i=q;i>=1;--i){
            int id=pos1(a[i].x,a[i].y);
            int col=a[i].col;
            for(int j=0;j<4;++j){
                //处理边权为3的线段树，把棋子自身删除
                if(e[j][id]==3){
                    int nxt=pos1(a[i].x+dx[j],a[i].y+dy[j]);
                    int nxtfa=dsu[0].getfa(nxt);
                    st[col].root[nxtfa]=st[col].ins(st[col].root[nxtfa],1,q,a[i].lv,-1);
                }
            }
            for(int j=0;j<4;++j){
                //合并边权为3的所有并查集，同时合并线段树
                if(e[j][id]==3){
                    int nxt=pos1(a[i].x+dx[j],a[i].y+dy[j]);
                    if(val[nxt] && val[nxt]<i)
                        continue;
                        //若出现还没有被删除的棋子，直接跳过
                    dsu[0].merge(id,nxt,1);
                }
            }
            int idfa=dsu[0].getfa(id);
            //首先将并查集内的所有确定点加入ans，再将所有边界上颜色不同级别更小的棋子加入
            ans[i]=dsu[0].getsize(id)+st[1^col].query1(st[1^col].root[idfa],1,q,a[i].lv);
            for(int j=0;j<4;++j){
                //合并边权为2的并查集
                if(e[j][id]==2){
                    int nxt=pos1(a[i].x+dx[j],a[i].y+dy[j]);
                    if(val[nxt] && val[nxt]<i)
                        continue;
                        //若出现还没有被删除的棋子，直接跳过
                    dsu[j%2+1].merge(id,nxt);
                }
            } 
            //计算边权为2的贡献，由于编号的影响同一列上的元素并不连续，所以要除以m
            int mx1=dsu[1].getmaxn(id),mx2=dsu[2].getmaxn(id),mn1=dsu[1].getminn(id),mn2=dsu[2].getminn(id);
            ans[i]+=mx2-mn2+1+(mx1-mn1)/m+1;
            int dmx=pos2(getxy(mx1).first,getxy(mx1).second);
            int dmn=pos2(getxy(mn1).first,getxy(mn1).second);
            //将2，3重复的部分删除（将2中的行/列放到3中的并查集内找）
            ans[i]-=st[2].querynum(idfa,dmn,dmx)+st[3].querynum(idfa,mn2,mx2);
            //特殊处理2的边界,若可以吃子且没有被3的边界包含进去就计入答案
            if(e[0][mn1]==2 && caneat(i,val[mn1-m]))
                if(!st[1^col].query2(st[1^col].root[idfa],1,q,a[val[mn1-m]].lv))
                    ++ans[i];
            if(e[1][mn2]==2 && caneat(i,val[mn2-1]))
                if(!st[1^col].query2(st[1^col].root[idfa],1,q,a[val[mn2-1]].lv))
                    ++ans[i];
            if(e[2][mx1]==2 && caneat(i,val[mx1+m]))
                if(!st[1^col].query2(st[1^col].root[idfa],1,q,a[val[mx1+m]].lv))
                    ++ans[i];
            if(e[3][mx2]==2 && caneat(i,val[mx2+1]))
                if(!st[1^col].query2(st[1^col].root[idfa],1,q,a[val[mx2+1]].lv))
                    ++ans[i];
            //处理边权为1的边
            for(int j=0;j<4;++j){
                if(e[j][id]==1){
                    int nxt=pos1(a[i].x+dx[j],a[i].y+dy[j]);
                    //若有棋子判断是否能吃，然后都要判断是否被包含
                    if(val[nxt] && val[nxt]<i){
                        if(caneat(i,val[nxt]) && (st[1^col].query2(st[1^col].root[idfa],1,q,a[val[nxt]].lv)==0))
                            ++ans[i];
                    }
                    else if(dsu[0].getfa(id)!=dsu[0].getfa(nxt)){
                        ans[i]=ans[i]+1;
                    }
                    
                }
            }
            //在计算边权为2时自己多算了1次，减掉
            --ans[i];
        }
        for(int k=1;k<=q;++k){
            printf("%d\n",ans[k]);
        }
    }
    return 0;
}
```

---

## 作者：AK_400 (赞：3)

感谢机房大佬 [Segtree](https://www.luogu.com.cn/user/678965) 教我这个题。

首先说一下存点，因为行列都很大，于是我们不能开二维数组，我们写一个编号函数，对每个位置编号。

```cpp

int id(int x,int y){
    return (x-1)*m+y;
}
```

## 8pts(7-8)
只有一类边，暴力判即可。
## 12pts(9-11)
你发现分裂很烦，于是我们把操作离线下来，变成从后往前删棋子，合并连通块，行列各一个并查集即可，注意对每个连通块维护编号最大和最小用于维护吃子。因为一类边和二类边都不能拐弯，于是不用去重。

## 12pts(12-14)



同理，对三类边维护并查集，但是你发现可能和一类边重复，于是我们在一类边判吃子时加上不能被 $p$ 通过三类边吃到。

问题又来了，怎么处理吃子？

你发现可吃的子的等级在区间 $[1,lv]$ 中（其中 $lv$ 表示当前棋子的等级），于是我们对每个连通块开两棵线段树维护每个等级与这个连通块连通的黑棋与白棋各有几个，连通块合并时把线段树也合并即可。

可这样会出现一个问题：对于这种情况，![](https://cdn.luogu.com.cn/upload/image_hosting/u101qc77.png)删除左下角的棋子时会导致右上角的棋子被计算两次，怎么办?

我们发现先加入的棋子不能吃后加入的棋子，于是我们把等级离散化，使得等级相等时，先加入的棋子的等级小于后加入的棋子的等级，线段树合并时对叶子取 $\max$，其余节点正常维护即可。
## 8pts(17-18)
没有吃子，但是需要对二类边和三类边去重。

然后我们需要查询可通过二类边走到的点中可通过三类边走到点的个数。

你发现对于横向的二类边，可走到的点的编号是连续的，于是我们可以上线段树维护连通块中编号区间的点的个数。
但是纵向的不是，于是我们写一个以列为第一关键字的编号函数即可。
## 100pts
把以上这些部分分合起来。再把二类边的吃子加上不能被当前棋子通过三类边吃到即可。
## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
void read(int&x) {
	x=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return;
}
void print(int x,char c='\n') {
	int stk[10],top=0;
	if(x==0) {
		putchar('0');
		putchar(c);
		return;
	}
	while(x)stk[++top]=x%10,x/=10;
	while(top)putchar(stk[top--]^48);
	putchar(c);
	return;
}
int n,m;
struct segtree {//线段树 
	int rt[200005],ls[20000000],rs[20000000],sum[20000000],tot;
#define mid (l+r>>1)
	void pu(int p) {
		sum[p]=0;
		if(ls[p])sum[p]+=sum[ls[p]];
		if(rs[p])sum[p]+=sum[rs[p]];
	} int insert(int l,int r,int x,int p) {
		if(!p)p=++tot;
		if(l==r) {
			sum[p]=1;
			return p;
		}
		if(x<=mid)ls[p]=insert(l,mid,x,ls[p]);
		else rs[p]=insert(mid+1,r,x,rs[p]);
		pu(p);
		return p;
	} void erase(int l,int r,int x,int p) {
		if(sum[p]==0)return;
		if(l==r) {
			sum[p]=0;
			return;
		}
		if(x<=mid)erase(l,mid,x,ls[p]);
		else erase(mid+1,r,x,rs[p]);
		pu(p);
		return;
	} int qu(int l,int r,int ml,int mr,int p) {
		if(!p)return 0;
		if(ml<=l&&r<=mr)return sum[p];
		int res=0;
		if(ml<=mid)res+=qu(l,mid,ml,mr,ls[p]);
		if(mid+1<=mr)res+=qu(mid+1,r,ml,mr,rs[p]);
		return res;
	} int mg(int l,int r,int x,int y) {
		if(!x&&!y)return 0;
		if(!x)return y;
		if(!y)return x;
		if(l==r) {
			sum[x]=max(sum[x],sum[y]);
			return x;
		}
		if(!sum[x]&&!sum[y])return 0;
		if(!sum[x])return y;
		if(!sum[y])return x;
		ls[x]=mg(l,mid,ls[x],ls[y]);
		rs[x]=mg(mid+1,r,rs[x],rs[y]);
		pu(x);
		return x;
	} void print(int l,int r,int p) {
		if(l==r&&r<=3)cout<<l<<" "<<r<<" "<<sum[p]<<endl;
		if(l==r)return;
		print(l,mid,ls[p]);
		print(mid+1,r,rs[p]);
		return;
	}
#undef mid
	void init() {
		for(int i=1; i<=n*m; i++)rt[i]=0;
		for(int i=1; i<=tot; i++)sum[i]=ls[i]=rs[i]=0;
		tot=0;
	}
} B,W,CT,LT;//黑色，白色，列，行 
struct dsu {//并查集 
	int fa[200005],sz[200005],mx[200005],mn[200005];
	int getrt(int x) {
		return fa[x]==x?x:(fa[x]=getrt(fa[x]));
	} void mg(int x,int y) {
		if(getrt(x)==getrt(y))return;
		x=getrt(x),y=getrt(y);
		mx[x]=max(mx[x],mx[y]);
		mn[x]=min(mn[x],mn[y]);
		sz[x]+=sz[y];
		fa[y]=x;
		return;
	} bool chk(int x,int y) {
		return getrt(x)==getrt(y);
	} void init() {
		for(int i=1; i<=n*m; i++) {
			fa[i]=i;
			mx[i]=i;
			mn[i]=i;
			sz[i]=1;
		}
	} int getsz(int x) {
		return sz[getrt(x)];
	} int getmn(int x) {
		return mn[getrt(x)];
	} int getmx(int x) {
		return mx[getrt(x)];
	}
} L,C,rd3;//行，列，三类边 
int id(int x,int y) {//以行为第一关键字的编号 
	return(x-1)*m+y;
}
int idc(int x,int y) {//以列为第一关键字的编号
	return x+(y-1)*n;
}
int ctid(int p) {//计算idc对应的id。
	int x=p%n?p%n:n;
	int y=(p-x)/n+1;
	return id(x,y);
}
int q;
int road[200005][4];//0表示上，1表示下，2表示左，3表示右。
struct node {
	int col,lv,x,y;
} nd[100005];
int ndid[200005];
void lsh() {//离散化。
	pair<int,int>a[100005];
	for(int i=1; i<=q; i++) {
		a[i]= {nd[i].lv,i};
	}
	sort(a+1,a+1+q);
	for(int i=1; i<=q; i++) {
		nd[i].lv=lower_bound(a+1,a+1+q,make_pair(nd[i].lv,i))-a;
	}
}
bool canatk(int x,int y) {//判断可否吃子。 
	if(!x||!y)return 1;
	if(nd[x].col==0&&W.qu(1,2e5,nd[y].lv,nd[y].lv,W.rt[rd3.getrt(id(nd[x].x,nd[x].y))])) {
		return 0;
	}
	if(nd[x].col&&B.qu(1,2e5,nd[y].lv,nd[y].lv,B.rt[rd3.getrt(id(nd[x].x,nd[x].y))])) {
		return 0;
	}
	if(nd[x].col==nd[y].col)return 0;
	if(nd[x].lv<nd[y].lv)return 0;
	return 1;
}
int res[100005];
void mgsegcol(int x,int y) {//线段树合并颜色。 
	if(rd3.getrt(x)==rd3.getrt(y))return;
	B.rt[rd3.getrt(x)]=B.mg(1,2e5,B.rt[rd3.getrt(x)],B.rt[rd3.getrt(y)]);
	W.rt[rd3.getrt(x)]=W.mg(1,2e5,W.rt[rd3.getrt(x)],W.rt[rd3.getrt(y)]);
}
void mgsegc(int x,int y) {//线段树合并列。
	if(rd3.getrt(x)==rd3.getrt(y))return;
	CT.rt[rd3.getrt(x)]=CT.mg(1,2e5,CT.rt[rd3.getrt(x)],CT.rt[rd3.getrt(y)]);
}
void mgsegl(int x,int y) {//线段树合并行。
	if(rd3.getrt(x)==rd3.getrt(y))return;
	LT.rt[rd3.getrt(x)]=LT.mg(1,2e5,LT.rt[rd3.getrt(x)],LT.rt[rd3.getrt(y)]);
}
void op(int p) {
	int x=nd[p].x,y=nd[p].y;
	if(x>1&&road[id(x,y)][0]==2&&!ndid[id(x-1,y)]) {//合并。
		C.mg(idc(x-1,y),idc(x,y));
	}
	if(x>1&&road[id(x,y)][0]==3) {
		if(!ndid[id(x-1,y)]) {
			mgsegcol(id(x,y),id(x-1,y));
			mgsegc(id(x,y),id(x-1,y));
			mgsegl(id(x,y),id(x-1,y));
			rd3.mg(id(x,y),id(x-1,y));
		} else {
			int idn=ndid[id(x-1,y)];
			if(nd[idn].col)W.rt[rd3.getrt(id(x,y))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(x,y))]);
			else B.rt[rd3.getrt(id(x,y))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(x,y))]);
		}
	}
	if(y>1&&road[id(x,y)][2]==2&&!ndid[id(x,y-1)]) {
		L.mg(id(x,y),id(x,y-1));
	}
	if(y>1&&road[id(x,y)][2]==3) {
		if(!ndid[id(x,y-1)]) {
			mgsegcol(id(x,y),id(x,y-1));
			mgsegc(id(x,y),id(x,y-1));
			mgsegl(id(x,y),id(x,y-1));
			rd3.mg(id(x,y),id(x,y-1));
		} else {
			int idn=ndid[id(x,y-1)];
			if(nd[idn].col)W.rt[rd3.getrt(id(x,y))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(x,y))]);
			else B.rt[rd3.getrt(id(x,y))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(x,y))]);
		}
	}
	if(x<n&&road[id(x,y)][1]==2&&!ndid[id(x+1,y)]) {
		C.mg(idc(x+1,y),idc(x,y));
	}
	if(x<n&&road[id(x,y)][1]==3) {
		if(!ndid[id(x+1,y)]) {
			mgsegcol(id(x,y),id(x+1,y));
			mgsegc(id(x,y),id(x+1,y));
			mgsegl(id(x,y),id(x+1,y));
			rd3.mg(id(x,y),id(x+1,y));
		} else {
			int idn=ndid[id(x+1,y)];
			if(nd[idn].col)W.rt[rd3.getrt(id(x,y))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(x,y))]);
			else B.rt[rd3.getrt(id(x,y))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(x,y))]);
		}
	}
	if(y<m&&road[id(x,y)][3]==2&&!ndid[id(x,y+1)]) {
		L.mg(id(x,y),id(x,y+1));
	}
	if(y<m&&road[id(x,y)][3]==3) {
		if(!ndid[id(x,y+1)]) {
			mgsegcol(id(x,y),id(x,y+1));
			mgsegc(id(x,y),id(x,y+1));
			mgsegl(id(x,y),id(x,y+1));
			rd3.mg(id(x,y),id(x,y+1));
		} else {
			int idn=ndid[id(x,y+1)];
			if(nd[idn].col)W.rt[rd3.getrt(id(x,y))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(x,y))]);
			else B.rt[rd3.getrt(id(x,y))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(x,y))]);
		}
	}
	W.erase(1,2e5,nd[p].lv,W.rt[rd3.getrt(id(x,y))]);
	B.erase(1,2e5,nd[p].lv,B.rt[rd3.getrt(id(x,y))]);
	ndid[id(nd[p].x,nd[p].y)]=0;
	int ans=0;
	if(x>1&&road[id(x,y)][0]==1&&canatk(p,ndid[id(x-1,y)])&&!rd3.chk(id(x,y),id(x-1,y)))ans++;//判一类边。 
	if(x<n&&road[id(x,y)][1]==1&&canatk(p,ndid[id(x+1,y)])&&!rd3.chk(id(x,y),id(x+1,y)))ans++;
	if(y>1&&road[id(x,y)][2]==1&&canatk(p,ndid[id(x,y-1)])&&!rd3.chk(id(x,y),id(x,y-1)))ans++;
	if(y<m&&road[id(x,y)][3]==1&&canatk(p,ndid[id(x,y+1)])&&!rd3.chk(id(x,y),id(x,y+1)))ans++;
	ans+=L.getsz(id(x,y));//二类边。
	int lmx=L.getmx(id(x,y));
	int lmn=L.getmn(id(x,y));
	if(lmx%m!=0&&ndid[lmx+1]&&canatk(p,ndid[lmx+1])&&road[lmx][3]==2)ans++;
	if(lmn%m!=1&&ndid[lmn-1]&&canatk(p,ndid[lmn-1])&&road[lmn][2]==2)ans++;
	ans+=C.getsz(idc(x,y));
	int cmx=C.getmx(idc(x,y));
	int cmn=C.getmn(idc(x,y));
	if(ndid[ctid(cmx+1)]&&canatk(p,ndid[ctid(cmx+1)])&&road[ctid(cmx)][1]==2)ans++;
	if(ndid[ctid(cmn-1)]&&canatk(p,ndid[ctid(cmn-1)])&&road[ctid(cmn)][0]==2)ans++;
	ans+=rd3.getsz(id(x,y));//三类边。 
	if(nd[p].col==0)ans+=W.qu(1,2e5,1,nd[p].lv,W.rt[rd3.getrt(id(x,y))]);
	else ans+=B.qu(1,2e5,1,nd[p].lv,B.rt[rd3.getrt(id(x,y))]);
	ans--;//去重。 
	ans-=LT.qu(1,2e5,L.getmn(id(x,y)),L.getmx(id(x,y)),LT.rt[rd3.getrt(id(x,y))]);
	ans-=CT.qu(1,2e5,C.getmn(idc(x,y)),C.getmx(idc(x,y)),CT.rt[rd3.getrt(id(x,y))]);
	res[p]=ans;
}
void init() {//清空。 
	L.init();
	C.init();
	rd3.init();
	B.init();
	W.init();
	CT.init();
	LT.init();
	for(int i=1; i<=n*m; i++)ndid[i]=0;
	for(int i=1; i<=n*m; i++) {
		road[i][0]=road[i][1]=road[i][2]=road[i][3]=0;
	}
}
void slv() {
	read(n),read(m),read(q);
	init();
	for(int i=1; i<=n; i++) {
		string s;
		cin>>s;;
		for(int j=1; j<m; j++) {
			road[id(i,j+1)][2]=road[id(i,j)][3]=s[j-1]^48;
		}
	}
	for(int i=1; i<n; i++) {
		string s;
		cin>>s;
		for(int j=1; j<=m; j++) {
			road[id(i+1,j)][0]=road[id(i,j)][1]=s[j-1]^48;
		}
	}
	for(int i=1; i<=q; i++) {
		cin>>nd[i].col>>nd[i].lv>>nd[i].x>>nd[i].y;
		ndid[id(nd[i].x,nd[i].y)]=i;
	}
	lsh();
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			CT.rt[id(i,j)]=CT.insert(1,2e5,idc(i,j),CT.rt[id(i,j)]);
			LT.rt[id(i,j)]=LT.insert(1,2e5,id(i,j),LT.rt[id(i,j)]);
		}
	}
	for(int i=1; i<=n; i++) {//合并初始连通块。 
		for(int j=1; j<=m; j++) {
			if(ndid[id(i,j)])continue;
			if(i>1&&road[id(i,j)][0]==2&&!ndid[id(i-1,j)]) {
				C.mg(idc(i,j),idc(i-1,j));
			}
			if(i>1&&road[id(i,j)][0]==3) {
				if(!ndid[id(i-1,j)]) {
					mgsegcol(id(i,j),id(i-1,j));
					mgsegc(id(i,j),id(i-1,j));
					mgsegl(id(i,j),id(i-1,j));
					rd3.mg(id(i,j),id(i-1,j));
				} else {
					int idn=ndid[id(i-1,j)];
					if(nd[idn].col)W.rt[rd3.getrt(id(i,j))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(i,j))]);
					else B.rt[rd3.getrt(id(i,j))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(i,j))]);
				}
			}
			if(j>1&&road[id(i,j)][2]==2&&!ndid[id(i,j-1)]) {
				L.mg(id(i,j),id(i,j-1));
			}
			if(j>1&&road[id(i,j)][2]==3) {
				if(!ndid[id(i,j-1)]) {
					mgsegcol(id(i,j),id(i,j-1));
					mgsegl(id(i,j),id(i,j-1));
					mgsegc(id(i,j),id(i,j-1));
					rd3.mg(id(i,j),id(i,j-1));
				} else {
					int idn=ndid[id(i,j-1)];
					if(nd[idn].col)W.rt[rd3.getrt(id(i,j))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(i,j))]);
					else B.rt[rd3.getrt(id(i,j))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(i,j))]);
				}
			}
			if(i<n&&road[id(i,j)][1]==2&&!ndid[id(i+1,j)]) {
				C.mg(idc(i,j),idc(i+1,j));
			}
			if(i<n&&road[id(i,j)][1]==3) {
				if(!ndid[id(i+1,j)]) {
					mgsegcol(id(i,j),id(i+1,j));
					mgsegc(id(i,j),id(i+1,j));
					mgsegl(id(i,j),id(i+1,j));
					rd3.mg(id(i,j),id(i+1,j));
				} else {
					int idn=ndid[id(i+1,j)];
					if(nd[idn].col)W.rt[rd3.getrt(id(i,j))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(i,j))]);
					else B.rt[rd3.getrt(id(i,j))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(i,j))]);
				}
			}
			if(j<m&&road[id(i,j)][3]==2&&!ndid[id(i,j+1)]) {
				L.mg(id(i,j),id(i,j+1));
			}
			if(j<m&&road[id(i,j)][3]==3) {
				if(!ndid[id(i,j+1)]) {
					mgsegcol(id(i,j),id(i,j+1));
					mgsegc(id(i,j),id(i,j+1));
					mgsegl(id(i,j),id(i,j+1));
					rd3.mg(id(i,j),id(i,j+1));
				} else {
					int idn=ndid[id(i,j+1)];
					if(nd[idn].col)W.rt[rd3.getrt(id(i,j))]=W.insert(1,2e5,nd[idn].lv,W.rt[rd3.getrt(id(i,j))]);
					else B.rt[rd3.getrt(id(i,j))]=B.insert(1,2e5,nd[idn].lv,B.rt[rd3.getrt(id(i,j))]);
				}
			}
		}
	}
	for(int i=q; i>=1; i--)op(i);
	for(int i=1; i<=q; i++)print(res[i]);
	return;
}
signed main() {
	read(T);
	while(T--)slv();
	return 0;
}
```

---

## 作者：Arghariza (赞：3)

推销：[Everyday DS](https://www.luogu.com.cn/blog/Ender32k/everyday-ds) | Day $S_{\text{fib}}(7)$。

历时 5.5h 写 + 调，真的有人会在场上写正解吗。/oh/oh

考虑以某些同种种类的边组成的若干连通块，注意到放一个棋子可能会将棋盘分割成不同的连通块，于是倒序考虑将分裂变成合并，每次相当于删去一个棋子。

$(x,y)$ 的答案分四类讨论，分别为 $S_1,S_2,S_3,S_4$：

- $S_1$ 为 $(x,y)$ 能通过 $2$ 类边到达的所有点个数。
- $S_2$ 为 $(x,y)$ 能通过 $3$ 类边到达的所有点个数。
- $S_3$ 为 $(x,y)$ 分别通过 $2$ 类边和 $3$ 类边都能到达的所有点个数。
- $S_4$ 为 $(x,y)$ 通过 $1$ 类边能到达的，通过 $2,3$ 类边均不能到达的点的个数。

答案就是 $S_1+S_2-S_3+S_4$。考虑求出以上答案所需要维护的信息，注意到我们要**支持合并**的数据结构，定义 $(x,y)$ 的横向坐标为 $(x-1)m+y$，纵向坐标为 $(y-1)n+x$，则一行的子段横向坐标连续、一列的子段纵向坐标连续：

- $S_1$：对每行/每列建并查集维护其中 $2$ 类边组成的连通块，由于只能走水平/竖直方向，每个连通块在横向/纵向坐标中是区间的形式，记录每个区间左端点以及右端点即可。
- $S_2,S_3$（因为有些限制重复所以放一起了）：对每个点建 $4$ 棵线段树，维护这个点所在的 $3$ 类边连通块（这里 $3$ 类边 $(u,v)$ 联通当且仅当 **$u,v$ 上均没有棋子**），分别表示按照横向坐标为下标的连通块中没有棋子的点集、纵向坐标为下标的连通块中没有棋子的点集、等级为下标的连通块**相邻**的有**白**棋的点集、等级为下标的连通块**相邻**的有**黑**棋的点集。
- 由于 $S_4\le 4$，我们直接对于 $(x,y)$ 的上下左右四个点用以上维护出的信息暴力 check 一遍就行了。

复杂度 $O((nm+q)\log nm)$，但是常数巨大无比。

```cpp
// Problem: P7963 [NOIP2021] 棋局
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7963
// Memory Limit: 1 MB
// Time Limit: 6000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#define pb emplace_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second
// #define FILE

using namespace std;
typedef long long ll;
typedef pair<int, int> pi;
typedef tuple<int, int, int> tu;
bool Mbe;

const int N = 2e5 + 200;
const int M = 1e5 + 100;
const int K = N << 5;

int n, m, q, len, cnt[M];
int fx[4][2] = { { 0, -1 }, { 0, 1 }, { 1, 0 }, { -1, 0 } };
pi lv[M], tp[M];
string s[N], t[N];
vector<pi> st[N];
vector<int> vis[N], id[N], res;

struct qnode { 
	int c, l, x, y; 
	qnode () { }
	qnode (int _c, int _l, int _x, int _y) :
	c(_c), l(_l), x(_x), y(_y) { }
} qr[M];

struct DSU {
	int fa[N], mn[N], mx[N];
	void init(int lim) {
		for (int i = 1; i <= lim; i++) 
			fa[i] = mn[i] = mx[i] = i;
	}
	int gf(int x) { return x == fa[x] ? x : fa[x] = gf(fa[x]); }
	void mrg(int x, int y) {
		if ((x = gf(x)) == (y = gf(y))) return;
		fa[x] = y, mx[y] = max(mx[y], mx[x]), mn[y] = min(mn[y], mn[x]);
	}
} dx, dy;

struct SEG {
	int fa[N], rt[N][4];
	struct seg {
		int tot, lc[K], rc[K], ct[K];
		#define ls lc[x]
		#define rs rc[x]
		#define mid ((l + r) >> 1)
		void upd(int l, int r, int p, int c, int &x) {
			if (!x) x = ++tot;
			if (l == r) return ct[x] = c, void();
			if (p <= mid) upd(l, mid, p, c, ls);
			else upd(mid + 1, r, p, c, rs);
			ct[x] = ct[ls] + ct[rs];
		}
		int qry(int l, int r, int s, int t, int x) {
			if (!x) return 0;
			if (s <= l && r <= t) return ct[x];
			if (s > mid) return qry(mid + 1, r, s, t, rs);
			else if (t <= mid) return qry(l, mid, s, t, ls);
			return qry(l, mid, s, t, ls) + qry(mid + 1, r, s, t, rs);
		}
		void mrg(int l, int r, int &x, int y) {
			if (!x || !y) return x = (x | y), void();
			if (l == r) return ct[x] |= ct[y], void();
			mrg(l, mid, ls, lc[y]), mrg(mid + 1, r, rs, rc[y]);
			ct[x] = ct[ls] + ct[rs];
		}
	} sx, sy, s0, s1;
	void init(int lim) { 
		for (int i = 1; i <= sx.tot; i++) sx.lc[i] = sx.rc[i] = sx.ct[i] = 0;
		for (int i = 1; i <= sy.tot; i++) sy.lc[i] = sy.rc[i] = sy.ct[i] = 0;
		for (int i = 1; i <= s0.tot; i++) s0.lc[i] = s0.rc[i] = s0.ct[i] = 0;
		for (int i = 1; i <= s1.tot; i++) s1.lc[i] = s1.rc[i] = s1.ct[i] = 0;
		sx.tot = sy.tot = s0.tot = s1.tot = 0; 
		for (int i = 1; i <= lim; i++) 
			fa[i] = i, rt[i][0] = rt[i][1] = rt[i][2] = rt[i][3] = 0; 
	}
	int gf(int x) { return x == fa[x] ? x : fa[x] = gf(fa[x]); }
	void com(int x, int y) {
		if ((x = gf(x)) == (y = gf(y))) return;
		int tp = x;
		if (sx.ct[rt[x][0]] < sx.ct[rt[y][0]]) swap(x, y);
		sx.mrg(1, n * m, rt[x][0], rt[y][0]), rt[y][0] = rt[x][0];
		if (sy.ct[rt[x][1]] < sy.ct[rt[y][1]]) swap(x, y);
		sy.mrg(1, n * m, rt[x][1], rt[y][1]), rt[y][1] = rt[x][1];
		if (s0.ct[rt[x][2]] < s0.ct[rt[y][2]]) swap(x, y);
		s0.mrg(1, len, rt[x][2], rt[y][2]), rt[y][2] = rt[x][2];
		if (s1.ct[rt[x][3]] < s1.ct[rt[y][3]]) swap(x, y);
		s1.mrg(1, len, rt[x][3], rt[y][3]), rt[y][3] = rt[x][3];
		fa[x] = fa[y] = tp;
	}
} T;

int idx(int x, int y) { return (x - 1) * m + y; }
int idy(int x, int y) { return (y - 1) * n + x; }
pi posx(int id) { return mp((id + m - 1) / m, (id - 1) % m + 1); }
pi posy(int id) { return mp((id - 1) % n + 1, (id + n - 1) / n); }

void init() {
	dx.init(n * m), dy.init(n * m), T.init(n * m);
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= m - 1; j++) 
			if (!vis[i][j] && !vis[i][j + 1] && st[i][j].fi == 2) 
				dx.mrg(idx(i, j), idx(i, j + 1));
	for (int i = 1; i <= n - 1; i++)
		for (int j = 1; j <= m; j++)
			if (!vis[i][j] && !vis[i + 1][j] && st[i][j].se == 2)
				dy.mrg(idy(i, j), idy(i + 1, j));
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			T.sx.upd(1, n * m, idx(i, j), 1, T.rt[idx(i, j)][0]);
			T.sy.upd(1, n * m, idy(i, j), 1, T.rt[idx(i, j)][1]);
			if (i > 1 && vis[i - 1][j] && st[i - 1][j].se == 3) {
				if (vis[i - 1][j] == 1) T.s0.upd(1, len, id[i - 1][j], 1, T.rt[idx(i, j)][2]);
				else T.s1.upd(1, len, id[i - 1][j], 1, T.rt[idx(i, j)][3]);
			}
			if (i < n && vis[i + 1][j] && st[i][j].se == 3) {
				if (vis[i + 1][j] == 1) T.s0.upd(1, len, id[i + 1][j], 1, T.rt[idx(i, j)][2]);
				else T.s1.upd(1, len, id[i + 1][j], 1, T.rt[idx(i, j)][3]);
			}
			if (j > 1 && vis[i][j - 1] && st[i][j - 1].fi == 3) {
				if (vis[i][j - 1] == 1) T.s0.upd(1, len, id[i][j - 1], 1, T.rt[idx(i, j)][2]);
				else T.s1.upd(1, len, id[i][j - 1], 1, T.rt[idx(i, j)][3]);
			}
			if (j < m && vis[i][j + 1] && st[i][j].fi == 3) {
				if (vis[i][j + 1] == 1) T.s0.upd(1, len, id[i][j + 1], 1, T.rt[idx(i, j)][2]);
				else T.s1.upd(1, len, id[i][j + 1], 1, T.rt[idx(i, j)][3]);
			}
		}
	}
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= m - 1; j++)
			if (!vis[i][j] && !vis[i][j + 1] && st[i][j].fi == 3)
				T.com(idx(i, j), idx(i, j + 1));
	for (int i = 1; i <= n - 1; i++) 
		for (int j = 1; j <= m; j++)
			if (!vis[i][j] && !vis[i + 1][j] && st[i][j].se == 3)
				T.com(idx(i, j), idx(i + 1, j)); 
}

void clear() {
	len = 0, res.clear();
	for (int i = 1; i <= n; i++) 
		st[i].clear(), vis[i].clear(), id[i].clear();
	for (int i = 1; i <= q; i++) cnt[i] = 0;
}

void solve() {
	cin >> n >> m >> q;
	for (int i = 1; i <= n; i++) cin >> s[i];
	for (int i = 1; i <= n - 1; i++) cin >> t[i];
	for (int i = 1; i <= n; i++) {
		st[i].resize(m + 1), vis[i].resize(m + 1), id[i].resize(m + 1);
		for (int j = 1; j <= m; j++) {
			vis[i][j] = 0;
			if (j < m) st[i][j].fi = s[i][j - 1] - '0';
			if (i < n) st[i][j].se = t[i][j - 1] - '0';
		}
	}
	for (int i = 1, c, l, x, y; i <= q; i++) {		
		cin >> c >> l >> x >> y, qr[i] = qnode(c, l, x, y), vis[x][y] = 1 + c;
		cnt[l]++, lv[i] = tp[++len] = mp(l, cnt[l]);
	}
	sort(tp + 1, tp + len + 1), len = unique(tp + 1, tp + len + 1) - tp - 1;
	for (int i = 1; i <= q; i++) {
		qr[i].l = lower_bound(tp + 1, tp + len + 1, lv[i]) - tp;
		id[qr[i].x][qr[i].y] = qr[i].l;
	}
	reverse(qr + 1, qr + q + 1), init();
	for (int _ = 1; _ <= q; _++) {
		int c = qr[_].c, l = qr[_].l, i = qr[_].x, j = qr[_].y, pr = T.gf(idx(i, j));
		if (i > 1 && st[i - 1][j].se == 3) {
			int prn = T.gf(idx(i - 1, j));
			if (vis[i][j] == 1) T.s0.upd(1, len, id[i][j], 0, T.rt[prn][2]);
			else T.s1.upd(1, len, id[i][j], 0, T.rt[prn][3]);
		}
		if (i < n && st[i][j].se == 3) {
			int prn = T.gf(idx(i + 1, j));
			if (vis[i][j] == 1) T.s0.upd(1, len, id[i][j], 0, T.rt[prn][2]);
			else T.s1.upd(1, len, id[i][j], 0, T.rt[prn][3]);
		}
		if (j > 1 && st[i][j - 1].fi == 3) {
			int prn = T.gf(idx(i, j - 1));
			if (vis[i][j] == 1) T.s0.upd(1, len, id[i][j], 0, T.rt[prn][2]);
			else T.s1.upd(1, len, id[i][j], 0, T.rt[prn][3]);
		}
		if (j < m && st[i][j].fi == 3) {
			int prn = T.gf(idx(i, j + 1));
			if (vis[i][j] == 1) T.s0.upd(1, len, id[i][j], 0, T.rt[prn][2]);
			else T.s1.upd(1, len, id[i][j], 0, T.rt[prn][3]);
		}
		if (j > 1 && !vis[i][j - 1]) {
			if (st[i][j - 1].fi == 2) dx.mrg(idx(i, j - 1), idx(i, j));
			else if (st[i][j - 1].fi == 3) T.com(idx(i, j - 1), idx(i, j));
		}
		if (i > 1 && !vis[i - 1][j]) {
			if (st[i - 1][j].se == 2) dy.mrg(idy(i - 1, j), idy(i, j));
			else if (st[i - 1][j].se == 3) T.com(idx(i - 1, j), idx(i, j));
		}
		if (j < m && !vis[i][j + 1]) {
			if (st[i][j].fi == 2) dx.mrg(idx(i, j), idx(i, j + 1));
			else if (st[i][j].fi == 3) T.com(idx(i, j), idx(i, j + 1));
		} 
		if (i < n && !vis[i + 1][j]) {
			if (st[i][j].se == 2) dy.mrg(idy(i, j), idy(i + 1, j));
			else if (st[i][j].se == 3) T.com(idx(i, j), idx(i + 1, j));
		}
		int rtx = dx.gf(idx(i, j)), rty = dy.gf(idy(i, j)); pr = T.gf(idx(i, j));
		int xmn = posx(dx.mn[rtx]).se, xmx = posx(dx.mx[rtx]).se;
		int ymn = posy(dy.mn[rty]).fi, ymx = posy(dy.mx[rty]).fi;
		if (xmn > 1 && st[i][xmn - 1].fi == 2 && vis[i][j] + vis[i][xmn - 1] == 3 && id[i][xmn - 1] < id[i][j]) xmn--;
		if (xmx < m && st[i][xmx].fi == 2 && vis[i][j] + vis[i][xmx + 1] == 3 && id[i][xmx + 1] < id[i][j]) xmx++;
		if (ymn > 1 && st[ymn - 1][j].se == 2 && vis[i][j] + vis[ymn - 1][j] == 3 && id[ymn - 1][j] < id[i][j]) ymn--;
		if (ymx < n && st[ymx][j].se == 2 && vis[i][j] + vis[ymx + 1][j] == 3 && id[ymx + 1][j] < id[i][j]) ymx++;
		int ans = xmx - xmn + ymx - ymn;
		ans += T.sx.ct[T.rt[pr][0]] - 1;
		ans -= T.sx.qry(1, n * m, idx(i, xmn), idx(i, xmx), T.rt[pr][0]) - 1;
		ans -= T.sy.qry(1, n * m, idy(ymn, j), idy(ymx, j), T.rt[pr][1]) - 1;
		if (vis[i][j] == 1) {
			ans += T.s1.qry(1, len, 1, id[i][j] - 1, T.rt[pr][3]);
			ans -= (xmn != j && vis[i][xmn] == 2 && id[i][xmn] < id[i][j] && T.s1.qry(1, len, id[i][xmn], id[i][xmn], T.rt[pr][3]));
			ans -= (xmx != j && vis[i][xmx] == 2 && id[i][xmx] < id[i][j] && T.s1.qry(1, len, id[i][xmx], id[i][xmx], T.rt[pr][3]));
			ans -= (ymn != i && vis[ymn][j] == 2 && id[ymn][j] < id[i][j] && T.s1.qry(1, len, id[ymn][j], id[ymn][j], T.rt[pr][3]));
			ans -= (ymx != i && vis[ymx][j] == 2 && id[ymx][j] < id[i][j] && T.s1.qry(1, len, id[ymx][j], id[ymx][j], T.rt[pr][3]));
		}
		if (vis[i][j] == 2) {
			ans += T.s0.qry(1, len, 1, id[i][j] - 1, T.rt[pr][2]);
			ans -= (xmn != j && vis[i][xmn] == 1 && id[i][xmn] < id[i][j] && T.s0.qry(1, len, id[i][xmn], id[i][xmn], T.rt[pr][2]));
			ans -= (xmx != j && vis[i][xmx] == 1 && id[i][xmx] < id[i][j] && T.s0.qry(1, len, id[i][xmx], id[i][xmx], T.rt[pr][2]));
			ans -= (ymn != i && vis[ymn][j] == 1 && id[ymn][j] < id[i][j] && T.s0.qry(1, len, id[ymn][j], id[ymn][j], T.rt[pr][2]));
			ans -= (ymx != i && vis[ymx][j] == 1 && id[ymx][j] < id[i][j] && T.s0.qry(1, len, id[ymx][j], id[ymx][j], T.rt[pr][2]));
		}
		auto chk = [&] (int x, int y) {
			if (x == i && xmn <= y && y <= xmx) return 0;
			if (y == j && ymn <= x && x <= ymx) return 0;
			if (vis[x][y] == 0 && T.sx.qry(1, n * m, idx(x, y), idx(x, y), T.rt[pr][0])) return 0;
			if (vis[x][y] == 1 && (T.s0.qry(1, len, id[x][y], id[x][y], T.rt[pr][2]) || vis[i][j] == 1 || (vis[i][j] == 2 && id[i][j] <= id[x][y]))) return 0;
			if (vis[x][y] == 2 && (T.s1.qry(1, len, id[x][y], id[x][y], T.rt[pr][3]) || vis[i][j] == 2 || (vis[i][j] == 1 && id[i][j] <= id[x][y]))) return 0;
			return 1;
		};
		if (j < m && st[i][j].fi == 1) ans += chk(i, j + 1);
		if (j > 1 && st[i][j - 1].fi == 1) ans += chk(i, j - 1);
		if (i < n && st[i][j].se == 1) ans += chk(i + 1, j);
		if (i > 1 && st[i - 1][j].se == 1) ans += chk(i - 1, j);
		res.pb(ans), vis[i][j] = 0;
	}
	reverse(res.begin(), res.end());
	for (int i : res) cout << i << '\n';
	clear();
}

bool Med;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen("chess.in", "r", stdin);
		freopen("chess.out", "w", stdout);
	#endif
	int T = 1;
	cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：vectorwyx (赞：3)

> 都什么年代了还在下传统围棋？

题面看起来很吓人，但细想一下就会发现思路还是很直接的。以下把有棋子的格点称为特殊点。

首先想到的是对普通道路、直达道路、互通道路分别维护。前两者看起来都比较容易：普通道路只有 $4$ 种可能，直达道路也只有四个方向，可以概括为四条线段；而直达道路和普通道路可达的点也是不交的。问题在于互通道路，以及怎么去除互通道路与其它道路的交集。接下来先讨论怎么维护每个点通过互通道路能到达的点集。

由于到了一个特殊点之后就不可能再走下去，所以考虑把特殊点和普通点分开维护可达性。具体地，对每个普通点开一个集合存储与它相邻的特殊点，每次加入一个棋子时，把对应格点删掉，并把这枚棋子放入相邻的、与它由一条互通道路连接的普通点的集合中。这样的话，从某个点出发能到达的特殊点的集合就是从它出发能到达的普通点对应的集合的并。现在的任务看起来就只有删点，以及维护普通点的连通块信息。时间倒流，由删点变为加点。为了支持查询，对每个点维护两棵平衡树分别表示颜色为 $0,1$ 的可达特殊点，平衡树以等级为第一关键字、编号为第二关键字。加点时合并对应连通块的平衡树，同时把对应的特殊点改为普通点，这只需要把对应棋子从连通块的平衡树中删除。注意平衡树自带了取并操作。而由普通道路和直达道路能到达的特殊点最多有 $4$ 个，那么判重也是简单的。

而对于能到达的普通点也是类似地维护，但是为了去重我们需要算出对应点集中，横坐标为 $x$，纵坐标介于 $[l,r]$ 之间的点的数量。以及横坐标介于 $[l,r]$ 之间，纵坐标为 $y$ 的点数。不过这也是好办的，仍然开两棵平衡树，一棵以横坐标为第一关键字、纵坐标为第二关键字，另一棵以纵坐标为第一关键字、横坐标为第二关键字，查询时差分一下就行。注意自身可能被算进去，要去掉。

现在的问题只剩下求出直达道路对应的横竖两条线段的范围。对于每一行和每一列，用并查集维护直达道路的连续段，加点时合并即可。

具体实现上，用 pb_ds 的平衡树会被卡常。需要用线段树代替平衡树，然后线段树合并。但这样的话，特殊点的集合取并会比较头疼。如果你想用启发式合并哈希表的方式来完成，就会陷入不幸。正确的打开方式是把棋子的权值按（权值，出现时间）离散化成不同的值，这样直接线段树合并就啥事也没有了。复杂度单 $\log$。

代码如下：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp> 
//#include<ext/pb_ds/tree_policy.hpp> 
#include<ext/pb_ds/hash_policy.hpp> 
namespace vectorwyx{
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define gtc getchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
//#define Tree tree<pii,null_type,less<pii>,rb_tree_tag,tree_order_statistics_node_update>
//#define It Tree::iterator
using namespace std;
using namespace __gnu_pbds;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=2e5+5,inf=1e9;
#define F(i,j) ((i-1)*m+j)
#define F_(i,j) ((i-1)*n+j)
int ban[N],n,m,q,col[N],lv[N];
vector<int> e[N][4];

namespace Sgt{
const int N=2e7;
struct Node{
	int lt,rt,sum;
	Node(){lt=rt=sum=0;}
}tr[N];
int num,trash[N],ct;
void clear(){fo(i,1,num) tr[i]=Node();ct=num=0;}
#define ls (tr[x].lt)
#define rs (tr[x].rt)
#define mid ((l+r)>>1)
int new_(){
	if(ct) re trash[ct--];
	re ++num;
}
void ps(int x){tr[x].sum=tr[ls].sum+tr[rs].sum;}
void upd(int &x,int l,int r,int aim,int k){
	if(!x) x=new_();//,assert(x<=N*4*21);
//	printf("upd(%d,%d,%d,%d,%d)\n",x,l,r,aim,k);
	if(l==r){tr[x].sum=k;re;}
	if(aim<=mid) upd(ls,l,mid,aim,k);
	else upd(rs,mid+1,r,aim,k);
	ps(x);
}
#define JI(x) (tr[x]=Node(),trash[++ct]=x)
int merge(int x,int y){
	if(!x||!y) re x|y;
	int w=new_();
	if(!tr[x].lt&&!tr[x].rt&&!tr[y].lt&&!tr[y].rt){
		tr[w].sum=tr[x].sum|tr[y].sum;
		JI(x),JI(y);
		re w;
	}
	tr[w].lt=merge(tr[x].lt,tr[y].lt);
	tr[w].rt=merge(tr[x].rt,tr[y].rt);
	ps(w);
	JI(x),JI(y);
	re w;
}
int rank(int x,int l,int r,int k){
	if(!x) re 0;
	if(r<=k) re tr[x].sum;
	int ret=rank(ls,l,mid,k);
	if(k>mid) ret+=rank(rs,mid+1,r,k);
	re ret;
}
int ask(int x,int l,int r,int aim){
	if(!x) re 0;
	if(l==r) re tr[x].sum; 
	if(aim<=mid) re ask(ls,l,mid,aim);
	else re ask(rs,mid+1,r,aim);
}
//void clr(int x){
//	if(!x) re;
//	clr(ls);clr(rs);
//	JI(x);
//}
}
using Sgt::upd;

struct Splay{
//	#define hxb map<int,int>
//	hxb mp;
	int rt;
	void clear(){
		rt=0;
//		hxb tmp;swap(mp,tmp);
	}
	void insert(int x){
//		re;
//		printf("insert(%d)\n",x);
//		if(mp[x]) re;
//		mp[x]=1;
		upd(rt,1,q,lv[x],1);
	}
	int order_of_key(int x){re Sgt::rank(rt,1,q,x);}
	int size(){re Sgt::tr[rt].sum;}
	void erase(int x){//注意 STL set 的 erase 是会先检验元素是否存在的！ 
//		re;
//		if(mp.find(x)==mp.end()) re;
//		mp.erase(x);
		upd(rt,1,q,lv[x],0);
	}
	bool find(int x){re Sgt::ask(rt,1,q,lv[x]);}
}rea[N][2];

struct Set{
	int rt;
	void clear(){rt=0;}
	void insert(int x){upd(rt,1,n*m,x,1);}
	int order_of_key(int x){re Sgt::rank(rt,1,n*m,x);}
	int size(){re Sgt::tr[rt].sum;}
	bool find(int x){
		re Sgt::ask(rt,1,n*m,x);
	}
}Rh[N],Rl[N];

int siz[N];
struct DSU{
vector<int> f,mn,mx;
void reset(int len){
	f.resize(len+2);mn.resize(len+2);mx.resize(len+2);
	fo(i,1,len) f[i]=mn[i]=mx[i]=i;
}
int fin(int x){
	if(f[x]==x) re x;
	re f[x]=fin(f[x]);
}
void merge(int x,int y){
	int fx=fin(x),fy=fin(y);
	if(fx==fy) re;
	f[fx]=fy;sml(mn[fy],mn[fx]),big(mx[fy],mx[fx]);
}
int L(int x){re mn[fin(x)];}
int R(int x){re mx[fin(x)];}
}B1[N],B2[N],all;//并查集 

//Tree rea[N][2],Rh[N],Rl[N];

struct Opt{
	int col,lv,x,y;
}a[N];

int road[N][4]; 
void connect(int x,int y,int o){
	if(!o) re;
	e[x][o].eb(y);
	e[y][o].eb(x);
}

void clear(){
	fo(i,1,n*m){
		fo(o,0,3) road[i][o]=0;
		rea[i][0].clear(),rea[i][1].clear();
		Rh[i].clear(),Rl[i].clear();
		fo(j,1,3) e[i][j].clear();
	}
	Sgt::clear();
}

#define H_(x) ((x-1)/m+1)
#define L_(x) ((x-1)%m+1)

void gao(Splay &x,Splay &y){//把 x 并入到 y 中 
	y.rt=Sgt::merge(x.rt,y.rt);
//	for(auto i:x.mp) y.insert(i.fi),cnt++;
//	x.clear();
}

void gao(Set &x,Set &y){
	y.rt=Sgt::merge(x.rt,y.rt);
}

void merge(int x,int y){//互通道路的连接 
//	printf("merge(%d,%d)\n",x,y);
//	for(auto i:rea[3][0].mp) printf("(%d,%d) ",i.fi,i.se);HH;
//	int x_=x,y_=y;
	x=all.fin(x),y=all.fin(y);
	if(x==y) re;
	if(siz[x]>siz[y]) swap(x,y);
	all.merge(x,y);siz[y]+=siz[x];
	gao(Rh[x],Rh[y]);
	gao(Rl[x],Rl[y]);
	gao(rea[x][0],rea[y][0]);
	gao(rea[x][1],rea[y][1]);
}

void add_point(int x){
	int i=H_(x),j=L_(x);
//	printf("add_point(%d) %d,%d\n",x,i,j);
//	tr1[i].upd(j,1);tr2[j].upd(i,1);
	//处理直达道路 
	for(int k:e[x][2]) if(!ban[k]){
		if(H_(k)==i) B1[i].merge(L_(k),j);
		else B2[j].merge(H_(k),i);
	}
	//处理互通道路 
	for(int k:e[x][3]) if(ban[k]) 
		rea[all.fin(x)][col[k]].insert(k);
	for(int k:e[x][3]) if(!ban[k]) merge(x,k);
}

int cnt[N];

void build(){
	all.reset(n*m);fo(i,1,n*m) siz[i]=1;
	fo(i,1,n) B1[i].reset(m);
	fo(i,1,m) B2[i].reset(n);	
	fo(i,1,q) cnt[i]=0;fo(i,1,q) cnt[a[i].lv]++;
	fo(i,2,q) cnt[i]+=cnt[i-1];
	go(i,q,1) lv[F(a[i].x,a[i].y)]=cnt[a[i].lv]--;
	fo(i,1,n) fo(j,1,m){
		int x=F(i,j);
		Rh[x].insert(F(i,j));
		Rl[x].insert(F_(j,i));
		if(!ban[x]) for(int k:e[x][3]) if(ban[k]) 
			rea[x][col[k]].insert(k);
	}
	fo(i,1,n) fo(j,1,m){
		int x=F(i,j);
		if(ban[x]) co;
		add_point(x);
	}
}

int calc_H(int x,int l,int r){
	//计算在 x 能通过互通道路到达的普通点中，
	//与 x 同行且列坐标位于 [l,r] 的点数 
	int i=H_(x),fx=all.fin(x);
	re (int)( Rh[fx].order_of_key(F(i,r))-Rh[fx].order_of_key(F(i,l-1)) );
}

int calc_L(int x,int l,int r){
	int j=L_(x),fx=all.fin(x);
	re (int)( Rl[fx].order_of_key(F_(j,r))-Rl[fx].order_of_key(F_(j,l-1)) );
}

int ask(int x){
//	re 0;
//	printf("ask(%d)\n",x);
	int ans=0,i=H_(x),j=L_(x),fx=all.fin(x);
	#define Rea rea[fx][col[x]^1]
//	for(auto w:Rea.mp) printf("(%d,%d) ",w.fi,w.se);HH;
	//计算能到达的特殊点
	ans+=(int)Rea.order_of_key(lv[x]);
//	int l=tr1[i].getL(B1[i].L(j),j-1),r=tr1[i].getR(j+1,B1[i].R(j));
	int l=B1[i].L(j),r=B1[i].R(j);
//	int L=tr2[j].getL(B2[j].L(i),i-1),R=tr2[j].getR(i+1,B2[j].R(i));
	int L=B2[j].L(i),R=B2[j].R(i);
//	printf("l=%d r=%d L=%d R=%d\n",l,r,L,R);
	#define QC(y) if(ban[y]&&lv[y]<=lv[x]&&col[y]!=col[x])\
						ans+=Rea.find(y)^1;
	if(l>1){
		int y=F(i,l-1);
		if(road[y][2]==2) QC(y);
	}
	if(L>1){
		int y=F(L-1,j);
		if(road[y][3]==2) QC(y);
	}
	if(r<m){
		int y=F(i,r+1);
		if(road[y][0]==2) QC(y);
	}
	if(R<n){
		int y=F(R+1,j);
		if(road[y][1]==2) QC(y);
	}
	for(int k:e[x][1]) if(ban[k]) QC(k);
//	printf("可达的特殊点数目为 %d\n",ans);
	
	//计算能到达的普通点 
	//注意 Rh 和 Rl 只有比较方式的差别 
	ans+=(int)Rh[fx].size()-1;//注意包含它本身 
	if(l<j) ans+=j-l-calc_H(x,l,j-1);
	if(r>j) ans+=r-j-calc_H(x,j+1,r);
	if(L<i) ans+=i-L-calc_L(x,L,i-1);
	if(R>i) ans+=R-i-calc_L(x,i+1,R);
	for(int k:e[x][1]) if(!ban[k]) 
		ans+=Rh[fx].find(k)==0;
//	printf("可达的总点数为 %d\n",ans);	
	re ans;
}

int ans[N];

void solve(){
	cin>>n>>m>>q;
	clear();
	fo(i,1,n){
		string s;cin>>s;
		fo(j,1,m-1){
			int x=F(i,j),y=F(i,j+1),o=(int)(s[j-1]-'0');
			connect(x,y,o);
			road[x][2]=road[y][0]=o;
		}
	}
	fo(i,1,n-1){
		string s;cin>>s;
		fo(j,1,m){
			int x=F(i,j),y=F(i+1,j),o=(int)(s[j-1]-'0');
			connect(x,y,o);
			road[x][3]=road[y][1]=o;
		}
	}
	fo(i,1,q){
		a[i].col=read(),a[i].lv=read(),a[i].x=read(),a[i].y=read();
		int x=F(a[i].x,a[i].y);
		ban[x]=1;col[x]=a[i].col;lv[x]=a[i].lv;
//		tr1[a[i].x].upd(a[i].y,1);tr2[a[i].y].upd(a[i].x,1);
	}
	build();
	go(t,q,1){
		int nd=F(a[t].x,a[t].y);
		
		ban[nd]=0;
		//tr1[x].upd(y,-1),tr2[y].upd(x,-1);
		add_point(nd);
//		rea[all.fin(nd)][col[nd]].erase(mk(lv[nd],nd));
//		cout<<"?";for(auto i:rea[all.fin(nd)][col[nd]].mp) printf("(%d,%d) ",i.fi,i.se);HH; 
		rea[all.fin(nd)][col[nd]].erase(nd);
		ans[t]=ask(nd);
	}
	fo(i,1,q) cout<<ans[i]<<'\n';
}

void file(){
	freopen("chess5.in","r",stdin);
	freopen(".out","w",stdout);
}

signed main(){
//	file();
	int T=read();
	while(T--) solve();
	return 0;
}
}
/*
-------------------------------------------------
*/










signed main(){re vectorwyx::main();}
```





---

## 作者：Leasier (赞：3)

前置芝士：线段树合并

先考虑没有吃子的情况（即 $lv_i = q - i + 1$）。

对于互通道路，注意到其连接的为一个没有棋子的连通块，而每次添加棋子相当于删边，于是考虑倒过来，改删边为加边，能通过互通道路到达的点数即为连通块大小 $- 1$（因为不包括这个棋子自己）。

对于直行道路，注意到其连接的一定为行列方向的四个连通块，于是先对每个位置预处理只走直行道路项四个方向分别能到哪个地方，再对每行每列用一个 set 维护不包括棋子的连通块即可。

但这样会算重，因为有可能某些位置互通道路和直行道路都可以到达，于是考虑对每个连通块用两棵（因为会查询横竖两个方向）动态开点线段树维护连通块中有哪些点，算直行道路时减去互通道路也能到达的点即可。

对于普通道路，枚举四个方向，如果可以通过普通道路到达且互通道路不能到达，把答案加一。

接下来考虑有吃子的情况。

对于互通道路，注意到当前棋子可能吃的棋子一定是连通块周围的一些颜色与之不同的棋子，于是考虑再对每个连通块开两棵动态开点线段树维护连通块周围两种颜色的棋子，查询颜色与自己不同且等级不高于自己的棋子即可。

但这样会在合并时算重，因为两个连通块可能共享某些在它们周围的棋子，而由于棋子等级并非互不相同，我们不能在合并是直接相加或取 $\max$。所以考虑更改棋子等级使其互不相同，具体操作就是先按本来的等级排序，相同时再按出现时间排序。

对于直行道路，注意到其最大可达区间外围的四个节点也需要考虑，这只需要在线段树上查询这个点能不能通过互通道路到达。

对于普通道路，与直行道路的操作基本相同。

时间复杂度为 $O(T (nm + q) (\log nm + \log q))$。

代码：
```cpp
#include <algorithm>
#include <set>
#include <vector>
#include <cstdio>

using namespace std;

typedef struct {
	int ls;
	int rs;
	int cnt;
} Node;

const int N = 2e5 + 7, M = 2 + 7, K = 1e5 + 7, P = 4, Q = 1.52e7 + 7;
int id;
int dsu_root[N], seg_root1[N], seg_root2[N], seg_root3[N], seg_root4[N][M], size[N], x[K], y[K], dx[P + 7] = {0, -1, 0, 0, 1}, dy[P + 7] = {0, 0, -1, 1, 0}, ans[K];
Node tree[Q];
pair<int, int> pr[K];
set<int> s1[K], s2[K];
vector<int> v1[K], v2[K], v3[K], v4[K], v5[K], v6[K], v7[K], v8[K], v9[K], v10[K];

inline int f(int x, int y, int n){
	return n * (x - 1) + y;
}

inline void init(int n, int m){
	int mi = m + 1, sz = n * m;
	id = 0;
	for (register int i = 1; i <= n; i++){
		v1[i].resize(mi);
		v2[i].resize(mi);
		v3[i].resize(m);
		v4[i].resize(mi);
		v5[i].resize(mi);
		v6[i].resize(mi);
		v7[i].resize(mi);
		v8[i].resize(mi);
		v9[i].clear();
		v9[i].resize(mi);
		v10[i].clear();
		v10[i].resize(mi);
		s1[i].clear();
		for (register int j = 1; j <= m; j++){
			v1[i][j] = f(i, j, m);
			v2[i][j] = f(j, i, n);
		}
	}
	for (register int i = 1; i <= m; i++){
		s2[i].clear();
	}
	for (register int i = 1; i <= sz; i++){
		dsu_root[i] = i;
		seg_root1[i] = seg_root2[i] = seg_root3[i] = seg_root4[i][1] = seg_root4[i][2] = 0;
		size[i] = 1;
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline int read_one(){
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	return ch - '0';
}

inline int get_road_type(int x, int y, int dx, int dy){
	if (dx == -1) return v4[x - 1][y];
	if (dx == 0){
		if (dy == -1) return v3[x][y - 1];
		return v3[x][y];
	}
	return v4[x][y];
}

inline void update(int x){
	tree[x].cnt = tree[tree[x].ls].cnt + tree[tree[x].rs].cnt;
}

void seg_insert(int &x, int l, int r, int pos){
	if (x == 0){
		x = ++id;
		tree[x].ls = tree[x].rs = 0;
	}
	if (l == r){
		tree[x].cnt = 1;
		return;
	}
	int mid = (l + r) >> 1;
	if (pos <= mid){
		seg_insert(tree[x].ls, l, mid, pos);
	} else {
		seg_insert(tree[x].rs, mid + 1, r, pos);
	}
	update(x);
}

int get_root(int x){
	if (dsu_root[x] == x) return x;
	return dsu_root[x] = get_root(dsu_root[x]);
}

int seg_merge(int x, int y, int l, int r){
	if (x == 0) return y;
	if (y == 0) return x;
	if (l == r){
		tree[x].cnt = max(tree[x].cnt, tree[y].cnt);
		return x;
	}
	int mid = (l + r) >> 1;
	tree[x].ls = seg_merge(tree[x].ls, tree[y].ls, l, mid);
	tree[x].rs = seg_merge(tree[x].rs, tree[y].rs, mid + 1, r);
	update(x);
	return x;
}

inline void dsu_merge(int x, int y, int n, int m){
	int x_root = get_root(x), y_root = get_root(y);
	if (x_root != y_root){
		dsu_root[x_root] = y_root;
		seg_root1[y_root] = seg_merge(seg_root1[y_root], seg_root1[x_root], 1, n);
		seg_root2[y_root] = seg_merge(seg_root2[y_root], seg_root2[x_root], 1, n);
		seg_root3[y_root] = seg_merge(seg_root3[y_root], seg_root3[x_root], 1, n);
		seg_root4[y_root][1] = seg_merge(seg_root4[y_root][1], seg_root4[x_root][1], 1, m);
		seg_root4[y_root][2] = seg_merge(seg_root4[y_root][2], seg_root4[x_root][2], 1, m);
		size[y_root] += size[x_root];
	}
}

void seg_erase(int x, int l, int r, int pos){
	if (l == r){
		tree[x].cnt = 0;
		return;
	}
	int mid = (l + r) >> 1;
	if (pos <= mid){
		seg_erase(tree[x].ls, l, mid, pos);
	} else {
		seg_erase(tree[x].rs, mid + 1, r, pos);
	}
	update(x);
}

inline void chess_erase(int x, int y, int n, int m, int k){
	int size = n * m;
	s1[x].erase(y);
	s2[y].erase(x);
	for (register int i = 1; i <= P; i++){
		int new_x = x + dx[i], new_y = y + dy[i];
		if (new_x >= 1 && new_x <= n && new_y >= 1 && new_y <= m && get_road_type(x, y, dx[i], dy[i]) == 3 && v9[new_x][new_y] == 0){
			int cur_root = get_root(v1[new_x][new_y]);
			seg_erase(seg_root3[cur_root], 1, size, v1[x][y]);
			seg_erase(seg_root4[cur_root][v9[x][y]], 1, k, v10[x][y]);
		}
	}
}

inline void blank_insert(int x, int y, int n, int m, int k){
	int cur_root = get_root(v1[x][y]), size = n * m;
	seg_insert(seg_root1[cur_root], 1, size, v1[x][y]);
	seg_insert(seg_root2[cur_root], 1, size, v2[x][y]);
	for (register int i = 1; i <= P; i++){
		int new_x = x + dx[i], new_y = y + dy[i];
		if (new_x >= 1 && new_x <= n && new_y >= 1 && new_y <= m && get_road_type(x, y, dx[i], dy[i]) == 3){
			if (v9[new_x][new_y] == 0){
				dsu_merge(v1[x][y], v1[new_x][new_y], size, k);
			} else {
				cur_root = get_root(v1[x][y]);
				seg_insert(seg_root3[cur_root], 1, size, v1[new_x][new_y]);
				seg_insert(seg_root4[cur_root][v9[new_x][new_y]], 1, k, v10[new_x][new_y]);
			}
		}
	}
}

int get_val(int x, int l, int r, int pos){
	if (x == 0) return 0;
	if (l == r) return tree[x].cnt;
	int mid = (l + r) >> 1;
	if (pos <= mid) return get_val(tree[x].ls, l, mid, pos);
	return get_val(tree[x].rs, mid + 1, r, pos);
}

int get_sum(int x, int L, int R, int l, int r){
	if (x == 0) return 0;
	if (l <= L && R <= r) return tree[x].cnt;
	int mid = (L + R) >> 1, ans = 0;
	if (l <= mid) ans = get_sum(tree[x].ls, L, mid, l, r);
	if (r > mid) ans += get_sum(tree[x].rs, mid + 1, R, l, r);
	return ans;
}

inline bool check(int pos, int a, int b){
	return v9[a][b] == 0 || (v9[x[pos]][y[pos]] != v9[a][b] && v10[x[pos]][y[pos]] >= v10[a][b]);
}

int main(){
	int t = read();
	for (register int i = 1; i <= t; i++){
		int n = read(), m = read(), q = read(), sz = n * m;
		init(n, m);
		for (register int j = 1; j <= n; j++){
			for (register int k = 1; k < m; k++){
				v3[j][k] = read_one();
			}
		}
		for (register int j = 1; j < n; j++){
			for (register int k = 1; k <= m; k++){
				v4[j][k] = read_one();
			}
		}
		for (register int j = n; j >= 1; j--){
			for (register int k = m; k >= 1; k--){
				if (k == m || get_road_type(j, k, 0, 1) != 2){
					v5[j][k] = k;
				} else {
					v5[j][k] = v5[j][k + 1];
				}
				if (j == n || get_road_type(j, k, 1, 0) != 2){
					v6[j][k] = j;
				} else {
					v6[j][k] = v6[j + 1][k];
				}
			}
		}
		for (register int j = 1; j <= n; j++){
			for (register int k = 1; k <= m; k++){
				if (k == 1 || get_road_type(j, k, 0, -1) != 2){
					v7[j][k] = k;
				} else {
					v7[j][k] = v7[j][k - 1];
				}
				if (j == 1 || get_road_type(j, k, -1, 0) != 2){
					v8[j][k] = j;
				} else {
					v8[j][k] = v8[j - 1][k];
				}
			}
		}
		for (register int j = 1; j <= q; j++){
			int col = read() + 1, lv = read();
			x[j] = read();
			y[j] = read();
			v9[x[j]][y[j]] = col;
			pr[j] = make_pair(lv, j);
			s1[x[j]].insert(y[j]);
			s2[y[j]].insert(x[j]);
		}
		sort(pr + 1, pr + q + 1);
		for (register int j = 1; j <= q; j++){
			int pos = pr[j].second;
			v10[x[pos]][y[pos]] = j;
		}
		for (register int j = 1; j <= n; j++){
			for (register int k = 1; k <= m; k++){
				if (v9[j][k] == 0) blank_insert(j, k, n, m, q);
			}
		}
		for (register int j = q; j >= 1; j--){
			int cur_root, pos;
			set<int>::iterator it;
			chess_erase(x[j], y[j], n, m, q);
			blank_insert(x[j], y[j], n, m, q);
			cur_root = get_root(v1[x[j]][y[j]]);
			ans[j] = 0;
			for (register int k = 1; k <= P; k++){
				int new_x = x[j] + dx[k], new_y = y[j] + dy[k];
				if (new_x >= 1 && new_x <= n && new_y >= 1 && new_y <= m && get_road_type(x[j], y[j], dx[k], dy[k]) == 1 && check(j, new_x, new_y) && get_val(seg_root1[cur_root], 1, sz, v1[new_x][new_y]) == 0 && get_val(seg_root3[cur_root], 1, sz, v1[new_x][new_y]) == 0) ans[j]++;
			}
			it = s1[x[j]].upper_bound(y[j]);
			pos = v5[x[j]][y[j]];
			if (it != s1[x[j]].end()) pos = min(pos, *it - 1);
			if (pos > y[j]) ans[j] += (pos - y[j]) - get_sum(seg_root1[cur_root], 1, sz, v1[x[j]][y[j] + 1], v1[x[j]][pos]);
			if (pos < v5[x[j]][y[j]] && check(j, x[j], pos + 1) && get_val(seg_root3[cur_root], 1, sz, v1[x[j]][pos + 1]) == 0) ans[j]++;
			pos = v7[x[j]][y[j]];
			if (it != s1[x[j]].begin()) pos = max(pos, *(--it) + 1);
			if (pos < y[j]) ans[j] += (y[j] - pos) - get_sum(seg_root1[cur_root], 1, sz, v1[x[j]][pos], v1[x[j]][y[j] - 1]);
			if (pos > v7[x[j]][y[j]] && check(j, x[j], pos - 1) && get_val(seg_root3[cur_root], 1, sz, v1[x[j]][pos - 1]) == 0) ans[j]++;
			it = s2[y[j]].upper_bound(x[j]);
			pos = v6[x[j]][y[j]];
			if (it != s2[y[j]].end()) pos = min(pos, *it - 1);
			if (pos > x[j]) ans[j] += (pos - x[j]) - get_sum(seg_root2[cur_root], 1, sz, v2[x[j] + 1][y[j]], v2[pos][y[j]]);
			if (pos < v6[x[j]][y[j]] && check(j, pos + 1, y[j]) && get_val(seg_root3[cur_root], 1, sz, v1[pos + 1][y[j]]) == 0) ans[j]++;
			pos = v8[x[j]][y[j]];
			if (it != s2[y[j]].begin()) pos = max(pos, *(--it) + 1);
			if (pos < x[j]) ans[j] += (x[j] - pos) - get_sum(seg_root2[cur_root], 1, sz, v2[pos][y[j]], v2[x[j] - 1][y[j]]);
			if (pos > v8[x[j]][y[j]] && check(j, pos - 1, y[j]) && get_val(seg_root3[cur_root], 1, sz, v1[pos - 1][y[j]]) == 0) ans[j]++;
			ans[j] += size[cur_root] + get_sum(seg_root4[cur_root][3 - v9[x[j]][y[j]]], 1, q, 1, v10[x[j]][y[j]]) - 1;
			v9[x[j]][y[j]] = v10[x[j]][y[j]] = 0;
		}
		for (register int j = 1; j <= q; j++){
			printf("%d\n", ans[j]);
		}
	}
	return 0;
}
```

---


# [CTSC2018] 青蕈领主

## 题目背景

“也许，我的生命也已经如同风中残烛了吧。”小绿如是说。

## 题目描述

小绿同学因为微积分这门课，对“连续”这一概念产生了浓厚的兴趣。小绿打算把连续的概念放到由整数构成的序列上，他定义一个长度为 $m$ 的整数序列是连续的，当且仅当这个序列中的最大值与最小值的差，不超过$m-1$。例如 $\{1,3,2\}$ 是连续的，而 $\{1,3\}$ 不是连续的。

某天，小绿的顶头上司板老大，给了小绿 $T$ 个长度为 $n$ 的排列。小绿拿到之后十分欢喜，他求出了每个排列的每个区间是否是他所定义的“连续”的。然而，小绿觉得被别的“连续”区间包含住的“连续”区间不够优秀，于是对于每个排列的所有右端点相同的“连续”区间，他只记录下了长度最长的那个“连续”区间的长度。也就是说，对于板老大给他的每一个排列，他都只记录下了在这个排列中，对于每一个 $1 \le i \le n$，右端点为 $i$ 的最长“连续”区间的长度 $L_i$。显然这个长度最少为 $1$，因为所有长度为 $1$ 的整数序列都是连续的。

做完这一切后，小绿爬上绿色床，美美地做了一个绿色的梦。

可是第二天醒来之后，小绿惊讶的发现板老大给他的所有排列都不见了，只剩下他记录下来的 $T$ 组信息。小绿知道自己在劫难逃，但是作为一个好奇的青年，他还是想知道：对于每一组信息，有多少个和信息符合的长度为 $n$ 的排列。

由于小绿已经放弃治疗了，你只需要告诉他每一个答案对 $998244353$ 取模的结果。

我们并不保证一定存在至少一个符合信息的排列，因为小绿也是人，他也有可能犯错。

## 说明/提示

### 数据规模

测试点编号|$n\le$|$T\le$|特殊性质
-|-|-|-
1~2|10|1|无
3~4|10|100|无
5|300|1|$L_{i,j}=j$
6|300|1|$L_{i,j}=1$ 且 $j<n$
7~8|300|100|无
9|1000|1|$L_{i,j}=1$ 且 $j<n$
10~12|1000|100|无
13~16|5000|100|无
17~20|50000|100|无

对于所有测试数据，$1 \le T \le 100,1 \le N \le 50000,1 \le L_{i,j} \le j$。  
本题部分测试点的输入规模较大，请注意读入效率。

## 样例 #1

### 输入

```
1 3
1 1 3```

### 输出

```
2
```

# 题解

## 作者：Weng_Weijie (赞：25)

这篇文章参考了其他人的题解，结合了我自己的理解，希望大家喜欢

***
### 题意

$\mathrm{Definition}$

> 极长连续区间: 若 $[l,r]$ 对应的值为 $\alpha_l,\dots,\alpha_r$, 且 $\max p -\min p + 1=r - l+1$，则 $[l,r]$ 称为连续区间，对一个 $i$， 找到最大的 $j$，使得 $[i-j+1,i]$ 是连续区间，称 $[i-j+1,i]$ 为极长连续区间

> 对于一个排列 $\alpha$，用 $L_i$ 表示以第 $i$ 个元素为右端点的极长连续区间长度

给定 $L_i$ 求满足条件的排列 $\alpha$ 的个数

***

### 题解

#### Part 1

$\mathrm{Theorem}\space 1.1$

> $L_n=n$

$\mathrm{Proof}\space 1.1$

> 显然整个排列就是一个极长连续区间

$\mathrm{Theorem}\space 1.2$

> 极长连续区间要么相包含，要么没有交

$\mathrm{Proof}\space 1.2$

> 如果两个极长连续区间相交而不包含，显然这两个极长连续区间的并也是连续区间，从而右边的极长连续区间不满足极长连续子区间的定义

由 *定理1.1* 和 *定理1.2* 可以总结出无解的条件

接下来的叙述可以说明当且仅当不满足上两个条件之一时无解

$\mathrm{Theorem}\space 1.3$

> 将每个极长连续区间找到最短的包含它的极长连续区间，会形成一个树型结构

$\mathrm{Proof}\space 1.3$

> 除了 $L_n$ 以外其他极长连续区间，都能找到一个最短的极长连续区间

#### Part 2

接下来将考虑如何计数

$\mathrm{Definition}$

> 令 $f_n$ 表示满足 $L_i=1\space (i\in [1,n])$ 的 $n+1$ 阶排列数量

> 若将一个连续区间 $[l,r]$ 提取出来，$L$ 不变，只考虑这些元素的相对大小关系，可以看成是一个 $r-l+1$ 阶排列，得到的一段区间的答案记做 $A[l,r]$，这道题即求 $A[1,n]$

$\mathrm{Theorem}\space 2.1$

> 若极长连续区间 $[l,r]$ 在树型关系中有 $k$ 个儿子分别为 $[p_0,p_1-1],[p_1,p_2-1]\dots,[p_{k-1},p_k-1]$，则 $A[l,r]=f(k)\displaystyle\prod_{i=0}^{k-1} A[p_i,p_{i+1}-1]$

$\mathrm{Proof}\space 2.1$

> 可以发现 $p_0=l,p_k=r$，由于 $[p_i,p_{i+1}-1]$ 这若干个区间是连续的，所以这 $k$ 个区间包括 $[r,r]$ 总共 $k+1$ 个区间相对大小关系是确定的，即要么 $A$ 中每个元素都小于 $B$ 中每个元素，要么都大于

> 将这 $k+1$ 个区间按照大小关系给定一个 $k+1$ 阶排列，在这  $k+1$ 阶排列中的连续区间，在原区间中也是连续区间

> 因此除了 $[r,r]$ 有一个长度为 $k+1$ 的极长连续区间， 其余均不能有长度大于 $1$ 的连续区间，否则在原排列中就不是极长连续区间

> 因此方案数为每个内部区间的方案数乘积再乘上 $f(k)$

$\mathrm{Theorem}\space 2.2$

> 设 $s_i$ 为以 $i$ 结尾极长连续区间树型结构中儿子个数，则答案为 $\displaystyle\prod_{i=1}^nf(s_i)$

$\mathrm{Proof}\space 2.2$

> 根据 *定理2.1* 将其展开即可

由 *定理2.1* 或 *定理2.2* 说明了之前无解条件的问题

#### Part 3

接下来的问题变为了如何求 $f(n)$

$\mathrm{Theorem}\space 3.1$

> $f(n)$ 等于所有连续区间要么包含 $n+1$，要么长度为 $1$ 的 $n+1$ 阶排列个数

$\mathrm{Prood}\space 3.1$

> 考虑排列 $\alpha$ 的逆 $\alpha^{-1}$

> 考虑连续区间 $[l,r]$ 的对应的值为 $[L,R]$ 那么在 $\alpha^{-1}$ 中 $[L,R]$ 对应的值为 $[l,r]$

> 若 $[l,r]$ 不是一个连续区间，那么 $\alpha_l,\dots,\alpha_r$ 不是一个区间

> 即原排列和逆排列的连续区间一一对应

> 原排列中的连续区间要么包含最后一个元素，要么长度为 $1$，因此逆排列中的连续区间要么包含 $n+1$，要么长度为 $1$

接下来考虑计算在后一个意义下计算 $f(n)$

记满足该性质的排列为合法排列

$\mathrm{Theorem}\space 3.3$

> 当 $n>2$ 时，$f(n)=(n-1)f(n-1)+\displaystyle\sum_{i=2}^{n-2}(n-i-1)f(i)f(n-i), f(0)=1, f(1)=2$

$\mathrm{Proof}\space 3.3$

> 考虑将 $n$ 阶排列中每个元素 $+1$ 然后插入 $1$ 来得到合法 $n+1$ 排列

> 分两种情况：

> (1) 原排列合法，此时插入 $1$ 只要不插入在 $2$ 旁边即可得到一个新的合法排列

> 假设产生了一个新的不经过最大值的连续区间 $[l,r]$，那么它一定经过 $1$，即 值域为 $[1,x]$，而此时原排列的区间 $[l,r-1]$ 的值域为 $[1,x-1]$，因此与它是合法区间矛盾

> (2) 原排列不合法，此时刚好有一个不经过最大值，长度 $>1$ 且不被其他极大连续区间包含的极大连续区间，否则插入一个 $1$ 并不会使两个极大连续区间同时消失，即不会变得合法

> 设这个原排列中极大连续区间长度为 $l$，值域为 $[x,x+l-1]$

> 首先 $x > 1$，不然插入后的这个区间也是连续的，然后因为原区间不经过最大值，因此 $x+l-1<n$，$2 \leq x \leq n-l$，所以 $x$ 的取值共有 $n-l-1$ 种

> 再考虑 $l$ 的范围，$l\geq 2$ 是显然的，而为了 $x$ 有取值 $n-l\geq 2$，即 $l\leq n-2$

> 再考虑方案数，先考虑这个特殊区间的方案数，这个区间中没有 $2$，因此经过 $1$ 的子区间都不会是连续的，于是把 $1$ 看做 $l+1$，其他的元素按大小关系编号为 $1\sim l$，方案数为 $f(l)$，接下来无视这个 $1$，将这个区间和其他 $n-l$ 个元素按照大小关系编号为 $1\sim n-l+1$，方案数为 $f(n-l)$，可以证明不会有新增的连续区间，证明方法与第一种情况类似

至此，这道题就做完了，可以用单调栈求出每个极长连续区间的儿子个数，用分治+FFT 求 $f(n)$。事实上OEIS上有这个序列，也可以参考一下 [A090753](http://oeis.org/A090753)

感谢 @CaptainSlow 在 Theorem 3.3 处指出的一处错误。

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <algorithm>

namespace IO {
	char rbuf[(int) 1e8], *in = rbuf, ch;
	void init() {
		std::fread(rbuf, 1, 1e8, stdin);
	}
	char getchar() {
		return *in++;
	}
	void read(int &x) {
		while (std::isspace(ch = getchar())); x = ch & 15;
		while (std::isdigit(ch = getchar())) x = x * 10 + (ch & 15);
	}
}
const int N = 131072;
using LL = long long;
int n, f[N], lim, s, rev[N], wn[N], w[N];
const int mod = 998244353;
int pow(int x, int y) {
	int ans = 1;
	for (; y; y >>= 1, x = (LL) x * x % mod)
		if (y & 1) ans = (LL) ans * x % mod;
	return ans;
}
void fftinit(int len) {
	wn[0] = lim = 1, s = -1; while (lim < len) lim <<= 1, ++s;
	for (int i = 0; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
	const int g = pow(3, (mod - 1) / lim);
	for (int i = 1; i < lim; ++i) wn[i] = (LL) wn[i - 1] * g % mod;
}
void reduce(int &x) { x += x >> 31 & mod; }
void fft(int *A, int typ) {
	for (int i = 0; i < lim; ++i)
		if (i < rev[i]) std::swap(A[i], A[rev[i]]);
	for (int i = 1; i < lim; i <<= 1) {
		const int t = lim / i / 2;
		for (int k = 0; k < i; ++k) w[k] = wn[t * k];
		for (int j = 0; j < lim; j += i << 1)
			for (int k = 0; k < i; ++k) {
				const int x = A[k + j], y = (LL) A[k + j + i] * w[k] % mod;
				reduce(A[k + j] += y - mod), reduce(A[k + j + i] = x - y);
			}
	}
	if (!typ) {
		std::reverse(A + 1, A + lim);
		const int il = pow(lim, mod - 2);
		for (int i = 0; i < lim; ++i)
			A[i] = (LL) A[i] * il % mod;
	}
}
int A[N], B[N];
void mul(int *A, int *B, int n, int m, int *ret, int len) {
	static int tA[N], tB[N];
	fftinit(n + m - 1);
	std::memcpy(tA, A, n << 2), std::memset(tA + n, 0, lim - n << 2);
	std::memcpy(tB, B, m << 2), std::memset(tB + m, 0, lim - m << 2);
	fft(tA, 1), fft(tB, 1);
	for (int i = 0; i < lim; ++i)
		tA[i] = (LL) tA[i] * tB[i] % mod;
	fft(tA, 0);
	std::memcpy(ret, tA, len << 2);
}
void solve(int l, int r) {
	if (l + 1 == r) { reduce(f[l] += (LL) (l - 1) * f[l - 1] % mod - mod); return; }
	int mid = l + r + 1 >> 1;
	solve(l, mid);
	if (l > 1) {
		for (int i = l; i < mid; ++i)
			A[i - l] = (LL) (i - 1) * f[i] % mod;
		B[0] = B[1] = 0;
		for (int i = 2; i < r - l; ++i)
			B[i] = f[i];
		mul(A, B, mid - l, r - l, A, r - l);
		for (int i = mid; i < r; ++i)
			reduce(f[i] += A[i - l] - mod);
		A[0] = A[1] = 0;
		for (int i = 2; i < r - l; ++i)
			A[i] = (LL) (i - 1) * f[i] % mod;
		for (int i = l; i < mid; ++i)
			B[i - l] = f[i];
		mul(A, B, r - l, mid - l, A, r - l);
		for (int i = mid; i < r; ++i)
			reduce(f[i] += A[i - l] - mod);
	} else {
		A[0] = A[1] = B[0] = B[1] = 0;
		for (int i = 2; i < mid; ++i)
			A[i] = (LL) (i - 1) * f[i] % mod, B[i] = f[i];
		mul(A, B, mid, mid, A, r);
		for (int i = mid; i < r; ++i)
			reduce(f[i] += A[i] - mod);
	}
	solve(mid, r);
}
int tc, L[N], stack[N], top;
void solve() {
	for (int i = 1; i <= n; ++i)
		IO::read(L[i]);
	if (L[n] != n)
		return void(std::puts("0"));
	top = 0;
	int ans = 1;
	for (int i = 1; i <= n; ++i) {
		int _cnt = 0;
		while (top) {
			if (i - L[i] + 1 <= stack[top] && i - L[i] > stack[top] - L[stack[top]]) {
				return void(std::puts("0"));
			}
			if (i - L[i] + 1 <= stack[top])
				++_cnt, --top;
			else
				break;
		}
		stack[++top] = i;
		ans = (LL) ans * f[_cnt] % mod;
	}
	std::printf("%d\n", ans);
}
int main() {
	IO::init();
	f[0] = 1, f[1] = 2;
	IO::read(tc), IO::read(n);
	solve(1, n);
	while (tc--)
		solve();
	return 0;
}
```

---

## 作者：2014吕泽龙 (赞：18)

Upd：感谢@Zhang_RQ提供的Hack题解，果然还是太弱了我推式子又出锅了

[蕈](https://hanyu.baidu.com/zici/s?wd=%E8%95%88&query=%E8%95%88&srcid=28232&from=kg0&from=kg0)xùn不谢。
### **分析**
吹爆这道神仙题。
#### **First：判断无解**
每个极大“连续”区间不可以相交，并且$L_n=n$

必要性：

因为每个连续区间内是连续的数字，有因为是排列所以数字不会重复，所以如果相交了的话肯定可以把后面的区间扩展到前面的那个区间，极大性就不满足了啊。
#### **Second：问题转化**
既然所有区间要么包含要么不相交，那么把每个点代表的区间和往右第一个包含它的区间连边，形成了一颗树形结构。

对于每个儿子所代表的一定是一段极大连续区间，而所有儿子加上当前节点也构成了一个极大连续区间，考虑把每个儿子缩成一个点再按大小编号，就构成了一个排列，探究这个排列的性质。
既然是"极大"的，那么一定不能有两个儿子的区间可以合并成一个新的连续区间。

所以对于每个节点，假设它一共有$sz$个儿子。那么等价第构造一个$sz+1$阶排列，**满足这个排列的$L$值为$1,1,1,\cdots, sz+1$，也就是除了最后一个节点，不存在任何一个大于1的连续子区间**。我们称这个排列为**合法排列**。

我们设这个值为$f$，那么答案就是$\prod f(sz_i)$

为了方便推导，下面的$f_i$表示的将长度为$i+1$的合法排列个数。

顺便说一句，这个$sz$用单调栈扫一遍即可。

#### **Second：计数Dp**
事实上，基于$f$本身的性质就可以得到递推式
$f_i=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(j-1)f_jf_{i-j}$

考虑在$1\cdots i$的基础之上插入$i+1$
##### **Step1：$1 \cdots i$是一个合法的排列**
除了$i$的两边，都可以插，一共$i-1$个位置，方案数$(i-1)f_{i-1}$。
##### **Step2：$1 \cdots i$不是合法的排列**
$i+1$的插入“打破”了原有的一个连续子区间。

首先这个子区间只能有一个。

所以我们可以把这个子区间合并成一个节点，对这个排列重新标号之后，这个排列就是合法的了。

枚举这个子区间的长度$j$，合并之后有$i-j+1$个节点，方案数是$f_{i-j}$。其中$j\in[2,i-2]$

对于每个$j$，考虑有多少种合法的值域选取。

也就是对于合并完之后$1\cdots i-j+1$的排列再把它选一个点“拆开”。

首先值为$i-j+1$的那个区间肯定不能拆，因为拆完之后值域是$[i-j+1,i]$，包括$i$的话插入$i+1$仍然是一个连续子区间。

其次这个连续子区间不在排列末尾，所以最后一个值也不能选。

又由于最后一个值一定不会是$i+j-1$（否则去掉最后一个值就是一个连续子区间不合法了），所以不管哪种情况都妥妥挖掉两个点。

所以选取的总方案是$i-j+1-2=i-j-1$

到目前为止的方案是
$(i-j-1)f_{i-j}$

考虑什么样的$j$阶排列和$i+1$是满足条件的。我们发现，插入$i+1$需要打破之前这个$j$阶排列的所有连续子区间。也就是说，插入了$i+1$之后$1\cdots j$的之前的所有连续子区间都经过$i+1$。

那么一个很自然的思路就是将$i+1$看成$j+1$，那么方案**就是一个$j+1$的排列，满足所有连续子区间经过最大值**。

不会怎么办？

算了先打个表找找规律试试。

诶诶？这个表怎么有点眼熟。

等等它好像和我之前打的$f_i$的表长得一样？

那石锤了，就这样吧。

~~假装我真的推到了这一步，打过表~~

考场中如果打了这个表这题不是赚翻了。

这样的话递推式已经出来了啊。
把之前的方案乘上$f_j$

$f_i=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(i-j-1)f_jf_{i-j}=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(j-1)f_jf_{i-j}$

下面考虑证明一下这个性质。

##### **Step3：巧妙的置换**
证明的思路非常神仙。

考虑原排列的逆$b_{a_i}=i$

这个排列和原排列好像关系不大。但是我们关心的东西是连续子区间。

考虑原排列的一个连续区间，假设下标为$[i,j]$，值域为$[a_l,a_r]$。
考虑逆置换之后，下标为$[a_l,a_r]$，值域为$[i,j]$
所以说，**对于原排列的连续区间和新排列之中的一一对应**。

这个时候，我们考虑原来的合法排列长啥样了？

我们原来合法的排列的连续子区间全部都是这个排列的后缀子区间，也就是说，它们都经过最后一个点。

而最后一个点被怼到哪里了我们不知道，但我们知道它的值是最大值。

所以抓这个最大值不放，**原来合法的排列在新排列中的连续子区间必定经过最大值**。

所以两者的方案是一一对应的。

事实上，如果最开始就想到了这个神仙性质，可以直接利用这个性质去推，会推出一样的式子。

但是如果正着推+打表辅助，会让这道题在神仙的同时增加一点点可做的成分，思路也变得自然很多（蒟蒻视角）。

#### **Third：Cdq分治+FFT**
剩下进入了套路时间。(蒟蒻表示仍然不会啊T-T)

$f_i=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(j-1)f_jf_{i-j}$

理论上它就很$Cdq+FFT$啊。

$Cdq$是考虑$[L,mid]$去卷$[1,R-L]$，贡献给$[m+1,R]$

可是$[R-L]$没求不是凉凉吗，毕竟是我 卷 我 自 己啊。

一种思路是，每次仅仅盯住两部分的贡献$[L,m]$卷$[L,m]$

以及$[L,m]$卷$[1,min(L-1,R-L)]$，也就是$[L,m]$区间之前的部分。
这样的话会有一个问题，就是$[L,m]$卷不到$[L,m]$之后的部分。

考虑每次$[L,m]$卷之前的部分。$[1,min(L-1,R-L)]$这个区间内肯定没有卷到之后的部分，我们再卷$[L,m]$和$[1,min(L-1,R-L)]$的时候把“历史遗留问题”解决掉。

本来是得$[L,m]$和$[1,min(L-1,R-L)]$，$[1,min(L-1,R-L)]$和$[L,m]$分别卷积的。

但是注意到$(j-1)f_jf_{j-i}+(i-j-1)f_{j-i}f_j=(i-2)f_jf_{i-j}$
所以卷一次之后直接乘上$(i-2)$就好了。

复杂度$O(nlog^2+Tn)$
### **代码**
```cpp
#include<bits/stdc++.h>
const int N = 2e5 + 10, P = 998244353;
int ri() {
    char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
    for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
int R[N], w[N], f[N], q[N], a[N], b[N], l[N], L, InvL;
int mul(int a, int b) {return 1LL * a * b % P;}
int add(int a, int b) {return a += b, a >= P ? a - P : a;}
int fix(int x) {return (x >> 31 & P) + x;}
int Pow(int x, int k) {
    int r = 1;
    for(;k; x = mul(x, x), k >>= 1)
        if(k & 1)
            r = mul(r, x);
    return r;
}
void Pre(int m) {
    L = 1; int x = 0;
    for(;(L <<= 1) < m;) ++x;
    for(int i = 0;i < L; ++i)
        R[i] = R[i >> 1] >> 1 | (i & 1) << x;
    w[0] = 1; int wn = Pow(3, (P - 1) / L);
    for(int i = 1;i < L; ++i) 
        w[i] = mul(w[i - 1], wn);
    InvL = Pow(L, P - 2);
}
void DNT(int *F) {
    for(int i = 0;i < L; ++i)
        if(i < R[i])
            std::swap(F[i], F[R[i]]);
    for(int i = 1, d = L >> 1;i < L; i <<= 1, d >>= 1)
        for(int j = 0;j < L; j += i << 1) {
            int *l = F + j, *r = F + i + j, *p = w, tp;
            for(int k = i; k--; ++l, ++r, p += d)
                tp = mul(*r, *p), *r = fix(*l - tp), *l = add(*l, tp);
        }
}
void Mul(int *A, int *B, int n, int m) {
    Pre(n + m);
    for(int i = n;i < L; ++i) A[i] = 0;
    for(int i = m;i < L; ++i) B[i] = 0;
    DNT(A); DNT(B);
    for(int i = 0;i < L; ++i)
        B[i] = mul(A[i], B[i]);
    DNT(B);
    for(int i = 0;i < L; ++i)
        A[i] = mul(B[L - i & L - 1], InvL);
}
void Cdq(int L, int R) {
    if(L == R) {
        f[L] = add(f[L], mul(L - 1, f[L - 1]));
        return ;
    }
    int m = L + R >> 1;
    Cdq(L, m);
    for(int i = L; i <= m; ++i)
        a[i - L] = mul(f[i], i - 1), 
        b[i - L] = f[i];
    Mul(a, b, m - L + 1, m - L + 1);
    for(int i = std::max(L << 1, m + 1); i <= R; ++i)
        f[i] = add(f[i], a[i - (L << 1)]);
    if(L != 2) {
        int d = std::min(L - 1, R - L);
        for(int i = 2;i <= d; ++i)
            a[i - 2] = f[i];
        for(int i = L;i <= m; ++i)
            b[i - L] = f[i];
        Mul(a, b, d - 1, m - L + 1);
        for(int i = std::max(L + 2, m + 1); i <= R; ++i)
            f[i] = add(f[i], mul(a[i - L - 2], i - 2));
    }
    Cdq(m + 1, R);
}
int main() {
    int T = ri(), n = ri(); 
    f[0] = 1; f[1] = 2;
    if(n > 2) Cdq(2, n - 1);
    for(;T--;) {
        bool flag = true; int Ans = 1, top = 0;
        for(int i = 1;i <= n; ++i)
            l[i] = ri();
        if(l[n] != n || l[1] != 1) {puts("0"); continue;}
        for(int i = 1;i <= n; ++i) {
            int cnt = 0; flag = true;
            for(;top && i - l[i] + 1 <= q[top];) {
                if(i - l[i] + 1 > q[top] - l[q[top]] + 1) {
                    flag = false; break;
                }
                --top; ++cnt;
            }
            if(flag == false) break;
            Ans = mul(Ans, f[cnt]);
            q[++top] = i;
        }
        printf("%d\n", !flag ? 0 : Ans);
    }
    return 0;
}

```


---

## 作者：加藤惠 (赞：8)

我来写一篇不一样的更复杂的~~整活~~做法。

我们直接快进到对每个 $i\in[1,n]$ 求所有非平凡连续段必定包含最后一个数的长度为 $i$ 的排列个数，用 $f_i$ 表示。

再令 $g_i$ 表示长度为 $i$ 的不存在非平凡连续段的排列个数。

则可以得到递推式：

$$f_i=\sum_{j=2}^{i-2} f_jg_{i-j+1}+g_n+2\sum_{j=1}^{i-1} \left( -1 \right)^{j+1}f_{i-j}$$

证明：

考虑分类讨论长度小于 $i$ 的最大的连续段的长度 $j$：

1. $j\in [2,i-2]$：考虑枚举长度小于 $i$ 的最大的连续段的长度 $j$，把这一段缩成一个点，且因为 $j$ 是最长的连续段的长度和每个非平凡连续段都必须包含最后一个数，所以把这段缩成一个点后，剩下的排列不能有非平凡连续段，所以方案就是 $g_{i-j+1}$。

2. $j=1$：即不存在非平凡连续段。

3. $j=i-1$：这一部分不为啥不能按照第一部分那么算呢？首先这个时候第一个位置填的必然是 $1$ 或者 $i$，而第二个位置放 $2$ 或者 $i-1$ 的方案也会被我们算进去！于是，我们需要把这些方案减掉，以第一个位置放 $i$ 举例，我们多算了 $\{i,i-1,\dots\}$ 于是要减去 $f_{i-2}$，但这个时候我们又多减去了 $\{i,i-1,i-2,\dots\}$...以此类推就得到了 $\sum_{j=1}^{i-1} \left( -1 \right)^{j+1}f_{i-j}$，填 $1$ 也是类似的，于是再乘上一个 $2$。

---

于是现在问题在于如何快速求 $g$ 的前 $n$ 项。

印象里前不久在 UOJ 群听 EI 说这个问题已经能做了，于是跑到 UOJ 群去问了下，然后 myh 直接往群里丢了份解题报告。

一点开往下滑：

![](https://cdn.luogu.com.cn/upload/image_hosting/0zyyhqig.png)

？？？

好家伙，小丑竟是我自己。

不过继续往下滑后还是看到了一种不用基于这个问题的解法。

令 $F(x)$ 为答案的生成函数，$G(x)$ 为满足对应的析合树根节点为合点且儿子的值域区间单调增的 $n$ 阶排列方案数的生成函数（不包括
$1$ 阶排列），$H(x)$ 为 $n$ 阶全排列方案数的生成函数。

当根节点为合点且儿子的值域区间单调增时，则每个儿子不能满足
该性质（除非是叶子节点），所以有：

$$G(x)=\sum_{i=2}^{\infty} (H(x)-G(x))^i$$

解得：

$$G(x)=\frac{H^2(x)}{H(x)+1}$$

一个排列对应的析合树的根节点除了合点的情况，还有析点的情况。

注意到根节点为析点的排列方案数的生成函数恰好为 $F(H(x))$。

于是有：

$$F(H(x))+2G(x)+x=H(x)$$

首先注意到 $H(x)$ 存在复合逆 $I(x)$。

我们对这个式子做一些变形：

$$
\begin{aligned}
F(H(x))&=H(x)-x-2G(x)\\
F(x)&=H(I(x))-I(x)-2G(I(x))\\
&=x-I(x)-\frac{2H^2(I(x))}{H(I(x))+1}\\
&=x-\frac{2x^2}{x+1}-I(x)
\end{aligned}
$$

对比对应项系数，我们可以得到 $g_n=-[x^n]I(x)+2\cdot\left(-1 \right)^{n+1}$，这个和 [OEIS](http://oeis.org/search?q=1%2C2%2C0%2C2%2C6%2C46&language=english&go=Search) 上的式子是一样的。

现在问题又转为求 $H(x)=\sum_{n\ge 1}n!x^n$ 的复合逆。

~~我也不知道怎么想到的~~我们知道 $H(x)$ 满足 $\text{ODE}$：

$$
\begin{aligned}
H(x)&=H'(x)x^2+H(x)x+x\\
H(I(x))&=\frac{1}{I'(x)}(\frac{d}{dx}H(I(x)))I^2(x)+H(I(x))I(x)+I(x)\\
x&=\frac{1}{I'(x)}I^2(x)+I(x)x+I(x)\\
0&=I^2(x)-I'(x)x+(x+1)I(x)I'(x)
\end{aligned}
$$

比较对应项系数，我们可以得到 $c_n=[x^n]I(x)$ 的递推式：

$$c_n=-\sum_{i=1}^{n-1} (i+1)c_ic_{n-i}-\sum_{i=2}^{n-1} ic_ic_{n-i+1}$$

于是原问题可以通过分治 $\text{FFT}$ 先求出 $c$ 再通过 $c$ 求出 $g$，再分治 $\text{FFT}$ 求出 $f$，在 $O(n\log^2 n+Tn)$ 的时间复杂度内解决本题。

---

再稍微提下分治 $\text{FFT}$ 是自己卷自己的情况。

这里需要按 $l$ 的值分两种情况讨论：

1. $l\ne 1$

此时原先的做法是正确的。

2. $l=1$

这个时候因为 $\left[mid+1,r\right]$ 内的值还没算出来，于是少算了 $\left[1,mid\right]$ 卷上 $\left[mid+1,r\right]$ 的贡献。

但是注意到 $\left[mid+1,r\right]$ 区间，其左端点是不等于 $1$ 的，于是我们可以在 $\text{solve}(mid+1,r)$ 的时候再算。

于是具体流程就是：

首先递归 $\text{solve}(l,mid)$ 计算完 $[l,mid]$ 之后，

若 $l=1$，则只计算 $[1,mid]$ 卷上 $[1,mid]$ 的贡献。

若 $l\ne 1$，先做 $[l,mid]$ 卷上 $[1,r-l]$ 的贡献，然后再计算 $[1,r-l]$ 卷上 $[l,mid]$ 的贡献以补偿在 $l=1$ 时的未计算量。

最后递归计算 $\text{solve}(mid+1,r)$。

---

## 作者：Great_Influence (赞：8)

首先可以先将无解的情况判掉。无解的情况有两种，一种就是出现两段区间相交而不包含(证明显然)，另一种是$L_n\not=n$。我们在输入时就可以直接处理出。

然后，开始对问题进行具体分析。对于一段长区间，因为每段小区间的数字必然是连续的，所以我们可以将每一段小区间缩成一个点，这样计算得到的结果必然与原问题相等。因此，我们设$f_i$表示长度为$i+1$**(注意)**的**除全区间外不存在连续最长子区间**的**排列**个数。

但是$f_i$难以计算。我们考虑进行转模。我们设$b_{a_i}=i$。可以发现，原序列的连续子区间都对应着该序列的连续自区间，且在原序列包含最后一个节点的连续子区间对应着该序列所有**包含最大值**的子区间。那么，我们修改$f_i$的定义为**除包含最大值外不存在连续最长子区间**的**排列**个数。可以发现，该定义与之前的定义等价。那么，我们按照后一个定义开始计算。经过分析~~打表~~后可以得到以下关系式:

$$f_n=(n-1)f_{n-1}+\sum_{i=2}^{n-2}(i-1)f_if_{n-i}$$

推导过程如下:

考虑从某个长度为$n$的排列插入一个数得到合法序列。

1. 当该序列本来就合法时:我们考虑将原序列数字整体$+1$,然后再插入$1$。可以知道，只要这个$1$的位置与$2$不相邻即可。其方案数为$n-1$。

2. 当该序列本来不合法时:我们考虑向它中间插入最大值来得到合法序列。可以知道，原序列一定只有$1$个不经过最大值的连续最长子区间。我们尝试枚举该区间的长度(范围为$[2,n-2]$)。假设该区间长度为$l$，那么最大值会插入在这个区间内并将这个区间分成两部分。如果考虑这两部分与最大值的整体，可以发现就是一个长度为$l+1$的合法区间，其方案数为$f_l$。这一段区间的值域范围为$[x,x+l-1]$，合法值域共有$n-l-1$个。剩余$n-l$个数字构成另一个合法区间，方案数为$f_{n-l}$。

综上所述，可以得到推导式:

$$f_n=(n-1)f_{n-1}+\sum_{l=2}^{n-2}(n-l-1)f_lf_{n-l}$$

$$=(n-1)f_{n-1}+\sum_{l=2}^{n-2}(l-1)f_lf_{n-l}$$

该式明显可以利用分治$FFT$进行优化计算，时间复杂度为$O(n\log^2 n)$。然后计算答案时，我们将子区间缩成$1$个点，假设此时当前母区间包含$cnt_i$个点(缩点之后)，那么它的贡献就是$f_{cnt_i}$。然后总方案数就是$\displaystyle\prod_{i=1}^n f_{cnt_i}$。

后半部分利用栈可以做到$O(n)$处理。总时间复杂度为$O(n\log^2 n+Tn)$。

注意本题的分治$FFT$的结构与一般情况不同，过程有很大区别。

代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
#endif
}

const int MAXN=(1<<17)+7;

static int TT,n;

namespace polynomial
{
	const int mod=998244353,g=3;

	inline int power(int u,int v)
	{
		static int sm;
		for(sm=1;v;v>>=1,u=(uint64)u*u%mod)if(v&1)
			sm=(uint64)sm*u%mod;
		return sm;
	}

	static int Len,rev[MAXN],lg[MAXN];

	inline void predone(){Rep(i,2,Len)lg[i]=lg[i>>1]+1;}

	inline void calrev(int Len)
	{
		Rep(i,1,Len)rev[i]=
			(rev[i>>1]>>1)|((i&1)<<lg[Len]-1);
	}

	inline int ad(int u,int v){return(u+=v)>=mod?u-mod:u;}

	inline void NTT(int *a,int typ)
	{
		Rep(i,1,Len-1)if(rev[i]>i)swap(a[rev[i]],a[i]);
		static int i,j,k,kk,w,wn,t;
		for(k=2;k<=Len;k<<=1)
		{
			kk=k>>1;wn=power(g,(mod-1)/k);
			for(i=0;i<Len;i+=k)
				for(w=1,j=0;j<kk;++j,w=(uint64)w*wn%mod)
				{
					t=(uint64)w*a[i+j+kk]%mod;
					a[i+j+kk]=ad(a[i+j],mod-t);
					a[i+j]=ad(a[i+j],t);
				}
		}
		if(typ==-1)
		{
			reverse(a+1,a+Len);
			static int invn;invn=power(Len,mod-2);
			Rep(i,0,Len-1)a[i]=(uint64)a[i]*invn%mod;
		}
	}

	inline void mul(int *A,int *B)
	{
		NTT(A,1);NTT(B,1);
		Rep(i,0,Len-1)A[i]=(uint64)A[i]*B[i]%mod;
		NTT(A,-1);
	}

	static int A[MAXN],B[MAXN];

	void cdqFFT(int *f,int l,int r)
	{
		if(l==r)
		{
			f[l]=ad(f[l],(uint64)(l-1)*f[l-1]%mod);
			return;
		}
		int mid=(l+r)>>1;
		cdqFFT(f,l,mid);
		for(Len=r-l+1;Len>(Len&-Len);Len+=(Len&-Len));
		Rep(i,0,Len)A[i]=B[i]=0;
		Rep(i,l,mid)A[i-l]=(uint64)f[i]*(i-1)%mod,B[i-l]=f[i];
		calrev(Len);mul(A,B);
		Rep(i,mid+1,r)if(i>=l*2)f[i]=ad(f[i],A[i-2*l]);
		if(l^2)
		{
			Rep(i,0,Len)A[i]=B[i]=0;
			Rep(i,2,min(l-1,r-l))A[i-2]=f[i];
			Rep(i,l,mid)B[i-l]=f[i];
			mul(A,B);
			Rep(i,mid+1,r)if(i>=l+2)
				f[i]=ad(f[i],(uint64)(i-2)*A[i-l-2]%mod);
		}
		cdqFFT(f,mid+1,r);
	}
}
using namespace polynomial;

static int f[MAXN];

inline void init()
{
	read(TT);read(n);
	f[0]=1;f[1]=2;
	for(Len=4;Len<=n<<1;Len<<=1);
	predone();
	if(n>2)cdqFFT(f,2,n);
}

static int l[MAXN],cnt[MAXN],sta[MAXN],tp;

inline void solve()
{
	static int flg;
	Rep(i,1,TT)
	{
		tp=flg=0;
		Rep(j,1,n)
		{
			read(l[j]);cnt[j]=0;
			while(tp>=0&&sta[tp]>=j-l[j]+1)
			{
				if(sta[tp]-l[sta[tp]]<j-l[j])
				{flg=1;break;}
				++cnt[j],--tp;
			}
			sta[++tp]=j;
		}
		if(flg||l[n]!=n){puts("0");continue;}
		static int ans;ans=1;
		Rep(i,1,n)ans=(uint64)ans*f[cnt[i]]%mod;
		printf("%d\n",ans);
	}
}

int main()
{
    file();
    init();
    solve();
    return 0;
}
```

---

## 作者：苹果蓝17 (赞：7)

显然若将每个 $i$ 对应的区间 $[i-a_i+1,i]$ 画出，这些区间一定形成树的结构，否则不合法。

具体而言，区间 $[i-a_i+1,i-1]$ 一定能被分成若干极长连续的子区间（即儿子）。可以将每个子区间看成一个数，故设子区间个数为 $son_u$，只需要求出形如 `1 1 ... 1 n+1` 问题的答案 $f_n$，答案即为 $\prod\limits_u f_{son_u}$。

利用递归的结构，设 $G(x)=\sum\limits_{i=1}^{+ \infty} i! x^i$，则有：

$$G(x)=xF(G(x))+x$$

$$F(G(x))+1=\dfrac{G(x)}{x}$$

设 $R(x)$ 为 $G(x)$ 的复合逆，代入 $R(x)$ 可得：

$$F(x)=\dfrac{x}{R(x)}-1$$

接下来只需要求 $R(x)$ 即可。注意到 $G(x)$ 是 D-finite 的，可知 $(x-1)G(x)+x^2 G'(x)+x=0$，代入 $R(x)$ 得：

$$x(R(x)-1)+R(x)^2 G'(R(x))+R(x)=0$$

由 $1=G(R(x))'=R'(x) G'(R(x))$，

$$x(R(x)-1)+\dfrac{R(x)^2}{R'(x)}+R(x)=0$$

$$xR(x)R'(x)-xR'(x)+R(x)^2+R(x)R'(x)=0$$

$$\sum\limits_{i=1}^{n-1} ir_ir_{n-i}+\sum\limits_{i=1}^{n-1} r_ir_{n-i}+\sum\limits_{i=1}^{n} ir_ir_{n+1-i}=nr_n$$

$$-r_n=\sum\limits_{i=1}^{n-1} (i+1)r_ir_{n-i}+\sum\limits_{i=2}^{n-1} ir_ir_{n+1-i}$$

分治 FFT 即可。时间复杂度 $O(n \log^2 n)$。

#### 代码

~~常数超大~~

upd：减小了常数

```
long long F[N],G[N],P[N],Q[N];
long long A[N],B[N];
void Devide_solve(long long l,long long r){
	if(l==r){
		G[l]=(mod-G[l])%mod;
		P[l]=(l+1)*G[l]%mod;
		if(l>1) Q[l]=l*G[l]%mod;
		return ;
	}
	long long mid=(l+r)>>1ll;
	Devide_solve(l,mid);
	
	long long lim=r-l+1,len=lim>>1ll;
	
	if(l==1){
		for(long long i=1;i<=len;i++) A[i]=(P[i]+Q[i+1])%mod;
		for(long long i=1;i<=len;i++) B[i]=G[i];
		NTT::solve(A,A,B,len,len);
		for(long long i=len+1;i<=lim;i++){
			int t=i-len+mid;
			G[t]=(G[t]+A[i])%mod;
		}
	}
	else{
		for(long long i=1;i<=len;i++) A[i]=P[l+i-1];
		for(long long i=0;i<=len;i++) A[i]=(A[i]+Q[l+i])%mod;
		for(long long i=1;i<=lim;i++) B[i]=G[i];
		NTT::solve(A,A,B,len,lim);
		for(long long i=len+1;i<=lim;i++){
			int t=i-len+mid;
			G[t]=(G[t]+A[i])%mod;
		}
		
		for(long long i=1;i<=len;i++) A[i]=G[l+i-1];
		for(long long i=1;i<=lim;i++) B[i]=(P[i]+Q[i+1])%mod;
		NTT::solve(A,A,B,len,lim);
		for(long long i=len+1;i<=lim;i++){
			int t=i-len+mid;
			G[t]=(G[t]+A[i])%mod;
		}
	}
	Devide_solve(mid+1,r);
}


long long T,n,ans;
long long a[N];

void solve(long long l,long long r){
	if(a[r]!=r-l+1) ans=0;
	if(l==r) return ;
	long long mx=r,tot=0;
	for(long long i=r-1;i>=l;i--){
		if(i<mx){
			mx=i-a[i]+1;
			solve(mx,i);
			tot++;
		}
		else if(i-a[i]+1<mx) ans=0;
	}
	ans=ans*F[tot]%mod;
}

int main(){
	pre();
	cin>>T>>n;
	
	G[1]=mod-1;
	long long lim=NTT::init(n,0);
	long long m=1ll<<lim;
	Devide_solve(1,m);
	
	for(long long i=0;i<n;i++) F[i]=G[i+1];
	INV::solve(F,F,n);
	
	while(T--){
		for(long long i=1;i<=n;i++) scanf("%lld",&a[i]);
		ans=1;
		solve(1,n);
		printf("%lld\n",ans);
	}
}
```

---

## 作者：251Sec (赞：6)

终于会全在线卷积了。

---

把所有区间 $[i-L_i+1,i]$ 画出来，手玩发现如果存在两个区间相交但不包含那就无解，而且如果 $L_n \ne n$ 也无解。

否则可以把区间画成一个树形结构，对于树上每个点考虑它的填数方案，发现可以把它的每个儿子缩成一个点考虑，那么我们只需要解决这样一个子问题：形如 $L=\{1,1,1,\cdots,n+1\}$ 的方案数计数，设这个方案数为 $f(n)$。我们需要对所有 $n \le 5 \times 10^4$ 求出 $f(n)$。

人类智慧地，在逆排列上考虑，相当于求长度为 $(n+1)$ 的排列，使得所有不包含最大值的区间都不连续。考虑加入最小值 $1$ 并把加入前的所有数加一，讨论加入最小值前序列的情况：

- 加入前序列合法，则最小值只要不放到次小值旁边就行，方案数 $(n-1)f(n-1)$。
- 加入前序列不合法，则加入前只能存在一段极长不合法区间，枚举这段区间的长度 $i$。
  - 首先这段区间原先的最小值不能是 $1$，否则加入后整个区间仍然连续，然后在这个限制下原区间和 $1$ 一起的方案数应当为 $f(i)$，即把原来的元素从小到大标号为 $1 \sim i$，再把加入的 $1$ 视为 $(i+1)$。
  - 这段区间的值域有 $(n-i-1)$ 种选择方法（即不能包含 $1$ 和 $n$）。
  - 然后把这段区间看成整体，并把它按照去掉 $1$ 之后任意元素在排列里的大小关系标号，因为这段区间去掉 $1$ 之后是连续的所以这样的标号方法良定义。因为我们钦定了这个区间是极长的，因此它也拥有不能往外延伸连续不包含 $(n+1)$ 区间的性质。这和原问题完全等价，于是这里的方案数为 $f(n-i)$。
  - 乘起来，方案数为 $(n-i-1)f(i)f(n-i)$。

于是我们得到递推式：

$$
f(n)=(n-1)f(n-1)+\sum_{i=2}^{n-2}(i-1)f(i)f(n-i)
$$

（为了让这个式子比较好看，我们翻转了右边求和的下标）

这是全在线卷积的形式，即形如 $c=a*b$ 的问题，其中 $a,b$ 都需要在线得出。

考虑这种问题的处理方法：不妨设要求 $0 \sim n$ 的 $f$，令 $m=\left\lfloor\frac{n}{2}\right\rfloor$。假设我们已经求出了 $0 \sim m$ 的 $f$，考虑对后面的贡献，设它从 $a_ib_j$ 得到。

- $i,j \le m$。这就是个普通卷积。
- $i \le m$，$j>m$。这是个半在线卷积。
- $j \le m$，$i>m$，这也是个半在线卷积。

我们知道半在线卷积可以简单地在 $O(n \log^2 n)$ 复杂度内求解，则 $T(n)=T\left(\frac{n}{2}\right)+O(n \log^2n)$，由主定理立得总复杂度为 $O(n\log^2 n)$。

[上述算法的暴力卷积实现，80pts。可读性应该挺强的。](/paste/0s4cvvn4)

[NTT 实现，100pts。](https://www.luogu.com.cn/paste/bqng0grd)

---

## 作者：Albert_Wei (赞：0)

我们发现连续的区间一定要么相离，要么包含，所以极长连续区间形成了树形结构。显然有 $L_n = n$。我们发现树的每一层其实是相互独立的，且我们可以把每个点子节点的对应区间视作一个单点，这是因为对于一个值域在 $[x, y]$ 中的连续区间 $[l, r]$，不存在不在区间 $[l, r]$ 中的元素值域在 $[x, y]$ 内，所以我们发现将其视作一个单点，不会影响包含 $[l, r]$ 的区间是否连续。记长度为 $n$ 满足 $L = 1, 1, \cdots, 1, n + 1$ 的排列是好排列，个数为 $f_n$，$c_i$ 为以 $i$ 为结尾的极长连续区间在树形结构中的子结点个数，则答案为 $\prod\limits_{i = 1} ^ n f_{c_i}$。

考虑如何求 $f$，我们考虑逆排列，我们发现一个长度为 $n + 1$ 的排列是好的当且仅当其逆排列所有长度 $\ge 2$ 且不包含 $n + 1$ 的区间都不连续。考虑递推，从长度为 $n$ 的排列中插入最小元素。

- $2, 3, \cdots, n + 1$ 构成好排列时：只需要 $1$ 不放在二的两侧，故贡献为 $(n - 1)f_{n - 1}$。
- $2, 3, \cdots, n + 1$ 不构成好排列时，则其逆排列至多有一个长度 $\ge 2$ 且不含 $n + 1$ 的连续区间。设其逆排列的连续区间值域为 $[l, r]$。首先有 $l \ge 3$，因为若 $l = 2$ 插入 $1$ 后不可能将该区间消除。其次根据定义显然 $r \neq n + 1$。所以对于长度为 $i$ 的连续区间，可选的值域共有 $n - i + 1$ 种。先考虑 $1$ 和连续区间内部的方案数。我们发现可以将连续区间中的元素视为 $1, 2, \cdots, i$，由于含有 $1$ 的区间肯定不是连续区间，所以限制条件是没有不含 $1$ 且长度 $\ge 2$ 的连续区间。我们发现如果把 $1$ 视为 $i + 1$，恰好与好排列的逆排列限制一致，所以内部共 $f_{i}$ 种排列方法。其次，我们考虑忽略 $1$，因为若一个长度 $\ge 2$ 的连续区间包含 $1$，则必然包含 $2$，又因为 $l \ge 3$，且 $1$ 被插在该连续区间内部，所以包含 $1$ 的连续区间长度 $\ge 3$，忽略 $1$ 后仍存在长度 $\ge 2$ 的连续区间。且忽略 $1$ 不会影响 $n + 1$ 是否存在。其次，我们显然仍可以将该连续区间视作一个单点，这个连续区间和剩下 $n - i$ 个元素按大小关系可编号为 $1, 2, \cdots, n - i + 1$，有 $f_{n - i}$ 种排列方案。综上，贡献为 $(n - i + 1)f_if_{n - i}$。

整理一下，我们有 $f$ 的递推公式为 $f_n = (n - 1)f_{n - 1} + \sum\limits_{i = 2} ^ {n - 1}(n - i + 1)f_if_{n - i} = (3 - n)f_{n - 1} + \sum\limits_{i = 1} ^ {n - 1}(i - 1)f_if_{n - i}$，暴力递推即可得到复杂度 $\mathcal{O}(n ^ 2 + Tn)$ 的做法。现在问题变成了已知 $f_1 = 2, f_i = (3 - i)f_{i - 1} + \sum\limits_{j = 1} ^ {i - 1} (j - 1) f_j f_{i - j}$，求 $f_1, f_2, \cdots, f_n$。

考虑 $\max(i, j) \in [L, mid]$ 的二元组 $(i, j)$ 对 $i + j$ 的贡献。

1. $L = 1$ 时，有 $i, j \in [L, mid]$ 将 $f_1, f_2, \cdots, f_{mid}$ 与 $0f_1, 1f_2, \cdots, (mid - 1)f_{mid}$ 卷积即可。
2. $L \neq 1$ 时，我们发现 $R - L < L$，故 $i, j$ 仅有一个在 $[L, mid]$ 中，将 $f_L, \cdots, f_{mid}$ 与 $0f_1, 1f_2, \cdots, (R - L - 1) f_{R - L}$ 卷积，再将 $(L - 1)f_L, Lf_{L + 1}, \cdots, (mid - 1)f_{mid}$ 与 $f_1, f_2, \cdots, f_{R - L}$ 卷积，再在对应位置贡献即可。

故分治 FFT 即可，复杂度为 $\mathcal{O}(n \log ^ 2 n)$，总复杂度 $\mathcal{O}(Tn + n \log ^ 2n)$。

---


# 【模板】多项式多点求值

## 题目描述

给定一个 $n$ 次多项式 $f(x)$ ，现在请你对于 $i \in [1,m]$ ，求出 $f(a_i)$ 。

## 说明/提示

$n,m \in [1,64000]$，$a_i,[x^i]f(x) \in [0,998244352]$ 。

$[x^i]f(x)$ 表示 $f(x)$ 的 $i$ 次项系数。

## 样例 #1

### 输入

```
10 10
18 2 6 17 7 19 17 6 2 12 14
4 15 5 20 2 6 20 12 16 5
```

### 输出

```
18147258
804760733
161737928
73381527
23750
973451550
73381527
525589927
842520242
161737928
```

# 题解

## 作者：Elegia (赞：147)

首先，感谢 rushcheyo, negiizhao, Created_Equal 于 IOI 2020中国国家集训队第一阶段作业《转置原理的简单介绍》中，对于本算法以及转置原理的引入和介绍工作。原本该文章的内容会由他们在 WC2020 中进行分享，可惜的是计划赶不上变化。

下面介绍的方法是多点求值的一种更快，代码量更小的算法。为了建立对其有外延性的理解，我们首先要简单解释转置原理，或称特勒根原理（Tellegen's Principle）的核心思想：

对于矩阵 $\mathbf M$ 和任一向量 $\mathbf v$，为了优化计算 $\mathbf {Mv}$，转置原理指出我们可以先考察计算 $\mathbf M^{\mathsf T}\mathbf v$ 的方法。即矩阵的转置。设有矩阵 $\mathbf M = {\mathbf E}_1{\mathbf E}_2 \cdots {\mathbf E}_k$ 这一分解，其中 ${\mathbf E}_i$ 均为初等矩阵，那么我们有 ${\mathbf M}^\mathsf T = {\mathbf E}_k^\mathsf T\cdots {\mathbf E}_2^\mathsf T{\mathbf E}_1^\mathsf T$。具体来说，初等矩阵中主要分为：

1. $\mathbf {Ev}$ 的效果是让向量 $\mathbf v$ 的第 $i$ 位乘以 $c$，那么其转置的效果也是一样的。
2. $\mathbf {Ev}$ 的效果是让向量 $\mathbf v$ 的第 $i$ 位乘以 $c$ 加到第 $j$ 位，那么其转置的效果就是让向量的第 $j$ 位乘以 $c$ 加到第 $i$ 位上。

我们考虑给定一组 $x_0 \sim x_{n-1}$，那么对于任给一个 $n-1$ 次多项式的写作系数向量的形式，转化为各位置点值的变换是线性变换，可写作矩阵

$$
\mathbf V(x_0, x_1,\dots, x_{n-1})=\begin{bmatrix}
1&x_0&x_0^2&\cdots& x_0^{n-1}\\
1&x_1&x_1^2&\cdots& x_1^{n-1}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
1&x_{n-1}&x_{n-1}^2&\cdots& x_{n-1}^{n-1}
\end{bmatrix}
$$

考虑其转置 $\mathbf V(x_0, x_1,\dots, x_{n-1})^{\mathsf T} \mathbf v = \begin{bmatrix}
1&1&1&\cdots& 1\\
x_0&x_1&x_2&\cdots& x_{n-1}\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
x_0^{n-1}&x_1^{n-1}&x_2^{n-1}&\cdots& x_{n-1}^{n-1}
\end{bmatrix}\mathbf v$

我们发现，其转置所求的实际上就是

$$
[x^k]\sum_{i=0}^{n-1} \frac{v_i}{1- x_i x}
$$

而我们知道为了求这个，我们常采取的做法是这样的 $\Theta(n\log^2n)$ 过程：

1. 对整体进行分治，维护对于左右 $\frac n2$ 两部分的 $(u_1, L), (u_2, R)$，即分子和分母部分，然后合并为 $(uR+vL, LR)$。
2. 最终，计算 $\frac{u_1}{P}$。

注意，中间所有的分母仅仅是这个线性变换中矩阵里的东西，是对于 $u$ 的线性变换。

接下来我们有必要注意一下一个重要的线性变换：多项式乘法作用 $\mathbf{MUL}(A) \mathbf v$ 的转置 $\mathbf{MUL}(A)^\mathsf T\mathbf v$。

对于多项式 $A(x)=\sum_i a_ix^i$，我们知道每个 $v_j$ 乘上 $a_i$ 会贡献给 $i+j$ 位置。因而转置后就是 $v_j$ 乘上 $a_i(i\le j)$ 会贡献给 $j-i$ 位置。因此这是另一个方向的卷积形式。此外，若原变换不溢出，则转置变换的 FFT 长度也是 $n$ 而不是 $2n$，因为循环卷积溢出的部分我们正好不要。

因此，我们得到的新的多点求值做法如下：

1. 对整体进行分治，维护出线段树对应的每个子树的 $(1-x_i x)$ 之乘积。
2. 对于要求值的 $m-1$ 次多项式，我们对其进行计算 $\mathbf {MUL} (P^{-1} \bmod x^{m})^\mathsf T \mathbf v$，然后保留前 $n$ 位。
3. 从线段树自顶向下递归，令下传的两部分向量 $\mathbf l = \mathbf{MUL}(R)^\mathsf T\mathbf v,\mathbf r = \mathbf{MUL}(L)^\mathsf T\mathbf v$
4. 最终，得到的叶节点的向量长度均为 $1$，对应于该处的点值。

新的算法有以下优点：

1. 不需要写多项式取模
2. 常数有显著提升

---

## 作者：Fuyuki (赞：53)

记待求值的多项式为 $F(x)$，需要求出其在 $x_0$ 处的点值 $F(x_0)$。

如果 $F(x)=Q(x)G(x)+R(x)$，则有 $F(x_0)=Q(x_0)G(x_0)+R(x_0)$。 如果构造 $G(x)$ 使得 $G(x_0)=0$，那么就有 $F(x_0)=R(x_0)$。

那么构造 $G(x)=x-x_0$，则 $F(x)$ 对 $G(x)$ 做多项式取模后得到的常数项就是 $F(x_0)$（因为取模后只有这一项了）。

多项式取模的过程可以分治进行，将 $F(x)$ 对 $\prod_{i=1}^{m/2} (x-x_i)$ 和 $\prod_{i=m/2+1}^{m} (x-x_i)$ 分别取模，再将取模后的结果向两边递归下去。每次 $O(mlogm)$ 的多项式取模都可以使得原问题的规模减半，就可以在 $O(nlogn+mlog^2m)$ 的时间内求出所有的点值（最开始还需要将 $F(x)$ 对 $\prod_{i=1}^{m}(x-x_i)$ 取模）。

这是大部分人的做法，但是鉴于多项式取模的大常数，这个做法的效率并不高。

重新分析一下，$R(x)$ 只有常数项，如果能算出 $Q(x)$ 的常数项，那么就可以计算出 $R(x)$。

考虑一下多项式除法是进行了一个怎么样的过程，假设 $F(x),G(x)$ 的最高次项次数分别为 $n,m$：

$$F(x)=Q(x)G(x)+R(x)$$

$$x^nF(\frac{1}{x})=x^{n-m}Q(\frac{1}{x})x^mG(\frac{1}{x})+x^nR(\frac{1}{x})$$

$$F_r(x)=Q_r(x)G_r(x)+x^{n-m+1}R_r(x)$$

$$Q_r(x)=F_r(x)G_r^{-1}(x)\pmod{x^{n-m+1}}$$

在这里，$F_r(x)$ 表示的是 $F_r(x)$ 的系数翻转后的结果。

设 $G(x)=\prod_{i=1}^{m}(x-x_i),G_0(x)=\prod_{i=1}^{m/2}(x-x_i),G_1(x)=\prod_{i=m/2+1}^{m}(x-x_i)$ 。

可以想到先求出 $Q_r(x)=F_r(x)G_r^{-1}(x)$ 然后用利用 $G_{0r}^{-1}(x)=G_r^{-1}(x)G_1(x)$ 来向下递归。

最底层的 $Q(x)$ 有 $n$ 项，也就是说为了保证底层计算结果是正确的，所有的计算都必须至少在 $\pmod{x^n}$ 的意义下进行，这样的复杂度显然是无法接受的。

但是注意到根本不需要计算出 $Q(x)$，只需要计算出 $Q(x)$ 的常数项，或者说 $[x^{n-1}]Q_r(x)$。换言之，只有某一项可能对最高项产生贡献才需要保留，否则可以直接舍弃。

如果接下来乘上的若干 $G(x)$ 之积的次数界为 $k$，那么就只需要保留 $Q(x)$ 的最后 $k$ 项，因为前面的若干项不可能对最高项产生贡献。

即，递归到区间 $[l,r]$ 的 $Q(x)$ 只需要保留最高的 $r-l+1$ 项。

这样，每次只需要一次多项式乘法而不是多项式取模就可以使得问题规模减半，效率得到了显著的提升（对我而言，五倍）。

此外，还需要注意：最底层需要第 $n$ 项，但是递归计算时当成只有 $m$ 项来处理，这样会导致 $n>m$ 时答案会错。

这有两个方法解决，第一种就是将 $F(x)$ 对 $G(x)$ 取模。第二种更简单，令 $m=\max(m,n)$，多出来的一些询问不会对答案造成影响。

（一千个人就有一千个多项式板子，代码仅供参考）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define ll long long int
#define isnum(ch) ('0'<=ch&&ch<='9')
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)
char _buf[100000],*_op(_buf),*_ed(_buf);
const int N=1<<18|1,mod=998244353;
V check(int&x){x-=mod,x+=x>>31&mod;}
I getint(){
	int _s=0;char _ch=gc;
	while(!isnum(_ch))_ch=gc;
	while(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;
	return _s;
}
I Pow(ll t,int x){
	ll s=1;
	for(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;
	return s;
}
namespace poly{
	int lmt,w[N],r[N];
	V init(int n){
		int l=-1,wn;
		for(lmt=1;lmt<=n;)lmt<<=1,l++;
		FOR(i,0,lmt-1)r[i]=(r[i>>1]>>1)|((i&1)<<l);
		wn=Pow(3,mod>>++l),w[lmt>>1]=1;
		FOR(i,(lmt>>1)+1,lmt-1)w[i]=1ll*w[i-1]*wn%mod;
		ROF(i,(lmt>>1)-1,1)w[i]=w[i<<1];
	}
	V cl(int*a,int n){memset(a,0,n<<2);}
	I getLen(int n){return 1<<32-__builtin_clz(n);}
	V mul(int*a,int x,int n,int*b){while(n--)*b++=1ll**a++*x%mod;}
	V dot(int*a,int*b,int n,int*c){while(n--)*c++=1ll**a++**b++%mod;}
	V DFT(int*a,int l){
		static unsigned ll tmp[N];
		int u=__builtin_ctz(lmt/l),t;
		FOR(i,0,l-1)tmp[i]=a[r[i]>>u];
		for(int i=1;i^l;i<<=1)for(int j=0,d=i<<1;j^l;j+=d)FOR(k,0,i-1)
			t=tmp[i|j|k]*w[i|k]%mod,tmp[i|j|k]=tmp[j|k]+mod-t,tmp[j|k]+=t;
		FOR(i,0,l-1)a[i]=tmp[i]%mod;
	}
	V IDFT(int*a,int l){reverse(a+1,a+l),DFT(a,l),mul(a,mod-mod/l,l,a);}
	V Inv(const int*a,int n,int*b){
		static int A[N],B[N],tmp[N],d,l;
		tmp[0]=Pow(a[0],mod-2),cl(A,d),cl(B,d);
		for(d=1,l=2;d<n;d<<=1,l<<=1){
			copy(a,a+min(l,n),A),copy(tmp,tmp+d,B);
			DFT(A,l),DFT(B,l),dot(A,B,l,A),IDFT(A,l);
			cl(A,d),DFT(A,l),dot(A,B,l,A),IDFT(A,l);
			copy(A+d,A+l,tmp+d),mul(tmp+d,mod-1,d,tmp+d);
		}
		copy(tmp,tmp+n,b);
	}
	int*f[N],*g[N],bin[N<<5],*np(bin);
	V Mul(int*a,int*b,int n,int m,int*c){
		static int A[N],B[N],l;
		l=getLen(n+m-1),copy(a,a+n,A),copy(b,b+m,B);
		DFT(A,l),DFT(B,l),dot(A,B,l,A),IDFT(A,l);
		copy(A,A+n+m-1,c),cl(A,l),cl(B,l);
	}
	V eva_init(int p,int l,int r,int*a){
		g[p]=np,np+=r-l+2,f[p]=np,np+=r-l+2;
		if(l==r)return g[p][0]=1,check(g[p][1]=mod-a[l]);
		int lc=p<<1,rc=lc|1,mid=l+r>>1,len1=mid-l+2,len2=r-mid+1;
		eva_init(lc,l,mid,a),eva_init(rc,mid+1,r,a);
		Mul(g[lc],g[rc],len1,len2,g[p]);
	}
	V Mult(int*a,int*b,int n,int m,int*c){
		static int A[N],B[N],l;
		l=getLen(n),copy(a,a+n,A),reverse_copy(b,b+m,B);
		DFT(A,l),DFT(B,l),dot(A,B,l,A),IDFT(A,l);
		copy(A+m-1,A+n,c);
		cl(A,l),cl(B,l);
	}
	V eva_work(int p,int l,int r,int*a){
		if(l==r)return void(a[l]=f[p][0]);
		int lc=p<<1,rc=lc|1,mid=l+r>>1,len1=mid-l+2,len2=r-mid+1;
		Mult(f[p],g[rc],r-l+1,len2,f[lc]);
		eva_work(lc,l,mid,a);
		Mult(f[p],g[lc],r-l+1,len1,f[rc]);
		eva_work(rc,mid+1,r,a);
	}
	V eva(int*a,int*b,int n,int m,int*c){
		static int X[N],Y[N],l;
		eva_init(1,1,m,b),Inv(g[1],m+1,X);
		reverse(X,X+m+1),Mul(a,X,n,m+1,Y);
		copy(Y+n,Y+n+m,f[1]),eva_work(1,1,m,c);
		FOR(i,1,m)check(c[i]=1ll*c[i]*b[i]%mod+a[0]);
	}
}
int n,m,a[N],b[N],c[N];
int main(){
	n=getint()+1,m=getint(),poly::init(max(n,m+1)<<1);
	FOR(i,0,n-1)a[i]=getint();
	FOR(i,1,m)b[i]=getint();
	n=max(n,m+1),poly::eva(a,b,n,max(n-1,m),c);
	FOR(i,1,m)cout<<c[i]<<'\n';
	return 0;
}
```

P.S. 代码里还使用了一个优化，就是从上往下计算 $Q$ 的时候，会有长度为 $l$ 的多项式乘上长度为 $\frac{l}{2}$ 的多项式然后只取后 $\frac{l}{2}$ 项的操作，这部分可以利用 $FFT$ 循环卷积的性质只进行长度为 $l$ 的 $DFT$。


---

## 作者：Vocalise (赞：39)

## 多点求值插值、转置算法以及范德蒙德矩阵逆

### 多点求值

给定 $n$ 项多项式 $f(x)$ 及 $a_0,a_1\cdots,a_{m-1}$，求 $f(a_0),f(a_1),f(a_2)\cdots f(a_{m-1})$。

这就是经典的多点求值问题。我们有容易理解的 $\Theta(n\log^2n)$ 算法：

注意到 $f(a_i) \equiv f(x)\pmod{(x-a_i)}$，所以我们需要求出 $f(x)$ 对 $m$ 个单项式取模的结果。我们分治：将求值点 $0\sim m-1$ 均分为两部分，对于前一部分，当前多项式对 $\prod\limits_{i=0}^{m/2}(x-a_i)$ 取模后递归，对 $\prod\limits_{i=m/2+1}^{m-1}(x-a_i)$ 取模后递归下去即可。取模复杂度 $\Theta(n\log n)$，所以总复杂度是 $\Theta(n\log^2n)$ 的。这个算法容易，但是取模具有极大常数，所以总效率极低。

所以我们有更优、且理论价值更高的转置算法。

### 转置算法

多点求值算法的本质是相当简单的：求一个向量左乘范德蒙德矩阵
$$
\mathrm V(a_0,\cdots,a_{m-1})=\begin{bmatrix}1 & a_0 & a_0^2 &\cdots& a_0^{n-1} \\ 1 & a_1 & a_1^2 &\cdots& a_1^{n-1} \\ \vdots&\vdots&\vdots &\ddots& \vdots \\ 1 & a_{m-1} & a_{m-1}^2 &\cdots& a_{m-1}^{n-1} \end{bmatrix}
$$
我们观察到，矩阵 $\mathrm V$ 的转置 $\mathrm V^{T}$ 左乘向量是好求的： 
$$
\mathrm V^T(a_0,a_1,\cdots,a_{m-1}) =
\begin{bmatrix}
1 & 1 &\cdots& 1 \\
a_0 & a_1 &\cdots& a_{m-1} \\
\vdots &\vdots &\ddots& \vdots \\
a_0^{n-1} & a_1^{n-1} &\cdots& a_{m-1}^{n-1}
\end{bmatrix}
,\quad\quad g_i = \sum_{j=0}^{m-1} f_ja_j^i
$$
这里若 $\mathrm V$ 不是方阵，无法右乘相同的向量。所以认为 $n=m$，不失一般性。

记 $G(x)$ 为 $g_i$ 的生成函数，有
$$
G(x) = \sum_{n\ge 0}\sum_{i=0}^{m-1}f_i(a_ix)^n = \sum_{i=0}^{m-1}\frac {f_i}{1-a_ix}
$$
较为清晰的形式下，可以采用分治求 $G(x)$ 的前 $n$ 项。维护分母即 $Q_{l,r}(x) = \prod\limits_{i=l}^{r}(1-a_ix)$ 和分子 $P_{l,r}(x)$。

对于分治区间 $[l,r]$ 及中点 $m$，
$$
\begin{aligned}
Q_{l,r}(x) &= Q_{l,m}(x)\times Q_{m + 1,r}(x) \\
P_{l,r}(x) &= P_{l,m}(x)\times Q_{m + 1,r}(x) + P_{m+1,r}(x)\times Q_{l,m}(x)
\end{aligned}
$$
注意到乘法和加法都不超过区间长度项，所以算法复杂度是 $\Theta(n\log^2n)$ 的。

这个矩阵转置后的算法和我们需要的算法有什么联系呢？

考虑 $A,B$ 矩阵，$(AB)^T = B^TA^T$，以及 $(A_1A_2\cdots A_k)^T = A_k^TA_{k-1}^T\cdots A_0^T$。

考虑到多点求值整个算法是**关于初始向量**的线性变换，以及其中的每个步骤都是线性的；具体来说，观察分治合并过程，$Q(x)$ 的求解和初始向量 $f_i$ 无关，可以视作常量。而 $P(x)$ 的求解是有关 $f_i$ 的关于 $x$ 的多项式与常多项式相乘再相加，为什么它是线性的呢？可以看出，$[x^k]P(x)$ 始终具有 $\sum\limits_{i=0}^{m-1}f_ic_{k,i}$ 的形式，$c_{k,i}$ 是常数。这和矩阵作用下向量得到的项是相符的。

**也就是说，$P(x)$ 是一个矩阵（变换），行按照 $x$ 的幂标号，列按照 $f_i$ 标号。而 $Q(x)$ 是一个（列）向量。**

我们将求解转置变换 $\mathrm V^T$ 问题的每一个较为基本的步骤逆序进行，并修改为转置过程，就可以得到原变换 $\mathrm V$ 问题的算法，不妨称为转置算法。

我们可以相信，转置算法和原算法有相同的复杂度；因为我们进行相同多次的线性运算。

这就是**转置原理**，或称**特勒根原理**（$\text{Tellegen's Principle}$）。

---

现在我们尝试描述上述算法的转置算法。

首先需要说明的是，我们将如何分解矩阵 $\mathrm V^T$ 。如果分解为初等矩阵的话，所有转置是显然的，但是出于封装和存在中间变量的关系，不妨分析将哪些步骤作为基本步骤逆序并转置。原算法的流程如下：
$$
\begin{aligned}
&1\ \ \text{Solve} (l,r): \\
&2\ \quad\quad \text{if } l = r: \text{return }f_l \\
&3\ \quad\quad m \leftarrow \lfloor(l+r)/2\rfloor \\
&4\ \quad\quad F,x,y \leftarrow 0 \quad\quad\quad\quad \text{// initial value can be given before all, doesn't count}\\
&5\ \quad\quad L \leftarrow \mathrm{Solve}(l,m) \\
&6\ \quad\quad R \leftarrow \mathrm{Solve}(m+1,r) \\
&7\ \quad\quad x \leftarrow x + L\times Q_{m+1,r}(x) \\
&8\ \quad\quad y \leftarrow y + R\times Q_{l,m}(x) \\
&9\ \quad\quad F \leftarrow F+1\times x \\
1&0\ \quad\quad F \leftarrow F+1\times y \\
1&1\ \quad\quad \mathrm {return\ } F \\
1&2\ \ g \leftarrow g+\mathrm{Solve}(0,m-1)\times Q^{-1}_{0,m-1}(x)
\end{aligned}
$$
注意到我们将赋值和加法运算修改为了初等变换的形式 $x \leftarrow x + c\times y$（请注意 $x,y,L,R$ 都是关于 $f_i$ 的向量；函数返回值占用的变量和 $L,R$ 认为是一致的，这里不存在赋值）。它的转置是 $y\leftarrow y + c\times x$。 这是十分重要的。

程序中有一些实际上顺序无关的过程，比如 $5,6$ 之间，$7,8$ 及 $9,10$ 之间。

这是一个后序遍历的递归算法。所以我们改成先序遍历。观察到，**每一层递归的 $F$ 值事先由上一层给出了**，所以改成不返回的过程，多带一个参数。尝试写出：
$$
\begin{aligned}
&1\ \ \text{Solve} (l,r,F): \\
&2\ \quad\quad \text{if } l = r: f_l\leftarrow F_0;\text{ return } \\
&3\ \quad\quad m \leftarrow \lfloor(l+r)/2\rfloor \\
&4\ \quad\quad x \leftarrow x+1\times^T F \\
&5\ \quad\quad y \leftarrow y+1\times^T F \\
&6\ \quad\quad L \leftarrow L + x\times^T Q_{m+1,r}(x) \\
&7\ \quad\quad R \leftarrow R + y\times^T Q_{l,m}(x) \\
&8\ \quad\quad \mathrm{Solve}(l,m,L) \\
&9\ \quad\quad \mathrm{Solve}(m+1,r,R) \\
1&0\ \quad\quad \mathrm{return} \\
1&1\ \ \mathrm{Solve}(0,m-1,g\times^T Q^{-1}_{0,m-1}(x))
\end{aligned}
$$
形式意外地更加简单，再将 $x,y$ 省略掉可得
$$
\begin{aligned}
&1\ \ \text{Solve} (l,r,F): \\
&2\ \quad\quad \text{if } l = r: f_l\leftarrow F_0;\text{ return } \\
&3\ \quad\quad m \leftarrow \lfloor(l+r)/2\rfloor \\
&6\ \quad\quad L \leftarrow L + F\times^T Q_{m+1,r}(x) \\
&7\ \quad\quad R \leftarrow R + F\times^T Q_{l,m}(x) \\
&8\ \quad\quad \mathrm{Solve}(l,m,L) \\
&9\ \quad\quad \mathrm{Solve}(m+1,r,R) \\
1&0\ \quad\quad \mathrm{return} \\
1&1\ \  \mathrm{Solve}(0,m-1,g\times^T Q^{-1}_{0,m-1}(x))
\end{aligned}
$$
这里 $\times^T$ 是多项式乘法，即各项卷积的转置；实际上只要把每一次「两项相乘累加」的过程置换即可，它们的顺序是无关紧要的。

设 $c_k = \sum\limits_{i=0}^ka_{k-i}b_i$，其中 $a_i$ 是初始向量的线性组合而 $b_i$ 是常量，那么对于过程
$$
c_k \leftarrow c_k + a_{k-i}\times b_i
$$
置换得到
$$
a_{k-i} \leftarrow a_{k-i} + c_k\times b_i
$$
这是差项卷积。但是注意到原乘法超过项数的不会有贡献，所以需要截取差卷积的 $n-m+1$ 项（除了递归前的一次乘法），同时保证了复杂度仍是 $\Theta(n\log^2n)$。

另外，除了分析累加以外，还有一种 DFT 转置的解法。

考虑另一种乘法的描述：DFT，对应点相乘，IDFT。

DFT 的变换矩阵 $(\omega_n^i)^j = (\omega_n^j)^i = (\omega_n)^{ij}$，所以它是对称的，转置等于本身。 IDFT 又可以分解为一次 DFT，一次数乘和一次逆序。逆序变换的矩阵就是副对角线，也是对称的。

可以看出，转置后就是：逆序，数乘，DFT，对应点相乘，DFT。这里的若干项都是严格意义上的「变换」了，没有必要展开。

自此，我们已经完全解决了多点求值问题。

```c++
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>

const int N = 64000 * 4;
const int p = 998244353;
typedef std::vector <int> Poly;

char buf[1 << 25] ,*p1 = buf ,*p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf ,1 ,1 << 21 ,stdin) ,p1 == p2) ? EOF : *p1++)
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

inline int pls(int a,int b) { return a + b >= p ? a + b - p : a + b; }
inline int mus(int a,int b) { return a - b < 0 ? a - b + p : a - b; }
inline int prd(int a,int b) { return 1ll * a * b % p; }
inline int fastpow(int a,int b) {
    int r = 1;
    while(b) {
        if(b & 1) r = 1ll * r * a % p;
        a = 1ll * a * a % p;
        b >>= 1;
    }
    return r;
}

int rev[N];
void NTT(Poly &a) {
    int N = a.size();
    for(int i = 0;i < N;i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * N / 2);
    for(int i = 0;i < N;i++) if(i > rev[i]) std::swap(a[i],a[rev[i]]);
    for(int n = 2, m = 1;n <= N;m = n, n <<= 1) {
        int g1 = fastpow(3,(p - 1) / n), t1, t2;
        for(int l = 0;l < N;l += n) {
            int g = 1;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = prd(a[i + m],g);
                a[i] = pls(t1,t2), a[i + m] = mus(t1,t2);
                g = prd(g,g1);
            }
        }
    }
    return;
}

void INTT(Poly &a) {
    NTT(a), std::reverse(a.begin() + 1,a.end()); 
    int invN = fastpow(a.size(),p - 2);
    for(int i = 0;i < (int)a.size();i++) a[i] = prd(a[i],invN);
}

Poly Mul(Poly a,Poly b) {
    int n = a.size() + b.size() - 1, N = 1;
    while(N < (int)(a.size() + b.size())) N <<= 1;
    a.resize(N), b.resize(N), NTT(a), NTT(b);
    for(int i = 0;i < N;i++) a[i] = prd(a[i],b[i]);
    INTT(a), a.resize(n);
    return a;
}

Poly MulT(Poly a,Poly b) {
    int n = a.size(), m = b.size(); 
    std::reverse(b.begin(),b.end()), b = Mul(a,b);
    for(int i = 0;i < n;i++) a[i] = b[i + m - 1];
    return a;
}

Poly tmp;
Poly Inv(Poly a,int n) {
    if(n == 1) return Poly(1,fastpow(a[0],p - 2));
    Poly b = Inv(a,(n + 1) / 2);
    int N = 1; while(N <= 2 * n) N <<= 1;
    tmp.resize(N), b.resize(N);
    for(int i = 0;i < n;i++) tmp[i] = a[i];
    for(int i = n;i < N;i++) tmp[i] = 0;
    NTT(tmp), NTT(b);
    for(int i = 0;i < N;i++) b[i] = mus(prd(2,b[i]),prd(prd(b[i],b[i]),tmp[i]));
    INTT(b), b.resize(n); return b;
}

int n,m; Poly a,f,v;

#define lc(k) k << 1
#define rc(k) k << 1 | 1
const int NODE = N * 4;
Poly Q[NODE];

void Init(Poly &a,int k,int l,int r) {
    if(l == r) {
        Q[k].resize(2);
        Q[k][0] = 1, Q[k][1] = mus(0,a[l]);
        return;
    }
    int m = (l + r) / 2;
    Init(a,lc(k),l,m), Init(a,rc(k),m + 1,r);
    Q[k] = Mul(Q[lc(k)],Q[rc(k)]);
    return;
}

void Multipoints(int k,int l,int r,Poly F,Poly &g) {
    F.resize(r - l + 1);
    if(l == r) return void(g[l] = F[0]);
    int m = (l + r) / 2;
    Multipoints(lc(k),l,m,MulT(F,Q[rc(k)]),g);
    Multipoints(rc(k),m + 1,r,MulT(F,Q[lc(k)]),g);
    return;
}

void Multipoint(Poly f,Poly a,Poly &v,int n) {
    f.resize(n + 1), a.resize(n);
    Init(a,1,0,n - 1), v.resize(n);
    Multipoints(1,0,n - 1,MulT(f,Inv(Q[1],n + 1)),v);
    return;
}

int main() {
    n = read() + 1, m = read();
    for(int i = 0;i < n;i++) f.push_back(read());
    for(int i = 0;i < m;i++) a.push_back(read());
    Multipoint(f,a,v,std::max(n,m));
    for(int i = 0;i < m;i++) std::printf("%d\n",v[i]);
    return 0;
}

```



## 快速插值

有拉格朗日插值公式：
$$
f(x) = \sum_{i=0}^{n-1}y_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}
$$
我们要求这个式子。 直观的 $\Theta(n^2)$ 算法是求出 $F(x) = \prod\limits_{i=0}^{n-1}(x-x_i)$ 和 $q_i = \prod\limits_{j\ne i}(x_i-x_j)$，作 $n$ 次多项式除一次式即可。

求 $n$ 次多项式除单项式？我们不禁把它和刚才的分治取模多点求值算法联系起来。然而这里我们求的是除法商而非余式，所以分治取模是不对的。

考虑多项式 $\dfrac{F(x)}{x-x_i}$，它是连续可导的，且在除 $x=x_i$ 以外的点都和 $\prod\limits_{j\ne i}(x-x_j)$ 值相同。所以 $x-x_i$ 是它的可去间断点。取极限得：
$$
\left.\prod_{j\ne i}(x-x_j)\right|_{x=x_i} = \lim_{x\to x_i}\frac{F(x)}{x-x_i} = \lim_{x\to x_i}F'(x) = F'(x_i)
$$
使用洛必达法则。所以 $q_i = F'(x_i)$。分治求出 $F(x)$ 后，可以使用多点求值得到 $q_i$。

我们要求 $f_{0,n-1}(x) = \sum\limits_{i=0}^{n-1}\dfrac{y_i}{q_i}\prod\limits_{j\ne i}(x-x_j)$，不妨再记 $t_i = \dfrac{y_i}{q_i}$。这个形式也可以直接分治计算，复杂度 $\Theta(n\log^2n)$。

```c++
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>

const int N = 400001;
const int p = 998244353;
typedef std::vector <int> Poly;

char buf[1 << 25] ,*p1 = buf ,*p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf ,1 ,1 << 21 ,stdin) ,p1 == p2) ? EOF : *p1++)
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

inline int pls(int a,int b) { return a + b >= p ? a + b - p : a + b; }
inline int mus(int a,int b) { return a - b < 0 ? a - b + p : a - b; }
inline int prd(int a,int b) { return 1ll * a * b % p; }
inline int fastpow(int a,int b) {
    int r = 1;
    while(b) {
        if(b & 1) r = 1ll * r * a % p;
        a = 1ll * a * a % p;
        b >>= 1;
    }
    return r;
}

int rev[N];
void NTT(Poly &a) {
    int N = a.size();
    for(int i = 0;i < N;i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * N / 2);
    for(int i = 0;i < N;i++) if(i > rev[i]) std::swap(a[i],a[rev[i]]);
    for(int n = 2, m = 1;n <= N;m = n, n <<= 1) {
        int g1 = fastpow(3,(p - 1) / n), t1, t2;
        for(int l = 0;l < N;l += n) {
            int g = 1;
            for(int i = l;i < l + m;i++) {
                t1 = a[i], t2 = prd(a[i + m],g);
                a[i] = pls(t1,t2), a[i + m] = mus(t1,t2);
                g = prd(g,g1);
            }
        }
    }
    return;
}

void INTT(Poly &a) {
    NTT(a), std::reverse(a.begin() + 1,a.end()); 
    int invN = fastpow(a.size(),p - 2);
    for(int i = 0;i < (int)a.size();i++) a[i] = prd(a[i],invN);
}

Poly Mul(Poly a,Poly b) {
    int n = a.size() + b.size() - 1, N = 1;
    while(N < (int)(a.size() + b.size())) N <<= 1;
    a.resize(N), b.resize(N), NTT(a), NTT(b);
    for(int i = 0;i < N;i++) a[i] = prd(a[i],b[i]);
    INTT(a), a.resize(n);
    return a;
}

Poly MulT(Poly a,Poly b) {
    int n = a.size(), m = b.size(); 
    std::reverse(b.begin(),b.end()), b = Mul(a,b);
    for(int i = 0;i < n;i++) a[i] = b[i + m - 1];
    return a;
}

Poly tmp;
Poly Inv(Poly a,int n) {
    if(n == 1) return Poly(1,fastpow(a[0],p - 2));
    Poly b = Inv(a,(n + 1) / 2);
    int N = 1; while(N <= 2 * n) N <<= 1;
    tmp.resize(N), b.resize(N);
    for(int i = 0;i < n;i++) tmp[i] = a[i];
    for(int i = n;i < N;i++) tmp[i] = 0;
    NTT(tmp), NTT(b);
    for(int i = 0;i < N;i++) b[i] = mus(prd(2,b[i]),prd(prd(b[i],b[i]),tmp[i]));
    INTT(b), b.resize(n); return b;
}

Poly Dervt(Poly a) {
    for(int i = 0;i < (int)a.size() - 1;i++) a[i] = prd(i + 1,a[i + 1]);
    a.pop_back(); return a;
}

#define lc(k) k << 1
#define rc(k) k << 1 | 1
Poly Q[N];

void MultiInit(Poly &a,int k,int l,int r) {
    if(l == r) {
        Q[k].resize(2);
        Q[k][0] = 1, Q[k][1] = mus(0,a[l]);
        return;
    }
    int m = (l + r) / 2;
    MultiInit(a,lc(k),l,m), MultiInit(a,rc(k),m + 1,r);
    Q[k] = Mul(Q[lc(k)],Q[rc(k)]);
    return;
}

void Multipoints(int k,int l,int r,Poly F,Poly &g) {
    F.resize(r - l + 1);
    if(l == r) return void(g[l] = F[0]);
    int m = (l + r) / 2;
    Multipoints(lc(k),l,m,MulT(F,Q[rc(k)]),g);
    Multipoints(rc(k),m + 1,r,MulT(F,Q[lc(k)]),g);
    return;
}

void Multipoint(Poly f,Poly a,Poly &v,int n) {
    f.resize(n + 1), a.resize(n);
    MultiInit(a,1,0,n - 1), v.resize(n);
    Multipoints(1,0,n - 1,MulT(f,Inv(Q[1],n + 1)),v);
    return;
}

int n; Poly x,y,t,f;

Poly F[N];
void InterInit(int k,int l,int r) {
    if(l == r) {
        F[k].resize(2);
        F[k][0] = mus(0,x[l]), F[k][1] = 1;
        return;
    }
    int m = (l + r) / 2;
    InterInit(lc(k),l,m);
    InterInit(rc(k),m + 1,r);
    F[k] = Mul(F[lc(k)],F[rc(k)]);
    return;
}

Poly InterSolve(int k,int l,int r,Poly &t) {
    if(l == r) return Poly(1,t[l]);
    int m = (l + r) / 2;
    Poly L(InterSolve(lc(k),l,m,t));
    Poly R(InterSolve(rc(k),m + 1,r,t));
    R = Mul(R,F[lc(k)]);
    L = Mul(L,F[rc(k)]);
    for(int i = 0;i < (int)R.size();i++) L[i] = pls(L[i],R[i]);
    return L;
}

void Interpolate(Poly x,Poly y,Poly &f,int n) {
    InterInit(1,0,n - 1);
    F[1] = Dervt(F[1]), Multipoint(F[1],x,t,n);
    for(int i = 0;i < n;i++) t[i] = prd(y[i],fastpow(t[i],p - 2));
    f = InterSolve(1,0,n - 1,t);
    return;
}

int main() {
    n = read();
    for(int i = 0;i < n;i++) x.push_back(read()), y.push_back(read());
    Interpolate(x,y,f,n);
    for(int i = 0;i < n;i++) std::printf("%d ",f[i]);
    return 0;
}

```



### 范德蒙德矩阵逆

插值是求点值的逆运算，所以插值就是求范德蒙德矩阵的逆乘向量。

这个矩阵没有一个简单的形式，但是我们这里就可以通过拉格朗日公式得到
$$
\mathrm V^{-1}_{ij} = [x^{i}]\prod\limits_{k\ne j}\dfrac{x-x_k}{x_j-x_k}
$$
展开式相当复杂。

---

## 作者：mrsrz (赞：32)

我们将要求值的点均分成两份，构造多项式$P_0(x)=\prod\limits_{i=1}^{\lfloor\frac n 2\rfloor}(x-x_i)$，$P_1(x)=\prod\limits_{i=\lfloor\frac n 2\rfloor+1}^{n}(x-x_i)$。

显然，对于$\forall i\in[1,\lfloor\frac n 2 \rfloor]$，有$P_0(x_i)=0$。$P_1$同理。

我们假设多项式$D(x),R(x)$满足：$D(x)$是一个$n-\lfloor\frac n 2\rfloor$次多项式，$R(x)$是一个次数不超过$\lfloor\frac n 2\rfloor-1$的多项式，且$A(x)=P_0(x)D(x)+R(x)$。

那么对于$\forall i\in[1,\lfloor\frac n 2 \rfloor]$，有$A(x_i)=R(x_i)$。$P_1$同理可得。

由于$R(x)$的次数是$A(x)$的次数的一半，所以我们把一个规模为$n$的问题，用$O(n\log n)$的复杂度（多项式取模，详见多项式除法），转化为两个规模为$\frac n 2$的问题。

分治计算即可，由主定理得时间复杂度$O(n\log^2 n)$。

求每次的$P_0(x),P_1(x)$，可以开始用一次分治NTT预处理。此处时间复杂度也为$O(n\log^2 n)$。

常数极大就是了QAQ。

## Code：
```cpp
#include<cstdio>
#include<algorithm>
typedef long long LL;
const int md=998244353,N=262145;
//Poly begin
int rev[N],lim,g[20][N],M,vv;
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
    int ret=1;
    for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;return ret;
}
inline void init(int n){
    int l=-1;
    for(lim=1;lim<n;lim<<=1)++l;M=l+1;
    for(int i=1;i<lim;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<l);vv=pow(lim,md-2);
}
void NTT(int*a,int f){
    for(int i=1;i<lim;++i)if(i<rev[i])std::swap(a[i],a[rev[i]]);
    for(int i=0;i<M;++i){
        const int*G=g[i],c=1<<i;
        for(int j=0;j<lim;j+=c<<1)
        for(int k=0;k<c;++k){
            const int x=a[j+k],y=a[j+k+c]*(LL)G[k]%md;
            upd(a[j+k]+=y-md),upd(a[j+k+c]=x-y);
        }
    }
    if(!f){
        for(int i=0;i<lim;++i)a[i]=(LL)a[i]*vv%md;
        std::reverse(a+1,a+lim);
    }
}
void INV(const int*a,int*B,int n){
    if(n==1){
        *B=pow(*a,md-2);
        return;
    }
    INV(a,B,n+1>>1);
    init(n<<1);
    static int A[N];
    for(int i=0;i<n;++i)A[i]=a[i];
    for(int i=n;i<lim;++i)A[i]=0;
    NTT(A,1),NTT(B,1);
    for(int i=0;i<lim;++i)B[i]=B[i]*(2-(LL)A[i]*B[i]%md+md)%md;
    NTT(B,0);
    for(int i=n;i<lim;++i)B[i]=0;
}
void REV(int*A,int n){std::reverse(A,A+n+1);}
void MOD(const int*a,const int*b,int*R,int n,int m){
    static int A[N],B[N],D[N];
    for(int i=0;i<n<<1;++i)D[i]=0;
    for(int i=0;i<=m;++i)B[i]=b[i];
    REV(B,m);
    for(int i=n-m+1;i<n<<1;++i)B[i]=0;
    INV(B,D,n-m+1);
    init(n-m+1<<1);
    for(int i=0;i<=n-m+1;++i)A[i]=a[n-i];
    for(int i=n-m+2;i<lim;++i)A[i]=0;
    NTT(A,1),NTT(D,1);
    for(int i=0;i<lim;++i)D[i]=(LL)D[i]*A[i]%md;
    NTT(D,0);
    REV(D,n-m);
    init(n+1<<1);
    for(int i=n-m+1;i<lim;++i)D[i]=0;
    for(int i=0;i<lim;++i)A[i]=B[i]=0;
    for(int i=0;i<=m;++i)B[i]=b[i];
    for(int i=0;i<=n;++i)A[i]=a[i];
    NTT(B,1),NTT(D,1);
    for(int i=0;i<lim;++i)B[i]=(LL)B[i]*D[i]%md;
    NTT(B,0);
    for(int i=0;i<m;++i)upd(R[i]=A[i]-B[i]);
}
//Poly end
int n,m,A[N],a[N],*P[N],len[N];
void solve(int l,int r,int o){
    if(l==r){
        len[o]=1;
        P[o]=new int[2];
        upd(P[o][0]=-a[l]),P[o][1]=1;
        return;
    }
    const int mid=l+r>>1,L=o<<1,R=L|1;
    solve(l,mid,L),solve(mid+1,r,R);
    len[o]=len[L]+len[R];
    P[o]=new int[len[o]+1];
    init(len[o]+1<<1);
    static int A[N],B[N];
    for(int i=len[L];~i;--i)A[i]=P[L][i];
    for(int i=len[L]+1;i<lim;++i)A[i]=0;
    for(int i=len[R];~i;--i)B[i]=P[R][i];
    for(int i=len[R]+1;i<lim;++i)B[i]=0;
    NTT(A,1),NTT(B,1);
    for(int i=0;i<lim;++i)A[i]=(LL)A[i]*B[i]%md;
    NTT(A,0);
    for(int i=len[o];~i;--i)P[o][i]=A[i];
}
void solve(int l,int r,int o,const int*A){
    if(l==r){printf("%d\n",*A);return;}
    const int mid=l+r>>1,L=o<<1,R=L|1;
    int B[len[o]+2<<1];
    MOD(A,P[L],B,len[o]-1,len[L]);
    solve(l,mid,L,B);
    MOD(A,P[R],B,len[o]-1,len[R]);
    solve(mid+1,r,R,B);
}
int main(){
    for(int i=0;i<19;++i){
        int*G=g[i];
        G[0]=1;
        const int gi=G[1]=pow(3,(md-1)/(1<<i+1));
        for(int j=2;j<1<<i;++j)G[j]=(LL)G[j-1]*gi%md;
    }
    scanf("%d%d",&n,&m);if(!m)return 0;
    for(int i=0;i<=n;++i)scanf("%d",A+i);
    for(int i=1;i<=m;++i)scanf("%d",a+i);
    solve(1,m,1);
    if(n>=m)MOD(A,P[1],A,n,m);
    solve(1,m,1,A);
    return 0;
}
```

---

## 作者：cyffff (赞：19)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5050)
## 题意
给出 $n$ 次多项式 $F(x)=\sum_{i=0}^n f_ix^i$，$m$ 组询问，第 $i$ 次询问给出 $x_i$，求出 $F(x_i)$ 的值。

$1\le n,m\le 6.4\times 10^4$。
## 思路
$\text{Update 2021.12.22}$：更改了代码。

$\text{Update 2022.04.07}$：对代码实现与代码细节进行补充说明。

$\text{Update 2024.03.19}$：更改了代码与部分说明。

以下默认 $mid=\lfloor\frac {l+r} 2\rfloor$。

考虑构造一个多项式 $G(x)=x-x_0$，我们可以证明 $F(x)\bmod G(x)=F(x_0)$：令 $F(x)=Q(x)\cdot G(x)+r$，那么 $F(x_0)=Q(x_0)\cdot G(x_0)+r$，因为 $G(x_0)=0$，所以 $F(x_0)=r$。

分治 $\text{NTT}$ 容易求出 $G_{l,r}=\displaystyle\prod_{i=l}^r(x-x_i)$，将 $F$ 分别对 $G_{l,mid}$ 和 $G_{mid+1,r}$ 取模后传入左右区间，当 $l=r$ 时就求出了第 $l$ 个询问的答案。分治到 $[l,r]$ 时 $F$ 的次数小于 $G_{l,r}$ 的次数即 $F$ 为 $r-l$ 次多项式。

假设 $n,m$ 同阶，我们得到了一个时间复杂度 $T(n)=2T(\frac n 2)+O(n\log n)=O(n\log^2n)$ 的算法，但由于每次递归都需要多项式取模，常数较大。

我们发现算出 $Q(x)$ 的常数项即可算出 $r$，即 $r=[x^0]Q(x)\cdot x_0+[x^0]F(x)$。

在多项式取模的推导过程中，我们得到了 $Q_R\equiv \dfrac {F_R}{G_R}(\bmod x^{n-m+1})$ 这一式子。因为 ${G_{l,mid}}_R^{-1}={G_{l,r}}_R^{-1}{G_{mid+1,r}}_R$，于是可以求出 $[l,r]$ 对应的 $Q_R$ 后乘上 ${G_{mid+1,r}}_R$ 得到 $[l,mid]$ 对应的 $Q_R$，右区间同理。

$G(x)$ 的长度看似没有保障，但是注意到我们最后只需要 $[x^0]Q(x)$ 即 $[x^{n-1}]Q_R(x)$，在递归到区间 $[l,r]$ 时，$Q_R$ 之后只会乘以次数小于 $r-l+1$ 的多项式，从而只有后 $r-l$ 位有可能对答案有贡献，于是只需要保留 $Q_R$ 的后 $r-l$ 位，这也保证了该算法的时间复杂度。

时间复杂度 $O(n\log^2n)$，每次递归只需要做多项式乘法，常数小。

事实上这与转置原理方法本质相同。

核心代码：
```cpp
namespace Evaluation{
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	inline Poly MulT(const Poly &a,const Poly &b){
		Poly F=a,G=b;
		int n=a.size(),m=b.size();
		reverse(G.begin(),G.end());
		init(n);
		F.resize(lim),G.resize(lim);
		NTT(F,1),NTT(G,1);
		for(int i=0;i<lim;i++)
			G[i]=1ll*F[i]*G[i]%mod;
		NTT(G,-1);
		for(int i=m-1;i<n;i++)
			F[i-m+1]=G[i];
		F.resize(max(0,n-m+1));
		return F;
	}
	Poly T[N];
	Poly Q,ans;
	inline void build(int rt,int l,int r){
		if(l==r){
			T[rt]=(Poly){1,dec(0,Q[l])};
			return ;
		}
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		T[rt]=T[ls]*T[rs];
	}
	inline void solve(int rt,int l,int r,Poly F){
		if(l==r){
			ans[l]=F[0];
			return ;
		}
		int mid=l+r>>1;
		solve(ls,l,mid,MulT(F,T[rs]));
		solve(rs,mid+1,r,MulT(F,T[ls]));
	}
	inline Poly solve(Poly F,Poly Qr){
		Q=Qr;
		int n=F.size(),m=Q.size();
		if(n<m) F.resize(n=m);
		if(m<n) Q.resize(n);
		build(1,0,n-1);
		ans.resize(n),F.resize(n*2);
		solve(1,0,n-1,MulT(F,Inv(T[1])));
		ans.resize(m);
		return ans;
	}
}
```

另外我还实现了任意模数多点求值，跑一个点大概要 300ms，[评测记录](https://www.luogu.com.cn/record/65564926)。实测可以轻松跑过 [P5282](https://www.luogu.com.cn/problem/P5282)。

---

## 作者：bztMinamoto (赞：13)

[传送门](https://www.luogu.org/problemnew/show/P5050)

人傻常数大.jpg

因为求逆的时候没清零结果调了几个小时……

## 前置芝士

多项式除法，多项式求逆

什么？你不会？左转你谷模板区，包教包会

## 题解

首先我们要知道一个结论$$f(x_0)\equiv f(x)\pmod{(x-x_0)}$$

其中$x_0$为一个常量，$f(x_0)$也为一个常量

证明如下，设$f(x)=g(x)(x-x_0)+A$，也就是说$A$是$f(x)$对$(x-x_0)$这个多项式取模之后的结果

因为$(x-x_0)$的最高次项为$1$，所以$A$的最高次项为$0$，也就是说$A$是一个常数，即$f(x)\equiv A\pmod{(x-x_0)}$

我们把$x_0$代入上式，得$f(x_0)=g(x_0)(x_0-x_0)+A$，同理可得$f(x_0)\equiv A\pmod{(x-x_0)}$

于是我们知道上式成立

~~这有毛用啊$O(n\log n)$多项式取模还没我暴力快~~

乍一看的确没啥卵用，但是考虑取模的过程是否能优化呢？

答案是可以的，我们考虑分治。设当前分治区间为$[l,r]$，令$P_0=\prod_{i=l}^{mid}(x-x_i)$，$P_1=\prod_{i=mid+1}^r (x-x_i)$，当前已经算出了$A\equiv f(x)\pmod{\prod_{i=l}^r(x-x_i)}$，那么只要分别用$A$对$P_0$和$P_1$取模，然后继续递归下去就行了。取模之后$A(x)$的最高次项的次数变为原来的一半，问题规模也就变为原来的一半。继续递归下去就行了

时间复杂度为$O(n\log^2n)$

upd：改了改代码，常数应该会小一点，比方说分治到某个时候暴力秦九韶展开

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(R int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=(1<<17)+5,P=998244353;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
	R int res=1;
	for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;
	return res;
}
int r[19][N],w[2][N],lg[N],inv[19];
void Pre(){
	fp(d,1,17){
		fp(i,1,(1<<d)-1)r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
		lg[1<<d]=d,inv[d]=ksm(1<<d,P-2);
	}
	for(R int t=(P-1)>>1,i=1,x,y;i<131072;i<<=1,t>>=1){
		x=ksm(3,t),y=ksm(332748118,t),w[0][i]=w[1][i]=1;
		fp(k,1,i-1)
			w[1][k+i]=mul(w[1][k+i-1],x),
			w[0][k+i]=mul(w[0][k+i-1],y);
	}
}
int lim,d,n,m;
inline void init(R int len){lim=1,d=0;while(lim<len)lim<<=1,++d;}
void NTT(int *A,int ty){
	fp(i,0,lim-1)if(i<r[d][i])swap(A[i],A[r[d][i]]);
	for(R int mid=1;mid<lim;mid<<=1)
		for(R int j=0,t;j<lim;j+=(mid<<1))
			fp(k,0,mid-1)
				A[j+k+mid]=dec(A[j+k],t=mul(w[ty][mid+k],A[j+k+mid])),
				A[j+k]=add(A[j+k],t);
	if(!ty)fp(i,0,lim-1)A[i]=mul(A[i],inv[d]);
}
void Inv(int *a,int *b,int len){
	if(len==1)return b[0]=ksm(a[0],P-2),void();
	Inv(a,b,len>>1),lim=(len<<1),d=lg[lim];
	static int A[N],B[N];
	fp(i,0,len-1)A[i]=a[i],B[i]=b[i];fp(i,len,lim-1)A[i]=B[i]=0;
	NTT(A,1),NTT(B,1);
	fp(i,0,lim-1)A[i]=mul(A[i],mul(B[i],B[i]));
	NTT(A,0);
	fp(i,0,len-1)b[i]=dec(add(b[i],b[i]),A[i]);
	fp(i,len,lim-1)b[i]=0;
}
struct node{
	node *lc,*rc;vector<int>vec;int deg;
	void Mod(const int *a,int *r,int n){
		static int A[N],B[N],D[N];
		int len=1;while(len<=n-deg)len<<=1;
		fp(i,0,n)A[i]=a[n-i];fp(i,0,deg)B[i]=vec[deg-i];
		fp(i,n-deg+1,len-1)B[i]=0;
		Inv(B,D,len);
		lim=(len<<1),d=lg[lim];
		fp(i,n-deg+1,lim-1)A[i]=D[i]=0;
		NTT(A,1),NTT(D,1);
		fp(i,0,lim-1)A[i]=mul(A[i],D[i]);
		NTT(A,0);
		reverse(A,A+n-deg+1);
		init(n+1);
		fp(i,n-deg+1,lim-1)A[i]=0;
		fp(i,0,deg)B[i]=vec[i];fp(i,deg+1,lim-1)B[i]=0;
		NTT(A,1),NTT(B,1);
		fp(i,0,lim-1)A[i]=mul(A[i],B[i]);
		NTT(A,0);
		fp(i,0,deg-1)r[i]=dec(a[i],A[i]);
	}
	void Mul(){
		static int A[N],B[N];deg=lc->deg+rc->deg,vec.resize(deg+1),init(deg+1);
		fp(i,0,lc->deg)A[i]=lc->vec[i];fp(i,lc->deg+1,lim-1)A[i]=0;
		fp(i,0,rc->deg)B[i]=rc->vec[i];fp(i,rc->deg+1,lim-1)B[i]=0;
		NTT(A,1),NTT(B,1);
		fp(i,0,lim-1)A[i]=mul(A[i],B[i]);
		NTT(A,0);
		fp(i,0,deg)vec[i]=A[i];
	}
}pool[N],*rt;
int A[N],a[N],tot;
inline node* newnode(){return &pool[tot++];}
void solve(node* &p,int l,int r){
	p=newnode();
	if(l==r)return p->deg=1,p->vec.resize(2),p->vec[0]=P-a[l],p->vec[1]=1,void();
	int mid=(l+r)>>1;
	solve(p->lc,l,mid),solve(p->rc,mid+1,r);
	p->Mul();
}
int b[25];
void calc(node* p,int l,int r,const int *A){
	if(r-l<=512){
		fp(i,l,r){
			int x=a[i],c1,c2,c3,c4,now=A[r-l];
			b[0]=1;fp(j,1,16)b[j]=mul(b[j-1],x);
			for(R int j=r-l-1;j-15>=0;j-=16){
				c1=(1ll*now*b[16]+1ll*A[j]*b[15]+1ll*A[j-1]*b[14]+1ll*A[j-2]*b[13])%P,
				c2=(1ll*A[j-3]*b[12]+1ll*A[j-4]*b[11]+1ll*A[j-5]*b[10]+1ll*A[j-6]*b[9])%P,
				c3=(1ll*A[j-7]*b[8]+1ll*A[j-8]*b[7]+1ll*A[j-9]*b[6]+1ll*A[j-10]*b[5])%P,
				c4=(1ll*A[j-11]*b[4]+1ll*A[j-12]*b[3]+1ll*A[j-13]*b[2]+1ll*A[j-14]*b[1])%P,
				now=(0ll+c1+c2+c3+c4+A[j-15])%P;
			}
			fd(j,(r-l)%16-1,0)now=(1ll*now*x+A[j])%P;
			print(now);
		}
		return;
	}
	int mid=(l+r)>>1,b[p->deg+1];
	p->lc->Mod(A,b,p->deg-1),calc(p->lc,l,mid,b);
	p->rc->Mod(A,b,p->deg-1),calc(p->rc,mid+1,r,b);
}
int main(){
//	freopen("testdata.in","r",stdin);
	n=read(),m=read();if(!m)return 0;
	Pre();
	fp(i,0,n)A[i]=read();
	fp(i,1,m)a[i]=read();
	solve(rt,1,m);
	if(n>=m)rt->Mod(A,A,n);
	calc(rt,1,m,A);
	return Ot(),0;
}
```

---

## 作者：AThousandSuns (赞：12)

调了一个月终于调出来了……

这里就加点详细的注释表明哪里容易写错好了。毕竟没题解调这种题会死人的……

---
我们发现如果构造一个多项式 $P_{l,r}(x)=\prod\limits^r_{i=l}(x-a_i)$，那么对于所有的 $l\le i\le r$，都有 $P_{l,r}(a_i)=0$。

存在一个 $n-(r-l+1)$ 次多项式 $Q$，和 $r-l$ 次多项式 $R$ 满足 $F(a_i)=P_{l,r}(a_i)Q(a_i)+R(a_i)$。因为 $P_{l,r}(a_i)=0$，所以 $F(a_i)=R(a_i)$。我们便成功把一个 $n$ 次多项式变成了 $r-l$ 次多项式。

求 $R(a_i)$？发现它实际上是 $F$ 模 $P_{l,r}$，多项式除法/取模！

现在考虑分治。令 $F_{l,r}(x)$ 为当前区间的多项式，那么分成 $[l,mid]$ 和 $[mid+1,r]$ 计算。以 $[l,mid]$ 为例，$F_{l,r}(a_i)=P_{l,mid}(a_i)Q(a_i)+F_{l,mid}(a_i)$。

边界：$l=r$ 时 $F$ 次数为 $0$，那么 $F(a_i)=[x^0]F_{l,r}(x)$。

但是 $P_{l,r}(x)$ 直接求也不可承受。实际上我们可以另外再来一次分治，$P_{l,r}(x)=P_{l,mid}(x)P_{mid+1,r}(x)$。边界也是 $l=r$。

时间复杂度：$T(n)=2T(\frac{n}{2})+O(n\log n)=O(n\log^2n)$。

因为自带大常数，我就模仿了@officeyutong 的做法，在 $r-l\le100$ 的时候直接秦九韶爆算。实际上会跑得快很多。

下面是我的代码+注释：（我用vector写的，可能会比较丑）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353,g=3;
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
inline int read(){
	int x=0,f=0;char ch=getchar();
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,m,b[64444],ans[64444];
int limit,l,rev[266666];
vector<int> poly[266666],a;
inline void init(int upr){
	for(limit=1,l=0;limit<=upr;limit<<=1,l++);
	FOR(i,0,limit-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
}
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int sub(int x,int y){return x<y?x-y+mod:x-y;}
inline int qpow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;
	return ans;
}
void NTT(vector<int> &A,int tp){
	while(A.size()<limit) A.push_back(0);	//加上这话！不然会越界！
	FOR(i,0,limit-1) if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(int i=1;i<limit;i<<=1)
		for(int j=0,r=i<<1,Wn=qpow(g,mod-1+tp*(mod-1)/r);j<limit;j+=r)
			for(int k=0,w=1;k<i;k++,w=1ll*w*Wn%mod){
				int x=A[j+k],y=1ll*A[i+j+k]*w%mod;
				A[j+k]=add(x,y);A[i+j+k]=sub(x,y);
			}
	if(tp==-1){
		int linv=qpow(limit,mod-2);
		FOR(i,0,limit-1) A[i]=1ll*A[i]*linv%mod;
	}
}
void NTT(vector<int> A,vector<int> B,vector<int> &C){
	C.clear();	//清空！
	NTT(A,1);NTT(B,1);
	FOR(i,0,limit-1) C.push_back(1ll*A[i]*B[i]%mod);	//不能直接用下标！
	NTT(C,-1);
}
void inv(vector<int> A,vector<int> &B,int deg){	//逆元（必须保证调用时B是空的）
	if(deg==1) return B.push_back(qpow(A[0],mod-2));
	inv(A,B,(deg+1)>>1);
	init(deg<<1);
	while(A.size()<limit) A.push_back(0);	//虽然NTT内有补全到limit的话，但这也要写
	FOR(i,deg,limit-1) A[i]=0;	//因为这里需要把deg后的设为0
	NTT(A,1);NTT(B,1);
	FOR(i,0,limit-1) B[i]=1ll*sub(2,1ll*A[i]*B[i]%mod)*B[i]%mod;
	NTT(B,-1);
	FOR(i,deg,limit-1) B[i]=0;
}
void modulo(vector<int> A,vector<int> B,vector<int> &D,int n,int m){
	//取模（须保证B高位为空，A随便）
	while(A.size()<=n) A.push_back(0);
	while(B.size()<=m) B.push_back(0);	//把空位补全！（具体原因下文会说）
	if(n<m) return void(D=A);	//如果除不了，那么答案就是被除数！
	vector<int> Arev,Brev,Brevinv,Crev,C;D.clear();
	FOR(i,0,n) Arev.push_back(A[n-i]);
	FOR(i,0,m) Brev.push_back(B[m-i]);
	FOR(i,n-m+2,Arev.size()-1) Arev[i]=0;
	FOR(i,n-m+1,Brev.size()-1) Brev[i]=0;	//记得清零
	inv(Brev,Brevinv,n-m+1);
	init((n-m+1)<<1);
	NTT(Arev,Brevinv,Crev);
	FOR(i,0,n-m) C.push_back(Crev[n-m-i]);
	init(n<<1);
	NTT(B,C,D);
	FOR(i,0,m-1) D[i]=sub(A[i],D[i]);
	FOR(i,m,limit-1) D[i]=0;
}
void get_poly(int o,int l,int r){
	if(l==r) return void((poly[o].push_back(b[l]?mod-b[l]:0),poly[o].push_back(1)));
    //l=r时就是x-a_l
	int mid=(l+r)>>1;
	get_poly(lson);get_poly(rson);	//分治两边
	init(r-l+1);
	NTT(poly[o<<1],poly[o<<1|1],poly[o]);	//乘到自己这
}
void solve(vector<int> A,int o,int l,int r){
	if(r-l<=100){	//常数（？）优化
		FOR(i,l,r){
			int s=0;
			ROF(j,A.size()-1,0) s=add(1ll*s*b[i]%mod,A[j]);	//直接秦九韶
			ans[i]=s;
		}
		return;
	}
	vector<int> B;int mid=(l+r)>>1;
	modulo(A,poly[o<<1],B,r-l,mid-l+1);	//取模到左边
    //此时A的次数应该<=r-l
	solve(B,lson);
	modulo(A,poly[o<<1|1],B,r-l,r-mid);	//取模到右边
    //因为A一开始的次数（就是n）可能巨小无比，甚至<r-l，所以在取模中要把高位补齐，不然可能越界
	solve(B,rson);
}
int main(){
	n=read();m=read();
	FOR(i,0,n) a.push_back(read());
	FOR(i,1,m) b[i]=read();
	get_poly(1,1,m);
	modulo(a,poly[1],a,n,m);	//提前取模（注意！就是这里可能n<m，所以在取模中就要特判）
	solve(a,1,1,m);
	FOR(i,1,m) printf("%d\n",ans[i]);
}
```

---

## 作者：ZhongYuLin (赞：10)

解法来自 $2024$ 宋佳兴的集训队论文《论现代硬件上的常数优化》。

题目要求 $\sum_{i=0}^nc_ix^i$，形如内积，可以分块并循环展开加速计算。具体地，我们分 $256$ 为一块，快速处理出块内的 $x^i$。对于每个块内，使用无符号 $128$ 位整数存储答案来避免取模。注意到 $x\bmod P$ 等价于 $\left \lfloor\frac{x}{2^{64}}  \right \rfloor \times(2^{64}\bmod P)+((x\bmod 2^{64})\bmod P)$，式子前一半的取模部分可以预处理，而后一半可以使用约减，只要为加法留有足够的空间即可。

注意我们总是应该使用无符号整数类型，因为它们之间相互转换**几乎**没有代价。

下面是宋佳兴给出的实现。注意循环展开的预处理指令实际上是可以在洛谷上编译的。


```cpp
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
using u128 = unsigned __int128_t;
const int P = 998244353;
const int N = 65000;
int n, m;
u64 a[N], b[N];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 0; i <= n; ++i)
        cin >> a[i];
    for (int i = 0; i < m; ++i)
        cin >> b[i];
    for (int k = 0; k < m; k++)
    {
        const int B = 256;
        u64 pows[B + 1] = {1};
        for (int i = 0; i < B; i++)
            pows[i + 1] = pows[i] * b[k] % P;
        u64 res = 0;
        for (int i = n & -B; i >= 0; i -= B)
        {
            u128 s0 = 0;
            #pragma GCC unroll 2
            for (int j0 = 0; j0 < B; j0 += 16)
            {
                u64 s1 = 0;
                #pragma GCC unroll 16
                for (int j1 = 0; j1 < 16; j1++)
                    s1 += a[i + j0 + j1] * pows[j0 + j1];
                s0 += s1;
            }
            const u64 r64 = -(u64)P % P; // 2^64 % P
            u64 low = s0, high = s0 >> 64;
            if (low >= 8ULL * P * P)
                low -= 8ULL * P * P;
            res = (res * pows[B] + high * r64 + low) % P;
        }
        printf("%llu\n", res);
    }
}
```

---

## 作者：Illusory_dimes (赞：4)

### 题目大意
给定 $n-1$ 次多项式 $f(x)$ 和 $m$ 个数 $a_i$ ，求所有 $f(a_i)$ 的值。

答案对 $998244353$ 取模。

数据范围 $1\leq n,m\leq 6.4\cdot 10^4$ ， $0\leq a_i,[x^i]f(x)\leq 998244353$ 。

### 前置芝士：
多项式除法（但商没用，其实就是取模）。（不用牛顿迭代，甚至~~非常入门的~~求导，积分都不要，老少咸宜！）

不会出门左拐即可。。（应该已经没有人读到这里就走了吧）

### solution
多项式除法的话推荐俺的[文章](https://www.luogu.com.cn/blog/N-pilot-S/solution-p4512)。（其实随便那篇都行，了解原理了就好了）

先来两个推论：

1.$f(a_i)\equiv f(x)\ mod\ (x-a_i)$

感觉大佬们的证法不太好理解。。（是我太菜了）

其实还可以这样：

当我们对两个式子同除 $(x-a_i)$ 的时候。（都会写竖式吧

对于当前的被除数最高次项，在对齐了次数与系数后，减去了几个 $x$ ，就会站起来几个 $a_i$ 。

意思就是 $f(x)$ 除以 $(x-a_i)$ 的余数就可以化归成 $f(a_i)$ 。（当然肯定还能再除下去，主要是证明推论的成立）

那么对于柿子（其实就是多项式除法里的柿子）：

$f(x)=q(x)\cdot g(x)+r(x)$

如果我们构造 $g(x)=(x-a_i)$ 最后 $f(x)=r(x)$ ，注意膜一个一次项的多项式，最后就只会剩常数项（芜湖起飞。。）

2.$(f(x)\ mod\ \varphi(x)\cdot g(x))\ mod\ g(x)=f(x)\ mod\ g(x)$

把多项式替换成一个常数会好理解得多，模拟一下就好了。~~对 $c$ 取模还赶不上对 $n\cdot c$ 取模？~~

推论说完了（有没有感觉推论二有点迭代的意思？）

预处理出所有区间 $[l,r]$ 所对应的 $\prod_{i=l}^{r}{(x-a_i)}$ ，哇哦，乘积形式哟。

那么就可以考虑分治 FFT 了。

在递归的时候，让多项式直接对当前区间所对应的模数取模，然后继续向下传（根据推论二，这样做也不会有影响），最后到了叶子结点的时候就好了（根据推论一，最后膜完只剩常数项）

时间复杂度 $O(n\log_{2}^{2}{n})$ 。

人傻常熟大 wtcl 。。

（转置定理什么的压根不知道/kel）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=128e3+10;
typedef ll arr[N<<1];
const int mod=998244353;
const int inv3=332748118;
int n,m,g[N],lim=1,fre,id[N<<1];
arr f[20],fr,gr,gi,q,ans,tp1,tp2,tmp,F1,G1;
int rt,tot,ls[N],rs[N],Ans[N];
vector<int> v[N];
inline ll inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline ll dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline ll mul(ll x,ll y){return 1ll*x*y%mod;}
inline ll read()
{
	ll s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=(1ll*tmp*a)%mod;
		b>>=1,a=(1ll*a*a)%mod;
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=(1ll*NTT[i]*inv_lim)%mod;
	}
}
/*
此Inv非彼Inv，一定要注意
因为多项式是0~n/m而非0~(n-1)/(m-1)
调用的时候也要多加注意 
*/
inline void Inv(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	Inv(F,G,nm>>1);
	lim=1,fre=0;
	for(;lim<=(nm<<1);lim<<=1)++fre;
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<=nm;++i)ans[i]=F[i];
	for(int i=nm+1;i<=lim;++i)ans[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(G,1);
	for(int i=0;i<=lim;++i)G[i]=mul(inc(2ll,-mul(ans[i],G[i])+mod),G[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void Mul(ll* F,ll* G,int nm)
{
	if(nm)
	{
		lim=1,fre=0;
		for(;lim<=(nm<<1);lim<<=1)++fre;
	}
	for(int i=0;i<=lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<lim;++i)F1[i]=F[i],G1[i]=G[i];
	Never_Tell_TLE(F1,1),Never_Tell_TLE(G1,1);
	for(int i=0;i<lim;++i)F1[i]=mul(F1[i],G1[i]);
	Never_Tell_TLE(F1,-1);
	for(int i=0;i<lim;++i)F[i]=F1[i];
}
inline void Mod(ll* F,ll* G,ll* R,int n,int m,ll* FR,ll* GR,ll* GI,ll* Q)
{
	for(int i=0;i<=n;++i)FR[n-i]=F[i];
	for(int i=0;i<=m;++i)GR[m-i]=G[i];
	for(int i=n-m+1;i<=m;++i)GR[i]=0;
	int lm=1,fe=0;
	for(;lm<=(n-m);lm<<=1)++fe;
	Inv(GR,GI,lm);
	Mul(FR,GI,n);
	for(int i=0;i<=n-m;++i)Q[i]=FR[n-m-i];
	for(int i=n-m+1;i<=lim;++i)Q[i]=0;
	Mul(Q,G,n);
	for(int i=0;i<m;++i)R[i]=inc(F[i],-Q[i]+mod);
	for(int i=0;i<=lim;++i)FR[i]=GR[i]=GI[i]=Q[i]=0;
}
inline void tree_form(int &p,int l,int r)
{
	p=++tot;lim=1,fre=0;
	for(;lim<=(r-l+1);lim<<=1)++fre;
	v[p].resize(lim);
	if(l==r)
	{
		v[p][0]=dec(mod,g[l]),v[p][1]=1;
		return;
	}
	int mid=(l+r)>>1,cnt;
	tree_form(ls[p],l,mid),tree_form(rs[p],mid+1,r);
	lim=1,fre=0;
	for(;lim<=(r-l+1);lim<<=1)++fre;
	cnt=v[ls[p]].size();
	for(int i=0;i<cnt;++i)tp1[i]=v[ls[p]][i];
	for(int i=cnt;i<=lim;++i)tp1[i]=0;
	cnt=v[rs[p]].size();
	for(int i=0;i<cnt;++i)tp2[i]=v[rs[p]][i];
	for(int i=cnt;i<=lim;++i)tp2[i]=0;
	Mul(tp1,tp2,0);
	for(int i=0;i<lim;++i)v[p][i]=tp1[i];
}
inline void solve(int p,int l,int r,int dep,int siz)
{
	for(int i=0;i<=r-l+1;++i)tmp[i]=v[p][i];
	if(siz<r-l+1)for(int i=0;i<=r-l;++i)f[dep][i]=f[dep-1][i];
	else Mod(f[dep-1],tmp,f[dep],siz,r-l+1,fr,gr,gi,q);
	for(int i=0;i<=r-l+1;++i)tmp[i]=0;
	if(l==r)
	{
		Ans[l]=f[dep][0];
		return;
	}
	int mid=(l+r)>>1;
	solve(ls[p],l,mid,dep+1,r-l);
	solve(rs[p],mid+1,r,dep+1,r-l);
}
int main()
{
	n=read(),m=read();
	for(int i=0;i<=n;++i)f[0][i]=read();
	for(int i=1;i<=m;++i)g[i]=read();
	tree_form(rt,1,m);
	solve(rt,1,m,1,n);
	for(int i=1;i<=m;++i)printf("%d\n",Ans[i]);
	return 0;
}
```

只求能帮助到几个人罢。。

---

## 作者：Spasmodic (赞：3)

[模板](https://www.luogu.com.cn/problem/P5050)

多项式多点求值，即求多项式 $A(x)$ 在点 $x_1,x_2,\cdots,x_n$ 上分别取到的值。

构造函数
$$
\begin{aligned}
P_0(x)&=\prod_{i=1}^{\lfloor\frac{n}{2}\rfloor}(x-x_i)\\
P_1(x)&=\prod_{i=\lfloor\frac{n}{2}\rfloor+1}^{n}(x-x_i)
\end{aligned}
$$
设 $A(x)=P_0(x)D(x)+R(x)$，且 $\deg R<\deg P_0=\lfloor\frac{n}{2}\rfloor$。

那么对于 $\forall x\in \{x_1,x_2,\cdots,x_{\lfloor\frac{n}{2}\rfloor}\}$，都有 $A(x)=R(x)$，于是我们就将一个 $\deg =n$ ，有 $n$ 个点的问题，转化为一个 $\deg <\lfloor\frac{n}{2}\rfloor$ ，有 $\lfloor\frac{n}{2}\rfloor$ 个点的问题。

另一半点值与上面同理。

因此分治 NTT 即可，注意计算 $P_0(x)$ 和 $P_1(x)$ 同样可以用一次分治 NTT 预处理。

设计算的复杂度为 $T(x)$，则 $T(x)=2T(\frac{x}{2})+O(n\log n)$，此处 $O(n\log n)$ 的部分是算 $D(x),R(x)$ 的复杂度，容易发现预计算复杂度也是 $T(x)$。

由主定理可得总复杂度为 $O(n\log^2 n)$。

实际应用时可以通过用暴力秦九韶进行剪枝来优化常数。

考虑到本题调试较为困难 在此直接放出完整代码，总长 4.9K，没有经过刻意卡常，所以可读性尚可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct IO_Tp {
    const static int _I_Buffer_Size = 2 << 22;
    char _I_Buffer[_I_Buffer_Size], *_I_pos = _I_Buffer;

    const static int _O_Buffer_Size = 2 << 22;
    char _O_Buffer[_O_Buffer_Size], *_O_pos = _O_Buffer;

    IO_Tp() { fread(_I_Buffer, 1, _I_Buffer_Size, stdin); }
    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }

    IO_Tp &operator>>(ll &res) {
    	ll f=1;
        while (!isdigit(*_I_pos)&&(*_I_pos)!='-') ++_I_pos;
        if(*_I_pos=='-')f=-1,++_I_pos;
        res = *_I_pos++ - '0';
        while (isdigit(*_I_pos)) res = res * 10 + (*_I_pos++ - '0');
        res*=f;
        return *this;
    }

    IO_Tp &operator<<(ll n) {
    	if(n<0)*_O_pos++='-',n=-n;
        static char _buf[10];
        char *_pos = _buf;
        do
            *_pos++ = '0' + n % 10;
        while (n /= 10);
        while (_pos != _buf) *_O_pos++ = *--_pos;
        return *this;
    }

    IO_Tp &operator<<(char ch) {
        *_O_pos++ = ch;
        return *this;
    }
} IO;

const ll N=1048576,P=998244353;
#define clear(a) memset((a),0,len<<5)
namespace Poly{
    const ll G=3,img=86583718;
    ll lmt,rev[N],a[N],b[N],c[N],d[N],e[N],h[N],x[N],y[N],z[N],X[N],Y[N],ff[N],gg[N],iv[N],t[N];//poly1
    ll A[N],B[N],Len[N],*p[N];
    inline ll qpow(ll a,ll k){
        ll ret=1;
        while(k){
            if(k&1)ret=ret*a%P;
            a=(a*a)%P;
            k>>=1;
        }
        return ret%P;
    }
    inline void init(ll n){
        lmt=1;ll t=0;
        while(lmt<n)lmt<<=1,t++;
        for(ll i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
    }
    inline void NTT(ll *A,ll lmt,ll tp){
        for(ll i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
        for(ll m=1;m<lmt;m<<=1)
            for(ll j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
                for(ll k=0,w=1,x,y;k<m;k++,w=w*Wn%P)
                    x=A[j+k],y=w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
        if(tp==1)return;
        reverse(A+1,A+lmt);
        for(ll i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=A[i]*inv%P;
    } 
    inline void mul(ll *f,ll *g,ll len){
        init(len);
        NTT(f,lmt,1);NTT(g,lmt,1);
        for(ll i=0;i<lmt;i++)f[i]=(f[i]*g[i])%P;
        NTT(f,lmt,-1);
    } 
    void getinv(ll*f,ll*g,ll len){
        if(len==1){g[0]=qpow(f[0],P-2);return;}
        getinv(f,g,len+1>>1);
        init(len<<1);
        for(ll i=0;i<len;i++)c[i]=f[i];
        for(ll i=len;i<lmt;i++)c[i]=0;
        NTT(c,lmt,1),NTT(g,lmt,1);
        for(ll i=0;i<lmt;i++)g[i]=(2LL-g[i]*c[i]%P+P)%P*g[i]%P;
        NTT(g,lmt,-1);
        for(ll i=len;i<lmt;i++)g[i]=0; 
        clear(c);
    }
    inline void div(ll *f,ll *g,ll *q,ll *r,ll n,ll m){
        for(ll i=0,t=n-1;i<n;i++,t--)ff[i]=f[t];
        for(ll i=0,t=m-1;i<m;i++,t--)gg[i]=g[t];
        ll len=n-m+1;
        for(ll i=len;i<n;i++)ff[i]=gg[i]=0;
        getinv(gg,iv,len);
        mul(ff,iv,len<<1);
        for(ll i=0,t=len-1;i<len;i++)q[i]=ff[t--];
        for(ll i=len;i<n;i++)q[i]=0;
        for(ll i=0;i<n;i++)t[i]=q[i];
        len=n;
        clear(gg);
        for(ll i=0;i<m;i++)gg[i]=g[i];
        mul(t,gg,n<<1);
        for(ll i=0;i<m-1;i++)r[i]=(f[i]-t[i]+P)%P;
        clear(ff),clear(gg),clear(iv),clear(t);
    }
    void getP(const ll *a,ll k,ll l,ll r){
    	if(l==r){
    		Len[k]=1;
    		p[k]=new ll[2];
    		p[k][0]=P-a[l];
    		p[k][1]=1;
    		return;
		}
		ll mid=l+r>>1;
		getP(a,k<<1,l,mid);
		getP(a,k<<1|1,mid+1,r);
		Len[k]=Len[k<<1]+Len[k<<1|1];
		p[k]=new ll[Len[k]+1];
		init(Len[k]+1<<1);
		static ll A[N],B[N];
		for(ll i=0;i<=Len[k<<1];i++)A[i]=p[k<<1][i];
		for(ll i=Len[k<<1]+1;i<lmt;i++)A[i]=0;
		for(ll i=0;i<=Len[k<<1|1];i++)B[i]=p[k<<1|1][i];
		for(ll i=Len[k<<1|1]+1;i<lmt;i++)B[i]=0;
		NTT(A,lmt,1);NTT(B,lmt,1);
		for(ll i=0;i<lmt;i++)A[i]=A[i]*B[i]%P;
		NTT(A,lmt,-1);
		for(ll i=0;i<=Len[k];i++)p[k][i]=A[i];
	}
	void solve(ll k,ll l,ll r,const ll *a,ll *A,ll *ans){
		if(Len[k]<=500){
			ll m=Len[k]-1;
			for(ll i=l;i<=r;i++)
				for(ll j=m;j>=0;j--)
					ans[i]=(ans[i]*a[i]+A[j])%P;
			return;
		}
		if(l==r){ans[l]=*A;return;}
		ll mid=l+r>>1,R[Len[k]+2>>1];
		static ll t[N];
		div(A,p[k<<1],t,R,Len[k],Len[k<<1]+1);
		solve(k<<1,l,mid,a,R,ans);
		div(A,p[k<<1|1],t,R,Len[k],Len[k<<1|1]+1); 
		solve(k<<1|1,mid+1,r,a,R,ans);
	}
	void evaluation(ll *f,ll *a,ll *ans,ll n,ll m){
		getP(a,1,1,m); 
		if(n>m){
			static ll t[N];
			div(f,p[1],t,f,n,m+1);
		}
		solve(1,1,m,a,f,ans);
	}
}
using Poly::evaluation;
ll n,m,f[N],a[N],ans[N];
int main(){
	IO>>n>>m;n++;
	for(ll i=0;i<n;i++)IO>>f[i];
	for(ll i=1;i<=m;i++)IO>>a[i];
	evaluation(f,a,ans,n,m);
	for(ll i=1;i<=m;i++)IO<<ans[i]<<'\n';
	return 0;
}
```


---

## 作者：Newuser (赞：3)


问题：给定一个n次多项式f(x)，现在请你对于i∈[1,m]，求出f(ai​)。

我们考虑分治处理，对于i∈[1,m/2] , 我们构造一个g(x) = ∏（x-ai) (1<=i<=n/2),我们发现对于[1,m/2]中所有的x值代入这个函数值都为0，那么我们直接对于[1,m/2]的原函数的f都%上g(x)应该是不会影响（即消除掉若干个g(x)不会影响)。这样就可以同时达到消除大于等于x^(m/2)次项的目的，我们发现消除到最后剩下的那个常数项的值恰好就是我们要求的f(x)（因为除了常数项都被我们消除掉了）, 时间复杂度为O（nlog^2n)

我们写成一个类似线段树的结构把插值的多项式存下来。

[欢迎来Newuser小站玩owo](http://www.newuser.top/2018/12/04/%E3%80%90moban%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/)
```cpp
#include<stdio.h>
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<vector>
using namespace std;
const int maxn = 64005;
const int mod = 998244353;
const int g = 3;
int mul(int x,int y) { return 1ll*x*y%mod; }
int add(int x,int y) { x+=y; return x>=mod?x-mod:x; }
int sub(int x,int y) { x-=y; return x<0?x+mod:x; }
int ksm(int a,int b) {
	int ans = 1;
	for(;b;b>>=1,a=mul(a,a))
		if(b&1) ans = mul(ans,a);
	return ans;
}
void ntt(int *a,int deg,int dft) {
	for(int i=0,j=0;i<deg;i++) {
		if(i<j) swap(a[i],a[j]);
		for(int k=(deg>>1);(j^=k)<k;k>>=1);
	}
	for(int st=1;st<deg;st<<=1) {
		int dwg = (dft==1) ? ksm(g,(mod-1)/(st<<1)) : ksm(g,mod-1-(mod-1)/(st<<1));
		for(int i=0;i<deg;i+=(st<<1)) {
			int ng = 1;
			for(int j=i;j<i+st;j++) {
				int x = a[j]; int y = mul(ng,a[j+st]);
				ng = mul(ng,dwg);
				a[j] = add(x,y); a[j+st] = add(x,mod-y);
			}
		}
	}
	if(dft==1) return;
	int invs = ksm(deg,mod-2);
	for(int i=0;i<deg;i++) a[i] = mul(invs,a[i]);
}
int F[18][maxn*4];
int n,m;
int ta[maxn*4],tb[maxn*4];
void MULL(int *a,int *b,int *c,int le) {
	for(int i=0;i<le;i++) ta[i]=b[i];
	for(int j=0;j<le;j++) tb[j]=c[j];
	ntt(ta,le,1); ntt(tb,le,1);
	for(int i=0;i<le;i++) ta[i]=mul(ta[i],tb[i]);
	ntt(ta,le,-1);
	for(int i=0;i<le;i++) a[i] = ta[i];
}
void ginv(int deg,int *a,int *b) {
	if(deg==1) { b[0]=ksm(a[0],mod-2); return; }
	ginv(deg>>1,a,b);
	for(int i=0;i<deg;i++) ta[i]=a[i];
	for(int i=deg;i<(deg<<1);i++) ta[i]=0;
	ntt(ta,deg<<1,1); ntt(b,deg<<1,1);
	for(int i=0;i<(deg<<1);i++) b[i]=mul(b[i],sub(2,mul(ta[i],b[i])));
	ntt(b,(deg<<1),-1);
	for(int i=deg;i<(deg<<1);i++) b[i]=0;
}
int Q[maxn*4],Fr[maxn*4],Gr[maxn*4],Gri[maxn*4],tmp[maxn*4];
void gmod(int *O,int *F,int *G,int n,int m) {//F%G==O (F n G m)
	for(int i=0;i<=n;i++) Fr[i] = F[n-i];
	for(int i=0;i<=m;i++) Gr[i] = G[m-i];
	for(int i=n-m+2;i<=m;i++) Gr[i] = 0;
	int le = 1; for(;le<=(n-m);le<<=1);
	for(int i=n-m+1;i<=m;i++) Gr[i]=0;
	ginv(le,Gr,Gri);
	le = 1; for(;le<=(n<<1);le<<=1);
	MULL(Q,Gri,Fr,le);
	reverse(Q,Q+n-m+1);
	for(int i=n-m+1;i<le;i++) Q[i]=0;
	MULL(tmp,Q,G,le);
	for(int i=0;i<m;i++) O[i] = sub(F[i],tmp[i]);
	for(int i=0;i<le;i++) tmp[i] = Fr[i] = Gr[i] = Gri[i] = Q[i] = 0;
}
vector<int>ve[maxn*2];
int tot,rt,ls[maxn*2],rs[maxn*2],X[maxn];
int tpa[maxn*4],tpb[maxn*4],tpc[maxn*4];
void maketree(int &p,int l,int r) {
	p = ++tot;
	int len = 1; for(;len<r-l+2;len<<=1);
	ve[p].resize(len); // len ci
	if(l==r) {
		ve[p][0] = (mod-(X[l]%mod+mod)%mod); ve[p][1] = 1; return; 
	}
	int mid = (l+r)>>1;
	maketree(ls[p],l,mid); maketree(rs[p],mid+1,r);
	
	int ss = ve[ls[p]].size();
	for(int i=0;i<ss;i++) tpa[i] = ve[ls[p]][i]; for(int i=ss;i<len;i++) tpa[i]=0;
	
		ss = ve[rs[p]].size();
	for(int i=0;i<ss;i++) tpb[i] = ve[rs[p]][i]; for(int i=ss;i<len;i++) tpb[i]=0;

	MULL(tpc,tpa,tpb,len);
	for(int i=0;i<len;i++) ve[p][i] = tpc[i];
}
int G[maxn*4];
int ANS[maxn];
void DC(int dep,int p,int l,int r,int cs) {
	int m = r-l+1;
	for(int i=0;i<=m;i++) G[i] = ve[p][i];
	if(cs>=m) gmod(F[dep],F[dep-1],G,cs,m);
	else {
		for(int i=0;i<=m-1;i++) F[dep][i] = F[dep-1][i];
	}
	for(int i=0;i<=m;i++) G[i] = 0;
	if(l==r) {
		ANS[l] = F[dep][0];
		return;
	}
	int mid = (l+r)>>1;
	DC(dep+1,ls[p],l,mid,m-1);
	DC(dep+1,rs[p],mid+1,r,m-1);
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n;i++) {
		int x; scanf("%d",&x);
		F[0][i] = x;
	}
	for(int i=1;i<=m;i++) scanf("%d",&X[i]);
	maketree(rt,1,m);
	for(int i=0;i<=m;i++) G[i] = ve[rt][i];
	DC(1,rt,1,m,n);
	for(int i=1;i<=m;i++) printf("%d\n",ANS[i]);
}
```

---

## 作者：封禁用户 (赞：3)

![](https://cdn.luogu.com.cn/upload/pic/48589.png)  
一定要及时清空存储多项式数组中不相关的项。  
请忽略大量调试代码。  

```cpp
#pragma GCC optimize("Ofast")
#include <assert.h>
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstring>
#include <ctime>
#include <iostream>
#include <vector>
using int_t = int;
using std::cin;
using std::cout;
using std::endl;
#ifdef DEBUG
#define debug(x) cout << #x << " = " << x << endl;
#else
#define debug(x)

#endif

const int_t mod = 998244353;
const int_t g = 3;
const int_t LARGE = 1 << 20;
int_t power(int_t base, int_t index);
void transform(int_t *A, int_t size, int_t arg);
constexpr int_t upper2n(int_t x);
void poly_mul(int_t *A, int_t *B, int_t size);
void poly_inv(int_t *A, int_t *inv, int_t n);
void poly_div(int_t *A, int_t n, int_t *B, int_t m, int_t *Q, int_t *R);
void poly_dc_mul(int_t *base, int_t n);
void poly_evaluation(int_t *A, const int_t *seq, int_t *result, int_t left,
                     int_t right);

template <class T>
std::ostream &operator<<(std::ostream &os, std::vector<T> &x) {
    os << "{ ";
    for (int_t v : x) os << v << " ";
    os << "} ";
    return os;
}
inline int_t bitRev(int_t x, int_t size2) {
    int_t res = 0;
    for (int_t i = 1; i < size2; i++) {
        res |= (x & 1);
        res <<= 1;
        x >>= 1;
    }
    return res | (x & 1);
};
int bitRevs[20][LARGE + 1];
int main() {
#ifdef TIME
    auto begin = clock();
#endif
    for (int_t i = 1; (1 << i) < LARGE; i++) {
        for (int_t j = 0; j < LARGE; j++) {
            bitRevs[i][j] = bitRev(j, i);
        }
    }
    // {
    //     static int_t A[LARGE], B[LARGE];
    //     int_t n, m;
    //     cin >> n >> m;
    //     for (int_t i = 0; i <= n; i++) cin >> A[i];
    //     for (int_t i = 0; i <= m; i++) cin >> B[i];
    //     int_t size = upper2n(n + m + 1);
    //     transform(A, size);
    //     for (int_t i = 0; i < size; i++) cout << A[i] << " ";
    //     cout << endl;
    //     transform(B, size);
    //     for (int_t i = 0; i < size; i++) cout << B[i] << " ";
    //     cout << endl;
    //     for (int_t i = 0; i < size; i++) A[i] = 1ll * A[i] * B[i] % mod;
    //     transform<-1>(A, size);
    //     for (int_t i = 0; i <= n + m; i++)
    //         cout << 1ll * A[i] * power(size, -1) % mod << " ";
    //     return 0;
    // }

    int n, m;
    static int_t A[LARGE], seq[LARGE], result[LARGE];
    scanf("%d%d", &n, &m);
    for (int_t i = 0; i <= n; i++) scanf("%d", &A[i]);
    for (int_t i = 0; i < m; i++) scanf("%d", &seq[i]);
    poly_evaluation(A, seq, result, 0, std::max(n + 1, m));
    for (int_t i = 0; i < m; i++) {
        printf("%d\n", (int)result[i]);
    }
#ifdef TIME
    auto end = clock();
    std::cerr << (end - begin) / (1.0 * CLOCKS_PER_SEC) << endl;
#endif
    return 0;
}

//计算n-1次多项式A代入x的值
int_t sub(int_t *A, int_t n, int_t x) {
    int_t result = 0;
    for (int_t i = 0; i < n; i++) {
        result = ((int64_t)result * x + A[n - i - 1]) % mod;
    }
    return result;
}

//[left,right]闭区间
//下标从0开始
void poly_evaluation(int_t *A, const int_t *seq, int_t *result, int_t left,
                     int_t right) {
    if (right - left <= 2000) {
        for (int_t i = left; i <= right; i++) {
            result[i] = sub(A + left, right - left + 1, seq[i]);
        }
        return;
    }
    if (left == right) {
        result[left] = A[left];
        return;
    }
    static int_t P0[LARGE], P1[LARGE], Q[LARGE], R0[LARGE], R1[LARGE];
    int_t mid = (right + left) / 2;
    int_t size = upper2n(right - left + 2);
    for (int_t i = 0; i < size; i++) {
        P0[i] = P1[i] = 0;
    }
    int_t size1 = upper2n((mid - left + 1) * 2 + 1),
          size2 = upper2n((right - mid) * 2 + 1);
    for (int_t i = 0; i < std::max(size1, size2); i += 2) {
        P0[i] = P1[i] = 1;
    }
    for (int_t i = 0; i < mid - left + 1; i++) {
        P0[i * 2] = -seq[i + left];
        P0[i * 2 + 1] = 1;
    }
    for (int_t i = 0; i < right - mid; i++) {
        P1[i * 2] = -seq[i + mid + 1];
        P1[i * 2 + 1] = 1;
    }
#ifdef DEBUG
    cout << "processing at interval " << left << "," << right << endl;
    cout << "mid = " << mid << endl;
    // cout << "size0=" << size0 << endl;
    cout << "size1=" << size1 << ",size2=" << size2 << endl;
    // cout << "size=" << size << endl;
    cout << "A ";
    for (int_t i = left; i <= right; i++) cout << A[i] << " ";
    cout << endl;
    cout << "P0 ";
    for (int_t i = 0; i < size1; i++) cout << P0[i] << " ";
    cout << endl;
    cout << "P1 ";
    for (int_t i = 0; i < size2; i++) cout << P1[i] << " ";
    cout << endl;
#endif
    poly_dc_mul(P0, size1);
    poly_dc_mul(P1, size2);
    poly_div(A + left, right - left, P0, mid - left + 1, Q, R0);
    poly_div(A + left, right - left, P1, right - mid, Q, R1);
    for (int_t i = mid - left + 1; i < size1; i++) R0[i] = 0;
    for (int_t i = right - mid; i < size2; i++) R1[i] = 0;

#ifdef DEBUG

    cout << "P0 ";
    for (int_t i = 0; i <= mid - left + 1; i++) cout << P0[i] << " ";
    cout << endl;
    cout << "P1 ";
    for (int_t i = 0; i <= right - mid; i++) cout << P1[i] << " ";
    cout << endl;
    cout << "R0 ";
    for (int_t i = 0; i < size1; i++) cout << R0[i] << " ";
    cout << endl;
    cout << "R1 ";
    for (int_t i = 0; i < size2; i++) cout << R1[i] << " ";
    cout << endl;

#endif
    for (int_t i = 0; i < mid - left + 1; i++) {
        A[i + left] = R0[i];
    }
    for (int_t i = 0; i < right - mid; i++) {
        A[i + mid + 1] = R1[i];
    }
#ifdef DEBUG
    cout << "A modfied ";
    for (int_t i = left; i <= right; i++) cout << A[i] << " ";
    cout << endl;
#endif
#ifdef DEBUG
    cout << endl << endl;
#endif
    poly_evaluation(A, seq, result, left, mid);
    poly_evaluation(A, seq, result, mid + 1, right);
}
//计算分治乘法,n是项数,必须是2的幂次
//初始时base中存放着若干个次数为1的多项式，每个占了两个位置
inline void poly_dc_mul(int_t *base, int_t n) {
#ifdef DEBUG

    // cout << "calc " << endl;
    // for (int_t i = 0; i < n; i++)
    //     cout << base[i] << " ";
    // cout << "="
    //      << " ";
    assert((1 << (int_t)log2(n)) == n);
#endif

    //枚举块大小
    for (int_t i = 4; i <= n; i *= 2) {
        //每块前后两部分相乘
        for (int_t j = 0; j < n; j += i) {
            static int_t A[LARGE], B[LARGE];
            std::fill(A, A + i, 0);
            std::fill(B, B + i, 0);
            std::copy(base + j, base + j + i / 2, A);
            std::copy(base + j + i / 2, base + j + i, B);
            poly_mul(A, B, i);
            std::copy(A, A + i, base + j);
        }
    }
#ifdef DEBUG
    // for (int_t i = 0; i < n; i++)
    //     cout << base[i] << " ";
    // cout << endl
    //      << endl;
#endif
}
//计算n次多项式A除以m次多项式B的商和余数。
//需要确保高次项干净。
inline void poly_div(int_t *A, int_t n, int_t *B, int_t m, int_t *Q, int_t *R) {
    const int_t size = upper2n(n + m + 1);
    // #ifdef DEBUG
    // cout<<"moding "
    // #endif
    static int_t Ax[LARGE], Bx[LARGE], Qx[LARGE], Binv[LARGE];
    for (int_t i = 0; i <= n; i++) Ax[i] = A[n - i];
    for (int_t i = 0; i <= m; i++) Bx[i] = B[m - i];
    const int_t len = size - (n - m + 1);
    memset(&Ax[n - m + 1], 0, sizeof(int_t) * len);
    memset(&Bx[n - m + 1], 0, sizeof(int_t) * len);
    poly_inv(Bx, Binv, n - m + 1);
    memcpy(Bx, Binv, sizeof(int_t) * (n - m + 1));
    memset(&Ax[n - m + 1], 0, sizeof(int_t) * len);
    poly_mul(Ax, Bx, size);
    for (int_t i = 0; i <= n - m; i++) {
        Qx[i] = Q[i] = Ax[n - m - i];
    }
    memset(&Qx[n - m + 1], 0, sizeof(int_t) * len);
    poly_mul(Qx, B, size);
    for (int_t i = 0; i <= m - 1; i++)
        R[i] = ((int64_t)A[i] - Qx[i] + 2 * mod) % mod;
}
inline void poly_mul(int_t *A, int_t *Bx, int_t size) {
    static int_t B[LARGE + 1];
    memcpy(B, Bx, sizeof(int_t) * size);
    transform(A, size, 1);
    transform(B, size, 1);
    for (int_t i = 0; i < size; i++) A[i] = (int64_t)A[i] * B[i] % mod;
    transform(A, size, -1);
    const int_t inv = power(size, -1);
    for (int_t i = 0; i < size; i++) A[i] = (int64_t)A[i] * inv % mod;
}
void poly_inv(int_t *A, int_t *inv, int_t n) {
    static int_t Ax[LARGE];
    if (n == 1) {
        inv[0] = power(A[0], -1);
        // for (int_t i = 1; i < upper2n(3); i++) inv[i] = 0;
        return;
    }
    poly_inv(A, inv, n / 2 + n % 2);
    // C(x)<-2B(x)-A(x)B(x)^2
    int_t size = upper2n(3 * n + 1);
    for (int_t i = 0; i < size; i++) {
        if (i < n)
            Ax[i] = A[i];
        else
            Ax[i] = 0;
    }
    for (int_t i = n; i < size; i++) inv[i] = 0;
    // for(int_t i=)
    transform(Ax, size, 1);
    transform(inv, size, 1);
    for (int_t i = 0; i < size; i++)
        inv[i] = ((int64_t)2 * inv[i] -
                  (int64_t)Ax[i] * inv[i] % mod * inv[i] % mod + 2 * mod) %
                 mod;
    transform(inv, size, -1);
    const int_t size_inv = power(size, -1);
    for (int_t i = 0; i < size; i++) {
        if (i < n)
            inv[i] = (int64_t)inv[i] * size_inv % mod;
        else
            inv[i] = 0;
    }
}
inline constexpr int_t upper2n(int_t x) {
    int_t res = 1;
    while (res < x) res *= 2;
    return res;
}
inline void transform(int_t *A, int_t size, int_t arg) {
    const int_t size2 = log2(size);
    for (int_t i = 0; i < size; i++) {
        int_t x = bitRevs[size2][i];
        if (x > i) std::swap(A[x], A[i]);
    }
    for (int_t i = 2; i <= size; i *= 2) {
        int_t mr = power(g, arg * (mod - 1) / i);
        int_t *p1 = A;
        int_t *p2 = p1 + i / 2;
        int_t counter = 0;
        int_t curr = 1;
        while (p2 < A + size) {
            int_t u = *p1, t = *p2 * (int64_t)curr % mod;
            *p1 = (u + t) % mod;
            *p2 = ((int64_t)u - t + (int64_t)2 * mod) % mod;
            curr = (int64_t)curr * mr % mod;
            counter += 1;
            p1++;
            p2++;
            if (counter == (i >> 1)) {
                counter = 0;
                p1 += (i >> 1);
                p2 += (i >> 1);
                curr = 1;
            }
        }
    }
}

int_t power(int_t base, int_t index) {
    const int_t phi = mod - 1;
    base = (base % mod + mod) % mod;
    index = (index % phi + phi) % phi;
    int_t result = 1;
    while (index) {
        if (index & 1) result = (int64_t)result * base % mod;
        base = (int64_t)base * base % mod;
        index >>= 1;
    }
    return result;
}
```
------------

为什么洛谷还不支持多行Latex啊...  
AxMath导出都没法用了..


---

## 作者：tylon2006 (赞：2)

整了一天，没救了（

使用了非（多次）取模做法，但是一个点跑 1.2s，难过。

---

#### 理论推导

约定 $n$ 为 $F(x)$ 的项数，其最高次为 $n-1$ 次。

由余式定理有 $F(x_i)=F(z) \mod (z-x_i)$，余式 $R_i$ 只有常数项。

设 $G_i=x_i+z$，$Q_i,R_i$ 的意义与多项式取模中的相同。

由于 $G_i$ 是一次式，则 $Q_i$ 最高次为 $n-2$ 次。

多项式取模告诉我们 $Q_{iR}\equiv F_R \cdot G_{iR}^{-1}\ \ \ (\mod z^{n-m+1})$。

设 $Q_{R(l,r)}=F_R\cdot (\prod_{i=l}^rG_{iR})^{-1}$。因为需要用于分治计算，不再考虑原来的模意义。

可以发现有 $Q_{R(l,mid)}\equiv Q_{R(l,r)} \cdot \prod_{i=mid+1}^rG_{iR}$，$Q_{R(mid+1,r)}$ 同理。于是可以分治解决。

又因为 $R_i$ 只有常数项，我们只需要求出 $Q_i$ 的常数项，即 $[z^{n-2}]Q_{iR}$，即 $Q_{iR}$ 的最高位。可以发现当分治进入子区间时，由于还能乘上的 $G_i$ 只有 $len-1$ 个，最终能贡献到最高位的只有后 $len$ 个位置，只保存有贡献的位置即可（此处 $len$ 为子区间长度）。

注意此处的**后 $len$ 个位置**指的是相对于 $z^{n-2}$ 在本区间对应位置而言的，这是令人迷惑的，可以自己画个图感受一下。具体实现见下文。

于是复杂度为 $O(n\log^2n)$。

---

#### 具体实现

仅供参考。

首先预处理一下每个分治段的 $\prod_{i=l}^{r}G_{iR}$。

以便处理，我们钦定 $z^{n-2}$ 在当前区间 $(l,r)$ 的对应位置是 $Q_{R(l,r)}$ 的最高位，即 $z^{len-1}$，$len=r-l+1$。

举个例子，分治到左区间时： 
$$Q_{R(l,mid)}=\sum_{i=\frac{len}{2}}^{len-1}x^{i-\frac{len}{2}}\cdot [x^{i}](Q_{R(l,r)}
 \prod_{j=mid+1}^{r}G_{jR})$$
 
那我们大概需要将第一层分治的 $Q_R$ 右移一位。

搞清楚这个，大概就可以实现了。

其他两篇题解的代码是真的没看懂，不知道为啥要翻转 $G_{R}^{-1}$，好像用了一些神秘操作。

---

#### Code

给点核心代码。

因为 $\prod G_{iR}$ 常数项必然为 1，所以可以去掉，那么项数就与区间长度相同，于是可以用静态数组保存，而不必动态开点。

此处将 m 补齐至二的次幂，同时满足 $n>m$，省去大量细节。

EVA->新世纪福音战士

```
void eva_solve(ull *F,int l,int r,int dep,int id){
	static ull H[maxn],A[maxn],B[maxn],x,y;
	if(l==r) return;
	int len=r-l+1;
	int lim=len<<1;
	int mid=(l+r)>>1; 
	memcpy(H,EVA[dep]+l,8*len);
	memcpy(A+1,EVA[dep+1]+l,4*len),A[0]=1;
	memcpy(B+1,EVA[dep+1]+mid+1,4*len),B[0]=1;
	NTT(H,1,lim,id),NTT(A,1,lim,id),NTT(B,1,lim,id);
	for(int i=0;i<lim;++i){
		x=A[i],y=B[i];
		A[i]=H[i]*y%p[id];
		B[i]=H[i]*x%p[id];
	}
	NTT(A,-1,lim,id),NTT(B,-1,lim,id);
	memcpy(EVA[dep+1]+l,A+(len>>1),4*len);//后len>>1个
	memcpy(EVA[dep+1]+mid+1,B+(len>>1),4*len);
	memset(H,0,8*lim),memset(A,0,8*lim),memset(B,0,8*lim);
	eva_solve(F,l,mid,dep+1,id);
	eva_solve(F,mid+1,r,dep+1,id);
}
void eva_init(ull *X,int l,int r,int dep,int id){
	static ull A[maxn],B[maxn];
	if(l==r){
		EVA[dep][l]=X[l]>0?p[id]-X[l]:-X[l];
		return;
	}
	int len=r-l+1;
	int mid=(l+r)>>1;
	eva_init(X,l,mid,dep+1,id);
	eva_init(X,mid+1,r,dep+1,id);
	int lim=len<<1;
	memcpy(A+1,EVA[dep+1]+l,4*len),A[0]=1;
	memcpy(B+1,EVA[dep+1]+mid+1,4*len),B[0]=1;
	NTT(A,1,lim,id),NTT(B,1,lim,id);
	for(int i=0;i<lim;++i) 
	A[i]=A[i]*B[i]%p[id];
	NTT(A,-1,lim,id);
	memcpy(EVA[dep]+l,A+1,8*len);
	memset(A,0,8*lim);
	memset(B,0,8*lim);
}
void eva(ull *F,ull *G,ull *X,int len,int id){//X即xi
	static ull H[maxn],T[maxn];
	int lim=len<<1;
	eva_init(X,0,len-1,0,id);
	memcpy(H+1,EVA[0],8*len),H[0]=1;
	invf(H,T,len+1,id);
	memcpy(H,F,8*len),H[len]=0;
	reverse(H,H+len);
	NTT(H,1,lim,id),NTT(T,1,lim,id);
	for(int i=0;i<lim;++i)
	H[i]=H[i]*T[i]%p[id];
	NTT(H,-1,lim,id);
	memcpy(EVA[0]+1,H,8*(len-1)),EVA[0][0]=0;//右移一位
	eva_solve(F,0,len-1,0,id);
	for(int i=0;i<len;++i)
	G[i]=add(F[0],EVA[to[len]][i]*X[i]%p[id],p[id]);
	memset(T,0,8*(len+1));
	memset(H,0,8*len);
}
```

---

## 作者：Memory_of_winter (赞：2)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10201900.html)

**题目大意：**给你一个$n$次多项式$f(x)$，以及$m$个$x_i$，对于$i\in[1,m]$，求$f(x_i)$

**题解：**多项式多点求值

令$g(x)=\prod\limits_{i=1}^m(x-x_i)$，求出$R(x)$使得$f(x)=Q(x)\times g(x)+R(x)$。因为当$x=x_i$时，$g(x)=0$，即$f(x)=R(x)$，$f(x)$是$n$次的，$R(x)$是$m-1$次的，似乎可以使得问题缩小了

考虑分治，现在区间为$[l,r]$，令$g_L(x)=\prod\limits_{i=l}^{mid}(x-x_i)$，$g_R(x)=\prod\limits_{i=mid}^r(x-x_i)$，所以$R_L(x)=f(x)\bmod g_L(x)$，$R_R(x)=f(x)\bmod g_R(x)$。最后当$l=r$时，第$i$个的值就是当前$R(x)$的常数项。

那$g(x)$怎么算呢，分治$FFT$，可以先把每个的$g(x)$求出来，用$vector$保存一下就行了

**卡点：**不知道为什么，用$C++$会$MLE$，$C++11$就过了，有可能是$vector$初始化部分出锅了



**C++ Code：**

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
const int mod = 998244353, G = 3;

namespace Math {
	inline int pw(int base, int p) {
		static int res;
		for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
		return res;
	}
	inline int inv(int x) { return pw(x, mod - 2); }
}
inline void reduce(int &x) { x += x >> 31 & mod; }

#define maxn 65536
int a[maxn], ans[maxn];
namespace Poly {
#define N maxn
	int rev[N], lim, s, ilim;
	int Wn[N + 1];
	inline void clear(register int *l, const int *r) {
		if (l >= r) return ;
		while (l != r) *l++ = 0;
	}

	inline void init(const int n) {
		s = -1, lim = 1; while (lim < n) lim <<= 1, ++s; ilim = Math::inv(lim);
		for (register int i = 0; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const int t = Math::pw(G, (mod - 1) / lim);
		*Wn = 1; for (register int *i = Wn; i != Wn + lim; ++i) *(i + 1) = static_cast<long long> (*i) * t % mod;
	}
	inline void NTT(int *A, const int op = 1) {
		static int Wt[N];
		for (register int i = 1; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			*Wt = Wn[op ? 0 : lim];
			for (register int *i = Wt, W = 0; i != Wt + mid; ++i, W += t) *i = Wn[op ? W : lim - W];
			for (register int i = 0; i < lim; i += mid << 1) {
				for (register int j = 0; j < mid; ++j) {
					const int X = A[i + j], Y = static_cast<long long> (Wt[j]) * A[i + j + mid] % mod;
					reduce(A[i + j] += Y - mod), reduce(A[i + j + mid] = X - Y);
				}
			}
		}
		if (!op) for (register int *i = A; i != A + lim; ++i) *i = static_cast<long long> (*i) * ilim % mod;
	}

	std::vector<int> P[N << 1], S[N << 1];
	int C[N], D[N];
	void DC_NTT(int rt, int l, int r) {
		if (l == r) { P[rt] = {a[l], 1}; return ; }
		int mid = l + r >> 1;
		DC_NTT(rt << 1, l, mid), DC_NTT(rt << 1 | 1, mid + 1, r);
		int L = rt << 1, R = rt << 1 | 1;
		int n = P[L].size(), m = P[R].size();
		init(n + m - 1);
		std::copy(P[L].begin(), P[L].end(), C); clear(C + n, C + lim);
		std::copy(P[R].begin(), P[R].end(), D); clear(D + m, D + lim);
		NTT(C), NTT(D);
		for (int i = 0; i < lim; ++i) C[i] = static_cast<long long> (C[i]) * D[i] % mod;
		NTT(C, 0);
		P[rt].assign(C, C + n + m - 1);
	}

	int E[N];
	void INV(int *A, int *B, int n) {
		if (n == 1) {
			*B = Math::inv(*A);
			return ;
		}
		INV(A, B, n + 1 >> 1);
		init(n + n - 1);
		std::copy(A, A + n, E); clear(E + n, E + lim);
		clear(B + (n + 1 >> 1), B + lim);
		NTT(B), NTT(E);
		for (int i = 0; i < lim; ++i) B[i] = (2 + mod - static_cast<long long> (B[i]) * E[i] % mod) * B[i] % mod;
		NTT(B, 0); clear(B + n, B + lim);
	}
	int F[N];
	void DIV(int A, int n, int B, int m) {
		const int len = n - m + 1;
		init(len << 1);
		std::reverse_copy(S[A].begin(), S[A].end(), C); clear(C + len, C + lim);
		std::reverse_copy(P[B].begin(), P[B].end(), D); clear(D + len, D + lim);
		clear(F, F + lim);
		INV(D, F, len);
		NTT(C), NTT(F);
		for (int i = 0; i < lim; ++i) F[i] = static_cast<long long> (F[i]) * C[i] % mod;
		NTT(F, 0);
		clear(F + len, F + lim);
	}
	void __DIVMOD(int res, int A, int n, int B, int m) {
		if (n < m) {
			S[res].assign(S[A].begin(), S[A].end());
			return ;
		}
		DIV(A, n, B, m);
		init(n);
		std::reverse_copy(F, F + n - m + 1, C); clear(C + n - m + 1, C + lim);
		std::copy(P[B].begin(), P[B].end(), D); clear(D + m, D + lim);
		NTT(C), NTT(D);
		for (int i = 0; i < lim; ++i) C[i] = static_cast<long long> (C[i]) * D[i] % mod;
		NTT(C, 0);
		for (int i = 0; i < m - 1; ++i) reduce(C[i] = S[A][i] - C[i]);
		S[res].assign(C, C + m - 1);
	}
	void DIVMOD(int res, int A) {
		int n = S[A].size(), m = P[res].size();
		__DIVMOD(res, A, n, res, m);
	}

	void solve(int rt, int l, int r) {
		if (l == r) {
			ans[l] = S[rt][0];
			return ;
		}
		int mid = l + r >> 1;
		DIVMOD(rt << 1, rt), DIVMOD(rt << 1 | 1, rt);
		solve(rt << 1, l, mid), solve(rt << 1 | 1, mid + 1, r);
	}

	void work(int *f, int n, int m) {
		DC_NTT(1, 1, m);
		S[0].assign(f, f + n);
		DIVMOD(1, 0);
		solve(1, 1, m);
	}
#undef N
}

int n, m;
int f[maxn];
int main() {
	scanf("%d%d", &n, &m); if (!m) return 0; ++n;
	for (int i = 0; i < n; ++i) scanf("%d", f + i);
	for (int i = 1; i <= m; ++i) scanf("%d", a + i), reduce(a[i] = -a[i]);
	Poly::work(f, n, m);
	for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
	return 0;
}

```



---


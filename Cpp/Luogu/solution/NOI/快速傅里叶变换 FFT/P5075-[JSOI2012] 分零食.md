# [JSOI2012] 分零食

## 题目描述

这里是欢乐的进香河，这里是欢乐的幼儿园。

今天是 2 月 14 日，星期二。在这个特殊的日子里，老师带着同学们欢乐地跳着，笑着。校长从幼儿园旁边的小吃店买了大量的零食决定分给同学们。听到这个消息，所有同学都安安静静地排好了队，大家都知道，校长不喜欢调皮的孩子。

同学们依次排成了一列，其中有 $A$ 位小朋友，有三个共同的欢乐系数 $O$，$S$ 和 $U$。如果有一位小朋友得到了 $x$ 个糖果，那么她的欢乐程度就是 $f(x)=Ox^2+Sx+U$。

现在校长开始分糖果了，一共有 $M$ 个糖果。有些小朋友可能得不到糖果，对于那些得不到糖果的小朋友来说，欢乐程度就是 $1$。如果一位小朋友得不到糖果，那么在她身后的小朋友们也都得不到糖果（即这一列得不到糖果的小朋友一定是最后的连续若干位）。

所有分糖果的方案都是等概率的。现在问题是：期望情况下，所有小朋友的欢乐程度的乘积是多少？呆呆同学很快就有了一个思路，只要知道总的方案个数 $T$ 和所有方案下欢乐程度乘积的总和 $S$，就可以得到答案 $ans=\frac{S}{T}$。现在他已经求出来了 $T$ 的答案，但是 $S$ 怎么求呢？他就不知道了。你能告诉他么？

因为答案很大，你只需要告诉他 $S$ 对 $P$ 取模后的结果。

后记：

虽然大家都知道，即便知道了 $T$，知道了 $S$ 对 $P$ 取模后的结果，也没有办法知道期望情况下，所有小朋友欢乐程度的乘积。但是，当呆呆想到这一点的时候，已经彻底绝望了。

## 说明/提示

**样例解释：**

函数 $f(x)=x^2$。一共有 $4$ 份零食，$4$ 位同学。如果只有第一个同学得到，欢乐程度为 $16$，若前两位同学得到，欢乐程度的所有可能依次为 $9, 9, 16$，若有三位同学得到，欢乐程度有 $4, 4, 4$，最后一种情况，每一个同学都得到了零食，欢乐程度为 $1$。相加后得到 $S=63$。

**数据范围：**

对于 $40 \%$ 的数据，$M \leq 150$。  
对于 $60 \%$ 的数据，$M \leq 2000$。  
对于 $80 \%$ 的数据，$M \leq 6000$。  
对于 $100 \%$ 的数据，$M \leq 10000, P \leq 255, A \leq 10^8, O \leq 4, S \leq 300, U \leq 100$。

## 样例 #1

### 输入

```
4 100
4
1
0
0
```

### 输出

```
63
```

# 题解

## 作者：NaCly_Fish (赞：15)

怎么这题比较正常的题解都在下面，，   
其实就是一道基础生成函数题。
****
首先，设 $f_n$ 为一个人分 $n$ 块糖时的快乐值，这个很容易求出；再设 $F(x)$ 为它的生成函数。

考虑其组合意义，不难发现 $(F(x)-1)^k$ 就是有 $k$ 个人都有糖时，「所有情况的快乐值乘积之和」的生成函数。

那么枚举有糖的人数，答案就直接出来了：
$$\sum_{k=0}^A (F(x)-1)^k$$
$$= \frac{1-(F(x)-1)^{A+1}}{2-F(x)}$$
由此也可以得到一个常数优化：当 $A \geq m$ 时，那个多项式的幂在模 $x^{m+1}$ 下为 $0$，可以直接忽略掉。这时的时间复杂度是 $\Theta(m \log m)$。

否则就只能倍增算那个多项式的幂（因为模数为合数，如果有更优的做法请告诉我）。

另外就是多项式的长度，由于 $F(x)-1$ 的常数项为 $0$，快速幂后前 $A$ 次都是 $0$，非 $0$ 项只有 $m-A$ 个，于是快速幂可以在模 $x^{m-A}$ 下计算——时间复杂度可以做到 $\Theta((m-A) \log A \log (m-A)) \space(A < m)$。

加上这些优化，成功跑到最优解第一：  
```cpp
#pragma GCC optimize ("unroll-loops")
#pragma GCC optimize ("Ofast")
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 32774
#define ll long long
#define reg register
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
using namespace std;

int p;

int rev[N],rt[N];
int siz;

#define md 998244353

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%md;
        a = (ll)a*a%md;
        t >>= 1; 
    }
    return res;
}

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    rt[lim>>1] = 1;
    w = power(3,(md-1)>>siz);
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%md;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void dft(int *f,int lim){
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%md;
        a[j|k|mid] = a[j|k]+md-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%md;
}

inline void idft(int *f,int lim){
    reverse(f+1,f+lim);
    dft(f,lim);
    int x = md-((md-1)>>__builtin_ctz(lim));
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%md;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

void multiply(const int *A,const int *B,int n,int m,int *R,int len){
    static int f[N],g[N];
    memcpy(f,A,(n+1)<<2),memcpy(g,B,(m+1)<<2);
    int lim = getlen(n+m);
    memset(f+n+1,0,(lim-n)<<2);
    memset(g+m+1,0,(lim-m)<<2);
    dft(f,lim),dft(g,lim);
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%md;
    idft(f,lim);
    for(reg int i=0;i<=len;++i) R[i] = f[i]%p;
}

inline void inverse(const int *f,int n,int *R){
    static int g[N],h[N];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    int s[30];
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        multiply(h,g,n,n,h,n);
        multiply(h,g,n,n,h,n);
        for(reg int i=0;i<=n;++i) g[i] = dec(add(g[i],g[i]),h[i]);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void power(int *f,int n,int k,int *R){
    int g[N];
    g[0] = 1;
    while(1){
        if(k&1) multiply(g,f,n,n,g,n);
        k >>= 1;
        if(k==0) break;
        multiply(f,f,n,n,f,n);
    }
    memcpy(R,g,(n+1)<<2);
}

int m,A,o,s,u;
int f[N],g[N],h[N];

int main(){
    scanf("%d%d%d%d%d%d",&m,&p,&A,&o,&s,&u);
    init(m<<1);
    for(reg int i=1;i<=m;++i) f[i] = (u+i*(s+o*i))%p;
    if(A<m) memcpy(g,f+1,(m-A)<<2);
    f[0] = 1;
    for(reg int i=1;i<=m;++i) f[i] = f[i]==0?0:p-f[i];
    inverse(f,m,f);
    if(A>=m){
        printf("%d",f[m]);
        return 0;
    }
    power(g,m-A-1,A+1,h);
    for(reg int i=m;i>A;--i) h[i] = h[i-A-1];
    for(reg int i=A+1;i<=m;++i) h[i] = h[i]==0?0:p-h[i];
    int ans = f[m];
    for(reg int i=A+1;i<=m;++i)
        if(h[i]!=0) ans = (ans+h[i]*f[m-i])%p;
    printf("%d",ans);    
    return 0;   
}
```

---

## 作者：Akura (赞：15)

$Latex$一直调不好，建议在博客中查看：

[luogu博客](https://www.luogu.com.cn/blog/lzslzslzs/p5075-jsoi2012-fen-ling-si-ti-xie)或者
[cnblogs](https://www.cnblogs.com/akura/p/12259557.html)

我这有个$m^2$的做法

有个比较naive的$dp$：设$f_{i,j}$表示前$i$个人一共拿到了$j$个糖的所有方案的欢乐值之和，那么有转移方程：
$$
f_{i,j}=\sum_{k=1}^{j-i+1}f_{i-1,j-k}\times(Ok^2+Sk+U)
$$

初始值可以设$f_{0,0}=1$。这个$dp$的复杂度就是$O(Am^2)$。一个优化就是，由于最多前$m$个人拿到糖(每个人至少拿一个糖)，所以$i$只用枚举到$min(m,A)$，复杂度为$O(m^3)$。

观察转移方程的结构，可以发现这样一个优化：

$$
f_{i,j-1}=\sum_{k=1}^{j-i}f_{i-1,j-1-k}\times(Ok^2+Sk+U)
=\sum_{k=2}^{j-i+1}f_{i-1,j-k}\times[O(k-1)^2+S(k-1)+U]
$$
$$
=\sum_{k=2}^{j-i+1}f_{i-1,j-k}\times(Ok^2+Sk+U)-
 \sum_{k=2}^{j-i+1}f_{i-1,j-k}\times(2Ok-O+S)
$$
$$
=f_{i,j}-f_{i-1,j-1}\times(O+S+U)-
  \sum_{k=2}^{j-i+1}f_{i-1,j-k}\times(2Ok-O+S)
$$

观察最后这个$\sum$，设

$$
g_{i,j}=\sum_{k=1}^{j-i+1}f_{i-1,j-k}\times(2Ok-O+S)
$$

那么求$f$的式子可以写成：

$$
f_{i,j-1}=
f_{i,j}-f_{i-1,j-1}\times(O+S+U)-g_{i,j}+f_{i-1,j-1}\times(O+S)
=f_{i,j}-Uf_{i-1,j-1}-g_{i,j}
$$

那么$f_{i,j}=f_{i,j-1}+Uf_{i-1,j-1}+g_{i,j}$。

$f$的转移变成$O(1)$的了。但$g$还是$O(n)$的。观察$g$的结构，可以类似地写出求$g$的优化：

$$
g_{i,j-1}=\sum_{k=1}^{j-i}f_{i-1,j-1-k}\times(2Ok-O+S)
=\sum_{k=2}^{j-i+1}f_{i-1,j-k}\times[2O(k-1)-O+S]
$$

$$
=\sum_{k=2}^{j-i+1}f_{i-1,j-k}\times(2Ok-O+S)-
 \sum_{k=2}^{j-i+1}f_{i-1,j-k}\times 2O
=g_{i,j}-f_{i-1,j-1}\times(O+S)-
 \sum_{k=2}^{j-i+1}f_{i-1,j-k}\times 2O
$$

观察最后这个$\sum$，设

$$
h_{i,j}=\sum_{k=1}^{j-i+1}f_{i-1,j-k}\times 2O
$$

那么求$g$的式子可以写成：

$$
g_{i,j-1}=
g_{i,j}-f_{i-1,j-1}\times(O+S)-h_{i,j}+f_{i-1,j-1}\times 2O
=g_{i,j}-f_{i-1,j-1}\times(S-O)-h_{i,j}
$$

那么$g_{i,j}=g_{i,j-1}+f_{i-1,j-1}\times(S-O)+h_{i,j}$。

每个$g$也可以$O(1)$求了，而且注意到$h$就是前缀和，每个$h$也可以$O(1)$求，所以整个$dp$被优化到了$O(m^2)$。

可以通过吗？时间上，复杂度虽然是$O(m^2)$的，但实际上由于$i\leq j$，所以只需要循环$\frac{m\times(m+1)}{2}$次，也就是$5\times 10^7$级别，是可以过的。空间上，加上滚动数组优化也能过。

```c++
#include<bits/stdc++.h>
#define rg register
#define il inline
#define cn const
#define gc getchar()
#define fp(i,a,b) for(rg int i=(a),ed=(b);i<=ed;++i)
using namespace std;
typedef cn int cint;
il int rd(){
   rg int x(0),f(1); rg char c(gc);
   while(c<'0'||'9'<c){ if(c=='-') f=-1; c=gc; }
   while('0'<=c&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=gc;
   return x*f;
}
cint maxn=10010;

int A,m,mod,O,S,U,ff,gg,hh,ans;
int f[2][maxn],g[2][maxn],h[2][maxn],pv=0,nw=1;

int main(){
	m=rd(),mod=rd(),A=rd(),O=rd(),S=rd(),U=rd();
	ff=U,gg=(S-O+mod)%mod,hh=(O<<1)%mod;
	
	f[0][0]=1;
	fp(i,1,min(m,A)){
		h[nw][i-1]=g[nw][i-1]=f[nw][i-1]=0;
		fp(j,i,m){
			h[nw][j]=(h[nw][j-1]+hh*f[pv][j-1])%mod;
			g[nw][j]=(g[nw][j-1]+gg*f[pv][j-1]+h[nw][j])%mod;
			f[nw][j]=(f[nw][j-1]+ff*f[pv][j-1]+g[nw][j])%mod;
		}
		ans=(ans+f[nw][m])%mod;
		nw^=pv^=nw^=pv;
	}
	printf("%d",ans);
	return 0;\\}
```

---

## 作者：tzc_wk (赞：4)

[我的博客园](https://www.cnblogs.com/ET2006/)

首先很容易观察到，$A\leq 10^8$ 的数据范围其实是假的，$A>M$ 和 $A=M$ 的答案其实是一样的，因为最多只有 $M$ 个人才能拿到糖，其它 $A-M$ 个人都是来打酱油，撑场子的。

考虑暴力 $dp$，$dp_{i,j}=$ 前 $i$ 个人中共拿了 $j$ 个糖的欢乐程度的乘积之和，那么 $dp_{i,j}=\sum\limits_{k=1}^jdp_{i-1,j-k}\times f(k)$，其中 $f(i)=Oi^2+Si+U$，最终答案即为 $\sum\limits_{i=1}^Adp_{i,M}$。时间复杂度 $m^3$，期望得分 40。

发现上述式子可以写成卷积的形式，故可以使用 FFT 优化，时间复杂度 $m^2\log m$，期望得分 60。

注意到我们复杂度的瓶颈在于，我们每做一次卷积都要将答案加入贡献。如果最终答案仅仅只是 $dp_{A,M}$ 那显然多项式快速幂就行了。

故我们考虑记 $g_{i,j}=\sum\limits_{k=1}^idp_{k,j}$，最终答案即为 $g_{A,M}$。

考虑怎么算 $g_i$：

- 如果 $i$ 为奇数，那么 $g_{i}=g_{i-1}+dp_{i}$。
- 如果 $i$ 为偶数，那么 $g_i=g_{i/2}+dp_{i/2}\times g_{i/2}$

多项式快速幂即可。

至于这个模数 $P$ 如何处理，其实不用任意模数 NTT，注意到这个 $P$ 很小，所以暴力 FFT 也不会爆精度。

时间复杂度 $m\log^2m$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXP=1<<16;
const double Pi=acos(-1);
int n,mod,m,a,b,c;
struct comp{
	double x,y;//(real,imag)
	comp(){x=y=0;}
	comp(double _x,double _y){x=_x;y=_y;}
	friend comp operator +(comp lhs,comp rhs){return comp(lhs.x+rhs.x,lhs.y+rhs.y);}
	friend comp operator -(comp lhs,comp rhs){return comp(lhs.x-rhs.x,lhs.y-rhs.y);}
	friend comp operator *(comp lhs,comp rhs){return comp(lhs.x*rhs.x-lhs.y*rhs.y,lhs.x*rhs.y+lhs.y*rhs.x);}
} x[MAXP+5],y[MAXP+5],z[MAXP+5];
int rev[MAXP+5],LEN=1,LOG=0,t[MAXP+5];
void FFT(comp *a,int len,int type){
	int lg=log2(len);
	for(int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(lg-1));
	for(int i=0;i<len;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		comp W=comp(cos(2*Pi/i),type*sin(2*Pi/i));
		for(int j=0;j<len;j+=i){
			comp w=comp(1,0);
			for(int k=0;k<(i>>1);k++,w=w*W){
				comp X=a[j+k],Y=a[(i>>1)+j+k]*w;
				a[j+k]=X+Y;a[(i>>1)+j+k]=X-Y;
			}
		}
	}
	if(type==-1) for(int i=0;i<len;i++) a[i].x=(int)(a[i].x/len+0.5)%mod;
}
void mul(int *a,int *b,int *c){
	for(int i=0;i<LEN;i++) x[i]=comp(a[i],0);
	for(int i=0;i<LEN;i++) y[i]=comp(b[i],0);
	FFT(x,LEN,1);FFT(y,LEN,1);
	for(int i=0;i<LEN;i++) z[i]=x[i]*y[i];
	FFT(z,LEN,-1);
	for(int i=1;i<=n;i++) c[i]=z[i].x;
}
int dp[MAXP+5],sum[MAXP+5],tmp[MAXP+5];
void solve(int x){
	if(x==1){
		for(int i=1;i<=n;i++) dp[i]=sum[i]=t[i];
		return;
	} solve(x>>1);
	mul(dp,sum,tmp);
	for(int i=0;i<LEN;i++) sum[i]=(sum[i]+tmp[i])%mod;
	mul(dp,dp,dp);
	if(x&1){
		mul(dp,t,dp);
		for(int i=0;i<LEN;i++) sum[i]=(sum[i]+dp[i])%mod;
	}
}
int main(){
	scanf("%d%d%d%d%d%d",&n,&mod,&m,&a,&b,&c);
	m=min(m,n);while(LEN<=n+n) LEN<<=1,LOG++;
	for(int i=1;i<=n;i++) t[i]=(a*i*i+b*i+c)%mod;
	solve(m);printf("%d\n",sum[n]);
	return 0;
}
```

---

## 作者：Peter_Z (赞：4)

博客内食用更佳qwq：[蒟蒻的博客](https://blog.csdn.net/The_OIer/article/details/100142498)

题目链接：[传送门](https://www.luogu.org/problem/P5075)

### 前置技能：

dp（雾）

快速幂（雾）

FFT

### 暴力dp

因为没有分到糖的小盆友只能是最后的一段，因此让$dp[i][j]$表示把$j$颗糖分给前$i$个小盆友的欢乐程度乘积的和。

转移方程：$dp[i][j]=\large\Sigma\normalsize dp[i-1][j-k]*f[k]$，其中$f[i]$表示分到$i$颗糖所得到的欢乐程度。

统计答案只需要把所有分出去$m$颗糖的情况加在一起，即$ans=\Large\Sigma\normalsize_{i=1}^{A}dp[i][m]$

时间复杂度$O(Am^2)$

~~然后，愉快地获得10分：~~

```cpp
#include<stdio.h>
#include<cstring>
#include<algorithm>
#include<math.h>
#define re register int
#define pi 3.1415926535897932384626433832795
using namespace std;
int read() {
	re x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') {
		if(ch=='-')	f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9') {
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
const int Size=5005;
int m,p,A,O,S,U;
inline int getf(int x) {
	return (O*x*x+S*x+U)%p;
}
int f[Size];
int dp[Size][Size];
int main() {
	m=read();
	p=read();
	A=read();
	O=read();
	S=read();
	U=read();
	for(re i=1; i<=m; i++) {
		f[i]=getf(i);
	}
	dp[0][0]=1;
	for(re i=1; i<=A; i++) {
		for(re j=1; j<=m; j++) {
			for(re k=1; k<=j-i+1; k++) {
				dp[i][j]+=dp[i-1][j-k]*f[k];
				dp[i][j]%=p;
			}
		}
	}
	int ans=0;
	for(re i=1; i<=A; i++) {
		ans=(ans+dp[i][m])%p;
	}
	printf("%d",ans);
	return 0;
}
```

### 优化

巨神yxc把这段代码优化了一下qwq

这里有一个奇妙的性质：因为$m$颗糖最多分给$m$个人，所以让$A=min(A,m)$就珂以了qwq

再加上滚动数组的优化，成功拿到40分

时间复杂度$O(m^3)$

```cpp
#include<stdio.h>
#include<cstring>
#include<algorithm>
#include<math.h>
#define re register int
#define pi 3.1415926535897932384626433832795
using namespace std;
int read() {
	re x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') {
		if(ch=='-')	f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9') {
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
const int Size=10005;
int m,p,A,O,S,U;
inline int getf(int x) {
	return (O*x*x+S*x+U)%p;
}
int f[Size];
int dp[2][Size];
int main() {
	m=read();
	p=read();
	A=read();
	O=read();
	S=read();
	U=read();
	for(re i=1; i<=m; i++) {
		f[i]=getf(i);
	}
	dp[0][0]=1;
	A=min(A,m);
	int ans=0;
	for(re i=1; i<=A; i++) {
		int now=(i&1),pre=!(i&1);
		memset(dp[now],0,sizeof(dp[now]));
		for(re j=1; j<=m; j++) {
			for(re k=1; k<=j-i+1; k++) {
				dp[now][j]+=dp[pre][j-k]*f[k];
				dp[now][j]%=p;
			}
		}
		ans=(ans+dp[now][m])%p;
	}
	printf("%d",ans);
	return 0;
}
```

### FFT优化

观察这个dp方程：

$dp[i][j]=\large\Sigma\normalsize dp[i-1][j-k]*f[k]$

$j-k$和$k$貌似是一个裸的卷积形式，珂以用FFT来优化qwq

把方程写成$dp[i]=dp[i-1]*f$，然后就是一个裸的FFT qwq

时间复杂度……大概$O(m^2logm)$？~~反正过不去就是了qwq，也没写~~

### 分治优化

说是分治……其实就是一个快速幂……

由于卷积满足结合律，所以不难得出$dp[i]=dp[0]*f^i=f^i$

（$dp[0]$：$dp[0][0]=1$，其余为0，所以$dp[0]*f=f$）

这里令$g[i]=\Large\Sigma\normalsize dp[i]$，则$ans=g[m]$。

**当$n$是偶数时，**

$g[n]=\Large\Sigma\large_{i=1}^{\frac{n}{2}}dp[i]+\Large\Sigma\large_{i=\frac{n}{2}+1}^{n}dp[i]$

$=\large g[\frac{n}{2}]+\Large\Sigma\large_{i=1}^{\frac{n}{2}}dp[\frac{n}{2}+i]$
$=\large g[\frac{n}{2}]+\Large\Sigma\large_{i=1}dp[i]*dp[\frac{n}{2}]$

这里把$dp[i]*dp[\frac{n}{2}]$用卷积展开，变成

$g[\frac{n}{2}]+\Large\Sigma\large_{i=1}^\frac{n}{2}\Large\Sigma\large_{j=1}^{m-1}dp[i][j]*dp[\frac{n}{2}][m-j]$

$=g[\frac{n}{2}]+\Large\Sigma\large_{j=1}^{m-1}dp[\frac{n}{2}][m-j]*\Large\Sigma\large_{i=1}^\frac{n}{2}dp[i][j]$

$=g[\frac{n}{2}]+\Large\Sigma\large_{j=1}^{m-1}dp[\frac{n}{2}][m-j]*g[\frac{n}{2}]$

$=g[\frac{n}{2}]+dp[\frac{n}{2}]*g[\frac{n}{2}]$

**当$n$是奇数时**，算出的是$g[n-1]$的答案，所以再乘上一个$f$就珂以了qwq。

即$g[n]=g[n-1]+dp[n]$，$dp[n]=dp[n-1]*f$。

~~所以……这不就是个快速幂吗~~

时间复杂度目测$O(mlog^2m)$qwq

### 代码

```cpp
#include<stdio.h>
#include<cstring>
#include<algorithm>
#include<math.h>
#define re register int
#define rl register ll
#define pi 3.14159265358979323846264338328
using namespace std;
typedef long long ll;
int read() {
	re x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') {
		if(ch=='-')    f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9') {
		x=10*x+ch-'0';
		ch=getchar();
	}
	return x*f;
}
const int Size=40005;
namespace Fast_Fast_TLE {

	struct cpx {    //complex
		double x,y;
	};
	inline cpx operator + (const cpx a,const cpx b) {
		return (cpx) {
			a.x+b.x,a.y+b.y
		};
	}
	inline cpx operator - (const cpx a,const cpx b) {
		return (cpx) {
			a.x-b.x,a.y-b.y
		};
	}
	inline cpx operator * (const cpx a,const cpx b) {
		return (cpx) {
			a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y
		};
	}
//万恶的变量重名
	cpx ca[Size],cb[Size];
	int R[Size];
	void FFT(cpx *ans,int n,int type) {
		for(re i=0; i<n; i++)	if(i<R[i])	swap(ans[i],ans[R[i]]);
		for(re i=1; i<n; i<<=1) {
			const cpx wn=(cpx) {
				cos(pi/i),type*sin(pi/i)
			};
			for(re j=0; j<n; j+=i<<1) {
				cpx w=(cpx) {
					1,0
				};
				for(re k=0; k<i; k++) {
					cpx x=ans[j+k],y=w*ans[i+j+k];
					ans[j+k]=x+y;
					ans[i+j+k]=x-y;
					w=w*wn;
				}
			}
		}
	}

}
using namespace Fast_Fast_TLE;
int len,m,p,A,O,S,U;
int f[Size],g[Size],dp[Size];
inline int getf(int x) {
	return (O*x*x+S*x+U)%p;
}
inline void mul(int *a,int *b,int *c) {
	for(re i=0; i<len; i++) {
		ca[i]=(cpx) {
			a[i],0
		};
		cb[i]=(cpx) {
			b[i],0
		};
	}
	FFT(ca,len,1);
	FFT(cb,len,1);
	for(re i=0; i<len; i++) {
		ca[i]=ca[i]*cb[i];
	}
	FFT(ca,len,-1);
	for(re i=1; i<=m; i++) {
		c[i]=((int)((double)ca[i].x/len+0.5))%p;
	}
}
int pre[Size],tmp[Size];
void fpow(int k) {
	if(k==1) {
		memcpy(f,pre,sizeof(pre));
		memcpy(g,pre,sizeof(pre));
		return;
	}
//	if(k==3) {
//		puts("I love Nephren forever");
//	}
	fpow(k>>1);
//	if(k==2) {
//		puts("我永远喜欢珂朵莉");
//	}
	mul(f,g,tmp);
	for(re i=0; i<=len; i++)   	f[i]=(f[i]+tmp[i])%p;
	mul(g,g,g);
	if(k&1) {
		mul(g,pre,g);
		for(re i=0; i<=len; i++) {
			f[i]=(f[i]+g[i])%p;
		}
	}
}
int main() {
	m=read();
	p=read();
	A=read();
	O=read();
	S=read();
	U=read();
	for(re i=1; i<=m; i++) {
		pre[i]=getf(i);
	}
	len=1;
	int L=0,maxn=m<<1;
	while(len<=maxn) {
		len<<=1;
		L++;
	}
	for(re i=0; i<=len; i++) {
		R[i]=((R[i>>1]>>1)|((i&1)<<(L-1)));
	}
	fpow(min(A,m));
	printf("%d\n",f[m]);
	return 0;
}
```

---

## 作者：Memory_of_winter (赞：2)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10277145.html)

**题目大意：**有$m(m\leqslant10^8)$个人站成一排，有$n(n\leqslant10^4)$个糖果，若第$i$个人没有糖果，那么第$i+1$个人也没有糖果。一个人有$x$个糖果会获得快乐值$v(x)$。

$$v(x)=\begin{cases}ax^2+bx+c&(x>1)\\1&(x=1)\end{cases}$$
一个方案的价值为$\prod\limits_{i=1}^mv(s_i)$（$s_i$为第$i$个人得到的糖果数）。问所有方案的价值和，对$mod(mod\leqslant255)$取模

**题解：**令$f(x)=\sum\limits_{i=1}^{\infty}v(i)x^i$，那么$k$个人全部得到糖果的方案数是$[x^n]f^k(x)$。

$$\begin{aligned}ans&=[x^n]\sum\limits_{i=1}^mf^i(x)\\	&=[x^n]\sum\limits_{i=0}^mf^i(x)\\	&=[x^n]\dfrac{1-f^{m+1}(x)}{1-f(x)}\end{aligned}$$
注意这里的模数不是质数，但很小，可以用一模$NTT$，注意求逆部分，需要多把点值转成系数，因为负数无法表示。



**C++ Code：**

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 32768
const int mod = 998244353;
namespace Math {
	inline int pw(int base, int p) {
		static int res;
		for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
		return res;
	}
	inline int inv(int x) { return pw(x, mod - 2); }
}
inline void reduce(int &x) { x += x >> 31 & mod; }
inline void clear(register int *l, const int *r){
	if(l >= r) return ;
	while (l != r) *l++ = 0;
}

int n, m, a, b, c, pmod;
namespace Poly {
#define N maxn
	int lim, s, rev[N];
	int Wn[N + 1];
	inline void init(const int n) {
		lim = 1, s = -1; while (lim < n) lim <<= 1, ++s;
		for (register int i = 1; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const int t = Math::pw(3, (mod - 1) / lim);
		*Wn = 1; for (register int *i = Wn; i != Wn + lim; ++i) *(i + 1) = static_cast<long long> (*i) * t % mod;
	}
	inline void NTT(int *A, const int op = 1) {
		for (register int i = 1; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			for (register int i = 0; i < lim; i += mid << 1)
				for (register int j = 0; j < mid; ++j) {
					const int X = A[i + j], Y = static_cast<long long> (A[i + j + mid]) * Wn[j * t] % mod;
					reduce(A[i + j] += Y - mod), reduce(A[i + j + mid] = X - Y);
				}
		}
		if (!op) {
			const int ilim = Math::inv(lim);
			for (register int *i = A; i != A + lim; ++i) *i = static_cast<long long> (*i) * ilim % mod;
			std::reverse(A + 1, A + lim);
		}
	}

	inline void INV(int *A, int *B, int n) {
		if (n == 1) { *B = 1; return ; }
		static int C[N];
		const int len = n + 1 >> 1;
		INV(A, B, len);
		init(n + n - 1);
		std::copy(A, A + n, C), clear(C + n, C + lim);
		NTT(C), NTT(B);
		for (register int i = 0; i < lim; ++i) C[i] = static_cast<long long> (C[i]) * B[i] % mod;
		NTT(C, 0), clear(C + n, C + lim);
		for (int *i = C; i != C + n; ++i) *i = pmod - *i % pmod;
		C[0] += 2, NTT(C);
		for (int i = 0; i < lim; ++i) B[i] = static_cast<long long> (B[i]) * C[i] % mod;
		NTT(B, 0);
		for (int *i = B; i != B + n; ++i) *i %= pmod;
		clear(B + n, B + lim);
	}
	inline void PW(int *A, int *B, int n, int p) {
		static int C[N], D[N];
		std::copy(A, A + n, C);
		init(n + n - 1);
		B[0] = 1, clear(B + 1, B + lim);
		while (p) {
			if (p & 1) {
				std::copy(C, C + n, D), clear(D + n, D + lim);
				NTT(B), NTT(D);
				for (int i = 0; i < lim; ++i) B[i] = static_cast<long long> (B[i]) * D[i] % mod;
				NTT(B, 0), clear(B + n, B + lim);
				for (int *i = B; i != B + n; ++i) *i %= pmod;
			}
			if (p >>= 1) {
				NTT(C);
				for (int *i = C; i != C + lim; ++i) *i = static_cast<long long> (*i) * *i % mod;
				NTT(C, 0), clear(C + n, C + lim);
				for (int *i = C; i != C + n; ++i) *i %= pmod;
			}
		}
	}
#undef N
}

int f[maxn], A[maxn], B[maxn];
int main() {
	scanf("%d%d", &n, &pmod); ++n;
	scanf("%d%d%d%d", &m, &a, &b, &c);
	m = std::min(m, n - 1);
	for (int i = 1; i < n; ++i) f[i] = (i * i % pmod * a + i * b + c) % pmod;

	Poly::PW(f, A, n, m + 1);
	for (int *i = A; i != A + n; ++i) *i = pmod - *i; ++*A;
	for (int *i = f; i != f + n; ++i) *i = pmod - *i; ++*f;
	Poly::INV(f, B, n);

	Poly::init(n + n - 1);
	Poly::NTT(A), Poly::NTT(B);
	for (int i = Poly::lim; ~i; --i) A[i] = static_cast<long long> (A[i]) * B[i] % mod;
	Poly::NTT(A, 0);

	printf("%d\n", A[n - 1] % pmod);
	return 0;
}

```





---

## 作者：Union_Find (赞：1)

首先我们可以容易得到一个简单的 dp，设 $f_{i,j}$ 表示前 $i$ 个小朋友分 $j$ 个糖果的答案。那么我们可以有如下转移。

$$f_{i,j} = \sum_{k=1}^{j-1} f_{i-1,j-k}F(k)$$

这个式子表示 $i$ 这个小朋友分到 $k$ 个糖果。注意，没有糖果的小朋友一定是一段后缀。

现在的答案就是 $\sum_{i=1}^N f_{i,M}$，但是转移是 $O(M^2)$ 的，有 $N$ 次，所以是 $O(NM^2)$ 的。

注意力惊人，发现实际上对于 $i > M$ 的部分来说，这些小朋友无论如何都分不到糖果，所以可以优化成 $O(M^3)$ 的。

注意力再次惊人，发现上面的转移形式是**卷积**的形式，直接用 FFT 优化即可做到 $O(M^2\log M)$。

此时的程序已经很优了，但是还是不太行，我们尝试再次优化。现在的问题是如果答案只和 $f_{N,i}$ 有关的话我们就可以直接**多项式快速幂**解决了，但是实际上我们需要每一个的 $f_{i,M}$，所以没有办法快速幂优化。

基于这点，我们设 $g_{i,j} = \sum_{k=1}^i f_{k,j}$，那么我们求的就是 $f_{N,M}$，所以我们现在只要得到 $g$ 的转移方程，就可以直接快速幂优化了。

首先，我们知道 $g_i = g_{i-1} + f_i$，这个是定义。接下来，我们尝试分治快速幂的思想来优化，即知道了 $f_{\frac n 2}$ 和 $g_{\frac n 2}$，求 $f_n$ 和 $g_n$。

$$g_n = \sum_{i=1}^{\frac n 2} f_i + \sum_{i=\frac n 2 + 1}^n f_i$$
$$= g_{\frac n 2} + \sum_{i=\frac n 2 + 1}^n f_i$$
$$= g_{\frac n 2} + \sum_{i=1}^{\frac n 2} f_{\frac n 2 + i}$$
$$= g_{\frac n 2} + \sum_{i=1}^{\frac n 2} f_{\frac n 2} \ast f_i$$

接下来把卷积的形式展开。

$$g_{\frac n 2} + \sum_{i=1}^{\frac n 2} f_{\frac n 2} \ast f_i$$
$$= g_{\frac n 2} + \sum_{i=1}^{\frac n 2} \sum_{j=1}^{m-1} f_{\frac n 2,m-j} \times f_{i,j}$$
$$= g_{\frac n 2} + \sum_{j=1}^{m-1} f_{\frac n 2,m-j} \times \sum_{i=1}^{\frac n 2} f_{i,j}$$
$$= g_{\frac n 2} + \sum_{j=1}^{m-1} f_{\frac n 2,m-j} \times g_{\frac n 2,j}$$
$$= g_{\frac n 2} + f_{\frac n 2} \ast g_{\frac n 2}$$

于是我们就有了一个优美的卷积的形式。但是别忘了这个是对于 $n$ 为偶数的情况，而对于 $n$ 是奇数的情况，要特殊处理，$f$ 要卷以下 $F$，$g$ 要加上 $f$。

于是我们现在就有了一个优美的 $O(M\log^2M)$ 的算法。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define ld double
il int rd(){
	int s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
const ld Pi = acos(-1.0);
const int N = (1 << 19) + 5, P = 998244353, G = 3, invG = 332748118, inv2 = 499122177;
int rev[N];
int n, m, p, ans, A, B, C, f[N], g[N], h[N], F[N], L;
struct Complex{
	ld x, y;
	Complex(ld X = 0, ld Y = 0){x = X, y = Y;}
}fa[N], fb[N];
Complex operator + (Complex a, Complex b){return Complex(a.x + b.x, a.y + b.y);}
Complex operator - (Complex a, Complex b){return Complex(a.x - b.x, a.y - b.y);}
Complex operator * (Complex a, Complex b){return Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}
il void cpy(Complex *a, Complex *b, int n){for (int i = 0; i < n; i++) a[i] = b[i];}
il void clr(Complex *a, int n){for (int i = 0; i < n; i++) a[i] = Complex(0, 0);}
il void px(Complex *a, Complex *b, int n){for (int i = 0; i < n; i++) a[i] = a[i] * b[i];}
il void FFT (Complex *a, int n, int typ){
	for (int i = 0; i < n; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (n >> 1) : 0);
	for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
	for (int len = 1; len < n; len <<= 1){
		Complex wn(cos(Pi / len), typ * sin(Pi / len));
		for (int i = 0; i < n; i += (len << 1)){
			Complex w(1, 0);
			for (int j = 0; j < len; j++){
				Complex x = a[i + j], y = w * a[i + j + len];
				a[i + j] = x + y, a[i + j + len] = x - y, w = w * wn;
			}
		}
	}
	if (typ == -1){
		for (int i = 0; i < n; i++) a[i].x /= n, a[i].y /= n;
	}
}
il void times(int *a, int *b, int *c){
	for (int i = 0; i <= n; i++) fa[i].x = a[i];
	for (int i = 0; i <= n; i++) fb[i].x = b[i];
	FFT(fa, L, 1), FFT(fb, L, 1), px(fa, fb, L), FFT(fa, L, -1);
	for (int i = 0; i <= n; i++) c[i] = (int)(fa[i].x + 0.5) % p;
	clr(fa, L), clr(fb, L);
}
void solve(int n){
	if (n == 1){
		memcpy(f, F, sizeof f);
		memcpy(g, F, sizeof g);
		return ;
	}
	solve(n >> 1);
	times(g, f, h);
	for (int i = 0; i < L; i++) g[i] = (g[i] + h[i]) % p;
	times(f, f, f);
	if (n & 1){
		times(f, F, f);
		for (int i = 0; i < L; i++) g[i] = (g[i] + f[i]) % p;
	}
}
signed main(){
	n = rd(), p = rd(), m = rd(), m = min(n, m), A = rd(), B = rd(), C = rd();
	for (L = 1; L <= n + n; L <<= 1);
	for (int i = 1; i <= n; i++) F[i] = (A * i * i + B * i + C) % p;
	solve(m);
	printf ("%d\n", g[n]);
	return 0;
}

```

---

## 作者：lzyqwq (赞：1)

> - 将 $m$ 个糖果分给 $A$ 个人，若第 $i$ 个人分到 $x$ 个糖果 则会产生 $f(x)=Ox^2+Sx+U$ 的快乐值。
> - 称一个分糖果方案的权值为所有人快乐值的积。称一个分糖果方案是合法的当且仅当有糖果的人的编号形如一段前缀。
> - 求所有合法方案的权值和，对 $P$ 取模。
> - $m\le 10^4$，$A\le 10^8$，$P\le 255$。

不会生成函数。来点组合意义做法。

设 $F_{i,j}$ 表示前 $i$ 个人分 $j$ 个糖果的欢乐度乘积的和。设 $i=x+y$，考虑将 $i$ 个人分成前 $x$ 个人和后 $y$ 个人，枚举给前 $x$ 个人分 $k$ 个糖果，得到：

$$F_{i,j}=\sum\limits_{k=1}^{j-1}F_{x,k}F_{y,j-k}$$

其中 $F_{1,j}=f(j)$。我们要求的是 $\sum\limits_{i=1}^{A}F_{i,m}$。考虑设 $g_{i,j}=\sum\limits_{k=1}^iF_{k,j}$，则答案为 $g_{A,m}$。可以发现 $g_{i,j}=g_{i-1,j}+F_{i,j}$。

注意到：

$$g_{2n,j}=g_{n,j}+\sum\limits_{k=n+1}^{2n}F_{k,j}=g_{n,j}+\sum\limits_{k=1}^nF_{k+n,j}$$

将 $F_{k+n,j}$ 用第一个式子展开：

$$\begin{aligned}\sum\limits_{k=1}^nF_{k+n,j}&=\sum\limits_{k=1}^n\sum\limits_{p=1}^{j-1}F_{k,p}F_{n,j-p}\end{aligned}$$

考虑设 $G(x)=\sum\limits_{i=1}^mF_{n,i}x^i,H(x)=\sum\limits_{i=1}^mg_{n,i}x^i$。考察 $[x^j](G(x)H(x))$：

$$\begin{aligned}\sum\limits_{p=1}^{j-1}F_{n,j-p}g_{n,p}&=\sum\limits_{p=1}^{j-1}F_{n,j-p}\sum\limits_{k=1}^nF_{k,p}\\&=\sum\limits_{k=1}^n\sum\limits_{p=1}^{j-1}F_{k,p}F_{n,j-p}\\&=\sum\limits_{k=1}^nF_{k+n,j}\end{aligned}$$

那么可以递归求解 $g_{n,j}$。考虑先求出 $g_{\lfloor\frac{n}{2}\rfloor,j}$ 和 $F_{\lfloor\frac{n}{2}\rfloor,j}$，将 $g_{\lfloor\frac{n}{2}\rfloor,j}$ 加上对应的 $[x^j](G(x)H(x))$ 即可求出 $g_{n-n\bmod 2}$。如果 $n$ 是奇数再将 $g_{n-n\bmod 2,j}$ 加上 $F_{n,j}$ 即可。

至于 $F_{n,j}$ 的计算，同样先求出 $F_{n-n\bmod 2,j}$。考虑拓展一下第一个式子，记 $A_{y}(x)=\sum\limits_{i=1}^nF_{y,i}x^i$，那么对于 $i=a+b$，有 $F_{i,j}=[x^j](A_a(x)A_b(x))$。那么可以通过 $A_{\lfloor\frac{n}{2}\rfloor}(x)$ 和自己卷积算出 $F_{n-n\bmod 2,j}$。若 $n$ 为奇数，再将其和 $A_1(x)$ 卷积算出 $F_{n,j}$。

时间复杂度 $\mathcal{O}(m\log m\log A)$，空间复杂度 $\mathcal{O}(m)$。

注意事项：

- 卷积完之后比 $x^m$ 高的项是没用的，需要删去。
- 虽然模数不是 NTT 模数，但是注意到在该数据范围下卷积的真实值不会超过 $998244353$，因此可以 NTT 算出真实值后再取模。


```cpp
#include <bits/stdc++.h>
template<class T> void read(T &x) {
    x = 0; T f = 1; char c = getchar();
    for (; c < 48 || c > 57; c = getchar()) if (c == 45) f = -1;
    for (; c > 47 && c < 58; c = getchar()) x = x * 10 + c - 48; x *= f;
}
template<class T> void write(T x) {
    if (x > 9) write(x / 10); putchar(x % 10 + 48);
}
template<class T> void print(T x, char ed = '\n') {
    if (x < 0) putchar('-'), x = -x; write(x), putchar(ed);
}
using namespace std;
namespace Poly {
	using ll = long long; using poly = vector<ll>;
	const ll M = 1004535809, G = 3; const int N = 1 << 15; int R[N];
	poly get(int n) { return poly(n + 1); } int dg(poly &a) { return a.size() - 1; }
	ll qp(ll x, ll y) {
		ll r = 1; for (; y; y >>= 1, x = x * x % M) if (y & 1) r = r * x % M;
		return r;
	}
	void init(int n) {
		for (int i = 0; i < n; ++i) {
			R[i] = R[i >> 1] >> 1; if (i & 1) R[i] |= n >> 1;
		}
	}
	void NTT(poly &a, int n, bool o = 0) {
		if (o) init(n);
		for (int i = 0; i < n; ++i) if (i < R[i]) swap(a[i], a[R[i]]);
		for (int i = 2; i <= n; i <<= 1) {
			ll g = qp(G, (M - 1) / i), w, u, v;
			for (int j = 0; j < n; j += i) {
				w = 1;
				for (int k = j; k < j + (i >> 1); ++k, w = w * g % M)
					u = a[k], v = w * a[k + (i >> 1)] % M,
					a[k] = (u + v) % M, a[k + (i >> 1)] = (u - v + M) % M;
			}
		}
	}
	poly operator*(poly a, poly b) {
		int n = a.size(), m = b.size(), L = 1; while (L < n + m - 1) L <<= 1;
		a.resize(L); b.resize(L); NTT(a, L, 1); NTT(b, L);
		for (int i = 0; i < L; ++i) a[i] = a[i] * b[i] % M; NTT(a, L);
		poly c = get(n + m - 2); ll inv = qp(L, M - 2); c[0] = a[0] * inv % M;
		for (int i = 1; i < n + m - 1; ++i) c[i] = a[L - i] * inv % M; return c;
	}
	poly mod(poly a, int n) { a.resize(n, 0); return a; }
    poly operator%(poly a, int b) {
        poly c = a; for (int i = 0; i <= dg(c); ++i) c[i] %= b; return c;
    }
}
using namespace Poly; ll m, p, a, o, s, u; poly f, k;
poly operator+(poly a, poly b) {
    int n = max(a.size(), b.size()); a.resize(n); b.resize(n);
    poly c = get(n - 1); for (int i = 0; i < n; ++i) c[i] = a[i] + b[i]; return c;
}
poly F(int n) {
    if (n == 1) return f; poly g = F(n >> 1);
    g = (g + mod(f * g, m + 1)) % p; f = mod(f * f, m + 1) % p;
    if (n & 1) f = mod(f * k, m + 1) % p, g = (g + f) % p; return g;
}
signed main() {
    read(m); read(p); read(a); read(o); read(s); read(u); f = k = get(m);
    for (int i = 1; i <= m; ++i)
        k[i] = f[i] = (o * i * i + s * i + u) % p;
    return print(F(a)[m]), 0;
}
```

---

## 作者：analysis (赞：1)

一个比较简单的问题，显然是 $SEQ_{\leq A}$。

具体来说，假设 $F=\sum_{i \geq 1}f(i)x^i$，枚举有分配糖果的小朋友个数 $i$，乘积之和即为 $[x^m]F^i(x)$，答案即为：$[x^m]\sum_{i=0}^{A}F^i(x)=\frac{F^{A+1}-1}{F-1}$。

直接快速幂+求逆可以做到 $O(m\log^2{m})$。

---

事实上，由于 $F(0)=0$，当 $A+1 > m$ 的时候 $F(x) \equiv 0 \pmod{x^{m+1}}$，可以不用跑多项式快速幂。

---

事实上可以通过 exp 将理论复杂度优化至 $O(m\log{m})$。

---

事实上可以不写多项式求逆。

考虑 $F(x)$ 的系数比较简单，可以简化一下。

$$
F(x)=o\sum_{i \geq 1}i^2x^i+s\sum_{i \geq 1}ix^i+u\sum_{i \geq 1}x^i
$$

$u\sum_{i \geq 1}x^i$ 可以直接等比数列得到 $\frac{ux}{1-x}$。

$s\sum_{i \geq 1}ix^i$ 提一个 $x$ 视作求导，可以得到 $\frac{sx}{(1-x)^2}$。

$o\sum_{i \geq 1}i^2x^i$ 可以把一个 $i$ 视作 $\sum_{j=1}^{i}$，也视作求导推得 $\frac{ox(1+x)}{(1-x)^3}$。

通分一下，把 $(1-x)^3$ 提到上面去得到：

$$
\frac{(1-x)^3(F^{A+1}-1)}{(u+1)x^3+(o-s-2u-3)x^2+(o+s+u+3)x-1}
$$

除 $1-x$ 是前缀和，乘上就是倒着做一遍，三次 $O(m)$ 可以算出上面。

下面的部分是短多项式，故可以直接递推，也是 $O(m)$。

（当然，瓶颈还是在多项式快速幂，只是可以不用写求逆了）

---

## 作者：Sym_Je (赞：1)

# P5075 [JSOI2012]分零食     

## 题目大意   

让你用 $n$ 个糖果发给 $1\to min(n,m)$ 个孩子 ，一个孩子的贡献是 $f(x)=Ox 
^2+Sx+U$ ,每一次发糖果的方案的贡献就是所有孩子的贡献的积 ， (没有糖果的孩子的贡献为 $1$ ) ，求所有方案的贡献和 。 


## $solution$   

首先我们可以直接写出他的 $dp$ 转移方程 ， 复杂度 $O(Am^2)$  

```cpp


int dp[maxn][maxn];// 分给了 i 个同学 j 个糖果的总贡献    
int m,p,A,O,S,U,ans;
int get(int x) {
	return (O*x*x+S*x+U)%p;
}
int main() {
	scanf("%d%d",&m,&p);
	scanf("%d%d%d%d",&A,&O,&S,&U); 
	dp[0][0]=1;
	for(int i=1;i<=A;++i) {
		for(int j=i;j<=m;++j) {
			for(int k=i-1;k<j;++k) {
				dp[i][j]=(dp[i][j]+dp[i-1][k]*get(j-k))%p;
			}
		}
	}  
	for(int i=1;i<=A;++i) ans=(ans+dp[i][m])%p;
	cout<<ans<<"\n";
	return 0;
}

```    

我会优化 ！！   
我们可以发现他的转移 ，   

```
dp[i][j]=(dp[i][j]+dp[i-1][k]*get(j-k))%p

```       

就是一个卷积的形式 ，$dp[i]=dp[i-1]* f$ $(f[i]=get(i))$   

复杂度 $O(Amlogm)$  期望得分 $50$ . 
 
我们的 $dp_i=f^i$ 

我们发现，我们其实最后是对所有的 $dp[m]$ 求和得到的答案 ，呢么我们能否快速的得到他们的和呢 ，我们设 $g_{n}$ 为 $\sum_{i=1}^{n}dp_i$ .     

我们可以发现    
$g_n=g_{\lfloor\frac{n}{2} \rfloor}+g_{\lfloor\frac{n}{2} \rfloor}* dp_{\lfloor\frac{n}{2} \rfloor}~~ (2|n)$   
$dp_n=dp_{\lfloor\frac{n}{2} \rfloor}*dp_{\lfloor\frac{n}{2} \rfloor}$

若 $[n\%2]$   
$g_n=g_{n-1}+dp_{n}$     
$dp_{n}=dp_{n-1}*f$

这样我们就直接分治算出来就好了 。
复杂度 $O(mlogmlogA)$ .   

* $code$   

```cpp

#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const ll maxn=2e6+10;
const ll mod=998244353;
const ll G=3,Gi=332748118;
ll m,p,N,O,S,U;

ll mul(ll x,ll y) {
	return x*y%mod;
}
ll add(ll x,ll y) {
	return (x+y)%mod;
}
ll dec(ll x,ll y) {
	return (x-y+mod)%mod;
} 
ll get(ll x) {
	return (O*x*x+S*x+U)%p;
}
ll poww(ll x,ll k) {
	ll ans=1;
	while(k) {
		if(k&1) ans=mul(ans,x);
		x=mul(x,x);
		k>>=1;
	}
	return ans; 
}
ll limit,r[maxn],l;

void NTT(ll *A,ll type) {
	for(ll i=0;i<limit;i++) if(r[i]<i) swap(A[i],A[r[i]]);
	for(ll mid=1;mid<limit;mid<<=1) {
		ll Wn=poww(type==1?G:Gi,(mod-1)/(mid<<1));
		for(ll R=(mid<<1),j=0;j<limit;j+=R) {
			ll w=1;
			for(ll k=0;k<mid;k++,w=mul(w,Wn)) {
				ll x=A[j+k],y=mul(w,A[j+k+mid]);
				A[j+k]=add(x,y);
				A[j+k+mid]=dec(x,y);
			}
		}
	}
	if(type==-1) {
		ll Inv=poww(limit,mod-2);
		for(ll i=0;i<limit;++i) A[i]=mul(A[i],Inv);
	}
}
ll ff[22][maxn],gg[22][maxn],z[maxn],qwq;
ll tmpA[maxn],tmpB[maxn];
void mul(ll *A,ll *B,ll *C) {
	for(ll i=0;i<=limit;++i) tmpA[i]=A[i],tmpB[i]=B[i];
	NTT(tmpA,1);NTT(tmpB,1);
	for(ll i=0;i<=limit;i++) tmpA[i]=mul(tmpA[i],tmpB[i]);
	NTT(tmpA,-1);
	for(ll i=1;i<=m;++i) C[i]=tmpA[i]%p; 
}

void fz(int k) {
	if(k==1) {
		return ;
	}
	fz(k>>1);
	++qwq;
	mul(ff[qwq-1],ff[qwq-1],ff[qwq]);
	ff[qwq-1][0]=(ff[qwq-1][0]+1)%p;
	mul(ff[qwq-1],gg[qwq-1],gg[qwq]);
	ff[qwq-1][0]=(ff[qwq-1][0]-1+p)%p;
	if(k&1) { 
		mul(ff[qwq],ff[0],z);
		for(int i=1;i<=m;++i) {
			ff[qwq][i]=z[i];
			gg[qwq][i]=(gg[qwq][i]+z[i])%p;
		}
	}
} 

int main() 
{
	scanf("%lld%lld",&m,&p);
	for(limit=1;limit<=m+m;limit<<=1,l++);
	for(ll i=0;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1)); 
	scanf("%lld%lld%lld%lld",&N,&O,&S,&U);
	for(ll i=1;i<=m;++i) 
		gg[0][i]=ff[0][i]=get(i);
	fz(N);
	/*for(ll i=0;i<=N;++i) {
		for(ll j=0;j<=m;++j) cout<<gg[i][j]<<" ";
		puts("");
	}*/
	cout<<gg[qwq][m]<<"\n";
	return 0;
} 



```




---

## 作者：Great_Influence (赞：1)

多项式求逆。

首先，可以列出一个简单的$dp$式子:

设$dp[i][j]$表示$i$个小朋友分$j$个糖果且每个人都至少有一颗的答案之和，则:

$$dp[n][m]=\sum_{i=1}^m (O*i^2+S*i+U)dp[n-1][m-i]$$

其中，$dp[0][0]=1$。

我们要求的答案为$\sum_{i=1}^A dp[i][m]$。

设$P=\sum_{i=1}^\infty (Oi^2+Si+U)x^i,Dp_n=\sum_{i=0}^\infty dp[n][i]x^i$，则上述转移可以写作:

$$Dp_n=Dp_{n-1}*P$$

$$Dp_0=1$$

答案可以写作:

$\sum_{i=1}^A Dp_i[m]$

$=\sum_{i=1}^A P^i[m]$

$=\frac{1-P^{A+1}}{1-P}[m]$

写一个多项式求逆就可以了。时间复杂度$O(n\log^2 n)$。你也可以写一个$Exp$优化到$O(n\log n)$，但是没必要。

代码:

```cpp

#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
    {
        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
    }
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++='0';
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using IO::read;
using IO::write;

inline void file()
{
#ifndef ONLINE_JUDGE
    FILE*WA=freopen("water.in","r",stdin);
    FILE*TER=freopen("water.out","w",stdout);
#endif
}

const int MAXN=(1<<17)+7;

static int m,mod,Tm,o,s,u;

inline void init()
{
	read(m),read(mod),read(Tm),read(o),read(s),read(u);
	Chkmin(Tm,m);
}

static int F[MAXN],G[MAXN];

static struct comp
{
	double tr,im;

	comp(double _tr,double _im):tr(_tr),im(_im){}

	comp(){tr=im=0;}

	friend comp operator*(comp a,comp b)
	{return comp(a.tr*b.tr-a.im*b.im,a.tr*b.im+a.im*b.tr);}

	friend comp operator+(comp a,comp b)
	{return comp(a.tr+b.tr,a.im+b.im);}

	friend comp operator-(comp a,comp b)
	{return comp(a.tr-b.tr,a.im-b.im);}
}A[MAXN],B[MAXN];

static int Len,rev[MAXN];

const double pi=acos(-1);

inline void FFT(comp*F,int typ)
{
	Rep(i,1,Len-1)if(rev[i]>i)swap(F[i],F[rev[i]]);
	for(register int i=2,ii=1;i<=Len;i<<=1,ii<<=1)
	{
		register comp wn=comp(cos(2*pi/i),typ*sin(2*pi/i));
		for(register int j=0;j<Len;j+=i)
		{
			register comp w=comp(1.0,0.0);
			Rep(k,0,ii-1)
			{
				register comp t=w*F[j+k+ii];
				F[j+k+ii]=F[j+k]-t;
				F[j+k]=F[j+k]+t;
				w=w*wn;
			}
		}
	}
	if(typ==-1)Rep(i,0,Len-1)F[i].tr/=Len;
}

inline void mul(int*a,int*b)
{
	Rep(i,0,m)A[i].tr=a[i],A[i].im=0,B[i].tr=b[i],B[i].im=0;
	Rep(i,m+1,Len-1)A[i]=B[i]=comp(0.0,0.0);
	FFT(A,1),FFT(B,1);
	Rep(i,0,Len-1)A[i]=A[i]*B[i];
	FFT(A,-1);
	Rep(i,0,m)a[i]=((int)(A[i].tr+0.5))%mod;
}

comp X[MAXN],Y[MAXN];

inline void calrev()
{
	int lg=log(Len)/log(2)-1;
	Rep(i,1,Len-1)rev[i]=rev[i>>1]>>1|(i&1)<<lg;
}

static int T[MAXN];

inline void Inv(int*a,int*b,int n)
{
	if(n==1){b[0]=1;return;}
	Inv(a,b,n>>1);
	Len=n<<1;
	Rep(i,0,n)T[i]=a[i];
	calrev();
	mul(T,b),mul(T,b);
	Rep(i,0,n-1)b[i]=(2*b[i]-T[i]+mod)%mod;
}

inline void solve()
{
	int lg=0;
	Rep(i,1,m)F[i]=mod-(o*i*i+s*i+u)%mod;
	for(Len=2;Len<=m<<1;++lg,Len<<=1);
	F[0]=1,Inv(F,G,Len);
	Rep(i,1,m)F[i]=mod-F[i];
	F[0]=0;
	for(Len=2;Len<=m<<1;++lg,Len<<=1);
	calrev(),memset(T,0,sizeof T),T[0]=1;
	for(++Tm;Tm;Tm>>=1,mul(F,F))if(Tm&1)mul(T,F);
	Rep(i,1,m)T[i]=mod-T[i];
	T[0]=1;
	mul(T,G);
	cout<<T[m]<<endl;
}

int main()
{
	file();
	init();
	solve();
    return 0;
}

```

---

## 作者：Fzrcy (赞：0)

一眼多项式题，先考虑暴力，设前 $i$ 个小朋友共有 $j$ 个糖果（每个人至少有一个）的情况下欢乐程度乘积的总和为 $f_{i,j}$，有转移：
$$
f_{i,j}=\sum_{k>0} f_{i-1,j-k}\times(Ok^2+Sk+U)
$$
初始值 $f_{0,0}=1$，因为 $m$ 个糖最多分给 $m$ 个小朋友，所以 $A=\min(A,m)$，复杂度 $O(m^2\min(A,m))$。

然后设多项式 $G=\sum_{i=1}(Oi^2+Si+U)x^{i}$，$F_{i}=\sum f_{i,j}x^j$，那么 $F_i=G*F_{i-1}=G^i$，答案即为 $[x^m]\sum_{i=1}^{\min(m,A)}F_{i}$。

问题转为求多项式 $sum=\sum_{i=1}^{n}G^i$，考虑倍增，假设我们求出 $sum'=\sum_{i=1}^{\lfloor\frac{n}{2}\rfloor}G^i$，然后根据 $n$ 的奇偶性进行分类讨论：

- 当 $n$ 为偶数时，$sum=sum'+G^{\lfloor\frac{n}{2}\rfloor}sum'$。
- 当 $n$ 为奇数时，$sum=sum'+G^{\lfloor\frac{n}{2}\rfloor}sum'+G^{n}$。

复杂度 $O(m\log^{2}m)$。

```cpp
// Fzrcy
#include <bits/stdc++.h>
#define inl inline
using namespace std;
constexpr int N=1e4+9;
const double pi=acos(-1);
int Mod,m;
struct Poly{int a[N],Len;Poly(){for(int i=0;i<=m;i++)a[i]=0;}};
struct FFT{
    struct cp{
        double x,y;
        inl cp operator + (cp b){return {x+b.x,y+b.y};}
        inl cp operator - (cp b){return {x-b.x,y-b.y};}
        inl cp operator * (cp b){return {x*b.x-y*b.y,x*b.y+y*b.x};}
    };
    cp w[N<<3],F[N<<3],G[N<<3]; int rev[N<<3];
    inl void fft(cp*a,int len,bool fl){
        for(int i=0;i<len;i++){
            rev[i]=(rev[i>>1]>>1)+(i&1?len>>1:0);
            if(rev[i]>i)swap(a[rev[i]],a[i]);
        }
        for(int d=1;d<len;d<<=1){
            cp W={cos(pi/d),sin(pi/d)};
            if(fl)W.y=-W.y; w[0]={1,0};
            for(int i=1;i<d;i++)w[i]=w[i-1]*W;
            for(int i=0;i<len;i+=d<<1){
                for(int j=0;j<d;j++){
                    cp a0(a[i+j]),a1(a[i+j+d]*w[j]);
                    a[i+j]=a0+a1,a[i+j+d]=a0-a1;
                }
            }
        }
        if(fl){
            for(int i=0;i<len;i++)
                a[i].x/=len,a[i].y/=len;
        }
    }
    inl void operator () (const Poly&x,const Poly&y,Poly&ret){
        int len=1;while(len<=x.Len+y.Len+9)len<<=1;
        for(int i=0;i<len;i++)F[i]=G[i]={0,0};
        for(int i=0;i<x.Len;i++)F[i]={(double)x.a[i],0};
        for(int i=0;i<y.Len;i++)G[i]={(double)y.a[i],0};
        fft(F,len,0), fft(G,len,0);
        for(int i=0;i<len;i++)F[i]=F[i]*G[i];
        fft(F,len,1);
        ret.Len=m+1;
        for(int i=0;i<ret.Len;i++)
            ret.a[i]=(int(F[i].x+0.5))%Mod;
    }
}conv;
Poly A,B,sum,Tmp;
inl void sol(int T){
    if(T==1){sum=A=B;return;}
    sol(T>>1);
    conv(sum,A,Tmp);
    for(int i=1;i<=m;i++)
        sum.a[i]=(sum.a[i]+Tmp.a[i])%Mod;
    conv(A,A,A);
    if(T&1){
        conv(A,B,A);
        for(int i=1;i<=m;i++)
            sum.a[i]=(sum.a[i]+A.a[i])%Mod;
    }
}
int O,S,U,a;
int main(){
    cin>>m>>Mod>>a>>O>>S>>U;B.Len=m+1;
    for(int i=1;i<=m;i++)B.a[i]=(O*i%Mod*i%Mod+S*i%Mod+U)%Mod;
    return a=min(a,m),sol(a),cout<<sum.a[m]<<endl,0;
}
```

---


# 普通多项式转下降幂多项式

## 题目背景

这是一道模板题

## 题目描述

已知普通多项式 $F(x)=\displaystyle\sum_{i=0}^{n-1}a_ix^{i}$。

求下降幂多项式 $G(x)=\displaystyle\sum_{i=0}^{n-1}b_ix^{\underline{i}}$。

使得 $G(x)=F(x)$。

所有运算均在 $\bmod\ 998244353$ 意义下进行。

## 说明/提示

对于所有数据 $a_i\in\lbrack0,998244353)$。

本题一共 $10$ 个点。

其中 $3$ 个点 $n=2000$。

另外 $7$ 个点 $n=10^5$。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
1 2 1```

# 题解

## 作者：zhoukangyang (赞：23)

[来博客园里看 /kel /kel /kel /kel /kel](https://www.cnblogs.com/zkyJuruo/p/14317051.html)

看题解里都是多点求值，但是这不是显然可以分治 $\tt FFT$ 吗 /yiw

考虑把下降幂分成两半，$F(x) = G(x) = \sum\limits_{i = 0}^{mid} b_i x^{\underline{i}} + x^{\underline{mid+1}} \sum\limits_{i = mid + 1}^{n - 1} b_i (x - mid - 1)^{\underline{i - mid - 1}}$

发现左边那部分的次数是 $mid$ 次，右边那部分是 $mid+1$ 次多项式 $x^{\underline{mid+1}}$ 的倍数。

左边那部分相当于把 $F(x)$ 对 $x^{\underline{mid + 1}}$ 取模，右边那部分相当于 $F(x)$ 对 $x^{\underline{mid + 1}}$ 做除法。

于是做一遍多项式除法，就变成要算 $\sum\limits_{i = 0}^{mid} b_i x^{\underline{i}}$ 和 $\sum\limits_{i = mid + 1}^{n - 1} b_i (x - mid)^{\underline{i - mid - 1}}$ 。

这个东西分治下去算就行了，时间复杂度 $\Theta(n \log ^ 2 n)$

每次分治只需要一次取模，快于多点求值。

代码：

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int, int>
#define mkp make_pair
using namespace std;
char buf[512], *p1 = buf, *p2 = buf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,512,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x = 0; char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
	return x;
}
void print(int x) {
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
const int N = (1 << 21), mod = 998244353, G = 3, iG = (mod + 1) / G;
int qpow(int x, int y = mod - 2) {
	int res = 1;
	for(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;
	return res;
}
int *A[N], tmp[N * 40], *Id = tmp; 
int Lim, lim, pp[N], PowG[N], iPowG[N];
void revlim() { L(i, 0, lim - 1) pp[i] = ((pp[i >> 1] >> 1) | ((i & 1) * (lim >> 1))); }
void up(int x) { lim = 1; for(; lim <= x; lim <<= 1); }
void cle(int *f) { L(i, 0, lim - 1) f[i] = 0; }
void init(int x) {
	int Pw;
	up(x), Lim = lim;
	Pw = qpow(G, (mod - 1) / Lim), PowG[0] = 1;
	L(i, 1, lim - 1) PowG[i] = (ll) PowG[i - 1] * Pw % mod;
	Pw = qpow(iG, (mod - 1) / Lim), iPowG[0] = 1;
	L(i, 1, lim - 1) iPowG[i] = (ll) iPowG[i - 1] * Pw % mod;
}
void NTT(int *f, int flag) {
	L(i, 0, lim - 1) if(pp[i] < i) swap(f[pp[i]], f[i]);
	for(int i = 2; i <= lim; i <<= 1) 
		for(int j = 0, l = (i >> 1), ch = Lim / i; j < lim; j += i) 
			for(int k = j, now = 0; k < j + l; k ++) {
				int pa = f[k], pb = (ll) f[k + l] * (flag == 1 ? PowG[now] : iPowG[now]) % mod;
				f[k] = (pa + pb) % mod, f[k + l] = (pa + mod - pb) % mod, now += ch;
			}
	if(flag == -1) {
		int nylim = qpow(lim);
		L(i, 0, lim - 1) f[i] = (ll) f[i] * nylim % mod;
	}
}
int sav[N], sv[N], svA[N], svB[N];
void inv(int *f, int *g, int len) { 
	if(len == 1) return g[0] = qpow(f[0]), void();
	inv(f, g, (len + 1) >> 1), up(len << 1), cle(sav), copy(f, f + len, sav), revlim(), NTT(sav, 1), NTT(g, 1);
	L(i, 0, lim - 1) g[i] = (ll) g[i] * (2ll + mod - (ll) g[i] * sav[i] % mod) % mod;
	NTT(g, -1), fill(g + len, g + lim, 0);
}
void Mul(int *f, int *g, int *ans, int n, int m) {
	static int A[N], B[N];
	up(n + m), revlim(), cle(A), cle(B), copy(f, f + n, A), copy(g, g + m, B);
	NTT(A, 1), NTT(B, 1);
	L(i, 0, lim - 1) A[i] = (ll) A[i] * B[i] % mod;
	NTT(A, -1), copy(A, A + n + m - 1, ans);
}
void div(int *f, int *g, int *ansa, int *ansb, int n, int m) {
	static int A[N];
	reverse(f, f + n), reverse(g, g + m), up((n - m + 1) << 1), cle(A);
	inv(g, A, n - m + 1), Mul(f, A, A, n - m + 1, n - m + 1);
	reverse(A, A + n - m + 1), copy(A, A + n - m + 1, ansa);
	reverse(f, f + n), reverse(g, g + m), Mul(g, A, A, m, n - m + 1);
	L(i, 0, m - 2) ansb[i] = (f[i] - A[i] + mod) % mod;
}
int ans[N], sava[N], savb[N];
void div1(int id, int l, int r) {
	A[id] = Id, Id += r - l + 2;
	if(l == r) return A[id][0] = mod - l, A[id][1] = 1, void();
	int mid = (l + r) >> 1;
	div1(id << 1, l, mid), div1(id << 1 | 1, mid + 1, r);
	up(r - l + 1), revlim(), cle(svA), cle(svB);
	copy(A[id << 1], A[id << 1] + mid - l + 2, svA), copy(A[id << 1 | 1], A[id << 1 | 1] + r - mid + 1, svB);
	NTT(svA, 1), NTT(svB, 1);
	L(i, 0, lim - 1) svA[i] = (ll) svA[i] * svB[i] % mod;
	NTT(svA, -1), copy(svA, svA + r - l + 2, A[id]);
}
void div2(int id, int l, int r, int *f) {
	if(l == r) return ans[l] = f[0], void();
	int len = r - l + 1, mid = (l + r) >> 1, La = mid - l + 1, Lb = r - mid, *a1, *a2;
	a1 = Id, Id += La + 1, a2 = Id, Id += Lb + 1;
	up(len + Lb), cle(sava), cle(savb);
	div(f, A[id << 1], savb, sava, len, La + 1);
	copy(sava, sava + La, a1), copy(savb, savb + Lb, a2);
	div2(id << 1, l, mid, a1), div2(id << 1 | 1, mid + 1, r, a2);
}
int n, m, f[N], g[N], ansa[N], ansb[N];
int main() {
	n = read(), init(n * 2);
	L(i, 0, n - 1) f[i] = read();
	div1(1, 0, n - 1), div2(1, 0, n - 1, f);
	L(i, 0, n - 1) print(ans[i]), putchar(' ');
	return 0;
} 
```

其实下降幂多项式转普通多项式也可以分治 $\tt FFT$，但那道题的题解区里有且比较显然就不讲了。

**祝大家学习愉快！**

---

## 作者：henrytb (赞：11)

今天上课了解到了这个知识，于是来写一写。

这篇题解**不**需要多点求值！**不**需要多项式除法！

## 下降幂多项式

形如 $f(x) = \sum_{i = 0}^{n}a_i x^{\underline{i} }$ 的多项式被称为**下降幂多项式**。

它有一些绝妙的性质。

求值：可以快速求一段 $0 \sim m$ 内的所有点值。

插值：可以根据 $0 \sim n + 1$ 的点值简单地插出这个下降幂多项式。

对于求值，考虑

$$
\begin{aligned}
f(x) & = \sum_{i = 0}^{n} a_i x^{\underline{i} } \\
& = x!\sum_{i = 0}^{n} a_i \frac{1}{(x - i)!}
\end{aligned}
$$

只需要求 $f$ 和 $\exp$ 的卷积，乘上 $x!$ 即可计算出 $f(x)$。

对于插值，考虑

$$
\begin{aligned}
f(x) & = \sum_{i = 0}^{n} a_i x^{\underline{i} } \\
& = \sum_{i = 0}^{x} \binom{x}{i} i! a_i
\end{aligned}
$$

二项式反演。

$$
\begin{aligned}
a_x & = \frac{1}{x!} \sum_{i = 0}^{x} (-1)^{x - i} \binom{x}{i} f(i) \\
& = \sum_{i = 0}^{x}\frac{f(i)}{i!} \cdot \frac{(-1)^{x - i}}{(x - i)!}
\end{aligned}
$$

这样就用 $0 \sim n$ 处的点值插出了所有 $a_i$。只需要一次卷积。

## 普通多项式转下降幂多项式

考虑分治。

设 $f$ 为待转换的普通多项式，$g$ 为转换后的下降幂多项式。

将 $f_{l\sim mid}$ 与 $f_{mid + 1 \sim r}$ 递归处理，求出 $g_{l\sim mid}$ 和 $g_{mid + 1 \sim r}$。

设 $m = mid - l + 1$，$len = r - l + 1$。

那么 $g_{l\sim r} = g_{l\sim mid} + x^m \cdot g_{mid + 1 \sim r}$。

考虑 $x^{m} \cdot g_{\ldots}$ 怎么求。其中 $g$ 已经是下降幂多项式了。

我们可以求出 $x^{m}$ 与 $g$ 在 $0 \sim len - 1$ 处的所有点值，$x^m$ 可以暴力，$g$ 可以采用上述方法处理。

然后将点值两两相乘得到 $x^m\cdot g$ 的点值，再插值回去即可得到 $x^m\cdot g$。

这样我们就将 $g_{l\sim mid}$ 和 $g_{mid + 1 \sim r}$ 合并成了 $g_{l\sim r}$。

Code:

```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define per(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
const int N = 1 << 18 | 5;
const int mod = 998244353;
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
int rev[N];
void NTT(int *f, int n, int sign) {
    int p = __lg(n);
    rep(i, 0, n - 1) {
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (p - 1));
        if (i < rev[i]) swap(f[i], f[rev[i]]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        int w = qpow(3, (mod - 1) / len), mid = len >> 1;
        for (int i = 0; i < n; i += len) {
            int now = 1;
            rep(j, 0, mid - 1) {
                int tx = f[i + j], ty = f[i + j + mid] * now % mod;
                f[i + j] = (tx + ty) % mod;
                f[i + j + mid] = (tx - ty + mod) % mod;
                now = now * w % mod;
            }
        }
    }
    if (sign == -1) {
        reverse(f + 1, f + n);
        int inv = qpow(n, mod - 2);
        rep(i, 0, n - 1) f[i] = f[i] * inv % mod;
    }
}
int n, f[N], g[N], gl[N], gr[N];
int ex[N], fac[N], ifac[N];
int C(int n, int m) {
    return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}
void solve(int l, int r) {
    if (l == r) {
        g[l] = f[l];
        return;
    }
    int mid = (l + r) >> 1;
    solve(l, mid);
    solve(mid + 1, r);
    int m = mid - l + 1, mr = r - mid;
    // * x ^ m
    rep(i, 0, m - 1) gl[i] = g[i + l];
    rep(i, 0, mr - 1) gr[i] = g[i + mid + 1];
    // gr
    // 0 ~ m + mr - 1
    rep(i, 0, m + mr - 1) ex[i] = ifac[i];
    int p = 0;
    while ((1 << p) <= mr - 1 + m + mr - 1) ++p;
    rep(i, mr, (1 << p) - 1) gr[i] = 0;
    rep(i, m + mr, (1 << p) - 1) ex[i] = 0;
    NTT(gr, 1 << p, 1); NTT(ex, 1 << p, 1);
    rep(i, 0, (1 << p) - 1) ex[i] = ex[i] * gr[i] % mod;
    NTT(ex, 1 << p, -1);
    rep(i, 0, m + mr - 1) ex[i] = ex[i] * qpow(i, m) % mod; // * fac[i] * ifac[i]
    rep(i, 0, m + mr - 1) {
        int fl = 1;
        if (i & 1) fl = mod - 1;
        gr[i] = ifac[i] * fl % mod;
    }
    p = 0;
    while ((1 << p) <= m + mr - 1 + m + mr - 1) ++p;
    rep(i, m + mr, (1 << p) - 1) ex[i] = gr[i] = 0;
    NTT(gr, 1 << p, 1); NTT(ex, 1 << p, 1);
    rep(i, 0, (1 << p) - 1) ex[i] = ex[i] * gr[i] % mod;
    NTT(ex, 1 << p, -1);
    rep(i, 0, m + mr - 1) g[i + l] = ((i < m ? gl[i] : 0) + ex[i]) % mod;
}
signed main() {
    fac[0] = 1;
    rep(i, 1, N - 5) fac[i] = fac[i - 1] * i % mod;
    ifac[N - 5] = qpow(fac[N - 5], mod - 2);
    per(i, N - 6, 0) ifac[i] = ifac[i + 1] * (i + 1) % mod;
    scanf("%lld", &n);
    rep(i, 0, n - 1) scanf("%lld", &f[i]);
    solve(0, n - 1);
    rep(i, 0, n - 1) printf("%lld ", g[i]);
    return 0;
}
```

---

## 作者：lazytag (赞：6)

（非常抱歉，上一次交错位置了，增加了管理员的工作量，以后会更加注意，希望管理员给过/kel）


学习了 bztMinamoto 大佬的做法，希望这篇题解可以使得那个方法更加易于理解。

既然下降幂多项式转普通多项式可以采取分治 $\operatorname{NTT}$，那么可以猜测逆过来也可以。（分治除法？？？）

引理：考虑，$\forall j>i$，都有 $x^{\underline{j}}\bmod x^{\underline{i}}=0$，那么，如果我们只是求 $x^{\underline{i}}$ 项的系数，我们可以直接把原式模 $x^{\underline{i+1}}$，再除以 $x^{\underline{i}}$ 获得答案。（以下除法均为带余除法，如果没有写明取余数，均**只取商**）。

如果对于每个位置都做两次除法，会导致大量重复计算，所以可以考虑分治做。

**具体做法：**

我们记 $D_{l,r}$，表示：
$$
D_{l,r}=\prod_{i=l}^{r-1}(x-i)
$$

我们通过分治 $\operatorname{NTT}$ 处理出 $D_{l,r}$，于是 $x^{\underline{i}}$，也就是 $D_{0,i}$ 可以通过 $O(\log n)$ 个区间合并出来。

不过当然不必如此繁琐，假设我们正在处理 $[l,r)$ 这段区间中下降幂多项式的系数，且已经得到：

$$
F'(x)=\frac{F(x)\bmod x^{\underline{r}}}{x^{\underline{l}}}
$$
那么，我们将 $F'(x)$ 除以 $D_{l,mid}$，将余数放入左子区间，商放入右子区间递归处理即可。

时间复杂度 $\mathcal O(n\log^{2}n)$。

关键代码：

```c++
using namespace Poly_NTT;

const int N = 1 << 18;
int n;
poly F[N << 2], D[N << 2], ans;
#define lc (k << 1)
#define rc ((k << 1) | 1) 
void calc(int k, int l, int r) {//代码中均为闭区间
	if (l == r) {
		D[k] = poly(vector <ll> {(mo - l) % mo, 1});
		return;
	}
	int mid = (l + r) >> 1;
	calc(lc, l, mid);
	calc(rc, mid + 1, r);
	D[k] = D[lc] * D[rc];
}
pair <poly, poly> tmp;
void solve(int k, int l, int r) {
	if (l == r) {
		ans[l] = F[k][0];
		return;
	}
	int mid = (l + r) >> 1;
	tmp = F[k] / D[lc];//second为余数，first为商。
	F[lc] = tmp.second;
	F[rc] = tmp.first;
	solve(lc, l, mid);
	solve(rc, mid + 1, r); 
}
int main() {
	read(n);
	F[1].resize(n); ans.resize(n);
	for (int i = 0; i < n; ++i) {
		read(F[1][i]);
	}
	calc(1, 0, n - 1);
	solve(1, 0, n - 1);
	ans.print();
	return 0;
}
```

相信大家都有自己的板子了，完整的就不放了，运算符还是很好理解的吧。



---

## 作者：NeosKnight (赞：6)

核心就是把 幂用下降幂来代替。

使用斯特林数展开幂为下降幂:

$$x^n=\sum_{i=0}^n{x\choose i}i!S(n,i)=\sum_{i=0}^nS(n,i)x^{\underline i}$$

那么要求的多项式:

$$\sum_{i=0}^{n-1}a_ix^i=\sum_{i=0}^{n-1}a_i\sum_{j=0}^jS(i,j)x^{\underline j}$$
交换求和顺序:
$$\sum_{j=0}^{n-1}x^{\underline j}\sum_{i=j}^{n-1} a_iS(i,j)$$

那么求出后面那个东西就行了。由于当 $i<j$时 $S(i,j)=0$,所以 $i$ 可以从 $0$ 开始枚举。这个就是一个要求一列的斯特林数的模型。

把斯特林数拆开:
$$\sum_{i=0}^{n-1}\frac{a_i}{j!}\sum_{k=0}^j (-1)^{j-k}{j\choose k}k^i$$

组合数拆开形成卷积:

$$\sum_{k=0}^j\frac{(-1)^{j-k}}{(j-k)!}*\sum_{i=0}^{n-1}\frac{a_ik^i}{k!}$$

令 $f_k=\frac{(-1)^k}{k!},g_k=\sum_{i=0}^{n-1}\frac{a_ik^i}{k!}$ ,那么对 $F(x)$与$G(x)$做卷积即可。

求 $G(x)$ 需要多项式多点求值。

code:
```cpp
#include<bits/stdc++.h>
#define Set(a,b) memset(a,b,sizeof(a))
#define Clear(a,_begin_,_end_) for(int i=_begin_;i<_end_;++i) a[i]=0
#define Input_Array(a,_begin_,_end_) for(int i=_begin_;i<_end_;++i) init(a[i])
#define __ NULL
using namespace std;
const int N=1e5+10,MAXN=N<<2,MAXM=5e6;
typedef vector<int> Poly;
template <typename T> inline void init(T&x){
	x=0;char ch=getchar();bool t=0;
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);
	if(t) x=-x;return;
}typedef double db;
typedef long long ll;
int Inv[MAXN],rader[MAXN];
const int mod=998244353,phi=998244352,SIZE=sizeof(rader),inv2=499122177;
template<typename T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;return;}
template<typename T>inline void Dec(T&x,int y){x-=y;if(x <	0) x+=mod;return;}
template<typename T>inline int fpow(int x,T k){int ret=1;for(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ret=(ll)ret*x%mod;return ret;}
inline int Sum(int x,int y){x+=y;if(x>=mod) return x-mod;return x;}
inline int Dif(int x,int y){x-=y;if(x < 0 ) return x+mod;return x;}
inline int Init(int n){int len=1,up=-1;while(len<=n) len<<=1,++up;for(int i=0;i<len;++i) rader[i]=(rader[i>>1]>>1)|((i&1)<<up);return len;}
inline void Calc_Inversion(){Inv[1]=1;for(int i=2;i<MAXN;++i) Inv[i]=(ll)(mod-mod/i)*Inv[mod%i]%mod;return;}
namespace NTT{
	int wn[30],iwn[30];
	inline void Calcw(){for(int i=0;i<30;++i) wn[i]=fpow(3,phi/(1<<i)),iwn[i]=fpow(wn[i],mod-2);}
	inline void NTT(int*A,int n,int f){
		for(int i=0;i<n;++i) if(rader[i]>i) swap(A[i],A[rader[i]]);
		for(int i=1,h=1;i<n;++h,i<<=1){
			int W=(~f)? wn[h]:iwn[h];
			for(int j=0,p=i<<1;j<n;j+=p){
				for(int w=1,k=0;k<i;++k,w=(ll)w*W%mod){
					int X=A[j|k],Y=(ll)w*A[j|k|i]%mod;
					A[j|k]=Sum(X,Y),A[j|k|i]=Dif(X,Y);
				}
			}
		}if(!~f) for(int i=0;i<n;++i) A[i]=(ll)A[i]*Inv[n]%mod;
		return;
	}
	inline void Mul(int*a,int*b,int*c,int n,int m) {
		int L=n+m-1;int len=Init(L);static int A[MAXN],B[MAXN];
		for(int i=0;i<n;++i) A[i]=a[i];for(int i=0;i<m;++i) B[i]=b[i];
		Clear(A,n,len);Clear(B,m,len);NTT(A,len,1),NTT(B,len,1);
		for(int i=0;i<len;++i) c[i]=(ll)A[i]*B[i]%mod;
		NTT(c,len,-1);return;
	}
	inline void Poly_Inv(int*F,int*I,int n){
		if(n==1) {memset(I,0,SIZE);I[0]=fpow(F[0],mod-2);return;}
		Poly_Inv(F,I,(n+1)>>1);int L=n<<1,len=Init(L);
		static int A[MAXN];for(int i=0;i<n;++i) A[i]=F[i];Clear(A,n,len);
		NTT(I,len,1);NTT(A,len,1);
		for(int i=0;i<len;++i) I[i]=Dif(Sum(I[i],I[i]),(ll)I[i]*I[i]%mod*A[i]%mod);
		NTT(I,len,-1);Clear(I,n,len);return;
	}
	inline void Poly_Mod(int*A,int*B,int*Q,int*R,int n,int m){
		if(n<m) {for(int i=0;i<=n;++i) R[i]=A[i];return;}
		static int C[MAXN],D[MAXN],E[MAXN];
		const int r=(n-m)<<1;int len=1;while(len<=r)len<<=1;
		for(int i=0;i<=n-m;++i) D[i]=A[n-i];Clear(D,n-m+1,len);
		for(int i=0;i<=m;++i)   E[i]=B[m-i];Clear(E,m+1,len);
		Poly_Inv(E,C,n-m+1);len=Init(r);NTT(C,len,1),NTT(D,len,1);
		for(int i=0;i<len;++i) C[i]=(ll)C[i]*D[i]%mod;
		NTT(C,len,-1);reverse(E,E+1+m),reverse(C,C+1+n-m);
		if(Q) for(int i=0;i<=n-m;++i) Q[i]=C[i];
		len=Init(n);Clear(C,n-m+1,len);Clear(E,m+1,len);
		NTT(C,len,1),NTT(E,len,1);
		for(int i=0;i<len;++i) C[i]=(ll)C[i]*E[i]%mod;
		NTT(C,len,-1);for(int i=0;i<m;++i) R[i]=Dif(A[i],C[i]);
		return;
	}
#define ls (u<<1)
#define rs (u<<1|1)
	int POOL[MAXM],cnt=0;
	int *P[MAXN],*F[MAXN],*G[MAXN],X[N],*val;
	inline int* Neospace(int len){int*ret=&POOL[cnt];cnt+=len;return ret;}
	inline int Calc(int*F,int n,const int x){int X=1,ret=0;for(int i=0;i<n;++i) Inc(ret,(ll)F[i]*X%mod),X=(ll)X*x%mod;return ret;}
	inline void Divide(int u,int l,int r){P[u]=NULL;//分治+NTT , 保留了中间的结果
		if(l==r) {P[u]=Neospace(2);P[u][0]=mod-X[l];P[u][1]=1;return;}
		static int L[MAXN],R[MAXN];int mid=(l+r)>>1;int LS=ls,RS=rs;
		Divide(LS,l,mid);Divide(RS,mid+1,r);
		int n=r-l+2,nl=mid-l+2,nr=r-mid+1;
		for(int i=0;i<nl;++i) L[i]=P[LS][i];
		for(int i=0;i<nr;++i) R[i]=P[RS][i];
		Mul(L,R,L,nl,nr);P[u]=Neospace(n);
		for(int i=0;i<n;++i) P[u][i]=L[i];
		return;
	}
	inline void Poly_Evaluate(int u,int l,int r){// 多点求值
		if(r-l+1<=500) {for(int i=l;i<=r;++i) val[i]=Calc(F[u],r-l+1,X[i]);return;}// 长度小的暴力计算
		int mid=(l+r)>>1,LS=ls,RS=rs;
		int n=r-l+1,nl=mid-l+1,nr=r-mid;
		static int R[MAXN];
		F[LS]=Neospace(nl),F[RS]=Neospace(nr);
		Poly_Mod(F[u],P[LS],__,R,n-1,nl);
		for(int i=0;i<nl;++i) F[LS][i]=R[i];
		Poly_Mod(F[u],P[RS],__,R,n-1,nr);
		for(int i=0;i<nr;++i) F[RS][i]=R[i];
		Poly_Evaluate(LS,l,mid);
		Poly_Evaluate(RS,mid+1,r);
		return;
	}
	inline void Solve_Evaluation(int*A,int*_X,int*ans,int n,int m){
		cnt=0;F[1]=Neospace(m);val=ans;
		for(int i=1;i<=m;++i) X[i]=_X[i];Divide(1,1,m);
		Poly_Mod(A,P[1],__,F[1],n-1,m);//注意最开始的多项式也要取一次模
		Poly_Evaluate(1,1,m);return;
	}
}
int fac[N],finv[N];
int main()
{
	Calc_Inversion();NTT::Calcw();
	int n;fac[0]=finv[0]=1;init(n);
	for(int i=1;i<n;++i) fac[i]=(ll)fac[i-1]*i%mod,finv[i]=(ll)finv[i-1]*Inv[i]%mod;
	static int F[MAXN],A[MAXN],X[MAXN];
	for(int i=0;i<n;++i) init(A[i]),X[i+1]=i,F[i]=(i&1)? (mod-finv[i]):finv[i];
	NTT::Solve_Evaluation(A,X,X,n,n);
	for(int i=0;i<n;++i) X[i]=(ll)X[i+1]*finv[i]%mod;X[n]=0;
	NTT::Mul(X,F,F,n,n);
	for(int i=0;i<n;++i) printf("%d ",F[i]);putchar('\n');
	return 0;
}

```




---

## 作者：command_block (赞：5)

**前置芝士**:

生成函数

[P5394 【模板】下降幂多项式乘法](https://www.luogu.org/problem/P5394)

[P5050 【模板】多项式多点求值](https://www.luogu.org/problem/P5050)

“下降幂多项式乘法”的主要思想就是(**连续**)点值EGF和下降幂多项式之间的$O(nlogn)$转换,称之为(I)FDT。

具体可见[Link](https://www.luogu.org/blog/command-block/solution-p5394)

我们可以直接采用多点求值求出原普通多项式在$1...n$的点值,然后IFDT变成下降幂多项式。

说起来简单码起来难……已经突破了我在luogu最长AC代码的记录……

别忘记是EGF,要乘阶乘逆元的!

```cpp
// luogu-judger-enable-o2
#include<algorithm>
#include<cstdio>
#define mod 998244353
#define G 3
#define Maxn 140000
#define ll long long 
using namespace std;
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int r[Maxn<<1];
long long invn,invG;
ll powM(ll a,ll t=mod-2)
{
  ll ans=1;
  while(t){
  	if(t&1)ans=ans*a%mod;
  	a=a*a%mod;
  	t>>=1;
  }return ans;
}
inline void print(long long *f,int len)
{
  for (int i=0;i<len;i++)
   printf("%lld ",f[i]);
  puts("");
}
//f=g
inline void cop(ll *f,ll *g,int len)
{for (int i=0;i<len;i++)f[i]=g[i];}
void NTT(ll *f,int n,int op)
{
  for (int i=0;i<n;i++)
    if (r[i]<i)swap(f[r[i]],f[i]);
  for (int p=2;p<=n;p<<=1){
  	int len=p>>1,
  	    w=powM(op==1 ?G:invG,(mod-1)/p);
  	for (int k=0;k<n;k+=p){
  	  ll buf=1;
  	  for (int i=k;i<k+len;i++){
  	  	int sav=f[len+i]*buf%mod;
  	  	f[len+i]=f[i]-sav;
  	  	if (f[len+i]<0)f[len+i]+=mod;
  	  	f[i]=f[i]+sav;
  	  	if (f[i]>=mod)f[i]-=mod;
  	  	buf=buf*w%mod;
  	  }
    }
  }
}
ll _g[Maxn<<1];//f*=g
void times(ll *f,ll *gg,int len1,int len2,int limit)
{
  int n=1;for(;n<len1+len2;n<<=1);
  ll *g=_g;
  for (int i=0;i<len2;i++)g[i]=gg[i];
  for(int i=0;i<n;i++)
    r[i]=(r[i>>1]>>1)|((i&1)?n>>1:0);
  NTT(f,n,1);NTT(g,n,1);
  for(int i=0;i<n;++i)f[i]=f[i]*g[i]%mod;
  NTT(f,n,-1);invn=powM(n);
  for(int i=0;i<limit;++i)f[i]=f[i]*invn%mod;
  for(int i=limit;i<n;++i)f[i]=0;
  for (int i=0;i<n;i++)g[i]=0;
}
ll _sav[Maxn<<1];//f*=g
inline void savtimes(ll *f,ll *g,int len1,int len2,int limit)
{
  for (int i=0;i<len1;i++)_sav[i]=f[i];
  times(_sav,g,len1,len2,limit);
  for(int i=0;i<limit;++i)f[i]=_sav[i];
  for(int i=0;i<limit;++i)_sav[i]=0;
}
ll _r[Maxn<<1],_rr[Maxn<<1];
void invp(ll *f,int len)
{
  ll *r=_r,*rr=_rr;
  int n=1;for(;n<len;n<<=1);
  rr[0]=powM(f[0]);
  for (int len=2;len<=n;len<<=1){
  	for (int i=0;i<len;i++)
  	  r[i]=(rr[i]<<1)%mod;
  	times(rr,rr,len>>1,len>>1,len);
  	times(rr,f,len,len,len);
  	for (int i=0;i<len;i++)
  	  rr[i]=(r[i]-rr[i]+mod)%mod;
  }for (int i=0;i<len;i++)f[i]=rr[i];
  for (int i=0;i<n;i++)r[i]=rr[i]=0;
}
ll *sav=_g;
void fan(ll *f,int m)
{
  for (int i=0;i<m;i++)sav[i]=f[i];
  for (int i=0;i<m;i++)f[i]=sav[m-i-1];
  for (int i=0;i<m;i++)sav[i]=0;
}
ll _q[Maxn<<1],_t[Maxn<<1];//f%=g
void mof(ll *f,ll *g,int n,int m)
{
  ll *q=_q,*t=_t;
  fan(g,m);cop(q,g,n-m+1);fan(g,m);
  invp(q,n-m+1);
  fan(f,n);cop(t,f,n-m+1);fan(f,n);
  times(q,t,n-m+1,n-m+1,n-m+1);
  fan(q,n-m+1);
  times(q,g,n-m+1,m,n);
  for (int i=0;i<m-1;i++)f[i]=(f[i]-q[i]+mod)%mod;
  for (int i=m-1;i<n;i++)f[i]=0;
  for (int i=0;i<n;i++)q[i]=t[i]=0;
}
ll gl[17][Maxn<<1];
void qfpre(int lev,int l,int r)
{
  if (l==r){
    gl[lev][l<<1]=mod-l;
    gl[lev][l<<1|1]=1;
    return ;
  }int mid=(l+r)>>1;
  qfpre(lev+1,l,mid);
  qfpre(lev+1,mid+1,r);
  cop(&gl[lev][l<<1],&gl[lev+1][l<<1],mid-l+2);
  savtimes(&gl[lev][l<<1],&gl[lev+1][(mid+1)<<1],mid-l+2,r-mid+1,r-l+2);
}
ll _s1[Maxn<<1],_s2[Maxn<<1];
void _queryf(int lev,int l,int r,ll *f,ll *y)
{
  if (r-l<=400){
    for (int i=l;i<=r;i++){
      long long buf=1;
      for (int j=l+l;j<l+r+1;j++){
        y[i]=(y[i]+buf*f[j])%mod;
        buf=buf*i%mod;
      }
    }return ;
  }int mid=(l+r)>>1;
  cop(_s1,&f[l<<1],r-l+1);
  mof(_s1,&gl[lev+1][l<<1],r-l+1,mid-l+2);
  cop(_s2,&f[l<<1],r-l+1);
  mof(_s2,&gl[lev+1][(mid+1)<<1],r-l+1,r-mid+1);
  for (int i=(l<<1);i<(r<<1|1);i++)f[i]=0;
  cop(&f[l<<1],_s1,mid-l+1);
  cop(&f[(mid+1)<<1],_s2,r-mid);
  for (int i=0;i<r-l+1;i++)_s1[i]=_s2[i]=0;
  _queryf(lev+1,l,mid,f,y);
  _queryf(lev+1,mid+1,r,f,y);
}
void queryf(ll *f,ll *y,int n,int m)
{
  qfpre(0,0,m-1);
  if (n>m)mof(f,gl[0],n,m+1);
  _queryf(0,0,m-1,f,y);
}
ll fac[Maxn],inv[Maxn];
void Init(int lim)
{
  inv[1]=inv[0]=fac[0]=1;
  for (int i=1;i<=lim;i++)fac[i]=fac[i-1]*i%mod;
  for (int i=2;i<=lim;i++)
  	inv[i]=inv[mod%i]*(mod-mod/i)%mod;
  for (int i=2;i<=lim;i++)inv[i]=inv[i-1]*inv[i]%mod;
}
ll _s[Maxn<<2];
void FDT(ll *f,int n)
{
  ll *s=_s;
  for (int i=0;i<n;i++)
    if (i&1)s[i]=mod-inv[i];
    else s[i]=inv[i];
  int len=1;for (;len<n+n;len<<=1);
  for (int i=n;i<len;i++)s[i]=0;
  for (int i=0;i<len;i++)
    r[i]=(r[i>>1]>>1)|(i&1?len>>1:0);
  NTT(f,len,1);NTT(s,len,1);
  for (int i=0;i<len;i++)f[i]=f[i]*s[i]%mod;
  NTT(f,len,-1);invn=powM(len);
  for (int i=0;i<n;i++)f[i]=f[i]*invn%mod;
  for (int i=n;i<len;i++)f[i]=0;
}
int n;
ll f[Maxn<<1],y[Maxn<<1];
int main()
{
  invG=powM(G);
  n=read();Init(n);
  for (int i=0;i<n;i++)f[i]=read();
  queryf(f,y,n,n);
  for (int i=0;i<n;i++)y[i]=y[i]*inv[i]%mod;
  FDT(y,n);
  for (int i=0;i<n;i++)printf("%lld ",y[i]);
  return 0;
}
```

更多信息请见[下降幂多项式杂谈](https://www.luogu.org/blog/command-block/xia-xiang-mi-duo-xiang-shi-za-tan)


---

## 作者：w33z8kqrqk8zzzx33 (赞：5)

~~众所周知~~有

$$x^k=\sum_{i=0}^k\begin{Bmatrix}k\\i\end{Bmatrix}x^{\underline i}$$

套：

$$\sum_{k=0}^{n-1}a_kx^k=\sum_{k=0}^{n-1}\sum_{i=0}^ka_k\begin{Bmatrix}k\\i\end{Bmatrix}x^{\underline i}=\sum_{i=0}^n(\sum_{k=i}^na_k\begin{Bmatrix}k\\i\end{Bmatrix})x^{\underline i}$$

于是答案序列 $b$ 就是（注意在这里重新标号）

$$b_k=\sum_{i=k}^na_i\begin{Bmatrix}i\\k\end{Bmatrix}=\sum_{i=0}^na_i\begin{Bmatrix}i\\k\end{Bmatrix}$$

第二类斯特林展开：

$$b_k=\sum_{i=0}^na_i\sum_{t=0}^k\frac{t^i}{t!}\frac{(-1)^{k-t}}{(k-t)!}=\sum_{t=0}^k\frac{\sum_{i=0}^na_it^i}{t!}\frac{(-1)^{k-t}}{(k-t)!}$$

注意里面的和就是给定的多项式！

$$b_k=\sum_{t=0}^k\frac{F(t)}{t!}\frac{(-1)^{k-t}}{(k-t)!}$$

用多点求值预处理 $F(0),F(1),\dots,F(n)$ 就变成了一个标准卷积。

代码：

```cpp
#pragma GCC optimize("-Ofast","-funroll-all-loops","-ffast-math")
#pragma GCC optimize("-fno-math-errno")
#pragma GCC optimize("-funsafe-math-optimizations")
#pragma GCC optimize("-freciprocal-math")
#pragma GCC optimize("-fno-trapping-math")
#pragma GCC optimize("-ffinite-math-only")
#pragma GCC optimize("-fno-stack-protector")
#pragma GCC target ("avx2","sse4.2","fma")
#include <immintrin.h>
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// https://judge.yosupo.jp/submission/5253

struct IO {
  static constexpr size_t buf_size = 1 << 18;
  char buf_in[buf_size], buf_out[buf_size];
  size_t pt_in = 0, pt_out = 0, tail_in = 0;
  char strs[10000 * 4];
  inline size_t num_digits(long long x) {
    if (x >= (long long)1e9) {
      if (x >= (long long)1e18) return 19;
      if (x >= (long long)1e17) return 18;
      if (x >= (long long)1e16) return 17;
      if (x >= (long long)1e15) return 16;
      if (x >= (long long)1e14) return 15;
      if (x >= (long long)1e13) return 14;
      if (x >= (long long)1e12) return 13;
      if (x >= (long long)1e11) return 12;
      if (x >= (long long)1e10) return 11;
      return 10;
    } else {
      if (x >= (long long)1e8) return 9;
      if (x >= (long long)1e7) return 8;
      if (x >= (long long)1e6) return 7;
      if (x >= (long long)1e5) return 6;
      if (x >= (long long)1e4) return 5;
      if (x >= (long long)1e3) return 4;
      if (x >= (long long)1e2) return 3;
      if (x >= (long long)1e1) return 2;
      return 1;
    }
  }
  IO() {
    load();
    for (int i = 0; i < 10000; ++i) {
      int j = i;
      for (int t = 3; t >= 0; --t) {
        strs[i * 4 + t] = j % 10 + '0';
        j /= 10;
      }
    }
  }
  ~IO() { flush(); }
  inline void load() {
    memcpy(buf_in, buf_in + pt_in, tail_in - pt_in);
    size_t width = tail_in - pt_in;
    tail_in = width + fread(buf_in + width, 1, buf_size - width, stdin);
    pt_in = 0;
  }
  inline void flush() {
    fwrite(buf_out, 1, pt_out, stdout);
    pt_out = 0;
  }
  inline void read(char& c) { c = buf_in[pt_in++]; }
  template <class T>
  inline void read(T& x) {
    if (pt_in + 32 > tail_in) load();
    char c;
    do {
      read(c);
    } while (c < '0');
    bool minus = 0;
    if (c == '-') {
      minus = 1;
      read(c);
    }
    x = 0;
    while (c >= '0') {
      x = x * 10 + (c & 15);
      read(c);
    }
    if (minus) x = -x;
  }
  inline void write(char c) { buf_out[pt_out++] = c; }
  template <class T>
  inline void write(T x) {
    if (pt_out > buf_size - 32) flush();
    if (x < 0) {
      write('-');
      x = -x;
    }
    size_t digits = num_digits(x);
    int i;
    for (i = pt_out + digits - 4; i > (int)pt_out; i -= 4) {
      memcpy(buf_out + i, strs + (x % 10000) * 4, 4);
      x /= 10000;
    }
    memcpy(buf_out + pt_out, strs + x * 4 + (pt_out - i), 4 + i - pt_out);
    pt_out += digits;
  }
  inline void write(const char* s) {
    if (pt_out > buf_size - 32) flush();
    for (int i = 0; s[i] != 0; ++i) write(s[i]);
  }
  template <class T>
  inline void writeln(T x) {
    write(x);
    write('\n');
  }
} io;

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, (int)(a))
#define rep1(i, a) iter(i, 1, (int)(a)+1)
#define fi first
#define se second
#define pb push_back
#define intsize (sizeof(int))
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;

typedef unsigned us;
typedef unsigned long long ull;

static char buf[450 << 20];
void* operator new(size_t s) {
	static size_t i = sizeof buf;
	assert(s < i);
	return (void*)&buf[i -= s];
}
void operator delete(void*) {}

template<class T> struct ptr {
	unsigned ind;
	ptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {
		assert(ind < sizeof buf);
	}
	T& operator*() const { return *(T*)(buf + ind); }
	T* get() const { return &**this; }
	T& operator[](int a) const { return (&**this)[a]; }
	explicit operator bool() const { return ind; }
};

namespace poly {
	const int MOD = 998244353;
	const int IMAG = 86583718;
	const int NTTG = 3;
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
// https://www.luogu.com.cn/record/32153077
// zzq orz
#define SZ 524320
ll qp(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%MOD;
		a=a*a%MOD; b>>=1;
	}
	return ans;
}
int getK(int n)
{int s=1; while(s<n) s<<=1; return s;}
us pool[SZ*4] __attribute__ ((aligned(64))),*ptr=pool;
us *p0[SZ],*p1[SZ],*q0[SZ],*q1[SZ];
__attribute__((always_inline)) void bit_flip(us*p,int t)
{
	for(int i=0,j=0;i<t;++i)
	{
		if(i>j) swap(p[i],p[j]);
		for(int l=t>>1;(j^=l)<l;l>>=1);
	}
}
void prep(int n)
{
	static int t=1;
	for(;t<n;t<<=1)
	{
		int g=qp(3,(MOD-1)/(t*2));
		us*p,*q;
		p=p0[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q0[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
		g=qp(g,MOD-2);
		p=p1[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q1[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
	}
}
typedef unsigned long long ull;
__attribute__((always_inline)) us my_mul(us a,us b,us c)
{
	return b*(ull)a-((ull(a)*c)>>32)*ull(998244353);
}
__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i&a, const __m128i& b)
{
	return _mm_mullo_epi32(a,b);
	/*
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2) 
	__m128i prod   = _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
	*/
}
__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i&a, const __m128i& b)
{
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (a2*b2,-,a0*b0,-)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (a3*b3,-,a1*b1,-)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (a1*b1,a0*b0,-,-) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (a3*b3,a2*b2,-,-) 
	__m128i prod   = _mm_unpackhi_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
}
void ntt(us* __restrict__ x,int n)
{
	int t=n;
	for(int m=1;m<n;m<<=1)
	{
		t>>=1;
		us* __restrict__ p=p0[m];
		us* __restrict__ q=q0[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					u=_mm_sub_epi32(u,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u,mm),
					_mm_cmpgt_epi32(m0,u)),mm));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					v=_mm_sub_epi32(my_mullo_epu32(v,p4),
					my_mullo_epu32(my_mulhi_epu32(v,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u,v));
					_mm_storeu_si128((__m128i*)(xb+j),_mm_add_epi32(_mm_sub_epi32(u,v),mm));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					u0=_mm_sub_epi32(u0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u0,mm),
					_mm_cmpgt_epi32(m0,u0)),mm));
					u1=_mm_sub_epi32(u1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u1,mm),
					_mm_cmpgt_epi32(m0,u1)),mm));
					v0=_mm_sub_epi32(my_mullo_epu32(v0,p4),
					my_mullo_epu32(my_mulhi_epu32(v0,q4),m1));
					v1=_mm_sub_epi32(my_mullo_epu32(v1,p4),
					my_mullo_epu32(my_mulhi_epu32(v1,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u0,v0));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_add_epi32(u1,v1));
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_add_epi32(_mm_sub_epi32(u0,v0),mm));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_add_epi32(_mm_sub_epi32(u1,v1),mm));
				}
			}
		}
	}
	for(int i=0;i<n;++i)
		x[i]-=(x[i]>=us(MOD+MOD))*us(MOD+MOD),
		x[i]-=(x[i]>=us(MOD))*us(MOD);
}
void intt(us* __restrict__ x,int n)
{
	int t=1;
	for(int m=(n>>1);m;m>>=1)
	{
		us* __restrict__ p=p1[m];
		us* __restrict__ q=q1[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i uv=_mm_add_epi32(u,v);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv,mm),
					_mm_cmpgt_epi32(m0,uv)),mm)));
					uv=_mm_add_epi32(_mm_sub_epi32(u,v),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv,p4),
					my_mullo_epu32(my_mulhi_epu32(uv,q4),m1)));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					__m128i uv0=_mm_add_epi32(u0,v0);
					__m128i uv1=_mm_add_epi32(u1,v1);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv0,mm),
					_mm_cmpgt_epi32(m0,uv0)),mm)));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_sub_epi32(uv1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv1,mm),
					_mm_cmpgt_epi32(m0,uv1)),mm)));
					uv0=_mm_add_epi32(_mm_sub_epi32(u0,v0),mm);
					uv1=_mm_add_epi32(_mm_sub_epi32(u1,v1),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv0,p4),
					my_mullo_epu32(my_mulhi_epu32(uv0,q4),m1)));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_sub_epi32(my_mullo_epu32(uv1,p4),
					my_mullo_epu32(my_mulhi_epu32(uv1,q4),m1)));
				}
			}
		}
		t<<=1;
	}
	us rn=qp(n,MOD-2);
	for(int i=0;i<n;++i)
		x[i]=x[i]*(ull)rn%MOD;
}
	
	void mult(us *a, us as, us *b, us bs, us *o, bool construct, bool clean = 0, us th = 100000000) {
		us n = as+bs-1;
		if(n >= 40) {
    		while(n - (n & (-n))) n += (n & (-n));
    		assert(!construct);
    		//constructrev(n);
    		ntt(a, n); ntt(b, n);
    		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
    		intt(o, n);
		} else {
		    static ll tmp[41];
		    rep(i, as) rep(j, bs) tmp[i+j] += 1ll * a[i] * b[j];
		    rep(i, n) {
		        o[i] = tmp[i] % MOD;
		        tmp[i] = 0;
		    }
		}
		iter(i, th, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(us* a, us as, us *o) {
		static us tmp[524320];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); us le = 0;
		while((1 << le) < (as << 1)) le++;
		//constructrev(1 << le);
		memcpy(tmp, a, as*intsize);
		memset(tmp+as, 0, ((1<<le)-as)*intsize);
		ntt(tmp, 1<<le); ntt(o, 1<<le);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		intt(o, 1<<le);
		memset(o+as, 0, ((1<<le)-as)*intsize);
	}

	void init(us n) { prep(n); }
	
	void divide(us *a, us as, us *b, us bs, us *q, us *r) {
		static us ar[524320], br[524320], bin[524320];
		us th = as, re = as-bs+1;
		//th = re+1;
		rep(i, as) ar[i] = a[as-1-i];
		rep(i, bs) br[i] = b[bs-1-i];
		cfn(br, th, bin);
		mult(ar, th, bin, th, q, 0, 1, re);
		reverse(q, q+re);
		mult(q, re, b, bs, r, 0, 1, bs - 1);
		rep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;
	}
	
}

#define array MY_FUCKING_ARRAY

struct array {
    ptr<us> head; us sz;
    array() : sz(0) { head = nullptr; }
    array(us size) : sz(size) { head = new us[size]; }
    us& operator[](const us idx) { return head[idx]; }
    us* get() { return head.get(); }
    const us size() { return sz; }
};

array pol[524320];


namespace Eval {
    us points[524320];
    us answer[524320];
    
    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }

    void solve(us idx, us l, us r, array& polynomial) {
        static us tmp[524320], tmp2[524320], tmp3[524320], BULLSHIT[524320];
        //assert(polynomial.size() == r-l);
        if(r - l == 0) return;
        if(r - l == 1) {
            answer[l] = polynomial[0];
            return;
        }
        us m = (l+r)/2;
        if(m - l) {
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2].get(), (m-l+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, m-l+1, BULLSHIT, tmp3);
            array p2(m-l); memcpy(p2.get(), tmp3, (m-l)*intsize);
            solve(idx*2, l, m, p2);
        }
        if(r - m) { 
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2+1].get(), (r-m+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, r-m+1, BULLSHIT, tmp3);
            array p2(r-m); memcpy(p2.get(), tmp3, (r-m)*intsize);
            solve(idx*2+1, m, r, p2);
        }
    }
us p[524320];
us dv[524320];
us rp[524320];
us BULLsHIT[524320];
    array eval(array& po, array& v) {
        us n = po.size(), m = v.size();
        rep(i, m) {
            points[i] = v[i];
            if(!v[i]) v[i] = MOD;
        }
        init(1, 0, m);
        static us tmp[524320];
        array pp(m);
        if(n >= m+1) {
            rep(i, m+1) dv[i] = pol[1][i];
            rep(i, n) p[i] = po[i];
            poly::divide(p, n, dv, m+1, BULLsHIT, tmp);
            memcpy(pp.get(), tmp, m*intsize);
        } else pp = po;
        solve(1, 0, m, pp);
        array res(m); memcpy(res.get(), answer, m*intsize);
        return res;
    }
}

/*
namespace Inter {
    us points[524320], values[524320];
    
    array drv, coeff;

    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }
    
    array solve(us idx, us l, us r) {
        if(r - l == 0) {
            array ans(1); ans[0] = 1;
            return ans;
        }
        if(r - l == 1) {
            array ans(1); ans[0] = 1ll * values[l] * poly::qpow(coeff[l], MOD-2) % MOD;
            return ans;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320], tmp4[524320];
        array tmp = solve(idx*2, l, (l+r)/2);
        array tmpp = solve(idx*2+1, (l+r)/2, r);
        memcpy(tmp1, tmp.get(), tmp.size() * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), pol[idx*2+1].size() * intsize);
        us s1 = tmp.size() + pol[idx*2+1].size() - 1;
        poly::mult(tmp1, tmp.size(), tmp2, pol[idx*2+1].size(), tmp3, 0, 1); 
        rep(i, tmpp.size()) tmp1[i] = tmpp[i];
        memcpy(tmp1, tmpp.get(), tmpp.size() * intsize);
        memcpy(tmp2, pol[idx*2].get(), pol[idx*2].size() * intsize);
        us s2 = tmpp.size() + pol[idx*2].size() - 1;
        poly::mult(tmp1, tmpp.size(), tmp2, pol[idx*2].size(), tmp4, 0, 1); 
        s2 = max(s2, s1); tmp = array(s2);
        rep(i, s2) {
            us p = tmp3[i] + tmp4[i]; p -= (p >= MOD ? MOD : 0);
            tmp[i] = p;
            //tmp3[i] = tmp4[i] = 0;
        }
        return tmp;
    }

    array inter(array& pt, array& vl) {
        assert(pt.size() == vl.size());
        us n = pt.size();
        memcpy(points, pt.get(), n * intsize);
        memcpy(values, vl.get(), n * intsize);
        init(1, 0, n);
        drv = array(n);
        rep1(i, n) { drv[i-1] = 1ll * i * pol[1][i] % MOD; }
        coeff = Eval::eval(drv, pt);
        return solve(1, 0, n);
    }
}
*/

#define pol MY_FUCKING_pol

array pts;
array pol;
array tmp;

us fac[524300], ifac[524300], inv[524300];
us ar1[524320], ar2[524320], f[524320];

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; io.read(n);
    fac[0] = ifac[0] = fac[1] = ifac[1] = inv[0] = inv[1] = 1;
    iter(i, 2, n+2) {
    	inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
    	fac[i] = 1ll * fac[i-1] * i % MOD;
    	ifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;
    }
    pts = array(n+1);
    rep(i, n+1) pts[i] = i;
    pol = array(n);
    rep(i, n) io.read(pol[i]);
    int k = 1; while(k < ((n+2) << 1)) k <<= 1;
    poly::init(k);
    tmp = Eval::eval(pol, pts);
    rep(i, n+1) ar1[i] = 1ll * tmp[i] * ifac[i] % MOD;
    rep(i, n+1) ar2[i] = 1ll * ((i % 2) ? (MOD - 1) : 1) * ifac[i] % MOD;
    poly::mult(ar1, n+1, ar2, n+1, f, 0);
    rep(i, n) io.write(f[i]), io.write(' ');
}
```

---

## 作者：Rorschachindark (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P5383)
# 题目大意
给出一个$n$次普通多项式$F(x)=\sum_{i=0}^{n-1} a_ix^i$，求出一个下降幂多项式$G(x)=\sum_{i=0}^{n-1} b_ix^{\underline{i}}$，使得$F(x)=G(x)$。

$n\le 10^5$
# 思路
这个题其实推式子的方法有很多种，这里介绍题解里面没有提到的两种方法。第一种方法就是借用一下[下降幂多项式乘法](https://www.cnblogs.com/Dark-Romance/p/13340138.html)里面的式子，直接多点求值，然后用它的$\texttt{EGF}$乘上$e^{-x}$就是下降幂多项式。

第二种方法就是用斯特林反演+第二类斯特林的表达公式推式子，这里讲一下第二种。

因为我们知道:

$$x^{\underline{n}}=\sum_{i=0}^{n} (-1)^{n-i} \begin{bmatrix} n\\i\end{bmatrix}x^i$$

于是，我们可以得到:

$$a_i = \sum_{x=i}^{n} (-1)^{x-i} \begin{bmatrix}x\\i \end{bmatrix} b_x$$

通过斯特林反演可以得到:

$$b_i=\sum_{x=i}^{n} \begin{Bmatrix}x\\i\end{Bmatrix}a_x$$

又因为我们知道:

$$\begin{Bmatrix}n\\m\end{Bmatrix}=\frac{1}{m!}\sum_{i=0}^{m} \binom{m}{i} (-1)^{m-i} i^n$$

所以我们可以得到:

$$b_i=\sum_{x=i}^{n} \frac{a_x}{i!} \sum_{k=0}^{i} \binom{i}{k}(-1)^{k-i}k^x$$

调换求和顺序、拆开组合数可以得到:

$$b_i=\sum_{k=0}^{i} (\frac{(-1)^{i-k}}{(i-k)!}\frac{1}{k!}\sum_{j=0}^{n-1} a_jk^j)$$

然后这个东西括号里面的$\sum$可以用多点求值求出来。其实和上面那个方法的最后的式子是一样的。

这道题有点卡常，所以多点求值的部分借鉴了$\texttt{bztMinamoto}$的思路，就是当区间长度比较小的时候，我们直接循环展开暴力，经过实测，不加上这种优化我的代码只有$30$，加上之后开了 O2 $\texttt{10.84s}$通过了。

时间复杂度$\Theta(n\log^2n)$。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define SZ(x) ((int)x.size())
#define Int register int
#define mod 998244353
#define MAXN 1000005

int mul (int a,int b){return 1ll * a * b % mod;}
int dec (int a,int b){return a >= b ? a - b : a + mod - b;}
int add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}
int qkpow (int a,int k){
	int res = 1;for (;k;k >>= 1,a = 1ll * a * a % mod) if (k & 1) res = 1ll * res * a % mod;
	return res;
}
int inv (int x){return qkpow (x,mod - 2);}

typedef vector <int> poly;

int w[MAXN],rev[MAXN];

void init_ntt (){
	int lim = 1 << 18;
	for (Int i = 0;i < lim;++ i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << 17);
	int Wn = qkpow (3,(mod - 1) / lim);w[lim >> 1] = 1;
	for (Int i = lim / 2 + 1;i < lim;++ i) w[i] = mul (w[i - 1],Wn);
	for (Int i = lim / 2 - 1;i;-- i) w[i] = w[i << 1];
}

void ntt (poly &a,int lim,int type){
#define G 3
#define Gi 332748118
	static int d[MAXN];
	for (Int i = 0,z = 18 - __builtin_ctz(lim);i < lim;++ i) d[rev[i] >> z] = a[i];
	for (Int i = 1;i < lim;i <<= 1)
		for (Int j = 0;j < lim;j += i << 1)
			for (Int k = 0;k < i;++ k){
				int x = mul (w[i + k],d[i + j + k]);
				d[i + j + k] = dec (d[j + k],x),d[j + k] = add (d[j + k],x);
			}
	for (Int i = 0;i < lim;++ i) a[i] = d[i] % mod;
	if (type == -1){
		reverse (a.begin() + 1,a.begin() + lim);
		for (Int i = 0,Inv = inv (lim);i < lim;++ i) a[i] = mul (a[i],Inv);
	}
#undef G
#undef Gi 
}

poly operator - (poly a,poly b){
	a.resize (max (SZ (a),SZ (b)));
	for (Int i = 0;i < SZ (b);++ i) a[i] = dec (a[i],b[i]);
	return a;
}

poly operator * (poly a,poly b){
	int d = SZ (a) + SZ (b) - 1,lim = 1;while (lim < d) lim <<= 1;
	a.resize (lim),b.resize (lim);
	ntt (a,lim,1),ntt (b,lim,1);
	for (Int i = 0;i < lim;++ i) a[i] = mul (a[i],b[i]);
	ntt (a,lim,-1),a.resize (d);
	return a;
}

poly inv (poly a,int n){
	poly b(1,inv (a[0])),c;
	for (Int l = 4;(l >> 2) < n;l <<= 1){
		c.resize (l >> 1);
		for (Int i = 0;i < (l >> 1);++ i) c[i] = i < n ? a[i] : 0;
		c.resize (l),b.resize (l);
		ntt (c,l,1),ntt (b,l,1);
		for (Int i = 0;i < l;++ i) b[i] = mul (b[i],dec (2,mul (b[i],c[i])));
		ntt (b,l,-1),b.resize (l >> 1);
	}
	b.resize (n);
	return b;
}

poly inv (poly a){return inv (a,SZ (a));}

poly Mod (poly F,poly G){
	int n = SZ (F) - 1,m = SZ (G) - 1;poly Q;Q.resize (m + 1);for (Int i = 0;i <= m;++ i) Q[i] = G[i];
	reverse (F.begin(),F.end()),reverse (G.begin(),G.end()),reverse (Q.begin(),Q.end()),Q.resize (n - m + 1),Q = inv (Q) * F,Q.resize (n - m + 1),reverse (Q.begin(),Q.end());
	reverse (F.begin(),F.end()),reverse (G.begin(),G.end()),Q = G * Q,Q.resize (m),Q = F - Q,Q.resize (m);
	return Q;
}

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,fac[MAXN],ifac[MAXN];
poly A,BB,CC,DR[MAXN << 2];

void divide1 (int i,int l,int r){
	if (l == r) return DR[i].resize (2),DR[i][0] = mod - l,DR[i][1] = 1,void ();
	int mid = (l + r) >> 1;divide1 (i << 1,l,mid),divide1 (i << 1 | 1,mid + 1,r);
	DR[i] = DR[i << 1] * DR[i << 1 | 1];
}

void divide2 (int i,int l,int r,poly AA){
	if (l == r) return CC[l] = AA[0],void ();
	poly B = Mod (AA,DR[i << 1]);int mid = (l + r) >> 1;divide2 (i << 1,l,mid,B);B = Mod (AA,DR[i << 1 | 1]);divide2 (i << 1 | 1,mid + 1,r,B);
}

signed main(){
	init_ntt(),read (n),A.resize (n);
	fac[0] = 1;for (Int i = 1;i <= n;++ i) fac[i] = mul (fac[i - 1],i);
	ifac[n] = inv (fac[n]);for (Int i = n;i;-- i) ifac[i - 1] = mul (ifac[i],i);
	for (Int i = 0;i < n;++ i) read (A[i]);CC.resize (n);divide1 (1,0,n - 1),divide2 (1,0,n - 1,A),BB.resize (n);
	for (Int i = 0;i < n;++ i) BB[i] = i & 1 ? mod - ifac[i] : ifac[i],CC[i] = mul (CC[i],ifac[i]);BB = BB * CC;
	for (Int i = 0;i < n;++ i) write (BB[i]),putchar (' ');
	putchar ('\n');
	return 0;
}
```

---

## 作者：littlez_meow (赞：1)

不会分治 NTT 当然是用无脑做法。

[题目指路](https://www.luogu.com.cn/problem/P5383)。

## 思路

你需要首先会：[多项式多点求值](https://www.luogu.com.cn/problem/P5050)、[下降幂多项式乘法](https://www.luogu.com.cn/problem/P5394)。

我们在点值间建立二者的联系。已知下降幂多项式在 $0\sim n$ 上的点值，还原出下降幂多项式是很简单的，只需求出点值序列的指数型生成函数，再卷上 $e^{-x}$ 即可得到系数序列的普通生成函数。

如何求 $0\sim n$ 次上的点值呢？当然是多项式多点求值了！

时间复杂度 $O(n\log^2 n)$，由于多点求值的巨大常数你可能需要预处理原根和原根逆元次幂、快速取模等卡常技巧。如果你用 `vector` 开 C++20 会有很好的卡常效果。

注意 $e^{-x}$ 可以泰勒展开而不是多项式求逆。

代码中记得转化成指数型生成函数。

## 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
const int MAXLEN=1<<20,MOD=998244353;
const int G=3,INVG=332748118;

namespace Barrette{
	typedef unsigned long long ull;
	typedef __uint128_t L;
	struct FastMod{
		const ull b, m;
		FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}
		ull reduce(ull a) {
			ull q = (ull)((L(m) * a) >> 64);
			ull r = a - q * b;
			return r >= b ? r - b : r;
		}
	}Mod(998244353);
	inline ll qpow(ll base,int expo){
		ll res(1);
		while(expo){
			(expo&1)&&(res=Mod.reduce(res*base));
			base=Mod.reduce(base*base),expo>>=1;
		}
		return res;
	}
	inline void meow(int&t){
		t>=MOD&&(t-=MOD);
		t<0&&(t+=MOD);
		return;
	}
}
using namespace Barrette;
int gpow[23],invgpow[23];
inline void pre(){
	F(i,1,22) gpow[i]=qpow(G,(MOD-1)>>i),invgpow[i]=qpow(INVG,(MOD-1)>>i);
	return;
}
int rev[MAXLEN];
inline int NTT(vector<int>&poly,bool inv){
	int n=poly.size();
	int len(2),expo(1);
	while(len<n) ++expo,len<<=1;
	poly.resize(len);
	F(i,0,len-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<(expo-1));
	F(i,0,len-1) i<rev[i]&&(swap(poly[i],poly[rev[i]]),1);
	static ll g[MAXLEN];
	g[0]=1;
	for(int i(1),expo(1);i<len;i<<=1,++expo){
		ll omega=inv?invgpow[expo]:gpow[expo];
		F(j,1,i-1) g[j]=g[j-1]*1ll*omega%MOD;
		for(int j(0);j<len;j+=(i<<1)) F(k,0,i-1){
			int&aa(poly[j+k]),&bb(poly[i+j+k]);
			int y(Mod.reduce(g[k]*bb));
			bb=aa-y;
			meow(bb);
			aa+=y;
			meow(aa);
		}
	}
	if(inv){
		ll invl(qpow(len,MOD-2));
		F(i,0,len-1) poly[i]=Mod.reduce(poly[i]*invl);
	}
	return len;
}
inline vector<int> inv(vector<int>poly){
	int n=poly.size();
	vector<int>res;
	res.push_back(qpow(poly[0],MOD-2));
	for(int l(2);l<(n<<1);l<<=1){
		vector<int>tmp=poly;
		tmp.resize(l);
		tmp.resize(l<<1),res.resize(l<<1);
		int lennow=NTT(tmp,0);
		NTT(res,0);
		F(i,0,lennow-1){
			int&qwq(res[i]),t(2-Mod.reduce(1ll*qwq*tmp[i]));
			meow(t);
			qwq=Mod.reduce(1ll*qwq*t);
		}
		NTT(res,1);
		res.resize(l);
	}
	res.resize(n);
	return res;
}
inline vector<int> mul(vector<int>a,vector<int>b){
	int n=a.size(),m=b.size(),len;
	a.resize(n+m-1),b.resize(n+m-1);
	len=NTT(a,0);
	NTT(b,0);
	F(i,0,len-1) a[i]=Mod.reduce(1ll*a[i]*b[i]);
	NTT(a,1);
	a.resize(n+m-1);
	return a;
}
inline vector<int> demul(vector<int>a,vector<int>b){
	int n=a.size(),m=b.size();
	if(n<m) return vector<int>();
	reverse(b.begin(),b.end());
	a.resize(n+m-1),b.resize(n+m-1);	
	int len=NTT(a,0);
	NTT(b,0);
	F(i,0,len-1) a[i]=Mod.reduce(1ll*a[i]*b[i]);
	NTT(a,1);
	F(i,0,n-m) a[i]=a[i+m-1];
	a.resize(n-m+1);
	return a;
}

vector<int>pos,ans;
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
vector<int>tree[400001];
inline void init(vector<int>&qwq){
	vector<int>qaq;
	swap(qwq,qaq);
	return;
}
inline void build(int now,int l,int r){
	if(l==r){
		init(tree[now]);
		tree[now].push_back(1);
		tree[now].push_back(pos[l]==0?0:MOD-pos[l]);
		return;
	}
	int mid((l+r)>>1);
	build(lc(now),l,mid),build(rc(now),mid+1,r);
	tree[now]=mul(tree[lc(now)],tree[rc(now)]);
	return;
}
inline void calc(int now,int l,int r,vector<int>qwq){
	if(l==r){
		ans[l]=qwq[0];
		return;
	}
	int mid((l+r)>>1);
	calc(lc(now),l,mid,demul(qwq,tree[rc(now)]));
	calc(rc(now),mid+1,r,demul(qwq,tree[lc(now)]));
	return;
}
inline void multipoint(vector<int>poly,vector<int>point){
	init(pos),init(ans);
	int n=max(point.size(),poly.size());
	ans.resize(n),poly.resize(n<<1),point.resize(n);
	pos=point;
	build(1,0,n-1);
	tree[1]=inv(tree[1]);
	calc(1,0,n-1,demul(poly,tree[1]));
	return;
}
int fact[MAXLEN],invf[MAXLEN];
vector<int>x,z;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,mm;
	vector<int>poly,point;
	pre();
	cin>>n;
	F(i,0,n-1){
		int x;
		cin>>x;
		poly.push_back(x);
	}
	F(i,0,n-1) point.push_back(i);
	multipoint(poly,point);
	fact[0]=invf[0]=1;
	F(i,1,n) fact[i]=Mod.reduce(fact[i-1]*1ll*i);
	invf[n]=qpow(fact[n],MOD-2);
	R(i,n,2) invf[i-1]=Mod.reduce(invf[i]*1ll*i);
	x.resize(n<<1);
	z.resize(n<<1);
	F(i,0,n-1) x[i]=Mod.reduce(ans[i]*1ll*invf[i]),z[i]=(i&1)?MOD-invf[i]:invf[i];
	mm=NTT(z,0);
	NTT(x,0);
	F(i,0,mm-1) x[i]=Mod.reduce(x[i]*1ll*z[i]);
	NTT(x,1);
	F(i,0,n-1) cout<<x[i]<<" ";
	return 0;
}
```

---

## 作者：Heng1116 (赞：0)

这个做法应该是常数比较小的了。

首先你需要会 [P5667](www.luogu.com.cn/problem/P5667)。

因为我们要求的是连续的点值，直接多点求值非常浪费。所以考虑多项式点值平移。

## 多点求值

假设要多点求值多项式为 

$$\sum_{i=0}^{2n-1} a_i x^i$$

已经求出了

$$\sum_{i=0}^{n-1} a_i x^i,\sum_{i=0}^{n-1} a_{i+n} x^i$$ 

在 $0 \sim n-1$ 的点值。

可以使用多项式点值平移求出 

$$\sum_{i=0}^{n-1} a_i x^i,\sum_{i=0}^{n-1} a_{i+n} x^i$$

在 $0 \sim 2n-1$ 的点值。

维护一个快速幂数组 $B[i]$，表示 $x^n$ 在 $0 \sim 2n-1$ 的点值。


这样通过乘上 $x^n$ 在 $0 \sim 2n-1$ 的点值就可以求出

$$\sum_{i=0}^{n-1} a_{i+n} x^{i+n}$$

在 $0 \sim 2n-1$ 的点值。把高次项和低次项点值求和即可。

## IFDT

最后一步，把点值转换成下降幂多项式，也就是 IFDT。

这个方法本质上与下降幂多项式乘法的原理相同。区别在于只有在输出时多项式才转变为系数形式，省下了 FDT/IFDT 的时间。

考虑 $x^{\underline{n}}$ 点值的 EGF：

$$\sum_{i=0}^\infty \frac{i^{\underline{n}}}{i!} x^i=\sum_{i=0}^\infty \frac{1}{(i-n)!} x^i=x^n\sum_{i=0}^\infty \frac{x^{(i-n)}}{(i-n)!}=x^n e^x$$

所以要把下降幂多项式转成点值只要把它看作普通多项式乘上 $e^x$，反之乘上 $e^{-x}$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
#define N 1048575
#define M 998244353
#define ll long long
#define RI register int
#define F(x) for(RI i=0;i<x;i++)
ll l = 2, A[N], a[N], b[N], B[N], c[N], g[N], m, n, t = 1, k;
inline int read() {
    int x = 0;
    char c = getchar();

    while (c >= '0' && c <= '9') {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }

    return x;
}
inline ll ksm(ll a, ll b) {
    ll ans = 1;

    while (b) {
        if (b & 1)
            ans = (ans * a) % M;

        a = (a * a) % M;
        b >>= 1ll;
    }

    return ans;
}
inline void inv(ll(&a)[N], ll(&b)[N], ll n, ll p, ll s) {
    b[s | 0] = 1;
    ll c = 1, d;

    for (ll i = 1; i <= n; i++) {
        b[s | i] = (a[s | i] * b[s | (i - 1)]) % p;
    }

    for (ll i = n; i >= 1; i--) {
        d = a[s | i];
        a[s | i] = (b[s | (i - 1)] * c) % p;
        c = (d * c) % p;
    }

    b[s | n] = ksm(b[s | n], p - 2);

    for (ll i = 1; i <= n; i++)
        a[s | i] = (a[s | i] * b[s | n]) % p;

    a[s | 0] = ksm(a[s | 0], p - 2);
}
inline void NTT(ll(&a)[N], bool inv, ll s) {

    F(l)if (i < c[i])
        swap(a[s | i], a[s | c[i]]);

    for (int h = 2; h <= l; h <<= 1) {
        ll w_n = ksm(ksm(3, inv ? M - 2 : 1), (M - 1) / h);

        for (int j = 0; j < l; j += h) {
            ll w = 1;

            for (int k = 0; k < (h >> 1); k++) {
                int x = a[s | j | k];
                int y = w * a[s | j | k | (h >> 1)] % M;
                a[s | j | k] = (x + y) % M;
                a[s | j | k | (h >> 1)] = (x - y + M) % M;
                w = (w * w_n) % M;
            }
        }
    }

    if (inv) {
        ll invl = ksm(l, M - 2);

        for (int i = 0; i < l; i++)
            a[s | i] = (a[s | i] * invl) % M;
    }
}
inline void move(ll(&a)[N], ll(&b)[N], ll(&A)[N], ll n, ll m, ll s) {
    while (l <= n * 3) {
        l <<= 1;
        t++;
    }

    F(l)c[i] = ((i & 1) << (t - 1)) | (c[i >> 1] >> 1);

    for (RI i = 0; i <= (n << 1); i++)
        A[s | i] = (m - n + i) % M;

    inv(A, b, n << 1, M, s);
    F(n + 1)b[s | i] = (a[s | i] * ((g[i] * g[n - i]) % M)) % M;

    F(n + 1)if ((n ^ i) & 1)
        b[s | i] = (M - b[s | i]) % M;

    F(n)b[s | (n + 1 + i)] = 0;
    F(l)c[i] = ((i & 1) << (t - 1)) | (c[i >> 1] >> 1);
    NTT(A, 0, s);
    NTT(b, 0, s);
    F(l)b[s | i] = (A[s | i] * b[s | i]) % M;
    NTT(A, 1, s);
    NTT(b, 1, s);
    ll r = 1;

    for (RI i = m - n; i <= m; i++)
        r = (r * i) % M;

    F(n + 1) {
        b[s | i] = (b[s | (n + i)] * r) % M;
        r = (r * ((A[s | i] * (m + i + 1)) % M)) % M;
    }
    F(l)A[s | i] = 0;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    m = read();
    F(m)a[i << 2] = read();
    n = 1;
    g[0] = 1;
    g[1] = 1;

    for (RI i = 2; i < N; i++)
        g[i] = ((M - M / i) * g[M % i]) % M;

    for (RI i = 1; i < N; i++)
        g[i] = (g[i] * g[i - 1]) % M;

    F(m << 1)B[i] = i;

    while (n < m) {
        n <<= 1;

        for (RI j = 0; j < (m << 2); j += n << 2) {
            move(a, b, A, (n >> 1) - 1, n >> 1, j);
            move(a, b, A, (n >> 1) - 1, n >> 1, j | (n << 1));
            F(n >> 1) {
                a[j | (n << 1) | i] = (a[j | (n << 1) | i] * B[i]) % M;
                b[j | (n >> 1) | i] = (b[j | (n >> 1) | i] * B[i | (n >> 1)]) % M;
            }
            F(n >> 1) {
                a[j | i] = (a[j | i] + a[j | (n << 1) | i]) % M;
                a[j | (n << 1) | i] = 0;
                a[j | (n >> 1) | i] = (b[j | i] + ((b[j | (n << 1) | i] * B[i | (n >> 1)]) % M)) % M;
            }
        }

        F(m << 3)b[i] = 0;
        F(m << 1)B[i] = (B[i] * B[i]) % M;
    }

    F(m) {
        a[i] = (a[i] * g[i]) % M;

        if (i & 1)
            g[i] = (M - g[i]) % M;
    }
    F(l)g[l | i] = 0;
    l <<= 1;
    F(l)c[i] = ((i & 1) << t) | (c[i >> 1] >> 1);
    NTT(a, 0, 0);
    NTT(g, 0, 0);
    F(l)a[i] = (a[i] * g[i]) % M;
    NTT(a, 1, 0);
    F(m)printf("%lld ", a[i]);
    return 0;
}
```

[1.44s](www.luogu.com.cn/record/195345475)

## 优化

其实由于我们每次合并时多项式的次数都是 $2^k$，但是由于多项式点值平移要用到 NTT，而 NTT 只支持 $2^k-1$ 次以下的多项式乘法，所以需要进行 $2$ 倍大小的 NTT。

其实我们可以把最高次项单独拎出来暴力计算，这样理论上应该可以卡掉一半的常数。具体没试过，应该可以卡到 720ms，再通过在低次项使用暴力计算的方式，应该可以卡到 700ms。

---


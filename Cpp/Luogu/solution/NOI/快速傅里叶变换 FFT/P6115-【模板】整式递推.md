# 【模板】整式递推

## 题目背景

话说上次菜菜的 NaCly\_Fish 想教后辈做常系数线性齐次递推，奈何智商不够，见识短浅，被机房同学轮番吊打。

之后她又听说了整式递推这种东西，便去请教中国队长 $\mathsf E \color{red}\mathsf{ntropyIncreaser}$。然而 $\mathsf E \color{red}\mathsf{ntropyIncreaser}$ 觉得这个东西太简单了，只回应了一句：“你不看候选队论文么？”

NaCly\_Fish 终于找来论文，但她完全看不懂。于是她只能找又强又热心的你来教她这个问题。

## 题目描述

对于无限数列 $a$，已知 $\forall n \ge m$ 都满足
$$\sum_{k=0}^m a_{n-k} P_k(n) = 0$$
其中 $P_k$ 为不超过 $d$ 次的多项式。  
给定所有 $P_k$ 的系数，和 $\{ a_i \}_{i=0}^{m-1} $，求 $a_n$。

由于答案可能很大，所以要对 $998244353$ 取模。

## 说明/提示

【样例一解释】  
这里的递推式就是 $a_n \equiv (n-1)(a_{n-1}+a_{n-2}) \pmod{998244353}$，容易计算得 $a_5 \equiv 44 \pmod{998244353}$。

【数据范围】  
对于 $30\%$ 的数据，$1\le n \le 10^6$。  
对于 $100\%$ 的数据，$1\le m,d \le 7$，$1 \le n \le 6 \times 10^8$。

所有输入不超过 $6 \times 10^8$。  
$\forall x \in [m,n] \cap \mathbb Z \text{ s.t. } P_0(x) \not \equiv 0 \pmod{998244353}$。

欢迎加入 $\mathsf E \color{red}\mathsf{ntropyIncreaser}$ 粉丝群：747262201

## 样例 #1

### 输入

```
5 2 1
1 0
998244352 0
998244352 1
998244352 1```

### 输出

```
44```

## 样例 #2

### 输入

```
233 2 3
1 0
998244352 0 0 0
0 998244349 4 0
0 8 998244337 8```

### 输出

```
193416411```

## 样例 #3

### 输入

```
114514 7 7
1 9 8 2 6 4 7
9 1 8 2 7 6 5 3
2 8 4 6 2 9 4 5
1 9 2 6 0 8 1 7
1 9 1 9 8 1 0 7
1 1 4 5 1 4 4 4
4 4 4 4 4 4 4 4
9 9 8 2 4 4 3 5
1 9 8 6 0 6 0 4```

### 输出

```
565704112```

# 题解

## 作者：NaCly_Fish (赞：53)

现在研究这个的人还不多，所以就放了个模板。  
这篇题解算是对 zzq IOI2019 候选队论文的补充吧。
****
现在递推系数变成了关于 $n$ 的多项式。虽然不能矩阵快速幂了，但维护转移矩阵乘积还是可以的。

根据整式递推的形式
$$P_0(n)a_n=-\sum_{k=1}^ma_{n-k}P_k(n)$$
我们可以设一个向量 $u_i$

$$u_i = \left\{ a_j\prod_{t=0}^{i-1}P_0(m+t)\right\}_{j=i}^{i+m-1}$$
那么只要求出 $u_{n-m+1}$，就能得到 

$$a_n\prod_{t=m}^nP_0(t)$$
（为了表述方便，下面设 $n'=n-m+1$）

现在需要一个矩阵 $M_i$，可以使得 $u_i\times M_i=u_{i+1}$。  

$$M_i=\begin{bmatrix} 0 & 0 & \dots &0 &0 & -P_m(i+m) \\ P_0(i+m) & 0 &\dots &0 &0 &-P_{m-1}(i+m) \\0 &P_0(i+m) & \dots &0 & 0 &-P_{m-2}(i+m) \\ \dots & \dots & \dots & \dots & \dots &\dots \\ 0 & 0 &\dots & P_0(i+m) &0 &-P_2(i+m) \\0 & 0 & \dots & 0 &P_0(i+m) & -P_1(i+m)\end{bmatrix}$$
手玩一下就能发现这个就是转移矩阵（  

那么问题转化为求 $M_0 \sim M_{n'-1}$ 的乘积（是个矩阵）。   
可以用类似 [P5282](https://www.luogu.com.cn/problem/P5282) 的做法，维护这样一个多项式的点值（要时刻记着 $f_w(x)$ 的点值也是矩阵）

$$f_w(x)=\prod_{i=0}^{w-1}M_{x+i}$$
这里设一个分块大小 $s$，它具体是多少先不管，到最后再确定。  
取 $f_s(x)$ 在 $0,s,2s,\dots,\lfloor (n'-s)/s\rfloor s$ 处的值乘起来，再乘一小段 $M_{s\lfloor n'/s \rfloor} \sim M_{n'-1}$ 即可。


与 P5282 不同的是，这里 $f_w(x)$ 是一个 $wd$ 次多项式，需要 $wd+1$ 个点值来确定它。  

按照那题的解法，会遇到一个矩阵序列和整数序列做卷积的情况；只需要枚举位置 $i,j$，把每个矩阵的这一位置取出来成一个序列，然后做正常的卷积就好了。

除此之外就和 P5282 做法基本一致，详细的做法在我的 [这篇blog](https://www.luogu.com.cn/blog/NaCly-Fish-blog/ji-yu-bei-zeng-wei-hu-duo-xiang-shi-dian-zhi-di-ji-suan) 中有讲（不想搬过来再写一遍了）。

别忘了还要计算 $P_0(m) \sim P_0(n)$ 的乘积，在倍增维护矩阵乘积的同时搞一下就好。

哦好像忘了确定 $s$ 的大小，我们发现时间复杂度是这么一个奇怪的式子
$$\text O\left(sd(m^3+m^2\log(n/s))\right)$$
稍加思索可以发现 $s$ 取 $\text O(\sqrt{n/d})$ 时最优。  
总时间复杂度就是 $\text O\left(\sqrt {nd}(m^3+m^2\log(nd))\right)$。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 524292
#define ll long long
#define reg register
#define p 998244353
using namespace std;

struct Z{
    int v;
    inline Z(const int _v=0):v(_v){}
};

inline Z operator + (const Z& lhs,const Z& rhs){ return lhs.v+rhs.v<p ? lhs.v+rhs.v : lhs.v+rhs.v-p; }
inline Z operator - (const Z& lhs,const Z& rhs){ return lhs.v<rhs.v ? lhs.v-rhs.v+p : lhs.v-rhs.v; }
inline Z operator - (const Z& x){ return x.v?p-x:0; }
inline Z operator * (const Z& lhs,const Z& rhs){ return (ll)lhs.v*rhs.v%p; }
inline Z& operator += (Z& lhs,const Z& rhs){ lhs.v = lhs.v+rhs.v<p ? lhs.v+rhs.v : lhs.v+rhs.v-p; return lhs; }
inline Z& operator -= (Z& lhs,const Z& rhs){ lhs.v = lhs.v<rhs.v ? lhs.v-rhs.v+p : lhs.v-rhs.v; return lhs; }
inline Z& operator *= (Z& lhs,const Z& rhs){ lhs.v = (ll)lhs.v*rhs.v%p; return lhs; }

template<typename T> inline void read(T& x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = x*10+(c^48);
        c = getchar();
    }
}

inline Z power(Z a,int t){
    Z res = 1;
    while(t){
        if(t&1) res *= a;
        a *= a;
        t >>= 1;
    }
    return res;
}

int ms;

struct matrix{
    Z a[8][8];
    inline matrix(){ memset(a,0,sizeof(a)); }

    inline matrix operator * (const matrix& b) const{
        matrix res = matrix();
        for(reg int i=0;i!=ms;++i)
        for(reg int j=0;j!=ms;++j)
        for(reg int k=0;k!=ms;++k)
            res.a[i][j] += a[i][k]*b.a[k][j];
        return res;    
    }
}I;

inline bool operator == (const matrix& lhs,const matrix& rhs){
    for(reg int i=0;i!=ms;++i)
    for(reg int j=0;j!=ms;++j)
        if(lhs.a[i][j].v!=rhs.a[i][j].v) return false;
    return true;   
}

struct poly{
    Z a[9];
    int t;
    inline Z operator [] (const int& x) const{ return a[x]; }
    inline Z& operator [] (const int& x){ return a[x]; }

    inline Z eval(const int& x){
        Z res = a[t];
        for(reg int i=t-1;~i;--i) res = a[i]+res*x;
        return res;
    }
}P[9];

inline matrix getmat(int x){
    matrix res = matrix();
    Z p0 = P[0].eval(x+ms);
    for(reg int i=0;i!=ms-1;++i) res.a[i+1][i] = p0;
    for(reg int i=0;i!=ms;++i) res.a[i][ms-1] = -P[ms-i].eval(x+ms);
    return res;
}

Z fac[N],ifac[N],rt[N],facm[N],inv[N];
int rev[N];
int siz;

inline int getlen(int n){ return 1<<(32-__builtin_clz(n)); }

void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    Z w = power(3,(p-1)>>siz);
    inv[1] = fac[0] = fac[1] = ifac[0] = ifac[1] = rt[lim>>1] = 1;
    for(reg int i=lim>>1|1;i!=lim;++i) rt[i] = rt[i-1]*w;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) fac[i] = fac[i-1]*i;
    ifac[n] = power(fac[n],p-2);
    for(reg int i=n-1;i;--i) ifac[i] = ifac[i+1]*(i+1);
    for(reg int i=2;i<=n;++i) inv[i] = fac[i-1]*ifac[i];
    for(reg int i=0;i!=ms;++i) I.a[i][i] = 1;
}

inline void dft(Z *f,int lim){
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i].v;
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k].v%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
}

inline void idft(Z *f,int lim){
    reverse(f+1,f+lim);
    dft(f,lim);
    reg int x = p-((p-1)>>__builtin_ctz(lim));
    for(reg int i=0;i!=lim;++i) f[i] *= x;
}

inline void lagrange(const matrix* F1,const Z *F2,int n,Z m,matrix* R1,Z *R2,bool flag){
    static Z pre[N],suf[N],f1[N],f2[N],g[N],inv_[N],ifcm[N],mul;
    int k = n<<1|1,lim = getlen(n<<1);
    facm[0] = 1;
    for(reg int i=0;i<=n;++i){
        facm[0] *= m-n+i;
        ifcm[i] = ifac[i]*ifac[n-i];
    }
    pre[0] = suf[k+1] = 1;
    for(reg int i=1;i<=k;++i) pre[i] = pre[i-1]*(m-n+i-1);
    for(reg int i=k;i;--i) suf[i] = suf[i+1]*(m-n+i-1);
    mul = power(pre[k],p-2);
    for(reg int i=1;i<=k;++i) inv_[i] = mul*pre[i-1]*suf[i+1];
    for(reg int i=1;i<=n;++i) facm[i] = facm[i-1]*(m+i)*inv_[i];
    for(reg int i=0;i!=k;++i) g[i] = inv_[i+1];
    memset(g+k,0,(lim-k+1)<<2);
    dft(g,lim);
    for(reg int i=0;i<=n;++i) f2[i] = ifcm[i]*((n-i)&1?-F2[i]:F2[i]);
    memset(f2+n+1,0,(lim-n)<<2);
    dft(f2,lim);
    for(reg int i=0;i!=lim;++i) f2[i] *= g[i];
    idft(f2,lim);
    for(reg int i=0;i<=n;++i) R2[i] = f2[i+n]*facm[i];
    if(!flag) return;
    for(reg int i=0;i!=ms;++i)
    for(reg int j=0;j!=ms;++j){
        for(reg int t=0;t<=n;++t) f1[t] = ifcm[t]*((n-t)&1?-F1[t].a[i][j]:F1[t].a[i][j]);
        memset(f1+n+1,0,(lim-n)<<2);
        dft(f1,lim);
        for(reg int t=0;t!=lim;++t) f1[t] *= g[t];
        idft(f1,lim);
        for(reg int t=0;t<=n;++t) R1[t].a[i][j] = f1[t+n]*facm[t];
    }
}

inline matrix ff(int d,int x){
    matrix res = getmat(x);
    for(reg int i=1;i!=d;++i) res = res*getmat(x+i);
    return res;
}

inline Z gg(int d,int x){
    Z res = P[0].eval(x);
    for(reg int i=1;i!=d;++i) res *= P[0].eval(x+i);
    return res;
}

int k;

pair<matrix,Z> magic(int s,int t){ 
    static Z g[N],gd[N],invs = power(s,p-2);
    static matrix f[N],fd[N];
    static int st[30],top = 0,x = s,d = 1,kd;
    while(x){
        st[++top] = x;
        x >>= 1;
    }
    for(reg int i=0;i<=k;++i){
        x = i*s;
        g[i] = P[0].eval(x);
        f[i] = getmat(x);
    }
    --top;
    while(top--){
        kd = k*d;
        lagrange(f,g,kd,kd+1,f+kd+1,g+kd+1,true);
        g[kd<<1|1] = 0;
        f[kd<<1|1] = matrix();
        lagrange(f,g,kd<<1,d*invs,fd,gd,true);
        for(reg int i=0;i<=(kd<<1);++i){
            f[i] = f[i]*fd[i];
            g[i] *= gd[i];
        }
        d <<= 1;
        if(!(st[top+1]&1)) continue;
        kd = k*(d+1);
        for(reg int i=k*d+1;i<=kd;++i){
            x = i*s;
            f[i] = ff(d,x),g[i] = gg(d,x);
        }
        for(reg int i=0;i<=kd;++i){
            x = i*s;
            f[i] = f[i]*getmat(x+d);
            g[i] *= P[0].eval(x+d);
        }
        ++d;
    }
    lagrange(f,g,k*s,ms*invs,f,g,false);
    matrix r1 = I;
    Z r2 = 1;
    for(reg int i=0;i<=t;++i) r1 = r1*f[i],r2 *= g[i];
    return make_pair(r1,r2);
}

Z P_recursive(const Z *a,int n){
    int tn = n-ms+1,s;
    s = ceil(sqrt(tn*1.0/k))+1;
    pair<matrix,Z> tmp = magic(s,(tn-s)/s);
    matrix mul = tmp.first;
    Z div_ = tmp.second,res = 0;
    for(reg int i=(tn/s)*s;i!=tn;++i){
        mul = mul*getmat(i);
        div_ *= P[0].eval(i+ms);
    }
    for(reg int i=0;i!=ms;++i) res += a[i]*mul.a[i][ms-1];
    return res*power(div_,p-2);
}

int n;
Z a[9];

int main(){
    read(n),read(ms),read(k);
    init(262147);
    for(reg int i=0;i!=ms;++i) read(a[i]);
    for(reg int i=0;i<=ms;++i){
        P[i].t = k;
        for(reg int j=0;j<=k;++j) read(P[i][j]);
    }
    Z ans = P_recursive(a,n);
    printf("%d",ans.v);
    return 0;   
}
```

---

## 作者：myee (赞：7)

### 引言

这题我之前一直只是口胡着，没有来写，现在有空了来写一下。

做这题之前建议先去做一下[快速阶乘算法](https://www.luogu.com.cn/problem/P5282)。

容易发现快速阶乘算法其实就是整式递推的一个特例而已……

所以如果你已经会了快速阶乘算法，这道题目就很容易实现了。

以下默认你已经学会了快速阶乘算法。

---
### 思路

好了，你现在已经会了快速阶乘算法了。

快速阶乘算法的思想在于**让机器帮你快速实现分段打表**。

具体的实现方法上，其依赖于**连续点值平移**与**值域倍增**。

为了实现整式递推，我们应当注意到快速阶乘算法过程中，我们维护的点值其实并不是 $n!$，而是 $\prod_{i=0}^{T-1}(aT+i)$，即**一对点值之间的倍数关系**。

由于整式递推阶数 $m$ 不止是 $1$ 了，我们就**不能直接维护一对数之间的倍数关系了**；而是维护出**一对 $m$ 维向量之间的线性变换**，即 $m\times m$ 的一个矩阵，**矩阵的每一项对应于某个多项式的一个点值**。

（学过高等代数的同学应该知道，由于一元多项式环是整环，所以在多项式环上的矩阵有定义，通常称为 $\lambda$-矩阵，其可以把 $\lambda$ 提出来写成多项式的形式。不过这不是重点。）

这个矩阵的形式不好构造成完全的多项式形式，我们不妨先令 $P_0(n)=-1$，那么相邻的向量之间的关系可以记为：

$$
\begin{bmatrix}P_1(n)&P_2(n)&P_3(n)&\cdots&P_{m-1}(n)&P_m(n)\\1\\&1\\&&1\\&&&\ddots\\&&&&1\\\end{bmatrix}
\begin{bmatrix}a_{n-1}\\a_{n-2}\\a_{n-3}\\\vdots\\a_{n-m+1}\\a_{n-m}\end{bmatrix}
=\begin{bmatrix}a_n\\a_{n-1}\\a_{n-2}\\\vdots\\a_{n-m+2}\\a_{n-m+1}\end{bmatrix}
$$

然后我们现在要考虑一般的 $P_0$，则为

$$
-{1\over P_0(n)}\begin{bmatrix}P_1(n)&P_2(n)&P_3(n)&\cdots&P_{m-1}(n)&P_m(n)\\-P_0(n)\\&-P_0(n)\\&&-P_0(n)\\&&&\ddots\\&&&&-P_0(n)\\\end{bmatrix}
\begin{bmatrix}a_{n-1}\\a_{n-2}\\a_{n-3}\\\vdots\\a_{n-m+1}\\a_{n-m}\end{bmatrix}
=\begin{bmatrix}a_n\\a_{n-1}\\a_{n-2}\\\vdots\\a_{n-m+2}\\a_{n-m+1}\end{bmatrix}
$$

设 $B(\lambda)=\begin{bmatrix}P_1(\lambda)&P_2(\lambda)&P_3(\lambda)&\cdots&P_{m-1}(\lambda)&P_m(\lambda)\\-P_0(\lambda)\\&-P_0(\lambda)\\&&-P_0(\lambda)\\&&&\ddots\\&&&&-P_0(\lambda)\\\end{bmatrix}
$，我们先撇开前面的 $-\frac1{P_0(n)}$ 因子不论，我们现在要维护 $\prod_{i=0}^{T-1}B(aT+m+i)$ 这种形式的量，其中乘法自右往左。

容易发现 $B_T(\lambda)=\prod_{i=0}^{T-1}B(\lambda+i)$ 是一个各项次数不高于 $dT$ 的 $\lambda$-矩阵，只用 $dT+1$ 个值即可维护。

于是我们维护出 $B_T(m)$，$B_T(m+T)$，$B_T(m+2T)$，$\dots$，$B_T(m+(dT-1)T)$，$B_T(m+dT^2)$ 这几个 $\lambda$-矩阵点值，然后用类似于快速阶乘算法的方式暴力进行多项式点值平移和倍增就好了。

初值 $T=1$，$B_1(\lambda)=B(\lambda)$，要维护 $d+1$ 处点值。

最后把原向量逐个乘过去即可。

完了？

别忘记还有 $-\frac1{P_0(n)}$ 因子！

现在要求 $\prod_{i=m}^n-P_0(i)$，直接再同上的方式做一次快速阶乘算法式的倍增即可。

---
### Code

常数太大，没过，就不贴了。

---
Update on 2022.10.10：

用循环卷积卡常卡过去了。

下面是核心代码。

```cpp
const ullt Mod=998244353,g=3;
typedef ConstMod::mod_ullt<Mod>modint;
typedef std::vector<modint>modvec;
typedef NTT_POLY::poly_NTT<Mod,g>poly;
typedef NTT_POLY::poly_eval<Mod,g>eval;
typedef NTT_POLY::poly_inter<Mod,g>inter;
typedef NTT_POLY::poly_cpd<Mod,g>cpd;
typedef NTT_POLY::poly_nums<Mod,g>nums;
typedef FWT_MODINT::FWT_Mod<Mod>FWT;
modint P[2000005],Q[2000005];
poly::DIFDIT s;
modvec shift2(modvec A,uint n,modint v){
    static modint User[4000005],UserInv[4000005];
    User[0]=1;
    for(uint i=0;i<=n*2;i++)User[i+1]=User[i]*(v-n+i);
    UserInv[n*2+1]=User[n*2+1].inv();
    for(uint i=n*2;~i;i--)UserInv[i]=UserInv[i+1]*(v-n+i);
    modvec G;for(uint i=0;i<=n*2;i++)G.push_back(UserInv[i+1]*User[i]);
    s.dif(G);for(uint i=0;i<s.size();i++)G[i]*=A[i];
    s.dit(G);
    modvec ans(n+1);
    for(uint i=0;i<=n;i++)ans[i]=G[i+n]*UserInv[i]*User[i+n+1];
    return ans;
}
modint A[10];poly W[10];
modvec B[10][10],B2;
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    P[0]=1;for(uint i=1;i<=2000000;i++)P[i]=P[i-1]*i;
    Q[2000000]=P[2000000].inv();for(uint i=2000000;i;i--)Q[i-1]=Q[i]*i;
    uint n,m,d;scanf("%u%u%u",&n,&m,&d);
    uint T=2;while(m+T*T*d<=n)T<<=1; // T \sim \sqrt n/d
    for(uint i=0;i<m;i++)A[i].read();
    std::reverse(A,A+m);
    for(uint i=0;i<=m;i++){W[i].chg_deg(d);for(uint j=0;j<=d;j++)W[i][j].read();}
    for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)B[i][j].resize(d+1);
    B2.resize(d+1);
    for(uint i=0;i<=d;i++)
    {
        for(uint j=0;j<m;j++)B[j][0][i]=cpd().point_eval(W[j+1],m+i);
        modint v=B2[i]=-cpd().point_eval(W[0],m+i);
        for(uint j=1;j<m;j++)B[j-1][j][i]=v;
    }
    for(uint t=2;t<=T;t<<=1){
        static modvec X,Y,Z,W;s.bzr(d*t+1); // 循环卷积卡常
        for(uint i=0;i<m;i++)for(uint j=0;j<m;j++){
            W=B[i][j];
            for(uint i=0;i<=d*(t/2);i++)W[i]*=Q[i]*Q[d*(t/2)-i]*((d*(t/2)-i)&1?-modint(1):1);
            s.dif(W),X=shift2(W,d*(t/2),d*(t/2)+1),Y=shift2(W,d*(t/2),d*t+2),Z=shift2(W,d*(t/2),d*(t/2)*3+3);
            for(auto v:X)B[i][j].push_back(v);
            for(auto v:Y)B[i][j].push_back(v);
            for(auto v:Z)B[i][j].push_back(v);
        }
        static modint QwQ[10][10];
        for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)QwQ[i][j]=0;
        for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)for(uint k=0;k<m;k++)QwQ[i][k]+=B[i][j][0]*B[j][k][1];
        for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)B[i][j][0]=QwQ[i][j];
        for(uint dep=1;dep<=d*t;dep++){
            for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)B[i][j][dep]=0;
            for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)for(uint k=0;k<m;k++)
                B[i][k][dep]+=B[i][j][dep<<1]*B[j][k][dep<<1|1];
        }
        for(uint i=0;i<m;i++)for(uint j=0;j<m;j++)B[i][j].resize(t*d+1);
        W=B2;
        for(uint i=0;i<=d*(t/2);i++)W[i]*=Q[i]*Q[d*(t/2)-i]*((d*(t/2)-i)&1?-modint(1):1);
        s.dif(W),X=shift2(W,d*(t/2),d*(t/2)+1),Y=shift2(W,d*(t/2),d*t+2),Z=shift2(W,d*(t/2),d*(t/2)*3+3);
        for(auto v:X)B2.push_back(v);
        for(auto v:Y)B2.push_back(v);
        for(auto v:Z)B2.push_back(v);
        for(uint dep=0;dep<=d*t;dep++)B2[dep]=B2[dep<<1]*B2[dep<<1|1];
        B2.resize(d*t+1);
    }
    modint ans(1);
    for(uint i=0;i<(n-m)/T;i++){
        modvec User(m);
        for(uint j=0;j<m;j++)for(uint k=0;k<m;k++)User[k]+=B[j][k][i]*A[j];
        for(uint j=0;j<m;j++)A[j]=User[j];
        ans*=B2[i];
    }
    for(uint i=(n-m)/T*T+m;i<=n;i++){
        modint user;
        for(uint j=0;j<m;j++)user+=cpd().point_eval(W[j+1],i)*A[j];
        modint v=-cpd().point_eval(W[0],i);
        for(uint j=m-1;j;j--)A[j]=A[j-1]*v;
        A[0]=user,ans*=v;
    }
    ans=A[0]/ans;
    ans.println();
    return 0;
}
```



---


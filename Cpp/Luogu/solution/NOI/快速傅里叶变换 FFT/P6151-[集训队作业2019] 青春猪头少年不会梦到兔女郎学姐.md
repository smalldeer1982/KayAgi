# [集训队作业2019] 青春猪头少年不会梦到兔女郎学姐

## 题目背景

来源：2019 集训队作业 Round4

## 题目描述

若干个正整数排成一个序列，其中数字 $i$ 的出现次数为 $c_i$，对于每一个这样的序列，定义他的权值如下：

把这个序列首尾相接放在一个圆上，把这些数字分成若干相邻的段，使得每段都是在圆上相邻的数字，任意两段没有公共的元素，每一段中的数字都相同，相邻段中的数字不同，则这个序列的权值定义为所有段的长度之积。

求所有的序列的权值和对 $998244353$ 取模。

注：虽然计算序列的权值的时候是圆排列，但互为循环排列的不同序列仍然被认为是不同的，如 $(1,2,1,2)$ 和 $(2,1,2,1)$ 被认为是不同的序列。

## 说明/提示

样例解释 #1：

合法序列为 $(1,1,2,2),(1,2,1,2),(1,2,2,1),(2,1,1,2),(2,1,2,1),(2,2,1,1)$。
权值分别为 $4,1,4,4,1,4$，和为 $18$。

$\sum c_i \le 2\times 10^5$

$2\le n\le 2\times 10^5$

## 样例 #1

### 输入

```
2
2 2```

### 输出

```
18```

## 样例 #2

### 输入

```
6
7 8 9 10 11 12```

### 输出

```
515320459```

# 题解

## 作者：iostream (赞：11)

5.7 update ：现在公式似乎不会出锅了？


引例：$n$ 种颜色的球分别 $a_i$ 个，相邻不同色，排列，方案数。

$m=\sum a_i\le 10^5$

首先考虑题目中的限制条件是什么，对于单种颜色的球从左往右看，第 $i$ 个跟第 $i+1$ 个不相邻，那么该颜色就对应着 $a_i-1$ 个限制。

普通容斥，也就是枚举打破多少限制
$$
\sum_{b_1\sim b_n,b_i\in[0,a_i-1]} \prod_{i=1}^n(-1)^{b_i}{a_i-1\choose b_i}\times {(\sum a_i-b_i)!\over \prod_{i=1}^n (a_i-b_i)!}
$$
换成枚举 $c_i=a_i-b_i$，然后 $c_i$ 的意义是说第 $i$ 个颜色强制缩成这么多个段。
$$
\sum_{c_1\sim c_n,c_i\in [1,a_i]} (\sum c_i)!\prod_{i=1}^n(-1)^{a_i-c_i}{(a_i-1)!\over (a_i-c_i)!(c_i-1)!}{1\over c_i!}
$$
注意到可以按 $\sum c_i$ 统计答案，那么构造关于后式的普通生成函数
$$
F_i(x)=\sum_{j=1}^{a_i}(-1)^{a_i-j}{(a_i-1)!\over (a_i-j)!(j-1)!j!}x^j
$$
用分治 ntt 卷积以后统计答案即可，复杂度 $O(m\log^2m)$。

当然这个是带标号球的拼接，显然可以直接用指数生成函数来理解，本质是一样的。

## 回到本题

给定 $n$ 种颜色的球，第 $i$ 种颜色的球数量为 $r_i$ ，对于一种排列方式，贡献可以如下计算：先把这个序列首尾相连，然后把所有相邻且颜色相同的段拿出来，贡献为他们的长度之积，求所有贡献和。
$(1,2,1,2)$ 和 $(2,1,2,1)$ 贡献相同但排列方式不同，要分别计算。

$\sum r_i\le 2\times 10^5$

我们首先考虑不成环的情况。

#### Step 1

枚举把颜色 $i$ 切成 $a_i$ 段，设 $f(x,y)$ 表示 $x$ 有序的切成 $y$ 段的所有方案，每段长度乘积之和。

问题转换为交错排列，直接套用上题的式子，那么有：
$$
\sum_{a_1\sim a_n,a_i\in[1,r_i]}f(r_i,a_i)\sum_{c_1\sim c_n,c_i\in [1,a_i]} (\sum c_i)!\prod_{i=1}^n(-1)^{a_i-c_i}{(a_i-1)!\over (a_i-c_i)!(c_i-1)!}{1\over c_i!}
$$
把 $c_i$ 整到前面来得到
$$
\sum_{c_1\sim c_n,c_i\in [1,r_i]} (\sum c_i)!\sum_{c_i\le a_i\le r_i}f(r_i,a_i)\prod_{i=1}^n(-1)^{a_i-c_i}{(a_i-1)!\over (a_i-c_i)!(c_i-1)!}{1\over c_i!}
$$
那么维护生成函数
$$
F_i(x)=\sum_{j=1}^{r_i}\sum_{j\le a_i\le r_i}f(r_i,a_i)(-1)^{a_i-j}{(a_i-1)!\over (a_i-j)!(j-1)!j!}x^j
$$
#### Step 2

考虑算这个 $F_i(x)$ 有 $f(x,y)={x+y-1\choose 2y-1}$ ，可以结合组合意义理解，考虑插板出一个方案，对于每一个连续段还要选出一个位置，相当于 $x+y-1$ 个位置选出 $2y-1$ 个位置。

于是计算 $F_i(x)$ 是一个卷积形式。

#### Step 3

分治 ntt 计算每种球的生成函数的乘积，复杂度 $O(m\log^2 m)$。

#### Step 4

要做环上的情况，我们钦定颜色 1 在序列最前头并且结尾不是 1，那么用开头是 1 的 - 开头结尾都是 1 的。

（钦定 $t$ 个位置为 1 相当于把 $F_1(x)$ 多项式往左平移 $t$ 位。）

这样的一种方案，我们可以通过任意旋转的方式遍历所有可行方案，那么我们最终把答案乘以 $m=\sum r_i$ 即可。

#### Step 5

然后你发现这样会算重，具体的，一个方案有 $j$ 段颜色 1，会被每个 1 遍历一遍，所以算重 $j$ 遍，那么可以在颜色 1 的生成函数中带上 $1\over j$ 的系数来抵消掉，问题才最终解决。

### 另外一种未知原理的方法

考虑计算关于序列的生成函数 $f(x)$, 则 $ans=m\sum_{j=1}^m (j-1)![x^j]f(x)$。

目前我不太清楚为什么，知道原理的大佬请评论区留言或者私信，谢谢！

---

## 作者：zhongyuwei (赞：9)

如果公式挂了请在[我的博客](https://zhongyuwei.github.io/2020/04/22/luogu-P6151-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2019-%E9%9D%92%E6%98%A5%E7%8C%AA%E5%A4%B4%E5%B0%91%E5%B9%B4%E4%B8%8D%E4%BC%9A%E6%A2%A6%E5%88%B0%E5%85%94%E5%A5%B3%E9%83%8E%E5%AD%A6%E5%A7%90/)或者[我的洛谷博客](https://www.luogu.com.cn/blog/zhongyuwei/solution-p6151)中查看

## Sol

定义一个序列是好的，当且仅当它以 $1$ 开始且不以 $1$ 结尾。

任意一个序列 $S$，假设它对应的圆排列中有 $c(S)$ 段 $1$，那么它的循环移位中有 $c(S)$ 个好的序列（这其中可能有相同的好序列）。也就是说，所有的好序列的、等于 $S$ 的循环移位的数量为 $c(S)$。

设 $val(S)$ 为序列 $S$ 的权值（与题目中的定义相同），那么


$
\begin{gathered}
Ans\\
= \sum_{\text{S为符合题意的序列}} val(S) \\
= \sum_{\text{S为符合题意的序列}} \frac{1}{c(S)}\sum_{\text{P是S的循环移位且P是好序列}} val(P)\\
= \sum_{\text{S为符合题意的序列}} \sum_{\text{P是S的循环移位且P是好序列}} \frac{1}{c(P)} val(P)\\
= \sum_{\text{P 是符合题意的好序列}} \frac{ val(P)}{c(P)} \sum_{\text{S 是 P 的循环移位}} 1\\
= \sum_{\text{P 是符合题意的好序列}} \frac{val(P)}{c(P)} |P|
\end{gathered}
$

因为序列的长度是固定的，我们只需要统计 $\sum_{\text{P是符合题意的好序列}} \frac{val(P)}{c(P)}$ 就能得到答案。

将 $a$ 个相同的数字划分成 $b$ 段的所有方案的权值和为

$
\begin{gathered}
\sum_{x_i \ge 1, x_1+x_2+\cdots x_b = a} \prod_{i=1}^b x_i
\end{gathered}
$

考虑到 $\prod_i x_i$ 的组合意义相当于是从每段里面再选出一个球，把选的这个球当成板子，可以得到上式等价于

$
\begin{gathered}
\sum_{x_i \ge 0, x_1+x_2+\cdots x_{2b} = a-b} 1\\
= \binom{a+b-1}{2b-1}
\end{gathered}
$

先枚举每种数字在最终的序列中形成了多少段，然后由于要求同种数字的段不能相邻，所以再枚举同种数字的哪些段被粘在了一起（容斥）。不为 $1$ 的数字，它的 EGF 为（假设这种数字共有 $a$ 个）

$
\begin{gathered}
\sum_{b=1}^a \binom{a+b-1}{2b-1} \sum_{j=1}^b (-1)^{b-j} \binom{b-1}{j-1} \frac{x^j}{j!}\\
= \sum_{j=1}^a \frac{x^j}{j!(j-1)!} (-1)^j \sum_{b=j}^a \frac{(b-1)!}{(b-j)!} (-1)^b \binom{a+b-1}{2b-1}
\end{gathered}
$

可以一次 FFT 算出来。

而对于数字 $1$，容斥的时候除了可以把相邻的段粘在一起，还可以把最后一段和结尾粘在一起，并且第一段在序列中的位置是确定了的，不参与排列，所以它的 EGF 为（仍然设 $a=c_1$）

$
\begin{gathered}
\sum_{b=1}^a \frac{1}{b} \binom{a+b-1}{2b-1} \sum_{j=0}^{b-1} \binom{b}{b-1-j} (-1)^{b-1-j} \frac{x^j}{j!}\\
= \sum_{j=0}^{a-1} \frac{x^j}{j!(j+1)!} (-1)^j \sum_{b=j+1}^a \frac{b!}{(b-j-1)!}(-1)^{b-1} \frac{1}{b} \binom{a+b-1}{2b-1}
\end{gathered}
$

也可以一次 FFT 算出来。

最后我们需要算的是每个数字的 EGF 的乘积，分治 FFT 即可。

## Code

``` cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#define PB push_back
#define MP make_pair
#define PII pair<int,int>
#define FIR first
#define SEC second
#define ll long long
using namespace std;
template <class T>
inline void rd(T &x) {
	x=0; char c=getchar(); int f=1;
	while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }
	while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
const int mod=998244353;
const int N=2e5+10;
ll Pow(ll x,int y) { ll res=1; for(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod; return res; }

namespace Poly {
	const int N=(1<<18)+10;
    int wn[2][N],rev[N];
    void getwn(int l) {
        for(int i=1;i<(1<<l);i<<=1) {
            int w0=Pow(3,(mod-1)/(i<<1)),w1=Pow(3,mod-1-(mod-1)/(i<<1));
            wn[0][i]=wn[1][i]=1;
            for(int j=1;j<i;++j)
                wn[0][i+j]=wn[0][i+j-1]*(ll)w0%mod,
                wn[1][i+j]=wn[1][i+j-1]*(ll)w1%mod;
        }
    }
    void getr(int len) { for(int i=1;i<len;++i) rev[i]=(rev[i>>1]>>1)|((i&1)*(len>>1)); }
    void FFT(int *A,int len,int f) {
        for(int i=0;i<len;++i) if(rev[i]<i) swap(A[i],A[rev[i]]);
        for(int l=1;l<len;l<<=1)
            for(int i=0;i<len;i+=l<<1)
                for(int j=0;j<l;++j) {
                    int t0=A[i+j],t1=A[i+l+j]*(ll)wn[f][l+j]%mod;
                    A[i+j]=(t0+t1)%mod,A[i+l+j]=(t0-t1)%mod;
                }
        if(f==1) {
            int Inv=Pow(len,mod-2);
            for(int i=0;i<len;++i) A[i]=A[i]*(ll)Inv%mod;
        }
    }  
	void Mul(int *A,int *B,int *C,int n,int m,int l3) {
        static int a[N],b[N];
        int len=1; while(len<n+m-1||len<l3) len<<=1; getr(len);
        for(int i=0;i<len;++i) a[i]=b[i]=0;
        for(int i=0;i<n;++i) a[i]=A[i];
        for(int i=0;i<m;++i) b[i]=B[i];
        FFT(a,len,0),FFT(b,len,0); for(int i=0;i<len;++i) a[i]=a[i]*(ll)b[i]%mod; FFT(a,len,1);
        for(int i=0;i<l3;++i) C[i]=a[i];
    }
    void Mul(int *A,int *B,int *C,int n,int m) { Mul(A,B,C,n,m,n+m-1); }
    inline void Mul(vector<int> &A,vector<int> &B,vector<int> &C) {
    	static int a[N],b[N];
        int len=1; while(len<A.size()+B.size()-1) len<<=1; getr(len);
        for(int i=0;i<len;++i) a[i]=b[i]=0;
        for(int i=0;i<A.size();++i) a[i]=A[i];
        for(int i=0;i<B.size();++i) b[i]=B[i];
        FFT(a,len,0),FFT(b,len,0); for(int i=0;i<len;++i) a[i]=a[i]*(ll)b[i]%mod; FFT(a,len,1);
        C.resize(A.size()+B.size()-1);
        for(int i=0;i<C.size();++i) C[i]=a[i];
    }
}

vector<int> g[N],s[N<<2];
inline void solve(int l,int r,int c) {
	if(l==r) return (void)(s[c]=g[l]);
	int mid=l+r>>1;
	solve(l,mid,c<<1),solve(mid+1,r,c<<1|1);
	Poly::Mul(s[c<<1],s[c<<1|1],s[c]);
	s[c<<1].clear();
	s[c<<1|1].clear();
}
ll fac[N<<1],inv[N<<1];
// ll A[N],B[N],C[N];
int A[N],B[N],C[N];
ll f[N];
//ll sum[N],tmp[N];
//int len;
inline void getfac(int n) {
	fac[0]=1; for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
	inv[n]=Pow(fac[n],mod-2); for(int i=n;i>=1;--i) inv[i-1]=inv[i]*i%mod;
}
inline ll binom(int n,int m) { return fac[n]*inv[m]%mod*inv[n-m]%mod; }
int ra[N];
int main() {
	int m; rd(m);
	getfac(400000);
	Poly::getwn(18);
//	sum[0]=1;
	int coe=0;
	for(int now=1,a;now<=m;++now) {
		rd(a),coe+=a;
		for(int i=0;i<=a;++i) A[i]=B[i]=0;
		if(now==1) {
			for(int i=1;i<=a;++i) A[i]=binom(a+i-1,2*i-1)*fac[i-1]%mod*(i&1?1:-1);
			for(int i=1;i<=a;++i) B[a-i]=inv[i-1];
			Poly::Mul(A,B,C,a+1,a+1);
			for(int i=0;i<a;++i) f[i]=C[i+a]*inv[i]%mod*inv[i+1]%mod*(i&1?-1:1);
			
//			for(int i=1;i<=a;++i) B[i]=inv[i-1];
//			for(int i=1;i<=a;++i) for(int j=1;j<=i;++j) (C[i-j]+=A[i]*B[j]%mod)%=mod;
//			for(int i=0;i<a;++i) f[i]=C[i]*inv[i]%mod*inv[i+1]%mod*(i&1?-1:1),C[i]=0;
		}
		else {
			for(int i=1;i<=a;++i) A[i]=binom(a+i-1,2*i-1)*fac[i-1]%mod*(i&1?-1:1);
			for(int i=0;i<a;++i) B[a-i]=inv[i];
			Poly::Mul(A,B,C,a+1,a+1);
			for(int i=1;i<=a;++i) f[i]=C[i+a]*inv[i]%mod*inv[i-1]%mod*(i&1?-1:1);
//			for(int i=0;i<a;++i) B[i]=inv[i];
//			for(int i=1;i<=a;++i) for(int j=0;j<i;++j) (C[i-j]+=A[i]*B[j]%mod)%=mod;
//			for(int i=1;i<=a;++i) f[i]=C[i]*inv[i]%mod*inv[i-1]%mod*(i&1?-1:1),C[i]=0;
		}
		for(int i=0;i<=a;++i) g[now].PB(f[i]),f[i]=0;
//		for(int i=0;i<=a;++i)
//		for(int j=0;j<=len;++j)
//			(tmp[i+j]+=f[i]*sum[j]%mod)%=mod;
//		len+=a;
//		for(int i=0;i<=len;++i) sum[i]=tmp[i],tmp[i]=0;
//		for(int i=0;i<=a;++i) f[i]=0;
	}
	solve(1,m,1);
	int ans=0;
//	for(int i=0;i<=len;++i) (ans+=sum[i]*fac[i]%mod)%=mod;
	for(int i=0;i<s[1].size();++i) (ans+=s[1][i]*fac[i]%mod)%=mod;
	ans=1ll*ans*coe%mod;
	printf("%d",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：VinstaG173 (赞：7)

### 前言 一些没啥用的题外话

新剧场版要播出了。因为真的很喜欢青猪所以来做下这道题。

同时祝枫 24 岁生日快乐。但是我还没有 24 岁，这么说来应该是姐姐（？

upd on 11.25

官方设定花枫的生日是 11.25，那就今天祝花枫生日快乐吧！

退役太久了什么都不会了，因此试着写一篇和我一样什么都不会的人也能看懂的题解，不过需要一些基础的生成函数知识和数学计算能力，另外 CDQ 分治部分和板子题的解法类似，故细节在本文中不再赘述。

但是我觉得这个绕开极长连续段的做法实在太他妈天才了阿！绕开之后的过程也很优雅。

以下进入正文。

---

### 零 简要题意

对于 $c_1$ 个 $1$，$c_2$ 个 $2$，$\dots$，$c_n$ 个 $n$ 构成的任意排列，定义其权值为**将其首尾相接成圆排列后**所有**极长连续相同数段**的长度之积，求所有不同排列（**不是所有圆排列**）的权值之和。

具体地，例如对于 $1,2,1,2$，其权值为 $1 \times 1 \times 1 \times 1=1$；对于 $1,2,2,1$，其权值为 $2 \times 2=4$。最终答案的计算可见样例解释。

记 $\sum c_i=C$。

### 一 问题转化

我们考虑一个极长连续相同数段的贡献。

不妨设为一个长度为 $l$ 的全为 $1$ 的数段，出现在区间 $[1,l]$。则其仅在 $[1,l]$ 均为 $1$ 且 $l+1,C$ 位置均不为 $1$ 的排列中出现，考虑计算这些排列的权值总和。其中每个排列可以分为 $[l+1,C]$ 这个 $C-l$ 位序列的 $l+1,C$ 位置上均不为 $1$ 的一个排列和一个长为 $l$ 的全为 $1$ 的排列，圆排列的权值是这两个排列（此时已经断开成序列而不是圆排列）的权值之积。

求这些圆排列的权值之和时，可以提取公因数，即长为 $l$ 的全为 $1$ 的排列的权值（即为 $l$），将剩下的长为 $C-l$ 的所有排列权值求和，设这个和为 $v_1$。

如果容斥处理极长的性质，式子可能会很复杂。我们寻找一个等价的刻画，仍然使得长为 $l$ 全为 $1$ 的排列的权值计算结果为 $l$。

我们试图将极长连续相同数段的条件弱化为连续相同数段，方便后续处理。设此时长为 $k$ 的数段的权值为 $a_k$。则按照题目中的计算法则（注意此时我们取的贡献是所有**连续相同数段**的 $a_k$ 乘积之和，不是所有**极长连续相同数段**的 $l$ 乘积之和），我们将 $l$ 划分为若干个 $k_i$ 之和，则这些长为 $k_i$ 的数段的总权值为 $\prod_i a_{k_i}$，再由加法原理得到所有可能的划分方式的权值总和为

$$\sum_{t \ge 1}\sum_{\sum_{i=1}^tk_i=l}\prod_{i=1}^ta_{k_i}.$$

由于我们寻求一个等价的替代，因此我们希望 $\displaystyle\sum_{t \ge 1}\sum_{\sum_{i=1}^tk_i=l}\prod_{i=1}^ta_{k_i}=l$。

为什么这是一个等价的替代呢？

首先由于该数段内与数段外贡献独立，故原来的计算下所有排列的权值为 $v_1l$。现在我们将原来的一个圆排列中 $[1,l]$ 划分为长为 $k_i$ 的数段，事实上多出了很多排列，但此时 $[1,l]$ 中划分方式相同的排列仍然可以提取公因数 $\prod_i a_{k_i}$，与段外权值通过乘法原理得到总权值 $v_1\prod_i a_{k_i}$，再求和后得到所有排列的权值和仍为 $\displaystyle\sum_{t \ge 1}\sum_{\sum_{i=1}^tk_i=l}v_1\prod_{i=1}^ta_{k_i}=v_1l$，故这个替代是等价的。

考虑 $a_k$ 的 OGF：$\displaystyle A(x)=\sum_{k\ge1}a_kx^k$，则 $\displaystyle[x^l]\sum_{t\ge1}A^t=l$，故 $\dfrac{A}{1-A}=\dfrac{x}{(1-x)^2}$。

这样我们将题意转化为：定义排列的权值为将其接成圆排列后**所有划分为连续相同数段的方式**的**所有数段长度 $k$ 对应的 $a_k$ 的乘积之和**（这里是对于**一个排列**，对于**所有划分方式**求和得到**排列的权值**），求所有排列的权值之和。其中 $a_k$ 为如上定义的生成函数 $A$ 的系数。

事实上 $a_k$ 的值成 $0,1,1,0,-1,-1$ 的 $6$ 位循环，但是在稍后的计算中我们会发现这并不是很有用。

例如排列 $1,2,2,1$，其权值为 $(1),(2),(2),(1);(1,1),(2),(2);(1),(2,2),(1);(1,1),(2,2)$ 四种**划分方式**的权值之和，即 $a_1^4+2a_1^2a_2+a_2^2$。有 $a_1=a_2=1$，故其权值为 $4$。

以下设 $C=\displaystyle\sum_{i=1}^nc_i$，原排列为 $p_1,\dots,p_C$。

### 二 解决转化后的问题

假设共有 $m$ 个连续数段，值为 $i$ 的数段有 $t_i$ 个，其中 $\displaystyle\sum_{i=1}^nt_i=m$。由于不要求相同值的数段不相邻，因此我们可以任意排列数段。

设 $p_1=v$，则只考虑数段的值而不考虑长度时，可以看作剩下 $t_i$ 个 $i(i \neq v)$ 和 $t_v-1$ 个 $v$ 的排列，有 $\displaystyle\binom{m-1}{t_1,\dots,t_v-1,\dots,t_n}$ 种。

对于每种数值 $v$，$c_v$ 个 $v$ 被划分为 $t$ 个数段的划分方式的总权值为

$$f_{v,t}=\sum_{\sum_{i=1}^tk_i=c_v}\prod_{i=1}^ta_{k_i}=[x^{c_v}]A^t(x),$$

设这个总权值的 EGF 为 $\displaystyle F_v(y)=\sum_{t\ge1}\dfrac{f_{v,t}}{t!}y^t$。

而钦定一段覆盖 $p_1$ 时，设该段的长度为 $k$，则 $p_1$ 位置有 $k$ 种可能，其对总权值的贡献为 $ka_{k}$，OGF 为 $xA'(x)$，故总权值为

$$\begin{aligned}f_{v,t}'&=[x^{c_v}]xA'(x)A^{t-1}(x)\\
&=[x^{c_v-1}]\dfrac1t(A^t)'(x)\\
&=\dfrac{c_v}t[x^{c_v}]A^t(x)=\dfrac{c_v}tf_{v,t},
\end{aligned}$$

则对于所有由 $m$ 个数段组成的圆排列，首先确定分别有哪些数段值为 $i$，同时确定 $p_1$ 的数值 $v$，再决定 $t_i$ 个值为 $i$ 的数段的长度划分方式，其总权值为

$$\begin{aligned}
g_m&=\sum_{\sum_{i=1}^nt_i=m}\sum_{v=1}^n\binom{m}{t_1,\dots,t_v-1,\dots,t_n}\dfrac{c_v}{t_v}\prod_{i=1}^nf_{i,t_i}\\
&=(m-1)!\sum_{\sum_{i=1}^nt_i=m}\sum_{v=1}^nc_v\prod_{i=1}^n[y^{t_i}]F_i(y)\\
&=C(m-1)![y^m]\prod_{i=1}^nF_i(y).
\end{aligned}$$

枚举总段数 $m$，最终答案即为 $\displaystyle\sum_{m=n}^Cg_m$。

### 三 具体算法

至此我们已经结束了大量的数学推导，接下来的任务就是计算 $g_m$。

首先我们要计算 $F_v$，这要求我们对 $t\in[1,c_v]$ 求出 $[x^{c_v}]A^t(x)$。

由（扩展）拉格朗日反演，设 $B(x)$ 满足 $B(A(x))=x$ 为 $A$ 的复合逆，有 $[x^c]A^t(x)=\dfrac1c[x^{c-1}](x^t)'\left(\dfrac x{B(x)}\right)^c=\dfrac{t}{c}[x^{c-t}]\left(\dfrac x{B(x)}\right)^c$，于是我们只需求出 $\left(\dfrac x{B(x)}\right)^c$ 的系数即可。

由于 $A(x)$ 满足 $\dfrac{A(x)}{1-A(x)}=\dfrac x{(1-x)^2}$，故 $\dfrac x{1-x}=\dfrac{B(x)}{(1-B(x))^2}$，整理得 $x+xB(x)^2=B(x)+xB(x)$，令 $D(x)=\dfrac{B(x)}x$，则 $1+x^2D(x)^2=D(x)+xD(x)$，故

$$\begin{aligned}
d_0=1,\displaystyle\sum_{i=0}^td_id_{t-i}&=[x^{t+2}](1+x^2D(x)^2)\\
&=[x^{t+2}](D(x)+xD(x))=d_{t+2}+d_{t+1}.
\end{aligned}$$

可以用分治 FFT（CDQ 分治）$O(n\log^2n)$ 计算。

取 $-c_p\ln D(x)$ 的 $\exp$，即可计算得到 $F_v$ 的系数。接下来只需要计算乘积 $\displaystyle\prod_{v=1}^n F_v$。

由于 $\displaystyle\sum_{v=1}^n\deg F_v=C$，考虑分治计算乘积。将 $F_v$ 的乘积放到线段树上，区间 $[l,r]$ 存储 $\displaystyle\prod_{v=l}^rF_v$，则共有 $O(\log n)$ 层。对于每个非叶子结点 NTT 计算两个儿子的多项式乘法。由于每层的所有多项式次数之和为 $O(C)$，故对于每层都只需要 $O(C\log C)$ 时间即可求出所有乘积多项式，总复杂度 $O(C\log C\log n)$。

由于 $n,C$ 同阶，因此总时间复杂度为 $O(n\log^2n)$，瓶颈在以上两个分治过程。

### 后记 一些不一定有啥用的题外话

事实上我们直接将极长数段权值 $l$ 转化为数段权值 $a_k$ 的这个过程中 $l$ 是非本质的，即我们可以用同样的方法解决极长数段权值为 $u_l$ 的版本。此时有 $\dfrac A{1-A}=U$，后续数学推导部分全部一致。

但对于不知性质的一般 $U$，求 $A$ 甚至 $B$ 的系数将变得很复杂。我们同样有 $\dfrac x{1-x}=U(B(x))$，此时该方程可能很难解。

---

## 作者：GreenDay (赞：7)

```
while(1)ORZ(iostream);
```

[题面](https://www.luogu.com.cn/problem/P6151)

介于洛谷上现在还没有这道题的代码，就让本蒟蒻来提供一篇。(抵制无脑复制粘贴，从我做起)

```cpp
#include <bits/stdc++.h>
using namespace std;

//就暂且这么认为吧
typedef long long int64;
const int mod = 998244353 , g = 3;
namespace SYT_POLY
{

int _[1<<19] , w0[1<<19] , w1[1<<19];//备用的数组

int qpow(int x , int y = mod - 2)
{
    int res = 1;
    for(; y ; y >>= 1 , x = 1ll * x * x % mod)
        if(y & 1) res = 1ll * res * x % mod;
    return res; 
} 

struct Poly : public vector<int>
{
    int degree() {return (int)size() - 1;}
    void set(int deg) {resize(deg + 1);}
    int val(int x)//单点求值
    {
        int res = 0;
        for(int i = degree() ; ~i ; i--)
            res = (1ll * res * x + this->at(i)) % mod;
        return res;
    }
};

//加法
Poly operator + (Poly a , Poly b)
{
    a.set(max(a.degree() , b.degree()));
    for(int i = 0 ; i <= b.degree() ; i ++) a[i] = (a[i] + b[i]) % mod;
    return a;
}
//减法
Poly operator - (Poly a , Poly b)
{
    a.set(max(a.degree() , b.degree()));
    for(int i = 0 ; i <= b.degree() ; i ++) a[i] = (a[i] - b[i] + mod) % mod;
    return a;
}

//准备备用数组，计算limit
int ntt_prepare(int deg)
{
    int limit = 1;
    while(limit <= deg) limit <<= 1;
    for(int i = 1 ; i < limit ; i++)
    {
        _[i] = _[i >> 1] >> 1;
        if(i&1) _[i] |= (limit >> 1);
    }
    w0[0] = w1[0] = 1;
    int wn = qpow(g , (mod-1) / limit);
    for(int i = 1 ; i < limit ; i++) 
        w0[limit - i] = w1[i] = 1ll * w1[i-1] * wn % mod;
    return limit;
}
//NTT
void NTT(Poly& x , bool type , int limit)
{
    x.set(limit - 1);
    for(int i = 0 ; i < limit ; i ++)
        if(i < _[i]) swap(x[i] , x[_[i]]);
    for(int mid = 1 ; mid < limit ; mid <<= 1)
        for(int j = 0 , i = limit/(2*mid); j < limit ; j += mid*2)
            for(int k = 0 ; k < mid ; k++)
            {
                int a = x[j + k] , b = 1ll * x[j + k + mid] * (type?w1[i*k]:w0[i*k]) % mod;
                x[j + k] = (a + b) % mod;
                x[j + k + mid] = (a - b + mod) % mod;                
            }
    if(type) return ;
    int64 inv = qpow(limit);
    for(int i = 0 ; i < limit ; i ++) x[i] = x[i] * inv % mod;
}
//乘法
Poly operator * (Poly a , Poly b)
{
    if(a.empty()) return a ; if(b.empty()) return b;
    int tot = a.degree()+b.degree();
    int limit = ntt_prepare(tot);
    NTT(a , 1 , limit) , NTT(b , 1 , limit);
    for(int i = 0 ; i < limit ; i ++) a[i] = 1ll*a[i]*b[i]%mod;
    NTT(a , 0 , limit) , a.set(tot);
    return a;
}
}
using namespace SYT_POLY;

const int N = 200020;
int fac[2*N] , ifac[2*N];
void C_init(int len)
{
    fac[0] = 1;
    for(int i = 1 ; i <= len ; i ++) fac[i] = 1ll * fac[i - 1] * i % mod;
    ifac[len] = qpow(fac[len]);
    for(int i = len-1 ; ~i ; i --) ifac[i] = ifac[i + 1] * (i + 1ll) % mod;
}

int C(int x , int y) {
    if(y < 0 || y > x) return 0;
    return 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;
}
inline int read() {
    int x = 0 ; char c = getchar(); bool f = 0;
    while(c < '0' || c > '9') f |= (c=='-') , c = getchar();
    while(c >= '0' && c <= '9') x = x * 10 + (c^48) , c = getchar();
    return f ? -x : x;
}

int n , m , ans;

Poly move(Poly a , int w) {
    if(w > a.degree()) {a.clear() ; return a;}
    for(int i = w ; i <= a.degree() ; ++i)
        a[i - w] = a[i];
    a.set(a.degree() - w);
    return a;
}

//EGF
Poly f[N];
Poly calc(int l , int r) {
    if(l == r) {
        Poly g = f[l];
        for(int i = 0 ; i <= g.degree() ; ++i)
            g[i] = 1LL * g[i] * ifac[i] % mod;
        return g;
    }
    int mid = (l + r) >> 1;
    return calc(l , mid) * calc(mid + 1 , r);
}
inline int sgn(int i) { return (i&1) ? mod - 1 : 1; }

int main() {
    C_init(400010);
    n = read();
    
    for(int i = 1 ; i <= n ; ++i) {
        Poly A , B , &F = f[i];
        A.clear() , B.clear();
        int a = read(); m += a;
        A.set(a) , B.set(a);

        for(int j = 1 ; j <= a ; ++j)
            A[j] = 1LL * fac[j - 1] * C(a + j - 1 , a - j) % mod;
        if(i == 1) {
            for(int j = 1 ; j <= a ; ++j)
                A[j] = 1LL * A[j] * qpow(j) % mod;
        }
        for(int j = 0 ; j <= a ; ++j)
            B[a - j] = 1LL * sgn(j) * ifac[j] % mod;
        F = move(A * B , a);
        for(int j = 1 ; j <= a ; ++j)
            F[j] = 1LL * F[j] * ifac[j - 1] % mod;
        F[0] = 0;
    }
    Poly _2__n = calc(2 , n) , res;
    f[1] = move(f[1] , 1);
    res = calc(1 , 1) * _2__n;
    f[1] = move(f[1] , 1);
    res = res - calc(1 , 1) * _2__n;
    for(int i = 1 ; i <= res.degree() ; ++i)
        ans = (ans + 1LL * res[i] * fac[i]) % mod;
    ans = 1LL * ans * m % mod;
    printf("%d\n" , ans);
    return 0;
}
```

iostream已经有神仙解释了，我还是再复读几句吧。。。


首先考虑如果有$a$个球，划分为$b$段，计算所有方案总贡献？

$$
w(a,b)=\binom{a+b-1}{a-b}
$$

为什么呢？我们在$a$个数中插入$b-1$个板，然后在打上$b$个标记。我们的操作顺序是[标记，板，标记，板]....等价于从$a+b-1$个数里选$2b-1$个数。

我们先考虑一下这个问题的一个简化板，即**在序列上的情况**。

怎么做？~~看标签~~，容斥！

设$b_i$表示每一种颜色选几段，$c_i$表示每一种颜色至少保存几段。

所以答案就是

$$
(\sum\limits_b \sum\limits_c \prod\limits_{i=1}^n w(a_i,b_i) \binom{b_i-1}{c_i-1}(-1)^{b_i-c_i})*\frac{(\sum{c_i})!}{(\sum{c_i!})}
$$

意义就是枚举$b,c$，然后选出至少保存的位置，再乘上容斥系数，最后要乘上多重集排列数。

看到后边的式子，我们不由得想到了`EGF`的卷积。

给每一种颜色来个`EGF`

$$
F_i=\sum\limits_c \frac{x^c}{c!}\sum\limits_bw(a_i,b)\binom{b-1}{c-1}(-1)^{b-c}
$$

可以卷积，分治FFT就可以求原来的答案。

推式子到现在，您的期望得分$\color{red}{0}$.还有两个至关重要的问题尚未解决。

### 1:如何把序列问题迁移到环上？

钦定1号颜色的一段的头部为起始的位置。我们有如下容斥：

EGF(起始位置为1，终止位置任意)-EGF(起始位置，终止位置均为1)

相当于分别钦定了1段，2段为1号颜色.我们把1号颜色的`EGF`分别向左移1，2位就可以了。~~生成函数真是奇妙啊~~


### 2:如何解决重复和漏数的问题？

首先，我们漏数了。题目中要求循环移位算不同方案，所以最终的答案要乘上一个$\sum a$.

然后，我们又数多了。因为如果颜色1出现了$b$次，我们就会多数$b$次，解决方法就是在求$F_1$的时侯，每个$f(a_i,b_i)$中除以个$b_i$就做到了去重。

最后，别忘EGF卷起来后还要乘一个阶乘。这样就OK辣！

---

## 作者：Y_B_X (赞：4)

[原题链接](https://www.luogu.com.cn/problem/P6151)

这里给出一种通法，不依赖于每个颜色段的贡献一定是其长度。

>给定出 $t$ 种颜色，每种有 $c_i$ 个，$\displaystyle n=\sum_{i=1}^tc_i$   
现在将一个长度为 $n$ 的序列染色，首尾相接形成一个环。  
对于一个环的所有极长连续颜色段 $l_1,l_2\cdots l_s$ 定义权值为 $\displaystyle \prod_{i=1}^sf(l_i)$  
求每种染色方案的权值之和，注意两种方案不同由染成的序列决定。  

## $\text{Step 1}$

由于极长连续段不好处理，考虑相同的一段当成几段来算的方案。

设这样算一个相同颜色段长度为 $l$ 时计入的是 $a_l$，设 $\displaystyle A(x)=\sum_{n\geq 1}a_nx^n$。

那 $\displaystyle \sum_{k\geq 1}\sum_{\sum\limits_{i=1}^kn_i=l}\prod_{i=1}^{k}a_{n_i}=f(l)$，第一个 $k$ 枚举分成几段，后面的 $n_i$ 代表分成的每一段。

由于是排成一段，所以这里要**区分先后**的 $n_i$ 枚举顺序。

对两边关于 $l$ 生成有 $\displaystyle \sum_{k\geq 1}A^k(x)=\sum_{l\geq 1}f(l)x^l$，所以 $\dfrac{A(x)}{1-A(x)}=F(x)$

接下来先对每个颜色单独考虑，之后再想如何合并。

设该颜色为 $p,m\!=\!c_{p}$

## $\text{Step 2.1}$

先考虑一个序列而非环。

设这个颜色颜色被分成了 $k$ 段，这 $k$ 个部分**不区分先后顺序**。

那贡献就是 $\dfrac{\left[x^m\right]A^k(x)}{k!}$，后面除的阶乘就是不区分顺序。

再设 $\displaystyle F_P(x)=\sum_{k\geq 1}\dfrac{\left[x^m\right]A^{k}(x)}{k!}y^k$，可以理解为关于段数的 $\text{OGF}$。

关于段数是为了最终每一段的顺序区分，而一个颜色段的内部标号必定连续，只需涉及 $\text{OGF}$ 。

## $\text{Step 2.2}$

现在再考虑环。

钦定环起始的第一段是该颜色 $p$ 的段，长度为 $l$。

那这个环就能被算入 $l$ 次。

除了开头的第一段，而其他段依然**不区分先后顺序**。

因此这个颜色有 $k$ 段时贡献是 $\dfrac{\left[x^m\right]A^{k-1}(x)\ xA'(x)}{(k-1)!}$。

可以理解为先算第一个段，$xA'(x)$ 就是对应系数乘了 $l$，后面 $k\!-\!1$ 段仍要除去顺序。

尝试化简一下上式的取系数：

$$\left[x^m\right]A^{k-1}(x)\ xA'(x)=\left[x^{m-1}\right]\dfrac{1}{k}\left(A^{k}(x)\right)'=\dfrac{m}{k}\left[x^m\right]A^k(x)$$

此时以颜色 $p$ 为起始，环上的 $\text{OGF}$ 设为 $\displaystyle T_p(x)=\sum_{k\geq 1}\dfrac{\left[x^m\right]A^{k-1}(x)\ xA'(x)}{(k-1)!}y^k$。

代入上面的化简得到 $\displaystyle T_p(x)=\sum_{k\geq 1}\dfrac{\left[x^m\right]A^k(x)}{(k-1)!}\dfrac{m}{k}y^k=m\sum_{k\geq 1}\left[x^m\right]A^k(x)\dfrac{y^k}{k!}=mF_p(x)$

## $\text{Step 3}$

先在需要把所有的颜色拼起来。

这样设 $g_i$ 为转化后（每一段不一定是极长颜色段）一共有 $i$ 段的权值之和。

先不考虑颜色段的排列，那有 $\displaystyle G(x)=\sum_{i=1}^tT_i(x)\prod_{1\leq j\leq t,i\neq j}F_j(x)$

所以 $\displaystyle G(x)=\prod_{i=1}^tF_j(x)\left(\sum_{i=1}^tc_i\right)=n\prod_{i=1}^tF_j(x)$。

可以理解为 $i$ 这个颜色独占环的起始位置，后面的颜色变成序列上的。

但是这些组成的段还可以各自交换，成为一个环排列的个数。

所以答案是 $\displaystyle \sum_{i=1}^n(i-1)!\left[x^i\right]G(x)$

## $\text{Step 4}$

这部分着重讲述如何实现。

在求出了 $F_p(x)$ 之后只需分治 $\text{NTT}$ 即可求出 $G(x)$。

而为了求 $F_p(x)$ 需要对 $k\!=1,\cdots ,n$ 知道 $\left[x^n \right]A^k(x)$。

通过拉格朗日反演得到：

$$\left[x^n\right]A^k(x)\!=\!\dfrac{1}{n}\left[x^{n-1}\right]kx^{k-1}\left(\dfrac{x}{B(x)}\right)^n=\dfrac{k}{n}\left[x^{n-k}\right]\left(\dfrac{x}{B(x)}\right)^n$$

其中 $B(A(x))\!=\!x$，即 $A(x)$ 的复合逆。

一般情况下通过之前推导的 $\dfrac{A(x)}{1-A(x)}=F(x)$，即可算出 $B(x)$。

回到本题中，$\displaystyle f_l=l,F(x)=\sum_{l\geq 1}lx^l=\dfrac{x}{(1-x)^2}$

所以 $\dfrac{A(x)}{1-A(x)}=\dfrac{x}{(1-x)^2}$，因此 $\dfrac{x}{1-x}=\dfrac{B(x)}{(1-B(x))^2}$

化简一下有 $x+xB(x)^2=B(x)-xB(x)$，已经能分治 $\text{FFT}$ 求了。

具体来说可以设 $B(x)=xC(x)$，有 $\displaystyle \sum_{i=0}^nc_ic_{n-i}=c_{n+1}+c_{n+2},c_0=1$

于是可以在 $O(n\log^2n)$ 的时间内解决本题，瓶颈在于分治 $\text{FFT}$ 以及分治 $\text{NTT}$。

注意到 $F_p(x)$ 常数项为 $0$，所以可以先计算 $\dfrac{F_p(x)}{x}$ 能省一定时间，也方便写。

代码：（仅供参考,~~实际提交的代码比这份优化多多了~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;
const int mod=998244353;
const int inv2=(mod+1)/2;
char ch;int T,ans;
int n,k,m,nn,n_,x,y,res,wn,v;
int n1;int invn,w,lgn;
int nt[N],a[N],b[N],f[N],c[N];
int rev[N],inv[N],fac[N],ifac[N];
int invt[N],lnt[N],expt[N];
int cdqa[N],cdqb[N],ab[N];
int *q[N],_q[N<<1],*qq=_q;
int *t[N<<1],_t[N<<4],*tt=_t,len[N<<1];
int *pf[20],_pf[N<<1],*ppf=_pf;
inline void read(int &x){
	x=0;ch=getchar();while(ch<47)ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x>9)write(x/10);putchar(48|x%10);}
inline void swap(int &x,int &y){x^=y^=x^=y;}
void qpow(int x,int k){
	res=1;
	while(k){
		if(k&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;k>>=1;
	}
}
void getinv(int n){
	register int i;inv[0]=inv[1]=1;
	for(i=2;i^n;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
}
void getfac(int n){
	register int i;
	for(ifac[0]=1,i=1;i^n;++i)ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	for(fac[0]=1,i=1;i^n;++i)fac[i]=1ll*fac[i-1]*i%mod;
}
void getrev(int n){
	static int i;
	n1=1;while(n1<(n<<1))n1<<=1;w=n1>>1;
	for(i=0;i^n1;++i)rev[i]=(rev[i>>1]>>1)|((i&1)?w:0);
}
void ntt_init(int n){
	register int i,mid,j;n<<=1;
	for(mid=1;mid<n;mid<<=1){
		qpow(3,(mod-1)/(mid<<1));
		wn=res;nt[mid]=1;j=(mid<<1);
		for(i=mid+1;i<j;++i)nt[i]=1ll*nt[i-1]*wn%mod;
	}
}
inline int add(int x,int y){return x+y>mod?x+y-mod:x+y;}
inline int sub(int x,int y){return x>y?x-y:x-y+mod;}
void ntt(int n,int *a,bool t){
	static int i,mid,j,k;
	for(i=0;i^n;++i)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(mid=1;mid<n;mid<<=1){
		for(j=0;j<n;j+=(mid<<1)){
			for(k=0;k<mid;++k){
				y=1ll*nt[mid+k]*a[j+k+mid]%mod;
				a[j+k+mid]=sub(a[j+k],y);
				a[j+k]=add(a[j+k],y);
			}
		}
	}
	if(t){
		invn=n+1>>1;for(i=1;i^invn;++i)swap(a[i],a[n-i]);
		for(invn=inv[n],i=0;i^n;++i)a[i]=1ll*a[i]*invn%mod;
	}
}
void polyinv(int n,int *f,int *g){
	static int i;
	if(n==1)qpow(f[0],mod-2),g[0]=res;
	else {
		polyinv(n+1>>1,f,g);
		getrev(n);
		for(i=0;i^n;++i)invt[i]=f[i];
		for(i=n;i^n1;++i)invt[i]=0;
		ntt(n1,invt,0);ntt(n1,g,0);
		for(i=0;i^n1;++i)g[i]=1ll*sub(2,1ll*invt[i]*g[i]%mod)*g[i]%mod;
		ntt(n1,g,1);for(i=n;i^n1;++i)g[i]=0;
	}
}
void polyln(int n,int *f,int *g){
	static int i;
	getrev(n);
	for(i=0;i^n;++i)lnt[i]=f[i],g[i]=0;
	for(i=n;i^n1;++i)lnt[i]=g[i]=0;
	polyinv(n,f,g);lnt[n-1]=0;
	for(i=0;i<n;++i)lnt[i-1]=1ll*f[i]*i%mod;
	ntt(n1,g,0);ntt(n1,lnt,0);
	for(i=0;i<n1;++i)lnt[i]=1ll*lnt[i]*g[i]%mod;
	ntt(n1,lnt,1);g[0]=0;
	for(i=1;i<n;++i)g[i]=1ll*lnt[i-1]*inv[i]%mod;
	for(i=n;i<n1;++i)g[i]=0;
}
void polyexp(int n,int *f,int *g){
	static int i;
	if(n==1)g[0]=1;
	else {
		polyexp(n+1>>1,f,g);
		polyln(n,g,expt);
		for(i=0;i<n;++i)expt[i]=sub(f[i],expt[i]);
		expt[0]=add(expt[0],1);
		ntt(n1,g,0);
		ntt(n1,expt,0);
		for(i=0;i<n1;++i)g[i]=1ll*g[i]*expt[i]%mod;
		ntt(n1,g,1);
		for(i=n;i<n1;++i)g[i]=0;
	}
}
void cdq(int l,int r,int d){
	static int i,n;
	if(l+1^r){
		int mid=(l+r)>>1;
		cdq(l,mid,d-1);
		n=r-l;
		if(l){
			for(i=l;i^mid;++i)cdqa[i-l]=f[i];
			for(i=0;i^n;++i)cdqb[i]=f[i];
			getrev(n>>1);ntt(n1,cdqa,0);ntt(n1,cdqb,0);
			for(i=0;i^n;++i)cdqa[i]=1ll*cdqa[i]*cdqb[i]%mod;
			ntt(n1,cdqa,1);
			for(i=mid;i^r;++i)f[i+1]=add(f[i+1],cdqa[i-l-1]*2%mod);
			for(i=0;i^n;++i)cdqa[i]=cdqb[i]=0;
		}
		else {
			for(i=0;i^mid;++i)cdqa[i]=cdqb[i]=f[i];
			getrev(n>>1);
			ntt(n1,cdqa,0);ntt(n1,cdqb,0);
			for(i=0;i^n;++i)cdqa[i]=1ll*cdqa[i]*cdqb[i]%mod;
			ntt(n1,cdqa,1);
			for(i=mid;i^r;++i)f[i+1]=add(f[i+1],cdqa[i-1]);
			for(i=0;i^n;++i)cdqa[i]=cdqb[i]=0;
		}
		cdq(mid,r,d-1);
	}
	else if(l)f[l]=sub(f[l],f[l-1]);
}
void work(int j){
	static int i;
	nn=c[j];q[j]=qq,qq+=nn;
	for(i=0;i^nn;++i)a[i]=1ll*f[i]*nn%mod;
	polyexp(nn,a,b);
	w=inv[nn];
	for(i=0;i^nn;++i)q[j][i]=1ll*b[nn-i-1]*ifac[i]%mod*w%mod;
	for(i=0;i^nn;++i)a[i]=b[i]=0;
}
#define ls k<<1
#define rs k<<1|1
void pre_solve(int l,int r,int k){
	if(l^r){
		int mid=(l+r)>>1;
		len[k]=b[r]-b[l-1]+1;
		t[k]=tt,tt+=len[k];
		pre_solve(l,mid,ls);
		pre_solve(mid+1,r,rs);
	}
	else t[k]=q[l],len[k]=b[l]-b[l-1]+1;
}
void solve(int l,int r,int k){
	if(l^r){
		static int i;
		int mid=(l+r)>>1;
		solve(l,mid,ls);
		solve(mid+1,r,rs);
		for(i=0;i^len[ls];++i)a[i]=t[ls][i];
		for(i=0;i^len[rs];++i)b[i]=t[rs][i];
		getrev(len[k]+1>>1);
		ntt(n1,a,0);ntt(n1,b,0);
		for(i=0;i^n1;++i)a[i]=1ll*a[i]*b[i]%mod,b[i]=0;
		ntt(n1,a,1);for(i=len[k];i^n1;++i)a[i]=0;
		for(i=0;i^len[k];++i)t[k][i]=a[i];
		for(i=0;i^len[k];++i)a[i]=b[i]=0;
	}
}
main(){
	read(m);register int i;
	for(i=1;i<=m;++i)read(c[i]),n+=c[i];
	getinv(n<<2);ntt_init(n<<1);
	n=0;for(i=1;i<=m;++i)n=max(n,c[i]);
	nn=1;lgn=0;while(nn<n)nn<<=1,++lgn;
	f[0]=1;cdq(0,nn,lgn);
	for(i=n;i^nn;++i)f[i]=0;
	polyln(n,f,a);
	f[0]=0;for(i=1;i^n;++i)f[i]=sub(0,a[i]),a[i]=0;
	n=0;for(i=1;i<=m;++i)n+=c[i];getfac(n);
	for(i=1;i<=m;++i)work(i);
	for(i=1;i<=m;++i)b[i]=c[i]-1,b[i]+=b[i-1];
	pre_solve(1,m,1);
	for(i=0;i<=n;++i)a[i]=b[i]=0;
	solve(1,m,1);
	for(i=m;i<=n;++i)ans=add(ans,1ll*_t[i-m]*fac[i-1]%mod);
	write(1ll*ans*n%mod);
}
```

---


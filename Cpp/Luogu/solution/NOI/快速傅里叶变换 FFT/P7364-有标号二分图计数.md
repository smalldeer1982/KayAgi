# 有标号二分图计数

## 题目描述

求 $n$ 个点的有标号二分图数目。对每个 $1\le n\le 10^5$ 求出答案。

对 $998244353$ 取模。

## 样例 #1

### 输入

```
没有输入。```

### 输出

```
答案的前八行：
1
2
7
41
376
5177
103237
2922446```

# 题解

## 作者：wlzhouzhuan (赞：12)

设有标号二分连通图的 $\text{EGF}$ 为 $F(x)$ ，有标号二分图的 $\text{EGF}$ 为 $G(x)$ ，则：

$$G(x)=\sum\limits_{i}\frac{F^i(x)}{i!}=e^{F(x)}$$

发现 $F(x)$ 并不好求。令二分染色图的 $\text{EGF}$ 为 $H(x)$ ，则 $h_n=\sum\limits_{i=0}^{n} \binom{n}{i} 2^{i(n-i)}$ 。

给每个连通图的一个点钦定一个颜色，则该连通图所有点颜色确定，于是：

$$H(x)=\sum\limits_{i}\frac{2^iF^i(x)}{i!}=e^{2F(x)}$$

发现 $G(x)=\sqrt{H(x)}$ ，而 

$$h_n=n!2^{\binom{n}{2}}\sum\limits_{i=0}^{n}\frac{1}{i!2^{\binom{i}{2}}}\frac{1}{(n-i)!2^{\binom{n-i}{2}}}$$

不难通过卷积得到 $H(x)$ 。

时间复杂度 $O(nlogn)$ 。

---

## 作者：jun头吉吉 (赞：8)

## 题意
求 $n$ 个点的有标号二分图数目。
## 题解

有个很 $\rm Naive$ 的想法，求下面这个式子：
$$\sum_{i=0}^n\binom{n}{i}2^{i(n-i)}$$
理解十分容易，先钦定 $i$ 个到左边，左边和右边连边。

为什么 $\rm Naive$ 呢，就是因为这个式子实在没什么用。来仔细思考一波：对于一个二分图中的联通块，这个式子会计算两遍，钦定的放左边算一遍， 放右边又算一遍。但是二分图是没有左右之分的。

上面的东西可能理解为黑白染色更恰当。

来考虑上面的黑白染色 $\bf EGF$ 为 $F(x)$，最终答案的 $\bf EGF$ $G(x)$，不难发现：
$$G(x)\times G(x)=F(x)\tag{1}$$
考虑一般二分图的类 $\mathcal G$，记 $\mathcal G^{\bullet}$ 为钦定了每个联通块最小的节点为黑色的类， $\mathcal G^{\circ}$ 为钦定了最小的为白色的类，那么就可以认为 $\mathcal G^\bullet\times \mathcal G^\circ=\mathcal F$。一个染色方案必然是若干个联通块最小为白色和若干个联通块最小为黑色。因此上面的柿子是成立的。

翻译成 $\bf EGF$ 就是 $(1)$ 了。

现在只要会求 $F(x)$ 就做完了。

$F(x)$ 的求法很多，这里写个比较不需要思考的：
$$\begin{aligned}
f_n&=n!\sum_{i=0}^n\frac1{i!(n-i)!}2^{\binom{n}2-\binom{n-i}2-\binom{i}2}\\
&=n!2^{\binom{n}2}\sum_{i=0}^n\frac1{2^{\binom i2}i!}\times\frac1{2^\binom{n-i}2(n-i)!}
\end{aligned}$$
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
    modint<mod> &operator++(int){return *this+=1;}
};
const int N=4e6+5;

const int mod=998244353;
const modint<mod> GG=3,Ginv=modint<mod>(1)/3,I=86583718;
struct poly{
    vector<modint<mod>>a;
    modint<mod>&operator[](int i){return a[i];}
    int size(){return a.size();}
    void resize(int n){a.resize(n);}
    void reverse(){std::reverse(a.begin(),a.end());}
    void print(){for(auto x:a)printf("%d ",x);puts("");}
};
int rev[N];
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){int n=1<<k;for(int i=0;i<n;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));}
inline void ntt(poly&a,int k,int typ){
    int n=1<<k;
    for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
    for(int mid=1;mid<n;mid<<=1){
        modint<mod> wn=(typ>0?GG:Ginv)^((mod-1)/(mid<<1));
        for(int r=mid<<1,j=0;j<n;j+=r){
            modint<mod> w=1;
            for(int k=0;k<mid;k++,w=w*wn){
                modint<mod> x=a[j+k],y=w*a[j+k+mid];
                a[j+k]=x+y,a[j+k+mid]=x-y;
            }
        }
    }
    if(typ<0){
        modint<mod> inv=modint<mod>(1)/n;
        for(int i=0;i<n;i++)a[i]*=inv;
    }
}
inline poly one(){poly a;a.a.push_back(1);return a;}
poly operator +(poly a,poly b){
    int n=max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a[i]+=b[i];return a;
}
poly operator -(poly a,poly b){
    int n=max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a[i]-=b[i];return a;
}
inline poly operator*(poly a,poly b){
    int n=a.size()+b.size()-1,k=ext(n);
    a.resize(1<<k),b.resize(1<<k),init(k);
    ntt(a,k,1);ntt(b,k,1);for(int i=0;i<(1<<k);i++)a[i]*=b[i];
    ntt(a,k,-1),a.resize(n);return a;
}
inline poly operator*(poly a,modint<mod> b){for(int i=0;i<a.size();i++)a[i]*=b;return a; }
inline poly operator/(poly a,modint<mod> b){for(int i=0;i<a.size();i++)a[i]/=b;return a; }
inline poly operator-(poly a){for(int i=0;i<a.size();i++)a[i]=-a[i];return a; }
poly inv(poly F,int k){
    int n=1<<k;F.resize(n);
    if(n==1){F[0]=modint<mod>(1)/F[0];return F;}
    poly G,H=inv(F,k-1);
    G.resize(n),H.resize(n<<1),F.resize(n<<1);
    for(int i=0;i<n/2;i++)G[i]=H[i]*2;
    init(k+1),ntt(H,k+1,1),ntt(F,k+1,1);
    for(int i=0;i<(n<<1);i++)H[i]=H[i]*H[i]*F[i];
    ntt(H,k+1,-1),H.resize(n);
    for(int i=0;i<n;i++)G[i]-=H[i];return G;
}
inline poly inv(poly a){
    int n=a.size();
    a=inv(a,ext(n)),a.resize(n);return a;;
}
inline poly deriv(poly a){//姹傚 
    int n=a.size()-1;
    for(int i=0;i<n;i++)a[i]=a[i+1]*(i+1);
    a.resize(n);return a;
}
inline poly inter(poly a){//姹傚師 
    int n=a.size()+1;a.resize(n);
    for(int i=n;i>=1;i--)a[i]=a[i-1]/i;
    a[0]=0;return a;
}
poly sqrt(poly F,int k){
    int n=1<<k;F.resize(n);
    if(n==1){F[0]=1;return F;}
    poly G,H=sqrt(F,k-1);
    H.resize(n);init(k);poly invH=inv(H);
    G.resize(n),H.resize(n<<1),F.resize(n<<1);
    init(k+1),ntt(H,k+1,1);
    for(int i=0;i<(n<<1);i++)H[i]=H[i]*H[i];
    ntt(H,k+1,-1),H.resize(n);
    for(int i=0;i<n;i++)G[i]=H[i]+F[i];
    G=G*invH;G.resize(n);for(int i=0;i<n;i++)G[i]/=2;
    return G;
}
inline poly sqrt(poly a){
    int n=a.size();
    a=sqrt(a,ext(n)),a.resize(n);return a;;
}
typedef modint<mod> mint;
#define C2(n) (1ll*n*(n-1)/2)%(mod-1)
mint fac[N];
mint ifac[N];
signed main(){
	fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i;
	ifac[N-1]=1/fac[N-1];for(int i=N-1;i;i--)ifac[i-1]=ifac[i]*i;
	int n=1e5+1;
	poly F;F.resize(n);
	for(int i=0;i<n;i++)F[i]=ifac[i]/(mint(2)^C2(i));
	F=F*F;
	F.resize(n);
	//F.print();
	for(int i=0;i<n;i++)F[i]*=(mint(2)^C2(i));
	//F.print();
	poly G=sqrt(F);
	for(int i=1;i<n;i++)printf("%d\n",G[i]*fac[i]);
}
```

---

## 作者：_lbw_ (赞：5)

二分图，联想到二分图染色。

而一半二分图染色方案数难以构成一个映射，考虑有标号连通二分图计数。

而设有标号二分图 EGF 为 $F(z)$，有标号**连通**二分图 EGF 为 $G(z)$，则显然有：

$$e^G=F$$

接下来考虑求有标号连通图二分图染色 EGF $H(z)$，显然的，$G(z)$ 每一项为 $H(z)$ 的一半，因为只要确定了 1 的颜色就唯一的对应了一种连通图二分图染色。

我们发现 $H$ 不好求，因为有连通的限制，直接枚举左右部点两边可能会不连通。

而我们假设不一定要连通的有标号二分图染色 $H'(z)$，它是容易的，枚举左部点个数 $i$，则右部点个数 $n-i$。

$$[z^n]H'(z)=\sum\limits_{i=0}^n \binom{n}{i}2^{i(n-i)}$$

使用经典套路 $i(n-i)=\dbinom n2-\dbinom i2-\dbinom{n-i}2$，也就是说设 $L(z)=\sum\limits_{i=0}^n \dfrac1{2^\binom i2z^ii!}$，求出 $L^2$ 后容易计算答案。

最后再应用 $\ln H'=H,\dfrac{[z^i]H}2=[z^i]G,e^G=F$ 即可。

---

## 作者：SAMSHAWCRAFT (赞：5)

有标号二分图计数：求 $n$ 个点的有标号二分图数量。

分享一下我的思路以及纠错过程。

对于这种数据范围的图计数我们一般考虑生成函数做法，对于有标号的计数问题我们用指数型生成函数（EGF）求解。设 $f_i$ 表示有 $i$ 个点的有标号二分图数量，对应的 EGF 为 $F(x)$，$f_n$ 就是我们要的答案。一个二分图是由若干个二分连通图组成的，由此我们将求解 $f_i$ 的问题划归到求二分连通图的数量，设 $g_i$ 表示有 $i$ 个点的有标号二分连通图数量，对应的 EGF 为 $G(x)$。因为二分连通图是二分图的组成部分，所以有 
$$F(x)=e^{G(x)}$$

关于多项式指数函数的组合意义，如果不明白的话我这里有三个例子大家可以自己体会一下，假设 $F(x)$ 是一个大小为 $i$ 的盒子内部分配方案数的 EGF，即 $F(x)$ 的 $x^i$ 项系数除以 $i!$ 表示大小为 $i$ 的盒子内部物品分配方案数，那么有：

1. ${F^i(x)}$ 是将有标号物品分配到 $i$ 个有标号盒子的方案数的 EGF
  
2. $\frac {F^i(x)}{i!}$ 是将有标号物品分配到 $i$ 个无标号盒子的方案数的 EGF
  
3. $\sum_{i=0}^{\infty} \frac{F^i(x)}{i!}$ 是将有标号物品分配到任意数量的无标号盒子的方案数的 EGF，同时还相当于取出问题的组成部分，比如仙人掌森林的组成部分是仙人掌，二分图的组成部分是二分连通图（当然也可以选取其他组成部分，只要方便计数就好）。
  

由指数函数的麦克劳林展开我们可以知道 
$$\sum_{i=0}^{\infty} \frac{F^i(x)}{i!}=e^{F(x)}$$

回到本题，如何求 $G(x)$ 呢？我们思考二分连通图有何性质，首先想到的应该就是染色，给二分连通图中一个点染黑色或白色，整个二分连通图的染色方式就唯一确定下来；其次想到的就是二分图可以分为左右两个部分，左半部分的任意两点没有连边，右半部分任意两点没有连边，由此可以想到如何数染色二分图的数量，记 $h'_i$ 为 $i$ 个点的染色二分连通图数量，对应的 EGF 是 $H'(x)$，不难知道 

$$h'_i=\sum_{k=0}^i \binom {i}{k}2^{k(i-k)}$$

即选出图中 $k$ 个点，把这些点都放在左半，剩余的放在右半。这是我一开始的错误的 naive 的想法，这里遗留的一个问题我们之后处理，先继续推 $H(x)$ 和 $F(x)$ 的关系（这里给 $h_i$ 和 $H(x)$ 加一撇是为了区分错解和正解）。

给一个二分图的每个连通块染色，每个块都有两种染色方法，因此枚举二分图连通块个数，有 
$$H(x)=\sum_{i}\frac{2^iG^i(x)}{i!}=\sum_{i}\frac{(2G(x))^i}{i!}=e^{2G(x)}$$

得到 $F(x)=e^{G(x)}=\sqrt {e^{2G(x)}}=\sqrt {H(x)}$。多项式开根即可。

等等，刚刚的 $H'(x)$ 是不是有问题？二分图左右是分开了，但是连边呢？标号呢？所以我们需要重新推导一下 $H(x)$。

$H(x)$ 的推导：排列 $i$ 个点有 $i!$ 种方法，在图中任意连边有 $2^\binom{i}{2}$ 种方法，为了让图变成二分图，要让左右两边内部没有连边，因此再乘一个 $\sum_{k=0}^{i}\frac{1}{k!2^\binom{k}{2}}\frac{1}{(i-k)!2^\binom{i-k}{2}}$，最终推导出实际的表达式：

$$h_i=i!2^\binom{i}{2}\sum_{k=0}^{i}\frac{1}{k!2^\binom{k}{2}}\frac{1}{(i-k)!2^\binom{i-k}{2}}$$

参考代码（代码中的 F 数组对应上文 $H(x)$，G 数组对应上文 $F(x)$）：

```cpp
#include <stdio.h>
#include <algorithm>
#include <vector>
#define qaq inline
const int sz=8.3e5+19;
int lim,limbit,revid[sz];
using ll=long long;
template<int mod=998244353>struct fp{
  int v; static int get_mod(){ return mod; }
  int inv()const{
    int tmp,a=v,b=mod,x=1,y=0;
    while(b) tmp=a/b,a-=tmp*b,std::swap(a,b),x-=tmp*y,std::swap(x,y);
    if(x<0) x+=mod;
    return x;
  }
  qaq fp(ll x=0){ init(x%mod+mod); }
  qaq fp& init(int x){ v=(x<mod?x:x-mod); return *this; }
  qaq fp operator-()const{ return fp()-*this; }
  fp pow(ll t)const{ fp res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;} return res; }
  fp unitrt(int l)const{ return pow((mod-1)/l); }
  qaq fp& operator+=(const fp& x){ return init(v+x.v); }
  qaq fp& operator-=(const fp& x){ return init(v-x.v+mod); }
  qaq fp& operator*=(const fp& x){ v=ll(v)*x.v%mod; return *this; }
  qaq fp& operator/=(const fp& x){ v=ll(v)*x.inv()%mod; return *this; }
  qaq fp operator+(const fp& x)const{ return fp(*this)+=x; }
  qaq fp operator-(const fp& x)const{ return fp(*this)-=x; }
  qaq fp operator*(const fp& x)const{ return fp(*this)*=x; }
  qaq fp operator/(const fp& x)const{ return fp(*this)/=x; }
  bool operator==(const fp& x){ return v==x.v; }
  bool operator!=(const fp& x){ return v!=x.v; }
};
using Fp=fp<>;
template<int Cap=sz+2>struct Factorial{
  std::vector<Fp> fac,invfac;
  void init(int cap=Cap){
    fac.resize(cap+1),invfac.resize(cap+1);
    fac[0]=1;
    for(int cx=1;cx<=cap;++cx) fac[cx]=fac[cx-1]*cx;
    invfac[cap]=fac[cap].inv();
    for(int cx=cap;cx!=0;--cx) invfac[cx-1]=invfac[cx]*cx;
  }
  Fp A(int n,int r){
    if(n<0||r<0||n<r) return 0;
    return fac[n]*invfac[n-r];
  }
  Fp C(int n,int r){
    if(n<0||r<0||n<r) return 0;
    return fac[n]*invfac[r]*invfac[n-r];
  }
  Fp H(int n,int r){ return C(n+r-1,r); }
  Fp fact(int n,bool sign=true){ return sign?fac[n]:invfac[n]; }
};
Factorial<> Qf;
const Fp g=Fp(3),invg=Fp(g.inv());
void NTT(int limit,Fp *arr,int sign){
  for(int cx=0;cx<limit;++cx)
    if(cx<revid[cx]) std::swap(arr[cx],arr[revid[cx]]);
  for(int l=2;l<=limit;l<<=1){
    Fp Wn=((sign==1)?g:invg).unitrt(l);
    for(int cx=0;cx<limit;cx+=l){
      Fp w=1;
      for(int cy=0;cy<(l>>1);++cy,w*=Wn){
        Fp tmp1=arr[cx+cy],tmp2=arr[cx+cy+(l>>1)]*w;
        arr[cx+cy]=tmp1+tmp2,arr[cx+cy+(l>>1)]=tmp1-tmp2;
      }
    }
  }
  if(sign==-1){
    int invlim=Fp(limit).inv();
    for(int cx=0;cx<limit;++cx)
      arr[cx]*=invlim;
  }
}
void polydiff(int n,Fp *f,Fp *g){
  for(int cx=1;cx<n;++cx)
    g[cx-1]=f[cx]*cx;
  g[n-1]=0;
}
void polyinteg(int n,Fp *f,Fp *g){
  for(int cx=1;cx<n;++cx)
    g[cx]=f[cx-1]/cx;
  g[0]=0;
}
void polyinv(int n,Fp *f,Fp *g){
  static Fp c[sz];
  if(n==1){
    g[0]=f[0].inv();
    return;
  }
  polyinv((n+1)>>1,f,g);
  for(lim=1,limbit=0;lim<n*2;lim<<=1,++limbit);
  for(int cx=1;cx<lim;++cx)
    revid[cx]=(revid[cx>>1]>>1)|((cx&1)<<(limbit-1));
  for(int cx=0;cx<n;++cx) c[cx]=f[cx];
  for(int cx=n;cx<lim;++cx) c[cx]=0;
  NTT(lim,g,1),NTT(lim,c,1);
  for(int cx=0;cx<lim;++cx)
    g[cx]=(-g[cx]*c[cx]+2)*g[cx];
  NTT(lim,g,-1);
  for(int cx=n;cx<lim;++cx) g[cx]=0;
}
void polysqrt(int n,Fp *f,Fp *g){
  static Fp ig[sz],c[sz];
  if(n==1){
    g[0]=1;
    return;
  }
  polysqrt((n+1)>>1,f,g);
  std::fill(ig,ig+sz,0);
  polyinv(n,g,ig);
  for(lim=1,limbit=0;lim<(n<<1);lim<<=1,++limbit);
  for(int cx=1;cx<lim;++cx)
    revid[cx]=(revid[cx>>1]>>1)|((cx&1)<<(limbit-1));
  for(int cx=0;cx<n;++cx) c[cx]=f[cx];
  for(int cx=n;cx<lim;++cx) c[cx]=0;
  NTT(lim,ig,1),NTT(lim,c,1),NTT(lim,g,1);
  for(int cx=0,inv2=Fp(2).inv();cx<lim;++cx)
    g[cx]=(ig[cx]*c[cx]+g[cx])*inv2;
  NTT(lim,g,-1);
  for(int cx=n;cx<lim;++cx)
    g[cx]=0;
}
int n=100001;
Fp F[sz],G[sz];
int main(){
  Qf.init(n+1);
  for(int cx=0;cx<n;++cx)
    F[cx]=Qf.fact(cx,false)/Fp(2).pow(1LL*(cx)*(cx-1)/2%998244352);
  for(lim=1,limbit=0;lim<n*2;lim<<=1,++limbit);
  for(int cx=1;cx<lim;++cx)
    revid[cx]=(revid[cx>>1]>>1)|((cx&1)<<(limbit-1));
  NTT(lim,F,1);
  for(int cx=0;cx<lim;++cx)
    F[cx]=F[cx]*F[cx];
  NTT(lim,F,-1);
  for(int cx=0;cx<n;++cx)
    F[cx]*=Fp(2).pow(1LL*cx*(cx-1)/2%998244352);
  polysqrt(n,F,G);
  for(int cx=1;cx<n;++cx)
    printf("%d\n",G[cx]*Qf.fact(cx));
  return 0;
}
```

---

## 作者：ღꦿ࿐ (赞：2)

在[我的博客](https://www.cnblogs.com/Dreamerkk/p/17141530.html)查看。

本文中  $f[i]$ 表示 $[x^i]f(x)$

带标号的二分图的数量不方便用一个式子直接写出，我们考虑用别的统计去推出它。
 
我们先求出连通二分图的生成函数，再求任意二分图的生成函数。
 
二分图想到黑白染色，二分图黑白染色的方案是好得到的：令 $f(x)$ 表示所有 $n$ 个点的图的的黑白染色方案之和的生成函数，则有 

$$
f[n]=\sum_{i=0}^{n} \binom ni\times2^{i(n-i)}
$$

稍微转化一下。

$$
\dfrac {f[n]} {2^{n^2/2} \times n!}=\sum_{i=0}^{n} \dfrac 1 {i!(n-i)!\times2^{i^2/2}\times2^{(n-i)^2/2}}
$$


就是加法卷积的形式了。

当一个二分图连通时，其黑白染色的方案等于 $2$，所以找到连通二分图的黑白染色的生成函数就形了。



连通图——任意图 是一种典型的“集合——集族”关系，它们的指数生成函数满足以下关系：

其中任意图的指数生成函数为 $g(x)$，连通图的为 $f(x)$

$$\operatorname{Exp}(f(x))=g(x)$$

做一次多项式 $\operatorname{ln}$ 再对每一项除二得到二分连通图的指数生成函数，再使用“集合——集族”关系 $\operatorname{Exp}$ 回去即可。

会发现上述过程等价于给 $g(x)$ 开根，直接开根有更优秀的常数，时间复杂度都是 $O(n\log n)$。


主要部分（因为我没想到对 $2$ 的指数做一些很妙的转化，就直接用了二次剩余来处理除二的问题。其中 $b^2=2$ ）：

```
n=1e5;
rep(i,0,n) f[i] = math::finv[i] * math::Pow(b,(ll)i*i%(mod-1)*(mod-2)) % mod ;
poly::work(n+n);
poly::NTT(f);
poly::pmul(f,f,f);
poly::iNTT(f);
poly::mem(f+n+1,poly::L-n);
rep(i,0,n) f[i]=(ll)f[i] * math::Pow(b,(ll)i*i) % mod;
poly::ln(f,n,g);
poly::nummul(g,n,i2,g);
poly::exp(g,n,f);
rep(i,1,n) wrt(f[i] * math::fac[i] % mod,'\n');

```



[完整代码](https://www.luogu.com.cn/paste/fpgxfedm)





---

## 作者：_abcd_ (赞：2)

## [[P7364] 有标号二分图计数](https://www.luogu.com.cn/problem/P7364)

有一个想法是：将图黑白染色，并在黑白点间两两连点。

不难发现这种做法显然是错的，当存在 $i$ 个连通块时，这个情况将会被重复算 $2^i$ 次。不妨钦定图连通。设 $g_i = \sum\limits_{j=0}^i C_i^j 2^{j(i-j)}$，即将图染色并连点的方案数，那么就有

$$f_i = g_i - \sum\limits_{j=1}^{i-1} C_{i-1}^{j-1} f_j g_{i-j}$$

意为枚举 $1$ 号点所在的连通块的大小，然后减去大小 $< i$ 的情况。

先考虑 $G$ 怎么算。不难发现 

$$\frac {g_{i+j}}{(i+j)!} = 2^{\frac {(i+j)(i+j-1)}2} \sum \frac 1{2^{\frac {i(i-1)}2}i!} \frac 1{2^{\frac {j(j-1)}2}j!}$$

因此可以直接卷积算。

令 $f_0 = g_0 = 0$，又有

$$\frac {f_i}{(i-1)!} = \frac {g_i}{(i-1)!} - \sum\limits_{j=0}^i \frac {f_j}{(j-1)!} \frac {g_{i-j}}{(i-j)!}$$

可以直接用半在线卷积算，但是这样是 $O(n \log^2 n)$ 的。

我们设

$$F = \sum \frac {f_i x^i}{i!},G = \sum \frac {g_i x^i}{i!}$$

那么就有

$$xF' = xG' - xF' G$$
$$xF'(1+G) = xG'$$
$$F' = \frac {G'}{1+G}$$

然后直接算出 $\exp(F)$ 就行了。复杂度为 $O(n \log n)$，但是由于常数很大，比半在线卷积快不了多少。

### Code:
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pn putchar('\n')
#define mset(a,x) memset(a,x,sizeof a)
#define mcpy(a,b) memcpy(a,b,sizeof a)
#define all(a) a.begin(),a.end()
#define fls() fflush(stdout)
#define int ll
#define N 262144
#define mod 998244353
using namespace std;
int re()
{
    int x=0;
    bool t=1;
    char ch=getchar();
    while(ch>'9'||ch<'0')
        t=ch=='-'?0:t,ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return t?x:-x;
}
int ksm(int x,int y)
{
    int ret=1;
    while(y)
    {
        if(y&1)ret=ret*x%mod;
        x=x*x%mod,y>>=1;
    }
    return ret;
}
void dq(int &x)
{
    if(x>=mod)x-=mod;
    if(x<0)x+=mod;
}
void swap(int& x,int& y)
{
    x^=y^=x^=y;
}
namespace polynomial
{
    int gn[N<<1],gi[N<<1],rev[N<<1],iv[N+1];
    void poly_init()
    {
        for(int i=1;i<=N;i<<=1)
        {
            gn[i]=ksm(3,(mod-1)/i);
            gi[i]=ksm(gn[i],i-1);
        }
        gn[0]=gi[0]=1;
        for(int i=1;i<N<<1;i++)
        {
            int j=1<<__lg(i);
            gn[i]=gn[i-1]*gn[j]%mod;
            gi[i]=gi[i-1]*gi[j]%mod;
        }
        for(int i=2;i<=N;i<<=1)
        {
            for(int j=i;j<i<<1;j++)
            {
                rev[j]=rev[j-i>>1|i]>>1;
                if(j&1)
                    rev[j]|=i>>1;
            }
        }
        iv[0]=iv[1]=1;
        for(int i=2;i<=N;i++)
            iv[i]=(mod-mod/i)*iv[mod%i]%mod;
    }
    int getn(int n)
    {
        if(n==1)
            return 1;
        return 1<<__lg(n-1)+1;
    }
    struct Poly
    {
        int a[N];
        int& operator [] (int x)
        {
            return a[x];
        }
        void print(int n,int l=0)
        {
            for(int i=l;i<l+n;i++)
                printf("%lld ",a[i]);
            pn;
        }
        void cpy(Poly& t,int n,int l=0)
        {
            for(int i=l;i<l+n;i++)
                a[i]=t[i];
        }
        void clr(int n,int l=0)
        {
            for(int i=l;i<l+n;i++)
                a[i]=0;
        }
        void NTT(int n,int ty=1)
        {
            for(int i=0,*t=rev+n;i<n;i++,t++)
            {
                if(*t<i)
                    swap(a[i],a[*t]);
            }
            for(int i=1;i<n;i<<=1)
            {
                for(int j=0;j<n;j+=i<<1)
                {
                    int *x=(ty==1?gn:gi)+(i<<1)-1;
                    for(int k=j;k<j+i;k++,x++)
                    {
                        int l=a[k],r=*x*a[k+i]%mod;
                        a[k]=l+r,a[k+i]=l-r;
                        a[k]=a[k]>=mod?a[k]-mod:a[k];
                        a[k+i]=a[k+i]<0?a[k+i]+mod:a[k+i];
                    }
                }
            }
            if(ty==-1)
            {
                for(int i=0;i<n;i++)
                    a[i]=a[i]*iv[n]%mod;
            }
        }
        void mul(Poly& F,Poly& G,int n)
        {
            n=getn(n);
            F.NTT(n);
            G.NTT(n);
            for(int i=0;i<n;i++)
                a[i]=F[i]*G[i]%mod;
            NTT(n,-1);
        }
        void bni(Poly& t,int n)
        {
            if(n==1)
            {
                a[0]=ksm(t[0],mod-2);
                return;
            }
            clr(n>>1,n>>1);
            static Poly tni1,tni2;
            tni1.cpy(*this,n);
            tni2.cpy(t,n);
            tni1.mul(tni1,tni2,n);
            tni1.clr(n>>1);
            tni2.cpy(*this,n);
            tni1.mul(tni1,tni2,n);
            for(int i=n>>1;i<n;i++)
                dq(a[i]=-tni1[i]);
        }
        void ni(int n)
        {
            static Poly tni0;
            n=getn(n);
            tni0.cpy(*this,n);
            for(int i=1;i<=n;i<<=1)
                bni(tni0,i);
        }
        void dao(int n)
        {
            for(int i=1;i<n;i++)
                a[i-1]=i*a[i]%mod;
            a[n-1]=0;
        }
        void jf(int n)
        {
            for(int i=n-1;i;i--)
                a[i]=a[i-1]*iv[i]%mod;
            a[0]=0;
        }
        void ln(int n)
        {
            static Poly tln;
            n=getn(n);
            tln.cpy(*this,n<<1);
            tln.dao(n);
            ni(n);
            mul(*this,tln,n<<1);
            jf(n);
        }
        void exp(int n)
        {
            n=getn(n);
            static Poly texp0;
            texp0.cpy(*this,n);
            a[0]=1;
            a[1]=0;
            for(int len=2;len<=n;len<<=1)
            {
                static Poly texp1,texp2,texp3;
                texp1.bni(*this,len>>1);
                texp1.bni(*this,len);
                texp2.cpy(texp1,len);
                texp3.cpy(*this,len);
                texp3.dao(len);
                texp3.clr(len,len);
                texp2.clr(len,len);
                texp2.mul(texp2,texp3,len<<1);
                texp2.jf(len);
                dq(texp2[0]=1-texp2[0]);
                for(int i=1;i<len;i++)
                    dq(texp2[i]=texp0[i]-texp2[i]);
                clr(len,len);
                mul(*this,texp2,len<<1);
                clr(len,len);
                texp1.clr(len,len);
            }
        }
        void mi(int n,int m)
        {
            n=getn(n);
            ln(n);
            for(int i=0;i<n;i++)
                (a[i]*=m)%=mod;
            exp(n);
        }
    };
}
using namespace polynomial;
int m=1e5,n;
Poly F,G;
int jc[N],inv[N];
void zh_init()
{
    jc[0]=1;
    for(int i=1;i<=n;i++)
        jc[i]=jc[i-1]*i%mod;
    inv[n]=ksm(jc[n],mod-2);
    for(int i=n;i;i--)
        inv[i-1]=inv[i]*i%mod;
}
signed main()
{
    poly_init();
    n=getn(m+1);
    zh_init();
    for(int i=0;i<n;i++)
        F[i]=G[i]=ksm(2,i*(i-1)/2*(mod-2))*inv[i]%mod;
    G.mul(F,G,n<<1);
    G[0]=0;
    for(int i=0;i<n;i++)
        (G[i]*=ksm(2,i*(i-1)/2))%=mod;
    G.clr(n,n);
    F.cpy(G,n<<1);
    for(int i=0;i<n;i++)
        (F[i]*=i)%=mod;
    G[0]=1;
    G.ni(n);
    F.mul(F,G,n<<1);
    for(int i=1;i<n;i++)
        (F[i]*=iv[i]*iv[2]%mod)%=mod;
    F.exp(n);
    for(int i=1;i<=m;i++)
        printf("%lld\n",F[i]*jc[i]%mod);
    pn;
    return 0;
}
```

---

## 作者：Ydoc770 (赞：1)

### [P7364 有标号二分图计数](https://www.luogu.com.cn/problem/P7364)

Hint：考虑用 exp 构建连通和不连通的有标号二分图的生成函数的关系。

一般图的限制很弱，所以先考虑直接枚举选 $i$ 个点来作为左部点，一共 $i(n-i)$ 条边任意连，有：

$$
f_n=\sum_{i=0}^n{n\choose i}2^{i(n-i)}
$$

然后你会发现这里面有大量算重的方案，因为二分图其实没有严格限制左右的先后顺序，但是这里却蕴含了黑白染色状的顺序，然而实际上黑色白色是等价的。一般图每个连通块被算重的次数不好具体反映到式子中，所以考虑 $f_n$ 的 EGF $F(x)$ 转成 $\ln F(x)$ 来通过单个连通块考虑。单个连通块考虑起来就简易多了，显然算重了两次，于是有标号连通二分图的方案数即为：

$$
{1\over 2}\ln F(x)\iff \ln\sqrt{F(x)}
$$

而我们要求的有标号一般二分图的 EGF 只需要再 exp 回去，也就是：

$$
\exp\left(\ln\sqrt{F(x)}\right)\iff\sqrt{F(x)}
$$

至于 $F(x)$ 的求法，可以使用一个恒等式

$$
ab={a+b\choose 2}-{a\choose 2}-{b\choose 2}
$$

来把 $2$ 的指数拆开，化成卷积的形式，利用多项式技术快速求。具体地：

$$
\begin{aligned}
\sum_{n\ge0}f_nx^n&=\sum_{n\ge0}\sum_{i=0}^n{n!\over i!(n-i)!}2^{{n\choose2}-{i\choose2}-{n-i\choose 2}}x^n\\
\sum_{n\ge0}{f_n\over n!}x^n&=\sum_{n\ge0}2^{n\choose2}\sum_{i=0}^n{1\over2^{i\choose2} i!}\cdot{1\over2^{n-i\choose2} (n-i)!}x^n\\
F(x)&=\sum_{n\ge0}2^{n\choose2}\sum_{i=0}^n{1\over2^{i\choose2} i!}\cdot{1\over2^{n-i\choose2} (n-i)!}x^n\\
\end{aligned}
$$

设

$$
G(x)=\sum_{k\ge0}{1\over2^{k\choose2} k!}x^k
$$

于是右式可以先用卷积把系数算一部分出来，再稍微算算就可以得到 $F(x)$。

什么？你觉得 $f_n$ 可以直接线性求？你也太可爱了。我们要求 $\le 10^5$ 的所有 $f_n$，这样当然是不可以的。

当然如果你想当然认为可以暴力求 $F(x)$ + 暴力多项式开根 + 打表通过此题，其实也是可以的哟。

---


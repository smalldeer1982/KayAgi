# 更简单的排列计数

## 题目描述

设 $\text{cyc}_\pi$ 将长为 $n$ 的排列 $\pi$ 当成置换时所能分解成的循环个数。给定两个整数 $n,k$ 和一个 $k-1$ 次多项式，对 $1\leq m\leq n$ 求：

$$
\sum\limits_{\pi}F(\text{cyc}_{\pi})
$$

其中 $\pi$ 是长度为 $m$ 且不存在位置 $i$ 使得 $\pi_i=i$ 的排列。

## 说明/提示

### 样例解释 1

下面是当 $m=1,2,3$ 时满足要求的所有排列：

$\text{cyc}_{(2,1)}=1,\text{cyc}_{(2,3,1)}=1,\text{cyc}_{(3,1,2)}=1$。
所以当 $m=1$ 时答案为 $0$，$m=2$ 时为 $1$，$m=3$ 时为 $2$。

### 数据范围

| 子任务编号 | 分值 | $n\leq$ | $k\leq$ | 其他限制 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| Subtask 1 | $1$ | $10$ | $6$ |  |
| Subtask 2 | $5$ | $2\times 10^3$ | $6$ |  |
| Subtask 3 | $6$ | $2\times 10^5$ | $1$ |  |
| Subtask 4 | $16$ | $2\times 10^5$ | $6$ | $F(x)=x^k$ |
| Subtask 5 | $16$ | $2\times 10^5$ | $3$ |  |
| Subtask 6 | $56$ | $6\times 10^5$ | $100$ |  |

对于 $100\%$ 的数据，$1\leq n\leq 6\times 10^5$，$1\leq k\leq 100$，$0\leq [x^k]F(x)\leq 998244352$。

## 样例 #1

### 输入

```
3 2
0 1```

### 输出

```
0 1 2```

## 样例 #2

### 输入

```
6 4
11 43 27 7```

### 输出

```
0 88 176 1311 7332 53070```

# 题解

## 作者：飞雨烟雁 (赞：10)

本题解提供一种无需生成函数的做法。

------------

**注**：以下所有排列 $\pi$ 均为错排，$|\pi|$ 表示排列 $\pi$ 的长度。

------------

记 $c_{n,i}=\sum_\pi[|\pi|=n][\text{cyc}_ \pi=i]$，即在长度为 $n$ 的错排中，恰能分解为 $i$ 个循环的排列个数。先列个关于 $c_{n,i}$ 的表：

| $n,i$ | $1$ | $2$ | $3$ |
| :----------: | :----------: | :----------: | :----------: |
| $2$ | $1$ |  |  |
| $3$ | $2$ |  |  |
| $4$ | $6$ | $3$ |  |
| $5$ | $24$ | $20$ |  |
| $6$ | $120$| $130$ | $15$ |

不难发现 $c_{n,i}=(n-1)(c_{n-1,i}+c_{n-2,i-1})$，以下证明：

对长度为 $n$ 的排列 $\pi$ 的最后一个数所在循环长度进行分类讨论：

+ 显然其循环长度不可能为 $1$。

+ 若其循环长度为 $2$，则将**这个数字**和**与它构成循环的那个数**一起拿走，剩下一个长度为 $(n-2)$ 的错排。因为原错排有 $i$ 个循环，现拿掉了一个循环，故剩下 $(i-1)$ 个循环，所以剩余部分有 $c_{n-2,i-1}$ 种方案。对于拿掉的那两个数，一个必须是 $\pi_n$，另一个是 $1\sim n-1$ 中任意一个，有 $(n-1)$ 种情况。

+ 若其循环长度大于等于 $3$，则将 $\pi_n$ 拿走，并让**指向 $\pi_n$ 的那个数**指向 $\pi_n$ **所指的那个数**（见下例）。那么剩下的 $(n-1)$ 个数仍是错排，且循环数为 $i$，故方案数为 $c_{n-1,i}$。对于 $\pi_n$，它原先可以插在任意一个数的前面，共有 $(n-1)$ 个位置可插。

$$\begin{pmatrix}1&2&3&4\\2&4&1&3\end{pmatrix}\rightarrow\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix}$$


综上，方案数为 $c_{n,i}=(n-1)(c_{n-1,i}+c_{n-2,i-1})$。

------------

再看题目要求，记 $\text{Ans}_ m=\sum_{|\pi|=m}F(\text{cyc}_ \pi)$，$F(x)=\sum_if_ix^i$。

若直接展开 $F(\text{cyc}_ \pi)$ 则得：

$$
\begin{aligned}
\text{Ans}_ m&=\sum_{j}f_j\sum_{|\pi|=m}(\text{cyc}_ \pi)^j\\
&=\sum_{j}f_j\sum_ic_{m,i}\,i^j
\end{aligned}
$$

记 $b_{m,j}=\sum_ic_{m,i}\,i^j$，可以证明有递推式：

$$b_{m,j}=(m-1)(b_{m-1,j}+\sum_{i=0}^j\binom jib_{m-2,i})$$

但是要是这样递推下去，时间复杂度是 $O(n^3)$ 的，不如不要。

------------

考虑采用 [P4827](https://www.luogu.com.cn/problem/P4827) 中的方法，用第二类斯特林数展开普通幂。因为：

$$m^n=\sum_{i=0}^ni!\binom mi\begin{Bmatrix} n \\i \end{Bmatrix}$$

所以可以用这个东西展开 $(\text{cyc}_ \pi)^j$，代入原式有：

$$
\begin{aligned}
\text{Ans}_ m&=\sum_{j=0}^{k-1}f_j\sum_{|\pi|=m}\sum_{i=0}^ji!\binom {\text{cyc}_ \pi}i\begin{Bmatrix} j \\i \end{Bmatrix}\\
&=\sum_{i=0}^{k-1}\Bigg(i!\sum_{j=i}^{k-1}f_j\begin{Bmatrix} j \\i \end{Bmatrix}\Bigg)\sum_{|\pi|=m}\binom {\text{cyc}_ \pi}i
\end{aligned}
$$

记 $p_{m,i}=\sum_{|\pi|=m}\binom{\text{cyc}_ \pi}{i}$，列表观察：

| $m,i$ | $0$ | $1$ | $2$ |
| :----------: | :----------: | :----------: | :----------: |
| $2$ | $1$ | $1$ | $0$ |
| $3$ | $2$ | $2$ | $0$ |
| $4$ | $9$ | $12$ | $3$ |
| $5$ | $44$ | $64$ | $20$ |

发现 $p_{m,i}=(m-1)(p_{m-1,i}+p_{m-2,i}+p_{m-2,i-1})$，以下证明：

$$

\begin{aligned}
p_{m,i}&=\sum_{|\pi|=m}\binom{\text{cyc}_ \pi}i\\
&=\sum_{j}\binom jic_{m,j}\\
&=(m-1)\sum_{j}\binom ji(c_{m-1,j}+c_{m-2,j-1})\\
&=(m-1)\Big(p_{m-1,i}+\sum_{j}\binom {j-1}{i}c_{m-2,j-1}+\sum_{j}\binom {j-1}{i-1}c_{m-2,j-1}\Big)\\
&=(m-1)(p_{m-1,i}+p_{m-2,i}+p_{m-2,i-1})
\end{aligned}

$$

证毕，则可在 $O(nk)$ 的时间内把所有的 $p_{m,i}(m\le n, i<k)$ 求出。

关于 $i!\sum_{j=i}^{k-1}f_j\begin{Bmatrix} j \\i \end{Bmatrix}$ 这一部分，可以暴力 $O(k^2)$ 求出。

至此，本题可在 $O(nk+k^2)$ 的时间复杂度内完成。

---

## 作者：Aleph1022 (赞：10)

首先把给定的多项式转成牛顿级数，即转写成
$$
F(x) = \sum\limits_{i=0}^{k-1} a_i \binom xi
$$

然后套路的拆开项，考虑计算
$$
\sum\limits_{\pi} \binom{{\rm cyc}_{\pi}}{k}
$$

让我们考虑一个错排，显然它是由非自环的循环置换为基本单位构成的，即
$$
{\rm e}^{-x-\ln(1-x)}
$$

然后考虑从中选 $k$ 个。不难发现这只需要对一个循环置换附加一个因子 $(1+y)$ 即可做到：
$$
{\rm e}^{(1+y)(-x-\ln(1-x))}
$$

令其为 $G$，考虑提取其系数。对 $x$ 求导可以得到
$$
\frac{\partial G}{\partial x} = (1+y)\frac x{1-x} G
$$

即
$$
[x^{n+1}y^k] G = \frac1{n+1} \sum\limits_{i=0}^{n-1} ([x^iy^k] + [x^iy^{k-1}]) G
$$

递推即可。时间复杂度 $O(nk)$。

---

## 作者：缙云山车神 (赞：6)

把多项式 $F(x)$ 写成牛顿级数
$$
F(x)=\sum_{i=0}^{k-1} a_i{x\choose i}
$$
现在问题变成求出答案的每一项，即对于每一个 $m(1\leq m\leq n)$ 和 $i(0\le i<k)$ 求 $\sum_{\pi}{\text{cyc}_\pi\choose i}$。$\pi$ 是长度为 $m$ 的错排，$\text{cyc}_\pi$ 表示错排的环数。

考虑错排的生成函数，首先我们知道一个环的 $EGF$ 为
$$
H=\sum_{i>0} \frac{(i-1)!}{i!}x^i= \sum_{i>0} \frac{x^i}{i}=-\ln(1-x)
$$
一个错排是由若干个环（无自环）组成的，所以错排的 $EGF$ 为
$$
G=e^{-\ln(1-x)-x}
$$
$-x$ 是因为要去除自环。

这道题是要我们求从若干个环中选若干个的答案， 所以加一元 $y$ 表示选了多少个环，于是就表示成
$$
G=e^{(-\ln(1-x)-x)\times(1+y)}
$$
记 $g_{a,b}=[x^ay^b]G$，也就是说长度为 $m$ 的错排中选 $i$ 个环的方案数的和为 $m!g_{m,i}$ ，也就是我们要求的 $\sum_{\pi}{\text{cyc}_\pi\choose i}$ 。

直接暴力上多项式牛迭复杂度就飞了。

在 $G$ 上对 $x$ 求导
$$
G(x)'=\frac{x(1+y)}{1-x}G
$$
那么
$$
(n+1)g_{n+1,k}=\sum_{i=0}^{n-1}g_{i,k}+g_{i,k-1}\\
=n\times g_{n,k}+g_{n-1,k}+g_{n-1,k-1}
$$
$O(nk)$ 递推即可。

```cpp
#include <bits/stdc++.h>
#define N 600005
#define K 102 
using namespace std;
typedef long long ll;
const int mod=998244353;
ll g[N][K],n,k,fac[N],inv[N];
ll a[K],A[K][K];
ll ksm(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1) res=res*x%mod; 
		x=x*x%mod; y>>=1;
	}
	return res;
}
void init(){
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	inv[n]=ksm(fac[n],mod-2);
	for(int i=n-1;i>=0;i--) 
		inv[i]=inv[i+1]*(i+1)%mod,inv[i+1]=inv[i+1]*fac[i]%mod;
}
void get_G(){
	g[2][0]=inv[2],g[2][1]=inv[2];
	for(ll i=3;i<=n;i++){
		g[i][0]=((i-1)*g[i-1][0]%mod+g[i-2][0])*inv[i]%mod;
		for(int j=1;j<k;j++)
			g[i][j]=((i-1)*g[i-1][j]%mod+g[i-2][j]+g[i-2][j-1])*inv[i]%mod;
	}
}
ll get_A(ll x){
	ll res=0,X=1;
	for(int i=0;i<k;i++,X=X*x%mod) res=(res+X*a[i]%mod)%mod;
	return res;
}
int main(){
//	freopen("test.in","r",stdin);
	cin>>n>>k;
	init();
	get_G();
	for(int i=0;i<k;i++) cin>>a[i];
	for(int i=0;i<k;i++) A[0][i]=get_A(i);
	for(int i=k,op=1;i>1;i--,op++)
		for(int j=0;j<i-1;j++)
			A[op][j]=(A[op-1][j+1]-A[op-1][j]+mod)%mod;
	for(int i=0;i<k;i++) a[i]=A[i][0];
	for(int m=1;m<=n;m++){
		ll res=0;
		for(int i=0;i<k;i++)
			(res+=g[m][i]%mod*a[i]%mod)%=mod;
		cout<<fac[m]*res%mod<<' ';
	}
}
```



---

## 作者：Lyrella (赞：4)

# 题意

设 $\text{cyc}_\pi$ 将长为 $n$ 的排列 $\pi$ 当成置换时所能分解成的循环个数。给定两个整数 $n,k$ 和一个 $k-1$ 次多项式，对 $1\leq m\leq n$ 求：

$$
\sum\limits_{\pi}F(\text{cyc}_{\pi})
$$

其中 $\pi$ 是长度为 $m$ 且不存在位置 $i$ 使得 $\pi_i=i$ 的排列。

数据范围：$1\leq n\leq 6\times10^5,1\le k\le 100$。

# 题解

首先我们要把 $F$ 写成牛顿级数的形式：
$$
F(\text{cyc}_\pi)=\sum_{i=0}^kf_i{\text{cyc}_\pi\choose i}
$$
代入可得：
$$
\sum_{i=0}^kf_i\sum_\pi{\text{cyc}_\pi\choose i}
$$
现在只需要算 $f_i$ 的系数即可。后面这个东西翻译成人话就是对所有错排求环数选 $i$ 个的答案。现在有一个思路是我们尝试用生成函数去刻画出错排和环的信息，然后提取系数。接下来开始刻画生成函数。

## 错排的 $\text{EGF}$

得到错排的 $\text{EGF}$ 的方法有许多，这里只讲一种笔者认为最便捷的。我们从置换环的角度入手，错排满足**不存在长度为一的置换环**。不存在长度为一的置换环这东西可以刻画出来：
$$
\sum_{i>1}{x^i\over i}=-\ln(1-x)-x
$$
推导考虑先将左边补一项，然后求导即可。然后求错排的 $\text{EGF}$ 就直接 $\exp$ 即可。现在考虑将循环数的信息放进去，我们加一元，用 $G(x,y)=e^{(1+y)(-\ln(1-x)-x)}$ 表示。

有了生成函数后我们只需要快速得到系数即可。于是我们考虑对函数求偏导：
$$
\begin{aligned}
{\partial\over\partial x}G(x,y) &= (1+y){x\over1-x}G(x,y)\\
[x^n]{\partial\over\partial x}G(x,y) &= [x^n](1+y){x\over1-x}G(x,y)\\
(n+1)[x^{n+1}]G(x,y) &= [x^{n-1}]{1\over1-x}G(x,y)+[x^{n-1}]{y\over1-x}G(x,y)\\
(n+1)[x^{n+1}y^m]G(x,y) &= [x^{n-1}y^m]{1\over1-x}G(x,y)+[x^{n-1}y^{m-1}]{1\over1-x}G(x,y)\\
(n+1)[x^{n+1}y^m]G(x,y) &= \sum_{i=0}^{n-1}[x^{i}y^m]G(x,y)+[x^iy^{m-1}]G(x,y)\\
\end{aligned}
$$
到此得到递推式，前缀和优化一下，时间复杂度 $O(nk)$。

---

## 作者：__O_v_O__ (赞：4)

观察题目中的式子：

$
\begin{aligned}
\sum\limits_{\pi}F(cyc_{\pi})&=\sum\limits_{\pi}\sum\limits_{i=0}^{k-1}f_icyc_{\pi}^i
\\&=\sum\limits_{\pi}\sum\limits_{i=0}^{k-1}f_i\sum\limits_{j=0}^i\begin{Bmatrix} i \\j \end{Bmatrix}\binom{cyc_{\pi}}{j}j!\\&=\sum\limits_{\pi}\sum\limits_{i=0}^{k-1}\sum\limits_{j=0}^if_i\begin{Bmatrix} i \\j \end{Bmatrix}\binom{cyc_{\pi}}{j}j!\\&=\sum\limits_{\pi}\sum\limits_{j=0}^{k-1}\sum\limits_{i=j}^{k-1}f_i\begin{Bmatrix} i \\j \end{Bmatrix}\binom{cyc_{\pi}}{j}j!\\&=(\sum\limits_{j=0}^{k-1}j!)(\sum\limits_{\pi}\binom{cyc_{\pi}}{j})(\sum\limits_{i=j}^{k-1}f_i\begin{Bmatrix} i \\j \end{Bmatrix})\end{aligned}$

记 $c_{t,i}$ 表示 $|\pi|=t$ 且 $cyc_{\pi}=i$ 的错排 $\pi$ 个数。

考虑递推，设 1 在序列中的位置为 $k$，分两种情况：

- $k$ 的位置为 1，此时有 $c_{t-2,i-1}$ 种情况（多了一个循环）。

- $k$ 的位置不为 1，此时有 $c_{t-1,i}$ 种情况。

这里其实和错排的递推差不多。

而 $k$ 有 $t-1$ 种选法，则 $c_{t,i}=(t-1)(c_{t-2,i-1}+c_{t-1,i})$。

又记 $p_{t,i}$ 表示 $\sum\limits_{|\pi|=t}\binom{cyc_{\pi}}{i}$ 的值。

将式子转换为枚举 $cyc_{\pi}$，可得：

$\begin{aligned}p_{t,i}&=\sum\limits_{j=1}^t\binom{j}{i}c_{t,j}\\&=\sum\limits_{j=1}^t\binom{j}{i}(t-1)(c_{t-2,j-1}+c_{t-1,j})\\&=(t-1)\sum\limits_{j=1}^t\binom{j}{i}(c_{t-2,j-1}+c_{t-1,j})\\&=(t-1)[\sum\limits_{j=1}^t\binom{j}{i}c_{t-2,j-1}+\sum\limits_{j=1}^t\binom{j}{i}c_{t-1,j}]\\&=(t-1)[\sum\limits_{j=1}^t[\binom{j-1}{i}c_{t-2,j-1}+\binom{j-1}{i-1}c_{t-2,j-1}]+\sum\limits_{j=1}^t\binom{j}{i}c_{t-1,j}]\\&=(t-1)(p_{t-2,i}+p_{t-2,i-1}+p_{t-1,i})\end{aligned}$

而由于 $t\le n,i<k$，则 $p$ 数组可以在 $O(nk)$ 时间复杂度内递推处理。

再看求得的答案式子：

$$(\sum\limits_{j=0}^{k-1}j!)(\sum\limits_{\pi}\binom{cyc_{\pi}}{j})(\sum\limits_{i=j}^{k-1}f_i\begin{Bmatrix} i \\j \end{Bmatrix})$$

我们发现：前面一部分和后面一部分可以 $O(k^2)$ 预处理，中间一部分已经被 $O(nk)$ 递推，则枚举要计算的 $m$，式子就能 $O(1)$ 算了。

---

## 作者：Anoshag_Ruwan (赞：0)

代码实现难度上确实是比 [简单的排列计数](luogu.com.cn/problem/P7438) 更简单的，因为 P7435 需要写多项式 $\exp$。

令 $d_{n,m}$ 表示长为 $n$ 的错位排列中置换环数为 $m$ 的种数。与第一类斯特林数不同的是，第 $n$ 个元素自成环排列的方案无法成立，可能的情况有：1.$n$ 插入 $[1,n-1]$ 任一元素的后方，2.$n$ 与 $[1,n-1]$ 任一元素组成大小为 $2$ 的置换环。得到递推式 $d_{n+1,m+1}=n(d_{n,m+1}+d_{n-1,m}),d_{n,1}=(n-1)!-[n=1]$。

照例转生成函数，令 $D_n(x)=\sum\limits_{m\ge 1}d_{n,m}x^m$，则 $D_n(x)$ 满足递推式 $D_n(x)=(n-1)(D_{n-1}(x)+xD_{n-2}(x))(n\ge3),D_2(x)=x$。

回过来看问题，题目要求 $\sum F(cyc_\pi)$，实际就是 $\sum\limits_{m\ge 1}d_{n,m}F(m)$，相当于 $\forall t\in[0,k-1]$，求每个 $\sum\limits_{m\ge 1}d_{n,m}m^t$。发现递推式较好契合题目要求的变换方式是求导，因此考虑普通幂转下降幂。

令 $S(x,y)$ 表示第二类斯特林数，恒等式 $x^m=\sum\limits_{k\ge0}S(m,k)x^{\underline{k}}$，于是令 $g_t=\sum\limits_{i\ge t}S(i,t)f_i$，则 $F(x)=\sum\limits_{i\ge 0}f_ix^i=\sum\limits_{i\ge0}g_ix^{\underline{i}}$。可以处理递推式了，对 $D_n(x)=(n-1)(D_{n-1}(x)+xD_{n-2}(x))$ 求导得 $D_n'(x)=(n-1)(D_{n-1}'(x)+xD_{n-2}'(x))$，进一步求导不难得到规律：$D_{n}'^{(t)}(x)=(n-1)^{\underline{t}}(D_{n-1}'^{(t)}(x)+(x+t-1)D_{n-1}'^{(t-1)}(x))$，将 $x$ 代入 $1$ 就得到了 $\sum\limits_{m\ge 0}d_{n,m}m^{\underline{t}}$。

由于实质上是一个二阶递推，使用滚动数组求出每个 $D_{n}'^{(m)}(x)$，边推边计算牛顿级数，时间复杂度 $O(nk)$，空间复杂度 $O(n+k)$。


```cpp
#include<cstdio>
#include<algorithm>
#define LL long long
using namespace std;
const int p=998244353,N=6e5+11;
LL a[N],b[N],u1[111],u2[111],u3[111],c[111],d[111],s[111][111];
inline int add(int x,int y){return x+y>=p?x+y-p:x+y;}
inline LL ksm(LL x,LL y){
    LL k=1,l=x;if(l>=p)l%=p;
    while(y){if(y&1)k=k*l%p;l=l*l%p,y>>=1;}
    return k;}
inline int rd(){
	int i=0;char g=getchar();
	while(g>57||g<48)g=getchar();
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i; 
}
int main()
{
	LL i,j,k,n=rd(),m=rd();
	for(i=2,s[1][1]=1;i<=m;i++)for(j=1;j<=m;j++)
		s[i][j]=add(s[i-1][j-1],s[i-1][j]*j%p);
	for(i=k=0;i<m;k=add(k,c[i]),i++)c[i]=rd();
	u1[0]=u1[1]=1,u2[0]=u2[1]=2;
	for(i=3,a[2]=b[2]=1;i<=n;i++)
		a[i]=b[i]=add(a[i-1],a[i-2])*(i-1)%p;
	for(i=2;i<=n;i++)a[i]=a[i]*c[0]%p;a[2]=k,a[3]=add(k,k);
	for(i=1,d[0]=c[0];i<m;i++)
		for(j=1;j<=i;j++)d[j]=add(c[i]*s[i][j]%p,d[j]);
	for(i=0;i<m;i++)printf("%lld ",d[i]);printf("\n");
	for(i=4;i<=n;i++){
		for(j=1,u3[0]=b[i];j<m;j++)
			u3[j]=(i-1)*add(add(u2[j],u1[j]),u1[j-1]*j%p)%p;
		for(j=0;j<m;j++)printf("%lld ",u3[j]);printf("\n");
		for(j=1;j<m;j++)a[i]=add(a[i],d[j]*u3[j]%p);
		for(j=0;j<m;j++)u1[j]=u2[j],u2[j]=u3[j];
	}for(i=1;i<=n;i++)printf("%lld ",a[i]);
	printf("\n");
	return 0;
}
```

---


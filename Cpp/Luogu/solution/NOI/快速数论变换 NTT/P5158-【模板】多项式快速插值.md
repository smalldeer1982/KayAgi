# 【模板】多项式快速插值

## 题目背景

模板题，无背景

## 题目描述

给出 $n$ 个点 $(x_i, y_i)$

求一个 $n-1$ 次的多项式 $f(x)$，使得 $f(x_i)\equiv y_i\pmod{998244353}$

## 说明/提示

$1 \leqslant n \leqslant 100000$

$0 \leqslant x_i, y_i \lt 998244353$

保证 $x_i$ 互不相同

对于 $30\%$ 的数据，$n \leqslant 5000$

注意，你输出的数必须是 $[0, 998244353)$ 范围内的整数

数据使用 CYaRon 在五分钟之内生成。

## 样例 #1

### 输入

```
4
1 1
2 4
3 9
4 16```

### 输出

```
0 0 1 0```

# 题解

## 作者：bztMinamoto (赞：22)

## 题面

[传送门](https://www.luogu.org/problemnew/show/P5158)

## 前置芝士

[拉格朗日插值](https://www.cnblogs.com/bztMinamoto/p/10185153.html)，[多项式多点求值](https://www.cnblogs.com/bztMinamoto/p/10371636.html)

## 题解

首先根据拉格朗日插值公式我们可以暴力$O(n^2)$插出这个多项式，然而这显然是$gg$的

那么看看怎么优化，先来看一看拉格朗日插值的公式

$$f(x)=\sum_{i = 1}^{n} y_i \prod_{i \not = j} \frac{x - x_j}{x_i - x_j}$$

转化一下

$$f(x)=\sum_{i = 1}^{n}{ y_i\over \prod_{i \not = j}{x_i - x_j}} \prod_{i \not = j}(x - x_j)$$

来考虑一下${ y_i\over \prod_{i \not = j}{x_i - x_j}}$这个东西，上面是个常数，那么只考虑下面。如果我们设多项式$g(x)=\prod_{i=1}^n (x-x_i)$，那么下面那个东西就是${g(x_i)\over (x-x_i)}$

这分子分母全为$0$我怎么求啊……

根据~~我也不知道是啥的~~洛必达法则，如果

$$\lim_{x\to a}f(x)=0,\lim_{x\to a}g(x)=0$$

则有

$$\lim_{x\to a}{f(x)\over g(x)}=\lim_{x\to a}{f'(x)\over g'(x)}$$

那么我们代入之后可以发现${g(x_i)\over (x-x_i)}=g'(x_i)$

先分治$NTT$算出$g$，然后多点求值把每个点处的值算出来就好了

那么接下来我们就考虑分治，设$f_{l,r}$表示$(x_l,y_l),(x_r,y_r)$这些点算出来的答案，则有

$$\begin{aligned}f_{l,r}&=\sum_{i = l}^{r}{ y_i\over g'(x_i)} \prod_{j=l,i \not = j}^r(x - x_j)\\&=\prod_{j=mid+1}^r(x - x_j)\sum_{i = l}^{mid}{ y_i\over g'(x_i)} \prod_{j=l,i \not = j}^{mid}(x - x_j)+\prod_{j=l}^{mid}(x - x_j)\sum_{i = mid+1}^{r}{ y_i\over g'(x_i)} \prod_{j=mid+1,i \not = j}^{r}(x - x_j)\\&=\prod_{j=mid+1}^r(x - x_j)f_{l,mid}+\prod_{j=l}^{mid}(x - x_j)f_{mid+1,r}\\\end{aligned}$$

然后没有然后了
复杂度为$O(n\log^2n)$

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(R int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=(1<<18)+5,P=998244353;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
	R int res=1;
	for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;
	return res;
}
int r[19][N],w[2][N],lg[N],inv[19];
void Pre(){
	fp(d,1,18){
		fp(i,1,(1<<d)-1)r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
		lg[1<<d]=d,inv[d]=ksm(1<<d,P-2);
	}
	for(R int t=(P-1)>>1,i=1,x,y;i<262144;i<<=1,t>>=1){
		x=ksm(3,t),y=ksm(332748118,t),w[0][i]=w[1][i]=1;
		fp(k,1,i-1)
			w[1][k+i]=mul(w[1][k+i-1],x),
			w[0][k+i]=mul(w[0][k+i-1],y);
	}
}
int lim,d,n,m;
inline void init(R int len){lim=1,d=0;while(lim<len)lim<<=1,++d;}
void NTT(int *A,int ty){
	fp(i,0,lim-1)if(i<r[d][i])swap(A[i],A[r[d][i]]);
	for(R int mid=1;mid<lim;mid<<=1)
		for(R int j=0,t;j<lim;j+=(mid<<1))
			fp(k,0,mid-1)
				A[j+k+mid]=dec(A[j+k],t=mul(w[ty][mid+k],A[j+k+mid])),
				A[j+k]=add(A[j+k],t);
	if(!ty)fp(i,0,lim-1)A[i]=mul(A[i],inv[d]);
}
void Inv(int *a,int *b,int len){
	if(len==1)return b[0]=ksm(a[0],P-2),void();
	Inv(a,b,len>>1),lim=(len<<1),d=lg[lim];
	static int A[N],B[N];
	fp(i,0,len-1)A[i]=a[i],B[i]=b[i];fp(i,len,lim-1)A[i]=B[i]=0;
	NTT(A,1),NTT(B,1);
	fp(i,0,lim-1)A[i]=mul(A[i],mul(B[i],B[i]));
	NTT(A,0);
	fp(i,0,len-1)b[i]=dec(add(b[i],b[i]),A[i]);
	fp(i,len,lim-1)b[i]=0;
}
struct node{
	node *lc,*rc;vector<int>vec;int deg;
	void Mod(const int *a,int *r,int n){
		static int A[N],B[N],D[N];
		int len=1;while(len<=n-deg)len<<=1;
		fp(i,0,n)A[i]=a[n-i];fp(i,0,deg)B[i]=vec[deg-i];
		fp(i,n-deg+1,len-1)B[i]=0;
		Inv(B,D,len);
		lim=(len<<1),d=lg[lim];
		fp(i,n-deg+1,lim-1)A[i]=D[i]=0;
		NTT(A,1),NTT(D,1);
		fp(i,0,lim-1)A[i]=mul(A[i],D[i]);
		NTT(A,0);
		reverse(A,A+n-deg+1);
		init(n+1);
		fp(i,n-deg+1,lim-1)A[i]=0;
		fp(i,0,deg)B[i]=vec[i];fp(i,deg+1,lim-1)B[i]=0;
		NTT(A,1),NTT(B,1);
		fp(i,0,lim-1)A[i]=mul(A[i],B[i]);
		NTT(A,0);
		fp(i,0,deg-1)r[i]=dec(a[i],A[i]);
	}
    void Mul(){
        static int A[N],B[N];deg=lc->deg+rc->deg,vec.resize(deg+1),init(deg+1);
        fp(i,0,lc->deg)A[i]=lc->vec[i];fp(i,lc->deg+1,lim-1)A[i]=0;
        fp(i,0,rc->deg)B[i]=rc->vec[i];fp(i,rc->deg+1,lim-1)B[i]=0;
        NTT(A,1),NTT(B,1);
        fp(i,0,lim-1)A[i]=mul(A[i],B[i]);
        NTT(A,0);
        fp(i,0,deg)vec[i]=A[i];
    }
}pool[N],*rt;
struct QAQ{
	QAQ *lc,*rc;vector<int>vec;int l,r;
	void Mul(node* p){
		static int A[N],B[N],C[N],D[N];
		int mid=(l+r)>>1;init(r-l+1+1);
		fp(i,0,mid-l+1)A[i]=lc->vec[i],C[i]=p->lc->vec[i];
		fp(i,mid-l+2,lim-1)A[i]=C[i]=0;
		fp(i,0,r-mid)B[i]=rc->vec[i],D[i]=p->rc->vec[i];
		fp(i,r-mid+1,lim-1)B[i]=D[i]=0;
		NTT(A,1),NTT(B,1),NTT(C,1),NTT(D,1);
		fp(i,0,lim-1)A[i]=add(mul(A[i],D[i]),mul(B[i],C[i]));
		NTT(A,0);vec.resize(r-l+2);
		fp(i,0,r-l+1)vec[i]=A[i];
	}
}o[N],*qwq;
int a[N],tot,cnt;
inline node* newnode(){return &pool[tot++];}
inline QAQ* newQAQ(){return &o[cnt++];}
void solve(node* &p,int l,int r){
	p=newnode();
	if(l==r)return p->deg=1,p->vec.resize(2),p->vec[0]=P-a[l],p->vec[1]=1,void();
	int mid=(l+r)>>1;
	solve(p->lc,l,mid),solve(p->rc,mid+1,r);
	p->Mul();
}
int b[25],f[N];
void calc(node* p,int l,int r,const int *A){
	if(r-l<=512){
		fp(i,l,r){
			int x=a[i],c1,c2,c3,c4,now=A[r-l];
			b[0]=1;fp(j,1,16)b[j]=mul(b[j-1],x);
			for(R int j=r-l-1;j-15>=0;j-=16){
				c1=(1ll*now*b[16]+1ll*A[j]*b[15]+1ll*A[j-1]*b[14]+1ll*A[j-2]*b[13])%P,
				c2=(1ll*A[j-3]*b[12]+1ll*A[j-4]*b[11]+1ll*A[j-5]*b[10]+1ll*A[j-6]*b[9])%P,
				c3=(1ll*A[j-7]*b[8]+1ll*A[j-8]*b[7]+1ll*A[j-9]*b[6]+1ll*A[j-10]*b[5])%P,
				c4=(1ll*A[j-11]*b[4]+1ll*A[j-12]*b[3]+1ll*A[j-13]*b[2]+1ll*A[j-14]*b[1])%P,
				now=(0ll+c1+c2+c3+c4+A[j-15])%P;
			}
			fd(j,(r-l)%16-1,0)now=(1ll*now*x+A[j])%P;
			f[i]=now;
		}
		return;
	}
	int mid=(l+r)>>1,b[p->deg+1];
	p->lc->Mod(A,b,p->deg-1),calc(p->lc,l,mid,b);
	p->rc->Mod(A,b,p->deg-1),calc(p->rc,mid+1,r,b);
}
int x[N],y[N],A[N];
void loli(QAQ* &qwq,node *p,int l,int r){
	qwq=newQAQ(),qwq->l=l,qwq->r=r;
	if(l==r)return qwq->vec.resize(2),qwq->vec[0]=mul(y[l],ksm(f[l],P-2)),qwq->vec[1]=0,void();
	int mid=(l+r)>>1;
	loli(qwq->lc,p->lc,l,mid),loli(qwq->rc,p->rc,mid+1,r);
	qwq->Mul(p);
}
int main(){
//	freopen("testdata.in","r",stdin);
	n=read(),Pre();
	fp(i,1,n)x[i]=a[i]=read(),y[i]=read();
	solve(rt,1,n);
	fp(i,1,n)A[i-1]=mul(rt->vec[i],i);A[n]=0;
	calc(rt,1,n,A);
	loli(qwq,rt,1,n);
	fp(i,0,n-1)print(qwq->vec[i]);
	return Ot(),0;
}
```

---

## 作者：cyffff (赞：14)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5158)
## 题意
给出 $n-1$ 次多项式 $F(x)$ 的 $n$ 个点值 $F(x_i)=y_i$，求出这个多项式 $F(x)$。

$1\le n\le10^5$。
## 思路
$\text{Update 2024.03.19}$：更改了代码与部分说明。

以下默认 $mid=\lfloor\frac {l+r} 2\rfloor$。

回顾拉格朗日插值的式子：

$$F(x)=\sum_{i=1}^n y_i\prod_{i\ne j}\dfrac{x-x_j}{x_i-x_j}$$

将后面的分母提到前面：

$$F(x)=\sum_{i=1}^n \dfrac{y_i}{\prod_{i\ne j}{x_i-x_j}}\prod_{i\ne j}{(x-x_j)}$$

设 $\delta(x)=\displaystyle\prod_{i=1}^n(x-x_i)$，则：

$$\prod_{i\ne j}({x_i-x_j})=\lim_{x\to x_i}\dfrac{\delta(x)}{x-x_i}=\delta'(x_i)$$

$$F(x)=\sum_{i=1}^n \dfrac{y_i}{\delta'(x_i)}\prod_{i\ne j}{(x-x_j)}$$

$\delta(x)$ 容易分治 $\text{NTT}$ 求出，然后使用多点求值求出 $\delta'(x_i)$，不会多点求值可以看[这里](https://www.luogu.com.cn/blog/cyffff/solution-p5050)。

接下来直接分治 $\text{NTT}$ 即可。具体地，设 $G_{l,r}(x)=\prod_{i=l}^r(x-x_i)$，$H_{l,r}(x)$ 为 $(x_l,y_l),(x_{l+1}y_{l+1}),\dots (x_r,y_r)$ 插出来的多项式，即 $\sum_{i=l}^r \frac{y_i}{\delta'(x_i)}\prod_{i\ne j}^{l\le j\le r}{(x-x_j)}$，不难导出：

$$G_{l,r}(x)=G_{l,mid}(x)\cdot G_{mid+1,r}(x)$$

$$H_{l,r}(x)=H_{l,mid}(x)\cdot G_{mid+1,r}(x)+H_{mid+1,r}(x)\cdot G_{l,mid}(x)$$

每一步的时间复杂度均为 $O(n\log^2 n)$，于是总时间复杂度为 $O(n\log^2 n)$。

核心代码：
```cpp
namespace Interpolation{
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	inline Poly MulT(const Poly &a,const Poly &b){
		Poly F=a,G=b;
		int n=a.size(),m=b.size();
		reverse(G.begin(),G.end());
		init(n);
		F.resize(lim),G.resize(lim);
		NTT(F,1),NTT(G,1);
		for(int i=0;i<lim;i++)
			G[i]=1ll*F[i]*G[i]%mod;
		NTT(G,-1);
		for(int i=m-1;i<n;i++)
			F[i-m+1]=G[i];
		F.resize(max(0,n-m+1));
		return F;
	}
	Poly TR[N],T[N];
	Poly Q,QY,ans;
	inline void build(int rt,int l,int r){
		if(l==r){
			TR[rt]=(Poly){1,dec(0,Q[l])};
			T[rt]=TR[rt],reverse(T[rt].begin(),T[rt].end());
			return ;
		}
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		TR[rt]=TR[ls]*TR[rs];
		T[rt]=TR[rt],reverse(T[rt].begin(),T[rt].end());
	}
	inline void solve(int rt,int l,int r,Poly F){
		if(l==r){
			ans[l]=F[0];
			return ;
		}
		int mid=l+r>>1;
		solve(ls,l,mid,MulT(F,TR[rs]));
		solve(rs,mid+1,r,MulT(F,TR[ls]));
	}
	inline Poly solve(int rt,int l,int r){
		if(l==r)
			return (Poly){1ll*QY[l]*qpow(ans[l],mod-2)%mod};
		int mid=l+r>>1;
		Poly L=solve(ls,l,mid),R=solve(rs,mid+1,r);
		return L*T[rs]+R*T[ls];
	}
	inline Poly solve(Poly X,Poly Y){
		Q=X,QY=Y;
		int n=X.size();
		build(1,0,n-1);
		Poly F=Deriv(T[1]);
		ans.resize(n),F.resize(n*2);
		solve(1,0,n-1,MulT(F,Inv(TR[1])));
		return solve(1,0,n-1);
	}
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：7)

人傻常数大.jpg

首先，对这道题目拉格朗日插值是误导，我们看怎么从零推柿子。

注意到答案多项式肯定能写成 $n$ 个多项式 $f_1(x),f_2(x),\dots,f_n(x)$ 之和，其中如果 $j\neq i$，$f_i(x_j)=0$，否则 $f_i(x_i)=y_i$。

考虑怎么构造第 $i$ 个多项式。显然它的根在 $x_j(j\neq i)$，所以 $\prod_{j\neq i}(x-x_j)$ 必须是 $f_i(x)$ 的一个因子。但是这样已经到 $x^{n-1}$ 了，所以后面必须是乘一个常数项，不可能在加入有 $x$ 的因子了。

$$k_i\prod_{j\neq i}(x_i-x_j)=y_i\implies k_i=\frac{y_i}{\prod_{j\neq i}(x_i-x_j)}$$

答案为 $\sum k_i\prod(x-x_j)$ 这个多项式。

那么，如果计算出来 $k_i$ 了，那就可以用分治计算答案。定义 $v(l,r)$：

$$v(l,r)=\sum_{i=l}^{r-1}k_i\prod_{j=l,i\neq j}^{r-1}(x-x_j)$$

再定义 $p(l,r)$（这个需要预处理）：

$$p(l,r)=\prod_{i=l}^{r-1}(x-x_i)$$

我们有 $v(l,r)=v(l,\lfloor\frac{l+r}2\rfloor)p(\lfloor\frac{l+r}2\rfloor,r)+p(l,\lfloor\frac{l+r}2\rfloor)v(\lfloor\frac{l+r}2\rfloor,r)$，因为每一个 $i$ 要么是在左半部分要么在右半部分，如果在左半仅仅需要对所有在和里面乘上右半的 $p$，对右半相似。

到这里发现 $k_i$ 有点麻烦来计算，因为 $\prod_{j\neq i}(x_i-x_j)$ 由于有一个 $j\neq i$ 难处理。

考虑求极限：

$$\prod_{j\neq i}(x_i-x_j)=\lim_{x\rightarrow x_i}\frac{\prod(x-x_j)}{x-x_i}$$

定义一个函数 $f(x)=\prod(x-x_j)$。显然 $f(x_i)=0$，所以以上柿子等价于

$$\prod_{j\neq i}(x_i-x_j)=\lim_{x\rightarrow x_i}\frac{f(x)-f(x_i)}{x-x_i}$$

这个也就是导的一个定义，所以我们就有

$$\prod_{j\neq i}(x_i-x_j)=f'(x_i)$$

$$k_i=\frac{y_i}{f'(x_i)}$$

对 $f_i$ 多点求值即可。

这道题目卡长真有毒，复制了几个地方的板子（不过求值插值还是我写的

主要是特别感谢 fjzzq2002 的 AVX 优化 NTT 代码。

代码：

```cpp
#pragma GCC optimize("-Ofast","-funroll-all-loops","-ffast-math")
#pragma GCC optimize("-fno-math-errno")
#pragma GCC optimize("-funsafe-math-optimizations")
#pragma GCC optimize("-freciprocal-math")
#pragma GCC optimize("-fno-trapping-math")
#pragma GCC optimize("-ffinite-math-only")
#pragma GCC optimize("-fno-stack-protector")
#pragma GCC target ("avx2","sse4.2","fma")
#include <immintrin.h>
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// https://judge.yosupo.jp/submission/5253

struct IO {
  static constexpr size_t buf_size = 1 << 18;
  char buf_in[buf_size], buf_out[buf_size];
  size_t pt_in = 0, pt_out = 0, tail_in = 0;
  char strs[10000 * 4];
  inline size_t num_digits(long long x) {
    if (x >= (long long)1e9) {
      if (x >= (long long)1e18) return 19;
      if (x >= (long long)1e17) return 18;
      if (x >= (long long)1e16) return 17;
      if (x >= (long long)1e15) return 16;
      if (x >= (long long)1e14) return 15;
      if (x >= (long long)1e13) return 14;
      if (x >= (long long)1e12) return 13;
      if (x >= (long long)1e11) return 12;
      if (x >= (long long)1e10) return 11;
      return 10;
    } else {
      if (x >= (long long)1e8) return 9;
      if (x >= (long long)1e7) return 8;
      if (x >= (long long)1e6) return 7;
      if (x >= (long long)1e5) return 6;
      if (x >= (long long)1e4) return 5;
      if (x >= (long long)1e3) return 4;
      if (x >= (long long)1e2) return 3;
      if (x >= (long long)1e1) return 2;
      return 1;
    }
  }
  IO() {
    load();
    for (int i = 0; i < 10000; ++i) {
      int j = i;
      for (int t = 3; t >= 0; --t) {
        strs[i * 4 + t] = j % 10 + '0';
        j /= 10;
      }
    }
  }
  ~IO() { flush(); }
  inline void load() {
    memcpy(buf_in, buf_in + pt_in, tail_in - pt_in);
    size_t width = tail_in - pt_in;
    tail_in = width + fread(buf_in + width, 1, buf_size - width, stdin);
    pt_in = 0;
  }
  inline void flush() {
    fwrite(buf_out, 1, pt_out, stdout);
    pt_out = 0;
  }
  inline void read(char& c) { c = buf_in[pt_in++]; }
  template <class T>
  inline void read(T& x) {
    if (pt_in + 32 > tail_in) load();
    char c;
    do {
      read(c);
    } while (c < '0');
    bool minus = 0;
    if (c == '-') {
      minus = 1;
      read(c);
    }
    x = 0;
    while (c >= '0') {
      x = x * 10 + (c & 15);
      read(c);
    }
    if (minus) x = -x;
  }
  inline void write(char c) { buf_out[pt_out++] = c; }
  template <class T>
  inline void write(T x) {
    if (pt_out > buf_size - 32) flush();
    if (x < 0) {
      write('-');
      x = -x;
    }
    size_t digits = num_digits(x);
    int i;
    for (i = pt_out + digits - 4; i > (int)pt_out; i -= 4) {
      memcpy(buf_out + i, strs + (x % 10000) * 4, 4);
      x /= 10000;
    }
    memcpy(buf_out + pt_out, strs + x * 4 + (pt_out - i), 4 + i - pt_out);
    pt_out += digits;
  }
  inline void write(const char* s) {
    if (pt_out > buf_size - 32) flush();
    for (int i = 0; s[i] != 0; ++i) write(s[i]);
  }
  template <class T>
  inline void writeln(T x) {
    write(x);
    write('\n');
  }
} io;

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, (int)(a))
#define rep1(i, a) iter(i, 1, (int)(a)+1)
#define fi first
#define se second
#define pb push_back
#define intsize (sizeof(int))
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;

typedef unsigned us;
typedef unsigned long long ull;

static char buf[450 << 20];
void* operator new(size_t s) {
	static size_t i = sizeof buf;
	assert(s < i);
	return (void*)&buf[i -= s];
}
void operator delete(void*) {}

template<class T> struct ptr {
	unsigned ind;
	ptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {
		assert(ind < sizeof buf);
	}
	T& operator*() const { return *(T*)(buf + ind); }
	T* get() const { return &**this; }
	T& operator[](int a) const { return (&**this)[a]; }
	explicit operator bool() const { return ind; }
};

namespace poly {
	const int MOD = 998244353;
	const int IMAG = 86583718;
	const int NTTG = 3;
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
// https://www.luogu.com.cn/record/32153077
// zzq orz
#define SZ 524320
ll qp(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%MOD;
		a=a*a%MOD; b>>=1;
	}
	return ans;
}
int getK(int n)
{int s=1; while(s<n) s<<=1; return s;}
us pool[SZ*4] __attribute__ ((aligned(64))),*ptr=pool;
us *p0[SZ],*p1[SZ],*q0[SZ],*q1[SZ];
__attribute__((always_inline)) void bit_flip(us*p,int t)
{
	for(int i=0,j=0;i<t;++i)
	{
		if(i>j) swap(p[i],p[j]);
		for(int l=t>>1;(j^=l)<l;l>>=1);
	}
}
void prep(int n)
{
	static int t=1;
	for(;t<n;t<<=1)
	{
		int g=qp(3,(MOD-1)/(t*2));
		us*p,*q;
		p=p0[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q0[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
		g=qp(g,MOD-2);
		p=p1[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q1[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
	}
}
typedef unsigned long long ull;
__attribute__((always_inline)) us my_mul(us a,us b,us c)
{
	return b*(ull)a-((ull(a)*c)>>32)*ull(998244353);
}
__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i&a, const __m128i& b)
{
	return _mm_mullo_epi32(a,b);
	/*
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2) 
	__m128i prod   = _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
	*/
}
__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i&a, const __m128i& b)
{
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (a2*b2,-,a0*b0,-)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (a3*b3,-,a1*b1,-)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (a1*b1,a0*b0,-,-) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (a3*b3,a2*b2,-,-) 
	__m128i prod   = _mm_unpackhi_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
}
void ntt(us* __restrict__ x,int n)
{
	int t=n;
	for(int m=1;m<n;m<<=1)
	{
		t>>=1;
		us* __restrict__ p=p0[m];
		us* __restrict__ q=q0[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					u=_mm_sub_epi32(u,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u,mm),
					_mm_cmpgt_epi32(m0,u)),mm));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					v=_mm_sub_epi32(my_mullo_epu32(v,p4),
					my_mullo_epu32(my_mulhi_epu32(v,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u,v));
					_mm_storeu_si128((__m128i*)(xb+j),_mm_add_epi32(_mm_sub_epi32(u,v),mm));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					u0=_mm_sub_epi32(u0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u0,mm),
					_mm_cmpgt_epi32(m0,u0)),mm));
					u1=_mm_sub_epi32(u1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u1,mm),
					_mm_cmpgt_epi32(m0,u1)),mm));
					v0=_mm_sub_epi32(my_mullo_epu32(v0,p4),
					my_mullo_epu32(my_mulhi_epu32(v0,q4),m1));
					v1=_mm_sub_epi32(my_mullo_epu32(v1,p4),
					my_mullo_epu32(my_mulhi_epu32(v1,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u0,v0));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_add_epi32(u1,v1));
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_add_epi32(_mm_sub_epi32(u0,v0),mm));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_add_epi32(_mm_sub_epi32(u1,v1),mm));
				}
			}
		}
	}
	for(int i=0;i<n;++i)
		x[i]-=(x[i]>=us(MOD+MOD))*us(MOD+MOD),
		x[i]-=(x[i]>=us(MOD))*us(MOD);
}
void intt(us* __restrict__ x,int n)
{
	int t=1;
	for(int m=(n>>1);m;m>>=1)
	{
		us* __restrict__ p=p1[m];
		us* __restrict__ q=q1[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i uv=_mm_add_epi32(u,v);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv,mm),
					_mm_cmpgt_epi32(m0,uv)),mm)));
					uv=_mm_add_epi32(_mm_sub_epi32(u,v),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv,p4),
					my_mullo_epu32(my_mulhi_epu32(uv,q4),m1)));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					__m128i uv0=_mm_add_epi32(u0,v0);
					__m128i uv1=_mm_add_epi32(u1,v1);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv0,mm),
					_mm_cmpgt_epi32(m0,uv0)),mm)));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_sub_epi32(uv1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv1,mm),
					_mm_cmpgt_epi32(m0,uv1)),mm)));
					uv0=_mm_add_epi32(_mm_sub_epi32(u0,v0),mm);
					uv1=_mm_add_epi32(_mm_sub_epi32(u1,v1),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv0,p4),
					my_mullo_epu32(my_mulhi_epu32(uv0,q4),m1)));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_sub_epi32(my_mullo_epu32(uv1,p4),
					my_mullo_epu32(my_mulhi_epu32(uv1,q4),m1)));
				}
			}
		}
		t<<=1;
	}
	us rn=qp(n,MOD-2);
	for(int i=0;i<n;++i)
		x[i]=x[i]*(ull)rn%MOD;
}
	
	void mult(us *a, us as, us *b, us bs, us *o, bool construct, bool clean = 0, us th = 100000000) {
		us n = as+bs-1;
		if(n >= 40) {
    		while(n - (n & (-n))) n += (n & (-n));
    		assert(!construct);
    		//constructrev(n);
    		ntt(a, n); ntt(b, n);
    		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
    		intt(o, n);
		} else {
		    static ll tmp[41];
		    rep(i, as) rep(j, bs) tmp[i+j] += 1ll * a[i] * b[j];
		    rep(i, n) {
		        o[i] = tmp[i] % MOD;
		        tmp[i] = 0;
		    }
		}
		iter(i, th, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(us* a, us as, us *o) {
		static us tmp[524320];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); us le = 0;
		while((1 << le) < (as << 1)) le++;
		//constructrev(1 << le);
		memcpy(tmp, a, as*intsize);
		memset(tmp+as, 0, ((1<<le)-as)*intsize);
		ntt(tmp, 1<<le); ntt(o, 1<<le);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		intt(o, 1<<le);
		memset(o+as, 0, ((1<<le)-as)*intsize);
	}

	void init(us n) { prep(n); }
	
	void divide(us *a, us as, us *b, us bs, us *q, us *r) {
		static us ar[524320], br[524320], bin[524320];
		us th = as, re = as-bs+1;
		//th = re+1;
		rep(i, as) ar[i] = a[as-1-i];
		rep(i, bs) br[i] = b[bs-1-i];
		cfn(br, th, bin);
		mult(ar, th, bin, th, q, 0, 1, re);
		reverse(q, q+re);
		mult(q, re, b, bs, r, 0, 1, bs - 1);
		rep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;
	}
	
}

#define array MY_FUCKING_ARRAY

struct array {
    ptr<us> head; us sz;
    array() : sz(0) { head = nullptr; }
    array(us size) : sz(size) { head = new us[size]; }
    us& operator[](const us idx) { return head[idx]; }
    us* get() { return head.get(); }
    const us size() { return sz; }
};

array pol[524320];


namespace Eval {
    us points[524320];
    us answer[524320];
    
    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }

    void solve(us idx, us l, us r, array& polynomial) {
        static us tmp[524320], tmp2[524320], tmp3[524320], BULLSHIT[524320];
        //assert(polynomial.size() == r-l);
        if(r - l == 0) return;
        if(r - l == 1) {
            answer[l] = polynomial[0];
            return;
        }
        us m = (l+r)/2;
        if(m - l) {
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2].get(), (m-l+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, m-l+1, BULLSHIT, tmp3);
            array p2(m-l); memcpy(p2.get(), tmp3, (m-l)*intsize);
            solve(idx*2, l, m, p2);
        }
        if(r - m) { 
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2+1].get(), (r-m+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, r-m+1, BULLSHIT, tmp3);
            array p2(r-m); memcpy(p2.get(), tmp3, (r-m)*intsize);
            solve(idx*2+1, m, r, p2);
        }
    }
us p[524320];
us dv[524320];
us rp[524320];
us BULLsHIT[524320];
    array eval(array& po, array& v) {
        us n = po.size(), m = v.size();
        rep(i, m) {
            points[i] = v[i];
            if(!v[i]) v[i] = MOD;
        }
        //init(1, 0, m);
        static us tmp[524320];
        array pp(m);
        if(n >= m+1) {
            rep(i, m+1) dv[i] = pol[1][i];
            rep(i, n) p[i] = po[i];
            poly::divide(p, n, dv, m+1, BULLsHIT, tmp);
            memcpy(pp.get(), tmp, m*intsize);
        } else pp = po;
        solve(1, 0, m, pp);
        array res(m); memcpy(res.get(), answer, m*intsize);
        return res;
    }
}

namespace Inter {
    us points[524320], values[524320];
    
    array drv, coeff;

    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }
    
    array solve(us idx, us l, us r) {
        if(r - l == 0) {
            array ans(1); ans[0] = 1;
            return ans;
        }
        if(r - l == 1) {
            array ans(1); ans[0] = 1ll * values[l] * poly::qpow(coeff[l], MOD-2) % MOD;
            return ans;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320], tmp4[524320];
        array tmp = solve(idx*2, l, (l+r)/2);
        array tmpp = solve(idx*2+1, (l+r)/2, r);
        memcpy(tmp1, tmp.get(), tmp.size() * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), pol[idx*2+1].size() * intsize);
        us s1 = tmp.size() + pol[idx*2+1].size() - 1;
        poly::mult(tmp1, tmp.size(), tmp2, pol[idx*2+1].size(), tmp3, 0, 1); 
        rep(i, tmpp.size()) tmp1[i] = tmpp[i];
        memcpy(tmp1, tmpp.get(), tmpp.size() * intsize);
        memcpy(tmp2, pol[idx*2].get(), pol[idx*2].size() * intsize);
        us s2 = tmpp.size() + pol[idx*2].size() - 1;
        poly::mult(tmp1, tmpp.size(), tmp2, pol[idx*2].size(), tmp4, 0, 1); 
        s2 = max(s2, s1); tmp = array(s2);
        rep(i, s2) {
            us p = tmp3[i] + tmp4[i]; p -= (p >= MOD ? MOD : 0);
            tmp[i] = p;
            //tmp3[i] = tmp4[i] = 0;
        }
        return tmp;
    }

    array inter(array& pt, array& vl) {
        assert(pt.size() == vl.size());
        us n = pt.size();
        memcpy(points, pt.get(), n * intsize);
        memcpy(values, vl.get(), n * intsize);
        init(1, 0, n);
        drv = array(n);
        rep1(i, n) { drv[i-1] = 1ll * i * pol[1][i] % MOD; }
        coeff = Eval::eval(drv, pt);
        return solve(1, 0, n);
    }
}

array a, b, r;

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; io.read(n);
    a = array(n);
    b = array(n);
    rep(i, n) io.read(a[i]), io.read(b[i]);
    int k = 1; while(k <= (n << 1)) k <<= 1;
    poly::init(k);
    r = Inter::inter(a, b);
    rep(i, n) io.write(r[i]), io.write(' ');
}
```

---

## 作者：Great_Influence (赞：6)

想要解决这个问题，你得先知道[多项式多点求值](https://www.luogu.org/problemnew/show/P5050)和[拉格朗日插值](https://www.luogu.org/problemnew/show/P4781)。

知道拉格朗日插值，你就能够在$O(n^2)$内解决这个问题。但是这个显然是不能过去的。

不过，我们可以尝试优化插值的过程。

先看拉格朗日插值的过程。

$$f(x)=\sum_{i=1}^n y_i\prod_{j=1,j\not = i}^n \frac{x-x_j}{x_i-x_j}$$

$$=\sum_{i=1}^n  \frac{y_i}{\prod_{j=1,j\not = i}^n(x_i-x_j)}*\prod_{j=1,j\not = i}^n(x-x_j)$$

我们将它分成两个部分去计算。

先计算$\frac{y_i}{\prod_{j=1,j\not=i}^n (x_i-x_j)}$。上面是常数，因此我们只考虑下半部分。

设$\pi(x)=\prod_{i=1}^n (x-x_i)$，则我们要求的是$\frac{\pi(x_i)}{x-x_i}$。根据洛必达法则可以得到它就等于$\pi'(x_i)$。这部分利用上面的多点求值即可做到$O(n\log^2n)$。

然后，我们将式子拆开。

设$f_{l,r}(x)$表示$(x_l,y_l)$到$(x_r,y_r)$这些点插出来的多项式，则

$$f_{l,r}(x)=\sum_{i=l}^r  \frac{y_i}{\pi'(x)}*\prod_{j=l,j\not = i}^r(x-x_j)$$

$$=[\prod_{j=mid+1}^r(x-x_j)]*\sum_{i=l}^{mid}\frac{y_i}{\pi'(x)}*[\prod_{j=l,j\not =i}^{mid}(x-x_j)]$$
$$+[\prod_{j=l}^{mid}(x-x_j)]*\sum_{i=mid+1}^r\frac{y_i}{\pi'(x)}*[\prod_{j=mid+1,j\not =i}^r(x-x_j)]$$

$$= [\prod_{j=mid+1}^r(x-x_j)]f_{l,mid}(x)+[\prod_{j=l}^{mid}(x-x_j)]f_{mid+1,r}(x)$$

递归求解即可。时间复杂度$O(n\log^2n)$。

核心代码:
```cpp

static int fst[MAXN];

void calcf(int*x,int l,int r,int lev)
{
	if(l==r){pol[lev][0]=fst[l];return;}
	int mid=(l+r)>>1;
	calcf(x,l,mid,lev+1);
	calc(x,mid+1,r,0,0);//这是分治乘法
	mul(pol[lev+1],solv[0][0],pol[lev],mid-l,r-mid);//这是多项式乘法
	calcf(x,mid+1,r,lev+1);
	calc(x,l,mid,0,0);
	mul(pol[lev+1],solv[0][0],Q,r-mid-1,mid-l+1);
	Rep(i,0,r-l)pol[lev][i]=ad(pol[lev][i],Q[i]);
}

inline void getfunc(int*x,int*y,int*F,int n)
{
	calc(x,1,n,0,0);
	Rep(i,0,n)pol[0][i]=solv[0][0][i];
	Deriv(pol[0],pol[0],n);//这是求导
	getnum(x,fst,1,n,0,n-1);//这是多点求值
	Rep(i,1,n)fst[i]=(ll)y[i]*power(fst[i],mod-2)%mod;
	calcf(x,1,n,0);//主函数
	Rep(i,0,n-1)F[i]=pol[0][i];
}
```

---

## 作者：rEdWhitE_uMbrElla (赞：5)

咕咕~ 本蒟蒻是看到新模板后现学的，，，于是可能有描述不准确的地方，请见谅。

### 0. 多项式多点求值

这是做着题的基本，详见[P5050](https://www.luogu.org/problemnew/show/P5050)，蒟蒻在这里就不详细讲了。

### 1. 假·解法

$O(n^2)$拉格朗日插值。这是蒟蒻的最开始想法，，，但明显过不了。。

### 2. 真·解法

然而还是拉格朗日插值。。。即，$f(x)=\sum_{i=0}^{n-1}\frac {\prod_{j\ne i}(x-x_j)} {\prod_{j\ne i}(x_i-x_j)}y_i$

1. $\prod_{j\ne i}(x_i-x_j)$

	这是要先计算的。
    
    设$L(x)=\prod_{i=0}^{n-1} (x-x_i),R_i(x)=\frac{L(x)}{x-x_i}$，则有$\prod_{j\ne i}(x_i-x_j)=R_i(x_i)$，我们发现此时分式$R_i$分子分母都为0，于是有$\prod_{j\ne i}(x_i-x_j)=R_i(x_i)=L'(x_i) ^{\tiny{\textcolor{grey}{\text{*根据洛必达法则}}}}$
    
    于是此部分可用多项式多点求值求得。
    
2. 整体

	上面那部分求完了，就可以直接求整体了。
    
    经上一部分的转化，我们现在要求$f(x)=\sum_{i=0}^{n-1}\frac{y_i}{\prod_{j\ne i}(x_i-x_j)}\prod_{j\ne i}(x-x_j)$
    
    然后我们可以NTT一下，于是~~超长公式警告~~
    
    $$f(x)=\Large[\normalsize\prod_{i=\lfloor\frac{n}{2}\rfloor+1}^{n-1}(x-x_i)\Large]\{\normalsize\sum_{i=0}^{\lfloor\frac{n}{2}\rfloor}\Large[\normalsize\frac{y_i}{\prod_{j\ne i}(x_i-x_j)}\Large][\normalsize\prod_{0\le j\le \lfloor\frac{n}{2}\rfloor,j\ne i}(x-x_j)\Large]\}\normalsize+\Large[\normalsize\prod_{i=0}^{\lfloor\frac{n}{2}\rfloor}(x-x_i)\Large]\normalsize\Large[\normalsize\sum_{i=\lfloor\frac{n}{2}\rfloor+1}^{n-1}\quad \prod_{\lfloor\frac{n}{2}\rfloor<j<n,j\ne i}(x-x_j)\Large]\normalsize$$
    
    个人觉得这个公式被强制性加括号后好读了许多。。。
    
总时间复杂度$O(nlogn)$

代码如下（封装度可高了QAQ）：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int P = 998244353;

int n, m;
vector<int> x, y, z, ans;
vector<vector<int>> p;

namespace commonTool{
    inline int power(ll x, int y=P-2){
        int ans=1;
        for(; y; y>>=1, x=x*x%P) if(y&1) ans=ans*x%P;
        return ans;
    }
    
    inline int power2to(int x){
        int n=1;
        while(n<=x) n<<=1;
        return n;
    }
    
    inline int mod(int x){
        return x<P?x:x-P;
    }
    inline void NTT(vector<int> &f, int g, int n){
        using namespace commonTool;
        f.resize(n);
        for(int i=0, j=0; i<n; ++i){
            if(i>j) swap(f[i], f[j]);
            for(int k=n>>1; (j^=k)<k; k>>=1);
        }
        vector<int> w(n>>1);
        for(int i=1; i<n; i<<=1){
            for(int j=w[0]=1, w0=(g==1?power(3, (P-1)/i/2):power(power(3, (P-1)/i/2))); j<i; ++j) w[j]=(ll)w[j-1]*w0%P;
            for(int j=0; j<n; j+=i<<1){
                for(int k=j; k<j+i; ++k){
                    int t=(ll)f[k+i]*w[k-j]%P;
                    f[k+i]=mod(f[k]-t+P);
                    f[k]=mod(f[k]+t);
                }
            }
        }
        if(g==-1) for(int i=0, I=power(n); i<n; ++i) f[i]=(ll)f[i]*I%P;
    }
}

namespace sptInter{
    inline vector<int> add(const vector<int> &f, const vector<int> &g){
        vector<int> ans=f;
        for(unsigned i=0; i<f.size(); ++i) (ans[i]+=g[i])%=P;
        return ans;
    }
    
    inline vector<int> multi(const vector<int> &f, const vector<int> &g){
        using namespace commonTool;
        vector<int> F=f, G=g;
        int p=power2to(f.size()+g.size()-2);
        NTT(F, 1, p), NTT(G, 1, p);
        for(int i=0; i<p; ++i) F[i]=(ll)F[i]*G[i]%P;
        NTT(F, -1, p);
        return F.resize(f.size()+g.size()-1), F;
    }
    
    inline vector<int> inv(const vector<int> &f, int n=-1){
        using namespace commonTool;
        if(n==-1) n=f.size();
        vector<int> ans;
        if(n==1) return ans.push_back(power(f[0])), ans;
        ans=inv(f, (n+1)/2);
        vector<int> tmp(&f[0], &f[0]+n);
        int p=power2to(n*2-2);
        NTT(tmp, 1, p), NTT(ans, 1, p);
        for(int i=0; i<p; ++i) ans[i]=(2-(ll)ans[i]*tmp[i]%P+P)*ans[i]%P;
        NTT(ans, -1, p);
        return ans.resize(n), ans;
    }
    
    inline void div(const vector<int> &a, const vector<int> &b, vector<int> &d, vector<int> &r){
        if(b.size()>a.size()) return (void)(d.clear(), r=a);
        vector<int> A=a, B=b, iB;
        int n=a.size(), m=b.size();
        reverse(A.begin(), A.end()), reverse(B.begin(), B.end());
        B.resize(n-m+1), iB=inv(B, n-m+1);
        d=multi(A, iB);
        d.resize(n-m+1), reverse(d.begin(), d.end());
        r=multi(b, d);
        for(int i=0; i<m-1; ++i) r[i]=(P+a[i]-r[i])%P;
        r.resize(m-1);
    }
    
    inline vector<int> der(const vector<int> &a){
        vector<int> ans;
        ans.resize(a.size()-1);
        for(unsigned i=1; i<a.size(); ++i) ans[i-1]=(ll)a[i]*i%P;
        return ans;
    }
    
    void evalinit(int l, int r, int t, const vector<int> &a){
        if(l==r) return p[t].clear(), p[t].push_back(P-a[l]), p[t].push_back(1);
        int mid=(l+r)/2, k=t<<1;
        evalinit(l, mid, k, a), evalinit(mid+1, r, k|1, a);
        p[t]=multi(p[k], p[k|1]);
    }
    
    inline void eval(int l, int r, int t, const vector<int> &f, const vector<int> &a){
        if(r-l+1<=512){
            for(int i=l; i<=r; ++i){
                int x=0, j=f.size(), a1=a[i], a2=(ll)a[i]*a[i]%P, a3=(ll)a[i]*a2%P, a4=(ll)a[i]*a3%P, a5=(ll)a[i]*a4%P, a6=(ll)a[i]*a5%P, a7=(ll)a[i]*a6%P, a8=(ll)a[i]*a7%P;
                while(j>=8)
                    x=((ll)x*a8+(ll)f[j-1]*a7+(ll)f[j-2]*a6+(ll)f[j-3]*a5+(ll)f[j-4]*a4+(ll)f[j-5]*a3+(ll)f[j-6]*a2+(ll)f[j-7]*a1+f[j-8])%P, j-=8;
                while(j--) x=((ll)x*a[i]+f[j])%P;
                ans.push_back(x);
            }
            return;
        }
        vector<int> tmp;
        div(f, p[t], tmp, tmp);
        eval(l, (l+r)/2, t<<1, tmp, a), eval((l+r)/2+1, r, t<<1|1, tmp, a);
    }
}

inline vector<int> eval(const vector<int> &f, const vector<int> &a, int flag=-1){
    if(flag==-1) p.resize(a.size()<<2), evalinit(0, a.size()-1, 1, a);
    ans.clear(), eval(0, a.size()-1, 1, f, a);
    return ans;
}

int main() {
    cin>>n>>m, x.resize(n), y.resize(m);
    for(int i=0; i<n; ++i) cin>>x[i];
    for(int i=0; i<m; ++i) cin>>y[i];
    y=eval(x,y);
    for(int i=0; i<m; ++i) cout<<y[i]<<' ';
    return 0;
}
```

---

## 作者：Rui_R (赞：4)

题意：题如其名，给出 $n$ 个点，求一个经过这 $n$ 个点的 $n-1$ 次多项式，模 $998244353$ 意义下。

[原题](https://www.luogu.com.cn/problem/P5158)

---

upd 2021-11-12：更新了代码，原代码会内存泄漏，真有我的

---

前置知识：
$$
\lim_{x\to \alpha}f(x)=0,\lim_{x\to \alpha} g(x)=0\to\lim_{x\to \alpha}\frac{f(x)}{g(x)}=\lim_{x\to \alpha}\frac{f'(x)}{g'(x)}
$$
也就是洛必达。

以及多项式多点求值。

---

首先我们有拉格朗日插值公式：
$$
f(x)=\sum_{i=1}^{n}y_i\cdot \prod_{j\ne i} \frac{x-x_j}{x_i-x_j}
$$
正确性显然，因为这是一个 $n-1$ 次多项式，并且把任何一个已知点的 $x$ 带进去都会算出来对应的 $y$ 。

可以先算出 $\ell(x)=\prod_{i=1}^{n}\limits (x-x_i)$ ，然后对于每个 $i$ ，通过模拟除法 $O(n)$ 得到 $\prod_{j\ne i}(x-x_j)$ ，并且 $\prod_{j\ne i}(x_i-x_j)$ 也可以 $O(n)$ 得到，所以我们有了一个 $O(n^2)$ 的做法。然而这个显然不行。

---

推一下式子：
$$
f(x)=\sum_{i=1}^{n}\frac{y_i}{\lim_{x\to x_i}\limits \frac{\ell(x)}{x-x_i}} \prod_{j\ne i} (x-x_j)
$$
好唉，那个 $\lim$ 上下都趋向于 $0$ ，上洛必达：
$$
f(x)=\sum_{i=1}^{n} \frac{y_i}{\lim_{x\to x_i}\limits \ell'(x)} \prod_{j\ne i} (x-x_j))=\sum_{i=1}^{n} \frac{y_i}{\ell'(x_i)} \prod_{j \ne i}(x-x_j)
$$
$\ell(x)$ 可以分治+$\text{NTT}$ 得到，$\ell'(x)$ 是多项式， $\ell'(x_i)$ 可以多点求值  $O(n\log^2 n) $ 得到。那么令 $\gamma_i=\dfrac{y_i}{\ell'(x_i)}$。
$$
f(x)=\sum_{i=1}^{n}\gamma_i\prod_{j\ne i}(x-x_j)
$$
这个可以分治求解，令

$$
f_{l,r}(x)=\sum_{i=l}^{r} \gamma_i\prod_{j=l,j\ne i}^{r} (x-x_j),mid= \lfloor \frac{l+r}{2} \rfloor
$$

则
$$
f_{l,r}(x)=\sum_{i=l}^{mid} \gamma_i \prod_{j=l,j \ne i}^{mid} (x-x_j) \prod_{j=mid+1}^{r} (x-x_j)+\sum_{i=mid+1}^{r} \gamma_i \prod_{j=mid+1,j \ne i}^{r}(x-x_j)\prod_{j=l}^{mid}(x-x_j)
$$

$$
f_{l,r}(x)=f_{l,mid}(x)\cdot \prod_{j=mid+1}^{r} (x-x_j) + f_{mid+1,r}(x)\cdot \prod_{j=l}^{mid} (x-x_j)
$$

并且 $\prod_{j=mid+1}^{r} \limits (x-x_j)$ 和 $\prod_{j=l}^{mid}\limits(x-x_j)$ 在之前求 $\ell(x)$ 的时候就已经求好了，那么就可以愉快的递归分治了。

递归边界为 $f_{i,i}(x)=\gamma_i$ 。复杂度 $O(n\log^2 n)$ 。

```cpp
#include <cstdio>
#include <cstring>

const int maxn = 3e6+5 , mod = 998244353;

template<typename T>
inline T max(const T &a,const T &b){
	return a>b?a:b;
}

template<typename T>
inline void swap(T &a,T &b){
	T temp=a;a=b;b=temp;
}

struct IO{
	IO(){};char c;
	inline char gc(){
		static char buf[maxn],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;
	}
	template<typename T>
	inline IO&operator>>(T &_){
		_=0;bool f=1;c=gc();while(c<'0'||c>'9'){if(c=='-') f=0; c=gc();}
		while(c>='0'&&c<='9'){_=_*10+c-48;c=gc();}if(!f) _=-_;return *this;
	}
	char buf[maxn];int p = 0;~IO(){fwrite(buf,1,p,stdout);}
	inline void pc(const char &c){
		buf[p++] = c;
		if(p==maxn) fwrite(buf,1,maxn,stdout),p=0;
	}
	template<typename T>
	inline IO&operator<<(T x){
		if(!x){pc(48);return *this;}static int wt[41],len;len=0;if(x<0){pc('-');x=-x;}
		for(;x;x/=10){wt[++len]=x%10;}
		while(len){pc(wt[len--]+48);}return *this;
	}
	inline IO&operator<<(const char &c){pc(c);return *this;}
}io;

int fastpow(int x,int y){
	if(y==0) return 1;int tmp=fastpow(x,y>>1);
	return y&1?1ll*tmp*tmp%mod*x%mod:1ll*tmp*tmp%mod ;
}

inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}

inline void copy(int *Alpha,int *Beta,int len){
	//Alpha -> Beta
	for(int i=0;i<len;i++) Alpha[i]=Beta[i];
}

namespace Poly{
	const int gate = 3,invg = fastpow(gate,mod-2);
	int lim,lg,sing[maxn];int Gate[maxn],Invg[maxn];int inv[maxn];
	void init(int len){
		lim = 1,lg = 0;while(lim<len) lim<<=1,lg++;
		for(int i=1;i<lim;i++) sing[i]=(sing[i>>1]>>1)|((i&1)<<(lg-1));
	}
	int Hacking_to_the(){
		for(int i=1;i<maxn;i<<=1) Gate[i] = fastpow(gate,(mod-1)/(i<<1)),Invg[i] = fastpow(invg,(mod-1)/(i<<1));
		// inv[1] = 1 ;for(int i=2;i<maxn;i++) inv[i] = (mod-1ll*(mod/i)*inv[mod%i]%mod) ;
		return 0 ;
	}
	int GATE = Hacking_to_the();
	void NTT(int *Steins,int type){
		for(int i=0;i<lim;i++) if(i<sing[i]) swap(Steins[i],Steins[sing[i]]);
		for(int len=1;len<lim;len<<=1){
			int unit = type==1?Gate[len]:Invg[len];
			for(int i=0;i<lim;i+=(len<<1)){
				int w = 1;
				for(int k=0;k<len;k++,w=1ll*w*unit%mod){
					int x=Steins[i+k],y=1ll*w*Steins[i+k+len]%mod;
					Steins[i+k]=add(x,y),Steins[i+k+len]=sub(x,y);
				}
			}
		}
		if(type!=1){int Okabe=fastpow(lim,mod-2);for(int i=0;i<lim;i++) Steins[i]=1ll*Steins[i]*Okabe%mod;}
	}
	void convolution(int *Alpha,int la,int *Beta,int lb,int *Zeta){
		init(la+lb-1);for(int i=la;i<lim;i++) Alpha[i]=0;for(int i=lb;i<lim;i++) Beta[i]=0;
		NTT(Alpha,1),NTT(Beta,1);
		for(int i=0;i<lim;i++) Zeta[i]=1ll*Alpha[i]*Beta[i]%mod;return NTT(Zeta,-1) ;
	}
	int g[maxn];
	void get_inv(int *Alpha,int len,int *Beta){
		//使用前清空Beta数组
		if(len==1){Beta[0]=fastpow(Alpha[0],mod-2);return ;}
		get_inv(Alpha,(len+1)>>1,Beta);init(len+len-1);
		copy(g,Alpha,len);for(int i=len;i<lim;i++) g[i] = 0;
		NTT(Beta,1),NTT(g,1);
		for(int i=0;i<lim;i++) Beta[i]=1ll*Beta[i]*(mod+2-1ll*Beta[i]*g[i]%mod)%mod;
		NTT(Beta,-1);
		for(int i=len;i<lim;i++) Beta[i]=0;
	}
	const int inv2=fastpow(2,mod-2);
	int t[maxn];
	void get_sqrt(int *Alpha,int len,int *Beta){
		//使用前清空Beta数组
		if(len==1){Beta[0]=1;return ;}get_sqrt(Alpha,(len+1)>>1,Beta);
		get_inv(Beta,len,t);
		init(len+len-1);copy(g,Alpha,len);for(int i=len;i<lim;i++) g[i]=0;
		convolution(g,len,t,len,g);
		for(int i=0;i<lim;i++) Beta[i]=1ll*inv2*(Beta[i]+g[i])%mod;
		for(int i=len;i<lim;i++) Beta[i]=0;for(int i=0;i<lim;i++) t[i]=0;
	}
	void derivative(int *Alpha,int len,int *Beta){
		for(int i=1;i<len;i++) Beta[i-1]=1ll*i*Alpha[i]%mod;
		Beta[len-1] = 0;
	}
	void integral(int *Alpha,int len,int *Beta){
		for(int i=len-1;i>=1;i--) Beta[i]=1ll*Alpha[i-1]*inv[i];
		Beta[0] = 0;
	}
	int f1[maxn],f2[maxn];
	void get_ln(int *Alpha,int len,int *Beta){
		memset(f2,0,sizeof(f2));
		derivative(Alpha,len,f1),get_inv(Alpha,len,f2);
		convolution(f1,len,f2,len,Beta);
		return integral(Beta,len,Beta) ;
	}
	int e1[maxn],e2[maxn];
	void get_exp(int *Alpha,int len,int *Beta){
		//使用前清空Beta数组
		if(len==1) return void(Beta[0]=1);
		get_exp(Alpha,(len+1)>>1,Beta);get_ln(Beta,len,e1);
		init(len+len-1);
		for(int i=0;i<len;i++) e2[i] = sub(Alpha[i],e1[i]);for(int i=len;i<lim;i++) e2[i]=0;
		NTT(e2,1),NTT(Beta,1);
		for(int i=0;i<lim;i++) Beta[i]=1ll*Beta[i]*(e2[i]+1)%mod;
		NTT(Beta,-1);
		for(int i=len;i<lim;i++) Beta[i]=0;for(int i=0;i<lim;i++) e1[i]=0;
	}
	int g1[maxn],g2[maxn],g3[maxn];
	void division(int *Alpha,int la,int *Beta,int lb,int *Zeta,int *Gamma){
		//Zeta's length requires 2la-lb
		if(la<lb){
			for(int i=0;i<=la-lb;i++) Zeta[i] = 0;
			for(int i=la;i<lb;i++) Gamma[i] = 0;return copy(Gamma,Alpha,la);
		}
		for(int i=0;i<la;i++) g1[i]=Alpha[la-i-1];for(int i=0;i<lb;i++) g2[i]=Beta[lb-i-1];
		for(int i=lb;i<=la-lb;i++) g2[i]=0;
		lim=1;while(lim<=(la-lb)<<1) lim<<=1;for(int i=0;i<lim;i++) g3[i]=0;
		get_inv(g2,la-lb+1,g3);
		convolution(g1,la,g3,la-lb+1,Zeta);for(int i=0;i<la-lb-i;i++) swap(Zeta[i],Zeta[la-lb-i]);
		for(int i=la-lb+1;i<lim;i++) Zeta[i]=0;
		copy(g1,Beta,lb);copy(g2,Zeta,la-lb+1);
		convolution(g1,lb,g2,la-lb+1,g1);for(int i=0;i<lb;i++) Gamma[i]=sub(Alpha[i],g1[i]);
	}
}

namespace Multi_point{
	int *gate[maxn<<2];
	void init(int now,int l,int r,int *Alpha){
		if(l==r){gate[now] = new int[2];gate[now][0]=mod-Alpha[l],gate[now][1]=1;return ;}
		int mid = (l+r) >> 1,lim = 1;while(lim<r-l+1+1) lim<<=1;
		gate[now] = new int[lim];
		int *g1 = new int[lim],*g2 = new int[lim];
		init(now<<1,l,mid,Alpha),init(now<<1|1,mid+1,r,Alpha);
		copy(g1,gate[now<<1],mid-l+1+1);
		copy(g2,gate[now<<1|1],r-mid+1);
		return Poly::convolution(g1,mid-l+1+1,g2,r-mid+1,gate[now]) ;
	}
	void evaluation(int now,int l,int r,int *Alpha,int *Beta,int *Zeta){
		//Alpha->f(x),Beta->S{x}
		if(r-l+1<=256){
			for(int i=l;i<=r;i++){
				int answer = 0;int base = 1;
				for(int j=0;j<=r-l;j++,base=1ll*base*Beta[i]%mod)
				answer = (answer + 1ll*base*Alpha[j]) % mod;
				Zeta[i] = answer;
			}
			return ;//Which makes it faster;
		}
		int mid = (l+r) >> 1,lim = 1;while(lim<r-l+1+1) lim<<=1;
		int *g1,*g2;g1 = new int[lim<<1],g2 = new int[lim];
		Poly::division(Alpha,r-l+1,gate[now<<1],mid-l+1+1,g1,g2);
		evaluation(now<<1,l,mid,g2,Beta,Zeta);
		Poly::division(Alpha,r-l+1,gate[now<<1|1],r-mid+1,g1,g2);
		evaluation(now<<1|1,mid+1,r,g2,Beta,Zeta);
		delete[] g1,delete[] g2;
	}
	int g1[maxn],g2[maxn];
	void Evaluation(int *Alpha,int len,int *Beta,int n,int *Zeta){
		init(1,1,n,Beta);Poly::division(Alpha,len,gate[1],n+1,g1,g2);
		return evaluation(1,1,n,g2,Beta,Zeta) ;
	}
	int f1[maxn],f2[maxn],ell[maxn];
	int *Steins[maxn<<1],e1[maxn],e2[maxn],G1[maxn],G2[maxn];
	void interpolation(int now,int l,int r){
		if(l==r){
			Steins[now] = new int[1];
			return void(Steins[now][0] = ell[l]);
		}
		Steins[now] = new int[r-l+1];
		int mid = (l+r) >> 1,lim = 1;
		interpolation(now<<1,l,mid),interpolation(now<<1|1,mid+1,r);
		while(lim<(r-l+1)) lim<<=1;
		copy(G1,Steins[now<<1],mid-l+1),copy(G2,Steins[now<<1|1],r-mid);
		copy(e1,gate[now<<1|1],r-mid+1),copy(e2,gate[now<<1],mid-l+1+1);
		Poly::convolution(e1,r-mid+1,G1,mid-l+1,e1);
		Poly::convolution(e2,mid-l+1+1,G2,r-mid,e2);
		for(int i=0;i<=r-l;i++) Steins[now][i]=(e1[i]+e2[i])%mod;
	}
	void Interpolation(int *Alpha,int *Beta,int n,int *Zeta){
		//Alpha->x,Beta->y
		init(1,1,n,Alpha);copy(f1,gate[1],n+1);Poly::derivative(f1,n+1,f2);
		evaluation(1,1,n,f2,Alpha,ell);
		for(int i=1;i<=n;i++) ell[i]=1ll*Beta[i]*fastpow(ell[i],mod-2)%mod;
		interpolation(1,1,n);
		return copy(Zeta,Steins[1],n) ;
	}
}

int n ;int Alpha[maxn],Beta[maxn],Zeta[maxn];

int main(){
	scanf("%d",&n);for(int i=1;i<=n;i++) scanf("%d%d",&Alpha[i],&Beta[i]);
	Multi_point::Interpolation(Alpha,Beta,n,Zeta);
	for(int i=0;i<n;i++) io << Zeta[i] << " \n"[i==n-1];
	return 0;
}

/*
7
0 1
17 214151313
-121 235759984
1001 -137241143
996 655399767
-12 -23201855
499000000 224897344
*/

```



---

## 作者：Rorschachindark (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5158)
# 题目大意
给出$n$个点$(x_i,y_i)$，求出经过这$n$个点的一个$n-1$次多项式。

$n\le 10^5$
# 思路
差点卡常死在这里。论多项式里面的调参（有$\texttt{SA}$内味了）（雾

我们发现这个东西我们显然可以使用拉格朗日插值法，我们可以求到答案为:

$$\sum_{i=1}^{n} y_i\prod_{j=1\wedge i\not= j} \frac{x-x_j}{x_i-x_j}$$

变一下我们就可以得到:

$$\sum_{i=1}^{n} \frac{y_i}{\prod_{j=1\wedge i\not= j}^{n}(x_i-x_j)}\prod_{j=1\wedge i\not= j}^{n} (x-x_j)$$

我们假设$g(x)=\prod_{i=1}^{n}(x-x_i)$，那么上面的式子就是:

$$\sum_{i=1}^{n} \frac{y_i}{\frac{g(x_i)}{x_i-x_i}}\prod_{j=1\wedge i\not= j}^{n}(x-x_j)$$

我们发现$\frac{g(x_i)}{x_i-x_i}$可以使用洛必达法则求到，答案即为$g^{'}(x_i)$。

所以式子就是:

$$\sum_{i=1}^{n} \frac{y_i}{g^{'}(x_i)} \prod_{j=1\wedge i\not= j}^{n} (x-x_j)$$

我们发现这个式子如果我们直接求的话会炸成$\Theta(n^2\log^2n)$，但是我们发现可以使用分治解决这个问题。

我们假设当前区间为$l,r$，答案为$f_{l,r}$，中点为$mid$，那么可以得到:

$$f_{l,r}=\sum_{i=l}^{r} (\frac{y_i}{g^{'}(x_i)}\prod_{j=l\wedge i\not= j}^{r}(x-x_j))$$

我们从中间拆开就可以得到:

$$f_{l,r}=\prod_{k=mid+1}^{r}(x-x_k)(\sum_{i=l}^{mid} \frac{y_i}{g^{'}(x_i)}\prod_{j=l\wedge i\not=j}^{mid}(x-x_j))+\prod_{k=l}^{mid}(x-x_k)(\sum_{i=mid+1}^{r} \frac{y_i}{g^{'}(x_i)}\prod_{j=mid+1\wedge i\not=j}^{r}(x-x_j))$$

即:

$$f_{l,r}=\prod_{k=mid+1}^{r} (x-x_k) f_{l,mid}+\prod_{k=l}^{mid} (x-x_k)f_{mid+1,r}$$

于是我们就可以直接分治解决了。至于$g^{'}(x_i)$可以使用多项式多点求值$\Theta(n\log ^2n)$预处理求出来，每一层的$\prod_{k=l}^{r}(x-x_k)$也可以使用分治求出来。总时间复杂度根据主定理为$F(n)=F(n/2)+\Theta(n\log n)=\Theta(n\log^2n)$。

但是这道题有点卡常，所以多项式多点求值的地方需要调参，我差点自闭了。。。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define SZ(x) ((int)x.size())
#define Int register int
#define mod 998244353
#define ll long long
#define MAXN 1000005

int mul (int a,int b){return 1ll * a * b % mod;}
int dec (int a,int b){return a >= b ? a - b : a + mod - b;}
int add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}
int qkpow (int a,int k){
	int res = 1;for (;k;k >>= 1,a = 1ll * a * a % mod) if (k & 1) res = 1ll * res * a % mod;
	return res;
}
int inv (int x){return qkpow (x,mod - 2);}

typedef vector <int> poly;

int w[MAXN],rev[MAXN];

void init_ntt (){
	int lim = 1 << 18;
	for (Int i = 0;i < lim;++ i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << 17);
	int Wn = qkpow (3,(mod - 1) / lim);w[lim >> 1] = 1;
	for (Int i = lim / 2 + 1;i < lim;++ i) w[i] = mul (w[i - 1],Wn);
	for (Int i = lim / 2 - 1;i;-- i) w[i] = w[i << 1];
}

void ntt (poly &a,int lim,int type){
#define G 3
#define Gi 332748118
	static int d[MAXN];
	for (Int i = 0,z = 18 - __builtin_ctz(lim);i < lim;++ i) d[rev[i] >> z] = a[i];
	for (Int i = 1;i < lim;i <<= 1)
		for (Int j = 0;j < lim;j += i << 1)
			for (Int k = 0;k < i;++ k){
				int x = mul (w[i + k],d[i + j + k]);
				d[i + j + k] = dec (d[j + k],x),d[j + k] = add (d[j + k],x);
			}
	for (Int i = 0;i < lim;++ i) a[i] = d[i] % mod;
	if (type == -1){
		reverse (a.begin() + 1,a.begin() + lim);
		for (Int i = 0,Inv = inv (lim);i < lim;++ i) a[i] = mul (a[i],Inv);
	}
#undef G
#undef Gi 
}

poly operator + (poly a,poly b){
	a.resize (max (SZ (a),SZ (b)));
	for (Int i = 0;i < SZ (b);++ i) a[i] = add (a[i],b[i]);
	return a;
}

poly operator - (poly a,poly b){
	a.resize (max (SZ (a),SZ (b)));
	for (Int i = 0;i < SZ (b);++ i) a[i] = dec (a[i],b[i]);
	return a;
}

poly operator * (poly a,int b){
	for (Int i = 0;i < SZ (a);++ i) a[i] = mul (a[i],b);
	return a;
}

poly der (poly a){
	for (Int i = 0;i < SZ (a) - 1;++ i) a[i] = mul (a[i + 1],i + 1);
	a.pop_back ();return a;
}

poly operator * (poly a,poly b){
	int d = SZ (a) + SZ (b) - 1,lim = 1;while (lim < d) lim <<= 1;
	a.resize (lim),b.resize (lim);
	ntt (a,lim,1),ntt (b,lim,1);
	for (Int i = 0;i < lim;++ i) a[i] = mul (a[i],b[i]);
	ntt (a,lim,-1),a.resize (d);
	return a;
}

poly inv (poly a,int n){
	poly b(1,inv (a[0])),c;
	for (Int l = 4;(l >> 2) < n;l <<= 1){
		c.resize (l >> 1);
		for (Int i = 0;i < (l >> 1);++ i) c[i] = i < n ? a[i] : 0;
		c.resize (l),b.resize (l);
		ntt (c,l,1),ntt (b,l,1);
		for (Int i = 0;i < l;++ i) b[i] = mul (b[i],dec (2,mul (b[i],c[i])));
		ntt (b,l,-1),b.resize (l >> 1);
	}
	b.resize (n);
	return b;
}

poly inv (poly a){return inv (a,SZ (a));}

poly Mod (poly F,poly G){
	int n = SZ (F) - 1,m = SZ (G) - 1;poly Q;Q.resize (m + 1);for (Int i = 0;i <= m;++ i) Q[i] = G[i];
	reverse (F.begin(),F.end()),reverse (G.begin(),G.end()),reverse (Q.begin(),Q.end()),Q.resize (n - m + 1),Q = inv (Q) * F,Q.resize (n - m + 1),reverse (Q.begin(),Q.end());
	reverse (F.begin(),F.end()),reverse (G.begin(),G.end()),Q = G * Q,Q.resize (m),Q = F - Q,Q.resize (m);
	return Q;
}

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,a[MAXN],bb[MAXN],AAns[MAXN];
poly AAA,D[MAXN << 2],DR[MAXN << 2];

void divide1 (int i,int l,int r){
	if (l == r) return DR[i].resize (2),DR[i][0] = mod - a[l],DR[i][1] = 1,void ();
	int mid = (l + r) >> 1;divide1 (i << 1,l,mid),divide1 (i << 1 | 1,mid + 1,r);
	DR[i] = DR[i << 1] * DR[i << 1 | 1];
}

ll c1,c2,c3,c4,b[17];

void divide2 (int i,int l,int r,poly AA){
	if (r - l <= 512){
		for (Int i = l;i <= r;++ i){
			int x = a[i];b[0] = 1;int now = r - l;
			for (Int j = 1;j <= 16;++ j) b[j] = b[j - 1] * x % mod;
			ll Ans = AA[now];
			for (Int j = now - 1;j - 15 >= 0;j -= 16){
				c1 = Ans * b[16] + AA[j] * b[15] + AA[j - 1] * b[14] + AA[j - 2] * b[13],c1 %= mod;
				c2 = AA[j - 3] * b[12] + AA[j - 4] * b[11] + AA[j - 5] * b[10] + AA[j - 6] * b[9],c2 %= mod;
				c3 = AA[j - 7] * b[8] + AA[j - 8] * b[7] + AA[j - 9] * b[6] + AA[j - 10] * b[5],c3 %= mod;
				c4 = AA[j - 11] * b[4] + AA[j - 12] * b[3] + AA[j - 13] * b[2] + AA[j - 14] * b[1],c4 %= mod;
				Ans = (c1 + c2 + c3 + c4 + AA[j - 15]) % mod;
			} 
			for (Int j = now % 16 - 1;~j;-- j) Ans = (Ans * x + AA[j]) % mod;
			AAns[i] = Ans;
		}
		return ;
	}
	if (l == r) return write (AA[0]),putchar ('\n'),void ();
	poly B = Mod (AA,DR[i << 1]);int mid = (l + r) >> 1;divide2 (i << 1,l,mid,B);B = Mod (AA,DR[i << 1 | 1]);divide2 (i << 1 | 1,mid + 1,r,B);
}

void divide3 (int i,int l,int r){
	if (l == r) return D[i].resize (1),D[i][0] = mul (bb[l],inv (AAns[l])),void ();
	int mid = (l + r) >> 1;divide3 (i << 1,l,mid),divide3 (i << 1 | 1,mid + 1,r);
	D[i] = DR[i << 1 | 1] * D[i << 1] + DR[i << 1] * D[i << 1 | 1];
}

signed main(){
	init_ntt(),read (n);
	for (Int i = 1;i <= n;++ i) read (a[i],bb[i]);
	divide1 (1,1,n),AAA = der (DR[1]),divide2 (1,1,n,AAA),divide3 (1,1,n);
	for (Int i = 0;i < n;++ i) write (D[1][i]),putchar (' ');putchar ('\n');
	return 0;
}
```

---


# [Cnoi2019] 最终幻想

## 题目背景

理论上来说，压轴的应该是一道数据结构题，可是它咕咕咕~了.

## 题目描述

你有一个 $n$ 维超球, 求使用 $k$ 个 $n-1$ 维超平面可以将这个 $n$ 维超球划分成多少个 $n$ 维块。

答案对 $998244353$ 取模。

## 说明/提示

Subtask1( 21pts ) : $n \le 10^6$

Subtask2( 7pts )   : $k \le n$

Subtask3( 72pts ) : 无特殊限制

对于 100% 的数据 $n, k \in [1,998244353)$

## 样例 #1

### 输入

```
3 4```

### 输出

```
15```

# 题解

## 作者：searchstar (赞：13)

[yamengxi](https://www.luogu.com.cn/blog/yamengxi/solution-p5388) 大佬写了一个优美的公式，但是没有给出证明。时隔两年，本蒟蒻终于可以帮大佬补个证明了。

假设答案是 $f_n(k)$ ，那么根据 [c__z__a](https://www.luogu.com.cn/blog/401583/solution-p5388) 的题解，可以得到以下递推表达式：

$$f_n(k) = \begin{cases}
\sum_{i=0}^{k-1}f_{n-1}(i) + 1 & n > 1 \\
k + 1 & n = 1
\end{cases}$$

下面用母函数来求 $f_n(k)$ 的通项。设

$$G_n(x) = \sum_{k=0}^{\infty}f_n(k) x^k$$

那么有

$$\begin{aligned}
G_1(x) =& \sum_{k=0}^{\infty}f_1(k) x^k \\
=& \sum_{k=0}^{\infty}(k+1)x^k \\
=& (\sum_{k=0}^{\infty}x^{k+1})' \\
=& (\sum_{k=1}^{\infty}x^k)' \\
=& (\sum_{k=0}^{\infty}x^k - 1)' \\
=& (\frac{1}{1-x} - 1)' \\
=& \frac{1}{(1-x)^2}
\end{aligned}$$

$n>1$ 时，有

$$\begin{aligned}
G_n(x) =& \sum_{k=0}^{\infty}f_n(k) x^k \\
=& \sum_{k=0}^{\infty}(\sum_{i=0}^{k-1}f_{n-1}(i) + 1)x^k \\
=& \sum_{k=0}^{\infty}x^k + \sum_{k=0}^{\infty}(\sum_{i=0}^{k-1}f_{n-1}(i))x^k \\
=& \frac{1}{1-x} + x\sum_{k=0}^{\infty}(\sum_{i=0}^k f_{n-1}(i))x^k \\
=& \frac{1}{1-x} + x(\sum_{k=0}^{\infty}f_{n-1}(k)x^k)(\sum_{k=0}^{\infty}x^k) \\
=& \frac{1}{1-x} + \frac{x}{1-x}G_{n-1}(x)
\end{aligned}$$

所以

$$G_2(x) = \frac{x}{(1-x)^3} + \frac{1}{1-x}$$

$$G_3(x) = \frac{x^2}{(1-x)^4} + \frac{x}{(1-x)^2} + \frac{1}{1-x}$$

$$\begin{aligned}
G_n(x) =& \frac{x^{n-1}}{(1-x)^{n+1}} + \sum_{i=0}^{n-2}\frac{x^i}{(1-x)^{i+1}} \\
=& \frac{x^{n-1}}{(1-x)^{n+1}} + \frac{1}{1-x} \frac{1-\frac{x^{n-1}}{(1-x)^{n-1}}}{1-\frac{x}{1-x}} \\
=& \frac{x^{n-1}}{(1-x)^{n+1}} + \frac{1-\frac{x^{n-1}}{(1-x)^{n-1}}}{1-2x} \\
=& \frac{1}{1-2x} + \frac{x^{n-1}}{(1-x)^{n+1}} - \frac{1}{1-2x} \frac{x^{n-1}}{(1-x)^{n-1}} \\
=& \frac{1}{1-2x} + \frac{x^{n-1}}{(1-x)^{n-1}} (\frac{1}{(1-x)^2} - \frac{1}{1-2x}) \\
=& \frac{1}{1-2x} + \frac{x^{n-1}}{(1-x)^{n-1}} \frac{-x^2}{(1-2x)(1-x)^2} \\
=& \frac{1}{1-2x} - \frac{1}{1-2x} \frac{x^{n+1}}{(1-x)^{n+1}}
\end{aligned}$$

$\frac{1}{1-2x}$ 的第 $k$ 项是 $2^k$ ， $\frac{1}{(1-x)^{n+1}}$ 的第 $k$ 项是 $C_{n+k}^{n}$ ，所以 $\frac{1}{1-2x} \frac{1}{(1-x)^{n+1}}$ 的第 $k$ 项是 $\sum_{i=0}^k C_{n+i}^{n} 2^{k-i}$ ，所以 $\frac{1}{1-2x} \frac{x^{n+1}}{(1-x)^{n+1}}$ 的第 $k$ 项是

$$\begin{cases}
0 & k \le n \\
\sum_{i=0}^{k-n-1} C_{n+i}^{n} 2^{k-n-1-i} & k > n
\end{cases}$$

所以 $G_n(x)$ 的第 $k$ 项是

$$\begin{cases}
2^k & k \le n \\
2^k - \sum_{i=0}^{k-n-1} C_{n+i}^{n} 2^{k-n-1-i} & k > n
\end{cases}$$

~~咦？怎么跟 yamengxi 的不太一样？~~

此外，我完全看不出这个东西怎么能化简到 $\sum_{i=0}^n C_k^i$ ，希望未来有大佬可以补上这个证明。

---

## 作者：cosmicAC (赞：12)

这题一看就是要求$F(n,k)=\sum_{i=0}^{n}\binom{k}{i}$。然而怎么只有21分？原来n最大可以到mod-1。

于是考虑经典的分块打表。记录一部分的$F(n,k)$，根据洛谷的代码上限50KB，可以计算得到最多能记录10000个数不到。所以我们可以每隔1e7个数记录一个$F(n,k)$。（**打表程序需要求$1\ldots mod-1$的逆元，并且复杂度是$O(100\times mod)$，所以需要很长的时间与大概4G的空间。**）

然后问题就变成了：给定$F(n,k)$，求$F(n+\Delta n,k+\Delta k)$。这个问题可以拆成两个部分，就是从$F(n,k)$求$F(n,k+1)$和$F(n+1,k)$。

从$F(n,k)$求$F(n+1,k)$很简单，就是加上一个$\binom{k}{n+1}$。然后考虑到$\binom{k+1}{n}=\binom{k}{n}+\binom{k}{n-1}$，有
$$F(n,k+1)=\sum_{i=0}^{n}\binom{k+1}{i}$$
$$=\sum_{i=0}^{n}\binom{k}{i}+\binom{k}{i-1}$$
$$=\sum_{i=0}^{n}\binom{k}{i}+\sum_{i=0}^{n-1}\binom{k}{i}$$
$$=2F(n,k)-\binom{k}{n}$$
所以问题被转化为了求一行组合数和一列组合数。先再次打表记录$n!$，暴力求出一个组合数。然后考虑从$\binom{n}{k}$变成$\binom{n}{k+1}$和$\binom{n+1}{k}$，都只要乘一个数再除以一个数，就只需要求2e7个数的逆元，直接离线线性求逆即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int siz=10507835;
const ll mod=998244353;
//省略打表数组
int n,k,inv1[siz+10],inv2[siz+10];
ll po(ll a,ll b){ll r=1;for(;b;b/=2,a=a*a%mod)if(b&1)r=r*a%mod;return r;}
ll fac(int x){
	ll r=fc[x/siz];
	for(int i=x/siz*siz+1;i<=x;i++)(r*=i)%=mod;
	return r;
}
ll C(int x,int y){return fac(x)*po(fac(y),mod-2)%mod*po(fac(x-y),mod-2)%mod;}
int main(){
	scanf("%d%d",&n,&k);
	if(n>=k)printf("%lld\n",po(2,k)),exit(0);
	int kk=k/siz*siz,nn=n/siz*siz;
	inv1[0]=inv2[0]=1;
	
	for(int i=1;i<=k-kk;i++)inv1[i]=1ll*inv1[i-1]*(i+kk-nn)%mod;
	ll now=po(inv1[k-kk],mod-2);if(k>kk)inv1[k-kk]=now*inv1[k-kk-1]%mod;
	for(int i=k-kk-1;i>0;i--)
		(now*=i+1+kk-nn)%=mod,inv1[i]=now*inv1[i-1]%mod;
	for(int i=1;i<=n-nn;i++)inv2[i]=1ll*inv2[i-1]*(i+nn)%mod;
	now=po(inv2[n-nn],mod-2);if(n>nn)inv2[n-nn]=now*inv2[n-nn-1]%mod;
	for(int i=n-nn-1;i>0;i--)
		(now*=i+1+nn)%=mod,inv2[i]=now*inv2[i-1]%mod;
	
	ll res=db[k/siz][n/siz];now=C(kk,nn);
	for(int t=kk;t<k;t++){
		res=(2*res-now)%mod;
		(now*=1ll*(t+1)*inv1[t-kk+1]%mod)%=mod;
	}
	for(int t=nn;t<n;t++){
		(now*=1ll*inv2[t-nn+1]*(k-t)%mod)%=mod;
		(res+=now)%=mod;
	}
	printf("%lld\n",(res+mod)%mod);
	return 0;
}
```

---

## 作者：bcdmwSjy (赞：6)

题解怎么都在分段打表啊，这里给出一种更加友好的求解方式（指对电脑友好，不需要打表）。

首先，我们要明确这道题要求的是 $\sum\limits^n_{i=0}\binom ki$，但是这篇文章的重点不在推导出这个答案，详细的推导过程可以看其他题解。

这里给出一种时间复杂度为 $O(\sqrt n\log n)$ 的组合数前缀和算法。

思路与快速阶乘算法一致，同样先分块，我们发现 $\binom n{m+1}=\frac{n-m}{m+1}\binom nm$，再把它写成矩阵形式，带上前缀和，可以得到

$$\begin{bmatrix}
\binom n{m+1}\\
\sum\limits^m_{i=0}\binom ni
\end{bmatrix}=\left(\prod\limits^m_{i=0}
\begin{bmatrix}
\frac{n-i}{i+1}&0\\
1&1 
\end{bmatrix}\right)
\begin{bmatrix}
1\\
0
\end{bmatrix}$$

注意上面的乘积顺序运算是从右向左的（即每次把矩阵放到左边和之前的结果相乘）。

但是这个矩阵中带有分数，并不好计算，所以先通分，再把分母提出来，即 $(m+1)!$，化简后得到

$$\frac 1{(m+1)!}\left(\prod\limits^m_{i=0}
\begin{bmatrix}
n-i&0\\
i+1&i+1 
\end{bmatrix}\right)
\begin{bmatrix}
1\\
0
\end{bmatrix}$$

现在只需要维护 $3$ 个点值 $f,g,h$，倍增计算

$\begin{bmatrix}
f_{2m}(x)&0\\
g_{2m}(x)&h_{2m}(x)
\end{bmatrix}=\begin{bmatrix}
f_{m}(x+m)&0\\
g_{m}(x+m)&h_{m}(x+m)
\end{bmatrix}
\begin{bmatrix}
f_{m}(x)&0\\
g_{m}(x)&h_{m}(x)
\end{bmatrix}$

手动计算一下矩阵乘法可以得到

$$\begin{bmatrix}
f_m(x)f_m(x+m)&0\\
f_m(x)g_m(x+m)+g_m(x)h_m(x+m)&h_m(x)h_m(x+m)
\end{bmatrix}$$

直接每轮跑 $6$ 次点值平移，倍增即可，实现时取块长为 $2^{\lceil\log_2\sqrt m\rceil}$，这样可以避免出现从 $m$ 转移到 $m+1$ 的情况。

最后答案要除以 $(m+1)!$，但此时我们不需要单独计算一次阶乘，上面的 $h$ 实际上维护的就是阶乘的点值，同时算出来就好了。

参考实现：

```cpp
int sumcomb(int n,int m,const int mod){
	m=min(n,m)+1;
	// 注意这里，上面式子中乘积下标是从 0 开始的，但是这里计算从 1 开始，所以加上 1 再计算
	MPoly f(2),g(2),h(2);
	f.setmod(mod),g.setmod(f.fm),h.setmod(f.fm);
	int B=1<<int(ceil(0.5*log2(m))),r=qpow(B,mod-2,f.fm),siz=m/B;
	f.a[0]=n,f.a[1]=n-B;
	g.a[0]=1,g.a[1]=B+1;
	h.a[0]=1,h.a[1]=B+1; // 初始值
	for (int l=2;l<=B;l<<=1){
		f.extend(pointValueTranslation(f,(l>>1)+1));
		g.extend(pointValueTranslation(g,(l>>1)+1));
		h.extend(pointValueTranslation(h,(l>>1)+1));
		MPoly u=pointValueTranslation(f,r*ll(l>>1)%f.fm);
		MPoly v=pointValueTranslation(g,r*ll(l>>1)%f.fm);
		MPoly w=pointValueTranslation(h,r*ll(l>>1)%f.fm);
		g.mulcoefficient(w);
		g+=v.mulcoefficient(f);
		f.mulcoefficient(u);
		h.mulcoefficient(w);
		f.resize(l+1),g.resize(l+1),h.resize(l+1);
	}
	ll res1=1,res2=0,res3=1;
	for (int i=0;i<siz;i++){
		res2=(res1*g.a[i]+res2*h.a[i])%f.fm;
		res1=res1*f.a[i]%f.fm;
		res3=res3*h.a[i]%f.fm;
	}
	for (int i=siz*B+1;i<=m;i++){
		res2=(res1+res2)*i%f.fm;
		res1=res1*(n-i+1)%f.fm;
		res3=res3*i%f.fm;
	}
	// 计算零散部分
	return qpow(res3,f.mod-2,f.fm,res2);
}
```

时间复杂度为 $O(\sqrt n\log n)$，可以轻松通过。

前面的多项式部分可以看[这里](https://www.luogu.com.cn/article/ib11aqd7)。

更多题目：[loj6386](https://loj.ac/p/6386)，[U562050](https://www.luogu.com.cn/problem/U562050)（我自己的题，需要任意模数）。

---

## 作者：minstdfx (赞：4)

考虑固定 $k$，进行一个~~二向箔的反演~~维度的升。

如果 $n=0$，那么是一个点，怎么弄都只有一个点，所以答案为 $1$。

对于 $m$ 个 $n-1$ 维超平面，两两相交于一个 $n-2$ 维空间，三三不共 $n-2$ 维空间（考虑对于三个超平面交于一个 $n-2$ 维空间，微微扰动就能使出现更多的“原本被缩成一个点”的空间块），其余同理。

设 $P_n^m$ 为有 $m$ 个超平面，从 $n-1$ 维升到 $n$ 维的贡献。

特别的，当 $n=0$ 时，因为原本就有一块，所以 $P_0^m=1$。

维数升高了都没用，所以 $P_n^m=0\;(n>m)$。

考虑对于增加一个超平面的情况。这个超平面每经过一个已经被切割出来的块，它就会把那个块分隔成两个，并且与那个块的交集是一个超平面上的图形，它的每一条 $n-2$ 维边都是超平面与块的 $n-1$ 维面的交，也就是超平面与之前的超平面的交。因此被块的 $n-2$ 维边分割等价于被原本的超平面分割。

又，原本的超平面在现在新加的超平面中投下了 $m-1$ 个 $n-2$ 维的边，因此就是 **$m-1$ 个 $n-2$ 维超平面 分割 $n-1$ 维空间**的答案。

因此有：

$$P_n^m=\sum_{i=0}^{m-1}{P_{n-1}^{i}}$$

到这里就要证明 $P_n^m=C_m^n$。

首先边界条件显然相等。

然后，对于答案， $D_n^m=\sum_{i=0}^{n}{P_{i}^{m}}$

我们得出的结论 $D_n^m=D_n^{m-1}+D_{n-1}^{m-1}$

就是 
$$D_n^m=\sum_{i=0}^{n}{P_{i}^{m}}=\sum_{i=0}^{n}{P_{i}^{m-1}}+\sum_{i=0}^{n-1}{P_{i}^{m-1}}$$

两两相减，

$$P_n^m=P_n^{m-1}+P_{n-1}^{m-1}$$

这一步都出来了。结合 $P_n^m=0\;(n>m)$ 和 $P_0^m=1$，可以知道 $P_n^m=C_m^n$。

因此答案 $D_n^m=\sum_{i=0}^n{C_m^i}$ 就出来了，然后分段打表就行了。

---

## 作者：LKY928261 (赞：1)

非常有趣的推柿子题。

### Part 1. 列式子

记 $f_k(n)$ 表示 $k$ 维的情况下用 $n$ 个 $k-1$ 维平面能切出来的块数的最大值。注意：这与题面中的定义恰好相反。

考虑如何在 $f_k(n-1)$ 的基础上多切一刀。设新加入的这个平面被原来已有的平面划分成了 $x$ 个部分，而其中每个部分都对应着一个被一分为二的原来的块，所以切完后的块数比原来增加了 $x$。

那么这个 $x$ 的最大值是多少呢？新加入的 $k-1$ 维平面与原来的 $n-1$ 个平面产生了 $n-1$ 条交线，求 $x$ 的最大值就是求这 $n-1$ 条交线最多将这个 $k-1$ 维平面分成了多少块。而这恰好就是 $f_{k-1}(n-1)$。

于是我们得到了 $f_k(n)$ 的递推式：

$$f_k(n)=f_k(n-1)+f_{k-1}(n-1)$$

至于边界情况：

- 在零维时，一个点永远不能再分，故 $f_0(n)=1$；
- 在不切的情况下永远只有一部分，故 $f_k(0)=1$。

于是：

$$
f_k(n)=\left\{\begin{matrix} 
1, & k=0 \lor n=0\\
f_k(n-1)+f_{k-1}(n-1), & k>0 \land n>0
\end{matrix}\right.
$$

### Part 2. 推式子

先对写出来的式子递归转求和一下：

$$
f_k(n)=\left\{\begin{matrix} 
1,&k=0\\
1+\sum_{i=0}^{n-1}f_{k-1}(i),&k>0
\end{matrix}\right.
$$

定义 $F_k$ 为函数 $f_k(n)$ 的生成函数，即 $F_k=\sum_{i=0}^{+\infty}f_k(i)x^i$。

将上面的式子改写一下：

$$F_0=\frac{1}{1-x}$$

$$F_k=\frac{1+x\cdot F_{k-1}}{1-x},(k>0)$$

就得到了 $F_k$ 的递推式。

然后设多项式 $T$ 满足 $G_k=F_k-T$ 是一个等比数列（~~或许应该叫“等比多项式列”？~~）。代入第二个式子得到：

$$
\begin{aligned}
G_k&=\frac{1+x\cdot(G_{k-1}+T)}{1-x}-T\\
&=\frac{x}{1-x}\cdot G_{k-1}+\left(\frac{1+x\cdot T}{1-x}-T\right)
\end{aligned}
$$

我们希望 $\{G_k\}$ 为等比数列，即后面的那堆为 $0$。

$$\frac{1+x\cdot T}{1-x}-T=0$$

解得：

$$T=\frac{1}{1-2x}$$

于是：

$$
\begin{aligned}
F_k&=G_k+T\\
&=G_0\cdot\left(\frac{x}{1-x}\right)^k+T\\
&=(F_0-T)\cdot\left(\frac{x}{1-x}\right)^k+T\\
&=\left(\frac{1}{1-x}-\frac{1}{1-2x}\right)\cdot\left(\frac{x}{1-x}\right)^k+\frac{1}{1-2x}
\end{aligned}
$$

接下来求 $f_k(n)$ 也就是 $[x^n]F_k$ 的值。

$$
\begin{aligned}
[x^n]F_k&=[x^n]\left(\left(\frac{1}{1-x}-\frac{1}{1-2x}\right)\cdot\left(\frac{x}{1-x}\right)^k+\frac{1}{1-2x}\right)\\
&=[x^n]\frac{1}{1-2x}+[x^n]\frac{x^k}{(1-x)^{k+1}}-[x^n]\left(\frac{1}{1-2x}\cdot\frac{x^k}{(1-x)^k}\right)\\
&=2^n+[x^{n-k}]\frac{1}{(1-x)^{k+1}}-[x^{n-k}]\left(\frac{1}{1-2x}\cdot\frac{1}{(1-x)^k}\right)\\
&=2^n+\binom{n}{k}-\sum_{i=0}^{n-k}\binom{i+k-1}{k-1}2^{n-k-i}
\end{aligned}
$$

现在只需要化简后面那个和式。考虑组合意义推导。

想象有 $n-1$ 个白球，用一个挡板分成左右两边，要从左边的 $i+k-1$ 个中选出恰好 $k-1$ 个染黑，右边的 $n-k-i$ 个任意，挡板的位置不同或球的颜色不同都算作不同方案。显然这个方案数就是 $\sum_{i=0}^{n-k}\binom{i+k-1}{k-1}2^{n-k-i}$。

然后考虑将上述情形中的“挡板”替换成一个“黑球”，此时由于挡板左侧有恰好 $k-1$ 个黑球，挡板就成了从左往右数的第 $k$ 个黑球。

现在的组合意义就变成了：从 $n$ 个白球中选出若干个球进行染黑，其中从左往右的第 $k$ 个黑球就是原来的挡板。因为挡板必须存在，所以必须选出至少 $k$ 个球染黑，除此之外就没有别的限制了。所以方案数是 $\sum_{i=k}^{n}\binom{n}{i}$。

现在将这个代回原式：

$$
\begin{aligned}
f_k(n)=[x^n]F_k&=2^n+\binom{n}{k}-\sum_{i=0}^{n-k}\binom{i+k-1}{k-1}2^{n-k-i}\\
&=2^n+\binom{n}{k}-\sum_{i=k}^{n}\binom{n}{i}\\
&=2^n-\sum_{i=k+1}^{n}\binom{n}{i}\\
&=\sum_{i=0}^{n}\binom{n}{i}-\sum_{i=k+1}^{n}\binom{n}{i}\\
&=\sum_{i=0}^{k}\binom{n}{i}
\end{aligned}
$$

### Part 3. 算式子

设 $D(n,k)=\sum_{i=0}^{k}\binom{n}{i}$。

考虑分段打表。

具体地，设打表块长为 $B$，则记录下每个 $D(iB,jB)$ 处的点值，求 $D(n,k)$ 时就从其左上方第一个 $D(iB,jB)$ 转移过来。

转移只需要知道 $D(x,y)\to D(x,y+1)$ 和 $D(x,y)\to D(x+1,y)$ 怎么算就行了。

对于 $D(x,y)\to D(x,y+1)$，显然有 $D(x,y+1)=D(x,y)+\binom{x}{y+1}$。

对于 $D(x,y)\to D(x+1,y)$，因为 $\binom{x}{y}=\binom{x-1}{y}+\binom{x-1}{y-1}$，所以：

$$
\begin{aligned}
D(x+1,y)&=\sum_{i=0}^{y}\binom{x+1}{i}\\
&=\sum_{i=0}^{y}\left(\binom{x}{i}+\binom{x}{i-1}\right)\\
&=2\sum_{i=0}^{y}\binom{x}{i}-\binom{x}{y}\\
&=2D(x,y)-\binom{x}{y}
\end{aligned}
$$

只要在算 $D(x,y)$ 的同时维护一下 $\binom{x}{y}$ 就好了。

最开始的那一个 $\binom{x}{y}$ 直接用暴力阶乘和快速幂求逆元来算，此处还需打一个阶乘的表。

组合数的转移是简单的，都是乘一个数再除一个数。

过程中会用到 $O(B)$ 个数的逆元，需要提前线性预处理出来。

什么？你说你不会预处理？

>对于 $n$ 个数 $a_1,a_2,\cdots,a_n$，要求它们各自在模同一质数 $M$ 意义下的逆元。
>
>首先算出 $b_i=\prod_{j=1}^{i}a_j$，令 $S=b_n^{-1}$。
>
>那么 $a_n^{-1}=S\times b_{n-1}$。
>
>然后令 $S\gets S\times a_n$，此时 $S=(b_{n-1})^{-1}$，就可以接着算前一个的逆元了。
>
>复杂度 $O(n+\log M)$。

到此这道题就做完了。

打表代码时间复杂度 $O(\frac{n^2}{B})$，空间复杂度 $O(n)$，表长度 $O(\frac{n^2}{B^2})$。

最终代码时间复杂度 $O(B+\log M)$，空间复杂度 $O(B)$。

$B$ 取到 $10^7$ 量级即可。

### Code

打表代码如下：

```cpp
#include<bits/stdc++.h>
#include<fcntl.h>
#include<unistd.h>
#include<sys/mman.h>
using namespace std;
template<class T>T* get_array(const string &name,const int N){
	int fd=open((name+".dat").c_str(),O_RDWR|O_CREAT,S_IRUSR|S_IWUSR);
	assert(!ftruncate(fd,N*sizeof(T)));
	T *array=(T*)mmap(NULL,N*sizeof(T),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
	close(fd);return array;
}
#define ll unsigned long long
const ll B=1e7,M=998244353;
ll n,k,t,s,i,j;int *a=get_array<int>("a",M);
int main(){
	freopen("a.txt","w",stdout);
	for(a[1]=1,i=2;i<M;i++)a[i]=(M-M/i)*a[M%i]%M;
	for(k=1,i=0;i<M;i+=B){
		cout<<"{1";
		for(s=t=j=1;j<=i;j++){
			s+=t=t*(i-j+1)%M*a[j]%M;
			if(j%B==0)cout<<','<<s%M;
		}
		cout<<"},\n";
		for(j=i;j<i+B;j++)k=k*j%M;
	}
}
```

需要注意的是，由于打表程序需要使用 $O(n)$ 大小的逆元数组，所需的空间太大，大约需要 $\text{4GB}$，因此使用了外存进行存储。

由于我懒得进行常数优化，上面这份代码打表需要花大概十分钟。

最终代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll B=1e7,M=998244353;
ll a[100][100]={...}; // D(n,k) 的表
ll b[100]={...}; // n! 的表
ll fac(ll n){ll k=n/B,s=b[k],i;for(i=k*B+1;i<=n;i++)s=s*i%M;return s;}
ll qp(ll x,ll y){ll z=1;for(;y;y>>=1,x=x*x%M)if(y&1)z=z*x%M;return z;}
ll C(ll x,ll y){return fac(x)*qp(fac(y),M-2)%M*qp(fac(x-y),M-2)%M;}
ll n,m,x,y,s,k,t,i,j;int c[B<<1],d[B<<1];
int main(){
	cin>>m>>n;m=min(m,n);x=n/B;y=m/B;
	for(i=x*B+1;i<=n;i++)c[++t]=i-y*B;
	for(i=y*B+1;i<=m;i++)c[++t]=i;
	for(d[0]=i=1;i<=t;i++)d[i]=(ll)d[i-1]*c[i]%M;
	for(k=qp(d[t],M-2),i=t;i;i--)d[i]=k*d[i-1]%M,k=k*c[i]%M;
	s=a[x][y];k=C(x*B,y*B);t=n-x*B;
	for(i=x*B+1;i<=n;i++)s=(s*2+M-k)%M,k=k*i%M*d[i-x*B]%M;
	for(i=y*B+1;i<=m;i++)k=k*(n-i+1)%M*d[i-y*B+t]%M,s+=k;
	cout<<s%M<<'\n';
}
```

### 后记

看到 [LOJ6386](https://loj.ac/p/6386) 的讨论区有人给出了组合数前缀和的一种比较牛的求法，可惜我不会。

---


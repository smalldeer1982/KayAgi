# 【模板】常系数非齐次线性递推

## 题目背景

NaCly\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......

NaCly\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......
****  
NaCly\_Fish 看见了这题，她根本不会做。  
看在她那么菜的份上，请您做了这题，帮帮她吧。

## 题目描述

已知递推式：  

$$a_n = P(n) + \sum\limits_{i=1}^k f_i \times a_{n-i}$$  

其中 $P(x)$ 是一个 $m$ 次多项式。

给定 $f_1,f_2,\dots,f_k$，$a_0,a_1,\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  
答案对 $998244353$ 取模。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^9$，$1\le m,k \le 30000$。    
除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  

数据有一定梯度。

## 样例 #1

### 输入

```
40 5 6
1 2 3 5 8 13
1 3 4 9 6 7
1 1 4 5 1 4```

### 输出

```
349344375```

# 题解

## 作者：NaCly_Fish (赞：20)

首先，题目中是非齐次递推，考虑将其化为齐次的。  
以下若无说明，则 $f_0=-1$。
$$a_n=\sum\limits_{i=0}^mp_in^i+\sum\limits_{i=1}^kf_i \times a_{n-i}$$
$$a_n=p_mn^m+\sum_{i=0}^{m-1}p_in^i+\sum_{i=1}^kf_i \times a_{n-i}$$
$$p_mn^m=a_n-\sum_{i=0}^{m-1}p_in^i-\sum_{i=1}^kf_i \times a_{n-i}$$
$$p_m(n-1)^m=a_{n-1}-\sum_{i=0}^{m-1}p_i(n-1)^i-\sum_{i=1}^kf_i \times a_{n-1-i}$$
式子推到这里其实就可以收手了；把左式的 $(n-1)^m$ 展开后，除了 $p_mn^m$ 项都移到右边去。然后用右边的式子，取代原式中的 $p_mn^m$。

代回原式上面后，相当于把递推系数做了个差分（当然还要在后面加一项），而和多项式的系数没有关系。  

也就是说将递推系数求 $m+1$ 阶差分，就可以得到等价的齐次递推式了。
****  
由于多了 $m+1$ 项，就要再求出 $a_k\sim a_{k+m}$。  
原式的递推可以写成这样：    
（其中 $b$ 是我们构造的一个序列）
$$a_n=b_n+\sum_{i=1}^kf_i\times a_{n-i}$$  
**为了下面推式子方便，定义 $f_0=0$** 。
$$a_n=b_n+\sum\limits_{i=0}^nf_i \times a_{n-i}$$  
这样就是一个明显的卷积，设 $\{a_n\}_{n=0}^\infty,\{b_n\}_{n=0}^\infty,\{f_n\}_{n=0}^\infty$ 的生成函数为 $A(x),B(x),F(x)$，那么就有：  
$$A(x)=B(x)+F(x)A(x)$$
$$(1-F(x))A(x)=B(x)$$
$$A(x)=\frac{B(x)}{1-F(x)}$$
所以只要构造出序列 $b$，就能多项式求逆算出 $a$ 了。

首先对于 $\forall n \ge k,b_n=P(n)$，多项式多点求值即可。  
而对于 $n \le k-1$：  
$$b_n=a_n-\sum\limits_{i=0}^nf_i \times a_{n-i}$$  
这右边还是个卷积，由于这里 $n$ 只能取到 $k-1$，所以就可以直接算出来了。  

前面做的都是准备工作，搞完了之后直接上线性递推板子即可。  

参考代码：  
（为了可读性没有刻意卡常数）
```cpp
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 131077
#define p 998244353
#define ll long long
#define reg register
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
using namespace std;

inline void read(int &x){
	x = 0;
	char c = getchar();
	while(c<'0'||c>'9') c = getchar();
	while(c>='0'&&c<='9'){
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
}

void print(int x){
	if(x>9) print(x/10);
	putchar(x%10+'0');	
}

inline int power(int a,int t){
	int res = 1;
	while(t){
		if(t&1) res = (ll)res*a%p;
		a = (ll)a*a%p;
		t >>= 1; 
	}
	return res;
}

int rt[N],rev[N],inv[N],fac[N],ifac[N];
int siz;

inline int binom(int x,int y){
    if(x<y) return 0;
    return (ll)fac[x]*ifac[y]%p*ifac[x-y]%p;
}

void init(int n){
	int w,lim = 1;
	while(lim<=n) lim <<= 1,++siz;
	for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
	w = power(3,(p-1)>>siz);
	fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = rt[lim>>1] = 1;
	for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
	for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];	
	for(reg int i=2;i<=lim;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
    for(reg int i=2;i<=lim;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[lim] = power(fac[lim],p-2);
    for(reg int i=lim-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
}

inline int getlen(int n){
	return 1<<(32-__builtin_clz(n));	
}

inline void NTT(int *f,int type,int lim){
	if(type==-1) reverse(f+1,f+lim);
	reg int x,shift = siz-__builtin_ctz(lim);
	static int a[N];
	for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
	for(reg int mid=1;mid!=lim;mid<<=1){
		for(reg int j=0;j!=lim;j+=(mid<<1)){
			for(reg int k=0;k!=mid;++k){
				x = (ll)a[j|k|mid]*rt[mid|k]%p;
				a[j|k|mid] = dec(a[j|k],x);
				a[j|k] = add(a[j|k],x);
			}
		}
	}
	memcpy(f,a,lim<<2);
	if(type==1) return;
	x = inv[lim];
	for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

void inverse(const int *f,int *R,int n){
	static int g[N],h[N],q[N];
	memset(g,0,getlen(n<<1)+2<<2);
	int lim = 1,top = 0;
	int s[30];
	while(n){
		s[++top] = n;
		n >>= 1;
	}
	g[0] = power(f[0],p-2);
	while(top--){
		n = s[top+1];
		while(lim<=(n<<1)) lim <<= 1;
		memcpy(q,g,(n+1)<<2);
		memcpy(h,f,(n+1)<<2);
		memset(h+n+1,0,(lim-n)<<2);
		NTT(g,1,lim),NTT(h,1,lim);
		for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*g[i]%p*h[i]%p;
		NTT(g,-1,lim);
		for(reg int i=0;i<=n;++i) g[i] = dec(add(q[i],q[i]),g[i]);
		memset(g+n+1,0,(lim-n)<<2);
	}
	memcpy(R,g,(n+1)<<2);
}

void divide(const int *f,const int *g,int n,int m,int *R){
	static int A[N],B[N];
    memcpy(A,f,(n+1)<<2);
	memcpy(B,g,(m+1)<<2);
    reverse(A,A+n+1);
    reverse(B,B+m+1);
    int tt = n-m,lim = getlen((n-m)<<1);
    for(reg int i=tt+1;i!=lim;++i) A[i] = 0;
    for(reg int i=min(m,tt)+1;i!=lim;++i) B[i] = 0;
    inverse(B,B,tt);
    NTT(A,1,lim),NTT(B,1,lim);
    for(reg int i=0;i!=lim;++i) A[i] = (ll)A[i]*B[i]%p;
    NTT(A,-1,lim);
    reverse(A,A+tt+1);
    memcpy(R,A,(tt+1)<<2);
}

void mod(const int *f,const int *g,int n,int m,int *R){
    if(n<m){
        memcpy(R,f,(n+1)<<2);
        return;
    }   
    static int A[N],B[N];
    memcpy(B,f,(n+1)<<2);
    int lim = getlen(n);
	divide(f,g,n,m,R);
	for(int i=0;i<=m;++i) A[i] = g[i];
	for(int i=m+1;i!=lim;++i) A[i] = 0;
	for(int i=n-m+1;i!=lim;++i) R[i] = 0;
	NTT(A,1,lim),NTT(R,1,lim);
    for(reg int i=0;i!=lim;++i) R[i] = (ll)A[i]*R[i]%p;
    NTT(R,-1,lim);
    for(reg int i=0;i!=m;++i) R[i] = dec(B[i],R[i]);
    for(int i=m;i!=lim;++i) R[i] = 0;
}

#define mid ((l+r)>>1)
#define ls (u<<1)
#define rs (u<<1|1)
int bflim;
int *P[N],len[N];

void prepare(int l,int r,int u,const int *a){ //分治乘,多点求值用
	if(l==r){
		len[u] = 1;
		P[u] = new int[2];
		P[u][0] = p-a[l],P[u][1] = 1;
		return;
	}
	prepare(l,mid,ls,a);
	prepare(mid+1,r,rs,a);
	len[u] = r-l+1;
	int lim = getlen(len[u]);
	P[u] = new int[len[u]+1];
	int F[lim+1],G[lim+1];
	memcpy(F,P[ls],(len[ls]+1)<<2);
	memcpy(G,P[rs],(len[rs]+1)<<2);
	if(r-l>bflim){
		memset(F+len[ls]+1,0,(lim-len[ls]+1)<<2);
		memset(G+len[rs]+1,0,(lim-len[rs]+1)<<2);
		NTT(F,1,lim),NTT(G,1,lim);
		for(reg int i=0;i!=lim;++i) F[i] = (ll)F[i]*G[i]%p;
		NTT(F,-1,lim);
		memcpy(P[u],F,(len[u]+1)<<2);
	}else{
		memset(P[u],0,(len[u]+1)<<2);
		for(reg int i=0;i<=len[ls];++i)
		for(reg int j=0;j<=len[rs];++j)
			P[u][i+j] = (P[u][i+j]+(ll)F[i]*G[j])%p;
	}
}

void solve(const int *F,int l,int r,const int *a,int u,int n,int *R){ //多点求值
	if(r-l<=bflim){ //小范围暴力
		ll pw[17];
		int res,x;
		ll s1,s2,s3,s4;
		pw[0] = 1;
		for(reg int j=l;j<=r;++j){
			res = F[n],x = a[j];
			reg int i = 1;
			for(;i<=16;++i) pw[i] = pw[i-1]*x%p;
			i = n-1;
			while(i>=15){
				s1 = res*pw[16]+F[i]*pw[15]+F[i-1]*pw[14]+F[i-2]*pw[13];
				s2 = F[i-3]*pw[12]+F[i-4]*pw[11]+F[i-5]*pw[10]+F[i-6]*pw[9];
				s3 = F[i-7]*pw[8]+F[i-8]*pw[7]+F[i-9]*pw[6]+F[i-10]*pw[5];
				s4 = F[i-11]*pw[4]+F[i-12]*pw[3]+F[i-13]*pw[2]+F[i-14]*x;
				res = ((F[i-15]+s1+s2)%p+s3+s4)%p;
				i -= 16;
			}
			i = (n&15)-1;
			for(;~i;--i) res = ((ll)res*x+F[i])%p;
			R[j] = res;
		}
		return;
	}
	int G[getlen(n<<1)+1];
	memset(G,0,sizeof(G));
	mod(F,P[ls],n,len[ls],G);
	solve(G,l,mid,a,ls,len[ls]-1,R);
	memset(G,0,sizeof(G));
	mod(F,P[rs],n,len[rs],G);
	solve(G,mid+1,r,a,rs,len[rs]-1,R);
}

void evaluation(const int *F,int *a,int n,int m,int *R){
	bflim = log2(m);
	prepare(1,m,1,a);
	solve(F,1,m,a,1,n,R);
}

#undef ls
#undef rs
#undef mid

void multiply(const int *F,const int *G,int n,int m,int len,int *R){
    static int A[N],B[N];
    memcpy(A,F,(n+1)<<2);
    memcpy(B,G,(m+1)<<2);
    int lim = getlen(n+m);
    memset(A+n+1,0,(lim-n+2)<<2);
    memset(B+m+1,0,(lim-m+2)<<2);
    NTT(A,1,lim),NTT(B,1,lim);
    for(reg int i=0;i!=lim;++i) R[i] = (ll)A[i]*B[i]%p;
    NTT(R,-1,lim);
    memset(R+len+1,0,(lim-len+2)<<2);
}

void mod_power(const int *G,int k,int t,int *R){ //多项式快速幂 (模G(x))
    int f[N],g[N];
    memset(f,0,sizeof(f));
    memset(g,0,sizeof(g));
    int n = 1,m = 0;
    f[1] = g[0] = 1;
    while(t){
        if(t&1){
            multiply(f,g,n,m,n+m,g);
            mod(g,G,n+m,k,g);
            m = min(n+m,k-1);
        }
        int lim = getlen(n<<1);
        NTT(f,1,lim);
        for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*f[i]%p;
        NTT(f,-1,lim);
        mod(f,G,n<<1,k,f);
        n = min(n<<1,k-1);
        t >>= 1;
    }
    memcpy(R,g,k<<2);
}

int n,m,k,ans,T;
int F[N],G[N],B[N],A[N],a[N],f[N],d[N];

int main(){
    init(100000);
	read(n),read(m),read(k);
	for(reg int i=0;i!=k;++i) read(a[i]);
	for(reg int i=1;i<=k;++i) read(f[i]);
    for(reg int i=0;i<=m;++i) read(G[i]);
    for(reg int i=0;i<=m;++i) d[i+1] = i+k;
	evaluation(G,d,m,m+1,B); //构造B的后半部分
    for(reg int i=k+m;i>=k;--i) B[i] = B[i-k+1];
    for(reg int i=0;i!=k;++i) B[i] = 0;
    multiply(f,a,k,k,k-1,d); //一波卷积求出B的前半部分
    for(reg int i=0;i!=k;++i) B[i] = dec(a[i],d[i]);
    f[0] = p-1;
    for(reg int i=0;i<=k;++i) F[i] = p-f[i];
    inverse(F,F,m+k);
    multiply(F,B,m+k,m+k,m+k,A); //求逆算出A
    for(reg int i=0;i<=m+k;++i) a[i] = A[i];
    memset(F,0,sizeof(F));
    for(reg int i=0;i<=m+1;++i) F[i] = (m+1-i)&1?p-binom(m+1,i):binom(m+1,i); //高阶差分系数
    T = m+k+1;
    multiply(F,f,m+1,k,T,f); //化为齐次递推
    memset(G,0,sizeof(G));
    for(reg int i=0;i<=T;++i) G[T-i] = p-f[i];
    mod_power(G,T,n,F);
    for(reg int i=0;i!=T;++i) ans = (ans+(ll)F[i]*a[i])%p;
    print(ans);
	return 0;	
}
```

---

## 作者：Itst (赞：9)

胡一个直接通过齐次线性递推得到做法的方法以供参考。~~因为懒~~没有写代码，纯属口胡，如有错误请及时告知，如果我没有退役会及时修复，谢谢。

### 问题引入

**因为一些原因，变量名与题面中的变量名有不同，题解中以这里声明的变量名为准**

给出一多项式$F(x) = \sum\limits_{i=0}^{k} f_ix^i$和递推式$a_p = \sum\limits_{i=1}^n b_ia_{p-i} + F(p)(p \geq n)$和初始值$a_0,a_1,...,a_{n-1}$，求$b_m$的值。$n,k \leq 30000 , m < 10^9$。

### 前置芝士

- 掌握[常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)的证明过程，不需要会证明CH定理。

- [常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)的板子

- 多项式多点求值

- 基本线性代数知识

### 算法流程

类似于齐次线性递推，我们先考虑矩阵快速幂的暴力：

设

$$A = \begin{array}{cccc}(a_{n-1} & a_{n-2} & ... & a_0 & n^k & n^{k-1} & ... & n^0) \end{array}$$

$$B = \left(\begin{array}{cccc} {B_1}_{n \times n} & 0_{n \times (k+1)} \\ {B_2}_{(k+1) \times n} & {B_3}_{(k+1) \times (k+1)} \end{array} \right)$$

其中

$${B_1}_{n \times n} = \left(\begin{array}{cccc} b_1 & 1 & 0 & 0 & ... & 0 \\ b_2 & 0 & 1 & 0 & ... & 0 \\ b_3 & 0 & 0 & 1 & ... & 0 \\ \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\ b_n & 0 & 0 & 0 & ... & 0 \end{array}\right)$$

$${B_2}_{(k+1) \times n} = \left(\begin{array}{cccc} f_k & 0 & 0 & ... & 0 \\ f_{k-1} & 0 & 0 & ... & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ f_0 & 0 & 0 & ... & 0 \end{array} \right)$$

$${B_3}_{(k+1) \times (k+1)} = \left(\begin{array}{cccc} \binom{k}{k} & 0 & 0 & ... & 0 \\ \binom{k}{k-1} & \binom{k-1}{k-1} & 0 & ... & 0 \\ \binom{k}{k-2} & \binom{k-1}{k-2} & \binom{k - 2}{k-2} & ... & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ \binom{k}{0} & \binom{k - 1}{0} & \binom{k - 2}{0} & ... & \binom{0}{0} \end{array} \right)$$

$B_1$矩阵就是齐次线性递推中的矩阵，$B_2$将$F(n)$加入进当前的数，而$B_3$通过二项式定理将$\begin{array}{cccc} (n^k & n^{k-1} & ... & n^0) \end{array}$变为$\begin{array}{cccc} ((n+1)^k & (n+1)^{k-1} & ... & (n+1)^0) \end{array}$。

那么答案就是$(AB^m)_n$。

我们如果可以得到$B$的特征多项式$f(\lambda) = |\lambda I - B|$就是齐次线性递推那一套了。

注意到$\lambda I - B = \left(\begin{array}{cccc} \lambda I - B_1 & 0 \\ -B_2 & \lambda I - B_3 \end{array} \right)$，利用矩阵分块的经典结论，$|\lambda I - B| = |\lambda I - B_1||\lambda I - B_3|$。

在齐次线性递推中我们已经知道了$|\lambda I - B_1| = \lambda^n - \sum\limits_{j=1}^{n}b_i \lambda^{n-i}$，而$\lambda I - B_3$是一个下三角矩阵，故$|\lambda I - B_3| = (\lambda - 1)^{k+1}$，那么$|\lambda I - B| = (\lambda - 1)^{k+1}(\lambda^n - \sum\limits_{j=1}^{n}b_i \lambda^{n-i})$。卷一下就可以得到其表示。

---

可以发现其特征多项式是$n+k+1$次的，所以我们还需要求出$a_n , a_{n+1} , ... , a_{n+k}$才行。

定义$b_0 = 0$，递推式可以被表示为$A(x) = A(x) * B(x) + P(x)$的形式，其中$A(x) = \sum\limits_{i=0}^ \infty a_ix^i , B(x) = \sum\limits_{i=0}^n b_ix^i$，而$P(x)$则相对复杂：在$i \geq n$时遵循递推式，那么$[x^i]P(x) = F(i)$；在$i < n$时需要用$P(x)$把系数补上，那么$[x^i]P(x) = a_i - \sum\limits_{j=0}^i a_jb_{i-j}$。

那么$A(x) = \frac{P(x)}{1 - B(x)}$，求逆卷一下然后多点求值就可以得到$A(x)$的前$n+k$项。

---

算法到此结束，拉板子即可。复杂度$O(n \log n (\log n + \log m))$。

---

## 作者：ZhongYuLin (赞：4)

考虑延用齐次时的做法。设 $\mathbf{x}_n,\mathbf{y}_n$ 两个列向量为：

$$\mathbf{x}_n=\begin{bmatrix}
a_{n-k}\\
a_{n-k+1} \\
 \vdots \\
 a_{n-1}\\
 a_n\\

\end{bmatrix},\mathbf{y}_n=\begin{bmatrix}
n^m\\
n^{m-1} \\
 \vdots \\
 n\\
 1\\

\end{bmatrix}$$

故我们要对 $\begin{bmatrix}
 \mathbf{x}_n\\
\mathbf{y}_n
\end{bmatrix}$ 进行递推，容易发现转移矩阵形如 $\begin{bmatrix}
  A& B\\
  O&C
\end{bmatrix}$，其中 $O$ 为 $0$ 矩阵。即：

$$\begin{bmatrix}
 \mathbf{x}_{n+1}\\
\mathbf{y}_{n+1}
\end{bmatrix}=\begin{bmatrix}
  A& B\\
  O&C
\end{bmatrix}\begin{bmatrix}
 \mathbf{x}_n\\
\mathbf{y}_n
\end{bmatrix}=\begin{bmatrix}
 A\mathbf{x}_n+B\mathbf{y}_n\\
C\mathbf{y}_n
\end{bmatrix}$$

容易依题意列出 $A,B$，同时依二项式定理可以列出 $C$，会发现 $C$ 是一个主对角线全 $1$（$\binom{n}{n}=1$）的上三角矩阵，因为我们是用低次来线性组合出高次。考虑这东西的特征多项式，显然是 $p_A(\lambda)p_C(\lambda)$，依次沿最后一行展开易证。也即 $(\lambda^k-\sum_{i=0}^{k-1}f_{k-i+1}\lambda^i)(1-\lambda)^{m+1}$。这是一个 $m+k+1$ 次多项式，我们需要求出前 $m+k+1$ 项，才能套用齐次的做法。

可以多项式多点求值以后参照[【模板】分治 FFT](https://www.luogu.com.cn/problem/P4721)，快速求出前 $m+k+1$ 项，可以通过这道题。

然而，现在是 $2025$ 年，由于出题人很良心，所以我们暴力求前 $m+k+1$ 项（大概率）也可以通过这个题，参照 [暴力过多点求值](https://www.luogu.com.cn/article/kitad12w)。毫无疑问，本题数据范围远远弱于多点求值，很可能可以通过。

遗憾的是，笔者的多项式板子过于烂，导致取模时就已经超时，而笔者忙于学业，无暇改进多项式板子并实现暴力卡常做法。下面给出并不能通过的主函数，来进一步阐释上文。[记录](https://www.luogu.com.cn/record/201006618)。


```cpp
int main(){
    int n,m,K;
    cin>>n>>m>>K;++m;
    poly f(K),p(m),a(K+m);
    for(int i=0;i<K;++i)cin>>a[i];
    for(auto &x:f)cin>>x;
    for(auto &x:p)cin>>x;
    poly A=f,B(m+1);
    reverse(A.begin(),A.end());
    A.push_back(P-1);
    B[0]=1;
    for(int i=1;i<=m;++i)B[i]=B[i-1]*fp(i)%P*(P-1)%P*(m-i+1)%P;
    A=A*B;
    poly now={0,1},cf={1};
    for(;n;n>>=1,now=now*now%A)
        if(n&1)cf=cf*now%A;
    for(int j=K;j<K+m;++j){
        ll sum=calc(p,j);//求多项式 p 在 j 处的点值
        for(int i=1;i<=K;++i)
            sum=(sum+f[i-1]*a[j-i])%P;
        a[j]=sum;
    }
    ll ans=0;
    for(int i=0;i<m+K;++i)ans=(ans+cf[i]*a[i])%P;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Spasmodic (赞：3)

这里是一种用新线性递推的方法来解决这道题。

新线性递推本质上是对 $x^n$ 对首一多项式取模的结果，但是在这题里面特征多项式不再一定首一。

不过我们观察到当且仅当在 $2|m$ 的时候首位会变成 $-1$，而 $x^n\bmod f$ 和 $x^n\bmod -f$ 的结果是一致的，而这时 $f$ 就会再次变成首一，因此我们做一个特判就可以过了。

由于新线性递推算法的优越性，这份代码即使是进行了大量的封装也以前最优解所需时间的一半成为了（到目前为止的）最优解。

Code：
```cpp
mi poly::LNRR(const poly&P,const vec&a,int n)const{
	int m=P.deg(),k=a.size();
	vec d(m+1);
	rep(i,0,m)d[i]=i+k;
	vec b=tp.eval(P,d);
	b.resize(k+m+1);
	Rep(i,k+m,k)b[i]=b[i-k];
	memset(b.data(),0,sizeof(mi)*k);
	auto res=operator*(poly(a)).shift(1);
	rep(i,0,k-1)b[i]=a[i]-res[i];
	poly B(b),F=shift(1),A=B.quo((poly(1)-F).slice(m+k));
	F.redeg(m+1);
	rep(i,0,m+1)
		if((m+1-i)&1)F[i]=-math.binom(m+1,i);
		else F[i]=math.binom(m+1,i);
	int T=m+k;
	poly f=((shift(1)-1)*F);
	if(f[0]==1)f=-f;//上文所讲到的特判
	return f.shift(-1).slice(T).LHRR(A.a,n);
}
int main(){
	int n,m,k;
	IO>>n>>m>>k;
	vec a(k);
	poly f=zeroes(k-1),P=zeroes(m);
	IO>>a>>f.a>>P.a;
	IO<<f.LNRR(P,a,n);
	return 0;
}
```


---


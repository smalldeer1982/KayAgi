# 【模板】多项式复合逆

## 题目背景

神鱼姐姐太鸽了 qwq

## 题目描述

令 $n-1$ 次多项式 $F(x)=\sum\limits _{i=0}^{n-1} a_ix^i$。

给定 $n$ 和 $F(x)$ 的各项系数，要求一个 $n-1$ 次多项式 $G(x)$ 满足：

$$
G(F(x))\equiv x\pmod{x^n}
$$

求 $G(x)$ 的各项系数对 $998244353$ 取模的结果。

保证 $a_0=0$，$a_1\neq 0$。

## 说明/提示

对于 $100\%$ 的数据，$2\leq n\leq 2^{14}$，$0\leq a_i < 998,244,353$。

## 样例 #1

### 输入

```
6
0 1 2 2 4 3
```

### 输出

```
0 1 998244351 6 998244329 113
```

## 样例 #2

### 输入

```
7
0 1 1 4 5 1 4
```

### 输出

```
0 1 998244352 998244351 10 7 998244202
```

# 题解

## 作者：cyffff (赞：16)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5809)

力求把最新技术翻译地人人都能看懂。

推荐先学习：[拉格朗日反演](https://www.luogu.com.cn/article/tbr4td9e)。
## 题意
给出 $n$ 次多项式 $F(x)$，求一个 $n$ 次多项式 $G(x)$ 满足 $F(G(x))\equiv x\pmod {x^{n+1}}$。保证 $[x^0]F(x)=0$ 且 $[x^1]F(x)\ne 0$。

$n\le 2\times 10^4$。
## 思路
我们将 $[x^1]F(x)$ 化成 $1$ 以便后续处理。令 $F'(x)$ 为原多项式，$v$ 为 $[x^1]F'(x)$，$F(x)$ 为 $\dfrac{F'(x)}{v}$。

那么我们有：$F(G(x))=\dfrac{x}{v}$，$F^k(G(x))=\dfrac{x^k}{v^k}$，根据扩展拉格朗日反演，我们有：

$$[x^n]F^k(x)=\frac1{n}\cdot[x^{n-1}]\frac{kx^{k-1}}{v^k}\cdot\frac{x^n}{G^n(x)}$$

$$[x^n]F^k(x)=\frac k {nv^k}\cdot[x^{n-k}]\frac{x^n}{G^n(x)}$$
$$\sum_kx^{n-k}\frac{nv^k}k[x^n]F^k(x)=\left(\frac{G(x)}x\right)^{-n}$$

$$G(x)=x\left(\sum_kx^{n-k}\frac{nv^k}{k}[x^n]F^k(x)\right)^{-1/n}$$

$$G(x)=\frac{x}v\left(\sum_kx^{n-k}\frac{n}{kv^{n-k}}[x^n]F^k(x)\right)^{-1/n}$$

可以发现此处需要开根的多项式常数项为 $1$，直接用多项式快速幂即可。于是接下来我们的任务就是对 $\forall k\in[0,n]$ 求出 $[x^n]F^k(x)$。不难发现，这等价于求多项式 $[x^n]\dfrac{1}{1-yF(x)}$。

首先我们需要了解 Bostan-Mori 算法，该算法可在 $O(k\log k\log n)$ 的复杂度下对 $O(k)$ 次的多项式 $F(x),G(x)$ 求出 $[x^n]\dfrac{F(x)}{G(x)}$。具体地，
$$[x^n]\dfrac{F(x)}{G(x)}=[x^n]\dfrac{F(x)G(-x)}{G(x)G(-x)}=[x^n]\dfrac{F_0(x^2)}{G_0(x^2)}+x\dfrac{F_1(x^2)}{G_0(x^2)}$$

两边分别只有偶数次和奇数次有值，根据 $n$ 的奇偶性取一边递归即可。当 $n=0$ 时直接返回 $\dfrac{[x^0]F(x)}{[x^0]G(x)}$ 即可。

二元多项式的情况也是一样的：
$$[x^n]\dfrac{F(x,y)}{G(x,y)}=[x^n]\dfrac{F(x,y)G(-x,y)}{G(x,y)G(-x,y)}=[x^n]\dfrac{F_0(x^2,y)}{G_0(x^2,y)}+x\dfrac{F_1(x^2,y)}{G_0(x^2,y)}$$

注意到递归到第 $t$ 层时 $x$ 只需要保留 $\lfloor\dfrac{n}{2^t}\rfloor$ 次，而 $y$ 每层次数只会翻倍，只有 $2^{t+1}$ 次，所以整个二元多项式只有 $O(n)$ 项。

于是我们在 $O(n\log^2n)$ 的时间复杂度内解决了多项式复合逆问题。

核心代码：
```cpp
namespace PolyC{
	//...
	#define PolyY vector<Poly>
	inline PolyY operator*(const PolyY &a,const PolyY &b){
		int n=a.size(),m=b.size(),p=a[0].size(),q=b[0].size();
		Poly P,Q;
		P.resize(n*(p+q-1)),Q.resize(m*(p+q-1));
		for(int i=0;i<n;i++)
			for(int j=0;j<p;j++)
				P[i*(p+q-1)+j]=a[i][j];
		for(int i=0;i<m;i++)
			for(int j=0;j<q;j++)
				Q[i*(p+q-1)+j]=b[i][j];
		P=P*Q;
		PolyY F(n+m-1,Poly(p+q-1,0)); 
		for(int i=0;i<n+m-1;i++)
			for(int j=0;j<p+q-1;j++)
				F[i][j]=P[i*(p+q-1)+j]; 
		return F;
	}
}
using namespace PolyC;
inline Poly BostanMori(int n,PolyY F,PolyY G){
	if(!n) return F[0]*Inv(G[0]);
	if(n+1<F.size()) F.resize(n+1);
	if(n+1<G.size()) G.resize(n+1);
	PolyY H=G;
	for(int i=1;i<H.size();i+=2)
		for(int j=0;j<H[i].size();j++)
			H[i][j]=dec(0,H[i][j]);
	F=F*H,G=G*H;
	PolyY A,B;
	for(int i=n&1;i<F.size();i+=2) A.push_back(F[i]);
	for(int i=0;i<G.size();i+=2) B.push_back(G[i]);
	return BostanMori(n/2,A,B);
}
inline Poly CompInv(Poly F){
	int n=F.size();
	int t=F[1],v=qpow(t,mod-2);
	for(int i=0;i<n;i++)
		F[i]=1ll*F[i]*v%mod;
	PolyY P,Q;
	for(int i=0;i<n;i++)
		P.push_back({!i,0}),
		Q.push_back({!i,dec(0,F[i])});
	Poly G=BostanMori(n-1,P,Q),H(n,0); 
	G.resize(n);
	for(int i=0;i<n;i++)
		H[n-1-i]=1ll*G[i]*(n-1)%mod*inv[i]%mod;
	for(int i=0,w=1;i<n;i++,w=1ll*w*v%mod)
		H[i]=1ll*H[i]*w%mod;
	H=Pow(H,mod-inv[n-1]);
	H.insert(H.begin(),0),H.resize(n);
	for(int i=0;i<n;i++)
		H[i]=1ll*H[i]*v%mod;
	return H;
}
```

---

## 作者：mrsrz (赞：13)

[可能更好的体验](https://mrsrz.github.io/2019/12/13/lg5809/)

对于满足 $G(F(x))=x$ 且 $F(x)$ 的常数项为 $0$，一次项有逆元的多项式 $F(x),G(x)$，有拉格朗日反演公式：
$$[x^n]G(x)=\frac 1{n}[x^{n-1}](\frac{x}{F(x)})^n$$
这个可以求单项系数。我们要求所有系数。

按多项式复合的做法来就可以了。

令 $L=\sqrt n$。

那么有：
$$G(x)=\sum_{i=1}^n \left(\frac{1}{i}[x^{i-1}](\frac{x}{F(x)})^i\right)x^i$$
$$=\sum_{i=0}^{L-1} \sum_{j=1}^L \left(\frac{1}{iL+j}[x^{iL+j-1}](\frac{x}{F(x)})^{iL+j}\right)x^{iL+j}$$
$$=\sum_{i=0}^{L-1}\sum_{j=1}^L \left(\frac{1}{iL+j}[x^{iL+j-1}](\frac{x}{F(x)})^{iL}(\frac{x}{F(x)})^j\right)x^{iL+j}$$
其中，$(\frac{x}{F(x)})^{iL}$ 和 $(\frac{x}{F(x)})^{j}$ 我们可以直接 FFT 预处理。时间复杂度 $O(n\sqrt n\log n)$。

观察 $[x^{iL+j-1}] (\frac{x}{F(x)})^{iL}(\frac{x}{F(x)})^j$，这部分相当于给出两个多项式，求它们的乘积的某一项系数。这个可以 $O(n)$ 暴力求得。常数很小。

总时间复杂度 $O(n^2+n\sqrt n\log n)$，可以通过。

## Code：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#define lg2(x)(31-__builtin_clz((x)))
using namespace std;
typedef long long LL;
const int N=32769,BS=140,md=998244353;
int n,a[N],b[N],rev[N],lim,LG,L;
int G[15][N];
int B[BS][N],B_[BS][N];
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;
	return ret;
}
void init(int n){
	int l=-1;
	for(lim=1;lim<n;lim<<=1)++l;LG=l+1;
	for(int i=1;i<lim;++i)
	rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
}
void FFT(int*a,int f){
	for(int i=1;i<lim;++i)
	if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int i=0;i<LG;++i){
		const int*g=G[i],c=1<<i;
		for(int j=0;j<lim;j+=c<<1)
		for(int k=0;k<c;++k){
			const int x=a[j+k],y=g[k]*(LL)a[j+k+c]%md;
			upd(a[j+k]+=y-md),upd(a[j+k+c]=x-y);
		}
	}
	if(!f){
		const int iv=pow(lim,md-2);
		for(int i=0;i<lim;++i)a[i]=(LL)a[i]*iv%md;
		reverse(a+1,a+lim);
	}
}
void INV(int*a,int*B,int n){
	if(n==1){
		*B=pow(*a,md-2);
		return;
	}
	INV(a,B,n+1>>1);
	init(n<<1);
	static int A[N];
	for(int i=0;i<n;++i)A[i]=a[i];
	for(int i=n;i<lim;++i)A[i]=0;
	FFT(A,1),FFT(B,1);
	for(int i=0;i<lim;++i)B[i]=B[i]*(2-B[i]*(LL)A[i]%md+md)%md;
	FFT(B,0);
	for(int i=n;i<lim;++i)B[i]=0;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>a[0];--n;
	for(int i=0;i<15;++i){
		int*g=G[i];
		g[0]=1;
		const int gi=pow(3,(md-1)/(1<<i+1));
		for(int j=1;j<1<<i;++j)
		g[j]=(LL)g[j-1]*gi%md;
	}
	for(int i=0;i<n;++i)cin>>a[i];
	cout.put('0');
	INV(a,b,n);
	L=sqrt(n)+1;
	init(n<<1);
	**B=1;
	FFT(*B,1);
	for(int i=0;i<lim;++i)B_[0][i]=B[0][i];
	for(int i=0;i<n;++i)B[1][i]=b[i];
	FFT(B[1],1);
	for(int i=2;i<=L;++i){
		for(int j=0;j<lim;++j)
		B[i][j]=(LL)B[i-1][j]*B[1][j]%md;
		FFT(B[i],0);
		for(int j=n;j<lim;++j)B[i][j]=0;
		FFT(B[i],1);
	}
	for(int i=0;i<lim;++i)B_[0][i]=B[0][i],B_[1][i]=B[L][i];
	for(int i=2;i<=L;++i){
		for(int j=0;j<lim;++j)
		B_[i][j]=(LL)B_[i-1][j]*B_[1][j]%md;
		FFT(B_[i],0);
		for(int j=n;j<lim;++j)B_[i][j]=0;
		FFT(B_[i],1);
	}
	for(int i=0;i<=L;++i)FFT(B[i],0),FFT(B_[i],0);
	for(int i=0;i<L;++i){
		int*g_=B_[i];
		for(int j=1;j<=L;++j){
			const int x=i*L+j-1;
			if(x>=n)return 0;
			int*g=B[j];
			int ans=0;
			for(register int t=0;t<=x;++t)
			ans=(ans+(LL)g_[t]*g[x-t])%md;
			cout<<' '<<(LL)ans*pow(x+1,md-2)%md;
		}
	}
	return 0;
}
```


---

## 作者：Phartial (赞：0)

### 分式域

首先有这样一个问题：为什么幂级数求乘法逆要求常数项非零？

很简单，因为 $F^{-1}$ 系数的递推方程中用到了 $F[0]^{-1}$，不过有这项系数的根本原因是我们的递推基础是 $F[0]\times F^{-1}[0]=(F\times F^{-1})[0]=1$，后一个等式是乘法逆的定义，考虑修改前一个等式，使得常数项为零的幂级数也存在乘法逆元。考虑引入负次数，即形如 $x^{-1}$ 的项。

引入负次数后的加法、乘法仍然容易定义，但为了保留幂级数上的一些优良性质，我们只会使用有限项负次项。

为方便，称无负次数的幂级数为整式，有负次数的幂级数为分式。

_以下将在某些时候使用记号 $[x^i]F(x)$ 表示 $F(x)$ 的 $x^i$ 项系数。_

我们有引理：

> 对于 $F[0]=0,F[1]\ne 0$ 的整式 $F$，有 $[x^{-1}]F'(x)F^k(x)=[k=-1]$。

证明：若 $k\ne -1$，则有 $F'(x)F^k(x)=\left(\dfrac{F^{k+1}}{k+1}\right)'(x)$，而对一个任何一个幂级数求导都不可能产生 $x^{-1}$ 这一项。

若 $k=-1$，则左式即为 $[x^{-1}]\dfrac{F'(x)}{F(x)}=[x^0]\dfrac{xF'(x)}{F(x)}=[x^0]\dfrac{F'(x)}{F(x)/x}$。$(F(x)/x)\bmod{x}=F[1]$，因此 $(F(x)/x)^{-1}\bmod x=F[1]^{-1}$，于是有 $\dfrac{F'(x)}{F(x)/x}\equiv F[1]F[1]^{-1}\equiv 1\pmod{x}$。

这个引理实际上给予了我们从 $F^k$ 导出艾弗森括号的能力。

### 复合逆

考虑互为复合逆的两个整式 $F,G$，我们有 $\displaystyle \sum_{i=0}^\infty G[i]F^i=x$，考虑从 $F^i$ 导出艾弗森括号，从而锁定某项 $G[i]$ 进行处理。

有两种处理方法，分别给出不同的结果：

第一种方法是对等式两边求导，于是有 $\displaystyle\sum_{i=0}^\infty G[i]iF^{i-1}F'=1$，为提取 $G[n]$，我们尝试构造形如 $[i-n-1=-1]$ 的艾弗森括号，于是等式两边同乘 $F^{-n}$，得到：

$$
\begin{aligned}
  \sum_{i=0}^\infty G[i]iF^{i-n-1}F'&=F^{-n}\\
  [x^{-1}]\sum_{i=0}^\infty G[i]iF^{i-n-1}F'&=[x^{-1}]F^{-n}\\
  \sum_{i=0}^\infty G[i]i[i-n-1=-1]&=[x^{-1}]F^{-n}\\
  nG[n]&=[x^{-1}]x^{-n}\left(\frac{F}{x}\right)^{-n}\\
  [x^n]G&=\frac{1}{n}[x^{n-1}]\left(\frac{F}{x}\right)^{-n}\\
\end{aligned}
$$

第二种方法是直接乘上 $F'$，于是有 $\displaystyle\sum_{i=0}^\infty G[i]F^iF'=xF'$，为提取 $G[n]$，尝试构造形如 $[i-n-1=-1]$ 的艾弗森括号，于是等式两边同乘 $F^{-n-1}$，得到：

$$
\begin{aligned}
  \sum_{i=0}^\infty G[i]F^{i-n-1}F'&=xF'F^{-n-1}\\
  G[n]&=[x^{-1}]xF'F^{-n-1}\\
  G[n]&=[x^{-1}]x^{-n}F'\left(\frac{F}{x}\right)^{-n-1}\\
  [x^n]G&=[x^{n-1}]F'\left(\frac{F}{x}\right)^{-n-1}\\
\end{aligned}
$$

若设 $T(x)=H(G(x))$（这里 $H$ 是任意幂级数），则有 $T(F)=H$，展开此式并用相同的方式提取 $T[n]$，可以得到另外两个等式：

$$
\begin{aligned}
  [x^n]H(G)&=\dfrac{1}{n}[x^{n-1}]H'\left(\frac{F}{x}\right)^{-n}\\
  [x^n]H(G)&=[x^{n-1}]HF'\left(\frac{F}{x}\right)^{-n-1}\\
\end{aligned}
$$

这四个等式叫做拉格朗日反演，其主要用处是搭配生成函数使用。或者，利用一些科技，我们也可以直接求出 $n-1$ 次多项式 $F$ 的复合逆 $G$ 在 ${\!}\bmod x^n$ 后的结果。

我们有 $F^k(G(x))=x^k$，由拉格朗日反演的第三个式子，有：

$$
\begin{aligned}
  [x^n]F^k&=\frac{1}{n}[x^{n-1}]kx^{k-1}\left(\frac{G}{x}\right)^{-n}\\
  [x^n]F^k&=\frac{k}{n}[x^{n-k}]\left(\frac{G}{x}\right)^{-n}\\
  \frac{n}{k}[x^n]F^k&=[x^{n-k}]\left(\frac{G}{x}\right)^{-n}\\
  \sum_k x^{n-k}\frac{n}{k}[x^n]F^k&=\left(\frac{G}{x}\right)^{-n}\\
  G&=x\left(\sum_k x^{n-k}\frac{n}{k}[x^n]F^k\right)^{-1/n}\\
\end{aligned}
$$

和式的 $k$ 只需要取 $0<k\le n$，括号里的幂级数常数项为 $([x^0]F)^n$，为了避免 $n$ 在 $998244352$ 下没有逆元之类的麻烦，先将这个东西提出来，设 $F'=\dfrac{F}{[x^0]F}$ 就有：

$$
\begin{aligned}
  G&=x\left(\sum_kx^{n-k}\frac{n([x^0]F)^k}{k}[x^n]F'^k\right)^{-1/n}\\
  &=\frac{x}{[x^0]F}\left(\sum_kx^{n-k}\frac{n}{k([x^0]F)^{n-k}}[x^n]F'^k\right)^{-1/n}\\
\end{aligned}
$$

经过这样的处理后括号内部的常数项就是 $1$ 了，可以直接快速幂。于是只需要对所有 $0<k\le n$ 求出 $[x^n]F'^k$。

构造**二元**幂级数 $\displaystyle P(x,y)=\sum_{i=0}^\infty x^i\sum_{j=0}^\infty y^j[x^i]F'^j=\sum_{j=0}^\infty y^j\sum_{i=0}^\infty x^i[x^i]F'^j=\sum_{j=0}^\infty y^jF'^j=\frac{1}{1-yF'}$。提取其 $[x^n]$ 上的幂级数 $P'(y)$ 即可。

将其一般化，考虑求解 $[x^n]\dfrac{P(x,y)}{Q(x,y)}$。上下同乘 $Q(-x,y)$ 并将 $Q$ 按 $x$ 项奇偶划分为 $Q_0(x,y)$ 和 $Q_1(x,y)$，就有 $[x^n]\dfrac{P(x,y)}{Q(x,y)}=[x^n]\dfrac{P(x,y)Q(-x,y)}{Q(x,y)Q(-x,y)}=[x^n]\dfrac{P(x,y)Q(-x,y)}{Q_0^2(x^2,y)-x^2Q_1^2(x^2,y)}$，设 $V(x,y)=Q_0^2(x,y)-xQ_1^2(x,y)$，$U_0(x,y),U_1(x,y)$ 为 $P(x,y)Q(-x,y)$ 按 $x$ 项的奇偶划分，那么就有 $[x^n]\dfrac{P(x,y)}{Q(x,y)}=[x^n]\dfrac{U_0(x^2,y)}{V(x^2,y)}+x\dfrac{U_1(x^2,y)}{V(x^2,y)}$，根据 $n$ 的奇偶性决定递归到哪一个分式即可。边界情况为 $[x^0]\dfrac{P(x,y)}{Q(x,y)}=\dfrac{[x^0]P(x,y)}{[x^0]Q(x,y)}$。

_这个东西叫 Bostan-Mori 算法。_

递归到第 $t$ 层时，$n$ 已经被砍到了 $n/2^t$ 量级，因此 $x$ 这一维大小为 $n/2^t$，每次递归后 $y$ 的次数会翻倍，大小为 $2^t$，所以 $P(x,y)$ 和 $Q(x,y)$ 的项数是 $\mathcal{O}(n)$ 的。

如何计算二元多项式的乘法？考虑对某一维（比如 $x$）使用 DFT，得到的点值序列形如 $\{(x_i,F_i(y))\}$，两个点值序列的点乘就变成了 $y$ 维上的多项式乘法。时间复杂度不变。

但是有一个更好写的做法：把形如 $x^ay^b$ 的项当作 $t^{ap+b}$，其中 $p$ 是 $y$ 维上可能得到的最高次数再加一，然后直接跑一元多项式乘法后还原即可。

代码一坨，放剪贴板里了，[code](https://www.luogu.com.cn/paste/7mfbt3zp)。

---

## 作者：Gorenstein (赞：0)

对于 $G(F(z))=z$，首先有拉格朗日反演

$$
n[z^n]F^{\langle-1\rangle}(z)^k=k\!\left[z^{n-k}\right]\!\left(\frac{z}{F(z)}\right)^n=k\!\left[z^{-k}\right]\!F(z)^{-n},
$$

这里无非是 $k=1$。设 $L=\sqrt{n}$，据此就有

$$
\begin{aligned}
G(z)&=\sum_{k=0}^{n}\left(\frac{1}{k}\left[z^{k-1}\right]\left(\frac{z}{F(z)}\right)^k\right)z^k\\
&=\sum_{i=0}^{L}\sum_{j=0}^L\left(\frac{1}{iL+j}\left[z^{iL+j-1}\right]\left(\frac{z}{F(z)}\right)^{iL+j}\right)z^{iL+j}\\
&=\sum_{i=0}^{L}z^{iL}\sum_{j=0}^L\frac{z^{j}}{iL+j}\left[z^{iL+j-1}\right]\left(\left(\frac{z}{F(z)}\right)^{iL}\left(\frac{z}{F(z)}\right)^{j}\right),
\end{aligned}
$$

于是 $O(n\sqrt{n}\log n)$ 预处理 $\big(\frac{z}{F(z)}\big)^{iL}$ 与 $\big(\frac{z}{F(z)}\big)^{j}$ 即可。之后内层和式暴力计算并与 $z^{iL}$ 相乘，加起来即是答案，这部分复杂度时是 $O(n^2)$。

```cpp
n=read()-1;
for(ll i=0;i<=n;i++)f[i]=read();
for(ll i=0;i<=n;i++)f[i]=f[i+1];
f[n]=0,Inv(f,g,n+1);
L=sqrt(n)+1,gj[0][0]=gl[0]=gil[0][0]=1;
for(ll i=1;i<=L;i++)
	Mul(gj[i-1],g,gj[i],n+1,n+1),Mul(gl,g,gl,n+1,n+1);
for(ll i=1;i<=L;i++)Mul(gil[i-1],gl,gil[i],n+1,n+1);
for(ll i=0;i<L;i++){
	for(ll i=0;i<=n;i++)cur[i]=0;
	for(ll j=0;j<L;j++){
		ll x=0,t=i*L+j-1;
		for(ll k=0;k<=t;k++)
			x=(x+gil[i][k]*gj[j][t-k]%mod)%mod;
		cur[j]=x*Qpow(t+1,mod-2)%mod;
	}
	for(ll j=n;j>=i*L;j--)cur[j]=cur[j-i*L];
	for(ll j=0;j<i*L;j++)cur[j]=0;
	for(ll j=0;j<=n;j++)h[j]=(h[j]+cur[j])%mod;
}
for(ll i=0;i<=n;i++)printf("%lld ",h[i]);
```

---


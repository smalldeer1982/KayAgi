# 边双连通图计数

## 题目描述

求 $n$ 个点的有标号边双连通图（简单无向图，整个图是一个边双连通分量）的个数，答案对 $998244353$ 取模。

## 说明/提示

$1 \le n \le 10^5$。

## 样例 #1

### 输入

```
1
2
3
4
5
```

### 输出

```
1
0
1
10
253
```

# 题解

## 作者：zhoukangyang (赞：34)

大家的做法都用了拉反，给个不用拉反的做法。

考虑容斥：钦定边集 $S$，满足 $S$ 中的边都是割边。

最终的图一定是若干个联通块由 $S$ 中的边连成的。若把联通块看做点，那么最终的图就是一颗树。

直接做不好做，因此更换枚举顺序。先枚举连通块（设大小分别为 $a_1,a_2,...,a_m$），再枚举 $S$。根据一个[经典结论](https://www.luogu.com.cn/problem/CF156D)，取 $S$ 的方案数是  $n^{m-2} \prod a_i$。带上容斥系数就是 $-\frac{1}{n^2} \prod (-na_i)$。

设[有标号连通图](https://www.luogu.com.cn/problem/P4841)的 $\rm EGF$ 为 $H$。那么设 $G(x)$ 满足 $G_i  = -niH_i$，答案就是 $[x^n]-\frac{n!}{n^2} e^{G}$。


核心代码：

```cpp
cin >> n;
poly F (n + 1);
F[0] = 1;
L(i, 1, n) F[i] = (ll) F[i - 1] * qpow (2, i - 1) % mod * inv[i] % mod;
F = F.Ln();
L(i, 1, n) F[i] = mod - (ll) F[i] * i % mod * n % mod;
F = F.Exp();
cout << (ll) (mod - F[n]) * inv[n] % mod * fac[n - 1] % mod << "\n";
```

---

## 作者：iostream (赞：19)

## 前置技能：无向连通图计数
设有标号无向图的 egf 为 $F(x)=\sum_{i=0}^\infty \frac{f_ix^i}{i!}$，容易知道 $f_i=2^{n\choose 2}$，则有标号连通无向图的 egf 满足 $G=\ln F$。

## 边双连通图
首先设有根连通无向图的指数生成函数是 $D(x)$，有根边双连通图的指数生成函数是 $B(x)$。
用 $B$ 来表示 $D$：假设根所在边双大小 $n$，其egf为 $\frac{b_nx^n}{n!}$，而对于其相邻的边，对于其中一条边，它挂着一个连通无向图，接在边双的任意一个点上，所以得到它的egf为 $nD(x)$；若干边自由排列（这里也可以理解成集合的组合），故邻边的egf是 $\exp(nD(x))$。
枚举大小求和得 
$$D(x)=\sum_{n\ge 1} \frac{b_nx^n\exp(nD(x))}{n!}=B(x\exp(D(x)))$$
设 $F(x)=x\exp(D(x))$ 则 $D(x)=B(F(x))$；
两边对 $F(x)$ 作复合逆得 $B(x)=D(F^{-1}(x))$。
有扩展拉格朗日反演公式如下：
$$[x^n]A(B^{-1}(x))=\frac{1}{n} [x^{n-1}]A'(x)(\frac{x}{B(x)})^n$$

代入可得 $[x^n]B(x)=\frac{1}{n} [x^{n-1}]D'(x)(\frac{x}{F(x)})^n$，继续化简可得
$$[x^n]B(x)=\frac{1}{n} [x^{n-1}]D'(x)\exp(-nD(x))$$
我们可以在 $O(n\log n)$ 的时间复杂度求得 $B(x)$ 的一项系数，注意是有根边双的 egf，最后要乘一个 $n!$ 和除以一个 $n$。

```cpp
//多项式模板略去
void init()
{
	F.resize(n+1);
	for(int i=0;i<F.size();++i)F[i]=power(2,(ll)i*(i-1)/2%(mod-1),ifac[i]);
	D=Ln(F);
	for(int i=0;i<D.size();++i)Mul(D[i],i);
	G=Deriv(D);
}

// B(x)->有根边双 
// D(x)=B(xexp(D(x)))
// [x^n]B(x) = \frac{1}{n}[x^{n-1}]D'(x) (1/exp(D))^n

int calc(int n)
{
	Poly C(D.begin(),D.begin()+n),L(G.begin(),G.begin()+n);
	for(int i=0;i<C.size();++i)Mul(C[i],mod-n);
	C=Exp(C)*L;
	return mul(inv[n],C[n-1]);
}

int main()
{
	init();
	scanf("%d",&n);
	ans=(ll)calc(n)*fac[n-1]%mod; //n!是因为egf, 除去n是因为有根
	printf("%d\n",ans);
}
```

---

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5828)
## 题意
求 $n$ 个点的有标号边双连通图数量，对 $998244353$ 取模。

$1\le n\le10^5$
## 思路
### 前置
[有标号无向连通图计数](https://www.luogu.com.cn/problem/P4841)、[扩展拉格朗日反演](https://www.luogu.com.cn/blog/cyffff/lagrange-inversion)
****
设有根无向连通图的 $\text{EGF}$ 为 $F(x)$，有根边双连通图的 $\text{EGF}$ 为 $G(x)$。

我们显然可以使用[有标号无向连通图](https://www.luogu.com.cn/problem/P4841)的 $\text{EGF}$ 乘上 $n$ 以得到 $F(x)$，于是考虑用 $F,G$ 互相表示。

对于一个有根无向连通图，我们可以枚举其根所在的边双大小，再算出所有连向其它部分的边的 $\text{EGF}$。

对于一条边，我们可以有：其挂着一个无向连通图；可以连在边双中任意一个点上。所以一条边的 $\text{EGF}$ 为 $nF(x)$。（其中 $n$ 为根节点所在的边双的大小）

由于连的多条边与一条边也可看为集合与元素的关系，可以直接得到
$$\begin{aligned}
F(x)&=\sum_{n\ge1}g_n\exp(nF(x))\frac{x^n}{n!}\\
&=\sum_{n\ge1}\frac{g_n}{n!}x^ne^{nF(x)}\\
&=\sum_{n\ge1}\frac{g_n}{n!}x^n{e^{F(x)}}^n\\
&=\sum_{n\ge1}\frac{g_n}{n!}\left(x\exp(F(x))\right)^n\\
&=G(x\exp(F(x)))
\end{aligned}$$
令 $H(x)=x\exp(F(x))$，有 $F(x)=G(H(x))$，根据扩展拉格朗日反演有
$$\begin{aligned}
[x^n]G(x)&=\frac 1 n\cdot[x^{n-1}]F'(x)\frac{x^n}{H^n(x)}\\
&=\frac 1 n\cdot[x^{n-1}]F'(x)\exp(-nF(x))
\end{aligned}
$$
至此直接求解即可。

时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int mod=998244353,N=524288+10;
namespace Poly{
	int n,m,a[N],b[N],c[N],s[N],ss[N],d[N],e[N];
	int f[N],g[N],h[N],F[N],tmp1[N],tmp2[N];
	int rev[N],inv[N],fac[N],ifac[N],G[19][N],lim;
	inline void init(int n,int mode=1){
		if(mode){
			int l=0;
			for(lim=1;lim<n;lim<<=1)l++;
			for(int i=1;i<lim;i++)
				rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
		}else{
			for(lim=1;lim<n;lim<<=1);
		}
	}
	inline int qpow(int x,int y){
		int res=1;
		while(y){
			if(y&1) res=1ll*res*x%mod;
			x=1ll*x*x%mod;
			y>>=1;
		}
		return res;
	}
	inline void Prefix(int n){
		inv[1]=1;
		for(int i=2;i<=n;i++)
			inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		fac[0]=1;
		for(int i=1;i<=n;i++)
			fac[i]=1ll*fac[i-1]*i%mod;
		ifac[n]=qpow(fac[n],mod-2);
		for(int i=n;i>=1;i--)
			ifac[i-1]=1ll*ifac[i]*i%mod;
		for(int i=1,p=1;i<=18;i++,p<<=1){
			G[i][0]=1;
			G[i][1]=qpow(3,mod-1>>i);
			for(int j=2;j<p;j++)
				G[i][j]=1ll*G[i][j-1]*G[i][1]%mod;
		}
	}
	inline void NTT(int *a,int t){
		for(int i=0;i<lim;i++)
			if(i<rev[i])
				swap(a[i],a[rev[i]]);
		for(int i=1,t=1;i<lim;i<<=1,t++){
			for(int j=0;j<lim;j+=i<<1){
				int t1,t2;
				for(int k=0;k<i;k++){
					t1=a[j+k];
					t2=1ll*G[t][k]*a[i+j+k]%mod;
					a[j+k]=(t1+t2)%mod;
					a[i+j+k]=(t1-t2+mod)%mod;
				}
			}
		}
		if(t==1) return ;
		int Inv=qpow(lim,mod-2);
		reverse(a+1,a+lim);
		for(int i=0;i<lim;i++)
			a[i]=1ll*a[i]*Inv%mod;
	}
	inline void Inv(int *a,int *b,int n){
		if(n==1){
			b[0]=qpow(a[0],mod-2);
			return ;
		}
		Inv(a,b,n+1>>1);
		init(n<<1);
		for(int i=0;i<n;i++)
			c[i]=a[i];
		for(int i=n;i<lim;i++)
			c[i]=0;
		NTT(c,1),NTT(b,1);
		for(int i=0;i<lim;i++)
			b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)%mod*b[i]%mod;
		NTT(b,-1);
		for(int i=n;i<lim;i++)
			b[i]=0;
	}
	inline void Mul(int *a,int *b,int n){
		init(n<<1);
		memset(c,0,lim<<2);
		memcpy(c,b,n<<2);
		NTT(a,1),NTT(c,1);
		for(int i=0;i<lim;i++)
			a[i]=1ll*a[i]*c[i]%mod;
		NTT(a,-1);
	}
	inline void Der(int *a,int *b,int n){
		for(int i=1;i<n;i++)
			b[i-1]=1ll*i*a[i]%mod;
		b[n-1]=0;
	}
	inline void Int(int *a,int *b,int n){
		for(int i=1;i<n;i++)
			b[i]=1ll*a[i-1]*inv[i]%mod;
		b[0]=0;
	}
	inline void polyln(int *a,int *b,int n){
		static int p[N];
		memset(p,0,n<<3);
		memset(d,0,n<<3);
		Der(a,p,n);
		Inv(a,d,n);
		Mul(p,d,n);
		Int(p,b,n);
	}
	inline void Log(int n,int *f,int *g){
		init(n);
		polyln(f,g,lim);
		for(int i=n;i<lim;i++)
			g[i]=0;
	}
	inline void polyexp(int n,int *a,int *b){
		if(n==1){
			b[0]=1;
			return ;
		}
		polyexp(n+1>>1,a,b);
		Log(n,b,s);
		for(int i=0;i<n;i++)
			s[i]=a[i]>=s[i]?a[i]-s[i]:a[i]+mod-s[i];
		for(int i=n;i<lim;i++)
			b[i]=s[i]=0;
		s[0]++;
		NTT(s,1),NTT(b,1);
		for(int i=0;i<lim;i++)
			b[i]=1ll*b[i]*s[i]%mod;
		NTT(b,-1);
		for(int i=n;i<lim;i++)
			b[i]=0;
	}
	inline void Exp(int n,int *a,int *b){
		polyexp(n,a,b);
	}
}
using namespace Poly;
int ask[5],L;
inline int solve(int m){
	memset(g,0,sizeof(g));
	memset(tmp1,0,sizeof(tmp1));
	for(int i=0;i<L;i++)
		g[i]=1ll*(mod-m)*F[i]%mod;
	Exp(L,g,tmp1);
	init(L<<1);
	NTT(tmp1,1);
	for(int i=0;i<lim;i++)
		tmp1[i]=1ll*tmp1[i]*tmp2[i]%mod;
	NTT(tmp1,-1);
	return 1ll*tmp1[m-1]*inv[m]%mod*fac[m-1]%mod;
}
int main(){
	for(int i=0;i<5;i++)
		ask[i]=read(),n=max(n,ask[i]+1);
	init(n,0);
	L=lim;
	Prefix(L);
	for(int i=0;i<L;i++)
		f[i]=1ll*qpow(2,1ll*i*(i-1)/2%(mod-1))*ifac[i]%mod;
	Log(L,f,F);
	for(int i=0;i<L;i++)
		F[i]=1ll*F[i]*i%mod;
	Der(F,tmp2,L);
	NTT(tmp2,1);
	for(int i=0;i<5;i++)
		write(solve(ask[i])),putc('\n');
	flush();
	return 0;
}
```


---

## 作者：Kinandra (赞：3)

感觉 `iostream` 讲的好清楚啊.  %

推式子的思路基本与其他题解一致, 已经推完了的可以康康 `Part 4` .

#### Part 1 简单的预处理

先从有标号无向图的**指数生成函数**(简称 `EGF `) $F(x)=\sum_i 2^{n\choose 2}x^i$, ($2^{n\choose 2}$ 表示无向图每两个点之间都可以选择连边或不连)推导出有标号连通无向图的 EGF .

由于无向图是由各个连通块组合出来的, 故 $F=\exp G$ , 求得 $G=\ln F$ .

#### Part 2 将双连通图与好求的连通图建立联系

首先设有根连通无向图的 EGF 是 $D(x)$, 有根边双连通图的 EGF 是 $B(x)=\sum_i{b_i\over i!}x^i$ . 易知 $[x^n]D(x)=n[x^n]G(x)$ .

枚举一个有根连通无向图的根所处边双连通分量大小 $n$, 我们可以得到:
$$
D(x)=\sum_{n=1}^{+\infty}{b_nx^n\exp(nD(x))\over n!}=\sum_{n=1}^{+\infty}{b_n\over n!}(x\exp(D(x)))^n=B(x\exp D(x))
$$

#### Part 3 推导计算

令 $H(x)=x\exp D(x)$ , $H^{-1}(x)$ 为 $H(x)$ 的复合逆, 则 $B(x)=D(H^{-1}(x))$.

由扩展拉格朗日反演公式得:
$$
[x^n]B(x)={1\over n}[x^{-1}]D'(x)(H(x))^{-n}={1\over n}[x^{n-1}]D'(x)({x\over H(x)})^{n}
$$
将 $H(x)=x\exp D(x)$ 代入得:
$$
[x^n]B(x)={1\over n}[x^{n-1}]D'(x)({1\over \exp D(x)})^{n}={1\over n}[x^{n-1}]D'(x)\exp (-nD(x))
$$

#### Part 4 细节

注意 $D,B$ 都是**有根**的且是 **EGF** , 系数处理时要格外注意.

在计算 $F$ 的过程中我们需要计算 $2^{n\choose 2}$ , 注意**指数上**的 ${n\choose 2}$ 要在 $\bmod (mod-1)$ 意义下处理才行(因为这个错调到自闭).

注意 $D'(x)$ 的 `NTT` 变换可以预处理, 不需要对每个询问都重新计算, 可以卡一点常.

#### Part 5 Code

调题苦手福音!

```cpp
#include <bits/stdc++.h>
#define mod 998244353
using namespace std;
int read();
int M(int x) { return x >= mod ? x - mod : x; }
void Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }
int fsp(long long bs, int p) {
    int rt = 1;
    while (p) {
        if (p & 1) rt = bs * rt % mod;
        bs = bs * bs % mod, p >>= 1;
    }
    return rt;
}
int fac[300005], caf[300005], lim = 300000;
void init() {
    fac[0] = 1;
    for (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;
    caf[lim] = fsp(fac[lim], mod - 2);
    for (int i = lim; i >= 1; --i) caf[i - 1] = 1ll * caf[i] * i % mod;
}
int inv(int x) { return 1ll * caf[x] * fac[x - 1] % mod; }

int L = 1 << 18;
int O[300005];
void initO() {
    O[0] = 1, O[1] = fsp(3, (mod - 1) / L);
    for (int i = 2; i < L; ++i) O[i] = 1ll * O[i - 1] * O[1] % mod;
}
int R[300005];
void getR(int len, int w) {
    for (int i = 1; i < len; ++i) R[i] = R[i >> 1] >> 1 | ((i & 1) << w - 1);
}
struct Poly {
    int x[300005];
    int &operator[](int p) { return x[p]; }
    void mem(int len, int st = 0) { memset(x + st, 0, len << 2); }
    void cpy(Poly &y, int len) { memcpy(x, y.x, len << 2); }
    void cpy(int *y, int len) { memcpy(x, y, len << 2); }
    void der(int len) {
        for (int i = 0; i < len - 1; ++i) x[i] = 1ll * (i + 1) * x[i + 1] % mod;
        x[len - 1] = 0;
    }
    void inter(int len) {
        for (int i = len - 1; i >= 1; --i) x[i] = 1ll * inv(i) * x[i - 1] % mod;
        x[0] = 0;
    }

    void dft(int len) {
        for (int i = 1; i < len; ++i) R[i] > i ? swap(x[i], x[R[i]]) : void();
        for (int l = 2; l <= len; l <<= 1)
            for (int i = 0, m = l >> 1, dO = L / l; i < len; i += l)
                for (int j = i, t, *tO = O; j < i + m; ++j, tO += dO) {
                    t = 1ll * *tO * x[j + m] % mod;
                    x[j + m] = M(x[j] - t + mod), x[j] = M(x[j] + t);
                }
    }

    void idft(int len) {
        int ny = (dft(len), reverse(x + 1, x + len), fsp(len, mod - 2));
        for (int i = 0; i < len; ++i) x[i] = 1ll * x[i] * ny % mod;
    }

    void Inv(int len) {
        static Poly y, tx, ty;
        y.mem(len << 1), tx.mem(len << 1), ty.mem(len << 1);
        y[0] = fsp(x[0], mod - 2);
        for (int tl = 2, w = 1; tl <= len; tl <<= 1, ++w) {
            tx.cpy(x, tl), ty.cpy(y, tl), getR(tl << 1, w + 1);
            tx.dft(tl << 1), ty.dft(tl << 1);
            for (int i = 0; i < (tl << 1); ++i)
                tx[i] = 1ll * tx[i] * ty[i] % mod * ty[i] % mod;
            tx.idft(tl << 1);
            for (int i = 0; i < tl; ++i) y[i] = M(M(y[i] << 1) - tx[i] + mod);
        }
        cpy(y, len);
    }

    void Ln(int len) {
        int w = 0;
        while ((1 << w) < len) ++w;
        static Poly y;
        y.mem(len << 1), y.cpy(x, len), y.Inv(len), der(len);
        getR(len << 1, w + 1), y.dft(len << 1), dft(len << 1);
        for (int i = 0; i < (len << 1); ++i) x[i] = 1ll * x[i] * y[i] % mod;
        idft(len << 1), mem(len, len), inter(len);
    }

    void exp(int len, int t = 1) {
        static Poly y, tx, ty;
        y.mem(len << 1), tx.mem(len << 1), ty.mem(len << 1), y[0] = t;
        for (int tl = 2, w = 1; tl <= len; tl <<= 1, ++w) {
            ty.cpy(y, tl), ty.Ln(tl);
            for (int i = 0; i < tl; ++i) tx[i] = M(x[i] - ty[i] + mod);

            tx[0] = t, ty.cpy(y, tl), getR(tl << 1, w + 1);
            tx.dft(tl << 1), ty.dft(tl << 1);
            for (int i = 0; i < (tl << 1); ++i)
                ty[i] = 1ll * tx[i] * ty[i] % mod;
            ty.idft(tl << 1), y.cpy(ty, tl);
        }
        cpy(y, len);
    }
} F, G, dG, nG;

void prework() {
    int len = 1 << 17;
    for (int i = 0; i < len; ++i)
        F[i] = 1ll * fsp(2, 1ll * i * (i - 1) / 2 % (mod - 1)) * caf[i] % mod;
    G.cpy(F, len), G.Ln(len);
    for (int i = 0; i < len; ++i) G[i] = 1ll * G[i] * i % mod;
    dG.cpy(G, len), dG.der(len), dG.dft(len << 1);
}

void work(int n) {
    int len = 1 << 17;
    nG.mem(len << 1);
    for (int i = 0; i < len; ++i) nG[i] = 1ll * G[i] * (mod - n) % mod;
    nG.exp(len), nG.dft(len << 1);
    for (int i = 0; i < (len << 1); ++i) nG[i] = 1ll * nG[i] * dG[i] % mod;
    nG.idft(len << 1);
    printf("%d\n", 1ll * nG[n - 1] * inv(n) % mod * fac[n - 1] % mod);
}

int main() {
    init(), initO(), prework();
    for (int i = 1; i <= 5; ++i) work(read());
    return 0;
}

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
```



---

## 作者：gxy001 (赞：2)

## 边双联通图计数

前置知识：[无向联通图计数](https://www.luogu.com.cn/problem/P4841)，扩展拉格朗日反演。

### 无向联通图计数

设 $F(x)$ 为有标号无向图的 $\text{EGF}$，$G(x)$ 为有标号无向联通图的 $\text{EGF}$，根据 $\exp$ 的组合意义有 $F=\exp G$，所以有 $G=\ln F$，$F(x)=\sum\limits_{i=0}^\infin\frac{2^{i\choose 2}x^i}{i!}$。

### 边双联通图计数

设有根有标号无向联通图的 $\text{EGF}$ 为 $D(x)$，显然有 $[x^n]D(x)=n[x^n]G(x)$。设有根有标号边双联通图的 $\text{EGF}$ 为 $B(x)$，注意到一个有根无向图一定是由根所在的边双向外连了一些无向图构成的，即 

$$
D(x)=\sum\limits_{i=1}^\infin\frac{b_ix^i\exp(iD(x))}{i!}=B(x\exp(D(x)))
$$

设 $F(x)=x\exp(D(x))$，则 $D(x)=B(F(x))$，两边对 $F(x)$ 作复合逆，则有 $B(x)=D(F^{-1}(x))$，由扩展拉格朗日反演得 $[x^n]B(x)=\frac{1}{n}[x^{n-1}](D'(x)(\frac{x}{F(x)})^n)$ ，化简得：
$$
[x^n]B(x)=\frac{1}{n}[x^{n-1}](D'(x)\exp(-nD(x)))
$$

```cpp
#include<cstdio>
#include<algorithm>
int const mod=998244353,g=3,gi=998244354/3,maxn=400010;
int pow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*x*res%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return res;
}
struct NTT{
	int r[maxn],lim;
	NTT():r(),lim(){}
	void getr(int lm){
		lim=lm;
		for(int i=0;i<lim;i++)r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));
	}
	void operator ()(int *a,int type){
		for(int i=0;i<lim;i++)if(i<r[i])std::swap(a[i],a[r[i]]);
		for(int mid=1;mid<lim;mid<<=1){
			int rt=pow(type==1?g:gi,(mod-1)/(mid<<1));
			for(int r=mid<<1,j=0;j<lim;j+=r){
				int p=1;
				for(int k=0;k<mid;k++,p=1ll*p*rt%mod){
					int x=a[j+k],y=1ll*p*a[j+mid+k]%mod;
					a[j+k]=(x+y)%mod,a[j+mid+k]=(x-y+mod)%mod;
				}
			}
		}
		if(type==-1)for(int i=0,p=pow(lim,mod-2);i<lim;i++)a[i]=1ll*p*a[i]%mod;
	}
}ntt;
void inv(int const *a,int *ans,int n){
	static int tmp[maxn];
	for(int i=0;i<n<<1;i++)tmp[i]=ans[i]=0;
	ans[0]=pow(a[0],mod-2);
	for(int m=2;m<=n;m<<=1){
		int lim=m<<1;
		ntt.getr(lim);
		for(int i=0;i<m;i++)tmp[i]=a[i];
		ntt(tmp,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=ans[i]*(2-1ll*ans[i]*tmp[i]%mod+mod)%mod,tmp[i]=0;
		ntt(ans,-1);
		for(int i=m;i<lim;i++)ans[i]=0;
	}
}
void inte(int const *a,int *ans,int n){
	for(int i=n-1;i;i--)ans[i]=1ll*a[i-1]*pow(i,mod-2)%mod;
	ans[0]=0;
}
void der(int const *a,int *ans,int n){
	for(int i=1;i<n;i++)ans[i-1]=1ll*i*a[i]%mod;
	ans[n-1]=0;
}
void ln(int const *a,int *ans,int n){
	static int b[maxn];
	for(int i=0;i<n<<1;i++)ans[i]=b[i]=0;
	inv(a,ans,n);
	der(a,b,n);
	int lim=n<<1;
	ntt.getr(lim);
	ntt(b,1),ntt(ans,1);
	for(int i=0;i<lim;i++)b[i]=1ll*ans[i]*b[i]%mod,ans[i]=0;
	ntt(b,-1);
	for(int i=n;i<lim;i++)b[i]=0;
	inte(b,ans,n);
}
void exp(int const *a,int *ans,int n){
	static int f[maxn];
	for(int i=0;i<n<<1;i++)ans[i]=f[i]=0;
	ans[0]=1;
	for(int m=2;m<=n;m<<=1){
		int lim=m<<1;
		ln(ans,f,m);
		f[0]=(a[0]+1-f[0]+mod)%mod;
		for(int i=1;i<m;i++)f[i]=(a[i]-f[i]+mod)%mod;
		ntt.getr(lim);
		ntt(f,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=1ll*ans[i]*f[i]%mod,f[i]=0;
		ntt(ans,-1);
		for(int i=m;i<lim;i++)ans[i]=0;
	}
}
int f[maxn],d[maxn],t[maxn],fac[maxn],ifac[maxn],lim=1<<17,tpd[maxn];
int main(){
	fac[0]=1;
	for(int i=1;i<lim;i++)fac[i]=1ll*fac[i-1]*i%mod;
	ifac[lim-1]=pow(fac[lim-1],mod-2);
	for(int i=lim-1;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;
	for(int i=0;i<lim;i++)f[i]=1ll*pow(2,1ll*i*(i-1)/2%(mod-1))*ifac[i]%mod;
	ln(f,d,lim);
	for(int i=0;i<lim;i++)d[i]=1ll*d[i]*i%mod;
	int testcase=5;
	der(d,tpd,lim);
	ntt.getr(lim<<1);
	ntt(tpd,1);
	while(testcase--){
		int n;
		scanf("%d",&n);
		for(int i=0;i<lim;i++)f[i]=0,t[i]=1ll*(mod-n)*d[i]%mod;
		exp(t,f,lim);
		ntt.getr(lim<<1);
		ntt(f,1);
		for(int i=0;i<lim<<1;i++)f[i]=1ll*f[i]*tpd[i]%mod;
		ntt(f,-1);
		printf("%lld\n",1ll*pow(n,mod-2)*f[n-1]%mod*fac[n-1]%mod);
	} 
	return 0;
}
```



---

## 作者：Panda_hu (赞：2)

[点此查看全文](https://blog.csdn.net/qq_34940287/article/details/107191864)
> 求 $n$ 个点的有标号边双连通图（简单无向图，整个图是一个边双连通分量）的个数，答案对 $998244353$ 取模。

> 边双连通图:如果一个无向连通图删去任意一条边都仍然是连通的，我们就称其为边双连通图。

  知道[点双连通计数](https://www.luogu.com.cn/blog/littlejuruo/solution-p5827)怎么做之后边双就很简单了。
 
  首先我们需要知道:对于一个无向简单连通图，任意一个点必定在**有且只有一个**边双连通分量里面，一个边双连通分量的大小大于等于$1$。

  同样用上道题的方法得到$i$个点**有根**无向连通图数$d_i$的生成函数为$D(x)$。
 
  定义$i$个点**有根**(没错,是有根)边双连通图数$b_i$的生成函数为$B(x)$。
 
  同样先找$B(x)$与$D(x)$之间的关系，同样对于一个无向连通图的根$R$，根据性质我们这只能够找到有且一个包含该点的边双连通分量。
 
  还是那张奇怪的图，显然包含$R$的边双连通分量的点集为$\{4,5,6,7,8,9,10,11,12,R\}$。
 
![p1](https://img-blog.csdnimg.cn/20200708085405193.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTQwMjg3,size_16,color_FFFFFF,t_70)

  由于只有一个边双连通分量，我们无需删掉$R$。我们可以直接考虑在这个边双连通分量的点上插入连同块。
 
  但是问题来了，如果我们仍然像上一道题目那样直接在上面插上一个以其为根的无向连通图，那么下面这个图也会被计入连通边双连通分量的点集为$\{4,5,6,7,8,9,10,11,12,R\}$的情况:
  ![p3](https://img-blog.csdnimg.cn/2020070810200982.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTQwMjg3,size_16,color_FFFFFF,t_70)
 
  事实上我们知道整个图才是一个边双连通分量，因此这样会算重。
 
  如何解决？其实我们只需要让连通块的根连到这个边双连通分量的任意一点即可(即规定根不在边双连通分量上而是隔了一条边)。
  接下来枚举这个边双连通分量大小为$i$。
 
  那么一个连通块连到这个边双连通分量的**任意一点**的方案数$iD(x)$。
 
  由于我们可以选任意多个互不干扰的连通块接上这个边双连通分量，因此整个在边双连通分量上接连通块的方案数的生成函数为$e^{iD(x)}$。
 
  接下来很容易得到:
  $$D(x)=\sum^{∞}_{i=1}b_ie^{iD(x)}\frac{x^i}{i!}=\sum^{∞}_{i=1}b_i\frac{(xe^{D(x)})^i}{i!}=B(xe^{D(x)})$$
  接下来我们同样用复合逆解决:
  令$H(x)=xe^{D(x)}$，得到$B(H(x))=D(x)$
  $$[x^n]B(x)=\frac{1}{n}[x^{n-1}]D'(x)(\frac{x}{H(x)})^n$$
  $$[x^n]B(x)=\frac{1}{n}[x^{n-1}]D'(x)e^{-nD(x)}$$
  没有什么细节，直接用多项式全家桶爆算即可。
 
  理论复杂度:$O(n\log n)$(常数巨大)。
  # 实现
  ```cpp
  #include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
using namespace std;

#define LL long long
#define DB double
#define MAXN 600000
#define MOD 998244353
#define G 3
#define Pr pair<LL,int>
#define X first
#define Y second
#define INF 1000000000000000000
#define mem(x,v) memset(x,v,sizeof(x))

LL read(){
    LL x=0,F=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x*10+c-'0')%MOD;c=getchar();}
    return x*F;
}
int add(int a,int b){return (a+b>=MOD)?a+b-MOD:a+b;}
int dec(int a,int b){return (a-b<0)?a-b+MOD:a-b;}
int mul(int a,int b){return (1LL*a*b)%MOD;}
int fst_pow(int a,LL b){
    int res=1;
    while(b){
        if(b&1)res=mul(res,a);
        a=mul(a,a),b>>=1;
    }return res;
}

int inv2,fac[MAXN+5],ifac[MAXN+5];

void prepare(){
    fac[0]=1;
    for(int i=1;i<=MAXN;i++)fac[i]=mul(fac[i-1],i);
    ifac[MAXN]=fst_pow(fac[MAXN],MOD-2);
    for(int i=MAXN;i>=1;i--)ifac[i-1]=mul(ifac[i],i);
}
void NTT(int *a,int n,int x){
    for(int i=0,j=0;i<n;i++){
        if(i<j)swap(a[i],a[j]);
        int k=n>>1;
        while(k&&(k&j))j^=k,k>>=1;
        j^=k;
    }
    for(int i=1;i<n;i<<=1){
        int gn=fst_pow(G,(MOD-1)/(i<<1));
        for(int j=0;j<n;j+=(i<<1)){
            int g=1;
            for(int k=0;k<i;k++,g=mul(g,gn)){
                int X=a[j+k],Y=mul(a[i+j+k],g);
                a[j+k]=add(X,Y),a[i+j+k]=dec(X,Y);
            }
        }
    }
    if(x==1)return ;
    int ny=fst_pow(n,MOD-2);reverse(a+1,a+n);
    for(int i=0;i<n;i++)a[i]=mul(a[i],ny);
}
void ploy_inv(int n,int *a,int *b){
    static int c[MAXN+5];
    if(n==1){b[0]=fst_pow(a[0],MOD-2);return ;}
    ploy_inv((n+1)>>1,a,b);
    int len=1;
    while(len<(n<<1))len<<=1;
    copy(a,a+len,c);
    fill(c+n,c+len,0),NTT(c,len,1);
    fill(b+n,b+len,0),NTT(b,len,1);
    for(int i=0;i<len;i++)
    b[i]=mul(dec(2,mul(c[i],b[i])),b[i]);
    NTT(b,len,-1);
    fill(b+n,b+len,0);
}
void ploy_der(int n,int *a,int *b){
    for(int i=1;i<n;i++)b[i-1]=mul(a[i],i);
    b[n-1]=0;
}
void ploy_cal(int n,int *a,int *b){
    for(int i=1;i<n;i++)b[i]=mul(a[i-1],fst_pow(i,MOD-2));
    b[0]=0;
}
void ploy_ln(int n,int *a,int *b){
    static int A[MAXN+5],B[MAXN+5];
    fill(A,A+(n<<1),0),fill(B,B+(n<<1),0);
    ploy_der(n,a,A),ploy_inv(n,a,B);
    int len=1;while(len<(n<<1))len<<=1;
    NTT(A,len,1),NTT(B,len,1);
    for(int i=0;i<len;i++)A[i]=mul(A[i],B[i]);
    NTT(A,len,-1),ploy_cal(n,A,b);
}
void ploy_exp(int n,int *a,int *b){
    static int F[MAXN+5];
    if(n==1){b[0]=1;return ;}
    ploy_exp((n+1)>>1,a,b);
    fill(F,F+(n<<1),0),ploy_ln(n,b,F);
    for(int i=0;i<n;i++)F[i]=dec(a[i],F[i]);
    F[0]=add(F[0],1);
    int len=1;while(len<(n<<1))len<<=1;
    fill(b+n,b+len,0),NTT(b,len,1);
    fill(F+n,F+len,0),NTT(F,len,1);
    for(int i=0;i<len;i++)b[i]=mul(b[i],F[i]);
    NTT(b,len,-1),fill(b+n,b+len,0);
}
int n,m,f[MAXN+5],D[MAXN+5],dD[MAXN+5],tmp[MAXN+5],nh[MAXN+5];
void init(){
    m=1<<17;
    for(int i=0;i<m;i++)f[i]=mul(fst_pow(2,1LL*i*(i-1)/2%(MOD-1)),ifac[i]);
    ploy_ln(m,f,D);
    for(int i=0;i<m;i++)D[i]=mul(D[i],i);
    ploy_der(m,D,dD);NTT(dD,m<<1,1);
}
int solve(int n){
    for(int i=m;i<(m<<1);i++)tmp[i]=0;
    for(int i=0;i<m;i++)tmp[i]=mul(D[i],MOD-n);
    ploy_exp(m,tmp,nh);
    NTT(nh,m<<1,1);
    for(int i=0;i<(m<<1);i++)nh[i]=mul(dD[i],nh[i]);
    NTT(nh,m<<1,-1);
    return mul(nh[n-1],mul(fst_pow(n,MOD-2),fac[n-1]));
}

int main(){
    prepare(),init();
    for(int i=1;i<=5;i++)
    printf("%d\n",solve(read()));
}
  ```

---

## 作者：littlez_meow (赞：1)

前置知识：[无向连通图计数](https://www.luogu.com.cn/problem/P4841)、扩展拉格朗日定理（不会也没关系，这里给出了）

### 思路

钦定一个根便于分析问题。设有根有标号边双的 EGF 为 $F(x)$。

发现一个有根无向联通图可以视为有根边双向外挂了几个无向连通图。设有根无向连通图的 EGF 为 $G(x)$，枚举根边双的大小 $n$，则带根的父向边有根无向连通图的 EGF 为 $nG(x)$，因为根向边双一共有 $n$ 种连边方式。再根据 EGF $\exp$ 的组合意义，有不带边双根的图的 EGF 为 $e^{nG(x)}$。

记 $F(x)=\sum\limits_{i=1}^\infty f_ix^i$，组合意义得到：

$$G(x)=\sum\limits_{n=1}^{\infty}e^{nG(x)}f_nx^n$$

整理一下：

$$G(x)=\sum\limits_{n=1}^{\infty}f_n\left(e^{G(x)}x\right)^n$$

右边正是 $F$ 的形式：

$$G(x)=F\left(e^{G(x)}x\right)$$

设 $H(x)=xe^{G(x)}$，有 $G(x)=F(H(x))$。

好，复合函数，常数项为 $0$。扩展拉格朗日反演，启动！

**【扩展拉格朗日反演定理】** 若 $A(B(x))=C(x)$，则 $[x^n]A(x)=\dfrac 1 n[x^{n-1}]C'(x)\left(\dfrac{x}{B(x)}\right)^n$。

带式子，整理，得到：

$$[x^n]F(x)=\dfrac 1 n[x^{n-1}]G'(x)e^{-nG(x)}$$

多项式 $\exp$、求导即可，时间复杂度 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i) 
#define ll long long
using namespace std;
const int MAXN=(1<<20)+1;
const int MOD=998244353,G=3;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
const int INVG=qpow(G,MOD-2);
int gpow[24],invgpow[24];
inline void calc(){
	F(i,1,23) gpow[i]=qpow(G,(MOD-1)>>i),invgpow[i]=qpow(INVG,(MOD-1)>>i);
	return;
}
inline void meow(int&t){
	t<0&&(t+=MOD);
	t>=MOD&&(t-=MOD);
	return;
}
int rev[MAXN];
inline void NTT(int*poly,int len,bool inv){
	F(i,0,len-1) (i<rev[i])&&(swap(poly[i],poly[rev[i]]),1);
	static ll g[MAXN];
	g[0]=1;
	for(int i(1),expo(1);i<len;i<<=1,++expo){
		ll omega=inv?invgpow[expo]:gpow[expo];
		F(j,1,i-1) g[j]=g[j-1]*omega%MOD;
		for(int j(0);j<len;j+=(i<<1)) F(k,0,i-1){
			int&x(poly[j|k]),&y(poly[i|j|k]);
			ll qwq(g[k]*y%MOD);
			y=x-qwq;
			y<0&&(y+=MOD);
			x+=qwq;
			x>=MOD&&(x-=MOD);
		}
	}
	if(inv){
		ll invl=qpow(len,MOD-2);
		F(i,0,len-1) poly[i]=poly[i]*invl%MOD;
	}
	return;
}
struct poly{
	int num[MAXN]={};
	int len=0;
	
	inline void turn(const int a){
		len=0,num[0]=a;
		return;
	}
	inline void resize(const int a){
		for(;len>a;--len) num[len]=0;
		len=a;
		if(len<0) len=0;
		return;
	}
	inline poly operator+(const poly a)const{
		poly res;
		res.len=max(a.len,len);
		F(i,0,res.len) res.num[i]=((num[i]+a.num[i])%MOD+MOD)%MOD;
		return res;
	}
	inline poly operator+(const int a)const{
		poly res=*this;
		int&qwq(res.num[0]);
		qwq+=a;
		meow(qwq);
		return res;
	}
	inline poly operator-(const poly a)const{
		return a*(-1)+*this;
	}
	inline poly operator-(const int a)const{
		return *this+(-a);
	}
	inline poly operator*(const poly a)const{
		poly x,y=*this;
		if(a.len*1ll*len<=1e5){
			x.len=a.len+len;
			F(i,0,len) F(j,0,a.len){
				int&qwq(x.num[i+j]);
				qwq+=a.num[j]*1ll*num[i]%MOD;
				qwq>=MOD&&(qwq-=MOD);
			}
			return x;
		}
		x=a;
		int expo=max(__lg(((len+a.len+1)<<1)+1)+1,1),l=1<<expo;
		F(i,0,l-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<(expo-1));
		NTT(x.num,l,0);
		NTT(y.num,l,0);
		F(i,0,l-1) x.num[i]=1ll*x.num[i]*y.num[i]%MOD;
		NTT(x.num,l,1);
		x.resize(len+a.len);
		return x;
	}
	inline poly operator*(const int a)const{
		poly res=*this;
		F(i,0,len){
			int&qwq(res.num[i]);
			qwq=a*1ll*qwq%MOD;
			meow(qwq);
		}
		return res;
	}
	inline poly inv(){
		poly res;
		res.num[0]=qpow(num[0],MOD-2);
		for(int l(2),expo(1);l<(len<<1);l<<=1,++expo){
			int tmp[MAXN]={};
			F(i,0,(l<<1)-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<expo);
			memcpy(tmp,num,sizeof(int)*l);
			NTT(tmp,l<<1,0);
			NTT(res.num,l<<1,0);
			F(i,0,(l<<1)-1){
				int&qwq(res.num[i]),t(2-1ll*qwq*tmp[i]%MOD);
				meow(t);
				qwq=1ll*qwq*t%MOD;
			}
			NTT(res.num,l<<1,1);
			F(i,l,(l<<1)-1) res.num[i]=0;
		}
		res.resize(len);
		return res;
	}
	inline poly diff(){
		poly res;
		res.len=len-1;
		F(i,0,res.len) res.num[i]=1ll*num[i+1]*(i+1)%MOD;
		return res;
	}
	inline poly inte(){
		poly res;
		res.len=len+1,res.num[0]=0;
		F(i,1,res.len) res.num[i]=1ll*num[i-1]*qpow(i,MOD-2)%MOD;
		return res;
	}
	inline poly ln(){
		poly res;
		res=diff()*inv();
		res=res.inte();
		res.resize(len);
		return res;
	}
	inline poly exp(){
		poly res;
		int lenbfr=len;
		res.turn(1);
		for(int l(2);l<=lenbfr<<1;l<<=1){
			res.len=len=l-1;
			res=(*this-res.ln()+1)*res;
		}
    	len=lenbfr;
    	res.resize(len);
    	return res;
	}
};
int fact[MAXN],inv[MAXN];
poly h,g;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	calc();
	fact[0]=1;
	F(i,1,100001) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[100001]=qpow(fact[100001],MOD-2);
	R(i,100001,1) inv[i-1]=inv[i]*1ll*i%MOD;
	h.len=100001;
	F(i,0,100001) h.num[i]=qpow(2,((i-1ll)*i>>1)%(MOD-1))*inv[i]%MOD;
	g=h.ln();
	poly ans;
	F(i,1,100001) g.num[i]=g.num[i]*1ll*i%MOD;
	h=g.diff();
	F(i,1,5){
		int n;
		cin>>n;
		ans=g*(-n);
		ans.resize(n+1);
		ans=ans.exp();
		ll qwq(0);
		F(j,0,n-1) qwq=(qwq+ans.num[j]*1ll*h.num[n-1-j])%MOD;
		cout<<qwq*qpow(n,MOD-2)%MOD*fact[n-1]%MOD<<"\n";
	}
	return 0;
}
```

---

## 作者：Infinite_Eternity (赞：1)

# Description

[P5828 边双连通图计数](https://www.luogu.com.cn/problem/P5828)

给定一个 $n$，求出点数为 $n$ 的边双连通图的个数。

# Analysis

其实思路跟 [点双连通分量计数](https://www.luogu.com.cn/problem/solution/P5827?orderBy=time&page=1) 差不多的。

我们设 $F(x)$ 为有标号无向图的指数级生成函数，$G(x)$ 为有标号无向连通图的指数型生成函数。可以得到：

$$F(x)=\sum_{i=1}^{\infty} \frac{2^{\binom{i}{2}}}{i!}x^i$$

$$F(x)=e^{G(x)}\rightarrow G(x)=\ln F(z)$$

接着我们设 $D(x)$ 为有根无向连通图的指数型生成函数，$B(x)$ 为有根无向边双连通分量的指数型生成函数，我们可以得到：

$$D(x)=\sum_{i=1} \frac{b_ie^{iD(x)}}{i!}x^i$$

性感证明就是我们根所在的边双联通分量大小如果为 $i$，那么就相当于把连通图通过一条边挂在 $i$ 个点上面，而不是跟点双联通计数一样选一个点为连通图的根，就是 $e^{iD(x)}$，而边双联通分量又有 $b_i$ 种方法。

于是，从上面的式子我们可以推得：

$$D(x)=B(xe^{D(x)})$$

我们如果设 $F(x)=xe^{D(x)}$，则 $D(x)=B(F(x))$，两边同时做复合逆，可以得到 $B(x)=D(F^{-1}(x))$。于是，这里我们就可以使用拓展拉格朗日反演了：

$$
\begin{aligned}
[x^n]B(x)&=[x^n]D(F^{-1}(x))\\
&=\frac{1}{n}[x^{-1}]D^{'}(x)F(x)^{-n}\\
&=\frac{1}{n}[x^{n-1}]D^{'}(x)(\frac{x}{F(x)})^n\\
&=\frac{1}{n}[x^{n-1}]D^{'}(x)(\frac{x}{xe^{D(x)}})^n\\
&=\frac{1}{n}[x^{n-1}]D^{'}(x)e^{-nD(x)}
\end{aligned}
$$

于是，我们就可以在 $\mathcal{O}(n \log n)$ 的时间复杂度内解决这个问题。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define mod 998244353
#define Gii 332748118
#define ll long long
#define MAXN 300005
#define Gi 3

inline int quick_pow (int a,int b)
{
    int res = 1;
    for (; b; b >>= 1,a = 1ll * a * a % mod) if (b & 1) res = 1ll * res * a % mod;
    return res;
}

int limit,l,r[MAXN];

inline void NTT (int *a,int type)
{
    for (Int i = 0; i < limit; ++ i) if (i < r[i]) swap (a[i],a[r[i]]);
    for (Int mid = 1; mid < limit; mid <<= 1)
    {
        int Wn = quick_pow (type == 1 ? Gi : Gii,(mod - 1) / (mid << 1));
        for (Int R = mid << 1,j = 0; j < limit; j += R)
        {
            for (Int k = 0,w = 1; k < mid; ++ k,w = 1ll * w * Wn % mod)
            {
                int x = a[j + k],y = 1ll * w * a[j + k + mid] % mod;
                a[j + k] = (x + y) % mod,a[j + k + mid] = (x + mod - y) % mod;
            }
        }
    }
    if (type == 1) return ;
    int Inv = quick_pow (limit,mod - 2);
    for (Int i = 0; i < limit; ++ i) a[i] = 1ll * a[i] * Inv % mod;
}

int c[MAXN];

inline void Solve (int len,int *a,int *b)
{
    if (len == 1) return b[0] = quick_pow (a[0],mod - 2),void ();
    Solve ((len + 1) >> 1,a,b);
    limit = 1,l = 0;
    while (limit < (len << 1)) limit <<= 1,l ++;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for (Int i = 0; i < len; ++ i) c[i] = a[i];
    for (Int i = len; i < limit; ++ i) c[i] = 0;
    NTT (c,1);
    NTT (b,1);
    for (Int i = 0; i < limit; ++ i) b[i] = 1ll * b[i] * (2 + mod - 1ll * c[i] * b[i] % mod) % mod;
    NTT (b,-1);
    for (Int i = len; i < limit; ++ i) b[i] = 0;
}

inline void deravitive (int *a,int n)
{
    for (Int i = 1; i <= n; ++ i) a[i - 1] = 1ll * a[i] * i % mod;
    a[n] = 0;
}

inline void inter (int *a,int n)
{
    for (Int i = n; i >= 1; -- i) a[i] = 1ll * a[i - 1] * quick_pow (i,mod - 2) % mod;
    a[0] = 0;
}

int b[MAXN];

inline void Ln (int *a,int n)
{
    memset (b,0,sizeof (b));
    Solve (n,a,b);
    deravitive (a,n);
    while (limit <= n) limit <<= 1,l ++;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    NTT (a,1),NTT (b,1);
    for (Int i = 0; i < limit; ++ i) a[i] = 1ll * a[i] * b[i] % mod;
    NTT (a,-1),inter (a,n);
    for (Int i = n + 1; i < limit; ++ i) a[i] = 0;
}

int F0[MAXN];

inline void Exp (int *a,int *B,int n)
{
    if (n == 1) return B[0] = 1,void ();
    Exp (a,B,(n + 1) >> 1);
    for (Int i = 0; i < limit; ++ i) F0[i] = B[i];
    Ln (F0,n);
    F0[0] = (a[0] + 1 + mod - F0[0]) % mod;
    for (Int i = 1; i < n; ++ i) F0[i] = (a[i] + mod - F0[i]) % mod;
    NTT (F0,1);
    NTT (B,1);
    for (Int i = 0; i < limit; ++ i) B[i] = 1ll * F0[i] * B[i] % mod;
    NTT (B,-1);
    for (Int i = n; i < limit; ++ i) B[i] = 0;
}

inline int read ()
{
    int x = 0;
    char c = getchar();
    int f = 1;
    while (c < '0' || c > '9')
    {
        if (c == '-') f = -f;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}

inline void write (int x)
{
    if (x < 0)
    {
        x = -x;
        putchar ('-');
    }
    if (x > 9) write (x / 10);
    putchar (x % 10 + '0');
}

int fac[MAXN],caf[MAXN],lim = 140000;

inline void init ()
{
    fac[0] = 1;
    for (Int i = 1; i <= lim; ++ i) fac[i] = 1ll * fac[i - 1] * i % mod;
    caf[lim] = quick_pow (fac[lim],mod - 2);
    for (Int i = lim; i; -- i) caf[i - 1] = 1ll * caf[i] * i % mod;
}

int H[MAXN],H_[MAXN],G[MAXN],FG[MAXN],SG[MAXN];

inline void makerev (int len)
{
    limit = 1,l = 0;
    while (limit < len) limit <<= 1,l ++;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l - 1);
}

inline void prepare ()
{
    int len = 1 << 17;
    makerev (len);
    for (Int i = 0; i < len; ++ i) H[i] = 1ll * quick_pow (2,1ll * i * (i - 1) / 2 % (mod - 1)) * caf[i] % mod;
    Ln (H,len - 1);
    for (Int i = 0; i < len; ++ i) H[i] = H_[i] = 1ll * H[i] * i % mod;
    deravitive (H_,len - 1),makerev (len << 1),NTT (H_,1);
}

inline void work (int n)
{
    int len = 1 << 17;
    memset (SG,0,sizeof (SG)),memset (F0,0,sizeof (F0));
    for (Int i = 0; i < len; ++ i) G[i] = 1ll * H[i] * (mod - n) % mod;
    Exp (G,SG,len),makerev (len << 1),NTT (SG,1);
    for (Int i = 0; i < len << 1; ++ i) SG[i] = 1ll * SG[i] * H_[i] % mod;
    NTT (SG,-1);
    write (1ll * SG[n - 1] * quick_pow (n,mod - 2) % mod * fac[n - 1] % mod),putchar ('\n');
}

signed main()
{
    init (),prepare ();
    for (Int i = 1; i <= 5; ++ i) work (read ());
    return 0;
}
```


---

## 作者：_Arahc_ (赞：1)

本题解是对神仙 @[zhoukangyang](https://www.luogu.com.cn/user/173660) 的 [blog](https://www.luogu.com.cn/blog/173660/solution-p5828) 的个人补充 qwq。

做本题前强烈建议先写 [P4841](https://www.luogu.com.cn/problem/P4841) 和 [CF156D](https://www.luogu.com.cn/problem/CF156D)。

## 题意

> 求 $n$ 个点的有标号边双连通图的个数，答案对 $998244353$ 取模。
>
> $n\leqslant 10^5$，时间限制 $\text{4s}$。

## 分析

因为直接求边双连通图数量很麻烦，不妨考虑求出连通无向图的总数，再减去有割边的无向连通图个数。

不难发现一个无向连通图有割边，那么它边双缩点之后一定是一颗树。设无向图中有 $m$ 个边双连通分量，大小分别为 $a_1,a_2,\cdots,a_m$。根据 CF156D 这个题的结论，可以用 Prufer 序列（可以参考 [xht 的题解](https://www.luogu.com.cn/blog/xht37/solution-cf156d)）证明，总点数为 $n$ 的 $m$ 个连通块，添加 $m-1$ 条使原图连通的方案数为 $n^{m-2}\prod_{i=1}^m a_i$。

枚举连通块的时候，考虑每个连通块内部是一个边双，也就是求出一个 $a_i$ 个点的有标号无向边双连通图数量，这和这个题本身是一样的，确切地说这是原题的形式相同的子问题。因此再把 $a_i$ 代进来容斥，用 $a_i$ 个节点的无向连通图数量减去无向非边双连通图数量……一直容斥下去，因此原方案数还要带一个 $-1$ 的容斥系数。

还有一个感性的理解（口糊的，不知道对错，大家看一看做个乐子），如果对于一个连通块，单纯地只枚举它是一个连通块，那么大小为 $k$ 的连通块可能本身不是边双，而是 $p$ 条割边连接的连通图，而这种（不合法）情况刚好就是大小为 $k+p$ 的连通块中的合法方案，因此对于所有的 $p$，要减掉 $k+p$ 中合法的方案，而大小为 $k+p$ 的连通块中也可能算出不合法方案……而大小 $1$ 的连通块一定是边双，无需考虑不合法问题。

Anyway，需要带上 $-1$ 的容斥系数，即 $(-1)^{m+1} n^{m-2}\prod_{i=1}^m a_i$。把这个东西拆一下得到：
$$
-\frac{1}{n^2}\prod_{i=1}^m (-na_i)
$$
由 P4841，有标号连通图的 EGF 是可以求得的，根据 [OI-Wiki](https://oi-wiki.org/math/gen-func/egf/#_4) 的证明可以得到它为有标号无向图的 EGF 求个 $\ln$。设有标号连通图的 EGF 为 $\operatorname{F}(x)$。代入式子：
$$
\text{let } \operatorname{G}_i=-ni\operatorname{F}_i
$$
为什么要多乘上一个 $i$？个人第一想法是方便直接 $\exp$。由：
$$
\exp(\operatorname{G}(x)) = \sum \frac{\operatorname{G}^i(x)}{i}
$$
则答案可以表示为：
$$
ans = [x^n] - \frac{n!}{n^2}\exp(\operatorname{G(x)})
$$
EGF 忘乘阶乘见祖宗……

## 代码

主函数代码：

```cpp
    fac[0]=1;
    for(register int i=1;i<=N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N]=mi(fac[N]);
    for(register int i=N-1;i>=0;--i)
        inv[i]=inv[i+1]*(i+1)%mod;
    for(register int T=5,tmp;T>0;--T){
        n=read(),tmp=1;
        while(tmp<=n) tmp<<=1;
        for(register int i=0;i<=n;++i)
            f[i]=mi(2,i*(i-1)/2)*inv[i]%mod;
        DXS::init(tmp),
        DXS::Ln(f,g,tmp);
        for(register int i=0;i<=n;++i)
            f[i]=(mod-g[i]*i%mod*n%mod)%mod;
        memset(g,0,sizeof(g));
        DXS::Exp(f,g,tmp);
        write((mod-g[n])*mi(n*n%mod)%mod*fac[n]%mod),putchar('\n');
    }
```


---


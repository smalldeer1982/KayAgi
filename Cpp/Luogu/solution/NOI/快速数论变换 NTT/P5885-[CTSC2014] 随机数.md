# [CTSC2014] 随机数

## 题目描述

露露、花花和萱萱最近对计算机中的随机数产生了兴趣。为大家所熟知的是，有计算机生成的随机数序列并非真正的随机数，而是由一定法则生成的伪随机数。 

某一天，露露了解了一种生成随机数的方法，称为 Mersenne twister。给定初始参数 $m \in Z+$，$ x \le Z+\cap[0,2m)$ 和初值 $M_0 \in Z+\cap [0,2m)$，它通过下列递推式构造伪随机数列$\{M_n\}$: 

 $$M_n=\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\(2M_{n-1}-2^m) \ XOR \ x & 2M_{n-1}\geq 2^m\end{cases}$$
 

 其中 $XOR$ 是二进制异或运算（C/C++ 中的 $^$ 运算）。而参数 $x$ 的选取若使得该数列在长度趋于无穷时，近似等概率地在 $Z+ \cap (0,2m)$ 中取值，就称 $x$ 为好的。例如，在 $m>1$时 $x=0$ 就显然不是好的。 
 
在露露向伙伴们介绍了 Mersenne twister 之后，花花想用这一些经典的随机性测试来检验它的随机性强度。为此，花花使用计算机计算
了一些 $M_k$。 

但细心的萱萱注意到，花花在某次使用二进制输入 $k$ 时，在末尾多输入了 $l$ 个 $0$。她正想告诉花花这个疏忽，然而花花已经计算并记录了
错误的 $M_k$ 而没有记录 $k$ 的值。虽然这其实不是什么致命的问题，但是在萱萱告诉花花她这个疏漏时，作为完美主义者的花花还是恳求萱萱帮她修正 $M_k$ 的值。萱萱便把这个任务交给了她的 AI ——你。 

## 说明/提示

对于 $type=0$ 的部分，要么 $m,k \le 10^6$ 要么 $m\le 2000,k\le 10^{18}$；

对于 $type=1$ 的部分，$m \le 10^3$，$k \le 10^{18}$，$l \le 10$，$x$ 是“好的”。

## 样例 #1

### 输入

```
10
1 1 1 0 0 1 1 1 0 0
1 1 1 0 0 0 0 0 1 1
0
100
```

### 输出

```
0101111001
```

# 题解

## 作者：Scarlet_Hypoc (赞：12)

### 题解（废话）
~~这部分作者神志不清的自说自话大家跳过也无妨的qwq……~~

这题做的人少的吓人，我也是听了f321dd巨佬讲课才来尝试做一做，个人觉得还是很有趣的题qwq。

话说这题网上题解似乎只有不超过 $3$ 篇啊……像我这种菜鸡水平的人没什么题解看就很难受，所以千辛万苦过了这题来记录一下。

话说做这题的时候还有一个有趣的事儿，就是中途用瞪眼法已经再也瞪不出bug的时候，我去偷了一手Picks爷的代码对拍，结果拍出来四五个，手算之后发现错的全是Picks爷的代码qaq，定睛一看发现他在多项式快速幂的时候没有取模，如果 $k$ 比 $n$ 大一些他就裂开了……

顺便给大家送一组第二问的样例吧（应该是满足题目要求的……）：
```
input :
5
1 0 1 0 0
1 0 0 0 0
1
2
1 0 1 0 1
output :
00011
```

### 真·题解
**第一问**

这个递推式是让 $M_0$ 反复乘 $2$，大于等于 $2^m$ 的时候就减去 $2^m$ 并异或一个 $x$。众所周知异或可以看成二进制下不进位的加 / 减法，那么大于等于 $2^m$ 时的操作完全可以看成二进制下不进位的取模啊！

记题目中给出的数 $x$ 为多项式 $p(x)$，令 $G(x)=p(x)+x^m$，那么在模 $G(x)$ 意义下求一个 $M_0\times x^k$ 就是答案，注意为每一位的运算是模 $2$ 意义下的不进位加减法，多项式运算本身是不进位的，所以注意模 $2$ 就好。

时间复杂度 $O(m\log m\log k)$。

**第二问**

第二问就比较奇怪，给出 $M_{k\cdot 2^l}$，求 $M_k$。

注意到题目给了个也很奇怪的性质：$x$ 是好的——在序列长度趋于无穷的时候，近似等概率地在 $\mathbb Z^+\cap (0,2^m)$ 中取值。

**简单概括**

$M_0$ ~ $M_{\infty}$ 形成了一个大小为 $2^m-1$ 的多项式乘法群 $F$（并且这个多项式乘法是在模 $G(x)$ 意义下的）。

$\forall f(x)\in F$，显然 $f(x)^0$ 是 $F$ 的单位元，剩下 $2^m-2$ 个元素一定可以表示为 $f(x)^i$，那么 $f(x)^{2^m-1}=f(x)^0$，于是有 $f(x)^{2^m}=f(x)$。

---
**人话翻译** （可能略烦，略长……具有一定前置知识并且看懂了简单概括的就可以跳过了……）

定义初值为 $A_0\in (0,2^m)$，递推式为 $A_i=A_{i-1}\times B \pmod {G(x)} (B\in (0,2^m))$ 的序列为 $(A_0,B)$ 的生成序列。

显然 $M$ 序列存在循环节，上述性质相当于告诉我们循环节大小为 $2^m-1$，令 $F$ 为一个循环节内所有元素的集合。显然存在一个元素在原来的数值上为 $2$，在多项式表示下就是 $x^1$，那么 $M$ 相当于是 $(M_0,x^1)$ 的生成序列。

实际上不难发现任意生成序列的循环节都是 $2^m-1$，考虑 $F$ 内任意一个元素 $f(x)$，对于生成序列 $(1,f(x))$，其第 $2^m$ 项为 $f(x)$，即 $1\times f(x)^{2^m}=f(x)$，我们得到了和上面一样的结论。

---
有了这个结论，剩下的事情就很简单了。我们现在拥有 $M_{k\cdot2^l}=M_0\times x^{k\cdot 2^l}$，我们需要求 $M_k$，显然有：
$$
M_k=M_0\times x^k\times x^{2^m}=M_0\times (x^{k\cdot2^l})^{2^{m-l}}=M_0\times \left(\frac {M_{k\cdot 2^l}} {M_0}\right)^{2^{m-l}}
$$

好啦，这就做完啦！诶，慢着……我要怎么求模 $G(x)$ 意义下 $M_0$ 的逆啊？！

啊事实上这个东西也是可以做的，你需要往扩展欧几里得算法上套多项式板子，具体参见Picks巨佬的代码……但是不要怕！上面的性质不仅可以放到 $x$ 上用，我们也可以放到 $M_0$ 上再用一次！
$$
M_0\times \left(\frac {M_{k\cdot 2^l}} {M_0}\right)^{2^{m-l}}=M_0^{2^m}\times(M_{k\cdot 2^l}M_0^{-1})^{2^{m-l}}=M_{k\cdot 2^l}^{2^{m-l}}\times (M_0^{2^{m-l}})^{2^l-1}
$$

这样有了另一种又好看又好写的做法！时间复杂度是 $O(m^2\log m)$，因为每次快速幂是 $\log {2^m}=m$ 的复杂度。

---
啊哈！你以为这就完了？让我们看回第一问。

事实上，你信心满满的冲完第一问的代码后，交上去一看，恭喜你只有 $30$ 分，除去第二问的 $40$ 分，剩下你还会因为TLE丢掉 $30$ 分。

好，T就T，卡常就是了，然后你千辛万苦卡一通常后也许会少几个TLE，但是大概率那几个TLE会变成WA（笑

下面有两个奇技淫巧，大概能帮你解决这些乱七八糟的问题。

**为什么第一问会WA？**

这个的原因大概率是因为你没有处理好`系数要对2取模`这件事，每次将两个多项式卷积完后系数模 $2$ 了吗？多项式除法的时候商和余数的系数模 $2$ 了吗？这是需要检查的。

检查后会发现一个有趣的事情：如果你在多项式乘法的时候，系数都是正数，那么乘完之后直接系数模 $2$ 即可。但是如果出现了负数呢？负数在ntt模数下会变成正数，与此同时其奇偶性会发生改变，直接模 $2$ 会得到相反的结果。然而，我也没有很好的`判断一个系数是整数还是负数`的办法。

注意到，会出现负数的地方之后多项式求逆的部分，众所周知多项式求逆依赖于这个公式：$G=G_0(2-FG_0)$，然而，由于需要对系数模 $2$，我们却恰好可以利用这一点来规避遇到负数的问题：式子可以写成 $G=2G_0-FG_0^2$，模 $2$ 后 $2G_0$ 直接消掉，然后取负不影响奇偶性，即取负后模 $2$ 和直接模 $2$ 的结果相同，于是式子可以变成 $G=FG_0^2$，负数不见了！

**为什么第一问会TLE？**

~~这不是出题人的问题？复杂度mlog2m出1e6的范围，这还是多项式运算的log，这出题人脑子是不是有问题啊（~~

第一问其实有一个大优化，做快速幂的时候，如果多项式次数小于 $n$，那么就不需要取模，因为取了也不发生变化。那么复杂度变成 $O(m\log m(\log k-\log m))$，由于这里 $m,k$ 同阶，所以这是个大优化。加上之后应该是能无压力通过的（我最慢的点 $3.5$s）。

---
那么这样才算是真的做完啦，代码如下：
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
#define maxn 3000010
#define mod 998244353
#define bin(x) (1<<(x))
#define MS(f,x) memset(f,0,4<<(x))
#define CP(f,g,x) memcpy(f,g,(x)<<2)

#define cn getchar
template<class TY>void read(TY &x){
	x=0;int f1=1;char ch=cn();
	while(ch<'0'||ch>'9'){if(ch=='-')f1=-1;ch=cn();}
	while(ch>='0'&&ch<='9')x=x*10+(ch-'0'),ch=cn(); x*=f1;
}
int n,F[maxn],G[maxn];
int ksm(int x,int y){int re=1;for(;(y&1?re=1ll*re*x%mod:0),y;y>>=1,x=1ll*x*x%mod);return re;}
int w[maxn],inv[maxn];void prep(int lg){int N=bin(lg);
	inv[1]=1;for(int i=2;i<=N;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1,wn;i<N;i<<=1){
		w[i]=1;wn=ksm(3,(mod-1)/(i<<1));
		for(int j=1;j<i;j++)w[i+j]=1ll*w[i+j-1]*wn%mod;
	}
}
void reduce(int &x){x+=x>>31&mod;}
void ntt(int *f,int lg,int type=0){
	int limit=bin(lg);if(type)reverse(f+1,f+limit);
	for(int i=0,j=0,k;i<limit;i++){if(i<j)swap(f[i],f[j]);k=limit>>1;while((j^=k)<k)k>>=1;}
	for(int mid=1,t;mid<limit;mid<<=1)for(int j=0;j<limit;j+=(mid<<1))for(int i=0;i<mid;i++)
	{t=1ll*f[j|i|mid]*w[mid|i]%mod;reduce(f[j|i|mid]=f[j|i]-t);reduce(f[j|i]+=t-mod);}
	if(type)for(int i=0;i<limit;i++)f[i]=1ll*f[i]*inv[limit]%mod;
}
int A[maxn],B[maxn],C[maxn],D[maxn],E[maxn],Q[maxn],R[maxn];
void NTT(int *f,int *g,int ln,int Mul=2){
	int lg=ceil(log2(ln*Mul));ntt(f,lg);ntt(g,lg);
	for(int i=0;i<bin(lg);i++)f[i]=1ll*f[i]*g[i]%mod;ntt(f,lg,1);
	for(int i=0;i<bin(lg);i++)f[i]&=1;
}
void getsqr(int *f,int ln){
	int lg=ceil(log2(2*ln-1));
	ntt(f,lg);for(int i=0;i<bin(lg);i++)f[i]=1ll*f[i]*f[i]%mod;
	ntt(f,lg,1);for(int i=0;i<bin(lg);i++)f[i]&=1;
}
void getinv(int *f,int *g,int ln){
	if(ln==1){g[0]=ksm(f[0],mod-2);return;}getinv(f,g,ln+1>>1);
	int lg=ceil(log2(ln<<1));MS(A,lg);MS(B,lg);CP(A,f,ln);CP(B,g,ln);
	getsqr(B,ln+1>>1);NTT(B,A,ln);CP(g,B,ln);
}
void getrev(int *f,int *g,int ln){for(int i=0;i<=ln;i++)g[i]=f[ln-i];}
void getdiv(int *f,int *g,int *q,int ln1,int ln2){
	int lg=ceil(log2(ln1+1));MS(C,lg);MS(D,lg);MS(E,lg);
	getrev(f,C,ln1);getrev(g,D,ln2);for(int i=ln1-ln2+1;i<=ln1;i++)C[i]=D[i]=0;
	getinv(D,E,ln1-ln2+1);for(int i=0;i<=ln1-ln2;i++)E[i]&=1;
	NTT(C,E,ln1-ln2+1);getrev(C,q,ln1-ln2);
}
void getmod(int *f,int *g,int *q,int *r,int ln1,int ln2){
	int lg=ceil(log2(ln1+1));MS(C,lg);MS(D,lg);CP(C,g,ln2+1);CP(D,q,ln1-ln2+1);
	NTT(C,D,ln1+1,1);for(int i=0;i<ln2;i++)r[i]=f[i]^C[i];
}
void Modto(int *f,int *g,int ln1,int ln2){
	for(int i=0;i<=ln1;i++)f[i]&=1;
	getdiv(f,g,Q,ln1,ln2);getmod(f,g,Q,R,ln1,ln2);
	for(int i=0;i<=ln1;i++)f[i]=(i<ln2?R[i]:0);
}
int Base[maxn],A1[maxn];
void solve1(){
	int ts;read(ts);
	int lg=ceil(log2(n<<1));Base[1]=A1[0]=1;
	int c1=0,c2=1;
	for(;ts;ts>>=1){
		if(ts&1){
			if((c1+=c2)<n)A1[c1-c2]=0,A1[c1]=1;
			else NTT(A1,Base,n),ntt(Base,lg,1),Modto(A1,G,2*n-1,n);
		}
		if((c2<<=1)<n)Base[c2>>1]=0,Base[c2]=1;
		else getsqr(Base,n),Modto(Base,G,2*n-1,n);
	}
	NTT(F,A1,n);Modto(F,G,2*n-1,n);
	for(int i=0;i<n;i++)putchar(F[i]?'1':'0');
}
int Mk[maxn];
void ksm1(int *f,int ts){
	for(int i=1;i<=ts;i++)
		getsqr(f,n),Modto(f,G,2*n-1,n);
}
void ksm2(int *f,int ts){
	int lg=ceil(log2(n<<1));
	CP(A1,f,n);ntt(f,lg);
	for(int i=1;i<ts;i++){
		for(int i=0;i<bin(lg);i++)f[i]=1ll*f[i]*f[i]%mod;
		ntt(f,lg,1);Modto(f,G,2*n-1,n);
		ntt(f,lg);ntt(A1,lg);for(int i=0;i<bin(lg);i++)A1[i]=1ll*A1[i]*f[i]%mod;
		ntt(A1,lg,1);Modto(A1,G,2*n-1,n);
	}
	for(int i=0;i<bin(lg);i++)f[i]=(i<n?A1[i]:0);
}
void solve2(){
	int l;read(l);
	for(int i=0;i<n;i++)read(Mk[i]);
	ksm1(Mk,n-l);ksm1(F,n-l);ksm2(F,l);
	NTT(F,Mk,n);Modto(F,G,2*n-1,n);
	for(int i=0;i<n;i++)putchar(F[i]?'1':'0');
}

int main()
{
	read(n);prep(ceil(log2(n+1<<1)));
	for(int i=0;i<n;i++)read(G[i]);G[n]=1;
	for(int i=0;i<n;i++)read(F[i]);
	int type;read(type);
	if(type==0)solve1();
	else solve2();
	return 0;
}
```

---

## 作者：_lbw_ (赞：0)

这题好像有挺多种复杂度都能过。

首先题面可以把 $M$ 用 GF 的形式表示为 $\sum\limits_{i=0}^{m-1}f_iz^i$，$f_i$ 为 $M$ 第 $i$ 位的值。

于是有 $M_n=zM_{n-1} \bmod (z^m-x)$。

### 第一问

分为两种情况。

- $m\leq 2\times 10^3$，直接快速幂，卷积和取模都用暴力，如果用 bitset 优化时间复杂度 $\mathcal{O}(\dfrac{m^2\log k}\omega)$。

- $k\leq 10^6$，实际上只需要取模一次，使用多项式取模的方法 NTT 卷积，时间复杂度 $\mathcal{O}(m\log m)$。

### 第二问

这个我的做法就比较抽象了。。。

可以看出，输入是 $z^{k2^l}M_0$ 和 $M_0$，要求的是 $z^{k}M_0$，那么好像只需要把 $z^k$ 解出来就可以了。

于是我们只需要求逆和开根，这里我为了做法多样性，使用的是解方程！！！

求逆直接设变量解就行了，开根呢？

容易发现 $F^2(z)=F(z^2)$，这样方程就只有异或而没有与了。

bitset 优化之，时间复杂度 $\mathcal{O}(\dfrac{m^3l}\omega)$。

这个复杂度看上去有些大，但是比第一部分的多项式取模快多了。


```cpp
#include<map>
#include<set>
#include<ctime>
#include<cmath>
#include<queue>
#include<bitset>
#include<cstdio>
#include<vector>
#include<random>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
#define I ll
#define her1 20081214
#define IV void
#define cht 998244353
#define ld long double
#define Aestas16 392699
#define ull unsigned long long
#define cp(x,y)memcpy(x,y,sizeof y)
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=G[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register i64 i=j;i>=n;i--)
#define EL(i,now)for(register i64 i=first[now];i;i=G[i].nxt)
#define FL(i,j,n)for(register i64 i=j;i<=n;i++)
//#define D(i,j,n)for(int i=j;i>=n;i--)
//#define E(i,now)for(int i=first[now];i;i=G[i].nxt)
//#define F(i,j,n)for(int i=j;i<=n;i++)
//#define DL(i,j,n)for(register ll i=j;i>=n;i--)
//#define EL(i,now)for(register ll i=first[now];i;i=G[i].nxt)
//#define FL(i,j,n)for(register ll i=j;i<=n;i++)
ll read(){
	ll ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans*f;
}
#undef ll
#include "assert.h"
mt19937_64 rnd(her1);
#include "functional"
using i64 = long long;
const int maxn = 1e6+5;
const int maxm = (1<<21)+5;
i64 n,v0[maxn*2],M[maxn];
namespace Subtask1{
	i64 k,tmp[maxn],c[maxn];
	IV solve(){
		if(n>1)tmp[1]=1;
		else tmp[0]=M[0];
		auto Mul=[&](i64*a,i64*b,i64*ans){
			F(i,0,2*n-2)c[i]=0;
			F(i,0,n-1)F(j,0,n-1)
				c[i+j]^=(a[i]&b[j]);
			D(i,2*n-2,n)if(c[i]){
				c[i]=0;
				F(j,0,n-1)c[i-j-1]^=M[n-j-1];
			}
			F(i,0,n-1)ans[i]=c[i];
		};
		k=read();
		while(k){
			if(k&1)Mul(v0,tmp,v0);
			Mul(tmp,tmp,tmp);k>>=1;
		}
		F(i,0,n-1)putchar(v0[i]+'0');puts("");
	}
} // namespace Subtask1
namespace Subtask2{
	#define in(i,V) F(i,0,(i64)V.size()-1)
	#define My_assert(expr,tips) ((expr)?(void(0)):(puts(tips),exit(0)))
	IV cadd(i64&x,i64 val){x=(x+val)%cht;}

	i64 k,w[maxm];
	i64 qpow(i64 n,i64 base=cht-2){
		i64 ans=1;
		while(base){
			if(base&1)ans=ans*n%cht;
			n=n*n%cht;base>>=1;
		}
		return ans;
	}
	IV init(i64 limit){
		for(int i=1,j,k;i<limit;i<<=1)
			for(w[j=i]=1,k=qpow(3,(cht-1)/(i<<1)),j++;j<(i<<1);j++)
				w[j]=w[j-1]*k%cht;
	}
	IV DIT(i64*a,i64 limit){
		for(i64 i,j,k=limit>>1,L,*W,*x,*y,z;k;k>>=1)
			for(L=k<<1,i=0;i<limit;i+=L)for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				*y=(*x+cht-(z=*y))* *W%cht,*x=(*x+z)%cht;
	}
	IV DIF(i64*a,i64 limit){
		for(i64 i,j,k=1,L,*W,*x,*y,z;k<limit;k<<=1)
			for(L=k<<1,i=0;i<limit;i+=L)for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				z=1ll* *W* *y%cht,*y=(*x-z)%cht,*x=(*x+z)%cht;
		reverse(a+1,a+limit);
		i64 inv=qpow(limit);
		F(i,0,limit-1)a[i]=a[i]*inv%cht;
	}
	#define poly vector<i64>

	poly operator*(const poly&A,const poly&B){
		static i64 f[maxm],g[maxm];
		My_assert(A.size()&&B.size(),"multiply with a empty poly.");
		i64 limit=1;
		while(limit<=A.size()+B.size())
			limit<<=1;
		F(i,0,limit-1)f[i]=g[i]=0;
		in(i,A)f[i]=A[i];in(i,B)g[i]=B[i];
		DIT(f,limit);DIT(g,limit);
		F(i,0,limit-1)f[i]=f[i]*g[i]%cht;DIF(f,limit);
		poly C;C.resize(A.size()+B.size()-1);
		in(i,C)C[i]=(((f[i]+cht)%cht)&1);
		return C;
	}
	poly operator+(const poly&A,const poly&B){
		poly C;C.resize(max(A.size(),B.size()));
		in(i,C)C[i]=0;
		in(i,A)C[i]^=A[i];
		in(i,B)C[i]^=B[i];
		return C;
	}
	
	IV print(poly A){for(auto x:A)putchar(x+'0');puts("");}
	IV remod(poly&A,i64 n){while(A.size()>n)A.pop_back();}
	poly getinv(poly A,i64 n){
		if(n==1)return{1};remod(A,n);
		poly g=getinv(A,(n-1)/2+1);
		// print(g);
		// print(g*g);
		g=g*g*A;remod(g,n);return g;
	}
	IV solve(){
		init(1<<21);M[n]=1;reverse(M,M+n+1);k=read();
		D(i,n+k-1,k)v0[i]=v0[i-k];D(i,k-1,0)v0[i]=0;reverse(v0,v0+n+k);
		poly inv(M,M+n+1),T(v0,v0+k),X(v0,v0+n+k);
		// print(X);
		// print(inv);
		poly nw=getinv(inv,k);
		poly Ans=nw*T;remod(Ans,k);
		poly orz=Ans*inv+X;
		// F(i,0,n+k-1)cout<<orz[i]<<' ';puts("");
		// F(i,0,n+k-1)putchar(orz[i]+'0');puts("");
		D(i,n+k-1,k)putchar(orz[i]+'0');
	}
} // namespace Subtask2
namespace Subtask3{
	const int maxc = 1e3+5;
	bitset<maxc>bit,vk,g[maxc*2],zk;i64 l,ans[2*maxc];
	IV solve(){
		l=read();F(i,0,n-1)if(read())vk[i]=1;
		F(i,0,n-1)F(j,0,n-1)if(v0[j])g[i+j][i]=1;
		D(i,2*n-2,n)F(j,1,n)if(M[n-j])g[i-j]^=g[i];
		F(i,0,n-1)g[i][n]=vk[i];
		i64 o=0;
		// F(i,0,n-1){
		// 	F(j,0,n)cout<<g[i][j];
		// 	puts("");
		// }
		F(i,0,n-1){
			F(j,o,n-1)if(g[j][i]){swap(g[o],g[j]);break;}
			if(!g[o][i])continue;F(j,0,n-1)if(j!=o&&g[j][i])g[j]^=g[o];
			o++;
		}
		F(i,0,o-1)F(j,0,n-1)
			if(g[i][j])zk[j]=g[i][n];
		// F(i,0,n-1){
		// 	F(j,0,n)cout<<g[i][j];
		// 	puts("");
		// }
		while(l--){
			F(i,0,2*n-2)g[i].reset();
			F(i,0,2*n-2)if(i%2==0)g[i][i/2]=1;
			D(i,2*n-2,n)F(j,1,n)if(M[n-j])g[i-j]^=g[i];
			F(i,0,n-1)g[i][n]=zk[i];
			F(i,0,n-1){
				F(j,i,n-1)if(g[j][i]){swap(g[i],g[j]);break;}
				F(j,0,n-1)if(j!=i&&g[j][i])g[j]^=g[i];
			}
			F(i,0,n-1)zk[i]=g[i][n];
		}
		F(i,0,n-1)F(j,0,n-1)ans[i+j]^=zk[i]&v0[j];
		D(i,2*n-2,n)F(j,1,n)if(M[n-j])ans[i-j]^=ans[i];
		F(i,0,n-1)putchar(ans[i]+'0');
	}
} // namespace Subtask3

int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();
	F(i,0,n-1)M[i]=read();
	F(i,0,n-1)v0[i]=read();
	bool type=read();
	if(!type){
		if(n<=2e3)Subtask1::solve();
		else Subtask2::solve();
	}
	else Subtask3::solve();
	return 0;
}
```

---


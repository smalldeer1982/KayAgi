# 【烂题杯 Round 1】可持久化糖果树

## 题目描述

小 A 有一棵糖果树，树上有 $n$ 个节点，编号为 $1,2,\cdots,n$。每个节点里有 $m$ 位小朋友，编号为 $1,2,\cdots,m$。每个小朋友可以进行 $k$ 次祈愿，编号为 $1,2,\cdots,k$。节点 $i$ 中的第 $j$ 位小朋友的第 $x$ 次祈愿可以获得 $a_{i,j,x}$ 个糖果。我们称未被修改的糖果树为第 $0$ 个版本树。

一个小朋友被称为开心的，当且仅当她经过 $k$ 轮祈愿后可以获得的糖果数量可以被 $3$ 整除，这样就可以把糖果平均地分给她和她的父母。也就是说，第 $i$ 个节点的第 $j$ 个小朋友是开心的当且仅当 $\sum_{x=1}^k a_{i,j,x}\bmod 3=0$。

一个节点被称为是快乐的，当且仅当上面的 $m$ 位小朋友都是开心的。

小 A 可以施加魔法：他将会有 $q$ 次修改，下标从 $1$ 开始的第 $i$ 次修改可以描述为 $(x,y,z)$，表示将第 $x$ 个版本树上所有节点中的所有小朋友的第 $y$ 次祈愿获得的糖果数量乘上 $z$，得到第 $i$ 个版本树。要求你求出每个版本树中有多少个点是快乐的。

## 说明/提示

**数据范围：**

对于 $0\%$ 的数据，满足 $n\le 10^3$，$q\le 10^3$。

对于 $0\%$ 的数据，满足 $n\le 10^3$，$q\le 10^6$。

对于另外 $0\%$ 的数据，满足 $m=1$。

对于另外 $0\%$ 的数据，满足 $k=1$。

对于另外 $0\%$ 的数据，满足 $q=0$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 4$，$1\le k\le 12$，$0\le q\le 10^6$，$0\le a_{i,j,x}\le 10^9$。对于第 $i$ 次修改，$0\le x<i$，$1\le y\le k$，$0\le z\le 10^9$。

输入输出量较大，需要快速输入输出算法。

## 样例 #1

### 输入

```
2 2 3
1 2 3 4 5 6
7 8 9 10 11 12
5
0 1 13
0 2 14
1 2 15
1 3 16
2 3 17```

### 输出

```
2
2
0
0
2
0```

## 样例 #2

### 输入

```
10 1 2
568508003 500481779
296073373 42467215
878878423 182698953
810051825 300278778
506619835 300576052
878109763 816209514
722729481 557555287
810227870 524124026
693592304 92818139
971977946 139368888
3
0 1 524124026
0 1 500481779
0 2 816209514```

### 输出

```
1
6
6
2```

# 题解

## 作者：chenxinyang2006 (赞：12)

重述一下题意：给出 $n$ 个 $k$ 维向量 $m$ 元组，$q$ 次询问，每次询问也给出一个 $k$ 维向量 $v$，求多少个 $m$ 元组满足其中任何一个向量与 $v$ 点积为 $0$，所有向量间的运算都在模 $3$ 意义下进行。

  假设一个 $m$ 元组分别含有向量 $a_1 \sim a_m$，可以发现 $\forall 1 \le i \le m,a_i \cdot v=0$ 当且仅当 $\sum\limits_{b_1...b_m} \omega_3^{\sum\limits_{i=1}^m (a_i \cdot v)b_i}=3^m$，其中 $b_1 \sim b_m$ 是枚举所有不同系数在 $[0,2]$ 间的 $m$ 维向量，而如果存在 $a_i \cdot x \neq 0$，这个式子的值一定为 $0$。

  注意 $b_i$ 是 $b$ 这个 $m$ 维向量第 $i$ 维的值，而 $a_i$ 是一个 $k$ 维向量。

  证明：这个式子的值等于 $\prod\limits_{i=1}^m (1+\omega_{3}^{a_i \cdot v}+\omega_{3}^{2a_i \cdot v})$，而 $a_i \cdot v=0$ 时贡献是 $3$ 否则为 $0$。其实这类似在做高维单位根反演。

  而 $\sum\limits_{i=1}^m (a_i \cdot v)b_i = (\sum\limits_{i=1}^m a_ib_i) \cdot v$，当 $b_1 \sim b_m$ 确定时算出 $\sum\limits_{i=1}^m a_ib_i$ 这个 $k$ 维向量，那我们相当于把这一个 $m$ 元组的贡献拆成了 $3^m$ 个 $k$ 维向量，询问时求所有这些向量的 $\omega_3$ 的 $\text{拆出的向量} \cdot v$ 次方之和（最后答案除以 $3^m$）。

  $O(n3^mk)$ 拆出所有向量，对 $3^k$ 种向量每种记录拆出来了多少个，设向量 $c_1 \sim c_m$ 有 $cnt_{\overline {c_1c_2...c_m}}$ 种。注意到可能的询问也只有 $3^k$ 种，相当于要对所有 $\overline {v_1v_2...v_m}$ 计算 $\sum\limits_{c_1 \sim c_m} \omega_3^{v \cdot c} cnt_{\overline {c_1c_2...c_m}}$。

  这是高维 DFT 的形式，因为每维长度是 $3$ 直接暴力做就行，时间复杂度 $O(3^k k)$。

  $10^9+9$ 有 $3$ 次单位根，而且答案也不超过 $n$，直接在模 $10^9+9$ 意义下运算就行。

  最后时间复杂度 $O(n3^mk+3^kk + qk)$。

  注意下面代码写的是 $O(n3^mmk+3^kk+qk)$ 的。

```cpp
#include <bits/stdc++.h>
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define uint unsigned int
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pii pair<int,int>
#define pll pair<ll,ll>
#define mkp make_pair
#define eb emplace_back
#define SZ(S) (int)S.size()
//#define mod 998244353
#define mod 1000000009
#define inf 0x3f3f3f3f
#define linf 0x3f3f3f3f3f3f3f3f
using namespace std;

template <class T>
void chkmax(T &x,T y){
    if(x < y) x = y;
}

template <class T>
void chkmin(T &x,T y){
    if(x > y) x = y;
}

inline int popcnt(int x){
    return __builtin_popcount(x);
}

inline int ctz(int x){
    return __builtin_ctz(x);
}

template <int P>
class mod_int
{
    using Z = mod_int;

private:
    static int mo(int x) { return x < 0 ? x + P : x; }

public:
    int x;
    int val() const { return x; }
    mod_int() : x(0) {}
    template <class T>
    mod_int(const T &x_) : x(x_ >= 0 && x_ < P ? static_cast<int>(x_) : mo(static_cast<int>(x_ % P))) {}
    bool operator==(const Z &rhs) const { return x == rhs.x; }
    bool operator!=(const Z &rhs) const { return x != rhs.x; }
    Z operator-() const { return Z(x ? P - x : 0); }
    Z pow(long long k) const
    {
        Z res = 1, t = *this;
        while (k)
        {
            if (k & 1)
                res *= t;
            if (k >>= 1)
                t *= t;
        }
        return res;
    }
    Z &operator++()
    {
        x < P - 1 ? ++x : x = 0;
        return *this;
    }
    Z &operator--()
    {
        x ? --x : x = P - 1;
        return *this;
    }
    Z operator++(int)
    {
        Z ret = x;
        x < P - 1 ? ++x : x = 0;
        return ret;
    }
    Z operator--(int)
    {
        Z ret = x;
        x ? --x : x = P - 1;
        return ret;
    }
    Z inv() const { return pow(P - 2); }
    Z &operator+=(const Z &rhs)
    {
        (x += rhs.x) >= P && (x -= P);
        return *this;
    }
    Z &operator-=(const Z &rhs)
    {
        (x -= rhs.x) < 0 && (x += P);
        return *this;
    }
    Z operator-()
    {
        return -x;
    }
    Z &operator*=(const Z &rhs)
    {
        x = 1ULL * x * rhs.x % P;
        return *this;
    }
    Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }
#define setO(T, o)                                  \
    friend T operator o(const Z &lhs, const Z &rhs) \
    {                                               \
        Z res = lhs;                                \
        return res o## = rhs;                       \
    }
    setO(Z, +) setO(Z, -) setO(Z, *) setO(Z, /)
#undef setO
    
    friend istream& operator>>(istream& is, mod_int& x)
    {
        long long tmp;
        is >> tmp;
        x = tmp;
        return is;
    }
    friend ostream& operator<<(ostream& os, const mod_int& x)
    {
        os << x.val();
        return os;
    }
};

using Z = mod_int<mod>;
Z power(Z p,ll k){
    Z ans = 1;
    while(k){
        if(k % 2 == 1) ans *= p;
        p *= p;
        k /= 2;
    }
    return ans;
}
const Z w = 115381398;
int n,m,q,k,X;
int a[4][12],b[12],P[15];
int resp[81][4];

Z dp[531441],ndp[531441],answer[531441];
void slv(){
    rep(i,0,m - 1){
        rep(j,0,k - 1) a[i][j] %= 3;
    }
/*  rep(i,0,m - 1){
        rep(j,0,k - 1) printf("%d ",a[i][j]);
        printf("\n");
    }
    printf("\n");*/
    rep(S,0,P[m] - 1){
        fill(b,b + k,0);
        rep(i,0,m - 1){
            rep(j,0,k - 1) b[j] += resp[S][i] * a[i][j];
        }
        int msk = 0;
        rep(i,0,k - 1) msk += P[i] * (b[i] % 3);
        dp[msk] += 1;
    }
}

void dft(){
    int S0,S1,S2;
    rep(i,0,k - 1){
        rep(S,0,P[k] - 1){
            if(S / P[i] % 3) continue;
            S0 = S;S1 = S0 + P[i];S2 = S1 + P[i]; 
            ndp[S0] += dp[S0] + dp[S1] + dp[S2];
            ndp[S1] += dp[S0] + dp[S1] * w + dp[S2] * w * w;
            ndp[S2] += dp[S0] + dp[S1] * w * w + dp[S2] * w;
        }
        rep(S,0,P[k] - 1){
            dp[S] = ndp[S];
            ndp[S] = 0;
        }
    }
}

int val[1000005][12];

int main(){ 
//    freopen("test.in","r",stdin);
//    freopen("test.out","w",stdout);
    scanf("%d%d%d%d",&n,&m,&k,&X);
    P[0] = 1;
    rep(i,1,max(m,k)) P[i] = 3 * P[i - 1];
    rep(S,0,P[m] - 1){
        rep(i,0,m - 1) resp[S][i] = S / P[i] % 3;
    }
    rep(i,1,n){
        rep(j,1,m){
            rep(x,1,k) a[j - 1][x - 1] = (X + 1ll * X * i + (X ^ (j * x))) % 1000000000;
        }
        slv();
    }
//    rep(p,0,2) slv(p);
    dft();
    rep(S,0,P[k] - 1) answer[S] = dp[S] / P[m];

    fill(val[0],val[0] + k,1);
    scanf("%d",&q);
    int x,y,z;
    rep(i,1,q){
        x = (X ^ i) % i;
        y = (X ^ i) % k;
        z = (X + (X ^ i)) % 999999999;      
        copy(val[x],val[x] + k,val[i]);
        val[i][y] = 1ll * val[i][y] * z % 3;
    }

    uint output = 0;
    int msk;
    rep(i,0,q){
        msk = 0;
        rep(j,0,k - 1) msk += P[j] * val[i][j];
        output ^= answer[msk].val();
    }
    printf("%u\n",output);
    cerr << clock() << endl;
    return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：11)

很牛的题！拜谢出题人。

个人感觉 $3^m$ 的做法更加自然，因为这是直接单位根反演的结果。

### Solution

考虑单位根反演：

$$[k|n]=\frac 1k\sum_{i=0}^{k-1}\omega_k^{in}$$

我们应用它来刻画 $\sum_{x=1}^ka_{i,j,x}\equiv 0\pmod 3$。一个节点 $i$ 是合法的当且仅当：

$$\frac 1{3^m}\prod_{j=1}^m(1+\omega_3^{\sum a_{i,j,x}}+\omega_3^{2\sum a_{i,j,x}})=1$$

则答案即为

$$\frac 1{3^m}\sum_{i=1}^n\sum_{j=1}^m(1+\omega_3^{\sum a_{i,j,x}}+\omega_3^{2\sum a_{i,j,x}})$$

将式子展开，得到

$$\begin{aligned}
&\frac 1{3^m}\sum_{i=1}^n\sum_b\omega_3^{\sum_{j=1}^mb_j\sum_{x=1}^k a_{i,j,x}}\\
=&\frac 1{3^m}\sum_{i=1}^n\sum_{b}\omega_3^{\sum_{x=1}^k\sum_{j=1}^ma_{i,j,x}b_j}
\end{aligned}$$

其中序列 $b$ 满足 $|b|=m,b_i\in\{0,1,2\}$。

现在我们已经可以做到 $n3^mk$ 或更快的单次询问了，考虑支持修改。设 $a_{i,j,x}\gets a_{i,j,x}\times d_x$，继续推式子：

$$\begin{aligned}
&\frac 1{3^m}\sum_{i=1}^n\sum_{b}\omega_3^{\sum_{x=1}^k \sum_{j=1}^md_xa_{i,j,x}b_j}\\
=&\frac 1{3^m}\sum_{i=1}^n\sum_{b}\omega_3^{\sum_{x=1}^kd_x\sum_{j=1}^ma_{i,j,x}b_j}
\end{aligned}$$

对于确定的 $a_i$ 和 $b$，我们可以得到序列 $c$，满足 $c_x=\sum_{j=1}^ma_{i,j,x}b_j$。记录 $cnt_c$ 表示上述 $c$ 的出现次数，答案即为：

$$\frac 1{3^m}\sum_ccnt_c\prod_{x=1}^k\omega_3^{c_xd_x}$$

$cnt_c$ 可以 $n3^mmk$ 预处理出来。对于每一个 $d$，我们预处理 $f_d=\frac 1{3^m}\sum_ccnt_c\prod_{x=1}^k\omega_3^{c_xd_x}$，这是可以直接对于 $x=1\sim k$ DP 的，可以 $k3^k$ 预处理。

总的复杂度即为 $O(n3^mmk+k3^k+qk)$。

Bonus：其实上述的 $k3^k$ DP 即为 3-FWT。

### Code

朴素的实现需要扩域。但我们可以选一个大于等于 $n$ 的质数 $p$ 满足 $3|(p-1)$，这样在 $\mathbb F_p$ 中就存在 $\omega_3$，算答案时直接对 $p$ 取模即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=1e6+5,M=5,K=13,mod=1145140831,w1=431040359,w2=714100471;
int n,m,k,X,q,a[M][K],b[K],p3[K],num[N],tmp[K];
ll F[N];
inline ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
void dfs(int x){
	if(x==m+1){
		int cur=0,sum;
		for(int i=1;i<=k;i++){
			sum=0;
			for(int j=1;j<=m;j++)
				sum+=b[j]*a[j][i];
			cur+=p3[i-1]*(sum%3);
		}
		++F[cur];
		return;
	}
	for(int i=0;i<3;i++){
		b[x]=i;
		dfs(x+1);
	}
}
void FWT(ll *F,int n){
	for(int i=1;i<n;i*=3)
		for(int j=0;j<n;j+=i*3)
			for(int k=0;k<i;k++){
				ll x=F[j+k],y=F[i+j+k],z=F[(i<<1)+j+k];
				F[j+k]=(x+y+z)%mod;
				F[i+j+k]=(x+w1*y+w2*z)%mod;
				F[(i<<1)+j+k]=(x+w2*y+w1*z)%mod;
			}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k>>X;
	p3[0]=1;
	for(int i=1;i<=k;i++)p3[i]=p3[i-1]*3;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			for(int x=1;x<=k;x++)
				a[j][x]=(X*(i+1ll)+(X^(j*x)))%1000000000%3;
		dfs(1);
	}
	FWT(F,p3[k]);
	ll inv=qpow(3,mod-m-1);
	for(int i=0;i<p3[k];i++)F[i]=F[i]*inv%mod;
	for(int i=1;i<=k;i++)num[0]+=p3[i-1];
	int ans=F[num[0]];
	cin>>q;
	for(int i=1;i<=q;i++){
		int x=(X^i)%i,y=(X^i)%k+1,z=(X+(X^i))%999999999%3;
		for(int j=1;j<=k;j++)tmp[j]=num[x]/p3[j-1]%3;
		tmp[y]=(tmp[y]*z)%3;
		for(int j=1;j<=k;j++)num[i]+=tmp[j]*p3[j-1];
		ans^=F[num[i]];
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Nt_Tsumiki (赞：11)

先把题面写成人看不懂的样子。

给定 $a_{i,j,x}$ 和 $d_{1\dots k}$ 求 $\sum_{i=1}^n\prod_{j=1}^m[3|\sum_{x=1}^ka_{i,j,x}d_x]$。

让我们施以单位根反演有：

$$
\begin{aligned}
\sum_{i=1}^n\prod_{j=1}^m[3|\sum_{x=1}^ka_{i,j,x}d_x]&=\frac{1}{3^m}\sum_{i=1}^n\prod_{j=1}^m1+w_3^{\sum_{x=1}^ka_{i,j,x}d_x}+w_3^{2\sum_{x=1}^ka_{i,j,x}d_x}
\end{aligned}
$$

让我们展开 $\prod$，以及令 $|b|=m \land \forall i\in[1,m],b_i\in\{0,1,2\}$ 有：

$$
\begin{aligned}
\sum_{i=1}^n\prod_{j=1}^m[3|\sum_{x=1}^ka_{i,j,x}d_x]
&=\frac{1}{3^m}\sum_{i=1}^n\prod_{j=1}^m1+w_3^{\sum_{x=1}^ka_{i,j,x}d_x}+w_3^{2\sum_{x=1}^ka_{i,j,x}d_x}\\
&=\frac{1}{3^m}\sum_{i=1}^n\sum_b\prod_{j=1}^mw_3^{b_j\sum_{x=1}^ka_{i,j,x}d_x}\\
&=\frac{1}{3^m}\sum_{i=1}^n\sum_bw_3^{\sum_{j=1}^mb_j\sum_{x=1}^ka_{i,j,x}d_x}\\
&=\frac{1}{3^m}\sum_{i=1}^n\sum_bw_3^{\sum_{x=1}^kd_x\sum_{j=1}^ma_{i,j,x}b_j}\\
\end{aligned}
$$

让我们给定 $a_i$ 和 $b$ 并令 $c_x=\sum_{j=1}^ma_{i,j,x}b_j$ 然后对状压起来的 $c$ 计数有：

$$
\begin{aligned}
\sum_{i=1}^n\prod_{j=1}^m[3|\sum_{x=1}^ka_{i,j,x}d_x]
&=\frac{1}{3^m}\sum_{i=1}^n\sum_bw_3^{\sum_{x=1}^kd_x\sum_{j=1}^ma_{i,j,x}b_j}\\
&=\frac{1}{3^m}\sum_{c}\text{cnt}_cw_3^{\sum_{x=1}^kd_xc_x}\\
&=\frac{1}{3^m}\sum_{c}\text{cnt}_c\prod_{x=1}^kw_3^{d_xc_x}\\
\end{aligned}
$$

好了，推式子告一段落，以上所述的 $c$ 和 $\text{cnt}_c$ 因为运算是在模 $3$ 意义下进行的，所以可以爆搜 $b$ 做到 $O(3^mnmk)$ 的复杂度。

然后我们令 $f_d=\sum_{c}\text{cnt}_c\prod_{x=1}^k w_3^{d_xc_x}$，那么我们现在考虑如何预处理出 $f_{1\dots 3^k}$，那么我们就能做到 $O(k)$ 的查询复杂度。

考虑 3-FWT 的式子是啥：

$$
\begin{aligned}
FWT(A)_i&=\sum_{j=0}^{3^k-1}A_jc_{j,i}\\
&=\sum_{j=0}^{3^k-1}A_j\prod_{x=1}^kc_{j_xi_x}\\
&=\sum_{j=0}^{3^k-1}A_j\prod_{x=1}^kw_3^{j_xi_x}
\end{aligned}
$$

啊所以 $f_d$ 就是对 $\text{cnt}_c$ FWT 一下后的结果，数学还是太神奇了。

总复杂度 $O(3^mnmk+k3^k+qk)$。

[submission](https://www.luogu.com.cn/record/201684648)

---

## 作者：ZnPdCo (赞：8)

首先我们发现这道题目的 $a_{i,j,x}$ 与每次操作的 $z$ 都可以对 $3$ 取模。那么第 $i$ 个节点的第 $j$ 个小朋友的所有祈愿可以被压为一个三进制数，即定义 $b_{i,j}=\sum_{x=1}^k 3^{x-1}(a_{i,j,x}\bmod 3)$。定义 $\oplus$ 表示 $3$ 进制意义下的不进位按位加法，例如 $(120)_3\oplus (201)_3=(021)_3$。定义 $\&$ 表示 $3$ 进制意义下的不进位按位乘，例如 $(120)_3\& (201)_3=(200)_3$。定义 $|x|$ 表示 $x$ 三进制意义下的按位和。那么原问题可以被重新表述：

有 $n\times m$ 个长度为 $k$ 的三进制数 $a_{i,j}$，每次查询为问有多少个 $i$ 满足对于所有的 $j$，$|b_{i,j}|\bmod 3=0$。

考虑修改，发现修改的可持久化其实是诈骗的，你可以直接记录一下每个版本修改的值，然后每次修改直接从对应版本的值上的某一位乘上某个数。

那么修改为将所有的 $b_{i,j}$ 在 $3$ 进制意义下不进位按位乘上某个数，即问题变为了 $\sum_{i=1}^n \prod_{j=1}^m[|b_{i,j}\&x|\bmod 3=0]$。

考虑单位根反演，那么有：
$$
[k|n]=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{in}
$$
则答案变成了：
$$
\sum_{i=1}^n \prod_{j=1}^m\frac{1}{3}(1+\omega_3^{|b_{i,j}\&x|}+\omega_3^{2|b_{i,j}\&x|})
$$
即：
$$
\frac{1}{3^m}\sum_{i=1}^n \prod_{j=1}^m(1+\omega_3^{|b_{i,j}\&x|}+\omega_3^{2|b_{i,j}\&x|})
$$
将内部连乘容斥出 $f_i$ 表示指数为 $i\& x$ 的数的系数。答案就是：

$$
\sum \omega_3^{|i\cap x|}f_{i}
$$

现在发现它具有 FWT 的样子，我们考虑 3-FWT 的实际意义：

定义 $A_i=\sum_{|i\cap j|=0} a_j+\sum_{|i\cap j|=1} \omega_3^1a_j+\sum_{|i\cap j|=2} \omega_3^2a_j$，容易证明 $A_iB_i=C_i$：
$$
\begin{aligned}
A_iB_i&=(\sum_{|i\cap j|=0} a_j+\sum_{|i\cap j|=1} \omega_3^1a_j+\sum_{|i\cap j|=2} \omega_3^2a_j)(\sum_{|i\cap k|=0} b_k+\sum_{|i\cap k|=1} \omega_3^1b_k+\sum_{|i\cap k|=2} \omega_3^2b_k) \\
&=(\sum_{|i\cap j|=0}\sum_{|i\cap k|=0} a_{j}b_{k}+\sum_{|i\cap j|=1}\sum_{|j\cap k|=2} a_jb_k+\sum_{|i\cap j|=2}\sum_{|j\cap k|=1} a_{j}b_k)+ \\
& \omega_3^1(\sum_{|i\cap j|=0}\sum_{|i\cap k|=1} a_{j}b_{k}+\sum_{|i\cap j|=1}\sum_{|j\cap k|=0} a_jb_k+\sum_{|i\cap j|=2}\sum_{|j\cap k|=2} a_{j}b_k)+ \\
& \omega_3^2(\sum_{|i\cap j|=0}\sum_{|i\cap k|=2} a_{j}b_{k}+\sum_{|i\cap j|=1}\sum_{|j\cap k|=1} a_jb_k+\sum_{|i\cap j|=2}\sum_{|j\cap k|=0} a_{j}b_k) \\
&=\sum_{|(j\oplus k)\cap i|=0}a_jb_k+\sum_{|(j\oplus k)\cap i|=1}\omega_3^1a_jb_k+\sum_{|(j\oplus k)\cap i|=2}\omega_3^2a_jb_k \\
&=C_i
\end{aligned}
$$
考虑快速计算 $A_i$，使用分治，假设当前考虑到第 $x$ 位，如果这一位是 $0$，有 $0\cap0=0\cap1=0\cap2=0$；如果这一位是 $1$，有 $1\cap0=0，1\cap1=1，1\cap2=2$；如果这一位是 $2$，有 $2\cap0=0,2\cap1=2,2\cap2=1$。

类似 FWT 地，有：
$$
A_i=merge(A_0+A_1+A_2,A_0+\omega_3^1A_1+\omega_3^2A_2,A_0+\omega_3^2A_1+\omega_3^1A_2)
$$
同理地得出位矩阵：
$$
\begin{bmatrix}
1 & 1 & 1 \\
1 & \omega_{3}^1 & \omega_{3}^2 \\
1 & \omega_{3}^2 & \omega_{3}^4 \\
\end{bmatrix}
$$
这就是 3-FWT 的转移位矩阵，所以我们只需要对容斥后的 $f$ 计算一次 3-FWT 就可以得出答案了。

可持久化容易实现，这里不予说明。

注意到在 $10^9+9$ 下 $3$ 具有单位根，所以我们在 $10^9+9$ 意义下计算就好了。

时间复杂度由容斥与 3-FWT 组合，瓶颈在于容斥。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
// 省略IO
const ll P = 1e9 + 9;
const ll N = 1e5 + 10;
const ll M = 6;
const ll K = 21;
ll qpow(ll x, ll y) {
	if(y == 0) return 1;
	if(y % 2 == 1) return x * qpow(x, y - 1) % P;
	ll tmp = qpow(x, y / 2);
	return tmp * tmp % P;
}
const ll G = 13;
const ll w1 = qpow(G, (P - 1) / 3);
const ll w2 = qpow(G, (P - 1) / 3 * 2);
const ll inv3 = qpow(3, P - 2);
ll tmp1[3], tmp2[3], pw3[K];
ll num1[K], num2[K];
ll n, m, k, q, X;
ll f[1000010];
ll a[N][M];
ll ver[1000010];
ll root;
struct base3 {
	int num[K];
	base3(int x = 0) {
		memset(num, 0, sizeof num);
		int len = 0;
		while(x) {
			num[++ len] = x % 3;
			x /= 3;
		}
	}
	friend base3 operator ^(const base3 &x, const base3 &y) {
		base3 z;
		for(int i = 1; i < K; i ++) {
			z.num[i] = (x.num[i] + y.num[i]) % 3;
		}
		return z;
	}
	int to_int() {
		int x = 0;
		for(ll i = 1; i < K; i ++) {
			x += pw3[i - 1] * num[i];
		}
		return x;
	}
} b[M];
ll Change(ll x, ll y, ll z) {
	ll len = 0;
	while(x) {
		num1[++ len] = x % 3;
		x /= 3;
	}
	for(ll i = 1; i <= len; i ++) {
		if(i == y) num1[i] = (num1[i] * z) % 3;
		x += pw3[i - 1] * num1[i];
		num1[i] = 0;
	}
	return x;
}
void dfs(ll num, base3 x) {
	if(num > m) {
		f[x.to_int()]++;
		return;
	}
    dfs(num + 1, x);
    dfs(num + 1, x ^ b[num]);
    dfs(num + 1, x ^ b[num] ^ b[num]);
}
void FWT(ll *a, ll type, ll len) {
	for (ll x = 3; x <= len; x *= 3) {
		ll k = x / 3;
		for (ll i = 0; i < len; i += x) {
			for (ll j = 0; j < k; j ++) {
				for (ll l = 0; l < 3; l++) tmp1[l] = a[i + j + l * k];
				if (type == 1) {
					tmp2[0] = (tmp1[0] + tmp1[1] + tmp1[2]) % P;
					tmp2[1] = (tmp1[0] + tmp1[1] * w1 + tmp1[2] * w2) % P;
					tmp2[2] = (tmp1[0] + tmp1[1] * w2 + tmp1[2] * w1) % P;
				} else {
					tmp2[0] = (tmp1[0] + tmp1[1] + tmp1[2]) % P;
					tmp2[1] = (tmp1[0] + tmp1[1] * w2 + tmp1[2] * w1) % P;
					tmp2[2] = (tmp1[0] + tmp1[1] * w1 + tmp1[2] * w2) % P;
					for (ll l = 0; l < 3; l++) (tmp2[l] *= inv3) %= P;
				}
				for (ll l = 0; l < 3; l++) a[i + j + l * k] = tmp2[l];
			}
		}
	}
}
int main() {
	read(n), read(m), read(k), read(X);
	pw3[0] = 1;
	for(int i = 1; i <= k; i ++) {
		root = root * 3 + 1;
		pw3[i] = pw3[i - 1] * 3;
	}
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			for(int x = 1; x <= k; x ++) {
				ll tmp = (X + 1ll * X * i + (X ^ (1ll * j * x + 1ll * i * i))) % 1000000000;
				tmp %= 3;
				a[i][j] += pw3[x - 1] * tmp;
			}
			b[j] = base3(a[i][j]);
		}
		dfs(1, base3());
	}
	ll inv = qpow(qpow(3, m), P - 2);
	FWT(f, 1, pw3[k]);
	ver[0] = root;
	ll ans = f[ver[0]] * inv % P;
	read(q);
	for(int i = 1; i <= q; i ++) {
		int x = (X ^ i) % i, y = (X ^ i) % k + 1, z = (X + (X ^ i)) % 3;
		ver[i] = Change(ver[x], y, z);
		ans ^= (f[ver[i]] * inv % P);
	}
	write(ans);
}
```

---


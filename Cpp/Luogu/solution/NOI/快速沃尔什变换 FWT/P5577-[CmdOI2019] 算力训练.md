# [CmdOI2019] 算力训练

## 题目背景

最近，出题人快乐地学习了如何解一元二次方程。

晚上在宿舍里，出题人梦见了一个使用 $k$ 进制的国度，入乡随俗嘛，出题人在这里也使用 $k$ 进制。

当然，这个国度里面的人也懂数学，所以解不出一元二次方程的出题人并没有逃掉算力训练。

## 题目描述

出题人在纸条上写了 $n$ 个 $k$ 进制自然数，由于他很懒，这些数的位数不会太多，都不会超过 $m$ 位。

为了训练算力，他每次会**随意取出一个子序列** (允许一个数都不选) ，然后把这些数都加起来。

他又觉得进位太麻烦了，干脆规定**加法不进位**。

算了几次之后，他突然很想知道自己得到每个数的方案数是多少，可是他太菜了，又不会算。冥思苦想一番之后,突然被起床铃拉出了梦境。

他觉得这个问题很有趣，只好求助于单手虐暴无数代数题的你，来帮忙计算一下。

**形式化题意** ： 对于一个序列 $A$ ，定义其权值 $W(A)$ 为 $A$ 中元素做 $k$ 进制不进位加法的和。

给出 $m,k$ 和一个长为 $n$ 的序列 $S$。保证 $S\subseteq [0,k^m)∩Z$。

对于 $t=0,1,2,...,k^m-1$ ，分别求出下列式子的值 ：

$${\rm Ans}[t]=\sum\limits_{\text{R 是 S 的子序列}}\big[W(R)=t\big]$$

注 ：根据正确的题意可推知 $\sum\limits_{t=0}^{k^m-1}{\rm Ans}[t]=2^n$。

## 说明/提示

### 样例解释

对于样例#1，共有 $2^3=8$ 种选取子序列的方法：

1. 什么都不选，和为 $0$
2. 选 $1$ ，和为 $1$
3. 选 $2$ ，和为 $2$
4. 选 $3$ ，和为 $3$
5. 选 $1+2$ ，和为 $3$
6. 选 $1+3$ ，和为 $4$
7. 选 $2+3$ ，和为 $0$ （由于是 $5$ 进制，本来要变成 $10$ 的，但是不进位就只剩下 $0$ 了）
8. 选 $1+2+3$，和为 $1$

综上，得到 `0,1,2,3,4` 的方案数分别是 `2,2,1,2,1` 。

### 数据范围和约定

| 测试点编号 | 　n　 | 　k　 | 　m　 | 总分数 |
| :--: | :--: | :--: | :--: | :--: |
| #1 | $20$ | $5$ | $4$ | $5$ |
| #2 | $1000$ | $5$ | $4$ | $5$ |
| #3~4 | $10^6$ | $5$ | $5$ | $10$ |
| #5 | $10^6$ | $5$ | $6$ | $10$ |
| #6~7 | $10^6$ | $5$ | $7$ | $20$ |
| #8 | $20$ | $6$ | $4$ | $5$ |
| #9 | $1000$ | $6$ | $4$ | $5$ |
| #10~11 | $10^6$ | $6$ | $4$ | $10$ |
| #12~14 | $10^6$ | $6$ | $6$ | $30$ |

## 样例 #1

### 输入

```
3 5 1
1 2 3```

### 输出

```
2
2
1
2
1```

## 样例 #2

### 输入

```
5 6 1
1 1 4 5 1 4```

### 输出

```
8
7
4
2
4
7```

# 题解

## 作者：Elegia (赞：9)

一些解释以及复杂度的明确。

假设我们的模数是一个性质比较好的质数 $p$，满足在 $\mathbb F_p$ 上方程 $\omega^k=1$ 有 $k$ 个互异根，这就可以直接对问题施加高维 DFT，俗称“单位根反演”或者 FWT 等。也就是首先任取本源单位根 $\Phi_k(\omega)=0$。

其中为了求算

$$ f_{x_0x_1x_2\dots x_{m-1}} = \prod_{y=y_0y_1\dots y_{m-1}} (1+\omega^{\sum_{i=0}^{m-1}x_iy_i})^{cnt_y}$$

我们需要添加占位多项式取模 $x^k-1$，通过

$$\prod_{y=y_0y_1\dots y_{m-1}} cnt_yx^{\sum_{i=0}^{m-1}x_iy_i}$$

的计算来得到每个 $(1+w^i)$ 需要做幂的上指标。事实上我们发现上述变换其实还是一个高维各自独立的变换，我们按照类似 FWT 的形式做转移，只需要做 $m k^{m-1}$ 次变换，每次可以在 $\Theta(k^3)$ 甚至 $\Theta(k^2\log k)$（不实用）的时间完成变换，这部分的时间复杂度是 $\Theta(mk^{m+2})$ 甚至 $\Theta(mk^{m+1}\log k)$。

我们考虑用占位多项式来先代替扩域。预见到我们的过程中没有发生除法，那么所有的运算都是可进行的。而注意到模 $x^k-1$ 有零因子，这等价于一个“数”被给出了多种表示。考虑本原多项式 $\Phi_k(x)$，由于在 $k=5,6$ 时本原多项式分别是 $x^4+x^3+x^2+x+1$ 和 $x^2-x+1$，经验证它们都不可因式分解。

> 如何验证？$\mathbb F_p$ 上的多项式的不可约性检测方法是验证充要条件：$f | (x^{p^n}-x)$ 且对任意素数 $t | n$，有 $\gcd(x^{p^{n/t}}-x,f) = 1$。

根据定义有 $\Phi_k(x) | x^k-1$，因此 $(f\bmod x^k-1)\bmod \Phi_k(x) = f \bmod \Phi_k(x)$，我们只需在原本占位多项式算得的结果基础上再进行这样一次约化，由于 $\bmod \Phi_k(x)$ 系没有零因子，所以这个环是域，因而我们可以断言取模完了之后只剩下常数项。

接下来考虑 $(1+x)^r$ 的计算，容易发现我们每个上指标 $r\le n$，所以可以通过分块预处理 $\Theta(wn^{1/w} k^2)$，单次询问 $\Theta(wk^2)$。实际上取 $w=2$ 就已经对效率没什么影响了。因为一项的乘积就是要计算 $\prod_i (1+w^i)^{r_{x,i}}$，我们要将若干 $\prod_i F_{x,i}(w^i)$ 相乘，第 $i$ 个在 $x^j \rightarrow x^{ij \bmod k}$ 下标变换后可以认为是 $k/\gcd(i,k)$ 项的，总共乘法消耗可以认为是 $\Theta(k\sum_{d|k} \varphi(d)d) = \Theta(k^3)$，此时 $\Theta(wk^3)$ 在 $w$ 取常数时是同阶的。

因此这种方法的复杂度是 $\Theta(nk + mk^{m+2} + wn^{1/w}k^2 + wk^{m+3})$。


---

## 作者：Itst (赞：9)

题意说人话就是给出一个长度为$n$的数列$a_1,a_2,...,a_n$，求$\prod\limits_{i=1}^n (1+x^{a_i})$，其中卷积的下标加法定义为$k$进制不进位加法。

---

$k$进制不进位加法不难想到$k$进制FWT，所以我们需要快速求出$\prod\limits_{i=1}^n \mathrm{DWT}_k(1 + x^{a_i})$，这里的乘法是点积，最后IDWT回来即可。

因为要用形式幂级数做到乘单位根，所以我们获得了一个$O(nk^mmk^2)$的优秀算法，然而并没有什么×用。

---

考虑优化。可以发现任意一个$\mathrm{DWT}_k(1 + x^{a_i})$中所有数构成的集合都是集合$W = \{w_k^i+1|i \in [0,k-1] \cap Z\}$的子集，而$|W|=k$并不大，所以我们可以考虑设

$$x_{i,j} = \sum\limits_{p=1}^n [[x^i]\mathrm{DWT}_k(1+x^{a_p}) = w_k^j + 1]$$

那么这$n$个幂级数的卷积的第$i$项的值就是

$$\prod\limits_{p=0}^{k-1} (w_k^p+1)^{x_{i,p}}$$

可以快速计算。

---

接下来考虑对于一个确定的$i$如何求出$x_{i,j}$的值。毫无疑问需要解方程。

首先我们显然有一个式子是

$$x_{i,0} + x_{i,1} + x_{i,2}+...+x_{i,k-1}=n$$


设幂级数$A$满足$[x^j]A = \sum\limits_{i=1}^n [a_i = j]$，考虑$[x^i] \mathrm{DWT}_k(A)$。对于一个$p$和一个满足$[x^i]\mathrm{DWT}_k(1+x^{a_j}) = w_k^p + 1$的$j$，可以发现其对$[x^i]\mathrm{DWT}_k(A)$的贡献是$w_k^p$。所以我们有

$$w_k^0x_{i,0}+w_k^1x_{i,1}+...+w_k^{k-1}x_{i,k-1} = [x^i]\mathrm{DWT}_k(A)$$

---

观察两个方程的系数向量：

$$1,1,1,1,...,1$$

$$w_k^0,w_k^1,w_k^2,...,w_k^{k-1}$$

有些范德蒙德矩阵的Feeling。那么我们能不能求出

$$w_k^0x_{i,0}+w_k^2x_{i,1}+...+w_k^{2(k-1)}x_{i,k-1}$$

也就是原来对某个位置贡献为$w_k^p$的数组，在变换之后它的贡献变为$w^{2p}_k$。

可以发现这相当于将FWT过程中的单位根平方一下。所以我们只需要把所有$w_k$都变为$w_k^2$就可以了。具体来说，以$k=5$为例，$k$进制FWT使用下面的位矩阵：

$$\left( \begin{array}{cccc} 1 & 1 & 1 & 1 & 1 \\ 1 & w_5^1 & w_5^2 & w_5^3 & w_5^4 \\ 1 & w_5^2 & w_5^4 & w_5^1 & w_5^3 \\ 1 & w_5^3 & w_5^1 & w_5^4 & w_5^2 \\ 1 & w_5^4 & w_5^3 &w_5^2 & w_5^1 \end{array} \right)$$

现在把单位根平方，位矩阵就变成下面这样：

$$\left( \begin{array}{cccc} 1 & 1 & 1 & 1 & 1 \\ 1 & w_5^2 & w_5^4 & w_5^1 & w_5^3 \\ 1 & w_5^4 & w_5^3 & w_5^2 & w_5^1 \\ 1 & w_5^1 & w_5^2 & w_5^3 & w_5^4 \\ 1 & w_5^3 & w_5^1 &w_5^4 & w_5^2 \end{array} \right)$$

使用这一个位矩阵进行DWT，则$[x^i]\mathrm{DWT}_k(A)=w_k^0x_{i,0}+w_k^2x_{i,1}+...+w_k^{2(k-1)}x_{i,k-1}$。

值得注意的是我们只是求值，所以这个矩阵就算不是合法的位矩阵也可以这么做（毕竟你不需要进行逆操作）。

照葫芦画瓢地可以得到$k$个方程，其系数矩阵是DWT使用的范德蒙德矩阵。所以只要对于得到的所有结果IDWT一下就可以得到所有$x_{i,j}$的值。

---

朴素实现复杂度大概是$O(k^{m+4}m)$的（$k$次FWT，每一次$k^mmk$次乘法，乘法复杂度$k^2$）比较慢。下面是一些实现细节：

1. 可以发现将单位根乘方之后对幂级数进行FWT得到的每一位的值构成的集合一定是对其进行$k$进制FWT得到的值的集合的子集。可以实现一个函数计算对单位根进行乘方后FWT得到的每一位的值分别对应进行$k$进制FWT后哪一位的值。这样可以把一个$k$摘掉，复杂度变为$O(k^{m+3}m)$。这一部分实现可以参考代码中的`getid`函数。

2. 单位根在模意义下不存在所以要扩域，即将一个数表示为$a_0w^0+a_1w^1+...+a_{k-1}w^{k-1}$，可以发现它是封闭的。如果直接这样做有一个非常大的好处是所有单位根都只有一个位置有值，可以做到$O(k)$乘单位根。有一个bug是最后的答案并不是$a_0$所以并没有这样实现。

3. 延续点2中的问题，我们最后的答案不是$a_0$的原因是有一些单位根它们的和为$0$，比如说$\sum\limits_{i=0}^{k-1} w_k^{k-1}=0$，或者在$2 \mid k$时$w_k^i = w_k^{i+\frac{k}{2}}$，这意味着一个整数在这个域上的表示不是唯一的。这就是为什么我写成了二合一：

- 对于$k=5$的情况将$w^4 = -(w^0+w^1+w^2+w^3)$代入，将一个数表示为$a_0w^0+a_1w^1+a_2w^2+a_3w^3$的形式进行求解。
- 对于$k=6$的情况先使用$w_1=-w_4,w_3=-w_0,w_5=-w_2$，这样就只剩下$w_0,w_2,w_4$，然后代入$w_4=-w_0-w_2$，这样我们可以只用将数表示为$a_0w_0+a_1w_2$的形式就可以求解了。

以这样的形式求解最后得到的$a_0$就是答案。

然而我很想知道为什么这么消了之后一个整数就一定能被唯一表示……

---

code:

```c++
#include<bits/stdc++.h>
using namespace std;

int read(){
	int a = 0; char c = getchar(); while(!isdigit(c)) c = getchar();
	while(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return a;
}

const int MOD = 998244353;
int upd(int x){return x + (x >> 31 & MOD);}
int add(int x , int y){return upd(x + y - MOD);}
int sub(int x , int y){return upd(x - y);}
int mul(int x , int y){return x <= 1 || y <= 1 ? x * y : 1ll * x * y % MOD;}

int N , K , M , arr[1000003] , pwK[10]; long long IVK;
int id[100003];
void getid(int L , int pw){
	if(L == 1) return (void)(id[0] = 0);
	int p = L / K; getid(p , pw);
	for(int i = 0 ; i < p ; ++i){
		int t = id[i];
		for(int j = 0 ; j < K ; ++j , t = (t + p * pw) % L)
			id[i + j * p] = t;
	}
}

template < typename op >
void FWT(op *now , op *tmp , op *w , int tp){
	for(int i = 0 ; i < M ; ++i){
		for(int j = 0 ; j < pwK[M] ; j += pwK[i + 1])
			for(int k = 0 ; k < pwK[i] ; ++k){
				for(int l = 0 ; l < K ; ++l) tmp[j + k + pwK[i] * l] = op();
				for(int l = 0 ; l < K ; ++l)
					for(int p = 0 ; p < K ; ++p)
						tmp[j + k + pwK[i] * l] = tmp[j + k + pwK[i] * l] +
							(!l || !p ? now[j + k + pwK[i] * p] : now[j + k + pwK[i] * p] * w[(tp == 1 ? l : K - l) * p % K]);
			}
		for(int j = 0 ; j < pwK[M] ; ++j) now[j] = tmp[j];
	}
}

namespace solve1{
	struct op{
		int arr[4];
		op(int _a = 0 , int _b = 0 , int _c = 0 , int _d = 0){arr[0] = _a; arr[1] = _b; arr[2] = _c; arr[3] = _d;}
		int& operator [](int x){return arr[x];}
		friend op operator +(op x , op y){op t; for(int i = 0 ; i < 4 ; ++i) t[i] = add(x[i] , y[i]); return t;}
		friend op operator -(op x , op y){op t; for(int i = 0 ; i < 4 ; ++i) t[i] = sub(x[i] , y[i]); return t;}
		friend op operator *(op x , op y){
			op t; int sum4 = 0;
			for(int j = 0 ; j < 4 ; ++j)
				if(y[j])
					for(int i = 0 ; i < 4 ; ++i){
						int id = i + j >= 5 ? i + j - 5 : i + j;
						(id == 4 ? sum4 : t[id]) = add(id == 4 ? sum4 : t[id] , mul(x[i] , y[j]));
					}
			if(sum4) for(int i = 0 ; i < 4 ; ++i) t[i] = sub(t[i] , sum4);
			return t;
		}
	}now[100003] , tmp[100003] , val[5][100003] , w[5]{op(1),op(0,1),op(0,0,1),op(0,0,0,1),op(MOD-1,MOD-1,MOD-1,MOD-1)} , pww1[5][1003] , pww2[5][1003];

	void init_pww(){
		for(int i = 0 ; i < K ; ++i){
			pww1[i][0] = pww2[i][0] = op(1); pww1[i][1] = w[i] + op(1);
			for(int j = 2 ; j <= 1000 ; ++j) pww1[i][j] = pww1[i][j - 1] * pww1[i][1];
			pww2[i][1] = pww1[i][1000];
			for(int j = 2 ; j <= 1000 ; ++j) pww2[i][j] = pww2[i][j - 1] * pww2[i][1];
		}
	}

	op getpw(int id , int val){return pww2[id][val / 1000] * pww1[id][val % 1000];}
	
	void work(){
		init_pww();
		for(int i = 1 ; i <= N ; ++i){
			int tmp = arr[i] , t = 0 , tms = 1; while(tmp){t += tmp % 10 * tms; tms *= K; tmp /= 10;} ++now[t][0];
		}
		FWT(now , tmp , w , 1); for(int i = 0 ; i < pwK[M] ; ++i) val[0][i][0] = N;
		for(int i = 1 ; i < K ; ++i){getid(pwK[M] , i); for(int j = 0 ; j < pwK[M] ; ++j) val[i][j] = now[id[j]];}
		for(int i = 0 ; i < pwK[M] ; ++i){
			for(int j = 0 ; j < K ; ++j) tmp[j] = op(0 , 0);
			for(int j = 0 ; j < K ; ++j) for(int l = 0 ; l < K ; ++l) tmp[j] = tmp[j] + val[l][i] * w[l * (K - j) % K];
			now[i] = op(1); for(int j = 0 ; j < K ; ++j) now[i] = now[i] * getpw(j , 1ll * tmp[j][0] * IVK % MOD);
		}
		FWT(now , tmp , w , -1); int iv = 1; for(int i = 0 ; i < M ; ++i) iv = 1ll * iv * IVK % MOD;
		for(int i = 0 ; i < pwK[M] ; ++i) printf("%lld\n" , 1ll * now[i][0] * iv % MOD);
	}
}

namespace solve2{
	struct op{
		int x , y; op(int _x = 0 , int _y = 0) : x(_x) , y(_y){}
		friend op operator +(op x , op y){return op(add(x.x , y.x) , add(x.y , y.y));}
		friend op operator -(op x , op y){return op(sub(x.x , y.x) , sub(x.y , y.y));}
		friend op operator *(op x , op y){int t = mul(x.y , y.y); return op(sub(mul(x.x , y.x) , t) , sub(add(mul(x.y , y.x) , mul(x.x , y.y)) , t));}
	}now[100003] , tmp[100003] , val[6][100003] , w[6]{op(1),op(1,1),op(0,1),op(MOD-1),op(MOD-1,MOD-1),op(0,MOD-1)} , pww1[6][1003] , pww2[6][1003];

	void init_pww(){
		for(int i = 0 ; i < K ; ++i){
			pww1[i][0] = pww2[i][0] = op(1); pww1[i][1] = w[i] + op(1);
			for(int j = 2 ; j <= 1000 ; ++j) pww1[i][j] = pww1[i][j - 1] * pww1[i][1];
			pww2[i][1] = pww1[i][1000];
			for(int j = 2 ; j <= 1000 ; ++j) pww2[i][j] = pww2[i][j - 1] * pww2[i][1];
		}
	}

	op getpw(int id , int val){return pww2[id][val / 1000] * pww1[id][val % 1000];}
	
	void work(){
		init_pww();
		for(int i = 1 ; i <= N ; ++i){
			int tmp = arr[i] , t = 0 , tms = 1;
			while(tmp){t += tmp % 10 * tms; tms *= K; tmp /= 10;}
			++now[t].x;
		}
		FWT(now , tmp , w , 1); for(int i = 0 ; i < pwK[M] ; ++i) val[0][i].x = N;
		for(int i = 1 ; i < K ; ++i){getid(pwK[M] , i); for(int j = 0 ; j < pwK[M] ; ++j) val[i][j] = now[id[j]];}
		for(int i = 0 ; i < pwK[M] ; ++i){
			for(int j = 0 ; j < K ; ++j) tmp[j] = op(0 , 0);
			for(int j = 0 ; j < K ; ++j) for(int l = 0 ; l < K ; ++l) tmp[j] = tmp[j] + val[l][i] * w[l * (K - j) % K];
			now[i] = op(1 , 0); for(int j = 0 ; j < K ; ++j) now[i] = now[i] * getpw(j , 1ll * tmp[j].x * IVK % MOD);
		}
		FWT(now , tmp , w , -1); int iv = 1; for(int i = 0 ; i < M ; ++i) iv = 1ll * iv * IVK % MOD;
		for(int i = 0 ; i < pwK[M] ; ++i) printf("%lld\n" , 1ll * now[i].x * iv % MOD);
	}
}

int main(){
	N = read(); K = read(); M = read(); for(int i = 1 ; i <= N ; ++i) arr[i] = read();
	IVK = MOD + 1; while(IVK % K) IVK += MOD;
	IVK /= K; pwK[0] = 1; for(int i = 1 ; i <= M ; ++i) pwK[i] = pwK[i - 1] * K;
	if(K == 6) solve2::work(); else solve1::work();
	return 0;
}
```

---

## 作者：command_block (赞：5)

### 官方题解:算力训练

$\color{blue}\text{重制于2020.11}$ : 更优的复杂度，更严谨普适的推导。

终于跨越 / 尘封的灵光一现 / 突破崭新的界面 / 环视身边的一切

**题意** : 给出 $m,k$ 和一个可重集合 $S$ ，保证 $S\subset [0,k^m)$。

选出所有 $2^{|S|}$ 个子集做 $k$ 进制不进位加法，求得到 $[0,k^m)$ 中每个数的方案数。

答案对 $998244353$ 取模。

- （1） $k=5,m\leq 7$

- （2） $k=6,m\leq 6$

时限 $\texttt{600ms}$。

------------


- $\Large 10'$

直接枚举所有子集暴力搞就好了，复杂度 $O(2^nm)$。

只要会写 $k$ 进制不进位加法和进制转换就行。

- $\Large 20'$

不难想到一个 $\rm DP$ : $f[i][j]$ 表示前 $i$ 个数的子集和为 $j$ 的方案数。

易得 $f[i][j]=f[i-1][j]+\sum\limits_{a_i\otimes k=j}f[i-1][k]$

复杂度 $O(nmk^m)$。

```cpp
#include<cstdio>
#define ll long long 
using namespace std;
const int mod=998244353;
ll powM(ll a,int t=mod-2){
  ll ans=1;
  while(t){
  	if (t&1)ans=ans*a%mod;
  	a=a*a%mod;t>>=1;
  }return ans;
} 
int m,bas;
int read(){
  int X=0;char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*bas+(ch^48),ch=getchar();
  return X;
}
inline int add(int x,int y)
{
  for (int i=0,t=1,sav;i<m;i++,t*=bas){
  	sav=(y/t+x/t)%bas;
  	x-=x/t%bas*t;
  	x+=sav*t;
  }return x;
}
int tot,n,f[2500],fs[2500];
int main()
{
  scanf("%d%d%d",&tot,&bas,&m);
  n=powM(bas,m);fs[0]=1;
  for (int i=1,sav;i<=tot;i++){
  	sav=read();
  	for (int j=0;j<n;j++)f[j]=fs[j];
    for (int j=0;j<n;j++){
	    int k=add(j,sav);
      f[k]=(f[k]+fs[j])%mod;
    }for (int j=0;j<n;j++)fs[j]=f[j];
  }
  for (int i=0;i<n;i++)
    printf("%d\n",f[i]);
  return 0;
}
```

- $\Large 40'$

正 片 开 始。

- **前置知识** ： $k$ 进制不进位加法卷积

  可见 [位运算卷积(FWT) & 集合幂级数](https://www.luogu.com.cn/blog/command-block/wei-yun-suan-juan-ji-yu-ji-kuo-zhan) 中第四节。
  
  注意，在本题中单位根 $w_k$ 在模意义下不存在，需要相关扩域技巧。文章中有详细介绍。

不难发现，将数字 $a$ 写成向量幂级数 $1+x^a$ ，这些幂级数的$k$ 进制不进位加法卷积就是答案。

前文的 $\rm DP$ 就相当于在暴力计算这个卷积。

考虑如何加速计算，注意到每个幂级数中都只有两项，可以挖掘性质。

设 $F_{1...n}$ 为各个幂级数，$c(\_,\_)$ 为变换系数。

${\rm FWT}(F_i)[k]=\sum\limits_{i=0}c(k,i)F_i[i]$

由于 $F_i$ 只有 $0,a_i$ 这两个非 $0$ 项，而恒有 $c(0,\_)=1$。

可得 ${\rm FWT}(F_i)[k]=1+c(k,a_i)$。

设最终答案幂级数 $P=\prod\limits_{i=1}^nF_i$ ，则根据变换的性质 有 ${\rm FWT}(P)[k]=\prod\limits_{i=1}^n{\rm FWT}(F_i)[k]$

我们的位矩阵是范德蒙德矩阵，其中都是 $k$ 次单位根的幂，可推知 $c$ 都是单位根的幂，显然只有 $k$ 种。

那么 ${\rm FWT}(F_i)[k]$ 也只有 $(1+w_k^0),(1+w_k^1)...(1+w_k^{k-1})$ 这 $k$ 种。

只要求出 ${\rm FWT}(P)[k]=\prod\limits_{i=1}^n{\rm FWT}(F_i)[k]$ 中被乘了多少次，然后求幂即可快速得到 ${\rm FWT}(P)$。

一个简单的想法是，对于每种可能的 $F_i$ 暴力统计贡献，复杂度为 $O(k^{2m})$。
 
- $\Large 100'$

设多项式 $C[k]=\sum\limits_{i=1}^{n}[a_i=k]$ ，即计数数组。

对 $C[k]$ 求 $\rm FWT$ 变换，可得 ${\rm FWT}(C)[k]=\sum\limits_{i=0}c(k,i)C[i]=\sum\limits_{i=0}^nc(k,i)[a_i=k]$。

这可以统计第 $k$ 位上变换计数的和。

考虑使用对 $x^k-1$ 取模的循环卷积多项式来代替单位根，填到变换矩阵中。

此时，算得的 $\sum\limits_{i=0}^nc(k,i)[a_i=k]$ 就会自动按照幂次将不同的 $c(k,i)$ 出现次数分隔开。

这个求和的复杂度与经典 $\rm FWT$ 相同，为 $O(k^{m+2}m)$。

得到了每个 $(1+w_k^?)$ 的出现次数之后，需要计算其幂，这里需要使用光速幂。这部分复杂度为 $O(k^{m+3})$。

等我有空了再来写复杂度正确的代码，可能会投放到评论区里面。

---

## 作者：不知不觉lb (赞：3)

推广个人博客：[buzhibjue.cf](https://buzhibujue.cf)

> ### Description
>
> $n$ 个不超过 $m$ 位的 $k$ 进制数，每次**随意取出一些数** （注意可以一个数都不选）， 然后把这些数进行 $k$ 进制下**不进位**加法。
>
> 求最终 $0\sim k^m-1$ 的每个数字被表示出来的方案数对 $998244353$ 取模
>
> ### Input
>
> 第一行三个整数 $n,k,m$ 意义为题目中所述。
>
> 第二行 $n$ 个整数，之间用空格隔开，表示纸条上的数字。
>
> （**注意** , 纸条上的数均为 $k$ 进制数）
>
> ### Output
>
>  共 $k^m$ 行，你需要在第 $i$ 行输出最终得到数字 $i−1$ 的方案数模  $998244353$ 的值。 
>
> ### Sample Input

```plain
3 5 1
1 2 3
```

> ### Sample Output

```plain
2
2
1
2
1
```

> ### Constraints
>
> $n\leq 10^6$ 
> $k=5$ 时 $m\leq 7$ 
> $k=6$ 时 $m\leq 6$



### Solution

答案是形如 $\prod_{i=1}^n(1+x^{a_i})$ 的所有项的系数并且此处卷积的定义是：两个下标乘起来得到的下标是这两个下标的 $k$ 进制下不进位加法得到的值。

于是就有了个 $O(nk^m)$ 的优质做法：每次加入一个数就枚举所有下标并更新它乘上 $1+x^{a_i}$ 到达的位置。可以获得 20pts 的好成绩

如果这是普通的多项式乘法那么直接对于每个数 DFT 一遍算出许多点值再对应乘起来再把这些点值 IDFT 回去就是答案。

然后你大概感性理解~~意会~~一下题目中的「 $k$ 进制下不进位加法」的卷积其实也可以类似的做：把每个下标看成一个 $m$ 维的向量 $\mathbf{V}=\{v_0,v_1,v_2,\cdots v_{m-1}\}$ 且其中每一位 $v_i<k$ （就是 $k$ 进制下的每一位），那么一个下标 $\mathbf{V}=\{v_0,v_1,v_2\cdots,v_m\}$ 和 $\mathbf{U}=\{u_0,u_1,u_2,\cdots u_{m-1}\}$ 的卷积 $\mathbf{V\cdot U}=\{(v_0+u_0)\mod k,(v_1+u_1)\mod k,\cdots,(v_{m-1}+u_{m-1})\mod k\}$ 就是向量中对应的每一位在模 $x^k$ 意义下的循环卷积。

> 循环卷积的例子：模 $x^5$ 意义下的 $x^3\cdot x^4=x^7$ 就变成了 $x^2$ 

我们尝试对于一个 $1+x^{a_i}$ 如何进行 $m$ 维下的 DFT

回想一下一般的一维 DFT 含义：对于第 $i$ 项系数它对 DFT 的结果中位置 $j$ 的贡献的系数是 $\omega^{ij}$ 

二维的话位置 $(Ax,Ay)$ 对位置 $(Bx,By)$ 的贡献就是 $\omega^{AxBx}\cdot\omega^{AyBy}=\omega^{AxBx+AyBy}$ 直接先对每一行 DFT 再对每一列 DFT 就行

那么似乎可以直接套到多维上去：对于一个向量 $\mathbf{U}=\{u_0,u_1,\cdots u_{m-1}\}$ ，其对结果中位置 $\mathbf{V}=\{v_0,v_1,\cdots,v_{m-1}\}$ 的贡献是 $\omega^{u_0v_0}\cdot\omega^{u_1v_1}\cdots\omega^{u_{m-1}v_{m-1}}=\omega^{u_0v_0+u_1v_1+\cdots+u_{m-1}v_{m-1}}$

回到题目。

> 因为模 $998244353$ 意义下不存在 $\omega_5$ 和 $\omega_6$ 的整数解，但我们又需要表示出 $\omega_5$ 和 $\omega_6$ ，以下内容均在扩域后的意义下进行
>
> 即把每个「数」看成是 $a_0\omega_k^0+a_1\omega_k^1+\cdots+a_{k-1}\omega_k^{k-1}$ 
>
> 易证这个域里的「数」满足加法和乘法的封闭性

结合 20pts 做法，注意到每次乘上的只有两项，其中 $1=x^0=x^{\{0,0,\cdots,0\}}$ 它对所有位置都会造成 $\omega_k^{0+0+\cdots+0}=1$ 的贡献；而 $x^{V}=x^{\{v_0,v_1,\cdots,v_{m-1}\}}$ 对于每个位置 $\mathbf{U}=\{u_0,u_1,\cdots u_{m-1}\}$ 会造成 $\omega_k^{u_0v_0}\cdot\omega_k^{u_1v_1}\cdots\omega_k^{u_{m-1}v_{m-1}}=\omega_k^{u_0v_0+u_1v_1+\cdots+u_{m-1}v_{m-1}}$ 的贡献

那我们对于 $n$ 个数可以每次 DFT 得到 $k^m$ 个形如 $1+\omega_k^{t}$ 的的点值，一共求 $n$ 遍对于每一位把它对应的 $n$ 个 $1+\omega_k^t$ 乘起来最后再 IDFT 回去就是答案

这样做复杂度可能是 $O(n(k^m\times k^2))$ 的无疑是过不了的。


但是发现 $n$ 的范围很大但 $k^m$ 却小得多似乎指引我们按照值域做。

仔细一想对于某一位来说，似乎并不需要求出所有的 $n$ 个 $1+\omega_k^t$ 分别是多少，只需要对于每个 $t\in[0,k-1]$ 知道有多少个 $1+\omega_k^t$ 就行了（只需要个数，至于它们具体属于 $n$ 个中的哪几个是无关紧要的）

那问题就转化为有 $n$ 个数 $\mathbf{V_1,V_2,\cdots,V_{n}}$ ，每一项对于位置 $\mathbf{U}$ 的贡献都是上面那个很长的式子。求对于每个位置 $\mathbf U$ 的每个 $t\in[0,k-1]$ ，在这 $n$ 个数中有多少个数对于他的贡献是 $\omega_k^t$

这东西看上去异常的难以下手，出题人的标程里写的好像是什么奇奇怪怪的折半引理消去引理的奇淫技巧~~看不懂~~

讨论区里又有一位 djq 大爷说是什么单位根反演，但（道理我都懂~~板子我都抄过~~，哪里有单位根反演啊/晕）

然后我不知道怎么搞直接把每个值对应下标加一然后做一遍 DFT ，令人惊奇的发现它！就！对！了！

（我写到这里一看上面我写的，就想问自己，这**为什么不对啊）

但这里给读者讲一下~~（也给将来的我自己）~~（看懂的就直接跳过好了）：

大概是对应下标加一后位置 $\mathbf V$ 的系数就是这个 $\mathbf{V}$ 出现的次数，对于每一个 $\mathbf V$ 它对于每个下标 $\mathbf U$ 的影响都是个定值 $\omega_k^t$ 。那么有 $a_{\mathbf V}$ 个，贡献就是 $a_{\mathbf V}\omega_k^t$ 。那么我们直接把这 $a_V$ 个一起做 DFT 肯定是没有问题的（我们每次是 $a_{\mathbf V}$ 加一（而没有改变后面的 $\omega_k^1,\omega_k^2\cdots $ 的项的系数 ），所以最后乘出来对于每个位置的贡献确实就是 $\omega_k^t$ 有多少个算多少个）~~感觉跟没讲一样，有啥问题评论区问吧~~ 

现在我们知道了对于一个位置 $\mathbf U$ 和 $t\in[0,k-1]$ 有多少个数最后对其的贡献是 $\omega_k^t$ （记为 $a(\mathbf V,t)$ 。那么这些数点积时都会是 $1+\omega_k^t$ 的形式，那么最后点积出来位置 $\mathbf V$ 的值就是 $\prod_{t=0}^{k-1}(1+\omega_k^t)^{a(\mathbf V,t)}$ 

最后再做一遍 IDFT 就能得到最终的答案了，总复杂度大概是 $O(k^{m+2}\sim k^{m+3})$ 左右，如果快速幂没有预处理（见实现细节）可能还要多个 $\log n$ 

好你就这样高高兴兴的写完然后输出每个答案 ( $a_0\omega_k^0+a_1\omega_k^1+\cdots+a_{k-1}\omega_k^{k-1}$ ) 中的 $a_0$ 就发现样例都过不了？？？

你一看题解发现要输出 $a_0+a_1-a_2-a_3$ 才行？？？而且写了就直接能过？？？

如果你做过 [cf1103E]( https://www.luogu.org/problem/CF1103E ) 的话可能也会对洛谷上唯一的题解里最终输出的是 `` a[i].a[0]-a[i].a[4] `` 而不是 ``a[i].a[0]`` 感到疑惑（然而题解并没有提到这个 magic number 是哪来的（以及他把 $\omega_{10}$ 写成 $-\omega_5^3$ 为啥是对的都没有解释，像我等蒟蒻看的真是难受））

这里就方便一下我等蒟蒻略作证明（不需要的可以跳过看代码了）：

##### $k=5$ 

先说结论：可以证得：$a_1=a_2=a_3=a_4$ 

（可以像那篇题解一样「带进去检验」，然而对于我等来说真不容易）

我的证法是：你可以发现最终这个东西一定是个整数，并且无论我们把 $\omega_5^1,\omega_5^2,\omega_5^3,\omega_5^4$ 中的哪一个带入答案都会是整数（这个我确实不会证，应该和 FFT 最后会是不带虚部的实数是同一个原因）

那么我们在复平面中画出所有的 $\omega_5$ 的幂

![pic1](https://s2.ax1x.com/2019/11/08/ME5GSP.png)

我们最后要得到 $a_0\omega_5^0+a_1\omega_5^1+a_2\omega_5^2+a_3\omega_5^3+a_4\omega_5^4$ 是一个不带虚部的整数

有 

$$
\begin{cases}
x=a_0+a_1\sin18^{\circ}+a_4\sin 18^{\circ}-a_2\cos 36^{\circ}-a_3\cos 36^{\circ}\in \mathbf Z
\\
y=a_1\cos 18^{\circ}-a_4\cos 18^{\circ}+a_2\sin 36^{\circ}-a_3\sin 36^{\circ}=0 
\end{cases}
$$

而 $\sin 18^{\circ}=\frac{\sqrt 5-1}4,\cos 18^{\circ}=\frac{\sqrt{10+2\sqrt 5}}4,\sin 36^{\circ}=\frac{\sqrt{10-2\sqrt 5}}4,\cos 36^{\circ}=\frac{1+\sqrt 5}4$

所以得到
$$
\begin{cases}
a_0+(a_1+a_4)\sin 18^{\circ}-(a_2+a_3)\cos 36^{\circ}=a_0+(a_1+a_4)\frac{\sqrt 5-1}4-(a_2+a_3)\frac{\sqrt 5 +1}4\\=\frac {\sqrt 5 }4(a_1+a_4-a_2-a_3)+\frac 14(4a_0-a_1-a_4-a_2-a_3)\in \mathbf Z\\
(a_1-a_4)\cos 18^{\circ}+(a_2-a_3)\sin 36^{\circ}=(a_1-a_4)\frac{\sqrt{10+2\sqrt 5}}4+(a_2-a_3)\frac{\sqrt{10-2\sqrt 5}}{4}=0
\end{cases}
$$

又因为 $a_0,a_1,a_2,a_3,a_4\in \mathbf Z$ ，由上面的第二个式子得到 $a_1-a_4=a_2-a_3=0$ ，又由第一个式子得到 $a_1+a_4-a_2-a_3=0$ 于是就有 $a_1=a_2=a_3=a_4$

> 实际上不严谨的证明大概想一下上下对应的系数一定相同才能使得最后 $y$ 被抵消完落在 $x$ 轴上成为不带虚部的整数，左右两边如果相同的话就是 $\cos 72^{\circ}-\cos 36^{\circ}=-\frac 12$ 是个有理数 ~~感觉是对的~~

知道这个后求值就很简单了：
$$
\begin{aligned}
&a_0\omega_5^0+a_1\omega_5^1+a_2\omega_5^2+a_3\omega_5^3+a_4\omega_5^4
\\=&
a_0+a_1(\omega_5^1+\omega_5^2+\omega_5^3+\omega_5^4)
\\=&
a_0+a_1(\frac{\omega_5-\omega_5^5}{1-\omega_5})
\\=&
a_0-a_1
\end{aligned}
$$
当然也可以直接用刚才三角函数的式子： $x=\frac {\sqrt 5 }4(a_1+a_4-a_2-a_3)+\frac 14(4a_0-a_1-a_4-a_2-a_3)=a_0-a_1$



##### $k=6$

也差不多，不知道其他人怎么证的我还是画了个图：

![pic2](https://s2.ax1x.com/2019/11/08/ME53Wt.png)

和刚才类似的，我们可以得到
$$
\begin{cases}
x=a_0+a_1\cos 60^{\circ}-a_2\cos 60^{\circ}-a_3-a_4\cos 60^{\circ}+a_5\cos 60^{\circ}\in \mathbf Z\\
y=a_1\sin 60^{\circ}+a_2\sin 60^{\circ}-a_4\sin 60^{\circ}-a_5\sin 60^{\circ}=0
\end{cases}
$$

$\sin 60^{\circ}=\frac{\sqrt 3}2,\cos 60^{\circ}=\frac 12$ ，我们得到 $a_1+a_2-a_4-a_5=0$ 以及 $x=a_0-a_3+\frac 12(a_1-a_2-a_4+a_5)\in \mathbf Z$

这里并不能保证上下对应位置的系数相等了（即不能保证 $a_1=a_2=a_4=a_5$ ），但由 $a_1+a_2-a_4-a_5=0$ 可以得到 $a_1-a_4=a_5-a_2$ 得到 $x=a_0-a_3+\frac 12(a_1-a_4+a_5-a_2)=a_0-a_3+a_1-a_4$

答案就是 $a_0+a_1-a_4-a_3$ （题解里好像是 $a_0+a_1-a_2-a_3$ 所以应该可以证明 $a_2=a_4,a_1=a_5$ ？感觉我还不会证，欢迎交流。~~反正打表出来是对的那我们就当它是对的~~ ）




#### 一些实现上的细节

1. 求 $1+\omega_k^t$ 在 $t=0$ 的时候是 $1+1=2$ 注意不要对应系数直接赋值成 $1$ 了
2. $(1+\omega_k^t)^{a(\mathbf V,t)}$ 的时候快速幂可能被卡常，可以预处理出 $(1+\omega_k^t)^{1000}$ 的幂来加速
3. $k=5$ 也可以用 $a_0+a_1-a_2-a_3$ 表示（ $=a_0-a_1$ ）不用分类讨论
4. DFT 时的单位根只有一项有值，可以把 $O(k^2)$ 的乘法优化成 $O(k)$ ~~我太懒了就没写~~


### Code

```c++
#include<bits/stdc++.h>
#define FIO "P5577"
#define ll long long

char buf[1<<20]; int bufl,bufr;
#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1<<20,stdin)))?buf[bufl++]:EOF)
template <class T>inline void read (T &x,const int &bas=10) {
	T f=1;
	x=0;
	char ch=getch;
	for (; !isdigit (ch)&&ch!='-'; ch=getch);
	if (ch=='-')f=-1,ch=getch;
	for (; isdigit (ch); ch=getch)x=x*bas+ch-'0';
	x*=f;
}

const int MOD=998244353,V=6,N=pow(5,7)+5;

inline int add(int a,const int &b){a+=b;return a>=MOD?a-MOD:a;}
inline int sub(int a,const int &b){a-=b;return a<		0?a+MOD:a;}
inline int mul(const int &a,const int &b){return 1ll*a*b%MOD;}
inline int& inc(int &a,const int &b){return a=add(a,b);}
inline int& dec(int &a,const int &b){return a=sub(a,b);}
inline int& pro(int &a,const int &b){return a=mul(a,b);}
inline int qpow(int a,int b){int c=1;for(;b;b>>=1,pro(a,a))if(b&1)pro(c,a);return c;}

int n,k,m;

struct Com{
  int a[V];
  inline void clear(){a[0]=a[1]=a[2]=a[3]=a[4]=a[5]=0;}
  inline Com(){clear();}
  inline int& operator [](int x){return a[x];}
  inline const int& operator [](const int &x)const{return a[x];}
  inline Com operator +(const Com &b)const{Com c;for(int i=0;i<k;i++)c[i]=add(a[i],b[i]);return c;}
  inline Com operator -(const Com &b)const{Com c;for(int i=0;i<k;i++)c[i]=sub(a[i],b[i]);return c;}
  inline Com operator *(const int &b)const{Com c;for(int i=0;i<k;i++)c[i]=mul(a[i],b);return c;}
  inline Com& operator +=(const Com &b){return *this=*this+b;}
  inline Com& operator *=(const int &b){return *this=*this*b;}
  inline Com operator *(const Com &b)const{
    static ll r[V<<1];
    const ll Moc=8ll*MOD*MOD;
    for(int i=0;i<k;i++)if(a[i])for(int j=0;j<k;j++)if(b[j]){
      r[i+j]+=1ll*a[i]*b[j];
      if(r[i+j]>=Moc)r[i+j]-=Moc;
    }
    Com c;
    for(int i=0;i<k;i++)c[i]=(r[i]+r[i+k])%MOD,r[i]=r[i+k]=0;
    return c;
  }
  inline Com& operator *=(const Com &b){return *this=*this*b;}
  inline void out(){for(int i=0;i<k;i++)printf("%d%c",a[i],i^(k-1)?' ':'\n');}
  inline int val(){
    return sub(add(a[0],a[1]),add(a[2],a[3]));
  }
}a[N],w[2][V],b[N];

inline void pre(){
  w[0][0][0]=w[1][0][0]=1;
  w[0][1][1]=w[1][1][k-1]=1;
  for(int i=2;i<k;i++)
    w[0][i]=w[0][i-1]*w[0][1],w[1][i]=w[1][i-1]*w[1][1];
}

//inline Com qpow(Com a,int b){Com c;c[0]=1;for(;b;b>>=1,a*=a)if(b&1)c*=a;return c;}
const int B=1000;
Com pw0[B+5],pw1[B+5];
inline Com qpow(Com a,int b){return pw1[b/B]*pw0[b%B];}

inline void getpow(){
  for(int i=0;i<n;i++)b[i][0]=1;
  for(int i=0;i<k;i++){
    Com omega;
    //!!! i=1 gg 
    omega[0]=1;omega[i]++;
    pw0[0][0]=pw1[0][0]=1;
    for(int i=1;i<=B;i++)pw0[i]=pw0[i-1]*omega;
    pw1[1]=pw0[B];
    for(int i=1;i<=B;i++)pw1[i]=pw1[i-1]*pw1[1];
    for(int id=0;id<n;id++)b[id]*=qpow(omega,a[id][i]);
  }
  for(int i=0;i<n;i++)a[i]=b[i];
}

int pw[V];
inline void fft(int opt){
  pw[0]=1;for(int i=1;i<m;i++)pw[i]=pw[i-1]*k;
  for(int i=0;i<m;i++){
    for(int j=0;j<n;j++)
    if(!((j/pw[i])%k)){
      static Com f[V];
      for(int x=0;x<k;x++)
        for(int y=0;y<k;y++)
          f[y]+=a[j+pw[i]*x]*w[opt][x*y%k];
      for(int x=0;x<k;x++)
        a[j+pw[i]*x]=f[x],f[x].clear();
    }
  }
  if(opt)for(int i=0,inv=qpow(n,MOD-2);i<n;i++)a[i]*=inv;
}

int main(){
	freopen(FIO".in","r",stdin);
	freopen(FIO".out","w",stdout);
 read(n);read(k);read(m);
  for(int i=1,x;i<=n;i++)read(x,k),a[x][0]++;
  n=qpow(k,m);
  pre();

  fft(0);

  getpow();

  fft(1);

  for(int i=0;i<n;i++)printf("%d\n",a[i].val());

	return 0;
}
```



---

## 作者：_abcd_ (赞：1)

## [[CmdOI2019] 算力训练](https://www.luogu.com.cn/problem/P5577)

看到 $ k $ 进制不进位加法很自然会想到 $ \rm FWT $。不会 $ k $ 进制 $ \rm FTW $ 的可以去 [$ \rm OI-Wiki $](https://oi-wiki.org/math/poly/fwt/#%E4%B8%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95)。

不难发现答案为
$$ \prod\limits_{i=1}^n 1 + x^{a_i} $$

这里下标的加法定义为 $ k $ 进制不进位加法。

一个朴素的想法就是，对于每个 $ i $，对 $ 1 + x^{a_i} $ 进行 $ \rm FWT $，并将每一位都乘一起，最后 $ \rm UFWT $ 回去。由于不存在 $ 6 $ 次单位根，因此还需要将每一位都设为关于 $ \omega_k $ 的多项式。这么做的复杂度是 $ O( n m k^{m+2} ) $，显然过不去。

考虑优化。不难发现，对 $ x^{a_i} $ 进行 $ \rm FWT $ 后，每一位都是形如 $ \omega_k^c $ 的，而对 $ 1 $ 进行 $ \rm FWT $ 后，每一位都是 $ 1 $。因此，对 $ 1 + x^{a_i} $ 进行 $ \rm FWT $ 后，每一位都是形如 $ 1 + \omega_k^c $ 的。

因此，对 $ \sum\limits_{i=1}^n x^{a_i} $ 进行 $ \rm FWT $ 后，对于某个 $i$，设结果的第 $i$ 位为 $ \sum\limits_{j=0}^{k-1} c_j \omega_k^{j} $，则说明对于每个 $ j $，都恰好存在 $ c_j $ 个 $ a $，使得 $ [x^i] \operatorname{FWT}( 1 + x^a ) = 1 + \omega_k^j $，所以 $ [x^i] \prod\limits_{j=1}^n 1 + x^{a_j} = \prod\limits_{j=0}^{k-1} ( 1 + \omega_k^j )^{c_j} $。由于 $ c_j \le n $，因此对每个 $ j, c $ 预处理出 $ ( 1 + \omega_k^j )^c $ 即可。复杂度为 $ O( n k^2 + k^{m+3} ) $。注意预处理 $ ( 1 + \omega_k^j )^c $ 时不要把所有结果都存下来，最好对每个 $ j $ 单独处理，否则会爆空间。

---

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pn putchar('\n')
#define mset(a,x) memset(a,x,sizeof a)
#define mcpy(a,b) memcpy(a,b,sizeof a)
#define all(a) a.begin(),a.end()
#define fls() fflush(stdout)
#define int ll
#define maxn 1000005
#define mod 998244353
using namespace std;
int re()
{
    int x=0;
    bool t=1;
    char ch=getchar();
    while(ch>'9'||ch<'0')
        t=ch=='-'?0:t,ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return t?x:-x;
}
int ksm(int x,int y)
{
    int ret=1;
    while(y)
    {
        if(y&1)ret=ret*x%mod;
        x=x*x%mod,y>>=1;
    }
    return ret;
}
void dq(int &x)
{
    if(x>=mod)x-=mod;
    if(x<0)x+=mod;
}
int n,K,m,N;
int toK(int x)
{
    int ret=0;
    for(int i=1;i<N;i*=K)
    {
        ret+=x%10*i;
        x/=10;
    }
    return ret;
}
struct Poly
{
    int a[6];
    Poly()
    {
        mset(a,0);
    }
    void clr()
    {
        mset(a,0);
    }
    void print()
    {
        for(int i=0;i<K;i++)
            printf("%lld ",a[i]);
        pn;
    }
    void operator = (int x)
    {
        mset(a,0);
        a[0]=x;
    }
    int& operator [] (int x)
    {
        return a[x];
    }
    Poly operator << (int t)
    {
        t%=K;
        if(t<0)
            t+=K;
        Poly ret;
        for(int i=0;i<K;i++)
            ret[t+i>=K?t+i-K:t+i]=a[i];
        return ret;
    }
    Poly operator + (Poly t)
    {
        Poly ret;
        for(int i=0;i<K;i++)
            dq(ret[i]=a[i]+t[i]);
        return ret;
    }
    void operator += (Poly t)
    {
        *this=*this+t;
    }
    Poly operator * (Poly t)
    {
        Poly ret;
        for(int i=0;i<K;i++)
        {
            for(int j=0;j<K;j++)
                (ret[i+j>=K?i+j-K:i+j]+=a[i]*t[j])%=mod;
        }
        return ret;
    }
    void operator *= (Poly t)
    {
        *this=*this*t;
    }
    Poly operator * (int t)
    {
        Poly ret;
        for(int i=0;i<K;i++)
            ret[i]=a[i]*t%mod;
        return ret;
    }
    void operator *= (int t)
    {
        *this=*this*t;
    }
}a[100000],b[100000],P,tmp[100000],f[maxn];
void FWT(Poly a[],bool ty=0)
{
    for(int i=1;i<N;i*=K)
    {
        for(int j=0;j<N;j+=i*K)
        {
            for(int k=j;k<j+i;k++)
            {
                for(int l=0;l<K;l++)
                {
                    int t=k+l*i;
                    tmp[t]=a[t];
                    a[t].clr();
                }
                for(int x=0;x<K;x++)
                {
                    for(int y=0;y<K;y++)
                        a[k+x*i]+=tmp[k+y*i]<<(!ty?x*y:-x*y);
                }
            }
        }
    }
    if(ty)
    {
        int iv=ksm(N,mod-2);
        for(int i=0;i<N;i++)
            a[i]*=iv;
    }
}
void Mod(Poly& a)
{
    for(int i=K-1;i>=m;i--)
    {
        int t=a[i];
        for(int j=0;j<=m;j++)
            (a[i-j]-=t*P[m-j])%=mod;
    }
}
signed main()
{
    n=re(),K=re(),m=re();
    N=1;
    while(m--)
        N*=K;
    if(K==5)
    {
        m=4;
        P[0]=P[1]=P[2]=P[3]=P[4]=1;
    }
    else
    {
        m=2;
        P[0]=P[2]=1;
        P[1]=-1;
    }
    for(int i=1;i<=n;i++)
        a[toK(re())][0]++;
    FWT(a);
    for(int i=0;i<N;i++)
        b[i]=1;
    for(int i=0;i<K;i++)
    {
        f[0]=1;
        for(int j=1;j<=n;j++)
        {
            for(int k=0;k<K;k++)
                f[j][k]=f[j-1][k];
            for(int k=0;k<K;k++)
                dq(f[j][k+i>=K?k+i-K:k+i]+=f[j-1][k]);
        }
        for(int j=0;j<N;j++)
            b[j]*=f[a[j][i]];
    }
    FWT(b,1);
    for(int i=0;i<N;i++)
    {
        Mod(b[i]);
        int ans=b[i][0];
        if(ans<0)
            ans+=mod;
        printf("%lld\n",ans);
    }
    return 0;
}
```

---


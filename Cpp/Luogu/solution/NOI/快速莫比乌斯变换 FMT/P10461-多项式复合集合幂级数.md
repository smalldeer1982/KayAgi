# 多项式复合集合幂级数

## 题目描述

给定一个集合幂级数 $F(x)$ 和一个多项式 $G(x)$，保证 $[x^{\varnothing}]F(x)=0$。定义 $x$ 的乘法为子集卷积，你需要对 $S\subseteq\{1,2,\cdots,n\}$ 求出 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值。

如果你仍不清楚题意，可以阅读题面最后的提示部分。

## 说明/提示

#### 【数据范围】

对于所有数据，保证 $1\le n\le 20$，$[x^S]F(x),[x^n]G(x)\in[0,998244353)\cap\mathbb Z$。

本题有 $20$ 个测试点，第 $i$ 个测试点满足 $n=i$。

#### 【提示】

假设 $F(x)=\displaystyle \sum_S f_Sx^S$，那么 $[x^S]F(x)=f_S$。

在本题中，$x$ 的乘法被定义为子集卷积，即：
$$x^S\cdot x^T=\begin{cases}0&S\cap T\neq\varnothing\\x^{S\cup T}&\text{otherwise}\end{cases}$$

**请注意内存访问连续性带来的效率差异。**

## 样例 #1

### 输入

```
2
0 1 2 3
2 1 1```

### 输出

```
2 1 2 7```

## 样例 #2

### 输入

```
4
0 8 3 2 7 3 9 0 0 1 8 2 3 7 0 2
1 0 4 8 2```

### 输出

```
1 0 0 192 0 448 168 8824 0 0 0 536 0 248 520 26560 ```

# 题解

## 作者：喵仔牛奶 (赞：5)

## Solution

设 $f_{k,S}$ 表示 $[x^S]F^k(x)$，$g_{i}$ 表示 $[x^n]G(x)$。集合幂级数的乘法是子集卷积。

考虑 $\sum_{k=0}^{n}g_k\times f_{k,S}$ 的组合意义：初始集合为 $S$，每次删一个包含 $\max S$ 的子集，如果删了 $k$ 次有 $g_k\times k!$ 的贡献。注意这里的正确性依赖 $f_{1,\varnothing}=0$。

设 $[x^S]H_{i,j}(x)$ 表示删除了 $j$ 次后集合变为 $S$，且 $\max S\le i$，这种情况下所有删 $S$ 方案的贡献和。

初始时 $h_{0,i,\varnothing}=g_i\times i!$。考虑从小到大枚举 $i$，刷表法转移：
- 存在一次删除，满足 $i=\max S$ 的情况：设 $F_i(x)=\sum_S f_S[i=\max S]$，$H_{i,j-1}\gets H_{i,j-1}+H_{i-1,j}\times F_i$。
- 不存在这样的删除的情况：原样转移，$H_{i,j}\gets H_{i,j}+H_{i-1,j}$。

显然，$H_{n,0}$ 即为答案。

转移时忽略 $\max S>i$ 的集合，时间复杂度为 $\sum_{i=0}^{n}(n-i)i^22^i=\mathcal O(n^22^n)$。使用滚动数组压掉第一维，空间复杂度为 $\mathcal O(n2^n)$。

---

## 作者：STARSczy (赞：3)

要求 $f(G)$，设答案 $F=f(G)$。

考虑等式两边同时求导，有 $F'=G'f'(G)$。这里求导是求等式关于 $x_n$ 的偏导，即将除 $x_n$ 以外的其它变量看做常数求导。对于一个集合幂级数 $F$ 求偏导 $F'$，有 $F'=[x_n^1]F$。故 $[x_n^1]F=[x_n^1]G f'(G)$。由于 $[x_n^1]f'(G)$ 对答案无意义，即只有 $[x_n^0]f'(G)$ 对答案有意义，故 $[x_n^1]F=[x_n^1]G [x_n^0]f'(G)$，得 $[x_n^1]F=[x_n^1]G f'([x_n^0]G)$。我们发现这是求 $[x_n^1]F$ 的方法。

于是考虑如何求 $[x_n^0]F$。$[x_n^0]F=[x_n^0]f(G)=f([x_n^0]G)$。这是求 $[x_n^0]F$ 的方法。

因为 $F=x_n^1[x_n^1]F+x_n^0[x_n^0]F$，所以可分治求解。

回顾一下。对于一个 $f(G)$，我们要求 $[x_n^1]G f'([x_n^0]G)$ 和 $f([x_n^0]G)$，这两个子问题 $n$ 的规模都减了 $1$，而要多求一个 $f'([x_n^0]G)$。所以时间复杂度有 $\sum_{i=0}^n (n-i)\Theta(i^2 2^i)=\Theta(n^2 2^n)$，时间复杂度足以通过。

注意要加上滚动数组，将空间优化到 $\Theta(n 2^n)$。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/rope>
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
//#define int long long
#define double long double
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define rbtree(way) tree<way,null_type,less<way>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
const int maxn=(1<<20)+10,maxm=1e6+10,mod=998244353,inf=INT_MAX;
inline int ksm(int x,int k,int mod=mod){
	int ans=1;
	for(;k;k>>=1,x=x*x%mod) if(k&1) ans=ans*x%mod;
	return ans;
}

int n,f[23][23],a[maxn][23],ans[maxn][23],ans1[maxn<<1][23],cn[maxn];

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	rep(i,0,(1<<n)-1) cin>>a[i][(cn[i]=__builtin_popcount(i))-1];
	rep(i,0,n) cin>>f[n][i];
	per(i,n-1,0) rep(j,0,i) f[i][j]=1ll*f[i+1][j+1]*(j+1)%mod;
	rep(i,1,n) rep(x,0,i-2) rep(sub,1<<i-1,(1<<i)-1) if(sub>>x&1)
		rep(j,0,n) (a[sub][j]+=a[sub^(1<<x)][j])%=mod;
	rep(i,0,n){
		rep(sub,0,(1<<i)-1) rep(k,0,n) ans[sub][k]=ans1[sub][k],ans1[sub][k]=0;
		ans1[1][0]=f[i][0];
		if(!i) continue;
		rep(j,1,i){
			rep(x,0,j-2) rep(sub,1<<j-1,(1<<j)-1) if(sub>>x&1)
				rep(k,0,n) (ans[sub][k]+=ans[sub^(1<<x)][k])%=mod;
			rep(sub,1<<j-1,(1<<j)-1) rep(k,0,n) rep(x,0,k)
				(ans1[(1<<j)|sub][k]+=1ll*a[sub][x]*ans[sub][k-x]%mod)%=mod;
			rep(x,0,j-2) per(sub,(1<<j+1)-1,(1<<j)|(1<<j-1)) if(sub>>x&1)
				rep(k,0,n) (ans1[sub][k]+=mod-ans1[sub^(1<<x)][k])%=mod;
			rep(sub,(1<<j)+(1<<j-1),(1<<j+1)-1) per(i,n,1) swap(ans1[sub][i],ans1[sub][i-1]);
			rep(sub,0,(1<<j-1)-1) ans1[sub|(1<<j)][cn[sub]]=ans1[sub|(1<<j-1)][cn[sub]];
			rep(sub,0,(1<<j)-1) rep(k,0,n) if(k!=cn[sub]) ans1[sub|(1<<j)][k]=0;
		}
	}
	rep(sub,0,(1<<n)-1) cout<<ans1[sub|(1<<n)][cn[sub]]<<' ';
	return 0;
}
```

---


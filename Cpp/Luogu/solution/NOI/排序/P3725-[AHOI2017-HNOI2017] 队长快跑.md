# [AHOI2017/HNOI2017] 队长快跑

## 题目描述

众所周知，在 P 国外不远处盘踞着巨龙大 Y。传说中，在远古时代，巨龙大 Y 将 P 国的镇国之宝窃走并藏在了其巢穴中，这吸引着整个 P 国的所有冒险家前去夺回，尤其是皇家卫士队的队长小 W。在 P 国量子科技实验室的帮助下，队长小 W 通过量子传输进入了巨龙大 Y 的藏宝室，并成功夺回了镇国之宝。但此时巨龙布下的攻击性防壁启动，将小 W 困在了美杜莎的迷宫当中。

被困在迷宫 $(0,0)$ 处的队长小 W 快速观察了美杜莎的迷宫的构造，发现迷宫的出口位于 $(p,q)$ 处。巨龙大 Y 在迷宫当中布置了 $n$ 火焰吐息机关，每个机关可以用三个参数 $(x,y,\theta)$ 表示，分别指明机关位于平面的坐标 $(x,y)$，以及火焰吐息的方向相对于 $x$ 正方向的倾角 $\theta$。巨龙强大的力量使得火焰吐息有无穷长，且队长小  W 不能通过被火焰吐息覆盖的射线（注意，机关所处的坐标若没有被其他火焰吐息覆盖，则是可以通过的）。同时，迷宫在沿 $x$ 负方向无穷远的地方放置了美杜莎之眼，使得队长小 W 必须倾向于向 $x$ 正方向行动（即队长小 W 的移动方向在 $x$ 正方向上的投影必须为正，不能是负数或零），否则队长小 W 将被瞬间石化而无法逃离。

心急如焚的队长小 W 需要趁着巨龙大 Y 还没将其抓住前逃离美杜莎的迷宫，所以他立马向 P 国智囊团求助，作为智囊团团长的你，一定可以帮队长小 W 找出安全逃至迷宫出口的最短道路。

## 说明/提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/5107.png) 

$30\%$ 的数据满足 $n\leq 300$；

$60\%$ 的数据满足 $n\leq 2000$；

$80\%$ 的数据满足 $n\leq 10^5$；

$100\%$ 的数据满足： $0 \leq n,p, |q|, |x|, |y| \leq 10^6； \theta \in [−\pi, \pi]$。
数据保证至少存在一条合法路径，且起点和终点均不会被火焰路径覆盖。

## 样例 #1

### 输入

```
7 20 -5
4 3 -2.875
5 7 -1.314
10 -2 0.666
16 1 -1.571
16 1 1.571
23 -3 -2.130
14 -5 3.073```

### 输出

```
33.3380422500```

## 样例 #2

### 输入

```
7 20 0
5 2 1.155
5 2 1.987
5 2 -1.571
11 -4 1.765
11 -4 1.377
15 -4 1.765
15 -4 1.377```

### 输出

```
24.2735704188```

# 题解

## 作者：a1455520571 (赞：22)

本人与同学各种证明了两天，终于是把我们目前所知的问题全都证明出来了，如果你被网上各种只给做法不给证明的题解所困扰，希望这篇题解可以帮助到你。（拒绝感性理解和咕咕咕）

鸣谢 $\_Cavalier23$ 与 $Ninjia$ 的帮助。

个人认为先将做法看懂再去看证明会比较容易理解。

# 题解正文

明显，最优路径肯定是由一堆上凸和下凸路径拼起来的。那么我们就可以通过维护上凸和下凸来得到最优解。我们把射线分成两类，一类用来维护上凸路径，另一类用来维护下凸路径。（可以想象为上下两个方向，下面用 “上” 来表示维护上凸路径的一类， “下” 类似）分类标准是：在起点到终点的向量左边的射线如果与起点到终点的**线段**有交点，分入 “上” ，否则分入 “下” 。在起点到终点的向量右边的射线如果与起点到终点的**线段**有交点，分入 “下” ，否则分入 “上” 。接下来将 “上” 中的路径掰竖直向上，“下” 中的路径掰竖直向下（理由见下面的证明1）。

例子：

掰直前：
![a.png](https://i.loli.net/2020/05/21/AdXvNKhmO1B3boI.png)

掰直后：
![b.png](https://i.loli.net/2020/05/21/vO6DEYe8dKVFLBj.png)

明显我们只需要走端点，然后我们考虑如何维护。

对于每一个点，我们可以记录下从起点到它的最优路径中它的上一个点是谁（如果有最优路径的话），这样我们就可以逐步还原最优路径。记点 $i$ 的上一个点为 $pre_i$ ，那么我们的问题就转换成如何求每个点的 $pre$ 。然后发现这里有单调性：

对于一段上凸路径，考虑在末尾新加入一条射线。如果加入后并没有形成上凸包，就说明上一条射线没有切断上上个端点与当前端点的
联系，那么就可以直接删除最后的节点（样例如下）。这明显就可以用单调队列维护，维护好后队尾的端点就是新加入端点的 $pre$ 。下凸路径相似。

![c.png](https://i.loli.net/2020/05/21/xhJOXl73RIHBobP.png)

但是不同指向的射线也有可能会相互影响，就如下图（以下的图都默认粉色的点是指上的，蓝色的点是指下的）：

![e.png](https://i.loli.net/2020/05/21/8PQx3n9jWlFXreO.png)

对于 $G$ ，我们可以发现 $C$ 到 $G$ 的路径被射线$I$ 截断了，通过凸包的单调性，可以推得 **有路径被截断时，起点到 $G$ 的路径一定被第一条指下的射线截断。** 此时到G点的最优路径应该是 $S→E→I→G$ ，原先指上的端点一个都不经过。证明如下：

假如我们先走一段上凸路径，然后接上一段下凸到新加入的点（如下图）

![g.png](https://i.loli.net/2020/05/21/eZMEJzLmd8VoArl.png)

那么在图中，我们连接 $S,I$，然后延长 $ED,DC,BC$ 交 $SI$，得到下图：

![h.png](https://i.loli.net/2020/05/21/rkoE9SC1Lz6DgIx.png)

在$S→E$ 的下凸路径上的点一定都在三角形 $SIE$ ，图中我们可以通过三角不等式得到 

$IE+IJ>JE=JD+DE$

$JD+JK>KD=KC+CD$

$KC+KL>LC=LB+BC$

$SL+LB>SB$

整合得

$IA+AI+IE>IS+IE>SB+BC+CD+DE$

其他情况类似，通过相似的做法也可以证明在不同指向的射线没有相互影响时，在上凸路径中的点的最优路径一定是从起点一直走上凸路径到它而非先先走一段下凸再走上来。如果感觉没听懂，可以看下面的例子：

![i.png](https://i.loli.net/2020/05/21/TavFWeEu9ZDJSKi.png)

图中 $SC+CD+DE+EF<SB+BE+EF$也可以用上面的方法证明。


回到正题，原来的上凸包被弹空了，我们维护的上凸包失效了，要想一个办法重新整出一个上凸包才行，这时我们发现到原先的"上凸包"与下凸包有一段是重合的，设它们从点 $x$ 后分离，那么在 $x$ 之前的点都不会与之后加入的点有直接连接（因为被射线 $x$ 与 最后加入的射线挡住了）。那么我们可以直接**把 $x$ 作为新起点开始维护**。这样上凸包又有了。

这里还有一个问题，就是射线的方向应该是通过判断它与新起点和终点的位置关系确定，不过其它题解都是直接在一开始就判断，这样没问题吗？答案是肯定的，详见下证明2。

## 证明1

不在起点与终点间的射线没有影响，它们不会经过起点到终点的线段（不然就无解了）。而被该射线分隔的射线（如下图中在C射线之上的）无法更新答案，因为它们的指向必须全部相同（不然就会有射线切到起点到终点的线段，造成无解情况），于是无法用来更新起点，而要更新起点一定会有更优的射线把它们全部弹掉。而它们也无法阻隔起点到终点，最后也肯定会被终点更新掉，所以不在起点与终点间的射线一定没有影响。

![k.png](https://i.loli.net/2020/05/21/oRZMCJkKcj3UTHp.png)

两条指向不同的射线，要么交点不在起点到终点之间，要么没有交点。不然绝对会将起点与终点分隔在两个区域。

两条指向相同的射线，证明就复杂一些了。

我们要关注的就是后面的射线是否会切断**起点**与前面的端点的连线，前面的射线是否会切断**终点**与后面的端点的连线，然后分类讨论。

#### 1. 前不切，后不切

那就跟直接掰直没区别了。
#### 2. 前不切，后切
举个例子：
![l.png](https://i.loli.net/2020/05/21/VhdNogKGTsRYe6F.png)
通过一定的手玩，可以猜测**后面的射线一定可以弹掉前面的射线**。

证明：

以指上的射线为例，在前面的点称为 $A$ ，后面的点称为 $C$ 。

若射线 $A$ 经过线段 $ST$ ,那么就会造成无解情况(如下图)。

![o.png](https://i.loli.net/2020/05/21/2lSpqvTcrzQ6GLN.png)

若射线 $A$ 不经过线段 $ST$ ,如果点 $C$ 无法将 $A$ 弹出，那么就必须在图中的阴影部分

![p.png](https://i.loli.net/2020/05/21/vklcxowSMtL8zGj.png)

而此时射线 $C$ 要经过线段 $SA$ ，必须同时经过线段 $ST$ ，那么方向就不是朝上了，与条件冲突。

所以猜测是正确的,那么该情况和掰直达到的效果也就是一样的。

#### 3. 前切，后不切

该情况的证明与情况2类似，不在此赘述。

#### 4. 前切，后切

该情况下，两条射线都不经过线段 $ST$,因为若射线 $A$ 经过 $ST$ ,那么点 $C$ 就必须在下图的阴影部分中，这样点 $A$ 就被包含在三角形 $STC$ 中，射线 $A$ 也就只能经过该三角形的一条边，因此射线 $A$ 不可能同时经过线 $ST$ 和 $CT$ 。
![q.png](https://i.loli.net/2020/05/21/Did9cTpZgQJbHkA.png)

而两条射线都不经过线段 $ST$ 的情况，这两条射线围成的部分（如下图中的蓝色部分）跟不在起点与终点间的射线围成的部分起到的作用是一样的。所以也可以直接掰直。

$\ $

![r.png](https://i.loli.net/2020/05/21/O9UzbS5P6yaENFW.png)

综上，所以情况都被证实可以了。

## 证明2

设旧起点为 $S$ ,新起点为 $S'$ ,终点为 $T$ ，在 $S'$左边的射线不考虑；在三角形 $STS'$中的射线方向是不变的，枚举射线过的边就可以证明；
而在三角形外的射线如果要改变方向，那必须经过边 $SS'$,不过这种情况明显非法。所以剩下的射线的方向全都不变。

### 总结
这个贪心做法虽然会考虑错许多情况，但这些情况都不会对答案造成影响（简直恶心），对出题人的脑洞五体投地。

### 代码：

```
#include<bits/stdc++.h>//码风奇丑，敬请见谅。 
using namespace std;
const int N=1e6+5;
int n,tx,ty,sx,sy,q[2][N],ql[2],qr[2],l,pre[N];
double ans;
struct P{
	int x,y;
	double w;
	bool operator < (const P&t)const{
		return x<t.x;
	}
	P operator - (const P&t)const{
		return (P){x-t.x,y-t.y,0};
	}
}a[N],b[N];
int dir(P a){//确定方向 
	double l=atan2(sy-a.y,sx-a.x),r=atan2(ty-a.y,tx-a.x);
	if(l<r)return l<a.w&&a.w<r;
	return a.w<r||a.w>l;
}
long long crs(P a,P b){//叉积判断位置， 
	return 1ll*a.x*b.y-1ll*b.x*a.y;
}
long long s2(int x){return 1ll*x*x;}
#define u1 b[q[ur][ql[ur]]]
#define u2 b[q[ur][ql[ur]+1]]
#define d1 b[q[dr][qr[dr]]]
#define d2 b[q[dr][qr[dr]-1]]
int main(){
	scanf("%d %d %d",&n,&tx,&ty);
	for(int i=1;i<=n;++i){
		scanf("%d %d %lf",&a[i].x,&a[i].y,&a[i].w);
	}
	sort(a+1,a+n+1);//将射线按x坐标排序 
	for(int i=1;i<=n;++i)if(a[i].x>0&&a[i].x<tx)b[++l]=a[i];//选出有用的射线 
	b[++l]=(P){tx,ty,0}; 
	for(int i=1;i<=l;++i){//两个队列队首元素永远都是起点
		int dr=dir(b[i]),ur=!dr,cg=dr? -1:1;
		if(ql[ur]<qr[ur]&&(crs(b[i]-u1,u2-u1)*cg)>=0){//判断路径是否被不同指向的射线截断 
			ql[dr]=qr[dr]+1;//将没用元素清空。
			ql[ur]++;
			while(ql[ur]<qr[ur]&&(crs(b[i]-u1,u2-u1)*cg)>=0)ql[ur]++;
			q[dr][++qr[dr]]=q[ur][ql[ur]];
			sx=u1.x;sy=u1.y;
		}else {
			while(ql[dr]<qr[dr]&&(crs(b[i]-d2,d1-d2)*cg)>=0)qr[dr]--;
		}
		pre[i]=q[dr][qr[dr]];
		q[dr][++qr[dr]]=i;
	}
	for(int i=l;i;i=pre[i])ans+=sqrt(s2(b[i].x-b[pre[i]].x)+s2(b[i].y-b[pre[i]].y)); 
	printf("%.10lf",ans);
	return 0;
}

```


---

## 作者：斯德哥尔摩 (赞：8)

这题真得是神奇啊！

我已经卡了半个月了，不是代码码不出来，而是根本没有思路。。。

然后看了一位巨神的[Blog](http://ljqpaper.duapp.com/index.php/archives/485/)终于还是弄懂了。

但是洛谷上的数据可能有误，我也不知道是不是这种思路的问题，反正洛谷上的题解允许非正解/AC算法，那就为OIer们做个好事吧。

其实就是这样的：

我们可以把射线的方向规约成两类：相对于$s,t$的连线分成向上与向下的两类。

不难发现，改变射线的方向后，原有的限制条件并未被改变。

要判断一条线是否规约为“向下”，只需判断它的关于$P$的极角是否在$s$和$t$关于$P$的极角之间。

问题可以转化为多边形两点间最短距离，有经典算法可以解决，但是目前oi界应该不会涉及到吧。~~（虽然我也不知道是什么。。。）~~

有一个做法可以通过本题的大部分数据（除了后面那几个数据可能有误的点），下面介绍它的具体实现。

将所有射线按端点的横坐标排序，依次计算每个端点到$s$的最短路径上，距离它最近的点$next$。

维护两个队列$que1$和$que2$，分别对应上和下两种方向的端点。

初始时在$que1$和$que2$中都加入起点坐标。

每次考虑到一个点$P$（不妨设它是向上的射线），首先看$que2$的队首到$P$的连线是否被队列中后一个元素挡住，如果是，则$next$在$que2$中；否则$next$在$que1$中。

若$next$在$que2$中，则不断判断队首是否被后一个挡住，只要被挡住，就向后移动队首的指针，$next$就是最终的队首。

接着，清空$que1$，并将$next$放入$que1$中。

若$next$在$que1$中，则不断判断$que1$中倒数第二个是否被队尾挡住，只要没被挡住，就向前移动队尾的指针，$next$就是最终的队尾。

最后，无论$next$在哪里，都在$que1$的末尾加入$P$。

至于这种做法的正确性，我也没有找出反例。。。

姑且存之，若有更好的解法，请公开于题解！

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 1000010
using namespace std;
const double PI=acos(-1);
int n,top=0,head[2],tail[2];
struct Point{
	long long x,y;
	Point *next;
	int direction;
	Point operator +(const Point &p)const{return (Point){x+p.x,y+p.y};}
	Point operator -(const Point &p)const{return (Point){x-p.x,y-p.y};}
	long long operator *(const Point &p)const{return x*p.y-y*p.x;}
	bool operator !=(const Point &p)const{return (x!=p.x||y!=p.y);}
	bool operator <(const Point &p)const{return x<p.x;}
	double dis()const{return sqrt(x*x+y*y);}
}s,t,a[MAXN],b[MAXN],*que[2][MAXN];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline bool NotInRange(double div,double x,double y){判断射线方向
	if(div>=-PI/2.0&&div<=PI/2.0)return ((x<div||x>PI/2.0)&&(y<div||y>PI/2.0));
	else if(div<0)return (x>div&&x<PI/2.0&&y>div&&y<PI/2.0);
	else return ((x>div||x<PI/2.0)&&(y>div||y<PI/2.0));
}
void work(){
	double ans=0;
	head[0]=tail[0]=head[1]=tail[1]=1;
	que[0][1]=que[1][1]=&s;
	for(int i=1;i<=n;i++){//维护队列
		int x=a[i].direction,y=x^1;
		if(head[y]<tail[y]&&((a[i]-*que[y][head[y]])*(*que[y][head[y]+1]-*que[y][head[y]]))*(x==1?1:-1)>=0){
			while(head[y]<tail[y]&&((a[i]-*que[y][head[y]])*(*que[y][head[y]+1]-*que[y][head[y]]))*(x==1?1:-1)>=0)head[y]++;
			a[i].next=que[y][head[y]];
			head[x]=tail[x]=tail[x]+1;
			que[x][head[x]]=que[y][head[y]];
		}else{
			while(head[x]<tail[x]&&((a[i]-*que[x][tail[x]-1])*(*que[x][tail[x]]-*que[x][tail[x]-1]))*(x==1?1:-1)>=0)tail[x]--;
			a[i].next=que[x][tail[x]];
		}
		que[x][++tail[x]]=&a[i];
	}
	for(Point *now=&a[n],*last;*now!=s;){//求最小值
		last=now;now=now->next;
		ans+=(*now-*last).dis();
	}
	printf("%.10lf\n",ans);
}
void init(){//读入+预处理
	double u,v,w;
	n=read();t.x=read();t.y=read();
	s.x=s.y=0;
	for(int i=1;i<=n;i++){
		a[i].x=read();a[i].y=read();
		scanf("%lf",&w);
		u=atan2(s.y-a[i].y,s.x-a[i].x);
		v=atan2(t.y-a[i].y,t.x-a[i].x);
		if(NotInRange(w,u,v))a[i].direction=1;//射线向上
		else a[i].direction=0;//射线向下
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(a[i].x<s.x||a[i].x>t.x)continue;//不能往后走
		a[++top]=a[i];
	}
	a[++top]=t;
	n=top;
}
int main(){
	init();
	work();
	return 0;
}

```

---

## 作者：墨舞灵纯 (赞：5)

这个题全网的题解都比较少而且都不太好懂，于是只好自己想，刚了好几天终于做出来了。这里写下一点自己的想法，希望能对其他像我这样找遍全网都看不懂题解的同学有一些帮助。

题意是给定一些射线，求出$S$到$T$的最短路，要求这条最短路不穿过射线。

首先明确，如果我们把射线旋转成正的是没什么问题的；因为如果我们要穿过射线射出的一侧，肯定会撞上去。所以我们忽略掉角度的影响，自动把射线旋成正的。
 
把机关抽象成点后实际上就是把整个图当成个多边形。考虑$i$可以到$j$的条件是$i,j$之间不能有射线遮挡住，可以想到$dp$的思想。但是这个$dp$最少是$O(n^2)$的，于是考虑优化。那我们把射线分成向下射和向上射两种，对于上下的点分别维护，因为你上面的到下面或者下面到上面的的必然会穿过障碍物，所以只能上就走上下就走下。考虑下图这样：（向上射的射线同理）

![](https://img2018.cnblogs.com/i-beta/1747763/202002/1747763-20200229172528072-1134616699.png)

这个可以说明是单调的，于是用单调队列维护即可。看起来思路非常容易，但我想了两天……

代码实现不是很难，大家可以参考其他两篇题解，我觉得那两篇的代码实现讲解方式非常优秀，简明易懂。

就这样啦，还有不懂的评论私信都可。

---

## 作者：_Sein (赞：4)

这道题挺有意思的。

通过两个样例的解释，发现一个规律，都是从一个机关坐标到另外一个机关坐标。

事实上，这也是最优的(臆想一下易得)。

那么现在的问题就是，当前点$i$，如何找到它的决策点$j$($i$从哪里来)。

如果一条射线方向朝上(朝上的定义等下讲)，那么人就不能往上走，因为被挡住了。

方向朝下，一样的道理。

朝上朝下的定义：对于每一个点$i$，以它为极点构造极坐标系，由$i$射向$S$的直线$l_1$的极角$l$，由$i$射向$T$的直线$l_2$的极角$r$，若射线$i$的极角$t$在$l$顺时针到$r$的极角范围内，称射线$i$方向向上，反之方向朝下。

这里有一张向上的图

![捕获.PNG][1]





这个很好理解的，因为不能穿过图中射线$h$到达$T$，不能向上走，再怎么向上走，也走不到$T$。

因此对于每一个射线的方向进行编号，可以分成两类射线:向上或向下。

画个图出来:

![捕获1.PNG][2]

就是这样的(只画了一半)，从左到右给它们编个号，$i,j,k,z$。

$i$直接到$k$的路径不合法，所以通过$j$到$k$。

$j$直接到$z$的路径合法，且比经过$k$的路径短，因此可以在插入$z$时，弹出$k$

那么现在问题变成了当前点$i$，找到最远且合法的决策点。

对于同一种方向的决策点，可以用上述讲的方法进行操作，并用单调队列进行优化。

但是如果出现了这种情况呢？

![!\[\](C:\Users\Administrator\Desktop\新建文件夹 (2)\捕获2.PNG)][3]

同样地，对它们进行编号，$i,j,k$

对于正在插入的$k$，$i$显然不是最优决策，踢掉。

那么对于之后的$z$，$i$是否能成为最优决策呢？

显然不能，$i$与$z$的连线，要么被$j$阻隔，要么被$k$阻隔，因此对于之后的状态，$i$也不可能成为决策点。

貌似就这两种情况。

upd:

其实整个图可以类比成凸壳，向上的线段在大体上看是一个上凸壳，向下的线段在大体上看是一个下凸壳。

如果插入的射线$l$与另一方向的队头的连线被阻断，那么与其同一方向的射线，要么被阻隔，要么因为不是最优决策(距离过长)而被淘汰，在另一方向上总有一条射线会更优。

因此最优决策只会产生在另一方向的射线集合中，因此可以选择清空同一方向的队列，再将最优决策插入到这一队列中。



## 总结一下:

1. 对射线方向进行判断。
2. 弄出所有有用直线出来(在$S,T$之间)
3. 判断当前直线有没有类似第二种情况出现
4. 若没有，直接用单调队列踢队尾
5. 若有，对另一个单调队列踢队首。

代码就不贴了。


  [1]: http://lb2003.top/usr/uploads/2020/03/2614008042.png
  [2]: http://lb2003.top/usr/uploads/2020/03/2668258450.png
  [3]: http://lb2003.top/usr/uploads/2020/03/4029475979.png

---

## 作者：Freopen (赞：4)

[点此获得CSDN版广告体验](https://blog.csdn.net/qq_35950004/article/details/103682582)

题意：平面上有$n$条射线，求从$(0,0)$到$(Tx,Ty)$最短合法路径长度（保证存在合法路径），合法路径是指不经过射线（可以经过不被其他射线覆盖的端点）的，任意时刻走的方向在$x$轴正方向上的投影为正的一条路径。

题解：
首先，可以发现对于每条射线，我们都是从下或从上绕过去，那么可以把每条射线调整为竖直向上或向下。

然后我们想到可以$dp$，发现除了起点和终点，我们只会在射线的端点处拐弯。
可以从左到右$dp$，$i$转移到$j$的条件是中间不能有射线挡。

这东西可以单调队列优化，尽管我们还没有提出来怎么$dp$。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224145135372.png)

我们用两个单调队列来维护，一个维护起点+向上的，一个维护起点+向下的。
那么这个样子显然对于上面的每一点，他的最优决策点就是上面的前面一个点。
下面同理。

如果出现了一边（上或下）的最后3条射线，中间那条无法挡住左右射线的端点互相直达，那么中间右边射线的最优决策点就不可能是中间那条，于是我们弹出中间那条。

但是这样的维护没有考虑不同方向的射线互相遮挡影响的情况。
我们在插入一条射线$i$时（不妨设其方向为向上），先向其射的反方向的队列中做如下判断：反方向的起点（队列中的队首）到这个射线端点的线段是否被队列中第二条射线截断。

如果不是，那么我们可以继续上下相安无事各自继续维护两种方向的单调队列。
如果是，那么我们的最优决策点就不可能是一条方向向上的线段。

这个。在上面的图中臆想一下。

那么之后的方向向上的射线$j$，要么和起点的线段被$i$截断，要么，反方向的起点到$j$的端点的线段一定被队列中第二条射线截断，根据我们上面的断言，它的最优决策点也不可能是一条方向向上的线段。

之后的方向向下的射线，可以想想。

总之我们可以把$i$之前的向上的线段全部从队列中删去。

我们在反方向，考虑如果反方向的起点到$i$的线段被队列中第二条射线截断，则弹出队首。

直到最后我们的队首$k$是可以到$i$的。

那么之前被弹出的队首也可以被论证之后是不能作为最优决策点的。

这时$k$相当于就是我们新起点，把它作为向上的队首，再把$i$作为向上的队列中的第二个就行了。

中间有很多论证过程我都咕咕咕了，网上也没有一篇博客说了这个做法的正确性，所以可能是错的，我只是各位一种感性理解的方式。~~按理说这题和今年CSP-S
D2T2某p题解题方法好像啊，先猜结论后单调队列。。。，提高+警告~~

$\mathrm {AC \ Code}$


```cpp
#include<bits/stdc++.h>
#define LL long long
#define maxn 1000006
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
using namespace std;

int n,m;
struct Point{
	LL x,y;int dir;Point(LL x=0,LL y=0):x(x),y(y){}
	Point operator -(const Point &B)const{ return Point(x-B.x,y-B.y); }
	LL operator *(const Point &B)const{ return x*B.y-y*B.x; }
}a[maxn],b[maxn],S,T;
int dir[maxn],nd[maxn],c[maxn],pre[maxn];
bool cmp(const int &u,const int &v){ return a[u].x<a[v].x; }
int q[2][maxn],ql[2],qr[2];
double sqr(double a){ return a*a; }

int main(){
	scanf("%d%lld%lld",&n,&T.x,&T.y);
	rep(i,1,n){
		double l,r,t;
		scanf("%lld%lld%lf",&a[i].x,&a[i].y,&t);
		l=atan2(S.y-a[i].y,S.x-a[i].x);
		r=atan2(T.y-a[i].y,T.x-a[i].x);
		if(l<r) dir[i]=(l<t&&t<r);//1 dn 0 up
		else dir[i]=!(r<t&&t<l);
		c[i]=i;
	}
	sort(c+1,c+1+n,cmp);
	b[++m]=S;
	for(int i=1;i<=n && a[c[i]].x<T.x;i++)
		if(a[c[i]].x>S.x)
			b[++m]=a[c[i]],nd[m]=dir[c[i]];
	b[++m]=T;
	q[0][0]=q[1][0]=1;
	rep(i,1,m){
		int x=nd[i],&l0=ql[x],&r0=qr[x],&l1=ql[x^1],&r1=qr[x^1],*q0=q[x],*q1=q[x^1],tg=(x?-1:1);
		if(l1<r1 && (b[i]-b[q1[l1]])*(b[q1[l1+1]]-b[q1[l1]])*tg>=0){
			for(;l1<r1 && (b[i]-b[q1[l1]])*(b[q1[l1+1]]-b[q1[l1]])*tg>=0;l1++);
			pre[i]=q1[l1];q0[l0=r0=r0+1]=q1[l1];
		}
		else{
			for(;l0<r0 && (b[i]-b[q0[r0-1]])*(b[q0[r0]]-b[q0[r0-1]])*tg>=0;r0--);
			pre[i]=q0[r0];
		}
		q0[++r0]=i;
	}
	double ans = 0;
	for(int i=m;i!=1;i=pre[i]) ans+=sqrt(sqr(b[i].x-b[pre[i]].x)+sqr(b[i].y-b[pre[i]].y));
	printf("%.10lf\n",ans);
}

```



---

## 作者：PeppaPig_qwq (赞：1)

首先可以注意到最优的路径一定是一条折线，折线连接了一射线的端点。如样例解释中所示。

所以，我们可以列出 DP 方程。定义 $f_i$ 表示从原点到第 $i$ 条射线的端点，不穿过任何一条射线的最短距离。设射线 $i$ 的端点为 $p_i$。转移：$f_i=\min\{f_j+dis_{i,j}\}$ ($i$ 到 $j$ 不经过任何一条射线)。复杂度为 $O(n^3)$，可以得 30pts。

尝试优化转移。首先，对于每一条射线，可以将射线分为两类：朝上或朝下。

由于队长只能往右走，所以转移有单调性。先维护两个队列，一个维护朝上的射线的端点，另一个维护朝下的射线的端点。最开始将原点加入两个队列，将每个射线按照端点的 $x$ 坐标排序。

接下来，到了最难的分讨环节。

第一种情况：

![图一](https://cdn.luogu.com.cn/upload/image_hosting/6uh4lavt.png)

如图，$AF$ 与 $BC$ 和 $DE$ 相交，且 $GF$ 与 $BC$ 不同向。

此时，$F$ 应往 $D$ 连边。这时，$BC$ 这条射线截断了 $AF$。所以，$A$ 不能再更新任何一个点了。将 $BC$ 所在队列的队首弹出，并一直弹出队首直到满足条件。将 $GF$ 所在队列清空，因为这个队列所有射线都不可能更新答案（想想为什么）。

![图二](https://cdn.luogu.com.cn/upload/image_hosting/dq54dmoy.png)

如图，不满足情况一。此时 $BD+EF \ge BF$。所以将 $FG$ 所在队列队尾一直弹出，直到满足情况。

最后，注意将所有端点 $x$ 坐标大于等于终点的 $x$ 坐标的射线和端点 $x$ 坐标小于等于 0 的射线删除。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

const ll Pig = 1e6 + 10;

namespace Geo {
const ld eps = 1e-10, Pi = atan(1) * 4;
ll check(ld a) {
    if (fabs(a) < eps)
        return 0;
    if (a > 0)
        return 1;
    return -1;
}
struct Vector {
    ld x, y;
    Vector() = default;
    Vector(ld _x, ld _y) : x(_x), y(_y) {}
    [[nodiscard]] ld sqr() const { return x * x + y * y; }
    [[nodiscard]] ld len() const { return sqrt(x * x + y * y); }
    Vector operator+(const Vector &a) const { return { x + a.x, y + a.y }; }
    Vector operator*(ld k) const { return { x * k, y * k }; }
    Vector operator*(const Vector &a) const { return { x * a.x - y * a.y, x * a.y + y * a.x }; }
    Vector operator-(const Vector &a) const { return { x - a.x, y - a.y }; }
    Vector operator/(ld k) const { return { x / k, y / k }; }
    [[nodiscard]] Vector conj() const { return { x, -y }; }
    void normalize() {
        ld cur = len();
        x /= cur;
        y /= cur;
    }
    [[nodiscard]] ld angle() const {
        ld cur = atan2(y, x);
        return cur;
    }
    bool operator<(const Vector &a) const {
        return x < a.x;
    }
};

ld dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y; }

ld cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x; }

ld dis(const Vector &a, const Vector &b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

Vector operator/(Vector a, Vector b) { return Vector{ dot(a, b), -cross(a, b) } / a.sqr(); }

ostream &operator<<(ostream &out, Vector a) {
    out << a.x << " " << a.y;
    return out;
}

const Vector nAn = { NAN, NAN };

struct Line {
    Vector x, y;
    Line() = default;
    Line(Vector _x, Vector _y) : x(_x), y(_y) {}
    [[nodiscard]] Vector val() const { return x + y; }
    [[nodiscard]] ld side(Vector a) const { return cross(y, a - x); }
};

Vector inter(Line a, Line b) {
    if (fabs(cross(a.y, b.y)) <= eps) {
        return nAn;
    }
    ld w1 = a.side(b.x), w2 = -a.side(b.val());
    Vector cur = b.x * w2 + b.val() * w1;
    cur = cur / (w1 + w2);
    return cur;
}
bool check_ccf(Vector a) { return (isnan(a.x) or isnan(a.y)); }

Line perp(Vector a, Line b) { return Line{ a, b.y * Vector{ 0, 1 } }; }

ld dist(Vector a, Line b) { return dis(a, inter(perp(a, b), b)); }
}  // namespace Geo
using namespace Geo;

vector<Vector> points;

ld side(Vector a, Vector b, Vector c) { return cross(b - a, c - a); }

ll id[Pig], bck[Pig], n;
vector<Vector> b;
bitset<Pig> di, dir;

bool cmp(Vector a, Vector b) {
    if (check(a.angle() - b.angle()) == 0)
        return a.len() < b.len();
    return a.angle() < b.angle();
}

bool chk(ll i, ll j, ll k, ll r) {
	return (bool)(r * cross(b[i] - b[j], b[k] - b[j]) >= 0);
}

Vector ed, st(0, 0);

void proc() {
    sort(id + 1, id + n + 1, [](ll x, ll y){return points[x].x < points[y].x;});
    b.emplace_back(st);
    ll cnt = 1;
    for (ll i = 1; i <= n; i++) {
    	if (points[id[i]].x >= st.x - eps and points[id[i]].x <= ed.x + eps) {
    		b.emplace_back(points[id[i]]);
    		dir[cnt++] = di[id[i]];                                                            
		}
	}
	b.emplace_back(ed);
    deque<ll> q[2];
    q[0].emplace_back(0);
    q[1].emplace_back(0);
    for (ll i = 1; i < b.size(); i++) {
    	ll res = (dir[i] ? -1 : 1);
    	if (q[dir[i] ^ 1].size() >= 2 and chk(i, q[dir[i] ^ 1][0], q[dir[i] ^ 1][1], res)) {
    		while (q[dir[i] ^ 1].size() >= 2 and chk(i, q[dir[i] ^ 1][0], q[dir[i] ^ 1][1], res))
    			q[dir[i] ^ 1].pop_front();
    		bck[i] = q[dir[i] ^ 1].front();
    		q[dir[i]].clear();
    		q[dir[i]].emplace_back(bck[i]);
		} else {
			while (q[dir[i]].size() >= 2 and chk(i, q[dir[i]][q[dir[i]].size() - 2], q[dir[i]][q[dir[i]].size() - 1], res))
				q[dir[i]].pop_back();
			bck[i] = q[dir[i]].back();
		}
		q[dir[i]].emplace_back(i);
		/*cout << "\nNow proc-ing line " << i << ". Queue 1:\n";
		for (ll i : q[0])
			cout << i << " ";
		cout << "\nQueue2:\n";
		for (ll i : q[1])
			cout << i << " ";*/
	}
	/*cout << "\n";
	for (ll i = 1; i < b.size(); i++)
		cout << bck[i] << ' ';
	cout << "\n";*/
	ll c = b.size() - 1;
	ld ans = 0;
	//cout << b[c] << "\n";
	while (c) {
		ans += dis(b[c], b[bck[c]]);
		c = bck[c];
		//cout << b[c] << "\n";
	}
	cout << ans;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.setf(ios::fixed);
    cout.precision(20);
    points.clear();
    cin >> n;
    cin >> ed.x >> ed.y;
    points.emplace_back(st);
    for (ll i = 1; i <= n; i++) {
        Vector cur;
        ld theta;
        cin >> cur.x >> cur.y >> theta;
        Vector a = (st - cur), b = (ed - cur);
        ld l = a.angle(), r = b.angle();
        points.emplace_back(cur);
        di[i] = (l < r) ? (l <= theta and theta <= r) : (!(r <= theta and theta <= l));
        id[i] = i;
    }
    points.emplace_back(ed);
    proc();
}
/*
3 5 0
2 2 -1.571
3 -1 -1.571
4 1 1.571
*/
```

---

## 作者：Otomachi_Una_ (赞：0)

首先题目即你要从平面上的 $S$ 到达 $T$。这期间不能经过任何射线，且方向和 $x$ 的夹角必须为正。

首先你发现我们的轨迹肯定是个折线，且折线的折点一定是某个射线的起点。由于 $x$ 有单调性，于是可以直接 dp，复杂度 $O(n^3)$。

我们来抛出一个重磅结论。我们可以**把所有射线变成向垂直向上、向下而不影响答案**。这是因为考虑对于每条射线 $Pl$ 而言，你穿过 $x=P(x)$ 之后一定是向终点一方行走。那么我们可以对每个答案掰直，这时候**答案不会变大**。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rvrg5g84.png)

上图展示了几种掰直的例子。

然后我们来说明掰直后的路径，在掰直前仍然合法。

首先我们根据答案路径的每个折点是上凸还是下凸我们是可以知道这个射线是向上还是向下。

![](https://cdn.luogu.com.cn/upload/image_hosting/lccvasmm.png)

首先我们说明折线上的点的原射线不会和答案路径有交。反之，不妨设相交射线在原路径上上凸。

![](https://cdn.luogu.com.cn/upload/image_hosting/052ibl4f.png)

容易发现肯定和至少一个向上的射线有相交。而这时 $S$ 在原问题上是不可能到达 $T$ 的（不可能穿过绿色屏障）于是矛盾。

对折线外的点道理是相同的。都可以推导出原问题无解。

然后考虑只有上，下的射线如何计算答案。我们维护每个点的最优转移点。假设我们需要计算 $P$ 点，不妨其射线向下。

如果只看向下的点，那么肯定就形如一个凸包。我们用两个双端队列来维护向上、向下的两个凸包。

![](https://cdn.luogu.com.cn/upload/image_hosting/cfjage2r.png)

但是这时可能有些问题，比如这个最优转移点实际上被某个向上的射线拦截了。

![](https://cdn.luogu.com.cn/upload/image_hosting/7mj2wgkf.png)

那么此时，$P$ 不可能和向下的射线起点转移。把向下射线的凸包清空。然后不断弹出向上射线的队首使得队首和 $P$ 连线不和任何向上的射线有交（实际上如果有交肯定是队首后一个点）。然后此时 $P$ 肯定是从这个向上的凸包的队首进行转移。其余向下的射线也必须经过这个点。我们把这个点当作新的起点即可。

除排序复杂度是 $O(n)$ 的。这也太牛了。

---


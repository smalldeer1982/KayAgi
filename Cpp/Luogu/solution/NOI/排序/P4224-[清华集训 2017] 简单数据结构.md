# [清华集训 2017] 简单数据结构

## 题目描述

参加完IOI2018之后就是姚班面试。而你，由于讨厌物理、并且想成为乔布斯一样的创业家，被成功踢回贵系。

转眼，时间的指针被指向2019，大二，12月初，考试周。

你早听学长说，数据结构期中考很难，对竞赛生不友好，集训队选手做不完卷子。

你冷笑。哼，堂堂国际金，这点难度的考试算什么。

两小时，你看完习题解析前五章所有内容，并且倒背如流；

一小时，你看了500页的讲义，并且记忆犹新；

十分钟，你骑车到考场，自信的你只带了一把水笔，虽然考试让带资料；

现在，摊开传说中神级卷子，你定神一看——

给出一个长度为 $N$ 的序列 $A_1,A_2,\cdots,A_N$，如果 $A$ 中的一个子序列         $B_1,B_2,\cdots,B_M$，满足条件：

$1 \le M \le N$

∀$1 \le i \le M$，$B_i$|$B_{i+1}$

那么称 $B$ 为 $A$ 的上升倍数子序列。

现在有一个长度为 $N$ 的序列 $A$ 被初始化为 $A_{1},A_{2},\cdots,A_{N}$，以及 $Q$ 次对序列 $A$ 的操作。此处要求实现如下四种操作：

0 x：在序列 $A$ 的最左端插入一个数字 $x$；

1 x：在序列 $A$ 的最右端插入一个数字 $x$；

2：移除序列 $A$ 最左端的一个数字；

3：移除序列 $A$ 最右端的一个数字；

在初始化序列 $A$ 和每次操作之后，请计算此时序列 $A$ 中最长上升倍数子序列的长度 $\mathrm{MaxLen}$，以及所有长度为 $\mathrm{MaxLen}$ 的上升倍数子序列的不同的开头数 $\mathrm{Cnt}$，输出 $\mathrm{MaxLen}$ 和 $\mathrm{Cnt}$。

为了大幅度降低题目难度，保证在任意时刻序列 $A$ 非空，其中的元素互不相等，并且均为 $1\sim M$ 之间的正整数；同一个数字最多只会被插入 $C$ 次。


## 说明/提示

**样例解释**

表格中以//隔开不同开头的最长上升子序列。

 ![](https://cdn.luogu.com.cn/upload/pic/13370.png) 

对于所有的数据，有 $1\le N \le 10^5$，$N\le M \le 10^6$，$0\le Q \le 10^5$，$1\le A_i\le M$，$C=10$。


下表展示了某些数据点的一些特殊约束，其中只有1表示只有形如1 x的操作，其他表述同理。

![](https://cdn.luogu.com.cn/upload/pic/13371.png)

后记

“奋战两小时，考个四五十”的表情包占领了你的朋友圈：

    “啊，感觉自己人生完全了”
    “但愿……我真的能拿到四五十”
    “我考完了……考完了……完了”
    “曾经以为是开玩笑的，原来我还是naïve了”

你冷笑。提前半小时交卷，你自然觉得，数据结构，满分，正常。

## 样例 #1

### 输入

```
5 10 10
1 2 5 9 10
2
1 7
3
3
0 8
3
2
1 8
3
0 3```

### 输出

```
3 1
2 2
2 2
2 2
1 3
1 4
1 3
1 2
2 1
1 2
1 3```

# 题解

## 作者：s_r_f (赞：23)

这是清华集训某天的T1吧。~~某神犇(反正不是我):T1送分的啊，暴力题啊~~

这题。。。。

题意:  
每次在数列A的头/尾做一次操作(加数/删数)，每次求出"上升倍数子序列"的maxlen和cntfront.

## 一、忽略复杂度问题,先来想一个DP

由于我们求的是cntfront,所以状态当然要设计成:    

```cpp
  f[i]表示以i为开头的maxlen
  g[i][j]表示以i为开头,len = j的"上升倍数子序列"的nxt的个数。
  //实际上是 j > i 且 f[j] == j-1 的f[j]个数。
  //why?
  //主要是因为直接维护nxt非常麻烦,但是我们的dp中只要保留最优的转移方式。
  //而且如果一个nxt改了,复杂度直接就成了O(ans),
  //而新的状态是O(1)
```

每次操作之后dp.  
~~(qty神犇:小数据dp什么g[][]啊,直接f[]就行了啊)~~    
~~(但是g[][]是标算啊,先写上不然好烦啊)~~  
这个转移很奇妙,每次枚举倍数/约数转移,跑的贼快！  
于是我们就得到了n,q <= 1000 的 25pts!  (连~~松一松~~都不要)

------------

## 二、冷静分析

其实一开始第一眼看就觉得**不可做**,但是。。。题目条件好多啊！

~~之前的部分分一条性质都没用诶~~

我们冷静分析一下题目条件。 


------------

性质1.数列中的数有值域限制。  
性质2.数列中没有相同的数值。   
性质3.相同的数值只会被插入/删除不超过10次。

------------

因为数列中没有相同的数值,  
这个**上升倍数子序列**的A[i] >= A[i-1] * 2   
因为A[i] <= 1000000, 2的20次方 = 1048576 > 1000000.  
所以答案一定 < 20.
~~也就是说g数组不会爆空间！~~

再看看那个性质3。  
枚举所有A[i]的倍数dp?  

复杂度 = 10 × O(n + n/2 + n/3 + .. + 1)  
= 10 × O(n) × O(1+1/2+1/3+1/4+...+1/n)  
= 10 × O(n * H(n)) (H(n)表示调和级数)  

≈ O(nlogn),比nlogn略大，~~不过暴力题,std肯定也得能过啊,否则...~~

枚举所有A[i]的倍数dp是10 * O(nlogn)的！  
枚举所有A[i]的约数？O(nsqrt(n)).


好了,言归正传考虑每个操作吧。  

首先我们定义一些变量:

```
f和g:不说了

fcnt[i] 表示f[j] = i的个数

pos[i] 表示i的位置(存在时唯一,不存在时设为0)
```

#### 1、在开头add(x)
  枚举x的所有倍数,直接求出x的g数组。  
  别忘了更新fcnt[],和pos[]。
  ```cpp
  void Add_front(int x){
	int i;
	--l,a[l] = x,pos[x] = l;
	memset(g[l],0,sizeof(g[l])),f[l] = g[l][1] = 1;
	for (i = x<<1; i <= m; i += x) if (pos[i]) ++g[l][f[pos[i]] + 1];
	for (i = MAX - 1; i ; --i) if (g[l][i]) {f[l] = i,++fcnt[f[l]]; return;}
  }
  ```
#### 2、开头del()
   更新fcnt[]和pos[],直接把a[l]删除。
   ```cpp
   void Del_front(){ --fcnt[f[l]],pos[a[l]] = 0,++l; }
   
   ```
 
#### 3、结尾add(x) / del()
	重点是讨论他们对于数列中a[r]的约数的dp的影响。
    
    O(sqrt(n))枚举约数,然后从大到小更新。
    
   upd:修改前应把f[]的原始值存进一个oldf[i]里，然后比对新的f[i]并决定是否修改。
   
   细节说的比较多了,再没办法就只能看~~(copy)~~代码了:
   ```cpp
    
	void DP_Add(int x,int ff){
		int i;
		++fcnt[ff];
		for (i = 1; i <= Sqrt[x]; ++i) if (!(x % i)){
			if (pos[i] < pos[x]) ++g[pos[i]][ff+1];
			if (i * i != x && pos[x/i] < pos[x] && pos[x/i]) ++g[pos[x/i]][ff+1];
		}
	}
	void DP_Dev(int x,int ff){
		int i;
		--fcnt[ff];
		for (i = 1; i <= Sqrt[x]; ++i) if (!(x % i)){
			if (pos[i] && pos[i] < pos[x]) --g[pos[i]][ff+1];
			if (i * i != x && pos[x/i] < pos[x] && pos[x/i]) --g[pos[x/i]][ff+1];
		}
	}

    
   ```
   
   
好了,我们AC了本题！  
放一下我丑陋的代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(int x){
    int k = 0;char put[40];
    if (!x) putchar('0');
    if (x < 0) putchar('-'),x = -x;
    while (x)  put[++k] = (x % 10) + '0',x /= 10;
    while (k)  putchar(put[k]),--k;
}

const int N = 100005 << 2,M = 1000005,Q = 100005,MAX = 21;

int n,m,q;
int a[N],l,r;

int fcnt[N]; 
int pos[M],f[N],g[N][MAX];

void Add_front(int x){
	int i;
	--l,a[l] = x,pos[x] = l;
	memset(g[l],0,sizeof(g[l])),f[l] = g[l][1] = 1;
	for (i = x<<1; i <= m; i += x) if (pos[i]) ++g[l][f[pos[i]] + 1];
	for (i = MAX - 1; i ; --i) if (g[l][i]) {f[l] = i,++fcnt[f[l]]; return;}
}
void Del_front(){ --fcnt[f[l]],pos[a[l]] = 0,++l; }

int Sqrt[M];
void DP_Add(int x,int ff){
	int i;
	++fcnt[ff];
	for (i = 1; i <= Sqrt[x]; ++i) if (!(x % i)){
		if (pos[i] < pos[x]) ++g[pos[i]][ff+1];
		if (i * i != x && pos[x/i] < pos[x] && pos[x/i]) ++g[pos[x/i]][ff+1];
	}
}
void DP_Dev(int x,int ff){
	int i;
	--fcnt[ff];
	for (i = 1; i <= Sqrt[x]; ++i) if (!(x % i)){
		if (pos[i] && pos[i] < pos[x]) --g[pos[i]][ff+1];
		if (i * i != x && pos[x/i] < pos[x] && pos[x/i]) --g[pos[x/i]][ff+1];
	}
}

int c[N],len,oldf[N];

void Add_back(int x){
	++r,a[r] = x,pos[x] = r;
	memset(g[r],0,sizeof(g[r])),f[r] = g[r][1] = 1,DP_Add(x,f[r]);
	
	int i,j;
	len = 0;
	for (i = 1; i <= Sqrt[x]; ++i) if (!(x%i)) ++len,c[len] = i,oldf[pos[i]] = f[pos[i]];
	for (i = Sqrt[x]; i >= 1; --i) if (i * i != x && !(x%i)) ++len,c[len] = x/i,oldf[pos[x/i]] = f[pos[x/i]];
	
	int id;
	for (i = len; i >= 1; --i) if (id = pos[c[i]]){
		for (j = MAX-1; j >= 0; --j) if (g[id][j]) {f[id] = j; break;}
		if (f[id] ^ oldf[id]) DP_Dev(c[i],oldf[id]),DP_Add(c[i],f[id]);
	}
}

void Del_back(){
	int i,j,x = a[r];
	
	DP_Dev(x,f[r]);
	len = 0;
	for (i = 1; i <= Sqrt[x]; ++i) if (!(x%i)) ++len,c[len] = i,oldf[pos[i]] = f[pos[i]];
	for (i = Sqrt[x]; i >= 1; --i) if (i * i != x && !(x%i)) ++len,c[len] = x/i,oldf[pos[x/i]] = f[pos[x/i]];
	int id;
	for (i = len; i >= 1; --i) if (id = pos[c[i]]){
		for (j = MAX-1; j >= 0; --j) if (g[id][j]) {f[id] = j; break;}
		if (f[id] ^ oldf[id]) DP_Dev(c[i],oldf[id]),DP_Add(c[i],f[id]);
	}
	f[r] = 0,pos[x] = 0,--r;
}

int b[N];
void Init(int n){
	int i;
	for (i = 1; i <= n; ++i) b[i] = read();
	for (i = 1; i <= n; ++i) Add_front(b[n-i+1]);
} 

int mxlen,_i;
void Answer(){
	for (_i = MAX - 1; _i ; --_i)
		if (fcnt[_i]) {write(_i),putchar(' '),write(fcnt[_i]),putchar('\n'); return;}
}

int main(){
	int i,op,x;
	n = read(),m = read(),q = read(),l = n + q + 50,r = l-1;
	for (i = 1; i <= m; ++i){
		Sqrt[i] = min(i,(int)sqrt(i) + 1);
		if (Sqrt[i] * Sqrt[i] > i) --Sqrt[i];
	}
	Init(n),Answer();
	while (q--){
		op = read();
		if (!op) x = read(),Add_front(x);
		else if (!(op^1)) x = read(),Add_back(x);
		else if (!(op^2)) Del_front();
		else Del_back();
		Answer();
	}
    return 0;
}
```

# 写在后面
看来这题还真的是个技巧题啊。。。  
不过其实学过数论的同学发现整除和值域限制应该就很~~简单~~明显了吧。  
~~所以说是个暴力题。~~  
还是要再多多积累做题技巧啊。  

题解完结。。  

---

## 作者：muller (赞：12)

我觉得这题比hello world还要简单吧！~~不是秒切~~

不就分情况讨论！然后在i*i
范围内加点套路即可！

我觉得首先

为了大幅度降低题目难度，保证在任意时刻序列 AA 非空，其中的元素互不相等，并且均为 1\sim M1∼M 之间的正整数；同一个数字最多只会被插入 C 次。

同一个数字最多只会被插入 C 次。这个条件特别重要，然后我们瞎搞！

模拟一下即可！就像用队列一样吧，只是要考虑对前后的影响！

注意最好卡点常，否则可能GG，反正我觉得这可以直接这么做，我A了吧？？？
当然byf大佬好像直接加上树套树？（不懂）

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005, K = 25;
int n, m, q, f[N], ans[K], cnt[N][K], l, r, tot, a[N], val[N], pos[N], old[N];
void print() {int i; for (i = K - 1; ~i; --i) if (ans[i]) {printf("%d %d\n",i, ans[i]); return;}}
void upd(int x, int v, int d) {
	int i; ans[v] += d;
	for (i = 1; i * i <= x; ++i)
		if (!(x % i)) {
			if (pos[i] < pos[x]) cnt[i][v + 1] += d;
			if (i * i < x && pos[x / i] < pos[x]) cnt[x / i][v + 1] += d;
		}
}
void solve(int x,int y) {
	int i, j, p;
	for (i = 1; i * i <= x; ++i)
		if (!(x % i)) {
			val[++tot] = i, old[i] = f[i];
			if (i * i < x) val[++tot] = x / i, old[x / i] = f[x / i];
		}
	sort(val + 1, val + tot + 1), upd(x, f[x], y);
	for (i = tot - 1; i; --i) {
		for (j = K - 1; j; --j) if (cnt[p = val[i]][j]) {f[p] = j; break;}
		if (!pos[p] || f[p] == old[p]) continue;
		upd(p, old[p], -1), upd(p, f[p], 1);
	}
}
void push_front(int x) {
	int i; tot = 0, memset(cnt[x], 0, sizeof(cnt[x]));
	f[x] = cnt[x][1] = 1, a[pos[x] = --l] = x;
	for (i = 2 * x; i <= m; i += x) if (pos[i]) ++cnt[x][f[i] + 1];
	for (i = K - 1; i; --i) if (cnt[x][i]) {++ans[f[x] = i]; break;}
}
void push_back(int x) {memset(cnt[x], 0, sizeof(cnt[x])); f[x] = cnt[x][1] = 1, a[pos[x] = ++r] = x, tot = 0, solve(x, 1);}
void pop_front(int x) {--ans[f[x]], pos[x] = 0;}
void pop_back(int x) {tot = 0, solve(x, -1), pos[x] = 0;}
int main() {
	int i, x; scanf("%d %d %d", &n, &m, &q); l = n + q; r = l - 1;
	for (i = 1; i <= n; ++i) scanf("%d", &x), push_back(x);
	print();
	for (i = 1; i <= q; print(), ++i) {
		int opt; scanf("%d", &opt);
		if (opt == 0) scanf("%d", &x), push_front(x);
		if (opt == 1) scanf("%d", &x), push_back(x);
		if (opt == 2) pop_front(a[l++]);
		if (opt == 3) pop_back(a[r--]);
	}
	return 0;
}

```

---

## 作者：_Arahc_ (赞：7)


很有意思的一道题。但是评黑是不是有点过了？

## 题意

> 给定一个双端队列，每次对双端队列操作（左右插入、删除）时，求出序列的最长上升倍数子序列长度，和以多少个位置为开头可以得到一个最长上升倍数子序列。
>
> 最长上升倍数子序列定义：序列的后一项是前一项的倍数。
>
> $n,q\leqslant 10^5$。数据满足如下性质：
>
> + 任意时刻双端队列内只有 $[1,m]$ 的数（$m\leqslant 10^6$）。
> + 任意时刻队列内数字互不相同。
> + 同一个数字最多只会被插入 $10$ 次。

众所周知，如果一个题目保证数据满足一些不寻常的性质，通常说明如果不满足这个性质，本题将不可做~~或出题人不会~~。

## 分析

### 暴力

先从暴力开始，设 $f_i$ 表示从 $i$ 开头能得到的最长上升子序列长度，仿照 LIS，枚举倍数转移即可。枚举倍数时，考虑到队列内相同数字只有一个，开个 $pos$ 数组标记每个数位置快速定位。

```cpp
inline void DP(){
    memset(pos,-1,sizeof(pos));
    int n=q.size(),mx=1,R=1,cnt=0;
    for(register int i=0;i<n;++i){
        R=max(R,q[i]);
        pos[q[i]]=i,f[i]=1;
    }
    for(register int i=n-2;i>=0;--i){
        for(register int j=q[i]*2;j<=R;j+=q[i])
            if(pos[j]>i)
                f[i]=max(f[i],f[pos[j]]+1);
        mx=max(mx,f[i]);
    }
    for(register int i=0;i<n;++i)
        cnt+=(f[i]==mx);
    write(mx),putchar(' '),write(cnt),putchar('\n');
}
```

$pos$ 可以在修改的时候动态维护，因此关键在 $f$。

### 正解

+ 队列内数字互不相同，且任意时刻队列内只有 $[1,m]$ 的数。

  所以最长上升倍数子序列长度不超过 $\log m$，开数组 $g_i$ 表示 $f_j=i$ 的 $j$ 的个数，单次查询答案就找最大的 $i$ 使 $g_i\neq 0$，复杂度 $\log m$。

+ 同一个数字只会被插入 $10$ 次，而队列内数字互不同，所以一个数最多只会被删除 $11$ 次。

  所以插入和删除的复杂度有些大，撑不起 $n$ 次插/删。假设已经求得一个最长上升倍数子序列，右侧插入一个数时，如果暴力枚举约数算影响，枚举约数复杂度是 $\sqrt{m}$ 的。如果影响计算能很快，单次操作就是 $\sqrt{m}$。

  这貌似与 $10$ 没什么关系，但是考虑如果从左侧插入，就要枚举这个数的倍数了，枚举一个数的倍数是 $\log m$，每个数最多出现 $10$ 次，单次操作就是 $10\log m$。

有了一个很模糊的认识，再看每个操作：

+ 左侧插入：

  和 LIS 类似的转移，枚举这个数的倍数，如果在队列里，$f_i\leftarrow \max\{f_j+1\}$。

+ 左侧删除：

  因为转移是倒序的，左边的点不对右边的点算贡献，直接删除即可。

+ 右侧插入：

  枚举约数，并“尝试”对序列造成影响（让这个序列后面接在这个数上），最后比较影响前后 $f$ 变大还是变小，取新 $f_i$ 和旧 $f_i$ 较大的一个。

  具体而言，开辅助数组 $h_{i,j}$ 表示以 $i$ 开头，长度为 $j$ 的子序列有多少个，因为长度小于 $20$，所以也可以 $\log m$ 用 $h$ 数组推得新 $f$ 数组。

+ 右侧删除：

  同理右侧插入。

左侧相关复杂度为 $\log m$（或 $\operatorname{O}(1)$）；右侧相关复杂度为插入的数的所有约数的约数个数和，这个复杂度不太好估，但打表可得是恰好能接受的；查询复杂度为 $\log m$，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1000006;
inline int read(){
    int x=0;bool w=0;char c=getchar();
    while(c<'0' || c>'9') w|=c=='-',c=getchar();
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
}

int n,m,Q;

struct Deque{
    int l,r,q[max_n*3];
    int f[max_n*3],g[22],h[max_n*3][22],pos[max_n];
    Deque(){l=1000006,r=1000005;}
    inline void ask(){
        for(register int i=21;i>=0;--i)
            if(g[i]){
                write(i),putchar(' '),write(g[i]),putchar('\n');
                break;
            }
    }
    inline void push_front(int x){
        q[--l]=x,pos[x]=l;
        memset(h[l],0,sizeof(h[l])),f[l]=h[l][1]=1;
        for(register int i=x*2;i<=m;i+=x)
            if(pos[i]>l){
                ++h[l][f[pos[i]]+1],
                f[l]=max(f[l],f[pos[i]]+1);
            }
        ++g[f[l]];
    }
    inline void pop_front(){
        --g[f[l]],pos[q[l++]]=0;
    }
    inline void upd(int x,int val,int dat){
        g[val]+=dat;
        for(register int i=1;i*i<=x;++i){
            if(x%i!=0) continue;
            if(pos[i]<pos[x])
                h[pos[i]][val+1]+=dat;
            if(i*i<x && pos[x/i] && pos[x/i]<pos[x])
                h[pos[x/i]][val+1]+=dat;
        }
    }
    int tmp[max_n*3],a[max_n*3],tot;
    inline void push(int x){
        tot=0;
        for(register int i=1;i*i<=x;++i){
            if(x%i!=0 || !pos[i]) continue;
            tmp[pos[i]]=f[pos[i]],
            a[++tot]=i;
        }
        for(register int i=sqrt(x);i>=1;--i){
            if(x%i!=0 || !pos[x/i]) continue;
            if(i*i<x && pos[x/i]){
                tmp[pos[x/i]]=f[pos[x/i]];
                a[++tot]=x/i;
            }
        }
    }
    inline void push_back(int x){
        q[++r]=x,pos[x]=r;
        memset(h[r],0,sizeof(h[r])),f[r]=h[r][1]=1;
        upd(x,f[r],1),push(x);
        for(register int i=tot;i>=1;--i) if(pos[a[i]]){
            for(register int j=21;j>=0;--j)
                if(h[pos[a[i]]][j]){
                    f[pos[a[i]]]=j;
                    break;
                }
            if(f[pos[a[i]]]!=tmp[pos[a[i]]])
                upd(a[i],tmp[pos[a[i]]],-1),
                upd(a[i],f[pos[a[i]]],1);
        }
    }
    inline void pop_back(){
        upd(q[r],f[r],-1),push(q[r]);
        for(register int i=tot;i>=1;--i) if(pos[a[i]]){
            for(register int j=21;j>=0;--j)
                if(h[pos[a[i]]][j]){
                    f[pos[a[i]]]=j;
                    break;
                }
            if(f[pos[a[i]]]!=tmp[pos[a[i]]])
                upd(a[i],tmp[pos[a[i]]],-1),
                upd(a[i],f[pos[a[i]]],1);
        }
        pos[q[r]]=0,f[r--]=0;
    }
    inline void init(){
        for(register int i=1;i<=n;++i)
            push_back(read());
        ask();
    }
}q;

signed main(){
    n=read(),m=read(),Q=read(),q.init();
    while(Q--){
        int op=read();
        if(op==0)
            q.push_front(read());
        if(op==1)
            q.push_back(read());
        if(op==2)
            q.pop_front();
        if(op==3)
            q.pop_back();
        q.ask();
    }
    return 0;
}
```



---

## 作者：_ReClouds_ (赞：7)

（本文是基于队爷 @s_r_f 所写题解的完善和补充）

可以发现，如果我们暴力地枚举一个数的因数或倍数，时间复杂度是可接受的。

对于前者，单次复杂度为 $\mathcal{O}(\sqrt n)$；对于后者，由于题目保证了 $C \leq 10$，所以单次的均摊复杂度应为 $\mathcal{O}(\ln n)$。

所以，我们可以考虑直接模拟题意中的操作。

------

首先，我们设 $f_i$ 为以 $i$ 开头的最长上升倍数子序列的长度。同时，为了方便统计答案的第二项，我们再设一个 $fcnt_i$，表示有多少个 $j$ 满足 $f_j = i$。

有了以上两个数组，我们就可以从小到大枚举 $i$，当 $fcnt_i$ 不为 $0$ 时，我们就同时找到了答案的第一项和第二项，一举两得。

没错！这样做的理论复杂度是 $\mathcal{O}(nq)$ 的，会超时。但这真的是实际的复杂度吗？

注意题目中有这样一句话：保证在任意时刻序列 $A$ 非空，**其中的元素互不相等**。

也就是说，就算是最坏的情况，这个子序列的长度也是不超过 $\mathcal{O}(\log_2 m)$ 的，所以上述做法的实际复杂度为：$\mathcal{O}(q\log_2m)$。

------

解决完了询问，我们再看看四个操作中哪个最好想。

显然是在序列左端进行的两个操作。究其原因，我们先来推推 $f_i$ 的转移方程式：

考虑枚举 $i$ 的倍数 $j$，如果 $j$ 存在，设 $j$ 的位置为 $pos_j$，则有：
$$
f_i = \max_{i | j, pos_j > 0}\{f_j + 1\}
$$
所以，在左端插入一个数，我们只需要枚举它的倍数转移即可。前面提到了，单次均摊复杂度为 $\mathcal{O}(\ln n)$。

而在左端删除一个数则更加简单，因为最左端的数不会对右侧的任何位置造成任何贡献，所以让它平静地离队即可。单次复杂度 $\mathcal{O}(1)$。

------

我们再来考虑序列右端的两个操作。实际上，它们应当是大同小异的，都是枚举因数计算贡献，如果插入则把贡献也加入进去，否则把贡献删除。

现在我们需要完成的操作是：加入或者删除一个位置的贡献。

先放上代码：（$val$ 表示需要加入或者删除贡献的数，$tmpf$ 表示的是需要加入或删除的贡献）

```cpp
inline void Modify(int val, int tmpf)
{
	++fcnt[tmpf];
	for(register int i = 1; i <= Sqrt[val]; i++) if(val % i == 0)
	{
		if(pos[i] && pos[i] < pos[val]) ++g[pos[i]][tmpf + 1];
		if(i * i != val && pos[val / i] && pos[val / i] < pos[val]) ++g[pos[val / i]][tmpf + 1];
	}
	return;
}

inline void Delete(int val, int tmpf)
{
	--fcnt[tmpf];
	for(register int i = 1; i <= Sqrt[val]; i++) if(val % i == 0)
	{
		if(pos[i] && pos[i] < pos[val]) --g[pos[i]][tmpf + 1];
		if(i * i != val && pos[val / i] && pos[val / i] < pos[val]) --g[pos[val / i]][tmpf + 1];
	}
	return;
}
```

我们发现，为了方便维护，代码中加设了 $g_{i, j}$ 表示以 $i$ 开头，长度为 $j$ 的最长上升倍数子序列有多个。（这个在前面左端插入的操作中也需要维护）

这个数组的作用类似 $fcnt$，是为了方便我们在修改贡献后，找到 $f$ 数组最终被修改成了什么样子。

有了这两个函数，我们就可以先把 $val$ 的贡献加入，然后枚举所有 $val$ 的因数，把所有修改过的位置更新即可。

具体实现的时候，对于没有修改过的位置可以选择不修改，可以节省一点常数。

右侧的删除与加入几乎一样，不过应当先删去而非加上 $val$ 的贡献。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>

#define MAXN 300005
#define MAXM 1000001
#define MAXLOG 21

using namespace std;

int n, m, q, a[MAXN], pos[MAXM], f[MAXN], oldf[MAXN], fcnt[MAXLOG], g[MAXN][MAXLOG], Sqrt[MAXM], len, seq[MAXM];

namespace Deque
{
	int l, r, a[MAXN];
		
	inline void Prework() { return r = n + q, l = n + q + 1, void(); } 
	
	inline void Modify(int val, int tmpf)	//加入贡献
	{
		++fcnt[tmpf];
		for(register int i = 1; i <= Sqrt[val]; i++) if(val % i == 0)
		{
			if(pos[i] && pos[i] < pos[val]) ++g[pos[i]][tmpf + 1];
			if(i * i != val && pos[val / i] && pos[val / i] < pos[val]) ++g[pos[val / i]][tmpf + 1];
		}
		return;
	}

	inline void Delete(int val, int tmpf)	//删除贡献
	{
		--fcnt[tmpf];
		for(register int i = 1; i <= Sqrt[val]; i++) if(val % i == 0)
		{
			if(pos[i] && pos[i] < pos[val]) --g[pos[i]][tmpf + 1];
			if(i * i != val && pos[val / i] && pos[val / i] < pos[val]) --g[pos[val / i]][tmpf + 1];
		}
		return;
	}

	inline void Push_Front(int val)
	{
		a[--l] = val, pos[val] = l;
		memset(g[l], 0, sizeof g[l]);
		f[l] = g[l][1] = 1;
		for(register int i = val * 2; i < MAXM; i += val) if(pos[i]) ++g[l][f[pos[i]] + 1];
		for(register int i = MAXLOG - 1; i >= 0; i--) if(g[l][i]) { ++fcnt[f[l] = i]; break; }
		return;
	}

	inline void Push_Back(int val)
	{
		a[++r] = val, pos[val] = r;
		memset(g[r], 0, sizeof g[r]);
		f[r] = g[r][1] = 1;
		Modify(val, f[r]);
		len = 0;
		for(register int i = 1; i <= Sqrt[val]; i++) if(val % i == 0) seq[++len] = i, oldf[pos[i]] = f[pos[i]];
		for(register int i = Sqrt[val]; i >= 1; i--) if(i * i != val && val % i == 0) seq[++len] = val / i, oldf[pos[val / i]] = f[pos[val / i]];
		int id;
		for(register int i = len; i >= 1; i--) if(id = pos[seq[i]])
		{
			for(register int j = MAXLOG - 1; j >= 1; j--) if(g[id][j]) { f[id] = j; break; }
			if(f[id] != oldf[id]) Delete(seq[i], oldf[id]), Modify(seq[i], f[id]);
		}
		return;
	}
	
	inline void Pop_Front()
	{
		--fcnt[f[l]], f[l] = 0, pos[a[l++]] = 0;
		return;
	}
	
	inline void Pop_Back()
	{
		int val = a[r];
		Delete(val, f[r]);
		len = 0;
		for(register int i = 1; i <= Sqrt[val]; i++) if(val % i == 0) seq[++len] = i, oldf[pos[i]] = f[pos[i]];
		for(register int i = Sqrt[val]; i >= 1; i--) if(i * i != val && val % i == 0) seq[++len] = val / i, oldf[pos[val / i]] = f[pos[val / i]];
		int id;
		for(register int i = len; i >= 1; i--) if(id = pos[seq[i]])
		{
			for(register int j = MAXLOG - 1; j >= 1; j--) if(g[id][j]) { f[id] = j; break; }
			if(f[id] != oldf[id]) Delete(seq[i], oldf[id]), Modify(seq[i], f[id]);
		}
		f[r] = 0, pos[val] = 0, --r;
		return;
	}

	inline void Solve()	//求解答案
	{
		int ans = 0;
		for(register int i = MAXLOG - 1; i >= 1; i--) if(fcnt[i]) { ans = i; break; }
		printf("%d %d\n", ans, fcnt[ans]);
		return;		
	}
}

namespace dq = Deque;

int main()
{
	#ifdef FILE
		freopen("Input.in", "r", stdin);
	#endif
	scanf("%d%d%d", &n, &m, &q);
	dq :: Prework();
	for(register int i = 1; i <= n; i++) scanf("%d", a + i);
	for(register int i = n; i >= 1; i--) dq :: Push_Front(a[i]);	//当然也可以用 Push_Back，不过这里会省下一些常数
	for(register int i = 1; i <= m; i++) { Sqrt[i] = min(i, (int)sqrt(i) + 1); if(Sqrt[i] * Sqrt[i] > i) --Sqrt[i]; }
	dq :: Solve();
	while(q--)
	{
		int opt; scanf("%d", &opt);
		if(opt == 0) { int val; scanf("%d", &val); dq :: Push_Front(val); }
		if(opt == 1) { int val; scanf("%d", &val); dq :: Push_Back(val);}
		if(opt == 2) dq :: Pop_Front();
		if(opt == 3) dq :: Pop_Back();
		dq :: Solve();
	}
	return 0;
}

```

---

## 作者：小木虫 (赞：4)

### Preface  
这个题虽然叫简单数据结构但是和数据结构没有一毛钱关系。
### Problem  
给你一个初始有 $n$ 个元素的双向队列 $a$，要求实现 $q$ 次如下操作：  
1.在队首插入一个正整数 $x\space (0<x\leq m)$。  
2.在队尾插入一个正整数 $x\space (0<x\leq m)$。  
3.删除队首元素。   
4.删除队尾元素。  

保证任意时刻队内无相同元素，同一个数最多入队 $c$ 次。  
在第一次操作前和每次操作后输出该队列的最长倍数子序列长度和个数。  
$n,q\leq 10^5,n\leq m\leq 10^6,c\leq 10$。  

### Solution  
毫无疑问，这个子序列最优化和子序列计数问题是 dp 问题。  
发现这个题的特殊限制有两个。  
首先，无相同元素，这意味着最长倍数子序列长度是 $\log m$ 的。  
然后，同一个数最多入队 10 次，这个东西可能第一眼看上去没什么用。

考虑静态 dp，设状态 $f_i$ 为第一个元素的下标为 $i$ 的最长倍数子序列长度，易得转移方程：  
$$f_i=\max _{i<j,a_i|a_j}f_j+1$$  

看上去复杂度是 $O(n^2)$ 的，但其实根据调和级数（$\sum_i^n\frac{n}{i}=O(n\ln n)$），复杂度为 $O(m\ln m)$。  
然后你发现，这个 dp 是容易在队首插入删除的。  
删除很简单，因为它不影响后面的数据，直接删就好。  
插入考虑直接新添一个 dp 位置，然后对后面暴力转移。  
然后你发现，入队次数限制好像有用了，由于一个数入队次数为 $c$，所以整体复杂度为 $O(\sum_i^{n}c\frac{m}{a_i})$，同样可以近似为 $O(m\ln m\times c)$。  

考虑一下询问，直接拿一个大小为 $\log m$ 的桶对 $f$ 内的值计一下数就好。  

然后接下来考虑一下尾部插入删除，这个比较麻烦，因为他会影响到前面的 dp 值。  
我们发现尾部插入删除不仅是其自身会影响前面的值，他的影响还可以呈链式传递。  
形式化地说：$i<j<k,a_i|a_j|a_k$，当 $a_k$ 受到影响的时候，$f_i$ 不仅受到 $f_k$ 的影响，还会受到 $f_j$ 的影响。  
考虑到删除插入其实等价于修改，所以我们讨论修改即可。

首先，毋庸置疑的是，更改尾部值 $a_i$，受到影响的一定是其所有因数。  
在数论中，有一个可以拿来的现成结论：  
$$\max\{d(n)\}\leq 240,(n\leq 10^6)$$  
这个数字很小，是允许我们枚举修改的。  
然后让我们考虑一下链式传递怎么搞。  
你考虑到链式传递一定满足传递过程中越来越小，我们只能先做链尾的元素，所以我们从大因数开始修改，然后携带所有修改过的影响往下继续操作，这样就可以处理链式关系。  

然后让我们考虑一下怎么快速贡献前面的 $f$ 数组。  
更改之后再对前面做一次转移太脑瘫了，考虑把前面的转移都存下来。  
设 $g_{i,j}$ 为第 $i$ 个位置，有多少后面的 $f$ 值允许将该位置转移为 $j$。  

这样，我们在对前面做重转移的时候就可以避免重复转移，直接更改目标的 $g$ 数组，更新的时候单点 $O(\log m)$ 即可。  
换句话说，转移过程中有很多相同的 $f$ 值，把他们塞进一个桶里就可以压缩转移。  

这样，我们在做前文所说的“携带修改影响往下操作”的时候，枚举从大到小的因数，先 $O(\log m)$ 单点更新此处的 $f$，然后若发现 $f$ 被修改了，我们就删除这里原来的 $f$ 对于别处的贡献，然后通过修改 $g$ 重贡献一次，在这里我们需要枚举这里的 $f$ 对哪些地方有贡献，设这个因数为 $v$，则复杂度为 $O(\sqrt{v})$。  
若插入的数为 $x$。  
那么尾部修改的总复杂度为 $O(d(x)\times \log m+\sqrt{x}+\sum_{d|x}\sqrt{d})$。  
其中，对于 $\sum_{d|x}\sqrt{d}$，你能感觉出它可能不是很大。  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	vector <int> p;
	for(int i=1;i<=1e6;i++){
		int sum=0;
		for(int j=2;j*j<=i;j++){
			if(i%j!=0)continue;
			sum+=sqrt(j);
			if(j*j!=i)sum+=sqrt(i/j);
		}p.push_back(sum);
	}sort(p.begin(),p.end());
	reverse(p.begin(),p.end());
	int sum=0;
	for(int i=0;i<2e5;i++){
		sum+=p[i];
	}cout<<sum;
	return 0;
}
```
通过这段代码，我们可以得出最多的 $2\times 10^5$ 个 $\sum_{d|x}\sqrt{d}$ 的和是 $584472468$。  
~~卡卡还是能过的。~~  
别看它看起来大，实际上根本不可能跑满，因为队列里就那么多数，我们直接规避掉不在队列内的约数的转移就可以让常数变小非常多。   
为什么呢？关于这个复杂度，有一个很重要的事情：  
对于 $d|x$，进行 $\sqrt{d}$ 的贡献的时候必须满足之前已插入 $d$ 这个数。  
然后你可以均摊，让常数进一步变小。  
同时，在上面的分析的基础上，还有一件事就是越大的 $d$ 所能贡献到的 $x$ 就越少，这就意味着你需要插入非常多大的 $d$ 才能让复杂度跑的尽量满一些。   
上面的平时你可能不会注意到的常数优化或许就能让这个非常卡常数的代码通过本题，事实上，这样做的常数优化至少有三倍，能直接让复杂度变得可以接受。

关于 $d(x)\times \log m$。  
$\max\{d(m)\}\times \log m=4800,(m=10^6)$。  
看起来很卡常。  
但是，不要忘了我们还有一个数字的最多插入次数限制，而且因数很多的数不会很多。  
事实上，这个常数是比较小的，而且开了三秒。  
总的一个很松的复杂度是 $O((n+q)\times (d(m)\times \log m+\sqrt{m}+\sum_{d|m}\sqrt{d})+m\ln m\times c)$，常数巨小无比。  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e5+10;
const int M=1e6+10;
int n,m,q,a[N],op,x,f[N],tmp[N],g[N][25],buk[M],cnt[N],head,tail,d[N],tot;
void push_front(int x){
	--head;buk[x]=head;a[head]=x;f[head]=g[head][1]=1;
	for(int i=2;x*i<=m;i++){
		f[head]=max(f[head],f[buk[x*i]]+1);
		g[head][f[buk[x*i]]+1]++;
	}cnt[f[head]]++;
}
void pop_front(){cnt[f[head]]--;buk[a[head]]=0;memset(g[head],0,sizeof(g[head]));head++;}
void update(int x,int len,int op){
	cnt[len]+=op;
	for(int i=1;i*i<=x;i++){
		if(x%i!=0)continue;
		if(buk[i]&&buk[i]<buk[x])g[buk[i]][len+1]+=op;
		if(i*i!=x&&buk[x/i]&&buk[x/i]<buk[x])g[buk[x/i]][len+1]+=op;
	}
}
void push_back(int x){
	++tail;buk[x]=tail;a[tail]=x;f[tail]=g[tail][1]=1;
	update(x,1,1);tot=0;
	for(int i=1;i*i<=x;i++){
		if(x%i!=0)continue;
		d[++tot]=i;tmp[buk[i]]=f[buk[i]];
	}for(int i=sqrt(x);i>=2;i--){
		if(x%i!=0)continue;
		if(i*i!=x)d[++tot]=x/i,tmp[buk[x/i]]=f[buk[x/i]];
	}for(int u=tot;u>=1;u--){
		int now=d[u];int pos=buk[now];if(!pos)continue;
		for(int i=20;i>=1;i--)if(g[pos][i]){f[pos]=i;break;}
		update(now,tmp[pos],-1);update(now,f[pos],1);
	}
}
void pop_back(){int x=a[tail];
	update(x,1,-1);tot=0;
	for(int i=1;i*i<=x;i++){
		if(x%i!=0)continue;
		d[++tot]=i;tmp[buk[i]]=f[buk[i]];
	}for(int i=sqrt(x);i>=2;i--){
		if(x%i!=0)continue;
		if(i*i!=x)d[++tot]=x/i,tmp[buk[x/i]]=f[buk[x/i]];
	}for(int u=tot;u>=1;u--){
		int now=d[u];int pos=buk[now];if(!pos)continue;
		for(int i=20;i>=1;i--)if(g[pos][i]){f[pos]=i;break;}
		update(now,tmp[pos],-1);update(now,f[pos],1);
	}buk[x]=0;memset(g[tail],0,sizeof(g[tail]));tail--;
}
void query(){
	for(int i=20;i>=1;i--)
		if(cnt[i]){
			cout<<i<<" "<<cnt[i]<<"\n";return;
		}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>q;head=q+1;tail=q;
	for(int i=1;i<=n;i++)
		cin>>x,push_back(x);
	query();
	while(q--){
		cin>>op;
		if(op==0){
			cin>>x;push_front(x);
		}else if(op==1){
			cin>>x;push_back(x);
		}else if(op==2){
			pop_front();
		}else pop_back();
		query();
	}
	return 0;
}
```


---

## 作者：WZKQWQ (赞：3)

### 前言

模拟赛补题，赛时部分分用栈做忘记弹栈挂 $15$ 分，警钟撅烂。

提交时明明是最优解，才过了不到一天就被挤到第三了（悲。

### 正文

首先题意是模拟一个双端队列，并支持查找最长上升倍数子序列长度与多少点可以作为开头。

有一些性质，如任意时刻队列里没有值相同的元素，且所有元素在 $[1,m]$ 之间，并且同一个数字最多加 $10$ 次。

#### step1

首先考虑 $q=0$ 的部分分怎么做：

如果正着 DP 多少点开头太难算力，所以从后往前 DP，认为后面才是开头，$f_i$ 表示以 $i$ 结尾（这里的 $i$ 不是位置而是值）的最长上升倍数子序列长度。每次从后往前 DP，枚举倍数转移，由于特殊性质所以复杂度大概是调和级数级别的，且上界是 $O(m\log m)$。

统计答案考虑到答案不会超过 $20$ 所以开一个 $cnt_j$ 表示 $f_i=j$ 的 $i$ 的数量，一下子把两个询问全解决了。 

#### step2

然后一个一个加操作，考虑操作 $0$ 和 $2$ 都很好做，直接加删即可，因为从后往前 DP，所以在前面加删不影响后面，由于每个值最多加入 $10$ 次，复杂度依然正确。

#### step3

操作 $1$ 也不难，因为其实从后面加一个数会影响到的点只有它的约数，因此从后往前每次枚举因子转移即可，这里有两个小优化：

1. 可以预处理因子，但是复杂度可能过高，所以我们离线询问，只处理会加进队列的数。

2. 不难发现有些转移是无效的，我们可以采用 bfs 的转移方式。

复杂度不会证，但是可接受，粗略估一个上界是 $[1,m]$ 范围内每个数约数个数的平方，打一下表发现可接受。

#### step4

最难的操作显然是 $3$，当删除一个点时会同时需要它的所有约数都重新计算，这样显然是不可接受的，所以维护一个数组 $g_{i,j}$ 表示所有能转移到 $i$ 的点中，$f_k=j$ 的 $k$ 的个数。

不难发现每次删点最多使其他点的 $f$ 值减少 $1$，所以也可以用操作 $1$ 的方法做和优化。

代码：

```cpp

#include<bits/stdc++.h>
using namespace std;
const int N = 100005,M = 1000005,Log = 21;
struct qus{
	int op,x;
}b[N];
vector<int>d[M];
int n,m,q,a[N],f[M],g[M][Log],cnt[Log],l,r,s[M],pos[M];
void out(){
	for(int i = Log - 1;i;--i) if(cnt[i]){
		printf("%d %d\n",i,cnt[i]);
		break;
	}
}
void push_front(int x){
	s[--l] = x;
	pos[x] = l;
	for(int i = x + x;i <= m;i += x) f[x] = max(f[x],f[i]),++g[x][f[i]];
	++f[x];
	++cnt[f[x]];
}
void pop_front(){
	pos[s[l]] = 0;
	--cnt[f[s[l]]];
	f[s[l]] = 0;
	for(int i = 1;i < Log;++i) g[s[l]][i] = 0;
	++l;
}
void push_back(int now){
	s[++r] = now;
	pos[now] = r;
	f[now] = 1;
	++cnt[1];
	queue<int> q1;
	q1.push(now);
	while(!q1.empty()){
		int x = q1.front();
		q1.pop();
		for(int to:d[x]){
			if(pos[to] < pos[x] && pos[to]){
				--g[to][f[x] - 1],++g[to][f[x]];
				if(f[to] < f[x] + 1){
					--cnt[f[to]];
					f[to] = f[x] + 1;
					++cnt[f[to]];
					q1.push(to);
				}
			}
		}
	}
}
void pop_back(){
	queue<int> q1;
	int now = s[r];
	q1.push(now);
	--cnt[f[now]];
	f[now] = 0;
	while(!q1.empty()){
		int x = q1.front();
		q1.pop();
		for(int to:d[x]){
			if(pos[to] < pos[x] && pos[to]){
				++g[to][f[x]],--g[to][f[x] + 1];
				if(g[to][f[to] - 1] == 0){
					--cnt[f[to]];
					--f[to];
					++cnt[f[to]];
					q1.push(to);
				}
			}
		}
	}
	pos[now] = 0;
	for(int i = 1;i < Log;++i) g[now][i] = 0;
	--r;
}
bool v[M];
namespace INPUT_SPACE{
	const int S=(1<<20)+5;char B[S],*H,*T;inline int gc() { if(H==T) T=(H=B)+fread(B,1,S,stdin);return (H==T)?EOF:*H++; }
	inline unsigned int inn() { unsigned int x,ch;while((ch=gc())<'0'||ch>'9');x=ch^'0';while((ch=gc())>='0'&&ch<='9') x=x*10+(ch^'0');return x; }
}using INPUT_SPACE::inn;
int main(){
	n = inn(),m = inn(),q = inn();
	l = n + q + 1,r = n + q;
	for(int i = 1;i <= n;++i) a[i] = inn(),v[a[i]] = 1;
	for(int i = 1;i <= q;++i){
		b[i].op = inn();
		if(b[i].op < 2) b[i].x = inn(),v[b[i].x] = 1;
	}
	for(int i = 1;i <= m;++i) if(v[i])
		for(int j = i + i;j <= m;j += i) if(v[j]) d[j].push_back(i);
	for(int i = n;i;--i) push_front(a[i]);
	out();
	for(int i = 1;i <= q;++i){
		if(b[i].op == 0) push_front(b[i].x);
		else if(b[i].op == 1) push_back(b[i].x);
		else if(b[i].op == 2) pop_front();
		else pop_back();
		out();
	}
	return 0;
}
```


---

## 作者：Leasier (赞：1)

首先考虑暴力 dp。由于我们的 $cnt$ 与 开头有关，考虑从后往前 dp，设 $dp_i$ 表示以 $a_i$ 开头的最长上升倍数子序列的最大长度。

转移：$dp_i = \max(\displaystyle\sum_{j > i, a_i \mid a_j} dp_j, 0) + 1$。

对所有存在的 $dp_i$ 的值维护一个 set 和一个桶即可在转移完后 $O(1)$ 求解答案，现在我们想要知道如何维护这坨操作。

1. 左端插入

此时我们只需要进行一次正常的转移，直接枚举倍数即可。设 $c = 10$，则总时间复杂度为 $O(cm \ln m + (n + q) \log n)$。

2. 左端删除

此时我们直接把 $dp_i$ 从 set 和桶里扔掉即可。单次时间复杂度为 $O(\log n)$。

3. 右端插入

此时就有些麻烦了，因为插入一个可能会影响到所有它因数处的值。

考虑暴力一点，对每个 $dp_i$ 的所有合法转移点的 dp 值放进一个 set，每次先扔掉所有合法转移点的贡献，更新 $dp_i = 1$ 的信息后再重新加进去。单次时间复杂度为 $O(\tau(x)^2 \log m)$。

4. 右端删除

与 3 基本相同。

综上，时间复杂度为 $O(cm \ln m + (n + q) \log n + \sum \tau(x)^2 \log m)$。最后那坨看上去很大，但因为 $\tau(x)$ 很大的值不会太多，所以实际上跑不满。

但可惜这样做只能获得高贵的 $75$ 分……

注意到我们在 set 里需要维护的值域是 $\lceil \log_2 m \rceil - 1 \leq 19$，所以直接把 set 换成桶，就可以单次修改 $O(1)$、单次查询 $O(\log m)$，进而可以做到 $O(cm \ln m + (n + q) \log n + \sum \tau(x)(\tau(x) + \log m))$，然后就可以通过了。

事实上单次查询也可以是 $O(1)$——把桶换成压位即可。时间复杂度为 $O(cm \ln m + (n + q) \log n + \sum \tau^2(x))$。~~但在洛谷上跑得反而比桶慢一些？~~

代码：
```cpp
#include <iostream>
#include <set>
#include <functional>

using namespace std;

const int N = 19;

typedef struct {
	int state = 0;
	int cnt[N + 7];
	
	inline void clear(){
		state = 0;
		for (register int i = 1; i <= N; i++){
			cnt[i] = 0;
		}
	}
	
	inline void insert(int x){
		if (++cnt[x] == 1) state |= 1 << (x - 1);
	}
	
	inline bool empty(){
		return state == 0;
	}
	
	inline int get_max(){
		return state == 0 ? -1 : 32 - __builtin_clz(state);
	}
	
	inline void erase(int x){
		if (--cnt[x] == 0) state ^= 1 << (x - 1);
	}
} State;

const int M = 1e6 + 7, K = 1e5 + 7, P = 3e5 + 7, Q = 2e5 + 7;
int sz[M], a_[K], a[P], pos[M], dp[P], cnt[Q];
int *v[M];
State st[P];
set<int, greater<int> > se;

inline void init(int n){
	for (register int i = 1; i <= n; i++){
		for (register int j = i; j <= n; j += i){
			sz[j]++;
		}
	}
	for (register int i = 1; i <= n; i++){
		v[i] = new int[sz[i] + 1];
	}
	for (register int i = 1; i <= n; i++){
		for (register int j = i; j <= n; j += i){
			v[j][sz[j]--] = i;
		}
	}
	for (register int i = 1; i <= n; i++){
		for (register int j = i; j <= n; j += i){
			sz[j]++;
		}
	}
}

inline void insert(int x){
	if (++cnt[dp[x]] == 1) se.insert(dp[x]);
}

inline void addl(int x, int val, int m){
	a[x] = val;
	pos[val] = x;
	st[x].clear();
	for (register int i = val * 2; i <= m; i += val){
		if (pos[i] != 0) st[x].insert(dp[pos[i]]);
	}
	dp[x] = st[x].empty() ? 1 : st[x].get_max() + 1;
	insert(x);
}

inline void output(){
	int maxlen = *se.begin();
	cout << maxlen << " " << cnt[maxlen] << endl;
}

inline void erase(int x){
	if (--cnt[dp[x]] == 0) se.erase(dp[x]);
}

inline void addr(int x, int val){
	for (register int i = 2; i <= sz[val]; i++){
		int y = v[val][i];
		if (pos[y] != 0){
			erase(pos[y]);
			for (register int j = 1; j <= i; j++){
				int z = v[val][j];
				if (z % y == 0 && pos[z] != 0 && pos[z] > pos[y]) st[pos[y]].erase(dp[pos[z]]);
			}
		}
	}
	a[x] = val;
	pos[val] = x;
	dp[x] = 1;
	st[x].clear();
	insert(x);
	for (register int i = 2; i <= sz[val]; i++){
		int y = v[val][i];
		if (pos[y] != 0){
			for (register int j = 1; j <= i; j++){
				int z = v[val][j];
				if (z % y == 0 && pos[z] != 0 && pos[z] > pos[y]) st[pos[y]].insert(dp[pos[z]]);
			}
			dp[pos[y]] = st[pos[y]].get_max() + 1;
			insert(pos[y]);
		}
	}
}

inline void dell(int x){
	pos[a[x]] = 0;
	erase(x);
}

inline void delr(int x){
	erase(x);
	for (register int i = 2; i <= sz[a[x]]; i++){
		int y = v[a[x]][i];
		if (pos[y] != 0){
			erase(pos[y]);
			for (register int j = 1; j <= i; j++){
				int z = v[a[x]][j];
				if (z % y == 0 && pos[z] != 0 && pos[z] > pos[y]) st[pos[y]].erase(dp[pos[z]]);
			}
		}
	}
	pos[a[x]] = 0;
	for (register int i = 2; i <= sz[a[x]]; i++){
		int y = v[a[x]][i];
		if (pos[y] != 0){
			for (register int j = 1; j <= i; j++){
				int z = v[a[x]][j];
				if (z % y == 0 && pos[z] != 0 && pos[z] > pos[y]) st[pos[y]].insert(dp[pos[z]]);
			}
			dp[pos[y]] = st[pos[y]].empty() ? 1 : st[pos[y]].get_max() + 1;
			insert(pos[y]);
		}
	}
}

int main(){
	int n, m, q, l, r;
	cin >> n >> m >> q;
	l = n + q + 1;
	r = l - 1;
	init(m);
	for (register int i = 1; i <= n; i++){
		cin >> a_[i];
	}
	for (register int i = n; i >= 1; i--){
		addl(--l, a_[i], m);
	}
	output();
	for (register int i = 1; i <= q; i++){
		int op;
		cin >> op;
		if (op <= 1){
			int x;
			cin >> x;
			if (op == 0){
				addl(--l, x, m);
			} else {
				addr(++r, x);
			}
		} else if (op == 2){
			dell(l++);
		} else {
			delr(r--);
		}
		output();
	}
	return 0;
}
```

---

## 作者：shiruoyu114514 (赞：0)

首先我们需要统计“合法开头数量”，如果像往常一样从前往后 DP 会导致非常难处理。我们不妨从后往前 DP，这样所需要统计的就是“最大的合法 DP 值及其个数”了。

转移方程：

$$dp_i=\max_{j>i,a_i|a_j}{dp_j+1}$$

现在这个问题还是显得很不好处理，我们试着观察一下题目的特殊性质。一个数至多加入 $10$ 次意味着你每次插入/删除的时候如果你能做到以 $O(\frac{m}{x})$ 或者 $O(d(x))$ 处理的话，你的总时间复杂度就将达到 $O(10m\ln m)$。

容易发现此 DP 如果记录每个值的 DP 值得话，每当 ``push_front(x)`` 一次的时候时间复杂度将达到 $O(\frac{m}{x})$，加上暴力可以得到 $45$ 分。

现在棘手的是 ``push_back(x)`` 以及 ``pop_back()``。乍一看会形成非常恐怖的连锁反应，但是由于任意时刻数列中的每个数都是不同的，所以最终影响到的数至多只有 $d(x)$ 个。对于每一个被影响到的数，我们只需要在 $O(1)$ 时间复杂度内更新时间复杂度就对了。

当 ``push_back(x)`` 时，你可以以类似于最长路的更新方式使用 BFS 尝试更新每一个被影响到的数。

当 ``pop_back()`` 时，你可以记录 $g_{i,j}$，表示有多少个 DP 值为 $j$ 的节点可以转移到 $i$。由于数列中每个数都不同，所以最长上升倍数子序列的每一项相较于前一项至少翻倍，所以 $j$ 至多只有 $\log m$ 项。我们可以仿照 ``push_back()`` 的方式，通过 BFS 来用每一个值发生改变的数来试着改变其它的数。可以用 $g$ 数组 $O(1)$ 判断每个 DP 值在前驱发生变化之后需不需要改变。

于是本题就做完了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxm = 1e6;
const int LOG = 21;

int a[maxm + 5];
int dp[maxm + 5];
int g[maxm + 5][LOG];
int cnt[LOG];
int pos[maxm + 5];
vector<int> d[maxm + 5];
int l, r;
int m;

void out() {
    for (int i = LOG - 1; i >= 0; i--) {
        if (cnt[i]) {
            cout << i << " " << cnt[i] << "\n";
            return;
        }
    }
}

void push_front(int x) {
    l--;
    a[l] = x;
    pos[x] = l;
    for (int i = 2 * x; i <= m; i += x) {
        if (pos[i]) {
            dp[l] = max(dp[l], dp[pos[i]]);
            g[l][dp[pos[i]]]++;
        }
    }
    dp[l]++;
    // cout<<l<<" "<<x<<" "<<dp[l]<<"\n";
    cnt[dp[l]]++;
}

void pop_front() {
    pos[a[l]] = 0;
    cnt[dp[l]]--;
    dp[l] = 0;
    for (int i = 1; i < LOG; i++) {
        g[l][i] = 0;
    }
    l++;
}

void push_back(int x) {
    r++;
    a[r] = x;
    pos[x] = r;
    dp[r] = 1;
    cnt[1]++;
    queue<int> q;
    q.push(r);
    while (!q.empty()) {
        int front = q.front();
        q.pop();
        for (auto i : d[a[front]]) {
            if (pos[i] && pos[i] < front) {
                g[pos[i]][dp[front] - 1]--;
                g[pos[i]][dp[front]]++;
                if (dp[front] + 1 > dp[pos[i]]) {
                    cnt[dp[pos[i]]]--;
                    cnt[dp[pos[i]] + 1]++;
                    dp[pos[i]]++;
                    q.push(pos[i]);
                }
            }
        }
    }
}

void pop_back() {
    queue<int> q;
    q.push(r);
    cnt[dp[r]]--;
    dp[r] = 0;
    pos[a[r]] = 0;
    for (int i = 0; i < LOG; i++) {
        g[r][i] = 0;
    }
    while (!q.empty()) {
        int front = q.front();
        q.pop();
        for (auto i : d[a[front]]) {
            if (pos[i] && pos[i] < front) {
                g[pos[i]][dp[front] + 1]--;
                g[pos[i]][dp[front]]++;
                if (g[pos[i]][dp[pos[i]] - 1] == 0) {
                    cnt[dp[pos[i]]]--;
                    dp[pos[i]]--;
                    cnt[dp[pos[i]]]++;
                    q.push(pos[i]);
                }
            }
        }
    }
    a[r] = 0;
    r--;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= m; i++) {
        for (int j = 2 * i; j <= m; j += i) {
            d[j].push_back(i);
        }
    }
    l = n + q + 1, r = n + q;
    int a[n + 1];
    for (int i = 1; i <= n; i++) {
        // push_front(x);
        cin >> a[i];
    }
    for (int i = n; i >= 1; i--) {
        push_front(a[i]);
    }
    out();
    while (q--) {
        int op;
        cin >> op;
        if (op == 0) {
            int x;
            cin >> x;
            push_front(x);
        } else if (op == 2) {
            pop_front();
        } else if (op == 1) {
            int x;
            cin >> x;
            push_back(x);
        } else {
            pop_back();
        }
        out();
    }
}

``

---


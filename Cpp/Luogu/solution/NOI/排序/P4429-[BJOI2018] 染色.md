# [BJOI2018] 染色

## 题目描述

pupil 喜欢给图的顶点染颜色。有一天，master 想刁难他，于是给了他一个无重边和自环的无向图，并且对每个点分别给了一个大小为 $2$ 的颜色集合，pupil 只能从这个集合中选一种颜色给这个点染色。master 希望 pupil 的染色方案使得没有两个有边相连的点被染了相同的颜色。

现在 pupil 想知道，是否无论 master 的颜色集合是什么，他均有办法按照要求染色。

## 说明/提示

### 样例解释

对于第一组数据，如果第一个点和第二个点的集合为 $\{A,B\}$，第三个点和第四个点的集合为 $\{A,C\}$，第五个点和第六个点的集合为 $\{B,C\}$，
则奇数点至少使用了两种颜色，偶数点至少使用了两种颜色，因此至少有一个奇数点和一个偶数点颜色相同。但每两个奇数点和每两个偶数点之间均有边，
因此无法满足“没有两个有边相连的点被染了相同的颜色”。

对于第二组数据，无论两个集合是什么，第一个点随便染它的集合中的其中一种颜色，第二个点染它的集合中某个与第一个点不同的颜色即可。

对于第三组数据，如果三个点的集合均是 $\{A,B\}$，那么无法满足“没有两个有边相连的点被染了相同的颜色”。

### 数据范围

- 对于 $10\%$ 的数据，$1 \leq n \leq 3$；
- 对于 $20\%$ 的数据，$1 \leq n \leq 6$；
- 对于 $50\%$ 的数据，$1 \leq n \leq 1000$，$0 \leq m \leq 2000$；
- 对于 $100\%$ 的数据，$1 \leq n \leq 10000$，$0 \leq m \leq 20000$，$1 \leq T \leq 10$。
- 另外存在 5 个不计分的 hack 数据。

## 样例 #1

### 输入

```
3
6 9
1 2
1 4
1 6
3 2
3 4
3 6
5 2
5 4
5 6
2 1
1 2
3 3
1 2
1 3
2 3```

### 输出

```
NO
YES
NO```

# 题解

## 作者：Alex_Wei (赞：25)

Upd on 2022.7.7：修正代码，修改笔误。

> *[P4429 [BJOI2018] 染色](https://www.luogu.com.cn/problem/P4429)

我花了一个下午和一个晚上研究这道结论题及其证明。现有题解的证明与推导过程太简略，并不严谨，且没能很好地体现本题的思维难度，希望我的题解能帮到大家。

如有笔误或难以理解的部分还请指出。

#### 基本判断

显然，当 $G$ 不是二分图时无解，图上所有环均为偶环。

设 $G$ 连通，若 $G$ 不连通，其每个连通块独立，可分别求解。

度数为 $1$ 的点不产生贡献，因其可根据唯一邻点的颜色确定自身颜色，不可能无解，故不断剥去度数为 $1$ 的点，直到图上所有点度数 $\geq 2$。

#### 固定

由样例可知若 $G$ 包含 $K_{3, 3}$ 则无解，但这个条件太强了，不必要。

尝试手玩 $K_{2, 2}$，即长度为 $4$ 的环 $(1, 2, 3, 4)$，目标是确定一些颜色，降低不确定性。

不失一般性，节点 $1$ 的颜色集合 $S_1 = \{A, B\}$。注意到 $3$ 与 $2, 4$ 相连，若给 $1$ 涂上颜色 $A$ 后，$2, 4$ 被迫选择 $B, C$，令 $S_3 = \{B, C\}$ 即可导出矛盾。根据推理，当 $S_1 = \{A, B\}$，$S_2 = \{A, B\}$，$S_3 = \{B, C\}$，$S_4 = \{A, C\}$ 时，可固定 $c_1 = B$。

尝试抽象出固定的本质。设节点 $i$ 及 $S_i = \{A, B\}$，「固定」需要两个「自由点」$j, k$，使得 $i$ 取某个颜色时，$j$ 不得不取某个 **与 $i$ 不同** 的颜色，而 $k$ 的颜色集与 $i, j$ 颜色重合，得到矛盾。

#### 简单环

接下来讨论的环为不经过重复节点的 **简单环**。

一个环固定环上任意点颜色，只需再用一个环导出矛盾即可。因形如 “只能选两种颜色之一” 的限制可通过度数为 $2$ 的节点传播，故若 $G$ 存在两个不交的由一条链连接的环，则无解。

证明：考虑环 $C_1, C_2$ 及连接它们的路径 $P = u\to v$，其中 $u\in C_1$，$v\in C_2$。令 $P$ 上所有节点颜色集合为 $\{A, B\}$。固定 $c_u = A$，$c_v$ 根据 $|P|$ 奇偶性固定为 $A$ 或 $B$ 容易通过 $P$ 导出矛盾。证毕。

进一步地，若 $G$ 存在两个交于一点的环，则无解，此时 $P$ 退化为单点。例如在上例基础上添加环 $(1, 5, 6, 7)$，令 $S_5 = \{A, B\}$，$S_6 = \{A, C\}$，$S_7 = \{B, C\}$ 可固定 $c_1 = A$，矛盾。

#### 两个四度点

注意到两个交于一点的环形成度数为 $4$ 的节点，设两个 $deg \geq 4$ 的节点 $u, v$。

若存在 $u\to v$ 的两条路径 $P_1, P_2$ 交于 $q_1, q_2, \cdots, q_k\neq u, v$，则 $C_1 = u\xrightarrow{P_1} q_1 \xrightarrow{P_2} u$ 与 $C_2 = v\xrightarrow{P_1} q_k\xrightarrow{P_2} v$ 至多交于一点 $q_1$，无解。

假设 $u\to v$ 某四条路径分别长 $L_1, L_2, L_3, L_4$。

当 $L$ 为奇数时，因无重边，故 $L_2, L_3, L_4 \geq 3$。因形如 “只能选某固定颜色” 的限制可通过度数为 $2$ 的节点 **以 $2$ 为周期** 传播，即讨论无解性时长 $k$ 的链可归约至长 $k - 2$ 的链，故只需考虑 $L_2 = L_3 = L_4 = 3$。根据固定的本质，读者容易自行构造反例。如果不会，见三度点部分 $(3, 3, 1)$ 反例，其强于 $(3, 3, 3)$。

当 $L$ 为偶数时，同理只需考虑 $L_1 = L_2 = L_3 = L_4 = 2$ 的 $K_{2, 4}$。令 $S_u = \{A, B\}$，$S_v = \{C, D\}$，中间四个点分别为 $\{A, C\}$，$\{A, D\}$，$\{B, C\}$，$\{B, D\}$ 即可。

因此，图上存在至少两个 $deg\geq 4$ 的节点时，无解。

#### 一个四度点

当图上仅有一个 $deg\geq 4$ 的节点时，要么存在至少两个 $deg = 3$ 的节点，要么剩余所有节点 $deg = 2$。

对于后者，其形态为两个交于一点的环，无解。

对于前者，设两个 $deg = 3$ 的节点 $u, v$，同理可证 $u\to v$ 之间任意路径仅在 $u, v$ 处相交，与存在 $deg\geq 4$ 的节点矛盾。

因此，图上存在至少一个 $deg\geq 4$ 的节点时，无解。

接下来讨论不存在四度及以上节点的图。

#### 三度点

讨论完四度点，让我们将目光转向三度点。一旦图上存在三度点的情况被讨论清楚，问题就迎刃而解。

考虑图上某两个三度点 $u, v$，上文已经说明 $u\to v$ 之间任意路径仅在 $u, v$ 处相交，故图上仅存在两个三度点。

设 $u\to v$ 三条路径长 $L_1, L_2, L_3$，$L_1 \geq L_2 \geq L_3$。

考虑 $L_3 = 1$。

因无重边，故 $L_1, L_2 \geq 3$。如法炮制，根据归约关系考虑 $L_1 = L_2 = 3$。根据固定的本质，在最开始例子的基础上，添加环 $(1, 2, 5, 6)$，令 $S_5 = \{A, C\}$，$S_6 = \{B, C\}$ 可固定 $c_1 = A$。无解，称为 $(3, 3, 1)$ 反例。

考虑 $L_3 = 2$。

从简单情况入手，考虑 $L_1 = L_2 = 2$ 的 $K_{2, 3}$。

- 若 $S_u\cap S_v \neq \varnothing$，则令 $c_u$ 和 $c_v$ 等于它们的交中的某个颜色，则中间三个点因为 $|S| = 2$，总可以选择不与该颜色相同的颜色，有解。
- 若 $S_u\cap S_v = \varnothing$，则 $c_u$ 与 $c_v$ 的颜色共有 $4$ 种不同情况，而每个节点只被唯一情况封锁住，所以至少有一种情况没有封锁住任何节点，有解。

这说明 $K_{2, 3}$ 有解。

进一步地，考虑 $L_1 \geq 4$。$K_{2, 3}$ 的讨论给予我们突破点：考虑 $c_u, c_v$ 的颜色情况数，与夹在中间的节点个数 $2$ 作比较。若情况数 $> 2$ 或 $c_u = c_v$ 则有解，否则无解。

- 若 $L_1$ 对应路径存在相邻两个点的 $S$ 不同，则当 $c_u$ 取两种颜色时，按照环边染色，$c_v$ 分别有两种和至少一种合法选择。
  - 若 $S_u\cap S_v \neq \varnothing$，存在三种不同情况，有解。
  - 若 $|S_u\cap S_v| = \{A\}$，若 $c_u = c_v = A$ 不合法，则剩余三种情况互不相同，有解；否则 $c_u = c_v = A$ 合法，有解。
  - 若 $S_u = S_v$，$c_u\neq c_v$ 的情况只有两种，必然存在 $c_u = c_v$ 合法的情况，有解。
- 否则，由于 $L_1$ 为偶数，所以 $c_u = c_v$，有解。

这说明仅有 $L_1 \geq 4$ 时仍然有解。

容易发现上述证明并没有用到 $L_1 \geq 4$ 的性质，即它可以用于证明 $K_{2, 3}$ 的有解性。但如果不先从 $K_{2, 3}$ 下手，不易想到情况数这一突破点。因此，**从简单情况入手** 是这种推性质题相当好用的解题技巧。

进一步地，考虑 $L_1, L_2\geq 4$。由于上文讨论过 $(3, 3, 1)$ 无解，不难再此基础上稍作修补，构造出使得 $(4, 4, 2)$ 无解的反例。提示：考虑固定的本质，$L_1, L_2 \geq 4$ 说明存在两组自由点 $j, k$，每组自由点可固定 $c_u$ 为某颜色。

综上，我们得到图上存在三度点有解的充要条件：图上仅存在两个三度点，且至少存在两个与两个三度点同时相邻的二度点。

#### 偶环

最后，考虑仅存在二度点的图。因无重边，它是一个长度 $\geq 4$ 的环。

类似地，考虑环上相邻三个节点 $u, v, q$ 并最后考虑 $v$ 的限制。若 $u$ 从环的另一侧到 $q$ 的路径上 $S$ 相同，则 $c_u = c_q$ 合法，有解。否则考虑使得 $c_q$ 有两种染色方案的 $c_u$，无法封锁 $v$，有解。

#### 结论

对 $G$ 的每个连通块单独求解，若存在连通块无解则整张图无解。

$G$ 有解当且仅当其为二分图，且满足以下性质之一：

- 不存在 $deg \geq 3$ 的点。
- 不存在 $deg \geq 4$ 的点，且仅存在两个三度点，且至少存在两个与三度点同时相邻的二度点。

容易在 $\mathcal{O}(m\log m)$ 或 $\mathcal{O}(m)$ 的时间进行上述判定。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 1e4 + 5;
int n, m, GG, col[N];
set<int> e[N];
vector<int> G;
void dfs(int id) {
  G.push_back(id);
  for(int it : e[id]) {
    if(col[it] == -1) col[it] = col[id] ^ 1, dfs(it);
    else if(col[id] == col[it]) GG = 1;
  }
}
void solve() {
  GG = 0;
  cin >> n >> m;
  memset(col, -1, sizeof(col));
  for(int i = 1; i <= n; i++) e[i].clear();
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[u].insert(v), e[v].insert(u);
  }
  queue<int> q;
  for(int i = 1; i <= n; i++) if(e[i].size() == 1) q.push(i);
  while(!q.empty()) {
    int t = q.front();
    q.pop();
    if(e[t].empty()) continue;
    int it = *e[t].begin();
    e[t].clear(), e[it].erase(t);
    if(e[it].size() == 1) q.push(it);
  }
  for(int i = 1; i <= n; i++) if(e[i].size() > 3) return puts("NO"), void();
  for(int i = 1; i <= n; i++) {
    if(col[i] != -1) continue;
    col[i] = 0, G.clear(), dfs(i);
    if(GG) return puts("NO"), void();
    int u = -1, v = -1;
    for(int it : G)
      if(e[it].size() == 3) {
        if(u == -1) u = it;
        else if(v == -1) v = it;
        else return puts("NO"), void();
      }
    if(u != -1) {
      int cnt = 0, c[3], d[3];
      for(int i : {0, 1, 2}) {
        c[i] = *e[u].begin(), e[u].erase(e[u].begin());
        d[i] = *e[v].begin(), e[v].erase(e[v].begin());
      }
      for(int i : {0, 1, 2}) for(int j : {0, 1, 2}) cnt += c[i] == d[j];
      if(cnt < 2) return puts("NO"), void();
    }
  }
  puts("YES");
}
bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  int T;
  cin >> T;
  while(T--) solve();
  return cerr << "Time: " << clock() << "\n", 0;
}
/*
2022/7/6
start thinking at 9:57
首先图必须得是二分图。
再加上不存在 K{3, 3} 是否是充要条件？
Try a try, AC is OK.
不是。
冷静分析了一下，可能是 K{2, 3}。
不是。
好像是两个并列简单环。
很神仙的题目，研究了一下午。
start coding at 17:10
finish debugging at 17:18
*/
```

---

## 作者：FunnyCreatress (赞：14)

upd：之前证明有小锅，修了。

神仙结论题 Orz

首先，考虑非二分图的情况，直接规定每个点都只能用 $A$ 或 $B$，由于存在奇环，所以就爆炸了，答案为 `NO`。

接下来讨论二分图的情况，不妨只考虑每个连通块的情况。

容易发现，用拓扑排序把外面一圈没什么用的点干掉并不影响答案。所以可以假设所有点度数都不小于 $2$。

考虑最简单的一个环的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/68o0ttw5.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

这样标就可以固定 $2,4$ 号点的颜色 (更进一步地，任意环上距离奇数的两个点的颜色)，于是只要我们的连通块里有两个边不交的环，或者环的相交部分有奇数条边，答案就是 `NO` 了。

$m\le n$ 时，最多只有一个环，这肯定是随便搞掉的。

$m=n+1$ 的情况略繁琐：

众所周知，$2m=\sum_{i=1}^ndeg_i$，又有 $deg_i\ge2$，所以要么有两个点度数为 $3$，要么一个点度数为 $4$。

度数为 $4$ 的情况显然就是两个环交在同一点上，由前面的结论，答案为 `NO`。

两个度数为 $3$ 且两点间夹奇数个点的情况如下：

- 存在两条点数大于 $1$ 的链夹在两点之间，我们只要举出两条都为 $3$ 的反例即可。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5e3bqxzz.png?x-oss-process=image/resize,m_lfit,h_300,w_300)
- 否则，容易证明不存在反例，答案为 `YES`。

直接比较三度点的邻集，看重合点数是否 $>1$ 即可。

$m\ge n+2$ 且不存在相交部分有奇数条边的环时，一定可以找到形如上面那个反例的子图，答案为 `NO`。

单次复杂度 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e4+5;
int T,n,m,tot,deg[N],hd[N],nxt[N],to[N],vst[N],cntE,cntV,___[N];
bool del[N];vector<int> v;queue<int> q;
void add(int x,int y){to[++tot]=y,nxt[tot]=hd[x],hd[x]=tot;}
void init(){
	tot=0;
	memset(hd,0,sizeof(hd));
	memset(vst,0,sizeof(vst));
	memset(deg,0,sizeof(deg));
	memset(del,0,sizeof(del));
	memset(___,0,sizeof(___));
}
bool dfs(int x,int c){
	if(!vst[x])vst[x]=c;
	else return vst[x]==c;
	for(int i=hd[x];i;i=nxt[i])
		if(!dfs(to[i],3-c))return 0;
	return 1;
}
bool isbip(){for(int i=1;i<=n;i++)if(!vst[i]){if(!dfs(i,1))return 0;}return 1;}
void dfs2(int x){
	vst[x]=1,cntV++;
	for(int i=hd[x];i;i=nxt[i]){if(!vst[to[i]])dfs2(to[i]);cntE++;}
	if(deg[x]==1){
		del[x]=1,deg[x]=0,cntE-=2,cntV--;
		for(int i=hd[x];i;i=nxt[i])if(!del[to[i]])deg[to[i]]--;
	}
	else v.push_back(x);
}
bool check(int x){
	cntE=cntV=0,v.clear(),dfs2(x),cntE>>=1;
	if(cntE<=cntV)return 1;
	if(cntE>=cntV+2)return 0;
	int s=0,t=0,cc=0;
	for(int i=0;i<v.size();i++)if(deg[v[i]]==3)s?t=v[i]:s=v[i];
	for(int i=hd[s];i;i=nxt[i])if(!del[to[i]])___[to[i]]++;
	for(int i=hd[t];i;i=nxt[i])if(!del[to[i]])___[to[i]]+=2;
	for(int i=hd[s];i;i=nxt[i])if(!del[to[i]])cc+=(___[to[i]]==3);
	return cc>=2;
}
bool i_love_funnycreature(){
	memset(vst,0,sizeof(vst));
	for(int i=1;i<=n;i++)if(!vst[i]){if(!check(i))return 0;}
	return 1;
}
int main(){
	scanf("%d",&T);
	while(T--){
		init();
		scanf("%d%d",&n,&m);
		for(int i=1,x,y;i<=m;i++)scanf("%d%d",&x,&y),add(x,y),add(y,x),deg[x]++,deg[y]++;
		if(!isbip()){printf("NO\n");continue;}
		if(!i_love_funnycreature())printf("NO\n");
		else printf("YES\n");
	}
	return 0;
}
```



---

## 作者：cyh_toby (赞：10)

首先各连通块互不影响，所以可以分别考虑，以下均讨论一个连通块内的情况。

**Lemma1.** 非二分图一定无解。

**Proof1.** 非二分图无法黑白染色，只需要令每个点的颜色集合为黑色和白色就寄了。

所以接下来考虑二分图的情况。注意到所有的孤点和一度点都可以删去，前者显然，后者是因为任意一条链确定一个端点后，可以依次往另一个端点的方向染过去，一定不会无解。所以可以用类似拓扑排序的方式，把度数 $\le 1$ 的点全部删去，剩下的图所有点度数均 $\ge 2$。以下均讨论这样处理之后的情况。

**Lemma2.** 如果该连通块仅是一个偶环，那么它有解。

**Proof2.** 如果所有点的颜色集合都一样（比如，全是黑白），直接二分图染色即可。否则，一定存在相邻两个点 $x,y$，使得至少有一种颜色 $x$ 有，$y$ 没有。直接让 $x$ 染这种颜色，那么 $y$ 不管染什么颜色都不会和 $x$ 冲突，因此可以从 $x,y$ 之间把环断开，变成一条链，上面分析过一定有解。

考虑如下一个四元环，按图中所示方案分配集合，容易发现整个图的染色方案有且仅有一种。

![图](https://cdn.luogu.com.cn/upload/image_hosting/h2ge8tgs.png)

$1$ 号点只能染颜色 $B$，$2$ 号点只能染颜色 $A$。而且如果交换 $3,4$ 号点的集合，$1,2$ 号点只能染的颜色也要交换。

这个性质可以拓展到任意长度 $\ge 4$ 的偶环，只需要选两个相邻的点，按上图 $3,4$ 那样分配集合，剩余的点全部分配 $AB$ 即可。

因此，如果有两个偶环相交，且不交的部分均足以放下 $3,4$ 号点那样的分配（即，两侧不交部分点数分别都 $\ge 2$），我们就可以通过把左右两侧的 $3,4$ 号点方式的点的顺序搞成不同的，使相交部分产生矛盾，即：

![图2](https://cdn.luogu.com.cn/upload/image_hosting/gq8v2sg0.png)

所以，几乎所有不是单独一个环的情况都是无解的，我们几乎都可以用上面的方法，把两个相交的环寄掉。接下来仔细分析。

**Lemma3.** 有两个以上度数 $\ge 3$ 的点的图，一定无解。

**Proof3.** 取出两个度数 $\ge 3$ 的点 $x,y$，则 $x,y$ 之间的所有路径，只要有 $x,y$ 以外的交点，就会形成能用上面方法寄掉的两个相交环（注意上图的例子中，相交部分有两个交点，但是其实仅需有一个交点即可卡掉）。如果度数 $\ge 3$ 的点有两个以上，则这样的交点一定会形成。

**Lemma4.** 如果度数最大点的度数 $\ge 4$，一定无解。

**Proof4.** 考虑取出其中一个度数 $\ge 4$ 的点，不妨假设是左部点 $p$，那么它向右侧连了至少四个点 $x,y,z,w$，如果形成了两个环，即 $p-x-\dots-y-p$ 和 $p-z-\dots w-p$，那么给 $p$ 分配 $AB$，把第一个环上顺次分配 $AC,CD,CD,\dots,CD,AD$，第二个环上顺次分配 $BC,CD,CD,\dots,CD,BD$，则当 $p$ 选 $A$ 时，第一个环只能依次是 $A,C,D,C\dots,C$（注意总共有偶数个点），但是最后一个点必须选 $A$ 或 $D$，所以就寄了；$p$ 选 $B$ 是一样的。于是，我们只需要证明一定会形成两个环。如果剩余的点度数都 $\le 2$，则必然是两个环；否则根据 lemma3，只能还有至多一个度数 $\ge 3$ 的点 $q$，但是这个点要么不会破坏形成的两个环，要么自己直接连接了 $x,y,z$，可是这样 $w$ 只能单独连一条路径出去，最终必定走回 $p$ 或者 $q$，不论如何还是会新形成一个环，就寄了。

接下来只剩一种情况，就是只有两个度数是 $3$ 的点。注意前面说了上述方法有个条件，就是不交的部分足以容纳下两个点（来放 $AC,BC$）。所以如果这个连通块形如「一条链，然后两个端点之间还额外连了两条边数为 $2$ 的路径」，则它是也合法的。此外情况都是不合法的。

参考：<https://qmqmqm.blog.uoj.ac/blog/3515>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e4 + 5;
#define pb push_back

int n, m;
vector<int> g[N];
int d[N], c[N], ban[N];

bool dfs(int x, int col) {
	c[x] = col;
	for (auto y : g[x]) {
		if (!~c[y]) dfs(y, col ^ 1);
		else if (c[y] == c[x]) return false;
	}
	return true;
} 

inline void solve() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) g[i].clear(), ban[i] = d[i] = 0, c[i] = -1;
	for (int i = 1, x, y; i <= m; i++) 
		scanf("%d%d", &x, &y), g[x].pb(y), g[y].pb(x), d[x]++, d[y]++;
	for (int i = 1; i <= n; i++) if (!~c[i] && !dfs(i, 0)) return puts("NO"), void();
	queue<int> q;
	for (int i = 1; i <= n; i++) if (d[i] <= 1) q.push(i);
	while (!q.empty()) {
		int x = q.front(); q.pop();
		ban[x] = 1;
		for (auto y : g[x]) if (!ban[y] && --d[y] <= 1) q.push(y);
	}
	for (int i = 1; i <= n; i++) if (!ban[i]) {
		vector<int> p, q;
		function<void(int)> dfs = [&](int x) {
			p.pb(x), ban[x] = 1;
			for (auto y : g[x]) if (!ban[y]) dfs(y);
		};
		dfs(i);
		int mxd = 0;
		for (auto x : p) mxd = max(mxd, d[x]);
		if (mxd == 2) continue;
		if (mxd > 3) return puts("NO"), void();
		for (auto x : p) if (d[x] == 3) q.pb(x);
		if (q.size() != 2u) return puts("NO"), void();
		int S = q[0], T = q[1], cnt = 0;
		for (auto x : p) if (x != S && x != T) {
			int OS = 0, OT = 0;
			for (auto y : g[x]) OS |= (y == S), OT |= (y == T);
			if (OS && OT) cnt++;
		}
		if (cnt < 2) return puts("NO"), void();
	}
	puts("YES");
}

int main()
{
	int T; scanf("%d", &T);
	while (T--) solve();
	return 0;
}
```


---

## 作者：takanashi_mifuru (赞：3)

比较厉害的题。

考虑首先这个东西很明显可以总共只放两个颜色，变成判二分图，这个随便判。

一条链可以传递【强制选某个颜色】的讯息，譬如现在有一条链上有 $3$ 个点，其中 $S_1=[A,B],S_2=[A,C],S_3=[C,B]$，那么第 $1$ 个点强制选 $A$ 的讯息就可以作为第 $3$ 个点强制选 $B$ 的讯息被传递出去。

如果两条链同奇偶他们就可以传递同样的讯息，因为长度为 $2$ 的路径可以传递原来的讯息，原因显然。

度数为 $1$ 的点没用，因为只有一个点在他旁边可以直接调整，所以我们预先把这些全部拿下。

因为这个点只和相邻的点有关所以容易发现各个连通块之间独立，一个无解全部无解。

容易发现像这样飘在外面的链全部解决掉了之后，剩下的就会是一大堆环。

然后我们观察一下环能够干什么。

我们考虑对这个我们要构造反例也就是强制让他产生矛盾，怎么能够强制让他产生矛盾？

![](https://pic.imgdb.cn/item/65cabb0f9f345e8d036d1a78.jpg)

这是环大小为 $4$ 的一种构造方案，容易发现环长比 $4$ 大的话中间多出来的我们可以直接仿照这个构造。

这样的话当左上角那个点取 $A$ 的时候，右上取 $C$，右下取 $D$，左下取 $A$，与左上矛盾了，于是左上不得不取 $B$，于是我们发现了一个伟大的结构。

如果我们有一个节点 $x$，一个节点 $y$ 和另一个节点 $z$，其中 $y$ 和 $z$ 分别是 $x$ 的邻接点，假设 $S_x=[A,B]$，我们想要固定 $x$ 取 $B$，那么我们可以设 $S_y=[A,C]$，这样就能够强制让 $y$ 取到 $C$，而我们只要能够让 $y$ 的消息直接传到 $z$（其实就是有一个 $x$ 到 $y$，$y$ 到 $z$，$z$ 到 $x$ 三段路径拼起来的环），我们就一定能像上图一样构造出一种方案使得 $z$ 不得不取 $A$，然后出现矛盾，$x$ 就不得不取 $B$ 了。

如果你看得云里雾里也没有关系，简单来说，如果 $x$ 在任意一个简单环中，那么我们一定有办法构造方案把他锁成一个颜色。

---

然后来说一下简单环。

我们已经知道简单环能够锁定其中一个点了，那么显然的，在我们讨论的图中如果出现了两个简单环没有交点，那么他们中间一定靠一条路径连接。

显然的，第一个环可以总够构造固定在路径那一端的点的取值，而我们可以使用路径把这个消息传递到另一个环的端点让他强制取那个端点，然后我们再使用简单环将那个点强制取成另外一个点，两个限制条件出现矛盾就结束了。

![](https://pic.imgdb.cn/item/65cac0389f345e8d03780a0c.jpg)

如图，左下角被红色正方形圈起来的点由于简单环限制强制选 $B$，则通过蓝色的边我们传递出右上角被红色正方形圈起来的点强制选 $A$，但是右上角有一个和左下角一样的矩形，他又强制右上角被红色正方形圈起来的点强制选 $B$，那么右上角这个点就出现了矛盾，结束。

我们之前提到过，链可以传递讯息，那么他中间无论隔着一条怎样的链，只要没有交点，就一定能构造出矛盾方案。

而容易发现就算链的长度为 $1$ 也就是退化为孤立点（两个环有且仅有一个交点）时，同样可以构造无解方案，具体方式同上，感兴趣可以自己造一下。

---

有了上面这个结论我们可以再推一个结论出来。

假设现在有两个点，他们之间有两条路径，这两条路径只要除了他们两个之外有一个交点那就无解。

![](https://pic.imgdb.cn/item/65cac3909f345e8d037f149d.jpg)

如图，显然当有交点的时候两个红圈范围内一定是一个简单环，他们最多在两条路径交点只有一个的时候能有且仅有一个相交的地方，其他时候都是不相交的，于是直接无解了。

---


我们发现当两个环交点有且仅有一个的时候会为我们带来四度点，我们来对他讨论一手。

容易发现比四度点多的将拥有四度点的所有性质，所以我们只讨论这个。

容易发现在删去无用节点后还出现四度点的时候总共有三种情况。

首先是第一种，有二度点给他封好了，那么已经出现两个有且仅有一个交点的环了，无解。

然后是第二种，一个四度点把他封好了，那么考虑这两个四度点中间必有四条不相交的路径，否则的话四度点是锁不住的。（或者你单独领出来几对点把他单独变成环，出现两个不相交简单环，无解）

而这四条路径因为讯息可以直接传递，可以挑出来其中两条传递一个端点选了某个颜色的讯息，而另外两条传递选了另一个颜色的讯息，最后通过路径传递过去把另外一个端点的颜色全占了就好了。

![](https://pic.imgdb.cn/item/65cac7359f345e8d03877c91.jpg)

如图，当左边节点选 $A$ 时通过红色的路径会造成最右边节点的矛盾，而选 $B$ 时又会通过蓝色的路径操作最右边结点的矛盾，所以第二种情况也是无解的。

最后是第三种，用三度点给他封好了。

容易发现至少需要使用两个三度点，同上可得两个三度点之间有三条不相交的路径，那么四度点根本没地方放（如果在路径中间那么路径相交，如果在路径内部然后再自己给自己封口那么出现两个不交简单环），所以也无解。

于是我们证明了根本没有点能够在有解的前提下封住度数为 $4$ 的点，也就是说，**只要出现了度数为 $4$ 的点就无解**。

---

讨论了度数为 $4$ 的点和度数为 $2$ 的点，接下来只需要讨论一下度数为 $3$ 的点就行了。

容易发现永远没法用二度点封住三度点，一定会出现至少两个三度点，他们之间总共有三条路径，而由于二度点的性质，每两个点可以传递相同的信息，这启发我们对奇偶性分开讨论。

容易发现这几条路径必须同奇偶，否则的话连起来会出现奇环。

先来考虑全都是奇数的情况，这种情况下只需要讨论三条路径长度分别是 $3,3,1$ 的情况就可以了，如果全是 $1$ 的话会出现重边。

![](https://pic.imgdb.cn/item/65cacc4e9f345e8d0393536f.jpg)

这样构造的话两个标红的节点之间就会出现矛盾。

这意味着当出现两个三度点且他们中间的路径长度都是奇数的时候无解。

然后我们来看偶数，也就是 $2,2,2$ 的情况，容易发现 $2,2,2$ 是有解的，因为中间有一个点正好隔开了限制，使得她必须选另一个，如果是这样的话如果想要传递讯息她就必须选择和左边三度点不同的颜色来直接传递讯息，这也就意味着如果我们想要造成矛盾那么就必须使用至少两个点来封锁，这样只能封锁一个颜色，于是就有解了。

但是长度为 $2$ 的根本没有操作空间，我们之前说能传递相同讯息，但是 $2$ 这种转手丢回去的限制了我可以限制的颜色种类，譬如说我选的是 $A$，我想让对面的三度点没法选 $A$，如果只剩 $2$ 度点根本没法做到。

于是我们放宽限制，把其中一条路径放宽到长度为 $4$，容易发现我们可以构造一条链使得当我选 $A$ 的时候对方没法选 $A$ 了，那么接下来的操作就是直接通过大小为 $4$ 的环将他锁成 $A$，问题就结束了吧！

这只是选 $A$ 的情况，容易发现只要我不选 $A$ 的话有两种可能。

1. 讯息传递不出去。
2. 讯息传递出去了，但是环上构造的锁定选 $A$ 的情况就和链的情况对应上了。

于是容易发现当有一条路径放宽到 $4$ 的时候仍有解。

那我们把两条路径放宽到 $4$ 呢？

容易发现当我们把两条路径放宽到 $4$ 的时候，我们可以仿照奇数的构造方法，用两条链换出两种选择下对面固定的颜色，最后再用中间的一个二度点把这几个选择方案叉到一起就能构造出矛盾了。

---

上面只讨论了仅有两个三度点的情况，如果有比这个数量还要多的三度点怎么办？

容易发现如果是这样的话两个三度点之间必能找出有交点的路径，所以直接无解。

---

然后这个题就做完了。

总结一下图有解的条件。

1. 必须是二分图。
2. 去除无用节点后不能有四度点。
3. 去除无用节点后要么没有三度点，要么有且仅有两个三度点且中间有至少两个二度点将他们直接连接。

---

很炫酷的一个题，路径不能有交点的结论根本没想到，导致四度点都没证出来。

---

## 作者：Cx114514 (赞：2)

### 题目链接：[[BJOI2018] 染色](https://www.luogu.com.cn/problem/P4429)

奇妙题目。

如果该图不是二分图，一定无解（直接黑白染色）。

接下来考虑是二分图的情况。

首先可以把那些度数为 $1$ 的点删去，因为那些一定是有解的。剩下的点度数至少为 $2$。

一个偶环一定有解。

证明：如果每个点的染色集合一样，直接二分图染色。否则，一定存在两个相邻的点 $x,y$ 使得 $x$ 和 $y$ 的染色集合不一样，令 $x$ 染上 $y$ 的集合中没有的那种颜色，从 $x$ 和 $y$ 间破环成链，在链上直接染色，$y$ 最终不会和 $x$ 相同。

考虑这样的一个四元环：

![](https://cdn.luogu.com.cn/upload/image_hosting/55y29qkk.png)

不难发现左上角的点只能选 $\text{A}$，依靠此性质，我们可以构造出无解的情况如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/oco4p5o6.png)

这样就能保证上方的环和下方的环至少有一个冲突。

如下图，对上述情况进行扩展，该情况下也无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/478m34ew.png)

可以发现，只要两个环之间连通，且两个环的非公共部分大小均 $\ge 2$（放得下 $\text{AC}$ 和 $\text{BC}$），就一定无解。

接下来分类讨论：

- 所有点度数均为 $2$，是一个偶环，有解。

- 最大度数为 $3$，且有 $2$ 个度数为 $3$ 的点（不存在只有 $1$ 个度数为 $2$ 的点的情况，因为总度数一定是偶数）。

有 $2$ 种情况。

1. $2$ 个点不相交，由若干条边连接。

2. $2$ 个环有相交点。

第 $1$ 种情况一定无解，考虑第 $2$ 种情况。

上文提到，如果非公共大小均 $\ge 2$，则无解，我们放到图上来看一下。

令这两个度数为 $3$ 的点为 $u$ 和 $v$，可以看作 $u\sim v$ 之间有 $3$ 条路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/kyavnxh0.png)

如上图，把 $u\sim x\sim v$ 的路径看作 $2$ 个环的公共路径，则另外 $2$ 条路径则是 $2$ 个环的非公共部分，因为均 $\ge 2$，所以无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/mjdsdrnj.png)

如上图，无论选择哪一条路径当作公共路径，均至少存在一条路径上点数 $\le 2$，故一定有解。

不难得出结论：在该种情况下，有解当且仅当 $u$ 和 $v$ 之间至少存在两条路径点数 $\le 2$。

- 最大度数为 $3$，且有 $2$ 个以上度数为 $3$ 的点。

该种情况一定无解，证明如下：

首先构造一种有 $2$ 个度数为 $3$ 的点的有解情况。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4xz3i7vk.png)

其它度数为 $3$ 的点一定连着若干个环，且一定是挂在原图上若干个度数为 $2$ 的点上的。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/46ome1gg.png)

这样的图其中包含不相交且通过若干条边连接的 $2$ 个环，一定是无解的。

- 最大度数 $\ge 4$。

存在一个点连出去至少 $4$ 条边。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mutblopo.png)

图中方块中要么是单独若干个环，要么和另外一条边形成若干个环，则图中至少有两个环，一定无解。

综上，有解当且仅当图是偶环或图中最大度数为 $3$ 且度数为 $3$ 的点有 $2$ 个且两点之间至少存在 $2$ 条经过点数 $<2$ 的路径。

具体实现：

把度数为 $1$ 的点删去可以用类似拓扑排序的方式。

找长度为 $1$ 的路径可以直接判断，长度为 $2$ 的路径可以枚举中间点。

具体实现见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

int T, n, m, ok, cnt, b, col[10005], deg[10005];

vector < int > G[10005], B[10005];

queue < int > q;

void dfs(int u)
{
	B[cnt].push_back(u);
	if (ok) return;
	if (!col[u]) col[u] = 1;
	for (int i = 0; i < G[u].size(); i++)
	{
		int v = G[u][i];
		if (!col[v]) 
		{
			col[v] = 3 - col[u];
			dfs(v);
		}
		else if (col[u] == col[v]) 
		{
			ok = 1;
			break;
		}
	}
}

int main()
{
	cin >> T;
	while (T--)
	{
		for (int i = 1; i <= n; i++)
			G[i].clear();
		for (int i = 1; i <= n; i++)
			col[i] = 0;
		for (int i = 1; i <= n; i++)
			deg[i] = 0;
		for (int i = 1; i <= cnt; i++)
			B[i].clear();
		b = 0;
		cnt = 0;
		cin >> n >> m;
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			cin >> u >> v;
			G[u].push_back(v);
			G[v].push_back(u);
			deg[u]++;
			deg[v]++;
		}
		for (int i = 1; i <= n; i++)
			if (!col[i])
			{
				cnt++;
				ok = 0;
				dfs(i);
				if (ok)
				{
					cout << "NO\n";
					b = 1;
					break;
				}
			}
		if (b) continue;
		for (int i = 1; i <= n; i++)
			if (deg[i] == 1)
			{
				q.push(i);
			}
		while (!q.empty())
		{
			int t = q.front();
			q.pop();
			for (int i = 0; i < G[t].size(); i++)
			{
				int v = G[t][i];
				deg[v]--;
				if (deg[v] == 1) q.push(v);
			}
		}
		for (int i = 1; i <= cnt; i++)
		{
			int maxdeg = 0, cnt3deg = 0;
			for (int j = 0; j < B[i].size(); j++)
			{
				int u = B[i][j];
				maxdeg = max(maxdeg, deg[u]);
				if (deg[u] == 3) cnt3deg++;
			}
			if ((maxdeg == 3 && cnt3deg > 2) || maxdeg > 3)
			{
				cout << "NO\n";
				b = 1;
				break;
			}
			if (maxdeg == 3 && cnt3deg == 2)
			{
				int x = 0, y = 0;
				for (int j = 0; j < B[i].size(); j++)
				{
					int u = B[i][j];
					if (deg[u] == 3) 
					{
						if (!x) x = u;
						else y = u;
					}
				}
				int tot = 0;
				for (int j = 0; j < G[x].size(); j++)
					if (G[x][j] == y) tot++;
				for (int j = 0; j < B[i].size(); j++)
				{
					int u = B[i][j];
					int vis1 = 0, vis2 = 0;
					for (int k = 0; k < G[u].size(); k++)
					{
						int v = G[u][k];
						if (v == x) vis1++;
						if (v == y) vis2++;
					}
					if (vis1 && vis2) tot++;
				}
				if (tot < 2)
				{
					cout << "NO\n";
					b = 1;
					break;
				}
			}
		}
		if (b) continue;
		cout << "YES\n";
	}
	return 0;
}
```

---


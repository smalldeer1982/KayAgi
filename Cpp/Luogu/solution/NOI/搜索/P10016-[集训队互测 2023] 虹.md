# [集训队互测 2023] 虹

## 题目描述

给定一棵 $n$ 个点的树。

- 称点集 $S$ **连通**，当且仅当 $\forall u,v \in S$，所有 $u$ 到 $v$ 的简单路径上的点均在 $S$ 中。
- 称点集 $S$ 是 $[l,r]$ 的**虹**，当且仅当 $S$ **连通**，且 $S$ 包含 $[l,r]$ 中的所有点。
- 称点集 $S_0$ 是 $[l,r]$ 的**最小虹**，当且仅当 $S_0$ 是 $[l,r]$ 的所有**虹**中大小最小的。可以证明，$S_0$ 是唯一的。

点带权，点 $u$ 的权值为 $w_u$，初始所有点权均为 $0$。同时，给定序列 $\{z_1,z_2,\cdots,z_n\}$。

给定 $q$ 次命令，每次命令形如以下两类之一：

- `1 l r`：令 $S_0$ 为 $[l,r]$ 的**最小虹**，$\forall u \in S_0$，将 $w_u$ 加 $1$。
- `2 l r u`：求 $\left(\sum_{i=l}^r 19901991^{z_{\gcd(i,u)} w_i} \right) \bmod {20242024}$ 的值。

## 说明/提示

**本题采用捆绑测试**。

对于所有测试数据保证：$1 \le n, q \le 8 \times 10^4,0 \le z_i \le 10^9$，所有命令满足 $1 \le l \le r \le n, 1 \le u \le n$，**保证第一类命令的 $(l,r)$ 随机生成**。随机生成方式如下：
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $l$。
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $r$。
- 若 $l>r$，则交换 $l,r$。

| 子任务编号 | 分值 | $n \le$ | $q \le$ | 特殊性质 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :----------: |
| $1$ | $10$ | $10^3$ | $10^3$ | 无 | 无 |
| $2$ | $20$ | $65536$ | $65536$ | A, B | 无 |
| $3$ | $20$ | $65536$ | $65536$ | A | 依赖于子任务 $2$ |
| $4$ | $30$ | $65536$ | $65536$ | 无 | 依赖于子任务 $1,2,3$ |
| $5$ | $20$ | $80000$ | $80000$ | 无 | 依赖于子任务 $1,2,3,4$ |

特殊性质 A：保证所有第二类命令均在所有第一类命令之后。

特殊性质 B：保证第二类命令次数 $\le 20$。

## 样例 #1

### 输入

```
5 4
1 0 0 0 1
1 2
1 3
3 4
3 5
1 2 3
2 1 3 3
1 4 5
2 3 5 3```

### 输出

```
19561959
19561959```

# 题解

## 作者：yyyx_ (赞：7)

### 题意

$q$ 次查询：

- `1 l r`：令 $S_0$ 为 $[l,r]$ 的**最小虹**，$\forall u \in S_0$，将 $w_u$ 加 $1$。
- `2 l r u`：求 $\left(\sum_{i=l}^r 19901991^{z_{\gcd(i,u)} w_i} \right) \bmod {20242024}$ 的值。

### Solution

注意到 $19901991^2 \equiv 1 \pmod{20242024}$。

问题转变为求 $\sum_{i=l}^r [z_{\gcd(i,u)} \bmod 2 = 1 \wedge w_i \bmod 2 = 1]$。

令上述式子的值为 $V$，询问的区间为 $[L,R]$。容易得到答案为 $19901991\times V + R - L + 1 - V$，化简得 $19901990\times V + R - L + 1$。

模 $2$ 意义下的 $+1$ 等价于 $\operatorname{xor} 1$，这启发我们使用 `bitset` 维护。

考虑分块。把操作离线下来，对于修改区间为 $[L,R]$ 的 $1$ 操作：

- $L,R$ 不属于同一块：

  可以把 $[L,R]$ 拆成 $[L,p],[p + 1,R]$ 两个区间。令 $p$ 为某一块的右端点，把所有 $1$ 操作按 $p$ 排序。
  
  对于每一块，从它的右端点 $p'$ 遍历到 $1$，每次加入一个点。从这个点不断地跳父亲，经过的所有点都标记为 $1$，直到当前跳到的点已经被访问。令该过程的标记数组为 $S$。

  在加入点的过程中，所有点的公共祖先深度单调不降。我们维护祖先所在的点编号 $pos$，$T$ 表示祖先到树根简单路径的节点 `bitset`，令 $1$ 表示节点在该路径上，$0$ 反之。则每次加入点后让 $pos$ 一直跳父亲，将经过的点设为 $0$，直到跳到了新的公共祖先。

  `S ^ T` 的 `bitset` 集合即为 $[L,p]$ 的最小虹，把这个集合存下来。

  对于 $[p + 1,R]$ 的处理同理。

  某种实现会带来一个问题：左部分与右部分不相连。这个时候可以把左部分与右部分的 `lca` 和他们公共的 `lca` 挂在节点上，`dfs` 维护一个 `bitset`，到哪个点就处理一下 $S_i$ 即可。

  容易证明每个节点只会被访问一次，总复杂度 $O(n\sqrt n)$。

- $L,R$ 属于同一块：

  我们没有什么好方法去处理这种情况。题目保证了 $L,R$ 在 $[1,n]$ 中等概率随机，所以期望下 $L,R$ 属于同一块的次数为 $O(\sqrt n)$。

  类似第一种，对于 $[L,R]$ 每个点跳父亲，暴力 $O(n)$ 处理这种情况下的 `bitset` 即可。

  总复杂度 $O(n\sqrt n)$。

对于每个 $2$ 操作，将他们的 `bitset` 中的 $[L,R]$ 位全部置为 $1$，其他都置为 $0$。

把操作按原顺序拍回去。令 $S_i$ 是上面预处理的 `bitset`。令 `bitset` 类型的 $ans$ 初始全为 $0$。若为 $1$ 操作则令 $ans\gets ans \operatorname{xor} S_i$；若为 $2$ 操作则令 $S_i\gets S_i \operatorname{and} ans$。

对于 $z_i$，我们可以直接爆搜所有质数乘积组合。过程中注意要有 $vis$ 数组，不然复杂度会退化。维护一个 $T$ 表示第 $i$ 位上是奇数还是偶数。搜到 $u$ 直接将对应的询问 $S_i \gets S_i \operatorname{and} T$ 即可。

时间复杂度大约是 $O(n\sqrt n)$，据说是 $O(4\times 10^7)$。

总复杂度 $O(n\sqrt n + \frac{nq}{w})$。

输出时使用 `bitset<N>().count()` 统计即可。

我的代码真的很长，还是打的时候没带脑子了哎。


```cpp
#include <bits/stdc++.h>
using namespace std;

namespace Fread
{
    const int SIZE = 1 << 21;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 21;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct POPOSSIBLE
    {
        ~POPOSSIBLE() { flush(); }
    } ztr;
}
#define getchar Fread::getchar
#define putchar Fwrite::putchar
namespace Fastio
{
    struct Reader
    {
        template <typename T>
        Reader &operator>>(T &x)
        {
            char c = getchar();
            T f = 1;
            while (c < '0' || c > '9')
            {
                if (c == '-')
                    f = -1;
                c = getchar();
            }
            x = 0;
            while (c >= '0' && c <= '9')
            {
                x = x * 10 + (c - '0');
                c = getchar();
            }
            x *= f;
            return *this;
        }
        Reader &operator>>(char &c)
        {
            c = getchar();
            while (c == ' ' || c == '\n')
                c = getchar();
            return *this;
        }
        Reader() {}
    } cin;
    struct Writer
    {
        template <typename T>
        Writer &operator<<(T x)
        {
            if (x == 0)
            {
                putchar('0');
                return *this;
            }
            if (x < 0)
            {
                putchar('-');
                x = -x;
            }
            static int sta[45];
            int top = 0;
            while (x)
            {
                sta[++top] = x % 10;
                x /= 10;
            }
            while (top)
            {
                putchar(sta[top] + '0');
                --top;
            }
            return *this;
        }
        Writer &operator<<(char c)
        {
            putchar(c);
            return *this;
        }
        Writer &operator<<(const char *str)
        {
            int cur = 0;
            while (str[cur])
                putchar(str[cur++]);
            return *this;
        }
        Writer() {}
    } cout;
}
#define endl '\n'
#define cin Fastio::cin
#define cout Fastio::cout
#define de(x) cerr << '[' << #x << ' ' << '=' << ' ' << x << ']' << ' '
#define ed() cerr << endl
const int N = 8e4 + 2;
const int B = 283;
typedef long long ll;
constexpr void dd(bitset<N> &x)
{
    for (int i = 0; i <= 10; i++)
        cerr << x[i];
}

int n, q, z[N];
vector<int> g[N];
bitset<N> b[N], S, T;
struct node1
{
    int l, r, id;
};
vector<node1> md;
struct node2
{
    int u, id;
};
vector<node2> qy;
int dfn[N], pos;
int f[N][18], fa[N];
void dfs0(int x)
{
    f[dfn[x] = ++pos][0] = fa[x];
    for (auto y : g[x])
    {
        if (y == fa[x])
            continue;
        fa[y] = x;
        dfs0(y);
    }
}
int Min(int x, int y)
{
    return dfn[x] < dfn[y] ? x : y;
}
void init()
{
    dfs0(1);
    for (int j = 1; j <= __lg(n); j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            f[i][j] = Min(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
}
int lca(int x, int y)
{
    if (x == y)
        return x;
    x = dfn[x];
    y = dfn[y];
    if (x > y)
        swap(x, y);
    ++x;
    int t = __lg(y - x + 1);
    return Min(f[x][t], f[y - (1 << t) + 1][t]);
}
int blo[N];
void init2()
{
    int cnt = 0;
    for (int l = 1; l <= n; l += B)
    {
        ++cnt;
        int r = min(n, l + B - 1);
        for (int i = l; i <= r; i++)
            blo[i] = cnt;
    }
}
int st[N][18];
void init3()
{
    for (int i = 1; i <= n; i++)
        st[i][0] = i;
    for (int j = 1; j <= __lg(n); j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            st[i][j] = lca(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
}
int totlca(int x, int y)
{
    int t = __lg(y - x + 1);
    return lca(st[x][t], st[y - (1 << t) + 1][t]);
}
int idx[N];
vector<pair<int, int>> tmp[B + 2];
vector<int> br0[N];
vector<int> prime;
vector<bool> isPrime;
void LinearSieves(const int n)
{
    isPrime.resize(n + 1, 1);
    isPrime[0] = isPrime[1] = 0;
    for (int i = 2; i <= n; i++)
    {
        if (isPrime[i])
        {
            prime.emplace_back(i);
        }
        for (int &x : prime)
        {
            if (i * x > n)
                break;
            isPrime[i * x] = 0;
            if (i % x == 0)
            {
                break;
            }
        }
    }
}
void dfs(int x)
{
    // de(x), dd(S), ed();
    T[x] = 1;
    for (auto &id : br0[x])
        b[id] &= S;
    for (auto &P : prime)
    {
        x *= P;
        if (x > n)
            break;
        if (!T[x])
        {
            vector<bool> trp(1, 0);
            for (int i = P; i <= n; i += P)
                trp.emplace_back(bool(S[i])), S[i] = z[__gcd(x, i)];
            dfs(x);
            for (int i = P; i <= n; i += P)
                S[i] = trp[i / P];
        }
        x /= P;
    }
}
int len[N];
const int mod = 20242024;
vector<int> b0[N], b1[N];
void dfs2(int x)
{
    for (auto id : b1[x])
        b[id] |= S;
    S[x] = 1;
    for (auto y : g[x])
    {
        if (y == fa[x])
            continue;
        dfs2(y);
    }
    S[x] = 0;
    for (auto id : b0[x])
        b[id] ^= S;
}

signed main()
{
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
        cin >> z[i], z[i] &= 1;
    for (int i = 1, x, y; i < n; i++)
    {
        cin >> x >> y;
        g[x].emplace_back(y);
        g[y].emplace_back(x);
    }
    init();
    init2();
    for (int i = 1; i <= q; i++)
    {
        int op;
        cin >> op;
        if (op == 1)
        {
            int l, r;
            cin >> l >> r;
            md.emplace_back(node1{l, r, i});
            if (blo[l] != blo[r])
                tmp[blo[r / B * B]].emplace_back(l, i);
        }
        else
        {
            int l, r, u;
            cin >> l >> r >> u;
            len[i] = r - l + 1;
            if (len[i] >= B)
                idx[i] = r / B * B;
            b[i].set();
            b[i] >>= N - len[i];
            b[i] <<= l;
            qy.emplace_back(node2{u, i});
        }
    }
    int bcnt = (n + B - 1) / B;
    for (int i = 1; i <= bcnt; i++)
    {
        sort(tmp[i].begin(), tmp[i].end());
        // for (auto x : tmp[i])
        //     de(i), de(x.first), de(x.second), ed();
    }
    for (int l = 1; l <= n; l += B)
    {
        int r = min(n, l + B - 1);
        auto &h = tmp[blo[r]];
        int j = h.size() - 1;
        if (~j)
        {
            auto jmp = [&](int x)
            {
                while (x && !S[x])
                {
                    S[x] = 1;
                    x = fa[x];
                }
            };
            S.reset();
            jmp(r);
            T = S;
            T[r] = 0;
            int tag = r;
            auto clear = [&](int gl)
            {
                while (tag != gl)
                {
                    T[tag] = 0;
                    tag = fa[tag];
                }
                T[tag] = 0;
            };
            while (~j && h[j].first == r)
            {
                b[h[j].second] |= S ^ T;
                --j;
            }
            if (!~j)
                continue;
            for (int i = r - 1; i >= 1; i--)
            {
                jmp(i);
                clear(lca(tag, i));
                while (~j && h[j].first > i)
                    --j;
                while (~j && h[j].first == i)
                {
                    b[h[j].second] |= S ^ T;
                    --j;
                }
                if (!~j)
                    break;
            }
        }
    }
    // for (auto &[l, r, id] : md)
    //     dd(b[id]), ed();
    for (int i = 1; i <= bcnt; i++)
    {
        tmp[i].clear();
    }
    for (auto &[l, r, id] : md)
    {
        if (blo[l] != blo[r])
        {
            int R = r / B * B;
            if (R != r)
                tmp[blo[R + 1]].emplace_back(r, id);
        }
    }
    for (int i = 1; i <= bcnt; i++)
    {
        sort(tmp[i].begin(), tmp[i].end(), greater<pair<int, int>>());
        // for (auto x : tmp[i])
        //     de(i), de(x.first), de(x.second), ed();
    }
    for (int l = 1; l <= n; l += B)
    {
        int r = min(n, l + B - 1);
        auto &h = tmp[blo[r]];
        int j = h.size() - 1;
        if (~j)
        {
            auto jmp = [&](int x)
            {
                while (x && !S[x])
                {
                    S[x] = 1;
                    x = fa[x];
                }
            };
            S.reset();
            jmp(l);
            T = S;
            T[l] = 0;
            int tag = l;
            auto clear = [&](int gl)
            {
                while (tag != gl)
                {
                    T[tag] = 0;
                    tag = fa[tag];
                }
                T[tag] = 0;
            };
            while (~j && h[j].first == l)
            {
                b[h[j].second] |= S ^ T;
                --j;
            }
            if (!~j)
                continue;
            for (int i = l + 1; i <= n; i++)
            {
                jmp(i);
                clear(lca(tag, i));
                while (~j && h[j].first < i)
                    --j;
                while (~j && h[j].first == i)
                {
                    b[h[j].second] |= S ^ T;
                    --j;
                }
                if (!~j)
                    break;
            }
        }
    }
    init3();
    for (auto &[l, r, id] : md)
    {
        if (blo[l] == blo[r])
        {
            auto jmp = [&](int x)
            {
                while (x && !S[x])
                {
                    S[x] = 1;
                    x = fa[x];
                }
            };
            S.reset();
            jmp(l);
            T = S;
            T[l] = 0;
            int tag = l;
            auto clear = [&](int gl)
            {
                while (tag != gl)
                {
                    T[tag] = 0;
                    tag = fa[tag];
                }
                T[tag] = 0;
            };
            for (int i = l + 1; i <= r; i++)
            {
                jmp(i);
                clear(lca(tag, i));
            }
            b[id] |= S ^ T;
            // dd(b[id]), ed();
            // dd(S), ed();
            // dd(T), ed();
        }
        else
        {
            int R = r / B * B;
            if (R != r)
            {
                b1[totlca(l, R)].emplace_back(id);
                b1[totlca(R + 1, r)].emplace_back(id);
                b0[totlca(l, r)].emplace_back(id);
            }
        }
    }
    // for (auto &[l, r, id] : md)
    //     dd(b[id]), ed();
    S.reset();
    dfs2(1);
    auto op = md.begin();
    S.reset();
    for (auto &[u, id] : qy)
    {
        while (op != md.end() && (*op).id < id)
            S ^= b[(*op).id], ++op;
        b[id] &= S;
        br0[u].emplace_back(id);
    }
    LinearSieves(n);
    S.reset();
    T.reset();
    for (int i = 1; i <= n; i++)
        S[i] = z[1];
    for (auto &P : prime)
    {
        for (int i = P; i <= n; i += P)
            S[i] = z[P];
        dfs(P);
        for (int i = P; i <= n; i += P)
            S[i] = z[1];
    }
    for (auto &id : br0[1])
        b[id] &= S;
    for (auto &[u, id] : qy)
    {
        cout << (19901990ll * b[id].count() + len[id]) % mod << endl;
    }

    return 0;
}
```

---

## 作者：ducati (赞：5)

## 题目大意

给定一棵 $n$ 个点的树。

- 称点集 $S$ **连通**，当且仅当 $\forall u,v \in S$，所有 $u$ 到 $v$ 的简单路径上的点均在 $S$ 中。
- 称点集 $S$ 是 $[l,r]$ 的**虹**，当且仅当 $S$ **连通**，且 $S$ 包含 $[l,r]$ 中的所有点。
- 称点集 $S_0$ 是 $[l,r]$ 的**最小虹**，当且仅当 $S_0$ 是 $[l,r]$ 的所有**虹**中大小最小的集合。可以证明，$S_0$ 是唯一的。

点带权，点 $u$ 的权值为 $w_u$。初始所有点权均为 $0$。同时，给定序列 $\{z_1,z_2,\cdots,z_n\}$。

给定 $q$ 次命令，每次命令形如以下两类之一：

- `1 l r`：令 $S_0$ 为 $[l,r]$ 的**最小虹**，$\forall u \in S_0$，将 $w_u$ 加 $1$。
- `2 l r u`：求 $\left(\sum_{i=l}^r 19901991^{z_{\gcd(i,u)} w_i} \right) \bmod {20242024}$ 的值。

## 数据范围

对于所有测试数据保证，$1 \le n, q \le 8 \times 10^4,0 \le z_i \le 10^9$，所有命令满足 $1 \le l \le r \le n, 1 \le u \le n$，**保证第一类命令的 $(l,r)$ 随机生成**。随机生成方式如下：

- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $l$。
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $r$。
- 若 $l>r$，则交换 $l,r$。

## 解题过程

### Part 1

注意到 $19901991^2 \equiv 1 \pmod {20242024}$。令 $c$ 为满足 $i \in [l,r], z_{\gcd(i,u)} \equiv w_i \equiv 1 \pmod 2$ 的 $i$ 数量，则答案为 $(19901991c + r-l+1-c) \bmod {20242024}$。

考虑 bitset。假设已知 $\{w_1 \bmod 2,w_2 \bmod 2,\cdots,w_n \bmod 2\}$ 及 $\{z_{\gcd(1,u)} \bmod 2,z_{\gcd(2,u)} \bmod 2,\cdots,z_{\gcd(n,u)} \bmod 2\}$ 对应的 bitset（不妨称作 $W,Z$），通过按位与、$\text{popcount}$ 即可算出 $c$。关键在于如何维护 $W,Z$。

### Part 2

加一在模 $2$ 意义下等价于取反。那么，只要对每个 $(l,r)$ 求出了 $S_0$，则容易通过按位异或，递推出所有的 $W$。

令 $t$ 为 $l,l+1,\cdots,r$ 的 LCA 的父节点，$P_u$ 为 $t$ 到根路径对应的点集，$S'_0 = P_l \cup P_{l+1} \cup \cdots \cup P_r$，则 $S_0 = \complement_{S'_0}  P_{t}$。使用类似 ST 表的结构容易算出 $t$。考虑如何计算 $S'_0$。

考虑分块，令块长为 $B$，当块长较小时，由于第一类命令的 $(l,r)$ 随机，几乎所有 $[l,r]$ 满足 $l,r$ 属于不同块。我们将 $[l,r]$ 拆成三部分，即某个块的后缀，若干个连续的块，和某个块的前缀。先考虑如何计算：某个块的前缀对应的 $P$ 的并。我们枚举每个块，从前往后加入每个点，维护前缀各 $P$ 的并；每当加入新点时，我们从新加入的点往上跳，若 bitset 在该处已经是 $1$ 则结束，否则将其设为 $1$ 并继续往上跳。另两部分同理。通过均摊分析，时间复杂度 $O(\frac {n^2} {B})$。

此外，每对 $(l,r)$ 有 $O(\frac {B} {n})$ 的概率属于同一块，此时暴力 $O(n)$ 求出 $S_0$，时间复杂度 $O(qB)$。

令 $B = \frac {n} {\sqrt q}$，本部分复杂度 $O(n \sqrt q+\frac {nq} {\omega})$。

### Part 3

考虑如何求 $Z$。

考虑直接暴力。离线下来，从小到大爆搜 $u$ 所有质因子及幂次，在此过程中维护 $\gcd(1,u),\gcd(2,u),\cdots,\gcd(n,u)$ 及 $Z$。

乍一看复杂度很不对，但实际上跑得飞快。写个程序算一下，发现当 $n = 80000$ 时最多更新 $43474197$ 次。

本部分复杂度 $O(X + \frac {nq} {\omega})$，其中 $X$ 表示更新次数 $(X \le 43474197)$。

总复杂度 $O(n \sqrt q + X + \frac {nq} {\omega})$，可以通过本题。

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P10016)

**题目大意**

> 给定 $n$ 个点的树以及 $z_1\sim z_n$，初始 $w_1\sim w_n$ 全为 $0$，支持如下操作：
>
> - 给定 $l,r$，将编号在 $[l,r]$ 内的节点构成的斯坦纳树上每个点 $u$ 的 $w_u$ 加一，保证 $l,r$ 随机。
> - 给定 $l,r,u$，求 $\sum_{i=l}^r X^{z_{gcd(i,u)}w_i}\bmod Y$，其中 $X=19901991,Y=20242024$。
>
> 数据范围：$n,q\le 80000$。

**思路分析**

注意到 $X^2=Y$，因此我们只关心 $\sum_{i=l}^r (z_{\gcd(i,u)}w_i\bmod 2)$。

考虑用 `bitset` 维护，我们用一个 `bitset` 维护当前所有 $w_i\bmod 2$ 的值，一个 `bitset` 维护所有 $z_{\gcd(i,u)}$ 的值，取交后左移右移一段距离去掉区间外的点即可。

先尝试用 `bitset` 维护所有 $w_i\bmod 2$ 的值。

那么我们只要对于每个操作一，求出 $[l,r]$ 斯坦纳树的点集，这可以看成 $l\sim r$ 到根的链并，减去根到区间 $\mathrm{LCA}$ 父亲的路径。

第二部分是容易处理掉的，因此我们只要求 $[l,r]$ 节点到根的链并。

考虑分块，如果 $l,r$ 跨过了某个块，那么我们就能把 $[l,r]$ 的链并看成 $[l,kB],(kB,r]$ 两部分的并。

对于每个关键点 $kB$，考虑算出每个后缀的链并，重复修改是无意义的，那么在后缀增加的过程中，均摊增量是 $\mathcal O(n)$ 级别，前缀同理。

因此对每个关键点算前后缀链并，复杂度 $\mathcal O\left(\dfrac{n^2}B\right)$。

对于一个 $[l,r]$ 被某个块完全包含的询问，由于数据随机，因此这种情况出现概率并不高，仅为 $\mathcal O\left(\dfrac Bn\right)$ 级别，每次 $\mathcal O(n)$ 暴力可以做到 $\mathcal O(qB)$。

取 $B=\dfrac n{\sqrt q}$ 得到最优复杂度 $\mathcal O\left(n\sqrt q+\dfrac{nq}\omega\right)$。

那么我们只要对每个 $u$ 求出 $z_{\gcd(i,u)}\bmod 2$ 对应的 `bitset`，考虑如何刻画所有 $\gcd(i,u)$。

考虑爆搜 $u$ 的所有质因子，当 $u$ 的某个质因子 $p$ 指数从 $p^c\to p^{c+1}$ 变化时，会把 $p^{c+1}\mid i$ 的 $\gcd(i,u)$ 乘以 $p$。

暴力维护这个过程，精细实现后计算量 $T(n)\approx4.3\times 10^7$。

时间复杂度 $\mathcal O\left(n\sqrt q+\dfrac{nq}\omega+T(n)\right)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=8e4+5,B=282,X=19901991,Y=20242024;
int n,q,z[MAXN],bel[MAXN],lp[MAXN],rp[MAXN];
vector <int> G[MAXN];
int fa[MAXN],dfn[MAXN],dcnt,st[MAXN][18],dl[MAXN][18],dr[MAXN][18];
int bit(int x) { return 1<<x; }
int cmp(int x,int y) { return dfn[x]<dfn[y]?x:y; }
int qdl(int l,int r) {
	int k=__lg(r-l+1);
	return min(dl[l][k],dl[r-bit(k)+1][k]);
}
int qdr(int l,int r) {
	int k=__lg(r-l+1);
	return max(dr[l][k],dr[r-bit(k)+1][k]);
}
int lca(int l,int r) {
	int k=__lg(r-l+1);
	return cmp(st[l][k],st[r-bit(k)+1][k]);
}
void dfs0(int u,int fz) {
	fa[u]=fz,dl[u][0]=dr[u][0]=dfn[u]=++dcnt,st[dcnt][0]=fz;
	for(int v:G[u]) if(v^fz) dfs0(v,u);
}
int op[MAXN],ql[MAXN],qr[MAXN];
bitset <MAXN> F[MAXN],S;
vector <int> wl[MAXN],wr[MAXN],wx[MAXN],LCA[MAXN];
void add(bitset<MAXN>&s,int u) { for(;u&&!s[u];u=fa[u]) s.set(u); }
void dfs1(int u) {
	S.set(u);
	for(int i:LCA[u]) F[i]^=S;
	for(int v:G[u]) if(v^fa[u]) dfs1(v);
	S.reset(u);
}
int pr[MAXN],tot,g[MAXN];
bool isc[MAXN];
void dfs2(int o,int x,int y) {
	for(int i:wx[x]) F[i]&=S;
	for(int i=o;i<=tot&&1ll*x*pr[i]<=n;++i) {
		int p=pr[i],w=(i==o?y*p:p);
		for(int j=w;j<=n;j+=w) S[j]=z[g[j]*=p];
		dfs2(i,x*pr[i],w);
		for(int j=w;j<=n;j+=w) S[j]=z[g[j]/=p];
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;++i) cin>>z[i],z[i]%=2;
	for(int i=1;(i-1)*B+1<=n;++i) {
		lp[i]=(i-1)*B+1,rp[i]=min(i*B,n);
		fill(bel+lp[i],bel+rp[i]+1,i);
	}
	for(int i=1,u,v;i<n;++i) cin>>u>>v,G[u].push_back(v),G[v].push_back(u);
	dfs0(1,0);
	for(int k=1;k<18;++k) for(int i=1;i+bit(k)-1<=n;++i) {
		st[i][k]=cmp(st[i][k-1],st[i+bit(k-1)][k-1]);
		dl[i][k]=min(dl[i][k-1],dl[i+bit(k-1)][k-1]);
		dr[i][k]=max(dr[i][k-1],dr[i+bit(k-1)][k-1]);
	}
	for(int i=1,x;i<=q;++i) {
		cin>>op[i]>>ql[i]>>qr[i];
		if(op[i]==1) {
			if(ql[i]==qr[i]) LCA[fa[ql[i]]].push_back(i);
			else LCA[fa[lca(qdl(ql[i],qr[i])+1,qdr(ql[i],qr[i]))]].push_back(i);
			if(bel[ql[i]]==bel[qr[i]]) for(int u=ql[i];u<=qr[i];++u) add(F[i],u);
			else wl[bel[ql[i]]].push_back(i),wr[bel[ql[i]]+1].push_back(i);
		} else cin>>x,wx[x].push_back(i);
	}
	for(int o=1;o<=bel[n];++o) {
		sort(wl[o].begin(),wl[o].end(),[&](int x,int y){ return ql[x]>ql[y]; });
		sort(wr[o].begin(),wr[o].end(),[&](int x,int y){ return qr[x]<qr[y]; });
		S.reset();
		for(int i=lp[o],j=0,s=wr[o].size();j<s;++i) {
			add(S,i);
			while(j<s&&qr[wr[o][j]]==i) F[wr[o][j++]]|=S;
		}
		S.reset();
		for(int i=rp[o],j=0,s=wl[o].size();j<s;--i) {
			add(S,i);
			while(j<s&&ql[wl[o][j]]==i) F[wl[o][j++]]|=S;
		}
	}
	S.reset(),dfs1(1);
	for(int i=1;i<=q;++i) F[i]^=F[i-1];
 	for(int i=2;i<=n;++i) if(!isc[i]) {
		pr[++tot]=i;
		for(int j=2*i;j<=n;j+=i) isc[j]=true;
	}
	S.reset();
	for(int i=1;i<=n;++i) S[i]=z[g[i]=1];
	dfs2(1,1,1);
	for(int i=1;i<=q;++i) if(op[i]==2) {
		int l=ql[i],r=qr[i];
		F[i]>>=l,F[i]<<=(MAXN-(r-l+1));
		int s=F[i].count();
		cout<<(1ll*s*(X-1)+r-l+1)%Y<<"\n";
	}
	return 0;
}
```

---

## 作者：Larunatrecy (赞：2)

很神奇的题。

我们可以发现 ${19901991}^2\equiv 1\pmod {20242024}$

也就是说，如果 $2|z_{\gcd(i,u)}w_i$，贡献为 $1$，否则贡献为 $19901991$ 。

记 $C$ 为满足 $z_{\gcd(i,u)}\equiv w_i\equiv 1\pmod 2$ 的 $i$ 的个数，那么答案就是 $(19901991C+r-l+1-C)\bmod 19901991$ 。

考虑维护出来 $z_{\gcd(i,u)}\bmod 2$ 以及 $w_i\bmod 2$ 形成的两个 $\text{bitset}$ ( 分别记为 $Z_i,W_i$ ) ,然后按位与之后查询区间 $\text{popcount}$ 即可。

关键在于维护 $Z_i,W_i$ 。

## $Z_i$ 怎么求

考虑暴搜 $u$ ，每次给 $u$ 添一个质因子，动态维护 $\gcd(u,i)$ 。

如果添加的质因子是 $p$，添加后 $u$ 里 $p$ 的指数是 $c$ ，那么变化为：所有 $p^c$ 的倍数的 $\gcd$ 乘一个 $p$ 。

打一个表可以发现，$n=8\times 10^4$ 时总变化量是 $43474197$ 。

## $W_i$ 怎么求

假如我们能对于每个修改操作，维护出其虚树 $S_0$ ，那么加一对于 $W$ 的影响就是异或上 $S_0$ 。

$S_0$ 可以看成是区间内所有点到根的路径并然后刨去区间内所有点的 $\text{lca}$ 的父亲到根的路径，后者是简单的。

前者我们考虑分块，把序列每 $B$ 个元素分成一个块。

如果操作区间不在块内，那么区间内必定存在某个块的结尾 $ed$，以及下个块的开始 $st$。

注意到因为树上点一共就 $n$ 个，所以我们可以在 $O(n)$ 的时间内求出任意一个点集的 $\text{bitset}$，同时可以动态加点 。

那我们离线下来，求出从每个 $ed$ 向前加点的点集，以及从每个 $st$ 向后加点的点集，因为 $st,ed$ 只有 $O(\frac{n}{B})$ 种，所以复杂度 $O(\frac{n^2}{B})$ 。

如果操作区间在块内，其实我们是没有什么好办法的，所以题目才保证了 $l,r$ 随机，这样的话，随机在一个块里的概率是 $\frac{B}{n}$，还是用上述办法暴力求，期望复杂度 $O(qB)$ 。

平衡一下，取 $B=\frac{n}{\sqrt q}$，这一部分复杂度 $O(n\sqrt q+\frac{nq}{w})$ 。

总复杂度 $O(n\sqrt q+\frac{nq}{w})$，代码很好写。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 8e4+7;
int n,m;
int z[N];
struct edge 
{
	int y,next;
}e[2*N];
int flink[N],t=0;
void add(int x,int y)
{
	e[++t].y=y;
	e[t].next=flink[x];
	flink[x]=t;
}
int fa[N],dep[N],siz[N],son[N],top[N];
void dfs(int x,int pre)
{
	siz[x]=1;
	fa[x]=pre;
	dep[x]=dep[pre]+1;
	for(int i=flink[x];i;i=e[i].next)
	{
		int y=e[i].y;
		if(y==pre)continue;
		dfs(y,x);
		siz[x]+=siz[y];
		if(siz[y]>siz[son[x]])son[x]=y;
	}
}
void Exdfs(int x,int topth)
{
	top[x]=topth;
	if(!son[x])return;
	Exdfs(son[x],topth);
	for(int i=flink[x];i;i=e[i].next)
	{
		int y=e[i].y;
		if(y==fa[x]||y==son[x])continue;
		Exdfs(y,y);
	}
}
int qlca(int x,int y)
{
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
bitset<N> Q[N];
int bel[N],st[N],ed[N];
int qc[N],ql[N],qr[N],qu[N];
int lca[N][18],lg[N];
int query(int l,int r)
{
	int k=lg[r-l+1];
	return qlca(lca[l][k],lca[r-(1<<k)+1][k]);
}
vector<int> Ql[N],Qr[N],Qf[N];
void apply(int p,int l,int r)
{
	int u=query(l,r);
	if(fa[u])Qf[fa[u]].push_back(p);
	if(bel[l]==bel[r])
	{
		for(int i=l;i<=r;i++)
		{
			int x=i;
			while(!Q[p][x])
			{
				Q[p][x]=1;
				x=fa[x];
			}
		}
		return;
	}
	Ql[l].push_back(p);
	Qr[bel[l]+1].push_back(p);
}
vector<int> q[N];
bitset<N> cur,W,Z,I; 
void dfs2(int x)
{
	cur[x]=1;
	for(auto p:Qf[x])Q[p]^=cur;
	for(int i=flink[x];i;i=e[i].next)
	{
		int y=e[i].y;
		if(y==fa[x])continue;
		dfs2(y);
	}
	cur[x]=0;
}
vector<int> qnum[N];
int gd[N],prime[N],tot=0,v[N];
void init()
{
	for(int i=2;i<=n;i++)
	{
		if(!v[i])
		{
			v[i]=i;
			prime[++tot]=i;
		}
		for(int j=1;j<=tot;j++)
		{
			if(prime[j]>v[i]||1ll*i*prime[j]>n)break;
			v[i*prime[j]]=prime[j];
		}
	}
}
int vis[N],ans[N];
const int mod = 20242024;
void dfs(int X,int x,int p)
{
	vis[X]++;
	for(auto i:qnum[X])
	{
		Q[i]=Q[i]&Z;
		Q[i]=(Q[i]>>(ql[i]));
		int c=((I>>(n-(qr[i]-ql[i]+1)+1))&Q[i]).count();
		ans[i]=(19901991ll*c%mod+qr[i]-ql[i]+1-c)%mod;
	}
	for(int i=x;i<=tot&&1ll*X*prime[i]<=n;i++)
	{
		int np=p;
		if(i==x)np*=prime[i];
		else np=prime[i];
		for(int P=np;P<=n;P+=np)
		{
			gd[P]=gd[P]*prime[i];
			Z[P]=z[gd[P]];
		}
		dfs(X*prime[i],i,np);
		for(int P=np;P<=n;P+=np)
		{
			gd[P]=gd[P]/prime[i];
			Z[P]=z[gd[P]];
		}
	}
}
int main()
{
	scanf("%d %d",&n,&m);init();
	for(int i=1;i<=n;i++)scanf("%d",&z[i]),z[i]%=2;
	for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs(1,0);Exdfs(1,1);
	for(int i=1;i<=n;i++)lca[i][0]=i;
	for(int k=1;k<=lg[n];k++)
	for(int i=1;i+(1<<k)-1<=n;i++)
	lca[i][k]=qlca(lca[i][k-1],lca[i+(1<<(k-1))][k-1]);
	int B=n/sqrt(m);
	for(int i=1;i<=n;i++)
	{
		bel[i]=(i-1)/B+1;
		ed[bel[i]]=i;
		if(!st[bel[i]])st[bel[i]]=i;
	}
	int C=bel[n];
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d %d",&qc[i],&ql[i],&qr[i]);
		if(qc[i]==2)scanf("%d",&qu[i]);
		else apply(i,ql[i],qr[i]);
	}
	for(int o=1;o<=C;o++)
	{
		cur.reset();
		for(int i=st[o];i<=n;i++)q[i].clear();
		for(auto p:Qr[o])q[qr[p]].push_back(p);
		for(int i=st[o];i<=n;i++)
		{
			int x=i;
			while(!cur[x])cur[x]=1,x=fa[x];
			for(auto p:q[i])Q[p]|=cur;
		}
		cur.reset();
		for(int i=ed[o];i>=st[o];i--)
		{
			int x=i;
			while(!cur[x])cur[x]=1,x=fa[x];
			for(auto p:Ql[i])Q[p]|=cur;
		}
	}
	cur.reset();
	dfs2(1);
	for(int i=1;i<=m;i++)
	{
		if(qc[i]==1) W^=Q[i];
		else 
		{
			Q[i]=W;
			qnum[qu[i]].push_back(i);
		}
	}
	for(int i=1;i<=n;i++)gd[i]=1,I[i]=1,Z[i]=z[1];
	dfs(1,1,1);
	for(int i=1;i<=m;i++)if(qc[i]==2)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：R_shuffle (赞：1)

注意到题目中给的两个数比较奇怪，可以发现 $19901991^2\equiv1\pmod {20242024}$。所以可以通过求区间中 $z_{gcd(i,u)}$ 和 $w_i$ 同时为奇数的 $i$ 的数量来求答案。这个可以用 bitset 维护。

考虑最小虹，取出区间所有点的 lca，然后每个点向 lca 跳，所有能被跳到的点就是最小虹的一个元素。不难发现最小虹也可以用 bitset 维护，可以用类似树上差分的方式把最小虹转成若干个点到根的路径之间的运算。但是把所有涉及到的点都运算一遍显然不可能，所以考虑分块。

由于保证了区间是随机出来的，所以实际上 $l,r$ 在一个块内的概率只有 $\frac{B}{n}$，可以暴力处理这一部分，不在同一个块内的，依次加点，显然暴力是直接跳到根，但是可以加一个小优化，遇到已经加过的点就直接跳出循环，这样就可以把复杂度优化到均摊 $\frac{n^2}{B}$。取 $B=\frac{n}{\sqrt q}$ 最优，可以得到复杂度为 $O(n\sqrt q+\frac{nq}{\omega})$。

然后再考虑 gcd 那个怎么求，考虑离线后爆搜，发现跑的飞快，就不优化了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
#define int long long
inline int read()
{
    int re=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
    while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^48),ch=getchar();
    return re*f;
}
const int N=80005,B=2000;
int n,Q,z[N],bl[N],L[N],R[N],lg[N];
vector<int>gra[N],vecl[N],vecr[N],vecp[N],smx[N];
int f[N],dfn[N],cnt,st[N][25],maxn[N][25],minn[N][25];
struct node
{
    int l,r,opt;
}q[N];
bitset<N>F[N],S;
int prime[N],ptot,g[N];
bool fg[N];
void dfs(int u,int fa)
{
    st[dfn[u]=++cnt][0]=f[u]=fa;
    minn[u][0]=maxn[u][0]=u;
    for(auto v:gra[u])
    {
        if(v==fa) continue;
        dfs(v,u);
    }
}
int get_a(int u,int v)
{
    if(dfn[u]>dfn[v]) return u;
    return v;
}
int get_i(int u,int v)
{
    if(dfn[u]<dfn[v]) return u;
    return v;
}
int get_max(int u,int v)
{
    int len=lg[v-u+1];
    return get_a(maxn[u][len],maxn[v-(1<<len)+1][len]);
}
int get_min(int u,int v)
{
    int len=lg[v-u+1];
    return get_i(minn[u][len],minn[v-(1<<len)+1][len]);
}
int get_lca(int u,int v)
{
    if(u==v) return u;
    u=dfn[u],v=dfn[v];
    if(u>v) swap(u,v);
    u++;
    int len=lg[v-u+1];
    return get_i(st[u][len],st[v-(1<<len)+1][len]);
}
void dfs2(int u,int fa)
{
    S.set(u);
    for(auto x:smx[u]) F[x]^=S;
    for(auto v:gra[u])
    {
        if(v==fa) continue;
        dfs2(v,u);
    }
    S.reset(u);
}
void dfs3(int u,int x,int y)
{
    for(auto v:vecp[x]) F[v]&=S;
    for(int i=u;i<=ptot&&x*prime[i]<=n;i++)
    {
        int w=(i==u?y*prime[i]:prime[i]);
        for(int j=w;j<=n;j+=w) S[j]=z[g[j]*=prime[i]];
        dfs3(i,x*prime[i],w);
        for(int j=w;j<=n;j+=w) S[j]=z[g[j]/=prime[i]];
    }
}
void add(bitset<N>&s,int pos)
{
    assert(pos<=n);
    while(pos&&!s[pos]) s.set(pos),pos=f[pos];
}
signed main(){
#if __MY_TEST__
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    n=read(),Q=read();
    for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
    for(int i=1;i<=n;i++) z[i]=read()%2;
    for(int l=1,r,tot=1;l<=n;l+=B,tot++)
    {
        r=min(l+B-1,n);
        L[tot]=l,R[tot]=r;
        for(int i=l;i<=r;i++) bl[i]=tot;
    }
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read();
        gra[u].push_back(v);
        gra[v].push_back(u);
    }
    dfs(1,0);
    for(int j=1;j<=20;j++) for(int i=1;i+(1<<j)-1<=n;i++)
        st[i][j]=get_i(st[i][j-1],st[i+(1<<(j-1))][j-1]),
        maxn[i][j]=get_a(maxn[i][j-1],maxn[i+(1<<(j-1))][j-1]),
        minn[i][j]=get_i(minn[i][j-1],minn[i+(1<<(j-1))][j-1]);
    for(int i=1;i<=Q;i++)
    {
        q[i].opt=read(),q[i].l=read(),q[i].r=read();
        if(q[i].opt==1)
        {
            int lca=get_lca(get_min(q[i].l,q[i].r),get_max(q[i].l,q[i].r));
            smx[f[lca]].push_back(i);
            if(bl[q[i].l]==bl[q[i].r]) for(int j=q[i].l;j<=q[i].r;j++) add(F[i],j);
            else vecl[bl[q[i].l]].push_back(i),vecr[bl[q[i].l]+1].push_back(i);
        }
        else
        {
            int t=read();
            vecp[t].push_back(i);
        }
    }
    for(int i=1;i<=bl[n];i++)
    {
        sort(vecl[i].begin(),vecl[i].end(),[&](int x,int y){return q[x].l>q[y].l;});
        sort(vecr[i].begin(),vecr[i].end(),[&](int x,int y){return q[x].r<q[y].r;});
        S.reset();
        for(int j=L[i],pos=0;pos<vecr[i].size();j++)
        {
            add(S,j);
            while(pos<vecr[i].size()&&q[vecr[i][pos]].r==j) F[vecr[i][pos++]]|=S;
        }
        S.reset();
        for(int j=R[i],pos=0;pos<vecl[i].size();j--)
        {
            add(S,j);
            while(pos<vecl[i].size()&&q[vecl[i][pos]].l==j) F[vecl[i][pos++]]|=S;
        }
    }
    S.reset();
    dfs2(1,0);
    for(int i=1;i<=Q;i++) F[i]^=F[i-1];
    for(int i=2;i<=n;i++)
    {
        if(!fg[i]) prime[++ptot]=i;
        for(int j=1;j<=ptot&&i*prime[j]<=n;j++)
        {
            fg[i*prime[j]]=1;
            if(i%prime[j]==0) break;
        }
    }
    S.reset();
    for(int i=1;i<=n;i++) S[i]=z[g[i]=1];
    dfs3(1,1,1);
    for(int i=1;i<=Q;i++) if(q[i].opt==2)
    {
        F[i]>>=q[i].l;
        F[i]<<=(N-(q[i].r-q[i].l+1));
        cout<<(1ll*F[i].count()*19901990+(q[i].r-q[i].l+1))%20242024<<'\n';
    }
}
```

---

## 作者：Aegleseeker_ (赞：1)

卡常的恶心题。

首先不太容易地注意到 $19901991$ 是 $2042024$ 的二次剩余，所以我们只需维护 $(z_{\gcd(i,u)}\times w_i)\bmod 2$ 的值。$\bmod 2$ 可以联想到 bitset，结合数据范围和要维护的东西的复杂程度基本上能够确定。相当于我们维护 $Z_1,Z_2,\dots,Z_n,W$ 这些 bitset，对于一组询问我们直接将 $Z_u$ 和 $W$ 做按位与，根据 $\bmod 2$ 的性质 popcount 就是答案。分别考虑如何维护 $Z_i$ 和 $W$。

对于 $W$，我们需要维护修改操作，即对 $[l,r]$ 的最小虹加一。不难发现最小虹等价于不缩点的虚树，根据结论我们求出 $i\in [l,r]$ 的根链路径并，最后抛去 $lca(l,r)$ 的父亲的根链路径即可。我们令 $p_i$ 代表 $i$ 的根链路径，后面那个 $lca$ 父亲是好处理的，直接 xor 一下。如何处理一段区间的 $p$ 的并？考虑分块，散块暴力算，整块区间预处理。这里有一个必要的剪枝是，我现在要加入一个点 $i$ 的贡献，在跳父亲的时候如果这个父亲已经被标记过了，就可以直接跳过了。通过这个剪枝可以保证暴力的复杂度均摊是 $O(\frac{n^2}{w})$ 的。对于端点在同一块内的区间，只能 $O(n)$ 暴力算。注意到数据随机，我们缩小块长令 $B=\frac{n}{\sqrt q}$，根据随机的概率这样整体的复杂度是最优的。

对于 $Z_i$，相当于要维护一个 $Z_{\gcd(i,j)}$ 的 01 矩阵。这个似乎不太能直接维护的了，考虑枚举每个质因子以及其出现次数，暴搜出每一个数，每次乘上一个质数，更新其 $\gcd$ 的贡献以及 $Z_i$。经过神秘计算，这个东西的计算次数为 $O(可过)$。

但是现在还仍然有很多问题没有解决。首先空间上我们只能开一个 $\frac{n^2}{w}$ 的 bitset。在暴搜的过程中，我们只能维护当前 $i$ 的 $Z$，不可能都存下来。于是我们考虑将询问都离线下来，$Z$ 只开一个，维护当前暴搜状态下的那个 $Z_i$。在暴搜中处理询问。但是如何同时维护修改操作呢？考虑对于每一个时间戳，维护一个当前状态下的 $W'$，也就是说我们将 $W$ 扩展了大小为 $q$ 的一维。暴搜里查询的时候找到该时间戳对应的 $W'$ 即可。

如何维护 $W'$ 呢？根据刚刚的分块操作，我们还需要维护块内根链路径并，散块前缀路径并，单点路径并。显然空间爆完了。考虑同样对 $W$ 进行类似二次离线的操作。对于一个散块的前后缀根链路径并，直接把询问挂在左右端点上，每次求出前后缀散块路径并时再 or 上对应的询问即可。对于若干整块的根链路径并，由于块长变小了，所以直接枚举每个块会爆。考虑当 $q$ 小的时候直接做，否则令 $b_{i,j}$ 代表第 $i$ 块到第 $j$ 块的答案，预处理这个 $b$。但这样空间又爆了，于是同样对整块也离线下来，询问挂在 $(i,j)$ 上，跟散块处理方法一致，只需开一个 bitset 即可。

可能有些地方我想的不太清楚，有些卡空间、时间做的可能比较冗余。反正就是多卡卡常就过了。欢迎大家给出更加厉害的处理方法，

为了让世人感受这个题的恶心，我放出完整代码。

感谢 masonxiong 的卡常帮助。我在交了 $13$ 发后 2989ms 在 QOJ 上过了此题。

```cpp
#ifndef acmlFastInput
#define acmlFastInput

#include <sstream>
#include <unistd.h>
#include <type_traits>

namespace acml {
    template <const std::size_t BufferSize = 4 << 20>
    class FastInput {
        alignas(64) char buffer[BufferSize];
        char *cursor, *end;
    
        void next() noexcept {
            if (__builtin_expect(++cursor == end, 0))
                read(0, cursor = buffer, BufferSize);
        }

    public:
        FastInput() : cursor(buffer), end(buffer + BufferSize) { read(0, buffer, BufferSize); }

        void input(char& value) noexcept {
            while (*cursor < 33)
                next();
            value = *cursor;
            next();
        }

        void input(char* value) noexcept {
            while (*cursor < 33)
                next();
            do {
                *value++ = *cursor;
                next();
            } while (*cursor > 32);
            *value = 0;
        }

        template <typename Value>
        typename std::enable_if<std::is_integral<Value>::value && std::is_unsigned<Value>::value>::type input(Value& value) noexcept {
            while (*cursor < 33)
                next();
            value = *cursor - 48;
            next();
            while (*cursor > 47) {
                value = value * 10 + *cursor - 48;
                next();
            }
        }

        template <typename Value>
        typename std::enable_if<std::is_integral<Value>::value && !std::is_unsigned<Value>::value>::type input(Value& value) noexcept {
            while (*cursor < 33)
                next();
            if (*cursor == 45) {
                next();
                value = 48 - *cursor;
                next();
                while (*cursor > 47) {
                    value = value * 10 + 48 - *cursor;
                    next();
                }
            } else {
                value = *cursor - 48;
                next();
                while (*cursor > 47) {
                    value = value * 10 + *cursor - 48;
                    next();
                }
            }
        }

        template <typename Value>
        typename std::enable_if<!std::is_integral<Value>::value && !std::is_same<Value, char>::value && !std::is_same<Value, char*>::value>::type input(Value& value) noexcept {
            std::string sInput;
            while (*cursor < 33)
                next();
            do {
                sInput.push_back(*cursor);
                next();
            } while (*cursor > 32);
            std::istringstream stream(sInput);
            stream >> value;
        }

        template <typename Value>
        FastInput& operator>>(Value& value) noexcept {
            input(value);
            return *this;
        }
    };
}

#endif
#ifndef acmlFastOutput
#define acmlFastOutput

#include <sstream>
#include <unistd.h>
#include <type_traits>

namespace acml {
    template <const std::size_t BufferSize = 4 << 20>
    class FastOutput {
        alignas(64) char buffer[BufferSize];
        char *cursor, *end;

    public:
        FastOutput() : cursor(buffer), end(buffer + BufferSize) {}

        ~FastOutput() { write(1, buffer, cursor - buffer); }

        void output(char value) noexcept {
            *cursor = value;
            if (__builtin_expect(++cursor == end, 0))
                write(1, cursor = buffer, BufferSize);
        }

        void output(const char* value) noexcept {
            do
                output(*value);
            while (*++value);
        }

        template <typename Value>
        typename std::enable_if<std::is_integral<Value>::value && std::is_unsigned<Value>::value>::type output(Value value) noexcept {
            static char stack[64], *top = stack;
            do
                *++top = value % 10 + 48;
            while ((value /= 10));
            do
                output(*top);
            while (--top != stack);
        }

        template <typename Value>
        typename std::enable_if<std::is_integral<Value>::value && !std::is_unsigned<Value>::value>::type output(Value value) noexcept {
            static char stack[64], *top = stack;
            if (value >= 0) {
                do
                    *++top = value % 10 + 48;
                while ((value /= 10));

            } else {
                output('-');
                do
                    *++top = 48 - value % 10;
                while ((value /= 10));

            }
            do
                output(*top);
            while (--top != stack);
        }

        template <typename Value>
        typename std::enable_if<!std::is_integral<Value>::value && !std::is_same<Value, char>::value && !std::is_same<Value, char*>::value>::type output(Value value) noexcept {
            std::ostringstream stream;
            stream << value;
            output(stream.str().c_str());
        }

        template <typename Value>
        FastOutput& operator<<(Value value) noexcept {
            output(value);
            return *this;
        }
    };
}

#endif

acml::FastInput<> fsti;
acml::FastOutput<> fsto;
#include<bits/stdc++.h>
using namespace std;
#define cin fsti
#define cout fsto
const int N=80005;
const int M=305;
const int mod=20242024;
int n,q,block,tot;
int z[N];
vector<int> g[N];
int deep[N],f[N][18],stlca[N][18],lg[N],prime[N],gd[N];
int L[N],R[N],belong[N];
bitset<N> blk[M],W[N],b,Z,w;
int ans[N];
struct node{
	int l,r,id,type;
};
vector<node> qq[N],dd[N];
vector<int> tt[M][M];
void dfs(int u,int fa){
	deep[u]=deep[fa]+1,f[u][0]=fa;
	for(int i=1;i<=17;i++){
		f[u][i]=f[f[u][i-1]][i-1];
	}
	for(auto v:g[u]){
		if(v==fa){
			continue;
		}
		dfs(v,u);
	}
}
int lca(int u,int v){
	if(deep[u]<deep[v]){
		swap(u,v);
	}
	for(int i=17;i>=0;i--){
		if(deep[f[u][i]]>=deep[v]){
			u=f[u][i];
		}
	}
	if(u==v){
		return u;
	}
	for(int i=17;i>=0;i--){
		if(f[u][i]!=f[v][i]){
			u=f[u][i],v=f[v][i];
		}
	}
	return f[u][0];
}
void initstlca(){
	for(int i=1;i<n;i++){
		stlca[i][0]=lca(i,i+1);
	}
	for(int i=2;i<=n;i++){
		lg[i]=lg[i/2]+1;
	}
	for(int j=1;j<=17;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			stlca[i][j]=(deep[stlca[i][j-1]]<deep[stlca[i+(1<<(j-1))][j-1]]?stlca[i][j-1]:stlca[i+(1<<(j-1))][j-1]);
		}
	}
}
int qlca(int l,int r){
	if(l==r){
		return l;
	}
	r--;
	int k=lg[r-l+1];
	return (deep[stlca[l][k]]<deep[stlca[r-(1<<k)+1][k]]?stlca[l][k]:stlca[r-(1<<k)+1][k]);
}
void initblock(){
	block=n/sqrt(q),tot=n/block+(n%block!=0);
	for(int i=1;i<=n;i++){
		belong[i]=(i-1)/block+1;
	}
	for(int i=1;i<=tot;i++){
		L[i]=(i-1)*block+1,R[i]=min(i*block,n);
	}
	for(int i=1;i<=n;i++){
		int u=i;
		while(u){
			if(blk[belong[i]][u]){
				break;
			}
			blk[belong[i]][u]=1,u=f[u][0];
		}
	}
}
void initW(int u,int fa){
	for(auto x:dd[u]){
		if(x.type==3){
			W[x.id]^=w;
		}
	}
	for(auto v:g[u]){
		if(v==fa){
			continue;
		}
		w[v]=1,initW(v,u),w[v]=0;
	}
}
int calc(bitset<N> x,bitset<N> y,int r){
	x<<=(N-1-r),y<<=(N-1-r);
	return (x&y).count();
}
void search(int x,int y,int zz){
	for(auto i:qq[x]){
		int cnt=calc(W[i.id],Z,i.r)-calc(W[i.id],Z,i.l-1);
		ans[i.id]=(1ll*19901991*cnt%mod+i.r-i.l+1-cnt+mod)%mod;
	}
	for(int i=y;i<=prime[0];i++){
		if(1ll*x*prime[i]>n){
			break;
		}
		int res=(i==y?zz*prime[i]:prime[i]);
		for(int j=res;j<=n;j+=res){
			gd[j]*=prime[i],Z[j]=z[gd[j]]%2;
		}
		search(x*prime[i],i,res);
		for(int j=res;j<=n;j+=res){
			gd[j]/=prime[i],Z[j]=z[gd[j]]%2;
		}
	}
}
void initZ(){
	for(int i=2;i<=n;i++){
		bool flag=1;
		for(int j=2;j*j<=i;j++){
			if(i%j==0){
				flag=0;
				break;
			}
		}
		if(flag){
			prime[++prime[0]]=i;
		}
	}
	for(int i=1;i<=n;i++){
		gd[i]=1,Z[i]=z[1]%2;
	}
	search(1,1,1);
}
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>z[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v),g[v].push_back(u);
	}
	dfs(1,0);
	initstlca();
	initblock();
	for(int i=1;i<=q;i++){
		int op;
		cin>>op;
		if(op==1){
			int l,r;
			cin>>l>>r;
			if(belong[l]==belong[r]){
				for(int j=l;j<=r;j++){
					int u=j;
					while(u){
						if(W[i][u]){
							break;
						}
						W[i][u]=1,u=f[u][0];
					}
				}
			}else{
				//W[i]|=b[belong[l]+1][belong[r]-1];
				tt[belong[l]+1][belong[r]-1].push_back(i);
				dd[l].push_back(node{l,r,i,1});
				dd[r].push_back(node{l,r,i,2});
			}
			dd[f[qlca(l,r)][0]].push_back(node{l,r,i,3});		
		}else{
			int l,r,u;
			cin>>l>>r>>u;
			qq[u].push_back(node{l,r,i,0});
		}
	}
	for(int i=1;i<=tot;i++){
		b.reset();
		for(int j=i;j<=tot;j++){
			b|=blk[j];
			for(auto x:tt[i][j]){
				W[x]|=b;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(belong[i-1]!=belong[i]){
			w.reset();
		}
		int u=i;
		while(u){
			if(w[u]){
				break;
			}
			w[u]=1,u=f[u][0];
		}
		for(auto x:dd[i]){
			if(x.type==2){
				W[x.id]|=w;
			}
		}	
	}
	w.reset();
	for(int i=n;i>=1;i--){
		if(belong[i+1]!=belong[i]){
			w.reset();
		}
		int u=i;
		while(u){
			if(w[u]){
				break;
			}
			w[u]=1,u=f[u][0];
		}
		for(auto x:dd[i]){
			if(x.type==1){
				W[x.id]|=w;
			}
		}	
	}
	w.reset();
	w[1]=1,initW(1,0);
	for(int i=1;i<=q;i++){
		W[i]^=W[i-1];
	}
	initZ();
	for(int i=1;i<=q;i++){
		if(ans[i]){
			cout<<ans[i]<<'\n';
		}
	}
	return 0;
}
```

bonus：由于此题数据比较随机，所以貌似不用对 $q$ 的大小进行分讨？

---

## 作者：anotherobject (赞：1)

### 初步观察

考虑刻画最小虹，发现就是区间内每个点到根链并再去掉所有点 $lca$ 的父亲到根链。

观察询问的形式，发现 $19901991^2\equiv 1\pmod  {20242024}$，所以只需要关注于 $\sum_{i=l}^r [z_{\gcd(i,u)w_i}\equiv 1\pmod 2]$。

容易想到用 bitset 维护，先将其拆成两部分，$z_{\gcd(i,u)}$ 的 bitset 和 $w_i$ 的 bitset。

### 求 $z_{\gcd(u,i)}$ 的 bitset

每次将 $u$ 乘上一个质数 $p$ 的时候，设当前含有 $c$ 个 $p$，只有 $p^c$ 的倍数位置的 $\gcd$ 会发生改变，具体地是乘上一个 $p$，所以爆搜即可通过，计算量 $X\approx 4\times 10^7$。

细节代码实现可以从小到大枚举每个质数，再枚举次数。

### 求 $w_i$ 的 bitset

尝试计算出每个查询区间最小虹的 bitset。

先拆成两部分，$fa_{lca}$ 到根链那段不考虑，因为做法比较 trivial（区间 lca 可以当做区间 rmq 做，然后一次 dfs 即可求出所有 bitset）。设区间内每个点到根链并叫做伪最小虹。

有一个重要观察：伪最小虹的大小 $\le n$，所以对于任意集合只需要 $O(n)$ 就能算出其伪最小虹，且可以动态加点，总复杂度仍然为 $O(n)$。（每次加入一个点，一直跳父亲，加入伪最小虹，直到遇到第一个在伪最小虹内的点为止。）

所以尝试选定一些端点进行扫描线，考虑分块，块长为 $B$。

对于一个跨块的询问，我们容易将其分成两部分 $[l,ed_{bel_l}],[st_{bel_{l}+1},r]$，其中 $st,ed$ 为某一块的起点终点，$bel$ 为某个位置在哪一块内。

这两部分都有一个 $st$ 或 $ed$ 做端点，所以将所有这种端点拿出来扫描线，复杂度为 $O(\frac{n^2}{B})$。

对于一个不跨块的询问，其出现概率只有 $\frac{B}{n}$，即在 $q$ 次询问中出现 $\frac{qB}{n}$ 次，每次暴力 $O(n)$ 计算伪最小虹即可，复杂度 $O(qB)$。

平衡复杂度得到 $B=\frac{n}{\sqrt q}$，总复杂度为 $O(n\sqrt q+\frac{nq}{w}+X)$。

代码有注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool Mbe;
const int N=8e4+10; int n;
const int p=20242024;
struct node{int to,nxt;}edge[N*2]; int head[N],cnt;
void add(int u,int v){edge[++cnt].to=v;edge[cnt].nxt=head[u];head[u]=cnt;}
void adde(int u,int v){add(u,v); add(v,u);}//链式前向星 
int prime[N],res,z[N],sl[N][20],pos[N],st[N],ed[N],g[N],G[N],B,dep[N],siz[N],top[N],son[N],fa[N];bitset<N>vis,F[N],cur,Z,W,I;vector<int>ql[N],qr[N],qf[N],_q[N],qx[N];
void sieve(int n){for(int i=2;i<=n;i++){if(!vis[i])prime[++res]=i;for(int j=1;j<=res&&1ll*prime[j]*i<=n;j++){vis[prime[j]*i]=1;if(i%prime[j]==0)break;}}}//筛素数 
struct queries{int op,l,r,u;}Q[N];
void dfs1(int u,int f){fa[u]=f;dep[u]=dep[f]+1;siz[u]=1;for(int i=head[u];i;i=edge[i].nxt){int v=edge[i].to;if(v==f)continue;dfs1(v,u);siz[u]+=siz[v];if(siz[v]>siz[son[u]])son[u]=v;}}
void dfs2(int u,int tp){top[u]=tp;if(!son[u]) return;dfs2(son[u],tp);for(int i=head[u];i;i=edge[i].nxt){int v=edge[i].to;if(v==fa[u]||v==son[u])continue;dfs2(v,v);}}
int LCA(int u,int v){while(top[u]!=top[v]){if(dep[top[u]]<dep[top[v]])swap(u,v);u=fa[top[u]];}if(dep[u]>dep[v]) swap(u,v); return u;}//树剖求lca 
int query(int l,int r){int k=log2(r-l+1);return LCA(sl[l][k],sl[r-(1<<k)+1][k]);}
void dfsx(int id,int pn,int P){
	for(auto i:qx[id]){F[i]&=Z;F[i]=(F[i]>>(Q[i].l));//去掉比l小的部分 
		int tmp=((I>>(n-(Q[i].r-Q[i].l+1)+1))&F[i]).count();//用一个全是1的bitset : I对齐并做and可以得到其1的数量 
		G[i]=(19901990ll*tmp%p+Q[i].r-Q[i].l+1)%p;
	}
	for(int i=pn;i<=res&&1ll*id*prime[i]<=n;i++){int tmp;if(i==pn)tmp=P*prime[i];else tmp=prime[i];//爆搜每个质数的出现次数 
		for(int j=tmp;j<=n;j+=tmp){g[j]=g[j]*prime[i];Z[j]=z[g[j]];}dfsx(id*prime[i],i,tmp);
		for(int j=tmp;j<=n;j+=tmp){g[j]=g[j]/prime[i];Z[j]=z[g[j]];}//回溯 
	}
}
void dfsf(int u){
	cur[u]=1;for(auto i:qf[u]) F[i]^=cur;//去掉lca父亲以上的部分 
	for(int i=head[u];i;i=edge[i].nxt){int v=edge[i].to;if(v==fa[u])continue;dfsf(v);}
	cur[u]=0;
}
void modify(int id,int l,int r){
	int lca=query(l,r);if(fa[lca]) qf[fa[lca]].push_back(id);
	if(pos[l]==pos[r]){for(int i=l;i<=r;i++){int u=i;//在一块内的询问，直接暴力求 
			while(!F[id][u]&&u){F[id][u]=1;u=fa[u];}}return;}
	ql[l].push_back(id);qr[pos[l]+1].push_back(id);//否则挂在块端点上，等待逐块处理 
}
int main(){
	sieve(N-10);int q; cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>z[i];for(int i=1;i<=n;i++) z[i]%=2;
	for(int i=1;i<n;i++){int u,v; cin>>u>>v;adde(u,v);}
	dfs1(1,0); dfs2(1,1);
	for(int i=1;i<=n;i++) sl[i][0]=i; int qwqwq=log2(n);
	for(int i=1;i<=qwqwq;i++){for(int j=1;j<=n-(1<<i)+1;j++){sl[j][i]=LCA(sl[j][i-1],sl[j+(1<<(i-1))][i-1])}}//ST表式地做区间LCA. 
	B=max((int)1,(int)(n/sqrt(q)));
	for(int i=1;i<=n;i++) pos[i]=(i-1)/B+1;
	for(int i=1;i<=pos[n];i++){st[i]=(i-1)*B+1;ed[i]=i*B;}ed[pos[n]]=n;//预处理一些分块数组 
	for(int i=1;i<=q;i++){cin>>Q[i].op>>Q[i].l>>Q[i].r;//读入询问，离线处理 
		if(Q[i].op==2){cin>>Q[i].u;}else modify(i,Q[i].l,Q[i].r);}
	for(int i=1;i<=pos[n];i++){//逐块处理询问 
		cur.reset();
		for(int j=st[i];j<=n;j++) _q[j].clear();
		for(auto j:qr[i]) _q[Q[j].r].push_back(j);
		for(int j=st[i];j<=n;j++){int u=j;//从i块开头往右扫 
			while(!cur[u]&&u){cur[u]=1;u=fa[u];}for(auto r:_q[j])F[r]|=cur;}
		cur.reset();
		for(int j=ed[i];j>=st[i];j--){int u=j;//倒着扫i块内后缀 
			while(!cur[u]&&u){cur[u]=1;u=fa[u];}for(auto r:ql[j])F[r]|=cur;}
	}
	cur.reset();dfsf(1);//处理掉lca的父亲到根链这段该删掉的信息 
	for(int i=1;i<=q;i++){//模拟读入顺序进行修改 
		if(Q[i].op==1) W^=F[i];
		else{F[i]=W;qx[Q[i].u].push_back(i);}
	}
	for(int i=1;i<=n;i++) Z[i]=z[1],g[i]=1,I[i]=1;dfsx(1,1,1);//爆搜所有可能的u 
	for(int i=1;i<=q;i++) if(Q[i].op==2) cout<<G[i]<<"\n";
}
```

---


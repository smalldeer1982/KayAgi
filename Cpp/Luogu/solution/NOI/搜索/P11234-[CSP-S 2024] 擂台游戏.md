# [CSP-S 2024] 擂台游戏

## 题目描述

小 S 想要举办一场擂台游戏，如果共有 $2^k$ 名选手参加，那么游戏分为 $k$ 轮进行：

- 第一轮编号为 $1, 2$ 的选手进行一次对局，编号为 $3, 4$ 的选手进行一次对局，以此类推，编号为 $2^k - 1, 2^k$ 的选手进行一次对局。
- 第二轮在只保留第一轮的胜者的前提下，相邻的两位依次进行一场对局。
- 以此类推，第 $k - 1$ 轮在只保留第 $k - 2$ 轮的 $4$ 位胜者的前提下，前两位、后两位分别进行对局，也就是所谓的半决赛。
- 第 $k$ 轮即为半决赛两位胜者的决赛。

确定了游戏晋级的规则后，小 S 将比赛的规则设置为了擂台赛。具体而言，每位选手都有一个能力值 $a_1, a_2, \dots , a_{2^k}$，能力值为 $[0,2^{31}-1]$ 之内的整数。对于每场比赛，会先抽签决定一个数 $0/1$，我们将第 $R$ 轮的第 $G$ 场比赛抽到的数记为 $d_{R,G}$。抽到 $0$ 则表示表示编号小的选手为擂主，抽到 $1$ 则表示编号大的选手为擂主。擂主获胜当且仅当他的能力值 $a\geq R$。也就是说，游戏的胜负只取决于**擂主的能力值**与**当前比赛是第几轮**的大小关系，**与另一位的能力值无关**。

现在，小 S 先后陆续收到了 $n$ 位选手的报名信息，他们分别告知了小 S 自己的能力值。小 S 会按照报名的先后顺序对选手进行编号为 $1, 2, \dots, n$。小 S 关心的是，补充**尽量少**的选手使总人数为 $2$ 的整次幂，且所有选手进行一次完整的擂台游戏后，所有可能成为总冠军的选手的**编号之和**是多少。

形式化地，设 $k$ 是最小的非负整数使得 $2^k\geq n$，那么应当补充 $(2^k-n)$ 名选手，且补充的选手的能力值可以任取 $[0,2^{31}-1]$ 之内的整数。**如果补充的选手有可能取胜，也应当计入答案中**。

当然小 S 觉得这个问题还是太简单了，所以他给了你 $m$ 个询问 $c_1,c_2,\dots,c_m$。小 S 希望你帮忙对于每个 $c_i$ 求出，在只收到前 $c_i$ 位选手的报名信息时，这个问题的答案是多少。

## 说明/提示

**【样例 1 解释】**

共有 $T = 4$ 组数据，这里只解释第一组。$5$ 名选手的真实能力值为 $[1, 0, 0, 2, 1]$。$5$ 组询问分别是对长度为 $5, 4, 1, 2, 3$ 的前缀进行的。

1. 对于长度为 $1$ 的前缀，由于只有 $1$ 号一个人，因此答案为 $1$。
2. 对于长度为 $2$ 的前缀，由于 $2$ 个人已经是 $2$ 的幂次，因此不需要进行扩充。根据抽签 $d_{1,1} = 1$ 可知 $2$ 号为擂主，由于 $a_2 < 1$，因此 $1$ 号获胜，答案为 $1$。
3. 对于长度为 $3$ 的前缀，首先 $1$ 号、$2$ 号比赛是 $1$ 号获胜（因为 $d_{1,1} = 1$，故 $2$ 号为擂主，$a_2 < 1$），然后虽然 $4$ 号能力值还不知道，但 $3$ 号、$4$ 号比赛一定是 $4$ 号获胜（因为 $d_{1,2} = 0$，故 $3$ 号为擂主，$a_3 < 1$），而决赛 $1$ 号、$4$ 号谁获胜都有可能（因为 $d_{2,1} = 1$，故 $4$ 号为擂主，如果 $a_4 < 2$ 则 $1$ 号获胜，$a_4 \geq 2$ 则 $4$ 号获胜）。综上所述，答案为 $1 + 4 = 5$。
4. 对于长度为 $4$ 的前缀，我们根据上一条的分析得知，由于 $a_4 \geq 2$ ，所以决赛获胜的是 $4$ 号。
5. 对于长度为 $5$ 的前缀，可以证明，可能获胜的选手包括 $4$ 号、$7$ 号、$8$ 号，答案为 $19$。

因此，该组测试数据的答案为 $(1 \times 19) \oplus (2 \times 4) \oplus (3 \times 1) \oplus (4 \times 1) \oplus (5 \times 5) = 5$。

**【样例 2】**

见选手目录下的 arena/arena2.in 与 arena/arena2.ans。

这组样例满足特殊性质 A。

**【样例 3】**

见选手目录下的 arena/arena3.in 与 arena/arena3.ans。

这组样例满足特殊性质 B。

**【样例 4】**

见选手目录下的 arena/arena4.in 与 arena/arena4.ans。

**【样例 5】**

见选手目录下的 arena/arena5.in 与 arena/arena5.ans。

**【数据范围】**

对于所有测试数据，保证：$2 \leq n, m \leq 10^5$，$0 \leq a_i, X_j < 2^{31}$，$1 \leq c_i \leq n$，$1 \leq T \leq 256$。

::cute-table{tuack}

| 测试点 | $T=$ | $n,m\leq$ | 特殊性质 A | 特殊性质 B |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $1$ | $8$ | 否 | 否 |
| $4,5$ | ^ | $500$ | 是 | ^ |
| $6\sim 8$ | ^ | ^ | 否 | 是 |
| $9,10$ | ^ | $5000$ | ^ | 否 |
| $11,12$ | ^ | $10^5$ | 是 | ^ |
| $13\sim 15$ | ^ | ^ | 否 | 是 |
| $16,17$ | $4$ | ^ | ^ | 否 |
| $18,19$ | $16$ | ^ | ^ | ^ |
| $20,21$ | $64$ | ^ | ^ | ^ |
| $22,23$ | $128$ | ^ | ^ | ^ |
| $24,25$ | $256$ | ^ | ^ | ^ |


特殊性质 A：保证询问的 $c_i$ 均为 $2$ 的幂次。

特殊性质 B：保证所有的 $d_{R,G} = 0$。

## 样例 #1

### 输入

```
5 5
0 0 0 0 0
5 4 1 2 3
1001
10
1
4
2 1 0 0
1 2 1 0
0 2 3 1
2 2 0 1```

### 输出

```
5
19
7
1```

# 题解

## 作者：lsj2009 (赞：136)

## Description

较为复杂，见原题。

## Solution

闲话：

考场上实现出了本题的 $\mathcal{O}(T(n\log{n}+m))$ 的做法。

然后由于算错了复杂度瓶颈（我认为树的大小是 $\mathcal{O}(n\log{n})$ 的，是不是要滚回去复习噗叽组了？？？？），所以并没有尝试给出 $\mathcal{O}(T(n+m))$ 的做法。

赛后重新思考发现，其实这最后一步优化并不复杂（感觉远不如想出 $\mathcal{O}(n\log{n})$ 做法难）。

下面从考场上以及考后的思考过程给出本题的完整做法。

### Part 1 $\mathcal{O}(Tmn\log{n})$ 做法

我们考虑拆贡献，变成判断每个 $i$ 能否成为 $n'=c_j$ 时最终的 winner；更一般的，**我们先讨论 $n'=n$ 的做法**。

那么我们此时会分两种情况（我们称一个**不知道信息的选手为「自由选手」**）：

1. $i\le n'$，也就是 $i$ 不是自由选手。
2. $i>n'$，也就是 $i$ 是自由选手。

我们考虑模拟 $i$ 不断打擂台打上去的过程：

1. 如果 **在一个节点 $u$ 时 $i$ 作为擂主（令 $i$ 所在子树为 $v$）**，那么我们容易判断 $i$ 可不可以成为这一局的 winner，具体的：
   - 如果 $i$ 是自由选手直接跳过即可，因为我们令 $a_i\gets \infty$ 就可以解决所有问题。
   - 如果 $i$ 不是自由选手，那么我们判断 $a_i$ 和 $k$ 的大小关系即可；如果 $a_i<k$ 就直接 game over 了，$i$ 不可能成为最终的 winner。
2. 如果不是 $i$ 作为擂主，也就是 **在 $v$ 的 brother 对局中的 winner 作为擂主**，这个时候就很难办。
   - 如果 $v$ 的 brother 子树内 **不存在自由选手**，那我在该子树的 winner 是确定的，并且可以预处理出来，此时我们就看看这个人作为擂主能不能打过就好了。
   - 如果 $v$ 的 brother 子树内 **存在自由选手**，我们有结论是：
     - 不妨认为自由选手的力量值是 $\infty$，然后同样 **把自由选手当作普通选手** 同样进行预处理。
     - 如果最终自由选手是 $v$ brother 上的 winner，则我们直接判 $i$ 成为了 $u$ 的 winner。
     - 如果最终非自由选手是 $v$ brother 上的 winner，则我们判断该选手能否守擂成功即可；成功的话对于 $i$ 就 game over 了。

对于「结论」的说明：

> 我们不妨先考虑 **不存在自由选手** 的情况。
>
> 不过这个可能没有很清晰的定义，我们认为「不存在」的定义是：
> - **如果一个非自由选手的对手是自由选手，则非自由选手自动获胜。**
>
> 当然自由选手对战自由选手就爱咋地咋地，我们并不关心。
>
> 我们不妨先考虑在上面这条规则的情况下求出所有 winner。
> 
> 则我们有结论是：根据真实规则下每个子树内的 winner 只有两种可能：
> 1. 在遵循上面规则情况下的 winner。
> 2. 一个自由选手。
>
> 证明是平凡的，大概而言就是说，你考虑设我原来的 winner 是 $k$，某个自由选手在某一轮成功干掉了 $k$，那么他在之后的轮次中 **就可以复刻 $k$ 的事件**，因为他的 $a$ 比 $k$ 强，对战的其他节点又是一样的，所以肯定可以成为最终的 winner。
>
> 好的，其实上面的说明有一个小问题：对战的其他节点有可能是不一样的！然而我们自下而上归纳，根据我们的结论，如果不一样则 **说明他对战了另一个自由选手**，那两个自由选手谁爱赢谁赢，这对于我们的初心——判断 $i$ 是否能成为最终的 winner 并没有影响。
>
> 好的，然后呢？
>
> 我们发现自由选手对 $i$ 有一个很强的优惠：**自由选手可以随机应变**！
>
> 具体的，其实我们发现让一个自由选手成为 $v$ brother 的 winner 我们并不要求他的 $a=\infty$，**而仅仅只是 $a\ge k-1$ 就完全足够了**；那么在这一轮对战中我们让 $a\gets k-1$，输掉这一轮对战，给 $i$ 让路即可！
>
> 这样子我们也就说明了我们上面的判断是没有任何问题的。

这样子我们对于单组询问就可以做到 $\mathcal{O}(n+n\log{n})$，分别为预处理和对于每个 $i$ 模拟向上跳的过程；总复杂度是 $\mathcal{O}(Tmn\log{n})$。

### Part 2 $\mathcal{O}(T(n\log{n}+m))$ 做法

上面给出的做法我们需要对于每询问单独处理，太弱智了，考虑优化。

首先我们注意到其实不同的 $c_i$ 其实就是在对每个「极左」的子树内做这个游戏。

- 我们称一个节点 $u$ 是「极左」的，**当且仅当从 $u$ 爬到根其一直作为左儿子**。

那我们从 $i$ 往上爬时，没爬到一个极左的节点，我们就可能可以对一个范围（$c_j$ 得大于其左子树叶子节点个数，小于等于其本身叶子节点个数）内的 $c_j$ 产生贡献。

能不能把这些 $c_i$ 归到一起处理呢？？？

显然是可以的。我们注意到一个事情：

- 假若当 $n'=i$ 时自由选手可以成为 $u$ 的 winner，则当 $n'=i'(i'<i)$ 时则自由选手必然可以成为 $u$ 的 winner。

则我们考虑记录 $f_u,g_u$ 分别表示：**正常做打擂台过程在 $u$ 处的 winner**（根据 Part 1 所说，我们视本身就是自由选手（$i>n$）的 $a_i$ 视作 $\infty$）和如果**想要让一个自由选手成为 $u$ 处的 winner，$n'$ 最大是多少**（需要注意的是，这里的自由选手是针对 $n'$ 而言而不是 $n$）。

转移是简单的。具体可以看下面代码。

则我们每次从 $i$ 向上跳，维护一个 $\max{n'}$，跳到一个 $u$，如果 $i$ 作为擂主，$a_i<k$，就直接结束；否则判断 $a_{f_{v\text{'s brother}}}$ 是否大于等于 $k$，如果是则我们要将 $\max{n'}$ 向 $g_{v\text{'s brother}}$ 取 $\min$。

则最终 $i$ 到一个极左节点时，就会贡献固有的范围（注意作为非自由选手应该还要向 $[i,n]$ 取交，作为自由选手要向 $[1,i)$ 取交）和 $[1,\max{n'}]$ 的交集；注意到这是一个区间，差分计算即可。

单组数据预处理复杂度 $\mathcal{O}(n)$，计算答案复杂度 $\mathcal{O}(n\log{n}+m)$。

**细节有点多，而且这个 Part 比较重要，下面给出代码，建议完全看懂后再阅读下一个 Part。**

考场上可能大概写出来这么一坨史（这个是考后复刻，跟考场代码不完全一样，不过细节基本上一致）：

[code link](https://www.luogu.com.cn/paste/85yc7th2)。

### Part 3 $\mathcal{O}(T(n+m))$ 做法

这个做法还是很有前途的！

因为我们注意到一个非常牛的事情是：**进行加法的区间个数只有 $\mathcal{O}(n)$ 个！**

- 分析：因为作为极左节点，这样节点的子树深度恰好是 $[1,K]$ 各有一个！而一个深度为 $k$ 的极左节点会有 $\mathcal{O}(\text{叶子节点数量})=\mathcal{O}(2^k)$ 个区间贡献给他，而 $\mathcal{O}(\sum\limits_{i=1}^K 2^k)=\mathcal{O}(n)$。

所以区间数量是可以接受的！

甚至，更进一步的是，我们可以对这 $K$ 个子树全部进行一次遍历！

我们观察：一个节点 $i$ 向上爬要注意两点：

1. 会不会其作为擂主直接挂掉。
2. 他的对手作为擂主能不能守擂成功，如果可以要向他对手的 $g$ 取 $\min$。

我们发现其实 **后面那个东西和 $a_i$ 根本没有任何关系**！

而前者也是容易处理的。

具体的：我们考虑 **从每一个极左节点开始自顶向下处理贡献**。

我们考虑遍历时维护一个二元组 $(x,y)$，经过一条边 $u\to v$ 时，我们考虑模拟 $i$ 从 $v\to u$ 的过程：

1. 如果 $v$ 子树内的点到 $u$ 作为擂主，则将 $x$ 向当前的 $k$ 取 $\max$。
2. 如果 $v$ 子树内的点到 $u$ 不作为擂主，则判断 $v\text{'s brother}$ 能否守擂成功，如果可以则将 $y$ 向 $g_{v\text{'s brother}}$ 取 $\min$。

到达叶子节点时（也就是我们的 $i$），这时 $x$ 就可以判断 $i$ 在往上跳时能不能到达我们枚举的极左节点；而 $y$ 就可以描述贡献区间的额外约束。

根据上面的分析，这样子单次复杂度就是 $\mathcal{O}(n+m)$ 的！

常数有点小大，可能要精细实现/ng

有点细节，这里给出一份 AC 代码：

[code link](https://www.luogu.com.cn/paste/yhm9kazt)。

### Part 4 另一种刻画方法——$\log$ 去哪了？

一些对于该题的额外思考。

我们考虑将这颗满二叉树刻画成线段树，那其实 $i$ 向上爬的过程中遇到的额外限制就好比是一个 tag，而其对答案的贡献就是一个 value，每次其实我们就是要实现一个东西 **来支持 value 和 tag 的合并**。

更细节的，我们在 Part 2 的代码中采取了 **标记永久化** 的写法。

然后我们带 $\log$ 的做法中比较蠢蛋的原因是，我们想要获知所有叶子节点的 value，然而我们发现 value 不支持合并！但是幸运的是 **合并具有交换律**，那么我们从每个叶子节点往上爬不断 $\operatorname{merge}(value,tag)$ 就好了。

这样子复杂度是带 $\log$ 的。

然而另外一种更好的方式是，我们不再采取 **标记永久化**，因为我们发现 **tag 和 tag 也是可以合并的**！我们直接自上而下把 tag 全部 push down 下去就好了。

这样子我们就仅仅只需要遍历整颗线段树，复杂度也就少一只 $\log$ 了。

如果还有其他看法（或者我有啥写错了），欢迎在评论区指出！

---

## 作者：wosile (赞：67)

树大小会变是很麻烦的事情，所以我们首先假设树大小固定，因为实际上我们可以枚举所有可能的树大小，复杂度也是线性的。

定义“时刻 $i$”表示第 $1\sim i$ 个人的能力值确定时的答案，$h_x$ 表示 $x$ 子树的高度，即擂主获胜需要的能力值。

一个显然的 $O(n \log^2 n)$ 做法是，由于每个人的能力值只有不超过 $\log_2 n$ 的部分是有效的，所以我们可以逐个确定能力值，对每个子树维护这个子树可能的胜者集合。具体来讲，我们可以对一个子树维护 $c_i$ 表示有多少个能力值为 $i$ 的人可能成为这个子树的胜者。

但是这太慢了。所以我们来观察一些性质。

首先，一个人可能会成为最终胜者计入答案中，当且仅当他在所有比赛中都没有**确定地被打败**。

> 我们观察到一个人似乎是在某一个时刻之后被确定地打败的......也就是说，这个人会在一段时刻前缀被计入答案。我们尝试具体描述一下这个前缀到底长什么样。如果可以描述清楚，这个题就做完了。

具体分析一下可以看出，一个人在一次比赛中确定地被打败只有以下两种情况：

- 这个人不是擂主，而且他的兄弟子树有一个唯一的，已知能力值足够的胜者；

- 这个人是擂主，但能力值不够。

我们发现第二个条件是容易的：在这个人的能力值尚未确定的时候，他不会受到这个条件的限制；在这个人的能力值确定之后，他的能力值就需要至少是所有他参加的他是擂主的比赛的最大值。这个容易线性处理出所有限制，而且和时刻无关。

要想考虑第一个条件，我们就仔细考虑一下子树确定胜者相关的事情。

对于一个子树 $x$ 而言，存在一个时刻 $t_x$，在这个时刻之后，这个子树会有一个唯一确定的胜者 $f_x$，并且这个胜者不会改变。

> 也就是说，在 $t_x$ 这个时刻，这个子树内的除了 $f_x$ 之外的所有人（无论其能力值是否确定），都已经**确定会被打败**。故显然 $f_x$ 不会改变。

那么，假如当前时刻为 $T$，这个人不是擂主而且他的兄弟子树是 $u$，他会被第一个条件打败就当且仅当 $T \ge t_u$ 并且 $a_{f_u}$ 足够赢下当前比赛。也就是说，假如 $a_{f_u}$ 够大，他就只能贡献在 $t_u-1$ 或更早的时刻。

好的！看来每个人贡献到答案的时刻确实是一个前缀（因为是很多个前缀的交），但是我们还不知道 $f_x$ 和 $t_x$ 怎么求。

我们考虑在树上 dp，那么 $f_x$ 和 $t_x$ 就可以由孩子节点的 $f$ 和 $t$ 值分类讨论一下得到了。值得一提的是，一个子树的胜者确定的时间不一定是其两个孩子确定时间的最大值：在左孩子是擂主的情况下，有可能左孩子确定之后直接赢了，就没有右孩子什么事了。

获胜的人是谁直接根据题意判一判就好。

因为一个人会参加 $O(\log n)$ 场比赛，所以要做到线性的话，我们不能对每个人大力枚举所有的比赛，而是可以用类似线段树标记下传的方式把所有限制传到叶子上。

实现上，我们一遍 dfs 预处理出每个子树的 $f$ 和 $t$，第二遍 dfs 计算所有限制并下传，然后再差分一下就可以求出所有时刻的答案了。

时间复杂度 $O(T(n+m))$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N ((1<<17)+5)
ll diff[N];
int fc[N<<1],tc[N<<1];
int a[N];
int n,m,Tc;
char tmp[N];
int D[N];
int A[N],c[N];
int K;
void dfs1(int x,int h){
    if(!h){
        fc[x]=a[x-(1<<K)+1];
        tc[x]=x-(1<<K)+1;
        return;
    }
    dfs1(x<<1,h-1);
    dfs1(x<<1|1,h-1);
    if(!D[x] && fc[x<<1]>=h)tc[x]=tc[x<<1];
    else tc[x]=tc[x<<1|1];
    fc[x]=fc[x<<1|(D[x]^(fc[(x<<1)|D[x]]<h))];
}
void dfs2(int x,int hi,int h,int L,int R){
    if(L>R)return;
    if(!h){
        int v=x-(1<<K)+1;
        if(L<min(R,v))diff[L]+=v,diff[min(R,v)]-=v;
        if(a[v]>=hi && max(v,L)<R)diff[max(v,L)]+=v,diff[R]-=v;
        return;
    }
    if(!D[x]){
        dfs2(x<<1,max(hi,h),h-1,L,R);
        dfs2(x<<1|1,hi,h-1,L,fc[x<<1]>=h?min(R,tc[x<<1]):R);
    }
    else{
        dfs2(x<<1,hi,h-1,L,fc[x<<1|1]>=h?min(R,tc[x<<1|1]):R);
        dfs2(x<<1|1,max(hi,h),h-1,L,R);
    }
}
int main(){
    freopen("arena.in","r",stdin);
    freopen("arena.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&A[i]);
    for(int i=1;i<=m;i++)scanf("%d",&c[i]);
    K=__lg(n-1)+1;
    for(int d=K-1;d>=0;d--){
        scanf("%s",tmp);
        for(int i=0;i<(1<<d);i++)D[i+(1<<d)]=tmp[i]-'0';
    }
    scanf("%d",&Tc);
    while(Tc--){
        int X[4];
        scanf("%d%d%d%d",&X[0],&X[1],&X[2],&X[3]);
        for(int i=1;i<=n;i++)a[i]=A[i]^X[i&3];
        dfs1(1,K);
        for(int i=0;i<=n;i++)diff[i]=0;
        for(int d=0;d<=K;d++)dfs2(1<<(K-d),0,d,d==0?1:(1<<(d-1))+1,(1<<d)+1);
        for(int i=1;i<=n;i++)diff[i]+=diff[i-1];
        ll ans=0;
        for(int i=1;i<=m;i++)ans^=i*diff[c[i]];
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：Caii (赞：43)

自底向上做很难不带 $\log$，所以我们只能采取自顶向下的方式获取每个前缀的答案。当我们递归到线段树代表 $c_i+1$ 的叶子节点时获取 $c_i$ 对应的答案。

当补充后参赛选手人数为 $2^k$ 时，对应原来的参赛人数在 $2^{k-1}+1\sim 2^k$ 之间，这些前缀对应线段树的叶子节点 $2^{k-1}+2\sim 2^k+1$，注意到 $2^k+1$ 这个点不是很和谐，不过还好，它对应参赛人数为 $2^k$ 时的答案，这个我们是可以 $O(1)$ 得到的，而 $2^{k-1}+1\sim 2^k$ 部分叶子节点刚好在同一棵子树内，因此我们尝试递归这颗子树来获取答案。

考虑线段树代表 $1\sim 2^k$ 的顶点，其左区间为 $1\sim 2^{k-1}$，右区间为 $2^{k-1}+1\sim 2^k$，当补充后参赛人数为 $2^k$ 时会对应到这个顶点，左区间全部都是报名选手，右区间有部分报名选手以及部分补充选手。考虑决赛，如果左区间（编号较小的选手）是擂主，因为左区间的参赛选手是确定的，所以我们可以直接知道决赛的胜负，如果左区间的选手胜利，那么右区间，也就是 $c_i$ 在 $2^{k-1}+1\sim 2^k-1$ 时，不论补充选手能力值如何，都是左区间的选手获得唯一冠军，直接赋值即可；如果左区间的选手失败，那么冠军为右区间对应的胜者，尝试使用递归解决问题。而如果右区间的选手是擂主，此时因为右区间存在补充选手，因此情况会变得复杂，不过还是抓住左区间的胜者是确定的这件事，可以将这个条件变成限制：如果右区间的胜者为报名选手且能力值小于 $k$，或者存在右区间的胜者为补充选手，则左区间的胜者可以是冠军。在接下来我们将围绕这个限制进行解题。

递归中，我们需要维护一个数组 $vt$ 以及一个量 $rd$，表示如果递归区间胜者能力值为 $i< rd$，则冠军为 $vt_{i+1}$，否则冠军为递归区间胜者。分编号较小（左区间）/较大（右区间）的选手为擂主两种情况讨论：

- 编号较小的选手为擂主。
- - （右区间冠军计算）此时擂主是确定的，擂主是否胜利也是确定的，继续分类讨论：如果擂主胜利，那么当前区间不论右区间选手如何，胜者都是左区间胜者，查表 $vt$ 即可直到当前区间冠军，区间赋值即可。如果擂主失败，则冠军只与右区间有关，递归即可。
  - （左区间冠军计算）此时右区间都是补充选手，考虑将左区间胜者能力值转化为限制：如果左区间胜者能力值不超过当前轮次，则右区间的补充选手都可能成为冠军。将这个限制写进 $vt$ 中递归即可。
- 编号较大的选手为擂主。
- - （右区间冠军计算）同样考虑将左区间胜者转化为限制之后递归：分左区间胜者能力值与 $rd$ 的关系讨论。如果能力值大于等于 $rd$ 则说明只有擂主输了左区间就可以成为冠军，因此限制为如果当前区间胜者为补充选手或者为能力值小于当前轮次的报名选手，则左区间胜者可以成为冠军，写进 $vt$ 中递归即可。如果其能力值小于 $rd$，此时即使左区间输了，他也不能成为冠军，但是他之后能赢一些场次从而能迫使一部分选手不能成为冠军，同样修改 $vt$ 之后递归即可。
  - （左区间冠军计算）右区间都是补充选手，这也就说明 $vt$ 表中的所有选手都可以成为冠军，因此此时相当于是区间加法，然后清空 $vt$ 表（但不能清空 $rd$，因为 $rd$ 对左区间内选手能否成为冠军的限制依旧有效）递归即可。

精细地维护 $vt$ 表即可做到 $O(n)$ 预处理出所有答案，然后 $O(1)$ 询问，总时间复杂度为 $O(T(n+m))$，可以获得 $100$ 分。

```c++
#include <bits/stdc++.h>

using LL = long long;

const int N = 1 << 18 | 7;
const int M = 18;

int n, m, t, aa[N], a[N], c[N];
int b[N], r[N], id[N], lp[N], rp[N];
LL sum[N], ans[N];
char s[M][N];

void build() {
  for(int i = 0; i < t; ++i) {
    r[i + t] = 0;
    id[i + t] = i;
    b[i + t] = i + 1;
    sum[i + t] = lp[i + t] = rp[i + t] = i + 1;
  }
  for(int i = t - 1; i >= 1; --i) {
    r[i] = r[i << 1] + 1;
    id[i] = id[i << 1] >> 1;
    lp[i] = lp[i << 1];
    rp[i] = rp[i << 1 | 1];
    sum[i] = sum[i << 1] + sum[i << 1 | 1];
    if(s[r[i]][id[i]] == '0')
      b[i] = a[b[i << 1]] >= r[i] ? b[i << 1] : b[i << 1 | 1];
    else
      b[i] = a[b[i << 1 | 1]] >= r[i] ? b[i << 1 | 1] : b[i << 1];
  }
}

LL vt[N], st;
int rd;
void dfs(int i, LL ss, int zl) {
  if(i >= t) {
    ans[i - t] = st + ss + lp[i];
    return ;
  }
  LL trd = rd, tst = st;
  if(s[r[i]][id[i]] == '0') {
    if(b[i] == b[i << 1]) {
      LL v = a[b[i]] >= rd ? b[i] : a[b[i]] + 1 >= zl ? 0 : vt[a[b[i]] + 1];
      std::fill(ans + lp[i << 1 | 1] - 1, ans + rp[i << 1 | 1], v + ss);
    }
    else {
      vt[r[i]] = vt[r[i] + 1];
      dfs(i << 1 | 1, ss, zl);
    }
    rd = trd, st = tst;
    rd = std::max(rd, r[i]);
    st += sum[i << 1 | 1];
    vt[r[i]] = st;
    dfs(i << 1, ss, zl);
  }
  else {
    vt[r[i]] = 0;
    st = 0;
    dfs(i << 1, ss + sum[i << 1 | 1] + tst, r[i]);
    st = tst, rd = trd;
    if(a[b[i << 1]] >= rd) {
      rd = std::max(rd, r[i]);
      vt[r[i]] = b[i << 1];
      st += b[i << 1];
      dfs(i << 1 | 1, ss, zl);
    }
    else {
      int tp = std::max(r[i], a[b[i << 1]]) + 1;
      vt[r[i]] = tp >= zl ? 0 : vt[tp];
      dfs(i << 1 | 1, ss, zl);
    }
  }
  vt[r[i]] = 0;
  rd = trd, st = tst;
}
 
void solve() {
  build();
  for(int i = 1; i < t; i <<= 1)
    if(s[r[i]][id[i]] == '0')
      if(b[i] == b[i << 1])
		std::fill(ans + lp[i << 1 | 1] - 1, ans + rp[i << 1 | 1], b[i]);
      else {
        vt[r[i]] = 0;
        rd = st = 0;
        dfs(i << 1 | 1, 0, 20);
      }
    else {
      rd = r[i];
      st = vt[r[i]] = b[i << 1];
      dfs(i << 1 | 1, 0, 20);
    }
  LL val = 0;
  for(int i = 1, x; i <= m; ++i) {
    for(x = 0; (1 << x) < c[i]; ++x) ;
    LL v = (1 << x) == c[i] ? b[t / c[i]] : ans[c[i]];
    //printf("%lld ", v);
    val ^= i * v;
  }
  printf("%lld\n", val);
}

int main() {

  freopen("arena.in", "r", stdin);
  freopen("arena.out", "w", stdout);
    
  scanf("%d%d", &n, &m);
  for(int i = 1; i <= n; ++i)
    scanf("%d", &aa[i]);
  for(int i = 1; i <= m; ++i)
    scanf("%d", &c[i]);
  for(t = n; t & (t - 1); t += t & -t) ;
  for(int i = 1; (1 << i) <= t; ++i)
    scanf("%s", s[i]);
  
  int cases;
  scanf("%d", &cases);

  while(cases--) {
    int x[4];
    scanf("%d%d%d%d", &x[0], &x[1], &x[2], &x[3]);
    for(int i = 1; i <= n; ++i)
      a[i] = aa[i] ^ x[i & 3];
    solve();
  }
  
  return 0;

}
```

---

## 作者：Lonely_NewYear (赞：36)

# P11234 题解

考场做法。

## 题目大意

太复杂，自己看题面吧。

## 题目分析

直线考虑怎么线性。

先把整个过程看成一个完全二叉树。

一个人能走到最后有两个条件：自己擂主时能力值要够大，别人擂主时别人的能力值要够小。第一个条件很容易，预处理出每个点到根最后一次当擂主的轮数就行。第二个条件则需要预处理出每个子树最小能让能力值多小的人胜出。

实际上每个子树只有两种可能：胜出者固定为某个人，或者胜出者的能力值可以取当前轮数以上的任意值。记 $f_u$ 表示子树 $u$ 的胜出者能力值，$f_u=-1$ 表示可以任取，记 $h_u$ 表示节点 $u$ 的轮数，不妨设左孩子是擂主，则：

$$f_u=\begin{cases}f_{ls}&f_{ls}\ge h_u\\-1&f_{ls}=-1\\f_{rs}&otherwise\end{cases}$$

容易发现在 $n$ 个人逐渐加入的过程中，任意一个点的 $f$ 总是初始是 $-1$，某一时刻变为 $\ge0$ 的值后一直不变。所以在 $n$ 个人逐渐加入时，从对应的叶子节点向上更新 $f$，直到某个点处 $f$ 不变，复杂度是线性的。

那么当一个节点的 $f$ 值变为 $\ge0$ 时，如果下一轮中这个节点是擂主且 $f_u\ge h_{fa}$，那么 $u$ 的兄弟节点的子树中的所有人就再也不可能走到最后。这时候可以再维护一个 $g_u$ 表示加入第几个人之后，子树 $u$ 中的人就再也不可能走到最后了。$n$ 个人都加入后，求出每个点到树根路径上的 $g$ 最小值，即 $g_u=\min(g_u,g_{fa})$，得出叶子节点处的 $g$，也就是每个人在哪个时间前还有可能走到最后。

求出叶子节点的 $g$ 后，一个人对于答案的贡献就是一个前缀加。差分一下可以实现线性求出所有询问的答案。

整个过程是这样的：初始 $f=-1$，从 $1\sim n$ 逐个加入每个人，将 $f_u$ 改为 $a_i$，并向上更新。如果某个点的擂主被确定，则用当前时间更新另一颗子树的 $g$。结束后把 $g$ 推下来，对于每个人做一个前缀加。

人数太少时树的结构会变化，只需要每次人数达到 $2^k$ 时重做一遍就行。

总复杂度线性。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100001;
int n,m,k;
int a[N];
int c[N];
char d[N*2];
int f[N*4],g[N*4],h[N*4],b[N*4];
void dfs(int i,int t){
	f[i]=-1,g[i]=t+1;
	if(i>=(1<<k))return;
	int j=(i<<1)+d[i]-'0';
	h[j]=h[j^1]=h[i]-1;
	if(b[i])b[j]=b[j^1]=b[i];
	else b[j]=h[i],b[j^1]=0;
	dfs(j,t),dfs(j^1,t);
}
void upd(int i,int t){
	if(!i)return;
	if(f[i]!=-1)return;
	int j=(i<<1)+d[i]-'0';
	if(f[j]>=h[i])f[i]=f[j],g[j^1]=min(g[j^1],t);
	else if(f[j]!=-1)f[i]=f[j^1];
	if(f[j]!=-1)upd(i>>1,t);
}
void get(int i){
	if(i>=(1<<k))return;
	int j=(i<<1)+d[i]-'0';
	g[j]=min(g[j],g[i]);
	g[j^1]=min(g[j^1],g[i]);
	get(j),get(j^1);
}
ll s[N*2],res[N*2];
void solve(int t){
	int p=1<<(k-t);
	h[p]=t,b[p]=0;
	dfs(p,1<<t);
	for(int i=1;i<=n;i++){
		int j=i+(1<<k)-1;
		if(a[i]<b[j])g[j]=min(g[j],i);
		f[j]=a[i];
		upd(j>>1,i);
	}
	get(p);
	for(int i=1;i<=(1<<t);i++)s[i]=0;
	for(int i=1;i<=(1<<t);i++){
		int j=i+(1<<k)-1;
		s[g[j]-1]+=i;
	}
	for(int i=(1<<t);i>=1;i--){
		s[i-1]+=s[i];
		res[i]=s[i];
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	while((1<<k)<n)k++;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>c[i];
	for(int i=k-1;i>=1;i--)
		for(int j=0;j<(1<<i);j++)
			cin>>d[(1<<i)+j];
	cin>>d[1];
	int T;
	cin>>T;
	while(T--){
		int x[4];
		cin>>x[0]>>x[1]>>x[2]>>x[3];
		for(int i=1;i<=n;i++)a[i]^=x[i%4];
		for(int i=k;i>=0;i--)solve(i);
		ll ans=0;
		for(int i=1;i<=m;i++)ans^=i*res[c[i]];
		cout<<ans<<'\n';
		for(int i=1;i<=n;i++)a[i]^=x[i%4];
	}
	return 0;
}
```

谢谢观看！

---

## 作者：ppip (赞：32)

水题，但考场上没调出来。

$H_i$：擂主晋级到点 $i$ 需要的点数。叶子处等于 $0$。

$W_i$：点 $i$ 子树内完全确定时，点 $i$ 的赢家。

先把树建出来，然后定义一个结点是自由的，当且仅当这个结点的权值可以同时取到 $\le H_i$ 和 $> H_i$。然后定义 $T_i$ 表示最后一次自由的时刻（时刻 $i$ 的定义是：前 $i$ 个叶子取值确定，剩下的任意）。

显然对于叶子，第 $k$ 个叶子的取值是 $k-1$。

然后可以发现自由的时刻总是一个前缀：因为子树内不确定的叶子显然更多不劣。

然后就可以很轻松的递推求出 $T$。

求 $T$ 的代码片段，$D_i$ 表示擂主，这里顺便求了 $W_i$。`K-__lg(i)` 就是 $H_i$。 

```cpp
if (!D[i]) {
      if (WN[i<<1]<K-__lg(i)) TM[i]=TM[i<<1|1],WN[i]=WN[i<<1|1];
      else TM[i]=TM[i<<1],WN[i]=WN[i<<1];
} else {
      TM[i]=TM[i<<1|1];
      if (WN[i<<1|1]>=K-__lg(i)) WN[i]=WN[i<<1|1];
      else WN[i]=WN[i<<1];
}
```

求完之后考虑哪些叶子有贡献。为了方便，我们对于每个 $2^k$ 分别做，这样要用到的树是确定的。

考虑每个叶子分别在确定和不确定时刻的贡献：

不确定：要求它所有祖先都是自由的，对它们自由的时刻取 $\min$ 即可。

确定：首先祖先上它这个分支作为擂主的结点它必须能通过（这个容易提前求出）；然后它祖先上的结点要么自由，要么 $W_p$ 是它。这个从上到下 DP 计算即可。

于是可以发现有贡献的时刻的限制是一个区间，差分计算贡献即可。复杂度 $O(Tn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N(2e5);
int a[N+5],c[N+5];
int D[2*N+5],TM[2*N+5],WN[2*N+5],FA[N*2+5],FRT[N*2+5],to[N*2+5],LG[N+5];
long long res[N+5];
int K;
void solve(int n) {
    for (int i{1};i<=(1<<K);++i)
        if (i<=n) TM[i+(1<<K)-1]=i-1,WN[i+(1<<K)-1]=a[i];
        else TM[i+(1<<K)-1]=1<<K;
    for (int i{1};i<=n;++i) to[i+(1<<K)-1]=FA[(i+(1<<K)-1)>>min(K,a[i])],res[i]=0;
    for (int i{(1<<K)-1};i>=1;--i) {
        if (!D[i]) {
            if (WN[i<<1]<K-LG[i]) TM[i]=TM[i<<1|1],WN[i]=WN[i<<1|1];
            else TM[i]=TM[i<<1],WN[i]=WN[i<<1];
        } else {
            TM[i]=TM[i<<1|1];
            if (WN[i<<1|1]>=K-LG[i]) WN[i]=WN[i<<1|1];
            else WN[i]=WN[i<<1];
        }
    }
    for (int W{0};W<=K;++W) {
        int O{(1<<K-W)-1};
        FRT[O+1]=1<<K;
        for (int i{1};i<1<<W;++i) {
            int p{(O<<LG[i])+i};
            FRT[p<<1|1]=FRT[p];
            FRT[p<<1]=FRT[p];
            if (!D[p]) {
                if (WN[p<<1]>=K-LG[p]) FRT[p<<1|1]=min(FRT[p<<1|1],TM[p]);
                else FRT[p<<1]=min(FRT[p<<1],TM[p<<1]);
            } else {
                if (WN[p<<1|1]>=K-LG[p]) FRT[p<<1]=min(FRT[p<<1],TM[p]);
                else FRT[p<<1|1]=min(FRT[p<<1|1],TM[p<<1|1]);
            }
        }
        for (int i{0};i<1<<W;++i) {
            int p{i+(1<<K)};
            if (i+1<=n&&to[p]>=W&&FRT[p]>=i+1&&FRT[p]>=(W?(1<<W-1):0)+1) {
                res[max(i+1,(W?(1<<W-1):0)+1)]+=i+1;
                res[min(FRT[p],1<<W)+1]-=i+1;
            }
            if (W>0&&i>(1<<W-1)&&FRT[p]>=(1<<W-1)) {
                res[(1<<W-1)+1]+=i+1;
                res[min(i,FRT[p])+1]-=i+1;
            }
        }
    }
    for (int i{1};i<=n;++i) res[i]+=res[i-1];
}
signed main() {
    // freopen("arena.in","r",stdin);
    // freopen("arena.out","w",stdout);
    cin.tie(nullptr)->sync_with_stdio(false);
    int n,m;cin>>n>>m;
    for (;(1<<K)<n;++K);
    for (int i{1};i<=n;++i) cin>>a[i];
    for (int i{1};i<=m;++i)
        cin>>c[i];
    for (int i{1};i<=K;++i) {
        string s;cin>>s;
        for (int j{0};j<1<<(K-i);++j)
            D[(1<<(K-i))+j]=s[j]-'0';
    }
    FA[1]=K;
    for (int i{2};i<1<<(K+1);++i) {
        LG[i]=__lg(i);
        if ((i&1)!=D[i>>1]) FA[i]=FA[i>>1];
        else FA[i]=K-LG[i];
    }
    int T;cin>>T;
    while (T--) {
        int x[4];
        cin>>x[0]>>x[1]>>x[2]>>x[3];
        for (int i{1};i<=n;++i) a[i]^=x[i&3];
        solve(n);
        long long ans{0};
        for (int i{1};i<=m;++i) ans^=1LL*i*res[c[i]];
        for (int i{1};i<=n;++i) a[i]^=x[i&3];
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：PosVII (赞：25)

## 前言

没挂就是场切！！！！！！！！！！

虽然 $O(n \log\log n)$，但是卡不满。

upd: 原来我写的就是 $O(n)$。

最后两分钟才调出来，肉眼看大样例没啥问题，应该能过吧？

## 题解

考虑一个点能爬到顶点的条件：

1. 当下一轮是以它为擂主，则它的能力值足够。
2. 当下一轮是以另一个子树为擂主，则要求另一个子树存在一种方案使得最终的点会在本轮输掉。

第一钟情况可以直接使用位运算 $O(n)$ 处理，考虑第二种情况。

第二种情况，我们考虑到真正有效的值范围是 $[0,k]$，其它的值可以和 $k$ 取较小值得到。

考虑 dp 确定每个子树最终能得到的值的集合，发现是有可能变化的，但是因为每次变化是变成原来的子集（不难证明），所以变化量是 $O(k)$ 的。

暴力归并两个子树合并即可，发现底层的节点变化数量没满，而上面的节点变化数量满但是节点数较少，可以证明上界是 $O(n \log \log n)$ 的。

统计答案的部分精细实现可以做到 $O(n)$ 或 $O(n \log \log n)$。

upd: 我精细实现的过程中去掉了不必要的状态（即只保留同时存在 $\leq dep$ 和 $> dep$ 的状态），可以证明此时状态数是 $O(1)$ 的，所以实际上这个方法是 $O(n)$ 的。

以上。

---

## 作者：max0810 (赞：22)

本文同步发表于 [cnblogs](https://www.cnblogs.com/max0810/p/18508595)。

## 前言

作者在考场上用了约 1h 把前三道题做完了，然后用了约半小时想了带 $\log$ 的做法，但是我决定放手一搏去想线性的做法，于是又想了有 1h 之后觉得想到了正解，然后我就一直写到了考试结束，但是最终没有调出来遗憾离场，因此写个题解来纪念一下。

## 题解

首先因为 $n,m$ 是同阶的，所以肯定是考虑把所有位置的答案全部算出来。首先，设 $N$ 为第一个不小于 $n$ 的 $2$ 的整数次幂，我们用 $N-n$ 个 $0$ 去补齐剩下的位置，第一步肯定是把所有轮获胜的人用一棵线段树建出来，这一步是好做的。

现在考虑依次求出每个位置的答案 $ans_i$，我第一想法是正着去扫，但是感觉不太好做，所以决定倒着去扫。有一个显然的结论就是，如果一个位置从一个确定的数变成了任意值，那么原来在答案里的人现在依然在答案里，也就是说，对于二进制位数相同的一段，$ans_i$ 是不增的，于是现在就考虑计算如果一个位置由确定值变成了任意值，有哪些新的可能的答案。当然，对于二进制位数不同的段，每次都要清空并重新计算，以下仅考虑对于同一个段的计算。

首先，我们线段树先预处理出了每个结点是哪一个人会获胜，对于当前的段，答案里肯定有本来就会获胜的那一个人，所以先讲其计入答案（注意，以下说的计入答案都指的是先判断这个人是否已被计入答案再加，因为可能有重复）。

接着，如果对于一个线段树的结点，满足以下条件，我们就将其称为坏点：这个区间的 $d=0$，且编号小的人会获胜。如果一个结点是坏点，那么对于这个结点右儿子中包含的所有的人，他们由确定值变为任意值对答案都是没有贡献的，因为到这个结点的时候他们一定都会被打败（所有人是从后往前一个一个变为不确定的，所以一个人变之后前面的所有人的值依然是确定的）。那么我们可以给整个区间打上标记，表示这个区间都没有贡献。如果扫到了一个被打标记的人，就直接跳过。

否则的话，这个人一定是有贡献的，因为只要将他的初始值设为 $\infty$，他就一定会赢，将他计入答案。接着考虑哪些人也会跟着计入答案，我们考虑从当前这个人代表的叶子结点不断往上跳。设当前点为 $x$，父亲为 $fa_x$，我们分 $x$ 是 $fa_x$ 的左儿子还是右儿子两种情况来考虑：

- $x$ 是右儿子，那么 $fa_x$ 的左儿子结点的胜者 $y$ 就有可能会被记入答案，具体的，我们对于每一个结点都再记录一个值 $mx$，表示根到这个结点的所有对局中，$d$ 为选到它的所有对局中轮数最大的是多少，这个也可以在预处理中简单计算。那么如果 $a_y\ge mx$，$y$ 就能被计入答案，因为我们可以将所有的任意值设为刚好在与 $y$ 对局时输掉，这样就能获胜。
- $x$ 是左儿子且 $fa_x$ 是一个坏点，那么此时 $fa_x$ 右儿子中的所有人都已经变成了任意值，他们都应该被计入答案。可以理解为这些人原来有个限制使得他们不能获胜，现在这个限制没了，所以这些人都可以获胜了。
- $x$ 是左儿子且 $fa_x$ 不是一个坏点，那么在继续往上跳的贡献都已经被 $fa_x$ 的右儿子计算过了，直接 break。

于是，我们就计算完了所有的贡献，每次在一个人变之前，让 $ans_i$ 赋为当前的答案即可。

考虑时间复杂度，首先建树什么的都是线性的，然后对于计算答案的部分，我们考虑对于每一个线段树的结点，它不可能同时被左儿子和右儿子访问（因为被左儿子访问要求这是个坏点，但是如果是坏点的话右儿子直接被打上标记跳过了），所以每个结点都只会被访问一次，所以复杂度是 $\mathcal{O}(Tn)$ 的。

另外，还有一个需要注意的问题：如果每一个二进制位数不同的段都预处理 $mx$ 的话常数太大了，我们发现每个结点的 $d$ 是一开始给定的，所以这个只需要在 $T$ 组数据前预处理即可。其他细节，比如读入之类的具体可以看代码。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ls x<<1
#define rs x<<1|1
#define lson x<<1,l,mid
#define rson x<<1|1,mid+1,r
#define ll long long
using namespace std;
const int N = (1<<17)+5;
int mx[20][N<<2],lg[N],aa[N],ok[N],a[N],c[N],n,m,nn = 1;
bool vis[N];ll ans[N],sum;
struct node{ll sum;int x;bool tp,d;}t[N << 2];
inline void build(int x,int l,int r)
{
    if(l == r){t[x].x = l;return ;}
    int mid = l+r>>1,k = lg[r-l+1],d = t[x].d;
    build(lson);build(rson);
    int win = a[t[x<<1|d].x] >= k;
    t[x].x = t[x<<1|(d^!win)].x;
    if(!d&&win)t[x].tp = 1,ok[r]++,ok[mid]--;
    else t[x].tp = 0;
}
inline void build2(int x,int l,int r,int *mx)
{
    t[x].sum = (l+r)*(r-l+1ll)/2;
    if(l == r)return ;
    int mid = l+r>>1,k = lg[r-l+1],d = t[x].d;
    if(~mx[x])mx[ls] = mx[rs] = mx[x];
    else mx[x<<1|d] = k;
    build2(lson,mx);build2(rson,mx);
}
inline void up(int x){sum += !vis[x]*x;vis[x] = 1;}
inline int rd()
{
    char c;int f = 1;
    while(!isdigit(c = getchar()))if(c=='-')f = -1;
    int x = c-'0';
    while(isdigit(c = getchar()))x = x*10+(c^48);
    return x*f;
}
inline char gc()
{char c;while((c = getchar()) <= ' ');return c;}
int main()
{
    // freopen("arena.in","r",stdin);
    // freopen("arena.out","w",stdout);
    n = rd();m = rd();
    for(int i = 1;i <= n;i++)aa[i] = rd();
    for(int i = 1;i <= m;i++)c[i] = rd();
    while(nn < n)nn <<= 1;
    for(int i = 2;i <= nn;i++)lg[i] = lg[i>>1]+1;
    for(int i = nn/2;i;i >>= 1)
        for(int j = i;j < i*2;j++)
            t[j].d = gc()-'0';
    memset(mx,-1,sizeof mx);
    for(int s = 0;(1<<s) <= nn;s++)
        build2(1<<s,1,nn>>s,mx[s]);
    for(int T = rd();T--;)
    {
        int yh[4] = {rd(),rd(),rd(),rd()};
        for(int i = 1;i <= n;i++)a[i] = aa[i]^yh[i&3];
        memset(ok,0,sizeof ok);build(1,1,nn);
        for(int i = nn,rt = 1,s = 0;i;i--)
        {
            if((1<<lg[i]) == i)
            {
                if(i != nn)rt <<= 1,s++;
                for(int j = 1;j <= i;j++)vis[j] = 0;
                sum = 0;up(t[rt].x);
            }
            ans[i] = sum;
            if(ok[i] += ok[i+1])continue;
            up(i);int x = i+nn-1;
            while(x != rt)
            {
                int d = x&1;x >>= 1;
                if(!d)
                    if(t[x].tp)sum += t[rs].sum;
                    else break;
                else if(a[t[ls].x] >= mx[s][ls])up(t[ls].x);
            }
        }
        ll num = 0;
        for(int i = 1;i <= m;i++)num ^= i*ans[c[i]];
        printf("%lld\n",num);
    }
    return 0;
}
```

## 总结

这是一道细节很多的好题，我觉得考场上至少再给我个 1h 才能写出来，但是我觉得能想出来已经很不错了，NOIP 再战吧！

关于代码或做法有任何问题的欢迎私信我！

---

## 作者：山田リョウ (赞：18)

害我写检讨的垃圾题，强烈谴责低素质出题人！！！

（方便起见，我们认为加第 $i$ 个人就是第 $i$ 个时刻）

首先一眼会得出一个在线加点的 $O(T n\log n)$ 做法，并感觉出应该可以通过出色的剪枝摊掉变成 $O(T n)$，但是我失败了。

比较严重的问题其实是出在每层擂主胜利条件是有区别的，致使从儿子向父亲转移时还需要删一部分不符合条件的点，这也太难了。

直觉告诉我可以再丢些东西摊掉，例如一个人只会被删 $O(1)$ 次，但是还是失败了。因为你需要动态维护些类区间和的东西，这个无法避免复杂度中 $\log n$ 的出现。

但是这并不是没有用的，它启发我们每个人能作为最终胜利者的区间其实是 $O(1)$（具体来说最多是 $2$ 个） 个的，所以考虑枚举人。

只不过在一切之前最好先把一些可能导致细节过多的东西消去，例如不同前缀需要跑的轮数可能是不一样的。但是考虑到 $\sum\limits_{k=0}^{n-1}2^k=2^n-1$，故枚举轮数即可。

固定轮数后每个人可以成为胜者是一个前缀，于是我们只需要找到使得他依然可以成为胜者的最大时间点即可。

分析一下一个人 $u$ 的胜利路径，大概可以拆分成 $u$ 到在 $l$（满足 $a_u\geq l$）的点 $v$ 使得要么他是擂主，要么擂主失败，以及 $v$ 到根的路径满足每一步均不是擂主且擂主失败。

考虑到合法的 $v$ 均在一条链上，枚举它在子树内树形 dp 即可。

具体来说，我们如何计算一个最大的时刻使得一个子树内的胜者的权值小于其父亲的深度？考虑到每个点 $u$ 的子树的胜者的权值要么一定可以在 $[\operatorname{depth}(u),2^{31})$ 上任取，要么一定是 $n$ 时刻时该子树的胜者的权值。

所以预处理出 $n$ 时刻每个子树的胜者以及使得子树胜者固定的最小时刻即可。

综上，时间复杂度为 $O(T n)$，洛谷上可能略微卡常，我最终通过的代码加了快读快写以及循环展开才过的。具体实现可以参考[我的代码](https://www.luogu.com.cn/paste/qnbqi9rb)对照下。

---

## 作者：rubbishZZZ (赞：14)

# [CSP-S 2024] 擂台游戏

看了看题解，全是从上往下做的，但是我就喜欢从下往上。

首先我们对于每个 $[2^i+1,2^{i+1}]$ 的区间单独处理，因为树的形态是一致的，如果单次能做到 $O(2^i)$ 就能做到 $O(Tn)$。

我们考虑某个 $2^{k-1}\lt n\leq 2^k$，那每个叶子结点都有一条往上的链，是**包赢**的。也就是说，无论 $(n,2^k]$ 内的节点如何选，这些节点都是某个定制。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/bmb4i2t9.png)

其中最下面的是权值，其余的是 $g$，那么每个点**包赢**的区间为：

![](https://cdn.luogu.com.cn/upload/image_hosting/3miruv8w.png)

好，那么好，一个点 $u$ 可以赢的充要条件是什么呢？

1. 该点包赢区间上方不能有其他包赢的点。
2. 该点到根路径上，对于他是 $x$ 左儿子且 $g=0$ 的情况以及他是右儿子且 $g=1$ 的情况，需要满足 $a_u\geq dep_x$，$dep_x$ 是从下往上的深度。

这为什么是对的呢？

1. 对于没有包赢的点，他的权值可以是任意。
2. 上面的第二点保证了存在一种权值放置方法使得可以到根。

男人！我说的什么罐头？

那么我们先将一个点 $u$ 的权值设为满足第二条的话就为 $u$ 否则为 $0$，再建个线段树。

然后我们就从 $2^{k-1}+1$ 到 $2^k$ 进行枚举，每个点对于包赢的情况再线段树上一直往上跳，记左右儿子为 $ls,rs$。

1. 如果作为 $rs_u$ 跳到一个点 $u$，且 $ls_u$ 是对于 $v$ 包赢的，那么减掉 $v$ 的权值。
2. 如果作为 $ls_u$ 跳到一个点 $u$，就减掉 $rs_u$ 内所有点的权值，然后下一次枚举的时候直接从 $rs_u$ 内最右的点的下一个开始枚举。
3. 如果作为 $rs_u$ 跳不动了，但是 $ls_u$ 由于 $rs_u$ 跳不动而跳的动了，那么就减掉 $rs_u$ 包赢的权值，$ls_u$ 接着向上跳。

我们发现每个点最多会被跳到一次，所以做下来复杂度是线性的，那么此题救以 $O(Tn)$ 做完了。

但是考场上没写出来，怎么回事呢，曼巴出去！

更新：加个代码


```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <ctime>
#include <random>
#include <cassert>
#include <numeric>
#include <cmath>
#include <bitset>
#include <ext/pb_ds/assoc_container.hpp>
#define pii pair<int, int>
#define fi first
#define se second
#define MP make_pair
#define ep emplace
#define eb emplace_back
//#define int long long
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
typedef double db;
typedef long double ldb;
typedef long long ll;
//typedef __int128 lll;
typedef unsigned long long ull;
typedef unsigned int ui;
using namespace std;
using namespace __gnu_pbds;
bool Mbe;

char buf[1 << 20], *p1, *p2;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1<<20,stdin), p1 == p2) ? 0 : *p1++)
int read() {
    int s = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
        f ^= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9')
        s = s * 10 + c - '0', c = getchar();
    return f ? s : -s;
}
template<typename T>void chkmax(T &x, const T &y) { x = max(x, y); }
template<typename T>void chkmin(T &x, const T &y) { x = min(x, y); }

const int N = 1000005;
int n, m, lim;
int q[N], a[N], aa[N], K, pw[N], winer[32][100005], val[N], id[N], mx[N], le[N], ri[N], g[32][100005];
ll pre[N], now, ans[N];
pii rev[N];
int stk[N], hd, tl;
void build(int l, int r, int k, int t, int ma) {
	ri[t] = r;
    rev[t] = MP(k, r / pw[k]);
    val[t] = 0;
    if (l == r) return mx[l] = ma, id[l] = t, void();
    int mid = (l + r) >> 1;
    build(l, mid, k - 1, t << 1, ma ? ma : (!g[k][r / pw[k]]) * k);
    build(mid + 1, r, k - 1, t << 1 | 1, ma ? ma : g[k][r / pw[k]] * k);
}
void add(int u, int f) { if (a[u] >= mx[u]) now += f * u; }
int lst;
void update(int u, int U) {
    add(val[u] = lst = U, 1);
    while (u > 1) {
        int fat = u >> 1;
        int k = rev[fat].fi, c = g[k][rev[fat].se], lt = fat << 1;
        if (u == lt) {
            if (!c && a[U] >= rev[fat].fi)
                val[fat] = U, now -= pre[ri[fat]] - pre[ri[fat] - pw[k - 1]];
            else break;
        } else {
            if ((c && a[U] >= k) || (!c && a[val[lt]] < k)) {
                if (val[lt]) add(val[lt], -1);
                val[fat] = U;
            } else if (val[lt] && !val[fat] && c && a[U] < k) {
                add(U, -1);
                U = val[lt];
                val[fat] = U;
            } else break;
        }
        u = fat;
        lst = ri[u];
    }
}
void insert(int u) {
    now -= u;
    int x = id[u];
    update(x, u);
}
void work(int L, int R, int k) {
    now = pre[pw[k]] - pre[pw[k - 1]];
    build(1, (1 << k), k, 1, 0);
    int x = winer[k - 1][1];
    if (!g[k][1] && a[x] >= k) {
        rep(i, L, min(R, n))ans[i] = x;
        return;
    }
    add(x, 1);
    val[2] = x;
    rep(i, L, min(R, n)) {
        insert(i);
        rep(j, i, lst)ans[j] = now;
        i = lst;
    }
}
void solve() {
    ans[1] = 1;
    rep(i, 1, n)winer[0][i] = i;
    rep(i, 1, K)rep(j, 1, n / pw[i])if (winer[i - 1][j * 2 - 1] && winer[i - 1][j * 2]) {
        if (!g[i][j]) {
            if (a[winer[i - 1][j * 2 - 1]] >= i)
                winer[i][j] = winer[i - 1][j * 2 - 1];
            else
                winer[i][j] = winer[i - 1][j * 2];
        } else {
            if (a[winer[i - 1][j * 2]] >= i)
                winer[i][j] = winer[i - 1][j * 2];
            else
                winer[i][j] = winer[i - 1][j * 2 - 1];
        }
    }
    rep(i, 1, K)work((1 << (i - 1)) + 1, (1 << i), i);
    ll Ans = 0;
    rep(i, 1, m)Ans ^= ((ll)i * ans[q[i]]);
    printf("%lld\n", Ans);
}

bool Med;
signed main() {
    fprintf(stderr, "%.3lfMb\n", (&Mbe - &Med) / 1024. / 1024.);
    n = read(), m = read();
    pw[0] = 1;
    rep(i, 1, 31)pw[i] = pw[i - 1] * 2;
    rep(i, 1, n)aa[i] = read();
    rep(i, 1, m)q[i] = read();
    for (;; K++) if ((1 << K) >= n) break;
    rep(i, 1, K) {
    	char c = getchar();
		rep(j, 1, (1 << (K - i))) {
    		while (c < '0' || c > '1') c = getchar();
    		g[i][j] = c - '0';
    		c = getchar();
		}
	}
    lim = (1 << K);
    rep(i, 1, lim)pre[i] = pre[i - 1] + i;
    for (int T = read(); T--;) {
        int X[4];
        rep(i, 0, 3)X[i] = read();
        rep(i, 1, n)a[i] = aa[i] ^ X[i % 4];
        solve();
    }
    return 0;
}
```

---

## 作者：user100566 (赞：14)

## 前言
本题解思路由 [Lonely_Christmas 的题解](https://www.luogu.com.cn/article/bx2nqbrf) 发展而来，主要优化为避免了对战树形态变化导致的多次计算，代码为作者本人编写，已 [AC](https://www.luogu.com.cn/record/186200396)。

废话: 本来是自己想要照着这个思路自己写代码的但是一直 `WA`，然后试图改进参考代码，但是无从入手一直卡 $64, 128$ 的 `TLE`，最后推倒重来边写题解边写代码，调的居然还挺快。

## 题目分析

注意到一个重要事实：**如果一个选手在报名人数为某值时能成为冠军，那么人数更少时也一定能成为冠军**(当然这名选手要有"参赛资格")。  
形式化的，对于选手 $i$，设 $l$ 为 $i$ 参加比赛的最小人数，则选手 $i$ 可能获胜的 $c$ 值是一个**区间** $[l, r]$（可能是空区间）。

知道了所有选手的 $[l, r]$ 后，根据选手编号在 $[1, n]$ 内做区间加，做完后将 $c_i$ 带入索引即为询问答案。只需要先差分再前缀加即可，复杂度 $O(Tn)$。

接下来考虑求 $[l, r]$，显然，$l$ 是小于 $i$ 的最大 $2$ 的整数次幂 $+1$（注意 $i=1$ 时 $l=1$）。  
下面的代码预处理出了 $l$，不要低估求 $l$ 的时长，这一优化相比传统求 $l$ 方法直接把最大样例的运行时长缩短约 `100ms`。

**预处理**（这里指在具体测试数据之前完成的处理，复杂度不含 $T$）在本题降常甚至降复杂度中起关键作用，~~起码对于我的代码是这样~~。本题解的代码实现，基本上只要一个数据不需要用到 $a_i$ 就直接预处理出来。

---

接下来只需要求出 $r$。  
考虑选手 $i$ 在报名选手数为 $c(c\ge l)$ 时成为冠军的条件：
1. $i$ 作为擂主的所有对局中，$i$ 都获胜。
2. $i$ 不作为擂主的所有对局中，$i$ 的对手可以守擂失败。

处理条件 1：
> $c<i$ 时条件 1 一定成立。  
> 当 $c\ge i$ 时，记 $x_j $ 为 $i$ 第 $j$ 次守擂的对局**轮数**，若 $a_i\ge max(x)$，条件 1 还是一定成立。
>
> 否则，存在最小的 $x_{j'}>a_i$，那么游戏轮数就不能达到 $x_{j'}$ 轮，**最大轮数**为 $x_{j'}-1$，这限制了 $r$ 的一个上界为 $2^{x_{j'}-1}$。
>
> 编码时，可以预处理出所有 $i$ 的 $x$，然后对所有 $a_i \in [0, 16]$（更大的 $a_i$ 一定满足条件 1）求出**最大轮数**，时空复杂度 $O(n\log n)$，之后使用时直接索引即可。注意这一步预处理的复杂度**不含 $T$**，如果写在了 $T$ 里面，时间复杂度 $O(Tn\log n)$ 超时。

接下来只需要处理条件 2：

我们将对局建模为**完美二叉树**，树的高度为 $K+1$, $[1, K]$ 层的结点表示 $[1, K]$ 轮对局的获胜者(也可以理解为左子树和右子树的对局)，树的叶结点($K+1$层)则为所有选手。~~如果不太熟悉完全二叉树的编码方式可以看这题：[完全二叉树](https://www.luogu.com.cn/problem/U498222)~~。

条件 2 不成立时，不妨设选手最后走到了 $u$，没能晋级到 $\operatorname{parent}(u)=v$ 上，即卡在了 $u\rightarrow v$ 上，那么原因很显然：$u$ 不是对局 $v$ 的擂主且 $\operatorname{brother}(u)=w$ 一定能打赢比赛 $u$，我们不妨模拟选手一个一个一个报名的过程来解出条件 2 的限制。

设 $R_t$ 表示结点 $t$ 对应的对局轮数（叶子记为 $0$），$p_t$ 表示结点 $t$ 的获胜者的能力值（不确定时记为 $-1$），$s_t$ 表示 $t$ 打赢 $\operatorname{parent}(t)$ 比赛时，$c$ 的最大值（初始值为 $\infty$）。  
当一名选手报名时，更新对应叶子结点的 $p_t$ 为对应的 $a$，然后更新 $s_{\operatorname{brother}(t)}, p_{\operatorname{parent}(t)}$，如果 $p_{\operatorname{parent}(t)}$ 被更新，还要进一步向上递归。

这里有一个重要事实：**$p_t$ 只会被一次更新为非 $-1$ 值**，实际上 $p$ 的定义已经证明了这一点：只要 $p_t$ 没有唯一确定值，$p_t$ 就应该为 $-1$。因此由平摊分析可知上述模拟过程复杂度 $O(Tn)$。

注意这里有一个正确性结论：如果 $p_{\operatorname{brother}(t)}=-1$，那么 $t$ 一定可以在对局 $\operatorname{parent}(t)$ 中获胜，简要证明：如果 $p_{\operatorname{brother}(t)}=-1$，那么 $p_{\operatorname{brother}(t)}$ 一定可以取到 $R_{\operatorname{parent}(t)}-1$（可以直接枚举所有情况证明），此时 $\operatorname{brother}(t)$ 失败，$t$ 获胜。

做完每个结点的 $s$ 值后，还需要对于每个叶子结点求出其到根结点的 $s$ 值的最小值才能得出条件 2 的限制。

这一步的复杂度要带 $T$ ，自叶子向上到根复杂度为 $O(Tn\log n)$，不能接受。我们可以直接自顶向下更新 $\min$，复杂度 $O(Tn)$。

但是，从上面传下来的 $min$ 值是否会因为当前轮数没有涉及到上面结点的比赛而导致 WA 呢？  
这是不需要担心的。高层结点 $u$ 的 $s$ 值更新是 $\operatorname{brother}(u)=w$ 的 $p$ 值改变导致的，如果 $w$ 为编号更大的子树（右子树），传下来的 $\min$ 值偏大是没有关系的，如果 $w$ 为左子树，既然当前轮数同时涉及到了 $u, w$，那么 $u， w$ 之间的对局一定在当前轮数中被涉及到，还是正确的。

## 总结思路

1. 读取非测试数据，预处理条件 1，预处理 $R, l$。
2. 读取测试数据，更新 $a_i$。
3. 重置 $s, p$。
4. 模拟 $[1, n]$ 的报名过程，模拟过程中更新 $s, p$。
5. 向下更新 $s$。
6. 对于所有可能的选手，计算贡献区间 $[l, r]$，差分维护加。
7. 计算所有询问的答案，输出最终答案。
8. 回到 2.。

## 代码

虽然长达 4000 字节，但是对阅读者友好。  
下面的代码提示了一些可能出错的地方，请放心食用。  
用了快读优化，最大样例运行时长上界约 `700ms`。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std; 
inline int read(){
	char c = getchar();
	while(c<48||c>57) c=getchar();
	int x = 0;
	while(48<=c&&c<=57){
		x = (x<<3)+(x<<1)+c-48;
		c = getchar();
	}
	return x;
}
typedef long long int64;
// 深度 x+1 的前缀，dpref(x)+i 为深度 x 中排行 i 的结点编号 
#define dpref(x) ((1<<(x))-1)
// 深度 x+1 的结点数 
#define dsize(x) (1<<(x))
#define fa(x) ((x)>>1)
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
#define bro(x) ((x)^1)
// x 是左(0)/右(1)子树 
#define lr(x) ((x)&1)

int n, m, a[100001], c[100001];
int K, d[131072];
int T, X[4]; 

void init();
void solve();

int main(){
	n = read(); m = read();
	for(K=1; (1<<K)<n; ++K);
	for(int i=1; i<=n; ++i) a[i] = read();
	for(int i=1; i<=m; ++i){
		c[i] = read();
	}
	char buffer[65537];
	for(int R=1; R<=K; ++R){
		scanf("%s", buffer);
		for(int G=1; G<=dsize(K-R); ++G){
			d[dpref(K-R)+G] = buffer[G-1]=='1';
		}
	}
	
	init();
	
	T = read();
	while(T--){
		for(int i=0; i<4; ++i) X[i] = read();
		for(int i=1; i<=n; ++i) a[i] ^= X[i%4];
		solve();
		// 技巧: 异或运算的自逆性 (a^b)^b = a 
		for(int i=1; i<=n; ++i) a[i] ^= X[i%4];
	}
	return 0;
}


// maxround[i][j] ~ 选手 i 的实力为 j 时，满足条件 1 的最大轮数 
int maxround[100001][17];
// cround[i] ~ i 对应的比赛结点的轮数(r)
int cround[262144];
// 获胜的 c 上界(s) 
int ceiling[262144];
// 获胜者能力值(p) 
int power[262144];
// larray[i] 即 i 对应的 l 值，预处理降常 
int larray[131073];

// 模拟法求 maxround ，复杂度 O(nlogn) 
void make_maxround(){
	for(int i=1; i<=n; ++i){
		for(int j=0; j<K; ++j){
			maxround[i][j] = K;
		}
		int curr = dpref(K)+i;
		int competion = fa(curr);
		// 双指针，即使不用，写成 O(n(logn)^2) 也是可以接受的 
		int p = 0;
		for(int round=1; round<=K; ++round){
			if(d[competion]==lr(curr)){
				for(int j=p; j<round; ++j){
					maxround[i][j] = round-1;
				}
				p = round;
			}
			curr = competion;
			competion = fa(curr);
		}
	}
}
// 求 cround ，复杂度 O(n)
void make_cround(int id, int round){
	cround[id] = round;
	if(id<=dpref(K)){
		make_cround(ls(id), round-1);
		make_cround(rs(id), round-1);
	}
}
void make_larray(){
	// 注意，i=1 时 ， l=1 
	larray[1] = 1;
	for(int i=2; i<=(1<<K); ++i){
		int l = 1;
		if(i!=1){
			for(; l<i; l<<=1);
			l = (l>>1)+1;
		}
		larray[i] = l;
	}
}
void init(){
	make_maxround();
	make_cround(1, K);
	make_larray();
}

// 重置 ceiling(s), power(p)
void clear(int id){
	ceiling[id] = n;
	power[id] = -1;
	if(id<=dpref(K)){
		clear(ls(id));
		clear(rs(id));
	}
}

// 更新 power[id] 后计算影响 
void update(int id, int time){
	if(id==1) return;
	// 注意不要遗漏能确定 power(fa[id]) 的情况 
	if(d[fa(id)]==lr(id)){
		if(power[id]>=cround[fa(id)]){
			ceiling[bro(id)] = min(ceiling[bro(id)], time-1);
			power[fa(id)] = power[id];
			update(fa(id), time);
		}else if(power[bro(id)]!=-1){
			power[fa(id)] = power[bro(id)];
			update(fa(id), time);
		}
	}else if(power[bro(id)]!=-1 && power[bro(id)]<cround[fa(id)]){
		power[fa(id)] = power[id];
		update(fa(id), time);
	}
}
// 向下传递 ceiling 
void push_down(int id){
	if(id<=dpref(K)){
		ceiling[ls(id)] = min(ceiling[ls(id)], ceiling[id]);
		ceiling[rs(id)] = min(ceiling[rs(id)], ceiling[id]);
		push_down(ls(id));
		push_down(rs(id));
	}
}

int64 result[100002];
void solve(){
	clear(1);
	for(int i=1; i<=n; ++i){
		power[dpref(K)+i] = a[i];
		update(dpref(K)+i, i);
		// 注意 result 差分数组也要清空 
		result[i] = 0;
	}
	push_down(1);
	for(int i=1; i<=dsize(K); ++i){
		int l = larray[i];
		// 条件 2 
		int r = ceiling[dpref(K)+i];
		// 条件 1 ，注意前提是 a[i] 是确定的值，a[i]>=K 时不会限制 
		if(i<=n && r>=i && a[i]<K){
			// min(r) 是必要的，条件 1 限制的上界可能大于条件 2 限制的上界 
			r = min(r, 1<<maxround[i][a[i]]);
			// 注意，当且仅当 r>=i 时才能用条件 1 限制 r ，应该 min(i-1) 修正 
			r = max(r, i-1);
		}
		if(r>=l){
			result[l] += i;
			result[r+1] -= i;
		}
	}
	for(int i=1; i<=n; ++i){
		result[i] += result[i-1];
	}
	int64 ans = 0;
	for(int i=1; i<=m; ++i){
		ans ^= result[c[i]]*i;
	}
	printf("%lld\n", ans);
}

```

---

## 作者：vzcx_host (赞：13)

写个更好理解的做法。

考虑没有选手能直接晋级的情况。

对于当前状态下某一位补充选手 $x$，在他与另一位补充选手交战时我们可以确保 $x$ 能获胜，在他与某一位确定选手 $y$ 交战时由于 $y$ 不能直接晋级，若 $y$ 为擂主 $y$ 必败，若 $x$ 为擂主也可以确保 $x$ 能赢，所以在当前状态下所有补充选手都有可能成为冠军。

对于某一位确定选手 $x$，假设仅考虑他自己的能力值有机会成为冠军的情况下，若他与某一位补充选手交战，补充选手一定可以为他让路，若他与某一位确定选手 $y$ 交战，要么 $y$ 擂主必败，要么 $x$ 擂主必胜（因为 $x$ 自己的能力值可以成为冠军），所以 $x$ 可以成为冠军。

所以对于一个不能直接晋级的状态，所有的补充选手和能力值足够的确定选手都有可能成为冠军，而能力值不够的确定选手一定不能成为冠军，所以我们找到了所有可能成为冠军的选手。

考虑有选手能直接晋级的情况，我们让他直接晋级，处理完后一定回到一个不能直接晋级的情况，对后者计算答案即可。

```cpp
// 预处理时数组为 0-index
now=0;
for(int i=1;i<=n;i++){
    int j=1,x=i-1;
    while(j<=K){
        if(id[j]!=-1){
            x=fight(id[j],x,j,war[x][j]);
            now-=(id[j]+1)*ok[j];
            id[j]=-1;
        }
        else if(war[x][j]==0&&a[x]>=j)
            i+=i&-i;
        else break;
        j++;
    }
    id[j]=x;
    if(j<=K&&war[x][j]==1&&a[x]>=rnk[x][cl[i+1]])
        ok[j]=1;
    else
        ok[j]=0;
    now+=(id[j]+1)*ok[j];
    if(i==(i&-i))
        ans[min(n,i)]=x+1;
    else
        ans[min(n,i)]=now+sum(i+1,1<<cl[i]);
}
for(int i=n-1;i>0;i--)
    if(ans[i]==-1)
        ans[i]=ans[i+1];
```

---

## 作者：狂风之息 (赞：10)

---

题意大概是在一个二叉树状物上跑了一些东西。在这里我们把“作为擂主”的点连向其父亲的边称作“关键边”。

容易知道关键边的数量是 $O(n)$ 的。所以我们可以考虑暴力跳关键边。

但我们还需要观察出一些结论与性质：（在此称“原先的选手”为“A 类”，“补充的选手”为“B 类”）

- 性质 1：B 类作为擂主对 A 类不影响，即：必然有一种方案，与 B 类对战的 A 类必胜。同时 B 类擂主有必胜方案。

> 证明可能比较感性：因为 B 类的能力值是可以随意调整的，所以必然能控制它恰好在某一轮比赛输或者赢。

- 性质 2：只考虑若干个 A 类比赛时，获胜者唯一且确定。

> 因为比赛过程确定，选手能力值也确定，所以结果确定。

- 性质 3：在比赛总轮次不变时，如果我们按编号从小到大加入 A 类（即依次考虑只有前 $1,2,3，\dots$ 个人参赛的情况），那么，一个人如果在某时刻不能成为冠军，则之后也不能。

> 由前两个性质可以知道，被 A 类打败的 A 类在之后必然失败；被 B 类打败的 A 类只会是守擂输了，在之后也必然失败。

以上性质启发我们：按编号从小到大加入人，在过程中不断将不可能成为冠军的人删掉。

注意：维护的是删除，而非维护可能获胜的人。

具体的，我们考虑对于每个点通过跳关键边的方式来维护这个过程。因为如果一个点的父亲边不是关键边，那么它就不必继续往上跳，所以每个点被访问的次数是 $O(1)$ 的。

---

以下是跳关键边的过程：（此处定义“被 B 类影响”的点表示 B 类点或者其对应的擂主被 B 类影响的点）

由性质 2，我们知道不被 B 类影响的点有唯一胜者。

我们在每个不被 B 类影响的点存下当前点对应的唯一胜者，这样就可以知道当前点对应的胜者的能力值了。

给出一个结论：对于被 B 类影响的点，我们可以直接退出，等到没有 B 类对这个点有影响时再计算。

> 因为如果一个点被 B 类影响，则由性质 1 必然有一个可能的胜者是 B 类，从而得出它不影响其它比赛。

那么跳的时候有四种可能：

- 左儿子守擂成功：则右子树所有点均可删去。可以通过打标记实现。
- 左儿子守擂失败：则需要等右子树决出胜者。删去左儿子，给右儿子打上标记代表它“保送”了即可，等到处理出右儿子胜者再往上跳。
- 右儿子守擂成功：则左儿子对应的胜者必然失败，可以删去。由性质 2 可以知道这个时候我们已经处理出了左儿子对应的胜者。
- 右儿子守擂失败：则父亲对应的胜者是左儿子的胜者。删去右儿子，把左儿子的胜者作为其父亲的胜者，继续往上跳即可。

---

至此，我们将这题的主体部分做完了，剩下一部分是细节处理。

- 注意总轮次在加入选手的过程中是会变化的。在轮次变化的时候要新增一些可能获胜的选手，同时要从原本的根尝试跳一次关键边。
- 注意到如果能力值太小，则无论 B 类如何取值，部分的 A 类都无法获胜（守擂必败），因此在轮次变化的时候要从当前根开始往叶子跑一次预处理，处理出获胜的最小能力值要求。在新增 A 类的时候，如果能力值小于要求，则将它从答案中删去，为了便于处理可以用打标记的方式。这部分预处理可以通过分析得到复杂度为 $O(n)$。

以上。单组数据跳关键边部分 $O(n)$，预处理部分 $O(n)$，总时间复杂度 $O(Tn)$，理论可过，民间数据可过。

考场代码可读性极差，仅作参考吧

```cpp
#include<bits/stdc++.h>
//#define int long long 如果我似了全怪这句话
using namespace std;

inline int read(){
	int n,f=1; char c;
	while (!isdigit(c=getchar())) f=(c=='-'?-1:1); n=c-'0';
	while (isdigit(c=getchar())) n=n*10+c-'0';
	return n*f;
}
void write(long long x){
	if (x>=10) write(x/10);
	putchar(x%10+'0');
}
void write_(long long x,char c){
	if (x<0) putchar('-'), x=-x;
	write(x); putchar(c);
}

int n,m,zzp=0;
int a_[270005], zzpx[10]; 
int a[270005], b[270005];
char s[270005];

char tag[270005], tag2[270005];
bool flag[270005];
long long w[270005], mn[270005];

void Init(){
  //预处理，标记关键边
	memset(flag,0,sizeof(flag));
	for (int i=1;i<=n;i++) a[i]=(a_[i]^zzpx[i%4]);
	for (int i=1;i<=(1<<zzp);i++) w[(1<<zzp)+i-1]=i;
	for (int i=zzp-1;i>=0;i--){
		for (int j=1;j<=(1<<i);j++){
			int p=(1<<zzp)-(1<<i+1)+j, id=(1<<i)+j-1;
			if (s[p]=='0') tag2[id]=1, tag[id*2]=1, tag[id*2+1]=0;
			else tag2[id]=2, tag[id*2]=0, tag[id*2+1]=1;
			w[id]=w[id*2]+w[id*2+1];
		}
	}
}

int T1;
long long cur, ans[200005];

void check_mn_zzp(int u,int dep,int mx_){
  //预处理能力值限制
	if (dep==0){
		mn[u]=mx_;
		return ;
	}
	check_mn_zzp((u<<1),dep-1,tag2[u]==1?max(mx_,dep):mx_);
	check_mn_zzp((u<<1)+1,dep-1,tag2[u]==2?max(mx_,dep):mx_);
	return ;
}

void check_cl_zzp(int u,int dep){
  //第一类的标记
	if (dep<0) return;
	tag[u]=-1;
	check_cl_zzp((u<<1),dep-1);
	check_cl_zzp((u<<1)+1,dep-1);
	return ;
}

void check(int u,short dep){
  //暴力跳关键边
	if (dep==T1) return ;
	if (tag[u]==0) return ;
	if (tag[u]==1){
		if (!(u&1)){
			if (a[w[u]]<=dep){
				tag[u+1]=2;
				if (!flag[u]) cur-=w[u];
				return ;
			}else{
				if (!flag[u+1]) cur-=w[u+1]; 
				check_cl_zzp(u+1,dep);
				w[(u>>1)]=w[u]; flag[(u>>1)]=flag[u];
				check((u>>1),dep+1);
				return ;
			}
		}else{
			if (a[w[u]]<=dep){
				tag[u-1]=2;
				check(u-1,dep);
				return ;
			}else{
				if (!flag[u-1]) cur-=w[u-1]; 
				w[(u>>1)]=w[u]; flag[(u>>1)]=flag[u];
				check((u>>1),dep+1);
				return ;
			}
		}
	}
	if (tag[u]==2){
		w[(u>>1)]=w[u]; flag[(u>>1)]=flag[u];
		check((u>>1),dep+1);
		return ;
	}
}

void Solve(){
	T1=0;
	cur=1; ans[1]=1; //cur 是当前答案，ans 记录答案
	for (int i=2;i<=n;i++){
		if ((1<<T1)<i){
			T1++;
			check_mn_zzp(1<<zzp-T1,T1,0);
			cur+=w[(1<<zzp-T1+1)+1];
			check(1<<zzp-T1+1,T1-1);
		}
		if (mn[(1<<zzp)+i-1]>a[i]&&tag[(1<<zzp)+i-1]!=-1) cur-=i, flag[(1<<zzp)+i-1]=1;//flag 是能力值限制的标记
		check((1<<zzp)+i-1,0);
		ans[i]=cur;
	}
	long long Ans=0;
	for (int i=1;i<=m;i++)
		Ans^=(i*ans[b[i]]);
	write_(Ans,'\n');
}

signed main(){
	n=read(); m=read();
	while ((1<<zzp)<n) zzp++;
	for (int i=1;i<=n;i++) a_[i]=read();
	for (int i=1;i<=m;i++) b[i]=read();
	for (int i=zzp-1;i>=0;i--) scanf("%s",s+(1<<zzp)-(1<<i+1)+1);
	int t; t=read();
	while (t--){
		zzpx[0]=read(); zzpx[1]=read(); zzpx[2]=read(); zzpx[3]=read();
		Init(); Solve();
	}
}
```

---

## 作者：fry2007 (赞：4)

死了。以下思路与我考场的思路基本相同，但是考试的时候没调出来。

------

建出这个淘汰赛对应的二叉树，二叉树的叶子依次是 $1,2\cdots 2^K$。先假设对于每个询问都是对整个二叉树做一次这个比赛。考虑依次将 $1,2\cdots n$ 设为已知，在 $i$ 时间我们将 $i$ 设为已知。从下到上依次将这个二叉树的层编号为 $0,1\cdots K$ ，第 $i$ 层的擂主可以在他父亲代表的比赛中获胜当且仅当他的权值是大于他所在层的编号的。对于一个点，他连向这个点代表的比赛的擂主所对应的点的边称为是实边，反之是虚边。

首先考虑在一个时刻，一个以 $x$ 为根的子树可能的赢家的权值是什么。对于叶子来说，如果是已知那么他的权值就是已知值，如果是不已知那么他的权值就是任意正数。那么可以发现，以 $x$ 为根的子树可能的赢家权值可以表示为 $\{a\}\cup[b,2^{32})$ 或者是 $\{a\}$，其中 $b$ 是一个不超过 $x$ 所在层编号的数。这个可以通过归纳证明。

那么考虑一个叶子什么时候能够成为最终的赢家。那么考虑他到根节点路径上走过的所有实边的约束，如果设这些实边中权值最大的是 $v$，那么要么此时这个叶子不已知最终值，要么这个叶子的最终值大于等于 $v$。这个 $v$ 是可以通过简单预处理得到的。考虑他到根路径上所有虚边的约束，那么对于一条虚边，其实要求的就是与之配对的那条实边对应的那个擂主节点要可以失败。考虑如果一个节点 $x$ 是他父亲的擂主，那么他可以失败也就是说 $x$ 的子树做一次比赛后可能的赢家权值可以小于等于 $x$ 所在层数的编号。我们刚才说明了以 $x$ 为根的子树可能的赢家权值可以表示为 $\{a\}\cup[b,2^{32})$ 或者是 $\{a\}$，其中 $b$ 是一个不超过 $x$ 所在层编号的数。因此如果他不可能输，那么一定要求此时考虑以 $x$ 为根的子树可能的赢家权值只能是一个唯一值，且这个唯一值是小于等于 $x$ 所在层编号的。我们可以线性预处理出每个点所在子树在最终是否赢家变成唯一值，这个值是多少，以及在什么时间之后会变成唯一值。然后如果一个点 $x$ 符合上述的这个情况，如果 $x$ 在 $t$ 时间及以后变成唯一值，且符合上面的条件，那么对于所有在 $x$ 的父亲的另一个儿子的子树内的叶子，他们产生贡献的时间一定 $<t$，否则就有一条虚边走不通了。

这样我们可以线性计算出每个叶子产生贡献的时间前缀，然后用差分就可以计算出每个时间的答案了。对于原问题，我们对于 $1$ 号叶子的所有祖先的子树都做一遍上面的这个就可以了。复杂度 $O(Tn)$。

```.cpp
/*
  author: honglan0301<-TangShi
  Sexy_goodier _ xiaoqing
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <cctype>
#include <queue>
#include <map>
#include <unordered_map>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>
#include <random>
#include <set>
#include <bitset>
#include <assert.h>
using namespace std;
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define ull unsigned long long
#define mod 998244353
#define G 3
#define Gi 332748118
mt19937 rnd(time(0));
mt19937_64 rndl(time(0));
#define endl "\n" 

int n , m ;
int a[100005] , cp[100005] ;
int c[100005] ;
int nd ;
int idx ;
int ch[400005][2] , v[400005] , d[400005] ;
int k ;
int f[400005] , t[400005] , fa[400005] ;
int pv[400005] , gt[400005] ;
int kpv[400005] ;
int lt[400005] , rt[400005] ;
typedef long long ll ;
ll s[400005] , tmp[400005] ;
int id[400005] ;
int pt[400005] ; 
int nrt ;
void dfs2( int x )
{
	if ( x != nrt ) gt[x] = min( pt[x] , gt[fa[x]] ) , kpv[x] = max( pv[x] , kpv[fa[x]] ) ;
	else gt[x] = ( 1 << k ) + 1 , kpv[x] = 0 ;
//	printf("gt[%d] %d\n" , x , gt[x]) ;
	if ( ch[x][0] ) dfs2( ch[x][0] ) ;
	if ( ch[x][1] ) dfs2( ch[x][1] ) ;
}
int bid[35] ;
int main()
{
//    freopen("arena.in" , "r" , stdin) ;
//    freopen("arena.out" , "w" , stdout) ;
    scanf("%d%d" , &n , &m) ;
    for ( int i = 1 ; i <= n ; i++ ) scanf("%d" , cp + i) ;
    for ( int i = 1 ; i <= m ; i++ ) scanf("%d" , c + i) ;
    for ( k = 0 ; ; k++ )
        if ( ( 1 << k ) >= n ) break ;
    nd = ( 1 << k ) ;
    int lst = 0 ;
    idx = ( 1 << k ) ;
    for ( int i = 1 ; i <= k ; i++ )
    {
    	bid[i - 1] = lst + 1 ;
        for ( int j = lst + 1 ; j <= lst + ( 1 << ( k - i + 1 ) ) ; j += 2 )
        {
            idx++ ;
            ch[idx][0] = j , ch[idx][1] = j + 1 ;
            fa[j] = fa[j + 1] = idx ;
            v[idx] = i ;
            scanf("%1d" , &d[idx]) ;
            pv[ch[idx][d[idx]]] = i ;
        }
        lst += ( 1 << ( k - i + 1 ) ) ;
    }
    lt[1] = 1 ;
    for ( int i = 1 ; i <= k ; i++ )
        for ( int j = ( 1 << ( i - 1 ) ) + 1 ; j <= ( 1 << i ) ; j++ ) lt[j] = 1 + ( 1 << ( i - 1 ) ) ;
    int T ;
    scanf("%d" , &T) ;
    while ( T -- )
    {
        int rd[5] ;
        for ( int i = 0 ; i < 4 ; i++ ) scanf("%d" , rd + i) ;
        for ( int i = 1 ; i <= n ; i++ ) a[i] = ( cp[i] ^ rd[i % 4] ) , id[i] = i ;
        for ( int i = ( 1 << k ) + 1 ; i <= idx ; i++ )
        {
            if ( a[id[ch[i][d[i]]]] >= v[i] ) id[i] = id[ch[i][d[i]]] ;
            else id[i] = id[ch[i][1 - d[i]]] ;
        };
		nrt = 1 ; // 当前的根节点 
        for ( int i = 1 ; i <= idx ; i++ )f[i] = t[i] = 0 ;
        for ( int i = 1 ; i <= n ; i++ ) a[i] = ( cp[i] ^ rd[i % 4] ) , f[i] = a[i] , t[i] = i ;
        for ( int i = ( 1 << k ) + 1 ; i <= idx ; i++ )
        {
            if ( d[i] == 0 && t[ch[i][0]] )
            {
                if ( f[ch[i][0]] >= v[i] ) f[i] = f[ch[i][0]] , t[i] = t[ch[i][0]] ;
                else if ( t[ch[i][1]] ) f[i] = f[ch[i][1]] , t[i] = max( t[ch[i][0]] , t[ch[i][1]] ) ;
            }
            if ( d[i] == 1 && t[ch[i][1]] )
            {
                if ( f[ch[i][1]] >= v[i] ) f[i] = f[ch[i][1]] , t[i] = t[ch[i][1]] ;
                else if ( t[ch[i][0]] ) f[i] = f[ch[i][0]] , t[i] = max( t[ch[i][0]] , t[ch[i][1]] ) ; 
            }
        }
        for ( int i = 1 ; i <= idx ; i++ ) pt[i] = ( 1 << k ) + 1 ;
        for ( int i = idx ; i > ( 1 << k ) ; i-- )
        	if ( f[ch[i][d[i]]] >= v[i] ) 
        	{
        		pt[ch[i][1 - d[i]]] = t[ch[i][d[i]]] ;
			}
//        for ( int i = 1 ; i <= idx - 1 ; i++ ) 
//            if ( i == ch[fa[i]][d[fa[i]]] && f[i] >= v[fa[i]] )
//            {
//                pt[ch[fa[i]][1 - d[fa[i]]]] = t[i] ;
//            }
		for ( int kk = 0 ; kk <= k ; kk++ )
		{
			int klt , krt = ( 1 << kk ) ;
			if ( kk == 0 ) klt = 1 ;
			else klt = ( 1 << ( kk - 1 ) ) + 1 ;
//			init( nrt ) ; 
			for ( int i = 0 ; i <= ( 1 << kk ) ; i++ ) s[i] = 0 ;
//			dfs( nrt ) ;
//			dfs2( nrt ) ;
			gt[nrt] = ( 1 << k ) + 1 , kpv[nrt] = 0 ;
			for ( int cc = kk - 1 ; cc >= 0 ; cc-- )
			{
				for ( int i = bid[cc] ; i <= bid[cc] + ( 1 << ( kk - cc ) ) - 1 ; i++ ) 
				{
					gt[i] = min( pt[i] , gt[fa[i]] ) ;
					kpv[i] = max( pv[i] , kpv[fa[i]] ) ;
				}
			}
			for ( int i = 1 ; i <= ( 1 << kk ) ; i++ )
			{
				int nt = gt[i] - 1 ;
				if ( i <= n && a[i] < kpv[i] ) nt = min( nt , i - 1 ) ;
				s[1] += i ;
				if ( nt + 1 <= ( 1 << k ) )
					s[nt + 1] -= i ;
			}
			for ( int i = 1 ; i <= ( 1 << kk ) ; i++ ) s[i] += s[i - 1] ;
			for ( int i = klt ; i <= krt ; i++ ) 
			{
				tmp[i] = s[i] ;
			}
			nrt = fa[nrt] ;
		}
		
        ll res = 0 ;
        for ( int i = 1 ; i <= m ; i++) 
        {
            res ^= ( tmp[c[i]] * i ) ;
        }
        printf("%lld\n" , res) ;
    }
    return 0 ;
}
```

---

## 作者：4041nofoundGeoge (赞：2)

讲一讲这道题的思路

### 题外话

今年 CCF 肯定是放大招了！普及组考了蓝题，提高组考了黑题！

## 思路

对于特殊性质 A，完全二叉树，每个节点的胜者是确定且唯一的，我们可以直接计算所有节点的胜者并输出根节点的答案。

我们考虑非完全二叉树的做法，在某个询问的时刻，空缺的位置会构成一条从根到叶子节点的链我们可以通过在未确定的位置填上任意的能力使得这条链的人有机会成为胜者。

每个点我们维护能够获胜到这个节点的所有可能能力值:

假设左儿子可能能力值为 $ls_i$，右儿子能力值为 $rs_i$，左儿子是擂主。如果左儿子获胜，则可以晋级到当前节点，因此可以继承 $ls_i$ 中所有 $≥ R$ 的能力。如果右儿子获胜，也就是左儿子存在至少一个 $<R$ 的能力值，右儿子的能力可以全部继承。
至此我们可以 $\cal O(\log n)$ 的维护一次节点能力值。

考虑如何判断某个人是否可以成为最后赢家，那么每次播台战都需要胜利，可以利用我们上面维护的信息来快速判定是否可以胜利。

可以进一步优化，我们可以用二进制来压缩能力值（最多有 $k$ 种不同的能力值），并且用二进制操作来进行快速合并操作。

总时间复杂度 $O(Tn\log n)$。

---


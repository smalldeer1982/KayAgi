# 【MX-X13-T7】「KDOI-12」No one can be anything without comparison.

## 题目描述

**请注意本题对 $\bm{n,k}$ 的特殊限制。**

$n$ 名选手参加了 $k$ 场 Tetris Tournament。每一场 Tetris Tournament 包含 $n-1$ 轮，每轮会选出两个目前还未淘汰的选手 $x,y$ 并让他们参加一场比赛，输的人淘汰。最后会有唯一胜者。你现在得知第 $j$ 个人在第 $i$ 场 Tetris Tournament 中被 $a_{i,j}$ 淘汰了。$j$ 是第 $i$ 场 Tetris Tournament 的胜者当且仅当 $a_{i,j}=0$。

选手们喜欢比较。他们都希望自己在某种意义上能够胜过别人，或至少跟别人水平差不多。

定义第 $i$ 场 Tetris Tournament 中 $x$ 严格吊打 $y$ 当且仅当存在 $x=p_1,p_2,\dots,p_m=y$（$m\ge 2$，也就是说 $x\neq y$），使得对于任意 $1\leq j<m$，$a_{i,p_{j+1}}=p_j$。

定义一个有序的选手 $k$ 元组 $(i_1,i_2,\dots,i_k)$ 是水平相似的当且仅当对于 $1\leq j<k$，$i_j$ 在第 $j$ 场比赛中严格吊打 $i_{j+1}$ 且 $i_k$ 在第 $k$ 场比赛中严格吊打 $i_1$。

求水平相似的 $k$ 元组数量，对 $998244353$ 取模。

## 说明/提示

**【样例解释 \#1】**

符合要求的三元组 $(i_1,i_2,i_3)$ 有：$(1,2,3)$，$(2,3,1)$。

**【数据范围】**

**本题使用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $k=$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $7$ | $100$ | $3$ | 无 |
| $2$ | $8$ | $500$ | $3$ | 无 |
| $3$ | $13$ | $3\times10^3$ | $3$ | 无 |
| $4$ | $14$ | $2.5\times10^5$ | $3$ | A |
| $5$ | $15$ | $10^5$ | $3$ | B |
| $6$ | $7$ | $10^5$ | $3$ | 无 |
| $7$ | $14$ | $2.5\times10^5$ | $3$ | 无 |
| $8$ | $7$ | $5\times10^4$ | $4$ | 无 |
| $9$ | $6$ | $7.5\times10^4$ | $4$ | 无 |
| $10$ | $9$ | $4\times10^4$ | $5$ | 无 |

* 特殊性质 A：对于 $1\leq i\leq n$，$a_{1,i}=a_{2,i}$；
* 特殊性质 B：对于 $1\leq i\leq k$，不存在 $1\leq j_1<j_2\leq n$ 使得 $a_{i,j_1}=a_{i,j_2}$。

对于所有数据：$1\leq n\leq2.5\times10^5$，$\bm{3\leq k\leq 5}$，保证 $a$ 数组符合题意，且：

* $k=3$ 时，$n\leq2.5\times10^5$；
* $k=4$ 时：$n\leq7.5\times10^4$；
* $k=5$ 时：$n\leq4\times10^4$。

## 样例 #1

### 输入

```
3 3
0 1 2
3 0 2
3 1 0```

### 输出

```
2```

## 样例 #2

### 输入

```
6 5
0 1 1 2 3 4
3 3 0 6 6 1
2 4 1 0 1 1
3 0 2 6 6 2
5 3 6 1 0 4```

### 输出

```
18```

# 题解

## 作者：xuanxuan001 (赞：8)

怎么没人补（感觉也不是很难写。

先考虑 $k = 3$ 的怎么做，然后再考虑怎么拓展，其实~~如果你是官方做法~~从 $k = 3$ 拓展到正解是比较容易的。

题意大概是给了你 $k$ 棵树，然后找 $k$ 个点成环，相邻点在对应的树上呈祖孙关系，所以考虑先枚举 $i_k$，那么此时考虑 $i_1$，那么显然它在第 $k$ 棵树上需要时 $i_k$ 的子树，这个可以求出 $k$ 的 dfs 序后改变为限制在一个区间内，下面考虑另一个方向的限制。

那么这个过程其实是：依次遍历 $i = k-1 \rightarrow 1$，初始化一个 $u = i_k$，每次将 $u$ 在第 $i$ 棵树上往上跳到 $u$ 的一个祖先（不包含自己）。每次的决策不同就对应着一种可能的 $i_1$，一个 $O(nk)$ 的 $k$ 次树上前缀和就可以容易对单个 $i_k$ 求出答案，但显然不优。

写一下我赛时 $k=3$ 的做法，按第二棵树的 dfs 序考虑所有的 $i_k$，此时 dfs 序只需要每次进入节点 $u$ 时插入 $i_2 = u$ 的情况并在离开时删除即可，那么插入一个点 $u$ 的过程实际上是继续枚举 $i_1$ 为第一棵树上 $u$ 的所有祖先，对每个 $i_1$ 在第三棵树上的 dfs 序对应位置修改，这个用树状数组即可，现在难点是如何快速解决链修改的问题。

考虑树链剖分，先将这个路径转换为 $O(\log n)$ 个链，然后考虑给每条重链分块，如果当前节点在某个块的块底，那么给这个块记录一个标记并直接跳到块首，否则就正常修改即可。查询时同时查询散的贡献并遍历每个块求出整块的贡献和，每个块到每个前缀的贡献系数可以预处理。设块长为 $B$，那么复杂度为 $O(nB \log^2 n + \dfrac {n^2}B)$，可以平衡到 $O(n \sqrt n \log n)$，如果用分块代替树状数组平衡复杂度应该也可以做到 $O(n \sqrt{n \log n})$，但实际上我赛时直接取的 $B = \sqrt n$ 直接过了。

但不难发现这个做法无法拓展 $k$，我赛时以为后面是一些神秘的 meet-in-middle，但发现不是。

下面说正解，给第二棵树做树分块，设块长为 $B$，那么会标记 $O(\dfrac nB)$ 个关键点，那么考虑在第二棵树上 $i_2$ 到 $i_3$ 的路径（不包括 $i_3$）是否经过某个关键点。

如果不经过，那么这样的 $(i_2,i_3)$ 只有 $O(nB)$ 个，直接存下来然后在第一棵树上 dfs 同时维护到根的链的信息，到点 $u$ 时将 $a_{1,i_2} = u$ 的数对拿出来更新答案，维护信息的部分是单点修改区间求和，可以用分块平衡实现 $O(n\sqrt n + nB)$。

如果经过，那么可以将 $i_3$ 直接记录在它上面第一个关键点上（不难发现 $i_3$ 一定会跳到这个点上），然后直接从关键点开始继续最前面说的暴力过程，由于前面说过可以 $O(nk)$ 对单点求答案，这里直接这么做就行了，可以先预处理出每个关键点到最后第一棵树上的每个点的方案数，由于查询时区间，所以直接按第三棵树的 dfs 序排好并求前缀和，就能直接 $O(1)$ 查询了，复杂度 $O(\dfrac {n^2k}B)$。

如果你真的理解了这个做法的核心思想，那么其实就不难发现怎么拓展了。它的关键就在于你可以花费并不太多的时间直接求出某个点的答案，因此直接分块即可。那么对于 $k > 3$ 的情况也是一样，可以对第 $2 \rightarrow k-1$ 棵树都树分块并找到关键点，并预处理对应的数组，我看官方题解的时候就总以为这里是用某种方式从前一棵树递推得来的，所以想了很久才明白，这里其实就是从头开始直接 dp 了一遍，和别的块的信息根本没关系。

考虑从每个 $i_k$ 出发，直接 dfs，枚举每个下一个 $i_{k-1}$ 并递归，但此时我们只需要找到它上面第一个关键点，找到后再往后的就可以直接用这个关键点的答案更新了，因此每个点的决策不超过 $B$，所以这个 dfs 的总复杂度不超过 $O(nB^{k-2})$，注意 $i_k$ 是直接枚举的，而如果到了需要确定 $i_1$ 的时候还没有碰到关键点我们就把 $(i_2,i_k)$ 记录下来并类似前面所述的做法处理，因此这里只会 dfs $k-2$ 层。

注意到真的把这些数对存下来也比较费劲，其实不需要，可以在需要找到 $i_2 = u$ 的所有数对的时候直接再正着 dfs 一遍，实测这样比给每个点开 vector 存下来强。官方题解还说了个什么莫队？不懂。

那么前面预处理整块的复杂度是 $O(\dfrac {n^2k^2}B)$，散的部分是 $O(nB^{k-2})$。平衡复杂度 $B = \sqrt[k-1]{nk^2}$，但实际上的块长都偏小。我最后选择的是 $400,80,30$。$500,100,40$ 也过了但比较卡时限，没前面那个快，代码没啥必要放了，也比较丑。

---

## 作者：王熙文 (赞：1)

这个 12s, 2GB 看起来就让人很有做的欲望。NOI 前几天谁还做正经题啊。

不需要树分块，好像比正解简单一点？而且只需要保留一棵树的形态，剩下的的限制只要是区间包含单点就可以做。但是复杂度和正解相同，可能本质相同吧。（upd：确实本质相同，我的做法是将祖先关系描述成一个点子树的一段区间，另一个做法是将祖先关系描述成一个点到根的链，都是转化成了某种线性的结构）

本来以为是巨大数据结构的，写完发现超级好写，失策了。

## 思路

先转化一下祖先的关系。放在 dfs 序上，设在第 $i$ 棵树上每个点的新编号是 $id_{i,j}$，每个点包含的编号区间是 $[l_{i,j},r_{i,j}]$（有 $id_{i,j}+1=l_{i,j}$）。那么一个有序对 $a_1,a_2,\cdots,a_k$ 合法等价于 $\forall 1 \le i \le k,id_{i,a_{i \bmod k+1}} \in [l_{i,a_i},r_{i,a_i}]$。

首先考虑 $\mathcal O(n^2)$ 左右的复杂度怎么做。这是一个环的限制，所以无论如何是需要枚举一个点的。枚举 $a_1$。设 $dp_{i,j}$ 表示走到第 $i$ 棵树的第 $j$ 个点的方案数。对于一个状态可以转移到一个区间，所以差分并还原即可。注意，转移后的下标是新编号，需要转化为原编号。

统计答案时，最后的限制是 $a_k$ 在第 $k$ 棵树上是 $a_1$ 的祖先。所以考虑解决这个限制。这里有两种思路，一种是从上到下 dfs，在 $a_k$ 处修改，$a_1$ 处查询，再撤销 $a_k$ 的贡献。另一种是 dsu on tree，$a_1$ 处修改，$a_k$ 处查询。先保留这两种思路，之后再看哪种更合适。

考虑 $k=3$ 怎么做。对于第一种思路，在 $a_1$ 处查询时 $a_2$ 是一段区间，贡献是 $a_2$ 对应的区间包含了多少个修改的 $a_3$。考虑分块，那么散块就是单点修改区间查询（可以使用 $\mathcal O(\sqrt{n})$ - $\mathcal O(1)$ 的分块平衡）。整块有很多区间，但值域只有 $n$，所以可以压缩信息。具体地，预处理，使用之前提到的做法求出每一个块对于每个 $a_3$ 的答案。对于每个 $a_3$ 的修改更新每个块的答案即可。对于第二种思路，思路其实是一样的。将 $a_1$ 的贡献分为整块和散块两部分，对于整块打上加一的 tag，散块区间加。查询 $a_3$ 时遍历每个块就可以算出整块的贡献，对于散块的贡献单点查询即可。

可以发现这两种思路本质是一样的。都是将贡献拆成整块和散块两部分，对于 $a_1$ 和 $a_3$ 在某一个整块上都有特定的贡献（$a_1$ 是 $1$，$a_3$ 是预处理的值），答案是将两者相乘。而散块就是将单点和区间的修改和查询的对应关系交换了，它们都是好做的。而第二种思路多一个 $\log$，所以接下来只考虑第一种思路。

可以发现整块的贡献可以扩展到 $k>3$，因为值域是 $n$，所以随时都在压缩信息，信息量不会随着树的个数而指数增加。而散块终究是不好做的。于是考虑将块长开很小，对于散块暴力枚举并递归到下一棵树的子问题。最开始我以为这样做的复杂度是 $\mathcal O(B^3)$ 的，于是可以设 $B=n^{\frac{1}{4}}$，就做完了。写完才发现递归到下一棵树的时候还需要枚举整块，在最后一棵树的时候会出现 $B^2\cdot \dfrac{n}{B}$，非常不牛。

能改进吗？考虑将第二棵树的块长开大一点，第三棵树的块长再开大一点，这样没准能平衡。设 $B_1,B_2,B_3$ 分别为三棵树的块长，那么运算次数是 $\dfrac{n}{B_1}+B_1\dfrac{n}{B_2}+B_1B_2\dfrac{n}{B_3}+B_1B_2B_3$。取 $\log$，从后到前依次取等，可以得到 $B_1=n^{\frac{1}{8}},B_2=n^{\frac{1}{4}},B_3=n^{\frac{1}{2}}$。这样就得到了 $\mathcal O(n^{\frac{15}{8}})$ 的优秀复杂度（而且还没算预处理的 $k^2$）。

我还真写了这个思路，甚至只跑了 40 多秒。其实确实合理，$\mathcal O(n^2)$ 估计就这么快，这个思路主要是为了压缩空间。

当我准备卡常的时候我突然看到了一段区间求和的代码。在递归的过程中完全不需要遍历整块！只需要在修改的时候动态维护前缀和即可。那为什么最初没发现呢？因为 $k=3$ 的时候块的个数与块长都是 $\sqrt{n}$，就没有区分它们，但是现在块的个数对复杂度产生影响了。所以要跳出思维定式。但是一步一步推过来想发现这一点对于我来说可能还挺难的。

于是这样的复杂度就是 $\mathcal O(\dfrac{n^2}{B}k^2+nB^3)$ 了。取 $B=n^{\frac{1}{4}}k^{\frac{1}{2}}$ 可以得到 $\mathcal O(n^{\frac{7}{4}}k^{\frac{3}{2}})$ 的复杂度。我取的是 $1000,80,30$，最后卡着时限过的。想要更快可能可以将整块的询问离线，这样可以优化空间访问。

[提交记录](https://www.luogu.com.cn/record/223365626)

---


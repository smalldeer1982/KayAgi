# 孤舟蓑笠翁

## 题目背景

![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)

出于保护鱼类的目的，最优秀的渔翁才能在洞庭湖继续捕鱼。经过层层选拔，洞庭湖上只剩下孤舟蓑笠翁。以前跟其他渔翁一起钓鱼、打牌、切磋武艺，而如今只剩孤单一人，蓑笠翁不禁黯然神伤。选拔被淘汰，如今他们都去哪里了呢？大概回家种田养猪了吧。

## 题目描述

![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)

蓑笠翁现在闲暇时在练的武术名为"左右互搏术"，相传是周伯通首创的武功。

练功时，蓑笠翁的双手在某竖直平面内运动，以该平面上某点作为坐标原点，向右为 $x$ 轴正方向，向上为 $y$ 轴正方向建立直角坐标系。那么该平面内的一个点就可以用坐标 $(x, y)$ 来表示。

该武功有 $n$ 个可停顿点，分别为 $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \ldots, p_n = (x_n, y_n)$。我们可以将蓑笠翁练功的过程分成一秒一秒来看，第 $i$ 秒时，双手都处于可停顿点上。而第 $i$ 秒末双手进行移动，移动到其它可停顿点上。（当然也可以不移动）

左右互搏术中，有 $k$ 种绝招。第 $i$ 种绝招为：左手处于 $v_i$ 号可停顿点，右手处于 $u_i$ 号可停顿点，则可以发动绝招。

练武功也有禁忌，在两只手停顿的时候，如果两只手的曼哈顿距离小于 $d_{min}$，则容易走火入魔。如果两只手的曼哈顿距离大于 $d_{max}$，则蓑笠翁的胳膊显然快被扯断了。所以假设左手在 $l$ 号停顿点，右手在 $r$ 号停顿点，则需要满足 $d_{min} \leq |x_l - x_r| + |y_l - y_r| \leq d_{max}$。

从一个停顿点移动到另一个停顿点也有讲究，而且对于左右手还不一样。有 $m$ 个移动条件，每个移动条件形如：左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，或右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。对于某一秒末，蓑笠翁的手没那么快，所以每只手至多只能进行移动一次。上面未提到的移动方式均为非法。

蓑笠翁希望能发动连击。即先发动第 $i$ 种绝招，经过 $t$ 秒的移动后，又发动了第 $j$ 种绝招，且 $i \neq j$。

给出 $p_1, \ldots , p_n$，$v_1, \ldots v_k$，$u_1, \ldots , u_k$，$d_{min}$，$d_{max}$，和 $m$ 个移动条件，现在蓑笠翁想知道，发动第 $i$ 种绝招之后，最少经过多少秒的移动后能发动某个编号不为 $i$ 的绝招，即发动连击的最短耗时。请对于每个 $1 \leq i \leq k$ 输出答案。

## 说明/提示

**【样例解释】**

![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)

**对于样例一的解释**　对于绝招 $1$，可以先同时将左手移动到 $2$ 号可停顿点，右手移动到 $3$ 号可停顿点，这样耗时 $1 \textrm{ s}$，再将左手移动到 $1$ 号可停顿点，右手不动，这样可以发动绝招 $2$，共用时 $2 \textrm{ s}$。对于绝招 $2$ 可以把刚才的过程反过来，发动绝招 $1$。对于绝招 $3$，无论如何右手都无法移动，不能发动任何绝招，故输出 $-1$。

**对于样例二的解释**　不解释。

**【数据范围】**

![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)

其中 $20 \%$ 的数据，$n \leq 50$，$m \leq 100$，$k \leq 100$。  
另有 $30 \%$ 的数据，$n \leq 500$，$m \leq 2000$，$k \leq 10000$，$d_{min} = 0$，$d_{max} = 10000$。  
对于 $100 \%$ 的数据，$n \leq 1000$，$m \leq 4000$，$1 \leq x_i, y_i \leq 1000$，$0 \leq d_{min} \leq d_{max} \leq {10}^9$。

## 样例 #1

### 输入

```
5 5
1 6
3 2
9 2
7 3
7 8
4 9
3
5 4
1 3
1 2
1 2 0
2 5 0
1 5 1
1 3 1
3 4 1```

### 输出

```
2
2
-1```

## 样例 #2

### 输入

```
6 14
2 7
3 10
8 9
3 4
6 5
3 10
6 7
4
6 2
1 2
5 2
3 6
5 2 0
4 5 1
2 3 1
5 4 0
1 2 1
1 4 0
6 4 1
5 4 1
4 6 0
1 5 0
4 1 0
6 4 0
5 5 0
1 2 0```

### 输出

```
2
1
1
-1```

# 题解

## 作者：chaojidouding (赞：20)

## 《江雪》系列第三题
这道题可以bfs做

你建立一个新图，先把每一对可停顿点(Pa,Pb)当做新图一个点，然后把dis(Pa,Pb)>Dmax和dis(Pa,Pb)<Dmin的点判掉，再把可抵达的点连边，这样题目就转化成了一个新问题：给你一个无向图，边权是1，给你一些关键点，让你求距离每一个关键点最短的关键点。

然后我们把所有的关键点push进队列里bfs，可以求出离每个点最近的关键点距离dis，然后我们可以枚举每一条边,设他两端点是x,y然后我们就分别更新距离x，y最近的关键点，把这个点的答案和dis[x]+dis[y]取最小值就可以了。

代码：

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int q[1010101],viss[1010101],dis[1010101],ans[1010101],x[10101],y[10101],a[10101],b[10101],type[10101],vis[1010101],u[1010101],v[1010101];
vector<int>s[1010101];
int n,k;
void jiantu(int x,int y)
{
	if(!vis[x]||!vis[y])
		return;
	s[x].push_back(y);
	s[y].push_back(x);
}
int get_dis(int a,int b)
{
	return abs(x[a]-x[b])+abs(y[a]-y[b]);
}
int calc(int x,int y)
{
	return (x-1)*n+y;
}
void bfs()
{
	int t,i,c,y,h,x;
	h=0,t=0;
	for(i=1;i<=k;i++)
		q[t++]=calc(u[i],v[i]),viss[calc(u[i],v[i])]=i,dis[calc(u[i],v[i])]=0;
	while(h<t)
	{
		x=q[h++];
		c=s[x].size();
		for(i=0;i<c;i++)
		{
			y=s[x][i];
			if(viss[y])
				continue;
			dis[y]=dis[x]+1;
			viss[y]=viss[x];
			q[t++]=y;
		}
	}
}
int main()
{
	int m,mx,mn,di,i,j,kk,xx,yy;
	scanf("%d%d",&n,&m);
	scanf("%d%d",&mn,&mx);
	for(i=1;i<=n;i++)
		scanf("%d%d",&x[i],&y[i]);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			di=get_dis(i,j);
			if(di<mn||di>mx)
				continue;
			vis[calc(i,j)]=1;
		}
	}
	scanf("%d",&k);
	for(i=1;i<=k;i++)
		scanf("%d%d",&u[i],&v[i]),ans[i]=1000000007;
	for(i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a[i],&b[i],&type[i]);
		if(type[i]==0)
		{
			for(j=1;j<=n;j++)
				jiantu(calc(a[i],j),calc(b[i],j));
		}
		else
		{
			for(j=1;j<=n;j++)
				jiantu(calc(j,a[i]),calc(j,b[i]));
		}
	}
	for(i=1;i<=m;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(type[i]==0&&type[j]==1)
			{
				jiantu(calc(a[i],a[j]),calc(b[i],b[j]));
				jiantu(calc(a[i],b[j]),calc(b[i],a[j]));
			}
		}
	}
	
	bfs();
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
		{
			xx=calc(i,j);
			for(kk=0;kk<s[xx].size();kk++)
			{
				yy=s[xx][kk];
				if(viss[xx]!=viss[yy])
				{
					ans[viss[xx]]=min(ans[viss[xx]],dis[xx]+dis[yy]+1);
					ans[viss[yy]]=min(ans[viss[yy]],dis[xx]+dis[yy]+1);
				}
			}
		}
	for(i=1;i<=k;i++)
	{
		if(ans[i]==1000000007)
			ans[i]=-1;
		printf("%d\n",ans[i]);
	}
	return 0;
}

```

---

## 作者：Jeslan (赞：4)

## Solution to [P4730 孤舟蓑笠翁](https://www.luogu.com.cn/problem/P4730)

首先考虑建新图，图上的每一个点代表一种左手和右手的位置组合，如果左手的位置是 $x$，右手的位置是 $y$，新图上的点的编号可以取 $xn+y$（均从 $0$ 开始编号）。$u$ 向 $v$ 的连边即从 $u$ 能一步到达 $v$。

根据题意，单独地从每一个绝招（对应的新图上的点）开始 BFS，求到所有其它绝招的最短路，再取最小值，就能得到答案。

出边可以在 BFS 时枚举，具体地，枚举左手可以移动到的位置和右手可以移动到的位置，判断是否合法。可以通过在原图中自己向自己连边，免去对手不动的情况的讨论。

但是这样复杂度太大，考虑一起 BFS。注意到这是个无向图，对每个节点记录它最早是被哪个绝招扩展到的，及其距离（可以证明这一定是最短路）。如果两个不同的绝招 $u$ 和 $v$ 遍历到同一个节点，那么 $u$ 和 $v$ 的答案就确定了。具体地，在 BFS 枚举出边时判断边连接的两个点是否是被不同绝招扩展到的，是则更新答案。

如果题目给出的图是有向图，可以在新图及其反图上分别跑一遍 BFS，对每个节点求出任一绝招到节点、节点到任一绝招的最短路及此绝招，然后枚举每一条新图上的边 $(u, v)$，用任一绝招到到 $u$ 的最短路和 $v$ 到任一绝招的最短路更新答案，不要忘记判断是否是不同的绝招。

上述做法忘了是从哪儿看来的，可能表述有误，只是想说这类题有多种做法。笔者用的是下述做法。

尝试记录每个绝招到达一个节点的最短路，注意到有用的只可能是最小的两个最短路（能够保证对于任意有解的绝招，一定会被至少一个其它绝招扩展到），所以对每个点只需要记录到它的距离最小的两个不同的绝招及其距离即可。

---

## 作者：DengDuck (赞：1)

这题也许有一些基于几何的做法，但是我不会几何，所以我想了想图论。

考虑把左右手的所有位置组合表示成点，对于合法的移动当成边。

我想到了转换为图之后就是对关键点求最近关键点，但是我想的是随机化之类，没什么前途。

注意到 $i\in[1,k]$，$k$ 可能很大，所以我们肯定是一口气全部求出来的。

那么我们这么想，最短路问题，我们通常都是只对起点限制或者只对终点限制，然而这里要求起点终点都是关键点。

如果我们将所有的关键点作为起点，跑 BFS，可以满足起点的限制，那么终点的限制呢？

这个我们没有办法直接做，所以我们观察路径，我们发现对于中间的点是没有限制的，于是我们想到，我们可以拼接路径。

比如从关键点 $A\to B$，如果中间有一条边 $(x,y)$，那么路径也可以表示成 $A\to (x,y) \to B$。

于是我们考虑求出所有点 $x$ 的最近关键点 $F_x$，然后对于一条边 $(x,y)$ 可以更新 $F_{x}$，$F_{y}$ 的答案。


于是我们学会了这么一个 Trick：当对路径起点终点都作约束的时候可以考虑拼接路径。

--- 

顺便，其他题解对于这个做法的正确性好像都没有说的很明白，我来解释一下为什么这样不重不漏：

对于一个关键点 $A$，其到最近的关键点 $B$ 的路径，所有点的 $F_x$ 应该是连续的一段 $A$ 和连续的一段 $B$，否则与 $B$ 是最近的关键点矛盾，而两者的分界线的那条边就可以给 $(A,B)$ 更新正确的答案。

```cpp
#include<bits/stdc++.h>
#define pII pair<int,int>
#define Fi first
#define Se second
#define pb push_back
using namespace std;
const int N=1e6+5;
int n,m,k,L,R,Vis[N],Ans[N];
int X[N],Y[N],Sp[N];
int A[N],B[N],O[N];
pII D[N];
const int Inf=1e9;
inline int Nam(int x,int y)
{
	return (x-1)*n+y;
}
inline int Dis(int a,int b){return abs(X[a]-X[b])+abs(Y[a]-Y[b]);}
vector<int>E[N];
inline void Add(int x,int y)
{
	if(!Vis[x]||!Vis[y])return;
	E[x].pb(y),E[y].pb(x);
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&L,&R);
	for(int i=1;i<=n;i++)scanf("%d%d",&X[i],&Y[i]);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		int D=Dis(i,j);
		Vis[Nam(i,j)]=L<=D&&D<=R;
	}
	scanf("%d",&k);
	for(int i=1,x,y;i<=k;i++)
	{
		scanf("%d%d",&x,&y);
		Sp[i]=Nam(x,y),Ans[i]=Inf;
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&A[i],&B[i],&O[i]);
		if(!O[i])
		{
			for(int j=1;j<=n;j++)Add(Nam(A[i],j),Nam(B[i],j));
		}
		else
		{
			for(int j=1;j<=n;j++)Add(Nam(j,A[i]),Nam(j,B[i]));
		}
	}
	for(int i=1;i<=m;i++)
	for(int j=1;j<=m;j++)
	{
		if(!O[i]&&O[j])
		{
			Add(Nam(A[i],A[j]),Nam(B[i],B[j]));
			Add(Nam(A[i],B[j]),Nam(B[i],A[j]));
		}
	}
	queue<int>Q;
	for(int i=1;i<=n*n;i++)D[i]={Inf,0};
	for(int i=1;i<=k;i++)Q.push(Sp[i]),D[Sp[i]]={0,i};
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		for(int v:E[u])
		{
			if(D[v].Fi>D[u].Fi+1)
			{
				D[v].Fi=D[u].Fi+1,D[v].Se=D[u].Se;
				Q.push(v);
			}
		}
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		int u=Nam(i,j);
		for(int v:E[u])
		{
			if(D[u].Se==D[v].Se)continue;
			Ans[D[u].Se]=min(Ans[D[u].Se],D[u].Fi+D[v].Fi+1);
			Ans[D[v].Se]=min(Ans[D[v].Se],D[u].Fi+D[v].Fi+1);
		}
	}
	for(int i=1;i<=k;i++)
	{
		if(Ans[i]==Inf)puts("-1");
		else printf("%d\n",Ans[i]);
	}
}
```

---


# [Sloi 2024]D1T2 简单的反链求和问题

## 题目背景

本题 **idea from**：[Projecteuler P386](https://pe-cn.github.io/386/).

![](https://cdn.luogu.com.cn/upload/image_hosting/0yeo7vce.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/8r5uh8th.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/h7syotrv.png)

图源：[zhihu](https://www.zhihu.com/question/19813666/answer/45229974).

## 题目描述

反链是序理论中的一个极其优美的结构。

---

给定正整数 $n$，记 $S(n)$ 为 $n$ 的约数构成的集合。

若 $S(n)$ 的子集 $A$ 只包含一个元素，或者 $A$ 中任意一个元素均不能整除其它元素，则称 $A$ 为 $S(n)$ 的**反链**。

例如：$S(30) = \{1, 2, 3, 5, 6, 10, 15, 30\}$。

- $\{2, 5, 6\}$ 不是 $S(30)$ 的反链。

- $\{2, 3, 5\}$ 是 $S(30)$ 的反链。

**hhoppitree** 喜欢长的反链，记 $f(n)$ 表示 $S(n)$ 的最长反链长度，她需要你帮忙求出 $ans=\sum\limits_{k=1}^n f(k)$。

~~如果做不出来，她就会喵的一声扑向你~~

## 说明/提示

样例 $1$：除了 $f(6)=f(10)=2$，其余 $f(k)=1(1\le k\le 10)$。

样例 $2$：除了 $f(6)=f(10)=f(12)=f(14)=f(15)=f(18)=f(20)=2$，其余 $f(k)=1(1\le k\le 20)$。

---

**本题采用捆绑测试**

对于所有测试数据，保证 $1\le n\le 123477145069\approx 1.2\times 10^{11}$。

**可以证明答案一定在 `long long` 范围内。**

|Subtask	| $n \le$ | Score |
| :--: | :--: | :--: |
|$1$ | $10$ | $5$ |
|$2$ | $2500$ | $5$ |
|$3$ | $10^6$ | $10$ |
|$4$ | $10^7$ | $10$ |
|$5$ | $10^8$ | $10$ |
|$6$ | $10^9$ | $20$ |
|$7$ | $23477145069$ | $20$ |
|$8$ | $123477145069$ | $20$ |

## 样例 #1

### 输入

```
10
```

### 输出

```
12```

## 样例 #2

### 输入

```
20```

### 输出

```
27```

## 样例 #3

### 输入

```
2347```

### 输出

```
6126```

## 样例 #4

### 输入

```
9234799```

### 输出

```
43445933```

## 样例 #5

### 输入

```
99234799```

### 输出

```
524524311```

## 样例 #6

### 输入

```
1000000000```

### 输出

```
5844921982```

## 样例 #7

### 输入

```
23477145069```

### 输出

```
154961952468```

# 题解

## 作者：Argon_Cube (赞：10)

新年第一题。

---

首先考虑如何算 $f(n)$。设 $n=\prod_i p_i^{k_i}$，可以发现 $f(n)$ 只与 $k_i$ 有关。但是还是难以计算 $f(n)$，此时我们需要一个结论：

> 令 $\Omega(n)$ 为 $n$ 的质因数分解中的 $k_i$ 之和。则一定存在一种最优解使得任意两个被选中的数 $a,b$ 都满足 $\Omega(a)=\Omega(b)$。

这个结论我还不会证，可能以后会补充完整。

猜出这种构造并不难，因为看起来这种构造就是很优的，且显然有合法性和极大性。

这样我们只需要做背包就能计算 $f(n)$ 了。但是要求的是 $f$ 的前缀和，把 $0$ 去掉后直觉上本质不同的 $\{k_i\}$ 应该是很少的，搜出来一共只有大约 $2.3\times 10^4$ 种，容易对于每种 $\{k_i\}$ 求出其对应的 $f(n)$。

现在我们只需要算出有多少个 $n$ 质因子次数是 $\{k_i\}$ 即可。直接爆搜除了最后一位以外的位置填哪些质数，最后一位次数如果是 $1$ 则可以使用 Min_25 筛做质数前缀统计，否则能填的最大质数不到 $\sqrt n$ 可以线性筛时直接预处理。可以发现这个东西跑的飞快然后就过了。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <bitset>
#include <string>
#include <array>
#include <cmath>

#define rgall(arr) (arr).begin(),(arr).end()
#define rgcnt(arr,cnt) (arr).begin(),(arr).begin()+(cnt)
#define rgo1(arr,cnt) (arr).begin()+1,(arr).begin()+1+(cnt)
#define rgany(arr,cnt,offset) (arr).begin()+(offset),(arr).begin()+(offset)+(cnt)

using namespace std;

array<long long,800000> dpp0,bpos;
const array<int,15>     DFSps={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
array<int,400000>       primes,sump0;
bitset<400000>          isprime;
vector<int>             cntps,sumps;
long long               answer,cntp,n,n2;
int                     divline;

long long fast_pow(long long base,long long exp)
{
    long long result;
    for(result=1;exp;exp&1?result=result*base:true,base=base*base,exp>>=1);
    return result;
}
inline long long xrooti(long long a,int b)
{
    return pow(a,1./b)+1e-10;
}
inline int loc_idx(long long a)
{
    return a>n2?n/a:n2-a+divline;
}
long long DFS_count(int dep,long long a,int pidx)
{
    if(cntps.empty())
        return 1;
    if(dep==cntps.size()-1)
    {
        if(cntps.back()==1)
            return max(0ll,dpp0[loc_idx(a)]-pidx);
        return max(sump0[xrooti(a,cntps.back())]-pidx,0);
    }
    long long result=0;
    for(int i=pidx+1;i<=cntp&&fast_pow(primes[i],sumps[dep])<a;i++)
        result+=DFS_count(dep+1,a/fast_pow(primes[i],cntps[dep]),i);
    return result;
}
void DFS_factor(int dep,long long a,const long long n)
{
    array<int,60> dp{1};
    for(int i:cntps)
        for(int j=59;j;j--)
            for(int k=1;k<=i&&k<=j;k++)
                dp[j]+=dp[j-k];
    int maxc=0;
    for(int i:dp)
        maxc=max(maxc,i);
    sumps=cntps;
    for(int i=(int)cntps.size()-2;i>=0;i--)
        sumps[i]+=sumps[i+1];
    answer+=maxc*DFS_count(0,n,0);
    cntps.push_back(1);
    a=a*DFSps[dep];
    while(a<=n)
    {
        DFS_factor(dep+1,a,n);
        a=a*DFSps[dep],++cntps.back();
    }
    cntps.pop_back();
}

int main(int argc,char* argv[],char* envp[])
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n,n2=sqrt(n)+1e-9;
    for(int i=2;i<=n2;i++)
    {
        sump0[i]=sump0[i-1];
        if(!isprime[i])
            primes[++cntp]=i,++sump0[i];
        for(int j=1;j<=cntp&&i*primes[j]<=n2;j++)
        {
            isprime.set(i*primes[j]);
            if(!(i%primes[j]))
                break;
        }
    }
    int cntb=0;
    for(long long i=1,j;i<=n;i=n/j+1)
    {
        ++cntb,dpp0[cntb]=(j=bpos[cntb]=n/i)-1;
        if(!divline&&j<=n2)
            divline=cntb;
    }
    for(int i=1;i<=cntp;i++)
        for(int j=1;1ll*primes[i]*primes[i]<=bpos[j];j++)
            dpp0[j]-=dpp0[loc_idx(bpos[j]/primes[i])]-i+1;
    DFS_factor(0,1,n);
    cout<<answer;
    return 0;
}
```

---

## 作者：masterhuang (赞：3)

**std** 代码能跑进 **1s**。

---

前置知识：[Fireflies](https://qoj.ac/contest/749/problem/3234) 的结论，**min_25** 筛。

- 下面多次应用到第一个例题，所以强烈建议先完成此例题。

---

我们先考虑如下问题，在 $[1,p_1]\times [1,p_2]\times \cdots \times [1,p_n]$ 的高维空间建立偏序关系，求最长反链大小。

具体的说：给定 $(x_1,...,x_n)$ 的 $n$ 维点，其中 $1\le x_k\le p_k$，若高维点 $A,B$ 满足 $\forall 1\le k\le n,A_k\le B_k$，则 $A\to B$ 连边，求这个图的最长反链大小。

摘录 [Fireflies](https://qoj.ac/contest/749/problem/3234) 的题解：

**Dilworth** 定理表明，最小链覆盖数等于最大反链数，也即选出互不可达位置的最多数目。

**Sperner** 定理显示，若要选择 $S$ 的幂集的一个子集使得其中没有一个集合包含在另一个集合中，则这种子集
的大小最大为 $\dbinom{|S|}{\lfloor |S|/2\rfloor }$。

**Sperner** 定理的一种推广可以给出本问题的答案：选择满足所有坐标之和等于 $M=\lfloor\frac{1}{2}\sum\limits_{i=1}^n (p_i+1)\rfloor$ 的位置即可达到最大的数量。

因此，我们需要计算的答案即为 $\sum\limits_{i=1}^n x_i=M$ 的解数，其中 $x_i\in \mathbb{Z},1\le x_i\le p$。

考虑容斥原理，可知答案为 $\sum\limits_{S\subseteq U} (-1)^{|S|} \dbinom{M-1-\sum_{i\in S} p_i}{n-1}$。

这样即可 $O(2^n)$ 计算最长反链大小。

**extend：** 推广 **Sperner** 定理的那个结论证明参考[这里](https://math.stackexchange.com/questions/299770/width-of-a-product-of-chains)。查看 [Fireflies](https://qoj.ac/contest/749/problem/3234) 的题解有 $O(2^{n/2}\text{poly}(n))$ 的求解本问题的方案，但是这题应该是不必要的。

---

接下来我们先考虑对于单个 $n$ 描述 $f(n)$。

设 $n=\prod\limits_{i=1}^c p_i^{k_i}$，则容易发现**整除关系**构成了高维空间中的一个偏序关系。

即 $f(n)$ 为：在 $[0,k_1]\times [0,k_2]\times \cdots \times [0,k_c]$ 的高维空间建立偏序关系，求最长反链大小。

对于单个 $n$ 是容易套用上述结论求解的，下面记 $\omega(n)$ 表示 $1\sim n$ 中最大的素因子个数，即 $1\sim n$ 质因数分解中的 $\max \{c\}$。

则复杂度为 $O(2^{\omega(n)})$ 或 $O(2^{\omega(n)/2}\times \text{poly})$。

---

这时候我们容易注意到 $f(n)$ 只和可重集 $\{k_1,k_2,\cdots k_c\}$ 的形态相关。

容易猜想不同形态的 $\{k_1,k_2,\cdots k_c\}$ 个数很少，设规模为 $K(n)$。

于是**假设**我们筛出了**所有形态**的 $\{k_1,k_2,\cdots k_c\}$，以及在 $1\sim n$ 中这种形态出现的次数。

那么容易枚举每一种形态套用上面计算方案，乘上个数然后累加即可。

---

设 $S=\{c\}$ 表示所有形态的素因数个数 $c$ 构成的可重集，那么复杂度规模是 $\sum\limits_{c\in S} 2^{c}$。

一个朴素的上界是 $O(K(n)2^{\omega(n)})$，但是大胆猜测**均摊下来** $2^c$ 不会太大，在本题范围下不妨试做一个大一点的常数 $C$。

于是复杂度可以看作 $O(C\cdot K(n))$。

- 或者采用 $O(2^{n/2}\text{poly}(n))$ 的算法就更不用担心这部分的复杂度，**std** 采用的是这种写法（直接粘的那个题）。

- 但是 $O(2^n)$ 的做法已经足够通过本题，因为在最大数据情况下，$K(n)\le 2300,\omega(n)\le 10$。

---

考虑如何筛出**所有形态**的 $\{k_1,k_2,\cdots k_c\}$，以及在 $1\sim n$ 中这种形态出现的次数。

我们注意到当 $p>\sqrt n$ 时，$p$ 的幂次至多为 $1$。

暴力从小到大枚举素数及其幂次 **dfs**。

若 **dfs** 到 $p_k$，当前累乘的数为 $s$，若 $s$ 是第一次出现，我们把 $s$ 的幂次构成的集合加上贡献 $1$。

- 当 $p_k^2s>n$ 时，我们只需 $s$ 的幂次加上元素 $1$ 这个集合，贡献是 $[p_k,\lfloor n/s\rfloor ]$ 中的素数个数。然后直接退出 **dfs**。

维护细节方面：

- 素数个数这个东西写个 **min_25** 筛简单维护即可，因为都是 $\lfloor n/x\rfloor$ 的形式。

- 维护集合的出现次数（即贡献）可以写一些简单的集合哈希，把集合映射到数上，然后上个 `gp_hash_table`，显然由于优良性质是很难冲突的。

- 我这种写法 $1$ 的贡献是没有计算到的，但是 $n=1$ 时 $f(1)=1$。最后答案要加上 $1$。

大致代码：

```cpp
mt19937_64 rnd(time(0));

u64 hs[105];
gp_hash_table<u64,LL>mp;
gp_hash_table<u64,vec>mp1;
vec K;
inline u64 upd(u64 v)
{
	if(mp1.find(v)==mp1.end()) mp1[v]=K;
	return v;
}
inline void dfs(int x,LL S,u64 v)
{
	if(x>cnt||(__int128)pr[x]*pr[x]*S>n)
	{
		LL t=g[TO(n/S)];
		if(t>=x) K.push_back(1),mp[upd(v+hs[1])]+=t-x+1,K.pop_back();
		return;
	}
	dfs(x+1,S,v);
	for(LL i=1,s=S*pr[x];s<=n;i++,s*=pr[x])
	{
		K.push_back(i),mp[upd(v+hs[i])]++;
		dfs(x+1,s,v+hs[i]);
		K.pop_back();
	}
}

for(int i=0;i<=100;i++) hs[i]=rnd();
dfs(1,1,0);

LL ans=1;
for(auto [u,v]:mp) ans+=v*sol(mp1[u]);
cout<<ans;
```

复杂度分析：感受那股劲，在这题极限数据下 **dfs** 的次数不超过 $4\times 10^7$，足以通过本题。

---

$O(C\cdot K(n))$ 的最后计算，$O(n^{3/4}/\log n)$ 的 **min_25** 筛均不成为复杂度瓶颈。

复杂度瓶颈在于 **dfs** 爆搜。据学长所述这东西是 $o(n)$ 的，但是这里跑出来比较优秀。

[$\bf{code}$](https://www.cnblogs.com/HaHeHyt/articles/18859199)

---

## upd on 2024/11/18，加强到 1.2*10^11 级别

**dfs** 部分可以枚举到 $p^3s>n$ 的时候，然后剩下的就只能是 $p,pq,p^2$，$p,p^2$ 是容易处理的。$pq$ 的部分仍然选择枚举。

速度比上面的做法在极限数据下快 $4\sim 6$ 倍，上面那个 $90$ 分，这个满分。

代码（仅有 **dfs** 部分有改动）：

```cpp
#define sq __builtin_sqrtl
inline void dfs(int x,LL S,u64 v)
{
	if(x>cnt||(__int128)pr[x]*pr[x]*pr[x]*S>n)
	{
		LL m=n/S,t=g[TO(m)];int U=sq(m);
		if(t>=x) K.push_back(1),mp[upd(v+hs[1])]+=t-x+1,K.pop_back();
		t=g[U];
		if(t>=x) K.push_back(2),mp[upd(v+hs[2])]+=t-x+1,K.pop_back();
		K.push_back(1),K.push_back(1);
		u64 V=upd(v+hs[1]*2);
		for(int i=x;i<=cnt&&pr[i]<=U;i++) mp[V]+=g[TO(div(m,pr[i]))]-i;
		K.pop_back(),K.pop_back();
		return;
	}
	dfs(x+1,S,v);
	for(LL i=1,s=S*pr[x];s<=n;i++,s*=pr[x])
	{
		K.push_back(i),mp[upd(v+hs[i])]++;
		dfs(x+1,s,v+hs[i]);
		K.pop_back();
	}
}
```

[$\bf{code}$](https://www.cnblogs.com/HaHeHyt/articles/18859200)

---

猜测这部分枚举能做到更优，并且不是单纯的这样一层一层拆。

---

## 本题可能的一些拓展研究

### 关于 $K(n)$ 的估计

如何对 $K(n)$ 更优秀的估界？[paper](https://arxiv.org/abs/2207.09410)，相关问题的 [oeis 表](https://oeis.org/A025487)。

论文表明了 $K(n)\sim \exp\left(\dfrac{2\pi}{\sqrt 3}\sqrt {\dfrac{\log n}{\log \log n}}\right)$。

给出一点简单的估计：显然每个集合中的元素之和不会超过 $\lfloor\log_2 n\rfloor$，于是我们直接用 $\lfloor\log_2 n\rfloor$ 的划分数来估计这个值。

划分数用经典估计：$p(n)\le \exp\left(\sqrt{\dfrac{20n}{3}}\right)$。那就估出了 $\exp(\sqrt {\log n})$ 这个级别，其实已经大差不差了（~~自我安慰罢了~~）。



### dfs 部分的分析

~~不会！~~

我只能说不劣于 **min_25**，理论总复杂度是 **min_25** 那里的。

---


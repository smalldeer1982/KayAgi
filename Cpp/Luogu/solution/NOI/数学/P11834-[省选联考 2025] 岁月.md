# [省选联考 2025] 岁月

## 题目背景

> 希望大家一直记得我。  
> “希望大家永远忘了我。”

## 题目描述

小 Y 有一个 $n$ 个节点、$m$ 条边的带权**无向图** $G$，节点由 1 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边连接 $u_i$ 和 $v_i$，边权为 $w_i$。保证 $G$ 连通且没有重边自环。

小 Y 预见到岁月将会磨灭图 $G$ 的痕迹，而这会导致一些边变成有向边，另一些边直接消失。具体地，图 $G$ 历经岁月将会磨损为 $n$ 个节点的带权**有向图** $G'$，其中对于第 $i$ ($1 \leq i \leq m$) 条边，$G'$ 上
- 有 $\frac{1}{4}$ 的概率同时存在 $u_i$ 向 $v_i$ 和 $v_i$ 向 $u_i$ 的有向边，它们的边权均为 $w_i$;
- 有 $\frac{1}{4}$ 的概率存在 $v_i$ 向 $u_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率存在 $u_i$ 向 $v_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率 $u_i$ 和 $v_i$ 之间没有边。

所有 $m$ 个随机事件是独立的。

小 Y 认为一个无向图的核心是最小生成树，而一个有向图的核心是最小外向生成树。称图 $G'$ 的一个边子集 $E$ 是**外向生成树**，当且仅当 $|E| = n - 1$ 且存在一个节点 $x$ 可以只经过 $E$ 中的有向边到达图 $G'$ 上的所有节点。图 $G'$ 的**最小外向生成树**即为图 $G'$ 上边权和最小的外向生成树。

小 Y 希望图的核心历经岁月侵蚀也保持不变，于是他想知道，有多大的概率，图 $G'$ 的最小外向生成树存在，且其边权和等于图 $G$ 的最小生成树边权和。

你需要将答案对 $(10^9 + 7)$ 取模。可以证明答案一定为有理数 $\frac{a}{b}$，其中 $a$ 和 $b$ 互质，且 $b$ 不是 $(10^9 + 7)$ 的倍数。因此你输出的数 $x$ 需要满足 $0 \leq x < 10^9 + 7$ 且 $a \equiv bx \pmod{10^9 + 7}$，可以证明这样的 $x$ 唯一存在。

## 说明/提示

**【样例 1 解释】**

该组样例共有 2 组测试数据。
- 对于第一组测试数据，由于图上只有一条边，因此只要 $G'$ 上有边，$G'$ 的最小外向生成树边权和就一定等于 $G$ 的最小生成树边权和。$G'$ 上存在边的概率为 $\frac{3}{4}$，故答案为 $\frac{3}{4}$，取模后的结果为 $750\,000\,006$。
- 对于第二组测试数据，在所有 $2^{2m} = 64$ 种 $G'$ 中，有 13 种情况不满足 $G'$ 的最小外向生成树边权和等于 $G$ 的最小生成树边权和：
 - $G'$ 为空图;
 - $G'$ 仅包含一条有向边，共 6 种情况;
 - $G'$ 仅包含两条有向边，且指向同一个节点，共 3 种情况;
 - $G'$ 仅包含两条有向边，且构成一个二元环，共 3 种情况。

由于所有情况等概率出现，因此答案为 $1 - \frac{13}{64} = \frac{51}{64}$，取模后的结果为 $171\,875\,002$。

**【样例 2】**

见选手目录下的 `years/years2.in` 与 `years/years2.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $1 \sim 3$、$4 \sim 6$、$7,8$、$9 \sim 11$、$12,13$ 的限制。

**【样例 3】**

见选手目录下的 `years/years3.in` 与 `years/years3.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $14 \sim 16$、$17, 18$、$19, 20$、$21 \sim 23$、$24, 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 5$,
- $2 \leq n \leq 15$, $n - 1 \leq m \leq \frac{n(n-1)}{2}$,
- $\forall 1 \leq i \leq m$, $1 \leq u_i < v_i \leq n$, $1 \leq w_i \leq m$,
- $\forall 1 \leq i < j \leq m$, $(u_i, v_i) \neq (u_j, v_j)$，即 $G$ 没有重边，
- 保证 $G$ 连通。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:------------:|:------------:|:----------:|
| $1 \sim 3$ | $6$ | A |
| $4 \sim 6$ | $15$ | B |
| $7, 8$ | $9$ | C |
| $9 \sim 11$ | $12$ | ^ |
| $12, 13$ | $14$ | ^ |
| $14 \sim 16$ | $15$ | ^ |
| $17, 18$ | $9$ | 无 |
| $19, 20$ | $12$ | ^ |
| $21 \sim 23$ | $14$ | ^ |
| $24, 25$ | $15$ | ^ |

- 特殊性质 A：$m \leq 6$, $\forall 1 \leq i \leq m$, $w_i \leq 2$。
- 特殊性质 B：$\forall 1 \leq i < j \leq m$, $w_i \neq w_j$。
- 特殊性质 C：$\forall 1 \leq i \leq m$, $w_i = 1$。

## 样例 #1

### 输入

```
0 2
2 1
1 2 1
3 3
1 2 2
1 3 2
2 3 2```

### 输出

```
750000006
171875002```

# 题解

## 作者：chenxinyang2006 (赞：53)

记号：$U=\{1,2...n\}$ 点的全集。

  对于 C 性质， $G'$ 合法充要于存在一个点 $u$ 使得 $u$ 在 $G'$ 上可达所有点。

  先来考虑更为简化的一个情况：必须 $u=1$ 在 $G'$ 上可达剩余所有点才认为合法，该情况该如何解决？

  可以做类似 [连通无向图计数](https://www.luogu.com.cn/problem/P10982) 的操作：设 $f_S$ 表示 $S$ 导出子图内的边按照所述方式随机是否保留，那么 $1$ 可达 $S$ 内所有点的概率，这里我们认为只有 $1 \in S$ 时 $f_S$ 才有意义。那么考虑不合法的情况必定是 $1$ 只可达 $S$ 的某个真子集 $T$，容斥减去这些情况即可。记 $cross(S,T)$ 为 $S,T$ 两个集合间的连边数（默认 $S \cap T=\varnothing$），转移应是 $f_S=1-\sum\limits_{T \subsetneq S,1 \in T} f_T 2^{-cross(S-T,T)}$。

  但事实上限制是 “存在一个点 $u$”，假设这样合法的点 $u$ 构成集合 $P$。那么在 $G'$ 上，$P$ 导出子图就应强连通，并且所有不在 $P$ 内的点必然不能有边指向 $P$ 内的点。除此之外要求 $P$ 内所有点可达所有 $1 \sim n$，这部分的概率可以用上述 DP 计算，只需改为认为只有 $P \subseteq S$ 时 $f_S$ 才有意义即可。这三部分的概率都是独立的可以分别计算出后相乘，对所有 $P \subseteq \{1,2...n\}$ 求出 $P$ 导出子图强连通的概率与 [主旋律](https://www.luogu.com.cn/problem/P11714) 的做法一致。这样我们确实得到了一个 C 性质能跑的做法，但做 $f$ 的 DP 的部分太慢了。[$4^n$ C 性质](https://www.luogu.me/paste/mdz5djw8)

  观察这份代码，$f$ 的转移可以视作在有向图上游走：对于 $T \subsetneq S$，$T \to S$ 有一条权重为 $-2^{-cross(S-T,T)}$ 的边，记一条路径的权值为其上所有边的边权之积。对于 $P$ 而言，希望求出的值其实是所有起点 $P'$ 满足 $P \subseteq P'$，且终点为 $U$ 的 $P' \to U$ 的所有路径的权值和。倒过来设 $f'_T$ 为 $T \to U$ 所有路径权值和，可以 $O(3^n)$ 求出所有 $f'_T$，再做一次超集和即可求出需要的值。[$3^n$ C 性质](https://www.luogu.me/paste/9lychgxv)
  
  接下来考虑原问题，对于一颗选定的 $G'$ 的外向生成树，它和 $G$ 的最小生成树边权和相同实际上当且仅当对任意的 $v \in \Z$，连上所有边权 $\le v$ 的所有边得到的图的连通性，与连接外向生成树边权 $\le v$ 的所有边并视有向图为无向图后得到的图的连通性是完全一致的。这里 $G_1,G_2$ 的连通性完全一致定义为 $\forall 1 \le u,v \le n$，$u,v$ 在 $G_1$ 内连通充要于 $G_2$ 内连通。这一性质如果了解 [最小生成树计数](https://www.luogu.com.cn/problem/P4208) 的做法就不难看出。
  
  知道这一点后，该如何设计出一个易于改写为计数的判断 $G'$ 是否合法的算法？设 $G_v$ 只保留 $G$ 内所有边权 $\le v$ 的边后得到的图，$G'_v$ 为 $G'$ 的某颗合法外向生成树只保留边权 $\le v$ 的边后得到的图。由于上述性质，$\forall v \in \Z$，$G'_v$ 一定形成与 $G_v$ 弱连通性一致的外向森林（外向树删去一些边后得到外向森林）。且从 $v \to v+1$，考虑 $G_{v+1}$ 的某个连通块是由一些 $G_v$ 的连通块合并而来，相应的 $G'_{v+1}$ 内点集一致的弱连通块一定由 $G'_v$ 内原来的对应的外向森林（设有 $s$ 颗外向树）合并而来，有恰 $s-1$ 个原来的外向树的根被一条 $G'$ 内边权为 $v+1$ 的边指向。
  
  既然这样，不难看出实际上只有每个外向树的根是重要的。要对 $G'$ 找合法外向生成树，在固定 $v$ 时只需知道 $G_v$ 的每个连通块内，以这个连通块内的每个点为根是否存在满足上述过程的外向生成树。初始 $v=0$ 时 $G_0$ 没有边，所有点都合法。当 $v \to v+1$ 时，若 $G_{v+1}$ 合并了一些连通块 $S_1,S_2...S_k$ ，$u \in S_i$ 合法，当且仅当它之前就合法，且可以选出 $G$ 中一些权值为 $v+1$，指向的点也之前合法的边，使得将 $S_i$ 整体视作一个点后，选出的边在 $k$ 个点的图上是一颗以 $i$ 为根的外向树。最后只要有至少一个点合法 $G'$ 就合法。
  
  新问题与 C 性质是非常类似的，但区别在于在新问题上即使是权值为 $v+1$ 的会被考虑的边，其也只在指向的点是之前合法的点时有意义。增量维护 $v$，设 $res_S$ 为 $S$ 所在的 $G_v$ 的连通块中 $S$ 恰是合法点集的概率，$res_S$ 的值仅在 $S$ 所有点在 $G_v$ 中属于同一连通块时才有意义。$v \to v+1$ 时需要计算新的 $res$，将 C 性质的做法移植过来即可，区别主要在于如果将一个 $G_v$ 中的连通块视作一个点的话，这个点带有一些 “属性” 是这个连通块之前的合法点集，而这个 “属性” 会影响转移系数（因为只有指向的点是合法点的边才有意义） 。细枝末节的地方建议 [看代码](https://www.luogu.me/paste/q4u44lpo)。
  
  最后是时间复杂度的问题，容易理解复杂度不会高于 $O(3^nn)$ 因为实际上连通性只会发生 $n$ 次合并，而每次合并的转移只是在做 C 性质是 $O(3^n)$ 的。但实际上加一个小优化：若点 $u$ 所在的连通块在 $G_v,G_{v+1}$ 中没有发生变化，所有包含 $u$ 的 $res$ 其实保持不变，于是所有包含 $u$ 的状态都无需考虑。那么合并总点数为 $s$ 的连通块便只消耗 $O(3^s)$ 时间，考虑 $T(n)=\max\limits_{a_1+a_2+a_3+...+a_k=n,a_i \ge 1,k > 1} (\sum\limits_{i=1}^k T(a_i)+O(3^n))$ 显然是 $O(3^n)$ 的。如果要分析得再仔细一些的话，上面给出的代码其实是 $O(2^nn^2+3^n)$ 的。

---

## 作者：CarroT1212 (赞：32)

$\gdef\mst#1{\operatorname{MST}(#1)}\gdef\most#1{\operatorname{MOST}(#1)}$图计数超值全家桶。之后的省选应该不会 D2T2 稳定出一道状压图计数题吧。

下面会有大量也许无关紧要的细节，但如果你对这些知识熟悉的话其实很多地方都可以一下就想清楚。所以主要也是帮我自己整理一些图计数的思路。虽然写的不太是人话。

首先觉得不顺眼的话可以和重塑时光一样开局把概率杀了转纯方案数计算，但这题不杀的话做法貌似更好理解。所以保留概率计算。估计是这种元素概率性存在问题，直接用概率算可以更好地表示一些互相独立的信息，系数会简单一点。但是赛场上写调试难度极大，见仁见智吧。

明确一下使用的定义：

+ $U$ 为点全集。
+ $G$ 是输入给定的带权**无向图**；
+ $G"$ 为**有向图**形态下的 $G$，即 $G$ 的无向边在 $G"$ 里以成对有向边形式存在；
+ $G'$ 为 $G"$ 里的每一条有向边以 $\frac{1}{2}$ 的概率出现或不出现时得到的**有向**图。
+ $E(S,T)$ 为 $G$ 中连接点集 $S$ 和 $T$ 的边的数量。$E(S)$ 为 $S$ 内部的边数。
+ ST 指无向图的生成树，MST 指无向图的最小生成树，OST 指有向图的外向生成树，MOST 指有向图的最小外向生成树。
+ $\mst G$ 为无向图 $G$ 的一棵 MST，$\most G$ 为有向图 $G$ 的一棵 MOST。
+ 反斜杠太难打了，用正斜杠。

### A 性质

直接枚举 $G'$，判定是否存在 $G'$ 的子边集为 OST 且权值等于 $\mst G$ 即可。至此 $12$ 分。

### B 性质

$\mst G$ 是唯一的，那么 $\most{G'}$ 肯定为 $\mst G$ 上每一条边定向得到，并且 $G'$ 上其它的边没有任何限制，反正它们不可能成为合法 MOST 上的边。所以可以直接令 $G\gets \mst G$，然后问题就变成了 $G$ 是**一棵树**，求 $G'$ **存在** OST 的概率，无需考虑最小性。

如果固定 $G'$ 上的外向树根为 $rt$，那么对 $G'$ 合法性的限制其实只有，$G'$ 上所有朝 $rt$ 外侧的有向边必须存在。

但实际计数时一个 $G'$ 可以有多个合法的 OST 根，直接枚举 $rt$ 包算重的。那就直接枚举 $G'$ 合法 OST 根的**集合** $R$ 是什么。要求：从 $R$ 任意一个点开始能走到全图；不存在 $x\notin R$ 也可作为外向树根。

意会一下把条件转为更形象的东西：$R$ 内部每一对有向边都双向存在（$R$ 是强连通的）；剩下所有指向外侧的有向边都存在；不存在任何边从 $R$ 外指向 $R$ 内。

这三种边集不相交，所以计算三种边数各自概率乘起来即可。于是 $O(2^n)$ 左右解决，至此 $24$ 分。

### C 性质

$G'$ 上任意一棵 OST 都是 MOST。所以就是把 B 性质加强了一下，还是计算有多少个 $G'$ 满足存在外向生成树，但 $G$ 不一定是树了。

考虑还是一样枚举合法 OST 根集合 $R$。答案概率还是可以跟 B 性质一样分成类似的三部分。

+ $R$ 强连通。
  + 这是[主旋律](https://www.luogu.com.cn/problem/P11714)。具体做法建议到那题题解下学习。
  + ~~我场上就死这了。~~
  + 简单来说，考虑缩点后的 $R$，那么如果 $R$ 不合法它就会形成 $>1$ 个 scc 的 DAG。然后套 DAG 计数的容斥做法，但这里容斥系数看的是 scc 数（而不是更普遍的点数），不太好直接求，所以点集作为零度点的贡献带上容斥系数之和需要额外来一个 DP（奇 scc 数贡献 $-$ 偶 scc 数贡献）。
+ $G'$ 中（在假定 $R$ 内部已经强连通的情况下），剩下存在的边支持从 $R$ 开始可以走到全图。
  + 也是一个经典的 DP 思路。设 $dp_S(S\supseteq R)$ 为从 $R$ 能走到 $S$ 内全部点的概率，$dp_R=1$。
  + 每次转移减去不合法的概率。每次转移到 $S$ 时，枚举 $S$ 内有一个集合 $T$，从 $R$ 不能到，于是有转移 $dp_S=1-\sum\limits_{T\subsetneq S,T\cap R=\varnothing} dp_{S/T}\cdot 2^{-E(S/T,T)}$，表示限制 $G'$ 里从 $S/T$ 连向 $T$ 的所有边都不存在。直接拿 $dp_U$ 就是结果。但这个和枚举 $R$ 搞在一起是 $O(4^n)$ 的，不太牛。
  + 注意所有 $R$ 的 DP 中，始态五花八门，但是终态都是一个 $dp_U$，而且转移只有简单的加减乘。于是可以转置此 DP，只用从 $U$ 开始反过来做一遍就可以得到所有 $dp_R$ 对应的结果，喜提 $O(3^n)$。
    + 关于转置 DP：
    + 把转移看成在点数 $2^n$ 的图上移动，相当于你可以从任意 $R'\supseteq R$（注意这里的超集关系）以 $1$ 为初始权值开始走，每次从 $S/T\to S$ 的话权值要乘 $-2^{-E(S/T,T)}$，问 $R'\to U$ 的所有路径权值之和。
    + 如果把所有的转移方向反过来，那么结合上面意义可知此时 $U\to R'$ 算出的路径权值和正向时的 $R'\to U$ 是一样的。
    + 然后因为有个 $R'\supseteq R$，所以反向 DP 完之后还要做超集和。
+ 不存在任何边从 $R$ 外指向 $R$ 内。
  + 一个简单细节：为什么这个概率和前两个是独立的？
    + 显然它和强连通部分独立。
    + $U/R\to R$ 边的存在性和 $R$ 到全图的可行性没有关系。具体来说，就算这样的边加上了，你也只能可能可以从外面的某个点再走回到 $R$，不影响你能不能从 $R$ 走到外面的某个点。
  + 概率为 $2^{-E(U/R,R)}$。

$O(3^n)$，至此 $64$ 分。[代码](https://www.luogu.me/paste/bc5n08nx)。

### 正解

这里开始才需要真正跟 MST 的条件硬刚。现在是计算 $G'$ 里有 MOST，且其权值等于 $\mst G$ 的概率。我们需要想一些方法刻画它。

如果你做过类似的题，或者是从 B 性质 MST 唯一的结论受到启发，或者是狂暴分析了 Kruskal 操作的性质，那么你会知道，去按边权分层转化为连通性问题是一个不错的选择。

+ 结论：设 $G_x$ 是图 $G$ 只保留权值 $\le x$ 的边得到的图，$T$ 是 $G$ 的任意一棵 MST。设 $T'$ 是 $G$ 的一棵 ST，那么当且仅当对于所有 $x$ 都满足，**$T_x$ 和 $T'_x$ 中每一对点的可达性都相同**（或者说它们形成了相同的连通块），$T'$ 才是 $G$ 的一棵 MST。
  + 证明直接考虑 Kruskal 的过程。
+ 考虑如何类比这个结论先判断 $G'$ 是否有 MOST。
+ 这个结论是对于无向图的，所以对有向图 $G'$ 还要加一个限制就是，对于所有 $x$ 都满足，**$G'_x$ 的各个连通块里都存在 OST**，并限制 **$G'_x$ 的 “OST” 必须由 $G'_{x-1}$ 各个连通块的 “OST” 加上权值 $=x$ 的几条有向边得到**。
+ 这样做完，$G'$ 里的 “OST” 一定就是它的 MOST 了。现在只需考虑这个 MOST 的权值是否和 $G$ 的相同。

可以计数了。按边权从小到大处理这些边是否在 $G'$ 中出现。假设现在我们统一处理边权为 $w$ 的边，$\le w-1$ 的边的选取情况已经确定。

那这个时候，根据 $G$，我们一定知道，$G'_{w-1}$ 形成了哪几个连通块；$G'_{w-1}\to G'_w$ 是哪些小连通块合并成了大连通块。这是固定的。问题只在于，需要把这些各自有 OST 的小连通块，用 $=w$ 的边连成一个也有 OST 的大连通块。这部分看起来就很像 C 性质。

**只要严格根据 $G$ 各层的连通性进行合并，就能保证最终 $G'$ MOST 的权值和 $G$ 相同。**

细细地盘一下每次 $=w$ 需要做什么。以下的连通块指的全部都是弱连通块。

+ 称一个连通块中，可以作为这个连通块的某个 MOST 的根的**所有**点，为“根点”。其余为非根点。
+ 维护 $f_{w,R}$ 表示，$R$ 集合**恰好**为 $G'_w$ 中，其所在的连通块的根点集合，的概率。令 $R$ 必须全部在同一个连通块中才有意义。
+ 假设现在需要把 $k$ 个连通块 $P_1,P_2,\cdots,P_k$ 用 $=w$ 的边全部合并成一个大连通块 $P$。
+ 跟 C 性质相比主要多的细节在于，每个小连通块内的所有点都能对其它连通块输出有效的出边，但是**只有根点能接受有效的入边**。一个小连通块入边如果全部连到非根点就是不合法的，因为根点依然不可达。所以连边的时候需要多几个心眼子。
  + 枚举大连通块的根点集合 $R$。
  + 设点集 $S$ 里的点出现在的小连通块集合为 $sc_S$。
  + 依然把概率分为独立的几部分。
    + 这次多了一部分概率：我们还需要让 $R$ 的点在 $G'_{w-1}$ 就是各自小连通块里的根点，**并且这些小连通块没有别的根点不在 $R$ 里**（不然 $G'_w$ 的根点就不只有 $R$ 了）。这在接下来设计 DP 的时候可以一起处理。
  + 从 $R$ 能走到其它所有的连通块（以及 $R$ 里的点为各自小连通块的根点）。
    + 方法很多。感觉[这篇题解](https://www.luogu.com.cn/article/h03ia3tt)的 DP 设法比较好看，解释一下。
    + 很多人第一反应是设能到的连通块集合为 $S$ 然后转移。
    + 但实际上因为连边的时候我们只关心小连通块的根点集合，所以 DP 状态里也可以只存这些根点。反正只要知道哪些根点能到，就知道哪些小连通块可以到了。并且还可以把多出来的那一部分概率（$R$ 为小连通块根点）给处理了。
    + 设 $dp_S$ 为从 $R$ 开始，可以走到的小连通块**根点**集合为 $S$ 的概率。这个状态同时隐含了一个“**从 $R$ 可以走到的连通块集合恰好为 $sc_S$**”的条件，所以就不需要单独把 $sc_S$ 开进状态了。
    + 可以预处理一个 $be_S$ 表示，$sc_S$ 里的所有小连通块，它们的根点集合恰好组成了 $S$ 的概率。
    + 那么有转移 $dp_S=be_S-\sum\limits_{T\subsetneq S,sc_T\cap sc_{S/T}=\varnothing}2^{-E(sc_{S/T},T)}dp_{S/T}be_T$。注意这里多出来的几个 $sc$。
    + 依然可以用类似的方法转置成 $O(3^n)$。
    + 注意 $S$ 只要满足 $sc_S$ 包含了被合成一个大连通块的所有小连通块，它就是一个终态。
  + $R$ 强连通。
    + 对 $=w$ 的边跑主旋律。这里要魔改一下，根据定义，我们假定在同一个小连通块的根点一定是强连通的。这个概率在前一部分已经算过了。
    + 那么容斥的 $T$ 和 $S/T$ 里不能出现同一个小连通块。转移系数也有一点变化。
  + 没有边从完全与 $R$ 不交的**连通块**里的点连进 $R$。
    + 这是简单的。
  + 乘起来就获得了大连通块的 $f_{w,R}$。

时间复杂度？每次 $w-1\to w$ 时不需要管没有任何动静的连通块。瓶颈在每次的 $O(3^n)$ 上，加上这个优化后容易知道总共还是 $O(3^n)$ 的。

于是，我们通过了此题……

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define fi first
#define se second
#define mms(x) memset(x,0,sizeof(x))
using namespace std; bool MEM;
using ll=long long; using ld=long double;
using pii=pair<int,int>; using pll=pair<ll,ll>;
const int I=1e9;
const ll J=1e18,N=15,M=507,P=1e9+7;
ll qp(ll x,ll y=P-2) { return y?(y&1?x:1)*qp(x*x%P,y>>1)%P:1; }
ll type,n,m,U,p2[M],q2[M];
ll ee[1<<N],sc[1<<N],nsc[1<<N],be[1<<N],is[1<<N],cn[N],to[N];
ll f[1<<N],g[1<<N],dp[1<<N],ans[1<<N];
struct dsu {
	ll f[N];
	void ini() { iota(f,f+N,0); }
	ll fnd(ll x) { return f[x]==x?x:f[x]=fnd(f[x]); }
	void mrg(ll x,ll y) { f[fnd(x)]=fnd(y); }
} D;
struct edg { ll x,y,z; } b[M];
ll ce(ll s,ll t) { return ee[s|t]-ee[s]-ee[t]; }
void mian() {
	scanf("%lld%lld",&n,&m),U=(1<<n)-1,D.ini(),mms(ans);
	for (ll i=0,x,y,z;i<m;i++) scanf("%lld%lld%lld",&x,&y,&z),x--,y--,b[i]={x,y,z};
	sort(b,b+m,[](edg x,edg y){return x.z<y.z;});
	for (ll i=0;i<n;i++) ans[1<<i]=1,cn[i]=1<<i;
	for (ll s=1;s<=U;s++) nsc[s]=s;
	for (ll l=0,r;l<m;l=r+1) {
		for (r=l;r+1<m&&b[r+1].z==b[l].z;r++);
		swap(sc,nsc),mms(ee),mms(nsc),mms(be),mms(is),mms(to),mms(f),mms(g),mms(dp);
		for (ll i=l;i<=r;i++) if (D.fnd(b[i].x)!=D.fnd(b[i].y))
			cn[D.fnd(b[i].y)]|=cn[D.fnd(b[i].x)],D.mrg(b[i].x,b[i].y);
		for (ll i=l;i<=r;i++) to[b[i].x]|=1<<b[i].y,to[b[i].y]|=1<<b[i].x;
		be[0]=1;
		for (ll s=1;s<=U;s++) {
			be[s]=be[s^(s&sc[s&-s])]*ans[s&sc[s&-s]]%P,
			nsc[s]=nsc[s^(s&cn[D.fnd(__lg(s&-s))])]|cn[D.fnd(__lg(s&-s))];
			for (ll i=l;i<=r;i++) ee[s]+=s>>b[i].x&1&&s>>b[i].y&1;
		}
		for (ll i=0;i<n;i++) if (D.fnd(i)==i) {
			for (ll s=cn[i];s;s=(s-1)&cn[i]) nsc[s]=cn[i];
			if (sc[1<<i]!=nsc[1<<i]) for (ll s=cn[i];s;s=(s-1)&cn[i]) is[s]=1;
		}
		for (ll s=1;s<=U;s++) if (is[s]) {
			f[s]=1;
			for (ll t=s;t;t=(t-1)&s) if (t&(s&-s)&&(sc[s^t]&sc[t])==0)
				(g[s]+=P-f[t]*g[s^t]%P*q2[ce(sc[s^t],t)+ce(s^t,sc[t])]%P)%=P;
			for (ll t=s;t;t=(t-1)&s) if ((sc[s^t]&sc[t])==0) (f[s]+=P-g[t]*q2[ce(sc[s^t],t)]%P)%=P;
			(g[s]+=f[s])%=P;
		}
		for (ll s=1;s<=U;s++) if (is[s]) {
			ll cnm=0,t=__lg(s&-s);
			for (ll i=0;i<n;i++) if (nsc[1<<i]==nsc[1<<t]&&(sc[1<<i]&sc[s])==0)
				cnm+=__builtin_popcount(to[i]&s);
			(f[s]*=q2[cnm])%=P;
		}
		for (ll s=1;s<=U;s++) if (is[s]) {
			ll flg=1,t=__lg(s&-s);
			for (ll i=0;i<n;i++) if (nsc[1<<i]==nsc[1<<t]&&(sc[1<<i]&s)==0) { flg=0; break; }
			dp[s]=flg;
		}
		for (ll s=U;s;s--) if (is[s]) {
			for (ll t=(s-1)&s;t;t=(t-1)&s) if ((sc[s^t]&sc[t])==0)
				(dp[s^t]+=dp[s]*(P-q2[ce(sc[s^t],t)])%P*be[t])%=P;
		}
		for (ll s=1;s<=U;s++) if (dp[s]) {
			(dp[s]*=be[s])%=P;
			for (ll t=(s-1)&s;t;t=(t-1)&s) if ((sc[s^t]&sc[t])==0) (dp[t]+=dp[s])%=P;
		}
		for (ll s=1;s<=U;s++) if (is[s]) ans[s]=dp[s]*f[s]%P;
	}
	ll tot=0;
	for (ll s=1;s<=U;s++) (tot+=ans[s])%=P;
	cout<<tot<<"\n";
}
bool ORY; int main() {
	p2[0]=q2[0]=1;
	for (ll i=1;i<M;i++) p2[i]=p2[i-1]*2%P,q2[i]=qp(p2[i]);
	// while (1)
	int t; for (scanf("%lld%d",&type,&t);t--;)
	mian();
	cerr<<"\n"<<abs(&MEM-&ORY)/1048576<<"MB";
	return 0;
}
```

难度相比去年重塑时光的话算是全面超级加强了吧。重塑时光也就涉及到了 DAG 计数的套路，以及一个不加也能过的插值优化。但这题包含了 DAG 计数，SCC 计数，MST 计数等等各种奇怪但经典的东西，而且应用形式都比较灵活，细节非常多，一旦里面有任何一个不熟悉就很难获得较高的分数。

~~所以也很难想象明年 D2T2 如果还要出状压图计数的话要放什么东西了。~~

总之用这题来检验一下自己对图计数的理解我觉得是非常好的。我检验过了，我不理解。

25-5-6 upd：修改了一些用词，希望能明白一些。

---

## 作者：20_200 (赞：10)

一年前，你首次亮相，我满怀悲痛的走出考场。

一年的岁月磨灭了那悲痛的痕迹，我时不时幻想着一年后的那天能够重塑时光。

而当这一天真的来临，你竟然再次出现，虽经历岁月侵蚀，但核心却仍然保持不变。

我却只能在无尽的代码中苦苦挣扎，面对着即便重塑时光依旧无法改变的必死结局，追忆这逝去的青春岁月。

**题意**

给定一个 $n$ 个点 $m$ 条边的带权无向图，现在每条边对应的正反向边都有 $\frac{1}{2}$ 的概率被删除，求删边后的有向图存在最小外向生成树且其权值和等于原图最小生成树的概率。

**分析**

因为总方案数有限，所以直接把概率转计数，最后再除以 $2^{2m}$，~~虽然直接算概率能省去很多系数但是概率全是分数debug过于困难~~。

定义 $A/B$ 表示集合 $A$ 去掉集合 $A\cap B$ 得到的集合。

定义一个有向图弱连通当且仅当将其所有边看作无向图后连通，有向图的 MST 为其最小外向生成树。

定义一个有向图**合法**当且仅当将其存在 MST，可以发现这等价于**将其缩点后只有一个入度为零的强连通分量**。接下来我们只讨论合法的有向图。

定义合法有向图的**关键点集**为可以作为MST的根的点集，显然该点集强连通。

显然删边后的有向图 MST 的权值和大于等于原图 MST，而根据 Kruskal 算法的原理，两者相等的**必要条件**是对任意 $i\in[1,m]$，加入所有边权 $\le i$ 的边，得到的图的弱连通性与原图加入所有边权 $\le i$ 的边后的图相同，且每个弱连通分量都合法。

我们对每个 $i$ 的每个弱连通分量分别考虑（注意因为原图的边是给定的，所以这里的弱连通分量是固定的），我们需要选择一些该弱连通分量中边权为 $i$ 的边，把若干个由边权 $<i$ 的边组成的合法弱连通分量合并成一个。

对于一个边权-弱连通分量 $k$，设其点集为 $A_k$，对应的边权为 $v_k$，其合并集为 $C_k$，即 $A_k=\cup_{x\in C_k}A_x$ 的，该连通分量中权值等于 $v_k$ 的边集为 $E_k$。现在只考虑 $E_k$ 中的边，定义两端点不在同一个 $A_x$，且**终点**为某个 $A_x$ 的关键点的边称为**关键边**。

由于在任意一个 MST 中，每个 $A_x$ 的入度不超过一，因此，**最终的 MST 只可能包含关键边**。那么对于上面所说的必要条件，可以发现，**若只考虑关键边，则上述条件变为充要条件**，因为对每个边权-弱连通分量 $k$，从关键点出发就可以充分利用边权 $\le v_k$ 的所有边，而关键边都会连接到关键点，若仅靠关键边就能保持弱连通和合法性，则可以选择和原图数量相同的边权为 $v_k$ 的边并充分利用边权小于 $v_k$ 的边，使得 $A_k$ 的 MST 等于原图。

而一条边是否关键只与其对应 $A_x$ 的关键点集有。所以，对每个 $k$，将 $x\in C_k$ 的每个 $A_x$ 看作一个点，这些点和关键边组成一个有向图，**则选择的关键边应使得该图合法，而 $A_k$ 的关键点集为该图的关键点集对应的 $A_x$ 对应的关键点集的并集**。

那么现在这题的思路就很明确了，状态只需要记录关键点集，然后由于关键点集的强连通性，还需要做强连通计数。

**DP**

这个部分基本是和重塑时光一脉相承的东西，核心思想就是容斥入度为零的点（强联通分量）。

考虑设计 dp 状态，设 $\text{dp}_{k,S}$ 表示选择两端点都在 $A_k$ 中的边使得 $A_k$ 合法且其关键点集是 $S$ 的方案数。

下面计算某一个 $k$ 的 dp，以下讨论的 $S$ 为 $A_k$ 的子集。

定义 $cnt(S,T)=2^{\sum[x\in S][y\in T][(x,y)\in E_k]}$。

设 $u_S$ 表示所有 $S\cap A_x\neq\varnothing$ 的 $x$ 构成的集合，$d_S=\cup_{x\in u_S}A_x$。

设 $f_S$ 表示对于 $x\in u_S$，$A_x$ 的关键点集为 $S\cap A_x$，用关键边将 $u_S$ 合并成一个强连通分量的方案数。

设 $g_S=\sum_{T_1,T_2,\dots,T_x}(-1)^x\prod_{i=1}^xf_{T_i}$，其中 $T_1,T_2,\dots,T_x$ 是 $S$ 的**无序划分**，且对于 $i\neq j$，$u_{T_i}\cap u_{T_j}=\varnothing$，即 $S$ 带容斥系数的划分的 $f$ 的贡献和。

$f_S$ 的转移考虑容斥，$u_S$ 强连通相当于所有连边方案减去不是强连通的情况，即有多个入度为零的强连通分量或者有一个入度为零且不等于 $u_S$ 的强连通分量，那么我们钦定有 $k$ 个入度为零强连通分量并确定关键点集，剩下点的关键边随便连，这里容斥系数为 $-(-1)^{k-1}=(-1)^k$，可以直接用 $g$，最后减去 $k=1$ 且该强连通分量等于 $u_S$ 的情况，得到

$$f_S=cnt(d_S,S)-f_S+\sum_{T\subseteq S,T\neq\varnothing,u_T\cap u_{S/T}=\varnothing}g_T\times cnt(d_T,S/T)$$

$g_S$ 的转移，由于其无序性，考虑每次划分出一个包含 $S$ 中编号最小的点（即 lowbit）的点集 $T$ 作为一个强连通分量并确定关键点集，乘以 $-1$ 的容斥系数，得到

$$g_S=-\sum_{T\subseteq S,T\neq\varnothing,u_T\cap u_{S/T}=\varnothing,\text{lowbit(S)}\in T}f_T\times g_{S/T}$$

注意这里 $f$ 和 $g$ 相互转移，要**先转移** $g_S$，由于 $f_S$ 还没转移，此时得到的 $g_S$ 刚好没算上 $f_S$，可以用来转移 $f_S$，这样 $f_S$ 的转移里面就不用减去自己，在 $f_S$ 转移完后再把 $g_S$ 减去 $f_S$ 即可。

设 $h_T$ 为对所有 $C_k/u_T$ 中的 $A_x$ 选择关键点集和关键边，还有选择非关键边和两端点都在 $A_k$ 中且权值 $\lt v_k$ 的边的方案数，考虑所有 $A_x$ 的关键点集的并为 $S$，则

$$h_T=\sum_{T\subseteq S\subseteq A_k,u_S=C_k}cnt(d_S,d_S/S)\times cnt(d_S,S/T)\prod_{x\in C_k}\text{dp}_{x,S\cap A_x}$$

$\text{dp}_{k,T}$ 的转移，这里 $T$ 作为 $A_k$ 的关键点集，是缩点后唯一的入度为零的强连通分量，那么仍然考虑容斥，钦定除了 $T$ 外还有一些入度为零的强连通分量（也可能没有）并确定关键点集，$T$ 和它们的并为 $S$，发现还是可以用 $g$ 自带的容斥系数，再乘上 $S$ 外的部分和非关键边的方案数 $h$，那么得到 

$$\text{dp}_{k,T}=\sum_{T\subseteq S\subseteq A_k,u_T\cap u_{S/T}=\varnothing}f_T\times g_{S/T}\times h_S$$

初始状态是 $g_\varnothing=h_\varnothing=1$，对于每个点 $x$，若只有它一个点的集合为 $A_k$，则 $\text{dp}_{k,\{x\}}=1$。

答案就是 $\{1,2,\dots,n\}$ 对应的 $k$（注意不一定是最大的）的所有 dp 值求和 $\times2^{-2m}$。

注意对每个 $k$ 都需要特判掉 $E_k$ 中两端点都在同一个 $A_x$ 的边，最后算概率除的时候也不能除这些边。

还要注意转移的条件。

复杂度瓶颈在于 cnt，直接算是要 $O(n^2)$ 的，而将每个点的出边用二进制数存就成 $O(n)$ 了，可以过。后来看别的题解好像可以做到 $O(1)$，但是我懒得改了。

时间复杂度 $O(T3^nn)$。

**代码**

目前写过的最长非 NTT 计数题，细节巨多，非常难调。

代码经过优化，截至提交时是最短解（2.03KB），变量名和上面说的一样，可以辅助理解一些细节。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define pii pair<ll,ll>
#define ve vector<ll>
#define fi first
#define se second
#define pb push_back
#define mid (l+r>>1)
#define lx (x<<1)
#define rx (x<<1|1)
using namespace std;
const ll N=502,M=(1<<15)+2,P=1e9+7;
ll T,n,m,a[N],e[N],p[N],v[N];
ll d[M],f[M],g[M],h[M],dp[N][M];
vector<pii>b[N];
vector<ll>c[N];
ll find(ll x){return x==p[x]?x:p[x]=find(p[x]);}
ll cnt(ll s,ll t){
	ll x=1;
	for(ll i=0;i<n;i++)
		if(s>>i&1)(x*=1<<__builtin_popcount(t&e[i]))%=P;
	return x;
}
void DP(ll k){
	g[0]=h[0]=1;
	for(ll s=1;s<(1<<n);s++){
		f[s]=g[s]=h[s]=d[s]=0;
		if((s&a[k])!=s)continue;
		ll x=1,y;
		for(ll i:c[k])
			if(s&a[i])d[s]|=a[i],(x*=dp[i][s&a[i]])%=P;
		(x*=cnt(d[s],d[s]^s))%=P;
		for(ll t=s;t;t=(t-1)&s)
			if(!(d[t]&d[s^t])){
				y=cnt(d[s],s^t),(f[s]+=g[t]*y)%=P;
				if((t|(s&-s))==t)(g[s]-=f[t]*g[s^t])%=P;
				if(d[s]==a[k])(h[t]+=x*y)%=P;
			}
		(f[s]+=g[s]+cnt(d[s],s))%=P;
		(g[s]-=f[s])%=P;
	}
	for(ll s=1;s<(1<<n);s++)
		for(ll t=s;d[s]&&t;t=(t-1)&s)
			if(!(d[t]&d[s^t]))(dp[k][t]+=f[t]*g[s^t]%P*h[s])%=P;
}
void slv(){
	cin>>n>>m;
	ll k=0,ans=0,u=0,w=1;
	memset(dp,0,sizeof dp);
	for(ll i=1;i<=m;i++)b[i].clear();
	for(ll i=1,x,y,z;i<=m;i++)
		cin>>x>>y>>z,b[z].pb({x,y});
	for(ll i=0;i<n;i++)
		a[++k]=1<<i,dp[k][a[k]]=1,
		p[k]=k,v[k]=0,c[k].clear();
	for(ll i=1;i<=m;i++){
		for(ll j=0;j<n;j++)e[j]=0;
		for(pii j:b[i])
			if(find(j.fi)!=find(j.se))
				e[j.fi-1]|=1<<(j.se-1),e[j.se-1]|=1<<(j.fi-1),
				(w*=(P+1)/4)%=P;
		for(pii j:b[i]){
			ll x=find(j.fi),y=find(j.se);
			if(x!=y){
				if(v[x]<v[y])swap(x,y);
				if(v[x]==i){
					if(v[y]==i)
						for(ll j:c[y])c[x].pb(j);
					else c[x].pb(y);
					p[y]=x,a[x]|=a[y],v[y]=0;
				}
				else
					p[x]=p[y]=++k,p[k]=k,v[k]=i,
					a[k]=a[x]|a[y],c[k].clear(),
					c[k].pb(x),c[k].pb(y);
			}
		}
		for(ll j=1;j<=k;j++)
			if(v[j]==i)DP(j),u=j;
	}
	for(ll s=1;s<(1<<n);s++)(ans+=dp[u][s])%=P;
	cout<<(ans*w+P*P)%P<<'\n';
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>T>>T;
	while(T--)slv();
	return 0;
}
```

---

## 作者：Moeebius (赞：7)

> 感谢 cxy 教会我做这道题。

## C 性质

由于所有边边权都一样，所以只要存在一棵外向生成树就合法。

首先一个自然的观察是，所有合法的根节点一定在一个强连通块中。这启发我们考虑缩点，不难发现合法等价于缩点后入度为 $0$ 的强连通块只有一个。

首先使用[主旋律](https://www.luogu.com.cn/problem/P11714)的做法算出每个集合 $S$ 强连通的概率 $f_S$。接下来，一个最具可拓展性的做法是，使用容斥算出 $S$ 恰好是这个缩点后入度为 $0$ 的强连通块的概率。

具体来说，我们枚举一个集合 $T\supseteq S$ 表示钦定 $T$ 内的 SCC 没有入度，容斥系数是将 $T \setminus S$ 分成 $c$ 个 SCC 的概率乘上 $(-1)^c$ 再求和，注意到这同时也是主旋律中的容斥系数 $g_{T \setminus S}$。除此以外需要乘上的概率还有 $S$ 和 $T \setminus S$ 之间不能有边，以及 $U \setminus T$ 不能有连向 $T$ 的边。精细实现可以做到 $O(3^n + n2^n)$。

代码可以见[这里](https://www.luogu.me/paste/gd6w4dye#)。

## 正解

不难发现，对于一张无向图而言，任取阈值 $B \in \N$，对于其所有最小生成树（下简称 MST）而言，保留树上中 $\le B$ 的边得到的图连通性都是相同的。（两张图 $G_1=(V,E_1),G_2=(V,E_2)$ 连通性相同，当且仅当 $\forall u,v \in V$，$u,v$ 在 $G_1$ 中连通等价于其在 $G_2$ 中连通。）

考虑将这一点推广到最小外向生成树（下简称 MOST）上。考虑加入所有边权为 $B$ 的边，这会使得若干个弱连通块被合并成一个（由于 MST 的性质我们已经知道是哪些弱联通块了）。每个合并前的弱联通块都有一些点可以作为其 MOST 的根，不妨称这些点构成该弱联通块的根集。把每个弱联通块看成一个“大点”，相当于边权为 $B$ 的所有 **指向某个根集** 的边中存在一棵外向生成树，新的根集即为所有 _可以成为外向生成树根_ 的“大点”对应的根集的并。

这个形式已经很像 C 性质了。不妨记 $ans_S$ 表示考虑边权 $< B$ 的所有边，$S$ 为其所在连通块根集的概率。考虑如何求出加上边权为 $B$ 的边后的答案 $ans'$。

我们只需要修改 C 性质中连边的系数即可。

- 计算 $f_S$ 和 $ans_S$ 时，我们需要知道某个“大点”外没有连向其根集的边的概率。
- 计算 $g_S$ 时，我们需要知道两个“大点”之间没有互相连边的概率；具体地，两个“大点”对应的根集之间不能有边，且一个“大点”内**不在根集中**的点不能连向另一个“大点”**根集中**的点。

依然是先计算出 $f$ 和 $g$，再使用一次容斥算出 $ans'$。这样合并若干个大小总和为 $n$ 的连通块的复杂度是 $O(n3^n+n2^n)$ 的（精细实现大概可以在 $3^n$ 上不带 $n$，但是笔者懒了）。不难发现总复杂度也是这个。

[代码](https://www.luogu.me/paste/8qf0s9yl#)，常数比较大，在洛谷上可能要 `target popcnt` 之类的才能过。

---

## 作者：_Eriri_ (赞：6)

做过最难的题。

[[清华集训 2014] 主旋律](https://www.luogu.com.cn/problem/P11714) 是本题绝对的前置，默认读者已经掌握。
## Part 0


将原图 $G$ 的一条无向边视作两条有向边后，问题变为：等概率在有向图 $G$ 的生成子图中选择一个作为 $G'$，求 $G'$ 最小外向生成树边权和等于 $G$ 最小生成树边权和的概率。


将概率转为方案进行计数，答案为合法的生成子图数去除以 $4^m$。

约定：

$Edge(S,T)=\sum_{u\in S}\sum_{v\in T} [(u,v)\in G]$。

$U$ 表示全集。


## Part 1 C 性质
从特殊性质开始入手。

考虑 $w_i=1$ 的情况。在这个情况下只要 $G$ 的生成子图存在至少一棵外向生成树就合法。把有向图缩点后考虑会比较好，尝试找出一个有向图存在一棵外向生成树在缩点图上的对应条件。

这个对应条件非常显然：如果一个有向图缩点后只有一个入度为 $0$ 的大点，那它存在至少一棵外向生成树。

问题转化为：$G$ 的生成子图计数，满足缩点后入度为 $0$ 的点恰好为 $1$ 个。

这个问题和[[清华集训 2014] 主旋律](https://www.luogu.com.cn/problem/P11714) 非常类似，主旋律中已经求得了 $g(S,i)$ 表示对于点集 $S$ 的导出子图，恰好缩成 $i$ 个互相之间没有边的大点的生成子图数。

考虑枚举 $S$，让入度为 $0$ 的大点**恰好**为 $S$ 缩起来。需要的是除 $S$ 外入度为 $0$ 的大点**恰好**为 $0$ 个的方案数。用 $f(S)$ 表示。直接写反演式：

$$f(S)=\sum_{S\subseteq T} \sum_{i=0}^n (-1)^i g(T-S,i)2^{Edge(T,U-T)+Edge(U-T,U-T)}$$

一个普通的二项式反演：枚举 $S$ 之外的点基，用 $g$ 表示，剩下点基到外部的边任意连。要求恰好为 $0$ 那容斥系数为 $\binom{i}{0}(-1)^{i-0}=(-1)^i$。

在主旋律里大家都是把 $(-1)^i$ 算到值域里，因此不需要记 $i$。为了清晰我把 $i$ 拆了出来，实际写的时候肯定不用。

最后总合法生成子图数是 $\sum_{S}f(S)g(S,1)$。

把 $S$ 缩成一个大点的方案数别忘了。

## Part2 正解


现在这个问题与 MST 相关。寻常的思路是将 C 性质的做法扩展到 ``Kruskal``上。

一个重要的发现：

对于任意 $w$，对于图 $G$ 的所有最小生成树，保留边权 $\le w$ 的边后连通性完全一样。

证明考虑 ``Kruskal`` 的过程，边权相同的边无论谁排在前面都不会影响连通性。

而对于 $G'$ 的一棵最小外向生成树，它一定对应 $G$ 的一棵最小生成树。也就是说，想要 $G'$ 合法，它在仅保留边权 $\le w$ 的边后，每个连通块和 $G$ 应该是相同的点集，并且每个连通块中都需要有一棵外向生成树的边权和等于 $G$ 中这个连通块的最小生成树边权和，把最小外向生成树的根称为合法根。而加入边权 $=w+1$ 的边相当于合并若干个连通块。

考虑按边权从小到大依次加边。设 $f(S)$ 表示对于当前图， $S$ 所处的连通块，有多少个生成子图使 $S$ 中的点**恰好**为 $S$ 所处连通块的合法根。$S$ 中的点必须来自同一个连通块。

现在到了 $w \to w+1$ 的过程，任务是算出新的 $f(S)$。

不妨设有 $k$ 个连通块要合并到一起。先枚举每个连通块的合法根集合 $S_1,S_2\ ...\ S_k$。不难发现新的合法根一定是 $\cup_{i=1}^k S_i$ 的子集。因为即使存在一个 $p \notin \cup_{i=1}^k S_i$ 可以作为一个外向生成树的根，由于它要走 $\ge 2$ 条边权为 $w+1$ 的边才能回到自己的原连通块，并且到其他任意连通块的 $w+1$ 边都可以被它所属的连通块的合法根走到，$p$ 一定做不到边权和最小。那么只要一条边的出点不在 $\cup S_i$ 中或它的两端在同一连通块内，它的存在与否就不对转移造成影响。只用剩下的边转移，最后乘上 $2^{cnt} \prod_{i=1}^k f(S_i)$，$cnt$ 是不造成影响的边数（这里还是把一条无向边拆成两条有向边）。连通块内部方案别忘。

将连通块视作点，如果出点在合法根集合内则出边，跑 C 性质即可，最后乘系数。设最后恰好为点基的大点集合为 $P$。新的合法根集合就是 $\cup_{i\in P}S_i$ 了。

最终答案：$Ans=\frac{\sum_S f(S)}{4^m}$。

因为我加的有向边，$Edge(S,T)$ 不能 $O(1)$ 求。时间复杂度 $O(n 3^n)$。纯 C 性质跑满。

其实我也胡了一个 $O(3^n)$。然而没写。

代码（最好别读）：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=15;
const int mod=1e9+7;
int n,m;
int qpow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
struct edge{int x,y;};
vector<edge>ked[N*N];
int f[1<<N],con[N];
int vis[N],pos[N],pc,bel[N],dy[N];
int fa[N];
int getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void Union(int x,int y){int bx=getfa(x),by=getfa(y);fa[bx]=by;}
int lowbit(int x){return x&(-x);}
int g[1<<N],h[1<<N],nh[1<<N];
int Ed[N][N],p2[N*N];
int sum[N][1<<N]; 
int bit[1<<N][N],cnt[1<<N],inn[1<<N];
int Edge(int st1,int st2,int len){
	int res=0;
	for(int i=0;i<cnt[st1];i++)res+=sum[bit[st1][i]][st2];
	return res;
}
int main(){
	int c,T;
	scanf("%d%d",&c,&T);
	while(T--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++)ked[i].clear();
		for(int i=1;i<=m;i++){
			int x,y,w;
			scanf("%d%d%d",&x,&y,&w);
			--x,--y;
			ked[w].push_back({x,y});
		}
		p2[0]=1;
		for(int i=1;i<=m*2;i++)p2[i]=1ll*p2[i-1]*2%mod;
		for(int i=0;i<n;i++)con[i]=1<<i,bel[i]=fa[i]=i,h[1<<i]=1;
		for(int w=1;w<=m;w++){
			for(int j=0;j<ked[w].size();j++){
				int x=ked[w][j].x,y=ked[w][j].y;
				Union(x,y);
			}
			for(int st=0;st<(1<<n);st++)nh[st]=0;
			for(int i=0;i<n;i++){
				if(getfa(i)==i){
					pc=0;
					int ttl=0;
					for(int j=0;j<n;j++)if(getfa(j)==i && !vis[bel[j]])vis[bel[j]]=1,pos[pc]=bel[j],dy[bel[j]]=pc,++pc,ttl|=con[bel[j]];
					//枚举根状态
					for(int st=ttl;st;st=(st-1)&ttl){
						int xs=1;
						for(int j=0;j<pc;j++)xs=1ll*xs*h[st&con[pos[j]]]%mod;	
						if(!xs)continue; 
						for(int j=0;j<ked[w].size();j++){
							int x=ked[w][j].x,y=ked[w][j].y;
							if(getfa(x)!=i)continue;
							if(bel[x]==bel[y]){
								xs=1ll*xs*4%mod;
								continue;
							}
							if(st&(1<<y))Ed[dy[bel[x]]][dy[bel[y]]]++;
							else xs=1ll*xs*2%mod;
							
							if(st&(1<<x))Ed[dy[bel[y]]][dy[bel[x]]]++;
							else xs=1ll*xs*2%mod;
						}
						for(int j=0;j<pc;j++)
							for(int st2=0;st2<(1<<pc);st2++){
								sum[j][st2]=0;
								for(int k=0;k<pc;k++)if(st2>>k&1)sum[j][st2]+=Ed[j][k];
							}					
						for(int st2=0;st2<(1<<pc);st2++){
							cnt[st2]=0;
							for(int k=0;k<pc;k++)if(st2>>k&1)bit[st2][cnt[st2]++]=k;
							inn[st2]=Edge(st2,st2,pc);
						}						
						//主旋律启动
						for(int st2=0;st2<(1<<pc);st2++)g[st2]=0;
						g[0]=1;	
						for(int st2=1;st2<(1<<pc);st2++){
							f[st2]=0;
							for(int sst=st2;sst;sst=(sst-1)&st2){
								if(lowbit(st2)==lowbit(sst))
									g[st2]=(g[st2]-1ll*f[sst]*g[st2^sst]%mod+mod)%mod;
							}
							f[st2]=p2[Edge(st2,st2,pc)];
							for(int sst=st2;sst;sst=(sst-1)&st2){
								int v=p2[Edge(sst,st2^sst,pc)+inn[st2^sst]];
								f[st2]=(f[st2]+1ll*v*g[sst])%mod;
							}	
							g[st2]=(g[st2]-f[st2]+mod)%mod;
						} 
						//反演：
						for(int sst=1;sst<(1<<pc);sst++){
							int nst=0;
							for(int j=0;j<pc;j++)if(sst>>j&1)nst|=(st&con[pos[j]]);
							int v=0;
							int bst=(1<<pc)-1-sst;
							while(1){
								int cst=bst|sst;
								int x=1ll*g[bst]*p2[Edge(cst,(1<<pc)-1-cst,pc)+inn[(1<<pc)-1-cst]]%mod;					
								v=(v+x)%mod;
								if(!bst)break;	
								bst=(bst-1)&((1<<pc)-1-sst);					
							}
							nh[nst]=(nh[nst]+1ll*xs*v%mod*f[sst])%mod;
						} 
						for(int j=0;j<pc;j++)
							for(int k=0;k<pc;k++)Ed[j][k]=0;
					} 
					memset(vis,0,sizeof(vis));
				}
			}
			for(int i=0;i<n;i++)con[i]=0;
			for(int i=0;i<n;i++)bel[i]=getfa(i),con[bel[i]]|=(1<<i);
			for(int st=0;st<(1<<n);st++)h[st]=nh[st];
		}
		int ans=0;
		for(int st=0;st<(1<<n);st++)ans=(ans+h[st])%mod;
		cout<<1ll*ans*qpow(qpow(4,m),mod-2)%mod<<'\n';
	}
	
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：6)

### 性质 C：对存在外向树进行计数

对于 SCC 缩点后要求形成一张从根节点可达任意大点的 DAG，事实上只需要对缩点后的 $0$ 入度点容斥，令其恰好只有 $1$ 个即可，这是充分必要的。

但是我们要先考虑内部缩点的方案数怎么计算，其实就是[【清华集训 2014】主旋律](https://uoj.ac/problem/37) 这个题：我们希望求出 $f_S$ 表示 $S$ 点集内部边的概率使得 $S$ 构成强连通图。进行容斥，用总数减去形成至少两个 SCC 的情况。可以钦定 $0$ 入度大点。对于一个 $S$ 你可以枚举 $T\subseteq S,S\ne T$，钦定 $T$ 是缩点后图上的一个子集，并且 $T$ 是钦定的图上 $0$ 入度 SCC 的并集。那么预处理一个 $g_S$ 表示将 $S$ 划分为若干孤立 SCC 的贡献，容斥系数和是 $(-1)^{\text{SCC-count}}$。自然是容易处理的。这一部分的时间复杂度是 $\mathcal O(3^nn)$。


回来做性质 C，我们钦定有 $k$ 个大点是零入度的，不难推导出容斥系数是 $coef_k=(-1)^{k+1}k$，因为我们要求 $f(k)=\sum_{i=1}^k\binom{k}{i}coef_i=[k=1]$。那么令 $h_{S,i}$ 表示 $S$ 子集被拆为 $i$ 个孤立 SCC 的权值和，定义一组划分方案的权值是 $\prod f_{S_i}$，这是容易 $\mathcal O(3^nn)$ 的，求答案就考虑所有 $S,i$ 即可。


其实是完全不必要的，在这个题由于是无向边，所以 $S,T$ 之间的边是容易计算的，也就是 $|E(S\cup T)|-|E(S)|-|E(T)|$，对于所有 $g_S$ 算贡献就是对的，$h_{S,i}$ 没有必要。这样复杂度可以做到 $\mathcal O(3^n)$。

### 一般情形

进一步拓展这个做法，回顾 MST 的求法，其中一种是按照边权从小到大，需要动态维护连通性。我们考虑 kruskal 算法对边权进行分层。假设当前考虑到 $w=x$ 的所有边，那么 $w<x$ 的所有边的弱连通块就是完全确定的，而我们要求用 $w=x$ 的边来进行连接。不难注意到对于当前的弱连通块后缩点的 DAG 一定满足存在一个大点可以抵达所有剩余的大点。我们加入 $w=x$ 的要求是同样的。



因此可以设计：$h_S$ 表示对于这个确定的弱连通而言，$S$ 作为缩点后 DAG 所谓的根的贡献。接下来做性质 C，假设要合并的是连通块 $P_1,P_2,\cdots,P_k$，那么此时你依然考虑对 $0$ 入度点进行容斥，只不过我们是从 $P_i$ 中选取子集 $S_i$，然后考虑这些集合的并 $T$，我们相当于对 $T$ 内部进行划分，要求划分出来的贡献是 $h$ 的乘积带上 $(-1)^{cnt}$。$f,g$ 是容易求的，$h$ 需要对所有 $S$ 计算所有 $T\subseteq S$ 的贡献。然后对于这个跑性质 C 就是正确的。做一组的时间复杂度是 $\mathcal O(3^n+2^nn^2)$，其实所有阶段求解的复杂度求和的复杂度也是这个。


### 参考代码

[提交记录。](https://uoj.ac/submission/743684)

---

## 作者：xzf_200906 (赞：5)

upd on 2025.03.08：修改了一处笔误并补充了一个内容。

此篇文章是对[另一篇题解](https://www.luogu.com.cn/article/h03ia3tt)从性质 C 扩展到正解的“细枝末节的地方”的补充，下文将默认读者看过另一篇题解。

在看完那篇题解之后，如果读者已经知晓此题的解法，那么请退出此文章，因为这篇文章已经没用了。如果读者还不清楚性质 C 怎么做或者不知道如何判定一张图合法，那么请回去再仔细阅读。如果读者已经知晓上述内容，但不知道如何将性质 C 的解法套用到正解上（即那篇文章的倒数第二段不清楚），那么请往下看。

枚举边权，将所有边权相同的边的两端所在的连通块合并。注意，在不加说明的情况下，下面所称的连通块为合并之前的连通块。假设将 $S_1,S_2,\cdots,S_k$ 合并成了一个，我们已经求出了原来的每个连通块中的每一个集合 $s$ 成为该连通块的合法点集的概率 $res_s$，考虑如何通过它来求出新的 $res$。类比性质 C，$s$ 合法当且仅当：
1. 对于 $s$ 中的每个元素，其在原来的连通块中合法。
2. $s$ 中的点强连通。
3. 若将每个连通块 $S_i$ 看作一个点，将在不同的连通块之间且终点合法的边加入后，每个和 $s$ 有交的连通块 $S_i$ 均可以到达其它所有点。
4. 按照条件 3 处理后，每个和 $s$ 不交的连通块 $S_i$ 均不完全能到达其它点。

下文将分部分讨论上述条件。
## Part 2
大体和 C 性质的部分相同，但由于我们已知 $s$ 中的所有点合法，那么对于任意的 $u\in s$，其可以到达其所在连通块的所有点。在 DP 的过程中我们会对缩点后有多个点的 DAG 进行计数。那么这张 DAG 一定满足以下条件：
+ 由于在原来的连通块中的合法点集组成一个强连通分量，故对于 DAG 中的任意两个点，它们所代表的强连通分量所在的连通块不交。
+ 对于其中的任意两个强连通分量 $u,v$，记 $ext_u$ 表示和 $u$ 中任意一个点在同一个连通块的点组成的集合，若不存在边 $u\to v$，则原图中不存在边 $p\to q$ 满足 $p\in ext_u,q\in v$。

记 $ok(s,t)=[ext_s\cap ext_t=\emptyset]$，$ans_s$ 为 $s$ **在所有点在原来合法的前提下**为强连通图的概率，则有如下转移方程：
$$ans_s=1-(g_s-ans_s)-\sum_{\emptyset \neq t\sub s}ok(s\setminus t,t) g_t2^{-cross(ext_{s\setminus t},t)}$$
$$g_s=ans_s-\sum_{lowbit(s)\in t\subseteq s}ok(s\setminus t,t)ans_tg_{s\setminus t}2^{-(cross(ext_{s\setminus t},t)+cross(ext_{t},s\setminus t))}$$
解释一下上面的式子，由于需要保证一个连通块不涉及到两个强连通分量，则需要计算 $ok$ 函数。在计算 $g_s$ 时需要在集合 $s\setminus t$ 的基础上并上 $t$，且 $t$ 和之前的所有点都没有边，则有 $cross(ext_{s\setminus t},t)+cross(ext_{t},s\setminus t)$ 条边不能存在。而在计算 $ans_s$ 的时候需要保证 $s\setminus t$ 没有连向 $t$ 的边，故有 $cross(ext_{s\setminus t},t)$ 条边不能存在，故有以上转移系数。如果有其它部分不能看懂请看[此题](https://www.luogu.com.cn/problem/P11714)。
## Part 4
最简单的一个，枚举所有和集合无交的连通块，统计起点在该连通块内，终点在 $s$ 中的边的数量。在 $s$ 中的所有点在原来合法的前提下，$s$ 符合该条件当且仅当这些边不存在。设 $cnt_s$ 为这些边的数量，则在该前提下 $s$ 符合该条件的概率为 $2^{-cnt_s}$。
## Part 1&3
类似于性质 C，先考虑一个较为暴力的算法。枚举一个集合 $r$ 并分别计算其符合条件的概率。设 $f_s$ 表示 $s$ 中的点在原来全部为合法点且 $r$ 可以到达所有与 $s$ 有交的连通块的概率。
> Q：为什么要这样设计状态而不是定义为直接从 $r\to s$ 的概率？
>
> A：因为 Part 3 中的点是原来的一整个连通块，如果 $s$ 是指的原图中的点集，那么这样的状态是没意义的。如果 $s$ 指的是可达的连通块组成的集合，那么由于要求每条边的终点在原来合法，这就意味着原来的合法点会影响转移系数，但是我们不可能在每次转移 $f_t\to f_s$ 时都枚举哪些点合法（存疑，如果有人有思路的话请踢我），所以就这样设计状态了。
> 
> 本质上 $f_s$ 实际上记录了两个状态：哪些连通块可达和已经可达的连通块中有哪些点合法，但是由于从后面的信息可以推出前面的信息，所以就只要记录后面的东西。

由于一个连通块以前的合法点现在要么全不合法，要么全合法，故只有 $r\subseteq s$ 且不存在一个连通块同时包含 $r$ 和 $s\setminus r$ 时 $f_s$ 才有意义。则考虑枚举 $t\sub s$，计算 $r$ 只能到达 $t$ 的概率并从总概率中减去。设 $cof_s$ 表示 $s$ 中的点在之前全部为关键点的概率，则：
$$f_s=cof_s-\sum_{r\subseteq t\sub s}ok(t,s\setminus t)f_t2^{-cross(ext_t,s\setminus t)}cof_{s\setminus t}$$
由于我们已经确定了 $t$ 中和其相交的每一个连通块中的合法点，不可以对其再作修改，所以仍然要计算 $ok(t,s\setminus t)$。

但是按上述转移方程暴力计算是不优的，联想到在 C 性质中的优化，上述 DP 本质上相当于建立一张边权为 $-f_t2^{-cross(ext_t,s\setminus t)}cof_{s\setminus t}$ 的边，求每条起点为 $p\supe r$ 且 $ok(r,p\setminus r)=1$，终点为全集的路径经过的边权之积乘上 $cof_p$ 的和。考虑倒着跑 DP，求出每个点到全集的路径权值和，再乘上 $cof_p$，最后再计算 $tf_s=\sum_{t\supe s} ok(s,t\setminus s) f_t$ 即可。

在计算完上述概率后，由于它们之间互相独立，则 $res_s=ans_s\times 2^{-cnt_s}\times tf_s$，最终的答案为 $\sum res_s$。

附一份加上了注释的部分上述题解的代码：
```cpp
int fa[25],bel[2][25],_msk[25],ext[2][1 << 15],con[1 << 15];
//_msk: 连通块的点集
//bel: 上一时刻和这一时刻和该点同连通块的点
//ext: 两时刻该集合同连通块的点
//con：这一时刻集合内部是否为同一连通块
int fnd(int u){
    if(fa[u] == u) return u;
    return fa[u] = fnd(fa[u]);
}

int mrg(int u,int v){
    u = fnd(u);v = fnd(v);
    if(u == v) return 0;
    fa[u] = v;
    return 1;
}

void init(){
    rep(u,0,n - 1) _msk[u] = 0;
    rep(u,0,n - 1) _msk[fnd(u)] |= 1 << u;
    fill(con,con + (1 << n),0);
    rep(u,0,n - 1) bel[1][u] = _msk[fnd(u)];
    con[0] = 1;
    rep(u,0,n - 1){
        for(int S = _msk[u];S;S = (S - 1) & _msk[u]) con[S] = 1;
    }
    rep(S,1,(1 << n) - 1){
        int u = ctz(S);
        ext[1][S] = ext[1][S - (1 << u)] | bel[1][u];
    }
}

int cross(int S,int T){
    assert((S & T) == 0);
    return sum[S + T] - sum[S] - sum[T];
}

int ok(int S,int T){
    //上一时刻两集合所属块是否不交
    return (ext[0][S] & ext[0][T]) == 0;
}
Z f[1 << 15],g[1 << 15],tf[1 << 15];

Z ans[1 << 15],cof[1 << 15],dp[1 << 15];
Z res[1 << 15];
void solve(){
    scanf("%d%d",&n,&m);
    P[0] = 1;
    rep(i,1,n * n) P[i] = P[i - 1] * 2;
    rep(i,0,n * n) iP[i] = Z(1) / P[i];
    fill(msk,msk + n,0);
    rep(i,1,m){
        scanf("%d%d%d",&E[i].u,&E[i].v,&E[i].w);
        E[i].u--;E[i].v--;
    }
    sort(E + 1,E + m + 1,cmp);
    rep(u,0,n - 1) fa[u] = u;
    init();
    rep(S,0,(1 << n) - 1) res[S] = 0;
    rep(i,0,n - 1) res[1 << i] = 1;
    for(int l = 1,r;l <= m;l = r + 1){
        r = l;
        while(r < m && E[r].w == E[r + 1].w) r++;
        rep(u,0,n - 1){
            swap(bel[0][u],bel[1][u]);
            msk[u] = 0;
        }
        rep(S,0,(1 << n) - 1) swap(ext[0][S],ext[1][S]);
        //保存上一时刻的连通性
        int succ = 0;
        rep(i,l,r){
            if(mrg(E[i].u,E[i].v)) succ = 1;
            msk[E[i].u] |= 1 << E[i].v;msk[E[i].v] |= 1 << E[i].u;
        }  
        init();
        //处理这一时刻的连通性
        if(!succ) continue;
        rep(S,1,(1 << n) - 1){
            int u = ctz(S);
            sum[S] = sum[S - (1 << u)] + popcnt(msk[u] & S);
        }
        //处理集合内的边，sum[S] 为两端均在 S 中的边的数量
        int stable = 0;
        rep(u,0,n - 1) if(bel[0][u] == bel[1][u]) stable |= 1 << u;
        rep(S,0,(1 << n) - 1) ans[S] = cof[S] = dp[S] = 0;
        cof[0] = -1;dp[0] = 1;
        //cof[0] 没有影响
        rep(S,1,(1 << n) - 1){
            if(!con[S] || (S & stable)) continue;
            for(int T = S;T;T = (T - 1) & S){
                if(lowbit(S) == lowbit(T) && ok(S - T,T)) cof[S] -= cof[S - T] * ans[T] * iP[cross(ext[0][S - T],T) + cross(ext[0][T],S - T)]; 
            }
            for(int T = S;T;T = (T - 1) & S){
                if(ok(S - T,T)) dp[S] += dp[S - T] * cof[T] * iP[cross(ext[0][S - T],T)];
                //S - T 必须合法，即 dp[S - T]=1，但实测删去不会出问题
            }
            //由于每个连通块只能有一个点，故需特判 ok(S - T,T)
            //若 u,v 包含在 S 中但不是同一个强连通分量，且不存在边 u->v，则不能存在 u->w->v，
            //其中 w 和 u 为同一连通块，且必有 u->w，故有以上转移
            ans[S] = 1 - dp[S];
            cof[S] += ans[S];
            dp[S] += ans[S];
            //dp[S] ∈ {0,1}
        } 
        //ans[S]：S 在每一个连通块只包含一个强连通分量，且缩点后为孤点的概率
        rep(S,0,(1 << n) - 1){
            g[S] = 0;
            if(!con[S] || (S & stable)) continue;
            int ssum = 0;
            rep(u,0,n - 1){
                if((ext[0][S] >> u) & 1) continue;
                if((ext[1][S] >> u) & 1) ssum += popcnt(msk[u] & S);      
            }       
            g[S] = iP[ssum] * ans[S];
            //g[S]：同时满足 Part 2&4 的概率
        }
        cof[0] = 1;
        rep(S,1,(1 << n) - 1){
            int u = ctz(S);
            cof[S] = cof[S - (bel[0][u] & S)] * res[(bel[0][u] & S)];
        }
        //cof与之前的含义不同，为 S 中的点均在之前为关键点的概率
        rep(S,0,(1 << n) - 1){
            f[S] = 0;
            if(!con[S] || (S & stable)) continue;
            int SS = ext[1][S],fail = 0;
            rep(u,0,n - 1) if(((SS >> u) & 1) && (S & bel[0][u]) == 0) fail = 1;
            f[S] = 1 - fail;
        }
        // S 是否包含合并上的每一个连通块
        per(S,(1 << n) - 1,0){
            if(S & stable) continue;
            for(int T = S - lowbit(S);T;T = (T - 1) & S) if(ok(S - T,T)) f[T] -= iP[cross(S - T,ext[0][T])] * f[S] * cof[S - T];
        }
        //统计路径，每次加入一个新的连通块
        rep(S,0,(1 << n) - 1) f[S] *= cof[S];
        //路径的起始点的权值也要乘上去
        rep(S,0,(1 << n) - 1) tf[S] = 0;
        rep(S,0,(1 << n) - 1){
            if((S & stable)) continue;
            for(int T = S;T;T = (T - 1) & S) if(ok(S - T,T)) tf[T] += f[S];
        }
        rep(S,0,(1 << n) - 1) if((S & stable) == 0) res[S] = tf[S] * g[S];
    }
    Z answer = 0;
    rep(S,1,(1 << n) - 1) answer += res[S];
    printf("%d\n",answer.val());
}
```

---

## 作者：Petit_Souris (赞：2)

本题两大难点：

1. 意识到题目中的条件就是缩点后 0 入度 SCC 恰好只有一个；

2. 熟练掌握 DAG 容斥技巧，以及《主旋律》一题的解法；

----------------

观察到 C 性质部分分很多，大概率是完整解法的一个重要部分。首先考虑 C 性质如何解决。

现在所有边权都相等，那么就和最小生成树无关了，只需要有任何一棵外向生成树，图就合法。考虑所有可能成为生成树根的节点，很自然地观察到这些点应当组成一个 SCC，否则无法互相到达。进一步地，这个 SCC 应当是缩点后图中唯一的 $0$ 入度 SCC。因此我们现在转化目标，枚举集合 $S$，计算 $S$ 中点**恰好**组成唯一合法 SCC 的方案数 $h_S$。

发现计算一个点集强连通的方案数是不可避免的。不妨设这个方案数为 $f_S$。这个问题就是《主旋律》，下面回顾一下这个问题的解法。

回忆 DAG 计数的过程：我们用“不断删除所有 $0$ 入度点”的过程来刻画一个 DAG，并使用容斥系数 $(-1)^{k + 1}$ 来处理每次删除的不一定是所有 $0$ 入度点的问题。放到这个问题上同理，我们考虑设 $g_S$ 表示将 $S$ **划分成若干个 $0$ 入度 SCC** 的带权求和，系数为 $(-1)^{k + 1}$。

考虑如何计算 $g_S$，我采用的方法或许和其他题解中略有区别。我们考虑对于 $S$，建立其所有导出子图和关于 $g$ 的带权求和的双射。可以考虑如下等式：

$$ 2^{2e_{S}} = \sum\limits_{T \subseteq S, T\neq \emptyset}2^{2e_{S - T} + E(S - T, T)}g_T $$

其中 $E(S, T)$ 表示两端分别在 $S, T$ 中的无向边数量（两个方向只算一次），$e_S$ 表示 $S$ 内部的无向边数量。$E(S, T)$ 可以用 $e_{S \cup T} - e_{S} - e_{T}$ 计算。

这个等式成立的原因：两边都代表 $S$ 的导出子图数量，右边相当于钦定 $T$ 中均为 $0$ 入度 SCC，剩下的边乱连。

那么移项之后，只需计算所有 $g_T(T\subset S)$ 即可推出 $g_S$。初始化有 $g_{\emptyset} = -1$，这部分时间复杂度为 $\mathcal O(3 ^ n)$。

接下来计算 $f_S$。我们可以考虑用 $g, f$ 之间的递推式解决：

$$g_{S} = \sum\limits_{T \subseteq S, \mathrm{lowbit}(S) \in T}-f_{T}g_{S - T}$$

（$g$ 的意义就是划分成若干个 SCC，互相不连边）

同理移项后可以表示出 $f_{S}$，时间复杂度也是 $\mathcal O(3 ^ n)$。

最后考虑如何计算答案。“恰好”的条件不好处理。考虑先做一步容斥：枚举 $T\supseteq S$，钦定 $T$ 中的点组成了若干个合法 SCC。设 $T - S$ 中的点组成了 $k$ 个 SCC，那么相当于违反了 $k$ 个限制，容斥系数为 $(-1) ^ k$。观察到这个系数就是 $-g_{T - S}$。

对于剩下的边，我们还有：

- $T$ 可以向 $U - T$ 连边；

- $U - T$ 内部可以任意连边。

因此 $T$ 对 $h_S$ 的贡献即为 $-f_{S}g_{T - S}2^{2e_{U - T} + E(U - T, T)}$。

至此 C 性质被解决。时间复杂度 $\mathcal O(3 ^ n)$，[代码](https://www.luogu.me/paste/4dqbu71y)。

------

接下来考虑正解，这里才正式开始和最小生成树的条件对决。

考虑 Kruskal 的过程，我们从小到大合并连通块。显然无论生成树取了什么，在合并完所有 $\le w$ 的边之后得到的连通性应当是相同的。同理，放到有向图上，弱连通性也得是相同的。

那么我们可以这样判断一张图是否合法：

从小到大扫描 $w$，**维护目前每个联通块可能成为根的点集**（下面称为根集）。加入所有权值为 $w$ 的边时，尽可能合并所有的连通块，并更新根集。最后根集非空即为合法。

下面称连通块为大点，我们考虑大点之间的图。

考虑根集应当如何合并：我们称一条边是**关键边**，当且仅当其终点属于根集。那么显然只需要保留所有关键边，这些关键边应当存在大点之间的一棵外向生成树。那么新的根集就是可能成为大点外向树的根对应的大点的根集之并。

可能说起来比较绕。实际上就是找到所有可能成为大图中的树根的点，这些点对应的原连通块，找到这些连通块中可能是根的点，并起来就是新的根。

发现这实际上形如若干个 C 性质的问题并起来。因此类似考虑容斥，大体过程类似，区别在于：

- $g$ 在计算的时候，“不连边”的条件相当于没有关键边，因此需要考虑终点是非根节点的边；

- $g\to f$ 在递推的时候，还需要考虑 $S - T$ 和 $T$ 之间的非关键边；

- 算答案的时候，要考虑 $S$ 和 $T - S$ 间的非关键边，以及 $U - T$ 向 $T$ 连的非关键边。

注意还有可能有无效的边（无论如何都不会在生成树里），给答案全局 $\times 4$ 即可。

时间复杂度还是 $\mathcal O(3 ^ n)$（参考其他题解证明），注意实现细节。[代码](https://www.luogu.me/paste/e2jmf8l6)。

---

## 作者：_Ch1F4N_ (赞：0)

我听说 noi 前写题解可以涨 rp。

首先我们来做下 C 性质，也就是多大的概率图存在一个外向生成树。

先考虑概率转计数。

存在外向生成树这个条件看上去奇怪，考虑对图缩点后其就是图上只存在一个没有入度的 SCC，考虑对这种图计数。

回忆 DAG 容斥的过程，每次剥去缩点后形成的 DAG 上没有入度的一层点的一个子集。

那么只存在一个没有入度的 SCC 实际上就是要求当从 $S$ 转移到全集时，剥去的这一层点只能有一个点。

那么你可以直接做一个背包：记录一个 $dp_{S,i}$ 表示把 $S$ 划分成 $i$ 个 SCC 的方案数，然后以 $S$ 代表整张图缩点形成的 DAG 中没有入度的一层点的一个子集去容斥（实际上剥掉这一层点后剩下的点之间的边可以随便选择是否保存，可以通过对于每个点集预处理其内部的边数量快速计算方案）。求出一个点集是 SCC 的方案就是主旋律那道题。

但是我们希望做到 $O(3^n)$。

不妨设计一个容斥状物，我们想要设计一个系数 $f_i$ 对于任意 $x$ 满足 $\sum_{i=1}^x {x \choose i} f_i = [x=1]$，这里有一个 $x \choose i$ 是因为我们是枚举了被剥去的一层点一个子集。

打个表，$f_i = i \times (-1)^{i+1}$。

那么我们设计一个 dp 对 SCC 做背包，记录权值和与方案数，每次新加入一个 SCC 的时候先让权值和加上方案数再取反，要以方案中 SCC 数量的奇偶性给个不同的初始系数，然后就能做到 $O(3^n)$。

现在来做整个题，根据最小生成树的性质，我们按照边权给边分类，从小到大依次加边，我们需要将若干个弱联通块视作若干个点并和新加入的边放在一起跑一个类似 C 性质的东西（也就是弱连通块当作点后构成的图要存在一个外向生成树），但是问题就来了，当你将弱连通块 $S_1,S_2,\dots,S_k$ 合并的时候，假若弱连通块 $S_i$ 在上一层缩点后那个唯一的入度为 $0$ 的 SCC 是 $C_i$，那么你这一层的边应当满足存在由 $S_i$ 指向 $C_j$ 才代表弱连通块 $i$ 向弱连通块 $j$ 连边。

所以状压的时候不能只记录选了哪些弱连通块，而是应该记录选的弱连通块的 $C$ 并（注意到这个信息可以同时刻画出选了哪些弱连通块），这样就可以顺利转移了。

然而有问题，注意到因为你下一层要用，所以对这一层需要求解唯一的入度为 $0$ 的 SCC 为 $T$ 的方案数，你发现前面的容斥不能胜任这个问题。

考虑直接把那个 DAG 容斥抛弃（这里指算答案的部分，算 SCC 方案还是要的），不妨将点集 $S$ 是唯一的 $0$ 入度 SCC 这个条件拆开，变为：

1. 从 $S$ 出发可以抵达所有点。

2. $S$ 是一个 SCC。

3. 没有 $S$ 外的点可以抵达 $S$ 中的点。

注意到三个条件限制了不同的边，所以实际上限制是独立的，也就是说可以用概率拆开方便计数。所以不妨对于每个 $S$ 求出考虑除了 $S$ 内部所有边是否保留，使得 $S$ 能抵达所有点的方案，再乘上 $S$ 是一个 SCC 的方案数和所有点都不能抵达 $S$ 的概率（这个容易利用预处理出的每个点集内的边数量快速算出来）就是答案。

不妨设 $dp_Z$ 表示考虑除了 $S$ 内部所有边是否保留，使得 $S$ 恰好能抵达 $Z$ 中所有点的方案，转移 dp 考虑容斥掉实际抵达点集不是 $Z$ 的情况，也就是枚举 $T$ 满足 $S \subseteq T \subsetneq Z$，容斥掉 $T$ 为实际可以抵达点集的情况，也就是从 $dp_T$ 转移到 $dp_Z$。

暴力枚举 $S$ 做一遍 dp 是 $O(4^n)$ 的，怎么办。

注意到所有的 dp 形式都是一致的，唯一的区别在于初值，我们实际上的问题是要对于不同初值分别求出最后 $dp_{\{1,2,3,\dots,n\}}$ 的值。

考虑转置整个过程，我们转变 $dp_Z$ 的定义为原先的 $dp_Z$ 对 $dp_{\{1,2,3,\dots,n\}}$ 的贡献系数，倒过来 dp 一遍将其算出来，然后枚举 $S$ 并代入不同的初值就能直接利用新的 dp 数组算出答案。

综上，对于每次将若干个弱连通块 $S_1,S_2,\dots,S_k$ 合并的过程，我们可以在 $O(3^{\sum_{i=1}^k |S_i|})$ 的复杂度内处理，注意到合并过程构成一棵树，当你在树上将大小为 $sz_1,sz_2,sz_3,\dots,sz_l$ 的子树合并的时候，复杂度就是 $O(3^{\sum_{i=1}^l sz_i})$，其的量级大于 $O(\sum_{i=1}^l 3^{sz_i})$，因此可以归纳地证明大小为 $sz$ 的子树处理其子树内所有点的复杂度是 $O(3^{sz})$ 的，所以总复杂度是 $O(3^n)$。

细节比较多。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9+7;
const int maxv = 1<<15;
const int maxn = 15;
const int maxe = 2000;
int _pow[maxe],inv[maxe];
int n,m;
struct info{
    vector<int> sze,scc,f,dp,z;
    //sze 只考虑合并时横跨了原先不同的连通块之间的边
    map<int,int> id;//编号为 i 的点在连通块内的编号
    vector<int> st;//st[S] S 点集中的点原来所属连通块编号的并集
    vector<int> p;//p[S] 原所属连通块编号属于集合 S 的所有点构成的集合
    int N,M;
    int delta;//合并时编号偏移量
    vector<int> l;//l[S] 集合 S 中点在原联通块中的方案数 
    info(){
    	sze.clear(),scc.clear(),f.clear(),dp.clear(),z.clear();
    	id.clear();
    	st.clear(),p.clear();
        N=M=0;
        delta=0;
        l.clear();
    }
    
};
info merge(vector<info> son,vector< pair<int,int> > edge){
    info res=info();
    for(int i=0;i<son.size();i++) res.N+=son[i].N,res.M+=son[i].M;
    res.M+=edge.size();
    //先处理编号
    int pre=0;
    res.st.resize(1<<res.N);
    res.p.resize(1<<son.size());
    for(int i=0;i<son.size();i++){
        son[i].delta=pre;
        for(int j=pre;j<pre+son[i].N;j++) res.st[1<<j]=1<<i,res.p[1<<i]|=(1<<j);
        for(pair<int,int> now:son[i].id) res.id[now.first]=now.second+pre;
        pre+=son[i].N;
    }
    for(int i=0;i<res.N;i++){
        for(int v=0;v<(1<<res.N);v++){
            if((1<<i)&v) res.st[v]|=res.st[v-(1<<i)];
        }
    }
    for(int i=0;i<son.size();i++){
        for(int v=0;v<(1<<son.size());v++){
            if((1<<i)&v) res.p[v]|=res.p[v-(1<<i)];
        }
    }
    res.sze.resize(1<<res.N);
    for(pair<int,int> now:edge){
        res.sze[(1<<res.id[now.first])|(1<<res.id[now.second])]++;
    }
    for(int i=0;i<res.N;i++){
        for(int v=0;v<(1<<res.N);v++){
            if((1<<i)&v) res.sze[v]+=res.sze[v-(1<<i)];
        }
    }
    res.l.resize(1<<res.N);
    for(int v=1;v<(1<<res.N);v++){
    	res.l[v]=1;
    	for(int i=0;i<son.size();i++){
    		if((v&res.p[1<<i])==0) continue;
    		res.l[v]=res.l[v]*son[i].z[(v&res.p[1<<i])>>son[i].delta]%mod;
		}
	}
    res.scc.resize(1<<res.N);
    res.f.resize(1<<res.N);
    for(int v=1;v<(1<<res.N);v++){
        if(__builtin_popcount(res.st[v])==1){
            //只包含一个原连通块中的点就直接从 dp 转移过来
            int id=log2(res.st[v]);
            res.scc[v]=res.f[v]=son[id].z[v>>son[id].delta];
            continue;
        }
        for(int s=(v-1)&v;s;s=(s-1)&v){
            if((res.st[s]&res.st[v-s])==0&&(s&(-s))==(v&(-v))){
                //scc 的核心不能有入边 
                int cnt=2*(res.sze[res.p[res.st[v]]]-res.sze[res.p[res.st[s]]]-res.sze[res.p[res.st[v]]-res.p[res.st[s]]]);
                cnt-=res.sze[s+res.p[res.st[v-s]]]-res.sze[s]-res.sze[res.p[res.st[v-s]]];
				cnt-=res.sze[v-s+res.p[res.st[s]]]-res.sze[v-s]-res.sze[res.p[res.st[s]]];
                res.f[v]=(res.f[v]+res.scc[s]*res.f[v-s]%mod*(mod-1)%mod*_pow[cnt]%mod)%mod;
            }
        }
        res.scc[v]=res.f[v];
        for(int s=(v-1)&v;s;s=(s-1)&v){
            if((res.st[s]&res.st[v-s])==0){
                //所有有向边容斥掉 v-s 代表的连通块中所有点连向 s 的有向边
                //这里需要管一下 v-s 内部的连边方式 
                int cnt=2*(res.sze[res.p[res.st[v]]]-res.sze[res.p[res.st[s]]])-(res.sze[res.p[res.st[v-s]]+s]-res.sze[res.p[res.st[v-s]]]-res.sze[s]);
                res.scc[v]=(res.scc[v]+res.f[s]*_pow[cnt]%mod*res.l[v-s]%mod)%mod;
            }
        }
        res.scc[v]=(_pow[2*res.sze[res.p[res.st[v]]]]*res.l[v]%mod+mod-res.scc[v])%mod;
        res.f[v]=(res.f[v]+res.scc[v])%mod;
    }
    res.z.resize(1<<res.N);
    res.dp.resize(1<<res.N);
    for(int v=1;v<(1<<res.N);v++){
    	if(res.p[res.st[v]]==(1<<res.N)-1) res.dp[v]=1;
	}
    for(int v=(1<<res.N)-1;v>=1;v--){
    	for(int s=(v-1)&v;s;s=(s-1)&v){
            if((res.st[s]&res.st[v-s])==0){
                //除了 s 代表的连通块连向 v-s 的有向边不能选，其他都能选
                int cnt=2*(res.sze[res.p[res.st[v]]]-res.sze[res.p[res.st[s]]]);
                cnt-=res.sze[res.p[res.st[s]]+v-s]-res.sze[res.p[res.st[s]]]-res.sze[v-s];
                res.dp[s]=(res.dp[s]+res.dp[v]*_pow[cnt]%mod*res.l[v-s]%mod*(mod-1)%mod)%mod;
            }
		}
	}
	//利用初值影响算出每个集合开始的答案
	for(int v=(1<<res.N)-1;v>=1;v--){
		res.z[v]=(res.z[v]+res.dp[v])%mod;
        for(int s=(v-1)&v;s;s=(s-1)&v){
            if((res.st[s]&res.st[v-s])==0){
                int cnt=2*(res.sze[res.p[res.st[v]]]-res.sze[res.p[res.st[s]]]);//考虑除了 S 内的边外的所有边
                res.z[s]=(res.z[s]+res.dp[v]*_pow[cnt]%mod*res.l[v-s]%mod);
            }
        }
	} 
	for(int v=1;v<(1<<res.N);v++){
        //U/res.p[res.st[v]] 与 v 之间的连边
		res.z[v]=res.z[v]*inv[res.sze[(1<<res.N)-1-res.p[res.st[v]]+v]-res.sze[(1<<res.N)-1-res.p[res.st[v]]]-res.sze[v]]%mod*res.scc[v]%mod;
    }
    return res;
}
int qpow(int a,int b){
    if(b==0) return 1;
    if(b==1) return a;
    int res=qpow(a,b/2);
    res=res*res%mod;
    if(b&1) res=res*a%mod;
    return res;
}
vector< pair<int,int> > E[maxe];
int fa[20];
int found(int u){
	return fa[u]=(fa[u]==u?u:found(fa[u]));
}
info ans[20];
void work(){
	cin>>n>>m;
	int M=m;
	for(int i=1;i<=n;i++){
		ans[i]=info();
		ans[i].z.resize(1<<1);
		ans[i].N=1,ans[i].z[1<<0]=1,ans[i].id[i]=0;
		fa[i]=i;
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		E[w].push_back(make_pair(u,v)); 
	}
	for(int i=1;i<=m;i++){
		vector<int> vec;
		for(int j=1;j<=n;j++){
			if(found(j)==j) vec.push_back(j);
		}
		vector< pair<int,int> > skip;
		for(pair<int,int> now:E[i]){
			if(found(now.first)==found(now.second)){
				M--;
			}else skip.push_back(now);			
		}
		for(pair<int,int> now:E[i]){
			fa[found(now.first)]=found(now.second);
		}
		swap(E[i],skip);
		for(int x:vec){
			if(found(x)!=x) continue;
			vector<info> son;
			for(int y:vec){
				if(found(y)==found(x)) son.push_back(ans[y]);
			}
			if(son.size()==1) continue;
			vector< pair<int,int> > e;
			for(pair<int,int> now:E[i]){
				if(found(now.first)==found(x)) e.push_back(now);
			}
			ans[x]=merge(son,e);
		}
	}
	int res=0;
	int rt=found(1);
	for(int i=1;i<(1<<n);i++){
		res=(res+ans[rt].z[i])%mod;
	}
	cout<<res*qpow(qpow(4,M),mod-2)%mod<<"\n";
	for(int i=1;i<=m;i++) E[i].clear();
	return ;
}
signed main(){
	_pow[0]=inv[0]=1;
	for(int i=1;i<maxe;i++) _pow[i]=_pow[i-1]*2%mod,inv[i]=inv[i-1]*((mod+1)/2)%mod;
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int c,t;
	cin>>c>>t;
	while(t--) work();
	return 0;
}
/*
0 1
3 3
1 2 1
2 3 2
3 1 2
46875001
*/
```

---


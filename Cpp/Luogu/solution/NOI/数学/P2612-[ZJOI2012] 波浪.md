# [ZJOI2012] 波浪

## 题目描述

阿米巴和小强是好朋友。

阿米巴和小强在大海旁边看海水的波涛。小强第一次面对如此汹涌的海潮，他兴奋地叫个不停。而阿米巴则很淡定，他回想起曾经的那些日子，事业的起伏，情感的挫折……总之今天的风浪和曾经经历的那些风雨比起来，简直什么都不算。

于是，这对好朋友不可避免地产生了分歧。为了论证自己的观点，小强建立了一个模型。他海面抽象成一个 $1$ 到 $N$ 的排列 $P_{1\ldots N}$。定义波动强度等于相邻两项的差的绝对值的和，即：

$$L = | P_2 – P_1 | + | P_3 – P_2 | +\ldots + | P_N – P_{N-1} |$$

给你一个 $N$ 和 $M$，问：随机一个 $1\ldots N$ 的排列，它的波动强度不小于 $M$ 的概率有多大？

答案请保留小数点后 $K$ 位输出，四舍五入。

## 说明/提示

$N = 3$ 的排列有 $6$ 个：$123, 132, 213, 231, 312, 321$；他们的波动强度分别为 $2, 3, 3, 3, 3, 2$。所以，波动强度不小于 $3$ 的概率是 $\frac 46$，即 $0.667$。

你也可以通过下面的代码来验证这个概率：

```cpp
int a[3]={0,1,2},s=0,n=3;
for (int i=0;i<1000000;i++){
random_shuffle(a,a+n);
int t=0;
for (int j=0;j<n-1;j++) t+=abs(a[j+1]-a[j]); 
if (t>=3) s++;
}
printf("%.3f\n",s/1000000.0);
```
### 【数据规模】

对于 $100\%$ 的数据，$0 \leq M \leq 2147483647$。

**请注意本题不存在一个测试点使得 $N,K$ 均达到最大值。**

| 测试点编号 | $N \le$ | $K \leq$|
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $30$ |
| $4 \sim 6$ | $100$ | $3$ |
| $7 \sim 9$ | $100$ | $8$ |
| $10$ | $50$ | $30$ |

## 样例 #1

### 输入

```
3 3 3```

### 输出

```
0.667```

# 题解

## 作者：Itst (赞：17)

**Update On 2020.03.07: 修复了代码中的小问题，修改了部分细节，优化了阅读体验。感谢 [Marser](https://www.luogu.com.cn/user/17930) 指出代码错误。**

---

考虑拆开绝对值计算贡献。对于 $1$ 到 $N$ 的排列，从小到大地将插入它们插入排列中，假设即将插入数 $i$ ，则前 $i-1$ 个数已经被插入到排列中。考虑如何计算 $i$ 的贡献。

不难发现：在最终的排列中，$i$ 的贡献与它和前 $i-1$ 个数和边界的相邻情况有关。如果 $i$ 某一边与边界相邻，会产生 $0$ 的贡献；某一边与小于 $i$ 的数相邻，会产生 $i$ 的贡献；某一边与大于 $i$ 的数相邻，会产生 $-i$ 的贡献。

但是在这里大于 $i$ 的数还没有被插入，所以这里必须要**强制**数 $i$ 与前 $i-1$ 个数和边界的相邻情况才能够在当前阶段计算出 $i$ 对序列价值的贡献。

设 $f_{i,j,k,l}$ 表示放完前 $i$ 个数、数列中存在 $j$ 个连通块（定义连通块为一段极长区间，满足这一段区间任意的相邻的两个数都被强制定为相邻，也就是说在之后的转移中，这一段区间内不能插入数）、数列总价值为 $k-5000$、有 $l$ 个边界已经与某个数强制相邻的方案数。

转移考虑数 $i$ 的相邻情况：

1. 一边与边界相邻，一边不与当前存在的连通块相邻。这会产生额外的一个连通块，并产生 $-i$ 的价值，方案数为 $2-l$；

2. 一边与边界相邻，一边与当前存在的连通块相邻。这不会导致连通块数变化，产生 $i$ 的价值，方案数为 $2-l$ ，要求 $j \neq 0$；

3. 两边均与当前存在的连通块相邻。这会导致两个连通块合并从而连通块数减少 $1$，产生 $2i$ 的价值，方案数为 $j-1$ ，要求 $j \geq 2$；

4. 两边均不与当前存在的连通块相邻。这会产生额外的一个连通块，产生 $-2i$ 的价值，方案数为 $j+1-l$；

5. 一边与当前存在的连通块相邻，另一边不与当前存在的连通块相邻。这不会产生额外的连通块，产生 $0$ 的价值，方案数为 $2j-l$ ，要求 $j \neq 0$。

注意到 $45$ 两种转移的方案数都减去了 $l$，因为对于两端都不与边界相邻的连通块，可以选择左右之一与当前的数相邻，但是有一段与边界相邻的连通块只有另一端可以。

答案是 $\frac{\sum\limits_{i=5000+M}^{10000} f_{N,1,i,2}}{n!}$。

然后这鬼题还要数据类型分治……$K \leq 8$使用long double，$K \leq 30$使用__float128。

还要注意在 DP 的过程中将 $\frac{1}{n!}$ 乘入，也就是当转移完 $f_{i,j,k,l}$ 之后将其乘上 $\frac{1}{i}$，而不是先计算方案数再乘上 $\frac{1}{n!}$。后者在比较刁钻的数据下会掉精度。

```c++
#include<bits/stdc++.h>
//This code is written by Itst
using namespace std;

namespace db{long double dp[2][110][10010][3];}
namespace flt{__float128 dp[2][110][10010][3];}
int N , M , K;

template < class T >

void out(T ans){
        if(ans + 1e-14 >= 1){cout << "1." << string(K,'0') << endl; return;}
	cout << "0.";
	ans *= 10;
	for(int i = 1 ; i <= K ; ++i){
		cout << (int)(ans + (K == i) * 0.5);
		ans = (ans - (int)ans) * 10;
	}
}

template < class T >

inline void solve(T dp[][110][10010][3]){
	T ans = 0;
	dp[0][0][5000][0] = 1;
	int now = 0;
	for(int i = 1 ; i <= N ; ++i){
		now ^= 1;
		memset(dp[now] , 0 , sizeof(dp[now]));
		for(int j = 0 ; j < i ; ++j)
			for(int k = 0 ; k <= 10000 ; ++k)
				for(int p = 0 ; p <= 2 ; ++p)
					if(dp[now ^ 1][j][k][p]){
						if(k - 2 * i >= 0)
							dp[now][j + 1][k - 2 * i][p] += dp[now ^ 1][j][k][p] * (j + 1 - p) / i;
						if(j)
							dp[now][j][k][p] += dp[now ^ 1][j][k][p] * (j * 2 - p) / i;
						if(j >= 2 && k + 2 * i <= 10000)
							dp[now][j - 1][k + 2 * i][p] += dp[now ^ 1][j][k][p] * (j - 1) / i;
						if(p != 2){
							if(k - i >= 0)
								dp[now][j + 1][k - i][p + 1] += dp[now ^ 1][j][k][p] * (2 - p) / i;
							if(j && k + i <= 10000)
								dp[now][j][k + i][p + 1] += dp[now ^ 1][j][k][p] * (2 - p) / i;
						}
					}
	}
	for(int i = M ; i <= 5000 ; ++i)
		ans += dp[now][1][5000 + i][2];
	out(ans);
}

int main(){
	cin >> N >> M >> K;
	if(K <= 8)
		solve(db::dp);
	else
		solve(flt::dp);
	return 0;
}
```

---

## 作者：λᴉʍ (赞：17)

因为有abs不太好搞，考虑拆掉abs.

生成排列的方法之一：n个空位，从1到n一次插入一个空位。

这样搞的话考虑一个数的贡献

如果是`233333 1 666666` `|233333-1|+|1-666666|==233333+-1+666666-1` 所以1的贡献为-2
如果是`233333 inf 666666` `|233333-inf|+|inf-666666|==inf-233333+inf-666666` 所以inf的贡献为2inf
如果是`1 2 3` `|1-2|+|2-3|==2-1+3-2` 所以2的贡献为0
也就是说一个数的贡献为(-这个数×(sgn(左边的数-这个数)+sgn(右边的数-这个数)))

(边界上的数可以看成这个数×(sgn(相邻的数-这个数))

然后因为是从小到大插的，所以只要看这个数和多少已插入的数相邻

$f[i][j][k][l]:已经插入了i个点，共j段连续，前面数的总贡献为(k-5000)，边界共放了l个的方案数$

k的话从0~10000，C++党没负下标只好这样了，P党无所谓

插入i分多种情况


- 插入在边界，且与一段相连，贡献为i

- 插入在边界，自成一段，贡献为-i

- 插入不在边界，与一段相连，贡献为0（因为一边放了一边没放）

- 插入不在边界，自成一段，贡献为-2i

- 插入不在边界，而且这次插入使得两段相连，贡献为2i


最后统计一下每种多少种情况即可。

不~~想~~会写高精，\_\_float128大法好


k<=8用double

[代码](http://www.cnblogs.com/xzz\_233/p/7513366.html)


---

## 作者：mRXxy0o0 (赞：7)

一道插入 DP 题。

# 分析

这一类型的 DP 大多是对许多段的维护，各个段之间的要求较弱或没有，~~一般都很难搞~~。

先把概率转成计数。

观察题面，我们可以考虑维护一条从上到下类似扫描线的东西，每次计算下移一格的贡献。很明显，在坐标轴上画出图像，应当由数个峰组成。从上往下扫描就会形成一些联续段，考虑 DP 维护。

设 $f_{i,j,k,p,q}$ 表示讨论了前 $i$ 大的值，它们组成了 $j$ 个连续段，已获得了 $k$ 的贡献，左右两侧是否取满了。

讨论第 $i$ 大放在了哪里，分类转移。

1. 新增一段。$f_{i,j,k,p,q}\times(j+1-p-q)\rightarrow f_{i+1,j+1,k+(2\times j-p-q),p,q}$

2. 新增靠边的一段。$f_{i,j,k,p,q}\rightarrow f_{i+1,j+1,k+(2\times j-p-q),p+0/1,q+1/0}$

3. 增长一段。$f_{i,j,k,p,q}\times(2\times j-p-q)\rightarrow f_{i+1,j,k+(2\times j-p-q),p,q}$

4. 合并两段。$f_{i,j,k,p,q}\times(j-1)\rightarrow f_{i+1,j-1,k+(2\times j-p-q),p,q}$

5. 合并一段与边界。$f_{i,j,k,p,q}\rightarrow f_{i+1,j,k+(2\times j-p-q),p+0/1,q+1/0}$

运算过程注意精度，至于输出（借用了一下另一位的），从高到低判断应该输出什么即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110,mod=1e9+7;
int n,m,q;
struct A{
	double f[N][N*N][2][2],g[N][N*N][2][2],ans;
	int main(){
		f[1][0][0][0]=f[1][0][0][1]=f[1][0][1][0]=f[1][0][1][1]=1;
		for(int i=2;i<=n;++i){
			for(int j=1;j<i;++j)
			for(int k=0;k<=i*i;++k)
			for(int p=0;p<2;++p)
			for(int q=0;q<2;++q){
				g[j][k][p][q]=f[j][k][p][q];
				f[j][k][p][q]=0;
			}
			for(int j=1;j<i;++j)
			for(int k=0;k<=i*i;++k)
			for(int p=0;p<2;++p)
			for(int q=0;q<2;++q){
				int cnt=k+2*j-p-q;
				double d=g[j][k][p][q];
				if(j+1-p-q>0) f[j+1][cnt][p][q]+=(j+1-p-q)*d/i;
				if(!p) f[j+1][cnt][1][q]+=d/i,f[j][cnt][1][q]+=d/i;
				if(!q) f[j+1][cnt][p][1]+=d/i,f[j][cnt][p][1]+=d/i;
				if(2*j-p-q>0) f[j][cnt][p][q]+=d*(2*j-p-q)/i;
				if(j>1) f[j-1][cnt][p][q]+=d*(j-1)/i;
			}
		}
		for(int i=m;i<=n*n;++i) ans+=f[1][i][1][1];
		if(ans + 1e-14 >= 1){cout << "1." << string(q,'0') << endl; return 0;}
		cout << "0.";
		ans *= 10;
		for(int i = 1 ; i <= q ; ++i){
			cout << (int)(ans + (q == i) * 0.5);
			ans = (ans - (int)ans) * 10;
		}
		return 0;
	}
}m1;
struct B{
	__float128 f[N][N*N][2][2],g[N][N*N][2][2],ans;
	int main(){
		f[1][0][0][0]=f[1][0][0][1]=f[1][0][1][0]=f[1][0][1][1]=1;
		for(int i=2;i<=n;++i){
			for(int j=1;j<i;++j)
			for(int k=0;k<=i*i;++k)
			for(int p=0;p<2;++p)
			for(int q=0;q<2;++q){
				g[j][k][p][q]=f[j][k][p][q];
				f[j][k][p][q]=0;
			}
			for(int j=1;j<i;++j)
			for(int k=0;k<=i*i;++k)
			for(int p=0;p<2;++p)
			for(int q=0;q<2;++q){
				int cnt=k+2*j-p-q;
				__float128 d=g[j][k][p][q];
				if(j+1-p-q>0) f[j+1][cnt][p][q]+=(j+1-p-q)*d/i;
				if(!p) f[j+1][cnt][1][q]+=d/i,f[j][cnt][1][q]+=d/i;
				if(!q) f[j+1][cnt][p][1]+=d/i,f[j][cnt][p][1]+=d/i;
				if(2*j-p-q>0) f[j][cnt][p][q]+=d*(2*j-p-q)/i;
				if(j>1) f[j-1][cnt][p][q]+=d*(j-1)/i;
			}
		}
		for(int i=m;i<=n*n;++i) ans+=f[1][i][1][1];
		if(ans + 1e-14 >= 1){cout << "1." << string(q,'0') << endl; return 0;}
		cout << "0.";
		ans *= 10;
		for(int i = 1 ; i <= q ; ++i){
			cout << (int)(ans + (q == i) * 0.5);
			ans = (ans - (int)ans) * 10;
		}
		return 0;
	}
}m2;
int main(){
	scanf("%d%d%d",&n,&m,&q);
	if(q<=8) m1.main();
	else m2.main();
	return 0;
}
```


---

## 作者：hzoi_liuchang (赞：5)

## 分析
蒟蒻发现没有高精度的题解，于是来水一发

因为有绝对值不好处理，所以我们强制从小到大填数

设 $f[i][j][p][o]$ 为当前填到了第 $i$ 个数，波动强度为 $j$，有 $p$ 个连续段并且两端的端点选了 $o$ 个时的概率

注意这里的连续段是强制规定的

那么转移有五种：

$1$、填的数单独成为一段并且不在整个区间的两个端点上

$f[i+1][j-i*2-2][p+1][o]+=f[i][j][p][o]*(p+1-o)$

因为后面填在这个数两边的数一定比这个数大，所以这个数一定做负贡献

之前一共有 $p$ 段，可以填的位置有 $p+1$ 种

因为一个段如果在整个区间的两端的话，只能在它的一边填，还要减去 $o$

$2$、填的数单独成为一段并且在整个区间的两个端点上

$f[i+1][j-i-1][p+1][o+1]+=f[i][j][p][o]*(2-o)$

此时这个数只会做一次负贡献

方案数为剩余的整个区间的端点的数量，即 $2-o$

$3$、新填的数放在已有的连续段的一端并且不与其它连续段相邻

$f[i+j][j][p][o]+=f[i][j][p][o]*(p*2-o)$

因为这个数一定做一次正贡献和一次负贡献，所以会抵消，总贡献不变

每个连续段都有两个端点可以选，再减去已选整个区间的端点的数量

$4$、新填的数放在已有的连续段的一端并且与其它连续段相邻

$f[i+1][j+2*i+2][p-1][o]+=f[i][j][p][o]*(p-1)$

其实就是把两个端拼成了一个大段

做两次正贡献

$5$、新填的数放在已有的连续段的一端并且当前的数填到了整个区间的端点上

$f[i+1][j+i+1][p][o+1]+=f[i][j][p][o]*(2-o)$

做一次正贡献

因为题目要求保留的位数不一样

所以，对于精度较低的测试点，可以用 $double$ 写

对于精度较高的测试点，我们可以手写高精度

手写高精度浮点数其实就是先把整个数左移很多位

然后进行正常的加、乘、除的操作

最后要多少位再四舍五入取到多少位即可
## 代码
``` cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<iomanip>
#define rg register
const int maxn=105,maxm=8005,bas=2500,jz=10000000;
int n,m,k,mmax;
struct asd{
	int num[10],len;
	asd(){
		memset(num,0,sizeof(num));
		len=0;
	}
	friend asd operator +(const asd &A,const asd &B){
		asd C;
		C.len=std::max(A.len,B.len);
		for(rg int i=0;i<C.len;i++){
			C.num[i]+=A.num[i]+B.num[i];
			if(C.num[i]>=jz){
				C.num[i]-=jz;
				C.num[i+1]+=1;
			}
		}
		if(C.num[C.len]) C.len++;
		return C;
	}
	friend asd operator *(const asd &A,const asd &B){
		asd C;
		for(rg int i=0;i<B.len;i++){
			for(rg int j=0;j<A.len;j++){
				C.num[i+j]+=B.num[i]*A.num[j];
			}
		}
		for(rg int i=0;i<B.len;i++){
			for(rg int j=0;j<A.len;j++){
				if(C.num[i+j]>=jz){
					C.num[i+j+1]+=C.num[i+j]/jz;
					C.num[i+j]%=jz;
				}
			}
		}
		C.len=B.len+A.len;
		while(C.num[C.len-1]==0 && C.len-1!=0) C.len--;
		return C;
	}		
	friend asd operator /(const asd &A,const int B){
		asd C,D;
		D=A;
		for(rg int i=D.len-1;i>=0;i--){
			rg int haha=D.num[i]+D.num[i+1]*jz;
			C.num[i]=haha/B;
			D.num[i]=haha%B;
			D.num[i+1]=0;
			if(i==0 && D.num[i]>=B/2){
				C.num[i]++;
			}
			if(C.len==0 && C.num[i]){
				C.len=i+1;
			}
		}
		while(C.num[C.len-1]==0 && C.len-1!=0) C.len--;
		return C;
	}
	void read(int aa){
		len=0;
		while(aa){
			num[len++]=aa%jz;
			aa/=jz;
		}
		while(num[len-1]==0 && len-1!=0) len--;
	}
	void write(int aa){
		rg int pd=0;
		printf("0.");
		for(rg int i=len-1;i>=0;i--){
			if(aa-7>=0){
				if(aa==7 && num[i-1]%1000000%10>=5) pd=1;
				printf("%07d",num[i]+pd);
				aa-=7;
			} else {
				if(aa==1 && num[i]/100000%10>=5){
					pd=1;
				}
				if(aa){
					printf("%01d",num[i]/1000000%10+pd);
					aa--;
				}
				if(aa==1 && num[i]/10000%10>=5){
					pd=1;
				}
				if(aa){
					printf("%01d",num[i]/100000%10+pd);
					aa--;
				}
				if(aa==1 && num[i]/1000%10>=5){
					pd=1;
				}
				if(aa){
					printf("%01d",num[i]/10000%10+pd);
					aa--;
				}
				if(aa==1 && num[i]/100%10>=5){
					pd=1;
				}
				if(aa){
					printf("%01d",num[i]/1000%10+pd);
					aa--;
				}
				if(aa==1 && num[i]/10%10>=5){
					pd=1;
				}
				if(aa){
					printf("%01d",num[i]/100%10+pd);
					aa--;
				}
				if(aa==1 && num[i]%10>=5){
					pd=1;
				}
				if(aa){
					printf("%01d",num[i]/10%10+pd);
					aa--;
				}
				if(aa){
					printf("%01d",num[i]%10+pd);
					aa--;
				}
				break;
			}
		}
		printf("\n");
	}
}g[2][maxm][maxn/2][3];
asd anss;
void solve1(){
	mmax=n/2+1;
	rg int now=1;
	g[0][bas][0][0].num[6]=1;
	g[0][bas][0][0].len=7;
	for(rg int i=0;i<n;i++){
		now^=1;
		for(rg int j=0;j<maxm;j++){
			for(rg int p=0;p<=mmax;p++){
				for(rg int o=0;o<=2;o++){
					g[now^1][j][p][o].len=0;
					memset(g[now^1][j][p][o].num,0,sizeof(g[now^1][j][p][i].num));
				}
			}
		}
		asd haha;
		for(rg int j=0;j<maxm;j++){
			for(rg int p=0;p<=mmax;p++){
				for(rg int o=0;o<=2;o++){
					if(g[now][j][p][o].len){
						if(j-2*i-2>=0){
							haha.read(p+1-o);
							g[now^1][j-2*i-2][p+1][o]=g[now^1][j-2*i-2][p+1][o]+g[now][j][p][o]*haha/(i+1);
						}
						if(o<2 && j-i-1>=0){
							haha.read(2-o);
							g[now^1][j-i-1][p+1][o+1]=g[now^1][j-i-1][p+1][o+1]+g[now][j][p][o]*haha/(i+1);
						}
						haha.read(p*2-o);
						g[now^1][j][p][o]=g[now^1][j][p][o]+g[now][j][p][o]*haha/(i+1);
						if(p && j+2*i+2<maxm){
							haha.read(p-1);
							g[now^1][j+2*i+2][p-1][o]=g[now^1][j+2*i+2][p-1][o]+g[now][j][p][o]*haha/(i+1);
						}
						if(o<2 && j+i+1<maxm){
							haha.read(2-o);
							g[now^1][j+i+1][p][o+1]=g[now^1][j+i+1][p][o+1]+g[now][j][p][o]*haha/(i+1);
						}
					}
				}
			}
		}
	}
	for(rg int j=bas+m;j<=bas+(n+1)*n/2;j++){
		anss=anss+g[now^1][j][1][2];
	}
	anss.write(k);
}
double f[2][maxm][maxn/2][3],ans;
void solve2(){
	mmax=n/2+1;
	rg int now=1;
	f[0][bas][0][0]=1.0;
	for(rg int i=0;i<n;i++){
		now^=1;
		for(rg int j=0;j<maxm;j++){
			for(rg int p=0;p<=mmax;p++){
				for(rg int o=0;o<=2;o++){
					f[now^1][j][p][o]=0;
				}
			}
		}
		for(rg int j=0;j<maxm;j++){
			for(rg int p=0;p<=mmax;p++){
				for(rg int o=0;o<=2;o++){
					if(f[now][j][p][o]){
						if(j-2*i-2>=0) f[now^1][j-2*i-2][p+1][o]+=f[now][j][p][o]*(p+1-o)/(i+1);
						if(o<2 && j-i-1>=0) f[now^1][j-i-1][p+1][o+1]+=f[now][j][p][o]*(2-o)/(i+1);
						f[now^1][j][p][o]+=f[now][j][p][o]*(p*2-o)/(i+1);
						if(p && j+2*i+2<maxm)  f[now^1][j+2*i+2][p-1][o]+=f[now][j][p][o]*(p-1)/(i+1);
						if(o<2 && j+i+1<maxm) f[now^1][j+i+1][p][o+1]+=f[now][j][p][o]*(2-o)/(i+1);
					}
				}
			}
		}
	}
	for(rg int j=bas+m;j<=bas+(n+1)*n/2;j++){
		ans+=f[now^1][j][1][2];
	}
	std::cout<<std::fixed<<std::setprecision(k)<<ans<<std::endl;
}
int main(){
	std::cin>>n>>m>>k;
	if(k<=8) solve2();
	else solve1();
	return 0;
}

```

---

## 作者：Jayun (赞：1)

## 题目大意

一个长度为 $n$ 的排列 $\{P_i\}$ 的价值为

$$\sum_{i=2}^n|P_i-P_{i-1}|$$

给定 $n,m,k$，求出长度为 $n$，价值不小于 $m$ 的排列的频率，保留小数点后 $k$ 位。

$n\le 100$.

## 思路

不难想到用 DP 实现。暂且先考虑设 $f_{i,j}$ 表示填了 $i$ 个位置，且价值达到 $j$ 的方案数。然而这样不能维护转移，不好维护选了哪些数。

实际上，我们只关心数字的相对大小而不关心具体选了哪些数，这或许能够成为突破口。因而我们把状态设为一个数集 $S$，表示选了的数。转移时，相对大小为主元，故考虑不断加入更大（或更小，它们地位相同，以更大为例）的数，而且是逐个连续加入，那么以 $1$ 开始从小到大加入即可。于是设 $f_{i,j}$ 表示选择了前 $i$ 个数，且价值达到 $j$ 的方案数。

继续考虑转移。这个状态仍然不好维护价值变化。试把选择了的 $i-1$ 个数分散到各个位置，再加入 $i$。发现 $i-1$ 个数形成若干个块，而围绕这些块，转移有几种情况：

1. $i$ 新开一块（可以和边界连或否）；
2. $i$ 一端连旧有的块，一端连空白或边界；
3. $i$ 与两个旧块相连，它们合并。

由此我们可以设出最终的状态：$f_{i,j,k,l}$ 表示加入了前 $i$ 个数，存在 $j$ 个块，价值达到 $k$，且占了 $l$ 个端点的方案数。

根据上面的分列，不难推出转移方程。

时间复杂度 $\mathcal{O}(n^4)$。

## 代码

思路锻炼很好，但代码实现有点难受，不知道考察的目的。高精度常数好大，压位也不能解决，很痛苦，学习了 `double` 和 `__float128` 切换的实现。

滚动数组优化空间。

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 110, K = 10010, mod = 998244353;

inline ll read() {
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

namespace db{long double f[2][N][K][3];}
namespace ft{__float128 f[2][N][K][3];}

namespace Main {
	int n, m, k;

/*
	const int base = 1e7;
	struct __int200{
		const static int M = 11;
		int d[M];
		__int200() { memset(d, 0, sizeof d); }
		__int200(int x) { for (memset(d, 0, sizeof d); x; d[++d[0]] = x % base, x /= base); }
	};
	__int200 operator + (__int200 a, __int200 b) {
		int r = 0; a.d[0] = max(a.d[0], b.d[0]); 
		for (int i = 1; i <= max(1, a.d[0]); ++i) {
			int x = a.d[i] + b.d[i] + r;
			a.d[i] = x % base;
			r = x / base;
			a.d[0] += (i == a.d[0] && r);
		}
		return a;
	}
	void operator += (__int200 &a, __int200 b) {
		a = a + b;
	}
//	__int200 operator * (__int200 a, int b) {
//	 	int r = 0;
//		for (int i = 1; i <= a.d[0]; ++i) {
//			int m = a.d[i] * b + r;
//			a.d[i] = m % 10;
//			r = m / 10;
//			a.d[0] += (i >= a.d[0] && r);
//		}
//		return a;
//	}
	__int200 operator * (__int200 a, __int200 b) {
		__int200 c(0); 
		if (!a.d[0] || !b.d[0]) return c;
		c.d[0] = a.d[0] + b.d[0];
		for (int i = 1; i <= a.d[0]; ++i)
			for (int j = 1; j <= b.d[0]; ++j)
				c.d[i + j - 1] += a.d[i] * b.d[j];	
		for (int i = 1; i <= c.d[0]; ++i) {
			c.d[i + 1] += c.d[i] / base;
			c.d[0] += (i == c.d[0] && c.d[i] >= base);
			c.d[i] %= base;
		}
		for (; !c.d[c.d[0]] && c.d[0] >= 0; c.d[0]--);
		return c;
	}
	__int200 operator / (__int200 a, int b) {
		__int200 c;
		for (int i = a.d[0]; i; --i) {
			int t = a.d[i] + a.d[i + 1] * base;
			c.d[i] = t / b;
			a.d[i] = t % b;
			a.d[i + 1] = 0;
			c.d[i] += (i == 0 && a.d[i] >= b / 2);
			c.d[0] = (!c.d[0] && c.d[i])? i: c.d[0];
		}
		return c;
	}
*/
	const int zer = K / 2;
	
	template < class T >
	void write (T x) {
		if(x + 1e-14 >= 1)cout << "1." << string(k, '0') << endl;
		else {
			cout << "0.", x *= 10;
			for(int i = 1; i <= k; ++i)cout << (int)(x + (i == k ? 0.5 : 0)), x = (x - (int)x) * 10;
		}
	}
	
	template < class T >
	void solve(T f[][N][K][3]){
		f[0][0][zer][0] = 1;
		for (int i = 1; i <= n; i++) {
			int now = i & 1;
			memset(f[now], 0, sizeof f[now]);
			for (int j = 0; j < i; ++j) 
				for (int k = 0; k < K; ++k)
					for (int l = 0; l < 3; ++l)
						if(f[now ^ 1][j][k][l]) {
							if (j) f[now][j][k][l] += f[now ^ 1][j][k][l] * (j * 2 - l) / i;
							if (k - 2 * i >= 0) f[now][j + 1][k - 2 * i][l] += f[now ^ 1][j][k][l] * (j + 1 - l) / i;
							if (j >= 2 && k + 2 * i < K) f[now][j - 1][k + 2 * i][l] += f[now ^ 1][j][k][l] * (j - 1) / i;
							if (l < 2) {
								if (k - i >= 0) f[now][j + 1][k - i][l + 1] += f[now ^ 1][j][k][l] * (2 - l) / i;
								if (j && k + i < K) f[now][j][k + i][l + 1] += f[now ^ 1][j][k][l] * (2 - l) / i;
							}
						}
		}
		T ans(0);
		for (int i = m; i <= (n + 1) * n / 2; ++i) ans += f[n & 1][1][i + zer][2];
		write(ans);
	}
	
	int main () {
		n = read(), m = read(), k = read();
		if (k <= 8) solve(db::f);
		else solve(ft::f);
		return 0;
	}
}

int main () {
	string str = "";
//	freopen((str + ".in").c_str(), "r", stdin);
//	freopen((str + ".out").c_str(), "w", stdout);
	Main::main();
	return 0;
}
```

---


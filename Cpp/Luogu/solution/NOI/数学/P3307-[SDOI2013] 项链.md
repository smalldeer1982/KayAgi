# [SDOI2013] 项链

## 题目背景

项链作为人体的装饰品之一，是最早出现的首饰。项链除了具有装饰功能之外，有些项链还具有特殊的显示作用，如天主教徒的十字架链和佛教徒的念珠。

从古至今人们为了美化人体本身，也美化环境，制造了各种不同风格、不同特点、不同样式的项链，满足了不同肤色、不同民族、不同审美观的人的审美需要。就材料而论，首饰市场上的项链有黄金、白银、珠宝等几种。

珍珠项链为珍珠制成的饰品，即将珍珠钻孔后用线串在一起，佩戴于项间，天然珍珠项链具有一定的护养作用。

## 题目描述

最近，铭铭迷恋上了一种项链。与其他珍珠项链基本上相同，不过这种项链的珠子却与众不同，是正三菱柱的泰山石雕刻而成的。

三菱柱的侧面是由正方形构成的，每个侧面都刻有数字。能够让铭铭满意的项链必须满足以下条件：

1. 这串项链由 $n$ 颗珠子构成。

2. 每一个珠子上面的每个数字 $x$，必须满足 $0<x\le a$，且珠子上面三个数字的最大公约数要恰好为 $1$。

3. 相邻的两个珠子必须不同。两个珠子被认为是相同的，当且仅当它们经过旋转，或者翻转后能够变成一样的。

4. 两串项链如果能够经过旋转变成一样的，那么这两串项链被认为是相同的。 

铭铭很好奇如果给定 $n$ 和 $a$，能够找到多少串不同的项链。由于答案可能很大，所以输出答案模上 $10^{9}+7$ 的值。

## 说明/提示

满足条件的珠子共有三种：`[1,1,1]`,`[1,1,2]`,`[1,2,2]`。

组成的满足条件的串有：`[1,2]`,`[1,3]`,`[2,3]`。

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2 \le n \le 10^{14}$，$1 \le a \le 10^7$。

## 样例 #1

### 输入

```
1
2  2```

### 输出

```
3```

# 题解

## 作者：小粉兔 (赞：17)

yyb的题解有一个地方是错的，比如最开始的式子，应该是$S3+S2*3+S1*2$。

### 题意简述：

这题分为两个部分：

① 有一些珠子，每个珠子可以看成一个无序三元组。三元组要满足三个数都在$1$到$m$之间，并且三个数互质，两个珠子不同当且仅当这个三元组不同。计算有多少种不同的珠子。

② 把这些珠子串成一个环，要满足相邻的珠子不同。两个环不同当且仅当旋转任意角度后仍然不同。计算有多少种不同的环。

### 题解：

分成两部分做。

#### 第一部分：

考虑计算三元组的个数，转无序为有序，再去重。

答案=(三个都不同的有序三元组方案)/6+(两个相同，另一个不同的方案)/3+(三个都相同的方案)。

容斥一下得到答案=(三元组的方案+二元组的方案\*3+一元组的方案\*2)/6。

因为一元组只有(1)满足条件，所以答案是(2+三元组的方案+二元组的方案\*3)/6。

考虑如何求出两种方案。

三元组的方案是$\sum_{i=1}^m\sum_{j=1}^m\sum_{k=1}^m[\gcd(i,j,k)=1]$，二元组同理。

显然是莫反套路，三元组的答案是$\sum_{d=1}^m\mu(d){\left\lfloor\frac{m}{d}\right\rfloor}^3$，二元组同理。

数论分块求出答案即可，最后乘上6的逆元。这一步复杂度$\Theta(m+T\sqrt{m})$。

#### 第二部分：

知道了不同珠子的数量，要求出本质不同的环的个数。

Burnside引理套路。最终方案数等于每个置换的不动点个数的平均数，即$\frac{1}{n}\sum_{i=1}^nf(i)$，$f(i)$表示旋转$i$格的不动点数量。

稍微化简一下：$\frac{1}{n}\sum_{d|n}\varphi(\frac{n}{d})f(d)$。

考虑计算$f(x)$，当$x$是$n$的因数时，$f(x)$就等于不考虑旋转时的长度为$x$的环的数量。

假设不同珠子的数量为$k$，不加证明地给出一个式子：$f(x)=(k-1)^x+(-1)^x(k-1)$。这个式子可以递推得出。

那么根据这个式子和上面的式子计算即可。

要注意$n$太大了，要求出$\varphi$的值比较困难，考虑DFS它的每个质因数，按照$\varphi$是个积性函数以及公式，求得$\varphi$。

要注意，最后除掉$n$的时候，$n$可能是模数的倍数导致没有逆元。可以发现$n$不会是模数平方的倍数，所以把模数平方后再做一遍，最后除掉模数这个因子即可。

```cpp
#include <cstdio>

#define reg register
typedef unsigned long long ULL;
const ULL MOD = 1000000007ll;
const ULL Inv61 = 166666668ll;
const ULL Inv62 = 833333345000000041ll;
ULL Mod;
ULL Inv6;
const int MN = 10000001;

ULL TN[11];
int TA[11], MA;

bool ip[MN];
int p[MN], pc;
int mu[MN];
inline void SieveInit() {
    ip[0] = ip[1] = 1;
    mu[1] = 1;
    for (reg int i = 2; i <= MA; ++i) {
        if (!ip[i])
            p[++pc] = i,
            mu[i] = -1;
        for (reg int j = 1; j <= pc; ++j) {
            reg int k = p[j] * i;
            if (k > MA) break;
            ip[k] = 1;
            if (i % p[j]) mu[k] = -mu[i];
            else break;
        }
    }
    for (reg int i = 2; i <= MA; ++i)
        mu[i] += mu[i - 1];
}

int O;
inline ULL Mul(ULL x, ULL y) {
    if (!O) return x * y % Mod;
    return (x * y - (ULL)((long double) x / Mod * y) * Mod + Mod) % Mod;
}

ULL N; int A;
ULL M;
inline void SolveM() {
    M = 2;
    for (reg int i = 1, j, k; i <= A; i = j + 1) {
        k = A / i, j = A / k;
        M = (M + Mul(Mul(Mul(k, k), k + 3), (mu[j] - mu[i - 1] + Mod) % Mod)) % Mod;
    }
    M = Mul(M, Inv6);
}

ULL Pow[60];
inline void PowInit() {
    Pow[0] = M - 1;
    for (reg int i = 1; i < 60; ++i) Pow[i] = Mul(Pow[i - 1], Pow[i - 1]);
}
inline ULL qPow(ULL E) {
    ULL A = 1;
    for (reg int j = 0; E; E >>= 1, ++j)
        if (E & 1) A = Mul(A, Pow[j]);
    return A;
}
inline ULL Inv(ULL B) {
    ULL A = 1;
    for (reg ULL E = MOD - 2; E; E >>= 1, B = B * B % MOD)
        if (E & 1) A = A * B % MOD;
    return A;
}

ULL b[15]; int e[15], cnt;
ULL Ans;
inline ULL F(ULL x) {
    return (qPow(x) + (x & 1 ? Mod - M + 1 : M - 1)) % Mod;
}
void DFS(int st, ULL now, ULL phi) {
    if (st > cnt) {
        Ans = (Ans + Mul(phi % Mod, F(N / now))) % Mod;
        return;
    }
    DFS(st + 1, now, phi);
    for (reg int i = 1; i <= e[st]; ++i) {
        now *= b[st];
        phi *= i == 1 ? b[st] - 1 : b[st];
        DFS(st + 1, now, phi);
    }
}
inline ULL Solve() {
    ULL NN = N; cnt = 0;
    for (reg ULL i = 2; i * i <= NN; ++i) if (NN % i == 0) {
        b[++cnt] = i, e[cnt] = 0;
        while (NN % i == 0) NN /= i, ++e[cnt];
    } if (NN > 1) b[++cnt] = NN, e[cnt] = 1;
    Ans = 0; DFS(1, 1, 1);
    if (O) Ans = Ans / MOD * Inv(N / MOD) % MOD;
    else Ans = Ans * Inv(N % MOD) % MOD;
    return Ans;
}

int main() {
    int Tests;
    scanf("%d", &Tests);
    for (int i = 1; i <= Tests; ++i)
        scanf("%llu%d", TN + i, TA + i),
        MA = TA[i] > MA ? TA[i] : MA;
    SieveInit();
    for (int i = 1; i <= Tests; ++i) {
        N = TN[i], A = TA[i];
        O = N % MOD ? 0 : 1;
        if (O) Mod = MOD * MOD, Inv6 = Inv62;
        else Mod = MOD, Inv6 = Inv61;
        SolveM();
        PowInit();
        printf("%llu\n", Solve());
    }
    return 0;
}
```

---

## 作者：George1123 (赞：9)

更哼哼啊的体验 $\to$ [`George1123`](https://www.cnblogs.com/George1123/p/14277797.html)


---

## 题面

> [SDOI2013 项链](https://www.luogu.com.cn/problem/P3307)

> $T$ 组测试数据，每次给 $n,a$。有一个长度为 $n$ 的珍珠项链，每个珍珠上有 $3$ 个数构成一个环。旋转、翻转同构的珍珠相同。相邻的珍珠必须不同，旋转同构的项链相同。求本质不同的项链个数。答案对 $10^9+7$ 取模。

> 数据范围：$1\le n\le 10^{14}$，$1\le a\le 10^7$。

---

## 题解

话说最近我写的题怎么都这么大啊，动不动就 $4k+$，而且好多是紫题，这道短一点却是黑题。

分成两步计算：计算有几种不同的珍珠，有几种不同的项链。

---

### 计算有几种不同的珍珠

设 $g(i)$ 表示 $3$ 个数 $\gcd$ 是 $i$ 的倍数的方案数。

设 $f(i)$ 为 $3$ 个数的 $\gcd$ 恰好为 $i$ 的方案数。

$$g(i)=\sum_{i|d} f(d)\Longleftrightarrow f(i)=\sum_{i|d} g(d)\mu(\frac{d}{i})$$

$$\therefore f(1)=\sum_{d=1}^{a} g(d)\mu(d)$$

计算 $g(d)$，相当于 $3$ 个数的选取范围是 $\lfloor\frac ad\rfloor$。

利用 `Burnside` 定理，考虑 $G$ 的元素，设 $m=\lfloor\frac ad\rfloor$：

$$g(d)=\frac{1}{6}\left(2m+3m^2+m^3\right)$$

然后就可以计算出 $f(1)$ 了，设 $c=f(1)$，需要线性筛和整除分块。

---

### 计算有几种不同的项链

同样利用 `Burnside` 定理，枚举循环节。

$$ans=\frac{1}{n}\sum_{d|n} p(d)\varphi(\frac nd)$$

先想想这个 $\varphi(d)$ 怎么做？不能线性筛，直接求也会 `TLE`。

可以利用 $n$ 的每个质因数，统一计算 $\varphi(d)=\prod_{p^c|d} \left(p^c-p^{c-1}\right)$。

这东西可以把 $n$ 的质因数和幂次预处理出来，用一个 `dfs` 实现。

这个 $p(d)$ 是长度为 $d$ 的鸽子序列，每个鸽子可以染 $c$ 种颜色，相邻、首尾两只鸽子不能同色的方案数。

我曾经犯过的错误：$p(d)=c(c-1)^{d-2}(c-2)$。

分类讨论：第 $1$ 个鸽子和第 $d-1$ 个鸽子颜色是否一样。

- 如果一样，相当于 $d-2$ 个鸽子，最后一只切成两只，然后往中间放第 $d$ 个鸽子：$p(d)\leftarrow (c-1)p(d-2)$。

- 如果不一样，相当于 $d-1$ 只鸽子，在最后两只之间放第 $d$ 个鸽子：$p(d)\leftarrow (c-2)p(d-1)$。

边界情况：$p(1)=0$，$p(2)=c(c-1)$。

矩阵快速幂会 `TLE`，但是这个东西可以通过特征方程递推：

$$p(d)=(c-2)p(d-1)+(c-1)p(d-2)\to x^2=(c-2)x+c-1$$

$$(x-(c-1))(x+1)=0\to x=c-1\ {\rm or}\ -1$$

$$\begin{cases}
p(d)-(c-1)p(d-1)=-(p(d-1)-(c-1)p(d-2))\\
p(d)+p(d-1)=(c-1)p(d-1)+(c-1)p(d-2)\\
\end{cases}$$

$$\begin{cases}
p(d)-(c-1)p(d-1)=(-1)^{d-2}c(c-1)\\
p(d)+p(d-1)=(c-1)^{d-2}c(c-1)\\
\end{cases}$$

$$p(d)=(c-1)((-1)^{d-2}+(c-1)^{d-1})$$

---

### 最后不可忽略的细节！

注意了，还有 $(10^9+7)|n$ 的情况，要把 $mod$ 变成 $(10^9+7)^2$，这样 $mod\nmid n$。

所有的乘法变成龟速乘。最后先把答案除以 $10^9+7$（因为答案如果不取模一定是 $n$ 的倍数），再除以 $\frac{n}{10^9+7}$ 对于 $10^9+7$ 的逆元。

时间复杂度 $\Theta(T(\sqrt a\log \bmod+\sqrt n+{\rm maxd}(n)\log^2 \bmod))$。

---

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define x first
#define y second
#define bg begin()
#define ed end()
#define pb push_back
#define mp make_pair
#define sz(a) int((a).size())
#define R(i,n) for(int i(0);i<(n);++i)
#define L(i,n) for(int i((n)-1);i>=0;--i)
const int iinf=0x3f3f3f3f;
const ll linf=0x3f3f3f3f3f3f3f3f;

//Math
const ll mod1=1e9+7;
const ll mod2=mod1*mod1;
ll mod,i6;
ll mymul(ll a,ll x,ll mod=::mod,ll res=0){
    for(;x;x>>=1,(a+=a)%=mod)
        if(x&1) (res+=a)%=mod;
    return res;
}
ll mypow(ll a,ll x,ll mod=::mod,ll res=1){
    for(;x;x>>=1,a=mymul(a,a,mod))
        if(x&1) res=mymul(res,a,mod);
    return res;
}
const ll i61=mypow(6,mod1-2,mod1);
const ll i62=mypow(6,(mod1-1)*mod1-1,mod2);

//Math//Number
namespace nb{
    const int N=1e7+1;
    bool np[N];
    int mu[N],sm[N|1];
    vector<int> prime;
    void sieve(int n=N){
        np[1]=true,mu[1]=1;
        for(int i=2;i<n;++i){
            if(!np[i]) prime.pb(i),mu[i]=-1;
            for(int p:prime){
                if(i*p>=n) break;
                np[i*p]=true;
                if(i%p==0){mu[i*p]=0; break;}
                mu[i*p]=-mu[i];
            }
        }
        R(i,n) sm[i+1]=sm[i]+mu[i];
    }
    vector<pair<ll,int>> pfac(ll n){
        vector<pair<ll,int>> res;
        for(ll d=2;d*d<=n;++d)if(n%d==0)
            for(res.pb({d,0});n%d==0;++res.back().y,n/=d);
        if(n>1) res.pb({n,1});
        return res;
    }
    void dfs(vector<pair<ll,int>> &p,
        vector<pair<ll,ll>> &np,int dep,pair<ll,ll> now){
        if(dep==sz(p)) return np.pb(now);
        pair<ll,ll> de=now;
        R(i,p[dep].y+1){
            dfs(p,np,dep+1,de);
            if(i) de.x*=p[dep].x,de.y*=p[dep].x;
            else de.x*=p[dep].x,de.y*=p[dep].x-1;
        }
    }
    vector<pair<ll,ll>> facphi(ll n){
        vector<pair<ll,ll>> res;
        vector<pair<ll,int>> pf=pfac(n);
        dfs(pf,res,0,mp(1,1));
        return res;
    }
}

//Matrix//Function
ll mycalc(ll c,ll n){
    if(n==1) return 0;
    if(n==2) return mymul(c,c-1+mod);
    c=(c-1+mod)%mod;
    ll res=mypow(c,n);
    if(n&1) (res+=mod-c)%=mod;
    else (res+=c)%=mod;
    return res;
}

//Main//Data
unordered_map<ll,ll> phi;

//Main
void mymain(){
    ll n,c=0,res=0; int a; cin>>n>>a;
    if(n%mod1==0) mod=mod2,i6=i62;
    else mod=mod1,i6=i61;
    // cout<<"mod="<<mod<<'\n';
    for(int l=1,r=-1;l<=a;l=r){
        int m=a/l; ll g=2*m; r=a/m+1;
        g=(mymul(3,mymul(m,m))+g)%mod;
        g=(mymul(mymul(m,m),m)+g)%mod;
        g=mymul(mymul(g,i6),nb::sm[r]-nb::sm[l]+mod);
        (c+=g)%=mod;
    }
    // cout<<"c="<<c<<'\n';
    vector<pair<ll,ll>> fp=nb::facphi(n);
    for(auto &u:fp) phi[u.x]=u.y;
    for(auto &u:fp) res=(mymul(mycalc(c,u.x),phi[n/u.x])+res)%mod;
    // cout<<"res="<<res<<'\n';
    if(n%mod1==0) res=(res/mod1*mypow(n/mod1,mod1-2,mod1))%mod1;
    else (res*=mypow(n,mod1-2,mod1))%=mod1;
    cout<<res<<'\n';
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    nb::sieve();
    int t; for(cin>>t;t--;mymain());
    return 0;
}
```

---

**祝大家学习愉快！**

---

## 作者：yybyyb (赞：9)


首先读完题目，很明显的感觉就是，分成了两个部分计算。  
首先计算本质不同的珠子个数，再计算本质不同的项链个数。  
前面一个部分和$gcd$相关，一种莫比乌斯反演的感觉。  
后面一个部分出现了旋转操作，要求本质不同的方案数，不难想到Burnside引理。  

首先先考虑怎么求本质不同的珠子个数。  
我们直接考虑无序的三元组$(x,y,z)$，满足$x,y,z\le a,gcd(x,y,z)=1$  
容斥考虑最终答案，就是$\frac{1}{6}(S3-S2*3+S1*2)$，其中$S3$是无序的三元组个数，$S2$是满足互质的二元组个数，而$S1$则是三个数都相同并且$gcd=1$的三元组个数。  
$S1$显然只有一个，即可以构成唯一合法三元组$(1,1,1)$  
考虑怎么计算$S2$和$S3$。  
看起来$s2$很熟悉，也就是$\sum_{i=1}^a\sum_{j=1}^a[gcd(i,j)=1]$  
然后直接莫比乌斯反演。  
设$F(x)=\sum_{i=1}^a\sum_{j=1}^a[gcd(i,j)=x]$  
$G(x)=\sum_{x|d}F(d)=\sum_{i=1}^a  \sum_{j=1}^a[x|gcd(i,j)]=[\frac{a}{x}]^2$  
然后又因为$F(x)=\sum_{x|d}G(d)*\mu(\frac{d}{x})$    
要求的是$F(1)$，即$F(1)=\sum_{i=1}^aG(i)*\mu(i)=\sum_{i=1}^a[\frac{a}{i}]^2\mu(i)$。  
然后是$S3$，即三元组个数，和上面一样的推法，可以得到贡献是$\sum_{i=1}^a[\frac{a}{i}]^3\mu(i)$  
好了，那么计算本质不同的珠子的个数就算完了。

接下来考虑如何计算本质不同的项链的个数。    
因为只有旋转计算本质不同，那么置换一共$n$个，是顺时针旋转$i$位。  
那么答案就是所有置换的不动点个数除以$n$。那么不难往Polya定理方面靠。    
只需要知道每个循环的大小即可。  
对于顺时针旋转$i$位的循环长度显然就是$\frac{n}{gcd(n,i)}$，循环个数$gcd(n,i)$也很显然。  
因为是不动点的个数，因此每一个循环内的所有珠子的颜色必须相同。同时，题目限制相邻两个位置的珠子颜色不能相同。因此，这里可以等价的看做有$gcd(n,i)$个珠子，收尾相连，要求相邻的珠子不同色的方案数，假装这个的方案数是$f(x)$,表示$x$个珠子收尾相连时候的方案数。那么现在要求的答案就是$\sum_{i=1}^nf(gcd(i,n))$。$n$太大了，考虑优化。  

我们枚举$gcd$,即$\sum_{d=1}^n\sum_{i=1}^n[gcd(i,n)=d]f(d)$，那么显然$d$是$n$的因数。所以可以接着写成$\sum_{d|n}\sum_{i=1}^n[gcd(i,n)=d]f(d)$,进一步推，也就是$\sum_{d|n}\sum_{i=1,d|i}^n[gcd(\frac{i}{d},\frac{n}{d})=1]f(d)$，即需要知道所有和$\frac{n}{d}$互质的$\frac{i}{d}$，考虑$\frac{i}{d}$的最大取值只有$\frac{n}{d}$，所以这个值显然就是$\varphi(\frac{n}{d})$。因此，总的贡献就是$\sum_{d|n}f(d)\varphi(\frac{n}{d})$。

现在来考虑怎么计算$f(x)$,假设一共有$m$中不同的珠子  
首先我们可以在两个珠子之间插入一个不同的珠子，即$f(x-1)*(m-2)$，亦或者强制让首位两个珠子颜色相同，然后插入一个不同颜色的珠子将他们隔开，这个操作等价于我现有$f(x-2)$个珠子构成了一个环，然后插入一个和首位相同的珠子，再插入一个颜色不同的珠子隔开，即$f(x-2)*(m-1)$，那么转移就是$f(x)=f(x-1)*(m-2)+f(x-2)*(m-1)$。  
显然可以矩阵乘法直接算。然而这种东西一般也可以推递推式的。  
我们尽可能让他往一个等比的方向上靠，  
那么我们最好能把式子化简为这种形式：$f(x)+af(x-1)=bf(x-1)+abf(x-2)$  
那么列出方程组：
$$\begin{cases}b-a&=m-2\\ab&=m-1\end{cases}$$
所以有$b=a+m-2$，所以有$a(a+m-2)-(m-1)=0$,也就是$a^2+(m-2)a-(m-1)=0$  
因式分解一下就是$(a+(m-1))(a-1)=0$  
解出来$a=1$或者$a=1-m$，看着$a=1$好做些，  
那么式子写成$f(x)+f(x-1)=(m-1)*(f(x-1)+f(x-2))$  
所以得到$f(x)+f(x-1)=(m-1)^{x-2}(f(1)+f(2))$,  
显然有$f(1)=0,f(2)=m*(m-1)$，为了方便，设$S(x)=f(x)+f(x-1)$。  
递推式换成$S(x)=(m-1)S(x-1)=(m-1)^{x-2}S(2)=(m-1)^{x-1}m$  
考虑一下$f(x)$怎么计算，$f(x)=S(x)-f(x-1)=m(m-1)^{x-1}-f(x-1)$  
一般这样子都可以构建一个递推式。  

$$\begin{aligned}f(x)&=m(m-1)^{x-1}-f(x-1)\\f(x)+A(m-1)&=-(f(x-1)+A)\\mA&=m(m-1)^{x-1}\\A&=(m-1)^{x-1}\end{aligned}$$

所以，我们可以构建出这样一个等式：
$$f(x)-(m-1)^{x}=-(f(x)-(m-1)^{x-1})$$
在考虑一下边界情况，可以得到$f(x)-(m-1)^x=(-1)^x(m-1)$   
即$f(x)=(-1)^x(m-1)+(m-1)^x$,这样子就可以快速幂计算$f(x)$了。

然而发现一些很不舒服的东西，因为$n$太大，导致$n$可能是模数的倍数，那就不能够直接除$n$了。  
怎么办呢？那么首先我们直接模$mod^2$，这样子最终的结果会是$mod$的倍数，所以可以先除掉$mod$然后再考虑逆元就行了。  
离线一下就跑得飞快了，目前是洛谷rk1，bzoj rk3  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
#define ll long long
const ll mod=1000000007;
const ll MOD=mod*mod;
const ll inv6 = 833333345000000041ll;
#define MAX 10000001
inline ll read()
{
	ll x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
void add(ll &x,ll y){x+=y;if(x>=MOD)x-=MOD;}
ll Multi(ll x,ll y){return (x*y-(ll)(((long double)x*y+0.5)/(long double)MOD)*MOD+MOD)%MOD;}
ll fpow(ll a,ll b)
{
	ll s=1;
	while(b){if(b&1)s=Multi(s,a);a=Multi(a,a);b>>=1;}
	return s;
}
ll qpow(ll a,ll b)
{
	ll s=1;
	while(b){if(b&1)s=s*a%mod;a=a*a%mod;b>>=1;}
	return s;
}
ll sqr(ll x){return Multi(x,x);}
ll cub(ll x){return Multi(sqr(x),x);}
bool zs[MAX];
int pri[MAX/10],tot,mu[MAX];
ll n,m,ans;int a,cnt;
ll nn[50],aa[50];
ll p[MAX/10],q[MAX/10];
void pre(ll N)
{
	mu[1]=1;
	for(int i=2;i<=N;++i)
	{
		if(!zs[i])pri[++tot]=i,mu[i]=-1;;
		for(int j=1;j<=tot&&i*pri[j]<=N;++j)
		{
			zs[i*pri[j]]=true;
			if(i%pri[j])mu[i*pri[j]]=-mu[i];
			else break;
		}
	}
	for(int i=1;i<=N;++i)mu[i]+=mu[i-1];
}
ll Calc(ll n)
{
	ll S2=0,S3=0;
	for(ll i=1,j;i<=n;i=j+1)
	{
		j=n/(n/i);
		add(S3,Multi(cub(n/i),(mu[j]-mu[i-1]+MOD)%MOD));
		add(S2,Multi(sqr(n/i),(mu[j]-mu[i-1]+MOD)%MOD));
	}
	add(S3,Multi(S2,3)),add(S3,2);
	return Multi(S3,inv6);
}
ll F(ll n)
{
	ll ret=fpow(m-1,n);
	if(n&1)add(ret,(MOD-(m-1))%MOD);
	else add(ret,m-1);
	return ret;
}
void dfs(int i,ll d,ll phi)
{
	if(i==cnt+1){add(ans,Multi(phi,F(n/d)));return;}
	dfs(i+1,d,phi);
	d*=p[i];phi*=p[i]-1;dfs(i+1,d,phi);
	for(int x=2;x<=q[i];++x)
		d*=p[i],phi*=p[i],dfs(i+1,d,phi);
}
int main()
{
	int T=read();ll mx=0;
	for(int i=1;i<=T;++i)nn[i]=read(),aa[i]=read();
	for(int i=1;i<=T;++i)mx=max(mx,max((ll)sqrt(nn[i]),aa[i]));
	pre(mx);
	for(int TT=1;TT<=T;++TT)
	{
		n=nn[TT];a=aa[TT];
		m=Calc(a);cnt=0;ll x=n;
		for(int i=1;i<=tot&&1ll*pri[i]*pri[i]<=x;++i)
			if(x%pri[i]==0)
			{
				p[++cnt]=pri[i];q[cnt]=0;
				while(x%pri[i]==0)++q[cnt],x/=pri[i];
			}
		if(x>1)p[++cnt]=x,q[cnt]=1;
		ans=0;dfs(1,1,1);
		if(n%mod==0)ans=(ll)(ans/mod)*qpow(n/mod,mod-2)%mod;
		else ans=(ans%mod)*qpow(n%mod,mod-2)%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Purslane (赞：7)

# Solution

可能是为数不多的自己做出来的黑题吧。

不过这道题没啥难度，恶心在于多合一。 /tuu

## Step 1

首先考虑计算有多少种符合条件的珠子。我们要人工除序，所以也就是求

$$\sum_{i=1}^a \sum_{j=i}^a \sum_{k=j}^a [(i,j,k)=1]$$

我们用莫比乌斯反演拆开得到

$$\sum_{d=1}^a \mu(d) \sum_{i=1}^{\lfloor \frac{a}{d} \rfloor} \sum_{j=i}^{\lfloor \frac{a}{d} \rfloor} \sum_{k=j}^{\lfloor \frac{a}{d} \rfloor} 1$$

后面这个东西又可以写作（令 $h = \lfloor \frac{a}{d} \rfloor$）

$$\sum_{i=1}^h \sum_{j=1}^i \sum_{k=1}^j 1$$

然后逐个计算求和号，最终答案是 $\frac{h(h+1)(h+2)}{6}$。于是可以线性筛预处理，用整除分块算出来。我们把答案记为 $cnt$。

## Step 2

考虑使用 Burnside 引理。首先看看是否满足使用条件。置换只有旋转，那么他们显然构成了一个群；如果一种染色方法合法，那么转一转肯定也合法，因此满足映射在置换作用下封闭。因此可以使用 Burnside 引理。

考虑设置换 $g$ 的不动点个数为 $s(g)$。我们发现，事实上相当于求长度为 $(n,dpos(g))$ 的相邻不相同的环的个数。（$dpos$ 表示旋转移动的长度）。

因此最终答案是

$$\frac{1}{n}\sum_{i=1}^n f((n,i))$$

其中 $f(x)$ 就是长度为 $x$ 的环的没有任何要求的答案。

显然你不能枚举 $i$。考虑记录每个 $(n,i)$ 被计算了多少次。那么求和部分可以化简为

$$\sum_{d|n} f(d) \varphi(\frac{n}{d})$$

我们可以预处理 $n$ 的质因数，在枚举 $n$ 所有的因子的同时完成 $\varphi$ 的计算。复杂度为 $O(d(n))$，肯定在范围内（查表知在题目条件下这个量级是十万）。

## Step 3

考虑计算 $f(len)$。假设我们钦定了第一个位置的颜色，有 $cnt$ 种方案。但是我们想要最后一个数不是我们开始的第一种。

因此来一个二元递推。设 $\alpha_n$ 表示填到第 $n$ 个珠子，它和第一个珠子一样的方案数，$\beta_n$ 表示和第一个珠子不一样的方案数。刚开始 $\alpha_1=cnt$，$\beta_1=0$。容易写出递推式：

$$\alpha_{n+1}=\beta_n$$
$$\beta_{n+1}=(cnt-1)\alpha_{n}+(cnt-2)\beta_n$$

我们想要求解 $\beta$，因此带换一下得到

$$\beta_{n+1}=(cnt-1)\beta_{n-1}+(cnt-2)\beta_n$$

特征方程为 $x^2-(cnt-2)x+(1-cnt)=0$。两个根分别为 $-1$ 和 $cnt-1$。把前两个数带进去，得到

$$\beta_n=(cnt-1)(-1)^n+(cnt-1)^n$$

感觉做完了。

## Step 4

你发现自己喜提 91 分。因为这种 $n$ 大于模数的题目要小心。因此有可能 $(10^9+7)|n$。这时候我们发现不存在逆元！就不能把除掉。

不过问题不大。我们发现 $n$ 里面顶多含有一个模数。所以你求出答案对于 $(10^9+7)^2$ 取模的值，如果 $n$ 是模数的倍数让二者同时除以模数即可。

总体复杂度大概是 $O(A)-O(\sqrt A \log A+d(n)\log n \log A)$。那么多老哥的原因是防止溢出用了龟速乘。

写的可能有点民科，见谅。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e7+10,MODD=1000000000+7,MOD=1ll*(1000000000+7)*(1000000000+7);
int T,n,a,ans,_6;
int mu[MAXN];
bool flg[MAXN];
int mod(int x) {
	if(x<0) x=x+MOD;
	return (x>=MOD)?x-MOD:x;	
}
int Mul(int a,int b) {
	b%=MOD,b=mod(b),a%=MOD,a=mod(a);
	int res=0;
	while(b) {
		if(b&1) res=mod(res+a);
		a=mod(a+a),b>>=1;
	}
	return res;
}
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=Mul(ans,base);
		base=Mul(base,base),p>>=1;
	}
	return ans;
}
int Qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MODD;
		base=base*base%MODD,p>>=1;
	}
	return ans;
}
vector<int> pr;
void init(int Mx) {
	mu[1]=1;
	ffor(i,2,Mx) {
		if(!flg[i]) pr.push_back(i),mu[i]=-1;
		for(auto v:pr) {
			if(i*v>Mx) break;
			flg[i*v]=1;
			if(i%v==0) {mu[i*v]=0;break;}
			mu[i*v]=-mu[i];	
		}
	}
	ffor(i,2,Mx) mu[i]+=mu[i-1];
	return ;
}
vector<pair<int,int>> zys;
void solve(int dep,int d,int phi,int n,int cnt) {
	if(dep==zys.size()) {
		int res=0;
		if((n/d)%2) res=1-cnt; else res=cnt-1;
		res+=qpow(cnt-1,n/d),res%=MOD;
		ans=(ans+Mul(phi%MOD,res))%MOD;
		return ;
	}
	int mul=1;
	ffor(i,0,zys[dep].second) {
		if(i==0) solve(dep+1,d,phi,n,cnt);
		else solve(dep+1,d*mul,phi*mul/zys[dep].first*(zys[dep].first-1),n,cnt);
		mul*=zys[dep].first;	
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T; init(10000000); _6=qpow(6,MODD*(MODD-1)-1);
	while(T--) {
		cin>>n>>a;
		int cnt=0;
		int l=1;
		while(l<=a) {
			int r=a/(a/l),v=a/l;
			cnt=cnt+Mul(Mul(Mul(Mul(v,v+1),v+2),_6),mu[r]-mu[l-1]),cnt%=MOD;
			l=r+1;
		}
		cnt%=MOD,cnt+=MOD,cnt%=MOD;
		if(n==1) {cout<<cnt<<'\n'; continue;}
		if(a==1) {cout<<0<<'\n'; continue;}
		int N=n; zys.clear();
		for(auto v:pr) if(n%v==0) {
			int cnt=0;
			while(n%v==0) n/=v,cnt++;
			zys.push_back({v,cnt});
		}
		if(n!=1) zys.push_back({n,1}); n=N;
		ans=0;
		solve(0,1,1,n,cnt);
		if(n%MODD) ans%=MODD,ans*=Qpow(n%MODD,MODD-2),ans%=MODD,ans+=MODD,ans%=MODD,cout<<ans<<'\n';
		else ans/=MODD,n/=MODD,ans%=MODD,ans*=Qpow(n%MODD,MODD-2),ans%=MODD,ans+=MODD,ans%=MODD,cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Refined_heart (赞：7)

## 前置知识

群论，莫比乌斯反演，Burnside 引理

## 分析

首先我们思考，发现题干中出现了 "旋转同构" 和 "翻转同构" 也就指向了群论相关的计数定理。

先来尝试分析这个题目。利用群论的相关结论，我们考虑最外层项链的操作群应当是 $n$ 阶循环群，我们可以直接枚举其循环节数目，根据循环群的性质我们知道，有 $x$ 个置换环的循环群中的置换，其所有置换环长度相同，均为 $\frac{n}{x}$

再利用 [MtOI2018]魔力环 中提到的转化技巧，由于原串也是环，我们发现我们可以将限制缩小到一个长度为 $\frac{n}{x}$ 的环中，并不考虑循环同构，只计算满足条件的环形合法方案。不动点的性质已经在循环编号 $0\cdots x, 0\cdots x$ 中的相同标号处确定了。

那么我们考虑如何求这个环的方案数，假设我们有 $m$ 种不同的珠子，问题看起来就好解决了……那么，在思考这个问题之前，我们要做的应该是先求出有多少本质不同的珠子。



------------


我们不考虑同构，根据第一个限制，枚举三个侧面的数，得到：

$$
\sum_{i = 1} ^ a \sum_{j = 1} ^ a \sum_{k = 1} ^ a \gcd(i, j, k) = 1

$$

直接反演，得到

$$
\sum_{d = 1} ^ a \mu(d) \left(\lfloor\frac{a}{d}\rfloor\right)^3
$$

那么记上式为 $T(n, 3).$ 我们来考虑循环和翻转同构的限制。

发现，这部分和 [AHOI2002]黑白瓷砖 中的操作是相似的，我们发现六种操作对应了三种等价类：

* 不动点

对应方案数是 $T(n, 3)$

* 旋转

发现要求三个都相同。旋转有两个，对应等价类大小是 $1.$

* 三个方向的翻折

发现要求有两个相同，方案数就是 $T(n, 2)$

于是根据 Burnside 引理，总珠子方案数就是 $\frac{1}{6}(2 + T(n, 3) + 3 \times T(n, 2))$ 了。



------------


我们记上面求到的不同珠子数目是 $m.$ 现在考虑如何计算长度为 $k$ 的环满足相邻不同的方案数。

发现环的接口部分很难处理，但是我们可以打表啊）

观察一下长度为 $i$ 颜色数是 $j$ 的方案，发现形如 $(j - 1) ^ i + (j - 1)$ 或 $(j - 1) ^ i - (j - 1)$ 根据打标程序即可 $O(\log n)$ 计算上式，证明不会。

于是我们将上述部分实现后，利用最外层的 Burnside 引理就可以写出：

$$
Ans = \frac{1}{n}\sum_{d | n} \varphi(d) f(\frac{n}{d})
$$

其中 $f(x)$ 就是长度为 $x$ 的方案数。总复杂度是 $O(T(\sqrt n + \sqrt n \log n))$ 级别的。

### 最后的细节处理

但是这个 $n > mod$ 就很烦，交上去发现 $91$ 分，下载数据后发现是模出来成 $0$ 了。

怎么办？我们直接大力，在 $\bmod 1000000007^2$ 的意义下进行上述操作，最后除掉 $1000000007$ 后再继续在 $1000000007$ 意义下除掉剩下的部分即可。

注意到我们只会这样除掉最多一个 $1000000007,$ 因为 $1000000007^2>maxn$

然后注意到这东西不是质数，费马小定理完蛋了，但是它与 $6$ 互质啊，所以我们可以扩展欧几里得求出 $6$ 的逆元。然后规避所有使用到质数的行为，例如快速幂的时候对指数 $\bmod (mod - 1)$


### 代码

代码中用 `map` 对暴力求欧拉函数的行为进行了记忆化，其中 `calc()` 函数是上述计算环中打表出来的具体结论。

打表的代码就是暴力枚举所有方案并检查，就不给出了。


```cpp
namespace Refined_heart {
	int xx, yy;
	int mu[10000001];
	bitset<100000001> vis;
	int pm[700000], pcnt;
	void shai() {
		mu[1] = 1;
		const int SN = 10000000;
		for(int i = 2; i <= SN; ++i) {
			if(!vis[i]) mu[i] = -1, pm[++pcnt] = i;
			for(int j = 1; j <= pcnt && i * pm[j] <= SN; ++j) {
				vis[i * pm[j]] = 1;
				if(i % pm[j] == 0) {
					break;
				}
				mu[i * pm[j]] = -mu[i];
			}
		}
		for(int i = 1; i <= SN; ++i) mu[i] = mu[i - 1] + mu[i];
	}
	
	namespace MOD2 {
		const int inv6 = (833333345000000041ll);
		const int mod = 1000000007ll * 1000000007ll;

		inline int Add(ci x, ci y, ci M = mod) {
			return (x + y) % M;
		}
		inline int Mul(ci x, ci y, ci M = mod) {
			return (__int128)x * y % M;
		}
		inline int Dec(ci x, ci y, ci M = mod) {
			return (x - y + M) % M;
		}
		inline int qpow(int x, int y, int M = mod) {
			int res = 1;
			x %= M;
			while (y) {
				if (y & 1)res = Mul(res, x, M);
				x = Mul(x, x, M);
				y >>= 1;
			}
			return res;
		}
		inline int sq3(int x) {
			return Mul(x, Mul(x, x));
		}
		inline int sq2(int x) {
			return Mul(x, x);
		}
		map<int, int> ph;
		int phi(int x) {
			if(x == 1) return 1;
			if(ph[x] != 0) return ph[x];
			int bv = x;
			int ans = x;
			for(int i = 2; i * i <= x; ++i) {
				if(x % i != 0) continue;
				while(x % i == 0) x /= i;
				ans = ans - ans / i;
			}
			if(x > 1) ans = ans - ans / x;
			ans %= mod;
			ph[bv] = ans;
			return ans;
		}
		int calc1(int a) {
			int ans = 0;
			for(int l = 1, r; l <= a; l = r + 1) {
				r = (a / (a / l));
				int sm = Dec((mu[r] + mod) % mod, (mu[l - 1] + mod) % mod);
				sm = Mul(sm, sq3(a / l));
				ans = Add(ans, sm);
			}
			return ans;
		}
		int calc2(int a) {
			int ans = 0;
			for(int l = 1, r; l <= a; l = r + 1) {
				r = (a / (a / l));
				int sm = Dec((mu[r] + mod) % mod, (mu[l - 1] + mod) % mod);
				sm = Mul(sm, sq2(a / l));
				ans = Add(ans, sm);
			}
			return ans;
		}
		int getAll(int a) {
			int res = 2;
			res = Add(res, calc1(a));
			res = Add(res, Mul(3, calc2(a)));
			res = Mul(res, inv6);
			return res;
		}
		int calc(int n, int m) {
			if(n == 1) {
				return 0;
			}
			int xs = (n & 1) ? (mod - 1) : 1;
			xs = Mul(xs, (m - 1));
			int vl = qpow(m - 1, n);
			vl = Add(vl, xs);
			return vl;
		}
		int calcans(int n, int x, int All) {
			return Mul(phi(x) % mod, calc(n / x, All) % mod);
		}
		void solve(int n, int a) {
			int All = getAll(a);
			All %= mod;
			int ans = 0;
			for(int i = 1; i * i <= n; ++i) {
				if(n % i != 0) continue;
				ans = Add(ans, calcans(n, i, All));
				if(i * i == n) continue;
				ans = Add(ans, calcans(n, n / i, All));
			}
			ans = ans / 1000000007;
			int z = n / 1000000007;
			ans = Mul(ans, qpow(z, 1000000005, 1000000007), 1000000007);
			write(ans);
			pc('\n');
		}
	}
	
	inline int Add(ci x, ci y, ci M = mod) {
		return (x + y) % M;
	}
	inline int Mul(ci x, ci y, ci M = mod) {
		return (__int128)x * y % M;
	}
	inline int Dec(ci x, ci y, ci M = mod) {
		return (x - y + M) % M;
	}
	inline int qpow(int x, int y) {
		int res = 1;
		x %= mod;
		while (y) {
			if (y & 1)res = Mul(res, x);
			x = Mul(x, x);
			y >>= 1;
		}
		return res;
	}
	const int inv6 = qpow(6, mod - 2);
	inline int sq3(int x) {
		return Mul(x, Mul(x, x));
	}
	inline int sq2(int x) {
		return Mul(x, x);
	}
	map<int, int> ph;
	int phi(int x) {
		if(x == 1) return 1;
		if(ph[x] != 0) return ph[x];
		int bv = x;
		int ans = x;
		for(int i = 2; i * i <= x; ++i) {
			if(x % i != 0) continue;
			while(x % i == 0) x /= i;
			ans = ans - ans / i;
		}
		if(x > 1) ans = ans - ans / x;
		ans %= mod;
		ph[bv] = ans;
		return ans;
	}
	int calc1(int a) {
		int ans = 0;
		for(int l = 1, r; l <= a; l = r + 1) {
			r = (a / (a / l));
			int sm = Dec(mu[r] + mod, mu[l - 1] + mod);
			sm = Mul(sm, sq3(a / l));
			ans = Add(ans, sm);
		}
		return ans;
	}
	int calc2(int a) {
		int ans = 0;
		for(int l = 1, r; l <= a; l = r + 1) {
			r = (a / (a / l));
			int sm = Dec(mu[r] + mod, mu[l - 1] + mod);
			sm = Mul(sm, sq2(a / l));
			ans = Add(ans, sm);
		}
		return ans;
	}
	int getAll(int a) {
		int res = 2;
		res = Add(res, calc1(a));
		res = Add(res, Mul(3, calc2(a)));
		res = Mul(res, inv6);
		return res;
	}
	int calc(int n, int m) {
		if(n == 1) {
			return 0;
		}
		int xs = (n & 1) ? (mod - 1) : 1;
		xs = Mul(xs, (m - 1));
		int vl = qpow(m - 1, n);
		vl = Add(vl, xs);
		return vl;
	}
	int calcans(int n, int x, int All) {
		return Mul(phi(x) % mod, calc(n / x, All) % mod);
	}
	void Exgcd(int a, int b, int &x, int &y) {
		if(!b) {
			x = 1;
			y = 0;
			return ;
		}
		Exgcd(b, a % b, x, y);
		int t = x;
		x = y;
		y = t - a / b * y;
	}
	
	void solve() {
		shai();
		int T, n, a;
		T = read();
		while(T--) {
			n = read();
			a = read();
			if(n % mod == 0) {
				MOD2::solve(n, a);
				continue;
			}
			int All = getAll(a);
			All %= mod;
			int ans = 0;
			for(int i = 1; i * i <= n; ++i) {
				if(n % i != 0) continue;
				ans = Add(ans, calcans(n, i, All));
				if(i * i == n) continue;
				ans = Add(ans, calcans(n, n / i, All));
			}
			ans = Mul(ans, qpow(n, mod - 2));
			write(ans);
			pc('\n');
		}
	}
}
```




---

## 作者：Hyscere (赞：4)

丧心病狂的数论二合一题。。

可以分成两部分来考虑，珠子的种类数和组成环的方案数。

------

**珠子的种类数**

设$s_3$为最多三元环的种类数，即：

$$s_3=\sum_{i=1}^a\sum_{j=1}^a\sum_{k=1}^a[\gcd(i,j,k)=1]$$

$s_2,s_1$依次类推，即：
$$s_2=\sum_{i=1}^a\sum_{j=1}^a[\gcd(i,j)=1],s_1=1$$
可以容斥得到：

总种类数$=1+(3s_2-3)/3+(s_3-(3s_2-3)-1)/6=(s_3+3s_2+2)/6.$

然后莫比乌斯反演求一下$s$就行了，式子：
$$s_3=\sum_{d=1}^a\mu(d)\lfloor\frac{a}{d}\rfloor^3,s_2=\sum_{d=1}^a\mu(d)\lfloor\frac{a}{d}\rfloor^2$$

------

**环的方案数**

设先前求出来的方案数为$m$。

看到环旋转前后属于同一种方案，可以想到$polya$定理：
$$ans=\sum_{i=1}^{n}f(\gcd(n,i))=\sum_{d|n}\varphi(\frac{n}{d})f(d)=\sum_{d|n}\varphi(d)f(\frac{n}{d})$$
由于有限制：相邻的颜色不同，设$f(n)$为$n$个点的环满足条件的涂色方案，则有：
$$f(n)=(m-2)f(n-1)+(m-1)f(n-2)$$
这个式子可以理解为：枚举一个合法方案的断点，两边颜色一定不同，这时候要么当前方案是由$(n-1)$个点组成的，只有$(m-2)$种颜色可选，要么由$(n-2)$个点组成的，加一个与一边相同的点，然后只有$(m-1)$中颜色选。

然后发现这是一个**二阶齐次线性方程**，可以搬出特征方程的套路，设这是一个等比数列，可得特征方程：
$$x^2=(m-2)x+m-1$$
解得：
$$x_1=m-1,x_2=-1$$
设当前数列通项公式为：
$$f(n)=\alpha x_1^n+\beta x_2^n$$
由于：
$$f(1)=0,f(2)=m^2-m$$
列出方程：

$$\alpha(m-1)-\beta=0$$
$$\alpha(m-1)^2+\beta=m^2-m$$

解得$\alpha=1,\beta=m-1$，所以$f$的通项公式为：
$$f(n)=(m-1)^n+(-1)^n(m-1)$$
答案是：
$$\sum_{d|n}\varphi(\frac{n}{d})f(d)$$所以直接一路暴力就好了。

记得$long\,\,long$会乘爆，用爆$long\,\,long$小技巧就好了，具体看代码$mul$函数。

由于$n$有可能是$1e9+7$的倍数，所以特判下，如果是就模$(1e9+7)^2$，最后除掉$1e9+7$即可。

然后细节还有挺多的，，注意下写法，不然调试很恶心。

```c++
#include<bits/stdc++.h>
using namespace std;

#define ll long long 
#define lf long double
#define ull unsigned long long

void read(ll &x) {
	x=0;ll f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}

void print(int x) {
	if(x<0) putchar('-'),x=-x;
	if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define sqr(x) mul(x,x)
#define cul(x) mul(sqr(x),x)

const int maxn = 1e7+10;
const int MOD = 1e9+7;
const int MAXN = 1e4+10;

ll mod;

int pri[maxn],vis[maxn],mu[maxn],tot;

void sieve(int N) {
    mu[1]=1;
    for(int i=2;i<=N;i++) {
        if(!vis[i]) pri[++tot]=i,mu[i]=-1;
        for(int j=1;j<=tot&&i*pri[j]<=N;j++) {
            vis[i*pri[j]]=1;
            if(i%pri[j]==0) break;
            mu[i*pri[j]]=-mu[i];
        }
    }
    for(int i=1;i<=N;i++) mu[i]+=mu[i-1];
}

ll mul(ll a,ll b) {
    lf res=(lf)a*b/mod;
    ll t=a*b,t2=(t-(ull)res*mod+mod)%mod;return t2;
}

ll qpow(ll a,ll x) {
    ll res=1;
    for(;x;x>>=1,a=mul(a,a)) if(x&1) res=mul(res,a);
    return res;
}

ll a[MAXN],p[MAXN],cnt;

ll m,ans,inv6,nown;

void mobius(int n) {
    m=0;int T=1;
    while(T<=n) {
        int pre=T;T=n/(n/T);
        m=(m+1ll*mul((mu[T]-mu[pre-1]),cul(n/T)))%mod;
        m=(m+1ll*mul((mu[T]-mu[pre-1]),sqr(n/T))*3ll%mod)%mod;T++;
    }m=(m+2)%mod;m=mul(m,inv6)%mod;
}

void prepare(ll n) {
    cnt=0;
    for(int i=2;1ll*i*i<=n;i++) {
        if(n%i) continue;
        a[++cnt]=i;p[cnt]=0;
        while(n%i==0) n/=i,p[cnt]++;
    }
    if(n!=1) a[++cnt]=n,p[cnt]=1;
}

ll f(ll n) {
    ll Ans=qpow(m-1,n);
    if(n&1) Ans=(Ans+mod-m+1)%mod;
    else Ans=(Ans+m-1)%mod;
    return Ans;
}

void polya(int now,ll d,ll phi) {
    if(now==cnt+1) return ans=(ans+mul(phi,f(nown/d)))%mod,void();
    polya(now+1,d,phi);
    d*=a[now],phi*=a[now]-1;
    polya(now+1,d,phi);
    for(int i=2;i<=p[now];i++)
        d*=a[now],phi*=a[now],polya(now+1,d,phi);
}

ll inn[20],ina[20],mx,inv[10];

void pre_inv() {
    inv[1]=1;
    for(int i=2;i<=6;i++) inv[i]=mul(mod-mod/i,inv[mod%i]);
    inv6=inv[6];
}

int main() {
    int t;scanf("%d",&t);
    for(int i=1;i<=t;i++) read(inn[i]),read(ina[i]),mx=max(mx,ina[i]);
    sieve(mx);
    for(int i=1;i<=t;i++) {
        nown=inn[i];
        if(inn[i]%MOD) mod=MOD;
        else mod=1ll*MOD*MOD;
        pre_inv();
        mobius(ina[i]);
        prepare(inn[i]);ans=0;
        polya(1,1,1);
        if(inn[i]%MOD) ans=mul(ans,qpow(inn[i],mod-2));
        else ans=mul(ans/MOD,qpow(inn[i]/MOD,MOD-2))%MOD;
        write(ans);
    }
    return 0;
}
```

---

## 作者：_Arahc_ (赞：2)

## 题目大意

题目传送门：[Link to Luogu](https://www.luogu.com.cn/problem/P3307)。

> 定义一个珠子为一个无序三元组 $(x,y,z)$，满足 $0<x,y,z\leqslant a$，且 $\gcd(x,y,z)=1$。
>
> 定义一个合法的项链，满足：项链由 $n$ 个珠子串起来，相邻的珠子不相同。两个项链是一样的当且仅当这两个项链可以经过旋转变成一样的。
>
> 给定 $n,a$，求有多少种合法的项链，对 $10^9+7$ 取模。
>
> $n\leqslant 10^{14},a\leqslant 10^7,T\leqslant 10$。

## 题解

因为“项链”的要求只需要相邻珠子不同，不要求珠子上的数字有什么别的关系，所以这个题是完全割裂的两个问题：

1. 怎么求珠子的数量？
2. 已知珠子的数量，怎么求合法的项链的数量？

### 珠子数量

> 第一小问：定义一个珠子为一个无序三元组 $(x,y,z)$，满足 $0<x,y,z\leqslant a$，且 $\gcd(x,y,z)=1$。
>
> 给定 $a$，求有多少种珠子。

互质这个条件就显得非常数论，然而一般的数论枚举是有序的，因此转化为有序问题：

1. 若 $x\neq y\neq z$，设有序三元组数量为 $a$，则无序三元组数量为 $\frac{a}{3!}=\frac{a}{6}$。
2. 若有两个元素相同，设有序三元组数量为 $a$，则无序三元组数量为 $\frac{a}{\operatorname{A}_3^2}=\frac{a}{3}$。
3. 若 $x=y=z$，因为三个数要互质，显然只有 $(1,1,1)$ 符合条件。

先考虑考虑第二个怎么算，莫反老套路了：
$$
\begin{aligned}
cnt_2 &= 3\sum_{i=1}^a \sum_{j=1}^a [i\neq j][\gcd(i,j)=1] \\
&= -3 + 3\sum_{i=1}^a\sum_{j=1}^a [\gcd(i,j)=1] \\
&= -3 + 3\sum_{i=1}^a \sum_{j=1}^a \sum_{d\mid \gcd(i,j)} \mu(d) \\
&= -3 + 3\sum_{d=1}^a \mu(d) \left\lfloor \frac{a}{d} \right\rfloor^2
\end{aligned}
$$
第一个？同理即可，不多赘述：
$$
\begin{aligned}
cnt_1 &= \sum_{i=1}^a \sum_{j=1}^a \sum_{k=1}^a [i\neq j\neq k][\gcd(i,j,k)=1] \\
&= -1 -cnt_2 + \sum_{d=1}^a \mu(d)\left\lfloor \frac{a}{d} \right\rfloor^3
\end{aligned}
$$
于是这一部分答案为 $\frac{cnt_1}{6} + \frac{cnt_2}{3} + 1$。

### 项链数量

> 第二小问：有 $m$ 种互不相同的珠子，每种无限个。求可以串成多少种本质不同的大小为 $n$ 的项链，要求相邻珠子不同种。两个项链本质相同，当且仅当其旋转后相同。

“本质不同的项链”非常的群论，我们考虑枚举循环节，设 $f_i$ 表示循环节个数为 $i$ 时，不动点的数量：
$$
\begin{aligned}
ans &= \sum_{i=1}^n f(\gcd(i,n)) \\
&= \frac{1}{n} \sum_{d\mid n} \varphi(\frac{n}{d})f(d)
\end{aligned}
$$
考虑 $f_i$ 的现实意义：大小为 $i$ 的合法项链的染色的方案数。考虑如何递推：对于一个大小为 $n-1$ 的合法项链，枚举一个断点，加入一个和两边颜色都不同的珠子；或者对于一个大小为 $n-2$ 的合法项链，先加入一个和一边颜色相同的珠子，然后在两个珠子之间加一个不同的颜色劈开。（因为项链是合法的，因此这两种统计不重）：
$$
f_n = (m-2)f_{n-1} + (m-1)f_{n-2}
$$
边界 $f_1 = 0,f_2 = m(m-1)$。看 $n$ 的范围 $10^{14}$，线性递推就算了吧。因为本人太菜不会常系数齐次线性递推，只能带大家用生成函数乱搞一下。怎么用生成函数求通项公式？写出 OGF、代入递推式（注意边界系数）、求出封闭形式、换另一种方法展开。

我们写出 $f_i$ 的 OGF：
$$
F(x) = \sum_{i=1}^\infty f_ix^i
$$
根据递推式得到：
$$
F(x) = x(m-2)F(x) + x^2(m-1)F(x) + x^2f_2 + xf_1
$$
整理，将 $f_1 = 0,f_2 = m(m-1)$ 代入：
$$
\begin{aligned}
F(x) &= \frac{x^2m(m-1)}{1-[x(m-2)+x^2(m-1)]} \\
&= \frac{x^2m(m-1)}{1-(m-2)x-(m-1)x^2}
\end{aligned}
$$
如何展开？不妨待定系数法，设待定系数 $A,B,a,b$ 满足：
$$
\frac{Ax}{1-ax}+\frac{Bx}{1-bx} = \frac{x^2m(m-1)}{1-(m-2)x-(m-1)x^2}
$$
整理得到：
$$
\frac{(A+B)x - (Ab+aB)x^2}{1-(a+b)x+abx^2} = \frac{x^2m(m-1)}{1-(m-2)x-(m-1)x^2}
$$
于是得到：
$$
\begin{cases}
A+B=0 \\
Ab+aB=-m(m-1) \\
a+b = m-2 \\
ab=-(m-1)
\end{cases}
$$
可以先解出 $a,b$，由第三个式子，$b=m-a-2$，代入第四个式子解一元二次方程：
$$
-a^2 - (2-m)a + m-1 = 0
$$
解二次方程都会吧，因为 $m\geqslant 0$，容易解得 $a_1=m-1,a_2 = -1$。不妨令 $a=m-1,b=-1$。
$$
\begin{cases}
A + B = 0 \\
-A + (m-1) B = m-m^2
\end{cases}
$$
解二元一次方程都会吧，容易解得 $A=m-1,B=1-m$。进一步地，比值为 $p$ 的等比数列的生成函数为 $G(x)=\frac{1}{1-px}$，因此：
$$
\begin{aligned}
F(x) &= x\left(\frac{A}{1-ax}+\frac{B}{1-bx} \right) \\
&= x\left(\frac{m-1}{1-(m-1)x} + \frac{1-m}{1-(-1)x}\right) \\
&= \sum_{i\geqslant 1} x^i\left[(m-1)(m-1)^{i-1} + (1-m)(-1)^{i-1}\right] \\
&= \sum_{i\geqslant 1} x^i \left[ (m-1)^i + (-1)^i(m-1) \right]
\end{aligned}
$$
因此这个序列的通项公式为：
$$
f_n = (m-1)^n + (-1)^n(m-1)
$$
又因为：
$$
ans = \frac{1}{n} \sum_{d\mid n} \varphi(\frac{n}{d})f(d)
$$
于是这个部分也完成了。

### 细节

细节很多，调了一个上午，看题解才豁然开朗。

1. 写这种题就是要像生产队的驴一样——多磨（模）。
2. $n$ 可能是模数的倍数，不能直接乘以 $n$。可以考虑先在模 $mod^2$ 意义下求解，最后在转化为模 $10^9+7$ 的答案。如果你 WA on #3 读到 $0$，就是这个原因。
3. 用上述方法时要么龟速乘要么 `__in128`，像我这种懒人当然选择 `__128` 了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int max_n=10000001,MOD=1000000007;int mod;
inline int read(){
    int x=0;bool w=0;char c=getchar();
    while(c<'0' || c>'9') w|=c=='-',c=getchar();
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
}
inline int mi(int a,int p=mod-2){
    int res=1;
    while(p){
        if(p&1) res=res*a%mod;
        a=a*a%mod,p>>=1;
    }
    return res;
}
struct par{
    int x,y;
};
inline par makep(int a,int b){
    par res;
    res.x=a,res.y=b;
    return res;
}

int n,m,iv6,iv62=833333345000000041LL,iv;

signed pr[max_n/10],mu[max_n],cntp;
bool isp[max_n];

inline void Getprime(int n){
    memset(isp,1,sizeof(isp)),isp[1]=0;
    mu[1]=1;
    for(register int i=2;i<=n;++i){
        if(isp[i]){
            pr[++cntp]=i,
            mu[i]=-1;
        }
        for(register int j=1;j<=cntp && i*pr[j]<=n;++j){
            isp[i*pr[j]]=0;
            if(i%pr[j]==0){
                mu[i*pr[j]]=0;
                break;
            }
            mu[i*pr[j]]=-mu[i];
        }
    }
    for(register int i=1;i<=n;++i)
        mu[i]=mu[i-1]+mu[i];
}

inline int F(int n){
    return (mi(m-1,n)+(n&1?mod-1:1)*(m-1)%mod)%mod;
}

int cnt1,cnt2;

inline int sub1(int a){
    cnt1=cnt2=0;
    for(register int l=1,r,k;l<=a;l=r+1){
        r=(a/(a/l)),k=a/l;
        cnt2=(cnt2+(int)(mu[r]-mu[l-1])*k*k)%mod,
        cnt1=(cnt1+(int)(mu[r]-mu[l-1])*k*k%mod*k)%mod;
    }
    cnt1=(cnt1%mod+mod)%mod,
    cnt2=(cnt2%mod+mod)%mod;

    cnt2=(mod-3+3*cnt2)%mod,
    cnt1=(mod-1-cnt2+cnt1)%mod;
    return (iv6*cnt1+iv6*2*cnt2+1)%mod;
}

int lim,ans;
vector<par> pfac; 

inline void fact(int n){
    pfac.resize(0);
    for(register int i=1;i<=cntp && pr[i]*pr[i]<=n;++i)
        if(n%pr[i]==0){
            int k=0;
            while(n%pr[i]==0)
                n/=pr[i],++k;
            pfac.push_back(makep(pr[i],k));
        }
    if(n>1)
        pfac.push_back(makep(n,1));
    lim=pfac.size();
}

inline void dfs(int l,int a,int phi){
    if(l==lim){
        ans=(ans+phi*F(n/a))%mod;
        return;
    }
    dfs(l+1,a,phi);
    for(register int i=1;i<=pfac[l].y;++i){
        a=a*pfac[l].x;
        phi=phi*(i==1?pfac[l].x-1:pfac[l].x)%mod;
        dfs(l+1,a,phi);
    }
}

inline int sub2(){
    ans=0,fact(n);
    dfs(0,1,1);
    return ans%mod;
}

signed main(){
    mod=MOD,Getprime(10000000),iv=iv6=mi(6);
    for(register int T=read();T>0;--T){
        n=read();bool ok=0;
        if(n%MOD==0) mod=MOD*MOD,iv6=iv62;
        else mod=MOD,ok=1,iv6=iv;
        m=sub1(read());
        int ans=sub2();
        if(!ok) write(ans/MOD*mi(n/MOD)%MOD);
        else write(ans*mi(n%MOD)%MOD);
        putchar('\n');
    }
    return 0;
}
```



---

## 作者：lyx1311 (赞：1)

## $\bf Statement$
给定整数 $n,a$。

定义『好的珠子』由一个无序三元组 $(x_1,x_2,x_3)$ 表示，且满足 $1\le x_i\le a$，$\gcd\{x_1,x_2,x_3\}=1$。

定义『好的项链』是一串由 $n$ 个珠子构成的环，满足相邻两个珠子不同。

试统计本质不同（即循环不同构）的好的项链的个数，答案对 $10^9+7$ 取模。

$T$ 组数据。$n\le10^{14}$，$a\le10^7$，$T\le10$。时限 $3~\text{s}$。

---
## $\bf Solution$
二合一题。

### 统计好的珠子个数
考虑容斥。设 $f(x)$ 表示 $\text{gcd}=x$ 的无序三元组个数，$g(x)$ 表示 $\gcd$ 为 $x$ 的倍数的无序三元组个数。

显然有 $g(d)=\sum_{d|n}f(x)$，由莫比乌斯反演得 $f(d)=\sum_{d|n}\mu(\frac xd)\cdot g(x)$。所以 $f(1)=\sum_{d=1}^a\mu(d)\cdot g(d)$。

求 $g(d)$ 考虑 Polya 引理，显然有 $1$ 种置换有 $3$ 个环，$3$ 种置换有 $2$ 个环，$2$ 种置换有 $1$ 个环。所以设 $m=\left\lfloor\frac ad\right\rfloor$，则 $g(d)=\frac16(m^3+3m^2+2m)$。整除分块即可。

### 统计好的项链个数
考虑 Burnside 引理，设 $f(x)$ 表示长为 $x$ 的相邻、首尾颜色不同的序列个数，则：

$$
\begin{aligned}
\text{ans}&=\frac1n\sum_{i=1}^nf(\gcd\{n,i\})\\
&=\frac1n\sum_{d=1}^n\sum_{i=1}^n[\gcd\{n,i\}=d]\cdot f(d)\\
&=\frac1n\sum_{d|n}\varphi\left(\frac nd\right)\cdot f(d)\\
\end{aligned}
$$

考虑 $f(d)$ 的递推式。记 $c$ 表示颜色个数，分类讨论：

- 如果 $1$ 和 $d-1$ 颜色相同，方案数为 $f(d-2)\cdot(c-1)$。
- 否则颜色不同，方案数为 $f(d-1)\cdot(c-2)$。
  

所以得到：

$$
f(x)=\begin{cases}
0,&x=1\\
c\cdot(c-1),&x=2\\
f(x-2)\cdot(c-1)+f(x-1)\cdot(c-2),&x\ge3
\end{cases}
$$

但 $n$ 太大了，递推显然不行。考虑求出通项：

$$
\begin{aligned}
f(x)&=f(x-2)\cdot(c-1)+f(x-1)\cdot(c-2)\\
f(x)+f(x-1)&=f(x-2)\cdot(c-1)+f(x-1)\cdot(c-1)\\
\end{aligned}
$$

设 $g(x)=f(x)+f(x-1)$，则有：

$$
\begin{aligned}
g(x)&=(c-1)\cdot g(x-1)\\
&=(c-1)^{x-2}g(2)\\
&=(c-1)^{x-2}f(2)
\end{aligned}
$$

然后 $f(x)=g(x)-g(x-1)+g(x-2)-g(x-3)+\cdots$，等比数列求和即可。

得到通项是 $f(x)=(c-1)^x+(-1)^x\cdot(c-1)$。代回上面 $\text{ans}$ 的式子即可。

实现时注意两点：

- 因为 $n$ 太大了，DFS 按唯一分解定理枚举质因数的幂次，来枚举约数 $\frac nd$ 并维护 $\varphi(d)$。
- 有一种烦人的情况是，可能 $(10^9+7)|n$。所以把所有模数改成 $(10^9+7)^2$ 做，这样能保证余数不变。因为此时 $\text{ans}$ 一定是 $n$ 的倍数，最后再分别除掉 $10^9+7$ 和 $\frac n{10^9+7}$ 即可。注意 $6$ 对 $(10^9+7)^2$ 的逆元要用欧拉定理求。

---
## $\bf Code$
实现的时候，偷懒可以用 `__int128`。不然只能龟速乘了。

**[完整代码 on Hydro](https://hydro.ac/d/bzoj/record/62d6026cb36e4a12382eccbd)**


---

## 作者：zhiyangfan (赞：1)

## P3307 [SDOI2013]项链 题解
数论绝赞二合一！

可以发现，这道题很明显被分为了两个部分：
- 求珠子有多少种。
- 求用这些珠子能组成多少项链。

发现两个问题都是旋转（翻转）同构，所以考虑 $\rm Burnside$ 引理。具体来讲，$\rm Burnside$ 引理说的是，对于一个置换群 $\mathcal{P}$，作用在某个集合上，得到本质不同的元素个数为：
$$\dfrac{1}{|\mathcal{P}|}\sum_{p\in\mathcal{P}}c(p)$$
其中 $c(p)$ 表示在置换 $p$ 下，集合内不动点的个数。

对于这道题，先来看看求珠子种类的部分。因为只有 $3$ 个位置，所以我们很轻松可以列出所有置换：
$$\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix},\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}$$
共 $6$ 个。其中有 $2$ 个置换的不动点要求所有数都相同，$3$ 个要求至少两个数相同，$1$ 个对于数不做限制。

根据简单的莫反，容易发现：
- 所有数都相同：$\sum\limits_{i=1}^a[i=1]=\sum\limits_{p=1}^a\mu(p)\lfloor\frac{a}{p}\rfloor$
- 至少两个数相同：$\sum\limits_{i=1}^a\sum\limits_{j=1}^a[\gcd(i,j)=1]=\sum\limits_{p=1}^a\mu(p)\lfloor\frac{a}{p}\rfloor^2$
- 对数不做限制：$\sum\limits_{i=1}^a\sum\limits_{j=1}^a\sum\limits_{k=1}^a[\gcd(i,j,k)=1]=\sum\limits_{p=1}^a\mu(p)\lfloor\frac{a}{p}\rfloor^3$

求和可得珠子的种类数为：
$$\dfrac{1}{6}\sum_{p=1}^a\mu(p)\left(2\left\lfloor\frac{a}{p}\right\rfloor+3\left\lfloor\frac{a}{p}\right\rfloor^2+\left\lfloor\frac{a}{p}\right\rfloor^3\right)$$
整除分块即可。

考虑记上面的式子为 $c$，则第二个问题变为，共 $c$ 种颜色，给项链涂色，问最多能涂出多少种旋转不同构，且相邻项颜色不同的项链。这就是比较经典的群论计数，继续考虑 $\rm Burnside$。但这次，我们好像不能把相邻两项颜色不同这个限制用置换表示了，那考虑先不管，只说旋转的事。观察 $\rm Burnside$ 的式子：
$$\dfrac{1}{n}\sum_{i=1}^nc(p_i)$$

在旋转 $i$ 步的置换下的不动点，是置换环上所有的点颜色都相同，且如果把第 $1\sim t(p)$ 个珠子拿出来，它们满足相邻项，首尾项颜色不同，其中 $t(p)$ 表示 $p$ 的置换环个数。这是因为考虑旋转的置换环如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/t7v76qkr.png)

容易发现后面的珠子都是对前 $t(p)$ 个珠子的循环。而又有经典结论旋转 $i$ 步的置换，置换环个数为 $\gcd(i,n)$。所以方案数为
$$\dfrac{1}{n}\sum_{i=1}^nf(\gcd(i,n),c)$$
其中 $f(x,y)$ 表示用 $y$ 种颜色涂长为 $x$ 的序列，相邻，首尾颜色不同的方案数。简单证一下经典结论。注意到旋转 $i$ 步后，置换上的对应关系为 $j$ 与 $j+i$ 对应。而在长度为 $n$ 的环上一次走 $i$ 步，走 $\frac{\operatorname{lcm}(i,n)}{i}$ 步就会走回来。（此时第一次满足走的长度模 $n$ 为 $0$）这样，每个置换环的长度均为 $\frac{\operatorname{lcm}(i,n)}{i}$，所以置换环的个数为 $\frac{n}{\frac{\operatorname{lcm}(i,n)}{i}}=\gcd(i,n)$。

言归正传，对上面的式子莫反一下可以得到：
$$\dfrac{1}{n}\sum_{d|n}f(d,c)\varphi\left(\dfrac{n}{d}\right)$$

现在有俩问题。首先 $n$ 是 $10^{14}$ 级别的，$\varphi$ 不好求。然后，$f(x,y)$ 不知道怎么求。

但我们发现，求的 $\varphi$ 是 $n$ 的所有因数，所以可以化为如下形式：
$$\prod_{p}p^{i_p-1}(p-1+[i_p=0])(i_p\le l_p)$$
其中定义 $n=\prod\limits_{p}p^{l_p}$。考虑搜索出所有 $n$ 的因数，然后根据它们的质因数的指数算出结果即可。时间复杂度仅为 $\mathcal{O}(d(n))$。

然后是 $f(x,y)$，设序列为 $a$，考虑讨论 $a_x$ 填怎么填。如果 $a_{x-1}=a_1$，则 $a_x$ 有 $y-1$ 种填法，此时剩下的数有 $f(x-2,y)$ 种。如果 $a_{x-1}\ne a_1$，则 $a_x$ 有 $y-2$ 种，剩下的数有 $f(x-1,y)$ 种。即：
$$f(x,y)=(y-1)f(x-2,y)+(y-2)f(x-1,y)$$
当然，因为本题 $y$ 只能为 $c$，所以还能进一步化简为：
$$g(x)=(c-1)g(x-2)+(c-2)g(x-1),g(1)=0,g(2)=c(c-1)$$
发现是常系数齐次线性递推的形式，[可以用 GF 推出](https://www.luogu.com.cn/paste/ic6s5egk) 下面的封闭形式：
$$g(n)=(c-1)^{n}+(1-c)(-1)^{n-1}$$
可以 $\mathcal{O}(\log n)$ 计算。

这样，这题就快做完了。我们已经可以求 $c$ 和 $\sum\limits_{d|n}f(d,c)\varphi\left(\dfrac{n}{d}\right)$ 了。但距离最后的答案还差一步，$\frac{1}{n}$。

注意到 $n\le 10^{14}$，而模数只有 $10^9+7$，说明可能出现 $mod|n$ 的情况。而此时，逆元是不存在的。

考虑最后的答案，形如 $b=a\times mod+r$，我们想知道的是 $r$。但现在我们只有 $b\times n$ 的结果，且 $mod|n$。考虑把 $b\times n$ 表示为 $a'\times mod^2+r'$，两边同除 $mod$ 可以得到：
$$\dfrac{b\times n}{mod}=a'\times mod+\dfrac{r'}{mod}$$
因为左边一定是整数，所以右边的 $r'$ 一定满足 $mod|r'$。而此时，$r$ 就可以被表示为：
$$r=\dfrac{r'}{mod}\times\left(\dfrac{n}{mod}\right)^{-1}$$
其中 $(\frac{n}{mod})^{-1}$ 为 $\frac{n}{mod}$ 在模 $mod$ 意义下的逆元，因为 $n<mod^2$，所以这个逆元一定存在。我们也就得到答案了。

注意模 $mod^2$ 中途运算要开 `__int128` ，或用龟速乘，或者黑科技。总时间复杂度 $\mathcal{O}(\sqrt{a}+d(n)\log n)$。
```cpp
#include <cstdio>
#include <vector>
typedef __int128_t i128; typedef long long ll;
const int Mod = 1e9 + 7; ll mod; const int N = 1e7 + 10;
int p[N], mu[N], tp; bool vis[N]; ll c;
const int inv61 = 166666668; const ll inv62 = 833333345000000041;
std::vector<std::pair<ll, int>> v; std::vector<std::pair<ll, ll>> vec;
inline void pre(int n)
{
	mu[1] = 1;
	for (int i = 2; i <= n; ++i)
	{
		if (!vis[i]) p[++tp] = i, mu[i] = -1;
		for (int j = 1; j <= tp && i * p[j] <= n; ++j)
		{
			vis[i * p[j]] = true;
			if (i % p[j] == 0) { mu[i * p[j]] = 0; break; }
			mu[i * p[j]] = -mu[i];
		}
	}
	for (int i = 1; i <= n; ++i) mu[i] += mu[i - 1];
}
inline ll ksm(ll a, ll b)
{
	ll ret = 1;
	while (b)
	{
		if (b & 1) ret = (i128)ret * a % mod;
		a = (i128)a * a % mod; b >>= 1;
	}
	return ret;
}
void dfs(ll now, ll phi, int step)
{
	if (step == (int)v.size()) return vec.emplace_back(now, phi), void();
	ll x = 1, p = v[step].first;
	for (int i = 0; i <= v[step].second; ++i, x *= p) dfs(now * x, phi * (!i ? 1 : (x - x / p)), step + 1);
}
inline ll f(ll n) { return (ksm(c - 1, n) + (n & 1 ? (mod - (c - 1)) : (c - 1))) % mod; }
int main()
{	
	int qwq; scanf("%d", &qwq); pre(N - 1);
	while (qwq--)
	{
		ll n; c = 0; int a, flg; scanf("%lld%d", &n, &a); flg = !(n % Mod);
		flg ? mod = (ll)Mod * Mod : mod = Mod;
		for (int l = 1, r, d; l <= a; l = r + 1)
		{
			d = a / l; r = a / d;
			(c += (i128)(mod + mu[r] - mu[l - 1]) % mod * 
			(2 * d + 3ll * d * d % mod + (i128)d * d % mod * d % mod) % mod) %= mod;
		}
		c = (i128)c * (flg ? inv62 : inv61) % mod;
		ll x = n; v.clear();
		for (ll i = 2; i * i <= n; ++i)
		{
			if (x % i) continue;
			v.emplace_back(i, 0);
			while (x % i == 0) ++v.back().second, x /= i;
		}
		if (x > 1) v.emplace_back(x, 1);
		vec.clear(); dfs(1, 1, 0); ll ans = 0;
		for (auto x : vec) (ans += (i128)x.second * f(n / x.first) % mod) %= mod;
		if (flg) ans /= Mod, mod = Mod, ans = ans * ksm(n / mod, mod - 2) % mod;
		else ans = ans * ksm(n, mod - 2) % mod;
		printf("%lld\n", ans);
	} 
	return 0;
}
```

---

## 作者：D0000 (赞：0)

不熟悉 Burnside 引理、莫比乌斯函数、数论分块、常系数齐次线性递推的话建议先学习

先计算本质不同珠子的数量 $R$（使用 Burnside 引理、莫比乌斯反演）：
$$\begin{aligned}R&={1\over 6}(1+1+3\sum_{i=1}^a\sum_{j=1}^a[\gcd(i,j)=1]+\sum_{i=1}^a\sum_{j=1}^a\sum_{k=1}^a[\gcd(i,j,k)=1])\\&={1\over 6}(1+1+3\sum_{i=1}^a\sum_{j=1}^a\sum_{d|i,d|j}\mu(d)+\sum_{i=1}^a\sum_{j=1}^a\sum_{k=1}^a\sum_{ d|i,d|j,d|k}\mu(d))\\&={1\over 6}(1+1+\sum_{d=1}^n({\lfloor{n\over d}\rfloor}^3+{3\lfloor{n\over d}\rfloor}^2)\end{aligned}$$

可以使用数论分块在 $O(\sqrt a)$ 算出 $R$。

在不考虑旋转同构的情况下，把项链改为序列的答案：

$$g(n)=R(R-1)^{n-1}$$

在不考虑旋转同构的情况下的答案为：

$$\begin{aligned}f(n)&=(R-2)f(n-1)+(g(n-1)-f(n-1))(R-1)\\&=g(n)-f(n-1)\\&=R(R-1)^{n-1}-f(n-1)\\&=R(R-1)^{n-1}-(R-1)f(n-1)+(R-2)f(n-1)\\&=R(R-1)^{n-1}-R(R-1)^{n-1}+(R-1)f(n-2)+(R-2)f(n-1)\\&=(R-1)f(n-2)+(R-2)f(n-1)\end{aligned}$$

列出特征方程：

$$x^2-(R-2)x-(R-1)=0$$

解得：

$$x=-1\text{ 或 }R-1$$

因此：

$$\begin{aligned}f(n)&=a(-1)^n+b(R-1)^n\\&=(R-1)(-1)^n+(R-1)^n\end{aligned}$$

$f$ 可使用 $O(\sqrt n)$ 预处理，$O(1)$ 查询得到。

最后再套一次 Burnside 引理，答案就是：

$$\begin{aligned}ans&={1\over n}\sum_{i=0}^{n-1}f(\gcd(n,i))\\&={1\over n}\sum_{d|n}f(d)\varphi({n\over d})\end{aligned}$$

注意到要求的 $\varphi$ 全部是 $n$ 的因数，好求。

总时间复杂度 $O(\sqrt a+\sqrt n)$。

---

## 作者：littlez_meow (赞：0)

算是一道比较经典的群论了。

[题目指路](https://www.luogu.com.cn/problem/P3307)。

### 题意

求满足以下条件的本质不同序列数量：

1. 序列由 $n$ 个三元可重集构成，相邻两个三元可重集不同。

2. 每个三元可重集内元素的值域为 $[1,a]\cap\mathbb Z$，且三个元素的最大公约数为 $1$。

两个序列本质相同，当且仅当一个序列经过若干次轮换后可以得到另一个。

### 思路

本质不同环的计数，想群论。

这道题和[这个](https://www.luogu.com.cn/problem/P5233)没什么太大区别。

还是分成两个部分，三元可重集计数和环计数。

无序集合是非常麻烦的，先计数有序再去重。

直接计数满足条件的有序三元组数量，为 $\sum\limits_{i=1}^a\sum\limits_{j=1}^a\sum\limits_{k=1}^a[\gcd(i,j,k)=1]$，莫反得到 $\sum\limits_{i=1}^a\mu(i)\lfloor\dfrac a i\rfloor^3$，再乘 $\dfrac 1 6$ 去掉顺序。

这样是对的吗？不是。因为对于形如 $(a,b,b)$ 的三元组，其只被重复算了三次，即 $(i,j,j),(j,i,j),(j,j,i)$，但我们当作它重复算了六次，还要补上多除掉的 $2$。也就是说，我们还要加上 $\dfrac 1 2\sum\limits_{i=1}^a\sum\limits_{j=1}^a[\gcd(i,j)=1]=\dfrac 1 2\sum\limits_{i=1}^a\mu(i)\lfloor\dfrac a i\rfloor^2$。

同理，三个全部相同 $(1,1,1)$ 的又被少算了 $\dfrac 1 3$，因此答案还需加 $\dfrac 1 3$。

所以，一共有 $\dfrac 1 6(2+\sum\limits_{i=1}^a\mu(i)\lfloor\dfrac a i\rfloor^2(\lfloor\dfrac a i\rfloor^+3))$ 种三元可重集，记这个数为 $m$。线性筛 $\mu(1)\sim\mu(a)$，每次整除分块即可。

然后再是环的计数，简单推导一下。

设 $f(t)$ 表示在不考虑循环同构的情况下的 $t$ 个元素的答案。对于一个旋转 $i$ 位的置换，其不动点有 $f(\gcd(i,t))$ 个。根据 Burnside 引理（也可以理解成组合意义），有考虑旋转同构时的答案为 $\dfrac 1 n\sum\limits_{i=1}^nf(\gcd(i,n))$。

枚举 $\gcd$ 的值得到上式等于：$\dfrac 1 n\sum\limits_{d|n}\sum\limits_{i=1}^nf(d)[\gcd(i,n)=d]$。

变枚举 $i$ 为枚举 $\dfrac i d$,使用乘法分配律：$\dfrac 1 n\sum\limits_{d|n}f(d)\sum\limits_{i=1}^{\frac n d}[\gcd(i,\dfrac n d)=1]$。

代入 $\varphi$ 的定义，得到答案为 $\dfrac 1 n\sum\limits_{d|n}f(d)\varphi(\dfrac n d)$。

可以用[这道题的 trick](https://www.luogu.com.cn/problem/P7454)避开线性筛 $\varphi$ 枚举因数。

最后，我们需要求 $f(t)$。可以容斥，为链上相邻不同的情况减去两端相同的情况。

链上不相同的情况为 $m(m-1)^{t-1}$，因为第一个有 $m$ 种选法，后面每个都和前一个不同，只有 $m-1$ 种选法。

两端相同的情况，可以把两端看成是同一个点，为 $f(t-1)$。

故 $f(t)=m(m-1)^{t-1}-f(t-1)$。打表找规律可得 $f(t)=(m-1)^t+(-1)^t(m-1)$。

该式子在 $t=1$ 时显然。假设在 $t=i$ 时该式成立，下证在 $t=i+1$ 时也成立。

写出递推式：$f(i+1)=m(m-1)^{i}-f(i)$。

代入 $f(i)=(m-1)^i+(-1)^i(m-1)$ 得到：$f(i+1)=m(m-1)^{i}-(m-1)^i+(-1)^{i+1}(m-1)$。

乘法分配律得到：$f(i+1)=(m-1)^{i+1}+(-1)^{i+1}(m-1)$。

得证。

所以 $f(t)=(m-1)^t+(-1)^t(m-1)$。直接展开然后等比数列求和也能证。

复杂度 $O(a+T(\sqrt a+\sqrt n\log n))$，分别是线性筛 $\mu$、整除分块、枚举因数和快速幂计算 $f$。

注意可能会有 $(10^9+7)|n$ 导致没有逆元。由于 $n$ 是答案的因数，此时答案肯定也能被 $10^9+7$ 整除且不能被 $(10^9+7)^2$ 整除。我们对 $(10^9+7)^2$ 取模，最后肯定会剩下 $10^9+7$ 的倍数。让 $n$ 和这个值同时除掉 $10^9+7$，然后就可以求逆元了。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
#define fir first
#define sec second
using namespace std;
const int MAXA=1e7+1;
vector<int>prime;
int mu[MAXA],v[MAXA];
inline void init(){
	mu[1]=v[1]=1;
	F(i,2,MAXA-1){
		!v[i]&&(prime.push_back(i),v[i]=i,mu[i]=-1);
		for(int j:prime){
			int k=i*j;
			if(k>=MAXA) break;
			v[k]=j;
			if(j==v[i]) break;
			else mu[k]=-mu[i];
		}
	}
	F(i,1,MAXA-1) mu[i]+=mu[i-1];
	return;
}
int a;
ll n;
vector<pair<ll,int> >fac;
int tot;
inline void factorize(ll qwq){
	fac.clear();
	tot=0;
	for(ll i(2);i*i<=qwq;++i){
		if(qwq%i) continue;
		int cnt(0);
		while(!(qwq%i)) qwq/=i,++cnt;
		fac.push_back({i,cnt});
		++tot;
	}
	if(qwq!=1) fac.push_back({qwq,1}),++tot;
	return;
}
namespace Normal{
	const int MOD=1e9+7,INV6=166666668;
	int ans,m;
	inline ll qpow(ll base,ll expo){
		ll res(1);
		base%=MOD;
		while(expo){
			(expo&1)&&(res=res*base%MOD);
			base=base*base%MOD,expo>>=1;
		}
		return res;
	}
	inline ll f(ll t){
		ll qwq=qpow(m-1,t);
		if(t&1) (qwq-=(m-1))<0&&(qwq+=MOD);
		else (qwq+=(m-1))>=MOD&&(qwq-=MOD);
		return qwq;
	}
	inline ll calc(ll t){
		return t*t%MOD*(t+3)%MOD;
	}
	void dfs(int step,ll now=1,ll phi=1){
		if(step==tot){
			ans=(ans+phi%MOD*f(n/now))%MOD;
			return;
		}
		ll p(fac[step].fir);
		dfs(step+1,now,phi);
		phi*=(p-1);
		F(i,1,fac[step].sec){
			now*=p;
			dfs(step+1,now,phi);
			phi*=p;
		}
		return;
	}
	inline void solve(){
		ans=m=0;
		for(int l(1),r;l<=a;l=r+1){
			int t=a/l;
			r=a/t;
			m=(m+(mu[r]-mu[l-1])*calc(t))%MOD;
		}
		(m=(m+2ll)*INV6%MOD)<0&&(m+=MOD);
		dfs(0);
		ans=ans*qpow(n,MOD-2)%MOD;
		cout<<ans<<"\n";
	}
}
namespace Special{
	const ll MOD=1000000014000000049,INV6=833333345000000041;
	ll ans,m;
	inline ll mul(ll x,ll y){
		return x*(__int128)y%MOD;
	}
	inline ll qpow(ll base,ll expo){
		ll res(1);
		base%=MOD;
		while(expo){
			(expo&1)&&(res=mul(res,base));
			base=mul(base,base),expo>>=1;
		}
		return res;
	}
	inline ll f(ll t){
		ll qwq=qpow(m-1,t);
		if(t&1) (qwq-=(m-1))<0&&(qwq+=MOD);
		else (qwq+=(m-1))>=MOD&&(qwq-=MOD);
		return qwq;
	}
	inline ll calc(int t){
		return mul(mul(t,t),t+3);
	}
	void dfs(int step,ll now=1,ll phi=1){
		if(step==tot){
			(ans+=mul(phi,f(n/now)))>=MOD&&(ans-=MOD);
			return;
		}
		ll p(fac[step].fir);
		dfs(step+1,now,phi);
		phi*=(p-1);
		F(i,1,fac[step].sec){
			now*=p;
			dfs(step+1,now,phi);
			phi*=p;
		}
		return;
	}
	inline void solve(){
		ans=m=0;
		for(int l(1),r;l<=a;l=r+1){
			int t=a/l;
			r=a/t;
			m=(m+mul(mu[r]-mu[l-1],calc(t)))%MOD;
		}
		(m=mul(m+2,INV6))<0&&(m+=MOD);
		dfs(0);
		ans/=Normal::MOD,n/=Normal::MOD;
		ans=ans*Normal::qpow(n,MOD-2)%Normal::MOD;
		cout<<ans<<"\n";
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	init();
	int T;
	for(cin>>T;T;--T){
		cin>>n>>a;
		factorize(n);
		if(n%Normal::MOD) Normal::solve();
		else Special::solve();
	}
	return 0;
} 
```

---

## 作者：Caiest_Oier (赞：0)

# [P3307](https://www.luogu.com.cn/problem/P3307)   

首先将题目分成两部分，一部分是计算珠子种类数，一部分是计算项链个数。      

先考虑珠子种类数。题目条件是三个数互质，我们令 $f_i$ 表示三个数都是 $i$ 的倍数的无序三元组个数，则答案就是 $\sum{f_i\mu(i)}$。而 $f(i)$ 相当于在 $\lfloor\frac{a}{i}\rfloor$ 内选无序三元组，这也是好求的，考虑对有序三元组，有序二元组，有序一元组容斥，得到 $\frac{x^3+3x^2+2x}{6}$，其中 $x=\lfloor\frac{a}{i}\rfloor$。这里可以用整除分块加速计算（我懒所以没写）。     

令珠子种类数为 $m$，则项链个数可以使用 Burnside 引理计算，即 $\frac{1}{n}\sum_{g\in G}{|X^g|}$，$G$ 是由循环操作构成的置换群，则对于一个旋转 $k$ 格的循环操作，分为了 $\gcd(k,n)$ 个等价类，容易发现这些等价类是相邻的，于是就是长为 $\gcd(k,n)$，颜色数为 $m$ 且相邻不同的环个数。       

令长为 $x$ 的环个数为 $f(x)$，考虑第 $x-1$ 个珠子与第一个珠子颜色是否相同，有 $f(x)=m(m-1)f(x-2)+(m-2)f(x-1)$，经过神秘的找规律可以发现 $f(x)=(m-1)^x+(-1)^x(m-1)$。     

需要注意 $n$ 会比模数大，这时候求 $n$ 的逆元会出问题，所以应该在 $MOD^2$ 下做计算。      

代码：    

```cpp
#include<bits/stdc++.h>
#define int long long
#define MOD 1000000014000000049ll
using namespace std;
int fst(int X,int Y){
	int ret=0,bse=X%MOD;
	while(Y){
		if(Y%2==1)ret=(ret+bse)%MOD;
		bse=(bse+bse)%MOD;
		Y/=2;
	}
	return ret;
}
int fstp(int X,int Y){
	int ret=1,bse=X%MOD;
	while(Y){
		if(Y%2==1)ret=fst(ret,bse);
		bse=fst(bse,bse);
		Y/=2;
	}
	return ret;
}
int T,n,a,m,ans,k1,k2,k3,k4,k5,k6,k7,k8,k9,ny6;
int pri[5000003],totp,g[10000003];
short miu[10000003];
char isp[10000003];
int stk[5003][2],tot;
int f(int X){
	if(X%2==0)return (fstp(m-1,X)+(m-1))%MOD;
	return (fstp(m-1,X)-((m-1)%MOD)+MOD)%MOD;
}
void dfs(int now,int val,int phi){
	if(now==tot+1){
		ans=(ans+fst(f(n/val),phi))%MOD;
		return;
	}
	dfs(now+1,val,phi);
	for(int i=1;i<=stk[now][1];i++){
		val=val*stk[now][0];
		phi=phi*stk[now][0];
		if(i==1){
			phi=phi/stk[now][0];
			phi=phi*(stk[now][0]-1);
		}
		dfs(now+1,val,phi);
	}
	return;
}
int G(int X){
	X%=MOD;
	int ret=fst(fst(X,X),X);
	ret=(ret+fst(X,X)*3ll)%MOD;
	ret=(ret+X*2ll)%MOD;
	return fst(ny6,ret)%MOD;
}
void calc(){
	for(int i=1;i<=a;i++){
		if(i!=1&&(a/i)==(a/(i-1)))g[i]=g[i-1];
		else g[i]=G(a/i);
	}
	for(int i=1;i<=a;i++)m=(m+miu[i]*g[i])%MOD;
	m%=MOD;
	m+=MOD;
	m%=MOD;
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	ny6=fstp(6,1000000007ll*1000000006ll-1);
	miu[1]=1;
	for(int i=2;i<=10000000;i++){
		if(!isp[i])pri[++totp]=i,miu[i]=-1;
		for(int j=1;j<=totp;j++){
			if(pri[j]*i>10000000)break;
			isp[pri[j]*i]=1;
			miu[pri[j]*i]=miu[i]*-1;
			if(i%pri[j]==0){
				miu[pri[j]*i]=0;
				break;
			}
		}
	}
	cin>>T;
	while(T--){
		cin>>n>>a;
		ans=0;
		m=0;
		calc();
		tot=0;
		k1=n;
		for(int i=1;i<=totp;i++){
			if(pri[i]*pri[i]>k1)break;
			if(k1%pri[i]!=0)continue;
			stk[++tot][0]=pri[i];
			stk[tot][1]=0;
			while(k1%pri[i]==0){
				stk[tot][1]++;
				k1/=pri[i];
			}
		}
		if(k1!=1){
			stk[++tot][0]=k1;
			stk[tot][1]=1;
		}
		dfs(1,1,1);
		if(n%1000000007==0){
			ans/=1000000007;
			n/=1000000007;
		}
		ans=fst(ans,fstp(n,MOD-2));
		ans%=MOD;
		ans+=MOD;
		ans%=MOD;
		ans%=1000000007;
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：tzc_wk (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P3307)

看到题目我们显然可以将题目拆分成两部分：首先求出有多少个符合要求的珠子 $c$，这样我们就可以将每种珠子看成一种颜色，题目也就等价于有多少种用 $c$ 种颜色染长度为 $n$ 的环的方法，满足相邻格子颜色不同，可以通过旋转重合的染色方案算同一种，这就是题目的第二部分。显然两部分是独立的，因此可以分开来计算。

首先考虑怎样求出 $c$ 的值，注意到这里涉及 $\gcd$，故可以套路地想到莫比乌斯反演，记 $f(i)$ 为珠子上三个数 $\gcd$ 恰好为 $i$ 的方案数，$g(i)$ 为珠子上三个数 $\gcd$ 为 $i$ 的倍数的方案数，那么显然有 $g(i)=\sum\limits_{i\mid j}f(j)$，莫反一下显然有 $f(i)=\sum\limits_{i\mid j}\mu(\dfrac{j}{i})g(j)$，最终答案 $c=f(1)=\sum\limits_{i=1}^a\mu(i)g(i)$，故只需求出 $g(i)$ 即可求出 $f(1)$，接下来考虑怎样求出 $g(i)$，由于珠子上三个数都是 $i$ 的倍数，那么该值就等价于珠子上三个数都不超过 $m=\lfloor\dfrac{a}{i}\rfloor$ 的方案数，而由于此题要求本质不同的珠子个数，故考虑 Burnside 定理，假设珠子上三个数为 $(a,b,c)$，那么 $(a,b,c)$ 与 $(a,c,b),(b,a,c),(b,c,a),(c,a,b),(c,b,a)$ 是本质上相同的，即 $(a,b,c)\times p$，其中 $p$ 是可以是任意一个三阶置换，我们对于每个 $p$ 都构造一个以小置换 $(a,b,c)$ 为元素的大置换 $P_p$，其中 $(a,b,c)$ 在 $P_p$ 中对应的元素为 $(a,b,c)\times p$，那么显然这 $3!=6$ 个大置换构成了一个置换群，我们要求的即为这个置换群中等价类的个数，而由 Burnside 定理其就等于 $\dfrac{1}{6}\sum\limits_{p}c(P_p)$，再由 Polya 定理 $P_p$ 中不动点的个数就是 $m^{p\text{中置换环的个数}}$，故 $g(i)=\dfrac{1}{6}(2m+3m^2+m^3)$，整除分块一下即可在 $\sqrt{a}$ 的时间内求出 $c$（虽然不用整除分块问题也不大）

接下来考虑题目的第二部分，我们将全部 $c$ 种珠子编号 $1,2,\cdots,c$，那么题目等价于求有多少种用 $c$ 种颜色染长度为 $n$ 的环的方法，满足相邻格子颜色不同，可以通过旋转重合的染色方案算同一种。看到本质不同，继续考虑 Burnside 定理，根据模板题的套路它就等于 $\dfrac{1}{n}\sum\limits_{d\mid n}\varphi(\dfrac{n}{d})q(d)$，其中 $q(d)$ 为用 $c$ 种颜色染长度为 $d$ 的纸片，满足相邻格子颜色不同，首尾格子颜色也不同的方案数。首先考虑怎样求出 $\varphi(\dfrac{n}{d})$，暴力 $\sqrt{n}$ 求复杂度会达到 $d(n)\sqrt{n}$，无法通过，不过我们发现我们计算的 $\varphi(i)$ 都是 $n$ 的因数，故考虑将 $n$ 分解质因数，然后一遍 DFS 预处理出所有 $n$ 的因数的 $\varphi$，用 `std::map` 存储，这样复杂度可降到 $\sqrt{n}+d(n)\log n$。最后考虑怎样求 $p(d)$，一个很 naive 的想法是 $p(d)=c(c-2)(c-1)^{d-2}$，不过这显然是错误的，因为对于第一个格子的颜色与第 $d-1$ 个格子颜色相同与不同的情况，第 $d$ 个格子染色的方案数也是不同的，因此考虑分两种情况讨论，若第一个格子的颜色与第 $d-1$ 个格子颜色相同，那么可视作对于长度为 $d-2$ 的纸片，将最后一个格子劈成两份，并拿一份放到开头，再在中间插入一个格子，即 $p(d)\leftarrow p(d-2)\times(c-1)$，若第一个格子的颜色与第 $d-1$ 个格子颜色不同，那么可视作对于长度为 $d-1$ 的纸片，在最后一个格子后面插入一个格子，即 $p(d)\leftarrow p(d-1)\times(c-2)$。故 $p(d)=p(d-2)\times(c-1)+p(d-1)\times(c-2)$，特征根方程推推，$x^2-(c-2)x-(c-1)=0$，解得 $x_1=-1,x_2=c-1$，待定系数法设 $p(d)=\alpha(-1)^{d}+\beta(c-1)^d$，那么显然 $p(1)=0,p(2)=c(c-1)$，故 $\begin{cases}\beta(c-1)-\alpha=0\\\beta(c-1)^2+\alpha=c(c-1)\end{cases}$，解得 $\begin{cases}\alpha=c-1\\\beta=1\end{cases}$，故 $p(d)=(c-1)(-1)^d+(c-1)^d$，大功告成。

最后还有一点，就是由于 $n\le 10^{14}$，可能出现 $(10^9+7)\mid n$ 的情况，这种情况下 $n$ 不存在 $\mod 10^9+7$ 意义下的逆元，因此需将模数变为 $(10^9+7)^2$，这样在最后乘以 $\dfrac{1}{n}$ 之前的答案 $ans$ 一定是 $10^9+7$ 的倍数，这样我们只需将 $ans$ 除以 $10^9+7$，然后再乘上 $\dfrac{n}{10^9+7}$ 的逆元即可，这时候需要写龟速乘，否则会爆 ll。

```cpp
const int MAXV=1e7;
int mu[MAXV+5],pr[MAXV/10+5],prcnt=0,sum[MAXV+5];
bitset<MAXV+5> vis;
void sieve(int n){
	mu[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]){pr[++prcnt]=i;mu[i]=-1;}
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j]==0) break;
			mu[i*pr[j]]=-mu[i];
		}
	}
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+mu[i];
}
ll smul(ll x,ll y,ll mod){
	if(x<0) x=(x%mod+mod)%mod;
	if(y<0) y=(y%mod+mod)%mod;
	ll ret=0;
	for(;y;y>>=1,x=(x+x)%mod) if(y&1) ret=(ret+x)%mod;
	return ret;
}
ll qpow(ll x,ll e,ll mod){
	ll ret=1;
	for(;e;e>>=1,x=smul(x,x,mod)) if(e&1) ret=smul(ret,x,mod);
	return ret;
}
const ll MOD1=1e9+7;
const ll MOD2=MOD1*MOD1;
ll INV6_1=qpow(6,MOD1-2,MOD1);
ll INV6_2=qpow(6,MOD1*(MOD1-1)-1,MOD2);
ll MOD,INV6;map<ll,ll> phi;
void dfs(int x,vector<pair<ll,int> > fac,ll mul,ll phim){
	if(x==fac.size()) return phi[mul]=phim,void();
	for(int i=0;i<=fac[x].se;i++){
		if(i){
			mul=mul*fac[x].fi;
			if(i==1) phim=phim*(fac[x].fi-1);
			else phim=phim*fac[x].fi;
		} dfs(x+1,fac,mul,phim);
	}
}
ll calc(ll k,ll n){return smul(k-1,((n&1)?-1:1)+qpow(k-1,n-1,MOD),MOD);}
void solve(){
	ll n,k=0;int a;scanf("%lld%d",&n,&a);
	if(n%MOD1==0) MOD=MOD2,INV6=INV6_2;
	else MOD=MOD1,INV6=INV6_1;
	for(int l=1,r;l<=a;l=r+1){
		r=(a/(a/l));ll lim=a/l,cnt=0;
		cnt=(cnt+smul(lim,smul(lim,lim,MOD),MOD))%MOD;
		cnt=(cnt+smul(3*lim,lim,MOD))%MOD;cnt=(cnt+2*lim)%MOD;
		cnt=smul(cnt,sum[r]-sum[l-1],MOD);cnt=smul(cnt,INV6,MOD);
		k=(k+cnt)%MOD;//printf("%d %d %lld\n",l,r,cnt);
	} //printf("%lld\n",k);
	vector<ll> fac;ll tmp=n;
	vector<pair<ll,int> > fac_dec;
	for(ll i=1;i*i<=n;i++) if(n%i==0){
		fac.pb(i);if(n/i!=i) fac.pb(n/i);
	}
	for(ll i=2;i*i<=n;i++) if(tmp%i==0){
		int cnt=0;
		while(tmp%i==0) tmp/=i,cnt++;
		fac_dec.pb(mp(i,cnt));
	} if(tmp>1) fac_dec.pb(mp(tmp,1));
	phi.clear();dfs(0,fac_dec,1,1);ll ans=0;
	for(ll x:fac) ans=(ans+smul(phi[n/x],calc(k,x),MOD))%MOD;
//	printf("%lld\n",ans);
	if(n%MOD1) ans=smul(ans,qpow(n,MOD1-2,MOD1),MOD1);
	else ans=smul(ans/MOD1,qpow(n/MOD1,MOD1*(MOD1-1)-1,MOD2),MOD2);
	printf("%lld\n",ans%MOD1);
}
int main(){
	int qu;scanf("%d",&qu);sieve(MAXV);
	while(qu--) solve();
	return 0;
}
```



---

## 作者：final_trump (赞：0)

## P3307 [SDOI2013]项链

很好的一道群论题。

本题的两个地方都可以用到置换群，我们分步考虑。

#### Part 1:

先考虑第一个子问题：给定一个长度为 $3$ 的环，每个环上的数可以填 $1$ 到 $a$ 。问有多少种本质不同的方案数，使得环上的的数互质。两种方案不同当且仅当一种方案无法通过**旋转或翻折**得到另一种方案。

看到同构就想到 Burnside 引理。对于这个环的置换共有 $6$ 个：$\rho_3^0,\rho_3,\rho_3^2,\tau_1,\tau_2,\tau_3$ ，即逆时针旋转 $0$ 格，旋转 $1$ 格，旋转 $2$ 格，沿第一格翻折，沿第二格翻折，沿第三格翻折。由于我们要求的是不动点的数量，则一个置换中处于同一循环置换的格子取值应相同。定义函数 $c(n,m)=\sum_{i_1=1}^n\sum_{i_2=1}^n\dots\sum_{i_m=1}^n[\gcd(i_1,i_2,\dots,i_m)=1]=\sum_{d=1}^n\mu(d)\lfloor \frac nd \rfloor^m$ 。因为每个置换的循环置换个数分别为 $3,1,1,2,2,2$ ，所以这一部分的答案为 $\frac 16 (c(n,3)+3c(n,2)+2c(n,1))$ 。将该部分答案记为 $m$ 。

#### Part 2:

第二个问题为：给定一个长为 $n$ 的环，每个格子可以染 $m$ 种颜色，问有多少种染色方案，使得相邻的格子颜色不同。两种方案不同当且仅当一种方案无法通过**旋转**得到另一种方案。

这个东西少了翻折同构，要好处理些。考虑 Burnside 引理，答案为 $\frac 1n\sum_{i=1}^n g(i)$ ，其中 $g(n)$ 表示在旋转 $n$ 格的情况下，不动点的数量。根据[某知名结论](https://www.luogu.com.cn/problem/P4980) ，答案式子可转变为 $\frac 1n\sum_{i=1}^n f(\gcd(i,n))$ ，其中 $f(n)$ 代表在循环节个数为 $n$ 的情况下不动点的数量。还是因为我们要保证一个方案经过该置换不变，所以**处于同一循环置换的点应该选择同一颜色**，所以总共有 $\gcd(i,n)$ 种选择。又因为从一号点出发的连续 $\gcd(i,n)$ 个点一定不处于同一置换，所以 $f(n)$ 的意义即为将长为 $n$ 的序列染色，满足相邻两格颜色不同且第一个和最后一格颜色不同的方案数。考虑递推，由 $f(n-1)$ 转移到 $f(n)$ 时，我们可以将一个与第 $n-1$ 个格子和第一个格子颜色不同的一种颜色染在当前格子上，有 $m-2$ 种方案。但这样我们会漏掉一些情况。比如 $1,2,1,2$ 就是一种合法方案，而 $1,2,1$ 不是，且我们无法从后面一种情况转移到前面的一种。所以我们应从 $f(n-2)$ 转移到 $f(n)$ ，钦定第 $n-1$ 个格子的颜色与第一个格子相同，则最后的格子有 $m-1$ 种染色方案。最后得到的递推式为 $f(n)=(m-2)f(n-1)+(m-1)f(n-2)$ ，边界条件为 $f(1)=0,f(2)=m(m-1)$ 。这是一个常系数线性齐次递推式，我们考虑找它的通解。其特征方程为 $x^2=(m-2)x+(m-1)$ ，解得 $x_1=m-1,x_2=-1$ 。考虑其通解 $f(n)=\alpha(m-1)^n+\beta(-1)^n$ ，将 $f(1)=0,f(2)=m(m-1)$ 代入，最后得 $f(n)=(m-1)^n+(-1)^n(m-1)$ 。然后将答案式子反演得到 $\frac 1n\sum_{d|n} \varphi(d)f(\frac nd)$ ，计算即可。

#### 一些细节：

1. 如何计算 $\varphi$ ：将 $n$ 进行质因数分解，dfs 枚举所有因数。

2. 若 $Mod|n$ 如何处理：此时我们记分子部分为 $x$ ，则答案表示为 $\frac xn$ 。此时我们将模数自乘，由于 $Mod|n,n|x$ ，分子模 $Mod^2$ 后一定还可以整除 $Mod$ ，于是我们将原式改写为 $\frac{\frac x{Mod}}{\frac n{Mod}}$ ，则分母将存在逆元。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long lxl;
const int MAXN=1e7+5;
const lxl Mod=1e9+7;

lxl MOD,n,a;
inline lxl read(){
	lxl x=0,f=1;char ch=getchar();
	while(!isdigit(ch))(ch=='-')&&(f=-f),ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}
struct modint{
	lxl data;
	modint(lxl data=0):data(data){};
	inline modint operator +(const modint &tmp)const{
		return tmp.data+data>=MOD?tmp.data+data-MOD:tmp.data+data;
	}
	inline void operator +=(const modint &tmp){
		data+=tmp.data;if(data>=MOD) data-=MOD;
	}
	inline modint operator -(const modint &tmp)const{
		return data<tmp.data?data-tmp.data+MOD:data-tmp.data;
	}
	inline modint operator -()const{
		return data!=0?MOD-data:0;
	}
	inline void operator -=(const modint &tmp){
		data-=tmp.data;if(data<0) data+=MOD;
	}
	inline modint operator *(const modint &tmp)const{
		return (data*tmp.data-(lxl)((long double)data/MOD*tmp.data)*MOD+MOD)%MOD;
	}
	inline void operator *=(const modint &tmp){
		data=(data*tmp.data-(lxl)((long double)data/MOD*tmp.data)*MOD+MOD)%MOD;
	}
	inline modint operator ^(const lxl &tmp)const{
		modint ans=1,n=(*this);lxl k=tmp;
		for(;k;k>>=1ll,n*=n) if(k&1ll) ans*=n;
		return ans;
	}
	inline modint operator /(const lxl &tmp)const{
		return data/tmp;
	}
};
modint inv6;
modint m,ans;

int prime[MAXN],cnt;
bool isprime[MAXN];
modint miu[MAXN];
inline void sieve(int n=MAXN-5){
	register int i,j;miu[1]=1;
	for(i=2;i<=n;++i) isprime[i]=1;
	for(i=2;i<=n;++i){
		if(isprime[i]) prime[++cnt]=i,miu[i]=MOD-1;
		for(j=1;j<=cnt&&i*prime[j]<=n;++j){
			isprime[i*prime[j]]=0;
			if(i%prime[j]) miu[i*prime[j]]=-miu[i];
			else break;
		}
	}
	for(i=1;i<=n;++i) miu[i]+=miu[i-1];
}

struct Prime{
	lxl p;
	int k;
	Prime(lxl p=0,int k=0):p(p),k(k){};
}P[31];int tot;

inline modint F(lxl len){
	modint ans=(m-1)^len;
	if(len&1) ans-=m-1;
	else ans+=m-1;
	return ans;
}

void dfs(int dep,lxl mul,lxl phi){
	if(dep==tot+1) return ans+=F(n/mul)*phi,void();
	lxl nowphi=1,nowmul=1;
	for(register int i=0;i<=P[dep].k;++i){
		dfs(dep+1,mul*nowmul,phi*nowphi);
		nowmul*=P[dep].p;
		nowphi*=(i==0?P[dep].p-1:P[dep].p);
	}
}

int main(){
	register int i,T=read();
	sieve();
	while(T--){
		n=read();a=read();
		MOD=Mod*Mod,inv6=modint(6)^(Mod*(Mod-1)-1);
		modint s1=0,s2=0;tot=0;
		for(lxl l=1,r;l<=a;l=r+1){
			r=a/(a/l);
			s1+=(miu[r]-miu[l-1])*(a/r)*(a/r)*(a/r);
			s2+=(miu[r]-miu[l-1])*(a/r)*(a/r);
		}
		m=inv6*(s1+s2*3+2);
		lxl res=n;
		for(i=1;i<=cnt&&1ll*prime[i]*prime[i]<=res;++i){
			if(n%prime[i]) continue;
			P[++tot]=Prime(prime[i],1);res/=prime[i];
			while(res%prime[i]==0) ++P[tot].k,res/=prime[i];
		}
		if(res>1) P[++tot]=Prime(res,1);
		ans=0;dfs(1,1,1);
		if(n%Mod==0) ans=ans/Mod*(modint(n/Mod)^(Mod-2));
		else ans*=(modint(n)^(Mod-2));
		printf("%lld\n",ans.data%Mod);
	}
	return 0;
}
```



 

---


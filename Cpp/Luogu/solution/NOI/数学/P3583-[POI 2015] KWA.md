# [POI 2015] KWA

## 题目描述

考虑将正整数 $n$ 拆分成几个不同的平方数之和，比如 $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$，而 $8$ 不存在这样的拆分。

用 $k(n)$ 表示 $n$ 的拆分中，最大的底数最小可能是多少。如果 $n$ 不存在这样的拆分，则令 $k(n) = \infty$。例如：$k(1) = 1$，$k(8) = \infty$，$k(378) = 12$，$k(380) = 10$。

定义一个数 $x$ 被称为“超重”的，当且仅当存在 $y > x$，使得 $k(y) < k(x)$。从上面的例子可知，$378$ 是一个“超重”的数。

给定 $n$，你需要：

1. 求出 $k(n)$。
2. 求出 $1 \sim n$ 中有几个“超重”的数。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le {10}^{18}$。

----

原题名称：Kwadraty。

## 样例 #1

### 输入

```
30```

### 输出

```
4 15```

# 题解

## 作者：18Michael (赞：6)

## 题意

设 $k(n)$ 表示将正整数 $n$ 拆分成若干不同的平方数之和的所有方案中，最大的底数最小可能是多少，如果不存在这样的拆分，则 $k(n) = \infty$。

定义一个数 $x$ 「超重」，当且仅当存在 $y > x$，使得 $k(y) < k(x)$。

给定 $n$，求 $k(n)$ 和 $1 \sim n$ 中「超重」的数个数。

## 题解

设 $S_n=\sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$，$t_n$
 满足 $S_{t_n-1}\lt n\le S_{t_n}$，则 $k(n)\ge t_n$。

对于第一问，当 $n\le285$ 时，可以 $O(n\sqrt n)$ 时间内 dp 出答案，且该范围内只有 $31$ 个数无法被表示出；当 $n>285$ 时，$t_n\ge10$。

首先 $128\le x\le285$ 时由 dp 可知都有 $k(x)\ne\infty$，$k(x)\le t_x+1$。

假设我们已经归纳证明了 $128\lt x\le n-1$ 时都有 $k(x)\ne\infty$，$k(x)\le t_x+1$，则 $x=n$ 时：

若 $k(S_t-n)<t_n$，则容易构造方案使得 $k(n)=t_n$；否则 $k(n)\gt t_n$，且由于 $n-(t_n+1)^2\gt S_{t_n-1}-(t_n+1)^2\ge S_9-10^2=185$，故 $k(n-(t_n+1)^2)\ne\infty$。

又由于 $n-(t_n+1)^2\le S_{t_n}-(t_n+1)^2\lt S_{t_n-1}$，故由归纳假设知 $k(n-(t_n+1)^2)\le t_{n-(t_n+1)^2}\le t_n-1$，因此可以构造方案使得 $k(n)=t_n+1$。

因此该结论成立，可以通过递归在 $O(\log n)$ 时间内求出答案。

对于第二问，由上述结论知当 $t\gt31$ 且 $S_{t-1}\lt x\le S_t$ 时，$t\le k(x)\le t+1$，因此该范围内所有超重的数即为 $k(x)=t+1$ 的数。又由之前结论的推导过程可知该范围内恰有 $31$ 个数的 $k$ 值为 $t+1$，为所有的 $S_t-x$ 满足 $k(x)=\infty$，因此可分成 $S_t\le n$ 和 $S_{t-1}\lt n\le S_t$ 两部分分别统计答案。

总时间复杂度 $O(\log n)$。

## Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;
int Mx=10416;
LL n,ans=0;
int f[10422];
inline LL S(LL x)
{
	return x*(x+1)*(2*x+1)/6;
}
inline int get(LL x)
{
	int t=pow(x*3,1.0/3);
	while(S(t-1)>=x)--t;
	while(S(t)<x)++t;
	return t;
}
inline int F(LL x)
{
	if(x<=Mx)return f[x];
	int t=get(x);
	return t+(F(S(t)-x)>=t);
}
int main()
{
	scanf("%lld",&n);
	if(n<Mx)Mx=n;
	for(int i=1;i<=Mx;++i)f[i]=inf;
	for(int i=1;i*i<=Mx;++i)for(int j=Mx;j>=i*i;--j)if(f[j-i*i]<inf)f[j]=min(f[j],i);
	if(n<=Mx && f[n]==inf)putchar('-');
	else printf("%d",F(n));
	for(int i=1;i<=Mx;++i)ans+=(f[i]==inf || S(f[i]-1)>i);
	if(Mx<n)
	{
		int t=get(n);
		ans+=31LL*(t-32);
		for(int i=1;i<=128;++i)ans+=(f[i]==inf && S(t)-i<=n);
	}
	return 0&printf(" %lld",ans);
}
```

---

## 作者：Alex_Wei (赞：6)

> [P3583 [POI2015]KWA](https://www.luogu.com.cn/problem/P3583)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

打表猜结论题。首先这道题目长得就一脸可以打表的样子，所以我们先通过 DP 求得一点小数据的 $w$ 值。

输出到 $10^4$，发现一个比较明显的分割点在 $9455$ 这个地方：因为 $9455=S(30)=\sum_{i=1}^{30}i^2$ 所以它是最后一个 $w$ 值为 $30$ 的数，显然若 $i>9455$ 则 $w(i)>30$。这给予我们第一个思想：当 $i$ 很大的时候，$j^2\ (j\leq i)$ 的组合能够生成的数覆盖了**几乎所有** $S(i-1)\sim S(i)$ 之间的数，以及当 $n>S(i)$ 时，必然有 $w(n)>i$。

但再观察表，发现在 $9455$ 的前面有一些 “超重” 数，它们的 $w$ 值为 $31$。乍一看似乎没啥规律，不过仔细思考后可以发现，这些超重数 $p$ 与 $9455$ 之间的差 $q\ (q=9455-p)$，应该就是所有 $w(q)=\infty$ 的 $q$。毕竟 $p$ 应该由 $1\sim i$ 的平方之和减掉一些数的平方得到，但如果它们的差（$n-p$）即要减去的数不能由若干个不同的完全平方数之和得到，那么 $p$ 也不能由 $S(i)$ 减去一些不同的完全平方数得到，这说明 $w(p)$ 不得不大于 $i$。

接下来我们证明在 $p$ 足够大的时候，一定有 $w(p)=i+1$，其中 $i$ 为使得 $S(i)\geq p$ 的最小的 $i$ 且 **$S(i)-p$ 不能由若干完全平方之和表示**：设 $q=S(i+1)-p$，由于不能被若干完全平方之和表示的数有限（共有 $31$ 个且最大值为 $128$），所以 $p\to \infty$ 时 $q\gg 128$，因此 $w(q)\neq \infty$，这说明 $p$ 可以由 $S(i+1)$ 减去若干完全平方数得到，故 $w(p)=i+1$。

综上，我们有如下算法：首先暴力求出 $n$ 比较小时的 $w(n)$（大概到 $10^3$ 级别就够了，设范围为 $[1,x]$），若给定的 $n$ 属于 “比较小”，即 $n\leq x$，直接输出答案。否则**二分**求出最小的 $i$ 使得 $S(i)\geq n$，那么第一问的答案即 $i+[\mathrm{exist}\ j,\ w(j)=\infty\land n+j=S(i)]$，第二问的答案可以由 $n$ 较小时的超重数之和，加上从 $x+1$ 到 $n$ 之间所有超重数得到。

因为对于固定的 $j$，所有 $w(p)=j$ 的 $p$ 中有 $31$ 个超重数（可表示为 $S(j-1)-q$，其中 $w(q)=\infty$），所以令 $l$ 为 $S(l)\leq x$ 的最大的 $l$（注意这个分割点 $x$ 不应该取到比较靠近形如 $S(i)-d$ 其中 $d$ 是一个很小的数的位置，因为这样会把 $w(p)=l$ 的超重数 $p$ 分割成 $\leq x$ 和 $>x$ 两部分，无法直接用 $31$ 乘以 $j$ 的个数计算），答案加上 $31\times (i-1-l)$，再枚举 $w(q)=\infty$ 的 $q$，若 $S(i)-q\leq n$ 说明 $S(i)-q$ 这一超重数的贡献也要算上，答案加 $1$。

除去预处理的常数复杂度，时间复杂度为二分求 $i$ 的 $\log n$。代码预处理到了 $10^4$，此时 $l=30$ 所以上式可改写为 $31\times (i-31)$。

```cpp
const int N = 1e4 + 5;
int f[N], mnf[N], w[N];
ll n;
int main() {
	mem(f, 0x3f, N), f[0] = 0, mnf[N - 4] = N;
	for(int i = 1, sum = 0; i <= 31; i++, sum += i * i)
		for(int j = min(N - 1, sum); ~j; j--)
			if(f[j] < N) cmin(f[j + i * i], i);
	for(int i = N - 5; i; i--) mnf[i] = min(mnf[i + 1], f[i]), w[i] = f[i] > mnf[i];
	for(int i = 1; i < N - 4; i++) w[i] += w[i - 1];
	cin >> n;
	if(n < N - 4) {
		if(f[n] > N) cout << "- " << w[n] << endl;
		else cout << f[n] << " " << w[n] << endl; exit(0);
	}
	ll l = 30, r = 1.5e6;
	while(l < r) {
		ll m = (l + r >> 1) + 1;
		ll sum = m * (m + 1) * (2 * m + 1) / 6;
		if(sum < n) l = m;
		else r = m - 1;
	}
	int ans = w[N - 5] + (l - 30) * 31;
	ll val = (l + 1) * (l + 2) * (2 * l + 3) / 6;
	for(int i = 1; i <= 1 << 7; i++)
		if(f[i] > N) {
			ans += val - i <= n;
			if(val - i == n) r++;
		}
	cout << r + 1 << " " << ans << endl;
	return cerr << "Time : " << clock() << " ms" << endl, flush(), 0;
}
```

---

## 作者：Sya_Resory (赞：0)

模拟赛出这道题？？？

还好赛时乱搞做出来了（/hanx

[link](https://www.luogu.com.cn/problem/P3583)

## Description

> 定义一个数 $n$ 的拆分为：将 $n$ 表示为若干个不同的正整数的平方和。令 $k(n)$ 为 $n$ 的拆分中最大数的最小值。若不存在满足要求的拆分，则 $k(n)=\infty$。
>
> 给定 $n$（$n\le10^{18}$），求 $k(n)$ 以及 $\sum_{i=1}^n[\exists j>i,k(j)<k(i)]$。

## Solution

~~赛时看到 1e18 直接震惊~~

这个拆分似乎没有什么好性质，于是暴力算一下 $1\sim10^4$ 以内的数，发现只有 $2\sim128$ 中的 $31$ 个数无法被表示。大胆猜测只有这几个数无法被表示。

令 $S(n)=\sum_{i=1}^ni^2=\frac16n(n+1)(2n+1)$，$t=\min\{x\mid S(x)\ge n\}$。那么显然有 $k(n)\ge t$（否则全选也表示不了）。

上界不大好处理。正难则反，考虑从 $S(t)$ 里蒯出几个不需要的平方数，即考虑 $S(t)-n$。由于 $n$ 足够大，可以认定 $n>S(t)-n$，于是我们缩小了要考虑的数的范围。如果 $S(t)-n$ 能被表示出来，那么显然 $k(n)=t$。但是如果 $k(S(t)-n)=\infty$ 就不能这样。

观察打表数据大胆猜测剩下这种情况是 $k(n)= t+1$。感性理解一下有 $n-(t+1)^2$ 比较小，可以用 $1\sim t$ 构造出来，于是 $n$ 就构造出来了。$S(t)-n$ 只有 $31$ 种取值，所以 $k(n)=t+1$ 也只有 $31$ 个。

于是可以求出 $k(n)$，时间复杂度感觉是比较松的 $O(n^{1/3})$？题解的 $O(\log)$ 感觉不大对。

第二问考虑把 $1\sim n$ 的数分为若干个 $(S(x-1),S(x)]$ 的块求解。$t>30$ 后可以整块求解（每块只有 $31$ 个取值为 $x+1$ 的），前面的暴力就行了。

实际做的时候，$n$ 比较小可能出问题，可以考虑预处理出一部分答案。~~我一开始预处理写错了结果你谷和模拟赛数据都没卡掉~~

时间复杂度就是求 $k(n)$ 的复杂度。

code：

```cpp
#include <cstdio>
#include <cmath>

typedef long long ll;
const ll Bad[31] = {2,3,6,7,8,11,12,15,18,19,22,23,24,27,28,31,32,33,43,44,47,48,60,67,72,76,92,96,108,112,128};
	// Numbers that can't be represented
const ll inf = 1e18;
const ll N = 9455,maxn = 2.5e4; // S(31) = 9455

ll n,t,k[maxn];

inline ll S(ll n) { return n * (n + 1) / 2 * (2 * n + 1) / 3; } // Prefix Square Sum

inline ll Get(ll n) { // Least t s.t. S(t) >= n
	ll t = pow(n * 3.,1. / 3);
	for(;S(t) >= n;) t --;
	for(;S(t) < n;) t ++;
	return t;
}

inline ll K(ll n) { // k(n)
	if(n <= N) return k[n];
	ll t = Get(n);
	if(K(S(t) - n) >= t) return t + 1;
	return t;
}

inline void Init() { // Pre-compute the value of k(i) for i in 1 ~ S(31)
	for(ll i = 1;i <= N;i ++) k[i] = inf;
	for(ll s = 0,i = 1;i <= 32;i ++,s += i * i)
		for(ll j = s;j >= 0;j --) if(k[j] < inf && k[j + i * i] > i) k[j + i * i] = i;
}

int main() {
	scanf("%lld",&n); Init();
	ll Cnt_res = 0,t,K_res = K(n);
	if(K_res < inf) printf("%lld",K_res); else putchar('-'); // Part 1
	for(ll i = 1;i <= N && i <= n;i ++) if(k[i] == inf || S(k[i] - 1) > i) Cnt_res ++; // 1 ~ S(31)
	if(n > N) {
		t = Get(n); Cnt_res += 31LL * (t - 31);
		for(int i = 0;i < 31;i ++) if(S(t) - Bad[i] <= n) Cnt_res ++;
	}
	printf(" %lld\n",Cnt_res); // Part 2
	return 0;
}
```

---

## 作者：PosVII (赞：0)

**前言**

------------

很妙的结论题，拿到了最优解前三。

**正文**

------------

首先打一个动态规划寻找无法被表达的数，我们发现有且仅有 $31$ 个数。

根据这个信息我们可以得到：当一个数足够大时一定能被表达出来，进一步寻找，我们会发现对于一个数 $x$，一定有：

$\frac{ (y - 1) \times y \times ( y \times 2 - 1 ) }{ 6 } < x \leq \frac{ y \times ( y + 1 ) \times ( y \times 2 + 1 ) }{ 6 }$ 时 $x$ 一定能被 $ y + 1 $ 以内的数拆分。

那么可以进行二分查找寻找 $y$ 值，而超重数的数量可被分为 $y$ 个整体，而每个整体里都会有 $31$ 个超重数，剩下的部分循环枚举即可。需要预处理然后分段讨论。

**code**

------------

```
#include<bits/stdc++.h>
using namespace std;
#define max(x,y) x>y?x:y
#define min(x,y) x>y?y:x
template<typename G>inline void read(G&x){x=0;G f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+(ch^48),ch=getchar();x*=f;}
const int MAXN=2310+5;
int dp[MAXN]={0,1,1061109567,1061109567,2,2,1061109567,1061109567,1061109567,3,3,1061109567,1061109567,3,3,1061109567,4,4,1061109567,1061109567,4,4,1061109567,1061109567,1061109567,4,4,1061109567,1061109567,4,4,1061109567,1061109567,1061109567,5,5,6,6,5,5,6,5,5,1061109567,1061109567,5,5,1061109567,1061109567,6,5,5,6,6,5,5,6,6,7,7,1061109567,6,6,7,8,6,6,1061109567,8,7,6,6,1061109567,8,6,6,1061109567,6,6,7,8,6,6,7,7,7,6,6,7,7,6,6,1061109567,8,7,7,1061109567,9,7,7,7,7,7,7,7,7,7,9,1061109567,8,7,7,1061109567,8,7,7,8,8,8,7,7,8,8,7,7,8,7,7,1061109567,8,7,7,9,8,8,7,7,9,8,7,7,8,8,8,9,8,8,8,8,8,8,8,8,8,8,8,9,10,8,8,9,9,8,8,8,8,8,8,8,8,8,9,9,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,9,9,9,9,10,9,9,9,10,9,9,9,9,10,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,9,9,9,10,10,9,9,10,10,9,9,9,9,9,9,9,9,9,10,10,10,9,9,11,10,9,9,10,10,10,9,9,10,10,9,9,10,9,9,11,10,9,9,11,10,10,9,9,10,10,9,9,10,10,10,11,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,10,10,11,10,10,10,10,11,10,10,10,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,11,11,10,10,11,11,10,10,10,10,10,10,10,10,10,11,11,11,10,10,11,11,10,10,11,11,11,10,10,11,11,10,10,11,10,10,11,11,10,10,11,12,11,10,10,11,11,10,10,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,12,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,12,12,11,11,11,11,11,11,11,11,11,12,12,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,12,12,12,13,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,13,13,12,12,13,13,12,12,12,12,12,12,12,12,12,13,13,13,12,12,13,13,12,12,13,13,13,12,12,13,13,12,12,13,12,12,13,13,12,12,13,13,13,12,12,13,13,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,14,13,13,13,13,14,13,13,13,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,14,14,13,13,14,14,13,13,13,13,13,13,13,13,13,14,14,14,13,13,14,14,13,13,14,14,14,13,13,14,14,13,13,14,13,13,14,14,13,13,14,14,14,13,13,14,14,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,14,14,14,14,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,15,15,14,14,14,14,14,14,14,14,14,15,15,15,14,14,15,15,14,14,15,15,15,14,14,15,15,14,14,15,14,14,15,15,14,14,15,15,15,14,14,15,15,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,15,15,15,16,15,15,15,15,15,15,15,15,15,15,15,16,15,15,15,16,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,15,15,15,16,15,15,15,15,16,15,15,15,15,15,15,16,15,15,15,15,15,15,15,15,15,15,15,16,16,15,15,16,16,15,15,15,15,15,15,15,15,15,16,16,16,15,15,16,16,15,15,16,16,16,15,15,16,16,15,15,16,15,15,16,16,15,15,16,16,16,15,15,16,16,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,16,16,16,17,16,16,16,16,16,16,16,16,16,16,16,17,16,16,16,17,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,16,16,16,17,16,16,16,16,17,16,16,16,16,16,16,17,16,16,16,16,16,16,16,16,16,16,16,17,17,16,16,17,17,16,16,16,16,16,16,16,16,16,17,17,17,16,16,17,17,16,16,17,17,17,16,16,17,17,16,16,17,16,16,17,17,16,16,17,17,17,16,16,17,17,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,17,17,17,18,17,17,17,17,17,17,17,17,17,17,17,18,17,17,17,18,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,17,17,17,18,17,17,17,17,18,17,17,17,17,17,17,18,17,17,17,17,17,17,17,17,17,17,17,18,18,17,17,18,18,17,17,17,17,17,17,17,17,17,18,18,18,17,17,18,18,17,17,18,18,18,17,17,18,18,17,17,18,17,17,18,18,17,17,18,18,18,17,17,18,18,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,19,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,19,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,19,18,18,18,18,19,18,18,18,18,18,18,19,18,18,18,18,18,18,18,18,18,18,18,19,19,18,18,19,19,18,18,18,18,18,18,18,18,18,19,19,19,18,18,19,19,18,18,19,19,19,18,18,19,19,18,18,19,18,18,19,19,18,18,19,19,19,18,18,19,19,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19};
int mn[MAXN],sum[MAXN];
long long n,l=15,r=1500000,ans,k;
int main() {
	read(n);mn[2311]=0x3f3f3f3f;
	for(int i=2310;i>=1;--i) {
		mn[i]=min(dp[i],mn[i+1]);
		if(mn[i]<dp[i]) sum[i]=1;
	}
	for(int i=1;i<=2310;++i) sum[i]+=sum[i-1];
	if(n<=2310) {
		if(dp[n]==0x3f3f3f3f) printf("- ");
		else printf("%d ",dp[n]);
		printf("%d",sum[n]);
		return 0;
	}
	while(l<=r) {
		long long mid=(l+r)>>1;
		if(mid*(mid+1)*(2*mid+1)/6>=n) r=mid-1,k=mid;
		else l=mid+1;
	}
	long long num=sum[2310]+(k-19)*31;
	ans=k*(k+1)*(k*2+1)/6;
	if(ans-n<=128&&ans-n>0&&dp[ans-n]==0x3f3f3f3f) ++k;
	for(int i=1;i<=128;++i) {
		if(dp[i]==0x3f3f3f3f&&ans-i<=n) {
			++num;
		}
	}
	printf("%lld %lld",k,num);
	return 0;
}
/*
105041937
*/
```

---


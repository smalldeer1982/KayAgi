# [ZJOI2018] 迷宫

## 题目背景

九条可怜是一个贪玩的女孩子。

## 题目描述

暑假快要到了，可怜打算在她家的私人海滩旁边建一座城堡，这样就可以在放暑假的时候 邀请她的朋友们来玩了。同时，可怜打算在城堡的地下修建一座迷宫，因为探险总是一件充满 乐趣的事情。

经过简单的设计，可怜打算修建一座这样的迷宫：
- 迷宫可以被抽象成 $n$ 个点，$nm$ 条边的有向图。$1$ 号点是唯一的入口也是唯一的出口。 
- 每一个点恰好有 $m$ 条出边，且这些出边被依次标号为 $[0,m)$ 的正整数。 
- 迷宫允许自环和重边。

同时，一座优秀的迷宫应该有一定的解谜因素。因此可怜希望每一条从 $1$ 号点出发并回到 $1$ 号点的回路都有着一定的规律。可怜发现，如果把一条从 $1$ 出发的路径经过的所有边的编号都记录下来，那么能得到一个（可能有前导 $0$）的 $m$ 进制数；同时对于每一个（可能有前导 $0$）的 $m$ 进制数，都能对应回一 条从 $1$ 出发的路径。

于是可怜选定了一个整数 $K$，她希望这个迷宫满足一条从 $1$ 出发的路径能回到 $1$ **当且仅当**这条路径对应的数是 $K$ 的倍数。

现在可怜已经选定了 $m$ 和 $K$，但是她发现并不是对所有的 $n$，都存在满足上述所有条件的迷宫设计方案。建造迷宫是一件费时费力的事情，于是可怜想要找到一个最小的满足条件的 $n$。

然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这个数值。

## 说明/提示

第一组数据（左）和第二组数据（右）的一种设计方案如下图所示。其中紫色边表示 $0$ 号边，蓝色边表示 $1$ 号边。

![](https://cdn.luogu.com.cn/upload/pic/16017.png)

![](https://cdn.luogu.com.cn/upload/pic/16018.png)

## 样例 #1

### 输入

```
3 
2 3
2 4 
6 8```

### 输出

```
3 
3
5```

# 题解

## 作者：brealid (赞：28)

这篇文章的所有图片使用 $\operatorname{Graphviz}$ 生成，在此鸣谢。 

初稿 on ``2020-05-28 16:26:54``  
更改图源 on ``2021-03-21 10:25:22``

## 构造有 $K$ 个点的“基本方案”

考虑构造一个有 $∞$ 个点的方案。  
为了方便，我们假设题目中的 $1$ 号点为 $0$ 号点。  
对于一个点 $x$，我们使它的第 $i(i\in[0,m-1])$ 条出边指向节点 $x · m + i$。  
为了使得路径能回到 $0$ 号点，我们使所有满足 $x\equiv 0 \pmod {K}$ 的点的第 $0$ 条出边都指向 $0$。容易证明这样一定是可行的。  
于是我们容易想到，如果把每个节点的编号都模上 $K$，我们将得到一个有 $K$ 个点的方案。

整理一下：  
为了得到一个有 $K$ 个点的方案，对于每一个节点 $x\in[0,K-1]$，其第 $i(i\in[0,m-1])$ 条出边指向节点 $(x · m + i)\bmod K$。  

## “缩点”

我们发现，样例中第一组数据是满足我们的构造方案的，但是第二、三组数据的答案均比 $n=K$ 优秀。  
考虑用我们的方案先构造一个 $m=2,n=K=4$ 的方案  
![m2k4-1.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m2k4-1.PNG)  
其中黑色边表示 $0$ 号边，红色边表示 $1$ 号边。  
我们能发现什么东西么？  
**基本事实 1** 如果两个点可以到达的点集相同，那么这两个点可以被缩成 1 个点。  
所谓“可以到达的点集相同”，形式化的说，对于两个点 $a,b$，是指 $\forall \ {0\le i<m}$，有 $(a · m + i)\bmod K = (b · m + i)\bmod K$ 或者 $(a · m + i)\bmod K = b$ 或者 $(b · m + i)\bmod K = a$  
感性理解，就是缩点之后， $\forall \ {0\le i<m}$, 被缩点的第 $i$ 条出边指向的目标点不会不同。  
如样例第二组数据，可以对 $1,3$ 号节点缩点，变成这样：  
![m2k4-2.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m2k4-2.PNG)  
可以发现，这就是样例解释。  
（$0$ 号点对应样例 $1$ 号点，$2$ 号点对应样例 $2$ 号点，$13$ 号点对应样例 $3$ 号点）

再给一张大一点的图（对应样例第三组数据）。  
黑色边表示 $0$ 号边，红色边表示 $1$ 号边，绿色边表示 $2$ 号边，蓝色边表示 $3$ 号边，紫色边表示 $4$ 号边，橙色边表示 $5$ 号边。  
![col-释.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/col-释.PNG)   
当 $m=6,K=8$ 时可以构造出一个 $n=8$ 的基本方案  
![m6k8-1.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m6k8-1.PNG)  
缩点后得到一个 $n=5$ 的最佳方案  
![m6k8-2.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m6k8-2.PNG)  
可以手玩一下验证其正确性  
即样例输出


## 关于 $0$ 号节点

注意到上面几张图中 $0$ 号节点都没有被缩点。  
注意到这个节点比较的特殊，不能被缩点。  
为什么？  
因为 $0$ 号节点可以被作为迷宫的结束点，而别的任意一个节点均不满足这一性质，自然不能与 $0$ 号节点一起缩点。  
但是其他与 $0$ 可以到达的点集相同的点之间时可以缩点的。  
口说无凭，以图解释。  
$m=3,K=3$ （黑色边表示 $0$ 号边，红色边表示 $1$ 号边，绿色边表示 $2$ 号边）  
基本方案 $n = 3$  
![m3k3-1.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m3k3-1.PNG)  
缩点后 $n = 2$  
![m3k3-2.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m3k3-2.PNG)  

## 什么时候可以缩点

对于两个可以缩的点 $a, b$  
因为 $\forall 0\le i<m,a·m+i\equiv b·m+i\pmod K$  
所以若有 $a·m\equiv b·m\pmod K$ 则可以缩点  
设 $g = \gcd(m, K)$  
则有 $a·\frac{m}{g}\equiv b·\frac{m}{g}\pmod {\frac{K}{g}}$  
设 $m^′=\frac{m}{g},K^′=\frac{K}{g}$  
则有 $a·m^′\equiv b·m^′\pmod {K^′}$    
此时 $m^′,K^′$ 互质  
那么若有 $a\not\equiv 0 \pmod {K^′}$ 且 $b\not\equiv 0 \pmod {K^′}$，就一定有 $a\equiv b \pmod {K^′}$   

> 证明：  
> 不妨设 $a=cK^′+e,b=dK^′+f$    
> 其中 $e,f\in[0,K^′)$ 且 $c,d,e,f$ 均为自然数  
> $\therefore a\equiv e\pmod {K^′},b\equiv f\pmod {K^′}$  
> $\because a·m^′\equiv m^′(cK^′+e)\equiv m^′cK^′+m^′e\equiv m^′e\pmod {K^′},$    
> $b·m^′\equiv m^′(dK^′+f)\equiv m^′dK^′+m^′f\equiv m^′f\pmod {K^′}$  
> $\therefore m^′e=m^′f\pmod {K^′}$  
> $\because m^′,K^′$ 互质且 $a\not\equiv 0 \pmod {K^′}$， $b\not\equiv 0 \pmod {K^′}$   
> $\therefore e=f$  
> $\therefore a\equiv b\pmod {K^′}$  
> 因此原命题得证  

考虑计算哪些点可以缩点。  
对于点 $x$，$x$ 可以化为 $x=yK^′+z$，其中 $z\in[0,K^′)$ 且 $y,z$ 均为自然数。  
一个点可以被缩点，当且仅当 $z\not ={0}$。  
此时能与点 $x$ 缩为一点的点 $z$ 都相等。  
而对于 $x\in [0,K)$，$z$ 相等的数有 $g$ 个。  
因此，对于同一个 $z$ 对应的 $g$ 个点，缩为一点的时候会减少 $g-1$ 个点。  
因为 $z\in [1,K^′)$ 时可以缩点，所以有 $K^′-1$ 组可以缩的点，这些点会使答案减少 $(g-1)(K^′-1)$  
所以最终答案为 $K - (g-1)(K^′-1)$，其中 $g = \gcd(m, K)$

发现这一性质满足样例的三组数据。  
提交后，我们获得了 $0$ 分的好成绩。

## 论证之不严密

我们发现，有些点是可以被二次缩点的。
观察下列 $m=2,K=8$ 的图（黑色边表示 $0$ 号边，红色边表示 $1$ 号边）  
基本方案 $n=8$  
![m2k8-1.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m2k8-1.PNG)  
一次缩点 $n=6$  
![m2k8-2.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m2k8-2.PNG)  
二次缩点 $n=5$  
![m2k8-3.PNG](https://gitee.com/hkxa/mycode/raw/master/luogu/P4339_graphviz/m2k8-3.PNG)  
这时候我们的原计算方案就失效了，需要寻求新的解决方案。

## 递归缩点

由于需要多次缩点，考虑递归求解。

发现两个点 $x,y$ 能被二次缩点，一定需要满足 $x·m^u=y·m^u \pmod{K^′}$  
不妨设当前缩点后还剩下 $r$ 个点，不妨设其编号为 $1\dots r$ （排除 $0$ 号节点）。  
需要注意，在前一轮缩点中没有被缩点的点，下一轮一定不可能被缩点（自行感性理解，或者结合上面 $m=2,K=8$ 的图理解，不会证）  
考虑设计一个函数 ``solve``，返回缩点中去除了几个节点。  
分析这个函数需要的参数。  
由于每次一定进行了缩点，$r$ 值变化, $r$ 需要作为参数。  
同时需要参数 $t=m^u$ （其中 $u$ 的实际意义是递归次数，但不会存储）  
还需要参数 $K$。因为每次计算时都使用 $K^′$，所以应该将 $K^′$ 传给下一层递归函数。  
同时由于我们下传的 $K$ 每次都除以了 $g$，下传的 $t$ 也应该一并除以 $g$ （实际原因：$t$ 实际不是 $u$ 次递归中 $m$ 的乘积，而应该是 $u$ 次递归中 $m^′$ 的乘积）  
考虑到如果 $g=1$，那么一定不能缩点（显然不证）    
考虑到如果 $r<K^′$，点的个数小于“出边构成的集合”的种类数，也不能缩点。  
因此上述两种情况都应该返回 $0$ 以表示缩去了 $0$ 个点。  
考虑到缩点的时候，缩得的 $K^′$ 个点中有 $t$ 个点是不可能再次被缩的，因此传给下一层 ``solve`` 的 $r$ 应为 $K^′-t$  

考虑递归终止条件。  
假设 $r<0$ 显然应该终止。  
**但是** 如果这样计算，$t$ 有可能会爆 ``int64``（实测 $80$ $pts$），所以我们需要再上一层就判断传给下一层的 $r$ 的正负，而且不应当用整数乘法，应当用**浮点数除法**  
（事实上，你可以使用 ``__int128`` 解决问题，但不能保证 ZJOI i3 老年机会不会返回 $0$ 分的好成绩）

``solve`` 的返回值应为下一层递归的结果加上 $r-K^′$（到这一层剩余的点减去缩得的点个数）

代码放 ``solve`` 函数和 ``main`` 函数

其中 ``K_`` 表示 $K^′$，``m_`` 表示 $m^′$

```cpp
typedef long long int64;

int64 solve(int64 r, int64 t, int64 K) {
    int64 g = gcd(m, K), K_ = K / g, m_ = m / g;
    if (g == 1 || r <= K_) return 0;
    if ((double)K_ / m_ < t) return r - K_;
    t *= m_;
    return solve(K_ - t, t, K_) + r - K_;
} 
int main()
{
    T = read<int>();
    while (T--) {
        m = read<int64>();
        K = read<int64>();
        int64 g = gcd(m, K), K_ = K / g;
        write(K - solve(K - 1, 1, K), 10);
    }
    return 0;
}
```

---

## 作者：殇雪 (赞：28)

      我们发现自动机的平凡上界就是T。

       因为我们令到每一个点的路径在mo T意义下相等，则这样一定是合法的。

      我们考虑如何合并这些点：

      我们发现在 当两个点可以到达的点是一致的时候，就可以缩为一个点。

      我们发现*k mo T 相同就可以缩点。

      我们发现这样子是过不了的。

       因为我们其实缩点以后，我们划归为了一个子问题，所以我们要迭代下去。

       我们怎么迭代呢，我们考虑缩点以后用标号小的点来表示新点

       那我们发现每次后，剩下的0 到 X 联续的。

      我们可以每次拿掉一个 gcd 迭代。

      终止条件是 X与 T（迭代后的）互质。

     这样做的正确性比较显然吧。

      考试的时候simple的认为这是数论相关的。应该会带个u ，默默的减去 平方因子的贡献，非常神奇的是，过了大样例。然后华丽爆零
     
```
#include<bits/stdc++.h>
#define LL __int128
using namespace std;
LL gcd(LL x,LL y){return y?gcd(y,x%y):x;}
LL sol(LL l,LL m,LL k){
    LL d=gcd(m,k);
    if (d==1) return l;
    if (l>k/d) return m*(k-l)/d+sol((k-m*(k-l))/d,m,k/d);
    return l;
}
int T;LL m,k;
signed main () {
    scanf("%d",&T);
    while (T--) {
        scanf("%lld %lld",&m,&k);
        printf("%lld\n",sol(k-1,m,k)+1);
    } return 0;
}
```

---

## 作者：x义x (赞：23)

啊，ZJOI2018，永远滴神！

> **题目大意.**
>
> 令字符集为 $0\sim m-1$。
>
> 称一个字符串合法，如果它看成一个 $m$ 进制数时能被 $k$ 整除。
>
> 要求最小的 $n$ 使得：存在一个大小为 $n$，每个点有 $m$ 条转移边的自动机，其中必须保证 $0$ 号点既是入口也是出口，且恰能识别所有合法串。
>
> $m,k\le 10^{18}$。

显然 $n=k$ 是可以的：每个节点代表一个模 $k$ 同余等价类，$i$ 号点的 $j$ 号转移边转移到的是 $im+j\bmod k$。接下来的问题就是怎么把这个自动机压缩。

**事实 0.** 两个点等价当且仅当它们每一对相同转移边到的点等价。

*那么我们为什么不认为所有点全都等价呢？*（智将）这可不是开玩笑，其实想想好像也很有道理。

问题在于：$0$ 号点是出口，这赋予了它**特殊性**。进一步发现，"某条转移边走到的是 $0$"也具有特殊性。更进一步有以下事实：

**事实 1.** 两个节点等价当且仅当它们走到 $0$ 的路径集合完全相同。一种有趣的看法是：*$0$ 是一切特殊性之源。*

下面是对于 **事实 1** 的解读。

> 定义 $u$ 的第 $r$ 阶**转移函数**为 $m^ru+\sum_{i=1}^rm^{r-i}x_i$，其中 $x_i$ 可理解为第 $i$ 步转移走的转移边。转移函数的零点显然就是 $u$ 走到 $0$ 的路径集合。
>
> 比较两个点 $u,v$ 的第 $r$ 阶转移函数。注意到由于后面的 $\Sigma$ 实际上不重地枚举了所有 $[0,m^r-1]$ 的整数，所以：如果 $m^ru\neq m^rv$ 且这两个转移函数其中之一有解，则 $u,v$ 必然不等价。
>
> 事实上，显然地，如果满足这个条件则 $u,v$ 必定等价，即我们得出了等价的充要条件。

显然，如果 $m^ru=m^rv$ 则必定有 $m^{r+1}u=m^{r+1}v$，所以我们不妨直接枚举 $r$，每次把 $m^ru=m^rv$ 的点合并起来，把那些方程有解的点扔掉。

好了，你已经完全搞懂了缩点的 spirit，接下来只需要对更多的 $m,k$ 手动试验来获得更完整的对各种 case 的认识。下面给出精确的式子。

```cpp
#include<bits/stdc++.h>
typedef __int128 iint;
using namespace std;

iint m;
iint gcd(iint a, iint b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
iint calc(iint h, iint d, iint k) { //h : 还剩的点数, d : 已经有解的点数
    if (h <= 0) return 0;
    iint g = gcd(m, k), k0 = k / g, m0 = m / g;
    if (g == 1) return 0; //无法进行任何合并
    if (h <= k0) return 0; //无法进行任何合并
    d *= m0;
    return h - k0 + calc(k0 - d, d, k0);
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        long long m_, k_; scanf("%lld%lld", &m_, &k_);
        m = m_;
        printf("%lld\n", k_ - (long long)calc(k_ - 1, 1, k_));
    }
}
```





---

## 作者：jijidawang (赞：3)

> 给定不小于 2 的正整数 $m$ 与正整数 $k$，求能够识别语言 $L$ 的 DFA 的最小状态数，其中字符集为 $\Sigma = \{ 0, 1, \ldots, m - 1 \}$，$L$ 定义为所有表示在 $m$ 进制下后是 $k$ 的倍数的字符串。
> 
> 即求出能够识别在 $m$ 进制下是 $k$ 的倍数的字符串的 DFA 最小化后的状态数。

***

首先显然可以构造出一种可行 DFA：每个节点代表一个模 $k$ 的同余类，$i$ 号点的 $j$ 号转移边转移到的是 $(ib+j)\bmod k$。接下来考虑最小化它 .

可以发现 $u,v$ 的出边相等就是 $\forall i\in[0,m),\ ub+i\equiv vb+i\pmod k$，其实也就是 $ub=vb\pmod k$ .

那么根据 Myhill–Nerode 定理（见文末）可以得到 $u,v$ 等价当且仅当对于所有 $r$ 有 $u\cdot m^r\equiv v\cdot m^r\pmod k$ .

那么从小到大枚举 $r$，每次缩起来满足 $u\cdot m^r\equiv v\cdot m^r\pmod k$ 的点就好了 .

关于 $ak\equiv bk\pmod p$ 的判定的经典做法是转为 $a\equiv m\pmod{p/\gcd(k,p)}$ .

时间复杂度大概是 $O(\log_bm)$？代码如下：

```cpp
// 使用 C++11 或 C++14 编译，不要使用过低或过高的语言标准
using i128 = __int128;
i128 gcd(i128 a, i128 b){return b ? gcd(b, a % b) : a;}
ll b, m;
int main()
{
	int T; scanf("%d", &T);
	while (T--)
	{
		scanf("%lld%lld", &b, &m);
		ll ans = 0;
		i128 br = 1, gr = 1;
		int r = 0;
		while (true)
		{
			i128 grp = gcd(gr * b, m);
			if ((grp == gr) || (m / grp * gr + br > m)){ans += m / gr; break;}
			ans += br / gr;
			if (m / b < br){ans += m / grp; break;}
			++r; br *= b; gr = grp;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

注：

**Myhill–Nerode 定理**：DFA 中的两个状态 $u, v$ 等价（即可合并为同一个状态），当且仅当对于所有字符串 $s$（可以为空），$u$ 依次经过 $s$ 转移到的状态 $u'$，与 $v$ 依次经过 $s$ 转移到的状态 $v'$，要么同时是接受状态，要么同时不是接受状态 .

即对于所有字符串 $s$，不能有 $u', v'$ 恰有其中一个是接受状态的情况，只有此时两状态 $u, v$ 才等价；  
如果存在使得 $u', v'$ 恰有其中一个是接受状态的字符串 $s$，则 $u, v$ 不等价，即不可合并为同一个状态 .

---

## 作者：Illusory_dimes (赞：2)

[不知道更好还是更坏的阅读体验](https://www.cnblogs.com/Illusory-dimes/p/15888217.html)

复盘 cdw 讲的题，写篇题解~~来祸害社会~~（

## Description

给定 $m$ 和 $k$ ，要求构造这样的一张图，满足以下条件：

- 每个点恰好有 $m$ 条出边，每个出边都恰好有一个转移值 $\in [0, m)$ 。

- 从初始点开始，走一条长度为 $k$ 的路径，并且回到出发节点，路径上所有转移构成的一个 $m$ 进制的数恰为 $k$ 的倍数。

- 图无限制，可有自环和重边。

要求一个总点数最少的图，求这个点数 $n$ 。

多测。

$1\leq m,\ k \leq 10 ^ {18},\ 1\leq t \leq 3 \cdot 10 ^ 5$

## Solution

能明显感觉到这玩意的定义有点像 DFA ，但是用处不大所以我们不去管他。

### n = k

（注：初始节点定为 $0$ ，对于状态表示更方便

先满足第一个限制，这样就有一个有着无限个点的 $m$ 叉树，每条边能够按照题目的意思分配好转移值，那么每个点对应的状态就是从初始状态到自己的路径组成的 $m$ 进制数。

形式化表达就是对于一个点对应的状态 $u$ ，儿子的状态为 $u \cdot m + i,\ i \in [0,\ m)$

考虑怎么一步到位，满足第二个限制，我们知道，如果要求一个数是 $k$ 的倍数，那么在树上的 $m$ 个儿子在模 $k$ 意义下本质上还是一样的，那么我们就直接考虑对所有状态的值模 $k$ 。

恰好所有 $k$ 的倍数最终会连回初始节点同时因为有限制三，我们无论如何都不会连的不合法，所以这样我们就一次性得到了一个点数为 $k$ 的满足条件的图。

### n < k

这里同 SAM 一样，我们要求的是一个点数尽量少的图，所以我们也要考虑考虑缩点的问题。

假如两个点 $a$ 和 $b$ 能被缩到一起，那么一定有：

- $\forall\ i \in [0,\ m),\ (a \cdot m + i) \equiv (b \cdot m + i)\ ({\rm mod}\ k)$

或者

- $\forall\ i \in [0,\ m),\ (a \cdot m + i) \equiv b\ ({\rm mod}\ k)$

再或者

- $\forall\ i \in [0,\ m),\ (b \cdot m + i) \equiv a\ ({\rm mod}\ k)$

形式化理解就是要么这两个状态全部指向同样的点，要么无论从哪个点进入状态 $1$ ，它都会给你怼到状态 $2$ 去，这样的话明显我们不需要建立两个点，就可以缩掉。

其实我们还可以进一步感受到一个地方就是上文提到的后两种情况，因为 $i$ 是连续的整数，所以只有可能是 $k = 1$ 的情况，这种情况又只有 $0$ 它自己，所以说可以忽略。

所以我们就只有这样的一个限制：

$$\forall\ i \in [0,\ m),\ (a \cdot m + i) \equiv (b \cdot m + i)\ ({\rm mod}\ k)$$

$$\Rightarrow a \cdot m \equiv b \cdot m\ ({\rm mod}\ k)$$

此时 $m$ 和 $k$ 可能不互质，我们令 $g = \gcd(m, k),\ k^{'} = k / g,\ m^{'} = m / g$ ，有。

$$\Rightarrow a \cdot m^{'} \equiv b \cdot m^{'}\ ({\rm mod}\ k^{'})$$

此时则必然有 $a \equiv b\ ({\rm mod}\ k ^ {'})$ ，具体证明（其实不是很重要，意会意会就行了）：

> 使 $a$ 和 $b$ 能表示成： $a = i \cdot k ^ {'} + x,\ b = j \cdot k ^ {'} + y$ 其中 $x$ 和 $y$ 均小于 $k ^ {'}$ 。
则有： $a \equiv x\ ({\rm mod}\ k ^ {'}),\ b \equiv y\ ({\rm mod}\ k ^ {'})$ 。
同时也有：$a \cdot m ^ {'} \equiv (i \cdot k ^ {'} + x) \cdot m ^ {'} \equiv x \cdot m ^ {'}\ ({\rm mod}\ k ^ {'}),\ b \cdot m ^ {'} \equiv (j \cdot k ^ {'} + y) \cdot m ^ {'} \equiv y \cdot m ^ {'}\ ({\rm mod}\ k ^ {'})$
所以：$x \cdot m ^ {'} \equiv y \cdot m ^ {'}\ ({\rm mod}\ k ^ {'})$
因为注意到 $x$ 和 $y$ 的范围不超过 $k ^ {'}$ ，所以有：$x \equiv y\ ({\rm mod}\ k ^ {'})$
所以：$a \equiv b\ ({\rm mod}\ k ^ {'})$

所以很明显在新的模 $k ^ {'}$ 的意义下相同的数都要合并到一起，然后你手模了三个样例，发现全部满足，然后就结束了吗？？

当 $m = 2,\ k = 8$ 的时候，手摸完发现点数变成了 $5$ 个，但是似乎还可以继续合并成 $4$ 个点。但是在刚刚的步骤中仅仅只操作了一次，所以这个做法并不完美。

那怎么处理能够多次缩点的情况呢？？

其实我们能感觉到这有点子问题的意思，在这些缩完的点中，其实就是在新的 $k ^ {'}$ 之下一个新的图，所以按照之前的做法，我们可以总结出：$a \cdot m^p \equiv b \cdot m^p\ ({\rm mod}\ k^{'})$ ，而每次我们只需要把新的 $k$ 传下去做递归，直到不能再缩为止。

注意到可能相乘会爆 long long ，所以乘化除就行了。

## Code

```cpp
/*

*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll m, k;
inline ll read() {
	char ch = getchar();
	ll s = 0, w = 1;
	while (!isdigit(ch)) {if (ch == '-') w = -1; ch = getchar();}
	while (isdigit(ch)) {s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar();}
	return s * w;
}
inline ll gcd(ll a, ll b) {return (!b) ? a : gcd(b, a % b);}
inline ll solve(ll now, ll t, ll k) {
	ll g = gcd(m, k), _k = k / g, _m = m / g;
	if (g == 1 || now <= _k) return 0;
	if ((double)_k / _m < t) return now - _k;
	t *= _m;
	return solve(_k - t, t, _k) + now - _k;
}
inline void mian() {
	m = read(); k = read();
	printf("%lld\n", k - solve(k - 1, 1, k));
}
int main() {
	int T = read();
	while (T--) mian();
	return 0;
}
```

---

## 作者：Larunatrecy (赞：1)

方便起见，我们把点编号为 $0\to n-1$ 。

首先，我们很容易可以构造出一个上界 $K$，因为只需要让点 $x$ 的第 $i$ 条边连向 $(x\times m+i )\bmod K$ 即可。

我们的任务就是把这个 ```DFA``` 压缩一下，换言之把等价的节点缩起来。

设函数 ```solve(n,K)``` 表示当前除了 $0$ 之外还剩下 $n$ 个点，当前的模数为 $K$ 时，会删掉多少节点，我们希望通过递归实现多层压缩。


两个节点等价当且仅当他们出边到的点集合相同，也就是 $\forall i\in [0,m-1], xm+i\equiv ym+i \pmod K $ ，即 $xm\equiv ym \pmod K $ 。


记 $d=\gcd(m,K),f(x)=(xm)\bmod K$，那么通过简单的数论知识我们可以推出：

- $d|f(x)$

- $f(x)$ 每 $\frac{K}{d}$ 个一循环

那我们可以把 $f(x)$ 相同的缩起来，会形成最多 $\frac{K}{d}$ 个点。

这里有几种简单的边界情况：

- $d=1$，那么所有的数都不同，返回 $0$

- $L\leq \frac{K}{d}$，此时一个循环节都没跑满肯定也不重复，返回 $0$ 。

否则会剩下 $\frac{K}{d}$ 个点，也就是删掉 $n-\frac{K}{d}$ 个点。

但是有一点需要注意，如果初始的图中节点 $x$ 可以通过 $h(x)$ 步回到 $0$ 点，那么它最多只能参与 $h(x)$ 轮缩点，因为每一轮缩点相当于把 $h(x)-1$，而 $0$ 是不能参与缩点的。

更精确的，我们可以知道，如果存在 $j\in [0,m-1]$，$f(x)+j = K$，那么这些点都可以一步到原点。

因此，进行下一层递归时，剩余的可以缩点的点数应当是 $\frac{K}{d}-r$，其中 $r$ 是已经可以到达 $0$ 点的点个数，实际上就是每一轮缩点的 $\frac{m}{d}$ 的乘积。

注意一下 $r$ 可能会很大，要开 ```int128``` 。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef __int128 BIG;
LL gcd(LL a,LL b)
{
	if(!b)return a;
	return gcd(b,a%b);
}
LL m;
LL solve(LL n,BIG r,LL k)
{
	LL d=gcd(m,k),M=m/d,K=k/d;
	if(d==1) return 0;
	if(n<=K) return 0;
	if((BIG)K<r*M) return n-K;
	r*=M;
	return solve(K-r,r,K)+n-K; 
} 
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		LL k;
		scanf("%lld %lld",&m,&k);
		printf("%lld\n",k-solve(k-1,1,k));
	}
	return 0;
} 
```

---


# [COCI 2009/2010 #1] ALADIN

## 题目描述

给你 $n$ 个盒子，有 $q$ 个操作，操作有两种：

- 第一种操作输入格式为 `1 L R A B`，表示将编号为 $L$ 到 $R$ 的盒子里的石头数量变为 $(X-L+1) \times A \bmod B$，其中 $X$ 为盒子的编号。
- 第二种操作输入格式为 `2 L R`，表示查询编号为 $L$ 到 $R$ 的盒子里的石头总数。

## 说明/提示

- 对于 $30\%$ 的数据，$n, q \leq 10^3$；
- 对于 $70\%$ 的数据，$q \leq 10^3$。

对于 $100\%$ 的数据，$1\leq A,B\leq 10^6$。

## 样例 #1

### 输入

```
6 3
2 1 6
1 1 5 1 2
2 1 6
```

### 输出

```
0
3```

## 样例 #2

### 输入

```
4 5
1 1 4 3 4
2 1 1
2 2 2
2 3 3
2 4 4
```

### 输出

```
3
2
1
0```

## 样例 #3

### 输入

```
4 4
1 1 4 7 9
2 1 4
1 1 4 1 1
2 1 4
```

### 输出

```
16
0```

# 题解

## 作者：浅色调 (赞：23)

### Solution：

　　本题黑的不行啊，两天就荒(废)在这题上了！

　　思路：数学大套路+线段树。

　　题目中唯一出现的数学式子：$\sum\limits_{i=1}^{i\leq n} {(i*A\mod B)}$，那么切入点当然是如何快速求该式子咯。

　　我们对式子变形：原式$=A*\sum\limits_{i=1}^{i\leq n}{i}-B*\sum\limits_{i=1}^{i\leq n}{\lfloor \frac{i*A}{B} \rfloor}$。

　　被减数式子很好算直接忽略，减数式子的解决关键是式子$\sum\limits_{i=1}^{i\leq n}{\lfloor \frac{i*A}{B} \rfloor}$，对此式子我们分情况讨论（$A==B$的情况该式子为0，直接忽略咯）：

$\quad\quad\quad$ 1、$A>B$，我们假设$A=kB+r$，则原式子化为$\sum\limits_{i=1}^{i\leq n}{\lfloor \frac{i*(kB+r)}{B} \rfloor}=k*\sum\limits_{i=1}^{i\leq n}{i}+\sum\limits_{i=1}^{i\leq n}{\lfloor \frac{i*r}{B} \rfloor}$，我们把$r$当作新的$A$，那么就将该式子转化为了$A<B$的情况，于是关键就成了$A<B$时如何快速求原式子。

$\quad\quad\quad$ 2、$A<B$，我们将其抽象到平面直角坐标系上，不难发现$\sum\limits_{i=1}^{i\leq n}{\lfloor \frac{i*A}{B} \rfloor}$实际求的是坐标为$(0,0),(n,0),(n,\frac{n*A}{B})$三点围成的三角形的不在$X$轴上的格点个数，可能有点难以理解，我们画图理解（~~留图待画~~、手绘勿喷）：![](http://images2018.cnblogs.com/blog/1240891/201809/1240891-20180908080941500-263541017.png)

如图，对角线上每个被标记的点到x轴的垂线段上的格点（除开x轴的格点），所对应的就是每个$\lfloor \frac{i*A}{B} \rfloor$。我们若直接算下三角的格点个数会很麻烦，但是很容易算出整个矩形的格点个数，我们设$m=\lfloor \frac{n*A}{B} \rfloor$，则矩形的格点个数为$n*m$，我们用矩形的格点个数-上三角的格点个数+对角线上的格点个数，就能得到原式子的值。如何求上三角的格点个数和对角线的格点个数呢？我们把上三角逆时针旋转90度，就能得到一个类似于下三角的一条边为整数的三角形，用同样的方法去求，发现上三角的格点个数恰好等于$\sum\limits_{i=1}^{i\leq m}{\lfloor \frac{i*B}{A} \rfloor}$，因为$A<B$，我们又回到了第1种$A>B$情况，于是可以递归去求（递归边界就是$A|B$返回0）。而对角线斜率为$\frac{\frac{A}{gcd(A,B)}}{\frac{B}{gcd(A,B)}}$，那么横坐标每隔$\frac{B}{gcd(A,B)}$个单位会有一个格点出现，所以对角线上共有$\frac{n*gcd(A,B)}{B}$个格点。不难发现整个递归过程就是个类欧几里得的求法，时间复杂度为$O(\log n)$

　　有了上面的结论，我们就能在$O(\log n)$的复杂度下修改一段区间，那么对于原题的区间查询，我们使用懒惰标记，记录每段被修改的$A,B$和前一个点位置$st$，然后任意一度区间$[l,r]$的和都可以用$sum[r]-sum[l-1]$去算，而每个$sum[i]$直接调用上面的递归过程就好了。

　　细节太多，注意：区间肯定得离散，而求区间和时用到了前缀和的思想，一个简单的离散方法是对询问的$l,r$，将$l-1,r$离散，然后线段树建树时每个节点维护的是一整段区间，要把每段小的区间都表示出来（开始30分的原因）。

　　最后总时间复杂度$O(q\log^2 n)$，稳妥！（>.^_^.<咕咕）


$\quad\;\;$**欢迎来踩博客**：[five20](https://www.cnblogs.com/five20/p/9607384.html)（蒟蒻写题解不易，转载请注明出处，万分感谢～！）

### 代码：
```cpp
    /*Code by 520 -- 9.7*/
    #include<bits/stdc++.h>
    #define il inline
    #define ll long long
    #define RE register
    #define For(i,a,b) for(RE int (i)=(a);(i)<=(b);++(i))
    #define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);--(i))
    #define lson l,m,rt<<1
    #define rson m,r,rt<<1|1
    using namespace std;
    const int N=1000005;
    int n,m,flag[N],L[N],R[N],*Q[N],cnt,tot,val[N];
    ll A[N],B[N];
    struct node{
        ll sum,a,b,st,len;
    }t[N];
    int gi(){
        int a=0;char x=getchar();
        while(x<'0'||x>'9')x=getchar();
        while(x>='0'&&x<='9')a=(a<<3)+(a<<1)+(x^48),x=getchar();
        return a;
    }
    il bool cmp(int *a,int *b){return *a<*b;}
    ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
    ll calc(ll a,ll b,ll n){
        ll x=a/b;a%=b;
        ll sum=n*(n+1)/2*x;
        if(!a||!b) return sum;
        ll lala=n/b,m=a*n/b;
        return sum+n*m-calc(b,a,m)+lala;
    }
    il ll solve(ll a,ll b,ll n){
        if(n<1)return 0;
        ll g=gcd(a,b);
        return n*(n+1)/2*a-b*calc(a/g,b/g,n);
    }
    il void pushup(int rt){t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;}
    il void gai(ll A,ll B,ll st,int rt){
        t[rt].a=A,t[rt].b=B,t[rt].st=st;
        t[rt].sum=solve(A,B,st+t[rt].len-1)-solve(A,B,st-1);
    }    
    il void pushdown(int rt){
        if(t[rt].b){
            gai(t[rt].a,t[rt].b,t[rt].st,rt<<1);
            gai(t[rt].a,t[rt].b,t[rt].st+t[rt<<1].len,rt<<1|1);
            t[rt].b=0;
        }
    }
    void build(int l,int r,int rt){
        if(l+1==r){t[rt]=node{0,0,0,0,val[r]-val[l]};return;}
        int m=l+r>>1;
        t[rt]=node{0,0,0,0,val[r]-val[l]};
        build(lson),build(rson);
    }
    void update(ll A,ll B,int L,int R,int l,int r,int rt){
        if(R<=l||r<=L)return;
        if(L<=l&&R>=r){gai(A,B,val[l]-val[L]+1,rt);return;}
        pushdown(rt);
        int m=l+r>>1;
        if(L<=m) update(A,B,L,R,lson);
        if(R>=m) update(A,B,L,R,rson);
        pushup(rt);
    }
    ll query(int L,int R,int l,int r,int rt){
        if(R<=l||r<=L)return 0;
        if(L<=l&&R>=r)return t[rt].sum;
        pushdown(rt);
        int m=l+r>>1;
        ll ret=0;
        if(L<=m) ret+=query(L,R,lson);
        if(R>=m) ret+=query(L,R,rson);
        return ret;
    }
    int main(){
        n=gi(),m=gi();
        For(i,1,m) {
            flag[i]=gi(),L[i]=gi()-1,R[i]=gi(),Q[++tot]=&L[i],Q[++tot]=&R[i];
            if(flag[i]==1) A[i]=gi(),B[i]=gi();
        }
        sort(Q+1,Q+tot+1,cmp);
        int lst=-1;
        For(i,1,tot) if(*Q[i]!=lst) lst=*Q[i],*Q[i]=++cnt,val[cnt]=lst;else *Q[i]=cnt;
        build(1,cnt,1);
        For(i,1,m)
            if(flag[i]==1) update(A[i],B[i],L[i],R[i],1,cnt,1);
            else printf("%lld\n",query(L[i],R[i],1,cnt,1));
        return 0;
    }    
```


---

## 作者：251Sec (赞：6)

思维含量很低的题目，但是实现有些麻烦。

## 题意

维护一个数据结构，支持区间赋值对指定值取模的等差数列，支持区间求和。

## 分析

把一个等差数列劈成两半就是两个等差数列。所以可以用线段树维护。

线段树每个节点维护等差数列首项，公差，模数，那么就是线段树的基础操作了。

接下来唯一的问题就是一个等差数列对某个数取模之后的和是多少怎么求。

$$\begin{aligned}\sum\limits_{i=0}^{n-1}(Ai+B) \bmod C &=\sum\limits_{i=0}^{n-1}\left(Ai+B-C\left\lfloor\dfrac{Ai+B}{C}\right\rfloor\right) \\ &=\dfrac{An(n-1)}{2}+Bn-C\sum\limits_{i=0}^{n-1}\left\lfloor\dfrac{Ai+B}{C}\right\rfloor\end{aligned}$$

发现 $\sum\limits_{i=0}^{n-1}\left\lfloor\dfrac{Ai+B}{C}\right\rfloor$ 可以使用[类欧几里得算法](https://www.luogu.com.cn/problem/P5170)求解。

另外 $n \leq 10^9$，因此需要离散化（直接动态开点其实也差不太多，但是这题 64MB 的确比较紧所以还是离散化吧）。我们让每个查询和修改操作把整个 $[1,n]$ 的区间划分成若干小的区间，然后线段树的每个叶子节点对应这里一个区间。注意到 $q \leq 5 \times 10^4$，因此线段树节点在 $2 \times 10^5$ 级别，完全能过！

细节有点多，可以看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define lson tr[tr[p].ls]
#define rson tr[tr[p].rs]
#define self tr[p]
struct Node {
	ll val;
	int a, b, c;
	int ls, rs;
	int l, r;
} tr[200005];
struct Quest {
	int op, l, r, a, b;
} qu[50005];
int cnt;
int NewNode() {
	tr[++cnt].ls = 0;
	tr[cnt].rs = 0;
	tr[cnt].l = tr[cnt].r = 0;
	tr[cnt].a = -1;
	tr[cnt].b = tr[cnt].c = 0;
	return cnt;
}
int b[100005], len;
int Build(int l, int r) {
	int p = NewNode();
	if (l == r) {
		self.l = b[l];
		self.r = b[l + 1] - 1;
		return p;
	}
	int mid = l + r >> 1;
	self.ls = Build(l, mid);
	self.rs = Build(mid + 1, r);
	self.l = lson.l;
	self.r = rson.r;
	return p;
}
ll f(ll a, ll b, ll c, ll n) {
    if (a >= c || b >= c) {
        return n * (n + 1) / 2 * (a / c) + (n + 1) * (b / c) + f(a % c, b % c, c, n);
    }
    if (!a) {
        return b / c * (n + 1);
    }
    return (a * n + b) / c * n - f(c, c - b - 1, a, (a * n + b) / c - 1);
}
ll g(ll a, ll b, ll c, ll n) {
    return n * (n - 1) / 2 * a - c * f(a, b, c, n - 1) + b * n;
}
void Pushdown(int p) {
	if (p && ~tr[p].a) {
		lson.a = self.a;
		lson.b = self.b;
		lson.c = self.c;
		lson.val = g(lson.a, lson.b, lson.c, lson.r - lson.l + 1);
		rson.a = self.a;
		rson.b = (self.b + 1ll * self.a * (rson.l - self.l) % self.c) % self.c;
		rson.c = self.c;
		rson.val = g(rson.a, rson.b, rson.c, rson.r - rson.l + 1);
		self.a = -1;
	}
}
void Modify(int p, int l, int r, ll a, ll c) {
	if (self.l > r || self.r < l) return;
	if (self.l >= l && self.r <= r) {
		self.a = a;
		self.b = (self.l - l + 1) * a % c;
		self.c = c;
		self.val = g(self.a, self.b, self.c, self.r - self.l + 1);
		return;
	}
	Pushdown(p);
	Modify(self.ls, l, r, a, c);
	Modify(self.rs, l, r, a, c);
	self.val = lson.val + rson.val;
}
ll Query(int p, int l, int r) {
	if (self.l > r || self.r < l) return 0;
	if (self.l >= l && self.r <= r) {
		return self.val;
	}
	Pushdown(p);
	return Query(self.ls, l, r) + Query(self.rs, l, r);
}
int n, q;
int root;
int main() {
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= q; i++) {
		scanf("%d%d%d", &qu[i].op, &qu[i].l, &qu[i].r);
		b[++len] = qu[i].l;
		b[++len] = qu[i].r + 1;
		if (qu[i].op == 1) {
			scanf("%d%d", &qu[i].a, &qu[i].b);
		}
	}
	sort(b + 1, b + len + 1);
	len = unique(b + 1, b + len + 1) - b - 1;
	root = Build(1, len - 1);
	for (int i = 1; i <= q; i++) {
		if (qu[i].op == 1) {
			Modify(root, qu[i].l, qu[i].r, qu[i].a, qu[i].b);
		}
		else {
			printf("%lld\n", Query(root, qu[i].l, qu[i].r));
		}
	}
	return 0;
}
```

---

## 作者：Pengzt (赞：5)

[P4433](https://www.luogu.com.cn/problem/P4433)

[cnblogs](https://www.cnblogs.com/Pengzt/p/18012481/solution-P4433)

### Problem

有一个长度为 $n$ 初始所有元素均为为 $0$ 的数列 $a$。

要求支持两种操作：

+ 给定 $L, R, A, B$，表示对于 $\forall i\in [L, R]$，$a_i \gets (A\times (i - L + 1)) \bmod B$。

+ 给定 $L, R$，输出 $\sum\limits_{i = L}^{R} a_i$。

$1\le n\le 10^9, 1\le q\le 5\times 10^4$。

时空限制：8s, 64MB。

保证任何时候 $\sum\limits_{i = 1}^{n} a_i < 2^{63} - 1$？

### Sol

发现这个东西和等差数列相似，易于下传标记，考虑用线段树维护。

发现模数不固定，就不能直接加一个模数的 tag。于是考虑拆开修改的贡献，有一个常用的模数相关的 trick，就是 $A\bmod B = A - \lfloor\frac{A}{B}\rfloor\times B$。思考操作 $L, R, A, B$ 会对线段树上的 $[l, r]\in [L, R]$ 的节点的 $sum$ 会产生什么影响：$\sum \limits_{i = L}^{R} A\times (i - L + 1) \bmod B = A\times \frac{(R - L + 1)\times (R - L + 2)}{2} - B\sum\limits_{i = L}^{R} \lfloor\frac{A(i - L + 1)}{B}\rfloor$。前面的部分显然可以直接下传，计算。后面的部分不是很好计算，去掉 $B$ 换一个形式，并用 $len$ 替代 $R - L + 1$，得到：$\sum \limits_{i = 1}^{len} \lfloor \frac{Ai}{B} \rfloor$。发现这就是一个类欧板子，甚至没有了板子的常数项，会类欧的可以直接跳过下面一段。

-------

求解 $\sum\limits_{i = 0}^{n} \lfloor\frac{Ai + C}{B}\rfloor$：

若 $A = 0$ 是简单的，即 $(n + 1)\lfloor \frac{C}{B} \rfloor$。

若 $A\le B \wedge C\le B$：令 $m = \lfloor \frac{An + C}{B}\rfloor$，$\sum\limits_{i = 0}^{n} \lfloor\frac{Ai + C}{B}\rfloor = \sum\limits_{i = 0}^{n} \sum\limits_{j = 1}^{m}[j \le \lfloor \frac{Ai + C}{B} \rfloor]$。其中的中括号是艾弗森括号，其满足条件值为 $1$，否则为 $0$。向下取整是很麻烦的，用向下取整的相关性质去掉除号：

$$\sum\limits_{j = 1}^{m} j\le \lfloor\frac{Ai + C}{B}\rfloor$$

$$\Leftrightarrow\sum \limits_{j = 0}^{m - 1} [B(j + 1) \le B\lfloor \frac{Ai + C}{B} \rfloor]$$

$$\Leftrightarrow \sum \limits_{j = 0}^{m - 1} [Bj + B - 1 < Ai + C]$$

$$\Leftrightarrow \sum \limits_{j = 0}^{m - 1} [\frac{Bj + B - C - 1}{A} < i]$$

带入得到：$\sum\limits_{i = 0}^{n}\sum \limits_{j = 0}^{m - 1} [\frac{Bj + B - C - 1}{A} < i]$，交换 $i, j$ 维可以得到 $\sum \limits_{j = 0}^{m - 1}\sum\limits_{i = 0}^{n}[\frac{Bj + B - C - 1}{A} < i]$，然后发现后面部分的贡献可以直接计算，于是可以得到 $\sum \limits_{j = 0}^{m - 1}n - \lfloor\frac{Bj + B - C - 1}{A}\rfloor$，在化一下变成 $mn - \sum\limits_{i = 0}^{m - 1}\lfloor \frac{Bi + B - C - 1}{A} \rfloor$。若记 $f(A, B, C, n)$ 表示 $\sum\limits_{i = 0}^{n} \lfloor\frac{Ai + C}{B}\rfloor$，后面的和式显然就是 $f(B, B - C - 1, A, m - 1)$，递归计算即可。

否则有 $\sum\limits_{i = 0}^{n} \lfloor\frac{Ai + C}{B}\rfloor \Leftrightarrow \sum\limits_{i = 0}^{n} \lfloor\frac{(A\bmod B)i + (C \bmod B)}{B}\rfloor + \frac{n(n + 1)}{2}\lfloor \frac{A}{B}\rfloor + (n + 1) \lfloor \frac{C}{B} \rfloor$，前半部分为 $f(A\bmod B, C\bmod B, B, n)$ 继续递归即可。

-------

具体地，在线段树上维护形如 $(a, b, t)$ 的 tag，表示覆盖的是在当前的 $[L, R]$ 中，$\lfloor\frac{ai}{b}\rfloor$ 的 $i$ 是从 $t$ 开始覆盖的，然后线段树进行区间修改和区间求和即可。

类欧的操作三的复杂度证明参考欧几里得算法，即次数为 $\mathcal{O}(\log n)$ 的，而执行第二种操作之后再执行一次 $a$ 就会变为 $0$。所以更新线段树上单个节点的复杂度为 $\mathcal{O}(\log n)$，则总时间复杂度为 $\mathcal{O}(q\log^2 n)$ 的，空间在离散化后可做到 $\mathcal{O}(q)$。

### Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define sz(a) ((int) (a).size())
#define vi vector < int >
#define pb emplace_back
#define pii pair < int, int >
#define fi first
#define se second
using namespace std;
int n, m, num;
int b[100010];
struct ques {
	int opt, l, r, a, b;
} q[50010];
ll solve(ll a, ll b, ll c, ll n) {
	if(!a)
		return b / c * (n + 1);
	if(a >= c || b >= c)
		return n * (n + 1) / 2 * (a / c) + (b / c) * (n + 1) + solve(a % c, b % c, c, n);
	ll m = (a * n + b) / c;
	return m * n - solve(c, c - b - 1, a, m - 1);
}
struct Tag {
	ll a, b, t;
	Tag(ll _a = 0, ll _b = 0, ll _t = 0) {
		a = _a, b = _b, t = _t;
	}
}; 
struct segtree {
	Tag laz[400010];
	ll val[400010];
	void tag(int x, ll L, ll R, ll va, ll vb, int t) {
		L = b[L], R = b[R + 1] - 1;
		val[x] = (R - L + 2 + 2 * t) * (R - L + 1) / 2 * va - vb * (solve(va, 0, vb, R - L + 1 + t) - solve(va, 0, vb, t));
		laz[x].a = va, laz[x].b = vb, laz[x].t = t;
	}
	void down(int x, int L, int R) {
		if(laz[x].a && laz[x].b) {
			int mid = (L + R) >> 1;
			tag(x << 1, L, mid, laz[x].a, laz[x].b, laz[x].t);
			tag(x << 1 | 1, mid + 1, R, laz[x].a, laz[x].b, laz[x].t + b[mid + 1] - b[L]);
			laz[x].a = laz[x].b = laz[x].t = 0;
		}
	}
	void modify(int x, int L, int R, int l, int r, ll va, ll vb) {
		if(l <= L && R <= r)
			return tag(x, L, R, va, vb, b[L] - b[l]);
		down(x, L, R);
		int mid = (L + R) >> 1;
		if(l <= mid)
			modify(x << 1, L, mid, l, r, va, vb);
		if(r > mid)
			modify(x << 1 | 1, mid + 1, R, l, r, va, vb);
		val[x] = val[x << 1] + val[x << 1 | 1];
	}
	ll query(int x, int L, int R, int l, int r) {
		if(l <= L && R <= r)
			return val[x];
		down(x, L, R);
		int mid = (L + R) >> 1; ll res = 0;
		if(l <= mid)
			res = query(x << 1, L, mid, l, r);
		if(r > mid)
			res += query(x << 1 | 1, mid + 1, R, l, r);
		return res;
	}
} t;
int main() {
	ios :: sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	n = 0;
	for(int i = 1; i <= m; ++i) {
		cin >> q[i].opt >> q[i].l >> q[i].r;
		b[++n] = q[i].l;
		b[++n] = ++q[i].r;
		if(q[i].opt == 1)
			cin >> q[i].a >> q[i].b;
	}
	sort(b + 1, b + n + 1);
	n = unique(b + 1, b + n + 1) - b - 1;
	for(int i = 1; i <= m; ++i) {
		int l = q[i].l, r = q[i].r;
		l = lower_bound(b + 1, b + n + 1, l) - b;
		r = lower_bound(b + 1, b + n + 1, r) - b - 1;
		if(q[i].opt == 1)
			t.modify(1, 1, n - 1, l, r, q[i].a, q[i].b);
		else
			cout << t.query(1, 1, n - 1, l, r) << "\n";
	}
	return 0;
}
```


---

## 作者：chzhc (赞：4)

### 题意

有两种操作：

1. 将第 $X$ 个位置上（$X \in [L ,R]$） 的数字变为 $((X - L + 1) \times A) \bmod B$。

2. 查询 $[L, R]$ 的数字和。

### 做法

线段树 + 类欧几里得算法。

首先，对于一个线段树上的区间，我们只需要记录 $L, A, B$，然后我们考虑如何求出答案。

对于相同 $L, A, B$ 的区间 $[l, r]$，其贡献显然为
$$
\sum_{i=l}^r (((i - L + 1) \times A) \bmod B)
$$
记 
$$
\operatorname{F}(n) = \sum_{i = 0} ^n (((i - L + 1) \times A) \bmod B)
$$
则贡献可改写为 
$$
\operatorname{F}(r) - \operatorname{F}(l - 1)
$$
考虑求 $\operatorname {F}(n)$，首先把取模去掉，可改写为
$$
\operatorname {F}(n) = \sum_{i=0}^n \left(((i - L + 1) \times A) - \left \lfloor \frac{((i - L + 1) \times A)}{B} \right \rfloor B \right)
$$
前半部分的贡献可以直接算，考虑求后半部分的贡献。
$$
\sum_{i=0}^n \left \lfloor \frac{((i - L + 1) \times A)}{B} \right \rfloor B = B\sum_{i=0}^n \left \lfloor \frac{iA + (A - LA)}{B} \right \rfloor
$$
定义 
$$
f(a, b, c, n) = \sum_{i=0}^n \left \lfloor \frac{ia + b}{c} \right \rfloor
$$
发现原式其实就是
$$
B f(A, A - LA, B, n)
$$
而 $f(a, b, c, n)$ 可以做到 $\mathcal O(\log n)$ 计算。

具体如下：
若 $a \geq c$ 或 $b \geq c$，我们可以将 $a, b$ 对 $c$ 取模以简化问题。
考虑到
$$
x = \left \lfloor \frac{x}{c}\right \rfloor c + x \bmod c
$$
故
$$
f(a, b, c, n) = \sum_{i=0}^n \left\lfloor\frac{ai + b}{c}\right\rfloor 
   		      = \sum_{i=0}^n \left\lfloor\frac{(\left \lfloor \frac{a}{c}\right \rfloor c + a \bmod c)i + (\left \lfloor \frac{b}{c}\right \rfloor c + b \bmod c)}{c}\right\rfloor 
$$
$$
= \frac{n(n + 1)}{2} \left \lfloor \frac{a}{c}\right \rfloor + (n+1) \left \lfloor \frac{b}{c}\right \rfloor + f(a \bmod c , b\bmod c, c, n)
$$
此时一定有 $a < c$ 且 $b < c$。

令 
$$
S(i)={\left\lfloor\frac{ai + b}{c}\right\rfloor} - 1
$$
再进行转化

$$
\sum_{i=0}^n \left\lfloor\frac{ai + b}{c}\right\rfloor 
= \sum_{i=0}^n \sum_{j=0}^{S(i)} 1
= \sum_{j=0}^{S(n)} \sum_{i=0}^n \left[ j \leq S(i) \right]
$$

考虑到
$$
j \leq S(i) \iff j + 1 \leq {\left\lfloor\frac{ai + b}{c}\right\rfloor} 
$$
$$
j + 1 \leq {\left\lfloor\frac{ai + b}{c}\right\rfloor} \iff j + 1 \leq \frac{ai + b}{c} 
$$
$$
j + 1 \leq \frac{ai + b}{c} \iff jc + c \leq ai + b 
$$
$$
jc + c \leq ai + b \iff jc + c - b \leq ai 
$$
$$
jc + c - b \leq ai \iff jc + c - b - 1 < ai 
$$
$$
jc + c - b - 1 < ai \iff \left \lfloor \frac{jc + c - b - 1}{a} \right \rfloor < i
$$
故
$$
\sum_{j=0}^{S(n)} \sum_{i=0}^n \left[ j \leq S(i) \right] 
= \sum_{j=0}^{S(n)} \sum_{i=0}^n \left[ i > \left \lfloor \frac{jc + c - b - 1}{a} \right \rfloor\right] 
$$
$$
= \sum_{j=0}^{S(n)} \left(n - \left \lfloor \frac{jc + c - b - 1}{a} \right \rfloor \right) 
$$
$$
= (S(n) + 1)n - \sum_{j=0}^{S(n)} \left \lfloor \frac{c j + (c - b - 1)}{a} \right \rfloor 
$$
$$
= (S(n) + 1)n - f(c, c - b - 1, a, S(n))
$$
故 
$$
f(a, b, c, n) = (S(n) + 1)n - f(c, c - b - 1, a, S(n))
$$


可以发现，上述式子是一个递归式，我们不断重复上述过程，先取模，后递归，其实就是辗转相除的过程，时间复杂度 $\mathcal O(\log n)$。

以上内容来自[我的博客](https://www.cnblogs.com/chzhc-/p/15984626.html)，可以去里面查看更多内容。

于是这道题就可以在 $\mathcal O(q \log^2 n)$ 做完。

由于线段树上分叉的结点也会有贡献，所以也需要加上，注意细节即可。

```cpp
#include <bits/stdc++.h>
const int Q = 5e4 + 10;

int n, q;

int a[Q * 2], cnt, newcnt;
int op[Q], A[Q], B[Q], L[Q], R[Q];
int val[Q * 2];

struct sgt
{
    int A, B, L;
    long long sum;
    int tag, l, r;
    int forkA, forkB, forkL;
} t[Q * 8];

inline long long S(int a, long long b, int c, int i)
{
    return ((1ll * a * i + b) / (1ll * c)) - 1ll;
}

inline long long solve(int a, long long b, int c, long long n)
{
    if (a == 0)
        return 1ll * (b / c) * (n + 1);
    if (a >= c || b >= c)
        return 1ll * n * (n + 1) / 2 * (a / c) + 1ll * (n + 1) * (b / c) + solve(a % c, b % c, c, n);
    return 1ll * (S(a, b, c, n) + 1) * n - solve(c, c - b - 1, a, S(a, b, c, n));
}

inline long long F(long long x, int AA, int BB, int LL)
{
    long long ans = 1ll * x * (x + 1) / 2 * AA + 1ll * (x + 1) * (AA - 1ll * LL * AA);
    ans = (ans - 1ll * BB * solve(AA, AA - 1ll * LL * AA, BB, x));
    return ans;
}

inline void upd(int p)
{
    long long sum = 0;

    if (t[p].forkB)
    {
        sum = F(val[t[p * 2 + 1].l] - 1, t[p].forkA, t[p].forkB, t[p].forkL) - 
              F(val[t[p * 2].r], t[p].forkA, t[p].forkB, t[p].forkL);    
    }
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum + sum;
}

inline void build(int p, int l, int r)
{
    t[p] = {0, 0, 0, 0, 0, l, r, 0, 0, 0};
    if (l == r)
        return;

    int mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    upd(p);
}

inline void chg(int p)
{
    t[p].sum = F(val[t[p].r], t[p].A, t[p].B, t[p].L) - F(val[t[p].l] - 1, t[p].A, t[p].B, t[p].L);
}

inline void pushdown(int p)
{
    if (t[p].tag)
    {
        t[p * 2].A = t[p].A;
        t[p * 2 + 1].A = t[p].A;
        t[p * 2].B = t[p].B;
        t[p * 2 + 1].B = t[p].B;
        t[p * 2].L = t[p].L;
        t[p * 2 + 1].L = t[p].L;
        t[p].forkA = t[p].A;
        t[p].forkB = t[p].B;
        t[p].forkL = t[p].L;
        chg(p * 2);
        chg(p * 2 + 1);
        t[p * 2].tag = 1;
        t[p * 2 + 1].tag = 1;
        t[p].tag = 0;
    }
}

inline long long query(int p, int l, int r, int s, int e)
{
    if (l >= s && r <= e) return t[p].sum;
    pushdown(p);
    int mid = (l + r) / 2;
    if (e <= mid)
        return query(p * 2, l, mid, s, e);
    else if (s > mid)
        return query(p * 2 + 1, mid + 1, r, s, e);
    else
    {   
        long long sum = 0;

        if (t[p].forkB)
        {
            sum = F(val[t[p * 2 + 1].l] - 1, t[p].forkA, t[p].forkB, t[p].forkL) - 
                  F(val[t[p * 2].r], t[p].forkA, t[p].forkB, t[p].forkL);    
        }
        return query(p * 2 + 1, mid + 1, r, s, e) + query(p * 2, l, mid, s, e) + sum;
    }
}

inline void modify(int p, int l, int r, int s, int e, int AA, int BB, int LL)
{
    if (l >= s && r <= e)
    {
        t[p].A = AA; t[p].B = BB; t[p].L = LL;
        t[p].forkA = 0; t[p].forkB = 0; t[p].forkL = 0;
        t[p].tag = 1;
        chg(p);
        return;
    }
    pushdown(p);
    int mid = (l + r) / 2;
    if (e <= mid)
    {
        modify(p * 2, l, mid, s, e, AA, BB, LL);
        upd(p);
        return;
    }
    else if (s > mid)
    {
        modify(p * 2 + 1, mid + 1, r, s, e, AA, BB, LL);
        upd(p);
        return;
    }
    else
    {
        t[p].forkA = AA, t[p].forkB = BB, t[p].forkL = LL;
        modify(p * 2, l, mid, s, e, AA, BB, LL);
        modify(p * 2 + 1, mid + 1, r, s, e, AA, BB, LL);
        upd(p);
    }
}

int main()
{
    std::cin >> n >> q;

    for (int i = 1; i <= q; ++ i)
    {
        std::cin >> op[i] >> L[i] >> R[i];
        if (op[i] == 1)
        {
            a[++ cnt] = L[i]; a[++ cnt] = R[i];
            std::cin >> A[i] >> B[i];
        }
        if (op[i] == 2)
        {
            a[++ cnt] = L[i]; a[++ cnt] = R[i];
        }
    }

    std::sort(a + 1, a + 1 + cnt);

    newcnt = std::unique(a + 1, a + 1 + cnt) - a - 1;
    for (int i = 1; i <= newcnt; ++ i)
        val[i] = a[i];

    build(1, 1, newcnt);

    for (int i = 1; i <= q; ++ i)
    {
        if (op[i] == 1)
        {
            int Li = std::lower_bound(a + 1, a + 1 + newcnt, L[i]) - a;
            int Ri = std::lower_bound(a + 1, a + 1 + newcnt, R[i]) - a;
            modify(1, 1, newcnt, Li, Ri, A[i], B[i], L[i]);
        }
        if (op[i] == 2)
        {
            int Li = std::lower_bound(a + 1, a + 1 + newcnt, L[i]) - a;
            int Ri = std::lower_bound(a + 1, a + 1 + newcnt, R[i]) - a;
            printf("%lld\n", query(1, 1, newcnt, Li, Ri));
        }
    }

    return 0;
}
```

---

## 作者：YipChip (赞：3)

### 吐槽

一个极其恶心的类欧题，容易因为数据结构不熟练导致题目出错却找不到原因。

建立线段树变量多了还 MLE，浪费了我 2 天时间写一个题。

### 思路

首先注意到区间范围在 $10^9$ 如此庞大的数量级上，我们知道，只能通过离散化之后再建立线段树才不会超出空间。

然后我们看向式子，是一个带模数的区间赋值，由 $a \bmod b = a - b\lfloor\frac{a}{b}\rfloor$ 这个性质，我们考虑下面这个式子。

$$\sum_{i=0}^{n-1}(ai+b) \bmod c=\sum_{i=0}^{n-1}\bigg(ai+b-c\bigg\lfloor\frac{ai+b}{c}\bigg\rfloor\bigg)$$

展开可以得到：

$$\frac{an(n-1)}{2}+bn-c\sum_{i=0}^{n-1}\bigg\lfloor\frac{ai+b}{c}\bigg\rfloor$$

对于这个式子最复杂的成分 $\sum\limits_{i=0}^{n-1}\lfloor\frac{ai+b}{c}\rfloor$ 也就是一阶[**类欧**](https://www.luogu.com.cn/blog/YipChip/lei-ou-ji-li-dei-suan-fa)的求和 $f(a,\, b,\, c,\, n-1)$。

对于区间赋值 $[L, R]$，树上节点为 $[l, r]$，若满足 $L \le l \le r \le R$，则该区间赋值有：

$$\sum_{i = l}^{r}(i-L+1) \times A \bmod B$$

改一下形式也就是：

$$\sum_{i = 0}^{r - l}\bigg(Ai+(l-L+1) \times A \bigg)\bmod B$$

此式子满足上述推导过程得到的结论，令 $a = A,\, b = (l - L + 1) \times A,\, c = B,\, n = r - l + 1$，可以发现，对于一个子段的赋值也就是 $S(a,\,b,\,c,\,n-1) = \frac{an(n-1)}{2}+bn-cf(a,\,b,\,c,\,n-1)$。

接下来考虑懒标记下传，为了维护式子的统一性，我们在每个节点内存储左端点 $l$，右端点 $r$，以及 $a,\,b,\,c$ 的值，我们用大写字母来表示父亲的数据，$T$ 表示父亲，$tl,\, tr$ 分别表示左右儿子。

考虑 $S(a,\,b,\,c,\,n-1)$ 的形式，由于 $L$ 的不变性，$a,\,b,\,c$ 显然为定值，唯一改变的就是 $n - 1$ 的部分，而对于每个 $n - 1$ 唯一对应线段树上一个节点所表示的区间范围 $[l,\, r]$，因此左儿子的转移一定。

$$T(A,\,B,\,C) \to tl(a,\,b,\,c)$$

$$sum = S_{tl}(a,\,b,\,c,\, r_{tl} - l_{tl} + 1)$$

考虑右儿子同样发现只有 $l$ 发生了改变，我们直接的将求和式中的 $i$ 的下限从 $0$ 改为 $r_{tl}-l_{tl}+1$ 其实也就是 $l_{tr}-L$，简单推一下式子。

对于父亲有：

$$\sum_{i = 0}^{R - L}(Ai+B) \bmod C$$

对于右儿子有：

$$\sum_{i = l_{tr}-L}^{R - L}(ai+b) \bmod c$$

$$=\sum_{i = 0}^{R - L - l_{tr} + L}(A(i+l_{tr}-L)+B) \bmod C$$

$$=\sum_{i = 0}^{r_{tr} - l_{tr}}(Ai+(l_{tr}-L)A+B) \bmod C$$

可以发现 $a = A,\, b = (l_{tr} - L)A + B,\, c = C,\, n = r_{tr} - l_{tl} + 1$，对于常数 $b$ 我们可以直接对 $c$ 取个模防止暴毙。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e4 + 10;
int n, m, q[N][5], root, idx;
vector<int> v;
struct Node
{
	int l, r, ls, rs, a, b, c;
	ll sum;
}tr[N << 2];

ll calc(ll a, ll b, ll c, ll n)
{
	if (!a) return b / c * (n + 1);
	if (a < c && b < c)
	{
		ll m = (a * n + b) / c;
		if (!m) return 0;
		return n * m - calc(c, c - b - 1, a, m - 1);
	}
	return calc(a % c, b % c, c, n) + (n + 1) * n / 2 * (a / c) + (n + 1) * (b / c);
}

ll solve(ll a, ll b, ll c, ll n)
{
	return n * (n - 1) / 2 * a - c * calc(a, b, c, n - 1) + b * n;
}

void pushup(int p)
{
	tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;
}

void pushdown(int p)
{
	if (tr[p].c)
	{
		tr[tr[p].ls].a = tr[p].a, tr[tr[p].ls].b = tr[p].b, tr[tr[p].ls].c = tr[p].c;
		tr[tr[p].rs].a = tr[p].a, tr[tr[p].rs].b = (1ll * tr[p].a * (tr[tr[p].rs].l - tr[p].l) + tr[p].b) % tr[p].c, tr[tr[p].rs].c = tr[p].c;
		tr[tr[p].ls].sum = solve(tr[tr[p].ls].a, tr[tr[p].ls].b, tr[tr[p].ls].c, tr[tr[p].ls].r - tr[tr[p].ls].l + 1);
		tr[tr[p].rs].sum = solve(tr[tr[p].rs].a, tr[tr[p].rs].b, tr[tr[p].rs].c, tr[tr[p].rs].r - tr[tr[p].rs].l + 1);
		tr[p].c = 0;
	}
}

int build(int l, int r)
{
	int p = ++ idx;
	if (l == r)
	{
		tr[p].l = v[l];
		tr[p].r = v[l + 1] - 1;
		return p;
	}
	int mid = l + r >> 1;
	tr[p].ls = build(l, mid), tr[p].rs = build(mid + 1, r);
	tr[p].l = tr[tr[p].ls].l, tr[p].r = tr[tr[p].rs].r;
	return p;
}

void modify(int p, int l, int r, int a, int c)
{
	if (tr[p].l > r || tr[p].r < l) return;
	if (tr[p].l >= l && tr[p].r <= r)
	{
		tr[p].a = a;
		tr[p].b = (tr[p].l - l + 1ll) * a % c;
		tr[p].c = c;
		tr[p].sum = solve(tr[p].a, tr[p].b, tr[p].c, tr[p].r - tr[p].l + 1);
		return;
	}
	pushdown(p);
	modify(tr[p].ls, l, r, a, c), modify(tr[p].rs, l, r, a, c);
	pushup(p);
}

ll query(int p, int l, int r)
{
	if (tr[p].l > r || tr[p].r < l) return 0;
	if (tr[p].l >= l && tr[p].r <= r) return tr[p].sum;
	pushdown(p);
	return query(tr[p].ls, l, r) + query(tr[p].rs, l, r);
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i ++ )
	{
		int op, l, r;
		scanf("%d%d%d", &op, &l, &r);
		q[i][0] = op, q[i][1] = l, q[i][2] = r;
		v.push_back(l), v.push_back(r + 1);
		if (op == 1)
		{
			int a, b;
			scanf("%d%d", &a, &b);
			q[i][3] = a, q[i][4] = b;
		}
	}
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	root = build(0, v.size() - 2);
	for (int i = 1; i <= m; i ++ )
		if (q[i][0] == 1) modify(root, q[i][1], q[i][2], q[i][3], q[i][4]);
		else printf("%lld\n", query(root, q[i][1], q[i][2]));
	return 0;
}
```

---

## 作者：EuphoricStar (赞：3)

考虑一个前置问题：给定 $a, b, n$，求 $\sum\limits_{i = 1}^{n} (ia \bmod b)$。

根据 $x \bmod y = x - y \left\lfloor\frac{x}{y}\right\rfloor$ 可以化简式子：

$$\sum\limits_{i = 1}^{n} (ia \bmod b) = \sum\limits_{i = 1}^n ia - b \sum\limits_{i = 1}^n \left\lfloor\frac{ia}{b}\right\rfloor$$

可以类欧计算。

考虑离散化后用线段树维护区间和，每个叶子结点代表离散化端点后相邻两点形成的区间。

区间修改时，给涉及到的点打形如 $(a, b, t)$ 的标记，表示这个点的和为 $\sum\limits_{i = t}^{t + len - 1} (ia \bmod b)$。下传是容易的。

时间复杂度 $O(q \log q \log V)$。

```cpp
// Problem: P4433 [COCI2009-2010#1] ALADIN
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4433
// Memory Limit: 64 MB
// Time Limit: 8000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef __int128 lll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 100100;

ll n, m, lsh[maxn], tot;
struct wwh {
	ll op, l, r, a, b;
} qq[maxn];

struct node {
	lll cntx, cnty, sum;
	node(lll a = 0, lll b = 0, lll c = 0) : cntx(a), cnty(b), sum(c) {}
};

inline node operator + (const node &a, const node &b) {
	node res;
	res.cntx = a.cntx + b.cntx;
	res.cnty = a.cnty + b.cnty;
	res.sum = a.sum + b.sum + a.cnty * b.cntx;
	return res;
}

inline node qpow(node a, lll p) {
	node res;
	while (p) {
		if (p & 1) {
			res = res + a;
		}
		a = a + a;
		p >>= 1;
	}
	return res;
}

node solve(lll p, lll q, lll r, lll n, node a, node b) {
	if (!n) {
		return node();
	}
	if (p >= q) {
		return solve(p % q, q, r, n, a, qpow(a, p / q) + b);
	}
	lll cnt = (n * p + r) / q;
	if (!cnt) {
		return qpow(b, n);
	}
	return qpow(b, (q - r - 1) / p) + a + solve(q, p, (q - r - 1) % p, cnt - 1, b, a) + qpow(b, n - (q * cnt - r - 1) / p);
}

inline lll calc1(lll p, lll q, lll r, lll n) {
	node a(0, 1), b(1, 0);
	node ans = qpow(a, r / q) + solve(p, q, r % q, n, a, b);
	return ans.sum;
}

inline lll calc2(lll a, lll b, lll n) {
	lll s1 = n * (n + 1) / 2 * a;
	lll s2 = calc1(a, b, 0, n) * b;
	return s1 - s2;
}

inline lll calc2(lll a, lll b, lll l, lll r) {
	return calc2(a, b, r) - calc2(a, b, l - 1);
}

namespace SGT {
	struct node {
		ll a, b, t;
		node(ll x = 0, ll y = 0, ll z = 0) : a(x), b(y), t(z) {}
	} tag[maxn << 2];
	ll sum[maxn << 2];
	
	inline void pushup(int x) {
		sum[x] = sum[x << 1] + sum[x << 1 | 1];
	}
	
	inline void pushdown(int x, int l, int r) {
		if (!tag[x].b) {
			return;
		}
		int mid = (l + r) >> 1;
		sum[x << 1] = calc2(tag[x].a, tag[x].b, tag[x].t, tag[x].t + lsh[mid + 1] - lsh[l] - 1);
		sum[x << 1 | 1] = calc2(tag[x].a, tag[x].b, tag[x].t + lsh[mid + 1] - lsh[l], tag[x].t + lsh[r + 1] - lsh[l] - 1);
		tag[x << 1] = node(tag[x].a, tag[x].b, tag[x].t);
		tag[x << 1 | 1] = node(tag[x].a, tag[x].b, tag[x].t + lsh[mid + 1] - lsh[l]);
		tag[x] = node();
	}
	
	void update(int rt, int l, int r, int ql, int qr, ll a, ll b) {
		if (ql <= l && r <= qr) {
			tag[rt] = node(a, b, lsh[l] - lsh[ql] + 1);
			sum[rt] = calc2(a, b, lsh[l] - lsh[ql] + 1, lsh[r + 1] - lsh[ql]);
			return;
		}
		pushdown(rt, l, r);
		int mid = (l + r) >> 1;
		if (ql <= mid) {
			update(rt << 1, l, mid, ql, qr, a, b);
		}
		if (qr > mid) {
			update(rt << 1 | 1, mid + 1, r, ql, qr, a, b);
		}
		pushup(rt);
	}
	
	ll query(int rt, int l, int r, int ql, int qr) {
		if (ql <= l && r <= qr) {
			return sum[rt];
		}
		pushdown(rt, l, r);
		int mid = (l + r) >> 1;
		ll res = 0;
		if (ql <= mid) {
			res += query(rt << 1, l, mid, ql, qr);
		}
		if (qr > mid) {
			res += query(rt << 1 | 1, mid + 1, r, ql, qr);
		}
		return res;
	}
}

void solve() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= m; ++i) {
		scanf("%lld%lld%lld", &qq[i].op, &qq[i].l, &qq[i].r);
		if (qq[i].op == 1) {
			scanf("%lld%lld", &qq[i].a, &qq[i].b);
		}
		lsh[++tot] = qq[i].l;
		lsh[++tot] = (++qq[i].r);
	}
	sort(lsh + 1, lsh + tot + 1);
	tot = unique(lsh + 1, lsh + tot + 1) - lsh - 1;
	for (int i = 1; i <= m; ++i) {
		qq[i].l = lower_bound(lsh + 1, lsh + tot + 1, qq[i].l) - lsh;
		qq[i].r = lower_bound(lsh + 1, lsh + tot + 1, qq[i].r) - lsh;
	}
	for (int i = 1; i <= m; ++i) {
		ll op = qq[i].op, l = qq[i].l, r = qq[i].r, a = qq[i].a, b = qq[i].b;
		if (op == 1) {
			SGT::update(1, 1, tot - 1, l, r - 1, a, b);
		} else {
			printf("%lld\n", SGT::query(1, 1, tot - 1, l, r - 1));
		}
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```


---

## 作者：JiaY19 (赞：3)

我的评价是：什么神必题。

### 思路

考虑询问只有 $50000$。

需要对区间进行离散化，然后使用线段树进行维护。

考虑处理相同 $L,A,B$ 的区间 $[l,r]$。

贡献为：

$$\sum_{i=l}^r(i-L+1)\times A \bmod B$$

计前缀和：

$$sum(n)=\sum_{i=1}^n(i-L+1)\times A \bmod B$$

则：

$$\sum_{i=l}^r(i-L+1)\times A \bmod B=sum(r)-sum(l-1)$$

考虑求：

$$sum(n)=\sum_{i=1}^n(i-L+1)\times A-\lfloor\frac{(i-L+1)\times A}{B}\rfloor B$$

可以发现，前面一段直接计算，后面一段同样万能欧几里得算法即可。

可以吗？

发现这道题十分没有素质的把我的万能欧几里得算法卡炸了。

也有可能是我的板子比较废物。

但确实对于精度的要求比较高。

使用类欧几里得算法即可。

[code](https://www.luogu.com.cn/record/105646523)

---

## 作者：DaiRuiChen007 (赞：2)

# P4433 题解

[Problem Link](https://www.luogu.com.cn/problem/P4433)

**题目大意**

> 维护一个长度为 $n$ 的数组 $a_1\sim a_n$，支持如下两种操作共 $q$ 次：
>
> - 对于 $i\in [l,r]$，令 $a_i\gets (A\times (i-l+1))\bmod B$。
> - 求 $a_l\sim a_r$ 的和。
>
> 数据范围：$n,q\le 10^9,A,B\le 10^6,q\le 5\times 10^4$。

**思路分析**

一眼线段树，比较复杂的是如何打标记，即求 $\sum _{i=0}^n (Ai)\bmod B$ 的值，显然转为整除得到：
$$
\sum _{i=0}^n (Ai)\bmod B=A\times \dfrac{n(n+1)}2-B\sum_{i=0}^n\left\lfloor\dfrac{iA}{B}\right\rfloor
$$
后面那个式子显然是类欧板子，记 $f(n,a,b,c)=\sum _{i=0}^n\left\lfloor\dfrac{ai+b}c\right\rfloor$，推式子得到：

显然可以处理 $a\ge c$ 或 $b\ge c$ 的情况，直接取模即可，即：
$$
f(n,a,b,c)=f(n,a\bmod c,b\bmod c,c)+\lfloor b/c\rfloor\times (n+1)+\lfloor a/c\rfloor\times \dfrac{n\times(n+1)}2
$$
然后考虑 $a<c,b<c$ 的情况，容易发现 $i=0$ 没有贡献，因此得到：
$$
\begin{aligned}
f(n,a,b,c)
&=\sum_{i=1}^n\left\lfloor\dfrac{ai+b}c\right\rfloor\\
&=\sum_{i=1}^n\sum_{j=0}^{\lfloor(an+b)/c\rfloor-1}\left[j+1\le \left\lfloor\dfrac{ai+b}c\right\rfloor\right]\\
&=\sum_{j=0}^{\lfloor(an+b)/c\rfloor-1}\sum_{i=1}^n\left[i\ge \left\lceil\dfrac{jc+c-b}{a}\right\rceil\right]\\
&=\sum_{j=0}^{\lfloor(an+b)/c\rfloor-1} n-\left\lfloor\dfrac{jc-b+a-1}{a}\right\rfloor+1\\
&=(n+1)\times \lfloor(an+b)/c\rfloor-f(\lfloor(an+b)/c\rfloor-1,c,c+a-b-1,a)
\end{aligned}
$$
递归即可计算，注意到两种递归式中 $(a,c)$ 的递归形如欧几里得算法，因此复杂度为 $\mathcal O(\log c)$。

考虑原式，得到 $\sum _{i=0}^n (Ai)\bmod B=A\times \dfrac{n(n+1)}2-Bf(n,A,0,B)$，然后用线段树维护即可，由于本题卡空间，因此把每个区间离散化，线段树上每个叶子维护一个最小子区间。

时间复杂度 $\mathcal O(q\log q\log B)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll __int128
using namespace std;
const int MAXN=1e5+5;
int n,q;
inline int f(ll a,ll b,ll c,ll n) {
	if(!a) return (b/c)*(n+1);
	if(a>=c||b>=c) return f(a%c,b%c,c,n)+(a/c)*(n+1)*n/2+(b/c)*(n+1);
	return (a*n+b)/c*(n+1)-f(c,c-b+a-1,a,(a*n+b)/c-1);
}
inline int Calc(ll l,ll r,ll a,ll b) {
	auto pres=[&](int n) -> ll {
		return a*n*(n+1)/2-b*f(a,0,b,n);
	};
	return pres(r)-pres(l-1);
}
struct Info { int st,a,b; };
int m,pos[MAXN];
class SegmentTree {
	private:
		struct Node {
			int L,R,sum;
			Info I; 
			bool c;
		}   tr[MAXN<<2];
		inline int L(int p) { return p<<1; }
		inline int R(int p) { return p<<1|1; }
		inline void pushup(int p) { tr[p].sum=tr[L(p)].sum+tr[R(p)].sum; }
		inline void addtag(int p,Info I) {
			tr[p].c=true,tr[p].I=I;
			tr[p].sum=Calc(tr[p].L-I.st+1,tr[p].R-I.st+1,I.a,I.b);
		}
		inline void pushdown(int p) {
			if(tr[p].c) addtag(L(p),tr[p].I),addtag(R(p),tr[p].I),tr[p].c=false;
		}
	public:
		inline void Build(int l=1,int r=m,int p=1) {
			tr[p].L=pos[l],tr[p].R=pos[r+1]-1;
			if(l==r) return void();
			int mid=(l+r)>>1;
			Build(l,mid,L(p)),Build(mid+1,r,R(p));
		}
		inline void Modify(int ul,int ur,Info I,int l=1,int r=m,int p=1) {
			if(ul<=l&&r<=ur) return addtag(p,I);
			int mid=(l+r)>>1;
			pushdown(p);
			if(ul<=mid) Modify(ul,ur,I,l,mid,L(p));
			if(mid<ur) Modify(ul,ur,I,mid+1,r,R(p));
			pushup(p);
		}
		inline int Query(int ul,int ur,int l=1,int r=m,int p=1) {
			if(!p||(ul<=l&&r<=ur)) return tr[p].sum;
			int mid=(l+r)>>1,res=0;
			pushdown(p);
			if(ul<=mid) res+=Query(ul,ur,l,mid,L(p));
			if(mid<ur) res+=Query(ul,ur,mid+1,r,R(p));
			return res;
		}
}   TR;
struct Oper { int opt,l,r,a,b; };
vector <Oper> Q;
signed main() {
//  freopen("c.in","r",stdin);
//  freopen("c.out","w",stdout);
	scanf("%lld%lld",&n,&q);
	pos[++m]=1,pos[++m]=n+1;
	for(int opt,l,r,a,b;q--;) {
		scanf("%lld%lld%lld",&opt,&l,&r),++r;
		if(opt==1) scanf("%lld%lld",&a,&b);
		else a=b=0;
		Q.push_back({opt,l,r,a,b});
		pos[++m]=l,pos[++m]=r;
	}
	sort(pos+1,pos+m+1),m=unique(pos+1,pos+m+1)-pos-2;
	TR.Build();
	for(auto q:Q) {
		int s=q.l;
		q.l=lower_bound(pos+1,pos+m+2,q.l)-pos;
		q.r=lower_bound(pos+1,pos+m+2,q.r)-pos-1;
		if(q.opt==1) TR.Modify(q.l,q.r,{s,q.a,q.b});
		else printf("%lld\n",TR.Query(q.l,q.r));
	}
	return 0;
}
```

---

## 作者：cforrest (赞：0)

这题用平衡树会更方便一些，不用离散化。直接写个 WBLT，然后写个结点回收，就也用不了多少空间，还跑得飞快。

具体讲一下思路，就是每个结点处存当前线段参数 $(a,b,c,n)$ 和所求的和式 $su$。显然，对于线段

$$
y=(ax+b)/c,~1\le x\le n
$$

来说，所求和式等于

$$
\begin{aligned}
\sum_{i=1}^n(ai+b)\bmod c &= \sum_{i=1}^n\left((ai+b)-c\left\lfloor\dfrac{ai+b}{c}\right\rfloor\right) \\
&= \dfrac{a}{2}n(n+1)+bn-c\sum_{i=1}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor.
\end{aligned}
$$

最后一项可以通过类欧几里得算法实现。

WBLT 中，除了叶子结点外，不需要存储多余的信息，把所求和式穿上去就行。

每次覆盖一条新的线段的时候，直接分裂出相应的子树，然后替换成新的线段的参数，再合并，就完成了一次更新。

分裂的时候需要算一下两边的线段参数，其中，$a$ 和 $c$ 是不变的，只要把右边线段的截距 $b$ 算出来就可以了。然后重新更新一下两侧的和 $su$。

```cpp
#include <iostream>
#include <vector>
#define fast_io std::ios::sync_with_stdio(false), std::cin.tie(nullptr)

long long sum_floor(long long a, long long b, long long c, long long n) {
    long long n2 = n * (n + 1) / 2;
    if (a >= c || b >= c) {
        long long aa = a / c, bb = b / c;
        return sum_floor(a % c, b % c, c, n) + aa * n2 + bb * (n + 1);
    } else if (a) {
        long long m = (a * n + b) / c;
        return m * n - sum_floor(c, c - b - 1, a, m - 1);
    } else {
        return 0;
    }
}

class WBLT {
    struct Node {
        int ch[2], sz, a, b, c, n;
        long long su;
        Node() : ch{}, sz{}, a{}, b{}, c{}, n{}, su{} {}

        void update() {
            su = (long long)n * b + (long long)(n + 1) * n / 2 * a
                - (long long)c * (sum_floor(a, b, c, n) - (b / c));
        }
    };

    int id, rt, top;
    std::vector<int> pool;
    std::vector<Node> node;
    
#define getter(var) \
    auto var(int x) const { return node[x].var; } \
    auto& var(int x) { return node[x].var; }

    getter(sz)
    getter(a)
    getter(b)
    getter(c)
    getter(n)
    getter(su)

#undef getter

    auto& ch(int x, int i) { return node[x].ch[i]; }
    auto ch(int x, int i) const { return node[x].ch[i]; }

    void push_up(int x) {
        sz(x) = sz(ch(x, 0)) + sz(ch(x, 1));
        su(x) = su(ch(x, 0)) + su(ch(x, 1));
        n(x) = n(ch(x, 0)) + n(ch(x, 1));
    }

    void push_down(int x) {}

    int new_node() {
        int x = top ? pool[--top] : ++id;
        node[x] = Node();
        return x;
    }

    void del_node(int& x) {
        pool[top++] = x;
        x = 0;
    }

    int new_leaf(int _a, int _b, int _c, int _n) {
        int x = new_node();
        sz(x) = 1;
        a(x) = _a;
        b(x) = _b;
        c(x) = _c;
        n(x) = _n;
        node[x].update();
        return x;
    }

    int join(int x, int y) {
        int z = new_node();
        ch(z, 0) = x;
        ch(z, 1) = y;
        push_up(z);
        return z;
    }

    auto cut(int& x) {
        push_down(x);
        int y = ch(x, 0);
        int z = ch(x, 1);
        del_node(x);
        return std::pair(y, z);
    }

    bool too_heavy(int sx, int sy) {
        return sx * 2 > sy * 5;
    }
    
    int merge(int x, int y) {
        if (!x || !y) return x | y;
        if (too_heavy(sz(x), sz(y))) {
            auto [a, b] = cut(x);
            if (too_heavy(sz(b) + sz(y), sz(a))) {
                auto [c, d] = cut(b);
                return merge(merge(a, c), merge(d, y));
            } else {
                return merge(a, merge(b, y));
            }
        } else if (too_heavy(sz(y), sz(x))) {
            auto [a, b] = cut(y);
            if (too_heavy(sz(a) + sz(x), sz(b))) {
                auto [c, d] = cut(a);
                return merge(merge(x, c), merge(d, b));
            } else {
                return merge(merge(x, a), b);
            }
        } else {
            return join(x, y);
        }
    }

    std::pair<int, int> split(int x, int k) {
        if (!x) return { 0, 0 };
        if (!k) return { 0, x };
        if (k == n(x)) return { x, 0 };
        if (sz(x) == 1) {
            auto y = new_leaf(a(x), (b(x) + (long long)a(x) * k) % c(x), c(x), n(x) - k);
            n(x) = k;
            su(x) -= su(y);
            return { x, y };
        }
        auto [a, b] = cut(x);
        if (k <= n(a)) {
            auto [ll, rr] = split(a, k);
            return { ll, merge(rr, b) };
        } else {
            auto [ll, rr] = split(b, k - n(a));
            return { merge(a, ll), rr };
        }
    }

    void del_tree(int& x) {
        if (!x) return;
        del_tree(ch(x, 0));
        del_tree(ch(x, 1));
        del_node(x);
    }

public:
    WBLT(int n, int N) : id(0), rt(0), top(0), pool(n << 1), node(n << 1) {
        rt = new_leaf(0, 0, 1, N);
    }

    void modify(int l, int r, int a, int b) {
        int ll, rr;
        std::tie(rt, rr) = split(rt, r);
        std::tie(ll, rt) = split(rt, l - 1);
        del_tree(rt);
        rt = new_leaf(a, 0, b, r - l + 1);
        rt = merge(merge(ll, rt), rr);
    }

    long long find_sum(int l, int r) {
        int ll, rr;
        std::tie(rt, rr) = split(rt, r);
        std::tie(ll, rt) = split(rt, l - 1);
        auto res = su(rt);
        rt = merge(merge(ll, rt), rr);
        return res;
    }
};

int main() {
    fast_io;
    int n, q;
    std::cin >> n >> q;
    WBLT st(q << 1, n);
    for (; q; --q) {
        int op;
        std::cin >> op;
        if (op == 1) {
            int l, r, a, b;
            std::cin >> l >> r >> a >> b;
            st.modify(l, r, a, b);
        } else if (op == 2) {
            int l, r;
            std::cin >> l >> r;
            std::cout << st.find_sum(l, r) << '\n';
        }
    }
    return 0;
}
```

---

## 作者：ll_dio (赞：0)

## 前言
本来黑题首 A 是猪国杀，结果降紫了（悲）。今天补上新的首 A。
## 题目大意
给定一个长度为 $n$ 的序列 $a$，初始为空。现给定 $q$ 个操作，将一个区间在模 $B$ 意义下修改为首项为 $A$，公差为 $A$ 的等差数列或求区间和。

数据范围：$1\leq n\leq10^{9},1\leq q\leq5\times10^{4},1\leq A,B\leq10^{6}$

（注意到题目翻译有误，漏了 $A,B$ 的数据范围，目前已 @ 管理员，望修改）

## 题目分析
容易注意到这是一道数据结构题，虽然空间卡的很紧，但这题的正解依旧是线段树。空间问题可以动态开点然后多写一点 int 解决，那么关键问题就是如何解决区间修改。

我们考虑如何解决在模 $B$ 意义下，将区间 $[l,r]$ 修改为一个从 $L$ 开始的，首项与公差均为 $A$ 的等差数列中的 $[l,r]$ 一段并维护其区间和。

不难发现，问题即为求下面的式子：
$$\begin{aligned} \sum_{i=l}^{r}\{[(i-L+1)\times A]\bmod B\}&=A\times\sum_{i=l}^{r}(i-L+1)-\sum_{i=l}^{r} \left(\left\lfloor \dfrac{(i-L+1)\times A}{B} \right\rfloor \times B \right)\\&=\dfrac{(l+r-2\times L+2)\times(r-l+1)}{2}\times A - B\times\sum_{i=l}^{r}\left\lfloor \dfrac{(i-L+1)\times A}{B}\right\rfloor\\&=\dfrac{(l+r-2\times L+2)\times(r-l+1)}{2}\times A - B\times\sum_{i=0}^{r-l}\left\lfloor \dfrac{A\times i+(l-L+1)\times A}{B}\right\rfloor\end{aligned}$$

不难看出，推导后的式子，左半部分可以直接求，而右半部分是一个标准的类欧，相当于 $B\times\operatorname{f}(A,(l-L+1)\times A,B,r-l)$，直接类欧即可。

不会类欧的见[这道](https://www.luogu.com.cn/problem/P5170)。

## 注意事项
对于刚学线段树不久或线段树掌握的不熟练的 OIER 来说，这题有个小细节需要注意。

本题中 $n\leq 10^{9}$，所以需要离散化，但由于这题的更新跟当前端点的区间左右端点有关，因此按下段代码离散化的话只能拿到区区 $10$ 分。

```cpp

for(int i=1;i<=nQ;i++){
    scanf("%d %d %d",&q[i].op,&q[i].l,&q[i].r);
    if(q[i].op==1) scanf("%d %d",&q[i].a,&q[i].b);
    x[2*i-1]=usf[2*i-1]=q[i].l;
    x[2*i]=usf[2*i]=q[i].r;
}
sort(x+1,x+2*nQ+1);
nUnq=unique(x+1,x+2*nQ+1)-x-1;
for(int i=1;i<=2*nQ;i++) 
    id[i]=lower_bound(x+1,x+nUnq+1,usf[i])-x;
```
这里我们需要明确线段树各节点的范围，假设离散化后原来的 $x_{i}$ 号节点离散化后变为 $i$ 号节点，则线段树上代表离散化后区间 $[l,r]$ 的端点对应的原区间为 $[x_{l-1}+1,x_{r}]$。

如果按照上段代码离散化的话，那么在进行增加操作时，期望覆盖区间 $[x_{l},x_{r}]$ 的线段树上点集实际会覆盖到 $[x_{l-1}+1,x_{r}]$。

修改方法很简单，在离散化时额外加入编号为 $l-1$ 的节点即可，具体实现见下。

## 主要代码

```cpp
int n,nQ,usf[3*N],x[3*N],id[3*N],nUnq,rt,nV;//能用int就用int 
struct Segment{
	int tagA,tagB,tagL,ls,rs;//动态开点省空间 
	ll sum;//区间和用ll 
} tr[6*N];
struct Query{
	int op,l,r,a,b;
} q[N];//因为要离散化所以离线问询 
ll f(ll a,ll b,ll c,ll d){
	if(d==0) return b/c;
	if(a==0) return (b/c)*(d+1);
	if(a>=c||b>=c) return d*(d+1)/2*(a/c)+(d+1)*(b/c)+f(a%c,b%c,c,d);
	ll m=(a*d+b)/c;
	return d*m-f(c,c-b-1,a,m-1);
}//类欧 
void tag(int u,int vL,int vA,int vB,int lt,int rt){
	ll L=x[vL],A=vA,B=vB,l=x[lt-1]+1,r=x[rt];
	tr[u].sum=(l+r-2*L+2)*(r-l+1)/2*A;
	tr[u].sum-=B*f(A,(l-L+1)*A,B,r-l);
	tr[u].tagL=vL; tr[u].tagA=vA; tr[u].tagB=vB;
}
void pushdown(int u,int lt,int rt){
	if(!tr[u].tagL) return;
	int vA=tr[u].tagA,vB=tr[u].tagB,vL=tr[u].tagL;
	int mid=(lt+rt)/2;
	if(tr[u].ls) tag(tr[u].ls,vL,vA,vB,lt,mid);
	if(tr[u].rs) tag(tr[u].rs,vL,vA,vB,mid+1,rt);
	tr[u].tagA=tr[u].tagB=tr[u].tagL=0;
}
void brush(int u){
	if((!tr[u].ls)&&(!tr[u].rs)) return;
	tr[u].sum=tr[tr[u].ls].sum+tr[tr[u].rs].sum;
}
int build(int l,int r){
	nV++; int now=nV;
	if(l==r) return now;
	int mid=(l+r)/2;
	tr[now].ls=build(l,mid);
	tr[now].rs=build(mid+1,r);
	return now;
}
void upd(int u,int lt,int rt,int l,int r,int vA,int vB){
	if(lt>r||rt<l) return;
	if(l<=lt&&rt<=r){
		tag(u,l,vA,vB,lt,rt);
		return;
	}
	pushdown(u,lt,rt);
	int mid=(lt+rt)/2;
	upd(tr[u].ls,lt,mid,l,r,vA,vB);
	upd(tr[u].rs,mid+1,rt,l,r,vA,vB);
	brush(u);
}
ll query(int u,int lt,int rt,int l,int r){
	if(lt>r||rt<l) return 0;
	if(l<=lt&&rt<=r) return tr[u].sum;
	pushdown(u,lt,rt);
	int mid=(lt+rt)/2;
	return query(tr[u].ls,lt,mid,l,r)+query(tr[u].rs,mid+1,rt,l,r);
}//以上皆为动态开点线段树 
void input(){
	scanf("%d %d",&n,&nQ);
	for(int i=1;i<=nQ;i++){
		scanf("%d %d %d",&q[i].op,&q[i].l,&q[i].r);
		if(q[i].op==1) scanf("%d %d",&q[i].a,&q[i].b);
		x[3*i-2]=usf[3*i-2]=q[i].l;
		x[3*i-1]=usf[3*i-1]=q[i].r;
		x[3*i]=usf[3*i]=q[i].l-1;
		//输入+离散化预备 
	}
}
void solve(){
	sort(x+1,x+3*nQ+1);
	nUnq=unique(x+1,x+3*nQ+1)-x-1;
	for(int i=1;i<=3*nQ;i++) id[i]=lower_bound(x+1,x+nUnq+1,usf[i])-x;
	//离散化 
	rt=build(1,nUnq);
	for(int i=1;i<=nQ;i++){
		if(q[i].op==1) upd(1,1,nUnq,id[3*i-2],id[3*i-1],q[i].a,q[i].b);
		else printf("%lld\n",query(1,1,nUnq,id[3*i-2],id[3*i-1]));
	}//处理问询与修改 
}
```

---

## 作者：yqr123YQR (赞：0)

### 分析
不是特别难的样子。

由于题中是取模后再加，直接线段树是不可行的。考虑以 $x-p\lfloor\frac xp\rfloor$ 的形式表示 $a\bmod p$。同时我们记 $f(a,b,c,n)=\sum\limits_{i=0}^n\lfloor\frac{ai+b}c\rfloor$。

这时，在线段树上对区间 $[l,r]$ 执行操作 $(A,B,L)$，就可以将这段区间的和表示为：
$$
\begin{align*}
\sum_{i=l}^r((Ai-AL)\bmod B)&=\sum_{i=0}^r((Ai-AL)\bmod B)-\sum_{i=0}^{l-1}((Ai-AL)\bmod B)\\
&=\left(\sum_{i=l}^rAi-AL\right)-B\left(\sum_{i=0}^r\lfloor\frac{Ai-AL}B\rfloor-\sum_{i=0}^{l-1}\lfloor\frac{Ai-AL}B\rfloor\right)\\
&=A\left(\frac{(l+r)(r-l+1)}2-L(r-l+1)\right)-B(f(A,-AL,B,r)-f(A,-AL,B,l-1))
\end{align*}
$$

现在只需考虑快速求出 $f(a,b,c,n)$。出于统一形式，令 $a=a'+c\lfloor\frac ac\rfloor,b=b'+c\lfloor\frac bc\rfloor$，当 $a\geqslant c\vee b\geqslant c$ 时：
$$
\begin{align*}
f(a,b,c,n)&=\sum_{i=0}^n\lfloor\frac{ai+b}c\rfloor\\
&=\sum_{i=0}^n\left\lfloor\frac{ia'+ic\lfloor\frac ac\rfloor+b'+c\lfloor\frac bc\rfloor}c\right\rfloor\\
&=\frac{n(n+1)}2\lfloor\frac ac\rfloor+n\lfloor\frac bc\rfloor+\sum_{i=0}^n\lfloor\frac{a'i+b'}c\rfloor\\
&=\frac{n(n+1)}2\lfloor\frac ac\rfloor+n\lfloor\frac bc\rfloor+f(a',b',c,n)
\end{align*}
$$
令 $m=\lfloor\frac{an+b}c\rfloor$，稍加变形：
$$
\begin{align}
f(a,b,c,n)&=\sum_{i=0}^n\lfloor\frac{ai+b}c\rfloor\notag\\
&=\sum_{v=0}^{m-1}\sum_{i=0}^n\left[\lfloor\frac{ai+b}c\rfloor>v\right]\\
&=\sum_{v=0}^{m-1}\left(n-\lfloor\frac{vc+c-b-1}a\rfloor\right)\notag\\
&=nm-f(c,c-b-1,a,m-1)\notag
\end{align}
$$
> 标号行：由于前一行的式子对于每个 $i$ 的取值，在平面上呈多个矩形，故枚举的 $v$ 可以视作一条扫描线。

关于时间复杂度，考虑在 $a,c$ 互换位置时，总会互相取一遍模，所以其时间复杂度应与欧几里得法求 $\gcd$ 相同：$\log(\max(a,c))$。这就是类欧几里得算法。

有了类欧，剩下的就是线段树基本操作。

由于 $n$ 很大，离散化一遍每个修改 / 询问的 $l-1$ 和 $r$ 即可，此时线段树上区间 $[l,r]$ 实际指 $(val_{l-1},val_r]$。
### 代码
```cpp
#include<stdio.h>
#include<ctype.h>
#include<algorithm>
namespace IO {
	constexpr int bufsize = 230005;
	char buf[bufsize], *f1, *f2;
	#define gtchar() (f1 == f2 && (f2 = buf + fread(f1 = buf, 1, bufsize, stdin)) == buf? EOF: *f1++)
	template<typename T> void read(T &ret)
	{
		int f = ret = 0;
		char ch = gtchar();
		while(!isdigit(ch)) f = ch == '-', ch = gtchar();
		while(isdigit(ch)) ret = (ret << 3) + (ret << 1) + (ch ^ 48), ch = gtchar();
		if(f) ret = -ret;
	}
	#undef gtchar
	template<typename t, typename ...T> void read(t &a, T &...b) {read(a), read(b...);}
}using IO::read;
constexpr int maxn = 50005;
typedef long long ll;
struct que {
	int opt, l, r, a, b;
}qs[maxn];
int n, q, idx, val[maxn << 1];
ll f(ll a, ll b, ll c, ll n)
{
	ll ac = a < 0? -((-a - 1) / c) - 1: a / c, bc = b < 0? -((-b - 1) / c) - 1: b / c;
	ll ret = n * (n + 1) / 2 * ac + n * bc;
	a -= c * ac, b -= c * bc;
	if(!a) return ret;
	ll m = (a * n + b) / c;
	return n * m - f(c, c - b - 1, a, m - 1) + ret;
}
struct segment_tree {
	struct node {
		int A, B, L;
		ll sum;
	}s[maxn << 3];
	void pushup(int k) {s[k].sum = s[k << 1].sum + s[k << 1 | 1].sum;}
	void cover(int k, int sl, int sr, int A, int B, ll L)
	{
		s[k].A = A, s[k].B = B, s[k].L = L;
		s[k].sum = ((ll) (val[sr] + val[sl - 1] + 1) * (val[sr] - val[sl - 1]) / 2 - L * (val[sr] - val[sl - 1])) * A - B * (f(A, -A * L, B, val[sr]) - f(A, -A * L, B, val[sl - 1]));
	}
	void pushdown(int k, int sl, int sr)
	{
		int mid = sl + sr >> 1;
		if(s[k].A) cover(k << 1, sl, mid, s[k].A, s[k].B, s[k].L), cover(k << 1 | 1, mid + 1, sr, s[k].A, s[k].B, s[k].L), s[k].A = 0;
	}
	void modify(int k, int sl, int sr, int ql, int qr, int a, int b)
	{
		if(ql <= sl && sr <= qr) return cover(k, sl, sr, a, b, val[ql - 1]);
		int mid = sl + sr >> 1;
		pushdown(k, sl, sr);
		if(ql <= mid) modify(k << 1, sl, mid, ql, qr, a, b);
		if(qr > mid) modify(k << 1 | 1, mid + 1, sr, ql, qr, a, b);
		pushup(k);
	}
	ll query(int k, int sl, int sr, int ql, int qr)
	{
		if(ql <= sl && sr <= qr) return s[k].sum;
		ll ret = 0;
		int mid = sl + sr >> 1;
		pushdown(k, sl, sr);
		if(ql <= mid) ret = query(k << 1, sl, mid, ql, qr);
		if(qr > mid) ret += query(k << 1 | 1, mid + 1, sr, ql, qr);
		return ret;
	}
}tree;
int main()
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	read(n, q);
	for(int i = 1; i <= q; i++)
	{
		read(qs[i].opt, qs[i].l, qs[i].r), val[++idx] = qs[i].r;
		if(qs[i].l > 1) val[++idx] = qs[i].l - 1;
		if(qs[i].opt == 1) read(qs[i].a, qs[i].b);
	}
	std::sort(val + 1, val + 1 + idx), idx = std::unique(val + 1, val + 1 + idx) - val - 1;
	for(int i = 1; i <= q; i++)
	{
		qs[i].l = std::lower_bound(val + 1, val + 1 + idx, qs[i].l) - val;
		qs[i].r = std::lower_bound(val + 1, val + 1 + idx, qs[i].r) - val;
		if(qs[i].opt == 1) tree.modify(1, 1, idx, qs[i].l, qs[i].r, qs[i].a, qs[i].b);
		else printf("%lld\n", tree.query(1, 1, idx, qs[i].l, qs[i].r));
	}
	return 0;
}
```

---


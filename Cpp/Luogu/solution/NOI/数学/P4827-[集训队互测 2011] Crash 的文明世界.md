# [集训队互测 2011] Crash 的文明世界

## 题目描述

Crash 小朋友最近迷上了一款游戏——文明5 (Civilization V)。在这个游戏中，玩家可以建立和发展自己的国家，通过外交和别的国家交流，或是通过战争征服别的国家。

现在 Crash 已经拥有了一个 $n$ 个城市的国家，这些城市之间通过道路相连。由于建设道路是有花费的，因此 Crash 只修建了 $n-1$ 条道路连接这些城市，不过可以保证任意两个城市都有路径相通。

在游戏中，Crash 需要选择一个城市作为他的国家的首都，选择首都需要考虑很多指标，有一个指标是这样的：

$$S(i) = \sum_{j = 1}^{n}{\rm dist}(i, j) ^ k$$

其中 $S(i)$ 表示第 $i$ 个城市的指标值，${\rm dist}(i, j)$ 表示第 $i$ 个城市到第 $j$ 个城市需要经过的道路条数的最小值，$k$ 为一个常数且为正整数。

因此 Crash 交给你一个简单的任务：给出城市之间的道路，对于每个城市，输出这个城市的指标值，由于指标值可能会很大，所以你只需要输出这个数 $\bmod\ 10007$ 的值。

## 说明/提示

对于 $20 \%$ 的数据，$n\le 5000$，$k\le 30$。

对于 $50 \%$ 的数据，$n\le 5\times 10^4$，$k\le 30$。

对于 $100 \%$ 的数据，$1\le n\le 5\times 10^4$，$1\le k\le 150$。

## 样例 #1

### 输入

```
5 2
1 2
1 3
2 4
2 5
```

### 输出

```
10
7
23
18
18
```

# 题解

## 作者：y2823774827y (赞：43)

## 题目
[[国家集训队] Crash 的文明世界](https://www.luogu.org/problemnew/show/P4827)
## 前置
斯特林数$\Longrightarrow$[斯特林数及反演总结](https://www.cnblogs.com/y2823774827y/p/10700231.html)
## 做法
$ans_x=\sum\limits_{i=1}^ndis(i,x)^k$

$~~~~~~~~=\sum\limits_{i=1}^n\sum\limits_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}C_{dis(i,x)}^jj!$

$~~~~~~~~=\sum\limits_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum\limits_{i=1}^nC_{dis(i,x)}^j$

$~~~~~~~~=\sum\limits_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum\limits_{i=1}^n(C_{dis(i,x)-1}^j+C_{dis(i,x)-1}^{j-1})$

$f[x][j]$表示$x$子树内，关于$x$：$C_{dis(i,x)}^j$的答案

显然有$f[x][j]=\sum\limits_{son}f[son][j]+f[son][j-1]$

当这仅仅对于根有效，所以再做一遍换根$dp$
## Code
```cpp
#include<bits/stdc++.h>
typedef int LL;
const LL maxn=5e4+9,mod=10007,maxm=209;
inline LL Read(){
    LL x(0),f(1); char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-') f=-1; c=getchar();
    }
    while(c>='0' && c<='9'){
        x=(x<<3)+(x<<1)+c-'0'; c=getchar();
    }
    return x*f;
}
struct node{
	LL to,nxt;
}dis[maxn<<1];
LL n,num,K;
LL head[maxn],dp1[maxn][maxm],dp2[maxn][maxm],strl[maxm][maxm],tmp[maxm],fac[maxm];
inline void Add(LL u,LL v){
	dis[++num]=(node){v,head[u]}; head[u]=num;
}
void Dfs1(LL u,LL f){
	dp1[u][0]=1;
	for(LL i=head[u];i;i=dis[i].nxt){
		LL v(dis[i].to);
		if(v==f) continue;
		Dfs1(v,u);
		for(LL j=1;j<=K;++j) dp1[u][j]=(dp1[u][j]+dp1[v][j]+dp1[v][j-1])%mod;
		dp1[u][0]=(dp1[u][0]+dp1[v][0])%mod;
	}
}
void Dfs2(LL u,LL f){
	for(LL i=0;i<=K;++i) dp2[u][i]=dp1[u][i];
	if(f){
		for(LL i=1;i<=K;++i) tmp[i]=(dp2[f][i]-dp1[u][i]+mod-dp1[u][i-1]+mod)%mod;
		tmp[0]=(dp2[f][0]-dp1[u][0]+mod)%mod;
		for(LL i=1;i<=K;++i) dp2[u][i]=(dp2[u][i]+tmp[i]+tmp[i-1])%mod;
		dp2[u][0]=(dp2[u][0]+tmp[0])%mod;
	}
	for(LL i=head[u];i;i=dis[i].nxt){
		LL v(dis[i].to);
		if(v==f) continue;
		Dfs2(v,u);
	}
}
int main(){
	n=Read(); K=Read();
	strl[0][0]=strl[1][1]=1;
	for(LL i=2;i<=K;++i)
	    for(LL j=1;j<=i;++j)
	        strl[i][j]=(strl[i-1][j-1]+j*strl[i-1][j])%mod;
	fac[0]=fac[1]=1;
	for(LL i=2;i<=K;++i) fac[i]=fac[i-1]*i%mod;
	for(LL i=1;i<n;++i){
		LL u(Read()),v(Read());
		Add(u,v); Add(v,u);
	}
	Dfs1(1,0); Dfs2(1,0);
	for(LL i=1;i<=n;++i){
		LL ret(0);
		for(LL j=0;j<=K;++j) ret=(ret+1ll*strl[K][j]*fac[j]*dp2[i][j])%mod;
		printf("%d\n",ret);
	}
	return 0;
}
```

---

## 作者：asuldb (赞：20)

先写一个五十分的思路吧

首先这道题有一个弱化版

[[POI2008]STA-Station](https://www.luogu.org/problemnew/show/P3478)

相当于$k=1$，于是就是一个非常简单的树形$dp$的$up\ \ and\ \ down$思想

但是我们现在要求的是这个柿子了

$$\sum_{j=1}^ndis(i,j)^k$$

感觉这个东西很组合数学啊，感觉这个柿子像是天生为二项式定理准备的

我们还是考虑树形$dp$

在第一遍$up$的时候，我们设$dp[i][k]$表示

$$\sum_{j\in{i}}dis(i,j)^k$$

$j\in{i}$表示$j$在$i$子树内部

于是我们考虑一下化这个柿子

到达$i$肯定要先达到$i$的一个儿子，于是就有

$$dp[i][k]=\sum_{fa[j]=i}\sum_{t\in{j}}(dis(t,j)+1)^k$$

我们用二项式定理来将这个柿子展开

$$dp[i][k]=\sum_{fa[j]=i}\sum_{t\in{j}}\sum_{r=0}^kC_{k}^{r}*dis(t,j)^r$$

后面两个$\sum$换一下位置

$$dp[i][k]=\sum_{fa[j]=i}\sum_{r=0}^kC_{k}^{r}*\sum_{t\in{j}}dis(t,j)^r$$

之后就会惊奇的发现$\sum_{t\in{j}}dis(t,j)^r$就是$dp[j][r]$，于是现在就有了

$$dp[i][k]=\sum_{fa[j]=i}\sum_{r=0}^kC_{k}^{r}*dp[j][r]$$

这就是$up$的转移方程式，$down$的方程式也很好推

$down$的时候$dp[i][k]$表示的不仅局限于$i$的子树内部了，而是整棵树了

到达$i$首先要到达$fa[i]$，于是就有

$$dp[i][k]+=\sum_{j\notin{i},j\in{fa[i]}}(dis(fa[i],j)+1)^k$$

$$dp[i][k]+=\sum_{j\notin{i},j\in{fa[i]}}\sum_{r=0}^kC_{k}^r*dis(fa[i],j)^r$$

我们的要求不就是$j$不能来自于$i$内部吗，于是我们大力容斥就好了

我们把来自于$i$子树内部的答案减掉，于是就有了一个可以更新的柿子了

现在就有了一个我们就可以转移了，复杂度大概是$O(nk^2)$

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define re register
#define maxn 50005
#define int long long
const int mod=10007; 
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
struct E
{
	int v,nxt;
}e[maxn<<1];
int head[maxn],deep[maxn];
int n,m,num;
long long dp[maxn][151];
long long now[151];
long long c[151][151];
void dfs(int x)
{
	dp[x][0]=1;
	for(re int i=head[x];i;i=e[i].nxt)
	if(!deep[e[i].v])
	{
		deep[e[i].v]=deep[x]+1;
		dfs(e[i].v);
		dp[x][0]+=dp[e[i].v][0];
		for(re int k=1;k<=m;k++)
			for(re int r=0;r<=k;r++)
				dp[x][k]=(dp[x][k]+c[k][r]*dp[e[i].v][r])%mod;
	}
}
void redfs(int x)
{
	for(re int i=head[x];i;i=e[i].nxt)
	if(deep[e[i].v]>deep[x])
	{
		memset(now,0,sizeof(now));
		for(re int k=0;k<=m;k++)
		{
			now[k]=dp[x][k];
			for(re int r=0;r<=k;r++)
				now[k]=(now[k]-dp[e[i].v][r]*c[k][r]+mod)%mod;
		}//先容斥，不能来自于e[i].v子树内部
		for(re int k=0;k<=m;k++)
			for(re int r=0;r<=k;r++)
				dp[e[i].v][k]=(dp[e[i].v][k]+c[k][r]*now[r])%mod;//用容斥之后的答案来更新
		redfs(e[i].v);
	}
}
inline void add_edge(int x,int y)
{
	e[++num].v=y;
	e[num].nxt=head[x];
	head[x]=num;
}
signed main()
{
	n=read(),m=read();
	int x,y;
	for(re int i=1;i<n;i++)
		x=read(),y=read(),add_edge(x,y),add_edge(y,x);
	c[0][0]=1;
	for(re int i=1;i<=m;i++) c[i][0]=c[i][i]=1;
	for(re int i=1;i<=m;i++)
		for(re int j=1;j<i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	deep[1]=1;
	dfs(1);
	redfs(1);
	for(re int i=1;i<=n;i++)
		printf("%lld\n",(dp[i][m]%mod+mod)%mod);
	return 0;
}
```

这是一个要T的复杂度，但是已经有了$50$分的好成绩

点分治据说可以做到$O(nklogk)$，但是不会

我们继续组合数做吧

我们发现求**$x^k$可以理解为把$k$个物品放到$x$个互不相同的盒子里，允许有盒子空着不放的方案数**

于是我们可以写成$x^k=\sum_{i=1}^kS(k,i)*C_{x}^i*i!$

**其中$S(k,i)$是第二类斯特林数，表示的是将$k$个球分到$i$个盒子里，这$i$个盒子没有差别，而且没有盒子是空的的方案数**

$C_{x}^i*i!$其实就是排列数了，就相当于我们给$i$个盒子强行制造了差别

于是这个柿子可以理解为$i$枚举的是当前有几个盒子是有球的，之后通过加法原理合并了答案

其实我一开始觉得这里的$\sum$的上标应该写$x$，好像也只有写$x$才满足组合的意义，之后发现自己非常naive

1. 当$k>x$的时候显然是没有什么问题的了，因为$\binom{x}{i}$在$x>i$的时候取0，于是没有什么影响

1. 当$k<x$的时候，如果上标取到比$k$大的数了，那么也会导致$S(k,i)$变成$0$，于是写成$k$就可以了，在数值上没有什么影响

之后我们继续化柿子

$$ans[t]=\sum_{j=1}^{n}dis(t,j)^k$$

$$=\sum_{j=1}^{n}\sum_{i=1}^kS(k,i)*\binom{dis(t,j)}{i}*i!$$

$$=\sum_{i=1}^{k}S(k,i)*i!*\sum_{j=1}^n\binom{dis(t,j)}{i}$$

那么我们现在只需要求出$\sum_{j=1}^n\binom{dis(t,j)}{i}$就好了

我们都知道组合数有一个非常好的转移的方式就是$\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}$

于是

$$\sum_{j=1}^n\binom{dis(t,j)}{i}=\sum_{j=1}^n\binom{dis(t,j)-1}{i-1}+\sum_{j=1}^n\binom{dis(t,j)-1}{i}$$

现在是不是又可以用树形dp来转移了，因为到达$t$这个点还是要先到达$t$的儿子或者是父亲

于是我们设$dp[x][k]=\sum_{j\in{x}}\binom{dis(x,i)}{k}$

于是在$up$里的方程式就是

$$dp[x][k]=\sum_{fa[j]=i}dp[j][k]+dp[j][k-1]$$

$down$里我们还是要先容斥一下，方程和$up$类似

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 50005
#define LL long long
const LL mod=10007;
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
struct node
{
	int v,nxt;
}e[maxn<<1];
int head[maxn],deep[maxn];
LL dp[maxn][151],fac[151],s[151][151];
LL now[151];
int n,m,num;
inline void add_edge(int x,int y)
{
	e[++num].v=y;
	e[num].nxt=head[x];
	head[x]=num;
}
void dfs(int x)
{
	dp[x][0]=1;
	for(re int i=head[x];i;i=e[i].nxt)
	if(!deep[e[i].v])
	{
		deep[e[i].v]=deep[x]+1;
		dfs(e[i].v);
		dp[x][0]+=dp[e[i].v][0];
		for(re int j=1;j<=m;j++)
			dp[x][j]=(dp[x][j]+dp[e[i].v][j-1]+dp[e[i].v][j])%mod;
	}
}
void redfs(int x)
{
	for(re int i=head[x];i;i=e[i].nxt)
	if(deep[e[i].v]>deep[x])
	{
		memset(now,0,sizeof(now));
		now[0]=dp[x][0]-dp[e[i].v][0];
		for(re int j=1;j<=m;j++)
			now[j]=(dp[x][j]-dp[e[i].v][j]-dp[e[i].v][j-1]+mod)%mod;
            //依旧是先容斥一遍
		dp[e[i].v][0]+=now[0];
		for(re int j=1;j<=m;j++)
			dp[e[i].v][j]=(dp[e[i].v][j]+now[j]+now[j-1])%mod;
		redfs(e[i].v);
	}
}
int main()
{
	n=read(),m=read();
	int x,y;
	for(re int i=1;i<n;i++)
		x=read(),y=read(),add_edge(x,y),add_edge(y,x);
	s[0][0]=1;
	for(re int i=1;i<=m;i++)
		s[i][1]=s[i][i]=1;
	for(re int i=1;i<=m;i++)
		for(re int j=1;j<i;j++)
			s[i][j]=(s[i-1][j-1]+s[i-1][j]*j)%mod;//预处理第二类斯特林数
	fac[0]=1;
	for(re int i=1;i<=m;i++)
		fac[i]=(fac[i-1]*i)%mod;//预处理阶乘
	deep[1]=1;
	dfs(1);
	redfs(1);
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++)
			dp[i][j]=(dp[i][j]%mod+mod)%mod;
	for(re int i=1;i<=n;i++)
	{
		LL ans=0;
		for(re int j=1;j<=m;j++)
			ans=(ans+s[m][j]*fac[j]%mod*dp[i][j])%mod;
		printf("%lld\n",ans);//统计答案
	}
	return 0;
}
```

---

## 作者：p_b_p_b (赞：17)

[传送门](https://www.luogu.org/problemnew/show/P4827)

--------------

## 思路

又见到这个$k$次方啦！按照套路，我们将它搞成斯特林数：

$$ans_x=\sum_{i=0}^k i!S(k,i)\sum_y {dis(x,y) \choose i}$$


前面可以枚举，考虑后面那东西怎么求。

我们~~不知道为什么但就是~~考虑DP：设：

$$dn_{x,t}=\sum_{y\in x} {dis(x,y) \choose t}$$
$$up_{x,t}=\sum_{y\notin x} {dis(x,y) \choose t}$$

其中$y\in x$表示$y$在$x$的子树内。

显然$dn$比较好求，我们先搞$dn$。


$$dn_{x,t}=\sum_{y\in x} {dis(x,y) \choose t}$$
$$=[t=0]+\sum_v \sum_{y\in v} {dis(v,y)+1 \choose t}$$
$$=[t=0]+\sum_v \sum_{y\in v} \left( {dis(v,y) \choose t} + {dis(v,y) \choose t-1} \right)$$
$$=[t=0]+\sum_v (dp_{v,t} + dp_{v,t-1})$$


接下来是$up$。

$$up_{x,t}=\sum_{y\notin x} {dis(x,y) \choose t}$$
$$=\sum_{y\notin fa} {dis(fa,y)+1\choose t} +\sum_{y\in fa} {dis(fa,y)+1\choose t}-\sum_{y\in x} {dis(x,y)+2\choose t}$$
$$=up_{fa,t}+up_{fa,t-1}+dn_{fa,t}+dn_{fa,t-1}-dn_{x,t}-2dn_{x,t-1}-dn_{x,t-2}$$

特判一下$up_{1,t}=0$即可。

至此，问题结束。

复杂度$O(nk)$。

--------------------

## 代码

推了那么长的式子，代码其实超短。

```cpp
#include<bits/stdc++.h>
namespace my_std{
	using namespace std;
	#define pii pair<int,int>
	#define fir first
	#define sec second
	#define MP make_pair
	#define rep(i,x,y) for (int i=(x);i<=(y);i++)
	#define drep(i,x,y) for (int i=(x);i>=(y);i--)
	#define go(x) for (int i=head[x];i;i=edge[i].nxt)
	#define sz 50505
	#define mod 10007
	typedef long long ll;
	typedef double db;
	mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
	template<typename T>inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}
	template<typename T>inline void read(T& t)
	{
		t=0;char f=0,ch=getchar();double d=0.1;
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
		if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}
		t=(f?-t:t);
	}
	template<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}
	void file()
	{
		#ifndef ONLINE_JUDGE
		freopen("a.txt","r",stdin);
		#endif
	}
	#ifdef mod
	ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}
	ll inv(ll x){return ksm(x,mod-2);}
	#else
	ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}
	#endif
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

int n,K;
struct hh{int t,nxt;}edge[sz<<1];
int head[sz],ecnt;
void make_edge(int f,int t)
{
	edge[++ecnt]=(hh){t,head[f]};
	head[f]=ecnt;
	edge[++ecnt]=(hh){f,head[t]};
	head[t]=ecnt;
}

ll up[sz][233],dn[sz][233];
#define v edge[i].t
void dfs1(int x,int fa)
{
	dn[x][0]=1;
	go(x) if (v!=fa)
	{
		dfs1(v,x);
		(dn[x][0]+=dn[v][0])%=mod;
		rep(j,1,K) (dn[x][j]+=dn[v][j]+dn[v][j-1])%=mod;
	}
}
void dfs2(int x,int fa)
{
	if (x!=1)
	{
		up[x][0]=(up[fa][0]+dn[fa][0]-dn[x][0]+mod)%mod;
		up[x][1]=(up[fa][1]+up[fa][0]+dn[fa][1]+dn[fa][0]-dn[x][1]-2*dn[x][0]+mod*3)%mod;
		rep(i,2,K) up[x][i]=(up[fa][i]+up[fa][i-1]+dn[fa][i]+dn[fa][i-1]-dn[x][i]-2*dn[x][i-1]-dn[x][i-2]+mod*4)%mod;
	}
	go(x) if (v!=fa) dfs2(v,x);
}
#undef v

ll S[233][233];
ll fac[233];

int main()
{
	file();
	int x,y;
	read(n,K);
	rep(i,1,n-1) read(x,y),make_edge(x,y);
	dfs1(1,0);dfs2(1,0);
	fac[0]=1;rep(i,1,K) fac[i]=fac[i-1]*i%mod;
	S[0][0]=1;
	rep(i,1,K)
		rep(j,1,K)
			S[i][j]=(S[i-1][j-1]+1ll*j*S[i-1][j]%mod)%mod;
	rep(i,1,n)
	{
		ll ans=0;
		rep(j,0,K) ans=(ans+fac[j]*S[K][j]%mod*(up[i][j]+dn[i][j])%mod)%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：HenryHuang (赞：13)

# 「国家集训队」 Crash 的文明世界

提供一种不需要脑子的方法。

其实是看洛谷讨论版看出来的（

~~（但是全网也就这一篇这个方法的题解了）~~

首先这是一个关于树上路径的问题，我们可以无脑上点分治。

考虑当以 $root$ 为根时，如何计算经过 $root$ 的路径对某一个点的贡献。

若现在我们要找经过 $root$ 的路径中长度为 $d$ 且路径的一端为 $u$。

则这一部分的贡献为 $v_{d}cnt_{d-h_u}$，其中 $v_d=d^k$，$h_u$ 表示点 $u$ 的深度，$cnt_i$ 表示深度为 $i$ 的节点个数。

当然这里会有一种不合法的情况，就是找到的路径两端点在 $root$ 的同一棵子树中。这可以用点分治惯用的容斥解决。

以 $root$ 为根时，路径对点 $u$ 的贡献为（事实上对深度为 $h_u$ 的节点贡献是相同的）
$$
\sum_{d=h_u}^{maxdeep+h_u}v_dcnt_{d-h_u}\\
$$
为了处理起来更加方便，我们~~增加一些无用的部分~~

于是有
$$
\sum_{d=0}^{2\times maxdeep}v_dcnt_{d-h_u}\\
$$
令 $n=2\times maxdeep$。
$$
\sum_{d=0}^{n}v_dcnt_{d-h_u}\\
$$


按照套路，将 $cnt$ 数组翻转一下
$$
\sum_{d=0}^{n}v_dcnt_{n-d+h_u}\\
$$
令
$$
Ans_{n+h_u}=\sum_{d=0}^{n}v_dcnt_{n-d+h_u}\\
$$
这是一个卷积的形式，直接 $\texttt{FFT/NTT}$ 即可。

所以总时间复杂度为 $O(n\log_2n\log_2k)$。

~~（所以为啥不把这题的 k 开到和 n 同级呢）~~

下面讲讲常数优化：

+ 预处理原根、单位根必不可少。
+ 能不取模尽量别取模。
+ 由于这也是在分治的过程中进行 $\texttt{FFT}$ 的计算，所以当规模较小时暴力会更快。

另外值得注意的是，由于本题的模数不是一个 $\texttt{NTT}$ 模数，而中间过程中的结果最大可能为 $10006^2>998244353$ ，所以我们可能得换一个 $\texttt{NTT}$ 模数？（我也不知道需不需要，求大佬指点。~~事实上 998244353 也过了~~）

这样的话结果就一定不会有问题。

这个题就这样非常套路地被我们解决了。

贴一个很丑的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
const int p=1e4+7;
const int P=1004535809;
int n,k;
struct edge{
	int to,nex;
}e[maxn<<1];
int head[maxn],tot;
int siz[maxn],dp[maxn],vis[maxn],rt;
int w[maxn],cnt[maxn],ans[maxn];
int f[maxn],g[maxn],rev[maxn],len=1;
void add(int a,int b){
	e[++tot]=(edge){b,head[a]};
	head[a]=tot;
}
int ksm(int a,int b,int p){
	int ans=1;
	while(b){
		if(b&1) ans=1ll*ans*a%p;
		b>>=1,a=1ll*a*a%p;
	}
	return ans;
}
vector<int> W[20];
void INIT(){
	for(int i=1,num=0;num<=17;++num,i<<=1){
		int w=ksm(3,(P-1)/(i<<1),P),tmp=1;
		for(int k=0;k<i;++k)
			W[num].emplace_back(tmp),tmp=1ll*tmp*w%P;
	}
}
void NTT(int *f){
	for(int i=0;i<len;++i)
		if(i<rev[i]) swap(f[i],f[rev[i]]);
	for(int i=1,num=0;i<len;i<<=1,++num){
		for(int j=0;j<len;j+=(i<<1)){
			for(int k=0;k<i;++k){
				int x=f[j|k],y=1ll*W[num][k]*f[i|j|k]%P;
				f[j|k]=x+y>P?x+y-P:x+y;
				f[i|j|k]=x-y<0?x-y+P:x-y;
			}
		}
	}
}
void init(int x){
	len=1;
	while(len<=x) len<<=1;
	f[0]=g[0]=0;
	for(int i=1;i<len;++i)
		rev[i]=rev[i>>1]>>1|((i&1)?len>>1:0);
	memset(f,0,sizeof (int)*len);
	memset(g,0,sizeof (int)*len);
}
void getroot(int u,int f,int sum){
	siz[u]=1,dp[u]=0;
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(v==f||vis[v]) continue;
		getroot(v,u,sum);
		siz[u]+=siz[v];
		dp[u]=max(siz[v],dp[u]);
	}
	dp[u]=max(dp[u],sum-siz[u]);
	if(dp[u]<dp[rt]) rt=u;
}
void clear(int u,int f,int dis,int &mx){
	mx=max(mx,dis);
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(v==f||vis[v]) continue;
		clear(v,u,dis+1,mx);
	}
}
void getdis(int u,int f,int dis){
	++cnt[dis];
	if(cnt[dis]>=p) cnt[dis]-=p;
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(v==f||vis[v]) continue;
		getdis(v,u,dis+1);
	}
}
int owo[251];
void mul(int *a,int *b,int n){
	if(n<=100){
		memset(owo,0,sizeof (int)*(2*n+1));
		for(int i=0;i<=n;++i)
			for(int j=0;j<=n;++j)
				owo[i+j]=owo[i+j]+1ll*a[i]*b[j]%P>P?owo[i+j]+1ll*a[i]*b[j]%P-P:owo[i+j]+1ll*a[i]*b[j]%P;
		for(int i=0;i<=2*n;++i) a[i]=owo[i];
		return ;
	}
	memcpy(f,a,sizeof (int)*(n+1));
	memcpy(g,b,sizeof (int)*(n+1));
	NTT(f),NTT(g);
	for(int i=0;i<len;++i) f[i]=1ll*f[i]*g[i]%P;
	NTT(f);
	reverse(f+1,f+len);
	int inv=ksm(len,P-2,P);
	for(int i=0;i<=2*n;++i) a[i]=1ll*f[i]*inv%P;
}
void dfs(int u,int f,int dis,int opt){
	ans[u]+=opt*cnt[dis];
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(v==f||vis[v]) continue;
		dfs(v,u,dis+1,opt);
	}
}
void calc(int u,int dis,int opt){
	int n=0;
	clear(u,0,dis,n);n*=2;
	memset(cnt,0,sizeof (int)*(n+1));
	getdis(u,0,dis);
	reverse(cnt,cnt+n+1);
	init(2*n);
	mul(cnt,w,n);
	for(int i=0;i<=n;++i) cnt[i]=cnt[i+n];
	dfs(u,0,dis,opt);
}
void solve(int u){
	vis[u]=1;
	calc(u,0,1);
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(vis[v]) continue;
		calc(v,1,-1);
		rt=0;
		getroot(v,0,siz[v]);
		solve(rt);
	}
}
int main(){
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	INIT();
	for(int i=1;i<n;++i){
		int a,b;cin>>a>>b;
		add(a,b),add(b,a);
	}
	for(int i=0;i<n;++i) w[i]=ksm(i,k,p);
	dp[0]=(1<<30);
	getroot(1,0,n);
	solve(rt);
	for(int i=1;i<=n;++i) cout<<ans[i]%p<<'\n';
}
```



---

## 作者：81179332_ (赞：7)

前置知识：$m^n=\sum\limits_{i=0}^{\min(m,n)}\begin{Bmatrix} n\\i\end{Bmatrix}\dbinom mii!$

$m^n$ 是把 $n$ 个不同的小球放入 $m$ 个不同的盒子，允许盒子为空的方案数

$\dbinom mii!$ 表示我们从 $m$ 个盒子中选出在意顺序的 $i$ 个的方案数，我们钦定这些盒子非空

然后我们再乘上 $\begin{Bmatrix} n\\i\end{Bmatrix}$ 表示把这些不同的小球放入这 $i$ 个非空的盒子中的方案数

---
我们使用上面的公式改写一下题面中的式子：

$$\begin{aligned}
S_u&=\sum\limits_{v=1}^ndis(u,v)^k\\
&=\sum\limits_{v=1}^n\sum\limits_{i=0}^k\begin{Bmatrix} k\\i\end{Bmatrix}\dbinom {dis(u,v)}ii!\\
&=\sum\limits_{i=0}^k\begin{Bmatrix} n\\i\end{Bmatrix}i!\sum\limits_{v=1}^n\dbinom {dis(u,v)}i
\end{aligned}$$

设 $dp_{u,i}=\sum\limits_{v\in subtree(u)}\dbinom{dis(u,v)}i$

由于边权都是 $1$，$v$ 子树中所有点到 $u$ 的距离都比到 $v$ 的距离多了 $1$，容易联想到拆组合数：

$$
\begin{aligned}
\sum\limits_{v\in subtree(u)}\dbinom{dis(u,v)}i&=\sum\limits_{v\in subtree(u)}\dbinom{dis(u,v)-1}i+\dbinom{dis(u,v)-1}{i-1}\\
&=\sum\limits_{v\in son(u)} dp_{v,i}+dp_{v,i-1}
\end{aligned}
$$

则我们可以 `dp` 求出一个根的答案，换根 `dp` 即可求出所有点的答案

```cpp
const int N = 50010,K = 200,M = N;
int n,k;EE(1);
struct DP
{
	int f[K];int& operator [] (int x) { return f[x]; }
	friend void operator += (DP &u,DP v)
	{
		for(int i = 1;i <= k;i++) reduce(u[i] += Mod(v[i] + v[i - 1]) - mod);
		reduce(u[0] += v[0] - mod);
	}
	friend void operator -= (DP &u,DP v)
	{
		for(int i = 1;i <= k;i++) reduce(u[i] -= Mod(v[i] + v[i - 1]));
		reduce(u[0] -= v[0]);
	}
}dp[N],ans[N];
void dfs(int u,int fa)
{
	for(int i = 0;i <= k;i++) dp[u][i] = 0;
	dp[u][0] = 1;
	for(int i = head[u],v;i;i = e[i].nxt) if((v = e[i].to) != fa)
		dfs(v,u),dp[u] += dp[v];
}
void dfs1(int u,int fa)
{
	ans[u] = dp[u];
	for(int i = head[u],v;i;i = e[i].nxt) if((v = e[i].to) != fa)
	{
		DP tmp = dp[u];
		tmp -= dp[v];
		dp[v] += tmp;
		dfs1(v,u);
	}
}
int s[K][K],fac[K];
int main()
{
	n = read(),k = read();
	s[0][0] = s[1][1] = 1;
	for(int i = 2;i <= k;i++) for(int j = 1;j <= i;j++) s[i][j] = (s[i - 1][j - 1] + (ll)j * s[i - 1][j]) % mod;
	fac[0] = 1;for(int i = 1;i <= k;i++) fac[i] = (ll)fac[i - 1] * i % mod;
	for(int i = 1;i < n;i++) add_edge(read(),read());
	dfs(1,0),dfs1(1,0);
	for(int i = 1;i <= n;i++)
	{
		int res = 0;
		for(int j = 0;j <= k;j++) res = (res + (ll)s[k][j] * fac[j] * ans[i][j]) % mod;
		fprint(res);
	}
}
```

---

## 作者：Zxx200611 (赞：3)

给出一棵 $n$ 个节点的树 $T$ 和一个非负整数 $k$，树上节点编号为 $1 \sim n$。对于每个节点 $u$，求出：
$$
A(u) = \sum_{v=1}^{n} \operatorname{dist}(u,v)^k \pmod{10007}
$$
$n \le 5 \times 10^4$，$k \le 150$。

---

对于 $x^k$ 之类的表达式，除了用组合数容斥展开之外，还有一个惯用方法是用 Stirling 数展开。

考虑 $x^k$ 的组合意义：将 $k$ 个不同小球放入 $x$ 个不同盒子里，可以有盒子为空的方案数。

那么可以枚举空盒子数，用 Stirling 数的性质代替容斥计算：
$$
x^k = \sum_{i=1}^{x} \binom{x}{i} \times \begin{Bmatrix}k\\i\end{Bmatrix} \times i!
$$
即枚举有球的盒子数量 $i$，从 $x$ 个盒子中选出 $i$ 个，再将 $k$ 个不同小球塞入这些盒子里的方案数。



代入 $A(u)$ 的表达式，将其展开：
$$
\def \dist {\operatorname{dist}}
\begin{aligned}
A(u) & = \sum_{v=1}^{n} \dist(u,v)^k \\
     & = \sum_{v=1}^{n} \sum_{i=1}^{\dist(u,v)} \binom{\dist(u,v)}{i} \times \begin{Bmatrix} k\\i \end{Bmatrix} \times i! \\
     & = \sum_{v=1}^{n} \sum_{i=1}^{k} \binom{\dist(u,v)}{i} \times \begin{Bmatrix} k\\i \end{Bmatrix} \times i! \\
     & = \sum_{i=1}^{k} \begin{Bmatrix} k\\i \end{Bmatrix}i! \times  \sum_{v=1}^{n} \binom{\dist(u,v)}{i}
\end{aligned}
$$
那么对于每个 $i$，只用求出 $\sum_{v=1}^{n} \binom{\operatorname{dist(u,v)}}{i}$ 即可。设其为 $f[u,i]$。

根据组合数的递推式，有：
$$
\def \dist {\operatorname{dist}}
\sum_{v=1}^{n} \binom{\dist(u,v)}{i} = \sum_{v=1}^{n} \binom{\dist(u,v)-1}{i-1} + \sum_{v=1}^{n} \binom{\dist(u,v)-1}{i}
$$
那么可以考虑传统的 $\text{up and down}$ 树形 DP。设 $i$ 为某个值时，来自 $u$ 子树的贡献为 $f_d[u,i]$，来自 $u$ 父亲的贡献为 $f_u[u,i]$。注意 $f_u$ 的 $u$ 是一个字母而不是节点编号。

首先 $f_d$ 可以用一遍 DFS 求出。记 $T_u$ 为节点 $u$ 的子树，根据上面的式子，有：
$$
\def \dist {\operatorname{dist}}
\begin{aligned}
f_d[u,i] & = \sum_{v \in T_u} \binom{\dist(u,v)}{i} \\
         & = \sum_{v \in \operatorname{Son}(u)} \sum_{w\in T_v} \binom{\dist(v,w)+1}{i} \\
         & = \sum_{v \in \operatorname{Son}(u)} \left[ \sum_{w \in T_v} \binom{\dist(v,w)}{i} + \sum_{w \in T_v} \binom{\dist(v,w)}{i-1} \right ] \\
         & = \sum_{v \in \operatorname{Son}(u)} f_d[v,i] + f_d[v,i-1]
\end{aligned}
$$
若 $v$ 为叶子节点，则 $\forall i \in [0,k]$，$f_d[v,i]=1$。



接下来是 $f_u$，根据经验，需要从上往下求。令 $v$ 为节点 $u$ 的父亲，那么可以认为此时所有 $f_u[v,i]$ 都是求好的。

推转移方程，先试着将 $f_u[v,i]$ 拆出来：
$$
\def \dist {\operatorname{dist}}
\begin{aligned}
f_u[u,i] & = \sum_{w \in T-T_u} \binom{\dist(u,w)}{i} \\
         & = \sum_{w \in T-T_v} \binom{\dist(u,w)}{i} + \sum_{w \in T_v-T_u} \binom{\dist(u,w)}{i} \\

\end{aligned}
$$
此时 $f_u[v,i]$ 和前面已经很像了，简单变形即可，重点是后面的子树差的形式如何处理。我们的目标是将其表示为含有 $f$ 的形式。

可以想到一个显然错误的表达形式：
$$
\def \dist {\operatorname{dist}}
\sum_{w \in T_v} \binom{\dist(v,w)+1}{i}
$$
它会多算 $u$ 子树内的节点，且将其路程全部多算 $2$（$u \leftrightarrow v$ 这一条边被算了两次，原来不用算），那么将其减去即可。得到：
$$
\def \dist {\operatorname{dist}}
\sum_{w \in T_v-T_u} \binom{\dist(u,w)}{i} = \sum_{w \in T_v} \binom{\dist(v,w)+1}{i} - \sum_{w \in T_u} \binom{\dist(u,w)+2}{i}
$$
可以发现，我们将其都化成了在某个子树内到子树根距离的形式，那么接下来要做的就是简单地将其用 $f$ 表示出来：
$$
\def \dist {\operatorname{dist}}
\begin{aligned}
f_u[u,i] & = \sum_{w \in T-T_v} \binom{\dist(u,w)}{i} + \sum_{w \in T_v} \binom{\dist(u,w)}{i} - \sum_{w \in T_u} \binom{\dist(u,w)+2}{i} \\
         & = \sum_{w \in T-T_v} \binom{\dist(v,w)+1}{i} + \sum_{w \in T_v} \binom{\dist(v,w)+1}{i} - \sum_{w \in T_u} \binom{\dist(u,w)+2}{i} \\
         & = \sum_{w \in T-T_v} \left[ \binom{\dist(v,w)}{i}+\binom{\dist(v,w)}{i-1} \right] + \sum_{w \in T_v} \left[ \binom{\dist(v,w)}{i} + \binom{\dist(v,w)}{i-1} \right] - \sum_{w \in T_u} \binom{\dist(u,w)+2}{i} \\
         & = f_u[v,i] + f_u[v,i-1] + f_d[v,i] + f_d[v,i-1] - \sum_{w \in T_u} \left[ \binom{\dist(u,w)+1}{i} + \binom{\dist(u,w)+1}{i-1} \right] \\
         & = f_u[v,i] + f_u[v,i-1] + f_d[v,i] + f_d[v,i-1] - \sum_{w \in T_u} \left[ \binom{\dist(u,w)}{i} + 2 \times \binom{\dist(u,w)}{i-1} + \binom{\dist(u,w)}{i-2} \right] \\
         & = f_u[v,i] + f_u[v,i-1] + f_d[v,i] + f_d[v,i-1] - f_d[u,i] - 2f_d[u,i-1] - f_d[u,i-2]
\end{aligned}
$$
那么 $f_u$ 的转移方程也得到了。两次 DFS 即可得到所有 $f$。最终答案即为：
$$
A(u) = \sum_{i=1}^{k} \begin{Bmatrix}k\\i\end{Bmatrix}i! \times (f_u[u,i] + f_d[u,i])
$$
其中 Stirling 数可以 $O(k^2)$ 地递推求出。



总时间复杂度为 $O(nk)$，瓶颈在于 DP，足以通过此题。


代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int p=10007;

int k;
vector<int> G[50010];

int Stl[160][160];
int fu[50010][160],fd[50010][160];

inline
void getStl()
{
	Stl[0][0]=1;
	for(int i=1;i<=k;i++)
	{
		for(int j=1;j<=i;j++)
		{
			Stl[i][j]=(1ll*Stl[i-1][j]*j%p+Stl[i-1][j-1])%p;
		}
	}
}
void treeUpDP(int u,int fa)
{
	fd[u][0]=1;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(v==fa)
		{
			continue;
		}

		treeUpDP(v,u);
		for(int j=0;j<=k;j++)
		{
			fd[u][j]=(fd[u][j]+fd[v][j]+(j==0?0:fd[v][j-1]))%p;
		}
	}
}
void treeDownDP(int u,int fa)
{
	if(fa!=-1)
	{
		for(int i=0;i<=k;i++)
		{
			fu[u][i]=fu[fa][i]+fd[fa][i]-fd[u][i]
			         +(i>=1?fu[fa][i-1]+fd[fa][i-1]-2*fd[u][i-1]:0)
					 +(i>=2?-fd[u][i-2]:0);
			fu[u][i]=(fu[u][i]%p+p)%p;
		}
	}

	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(v==fa)
		{
			continue;
		}

		treeDownDP(v,u);
	}
}

int main()
{
	int n;
	cin>>n>>k;
	int u,v;
	for(int i=1;i<=n-1;i++)
	{
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}

	getStl();
	treeUpDP(1,-1);
	treeDownDP(1,-1);

	for(u=1;u<=n;u++)
	{
		int res=0;
		for(int i=1,w=1;i<=k;i++,w=1ll*w*i%p)
		{
			res+=1ll*Stl[k][i]*w*(fu[u][i]+fd[u][i])%p;
			res%=p;
		}
		cout<<res<<'\n';
	}
}
```

---

## 作者：shiroi (赞：3)

### Description

给定一棵 $n$ 个点 $n-1$ 条边的无向连通图，对于每个点 $i$ 求出：
$$
S(i) = \sum_{j=1}^n dist(i,j)^k
$$

### Solution

观察题目考虑利用第二类斯特林数进行推导。斯特林数具有如下性质：
$$
m^n=\sum\limits_{i=0}^m\begin{Bmatrix}n \\ i\end{Bmatrix}*i!*\dbinom{m}{i}
$$

这里给出感性证明。考虑到 $m^n$ 是把 $n$ 个不同的小球放进 $m$ 个不同的盒子,允许空盒的方案数。由于要求非空，需要从 $m$ 个盒子里面选出 $i$ 个非空盒子,要乘上 $\dbinom{m}{i}$ 。将 $n$ 个球放进去需要乘上 $\begin{Bmatrix}n \\ i\end{Bmatrix}$ ，由于盒子不同，最后需要乘以 $i!$ 。

对于点 $i$ 考虑将原先的式子用斯特林数展开：
$$
\begin {aligned}
S(i)
&=\sum_{j=1}^n dist(i,j)^k
\\ \\
&=\sum_{j=1}^n\sum_{t=0}^k \begin{Bmatrix} k\\t \end{Bmatrix}
\binom{dist(i,j)}{t} i!
\end{aligned}
$$
调整一下顺序即有：
$$
S(i)=\sum_{t=0}^k \begin{Bmatrix} k\\t \end{Bmatrix} i! \sum_{j=1}^n \binom{dist(i,j)}{t}
$$
我们可以简单递推预处理出斯特林数和阶乘的部分，之后换根dp求解后半部分即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
    int x=0,f=1,c=getchar();
    while(c<48) c=='-'&&(f=-1),c=getchar();
    while(c>47) x=x*10+c-'0',c=getchar();
    return x*f;
}

const int mod = 10007;
const int MAXN = 50005;
std::vector<int> G[MAXN];
int f[MAXN][155],g[MAXN][155];
int s[155][155],fac[155],res[MAXN];
int n,k;

inline void addedge(int u,int v)
{
    G[u].push_back(v);
    G[v].push_back(u);
}

void dfs(int x,int fa)
{
    f[x][0]=1;
    for(int &y : G[x])
    {
        if(y==fa) continue; dfs(y,x);
        for(int j=0; j<=k; ++j) (f[x][j]+=f[y][j])%=mod;
        for(int j=1; j<=k; ++j) (f[x][j]+=f[y][j-1])%=mod;
    }
}

inline void sol(int x,int fa)
{
    for(int j=0; j<=k; ++j) g[x][j]=f[x][j];
    if(fa)
    {
        for(int j=0; j<=k; ++j) res[j]=(g[fa][j]-f[x][j]+mod)%mod;
        for(int j=1; j<=k; ++j) res[j]=(res[j]-f[x][j-1]+mod)%mod;
        for(int j=0; j<=k; ++j) g[x][j]=(g[x][j]+res[j])%mod;
        for(int j=1; j<=k; ++j) g[x][j]=(g[x][j]+res[j-1])%mod;
    }
    for(int &y : G[x]) if(y^fa) sol(y,x);
}

inline void init()
{
    for(int i=1; i<=k; ++i) fac[i]=fac[i-1]*i%mod;
    for(int i=1; i<=k; ++i)
        for(int j=1; j<=i; ++j)
            s[i][j]=(s[i-1][j-1]+j*s[i-1][j])%mod;
}

int main(int argc, char const *argv[])
{
    n=read(); k=read(); fac[0]=s[0][0]=1;
    for(int i=1; i<n; ++i)
        addedge(read(),read());
    init(); dfs(1,0); sol(1,0);
    for(int i=1; i<=n; ++i)
    {
        int ans=0;
        for(int j=0; j<=k; ++j)
            ans=(ans+s[k][j]*fac[j]%mod*g[i][j]%mod)%mod;
        printf("%d\n",ans);
    }
    return 0;
}
```





---

## 作者：Soulist (赞：1)



给一棵树，你需要对于每个点 $x$ 求出：

$$\sum_{i=1}^n dist(i,x)^k$$

$n\le 5\times 10^4,k\le 150$

$\rm Sol:$

先把$x^k$这种形式通过第二类斯特林数表达：

得到：

$$\sum_{i=1}^n\sum_{j=0}^{dist(i,x)}\dbinom{dist(i,x)}{j}\begin{Bmatrix}k\\j\end{Bmatrix}j!$$

交换求和$\sum$得到：

$$\sum_{j=0}^L\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=0}^{n}\dbinom{dist(i,x)}{j}$$

事实上，如果我们能够对于$[0,L]$内的每个第二类斯特林数维护出其系数那么本题即大功告成了。

注意到对于$\dbinom{k}{j}\to \dbinom{k+1}{j}$相当于加上了一个$\dbinom{k}{j-1}$

于是距离的转移实际上是相当$easy$的。

我们可以考虑对于每个点 $x$ 以及每个$k\in[0,L]$维护其子树内所有点到其的系数和，即：$\sum_{u\in x.son} \dbinom{dis(x,u)}{k}$

实际上这个转移是相当容易的，注意到对于$x$跨过一条边走到$fa$的这个过程，所有距离都至少增大了$1$，所以我们可以直接套用组合数的转移（类似于[重返现世]）

即：

$$\text{系数}_{fa,k}=\text{系数}_{x,k}+\text{系数}_{x,k-1}$$

然后我们再单独把父亲本身的加上即可。

考虑如何统计答案，容易发现如此操作后我们可以得到根的答案，于是每个点的答案可以通过换根$dp$考虑，注意到子树内我们已经完成了统计，于是只需要关心子树外的贡献。

注意到子树外可以如此考虑：假定你求出了父亲$fa$子树外的贡献和，那么$x$子树外的贡献和，可以视为父亲的子树外+父亲的子树内-$x$的子树内到$fa$的答案，然后再考虑跨过一条边的影响即可。

置于换根的还原则类似。

复杂度$O(nk)$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define re register
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 5e4 + 5 ;
const int M = 150 + 5 ;
const int P = 10007 ; 
int n, m, cnt, head[N], f[N][M], g[M], fac[M], s[M][M], Ans[N] ; 
struct E { int to, next ; } e[N << 1] ; 
int fpow( int x, int k ) {
	int ans = 1, base = x % P ; 
	while( k ) {
		if( k & 1 ) ans = ans * base % P ;
		base = base * base % P, k >>= 1 ;
	} return ans % P ; 
} 
void add( int x, int y ) {
	e[++ cnt] = (E){ y, head[x] }, head[x] = cnt,
	e[++ cnt] = (E){ x, head[y] }, head[y] = cnt ; 
}
void dfs( int x, int fa ) {
	f[x][0] = 1 ; 
	Next( i, x ) {
		int v = e[i].to ; if( v == fa ) continue ; 
		dfs( v, x ) ; rep( j, 0, m ) {
			f[x][j] += f[v][j] ;
			if( j > 0 ) ( f[x][j] += f[v][j - 1] ) ; 
			f[x][j] %= P ;
		} 
	} 
}
void dfs_ans( int x, int fa ) {
	if( x != fa ) {
		g[0] += ( f[fa][0] - f[x][0] + P ) % P, g[0] %= P ;
		rep( i, 1, m ) g[i] += ( f[fa][i] - ( f[x][i] + f[x][i - 1] ) % P + P ) % P ;
		drep( i, 1, m ) g[i] = ( g[i] + g[i - 1] + P ) % P ;
	}
	rep( i, 0, m ) Ans[x] = ( Ans[x] + s[m][i] * fac[i] % P * ( g[i] + f[x][i] ) % P ) % P ;
	Next( i, x ) {
		int v = e[i].to ; if( v == fa ) continue ; 
		dfs_ans( v, x ) ;
	}
	rep( i, 1, m ) g[i] = ( g[i] - g[i - 1] ) % P ; g[0] = ( g[0] - ( f[fa][0] - f[x][0] ) + P ) % P ;
	rep( i, 1, m ) g[i] = ( g[i] - f[fa][i] + f[x][i] + f[x][i - 1] + P ) % P ;
}
signed main()
{
	n = gi(), m = gi() ; int x, y ; 
	rep( i, 2, n ) x = gi(), y = gi(), add( x, y ) ;
	s[0][0] = 1 ; rep( i, 1, m ) rep( j, 1, i ) {
		s[i][j] = s[i - 1][j] * j % P ;
		if( j > 0 ) s[i][j] += s[i - 1][j - 1], s[i][j] %= P ; 
	} 
	
	fac[0] = 1 ; 
	rep( i, 1, m ) fac[i] = fac[i - 1] * i % P ;
	dfs( 1, 1 ), dfs_ans( 1, 1 ) ;
	rep( i, 1, n ) printf("%lld\n", Ans[i] ) ;
	return 0 ;
}
```

---

## 作者：Star_Cried (赞：0)

## P4827 [国家集训队] Crash 的文明世界

### 题意

求出对于树上每个点 $x$ 的 $\sum_{u=1}^ndis(x,u)^k$。所有边长为 1。

### 思路 

根据斯特林反演：
$$
m^n=\sum_{j=0}^n\begin{Bmatrix}n\\j\end{Bmatrix}C_m^jj!
$$
可以得到：
$$\sum_{i=1}^n\sum_{j=0}^{k}\begin{Bmatrix}k\\j\end{Bmatrix}C_{dis(x,i)}^jj!$$
$$=\sum_{j=0}^{k}\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=1}^nC_{dis(x,i)}^j$$
$$=\sum_{j=0}^{k}\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum_{i=1}^n(C_{dis(x,i)-1}^{j-1}+C_{dis(x,i)-1}^j$$
我们只需要 Dp 一边维护后面的组合数部分的值就行了。最后一步是为了推出转移式，设 $f_{x,j}$ 为 $\sum_{i=1}^nC_{dis(x,i)}^j$，则有：
$$
f_{x,j}=\sum_{x\rightarrow u}f_{u,j}+f_{u,j-1}
$$
再进行一步换根最后代回原式得出答案即可。

### 实现

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=5e4+10,mod=10007,maxm=210;
	int ecnt,head[maxn],to[maxn<<1],nxt[maxn<<1];
	inline void addedge(int a,int b){
		to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;
		to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;
	}
	int n,k,f[maxn][maxm],g[maxn][maxm],S[maxm][maxm],mul[maxm];
	void dfs1(int x,int fa){
		f[x][0]=1;
		for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa){
			dfs1(u,x);
			for(int j=1;j<=k;j++) f[x][j]=(f[x][j]+f[u][j]+f[u][j-1])%mod;
			f[x][0]=(f[x][0]+f[u][0])%mod;
		}
	}
	void dfs2(int x,int fa){
		for(int i=0;i<=k;i++) g[x][i]=f[x][i];
		if(fa){
			static int res[maxm];
			for(int i=1;i<=k;i++) res[i]=(g[fa][i]-f[x][i]-f[x][i-1]+mod*2)%mod;
			res[0]=(g[fa][0]-f[x][0]+mod)%mod;
			for(int i=1;i<=k;i++) g[x][i]=(g[x][i]+res[i]+res[i-1])%mod;
			g[x][0]=(g[x][0]+res[0])%mod;
		}
		for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa) dfs2(u,x);
	}
	inline void work(){
		n=read(),k=read();
		for(int i=1;i<n;i++) addedge(read(),read());
		S[0][0]=S[1][1]=1;
		for(int i=2;i<=k;i++) for(int j=1;j<=i;j++) S[i][j]=(S[i-1][j-1]+S[i-1][j]*j)%mod;
		mul[0]=1;for(int i=1;i<=k;i++) mul[i]=mul[i-1]*i%mod;
		dfs1(1,0),dfs2(1,0);
		for(int i=1;i<=n;i++){
			int ans=0;
			for(int j=0;j<=k;j++) ans=(ans+1ll*S[k][j]*mul[j]*g[i][j])%mod;
			printf("%d\n",ans);
		}
	}
}
signed main(){
	star::work();
	return 0;
}
```



---


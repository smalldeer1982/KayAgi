# [十二省联考 2019] 骗分过样例

## 题目背景

这是一道**传统题**。

“我的程序需要完成什么功能呀？. . . . . . ”

“我也不知道. . . . . . ”

“啊？那我怎么写呀. . . . . . ”

“已经有人给你写好测试了，只要你通过这些测试就可以了. . . . . . ”

“啊？. . . . . . ”

“所有的测试数据都在题目目录下，请做好备份，避免误删！”

“这. . . . . . ”

“哦，我还可以把输入格式告诉你. . . . . . 不过都有完整的数据了，知道输入格式可能也没太大用处吧. . . . . . ”

## 题目描述

题目数据详见附加文件

## 说明/提示

#### 子任务
“‘每个功能的文档’在哪里呀？”

“我也没有，就像我没有题目描述一样. . . . . . ”

“好吧. . . . . . 那我是不是打表就可以了呀. . . . . . ”

“**代码长度限制是 $\bold{102400}$ 字节** （$100$KB），直接打肯定是不行的！不过，需要的话倒是可以稍微打一些小的表. . . . . . ”

“唔. . . . . . ”

“另外，我们会给你的程序对于每个测试点分别评分，求和后得到总分。按照传统
的规矩，每个测试点正确得满分，错误得 $0$ 分。**每个测试点的分值不全相同，测试点的分值、顺序与难度没有必然联系** 。”

| 测试点 | 功能编号 | 分值 |
| :-------: | :-------: | :-------: |
| $1$ | $\texttt{1\_998244353}$ | $4$ |
| $2$ | $\texttt{1\_998244353}$ | $4$ |
| $3$ | $\texttt{1\_998244353}$ | $4$ |
| $4$ | $\texttt{1?}$ | $7$ |
| $5$ | $\texttt{1?+}$ | $9$ |
| $6$ | $\texttt{1wa\_998244353}$ | $6$ |
| $7$ | $\texttt{1wa\_998244353}$ | $7$ |
| $8$ | $\texttt{2p}$ | $4$ |
| $9$ | $\texttt{2p}$ | $6$ |
| $10$ | $\texttt{2p}$ | $8$ |
| $11$ | $\texttt{2u}$ | $5$ |
| $12$ | $\texttt{2u}$ | $6$ |
| $13$ | $\texttt{2u}$ | $9$ |
| $14$ | $\texttt{2g}$ | $5$ |
| $15$ | $\texttt{2g}$ | $7$ |
| $16$ | $\texttt{2g?}$ | $9$ |


#### 提示
在你使用 C/C++ 的 `int` 类型时，如果发生了溢出，比较可能的情况是按照模 $2^{32}$ 同余的前提下，在 `int` 范围内取一个合理的值。例如在计算 $2147483647 + 2$ 时，较有可能会得到 $-2147483647$。

然而，C/C++ 标准将这种情况归类为“未定义行为”。当你的程序试图计算会溢
出的 `int` 运算时，除了上述结果外，编译器还可能会让你的程序在此时计算出错误结果、死循环、运行错误等，这也是符合 C/C++ 标准的。

如果你的程序希望利用 `int` 的自然溢出的特性，请转换为 `unsigned` 类型运算。例如将 `a + b` 改写为 `(int) ((unsigned) a + (unsigned) b)`，以避免出现不预期的错误。


# 题解

## 作者：TheLostWeak (赞：154)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5285.html)

**大致题意：** 把所有输入输出数据都给你，并给你一定提示，让你写出正确的程序。

### Case 1~Case 3

首先让我们点开数据，发现输入为 $0,1,2,3....$ ，输出为 $1,19,361,6859...$。

不用多说，显然是求 $19^x$。

再看功能编号 `1_998244353` ，显然 $998244353$ 是模数。

于是，用快速幂就可以过前两个点。

然后就会发现第三个点的 $x$ 很大。。。

因此就要借助**欧拉定理**来进行求解。

由欧拉定理可知：$a^{\phi(MOD)}\equiv1(mod\ MOD)$。

所以，$a^x\equiv a^{x\%\phi(MOD)}(mod\ MOD)$。

由于 $MOD$ 是个质数，所以 $\phi(MOD)$ 就等于 $MOD-1$。

这样一来，我们只需要在读入 $x$ 时边读边向 $MOD-1$ 取模，即可。

代码如下：

```cpp
I void Qmul(LL& x,CL y,CL X) {RL k=(LL)((1.0L*x*y)/(1.0L*X)),t=x*y-k*X;t-=X;W(t<0) t+=X;x=t;}//快速乘
I LL Qpow(RL x,RL y,CL X) {RL t=1;W(y) y&1&&(Qmul(t,x,X),0),Qmul(x,x,X),y>>=1;return t;}//快速幂
class CommonPow19Solver//求解19^x
{
	public:
		I void Solve(CL X)//求解答案，X为模数
		{
			RI n;RL x;for(F.read(n);n;--n)
				F.read_with_X(x,X-1),F.writeln(Qpow(19,x,X));//读入时向X-1取模，然后快速幂
		}
}Common;
```

### Case 4

看数据显然还是求 $19^x$。

但功能编号里本该放模数的位置变成了`?`是什么鬼？

仔细观察，似乎答案都不是很大。

因此我们可以考虑通过枚举的方式来确定模数。

然后有几点需要注意：

- 枚举下界是所有元素最大值（$1145099$）$+1$。
- 验证时不要像我一开始那样naive地对于每个数去验证，其实只要验证一下第一个大数 $627811703016764290815178977207148434322$ 的答案是否正确即可。
- 模数需要为质数，~~因为我们要相信出题人很良心，~~ 不然 $\phi$ 不好求。而判断其是否为质数可以使用[$\texttt{MillerRabin}$](https://www.cnblogs.com/chenxiaoran666/p/MillerRabin.html)。（我们会发现接下来经常要用到$\texttt{MillerRabin}$）

于是就可以得到找模数代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define Con const
#define CI Con int&
#define CL Con LL&
#define I inline
#define W while
#define LL long long
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define Shl(x) ((x<<=1)>=X&&(x-=X))
using namespace std;
LL X;
class MillerRabin//MillerRabin判素数板子
{
	private:
		#define Pcnt 12
		Con int P[Pcnt]={2,3,5,7,11,13,17,19,61,2333,4567,24251};
		I LL Qmul(CL x,CL y,CL X) 
		{
			RL k=(LL)((1.0L*x*y)/(1.0L*X)),t=x*y-k*X;
			t-=X;W(t<0) t+=X;return t;
		}
		I LL Qpow(RL x,RL y,CL X) 
		{
			RL t=1;W(y) y&1&&(t=Qmul(t,x,X)),x=Qmul(x,x,X),y>>=1;
			return t;
		}
		I bool Check(CL x,CI p)
		{
			if(Qpow(p%x,x-1,x)^1) return false;
			RL k=x-1,t;W(!(k&1))
			{
				if((t=Qpow(p%x,k>>=1,x))^1&&t^(x-1)) return false;
				if(!(t^(x-1))) return true;
			}return true;
		}
	public:
		I bool IsPrime(CL x)
		{
			if(x<2) return false;
			for(RI i=0;i^Pcnt;++i) {if(!(x^P[i])) return true;if(!Check(x,P[i])) return false;}
			return true;
		}
}MR;
I void Qmul(LL& t,RL y) {RL x=t;t=0;W(y) y&1&&Inc(t,x),Shl(x),y>>=1;}//快速乘
I LL Qpow(RL y) {RL x=19,t=1;W(y) y&1&&(Qmul(t,x),0),Qmul(x,x),y>>=1;return t;}//快速幂
I void Sread(Con string& s,LL& x,CL X)//从字符串中边取模边读入
{
	for(RI i=x=0,l=s.length();i^l;++i) 
		x=(((x<<3)+(x<<1))%X+(s[i]&15))%X;
}
I void FindX(CL l,CL r)//寻找模数
{
	RI n;RL i,x;Reg string st="627811703016764290815178977207148434322";//存下第一个大数
	for(i=l;i<=r;++i) if(MR.IsPrime(X=i))//枚举数，判断其是否为质数
		if(Sread(st,x,i-1),!(Qpow(x)^642666)) return (void)(printf("%lld",X));//读入，判断第一个数答案是否正确
}
int main() {return FindX(1145100,1500000),0;}//确定枚举范围
```

运行结果：

```cpp
1145141
```

然后就可以套用之前的板子，只需要在调用时改成：

```cpp
Common.Solve(1145141);
```

### Case 5

`1?+` 。。。一看就是 `1?` 的升级版。

我们可以发现模数似乎特别大。

暴枚肯定不行了，我们需要换一种思路。

考虑怎样才能确定模数的大致范围？

于是就能想到这样一种情况：找到最相近的两个数 $x,y$（$x<y$），使得 $x$ 的答案大于 $y$ 的答案。

则我们通过 $x$ 的答案求出$y$的答案在不取摸情况下为 $ans_x*19^{y-x}$，则模数必然为 $ans_x*19^{y-x}-ans_y$ 的因数。

具体实现就是将每个数与其对应的答案一起按数的大小排个序，然后扫一遍即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define Con const
#define CI Con int&
#define CL Con LL&
#define I inline
#define W while
#define N 10000
#define LL long long
#define Gmax(x,y) (x<(y)&&(x=(y)))
#define eps 1e-10
#define ull unsigned long long
using namespace std;
int n;char st[5];struct data {LL x,v;I bool operator < (Con data& t) Con {return x<t.x;}}s[N+5];
I int Pow(CI x,CI y) {RI i,t=1;for(i=1;i<=y;++i) t*=x;return t;}
int main()
{
	RI res=0;RL i,Mx=0;FILE *F1=fopen("software5.in","r"),*F2=fopen("software5.ans","r");
	for(fscanf(F1,"%s%d",st,&n),i=1;i<=n;++i) 
		fscanf(F1,"%lld",&s[i].x),fscanf(F2,"%lld",&s[i].v),Gmax(Mx,s[i].v);//读入每个数及其对应的答案，Mx统计答案最大值
	for(sort(s+1,s+n+1),i=1;i^n;++i) s[i].v>s[i+1].v&&//排序，然后找到符合条件的一对数
		(!res||s[i+1].x-s[i].x<s[res+1].x-s[res].x)&&(res=i);
	printf("Max=%lld\n%lld %lld\n%lld %lld\n",Mx,s[res].x,s[res].v,s[res+1].x,s[res+1].v);//输出
	return 0;
}
```

运行结果：

```cpp
Max=5211500658258874318
264708066 1996649514996338529
264708068 1589589654696467295
```

则可以计算出 $ans_y$ 不取模为 $1996649514996338529*361=720790474913678208969$，然后减去取模后的 $ans_y$，得到模数为 $719200885258981741674$ 的因数。

但对于这么大一个爆 `long long` 的数，我们该如何找它的因数呢？

没关系，我们有Python，然后就可以枚举寻找一个较小的因数，来确定较大的那个因数。

但考虑到在根号范围内寻找依然太慢，于是要加两个优化：

- 我们要相信出题人足够良心，模数不会爆 `long long`，因此对于一开始模数爆 `long long` 的情况可以直接跳过。
- 我们之前不是得到了一个答案下界（即最大值 $+1$）吗？当另一个较大的因数小于等于最大值时，我们就可以直接结束循环了。

于是效率大大提高，很快就能得出答案。

代码如下：

```python
v=719200885258981741674#已知答案是这个数的因数
Mx=5211500658258874319#答案下界
lim=2**63#long long范围
i=0#初始化i为0
while(1):
    i+=1#将i加1
    if(v//i>=lim):continue#如果此时答案超过long long范围，跳过
    if(v%i==0):print (v//i)#如果找到答案，输出
    if(v//i<Mx):break#如果小于答案下界，结束循环
```

运行结果：

```cpp
5211600617818708273
```

然后照样套用之前的板子，只需改成：

```cpp
Common.Solve(5211600617818708273);
```

### Case 6~Case 7

这个就很有趣了，`1wa_998244353`，显然还是在模 $998244353$ 意义下求 $19^x$，但这个 `wa` 是什么鬼？

点开输出，可以发现有负数！

便能想到或许是在暴力乘的时候写成了：

```cpp
x=19*x%X;
```

然而`19*x`爆`int`了，于是就有了负数。

但这样显然不能快速幂。

不过，这样或许会出现循环节！

于是就可以想到借助 map，写出这样一份代码：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define Con const
#define CI Con int&
#define CL Con LL&
#define I inline
#define W while
#define N 10000
#define LL long long
#define X 998244353
using namespace std;
map<int,int> p;
int main()
{
	for(RI i=1,x=1;;++i)
		if(p[x=19*x%X]) return printf("%d %d",p[x],i-p[x]),0;//找到循环节则输出开始循环的位置和周期
		else p[x]=i;return 0;//否则，继续处理
}
```

运行结果：

```cpp
55245 45699
```

然后就可以写出求解这个问题的代码了：

```cpp
class OverFlowPow19Solver//求解溢出情况下19^x
{
	private:
		#define A 55244//开始循环的位置
		#define B 45699//循环周期
		#define X 998244353//模数
		int a[A+B+5];
	public:
		I void Solve()
		{
			RI n,i;RL x;for(a[0]=i=1;i<=A+B;++i) a[i]=19*a[i-1]%X;//打表
			for(F.read(n);n;--n) F.read(x),F.writeln(a[x<=A?x:(x-A)%B+A]);//输出答案
		}
		#undef X
}OverFlow;
```

### Case 8~Case 10

看到功能编号变成了 `2`，说明接下来就不是求 $19^x$ 了。

首先，研究数据可得，`p` 为 Prime（素数），然后题目要求就是对一段区间内质数输出 $p$，合数输出 $.$。

判断大素数就可以用之前提到过的 $\texttt{MillerRabin}$，详见此博客：[初学MillerRabin素数测试](https://www.cnblogs.com/chenxiaoran666/p/MillerRabin.html)。

然后声明一下，这道题中我只用$2$和$3$来测试理论上来讲是不够严谨的，但错误概率小，依然过了。

而且主要是为了下一个部分分卡常需要。。。

代码如下：

```cpp
class MillerRabin//MillerRabin判素数板子
{
	private:
		I bool Check(CL x,CI p)
		{
			if(Qpow(p%x,x-1,x)^1) return false;
			RL k=x-1,t;W(!(k&1))
			{
				if((t=Qpow(p%x,k>>=1,x))^1&&t^(x-1)) return false;
				if(!(t^(x-1))) return true;
			}return true;
		}
	public:
		I bool IsPrime(CL x) 
		{
			return !(x^2)||!(x^3)||(x&1&&x%3&&Check(x,2)&&Check(x,3));
		}
}MR;
class PrimeSolver//判断一段区间内每个数是否为质数
{
	public:
		I void Solve()
		{
			RI n;RL i,l,r;for(F.read(n);n;--n,F.writec('\n'))
				for(F.read(l,r),i=l;i<=r;++i) F.writec(MR.IsPrime(i)?'p':'.');//输出
		}
}Prime;
```

### Case 11~Case 13

看到 `u`，以及输出为 $0,+,-$，便不难想到是求**莫比乌斯函数$\mu$**。

关于莫比乌斯函数的定义可以参考这篇博客：[初学莫比乌斯反演](https://www.cnblogs.com/chenxiaoran666/p/Mobius.html#莫比乌斯函数mu)。

观察可得，区间的左边界和右边界虽然值域高达 $10^{18}$，但是实际区间长度却很小。

则我们可以考虑先用[线性筛](https://www.cnblogs.com/chenxiaoran666/p/LineSieve.html)筛出 $10^6$ 以内所有质数及所有数的$\mu$值。

然后，对于小于等于 $10^6$ 的询问，直接输出筛到的 $\mu$。

否则，先把其所有小于等于 $10^6$ 的质因数全部除去，同时统计 $\mu$ 值。

然后，最后得到的这个数要么为 $1$，否则显然由**最多两个**大于 $10^6$ 的质数组成。

于是，进行以下操作：

- 用 $\texttt{MillerRabin}$ 判断其是否为质数，若是，将其先前统计的 $\mu$ 值乘上 $-1$ 然后输出。
- 否则，我们判断其是否为完全平方数，若是，则说明它是一个质数的平方，因此将其 $\mu$ 值改为 $0$。
- 否则，它由两个互不相同的质数组成，因此将其先前统计的 $\mu$ 值乘上 $(-1)*(-1)$，就相当于乘 $1$，无需任何操作。

然后注意卡常。

具体代码如下：

```cpp
class LineSiever//线性筛
{
	private:
		#define SZ 1000000
	public:
		int Pc,mu[SZ+5],P[SZ+5];
		I void Sieve(CI S)
		{
			for(RI i=(mu[1]=1,2),j;i<=S;++i)
				for(!P[i]&&(mu[P[++Pc]=i]=-1),j=1;j<=Pc&&1LL*i*P[j]<=S;++j)
					if(P[i*P[j]]=1,i%P[j]) mu[i*P[j]]=-mu[i];else break;
		}
}L;
class MuSolver//求一段区间内每个数的μ值
{
	private:
		#define S 1000000
		#define C(x) ((x)?(~(x)?'+':'-'):'0')
		int g[S+5];ull v[S+5];
	public:
		I void Solve()
		{
			RI n,i,j,lim,len;RU x,y,l,r;for(L.Sieve(S),F.read(n);n;--n)
			{
				if(F.read(l,r),l<=S)//对于筛过的数，直接输出μ值
				{
					for(i=l,lim=min(r,S);i<=lim;++i) F.writec(C(L.mu[i]));
					if(F.writec('\n'),r<=S) continue;l=S+1;
				}
				for(len=r-l+1,i=len;i;--i) g[i]=v[i]=1;//初始化
				for(i=L.Pc;i;--i) for(j=(l+L.P[i]-1)/L.P[i]*L.P[i]-l+1;j<=len;j+=L.P[i])//枚举质数及其倍数
					(l+j-1)/L.P[i]%L.P[i]?g[j]&&(g[j]*=-1,v[j]*=L.P[i]):(g[j]=0);//统计μ值
				for(i=1;i<=len;++i) g[i]&&(i+l-1)^v[i]&&(MR.IsPrime(x=(i+l-1)/v[i])?//如果不为1
					g[i]*=-1:(y=sqrt(x),y*y==x)&&(g[i]=0)),F.writec(C(g[i]));//为质数则将μ值乘-1，为完全平方数则将μ值变为0，然后输出
				F.writec('\n');
			}
		}
		#undef S
}Mu;
```

### Case 14

`g` 等于原根，这就相当于要我们求一段区间内每个数是否为给定质数的原根。

考虑原根定义：**一个数 $x$ 是质数 $p$ 的原根，当且仅当对于$\phi(p)$（即 $p-1$）的任意质因数 $q$，$x^{\frac{\phi(p)}q}\%p≠1$。**

发现这个点的模数全为 $998244353$，对此直接暴力分解 $998244352$，然后暴力判断即可：

```cpp
class GRSolver//判断一段区间内每个数是否为给定质数的原根
{
	private:
		#define S 100000
		int cnt,s[S+5];
		I void Init(CI x)//分解
		{
			RI i,t=x;for(cnt=0,i=1;1LL*L.P[i]*L.P[i]<=t;++i)
				if(!(t%L.P[i])) {s[++cnt]=L.P[i];W(!(t%L.P[i])) t/=L.P[i];}//存储质因数
			t^1&&(s[++cnt]=t);//存储质因数
		}
		I bool IsGR(CI x,CI X)//暴力判断
		{
			for(RI i=1;i<=cnt;++i) if(Qpow(x,(X-1)/s[i],X)==1) return false;
			return true;
		}
	public:
		I void Solve()
		{
			RI n,i,l,r,X;for(L.Sieve(S),F.read(n);n;--n)
				for(Init(X-1),i=l;i<=r;++i) F.writec(IsGR(i,X)?'g':'.');//暴力
		}
}GR;
```

### Case 15

这个点在原有模数基础上多了个 $13123111$。

然后暴力就跑不过了。。。

于是我们就要用一种特殊的方式来做。

首先，我们暴力找出其最小的一个原根（实际上任意一个原根都可以）。

接下来求出每个数以这个最小原根为原根的**指标**。

然后判断每个数的指标与 $\phi(X)$（即 $X-1$）是否互质即可判断这个数是否为原根。

但判互质这里需要一种类似于筛的东西。

考虑和上个点一样先求出$X-1$的全部质因数，然后把这些质因数的倍数全部打个标记。

最后指标没被打标记的就是原根。

与上一个点整合后的代码如下：

```cpp
class GRSolver//判断一段区间内每个数是否为给定质数的原根
{
	private:
		#define S 100000
		#define V 13123111
		int cnt,s[S+5],pos[V+5],vis[V+5];
		I void Init(CI x)//分解
		{
			RI i,t=x;for(cnt=0,i=1;1LL*L.P[i]*L.P[i]<=t;++i)
				if(!(t%L.P[i])) {s[++cnt]=L.P[i];W(!(t%L.P[i])) t/=L.P[i];}//存储质因数
			t^1&&(s[++cnt]=t);//存储质因数
		}
		I bool IsGR(CI x,CI X)//暴力判断
		{
			for(RI i=1;i<=cnt;++i) if(Qpow(x,(X-1)/s[i],X)==1) return false;
			return true;
		}
		I void Sieve(CI l,CI r,CI X)//筛
		{
			static int T=0;RI i,j,p,t;++T;//初始化
			for(t=1;!IsGR(t,X);++t);for(i=1,p=t;i^X;++i) pos[p]=i,p=1LL*p*t%X;//暴力找到一个最小的原根，然后求指标
			for(i=1;i<=cnt;++i) for(j=s[i];j<X;j+=s[i]) vis[j]=T;//打标记
			for(i=l;i<=r;++i) F.writec(vis[pos[i]]^T?'g':'.');//输出
		}
	public:
		I void Solve()
		{
			RI n,i,l,r,X;for(L.Sieve(S),F.read(n);n;--n)
			{
				if(X==998244353) for(Init(X-1),i=l;i<=r;++i) F.writec(IsGR(i,X)?'g':'.');//暴力
				else Init(X-1),Sieve(l,r,X);F.writec('\n');//筛
			}
		}
}GR;
```

### Case 16

`2g?`，又是一个要确定模数的，不过这次良心地给了模数的范围，只不过范围大小是 $10^9$。。。

考虑出题人会怎么卡你？肯定是把模数放在靠中间的位置。

因此，我们就从中间向两边枚举！

然后对于枚举到的数如何判断呢？

首先依然是 $\texttt{MillerRabin}$ 判素数。

接下来，我们只验证前 $50$ 个答案，如果这个数的 $\frac {x-1}2$ 次方为 $1$ 但是这一位应该是原根，就说明 $x$ 不是要求的模数。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define M 1500000000
#define S 50
using namespace std;
Con string s="...ggg..gg.g...g..gg..g.gg......gg..g......gg..gg.";
I int Qpow(RI x,RI y,CI X) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}
class MillerRabin//MillerRabin判素数板子
{
	private:
		#define Pcnt 12
		Con int P[Pcnt]={2,3,5,7,11,13,17,19,61,2333,4567,24251};
		I bool Check(CI x,CI p)
		{
			if(Qpow(p%x,x-1,x)^1) return false;
			RI k=x-1,t;W(!(k&1))
			{
				if((t=Qpow(p%x,k>>=1,x))^1&&t^(x-1)) return false;
				if(!(t^(x-1))) return true;
			}return true;
		}
	public:
		I bool IsPrime(CI x)
		{
			if(x<2) return false;
			for(RI i=0;i^Pcnt;++i) {if(!(x^P[i])) return true;if(!Check(x,P[i])) return false;}
			return true;
		}
}MR;
I bool Check(CI X)//验证前50个答案
{
	for(RI i=0;i^S;++i) if(Qpow(i+233333333,X-1>>1,X)==1&&s[i]^'.') return false;//产生冲突就返回false
	return true;//返回true
}
int main()
{
	for(RI i=1;;i+=2)//从中间向外枚
	{
		if(MR.IsPrime(M+i)&&Check(M+i)) return printf("%d",M+i),0;//先判质数，再验证
		if(MR.IsPrime(M-i)&&Check(M-i)) return printf("%d",M-i),0;//同上
	}return 0;
}
```

运行结果：

```cpp
1515343657
```

再与先前代码一整合，就可以得到这一部分的最终代码：

```cpp
class GRSolver//判断一段区间内每个数是否为给定质数的原根
{
	private:
		#define S 100000
		#define V 13123111
		int cnt,s[S+5],pos[V+5],vis[V+5];
		I void Init(CI x)//分解
		{
			RI i,t=x;for(cnt=0,i=1;1LL*L.P[i]*L.P[i]<=t;++i)
				if(!(t%L.P[i])) {s[++cnt]=L.P[i];W(!(t%L.P[i])) t/=L.P[i];}//存储质因数
			t^1&&(s[++cnt]=t);//存储质因数
		}
		I bool IsGR(CI x,CI X)//暴力判断
		{
			for(RI i=1;i<=cnt;++i) if(Qpow(x,(X-1)/s[i],X)==1) return false;
			return true;
		}
		I void Sieve(CI l,CI r,CI X)//筛
		{
			static int T=0;RI i,j,p,t;++T;//初始化
			for(t=1;!IsGR(t,X);++t);for(i=1,p=t;i^X;++i) pos[p]=i,p=1LL*p*t%X;//暴力找到一个最小的原根，然后求指标
			for(i=1;i<=cnt;++i) for(j=s[i];j<X;j+=s[i]) vis[j]=T;//打标记
			for(i=l;i<=r;++i) F.writec(vis[pos[i]]^T?'g':'.');//输出
		}
	public:
		I void Solve()
		{
			RI n,i,l,r,X;for(L.Sieve(S),F.read(n);n;--n)
			{
				if((!F.read(l,r,X)&&(X=1515343657))||(X==998244353))//对于?赋值为1515343657
					for(Init(X-1),i=l;i<=r;++i) F.writec(IsGR(i,X)?'g':'.');//暴力
				else Init(X-1),Sieve(l,r,X);F.writec('\n');//筛
			}
		}
}GR;
```

### 代码

最后放一下完整代码：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define RU Reg ull
#define Con const
#define CI Con int&
#define CL Con LL&
#define CU Con ull&
#define I inline
#define W while
#define LL long long
#define ull unsigned long long
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define Gmax(x,y) (x<(y)&&(x=(y)))
#define Gmin(x,y) (x>(y)&&(x=(y)))
using namespace std;
string op;
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I bool read(Ty& x) {x=0;W(!D) if(c=='?') return false;W(x=tn+(c&15),D);return true;}
		Tp I void write(Ty x) {x<0&&(pc('-'),x=-x);W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
		Ts I bool read(Ty& x,Ar&... y) {return read(x)&&read(y...);}
		Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
		Tp I void read_with_X(Ty& x,CL X) {x=0;W(!D);W(x=(tn%X+(c&15))%X,D);}
		I void reads(string& x) {x="";W(isspace(c=tc()));W(x+=c,!isspace(c=tc())&&~c);}
		I void writec(Con char& x) {pc(x);}
		I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
I void Qmul(LL& x,CL y,CL X) {RL k=(LL)((1.0L*x*y)/(1.0L*X)),t=x*y-k*X;t-=X;W(t<0) t+=X;x=t;}//快速乘
I LL Qpow(RL x,RL y,CL X) {RL t=1;W(y) y&1&&(Qmul(t,x,X),0),Qmul(x,x,X),y>>=1;return t;}//快速幂
class MillerRabin//MillerRabin判素数板子
{
	private:
		I bool Check(CL x,CI p)
		{
			if(Qpow(p%x,x-1,x)^1) return false;
			RL k=x-1,t;W(!(k&1))
			{
				if((t=Qpow(p%x,k>>=1,x))^1&&t^(x-1)) return false;
				if(!(t^(x-1))) return true;
			}return true;
		}
	public:
		I bool IsPrime(CL x) 
		{
			return !(x^2)||!(x^3)||(x&1&&x%3&&Check(x,2)&&Check(x,3));
		}
}MR;
class LineSiever//线性筛
{
	private:
		#define SZ 1000000
	public:
		int Pc,mu[SZ+5],P[SZ+5];
		I void Sieve(CI S)
		{
			for(RI i=(mu[1]=1,2),j;i<=S;++i)
				for(!P[i]&&(mu[P[++Pc]=i]=-1),j=1;j<=Pc&&1LL*i*P[j]<=S;++j)
					if(P[i*P[j]]=1,i%P[j]) mu[i*P[j]]=-mu[i];else break;
		}
}L;
class CommonPow19Solver//求解19^x
{
	public:
		I void Solve(CL X)//求解答案，X为模数
		{
			RI n;RL x;for(F.read(n);n;--n)
				F.read_with_X(x,X-1),F.writeln(Qpow(19,x,X));//读入时向X-1取模，然后快速幂
		}
}Common;
class OverFlowPow19Solver//求解溢出情况下19^x
{
	private:
		#define A 55244//开始循环的位置
		#define B 45699//循环周期
		#define X 998244353//模数
		int a[A+B+5];
	public:
		I void Solve()
		{
			RI n,i;RL x;for(a[0]=i=1;i<=A+B;++i) a[i]=19*a[i-1]%X;//打表
			for(F.read(n);n;--n) F.read(x),F.writeln(a[x<=A?x:(x-A)%B+A]);//输出答案
		}
		#undef X
}OverFlow;
class PrimeSolver//判断一段区间内每个数是否为质数
{
	public:
		I void Solve()
		{
			RI n;RL i,l,r;for(F.read(n);n;--n,F.writec('\n'))
				for(F.read(l,r),i=l;i<=r;++i) F.writec(MR.IsPrime(i)?'p':'.');//输出
		}
}Prime;
class MuSolver//求一段区间内每个数的μ值
{
	private:
		#define S 1000000
		#define C(x) ((x)?(~(x)?'+':'-'):'0')
		int g[S+5];ull v[S+5];
	public:
		I void Solve()
		{
			RI n,i,j,lim,len;RU x,y,l,r;for(L.Sieve(S),F.read(n);n;--n)
			{
				if(F.read(l,r),l<=S)//对于筛过的数，直接输出μ值
				{
					for(i=l,lim=min(r,S);i<=lim;++i) F.writec(C(L.mu[i]));
					if(F.writec('\n'),r<=S) continue;l=S+1;
				}
				for(len=r-l+1,i=len;i;--i) g[i]=v[i]=1;//初始化
				for(i=L.Pc;i;--i) for(j=(l+L.P[i]-1)/L.P[i]*L.P[i]-l+1;j<=len;j+=L.P[i])//枚举质数及其倍数
					(l+j-1)/L.P[i]%L.P[i]?g[j]&&(g[j]*=-1,v[j]*=L.P[i]):(g[j]=0);//统计μ值
				for(i=1;i<=len;++i) g[i]&&(i+l-1)^v[i]&&(MR.IsPrime(x=(i+l-1)/v[i])?//如果不为1
					g[i]*=-1:(y=sqrt(x),y*y==x)&&(g[i]=0)),F.writec(C(g[i]));//为质数则将μ值乘-1，为完全平方数则将μ值变为0，然后输出
				F.writec('\n');
			}
		}
		#undef S
}Mu;
class GRSolver//判断一段区间内每个数是否为给定质数的原根
{
	private:
		#define S 100000
		#define V 13123111
		int cnt,s[S+5],pos[V+5],vis[V+5];
		I void Init(CI x)//分解
		{
			RI i,t=x;for(cnt=0,i=1;1LL*L.P[i]*L.P[i]<=t;++i)
				if(!(t%L.P[i])) {s[++cnt]=L.P[i];W(!(t%L.P[i])) t/=L.P[i];}//存储质因数
			t^1&&(s[++cnt]=t);//存储质因数
		}
		I bool IsGR(CI x,CI X)//暴力判断
		{
			for(RI i=1;i<=cnt;++i) if(Qpow(x,(X-1)/s[i],X)==1) return false;
			return true;
		}
		I void Sieve(CI l,CI r,CI X)//筛
		{
			static int T=0;RI i,j,p,t;++T;//初始化
			for(t=1;!IsGR(t,X);++t);for(i=1,p=t;i^X;++i) pos[p]=i,p=1LL*p*t%X;//暴力找到一个最小的原根，然后求指标
			for(i=1;i<=cnt;++i) for(j=s[i];j<X;j+=s[i]) vis[j]=T;//打标记
			for(i=l;i<=r;++i) F.writec(vis[pos[i]]^T?'g':'.');//输出
		}
	public:
		I void Solve()
		{
			RI n,i,l,r,X;for(L.Sieve(S),F.read(n);n;--n)
			{
				if((!F.read(l,r,X)&&(X=1515343657))||(X==998244353))//对于?赋值为1515343657
					for(Init(X-1),i=l;i<=r;++i) F.writec(IsGR(i,X)?'g':'.');//暴力
				else Init(X-1),Sieve(l,r,X);F.writec('\n');//筛
			}
		}
}GR;
int main()
{
	if(F.reads(op),op=="1_998244353") Common.Solve(998244353);
	else if(op=="1?") Common.Solve(1145141);
	else if(op=="1?+") Common.Solve(5211600617818708273);
	else if(op=="1wa_998244353") OverFlow.Solve();
	else if(op=="2p") Prime.Solve();else if(op=="2u") Mu.Solve();else GR.Solve();
	return F.clear(),0;
}
```

---

## 作者：Acetyl (赞：64)

本人是今天参加省选的蒟蒻，几小时前刚做这题（当然没拿多少分），听完讲题后才明白怎么做。

~~就是个找规律啦~~

不过当时我在考场上并没有找到规律，所以便想了一个歪点子，便在这里讲一下，也可以做一个参考。

这就是，压缩。

考场上我看到数据的时候，发现某些数据中只有'p'和'.'这两个字符，而且'p'这个字符还是极少的，大多数就是'.'，于是就想怎么压缩了。

花了几分钟的时间，我想到了一个压缩方案，就是把连续的'.'的个数记录下来，然后当做一个字符写到字符串里（比如，'\5'的ASCII码是5，代表两个p中间夹着5个'.'）

但是，我发现，有时候'.'的数量不止256个，这时就没法压缩到单个字节了。根据我的经验，我想到了这样的压缩方法：如果这个数大于128，则将其模128然后加128后对应字符放进字符串，否则直接将这个数所对应的字符放进字符串。然后就对一些只有'p'和'.'的数据进行了压缩，发现第9个点和第10个点的输出字符串没有超过长度限制（但是不能两个都放进去，加起来就超过限制了），又因为第10个点的分数多一些，于是就把第10个点写了进去。

当然，本蒟蒻最后成功了。

不过这也不是什么好方法，建议大家还是老老实实静下心来找找规律吧。

程序就不给出了。

---

## 作者：WB_TS_欧寒 (赞：39)

# <1>题目分析
		他改变了传统题

本题极大地考察了和出题人心意相通的能力，它或许不能在茫茫人海中选出水平最高的选手，但一定能选出最适合当出题人 npy 的选手。

首先，出题人表示 “两个编号越相似，说明对应的两个功能的算法越接近。”。

那么 HOW TO 定义 “编号相似”？

我还觉得 1? 和 2p 字符串长度都是 2 所以比较相似呢！

无语了。

## 测试点 1,2,3
观察测试点 1 前几项，发现是 19n。对什么数取模呢？

是的你没猜错，就是 998244353！

至于输入的数字巨大，就要用欧拉定理降幂了。

## 测试点 4
没有给出模数，那就从输出里能找到的最大数字开始，暴力枚举模数咯，得到模数是 1145141（woc，恶臭模数）。

## 测试点 5
这个测试点就无法暴力枚举模数了，然后观察数据，发现数据里有这么两组：

第 7143 行，输入 264708066，输出 1996649514996338529。

第 9368 行，输入 264708068，输出 1589589654696467295。

得到 1996649514996338529*19 mod P =1589589654696467295。

然后将 1996649514996338529*19-1589589654696467295 用 “待会儿反正用得着现在先写一个的 Pollard rho” 分解质因数（或者手动枚举较小质因数，用 python 计算，较小质因数里最大的是 23），得到最大的质因子 5211600617818708273，代入发现它的确是模数。

## 测试点 6,7
毫无意义的一个点，既然是 WA，那就是快速幂写错了，咋写错的？来，又到了考察你和出题人心意相通的时间了。写快速幂的时候乘法没有强制转 long long？写快速幂的时候有个地方忘记取模？正确答案是——

暴力一个个乘的时候取模没强制转 long long！

惊不惊喜？意不意外？刺不刺激？

接下来你写一个这样的代码，找到循环节：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
const int mod=998244353;
map<int,int> mp;
int main()
{
    int x=1;mp[1]=0;
    for(RI i=1;;++i)
    {
        x=x*19%mod;
        if(mp.count(x))
        {
  		cout<<mp[x]<<"  "<<i<<endl;
  		break;
    	 }
         else mp[x]=i;
    }
    return 0;
}
```
就可以了。

## 测试点 8,9,10

2p？这是什么意思？

打开输入文件，每行两个数，第一个数要么是 2 要么是 5，第二个数则相对较大，而且是前一个数的倍数……

2 和 5，都是质数……

打开输出文件，若第一个数是 5，则输出 5 个数，否则输出第二个数字-1 个数……

每行只有 p 和.，这是什么……难道是像南蛮图腾那道题一样，要画图形吗？

而 2g 类的点，输出只有 g 和.，也就是说，编码给你什么字母，你输出就要画什么字母吗？

那为什么 2u 类的点输出是+，-，或者. 呢？

这个. 有什么特殊的含义吗？

你分析了这么一大堆，一个小时已经过去了，你无奈地打开了题解，发现你前面分析的那一大堆屁用没有，这个点是输出判断 l 到 r 的每个数是不是质数（p=prime）

你会唾骂出题人，然后怀着愤恨的心情写 Miller Rabin。

## 测试点 11,12,13
上一组测试点，p=prime。你若大致理解了一点出题人的脑回路后，你就能猜到——

u=μ
这个点还算有点技巧性，首先筛出 106106内的所有质数，用 lnln级的时间求出它们对区间内数的贡献，并且将它们的倍数都除以它们。接下来再扫一遍区间里的所有数，它们的剩余值，要么是个质数（用 Miller Rabin 判断），要么是两个大于 106的质数的乘积（相同或者不同的，用 sqrt 开根检验即可）

## 测试点 14
g=原根。

暴力检验即可。

## 测试点 15
求一个数的所有原根。

先找出它的其中一个原根（譬如说，6）

然后找出所有数关于该原根的指标（即 6d≡x(modP)，则称 d是 x的指标）

指标与 ϕ(P)互质的，都是 P的原根。

用 ϕ(P)的质因子将这些数都筛出来即可。

## 测试点 16
给了模数的范围，将所有范围内质数筛出，暴力检验前 15 个数字符不符合，得到模数等于 1515343657。

# <2>Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define RI register int
typedef unsigned long long uLL;
typedef long long LL;
char typ[50];
namespace work1
{
	uLL mul(uLL x,uLL y,uLL mod)
	{
		if(x<1e9 && y<1e9) return x*y%mod;
		uLL re=0;
		for(; y; y>>=1,x=(x+x)%mod) if(y&1) re=(re+x)%mod;
		return re;
	}
	void work(uLL mod)
	{
		char S[50];
		int len,T;
		cin>>T;
		while(T--)
		{
			scanf("%s",S+1),len=strlen(S+1);
			uLL y=0,re=1,x=19;
			for(RI i=1; i<=len;
			        ++i) y=(mul(10uLL,y,mod-1)+(uLL)(S[i]-'0'))%(mod-1);
			for(; y; y>>=1,x=mul(x,x,mod)) if(y & 1) re=mul(re,x,mod);
			printf("%llu\n",re);
		}
	}
};
namespace work2
{
	const int mod=998244353;
	int a[100950],T;
	void work()
	{
		a[0]=1;
		for(RI i=1; i<=100944; ++i) a[i]=a[i-1]*19%mod;
		cin>>T;
		while(T--)
		{
			uLL x;
			scanf("%llu",&x);
			if(x<=100944LL) cout<<a[x]<<endl;
			else cout<<a[(x-55245)%45699+55245]<<endl;
		}
	}
};
LL qmul(LL x,LL y,LL p)
{
	if(x<=2e9 && y<=2e9) return 1LL*x*y%p;
	return (x*y-(LL)((long double)x/p*y+0.5)*p+p)%p;
}
LL qpow(LL x,LL y,LL p)
{
	LL re=1;
	for(; y; y>>=1,x=qmul(x,x,p)) if(y&1) re=qmul(re,x,p);
	return re;
}
int Miller_Rabin(LL n,int lim_kas)
{
	if(n==2 || n==3 || n==5 || n==7 || n==11 || n==13) return 1;
	if(n%2==0 || n%3==0 || n%5==0 || n%7==0 || n%9==0 || n%11==0 || n%13==0) return 0;
	LL k=n-1,t=0;
	while(!(k&1))
	{
		t++;
		k>>=1;
	}
	for(RI kas=1; kas<=lim_kas; ++kas)
	{
		LL x=qpow(rand()%(n-2)+2,k,n),y;
		for(LL i=1; i<=t; ++i)
		{
			y=x;
			x=qmul(x,x,n);
			if(x==1 && y!=1 && y!=n-1) return 0;
		}
		if(x!=1) return 0;
	}
	return 1;
}
namespace work3
{
	void work()
	{
		LL l,r;
		int T;
		cin>>T;
		cin>>l>>r,puts("pp.p.p...");
		cin>>l>>r,puts("p.p...");
		cin>>l>>r,puts("pp.p.p...p.p..");
		cin>>l>>r;
		for(LL i=l; i<=r; ++i) putchar(Miller_Rabin(i,10)?'p':'.');
		puts("");
	}
};
namespace work4
{
	int tot,pri[1000005],is[1000005],mu[1000005];
	LL x[1000005];
	void work()
	{
		LL l,r;
		int T;
		cin>>T;
		cin>>l>>r,puts("--0-+-00+");
		cin>>l>>r,puts("-+-00+");
		cin>>l>>r,puts("--0-+-00+-0-++");
		cin>>l>>r;
		for(RI i=2; i<=1000000; ++i)
		{
			if(!is[i]) pri[++tot]=i;
			for(RI j=1; j<=tot && pri[j]*i<=1000000; ++j)
			{
				is[pri[j]*i]=1;
				if(i%pri[j]==0) break;
			}
		}
		for(LL i=1; i<=r-l+1; ++i) mu[i]=1,x[i]=l+i-1;
		for(RI i=1; i<=tot; ++i)
		{
			LL tmp=1LL*pri[i]*((l-1)/pri[i]+1);
			for(LL j=tmp; j<=r; j+=pri[i])
			{
				if(!mu[j-l+1]) continue;
				mu[j-l+1]=-mu[j-l+1],x[j-l+1]/=pri[i];
				if(x[j-l+1]%pri[i]==0) mu[j-l+1]=0;
			}
		}
		for(LL i=l; i<=r; ++i)
		{
			if(x[i-l+1]!=1)
			{
				if(Miller_Rabin(x[i-l+1],2)) mu[i-l+1]=-mu[i-l+1];
				else
				{
					LL tmp=sqrt((double)x[i-l+1]);
					if(tmp*tmp==x[i-l+1]) mu[i-l+1]=0;
				}
			}
			putchar(mu[i-l+1]==0?'0':(mu[i-l+1]==-1?'-':'+'));
		}
		puts("");
	}
};
namespace work5
{
	int pri[10],tot;
	bool is[13123120],isg[13123120];
	void QAQ1(int l,int r,int P)
	{
		if(P==998244353) tot=3,pri[1]=2,pri[2]=7,pri[3]=17;
		else tot=4,pri[1]=2,pri[2]=3,pri[3]=4003,pri[4]=15773;
		for(RI i=l; i<=r; ++i)
		{
			int flag=1;
			if(qpow(i,P-1,P)!=1) flag=0;
			else
			{
				for(RI j=1; j<=tot; ++j)
					if(qpow(i,(P-1)/pri[j],P)==1)
					{
						flag=0;
						break;
					}
			}
			putchar(flag?'g':'.');
		}
		puts("");
	}
	void QAQ2()
	{
		const int g=6;
		tot=8,pri[1]=2,pri[2]=3,pri[3]=5;
		pri[4]=7,pri[5]=11,pri[6]=13,pri[7]=19,pri[8]=23;
		for(RI i=1; i<=tot; ++i)
			for(RI j=pri[i]; j<=13123110; j+=pri[i]) is[j]=1;
		for(RI i=1,g=6; i<=13123110;
		        ++i,g=6LL*g%13123111) if(!is[i]) isg[g]=1;
		for(RI i=1; i<=13123110; ++i) putchar(isg[i]?'g':'.');
	}
	void work()
	{
		int l,r,P,T;
		cin>>T;
		cin>>l>>r>>P,puts(".g");
		cin>>l>>r>>P,puts(".g.gg...g");
		if(T==4)
		{
			cin>>l>>r>>P,QAQ1(l,r,P);
			cin>>l>>r>>P,QAQ1(l,r,P);
		}
		else
		{
			cin>>l>>r;
			if(l==1) QAQ2();
			else QAQ1(l,r,1515343657);
		}
	}
};
int main()
{
	srand(19260817);
	scanf("%s",typ);
	if(!strcmp(typ,"1_998244353")) work1::work(998244353LL);
	else if(!strcmp(typ,"1?")) work1::work(1145141LL);
	else if(!strcmp(typ,"1?+")) work1::work(5211600617818708273LL);
	else if(!strcmp(typ,"1wa_998244353")) work2::work();
	else if(!strcmp(typ,"2p")) work3::work();
	else if(!strcmp(typ,"2u")) work4::work();
	else work5::work();
	return 0;
}
```


---

## 作者：da32s1da (赞：18)

这里主要讲一下第$5$个点的膜数是怎么来的。

首先去$5.ans$里找到答案的最大值$5211500658258874318$，先确定一个大体的范围。

然后根据$5.in$，找到两个相邻最近的输入（0-9不算），到$5.ans$里找到它们的答案。
```
264708066 1996649514996338529
264708068 1589589654696467295
```
所以膜数就是$1996649514996338529\times 19^2-1589589654696467295\ $也就是$719200885258981741674$的某个约数，且要大于我们找到的最大值$5211500658258874318$。

考虑到$7e20/5e18$在$100$到$200$左右，也就是只要枚举$100$到$200$内的约数，发现只有$138$，所以膜数是$\frac{719200885258981741674}{138}=5211600617818708273$。

~~我考场也这么做的为啥没求出来，回来一下子就求出来了~~

---

## 作者：BJpers2 (赞：9)

这道题完全颠覆了我对传统题的认知，不如说是“反向提交答案”要准确一些。肝了一个下午加一个晚上才终于搞定。

------------
## $data \quad1\sim3:$
	
  观察发现是给一些数$x$，求$19^x \bmod {998244353}$。
  
  直接快速幂即可，注意$data3$中$x$是long long范围，需要用防爆乘，这里推荐使用O(1)防爆乘。
  ```cpp
ll mul(ll x,ll y,ll P){return (x*y-(ll)((long double)x/P*y)*P+P)%P;}
```
  
## $data \quad4\sim5:$

模数未知，求$19^x \bmod {P}$。

想办法将$P$预先找出，基本思路是找两个数$a$、$b$，有$19^x\equiv a,19^y\equiv b$，且$x<y$,但$a>b$。这样两式相减，有$19^{y-x}a-b=kP,k\in \mathbf{Z}$。

这样就能把$P$锁定在某个数的约数中，再根据$P$大于答案文件中最大的数来限定范围，枚举量就很小了。

$P_4=1145141 \quad P_5=5211600617818708273$

## $data \quad6\sim7:$

求$19^x \bmod {P}$，但这是在$int$溢出情况下完成的，具体的生成方式是

```
int x=1,P=998244353;
for(int i=1;i<=n;i++) x=19*x%P,cout<<x<<'\n';
```
显然暴力是不能搞$data7$的。但我们知道只要有一个数被我们输出过，就一定会形成周期。类似于一个$\rho$的形式。所以用map把环强行搞出来就，之后就直接模环长输出对应位，根据“生日悖论”，我们的周期不会很长（实际不超过$1e6$）。


## $data \quad8\sim10:$
输出$r-l+1$个数对应$[l,r]$中每个数的性质，质数输出“$p$”，否则输出“$.$”。

直接大力$\mathrm{Miller-Rabin}$即可过，用前五个素数作底就好，注意先粗筛一波前$10$个素数剪枝。

~~我不会告诉你我一直用十个素数卡了一个多小时常，一改成五个就过了~~。

## $data \quad11\sim13:$
输出$r-l+1$个数对应$[l,r]$中每个数的性质，$\mu(x)=0,1,-1$时分别输“$0$”，“$+$”，“$-$”。

我们考虑先筛出$1e7$以内的质数（之前筛$1e6$的素数一直卡不过去），然后枚举这些质数在$[l,r]$中的倍数，求出$c[x]$表示$x$除去在$[1,1e7]$中的质因子后剩下的数。并同时弄出一个只考虑$[1,1e7]$中的质因子的$\mu$数组。

假如$c[x]$是质数，那么$\mu(x)$取相反数。

否则，$c[x]$必为两$1e7$以上的素数的乘积。在此基础上，若$x$为完全平方数，则$\mu(x)=0$；否则因为两个质因数不同，两个$-1$会抵消所以不用管。

我按照这个思路一直卡在$2.3$秒，后来看了某大神的代码学到了两个至关重要的剪枝。

鉴于主要时间耗在$\mathrm{Miller-Rabin}$上，我们考虑减少不必的判断。

**剪枝一**：如果$\mu(x)$已经是$0$，那么$c[x]$是不是质数已经无所谓了。

**剪枝二**：一切$\leq 1e14$的$c[x]$一定是素数，不用再判。因为之前说了两个数乘起来的情况肯定是两个数都大于$1e7$的，矛盾。这就是多筛质数可以加速的原因。

## $data \quad14\sim16:$
求区间$[l,r]$哪些是$P$的原根，是输出“$g$”，不是输出“$.$”。

满足$P\leq2e9$，$r-l+1\leq2e7$，但当$r-l+1 > 1e6$时有$P\leq 2e7$。

- 当$P$比较大，区间会比较小，直接对所有$x\in[l,r]$判断即可。我们有定理：

	$x$不是原根$\Longleftrightarrow\exists y|P-1 $且$x^{(P-1)/y} \equiv1\bmod P$
    
- 当$P$比较小，我们可以预处理所有不是原根的，然后$O(1)$判断。先随便找出一个原根$g$，那么能表示成$g^x,\gcd(x,P-1)\not=1$的$g^x$都是不合法的。因为假设$\gcd(x,P-1)=d,x=dt$我们有$g^{x(P-1)/d}\equiv (g^{P-1})^{t}\equiv1$。

至于$data16$，我们可以搞出所有$1e9\sim2e9$的质数一个一个试，只要拿前面少数几个($15$个就够了)，岂可锁定$P_{16}=1515343657$。



------------

因为没有打表，只写了$3.9K$就没了。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<map>
#define FOR(i,a,b) for(register int i(a);i<=b;++i)
using namespace std;
typedef unsigned long long ll;
const int N=10001000;
char ques[100];
int tot,pr[N],fi[N],mu[N];
bool ck[N];
ll mul(ll x,ll y,ll P){return (x*y-(ll)((long double)x/P*y)*P+P)%P;}
ll f2(int x){return 1ll*x*x;}
ll qpw(ll x,ll y,ll P)
{ll z=1;for(;y;y>>=1,x=mul(x,x,P))if(y&1) z=mul(z,x,P);return z;}
bool M_R(ll x,int t){
	if(x<=4e6) return !ck[x];
	FOR(i,1,30) if(x%pr[i]==0) return 0;
	FOR(i,1,t){
		ll y=pr[i];
		if(qpw(y,x-1,x)!=1) return 0;
		ll v(x-1),t(1);
		while(t==1 && ~v&1){
			t=qpw(y,v>>=1,x);
			if(t!=1 && t!=x-1) return 0;
		}
	}return 1;
}//超快miller_rabin
void ini(int n){
	FOR(i,2,n){
		if(!ck[i]) pr[++tot]=i;
		FOR(j,1,tot){
			if(i*pr[j]>n) break;
			ck[i*pr[j]]=1;
			if(i%pr[j]==0) break;
		}
	}
}
namespace data_1234{
	int n,m;ll x;
	char s[100];
	void solve(ll P){
		scanf("%d",&n);
		FOR(i,1,n){
			scanf("%s",s+1);
			m=strlen(s+1);x=0;
			FOR(i,1,m) x=(10ll*x%(P-1)+s[i]-'0')%(P-1);
			printf("%lld\n",qpw(19,x,P));
		}
	}
}
namespace data_5{
	int n;ll x,P=5211600617818708273ll;
	void solve(){
		scanf("%d",&n);
		FOR(i,1,n){
			scanf("%lld",&x);
			printf("%lld\n",qpw(19,x,P));
		}
	}
}//求19^x
namespace data_67{
	int n,x,a[N],P=998244353,st;ll y,S;
	map<int,int>s;
	void solve(){
		a[0]=x=1;s[1]=0;
		FOR(i,1,P){
			x=19*x%P;
			if(s.find(x)!=s.end()) {st=s[x];S=i-s[x];break;}
			s[a[i]=x]=i;
		}
		scanf("%d",&n);
		FOR(i,1,n){
			scanf("%lld",&y);
			if(y<st) printf("%d\n",a[y]);
			else printf("%d\n",a[(y-st)%S+st]);
		}
	}
}//带溢出19^x
namespace data_8910{
	int n;ll l,r;
	char s[N];
	void solve(){
		scanf("%d",&n);
		FOR(i,1,n){
			scanf("%lld%lld",&l,&r);
			for(ll j=l;j<=r;j++)
				putchar(M_R(j,5)?'p':'.');
			puts("");
		}
	}
}//筛质数（实际上是暴力判断的）
namespace data_111213{
	int n,t;ll l,r,x,L,R,p;
	int u[N];ll c[N];
	char tra(int x){return x==0?'0':(x>0?'+':'-');}
	void solve(){
		scanf("%d",&n);
		while(n--){
			scanf("%lld%lld",&l,&r);
			FOR(j,1,r-l+1) u[j]=1,c[j]=j+l-1;
			FOR(j,1,tot){
				x=pr[j];
				for(ll p=x*((l-1)/x+1)-l+1;p<=r-l+1;p+=x){
					if(c[p]%(x*x)==0) u[p]=0;
					else u[p]=-u[p],c[p]/=x;
				}
			}
			//FOR(j,1,r-l+1) cout<<u[j]<<' ';cout<<'\n';
			FOR(j,1,r-l+1){
				x=c[j];
				//if(j%100000==0) cerr<<j<<"\n";
				if(u[j] && x>1){
					ll y=sqrt(x);
					if(y*y==x) u[j]=0;
					else if(x<=1e14 || M_R(x,1)) u[j]=-u[j];
				}
				if(u[j]) putchar(~u[j]?'+':'-');
				else putchar('0');
			}
			puts("");
		}
	}
}//筛mobius函数
namespace data_141516{
	int n,l,r,P,x,cnt,p[N],lg[N<<1];
	bool vi[N<<1];
	void div(int x){
		for(int i=2;i*i<=x;i++)if(x%i==0){
			while(x%i==0) x/=i;
			p[++cnt]=i;
		}if(x) p[++cnt]=x;
	}
	int qpw0(int x,int y){
		int z=1;
		for(;y;y>>=1,x=1ll*x*x%P)if(y&1) z=1ll*z*x%P;
		return z;
	}
	bool isg(int x){
		FOR(i,1,cnt) if(qpw0(x,(P-1)/p[i])==1) return false;
		return true;
	}
	void solve(){
		scanf("%d",&n);
		while(n--){
			cnt=0;
			scanf("%d%d",&l,&r);
			if(r==234133333) P=1515343657;
			else scanf("%d",&P);div(P-1);
			//FOR(i,1,cnt) cerr<<p[i]<<' ';cerr<<'\n'; 
			if(r-l+1<=1e6)
				FOR(i,l,r) putchar(isg(i)?'g':'.');
			else{
				FOR(i,1,cnt)FOR(j,1,(P-1)/p[i]) vi[p[i]*j]=1;
				for(x=2;;x++) if(isg(x)) break;
				for(int i=1,w=x;i<P;w=1ll*w*x%P,i++) lg[w]=i;
				FOR(i,l,r) putchar(vi[lg[i]]?'.':'g');
			}
			puts("");
		}
	}
}//找原根
int main(){
	//freopen("software7.in","r",stdin);
	//freopen("software.out","w",stdout);
	scanf("%s",ques);
	ini(10000000);
	if(ques[0]=='1' && ques[2]=='9') data_1234::solve(998244353);
	if(ques[0]=='1' && ques[2]== 0 ) data_1234::solve(1145141);
	if(ques[0]=='1' && ques[2]=='+') data_5::solve();
	if(ques[0]=='1' && ques[2]=='a') data_67::solve();
	if(ques[0]=='2' && ques[1]=='p') data_8910::solve();
	if(ques[0]=='2' && ques[1]=='u') data_111213::solve();
	if(ques[0]=='2' && ques[1]=='g') data_141516::solve();
}
```




---

## 作者：Gauss0320 (赞：6)

笔者写这篇题解主要有以下原因

- 第一篇题解给的模数有误

- 许多题解对原根及其性质讲解不清，容易给学习者以误导或使其感到迷惑.

---

## Case 1~Case 3

由功能编号和数据不难看出题目要求 $19^x$ 对 $998244353$ 取模的值.

当 $x$ 较小时，线性乘；

当 $x$ 较大但还在 ``long long`` 范围以内时，使用快速幂；

当 $x$ 特别大以至于任何数据类型都存不下时，用快速读入加欧拉定理.

## Case 4

把 ``software4.ans`` 打开，输出其中最大的数.

发现它跟一个很臭的数很像！

在这个数后面分别添加 $1,3,7,9$，判断其是否为质数且符合题目要求......

最终发现题目要求 $19^x$ 对 $1145141$ 取模的值.

## Case 5

把 ``software5.in`` 和 ``software5.ans`` 都打开，并按照指数从小到大排序.

假设我们已经知道 $a\equiv 19^x\pmod{p},b\equiv 19^y\pmod{p},c\equiv 19^{x-y}\pmod{p}(x>y)$.

由于 $19^{x}-19^y-19^{x-y}(19^y-1)\equiv 0\pmod{p}$，故有 $p|(a-b-c(b-1))$.

将所有合法的 $a,b,c$ 三元组找出，求 $a-b-c(b-1)$ 的 gcd 即可.

## Case 6~7

由功能编号，数据和 Hint 可综合判断出，题目要求的是 $19^x$ 边乘边模 $998244353$ 边爆 ``int`` 的值.

当 $x$ 较小时，可以模拟自然溢出；

当 $x$ 较大时，寻找循环节并用 hash 表存储即可.

## Case 8~10

由数据和功能编号可以判断出，题目要求询问一个区间中的每个数是否为质数.

当区间的右端点较小时，可以用欧拉筛；

否则上 Miller_Rabin，实测基数仅需选取 $2$ 和 $3$.

## Case 11~13

由数据和功能编号可以判断出，题目要求询问一个区间中的每个数的 Mobius 函数值.

首先可以考虑将 $\sqrt{r}$ 以内的质数筛出来，再贡献到它们在给定区间中的倍数.

但是注意到 $r$ 在 Case 13 中达到了 $10^{18}$，所以要考虑优化.

实际上，如果我们仅筛出 $10^7$ 内的质数，再用上述方法，最终只会有两万多个数答案有误，这个完全可以打表打出来.

或者，分别考虑每个数被除以后是否为完全平方数、质数异或是两个不同的质数之乘积，判断质数仍然用 Miller_Rabin 算法.

这里有几个卡常技巧：

1. 用质数除它们的倍数的时候不要直接除，而是将每个数的所有质因子乘起来，最后一起除.

2. Miller_Rabin 选取两个基数还是太慢了，找1个合适的基数即可.

## Case 14~16

有数据和功能编号可以判断出，题目要求询问一个区间中的每一个数是否为给定质数的原根.

这里补充原根的定义及一些对题目有用的性质.

下文提到的 $a,n$ 均满足 $(a,n)=1,a\ne 0,n>0$.

### 阶

称 $a^x\equiv 1\pmod{n}$ 的最小正整数解为 $a$ 模 $n$ 的阶，记为 $\text{ord}_n a$.

### 性质1.1

$a^x\equiv 1\pmod{n}$ 当且仅当 $\text{ord}_n a|x$.

推论：$\text{ord}_na|\varphi(n)$.

证明略.

### 性质1.2

$a^i\equiv a^j\pmod{n}$ 当且仅当 $i\equiv j\pmod{\text{ord}_n a}$.

证明略.

### 原根

若 $\text{ord}_na=\varphi(n)$，则称 $a$ 为 $n$ 的一个原根.

### 性质2.1

若 $r$ 为 $n$ 的一个原根，则 $r^1,r^2,\cdots,r^{\varphi(n)}$ 两两模 $n$ 不同余且与 $n$ 互质.

证明：

先证两两模 $n$ 不同余，若 $r^i\equiv r^j\pmod{n},1\le i,j\le \varphi(n)$，则 $i\equiv j\pmod{\text{ord}_n r}$，因为 $r$ 是 $n$ 的原根，所以 $\text{ord}_nr=\varphi(n)$，即 $i\equiv j\pmod{\varphi(n)}$，从而 $i=j$，即证 $r^i$ 两两模 $n$ 不同余.

而由 $(r,n)=1$ 立即得到 $(r^i,n)=1$.

证毕.

### 性质2.2

若 $\text{ord}_na=t$，则 $\text{ord}_n(a^u)=t/(t,u)$.

证明：

设 $s=\text{ord}_n(a^u)$；

再设 $v=(t,u),t=t_1v,u=u_1v$，则有 $(t_1,u_1)=1$；

一方面，$\displaystyle(a^u)^{t_1}=(a^t)^{u_1}\equiv 1\pmod{n}$，故 $s|t_1$；

另一方面，$(a^u)^s=a^{us}\equiv 1\pmod{n}$，故 $t|us$，即 $t_1|v_1s$，考虑到 $(t_1,v_1)=1$，从而 $t_1|s$.

综上，$s=t_1=t/(t,u)$，证毕.

推论：若 $a$ 是 $n$ 的原根，则 $a^x$ 是 $n$ 的原根当且仅当 $(x,\varphi(n))=1$.

于是我们得到了一个解决本题的方法：

从输出中找出 $p$ 一个原根 $g$.

由于所有与 $p$ 互质的数都可以表示为 $g^x$，所以我们将 $x$ 从 $1$ 到 $p-1$ 扫一遍，将区间中的数标记出来，没被标记到的数必定不是 $p$ 的原根.

再求出 $p-1$ 的所有质因子，筛出这些质数的倍数，没有被筛去的指数 $x$ 所对应的 $g^x$ 即为 $n$ 的原根.

对于最后一个点，按照提示枚举质数，找到符合数据的即可.

## Code

不长，就 6.6k.

```cpp
/*
#pragma GCC optimize("Ofast")
#pragma GCC target("sse3","sse2","sse")
#pragma GCC diagnostic error "-fwhole-program"
#pragma GCC diagnostic error "-fcse-skip-blocks"
#pragma GCC diagnostic error "-funsafe-loop-optimizations"
#pragma GCC optimize("fast-math","unroll-loops","no-stack-protector","inline")
*/
#include <cstdio>
#include <iostream>
#include <cmath>
#include <map>
#include <cstring>
#include <cstdlib>

using namespace std;
typedef unsigned long long ull;
const ull mod1 = 998244353;
const ull mod2 = 1145141;
const ull mod3 = 5211600617818708273;
const int P = 13123111;
const int N = 1e7;
int n, table[2500000];
char type[20];
int tot, prime[N / 10 + 1], mu[N + 1], fac[N / 100 + 1], _log[P + 1];
bool check[N + 1], vis[P + 1];
long long id[N / 10 + 1];
map<int, int> hash;

ull pow(ull a, ull b, ull mod)
{
	ull ans = 1;
	for(; b; b >>= 1, a = a * a % mod)
		if(b & 1) ans = ans * a % mod;
	return ans;
}
ull mul(ull a, ull b, ull mod)
{
	ull ans = 0;
	for(; b; b >>= 1, a = (a + a) % mod)
		if(b & 1) ans = (ans + a) % mod;
	return ans;	
}
ull _pow(ull a, ull b, ull mod)
{
	ull ans = 1;
	for(; b; b >>= 1, a = mul(a, a, mod))
		if(b & 1) ans = mul(ans, a, mod);
	return ans;
}
/*-----------------------------------------------------------*/
long long _mul(long long a, long long b, long long mod)
{
	a %= mod, b %= mod;
	long long z = (long double)a * b / mod;
	z = a * b - z * mod;
	return (z + mod) % mod;
}
long long __pow(long long a, long long b, long long mod)
{
	long long ans = 1;
	for(; b; b >>= 1, a = _mul(a, a, mod))
		if(b & 1) ans = _mul(ans, a, mod);
	return ans;
}
bool Miller_Rabin(long long n, int v = 0)
{
	if(n == 2 || n == 3) return 1;
	if(!(n & 1)) return 0;
	long long m = n - 1, q = 0;
	for(; !(m & 1); m >>= 1)
		q++;
	for(long long a = 2; a <= 3 - v; a++)
	{
		long long x = __pow(a, m, n), y;
		for(int k = 0; k <= q; k++)
		{
			y = _mul(x, x, n);
			if(y == 1 && x != 1 && x != n - 1)
				return 0;
			x = y;
		}
		if(y != 1) return 0;
	}
	return 1;
}
/*----------------------------------------------------------*/
bool __check(int g)
{
	for(int i = 1; i <= fac[0]; i++)
	{
		if(pow(g, fac[i], 998244353) == 1)
			return 0;
	}
	return 1;
}
bool _check(int g, int p)
{
	for(int i = 1; i <= fac[0]; i++)
	{
		if(pow(g, fac[i], p) == 1)
			return 0;
	}
	return 1;
}
void seive()
{
	for(int i = 2; i <= N; i++)
	{
		if(!check[i]) prime[++tot] = i;
		for(int j = 1; j <= tot && i * prime[j] <= N; j++)
		{
			check[i * prime[j]] = 1;
			if(i % prime[j] == 0)
				break;	
		}
	}
}
int main()
{
	freopen("software.in", "r", stdin);
	freopen("software.out", "w", stdout);
	scanf("%s", type);
	if(type[0] == '1' && type[1] == '_')
	{
		scanf("%d", &n);
		for(; n--; )
		{
			ull a = 0;
			char ch;
			for(; !isdigit(ch = getchar()); );
			for(; isdigit(ch); a = ((a << 1) + (a << 3) + (ch ^ 48)) % (mod1 - 1), ch = getchar());
			printf("%llu\n", pow(19, a, mod1));
		}
	}
	else if(type[0] == '1' && type[1] == '?' && type[2] == '+')
	{
		scanf("%d", &n);
		for(; n--; )
		{
			ull a;
			scanf("%llu", &a);
			printf("%llu\n", _pow(19, a, mod3));
		}
	}
	else if(type[0] == '1' && type[1] == '?')
	{
		scanf("%d", &n);
		for(; n--; )
		{
			ull a = 0;
			char ch;
			for(; !isdigit(ch = getchar()); );
			for(; isdigit(ch); a = ((a << 1) + (a << 3) + (ch ^ 48)) % (mod2 - 1), ch = getchar());
			printf("%llu\n", pow(19, a, mod2));
		}
	}
	else if(type[0] == '1' && type[1] == 'w')
	{
		scanf("%d", &n);
		int ans = 1;
		int st, len;
		for(int i = 1; ; i++)
		{
			ans = ans * 19 % 998244353;
			if(!hash.count(ans))
				hash[ans] = i;
			else
			{
				st = hash[ans], len = i - st;
				break;
			}
			table[i] = ans;
		}
		for(; n--; )
		{
			long long a;
			scanf("%lld", &a);
			if(!a)
				puts("1");
			else if(a < st)
				printf("%d\n", table[a]);
			else
				printf("%d\n", table[(a - st) % len + st]);
		}
	}
	else if(type[0] == '2' && type[1] == 'p')
	{
		scanf("%d", &n);
		for(; n--; )
		{
			long long l, r;
			scanf("%lld %lld", &l, &r);
			for(long long i = l; i <= r; i++)
				putchar(Miller_Rabin(i) ? 'p' : '.');
			puts("");
		}
	}
	else if(type[0] == '2' && type[1] == 'u')
	{
		scanf("%d", &n);
		seive();
		for(; n--; )
		{
			long long l, r;
			scanf("%lld %lld", &l, &r);
			for(int i = 0; i <= r - l; i++)
				mu[i] = id[i] = 1;
			for(int i = 1; i <= tot; i++)
			{
				long long p = prime[i], p2 = p * p;
				for(long long j = (l - 1) / p + 1; j * p <= r; j++)
					mu[p * j - l] *= -1, id[p * j - l] *= p;
				for(long long j = (l - 1) / p2 + 1; j * p2 <= r; j++)
					mu[p2 * j - l] = 0;
			}
			for(int i = 0; i <= r - l; i++)
			{
				if(!mu[i])
					putchar('0');
				else
				{
					id[i] = (i + l) / id[i];
					if(id[i] == 1)
						putchar(mu[i] > 0 ? '+' : '-');
					else
					{
						long long x = sqrt(id[i]), y = id[i];
						if(x * x == y)
							mu[i] = 0;
						else if(Miller_Rabin(y, 1))
							mu[i] *= -1;
						if(mu[i] > 0)
							putchar('+');
						else if(mu[i] < 0)
							putchar('-');
						else
							putchar('0');
					}
				}
			}
			puts("");
		}
	}
	else if(type[0] == '2' && type[1] == 'g' && type[2] == '?')
	{
		scanf("%d", &n);
		for(int i = 1; i <= n; i++)
		{
			int l, r, p, x;
			if(i <= 2)
				scanf("%d %d %d", &l, &r, &p);
			else
				scanf("%d %d ?", &l, &r), p = 1515343657;
			x = p - 1;
			fac[0] = 0;
			for(int i = 2; i * i <= x; i++)
			{
				if(x % i == 0)
				{
					fac[++fac[0]] = i;
					if(i * i != x)
						fac[++fac[0]] = x / i;
				}
			}
			for(int i = l; i <= r; i++)
				putchar(_check(i, p) ? 'g' : '.');
			puts("");
		}
	}
	else if(type[0] == '2' && type[1] == 'g')
	{
		scanf("%d", &n);
		fac[0] = 0;
		int x = 998244352;
		for(int i = 2; i * i <= x; i++)
		{
			if(x % i == 0)
			{
				fac[++fac[0]] = i;
				if(i * i != x)
					fac[++fac[0]] = x / i;
			}
		}
		for(; n--; )
		{
			memset(vis, 0, sizeof vis);
			int l, r, p, x, g;
			scanf("%d %d %d", &l, &r, &p), x = p - 1;
			if(p == 998244353)
			{
				for(int i = l; i <= r; i++)
					putchar(__check(i) ? 'g' : '.');
				puts("");
				continue;
			}
			g = 6, tot = 0;
			for(int i = 2; i * i <= x; i++)
			{
				if(x % i == 0)
				{
					prime[++tot] = i;
					for(; !(x % i); x /= i);
				}
			}
			if(x > 1) prime[++tot] = x;
			vis[0] = 1;
			for(int i = 1; i <= tot; i++)
			{
				for(int j = 1; j <= (p - 1) / prime[i]; j++)
				{
					vis[j * prime[i]] = 1;
				}
			}
			_log[1] = 0;
			for(int i = 1, w = g; i <= p - 1; i++, w = 1ll * w * 1ll * g % p)
				_log[w] = i;
			for(int i = l; i <= r; i++)
			{
				if(i % p == 0) putchar('.');
				else putchar(vis[_log[i]] ? '.' : 'g');
			}
			puts("");
		}
	}
	return 0;
}
```


---

## 作者：ChenZ01 (赞：6)


## Overview

本题的题意即为给定所有输入输出文件，让选手猜测每个点要实现的目的与方法。

经观察，Case 1-7与$19$的幂次有关，Case 8-16与区间内的数和函数有关。

同时经提示、联想与对数据的观察，不难得出：?表示某数未知，**wa**表示溢出，**p**表示质数（prime number），**u**表示Möbius函数（$\mu$），**g**表示原根（primitive root，常记为$g$）

初步的观察对于解题有着极大的帮助。观察过后，我们开始对每个Case进行分析。
## Solution
### Case 1-3
经观察可发现要求输出$19$的幂次对$998244353$取模的结果。

#### Method 1
使用高精度乘法。

#### Method 2
使用欧拉定理
$$a^{\varphi(n)}\equiv 1(\mathrm{mod}\,n)\quad \text{if}\,\gcd(a, n) = 1$$

在使用快读的时候将输入数据对$\varphi(998244353) = 998244352$取模即可。

### Case 4
经观察可发现要求输出$19$的幂次对某一质数$p$取模的结果。

观察下发的*software4.ans*可得到大致范围$p\in(1.1\times10^6, 1.2\times10^6)$，故枚举得到$p = 1145141$。

### Case 5
要求同Case 4一样，经观察可得出大致范围$p\in(5.2\times10^{18}, 5.3\times10^{18})$，故需要更优的解法。

设输入数据中某两个数为$x_1, x_2$，其对应的值为$y_1, y_2$，则在模$p$意义下有$19^{x_1}\equiv y_1, 19^{x_2}\equiv y_2$。稍作变形可得到
$$y_1\cdot19^{x_2 - x_1}\equiv y_2(\mathrm{mod}\,p)$$

故$p | y_1\cdot19^{x_2 - x_1} -  y_2$。根据*software5.in*和*software5.ans*中的两组指数相近的情况再经简单枚举可得出$p = 5211600617818708273$

### Case 6-7

经观察可发现要求输出$19$的幂次对$p = 998244353$取模的结果，但中间运算溢出导致出现错误结果。

考虑19的某次方对$p$取模且溢出的结果可看做在区间$(-p, p)$内随机选择了一个数。根据生日悖论，存在多个指数对应相同的结果的概率是相当大的。故我们断定：必然会存在$1 < x_1 < x_2$使得输出的结果相同。即从$x_1$开始每$x_2 - x_1$个数构成相同的循环节。
预处理后$\mathcal{O}(1)$解决一个询问。

### Case 8-10


经观察可发现要求判断指定区间内每个数为质数还是合数。

#### Method 1

由于区间长度不大于1000000，考虑直接对每个数Miller-Rabin测试。

#### Method 2

考虑筛法。

对于Case 8，直接线性筛。

对于Case 9，考虑到任意合数$a\in[10^6, 10^{12}]$必有质因子$p\in(1, 10^6)$，故先筛出$10^6$以内的质数，再用这些质数筛出所求区间内的合数。

对于Case 10，类似Case 9 + 打表解决。

### Case 11-13

经观察可发现要求输出指定区间内每个数的Möbius函数。

考虑先筛出$10^6$以内所有质数及所有数的Möbius函数。对于小于等于$10^6$的询问$\mu(x)$直接输出。

否则先将$x$的所有小于等于$10^6$的质因子全部除去并同时统计$\mu(x)$，设最后我们得到了$x_0$。显然$x_0$要么等于1，要么由**最多两个**大于$10^6$的质数组成。设当前统计到的$\mu(x)$为$\mu_P(x)$。

对于$x_0$，

1. 判断其是否为质数。
	- 若是，则输出$-\mu_P(x)$。
	- 否则继续第2步。
2. 判断其是否为完全平方数。
   - 若是，则输出$0$。
   - 否则其一定有两个与之前筛出的不同的质因子，则输出$\mu_P(x)\times(-1)\times(-1) = \mu_P(x)$。

实现时注意Miller-Rabin的基选取问题，经尝试仅需选取24251。

### Case 14-15

经观察可发现要求判断指定区间内每个数是否是指定质数$p$的原根。

对于$p = 998244353$，由欧拉定理可知，若$x^t\equiv1(\mathrm{mod}\,p), t < \varphi(p)$，则定有$t|\varphi(p)$。故若对于$p$的任意质因子$p_i$，都有$x^{p_i}\not\equiv1(\mathrm{mod}\,p)$，则$x$是$p$的一个原根。每个数验证即可。

对于$p = 13123111$，由于$\varphi(p)$的质因子较多，故不能按以上方法实现。

考虑先求出某一原根$g$。令$x = g^k\,\mathrm{mod}\,p$，则若$x$为原根，就有
$$g^{k\varphi(p)}\equiv1(\mathrm{mod}\,p)$$
且$\varphi(p)$是最小的使$g^{kt}\equiv1(\mathrm{mod}\,p)$的正整数$t$。而$g^{\varphi(p)}\equiv1(\mathrm{mod}\,p)$，故$k\perp\varphi(p)$。

预处理出每个$x$的$k$与每个数是否与$\varphi(p)$互质即可。

### Case 16

已知$p\in[10^9, 2\times10^9]$，要求判断指定区间内每个数是否是质数$p$的原根。

由于不同质数在同一区间内原根的分布情况是混乱的，故不是解的$p$一定会很快被排除。故只需筛出所有可能的质数代入求解即可。


---

## 作者：AC_Evil (赞：6)

#### [传送门](https://www.luogu.org/problem/P5285)

　　[这里食用更佳哦](https://www.cnblogs.com/ac-evil/p/11774865.html)

　　前置技能：$\text{Miller-Rabin}$，莫比乌斯函数，原根等数论知识。这些可以参考我最近写的[博客（数论汇总）](https://www.cnblogs.com/ac-evil/p/11705829.html)。

　　这道题是个毒瘤题，花费了我$\text{1day}$独立解决$16$个子任务。下面步入正题。

# subtask 1-3:1_998244353

　　这个观察数据不难得出要求$19^x\bmod 998244353$，直接搞即可。注意到可能$x$非常大，根据费马小定理$x^{P-1} \equiv 1 \pmod P$，我们需要**读入取模**。

# subtask 4:1?

　　观察数据和提示告诉我们：仍然求$19^x$，只不过模数不知道。发现输出文件的最大值在$10^6$左右，我们拿第一个输入直接爆搜检验，最后能找出来$P=1145141$。

# subtask 5:1?+

　　这个是前一个的加强版，发现模数在$5\times 10^{18}$左右，这个不好暴力了。怎么办呢？我把输入的数排了个序，发现有两组输入的$x$之差为$2$，于是我找到这两组对应的输出，得到了：$19^{264708066}\equiv 1996649514996338529 \pmod P$和$19^{264708068}\equiv 1589589654696467295 \pmod P$。也就是说上面的式子乘上$19^2$再取模就能得到下面的数字，于是我们得到了：$1996649514996338529\times 19^2 \equiv 1589589654696467295 \pmod P$。然后改写这个式子：$1996649514996338529\times 361-nP=1589589654696467295$，把常数移到右边，发现在$long\ long$范围内无法算出，我用$long\ double$算出了近似值。然后$P$一定是这个数的一个因子。发现$n$在$100$到$200$左右，我就暴力试除，考虑到精度又将$\pm 1000$的模数用第一组输入输出判断了一下，最后找到了模数$P=5211600617818708273$。

# subtask 6-7:1wa_998244353

　　发现并不是求$19^x \bmod 998244353$了，换成了用$int$一步一步直接乘再取模，忽视溢出等问题。代码如下。

```cpp
	x = (int)(x * 19) % 998244353;
```

　　第$6$个点直接顺序求解即可。第$7$个点恐怕不太行，$x$太大了。我一开始想改写快速幂来求解，发现行不通。正当我一筹莫展的时候，我让第$6$个点多跑到$10^6$组，发现了循环节。就是从$x=55246$开始，答案每过$45699$个数循环一次。这让我想起了$\text{Pollard-Rho}$算法的$\rho$。当然与那个算法没有关系，这里直接用上述性质即可。

# subtask 14-16:2g && 2g+

　　当时我在做完前面$6$个$\text{subtask}$后紧接着做的。前面两个点，每次询问给你三个数$l$，$r$，$P$，要求$l$到$r$在模$P$下的原根。对于第$14$个点，$P=998244353$时，$\varphi(P)=P-1=998244352=2^{23}\times 7\times 17$，因为不同的质因子只有$3$个，所以可以直接试除判断是否为原根。

　　对于第$15$个点，$P=13123111$，$\varphi(P)=13123110=2×3×5×7×11×13×19×23$，而且判断的数字多达$10^7$个，试除肯定会$\text{T}$。我们可以利用其中一个原根把其他的原根遍历出来。在这里$g$取$6$，因为$g^t$遍历所有$\varphi(P)$个与$P$互质的数，而当且仅当$t$与$\varphi(P)$互质的时候$g^t$也是原根。于是我们用$\varphi(P)$的质因子对$t$进行取模判断是否互质。遍历完后原根就找全了。

　　对于第$16$个点，最后一组询问未知模数，根据数据给的原根我们反求模数。提示说在$10^9$到$2\times 10^9$之间且是个质数，我们一个一个找，然后借助已有的原根通过试除法判断这个质数可不可行。根据原根的性质，$\forall g$，如果$g^\frac{P-1}{2}\not\equiv 1 \pmod P$，则$P$很可能是我们要找的模数。我的电脑跑了大约$5min$找到了一个数$P=1515343657$，然后检验发现是正确的。用它搜原根与用$P=998244353$的方法一样。于是就解决了。

# subtask 8-10:2p

　　要求我们判断$l$到$r$内每个数是不是质数。小范围的可以用线性筛，范围稍微大点的可能可以筛一部分数然后用这部分数来筛$l$到$r$。我直接上了$\text{Miller-Rabin}$，这个算法可以在$\log n$的时间内测试一个数是不是质数，正确率为$1-(\frac{1}{4})^s$，$s$为测试次数。这题貌似选取两三个数就可以了，这样常数小全能过。

# subtask 11-13:2u

　　这里让我们筛出$l$到$r$的莫比乌斯函数。

　　同上面一样，我们可以小范围地筛出来$\mu$过掉前两个点。当时我没有这么想，用了$\text{Pollard-Rho}$来暴力分解然后筛出前$10^6$个莫比乌斯函数，发现第二个点都过不掉。怎么办呢？最大的数为$10^{18}$，我想到如果筛出$10^6$以内的质数然后用这些质数来筛这些数，剩下的数的素因子一定$\geq 10^6$，所以剩下的数**最多**只能有两个素因子，也就是以下三种情况：

　　一、剩下的数是质数，用$\text{Miller-Rabin}$判一下，这个时候会使$\mu$乘上$-1$；

　　二、剩下的数是两个不同的质数的乘积；负负得正，这个时候不会对$\mu$产生贡献；

　　三、剩下的数是一个质数的平方。这个时候$\mu$为$0$。

　　用小于$10^6$的因子去筛这些数，并且维护$\mu$，然后通过上面的三种情况分类讨论即可求解。

　　但要注意要去掉含有平方因子的数。最后这道题就解完了。

```cpp
\\ AC代码
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ull unsigned long long
#define rep(i, a, b) for (register int i = a, end = b; i <= end; i++)
#define repd(i, a, b) for (register int i = a, end = b; i >= end; i--)
#define chkmax(a, b) a = max(a, b)
#define chkmin(a, b) a = min(a, b)
#define INF (1<<30)
#define pb push_back
#define mp(a, b) make_pair(a, b)
#define fst first
#define snd second
#define pii pair<int, int>

char s[15];

namespace _998244353 {
	int N;
	ull P;
	ull v;

	inline void inc(ull &a, ull b, ull p) {
		a += b;
		if (a >= p) a -= p;
	}

	ull Mult(ull a, ull b, ull p) {
		ull res = 0;
		for (ull k = a; b; inc(k, k, p), b >>= 1)
			if (b & 1) inc(res, k, p);
		return res;
	}

	ull qpow(ull a, ull b, ull p) {
		ull res = 1;
		for (register ull k = a; b; k = Mult(k, k, p), b >>= 1)
		if (b & 1) res = Mult(res, k, p);
		return res;
	}

	inline ull read() {
		ull w = 0; char c;
		while (!isdigit(c = getchar())) ;
		while (isdigit(c)) w = ((w << 3) + (w << 1) + (c ^ 48)) % (P-1), c = getchar();
		return w;
	}
	void main(ull orz) {
		P = orz;
		scanf("%d", &N);
		rep(i, 1, N) {
			v = read();
			printf("%llu\n", qpow(19, v, P));
		}
	}
}

namespace WA {
	int N;
	int ans[55246+45699+5];
	void main() {
		scanf("%d", &N);
		ans[0] = 1;
		rep(i, 1, 55246+45699) {
			ans[i] = (int)(ans[i-1]*19)%998244353;
		}
		rep(i, 1, N) {
			ll val;
			scanf("%lld", &val);
			if (val <= 55246+45699) printf("%d\n", ans[val]);
			else printf("%d\n", ans[(val-55246)%45699+55246]);
		}
	}
}

namespace GG {
	int qpow(int a, int b, int p) {
		int res = 1;
		for (register int k = a; b; k = (ll)k*k%p, b >>= 1)
			if (b & 1) res = (ll)res * k % p;
		return res;
	}
	void run1(int l, int r, int p) {
		if (p == 998244353) {
			rep(i, l, r) if (qpow(i, 499122176, 998244353) != 1 && qpow(i, 142606336, 998244353) != 1 && qpow(i, 58720256, 998244353) != 1) printf("g"); else printf(".");
		} else {
			rep(i, l, r) 
				if (qpow(i, 757671828, 1515343657) != 1 && qpow(i, 505114552, 1515343657) != 1 &&
					qpow(i, 378552, 1515343657) != 1 && qpow(i, 96072, 1515343657) != 1) printf("g"); else printf(".");
		}
		puts("");
	}
	int st[13123120];
	void run2(int p) {
		memset(st, 0, sizeof(st));
		int g = 6, cnt = 0;
		do {
			cnt++;
			if (cnt % 2 && cnt % 3 && cnt % 5 && cnt % 7 && cnt % 11 && cnt % 13 && cnt % 19 && cnt % 23) st[g] = 1;
			g = g*6%p;
		} while (g != 6);
		rep(i, 1, 13123110) if (st[i]) printf("g"); else printf(".");
		puts("");
	}
}

namespace PP {
	inline ll Mult(ll a, ll b, ll p) {
		ll c = (ll)a*b - (ll)((ull)((long double)a*b/p)*p);
		return c < 0 ? c+p : ((ull)c >= (ull)p ? c-p : c);
	}

	ll qpow(ll a, ll b, ll p) {
		ll res = 1;
		for (register ll k = a; b; k = Mult(k, k, p), b >>= 1)
			if (b & 1) res = Mult(res, k, p);
		return res;
	}
	int test[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
	bool MR(ll P, int cnt = 10) {
		ll s = P-1; int t = 0;
		while (!(s & 1)) s >>= 1, t++;
		rep(i, 0, cnt-1) {
			if (P == test[i]) return true;
			if (test[i] > P) return false;
			ll a = qpow(test[i], s, P), nxt;
			rep(x, 1, t) {
				nxt = Mult(a, a, P);
				if (nxt == 1 && a != 1 && a != P-1) return false;
				a = nxt;
				if (a == 1) break;
			}
			if (a != 1) return false;
		}
		return true;
	}
	int N;
	void main() {
		scanf("%d", &N);
		while (N--) {
			ll l, r;
			scanf("%lld%lld", &l, &r);
			while (l <= r) {
				if (MR(l)) printf("p"); else printf(".");
				l++;
			}
			puts("");
		}
	}
}

namespace UU {
	int N;
	int check[1000005], p[100000];
	void init() {
		memset(check, 0, sizeof(check));
		p[0] = 0;
		rep(i, 2, 1000000) {
			if (!check[i]) p[++p[0]] = i;
			for (register int j = 1; j <= p[0] && i*p[j] <= 1000000; j++) {
				check[i*p[j]] = 1;
				if (!(i % p[j])) break;
			}
		}
	}
	ll frac[1000001], mu[1000001];
	bool issqr(ll x) {
		ll v = sqrt(x);
		if (v*v == x || (v-1)*(v-1)==x || (v+1)*(v+1)==x) return true;
		return false;
	}
#define cc(x) ((x) == 0 ? '0' : ((x) < 0 ? '-' : '+'))
	void main() {
		init();
		scanf("%d", &N);
		while (N--) {
			ll l, r;
			scanf("%lld%lld", &l, &r);
			rep(i, 0, r-l) mu[i] = frac[i] = 1;
			rep(i, 1, p[0]) {
				ll x = 1ll*p[i]*p[i], st = l-(l-1)%x-1+x;
				while (st <= r) {
					mu[st-l] = 0; frac[st-l] = st; st += x;
				}
				x = p[i], st = l-(l-1)%x-1+x;
				while (st <= r) {
					mu[st-l] = -mu[st-l];
					if (frac[st-l] != st) frac[st-l] *= x;
					st += x;
				}
			}
			for (register ll i = l; i <= r; i++) {
				ll val = i/frac[i-l];
				if (val == 1) printf("%c", cc(mu[i-l]));
				else if (PP::MR(val, 2)) printf("%c", cc(-mu[i-l]));
				else if (issqr(val)) printf("0");
				else printf("%c", cc(mu[i-l]));
			}
			puts("");
		}
	}
}

int main() {
	srand(time(0));
	scanf("%s", s);
	if (s[2] == '9') _998244353::main(998244353);
	if (s[1] == '?') {
		if (s[2] == '+') {
			_998244353::main(5211600617818708273ll);
		} else {
			_998244353::main(1145141);
		}
	}
	if (s[1] == 'w') {
		WA::main();
	}
	if (s[1] == 'g') {
		int l, r, p, N;
		if (s[2] == '?') {
			scanf("%d", &N);
			while (N--) {
				scanf("%d%d", &l, &r);
				if (N) scanf("%d", &p); else p = 1515343657;
				GG::run1(l, r, p);
			}
		} else {
			scanf("%d", &N);
			while (N--) {
				scanf("%d%d%d", &l, &r, &p);
				if (p == 998244353) GG::run1(l, r, p);
				else GG::run2(p);
			}
		}
	}
	if (s[1] == 'p') {
		PP::main();
	}
	if (s[1] == 'u') {
		UU::main();
	}

	return 0;
}
```

---

## 作者：leoiter (赞：5)

写个全解吧

第1~3个点：1_998244353的ans可以找规律得出结论：第i个为$19^{x_i}$(模数不难根据题面猜出为998244353)，相当于求$19^x$。

第1个点：$\max{x_i}<100000$线性递推

第2个点：$\max{x_i}<100000000$可以快速幂(即处理$19^{(2^i)}$，组合出$19^x$)

第3个点：$x_i$为高精度数，根据欧拉定理：$x^i=x^{i\mod\phi(p)+phi(p)}(i>\phi(p))(\mod p)$，对于p为质数，$x^i=x^{i\mod\phi(p)}(\mod p)$
由于指数x对$\phi(p)$取模，可以无需使用高精度，在快读中对指数取模。

第4个点：1?的ans都不大，而模意义下这些值的分布是均匀的(可以认为是随机的)，从而猜测是换了个较小的模数，从最大的ans(1000000多)往上暴力找到第一个满足前5个ans正确的模数，最终得到模数为1145141。(剩下的实现参考第2个点)

第5个点：1?+的ans都很大，与1?类似，猜测是换了个较大的模数。将所有对应的in和ans按x的大小排序，发现一组特殊的：x=264708066，y=264708068。
p一定是$ans_x* 19^2-ans_y$的因数，$1996649514996338529×361−1589589654696467295=719200885258981741674=5211600617818708273*2*3* 23$，其最大质因子为5211600617818708273即为所求的模数。(由于模数巨大，快速幂的过程中可以使用__int128或者快速乘法)

第6~7个点：1wa_998244353求$19^x$对998244353取模。根据提示以及ans中的负数，猜测是int自然溢出。重点是它是每次$* 19$再自然溢出，不能快速幂。

第6个点：$\max{x_i}<100000$线性递推

第7个点：数据是有周期的，可以写个代码跑出来，从第55245个数进入循环节长度为45699的周期。

第8~10个点：2p观察发现是区间质数表

第8个点：$\max{x_i}<1000000$线性筛(埃氏筛法也行)

第9个点：$\max{x_i}<1e12$区间筛，先线性筛1e6内的质数，1e12内的合数一定有小于1e6的质因子，从而筛出1e12范围内长度为1e6的质数表。

第10个点：$\max{x_i}<1e18$素性测试，可以使用miller_rabin(也可以继承第9个点的思路，区间筛，先线性筛1e8内的质数，1e18内的合数一定有小于1e9的质因子，从而筛出1e18范围内的大部分质数，对于剩下的一一特判打表即可（表长5316个元素）。)

第11~13个点：2u观察发现是区间$\mu$函数表，考虑用类似2p的做法

第11个点：$\max{x_i}<1000000$线性筛积性函数

第12个点：$\max{x_i}<1e12$先线性筛1e6内的质数，1e12内的合数一定有小于1e6的质因子，从而筛出1e12范围内长度为1e6的数的所有<1e6的质因子构成，判断是否有大于1e6的因子即可。

第13个点：继承第12个点的思路，类比第10个点，对于与答案不同的一一特判打表即可（表长7171+6230个元素）。减少代码长度可以记录表的差分数组。具体可以看https://xyxiangjindui.blog.luogu.org/solution-p5285-2

第14~15个点：2g观察发现是区间原根表。

第14个点：直接做原根判断：一个数x是质数p的原根，当且仅当对于 $\phi(p)$的任意质因数q，$x^{\frac{\phi(p)}{q}}\mod p\neq 1$，必要性显然($\frac{\phi(p)}{q}<\phi(p)$若满足则不符合原根定义)，充分性显然(若有$x^y\mod p=1$则y一定是$\phi(p)$的因数，因为$\phi(p)$满足条件，而当$y\neq\phi(p)$时，y一定是某个$\frac{\phi(p)}{q}$的因数，不存在y满足但所有$\frac{\phi(p)}{q}$都不满足的情况)。

第15个点：$\phi(p)=13123110=2* 3* 5* 7* 11* 13* 19* 23$找到一个原根如6，求出每个数以6为原根的指标(不要用bsgs，直接线性扫)，指标与$\phi(p)$互质则为原根，否则不是。

第16个点：2g?在2g的基础上我们需要找到未知的模数。线性筛出1e9~2e9中所有质数，显然$\phi(p)$是2的倍数，取q=2判断前15个原根是否通过了14~15中的测试，得到模数1515343657(跑起来很快)。用第14个点的算法即可。


---

## 作者：leoiter (赞：4)

Orz @曾铭豪

具体做法/推导看@曾铭豪就好啦

这里记录一种不把数组压成字符串的做法以帮助大家减少思维难度，代码难度，节约做题时间

算法一：

记录结果与答案不同的位置用来修正(记录所有特殊的x($l\leq x\leq r$))

算法二：

表内是有序数字，表内元素大小为999999999999000000~1000000000000000000是不科学的，显然记录x-999999999999000000，范围0~1000000表长为原来1/3

到这，你已经有在考场拿打表分(第10个点/13个点)(为了压缩表长，蒟蒻线性筛了1e8，以至于最终ac需要期望2次提交/O2，显然调参是麻烦的，所以就这样吧)。

算法三：

但怎么同时打2个表呢，观察发现不合法情况是均匀的，所以相邻2个数的差（大部分）在50~500间浮动，如果对于表差分一下，表长减半，此时已经可以在loj上AC了。（表长65K）

不幸的是，没写过压字符串的蒟蒻我被迫写了素性测试，从而ac了本题。

提供代码相关数据：

一共3个表

1.合数补充表 表长 5316个元素

2.$\mu$+改-表 表长 7171个元素

3.$\mu$-改+表 表长 6230个元素

（$\mu$函数的0在暴力中全对了2333）

算法四：

为了对付洛谷困难的50k限制，提供一种非正解的未实现的可能思路，考虑压字符串，字符集可以包含可键入字符(0~9,a~z,A~Z,!@#$%^&*()-=_+)相当于可以压70~80进制的数，此时差分数组中每个数可以用1~2位表示，显然比上述做法要优，不确定是否正确。

我们可以计算一下，每个2位的情况，18717个元素每个2个字符，一共近38000个字符，约38K，理论上我们成功解决了这个问题。

---

## 作者：_slb (赞：3)

[my blog](https://luoyisu.github.io/loj3050/)

## Description

给出一些测试点的输入文件和输出文件以及每个测试点要实现的功能编号，你需要写一个程序通过这些给出的测试点。

[链接](https://loj.ac/p/3050)，这个题在 loj 上体验很好，洛谷上虽然也有这个题但容易被卡常。

## Solution

很明显：功能开头是 $1$ 还是 $2$ 区别很大，我们分开来看。

### input1~7

#### input1~3

这三个点都是 $\text{1\_998244353}$，我们看一下数据。

input：`0 1 2 3`

output：`1 19 361 6859`

很明显是要求 $19^n$。

发现肯定有一个模数，那很容易想到就是 $998244353$​。

写一个快速幂，这三个点就能过了。

注意第三个点指数很大，根据欧拉定理，我们只需要在读入的时候对 $998244352$ 取模即可。

#### input4

这个点是 $1?$。

看一下比较小的数据，发现还是求的 $19^n$，而模数不一样了，联想到由 $998244353$ 变成了 $?$，这个点看起来是让我们确定模数。

找到最大的数，发现是 $10^6$ 级别的，且不超过 $2\times10^6$，那我们可以尝试枚举这个模数，判断一下 $19^{627811703016764290815178977207148434322}$ 是否等于 $642666$ 即可。

写了一个 python 代码跑：

```python
def qpow(a, x, p):
    res = 1
    while x > 0:
        if x % 2 == 1:
            res = res * a % p
        x >>= 1
        a = a * a % p
    return res

for i in range(10 ** 6, 2 * 10 ** 6):
    if qpow(19, 627811703016764290815178977207148434322, i) == 642666:
        print('ans', i)
        break
    #print('check', i)
    if i % 10000 == 0:
        print(i)

```

能找到一个模数是 $1145141$，当看到 $114514$ 我们就知道应该是找对了。

模数找到了，这个点还有一个问题：指数太大。

我们看一下 $1145141$ 这个数，写一个判断素数的程序，发现是个质数，且和 $19$ 互质，那么根据欧拉定理，我们只需要在读入的时候对 $1145141-1$ 取模即可。

这个点也就很愉快地搞定了。

#### input5

实际上这个点可能是整道题最难的一个点了。

这个点是 $1?+$。

联系上一个点，看一下数据，发现似乎还是让我们确定模数，但模数似乎很大很大，最大的答案达到了 $5211500658258874318$，枚举肯定是不行了。

我们想一想怎么样能确定模数。。。

可以想到一个方法：找到两个相邻的指数，根据答案来确定质数。如果不懂就接着往下看。

我们打一个表：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef __int128_t lll;

lll read()
{
    lll x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = -1;
    for (; isdigit(ch); ch = getchar())
        x = x * 10 + ch - '0';
    return x * f;
}

void write(lll x)
{
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

inline void space() { putchar(' '); }
inline void endln() { putchar('\n'); }

int n = 10000;

const int maxn = 1e4 + 10;

pair<lll, lll> a[maxn];

inline lll myabs(lll x) { return x < 0 ? -x : x; }

int main()
{
    lll res = 0;        
    freopen("tmp5.in", "r", stdin);
    for (int i = 1; i <= n; i++)
        a[i].first = read();
    freopen("software5.ans", "r", stdin);
    for (int i = 1; i <= n; i++)
    {
        a[i].second = read();
        //if (myabs(a[i].first - a[i].second) < 10000000000)
        //    write(a[i].first), putchar(' '), write(a[i].second), putchar('\n');
    }
    std::sort(a + 1, a + 1 + n);
    for (int i = 2; i <= n; i++)
        if (a[i].first - a[i - 1].first < 5)
            write(a[i - 1].first), space(), write(a[i - 1].second), space(), write(a[i].first), space(), write(a[i].second), endln();
}

/*

5211500658258874318

*/
```

发现有这么一组数据：

```
264708066 1996649514996338529
264708068 1589589654696467295
```

也就是说，设 $1996649514996338529=a,1589589654696467295=b$，有 $19\times19a\equiv b\pmod p$。

那么 $p\mid19\times19a-b=719200885258981741674$​，又由于 $p>5211500658258874318$​​，所以我们只需要枚举一个小于等于 $138$ 的约数就行。

然后拿 python 一算，好家伙，$138$ 正好是一个约数，我们把 $719200885258981741674/138=5211600617818708273$ 这个数放进我们的程序里试一下，它居然过了，真好。

那么这个点也就过了。

以上五个点可以写成一个函数：传入模数，求 $19^n\pmod p$。

#### input6~7

这两个点给出了模数 $998244353$，但特殊之处在于这个 $\text{wa}$，看一下数据发现出现了负数，再看看题目上的提示，很明显是溢出导致的。

具体是哪里溢出了呢？

首先肯定不是快速幂，你可以试一试，也可以用这个思路去想：每个人的快速幂写法会有差异，不能用这个出题。

那就只剩下暴力一个个乘上去了。。。

试一下，发现貌似是对的。

也就是说在 `res = res * 19 % mod` 这一步中没开 `long long` 导致溢出了。

这玩意肯定没法用快速幂算，但是考虑到一个事情：这个溢出相当于对 $2^{32}$ 取模，那么就会产生循环节（因为这个数不是质数，欧拉函数不是它减去 $1$）。

我们可以用 `map` 来判断循环节，反正循环节应该不是很长：

```cpp
typedef long long ll;
typedef __int128_t lll;
typedef unsigned int ui;
typedef unsigned long long ull;

int n = 10000;

const int maxn = 1e4 + 10;
const int mod = 998244353;

pair<lll, lll> a[maxn];

inline lll myabs(lll x) { return x < 0 ? -x : x; }
inline int errmul(int a, int b) { return (int)((ui)a * (ui)b); }

map<int, int> mp;

int main()
{
    int now = 1;
    mp[0] = 1;
    for (int i = 1; ; i++)
    {
        now = errmul(now, 19) % mod;
        if (mp.count(now))
        {
            cout << i << " " << mp[now] << " " << i - mp[now] << " " << now << endl;
            return 0;
        }
        mp[now] = i;
    }
}
```

然后找到循环节开始位置是 $55245$，长度是 $45699$。

对于这两个点，直接暴力找循环节，对于一个询问，直接小学数学取个模就行。

那么这前 $7$ 个点就过了，$41$ 分到手。

### input8~16

这些点都有一个共同特征：给一个区间，问区间内所有数的一些性质。

分开来看三种功能：

#### input8~10

这三个点的关键信息是 $\text{p}$，看一下小数据：

input：`2 10`

output：`pp.p.p...`

很明显了吧，是求区间内所有质数。

发现数是非常大的，但区间不大，只有 $10^6$ 级别。

那我们直接对每个区间内的所有数进行 Miller-Rabin 素性测试就行了。

我一般找 $10$ 个随机数测试，但本机速度有点慢，跑不过去，于是进行了一波卡常：不使用随机数，而是用固定的数来测试（因为这样可以减少测试次数）。

试了试发现好像只用 $2,3$ 检测就能过这三个点，那就这样吧。

后来我又试了试随机数的判定，不知道为什么，在 loj 跑 $10$ 个随机数仍然飞快（第 $10$ 个点 232ms），但在洛谷跑 $5$ 个随机数就很勉强（第 $10$ 个点 1.39s），所以还是建议大家去 loj 做，避免卡常（）

#### input11~13

关键信息是 $\text{u}$，这是啥呢？

看一看答案，发现只有三种：负号、正号、零。

这。。再看看小数据联想一下，应该是莫比乌斯函数。

和上一个功能一样，数非常大，区间不大。

有一个比较经典的题是区间筛素数，使用的方法是先筛出平方根范围内的素数，然后再筛那个区间里的素数。

我们可以尝试类似的思路。

先筛出 $(10^{18})^{1/3}=10^6$ 范围内的素数以及莫比乌斯函数，用这些数去筛指定区间内的莫比乌斯函数，即让每个数都除掉他们在 $[1,10^6]$ 范围内的质因子，同时更新莫比乌斯函数。

这样剩下的数有一些很好的性质：要么是素数，要么是两个大于 $10^6$ 素数的积。

那么接下来的事情就比较明了了：

- 用 Miller-Rabin 先判断剩下的数是不是素数，如果是，那么把答案取相反数；
- 如果不是素数，我们判断这个数是不是平方数，如果是，答案变为 $0$；
- 如果都不是，那么就是由两个不同素数乘起来得到的，这样答案不变。

写出来之后在我的机子上又跑不过去了，想办法剪剪枝卡常：

- 多筛一些质数，能减少 Miller-Rabin 的执行次数；
- 很显然，如果答案已经是 $0$，不用管；
- 如果剩下的数是 $1$，不用管；

折腾完之后在我的机子上看起来速度还行，loj 上飞快。

这三个点也就过了。

#### input14~16

关键信息是 $\text{g}$，有了刚刚的经验，这个东西应该也是一个数学符号。

想一想再看看数据能发现是判断一个数是否是指定数的原根。

首先有**原根判定定理**：设 $m \geqslant 3, \gcd(a,m)=1$，则 $a$ 是模 $m$ 的原根的充要条件是，对于 $\varphi(m)$ 的每个素因数 $p$，都有 $a^{\frac{\varphi(m)}{p}}\not\equiv 1\pmod m$。

对于 input14，模数全部是 $998244353$，$\varphi(998244353)=998244352$ 质因子只有 $2,7,17$，区间也不大，直接暴力判断即可。

对于 input15，有一个模数是 $13123111$，$\varphi(13123111)=13123110=2\times3\times5\times7\times11\times13\times19\times23$，区间还贼大，暴力判断看上去不太行。

得请出另一个结论了：若 $\gcd\big(k,\varphi(m)\big)=1$，则有：$\delta_m(g^k)=\varphi(m)$，即 $g^k$ 也是模 $m$ 的原根。

用这个就可以筛原根了。

接着是最后一个点 input16，这个点有一个 $10^9\sim2\times10^9$ 的质数作为模数需要我们确定，我们使用 input14 的思路暴力枚举这个质数，然后暴力分解质因数来判断原根情况和原来是否一致即可。我这里只检验了前 $49$ 位。

看起来很暴力，但因为素数并不是特别多而且很容易检测出问题，实际代码跑起来是很快的。

```cpp
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#include <vector>
using std::cerr;
using std::cin;
using std::cout;
using std::endl;

typedef long long ll;
typedef __int128_t lll;
typedef unsigned int ui;
typedef unsigned long long ull;

ll qpow(ll a, ll x, ll p)
{
    ll res = 1;
    for (; x; x >>= 1, a = (lll)a * a % p)
        if (x & 1)
            res = (lll)res * a % p;
    return res;
}

bool MR(ll n)
{
    if (n < 3 || n % 2 == 0)
        return n == 2;
    if (n == 3 || n == 5 || n == 7 || n == 11)
        return 1;
    if (n % 3 == 0)
        return n == 3;
    ll a = n - 1, b = 0;
    while (a % 2 == 0)
        a >>= 1, b++;
    for (int i = 0, j; i < 5; i++)
    {
        ll c = rand() % (n - 1) + 1;
        ll v = qpow(c, a, n);
        if (v == 1)
            continue;
        for (j = 0; j < b; j++)
        {
            if (v == n - 1)
                break;
            v = (lll)v * v % n;
        }
        if (j >= b)
            return false;
    }
    return true;
}

char s[100];

std::vector<int> a;

int n, m;

int check(int x)
{
    a.clear();
    int t = x - 1;
    for (int i = 2; i * i <= t; i++)
    {
        if (t % i == 0)
        {
            a.push_back(i);
            while (t % i == 0)
                t /= i;
        }
    }
    int q = x - 1;
    for (int i = 1; i <= 49; i++)
    {
        int now = i + n - 1;
        int ok = 1;
        for (int j : a)
            if (qpow(now, q / j, x) == 1)
            {
                ok = 0;
                break;
            }
        if (ok && s[i] == '.')
            return false;
        else if (!ok && s[i] == 'g')
            return false;
    }
    return true;
}

int main()
{
    int l, r;
    cin >> l >> r;
    freopen("in.in", "r", stdin);
    cin >> n >> m;
    cin >> (s + 1);
    for (int i = l; i <= r; i++)
    {
        if (!MR(i))
            continue;
        int flag = check(i);
        if (flag == 1)
            cout << i << endl;
    }
}
```

我这里采用 $10$ 个程序并行的方式进行计算，效率很高，我刚开始第六个程序，第一个程序就跑完了。

找出来合法的数只有一个：$1515343657$。质因数分解一下 $1515343656$，发现质因子是 $2,3,4003,15773$，区间不大，直接用 input14 的方法暴力判断即可。

这样这道题就做完了。

## Code

完全没压行，所以很长。

```cpp
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#include <vector>
using std::cerr;
using std::cin;
using std::cout;
using std::endl;

typedef long long ll;
typedef __int128_t lll;
typedef unsigned int ui;
typedef unsigned long long ull;

namespace IO
{
    const int mxsiz = 1 << 20;
    char inbuf[mxsiz], *p1, *p2;
    char outbuf[mxsiz], *op = outbuf;
    struct endio
    {
        endio(){};
        ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); }
    } useless_var;
    inline char gc() { return p1 == p2 && (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; }
#define isdigit(x) (x >= '0' && x <= '9')
    inline ll read()
    {
        ll x = 0, f = 1;
        char ch = gc();
        for (; !isdigit(ch); ch = gc())
            if (ch == '-')
                f = -1;
        for (; isdigit(ch); ch = gc())
            x = x * 10 + ch - '0';
        return x * f;
    }
    int read_mod(int p)
    {
        int x = 0, f = 1;
        char ch = gc();
        for (; !isdigit(ch); ch = gc())
            if (ch == '-')
                f = -1;
        for (; isdigit(ch); ch = gc())
            x = (lll)x * 10 % p + ch - '0', x %= p;
        return x * f;
    }
#undef isdigit
    inline void push(char ch)
    {
        if (op - outbuf == mxsiz)
            fwrite(outbuf, 1, mxsiz, stdout), op = outbuf;
        *op++ = ch;
    }
    template <typename T>
    inline void work_wt(T x)
    {
        if (x > 9)
            work_wt(x / 10);
        push(x % 10 + '0');
    }
    template <typename T>
    inline void write(T x)
    {
        if (x < 0)
            x = -x, push('-');
        work_wt(x);
    }
    inline void endln() { push('\n'); }
    inline void space() { push(' '); }
    template <typename T>
    inline void writeln(T x) { write(x), endln(); }
}
using namespace IO;

ll qpow(ll a, ll x, ll p)
{
    ll res = 1;
    for (; x; x >>= 1, a = (lll)a * a % p)
        if (x & 1)
            res = (lll)res * a % p;
    return res;
}

namespace task1
{
    int n;
    void solve(const ll mod = 998244353)
    {
        n = read();
        for (int i = 1; i <= n; i++)
            write(qpow(19, read_mod(mod - 1), mod)), endln();
    }
    std::map<int, int> mp;
    inline int errmul(int a, int b) { return (int)((ui)a * (ui)b); }
    void solve2()
    {
        const int begin = 55245, round = 45699;
        const int mod = 998244353;
        mp[0] = 1;
        int now = 1;
        for (int i = 1; i <= begin + round; i++)
        {
            now = errmul(now, 19) % mod;
            mp[i] = now;
        }
        n = read();
        for (int i = 1; i <= n; i++)
        {
            ll x = read();
            write(x <= begin ? mp[x] : mp[(x - begin) % round + begin]);
            endln();
        }
    }
}

bool MR(ll n)
{
    if (n < 3 || n % 2 == 0)
        return n == 2;
    if (n == 3 || n == 5 || n == 7 || n == 11)
        return 1;
    ll a = n - 1, b = 0;
    while (a % 2 == 0)
        a >>= 1, b++;
    for (int i = 0, j; i < 2; i++)
    {
        ll c;
        if (i == 0)
            c = 2;
        else if (i == 1)
            c = 3;
        ll v = qpow(c, a, n);
        if (v == 1)
            continue;
        for (j = 0; j < b; j++)
        {
            if (v == n - 1)
                break;
            v = (lll)v * v % n;
        }
        if (j >= b)
            return false;
    }
    return true;
}

namespace task2
{
    void solve()
    {
        int n = read();
        while (n--)
        {
            ll l = read(), r = read();
            for (ll i = l; i <= r; i++)
                push(MR(i) ? 'p' : '.');
            endln();
        }
    }
}

namespace task3
{
    const int maxn = 5e6 + 10;
    int mu[maxn], pri[maxn], vis[maxn], tot;
    void init(const int n = 5e6)
    {
        mu[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            if (!vis[i])
                pri[++tot] = i, mu[i] = -1;
            for (int j = 1; j <= tot && i * pri[j] <= n; j++)
            {
                vis[i * pri[j]] = 1;
                if (i % pri[j] == 0)
                {
                    mu[i * pri[j]] = 0;
                    break;
                }
                else
                    mu[i * pri[j]] = -mu[i];
            }
        }
    }
    int ans[maxn];
    ll now[maxn];
    inline bool check(ll x)
    {
        ll p = std::sqrt(x);
        return p * p == x;
    }
    void work(ll x, ll y)
    {
        if (y <= 5e6)
        {
            for (int i = x; i <= y; i++)
                if (mu[i] == 0)
                    push('0');
                else if (mu[i] == 1)
                    push('+');
                else if (mu[i] == -1)
                    push('-');
        }
        else
        {
            for (int i = 0; i <= y - x; i++)
                now[i] = i + x;
            memset(ans, 1, sizeof(ans));
            for (int i = 1; i <= tot; i++)
            {
                int p = pri[i];
                ll j = 1ll * x / p;
                ll pos = 1ll * j * p;
                while (pos < x)
                    pos += p;
                while (pos <= y)
                {
                    int rp = pos - x;
                    int cnt = 0;
                    while (now[rp] % p == 0)
                        now[rp] /= p, cnt++;
                    if (cnt > 1)
                        ans[rp] = 0;
                    else if (ans[rp] > 1)
                        ans[rp] = -1;
                    else
                        ans[rp] *= -1;
                    pos += p;
                }
            }
            for (int i = 0; i <= y - x; i++)
            {
                if (ans[i] == 0 || now[i] == 1)
                    continue;
                if (MR(now[i]))
                    ans[i] = ans[i] > 2 ? -1 : ans[i] * -1;
                else if (now[i] != 1 && check(now[i]))
                    ans[i] = 0;
                else if (ans[i] > 2)
                    ans[i] = 1;
            }
            for (int i = 0; i <= y - x; i++)
                if (ans[i] == 0)
                    push('0');
                else if (ans[i] == 1)
                    push('+');
                else if (ans[i] == -1)
                    push('-');
        }
    }
    void solve()
    {
        init();
        int n = read();
        for (ll x, y, i = 1; i <= n; i++)
            x = read(), y = read(), work(x, y), endln();
    }
}

std::string s;

namespace task4
{
    int n;
    const int maxn = 1.4e7 + 10;
    bool ans[maxn];
    void BF(int l, int r, int p)
    {
        int q = p - 1;
        for (int i = l; i <= r; i++)
        {
            if (qpow(i, q / 2, p) == 1 || qpow(i, q / 7, p) == 1 || qpow(i, q / 17, p) == 1)
                ans[i - l] = 0;
            else
                ans[i - l] = 1;
        }
        for (int i = 0; i <= r - l; i++)
            push(ans[i] ? 'g' : '.');
        endln();
    }
    void BF2(int l, int r, int p)
    {
        int q = p - 1;
        for (int i = l; i <= r; i++)
        {
            if (qpow(i, q / 2, p) == 1 || qpow(i, q / 3, p) == 1 || qpow(i, q / 4003, p) == 1 
                || qpow(i, q / 15773, p) == 1)
                ans[i - l] = 0;
            else
                ans[i - l] = 1;
        }
        for (int i = 0; i <= r - l; i++)
            push(ans[i] ? 'g' : '.');
        endln();
    }
    const int g = 6;
    inline int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); }
    void qwq(int l, int r, int p)
    {
        const int q = p - 1;
        int now = g;
        for (int i = 1; i <= r; i++)
        {
            if (gcd(i, q) == 1)
            {
                ans[now] = 1;
            }
            now = now * g % p;
        }
        for (int i = l; i <= r; i++)
            push(ans[i] ? 'g' : '.');
        endln();
    }
    void work(int l, int r, int p)
    {
        if (p == 998244353)
            BF(l, r, p);
        else if (p == 1515343657)
            BF2(l, r, 1515343657);
        else
            qwq(l, r, p);
    }
    void solve(int flag = 0)
    {
        n = read();
        for (int i = 1; i <= n; i++)
        {
            int x = read(), y = read();
            if (flag && i == n)
                work(x, y, 1515343657);
            else
                work(x, y, read());
            memset(ans, 0, sizeof(ans));
        }
    }
}

int main()
{
    cin >> s;
    if (s == "1_998244353")
        task1::solve();
    else if (s == "1?")
        task1::solve(1145141);
    else if (s == "1?+")
        task1::solve(5211600617818708273);
    else if (s == "1wa_998244353")
        task1::solve2();
    else if (s == "2p")
        task2::solve();
    else if (s == "2u")
        task3::solve();
    else if (s == "2g")
        task4::solve();
    else if (s == "2g?")
        task4::solve(1);
}
```



---

## 作者：hl666 (赞：3)

### Preface

ZJOI一轮被麻将劝退的老年选手看到这题就两眼放光，省选也有**乱搞题**？

然后狂肝了3~4天终于打完了，期间还补了一堆姿势

由于我压缩技术比较菜，所以用的都是**非打表算法**，所以一共写了5K……

话不多说我们慢慢分析这道神题（真的是慢慢，最后还会放上许多辅助的CODE）

------

### Case1~Case3

首先这几个点就是让你熟悉一下题目意思的

我们套路地发现这题由两部分组成，他们的功能编号开头分别为$1/2$

然后点开第一个点，发现第一个是数据组数？剩下的输入一个$x$然后就输出一个数

通过$0\to1,1\to 19,2\to 361$我们发现这个就是$19^x$

之后就能理解$998244353$是什么了，其实就是模数

那么很简单，Case1暴力推就可以了，Case2指数在```long long```内直接快速幂即可

Case3我们通过**欧拉定理**，$x^p=x^{p\mod\phi(p)}$，当$\text{p is a prime number}$时，有$x^p=x^{p\mod p-1}$

一边读入一边取模即可

------

### Case4

$998244353$变成了`?`，我们发现这时候模数要自己猜

打开答案文件发现数据普遍很小，所以我们找出最大的数$1145098$，然后向后枚举判断即可

判断的时候只需要比对第一个的答案即可，这个可以很快找出最后的模数是$1145141$

------

### Case5

哎呀怎么又没有模数了，打开答案文件一看那庞大的数据范围看来就不能暴力枚举模数了

那么我们考虑我们一般找模数的过程，像这种单调增函数取模的时候肯定存在一个$x$，使得$f(x-1)>f(x)$（$f(x)=19^x\mod p$）

那么我们考虑用这种方法求出模数，首先找出一对$x,y(x<y)$使得$f(x)>f(y)$且$x,y$尽量接近

写个代码跑一下会得到这样的一组数据：

```python
264708066 1996649514996338529
264708068 1589589654696467295
```

然后我们计算差值，$264708066\times19^2-1589589654696467295=719200885258981741674$

显然此时模数必定是$719200885258981741674$的一个因数，我们考虑它还要大于最大数$5211500658258874318$，所以在$[100,200]$中枚举一个约数，求出另一个约数$5211600617818708273$即是最后的模数

下面放一下找差值的代码以及求约数的Python代码：

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
const int N=10005;
struct data
{
	int x; long long y;
	friend inline bool operator < (const data& A,const data& B)
	{
		return A.x<B.x;
	}
}a[N]; int n,mi=1e9,pos;
int main()
{
	freopen("mindlt.txt","w",stdout);
	FILE *fin1=fopen("software.in","r"),*fin2=fopen("software5.ans","r");
	register int i; char str[20]; fscanf(fin1,"%s",str+1);
	for (fscanf(fin1,"%d",&n),i=1;i<=n;++i) fscanf(fin1,"%d",&a[i].x);
	for (i=1;i<=n;++i) fscanf(fin2,"%lld",&a[i].y);
	for (sort(a+1,a+n+1),i=2;i<=n;++i) if (a[i].y<a[i-1].y)
	{
		if (a[i].x-a[i-1].x<mi) mi=a[i].x-a[i-1].x,pos=i;
	}
	return printf("%d %lld\n%d %lld",a[pos-1].x,a[pos-1].y,a[pos].x,a[pos].y),0;
}
```

```python
for i in range(100,201):
	if 719200885258981741674%i==0:
		if 719200885258981741674//i>5211500658258874318:
			print(719200885258981741674//i,end=' ')
            
```

最后提醒一点，两个模数范围的数相加都会爆```long long```，所以必须开```unsigned long long```

### Case6~Case7

艾玛这个$998244353$前面加个```wa```是什么鬼

打开答案文件发现输出有了负数，相信这个大家平时都有经历过，显然是没开```long long```炸了

那么快速幂我怎么知道要在哪里取模呢？没事Case6单次暴力乘起来即可，但是这样过不了Case7啊

不要慌我们意识到这种构造数列的方法类似于**生日悖论**，是很容易成环的

那么我们直接开一个```map```找出环然后直接做即可

这里给出找环的CODE，输出的第一个数是环之前的位置，第二个数是环的长度

```cpp
#include<cstdio>
#include<map>
#define RI register int
using namespace std;
const int N=10000005,mod=998244353;
int lst,nw; map <int,int> pos;
int main()
{
	freopen("circle.txt","w",stdout);
	pos[lst=1]=0; for (RI i=1;;++i)
	{
		nw=19*lst%mod; if (pos.count(nw))
		return printf("%d %d",pos[nw]-1,i-pos[nw]),0;
		pos[nw]=i; lst=nw;
	}
	return 0;
}
```

------

### Case8~Case10

woc终于写完第一个部分了，然后发现这第二个点的输出怎么都那么大呢

点开一看woc一片乱七八糟的字符？大致发现了输入可能是一个区间？然后每个数输出了一个字符

仔细分析加上适当联想（$\text{p=prime}$）我们发现这就是个**素性检测**

那么很简单，Case8一发线性筛，Case9可以筛出前$10^6$然后拿到这里筛，Case10。。。

可以选择打表，因为两个素数间的间隔很大，可以直接**记录差值**然后压缩起来

但是判素数我们还有一大法宝——**Miller_Rabin**，这里的MR不需卡常以及鬼畜选参数，直接做$10$次都能过

所以还算是轻松地结束了

------

### Case11~Case13

这里根据上面的套路我们点开答案文件发现只有```0```,```+```,```-```三种字符

然后结合$u$的提示很容易想到这就是区间求$\mu$，根据$\mu$的定义我们大力来一发质因数分解？

然后悲惨的我复习了**Pollard-Rho**之后发现这东西在运行多组数据时就是个弟弟，连Case11都跑不过233

那只能沿袭上面的套路了，Case11可以线性筛，Case12直接用$10^6$的素数来筛即可

那么Case13的做法就比较诡异了，这里讲一种LOJ上看到的做法：

首先类似于Case12，先筛出$10^6$内所有素数，然后先像上面一样筛一遍，同时记录每一个数此时的**乘积**

分解结束后看一下，如果还有剩下的因数，那么其实只要判断以下情况即可：

- 剩下的因数为素数，直接MR判一发即可
- 剩下一个平方数，直接```sqrt```后回代判断，并且直接把$\mu$置为$0$
- 这个数是两个不同的大于$10^6$的素数的乘积（容易发现不可能是三个及以上的积），这个什么都不干即可（乘两个$-1$等于不变）

然后写一发你就会发现TLE飞了，看一下真正慢的其实是MR哪里

然后我们就要利用**欧洲玄学**了，经过试验我们发现MR的底数可以只用$2,3$（据说只用一个$2$都能过）来跑，然后速度上卡过去了，且没有打表需求！

------

### Case14~Case16

这个根据上面的套路直接观察+大力猜测发现$\text{g=原根}$

然后根据基本数论技巧我们知道判断一个数是否是另一个数的原根只要判断对于$p$的所有**质因数**$p'$都有$x^{\frac{\phi(p)}{p'}}\mod p\not= 1$

然后发现$\phi(998244353)=998244352$只有$3$个质因数，所以暴力做就可以通过Case14

那么Case15是什么鬼，区间筛原根？其实还真的可以，我们利用原根于**指标**的关系可以发现先找出任意一个原根，然后求出关于它的指标就得到这个数是原根当且仅当该指标与$\phi(p)$互质

这个直接大力分解质因数枚举一发即可，即可通过Case15

然后就是最恶心的Case16了，感觉上可以用偏数学的方法求出，但是我们可以乱搞求出模数

意识到$[10^9,2\times10^9]$内很多素数，出题人为了卡你肯定要把正确的那个放在中间一点

所以我们从中间向两侧枚举，用MR判素数，然后怎么检测这个数是否符合要求呢

很简单，我们把答案的前$50$个全部记下来，因为$\phi(p) \mod 2=0$，所以必然有质因数$2$

我们只用这个来判断，一旦出现这个都不合法但答案却是合法的情况即说明这个数显然不行

那么耐性地等待一小会（20s不到）我们就可以得到模数$1515343657$了（正着找可能要几分钟吧）

这里给出暴力找的CODE

```cpp
#include<cstdio>
#include<cctype>
#define RI register int
#define CI const int&
using namespace std;
const int MR_prime[3]={2,3,61},ST=233333333,MID=1500000000;
const bool tar[50]={0,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0};
inline int quick_pow(int x,int p,int mod,int mul=1)
{
	for (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;
}
inline bool Singer_MR(CI x,CI p)
{
	if (quick_pow(x,p-1,p)!=1) return 0;
	int t=p-1; while (!(t&1))
	{
		t>>=1LL; int val=quick_pow(x,t,p);
		if (val!=1&&val!=p-1) return 0;
		if (val==p-1) return 1;
	}
	return 1;
}
inline bool Miller_Rabin(CI x)
{
	RI i; for (i=0;i<3;++i) { if (x==MR_prime[i]) return 1; if (x%MR_prime[i]==0) return 0; }
	for (i=0;i<3;++i) if (!Singer_MR(MR_prime[i],x)) return 0; return 1;
}
inline bool check(CI mod)
{
	for (RI i=0;i<50;++i) if (quick_pow(ST+i,mod-1>>1,mod)==1&&tar[i]) return 0; return 1;
}
int main()
{
	freopen("gr_mod.txt","w",stdout);
	for (RI i=0;;++i)
	{
		if (Miller_Rabin(MID-i)&&check(MID-i)) { printf("%d %d",MID-i,i); break; }
		if (Miller_Rabin(MID+i)&&check(MID+i)) { printf("%d %d",MID+i,i); break; }
	}
	return 0;
}
```

------

### ALL CODE

```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
#include<cstring>
#define RI register int
#define RL register LL
#define CI const int&
#define CL const LL&
#define Tp template <typename T>
using namespace std;
typedef long long LL;
class FastInputOutput
{
	public:
		int pt[25];
		Tp inline void read(T& x)
		{
			x=0; char ch; while (!isdigit(ch=getchar()));
			while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=getchar()));
		}
		Tp inline void read(T& x,const T& mod)
		{
			x=0; char ch; while (!isdigit(ch=getchar()));
			while (x=(10ull*x+(ch&15))%mod,isdigit(ch=getchar()));
		}
		Tp inline void write(T x)
		{
			if (!x) return (void)(putchar('0'),putchar('\n'));
			if (x<0) putchar('-'),x=-x;
			RI ptop=0; while (x) pt[++ptop]=x%10,x/=10;
			while (ptop) putchar(pt[ptop--]+48); putchar('\n');
		}
}F;
namespace Case1 //19^x%mod
{
	static const int L=101000,st=55244,len=45699;
	int n,val[L+5]; LL x,mod;
	inline void inc(LL& x,CL y)
	{
		unsigned long long t=x+y; x=t>=mod?t-mod:t;
	}
	inline LL quick_mul(LL x,LL y,LL sum=0)
	{
		for (;y;inc(x,x),y>>=1) if (y&1) inc(sum,x); return sum;
	}
	inline LL quick_pow(LL p,LL x=19,LL mul=1)
	{
		for (;p;p>>=1,x=quick_mul(x,x))
		if (p&1) mul=quick_mul(mul,x); return mul;
	}
	inline void work(void)
	{
		for (F.read(n);n;--n) F.read(x,mod-1),F.write(quick_pow(x));
	}
	inline void wa_work(void)
	{
		val[0]=1; for (RI i=1;i<=L;++i) val[i]=19*val[i-1]%mod;
		for (F.read(n);n;--n) F.read(x),F.write(val[x<=st?x:((x-st)%len+st)]);
	}
	/*inline int str_mod(const char *str,CI mod,int ret=0)
	{
		int len=strlen(str); for (RI i=0;i<len;++i)
		ret=((ret<<3)+(ret<<1)+(str[i]&15))%mod; return ret;
	}*/
	inline void solve(void)
	{
		char opt=getchar(); if (opt=='_') return F.read(n),mod=998244353,work();
		if (opt=='w') return F.read(n),mod=998244353,wa_work();
		/*for (RI i=1145099;;++i) if (Miller_Rabin(i))
		{
			if (mod=i,quick_pow(str_mod("627811703016764290815178977207148434322",mod-1))==642666)
			return;
		}*/
		opt=getchar(); if (opt=='+') mod=5211600617818708273LL;	else mod=1145141; work();
	}
};
namespace Case2 //number identify
{
	const int MR_prime[3]={2,3},N=1e6,MX=13123111;
	int n,prime[N+5],id[MX+5],mpr[N+5],mu[N+5],cnt,tot,mod;
	LL l,r,mul[N+5],t; bool vis[MX+5];
	inline LL quick_mul(CL x,CL y,CL mod)
	{
	    LL k=(LL)((1.0L*x*y)/(1.0L*mod)),r=x*y-k*mod;
		r-=mod;	while(r<0LL) r+=mod; return r;
	}
	inline LL quick_pow(LL x,LL p,LL mod,LL mul=1)
	{
		for (;p;p>>=1,x=quick_mul(x,x,mod))
		if (p&1) mul=quick_mul(mul,x,mod); return mul;
	}
	inline bool Singer_MR(CI x,CL p)
	{
		if (quick_pow(x,p-1,p)!=1) return 0;
		LL t=p-1; while (!(t&1))
		{
			t>>=1LL; LL val=quick_pow(x,t,p);
			if (val!=1&&val!=p-1) return 0;
			if (val==p-1) return 1;
		}
		return 1;
	}
	inline bool Miller_Rabin(CL x)
	{
		RI i; for (i=0;i<2;++i) { if (x==MR_prime[i]) return 1; if (x%MR_prime[i]==0) return 0; }
		for (i=0;i<2;++i) if (!Singer_MR(MR_prime[i],x)) return 0; return 1;
	}
	inline void prime_solve(void)
	{
		for (F.read(n);n;--n)
		{
			F.read(l); F.read(r); for (RL i=l;i<=r;++i)
			putchar(Miller_Rabin(i)?'p':'.'); putchar('\n');
		}
	}
	#define Pi prime[j]
	inline void init(CI n)
	{
		vis[1]=mu[1]=1; for (RI i=2;i<=n;++i)
		{
			if (!vis[i]) prime[++cnt]=i,mu[i]=-1;
			for (RI j=1;j<=cnt&&i*Pi<=n;++j)
			{
				vis[i*Pi]=1; if (i%Pi) mu[i*Pi]=-mu[i]; else break;
			}
		}
	}
	inline void mu_solve(void)
	{
		for (init(N),F.read(n);n;--n)
		{
			RI i,j; F.read(l); F.read(r); int len=r-l+1; if (r<=N)
			{
				for (i=l;i<=r;++i) putchar(mu[i]?(~mu[i]?'+':'-'):'0');
				putchar('\n'); continue;
			}
			for (i=1;i<=len;++i) mu[i]=mul[i]=1; for (j=1;j<=cnt;++j)
			for (RL i=1LL*((l-1)/Pi+1)*Pi;i<=r;i+=Pi)
			if (i%(1LL*Pi*Pi)==0) mu[i-l+1]=0; else mu[i-l+1]*=-1,mul[i-l+1]*=Pi;
			for (i=1;i<=len;++i)
			{
				if (!mu[i]) { putchar('0'); continue; }
				if (mul[i]!=i+l-1)
				{
					if (Miller_Rabin(t=(i+l-1)/mul[i])) mu[i]*=-1; else
					{
						LL sq=(LL)sqrt(t); if (sq*sq==t) mu[i]=0;
					}
				}
				if (!mu[i]) putchar('0'); else putchar(~mu[i]?'+':'-');
			} putchar('\n');
		}
	}
	inline void resolve(int x)
	{
		tot=0; for (RI j=1;Pi*Pi<=x;++j) if (x%Pi==0)
		{
			mpr[++tot]=Pi; while (x%Pi==0) x/=Pi;
		}
		if (x>1) mpr[++tot]=x;
	}
	#undef Pi
	inline bool is_GR(CI x)
	{
		for (RI i=1;i<=tot;++i)
		if (quick_pow(x,(mod-1)/mpr[i],mod)==1) return 0; return 1;
	}
	inline void GR_Sieve(CI mod)
	{  
		RI i,j; memset(vis,0,sizeof(vis)); int gr,pfx;
		for (i=1;i<mod;++i) if (is_GR(i)) { gr=i; break; }
		for (i=1,pfx=gr;i<mod;++i,pfx=1LL*pfx*gr%mod) id[pfx]=i;
		for (i=1;i<=tot;++i) for (j=mpr[i];j<mod;j+=mpr[i]) vis[j]=1;
		for (i=1;i<mod;++i) putchar(vis[id[i]]?'.':'g');
	}
	inline void GR_solve(void)
	{
		for (init(1e5),F.read(n);n;--n)
		{
			F.read(l); F.read(r); if (r==234133333) mod=1515343657; else F.read(mod);
			if (mod==998244353||mod==1515343657)
			{
				resolve(mod-1); for (RI i=l;i<=r;++i)
				putchar(is_GR(i)?'g':'.');
			} else resolve(mod-1),GR_Sieve(mod); putchar('\n');
		}
	}
	inline void solve(void)
	{
		char opt=getchar(); switch (opt)
		{
			case 'p':
				prime_solve(); break;
			case 'u':
				mu_solve(); break;
			case 'g':
				GR_solve(); break;
		}
	}
};
int main()
{
	//freopen("software.in","r",stdin); freopen("software.out","w",stdout);
	char opt=getchar(); if (opt=='1') Case1::solve(); else Case2::solve();
	return 0;
}
```

------

### Postscript

至此这道毒瘤题终于宣告终结，不得不说它改变了**传统题**的出题方式

放在赛场上这题就是防AK的绝佳手段，平时肝一肝可以，但是比赛的时候最好还是按照性价比拿分，合理安排吧

最后小声BB一句如果ZJOI也有这种**乱搞题**那不是很有趣（希望吉利二试能了一个心愿）233

---

## 作者：囧仙 (赞：3)

## 题解

这条题目我整整肝了一个晚上+一个上午+一个中午，已经写自闭了……如果没有足够的耐心与时间，不建议挑战这条题目。

### 测试点 $\bm{1\sim 3}$

观察下发的文件 $\textit{\textbf{software1/2/3}}$，容易发现这三个测试点就是要求选手输出 $19^x$ 对一个数字取模的结果。又根据该功能编号 $\verb!1_998244353!$，可以猜测模数为 $998244353$。对于 $\textit{\textbf{software1/2}}$，直接做快速幂；而 $\textit{\textbf{software3}}$ 的指数比较大，我们可以使用费马小定理：

$$a^{p-1}\equiv 1\pmod p$$

将指数对 $998244352$ 取模，然后做快速幂。这部分测试点对应的代码：

```cpp
namespace Sub1{
    int n; const int MOD =998244353;
    int pwr(int x,i64 y){
        int r=1; while(y){
            if(y&1) r=1ll*r*x%MOD; x=1ll*x*x%MOD,y>>=1;
        }
        return r;
    }
    void mian(){
        scanf("%d",&n); up(1,n,i){
            i64 t; char c;
            while(!isdigit(c=getchar())); t=c-'0';
            while( isdigit(c=getchar()))  t=(t*10+c-'0')%(MOD-1);
            printf("%d\n",pwr(19,t));
        }
    }
}
```

### 测试点 $\bm{4}$

观察功能编号，可以发现它与测试点 $1\sim 3$ 的区别在于模数未知。但是可以发现，在 $\textit{\textbf{software4.out}}$ 里的结果都不是很大。事实上，假设输入数据给出的指数随机生成，那么答案的最大值的期望应该是 $p\cdot \dfrac{n-1}{n}$。直接暴力枚举模数，可以得到测试点 $4$ 的模数是 $1145141$。由于其余部分和测试点 $1\sim 3$ 几乎相同（除了测试点 $3$ 要多写个龟速乘），因此就不放出该测试点代码了。

### 测试点 $\bm{5}$

容易发现这个测试点是和测试点 $4$ 同类型的。不过由于 $\textit{\textbf{software5.out}}$ 里的结果非常大，所以暴力枚举是行不通了……

我们需要解决如下方程组：

$$19^{x_i}\equiv y_i\pmod p$$

其中 $x_i,y_i$ 已知，需要求出 $p$。

直接求解方程组中的单个方程是很困难的。但我们可以稍微变形一下，得到如下结果：

$$p\mid (19^{x_i}-y_i)$$

假如 $p\mid a,p\mid b$，那么显然有 $p\mid \gcd(a,b)$。尽管如此，$19^{x_i}-y_i$ 仍会非常大，因此不得不使用高精度 $\text{gcd}$ 进行求解。也许出题人故意放了两个数字，在输入文件中有且仅有两个 $x_i$ 小于 $10^5$，分别是 $2225$ 和 $4572$。其对应的 $y_i$ 分别为 $3348492803508645910$ 和 $4433150361166877220$。更为巧合的是，直接计算对应的 $\text{gcd}$，恰好可以得到该测试点的模数 $5211600617818708273$！

虽然这里写的非常简略，但是光码一个高精度 $\text{gcd}$ 就要码好久……如下是高精度 $\text{gcd}$ 的代码：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e5+3;
int n,A[MAXN],B[MAXN]; char TMP[256];
void wrt(int &l,int W[]){
    dn(l,1,i) printf("%d",W[i]); puts("");
}
void mul(int &l,int *W,int w){
    dn(l,1,i) W[i]*=w;
    up(1,l,i)         W[i+1]+=W[i]/10,W[i]%=10;
    while(W[l+1]) ++l,W[l+1]+=W[l]/10,W[l]%=10;
}
void mns(int &l,int W[],i64 w){
    int t=0; while(w){W[++t]-=w%10; w/=10;}
    up(1,l,i) if(W[i]<0) --W[i+1],W[i]+=10;
    while(l&&!W[l]) --l;
}
bool cmp(int l,int W[],int t,int T[]){
    if(l!=t) return l<t; dn(l,1,i) if(W[i]!=T[i]) return W[i]<T[i];
    return false;
}
void mns(int &l,int W[],int &t,int T[]){
    up(1,t,i) W[i]-=T[i]; up(1,l,i) if(W[i]<0) --W[i+1],W[i]+=10;
    while(l&&!W[l]) --l;
}
void mod(int &l,int W[],int &t,int T[]){
    dn(l-t+1,1,i){
        int u=l-i+1;
        while(!cmp(u,W+l-u,t,T)) mns(u,W+l-u,t,T); l=i+u-1;
    }
}
void gcd(int &l,int W[],int &t,int T[]){
    while(1){
        if(cmp(l,W,t,T)) swap(l,t),swap(W,T); if(!t) break;
        mod(l,W,t,T);
    }
}
int a,b;
int main(){
    FILE * inf=fopen("software5.in" ,"r");
    FILE * anf=fopen("software5.ans","r");
    fgets(TMP,256,inf),fscanf(inf,"%d",&n);
    up(1,n,i){
        i64 x,y;
        fscanf(inf,"%lld",&x);
        fscanf(anf,"%lld",&y);
        if(x<=50000&&x>=10) printf("%lld %lld\n",x,y);
    }
    a=1,A[1]=1,b=1,B[1]=1;
    up(1,2225,i) mul(a,A,19); mns(a,A,3348492803508645910ll);
    up(1,4572,i) mul(b,B,19); mns(b,B,4433150361166877220ll);
    gcd(a,A,b,B),wrt(a,A);
    return 0;
}
```

### 测试点 $\bm {6\sim 7}$

该测试点貌似又回到了测试点 $1\sim 3$ 的形式；不同的是，在功能编号上多出来了一个 $\verb!wa!$，并且打开 $\textit{\textbf{software6/7}}$ 的输出文件，可以发现这里面**存在负数**。

又能发现，这题题面的提示部分特地强调了 $32$ 位有符号整型的溢出问题。又根据这个 $\verb!wa!$，大胆猜测本题的 $19^x$ 在计算的时候发生了溢出。其递推式可能如下：

$$\verb!A[n]=(int)((u32)A[n-1]*(u32)19)%MOD;!$$

暴力模拟，可以发现输出的结果与 $\textit{\textbf{software6}}$ 相吻合，而这证实了我们的猜想。可是打开 $\textit{\textbf{software7}}$，却发现里面的输入数据的值域达到了 $10^{18}$。暴力模拟行不通了。

由于并没有什么非常好的能够解决两次取模的结论，况且还要牵扯到补码，看上去非常不可做……不过，稍加观察可以发现递推式的结果非常随机。根据生日悖论（随机在 $1\sim n$ 中选取一些数字，使得存在两个数字相同，那么期望只要选择 $\sqrt{n}$ 个数字），如果足够随机的话，循环节应该是 $\sqrt{p}$ 左右。写一个简单的打表程序：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
const int MOD =998244353;
map<unsigned,int> M;
int main(){
    int t=1; up(1,1000000,i){
        t=(int)((unsigned)t*(unsigned)19)%MOD;
        if(M[t]){
            printf("id=%d,len=%d\n",i,i-M[t]); return 0;
        } else M[t]=i;
    }
    return 0;
}
```

可以得到，在遍历了 $100944$ 个数后会产生循环节，循环节长度为 $45699$。

那么这部分的代码就很简单了：

```cpp
namespace Sub4{
    const i64 MOD =998244353,MAXN=2e5+3;
    int n,m=106591-45699,t=45699,W[MAXN];
    void mian(){
        W[0]=1; up(1,m+t,i) W[i]=(int)((u32)W[i-1]*(u32)19)%MOD; 
        scanf("%d",&n); up(1,n,i){
            i64 x; scanf("%lld",&x);
            if(x<=m) printf("%d\n",W[x        ]);
            else     printf("%d\n",W[(x-m)%t+m]);
        }
    }
}
```

### 测试点 $\bm {8\sim 10}$

观察文件 $\textit{\textbf{software8/9/10}}$，容易发现，对于每次询问 $(a,b)$，输出的数字的个数恰好为 $b-a+1$ 个，因此可以猜测输出文件应当是区间 $[a,b]$ 内的数字的某种性质。同时经过观察，再结合该功能编号当中的 $\verb!`p'!$，推测第 $i$ 个字符是 $\verb!p!$，当且仅当 $i$ 是质数。

对于测试点 $8$，可以直接埃氏筛/线性筛；对于测试点 $9$，可以直接区间筛；但是对于测试点 $10$，$a,b$ 的范围达到了 $10^{18}$，再筛貌似是很困难了……我在做这个点的时候有两种做法：

#### 做法 $\bm 1$

尽管区间筛的时候，枚举的质数达不到 $\sqrt b$，但是我们可以枚举到 $2\times 10^7$，那么所有含有不超过 $2\times 10^7$ 的质因子的数都已经可以被筛掉。大胆猜想，剩下来的没被筛掉的数字应该是比较少的。

写个程序，统计一下有多少个数字没有被我们筛到（直接比对我们的输出文件和答案文件相比，多出来了多少个字符 $\verb!p!$ 即可）。容易发现，没被筛到的数字才 $9050$ 个。然后统计一下每两个数之间的间距，大概在 $100\sim 500$ 左右。因此可以使用两个字符存储每两个应该被筛掉的合数的间距，总共大概是 $20\text{KB}$，可以塞得下。以下是打表程序：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e6+3;
char A[MAXN],B[MAXN];
const char TAB[]="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
int main(){
    FILE * ouf=fopen("software10.out","r");
    FILE * anf=fopen("software10.ans","r");
    FILE * tmp=fopen("software10.tmp","w");
    up(1,4,i){
        int c=0,l=0;
        fgets(A,MAXN,ouf),fgets(B,MAXN,anf);
        up(0,strlen(A)-1,j)
            if(B[j]!=A[j])
                fprintf(tmp,"%c%c",TAB[(j-l)/62],TAB[(j-l)%62]),++c,l=j;
        printf("%d\n",c);
    }
    return 0;
}
```

#### 做法 $\bm 2$ 

因为区间长度也才 $10^6$，干脆直接用 $\text{Miller-Robin}$ 判断一下不确定的数字是否为质数。由于米勒罗宾算法不是我们的重点，因此想要学习的可以去看[【模板】Pollard-Rho算法](https://www.luogu.com.cn/problem/P4718)。由于 $10^6$ 不算小，所以**注意卡常**。

```cpp
namespace Pri{
    const int MAXM=2e6+3,MAXK=2e7+3;
    int p,P[MAXM]; bool V[MAXK]; int o=2e7;
    void iit(){
        V[1]=true; up(2,o,i){
            if(!V[i]) P[++p]=i;
            for(int j=1;j<=p&&i<=o/P[j];++j){
                V[i*P[j]]=true; if(i%P[j]==0) break;
            }
        }
    }
    i64 mul(i64 x,i64 y,i64 z){
        return ((u64)x*y-(u64)((long double)x/z*y)*z+z)%z;     
    }
    i64 pwr(i64 x,i64 y,i64 z){
        i64 r=1; while(y){
            if(y&1) r=mul(r,x,z); x=mul(x,x,z),y>>=1;
        }
        return r;
    }
    bool mlr(i64 x){
        if(x<=o) return !V[x];
        i64 a=x-1,b=0; while(!(a&1))a>>=1,++b;
        up(1,3,i){
            i64 t=rand()%(x-2)+2,v=pwr(t,a,x),j;
            if(v==1||v==x-1) continue; for(j=1;j<=b;++j){
                if(v==x-1) break; v=mul(v,v,x);
            }
            if(v!=x-1) return false;
        }
        return true;
    }
}
namespace Sub5{
    using namespace Pri;
    const int MAXN=1e6+3; bool U[MAXN];
    void clc(i64 l,i64 r){
        up(l,r,i) U[i-l]=0; up(1,p,i){
            int q=P[i]; if(q>r/q) break;
            up(max(2ll,(l-1)/q+1),r/q,j) U[q*j-l]=true;
        }
        up(l,r,i) if(!U[i-l]) U[i-l]=!mlr(i);
        up(l,r,i) putchar(U[i-l]?'.':'p'); puts("");
    }
    int n;
    void mian(){
        iit(),scanf("%d",&n); up(1,n,i){
            i64 l,r; scanf("%lld%lld",&l,&r); clc(l,r);
        }
    }
}
```

### 测试点 $\bm {11\sim 13}$

根据 $\textit{\textbf{software11/12/13}}$ 的输出文件中的 $\verb!+0-!$ 三种符号，其实就已经可以推出这部分测试点应该是要计算出 $[a,b]$ 内每个元素的**莫比乌斯函数** $\mu$ 的值了（从功能编号的 $\verb!u!$ 也能推测出来）。

然后就比较平凡。对于测试点 $11$ 和 $12$，直接使用区间筛法；对于测试点 $13$ 比较麻烦点（可以参考测试点 $8\sim 10$ 的做法 $1$），我们筛掉每个数字不超过 $2\times 10^7$ 的所有质因子。那么剩下来的还没有被筛掉的部分，**最多还剩下两个质因子**（或者就剩下 $1$，或者剩下一个大于 $2\times 10^7$ 的质因子）。原因在于，$\left(2^{10^7}\right)^3>10^{18}$。巧合的是，在题目给出的区间 $[10^{18}-10^6+1,10^{18}]$ 内不存在任何一个筛去不超过 $2\times 10^7$ 的质因子后，剩下的值为大于 $1$ 的完全平方数的数字。那么我们直接判断一下剩下来的数字是不是质数就行，可以使用刚刚的 $\text{Miller-Robin}$ 算法。

```cpp
namespace Sub6{
    using namespace Pri;
    const int MAXN =1e6+3;
    int M[MAXN]; i64 W[MAXN];
    void clc(i64 l,i64 r){
        up(l,r,i) M[i-l]=1,W[i-l]=i; up(1,p,i){
            int q=P[i]; if(q>r/q) break;
            up(max(2ll,(l-1)/q+1),r/q,j){
                while(W[q*j-l]%q==0) W[q*j-l]/=q;
                if(j%q==0) M[q*j-l]=0; else M[q*j-l]*=-1;
            }
        }
        up(l,r,i) if(W[i-l]!=1&&M[i-l]) M[i-l]*=mlr(W[i-l])?-1:1;
        up(l,r,i) putchar("-0+"[M[i-l]+1]); puts("");
    }
    int n;
    void mian(){
        iit(),scanf("%d",&n); up(1,n,i){
            i64 l,r; scanf("%lld%lld\n",&l,&r); clc(l,r);
        }
    }
}
```

### 测试点 $\bm{14\sim 15}$

根据功能编号当中的 $\verb!g!$，以及输入数据中除了区间 $(a,b)$ 还多出来的一个质数 $p$，推测我们要判断 $[a,b]$ 中每个数字是不是 $p$ 的原根（能不能直接看输出文件看出来，我就不清楚了）。

一个数字 $x$ 是数 $p$ 的原根，当且仅当：

$$\forall q\mid \varphi(p),x^{\varphi(p)\div q}\neq 1\pmod p$$

由于 $p$ 必然是质数，所以 $\varphi(p)=p-1$。测试点 $14$ 直接暴力枚举即可。

很糟糕的是，测试点 $15$ 里有一个质数 $13123111$，并且 $13123110=23\times 19\times 13\times 11\times 7\times 5\times 3\times 2$ 不同的质因数达到了 $8$ 个之多，并且题目给出的区间长度达到了 $1.3\times 10^7$ 的量级，直接使用 $\mathcal O(n\log^2w)$ 的做法显然会超时。

考虑使用线性筛优化这个过程。我们需要对于 $13123110$ 的每个质因子 $q$，计算出 $1\sim p$ 当中每个数字 $i$ 的 $i^{(p-1)\div q}$。因为 $f(x)=x^{k}$（$k$ 为常数）是一个完全积性函数，因此我们当然可以用筛 $\varphi$、$\mu$ 的方法筛出每个数字的 $(p-1)\div q$ 次方了（质数的总数为 $\dfrac{p}{\log p}$ 量级；对于每个质数直接用快速幂 $\mathcal O(\log w)$ 计算，因此总复杂度仍然为线性的）。对于 $13123110$ 的 $8$ 个因子都做一遍就行了。

然后你就会发现这玩意常数是真的大，你得不断地卡常……比如说，把所有 $\text{int}$ 换成无符号整型；将做 $8$ 次线性筛合并成一次线性筛同时处理 $8$ 个质数（本题空间限制 $500\text{MB}$，勉强能开的下去）。$8$ 个质数的乘法建议不要直接使用 $\text{for}$ 循环，而是使用类似于循环展开的方式减小常数。这样处理一下就可以卡过去了。

### 测试点 $\bm{16}$

与测试点 $14\sim 15$ 不同的是，这个测试点没告诉我们 $p$ 的值是啥，只告诉我们 $p\in[10^9,2\times 10^9]$。

问题不太大，想办法枚举出这个 $p$ 即可。具体而言，将这个大区间拆成一堆大小为 $10^6$ 的块（不然空间完全开不下），每个块内使用区间筛法求出所有的质因数。要注意的是，在筛的时候得求出该区间内每个数字的质因数分解，不然对于每个数都做一次 $\mathcal O(\sqrt{p})$ 或者 $\mathcal O(\sqrt[4]{p})$ 的质因数分解会浪费大量时间。然后使用测试点 $14$ 和 $15$ 的办法检查一下该质数是否合法（比对一下和答案的前 $50$ 个字符是否相同就足够了）。写起来还是很麻烦的……最好使用测试点 $14$ 和 $15$ 来检查一下求解程序有没有写错，不然就白跑了。

以下是求出这个 $p$ 的程序。其中，$\textit{\textbf{result.txt}}$ 里边放的是 $\textit{\textbf{software16.ans}}$ 第三行的结果。大概在 $10$ 分钟以内就能出结果了，蛮快的。

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
namespace Pri{
    const int MAXM=2e6+3,MAXK=1e5+3;
    int p,P[MAXM]; bool V[MAXK]; int o=1e5;
    void iit(){
        up(2,o,i){
            if(!V[i]) P[++p]=i;
            for(int j=1;j<=p&&i<=o/P[j];++j){
                V[i*P[j]]=true; if(i%P[j]==0) break;
            }
        }
    }
}
namespace Clc{
    using namespace Pri;
    const int MAXN =1e6+3;
    int X[20][MAXN],C[MAXN];
    void clc(int l,int r){
        up(l,r,i) C[i-l]=0;
        for(int i=1;P[i]<=r/P[i];++i){
            int x=P[i]; for(int j=(l-1)/x+1;j<=r/x;++j){
                X[++C[x*j-l]][x*j-l]=x;
            }
        }
    }
}
const int MAXL =8e5+3;
char TMP[256],S[MAXL];
namespace Slv{
    using namespace Clc;
    int W[30],w;
    int pwr(int x,int y,int z){
        int r=1; while(y){
            if(y&1) r=1ll*r*x%z; x=1ll*x*x%z,y>>=1;
        }
        return r;
    }
    bool chk(int l,int r,int x,int z){
        up(1,w,i){
            if(pwr(x,(z-1)/W[i],z)==1) return false;
        }
        return true;
    }
    void slv(){
        Pri::iit();
        int n=400000,g=233333333;
        for(int l=1e9,r;l<2e9;l=r+1){
            r=l+1e6-1,clc(l,r); printf("[%d,%d]\n",l,r);
            up(l,r,i) if(C[i-l]==0||X[1][i-l]==i){
                int t=i-1,s=t; w=0; up(1,C[t-l],i) {
                    W[++w]=X[i][t-l]; while(s%W[w]==0) s/=W[w];
                }
                if(s!=1) W[++w]=s;
                up(1,n,j){
                    if(".g"[chk(l,r,g+j-1,i)]!=S[j]) goto nxt;
                }
                printf("p=%d\n",i),exit(0);
                nxt:;
            }
        }
    }
}

int main(){
    freopen("result.txt","r",stdin);
    fgets(S+1,MAXL,stdin),Slv::slv();
    return 0;
}
```

可以求出来，测试点 $16$ 的那个 $\verb!`?'!$ 的值应当是 $1515343657$。对于测试点 $14\sim 16$ 可以打包在一个 $\text{namespace}$ 里。

```cpp
namespace Sub7{
    const int MAXN=13123111+5,MAXM=1e6+3;
    #define int u32
    inline int pwr(int x,int y,const int p){
        int r=1; while(y){
            if(y&1) r=1ull*r*x%p; x=1ull*x*x%p,y>>=1;
        }
        return r;
    }
    bool V[MAXN]; int o,P[MAXM],W[MAXN][8];
    void clc(){
        const int p=13123111; int x,c=0; W[1][0]=1;
        for(int i=2;i<=p;++i){
            if(!V[i]){
                P[++o]=i;
                W[i][0]=pwr(i,6561555u,p);W[i][1]=pwr(i,4374370u,p);
                W[i][2]=pwr(i,2624622u,p);W[i][3]=pwr(i,1874730u,p);
                W[i][4]=pwr(i,1193010u,p);W[i][5]=pwr(i,1009470u,p);
                W[i][6]=pwr(i, 690690u,p);W[i][7]=pwr(i, 570570u,p);
            }
            for(int j=1;j<=o;++j) if((x=i*P[j])<=p){
                V[x]=true;
                W[x][0]=1ull*W[i][0]*W[P[j]][0]%p;
                W[x][1]=1ull*W[i][1]*W[P[j]][1]%p;
                W[x][2]=1ull*W[i][2]*W[P[j]][2]%p;
                W[x][3]=1ull*W[i][3]*W[P[j]][3]%p;
                W[x][4]=1ull*W[i][4]*W[P[j]][4]%p;
                W[x][5]=1ull*W[i][5]*W[P[j]][5]%p;
                W[x][6]=1ull*W[i][6]*W[P[j]][6]%p;
                W[x][7]=1ull*W[i][7]*W[P[j]][7]%p;
                if(i%P[j]==0) break;
            } else break;
        }
    }
    #undef int
    int n;
    void mian(){
        scanf("%d",&n); up(1,n,i){
            int l,r,p; scanf("%d%d%d",&l,&r,&p);
            if(l==233333333&&r==234133333) p=1515343657;
            if(p==998244353)
                up(l,r,j){
                    if(pwr(j,(p-1)/2 ,p)!=1
                     &&pwr(j,(p-1)/7 ,p)!=1
                     &&pwr(j,(p-1)/17,p)!=1)
                    putchar('g'); else putchar('.');
                } else
            if(p==13123111){
                clc(); up(l,r,j)
                    if(W[j][0]==1||W[j][1]==1||W[j][2]==1||W[j][3]==1
                     ||W[j][4]==1||W[j][5]==1||W[j][6]==1||W[j][7]==1)
                    X[j]='.'; else X[j]='g';
                fwrite(X+1,1,r-l+1,stdout);
            } else {
                up(l,r,j){
                    if(pwr(j,(p-1)/2 ,p)!=1
                     &&pwr(j,(p-1)/3 ,p)!=1
                     &&pwr(j,(p-1)/4003 ,p)!=1
                     &&pwr(j,(p-1)/15773,p)!=1)
                    putchar('g'); else putchar('.');
                }
            }
            puts("");
        }
    }
}
```

把上面的所有 $\text{namespace}$ 加在一起，最后加上一个主程序，就完工了。

主程序：


```cpp
int main(){
    scanf("%s",S);
    if(!strcmp(S,"1_998244353"  )) Sub1::mian(); else 
    if(!strcmp(S,"1?"           )) Sub2::mian(); else 
    if(!strcmp(S,"1?+"          )) Sub3::mian(); else
    if(!strcmp(S,"1wa_998244353")) Sub4::mian(); else
    if(!strcmp(S,"2p"           )) Sub5::mian(); else 
    if(!strcmp(S,"2u"           )) Sub6::mian(); else 
    if(!strcmp(S,"2g"           )) Sub7::mian(); else 
    if(!strcmp(S,"2g?"          )) Sub7::mian(); 
    return 0;
}
```

因为代码比较长（$200+$ 行），又因为代码的主要部分都已经在上文提及，因此不再赘述。

---

## 作者：fsy_juruo (赞：2)

简要说一下测试点 13 的非打表做法。

首先，先筛出 $2$ ~ $10^7$ 之间的质数。然后，对于给定区间里的数，我们先用这些小于 $10^7$ 的质数去进行分解。过程中注意一旦筛到 $n$ 有平方数因子就把 $\mu (n)$ 直接设为 $0$，且计算筛到质数的乘积。

此时，如果用完小于 $10^7$ 的质数进行分解后，筛到的乘积仍然小于原数，只有以下三种情况：

1. 剩下这个数是质数。
**判断方法：** Miller-Rabin 一遍即可。

2. 剩下这个数是平方数。**判断方法：** 将剩下这个数 sqrt 后判断即可。（有些大佬没判这个也 A 了，为了保险我还是判了）

3. 剩下这个数是两个不同的，大于 $10^7$ 的质数之积。
**只要上述两个条件均不成立，那这个条件自然成立。**

可以证明，剩下的数肯定不会是三个及以上大于 $10^7$ 的质数的乘积。

上非打表代码：  
```cpp
void verdict_mobius() {
    int maxn = 10000000;
    vector<int> prime(maxn + 1), v(maxn + 1);
    int m = 0;
    _rep(i, 2, maxn) { // 此处是线性筛质数
        if(v[i] == 0) {
            v[i] = i; prime[++m] = i;
        }
        _rep(j, 1, m) {
            if(prime[j] > v[i] || prime[j] > maxn / i) break;
            v[i * prime[j]] = prime[j];
        }
    }
    int t; LL L, R;
    read(t);

    while(t--) {
        read(L); read(R);
        vector<LL> num;
        vector<int> miu;
        num.resize(R - L + 1); miu.resize(R - L + 1);
        _rep(i, 0, R - L) { // 初始化
            num[i] = 1; miu[i] = 1; 
        }
        _rep(i, 1, m) {
            for(LL j = (((L - 1) / prime[i] + 1) * prime[i]); j <= R; j += prime[i]) { // 在这一段区间内寻找能被该质数整除的数
                int cnt = 0;
                if(j % ((LL) prime[i] * prime[i]) == 0) miu[j - L] = 0; // 如果 j 能被该质数的平方整除，则直接把该数的莫比乌斯函数设为 0 
                else miu[j - L] = -miu[j - L]; // 否则就将莫比乌斯函数乘 -1 
                num[j - L] *= prime[i]; // 乘上该质数
            }
        }
        _rep(i, 0, R - L) {
            if(miu[i] == 0) {
                putchar('0'); continue;
            } else if(num[i] != i + L) { // 如果筛了一遍，仍然小于原数，证明原数一定有大于 10^7 的因子
                if(miller_rabin((i + L) / num[i], 1)) { // miller-rabin 判断剩下的这个数是不是质数
                    miu[i] *= -1;
                } else { // 判断剩下这个数是不是平方数
                    LL t = (long long)sqrt((i + L) / num[i]);
                    if(t * t == (i + L) / num[i]) miu[i] = 0;
                }
            }
			putchar(miu[i] == 0? '0' : (miu[i] == 1? '+' : '-'));
        }
        putchar('\n');
    }
}
```

---


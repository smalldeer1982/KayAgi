# [HNOI2019] 白兔之舞

## 题目背景

HNOI2019 day2t2

## 题目描述

有一张顶点数为 $(L+1)\times n$ 的有向图。这张图的每个顶点由一个二元组$(u,v)$表示$(0\le u\le L,1\le v\le n)$。
这张图不是简单图，对于任意两个顶点 $(u_1,v_1)(u_2,v_2)$，如果 $u_1<u_2$，则从 $(u_1,v_1)$ 到 $(u_2,v_2)$ 一共有 $w[v_1][v_2]$ 条不同的边，如果 $u_1\ge u_2$ 则没有边。

白兔将在这张图上上演一支舞曲。白兔初始时位于该有向图的顶点 $(0,x)$。

白兔将会跳若干步。每一步，白兔会从当前顶点沿任意一条出边跳到下一个顶点。白兔可以在任意时候停止跳舞（也可以没有跳就直接结束）。当到达第一维为 $L$ 的顶点就不得不停止，因为该顶点没有出边。

假设白兔停止时，跳了 $m$ 步，白兔会把这只舞曲给记录下来成为一个序列。序列的第 $i$ 个元素为它第 $i$ 步经过的边。

问题来了：给定正整数 $k$ 和 $y$（$1\le y\le n$），对于每个 $t$（$0\le t<k$），求有多少种舞曲（假设其长度为 $m$）满足 $m \bmod k=t$，且白兔最后停在了坐标第二维为 $y$ 的顶点？

两支舞曲不同定义为它们的长度（$m$）不同或者存在某一步它们所走的边不同。

输出的结果对 $p$ 取模。


## 说明/提示

### 样例解释 1
$t=0$：
1. 路径长度为 $0$，方案数为 $1$。
2. 路径长度为 $2$，一共有六类路径：
    - $(0,1)\to (1,1)\to (2,1)$ 该路径有 $w(1,1)\times w(1,1)=4$ 条；
    - $(0,1)\to (1,1)\to (3,1)$ 该路径有 $w(1,1)\times w(1,1)=4$ 条；
    - $(0,1)\to (2,1)\to (3,1)$ 该路径有 $w(1,1)\times w(1,1)=4$ 条；
    - $(0,1)\to (1,2)\to (2,1)$ 该路径有 $w(1,2)\times w(2,1)=1$ 条；
    - $(0,1)\to (1,2)\to (3,1)$ 该路径有 $w(1,2)\times w(2,1)=1$ 条；
    - $(0,1)\to (2,2)\to (3,1)$ 该路径有 $w(1,2)\times w(2,1)=1$ 条；

答案就为 $1+4+4+4+1+1+1=16$。

$t=1$：
1. 路径长度为 $1$，一共有三类路径：
    - $(0,1)\to (1,1)$ 该路径有 $w(1,1)=2$ 条；
    - $(0,1)\to (2,1)$ 该路径有 $w(1,1)=2$ 条；
    - $(0,1)\to (3,1)$ 该路径有 $w(1,1)=2$ 条；
2. 路径长度为 $3$，一共有三类路径：
    - $(0,1)\to (1,1)\to (2,1)\to (3,1)$ 该路径有 $w(1,1)\times w(1,1)\times w(1,1)=8$ 条；
    - $(0,1)\to (1,1)\to (2,2)\to (3,1)$ 该路径有 $w(1,1)\times w(1,2)\times w(2,1)=2$ 条；
    - $(0,1)\to (1,2)\to (2,1)\to (3,1)$ 该路径有 $w(1,2)\times w(2,1)\times w(1,1)=2$ 条；

答案就为 $2+2+2+8+2+2=18$。

### 数据范围

对于全部数据，$p$ 为一个质数，$10^8<p<2^{30}$，$1\le n\le 3$，$1\le x\le n$，$1\le y\le n$，$0\le w(i,j)<p$，$1\le k\le 65536$，$k$ 为 $p-1$ 的约数，$1\le L\le 10^8$。

对于每组测试点，特殊限制如下：
- 测试点 $1,2$：$L\le 10^5$；
- 测试点 $3$：$n=1,w(1,1)=1$，$k$ 的最大质因子为 $2$；
- 测试点 $4$：$n=1$，$k$ 的最大质因子为 $2$；
- 测试点 $5$：$n=1,w(1,1)=1$；
- 测试点 $6$：$n=1$；
- 测试点 $7,8$：$k$ 的最大质因子为 $2$。

## 样例 #1

### 输入

```
2 2 3 1 1 998244353
2 1
1 0```

### 输出

```
16
18```

## 样例 #2

### 输入

```
3 4 100 1 3 998244353
1 1 1
1 1 1
1 1 1```

### 输出

```
506551216
528858062
469849094
818871911
```

# 题解

## 作者：zhoukangyang (赞：16)

upd : 把所有 `C` 的符号换成了 `binom`

## 蒟蒻语
这是蒟蒻的第 $500$ 道 AC, 第 $30$ 道黑题, 写篇题解祭一下 qwq

开始全 T 以为是自己打挂了， 结果开了 O2 就 AC 了qwq
## 蒟蒻解
假设白兔跳了 $i$ 次。

那么如果枚举选择这 $i$ 个点跳这 $i$ 次有多少选择 $x$ 坐标的方案(白兔每一个点坐标为 $(x, y)$ )。

显然是从 $L$ 个中选择 $i$ 个， 就是 $\binom{L}{i}$

如果要求白兔跳了 $i$ 次有多少 $(x, y)$ 的方案数 $f_i$。

而 $x, y$ 是互相不影响的, 那么现在只要算跳 $i$ 次时这 $i$ 个 $y$ 的方案个数了。

那么考虑 $dp[i][y]$ 表示选择 $i$ 个点中选择 $y$ 坐标的方案个数。

$dp[i][j] = \sum\limits_{k=1}^{n} dp[i-1][k] * w[k][j]$

显然用矩阵优化

现在定义 $W$ 是转移矩阵, 可以直接用题目中的 $w$。

$dp[i][y] = G * W^i$ 的第 $y$ 项

那么 $f_i = \binom{L}{i} * dp[i][y]$

$$ans_t = \sum\limits_{i = 0}^L [i \ mod \ k = t] f_i$$

$$= \sum\limits_{i=0}^L [k | (i - t)] f_i$$

$$= \sum\limits_{i=0}^L f_i \frac{1}{k} \sum\limits_{j = 0}^{k-1} \omega_k^{j(i-t)}$$

$$= \frac{1}{k} \sum\limits_{i=0}^L f_i \sum\limits_{j = 0}^{k-1}(\omega_k^{-it} \omega_k^{ij})$$

$$= \frac{1}{k} \sum\limits_{j = 0}^{k-1}\omega_k^{-jt} \sum\limits_{i=0}^L \omega_{k}^{ij} f_i$$

$$= \frac{1}{k} \sum\limits_{j = 0}^{k-1}\omega_k^{-jt} \sum\limits_{i=0}^L \omega_{k}^{ij} \binom{L}{i} * G * W^i \ \ \text{的第 $y$ 项}$$ 

$$= \frac{1}{k} \sum\limits_{j = 0}^{k-1} G * \omega_k^{-jt} \sum\limits_{i=0}^L (\omega_{k}^{j})^i \binom{L}{i} *   W^i \ \ \text{的第 $y$ 项}$$ 


$$= \frac{1}{k} \sum\limits_{j = 0}^{k-1} G * \omega_k^{-jt}(\omega_{k}^{j} W+I)^L \ \ \text{的第 $y$ 项}$$ 

设 $h_i = G(\omega_{k}^{j} W+I)^L  \ \ \text{的第 y  项}$

$$ans_t = \frac{1}{k} \sum\limits_{i = 0}^{k-1} \omega_k^{-it} h_i$$


因为 $it = \binom{i+t}{2} - \binom{i}{2} - \binom{t}{2}$

$$ans_t = \frac{1}{k} \sum\limits_{i = 0}^{k-1} \omega_k^{- \binom{i+t}{2} + \binom{i}{2} + \binom{t}{2}} h_i$$

$$ans_t = \frac{1}{k} \sum\limits_{i = 0}^{k-1} \omega_k^{-\binom{i+t}{2}} \omega_{k}^{\binom{t}{2}}\omega_k^{\binom{i}{2}} h_i$$

$$ans_t = \frac{\omega_k^{\binom{t}{2}}}{k}\sum\limits_{i = 0}^{k-1} \omega_k^{-\binom{i + t}{2}} \omega_k^{\binom{i}{2}} h_i$$

设 $F(i) = \frac{\omega_k^{\binom{i}{2}}}{k}$, $P(i) = \omega_k^{\binom{i}{2}} h_i, S(i) = \omega_k^{-\binom{i}{2}}$

$$ans_t = F(t) \sum\limits_{i = 0}^{k - 1}P(i)S(i + t)$$

接下来是 $reverse$ 一下 $S, ans \ \ (S, ans\text{长度为}2k)$

$$ans_{2k - t - 1} = F(t) \sum\limits_{i=0}^{k-1} P(i)S(2k - 1 - i - t)$$

$$ans_t = F(2k - t - 1) \sum\limits_{i=0}^{k-1} P(i) S(t - i)$$

由于 $t > k - 1$, 所以:

$$ans_t = F(2k - t - 1) \sum\limits_{i=0}^{t} P(i) S(t - i)$$

直接 $\tt MTT$ 卷就好了

## 蒟蒻码
```cpp
#include<bits/stdc++.h>
#define db long double
#define N 800010
#define ll long long
using namespace std;
int n, k, L, x, y, mod, pp[N];
struct CP {
	db x, y;
	CP (db xx = 0, db yy = 0) {
		x = xx, y = yy;
	}
};
int fac[123], cnt, omg, omk;
void getfac(int x) {
	for(int i = 2; i <= sqrt(x); i++) 
		if(x % i == 0) {
			fac[++cnt] = i;
			while(x % i == 0) x /= i;
		}
}
int qpow(int x, int y, int pmod) {
	int res = 1;
	if(x == 0) return 0;
	for(; y; x = 1ll * x * x % pmod, y >>= 1) if(y & 1) res = 1ll * res * x % pmod;
	return res;
}
bool cheak(int x) {
	for(int i = 1; i <= cnt; i++) 
		if(qpow(x, (mod - 1) / fac[i], mod) == 1) return 0;
	return 1;
}
void find() {
	getfac(mod - 1);
	for(int i = 2; i < mod; i++) 
		if(cheak(i)) {
			omg = i;
			return;
		} 
}
db pi = acos(-1);
CP operator + (CP aa, CP bb) {
	return CP(aa.x + bb.x, aa.y + bb.y);
}
CP operator - (CP aa, CP bb) {
	return CP(aa.x - bb.x, aa.y - bb.y);
}
CP operator * (CP aa, CP bb) {
	return CP(aa.x * bb.x - aa.y * bb.y, aa.x * bb.y + aa.y * bb.x);
}
CP operator / (CP aa, db bb) {
	return CP(aa.x / bb, aa.y / bb);
}
struct Matrix {
	int a[4][4];
} S;
Matrix operator * (Matrix aa, Matrix bb) {
	Matrix res;
	for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) res.a[i][j] = 0;
	for(int i = 1; i <= n; i++) 
		for(int j = 1; j <= n; j++) 
			for(int k = 1; k <= n; k++) 
				(res.a[i][j] += 1ll * aa.a[i][k] * bb.a[k][j] % mod) %= mod;
	return res;
}
Matrix operator * (Matrix aa, int bb) {
	Matrix res;
	for(int i = 1; i <= n; i++) 
		for(int j = 1; j <= n; j++) 
			res.a[i][j] = 1ll * aa.a[i][j] * bb % mod;
	return res;
}
Matrix ps(Matrix aa) {
	Matrix res;
	for(int i = 1; i <= n; i++) 
		for(int j = 1; j <= n; j++) 
			res.a[i][j] = (aa.a[i][j] + (i == j)) % mod;
	return res;
}
Matrix operator ^ (Matrix aa, int bb) {
	Matrix res;
	for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) res.a[i][j] = 0;
	for(int i = 1; i <= n; i++) res.a[i][i] = 1;
	for(; bb; aa = aa * aa, bb >>= 1) if(bb & 1) res = res * aa;
	return res;
}
void FFT(CP *f, int len, int flag) {
	for(int i = 0; i < len; i++) if(pp[i] < i) swap(f[pp[i]], f[i]);
	for(int i = 2; i <= len; i <<= 1) {
		int FL = (i >> 1);
		CP ch(cos(2 * pi / i), flag * sin(2 * pi / i));
		for(int j = 0; j < len; j += i) {
			CP now(1, 0);
			for(int k = j; k < j + FL; k++) {
				CP Ga = f[k], Gb = f[k + FL] * now;
				f[k] = Ga + Gb, f[k + FL] = Ga - Gb, now = now * ch;
			}
		}
	}
	if(flag == -1) for(int i = 0; i < len; i++) f[i].x = f[i].x / len;
}
CP fa[N], fb[N], ga[N], gb[N], ssB[N], sB[N], B[N];
void MTT(int *a, int *b, int *c, int len) {
	int flen;
	for(flen = 1; flen <= len * 2; flen <<= 1);
	for(int i = 0; i < flen; i++) pp[i] = ((pp[i >> 1] >> 1) | ((i & 1) * (flen >> 1)));
	for(int i = 0; i < flen; i++) fa[i].x = (a[i] >> 15), fb[i].x = (a[i] & 32767);
	for(int i = 0; i < flen; i++) ga[i].x = (b[i] >> 15), gb[i].x = (b[i] & 32767);
	FFT(fa, flen, 1), FFT(fb, flen, 1), FFT(ga, flen, 1), FFT(gb, flen, 1);
	for(int i = 0; i < flen; i++) {
		ssB[i] = fa[i] * ga[i];
		sB[i] = (fa[i] * gb[i]) + (fb[i] * ga[i]);
		B[i] = fb[i] * gb[i];
	}
	FFT(ssB, flen, -1), FFT(sB, flen, -1), FFT(B, flen, -1);
	for(int i = 0; i < flen; i++) {
		ll dssB = (ll)(ssB[i].x + 0.49) % mod;
		ll dsB = (ll)(sB[i].x + 0.49) % mod;
		ll dB = (ll)(B[i].x + 0.49) % mod;
		c[i] = (0ll + (dssB << 30) % mod + (dsB << 15) % mod + dB) % mod;
	}
}
int C(int x) {
	return 1ll * x * (x - 1) / 2 % (mod - 1); 
}
int h[N], F[N], P[N], s[N], ans[N];
void init() {
	omk = qpow(omg, (mod - 1) / k, mod);
	int nyk = qpow(k, mod - 2, mod);
	for(int i = 0; i < k; i++) {
		h[i] = (ps((S * qpow(omk, i, mod))) ^ L).a[x][y];
		P[i] = 1ll * qpow(omk, C(i), mod) * h[i] % mod;
	}
	k <<= 1;
	for(int i = 0; i < k; i++) {
		F[i] = 1ll * qpow(omk, C(i), mod) * nyk % mod;
		s[i] = qpow(omk, mod - 1 - C(i), mod);
	}
	reverse(s, s + k);
	MTT(P, s, ans, k);
	// for(int t = 0; t < k; t++) 
		// for(int i = 0; i <= t; i++) 
			// (ans[t] += 1ll * P[i] * s[t - i] % mod) %= mod;
	reverse(ans, ans + k);
	for(int i = 0; i < (k >> 1); i++) ans[i] = 1ll * ans[i] * F[i] % mod, printf("%d\n", ans[i]);
}
int main() {
	scanf("%d%d%d%d%d%d", &n, &k, &L, &x, &y, &mod), find();
	for(int i = 1; i <= n; i++) 
		for(int j = 1; j <= n; j++) 
			scanf("%d", &S.a[i][j]);
	init();
	return 0;
}
```

---

## 作者：CTime_Pup_314 (赞：13)

公式渲染可能会有问题，请在博客中查看

很显然，设答案序列为 $a$ 则有

$$
a_t=\sum_{i=0}^L\binom{L}{i}w^i_{x,y}[i\operatorname{mod}k=t]
$$

由单位根反演

$$
[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ki}
$$

带入答案式子就有

$$
a_t=\sum_{i=0}^L\binom{L}{i}w_{x,y}^i\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{(i-t)j}
$$

我们交换求和顺序

$$
a_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^L\binom{L}{i}w_{x,y}^i\omega_k^{ij}
$$

后面的部分用二项式定理得

$$
a_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^jw+e)^L_{x,y}
$$

我们考虑多项式

$$
f(x)=\frac{1}{k}\sum_{j=0}^{k-1}x^j(\omega_k^jw+e)^L_{x,y}
$$

那么有

$$
a_t=f(\omega_k^{-t})
$$

单位根的求值可以用 `FFT` 快速求出，但前提是在项数为 $2$ 的整数次幂的情况下，如果我们要做任意长度的 `DFT` 那么就需要用 `Bluestein's Algorithm` 具体细节如下

考虑 `DFT` 的形式

$$
y_j=\sum_{i=0}^{n-1}a_i(\omega_n^j)^i
$$

根据 $ij=\binom{i+j}{2}-\binom{i}{2}-\binom{j}{2}$ 可以得到

$$
y_j=\omega_n^{-\binom{j}{2}}\sum_{i=0}^{n-1}a_i\omega_n^{-\binom{i}{2}}\omega_n^{\binom{i+j}{2}}
$$

如果设

$$
f=\sum_{i=0}^{n-1}a_i\omega_n^{-\binom{i}{2}}x^i
$$

$$
g=\sum_{i=0}^{2n-2}\omega_n^{\binom{2n-2-i}{2}}x^i
$$

则

$$
y_j=\omega_n^{-\binom{j}{2}}[x^{2n-2-j}]{(f\times g)}
$$

而后者就是一个普通的卷积

接着，我们考虑 `IDFT`

$$
c_j=\frac{1}{n}\sum_{i=0}^{n-1}a_i\omega_n^{-ij}
$$

其实与上面同理，只不过是符号变了罢了

若我们考虑模 $p$ 意义下的原根 $g$，用 $g^{\frac{p-1}{k}}$ 来代替 $\omega_k$ 的话，就用拆系数 `FTT` 即可

计算一下总复杂度为 $\operatorname{O}(\Delta+kn^3\log L+k\log k)$ 最前面是求原根的复杂度

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long i64;
typedef double f64;
inline int read(int f = 1, int x = 0, char ch = ' ')
{
    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;
    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();
    return f*x;
}
const int N = 3, K = 1<<18|5; const f64 PI = acos(-1);
int n, k, kinv, L, x, y, P, gn, g[K], f[K];
struct Mat
{
    i64 A[N][N];
    Mat() { memset(A, 0, sizeof(A)); }
    i64* operator [] (const int i) { return A[i]; }
    friend Mat operator * (Mat A, Mat B)
    {
        Mat C;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                for(int k = 0; k < n; ++k)
                    C[i][j] = (C[i][j]+A[i][k]*B[k][j]%P)%P;
        return C;
    }
    friend Mat operator * (int k, Mat A)
    {
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                A[i][j] = k*A[i][j]%P;
        return A;       
    }
    friend Mat operator + (Mat A, Mat B)
    {
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                A[i][j] = (A[i][j]+B[i][j])%P;
        return A;
    }
    void set() { for(int i = 0; i < n; ++i) A[i][i] = 1; }
    friend Mat operator ^ (Mat A, int b)
    {
        Mat ret; ret.set();
        for( ; b; b >>= 1, A = A*A) if(b&1) ret = ret*A;
        return ret;
    }
}w, e;
i64 qpow(i64 a, int b) { i64 ret = 1; for( ; b; b >>= 1, a = a*a%P) if(b&1) ret = ret*a%P; return ret; }
void groot()
{
    vector<int> p; int n = P-1;
    for(int i = 2, t = sqrt(n); i <= n; ++i)
        if(n%i == 0) { p.push_back(i); while(n%i == 0) n /= i; }
    if(n != 1) p.push_back(n);
    for(gn = 1; ; ++gn)
    {
        int i = 0; for( ; i < p.size()&&qpow(gn, (P-1)/p[i]) != 1; ++i);
        if(i == p.size()) break;
    }
    gn = qpow(gn, (P-1)/k), g[0] = 1;
    for(int i = 1; i < k; ++i) g[i] = 1ll*g[i-1]*gn%P;
}
namespace Bluestein
{
struct C
{
    f64 a, b;
    C(f64 a = 0, f64 b = 0):a(a), b(b) {};
    friend C operator + (C a, C b) { return C(a.a+b.a, a.b+b.b); }
    friend C operator - (C a, C b) { return C(a.a-b.a, a.b-b.b); }
    friend C operator * (C a, C b) { return C(a.a*b.a-a.b*b.b, a.a*b.b+a.b*b.a); }
    C operator ~ () { return C(a, -b); }
}w[K], S[K], T[K];
int lim, rev[K], C2[K];
void prepare(int ti)
{
    for(lim = 1; lim <= ti; lim <<= 1);
    for(int i = 0, j = 0; i < lim; ++i)
    {
        w[i] = C(cos(2*PI*i/lim), sin(2*PI*i/lim)), rev[i] = j;
        for(int k = lim>>1; (j ^= k) < k; k >>= 1);
    }
}
struct Poly
{
    vector<int> A; vector<C> B;
    int& operator [] (const int i) { return A[i]; }
    void set(int ti) { A.resize(ti+1); }
    int ti() { return A.size()-1; }
    void clear() { return B.clear(); } 
    void init() 
    { 
        int n = ti(); B.resize(n+1); 
        for(int i = 0; i <= n; ++i) B[i] = C(A[i]>>15, A[i]&32767);
    }
    void FFT(int t)
    {
        if(!t)
        {
            B.resize(lim); for(int i = 0; i < lim; ++i) if(i < rev[i]) swap(B[i], B[rev[i]]);
            for(int mid = 1; mid < lim; mid <<= 1)
                for(int j = 0, len = mid<<1; j < lim; j += len)
                    for(int k = 0, p = 0, q = lim/len; k < mid; ++k, p += q)
                    {
                        C x = B[j+k], y = w[p]*B[j+k+mid];
                        B[j+k] = x+y, B[j+k+mid] = x-y;
                    }
        }
        else
        {
            reverse(++B.begin(), B.end()), FFT(0); C v(1.0/lim, 0);
            for(int i = 0; i < lim; ++i) B[i] = B[i]*v;
        }
    } 
    friend Poly operator * (Poly A, Poly B)
    {
        int n = A.ti(), m = B.ti(); prepare(n+m), A.init(), B.init();
        A.FFT(0), B.FFT(0); C p, q, a, b, c, d;
        for(int i = 0; i < lim; ++i)
        {
            p = A.B[i], q = ~A.B[i?lim-i:0], a = (p+q)*C(0.5, 0), b = (p-q)*C(0, -0.5);
            p = B.B[i], q = ~B.B[i?lim-i:0], c = (p+q)*C(0.5, 0), d = (p-q)*C(0, -0.5);
            S[i] = a*c+b*d*C(0, 1), T[i] = a*d+b*c;
        }
        for(int i = 0; i < lim; ++i) A.B[i] = S[i], B.B[i] = T[i];
        A.FFT(1), B.FFT(1), A.set(n+m);
        for(int i = 0; i <= n+m; ++i)
        {
            i64 a = A.B[i].a+0.5, b = B.B[i].a+0.5, c = A.B[i].b+0.5;
            A[i] = (a%P*(1<<30)+b%P*(1<<15)+c)%P, A[i] = (A[i]+P)%P;
        }
        A.clear(), B.clear(); return A;
    }
};
void solve(int *a, int n)
{
    Poly F, G; F.set(n-1), G.set((n-1)<<1);
    for(int i = 1; i < (n-1)<<1; ++i) C2[i+1] = (C2[i]+i)%n;
    for(int i = 0; i < n; ++i) F[i] = 1ll*a[i]*g[C2[i]?n-C2[i]:0]%P;
    for(int i = 0; i <= (n-1)<<1; ++i) G[i] = g[C2[(n-1)*2-i]];
    F = F*G; for(int i = 0; i < n; ++i) a[i] = 1ll*g[C2[i]?n-C2[i]:0]*F[(n-1)*2-i]%P;
}
}
int main()
{
    n = read(), k = read(), L = read(), x = read()-1, y = read()-1, P = read();
    kinv = qpow(k, P-2), e.set(), groot();
    for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) w[i][j] = read();
    for(int i = 0; i < k; ++i) f[i] = kinv*((g[i]*w+e)^L)[x][y]%P;   
    Bluestein::solve(f, k);
    for(int i = 0; i < k; ++i) printf("%d\n", f[i?k-i:0]);
    return 0;
}
```

---

## 作者：λᴉʍ (赞：12)

先膜一发memset0，但是memset0有些地方写的不是很清楚，只有他这样的巨佬才能知道是啥意思（我这种弱的就要问N遍）（说得好像我写的很清楚一样），所以我再水一篇

显然$n=3$就是$n=1$的扩展版本，先来看看$n=1$怎么做。

令$W=w[1][1]$，显然答案是：$ans_t=\sum_{i\mod k=t}^{L}W^i\binom{L}{i}$

$=\sum_{i=0}^{L}[k|(i-t)]W^i\binom{L}{i}$

这时用一个单位根反演。

回顾一下，单位根是fft时用到的东西，$\omega_{n}=\cos\frac{2\pi}{n}+\sin\frac{2\pi}{n}i$，在膜$p$意义下，求出$p$的原根$g$，$\omega_{n}=g^{\frac{p-1}{n}}$。

有一些单位根的性质：

$\omega_n^i=\omega_n^{i\mod n}$

$\omega_n^i=-\omega_n^{i+\frac{n}{2}}$

单位根反演是这个东西：

$\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^k)^i=[n|k]$。

证明分类讨论：如果$n|k$，根据上面性质$\omega_n^k=\omega_n^0=1$；否则这是一个等比数列，公比为$\omega_{n}^k$，求和为$\frac{1-\omega_n^{kn}}{1-\omega_n^k}$，上面的这个东西是$0$。

将单位根反演套进上面式子，代替$[k|(i-t)]$。

$=\sum_{i=0}^{L}\frac{1}{k}\sum_{j=0}^{k-1}(\omega_k^{i-t})^jW^i\binom{L}{i}$

$=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L}W^i\omega_k^{ij}\binom{L}{i}$

后面这个式子和t没什么关系了，可以统一计算，好像这是个二项式，可以直接算：

$=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L}\binom{L}{i}(W\omega_k^j)^i1^{n-i}$

$=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^jW+1)^L$

后面这东西只和j有关系，可以提前随便算出来，记为$c_j$

$=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}c_j$

然后神仙一波操作，$-tj=\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}$

$=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}c_j$

$=\frac{1}{k}\omega_k^{\binom{t}{2}}\sum_{j=0}^{k-1}\omega_k^{\binom{j}{2}-\binom{t+j}{2}}c_j$

$=\frac{1}{k}\omega_k^{\binom{t}{2}}\sum_{j=0}^{k-1}\omega_k^{\binom{j}{2}}c_j\cdot \omega_k^{-\binom{t+j}{2}}$

这就是个多项式乘法了，注意t+j那个多项式直接reverse一下，我真的越学越蠢了，不知道这个怎么搞自闭1h

然后因为模数不是ntt模数还要用MTT

好的$n=1$做完了，$n=3$实际上就是把$n=1$的$W$换成了输入的矩阵。于是只要修改一下$c_i$的求法，先算出$(Begin\cdot(\omega_k^jW)+I)^L$，Begin就是初始矩阵，只有$1,x$处是1，再取最终结果需要取的$1,y$处的值就行了


```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
typedef long long ll;
il ll gi(){
    ll x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const double pi=acos(-1);
int m,k,n,x,y,mod,G;
struct matrix{
    int s[3][3];matrix(){memset(s,0,sizeof s);}
};
matrix I;
int omega[65539];
il matrix operator+(const matrix&a,const matrix&b){
    matrix ret;
    for(int i=0;i<3;++i)
        for(int j=0;j<3;++j){
            ret.s[i][j]=a.s[i][j]+b.s[i][j];
            if(ret.s[i][j]>=mod)ret.s[i][j]-=mod;
        }
    return ret;
}
il matrix operator*(const matrix&a,const matrix&b){
    matrix ret;
    for(int j=0;j<3;++j)
        for(int i=0;i<3;++i)
            for(int k=0;k<3;++k)
                ret.s[i][k]=(ret.s[i][k]+1ll*a.s[i][j]*b.s[j][k])%mod;
    return ret;
}
il matrix operator*(const matrix&a,const int&b){
    matrix ret;
    for(int i=0;i<3;++i)
        for(int j=0;j<3;++j)
            ret.s[i][j]=1ll*a.s[i][j]*b%mod;
    return ret;
}
matrix w;
int A[262147],B[262147];
il int pow(int x,int y){
    int ret=1;
    while(y){
        if(y&1)ret=1ll*ret*x%mod;
        x=1ll*x*x%mod;y>>=1;
    }
    return ret;
}
il matrix pow(matrix x,int y){
    matrix ret=I;
    while(y){
        if(y&1)ret=ret*x;
        x=x*x;y>>=1;
    }
    return ret;
}
il int getrt(int x){
    static int p[50],o=0;
    for(int i=2,y=x-1;i<=y;++i)
        if(y%i==0){
            p[++o]=i;
            while(y%i==0)y/=i;
        }
    for(int g=2;;++g){
        bool yes=1;
        for(int j=1;j<=o;++j)if(pow(g,(mod-1)/p[j])==1){yes=0;break;}
        if(yes)return g;
    }
}
typedef std::complex<double> cp;
int rev[262147];cp omg[262147];
cp A1[262147],A2[262147],B1[262147],B2[262147];
il vd fft(cp*A,int n){
    for(int i=0;i<n;++i)if(rev[i]>i)std::swap(A[i],A[rev[i]]);
    for(int o=1;o<n;o<<=1)
        for(cp*p=A;p!=A+n;p+=o<<1)
            for(int i=0;i<o;++i){
                cp t=omg[n/(o<<1)*i]*p[i+o];
                p[i+o]=p[i]-t,p[i]+=t;
            }
}
int ans[262147];
int main(){
#ifdef XZZSB
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    I.s[0][0]=I.s[1][1]=I.s[2][2]=1;
    m=gi(),k=gi(),n=gi(),x=gi()-1,y=gi()-1,mod=gi();
    omega[0]=1;omega[1]=pow(G=getrt(mod),(mod-1)/k);
    for(int i=2;i<k;++i)omega[i]=1ll*omega[1]*omega[i-1]%mod;
    for(int i=0;i<m;++i)for(int j=0;j<m;++j)w.s[i][j]=gi();
    for(int i=0;i<(k<<1|1);++i)A[i]=omega[(k-1ll*i*(i-1)/2%k)%k];
    matrix begin;begin.s[0][x]=1;
    for(int i=0;i<k;++i)B[i]=1ll*omega[1ll*i*(i-1)/2%k]*(begin*pow(w*omega[i]+I,n)).s[0][y]%mod;
    std::reverse(B,B+k+1);
    int N=1,lg=0;while(N<(k*3+5))N<<=1,++lg;
    for(int i=0;i<N;++i)omg[i]=(cp){cos(i*pi*2/N),sin(i*pi*2/N)};
    for(int i=0;i<N;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<lg-1);
    for(int i=0;i<N;++i)A1[i]=A[i]&32767,A2[i]=A[i]>>15;
    for(int i=0;i<N;++i)B1[i]=B[i]&32767,B2[i]=B[i]>>15;
    fft(A1,N),fft(B1,N);fft(A2,N),fft(B2,N);
    for(int i=0;i<N;++i){
        cp _A1=A1[i],_A2=A2[i],_B1=B1[i],_B2=B2[i];
        A1[i]=_A1*_B1;A2[i]=_A2*_B2;
        B1[i]=_A1*_B2;B2[i]=_A2*_B1;
    }
    for(int i=0;i<N;++i)omg[i]=(cp){cos(i*pi*2/N),-sin(i*pi*2/N)};
    fft(A1,N),fft(B1,N);fft(A2,N),fft(B2,N);
    for(int i=0;i<N;++i)A1[i]/=N;
    for(int i=0;i<N;++i)A2[i]/=N;
    for(int i=0;i<N;++i)B1[i]/=N;
    for(int i=0;i<N;++i)B2[i]/=N;
    for(int i=0;i<N;++i)A[i]=((ll)(A1[i].real()+0.5)%mod+1073741824ll*(((ll)(A2[i].real()+0.5))%mod)%mod+32768ll*(((ll)(B1[i].real()+0.5))%mod)%mod+32768ll*(((ll)(B2[i].real()+0.5))%mod)%mod)%mod;
    int invk=pow(k,mod-2);
    for(int i=0;i<k;++i)printf("%lld\n",1ll*A[i+k]*invk%mod*omega[1ll*i*(i-1)/2%k]%mod);
    return 0;
}
```

---

## 作者：myee (赞：8)

### 前言

~~我是卡老师，我 10min IP 赋，30min 贺白兔之舞！~~

联赛前单走一个多项式颓废记录。

刚学的 CZT，趁着热乎过来切白兔之舞并写篇题解。

---
### 思路

设 $f_{i,j}$ 表示白兔选 $i$ 个落脚点，最后一步所对应的第二维坐标是 $j$ 的方案数，而另设 $g$ 使 $f_{i,j}=\binom Lig_{i,j}$，即 $g$ 表示选完 $i$ 个落脚点后的答案。

那么我们得到一个很 naive 的 dp 式：

$$g_{i,j}=\sum_kg_{i-1,k}w_{k,j}$$

这个显然可以矩阵优化。

记 $\vec g_i=(g_{ij})_ {1\times n}$，那么 $\vec g_i=\vec g_{i-1}\cdot W$，其中 $W_{n\times n}$ 为给定的矩阵。

那么，$g_{i,j}=(W^i)_ {x,j}$。

或者说，**$\vec g_i$ 是 $W^i$ 的第 $x$ 个行向量**。

那么，类似的，$f_{i,j}=\binom Li g_{i,j}=\binom Li(W^i)_ {x,j}$。

设 $w_k=g^{p-1\over k}$，即 $w_k$ 为 $k$ 次单位根（$g$ 是 $p$ 一个原根）。

作单位根反演。

$$ans_t=\sum_m[k\mid m-t]f_{m,y}
\\=\sum_mf_{m,y}
{\sum\limits_{i=0}^{k-1}w_k^{i(m-t)}\over k}
\\=\dfrac1k\sum_{i=0}^{k-1}w_k^{-it}\sum_mw_k^{im}f_{m,y}
\\=\dfrac1k\sum_{i=0}^{k-1}w_k^{-it}\sum_mw_k^{im}\binom Lm(W^m)_ {x,y}
\\=\dfrac1k\sum_{i=0}^{k-1}w_k^{-it}(\sum_m\binom Lm(w_k^iW)^m)_ {x,y}
\\=\dfrac1k\sum_{i=0}^{k-1}w_k^{-it}((I_n+w_k^iW)^L)_ {x,y}$$

（最后这步逆用了一次二项式定理，$I_n$ 为 $n$ 阶单位矩阵）

对每个 $i$，矩阵快速幂求出 $h_i=((I_n+w_k^iW)^L)_ {x,y}$。

$$ans_t=\dfrac1k\sum_{i=0}^{k-1}w_k^{-it}h_i$$

来吧，CZT！

由于 $it=\binom{i+t}2-\binom i2-\binom t2$，因此我们有

$$ans_t=\dfrac1k\sum_{i=0}^{k-1}w_k^{-it}h_i
\\=\dfrac{w_k^\binom t2}k\sum_{i=0}^{k-1}w_k^{-\binom{i+t}2}(h_iw_k^{\binom i2})$$

一次差卷积。

---
### 关于差卷积

~~不会吧不会吧都爆切白兔之舞了肯定会 CZT 啊，会 CZT 还不会差卷积吗。~~

鉴于有的题解中只讲了 reverse 方法求差卷积而没有讲述差卷积的确切概念，补充一下。

数列 $\{a_n\}$ 与 $\{b_n\}$ 的差卷积 $\{c_n\}$ 表述为：

$$\forall0\le k\le n,c_k=\sum_ia_{i+k}b_i$$

做法就是设 $d_i=b_{n-i}$，再假设 $a$ 与 $d$ 用 FFT 卷成 $C$，那么 $c_k=\sum\limits_ia_{i+k}d_{n-i}=C_{n+k}$。

直观来看，就是**把 $b$ 翻转了后与 $a$ 卷起来，再把系数平移。**

---
### 复杂度分析

求单位根：$O(\ ^4\!\!\!\!\sqrt p\log\log p)$。

预处理单位根幂次：$\Theta(k+\log p)$。

矩阵快速幂：$\Theta(kn^3\log L)$。

卷积：$\Theta(k\log k)$。

---
### Code

写的四次 FFT，和 KarryS307 的比了比，我的还快一点？

代码较长，放[剪贴板](https://www.luogu.com.cn/paste/djs2axb0)了。


---

## 作者：dsidsi (赞：5)

### Description

有一张顶点数为 $(L+1)\times n$ 的有向图。这张图的每个顶点由一个二元组 $(u,v)$ 表示 $(0\le u\le L,1\le v\le n)$。这张图不是简单图，对于任意两个顶点 $(u_1,v_1),(u_2,v_2)$，如果 $u_1<u_2$，则从 $(u_1,v_1)$ 到 $(u_2,v_2)$ 一共有 $w(v_1,v_2)$ 条不同的边，如果 $u_1\ge u_2$ 则没有边。

白兔将在这张图上上演一支舞曲。白兔初始时位于该有向图的顶点 $(0,x)$。

白兔将会跳若干步。每一步，白兔会从当前顶点沿任意一条出边跳到下一个顶点。白兔可以在任意时候停止跳舞（也可以没有跳就直接结束）。当到达第一维为 $L$ 的顶点就不得不停止，因为该顶点没有出边。

假设白兔停止时，跳了 $m$ 步，白兔会把这只舞曲给记录下来成为一个序列。序列的第 $i$ 个元素为它第 $i$ 步经过的边。

问题来了：给定正整数 $k$ 和 $y\ (1\le y\le n)$，对于每个 $t\ (0\le t<k)$，求有多少种舞曲（假设其长度为 $m$）满足 $m \bmod k=t$，且白兔最后停在了坐标第二维为 $y$ 的顶点？

两支舞曲不同定义为它们的长度（$m$）不同或者存在某一步它们所走的边不同。

输出的结果对 $p$ 取模。

对于全部数据，$p$ 为一个质数，$10^8<p<2^{30}$，$1\le n\le 3$，$1\le x\le n$，$1\le y\le n$，$0\le w(i,j)<p$，$1\le k\le 65536$，$k$ 为 $p-1$ 的约数，$1\le L\le 10^8$。

### Solution

数据范围已经在提示使用单位根反演了。

每次添加一列时，可以选择不动或者跳过去。所以乘上转移矩阵$I+W$（$I$是单位矩阵，$w$是题目给出的数组构成的矩阵）。

构造以矩阵为变量的生成函数，$f(x)=(I+Wx)^L$。所求即为

$$Ans_t=\sum_{i \mod k \equiv t}f(x)[x^i]$$

套单位根反演的式子

$$
\begin{matrix}
Ans_t & = &\frac{1}{k}\sum_{i=0}^{k-1}f(\omega_{k}^i)(\omega_{k}^i)^{k-t}\\
 & = & \frac{1}{k}\sum_{i=0}^{k-1}f(\omega_{k}^i)\omega_{k}^{-it}\\
 &=&\frac{1}{k}\sum_{i=0}^{k-1}f(\omega_{k}^i)\omega_{k}^{\binom{i+t}{2}-\binom{i}{2}-\binom{t}{2}}\\
 &=&\frac{\omega_{k}^{-\binom{t}{2}}}{k}\sum_{i=0}^{k-1}\omega_{k}^{\binom{i+t}{2}}f(\omega_{k}^i)\omega_{k}^{-\binom{i}{2}}\\
\end{matrix}
$$

后半部分是一个卷积的形式，预处理$f$后$MTT$即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 5, maxk = 65540;

inline int gi()
{
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	int sum = 0;
	while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

int n, k, L, x, y, G, mod;
int wk[maxk], f[maxk << 3], g[maxk << 3], h[maxk << 3];

inline int add(int a, int b) {return a + b >= mod ? a + b - mod : a + b;}
inline int sub(int a, int b) {return a >= b ? a - b : a - b + mod;}

inline int fpow(int x, int k)
{
	int res = 1;
	while (k) {
		if (k & 1) res = (ll)res * x % mod;
		k >>= 1; x = (ll)x * x % mod;
	}
	return res;
}

struct matrix
{
	int n, m, a[maxn][maxn];
	matrix(int _n = 0, int _m = 0) {n = _n; m = _m; memset(a, 0, sizeof(a));}

	int* operator [] (int x) {return a[x];}
	
	matrix operator * (matrix b) {
		matrix ans(n, b.m);
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= b.m; ++j)
				for (int k = 1; k <= m; ++k)
					ans[i][j] = (ans[i][j] + (ll)a[i][k] * b[k][j]) % mod;
		return ans;
	}

	matrix operator + (matrix b) {
		matrix ans(n, m);
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				ans[i][j] = add(a[i][j], b[i][j]);
		return ans;
	}
	
	matrix operator * (int b) {
		matrix ans(n, m);
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				ans[i][j] = (ll)a[i][j] * b % mod;
		return ans;
	}
	
} S, w, I;

inline matrix fpow(matrix x, int k)
{
	matrix res = I;
	while (k) {
		if (k & 1) res = res * x;
		x = x * x; k >>= 1;
	}
	return res;
}

namespace poly
{

	const double pi = acos(-1);
	struct cpx
	{

		double a, b;
		inline cpx() {a = b = 0;}
		inline cpx(long double x, long double y) {a = x; b = y;}
		inline cpx operator + (const cpx &x) const { return cpx(a + x.a, b + x.b); }
		inline cpx operator - (const cpx &x) const { return cpx(a - x.a, b - x.b); }
		inline cpx operator * (const cpx &x) const { return cpx(a * x.a - b * x.b, a * x.b + b * x.a); }
		inline cpx conj() {	return cpx(a, -b); }
	
	} a[maxk << 3], b[maxk << 3], a1[maxk << 3], b1[maxk << 3], w[maxk << 3];
	int n, L, R[maxk << 3];
	
	void FFT(cpx *a, int f)
	{
		for (int i = 0; i < n; ++i) if (i < R[i]) swap(a[i], a[R[i]]);
		cpx wn, t;
		for (int i = 1; i < n; i <<= 1)
			for (int j = 0; j < n; j += (i << 1))
				for (int k = 0; k < i; ++k) {
					wn = w[n / i * k];
					if (f == -1) wn.b = -wn.b;
				
					t = wn * a[j + i + k];
					a[j + i + k] = a[j + k] - t;
					a[j + k] = a[j + k] + t;
				}
	}

	void mul(int *A, int *B, int l1, int l2, int *C)
	{
		for (n = 1; n < l1 + l2 - 1; n <<= 1) ++L;
		--L;
		for (int i = 0; i < n; ++i) R[i] = (R[i >> 1] >> 1) | ((i & 1) << L);
		for (int i = 0; i < n; ++i) w[i] = cpx(cos(pi * i / n), sin(pi * i / n));

		cpx ca, cb, da1, da2, db1, db2;
	
		for (int i = 0; i < n; ++i) a[i] = cpx(A[i] & 32767, A[i] >> 15), b[i] = cpx(B[i] & 32767, B[i] >> 15);
		FFT(a, 1); FFT(b, 1);
		for (int i = 0, k; i < n; ++i) {
			k = (n - i) & (n - 1);
			ca = a[k].conj(); cb = b[k].conj();
			da1 = (a[i] + ca) * cpx(0.5, 0); da2 = (a[i] - ca) * cpx(0, -0.5);
			db1 = (b[i] + cb) * cpx(0.5, 0); db2 = (b[i] - cb) * cpx(0, -0.5);
			a1[i] = da1 * db1 + (da1 * db2 + da2 * db1) * cpx(0, 1);
			b1[i] = da2 * db2;
		}

		FFT(a1, -1); FFT(b1, -1);
		for (int i = 0, v1, v2, v3; i < n; ++i) {
			v1 = (ll)(a1[i].a / n + 0.5) % mod;
			v2 = (ll)(a1[i].b / n + 0.5) % mod;
			v3 = (ll)(b1[i].a / n + 0.5) % mod;
			C[i] = (((ll)v3 << 30ll) + ((ll)v2 << 15ll) + v1) % mod;
			if (C[i] < 0) C[i] += mod;
		}
	}
	
}
	
int calcg(int p)
{
	int phi = p - 1;
	for (int i = 2; ; ++i) {
		int flg = 0;
		for (int j = 2; j * j <= phi && !flg; ++j)
			if (phi % j == 0) {
				flg |= fpow(i, j) == 1;
				if (j * j != phi) flg |= fpow(i, phi / j) == 1;
			}
		if (!flg) return i;
	}
	exit(-1);
}

int main()
{
	freopen("dance.in", "r", stdin);
	freopen("dance.out", "w", stdout);
	
	n = gi(); k = gi(); L = gi(); x = gi(); y = gi(); mod = gi();
	S.n = 1; S.m = w.n = w.m = I.n = I.m = n; S[1][x] = 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) w[i][j] = gi();
	for (int i = 1; i <= n; ++i) I[i][i] = 1;

	G = calcg(mod); wk[0] = 1; wk[1] = fpow(G, (mod - 1) / k);
	for (int i = 2; i <= k; ++i) wk[i] = (ll)wk[i - 1] * wk[1] % mod;
	
	for (int i = 0; i < k; ++i) f[i] = (ll)(S * fpow(w * wk[i] + I, L))[1][y] * wk[(ll)i * (i - 1) / 2 % k] % mod;
	for (int i = 0; i <= (k << 1); ++i) g[(k << 1) - i] = wk[k - (ll)i * (i - 1) / 2 % k];
	
	poly::mul(f, g, k, (k << 1) + 1, h);

	for (int inv = fpow(k, mod - 2), i = 0; i < k; ++i) printf("%lld\n", (ll)h[(k << 1) - i] * inv % mod * wk[(ll)i * (i - 1) / 2 % k] % mod);
	
	return 0;
}
```

---

## 作者：Limie (赞：4)

### 前言
2023 年 4 月 12 日，某次随机跳题时，菜鸡 Limie 发现了这题，并看到了 Karry5307 的题解，但是由于太菜，并没有看懂（因为当时连原根都不知道是啥，菜的没救了）。

2023 年 6 月，菜鸡 Limie 学习了原根，可是并没有学出什么所以然。

2023 年 8 月，菜鸡 Limie 学习了 FFT，第一次失败了，但是最终还是成功的通过了模板题。

2024 年 4 月 1 日，菜鸡 Limie 成功 AC P6800，但是在 P6828 中被卡常了。

2024 年 4 月 2 日，菜鸡 Limie 卡过了 P6828。

2024 年 4 月 12 日，菜鸡 Limie 终于调对了这题

一年前我在随机跳题时，折戟沉沙。一年后，我从倒下的地方爬起。

我成功了。我不再是以前的那个我了。

### 题解

#### 方法1（正解）
找到一台写有此题 AC 代码的电脑，背一下 ip，然后 ssh 即可。

upd on 2024/7/4：可以使用 [5m++5/C++50](https://www.luogu.com/article/nfyw7v4j) 中的 ssh 库，方便操作。

-------
#### 方法2（非正解）

发现 $n \le 3$，发现这非常矩阵。

设矩阵 $W$ 为输入矩阵。

那么对于走 $i$ 步的情况来说，方案数显然为（不会的回去重学矩阵快速幂）：
$$
\binom{L}{i} (W^i)_{x,y}
$$

那么，对于固定的 $t$，答案为：
$$
\sum_{i \equiv t (\bmod k)} \binom{L}{i} (W^i)_{x,y}
$$

推一下式子：
$$
=\sum_{i=0}^L \binom{L}{i} (W^i)_{x,y} \left [ k|i-t \right] \\
=\frac{1}{k}\sum_{i=0}^L \binom{L}{i} (W^i)_{x,y} \sum_{j=0}^{k-1} \omega_{k}^{j(i-t)} \\
=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-jt} \sum_{i=0}^L \binom{L}{i} \omega_{k}^{ij} (W^i)_{x,y} \\
=\frac{1}{k}\sum_{j=0}^{k-1} \omega_{k}^{-jt} ((W \times \omega_{k}^{j}+I)^L)_{x,y}
$$

###### ps：I 为单位矩阵

然后发现绝大部分东西都与 $t$ 无关，于是想到可以表示为一个多项式形式：
$$
f(x)=\frac{1}{k}\sum_{j=0}^{k-1} x^j ((W \times \omega_{k}^{j}+I)^L)_{x,y}
$$

那么答案为 $f(\omega_{k}^{-t})$。

发现实际上就是在做任意长度的 FFT，chirp-z 即可。

### chirp-z（dalao 可跳过）

模型是对于一个多项式 $f(x)$，求出 $f(g^0),f(g^1) \dots f(g^m)$。

$$
f(g^j)=\sum_{i=0}^n a_ig^{ij} \\
=\sum_{i=0}^n a_i g^{\binom{i+j}{2}-\binom{i}{2}-\binom{j}{2}} \\
=\sum_{i=0}^n a_i g^{\binom{i+j}{2}-\binom{i}{2}} g^{-\binom{j}{2}}
$$

减法卷积即可。

### 代码
4.37KB 的又臭又长代码，且为了好写常数极大 ~~（我绝对不会告诉你我调了 2h 是因为矩阵乘法没初始化呢）~~。
```cpp
#include<bits/stdc++.h>
namespace Limie{
	#define x first
	#define y second
	using namespace std;
	typedef long long LL;
	typedef pair<int,int> PII;
	typedef unsigned long long ULL;
	typedef double LD;
}
using namespace Limie;
int n,k,l,x,y,mod,w;
int qmi(int a,int b)
{
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return ans;
}
namespace Poly{
const LD PI=acos(-1);
struct Complex{
	LD a,b;
	inline Complex operator+(const Complex &w)
	{return Complex{a+w.a,b+w.b};}
	inline Complex operator-(const Complex &w)
	{return Complex{a-w.a,b-w.b};}
	inline Complex operator*(const Complex &w)
	{return Complex{a*w.a-b*w.b,a*w.b+b*w.a};}
	inline Complex operator/(const Complex &w)
	{
		double s=w.a*w.a+w.b*w.b;
		return Complex{(a*w.a+b*w.b)/s,(b*w.a-a*w.b)/s};
	}
};
vector<int> rev;
vector<Complex> fwk;
void Init_fft(int n)
{
	rev.resize(n);
	for(int i=1;i<n;i++)rev[i]=(rev[i>>1]>>1)|((i&1)*(n>>1));
	fwk.resize(n);
	for(int i=1;i<n;i<<=1)for(int j=0;j<i;j++)
	fwk[n/i*j]={cos(PI*j/i),sin(PI*j/i)};
}
void fft(vector<Complex> &a,const int f)
{
    int n=a.size();
    for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
    for(int l=1;l<n;l<<=1)
        for(int j=0;j<n;j+=(l<<1))
            for(int i=0;i<l;i++){
                Complex wk=fwk[n/l*i];wk.b*=f;
				Complex y=a[i+j+l]*wk;
                a[i+j+l]=a[i+j]-y,a[i+j]=a[i+j]+y;
            }
}
int pw1[32770],pw2[32770];
struct poly:vector<int>{
friend void operator*=(poly &a,poly b)
{
	int len=a.size(),n=1;
	while(n<len)n<<=1;
	vector<Complex> A(n),B(n),C(n),D(n);
	a.resize(n),b.resize(n);
	for(int i=0;i<n;i++){
		A[i].a=a[i]>>15,A[i].b=a[i]&32767;
		C[i].a=b[i]>>15,C[i].b=b[i]&32767;
	}
	Init_fft(n);
	fft(A,1),fft(C,1);
	for(int i=1;i<n;i++)B[i]=A[n-i],B[i].b*=-1;
	B[0]=A[0],B[0].b*=-1;
	for(int i=1;i<n;i++)D[i]=C[n-i],D[i].b*=-1;
	D[0]=C[0],D[0].b*=-1;
	for(int i=0;i<n;i++){
		Complex aa=(A[i]+B[i])*(Complex){0.5,0};
		Complex bb=(A[i]-B[i])*(Complex){0,-0.5};
		Complex cc=(C[i]+D[i])*(Complex){0.5,0};
		Complex dd=(C[i]-D[i])*(Complex){0,-0.5};
		A[i]=aa*cc+(Complex){0,1}*(aa*dd+bb*cc);
		B[i]=bb*dd;
	}
	fft(A,-1),fft(B,-1);
	a.resize(len);
	for(int i=0;i<len;i++){
		int aa=(LL)(A[i].a/n+0.5)%mod;
		int bb=(LL)(A[i].b/n+0.5)%mod;
		int cc=(LL)(B[i].a/n+0.5)%mod;
		a[i]=(((LL)aa*(1<<30)+(LL)bb*(1<<15)+cc)%mod+mod)%mod;
	}
}
friend void chirp_z(poly &a,int w)
{
	int len=(a.size()<<1)-1;poly b;
	a.resize(len),b.resize(len);
	pw1[0]=1;for(int i=1;i<=32768;i++)pw1[i]=(LL)pw1[i-1]*w%mod;
	pw2[0]=1;for(int i=1;i<=32768;i++)pw2[i]=(LL)pw2[i-1]*pw1[32768]%mod;
	auto qmi=[&](int a){return (LL)pw1[a&32767]*pw2[a>>15]%mod;};
	for(int i=0;i<len;i++){
		a[i]=(LL)a[i]*qmi(mod-1-((LL)i*(i-1)>>1)%(mod-1))%mod;
		b[len-1-i]=qmi(((LL)i*(i-1)>>1)%(mod-1));
	}a*=b;
	for(int i=0;i<(len+1>>1);i++)
	a[i]=(LL)a[len-1-i]*qmi(mod-1-((LL)i*(i-1)>>1)%(mod-1))%mod;
	a.resize(len+1>>1);
}
};
}
using Poly::poly;
namespace yuangen{
vector<int> p;
void init(int x=mod-1)
{
	for(int i=2;i*i<=x;i++)
		if(x%i==0){
			p.push_back(i);
			while(x%i==0)x/=i;
		}
		
	if(x>1)p.push_back(x);
}
int get()
{
	init();
	for(int i=2;;i++){
		bool f=1;
		for(int x:p)
			if(qmi(i,(mod-1)/x)==1){f=0;break;}
			
		if(f)return i;
	}
}
}
using yuangen::get;
namespace Matrix{
	struct mat:array<array<int,3>,3>{
        friend void clear(mat &a){for(int i=0;i<n;i++)for(int j=0;j<n;j++)a[i][j]=0;}
		friend void operator*=(mat &a,const int b)
		{
			for(int i=0;i<n;i++)
				for(int j=0;j<n;j++)a[i][j]=1ll*a[i][j]*b%mod;
		}
		friend void operator++(mat &a){for(int i=0;i<n;i++)a[i][i]++;}
		friend mat operator*(mat a,const mat b)
		{
			mat c;clear(c);
			for(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<n;k++)
			c[i][j]=(1ll*a[i][k]*b[k][j]%mod+c[i][j])%mod;return c;
		}
		friend mat pow(mat a,int b)
		{
			mat ans;clear(ans);++ans;
			while(b){
				if(b&1)ans=ans*a;
				a=a*a;
				b>>=1;
			}
			return ans;
		}
	};
}
using Matrix::mat;
int main()
{
	int i,j;
	cin>>n>>k>>l>>x>>y>>mod;
	w=qmi(get(),(mod-1)/k);
    poly a;mat s;a.resize(k);int inv=qmi(k,mod-2);
	for(i=0;i<n;i++)for(j=0;j<n;j++)cin>>s[i][j];
	for(i=0;i<k;i++){
		mat b=s;b*=qmi(w,i);
		++b;
		b=pow(b,l);
		a[i]=b[x-1][y-1];
	}
	chirp_z(a,w);
	reverse(a.begin()+1,a.end());
	for(int x:a)cout<<1ll*x*qmi(k,mod-2)%mod<<'\n';
}
```

---

## 作者：Fading (赞：4)

发一个没有什么错误而且格式正常的题解。。。

有一个简单的$dp$大家应该都会：

设$f_{i,j}$为走$i$步到第$j$行**任意合法位置**的方案数。

设$g_{i,j}$为走$i$步到第$j$行(**仅仅是行**)的方案数。

有

$$g_{i,j}=\sum_{k}g_{i-1,k}w_{k,j}$$

很显然是矩阵吧$...$

我们不妨令$n=3,x=1$

设$M=\begin{bmatrix}1 & 0 & 0\end{bmatrix},S=\begin{bmatrix}w_{1,1} & w_{1,2} & w_{1,3}  \\w_{2,1} & w_{2,2} & w_{2,3}  \\w_{3,1} & w_{3,2} & w_{3,3}  \\ \end{bmatrix}$

其他是同理的。

显而易见，$G_i=M\times S^i(G$为当前的矩阵，$F=\begin{bmatrix}g_{i,1}&g_{i,2}&g_{i,3}\end{bmatrix})$

那么$f_{i,j}$等价于白兔在$1,...,L$中选$i$个经过点进行跳舞。

$$\therefore f_{i,j}=C_{L}^{i}g_{i,j}$$

我们要求的就是

$$ans_t=\sum_{i=1}^{L}[i\ \text{mod}\ k=t]f_{i,y}$$

显而易见的[单位根反演](https://www.luogu.org/blog/wohaocaia/dan-wei-gen-fan-yan-xiao-jie)。

$$ans_t=\sum_{i=0}^{L}[k|(i-t)]f_{i,y}$$

$$=\sum_{i=0}^{L}f_{i,y}\frac 1k\sum_{j=0}^{k-1}\omega_{k}^{(i-t)j}$$

$$=\frac 1k\sum_{i=0}^{L}f_{i,y}\sum_{j=0}^{k-1}\omega_{k}^{(i-t)j}$$

$$=\frac 1k\sum_{i=0}^{L}f_{i,y}\sum_{j=0}^{k-1}\omega_{k}^{ij}\omega_{k}^{-tj}$$

$$=\frac 1k\sum_{i=0}^{L}\omega_{k}^{-tj}C_{L}^{i}g_{i,y}\sum_{j=0}^{k-1}\omega_{k}^{ij}$$

再把矩阵代入进去。

$$=\frac 1k\sum_{i=0}^{L}\omega_{k}^{-tj}C_{L}^{i}MS^i\sum_{j=0}^{k-1}\omega_{k}^{ij}\ \ \text{的第y项}$$

$$=\frac 1k\sum_{j=0}^{k-1}\omega_{k}^{-tj}M\sum_{i=0}^{L}S^iC_{L}^{i}(\omega_{k}^{j})^i\ \ \text{的第y项}$$

和[PYXFIB](https://www.luogu.org/blog/wohaocaia/ti-xie-bzoj3328pyxfib)一样的套路，根据矩阵的二项式定理（不会的可以点进题解看一看），设单位矩阵为$I$

$$I=\begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1 \end{bmatrix}$$

由于$I$和任意矩阵均满足交换律，则有

$$ans_t=\frac 1k\sum_{j=0}^{k-1}\omega_{k}^{k-tj}M(\omega_k^jS+I)^L\ \ \text{的第y项}$$

现在问题来了，后面这一坨我们可以用矩阵快速幂来求。但是前面这个好像很难处理。。。

设$h_j=M(\omega_k^jS+I)^L\ \ \text{的第y项}$

$$ans_t=\frac 1k\sum_{j=0}^{k-1}\omega_{k}^{-tj}h_j$$

我们需要快速求出这$k$个值$(ans_0,ans_1,..,ans_{k-1})$。

猜一猜就是一个卷积，但是怎么卷呢？

有一个东西叫做 Bluestein's Algorithm 想必大家都听过吧$...$

它是把$ij$拆成$-\frac {i^2}2-\frac {j^2}2+\frac {(i+j)^2}2$

但是~~翻了翻memset0的题解~~发现单位根不一定有二次剩余，只能把$-tj$拆成


$$C_t^2+C_j^2-C_{t+j}^2$$

验证一下

$$=\frac {t(t-1)+j(j-1)-(t+j)(t+j-1)}2$$

$$=-\frac {2tj}2$$

$$=-tj$$

代入以后就可以得到

$$ans_t=\frac 1k\sum_{j=0}^{k-1}\omega_{k}^{C_t^2+C_j^2-C_{t+j}^2}h_j$$

$$=\frac {\omega_{k}^{C_t^2}}k\sum_{j=0}^{k-1} h_j\omega_{k}^{C_j^2}\cdot\omega_{k}^{-C_{t+j}^2}$$

还看不出来吗？继续变形。

$$=\frac {\omega_{k}^{C_t^2}}k\sum_{j=0}^{k-1} h_j\omega_{k}^{C_j^2}\cdot \frac 1{\omega_{k}^{C_{t+j}^2}}$$

设

$$f_i=h_i\omega_{k}^{C_i^2},g_i=\frac 1{\omega_{k}^{C_{i}^2}}$$

则

$$ans_t=\frac {\omega_{k}^{C_t^2}}k\sum_{j=0}^{k-1}f_j\cdot g_{j+t}$$

剩下的就是[$\text{[ZJOI2014]力}$](https://www.luogu.org/problemnew/show/P3338) 了。

发现大家卷的都和我不一样。我是把设$f'_i=f_{2k-i}$，然后再卷积。

由于模数奇特以及出题人毒瘤，需要用三模数 NTT 或者 MTT 。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
double pi=acos(-1);
ll a[400002],c[400002],b[400002],n,K,L,X,Y,ljc,xx,yy,r[400002];
struct Complex{
    double x,y;
    Complex(double xx=0,double yy=0)
    {x=xx,y=yy;}
}A[400002],B[400002],C[400002],D[400002],w[400002];
ll WW[4][4];
struct matrix{
    ll x[4][4];
    inline void clear(){
    	for (int i=1;i<=n;i++){
    		for (int j=1;j<=n;j++){
    			x[i][j]=0;
            }
        }
    }
}aa,one,M;
inline matrix mul(matrix a,matrix b){
    matrix c;
    c.clear();
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            for (int k=1;k<=n;k++){
                c.x[i][j]=(c.x[i][j]+a.x[i][k]*b.x[k][j])%ljc;
            }
        }
    }
    return c;
}
inline matrix mfast_pow(matrix a,ll b){
    matrix t=one;
    while (b){
        if (b&1LL) t=mul(t,a);
        a=mul(a,a);b>>=1;
    }
    return t;
}
inline void init_one(){
    for (int i=1;i<=n;i++) one.x[i][i]=1;
}
inline void init_a(ll xx){
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            aa.x[i][j]=1LL*WW[i][j]*xx%ljc;
        }
        aa.x[i][i]++; 
    }
}
inline ll fast_pow(int a,int b,int p){
    ll t=1;
    while (b){
        if (b&1) t=1LL*t*a%p;
        b>>=1;a=1LL*a*a%p;
    }
    return t;
}
ll q[10010],gen;
inline ll G(ll s){
    q[0]=0;
    for (ll i=2;i*i<=s-1;i++){
        if ((s-1)%i==0){
            q[++q[0]]=i;
            if (i*i!=s-1) q[++q[0]]=(s-1)/i;
        }
    }
    for (ll i=2;;i++){
        bool flag=1;
        for (ll j=1;j<=q[0]&&flag;j++) if (fast_pow(i,q[j],s)==1) flag=0;
        if (flag) return i;
    }
    return -1;
}
inline Complex operator + (const Complex &a,const Complex &b){
    return Complex(a.x+b.x,a.y+b.y);
}
inline Complex operator - (const Complex &a,const Complex &b){
    return Complex(a.x-b.x,a.y-b.y);
}
inline Complex operator * (const Complex &a,const Complex &b){
    return Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
}
inline void swap(Complex &a,Complex &b){
    Complex t=a;a=b;b=t;
}
inline void FFT(Complex f[],int id,int lim){
    for (int i=0;i<lim;i++){
        if (i>r[i]) swap(f[r[i]],f[i]);
    }
    for (int len=1;len<lim;len<<=1){
    	Complex gen(cos(pi/len),id*sin(pi/len));
        for (int i=0;i<lim;i+=len<<1){
            Complex *f1=f+i,*f2=f1+len;
            for (int j=0;j<len;j++){
            	Complex WW=w[lim/len*j];
            	if (id==-1) WW.y=-WW.y;
                Complex x=f1[j],y=f2[j]*WW;
                f1[j]=x+y;f2[j]=x-y;
            }
        }
    }
    if (id==1) return;
    for (int i=0;i<lim;i++) f[i].x=fabs(f[i].x/lim+0.5);
}
const int sqq=32768;
int lim,len;
inline void MTT(int *a,int *b,int *c,int n,int m){
    lim=1,len=0;
    while (lim<=(n+m)) lim<<=1,len++;
    for (int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(len-1));
    for (int i=0;i<lim;i++){
        A[i].x=A[i].y=B[i].x=B[i].y=C[i].x=C[i].y=D[i].x=D[i].y=0;
    }
    for (int len=1;len<lim;len<<=1){
    	for (int j=0;j<len;j++){
    		w[lim/len*j]=(Complex){cos(j*pi/len),sin(j*pi/len)};
        }
    }
    for (int i=0;i<n;i++) A[i].x=a[i]/sqq,B[i].x=a[i]%sqq;
    for (int i=0;i<m;i++) C[i].x=b[i]/sqq,D[i].x=b[i]%sqq;
    FFT(A,1,lim);FFT(B,1,lim);FFT(C,1,lim);FFT(D,1,lim);
    Complex tmp1,tmp2;
    for (int i=0;i<lim;i++){
    	tmp1=A[i]*C[i];tmp2=D[i]*B[i];
        B[i]=B[i]*C[i]+A[i]*D[i];A[i]=tmp1;D[i]=tmp2;
    }
    FFT(A,-1,lim);FFT(B,-1,lim);FFT(D,-1,lim);
    for (int i=0;i<lim;i++){
    	c[i]=(c[i]+(ll)(A[i].x)*sqq%ljc*sqq%ljc)%ljc;
    	c[i]=(c[i]+(ll)(B[i].x)*sqq%ljc)%ljc;
    	c[i]=(c[i]+(ll)(D[i].x))%ljc;
    }
}
inline ll getC(ll n){
    if (n<=1) return 0;
    return 1LL*(n-1)*n/2;
}
ll Gen[100001];
signed main(){
    n=read(),K=read(),L=read(),X=read(),Y=read(),ljc=read();
    for (int i=1;i<=n;i++){
    	for (int j=1;j<=n;j++){
    		WW[i][j]=read();
        }
    }
    init_one();
    gen=fast_pow(G(ljc),(ljc-1)/K,ljc);
    Gen[0]=1;
    for (int i=1;i<K;i++) Gen[i]=Gen[i-1]*gen%ljc;
    for (ll i=0,w=1;i<K;i++,w=w*gen%ljc){
        init_a(w);
        aa=mfast_pow(aa,L);
        b[i]=1LL*aa.x[X][Y]*Gen[getC(i)%K]%ljc;
    }
    for (ll i=0;i<((K<<1)|1);i++){
        a[i]=Gen[(K-getC(i)%K)%K];
    } 
    reverse(a,a+(K<<1)+1);
    MTT(a,b,c,((K<<1)|1),K);
    ll KKK=fast_pow(K,ljc-2,ljc);
    for (ll i=0;i<K;i++){
        printf("%lld\n",1LL*c[2*K-i]*KKK%ljc*Gen[getC(i)%K]%ljc);
    }
}
```

---

## 作者：jun头吉吉 (赞：3)

## 题意
有一张顶点数为 $(L+1)\times n$ 的有向图，顶点用二元组$(u,v)$（$0\le u\le L,v\le 1\le n$）表示。

在这个矩形中，前面的$(u_1,v_1)$可以到后面的$(u_2,v_2)$，且有$w[v_1][v_2]$条路。

从$(0,x)$出发，到第二维为$y$的顶点，对于$x\in[0,k-1]$，有多少条走了$m(m\bmod k=x)$步的路线。

（感觉越解释越乱）
## 题解
这个屑没有学过矩阵表述不严谨请见谅。

记$g_{i,j}$为走了$i$步到第二维为$j$的顶点的方案数，有：

$$g_{i,j}=\sum_{k=1}^ng_{i-1,k}w_{k,j}$$

不难想到矩阵优化。

我们若记
$$G_i=(g_{i,1},g_{i,2},\ldots,g_{i,n})$$

$$
G_0=(\underbrace{0,\ldots,0}_{x-1},1,\underbrace{0,\ldots,0}_{n-x})
$$
$$
S=
\begin{pmatrix}
w_{1,1}&\cdots&w_{1,n}\\
\vdots&\ddots&\vdots\\
w_{n,1}&\cdots&w_{n,n}
\end{pmatrix}
$$
有：$G_i=G_{i-1}\times S$，即$G_i=G_0\times S^i$

但此时我们没有考虑白兔兔每次走了几步。所以我们还需要考虑$i$步走了那些列。实际上就是在$L$个位置上选了$i$个位置~~唱~~跳，也就是$\tbinom{L}{i}g_{i,j}=\tbinom{L}i(G_0S^i)_{1,y}$

那么此时我们已经表示出跳了$i$的方案数。来考虑答案，列出式子开始乱推：
$$ans_t=\sum_{i=0}^L[i\bmod k=t]\tbinom{L}{i}g_{i,y}$$
$[i\bmod k=t]$等价于$i=t+k\times a$，即$[k|(i-t)]$
$$ans_t=\sum_{i=0}^L[k|(i-t)]\tbinom{L}{i}g_{i,y}$$
然后就是神奇的单位根反演。先上公式：
$$\forall k,[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ik}$$
简单证明一下：
- 当$[n|k]$时$\omega_n^{ik}=\omega^0=1$，显然原式等于$1$
- 否则，就是一个等比数列求和$\dfrac{1}{n}\times \dfrac{\omega_n^{nk}-\omega_n^0}{\omega_n^k-1}=0$
把这个简单的柿子带进去：
$$ans_t=\sum_{i=0}^L\frac{1}{k}\tbinom{L}{i}g_{i,y}\sum_{j=0}^{k-1}\omega_{k}^{(i-t)j}$$
有一说一括号看着很难受，因此拆开来。
$$ans_t=\frac{1}{k}\sum_{i=0}^L\tbinom{L}{i}g_{i,y}\sum_{j=0}^{k-1}\omega_{k}^{ij}\omega_{k}^{-tj}$$
交换求和顺序就是传统艺能了。
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^L\tbinom{L}{i}g_{i,y}\omega_{k}^{ij}$$
把我们推出来的$g_{i,y}$带进去。
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}\sum_{i=0}^L\tbinom{L}{i}\omega_{k}^{ij}\times(G_0S^i)_{1,y}$$
矩阵那部分事实上也可以先提取公因式再求和再取下标，即：
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}(G_0\sum_{i=0}^L\tbinom{L}{i}\omega_{k}^{ij}\times S^i)_{1,y}$$
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}(G_0\sum_{i=0}^L\tbinom{L}{i}(\omega_{k}^{j}\times S)^i)_{1,y}$$
矩阵这一串柿子不禁让人联想到**二项式定理**，我们如果记单位矩阵为$I$有：
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}(G_0\sum_{i=0}^L\tbinom{L}{i}(\omega_{k}^{j}\times S)^iI^{L-i})_{1,y}$$
于是此时的幂形式就显而易见了。
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}(G_0(\omega_k^jS+I)^L)_{1,y}$$
如果我们记$f_i=(G_0(\omega_k^iS+I)^L)_{1,y}$，就可以吧答案写成比较简单的形式。
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-tj}f_j$$
这个$\omega_{k}^{-tj}$就要用到`Bluestein's Algorithm`这个听起来非常高大上实际上并不难的东西。核心思想就是把$ij$拆掉，变成与$i,j$一次关系，然后就可以`卷`了。

但这题$ij=\frac{(i+j)^2}{2}-\frac{i^2}{2}-\frac{j^2}{2}$本题似乎不太行，因为可能会出现$\frac{1}{2}$次但单位根可能没有二次剩余，因此我们需要另一种奇怪的方法：
$ij=\tbinom{i+j}{2}-\tbinom{i}{2}-\tbinom{j}{2}$，正确性拆开来就行了。这样就全部是整数从而避免了二次剩余。

那么带进去：
$$ans_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{-\tbinom{t+j}{2}+\tbinom{t}{2}+\tbinom{j}{2}}f_j$$
整理一下。
$$ans_t=\frac{\omega_{k}^\tbinom{t}{2}}{k}\sum_{j=0}^{k-1}\omega_{k}^{-\tbinom{t+j}{2}}\times \omega_{k}^\tbinom{j}{2}f_j$$
如果我们记$c_{k+t}=\dfrac{ans_tk}{\omega_{k}^\tbinom{t}{2}}$，$a_i=\omega_{k}^{-\tbinom{i}{2}}$,$b_{t-i}=\omega_{k}^\tbinom{i}{2}f_i$
$$c_{k+t}=\sum_{i=0}^{k-1}a_{t+i}b_{k-i}$$
`MTT`随便卷一下就好了。不过注意$a$需要倍长QwQ
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
typedef std::complex<double>complex;
const int N=4e6+10;const double PI=acos(-1);const complex I=complex(0,1);
int rev[N];complex Wn[N];int M,mod;
int ksm(int x,int y) {
	int re=1;
	for(;y;y>>=1,x=1LL*x*x%mod)if(y&1)re=1LL*re*x%mod;
	return re;
}
inline long long num(complex x){double d=x.real();return d<0?(long long)(d-0.5)%mod:(long long)(d+0.5)%mod;}
struct poly{
	std::vector<complex>a0,a1;
	int size(){return a0.size();}
    void resize(int n){a0.resize(n);a1.resize(n);}
	void set(int x,long long y){
		y%=mod;
		a0[x]=y/M;
		a1[x]=y%M;
	}
	long long get(int x){return (M*M*num(a0[x].real())%mod +
				M*(num(a0[x].imag())+num(a1[x].real()))%mod+num(a1[x].imag()))%mod;}
	long long val(int x){return (long long)(M*a0[x].real()+a1[x].real()+mod)%mod;}
};
poly operator+(poly a,poly b){
    int n=std::max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a.set(i,a.val(i)+b.val(i));return a;
}
poly operator-(poly a,poly b){
    int n=std::max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a.set(i,a.val(i)-b.val(i));return a;
}
inline poly one(){poly a;a.resize(1);a.set(0,1);return a;}
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){
	int n=1<<k;
	for(int i=0;i<n;i++)
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
	for(int i=0;i<n;i++)
		Wn[i]={cos(PI/n*i),sin(PI/n*i)};
}
void FFT(std::vector<complex>&A,int n,int t){
	if(t<0)for(int i=1;i<n;i++)if(i<(n-i))std::swap(A[i],A[n-i]);
	for(int i=0;i<n;i++)
		if(i<rev[i])std::swap(A[i],A[rev[i]]);
	for(int m=1;m<n;m<<=1)
		for(int i=0;i<n;i+=m<<1)
			for(int k=i;k<i+m;k++){
				complex W=Wn[1ll*(k-i)*n/m];
				complex a0=A[k],a1=A[k+m]*W;
				A[k]=a0+a1;A[k+m]=a0-a1; 
			}
	if(t<0)for(int i=0;i<n;i++)A[i]/=n;
}
void MTT(poly &A,int n,int t){
	for(int i=0;i<n;i++)A.a0[i]=A.a0[i]+I*A.a1[i];
	FFT(A.a0,n,t);
	for(int i=0;i<n;i++)A.a1[i]=std::conj(A.a0[i?n-i:0]);
	for(int i=0;i<n;i++){
		complex p=A.a0[i],q=A.a1[i];
		A.a0[i]=(p+q)*0.5;A.a1[i]=(q-p)*0.5*I;
	}
}
inline poly operator*(poly a,poly b){
    int n=a.size()+b.size()-1,k=ext(n);
    a.resize(1<<k),b.resize(1<<k),init(k);
    MTT(a,1<<k,1);MTT(b,1<<k,1);
	for(int i=0;i<(1<<k);i++){
		complex p=a.a0[i]*b.a0[i]+I*a.a1[i]*b.a0[i];
		complex q=a.a0[i]*b.a1[i]+I*a.a1[i]*b.a1[i];
		a.a0[i]=p,a.a1[i]=q;
	}
    FFT(a.a0,1<<k,-1);FFT(a.a1,1<<k,-1);a.resize(n);
	long long tmp;for(int i=0;i<n;i++)
		tmp=a.get(i),a.set(i,tmp);
	return a;
}
struct modint{
    int x;
    modint(int o=0){x=o;}
    modint &operator = (int o){return x=o,*this;}
    modint &operator +=(modint o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint &operator -=(modint o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint &operator *=(modint o){return x=1ll*x*o.x%mod,*this;}
    modint &operator ^=(int b){
        modint a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint &operator /=(modint o){return *this *=o^=mod-2;}
    modint &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint &operator /=(int o){return *this *= ((modint(o))^=mod-2);}
	template<class I>friend modint operator +(modint a,I b){return a+=b;}
    template<class I>friend modint operator -(modint a,I b){return a-=b;}
    template<class I>friend modint operator *(modint a,I b){return a*=b;}
    template<class I>friend modint operator /(modint a,I b){return a/=b;}
    friend modint operator ^(modint a,int b){return a^=b;}
    friend bool operator ==(modint a,int b){return a.x==b;}
    friend bool operator !=(modint a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint operator - () {return x?mod-x:0;}
	modint &operator++(int){return *this+=1;}
};
struct Mat{
	//矩阵
	int n,m;modint val[5][5]; 
	modint*operator[](const int x){return val[x];}
	friend Mat operator*(Mat A,modint B){
		for(int i=1;i<=A.n;i++)for(int j=1;j<=A.m;j++)A[i][j]*=B;
		return A;
	}
	friend Mat operator*(Mat A,Mat B){
		static Mat C;if(A.m!=B.n)exit(11);
		C.n=A.n,C.m=B.m;
		for(int i=1;i<=C.n;i++)
			for(int j=1;j<=C.m;j++){
				C[i][j]=0;
				for(int k=1;k<=A.m;k++)
					C[i][j]+=A[i][k]*B[k][j];
			}
		return C;
	}
	friend Mat operator+(Mat A,Mat B){
		if(A.n!=B.n||A.m!=B.m)exit(12);
		for(int i=1;i<=A.n;i++)for(int j=1;j<=A.m;j++)A[i][j]+=B[i][j];
		return A;
	}
	
};
int n,k,L,x,y;
Mat _1,S,G0;
modint w[N];
Mat operator^(Mat A,int B){
	Mat tmp=_1;
	while(B){
		if(B&1)tmp=tmp*A;
		A=A*A;B>>=1;
	}return tmp;
}
modint getG(int x){
	static int p[50],o=0;
	for(int i=2,y=x-1;i<=y;i++)
		if(y%i==0){
			p[++o]=i;
			while(y%i==0)y/=i;
		}
	for(int i=2;;i++){
		bool flag=true;
		for(int j=1;j<=o;j++)if((modint(i)^((mod-1)/p[j]))==1){flag=false;break;}
		if(flag)return i;
	}
}
#define C2(x) (1ll*(x)*(x-1)/2) 
signed main(){
	//freopen("1.in","r",stdin);
	in::read(n,k,L,x,y,mod);M=sqrt(mod);
	_1.n=_1.m=n;for(int i=1;i<=n;i++)_1[i][i]=1;
	S.n=S.m=n;for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)in::read(S[i][j]);
	G0.n=1;G0.m=n;G0[1][x]=1;
	w[0]=1;w[1]=getG(mod)^((mod-1)/k);
	for(int i=2;i<=k;i++)w[i]=w[i-1]*w[1];
	//out::write(getG(mod).x);
	poly a,b;a.resize(2*k);b.resize(k+1);
	for(int i=0;i<2*k;i++)a.set(i,w[(k-C2(i)%k)%k].x);
	//for(int i=0;i<2*k;i++)std::cout<<a.val(i)<<" ";std::cout<<std::endl;
	for(int i=0;i<k;i++)b.set(k-i,(w[C2(i)%k]*(G0*((S*w[i]+_1)^L))[1][y]).x);
	//for(int i=0;i<k;i++)std::cout<<b.val(i)<<" ";std::cout<<std::endl;
	poly c=a*b;
	for(int i=0;i<k;i++)out::write((c.val(k+i)*w[C2(i)%k]/k).x),out::putc('\n');
	out::flush();
	return 0;
}
```

---

## 作者：Prean (赞：3)

感觉比想象中的简单多了。。。除了比较缝合之外没什么难点。。。

显然有 DP：

设 $f[t][i][k]$ 表示目前在第 $t$ 行 $i$ 列，走的步数对 $k$ 取模的方案数，$g[t][i][k]=\sum_{j=0}^{i}f[t][j][k]$。

显然有 $f[t][i][k]=\sum_{x=1}^{n}g[x][i-1][k-1\bmod K]\times w[p][q]$

直接把 $k$ 的维度看成多项式，显然是一个循环卷积，有：
$$f[q][i](x)=\sum_{p=1}^{n}g[p][i-1](x)\times w[p][q](x)$$
$$g[q][i](x)=g[q][i-1](x)+\sum_{p=1}^{n}g[p][i-1](x)\times w[p][q](x)$$
对于循环卷积最好的办法是 FFT，注意到 $k\mid(p-1)$ 所以可以使用单位根：
$$g[q][i](\omega_k^t)=g[q][i-1](\omega_k^t)+\sum_{p=1}^{n}g[p][i-1](\omega_k^t)\times w[x][t](\omega_k^t)$$
只需要在最开始的时候对所有相关的东西做一遍长度为 $k$ 的 FFT 即可，这里使用 Z 变换即可。

继续，每次对 $\omega_k^t$ 相同的部分做：
$$g_q[i]=g_q[i-1]+\sum_{p=1}^{n}g_p[i-1]\times w[p][q]$$
这里就有常系数齐次线性递推的影子了。

这里稍微推一下可以用常系数齐次线性递推，或者偷懒用矩快也行。

复杂度 $O(k\log k+kn^3\log L)$，稳的。

以及这题任意模数需要 MTT，不懂为什么需要单位根反演。

注意到边界条件是 $f[x][0][0]=1$，那么显然有 $f[t][0](w_k^t)=[t=x]$。

而 $w[x][y](w_k^t)$ 很显然是一个类似 $c^t\times w[x][y]$ 的东西，可以使用 $c^{tL}\times w^L$ 只算一次矩快，复杂度能够被优化到 $O(k\log k+n^3\log L)$。
```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
#define IMP(lim,act) for(int qwq=(lim),i=0;i^qwq;++i)act
typedef double db;
const db Pi=acos(-1);
const int M=1<<16|5;
inline int read(){
	int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
inline void write(int n){
	static char s[15];int top(0);while(s[++top]=n%10^48,n/=10);while(putchar(s[top]),--top);putchar(10);
}
struct Barrett{
	typedef unsigned long long ull;
	typedef __uint128_t LL;
	ull B,m;
	Barrett(const ull&m=2):m(m),B((LL(1)<<64)/m){}
	friend inline ull operator%(const ull&a,const Barrett&mod){
		ull r=a-mod.m*(LL(mod.B)*a>>64);return r>=mod.m?r-mod.m:r;
	}
}mod;
int n,k,L,x,y,g,P,W[3][3],f[M];
int w1,c[M<<1],ic[M<<1],F[M<<1],G[M<<1],H[M<<1];
inline void swap(int&a,int&b){
	int c=a;a=b;b=c;
}
inline int qpow(int a,int b){
	int ans(1);for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;
}
inline int findg(int P){
	static int p[10];int len(0),phi=P-1;
	for(int i=2;i*i<=phi;++i)if(!(phi%i)){
		p[++len]=i;while(!(phi%i))phi/=i;
	}
	if(phi^1)p[++len]=phi;
	int g=2;
	while(true){
		bool typ(true);
		for(int i=1;i<=len;++i)if(qpow(g,(P-1)/p[i])==1){
			typ=false;break;
		}
		if(typ)return g;++g;
	}
	return-1;
}
struct complex{
	db x,y;
	complex(const db&x=0,const db&y=0):x(x),y(y){}
	inline complex operator+(const complex&it)const{
		return complex(x+it.x,y+it.y);
	}
	inline complex operator-(const complex&it)const{
		return complex(x-it.x,y-it.y);
	}
	inline complex operator*(const complex&it)const{
		return complex(x*it.x-y*it.y,x*it.y+y*it.x);
	}
}buf[M<<2],*w[20];
inline int Getlen(const int&n){
	int len(0);while((1<<len)<n)++len;return len;
}
inline void swap(complex&a,complex&b){
	complex c=a;a=b;b=c;
}
inline int Get(const db&x){
	return((long long)floor(x+.5))%mod;
}
inline void init(const int&n){
	const int&m=Getlen(n);complex*now=buf;w[m]=now;now+=1<<m;
	IMP(1<<m,w[m][i]=complex(std::cos(i*Pi/(1<<m)),std::sin(i*Pi/(1<<m))));
	for(int k=m-1;k>=0&&(w[k]=now,now+=1<<k);--k)IMP(1<<k,w[k][i]=w[k+1][i<<1]);
}
inline void DFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=n>>1,d=M-1;d>=0;--d,len>>=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*R)),*L++=(x+y),*R++=*W++*(x-y);
	}
}
inline void IDFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=1,d=0;d^M;++d,len<<=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*W++**R)),*L++=(x+y),*R++=(x-y);
	}
	IMP(n,(f[i].x/=n,f[i].y/=n));for(int i=1;(i<<1)<n;++i)swap(f[i],f[n-i]);
}
inline void MTT(int*f,int*g,int*h,const int&n,const int&m,const int&LEN){
	static complex Q[M<<1],P[M<<1],T[M<<1];const int&len=Getlen(LEN);
	IMP(n,(Q[i].x=f[i]&32767,P[i].x=f[i]>>15));IMP(m,T[i]=complex(g[i]&32767,g[i]>>15));
	DFT(Q,len);DFT(P,len);DFT(T,len);IMP(1<<len,(Q[i]=Q[i]*T[i],P[i]=P[i]*T[i]));IDFT(Q,len);IDFT(P,len);
	IMP(LEN,h[i]=(Get(Q[i].x)+(1ll*Get(Q[i].y+P[i].x)<<15)+(1ll*Get(P[i].y)<<30))%mod);
	IMP(1<<len,Q[i]=P[i]=T[i]=0);
}
inline void czt_init(const int&n){
	c[0]=ic[0]=1;c[1]=w1=qpow(g=findg(P),(P-1)/n);ic[1]=qpow(c[1],P-2);
	for(int i=2;i^n+n-1;++i)c[i]=1ll*c[i-1]*c[1]%mod;for(int i=2;i^n;++i)ic[i]=1ll*ic[i-1]*ic[1]%mod;
	for(int i=1;i^n+n-1;++i)c[i]=1ll*c[i-1]*c[i]%mod;for(int i=1;i^n;++i)ic[i]=1ll*ic[i-1]*ic[i]%mod;
	IMP(n+n-1,G[i]=c[i]);
}
inline void CZT(int*f,const int&n,const bool&typ){
	IMP(n,F[n-i]=1ll*f[i]*ic[i])%mod;
	MTT(F,G,H,n+1,n+n-1,n+n);IMP(n,f[i]=1ll*H[n+i]*ic[i]%mod);IMP(n+n,F[i]=H[i]=0);
	if(typ)for(int i=1;(i<<1)<n;++i)swap(f[i],f[n-i]);const int&k=qpow(n,P-2);IMP(n,f[i]=1ll*f[i]*k%mod);
}
namespace MATRIX{
	const int S=3;
	struct Matrix{
		int a[S][S];
		Matrix(){
			for(int i=0;i^n;++i)for(int j=0;j^n;++j)a[i][j]=0;
		}
		inline Matrix&I(){
			for(int i=0;i^n;++i)for(int j=0;j^n;++j)a[i][j]=i==j;return*this;
		}
		inline int*operator[](const int&x){
			return a[x];
		}
		inline Matrix operator*(Matrix b){
			static long long c[S][S];Matrix ans;
			for(int i=0;i^n;++i)for(int j=0;j^n;++j)for(int k=0;k^n;++k)c[i][j]+=1ll*a[i][k]*b[k][j];
			for(int i=0;i^n;++i)for(int j=0;j^n;++j)ans[i][j]=c[i][j]%mod,c[i][j]=0;return ans;
		}
		inline Matrix pow(int b){
			Matrix ans,base=*this;ans.I();for(;b;b>>=1,base=base*base)if(b&1)ans=ans*base;return ans;
		}
	};
}
signed main(){
	MATRIX::Matrix m;
	n=read();k=read();L=read();x=read()-1;y=read()-1;mod=Barrett(P=read());init(k<<1);czt_init(k);
	for(int i=0;i^n;++i)for(int j=0;j^n;++j)W[i][j]=read();for(int x=0;x^n;++x)for(int y=0;y^n;++y)m[x][y]=W[x][y];
	for(int i=0;i^k;++i){
		for(int x=0;x^n;++x)++m[x][x];f[i]=m.pow(L)[x][y];for(int x=0;x^n;++x)--m[x][x];
		for(int x=0;x^n;++x)for(int y=0;y^n;++y)m[x][y]=1ll*m[x][y]*w1%mod;
	}
	CZT(f,k,true);IMP(k,write(f[i]));
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

首先，一个矩阵快速幂的常规应用是来计算一个图里面长度恰好为 $k$ 的 $x\rightarrow y$ 路径数量。

假设在这道题目里链接矩阵为 $D$。那么 $m$ 步骤的 $x\rightarrow y$ 路径数量是 $\binom Lm (D^m)_{x,y}$；二项式系数是从选择第一维是什么。

现在可以推式子了：

$$a_t=\sum_{m=0}^L\binom Li(D^m)_{x,y}[m\bmod k=t]$$  
$$a_t=\sum_{m=0}^L\binom Li(D^m)_{x,y}[k|m-t]$$

假设我们找到了一个 $p$ 的原根，那么久可以单位根反演：

$$a_t=\sum_{m=0}^L\binom Li(D^m)_{x,y}\sum_{i=0}^{k-1}\omega_k^{i(m-t)}$$
$$a_t=\sum_{m=0}^L\binom Li(D^m)_{x,y}\sum_{i=0}^{k-1}\omega_k^{im}\omega_k^{-it}$$
$$a_t=\sum_{i=0}^{k-1}\omega_k^{-it}\sum_{m=0}^L\binom Li(D^m)_{x,y}\omega_k^{im}$$

以下根据一些矩阵的性质。

$$a_t=\sum_{i=0}^{k-1}\omega_k^{-it}\sum_{m=0}^L\binom Li((\omega_k^iD)^m)_{x,y}$$

反二项式定理

$$a_t=\sum_{i=0}^{k-1}\omega_k^{-it}((\omega_k^iD+I)^m)_{x,y}$$

对 $i=0,1,\dots,k-1$ 处理出来 $r_i=((\omega_k^iD+I)^m)_{x,y}$：

$$a_t=\sum_{i=0}^{k-1}\omega_k^{-it}r_i$$

$$a_t=\sum_{i=0}^{k-1}r_i((\omega_k^{-1})^t)^i$$

这个等价于有一个多项式 

$$P(x)=\sum_{i=0}^{k-1}r_ir^i$$

然后又 $a_t=P((\omega_k^{-1})^t)$。多点求值？~~显然炸上天~~ 可以用一个叫 CZT（思想是拆开 $it$）的东西来 $O(N\log N)$ 的一个多项式乘法解决这个东西。现在时间复杂度 $O(kn^3\log L+k\log k+\log^7p)$（从左到右：处理 $r_i$，做 CZT，找原根）~~实际是 O(可过）~~

代码：

```
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair
 
using ll=long long;
using pii=pair<int, int>;
//#define int ll
int p = 1000000007;

int qpow(int b, int e, int MOD) {
	int ans = 1;
	while(e) {
		if(e & 1) ans = 1ll * ans * b % MOD;
		b = 1ll * b * b % MOD;
		e >>= 1;
	}
	return ans;
}

int generator (int p) {
    vector<int> fact;
    int phi = p-1,  n = phi;
    for (int i=2; i*i<=n; ++i)
        if (n % i == 0) {
            fact.push_back (i);
            while (n % i == 0)
                n /= i;
        }
    if (n > 1)
        fact.push_back (n);

    for (int res=2; res<=p; ++res) {
        bool ok = true;
        for (size_t i=0; i<fact.size() && ok; ++i)
            ok &= qpow (res, phi / fact[i], p) != 1;
        if (ok)  return res;
    }
    return -1;
}

template<typename T, int S>
struct mat {
	T dat[S][S];
	void init() { rep(i, S) rep(j, S) dat[i][j] = 0; }
	T* operator[](int a) { return dat[a]; }
	T const* operator[](int a) const { return dat[a]; }
	mat mult(const mat&b) const {
		mat ans; ans.init(); rep(i, S) rep(j, S) rep(k, S) ans[i][k]=(ans[i][k]+dat[i][j]*b[j][k])%p;
		return ans;
	}
};

using matt=mat<ll, 3>;

matt qpow(const matt& b, const ll&e) {
	if(e==1) return b;
	if(!(e&1)) return qpow(b.mult(b),e>>1);
	return qpow(b,e-1).mult(b);
}

matt ini;
int w, iw, n;

int calc(int x, int y, int L, int j) {
	matt h; h.init();
	ll v = qpow(w, j, p);
	rep(i, n) rep(j, n) h[i][j] = (v * ini[i][j] + (i==j)) % p;
	return qpow(w, 1ll * j * (j-1) / 2 % (p - 1), p) * qpow(h, L)[x][y] % p;
}

namespace mootootoo {
	using cd=std::complex<long double>;
	const long double PI=acos(-1.0);

	int rev[262144];
	long double ang[20][2];
	cd w[20][2][262144];

	void constructrev(int n) {
			for(int i=1, j=0; i < n; i++) {
					int bit = n >> 1;
					for(; j & bit; bit >>= 1) j ^= bit;
					j ^= bit;
					rev[i] = j;
			}
			for(int l=1; (1<<l)<=n; l++) {
					rep(inv, 2) {
							ang[l][inv] = (2*inv-1)*2*PI/(1<<l);
							cd re(cos(ang[l][inv]), sin(ang[l][inv]));
							w[l][inv][0] = cd(1.0);
							rep1(i, (1<<(l-1))) w[l][inv][i] = w[l][inv][i-1] * re;
					}
			}
	}

	void fft(cd* v, int n, bool inv) {
			rep(i, n) if(i < rev[i]) swap(v[i], v[rev[i]]);
			for(int l=1; (1<<l)<=n; l++) {
					for(int i=0; i<n; i+=(1<<l)) {
							int p = i+(1<<(l-1));
							iter(j, i, p) {
									cd a = v[j], b = v[j+(1<<(l-1))]*w[l][inv][j-i];
									v[j] = a+b; v[j+(1<<(l-1))] = a-b;
							}
					}
			}
			if(inv) rep(i, n) v[i] /= n;
	}

	cd a1[65536*4], b1[65536*4];
	cd a2[65536*4], b2[65536*4];
	cd r1[65536*4], r2[65536*4], r3[65536*4];
	int Av[65536*4], Bv[65536*4];
	ll ans[65536*4];

	void mult(const int& as, const int& bs, const int& C, const int& P) {
			int n = as+bs-1;
			while(n - (n & (-n))) n += (n & (-n));
			constructrev(n);
			rep(i, as) {
					a1[i] = cd(Av[i] % C);
					a2[i] = cd(Av[i] / C);
			}
			rep(i, bs) {
					b1[i] = cd(Bv[i] % C);
					b2[i] = cd(Bv[i] / C);
			}
			fft(a1, n, 0); fft(a2, n, 0); fft(b1, n, 0); fft(b2, n, 0);
			rep(i, n) r1[i] = a1[i]*b1[i];
			rep(i, n) r2[i] = (a1[i]*b2[i]+a2[i]*b1[i]);
			rep(i, n) r3[i] = a2[i]*b2[i];
			fft(r1, n, 1); fft(r2, n, 1); fft(r3, n, 1);
			int V = C*C%P;
			rep(i, n) ans[i] = (((ll)round(r1[i].real())%P)+C*((ll)round(r2[i].real()))%P+V*((ll)round(r3[i].real())%P))%P;
	}
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int k, L, x, y; cin >> n >> k >> L >> x >> y >> p;
	x--; y--;
	int g = generator(p);
	w = qpow(g, (p-1)/k, p);
	iw = qpow(w, p-2, p);
	ini.init();
	rep(i, n) rep(j, n) cin >> ini[i][j];
	rep(i, 2*k) mootootoo::Av[i] = qpow(iw, 1ll * i * (i-1) / 2 % (p - 1), p);
	rep(i, k) mootootoo::Bv[k-1-i] = calc(x, y, L, i);
	//rep(i, 2*k) rep(j, 2*k) mootootoo::ans[i+j] = (mootootoo::ans[i+j] + 1ll * mootootoo::Av[i] * mootootoo::Bv[j]) % p;
	mootootoo::mult(2*k, 2*k, 1<<15, p);
	int ik = qpow(k, p-2, p);
	rep(i, k) cout << mootootoo::ans[k-1+i] * ik % p * qpow(w, 1ll * i * (i-1) / 2 % (p-1), p) % p << endl;
}

```

---

## 作者：AzusaCat (赞：2)

我们先来考虑，如果给定 $m$（长度），怎么求方案数。

显然我们可以把横着（二元组的第一维）的单独考虑，即我们要在 $L$ 个横坐标内选出 $m$ 个经过的横坐标，这部分的方案为 $\dbinom{L}{m}$；然后考虑纵坐标，当 $n=1$ 的时候显然是 $w_{1,1}^m$，当 $n>1$ 时，如果上一步在 $a$，发现会给下一步的 $1-n$ 分别贡献 $w_{a,1},w_{a,2},\dots,w_{a,n}$，发现这是一个矩阵乘法的形式，记 $W$ 为
$$
\begin{bmatrix}
w_{1,1}  & \dots & w_{1,n}\\
\vdots  & \ddots &  \vdots \\
w_{n,1}  & \dots & w_{n,n}
\end{bmatrix}
$$
即第二维的邻接矩阵，为了防止变量重复，我们记题目中的 $x,y$ 为 $a,b$，那么 $\dbinom{L}{m}W^m_{a,b}$ 就是答案。

然后我们考虑用多项式来表示这个式子，即我们构造一个系数为矩阵的多项式：
$$
F(x)=(I+Wx)^L
$$
其中 $I$ 是单位矩阵，则 $\left([x^m]F(x)\right)_{a,b}$ 就是答案。

那么我们考虑题目要求的是所有模 $k$ 等于 $t$ 的 $m$ 的答案之和，即
$$
\sum\limits_{m\equiv t\pmod k}\left([x^m]F(x)\right)_{a,b}
$$
那么我们就是要求
$$
ans_t=\sum\limits_{m\equiv t\pmod k}\left([x^m]F(x)\right)_{a,b}
$$
根据单位根反演的简单推广，可以得到
$$
\begin{aligned}
ans_t&=\sum\limits_{m\equiv t\pmod k}\left([x^m]F(x)\right)_{a,b}\\
&=\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{-tj}F(w_k^j)_{a,b}
\end{aligned}
$$
推导过程可以看[这里](https://s1rius.gitee.io/2020/07/28/单位根反演/#more)，注意单位根反演对矩阵也是成立的（似乎只需要满足数乘对加法有分配律就可以）。

显然 $F(w_k^j)_{a,b}$ 可以通过矩阵快速幂来求（把邻接矩阵乘上 $w_k^j$ 再加上单位矩阵的 $L$ 次方），现在的问题就是我们要对每个 $0\leqslant t\leqslant k-1$ 都求出 $ans_t$。

发现这是一个任意基 IDFT 的形式，并且不一定存在 $2k$ 次单位根，我们考虑使用 Bluestein's Algorithm 的形式二，即把 $-tj$ 拆成 $\dbinom{t}{2}+\dbinom{j}{2}-\dbinom{t+j}{2}$，那么带入并化简：
$$
\begin{aligned}
ans_t&=\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{-tj}F(w_k^j)_{a,b}\\
&=\frac{1}{k}\sum\limits_{j=0}^{k-1}w_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}F(w_k^j)_{a,b}\\
&=\frac{w_k^{\binom{t}{2}}}{k}\sum\limits_{j=0}^{k-1}w_k^{\binom{j}{2}-\binom{t+j}{2}}F(w_k^j)_{a,b}\\
\end{aligned}
$$
设 $A(x)=\sum\limits_iw_k^{\binom{i}{2}}F(w_k^j)_{a,b}x^i$，$B(x)=\sum\limits_iw_k^{-\binom{i}{2}}x^i$后面是一个差一定的卷积形式，可以通过反转 $B$ 求解。

由于这题不一定是 NTT 模数，所以需要自己找到原根然后写一个 MTT。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int F[400005],G[400005],H[400005],g,n,k,l,a,b,p;
namespace poly
{
    long double const pi=acos(-1);
    struct comp
    {
        long double r,i;
        comp(){r=i=0;}
        comp(long double x,long double y){r=x,i=y;}
        comp conj(){return comp(r,-i);}
        friend comp operator +(comp x,comp y){return comp(x.r+y.r,x.i+y.i);}
        friend comp operator -(comp x,comp y){return comp(x.r-y.r,x.i-y.i);}
        friend comp operator *(comp x,comp y){return comp(x.r*y.r-x.i*y.i,x.i*y.r+x.r*y.i);}
    };
    typedef long long ll;
    int r[400005];
    comp a[400005],b[400005],c[400005],d[400005];
    void fft(comp *f,int n,int op)
    {
        for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)+((i&1)?(n>>1):0);
        for(int i=1;i<n;i++)if(i<r[i])swap(f[i],f[r[i]]);
        for(int len=2;len<=n;len<<=1)
        {
            int q=len>>1;
            comp wn=comp(cos(pi/q),op*sin(pi/q));
            for(int i=0;i<n;i+=len)
            {
                comp w=comp(1,0);
                for(int j=i;j<i+q;j++,w=w*wn)
                {
                    comp d=f[j+q]*w;
                    f[j+q]=f[j]-d;
                    f[j]=f[j]+d;
                }
            }
        }
    }
    void mtt(int *f,int *g,int *h,int n,int p)
    {
        for(int i=0;i<n;i++)
            a[i].r=(f[i]>>15),a[i].i=(f[i]&32767),
            c[i].r=(g[i]>>15),c[i].i=(g[i]&32767);
        fft(a,n,1),fft(c,n,1);
        for(int i=1;i<n;i++)b[i]=a[n-i].conj();
        b[0]=a[0].conj();
        for(int i=1;i<n;i++)d[i]=c[n-i].conj();
        d[0]=c[0].conj();
        for(int i=0;i<n;i++)
        {
            comp 
            aa=(a[i]+b[i])*comp(0.5,0),
            bb=(a[i]-b[i])*comp(0,-0.5),
            cc=(c[i]+d[i])*comp(0.5,0),
            dd=(c[i]-d[i])*comp(0,-0.5);
            a[i]=aa*cc+comp(0,1)*(aa*dd+bb*cc),b[i]=bb*dd;
        }
        fft(a,n,-1),fft(b,n,-1);
        for(int i=0;i<n;i++)
        {
            int 
            aa=(ll)(a[i].r/n+0.5)%p,
            bb=(ll)(a[i].i/n+0.5)%p,
            cc=(ll)(b[i].r/n+0.5)%p;
            h[i]=((1ll*aa*(1<<30)+1ll*bb*(1<<15)+cc)%p+p)%p;
        }
    }
}
using poly::mtt;
int pw(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1)res=1ll*res*x%p;
        x=1ll*x*x%p;
        y>>=1;
    }
    return res;
}
inline int mod(int x){return x>=p?x-p:x;}
int get(int x)
{
    vector<int>v;
    int t=p-1;
    for(int i=2;i*i<=t;i++)
    {
        if(!(t%i))
        {
            v.push_back(i);
            while(!(t%i))t/=i;
        }
    }
    for(int i=2;i<=p-1;i++)
    {
        bool flag=1;
        for(int j=0;j<v.size();j++)
            if(pw(i,(p-1)/v[j])==1){flag=0;break;}
        if(flag)return i;
    }
}
struct matrix
{
    int s[4][4];
    matrix(){memset(s,0,sizeof(s));}
    friend matrix operator *(matrix a,matrix b)
    {
        matrix tmp;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                for(int k=1;k<=n;k++)
                    tmp.s[i][j]=mod(tmp.s[i][j]+1ll*a.s[i][k]*b.s[k][j]%p);
        return tmp;
    }
    friend matrix operator *(int a,matrix b)
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                b.s[i][j]=1ll*b.s[i][j]*a%p;
        return b;
    }
    friend matrix operator +(matrix a,matrix b)
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                b.s[i][j]=mod(a.s[i][j]+b.s[i][j]);
        return b;
    }
}W,I;
matrix pw2(matrix x,int y)
{
    matrix res=I;
    while(y)
    {
        if(y&1)res=res*x;
        x=x*x;
        y>>=1;
    }
    return res;
}
int main()
{
    scanf("%d%d%d%d%d%d",&n,&k,&l,&a,&b,&p);
    g=get(p);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&W.s[i][j]);
    for(int i=1;i<=n;i++)I.s[i][i]=1;
    int wk=pw(g,(p-1)/k),w=1;
    for(int i=0;i<k;i++,w=1ll*w*wk%p)
        F[i]=1ll*pw(wk,(1ll*i*(i-1)/2)%k)*pw2(w*W+I,l).s[a][b]%p;
    for(int i=0;i<(k<<1);i++)
        G[i]=1ll*pw(wk,(p-1-(1ll*i*(i-1)/2%k)));
    reverse(G,G+(k<<1));
    int lim=1,inv=pw(k,p-2);
    while(lim<(k<<1)+1)lim<<=1;
    mtt(F,G,H,lim,p);
    reverse(H,H+(k<<1));
    for(int i=0;i<k;i++)printf("%lld\n",1ll*inv*H[i]%p*pw(wk,(1ll*i*(i-1)/2)%k)%p);
    return 0;
}
```



---

## 作者：warzone (赞：2)

## 前言

[可能更好的阅读体验](https://www.luogu.com.cn/blog/wangrx/solution-p5293)

> 我成功了。我不再是以前的那个我了。  
> ———— by Karry5307

当年与 $\mathsf{A\color{red}krry}$ 一同参加 HNOI2019，然后 30pts 滚粗，自闭了 QAQ。

学习了单位根反演后，花了 1h，终于切掉这题。

~~即便学了单位根反演，这题还是很毒瘤。~~

## 题解

### 25pts
考虑 dp。

设 $f_{u,v,m}$ 表示跳 $m$ 步到 $(u,v)$ 的方案总数，则有

$$f_{0,x,0}=1,f_{u,v,m}=\sum_{u_0=0}^{u-1}\sum_{v_0=1}^nf_{u_0,v_0,m-1}w_{v_0,v}$$

这个 $\displaystyle\sum_{v_0=1}^n$ 对生成函数很不友好。  
查看数据范围，发现 $1\le n\le 3$ 。于是考虑矩阵快速幂：

$$
\vec{f}_{u,m}=\begin{bmatrix}f_{u,1,m}&f_{u,2,m}&\cdots&f_{u,n,m}\end{bmatrix}\\
W=\begin{bmatrix}
w_{1,1}&w_{1,2}&\cdots&w_{1,n}\\
w_{2,1}&w_{2,2}&\cdots&w_{2,n}\\
\vdots&\vdots&\vdots&\vdots\\
w_{n,1}&w_{n,2}&\cdots&w_{n,n}
\end{bmatrix}\\
\begin{matrix}
\\
f_{0,x,0}=1\\f_{0,v,0}=0&(v\not=x)\\
\vec{f}_{u,0}=\vec{0}&(u>0)\\
\end{matrix}\\
\vec{f}_{u,m}=\displaystyle\sum_{u_0=0}^{u-1}\vec{f}_{u_0,m-1}W
$$

矩阵乘法 $\times$ 关于矩阵加法 $+$ 满足分配律，因而 $W$ 会在右边累积。

设 $\displaystyle(\sum\ ^{(0)}f)(x)=f(x),(\sum\ ^{(m)} f)(x)=\sum_{x_0=0}^{x-1}(\sum\ ^{(m-1)}f)(x_0)$，则有

$$ϵ(x)=\begin{cases}
	1&(x=0)\\0&(x\not=0)
\end{cases},\vec{f}_{u,m}=(\sum\ ^{(m)}ϵ)(u)\vec{f}_{0,0}W^m$$

$\displaystyle(\sum\ ^{(m)}ϵ)(u)$ 使用有限微积分,发现就是 $\dfrac{u^{\underline{m}}}{m!}=\dbinom{u}{m}$ 。

设 $m\bmod k=t$ 时的答案为 $ans_t$，则   
$$ans_t=(\sum_{m=0}^L[m\bmod k=t]\binom{L}{m}\vec{f}_{0,0}W^m)_y$$

用这个柿子直接 $\Theta(Ln^3)$ 递推，可以得到 25 pts 的成绩。

### 100 pts

若去掉 $[m\bmod k=t]$ 的限制，则有 
$$\sum_{m=0}^L\binom{L}{m}\vec{f}_{0,0}W^m=\vec{f}_{0,0}\sum_{m=0}^L\binom{L}{m}W^m=\vec{f}_{0,0}(W+I)^m$$
其中 $I$ 为单位矩阵。

有一个结论：
$$[n|k]=\dfrac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ik}$$
其中 $\omega_n$ 为 $n$ 次单位根，这个结论被称为单位根反演。  

其实很好理解，若 $n|k$，则 $\omega_{n}^{ik}=1$ 。  
否则就是个等比数列求和，$\displaystyle\sum_{i=0}^{n-1}\omega_n^{ik}=\frac{\omega_n^{nk}-1}{\omega_n^k-1}=\frac{0}{\omega_n^k-1}=0$ 。

由于模数为质数，且为 $k$ 的倍数，可以用最小原根求出 $\omega_k$ 。

原根判别法：  
若对于 $\varphi(p)$ 的任意质因子 $a$，$g^\frac{\varphi(p)}{a}\equiv 1\pmod{p}$，则 $g$ 为 $p$ 的原根。  
最小原根不超过 $p^{0.25}$。$p$ 为质数时，$\varphi(p)=p-1$ 。

$[m\bmod k=t]=[k|(m-t)]$，套单位根反演的结论，得到

$$
ans_t=(\sum_{m=0}^L\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{i(m-t)}\binom{L}{m}\vec{f}_{0,0}W^m)_y\\
ans_t=\frac{1}{k}(\sum_{i=0}^{k-1}\sum_{m=0}^L\omega_k^{im}\omega_k^{-it}\binom{L}{m}\vec{f}_{0,0}W^m)_y\\
ans_t=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{-it}(\vec{f}_{0,0}\sum_{m=0}^L\binom{L}{m}\omega_k^{im}W^m)_y\\
ans_t=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{-it}(\vec{f}_{0,0}(\omega_k^iW+I)^L)_y
$$

用矩阵快速幂 $\Theta(k\log L)$ 求出 $g_i=(\vec{f}_{0,0}(\omega_k^iW+I)^L)_y$ 。于是有 

$$ans_t=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{-it}g_i$$

此时已经可以多点求值了，但由于是 MTT，会被卡常。

这时，可以把 $it$ 拆成 $\dfrac{1}{2}((t+i)^{\underline{2}}-t^{\underline{2}}-i^{\underline{2}})=\dbinom{t+i}{2}-\dbinom{t}{2}-\dbinom{i}{2}$，那么

$$ans_t=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{\binom{t}{2}+\binom{i}{2}-\binom{t+i}{2}}g_i=\frac{\omega_k^\binom{t}{2}}{k}\sum_{i=0}^{k-1}\omega_k^\binom{i}{2}g_i\omega_k^\binom{t+i}{2}$$

设 $h_i=\omega_k^\binom{k-1-i}{2}[0\le i\le k-1],s_i=\omega^\binom{i}{2}_kg_i$，则 
$$\sum_{i=0}^{k-1}\omega_k^\binom{i}{2}g_i\omega_k^\binom{t+i}{2}=\sum_{i=0}^{k-1}s_ih_{(k-1-t-i)\bmod k}$$
$$=\sum_{i=0}^{k-t-1}s_ih_{k-t-1-i}+\sum_{i=k-t}^{k-1}s_ih_{(k-1-t-i)\bmod k}$$
$$=(s\times h)_{k-1-t}+\sum_{i=k-t}^{k-1}s_{i}h_{2k-1-t-i}$$
$$=(s\times h)_{k-1-t}+\sum_{i=0}^{2k-1-t}s_ih_{2k-1-t-i}$$
$$=(s\times h)_{k-1-t}+(s\times h)_{2k-1-t}$$

于是一次卷积 $\Theta(k\log k)$ 即可求得。  
最终复杂度 $\Theta(k(\log L+\log k))$ 。

### code
```cpp
/* 
this code is made by warzone
2021.4.7 15:03
*/
#include<stdio.h>
#include<string.h>
#include<cmath>
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int word;
typedef unsigned char byte;
struct READ{//快读
	char c;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator >>(register type& num){
		while('0'>c||c>'9') c=getchar();
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		return *this;
	}
}cin;
word mod;
inline ull pow(register ull a,register word b){
	register ull ans=1;
	for(;b;b>>=1){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
	}
	return ans;
}//快速幂
struct complex{
	db real,imag;
	inline complex(){}
	inline complex(const complex& p){
		real=p.real,imag=p.imag;}
	inline complex(db a,db b=0){real=a,imag=b;}
	inline complex operator ~(){
		return complex(real,-imag);}
	inline complex operator +(const complex &p){
		return complex(real+p.real,imag+p.imag);}
	inline complex operator -(const complex &p){
		return complex(real-p.real,imag-p.imag);}
	inline complex operator *(const complex &p){
		return complex(real*p.real-imag*p.imag,
			real*p.imag+imag*p.real);}
	inline void operator +=(const complex &p){
		real+=p.real,imag+=p.imag;}
};//复数类
#define mx 17
#define mx_ 16
struct FFT{
	complex root[1<<mx],inv[1<<mx],eax[1<<mx],ebx[1<<mx];
	word realid[1<<mx];
	inline FFT(){
		for(register word i=0,head;head=i,i<1<<mx;++i)
			for(register byte floor=0;floor<mx;++floor,head>>=1)
				realid[i]=realid[i]<<1|(head&1);
		root[1<<mx_]=inv[1<<mx_]=1;
		for(register word i=1;i<1<<mx_;++i){
			#define PI std::acos(-1.0)/(1<<mx_)
			root[1<<mx_|i]=complex(std::cos(PI*i),std::sin(PI*i));
			inv[1<<mx_|i]=~root[1<<mx_|i];
			#undef PI
		}
		for(register word i=(1<<mx_)-1;i;--i)
			root[i]=root[i<<1],inv[i]=inv[i<<1];
	}
	#define fftfor(size)	\
		for(register word floor=1;floor<1u<<(size);floor<<=1)			\
			for(register word head=0;head<1u<<(size);head+=floor<<1)	\
				for(register word i=0;i<floor;++i)
	#define fft(num,root)(						\
		num2=num[head|i|floor]*root[i|floor],	\
		num[head|i|floor]=num[head|i]-num2,		\
		num[head|i]+=num2)
	#define id(size,i) (realid[i]>>(mx-(size)))
	#define FOR(size) for(register word i=0;i<1u<<(size);++i)
	#define cover(eax,ecx,edx)(	\
		num1=eax[i]+eax[((1u<<size)-i)&~(1u<<size)],	\
		num2=eax[i]-eax[((1u<<size)-i)&~(1u<<size)],	\
		ecx[i]=complex(num1.real/2,num2.imag/2),	\
		edx[i]=complex(num1.imag/2,-num2.real/2))
	complex ecx[1<<mx],edx[1<<mx],eex[1<<mx],efx[1<<mx];
	inline void operator()(word size,
		word *f,word *g,word *f_times_g){//MTT
		FOR(size){
			register word head=id(size+1,i);
			eax[head]=complex(f[i]>>16,f[i]&0xffff);
			ebx[head]=complex(g[i]>>16,g[i]&0xffff);
			head=id(size+1,i+(1u<<size));
			eax[head]=ebx[head]=0;
		}
		++size;
		register complex num1,num2;
		fftfor(size) fft(eax,root),fft(ebx,root);
		FOR(size) cover(eax,ecx,edx),cover(ebx,eex,efx);
		num1=complex(0,1);
		FOR(size){
			register word head=id(size,i);
			eax[head]=ecx[i]*eex[i]+num1*edx[i]*efx[i];
			ebx[head]=ecx[i]*efx[i]+num1*edx[i]*eex[i];
		}
		fftfor(size) fft(eax,inv),fft(ebx,inv);
		FOR(size){
			register ull out=0;
			out=(ull)(eax[i].real/(1u<<size)+0.5)%mod;
			out=(ull)(ebx[i].real/(1u<<size)+0.5)%mod+(out%mod<<16)%mod;
			out=(ull)(ebx[i].imag/(1u<<size)+0.5)%mod+out%mod;
			out=(ull)(eax[i].imag/(1u<<size)+0.5)%mod+(out%mod<<16)%mod;
			f_times_g[i]=out%mod;
		}
	}
	#undef fftfor
	#undef fft
	#undef id
	#undef cover
}fft;
word L,begin,end;
template<word n,word m>
struct matrix{//矩阵
	word num[n][m];
	inline matrix(){
		memset(this,0,sizeof(matrix));}
	inline matrix(const matrix& p){
		memcpy(this,&p,sizeof(matrix));}
	inline word* operator[](word id){
		return num[id];}
	inline void operator *=(ull x){
		for(register word i=0;i<n;++i)
			for(register word j=0;j<m;++j)
				num[i][j]=x*num[i][j]%mod;
	}
	inline void operator +=(const matrix &p){
		for(register word i=0;i<n;++i)
			for(register word j=0;j<m;++j)
				if((num[i][j]+=p.num[i][j])>=mod)
					num[i][j]-=mod;
	}
	template<word l>
	inline matrix<n,l> operator *(const matrix<m,l> &p){
		matrix<n,l> ans;
		for(register word i=0;i<n;++i)
			for(register word j=0;j<l;++j)
				for(register word k=0;k<m;++k)
					if((ans[i][j]+=(ull)(num[i][k])
						*p.num[k][j]%mod)>=mod)
							ans[i][j]-=mod;
		return ans;
	}
	inline matrix operator +(const matrix &p){
		matrix out(*this);return out+=p,out;}
	inline matrix operator *(ull x){
		matrix out(*this);return out*=x,out;}
};
template<word n>
struct vector:matrix<1,n>{//向量
	inline vector():matrix<1,n>(){}
	inline vector(const vector& p){
		memcpy(this,&p,sizeof(vector));}
	inline vector(const matrix<1,n> &p){
		memcpy(this,&p,sizeof(vector));}
	inline word& operator[](word id){
		return matrix<1,n>::num[0][id];}
};
word size_,n,g;
inline void getg(){//求最小原根
	word prime[32],size=0;
	prime[0]=1,size=0;
	for(g=mod-1;(g&1)^1;g>>=1)
		if(prime[size]!=2)
			prime[++size]=2;
	for(register ull i=3;i*i<=g;i+=2)
		for(;g%i==0;g/=i) 
			if(prime[size]!=i)
				prime[++size]=i;
	if(g!=1&&prime[size]!=g)
		prime[++size]=g;
	//分解 mod-1 质因数
	for(g=2;g<mod;++g){
		register word i;
		for(i=1;i<=size;++i)
			if(pow(g,(mod-1)/prime[i])==1)
				break;
		if(i==size+1) return;
	}//原根判别法
}
word eax[1<<mx],ebx[1<<mx],ecx[1<<mx];
template<byte size>
inline void getans(){
	if(size<size_) return getans<size+1>();
	matrix<size,size> value,I;
	for(register word i=0;i<size;I[i][i]=1,++i)
		for(register word j=0;j<size;++j)
			cin>>value[i][j];
	register ull num1=pow(g,(mod-1)/n);
	register ull num2=1;
	--begin,--end;
	for(register word i=0;i<n;++i){
		matrix<size,size> a=value*num2+I;
		vector<size> ans;
		ans[begin]=1;
		for(register word b=L;b;b>>=1){
			if(b&1) ans=ans*a;
			a=a*a;
		}//矩阵快速幂
		eax[i]=ans[end],ebx[i]=num2;//求单位根
		num2=num1*num2%mod;
	}
	for(register ll i=0;i<n;++i){
		ecx[i]=ebx[i*(i-1)/2%n];
		eax[i]=(ull)(eax[i])*ecx[i]%mod;
	}
	for(register word i=0;i<n;++i)
		ebx[n-1-i]=pow(ecx[i],mod-2);
	for(size_=0;1u<<size_<n;++size_);
	fft(size_,eax,ebx,eax);//卷积求答案
	num1=pow(n,mod-2);
	for(register word i=0;i<n;++i)
		printf("%llu\n",num1*ecx[i]%mod*(eax[n-1-i]+mod-eax[n+n-1-i])%mod);
}
template<>
inline void getans<4>(){
	perror("getans err");}
int main(){
	cin>>size_>>n>>L>>begin>>end>>mod;
	getg(),getans<1>();
	return 0;
}

```


---

## 作者：封禁用户 (赞：2)

蒟蒻并不会单位根反演，但是从朴素的DP也能推出来一样的东西qwq

(如果图片无法显示可以去https://yutong.site/?p=1388)

![](https://i.loli.net/2019/04/25/5cc08e6ab8cf3.png)



题外话:洛谷什么时候能支持多行Latex啊qwq..

```cpp
#include <assert.h>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <fstream>
#include <iostream>
#include <vector>
// #include
using int_t = long long int;
using std::cin;
using std::cout;
using std::endl;
using real_t = double;
using cpx_t = struct complex;
const int_t LARGE = 5e5;
const real_t PI = acos(-1);
struct complex {
    real_t real, imag;
    complex(real_t a = 0, real_t b = 0) : real(a), imag(b) {}
    complex operator+(const complex& rhs) const {
        return complex{real + rhs.real, imag + rhs.imag};
    }
    complex operator-(const complex& rhs) const {
        return complex{real - rhs.real, imag - rhs.imag};
    }
    complex operator*(const complex& rhs) const {
        return complex{real * rhs.real - imag * rhs.imag,
                       real * rhs.imag + imag * rhs.real};
    }
    complex& operator*=(const complex& rhs) {
        *this = (*this) * rhs;
        return *this;
    }
    complex conj() .{ return complex{real, -imag}; }
};
void transform(cpx_t* A, int size2, int arg);
void poly_mul(const int* A, int n, const int* B, int m, int* A0, int p);
// void transformX(int* A, int len, int g, int mod);
void transformNTT(int* A, int size2, int arg, int mod, int g);
std::vector<int> poly_dc_mul(const std::vector<int>& A);
void poly_inv(const int* A, int n, int* result);
void poly_div(const int* A, int n, const int* B, int m, int* R);
std::vector<int> poly_eval(const std::vector<int>& poly,
                           const std::vector<int>& vals);
void transformX(int* A0, int len, int g);
int power(int_t base, int_t index, int_t mod) {
    int result = 1;
    // base = (base % mod + mod) % mod;
    index = (index % (mod - 1) + mod - 1) % (mod - 1);
    while (index) {
        if (index & 1) result = (int_t)result * base % mod;
        index >>= 1;
        base = (int_t)base * base % mod;
    }
    assert(result >= 0);
    return result;
}
int_t mod;
struct Matrix {
    int_t n;
    int_t data[4][4];
    int_t* operator[](int_t r) { return data[r]; }
    int_t at(int_t r, int_t c) const { return data[r][c]; }
    Matrix(int_t n) {
        this->n = n;
        memset(data, 0, sizeof(data));
    }
    Matrix operator*(const Matrix& rhs) const {
        Matrix result(n);
        for (int_t i = 1; i <= n; i++) {
            for (int_t j = 1; j <= n; j++) {
                for (int_t k = 1; k <= n; k++) {
                    result[i][j] =
                        (at(i, k) * rhs.at(k, j) % mod + mod + result[i][j]) %
                        mod;
                }
            }
        }
        return result;
    }
    Matrix pow(int_t index) const {
        Matrix base = *this, result(n);
        for (int_t i = 1; i <= n; i++) result[i][i] = 1;
        while (index) {
            if (index & 1) result = result * base;
            base = base * base;
            index >>= 1;
        }
        return result;
    }
};
int_t n, k, l, x, y;
int_t mat[4][4];
Matrix makeMatrix(int_t x0) {
    Matrix result(n);
    for (int_t i = 1; i <= n; i++)
        for (int_t j = 1; j <= n; j++) {
            result[i][j] = x0 * mat[i][j] % mod;
            if (i == j) result[i][j] += 1;
            result[i][j] %= mod;
        }
    return result;
}
std::ostream& operator<<(std::ostream& os, const Matrix& mat) {
    for (int_t i = 1; i <= mat.n; i++) {
        for (int_t j = 1; j <= mat.n; j++) {
            os << mat.at(i, j) << " ";
        }
        cout << endl;
    }
    return os;
}
int flips[20][LARGE];
const auto flip = [=](int x, int size2) {
    int result = 0;
    for (int i = 1; i < size2; i++) {
        result |= (x & 1);
        x >>= 1;
        result <<= 1;
    }
    return result | (x & 1);
};
int main() {
    for (int i = 1; i < 19; i++) {
        for (int j = 1; j < (1 << i); j++) flips[i][j] = flip(j, i);
    }
    cin >> n >> k >> l >> x >> y >> mod;
    for (int_t i = 1; i <= n; i++)
        for (int_t j = 1; j <= n; j++) cin >> mat[i][j];
    Matrix M0(n);
    static int A[LARGE + 1];
    M0[1][x] = 1;
    int_t g = 2;
    std::vector<int_t> divs;
    int_t px = mod - 1;
    assert(px % k == 0);
    for (int_t i = 2; i * i <= px; i++) {
        if (px % i == 0) {
            divs.push_back(i);
            if (i * i != px) divs.push_back(px / i);
        }
    }
    for (; g <= mod - 2; g++) {
        bool ok = true;
        for (int_t x : divs) {
            if (power(g, x, mod) == 1 && x != mod - 1) {
                ok = false;
                break;
            }
        }
        if (ok) break;
    }
    for (int_t i = 0; i < k; i++) {
        int_t gx = power(g, (mod - 1) / k * i, mod);
        auto T = makeMatrix(gx);
        A[i] = (M0 * T.pow(l))[1][y];
    }
    transformX(A, k, g);
    const int_t leninv = power(k, mod - 2, mod);
    for (int_t i = 0; i < k; i++) printf("%lld\n", A[i] * leninv % mod);
    return 0;
}
void transformX(int* A0, int len, int g) {
    const auto C2 = [](int_t n) -> int_t { return n * (n - 1) / 2; };
    int root = power(g, (mod - 1) / len, mod);
    static int A[LARGE + 1], B[LARGE + 1], A1[LARGE + 1];
    for (int i = 0; i <= len * 2; i++) {
        A[i] = power(root, -C2(i), mod);
    }
    for (int i = 0; i < len; i++) {
        B[i] = (int_t)A0[i] * power(root, C2(i), mod) % mod;
    }
    std::reverse(B, B + len + 1);
    poly_mul(A, len * 2, B, len, A1, mod);
    for (int i = 0; i < len; i++)
        A0[i] = (int_t)A1[i + len] % mod * power(root, C2(i), mod) % mod;
}
void poly_mul(const int* A, int n, const int* B, int m, int* A0, int p) {
    int size2 = 0;
    while ((1 << size2) < n + m + 1) size2++;
    int len = (1 << size2);
    const int px = 3e4;
    static cpx_t C[LARGE + 1], D[LARGE + 1], G[LARGE + 1], Px[LARGE + 1];
    for (int i = 0; i < len; i++) {
        if (i <= n) {
            C[i] = cpx_t{A[i] / px};
            D[i] = cpx_t{A[i] % px};
        } else {
            C[i] = D[i] = cpx_t();
        }
        if (i <= m) {
            G[i] = cpx_t{B[i] / px, B[i] % px};
        } else {
            G[i] = cpx_t{0, 0};
        }
    }
    transform(C, size2, 1);
    transform(D, size2, 1);
    transform(G, size2, 1);
    for (int_t i = 0; i < len; i++) {
        C[i] = C[i] * G[i];
        D[i] = D[i] * G[i];
    }
    transform(C, size2, -1);
    transform(D, size2, -1);

    const auto make = [=](real_t x) -> int_t {
        assert(x / len >= -1);
        return (x / len) + 0.5;
    };
    for (int i = 0; i <= n + m; i++) {
        A0[i] = ((int_t)make(C[i].real) % p * px % p * px % p +
                 (int_t)make(C[i].imag + D[i].real) % p * px % p +
                 make(D[i].imag) % p) %
                p;
    }
}
void transform(cpx_t* A, int size2, int arg) {
    int len = (1 << size2);

    for (int i = 0; i < len; i++) {
        int x = flips[size2][i];
        if (x > i) std::swap(A[i], A[x]);
    }
    for (int i = 2; i <= len; i *= 2) {
        for (int j = 0; j < len; j += i) {
            for (int k = 0; k < i / 2; k++) {
                auto u = A[j + k],
                     t = cpx_t(cos(2 * PI / i * k), sin(2 * PI / i * k) * arg) *
                         A[j + k + i / 2];
                A[j + k] = u + t;
                A[j + k + i / 2] = u - t;
            }
        }
    }
}

```

---

## 作者：dcmfqw (赞：1)

下面的 $x$ 和 $y$ 均是单纯的下标，$X$ 和 $Y$ 才是是输入给定的 $x$ 和 $y$。

首先 $\rm dp$ 一手，设 $dp_{x,y,z}$ 为用 $z$ 步到 $(x,y)$ 号点的方案数。

那么转移方程是：

$$dp_{x,y,z}=\sum\limits_{i=1}^{x-1}\sum\limits_{j=1}^ndp_{i,j,z-1}w_{j,y}$$

复杂度爆炸，优化的一般想法是设一个前缀和数组 $pre_{x,y,z}=\sum\limits_{i=0}^xdp_{i,y,z}$，有：

$$dp_{x,y,z}=\sum\limits_{i=1}^npre_{x-1,i,z-1}w_{i,y}$$

既然都用了 $pre$ 数组了，干脆直接转移：

$$pre_{x,y,z}=pre_{x-1,y,z}+\sum\limits_{i=1}^npre_{x-1,i,z-1}w_{i,y}$$

注意到由于求答案时维度 $z$ 是模 $k$ 意义下的，那么转移过程中的 $z$ 也可以为模 $k$ 意义下的。

也即设 $mpre_{x,y,z}=\sum\limits_{k|i-z}pre_{x,y,i}$，那么：

$$mpre_{x,y,z}=pre_{x-1,y,z}+\begin{cases}\sum\limits_{i=1}^nmpre_{x-1,i,z-1}w_{i,y}&z>0\\\sum\limits_{i=1}^nmpre_{x-1,i,k-1}w_{i,y}&z=0\end{cases}$$

第 $i$ 个答案就是 $mpre_{L,Y,i}$（以 $0$ 开始计数），初始状态为 $mpre_{0,X,0}=1$。

到这就是 20pts。

发现 $k$ 的范围比较能接受，所以设一个多项式把第三维压进去：

$$f_{x,y}=\sum\limits_{i=0}^{k-1}mpre_{x,y,i}x^i$$

那么就可以集体转移（假设 $n=3$）：

$$\begin{bmatrix}f_{i,1}\\f_{i,2}\\f_{i,3}\end{bmatrix}=\begin{bmatrix}f_{i-1,1}\\f_{i-1,2}\\f_{i-1,3}\end{bmatrix}\begin{bmatrix}w_{1,1}x+1&w_{1,2}x&w_{1,3}x\\w_{2,1}x&w_{2,2}x+1&w_{2,3}x\\w_{3,1}x&w_{3,2}x&w_{3,3}x+1\end{bmatrix}$$

这里的多项式乘法是下标模 $k$ 意义下的循环卷积。

为了方便，下面设右边那个矩阵为 $s_{x,y}=w_{x,y}x+[x=y]$。

有：

$$\begin{bmatrix}f_{i,1}\\f_{i,2}\\f_{i,3}\end{bmatrix}=\begin{bmatrix}f_{0,1}\\f_{0,2}\\f_{0,3}\end{bmatrix}s^i$$

要求的答案就是 $f_{L,Y}$，初始状态是 $f_{0,X}=1$，$f_{0,x}=0(x\neq X)$。

那么答案就是 $s^L$ 这个矩阵的的第 $X$ 行第 $Y$ 列的多项式的系数。

不过即使 $n$ 奇小无比，直接做矩阵快速幂套 `FFT` 还是会炸到飞起。

由于我们是要求一个多项式，所以一个想法是选一些点，把它代进去用矩阵快速幂算点值，然后再用 `IFFT` 或多点求值等方法把它插回来。

但是这里要做的是循环卷积而不是一般加法卷积，所以随便选点会出问题。

注意到 `FFT` 本质上也是循环卷积，这提示我们选单位根。

也即对于 $0\le i<k$，选单位根 $x=\omega_k^i$ 代入 $s$ 矩阵内进行矩阵快速幂求答案多项式点值，可以证明这样在循环卷积意义下由点值还原回来的多项式也是正确的。

求点值复杂度 $O(n^3k\log L)$，前面的求原根复杂度忽略不计。

现在我们有多项式点值了，接下来考虑如何还原多项式。

由于 $k$ 不是 $2$ 的幂，所以不能直接 `INTT`。

但是看 `INTT` 的过程：

> 把点值换成系数，$\omega_n^1$ 换成 $\omega_n^{-1}$，然后做一遍 `NTT`，再把答案除 $n$ 即可。

其实你会发现这个做法的正确性证明是和 $n$ 是 $2$ 的幂这个性质无关的，所以可以把这个做法直接套过来用。

换句话说设插出来第 $i$ 个点值为 $d_i$，也即 $d_i=f_{L,Y}(\omega_k^i)$，那么有：

$$mpre_{L,Y,i}=\frac1k\sum\limits_{j=0}^{k-1}d_j(\omega_k^{-i})^j$$

这个东西的做法可以去看 [这个题](https://www.luogu.com.cn/problem/P6800)。

由于这里是模 $p$ 意义下的运算，而且用复数会爆精度，所以单位根 $\omega_k^i$ 实际上是原根 $g^{\frac{p-1}ki}$，题目保证的 $k|p-1$ 就是这样用的。

还要注意要用 `MTT` 或三模 `NTT`，这个部分复杂度 $O(k\log k)$，总复杂度 $O(k\log k+n^3k\log L)$。

然后这个题就没了，其实你会发现这个做法的本质和直接推式子的做法的本质一模一样。


---

## 作者：zzw4257 (赞：0)

之前格式炸了...

> 给定一张$(L+1)*n(L大,n小)$的网格图,求从$(0,x)$到$(?,y)$经过$i$步($i\in\{x|x\equiv r\bmod k\}$)的方案数,模数任意

首先我们回顾一下求和引理(单位根反演)
$$
\Large \frac{1}{n} \sum_{i=0}^{n-1}\omega_n^{ki} = [n|k]
$$

### Step1

首先大胆$dp$

设$f_{i,j}$表示不管列的到走$i$步(从第$x$行)到$j$行方案数

答案是(累计上选列的方案$\binom{L}{i}$)
$$
\large \begin{aligned}
&ans=\sum_{i=0}^L[i\equiv r\bmod k]\binom{L}{i}f_{i,y}\\
&=\sum_{i=0}^L[k|i-r]\binom{L}{i}f_{i,y}\\
&=\sum_{i=0}^L\binom{L}{i}f_{i,y}\frac{1}{k}\sum_{j=0}^{k-1} \omega_k^{(i-r)j}\\
\end{aligned}
$$


则$f_{i,j}=\sum\limits_{k}f_{i-1,k}*w_{k,j}$,设$A$为$w$的生成矩阵:$\large A=\begin{bmatrix}w_{0,0}&\cdots&w_{0,n-1}\\&\cdots\\w_{n-1,0}&\cdots&w_{n-1,n-1}\end{bmatrix}$

可以发现$f_{i,?}$的生成矩阵$F_i=F_0A^i=A^i$

然后就有$f^{x出发情况下}_{i,y}=A^i_{x,y}$(这个没问题吧，看一下原本递推定义即可)
$$
\large \begin{aligned}
&ans=\sum_{i=0}^{L}\binom{L}{i}A^i_{x,y}\frac{1}{k}\sum_{j=0}^{k-1} \omega_k^{(i-r)j}\\
&=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{-ir}\sum_{j=0}^{L}\binom{L}{j}(A^j)_{x,y}\times \omega^{ij}_k\end{aligned}$$
//这里是二项式反演标准式子
$$
\large\begin{aligned}
&=\frac{1}{k}\sum_{i=0}^{k-1}\omega_k^{-ir}(w^i_kA+I)^L_{x,y}\\
&=\frac{1}{k}\sum_{i=0}^{k-1}a_i\omega_k^{-ir}
\end{aligned}
$$

### Step2

矩阵快速幂求$a_i$

### Step3

Bluestein's Algorithm($\text{CTZ})$的核心
$$
\large ab = \binom{a+b}{2} - \binom{a}{2} - \binom{b}{2}
$$

(另一个拆法是$ab=\frac{(a+b)^2}{2}-\frac{(a)^2}{2}-\frac{(b)^2}{2}$但那样会用到$\omega_{2n}^k$之类的东西，可能不存在)

$$
\large
\begin{aligned}
ans=\frac{1}{k}\sum_{i=0}^{k-1}a_i\omega_k^{-\binom{i+r}{2} + \binom{i}{2} + \binom{r}{2}}\\
=\frac{1}k\omega_k^{r \choose 2}\sum_{i=0}^{k-1}\omega_k^{i \choose 2}a_i\omega_k^{-{r+i \choose 2}}
\end{aligned}
$$

//老技巧翻转转卷积
$$
\large\begin{aligned}
f_i=\omega_k^{i \choose 2},g_i=a_i\omega_k^{-{r+i \choose 2}}\\
\therefore ans=\frac{\omega_k^{r\choose 2}}k[x^{k+r}](f^Rg)\\(f^R_{k-i}=\omega_k^{i \choose 2})\\
\end{aligned}
$$
直接$\mathtt{MTT}$卷就可以了

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 262145
using namespace std;
typedef long long ll;
typedef double ld;//特别卡 
int rev[N],n,K,L,x,y,mod,wk[N],f[N],g[N],h[N];
const ld PI=acos(-1);
inline ll Mod(ll x,ll p=mod){return x>=p?x-p:x;}
inline int qpow(int a,int b){}
//-----------------------------------------------------------------原根--------------------------------------------------------------------
inline char Checkg(int v){}
inline int Getg(void){}
//-----------------------------------------------------------------矩阵乘法--------------------------------------------------------------------
struct Matrix{
	int a[3][3];
	Matrix(){}
	inline void Set(void){}
	inline Matrix operator*(Matrix b){}
	inline Matrix operator^(int k){}
	inline Matrix Make(int b){}
}I,s;
//-----------------------------------------------------------------MTT--------------------------------------------------------------------
struct cp{}a[N],b[N],c[N],d[N],W[19][1<<19];
inline void Getinv(int len){}
inline void Init(void){}
inline void Mul(int *f,int *g,int n,int *ans){}
signed main(void){
	int i,j,inv;scanf("%d%d%d%d%d%d",&n,&K,&L,&x,&y,&mod),--x,--y;I.Set();Init();
	for(i=0;i<n;++i)for(j=0;j<n;++j)scanf("%d",&s.a[i][j]);
	for(*wk=wk[K]=1,wk[1]=qpow(Getg(),(mod-1)/K),i=2;i<K;++i)wk[i]=1ll*wk[i-1]*wk[1]%mod;
	for(i=0;i<K;++i)f[K-1-i]=1ll*wk[1ll*i*(i-1)/2%K]*((s.Make(wk[i]))^L).a[x][y]%mod;
	for(i=0;i<2*K-1;++i)g[i]=wk[K-1ll*i*(i-1)/2%K];
	Mul(f,g,K*3-1,h);
	for(inv=qpow(K,mod-2),i=0;i<K;++i)printf("%d\n",1ll*h[K-1+i]*inv%mod*wk[1ll*i*(i-1)/2%K]%mod);
	return 0;
}
```



---


# [北京省选集训2019] 生成树计数

## 题目描述

小S 刚刚学习了生成树的知识，聪明的他想出了一个问题：  
给定一个 $n$ 个点的带权无向完全图，求其所有生成树权值的 $k$ 次方之和。  
定义一个树的权值，为其所有边权值和。    

因为他不会，所以你要来做这题。  
由于答案可能很大，请输出答案对 $998244353$ 取模的结果。

## 说明/提示

### 数据范围：  
对于 $20\%$的数据：  $1\le n\le 5$   
对于另外 $10\%$ 的数据：  $k = 0$   
对于另外 $10\%$ 的数据：  $k = 1$    
对于 $60\%$ 的数据：  $1\le n \le 15$    
对于另外 $15\%$ 的数据： $1\le k \le 15$  
对于 $100\%$ 的数据：$1\le n \le 30$，$0 \le k \le 30$，$0\le w_{i,j} \le 998244352$  

注意 $0^0 = 1$

## 样例 #1

### 输入

```
3 1
0 0 1
0 0 1
1 1 0```

### 输出

```
4```

# 题解

## 作者：Elegia (赞：20)

把这个式子化开就相当于

$$ (w_1+w_2+\cdots +w_m)^k = k![z^k]\prod_{i=1}^m \mathrm{e}^{w_iz} $$

注意矩阵树定理的内容扩展一下实际上：Laplacian 矩阵的主余子式等于 $\sum_T \prod_{(u, v)\in T} w(u,v)$，因此只需要我们构造一个多项式矩阵 $w(u,v) = \sum_{i=0}^k \frac{(wz)^i}{i!}$ ，运算时仅保留至第 $k$ 次然后用求生成树数量的方法算行列式就行了。复杂度 $\Theta(n^3 k^2)$

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cctype>

#include <algorithm>
#include <random>
#include <bitset>
#include <queue>
#include <functional>
#include <set>
#include <map>
#include <vector>
#include <chrono>
#include <iostream>
#include <limits>
#include <numeric>

#define LOG(FMT...) fprintf(stderr, FMT)

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int N = 32, P = 998244353;

int n, k;
int ifac[N], res[N];
int a[N][N];
int g[N][N][N];

int norm(int x) { return x >= P ? x - P : x; }

void println(int* a, FILE* fp) {
  for (int i = 0; i < k; ++i)
    fprintf(fp, "%d ", a[i]);
  fprintf(fp, "%d\n", a[k]);
}

void exGcd(int a, int b, int& x, int& y) {
  if (!b) {
    x = 1;
    y = 0;
    return;
  }
  exGcd(b, a % b, y, x);
  y -= a / b * x;
}

int inv(int a) {
  int x, y;
  exGcd(a, P, x, y);
  return norm(P + x);
}

int* mul(int* a, int* b, int* out) {
  static int tmp[N];
  memset(tmp, 0, sizeof(tmp));
  for (int i = 0; i <= k; ++i)
    for (int j = 0; j <= k - i; ++j)
      tmp[i + j] = (tmp[i + j] + a[i] * (ll)b[j]) % P;
  memcpy(out, tmp, sizeof(tmp));
  return tmp;
}

int* pinv(int* a, int* out) {
  static int b[N], tmp[N];
  memset(tmp, 0, sizeof(tmp));
  tmp[0] = inv(a[0]);
  for (int i = 1; i <= k; ++i)
    b[i] = a[i] * (ll)tmp[0] % P;
  for (int i = 1; i <= k; ++i)
    for (int j = 1; j <= i; ++j)
      tmp[i] = (tmp[i] + (P - b[j]) * (ll)tmp[i - j]) % P;
  memcpy(out, tmp, sizeof(tmp));
  return out;
}

int main() {
  scanf("%d%d", &n, &k);
  ifac[1] = 1;
  for (int x = 2; x <= k; ++x)
    ifac[x] = -(P / x) * (ll)ifac[P % x] % P + P;
  ifac[0] = 1;
  for (int x = 1; x <= k; ++x)
    ifac[x] = ifac[x - 1] * (ll)ifac[x] % P;
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= n; ++j)
      scanf("%d", &a[i][j]);
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j < i; ++j) {
      int pw = 1;
      for (int t = 0; t <= k; ++t) {
        int v = pw * (ll)ifac[t] % P;
        g[i][j][t] = g[j][i][t] = norm(P - v);
        g[i][i][t] = norm(g[i][i][t] + v);
        g[j][j][t] = norm(g[j][j][t] + v);
        pw = pw * (ll)a[i][j] % P;
      }
    }

  res[0] = 1;
  --n;
  for (int i = 1; i <= n; ++i) {
    static int cur[N];
    mul(g[i][i], res, res);
    pinv(g[i][i], cur);
    for (int j = n; j >= i; --j)
      mul(g[i][j], cur, g[i][j]);
    memset(g[i][i], 0, sizeof(g[i][i]));
    g[i][i][0] = 1;
    for (int j = n; j > i; --j) {
      for (int t = n; t >= i; --t) {
        mul(g[i][t], g[j][i], cur);
        for (int l = 0; l <= k; ++l)
          g[j][t][l] = norm(g[j][t][l] + P - cur[l]);
      }
    }
  }
  int ans = res[k];
  for (int i = 1; i <= k; ++i)
    ans = ans * (ll)i % P;
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：Karry5307 (赞：13)

### 题意

定义一棵树的权值为所有边的权值和，给定一个 $n$ 个点的图，边有权值，求这个图中所有生成树权值的 $k$ 次方和。

$\texttt{Data Range:}1\leq n,k\leq 30$

### 题解

由于这个题需要求的是所有生成树的权值的和，而一个生成树的权值是所有边的和的 $k$ 次方（这里重新定义了），而不是 Matrix-Tree 板子题里面的所有边的积，这引导我们去寻找一个类似于求积的转移。

假设现在需要找一棵生成树，已经被加入的边的权值为 $w^k$，如果新加进来一条权值为 $w_i$ 的边，则新的部分的答案为 $(w+w_i)^k$，简单拆一下得到

$$(w+w_i)^k=\sum\limits_{j=0}^{k}\binom{k}{j}w^jw_i^{k-j}$$

注意到这个东西是二项卷积的形式，可以直接写成两个 EGF 的乘积，即

$$e^{(w+w_i)x}=e^{wx}e^{w_ix}$$

这个时候，对一条权值为 $w_i$ 的边来说，重新定义其权值为 $e^{w_ix}$，那么一棵生成树的权值为所有边的权值多项式的积中 $x^k$ 的系数，相当于就是计算所有边的权值多项式的积。这个按照板子题来就行了，唯一的不同是矩阵中的元素变成了多项式而不是数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef vector<ll> Poly;
const ll MAXN=51,MOD=998244353;
ll n,fd,x;
ll fact[MAXN],finv[MAXN];
Poly mat[MAXN][MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
	ll res=1;
	while(exponent)
	{
		if(exponent&1)
		{
			res=(li)res*base%MOD;
		}
		base=(li)base*base%MOD,exponent>>=1;
	}
	return res;
}
inline void setup(ll cnt)
{
	fact[0]=fact[1]=finv[0]=1;
	for(register int i=2;i<=cnt;i++)
	{
		fact[i]=(li)fact[i-1]*i%MOD;
	}
	finv[cnt]=qpow(fact[cnt],MOD-2);
	for(register int i=cnt-1;i;i--)
	{
		finv[i]=(li)finv[i+1]*(i+1)%MOD;
	}
}
inline void printPoly(Poly f)
{
	for(register int i:f)
	{
		printf("%d ",i);
	}
}
inline Poly operator +(const Poly &f,const Poly &g)
{
	Poly res;
	res.resize(fd);
	for(register int i=0;i<fd;i++)
	{
		res[i]=(f[i]+g[i])%MOD;
	}
	return res;
}
inline Poly operator -(const Poly &f,const Poly &g)
{
	Poly res;
	res.resize(fd);
	for(register int i=0;i<fd;i++)
	{
		res[i]=(f[i]-g[i]+MOD)%MOD;
	}
	return res;
}
inline Poly operator *(const Poly &f,const Poly &g)
{
	Poly res;
	ll r;
	res.resize(fd);
	for(register int i=0;i<fd;i++)
	{
		r=0;
		for(register int j=0;j<=i;j++)
		{
			r=(r+(li)f[j]*g[i-j])%MOD;
		}
		res[i]=r;
	}
	return res;
}
inline Poly inv(Poly f)
{
	Poly res;
	ll r,invl;
	res.resize(fd),res[0]=invl=qpow(f[0],MOD-2);
	for(register int i=1;i<fd;i++)
	{
		r=0;
		for(register int j=0;j<i;j++)
		{
			r=(r+(li)res[j]*f[i-j])%MOD;
		}
		res[i]=(li)(MOD-r)*invl%MOD;
	}
	return res;
}
inline Poly exp(ll x)
{
	Poly res;
	ll cur=1;
	res.resize(fd);
	for(register int i=0;i<fd;i++)
	{
		res[i]=(li)cur*finv[i]%MOD,cur=(li)cur*x%MOD;
	}
	return res;
}
inline void add(ll x,ll y,ll w)
{
	Poly f=exp(w);
	mat[x][x]=mat[x][x]+f,mat[y][y]=mat[y][y]+f;
	mat[x][y]=mat[x][y]-f,mat[y][x]=mat[y][x]-f;
}
inline ll det(ll n,ll kk)
{
	ll pivot,sgn=1;
	Poly cof,invl,res;
	res.resize(fd),res[0]=1;
	for(register int i=1;i<=n;i++)
	{
		pivot=n+1;
		for(register int j=i;j<=n;j++)
		{
			if(mat[j][i][0])
			{
				pivot=i;
				break;
			}
		}
		if(pivot==n+1)
		{
			return 0;
		}
		pivot!=i?swap(mat[pivot],mat[i]),sgn*=-1:1,invl=inv(mat[i][i]);
		for(register int j=i+1;j<=n;j++)
		{
			cof=mat[j][i]*invl;
			for(register int k=i;k<=n;k++)
			{
				mat[j][k]=mat[j][k]-cof*mat[i][k];
			}
		}
	}
	for(register int i=1;i<=n;i++)
	{
		res=res*mat[i][i];
	}
	return sgn==1?res[kk]:(MOD-res[kk])%MOD;
}
int main()
{
	n=read(),setup(fd=read()+1);
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=n;j++)
		{
			mat[i][j].resize(fd);
		}
	}
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=n;j++)
		{
			x=read(),i<j?add(i,j,x):(void)1;
		}
	}
	printf("%d\n",(li)det(n-1,fd-1)*fact[fd-1]%MOD);
}
```


---

## 作者：crashed (赞：9)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P5296)看题目。  
# 分析
&emsp;&emsp;考察一下矩阵树定理的基本式子：   
    
$$\sum_T \prod_{e\in T} w_e$$    
     
&emsp;&emsp;设$v(T)$为$T$的权值，我们发现，$v(T)$应该是$T$中的边的“某种意义”下的**积**。   
    
&emsp;&emsp;这意味着，我们只需要能够**保证$v(T)$的贡献可分割，便可以定义一个存在基础四则运算的“类型”，满足该“类型”的积就相当于合并了边的贡献**。利用该“类型”，我们就可以用矩阵树定理计算所有生成树的贡献。      
    
&emsp;&emsp;例如，一般矩阵树定理，利用（带模）整数的运算即可；   
   
&emsp;&emsp;再例如，求边权和的矩阵树定理，利用“一次函数”的“积”，我们求出了系数的“和”。   
   
&emsp;&emsp;对于此题，我们考虑将“合并贡献”作为切入点，即考虑已知$a^k,b^k$，如何求出$(a+b)^k$。   
   
&emsp;&emsp;当然这样没法做，我们考虑用二项式定理展开：   
   
$$(a+b)^k=\sum_{i=0}^k\binom{k}{i}a^ib^{k-i}$$   
    
&emsp;&emsp;这样需要用到较低次幂，不过没有关系，我们同样可以维护一下较低次幂，合并方法类似。   
   
&emsp;&emsp;~~仔细观察你会发现这是指数生成函数的卷积，不过在这道题里面没有用。~~   
   
&emsp;&emsp;然后我们只需要用长为$k+1$的向量$\vec{z}=\begin{bmatrix}a^0&a^1&a^2&\dots&a^k\end{bmatrix}$表示贡献即可。   
   
&emsp;&emsp;加法和减法：不再赘述。   
   
&emsp;&emsp;乘法：“二项式卷积”。   
   
&emsp;&emsp;求逆元：可以次数从低到高进行递推，不再赘述。   
   
&emsp;&emsp;单次乘法$O(k^2)$，总时间复杂度$O(n^3k^2)$。   
# 代码
```cpp
#include <cstdio>
#include <iostream>

const int mod = 998244353;
const int MAXN = 35;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int C[MAXN][MAXN], invC[MAXN][MAXN];
int K;

int inv( const int );
int qkpow( int, int );
void add( int&, const int );
void sub( int&, const int );

struct vec
{
	int num[MAXN] = {};
	
	//h(i)=¡Æ{j=0...n}f(j)*g(i-j)*C(i,j) 
	
	vec() {}
	vec( const int b ) { num[0] = b; }
	
	int& operator [] ( const int indx ) { return num[indx]; }
	
	vec inver() const
	{
		vec ret;
		ret[0] = inv( num[0] );
		for( int i = 1, tmp ; i <= K ; i ++ )
		{
			tmp = 0;
			for( int j = 0 ; j < i ; j ++ )
				add( tmp, 1ll * ret[j] * num[i - j] % mod * C[i][j] % mod );
			ret[i] = 1ll * ( mod - tmp ) % mod * ret[0] % mod;
		}
		return ret;
	}
	
	vec operator + ( vec g ) const
	{
		vec ret;
		for( int i = 0 ; i <= K ; i ++ )
			add( ret[i], num[i] ), add( ret[i], g[i] );
		return ret;
	}
	
	vec operator - ( vec g ) const 
	{
		vec ret;
		for( int i = 0 ; i <= K ; i ++ )
			add( ret[i], num[i] ), sub( ret[i], g[i] );
		return ret;
	}

	vec operator * ( vec g ) const 
	{
		vec ret;
		for( int i = 0 ; i <= K ; i ++ )
			for( int j = 0 ; j <= i ; j ++ )
				add( ret[i], 1ll * num[j] * g[i - j] % mod * C[i][j] % mod );
		return ret;
	}
	
	vec operator / ( vec g ) const { return g * inver(); }
	void operator += ( vec g ) { *this = *this + g; }
	void operator -= ( vec g ) { *this = *this - g; }
	void operator *= ( vec g ) { *this = *this * g; }
	void operator /= ( vec g ) { *this = *this / g; }

	operator bool() const 
	{
		bool ret = false;
		for( int i = 0 ; i <= K ; i ++ )
			ret |= num[i]; 
		return ret; 
	} 
};

vec D[MAXN][MAXN], G[MAXN][MAXN], Kich[MAXN][MAXN];
int N;

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

int inv( const int a ) { return qkpow( a, mod - 2 ); }
void sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }
void add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }

int det( vec T[][MAXN], const int n )
{
	vec ans = 1, tmp, inver; int indx;
	for( int i = 1 ; i <= n ; i ++ )
	{
		indx = -1;
		for( int j = i ; j <= n ; j ++ )
			if( T[j][i] ) 
			{ indx = j; break; }
		if( indx == -1 ) return 0;
		if( indx ^ i ) 
			for( int k = 0 ; k <= K ; k ++ )
				ans[k] = mod - ans[k];
		std :: swap( T[i], T[indx] );
		inver = T[i][i].inver();
		for( int j = i + 1 ; j <= n ; j ++ )
			if( T[j][i] )
			{
				tmp = T[j][i] * inver;
				for( int k = i ; k <= n ; k ++ )	
					T[j][k] -= T[i][k] * tmp;
			}
		ans *= T[i][i];
	}
	return ans[K];
}

int main()
{
	int w;
	read( N ), read( K );
	for( int i = 0 ; i <= K ; i ++ )
	{
		C[i][0] = C[i][i] = 1;
		for( int j = 1 ; j < i ; j ++ )
			add( C[i][j], C[i - 1][j] ), add( C[i][j], C[i - 1][j - 1] );
	}
	int t;
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
		{
			read( w ), t = 1;
			for( int k = 0 ; k <= K ; k ++ )
				G[i][j][k] = t, t = 1ll * t * w % mod;
		}
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
			D[i][i] += G[i][j];
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
			Kich[i][j] = D[i][j] - G[i][j];
	write( det( Kich, N - 1 ) ), putchar( '\n' );
	return 0;
}
```

---

## 作者：jun头吉吉 (赞：3)

## 题意
定义一棵生成树的权值为其边权和的 $k$ 次方，求所有生成树的权值之和。
## 题解
数据范围很矩阵树。~~被出烂的老套路了~~

我们的矩阵树定理只能求所有的积的和，因此强行把和化为积。

可以发现 $(w_1+\ldots+w_m)^k$ 相当于把 $k$ 个不同小球涂上 $\sum w_i$ 种颜色，$w$ 种的 $\mathbf{EGF}$ 是 $e^{wx}$，于是就变成 $k![x^n]\prod_i e^{w_ix}$。

当然如果发现 $k![x^k]e^{(w_1+\ldots+w_m)x}=(w_1+\ldots+w_m)^k$ 就更容易了。

于是现在已经是积的和的形式，把每条边的边权定义为 $e^{w_ix}$，那么所有的生成树的权值积的和就是我们希望的生成函数了，具体地，对于一棵树 $T$ 和边集 $e$：
$$\begin{aligned}
&\sum_{T}(w_{e_1}+\ldots+w_{e_{n-1}})^k\\
=&\sum_{T}k![x^k]\prod e^{w_{e_i}x}\\
=&k![x^k]\sum_{T}\prod e^{w_{e_i}x}
\end{aligned}$$
把多项式扔进矩阵跑高斯消元就完事了。

由于 $k$ 十分小，暴力卷积/求逆即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=35,K=32;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
	template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
	modint<mod> &operator++(int){return *this+=1;}
};
const int mod=998244353;
typedef modint<mod> mint;
int n,k=20,w[N][N];
struct poly{
	mint a[K];
	poly(mint C=0){memset(a,0,sizeof a);a[0]=C;}
	mint&operator[](const int x){return a[x];}
	poly inv(){poly c(1/a[0]);for(int i=1;i<=k;i++){for(int j=0;j<i;j++)c[i]-=c[j]*a[i-j];c[i]/=a[0];}return c;}
	poly operator+(poly b)const{poly c;for(int i=0;i<=k;i++)c[i]=a[i]+b[i];return c;}
	poly operator-(poly b)const{poly c;for(int i=0;i<=k;i++)c[i]=a[i]-b[i];return c;}
	poly operator*(poly b)const{poly c;for(int i=0;i<=k;i++)for(int j=0;j<=i;j++)c[i]+=a[j]*b[i-j];return c;}
	poly operator/(poly b)const{return *this*b.inv();}
	poly operator-(){poly c;for(int i=0;i<=k;i++)c[i]=-a[i];return c;}
	poly&operator+=(poly b){return *this=*this+b;}
	poly&operator-=(poly b){return *this=*this-b;}
	poly&operator*=(poly b){return *this=*this*b;}
	poly&operator/=(poly b){return *this=*this/b;}
}a[N][N];
mint fac[N],ifac[N];
poly Exp(mint w){poly A;mint tmp=1;for(int i=0;i<=k;i++,tmp*=w)A[i]=tmp*ifac[i];return A;}
poly det(int n){
	poly res(1);
	for(int i=1;i<=n;i++){
		int k=i;
		for(int j=i;j<=n;j++)
			if(a[j][i].a[0]!=0)k=j;
		if(a[k][i].a[0]==0)return poly(0);
		if(k!=i)swap(a[i],a[k]),res=-res;
		for(int j=i+1;j<=n;j++){
			poly inv=a[j][i]/a[i][i];
			for(int l=i;l<=n;l++)
				a[j][l]-=a[i][l]*inv;
		}
		res*=a[i][i];
	}
	return res;
}
signed main(){
	fac[0]=ifac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i,ifac[i]=1/fac[i];
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			cin>>w[i][j];
			if(i<j){
				poly tmp=Exp(w[i][j]);
				a[i][i]+=tmp;
				a[j][j]+=tmp;
				a[i][j]-=tmp;
				a[j][i]-=tmp;
			}
		}
	cout<<(det(n-1)[k]*fac[k]).x;
}
```

---

## 作者：Acoipp (赞：2)

## 分析

题目就是要求出所有：

$$
\sum_{T} (\sum_{e \in T}w_e)^k
$$

我们看到生成树计数相关问题就可以考虑使用矩阵树定理，但是矩阵树定理只能求出若边权为 $v$ 的时候：

$$
\sum_{T} (\prod_{e \in T}v_e)
$$

并且 $v_e$ 可以不是一个数，乘法我们也可以重定义，只需要满足结合律、分配律和交换律即可。

那么我们对于这道题可以每条边设置一个长度为 $k+1$ 的向量为 $[w^0 \ w^1 \ w^2 \ w^3 \ \dots \ w_k]$。

我们把 $\prod_{e \in T} v_e$ 单独拿出来，接下来我们要重新定义乘法运算使得最后我们可以得到 $(\sum_{e \in T}w_e)^k$。

假如说我们知道了当前边集和的 $k$ 次方，加入一条边，那么新的边集和的 $k$ 次方为：

$$
(ans')^k = \sum_{i=0}^k ans_ival_{k-i}C_k^i
$$

这就变成了一个类似于卷积的形式，众所周知卷积是乘法运算，于是我们把上面的向量拿来做一个卷积就可以处理乘法问题了。

最后的答案就是第 $k+1$ 项的系数。

加法减法我们可以对应位置暴力相减，除法我们可以倒推求出逆元，然后乘上逆元即可，注意特别判断第 $1$ 项（常数项）的大小是不是为 $0$。

每次操作时间复杂度为 $O(k^2)$，总的时间复杂度是 $O(n^3k^2)$。

## 代码

代码如下，其中多项式相关技巧均为暴力实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 998244353
#define N 35
#define M 200005
using namespace std;
struct node{ll x,y,z;};
struct vect{ll p[N];}a[N][N];
ll n,K,i,j,k,m,x,y,z,ans,res,vis[N],f[M],fath[N],C[N][N],maps[N][N];
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t=a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}
vect operator+(vect a,vect b){
	vect c;
	for(ll i=0;i<=K;i++) c.p[i]=(a.p[i]+b.p[i])%mod;
	return c;
}
vect operator-(vect a,vect b){
	vect c;
	for(ll i=0;i<=K;i++) c.p[i]=(a.p[i]-b.p[i]+mod)%mod;
	return c;
}
vect operator*(vect a,vect b){
	vect c;
	for(ll i=0;i<=K;i++){
		c.p[i] = 0;
		for(ll j=0;j<=i;j++) c.p[i]=(c.p[i]+a.p[j]*b.p[i-j]%mod*C[i][j])%mod;
	}
	return c;
}
vect inv(vect a){
	vect c;
	c.p[0] = qmi(a.p[0],mod-2,mod);
	for(ll i=1;i<=K;i++){
		c.p[i] = 0;
		for(ll j=0;j<i;j++) c.p[i] = (c.p[i]-c.p[j]*a.p[i-j]%mod*C[i][j]%mod+mod)%mod;
		c.p[i] = c.p[i]*c.p[0]%mod;
	}
	return c;
}
bool operator==(vect a,vect b){
	for(ll i=0;i<=K;i++) if(a.p[i]!=b.p[i]) return 0;
	return 1;
}
bool operator!(vect a){
	for(ll i=0;i<=K;i++) if(a.p[i]) return 0;
	return 1;
}
inline ll solve(){
	ll i,j,k,has=0;
	for(i=1;i<n;i++) for(j=1;j<n;j++) for(k=0;k<=K;k++) a[i][j].p[k]=(a[i][j].p[k]%mod+mod)%mod;
	for(i=1;i<n;i++){
		for(j=i+1;j<n;j++){
			if(!a[i][i]) swap(a[i],a[j]),has^=1;
			vect res = a[j][i]*inv(a[i][i]);
			assert(res*a[i][i]==a[j][i]);
			for(k=i;k<n;k++) a[j][k]=a[j][k]-a[i][k]*res;
		}
	}
	vect ans;
	for(i=1;i<=K;i++) ans.p[i]=0;
	ans.p[0]=1;
	for(i=1;i<n;i++) ans=ans*a[i][i];
	return ans.p[K];
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>K;
	C[0][0] = 1;
	for(i=0;i<=K;i++){
		for(j=0;j<=K;j++){
			if(i==0&&j==0) continue;
			if(i) C[i][j]+=C[i-1][j];
			if(i&&j) C[i][j]+=C[i-1][j-1];
			C[i][j] %= mod;
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			cin>>maps[i][j];
			if(i>=j) continue;
			for(k=0,res=1;k<=K;k++,res=res*maps[i][j]%mod) a[i][i].p[k]+=res,a[j][j].p[k]+=res,a[i][j].p[k]-=res,a[j][i].p[k]-=res;
		}
	}
	cout<<solve()<<endl;
	return 0;
} 
/*
Input:
4 5  
1 2 12  
1 3 9  
2 4 6  
3 4 8  
1 4 4  

Output:
15
*/
```

---

## 作者：s_r_f (赞：2)

安利$:$ [杂题选做](https://www.luogu.com.cn/blog/s-r-f/liu-yue-qi-yue-za-ti-xuan-zuo)

首先我们来观察一下规律$.$

当$k=0$时就是直接$Matrix-Tree.$

$k=1$时就是联合省选那个套路$,$是把边权$w$变成$1+wx.$

不难发现这些式子都是$e^{wx},$同时你会发现由于二项式定理$,$可以证明用$e^{wx}$当边权$,$最后取答案的$k$次项系数是正确的$.$

所以把边权 $w$ 变成 $e^{wx}$ 然后求一下在 $\pmod{x^{k+1}}$ 意义下的行列式即可 $.$

因为 $k$ 比较小 $,$ 所以求逆和多项式乘法只能写$O(k^2)$ $,$ 直接套$NTT$板子会变慢 $.$

复杂度 $O(n^3k^2).$

代码$:$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 32,K = 32,P = 998244353;
inline int power(int x,LL y){
	static int r; r = 1; while (y){ if (y&1) r = (LL)r * x % P; x = (LL)x * x % P; y >>= 1; } return r;
}
int n,k,d[N][N],fac[505],nfac[505],inv[505];
struct Function{
	int a[K];
	inline void init(int w){ for (int i = 0,r = 1; i <= k; ++i,r = (LL)r * w % P) a[i] = (LL)nfac[i] * r % P; }
}A[N][N];

Function operator + (Function F,Function G){
	static int i; static Function T;
	for (i = 0; i <= k; ++i) T.a[i] = (F.a[i]+G.a[i]>=P)?(F.a[i]+G.a[i]-P):(F.a[i]+G.a[i]);
	return T;
}
Function operator - (Function F,Function G){
	static int i; static Function T;
	for (i = 0; i <= k; ++i) T.a[i] = (F.a[i]<G.a[i])?(F.a[i]-G.a[i]+P):(F.a[i]-G.a[i]);
	return T;
}
Function operator * (Function F,Function G){
	static int i,j; static Function T;
	for (i = 0; i <= k; ++i)
	for (T.a[i] = j = 0; j <= i; ++j) T.a[i] = (T.a[i] + (LL)F.a[j] * G.a[i-j]) % P;
	return T;
}
Function Inv(Function A){
	static int i,j,ret; static Function T;
	T.a[0] = power(A.a[0],P-2);
	for (i = 1; i <= k; ++i){
		for (ret = 0,j = 0; j < i; ++j) ret = (ret + (LL)T.a[j]*A.a[i-j]) % P;
		T.a[i] = (LL)(P-ret) * T.a[0] % P;
	}
	return T;
}

Function det(){
	int i,j,k; Function tmp,ans;
	ans.init(0),ans.a[0] = 1;
	for (i = 2; i <= n; ++i){
		ans = ans * A[i][i]; tmp = Inv(A[i][i]); for (j = i; j <= n; ++j) A[i][j] = A[i][j] * tmp;
		for (j = i+1; j <= n; ++j){
			tmp = A[j][i];
			for (k = i; k <= n; ++k) A[j][k] = A[j][k] - tmp * A[i][k];
		}
	}
	return ans;
}

int main(){
	int i,j,x; Function tmp;
	fac[0] = nfac[0] = inv[0] = fac[1] = nfac[1] = inv[1] = 1;
	for (i = 2; i <= 500; ++i){
		fac[i] = (LL)fac[i-1] * i % P;
		inv[i] = (LL)(P-P/i) * inv[P%i] % P;
		nfac[i] = (LL)nfac[i-1] * inv[i] % P;
	}
	cin >> n >> k;
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j){
		cin >> x; if (i >= j) continue; tmp.init(x);
		A[i][j] = A[i][j] - tmp,A[j][i] = A[j][i] - tmp;
		A[i][i] = A[i][i] + tmp,A[j][j] = A[j][j] + tmp;
	}
	cout << (LL)fac[k] * det().a[k] % P << '\n';
	return 0;
}
```

---

## 作者：chroneZ (赞：1)

> 我做这个题时先入为主地想到了斯特林拆幂，其实二项式定理化成 EGF 的形式好像简单些，这里就提供一下前者的思路。

发现是生成树相关内容的计数，直接考虑 Matrix Tree 定理。容易发现难点在于如何表示边权，使得边权之积包含了 $(\sum \omega(e)) ^ k$ 这个信息。

根据经典思路，先试试斯特林拆幂：$n ^ k = \sum \limits_{i = 0} ^ k {\begin{Bmatrix} k \\ i \end{Bmatrix}} \dbinom{n}{i} i!$。则我们可以把问题进一步转化为，找到一种表示边权的方式，使得边权之积等于 $\dbinom{\sum \omega(e)}{k}$。

这等价于，我们需要通过关于 $\dbinom{p}{k}$ 与 $\dbinom{q}{k}$ 的信息，求积得到关于 $\dbinom{p + q}{k}$ 的信息。这个 $\dbinom{p + q}{k}$ 的形式容易让我们联想到范德蒙德卷积：$\dbinom{p + q}{k} = \sum \limits_{i = 0} ^ {k} \dbinom{p}{i} \dbinom{q}{k - i}$，至此思路已经一目了然：将边权定为 $W(e) = \sum \limits_{i = 0} ^ k \dbinom{\omega(e)}{i} x ^ i$，则 $[x ^ k]\prod \limits_{e \in T} W(e) = \dbinom{\sum \omega(e)}{k}$。

运用 Matrix Tree 定理建立行列式后，通过行变换对行列式求值即可。将结果带回至斯特林拆幂的形式中即可得到答案。由于数据范围很小，暴力 $\Theta(k ^ 2)$ 的卷积和求逆是比大常数的 $\Theta(k \log k)$ 快的，因此采用暴力。时间复杂度 $\Theta(k ^ 2 n ^ 3)$。

行变换时需要用到多项式乘法逆，注意常数项为 $0$ 的问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

constexpr int mod = 998244353, N = 30 + 5;
namespace basic {
  inline int add(int x, int y) {return (x + y >= mod ? x + y - mod : x + y);}
  inline int dec(int x, int y) {return (x - y < 0 ? x - y + mod : x - y);}
  inline void ad(int &x, int y) {x = add(x, y);}
  inline void de(int &x, int y) {x = dec(x, y);}

  inline int qpow(int a, int b) {
    int r = 1;
    while(b) {
      if(b & 1) r = 1ll * r * a % mod;
      a = 1ll * a * a % mod; b >>= 1;
    }
    return r;
  }
  inline int inv(int x) {return qpow(x, mod - 2);}

  int fac[N], ifac[N];
  inline void fac_init(int n = N - 1) {
    fac[0] = 1;
    for(int i = 1; i <= n; i++)
      fac[i] = 1ll * fac[i - 1] * i % mod;
    ifac[n] = inv(fac[n]);
    for(int i = n - 1; i >= 0; i--)
      ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
  }
  int invx[N];
  inline void inv_init(int n = N - 1) {
    invx[1] = 1;
    for(int i = 2; i <= n; i++)
      invx[i] = 1ll * (mod - mod / i) * invx[mod % i] % mod;
  }
  inline int binom(int n, int m) {
    if(n < m || m < 0) return 0;
    return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
  }
}
using namespace basic;

struct TinyPoly {
  vector<int> a;

  TinyPoly() {}
  inline void resize(int n) {
    a.resize(n, 0);
  }
  TinyPoly(int n) {resize(n);}
  TinyPoly(vector<int> b) {a = b;}

  inline int & operator [] (int x) {
    // assert(x < a.size());
    return a[x];
  }
  inline int size() {
    return a.size();
  }
  inline void Rev() {
    reverse(a.begin(), a.end());
  }
  inline int fir() {
    for(int i = 0; i < a.size(); i++) {
      if(a[i]) {
        return i;
      }
    }
    return -1;
  }
  inline void popfront(int k) {
    assert(k <= a.size());
    reverse(a.begin(), a.end());
    while(k--) {
      a.pop_back();
    }
    reverse(a.begin(), a.end());
  }
  inline friend TinyPoly operator + (TinyPoly x, TinyPoly y) {
    TinyPoly ret(max(x.size(), y.size()));
    for(int i = 0; i < x.size() || i < y.size(); i++) {
      if(i < x.size()) {
        ad(ret[i], x[i]);
      }
      if(i < y.size()) {
        ad(ret[i], y[i]);
      }
    }
    return ret;
  }
  inline friend TinyPoly operator - (TinyPoly x, TinyPoly y) {
    TinyPoly ret(max(x.size(), y.size()));
    for(int i = 0; i < x.size() || i < y.size(); i++) {
      if(i < x.size()) {
        ad(ret[i], x[i]);
      }
      if(i < y.size()) {
        de(ret[i], y[i]);
      }
    }
    return ret;
  }
  inline friend TinyPoly operator * (TinyPoly x, TinyPoly y) {
    if(x.size() == 0 || y.size() == 0) {
      return {};
    }
    TinyPoly ret(x.size() + y.size() - 1);
    for(int i = 0; i < x.size(); i++) {
      for(int j = 0; j < y.size(); j++) {
        ad(ret[i + j], 1ll * x[i] * y[j] % mod);
      }
    }
    return ret;
  }
  inline TinyPoly Inv(int n) {
    assert(a[0]);
    TinyPoly ret(n);
    ret[0] = inv(a[0]);
    for(int i = 1; i < n; i++) {
      int C = 0;
      for(int j = 0; j < i; j++) {
        de(C, 1ll * a[i - j] * ret[j] % mod);
      }
      ret[i] = 1ll * C * ret[0] % mod;
    }
    return ret;
  }

  inline TinyPoly operator += (TinyPoly y) {
    return (*this) = (*this) + y;
  }
  inline TinyPoly operator -= (TinyPoly y) {
    return (*this) = (*this) - y;
  }
  inline TinyPoly operator *= (TinyPoly y) {
    return (*this) = (*this) * y;
  }
};

int k;
struct Determinant {
  int n; TinyPoly a[N][N];

  Determinant() {};
  Determinant(int _) {n = _;}

  inline TinyPoly* operator [] (int x) {
    return a[x];
  }

  inline TinyPoly det() {
    TinyPoly ret(k + 1); ret[0] = 1;
    for(int i = 1; i <= k; i++) {
      ret[i] = 0;
    }
    for(int i = 1; i <= n; i++) {
      int it = -1, fir = k + 1;
      for(int j = i; j <= n; j++) {
        int p = a[j][i].fir();
        if(p != -1 && p < fir) {
          fir = p, it = j;
        }
      }
      if(it == -1) {
        return ret[0] = 0, ret;
      }
      if(it != i) {
        swap(a[i], a[it]);
        ret[0] = mod - ret[0];
      }
      TinyPoly Inv = a[i][i]; Inv.popfront(fir), Inv.resize(k + 1);
      Inv = Inv.Inv(k + 1);
      for(int j = i + 1; j <= n; j++) {
        TinyPoly p = a[j][i]; p.popfront(fir);
        TinyPoly D = p * Inv; D.resize(k + 1);
        for(int t = i; t <= n; t++) {
          a[j][t] -= D * a[i][t];
          a[j][t].resize(k + 1);
        }
      }
    }
    for(int i = 1; i <= n; i++) {
      ret *= a[i][i];
      ret.resize(k + 1);
    }
    return ret;
  }
};

int n; TinyPoly D[N][N], A[N][N];
inline TinyPoly generate(int w) {
  TinyPoly ret(k + 1); ret[0] = 1;
  for(int i = 0; i < k; i++) {
    ret[i + 1] = 1ll * ret[i] * dec(w, i) % mod * inv(i + 1) % mod;
  }
  return ret;
}

int S2[N][N];

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr), cout.tie(nullptr);
  
  fac_init();
  
  cin >> n >> k;
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
      int w; cin >> w;
      if(i < j) {
        TinyPoly W = generate(w);
        D[i][i] += W, D[j][j] += W;
        A[i][j] += W, A[j][i] += W;
      }
    }
  }
  Determinant L(n - 1);
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
      L[i][j] = D[i][j] - A[i][j];
    }
  }
  TinyPoly res = L.det();
  // for(int i = 0; i <= k; i++) {
  //   cout << res[i] << " \n"[i == k];
  // }

  S2[0][0] = 1;
  for(int i = 1; i <= k; i++) {
    for(int j = 1; j <= i; j++) {
      S2[i][j] = add(S2[i - 1][j - 1], 1ll * S2[i - 1][j] * j % mod);
    }
  }

  int ans = 0;
  for(int i = 0; i <= k; i++) {
    ad(ans, 1ll * S2[k][i] * res[i] % mod * fac[i] % mod);
  }
  cout << ans << "\n";
}
```

---

## 作者：Graphcity (赞：1)

这里给出一种使用组合意义的，较为不同的做法。

首先发现 $k$ 较小，考虑拆贡献：

$$
x^k=\sum_{i=0}^k\binom{x}{i}\begin{Bmatrix}k\\i\end{Bmatrix}i!
$$

那么现在和生成树贡献有关的只有 $\dbinom{x}{i}$ 了。由于 $\dbinom{x}{i}=\dbinom{\sum w}{i}$，它的组合意义就是从 $\sum w$ 个球里面选 $i$ 个的方案数。

注意到 $\dbinom{a+b}{n}=\sum_{i=0}^n\dbinom{a}{i}\dbinom{b}{n-i}$，这是一个卷积的形式，对每条边维护一个多项式 $F_t(x)=\sum_{i=0}^k\dbinom{w_t}{i}x^i$，那么就有 $[x^i]F_a(x)F_b(x)=\dbinom{w_a+w_b}{i}x^i$。

套用矩阵树定理求解即可，时间复杂度 $O(n^3k^2)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=30,Mod=998244353;

inline int Pow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,y>>=1;
    }
    return res;
}
inline int C(int x,int y)
{
    if(x<y) return 0;
    int a=1; For(i,0,y-1) a=1ll*a*(x-i)%Mod*Pow(i+1,Mod-2)%Mod;
    return a;
}

struct Poly
{
    int p[31];
    inline Poly() {memset(p,0,sizeof(p));}
    inline int&operator()(int x) {return p[x];}
    inline Poly(int a) {For(i,0,30) p[i]=C(a,i);}
    inline Poly Inv()
    {
        Poly a; int inv=Pow(p[0],Mod-2); a(0)=inv;
        For(i,1,30)
        {
            int res=0;
            For(j,0,i-1) res=(res+1ll*a(j)*p[i-j]%Mod)%Mod;
            a(i)=1ll*inv*(Mod-res)%Mod;
        }
        return a;
    }
} Zero,One;
inline Poly operator+(Poly a,Poly b) {For(i,0,30) a(i)=(a(i)+b(i))%Mod; return a;}
inline Poly operator-(Poly a,Poly b) {For(i,0,30) a(i)=(a(i)-b(i)+Mod)%Mod; return a;}
inline Poly operator*(Poly a,Poly b) {Poly c; For(i,0,30) For(j,0,i) c(i)=(c(i)+1ll*a(j)*b(i-j)%Mod)%Mod; return c;}
inline Poly operator/(Poly a,Poly b) {return a*b.Inv();}
inline bool operator==(Poly a,Poly b) {For(i,0,30) if(a(i)!=b(i)) return false; return true;}
inline bool operator!=(Poly a,Poly b) {For(i,0,30) if(a(i)!=b(i)) return true; return false;}

int n,m,all,str[Maxn+5][Maxn+5];
Poly f[Maxn+5][Maxn+5]; int g[Maxn+5][Maxn+5];

inline int Fac(int x) {int res=1; For(i,1,x) res=1ll*res*i%Mod; return res;}
inline Poly Gauss()
{
    Poly res=One;
    For(i,1,n-1)
    {
        int p=i; Poly now;
        For(j,i+1,n-1) if(f[j][i]!=Zero) {p=j; break;}
        if(p>i) swap(f[i],f[p]),res=res*(Zero-One);
        res=res*f[i][i],now=f[i][i].Inv();
        For(j,i,n-1) f[i][j]=f[i][j]*now;
        For(j,i+1,n-1)
        {
            now=Zero-f[j][i];
            For(k,i,n-1) f[j][k]=f[j][k]+now*f[i][k];
        }
    }
    return res;
}

int main()
{
    cin>>n>>m; str[0][0]=1,One(0)=1;
    For(i,1,m) For(j,1,i)
        str[i][j]=(str[i-1][j-1]+1ll*j*str[i-1][j]%Mod)%Mod;
    For(i,1,n) For(j,1,n) cin>>g[i][j];
    For(i,1,n) For(j,1,n) if(i!=j)
        f[i][j]=Zero-Poly(g[i][j]),f[i][i]=f[i][i]+Poly(g[i][j]);
    Poly ans=Gauss();
    For(i,0,30) all=(all+1ll*str[m][i]*Fac(i)%Mod*ans(i)%Mod)%Mod;
    printf("%d\n",all);
    return 0;
}
```

---

## 作者：1saunoya (赞：1)

2333为什么模拟赛放这种题啊。

之前做到过联合省选的题，那题只需要把边权变成 $1+wx$ 然后矩阵树就行。


尝试给这个一个边权。

如果当前的答案是 $u$，要加入的边权是 $v$,我们要使得 $uv$ 得到我们想要的答案。

而显然我们看到 $k$ 次方可以联想到 $(u+v)^k = \sum \binom{k}{i} u^i v^{k-i}$。

$(u+v)^k = \sum \frac{k!}{i!(k-i)!} u^i v^{k-i}$。

进一步的，我们将 $k!$ 放到左边。

$\frac{(u+v)^k}{k!} = \sum \frac{u^i v^{k-i}}{i!(k-i)!}$


恰好是 EGF 的形式。

所以我们令 $w' = e^{w}$，直接矩阵树就好了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int P = 998244353;
int n, k;
vector<long long> fact, ifact;
long long power(long long x, long long y) {
 long long res = 1;
 while (y) {
  if (y & 1) {
   res = res * x % P;
  }
  x = x * x % P;
  y /= 2;
 }
 return res;
}
vector<long long> exp(int w) {
 vector<long long> e(k + 1);
 long long p = 1;
 for (int i = 0; i <= k; i++) {
  e[i] = p * ifact[i] % P;
  p *= w;
  p %= P;
 }
 return e;
}
vector<long long> operator -(const vector<long long> &a, const vector<long long> &b) {
 vector<long long> c(k + 1);
 for (int i = 0; i <= k; i++) {
  c[i] = a[i] - b[i];
  if (c[i] < 0) {
   c[i] += P;
  }
 }
 return c;
}
vector<long long> operator +(const vector<long long> &a, const vector<long long> &b) {
 vector<long long> c(k + 1);
 for (int i = 0; i <= k; i++) {
  c[i] = a[i] + b[i];
  if (c[i] >= P) {
   c[i] -= P;
  }
 }
 return c;
}
vector<long long> operator *(const vector<long long> &a, const vector<long long> &b) {
 vector<long long> c(k + 1);
 for (int i = 0; i <= k; i++) {
  for (int j = 0; j <= k - i; j++) {
   if (i + j <= k) {
    c[i + j] += a[i] * b[j] % P;
    if (c[i + j] >= P) {
     c[i + j] -= P;
    }
   }
  }
 }
 return c;
}
vector<long long> inv(const vector<long long> &a) {
 vector<long long> b(k + 1);
 b[0] = power(a[0], P - 2);
 for (int i = 1; i <= k; i++) {
  for (int j = 0; j < i; j++) {
   b[i] -= b[j] * a[i - j] % P;
   if (b[i] < 0) {
    b[i] += P;
   }
  }
  b[i] = b[i] * b[0] % P;
 }
 return b;
}
vector<long long> solve(vector<vector<vector<long long>>> e) {
 int n = (int) e.size();
 bool rev = false;
 for (int i = 0; i < n; i++) {
  int p = n;
  for (int j = i; j < n; j++) {
   if (e[j][i][0]) {
    p = j;
    break;
   }
  }
  if (p == n) {
   return {-1};
  }
  if (p != i) {
   swap(e[i], e[p]);
   rev = !rev;
  }
  auto iv = inv(e[i][i]);
  for (int j = i + 1; j < n; j++) {
   auto coef = e[j][i] * iv;
   for (int k = i; k <= n; k++) {
    e[j][k] = e[j][k] - coef * e[i][k];
   }
  }
 }
 vector<long long> res(k + 1);
 res[0] = 1;
 for (int i = 0; i < n; i++) {
  res = res * e[i][i];
 }
 if (rev) {
  for (int i = 0; i < n; i++) {
   res[i] = P - res[i];
  }
 }
 return res;
}
int main() {
 ios::sync_with_stdio(false);
 cin.tie(NULL);
 cin >> n >> k;
 fact.resize(k + 1);
 ifact.resize(k + 1);
 fact[0] = ifact[0] = 1;
 for (int i = 1; i <= k; i++) {
  fact[i] = fact[i - 1] * i % P;
  ifact[i] = power(fact[i], P - 2);
 }
 vector<vector<vector<long long>>> e(n, vector<vector<long long>>(n, vector<long long>(k + 1, 0LL)));
 for (int i = 0; i < n; i++) {
  for (int j = 0; j < n; j++) {
   int w;
   cin >> w;
   if (i < j) {
    auto ew = exp(w);
    e[i][i] = e[i][i] + ew;
    e[j][j] = e[j][j] + ew;
    e[i][j] = e[i][j] - ew;
    e[j][i] = e[j][i] - ew;
   }
  }
 }
 e.resize(n - 1);
 auto res = solve(e);
 cout << res[k] * fact[k] % P << "\n";
 return 0;
}
```

---

## 作者：littlez_meow (赞：0)

给出一种自然的想法。

[题目指路](https://www.luogu.com.cn/problem/P5296)。

## 思路

求生成树权值和，想矩阵树定理。但是矩阵树只能处理积的情况。

考虑化和为积。有什么运算可以做到？同底数下指数的运算。

再考虑什么情况下答案里会自带一个 $k$ 次方。泰勒展开可以。

我们发现，这个要求的式子简直完美适配 $e^x$ 的泰勒展开。

具体而言，我们重新定义一条边权为 $w$ 的边的边权为 $e^{wx}$。这样，一棵生成树所有边权的积为 $e^{x\sum w}$。取其中 $x^k$ 项，为 $\dfrac{(\sum w)^k}{k!}$。

这简直太合适了。剩下就是矩阵树定理的事。

直接维护多项式的行列式，暴力乘，时间复杂度 $O(n^3k^2)$。

手推一下多项式求逆的 $O(k^2)$ 办法。

设 $f(x)g(x)=1$，下记 $f_i=[x^i]f(x),g_i=[x^i]g(x)$。给定 $f$，求 $g$。

我们有 $\sum\limits_{i=0}^nf_ig_{n-i}=[n=0]$。

移项得到 $-\sum\limits_{i=1}^nf_ig_{n-i}=f_0g_n$。

因此有 $g_n=\left\{\begin{matrix}
 \dfrac 1 {f_0} & (n=0)\\
 -\dfrac 1 {f_0}\sum_{i=1}^n f_ig_{n-i}& (n>0)
\end{matrix}\right.$。

递推即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i) 
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
const int MOD=998244353,MAXN=31;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
int n,k;
struct Poly{
	int num[MAXN];
	Poly(){
		memset(num,0,sizeof(int)*(k+1));
		return;
	}
	Poly operator+(const Poly&x)const{
		Poly res;
		F(i,0,k){
			int&qwq(res.num[i]);
			qwq=num[i]+x.num[i];
			qwq>=MOD&&(qwq-=MOD);
		}
		return res;
	}
	Poly operator-(const Poly&x)const{
		Poly res;
		F(i,0,k){
			int&qwq(res.num[i]);
			qwq=num[i]-x.num[i];
			qwq<0&&(qwq+=MOD);
		}
		return res;
	}
	Poly operator*(const Poly&x)const{
		Poly res;
		F(i,0,k){
			unsigned ll qwq=0;
			F(j,0,min(i,15)) qwq+=num[j]*1ll*x.num[i-j];
			qwq%=MOD;
			if(i>15){
				F(j,16,i) qwq+=num[j]*1ll*x.num[i-j];
				qwq%=MOD;
			}
			res.num[i]=qwq;
		}
		return res;
	}
	bool operator!=(const int&x)const{
		R(i,k,1) if(num[i]) return 1;
		return num[0]!=x;
	}
	inline Poly inv(){
		Poly res;
		res.num[0]=qpow(num[0],MOD-2);
		F(i,1,k){
			unsigned ll qwq=0;
			F(j,1,min(i,15)) qwq+=num[j]*1ll*res.num[i-j];
			qwq%=MOD;
			if(i>15){
				F(j,16,i) qwq+=num[j]*1ll*res.num[i-j];
				qwq%=MOD;
			}
			qwq=MOD-qwq*res.num[0]%MOD;
			qwq>=MOD&&(qwq-=MOD);
			res.num[i]=qwq;
		}
		return res;
	}
};
int fact[MAXN],inv[MAXN];
inline Poly epow(int t){
	ll now(1);
	Poly res;
	F(i,0,k) res.num[i]=inv[i]*now%MOD,now=now*t%MOD;
	return res;
}
Poly mat[MAXN][MAXN];
inline ll det(){
	Poly res;
	bool factor=0;
	F(i,2,n){
		int row=-1;
		F(j,i,n) if(mat[j][i]!=0){
			row=j;
			break;
		}
		if(row==-1) return 0;
		row!=i&&(swap(mat[i],mat[row]),factor^=1);
		Poly qaq=mat[i][i].inv();
		F(j,i+1,n){
			Poly qwq=qaq*mat[j][i];
			F(k,i,n) mat[j][k]=mat[j][k]-qwq*mat[i][k];
		}
	}
	res.num[0]=1;
	F(i,2,n) res=res*mat[i][i];
	return factor?MOD-res.num[k]:res.num[k];
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	fact[0]=inv[0]=1;
	F(i,1,k) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[k]=qpow(fact[k],MOD-2);
	R(i,k,2) inv[i-1]=inv[i]*1ll*i%MOD;
	F(i,1,n) F(j,1,n){
		int w;
		cin>>w;
		Poly val=epow(w);
		mat[j][j]=mat[j][j]+val;
		mat[i][j]=mat[i][j]-val;
	}
	cout<<det()*fact[k]%MOD;
	return 0;
} 
```

---


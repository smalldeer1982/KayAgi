# 【模板】Min_25 筛

## 题目背景

模板题，无背景。

## 题目描述

定义积性函数 $f(x)$，且 $f(p ^ k) = p ^ k(p ^ k - 1)$（$p$ 是一个质数），求

$$\sum_{i = 1} ^ n f(i)$$

对 $10 ^ 9 + 7$ 取模。

## 说明/提示

$f(1)=1$，$f(2)=2$，$f(3)=6$，$f(4)=12$，$f(5)=20$；  
$f(6)=12$，$f(7)=42$，$f(8)=56$，$f(9)=72$，$f(10)=40$。

对于 $30\%$ 的数据，保证 $1\le n\le 10^6$。

对于 $100\%$ 的数据，保证 $1\le n\le 10^{10}$。

## 样例 #1

### 输入

```
10
```

### 输出

```
263
```

## 样例 #2

### 输入

```
1000000000
```

### 输出

```
710164413
```

# 题解

## 作者：wucstdio (赞：193)

洛谷题库里面终于有我的题了（虽然是一道板子），必须发一份题解庆祝一下。

## 题意

求$\sum_{i=1}^nf(i)$，其中$f(i)$是一个积性函数，且$f(p^k)=p^k(p^k-1)$。

## Min_25筛

为什么这个筛法叫做Min25筛呢？因为这个算法是Min25发明的。

假设我们要求一个$\sum_{i=1}^nf(i)$，满足$f(x)$是一个积性函数，且$f(p^e)$是一个关于$p$的低阶多项式。

因为多项式可以拆成若干个单项式，所以我们只需要考虑求出$f(p)=p^k$的前缀和，然后每一项加起来就行了。

那么如何求出每一项的和呢？

### Step1 分类

让我们先对$i$按照质数和合数分类：

$$\sum_{i=1}^nf(i)=\sum_{1\le p\le n}f(p)+\sum_{i=1\&\text{i is not a prime}}^nf(i)$$

然后，我们枚举后面合数的最小质因子以及最小质因子的次数。注意所有合数的最小质因子一定都小于等于$\sqrt n$：

$$\sum_{1\le p\le n}f(p)+\sum_{1\le p^e\le n,1\le p\le \sqrt n}f(p^e)\left(\sum_{1\le i\le n/p^e\&minp>p}f(i)\right)$$

其中$minp$表示$i$的最小质因子，因为公式中文太丑了所以就只好写英文了。

这样，整个式子就变成了两个部分，第一部分是所有质数的$f$之和，另一部分是枚举最小质因子后，求所有最小质因子大于这个质因子的$f$之和。

### Step2 第一部分

由于$n$实在太大，所以我们没法用线性筛求出所有质数的$f$和。

我们考虑一个DP的思路（天哪这是怎么想到的）：我们不知道从哪里找来了一个DP数组$g(n,i)$，满足

$$g(n,j)=\sum_{i=1}^n[\text{i is a prime or minp$> p_j$}]i^k$$

这里的$k$就是前面我们说的低阶多项式的一项。注意$i^k$并不是我们要求的$f$，只是一个和$f$在质数处的取值一样的完全积性函数，这样后面计算起来比较方便。

这个式子说人话就是$g(n,j)$表示求$1$到$n$之间所有满足条件的数的$k$次方和，条件就是要么是质数要么最小质因子大于$p_j$。

我们考虑$g(n,j-1)$如何转移到$g(n,j)$。随着$j$的增大，满足条件的数变少了，所以我们需要减去一些原来满足条件而现在不满足条件的数。

这些数应该是最小质因子恰好为$p_{j}$的合数。

我们可以提出来一个$p_{j}$作为最小质因子，这样剩下的就不能有小于它的质因子了，也就是$g\left(\dfrac{n}{p_{j}},j\right)-g(p_{j-1},j-1)$，后面那个$g$是为了把所有的质数去掉。

这样我们就得到了$g$的递推式：

$$g(n,j)=g(n,j-1)-p_j^k\left(g\left(\dfrac{n}{p_j},j-1\right)-g(p_{j-1},j-1)\right)$$

完全积性函数的好处在这里就体现出来了：由于只提出了一个$p_i$，所以后面还有可能有$p_i$这个因子，如果是完全积性函数的话就可以将函数值直接相乘，而不用管是否互质。

注意到后面的$g(p_{j-1},j-1)$其实就是前$j-1$个质数的$k$次方和。由于$p_j\le \sqrt n$，所以这一部分可以用线性筛预处理，我们设$sp_n=\sum_{i=1}^np_i^k$，也就是前$n$个质数的$k$次方和。

$1$到$n$中所有质数的$k$次方和其实就是$g(n,x)$，其中$p_x$是最后一个小于等于$\sqrt n$的质数。为了方便，我们把它记作$g(n)$。

但是因为$n$太大，我们还是没法对于每一个$n$求出$g(n,x)$，所以我们可以想到另一个重要的结论：

$$\left\lfloor\dfrac{\lfloor\dfrac na\rfloor}{b}\right\rfloor=\lfloor\dfrac{n}{ab}\rfloor$$

也就是说，无论你每一次把$n$除以几，最后你能得到的数一定是某一个$\lfloor\dfrac nx\rfloor$，所以我们没必要算出来所有的$n$，只需要算出可以写成$\lfloor\dfrac{n}{x}\rfloor$这种形式的数，这样的数一共有$O(\sqrt n)$个。

那么我们如何存储这$\sqrt n$个数呢？

首先我们不能直接下标访问，这样下标可以到$n$。我们需要对下标离散化。

但是离散化之后，我们还需要知道对于每一个$\lfloor\dfrac nx\rfloor$，它对应的下标是什么。

如果偷懒的话可以用map，但是时间复杂度会多一个$\log$。我们可以用$ind1[x]$表示$x$这个数对应的数组下标，$ind2[x]$表示$n/x$这个数对应的下标。这样两个$ind$数组最大都只会到$\sqrt n$。

具体实现可以看代码。数组的记录上需要精细实现一下。

### Step2 求解答案

答案就是先求出所有质数的函数和，然后先枚举了一个$p^e$，再枚举最小质因子大于$p$的数。

我们还是可以考虑DP的思想。设$S(n,x)$表示求$1$到$n$中所有最小质因子大于$p_x$的函数值之和，注意这里是$f$而不是$k$次方。答案就是$S(n,0)$。

我们将满足条件的数分成两部分，第一部分是大于$p_x$的质数，也就是$g(n)-sp_x$，另一部分是最小质因子大于$p_x$的合数，枚举最小质因子：

$$S(n,x)=g(n)-sp_x+\sum_{p_k^e\le n\&k>x}f(p_k^e)\left(S\left(\dfrac{n}{p_k^e},k\right)+[e\neq 1]\right)$$

这样问题就解决了，我们可以递归求解这个问题。根据某玄学定理，不需要记忆化。

### 一些细节

$1$既不是质数也不是合数，不含任何一个质因子，那么求解的过程中$g$和$S$到底是否包含$1$呢？其实是否包含都可以，但是处理上略有差别。我的$g$和$S$都没有包含$1$，只需要最后加一就行了。

min25筛的时间复杂度据说是$O\left(\dfrac{n^{3/4}}{\log n}\right)$，也有人说是$O(n^{1-\epsilon})$，在这道题上大致是1e10跑1s左右的样子。但是这个算法常数很小，具体表现参加WC2019课件里面的一张图：

![](https://cdn.luogu.com.cn/upload/pic/56355.png)

## 代码实现

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const ll MOD=1000000007,inv2=500000004,inv3=333333336;
ll prime[1000005],num,sp1[1000005],sp2[1000005];
ll n,Sqr,tot,g1[1000005],g2[1000005],w[1000005],ind1[1000005],ind2[1000005];
bool flag[1000005];
void pre(int n)//预处理，线性筛
{
    flag[1]=1;
    for(int i=1;i<=n;i++)
    {
        if(!flag[i])
        {
            prime[++num]=i;
            sp1[num]=(sp1[num-1]+i)%MOD;
            sp2[num]=(sp2[num-1]+1ll*i*i)%MOD;
        }
        for(int j=1;j<=num&&prime[j]*i<=n;j++)
        {
            flag[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
}
ll S(ll x,int y)//第二部分
{
    if(prime[y]>=x)return 0;
    ll k=x<=Sqr?ind1[x]:ind2[n/x];
    ll ans=(g2[k]-g1[k]+MOD-(sp2[y]-sp1[y])+MOD)%MOD;
    for(int i=y+1;i<=num&&prime[i]*prime[i]<=x;i++)
    {
        ll pe=prime[i];
        for(int e=1;pe<=x;e++,pe=pe*prime[i])
        {
            ll xx=pe%MOD;
            ans=(ans+xx*(xx-1)%MOD*(S(x/pe,i)+(e!=1)))%MOD;
        }
    }
    return ans%MOD;
}
int main()
{
    scanf("%lld",&n);
    Sqr=sqrt(n);
    pre(Sqr);
    for(ll i=1;i<=n;)
    {
        ll j=n/(n/i);
        w[++tot]=n/i;
        g1[tot]=w[tot]%MOD;
        g2[tot]=g1[tot]*(g1[tot]+1)/2%MOD*(2*g1[tot]+1)%MOD*inv3%MOD;
        g2[tot]--;
        g1[tot]=g1[tot]*(g1[tot]+1)/2%MOD-1;
        if(n/i<=Sqr)ind1[n/i]=tot;
        else ind2[n/(n/i)]=tot;
        i=j+1;
    }//g1,g2分别表示一次项和二次项，ind1和ind2用来记录这个数在数组中的位置
    for(int i=1;i<=num;i++)//由于g数组可以滚动，所以就只开了一维
    {
        for(int j=1;j<=tot&&prime[i]*prime[i]<=w[j];j++)
        {
            ll k=w[j]/prime[i]<=Sqr?ind1[w[j]/prime[i]]:ind2[n/(w[j]/prime[i])];
            g1[j]-=prime[i]*(g1[k]-sp1[i-1]+MOD)%MOD;
            g2[j]-=prime[i]*prime[i]%MOD*(g2[k]-sp2[i-1]+MOD)%MOD;
            g1[j]%=MOD,g2[j]%=MOD;
            if(g1[j]<0)g1[j]+=MOD;
            if(g2[j]<0)g2[j]+=MOD;
        }
    }
    printf("%lld\n",(S(n,0)+1)%MOD);
    return 0;
}
```

---

## 作者：zhoukangyang (赞：82)

[欢迎来蒟蒻的博客园里看](https://www.cnblogs.com/zkyJuruo/p/13445596.html)

[模板](https://www.luogu.com.cn/problem/P5325)

## 前言
好不容易 ~~对着题解抄会了~~ 学会了 $\rm Min\_25$ 筛。。。学了一天，希望这篇题解能帮到你。

在本文中用 $p$ 表示质数，$P_i$ 表示第 $i$ 个质数。

## 题解

### 预处理
设**完全**积性函数 $f'$ 在质数处取值与 $f$ 相同

设一个函数 $g$，满足 $g(n,j)=\sum\limits_{i=1}^n f'(i)(i \in prime | \min\limits_{p|i} p > P_j)$。

考虑 $g(n, j) - g(n, j-1)$。

当 $P_j^2 > n$ 时, $g(n, j)$ 显然没有多余贡献，$g(n, j) = g(n, j-1)$。

否则在 $g(n, j)$ 中有多余贡献的数， 一定有质因子 $P_j$。可以先把这些数都除以 $P_j$ 。这些数的所有质因子都大于等于 $P_j$，因此是 $g(\frac{n}{P_j})$。这样会多算小于 $P_j$ 的质数, 因此还要减去 $\sum\limits_{i=1}^{j-1}f'(P_i)$。

因此得出状态转移方程:

$$g(n, j)=\begin{cases}g(n, j-1) (P_j^2 > n)\\g(n, j-1) - f'(P_j)(g(\frac{n}{P_j}, j-1) - \sum\limits_{i=1}^{j-1}f'(P_i))(P_j^2 \le n)\end{cases}$$

### 求值
设函数 $S$，$S(n, j) = \sum\limits_{i=1}^n f(i) (\min\limits_{p|i} p > P_j)$。

分成质数和合数来讨论。

考虑到 $f'$ 和 $f$ 在质数处取值相同，所以在质数时答案为 $g(n, |P|)$ 。这样多算了前 $j$ 个质数，减去 $\sum\limits_{i = 1}^{j} f'(P_i)$。

在合数处答案考虑枚举每一个数的最小质因数及他的次数，答案为 $\sum\limits_{k>j} \sum\limits_{e=1}^{P_k^e \le n} f(P_k^e)[S(\frac{n}{P_k^e}, k) + (e>1)]$。

后面的 $e>1$ 表示如果 $k$ 次数不为 $1$ 那么就还要再增加一个 $f(P_k^e)$，因为 $S$ 是不算上为 $1$ 的数。而质数的 $1$ 次方已经在前面枚举质数的地方算过了。

因此 
$$S(n, j) = g(n, |P|) - \sum\limits_{i = 1}^{j} f'(P_i) + \sum\limits_{k>j} \sum\limits_{e=1}^{P_k^e \le n} f(P_k^e)[S(\frac{n}{P_k^e}, k) + (e>1)]$$
最终求的答案是 $S(n, 0) + f(1)$，还要加上 $f(1)$ 因为 $S$ 函数不会计算到$1$。

### 细节
在求 $g$ 的时候需要优化。$g$ 需要的地方都是 $g(\frac{n}{k}, ...)$ 的形式，众所周知 $\frac{n}{k}$ 的取值只有$2\sqrt{n}$种情况，让 $id1_k$ 记录 $k\le\sqrt n$，$id2_k$ 记录 $\frac{n}{k} \le \sqrt n$，所以可以只枚举这 $2\sqrt n$ 种情况。

在处理质数处的完全积性函数时，$p^k(p^k-1)$ 可以用 $p^{2k}$ 减 $p^k$ 表示。

## 代码
```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int, int>
#define mkp make_pair
#define ll long long
using namespace std;
const int N = 2e5 + 7;
const int mod = 1e9 + 7;
bool Prime[N];
int tot;
ll p[N], n, sq, w[N], m, sum1[N], sum2[N], g1[N], g2[N], id1[N], id2[N];
// id1 id2 如文中所示 w[k] 为第 k 个需要处理的数 
// 文中的 g 为 g2 - g1, g1 : f'(k) = k, g2: f'(k) = k ^ 2
// sum1 : 质数前缀和 ; sum2: 质数平方前缀和
void xxs() { // 线性筛
	L(i, 2, sq)  {
		if(!Prime[i]) ++tot, p[tot] = i;
		for(int j = 1; p[j] * i <= sq && j <= tot; j++) {
			Prime[p[j] * i] = 1;
			if(i % p[j] == 0) break;
		}
	}
	L(i, 1, tot) {
		sum1[i] = (sum1[i - 1] + p[i]) % mod;
		sum2[i] = (sum2[i - 1] + p[i] * p[i] % mod) % mod;
	}
}
ll getid(ll x) {
	if(x <= sq) return id1[x];
	else return id2[n / x];
}
ll f1(ll x) { // 1 ~ x 前缀和
	x %= mod;
	return x * (x + 1) / 2 % mod;
}
ll f2(ll x) { // 1 ~ x 前缀平方和
	x %= mod;
	return x * (x + 1) % mod * (2 * x % mod + 1) % mod * 166666668 % mod;
}
ll S(ll x, int j) {
	if(p[j] > x) return 0;
	ll Ans = ((g2[getid(x)] - g1[getid(x)] + mod) % mod - (sum2[j] - sum1[j] + mod) % mod + mod) % mod;
	for(int i = j + 1; i <= tot && p[i] * p[i] <= x; i ++) 
		for(ll e = 1, sp = p[i]; sp <= x; sp *= p[i], e ++) 
			Ans = (Ans + sp % mod * (sp % mod - 1) % mod * (S(x / sp, i) + (e > 1)) % mod) % mod;
	return Ans;
}
int main() {
	scanf("%lld", &n), sq = sqrt(n), xxs();
	for(ll l = 1, r; l <= n; l = r + 1) {
		r = (n / (n / l)), w[++m] = n / l;
		g1[m] = f1(w[m]) - 1, g2[m] = f2(w[m]) - 1; // 处理 g(?, 0)
		if(w[m] <= sq) id1[w[m]] = m;
		else id2[n / w[m]] = m;
	}
	L(i, 1, tot) { // dp 处理 g 函数
		for(int j = 1; j <= m && p[i] * p[i] <= w[j]; j++) {
			g1[j] = (g1[j] - p[i] * (g1[getid(w[j] / p[i])] - sum1[i - 1]) % mod + mod) % mod;
			g2[j] = (g2[j] - p[i] * p[i] % mod * (g2[getid(w[j] / p[i])] - sum2[i - 1]) % mod + mod) % mod;
		}
	}
	printf("%lld\n", (S(n, 0) + 1) % mod);
	return 0;
}
```

---

## 作者：攀岩高手 (赞：77)

作为 min-25 筛的模板题，本题可以使用 min-25 筛 / 洲阁筛 等亚线性积性函数求和的方法在 $O\left(\frac{n^{\frac{3}{4}}}{\log n}\right)$ 的时间复杂度内解决。下面提供一种解决这道题的新的思路，这种算法参考自 [zzq's blog](https://www.cnblogs.com/zzqsblog/p/9904271.html)。

### 定义：Powerful Number ###

若正整数 $x$ 满足它所有质因子的幂次都 $\geq 2$，则称 $x$ 是一个 $\mathbf{Powerful\;Number}$。

### 性质 ###

$[1,n]$ 间的 $\mathbf{Powerful\;Number}$ 有 $O(\sqrt n)$ 个。

> 证明：
> 显然所有 $\mathbf{Powerful\;Number}$ 都可以表示成 $a^2b^3$ 的形式。考虑枚举 $a$ ，则 $n$ 以内这种数的数量为
>$$\begin{aligned}&O\left(\sum_{a=1}^{\sqrt n}\left(\frac n{a^2}\right)^{\frac 1 3}\right)\\&=O\left(\int_1^{\sqrt n}\left(\frac n{x^2}\right)^{\frac 1 3}dx\right)\\&=O(\sqrt n)\\\end{aligned}$$

这个性质保证了该算法的复杂度。

### 本题思路 ###

设 $F(x)$ 为要求的积性函数。对于质数 $p$，有 $F(p)=p(p-1)$。设数论函数 $G(x)=x\varphi(x)$，显然 $G(x)$ 是积性函数，且满足 $G(p)=F(p)$。设数论函数 $H(x)$ 满足 $F=G*H$，其中 $*$ 表示狄利克雷卷积。则有

$$
F(p)=G(1)H(p)+G(p)H(1)
$$

因为 $F,G$ 均为积性函数，所以 $H$ 也为积性函数。所以 $G(1)=H(1)=1$，又因为 $G(p)=F(p)$，可以得出 $H(p)=0$。由于 $H$ 是积性函数，所以仅当 $x$ 是 $\mathbf{Powerful\;Number}$ 时，$H(x)$ 才可能不为 $0$。

考虑答案为

$$
\sum_{i=1}^{n}F(i)=\sum_{ij\leq n}G(i)H(j)=\sum_{i=1}^{n}H(i)\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}G(j)
$$

$G$ 本身是简单的积性函数，可以使用杜教筛在 $O(n^{\frac{2}{3}})$ 的时间内筛出所有 $\lfloor\frac{n}{i}\rfloor$ 位置上的前缀和。接下来只需考虑 $i$ 为 $\mathbf{Powerful\;Number}$ 时，$H(i)$ 如何计算。因为 $H$ 是积性函数，所以我们只需要求出 $H(p^k)$。由狄利克雷卷积，有

$$
F(p^k)=\sum_{i=0}^{k}G(p^i)H(p^{k-i})
$$

根据欧拉函数的有关性质，$G(p^k)=p^k\varphi(p^k)=p^k(p-1)p^{k-1}=(p-1)p^{2k-1}$。将 $F,G$ 展开，得

$$
p^k(p^k-1)=\sum_{i=0}^{k}(p-1)p^{2i-1}H(p^{k-i})
$$

归纳可证 $H(p^k)=(k-1)(p^{k+1}-p^k)$。

搜索 $[1,\sqrt n]$ 内质数，并从 2 开始枚举它们的幂次，即可得到 $[1,n]$ 内的所有 $\mathbf{Powerful\;Number}$。在这个过程中，我们可以同时得到这些数的 $H$ 函数值。事实上，如果 $H(p^k)$ 不像本题一样可以快速求出，由于 $\sqrt n$ 以内的质数只有 $O\left(\frac{\sqrt n}{\log n}\right)$ 个且 $p$ 的幂次是 $O(\log n)$ 的，也可以暴力地计算出它们。

这个做法的时间复杂度是 $O(n^{\frac{2}{3}})$ 的，其瓶颈在于杜教筛 $G(x)$ 的前缀和。渐进意义上这个复杂度低于 min-25 筛的复杂度 $O\left(\frac{n^{\frac{3}{4}}}{\log n}\right)$，但在本题的数据范围下表现稍不如后者。但是这个算法也有它的优点：实现简单；当 $G$ 的前缀和可以快速求出时复杂度可以降低到 $O(\sqrt n)$ ，有明显优势。

### 代码 ###

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
typedef long long ll;
const int MAXN=5500000;
const int MOD=1E9+7;
const int INV2=500000004, INV6=166666668;
ll n; int lim, cp, ans;
int pri[MAXN], phi[MAXN];
bool flag[MAXN];
int g1[MAXN], g2[MAXN];
void prework()
{
	memset(flag, 0, sizeof flag);
	phi[1]=1;
	for (int i=2; i<=lim; i++)
	{
		if (!flag[i]) pri[++cp]=i, phi[i]=i-1;
		for (int j=1; j<=cp&&i*pri[j]<=lim; j++)
		{
			flag[i*pri[j]]=1;
			if (i%pri[j]==0)
			{
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			phi[i*pri[j]]=phi[i]*(pri[j]-1);
		}
	}
	for (int i=1; i<=lim; i++) g1[i]=(g1[i-1]+1ll*i*phi[i])%MOD;
}
int djs(ll m)
{
	if (m<=lim) return g1[m];
	if (g2[n/m]) return g2[n/m];
	int res=(m%MOD)*((m+1)%MOD)%MOD*((2*m+1)%MOD)%MOD*INV6%MOD;
	for (ll i=2, j; i<=m; i=j+1)
	{
		j=m/(m/i);
		res=(res-((i+j)%MOD)*((j-i+1)%MOD)%MOD*INV2%MOD*djs(m/i)%MOD+MOD)%MOD;
	}
	return g2[n/m]=res;
}
void dfs(int k, ll m, int h)
{
	if (k>cp||m*pri[k]>n)
	{
		if (n/m<=lim) ans=(ans+1ll*h*g1[n/m])%MOD;
		else ans=(ans+1ll*h*g2[n/(n/m)])%MOD;
		return;
	}
	ll p=1ll*pri[k]*pri[k];
	dfs(k+1, m, h);
	for (int e=2; m*p<=n; p*=pri[k], e++)
		dfs(k+1, m*p, p%MOD*(pri[k]-1)%MOD*(e-1)%MOD*h%MOD);
}
int main()
{
//	freopen("P5325.in", "r", stdin);
//	freopen("P5325.out", "w", stdout);
	scanf("%lld", &n);
	lim=pow(n, 2.0/3);
	prework(); djs(n);
	dfs(1, 1, 1);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Register_int (赞：59)

## 前言

~~好像没啥要说的，就是没人写想写一写~~

## Min_26 筛

当积性函数 $f$ 在 $p$ 处的点值为关于 $p$ 的低次多项式，且 $f(p^k)$ 的值容易求出时，我们可以使用 Min26 筛在 $O\left(n^{\frac23}\right)$ 的时间复杂度内求出 $\sum f$ 在所有 $\left\lfloor\dfrac ni\right\rfloor$ 处的值。相较于 Min25 筛的 $O\left(\dfrac{n^{0.75}}{\log n}\right)$ 快了不少。

先来约定一些记号：

- $\mathbb P$：全体素数组成的集合。特别的，$p$ 的取值无特殊说明则为素数，$p_k$ 为第 $k$ 个素数。
- $\pi(n)=|\{p|p\le n\}|$，即前缀素数个数。$\pi(l,r)$ 则为 $[l,r]$ 之间的素数个数。
- $\text{lpf}(n)=\min_{p|n}p$，即最小质因子。特别地，$\text{lpf}(1)=\infty$。
- $F_{prime}(n)=\sum_{p\le n}f(p)$。
- $F_k(n)=\sum^n_{i=1}[\text{lpf}(i)\ge p_k]f(i)$。
- 除法或开根号若无说明均为向下取整。
- $F$ 函数在 $n$ 的所有点值：表示 $F$ 在所有 $x\in\{i|1\le i\le\sqrt n\}\cup\{\frac ni|1\le i\le\sqrt n\}$ 处的值。

该筛法共分为四步，总复杂度为 $O\left(n^{\frac23}\right)$。

### Step 1

求出 $F_{prime}$ 在 $n$ 处的所有点值。

来看看 Min25 筛是怎么处理的。由于 $f(p)$ 是关于 $p$ 的一个低次多项式，我们可以把它拆开来，拆成 $k$ 次方之和的形式。设 $g(n,j)=\sum^n_i[i\in\mathbb P\lor\text{lpf}(i)\ge p_j]i^k$。有转移公式：

$$g(n,j)=g(n,j-1)-p_j^k\left(g\left(\dfrac n{p_j},j-1\right)-g(p_{j-1},j-1)\right)$$

减去的部分是「最小质因子恰好为 $p_j$ 的合数」。则 $F_{prime}(x)=g(x,\pi(\sqrt n))$。

如果直接计算 $g$ 函数，时间复杂度为 $O\left(\dfrac{n^{0.75}}{\log n}\right)$。如何做到更优呢？

考虑 根 号 分 治。是的你没听错，根号分治。

首先对于 $x\ge n^{\frac23}$ 的点值，我们可以直接用原版 Min25 筛的方式更新。剩下的部分，我们先将每个位置都初始化为 $\sum^x_{i=2}i^k$，再在之后筛去质数 $p_j$ 时，将 $F_p(x)$ 更新为 $F_p(x)-\sum^x_{i=1}[\text{lpf(i)}=p_j\land i\not\in\mathbb P]i^k$ 即可。

看起来好像和原来完全没区别啊，还把好不容易搞出来的 dp 拆回去了。但实际上我们可以枚举 $p_j$，然后暴力搜索质因数分解，找出所有 $\text{lpf(i)}=p_j$ 的 $i$。发现转移式实际上就是个区间修改单点查询，所以用 树 状 数 组 来优化。

但是复杂度依然爆炸。没事，对于 $\text{lpf}(x)\le\sqrt[6]n$ 的点值，我们直接暴力计算。由于满足 $x<n^{\frac23}$ 且 $\text{lpf}(x)>\sqrt[6] n$ 的数有 $O\left(\dfrac{n^{\frac 23}}{\log n}\right)$ 个，算上树状数组的复杂度，总时间复杂度为 $O\left(n^{\frac 23}\right)$。我们成功地优化了老版筛法的复杂度！

第一步可能把你震撼了三次，但后面就好很多了。

- - - 

### Step 2

求出 $F_{\pi(\sqrt[3]n)+1}$ 在 $n$ 处的所有点值。不妨设 $t=\pi(\sqrt[3]n)+1$。

因为能造成贡献的 $f(x)$ 均满足 $\text{lpf}(x)\ge p_t$，所以 $x$ 只可能是 $1$，$p$，或 $p^2$（$p\ge p_t$）。那么我们可以推出转移式：

$$F_{t}(x)=1+(F_{prime}(x)-F_{prime}(p_t-1))+\sum^{\sqrt x}_{p\ge p_t}f(p^2)+f(p)(F_{prime}\left(\frac xp\right)-F_{prime}(p))$$

容易发现，当 $x<p_t^2$ 时，该式的转移都是 $O(1)$ 的，这部分有 $O(\sqrt n)$ 个数。当 $x\ge p_t^2$ 时，后半部分求和的次数为 $\pi(t,\sqrt x)$。总复杂度为 $O(\sqrt n+\sum^{\sqrt[3]n}_{i=1}\pi(\sqrt{\frac ni}))=O\left(\dfrac{n^{\frac 23}}{\log n}\right)$。

- - -

### Step 3

依次求出 $F_{\pi(\sqrt[3]n)},F_{\pi(\sqrt[3]n)-1},F_{\pi(\sqrt[3]n)-2},\cdots,F_{\pi(\sqrt[6]n)+1}$ 在 $n$ 处的所有点值。

可以发现前后区别就是 $\text{lpf}(x)=p_k$ 的这些数。得出有递推：

$$F_k(x)=\sum_{p_k^i\le x}f(p^i_k)F_{k+1}\left(\dfrac m{p_k}\right)$$

直接暴力转移复杂度爆炸，仍然考虑根号分治：对于 $x\ge n^{\frac23}$ 处的点值暴力更新，由于有 $F_k(x)=F_{k+1}(x)+\sum^x_{i=1}[\text{lpf}(i)=p_k]f(i)$，剩下的部分按第一步的方法更新即可，不再赘述。

- - -

### Step 4

依次求出 $F_{\pi(\sqrt[6]n)},F_{\pi(\sqrt[6]n)-1},F_{\pi(\sqrt[6]n)-2},\cdots,F_{1}$ 在 $n$ 处的所有点值。

这里直接用上一步的式子暴力做就可以了。时间复杂度 $O\left(\dfrac{n^{\frac 23}}{\log n}\right)$。

- - -

### 参考代码（P5325 【模板】Min_25 筛）

有 $f(p^k)=(p^k)^2-p^k$，直接计算。

没有特意卡常的情况下跑出了总和 [1.57s](/record/121848350) 的好成绩。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;
const int mod = 1e9 + 7;
const int inv = (mod + 1) / 6;

inline 
ll qpow(ll b, ll p) {
	ll res = 1;
	for (; p; p >>= 1, b = b * b % mod) if (p & 1) res = res * b % mod;
	return res;
}

int p[MAXN], tot, t3 = 1, t6 = 1; bool vis[MAXN];

ll s[MAXN][3], n2, n3, n6, n23; // sqrt(n), cbrt(n), sqrt[6](n), n^2/3

inline 
void init(int n) {
	vis[1] = 1, n += 10;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) p[++tot] = i;
		for (int j = 1; j <= tot; j++) {
			if (i * p[j] > n) break;
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) break;
		}
		if (i == n3) t3 += tot;
		if (i == n6) t6 += tot;
	}
	for (int i = 1; i <= tot; i++) {
		s[i][1] = (s[i][1] + p[i]) % mod;
		s[i][2] = (s[i][2] + (ll)p[i] * p[i] % mod) % mod;
	}
}

inline 
ll calc(ll n, int k) {
	n %= mod;
	if (!k) return n;
	if (k == 1) return (n * (n + 1) >> 1) % mod;
	if (k == 2) return n * (n + 1) % mod * (2 * n + 1) % mod * inv % mod;
}

inline 
ll f(ll n) {
	n %= mod;
	return (n * n - n) % mod;
}

ll F[MAXN << 1], g[MAXN << 1][3], val[MAXN << 1]; // F(n / i)

ll n; int m;

inline 
ll get(ll k) {
	return k <= n2 ? k : m - n / k + 1;
}

ll c[MAXN];

inline 
void add(int k, ll x) {
	for (int i = k; i <= m; i += i & -i) c[i] = (c[i] + x) % mod;
}

inline 
ll ask(int k) {
	ll res = 0;
	for (int i = k; i; i &= i - 1) res = (res + c[i]) % mod;
	return res;
}

void dfs(int k, int tp, ll v, ll fv) { // 搜索找 lpf(x)=p_k
	if (!~tp || v != p[k]) add(get(n / (n / v)), ~tp ? mod - fv : fv);
	for (int i = k + 1; p[i] * v < n23 && i <= tot; i++) {
		for (ll x = p[i]; v * x < n23; x *= p[i]) {
			dfs(i, tp, v * x, fv * (~tp ? qpow(x, tp) : f(x)) % mod);
		}
	}
}

inline 
void upd_lpf(int k, int tp) { // 搜索入口 
	for (ll i = p[k]; i < n23; i *= p[k]) {
		dfs(k, tp, i, ~tp ? qpow(i, tp) : f(i));
	}
}

int main() {
	// 初始化 
	scanf("%lld", &n);
	n2 = sqrtl(n), n3 = cbrtl(n), n6 = pow(n, 1.l / 6);
	init(n2), n23 = n / n3;
	for (ll i = 1; i < n; i = n / (n / (i + 1))) val[++m] = i; val[++m] = n;
	
	// step 1
	for (int i = 1; i <= m; i++) g[i][1] = calc(val[i], 1) - 1, g[i][2] = calc(val[i], 2) - 1;
	// 1. 对 lpf(x) <= sqrt[6](n) 暴力。 
	for (int i = 1; i < t6; i++) {
		for (int j = m, x; j && p[i] <= val[j] / p[i]; j--) {
			x = get(val[j] / p[i]);
			g[j][1] = (g[j][1] - p[i] * (g[x][1] - g[p[i - 1]][1]) % mod + mod) % mod;
			g[j][2] = (g[j][2] - p[i] * p[i] % mod * (g[x][2] - g[p[i - 1]][2]) % mod + mod) % mod;
		}
	}
	
	for (int k = 1; k <= 2; k++) { // 枚举次数 
		for (int i = 1; val[i] < n23; i++) c[i] = (g[i][k] - g[i & i - 1][k] + mod) % mod;
		// 2. 对 x <= n^2/3 使用树状数组优化原来的递推。
		for (int i = t6; i < t3; i++) {
			for (int j = m; j && val[j] >= n23 && p[i] <= val[j] / p[i]; j--) {
				ll x = val[j] / p[i];
				if (x < n23) g[j][k] = (g[j][k] - qpow(p[i], k) * (ask(get(x)) - ask(p[i - 1])) % mod + mod) % mod;
				else g[j][k] = (g[j][k] - qpow(p[i], k) * (g[get(x)][k] - ask(p[i - 1])) % mod + mod) % mod;
			}
			upd_lpf(i, k);
		}
		for (int i = 1; i <= m && val[i] < n23; i++) g[i][k] = ask(i);
		// 3. 其余暴力。
		for (int i = t3; i <= tot; i++) {
			for (int j = m; j && val[j] >= n23 && p[i] <= val[j] / p[i]; j--) {
				g[j][k] = (g[j][k] - qpow(p[i], k) * (g[get(val[j] / p[i])][k] - ask(p[i - 1])) % mod + mod) % mod;
			}
		}
	}
	for (int i = 1; i <= m; i++) F[i] = (g[i][2] - g[i][1] + mod) % mod;
	
	// step 2
	for (int i = m; i; i--) {
		if (val[i] < p[t3]) { F[i] = 1; continue; }
		F[i] = (F[i] + 1 - F[p[t3] - 1] + mod) % mod;
		for (int j = t3; j <= tot && p[j] <= val[i] / p[j]; j++) {
			ll x = f(p[j]) * (F[get(val[i] / p[j])] - F[p[j]] + mod) % mod;
			F[i] = (F[i] + f((ll)p[j] * p[j] % mod) + x) % mod;
		}
	}
	
	// step 3
	for (int i = 1; i <= m && val[i] < n23; i++) c[i] = (F[i] - F[i & i - 1] + mod) % mod;
	for (int i = t3 - 1; i >= t6; i--) {
		for (int j = m; j && val[j] >= n23; j--) {
			for (ll x = p[i]; x <= val[j]; x *= p[i]) {
				if (val[j] / x >= n23) F[j] = (F[j] + F[get(val[j] / x)] * f(x) % mod) % mod;
				else F[j] = (F[j] + ask(get(val[j] / x)) * f(x) % mod) % mod;
			}
		}
		upd_lpf(i, -1);
	}
	for (int i = 1; i <= m && val[i] < n23; i++) F[i] = ask(i);
	
	// step 4
	for (int i = t6 - 1; i; i--) {
		for (int j = m; j; j--) {
			for (ll x = p[i]; x <= val[j]; x *= p[i]) {
				F[j] = (F[j] + F[get(val[j] / x)] * f(x) % mod) % mod;
			}
		}
	}
	
	printf("%lld\n", F[m]);
}
```

##### 参考资料

- [dengtesla - 新版 min25 筛详解](//zhuanlan.zhihu.com/p/60378354)
- ~~Min_25 本人已经爆炸的博客~~

---

## 作者：神眷之樱花 (赞：47)

# 前言
由于其由 Min_25 发明并最早开始使用，故称「Min_25 筛」。
   * 从此种筛法的思想方法来说，其又被称为「Extended Eratosthenes Sieve」。

其可以在 $O(\frac{n^{\frac{3}{4}}}{logn})$ 的时间复杂度下解决一类 **积性函数** 的前缀和问题。

要求： $f(p)$ 是一个关于 $p$ 的项数较少的多项式或可以快速求值； $f(p^{c})$ 可以快速求值。

摘自 [OI wiki](https://oi-wiki.org/math/min-25/)
# 解析
## [例题](https://www.luogu.com.cn/problem/P5325)
积性函数 $f(p^k) = p^k(p^k - 1)$
求：$\sum_{i = 1} ^ n f(i)$
### 准备 $1$
规定 $p$ 代表质数, $minp(i)$ 代表 $i$ 的最小质因子（其中 $minp(p) = p$），则：

$\sum_{i = 1} ^ n f(i) = \sum_{p \leq n} f(p) + \sum_{i \leq n \ and \ i \notin p} f(i)$

这一步表示将答案拆成质数的答案和合数的答案。
那么对于合数部分：

根据积性函数的性质，则有：

$f(i) = \prod_{k = 1} ^ m f(p_k ^ {c_k})$。

提**尽** $i$ 的最小质因子 $p_e$，将 $i$ 分成两部分：
$p_e ^ {c_e} \times \frac{i}{p_e ^ {c_e}}$

则上式可变为：

$f(i) = f(p_e ^ {c_e}) \times f(\frac{i}{p_e ^ {c_e})})$

那么合数部分的答案可转化为：

$\sum_{p ^ e \leq n} f(p ^ e) \sum_{1 \leq i \leq n \ and \ p ^ e \mid i \ and \  minp(\frac{i}{p ^ e}) > p} f(\frac{i}{p ^ e})$

代表的意思是：

枚举质数 $p$ 及它的指数 $e$，

在可以提的合数 $i$ 中提出 $p ^ e$，将合数 $i$ 转化为 $p ^ e \times \frac{i}{p ^ e}$，即上式乘法分配律展开的结果。

然后再判断如下条件：
* $p$ 是否是 $i$ 的最小质因子
* $p$ 是否提尽

这两个条件均可通过 $minp(\frac{i}{p ^ e})$ 是否大于 $p$ 来判断：

对于 $minp(\frac{i}{p ^ e}) < p$ 的 $i$，那么不满足条件 $1$。

对于 $minp(\frac{i}{p ^ e}) = p$ 的 $i$，那么不满足条件 $2$。

这些均可通过对 $i$ 分解质因数来理解。

那么对于 $f(p ^ e)$ 由题意可以直接求，对于 $f(\frac{i}{p ^ e})$ 则是同样的求法，直到 $\frac{i}{p ^ e}$ 是 $p_k ^ {c_k}$ 可以直接求。

而上述的约束则保证了不会多求漏求。
### 准备 $2$
所以我们现在需要求出所有 $f(p ^ k)$ 的值。

因为 $n$ 的范围很大，所以我们没法线性筛求出 $f$ 的前缀和。

考虑 DP。。。

设 $h_k(i) = i ^ k$，显然 $h_k$ 是一个完全积性函数。

设： $g_k(n,j) = \sum_{i = 1} ^ n [i \in Prime \ or \  minp(i) > p_j] h_k(i)$

其中 $p_j$ 表示第 $j$ 个质数。

换句话说 $g_k(n,j)$ 也就是 $1$ ~ $n$ 中质数或者最小质因数大于 $p_j$ 的 $i$ 的 $h_k(i)$ 的前缀和。

$g_k$ 的作用在下文，但也可以先抛开问题本身，看懂 $g_k$ 的求法。

考虑转移。。。

对于 $g_k(n, j - 1)$ 根据定义，其中包含两部分：
* $g_k(n, j)$ 
* 最小质因数等于 $p_j$ 的 $h_k(i)$ 的和。

所以可由 $g_k(n, j - 1)$ 减去多余的部分得到 $g_k(n, j)$。

所以有状态转移方程如下：

$g_k(n,j) = g_k(n, j - 1) - p_{j} ^ k (g_k(\frac{n}{p_{j}}, j - 1) - g_k(p_{j - 1}, j - 1))$

从状态转移方程可以看出：

最小质因数等于 $p_j$ 的 $h_k(i)$ 的和即为：

$g_k(n, j - 1) - p_{j} ^ k (g_k(\frac{n}{p_j}, j - 1) - g_k(p_{j - 1}, j - 1))$。

原因如下：

根据定义不难得到 $g_k(p_{j - 1}, j - 1)$ 即为前 $j - 1$ 个质数的 $k$ 次方和。

而对于 $g_k(\frac{n}{p_j}, j - 1)$，包含了两部分：
* $1$ ~ $p_{j - 1}$ 的质数和
* 最小质因数大于等于 $p_j$ 的合数和，及 $p_{j}$ ~ $\frac{n}{p_j}$ 的质数和

注意第二点，如果我们将这些最小质因数大于等于 $p_j$ 的合数或者后一部分的质数同时乘上 $p_j$ 那么我们得到的是不是都是最小质因数等于 $p_j$ 的合数，这点应该很好理解。

那也就是说得到了我们想要筛去的合数。

因为我们只知道上述两部分的和 $g_k(\frac{n}{p_j}, j - 1)$，所以在乘的过程中第一部分也会被乘上一个 $p_j$，那么我们应该把这一部分质数减去。

也就是 $g_k(p_j, j - 1)$。

又因为 $h_k$ 是完全积性函数，而我们谈论的和是 $h_k$ 的累加，根据乘法分配律，我们可以对 $g_k$ 运用完全积性函数的性质（$f(ab) = f(a)f(b)$）。

那么要得到最小质因数等于 $p_j$ 的 $h_k(i)$ 的和，我们可以直接给我们的第二部分乘上 $h_k(p_j)$ 的值，也就是 $p_j ^ k$，得到我们要求的函数值。

所以关于状态转移方程的解释就结束了。

关于初始化：

显然对于 $g_k(n, 0) = \sum_{i = 1} i ^ k$
### 求解
而我们得到的 $g_k$ 有什么用呢？

设 $g(n, j) = \sum_{i = 1} ^ n [i \in Prime \ or \ minp(i) > p_j] f(i)$。

因为 $f(p) = p(p - 1) = p ^ 2 - p$。

那么将满足条件的 $f(i)$ 累加，就得到两部分：
* $i ^ 2$ 的和
* $i$ 的和的相反数

如果令上文的 $k$ 分别等于 $1, 2$。

那么就有： $g(n, j) = g_2(n, j) - g_1(n, j)$。

如果设 $p_x$ 为小于等于 $\sqrt{n}$ 的最大的质数，那么 $1$ ~ $n$ 的质数的 $f$ 的和 $g(n, x)$ 记为 $g(n)$。

设 $S(n, j) = \sum_{minp(i) > p_j} f(i)$。

显然我们也需要 DP 。。。

同样的，考虑 $S(n, j)$ 的组成：
* 质数部分：大于 $p_j$ 小于等于 $n$ 的质数
* 合数部分

设 $sum_k(x)$ 表示小于等于 $p_x$ 的质数的 $k$ 次方的和。

那么质数部分就等于：

$g(n) - (sum_{2}(j) - sum_{1}(j))$

对于合数部分：

我们模仿 $g_k$ 的求法

因为 $f$ 不是完全积性函数，而是积性函数，我们不能像求 $g_k$ 那样只提一个 $p_j$。

所以我们要把 $p_j$ 提尽。

得到：
$\sum_{k > j \ and \ p_k ^ e \leq n} f(p_k ^ e)(S(\frac{n}{p_k ^ e} + [e \neq 1]))$

利用 $S(\frac{n}{p_k ^ e}$ 的思想和求 $g_k$ 的时候完全一样，这里就不在赘述了，实在不懂的同学可以手推一下。

后面加上一个 $[e \neq 1]$ 是因为如果 $e > 1$，那么$p ^ e$ 在我们提 $p_k ^ e$ 时没有算进去，而 $e = 1$ 时，在质数部分就算了，就不用了算进去。
# 下标的离散化
因为 $n = 1e10$，直接开肯定不行。
由性质 $\lfloor \frac{\lfloor \frac{x}{a} \rfloor}{b} \rfloor = \lfloor \frac{x}{ab} \rfloor$，在递归的时候，无论我们把 $n$ 除以几，得到的都是 $n$ 除以某个数，所以我们可以直接只保存 $n / x$ 的值。
来自 wucstdio 大佬
# 代码
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>

using namespace std;

typedef long long LL;

const LL mod = 1e9 + 7, inv2 = 500000004, inv3 = 333333336;
const int N = 1e5 + 5;

LL n, Prime[N + 5], num, sp1[N + 5], sp2[N + 5], tot =  0, w[3 * N], g1[3 * N], g2[3 * N], sqr;
int id1[N + 5], id2[N + 5];
bool notPrime[N + 5];

void init() {
	memset(notPrime, false, sizeof(notPrime));
	num = 0;
	for(int i = 2; i <= N; i++) {
		if(!notPrime[i]) {
			Prime[++num] = i;
			sp1[num] = (sp1[num - 1] + i) % mod;
			sp2[num] = (sp2[num - 1] + 1ll * i * i % mod) % mod;
		}
		for(int j = 1; j <= num && Prime[j] * i <= N; j++) {
			notPrime[i * Prime[j]] = true;
			if(i % Prime[j] == 0) break;
		}
	}
}

LL s(LL x, int y) {
	if(Prime[y] >= x) return 0;
	LL k = x <= sqr ? id1[x] : id2[n / x];
	LL ans = (g2[k] - g1[k] + mod - (sp2[y] - sp1[y]) + mod) % mod;
	for(int i = y + 1; i <= num && Prime[i] * Prime[i] <= x; i++) {
		LL P = Prime[i];
		for(int e = 1; P <= x; e++, P = P * Prime[i]) {
			LL xx = P % mod;
			ans = (ans + xx * (xx - 1) % mod * (s(x / P, i) + (e != 1))) % mod;
		}
	}
	return ans % mod;
}

int main() {
	init();
	scanf("%lld", &n);
	sqr = sqrt(n);
	for(LL l = 1, r; l <= n; l = r + 1) {
		r = (n / (n / l));
		w[++tot] = n / l;
		g1[tot] = w[tot] % mod;
		g2[tot] = g1[tot] * (g1[tot] + 1) / 2 % mod * (2 * g1[tot] + 1) % mod * inv3 % mod - 1;
		if(g2[tot] < 0) g2[tot] += mod;
		g1[tot] = g1[tot] * (g1[tot] + 1) / 2 % mod - 1;
		if(g1[tot] < 0) g1[tot] += mod;
		if(w[tot] <= sqr) id1[w[tot]] = tot;
			else id2[n / w[tot]] = tot;
	}
	for(int i = 1; i <= num; i++)
		for(int j = 1; j <= tot && Prime[i] * Prime[i] <= w[j]; j++) {
			LL k = w[j] / Prime[i];
			k = k <= sqr ? id1[k] : id2[n / k];
			g1[j] -= Prime[i] * (g1[k] - sp1[i - 1] + mod) % mod;
			g2[j] -= Prime[i] * Prime[i] % mod * (g2[k] - sp2[i - 1] + mod) % mod;
			g1[j] %= mod, g2[j] %= mod;
			if(g1[j] < 0) g1[j] += mod;
			if(g2[j] < 0) g2[j] += mod;
		}
	printf("%lld", (s(n, 0) + 1) % mod); 
	return 0;
}
```

---

## 作者：λᴉʍ (赞：28)

# Min25筛



---

[yyb博客](https://www.cnblogs.com/cjyyb/p/9185093.html)

要求：$\sum_{i=1}^nF(x)$

$F(x)$是积性函数。

$Min25$筛能用的前提：质数处的$f(p)$值是关于$p$的多项式，质数次方处的$f(p^e)$值 可以快速计算。

## 预处理

设完全积性函数$F'(x)$，在质数处取值$F(p)=F'(p)$。

预处理一个$g$函数。$g(n,j)=\sum_{i=1}^nF'(i)[i\in\mathbb{P}\text{ or }\min_{p|i}p>P_j]$

也就是$i$是质数或者$i$最小值因子$>P_j$的贡献（注意求的是$F'$）

转移：

$g(n,j)=\begin{cases}g(n,j-1) (P_j^2>n)\\g(n,j-1)-F'(P_j)[g(\frac{n}{P_j},j-1)-g(P_{j-1},j-1)](P_j\leq n)\end{cases}$

考虑$g(n,j-1)-g(n,j)$。如果$P_j^2>n$显然没有多余贡献。

否则会多余的一定是$P_j$的倍数，那么因为$F'$是完全积性函数，可以将多余的数全部除以$P_j$，并乘上贡献$F'(P_j)$。那么减掉的是$F'(P_j)$乘【$\frac{n}{P_j}$以内最小质因数$\geq P_j$的数的贡献和】。这个值就是$g(\frac{n}{P_j},j-1)-g(P_{j-1},j-1)$。前面多算了$<P_j$的质数，后面减掉了这一部分。

可以看出只有$\sqrt n$内的质数有用，线性筛到$\sqrt n$就行了。

后面的$g(P_{j-1},j-1)$按照定义等于$\sum_{i=1}^{P_{j-1}}F'(i)$。线性筛时预处理一下就行了。

这个$g$后面只用了质数处的$F'$，所以是对的~~而且很妙~~

## 求值

设$S(n,j)=\sum_{i=1}^nF(i)[\min_{p|i}p>P_j]$，即最小质因数大于$P_j$的所有数的$F$和，那么要求的答案是$S(n,0)$。

$S$的递推式为：$S(n,j)=g(n,|P|)-\sum_{i=1}^{j-1}f(P_i)+\sum_{p_k^e\leq n,k>j}F(p_k^e)(S(\frac{n}{p_k^e},k)+[e>1])$

前面部分是质数的贡献，后面是合数的

后面的$\sum$意思就是枚举合数最小的质因子及次数，因为是积性函数可以直接乘起来。$[e>1]$意思是如果$e>1$那么有一个$p_k^e$没算进答案（$S$不计算$1$的贡献，但$e=1$时$p_k^e$就是质数已经在前面算过了），要算进答案。

## 代码

一些细节：

- $n$一直整除一个数之后还是$n$整除一个数，也就是只需要用到所有$\frac ni$。开两个数组$a1,a2$，对于$\sqrt n$的向$a1$存，下标为$\frac ni$，否则向$a2$存，下标为$i$。两个数组都是$\sqrt n$的。
- 由于$S$没有算$1$，最后还要加上$1$的贡献。

```
#include<bits/stdc++.h>
#define il inline
#define vd void
#define mod 1000000007
typedef long long ll;
il ll gi(){
    ll x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))f^=ch=='-',ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return f?x:-x;
}
ll n;
int qt;
int pr[100010],yes[100010],cnt,gp1[100010],gp2[100010];
ll w[200010],sw;
int g1[200010],g2[200010];
int id1[100010],id2[100010];
il int S(ll x,int y){
    if(pr[y]>=x)return 0;
    int p=x<=qt?id1[x]:id2[n/x];
    int ret=((0ll+g2[p]-g1[p]-(gp2[y]-gp1[y]))%mod+mod)%mod;
    for(int i=y+1;i<=cnt&&1ll*pr[i]*pr[i]<=x;++i){
        ll pe=pr[i];
        for(int e=1;pe<=x;++e,pe*=pr[i]){
            int o=pe%mod;
            ret=(ret+1ll*o*(o-1)%mod*(S(x/pe,i)+(e!=1)))%mod;
        }
    }
    return ret;
}
int mian(){
    n=gi();qt=sqrt(n);
    yes[1]=1;
    for(int i=2;i<=qt;++i){
        if(!yes[i])pr[++cnt]=i;
        for(int j=1;j<=cnt&&i*pr[j]<=qt;++j){
            yes[i*pr[j]]=1;
            if(i%pr[j]==0)break;
        }
    }
    for(int i=1;i<=cnt;++i)gp1[i]=(gp1[i-1]+pr[i])%mod,gp2[i]=(gp2[i-1]+1ll*pr[i]*pr[i])%mod;//递推时用的质数处F前缀和
    for(ll l=1,r;l<=n;l=r+1){//预处理(n/i) & 计算g的j=0边界，边界就是F'的前缀和，由于质数处F(p)是多项式所以可以快速算
        r=n/(n/l);w[++sw]=n/r;
        g1[sw]=w[sw]%mod;
        g2[sw]=(1ll*g1[sw]*(g1[sw]+1)%mod*(g1[sw]*2+1)%mod*166666668%mod-1)%mod;//1..w[sw]平方和
        g1[sw]=(1ll*g1[sw]*(g1[sw]+1)%mod*500000004-1)%mod;//1..w[sw]等差数列和
        if(n/r<=qt)id1[n/r]=sw;else id2[r]=sw;
    }
    //j从1到|P|递推g
    for(int i=1;i<=cnt;++i){
        ll sqr_pi=1ll*pr[i]*pr[i];
        for(int j=1;j<=sw&&sqr_pi<=w[j];++j){
            ll p=w[j]/pr[i];
            p=(p<=qt?id1[p]:id2[n/p]);//定位p的坐标
            g1[j]=(g1[j]-1ll*pr[i]*(g1[p]-gp1[i-1]+mod)%mod+mod)%mod;
            g2[j]=(g2[j]-1ll*pr[i]*pr[i]%mod*(g2[p]-gp2[i-1]+mod)%mod+mod)%mod;
        }
    }
    printf("%d\n",(S(n,0)+1)%mod);
    return 0;//}
```

---

## 作者：gxy001 (赞：21)

这篇题解是从 $\text{DGF}$ 的角度推式子。

关于 $\text{DGF}$ 的前置知识可以看我的[博客](https://www.luogu.com.cn/blog/gxy001/di-li-ke-lei-sheng-cheng-han-shuo-qian-tan)

我们先尝试把这个东西的 $\text{DGF}$ 用 $\zeta$ 表示。
$$
\begin{aligned}
 &\prod\limits_{p\in\mathrm{Prime}}\left(1+\sum\limits_{i=1}^\infin\frac{p^i(p^i-1)}{p^{ix}}\right)\\
=&\prod\limits_{p\in\mathrm{Prime}}\left(1+\sum\limits_{i=1}^\infin\frac{p^{2i}}{p^{ix}}-\sum\limits_{i=1}^\infin\frac{p^i}{p^{ix}}\right)\\
=&\prod\limits_{p\in\mathrm{Prime}}\left(1+\sum\limits_{i=1}^\infin p^{i(2-x)}-\sum\limits_{i=1}^\infin p^{i(1-x)}\right)\\
=&\prod\limits_{p\in\mathrm{Prime}}\left(1+\frac{p^{2-x}}{1-p^{2-x}}-\frac{p^{1-x}}{1-p^{1-x}}\right)\\
=&\prod\limits_{p\in\mathrm{Prime}}\frac{(1-p^{2-x})(1-p^{1-x})+p^{2-x}(1-p^{1-x})-p^{1-x}(1-p^{2-x})}{(1-p^{2-x})(1-p^{1-x})}\\
=&\prod\limits_{p\in\mathrm{Prime}}\frac{1-p^{1-x}-p^{2-x}+p^{3-2x}+p^{2-x}-p^{3-2x}-p^{1-x}+p^{3-2x}}{1-p^{1-x}-p^{2-x}+p^{3-2x}}\\
=&\prod\limits_{p\in\mathrm{Prime}}\frac{1-2p^{1-x}+p^{3-2x}}{1-p^{1-x}-p^{2-x}+p^{3-2x}}\\
=&\zeta(x-1)\zeta(x-2)\prod\limits_{p\in\mathrm{Prime}}(1-2p^{1-x}+p^{3-2x})\\
\end{aligned}
$$
我们发现后面那个东西似乎不能很好的用 $\zeta$ 表示，考虑换个方向推。

如果有一个积性函数的 $\text{DGF}$ 为 $\prod\limits_{p\in\mathrm{Prime}}(1+\sum\limits_{i=2}^\infin\frac{f(p^i)}{p^{ix}})$，那么我们是可以在 $\mathrm O(\sqrt n)$ 内求出它的前缀和的，因为 $[1,n]$ 之间的 $\text{Powerful Number}$（所有质因子次数都大于 $1$ 的数）只有 $\mathrm O(\sqrt n)$ 个。

证明：显然所有 $\text{Powerful Number}$ 都可以表示成 $a^2b^3$ 的形式。
$$
\begin{aligned}
&\mathrm O\left(\sum_{a=1}^{\sqrt n}\left(\frac{n}{a^2}\right)^{\frac{1}{3}}\right)\\
=&\mathrm O\left(\int_{1}^{\sqrt n}\left(\frac{n}{x^2}\right)^{\frac{1}{3}}dx\right)\\
=&\mathrm O(\sqrt n)\\
\end{aligned}
$$
我们现在想要把后面那个东西推成 $\prod\limits_{p\in\mathrm{Prime}}(1+\sum\limits_{i=2}^\infin\frac{f(p^i)}{p^{ix}})$ 的形式。
$$
\begin{aligned}
&\zeta(x-1)\zeta(x-2)\prod\limits_{p\in\mathrm{Prime}}(1-2p^{1-x}+p^{3-2x})\\
=&\zeta(x-1)\zeta(x-2)\prod_{p\in\mathrm{Prime}}(1-2p^{1-x}+p^{2(1-x)+1})\\
=&\zeta(x-1)\zeta(x-2)\prod_{p\in\mathrm{Prime}}((1-p^{1-x})^2+p^{2(1-x)+1}-p^{2(1-x)})\\
=&\frac{\zeta(x-2)}{\zeta(x-1)}\prod_{p\in\mathrm{Prime}}\frac{(1-p^{1-x})^2+p^{2(1-x)+1}-p^{2(1-x)}}{(1-p^{1-x})^2}\\
=&\frac{\zeta(x-2)}{\zeta(x-1)}\prod_{p\in\mathrm{Prime}}(1+\frac{p^{2(1-x)+1}}{(1-p^{1-x})^2}-\frac{p^{2(1-x)}}{(1-p^{1-x})^2})\\
=&\frac{\zeta(x-2)}{\zeta(x-1)}\prod_{p\in\mathrm{Prime}}(1+\sum_{i=2}^\infin (i-1)p^{i(1-x)+1}-\sum_{i=2}^\infin (i-1)p^{i(1-x)})\\
=&\frac{\zeta(x-2)}{\zeta(x-1)}\prod_{p\in\mathrm{Prime}}(1+\sum_{i=2}^\infin\frac{ip^{i+1}-p^{i+1}-ip^{i}+p^i}{p^{ix}})\\
\end{aligned}
$$

设要求的函数为 $f$，$\frac{\zeta(x-2)}{\zeta(x-1)}$ 对应的函数为 $g$，$\prod\limits_{p\in\mathrm{Prime}}(1+\sum_{i=2}^\infin\frac{ip^{i+1}-p^{i+1}-ip^{i}+p^i}{p^{ix}})$ 对应的函数为 $h$。

则有 $f=g*h$，$g$ 可以直接杜教筛，至于杜教筛的构造，显然有 $g*id_1=id_2$，$h$ 显然只在 $\text{Powerful Number}$ 处有值，直接爆搜所有小于 $\sqrt n$ 的质数即可，算到每一个 $\text{Powerful Number}$ 处统计 $h(x)(\sum\limits_{i=1}^{\lfloor\frac{n}{x}\rfloor} g(i))$ 即可求出 $\sum\limits_{i=1}^n f(i)$。

代码：

```cpp
#include<cstdio>
#include<cmath>
int const mod=1000000007,inv6=1000000008/6,inv2=1000000008/2;
int np[4641600],lim,cnt,p[464160],g[4641600],g2[4641600];
long long n;
int getsum(long long x){
	if(x<=lim) return g[x];
	if(g2[n/x]) return g2[n/x];
	int ans=x%mod*((x+1)%mod)%mod*((2*x+1)%mod)%mod*inv6%mod;
	for(long long l=2,r,d;l<=x;l=r+1){
		r=x/(x/l);
		ans=(ans-(l+r)%mod*(r-l+1)%mod*inv2%mod*getsum(x/l)%mod+mod)%mod;
	}
	return g2[n/x]=ans;
}
int ans;
void dfs(int k,long long m,int h){
	if(k>cnt||m*p[k]>n||m*p[k]*p[k]>n){
		long long const &p=n/m;
		if(p<=lim)ans=(ans+1ll*h*g[p])%mod;
		else ans=(ans+1ll*h*g2[n/p])%mod;
		return;
	}
	long long p=1ll*::p[k]*::p[k];
	dfs(k+1,m,h);
	for(int e=2;m*p<=n;p*=::p[k],++e)dfs(k+1,m*p,p%mod*(::p[k]-1)%mod*(e-1)%mod*h%mod);
}
int main(){
	scanf("%lld",&n);
	lim=pow(n,2.0/3.0);if(!lim)++lim;
	g[1]=1;
	for(int i=2;i<=lim;i++){
		if(!np[i])p[++cnt]=i,g[i]=i-1;
		for(int j=1,tmp;j<=cnt&&(tmp=i*p[j])<=lim;j++){
			np[tmp]=1;
			if(i%p[j]==0){
				g[tmp]=g[i]*p[j];
				break;
			}else g[tmp]=g[i]*g[p[j]];
		}
	}
	for(int i=1;i<=lim;i++)g[i]=(g[i-1]+1ll*i*g[i])%mod;
	getsum(n);
	dfs(1,1,1);
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：日居月诸 (赞：20)

**如果Latex有问题，请移步剪切板：** 

https://www.luogu.com.cn/paste/nyd6rs6i


# 利用 Powerful Number 求数论函数前缀和

## 0. 前言

**Powerful Number** 可以用来快速求解数论函数的前缀和。

本文参考了：

[zzq's blog](https://www.cnblogs.com/zzqsblog/p/9904271.html)

[攀岩高手 的博客](https://www.luogu.com.cn/blog/lengyanze/solution-p5325)

在此向以上文章的作者呈上真挚的感谢！

[我的 csdn 博客](https://blog.csdn.net/qq_41996523)，欢迎来逛。

## 1. Powerful Number

### 1.1 定义

正整数 $n=p_1^{a_1}p_2^{a_2}\cdots p_s^{a_s}$ 满足 $a_i\ge 2(1\le i\le s)$，即 $n$ 的所有质因子的幂次都 $\ge 2$ ，则称 $n$ 是一个 **Powerful Number**。特别地，1 为 **Powerful Number**。

### 1.2 性质

$[1,n]$ 内的 **Powerful Number** 有 $O(\sqrt n)$ 个。

**证：** 显然 **Powerful Number** 都可以表示成 $a^2b^3$ 的形式，我们枚举 $a$，则 $[1,n]$ 内 **Powerful Number** 的数量为
$$
O\left(\sum_{a=1}^{\sqrt n}\sqrt [3]{\dfrac{n}{a^2}}\right)
\\
=O\left(\sqrt[3] n\int_1^{\sqrt n}a^{-2/3}da\right)
\\
=O(\sqrt n)\\\Box
$$
这个性质保证了算法的复杂度。

## 2. 应用

[P5325 【模板】Min_25筛](https://www.luogu.com.cn/problem/P5325)

已知积性函数 $f(n)$，满足 $f(p^k)=p^k(p^k-1)$。求
$$
\sum_{i=1}^nf(i)
$$
$1\le n\le 10^{10}$。

先找到一个积性函数使得它与 $f$ 在素数的取值一致，我们可以找到 $g(n)=n\varphi(n)$。

设 $h$ 满足 $f=g*h$，其中 $*$ 为 Dirichlet 卷积，故有
$$
f(p)=g(1)h(p)+g(p)h(1)
$$
由于 $f,g$ 都是积性函数，则 $h$ 也是积性函数，故有 $h(1)=g(1)=1$，则又由于 $f(p)=g(p)$，有 $h(p)=0$。

由于 $h$ 是积性函数，则 $h$ 仅在 **Powerful Number** 处可能不为 0。

我们继续推式子，题目所求为
$$
\sum_{i=1}^nf(i)=\sum_{i=1}^n\sum_{d|i}g(d)h\left(\dfrac i d\right)
\\
=\sum_{ij\le n}g(i)h(j)=\sum_{i=1}^nh(i)\sum_{j=1}^{n/i}g(j)
$$
根据上文所说，我们只需考虑 $i$ 为 **Powerful Number** 时 $g$ 的前缀和怎么求，$h$ 的函数值怎么求（这两点也是最重要的）。

我们可以通过杜教筛简单地求得 $g$ 在所有特殊点 $\left\lfloor\dfrac ni\right\rfloor$ 处的前缀和。

那么唯一剩下的问题就变成了求 $h$ 在 **Powerful Number** 处的前缀和。

由于 $h$ 是积性函数，我们考虑计算 $h(p^k)$ 的值。注意到当 $p>\sqrt n$ 时不可能有 **Powerful Number** 有质因子 $p$，故我们只要计算 $p\le \sqrt n$ 时的情况。

我们有两种方法计算。

**Way1 推式子**

有
$$
f(p^k)=(h*g)(p^k)=\sum_{i=0}^kg(p^i)h(p^{k-i})
$$
而
$$
g(p^i)=p^i\varphi(p^i)=(p-1)p^{2i-1}(i\ge1)
\\
g(1)=1
$$
展开得
$$
p^k(p^k-1)=h(p^k)+\sum_{i=1}^k(p-1)p^{2i-1}h(p^{k-i})
$$
后面那部分很难看，我们不妨改一下 $h$ 的指数，有
$$
p^k(p^k-1)=h(p^k)+\sum_{i=0}^{k-1}(p-1)p^{2k-2i-1}h(p^i)
$$
接下来考察你高中数列的解题水平了，做不出来的请问你的高中数学老师。

用 $k-1$ 代替原式，有
$$
p^{k-1}(p^{k-1}-1)=h(p^{k-1})+\sum_{i=0}^{k-2}(p-1)p^{2k-2i-3}h(p^i)
\\
p^{k+1}(p^{k-1}-1)=p^2h(p^{k-1})+\sum_{i=0}^{k-2}(p-1)p^{2k-2i-1}h(p^i)
$$
两式相减得
$$
p^{2k}-p^k-p^{2k}+p^{k+1}=h(p^{k})-p^2h(p^{k-1})+(p-1)ph(p^{k-1})
$$
稍作化简得
$$
h(p^k)-ph(p^{k-1})=p^{k+1}-p^k
$$
设 $H(k)=h(p^k)$，则
$$
H(k)-pH(k-1)=p^{k+1}-p^k
\\
\dfrac{H(k)}{p^k}-\dfrac{H(k-1)}{p^{k-1}}=p-1
$$
累加法，又 $H(1)=h(p)=0$ 得
$$
\dfrac{H(k)}{p^k}=(k-1)(p-1)
\\
H(k)=h(p^k)=(k-1)(p-1)p^k
$$
于是我们得到了通项，直接代入计算即可。

**Way2 暴力计算**

根据
$$
p^k(p^k-1)=h(p^k)+\sum_{i=0}^{k-1}(p-1)p^{2k-2i-1}h(p^i)
$$
得
$$
h(p^k)=p^k(p^k-1)-\sum_{i=0}^{k-1}(p-1)p^{2k-2i-1}h(p^i)
$$
直接计算 $h(p^k)$，每个质因子递推计算即可。这样的复杂度为 $O(质数个数\times 幂次)$

而 $\sqrt n$ 以内素数个数为 $\pi(\sqrt n)=O(\dfrac{\sqrt n}{\log n})$，幂次为 $O(\log n)$，故复杂度仍为 $O(\sqrt n)$。这种方法不用动太多脑子。（当然你不好递推的话，纯暴力计算$O(\sqrt n\log n)$ ~~似乎也没啥大问题~~）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
char In[1 << 20], *ss = In, *tt = In;
#define getchar() (ss == tt && (tt = (ss = In) + fread(In, 1, 1 << 20, stdin), ss == tt) ? EOF : *ss++)
ll read() {
	ll x = 0, f = 1; char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + int(ch - '0');
	return x * f;
}
const int MAXK = 5e6 + 5;
const int P = 1e9 + 7, inv6 = 166666668;
ll pls(ll a, ll b) {return a + b < P ? a + b : a + b - P;}
ll mns(ll a, ll b) {return a < b ? a + P - b : a - b;}
ll mul(ll a, ll b) {return a * b % P;}
ll n, g[MAXK], sg[MAXK], tb_g[MAXK];
int pr[MAXK], ip[MAXK], tot; 
void Sieve(int n) {
	ip[1] = 1; g[1] = 1;
	for(int i = 2; i <= n; i++) {
		if(!ip[i]) {
			pr[++tot] = i;
			g[i] = i-1;
		}
		for(int j = 1; j <= tot && 1ll * i * pr[j] <= n; j++) {
			int k = i * pr[j];
			ip[k] = 1;
			if(i % pr[j]) g[k] = g[i] * (pr[j] - 1);
			else {
				g[k] = g[i] * pr[j];
				break;
			}
		}
	}
	for(int i = 1; i <= n; i++) g[i] = mul(g[i], i);
	for(int i = 1; i <= n; i++) sg[i] = pls(sg[i-1], g[i]);
}
ll S1(ll n) {n %= P; return n * (n + 1) / 2 % P;}
ll S2(ll n) {n %= P; return n * (n + 1) % P * (n + n + 1) % P * inv6 % P;}
ll calcsg(ll x) {
	if(x < MAXK) return sg[x];
	if(~tb_g[n / x]) return tb_g[n / x];
	ll ret = S2(x);
	for(ll i = 2, j; i <= x; i = j + 1) {
		ll t = x / i; j = x / t;
		ret = mns(ret, mul(calcsg(t), mns(S1(j), S1(i-1))));
	}
	return tb_g[n / x] = ret;
}
ll calch(ll p, ll pk, ll e) {p %= P; pk %= P; e %= P; return (e-1) * (p-1) % P * pk % P;}
ll dfs(ll k, ll lst, ll h) {
	ll ans = mul(h, calcsg(n / lst));
	for(ll g = n / lst; 1ll * pr[k] * pr[k] <= g; k++) {
		for(ll e = 2, p = 1ll * pr[k] * pr[k]; p <= g; p *= pr[k], e++)
			ans = pls(ans, dfs(k+1, lst * p, mul(h, calch(pr[k], p, e))));
	}
	return ans;
}
int main() {
	n = read();
	Sieve(MAXK - 1);
	memset(tb_g, -1, sizeof tb_g);
	printf("%lld\n", dfs(1, 1, 1));
	return 0;
}
```





---

## 作者：封禁用户 (赞：9)

# P5325 【模板】Min_25筛

## 题目描述
定义一个积性函数 $f(p^k)=p^k(p^k-1)$，求
$$\sum_{i=1}^{n}f(i)$$
对 $1e9+7$ 取模，$n \leq 1e10$。

## Solution

### step1

定义
$$h_k(i)=i^k$$
$$g_k(n,j)=\sum_{i=1}^{n} [i \in p \ or \ minp(i)>p_j] \ h_k(i)$$

考虑 $g_k(n,j)$ 如何由 $g_k(n,j-1)$ 转移。
$$g_k(n,j)=g_k(n,j-1)-\sum_{i=1}^{n}[i \notin p \ and \ minp(i)=p_{j-1}] \ h_k(i)$$

一个神奇的思路。观察 $g_k(\frac{n}{p_j},j-1)$ 包括两部分：

1. $1$ ~ $p_{j-1}$ 的质数和。
2. $p_j$ ~ $\frac{n}{p_j}$ 的质数和，$1$ ~ $\frac{n}{p_j}$ 中 $minp > p_j$ 的合数和。

将第 $2$ 部分乘上 $p_j$，就可以得到 $minp = p_j$ 的合数和。

所以

$$g_k(n,j)=g_k(n,j-1)-h(p_j)[g_k(\frac{n}{p_j},j-1)-g_k(p_{j-1},j-1)]$$

因为 $g_k$ 是对完全积性函数 $h_k$ 的求和，根据乘法分配律可得等式成立。

### step 2

定义
$$f'(i)=i(i-1)=i^2-i$$
$$g(n,j)= \sum_{i=1}^{n} [i \in p \ or \ minp(i)>p_j] \ f'(i)$$
$$=g_2(n,j)-g_1(n,j)$$
$$g(n)=\sum_{i=1}^{n}[i \in p] \ f'(i)$$
$$sum_k(x)=\sum_{i=1}^{p_x}[i\in p] \ i^k$$
$$S(n,j)=\sum_{i=1}^{n}[minp(i)>p_j] \ f(i)$$

对于 $S(n,j)$ 考虑从质数、合数两方面分别来求。

对于质数部分，值为：
$$g(n)-(sum_2(j)-sum_1(j))$$
对于合数部分，与 $g_k$ 的推导类似，但因为 $f$ 非完全积性函数，所以要将质因子提尽，值为：
$$\sum_{k>j \ and \ p_k^e \leq n}f(p_k^e)(S(\frac{n}{p_k^e}+[e \neq 1]))$$

之所以要加 $[e \neq 1]$，是因为当 $[e \neq 1]$ 时，$p_k^e$ 也是合数。

### step3

**下标离散化**

因为 $n \leq 1e10$，所以直接开肯定开不下。

根据
$$\lfloor \frac{\lfloor \frac{n}{a} \rfloor}{b} \rfloor=\lfloor \frac{n}{ab} \rfloor$$

得，$n$ 除以很多次之后，依然等于除以某一个数。

## 代码展示
```cpp
#include<cstdio>
#include<cmath>
#define LL long long
#define int long long
using namespace std;

const int MAXN = 1e6 +5;
const LL MOD = 1e9 + 7;

LL n, sqr, inv6, inv2;
LL cnt, prime[MAXN], v[MAXN];
LL sp1[MAXN], sp2[MAXN];
int tot; LL w[MAXN], g1[MAXN], g2[MAXN];
int id1[MAXN], id2[MAXN];

LL expow(LL x, LL y) {
	LL res = 1;
	while(y) {
		if(y & 1) res = res * x % MOD;
		y >>= 1, x = x * x % MOD; 
	}
	return res;
}

void init(int x) {
	for(int i = 2; i <= x; i++) {
		if(!v[i]) {
			v[i] = i, prime[++cnt] = i;
			sp1[cnt] = (sp1[cnt - 1] + i) % MOD;
			sp2[cnt] = (sp2[cnt - 1] + 1ll * i * i % MOD) % MOD;
		}
		for(int j = 1; j <= cnt && prime[j] * i <= x; j++) {
			v[i * prime[j]] = prime[j];
			if(i % prime[j] == 0) break;
		}
	}
	inv6 = expow(6, MOD - 2);
	inv2 = expow(2, MOD - 2);
}

LL S(LL x, int y) {
	if(prime[y] >= x) return 0;
	LL k = (x <= sqr) ? id1[x] : id2[n / x];
	//printf("%lld %lld %d\n",x, k, y);
	LL res = (g2[k] - g1[k] + MOD - (sp2[y] - sp1[y]) + MOD) % MOD;
	//printf("%lld\n",res);
	for(int i = y + 1; i <= cnt && prime[i] * prime[i] <= x; i++) {
		LL P = prime[i];
		for(int e = 1; P <= x; e++, P *= prime[i]) {
			LL mul = P % MOD;
			res = (res + mul * (mul - 1) % MOD * (S(x / P, i) + (e != 1)) % MOD) % MOD;
			//printf("%lld %lld\n",mul, res);
		}
	}
	return res;
}

main() {
	scanf("%lld",&n);
	sqr = sqrt(n);
	init(sqr);
	for(LL l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		w[++tot] = n / l;
		g1[tot] = w[tot] % MOD;
		g2[tot] = g1[tot] * (g1[tot] + 1) % MOD * (2 * g1[tot] + 1) % MOD * inv6 % MOD - 1;
		if(g2[tot] < 0) g2[tot] += MOD;
		g1[tot] = g1[tot] * (g1[tot] + 1) % MOD * inv2 % MOD - 1;
		if(g1[tot] < 0) g1[tot] += MOD;
		if(w[tot] <= sqr) id1[w[tot]] = tot;
		else id2[n / w[tot]] = tot;
	}
	for(int i = 1; i <= cnt; i++) {
		for(int j = 1; j <= tot && prime[i] * prime[i] <= w[j]; j++) {
			int k = w[j] / prime[i];
			k = (k <= sqr) ? id1[k] : id2[n / k];
			g1[j] = (g1[j] - prime[i] * (g1[k] - sp1[i - 1] + MOD) % MOD) % MOD;
			g2[j] = (g2[j] - prime[i] * prime[i] % MOD * (g2[k] - sp2[i - 1] + MOD) % MOD) % MOD;
			if(g1[j] < 0) g1[j] += MOD;
			if(g2[j] < 0) g2[j] += MOD;
			//printf("%lld %lld\n",g1[j], g2[j]);
		}
	}
	printf("%lld\n",(S(n, 0) + 1) % MOD);
	return 0;
}
```


---

## 作者：chenxia25 (赞：7)

### min25 筛

在 $\mathrm o(n)$ 时间内求特定积性函数 $f$ 的前 $n$ 项的和。

使用该算法的先决条件：$f$ 在质数 $p$ 处的值可以用关于 $p$ 的低次多项式表达出来，并且在质数的幂处的值可以较快算出。事实上对于前者，大部分积性函数都满足，例如 $\sigma_k(p)=p^k+1$，$\varphi(p)=p-1$，$\mu(p)=-1$；对后者也是大部分积性函数都满足。所以可以发现 min25 筛的适用性还是很广的，但它也有它自己的缺点，就是不能顺便获得关键点 $\left\lfloor\dfrac nx\right\rfloor$ 处的前缀和。

min25 筛分成两个部分：一是算 $n$ 以内质数的总贡献，二是算合数（当然最后要把 $1$ 处的值 $1$ 加上）。

第一部分：考虑模拟埃氏筛的过程，用一个个质数把所有合数筛掉，最终只剩下质数。由于合数最终不会被算，所以合数处的值搞成什么样都可以，不妨当作质数，和质数享有一样的低阶多项式表达式。考虑对多项式的每一项求和，最终加起来，这样不仅由于多项式低阶，计算次数可以忽略，而且对一个每处的值都是该处的幂的函数（恒等函数）是完全积性函数，并且前缀和有通项。考虑设 $g(i,j)$ 表示 $i$ 以内的数用前 $j$ 个质数筛过以后剩下来的所有数的幂的和，即所有质数和最小质因子大于第 $j$ 个质数的合数的总贡献。考虑埃氏筛的过程，若 $P_j^2>i$，则显然 $g(i,j)=g(i,j-1)$；否则 $g(i,j-1)\to g(i,j)$ 显然筛掉了最小质因子恰好等于第 $j$ 个质数的所有合数，根据完全积性函数的性质，转移方程显然有：
$$
g(i,j)=g(i,j-1)-f(P_j)\!\left(g\!\left(\left\lfloor\dfrac i{P_j}\right\rfloor\!,j-1\right)-g(P_{j-1},j-1)\right)
$$
可以发现，转移到的 $i$，由于 $\left\lfloor\dfrac{\left\lfloor\dfrac na\right\rfloor}b\right\rfloor=\left\lfloor\dfrac n{ab}\right\rfloor$，一定是某个 $\left\lfloor\dfrac nx\right\rfloor$ 的值，只有根号个。存储的话，还要进行离散化，这里有个巧方法：对 $\leq \sqrt n$ 的值记录 $i$，否则记录 $\left\lfloor\dfrac nx\right\rfloor=i$ 的唯一解 $x=\left\lfloor\dfrac ni\right\rfloor$。$g(P_{j-1},j-1)$ 表示小于 $P_j$ 的质数贡献和。由于仅当 $P_j^2\leq i\leq n$ 的时候才会用到这个转移式，所以这个质数的前缀和可以直接线筛，筛到 $\sqrt n$。然后 $j$ 这一维显然可以滚掉，就外层枚举 $j$，内层倒过来枚举 $i$ 转移。这样滚动还有个好处，就是将 $i$ 排序后，对每个 $j$ 需要更新的 $i$ 是一个后缀，可以直接搞。不难发现第一部分利用了低阶多项式的种种优美性质，以及埃氏筛中 $>\sqrt n$ 的质数不起作用这个重要的保障复杂度的事情。

第二部分：设 $h(i,j)$ 表示 $i$ 以内最小质因子大于 $P_j$ 的所有数的原积性函数值和。这次是倒过来转移的，即之前 $g$ 的边界 $g(i,0)$ 由于恒等函数的优美性质可以直接算，而这次边界为 $h(i,pcnt)$ 仅包含质数的贡献，最后答案是 $h(n,0)$。考虑转移，计算 $h(i,j)$ 时先把之前算过的质数的贡献算上（以下直接假定 $g$ 为第一部分所计算出的对多项式每一项分别的 $g$ 的和），然后枚举合数的最小质因子及其次数，利用积性函数的性质把值拆出来转移：
$$
h(i,j)=g(i,pcnt)-g(P_j,j)+\sum_{p>j,P_p^2\leq i}\sum_{k\geq1,P_p^k\leq i}f\!\left(P_p^k\right)\!\left(h\!\left(\left\lfloor\dfrac i{P_p^k}\right\rfloor\!,p\right)+[k>1]\right)
$$
$g(P_j,j)$ 依然是那个被线筛预处理的玩意。合数的最小质因子一定 $\leq\sqrt n$ 这个性质再一次保障了复杂度，保障了 $j$ 的范围是到根号，使得 $g$ 和 $h$ 的状态结构相同（另一个 point 是 $h$ 的有效 $i$ 值也是整除的形式）。枚举最小质因子的时候，也用到了这个性质来保障复杂度。然后就直接爆搜递归转移，边界是 $h(i,j)=0(P_j>i)$，甚至不需要记忆化。

这两个部分的总复杂度被证明是 $\mathrm O\!\left(n^{0.75}\log^{-1}n\right)$ 或者是 $\mathrm O\!\left(n^{1-\epsilon}\right)$ ~~我也不知道~~。总之挺快的，$n=10^{10}$ 大概跑 1s。

[min25 筛模板](https://www.luogu.com.cn/record/46654469) [杜教筛模板（用 min25 筛写的）](https://www.luogu.com.cn/record/46653242)

---

## 作者：AzusaCat (赞：5)

一种亚线性复杂度求积性函数前缀和的筛法。

适用条件：

-  $f(p)$ 为多项式（除代码外，本文 $p$ 均指质数）

- $f(p^k)$ 便于计算

我们以 LuoguP5325 为例简单介绍。

求 $\sum\limits_{i=1}^nf(i)$，其中 $f$ 是一个积性函数，且 $f(p^k)=p^k(p^k-1)$。$n\leqslant10^{10}$。

Min_25 筛的主要思想是把要求的前缀和转化为质数和非质数两部分进行计算。



##### 第一部分

对于质数部分，我们定义以下函数：
$$
g(n,j)=\sum\limits_{i=2}^n[i\ \text{is a prime or}\ \text{minp}(i)>p_j]i^k
$$
其中，$p_j$ 表示第 $j$ 个质数，$\text{minp}(i)$ 表示 $i$ 的最小质因子。翻译成中文就是对所有质数和最小质因子大于第 $j$ 个质数的 $k$ 次幂求和。

这里需要注意，如果我们求的 $f(p)$ 是一个多项式，就拆成单项式。比如这题就是 $p^2-p$，那么我们就计算 $g_1$ 和 $g_2$ 分别代表一次项的和以及二次项的和，这里先不管系数，会在后面算上。

我们考虑计算 $g(n,j)$，这是一个比较明显的可以递推的式子，于是我们尝试从 $g(n,j-1)$ 递推到 $g(n,j)$。

发现 $g(n,j-1)$ 和 $g(n,j)$ 实际上只差了最小质因子为 $p_j$（不包括 $p_j$ 本身）的函数值，所以我们只需要减掉这些多出来的值就可以了，下面先给出式子：
$$
g(n,j)=g(n,j-1)-p_j^k\left(g(\frac{n}{p_j},j-1)-g(p_{j-1},j-1)\right)
$$
注意一下这里除法为了美观没有写取整。我们发现 $i^k$ 是一个完全积性函数，所以对于所有最小质因子为 $p_j$ 的数，我们都可以提一个 $p_j$ 出来而且不需要管是否互质（也就是剩下的仍有 $p_j$ 这个因子），然后剩下的数一定小于等于 $\frac{n}{p_j}$ 且最小质因子仍大于等于 $p_j$，所以就是 $g(\frac{n}{p_j},j-1)$。然后发现所有小于 $p_j$ 的质数都被多减掉了，所以再用 $g(p_{j-1},j-1)$，即所有小于等于 $p_{j-1}$ 的质数的幂次和。

我们注意到小于等于 $n$ 的合数，它的最小质因子一定小于等于 $\sqrt n$，即如果 $p_j>\sqrt n$ 那么 $g(n,j)=g(n,j-1)$，所以我们只需要枚举小于等于 $\sqrt n$ 的质数。然后我们发现 $g(p_{j-1},j-1)$ 求的就是所有小于等于 $p_{j-1}$ 的质数的幂次和，而且 $p_{j-1}$ 是小于等于 $\sqrt n$ 的。所以我们一开始线性筛到 $\sqrt n$ 求出每个质数的这个东西，我们设它为 $sp(j-1)$。然后对于 $1$ 到 $n$ 的 $k$ 次方和，也即是 $g(n,\text{maxp}(n))$，其中 $p_{\text{maxp}(n)}$ 是小于等于 $n$ 的最大质数。

但是这样枚举量还是太大，我们发现一个很重要的式子：$\lfloor\frac{\lfloor\frac{n}{a}\rfloor}{b}\rfloor=\lfloor\frac{n}{ab}\rfloor$。所以所有能用到的第一个数值都形如 $\lfloor\frac{n}{a}\rfloor$，而众所周知这样的数只有 $O(\sqrt n)$ 个，所以我们只需要求出这样的 $g$ 就可以了。具体实现因为下标还是很大，用 `map` 和 `unordered_map` 都比较慢。根据那个 $O(\sqrt n)$ 的证明，我们手动离散化一下：记 `id1[x]` 为 $x$ 离散化的下标，`id2[x]` 为 $\lfloor\frac{n}{x}\rfloor$ 的下标，可以看代码。

这一部分的复杂度是 $O(\frac{n^{\frac{3}{4}}}{\log n})$ 的。



##### 第二部分

接下来，我们计算所有数的和，记 $s(n,j)$ 为 $\sum\limits_{i=2}^n[\text{minp}(i)>j]f(i)$，即所有最小质因子大于 $p_j$ 的 $f$ 的和。

我们依旧尝试递推，首先，我们把所有大于 质数的函数和 $\sum g(n,\text{maxp}(n))-sp(j)$ 算上（这里带上系数，比如板子题就是 $g2(n,\text{maxp}(n))-sp2(j)-(g1(n,\text{maxp}(n))-sp1(j))$ ，那么剩下合数部分枚举提出一个最小质因子，先看式子：
$$
s(n,j)=\sum(g(n,\text{maxp}(n))-sp(j))+\sum\limits_{c>j,p_c^e\leqslant n}f(p_c^e)\left(s(\frac{n}{p_c^e},c)+[e\not=1]\right)
$$
因为这一次并不是完全积性函数了，所以我们要一次把最小质因子提全，这样的话剩下的最小质因子都大于 $p_c$，然后因为我们没算 $1$，所以当 $e\not=1$ 的时候 $f(p_c^e)$ 没有算进去，当 $e=1$ 时会在前面质数部分算到。

则 $s(n,0)+f(1)$ 即为答案。这里直接递归计算，不需要记忆化。

这一部分的复杂度据说是 $O(n^{1-\epsilon})$ 的，即大于任何一个 $O(n^k),k<1$，但是常数很小。



代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll const p=1e9+7,inv2=500000004,inv6=166666668;
ll n,pr[100005],cnt,sp1[100005],sp2[100005],tot,bas[300005],g1[300005],
g2[300005],sqr;
int id1[100005],id2[100005];
bool flag[100005];
inline ll mod(ll const &x){return x>=p?x-p:x;}
ll s(ll i,int j)
{
    if(pr[j]>=i)return 0;
    int t=(i<=sqr)?id1[i]:id2[n/i];
    if(sp1[j]<0||sp2[j]<0)exit(-1);
    ll res=(g2[t]-sp2[j]-(g1[t]-sp1[j])+p+p)%p;//part1:质数部分
    for(int c=j+1;c<=cnt&&pr[c]*pr[c]<=i;c++)//part2 注意这里依旧只需要消去 sqrti 的最小质因子
    {
        ll now=pr[c];
        for(int e=1;now<=i;e++,now*=pr[c])
        {
            ll tmp=now%p;
            res=(res+tmp*(tmp-1+p)%p*(s(i/now,c)+(int)(e!=1)))%p;
        }
    }
    return res;
}
int main()
{
    scanf("%lld",&n);
    sqr=sqrt(n);
    for(ll i=2;i<=sqr;i++)//get prime
    {
        if(!flag[i])pr[++cnt]=i;
        for(int j=1;j<=cnt&&i*pr[j]<=sqr;j++)
        {
            flag[i*pr[j]]=1;
            if(!(i%pr[j]))break;
        }
    }
    for(int i=1;i<=cnt;i++)//计算sp
        sp1[i]=mod(sp1[i-1]+pr[i]),
        sp2[i]=mod(sp2[i-1]+pr[i]*pr[i]%p);
    for(ll l=1,r;l<=n;l=r+1)
    {//计算 g(x,0)，因为 g(n,j) 总是由 g(xxx,j-1) 推出而且后面只需要 g(n,maxp(n)) 所以滚动掉一维
        r=n/(n/l);
        bas[++tot]=n/l;//这一次计算 g(n/l,0) 也就是 2 到 n/l 的幂次和
        g1[tot]=bas[tot]%p;//因为减少取模所以暂时借用一下这个数
        g2[tot]=(g1[tot]*(g1[tot]+1)%p*(2*g1[tot]+1)%p*inv6+p-1)%p;
        g1[tot]=mod((g1[tot]+1)*g1[tot]%p*inv2%p+p-1);
        if(bas[tot]<=sqr)id1[bas[tot]]=tot;
        else id2[l]=tot;//此时一定有 l=r
    }
    for(int j=1;j<=cnt;j++)//为了和写的式子一样换了一下内外层变量
        for(int i=1;i<=tot&&pr[j]*pr[j]<=bas[i];i++)//递推 g(bas[i],j)
        {
            ll t=bas[i]/pr[j];
            t=(t<=sqr)?id1[t]:id2[n/t];//找到 bas[i]/pr[j] 对应的下标
            g1[i]=mod(g1[i]-pr[j]*(g1[t]-sp1[j-1]+p)%p+p);
            g2[i]=mod(g2[i]-pr[j]*pr[j]%p*(g2[t]-sp2[j-1]+p)%p+p);
        }
    printf("%lld",mod(s(n,0)+1));
    return 0;
}
```



---

## 作者：zimindaada (赞：4)

[博客食用更佳](https://www.cnblogs.com/zimindaada/p/13791651.html)

# Min_25筛学习笔记

Min_25筛可以用来求解一类$f(n)$的前缀和，其中$f$是积性函数，$f(P)$是关于质数$P$的低阶多项式，且$\forall k\in N^+,f(P^k)$可以通过某些方式快速求解。​

## 理论部分

**首先我们求解$\sum_{i=1}^n [i \in P]f(i)$。**

首先由于$f(P) $是多项式，所以我们可以把$f(P)$的每一项拆开来。

我们令$g_{n,j} = \sum_{i=1}^n [i \in P  \space or \space MinFactor(i) > P_j ]i^k$，其中$MinFactor(i)$为$i$的最小质因子（后简写成$MF$），$P$为质数集，$P_j$为第$j$个质数。由定义可以得到$g_{n,|P|}$即为我们所求,$g_{n,0} = \sum_{i=2}^{n}i^k$。

那么我们该怎么转移呢？

我们分类考虑一下。如果$P_j^2 > n$，那么就不存在$MF(i) > P_j$这条限制了，毕竟不存在一个合数有大于$\sqrt n$的质因子。

如果$P_j^2 \leq n$，则由于$g_{n,j}$所囊括的被计算$i^k$的$i$必定是$g_{n,j-1}$所囊括的的一个子集，所以$g_{n,j} = g_{n,j-1}-\Delta$。

具体考虑$\Delta$所包含的东西。容易发现$g_{n,j}$所没有包含的，而$g_{n,j-1}$所包含的就是最小质因子恰好等于P_j的。$∴\Delta = \sum_{i=1}^n [MF(i)=p_j]i^k =\sum_{i=1}^{\lfloor\frac{n}{P_j}\rfloor}[MF(i)\geq p_j] i^k \cdot P_j^k =P_j^k\cdot\sum_{i=1}^{\lfloor\frac{n}{P_j}\rfloor}[MF(i)=p_j]i^k=P_j^k\cdot(g_{\lfloor\frac{n}{P_j}\rfloor,j-1}-\sum_{i=1}^{j-1}[i\in P]i^k)$

把$f$的那些各个项合在一起，得到转移方程为：

$g_{n,j}=\begin{cases} g_{n,j-1}&,P_j>\sqrt n\\ g_{n,j-1}-f(P_j)\times(g_{\lfloor \frac{n}{P_j}\rfloor,j-1}-\sum_{i=1}^{j-1} f(P_i))&,P_j\le \sqrt n \end{cases}$

其中最后的质数前缀和可以在筛质数的时候顺带处理，复杂度不计。

在整完了质数部分的答案后我们就可以合起来，**考虑整体的答案了**。

我们令$S_{n,j}=\sum_{i=1}^n[MF(i)>P_j]f(i)$，则由定义有$ans = S_{n,0}+f(1)$，则

$S_{n,j} = (g_{n,|P|} - \sum_{i=1}^j P_i) + (\sum_{k=j+1}^{P_k\leq \sqrt n} \sum_{e=1}^{P_k^e \leq n}S_{n,k+1} + f(p_k^{e+1})) = (g_{n,|P|}-\sum_{i=1}^j P_i) + (\sum_{k=j+1}^{P_k\leq \sqrt n} \sum_{e=1}^{P_k^e \leq n}f(p_k^e)\cdot S_{\lfloor\frac{n}{p_k^e}\rfloor,k+1} + f(p_k^{e+1}))$

（第一个式子能倒腾到第二个是因为$f(p_k^e)$与$S_{\lfloor\frac{n}{p_k^e}\rfloor,k+1}$互质）

第二个式子第一个括号内的是前文中的质数部分的和，第二个括号内的则是和数部分的和。

第二个括号内的第一个$\Sigma$相当于在枚举最小质因子，第二个则是在枚举最小质因子的指数。这个$S_{\lfloor\frac{n}{p_k^e}\rfloor,k+1}$是个递归，由于我们不可能从后面的东西推前面，所以我们枚举他的最小质因子和指数，然后只需要考虑除完之后剩下部分的答案就好了，即$\lfloor\frac{n}{p_k^e}\rfloor$。因为最小质因数已经被除完，所以剩下部分中不能再含有最小质因数，所以我们递归下去的部分要考虑的最小质因子门槛要提高，即$k+1$。

同时，为了补上所有被筛掉的$p_k^e $类的合数，我们要把他们的值加回去，即式子最后的$f(p_k^{e+1}))$。

然而，我们看到，光是推这个$g$的时空复杂度，貌似是$O(n|P|)$的，这很明显无法被接受~~比暴力还慢的屑算法有什么存在的必要吗~~，所以说我们在实际的代码中肯定需要一些优化。

## 代码实现部分

首先我们看到$g_{n,j}$在 $j\leq \sqrt n$的递推那里，即$g_{n,j}=g_{n,j-1}-f(P_j)\times(g_{\lfloor \frac{n}{P_j}\rfloor,j-1}-\sum_{i=1}^{j-1} f(P_i))$。我们可以看出，

1. 从$j$的角度看，$g_{n,j}$都是从$g_{x,j-1}$转移来的；

2. 从$n$的角度看，$g_{n,j}$都是从$g_{\lfloor \frac{n}{P_j}\rfloor, y}$转移来的；

   这意味着什么呢？

从第一点看，我们可以压掉第二维数组。

从第二点看，我们不需要求出所有的$g_{x}$，只需要求$g_{\lfloor \frac{n}{x}\rfloor}$。由整除分块的知识得到，这个东西只有可能有$\sqrt n$种取值。于是时间复杂度降到了$O(\sqrt n \times |P|) < O(n)$（因为预处理的质数只用到$\sqrt n$就行）。

但是由于N很大，所以我们光把下标变成$\lfloor \frac{n}{x}\rfloor$不够，还要再离散化。具体的，我们把$\lfloor \frac{n}{x}\rfloor > \sqrt n$和$\lfloor \frac{n}{x}\rfloor \leq \sqrt n$两种分成两类编号来“离散化”，这样子就把空间复杂度压下去了。

由于在$g$的转移方程中我们是把各个质因子拆开来想的，所以在代码里面也得这么做。具体到下面的代码就是$g1$和$g2$，分别代表一次项和二次项。

尽管洛谷的模板题不需要特殊考虑2这个唯一的偶质数，但是在有些题比如[LOJ6053 简单的函数](https://loj.ac/problem/6053)就要考虑到。

时间复杂度为$O(n^{1-\epsilon})$，一说$O(\frac{n^{\frac{3}{4}}}{\log n})$，反正我也不会证QAQ

### 代码（ [洛谷模板（P5325）](https://www.luogu.com.cn/problem/P5325) ）

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
namespace ztd{
    using namespace std;
    typedef long long ll;
    template<typename T> inline T read(T& t) {//fast read
        t=0;short f=1;char ch=getchar();double d = 0.1;
        while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
        while (ch>='0'&&ch<='9') t=t*10+ch-'0',ch=getchar();
        if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}
        t*=f;
        return t;
    }
}
using namespace ztd;
const int maxn = 1e6+7;
const int mod = 1e9+7;
const ll INV6 = 166666668;//预处理6的逆元
ll n, sqrn;
inline ll f(ll x){//题面的f函数，其定义域只有prime^k
	x %= mod;
	return x*(x-1)%mod;
}
ll prime[maxn], sump1[maxn], sump2[maxn], pcnt;
//sump1和sump2分别是质数的前缀和以及二次前缀和(2^2+3^2+5^2……)
bool vis[maxn];
inline void preprocess_prime(int uplimit){//线性筛筛质数
    for(int i = 2; i <= uplimit; ++i){
        if(!vis[i]){
        	prime[++pcnt] = i;
        	sump1[pcnt] = (sump1[pcnt-1]+i) % mod;
        	sump2[pcnt] = (sump2[pcnt-1]+1ll*i*i%mod) % mod;
        } 
        for(int j = 1; j <= pcnt && i*prime[j] <= uplimit; ++j){
            vis[i*prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}

ll g1[maxn], g2[maxn], match1[maxn], match2[maxn], w[maxn], tot;
//g1,g2即上文所说， match1和match2和w就是上面所说的离散化了。
inline void preprocess_g(){//预处理g和离散化
	ll tmp;
	for(ll l = 1, r = 0; l <= n; l = r+1){
		r = n/(n/l); ++tot;
		w[tot] = n/l;
		if(w[tot] < sqrn) match1[n/l] = tot;
		else match2[n/(n/l)] = tot;
		tmp = w[tot] % mod;
		g1[tot] = tmp * (tmp+1) / 2 % mod-1;
		g2[tot] = tmp * (tmp+1) % mod * (tmp*2+1) % mod * INV6 % mod - 1;
	}
}
inline void process_g(){//g的递推
	for(int i = 1; i <= pcnt && prime[i]*prime[i] <= n; ++i){
		for(int j = 1; j <= tot && 1ll*prime[i]*prime[i] <= w[j]; ++j){
			ll pmt = w[j]/prime[i];
			ll tmp = (pmt >= sqrn) ? (match2[n/pmt]) : (match1[pmt]);
			g1[j] = (g1[j] - prime[i] * (g1[tmp]-sump1[i-1]+mod) % mod  % mod + mod) % mod;
			g2[j] = (g2[j] - prime[i]*prime[i]%mod * (g2[tmp]-sump2[i-1]+mod) % mod + mod) % mod;
		}
	}
}
ll S(ll N, ll y){//最后求答案的
	if(prime[y] > N) return 0;
	ll k = (N >= sqrn) ? (match2[n/N]) : (match1[N]);
	ll prans = (g2[k]-g1[k]+mod - (sump2[y-1]-sump1[y-1])+mod) % mod;//指质数方面的结果
	ll cpans = 0;//合数方面的结果
	for(int i = y; i <= pcnt && 1ll * prime[i]*prime[i] <= N; ++i){
		for(ll pk = prime[i]; prime[i]*pk <= N; pk *= prime[i]){
			cpans = (cpans + (f(pk) * S(N/pk, i+1) % mod + f(prime[i]*pk)) % mod) %mod;
		}
	}
	return (prans+cpans) % mod;
}
signed main(){
    read(n);  sqrn = sqrt(n);
    preprocess_prime(maxn-5);
    preprocess_g();
    process_g();
    cout << (S(n,1) + 1) % mod << '\n';//这道题定义了f(1)=1
    return 0;
}
```

P.S.1:感谢[这位](https://www.cnblogs.com/cjyyb/p/9185093.html)，[这位](https://www.cnblogs.com/p-b-p-b/p/10807098.html)，[和这位](https://www.cnblogs.com/AThousandMoons/p/10827172.html)dalao们的题解 ，我是靠拜读这些大佬的题解才勉强搞懂的QAQ

P.S.2:如果日语水平好的可以去攻读[min25本人的博客](https://min-25.hatenablog.com/entry/2018/11/11/172216)

---

## 作者：w33z8kqrqk8zzzx33 (赞：2)

题意：定 $f(n)$ 为积性函数并且

$$f(p^k)=p^{2k}-p^k$$

求 $f(n)$ 的前缀和。

---

我们先弱化一下问题，如何统计 $f(n)$ 在前 $p$ 个质数的前缀和？

观察到 $f(n)$ 在质数幂处为多项式，考虑对函数逐项统计前缀和。那么我们本质想求

$$S(n)=\sum_{i=1}^n[i\in\mathbb P]i^T$$

其中 $\mathbb{P}(i)$ 为 $i$ 的最小质因子。发现随着 $\mathbb P(i)$ 的增大，更多 $i^T$ 会被 “筛” 走。设 $p_i$ 为第 $i$ 质数，于是考虑定义

$$S(n,j)=\sum_{i=1}^n[i\in\mathbb P\lor\mathbb P(i)>p_j]i^T$$

当 $j\rightarrow\infty$ 则 $\max(n:S(n,j)=S(n))\rightarrow\infty$。

从定义可得边界：

$$S(n,0)=\sum_{i=2}^ni^T$$

考虑如何从 $j-1$ 转移到 $j$。筛走的合数必须有最大质因数 **等于** $p_j$。则

$$S(n,j)=S(n,j-1)-p_j^T(S(\frac{n}{p_j},j-1)-S(p_{j-1},j-1))$$

其中 $S(n,j-1)$ 为原有的质数或者合数贡献；$S(\frac{n}{p_j},j-1)-S(p_{j-1},j-1)$ 为这个东西

$$\sum_{i=1}^n[\mathbb P(i)>p_j]i^T$$

注意，我们必须减去 $[i\in\mathbb P]$ 的贡献才能真保证筛走的最小质因子为 $p_j$。

通过合并若干个 $T$ 的 $S$ 值，可以得到 $f$ 在质数处的前缀和。

于是我们现在可以计算 $S(n)$ 任意处的值，考虑如何用来计算答案。先假设 $1$ 不存在。

$$\sum_{i=2}^nf(i)=\sum_{i=2}^n[i\in\mathbb P]f(i)+\sum_{i=2}^n[i\notin\mathbb P]f(i)$$

我们可以枚举合数里的最小质因子：

$$\sum_{i=2}^nf(i)=\sum_{i=2}^n[i\in\mathbb P]f(i)+\sum_{p\in\mathbb P}\sum_{h=2}f(p^h)\sum_{j=1,\mathbb P(j)>p}^{\frac{n}{p^h}}f(j)$$

现在再次考虑 dp，仍然按照最小质因子大于 $p_j$ 进行计算。定

$$R(n,j)=\sum_{i=2}^n[\mathbb P(i)>p_j]f(i)$$

我们希望求 $R(n,0)$，其中边界情况为 $R(n,j)=0\iff p_j>n$

则自然有

$$R(n,j)=\sum_{i=p_j+1}^n[i\in\mathbb P]f(i)+\sum_{p\in\mathbb P\cup[p_j+1,\infty)}^n\sum_{h=1}f(p^h)\sum_{i=1+[h=1]}^{\frac{n}{p^h}}[\mathbb P(i)>p]f(i)$$

其中必须有 $i=1+[h=1]$ 而不是 $i=1$，因为如果 $h=1$ 不得算 $i=1$ 的贡献（否则 $ip^h$ 为质数，已经被左边贡献计算），如果 $h\neq 1$ 必须计算（否则 $ip^h$ 是合数但是没被算上）。

我们也必定有 $[\mathbb P(i)>p]$，因为已经计算上 $i$ 里 $p$ 当质因子的整体贡献，下一个质因子不得含有 $p$。

利用 $R(n,j)$ 表示：

$$R(n,j)=\sum_{i=p_j+1}^n[i\in\mathbb P]f(i)+\sum_{r=j+1}\sum_{h=1}f(p^h_r)\sum_{i=1+[h=1]}^{\frac{n}{p_r^h}}[\mathbb P(i)>p_r]f(i)$$
$$R(n,j)=\sum_{i=p_j+1}^n[i\in\mathbb P]f(i)+\sum_{r=j+1}\sum_{h=1}f(p^h_r)(R(\frac{n}{p^h_r},r)+[h\neq 1])$$
$$R(n,j)=S(n)-S(p_j)+\sum_{r=j+1}\sum_{h=1}f(p^h_r)(R(\frac{n}{p^h_r},r)+[h\neq 1])$$

仔细观察 $n$ 永远为 $N/x$ 的形式，然后只有 $O(\sqrt N)$ 个本质不同的 $N/x$，于是处理 $R$ 和 $S$ 的时候只在这些处计算。

再仔细观察发现 $np_j\le N$，得到 $p_j\le O(\sqrt N)$，可以预处理 $S(p_j)$。

做完啦！

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) { *s = __c; } *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) { x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; } return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) { qu[++ qr] = x % 10 + '0',  x /= 10; } while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair
 
using ll=long long;
using pii=pair<int, int>;
#define int ll
const int MOD = 1000000007;

const int msqn = 100100;
bool isc[msqn+5];
ll ps1[msqn+5], ps2[msqn+5];
int primes[10000]; int prc, c;
void sieve(int M) {
	isc[0]=isc[1]=1;
	iter(i, 2, M+1) {
		if(!isc[i]) {
			primes[++prc] = i;
			ps1[prc] = (ps1[prc-1] + i) % MOD;
			ps2[prc] = (ps2[prc-1] + 1ll * i * i) % MOD;
		}
		if(!(i&1)&&(i<<1)<=M) {
			isc[i<<1] = 1;
			continue;
		}
		for(register int j=1; j<=prc; j+=5) {
			if(primes[j] * i > M+1) break;
			isc[primes[j] * i] = 1;
			if(!(i % primes[j]) || !primes[j+1] || (primes[j+1] * i > M+1)) break;
			isc[primes[j+1] * i] = 1;
			if(!(i % primes[j+1]) || !primes[j+2] || (primes[j+2] * i > M+1)) break;
			isc[primes[j+2] * i] = 1;
			if(!(i % primes[j+2]) || !primes[j+3] || (primes[j+3] * i > M+1)) break;
			isc[primes[j+3] * i] = 1;
			if(!(i % primes[j+3]) || !primes[j+4] || (primes[j+4] * i > M+1)) break;
			isc[primes[j+4] * i] = 1;
		}
	}
}

constexpr int threeI = 333333336;

namespace PCF {
	ll ans1[2*msqn+5], ans2[2*msqn+5], ind1[2*msqn+5], ind2[2*msqn+5], w[2*msqn+5], tot = 0, sqr, NN;
	void init(ll n) {
		sqr = sqrt(n);
		tot = 0;
		for(ll l = 1, r; l <= n; l = r + 1) {
			r = n / (n / l);
			w[++tot] = n / l;
			ans1[tot] = w[tot] % MOD;
			ans2[tot] = ((ans1[tot] * (ans1[tot] + 1) / 2 % MOD) * (2 * ans1[tot] + 1) % MOD * threeI + MOD - 1) % MOD;
			ans1[tot] = ((ans1[tot] * (ans1[tot] + 1) / 2) + MOD - 1) % MOD;
			if(n / l <= sqr) ind1[n / l] = tot;
			else ind2[r] = tot;
		}
		rep1(i, prc)
			for(int j = 1; j <= tot && 1ll * primes[i] * primes[i] <= w[j]; j++) {
				ll v = w[j] / primes[i];
				ll k = (v <= sqr) ? ind1[v] : ind2[n / v];
				ans1[j] = (MOD + ans1[j] - primes[i] * (MOD + ans1[k] - ps1[i-1]) % MOD) % MOD;
				ans2[j] = (MOD + ans2[j] - primes[i] * primes[i] % MOD * (MOD + ans2[k] - ps2[i-1]) % MOD) % MOD;
				assert(0 <= ans1[j] && ans1[j] < MOD);
				assert(0 <= ans2[j] && ans2[j] < MOD);
			}
		NN = n;
	}
	ll S(ll n, ll x) {
		if(primes[x] >= n) return 0;
		ll k = (n <= sqr) ? ind1[n] : ind2[NN / n];
		ll ans = (ans2[k] - ans1[k] + MOD - ps2[x] + ps1[x] + MOD) % MOD;
		for(int i = x+1; i <= prc && primes[i] * primes[i] <= n; i ++ ) {
			ll pe = primes[i];
			for(int e = 1; pe <= n; e++, pe = pe * primes[i]) {
				ll v = pe % MOD;
				ans = (ans + v * (v - 1) % MOD * (S(n/pe, i) + (e != 1))) % MOD;
			}
		}
		return ans;
	}
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    sieve(msqn);
    ll n; gi(n);
    assert(n <= (ll)(1e10+1));
    PCF::init(n);
    print((PCF::S(n, 0) + 1) % MOD); 
}
```

---

## 作者：Spasmodic (赞：2)

注意到 $f(p^c)$ 是关于 $p$ 的项数较小的多项式，可以使用 Min_25 筛。

[这里是 Min_25 筛教程](https://www.luogu.com.cn/blog/Othinus-blog/min25-shai-xue-xi-bi-ji)

---

题解被毙了 理由是无意义内容过多 所以把文章贴一下好了

## 0.定义
定义 $x/y=\lfloor\frac{x}{y}\rfloor$。

定义 
$$\operatorname{isprime}(n)=\begin{cases}1&n\ prime\\0&otherwise\end{cases}$$
定义 $p_k$ 为第 $k$ 个质数，且 $p_0=1$。

定义 $\operatorname{lpf}(n)=\min\{p|[p|n]\}$。
## 1.算法
min_25 筛可以在 $O(\frac{n^\frac{3}{4}}{\log n})$ 或者 $O(n^{1-\epsilon})$时间内计算出积性函数前缀和问题。

要求：$f(p^c)$ 是关于 $p$ 的项数较少的多项式，可以快速求值。

考虑 dp。设
$$F_{prime}(n)=\sum_{2\le p\le n}f(p)$$
$$F_k(n)=\sum_{i=2}^{n}f(i)[p_k\le \operatorname{lpf}(i)]$$
枚举 $i$最小质因子，有：
$$
\begin{aligned}F_k(n)&=\sum_{i=2}^{n}f(i)[p_k\le \operatorname{lpf}(i)]\\
&=\sum_{i\ge k,p_i^2\le n}\sum_{c\ge 1,p_i^c\le n}f(p_i^c)([c>1]+F_{i+1}(n/p_i^c))+\sum_{i\ge k,p_i\le n}f(p_i)\\
&=\sum_{i\ge k,p_i^2\le n}\sum_{c\ge 1,p_i^c\le n}f(p_i^c)([c>1]+F_{i+1}(n/p_i^c))+F_{prime}(n)-F_{prime}(p_{k-1})\\
&=\sum_{i\ge k,p_i^2\le n}\sum_{c\ge 1,p_i^{c+1}\le n}(f(p_i^c)F_{i+1}(n/p_i^c)+f(p_i^{c+1}))+F_{prime}(n)-F_{prime}(p_{k-1})\\
\end{aligned}
$$
最后一步是因为
$$\sum_{c\ge 1,p_i^c\le n}f(p_i^c)([c>1]+F_{i+1}(n/p_i^c))$$
$$=\sum_{c\ge 1,p_i^c\le n}f(p_i^c)[c>1]+\sum_{c\ge 1,p_i^c\le n}f(p_i^c)F_{i+1}(n/p_i^c)$$
而因为对于满足 $p_i^c\le n<p_i^{c+1}$ 的 $c$，有 $1\le n/p_i^c<p_i<p_{i+1}$，所以 $F_{i+1}(n/p_i^c)=0$，所以
$$=\sum_{c\ge 1,p_i^{c+1}\le n}f(p_i^{c+1})+\sum_{c\ge 1,p_i^{c+1}\le n}f(p_i^c)F_{i+1}(n/p_i^c)$$
$$=\sum_{c\ge 1,p_i^{c+1}\le n}(f(p_i^c)F_{i+1}(n/p_i^c)+f(p_i^{c+1}))$$
下面有两种处理方法：

1. 直接按照定义式递推。
2. 从大到小枚举 $p$ ，注意到仅当 $p^2<n$ 时的转移增加值不为 $0$，所以按照递推式后缀和优化即可

下面考虑如何计算 $F_{prime}(n)$。

观察求 $F_k(n)$ 的过程，我们会发现只有 $1,2,\dots,\sqrt n,n/\sqrt n,n/(\sqrt n-1),\dots,n$ 共 $2\sqrt n$ 个数有用。

因为 $f(p)$ 是关于 $p$ 的多项式，按照次数拆分后，我们只要考虑 $f(p)=p^s$ 的情况，于是问题就转化为了：

> 给定 $n,s,g(p)=p^s$，对所有 $m=n/i$，求 $\sum_{p\le m}g(p)$。

设
$$G_k(n)=\sum_{i=1}^{n}[p_k<\operatorname{lpf}(i)\lor \operatorname{isprime(i)}]g(i)$$
对任意合数 $x$，都有 $\operatorname{lpf}\le \sqrt x$，所以所求 $F_{prime}(n)=G_{\lfloor\sqrt n\rfloor}(n)$。

显然有 $G_0(n)=\sum_{i=2}^{n}g(i)$，考虑如何转移。

考虑每部分的贡献：
1. 对于 $n<p_k^2$ 的部分，$G$ 值不变，贡献 $G_{k-1}(n)$。
2. 对于 $p_k^2\le n$ 的部分，被筛掉的数必有质因子 $p_k$，贡献 $-g(p_k)G_{k-1}(n/p_k)$。
3. 对于第二部分，由于 $p_k^2\le n\Leftrightarrow p_k\le n/p_k$，所以有一部分 $\operatorname{lpf}(i)<p_k$ 的 $i$ 被减去，这部分要加回来，即 $g(p_k)G_{k-1}(p_{k-1})$。

所以
$$G_k(n)=G_{k-1}(n)-[p_k^2\le n]g(p_k)(G_{k-1}(n/p_k)-G_{k-1}(p_{k-1}))$$
## 2.复杂度分析
对于 $F_k(n)$ 的计算，可以证明，第一种方法复杂度 $O(n^{1-\epsilon})$，第二种方法复杂度 $O\left(\frac{n^\frac{3}{4}}{\log n}\right)$。

对于 $F_{prime}(n)$ 的计算，可以证明复杂度为 $O\left(\frac{n^\frac{3}{4}}{\log n}\right)$。

## 3.实现
一般来说第一种方法代码难度低，而且数据范围较小时比第二种更快，所以一般采用第一种方法实现。

---

由于使用了第一种方法，所以复杂度不是 $O\left(\frac{n^\frac{3}{4}}{\log n}\right)$，应该是 $O(n^{1-\epsilon})$，反正都是 $O(\text{跑的过})$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1000005,P=1e9+7,inv3=333333336;
ll n,num,cnt,tot,w[N],g1[N],g2[N],pr[N],s1[N],s2[N],ind1[N],ind2[N];
bool vst[N]; 
ll S(ll x,ll y){
    if(pr[y]>=x)return 0;
    ll k=(x<=num?ind1[x]:ind2[n/x]),ret=(g2[k]-g1[k]+P-(s2[y]-s1[y])+P)%P;
    for(ll i=y+1;i<=cnt&&pr[i]*pr[i]<=x;i++)
        for(ll e=1,pe=pr[i],t;pe<=x;e++,pe=pe*pr[i])
            ret=(ret+(t=pe%P)*(t-1)%P*(S(x/pe,i)+(e!=1)))%P;
    return ret%P;
} 
int main(){
    scanf("%lld",&n);
    num=sqrt(n);
    for(ll i=2;i<=num;i++){
        if(!vst[i])pr[++cnt]=i,s1[cnt]=(s1[cnt-1]+i)%P,s2[cnt]=(s2[cnt-1]+i*i)%P;
        for(ll j=1;j<=cnt&&i*pr[j]<=num;j++){
            vst[i*pr[j]]=1;
            if(i%pr[j]==0)break;
        }
    }
    for(ll l=1,r;l<=n;l=r+1){
        r=n/(n/l);
        w[++tot]=n/l;
        g1[tot]=w[tot]%P;
        g2[tot]=g1[tot]*(g1[tot]+1)/2%P*(2*g1[tot]+1)%P*inv3%P-1;
        g1[tot]=g1[tot]*(g1[tot]+1)/2%P-1;
        if(n/l<=num)ind1[n/l]=tot;
        else ind2[r]=tot;
    }
    for(ll i=1;i<=cnt;i++)
        for(ll j=1,k;j<=tot&&pr[i]*pr[i]<=w[j];j++){
            k=(w[j]/pr[i]<=num?ind1[w[j]/pr[i]]:ind2[n/(w[j]/pr[i])]);
            g1[j]-=pr[i]*(g1[k]-s1[i-1]+P)%P;
            g2[j]-=pr[i]*pr[i]%P*(g2[k]-s2[i-1]+P)%P;
            g1[j]=(g1[j]%P+P)%P,g2[j]=(g2[j]%P+P)%P;
        }
    printf("%lld\n",(S(n,0)+1)%P);
    return 0;
}
```

---


# 下降幂多项式转普通多项式

## 题目背景

这是一道模板题


## 题目描述

已知下降幂多项式 $F(x)=\displaystyle\sum_{i=0}^{n-1}a_ix^{\underline{i}}$。

求一个普通多项式 $G(x)=\displaystyle\sum_{i=0}^{n-1}b_ix^i$。

使得 $G(x)=F(x)$。

所有运算均在 $\bmod\ 998244353$ 意义下进行。

## 说明/提示

对于所有数据 $a_i\in\lbrack0,998244353)$。

本题一共 $10$ 个点。

其中 $3$ 个点 $n=2000$。

另外 $7$ 个点 $n=200000$。

## 样例 #1

### 输入

```
3
1 2 1```

### 输出

```
1 1 1```

# 题解

## 作者：warzone (赞：11)

怎么清一色都先想到多项式多点求值/快速插值呀，这不是直接裸的分治 NTT 吗（不解）。  
首先，我们要求的是：$\displaystyle\sum^{n-1}_{i=0} a_ix^{\underline{i}}$，其中 $x^{\underline{i}}=\displaystyle\prod_{j=0}^{i-1}x-j\ $。  
设 $g_{l,r}(x)=\displaystyle\prod_{i=l}^{r-1}x-i,f_{l,r}(x)=\sum_{i=l}^{r-1}a_ig_{l,i}(x)$，显然答案为 $f_{0,n}(x)\ $。  
设 $mid\in(l,r)$，则 $g_{l,r}(x)=g_{l,mid}(x)g_{mid,r}(x),f_{l,r}(x)=f_{l,mid}(x)+f_{mid,r}(x)g_{l,mid}(x)\ $。  

最后，$g_{i,i+1}=x-i,f_{i,i+1}(x)=a_i,g_{i,i}(x)=1,f_{i,i}(x)=0\ $。  

直接分治即可，复杂度 $\Theta(n\log^2n)$。

还有一个小优化：$f_{l,r}(x),g_{l,r}(x)$ 是 $r-l$ 次的，在 $\pmod {x^{2^k}}$ 意义下会刚好多一项。  
考虑到循环卷积的性质，多出来的这一项单独处理，会大大降低常数。  

跑得挺快的代码（3.92s/10.57MB/3.55KB ）
```cpp
//this code is made by warzone
//2021.11.9 16:00
#include<stdio.h>
#include<string.h>
typedef unsigned long long ull;
typedef unsigned int word;
const word mod=998244353,nimod=29;
constexpr ull pow(word a,word b){//快速幂
	word ans=1;
	for(;b;b>>=1){
		if(b&1) ans=1ull*ans*a%mod;
		a=1ull*a*a%mod;
	}
	return ans;
}
#define mx 18
#define mx_ 17
word root[1<<mx],inv[1<<mx],realid[1<<(mx+1)];
word ni[nimod];
struct READ{
	char c;
	inline READ(){//NTT 预处理
		const ull num1=pow(3,(mod-1)>>mx);
		const ull num2=pow(num1,mod-2);
		root[1<<mx_]=inv[1<<mx_]=ni[1]=1;
		ni[2]=pow(2,mod-2),realid[1]=0;
		for(word floor=1,i=2;floor<=mx;++floor){
			ni[(1u<<floor)%nimod]=1ull*ni[(1u<<(floor-1))%nimod]*ni[2]%mod;
			for(;i<1u<<(floor+1);++i)
				realid[i]=(i&1)<<(floor-1)|realid[i>>1];
		}
		for(word i=(1<<mx_)+1;i<1<<mx;++i){
			root[i]=num1*root[i-1]%mod;
			inv[i]=num2*inv[i-1]%mod;
		}
		for(word i=(1<<mx_)-1;i;--i)
			root[i]=root[i<<1],inv[i]=inv[i<<1];
		c=getchar();}
	template<typename type>
	inline READ& operator >>(type& num){//快读
		while('0'>c||c>'9') c=getchar();
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		return *this;
	}
}cin;
#define nttfor(size)								\
	for(word floor=1;floor<(size);floor<<=1)		\
		for(word head=0;head<(size);head+=floor<<1)	\
			for(word i=0;i<floor;++i)//FFT 循环
#define ntt(num,root) [&](){							\
	word num1=num[head|i],num2=num[head|i|floor];		\
    num1+=(num2=1ull*num2*root[i|floor]%mod);   		\
	num[head|i]=num1>=mod? num1-mod:num1;	    		\
	num1-=num2,num1+=mod-num2;                  		\
	num[head|i|floor]=num1>=mod? num1-mod:num1;}()//蝴蝶变换
#define id(size,i) realid[(i)|(size)]//二进制翻转的下标
#define FOR(size) for(word i=0;i<(size);++i)

word eax[1<<mx],ebx[1<<mx],ecx[1<<mx],edx[1<<mx];
word ans[1<<mx],get[1<<mx];
struct poly{//多项式（包含单独处理的位置）
	word *const num,end;
	inline poly(word *const in):
		num(in),end(0){};
	inline poly(const poly &p):
		num(p.num),end(p.end){}
};
inline void cdq(poly& ans,poly& get,const word size,const word id){
	if(size==1){
		ans.end=0,get.end=1;	//f_{i,i+1}(x)=a_i
		get.num[0]=id? mod-id:0;//g_{i,i+1}(x)=x-i
		return;
	}
	poly ans0=ans.num,ans1=ans.num+(size>>1);//f_{l,mid}(x),f_{mid,r}(x)
	poly get0=get.num,get1=get.num+(size>>1);//g_{l,mid}(x),g_{mid,r}(x)
	cdq(ans0,get0,size>>1,id<<1);
	cdq(ans1,get1,size>>1,id<<1|1);
	memcpy(edx,ans0.num,size<<1);
	FOR(size>>1){
		word head=id(size,i);
		eax[head]=ans1.num[i];
		ebx[head]=get0.num[i];
		ecx[head]=get1.num[i];
		head=id(size,size>>1|i);
		eax[head]=ebx[head]=ecx[head]=0;
	}
	const word head=id(size,size>>1);
	eax[head]=ans1.end;
	ebx[head]=get0.end;
	ecx[head]=get1.end;
	nttfor(size) ntt(eax,root),ntt(ebx,root),ntt(ecx,root);
	FOR(size){
		const word head=id(size,i);
		ans.num[head]=1ull*eax[i]*ebx[i]%mod;//f_{l,r}(x)=f_{l,mid}(x)+f_{mid,r}(x)g_{l,mid}(x)
		get.num[head]=1ull*ebx[i]*ecx[i]%mod;//g_{l,r}(x)=g_{l,mid}(x)g_{mid,r}(x)
	}
	nttfor(size) ntt(ans.num,inv),ntt(get.num,inv);
	word num1=ni[size%nimod],num2;
	FOR(size){
		ans.num[i]=1ull*num1*ans.num[i]%mod;
		get.num[i]=1ull*num1*get.num[i]%mod;
	}
	ans.end=1ull*ans1.end*get0.end%mod;
	get.end=1ull*get0.end*get1.end%mod;
	num1=ans.end? mod-ans.end:0;
	num2=get.end? mod-get.end:0;
	ans.num[0]=(num1+ans.num[0])%mod;
	get.num[0]=(num2+get.num[0])%mod;//单独处理末项
	FOR(size>>1) if((ans.num[i]+=edx[i])>=mod)
		ans.num[i]-=mod;//+f_{l,mid}(x)
	if((ans.num[size>>1]+=ans0.end)>=mod)
		ans.num[size>>1]-=mod;
}
int main(){
	word n,size;
	cin>>n;
	for(word i=0;i<n;++i) cin>>ans[i];
	for(size=1;size<n;size<<=1);
	poly p0=ans,p1=get;
	cdq(p0,p1,size,0);
	for(word i=0;i<n;++i) printf("%u ",ans[i]);
	return 0;
}

```

---

## 作者：i207M (赞：7)

# 下降幂多项式

*FFP, Falling Factorial Polynomial*

## Poly to FFP

~~ri，这个卡常~~

先将$x^i$用$S_2$展开为$x^{\underline j}$，然后再用$x^i$展开$S_2$，可以得到一个卷积式子，其中有一项需要多点求值来算。

```cpp
il vector<int> PolytoFFP(const Poly &F)
{
	int n=Size(F);
	vector<int> cha; cha.resize(n);
	for(ri i=0; i<n; ++i) cha[i]=i;
	Poly R=Evaluation(F,cha),T(n);
	for(ri i=0; i<n; ++i) R[i]=mul(R[i],ifac[i]);
	for(ri i=0; i<n; ++i) T[i]=(i&1)?md-ifac[i]:ifac[i];
	Mul(R,T);
	return R.f;
}
```

## FFP to Poly

~~ri，这个更卡常~~

下降幂多项式的点值很好求，是和$e^x$卷积起来的形式，求出$0-(n-1)$的点值后，多项式快速插值回去即可。

由于点值是连续的，所以本来要用洛必达法则+多点求值得到的答案可以直接用阶乘求出来。

```cpp
pair<Poly,Poly> Interpolation2(const int x,const int l,const int r,const vector<int> &Y)
{
	if(l==r) return {{md-l,1},{mul(Y[l],mdinv(Eans[l]))}};
	gm;
	solid ls=Interpolation2(x<<1,l,mid,Y),rs=Interpolation2(x<<1|1,mid+1,r,Y);
	return {ls.fi*rs.fi,ls.fi *rs.se+ls.se*rs.fi};
}
il Poly FFPtoPoly(const vector<int> &F)
{
	int n=Size(F);
	Poly G=ifac; Mul(G,F);
	for(ri i=0; i<n; ++i) G[i]=mul(G[i],fac[i]);
	Eans.resize(n);
	Eans[0]=(n&1)?fac[n-1]:md-fac[n-1];
	for(ri i=1; i<n; ++i) Eans[i]=mul(fac[i],((n-i)&1)?fac[n-i-1]:md-fac[n-i-1]);
	return Interpolation2(1,0,n-1,G.f).se;
}
```

---

## 作者：critnos (赞：5)

感觉平凡。

构造 $n$ 个多项式 $g_{0\dots n-1}$，$g_0=a_0,\forall0<i<n,g_i=\dfrac {a_i}{a_{i-1}}(x-i+1)$。

答案即为 $\sum_{i=0}^{n-1}\prod_{j=0}^i g_j$。分治 NTT 即可。

设 $f_{l\dots r}$ 为 $\prod_{i=l}^r g_i$，$ans_{l\dots r}$ 为区间 $[l,r]$ 的答案。

那么有

$$f_{l\dots r}=f_{l\dots mid}f_{mid+1\dots r}$$

$$ans_{l\dots r}=f_{l\dots mid}ans_{mid+1\dots r}+ans_{l\dots mid}$$

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define lll __int128
using namespace std;
const int G=3,mod=998244353;
const int inv2=mod+1>>1;
const int maxn=1e6;
ull qpow(ull a,int p)
{
    ull mul=1;
    for(;p;p>>=1)
    {
        if(p&1) mul=mul*a%mod;
        a=a*a%mod;
    }
    return mul;
}
ull qpow(ull a,int p,int mod)
{
    ull mul=1;
    for(;p;p>>=1)
    {
        if(p&1) mul=mul*a%mod;
        a=a*a%mod;
    }
    return mul;
}
const int inV=qpow(G,mod-2);
void getmod(int &x)
{
    x+=(x<0)*mod,x-=(x>=mod)*mod;
}
void ntt(int a[],bool fl,int n)
{
    static ull f[maxn],w[maxn];
    static int bt[maxn];
    int i,j,p,l,t;
    for(i=0;i<n;i++)
        bt[i]=(bt[i/2]/2)|((i&1)?n/2:0);
    ull po;
    for(i=0;i<n;i++)
        f[i]=a[bt[i]];
    w[0]=1;
    for(l=1;l<n;l*=2)
    {
        po=qpow(fl?inV:G,(mod-1)/(l*2));
        for(i=1;i<l;i++)
            w[i]=w[i-1]*po%mod;
        for(i=0;i<n;i+=l*2)
            for(j=0;j<l;j++)
                t=w[j]*f[i|l|j]%mod,
                f[i|l|j]=f[i|j]+mod-t,
                f[i|j]+=t;
        if(l==(1<<17))
            for(i=0;i<n;i++)
                f[i]%=mod;
    }
    if(fl)
    {
        po=qpow(n,mod-2);
        for(i=0;i<n;i++)
            a[i]=f[i]%mod*po%mod;
    }
    else 
        for(i=0;i<n;i++)
            a[i]=f[i]%mod;
}
const int mod2=104857601;
void ntt2(int a[],bool fl,int n)
{
    static ull f[maxn],w[maxn];
    static int bt[maxn];
    int i,j,p,l,t,inV=qpow(G,mod2-2,mod2);
    for(i=0;i<n;i++)
        bt[i]=(bt[i/2]/2)|((i&1)?n/2:0);
    ull po;
    for(i=0;i<n;i++)
        f[i]=a[bt[i]];
    w[0]=1;
    for(l=1;l<n;l*=2)
    {
        po=qpow(fl?inV:G,(mod2-1)/(l*2),mod2);
        for(i=1;i<l;i++)
            w[i]=w[i-1]*po%mod2;
        for(i=0;i<n;i+=l*2)
            for(j=0;j<l;j++)
                t=w[j]*f[i|l|j]%mod2,
                f[i|l|j]=f[i|j]+mod2-t,
                f[i|j]+=t;
        if(l==(1<<17))
            for(i=0;i<n;i++)
                f[i]%=mod2;
    }
    if(fl)
    {
        po=qpow(n,mod2-2,mod2);
        for(i=0;i<n;i++)
            a[i]=f[i]%mod2*po%mod2;
    }
    else 
        for(i=0;i<n;i++)
            a[i]=f[i]%mod2;
}
const int mod3=136314881;
void ntt3(int a[],bool fl,int n)
{
    static ull f[maxn],w[maxn];
    static int bt[maxn];
    int i,j,p,l,t,inV=qpow(G,mod3-2,mod3);
    for(i=0;i<n;i++)
        bt[i]=(bt[i/2]/2)|((i&1)?n/2:0);
    ull po;
    for(i=0;i<n;i++)
        f[i]=a[bt[i]];
    w[0]=1;
    for(l=1;l<n;l*=2)
    {
        po=qpow(fl?inV:G,(mod3-1)/(l*2),mod3);
        for(i=1;i<l;i++)
            w[i]=w[i-1]*po%mod3;
        for(i=0;i<n;i+=l*2)
            for(j=0;j<l;j++)
                t=w[j]*f[i|l|j]%mod3,
                f[i|l|j]=f[i|j]+mod3-t,
                f[i|j]+=t;
        if(l==(1<<17))
            for(i=0;i<n;i++)
                f[i]%=mod3;
    }
    if(fl)
    {
        po=qpow(n,mod3-2,mod3);
        for(i=0;i<n;i++)
            a[i]=f[i]%mod3*po%mod3;
    }
    else 
        for(i=0;i<n;i++)
            a[i]=f[i]%mod3;
}
void fkyou(int a[],int b[],int n)
{
    for(int i=0;i<n;i++)
        a[i]=1ll*a[i]*b[i]%mod;
}
void mul(int a[],int b[],int l)
{
    static int cpy[maxn];
    int n,i;
    for(n=1;n<l;n*=2);
    memcpy(cpy,b,n*4);
    ntt(a,0,n),ntt(cpy,0,n);
    for(i=0;i<n;i++)
        a[i]=1ll*a[i]*cpy[i]%mod;
    ntt(a,1,n);
    memset(cpy,0,l*4);
    memset(a+l,0,(n-l)*4);
}
void mul(int a[],int b[],int l,int m)
{
    static int cpy[maxn];
    int n,i;
    for(n=1;n<l*2;n*=2);
    memcpy(cpy,b,m*4);
    ntt(a,0,n),ntt(cpy,0,n);
    for(i=0;i<n;i++)
        a[i]=1ll*a[i]*cpy[i]%mod;
    ntt(a,1,n);
    memset(cpy,0,l*4);
    memset(a+l,0,(n-l)*4);
}
void mul2(int a[],int b[],int l)
{
    static int cpy[maxn];
    int n,i;
    for(n=1;n<l;n*=2);
    memcpy(cpy,b,n*4);
    ntt2(a,0,n),ntt2(cpy,0,n);
    for(i=0;i<n;i++)
        a[i]=1ll*a[i]*cpy[i]%mod2;
    ntt2(a,1,n);
    memset(cpy,0,l*4);
    memset(a+l,0,(n-l)*4);
}
void mul3(int a[],int b[],int l)
{
    static int cpy[maxn];
    int n,i;
    for(n=1;n<l;n*=2);
    memcpy(cpy,b,n*4);
    ntt3(a,0,n),ntt3(cpy,0,n);
    for(i=0;i<n;i++)
        a[i]=1ll*a[i]*cpy[i]%mod3;
    ntt3(a,1,n);
    memset(cpy,0,l*4);
    memset(a+l,0,(n-l)*4);
}
int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
void ginv(int a[],int l)
{
    static int b[maxn],b2[maxn],f[maxn];
    int n,w,i;
    for (n=1;n<l*2;n*=2);
    b[0]=qpow(a[0],mod-2);
    for(w=2;w<=n;w*=2)
    { 
        memcpy(b2,b,w/2*4),memcpy(f,a,w*4);
        ntt(b,0,w*2),fkyou(b,b,w*2);
        ntt(f,0,w*2),fkyou(b,f,w*2);
        ntt(b,1,w*2);
        memset(b+w,0,w*4);
        for(i=0;i<w;i++)
            b[i]=(b2[i]*2-b[i]+mod)%mod;
    }
    memcpy(a,b,l*4);
    memset(b,0,n*2*4);
    memset(b2,0,n*2*4);
    memset(f,0,n*2*4);
}
void der(int a[],int n)
{
    for(int i=1;i<n;i++)
        a[i-1]=1ll*a[i]*i%mod;
    a[n-1]=0;
}
void ber(int a[],int n)
{
    static int inv[maxn];
    int i;
    inv[1]=1;
    for(i=2;i<=n;i++)
        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
    for(i=n;i;i--)
        a[i]=1ll*a[i-1]*inv[i]%mod;
    a[0]=0;
}
void gln(int a[],int l)
{
    static int b[maxn];
    memcpy(b,a,l*4);
    ginv(b,l);
    der(a,l);
    mul(a,b,l);
    ber(a,l-1);
    memset(b,0,l*4);
}
void gexp(int a[],int l)
{
    static int b[maxn],b2[maxn];
    int n,w,i;
    for(n=1;n<l;n*=2);
    b[0]=1;
    for(w=2;w<=n;w*=2)
    {
        memcpy(b2,b,w/2*4),gln(b2,w);
        for(i=0;i<w;i++)
            b2[i]=(a[i]-b2[i]+!i+mod)%mod;
        mul(b,b2,w);
    }
    memcpy(a,b,l*4);
    memset(b,0,n*4),memset(b2,0,n*4);
}
void gsqrt(int a[],int l)
{
    gln(a,l);
    for(int i=0;i<l;i++)
        a[i]=1ll*a[i]*inv2%mod;
    gexp(a,l);
}
void gqpow(int a[],int l,int k)
{
    gln(a,l);
    for(int i=0;i<l;i++)
        a[i]=1ll*a[i]*k%mod;
    gexp(a,l);
}
void gdiv(int a[],int b[],int n,int m)
{
    static int a2[maxn],b2[maxn];
    int len=n-m+1,i;
    reverse(b,b+m);
    memcpy(b2,b,len*4);
    reverse(b,b+m);
    reverse(a,a+n);
    memcpy(a2,a,len*4);
    reverse(a,a+n);
    ginv(b2,len);
    mul(b2,a2,len);
    reverse(b2,b2+len),
    mul(b,b2,n);
    for(i=0;i<m-1;i++)
        b[i]=(a[i]-b[i]+mod)%mod;
    memcpy(a,b2,len*4);
    memset(a+len,0,n-len<<2);
    memset(b+m-1,0,len*4); 
}
int fac[maxn],inv[maxn];
void init(int n)
{
    int i;
    fac[0]=1;
    for(i=1;i<=n;i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=qpow(fac[n],mod-2);
    for(i=n;i>=1;i--)
        inv[i-1]=1ll*inv[i]*i%mod;
}
const int modinv[]={590430925,656386,54835507};
lll CRT(int a[],int mod[])
{
    int i;
    lll mul=1,ans=0;
    for(i=0;i<3;i++)
        ans=(ans+mul/mod[i]*a[i]*modinv[i])%mul;
    return ans;
}
void gmul(int a[],int b[],int n,int MOD)
{
    int mod[]={998244353,104857601,136314881},i,j,c[3];
    static int res[3][maxn];
    memcpy(res[0],a,n*4),
    mul(res[0],b,n);
    memcpy(res[1],a,n*4),
    mul2(res[1],b,n);
    memcpy(res[2],a,n*4),
    mul3(res[2],b,n);
    for(i=0;i<n;i++)
    {
        for(j=0;j<3;j++) c[j]=res[j][i];
        a[i]=CRT(c,mod)%MOD;
    }
}
int a[maxn];
int t[maxn*20],*f[maxn],*top=t;
int t2[maxn*20],*f2[maxn],*top2=t2;
#define ls w<<1
#define rs ls|1
void solve(int w,int l,int r)
{
	if(l==r) 
	{
		f[w]=top,f2[w]=top2;
		if(l)
			f[w][1]=f2[w][1]=1ll*a[l]*qpow(a[l-1],mod-2)%mod,f[w][0]=f2[w][0]=(mod-f[w][1])*(l-1ll)%mod;
		else f[w][0]=f2[w][0]=a[0];
		top+=3,top2+=3;
		return;
	}
	int mid=l+r>>1;
	solve(ls,l,mid),solve(rs,mid+1,r);
	f[w]=top,f2[w]=top2;
	memcpy(f[w],f[ls],(mid-l+2)*4);
	mul(f[w],f[rs],r-l+2,r-mid+1);
	memcpy(f2[w],f[ls],(mid-l+2)*4);
	mul(f2[w],f2[rs],r-l+2,r-mid+1);
	for(int i=0;i<mid-l+2;i++)
		getmod(f2[w][i]+=f2[ls][i]);
	top+=r-l+3,top2+=r-l+3;
}
int main()
{
	int n=read(),i;
	for(i=0;i<n;i++)
		a[i]=read();
	solve(1,0,n-1);
	for(i=0;i<n;i++)
		printf("%d ",f2[1][i]);
}
```


---

## 作者：Rorschachindark (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5393)
# 题目大意
给出一个下降幂多项式$F(x)=\sum_{i=0}^{n-1} a_ix^{\underline{i}}$，求一个普通多项式$G(x)$使得$G(x)=F(x)$。

$n\le 2\times 10^5$
# 思路
一个非常$\texttt {naive}$的想法就是我们直接乘上$e^x$转换成点值$\texttt{EGF}$，然后再多项式快速插值插回去。

同时，我们发现点值是连续的，于是，我们就不需要多项式多点求值和多项式取模了。

最终的时间复杂度为$\Theta(n\log^2n)$。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define SZ(x) ((int)x.size())
#define Int register int
#define mod 998244353
#define ll long long
#define MAXN 2000005

int mul (int a,int b){return 1ll * a * b % mod;}
int dec (int a,int b){return a >= b ? a - b : a + mod - b;}
int add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}
int qkpow (int a,int k){
	int res = 1;for (;k;k >>= 1,a = 1ll * a * a % mod) if (k & 1) res = 1ll * res * a % mod;
	return res;
}
int inv (int x){return qkpow (x,mod - 2);}

typedef vector <int> poly;

int w[MAXN],rev[MAXN];

void init_ntt (){
	int lim = 1 << 19;
	for (Int i = 0;i < lim;++ i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << 18);
	int Wn = qkpow (3,(mod - 1) / lim);w[lim >> 1] = 1;
	for (Int i = lim / 2 + 1;i < lim;++ i) w[i] = mul (w[i - 1],Wn);
	for (Int i = lim / 2 - 1;i;-- i) w[i] = w[i << 1];
}

void ntt (poly &a,int lim,int type){
#define G 3
#define Gi 332748118
	static int d[MAXN];
	for (Int i = 0,z = 19 - __builtin_ctz(lim);i < lim;++ i) d[rev[i] >> z] = a[i];
	for (Int i = 1;i < lim;i <<= 1)
		for (Int j = 0;j < lim;j += i << 1)
			for (Int k = 0;k < i;++ k){
				int x = mul (w[i + k],d[i + j + k]);
				d[i + j + k] = dec (d[j + k],x),d[j + k] = add (d[j + k],x);
			}
	for (Int i = 0;i < lim;++ i) a[i] = d[i] % mod;
	if (type == -1){
		reverse (a.begin() + 1,a.begin() + lim);
		for (Int i = 0,Inv = inv (lim);i < lim;++ i) a[i] = mul (a[i],Inv);
	}
#undef G
#undef Gi 
}

poly operator + (poly a,poly b){
	a.resize (max (SZ (a),SZ (b)));
	for (Int i = 0;i < SZ (b);++ i) a[i] = add (a[i],b[i]);
	return a;
}

poly operator * (poly a,poly b){
	int d = SZ (a) + SZ (b) - 1,lim = 1;while (lim < d) lim <<= 1;
	a.resize (lim),b.resize (lim);
	ntt (a,lim,1),ntt (b,lim,1);
	for (Int i = 0;i < lim;++ i) a[i] = mul (a[i],b[i]);
	ntt (a,lim,-1),a.resize (d);
	return a;
}

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,fac[MAXN],ifac[MAXN];
poly fuck,III,D[MAXN << 2],DR[MAXN << 2];

void divide (int i,int l,int r){
	if (l == r){
		DR[i].resize (2),DR[i][0] = mod - l,DR[i][1] = 1;
		D[i].resize (1),D[i][0] = (n - l) & 1 ? mod - mul (fuck[l],ifac[n - l]) : mul (fuck[l],ifac[n - l]);
		return ;
	} 
	int mid = (l + r) >> 1;divide (i << 1,l,mid),divide (i << 1 | 1,mid + 1,r);
	D[i] = DR[i << 1 | 1] * D[i << 1] + DR[i << 1] * D[i << 1 | 1];
	DR[i] = DR[i << 1] * DR[i << 1 | 1];
}

signed main(){
	init_ntt(),read (n),fuck.resize (n),III.resize (n + 1);
	fac[0] = 1;for (Int i = 1;i <= n;++ i) fac[i] = mul (fac[i - 1],i);
	ifac[n] = inv (fac[n]);for (Int i = n;i;-- i) ifac[i - 1] = mul (ifac[i],i);
	for (Int i = 0;i < n;++ i) read (fuck[i]),III[i] = ifac[i];III[n] = ifac[n];
	fuck = fuck * III,fuck.resize (n + 1);divide (1,0,n);
	for (Int i = 0;i < n;++ i) write (D[1][i]),putchar (' ');putchar ('\n');
	return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：2)

前置：[普通转下降](https://www.luogu.com.cn/blog/220037/solution-p5383)

从普通转下降里面得到了

$$b_k=\sum_{t=0}^k\frac{F(t)}{t!}\frac{(-1)^{k-t}}{(k-t)!}$$

这显然是一个标准的卷积，但是这里面我们只有 $b_k$。

先构造 $\frac{(-1)^{k-t}}{(k-t)!}$ 序列以及乘法逆幂级数，把 $b_k$ 和逆卷积可以得到 $\frac{F(t)}{t!}$ 对应序列。

序列所有元素乘 $t!$ 就可以得到 $n+1$ 个 $(t,F(t))$ 数对，做快速插值即可。


代码：
```cpp
#pragma GCC optimize("-Ofast","-funroll-all-loops","-ffast-math")
#pragma GCC optimize("-fno-math-errno")
#pragma GCC optimize("-funsafe-math-optimizations")
#pragma GCC optimize("-freciprocal-math")
#pragma GCC optimize("-fno-trapping-math")
#pragma GCC optimize("-ffinite-math-only")
#pragma GCC optimize("-fno-stack-protector")
#pragma GCC target ("avx2","sse4.2","fma")
#include <immintrin.h>
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// https://judge.yosupo.jp/submission/5253

struct IO {
  static constexpr size_t buf_size = 1 << 18;
  char buf_in[buf_size], buf_out[buf_size];
  size_t pt_in = 0, pt_out = 0, tail_in = 0;
  char strs[10000 * 4];
  inline size_t num_digits(long long x) {
    if (x >= (long long)1e9) {
      if (x >= (long long)1e18) return 19;
      if (x >= (long long)1e17) return 18;
      if (x >= (long long)1e16) return 17;
      if (x >= (long long)1e15) return 16;
      if (x >= (long long)1e14) return 15;
      if (x >= (long long)1e13) return 14;
      if (x >= (long long)1e12) return 13;
      if (x >= (long long)1e11) return 12;
      if (x >= (long long)1e10) return 11;
      return 10;
    } else {
      if (x >= (long long)1e8) return 9;
      if (x >= (long long)1e7) return 8;
      if (x >= (long long)1e6) return 7;
      if (x >= (long long)1e5) return 6;
      if (x >= (long long)1e4) return 5;
      if (x >= (long long)1e3) return 4;
      if (x >= (long long)1e2) return 3;
      if (x >= (long long)1e1) return 2;
      return 1;
    }
  }
  IO() {
    load();
    for (int i = 0; i < 10000; ++i) {
      int j = i;
      for (int t = 3; t >= 0; --t) {
        strs[i * 4 + t] = j % 10 + '0';
        j /= 10;
      }
    }
  }
  ~IO() { flush(); }
  inline void load() {
    memcpy(buf_in, buf_in + pt_in, tail_in - pt_in);
    size_t width = tail_in - pt_in;
    tail_in = width + fread(buf_in + width, 1, buf_size - width, stdin);
    pt_in = 0;
  }
  inline void flush() {
    fwrite(buf_out, 1, pt_out, stdout);
    pt_out = 0;
  }
  inline void read(char& c) { c = buf_in[pt_in++]; }
  template <class T>
  inline void read(T& x) {
    if (pt_in + 32 > tail_in) load();
    char c;
    do {
      read(c);
    } while (c < '0');
    bool minus = 0;
    if (c == '-') {
      minus = 1;
      read(c);
    }
    x = 0;
    while (c >= '0') {
      x = x * 10 + (c & 15);
      read(c);
    }
    if (minus) x = -x;
  }
  inline void write(char c) { buf_out[pt_out++] = c; }
  template <class T>
  inline void write(T x) {
    if (pt_out > buf_size - 32) flush();
    if (x < 0) {
      write('-');
      x = -x;
    }
    size_t digits = num_digits(x);
    int i;
    for (i = pt_out + digits - 4; i > (int)pt_out; i -= 4) {
      memcpy(buf_out + i, strs + (x % 10000) * 4, 4);
      x /= 10000;
    }
    memcpy(buf_out + pt_out, strs + x * 4 + (pt_out - i), 4 + i - pt_out);
    pt_out += digits;
  }
  inline void write(const char* s) {
    if (pt_out > buf_size - 32) flush();
    for (int i = 0; s[i] != 0; ++i) write(s[i]);
  }
  template <class T>
  inline void writeln(T x) {
    write(x);
    write('\n');
  }
} io;

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, (int)(a))
#define rep1(i, a) iter(i, 1, (int)(a)+1)
#define fi first
#define se second
#define pb push_back
#define intsize (sizeof(int))
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;

typedef unsigned us;
typedef unsigned long long ull;

static char buf[450 << 20];
void* operator new(size_t s) {
	static size_t i = sizeof buf;
	assert(s < i);
	return (void*)&buf[i -= s];
}
void operator delete(void*) {}

template<class T> struct ptr {
	unsigned ind;
	ptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {
		assert(ind < sizeof buf);
	}
	T& operator*() const { return *(T*)(buf + ind); }
	T* get() const { return &**this; }
	T& operator[](int a) const { return (&**this)[a]; }
	explicit operator bool() const { return ind; }
};

namespace poly {
	const int MOD = 998244353;
	const int IMAG = 86583718;
	const int NTTG = 3;
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
// https://www.luogu.com.cn/record/32153077
// zzq orz
#define SZ 524320
ll qp(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%MOD;
		a=a*a%MOD; b>>=1;
	}
	return ans;
}
int getK(int n)
{int s=1; while(s<n) s<<=1; return s;}
us pool[SZ*4] __attribute__ ((aligned(64))),*ptr=pool;
us *p0[SZ],*p1[SZ],*q0[SZ],*q1[SZ];
__attribute__((always_inline)) void bit_flip(us*p,int t)
{
	for(int i=0,j=0;i<t;++i)
	{
		if(i>j) swap(p[i],p[j]);
		for(int l=t>>1;(j^=l)<l;l>>=1);
	}
}
void prep(int n)
{
	static int t=1;
	for(;t<n;t<<=1)
	{
		int g=qp(3,(MOD-1)/(t*2));
		us*p,*q;
		p=p0[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q0[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
		g=qp(g,MOD-2);
		p=p1[t]=ptr; ptr+=max(t,16); p[0]=1;
		for(int m=1;m<t;++m)
			p[m]=p[m-1]*(ull)g%us(MOD);
		bit_flip(p,t);
		q=q1[t]=ptr; ptr+=max(t,16);
		for(int i=0;i<t;++i)
			q[i]=(ull(p[i])<<32)/MOD;
	}
}
typedef unsigned long long ull;
__attribute__((always_inline)) us my_mul(us a,us b,us c)
{
	return b*(ull)a-((ull(a)*c)>>32)*ull(998244353);
}
__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i&a, const __m128i& b)
{
	return _mm_mullo_epi32(a,b);
	/*
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2) 
	__m128i prod   = _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
	*/
}
__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i&a, const __m128i& b)
{
	__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)
	__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)
	__m128i prod02 = _mm_mul_epu32(a, b);                 // (a2*b2,-,a0*b0,-)
	__m128i prod13 = _mm_mul_epu32(a13, b13);             // (a3*b3,-,a1*b1,-)
	__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (a1*b1,a0*b0,-,-) 
	__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (a3*b3,a2*b2,-,-) 
	__m128i prod   = _mm_unpackhi_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)
	return prod;
}
void ntt(us* __restrict__ x,int n)
{
	int t=n;
	for(int m=1;m<n;m<<=1)
	{
		t>>=1;
		us* __restrict__ p=p0[m];
		us* __restrict__ q=q0[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);
					us v=my_mul(xb[j],p[i],q[i]);
					xa[j]=u+v;
					xb[j]=u-v+us(MOD+MOD);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					u=_mm_sub_epi32(u,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u,mm),
					_mm_cmpgt_epi32(m0,u)),mm));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					v=_mm_sub_epi32(my_mullo_epu32(v,p4),
					my_mullo_epu32(my_mulhi_epu32(v,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u,v));
					_mm_storeu_si128((__m128i*)(xb+j),_mm_add_epi32(_mm_sub_epi32(u,v),mm));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					u0=_mm_sub_epi32(u0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u0,mm),
					_mm_cmpgt_epi32(m0,u0)),mm));
					u1=_mm_sub_epi32(u1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u1,mm),
					_mm_cmpgt_epi32(m0,u1)),mm));
					v0=_mm_sub_epi32(my_mullo_epu32(v0,p4),
					my_mullo_epu32(my_mulhi_epu32(v0,q4),m1));
					v1=_mm_sub_epi32(my_mullo_epu32(v1,p4),
					my_mullo_epu32(my_mulhi_epu32(v1,q4),m1));
					_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u0,v0));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_add_epi32(u1,v1));
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_add_epi32(_mm_sub_epi32(u0,v0),mm));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_add_epi32(_mm_sub_epi32(u1,v1),mm));
				}
			}
		}
	}
	for(int i=0;i<n;++i)
		x[i]-=(x[i]>=us(MOD+MOD))*us(MOD+MOD),
		x[i]-=(x[i]>=us(MOD))*us(MOD);
}
void intt(us* __restrict__ x,int n)
{
	int t=1;
	for(int m=(n>>1);m;m>>=1)
	{
		us* __restrict__ p=p1[m];
		us* __restrict__ q=q1[m];
		if(t==1)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==2)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
				for(int j=0;j<t;++j)
				{
					us u=xa[j],v=xb[j];
					xa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);
					xb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);
				}
		}
		else if(t==4)
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				for(int j=0;j<t;j+=4)
				{
					__m128i u=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i v=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i uv=_mm_add_epi32(u,v);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv,mm),
					_mm_cmpgt_epi32(m0,uv)),mm)));
					uv=_mm_add_epi32(_mm_sub_epi32(u,v),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv,p4),
					my_mullo_epu32(my_mulhi_epu32(uv,q4),m1)));
				}
			}
		}
		else
		{
			us *xa=x,*xb=x+t;
			for(int i=0;i<m;++i,xa+=t+t,xb+=t+t)
			{
				const __m128i p4=_mm_set1_epi32(p[i]),
				q4=_mm_set1_epi32(q[i]),
				mm=_mm_set1_epi32(MOD+MOD),
				m0=_mm_set1_epi32(0),
				m1=_mm_set1_epi32(MOD);
				//unfold 2x
				for(int j=0;j<t;j+=8)
				{
					__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));
					__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));
					__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));
					__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));
					__m128i uv0=_mm_add_epi32(u0,v0);
					__m128i uv1=_mm_add_epi32(u1,v1);
					_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv0,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv0,mm),
					_mm_cmpgt_epi32(m0,uv0)),mm)));
					_mm_storeu_si128((__m128i*)(xa+j+4),_mm_sub_epi32(uv1,
					_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv1,mm),
					_mm_cmpgt_epi32(m0,uv1)),mm)));
					uv0=_mm_add_epi32(_mm_sub_epi32(u0,v0),mm);
					uv1=_mm_add_epi32(_mm_sub_epi32(u1,v1),mm);
					_mm_storeu_si128((__m128i*)(xb+j),
					_mm_sub_epi32(my_mullo_epu32(uv0,p4),
					my_mullo_epu32(my_mulhi_epu32(uv0,q4),m1)));
					_mm_storeu_si128((__m128i*)(xb+j+4),
					_mm_sub_epi32(my_mullo_epu32(uv1,p4),
					my_mullo_epu32(my_mulhi_epu32(uv1,q4),m1)));
				}
			}
		}
		t<<=1;
	}
	us rn=qp(n,MOD-2);
	for(int i=0;i<n;++i)
		x[i]=x[i]*(ull)rn%MOD;
}
	
	void mult(us *a, us as, us *b, us bs, us *o, bool construct, bool clean = 0, us th = 100000000) {
		us n = as+bs-1;
		if(n >= 40) {
    		while(n - (n & (-n))) n += (n & (-n));
    		assert(!construct);
    		//constructrev(n);
    		ntt(a, n); ntt(b, n);
    		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
    		intt(o, n);
		} else {
		    static ll tmp[41];
		    rep(i, as) rep(j, bs) tmp[i+j] += 1ll * a[i] * b[j];
		    rep(i, n) {
		        o[i] = tmp[i] % MOD;
		        tmp[i] = 0;
		    }
		}
		iter(i, th, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(us* a, us as, us *o) {
		static us tmp[524320];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); us le = 0;
		while((1 << le) < (as << 1)) le++;
		//constructrev(1 << le);
		memcpy(tmp, a, as*intsize);
		memset(tmp+as, 0, ((1<<le)-as)*intsize);
		ntt(tmp, 1<<le); ntt(o, 1<<le);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		intt(o, 1<<le);
		memset(o+as, 0, ((1<<le)-as)*intsize);
	}

	void init(us n) { prep(n); }
	
	void divide(us *a, us as, us *b, us bs, us *q, us *r) {
		static us ar[524320], br[524320], bin[524320];
		us th = as, re = as-bs+1;
		//th = re+1;
		rep(i, as) ar[i] = a[as-1-i];
		rep(i, bs) br[i] = b[bs-1-i];
		cfn(br, th, bin);
		mult(ar, th, bin, th, q, 0, 1, re);
		reverse(q, q+re);
		mult(q, re, b, bs, r, 0, 1, bs - 1);
		rep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;
	}
	
}

#define array MY_FUCKING_ARRAY

struct array {
    ptr<us> head; us sz;
    array() : sz(0) { head = nullptr; }
    array(us size) : sz(size) { head = new us[size]; }
    us& operator[](const us idx) { return head[idx]; }
    us* get() { return head.get(); }
    const us size() { return sz; }
};

array pol[524320];


namespace Eval {
    us points[524320];
    us answer[524320];
    
    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }

    void solve(us idx, us l, us r, array& polynomial) {
        static us tmp[524320], tmp2[524320], tmp3[524320], BULLSHIT[524320];
        //assert(polynomial.size() == r-l);
        if(r - l == 0) return;
        if(r - l == 1) {
            answer[l] = polynomial[0];
            return;
        }
        us m = (l+r)/2;
        if(m - l) {
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2].get(), (m-l+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, m-l+1, BULLSHIT, tmp3);
            array p2(m-l); memcpy(p2.get(), tmp3, (m-l)*intsize);
            solve(idx*2, l, m, p2);
        }
        if(r - m) { 
            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);
            memcpy(tmp2, pol[idx*2+1].get(), (r-m+1)*intsize);
            poly::divide(tmp, polynomial.size(), tmp2, r-m+1, BULLSHIT, tmp3);
            array p2(r-m); memcpy(p2.get(), tmp3, (r-m)*intsize);
            solve(idx*2+1, m, r, p2);
        }
    }
us p[524320];
us dv[524320];
us rp[524320];
us BULLsHIT[524320];
    array eval(array& po, array& v) {
        us n = po.size(), m = v.size();
        rep(i, m) {
            points[i] = v[i];
            if(!v[i]) v[i] = MOD;
        }
        init(1, 0, m);
        static us tmp[524320];
        array pp(m);
        if(n >= m+1) {
            rep(i, m+1) dv[i] = pol[1][i];
            rep(i, n) p[i] = po[i];
            poly::divide(p, n, dv, m+1, BULLsHIT, tmp);
            memcpy(pp.get(), tmp, m*intsize);
        } else pp = po;
        solve(1, 0, m, pp);
        array res(m); memcpy(res.get(), answer, m*intsize);
        return res;
    }
}

namespace Inter {
    us points[524320], values[524320];
    
    array drv, coeff;

    void init(us idx, us l, us r) {
        // [l, r)
        if(r - l == 0) {
            pol[idx] = array(1);
            pol[idx][0] = 1;
            return;
        }
        if(r - l == 1) {
            pol[idx] = array(2);
            pol[idx][0] = (MOD - points[l]) % MOD;
            pol[idx][1] = 1;
            return;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320];
        init(idx*2, l, (l+r)/2);
        init(idx*2+1, (l+r)/2, r);
        us n = pol[idx*2].size();
        us m = pol[idx*2+1].size();
        memcpy(tmp1, pol[idx*2].get(), n * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);
        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);
        pol[idx] = array(n+m-1);
        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);
        //assert(pol[idx] == Eval::pol[idx]);
    }
    
    array solve(us idx, us l, us r) {
        if(r - l == 0) {
            array ans(1); ans[0] = 1;
            return ans;
        }
        if(r - l == 1) {
            array ans(1); ans[0] = 1ll * values[l] * poly::qpow(coeff[l], MOD-2) % MOD;
            return ans;
        }
        static us tmp1[524320], tmp2[524320], tmp3[524320], tmp4[524320];
        array tmp = solve(idx*2, l, (l+r)/2);
        array tmpp = solve(idx*2+1, (l+r)/2, r);
        memcpy(tmp1, tmp.get(), tmp.size() * intsize);
        memcpy(tmp2, pol[idx*2+1].get(), pol[idx*2+1].size() * intsize);
        us s1 = tmp.size() + pol[idx*2+1].size() - 1;
        poly::mult(tmp1, tmp.size(), tmp2, pol[idx*2+1].size(), tmp3, 0, 1); 
        rep(i, tmpp.size()) tmp1[i] = tmpp[i];
        memcpy(tmp1, tmpp.get(), tmpp.size() * intsize);
        memcpy(tmp2, pol[idx*2].get(), pol[idx*2].size() * intsize);
        us s2 = tmpp.size() + pol[idx*2].size() - 1;
        poly::mult(tmp1, tmpp.size(), tmp2, pol[idx*2].size(), tmp4, 0, 1); 
        s2 = max(s2, s1); tmp = array(s2);
        rep(i, s2) {
            us p = tmp3[i] + tmp4[i]; p -= (p >= MOD ? MOD : 0);
            tmp[i] = p;
            //tmp3[i] = tmp4[i] = 0;
        }
        return tmp;
    }

    array inter(array& pt, array& vl) {
        assert(pt.size() == vl.size());
        us n = pt.size();
        memcpy(points, pt.get(), n * intsize);
        memcpy(values, vl.get(), n * intsize);
        init(1, 0, n);
        drv = array(n);
        rep1(i, n) { drv[i-1] = 1ll * i * pol[1][i] % MOD; }
        coeff = Eval::eval(drv, pt);
        return solve(1, 0, n);
    }
}

#define pol MY_FUCKING_pol

us original_pol[524320];

array pts, vls;
array res;

us fac[524300], ifac[524300], inv[524300];
us ar1[524320], ar2[524320], f[524320];
us ar2i[524320];

us not_BULLSHIT[524320];

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; io.read(n);
    fac[0] = ifac[0] = fac[1] = ifac[1] = inv[0] = inv[1] = 1;
    iter(i, 2, n+2) {
    	inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
    	fac[i] = 1ll * fac[i-1] * i % MOD;
    	ifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;
    }
    pts = array(n+1);
    rep(i, n+1) pts[i] = i;
    rep(i, n) io.read(original_pol[i]);
    int k = 1; while(k < ((n+2) << 1)) k <<= 1;
    poly::init(k);
    //tmp = Eval::eval(pol, pts);
    //rep(i, n+1) ar1[i] = 1ll * tmp[i] * ifac[i] % MOD;
    rep(i, n+1) ar2[i] = 1ll * ((i % 2) ? (MOD - 1) : 1) * ifac[i] % MOD;
    poly::cfn(ar2, n+1, ar2i);
    poly::mult(original_pol, n+1, ar2i, n+1, not_BULLSHIT, 0);
    vls = array(n+1);
    rep(i, n+1) vls[i] = 1ll * not_BULLSHIT[i] * fac[i] % MOD;
    res = Inter::inter(pts, vls);
    rep(i, n) io.write(res[i]), io.write(' ');
}
```

---


# [CmdOI2019] 简单的数论题

## 题目描述

给出 $n,m$ 求下列式子的值 ：

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m \varphi\left(\dfrac{{\rm lcm}(i,j)}{\gcd(i,j)}\right) \bmod 23333$$

## 说明/提示

对于所有测试点， $T\leq 3\times 10^4,\ m\leq n\leq 5\times 10^4$。

| 测试点编号 | $n,m\leq $ | $T$ | 时限 | 特殊性质 | 
| :--: | :--: | :--: | :--: | :--: |
| #1~2 | $100$ | $100$ | $\texttt{1s}$ |  |
| #3~4 | $2000$ | $3\times 10^4$ | $\texttt{1s}$ |  |
| #5~6 | $3\times 10^4$ | $5000$ | $\texttt{2s}$ |  |
| #7~8 | $5\times 10^4$ | $3\times 10^4$ | $\texttt{2s}$ | $n=m$ |
| #9~10 | $5\times 10^4$ | $3\times 10^4$ | $\texttt{2s}$ |  |

## 样例 #1

### 输入

```
5
10 10
20 20
30 30
40 40
50 50
```

### 输出

```
768
13312
16218
7160
9031```

## 样例 #2

### 输入

```
3
5 4
20 15
100 88```

### 输出

```
52
7572
21475```

# 题解

## 作者：command_block (赞：17)

### 官方题解 : 简单的数论题

$\color{blue}(\text{重制于 2020.11.24})$ : 更简洁的推导，更严谨的复杂度分析。加更莫队解法。

其实这个题根本没用到欧拉函数的神奇性质。

如果你往 $\varphi(ij)=\dfrac{\varphi(i)\varphi(j)(i,j)}{\varphi((i,j))}$ 这方面思考，可能会一去不复返。

(当然,欢迎大佬踩标算)

换句话说把 $\varphi$ 换成任意一个积性函数,都是可以做的。

- $\Large 20'$

$n,m\leq 100,T\leq 100$

打出 $\varphi$ 的表，然后按照题意大力计算即可。

- $\Large 40'$

$n,m\leq 2000,T\leq 3*10^4$

打个答案的表就好了, $\varphi$ 线性筛,复杂度 $O(n^2\log n+T)$ 或者 $O(n^2+T)$ 。

```cpp
#include<algorithm>
#include<cstdio>
#define MaxN 4000500
#define MaxNum 2010
#define mod 23333
using namespace std;
int T,N,M;
bool e[MaxN+500];
int tn,p[MaxN+500],phi[MaxN+500];
int gcd[MaxNum+50][MaxNum+50];
int ans[MaxNum+50][MaxNum+50];
int gcdpre(int a,int b)
{
  if (!b)return a;
  if (gcd[a][b])return gcd[a][b];
  return gcd[a][b]=gcdpre(b,a%b); 
}
inline void getsth()
{
  e[1]=1;phi[1]=1;
  for (int i=2,t;i<=MaxN;i++){
    if (!e[i]){
      p[++tn]=i;
      phi[i]=i-1;
    }
    for (int j=1;j<=tn&&(t=p[j]*i)<=MaxN;j++){
      phi[t]=phi[i]*(i%p[j]==0 ? p[j] : p[j]-1);
      e[t]=1;
      if (i%p[j]==0)break;
    }
  }
  for (int i=1;i<=MaxNum;i++)
    for (int j=1;j<=MaxNum;j++)
      gcd[i][j]=gcdpre(i,j);
  for (int i=1;i<=MaxNum;i++)
    for (int j=1;j<=MaxNum;j++)
      ans[i][j]=(phi[i*j/gcd[i][j]/gcd[i][j]]
        +ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1])%mod;
}
int main()
{
  scanf("%d",&T);
  getsth();
  while(T--){
    scanf("%d%d",&N,&M);
    printf("%d\n",(ans[N][M]+mod)%mod);
  }return 0;
}
```

- $\Large 60'$

$n,m\leq 3\times 10^4,T\leq 5000$

送分结束,开始推导式子:

求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi\left(\dfrac{lcm(i,j)}{gcd(i,j)}\right)$

$=\sum\limits_{d=1}^n\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi\left(\dfrac{ij}{d^2}\right)[gcd(i,j)=d]$

$=\sum\limits_{d=1}^n\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}\varphi(ij)[i\perp j]$

$=\sum\limits_{d=1}^n\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}\varphi(i)\varphi(j)[i\perp j]$

$=\sum\limits_{d=1}^n\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}\varphi(i)\varphi(j)\sum\limits_{t|i,t|j}\mu(t)$

$=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)\sum\limits_{t|i}^{n/d}\varphi(i)\sum\limits_{t|j}^{m/d}\varphi(j)$

$=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)\sum\limits_{i=1}^{n/dt}\varphi(it)\sum\limits_{j=1}^{m/dt}\varphi(jt)$

- 设 $G(n,k)=\sum\limits_{i=1}^n\varphi(ik)$

.$=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)G(\lfloor n/dt\rfloor,t)G(\lfloor m/dt\rfloor,t)$

设 $L=\max(n,m)$。

不难发现，我们调用的 $G(n,k)$ 函数都满足 $n,k\leq L$，所以总状态量是 $O\Big(\sum\limits_{x,y}[xy\leq n]\Big)=O(L\log L)$ 的。

不过，由于 $t$ 的存在，上面那个式子仍然不能直接整除分块。

- 设 $S(n,m,k)=\mu(k)G(n,k)G(m,k)$

则 ${\rm Ans}=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}S(\lfloor n/dt\rfloor,\lfloor m/dt\rfloor,t)$

对 $S$ 在 $t$ 维度上做前缀和，即可整除分块。

我们预处理出 $n,m\leq B$ 的 $S(n,m,k)$，由 $m*k,n*k<=L$ 可以得到总状态量为 :

$O\Big(\sum\limits_{n=1}^B\sum\limits_{m=1}^BL/\max(n,m)\Big)=O\Big(\sum\limits_{n=1}^B\sum\limits_{m=1}^nL/n\Big)=O(LB)$。

${\rm Ans}=\sum\limits_{d=1}^nf(\lfloor n/d\rfloor,\lfloor m/d\rfloor ,1)$

令 $B≈\sqrt{L}$ ,预处理 $S$ 的时空复杂度为 $O(L\sqrt{L})$ 。

设 $f(n,m)=\sum\limits_{t=1}^{n}S(\lfloor n/t\rfloor,\lfloor m/t\rfloor,t)$

当 $n/t\geq B\Rightarrow t\leq n/B$ 时，没有预处理 $S$ ，需要暴力求和,复杂度为 $O(n/B)\leq O(\sqrt{n})$。

当 $t>n/B$ 时，可以整除分块计算，这部分复杂度为 $O(\sqrt{n})$。

${\rm Ans}=\sum\limits_{d=1}^nf(\lfloor n/d\rfloor,\lfloor m/d\rfloor)$

直接分块套分块计算，复杂度为$O(∫_1^{\sqrt{n}}\sqrt{n/x})=O(n^{3/4})$ ,常数较大。

总复杂度 $O(TL^{3/4}+L\sqrt{L})$。

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
#define MaxN 30500
using namespace std;
const int mod=23333,B=200,lim=30000;
int tn,p[MaxN>>2],mu[MaxN],phi[MaxN]
   ,*G[MaxN],_G[MaxN*16],*gp=_G
   ,*S[B+5][B+5],_S[MaxN*(B+B/4)],*sp=_S;
void getsth()
{
  phi[1]=mu[1]=1;
  for (int i=2,t;i<=lim;i++){
    if (!phi[i]){
      mu[p[++tn]=i]=-1;
      phi[i]=i-1;
    }
    for (int j=1;j<=tn&&(t=p[j]*i)<=lim;j++){
      if (i%p[j]==0){
        phi[t]=phi[i]*p[j];
        break;
      }mu[t]=-mu[i];
      phi[t]=phi[i]*(p[j]-1);
    }
  }G[0]=gp;gp+=lim+1;
  for (int x=1;x<=lim;x++){
    G[x]=gp+1;
    gp+=lim/x+1;
    for (int y=1;x*y<=lim;y++)
      G[x][y]=(G[x-1][y]+phi[x*y])%mod;
  }
  for (int j=1;j<=B;j++)
    for (int i=j;i<=B;i++){
      S[i][j]=sp;
      sp+=lim/i+2;
      for (int k=1;k*i<=lim;k++)
        S[i][j][k]=(S[i][j][k-1]+mu[k]*G[i][k]%mod*G[j][k])%mod;
    }
}
int f(int n,int m)
{
  ll ans=0;
  for (int i=1;i*B<=n;i++)
    ans+=mu[i]*G[n/i][i]*G[m/i][i];
  ans%=mod;
  register int l=n/B+1,r;int tn,tm;
  for (;l<=m;l=r+1){
    r=min(n/(tn=n/l),m/(tm=m/l));
    ans+=S[tn][tm][r]-S[tn][tm][l-1];
  }return ans%mod;
}
int T,N,M;
int main()
{
  scanf("%d",&T);
  getsth();
  while(T--){
    scanf("%d%d",&N,&M);
    if (N<M)swap(N,M);
    ll ans=0;
    int l=1,r;
    for (;l<=M;l=r+1){
      r=min(N/(N/l),M/(M/l));
      ans+=f(N/l,M/l)*(r-l+1)%mod;
    }printf("%d\n",(ans%mod+mod)%mod);
  }return 0;
}
```

- $\Large \oplus\ 20'$

$n=m\leq 5*10^4,T\leq 5*10^4$

发现预处理所有 $f(n,n)$ 的值，就只需一次外层整除分块。

(此外, $S$ 也不用费心)

- $\Large 100'$

$n,m\leq 5*10^4,T\leq 5*10^4$

承接上面的式子:

${\rm Ans}=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)G(n/dt,t)G(m/dt,t)$

设 $T=dk$ ,交换和式得到:

$=\sum\limits_{T=1}^n\sum\limits_{k|T}\mu(k)G(n/T,k)G(m/T,k)$

仍然不能整除分块，暴力的话需要 $O(n\log n)$ ,不知T到哪里去了。

我们设 $R(n,m,t)=\sum\limits_{k|T}\mu(k)G(n,k)G(m,k)$

我们预处理 $n\leq\sqrt{L}$ 的 $R(n,m,t)$ ，状态量仍然是 $O(L\sqrt{L})$。

预处理时，对于 $t$ 这一维做约数求和，容易做到 $O(L\sqrt{L}\log L)$ (调和级数)。

实际上还可以做到 $O(L\sqrt{L}\log\log L)$ ，感兴趣的同学可见 [狄利克雷相关](https://www.luogu.com.cn/blog/command-block/gcd-juan-ji-xiao-ji)。

${\rm Ans}=\sum\limits_{T=1}^nR(n/T,m/T,T)$

对于 $n/T\leq B$ 的部分整除分块，复杂度为 $O(\sqrt{n})$.

对于 $n/T>B$ 即 $T\leq n/B$ 的部分我们是没有预处理的,复杂度为 $O(n/B\log n)=O(\sqrt{n}\log n)$。

综上,空间 $O(n\sqrt{n})$ ,时间 $O\big((L+T)\sqrt{L}\log L\big)$。

~~常数比较小,所以比60pts做法快到不知哪里去了~~

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
#define MaxN 50500
using namespace std;
const int mod=23333,B=150,lim=50000;
int tn,p[MaxN>>2],mu[MaxN],phi[MaxN]
   ,*G[MaxN],_G[MaxN*16],*gp=_G
   ,*R[B+5][B+5],_R[MaxN*(B+B/4)],*rp=_R;
void getsth()
{
  phi[1]=mu[1]=1;
  for (int i=2,t;i<=lim;i++){
    if (!phi[i]){
      mu[p[++tn]=i]=-1;
      phi[i]=i-1;
    }
    for (int j=1;j<=tn&&(t=p[j]*i)<=lim;j++){
      if (i%p[j]==0){
        phi[t]=phi[i]*p[j];
        break;
      }mu[t]=-mu[i];
      phi[t]=phi[i]*(p[j]-1);
    }
  }G[0]=gp;gp+=lim+1;
  for (int x=1;x<=lim;x++){
    G[x]=gp+1;
    gp+=lim/x+1;
    for (int y=1;x*y<=lim;y++)
      G[x][y]=(G[x-1][y]+phi[x*y])%mod;
  }
  for (int j=1;j<=B;j++)
   for (int i=j;i<=B;i++){
     R[i][j]=rp;
     rp+=lim/i+2;
     int n0=lim/i;
     for (int k=1;k<=n0;k++){
       int sav=mu[k]*G[i][k]%mod*G[j][k];
       for (int p=k;p<=n0;p+=k)
         R[i][j][p]+=sav;
     }
     for (int k=1;k*i<=lim;k++)
       R[i][j][k]=(R[i][j][k-1]+R[i][j][k])%mod;
  }
}
int T,N,M;
int main()
{
  scanf("%d",&T);
  getsth();
  while(T--){
    scanf("%d%d",&N,&M);
    long long ans=0;
    for (int i=1;i*B<=N;i++)
      for (int j=i;j*B<=N;j+=i)
        ans+=mu[i]*G[N/j][i]*G[M/j][i];
    ans%=mod;
    register int l=N/B+1,r;int tn,tm;
    for (;l<=M;l=r+1){
      r=min(N/(tn=N/l),M/(tm=M/l));
      ans+=R[tn][tm][r]-R[tn][tm][l-1];
    }printf("%d\n",(ans%mod+mod)%mod);
  }return 0;
}
```

## 另解

来自 @流风之回雪 大佬的赛时解法。

发现此题并没有强制在线，可以使用基于莫队的的做法。

静待大佬发题解…… 

（然而一年多过去了还是没有其他题解，那我就自己写写吧）

设一行的权值 $S(n,k)=\sum\limits_{i=1}^n\varphi\Big(\dfrac{{\rm lcm}(i,k)}{\gcd(i,k)}\Big)$

莫队可以把问题转化成 $O(n\sqrt{T})$ 个 $S(n,k)$ 的求解。

$=\sum\limits_{d|k}\sum\limits_{i=1}^n\varphi\Big(\dfrac{ik}{d^2}\Big)[\gcd(i,k)=d]$

$=\sum\limits_{d|k}\sum\limits_{i=1}^{n/d}\varphi\Big(\dfrac{ik}{d}\Big)[i\perp(k/d)]$

$=\sum\limits_{d|k}\sum\limits_{i=1}^{n/(k/d)}\varphi(id)[i\perp d]$

$=\sum\limits_{d|k}\varphi(d)\sum\limits_{i=1}^{n/(k/d)}\varphi(i)[i\perp d]$

$=\sum\limits_{d|k}\varphi(d)\sum\limits_{i=1}^{n/(k/d)}\varphi(i)\sum\limits_{t|i,t|d}\mu(t)$

$=\sum\limits_{d|k}\varphi(d)\sum\limits_{t|d}\mu(t)\sum\limits_{t|i}^{n/(k/d)}\varphi(i)$

$=\sum\limits_{d|k}\varphi(d)\sum\limits_{t|d}\mu(t)\sum\limits_{i=1}^{n/t(k/d)}\varphi(it)$

$=\sum\limits_{d|k}\varphi(d)\sum\limits_{t|d}\mu(t)G(\lfloor nd/tk\rfloor,t)$

到这里可以尝试 $O\big((I*d)\big(k))$ 枚举约数计算。

平均复杂度大概是 $O(\log^2n)$ 的，这也正是大佬的赛时做法，现在似乎已经无法通过。


---

## 作者：peterwuyihong (赞：10)

题意：组数小于等于 $30000$，$n,m\le 5\times10^4$ 多测

$$\sum_{i=1}^n\sum_{j=1}^m\varphi(\frac{ij}{\gcd^2(i,j)})$$

默认 $n\le m,x/y\rightarrow\lfloor\frac{x}{y}\rfloor$，然后你一演

$$\sum_{d=1}^n\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\varphi(ij)[\gcd(i,j)=1]$$

$$\sum_{d=1}^n\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\varphi(i)\varphi(j)[\gcd(i,j)=1]$$

$$\sum_{d=1}^n\sum_{k=1}^{n/d}\mu(k)\sum_{i=1}^{n/dk}\varphi(ik)\sum_{j=1}^{m/dk}\varphi(jk)$$

$$dk\rightarrow T,\sum_{T=1}^n\sum_{d|T}\mu(d)\sum_{i=1}^{n/T}\varphi(id)\sum_{j=1}^{m/T}\varphi(jd)$$

然后就是发扬人类智慧的时候了！

你发现变化后的柿子只要求 $\varphi$ 在 $\text{maxn}$ 以内的值，于是你就掏出来一个 $G$，表示：

$$G(x,y)=\sum_{i=1}^x\varphi(yi)$$

显然 $G$ 不超过调和大小个，暴力预处理即可。

$$\sum_{T=1}^n\sum_{d|T}\mu(d)G(n/T,d)G(m/T,d)$$

然后你又掏出一个 $H$ ，表示：

$$H(x,y,z)=\sum_{i=1}^z\sum_{T|i}\mu(T)G(x,T)G(y,T)$$

如果你能把答案预处理出来，那将是非常美妙的事，但是会 $\text{MTLE}$，所以我们掏出一个人类智慧，考虑预处理一些东西出来，剩下暴力。

弄出来一个值域 $B$，对于 $m/B$ 以内的 $z$ 暴力用 $G$ 算，其他注意到 $H(x,y,z)$ 中的 $x,y$ 实质就是 $n/T,m/T$，使用整除分块来优化即可。

现在是 $16:41$，我看我什么时候写完。

现在是 $18:15$，我写完了。

```cpp
#define maxn 50010
const int p=23333;
int pri[maxn],mu[maxn],phi[maxn],tot;
bitset<maxn>v;
const int B=72;
vector<int>G[maxn],H[B+10][B+10],fac[maxn];
int ksm(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
int calc(int x,int y,int z){
	int ans=0;
	for(int o:fac[z])
	ans=(ans+mu[o]*G[o][x]%p*G[o][y])%p+p;
	return ans%p;
}
void shai(int n){
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j+=i)
	fac[j].push_back(i);
	mu[1]=phi[1]=1;
	for(int i=2;i<=n;i++){
		if(v[i]==0)pri[++tot]=i,phi[i]=i-1,mu[i]=-1;
		for(int j=1;j<=tot&&i*pri[j]<=n;j++){
			v[i*pri[j]]=1;
			if(i%pri[j]==0){
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			phi[i*pri[j]]=phi[i]*(pri[j]-1);
			mu[i*pri[j]]=-mu[i];
		}
	}
	for(int i=1;G[i].push_back(0),i<=n;i++)
	for(int j=1;j*i<=n;j++)
	G[i].push_back((G[i][j-1]+phi[i*j])%p);
	for(int i=1;i<=B;i++)for(int j=1;j<=B;j++){
		H[i][j].push_back(0);
		for(int k=1;k<=n/max(i,j);k++)
		H[i][j].push_back((H[i][j][k-1]+calc(i,j,k))%p);
	}
}
int T,n,m,ans;
signed main(){
	shai(50000);
	for(cin>>T;T;T--){
		cin>>n>>m;
		if(n>m)swap(n,m);
		ans=0;
		for(int i=1;i<=m/B;i++)ans=(ans+calc(n/i,m/i,i))%p;
		for(int L=m/B+1,R;L<=n;L=R+1){
			R=min(n/(n/L),m/(m/L));
			ans=(ans+H[n/L][m/L][R]-H[n/L][m/L][L-1]+p)%p;
		}
		cout<<ans%p<<endl;
	}
}
```
降智了，把P4240的代码贺过来的时候有个地方没改，$\text{WA}$ 了不久。

---

## 作者：Alex_Wei (赞：5)

> [P5572 [CmdOI2019] 简单的数论题](https://www.luogu.com.cn/problem/P5572)

$$
\begin{aligned}
\mathrm{answer} & = \sum\limits_{i = 1} ^ n \sum\limits_{j = 1} ^ m \varphi\left( \dfrac {i j} {\gcd ^ 2(i, j)}\right) \\
& = \sum\limits_{i = 1} ^ n \sum\limits_{j = 1} ^ m \varphi\left( \dfrac {i} {\gcd(i, j)}\right) \varphi\left( \dfrac {j} {\gcd(i, j)}\right) \\
& = \sum\limits_{d = 1} ^ m \sum\limits_{i = 1} ^ {\frac n d} \sum\limits_{j = 1} ^ {\frac m d} \varphi(i) \varphi(j) [i\perp j] \\
& = \sum\limits_{d = 1} ^ m \sum\limits_{d' = 1} ^ {\frac m d} \mu(d') \sum\limits_{i = 1} ^ {\frac n {dd'}} \sum\limits_{j = 1} ^ {\frac m {dd'}} \varphi(id') \varphi(jd') \\
& = \sum\limits_{T = 1} ^ m \sum\limits_{d\mid T} \mu(d) \left(\sum\limits_{i = 1} ^ {\frac n T} \varphi(id) \right)  \left(\sum\limits_{j = 1} ^ {\frac m T} \varphi(jd) \right) \\
\end{aligned}
$$

第二步运用了 $\varphi$ 的积性。

求出不大于某值的所有 $d$ 的倍数的 $\varphi$ 之和的形式出现多次，所以首先 $n\ln n$ 预处理 $f(d, s)$ 表示 $\sum\limits_{i = 1} ^ s \varphi(id)$。

计算单个 $T$ 的复杂度为 $d(T)$，且当 $T$ 大的时候，$\dfrac n T$ 和 $\dfrac m T$ 较小，所以我们考虑根号分治。

对于 $T\leq \sqrt n$，直接暴力枚举 $T, d$ 计算 $\sum\limits_{T = 1} ^ m \sum\limits_{d\mid T} \mu(d) f(d, \frac n T) f(d, \frac m T)$。这部分时间复杂度 $\mathcal{O}(n\sqrt n \log n)$。

对于 $T \geq \sqrt n$，$\dfrac n T\leq \sqrt n$，预处理 $g(i, j, s)$ 表示 $\sum\limits_{T = 1} ^ s \sum\limits_{d\mid T} \mu(d)f(d, i) f(d, j)$，则一段使得整除值 $\dfrac n T$ 和 $\dfrac m T$ 相同的 $T\in [l, r]$ 的贡献可直接表示为 $g(\frac n T, \frac m T, r) - g(\frac n T, \frac m T, l - 1)$。注意到 $i \geq j$ 且 $s$ 的上界为 $\dfrac n i$（要使 $\dfrac n T = i$，则 $T$ 不会超过 $n$ 的最大值除以 $i$），所以对于每个 $i$ 的 $j, s$ 情况数为 $i\times \dfrac n i = n$。对每个 $i\leq \sqrt n$ 预处理出所有 $(i, j, s)$ 的答案，空间复杂度 $\mathcal{O}(n\sqrt n)$，时间复杂度 $\mathcal{O}(n\sqrt n\log n)$ 或 $\mathcal{O}(n\sqrt n \log\log n)$。得到每段 $[l, r]$ 可以直接整除分块。

综上，时间复杂度 $\mathcal{O}(n\sqrt n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using uint = unsigned int;
using ld = long double;
// using lll = __int128;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using us = unsigned short;
using ull = unsigned long long;
inline ll read() {
  ll x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(ll x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 5e4 + 5;
constexpr int mod = 23333;
int reduce(int v) {return v >= mod ? v - mod : v;}
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
bool vis[N];
int pr[N], cnt, phi[N], mu[N];
vector<int> f[233][233], sphi[N];
int T, n[N], m[N];
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = read(), mx = 0;
  for(int i = 1; i <= T; i++) mx = max(mx, n[i] = read()), m[i] = read();
  phi[1] = mu[1] = 1;
  for(int i = 2; i <= mx; i++) {
    if(!vis[i]) pr[++cnt] = i, phi[i] = i - 1, mu[i] = -1;
    for(int j = 1; j <= cnt && i * pr[j] <= mx; j++) {
      vis[i * pr[j]] = 1;
      if(i % pr[j] == 0) {
        phi[i * pr[j]] = phi[i] * pr[j];
        break;
      }
      mu[i * pr[j]] = -mu[i];
      phi[i * pr[j]] = phi[i] * (pr[j] - 1);
    }
    phi[i] %= mod;
  }
  for(int d = 1; d <= mx; d++) {
    sphi[d].resize(N / d + 1);
    for(int j = 1; j * d <= mx; j++) sphi[d][j] = reduce(sphi[d][j - 1] + phi[j * d]);
  }
  int K = max(1, (int) sqrt(mx) / 3);
  for(int i = 1; i <= K; i++)
    for(int j = 1; j <= i; j++) {
      int lim = (N - 1) / i;
      f[i][j].resize(lim + 1);
      for(int d = 1; d * i <= mx; d++) {
        if(mu[d] == 0) continue;
        int v = sphi[d][i] * sphi[d][j] % mod;
        if(mu[d] == -1) v = mod - v;
        add(f[i][j][d], v);
      }
      for(int p = 1; p <= cnt && pr[p] <= lim; p++)
        for(int k = 1; k * pr[p] <= lim; k++)
          add(f[i][j][k * pr[p]], f[i][j][k]);
      for(int p = 1; p <= lim; p++) add(f[i][j][p], f[i][j][p - 1]);
    }
  for(int _ = 1; _ <= T; _++) {
    int n = ::n[_], m = ::m[_], ans = 0;
    int l = min(n / K, m) + 1;
    for(int d = 1; d < l; d++) {
      if(mu[d] == 0) continue;
      for(int T = d; T < l; T += d) {
        int v = sphi[d][n / T] * sphi[d][m / T] % mod;
        add(ans, mu[d] == -1 ? mod - v : v);
      }
    }
    for(int r; l <= m; l = r + 1) {
      r = min(n / (n / l), m / (m / l));
      add(ans, f[n / l][m / l][r]);
      add(ans, mod - f[n / l][m / l][l - 1]);
    }
    cout << ans << "\n";
  }
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/10/27
author: Alex_Wei
start coding at 7:12
finish debugging at 9:11
*/
```

---

## 作者：yizcdl2357 (赞：4)

# 题目大意

给定 $n,m$，求：

$$\sum_{i=1}^n\sum_{j=1}^m\varphi\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,j)}\right)\bmod 23333$$

$30000$ 组数据，$1\le m\le n\le 50000$。

# 解法

先推式子：（以下“$/$”默认向下取整）

$$\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m\varphi\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,j)}\right)\\
=&\sum_{i=1}^n\sum_{j=1}^m\varphi\left(\dfrac{ij}{\gcd(i,j)^2}\right)
&\text{（拆 lcm）}\\
=&\sum_{i=1}^n\sum_{j=1}^m\varphi\left(\dfrac{i}{\gcd(i,j)}\dfrac{j}{\gcd(i,j)}\right)
&\text{（此时}\dfrac{i}{\gcd(i,j)}\text{和}\dfrac{j}{\gcd(i,j)}\text{互质）}\\
=&\sum_{i=1}^n\sum_{j=1}^m\varphi\left(\dfrac{i}{\gcd(i,j)}\right)\varphi\left(\dfrac{j}{\gcd(i,j)}\right)
&\text{（}\varphi\text{是积性函数）}\\
=&\sum_{g=1}^m\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=g]\varphi\left(\dfrac{i}{g}\right)\varphi\left(\dfrac{j}{g}\right)
&\text{（枚举}\gcd\text{）}\\
=&\sum_{g=1}^m\sum_{i=1}^{n/g}\sum_{j=1}^{m/g}[\gcd(i,j)=1]\varphi(i)\varphi(j)
&\text{（用}i\text{代换}\dfrac{i}{g}\text{）}\\
=&\sum_{g=1}^m\sum_{i=1}^{n/g}\sum_{j=1}^{m/g}\varphi(i)\varphi(j)\sum_{k=1}^m[k|\gcd(i,j)]\mu(k)
&\text{（}\mu\text{的基本性质）}\\
=&\sum_{g=1}^m\sum_{k=1}^m\mu(k)\sum_{i=1}^{n/g}\sum_{j=1}^{m/g}[k|i][k|j]\varphi(i)\varphi(j)
&\text{（交换求和顺序）}\\
=&\sum_{g=1}^m\sum_{k=1}^m\mu(k)\sum_{i=1}^{n/gk}\sum_{j=1}^{m/gk}\varphi(ki)\varphi(kj)
&\text{（用}ki\text{代换}i\text{）}\\
=&\sum_{g=1}^m\sum_{k=1}^m\mu(k)\left(\sum_{i=1}^{n/gk}\varphi(ki)\right)\left(\sum_{j=1}^{m/gk}\varphi(kj)\right)
&\text{（把}i\text{和}j\text{分开）}\\
=&\sum_{T=1}^m\sum_{k|T}\mu(k)\left(\sum_{i=1}^{n/T}\varphi(ki)\right)\left(\sum_{j=1}^{m/T}\varphi(kj)\right)
&\text{（换元}T=kg\text{）}\\
\end{aligned}$$

观察和式中最后两个因子，它们都有 $\sum_{i=1}^{b}\varphi(ai)$ 的形式，其中 $a$ 和 $b$ 一定。

设 $G(a,b)=\sum_{i=1}^{b}\varphi(ai)$，则答案 $=\sum_{T=1}^m\sum_{k|T}\mu(k)\times G(n/T,k)\times G(m/T,k)$。

不难发现，在任何要调用 $G(a,b)$ 的情况下，$a\times b$ 都不超过 $n$，故 $a$ 和 $b$ 只有 $O(n\log n)$ 种取值，可以预处理到一个表里。

剩下的式子先考虑整除分块：
$$\begin{aligned}
&\sum_{T=1}^m\sum_{k|T}\mu(k) G(n/T,k) G(m/T,k)\\
=&\sum_{l,r}\sum_{T=l}^r\sum_{k|T}\mu(k) G(n/l,k) G(m/l,k)\\
=&\sum_{l,r}\left(\sum_{T=1}^r\sum_{k|T}\mu(k) G(n/l,k) G(m/l,k)\right)\\&-\left(\sum_{T=1}^{l-1}\sum_{k|T}\mu(k) G(n/l,k)G(m/l,k)\right)
\end{aligned}$$

观察和式中最后两项，它们都有 $\sum_{T=1}^{c}\sum_{k|T}\mu(k) G(a,k)G(b,k)$ 的形式，其中 $a,b$ 和 $c$ 一定。

设 $T(a,b,c)=\sum_{T=1}^{c}\sum_{k|T}\mu(k) G(a,k)G(b,k)$，则答案 $=\sum_{l,r}T(n/l,m/l,r)-T(n/l,m/l,l-1)$。再一次地，不难发现 $ac\le n,bc\le m$。

仍考虑预处理 $T$ 数组，但是如果全部预处理，时间和空间都受不了，考虑预处理一部分，剩下的部分暴力算。

我们设一个常数 $B$，然后预处理所有满足 $a\le B,b\le B$ 的 $T(a,b,c)$ 值。复杂度 $O(n\times B^2)$。

在查询 $T(n/l,m/l,r)$（或 $T(n/l,m/l,l-1)$）的值时，如果 $n/l$ 和 $m/l$ 均不大于 $B$，直接查表；

若 $n/l>B$，则 $l,r$ 一定较小（指 $l,r<n/B$），此时暴力计算复杂度较低。查询阶段复杂度 $O\left(\dfrac{Tn\log n}{B}\right)$。

通过调整 $B$ 的值，可以平衡预处理复杂度和查询复杂度。本菜鸡设 $B=50$。
# 代码
本题无需开 `long long`，因为模数仅有 $23333$。

预处理数组 `G`、`T` 以及用来记录每个数的所有因子的 `div`。此处用 `vector` 实现。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define M 23333
#define N 50000
#define B 50
using namespace std;
int T,n,m,pn,p[N+1],mu[N+1],phi[N+1],t[B+1][B+1][N+1];
bool ip[N+1];
vector<int> g[N+1],dv[N+1];
void init()
{
	memset(ip,1,sizeof(ip));
	ip[1]=0,mu[1]=1,phi[1]=1;
	for(int i=2;i<=N;i++)
	{
		if(ip[i]) p[++pn]=i,mu[i]=-1,phi[i]=i-1;
		for(int j=1;j<=pn;j++)
		{
			int now=i*p[j];
			if(now>N) break;
			ip[now]=0;
			phi[now]=phi[i]*(p[j]-1);
			mu[now]=-mu[i];
			if(i%p[j]==0)
			{
				phi[now]=phi[i]*p[j];
				mu[now]=0;
				break;
			}
		}
	}
	for(int i=1;i<=N;i++)
		dv[i].clear(),
		dv[i].push_back(0);
	for(int i=1;i<=N;i++)
	{
		g[i].clear();
		g[i].push_back(0);
		for(int j=1;j<=N/i;j++)
			g[i].push_back((g[i][j-1]+phi[i*j])%M),
			dv[i*j].push_back(i);
	}
	for(int i=1;i<=B;i++)
		for(int j=1;j<=B;j++)
			for(int k=1;k<=N/max(i,j);k++)
			{
				t[i][j][k]=t[i][j][k-1];
				int h;
				for(int l=1;l<dv[k].size();l++)
					h=dv[k][l],
					t[i][j][k]=(t[i][j][k]+mu[h]*g[h][i]*g[h][j]%M+M)%M;
			}
}
signed main()
{
	init();
	cin>>T;
	while(T--)
	{
		scanf("%d%d",&n,&m);
		int ans=0;
		for(int l=1,r;l<=min(n,m);l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			if(n/l>B||m/l>B)
			{
				int h;
				for(int i=l;i<=r;i++)
					for(int j=1;j<dv[i].size();j++)
						h=dv[i][j],
						ans=(ans+mu[h]*g[h][n/l]*g[h][m/l]%M+M)%M;
			}
			else ans=(ans+t[n/l][m/l][r]-t[n/l][m/l][l-1]+M)%M;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：critnos (赞：4)

（$n\le m$，$n=\Theta(m)$，分数向下取整）

$$\sum_{i=1}^n \sum_{j=1}^m \varphi(\dfrac {\text{lcm}(i,j)} {\gcd(i,j)})$$

$$\sum_{i=1}^n \sum_{j=1}^m \varphi(\dfrac {ij} {\gcd(i,j)^2})$$

$$\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^m \varphi(\dfrac {ij} {d^2}) [\gcd(i,j)=d]$$

$$\sum_{d=1}^n \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} \varphi(ij) [\gcd(i,j)=1]$$

$$\sum_{d=1}^n \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} \varphi(i)\varphi(j) [\gcd(i,j)=1]$$

（有趣的一步）

$$\sum_{d=1}^n \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} \varphi(i)\varphi(j)\sum_{x|i,x|j} \mu(x)$$

$$\sum_{d=1}^n \sum_{x=1}^{n/d} \mu(x)\sum_{i=1}^{n/dx} \varphi(ix)\sum_{j=1}^{m/dx} \varphi(jx)$$

令 $t=dx$

$$\sum_{t=1}^n \sum_{x|t} \mu(x) \sum_{i=1}^{n/t} \varphi(ix)\sum_{j=1}^{m/t} \varphi(jx)$$

设 $g(x,y)=\sum_{i=1}^x \varphi(iy)$

好[眼熟](https://www.luogu.com.cn/blog/203623/fake-ti-xie-p4240-du-liu-zhi-shen-di-kao-yan)的式子。

$g(x,y)=g(x-1,y)+\varphi(xy)$（告诉你他可以递推预处理）

显然所有的 $xy\le n$，所以递推预处理复杂度 $O(n\log n)$。

$$\sum_{t=1}^n \sum_{x|t} \mu(x) g(\dfrac n t,x)g(\dfrac m t,x)$$

设 $s(t,y,z)=\sum_{x|t} \mu(x) g(y,x)g(z,x)$

$$\sum_{t=1}^n s(t,\dfrac n t,\dfrac m t)$$

根号分治，设分治界为 $b$。

预处理 $s(\le n,\le b,\le b)$（非常不严谨的表述），$O(nb^2)$ 个状态。$O(nb^2 \log n)$ 预处理复杂度。

处理完了 $\dfrac m t\le b$ 部分。

若 $\dfrac m t>b$，则 $t<\dfrac m b$。直接求 $s$，复杂度 $O(d(t))$。然而总时间复杂度为 $O(\dfrac n b \log(\dfrac n b))$（调和级数）。

时间复杂度 $O(nb^2 \log n+T(\sqrt n+\dfrac n b \log(\dfrac n b)))$。

解得 $b=\Theta(T^{\frac 1 3})$~~，好[眼熟](https://www.luogu.com.cn/blog/203623/fake-ti-xie-p4240-du-liu-zhi-shen-di-kao-yan)的式子~~。

时间复杂度 $O(nT^{\frac 2 3}\log n+T\sqrt n)$。

（若我的计算有误，请指出）

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int S=5e4;
const int mod=23333;
const int b=21;
int mu[S+5],phi[S+5];
vector<int> g[S+5];
vector<int> ys[S+5];
int prime[S+5];
bool t[S+5];
int inv[S+5];
int s2[S+5][b+1][b+1];
void getmod(int &x)
{
	x+=(x<0)*mod,x-=(x>=mod)*mod;
}
int s(int t,int y,int z)
{
	ll sum=0;
	for(int i=0,x;i<ys[t].size();i++)
		sum+=1ll*mu[x=ys[t][i]]*g[y][x]*g[z][x];
	return sum%mod;
}
void init()
{
	inv[0]=inv[1]=phi[1]=t[1]=mu[1]=1;
	int i,j,k,l,x,cnt=0;
	ll sum;
	for(i=2;i<=S;i++)
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(i=2;i<=S;i++)
	{
		if(!t[i])
			prime[++cnt]=i,mu[i]=-1,phi[i]=i-1;
		for(j=1;j<=cnt&&i*prime[j]<=S;j++)
		{
			t[i*prime[j]]=1;
			if(i%prime[j])
				mu[i*prime[j]]=-mu[i],phi[i*prime[j]]=phi[i]*(prime[j]-1);
			else
			{
				mu[i*prime[j]]=0;
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
		}
	}
	g[0].resize(S+5);
	for(i=1;i<=S;i++)
	{
		g[i].resize(S/i+5);
		for(j=1;i*j<=S;j++)
			getmod(g[i][j]=g[i-1][j]+phi[i*j]);
	}	
	for(i=1;i<=S;i++)
		for(j=i;j<=S;j+=i)
			ys[j].push_back(i);
	for(i=1;i<=S;i++)
		for(j=1;j<=b;j++)
			for(k=1;k<=b;k++)
				if(i*j<=S&&i*k<=S)
					getmod(s2[i][j][k]=s(i,j,k)+s2[i-1][j][k]);			
}
int main()
{
	init();
	int T,n,m,l,r,x,y;
	ll ans;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		if(n>m) swap(n,m);
		for(ans=0,l=1;l<=n;l=r+1)
		{
			r=min(n/(x=n/l),m/(y=m/l));
			if(y<=b)
				ans+=s2[r][x][y]-s2[l-1][x][y];
			else
				for(;l<=r;l++)
					ans+=s(l,x,y);
		}
		printf("%ld\n",(ans%mod+mod)%mod);
	}
}
```


---

## 作者：littlez_meow (赞：2)

推式子的典型优化！

[题目指路](https://www.luogu.com.cn/problem/P5572)。

## step 1：推式子

写出原式：

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi\left(\dfrac{\operatorname{lcm}(i, j)}{\gcd(i, j)}\right) \bmod 23333$$

替换 $\operatorname{lcm}(i,j)$ 为 $\dfrac{ij}{\gcd(i,j)}$，得（下面省略取模）：

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi\left(\dfrac{ij}{\gcd(i, j)^2}\right)$$

枚举 $\gcd$，注意到数据范围中 $m\le n$，得：

$$\sum\limits_{t=1}^m\sum\limits_{i=1}^n\sum\limits_{j=1}^m\varphi\left(\dfrac{ij}{t^2}\right)[gcd(i,j)=t]$$

替换 $i,j$ 为 $it,jt$，得：

$$\sum\limits_{t=1}^m\sum\limits_{i=1}^{\lfloor\frac n t\rfloor}\sum\limits_{j=1}^{\lfloor\frac m t\rfloor}\varphi(ij)[gcd(i,j)=1]$$

利用积性函数的性质拆开，得：

$$\sum\limits_{t=1}^m\sum\limits_{i=1}^{\lfloor\frac n t\rfloor}\varphi(i)\sum\limits_{j=1}^{\lfloor\frac m t\rfloor}\varphi(j)[gcd(i,j)=1]$$

反演，有：

$$\sum\limits_{t=1}^m\sum\limits_{i=1}^{\lfloor\frac n t\rfloor}\varphi(i)\sum\limits_{j=1}^{\lfloor\frac m t\rfloor}\varphi(j)\sum\limits_{d|i,d|j}\mu(d)$$

枚举因数替换为枚举倍数，得到：

$$\sum\limits_{t=1}^m\sum\limits_{d=1}^{\lfloor\frac m t\rfloor}\mu(d)\sum\limits_{i=1}^{\lfloor\frac n{td}\rfloor}\varphi(id)\sum\limits_{j=1}^{\lfloor\frac m{td}\rfloor}\varphi(jd)$$

设 $k=td$，替换变量，有：

$$\sum\limits_{k=1}^m\sum\limits_{d|k}\mu(d)\sum\limits_{i=1}^{\lfloor\frac n k\rfloor}\varphi(id)\sum\limits_{j=1}^{\lfloor\frac m k\rfloor}\varphi(jd)$$

后面两项形式很像，设个函数 $f(x,y)=\sum\limits_{i=1}^y\varphi(ix)$，则有答案为：

$$\sum\limits_{k=1}^m\sum\limits_{d|k}\mu(d)f(d,\lfloor\dfrac n k\rfloor)f(d,\lfloor\dfrac m k\rfloor)$$

基本上推不下去了，预处理出所有 $f$，直接计算是 $O(Tm\log m)$ 的，显然过不了。

但是，$f$ 里面除了向下取整还有 $d$，不能整除分块。怎么办？

## step 2：优化

其实这里有人就能看出来了：这个式子和[毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240)的式子长得几乎一模一样，就连不能整除分块的原因都一样！

考虑非常典型的优化，把整个答案设成函数 $h(a,b,t)=\sum\limits_{i=1}^t\sum\limits_{d|i}\mu(d)f(d,a)f(d,b)$。

现在我们可以把答案拆成若干 $\lfloor\dfrac n i\rfloor$ 与 $\lfloor\dfrac m i\rfloor$ 相等的段，然后用 $h$ 这个前缀和函数算贡献。若该段的两个端点为 $l,r$，则对答案的贡献为 $h(\lfloor\dfrac n r\rfloor,\lfloor\dfrac m r\rfloor,r)-h(\lfloor\dfrac n{l-1}\rfloor,\lfloor\dfrac m{l-1}\rfloor,l-1)$。

这玩意就可以整除分块了。

但是，预处理 $h$ 的方法只能递推，如果求出所有复杂度是 $O(nm^2\log m)$ 的，更加不能接受。

当 $h(a,b,t)$ 中 $a,b$ 较小时，我们调用 $h$ 的次数多，但计算 $h$ 的时间却比较小。因此考虑根号分治，对于 $a,b\le B$ 的暴力计算，其他整除分块。

枚举 $a,b,t$ 和 $t$ 的倍数，预处理时间复杂度为 $O(B^2 m\log m)$，查询时间复杂度为 $O(T\dfrac{m\log m}B)$。根号平衡一下，取 $B\approx m^{\frac 1 3}$，得到时间复杂度为 $O(m^{\frac 5 3}\log m+Tm^{\frac 2 3}\log m)$。可以接受。

## step 3：附上代码

大量使用 vector 导致常数巨大，要开 O2。

代码里取 $B=50$。

模数很小甚至两数乘积都不爆 int，所以不用开 long long。

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
using namespace std;
const int MOD=23333;
const int MAXN=5e4,LIM=50;
int T,n,m;
vector<int>f[MAXN+1];
vector<int>h[LIM+1][LIM+1];
bool vis[MAXN+1];
vector<int>prime;
int phi[MAXN+1];
short mu[MAXN+1];
inline void init(){
	vis[1]=phi[1]=mu[1]=1;
	F(i,2,MAXN){
		if(!vis[i]){
			prime.push_back(i),phi[i]=i-1,mu[i]=-1;
			phi[i]>=MOD&&(phi[i]-=MOD);
		}
		for(int j:prime){
			ll h=1ll*i*j;
			if(h>MAXN) break;
			vis[h]=1;
			if(i%j){
				phi[h]=phi[i]*(j-1),mu[h]=-mu[i];
				phi[h]>=MOD&&(phi[h]-=MOD);
			}else{
				phi[h]=phi[i]*j;
				phi[h]>=MOD&&(phi[h]-=MOD);
				break;
			}
		}
	}
	F(t,1,MAXN){
		f[t].push_back(0);
		for(int i(t),cnt(1);i<=MAXN;i+=t,++cnt){
			f[t].push_back(f[t][cnt-1]+phi[i]);
			int&qwq(f[t][cnt]);
			qwq>=MOD&&(qwq-=MOD);
		}
	}
	F(a,1,LIM) F(b,1,LIM){
		h[a][b].resize(min(MAXN/a,MAXN/b)+1);
		for(int t(1);t*a<=MAXN&&t*b<=MAXN;++t) for(int k(t);k*a<=MAXN&&k*b<=MAXN;k+=t){
			int&qwq(h[a][b][k]);
			qwq+=f[t][a]*f[t][b]%MOD*mu[t]%MOD;
			qwq>=MOD&&(qwq-=MOD);
			qwq<0&&(qwq+=MOD);
		}
		for(int i(1);i*a<=MAXN&&i*b<=MAXN;++i){
			h[a][b][i]+=h[a][b][i-1];
			h[a][b][i]>=MOD&&(h[a][b][i]-=MOD);
		}
	}
	return;
}
inline int solve(){
	int ans(0),t(m/LIM);
	F(i,1,t) for(int j(i);j<=t;j+=i){
		ans+=1ll*mu[i]*f[i][n/j]%MOD*f[i][m/j]%MOD;
		ans>=MOD&&(ans-=MOD);
		ans<0&&(ans+=MOD);
	}
	for(int l=t+1,r;l<=n;l=r+1){
		r=min(n/(n/l),m/(m/l));
		ans+=h[n/l][m/l][r]-h[n/l][m/l][l-1]%MOD;
		ans>=MOD&&(ans-=MOD);
		ans<0&&(ans+=MOD);
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	init();
	for(cin>>T;T;--T){
		cin>>n>>m;
		n^=m,m^=n,n^=m;
		cout<<solve()<<"\n";
	} 
	return 0;
}
```

完结撒花 0w0~

---

## 作者：Lucky_Xiang (赞：2)

# 题目

[P5572](https://www.luogu.com.cn/problem/P5572)

# 分析

先按照套路，进行变换：

$$


\begin{aligned}


\text{原式}&=\sum_{i=1}^n\sum_{j=1}^m\varphi\bigg({\operatorname{lcm}(i,j)\over\gcd(i,j)}\bigg)

\\&=\sum_{i=1}^n\sum_{j=1}^m\varphi\bigg({ij\over\gcd^2(i,j)}\bigg)

\\&=\sum_d\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(ij)[i\bot j]

\\&=\sum_d\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(i)\varphi(j)[i\bot j]

\\&=\sum_d\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(i)\varphi(j)\sum_{t\mid\gcd(i,j)}\mu(t)

\\&=\sum_d\sum_t\mu(t)\sum_{i=1}^{\lfloor {n\over dt}\rfloor}\varphi(it)\sum_{j=1}^{\lfloor {m\over dt}\rfloor}\varphi(jt)

\\&=\sum_T\sum_{t\mid T}\mu(t)\sum_{i=1}^{\lfloor {n/ T}\rfloor}\varphi(it)\sum_{j=1}^{\lfloor {m/ T}\rfloor}\varphi(jt)

\end{aligned}$$

不妨设 $S(x,y)=\sum_{i=1}^x\varphi(iy)$。因为 $xy\le5\times10^4$，所以可以把所有的 $S(x,y)$ 全部先预处理出来。

再设 $G(T,x,y)=\sum_{t\mid T}\mu(t)S(x,t)S(y,t)$，则最终答案是 $\sum_T G(T,\lfloor n/T\rfloor,\lfloor m/T\rfloor)$。

但是，$G(T,x,y)$ 的状态量过大，不可能全部存下。于是，可以考虑设一个阈值 $B$，当 $T\le B$ 时暴力计算；而当 $T>B$ 时，因为 $Tx,Ty\le 5\times 10^4$，所以 $x,y$ 不会太大，暴力存储所有 $G(T,x,y)$ 的值，并用数论分块计算即可。

# 代码

为了方便计算，代码中 $S$ 的两维是反的，$G$ 的第一维被放在了最后。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=23333;
const int mn=50010;
const int N=50000;
const int B=500;
int T,n,m;
int p[mn],tot;
bool st[mn];
int mu[mn],phi[mn];
vector<int>D[mn];
vector<int>S[mn];
vector<int>G[110][110];
void init()
{
    mu[1]=phi[1]=1;
    for(int i=2;i<=N;i++)
    {
        if(!st[i])p[++tot]=i, mu[i]=-1, phi[i]=(i-1)%mod;
        for(int j=1;i*p[j]<=N;j++)
        {
            int k=i*p[j];
            st[k]=1;
            if(i%p[j]==0)
            {
                mu[k]=0;
                phi[k]=phi[i]*p[j]%mod;
                break;
            }
            mu[k]=-mu[i];
            phi[k]=phi[i]*(p[j]-1)%mod;
        }
    }
    for(int i=1;i<=N;i++)
    {
        for(int j=i;j<=N;j+=i)
        {
            D[j].push_back(i);
        }
    }
    for(int y=1;y<=N;y++)
    {
        S[y].push_back(0);
        int sum=0;
        for(int x=1;x*y<=N;x++)
        {
            sum+=phi[x*y];
            sum%=mod;
            S[y].push_back(sum);
        }
    }
    for(int i=1;i<=N/B;i++)
    {
        for(int j=1;j<=N/B;j++)
        {
            G[i][j].push_back(0);
            for(int T=B+1;T*max(i,j)<=N;T++)
            {
                int sum=0;
                for(int t:D[T])
                {
                    sum+=mu[t]*S[t][i]%mod*S[t][j]%mod;
                    sum%=mod;
                }
                G[i][j].push_back(sum);
            }
        }
    }
    for(int i=1;i<=N/B;i++)
    {
        for(int j=1;j<=N/B;j++)
        {
            for(int k=1;k<(int)G[i][j].size();k++)
            {
                G[i][j][k]+=G[i][j][k-1];
                G[i][j][k]%=mod;
            }
        }
    }
}
int res;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    init();
    cin>>T;
    while(T--)
    {
        cin>>n>>m;
        if(n>m)swap(n,m);
        res=0;
        for(int T=1;T<=min(n,B);T++)
        {
            for(int t:D[T])
            {
                res+=mu[t]*S[t][n/T]%mod*S[t][m/T]%mod;
                res%=mod;
            }
        }
        if(n>B)
        {
            for(int L=B+1,R=0;L<=n;L=R+1)
            {
                R=min(n/(n/L),m/(m/L));
                res+=G[n/L][m/L][R-B]-G[n/L][m/L][L-B-1];
                res%=mod;
            }
        }
        res=(res%mod+mod)%mod;
        cout<<res<<endl;
    }
    return 0;
}
```

---

## 作者：orz_z (赞：2)

### [P5572 [CmdOI2019]简单的数论题](https://www.luogu.com.cn/problem/P5572)

求：
$$
\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(\frac{\operatorname{lcm}(i,j)}{\gcd(i,j)})\bmod 23333
$$
$T$ 组数据，满足 $T \leq 3 \times 10^4,m \leq n \leq 5 \times 10^4$。

下面默认 $n \leq m$。

先化简原式，有：
$$
\begin{aligned}
\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(\frac{\operatorname{lcm}(i,j)}{\gcd(i,j)})&=\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(\frac{i \times j}{\gcd(i,j)^2})\\
&=\sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}\varphi(\frac{i \times j}{d^2})[\gcd(i,j)=d]\\
&=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(i\times j)[\gcd(i,j)=1]\\
&=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(i)\varphi(j)[\gcd(i,j)=1]\\
&=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(i)\varphi(j)\sum_{p|\gcd(i,j)}\mu(p)\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\varphi(i)\varphi(j)[p|i][p|j]\\
&=\sum_{d=1}^{n}\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p) \sum_{i=1}^{\lfloor\frac{n}{pd}\rfloor}\varphi(ip)\sum_{j=1}^{\lfloor\frac{m}{pd}\rfloor}\varphi(jp)\\
&=\sum_{T=1}^{n}\sum_{p|T}\mu(p)\sum_{i=1}^{\lfloor\frac{n}{T}\rfloor}\varphi(ip)\sum_{j=1}^{\lfloor\frac{m}{T}\rfloor}\varphi(jp)
\end{aligned}
$$
设：
$$
G(x,y)=\sum_{i=1}^{x}\varphi(iy)
$$
暴力预处理即可。

那么原式等于：
$$
\sum_{T=1}^{n}\sum_{p|T}\mu(p)G(\lfloor\frac{n}{T}\rfloor,p)G(\lfloor\frac{m}{T}\rfloor,p)
$$
再设：
$$
H(x,y,z)=\sum_{i=1}^{z}\sum_{p|i}\mu(p)G(x,p)g(y,p)
$$
然后跟 [P4240 毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240) 差不多，将答案表示为关于 $H$ 的差分加下取整的形式。

再考虑根号分治，我们设一个阈值，将所有范围内的 $H$ 值递推预处理出来。

后面的再数论分块算。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if(x < 0)
	{
		putchar('-');
		x = -x;
	}
	if(x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int p = 23333;

const int _ = 5e4 + 7;

int T, n, m;

bool vis[_];

int cnt, pr[_], phi[_], mu[_];

const int B = 72;

vector<int> G[_], H[B + 10][B + 10], fac[_];

int calc(int x, int y, int z)
{
    int ans = 0;
    for (int o : fac[z])
        ans = (ans + mu[o] * G[o][x] % p * G[o][y]) % p + p;
    return ans % p;
}

void init()
{
	for (int i = 1; i <= _ - 7; i++)
    	for (int j = i; j <= _ - 7; j += i)
        	fac[j].push_back(i);
	phi[1] = mu[1] = 1;
	for(int i = 2; i <= _ - 7; ++i)
	{
		if(!vis[i])
		{
			pr[++cnt] = i;
			phi[i] = i - 1;
			mu[i] = -1;
		}
		for(int j = 1; j <= cnt && i * pr[j] <= _ - 7; ++j)
		{
			int p = i * pr[j];
			vis[p] = 1;
			if(i % pr[j] == 0)
			{
				phi[p] = phi[i] * pr[j];
				mu[p] = 0;
				break;
			}
			phi[p] = phi[i] * (pr[j] - 1);
			mu[p] = -mu[i];
		}
	}
	for (int i = 1; G[i].push_back(0), i <= _ - 7; ++i)
		for (int j = 1; j * i <= _ - 7; ++j)
			G[i].push_back((G[i][j - 1] + phi[i * j]) % p);
	for (int i = 1; i <= B; ++i)
		for (int j = 1; j <= B; ++j)
		{
			H[i][j].push_back(0);
			for (int k = 1; k <= (_ - 7) / max(i, j); ++k)
				H[i][j].push_back((H[i][j][k - 1] + calc(i, j, k)) % p);
		}
}

signed main()
{
	init();
	T = read();
	while(T--)
	{
		n = read(), m = read();
		if(n > m) swap(n, m);
		int ans = 0;
		for(int i = 1; i <= m / B; ++i)
			ans = (ans + calc(n / i, m / i, i)) % p;
		for(int l = m / B + 1, r; l <= n; l = r + 1)
		{
			r = min(n / (n / l), m / (m / l));
			ans = (ans + H[n / l][m / l][r] - H[n / l][m / l][l - 1] + p) % p;
		}
		write(ans % p);
		putchar('\n');
	}
	return 0;
}
```



---

## 作者：王熙文 (赞：1)

看这题数据范围还以为正解就是 $\mathcal O(T n^{\frac{3}{4}})$ 的，然后我生生卡常卡过去了（

## 思路

下文设 $w=5 \cdot 10^4$。

题目要求：

$$\sum_{i=1}^n \sum_{j=1}^m \varphi\left(\dfrac{\text{lcm}(i,j)}{\gcd(i,j)}\right)$$

$$=\sum_{i=1}^n \sum_{j=1}^m \varphi \left( \dfrac{i}{\gcd(i,j)} \cdot \dfrac{j}{\gcd(i,j)}\right)$$

注意到 $\gcd\left(\dfrac{i}{\gcd(i,j)},\dfrac{j}{\gcd(i,j)}\right)=1$，且 $\varphi$ 是积性函数，所以原式

$$=\sum_{i=1}^n \sum_{j=1}^m \varphi \left( \dfrac{i}{\gcd(i,j)}\right) \cdot \varphi \left(\dfrac{j}{\gcd(i,j)}\right)$$

$$=\sum_{d=1}^{m}\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{m}{d}\rfloor}[\gcd(i,j)=1] \varphi(i)\varphi(j)$$

设

$$f(n,m)=\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1] \varphi(i)\varphi(j)$$

则原式

$$=\sum_{d=1}^m f\left(\left\lfloor \dfrac{n}{d}\right\rfloor,\left\lfloor \dfrac{m}{d}\right\rfloor\right)$$

现在考虑求 $f(n,m)$：

$$f(n,m)=\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1]\varphi(i)\varphi(j)$$

$$=\sum_{i=1}^n \sum_{j=1}^m \sum_{d|\gcd(i,j)} \mu(d) \varphi(i) \varphi(j)$$

$$=\sum_{d=1}^m\mu(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{m}{d}\rfloor} \varphi(id)\varphi(jd)$$

$$=\sum_{d=1}^m\mu(d)\left(\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \varphi(id) \right)\left(\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor} \varphi(jd)\right)$$

设

$$g(n,d)=\sum_{i=1}^n \varphi(id)$$

则

$$f(n,m)=\sum_{d=1}^m \mu(d) g\left(\left\lfloor \dfrac{n}{d}\right\rfloor\right)g\left(\left\lfloor \dfrac{m}{d}\right\rfloor\right)$$

因为 $nd \le w$，所以 $g$ 可以暴力预处理（$g(n,d)=g(n-1,d)+\varphi(nd)$）。

考虑对 $d$ 根号分治。当 $d \le B$ 时，可以 $\mathcal O(B)$ 暴力求；当 $d>B$ 时，$\left\lfloor \dfrac{m}{d}\right\rfloor \le \left\lfloor \dfrac{n}{d}\right\rfloor \le \dfrac{n}{B}$，这样就可以预处理了。预处理

$$h(n,m,k)=\sum_{d=1}^k \mu(d)g(n)g(m)$$

对于 $\left\lfloor \dfrac{n}{d}\right\rfloor$ 和 $\left\lfloor \dfrac{m}{d}\right\rfloor$ 都一定时，求出来 $d$ 的区间并用 $h$ 函数减一下即可。

但是 $h$ 函数可以预处理出来吗？因为 $nk \le w$，所以 $h$ 函数一共只有 $h$ 函数一共有 $\mathcal O\left(\sum\limits_{i=1}^{\frac{n}{B}} \sum\limits_{j=1}^{i} \left \lfloor \dfrac{w}{i}\right\rfloor\right)=O(\dfrac{n}{B} w)$ 种 $n,m,k$。

取 $B=\sqrt{n}$，这样就可以 $\mathcal O(\sqrt{n})$ 求出来 $f$ 函数了。外面还有一个整除分块，因为整除分块套整除分块的复杂度为 $\mathcal O(n^{\frac{3}{4}})$，所以询问的复杂度为 $\mathcal O(Tn^{\frac{3}{4}})$。因为 $n$ 最大为 $w$，所以预处理的复杂度为 $\mathcal O(w \sqrt{w})$。

我以为这个数据范围就是这么做的，就没有想优化了，结果交上去 T 飞了。但是我生生地将这个错解卡过去了。以下是这个做法的卡常方法：

* 少用 ```long long```。

* 注意到 $n\ge m$，所以预处理 $h$ 的时候只需要预处理 $i \ge j$ 的。

* 预处理 $\text{inv}_i =\dfrac{1}{i}$，然后对于每一个 $\dfrac{a}{b}$ 变成 $a \cdot \text{inv}_b$。

* 求 $f$ 函数时 $B$ 要动态取，否则复杂度会退化。

* 当 $d\le B$ 时不用整除分块，而是直接循环过去。

* 因为整除分块常数大，因此将 $B$ 调大，我设的 $B=\sqrt{12n}$。

## 代码

这里有两份代码，一份是毫无卡常的（方便理解），另一份是可以通过的。

代码中的 ```ycl``` 是 $h$ 函数。

毫无卡常的：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
bitset<50010> vis;
int tot=0,pr[50010];
int phi[50010],miu[50010];
vector<int> g[50010];
vector<int> ycl[231][231];
void init()
{
	phi[1]=miu[1]=1;
	for(int i=2; i<=5e4; ++i)
	{
		if(!vis[i]) pr[++tot]=i,phi[i]=i-1,miu[i]=-1;
		for(int j=1; j<=tot && i*pr[j]<=5e4; ++j)
		{
			vis[i*pr[j]]=1;
			if(i%pr[j]==0)
			{
				phi[i*pr[j]]=phi[i]*pr[j];
				miu[i*pr[j]]=0;
				break;
			}
			phi[i*pr[j]]=phi[i]*(pr[j]-1);
			miu[i*pr[j]]=-miu[i];
		}
	}
	for(int i=1; i<=5e4; ++i)
	{
		g[i].resize(5e4/i+1);
		for(int j=1; j<=5e4/i; ++j) g[i][j]=(i==1?0:g[i-1][j])+phi[i*j];
	}
	for(int i=1; i<=230; ++i)
	{
		for(int j=1; j<=i; ++j)
		{
			int d=min(5e4/i,5e4/j);
			ycl[i][j].resize(d+1);
			for(int k=1; k<=d; ++k) ycl[i][j][k]=ycl[i][j][k-1]+1ll*miu[k]*g[i][k]*g[j][k];
		}
	}
}
int n,m;
int f(int n,int m)
{
	int B=sqrt(n);
	int ans=0;
	for(int l=1,r; l<=min(n,m); l=r+1)
	{
		int tmp1=n/l,tmp2=m/l;
		r=min(n/tmp1,m/tmp2);
		if(r<=B) for(int j=l; j<=r; ++j) ans+=1ll*miu[j]*g[tmp1][j]*g[tmp2][j];
		else ans+=ycl[tmp1][tmp2][r]-ycl[tmp1][tmp2][l-1];
	}
	return ans;
}
signed main()
{
	init();
	int t; cin>>t; while(t--)
	{
		cin>>n>>m;
		int ans=0;
		for(int l=1,r; l<=min(n,m); l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			ans+=(r-l+1)*f(n/l,m/l);
		}
		cout<<ans%23333<<'\n';
	}
	return 0;
}
```

可以通过的：

```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<50010> vis;
int tot=0,pr[50010];
int phi[50010],miu[50010];
vector<int> g[50010];
vector<long long> ycl[101][101];
double inv[50010];
void init()
{
	phi[1]=miu[1]=1;
	for(int i=2; i<=5e4; ++i)
	{
		if(!vis[i]) pr[++tot]=i,phi[i]=i-1,miu[i]=-1;
		for(int j=1; j<=tot && i*pr[j]<=5e4; ++j)
		{
			vis[i*pr[j]]=1;
			if(i%pr[j]==0)
			{
				phi[i*pr[j]]=phi[i]*pr[j];
				miu[i*pr[j]]=0;
				break;
			}
			phi[i*pr[j]]=phi[i]*(pr[j]-1);
			miu[i*pr[j]]=-miu[i];
		}
	}
	for(int i=1; i<=5e4; ++i)
	{
		g[i].resize(5e4/i+1);
		for(int j=1; j<=5e4/i; ++j) g[i][j]=(i==1?0:g[i-1][j])+phi[i*j];
	}
	for(int i=1; i<=100; ++i)
	{
		for(int j=1; j<=i; ++j)
		{
			int d=min(5e4/i,5e4/j);
			ycl[i][j].resize(d+1);
			for(int k=1; k<=d; ++k) ycl[i][j][k]=ycl[i][j][k-1]+1ll*miu[k]*g[i][k]*g[j][k];
		}
	}
	for(int i=1; i<=5e4; ++i) inv[i]=1.0/i;
}
int n,m;
long long f(int n,int m)
{
	int B=sqrt(n*12);
	long long ans=0;
	for(int i=1; i<=min(B,m); ++i) ans+=1ll*miu[i]*g[(int)(n*inv[i]+1e-10)][i]*g[(int)(m*inv[i]+1e-10)][i];
	for(int l=B+1,r; l<=m; l=r+1)
	{
		int tmp1=n*inv[l]+1e-10,tmp2=m*inv[l]+1e-10;
		r=min(n*inv[tmp1]+1e-10,m*inv[tmp2]+1e-10);
		ans+=ycl[tmp1][tmp2][r]-ycl[tmp1][tmp2][l-1];
	}
	return ans;
}
int main()
{
	init();
	int t; cin>>t; for(int i=1; i<=t; ++i)
	{
		cin>>n>>m;
		long long ans=0;
		for(int l=1,r; l<=m; l=r+1)
		{
			int tmp1=n*inv[l]+1e-10,tmp2=m*inv[l]+1e-10;
			r=min(n*inv[tmp1]+1e-10,m*inv[tmp2]+1e-10);
			ans+=(r-l+1)*f(tmp1,tmp2);
		}
		cout<<ans%23333<<'\n';
	}
	return 0;
}
```

---

## 作者：Phartial (赞：1)

以下设 $n\le m$。

我们有

$$
\begin{aligned}
  &\sum_{i=1}^n\sum_{j=1}^m\varphi(\frac{\operatorname{lcm}(i,j)}{\gcd(i,j)})\\
  =&\sum_{i=1}^n\sum_{j=1}^m\varphi(\frac{ij}{\gcd(i,j)^2})\\
  =&\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m\varphi(\frac{ij}{d^2})[\gcd(i,j)=d]\\
  =&\sum_{d=1}^n\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(ij)[\gcd(i,j)=1]\\
\end{aligned}
$$

由 $\gcd(i,j)=1$，我们有 $\varphi(ij)=\varphi(i)\varphi(j)$。于是有

$$
\begin{aligned}
  &\sum_{d=1}^n\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(ij)[\gcd(i,j)=1]\\
  =&\sum_{d=1}^n\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\varphi(i)\varphi(j)\sum_{p\mid i,p\mid j}\mu(p)\\
  =&\sum_{d=1}^n\sum_{p=1}^{\lfloor n/d\rfloor}\mu(p)\sum_{i=1}^{\lfloor n/dp\rfloor}\varphi(ip)\sum_{j=1}^{\lfloor m/dp\rfloor}\varphi(jp)\\
  =&\sum_{t=1}^n\sum_{p\mid t}\mu(p)\sum_{i=1}^{\lfloor n/t\rfloor}\varphi(ip)\sum_{j=1}^{\lfloor m/t\rfloor}\varphi(jp) & t=dp\\
\end{aligned}
$$

设 $g(k,n)=\displaystyle\sum_{i=1}^{n}\varphi(ik)$，由于 $ik\le m$，显然此式只有 $O(n\log n)$ 种取值，可以直接预处理。

那么有

$$
\begin{aligned}
  &\sum_{t=1}^n\sum_{p\mid t}\mu(p)\sum_{i=1}^{\lfloor n/t\rfloor}\varphi(ip)\sum_{j=1}^{\lfloor m/t\rfloor}\varphi(jp)\\
  =&\sum_{t=1}^n\sum_{p\mid t}\mu(p)g(p,\lfloor n/t\rfloor)g(p,\lfloor m/t\rfloor)\\
\end{aligned}
$$

再设 $h(a,b,n)=\displaystyle\sum_{i=1}^n\sum_{p\mid i}\mu(p)g(p,a)g(p,b)$。

那么按 [P4240](https://wsfxk.blog.luogu.org/solution-p4240) 的套路做就行了。

注意预处理 $h$ 的时候我们需要先预处理 $\displaystyle\sum_{p\mid i}\mu(p)g(p,a)g(p,b)$，预处理瓶颈就在这里，计算一下，有

$$
\begin{aligned}
  &O(\sum_{i=1}^B\sum_{j=1}^B\sum_{p=1}^{n/j}n/jp)\\
  =&O(n\sum_{i=1}^B\sum_{j=1}^B1/j\sum_{p=1}^{n/j}1/p)\\
  =&O(n\sum_{i=1}^B\ln(B)\ln(n))\\
  =&O(nB\ln(B)\ln(n))\\
\end{aligned}
$$

总时间复杂度即为 $O(n\log n+nB\log B\log n+T(n/B\log(n/B)+\sqrt{n}))$，最优的 $B$ 满足 $B^2\log B=T$，近似解为 $B=80$。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kM = 23333;
const int kN = 5e4 + 1, kB = 81;

int t, n, m, phi[kN], mu[kN];
vector<int> g[kN], h[kB][kB], hf[kB][kB];
bool v[kN];
vector<int> pri;

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  mu[1] = phi[1] = 1;
  for (int i = 2; i < kN; ++i) {
    if (!v[i]) {
      pri.push_back(i), phi[i] = i - 1, mu[i] = -1;
    }
    for (int j : pri) {
      int k = i * j;
      if (k >= kN) {
        break;
      }
      v[k] = 1;
      if (i % j) {
        mu[k] = -mu[i], phi[k] = phi[i] * (j - 1);
      } else {
        mu[k] = 0, phi[k] = phi[i] * j;
        break;
      }
    }
  }
  for (int i = 1; i < kN; ++i) {
    phi[i] %= kM;
  }
  for (int k = 1; k < kN; ++k) {
    g[k].push_back(0);
    for (int i = 1; i * k < kN; ++i) {
      g[k].push_back((g[k].back() + phi[i * k]) % kM);
    }
  }
  for (int i = 1; i < kB; ++i) {
    for (int j = i; j < kB; ++j) {
      hf[i][j].resize((kN - 1) / j + 1);
      for (int p = 1; p < hf[i][j].size(); ++p) {
        int s = mu[p] * g[p][i] % kM * g[p][j] % kM + kM;
        for (int k = p; k < hf[i][j].size(); k += p) {
          hf[i][j][k] = (hf[i][j][k] + s) % kM;
        }
      }
      h[i][j].push_back(0);
      for (int k = 1; j * k < kN; ++k) {
        h[i][j].push_back((h[i][j].back() + hf[i][j][k]) % kM);
      }
    }
  }
  for (cin >> t; t--;) {
    cin >> m >> n;
    int ans = 0;
    for (int d = 1; d <= m / kB; ++d) {
      for (int l = d; l <= m / kB; l += d) {
        ans = (ans + mu[d] * g[d][n / l] % kM * g[d][m / l] % kM + kM) % kM;
      }
    }
    for (int l = m / kB + 1, r; l <= n; l = r + 1) {
      r = min(n / (n / l), m / (m / l));
      ans = (ans + (h[n / r][m / r][r] - h[n / r][m / r][l - 1] + kM)) % kM;
    }
    cout << ans << '\n';
  }
  return 0;
}
```

---

## 作者：mango09 (赞：1)

[P5572 [CmdOI2019]简单的数论题](https://www.luogu.com.cn/problem/P5572)

思路基本同 [P4240 毒瘤之神的考验](https://www.luogu.com.cn/problem/P4240)。

## Description

- 多测，$T$ 组数据。

- 给定整数 $n, m$，请求出
  $$
  \left[\sum_{i = 1}^n \sum_{j = 1}^m \varphi\left(\dfrac{\operatorname{lcm}(i, j)}{\gcd(i, j)} \right) \right] \bmod 23333
  $$

- $T\le 3\times 10^4, m\le n\le 5\times 10^4$。

## Solution

不妨设 $n\le m$。
$$
\begin{aligned}
ans
& = \sum_{d = 1}^n \sum_{i = 1}^n \sum_{j = 1}^m \varphi\left(\dfrac{ij}{d^2} \right) [\gcd(i, j) = d] \\
& = \sum_{d = 1}^n \sum_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \sum_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} \varphi(ij) [\gcd(i, j) = 1] \\
& = \sum_{d = 1}^n \sum_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \varphi(i) \sum_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} \varphi(j) [\gcd(i, j) = 1] \\
& = \sum_{d = 1}^n \sum_{k = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(k) \sum_{i = 1}^{\left\lfloor\frac{n}{dk}\right\rfloor} \varphi(ik) \sum_{j = 1}^{\left\lfloor\frac{m}{dk}\right\rfloor} \varphi(jk) \\
& = \sum_{T = 1}^n \sum_{k\mid T} \mu(k) \sum_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} \varphi(ik) \sum_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor} \varphi(jk)
\end{aligned}
$$
套路地设出来
$$
f(k, n) = \sum_{i = 1}^n \varphi(ik)
$$
那么
$$
ans = \sum_{T = 1}^n \sum_{k\mid T} \mu(k) f\left(k, \left\lfloor\dfrac{n}{T}\right\rfloor \right) f\left(k, \left\lfloor\dfrac{m}{T}\right\rfloor \right)
$$
又有递推式
$$
f(k, n) = f(k, n - 1) + \varphi(nk)
$$
即 $f$ 可以在 $\Theta(n\ln n)$ 时间内预处理。

但是这个 $f$ 带一个 $k$，无法整除分块，只能暴力，所以查询是 $\Omicron(T\sum\limits_{i = 1}^n \dfrac{n}{i}) \simeq \Omicron(T n\ln n)$ 的。

------

我们想要整除分块，那就弄个前缀和。

把整个表示出来
$$
g(n, m, l) = \sum_{i = 1}^l \sum_{k\mid i} \mu(k) f(k, n) f(k, m)
$$
那么整除分块大概长这样
$$
g\left(\left\lfloor\dfrac{n}{l}\right\rfloor, \left\lfloor\dfrac{m}{l}\right\rfloor, r \right) - g\left(\left\lfloor\dfrac{n}{l}\right\rfloor, \left\lfloor\dfrac{m}{l}\right\rfloor, l - 1 \right)
$$
同样有递推式
$$
g(n, m, l) = g(n, m, l - 1) + \sum_{k\mid l} \mu(k) f(k, n) f(k, m)
$$
预处理是
$$
\Omicron\left(n \sum_{i = 1}^n \left(\sum_{j = 1}^{\frac{n}{i}} \dfrac{n}{j}\right) + \dfrac{n}{i} \right) \simeq \Omicron(n^3)
$$
会 $\rm TLE + MLE$。

但是它能够做到十分优秀的 $\Omicron(T \sqrt{n})$ 回答。

------

如果要将两种方法结合，那么就是大家喜闻乐见的 **根号分治** 了。

（其实题目背景已经有提示了）

> A:“数论,分块。”

设 $k$ 为阈值，表示预处理 $g(n, m, l)$ 时 $n, m$ 只处理到 $k$。

那么计算时对于 $l \le \left\lfloor\dfrac{n}{k}\right\rfloor$ 的直接暴力；对于 $l > \left\lfloor\dfrac{n}{k}\right\rfloor$ 的部分，有 $\left\lfloor\dfrac{n}{l}\right\rfloor \le k$，直接用预处理过的 $g$。

## Code

```cpp
//18 = 9 + 9 = 18.
#include <iostream>
#include <cstdio>
#include <vector> 
#define Debug(x) cout << #x << "=" << x << endl
typedef long long ll;
using namespace std;

const int MAXN = 5e4 + 5;
const int N = 5e4;
const int MAXK = 155;
const int K = 150;
const int MOD = 23333;
typedef int arr[MAXN];
int add(int a, int b) {return (a + b) % MOD;}
int sub(int a, int b) {return (a - b + MOD) % MOD;}
int mul(int a, int b) {return (ll)a * b % MOD;}

arr p, mu, phi;
bool vis[MAXN];
vector<int> f[MAXN], g[MAXK][MAXK];

void pre()
{
	mu[1] = phi[1] = 1;
	for (int i = 2; i <= N; i++)
	{
		if (!vis[i])
		{
			p[++p[0]] = i;
			mu[i] = MOD - 1;
			phi[i] = (i - 1) % MOD;
		}
		for (int j = 1; j <= p[0] && i * p[j] <= N; j++)
		{
			vis[i * p[j]] = true;
			if (i % p[j] == 0)
			{
				mu[i * p[j]] = 0;
				phi[i * p[j]] = mul(phi[i], p[j]);
				break;
			}
			mu[i * p[j]] = mul(mu[i], mu[p[j]]);
			phi[i * p[j]] = mul(phi[i], phi[p[j]]);
		}
	}
	
	for (int k = 1; k <= N; k++)
	{
		f[k].resize(N / k + 5);
		for (int n = 1; n <= N / k; n++)
		{
			f[k][n] = add(f[k][n - 1], phi[n * k]);
		}
	}
	
	for (int n = 1; n <= K; n++)
	{
		for (int m = n; m <= K; m++)
		{
			g[n][m].resize(N / m + 5);
			for (int i = 1; i <= N / m; i++)
			{
				int wjy = mul(mu[i], mul(f[i][n], f[i][m]));
				for (int j = 1; j <= N / m / i; j++)
				{
					g[n][m][i * j] = add(g[n][m][i * j], wjy);
				}
			}
			for (int l = 1; l <= N / m; l++)
			{
				g[n][m][l] = add(g[n][m][l], g[n][m][l - 1]);
			}
		}
	}
}

int block(int n, int m)
{
	if (n > m)
	{
		swap(n, m);
	}
	int res = 0, xsy = m / K;
	for (int i = 1; i <= xsy; i++)
	{
		for (int j = 1; j <= xsy / i; j++)
		{
			int t = i * j;
			res = add(res, mul(mu[i], mul(f[i][n / t], f[i][m / t])));
		}
	}
	for (int l = xsy + 1, r; l <= n; l = r + 1)
	{
		int k1 = n / l, k2 = m / l;
		r = min(n / k1, m / k2);
		res = add(res, sub(g[k1][k2][r], g[k1][k2][l - 1]));
	}
	return res;
}

int main()
{
	pre();
	int t;
	scanf("%d", &t);
	while (t--)
	{
		int n, m;
		scanf("%d%d", &n, &m);
		printf("%d\n", block(n, m));
	}
	return 0;
}
```



---


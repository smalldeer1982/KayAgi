# 基础数论函数练习题

## 题目背景

YSGH 牛逼

## 题目描述

给定长度为 $n$ 的数组 $a$，$Q$ 次询问 $\operatorname{lcm}(a_l, a_{l + 1}, \ldots , a_{r - 1}, a_r)$。

由于输出较大，你只需要输出答案对 ${10}^9 + 7$ 取模的值。

## 说明/提示

| 数据点编号 | $n, Q, T \le$ | $a_i \le$ |
| :--: | :--: | :--: |
| $1$ | $10$ | $10$ |
| $2$ | $20$ | $2^{60}$ |
| $3$ | $50$ | $2^{60}$ |
| $4$ | $100$ | $2^{60}$ |
| $5$ | $150$ | $2^{60}$ |
| $6$ | $200$ | $2^{60}$ |
| $7$ | $240$ | $2^{60}$ |
| $8$ | $260$ | $2^{60}$ |
| $9$ | $280$ | $2^{60}$ |
| $10$ | $300$ | $2^{60}$ |

对于 $100\%$ 的数据，$1 \le n, Q, T \le 300$，$1 \le a_i \le 2^{60}$。

## 样例 #1

### 输入

```
1
3 3
63
70
112
1 2
1 3
2 3```

### 输出

```
630
5040
560```

# 题解

## 作者：大头 (赞：21)

### 算法1

我们尝试将$lcm_{l,r}$表示为$r-l+1$个数字$b_i$的乘积，其中$b_i|a_i$。

考虑加入一个数字$a_{r+1}$，则我们需要求出$gcd(\Pi b_i,a_{r+1})$。这可以使用取模很方便的实现。

每次询问可以暴力插入所有$r-l+1$个数字。

时间复杂度$O(Tn^3)$。

code:
```cpp
#include<bits/stdc++.h>
#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)
#define ll long long
using namespace std;
const int N=505;
const int mo=1000000007;
int n,Q;
ll a[505],b[505];
ll gcd(ll x,ll y){
	return y?gcd(y,x%y):x;
}
void solve(){
	scanf("%d%d",&n,&Q);
	For(i,1,n) scanf("%lld",&a[i]);
	while (Q--){
		int l,r,ans=1;
		scanf("%d%d",&l,&r);
		For(i,l,r){
			b[i]=a[i];
			__int128 tmp=1; 
			For(j,l,i-1) tmp=tmp*b[j]%b[i];
			b[i]/=gcd(b[i],tmp);
			ans=b[i]%mo*ans%mo;
		}
		printf("%d\n",ans);
	}
}
int main(){
	int T;
	scanf("%d",&T);
	while (T--) solve();
} 

```

### 算法2

然后考虑优化，我们考虑对数组进行分治。

假设我们将数组$a[1\cdots n]$分成$a[1\cdots mid]$和$a[mid+1\cdots n]$。

则我们可以预处理出来$lcm_{i,mid}$和$lcm_{mid+1,i}$。这一部分可以$O(n^2)$预处理

同时我们不难发现，我们可以把这些$lcm看$成两个序列$A,B$，满足:

$$\Pi_{j=mid}^{j \geq i}A_i=lcm_{i,mid}$$

$$\Pi_{j=mid+1}^{j \leq i}B_i=lcm_{mid+1,r}$$

现在我们需要预处理出所有$A$的前缀积和$B$的前缀积的$lcm$,并转化为$gcd$

此时我们仍然可以将其转成$gcd(\Pi B_i,A_{j})$。

在求完之后我们可以算出$B_i$在这一轮中除去的值。

如果求$gcd$技巧不够高超复杂度会退化为$O(Tn^2logV)$。

如果求$gcd$高超则可以优化至$O(Tn(n+logV))$。

gcd技巧不够高超的做法:

```cpp
#include<bits/stdc++.h>
#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)
#define ll long long
using namespace std;
const int N=505;
const int mo=1000000007;
int n,Q;
ll a[N],b[N];
int ans[N][N];
ll gcd(ll x,ll y){
	return y?gcd(y,x%y):x;
}
ll mul(ll x,ll y,ll mo){
	y%=mo;
	ll t=x*y-(ll)((long double)x/mo*y+1e-9)*mo;
	return t<mo?t+mo:t;
} 
void solve(int l,int r){
	if (l==r){
		ans[l][l]=a[l]%mo;
		return;
	}
	int mid=(l+r)/2;
	solve(l,mid);
	solve(mid+1,r);
	For(i,mid+1,r){
		b[i]=a[i];
		ll tmp=1;
		For(j,mid+1,i-1) tmp=mul(tmp,b[j],b[i]);
		b[i]/=gcd(b[i],tmp);
	}
	Rep(i,mid,l){
		b[i]=a[i];
		ll tmp=1;
		For(j,i+1,mid) tmp=mul(tmp,b[j],b[i]);
		b[i]/=gcd(b[i],tmp);
	}
	int S1=1;
	Rep(i,mid,l){
		S1=b[i]%mo*S1%mo;
		int S2=S1;
		For(j,mid+1,r){
			ll v=gcd(b[i],b[j]);
			b[i]/=v; b[j]/=v;
			ans[i][j]=S2=b[j]%mo*S2%mo;
		}
	}
}
void solve(){
	scanf("%d%d",&n,&Q);
	For(i,1,n) scanf("%lld",&a[i]);
	solve(1,n);
	For(i,1,Q){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",ans[l][r]);
	} 
}
int main(){
	int T;
	scanf("%d",&T);
	while (T--) solve();
} 

```

code:
```cpp
#include<bits/stdc++.h>
#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)
#define ll long long
using namespace std;
const int N=505;
const int mo=1000000007;
int n,Q;
ll a[N],b[N],c[N];
int ans[N][N];
ll gcd(ll x,ll y){
	return y?gcd(y,x%y):x;
}
ll mul(ll x,ll y,ll mo){
	y%=mo;
	ll t=x*y-(ll)((long double)x/mo*y+1e-9)*mo;
	return t<mo?t+mo:t;
} 
void solve(int l,int r){
	if (l==r){
		ans[l][l]=a[l]%mo;
		return;
	}
	int mid=(l+r)/2;
	solve(l,mid);
	solve(mid+1,r);
	For(i,mid+1,r){
		b[i]=a[i];
		ll tmp=1;
		For(j,mid+1,i-1) tmp=mul(tmp,b[j],b[i]);
		b[i]/=gcd(b[i],tmp);
	}
	Rep(i,mid,l){
		b[i]=a[i];
		ll tmp=1;
		For(j,i+1,mid) tmp=mul(tmp,b[j],b[i]);
		b[i]/=gcd(b[i],tmp);
	}
	int S1=1;
	Rep(i,mid,l){
		S1=b[i]%mo*S1%mo;
		int S2=S1; c[mid]=1;
		For(j,mid+1,r) c[j]=mul(c[j-1],b[j],b[i]);
		ll G=gcd(c[r],b[i]),rem;
		Rep(j,r-1,mid) if (rem=c[j]%G){
			ll nG=gcd(G,rem);
			b[j+1]/=G/nG; G=nG;
		}
		For(j,mid+1,r)
			ans[i][j]=S2=b[j]%mo*S2%mo;
	}
}
void solve(){
	scanf("%d%d",&n,&Q);
	For(i,1,n) scanf("%lld",&a[i]);
	solve(1,n);
	For(i,1,Q){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",ans[l][r]);
	} 
}
int main(){
	int T;
	scanf("%d",&T);
	while (T--) solve();	
}

```

---

## 作者：qwaszx (赞：15)

orz EMT__Mashiro

通过连续使用 $\mathrm{lcm}(a,b)=a\cdot \dfrac{b}{\gcd(a,b)}$，我们可以将$\mathrm{lcm}(a_1,a_2,\cdots ,a_m)$ 表为若干 $b_i$ 的乘积，即

$$
b_m=a_m,b_i=\frac{a_i}{\gcd(a_i,\prod_{j>i}b_j)}(i<m)
$$

直观的理解就是把 $a_i$ 除掉后面已经计算了的部分. 对应到每个质因子上，相当于对指数先做后缀 $\max$，然后再做后向的差分，因此只要做后缀的乘积即可算出后缀 $\max$.（对于下面的部分，这样理解会更加容易）.

考虑在最右边增加一个 $a_{m+1}$ 之后造成的影响，首先有 $b_{m+1}'=a_{m+1}$,然后对于剩下的 $b$，应该是在原有的 $b$ 上再除掉一个因子. 具体地，有

$$
b_i'=\frac{b_i}{\gcd(b_i,\prod_{j>i}b_j')}
$$

令 $c_i=b_i/b_i'$，我们有

$$
c_i=\gcd(b_i,a_{m+1}/\prod_{j>i}c_j)
$$

意思是说 $a_{m+1}$ 在前面已经除掉了 $\prod_{j>i}c_j$，把剩下的部分和 $b_i$ 取一个 $\gcd$ 就得到 $c_i$.

直接按照这个做，每次令右端点加一，然后算出所有 $b_i$，复杂度 $O(Tn^2\log w)$，瓶颈在于 $c$ 的计算.

考虑对每个右端点，不为 $1$ 的 $c$ 只有 $O(\log w)$ 个（因为每次 $c\neq 1$ 都会使得 $a_{m+1}$ 至少除以 $2$）. 所以现在我们的目标是快速判断这个位置的 $c$ 是否为 $1$. 

令 $s_i=\prod_{i\leq j\leq m}b_j'$，我们有 $\gcd(s_i,a_{m+1})=\prod_{i\leq j\leq m}c_j$. 那么如果 $\gcd(s_i,a_{m+1})\neq \gcd(s_{i+1},a_{m+1})$，我们就知道 $c_i\neq 1$. 我们断言 $\gcd(s_i,a_{m+1})\neq \gcd(s_{i+1},a_{m+1})$ 当且仅当 $s_{i+1}\bmod \gcd(s_i,a_{m+1})\neq 0$，这个可以通过对每个质因子独立考虑来证明. 取模可以通过 $(s_{i+1}\bmod a_{m+1})\bmod \gcd(s_i,a_{m+1})$ 来完成. 这样我们就只需要进行 $O(n\log w)$ 次求 $\gcd$，总复杂度 $O(Tn(n+\log^2 w))$，常数很小.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=500,mod=1000000007;
int T,n,qn;
long long tmp[N],a[N];
int ans[N][N];
long long gcd(long long a,long long b){return b?gcd(b,a%b):a;}
long long mul(long long a,long long b,long long m)
{
    long long t=a*b-(long long)((long double)a/m*b)*m;
    if(t<0)t+=m;else if(t>=m)t-=m;
    return t;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&qn);
        for(int i=1;i<=n;i++)
        {
            scanf("%lld",a+i);
            tmp[i]=1;for(int j=i-1;j>=1;j--)tmp[j]=mul(tmp[j+1],a[j],a[i]);
            long long t=gcd(tmp[1],a[i]);
            for(int j=1;j<i;j++)
                if(tmp[j+1]%t)
                {
                    long long g=gcd(tmp[j+1],t);
                    a[j]/=t/g,t=g;
                }
            ans[i][i]=a[i]%mod;
            for(int j=i-1;j>=1;j--)ans[j][i]=1ll*ans[j+1][i]*((a[j]%mod))%mod;
        }
        for(int i=1,l,r;i<=qn;i++)
        {
            scanf("%d%d",&l,&r),printf("%d\n",ans[l][r]);
        }
    }
}
```

---

## 作者：18Michael (赞：7)

chen_03 Orz！

## 题意

给定长度为 $n$ 的数组 $a$，$Q$ 次询问 $\operatorname{lcm}\left(a_l, a_{l + 1}, \ldots , a_{r - 1}, a_r\right)$，对 ${10}^9 + 7$ 取模。

## 题解

对于每个右端点，我们维护每个左端点的答案。

具体的，设当前右端点为 $m$，我们尝试找到数列 $b_i$ 使得区间 $[i,m]$ 的答案为 $\prod_{j=i}^{m}b_j$，显然 $b_{i}|a_{i}$。

假设我们已求出右端点为 $m-1$ 时的数组 $b$，现在尝试求出右端点为 $m$ 时的数组 $b'$。

首先，$b'_m=a_m$。若 $j\gt i$ 时 $b'_j$ 都已求出，那么有：

$$\prod_{j=i+1}^{m}b'_{j}=\frac{a_{m}\prod_{j=i+1}^{m-1}b_j}{\gcd\left(a_{m},\prod_{j=i+1}^{m-1}b_j\right)}$$

$$\prod_{j=i}^{m}b'_{j}=\frac{a_{m}\prod_{j=i}^{m-1}b_j}{\gcd\left(a_{m},\prod_{j=i}^{m-1}b_j\right)}$$

两式相除得：

$$b'_{i}=\frac{b_i}{\frac{\gcd\left(a_{m},\prod_{j=i}^{m-1}b_j\right)}{\gcd\left(a_{m},\prod_{j=i+1}^{m-1}b_j\right)}}$$

设 $X=a_{m},Y=b_i,Z=\prod_{j=i+1}^{m-1}b_j$，则：

$$\frac{\gcd\left(a_{m},\prod_{j=i}^{m-1}b_j\right)}{\gcd\left(a_{m},\prod_{j=i+1}^{m-1}b_j\right)}=\frac{\gcd\left(X,YZ\right)}{\gcd\left(X,Z\right)}$$

$$=\gcd\left(\frac{X}{\gcd\left(X,Z\right)},Y\frac{Z}{\gcd\left(X,Z\right)}\right)=\gcd\left(\frac{X}{\gcd\left(X,Z\right)},Y\right)=\gcd\left(\frac{a_{m}}{\gcd\left(a_{m},\prod_{j=i+1}^{m-1}b_j\right)},b_i\right)$$

通过上述式子我们已经可以 $O\left(Tn^2\log a\right)$ 求出答案。

设 $s_i=\prod_{j=i}^{m-1}b_j$，注意到 $\gcd\left(a_{m},\prod_{j=i+1}^{m-1}b_j\right)=\gcd\left(a_{m},s_{i+1}\right)$ 一定是 $a_m$ 的约数，且对 $\forall1\le i\lt j\le m$，有 $\gcd\left(a_{m},s_j\right)|\gcd\left(a_{m},s_i\right)$，因此不同的 $\gcd\left(a_{m},s_i\right)$ 取值只有 $O\left(\log a\right)$ 种。

如何快速找到这 $O\left(\log a\right)$ 个位置来减少计算 $\gcd$ 的次数呢？注意到若 $\gcd\left(a_{m},s_i\right)>\gcd\left(a_{m},s_{i+1}\right)$，那么一定存在某个质因子 $p$ 在左式中的次数比右式中的高。

设 $p$ 在 $a_{m},s_i,s_{i+1}$ 中的出现次数分别为 $x,y,z$，那么 $y>z$，又因为 $\min\left(x,y\right)>\min\left(x,z\right)$，因此 $x>z$。

故 $\min\left(x,y\right)>z$，所以这等价于 $\left(s_{i+1}\bmod a_m\right)\bmod \gcd\left(a_m,s_i\right)\ne0$。

因此，用一个变量 $\text{tmp}$ 存当前 $\gcd\left(a_m,s_i\right)$ 的值，根据 $\left(s_{i+1}\bmod a_m\right)\bmod\text{tmp}$ 是否等于 $0$ 可判断出是否需要更新 $\text{tmp}$。

总时间复杂度 $O\left(Tn\left(n+\log^2a\right)\right)$。

## Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mod 1000000007
using namespace std;
int n,q,Test_num;
LL tmp,c,tmp1,tmp2;
LL a[302],b[302],s[302];
LL ans[302][302];
inline LL gcd(LL a,LL b)
{
	return b? gcd(b,a%b):a;
}
inline void solve()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
	for(int i=1;i<=n;++i)
	{
		ans[i][i]=(b[i]=a[i])%mod,s[i]=1;
		for(int j=i-1;j;--j)s[j]=((__int128)s[j+1]*b[j])%a[i];
		tmp2=gcd(s[1],a[i]);
		for(int j=1;j<i;++j)if(s[j+1]%tmp2)tmp1=gcd(s[j+1],a[i]),c=tmp2/tmp1,tmp2=tmp1,tmp/=c,b[j]/=c;
		for(int j=i-1;j;--j)ans[j][i]=(ans[j+1][i]*(b[j]%mod))%mod;
	}
	for(int i=1,x,y;i<=q;++i)scanf("%d%d",&x,&y),printf("%lld\n",ans[x][y]);
}
int main()
{
	for(scanf("%d",&Test_num);Test_num--;)solve();
	return 0;
}
```


---

## 作者：Leasier (赞：6)

注意到 $n$ 很小，考虑预处理出每个区间的答案。

我们尝试在原区间 $[1, r - 1]$ 中加入一个数 $a_r$。

由于 $a_i$ 很大，直接算质因数的贡献等方法不便处理，考虑设 $b_i$ 表示在 $[i + 1, r]$ 的基础上加入一个 $a_i$ 的贡献。

具体地，我们可以得到 $b_i = \dfrac{a_i}{\gcd(a_i, \displaystyle\prod_{j = i + 1}^r b_j)}$。

在加入 $a_r$ 之后，设 $b'_i$ 表示新的 $b_i$，则我们发现 $b'_i$ 相当于在 $b_i$ 的基础上除掉了 $a_r$ 在前面带来的贡献。具体地，有 $b'_i = \dfrac{b_i}{\gcd(b_i, \displaystyle\prod_{j = i + 1}^r b'_j)}$。

但是 $\displaystyle\prod_{j = i + 1}^r b'_j$ 可能太大，但是不难发现 $[1, r]$ 的答案在 $[1, r - 1]$ 的基础上会乘上一个 $\leq a_r$ 的数，且 $b'_i \mid b_i$。

考虑设 $c_i = \frac{b_i}{b'_i}$，则可以得到 $c_i = \gcd(b_i, \dfrac{a_r}{\displaystyle\prod_{j = i + 1}^r c_j})$。

模拟上述过程即可。时间复杂度为 $O(Tn^2 \log w)$，其中 $w$ 为值域 $2^{60}$。

如果被卡常了，可以考虑使用二进制 $\gcd$ 的 trick 卡卡常。

代码：
```cpp
#include <iostream>

using namespace std;

typedef long long ll;

const int mod = 1e9 + 7;
ll a[307], b[307], c[307], ans[307][307];

inline ll gcd(ll a, ll b){
	if (a == 0) return b;
	if (b == 0) return a;
	int t = __builtin_ctz(a | b);
	a >>= __builtin_ctz(a);
	while (b){
		b >>= __builtin_ctz(b);
		if (a > b) swap(a, b);
		b -= a;
	}
	return a << t;
}

int main(){
	int t;
	cin >> t;
	for (register int i = 1; i <= t; i++){
		int n, q;
		cin >> n >> q;
		for (register int j = 1; j <= n; j++){
			cin >> a[j];
		}
		for (register int j = 1; j <= n; j++){
			ll val = a[j];
			b[j] = a[j];
			c[j] = 1;
			for (register int k = j - 1; k >= 1; k--){
				c[k] = gcd(b[k], val);
				val /= c[k];
				b[k] /= c[k];
			}
			ans[j][j] = a[j] % mod;
			for (register int k = j - 1; k >= 1; k--){
				ans[k][j] = ans[k + 1][j] * (b[k] % mod) % mod;
			}
		}
		for (register int j = 1; j <= q; j++){
			int l, r;
			cin >> l >> r;
			cout << ans[l][r] << endl;
		}
	}
	return 0;
}
```

---

## 作者：zesqwq (赞：3)

一个需要卡常的无脑莫队做法。

考虑暴力，实际上可以考虑加上一个数的贡献。

我们记第 $i$ 个数为 $a_i$，贡献为 $b_i$，那么对于新加的一个数 $j$，其贡献为 $\dfrac{a_j}{\gcd(\prod_{i=l}^r b_i, a_j)}$，其中 $l,r$ 为原区间，其原因显然。这样可以 $O(n)$ 算加入一个数的贡献。

可以参考暴力的代码：

```cpp
for (int j = q[i].l; j < q[i].r; j++) {
    c[j] = a[j];
    long long ftt = 1;
    for (int k = q[i].l; k < j; k++) ftt = (__int128)ftt * c[k] % c[j];
    c[j] /= gcd(c[j], ftt);
    answer[q[i].id] = (__int128)answer[q[i].id] * c[j] % P;
}
```

我们观察到新加的数可能是 $10^9+7$ 的倍数，因此虽然可以删除贡献，但是并不方便，因此可以直接回滚莫队，时间复杂度 $O(Tn^2\sqrt n)$，能过。

最后附上一个卡常乘法：

- 基于 UB 的快速大整数快速乘（比 `__int128`） 快，但是可能大于 `mo`，再减一次就可以了。

```cpp
inline long long mul(long long x, long long y, long long mo) {
    long long t = x * y - (long long)((long double)x / mo * y + 1e-9) * mo;
    return t < 0 ? t + mo : t;
}
```

[record](https://www.luogu.com.cn/record/103485424)

---

## 作者：harmis_yz (赞：2)

## 分析

考虑莫队。

令 $S=\operatorname{lcm}(a_l,a_{l+1},a_{l+2},\dots,a_{r-1})$。则对于新加进来的 $a_r$，有：

$$\operatorname{lcm}(a_l,a_{l+1},a_{l+2},\dots,a_{r-1},a_r)\\=\operatorname{lcm}(S,a_r)\\=\frac{S \times a_r}{\gcd(S,a_r)}$$

很容易发现，$S$ 在不取模的情况下会爆 __int128，所以不能这么搞。

考虑从 $a_r$ 对 $\operatorname{lcm}(a_l,a_{l+1},a_{l+2},\dots,a_{r-1},a_r)$ 的贡献。 令 $a_r$ 的贡献为 $b_r$，则：

$$b_r = \frac{a_r}{\gcd(\prod \limits_{i=l}^{r-1}b_i ,a_r)}$$

然后答案就是 $\prod\limits_{i=l}^{r}b_i $。

删除不好搞，用回滚即可。复杂度是 $O(T n^2 \sqrt{n})$ 的。

**【关于卡常】**

注意到 $\gcd(a,b)=\gcd(a \bmod b,b)$。那么在算 $\prod \limits_{i=l}^{r-1}b_i $ 的时候，我们就可以将其对 $a_r$ 取模，保证乘积不会爆 longlong。

在暴力求乘积的时候，如果当前的乘积是 $a_r$ 的倍数，直接退出循环即可。在正常卡常的基础上加上这个就能过了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register
#define il inline
#define pii pair<int,int>
#define x first
#define y second
#define gc getchar()
#define rd read()
#define debug() puts("------------")

namespace yzqwq{
	il ll read(){
		ll x=0;
		int f=1;char ch=gc;
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
		while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
		return x*f;
	}
	il int qmi(int a,int b,int p){
		int ans=1;
		while(b){
			if(b&1) ans=ans*a%p;
			a=a*a%p,b>>=1;
		}
		return ans;
	}
	il auto max(auto a,auto b){return (a>b?a:b);}
	il int min(int a,int b){return (a<b?a:b);}
	il ll gcd(ll a,ll b){
		return !b?a:gcd(b,a%b);
	}
	il int lcm(int a,int b){
		return a/gcd(a,b)*b;
	}
	il void exgcd(int a,int b,int &x,int &y){
		if(!b) return x=1,y=0,void(0);
		exgcd(b,a%b,x,y);
		int t=x;
		x=y,y=t-a/b*x;
		return ;
	}
	mt19937 rnd(time(0));
}
using namespace yzqwq;

const int N=305;
const ll p=1e9+7;
struct node{
	int l,r,id;
}Q[N];
int n,q,len;
ll a[N],ans[N];
ll b_[N],b[N];
ll S,S_,s;

il int get(int x){
	return (x-1)/len+1;
}
il bool cmp(node a,node b){
	if((a.l-1)/len!=(b.l-1)/len) return a.l<b.l;
	return a.r<b.r;
}
ll mul(ll a,ll b,ll m){
    ll t=a*b-(ll)((long double)a/m*b)*m;
    return t<0?t+m:(t>=m?t-m:t);
}

il void solve(){
	n=rd,q=rd,len=sqrt(n),S=1;
	for(re int i=1;i<=n;++i) a[i]=rd;
	for(re int i=1;i<=q;++i) Q[i]={rd,rd,i};
	sort(Q+1,Q+q+1,cmp);
	int l=1,l_,r=0,lst_bk=0;
	for(re int i=1;i<=q;++i){
		if(get(Q[i].l)==get(Q[i].r)){
			S_=1;
			for(re int j=Q[i].l;j<=Q[i].r;++j){
				s=1;
				for(re int k=Q[i].l;k<j;++k){
					s=mul(s,b_[k],a[j]);
					if(!s) break;
				}
				b_[j]=a[j]/gcd(a[j],s);
				S_=(S_*(b_[j]%p))%p;
			}
			ans[Q[i].id]=S_;
			continue;
		}
		if(lst_bk!=get(Q[i].l)){
			lst_bk=get(Q[i].l);
			l=min(lst_bk*len,n)+1,r=l-1;
			S=1;
		}
		while(r<Q[i].r){
			++r,s=1;
			for(re int k=l;k<r;++k){
				s=mul(s,b[k],a[r]);
				if(!s) break;
			}
			b[r]=a[r]/gcd(a[r],s);
			S=(S*(b[r]%p))%p;
		}
		S_=S,l_=l;
		while(l_>Q[i].l){
			--l_,s=1;
			for(re int k=l_+1;k<=r;++k){
				s=mul(s,b[k],a[l_]);
				if(!s) break;
			}
			b[l_]=a[l_]/gcd(a[l_],s);
			S_=(S_*(b[l_]%p))%p;
		}
		ans[Q[i].id]=S_;
	}
	for(re int i=1;i<=q;++i) printf("%lld\n",ans[i]);
	return ;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int t=rd;while(t--)
	solve();
	return 0;
}
```

---

## 作者：HECZ (赞：2)

把 $<10^{4.5}$ 的质数分开来处理，这样剩余每个数至多剩余 33 个不同的质因子。考虑我们不需把每个数分解质因数，只需要能够构造一个等价的质数集合即可。构造方法如下：

对于所有 $1 \leq i < j \leq n$，将 $\gcd(a_i, a_j) ,a_i / \gcd(a_i,a_j) ,a_j / \gcd(a_i,a_j)$ 加入到集合 $S$ 中。将其中存在 $S$ 中的数作为因数的数删掉，剩下的集合就是一个合法的质数集合。

接下来的一个朴素做法是莫队，需要一些精妙的实现使得那个 $\log$ 是加上去的而不是乘上去的。

会用到质数的快速幂，这个可以预处理相当于对于每个质数维护一个出现次数集合，支持加减和查询最大的出现次数。首先维护一个桶来去重，然后开一个 `long long`，并每次查询最高的 $11$ 出现的位置。
时间复杂度近似于 $O(n^3 \log n)$，需要一些非常精细的操作。

代码由于太丑不放了，如果读者能够读懂上述内容，想必不难实现程序。

---

## 作者：CQ_Bab (赞：1)

# 思路
首先发现这是一个典型莫队，但是如果有删除非常难做，所以考虑回滚莫队，可是由于 lcm 可能很大但是你取了模之后有可能导致 gcd 变化，所以我们考虑从 $l\sim r$ 拓展到 $l\sim r+1$ 时需要乘上 $r+1$ 的贡献，而 $r+1$ 的贡献为 $a_{r+1}\div \gcd(\prod_{i=l}^r b_i,a_{r+1})$ 这里的 $b_i$ 表示 $a_i$ 对答案的贡献，那么我们每往外拓展一个点就要遍历一遍 $l\sim r$ 求出 $\prod_{i=l}^{r} b_i$ 但是它还是很大，又由于辗转相除法可得 $\gcd(a,b)=\gcd(b,a\bmod b)$ 所以求前面的乘积时对 $a_{r+1}$ 取模即可。

对于莫队拓展左边的部分也同理，也是将 $\prod_{i=l+1}^{r} b_i$ 求出来即可，此时对 $a_l$ 取模，然后再求 gcd 即可，此题由于时间复杂度比较炸裂需要一点卡常（大致就是优化取模）。
# 代码
细节见代码。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define fs complex<double>
#define pi acos(-1)
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    while (ch < '0' || ch > '9') {ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
}
int T=1;
int n,q;
const int N=3e2+10,mod=1e9+7;
ll a[N];
int len,ll1[N];
vector<pair<int,int>>v[N];
il ll gcd(ll a,ll b) {
	if(!b) return a;
	return gcd(b,a%b);
}
#define bl(x) ((x-1)/len+1)
ll res[N];
ll b[N],b1[N];
ll mul(ll x,ll y,ll p) {
	ll t=(__int128)(x)*y-(ll)((long double)x/p*y)*p;
	return (t<0)?t+p:(t>=p?t-p:t);
}
void solve() {
	in(n),in(q);
	len=sqrtl(n);
	rep(i,1,n) in(a[i]);
	rep(i,1,q) {
		int l,r;
		in(l),in(r);
		v[bl(l)].pb({r,i});
		ll1[i]=l;
	}
	rep(i,1,bl(n)) sort(v[i].begin(),v[i].end());
	rep(i,1,bl(n)) {
		ll gg=1;
		int R=i*len-1;
		for(auto to:v[i]) {
			int l=ll1[to.second],r=to.first;
			if(r-l+1<=len) {
				rep(j,l,r) {
					ll io=1;
					rep(k,l,j-1) io=mul(io,b1[k],a[j]);
					b1[j]=a[j]/gcd(io,a[j]);
				}
				ll ans=1;
				rep(j,l,r) ans=ans*(b1[j]%mod)%mod;
				res[to.second]=ans;
			}else {
				while(R<r) {
					++R;
					ll kk=1;
					rep(j,i*len,R-1) kk=mul(kk,b[j],a[R]);
					b[R]=a[R]/gcd(a[R],kk);
					gg=gg*(b[R]%mod)%mod;
				}
				ll kk=gg;
				rep1(j,i*len-1,l) {
					ll io=1;
					rep(k,j+1,r) {
						io=mul(io,b[k],a[j]);
						if(!io) break;
					}
					b[j]=a[j]/gcd(io,a[j]);
					kk=kk*(b[j]%mod)%mod;
				}
				res[to.second]=kk;
			}
		}
	}
	rep(i,1,bl(n)) v[i].clear();
	rep(i,1,q) printf("%lld\n",res[i]);
}
fire main() {
	in(T);
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：zhenjianuo2025 (赞：1)

考虑求 $a_1\sim a_n$ 的 lcm 怎么做。

$i=n\sim 1$，令 $b_i=\dfrac{a_i}{\gcd(a_i,\prod_{j>i} b_j)}$，$a$ 的 lcm 即为 $\prod_jb_j$。

因为 $\gcd(a,b)=\gcd(a,b-a)$，所以 $\prod_{j>i} b_j$ 对 $a_i$ 取模即可。

若暴力每次询问，复杂度 $\mathcal{O}(TQn^2)$。


------------


考虑增加一个数 $a_{n+1}$，有 $b'_{n+1}=a_{n+1}$，
$b'_i=\dfrac{b_i}{\gcd(b_i,\prod_{j>i}b'_j)}$。

即在 $b_i$ 上除掉一个因子。

令 $c_i$ 为除掉的那个数，有 $c_i=\gcd(b_i,\dfrac{a_{n+1}}{\prod_{j>i}c_j})$。

此时直接做的复杂度为 $\mathcal{O}(Tn^2\log W)$，带着个 $\log$ 需要大力卡常。


------------

考虑只有 $\log W$ 个 $c_i$ 不为 $1$，因为每次会让 $a_{n+1}$ 除掉一个大于 $1$ 的数，我们需要快速判断 $c_i\ne 1$。

有 $\gcd(a_{n+1},\prod_{j\ge i}b_j)=\prod_{j\ge i}c_j$。

记 $s_i=\prod_{j\ge i}b_j$。

那么此时若 $\gcd(a_{n+1},s_i)\ne \gcd(a_{n+1},s_{i+1})$，$c_i\ne 1$。

考虑 $\gcd(a_{n+1},s_i)\ne \gcd(a_{n+1},s_{i+1})$ 当且仅当 $s_{i+1}\bmod\gcd(a_{n+1},s_i)\ne 0$，因为如果等于 $0$ 了，式子的值一定相等。

此时可以做到 $\mathcal{O}(Tn(n+\log^2 W))$。

---

## 作者：Yyxxxxx (赞：1)

## 题意
求区间$[l,r]$所有数的$lcm$
- 学校模拟赛有个[大佬](https://www.luogu.com.cn/user/181506)出这题~~被我爆破了~~

## 解题

考虑分治，将$lcm_{i=l}^ra_i$化为$lcm(lcm_{i=l}^{mid}a_i,lcm_{i=mid+1}^ra_i)$

接着我们可以预处理

$lcm_{i}^{mid}a_i(l\le i\le mid),lcm_{mid+1}^ra_i(mid+1\le i\le r)$

把上面两个$lcm$数列看作新数组 $A,B$，可以发现：

$$\prod\limits_{j=mid}^{i\le j}A_i=lcm_{i}^{mid}a_i,
\prod\limits_{j=mid+1}^{j\le i}B_i=lcm_{mid+1}^{i}a_i$$

那么处理出 $A,B$ 的前缀积的 $lcm$ ，并转成 $gcd$

此时依然可以将答案看作$gcd(\prod b_i,a_j)$的形式，求出除去$b_j$的值
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int mod = 1000000007, maxn = 410;
inline ll read()
{
    char c = getchar();
    ll x = 0;ll f=1;
    while (c < '0' || c > '9')
    {
        if(c=='-')
            f=-1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + c - 48, c = getchar();
    return x*f;
}
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll mul(ll a, ll b, ll mo)
{
    ll res = a * b - (ll)((long double)a / mo * b + 0.5) * mo;
    return res < 0 ? res + mo : res;
}
ll mul(ll a, ll b)
{
    b %= mod;
    return a % mod * b % mod;
}
int n, m, T;
ll a[maxn], b[maxn], ans[maxn][maxn];
void solve()
{
    n = (int)read(), m = (int)read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int j = 1; j <= n; j++)
    {
        ans[j][j] = a[j] % mod;
        b[j] = 1;
        for (int i = j - 1; i >= 1; i--)
            b[i] = mul(a[i], b[i + 1], a[j]);
        ll g = gcd(b[1], a[j]), tmp;
        for (int i = 1; i < j; i++)
            if (tmp = b[i + 1] % g)
                tmp = gcd(tmp, g), a[i] /= (g / tmp), g = tmp;
        for (int i = j - 1; i >= 1; i--)
            ans[i][j] = mul(ans[i + 1][j], a[i]);
    }
    while (m--)
    {
        int l = (int)read(), r = (int)read();
        printf("%lld\n", ans[l][r]);
    }
}
int main()
{
    T = (int)read();
    while (T--)
        solve();
}
```


---

## 作者：critnos (赞：0)

更加暴力的做法。

考虑按顺序加入每个数，维护 $\text{lcm}$。那么我们希望求出 $\gcd(a_i,\text{lcm}(a_1,a_2\dots a_{i-1}))$ 也就是 $\text{lcm}(\gcd(a_i,a_{i-1}),\gcd(a_i,a_{i-2})\dots)$。放到区间询问上，也就是求所有区间的右端点与其他数的 $\gcd$ 的 $\text{lcm}$（记为 $f_{l,r}$）。直接暴力是 $O(n^2\log V)$ 的。

注意到对于一个右端点，$\text{lcm}$ 只会更新 $\log V$ 次。显然更新当且仅当 $\gcd(a_i,a_r)\nmid f_{i+1,r}$。

考虑快速地找到这些 $a_i$。注意到我们可以同时判断若干个 $a_i$ 是否能更新，只需要求 $\gcd(\prod a\bmod a_r,a_r)$。于是用一个通用技术，先倍增一个后缀的长度求后缀积，再二分即可。

时间复杂度 $O(n(n+q)+n\log V\log n)$，但后者的常数很大，需要二进制 $\gcd$。

---

## 作者：木xx木大 (赞：0)

[P5655 基础数论函数练习题](https://www.luogu.com.cn/problem/P5655) 

首先，我们尝试用 $\prod_{l}^rb_i,b_i|a_i$ 来表示 $lcm_{l,r}$。当多加了一个数 $a_r$ 时，$b_r=\frac{a_r}{\gcd(a_r,\prod b_i)}$，即对 $a_r$ 除去前面计算过的部分。这样暴力做复杂度为 $O(TQn^2)$

考虑优化，对数组进行分治，处理出 $b_i=\left\{\begin{aligned}\frac{a_i}{\gcd(a_i,\prod_{j>i} b_j)}\quad(i\le mid)\\\frac{a_i}{\gcd(a_i,\prod_{j<i} b_j)}\quad(i> mid)\end{aligned}\right.$ 。考虑如何合并左右区间，考虑左边增加一个数对右边所有数的贡献，应该是每个数在原来的基础上再除去一个因子。设当前左端点移动到了 $l$ ，首先求出 $\gcd(\prod_{i=mid+1}^r{b_i},b_l)$，然后倒着往回推，当有一个因子是 $\gcd(\prod_{i=mid+1}^{j-1}{b_i},b_l)$ 没有而$\gcd(\prod_{i=mid+1}^{j}{b_i},b_l)$ 有时，这个因子就是 $b_j$ 应该除去的因子。（具体实现见代码）

考虑这样做的复杂度，因为每个数至多有 $O(\log w)$ 个质因子，所以对于每个左端点，移动右端点时只会求 $O(\log w)$ 次 $\gcd$。总复杂度为 $O(Tn(n+\log^2a))$


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m;
	const int N=305,mo=1e9+7;
	ll ans[N][N],a[N],b[N],c[N];
	ll mul(ll x,ll y,ll p)
	{
		y%=p;
		ll t=x*y-(ll)((long double)x/p*y+1e-9)*p;
		return t<0?t+p:t;
	}
	ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}
	void calc(int l,int r)
	{
		if(l==r){ans[l][l]=a[l]%mo;return;}
		int mid=(l+r)>>1;
		calc(l,mid),calc(mid+1,r);
		ll x,y,g,gg;
		for(int i=mid;i>=l;i--)
		{
			b[i]=a[i],x=1;
			for(int j=i+1;j<=mid;j++)
				x=mul(x,b[j],b[i]);
			b[i]/=gcd(x,b[i]);
		}
		for(int i=mid+1;i<=r;i++)
		{
			b[i]=a[i],x=1;
			for(int j=mid+1;j<i;j++)
				x=mul(x,b[j],b[i]);
			b[i]/=gcd(x,b[i]);
		}
		x=1;
		for(int i=mid;i>=l;i--)
		{
			x=b[i]%mo*x%mo;c[mid]=1;
			for(int j=mid+1;j<=r;j++)
				c[j]=mul(c[j-1],b[j],b[i]);
			g=gcd(c[r],b[i]);
			for(int j=r-1;j>=mid;j--)
				if(c[j]%g)gg=gcd(g,c[j]),b[j+1]/=(g/gg),g=gg;
			y=x;
			for(int j=mid+1;j<=r;j++)
				ans[i][j]=y=b[j]%mo*y%mo;
		}	
	}
	void work()
	{
		int T;
		scanf("%d",&T);
		while(T--)
		{
			scanf("%d%d",&n,&m);
			for(int i=1;i<=n;i++)
				scanf("%lld",&a[i]);
			calc(1,n);
			while(m--)
			{
				int l,r;
				scanf("%d%d",&l,&r);
				printf("%lld\n",ans[l][r]);
			}
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}



---


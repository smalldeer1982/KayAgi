# 点双连通图计数

## 题目描述

求 $n$ 个点的有标号点双连通图（简单无向图，整个图是一个点双连通分量）的个数，答案对 $998244353$ 取模。

## 说明/提示

$1 \le n \le 10^5$。

## 样例 #1

### 输入

```
1
2
3
4
5
```

### 输出

```
1
1
1
10
238
```

# 题解

## 作者：Panda_hu (赞：8)

[点此查看全文](https://blog.csdn.net/qq_34940287/article/details/107191864)
> 求 $n$ 个点的有标号点双连通图（简单无向图，整个图是一个点双连通分量）的个数，答案对 $998244353$ 取模。

> 点双连通图:如果一个无向连通图删去任意一个点都仍然是连通的，我们就称其为点双连通图。
	
  首先我们需要明确一点:对于一个无向简单连通图，任意一个点必定在**至少**一个点双连通分量里面，一个点双连通分量的大小至少大于等于$2$。
  
  所以我们首先需要特判$n=1$的情况。
 
  我们先用上一道题的做法求出$i$个点无向连通图数生成函数$F(x)$。
  
  然后设$i$个点**有根**无向连通图数$d_i$的生成函数为$D(x)$，$i$个点**无根**点双连通图数$b_i$的生成函数为$B(x)$。
 
  显然可以得到$[x^n]D(x)=n[x^n]F(x)$。
 
  考虑如何得到$B(x)$和$F(x)$之间的关系，我们可以利用我们一开始知道的性质，那么对于一个有根无向连通图其选中的根必定在至少一个点双连通分量里面，而且根据定义这些点双连通分量两两的交集有且只有根
  
  例如下面这个~~奇怪~~的有根无向连通图，包含它的根$R$的点双连通分量的点集可以表示为$\{3,R\},\{4,5,6,7,8,R\},\{9,10,11,12,R\}$。

![p1](https://img-blog.csdnimg.cn/20200708085405193.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTQwMjg3,size_16,color_FFFFFF,t_70)
  
  如何计数？现在我们考虑先将$R$这个点与其相邻的边删去。
 
![p2](https://img-blog.csdnimg.cn/20200708085856527.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTQwMjg3,size_16,color_FFFFFF,t_70)

  显然现在的连通块个数为先前包含根的点双连通分量的个数，我们对于每一个连通块单独计数，由于这些连通块理论上没有任何块数限制且相互独立，因此把它们$exp$起来即可。
 
  观察$\{3,R\}$这一组点双连通分量我们可以发现，对于每一个在点双连通分量上的点(除去$R$)我们其实都可以在上面插上一个**以其为根**的无向连通图，并且容易发现这样做**并不会影响到包含这个根$R$的任何点双连通分量的大小**。

  那么很容易得到一个连通块的方案数的生成函数:
$$\sum^{∞}_{i=1}b_{i+1}\frac{D^i(x)}{i!}$$
  注意到$\sum^{∞}_{i=1}\frac{b_{i+1}}{i!}x^i$就为$B'(x)$，因此原式等于$B'(D(x))$。
 
  那么整个图的生成函数为$D(x)=xe^{B'(D(x))}$(注意加上根)。
 
  现在我们成功的找到了$D(x)$与$B(x)$的关系，然而这个式子并不能牛顿迭代，考虑用复合逆解决:
  $$B'(D(x))=\ln \frac{D(x)}{x}$$
  令$H(x)=\ln \frac{D(x)}{x}$，套扩展拉格朗日反演公式可以得到:
  $$[x^n]B'(x)=\frac{1}{n}[x^{n-1}]H'(x)(\frac{x}{D(x)})^n$$
  由定义得$e^{-H(x)}=\frac{x}{D(x)}$，因此:
  $$[x^n]B'(x)=\frac{1}{n}[x^{n-1}]H'(x)e^{-nH(x)}$$
  注意我们求到的是$B'(x)$的系数，因此强烈建议一开始就将$n$减一然后做一遍(上面的推导也是减了一的)，最后再乘以一个$(n-1)!$(这里的$n$是减了之后的,由于$B(x)$是EGF我们首先乘$(n+1)!$,因为求导除以$(n+1)$,由于上面反演有一个系数再除一次$n$)。
 
  理论复杂度:$O(n\log n)$(常数巨大)。
 # 实现
 ```cpp
 #include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
using namespace std;

#define LL long long
#define DB double
#define MAXN 600000
#define MOD 998244353
#define G 3
#define Pr pair<LL,int>
#define X first
#define Y second
#define INF 1000000000000000000
#define mem(x,v) memset(x,v,sizeof(x))

LL read(){
    LL x=0,F=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x*10+c-'0')%MOD;c=getchar();}
    return x*F;
}
int add(int a,int b){return (a+b>=MOD)?a+b-MOD:a+b;}
int dec(int a,int b){return (a-b<0)?a-b+MOD:a-b;}
int mul(int a,int b){return (1LL*a*b)%MOD;}
int fst_pow(int a,LL b){
    int res=1;
    while(b){
        if(b&1)res=mul(res,a);
        a=mul(a,a),b>>=1;
    }return res;
}

int inv2,fac[MAXN+5],ifac[MAXN+5];

void prepare(){
    fac[0]=1;
    for(int i=1;i<=MAXN;i++)fac[i]=mul(fac[i-1],i);
    ifac[MAXN]=fst_pow(fac[MAXN],MOD-2);
    for(int i=MAXN;i>=1;i--)ifac[i-1]=mul(ifac[i],i);
}
void NTT(int *a,int n,int x){
    for(int i=0,j=0;i<n;i++){
        if(i<j)swap(a[i],a[j]);
        int k=n>>1;
        while(k&&(k&j))j^=k,k>>=1;
        j^=k;
    }
    for(int i=1;i<n;i<<=1){
        int gn=fst_pow(G,(MOD-1)/(i<<1));
        for(int j=0;j<n;j+=(i<<1)){
            int g=1;
            for(int k=0;k<i;k++,g=mul(g,gn)){
                int X=a[j+k],Y=mul(a[i+j+k],g);
                a[j+k]=add(X,Y),a[i+j+k]=dec(X,Y);
            }
        }
    }
    if(x==1)return ;
    int ny=fst_pow(n,MOD-2);reverse(a+1,a+n);
    for(int i=0;i<n;i++)a[i]=mul(a[i],ny);
}
void ploy_inv(int n,int *a,int *b){
    static int c[MAXN+5];
    if(n==1){b[0]=fst_pow(a[0],MOD-2);return ;}
    ploy_inv((n+1)>>1,a,b);
    int len=1;
    while(len<(n<<1))len<<=1;
    copy(a,a+len,c);
    fill(c+n,c+len,0),NTT(c,len,1);
    fill(b+n,b+len,0),NTT(b,len,1);
    for(int i=0;i<len;i++)
    b[i]=mul(dec(2,mul(c[i],b[i])),b[i]);
    NTT(b,len,-1);
    fill(b+n,b+len,0);
}
void ploy_der(int n,int *a,int *b){
    for(int i=1;i<n;i++)b[i-1]=mul(a[i],i);
    b[n-1]=0;
}
void ploy_cal(int n,int *a,int *b){
    for(int i=1;i<n;i++)b[i]=mul(a[i-1],fst_pow(i,MOD-2));
    b[0]=0;
}
void ploy_ln(int n,int *a,int *b){
    static int A[MAXN+5],B[MAXN+5];
    fill(A,A+(n<<1),0),fill(B,B+(n<<1),0);
    ploy_der(n,a,A),ploy_inv(n,a,B);
    int len=1;while(len<(n<<1))len<<=1;
    NTT(A,len,1),NTT(B,len,1);
    for(int i=0;i<len;i++)A[i]=mul(A[i],B[i]);
    NTT(A,len,-1),ploy_cal(n,A,b);
}
void ploy_exp(int n,int *a,int *b){
    static int F[MAXN+5];
    if(n==1){b[0]=1;return ;}
    ploy_exp((n+1)>>1,a,b);
    fill(F,F+(n<<1),0),ploy_ln(n,b,F);
    for(int i=0;i<n;i++)F[i]=dec(a[i],F[i]);
    F[0]=add(F[0],1);
    int len=1;while(len<(n<<1))len<<=1;
    fill(b+n,b+len,0),NTT(b,len,1);
    fill(F+n,F+len,0),NTT(F,len,1);
    for(int i=0;i<len;i++)b[i]=mul(b[i],F[i]);
    NTT(b,len,-1),fill(b+n,b+len,0);
}
int n,m,f[MAXN+5],g[MAXN+5],h[MAXN+5],dh[MAXN+5],tmp[MAXN+5],nh[MAXN+5];
void init(){
    m=1<<17;
    for(int i=0;i<m;i++)f[i]=mul(fst_pow(2,1LL*i*(i-1)/2%(MOD-1)),ifac[i]);
    ploy_ln(m,f,g);
    for(int i=0;i<m-1;i++)g[i]=mul(g[i+1],i+1);
    g[m-1]=0;
    ploy_ln(m,g,h);
    ploy_der(m,h,dh);
    NTT(dh,m<<1,1);
}
int solve(int n){
    n--;
    if(!n)return 1;
    for(int i=m;i<(m<<1);i++)tmp[i]=0;
    for(int i=0;i<m;i++)tmp[i]=mul(h[i],MOD-n);
    ploy_exp(m,tmp,nh);
    NTT(nh,m<<1,1);
    for(int i=0;i<(m<<1);i++)nh[i]=mul(nh[i],dh[i]);
    NTT(nh,m<<1,-1);
    return mul(nh[n-1],fac[n-1]);
}

int main(){
    prepare(),init();
    for(int i=1;i<=5;i++)
    printf("%d\n",solve(read()));
}

 ```

---

## 作者：Kinandra (赞：6)

和[边双](https://dra.blog.luogu.org/solution-p5828)的做法很相近. 

#### Part 1 简单的预处理

先从有标号无向图的**指数生成函数**(简称 `EGF `) $F(x)=\sum_i 2^{n\choose 2}x^i$, ($2^{n\choose 2}$ 表示无向图每两个点之间都可以选择连边或不连)推导出有标号连通无向图的 EGF .

由于无向图是由各个连通块组合出来的, 故 $F=\exp G$ , 求得 $G=\ln F$ .

#### Part 2 将双连通图与好求的连通图建立联系

首先设有根连通无向图的 EGF 是 $D(x)$ , 易知 $[x^n]D(x)=n[x^n]G(x)$ . 设大小为 $i$ 的点双连通图(**无根**)的数量为 $b_i$ .

有根连通无向图的根可能存在于多个点双连通分量当中, 这些点双显然只有根这一个交点, 去掉根之后一个点双对应一个连通块(称为**一个部分**,注意**一个部分**是不包含根的). 

所以只要求出**一个部分**的生成函数, 用 $\exp$ 组合起来并加上根, 就可以列出双连通图和连通图的数量关系了. 下面考虑的**一个部分**生成函数.

特判 $n=1$ 的情况, 则原图根所处的点双大小 $sz\geqslant 2$ , 将原图根所在点双内的所有边(两个端点都是点双中的点)删去, **一个部分**恰好被分成 $sz-1$ 个连通块, 分别对应点双内除根以外的每个点. 枚举 $i=sz-1$ , 可知**一个部分**的生成函数为:
$$
\sum_{i=1}^\infty b_{i+1} \frac{D(x)^i}{i!}
$$


令 $B(x)=\sum_i b_{i+1}{x^i\over i!}$ , 则有根连通无向图的 EGF 可表示为:
$$
D(x)=x\exp B(D(x))
$$

#### Part 3 推导计算



利用复合逆将上式变形: 
$$
\begin {aligned}
B(D(x))&=\ln{D(x)\over x}\\
B(x)&=\ln{x\over D^{-1}(x)}
\end {aligned}
$$


令 $H(x)=\ln{D(x)\over x}$ , $H^{-1}(x)$ 为 $H(x)$ 的复合逆, 则 $B(x)=H(D^{-1}(x))$.

由扩展拉格朗日反演公式得:
$$
\begin {aligned}
{[x^n}]B(x)&={1\over n}[x^{-1}]H'(x)(D(x))^{-n}\\
		 &={1\over n}[x^{n-1}]H'(x)({x\over D(x)})^{n}\\
		 &={1\over n}[x^{n-1}]H'(x)\exp(-n\ln{D(x)\over x})\\
		 &={1\over n}[x^{n-1}]H'(x)\exp(-n H(x))
\end {aligned}
$$
(发现式子的形式居然和边双是一样的

#### Part 4 细节

注意 $D,B$ 都是**有根**的且是 **EGF** , 并且 $b_i=i![x^i]B(x)$ 系数处理时要格外注意.

在计算 $F$ 的过程中我们需要计算 $2^{n\choose 2}$ , 注意**指数上**的 ${n\choose 2}$ 要在 $\bmod (mod-1)$ 意义下处理才行(因为这个错调到自闭).

注意 $H'(x)$ 的 `NTT` 变换可以预处理, 不需要对每个询问都重新计算, 可以卡一点常.

特判 $1$ .

#### Part 5 Code

```cpp
#include <bits/stdc++.h>
#define mod 998244353
using namespace std;
int read();
int M(int x) { return x >= mod ? x - mod : x; }
void Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }
int fsp(long long bs, int p) {
    int rt = 1;
    while (p) {
        if (p & 1) rt = bs * rt % mod;
        bs = bs * bs % mod, p >>= 1;
    }
    return rt;
}
int fac[300005], caf[300005], lim = 300000;
void init() {
    fac[0] = 1;
    for (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;
    caf[lim] = fsp(fac[lim], mod - 2);
    for (int i = lim; i >= 1; --i) caf[i - 1] = 1ll * caf[i] * i % mod;
}
int inv(int x) { return 1ll * caf[x] * fac[x - 1] % mod; }

int L = 1 << 18;
int O[300005];
void initO() {
    O[0] = 1, O[1] = fsp(3, (mod - 1) / L);
    for (int i = 2; i < L; ++i) O[i] = 1ll * O[i - 1] * O[1] % mod;
}
int R[300005];
void getR(int len, int w) {
    for (int i = 1; i < len; ++i) R[i] = R[i >> 1] >> 1 | ((i & 1) << w - 1);
}
struct Poly {
    int x[300005];
    int &operator[](int p) { return x[p]; }
    void mem(int len, int st = 0) { memset(x + st, 0, len << 2); }
    void cpy(Poly &y, int len) { memcpy(x, y.x, len << 2); }
    void cpy(int *y, int len) { memcpy(x, y, len << 2); }
    void der(int len) {
        for (int i = 0; i < len - 1; ++i) x[i] = 1ll * (i + 1) * x[i + 1] % mod;
        x[len - 1] = 0;
    }
    void inter(int len) {
        for (int i = len - 1; i >= 1; --i) x[i] = 1ll * inv(i) * x[i - 1] % mod;
        x[0] = 0;
    }

    void dft(int len) {
        for (int i = 1; i < len; ++i) R[i] > i ? swap(x[i], x[R[i]]) : void();
        for (int l = 2; l <= len; l <<= 1)
            for (int i = 0, m = l >> 1, dO = L / l; i < len; i += l)
                for (int j = i, t, *tO = O; j < i + m; ++j, tO += dO) {
                    t = 1ll * *tO * x[j + m] % mod;
                    x[j + m] = M(x[j] - t + mod), x[j] = M(x[j] + t);
                }
    }

    void idft(int len) {
        int ny = (dft(len), reverse(x + 1, x + len), fsp(len, mod - 2));
        for (int i = 0; i < len; ++i) x[i] = 1ll * x[i] * ny % mod;
    }

    void Inv(int len) {
        static Poly y, tx, ty;
        y.mem(len << 1), tx.mem(len << 1), ty.mem(len << 1);
        y[0] = fsp(x[0], mod - 2);
        for (int tl = 2, w = 1; tl <= len; tl <<= 1, ++w) {
            tx.cpy(x, tl), ty.cpy(y, tl), getR(tl << 1, w + 1);
            tx.dft(tl << 1), ty.dft(tl << 1);
            for (int i = 0; i < (tl << 1); ++i)
                tx[i] = 1ll * tx[i] * ty[i] % mod * ty[i] % mod;
            tx.idft(tl << 1);
            for (int i = 0; i < tl; ++i) y[i] = M(M(y[i] << 1) - tx[i] + mod);
        }
        cpy(y, len);
    }

    void Ln(int len) {
        int w = 0;
        while ((1 << w) < len) ++w;
        static Poly y;
        y.mem(len << 1), y.cpy(x, len), y.Inv(len), der(len);
        getR(len << 1, w + 1), y.dft(len << 1), dft(len << 1);
        for (int i = 0; i < (len << 1); ++i) x[i] = 1ll * x[i] * y[i] % mod;
        idft(len << 1), mem(len, len), inter(len);
    }

    void exp(int len, int t = 1) {
        static Poly y, tx, ty;
        y.mem(len << 1), tx.mem(len << 1), ty.mem(len << 1), y[0] = t;
        for (int tl = 2, w = 1; tl <= len; tl <<= 1, ++w) {
            ty.cpy(y, tl), ty.Ln(tl);
            for (int i = 0; i < tl; ++i) tx[i] = M(x[i] - ty[i] + mod);

            tx[0] = t, ty.cpy(y, tl), getR(tl << 1, w + 1);
            tx.dft(tl << 1), ty.dft(tl << 1);
            for (int i = 0; i < (tl << 1); ++i)
                ty[i] = 1ll * tx[i] * ty[i] % mod;
            ty.idft(tl << 1), y.cpy(ty, tl);
        }
        cpy(y, len);
    }
} F, G, dG, nG;

void prework() {
    int len = 1 << 17;
    for (int i = 0; i < len; ++i)
        F[i] = 1ll * fsp(2, 1ll * i * (i - 1) / 2 % (mod - 1)) * caf[i] % mod;
    G.cpy(F, len), G.Ln(len);
    for (int i = 0; i < len; ++i) G[i] = 1ll * G[i] * i % mod;
    for (int i = 0; i < len - 1; ++i) G[i] = G[i + 1];
    G[len - 1] = 0, G.Ln(len), dG.cpy(G, len), dG.der(len), dG.dft(len << 1);
}

void work(int n) {
    if (!(--n)) return puts("1"), void();
    int len = 1 << 17;
    nG.mem(len << 1);
    for (int i = 0; i < len; ++i) nG[i] = 1ll * G[i] * (mod - n) % mod;
    nG.exp(len), nG.dft(len << 1);
    for (int i = 0; i < (len << 1); ++i) nG[i] = 1ll * nG[i] * dG[i] % mod;
    nG.idft(len << 1);
    printf("%d\n", 1ll * nG[n - 1] * inv(n) % mod * fac[n] % mod);
}

int main() {
    init(), initO(), prework();
    for (int i = 1; i <= 5; ++i) work(read());
    return 0;
}

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}

```

---

## 作者：cyffff (赞：3)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5827)

$\text{Update 2024.03.26}$：修改一处式子错误。
## 题意
求 $n$ 个点的有标号点双连通图数量，对 $998244353$ 取模。

$1\le n\le10^5$。
## 思路
### 前置
[有标号无向连通图计数](https://www.luogu.com.cn/problem/P4841)、[扩展拉格朗日反演](https://www.luogu.com.cn/blog/cyffff/lagrange-inversion)。
****
设有根无向连通图的 $\text{EGF}$ 为 $F(x)$，无根点双连通图的 $\text{EGF}$ 为 $G(x)$。

我们显然可以使用[有标号无向连通图](https://www.luogu.com.cn/problem/P4841)的 $\text{EGF}$ 乘上 $n$ 以得到 $F(x)$，于是考虑用 $F,G$ 互相表示。

对于一个有根无向连通图，每个点都会被包含在至少 $1$ 个点双中，且每个点双的大小不少于 $2$。注意还需要特判 $n=1$ 时输出 $1$。

考虑断掉根连出的边，无向连通图被划分成若干连通块，根据 $\exp$ 的集合意义，求出单个连通块的 $\text{EGF}$ 即可。

对于根所在的任意一个点双连通块，若在其任何除根以外的一点连上一个以该点为根的无向连通图不会影响根所在的任意一个点双的大小，故单个连通块的 $\text{EGF}$ 为
$$\sum_{n\ge1}g_{n+1}\frac{F^n(x)}{n!}$$
可以直接得到
$$\begin{aligned}
F(x)&=x\exp(\sum_{n\ge1}g_{n+1}\frac{F^n(x)}{n!})\\
&=x\exp(G'(F(x)))\\
\ln \frac{F(x)}x&=G'(F(x))
\end{aligned}$$
令 $H(x)=\ln\dfrac{F(x)}{x}$，有 $G'(F(x))=H(x)$，根据扩展拉格朗日反演有
$$\begin{aligned}
[x^n]G'(x)&=\frac 1 n\cdot[x^{n-1}]H'(x)\frac{x^n}{F^n(x)}\\
&=\frac 1 n\cdot[x^{n-1}]H'(x)\exp(\ln(\left(\frac{F(x)}{x}\right)^{-n}))\\
&=\frac 1 n\cdot[x^{n-1}]H'(x)\exp(-nH(x))
\end{aligned}
$$
至此直接求解即可。

时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int mod=998244353,N=524288+10;
namespace Poly{
	int n,m,a[N],b[N],c[N],s[N],ss[N],d[N],e[N];
	int f[N],g[N],h[N],F[N],tmp1[N],tmp2[N],tmp3[N];
	int rev[N],inv[N],fac[N],ifac[N],G[19][N],lim;
	inline void init(int n,int mode=1){
		if(mode){
			int l=0;
			for(lim=1;lim<n;lim<<=1)l++;
			for(int i=1;i<lim;i++)
				rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
		}else{
			for(lim=1;lim<n;lim<<=1);
		}
	}
	inline int qpow(int x,int y){
		int res=1;
		while(y){
			if(y&1) res=1ll*res*x%mod;
			x=1ll*x*x%mod;
			y>>=1;
		}
		return res;
	}
	inline void Prefix(int n){
		inv[1]=1;
		for(int i=2;i<=n;i++)
			inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		fac[0]=1;
		for(int i=1;i<=n;i++)
			fac[i]=1ll*fac[i-1]*i%mod;
		ifac[n]=qpow(fac[n],mod-2);
		for(int i=n;i>=1;i--)
			ifac[i-1]=1ll*ifac[i]*i%mod;
		for(int i=1,p=1;i<=18;i++,p<<=1){
			G[i][0]=1;
			G[i][1]=qpow(3,mod-1>>i);
			for(int j=2;j<p;j++)
				G[i][j]=1ll*G[i][j-1]*G[i][1]%mod;
		}
	}
	inline void NTT(int *a,int t){
		for(int i=0;i<lim;i++)
			if(i<rev[i])
				swap(a[i],a[rev[i]]);
		for(int i=1,t=1;i<lim;i<<=1,t++){
			for(int j=0;j<lim;j+=i<<1){
				int t1,t2;
				for(int k=0;k<i;k++){
					t1=a[j+k];
					t2=1ll*G[t][k]*a[i+j+k]%mod;
					a[j+k]=(t1+t2)%mod;
					a[i+j+k]=(t1-t2+mod)%mod;
				}
			}
		}
		if(t==1) return ;
		int Inv=qpow(lim,mod-2);
		reverse(a+1,a+lim);
		for(int i=0;i<lim;i++)
			a[i]=1ll*a[i]*Inv%mod;
	}
	inline void Inv(int *a,int *b,int n){
		if(n==1){
			b[0]=qpow(a[0],mod-2);
			return ;
		}
		Inv(a,b,n+1>>1);
		init(n<<1);
		for(int i=0;i<n;i++)
			c[i]=a[i];
		for(int i=n;i<lim;i++)
			c[i]=0;
		NTT(c,1),NTT(b,1);
		for(int i=0;i<lim;i++)
			b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)%mod*b[i]%mod;
		NTT(b,-1);
		for(int i=n;i<lim;i++)
			b[i]=0;
	}
	inline void Mul(int *a,int *b,int n){
		init(n<<1);
		memset(c,0,lim<<2);
		memcpy(c,b,n<<2);
		NTT(a,1),NTT(c,1);
		for(int i=0;i<lim;i++)
			a[i]=1ll*a[i]*c[i]%mod;
		NTT(a,-1);
	}
	inline void Der(int *a,int *b,int n){
		for(int i=1;i<n;i++)
			b[i-1]=1ll*i*a[i]%mod;
		b[n-1]=0;
	}
	inline void Int(int *a,int *b,int n){
		for(int i=1;i<n;i++)
			b[i]=1ll*a[i-1]*inv[i]%mod;
		b[0]=0;
	}
	inline void polyln(int *a,int *b,int n){
		static int p[N];
		memset(p,0,n<<3);
		memset(d,0,n<<3);
		Der(a,p,n);
		Inv(a,d,n);
		Mul(p,d,n);
		Int(p,b,n);
	}
	inline void Log(int n,int *f,int *g){
		init(n);
		polyln(f,g,lim);
		for(int i=n;i<lim;i++)
			g[i]=0;
	}
	inline void polyexp(int n,int *a,int *b){
		if(n==1){
			b[0]=1;
			return ;
		}
		polyexp(n+1>>1,a,b);
		Log(n,b,s);
		for(int i=0;i<n;i++)
			s[i]=a[i]>=s[i]?a[i]-s[i]:a[i]+mod-s[i];
		for(int i=n;i<lim;i++)
			b[i]=s[i]=0;
		s[0]++;
		NTT(s,1),NTT(b,1);
		for(int i=0;i<lim;i++)
			b[i]=1ll*b[i]*s[i]%mod;
		NTT(b,-1);
		for(int i=n;i<lim;i++)
			b[i]=0;
	}
	inline void Exp(int n,int *a,int *b){
		polyexp(n,a,b);
	}
}
using namespace Poly;
int ask[5],L;
inline int solve(int m){
	memset(g,0,sizeof(g));
	memset(tmp1,0,sizeof(tmp1));
	m--;
	if(!m) return 1;
	for(int i=0;i<L;i++)
		g[i]=1ll*(mod-m)*tmp3[i]%mod;
	Exp(L,g,tmp1);
	init(L<<1);
	NTT(tmp1,1);
	for(int i=0;i<lim;i++)
		tmp1[i]=1ll*tmp1[i]*tmp2[i]%mod;
	NTT(tmp1,-1);
	return 1ll*tmp1[m-1]*fac[m-1]%mod;
}
int main(){
	for(int i=0;i<5;i++)
		ask[i]=read(),n=max(n,ask[i]+1);
	init(n,0);
	L=lim;
	Prefix(L);
	for(int i=0;i<L;i++)
		f[i]=1ll*qpow(2,1ll*i*(i-1)/2%(mod-1))*ifac[i]%mod;
	Log(L,f,F);
	Der(F,F,L);
	Log(L,F,tmp3);
	Der(tmp3,tmp2,L);
	NTT(tmp2,1);
	for(int i=0;i<5;i++)
		write(solve(ask[i])),putc('\n');
	flush();
	return 0;
}
```

---

## 作者：ducati (赞：2)

第一道独立做出的较高难度拉反题，写篇题解纪念一下，顺便理一下思路过程。

## Description

$T$ 次询问，每次给定 $n$，求 $n$ 个点的**有标号点双连通图**数量 $\bmod$  $998244353$。

数据范围：$T = 5, 1 \le n \le 10^5$。

## Solution

### Part 1

考虑 $\text{dp}$，状态暂且设计为：$n$ 个点的有标号点双连通图数量。

设计转移的关键在于转化为若干互相独立的子问题。在边双计数中，我们对任意无向连通图，将含根的**极大边双**拎出，而剩余部分形如若干个**连通图 + 割边**，从而转化为若干独立的子问题。从而，以含根的极大边双为基础转移，即可解决边双计数问题。

但若从割点的角度考察，就没有这么好的性质了。对于任意根 $rt$，含 $rt$ 的极大点双**可能有多个**，例如链 $1-2-3$，含 $2$ 的极大点双有两个。从而，若以含根的极大点双为基础转移，会造成重复计数。

那么，我们该以何为基础转移呢？我们有描述割点等信息的强有力工具——**圆方树**：

- ① 对于根在圆方树上相邻的方点，这些方点的子树是两两独立的。

- ② 对于每个方点在圆方树上的儿子，这些儿子都是圆点，它们的子树也是两两独立的。同时，若该方点恰有 $k$ 个儿子，则会对应一个大小为 $k + 1$ 的点双。

这启发我们设计以下三个 $\text{dp}$ 状态，互相转移：

- $f_n$：大小为 $n$ 的点双数量（本文若无特殊说明，均默认为有标号计数）
- $g_n$：以某个方点为根，且恰有 $n$ 个圆点的各圆方树**对应的无向图总数**。
- $h_n$：大小为 $n$ 的**有根**无向连通图数量。

根据 ①，我们有 $\frac {g_n} {n!} = [x^n]\sum_{k=1}^n f_{k+1} \frac {H(x)^k} {k!}$。这里，$H(x)$ 表示 $h$ 的 EGF，除掉 $k!$ 是因为方点各儿子的顺序无关紧要。

根据 ②，我们有 $\frac {h_n} {n!} = xe^{G(x)}$。这里，$G(x)$ 表示 $g$ 的 EGF，乘 $x$ 是因为根也是圆点，且也要钦定标号。

### Part 2

剩下的工作就较为套路了。

令 $F(x) = \sum_{k=1}^n \frac {f_{k+1}x^k} {k!}$，则 $G(x) = F(H(x))$，从而 $H(x) = xe^{F(H(x))}$。

两边同除 $x$，得 $\frac {H(x)} {x} = e^{F(H(x))}$。

两边取对数，得 $\ln(\frac {H(x)} {x}) = F(H(x))$。

令 $Z(x) = \ln(\frac {H(x)} {x})$，则 $Z(x) = F(H(x))$。

使用扩展拉格朗日反演，复杂度单次 $O(n \log n)$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N=262150,mod=998244353,Gb=3,Gi=(mod+1)/3,inv2=(mod+1)/2;

int read(){
	int s=0,w=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-w;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=(s<<1)+(s<<3)+(ch^'0');ch=getchar();}
	return s*w;
}
int n=1e5,k,h[N],z[N],th[N],res[N],fac[N],inv[N],ifac[N],all_graphs[N];
inline int quick_power(int x,int y){
	int res=1;
	for (;y;y=y>>1,x=(x*x)%mod){
		if (y&1)  res=(res*x)%mod;
	}
	return res;
}
inline int getinv(int x){return quick_power(x,mod-2);}
inline int Down(int x){return (x>=mod)?(x-mod):x;}
inline int Up(int x){return (x<0)?(x+mod):x;}
namespace poly{
	int rev[N],pw1[N],pw2[N];
	void init(int n){
		inv[1]=fac[0]=ifac[0]=1;
		for (int i=1;i<=n;i++)  fac[i]=(fac[i-1]*i)%mod;
		for (int i=2;i<=n;i++)  inv[i]=((mod-mod/i)*inv[mod%i])%mod;
		for (int i=1;i<=n;i++)  ifac[i]=(ifac[i-1]*inv[i])%mod;
		for (int i=2;i<=n;i<<=1){
			int t=(mod-1)/i,x=quick_power(Gb,t),y=quick_power(Gi,t); pw1[i>>1]=pw2[i>>1]=1;
			for (int j=(i>>1)+1;j<i;j++)  pw1[j]=(pw1[j-1]*x)%mod,pw2[j]=(pw2[j-1]*y)%mod;
		}
	}
	void NTT(int *A,int len,int flag){
		for (int i=0;i<len;++i){
			if (i>rev[i])  swap(A[i],A[rev[i]]);
		}
		for(int mid=1;mid<len;mid<<=1)for(int i=0;i<len;i+=(mid<<1))for(int j=0;j<mid;j++){
			int u=A[i+j],v=(flag==1?pw1:pw2)[mid+j]*A[i+j+mid]%mod;
			A[i+j]=Down(u+v),A[i+j+mid]=Up(u-v);
		}
		if (flag==-1){
			int val=getinv(len);
			for (int i=0;i<len;++i)  A[i]=(A[i]*val)%mod;
		}
	}
	void get_inv(int *A,int *B,int n){
		if (n==1)  return B[0]=getinv(A[0]),void();
		get_inv(A,B,(n+1)>>1);

		int p=1,cnt=0,f[N];
		while (p<=(n<<1))  p<<=1,cnt++;
		for (int i=0;i<=p;i++)  rev[i]=(rev[i>>1]>>1)|((i&1)<<(cnt-1));
		for (int i=0;i<n;i++)  f[i]=A[i];
		fill(f+n,f+p+1,0),NTT(f,p,1),NTT(B,p,1);
		for (int i=0;i<=p;i++)  B[i]=(Up((2ll-B[i]*f[i])%mod)*B[i])%mod;
		NTT(B,p,-1),fill(B+n,B+p+1,0);
	}
	void poly_mul(int *A,int *B,int *C,int n,int m){//degA=n, degB=m
		int p=1,cnt=0,f[N],g[N];
		while (p<=n+m)  p<<=1,cnt++;
		for (int i=0;i<=p;++i)  rev[i]=(rev[i>>1]>>1)|((i&1)<<(cnt-1));
		for (int i=0;i<=n;++i)  f[i]=A[i];
		for (int i=0;i<=m;++i)  g[i]=B[i];
		fill(f+n+1,f+p+1,0),fill(g+m+1,g+p+1,0);
		NTT(f,p,1),NTT(g,p,1);
		for (int i=0;i<=p;++i)  C[i]=(f[i]*g[i])%mod;
		NTT(C,p,-1),fill(C+n+m+1,C+p+1,0);
	}
	void poly_inv(int *A,int *B,int n){//deg=n-1
		int p=1,f[N];
		while (p<=(n<<1))  p<<=1;
		for (int i=0;i<n;i++)  f[i]=A[i];
		fill(f+n,f+p+1,0),fill(B,B+p+1,0),get_inv(f,B,n);
	}
	void poly_divide(int *A,int *B,int *D,int *R,int n,int m){//degA=n, degB=m
		int p=1,a[N],b[N],f[N],g[N];
		while (p<=n+m)  p<<=1;
		for (int i=0;i<=n;i++)  a[i]=A[i];
		for (int i=0;i<=m;i++)  b[i]=B[i];
		fill(a+n+1,a+p+1,0),fill(b+m+1,b+p+1,0),fill(D,D+p+1,0),fill(R,R+p+1,0);
		reverse(b,b+m+1),reverse(a,a+n+1);
		poly_inv(b,f,n-m+1),poly_mul(a,f,D,n-m,n-m),reverse(a,a+n+1);
		reverse(b,b+m+1),reverse(D,D+n-m+1),poly_mul(b,D,g,m,n-m);
		for (int i=0;i<m;i++)  R[i]=Up(a[i]-g[i]);
	}
	void poly_sqrt(int *A,int *B,int n){//degA=n-1
		if (n==1)  return B[0]=1,void();
		poly_sqrt(A,B,(n+1)>>1);

		int p=1,f[N];
		while (p<=(n<<1))  p<<=1;
		poly_inv(B,f,n),poly_mul(A,f,f,n,n);
		for (int i=0;i<n;i++)  B[i]=((B[i]+f[i])*inv2)%mod;
		fill(B+n,B+p+1,0);
	}
	void poly_derivate(int *A,int *B,int n){
		for (int i=1;i<=n;i++)  B[i-1]=(A[i]*i)%mod;
		B[n]=0;
	}
	void poly_integrate(int *A,int *B,int n){
		for (int i=1;i<=n;i++)  B[i]=(A[i-1]*inv[i])%mod;
		B[0]=0;
	}
	void poly_ln(int *A,int *B,int n){//degA=n-1
		int p=1,a[N],f[N],g[N];
		while (p<=(n<<1))  p++;
		for (int i=0;i<n;i++)  a[i]=A[i];
		fill(a+n,a+p+1,0),fill(f,f+p+1,0),fill(g,g+p+1,0);
		poly_inv(a,f,n),poly_derivate(A,g,n),poly_mul(f,g,g,n,n),poly_integrate(g,B,n);
	}
	void get_exp(int *A,int *B,int n){//degA=n-1
		if (n==1)  return B[0]=1,void();
		get_exp(A,B,(n+1)>>1);

		int p=1,f[N];
		while (p<=(n<<1))  p++;
		fill(f,f+p+1,0),poly_ln(B,f,n);
		for (int i=0;i<n;i++)  f[i]=Up(A[i]-f[i]);
		f[0]=Down(f[0]+1),poly_mul(f,B,B,n,n),fill(B+n,B+p+1,0);
	}
	void poly_exp(int *A,int *B,int n){//deg=n-1
		int p=1,f[N];
		while (p<=(n<<1))  p<<=1;
		for (int i=0;i<n;i++)  f[i]=A[i];
		fill(f+n,f+p+1,0),fill(B,B+p+1,0),get_exp(f,B,n);
	}
	void poly_power(int *A,int *B,int n,int k){//degA=n-1
		int f[N];
		for (int i=0;i<n;i++)  f[i]=A[i];
		poly::poly_ln(f,B,n);
		for (int i=0;i<n;i++)  f[i]=(B[i]*k)%mod;
		poly::poly_exp(f,B,n);
	}
}
signed main(){
	auto find_H=[&](){
		for (int sz=n+1;~sz;sz--)  all_graphs[sz]=(quick_power(2,(sz*(sz-1))>>1)*ifac[sz])%mod;
		poly::poly_ln(all_graphs,h,n+2);
		for (int sz=1;sz<=n;sz++)  (h[sz]*=sz)%=mod;
	};
	auto find_Z=[&](){
		for (int sz=0;sz<=n;sz++)  z[sz]=h[sz+1];
		poly::poly_ln(z,z,n+1),poly::poly_derivate(z,z,n+1);
	};
	auto find_th=[&](){
		for (int i=0;i<=n;i++)  th[i]=h[i+1];
		poly::poly_inv(th,th,n+1);
	};
	auto find_coef=[&](int pos){
		poly::poly_power(th,res,pos,pos);
		poly::poly_mul(res,z,res,pos,pos);
		return (res[pos-1]*inv[pos])%mod;
	};
	poly::init(N-5),find_H(),find_Z(),find_th();
	for (int t=1,x;t<=5;t++){
		x=read();
		if (x<=3)  puts("1");
		else printf("%lld\n",(find_coef(x-1)*fac[x-1])%mod);
	}
	return 0;
}
```


---

## 作者：gxy001 (赞：2)

## 点联通图计数

前置知识：[无向联通图计数](https://www.luogu.com.cn/problem/P4841)，扩展拉格朗日反演。

### 无向联通图计数

设 $F(x)$ 为有标号无向图的 $\text{EGF}$，$G(x)$ 为有标号无向联通图的 $\text{EGF}$，根据 $\exp$ 的组合意义有 $F=\exp G$，所以有 $G=\ln F$，$F(x)=\sum\limits_{i=0}^\infin\frac{2^{i\choose 2}x^i}{i!}$。

### 点双联通图计数

设有根有标号无向联通图的 $\text{EGF}$ 为 $D(x)$，显然有 $[x^n]D(x)=n[x^n]G(x)$。设有根有标号点双联通图的 $\text{EGF}$ 为 $B(x)$。注意到一个有根无向图的根可能在多个点双中，考虑断掉所有与根相邻的边，求出连通块的 $\text{EGF}$，然后 $\exp$ 后乘根就是 $D(x)$ 了。容易发现，一个连通块是由一个有根点双上除根外的每一个点连出一个无向联通图构成的，连通块的 $\text{EGF}$ $Q(x)=\sum\limits_{i=1}^\infin b_{i+1}\frac{D^i(x)}{i!}=B'(D(x))$。所以：
$$
D(x)=x\exp(B'(D(x)))\\
B'(D(x))=\ln\frac{D(x)}{x}
$$
设 $H(x)=\ln\frac{D(x)}{x}$，对 $D$ 做复合逆。
$$
B'(x)=H(D^{-1}(x))\\
$$
由扩展拉格朗日反演得：
$$
[x^n]B'(x)=\frac{1}{n}[x^{n-1}](H'(x)(\frac{x}{D(x)})^n)\\
[x^n]B'(x)=\frac{1}{n}[x^{n-1}](H'(x)\exp(-nH(x)))\\
$$
然后就可以直接做了。

```cpp
#include<cstdio>
#include<algorithm>
int const mod=998244353,g=3,gi=998244354/3,maxn=400010;
int pow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*x*res%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return res;
}
struct NTT{
	int r[maxn],lim;
	NTT():r(),lim(){}
	void getr(int lm){
		lim=lm;
		for(int i=0;i<lim;i++)r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));
	}
	void operator ()(int *a,int type){
		for(int i=0;i<lim;i++)if(i<r[i])std::swap(a[i],a[r[i]]);
		for(int mid=1;mid<lim;mid<<=1){
			int rt=pow(type==1?g:gi,(mod-1)/(mid<<1));
			for(int r=mid<<1,j=0;j<lim;j+=r){
				int p=1;
				for(int k=0;k<mid;k++,p=1ll*p*rt%mod){
					int x=a[j+k],y=1ll*p*a[j+mid+k]%mod;
					a[j+k]=(x+y)%mod,a[j+mid+k]=(x-y+mod)%mod;
				}
			}
		}
		if(type==-1)for(int i=0,p=pow(lim,mod-2);i<lim;i++)a[i]=1ll*p*a[i]%mod;
	}
}ntt;
void inv(int const *a,int *ans,int n){
	static int tmp[maxn];
	for(int i=0;i<n<<1;i++)tmp[i]=ans[i]=0;
	ans[0]=pow(a[0],mod-2);
	for(int m=2;m<=n;m<<=1){
		int lim=m<<1;
		ntt.getr(lim);
		for(int i=0;i<m;i++)tmp[i]=a[i];
		ntt(tmp,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=ans[i]*(2-1ll*ans[i]*tmp[i]%mod+mod)%mod,tmp[i]=0;
		ntt(ans,-1);
		for(int i=m;i<lim;i++)ans[i]=0;
	}
}
void inte(int const *a,int *ans,int n){
	for(int i=n-1;i;i--)ans[i]=1ll*a[i-1]*pow(i,mod-2)%mod;
	ans[0]=0;
}
void der(int const *a,int *ans,int n){
	for(int i=1;i<n;i++)ans[i-1]=1ll*i*a[i]%mod;
	ans[n-1]=0;
}
void ln(int const *a,int *ans,int n){
	static int b[maxn];
	for(int i=0;i<n<<1;i++)ans[i]=b[i]=0;
	inv(a,ans,n);
	der(a,b,n);
	int lim=n<<1;
	ntt.getr(lim);
	ntt(b,1),ntt(ans,1);
	for(int i=0;i<lim;i++)b[i]=1ll*ans[i]*b[i]%mod,ans[i]=0;
	ntt(b,-1);
	for(int i=n;i<lim;i++)b[i]=0;
	inte(b,ans,n);
}
void exp(int const *a,int *ans,int n){
	static int f[maxn];
	for(int i=0;i<n<<1;i++)ans[i]=f[i]=0;
	ans[0]=1;
	for(int m=2;m<=n;m<<=1){
		int lim=m<<1;
		ln(ans,f,m);
		f[0]=(a[0]+1-f[0]+mod)%mod;
		for(int i=1;i<m;i++)f[i]=(a[i]-f[i]+mod)%mod;
		ntt.getr(lim);
		ntt(f,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=1ll*ans[i]*f[i]%mod,f[i]=0;
		ntt(ans,-1);
		for(int i=m;i<lim;i++)ans[i]=0;
	}
}
int f[maxn],d[maxn],t[maxn],fac[maxn],ifac[maxn],lim=1<<17,tpd[maxn];
int main(){
	fac[0]=1;
	for(int i=1;i<lim;i++)fac[i]=1ll*fac[i-1]*i%mod;
	ifac[lim-1]=pow(fac[lim-1],mod-2);
	for(int i=lim-1;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;
	for(int i=0;i<lim;i++)f[i]=1ll*pow(2,1ll*i*(i-1)/2%(mod-1))*ifac[i]%mod;
	ln(f,d,lim);
	for(int i=0;i<lim;i++)d[i]=1ll*d[i]*i%mod;
	for(int i=0;i<lim;i++)d[i]=d[i+1],f[i]=0;
	d[lim-1]=0;
	ln(d,f,lim);
	int testcase=5;
	for(int i=0;i<lim;i++)d[i]=f[i],f[i]=0;
	der(d,tpd,lim);
	ntt.getr(lim<<1);
	ntt(tpd,1);
	while(testcase--){
		int n;
		scanf("%d",&n);
		--n;
		if(n==0){puts("1");continue;}
		for(int i=0;i<lim;i++)f[i]=0,t[i]=1ll*(mod-n)*d[i]%mod;
		exp(t,f,lim);
		ntt.getr(lim<<1);
		ntt(f,1);
		for(int i=0;i<lim<<1;i++)f[i]=1ll*f[i]*tpd[i]%mod;
		ntt(f,-1);
		printf("%lld\n",1ll*f[n-1]*fac[n-1]%mod);
	} 
	return 0;
}
```



---

## 作者：Infinite_Eternity (赞：0)

# Description

[P5827 点双连通图计数](https://www.luogu.com.cn/problem/P5827)

给出 $n$，求出 $n$ 个点的图满足该图为一个点双连通分量的方案数。

# Pre-reading

- 拓展拉格朗日反演

- 多项式指数函数、对数函数

# Analysis

如果做过[有标号无向连通图计数](https://www.luogu.com.cn/problem/P4841)就最好了。

我们来重温一下，我们设有标号无向图的指数生成函数为 $F(x)$，可以得到：

$$F(x)=\sum_{i=0}^{\infty} \frac{2^{\binom{i}{2}}}{i!}x^i$$

这里的 $2^{\binom{i}{2}}$ 就是每条边要或者不要。

我们再设有标号无向连通图的指数生成函数为 $G(x)$，可以得到：

$$G(x)=\sum_{i=0}^{\infty} \frac{F^i(x)}{i!}=e^{F(x)}$$

$$\Rightarrow F(x)=\ln G(x)$$

我们现在再设 $D(x)$ 为有标号有根无向连通图，可以得到：

$$[x^n]D(x)=n[x^n]G(x)$$

我们再设 $b_i$ 为 $i$ 个点的无根点双联通分量的个数，我们可以得到：

$$D(x)=xe^{\sum_{i=1}^{\infty} b_{i+1}\frac{D^i(x)}{i!}}$$

感性理解就是说，一个有标号有根无向连通图我们把根所在的点双提出来，上面每个点对应了一个连通块的根，除以 $i!$ 是因为图是不讲顺序的。最重要的一点是每个联通块之间互不干涉，所以不会影响根所在的点双连通分量大小。

如果我们设：

$$B(x)=\sum_{i} b_{i+1} \frac{x^i}{i!}$$

那我们就可以得到：

$$D(x)=xe^{B(D(x))}$$

$$\Rightarrow B(D(x))=\ln \frac{D(x)}{x}$$

$$\Rightarrow B(x)=\ln \frac{x}{D^{-1}(x)}$$

这里的 $D^{-1}(x)$ 是指的 $D(x)$ 的复合逆函数，即：

$$D^{-1}(D(x))=x$$

我们设 $H(x)=\ln \frac{D(x)}{x}$，可以得到：

$$B(x)=H(D^{-1}(x))$$

这里使用拓展拉格朗日反演公式可以得到：

$$
\begin{aligned}
[x^n]B(x)&=[x^n]H(D^{-1}(x))\\
&=\frac{1}{n}[x^{-1}]H^{'}(x)(\frac{1}{D(x)})^n\\
&=\frac{1}{n}[x^{n-1}]H^{'}(x)(\frac{x}{D(x)})^n
\end{aligned}
$$

这里使用多项式快速幂公式就可以得到：

$$
\begin{aligned}
&=\frac{1}{n}[x^{n-1}]H^{'}(x)e^{-n\ln \frac{D(x)}{x}}\\
&=\frac{1}{n}[x^{n-1}]H^{'}(x)e^{-nH(x)}
\end{aligned}
$$

于是，我们就可以在 $\mathcal{O}(n \log n)$ 的时间复杂度内解决这个问题了。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define mod 998244353
#define Gii 332748118
#define ll long long
#define MAXN 600005
#define Gi 3

int quick_pow (int a,int b)
{
    int res = 1;
    for (; b; b >>= 1,a = 1ll * a * a % mod) if (b & 1) res = 1ll * res * a % mod;
    return res;
}

int limit,l,r[MAXN];

void NTT (int *a,int type)
{
    for (Int i = 0; i < limit; ++ i) if (i < r[i]) swap (a[i],a[r[i]]);
    for (Int mid = 1; mid < limit; mid <<= 1)
    {
        int Wn = quick_pow (type == 1 ? Gi : Gii,(mod - 1) / (mid << 1));
        for (Int R = mid << 1,j = 0; j < limit; j += R)
        {
            for (Int k = 0,w = 1; k < mid; ++ k,w = 1ll * w * Wn % mod)
            {
                int x = a[j + k],y = 1ll * w * a[j + k + mid] % mod;
                a[j + k] = (x + y) % mod,a[j + k + mid] = (x + mod - y) % mod;
            }
        }
    }
    if (type == 1) return ;
    int Inv = quick_pow (limit,mod - 2);
    for (Int i = 0; i < limit; ++ i) a[i] = 1ll * a[i] * Inv % mod;
}

int c[MAXN];

void Solve (int len,int *a,int *b)
{
    if (len == 1) return b[0] = quick_pow (a[0],mod - 2),void ();
    Solve ((len + 1) >> 1,a,b);
    limit = 1,l = 0;
    while (limit < (len << 1)) limit <<= 1,l ++;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for (Int i = 0; i < len; ++ i) c[i] = a[i];
    for (Int i = len; i < limit; ++ i) c[i] = 0;
    NTT (c,1);
    NTT (b,1);
    for (Int i = 0; i < limit; ++ i) b[i] = 1ll * b[i] * (2 + mod - 1ll * c[i] * b[i] % mod) % mod;
    NTT (b,-1);
    for (Int i = len; i < limit; ++ i) b[i] = 0;
}

void deravitive (int *a,int n)
{
    for (Int i = 1; i <= n; ++ i) a[i - 1] = 1ll * a[i] * i % mod;
    a[n] = 0;
}

void inter (int *a,int n)
{
    for (Int i = n; i >= 1; -- i) a[i] = 1ll * a[i - 1] * quick_pow (i,mod - 2) % mod;
    a[0] = 0;
}

int b[MAXN];

void Ln (int *a,int n)
{
    memset (b,0,sizeof (b));
    Solve (n,a,b);
    deravitive (a,n);
    while (limit <= n) limit <<= 1,l ++;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    NTT (a,1),NTT (b,1);
    for (Int i = 0; i < limit; ++ i) a[i] = 1ll * a[i] * b[i] % mod;
    NTT (a,-1),inter (a,n);
    for (Int i = n + 1; i < limit; ++ i) a[i] = 0;
}

int F0[MAXN];

void Exp (int *a,int *B,int n)
{
    if (n == 1) return B[0] = 1,void ();
    Exp (a,B,(n + 1) >> 1);
    for (Int i = 0; i < limit; ++ i) F0[i] = B[i];
    Ln (F0,n);
    F0[0] = (a[0] + 1 + mod - F0[0]) % mod;
    for (Int i = 1; i < n; ++ i) F0[i] = (a[i] + mod - F0[i]) % mod;
    NTT (F0,1);
    NTT (B,1);
    for (Int i = 0; i < limit; ++ i) B[i] = 1ll * F0[i] * B[i] % mod;
    NTT (B,-1);
    for (Int i = n; i < limit; ++ i) B[i] = 0;
}

int read ()
{
    int x = 0;
    char c = getchar();
    int f = 1;
    while (c < '0' || c > '9')
    {
        if (c == '-') f = -f;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}

void write (int x)
{
    if (x < 0)
    {
        x = -x;
        putchar ('-');
    }
    if (x > 9) write (x / 10);
    putchar (x % 10 + '0');
}

int fac[MAXN],caf[MAXN],lim = 3e5;

void init ()
{
    fac[0] = 1;
    for (Int i = 1; i <= lim; ++ i) fac[i] = 1ll * fac[i - 1] * i % mod;
    caf[lim] = quick_pow (fac[lim],mod - 2);
    for (Int i = lim; i; -- i) caf[i - 1] = 1ll * caf[i] * i % mod;
}

int H[MAXN],H_[MAXN],G[MAXN],FG[MAXN];

void prepare ()
{
    int len = 1 << 17,lll = 17;
    for (Int i = 0; i < len; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << lll - 1);
    for (Int i = 0; i < len; ++ i) H[i] = 1ll * quick_pow (2,1ll * i * (i - 1) / 2 % (mod - 1)) * caf[i] % mod;
    Ln (H,len - 1);
    for (Int i = 0; i < len; ++ i) H[i] = 1ll * H[i + 1] * (i + 1) % mod;
    H[len - 1] = 0;
    Ln (H,len - 1);
    for (Int i = 0; i < len; ++ i) H_[i] = H[i];
    limit = 1 << 18,l = 18;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l - 1);
    deravitive (H_,len - 1),NTT (H_,1);
}

void work (int n)
{
    if (!(-- n)) return puts ("1"),void ();
    limit = 1 << 17,l = 17;
    memset (F0,0,sizeof (F0)),memset (FG,0,sizeof (FG));
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l - 1);
    for (Int i = 0; i < limit; ++ i) G[i] = 1ll * H[i] * (mod - n) % mod;
    Exp (G,FG,1 << 17),limit = 1 << 18,l = 18;
    for (Int i = 0; i < limit; ++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l - 1);
    NTT (FG,1);
    for (Int i = 0; i < limit; ++ i) FG[i] = 1ll * FG[i] * H_[i] % mod;
    NTT (FG,-1);
    write (1ll * FG[n - 1] * fac[n - 1] % mod),putchar ('\n');
}

signed main()
{
    init (),prepare ();
    for (Int i = 1; i <= 5; ++ i) work (read ());
    return 0;
}
```


---


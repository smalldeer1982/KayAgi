# 「ACOI2020」修学旅行

## 题目背景

![T5](https://s2.ax1x.com/2020/01/12/loS0Wq.md.png)

第一学期开学没多久，E 班的各位就要去修学旅行了！

## 题目描述

现在，六个人 赤羽 業，杉野 友人，奧田 愛美，茅野 楓，神崎 有希子，潮田 渚 为一组，他们将在京都进行一次暗杀旅行。他们的目标仍然是狙击杀老师。政府同时派来了职业狙击手 赤红之眼。但是完成任务的同时，他们想让快乐度尽量的高。

聪明的神崎 有希子（Kanzaki Yukiko）终于求出了快乐度的表达式，令人感到震惊的是，快乐度竟然和旅行景点个数和暗杀杀老师次数有关！

假设他们经过了 $n$ 个景点，暗杀了 $m$ 次杀老师，且定义：

$$
\Gamma(a,b)=\left\{
    \begin{aligned}
    & 1,a>b&\\
    &  \prod_{i=a}^b i,a \le b&\\
    \end{aligned}
    \right.
$$

那么快乐度为：

$$
\sum_{i=0}^m \lgroup \frac{\sqrt{\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\Gamma(n+1,n+i)} \times \Gamma(n-i+1,n) \rgroup 
$$

**我们保证** $\frac{\sqrt{\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\Gamma(n+1,n+i)} \times \Gamma(n-i+1,n)$ **是一个整数。**

现在他们有 $T$ 个问题想要问你，如果他们经过了 $n$ 个景点并且暗杀 $m$ 次杀老师，能否告诉他们快乐度呢？

**由于答案可能太大，请将答案对 $998244353$ 取模。**

## 说明/提示

#### 数据范围

**本题采用捆绑测试**。

- Subtask 1（10 points）：$T \leq 10$，$n,m \leq 10$。     
- Subtask 2（20 points）：$T \leq 100$，$n,m \leq 5 \times 10^4$。      
- Subtask 3（30 points）：$T \leq 50$，$n,m \leq 9 \times 10^8$。  
- Subtask 4（40 points）：数据无特殊限制。  

对于 $100\%$ 的数据，$m \leq n$，$1 \leq T \le 10^2$，$1 \leq n,m \leq 9 \times 10^8$。

---
#### 提示

**第三个子任务中的测试点时限 2S，第四个子任务中的测试点时限 5S。**

## 样例 #1

### 输入

```
5
5 3
7 3
9 6
100 50
44 22

```

### 输出

```
26
64
466
41441083
461961723
```

# 题解

## 作者：飞雨烟雁 (赞：6)

原题链接：[P6043 「ACOI2020」修学旅行](https://www.luogu.com.cn/problem/P6043)。

把之前的笔记整理一下，写个题解。

------------

我们先来证明题目中要用到的结论（$n\ge 2m$）：

$$\sum_{k=0}^m\binom mk^2\binom{n+k}{2m}=\binom nm^2$$

有一个叫 **Zeilberger** 的神奇算法，可以证明这条式子。但是我不会，所以只好用生成函数硬推了。


------------

我们先证一个引理（$n\ge m$）：

$$\sum_{k=0}^m(-1)^{m-k}\binom mk\binom {n+k}n=\binom nm$$

这个引理的证明较简单。有两种方法，一种是纯生成函数推导，这里采用另一种方法：二项式反演。

记 $g_k=\binom {n+k}n,f_k=\binom nk$，相当于我们要证明：

$$\sum_{k=0}^m(-1)^{m-k}\binom mkg_k=f_m$$

根据二项式反演的结论，我们只需要证明：

$$\sum_{k=0}^m\binom mkf_k=g_m$$

代入 $f_k$ 定义后我们发现左式是一个卷积的形式，于是：

$$\sum_{k=0}^m\binom {m}{m-k}\binom{n}{k}=[x^m]\Big((1+x)^m*(1+x)^n\Big)=[x^m](1+x)^{m+n}=g_m$$

这样引理就得证了。

------------

接着有以下两个基础的式子：

$$\binom mk=[x^m]\dfrac{x^k}{(1-x)^{k+1}}$$
$$\binom {n+k}{2m}=[z^{2m}]\dfrac{1}{(1-z)^{n-2m+k+1}}$$

它们是基于以下这个等式得出来的：

$$\sum_{k}\binom{m+k}nx^k=\frac{x^{n-m}}{(1-x)^{n+1}}$$

数学归纳法可证，此处略过。

------------


然后把这两个式子代入到左式，然后消掉一个元简化式子：

$$
\begin{aligned}
\sum_{k=0}^m\binom mk^2\binom{n+k}{2m}&=\sum_{k}[x^my^mz^{2m}]\dfrac{x^k}{(1-x)^{k+1}}\dfrac{y^k}{(1-y)^{k+1}}\dfrac{1}{z^{n-2m+k+1}}\\
&=[x^my^mz^{2m}]\dfrac{1}{(1-x)(1-y)(1-z)^{n-2m+1}}\dfrac{1}{1-\frac{xy}{(1-x)(1-y)(1-z)}}\\
&=[x^mz^{2m}]\dfrac{1}{(1-z)^{n-2m}}[y^m]\dfrac{1}{(z-xz-1)y+(x-1)(z-1)}\\
&=[x^mz^{2m}]\dfrac 1{(1-z)^{n-2m}}\dfrac{(1+xz-z)^m}{(1-x)^{m+1}(1-z)^{m+1}}
\end{aligned}
$$

最后一个等号是用到了 $[x^n](ax+b)^{-1}=(-a)^nb^{-n-1}$ 这条等式，同样可归纳证明。

下一步，我们要把这个式子再展开，并化简成引理的形式：

$$
\begin{aligned}
\sum_{k=0}^m\binom mk^2\binom{n+k}{2m}&=[x^mz^{2m}]\sum_{k=0}^m\binom mk\dfrac{z^k(x-1)^k}{(1-x)^{m+1}(1-z)^{n-m+1}}\\
&=\sum_{k=0}^m(-1)^k\binom mk[x^m]\dfrac{1}{(1-x)^{m-k+1}}[z^{2m-k}]\dfrac{1}{(1-z)^{n-m+1}}\\
&=\sum_{k=0}^m(-1)^k\binom mk\binom{2m-k}{m}\binom{n+m-k}{n-m}\\
&=\binom nm\sum_{k=0}^m(-1)^k\binom mk\binom{n+m-k}{n}\\
&=\binom nm\sum_{k=0}^m(-1)^{m-k}\binom mk\binom{n+k}{n}\\
&=\binom nm^2
\end{aligned}
$$

这样就证完了！结合这条式子就可以将「快乐度」的表达式化简为组合数前缀和了。

顺带一提，这个思路可以证明一个更普遍的结论：

$$\sum_k\binom nk\binom mk\binom {\alpha+k}{n+m}=\binom \alpha n\binom \alpha m$$

不过，这个证明有个小缺点——整体思路不够清晰，怎么这样推着推着就求出来了？我也不知道该怎么解释，因为我本来就是乱推的，只是一不小心就给证出来了，~~这也许就是瞎猫碰见死老鼠罢~~。


------------

接下来看这道题的第二部分，即**快速求组合数前缀和**。（注：以下的做法参考了 [OI WIKI](https://oi-wiki.org/math/poly/shift/#%E6%A8%A1%E7%B4%A0%E6%95%B0%E6%84%8F%E4%B9%89%E4%B8%8B%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E5%89%8D%E7%BC%80%E5%92%8C) 的内容）

这个求法的关键是这条式子：

$$\begin{bmatrix}\binom{n}{m+1}_ {_ {_ {}}}\\\sum_{i=0}^m\binom ni\end{bmatrix}=\dfrac{1}{(m+1)!}\Bigg(\prod_{i=0}^m\,\begin{bmatrix}n-i&0\\i+1&i+1\end{bmatrix}\Bigg)\begin{bmatrix}1\\0\end{bmatrix}$$

要注意这里矩阵乘法的顺序，把累乘展开后，在最左边的应该是 $i=m$ 的矩阵，最右边的是 $i=0$ 的矩阵。

然后就可以按一般的方法来维护多项式点值了，先设：

$$M_d(x)=\prod_{i=1}^d\begin{bmatrix}-x+n-i+1&0\\x+i&x+i\end{bmatrix}=\begin{bmatrix}f_d(x)&0\\g_d(x)&h_d(x)\end{bmatrix}$$

那么 $d\rightarrow 2d$ 的方法就是：

$$\begin{aligned}
f_{2d}(x)&=f_d(x+d)f_d(x)\\
g_{2d}(x)&=f_d(x)g_d(x+d)+g_d(x)h_d(x+d)\\
h_{2d}(x)&=h_d(x+d)h_d(x)
\end{aligned}$$

从[这篇博客](https://www.luogu.com.cn/blog/242973/solution-p5702)中，我们得知一个偷懒的小技巧，设 $v=2^{\lceil \log_2\sqrt m\rceil}$，对于 $M_d(x)$，我们维护 $M_d(0),M_d(v),M_d(2v)...M_d(dv)$ 这些点值。因为 $v$ 是 $2$ 的幂，所以可以绕开 $d\rightarrow d+1$ 的步骤，这样就不用写拉插辣！不过这样会让常数稍稍变大，常数大慎用。

至于最外面那个 $\frac 1{(m+1)!}$，注意到 $h_d(x)=\frac{(x+d)!}{x!}$，所以 $(v^2)!=h_v(0)h_v(v)...h_v(v^2-v)$。$v^2$ 在 $m$ 附近，可以借助 $(v^2)!$ 求出 $(m+1)!$。

总的时间复杂度是 $O(T\sqrt m\log m)$，以下是核心代码：

```cpp
Poly T1, T2, T3;
int F[Mx], G[Mx], H[Mx];

void Solve(int d, const int B, const int N){
	if(d == 1){
		F[0] = N, F[1] = N - B;
		G[0] = H[0] = 1;
		G[1] = H[1] = B + 1;
		return;
	}
	Solve(d >> 1, B, N), d >>= 1;
	
	for(int i = 0; i <= d; ++i) T1.F[i] = F[i], T2.F[i] = G[i], T3.F[i] = H[i];
	T1.DotShift(d, d + 1), T2.DotShift(d, d + 1), T3.DotShift(d, d + 1);
	for(int i = (d << 1); i > d; --i) F[i] = T1.F[i - d - 1], G[i] = T2.F[i - d - 1], H[i] = T3.F[i - d - 1];
	
	int K = d * Inv(B) % Mod; d <<= 1;
	for(int i = 0; i <= d; ++i) T1.F[i] = F[i], T2.F[i] = G[i], T3.F[i] = H[i];
	T1.DotShift(d, K), T2.DotShift(d, K), T3.DotShift(d, K);
	
	for(int i = 0; i <= d; ++i){
		G[i] = (1ll * T2.F[i] * F[i] + 1ll * T3.F[i] * G[i]) % Mod;
		F[i] = 1ll * T1.F[i] * F[i] % Mod;
		H[i] = 1ll * T3.F[i] * H[i] % Mod;
	}
}

int BinomSum(int n, int m){ // sum[0 <= k <= m] C(n, k)
	if(n == m) return FastPow(2, n);
	if(m > (n >> 1)) return (FastPow(2, n) - BinomSum(n, n - m - 1)) % Mod;
	int v = ceil(log(sqrt(m)) / log(2)), B = 1 << v;
	Solve(B, B, n);
	int K = m / B, M = K * B;
	
	/* Matrix Multiply */
	int m1 = F[0], m2 = G[0], m3 = H[0];
	for(int i = 1; i < K; ++i){
		m2 = (1ll * m1 * G[i] + 1ll * m2 * H[i]) % Mod;
		m1 = 1ll * m1 * F[i] % Mod;
		m3 = 1ll * m3 * H[i] % Mod;
	}
	if(!K) m1 = m3 = 1, m2 = 0;
	
	m3 = Inv(m3), m2 = 1ll * m2 * m3 % Mod;
	int Ans = m2;
	for(int i = M; i <= m; ++i){
		Ans = (Ans + 1ll * m1 * m3) % Mod;
		m3 = m3 * Inv(i + 1) % Mod;
		m1 = 1ll * m1 * (n - i) % Mod;
	}
	
	return Ans;
}
```

双倍经验：[P5388 [Cnoi2019] 最终幻想](https://www.luogu.com.cn/problem/P5388)。

---

## 作者：Y_B_X (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P6043)

> 题意：  
设 $\displaystyle f(n,m)\!=\!\sum_{i=0}^{m}\sqrt{\sum_{j=0}^{i}\binom{i}{j}^2\binom{n+2i-j}{2i}}\dfrac{n!}{(n-i)!}\dfrac{n!}{(n+i)!}$  
$T$ 次询问，每次给出 $n,m$，求 $f(n,m)$。  
$T\leq 100$，$n,m\leq 9\times 10^8$。

事实上能够发现 $\displaystyle \sum_{j=0}^{i}\binom{i}{j}^2\binom{n+2i-j}{2i}=\binom{n+i}{i}^2$。

证明可以通过 $\text{Zeilberger}$ 算法，有兴趣的可以看[这里](https://www.luogu.com.cn/paste/0jgy8czj)。

有这个式子也能推出一个有意思的事情：

$$\displaystyle \sum_{n\geq 0}\binom{n+k}{k}^2x^n=\dfrac{1}{(1-x)^{2k+1}}\sum_{r}\binom{k}{r}^2x^r$$

回到本题，$\displaystyle f(n,m)=\sum_{i=0}^{m}\binom{n+i}{i}\dfrac{n!^2}{(n-i)!(n+i)!}=\sum_{i=0}^{m}\binom{n}{i}$。

那剩下的就是[这题](https://loj.ac/p/6386)了。

以下思路可参见[该提示](https://loj.ac/d/501)，大体沿用[快速阶乘算法](https://www.cnblogs.com/zzqsblog/p/8408691.html)以及[调和级数求和](https://www.luogu.com.cn/problem/P5702)。

$\displaystyle \sum_{k=0}^m\binom{n}{k}=\dfrac{1}{m!}\sum_{k=0}^{m}\left(\prod_{j=i+1}^mj\right)\left(\prod_{j=0}^{i-1}n\!-\!j\right)$。

设 $\displaystyle S_{d}(x)=\sum_{i=0}^{d-1}\left(\prod_{j=i+1}^{d}j+x\right)\left(\prod_{j=0}^{i-1}n\!\!-\!j\!-\!x\right)$

再设 $\displaystyle P_d(x)=\prod_{i=1}^di\!+\!x,Q_d(x)=\prod_{j=0}^{d-1}n\!-\!j\!-\!x$

令 $v$ 为满足 $v^2\!+\!v\!\leq\!m$ 的最大数，则希望求出 $S_{v}(0),S_v(1)\cdots S_{v}(v^2)$，$P,Q$ 同理。

那对于求答案时，$d\!=\!v$，有

$$m!\!\sum_{k=x}^{x+d-1}\binom{n}{k}=\sum_{i=x}^{d+x-1}\left(\prod_{j=i+1}^{m}j\right)\left(\prod_{j=0}^{i-1}n\!-\!j\right)$$

$$=\sum_{i=0}^{d-1}\left(\prod_{j=i+x+1}^{m}j\right)\left(\prod_{j=0}^{i+x-1}n\!-\!j\right)$$

$$=\sum_{i=0}^{d-1}\left(\prod_{j=i+1}^{d}j\!+\!x\prod_{j=d+1}^{m-x}j\!+\!x\right)\left(\prod_{j=0}^{x-1}n\!-\!j\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)$$

$$=S_{d}(x)\left(\prod_{j=d+x+1}^{m}j\right)\left(\prod_{j=0}^{x-1}n-j\right)$$

而在有 $P_{d}(x),Q_d(x)$ 的情况下，$m!$ 容易得到。

而后两个括号几乎就是 $P_{d}(x)$ 的后缀积与 $Q_{d}(x)$ 的前缀积。

现在主要问题是如何求 $S,P,Q$，下面具体说明。

最开始时 $S_{1}(x)\!=\!x\!+\!1,P_1(x)\!=\!x\!+\!1,Q_1(x)\!=\!n\!-\!x$

设当前已求出 $S_d(0),S_d(v)\cdots S_d(dv)$。

## $\text{Step 1: }S_d(x)\rightarrow S_{2d}(x)$

$$S_{2d}(x)=\sum_{i=0}^{2d-1}\left(\prod_{j=i+1}^{2d}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)$$

$$=\sum_{i=0}^{d-1}\left(\prod_{j=i+ 1}^{2d}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)\!+\!\sum_{i=d}^{2d-1}\left(\prod_{j=i+1}^{2d}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)$$

$$=\left(\prod_{j=d+1}^{2d}j\!+\!x\right)\sum_{i=0}^{d-1}\left(\prod_{j=i+1}^{d}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)\!+\!\left(\prod_{j=0}^{d-1}j\!+\!x\right)\sum_{i=d}^{2d-1}\left(\prod_{j=i+1}^{2d}j\!+\!x\right)\left(\prod_{j=d}^{i-1}n\!-\!j\!-\!x\right)$$

$$=P_d(x\!+\!d)S_d(x)\!+\!Q_d(x)S_d(x\!+\!d)$$

而 $P_{2d}(x)=P_d(x)P_d(x\!+\!d),Q_{2d}(x)=Q_d(x)Q_d(x\!+\!d)$

然后通过点值平移，就可以得到 $S_{2d}(0),S_{2d}(v)\cdots S_{2d}(2dv)$，$P_{2d}$ 与 $Q_{2d}$ 也能同时维护。

这部分时间复杂度为 $O(d\log d)$。

## $\text{Step 2: }S_{d}(x)\rightarrow S_{d+1}(x)$

$$S_{d+1}(x)=\sum_{i=0}^{d}\left(\prod_{j=i+1}^{d+1}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)$$

$$=(d\!+\!x\!+\!1)\sum_{i=0}^{d-1}\left(\prod_{j=i+1}^{d}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)\!+\!(d\!+\!x\!+\!1)\prod_{j=0}^{d-1}n\!-\!j\!-\!x$$

$$=(d\!+\!x\!+\!1)\left(S_{d}(x)\!+\!Q_d(x)\right)$$

而 $P_{d+1}(x)=(d\!+\!1\!+\!x)P_d(x),Q_{d+1}(x)=(n\!-\!d\!-\!x)Q_{d}(x)$

这可以得出 $S_{d+1}(0),S_{d+1}(v)\cdots S_{d+1}(dv)$，$P_{d+1},Q_{d+1}$ 同理。

而对于 $\displaystyle x=(d\!+\!1)v,P_d(x)=\prod_{i=1}^{d+1}i\!+\!x,Q_d(x)=\prod_{j=0}^{d}n\!-\!j\!-\!x$。

$\displaystyle S_{d+1}(x)=\sum_{i=0}^{d}\left(\prod_{j=i+1}^{d+1}j\!+\!x\right)\left(\prod_{j=0}^{i-1}n\!-\!j\!-\!x\right)$

皆可以 $O(d)$ 求出，这部分时间复杂度也为 $O(d)$。

总时间复杂度为 $O(\sqrt m\log m)$。

### $\texttt{Code:}$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=2e6+10;
const int mod=998244353,g=3;
char ch;int T,ans,N;
int n,k,m,nn,n_,x,y,res,wn,v;
int n1,len;int invn,w;
int a[_],b[_],nt[_],suf[_];
int rev[_],inv[_],fac[_],ifac[_];
inline void read(int &x){
	x=0;ch=getchar();while(ch<47)ch=getchar();
	while(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x>9)write(x/10);putchar(48|x%10);}
inline void swap(int &x,int &y){x^=y^=x^=y;}
void qpow(int x,int k){
	res=1;
	while(k){
		if(k&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;k>>=1;
	}
}
void getinv(int n){
	register int i;
	for(inv[1]=1,i=2;i^n;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
}
void getinv(int n,int *f,int *g){
	static int i;
	for(suf[n]=1,i=n-1;~i;--i)suf[i]=1ll*suf[i+1]*f[i]%mod;
	qpow(suf[0],mod-2);g[0]=res;
	for(i=0;i^n;++i)g[i+1]=1ll*g[i]*f[i]%mod;
	for(i=0;i^n;++i)g[i]=1ll*g[i]*suf[i+1]%mod;
}
void getfac(int n){
	register int i;
	for(ifac[0]=1,i=1;i^n;++i)ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	for(fac[0]=1,i=1;i^n;++i)fac[i]=1ll*fac[i-1]*i%mod;
}
void getrev(int n){
	static int i;
	n1=1;len=-1;while(n1<(n<<1))n1<<=1,++len;
	for(i=0;i^n1;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<len);
}
void ntt_init(int n){
	register int i,mid,j;n<<=1;
	for(mid=1;mid<n;mid<<=1){
		qpow(g,(mod-1)/(mid<<1));
		wn=res;nt[mid]=1;j=(mid<<1);
		for(i=mid+1;i<j;++i)nt[i]=1ll*nt[i-1]*wn%mod;
	}
}
inline void reverse(int *a,int n){
	static int i,nn;nn=n>>1;
	for(i=0;i^nn;++i)swap(a[i],a[n-i-1]);
}
inline int add(int x,int y){return x+y>mod?x+y-mod:x+y;}
inline int sub(int x,int y){return x>y?x-y:x-y+mod;}
void ntt(int n,int *a,bool t){
	static int i,mid,j,k;
	for(i=0;i^n;++i)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(mid=1;mid<n;mid<<=1){
		for(j=0;j<n;j+=(mid<<1)){
			for(k=0;k<mid;++k){
				x=a[j+k],y=1ll*nt[mid+k]*a[j+k+mid]%mod;
				a[j+k]=add(x,y);
				a[j+k+mid]=sub(x,y);
			}
		}
	}
	if(t){
		reverse(a+1,n-1);
		for(invn=inv[n],i=0;i^n;++i)a[i]=1ll*a[i]*invn%mod;
	}
}
int wrk[_],wrk_[_],trn[_];
void pre_trans(int n,int m){
	static int i;
	for(i=0;i^nn;++i)wrk[i]=i+m-n;
	getinv(nn,wrk,wrk_);
	for(i=0;i^nn;++i)wrk[i]=wrk_[i];
	for(i=nn+1;i^n1;++i)wrk[i]=0;ntt(n1,wrk,0);
	for(w=1,i=0;i<=n;++i)w=1ll*w*(m-i)%mod;trn[0]=w;
	for(i=1;i<=n;++i)trn[i]=1ll*trn[i-1]*(m+i)%mod*wrk_[i-1]%mod;
}
void trans_from(int n,int *f){
	static int i;
	for(i=0;i<=n;++i)f[i]=1ll*f[i]*ifac[i]%mod;
	for(i=0;i<=n;++i)f[i]=1ll*f[i]*(n-i&1?mod-ifac[n-i]:ifac[n-i])%mod;
	for(i=n+1;i^n1;++i)f[i]=0;ntt(n1,f,0);
}
void trans_to(int n,int *f,int *g){
	static int i;
	for(i=0;i^n1;++i)g[i]=1ll*f[i]*wrk[i]%mod;
	ntt(n1,g,1);for(i=0;i<=n;++i)g[i]=g[n+i];
	for(i=0;i<=n;++i)g[i]=1ll*g[i]*trn[i]%mod;
}
void trans_to(int n,int *f){
	static int i;
	for(i=0;i^n1;++i)f[i]=1ll*f[i]*wrk[i]%mod;
	ntt(n1,f,1);for(i=0;i<=n;++i)f[i]=f[n+i];
	for(i=0;i<=n;++i)f[i]=1ll*f[i]*trn[i]%mod;
}
int p[_],pp[_],q[_],qq[_],s[_],ss[_];
int tp[_],tpp[_],tq[_],tqq[_],ts[_],tss[_];
void iterate(int n){
	static int i,m;
	nn=(n<<1)+1,getrev(nn);
	m=1ll*n*inv[v]%mod;pre_trans(n,m);
	for(i=0;i<=n;++i)ss[i]=ts[i]=s[i];
	for(i=0;i<=n;++i)pp[i]=tp[i]=p[i];
	for(i=0;i<=n;++i)qq[i]=tq[i]=q[i];
	trans_from(n,s),trans_to(n,s,tss);
	trans_from(n,p),trans_to(n,p,tpp);
	trans_from(n,q),trans_to(n,q,tqq);
	for(i=0;i<=n;++i)ss[i]=tss[i];
	for(i=0;i<=n;++i)pp[i]=tpp[i];
	for(i=0;i<=n;++i)qq[i]=tqq[i];
	m=n+1;pre_trans(n,m);
	trans_to(n,s);trans_from(n,ss);trans_to(n,ss);
	trans_to(n,p);trans_from(n,pp);trans_to(n,pp);
	trans_to(n,q);trans_from(n,qq);trans_to(n,qq);
	for(i=0;i^n;++i)s[n+i+1]=s[i],ss[n+i+1]=ss[i];
	for(i=0;i^n;++i)p[n+i+1]=p[i],pp[n+i+1]=pp[i];
	for(i=0;i^n;++i)q[n+i+1]=q[i],qq[n+i+1]=qq[i];
	for(i=0;i<=n;++i)s[i]=ts[i],ss[i]=tss[i];
	for(i=0;i<=n;++i)p[i]=tp[i],pp[i]=tpp[i];
	for(i=0;i<=n;++i)q[i]=tq[i],qq[i]=tqq[i];
	n<<=1;
	for(i=0;i<=n;++i)s[i]=add(1ll*s[i]*pp[i]%mod,1ll*q[i]*ss[i]%mod);
	for(i=0;i<=n;++i)p[i]=1ll*p[i]*pp[i]%mod;
	for(i=0;i<=n;++i)q[i]=1ll*q[i]*qq[i]%mod;
}
void shift(int n){
	static int i;
	for(i=0;i^n;++i)s[i]=1ll*add(s[i],q[i])*(n+i*v)%mod;
	for(i=0;i^n;++i)p[i]=1ll*p[i]*(n+i*v)%mod;
	nn=N-n+1;for(i=0;i^n;++i)q[i]=1ll*q[i]*(nn-i*v)%mod;
	for(nn=n*v,w=1,i=n;i;--i)w=1ll*w*(nn+i)%mod,ss[i]=w;p[n]=w;
	for(nn=N-nn,w=1,i=1;i<=n;++i)ts[i]=w,w=1ll*w*(nn-i+1)%mod;q[n]=w;
	for(w=0,i=1;i<=n;++i)w=add(w,1ll*ss[i]*ts[i]%mod);s[n]=w;
}
void solve(int n){
	if(n==1){
		s[0]=1,s[1]=v+1;
		p[0]=1,p[1]=v+1;
		q[0]=N,q[1]=N-v;
	}
	else {
		solve(n>>1);iterate(n>>1);
		if(n&1)shift(n);
	}
}
inline int min(int a,int b){return a<b?a:b;}
inline int max(int a,int b){return a>b?a:b;}
int inqn[110],inqm[110];bool inqb;
main(){
	read(T);
	register int i,facm,mn;
	for(i=0;i^T;++i)read(inqn[i]),read(inqm[i]),nn=max(nn,inqm[i]);
	v=1;while(v*v+v<=nn)++v;--v;
	getinv(v<<4);ntt_init(v<<2);getfac(v<<1);
	for(int zt=0;zt^T;++zt){
		N=inqn[zt],m=inqm[zt];inqb=0;
		if(m>=N){qpow(2,N);write(res);putchar('\n');continue;}
		if(N==1){write(m+1);putchar('\n');continue;}
		if(N-m-1<m)inqb=1,m=N-m-1;
		if(m==0)ans=1;
		else if(m==1)ans=N+1;
		else if(m==2)ans=add(N+1,1ll*N*(N-1)%mod*inv[2]%mod);
		else {
			v=1;while(v*v+v<m)++v;--v;
			solve(v);nn=v*v+v;
			for(w=1,i=nn+1;i<=m;++i)w=1ll*w*i%mod;p[v+1]=w;
			for(mn=1,i=nn;i^m;++i)mn=1ll*mn*(N-i)%mod;
			for(i=v;~i;--i)p[i]=1ll*p[i]*p[i+1]%mod;
			facm=p[0];for(i=0;i<=v;++i)p[i]=p[i+1];
			for(i=1;i<=v;++i)q[i]=1ll*q[i-1]*q[i]%mod;
			mn=1ll*mn*q[v]%mod;for(i=v+1;i;--i)q[i]=q[i-1];q[0]=1;
			for(i=0;i<=v;++i)ans=add(ans,1ll*p[i]%mod*q[i]%mod*s[i]%mod);
			ans=add(ans,mn);nn=m-nn;
			for(i=0;i^nn;++i)ss[i]=N-(m-i-1);getinv(nn,ss,ts);
			for(i=0;i^nn;++i)mn=1ll*mn*ts[i]%mod*(m-i)%mod,ans=add(ans,mn);
			qpow(facm,mod-2);ans=1ll*ans*res%mod;
		}
		if(inqb)qpow(2,N),ans=sub(res,ans);
		write(ans);putchar('\n');ans=0;
	}
}
```

---


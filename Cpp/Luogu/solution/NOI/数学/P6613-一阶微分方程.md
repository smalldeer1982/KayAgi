# 一阶微分方程

## 题目背景

题目中 $F'(x)$ 右侧的式子可以换成其它的，这里为了方便测试，是固定的。 

## 题目描述

已知多项式 $F(x),A(x),B(x)$，满足：

$$\frac{\text dF(x)}{\text dx} \equiv A(x)\text e^{F(x)-1}+B(x) \pmod{x^n}$$
且 $F(0)=1$。

给定 $A(x),B(x)$，请求出 $F(x)$ 的前 $n$ 次项系数。

答案对 $998244353$ 取模。

## 说明/提示

### 数据规模与约定
对于 $30\%$ 的数据，$1\le n \le 5000$；  
对于 $100\%$ 的数据，$1\le n \le 10^5$。

保证所有输入都在 $[0,998244353)$ 范围内。


## 样例 #1

### 输入

```
9
2 9 8 7 3 6 5 4 1 12
23 9 8 7 4 6 1 3 2 5 ```

### 输出

```
1 25 34 332748429 124783260 22560 624092696 904826719 284383572 50973515```

# 题解

## 作者：NaCly_Fish (赞：22)

其实这个科技在 2017 年就被神仙们所熟知了，这里应 [兔兔](https://www.luogu.com.cn/user/10703) 的要求，造了道模板题，来洛谷普及一下，，求轻喷。
****
任意一阶微分方程都能写成这种形式：
$$F'(x)\equiv G(F(x)) \pmod{x^n}$$
在洛谷模板题中，$G(F(x))=A(x)\text e^{F(x)-1}+B(x)$，$G'(F(x))=A(x)\text e^{F(x)-1}$。

假设已经求得 $F_0(x)$，在前 $\lceil n/2 \rceil$ 项满足上式；类比普通牛顿迭代的做法，在 $F_0(x)$ 处做 Taylor 展开后取前两项，有：

$$F'(x) \equiv G(F_0(x))+G'(F_0(x))(F(x)-F_0(x)) \pmod{x^n}$$ 
（后面的项在模 $x^n$ 下为零，当然可以忽略）  

我们希望把带 $F(x)$ 的项全都移到一边来
$$F'(x)-G'(F_0(x))F(x) \equiv G(F_0(x))-G'(F_0(x))F_0(x) \pmod{x^n}$$
如果能构造一个 $P(x)$，使得两边同乘 $P(x)$ 后，左边变成 $(F(x)P(x))'$ 的话：

$$F(x) \equiv  \frac{1}{P(x)} \left( \int P(x)(G(F_0(x))-G'(F_0(x))F_0(x))  \text dx +1\right)\pmod{x^n}$$
右边那个 $+1$ 是因为，这样积分漏了一项，补回去就好了。  
注意右边的 $F_0(x)$ 都是我们提前算好的，所以就能直接迭代......了？

啊，好像忘了说 $P(x)$ 应该怎么构造，其实就是：
$$(F(x)P(x))'=F'(x)P(x)+P'(x)F(x)$$
对比一下 $P(x)F'(x)-P(x)G'(F_0(x))F(x)$ 的式子，不难发现我们要求的就是

$$P'(x)=-P(x)G'(F_0(x))$$
$$(\ln P(x))'=-G'(F_0(x))$$
$$P(x) = \exp \left( \int -G'(F_0(x)) \text dx \right)$$
直接做就好了。~~常数奇大无比，完全打不过分治 fft~~  

代码为了好写，没怎么卡常，仅供参考。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 262147
#define ll long long
#define reg register
#define p 998244353
using namespace std;

inline int add(const int& x,const int& y){ return x+y>=p?x+y-p:x+y; }
inline int dec(const int& x,const int& y){ return x<y?x-y+p:x-y; }

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int siz;
int rev[N],rt[N],inv[N];

void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=0;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    int w = power(3,(p-1)>>siz);
    inv[1] = rt[lim>>1] = 1;
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
}

inline void dft(int *f,int n){
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(n);
    for(reg int i=0;i!=n;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=n;mid<<=1)
    for(reg int j=0;j!=n;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=n;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int n){
    reverse(f+1,f+n);
    dft(f,n);
    int x = p-((p-1)>>__builtin_ctz(n));
    for(reg int i=0;i!=n;++i) f[i] = (ll)f[i]*x%p;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

inline void inverse(const int *f,int n,int *r){
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        dft(g,lim),dft(h,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        idft(g,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(r,g,(n+1)<<2);
}

inline void log(const int *f,int n,int *r){
    static int g[N],h[N];
    inverse(f,n,g);
    for(reg int i=0;i!=n;++i) h[i] = (ll)f[i+1]*(i+1)%p;
    h[n] = 0;
    int lim = getlen(n<<1);
    memset(g+n+1,0,(lim-n)<<2);
    memset(h+n+1,0,(lim-n)<<2);
    dft(g,lim),dft(h,lim);
    for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
    idft(g,lim);
    for(reg int i=1;i<=n;++i) r[i] = (ll)g[i-1]*inv[i]%p;
    r[0] = 0;
}

inline void exp(const int *f,int n,int *r){
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,g,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        log(g,n,g);
        for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
        g[0] = add(g[0],1);
        dft(g,lim),dft(h,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
        idft(g,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(r,g,(n+1)<<2);
}

inline void multiply(const int *f,const int *g,int n,int m,int *r,int len){
    static int a[N],b[N];
    int lim = getlen(n+m);
    memcpy(a,f,(n+1)<<2),memcpy(b,g,(m+1)<<2);
    memset(a+n+1,0,(lim-n)<<2),memset(b+m+1,0,(lim-m)<<2);
    dft(a,lim),dft(b,lim);
    for(reg int i=0;i!=lim;++i) a[i] = (ll)a[i]*b[i]%p;
    idft(a,lim);
    memcpy(r,a,(len+1)<<2);
}

inline void solve(const int *a,const int *b,int n,int *r){
    static int f[N],ef[N],gf[N],dgf[N],h[N],q[N],st[30]; // P(x) in this code is h(x)
    int top = 0,lim = getlen(n<<1)<<1;
    memset(f,0,lim<<2);
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    f[0] = 1;
    while(top--){
        n = st[top+1];
        memcpy(ef+1,f+1,n<<2);
        ef[0] = 0;
        exp(ef,n,ef);
        multiply(ef,a,n,n,dgf,n);
        for(reg int i=0;i<=n;++i) gf[i] = add(dgf[i],b[i]);
        for(reg int i=0;i<=n;++i) h[i] = dgf[i]==0?0:p-dgf[i];
        for(reg int i=n;i;--i) h[i] = (ll)h[i-1]*inv[i]%p;
        h[0] = 0;
        exp(h,n,h);
        multiply(dgf,f,n,n,q,n);
        for(reg int i=0;i<=n;++i) q[i] = dec(gf[i],q[i]);
        multiply(q,h,n,n,q,n);
        for(reg int i=n;i;--i) q[i] = (ll)q[i-1]*inv[i]%p;
        q[0] = 1;
        inverse(h,n,h);
        multiply(q,h,n,n,q,n);
        memcpy(f+1,q+1,n<<2);
    }
    memcpy(r,f,(n+1)<<2);
}

int a[N],b[N],f[N];
int n;

int main(){
    read(n);
    init(n<<1);
    for(reg int i=0;i<=n;++i) read(a[i]);
    for(reg int i=0;i<=n;++i) read(b[i]);
    solve(a,b,n,f);
    for(reg int i=0;i<=n;++i) print(f[i]),putchar(' ');
    return 0;   
}
```

---

## 作者：warzone (赞：15)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/wangrx/p6613-ti-xie)  
题解区的很多大佬都是强解微分方程的，但常数变易法蒟蒻对此有许多不解。  
因此蒟蒻在此给出本题常数变易法的证明。 

------------------------------
## 一阶线性微分方程的常数变易法

这里有基础的大佬可以直接跳过。

让我们先考虑 一阶齐次线性微分方程：
$$y'=P(x)y$$

显然，我们已经知道了 $(\ln y)'=\dfrac{y'}{y}$，因此该方程化为
$$(\ln y)'=P(x)$$
$$\ln y=\int P(x)\mathrm{d}x+\ln C$$
$$y=Ce^{\int P(x)\mathrm{d}x}$$
其中 $C$ 为常数，由实际情况决定。

这个过程被称为分离变量法，相当地简单。

但对于一般的 一阶线性微分方程，多了一个与 $y$ 无关的 $Q(x)$，难度就直线飙升：
$$y'=P(x)y+Q(x)$$
为求出该方程的通解，拉格朗日花了整整 11 年的时间（在此佩服大佬的毅力），  
最后发现，如果把 $y$ 拆开，变为 $y=uv$，方程就可解了：
$$u'v+uv'=P(x)uv+Q(x)$$
$$u'v+u(v'-P(x)v)=Q(x)$$
只要使 $v$ 满足特定的条件，代入解出对应的 $u$，就可以求出 $y$ 了（反之亦然）。  
可以看到，如果使 $v'-P(x)v=0$，方程就变为 $u'=\dfrac{Q(x)}{v}$，可以直接积分求出 $u$。  
至于 $v'-P(x)v=0$，这不就是之前已经解决了的 一阶齐次线性微分方程 吗？  
由此得到了 一阶线性微分方程 的通解：
$$v=C_ve^{\int P(x)\mathrm{d}x}$$
$$u=C_v^{-1}(\int Q(x)e^{-\int P(x)\mathrm{d}x}\mathrm{d}x+C_u)$$
$$y=uv=e^{\int P(x)\mathrm{d}x}(\int Q(x)e^{-\int P(x)\mathrm{d}x}\mathrm{d}x+C_u)$$

拉格朗日发现，这个通解满足 $y=C(x)e^{\int P(x)\mathrm{d}x}$ 的形式。  
其实不难理解，$e^{\int P(x)\mathrm{d}x}$ 来自原本的 $v$，求解 $u$ 的过程就是求解 $C(x)$。  
因此之后求解的时候就略去拆开 $y$ 的过程，直接先解对应的齐次方程，  
然后将常数变为函数代入回去，这就是一阶线性微分方程的常数变易法。

-----------------------------
## 本题微分方程的常数变易法
接下来，让我们考虑本题的微分方程，它满足以下形式：
$$y'=P(x)f'^{-1}(y)+Q(x)$$
之前的经验告诉我们考虑对应的齐次方程：
$$y'=P(x)f'^{-1}(y)$$
$$f'(y)y'=P(x)$$
$$f(y)=\int P(x)\mathrm{d}x+C$$
$$y=\operatorname{arc}f(\int P(x)\mathrm{d}x+C)$$
其中 $\operatorname{arc}f$ 为 $f$ 对应的反函数，即
$$f:A\rightarrow B,\operatorname{arc}f:B\rightarrow A$$
$$\forall x\in A,\operatorname{arc}f(f(x))=x$$
$$\forall x\in B,f(\operatorname{arc}f(x))=x$$

推广到非齐次，我们猜想，本题微分方程通解的形式为：
$$y=\operatorname{arc}f(\int P(x)\mathrm{d}x+C(x))$$
接下来证明为什么这么做是正确的。  
同样将 $y$ 拆开，考虑到之前 $u,v$ 与通解两项的对应，可认为
$$y=\operatorname{arc}f(v+u)$$
当 $\operatorname{arc}f(x)=e^x$ 时，$f'^{-1}(x)=x$，  
$y=e^{v+u}=e^ue^v$，刚好对应上了一开始的拆法 $y=uv$。

$\operatorname{arc}f$ 值域 $=f$ 定义域 $\supseteq f'^{-1}$ 定义域，  
因此仍然可以使 $f,v$ 满足特定的条件，代入解出对应的 $u$ 来求解 $y$。

代入 $y=\operatorname{arc}f(v+u)$，得
$$\operatorname{arc}f'(v+u)(v'+u')=P(x)f'^{-1}(\operatorname{arc}f(v+u))+Q(x)$$
对 $f(\operatorname{arc}f(x))=x$ 求导，得
$$f'(\operatorname{arc}f(x))\operatorname{arc}f'(x)=1$$
$$\operatorname{arc}f'(x)=f'^{-1}(\operatorname{arc}f(x))$$
因此原方程可化为 
$$\operatorname{arc}f'(v+u)(v'+u')=P(x)\operatorname{arc}f'(v+u)+Q(x)$$
$$\operatorname{arc}f'(v+u)(v'+u'-P(x))=Q(x)$$
若 $v'-P(x)=0$，解得 $v=\displaystyle\int P(x)\mathrm{d}x+C_v$ 。  
因此之前通解的形式（常数变易法）是正确的。

------------------------------
## 本题微分方程的求解
回到本题的微分方程

$$y'=P(x)e^{y-1}+Q(x)$$
此时 $f'^{-1}(x)=e^{x-1}$，设 $f(x)=-e^{1-x}$，则 $\operatorname{arc}f(x)=1-\ln(-x)$。  
代入通解 $y=\operatorname{arc}f(\displaystyle\int P(x)\mathrm{d}x+C(x))$ 得

$$\operatorname{arc}f'(\int P(x)\mathrm{d}x+C(x))C'(x)=Q(x)$$
$$\frac{C'(x)}{\displaystyle-(\int P(x)\mathrm{d}x+C(x))}=Q(x)$$
$$C'(x)=-Q(x)C(x)-Q(x)\int P(x)\mathrm{d}x$$

由此转化为一阶线性微分方程，解得

$$C(x)=e^{-\int Q(x)\mathrm{d}x}(\int(-Q(x)\int P(x)\mathrm{d}x)e^{\int Q(x)\mathrm{d}x}\mathrm{d}x+C_u)$$
$$y=\operatorname{arc}f(\int P(x)\mathrm{d}x+C(x))$$
$$=1-\ln(-\int P(x)\mathrm{d}x-C(x))$$

-------------------------------
设 $A(x)=\displaystyle\int P(x)\mathrm{d}x,B(x)=\displaystyle e^{\int Q(x)\mathrm{d}x}$，则
$$C(x)=B^{-1}(x)(\int -Q(x)A(x)B(x)\mathrm{d}x+C_u)$$
$$y=1-\ln(-A(x)-C(x))$$
$$=1-\ln(-A(x)+B^{-1}(x)(\int Q(x)A(x)B(x)\mathrm{d}x-C_u))$$
$$=1+\ln B(x)-\ln(-A(x)B(x)+\int Q(x)A(x)B(x)\mathrm{d}x-C_u)$$
由 $y(0)=1$ 得
$$\ln B(0)-\ln(-A(0)B(0)+\displaystyle\int^0 Q(x)A(x)B(x)\mathrm{d}x-C_u)=0$$
$$B(0)=-A(0)B(0)-C_u$$
$$-C_u=A(0)B(0)+B(0)=B(0)=1$$


$$y=1+\int Q(x)\mathrm{d}x-\ln(-A(x)B(x)+\int Q(x)A(x)B(x)\mathrm{d}x+1)$$

已知 $B'(x)=Q(x)B(x),(A(x)B(x))'=A'(x)B(x)+A(x)B'(x)$  

于是得 $Q(x)A(x)B(x)=A(x)B'(x)=(A(x)B(x))'-A'(x)B(x)$  
$$-A(x)B(x)+\int Q(x)A(x)B(x)\mathrm{d}x$$
$$=-\int A'(x)B(x)\mathrm{d}x=-\int P(x)e^{\int Q(x)\mathrm{d}x}\mathrm{d}x$$

$$y=1+\int Q(x)\mathrm{d}x-\ln(1-\int P(x)e^{\int Q(x)\mathrm{d}x}\mathrm{d}x)$$
由此得解，时间复杂度 $\Theta(n\log n)$。

## Code
```cpp
/*
this code is made by warzone
2021.5.22 20:00
*/
#include<stdio.h>
#include<string.h>
typedef unsigned char byte;
typedef unsigned long long ull;
typedef long long ll;
typedef unsigned int word;
struct READ{//快读
	char c;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator>>(register type& num){
		while('0'>c||c>'9') c=getchar();
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		return *this;
	}
}cin;
class WRITE{//快写
	private:
		char out[1<<20],*top;
	public:
		inline WRITE(){top=out;}
		inline ~WRITE(){if(top!=out) fwrite(out,1,top-out,stdout);}
		inline WRITE& operator <<(char c){
			*(top++)=c;
			if(top==out+(1<<20))
				fwrite(top=out,1,1<<20,stdout);
			return *this;
		}
		inline void outnum(word num){
			if(num) outnum(num/10),*this<<(char)(num%10+'0');
		}
		template<typename type>
		inline WRITE& operator <<(type num){
		    if(num) return outnum(num),*this;
			return *this<<'0';
		}
}cout;
#define mx 18
#define mx_ 17
word root[1<<mx],inv[1<<mx],realid[1<<mx];
ull size,ni2;
const word mod=998244353;
inline ull pow(register ull a,register word b){
	register ull ans=1;
	for(;b;b>>=1){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
	}
	return ans;
}
//预处理单位根，翻转的 id
#define loading()			\
	register ull num1=pow(3,(mod-1)>>mx);	\
	register ull num2=pow(num1,mod-2);	\
	register word head,i,floor;	\
	root[1<<mx_]=inv[1<<mx_]=1;	\
	ni2=pow(2,mod-2);		\
	for(i=1;head=i,i<(1<<mx);++i)	\
		for(floor=0;floor<mx;++floor,head>>=1)	\
			realid[i]=realid[i]<<1|(head&1);	\
	for(i=1;i<(1<<mx_);++i){	\
		root[1<<mx_|i]=num1*root[1<<mx_|(i-1)]%mod;	\
		inv[1<<mx_|i]=num2*inv[1<<mx_|(i-1)]%mod;	\
	}	\
	for(i=(1<<mx_)-1;i;--i)	\
		root[i]=root[i<<1],inv[i]=inv[i<<1];
#define load()	\
	register ull num1,num2;\
	register word head,i,floor;
#define nttfor(size)	\
	for(floor=1;floor<1u<<(size);floor<<=1)	\
		for(head=0;head<1u<<(size);head+=floor<<1)	\
			for(i=0;i<floor;++i)
//floor 变换区间大小
//head 变换区间头指针 
//i 变换位置 
#define ntt(num,root)(	\
	num1=(num)[head|i],	\
	num2=(num)[head|i|floor],	\
	(num)[head|i]=(num1+((num2*=root[i|floor])%=mod))%mod,	\
	(num)[head|i|floor]=(num1+mod-num2)%mod)
#define id(size,i) (realid[i]>>(mx-(size)))
#define modx(num,size) memset(num+(1<<(size)),0,4<<(size))
#define set0(num,size) memset(num,0,4<<(size))
#define FOR(size) for(i=0;i<1u<<(size);i++)
#define newton(size)	\
	ull ni=ni2,size_=1;	\
	while(size_++,ni=ni*ni2%mod,size_-2<(size))
word in[1<<mx],eax[1<<mx],ebx[1<<mx],ecx[1<<mx],edx[1<<mx];
word out[1<<mx];
inline void _1(word size){//求 eax 的逆元，放入 ebx
	ebx[0]=pow(eax[0],mod-2);
    load()
	newton(size){
		FOR(size_-1){
            head=id(size_,i);
			ecx[head]=eax[i]? mod-eax[i]:0;
			edx[head]=ebx[i];
            head=id(size_,i+(1<<(size_-1)));
            ecx[head]=edx[head]=0;
		}
		nttfor(size_) ntt(ecx,root),ntt(edx,root);
		FOR(size_) ebx[id(size_,i)]=(ull)(ecx[i])*edx[i]%mod;
		nttfor(size_) ntt(ebx,inv);
		modx(ebx,size_-1);
		FOR(size_) ecx[id(size_,i)]=ni*ebx[i]%mod;
		ecx[0]=(ecx[0]+2)%mod;
		nttfor(size_) ntt(ecx,root);
		FOR(size_) ebx[id(size_,i)]=(ull)(ecx[i])*edx[i]%mod;
		nttfor(size_) ntt(ebx,inv);
		modx(ebx,size_-1);
		FOR(size_-1) ebx[i]=ni*ebx[i]%mod;
	}
}
inline void ln(word size){//求 eax 的 ln，放入 ebx
	_1(size);
    load()
	FOR(size){
        head=id(size+1,i);
		ecx[head]=ebx[i];
		edx[head]=(ll)(eax[i+1])*(i+1)%mod;
        head=id(size+1,i+(1<<size));
        ecx[head]=edx[head]=0;
	}
	nttfor(size+1) ntt(ecx,root),ntt(edx,root);
	FOR(size+1) ebx[id(size+1,i)]=(ull)(ecx[i])*edx[i]%mod;
	nttfor(size+1) ntt(ebx,inv);
	modx(ebx,size);
	for(register word i=(1u<<size)-1,ni=pow(1u<<(size+1),mod-2);i>0;i--)
		ebx[i]=pow(i,mod-2)*ebx[i-1]%mod*ni%mod;
	ebx[0]=0;
}
inline void exp(word size){// 求 in 的逆元，放入 eax
	eax[0]=1;
    load();
	newton(size){
		ln(size_-1);
		FOR(size_-1){
            head=id(size_,i);
			ecx[head]=eax[i];
			edx[head]=(mod-ebx[i]+in[i])%mod;
            head=id(size_,i+(1<<(size_-1)));
            ecx[head]=edx[head]=0;
		}
		edx[0]=(1ull+edx[0])%mod;
		nttfor(size_) ntt(ecx,root),ntt(edx,root);
		FOR(size_) eax[id(size_,i)]=(ull)(ecx[i])*edx[i]%mod;
		nttfor(size_) ntt(eax,inv);
		modx(eax,size_-1);
		FOR(size_-1) eax[i]=ni*eax[i]%mod;
	}
}
int main(){
	loading();
	word n,size=0;
	cin>>n;
	for(;1u<<size<=n+1;size++);
	for(i=0;i<=n;++i)
		cin>>out[id(size+1,i)];
	for(i=1;i<=n+1;++i)
		cin>>num1,in[i]=pow(i,mod-2)*num1%mod;
	exp(size);
	FOR(size){
		ecx[id(size+1,i)]=eax[i]? mod-eax[i]:0;
		ecx[id(size+1,i+(1u<<size))]=0;
	}
	nttfor(size+1) ntt(out,root),ntt(ecx,root);
	FOR(size+1) ebx[id(size+1,i)]=(ull)(out[i])*ecx[i]%mod;
	nttfor(size+1) ntt(ebx,inv);
	eax[0]=1;
	num1=pow(1u<<(size+1),mod-2);
	for(i=1;i<1u<<(size);++i)
		eax[i]=pow(i,mod-2)*num1%mod*ebx[i-1]%mod;
	ln(size);
	++in[0];
	for(register word i=0;i<=n;i++)
		cout<<((ull)(in[i])+mod-ebx[i])%mod<<' ';
	return 0;
}
```

---

## 作者：Spasmodic (赞：13)

众所周知，这是一道数学题
$$
\begin{aligned}
\frac{\mathrm{d}F(x)}{\mathrm{d}x}&=A(x)\exp(F(x)-1)+B(x)\\
\frac{\mathrm{d}y}{\mathrm{d}x}&=A(x)\exp(y-1)+B(x)
\end{aligned}
$$
我们先分离变量，用可分离变量方程的方法解
$$
\begin{aligned}
\frac{\mathrm{d}y}{\mathrm{d}x}&=A(x)\exp(y-1)\\
\frac{\mathrm{d}y}{\exp(y-1)}&=A(x)\mathrm{d}x\\
\int\frac{\mathrm{d}y}{\exp(y-1)}&=\int A(x)\mathrm{d}x\\
-\exp(1-y)&=A_1(x)-C\\
\exp(1-y)&=C-A_1(x)\\
1-y&=\ln(C-A_1(x))\\
y&=1-\ln(C-A_1(x))\\
y&=1+\ln\frac{1}{C-A_1(x)}
\end{aligned}
$$
其中
$$
A_1(x)=\int A(x)\mathrm{d}x
$$
使用常数变易法，设
$$
y=1+\ln\frac{1}{C(x)-A_1(x)}
$$
代入原方程
$$
\begin{aligned}
\frac{\mathrm{d}y}{\mathrm{d}x}&=A(x)\exp(y-1)+B(x)\\
-\frac{C'(x)-A(x)}{C(x)-A_1(x)}&=\frac{A(x)}{C(x)-A_1(x)}+B(x)\\
\frac{C'(x)}{C(x)-A_1(x)}&=-B(x)\\
\frac{\mathrm{d}C(x)}{\mathrm{d}x}&=A_1(x)B(x)-B(x)C(x)\\
\frac{\mathrm{d}z}{\mathrm{d}x}&=-B(x)z+A_1(x)B(x)
\end{aligned}
$$
我们还是先分离变量，用可分离变量方程的方法解
$$
\begin{aligned}
\frac{\mathrm{d}z}{\mathrm{d}x}&=-B(x)z\\
\frac{\mathrm{d}z}{z}&=-B(x)\mathrm{d}x\\
\int\frac{\mathrm{d}z}{z}&=-\int B(x)\mathrm{d}x\\
\ln z&=-B_1(x)+C\\
z&=C\exp(-B_1(x))
\end{aligned}
$$
其中
$$
B_1(x)=\int B(x)\mathrm{d}x
$$
使用常数变易法，设
$$
z=C_1(x)\exp(-B_1(x))
$$
代入原方程
$$
\begin{aligned}
\frac{\mathrm{d}z}{\mathrm{d}x}&=-B(x)z+A_1(x)B(x)\\
C_1'(x)\exp(-B_1(x))-C_1(x)\exp(-B_1(x))B(x)&=-B(x)C_1(x)\exp(-B_1(x))+A_1(x)B(x)\\
C_1'(x)\exp(-B_1(x))&=A_1(x)B(x)\\
C_1(x)&=\int A_1(x)B(x)\exp(B_1(x))\mathrm{d}x+C
\end{aligned}
$$
所以
$$
\begin{aligned}
F(x)&=1+\ln\frac{1}{C(x)-A_1(x)}\\
&=1+\ln\frac{1}{C_1(x)\exp(-B_1(x))-A_1(x)}\\
&=1-\ln(C_1(x)\exp(-B_1(x))-A_1(x))\\
&=1+B_1(x)-\ln(C_1(x)-A_1(x)\exp(B_1(x)))\\
&=1+B_1(x)-\ln(\int A_1(x)B(x)\exp(B_1(x))\mathrm{d}x-A_1(x)\exp(B_1(x))+C)
\end{aligned}
$$
取 $C=1$ 即可，复杂度 $O(n\log n)$。

目前~~借助 EI 的板子~~跑到了最优解 rk3（打不过半在线卷积）。
```cpp
int main(){
	int n;IO>>n;
	poly A=zeroes(n),B=zeroes(n);
	IO>>A.a>>B.a;
	poly A1=A.integ().slice(n),B1=B.integ().slice(n),expB1=B1.exp();
	(1+B1-(((A1*B).slice(n-1)*expB1).slice(n-1).integ()-(A1*expB1).slice(n)+1).ln()).println();
	return 0;
}
```

---

## 作者：rogeryoungh (赞：6)

瞎搞完了才发现，题解里竟然没人和我有相同的想法。

~~提交里那些分治代码我看不懂，看着好玄学。哪位 dalao 能够教教我~~

分析一下难点，我们之所以难算，就是因为这个问题里有 $e^x$。

$$
F' = A \ast e^{F - 1} + B
$$

那么把它换掉就好啦。令 $H = \frac{1}{e^{F-1}}$，可以发现

$$
H' = -\frac{F'}{e^{F-1} } = -F' \ast H
$$

把所有 $F$ 换掉，可以得到

$$
-H' = A + B \ast H
$$

这个形式可以方便的半在线卷积。

$$
-(n+1)H_{n+1} = \sum_{i=0}^n B_i H_{n-i} + A_n
$$

至于还原 $H$，其实不用求逆，因为有

$$
F = 1 + \ln\frac{1}{H} = 1 - \ln H
$$

于是可以写出代码

```cpp
int main() {
    int n = rr() + 1;
    Poly A(n), B(n);
    for (int i = 0; i < n; i++)
        A[i] = rr();
    for (int i = 0; i < n; i++)
        B[i] = rr();
    pre_inv(n);

    // -DH = A + B * H, H = 1 / exp(F - 1)
    PolyCDQ DH(B);
    DH.G[0] = 1;
    for (int i = 1; i < n; i++) {
    	DH.next();
        DH.G[i] = -(DH.conv[i - 1] + A[i - 1]) * Inv[i];
    }
    
    Poly F = Poly{1} - DH.G.ln();
    for (int i = 0; i < n; i++)
        printf("%d ", F[i].v);
    return 0;
}
```

全部代码可以看我的[提交](https://www.luogu.com.cn/record/65441752)，[二叉](https://www.luogu.com.cn/record/65442192)写法也还算快。

若令 $H = e^{F-1}$，则有两个缠在一起的卷积式，需要一个在线的和一个半在线的。

因为 $\ln$ 也相当于是一次半在线卷积，我这种方法合计是两次半在线，快不少。




---

## 作者：Y_B_X (赞：6)

[原题链接](https://www.luogu.com.cn/problem/P6613)

题意：
求满足$\frac{d F(x)}{d x}=A(x)\times e^{F(x)-1}+B(x)$ 的$F(x)$的前$n$项系数，且$F(0)=1$

强解微分方程！

设$y=F(x),A1(x)=\int^{}{}{A(x)d x},B1(x)=\int^{}{}{B(x)d x}$

先求$\frac{d y}{d x}=A(x)\times e^{y-1}$的解：

$\int^{}{}{e^{1-y}dy}$=$\int^{}{}{A(x)d x}-C$($C为常数$)

$-e^{1-y}=A1(x)-C$

固$y=1+\ln{\frac{1}{C-A1(x)}}$


再由常数变易法设$C=u(x)$

则$\frac{d y}{d x}=(u(x)-A1(x))(\frac{-1}{(u(x)-A1(x))^2})(\frac{du(x)}{dx}-A(x))$
$=\frac{A(x)-\frac{du(x)}{dx}}{u(x)-A1(x)}$

而$A(x)e^{F(x)-1}+B(x)=\frac{A(x)}{u(x)-A1(x)}+B(x)$

所以$\frac{du(x)}{dx}=A1(x)B(x)-u(x)B(x)$

再一次，先求$\frac{du(x)}{dx}=-u(x)B(x)$的解：

$\int^{}{}{\frac{1}{u}du}=-\int^{}{}{B(x)d x}+D$($D$为常数)

$\ln(u(x))=-B1(x)+D$

固$u(x)=e^{-B1(x)}\times E$（常数$E=e^D$）

再设$E=v(x)$

则$\frac{du(x)}{dx}=-v(x)B(x)e^{-B1(x)}+\frac{dv(x)}{dx}e^{-B1(x)}$

而$A1(x)B(x)-u(x)B(x)=-v(x)B(x)e^{-B1(x)}+A1(x)B(x)$

于是得到$\frac{dv(x)}{dx}=e^{B1(x)}A1(x)B(x)$

因此$v(x)=\int^{}{}{e^{B1(x)}A1(x)B(x)dx}+G$($G$为常数)


由于$C=u(x)=e^{-B1(x)}v(x)$

所以$F(x)=y=1+\ln{\frac{1}{e^{-B1(x)}v(x)-A1(x)}}=1+B1(x)-\ln(v(x)-A1(x)e^{B1(x)})$

$=1+B1(x)-\ln(\int^{}{}{e^{B1(x)}A1(x)B(x)dx}-A1(x)e^{B1(x)}+G)$

又$F(0)=1$,取$G=1$即可
代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+10;
const int mod=998244353;
int n,g;
int a[N],b[N];
int a1[N],b1[N],eb[N];
int c1[N],c2[N],c[N],d[N],dd[N];
int tmp[N],tmp1[N];
int tt[N],t1[N];
int tln[N],tinv[N];
int rev[N];
int inv[N];
void getinv(int n){
	inv[1]=1;
	for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
}
int getrev(int n){
	int n1=1,len=0;
	while(n1<(n<<1))n1<<=1,len++;
	for(int i=0;i<n1;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(len-1));
	return n1;
}
int qpow(int x,int k){
	int cnt=1;
	while(k){
		if(k&1)cnt=(cnt*x)%mod;
		x=(x*x)%mod;
		k>>=1;
	}
	return cnt;
}
void integral(int n,int *x,int *y){
	for(int i=1;i<n;i++)y[i]=x[i-1]*inv[i]%mod;
	y[0]=0;
} 
void ntt(int n,int *a,int t){
	for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	if(t==1)g=3;
	else g=332748118;
	for(int mid=1;mid<n;mid<<=1){
		int wn=qpow(g,(mod-1)/(mid<<1));
		for(int j=0;j<n;j+=(mid<<1)){
			int w=1;
			for(int k=0;k<mid;k++){
				int x=a[j+k],y=w*a[j+k+mid]%mod;
				a[j+k]=(x+y)%mod;
				a[j+k+mid]=(x-y+mod)%mod;
				w=w*wn%mod;
			}
		}
	}
	if(t==1)return;
	int inv=qpow(n,mod-2);
	for(int i=0;i<n;i++)a[i]=a[i]*inv%mod;
}
void polyinv(int n,int *f,int *g){
	if(n==1){
		g[0]=qpow(f[0],mod-2);
		return;
	}
	polyinv((n+1)>>1,f,g);
	int n1=getrev(n);
	for(int i=0;i<n;i++)tmp[i]=f[i];
	for(int i=n;i<n1;i++)tmp[i]=0;
	ntt(n1,tmp,1);
	ntt(n1,g,1);
	for(int i=0;i<n1;i++)g[i]=(2ll-tmp[i]*g[i]%mod+mod)%mod*g[i]%mod;
	ntt(n1,g,-1);
	for(int i=n;i<n1;i++)g[i]=0;
}
void polyln(int n,int *ff,int *gg){
	int n1=getrev(n);
	for(int i=0;i<n;i++)tt[i]=(i+1)*ff[i+1]%mod;
	for(int i=n;i<n1;i++)tt[i]=0,gg[i]=0;
	polyinv(n,ff,gg);
	ntt(n1,gg,1);
	ntt(n1,tt,1);
	for(int i=0;i<n1;i++)tt[i]=tt[i]*gg[i]%mod;
	ntt(n1,tt,-1);
	integral(n,tt,gg);
	for(int i=n;i<n1;i++)gg[i]=0;
}
void polyexp(int n,int *f1,int *g1){
	if(n==1){
		g1[0]=1;
		return;
	}
	polyexp((n+1)>>1,f1,g1);
	int n1=getrev(n);
	for(int i=0;i<n;i++)tmp1[i]=f1[i],tln[i]=0;
	for(int i=n;i<n1;i++)tmp1[i]=0,tln[i]=0,g1[i]=0;
	polyln(n,g1,tln);
	tmp1[0]=1;
	for(int i=0;i<n;i++)tmp1[i]=(tmp1[i]-tln[i]+mod)%mod;
	ntt(n1,g1,1);
	ntt(n1,tmp1,1);
	for(int i=0;i<n1;i++)g1[i]=g1[i]*tmp1[i]%mod;
	ntt(n1,g1,-1);
	for(int i=n;i<n1;i++)g1[i]=0;
}
signed main(){
	scanf("%d",&n),n++;
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	for(int i=0;i<n;i++)scanf("%d",&b[i]);
	int n1=getrev(n);
	getinv(n);
	integral(n,a,a1),integral(n,b,b1);
	polyexp(n,b1,eb);
	ntt(n1,eb,1),ntt(n1,a1,1);
	for(int i=0;i<n1;i++)c2[i]=a1[i]*eb[i]%mod;
	ntt(n1,c2,-1);
	for(int i=n;i<n1;i++)c2[i]=0;
	ntt(n1,c2,1);
	ntt(n1,b,1);
	for(int i=0;i<n1;i++)c1[i]=c2[i]*b[i]%mod;
	ntt(n1,c1,-1);
	integral(n,c1,d);
	ntt(n1,c2,-1);
	for(int i=0;i<n;i++)d[i]=(d[i]-c2[i]+mod)%mod;
	d[0]=1;
	polyln(n,d,dd);
	for(int i=0;i<n;i++)c[i]=(b1[i]-dd[i]+mod)%mod;
	c[0]=(c[0]+1)%mod;
	for(int i=0;i<n;i++)printf("%d ",c[i]);
}
```

---

## 作者：disangan233 (赞：6)

式子鱼鱼都给的很清楚了，有

$$
\begin{aligned}
&F(x) \equiv \frac 1{P(x)}\left(\int P(x)(G(F_0(x))-G'(F_0(x))F_0(x))\mathrm{d}x+1\right)\pmod {x^n} \\
&P(x)=\exp\left(\int -G'(F_0(x))\mathrm{d}x\right)
\end{aligned}
$$

讲一下一个容易错的地方

$$
G'(F_0(x))=A(x)e^{F_0(x)-1}
$$

$A(x),B(x)$ 看作常项，后面没有 $F_0'(x)$。

至于这东西有什么用，还是得看 EGF 那一套推导。求导可以抹去一个标号，同理积分可以增加一个标号，比如有标号无根非平面 $k$ 叉树的 EGF 为

$$
T=\int (xT')^k
$$

给个递归版的代码吧，一千个人有一千个多项式板子，仅供参考

```cpp
#pragma GCC optimize(2,3,"Ofast")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
#define in inline
namespace fast_io
{
	char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;
	in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
	in int read()
	{
		int x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;
		x=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;
	}
	in db gf() {int a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}
	in int gs(char *s) {char c,*t=s;while(c=gc(),c<=32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
	in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
	in void flush() {if(C>1<<22) ot();}
	template <typename T>
	in void write(T x,char t)
	{
		int y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
		if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
	}
	in void write(char *s) {int l=strlen(s);for(int i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
#define init(x,n) static int x[N];memset(x,0,4*n);
const int N=4e5+5,p=998244353,mod=p,G=3;
int n,m,ans,len,L,a[N],b[N],c[N],fac[N],inv[N];
in void M(int&x) {x-=p,x+=x>>31&p;}
in int add(int x,int y) {return M(x+=y),x;}
in int sub(int x,int y) {return M(x-=y),x;}
in int qpow(int x,int y) {int z=1;for(;y;y>>=1,x=1ll*x*x%p) if(y&1) z=1ll*x*z%p;return z;}
in void read(int *a,int n) {for(int i=0;i<n;i++) a[i]=read();}
in void print(int *a,int n) {for(int i=0;i<n;i++) write(a[i]," \n"[i==n-1]);}
in void pre()
{
	fac[0]=fac[1]=inv[0]=inv[1]=1;for(int i=2;i<N;i++) inv[i]=1ll*(p-p/i)*inv[p%i]%p;
	for(int i=2;i<N;i++) inv[i]=1ll*inv[i]*inv[i-1]%p,fac[i]=1ll*fac[i-1]*i%p;
}
namespace poly
{
	int r[N],ny[N],o[N],_o[N];
	in int qpow(int x,int y) {int z=1;for(;y;y>>=1,x=1ll*x*x%p) if(y&1) z=1ll*x*z%p;return z;}
	in void inter(int *a,int n) {for(int i=n-1;i;i--) a[i]=1ll*a[i-1]*qpow(i,p-2)%p;a[0]=0;}
	in void direv(int *a,int n) {for(int i=1;i<n;i++) a[i-1]=1ll*a[i]*i%p;a[n-1]=0;}
	in void calrev(int len,int L)
	{
		for(int i=1;i<=len;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(L-1));
		o[0]=1;o[1]=qpow(G,(p-1)/len);
		for(int i=2;i<=len;i++) o[i]=1ll*o[1]*o[i-1]%p;
		for(int i=0;i<len;i++) _o[i]=o[len-i];
	}
	in void ntt(int *a,int n,int op)
	{
		for(int i=0;i<n;i++) if(i<r[i]) swap(a[i],a[r[i]]);int *w=(op==1)?o:_o;
		for(int i=1;i<n;i<<=1) for(int j=0,d=i<<1;j<n;j+=d) for(int k=0,x,y;k<i;k++)
		x=a[j|k],y=1ll*w[n/(i<<1)*k]*a[i|j|k]%p,M(a[j|k]=x+y),M(a[i|j|k]=x+p-y);
		if(op==1) return; int inv=qpow(n,p-2);for(int i=0;i<n;i++) a[i]=1ll*a[i]*inv%p;
	}
	in void mul(int *a,int *b,int l1,int l2,int n,int *c=0)
	{
		if(c==0) c=a;if((int)ceil(log2(l1+l2-1))^L) L=ceil(log2(l1+l2-1)),calrev(len=1<<L,L);
		init(x,len);memcpy(x,a,4*l1);init(y,len);memcpy(y,b,4*l2);
		ntt(x,len,1);ntt(y,len,1);for(int i=0;i<len;i++) c[i]=1ll*x[i]*y[i]%p;
		ntt(c,len,-1);memset(c+n,0,4*(len-n));
	}
	void inv(int *a,int *b,int n)
	{
		if(n==1) return b[0]=qpow(a[0],p-2),void();
		inv(a,b,(n+1)>>1);L=ceil(log2(2*n));
		calrev(len=1<<L,L);init(c,len);memcpy(c,a,4*n);ntt(b,len,1);ntt(c,len,1);
		for(int i=0;i<len;i++) b[i]=(2ll-1ll*b[i]*c[i]%p+p)%p*b[i]%p;
		ntt(b,len,-1);memset(b+n,0,4*(len));
	}
	in void inv(int *a,int n) {init(b,n<<1);inv(a,b,n);memcpy(a,b,4*n);memset(b,0,4*len);}
	in void ln(int *a,int n)
	{
		init(b,n<<1);memcpy(b,a,4*n);direv(b,n);inv(a,n);
		mul(a,b,n,n,n);inter(a,n);memset(a+n,0,4*len/2);
	}
	void exp(int *a,int *b,int n)
	{
		if(n==1) return b[0]=1,void();
		exp(a,b,(n+1)>>1);init(c,n<<1);memcpy(c,b,4*n);ln(c,n);
		for(int i=0;i<n;i++) c[i]=((1ll*a[i]-c[i]+(i==0))%p+p)%p;mul(b,c,n,n,n);
	}
	in void exp(int *a,int n) {init(b,n<<1);exp(a,b,n);memcpy(a,b,4*n);memset(b,0,4*len);}
	in void div(int *a,int *b,int n,int m)
	{
		init(c,n<<1);memcpy(c,a,4*n);init(d,n<<1);memcpy(d,b,4*m);
		reverse(c,c+n);reverse(b,b+m);inv(b,n-m+1);
		mul(c,b,n<<1,n<<1,n);reverse(c,c+n-m+1);memset(c+(n-m+1),0,4*(m-1));
		mul(d,c,n<<1,n<<1,n);for(int i=0;i<m;i++) b[i]=((a[i]-d[i])%p+p)%p;
		memcpy(a,c,4*n);
	}
	in void sqrt(int *a,int *b,int n)
	{
		if(n==1) return b[0]=1,void();
		sqrt(a,b,(n+1)>>1);init(c,n<<1);init(d,n<<1);memcpy(c,b,4*n);memcpy(d,a,4*n);inv(c,n);
		L=ceil(log2(n*2));len=1<<L;calrev(len,L);ntt(b,len,1);ntt(c,len,1);ntt(d,len,1);
		for(int i=0;i<len;i++) b[i]=(1ll*b[i]+1ll*c[i]*d[i]%p)%p*qpow(2,p-2)%p;
		ntt(b,len,-1);memset(b+n,0,4*(len>>1));
	}
	in void sqrt(int *a,int n) {init(b,n<<1);sqrt(a,b,n);memcpy(a,b,4*n);}
	int *f[N],*g[N],bin[N<<3],*np(bin);
	void eva_init(int p,int l,int r,int *a)
	{
		g[p]=np;np+=r-l+2;f[p]=np;np+=r-l+2;if(l==r) return g[p][0]=1,M(g[p][1]=mod-a[l]);
		int ls=p<<1,rs=ls|1,mid=(l+r)>>1,l1=mid-l+2,l2=r-mid+1;
		eva_init(ls,l,mid,a);eva_init(rs,mid+1,r,a);
		mul(g[ls],g[rs],l1,l2,l1+l2-1,g[p]);
	}
	in void eva_mul(int *a,int *b,int l1,int l2,int n,int *c)
	{
		if(c==0) c=a;if((int)ceil(log2(l1+l2-1))^L) L=ceil(log2(l1+l2-1)),calrev(len=1<<L,L);
		init(x,len);memcpy(x,a,4*l1);init(y,len);memcpy(y,b,4*l2);reverse(y,y+l2);
		ntt(x,len,1);ntt(y,len,1);for(int i=0;i<len;i++) x[i]=1ll*x[i]*y[i]%p;
		ntt(x,len,-1);memcpy(c,x+l2-1,4*(l1-l2+1));
	}
	void eva_work(int p,int l,int r,int *a)
	{
		if(l==r) return a[l]=f[p][0],void();
		int ls=p<<1,rs=ls|1,mid=(l+r)>>1,lp=r-l+1,l1=mid-l+2,l2=r-mid+1;
		eva_mul(f[p],g[rs],lp,l2,lp+l2-1,f[ls]);eva_work(ls,l,mid,a);
		eva_mul(f[p],g[ls],lp,l1,lp+l1-1,f[rs]);eva_work(rs,mid+1,r,a);
	}
	in void eva(int *a,int *b,int n,int m,int *c)
	{
		init(x,n);init(y,n);eva_init(1,0,m-1,b);inv(g[1],x,m+1);
		reverse(x,x+m+1);mul(a,x,n,m+1,n+m,y);
		memcpy(f[1],y+n,4*(m+1));eva_work(1,0,m-1,c);
		for(int i=0;i<m;i++) M(c[i]=1ll*b[i]*c[i]%p+a[0]);
	}
	in void sin(int *a,int n)
	{
		static const int i=qpow(G,(p-1)/4);for(int j=0;j<n;j++) a[j]=1ll*a[j]*i%p;
		init(b,n<<1);for(int j=0;j<n;j++) M(b[j]=-a[j]);
		exp(a,n);exp(b,n);for(int j=0;j<n;j++) a[j]=1ll*sub(a[j],b[j])*qpow(2*i,p-2)%p;
	}
	in void cos(int *a,int n)
	{
		static const int i=qpow(G,(p-1)/4);for(int j=0;j<n;j++) a[j]=1ll*a[j]*i%p;
		init(b,n<<1);for(int j=0;j<n;j++) b[j]=-a[j];
		exp(a,n);exp(b,n);for(int j=0;j<n;j++) a[j]=1ll*add(a[j],b[j])*qpow(2,p-2)%p;
	}
	in void arcsin(int *a,int n)
	{
		init(b,n<<1);memcpy(b,a,4*n);direv(a,n);
		mul(b,b,n,n,n);for(int i=0;i<n;i++) b[i]=p-b[i];b[0]++;
		sqrt(b,n);inv(b,n);mul(a,b,n,n,n);inter(a,n);
	}
	in void arctan(int *a,int n)
	{
		init(b,n<<1);memcpy(b,a,4*n);direv(a,n);
		mul(b,b,n,n,n);b[0]++;inv(b,n);mul(a,b,n,n,n);inter(a,n);
	}
	in void qpow(int *a,int n,int k) {ln(a,n);for(int i=0;i<n;i++) a[i]=1ll*a[i]*k%p;exp(a,n);}
	in int lagrange(int *a,int n,int k) 
    {
    	init(b,n);inv(a,b,n);qpow(b,n,k);
        return 1ll*b[k-1]*qpow(k,p-2)%p;
    }
	in void G(int *f,int *a,int *b,int n) 
    {
    	M(f[0]+=p-1);exp(f,n);mul(f,a,n,n,n);
        for(int i=0;i<n;i++) M(f[i]+=b[i]);
    }
	in void direv(int *a,int *b,int *c,int n)
	{
		if(n==1) return c[0]=1,void();direv(a,b,c,(n+1)>>1);
		init(d,n<<1);memcpy(d,c,4*n);G(d,a,b,n);
        init(d1,n<<1);memcpy(d1,d,4*n);for(int i=0;i<n;i++) M(d1[i]+=p-b[i]);
		init(h,n<<1);memcpy(h,d1,4*n);mul(h,c,n,n,n);for(int i=0;i<n;i++) M(h[i]=d[i]+p-h[i]);
		init(P,n<<1);for(int i=0;i<n;i++) P[i]=p-d1[i];inter(P,n);exp(P,n);
		mul(h,P,n,n,n);inter(h,n);M(h[0]+=1);inv(P,n);mul(h,P,n,n,n);memcpy(c,h,4*n);
	}
}
int main()
{
	n=read()+1;read(a,n);read(b,n);
	poly::direv(a,b,c,n);print(c,n);
	return ot(),0;
}
//Author: disangan233
//Welcome to the Phigros!
```

---

## 作者：Convergent_Series (赞：4)

## 一阶微分方程的常数变易法

### (1) 一阶齐次线性微分方程

$$\begin{aligned}
F'(x)&=P(x)F(x)\\
\dfrac{1}{F(x)}\times F'(x)&=P(x)\\
(\ln F(x))'&=P(x)\\
\ln F(x)&=\int P(x) \text dx+\ln C\\
F(x)&= Ce^{\int P(x) \text dx}\\
\end{aligned}$$


### (2) 一阶非齐次线性微分方程

$$F'(x)=P(x)F(x)+Q(x)$$

考虑拆成两个只与 $P(x)$ 或 $Q(x)$ 其中一个相关的方程，分别求解后代回去计算 $F(x)$。

设 $F(x)=u(x)v(x)$

$$\begin{aligned}
u'(x)v(x)+u(x)v'(x)&=P(x)u(x)v(x)+Q(x)\\
u'(x)v(x)+u(x)(v'(x)-P(x)v(x))&=Q(x)\\
\end{aligned}$$

若 $v'(x)-P(x)v(x)=0$ 就可以消掉 $P(x)$ 求解了。由 (1) 得此时 $v(x)=C_ve^{\int P(x) \text dx}$。带入原方程
$$\begin{aligned}
u'(x)v(x)&=Q(x)\\
u'(x)C_ve^{\int P(x) \text dx}&=Q(x)\\
u'(x)&=\dfrac{Q(x)}{C_ve^{\int P(x) \text dx}}\\
u(x)&=C_v^{-1}(\int Q(x)e^{-\int P(x) \text dx}\text dx+C_u)\\
\end{aligned}$$

$\displaystyle\therefore F(x)=u(x)v(x)=(\int Q(x)e^{-\int P(x) \text dx}\text dx+C_u)e^{\int P(x) \text dx}$

发现解的形式与对应齐次方程的解 $ F(x)= Ce^{\int P(x) \text dx}$ 相似，只是把常数 $C$ 换成了关于 $x$ 的多项式 $\displaystyle C(x)=\int Q(x)e^{-\int P(x) \text dx}\text dx+C_u$

所以可以得到微分方程的常数变易法：先解对应的齐次方程，将常数换为待定多项式后代回原方程求解。

### (3) 一阶非线性微分方程


$$\frac{\text dF(x)}{\text dx} = A(x)\text e^{F(x)-1}+B(x) $$

考虑对应的齐次方程

$$\begin{aligned}
\dfrac{\text dF(x)}{\text dx}&=A(x)e^{F(x)-1}\\
\int\dfrac{\text dF(x)}{e^{F(x)-1}}&=\int A(x)\text dx\\
-e^{1-F(x)}&=\int A(x)\text dx-C\\
1-F(x)&=\ln(C-\int A(x)\text dx)\\
F(x)&=1-\ln(C-\int A(x)\text dx)\\
\end{aligned}$$

设原方程的解为 $\displaystyle F(x)=1-\ln(C(x)-\int A(x)\text dx)$，代入得

$$\begin{aligned}
(1-\ln(C(x)-\int A(x)\text dx))'&=\dfrac{A(x)}{\displaystyle C(x)-\int A(x)\text dx}+B(x)\\
-\dfrac{C'(x)-A(x)}{\displaystyle C(x)-\int A(x)\text dx}&=\dfrac{A(x)}{\displaystyle C(x)-\int A(x)\text dx}+B(x)\\
C'(x)&=-B(x)(C(x)-\int A(x)\text dx)\\
&=-B(x)C(x)+B(x)\int A(x)\text dx\\
\end{aligned}$$

由 (2)
得

$$\displaystyle C(x)=(\int (\int A(x)\text dx
)B(x)e^{\int B(x) \text dx}\text dx+C_0)e^{-\int B(x) \text dx}$$

$\therefore$

$$\begin{aligned}
F(x)&=1-\ln(C(x)-\int A(x)\text dx)\\
&=1-\ln((\int (\int A(x)\text dx)B(x)e^{\int B(x) \text dx}\text dx+C_0)e^{-\int B(x) \text dx}-\int A(x)\text dx)\\
&=1+\int B(x)\text dx-\ln(\int (\int A(x)\text dx)B(x)e^{\int B(x) \text dx}\text dx+C_0-\int A(x)\text dxe^{\int B(x) \text dx})\\
\end{aligned}$$

取  $C_0=1$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
#define bceil(n) (1<<__lg(n-1)+1)
using namespace std;
const int siz=1<<18;char buf[siz],*p1=buf,*p2=buf,obuf[siz],*p3=obuf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,siz,stdin),p1==p2)?EOF:*p1++
#define putchar(x) (p3-obuf<siz)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
int read(){
    int a=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+(ch^'0'),ch=getchar();
    return a;
} 
void write(int a){
    if(a>9) write(a/10); 
    putchar(a%10+'0');
}
const int MAXN=1e6+10,P=998244353,G=3,Gi=332748118,Img=86583718;
int l,r[MAXN],inv[MAXN],sav[MAXN<<1];
ll qpow(ll a,ll b=P-2){
    if(a==1) return 1;
    ll ans=1;
    while(b){if(b&1) ans=ans*a%P;a=a*a%P;b>>=1;}
    return ans;
}
void tpre(int lim){
    if(l==lim) return;l=lim;
    for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);
}
void px(int *A,int *B,int n){for(int i=0;i<n;i++) A[i]=1ll*A[i]*B[i]%P;} 
void NTT(int *A,int lim,int type){
    tpre(lim);
    static ull f[MAXN<<1],w[MAXN];w[0]=1;
    for(int i=0;i<lim;i++) f[i]=(((ll)P<<5)+A[r[i]])%P;
    for(int mid=1;mid<lim;mid<<=1){
        ull Wn=qpow(type+1?G:Gi,(P-1)/(mid+mid));
        for(int i=1;i<mid;i++)w[i]=w[i-1]*Wn%P;
        for(int j=0;j<lim;j+=mid+mid){
            for(int k=0;k<mid;k++){
                int x=w[k]*f[j|mid|k]%P;
                f[j|mid|k]=f[j|k]+P-x;
                f[j|k]+=x;
            }   
        }if(mid==(1<<10)){for(int i=0;i<lim;i++) f[i]%=P;}
    }if(type-1){
        ull inv=qpow(lim);
        for(int i=0;i<lim;i++) A[i]=f[i]%P*inv%P;
    }else for(int i=0;i<lim;i++) A[i]=f[i]%P;
}
void mul(int *A,int *B,int la,int lb){
    int lim=bceil(la+la);
    cpy(sav,B,lim);clr(sav+la,lim-la);
    NTT(A,lim,1);NTT(sav,lim,1);
    px(A,sav,lim);NTT(A,lim,-1);
    clr(A+lb,lim-lb);clr(sav,lim);
} 
void invp(int *A,int lim){
    int n=bceil(lim);
    static int w[MAXN<<1],r[MAXN<<1];
    w[0]=qpow(A[0]);
    for (int ln=2;ln<=n;ln<<=1){
        for(int i=0;i<(ln>>1);i++) r[i]=w[i];
        cpy(sav,A,ln);NTT(sav,ln,1);NTT(r,ln,1);px(r,sav,ln);
        NTT(r,ln,-1);clr(r,ln>>1);cpy(sav,w,ln);NTT(sav,ln,1);
        NTT(r,ln,1);px(r,sav,ln);NTT(r,ln,-1);
        for(int i=ln>>1;i<ln;i++) w[i]=(w[i]*2ll-r[i]+P)%P;
    }cpy(A,w,lim);clr(sav,n);clr(w,n);clr(r,n);
}
void deriv(int *A,int lim){
    for(int i=1;i<lim;i++) A[i-1]=1ll*A[i]*i%P;
    A[lim-1]=0;
}
void inv_init(int lim){
    inv[1]=1;
    for(int i=2;i<=lim;i++) inv[i]=1ll*inv[P%i]*(P-P/i)%P;
}
void integ(int *A,int lim){
    for(int i=lim;i;i--) A[i]=1ll*A[i-1]*inv[i]%P;
    A[0]=0;
}
void lnp(int *A,int lim){
    static int w[MAXN<<1];
    cpy(w,A,lim);
    invp(w,lim);deriv(A,lim);
    mul(A,w,lim,lim);
    integ(A,lim-1);
    clr(w,lim);
}
void exp(int *A,int lim){
    static int s[MAXN<<1],s2[MAXN<<1];
    int n=bceil(lim);
    s2[0]=1;
    for(int ln=2;ln<=n;ln<<=1){
        cpy(s,s2,ln>>1);lnp(s,ln);
        for(int i=0;i<ln;i++) s[i]=(A[i]-s[i]+P)%P;
        s[0]=(s[0]+1)%P;
        mul(s2,s,ln,ln);
    }cpy(A,s2,lim);clr(s,n);clr(s2,n);
}
int n,m,A[MAXN],B[MAXN],F[MAXN],s[MAXN];
int main(){
	n=read()+1;inv_init(n);
	for(int i=0;i<n;i++) A[i]=read();
	for(int i=0;i<n;i++) B[i]=read();
	integ(A,n);cpy(F,B,n);integ(F,n);
	cpy(s,F,n);exp(s,n);mul(s,A,n,n);
	mul(B,s,n,n);integ(B,n);B[0]++;
	for(int i=0;i<n;i++) B[i]=(B[i]-s[i]+P)%P;
	lnp(B,n);F[0]++;
	for(int i=0;i<n;i++) F[i]=(F[i]-B[i]+P)%P;
	for(int i=0;i<n;i++) write(F[i]),putchar(' ');
    fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

---

## 作者：peterwuyihong (赞：2)

我终于会了！我终于会了！我终于会了！

教授只讲了一阶齐次微分方程，我居然把一阶微分方程的解 yy 出来了。

题意：求方程的通解

$$\frac{\text{d}y}{\text{d}x}=A(x)e^{y-1}+B(x)$$

先解

$$\frac{\text{d}y}{\text{d}x}=A(x)e^{y-1}$$

$$\int e^{1-y}\text{d}y=\int A(x)\text{d}x$$

$$-e^{1-y}=\int A(x)\text{d}x+C$$

$$y=1-\ln(-\int A(x)\text{d}x-C)$$

使用常数变 yee 法，令 $C$ 为关于 $x$ 的函数 $C(x)$。

$$\frac{\text{d}(1-\ln(-\int A(x)\text{d}x-C(x)))}{\text{d}x}=\frac{A(x)}{-\int A(x)\text{d}x-C(x)}+B(x)$$
$${\text{d}(\ln(-\int A(x)\text{d}x-C(x)))}=\frac{A(x)\text{d}x}{\int A(x)\text{d}x+C(x)}-B(x)\text{d}x$$
$${\frac{\text{d}(\int A(x)\text{d}x+C(x))}{\int A(x)\text{d}x+C(x)}}=\frac{A(x)\text{d}x}{\int A(x)\text{d}x+C(x)}-B(x)\text{d}x$$
$${\frac{\text{d}C(x)}{\int A(x)\text{d}x+C(x)}}=-B(x)\text{d}x$$
$$\frac{\text{d}C(x)}{\text{d}x}+B(x)C(x)=-B(x)\int A(x)\text{d}x$$

对于方程

$$\frac{\text{d}y}{\text{d}x}+P(x)y=Q(x)$$

有通解

$$y=e^{-\int P(x)\text{d}x}(\int Q(x)e^{\int P(x)\text{d}x}\text{d}x+C)$$

对于这个通解的解法有两种：

第一种：两边同乘 $e^{\int P(x)\text{d}x}$

$$\frac{\text{d}(ye^{\int P(x)\text{d}x})}{\text{d}x}=Q(x)e^{\int P(x)\text{d}x}$$

$$ye^{\int P(x)\text{d}x}=\int Q(x)e^{\int P(x)\text{d}x}\text{d}x+C$$

就能解了。

第二种：常数变易法

对于方程 $\dfrac{\text{d}y}{\text{d}x}+P(x)y=0$

较易求解：

$$\frac{\text{d}y}{y}=-P(x)\text{d}x$$

$$y=Ce^{-\int P(x)\text{d}x}$$

此时令 $C$ 为关于 $x$ 的函数 $C(x)$

$$\frac{\text{d}(C(x)e^{-\int P(x)\text{d}x})}{\text{d}x}+P(x)C(x)e^{-\int P(x)\text{d} x}=Q(x)$$
化简得

$$\frac{\text{d}C(x)}{\text{d}x}=Q(x)e^{\int P(x)\text{d}x}$$
$$C(x)=\int Q(x)e^{\int P(x)\text{d}x}\text{d}x+C$$

回代即可得到

$$y=e^{-\int P(x)\text{d}x}(\int Q(x)e^{\int P(x)\text{d}x}\text{d}x+C)$$

代入可得

$$C(x)=e^{-\int B(x)\text{d}x}(\int-B(x)\int A(x)\text{d}xe^{\int B(x)\text{d}x}\text{d}x+C)$$

$$y=1-\ln(-\int A(x)\text{d}x-e^{-\int B(x)\text{d}x}(\int-B(x)\int A(x)\text{d}xe^{\int B(x)\text{d}x}\text{d}x+C))$$

---

## 作者：littlez_meow (赞：0)

乱糊不用脑子解方程做法，常数巨大。

[题目指路](https://www.luogu.com.cn/problem/P6613)。

## 解方程

下面推导省略同余号。

首先根据解方程的习惯，设 $y=F(x)$，有方程：

$$\dfrac{\mathrm{d} y}{\mathrm{d} x}=A(x)e^{y-1}+B(x) $$

如果这里不是 $e^{y-1}$ 而是一个 $y^n$，方程就是一个伯努利方程，特别好解。

因此，考虑换元，设 $t=e^{y-1}$，则 $y=\ln t+1$。

根据边界条件，当 $x=0$ 时，$y=1$，故此时 $t=1$。

原方程可化为：

$$\dfrac{\mathrm{d}(\ln t+1)}{\mathrm{d} x}=A(x)t+B(x)$$

我们有 $\mathrm{d}(\ln t+1)=\dfrac 1 t \mathrm{d}t$，移项得到：

$$\dfrac{\mathrm{d}t}{\mathrm{d} x}=A(x)t^2+B(x)t$$

还看不出来？再移项变成 $\dfrac{\mathrm{d}t}{\mathrm{d} x}-B(x)t=A(x)t^2$。这是一个伯努利方程！接下来就好解了。

两边同时除以 $t^2$，得到：

$$t^{-2}\dfrac{\mathrm{d}t}{\mathrm{d} x}-t^{-1}B(x)=A(x)$$

换元，设 $k=t^{-1}$，则 $t=\dfrac 1 k$。根据边界条件得到当 $x=0$ 时 $k=1$。

求导得到下式：

$$\dfrac{\mathrm{d}k}{\mathrm{d} x}=-t^{-2}\dfrac{\mathrm{d}t}{\mathrm{d} x}$$

带入上式，有：

$$\dfrac{\mathrm{d}k}{\mathrm{d} x}+B(x)k=-A(x)$$

这是一个关于 $k$ 的一阶线性微分方程。有通解：

$$k=C e^{-\int P(x) \mathrm{d}x}+e^{-\int P(x) \mathrm{d}x} \int Q(x) e^{\int P(x) \mathrm{d}x}\mathrm{d}x$$

具体解法是采用常数变易法化成一阶齐次微分方程然后求解。

考虑 $C$ 的取值。我们发现当 $x=0$ 时 $\int Q(x) e^{\int P(x)\mathrm{d}x}\mathrm{d}x=0,e^{-\int P(x) \mathrm{d}x}=1$，又由此时 $k=1$ 得到 $C=1$。

因此，使用上面的公式得到 $k$，多项式求逆得到 $t$，多项式求对数得到 $y-1$，即可求出答案。

总时间复杂度 $O(n\log n)$，但带个 $6$ 倍左右的常数。~~喜提[全站最劣解](https://www.luogu.com.cn/record/135511379)~~。不过一点脑子不用，套板子就行。

## 附上代码

省略多项式板子，其中 `inte` 为不定积分。

```cpp
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	A.len=B.len=n;
	F(i,0,n) cin>>A.num[i];
	F(i,0,n) cin>>B.num[i];
	poly x,y;
	B=B.inte();
	x=B.exp();
	y=(-1*B).exp();
	x=x*(-1*A);
	x.resize(n);
	x=x.inte();
	x.resize(n);
	res=y+y*x;
	res.resize(n);
	res=res.inv();
	res.resize(n);
	res=res.ln();
	res.resize(n);
	res=res+1;
	res.output();
	return 0;
}
```

完结撒花，不喜勿喷 qwq~

---


# [SNOI2020] 生成树

## 题目描述

给定无向连通图 $G$，已知 $G$ 在删掉一条边后是一颗仙人掌（仙人掌：不存在两个拥有公共边的简单环的无向联通图），求 $G$ 的生成树个数。结果对 $998244353$ 取模。

## 说明/提示

对于所有数据，$1 \le n \le m \le2 \times 10^5$。

- 对于 $10\%$ 的数据，$1 \le n=m \le 2000$。
- 对于另外 $40\%$ 的数据，$1 \le n,m \le 10^5$ 且 $G$ 本身是仙人掌。
- 对于余下 $50\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
4 5
1 2
1 3
2 3
2 4
3 4```

### 输出

```
8```

# 题解

## 作者：Karry5307 (赞：19)

### 题意

给定一个 $n$ 个点 $m$ 条边的图，保证这个图删掉一条边之后是边仙人掌，求该图生成树个数。

$\texttt{Data Range:}1\leq n,m\leq 5\times 10^5$

### 题解

广义串并联图。

注意到原图是广义串并联图，所以可以考虑对每条边进行 DP，然后在收缩的时候进行转移。

一个思路是设 $f_e$ 表示 $e$ 这条边在生成树上的方案，$g_e$ 表示这条边不在生成树上的方案，那么对于收缩的三种操作有：

- 删 $1$ 度点：直接将 $f_e$ 乘进答案即可。

- 缩 $2$ 度点：这两条边不可能同时不存在于生成树上，同时缩出来的边只有当两条边都存在时才存在，于是有如下转移：

$$\begin{cases}f_e=f_{e_1}f_{e_2}\\g_e=f_{e_1}g_{e_2}+f_{e_2}g_{e_1}\end{cases}$$

- 叠合重边：这两条边不可能同时存在于生成树上，同时缩出来的边只有当两条边都不存在时才不存在，于是有如下转移：

$$\begin{cases}f_e=f_{e_1}g_{e_2}+f_{e_2}g_{e_1}\\g_e=g_{e_1}g_{e_2}\end{cases}$$

然后拓扑排序构造出整个收缩序列即可，删边的话可以使用哈希表或者是 `map`，实测 `map` 比各种哈希表优秀，实现上有亿点细节要注意。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=5e5+51,MOD=998244353;
queue<ll>q;
ll n,m,u,v,totd,top,x,y,r,res=1;
ll f[MAXN],g[MAXN],deg[MAXN];
map<ll,ll>mp[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
    n=read(),m=read(),g[0]=1;
    for(register int i=1;i<=m;i++)
    {
    	u=read(),v=read();
		!mp[u][v]?g[mp[u][v]=mp[v][u]=++totd]=1,deg[u]++,deg[v]++:1;
		f[mp[u][v]]++;
	}
	for(register int i=1;i<=n;i++)
	{
		deg[i]<=2?q.push(i):(void)1;
	}
	while(!q.empty())
	{
		top=q.front(),q.pop();
		if(!deg[top])
		{
			continue;
		}
		if(deg[top]==1)
		{
			tie(u,x)=*mp[top].begin(),deg[top]=0,res=(li)res*f[x]%MOD;
			mp[top].clear(),mp[u].erase(top),--deg[u]<=2?q.push(u):(void)1;
		}
		if(deg[top]==2)
		{
			tie(u,x)=*mp[top].begin(),tie(v,y)=*next(mp[top].begin()),r=mp[u][v];
			mp[top].clear(),mp[u].erase(top),mp[v].erase(top),deg[top]=0;
			g[x]=((li)g[x]*f[y]+(li)f[x]*g[y])%MOD,f[x]=(li)f[x]*f[y]%MOD;
			f[x]=((li)f[x]*g[r]+(li)g[x]*f[r])%MOD,g[x]=(li)g[x]*g[r]%MOD;
			mp[u][v]=mp[v][u]=x;
			r?--deg[u]<=2?q.push(u):(void)1,--deg[v]<=2?q.push(v):(void)1:(void)1;
		}
	}
	printf("%d\n",res);
}
```

---

## 作者：DaiRuiChen007 (赞：9)

# P6790 题解

**题目大意**

> 给一张 $n$ 个点 $m$ 条边的图，保证存在某种保留 $m-1$ 条边的方案使得新图是边仙人掌，求图的生成树个数。
>
> 数据范围：$n,m\le 5\times 10^5$。

**思路分析**

注意到原图环很少，因此考虑证明原图是广义串并联图，任取四个点，容易发现无法选出六条边不交的路径将他们两两连接，因此原图是广义串并联图。

考虑用广义串并联图方法逐步简化这张图（删一度点、缩二度点、叠合重边）。

观察广义串并联图缩边后的一条边 $u\to v$，显然对应原图的一个子图，且子图里的点除了 $u\to v$ 以外只和 $u/v$ 连接，因此这个子图最后的状态只有两种：$u,v$ 连通或 $u,v$ 不连通。

不妨设 $e=(u,v)$ 连通方案数为 $f(e)$，不连通方案数为 $g(e)$。

- 删一度点：答案乘上 $f(e)$。
- 缩二度点：合并 $e_1,e_2$ 得到 $f(e^*)=f(e_1)\times f(e_2),g(e^*)=f(e_1)\times g(e_2)+f(e_2)\times g(e_1)$。
- 叠合重边：合并 $e_1,e_2$ 得到 $f(e^*)=f(e_1)\times g(e_2)+f(e_2)\times g(e_1),g(e^*)=g(e_1)\times g(e_2)$。

用队列维护度数 $\le 2$ 的点，逐步 BFS 即可。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fi first
#define se second
using namespace std;
const int MAXN=5e5+5,MOD=998244353;
int n,m;
map <int,array<ll,2>> g[MAXN];
queue <int> Q;
ll ans=1;
inline void link(int u,int v,array<ll,2> x) {
	if(g[u].count(v)) {
		array<ll,2> y=g[u][v];
		g[u][v]=g[v][u]={x[0]*y[0]%MOD,(x[0]*y[1]+x[1]*y[0])%MOD};
	} else g[u][v]=g[v][u]=x;
}
inline void upd(int x) { if(g[x].size()<=2) Q.push(x); }
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;++i) scanf("%d%d",&u,&v),link(u,v,{1,1});
	for(int i=1;i<=n;++i) upd(i);
	while(Q.size()) {
		int u=Q.front(); Q.pop();
		if(g[u].size()==1) ans=ans*(g[u].begin()->se)[1]%MOD;
		if(g[u].size()==2) {
			int x=g[u].begin()->fi,y=g[u].rbegin()->fi;
			auto c=g[u].begin()->se,d=g[u].rbegin()->se;
			link(x,y,{(c[0]*d[1]+c[1]*d[0])%MOD,c[1]*d[1]%MOD});
		}
		for(auto e:g[u]) g[e.fi].erase(u),upd(e.fi);
		g[u].clear();
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：8)

首先先思考如果其是一棵仙人掌，我们应该怎么做：显然，每个环上须删去且仅删去一条边，于是答案就是环长之积。

但是这不是仙人掌。还有一条额外边。

考虑建出仙人掌的圆方树，并将该额外边对应的路径摊到圆方树上。

该路径经过了若干方点，也即经过了若干环。

该路径外的部分，仍然是仙人掌的性质：每个环删一条边。该路径上的部分，我们把它单独摘出来。显然此时我们得到了一个若干环首尾相接连成一个大“环”的图形，就像若干小铁环串成一条锁链一样。

显然，除了其中的一个小环要删两条边外，其它小环都只需删一条边。

枚举该删两条边的小环。其两侧有两个与其它环相连的“割点”，将整个小环分成了上下两条路径。显然我们要在上下路径中各删一条，因此方案数即为上下路径长度之积。其它环的贡献即为其长度之积。

时间复杂度可以做到线性。

但是，我们回过头来思考一下，**应该如何找到那条额外边呢**？

一种想法就是建出广义圆方树然后大力在唯一一个非环 SCC 中大力讨论，但这太不优雅了。

注意到仙人掌有一个优雅的性质：求出其任一棵生成树，将其所有非树边摊到树上，则所有非树边对应路径两两无公共边。换句话说，就是每条树边被至多一条非树边覆盖。

现在多了一条边，就等于若干树边被额外一条非树边覆盖。

那就把所有非树边摊到树上后，找到所有被多于一条非树边覆盖的树边（显然，此时其必然被恰两条非树边覆盖），然后求出覆盖其的非树边的交集，则交集中的边即为该特殊边。（若交集中有不止一条边，则其均可作为特殊边）

个人觉得这个做法不用分类讨论之类的，会更加可爱……吗？

并不是。虽然仙人掌确实是满足每条树边被至多一条非树边覆盖的性质的，但是仙人掌加上一条边后，不一定每条树边都被至多两条非树边覆盖：假如加上的边在求生成树时成为了树边，则会有两条位于同一环中的边变成非树边，进而它们覆盖的边集有交。

这时，手玩可以发现新增边必然位于那两条环中的非树边对应路径的交集中。进一步，其是交集中某条仅被该两条环非树边覆盖的边。找到其即可。假如寻找的生成树是 dfs 树，还能更好写一些（因为 dfs 树中的非树边必为返祖边）。

同时，用这种方法实现时甚至不用写圆方树。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int n,m,X[500100],Y[500100];
vector<int>v[500100];
vector<int>u[500100];
int fi[500100],dep[500100];
int ban;
bool tr[500100];
void dfs(int x){
	for(auto i:v[x])if(i!=fi[x]&&i!=ban){
		int y=X[i]^Y[i]^x;
		if(fi[y])continue;
		tr[i]=true,fi[y]=i,dep[y]=dep[x]+1,dfs(y);
	}
}
int len[500100],on[500100];
void func(){
	memset(len,0,sizeof(len)),memset(on,0,sizeof(on));
	memset(fi,0,sizeof(fi)),memset(tr,false,sizeof(tr));
	for(int i=0;i<=n;i++)u[i].clear();
	fi[1]=-1,dep[1]=0,dfs(1);
	for(int i=1;i<=m;i++)if(!tr[i]&&i!=ban)
		for(int x=X[i],y=Y[i];x!=y;){
			if(dep[x]<dep[y])swap(x,y);
			u[x].push_back(i),len[i]++;
			x=X[fi[x]]^Y[fi[x]]^x;
			// printf("%d %d\n",x,y);
		}
}
vector<int>U,V;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d",&X[i],&Y[i]),
		v[X[i]].push_back(i),v[Y[i]].push_back(i);
	func();
	int mx=0;
	for(int i=1;i<=n;i++)mx=max(mx,(int)u[i].size());
	if(mx<=1){
		int res=1;
		for(int i=1;i<=m;i++)if(len[i])res=1ll*res*(len[i]+1)%mod;
		printf("%d\n",res);
		return 0;
	}
	for(int i=2;i<=n;i++)if(u[i].size()==mx){
		if(u[0].empty())u[0]=u[i];
		else{
			for(auto it=u[0].begin();it!=u[0].end();)
				if(find(u[i].begin(),u[i].end(),*it)==u[i].end())
					it=u[0].erase(it);
				else it++;
		}
	}
	if(mx==3){
		assert(u[0].size()>=2);
		int i=u[0][0],j=u[0][1];
		if(dep[X[i]]<dep[Y[i]])swap(X[i],Y[i]);
		if(dep[X[j]]<dep[Y[j]])swap(X[j],Y[j]);
		for(int x=(dep[X[i]]<dep[X[j]]?X[i]:X[j]);x!=Y[i]&&x!=Y[j];x=X[fi[x]]^Y[fi[x]]^x)
			if(u[x].size()==2){ban=fi[x];break;}
		assert(ban);
		func();
		for(int i=2;i<=n;i++)assert(u[i].size()<=1);
	}else{
		ban=u[0].back();
		int x=X[ban],y=Y[ban],z;
		while(x!=y){
			if(dep[x]<dep[y])swap(x,y);
			u[x].erase(find(u[x].begin(),u[x].end(),ban));
			x=X[fi[x]]^Y[fi[x]]^x;
		}
	}
	for(int i=2;i<=n;i++)assert(u[i].size()<=1);
	int x=X[ban],y=Y[ban],z;
	while(x!=y){
		if(dep[x]<dep[y])swap(x,y);
		x=X[fi[x]]^Y[fi[x]]^x;
	}
	z=x;
	x=X[ban],y=Y[ban];
	while(x!=z){
		if(!u[x].empty()){
			on[u[x].back()]++;
			if(U.empty()||U.back()!=u[x].back())
				U.push_back(u[x].back());
		}else U.push_back(fi[x]);
		x=X[fi[x]]^Y[fi[x]]^x;
	}
	while(y!=z){
		if(!u[y].empty()){
			on[u[y].back()]++;
			if(V.empty()||V.back()!=u[y].back())
				V.push_back(u[y].back());
		}else V.push_back(fi[y]);
		y=X[fi[y]]^Y[fi[y]]^y;
	}
	reverse(V.begin(),V.end());
	for(auto _:V)if(U.empty()||U.back()!=_)U.push_back(_);
	tr[ban]=true,len[ban]=0,U.push_back(ban);
	static int pre[500100],suf[500100];
	pre[0]=1;for(int i=0;i<U.size();i++)
		pre[i+1]=1ll*pre[i]*(len[U[i]]+1)%mod;
	suf[U.size()]=1;for(int i=U.size();i;i--)
		suf[i-1]=1ll*suf[i]*(len[U[i-1]]+1)%mod;
	int pro=1,res=0;
	for(int i=1;i<=m;i++)if(len[i]&&!on[i])
		pro=1ll*pro*(len[i]+1)%mod;
	for(int i=0;i<U.size();i++){
		if(tr[U[i]])res=(1ll*pre[i]*suf[i+1]+res)%mod;
		else res=(1ll*pre[i]*suf[i+1]%mod*on[U[i]]%mod*(len[U[i]]-on[U[i]]+1)+res)%mod;
	}
	printf("%d\n",1ll*pro*res%mod);
	return 0;
}
```



---

## 作者：Purslane (赞：6)

# Solution

广义串并联图。

定义一个广义串并联图为不存在同胚于 $K_4$ 的子图的图，即不存在四个顶点 $u_{1,2,3,4}$ 使得存在一个除顶点外两两不交的六元路径组 $\{u_i \leftrightarrow u_j \mid 1 \le i < j \le 4\}$。

广义串并联图有如下基本性质：

- 它是一个平面图，且 $m \le 2n$；
- 通过删一度点、缩二度点、叠合重边的手段可以把图变成只有一个点。

实际上，在信息学竞赛中常用的是第二种思想，换句话说，我们称这种技巧为“广义串并联图方法”。

如果一个图的规模很大，但 $m-n=k$ 比较小，就可以通过第二种操作大大降低图的规模。显然一次操作后，$m-n$ 不会变大，于是 $m'-n' \le k$。然而 $2m' \ge 3n'$，所以 $m' \le k + n' \le k + \dfrac{2}{3} m'$，$m' \le 3k$、$n' \le 2k$，达成了我们目标的操作。

本题是广义串并联图在计数上的重要应用之一。对于每条边使用 $\rm DP$。

设 $f_{e}$ 表示让 $e$ 这条边出现在最后的生成树中（即 $e$ 的两个端点 $u$ 和 $v$ 是通过 $e$ 对应的结构连接的），$e$ 这条边内部对应的选或不选的方案总数。

$g_e$ 表示不让 $e$ 这条边出现在最后的生成树中，但是要保证那些只有 $e$ 能访问到的节点联通（就是目前与左右端点中恰好一个联通）， $e$ 这条边内部对应选或不选的方案总数。

分析一下三种操作：

- 删除一度点 $e_1$。将 $f_{e_1}$ 直接乘入答案。
- 合并二度点，两边的边分别为 $e_1$、$e_2$，合并后为 $e$。则 $f_e = f_{e_1}f_{e_2}$，$g_e = f_{e_1}g_{e_2} + f_{e_2}g_{e_1}$。
- 叠合重边，将 $e_1$ 和 $e_2$ 叠合为 $e$。则 $f_e = f_{e_1} g_{e_2} + f_{e_2}g_{e_1}$，$g_e = g_{e_1}g_{e_2}$。

剩下只需要模拟三种操作。参考了题解区大佬们的写法。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
#define fi first
#define se second
using namespace std;
const int MAXN=2e5+10,MOD=998244353;
int n,m,ans=1,in[MAXN];
map<int,pair<int,int>> mp[MAXN];
void add_edge(int u,int v,pair<int,int> ad) {
	if(mp[u].count(v)) {
		auto pr=mp[u][v],ans=make_pair((pr.fi*ad.se+pr.se*ad.fi)%MOD,pr.se*ad.se%MOD);
		return mp[u][v]=mp[v][u]=ans,void();
	}
	return mp[u][v]=mp[v][u]=ad,void();
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) {int u,v;cin>>u>>v,add_edge(u,v,{1,1});}
	queue<int> q;
	ffor(i,1,n) if(mp[i].size()<=2) in[i]=1,q.push(i);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		if(mp[u].size()==0) continue ;
		if(mp[u].size()==1) {
			int to=mp[u].begin()->fi; ans=ans*(mp[u].begin()->se.fi)%MOD;
			mp[u].erase(to),mp[to].erase(u);
			if(mp[to].size()<=2&&in[to]==0) in[to]=1,q.push(to);
		}
		else {
			int l=mp[u].begin()->first,r=(++mp[u].begin())->first;
			auto pr1=mp[u].begin()->se,pr2=(++mp[u].begin())->se,ans=make_pair(pr1.first*pr2.first%MOD,(pr1.first*pr2.second+pr1.second*pr2.first)%MOD);
			mp[u].erase(l),mp[u].erase(r),mp[l].erase(u),mp[r].erase(u),add_edge(l,r,ans);
			if(mp[l].size()<=2&&in[l]==0) in[l]=1,q.push(l);
			if(mp[r].size()<=2&&in[r]==0) in[r]=1,q.push(r);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Fuyuki (赞：3)

如果一个点双的生成子图中有度数为 $3$ 的点，那么这个点双一定能表示成一个环上有若干不交的横跨边，没有被任何一条横跨边覆盖的边就是去掉后使得原图是个仙人掌的边。

~~但是出题人把最后一条边潜规则成去掉后剩下的是个仙人掌，找边这部分我就咕了~~

找到这条边之后，将所有生成树分成去掉额外边和不去掉额外边两种情况。

去掉额外边的生成树个数等于所有环的环长之积。

建出圆方树，额外边的两个端点在圆方树上找到的路径包含了所有需要额外处理的点双。这当中有一个点双需要去掉边使不连通，其余的所有环都需要去掉一条边把环断掉。

将一个点双变为不连通有两种情况，如果点双是一条边，那么方案为 $1$，否则找到环在路径上出现的两个节点，这两个节点将环划分成的两部分每部分都要去掉一条边，方案数在知道这两个节点在环上的距离后可以直接计算。

总复杂度为 $O(n)$，我的实现中为了方便用了 map，复杂度达到了 $O(nlogn)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define ll long long int
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)
const int N=5e5+1,mod=998244353;
vector<int>E[N];
int n,m,ans=1,tot,top;
map<int,int>id[N],cnt[N];
int h[N],dep[N],pre[N],tmp[N];
int dfn[N],low[N],sta[N],siz[N];
struct edge{int t,n;}e[N<<1];
I Pow(ll t,int x,ll s=1){
	for(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;
	return s;
}
V cmin(int&x,int y){if(y-x>>31)x=y;}
V add_edge(int x,int y){
	e[++tot]=(edge){y,h[x]},h[x]=tot;
	e[++tot]=(edge){x,h[y]},h[y]=tot;
}
V link(int x,int y){E[x].push_back(y),E[y].push_back(x);}
V input(){
	scanf("%d%d",&n,&m);
	for(int x,y;--m;add_edge(x,y))scanf("%d%d",&x,&y),cnt[x][y]++,cnt[y][x]++;
}
V dfs(int u){
	dfn[u]=low[u]=++tot,sta[++top]=u;
	REP(u)
		if(!dfn[v]){
			if(dfs(v),cmin(low[u],low[v]),low[v]!=dfn[u])continue;
			for(link(u,++n);sta[top+1]!=v;)id[n][sta[top]]=++siz[n],link(n,sta[top--]);
			if((id[n][u]=++siz[n])==2)siz[n]=cnt[u][v];
			ans=1ll*ans*siz[n]%mod;
		}
		else cmin(low[u],dfn[v]);
}
V init(int u){for(int v:E[u])if(v!=pre[u])pre[v]=u,dep[v]=dep[u]+1,init(v);}
V init(){tot=0,dfs(1),init(1);}
I lca(int x,int y){for(;x^y;x=pre[x])if(dep[x]<dep[y])swap(x,y);return x;}
V work(){
	int x,y,v1=ans,v2=0,p,c1,c2,d,l=0,r;
	scanf("%d%d",&x,&y),p=lca(x,y),m=dep[x]+dep[y]-dep[p]*2+1,r=m+1;
	while(x!=p)tmp[++l]=x,x=pre[x];
	while(y!=p)tmp[--r]=y,y=pre[y];
	tmp[++l]=tmp[--r]=p;
	FOR(i,1,m)if(siz[tmp[i]])v1=Pow(siz[tmp[i]],mod-2,v1);
	FOR(i,1,m)if(siz[p=tmp[i]]){
		if(x=tmp[i-1],y=tmp[i+1],siz[p]==1)c1=c2=1;
		else c1=siz[p],c2=abs(id[p][x]-id[p][y]),c2=1ll*c2*(siz[p]-c2)%mod;
		v2=(1ll*v1*c2+1ll*v2*c1)%mod,v1=1ll*v1*c1%mod;
	}
	cout<<(ans+v2)%mod;
}
int main(){
	input();
	init();
	work();
	return 0;
}
```

---

## 作者：Vidoliga (赞：2)

广义串并联图。

可以证明可以通过删 $1$ 度点，将 $2$ 度点两边合并，合并重边这三个操作使得原图被缩成一个单点。

该题要求生成树个数。

考虑 $f_e,g_e$ 表示当前通过上述三种操作目前的 $e$ 这条边选/不选入生成树边的方案数。

分别考虑上述三种操作带来的贡献转移：

1. 删 $1$ 度点

考虑其唯一邻边为 $e$，其必然出现在生成树上，否则该点不可能在生成树内。

直接将答案 $\times f_e$。

2. $2$ 度点两边合并

考虑其两条邻边 $e_1,e_2$，由于该点需要存在在生成树中，故不可能两条边都不选，并且当且仅当两条边都选该合并后的边才存在，设合并成 $e$：

$$f_e=f_{e1}f_{e2}$$

$$g_e=f_{e1}g_{e2}+f_{e2}g_{e1}$$

3. 合并重边

考虑其两边为 $e_1,e_2$，由于不可能两条边都选，并且当且仅当两条边都不选该合并后的边才不存在，设合并成 $e$：

$$f_e=f_{e1}g_{e2}+f_{e2}g_{e1}$$

$$g_e=g_{e1}g_{e2}$$

转移全部线性，删除合并操作可以用 ```map``` 维护，故总复杂度为 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fi first
#define se second
#define MP make_pair
#define pii pair<int,int>
#define pb push_back
using namespace std;
const int N=4e5+20,M=1e6+20,mod=998244353;
inline int add(int x,int y){x+=y;return x>=mod?x-mod:x;}
int n,m,f[N],g[N],deg[N],cnt;
map<int,int> mp[N];
queue<int> q;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1,x,y,p;i<=m;i++){
		cin>>x>>y;
		if(!mp[x][y]) mp[x][y]=mp[y][x]=++cnt,f[cnt]=g[cnt]=1,deg[x]++,deg[y]++;
		else p=mp[x][y],f[p]++;
	}
	for(int i=1;i<=n;i++) if(deg[i]<=2) q.push(i);
	int ans=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		if(!deg[u]) continue;
		else if(deg[u]==1){
			int x=(*mp[u].begin()).fi,a=(*mp[u].begin()).se;
			ans=1ll*ans*f[a]%mod;
			deg[x]--;deg[u]--;mp[x].erase(u),mp[u].erase(x);
			if(deg[x]<=2) q.push(x);
		}
		else{
			int x=(*mp[u].begin()).fi,a=(*mp[u].begin()).se;
			int y=(*mp[u].rbegin()).fi,b=(*mp[u].rbegin()).se;
			int p=mp[x][y];
			mp[x].erase(u),mp[u].erase(x);
			mp[y].erase(u),mp[u].erase(y);
			int F=1ll*f[a]*f[b]%mod,G=add(1ll*f[a]*g[b]%mod,1ll*f[b]*g[a]%mod);
			if(!p) mp[x][y]=mp[y][x]=p=++cnt,deg[x]++,deg[y]++,f[p]=F,g[p]=G;
			else f[p]=add(1ll*f[p]*G%mod,1ll*F*g[p]%mod),g[p]=1ll*g[p]*G%mod;
			deg[x]--,deg[y]--;deg[u]-=2;
			if(deg[x]<=2) q.push(x);
			if(deg[y]<=2) q.push(y);
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：all_for_god (赞：1)

感觉很多题解都说的不是很清楚？如何将三操作与二操作合并起来一起处理好像都没有提到。（也有可能是我太菜了，看了半天才懂）

## 思路

考虑这个图一定是一个广义串并联图。为什么呢？
广义串并联图的定义是不存在一个子图包含四个点且这将四个点之间的路径看作边，这四个点和路径所构成的边构成一个完全图。

显然仙人掌不可能包含一个四个点的完全图，因为四个点的完全图包含了四个有共边的环。
那考虑这个四个点的完全图删去一条边后可不可能是仙人掌。由于删去一条边最多只能删去两个环，仍然有两个环是共边的。
而这里“边”变作路径是同理的，这里不再赘述。
因此仙人掌加上一条边仍然不存在一个四个点的完全子图，也就是这个图是广义串并联图。

然后我们就可以使用广义串并联图的经典操作：删 1 度点，缩 2 度点，叠合重边。
由于最后可以删的只剩一个点，因此考虑 DP 来求总方案数。
设 $f_x$ 表示选边 $x$ 的方案数，$g_x$ 表示不选边 $x$ 的方案数。

由于我们处理的所有点的度数都小于等于 2，因此设当前点为 $top$，与其相连的两个点为 $u,v$，对应的两条边分别为 $x,y$，$u,v$ 之间的边为 $z$。（如果有的话）

1. 删 1 度点
   由于是生成树，每一个点都要包含，因此直接将 $f_x$ 累乘到答案上即可。

2. 缩 2 度点
   现在先假设 $u,v$ 之间没有连边。那我们缩 2 度点就会变成在 $u,v$ 之间新连一条边 $z$。
   由于 $top$ 必须被选，因此有

$$
\begin{aligned}
f_z &= f_xf_y \\
g_z&=f_xg_y+g_xf_y
\end{aligned}
$$

然后在 $u,v$ 之间更新一下边的信息即可。

3. 叠合重边
   因为输入时两个点间如果有多条边，我们可以将 $f$ 直接设为重边的数量，这根据定义是显然的，因此一开始的图中本应没有重边。
   所以有重边的原因时操作二中在 $u,v$ 之间连了一条新边 $z'$，但是有可能 $u,v$ 之间本身就有一条边 $z$，因此我们要将这两条边合并起来。
   由于是生成树，两条边不能都选，但是可以都不选，因此方程式比较显然了：

$$
\begin{aligned}
f_z &= f_zg_{z'}+g_zf_{z'}\\
g_z&=g_zg_{z'}
\end{aligned}
$$

## code

实现的时候用 `map` 来维护边的信息，复杂度阈值在 `map`，$O(n\log n)$。
可以看出来 2 操作与 3 操作是一体的，只有 2 操作过后 3 操作才有可能发生，因此要放在一起处理。
注意细节比较多，需要时刻注意边的细节维护完了没有。我因为在输入的时候没有初始化 $g$ 被卡了半个小时。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N=4e5+7,p=998244353;
int n,m,f[N],g[N],idcnt=0,ans=1,deg[N];
map <int,int> mp[N];
queue <int> q;
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;if(!mp[u][v]) mp[u][v]=mp[v][u]=++idcnt,deg[u]++,deg[v]++,g[idcnt]=1; //注意初始化 
		f[mp[u][v]]++;
	} 
	for(int i=1;i<=n;i++) if(deg[i]<=2) q.push(i);
	while(!q.empty()){
		int top=q.front();q.pop();
		if(deg[top]==0) continue;
		if(deg[top]==1){           //删1度点 
			int u,x;tie(u,x)=*mp[top].begin();
			ans=ans*f[x]%p;mp[u].erase(top);mp[top].erase(u),deg[u]--,deg[top]--;
			if(deg[u]<=2) q.push(u);
		}
		if(deg[top]==2){          //缩2度点 
			int u,v,x,y,z;tie(u,x)=*mp[top].begin();tie(v,y)=*next(mp[top].begin());z=mp[u][v];
			int F,G;F=(f[x]*f[y])%p,G=(f[x]*g[y]+f[y]*g[x])%p;
			if(!z){mp[u][v]=mp[v][u]=++idcnt;f[idcnt]=F,g[idcnt]=G;deg[u]++,deg[v]++;}
			else {f[z]=(f[z]*G+F*g[z])%p;g[z]=g[z]*G%p;}                            // 如果 u，v 间本身就有边，那就需要叠合重边 
			mp[u].erase(top),mp[v].erase(top),mp[top].erase(u),mp[top].erase(v);
			deg[u]--,deg[v]--,deg[top]-=2;
			if(deg[u]<=2) q.push(u);if(deg[v]<=2) q.push(v);
		}
	}
	cout<<ans<<'\n';return 0;
}
```

---

## 作者：strcmp (赞：1)

**$\text{K4}$：** 结点数为 $4$ 的完全图。

**广义串并联图：** 无向图 $G = (V,\,E)$ 如果不存在同胚于 $\text{K4}$ 的子图，那么图 $G$ 是**广义串并联图**。

如果图 $G$ 是广义串并联图，那么 $G$ 有如下性质：

- 删度数为 $1$ 的点、缩掉度数为 $2$ 的点、叠合重边。经过充分多次上述操作可以将图 $G$ 缩为一个点。

换句话说，任意广义串并联图都可以通过逆向的操作，从一个点开始生成出来。

- $|E| \le 2|V|$。

- $G$ 是平面图。

---

回到本题，图 $G = (V,\,E)$ 删掉一条边后是仙人掌。

本题的图 $G$ 是广义串并联图。

因为仙人掌不存在两个拥有公共边的简单环，考虑任意钦定四个点，则它们之间最多有四条路径（否则一定不满足仙人掌的定义），那么就不可能存在加了一条边出现 $\text{K4}$。

如果是广义串并联图，那么就可以靠我们的操作简化。

设 $f_e$ 代表使得边 $e$ 在生成树内的方案数，$g_e$ 代表使 $e$ 不在生成树内的方案数。

- 删除一度点，那么直接将答案乘上对应边的 $f$。

- 缩二度点，考虑 $x \leftrightarrow u \leftrightarrow y$。边 $e_1 : x \leftrightarrow u,\,e_2 : u \leftrightarrow y$。

1. 如果 $x$ 和 $y$ 没有边，那么新产生的边 $e$ 的 $f$ 应该是 $f_{e_1} \times f_{e_2}$（必须联通），$g$ 值应该是 $f_{e_1} \times g_{e_2} + f_{e_2} \times g_{e_1}$（可以一边不在生成树里，但不能两边都不在）。

2. 否则令 $x,\,y$ 的边为 $e_3$。要叠合重边 $e$ 和 $e_3$。考虑类似讨论，$f_{e_3} \gets f_e \times g_{e_3} + f_{e_3} \times g_e$，$g_{e_3} \gets g_e \times g_{e_3}$。

使用 `gp_hash_table` 维护边集，时间复杂度 $\Theta(n + m)$。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
#define mid (l + r >> 1)
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
using pli = pair<ll, int>;
using ump = __gnu_pbds::gp_hash_table<int, int>;
constexpr int maxn = 2e5 + 10, maxm = 4e5 + 10, mod = 998244353;
int q[maxm], hd = 1, tl, tot, n, m; 
ll ans = 1, f[maxm], g[maxm]; ump ed[maxn];
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v; i <= m; i++) {
		scanf("%d%d", &u, &v);
		if (ed[u].find(v) == ed[u].end()) ed[u][v] = ed[v][u] = ++tot, f[tot] = g[tot] = 1;
		else ++f[ed[u][v]];
	}
	rep(i, 1, n) if (ed[i].size() <= 2) q[++tl] = i;
	while (hd <= tl) {
		int u = q[hd++];
		if (ed[u].empty()) continue;
		if (ed[u].size() == 1) {
			auto[v, e] = *ed[u].begin(); 
			ed[u].erase(v), ed[v].erase(u);
			ans = ans * f[e] % mod;
			if (ed[v].size() <= 2) q[++tl] = v;
			continue;
		}
		auto[x, e1] = *ed[u].begin(); ed[u].erase(x), ed[x].erase(u);
		auto[y, e2] = *ed[u].begin(); ed[u].erase(y), ed[y].erase(u); 
		int w = ed[x].find(y) != ed[x].end() ? ed[x][y] : 0;
		ll nf = f[e1] * f[e2] % mod, ng = (f[e1] * g[e2] + f[e2] * g[e1]) % mod;
		if (!w && (w = ++tot)) ed[x][y] = ed[y][x] = w, f[w] = nf, g[w] = ng;
		else f[w] = (f[w] * ng + nf * g[w]) % mod, g[w] = g[w] * ng % mod; 
		(ed[x].size() <= 2) && (q[++tl] = x), (ed[y].size() <= 2) && (q[++tl] = y);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：liaiyang (赞：1)

首先发现这个图是一个广义串并联图。

感性理解一下，一棵仙人掌加上一条边找不到四个点之间存在六条不交的路径，所以这个图是一个广义串并联图。

我们可以对边做 dp，给每一条边赋一个权值 $f_{i,1/0}$ 表示当前这条边选或不选对应的生成树方案数。

我们考虑广义串并联图方法：删一度点，缩二度点，叠合重边。

删一度点时，连接当前点只有一条边，所以这条边必须选，直接将答案乘上 $f_{x,1}$ 即可。

缩二度点时，连接当前点的边有两条，这两条不可能同时不选，缩出来的边被选只能两条边都被选，否则只能选一条边，即 
$$
\begin{aligned}
&f_{x,1}=f_{u,1}\times f_{v,1}\\
&f_{x,0}=f_{u,0}\times f_{v,1}+f_{u,1}\times f_{v,0}
\end{aligned}
$$

叠合重边时，两条边不可能同时选，缩出来的边不被选只能两条边都不被选，否则只能选一条边，即
$$
\begin{aligned}
&f_{x,1}=f_{u,0}\times f_{v,1}+f_{u,1}\times f_{v,0}\\
&f_{x,0}=f_{u,0}\times f_{v,0}
\end{aligned}
$$

拓扑排序即可，删边用 map 维护。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
// #pragma GCC optimize(1)
// #pragma GCC optimize(2)
// #pragma GCC optimize(3)
// #pragma GCC optimize("Ofast")
// #pragma GCC optimize("unroll-loops")
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#define int long long
#define y0 Y0
#define y1 Y1
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
#define P pair<int,int>
#define x first
#define y second
#define modd(x) (((x)%mod+mod)%mod)
#define rd read()
#define lowbit(x) ((x)&(-(x)))
#define abs(x) ((x)<0?-(x):(x))
#define submod(x,y) (((x-=y)<0)&&(x+=mod))
#define addmod(x,y) (((x+=y)>=mod)&&(x-=mod))
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
#define fflush() fwrite(obuf,1,O-obuf,stdout)
char buf[(1<<21)+10],*p1=buf,*p2=buf,obuf[(1<<21)+10],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define putchar(x) (O-obuf<(1<<21)?*O++=(x):(fwrite(obuf,1,1<<21,stdout),O=obuf,*O++=(x)))
inline int read(int u=0, char c=getchar(), bool f=false){
    for(;!isdigit(c);c=getchar()) f|=c=='-';
    for(;isdigit(c);c=getchar()) u=(u<<1)+(u<<3)+(c^'0');
    return f?-u:u;
}
inline void read(string &s,char c=getchar()){
    for(;c<'a'||c>'z';c=getchar());s="";
    for(;c>='a'&&c<='z';c=getchar()) s+=c;
}
inline void wt(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) wt(x/10);
    putchar((x%10)^'0');
}
inline void wt(string s){for(char c:s) putchar(c);}
inline void wt(int x,char k){wt(x),putchar(k);}
const int inf=~0U>>1,linf=~0ULL>>1,iinf=1e18;
const int mod=998244353,g=3,gi=332748118,seed=19260817;
const int N=2e5+10;
map<int,P>mp[N];
int n,m,ans=1;queue<int>q;
void add(int x,int y,P w){
    if(mp[x].count(y)){
        P s=mp[x][y];
        mp[x][y]=mp[y][x]={(s.x*w.y+s.y*w.x)%mod,s.y*w.y%mod};
    }
    else mp[x][y]=mp[y][x]=w;
}
main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    n=rd,m=rd;
    for(int i=1;i<=m;i++){
        int u=rd,v=rd;
        add(u,v,{1,1});
    }
    for(int i=1;i<=n;i++) if(mp[i].size()<=2) q.push(i);
    while(!q.empty()){
        int u=q.front();q.pop();
        if(mp[u].size()==1) ans=ans*(mp[u].begin()->y).x%mod;
        if(mp[u].size()==2){
            int x=mp[u].begin()->x,y=mp[u].rbegin()->x;
            P w1=mp[u].begin()->y,w2=mp[u].rbegin()->y;
            add(x,y,{w1.x*w2.x%mod,(w1.x*w2.y+w1.y*w2.x)%mod});
        }
        for(auto i:mp[u]){
            mp[i.x].erase(u);
            if(mp[i.x].size()<=2) q.push(i.x);
        }
        mp[u].clear();
    }
    wt(ans,'\n');
    return fflush(),0;
}
```

---

## 作者：wwwwwza (赞：0)

手玩一下可以发现，仙人掌图加上一条边没有子图是 $K_4$，所以图 $G$ 是广义串并联图。

广义串并联图三步走：删 $1$ 度点，缩 $2$ 度点，叠重边。

每一条边都存两个变量 $f_e,g_e$，表示这条边在或不在生成树的方案。

- 删 $1$ 度点。

答案直接乘上 $f_e$，因为这条边一定要加上，否则生成树不连通。

- 缩 $2$ 度点。

设两条边分别为 $a,b$。
1. 这条边在生成树上，则组成这条边的边 $a,b$ 都要在生成树上（这么说有点不严谨，仅供理解），$f_e=f_a\times f_b$。
2. 这两条不能同时不在生成树上，否则生成树不连通，$g_e=f_a\times g_b+f_b\times g_a$。

- 叠重边。

设两条边分别为 $a,b$。
1. 因为这两条边不能同时存在，原本的边存在的方案乘新边不存在的方案加原边不存在新边存在的方案，$f_e=f_e\times(f_a\times g_b+f_b\times g_a)+g_e\times(f_a\times f_b)$。
2. 新边和原边都不存在，$g_e=g_e\times(f_a\times g_b+f_b\times g_a)$。

因为是广义串并联图，所以每个点总能遍历到，最后直接输出方案即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+5;
const int mod=998244353;
int n,m,x,y,ans=1;
bool vis[N];
int get(int x,int y){
	if(x>y)swap(x,y);
	return (x-1)*n+y;
}
struct node{
	int f,g;
};
struct edge{
	int u,v;
	node w;
}e[N];
map<int,int>mp;
set<int>g[N];
queue<int>q;
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		e[i]={x,y,{0,0}};
		if(!mp[get(x,y)]){
			e[mp[get(x,y)]=i].w.g=1;
			g[x].insert(i);
			g[y].insert(i);
		}
		e[mp[get(x,y)]].w.f++;
	}
	for(int i=1;i<=n;i++){
		if(g[i].size()<=2)q.push(i);
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		if(g[u].empty()||vis[u])continue;
		vis[u]=1;
		if(g[u].size()==1){
			int _i=*g[u].begin();
			edge i=e[_i];
			if(i.u!=u)swap(i.u,i.v);
			ans=ans*i.w.f%mod;
			g[i.v].erase(_i);
			if(g[i.v].size()<=2)q.push(i.v);
		}else{
			set<int>::iterator it=g[u].begin();
			int _i=*it;it++;
			int _j=*it;
			edge i=e[_i],j=e[_j];
			if(i.u!=u)swap(i.u,i.v);
			if(j.u!=u)swap(j.u,j.v);
			int pos=mp[get(i.v,j.v)];
			int F=i.w.f*j.w.f%mod,G=(i.w.f*j.w.g%mod+i.w.g*j.w.f%mod)%mod;
			if(pos){
				e[pos].w.f=(e[pos].w.f*G%mod+e[pos].w.g*F%mod)%mod;
				e[pos].w.g=e[pos].w.g*G%mod;
			}else{
				node p={F,G};
				e[++m]={i.v,j.v,p};
				mp[get(i.v,j.v)]=m;
				g[i.v].insert(m);
				g[j.v].insert(m);
			}
			g[i.v].erase(_i);
			g[j.v].erase(_j);
			if(g[i.v].size()<=2)q.push(i.v);
			if(g[j.v].size()<=2)q.push(j.v);
		}
	}
	printf("%lld",ans%mod);
	return 0;
}

```

---

## 作者：TernaryTree (赞：0)

广义串并联图。

给每条边两个值 $f_e,g_e$，$f_e$ 表示在最小生成树中，这条边的两端通过这条边连通起来的方案数，$g_e$ 表示在最小生成树中，这条边的两端不通过这条边连通起来的方案数。

考虑广义串并联图的三种操作。

- 去除一个度数为 $1$ 的点

  显然，这个点只能通过这条唯一的出边出去与生成树连通，所以这条边必选，令 $ans\gets ans\times f_e$。
  
- 将一个度数为 $2$ 的点的两端合并，并且去掉自己（串联）

  原来 $(u,v_1)$ 和 $(u,v_2)$ 的两条边记作 $e_1$ 和 $e_2$，将 $(v_1,v_2)$ 合并起来连的新边记作 $e'$。则有：
  
  $$\begin{aligned}f_{e'}&=f_{e_1}\cdot f_{e_2}\\g_{e'}&=f_{e_1}\cdot g_{e_2}+g_{e_1}\cdot f_{e_2}\end{aligned}$$
  
- 合并两条重边（并联）

  将两条重边记为 $e_1,e_2$，合并后的新边记为 $e'$。则有：
  
  $$\begin{aligned}f_{e'}&=f_{e_1}\cdot g_{e_2}+g_{e_1}\cdot f_{e_2}\\g_{e'}&=g_{e_1}\cdot g_{e_2}\end{aligned}$$
  
由广义串并联图性质我们得到，最后一定只剩下一个点。此时的 $ans$ 即为答案。

用类似拓扑的东西去做一下就行了。删边/加边使用 `unordered_map<int, unordered_map<int, pair<int, int>>>` 这样的邪恶东西维护，实际上是支持遍历一个点出边的邻接矩阵。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fs first
#define sc second
#define umap unordered_map
//#define cin fin
//#define cout fout

using namespace std;

struct ios {
    inline char read() {
        static const int inlen = 1 << 18 | 1;
        static char buf[inlen], *s, *t;
        return (s == t) && (t = (s = buf) + fread(buf, 1, inlen, stdin)), s == t ? -1 : *s++;
    }
    template<typename T> inline ios& operator>> (T &x) {
        static char c11, boo;
        for (c11 = read(), boo = 0; !isdigit(c11); c11 = read()) {
            if (c11 == -1) return *this;
            boo |= c11 == '-';
        }
        for (x = 0; isdigit(c11); c11 = read()) x = x * 10 + (c11 ^ '0');
        boo && (x = -x);
        return *this;
    }
} fin;

struct exios {
    template<typename _CharT, typename _Traits = char_traits<_CharT>>
    struct typ {
        typedef basic_ostream<_CharT, _Traits>& (* end) (basic_ostream<_CharT, _Traits>&);
    };

    template<typename T> friend exios &operator<<(exios &out, T num) {
        if (num < 0) putchar('-'), num = -num;
        if (num >= 10) out << num / 10;
        putchar(num % 10 + '0');
        return out;
    }

    friend exios &operator<<(exios &out, const char * s) { printf("%s", s); return out; }
    friend exios &operator<<(exios &out, string s) { cout << s; return out; }
    friend exios &operator<<(exios &out, typ<char>::end e) { puts(""); return out; }
} fout;

typedef pair<int, int> pii;
const int maxn = 1e6 + 10;
const int mod = 998244353;

int n, m, ans = 1;
umap<int, umap<int, pii>> g;
int deg[maxn];
queue<int> q;

void add_edge(int u, int v, pii w) {
	if (g.find(u) != g.end() && g[u].find(v) != g[u].end()) {
		pii nw = {(w.fs * g[u][v].sc % mod + w.sc * g[u][v].fs % mod) % mod, w.sc * g[u][v].sc % mod};
		deg[u]--;
		g[u][v] = nw;
	} else if (g.find(u) != g.end()) {
		g[u][v] = w;
	} else {
		g[u] = umap<int, pii> ();
		g[u][v] = w;
	}
}

signed main() {
	cin >> n >> m;
	for (int i = 1, u, v; i <= m; i++) {
		cin >> u >> v;
		add_edge(u, v, {1, 1});
		add_edge(v, u, {1, 1});
		++deg[u], ++deg[v];
	}
	for (int i = 1; i <= n; i++) if (deg[i] <= 2) q.push(i);
	while (!q.empty()) {
		int u = q.front(), dg = deg[u];
		q.pop();
		if (!dg) continue;
		if (dg == 1) {
			pair<int, pii> nxt = *g[u].begin();
			int v = nxt.fs;
			pii w = nxt.sc;
			g[u].erase(v);
			g[v].erase(u);
			ans = ans * w.fs % mod;
			deg[u]--, deg[v]--;
			if (deg[v] <= 2) q.push(v);
		} else if (dg == 2) {
			pair<int, pii> nxt[2] = {};
			int v[2] = {};
			pii w[2] = {};
			int cnt = 0;
			for (auto it : g[u]) {
				nxt[cnt] = it;
				v[cnt] = it.fs;
				w[cnt] = it.sc;
				g[v[cnt]].erase(u);
				cnt++;
			}
			g[u].clear();
			add_edge(v[0], v[1], {w[0].fs * w[1].fs % mod, (w[0].fs * w[1].sc % mod + w[1].fs * w[0].sc % mod) % mod});
			add_edge(v[1], v[0], {w[0].fs * w[1].fs % mod, (w[0].fs * w[1].sc % mod + w[1].fs * w[0].sc % mod) % mod});
			if (deg[v[0]] <= 2) q.push(v[0]);
			if (deg[v[1]] <= 2) q.push(v[1]);
		}
	}
	cout << ans << endl;
	return 0;
}

```

---


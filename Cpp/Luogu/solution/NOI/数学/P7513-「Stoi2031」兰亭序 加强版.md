# 「Stoi2031」兰亭序 加强版

## 题目背景

本题是[「Stoi2031」兰亭序](https://www.luogu.com.cn/problem/P7487) 的加强版。

## 题目描述

给定 $n=a^b,k$，对 $1 \le t \le k$ 求

$$\prod_{x_1=1}^{n}\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right) \bmod{335544323}$$

输出所有 $k$ 个答案的异或和。

其中 $e^{it}=\cos{t}+i\sin{t}$ 对所有 $t \in \mathbb{R}$ 成立，$i$ 为虚数单位，满足 $i^2=-1$。

## 说明/提示

对于所有数据，$1 \le a \le 10^{18}$，$1 \le b \le 10^{13}$，$1 \le k \le 10^5$。

## 样例 #1

### 输入

```
15 1 2
```

### 输出

```
201012023
```

## 样例 #2

### 输入

```
1 7 3
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3 2 3
```

### 输出

```
301162058
```

## 样例 #4

### 输入

```
4 2 2
```

### 输出

```
0
```

## 样例 #5

### 输入

```
19260817 114514 13579
```

### 输出

```
461194421
```

# 题解

## 作者：Argon_Cube (赞：15)

巨大推式子题又何尝不是一种数学大模拟呢。

来一个不一样的，应该简单一些的做法。

---

首先 $x^n-1=\prod_{0\leq i<n}(x-\omega_n^i)$，代入 $x=-1$ 就得到

$$\prod_{i=0}^{n-1}(1+\omega_n^i)=1-(-1)^n=2[2\nmid n]$$

所以首先 $2|n$ 时输出 $0$。否则直接展开最后一层：

$$\prod_{0\leq x_1,\cdots,x_{t-1}<n}2^{\gcd\left(\prod_{0<i<t}x_i,n\right)}$$

相当于是要对 $0\leq m<k$ 求

$$f(n,m)=\sum_{0\leq x_1,\cdots,x_{m}<n}\gcd\left(\prod_{1\leq i\leq m}x_i,n\right)\mod 335544322$$

发现 $335544322=2\times 167772161$，后面的是知名 NTT 模数，前面那个 $2$ 我们到时候再处理。显然 $f(n,0)=1$，以下我们默认 $m>0$ 不然会很麻烦。

显然这个式子就是 ABC245Ex，所以直接把那题方法套过来，首先跟 ABC245Ex 一样 $f(n,m)$ 是积性的，也就是说如果 $\gcd(a,b)=1$ 则 $f(ab,m)=f(a,m)f(b,m)$，证明就直接 CRT，所以我们直接把 $a$ 用 Pollard-Rho 质因数分解一下就只用考虑怎么计算 $f(p^n,m)$ 就行了。

算 $f(p^n,m)$ 就是枚举一下 $0\leq i<n$ 算出 $\gcd(\prod x,p^n)=p^i$ 有几种情况，剩下的就是 $\gcd(\prod x,p^n)=p^n$ 的方案数。计算 $\gcd(\prod x,p^n)=p^i$ 的方案数也和 ABC245Ex 一样，先让每个位置随便取与 $p$ 互质的数，然后把这 $i$ 个 $p$ 分到某些位置上，某个位置多分到一个 $p$ 这个地方取数的方案数就要除以 $p$，这样如果数组长为 $m$ 方案数就是 $\binom{m-1+i}{i}(p-1)^mp^{m(n-1)-i}$。

所以最后我们得到 $f(p^n,m)$ 是这坨东西：

$$f(p^n,m)=p^{n(m+1)}+\binom{m+n-1}{m}(p-1)^mp^{m(n-1)}-(p-1)^mp^{n+m(n-1)}\sum_{i=0}^{n-1}\binom{m-1+i}{i}p^{-i}$$

第一项是总方案数乘上 $p^n$，第三项是算有多少种方案 $\gcd\neq p^n$，它们的贡献在第一项里被算成了 $p^n$ 要减掉，第二项是 $\gcd\neq p^n$ 的方案的贡献。

发现 $f(p^n,m)$ 一定是个奇数，所以模 $2$ 的结果算出来了！这样我们只需要解决 $p_{mod}=167772161$ 就可以合并了，具体来说结果是偶数就加上一个 $167772161$ 即可。

现在要先讨论 $p\bmod p_{mod}$ 为 $0$ 或 $1$ 的情况，因为我们以后要算 $p^{-1}$ 和 $(p-1)^{-1}$，如果出现了这种情况那么 $f(p^n,m)\equiv p\pmod{p_{mod}}$。

现在已经能过原版了，要解决加强版要快速算后面那个和式：

$$g_m=\sum_{i=0}^{n-1}\binom{m-1+i}{i}p^{-i}$$

直接把中间那个二项式用加法公式拆了解出 $g_{m+1}$ 就可以得到

$$g_{m+1}=\frac{p}{p-1}\left(g_m-\binom{m+n-1}{m}p^{-n}\right)$$

发现这个东西可以直接线性递推就做完了，复杂度 $\Omicron(\sqrt[4]a+(k\log(bkp_{mod}))\omega(a)+k\log p_{mod})$。

---

## 作者：VinstaG173 (赞：14)

推式子。

首先 $n$ 为偶数时 $1+e^{\frac{2\pi i\cdot (\frac{n}{2})\cdot (1)^{t-1}}{n}}=0$，故答案为 $0$。

下面看 $n$ 为奇数。考虑取 $\log$ 将乘积转化成求和，打些小数据~~从样例 1 猜结论~~发现答案基本都是 $2$ 的幂。令 $f(n,t)=\log_2\left(\prod_{x_1=1}^{n}\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right)\right)$。

设 $\omega=e^{\frac{2\pi i}{n}}$。首先有 $\prod\limits_{x=1}^{n}\left( u-\omega^x \right)=u^n-1$， $\prod\limits_{x=1}^{n}\left( 1+e^{\frac{2\pi ix}{n}} \right)=(-1)^n\cdot((-1)^n-1)=2=2^1$。故 $f(n,1)=1$。

其他时候我们考虑处理 $x_1$，当 $\gcd(x_1,n)=d,x_1=dy,n=dm$ 时，

$$\begin{aligned}
\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right)&=\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi iyx_2\dots x_t}{m}} \right)\\
&=\left(\prod_{x_2=1}^{m}\dots\prod_{x_t=1}^{m}\left( 1+e^{\frac{2\pi ix_2\dots x_t}{m}} \right)\right)^{d^{t-1}}\\
&=2^{d^{t-1}f(m,t-1)},
\end{aligned}$$

故（$d=\gcd(x,n),m=\dfrac{n}{d}$，下同）

$$\begin{aligned}
f(n,t)&=\sum_{x=1}^{n}d^{t-1}f(m,t-1)\\
&=\sum_{d|n}\sum_{\gcd(x,n)=d}d^{t-1}f(m,t-1)\\
&=\sum_{d|n}\varphi(m)d^{t-1}f(m,t-1),
\end{aligned}$$

显然当 $f(n,t-1)$ 积性时 $f(n,t)$ 也积性。

那么就只要对 $n$ 分解质因子，求出每个 $f(p^v,t)$。

代入上式计算得

$$f(p^v,t)=\dfrac{(v+t-1)!p^{(t-1)v}}{(v-1)!}\sum_{j=0}^{t-1}\dfrac{(-1)^j}{j!(t-j-1)!(v+j)}p^{-j}.$$

证明：

先将式子表示为

$$\dfrac{(v+t-1)!}{(v-1)!(t-1)!}\sum_{j=0}^{t-1}\dfrac{(-1)^j\binom{t-1}{j}}{v+j}p^{(t-1)v-j}$$

考虑归纳。显然 $f(p^v,t+1)$ 中只有 $p^{tv-t}$ 到 $p^{tv}$ 系数不为 $0$。考虑计算 $f(p^v,t+1)$ 中 $p^{tv-j}$ 的系数。

首先处理掉一头一尾。$p^{tv}$ 的系数为

$$\begin{aligned}
[p^{tv}]f(p^v,t+1)&=\sum_{u=0}^v[p^{(t-1)(v-u)}]f(p^{v-u},t)\\
&=\sum_{u=0}^{v}\binom{v-u+t-1}{v-u}\\
&=\sum_{u=0}^{v}\binom{u+t-1}{u}\\
&=\binom{v+t}{v},
\end{aligned}$$

这个可以归纳。

类似的，$p^{t(v-1)}$ 的系数为

$$\begin{aligned}
[p^{t(v-1)}]f(p^v,t+1)&=(-1)^{t}\sum_{u=0}^{v-1}[p^{(t-1)(v-u-1)}]f(p^{v-u},t)\\
&=(-1)^t\sum_{u=0}^{v-1}\binom{v-u+t-2}{v-u}\\
&=(-1)^t\sum_{u=0}^{v-1}\binom{u+t-2}{u}\\
&=(-1)^t\binom{v+t-1}{v}.
\end{aligned}$$

然后处理中间的项。下面设 $1 \le j \le t-1$。第三到第四行对 $\sum$ 里的每一项化简，显然用 $u$ 代替 $v-u$ 式子不变。

$$\begin{aligned}[p^{tv-j}]f(p^v,t+1)&=\sum_{u=0}^{v-1}\left([p^{(t-1)(v-u)-j}]f(p^{v-u},t)-[p^{(t-1)(v-u)-j+1}]f(p^{v-u},t)\right)\\
&=[p^{(t-1)v-j}]f(p^v,t)-[p^{t-1-j}]f(p,t)+\sum_{u=1}^{v-1}\left([p^{(t-1)(v-u)-j}]f(p^{v-u},t)-[p^{(t-1)(v-u+1)-j+1}]f(p^{v-u+1},t)\right)\\
&=\dfrac{(v+t-1)!}{(t-1)!(v-1)!}\cdot\dfrac{(-1)^j\binom{t-1}{j}}{v+j}+\dfrac{t!}{(t-1)!0!}\cdot\dfrac{(-1)^{j}\binom{t-1}{j-1}}{j}+\sum_{u=1}^{v-1}\left(\dfrac{(v-u+t-1)!}{(t-1)!(v-u-1)!}\cdot\dfrac{(-1)^j\binom{t-1}{j}}{v-u+j}+\dfrac{(v-u+t)!}{(t-1)!(v-u)!}\cdot\dfrac{(-1)^j\binom{t-1}{j-1}}{v-u+j}\right)\\
&=\binom{u+t-1}{u}\cdot\dfrac{(-1)^j}{u+j}\cdot\left((u+t)\binom{t-1}{j-1}+u\binom{t-1}{j}\right)\\
&=\binom{u+t-1}{u}\cdot\dfrac{(-1)^j}{u+j}\cdot(t-1)!\cdot\dfrac{(u+t)j+(t-j)u}{(t-j)!j!}\\
&=(-1)^j\binom{t}{j}\binom{u+t-1}{u}.
\end{aligned}$$

又

$$\dfrac{(v+t-1)!}{(t-1)!(v-1)!}\cdot\dfrac{(-1)^j\binom{t-1}{j}}{v+j}=\dfrac{(-1)^j(t-j)}{v+j}\binom{t}{j}\binom{v+t-1}{v-1},$$

$$\dfrac{t!}{(t-1)!0!}\cdot\dfrac{(-1)^j\binom{t-1}{j-1}}{j}=(-1)^j\binom{t}{j}\binom{t-1}{0}.$$

因此

$$\begin{aligned}
&\ \ \ \ \ \dfrac{(v+t-1)!}{(t-1)!(v-1)!}\cdot\dfrac{(-1)^j\binom{t-1}{j}}{v+j}+\dfrac{t!}{(t-1)!0!}\cdot\dfrac{(-1)^{j}\binom{t-1}{j-1}}{j}+\sum_{u=1}^{v-1}\left(\dfrac{(v-u+t-1)!}{(t-1)!(v-u-1)!}\cdot\dfrac{(-1)^j\binom{t-1}{j}}{v-u+j}+\dfrac{(v-u+t)!}{(t-1)!(v-u)!}\cdot\dfrac{(-1)^j\binom{t-1}{j-1}}{v-u+j}\right)\\
&=(-1)^j\binom{t}{j}\left(\dfrac{t-j}{v+j}\binom{v+t-1}{v-1}+\sum_{u=0}^{v-1}\binom{u+t-1}{u}\right)\\
&=(-1)^j\binom{t}{j}\binom{v+t-1}{v-1}\left(\dfrac{t-1}{v+j}+1\right)\\
&=\dfrac{(v+t)!}{t!(v-1)!}\cdot\dfrac{(-1)^j\binom{t}{j}}{v+j}.
\end{aligned}$$

证毕。

考虑处理这个式子。显然可以卷积后再依次乘上前面的东西。

用费马小定理求解，$335544323-1=335544322=2 \times 167772161$，$167772161$ 是 NTT 模数，又由递推式容易知道 $f(n,t)$ 为奇数（只需注意到 $\varphi(n)$ 只有在 $n=1,2$ 时为奇数），直接 CRT 合并即可（其实就是偶数给它加上个 $167772161$）。

时间复杂度 $O(a^{\frac{1}{4}}+k\log{k}\log{a})$。

Code:
```cpp
#include<map>
#include<ctime>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define rg register
#define LL __int128
#define ll long long
#define mabs(a,b) (a>b?a-b:b-a)
using std::map;
using std::reverse;
const int NtF=335544323;
const int Ntf=335544322;
const int ntf=167772161;
inline ll qpw(ll x,ll v,ll NTF)
{
	ll r=1;
	while(v)
	{
		(v&1)&&(r=(LL)r*x%NTF);
		x=(LL)x*x%NTF,v>>=1;
	}
	return r;
}
inline ll _gcd(ll a,ll b)
{
	while(b^=a^=b^=a%=b);return a;
}
inline bool witness(ll a,ll n)
{
	ll t=n-1;
	while(t)
	{
		ll x=qpw(a,t,n);
		if(x!=1&&x!=n-1)return false;
		if((t&1)||x==n-1)return true;
		t>>=1;
	}
}
inline bool MR(ll n)
{
	if(n==1)return 0;
	if(n==2||n==3)return 1;
	if(n%6!=1&&n%6!=5)return 0;
	if(n==46856248255981ll)return 0;
	if(n==7||n==61||n==24251)return 1;
	return (witness(2,n)&&witness(61,n));
}
inline ll fnc(ll x,ll c,ll ntf)
{
	return ((LL)x*x+c)%ntf;
}
inline ll PR(ll n)
{
	ll x=0,y=0,v=1,c=rand()%(n-1)+1;
	for(rg int m=1;;m<<=1,x=y,v=1)
	{
		for(rg int s=0;s<m;++s)
		{
			y=fnc(y,c,n);
			v=(LL)v*mabs(x,y)%n;
			if(!(s%127))
			{
				ll d=_gcd(v,n);
				if(d>1)return d;
			}
		}
		ll d=_gcd(v,n);
		if(d>1)return d;
	}
}
map<ll,int>_exp;
inline void solve(ll n)
{
	if(n<2)return;
	if(MR(n))
	{
		(_exp.count(n))?++_exp[n]:_exp[n]=1;
		return;
	}
	ll p=n;
	while(p==n)p=PR(p);
	solve(n/p),solve(p);
}
ll prr[300007];
int rev[300007];
inline void init(int lim,int l)
{
	for(rg int i=0;i<lim;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	ll w;
	for(rg int i=1,b=1;i<lim;i<<=1,++b)
	{
		prr[i]=1;
		w=qpw(3,(ntf-1)>>b,ntf);
		for(rg int j=1;j<i;++j)prr[i+j]=prr[i+j-1]*w%ntf;
	}
}
inline void NTT(ll *a,int lim,int opt)
{
	for(rg int i=0;i<lim;++i)if(i<rev[i])a[i]^=a[rev[i]]^=a[i]^=a[rev[i]];
	for(rg int i=1;i<lim;i<<=1)
    {
    	for(rg int j=0;j<lim;j+=(i<<1))
    	{
    		for(rg int k=0;k<i;++k)
    		{
    			ll tx=a[i|j|k]*prr[i|k]%ntf;
				a[i|j|k]=(a[j|k]-tx+ntf)%ntf,a[j|k]=(a[j|k]+tx)%ntf;
			}
		}
	}
	if(opt)return;
	reverse(a+1,a+lim);
	ll x=qpw(lim,ntf-2,ntf);
	for(rg int i=0;i<lim;++i)a[i]=a[i]*x%ntf;
}
ll n,v,res;
int k,lim,l;
ll fac[300007];
ll fic[300007];
ll ans[300007];
ll f[300007],g[300007];
int main()
{
	scanf(" %lld %lld %d",&n,&v,&k);
	if(!(n&1))
	{
		puts("0");
		return 0;
	}
	solve(n);v%=ntf;
	for(rg int i=1;i<=k;++i)ans[i]=1;
	lim=1,l=0;
	while(lim<=(k<<1))lim<<=1,++l;
	init(lim,l);
	fac[0]=1;
	for(rg int i=1;i<=k;++i)fac[i]=fac[i-1]*i%ntf;
	fic[k]=qpw(fac[k],ntf-2,ntf);
	for(rg int i=k;i;--i)fic[i-1]=fic[i]*i%ntf;
	for(auto ex:_exp)
	{
		ll prm=ex.first%ntf;
		ll tim=ex.second*v%ntf;
		for(rg int i=0;i<k;++i)
		{
			f[i]=fic[i]*qpw(i+tim,ntf-2,ntf)%ntf*qpw(prm,ntf-1-i,ntf)%ntf;
			g[i]=fic[i];((i&1)&&(f[i]))&&(f[i]=ntf-f[i]);
		}
		for(rg int i=k;i<lim;++i)f[i]=g[i]=0;
		NTT(f,lim,1);NTT(g,lim,1);
		for(rg int i=0;i<lim;++i)f[i]=f[i]*g[i]%ntf;
		NTT(f,lim,0);
		ll t1=tim,t2=tim,t3=qpw(prm,tim,ntf),t4=1;
		for(rg int i=0;i<k;++i,++t1,t2=t2*t1%ntf,t4=t4*t3%ntf)f[i]=f[i]*t2%ntf*t4%ntf;
		for(rg int i=0;i<k;++i)ans[i+1]=(ans[i+1]*f[i])%ntf;
	}
	for(rg int i=1;i<=k;++i)(!(ans[i]&1))&&(ans[i]+=ntf),res^=qpw(2,ans[i],NtF);
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：NaCly_Fish (赞：11)

update：已补充完整证明。

本题解提供了一种 $\Theta(\sqrt[4]{a}+\sqrt p+k\omega(a))$（其中 $\omega(a)$ 表示 $a$ 的质因子个数）的整式递推做法，显著优于 std。

至于其中的 $\sqrt p$ 是因为要做到以 $\Theta(k)$ 的时间复杂度计算 $k$ 个同底的快速幂，需要预处理。

为了大家看的方便，这里试着尽量把式子完整推一遍。
****
根据单位根的基本性质
$$\prod_{i=1}^{n}(x-\omega_n^i)=x^n-1$$
代入 $x=-1$ 就得到
$$\prod_{i=1}^n(1+\omega_n^i)=(-1)^n((-1)^n-1) = 2\times(n\bmod 2)$$
由于连乘中只要有一项为零，答案就是零，所以 $n$ 为偶数时答案就是零。

若 $n$ 为奇数，设答案
$$f(n,t)=
\prod_{x_1=1}^n\prod_{x_2=1}^n\cdots\prod_{x_t=1}^n\left( 1+\exp \left( \frac{2\pi \text i}{n}\prod_{i=1}^t x_i\right) \right)$$
而 $g(n,t)=\log_2f(n,t)$。

考虑递推，把 $\exp$ 中乘积的 $x_1$ 提出来，设 $d=\gcd(x_1,n)$ 这样就能约分：

$$f(n,t)=\prod_{x_1=1}^n\prod_{x_2=1}^n\cdots\prod_{x_t=1}^n\left( 1+\exp \left( \frac{2\pi \text i x_1/d}{n/d}\prod_{i=2}^t x_i\right) \right)$$
根据单位根的另一个性质，当 $n,k$ 互质时有：
$$\prod_{i=0}^{n-1}(x-\omega_n^{ki})=\prod_{i=0}^{n-1}(x-\omega_n^i)=x^n-1$$
这是因为 $ki\bmod n \ (i\in[0,n-1])$ 可以取遍所有 $[0,n-1]$ 的整数。  

根据这个性质，前面式子中的 $x_1/d$ 就可以直接去掉，对答案没有影响。
$$f(n,t)= \prod_{x_1=1}^n\prod_{x_2=1}^n\cdots\prod_{x_t=1}^n\left( 1+\exp \left( \frac{2\pi \text i }{n/d}\prod_{i=2}^t x_i\right) \right)$$
$$=\prod_{x_1=1}^{n}\left(\prod_{x_2=1}^{n/d}\cdots\prod_{x_t=1}^{n/d}\left( 1+\exp \left( \frac{2\pi \text i }{n/d}\prod_{i=2}^t x_i\right) \right)\right)^{d^{t-1}}$$
$$=\prod_{x_1=1}^nf(n/d,t-1)^{d^{t-1}}$$
也即
$$g(n,t)=\sum_{i=1}^n g\left(\frac{n}{\gcd(n,i)},t-1\right)\gcd(n,i)^{t-1}$$
$$=\sum_{d|n}g\left(\frac{n}{d},t-1\right)d^{t-1}\sum_{i=1}^n [\gcd(n,i)=d]$$
$$=\sum_{d|n} g( d,t-1)\varphi(d)\left(\frac nd \right)^{t-1}$$
根据最开始的推论，我们知道 $g(n,1)=1$，关于 $n$ 是积性函数，故 $g(n,t)$ 关于 $n$ 也是积性函数，只需对输入的 $a$ 质因数分解，计算 $g(p^m,t)$ 的值即可。

$$g(p^m,t)=\sum_{i=0}^{m}g(p^i,t-1)\varphi(p^i)p^{(m-i)(t-1)}$$
不要忘了 $\varphi(p^k)=(p-1)p^{k-1}$ 仅在 $k\geq 1$ 时成立。
$$g(p^m,t)= p^{(t-1)m-1}+\frac{p-1}{p}\sum_{i=0}^m g(p^i,t-1)p^i\times p^{(t-1)(m-i)}$$
~~关于答案的式子个人没想到比较简洁的证法，暂时把原题解的搬过来，到时候再补~~  
完整证明已经出炉，速戳 $\to$ [Link](https://www.luogu.com.cn/blog/NaCly-Fish-blog/P7513-prove) $\leftarrow$

$$g(p^m,t)= \frac{m^{\overline t}p^{(t-1)m}}{(t-1)!}\sum_{j=0}^{t-1} \binom {t-1}{j} \frac{(-p^{-1})^j}{m+j}$$
注意到这个和式实际上是一个二项卷积，抛开看到卷积就用 FFT 处理的思维定势，我们可以考虑下面这个式子如何递推计算，原问题就能迎刃而解：
$$a_n=\sum_{i=0}^{n} \binom {n}i \frac{q^i}{m+i}$$
设 $\mathcal A(x)$ 为 $\{ a_n\}_{n=0}^{\infty}$ 的 EGF，$\mathcal H(x)$ 为 $\left\{ \dfrac{q^n}{m+n} \right\}_{n=0}^\infty$ 的 EGF，就有
$$\mathcal A(x) = \text e^x\mathcal H(x)$$
根据一点整式递推的知识，$\mathcal H(x)$ 的系数可以整式递推，$\text e^x$ 的系数显然也可以整式递推，所以 $\mathcal A(x)$ 的系数也可以整式递推。

进一步地，我们知道
$$(m+n)h_n=q^n$$
将其用微分方程表示，注意 EGF 中的第 $n$ 项都要除以 $n!$。
$$m \frac{h_n}{n!}+\frac{h_n}{(n-1)!}=\frac{q^n}{n!}$$
$$m\mathcal H(x)+x\mathcal H'(x)=\text e^{qx}$$
代入 $\mathcal A(x)$ 的计算式：
$$\mathcal A'(x) =\text e^x(\mathcal H(x)+\mathcal H'(x))$$
$$\mathcal A'(x) =\mathcal A(x)+\text e^x\mathcal H'(x)$$
$$\mathcal x\mathcal A'(x)=x\mathcal A(x)+\text e^x\left( \text e^{qx}-m\mathcal H(x)\right)$$
$$x\mathcal A'(x)=(x-m)\mathcal A(x)+\text e^{(q+1)x}$$
推到这一步就可以直接提系数了：
$$na_n=na_{n-1}-ma_n+ (q+1)^n$$
直接做就能以 $\Theta(n)$ 的时间复杂度求出前 $n$ 项。
****
最后就是细节部分，求 $g(n,t)$ 需要对 $335544322$ 取模，做 CRT 化为对 $2$ 和另一个大质数取模。

由 $g(n,t)$ 的初始递推式知道答案一定是奇数，在模 $2$ 下可以直接出结果。  
最后别忘了分解 $a$ 的质因数还需要 Pollard-Rho。

参考代码：
（感谢 [LinearODE](https://www.luogu.com.cn/user/134757) 提供的 pollard-rho 模板）
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<ctime>
#define ll long long
#define reg register
#define N 200003
#define p 167772161
#define md 335544323
#define i128 __int128_t
using namespace std;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

ll gcd(ll a,ll b){ return b==0?a:gcd(b,a%b); }

inline ll poww(ll a,ll t,ll m){
    ll res = 1;
    while(t){
        if(t&1) res = (i128)res*a%m;
        a = (i128)a*a%m;
        t >>= 1;
    }
    return res;
}

inline bool miller_rabin(ll x,ll b){
    ll k = x-1;
    while(k){
        ll cur = poww(b,k,x);
        if(cur!=1&&cur!=x-1) return false;
        if((k&1)||cur==x-1) return true;
        k >>= 1;
    }
    return true;
}

inline bool prime(ll x){
    if(x==46856248255981ll||x<2) return false;
    if(x==2||x==3||x==7||x==61||x==24251) return true;
    return miller_rabin(x,2)&&miller_rabin(x,61);
}

inline ll pollard_rho(ll x){ // 由于我不会 pr,这段是蒯来的板子
    ll s = 0,t = 0,c = (rand()*rand()+rand())%(x-1)+1;
    for(int goal=1;;goal<<=1,s=t){
        ll val = 1;
        for(int stp=1;stp<=goal;++stp){
            t = ((i128)t*t+c)%x;
            val = (i128)val*abs(t-s)%x;
            if(stp%127==0){
                ll d = gcd(val,x);
                if(d>1) return d;
            }
        }
        ll d = gcd(val,x);
        if(d>1) return d;
    }
    return -1;
}

ll max_factor;

inline void find_factor(ll x){
    if(x<=max(max_factor,2ll)) return;
    if(prime(x)){
        max_factor = max(max_factor,x);
        return;
    }
    ll d = x;
    while(d>=x) d = pollard_rho(x);
    while(x%d==0) x /= d;
    find_factor(x);
    find_factor(d);
}

int fac[N],ifac[N];

void init(int n){
    fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
    for(int i=2;i<=n;++i) fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(int i=n-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
}

inline int binom(int n,int m){
    if(n<m) return 0;
    return (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;
}

int ans[N];
int k;

void solve(int pr,ll m){ // 整式递推部分
    static int pre[N],suf[N],a[N];
    int q = p-power(pr,p-2),mul,upf = 1,pt = power(pr,m%(p-1));
    int _m = m%p;
    a[0] = power(_m,p-2);
    pre[0] = suf[k+1] = 1;
    for(int i=1;i<=k;++i) pre[i] = (ll)pre[i-1]*(i+_m)%p;
    for(int i=k;i;--i) suf[i] = (ll)suf[i+1]*(i+_m)%p;
    mul = power(suf[1],p-2);
    for(int i=1;i<=k;++i){
        upf = (ll)upf*(q+1)%p;
        a[i] = ((ll)i*a[i-1]%p+upf)*mul%p*pre[i-1]%p*suf[i+1]%p;
    }
    upf = q = 1;
    for(int i=1;i<=k;++i){
        upf = (ll)upf*(_m+i-1)%p;
        ans[i] = (ll)ans[i]*a[i-1]%p*upf%p*q%p*ifac[i-1]%p;
        q = (ll)q*pt%p;
    }
}

ll a,b,cnt;
int low[1<<15],high[12003];

int main(){
    srand(time(0));
    int m,xx,out = 0;
    scanf("%lld%lld%d",&a,&b,&k);
    if(!(a&1)){
        putchar('0');
        return 0;
    }
    init(k+3);
    for(int i=0;i<=k;++i) ans[i] = 1;
    while(a>1){
        max_factor = cnt = 0;
        find_factor(a);
        while(a%max_factor==0) a /= max_factor,++cnt;
        solve(max_factor%p,b*cnt);
    }
    for(int i=1;i<=k;++i) ans[i] = (p+(ll)ans[i]*(p+1))%(md-1); // crt
    low[0] = high[0] = 1;
    for(int i=1;i!=32768;++i) low[i] = (low[i-1]<<1)>=md?(low[i-1]<<1)-md:(low[i-1]<<1);
    m = (low[32767]<<1)%md;
    for(int i=1;i!=12000;++i) high[i] = (ll)high[i-1]*m%md;
    for(int i=1;i<=k;++i){
        xx = (ll)low[ans[i]&32767]*high[ans[i]>>15]%md;
        out ^= xx;
    }
    printf("%d",out);
    return 0;
}
```
****
个人隐约觉得这个做法还可以继续优化，即做到 $\Theta(\sqrt[4]a + \sqrt p + k)$ 的时间复杂度，但不知可行与否。

如果有懂哥的话还请指点一下（

---


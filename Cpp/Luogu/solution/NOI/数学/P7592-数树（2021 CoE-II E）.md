# 数树（2021 CoE-II E）

## 题目描述

定义一棵树 $\mathcal T$ 为 $k_1-k_2$ 叉树，当且仅当每个节点 $p\in \mathcal T$ 有儿子，要么有 $k_1$ 个儿子，要么有 $k_2$ 个儿子，$k_1 \ne k_2$。我们定义两棵 $k_1-k_2$ 树同构，当且仅当以下伪代码返回的字符串相同：
$$
\begin{array}{ll}
1 &  \textbf{Input. } \text{The edges of the tree } \mathcal T  \\
2 &  \textbf{Output. } \text{The eigenvalue of tree } \mathcal T.\\
3 &  \textbf{Algorithm. }  \text{dfs}(u)\\
4 &  \qquad result \gets \texttt{'('} \\
5 &  \qquad \textbf{for} \text{ each } (u, v) \text{ in the  } \mathcal T \\
6 &  \qquad \qquad \textbf{if }  v \text{ is not the father of  } u \\
7 &  \qquad \qquad\qquad  result \gets result\  +\ \mathrm{dfs}(v) \\
8 &  \qquad result\gets result\ +\ \texttt{')'} \\
9 & \qquad \textbf{return }  result \\
10 & \textbf{Method. } \text{check}(\mathcal T) \\
11 & \qquad \textbf{return } \text{dfs(the root of the tree } \mathcal T\text{)}
\end{array}
$$

形式化地，$k_1-k_2$ 叉树有**确定的根节点**，每个节点的若干儿子之间**有顺序**，但是节点**没有标号**。

若 $k_1-k_2$ 叉树 $\mathcal T$ 有一个 $k_1$ 叉节点，则得分 $a$，若有一个 $k_2$ 叉节点，则得分 $b$，叶节点无得分。定义一棵树的得分为其所有节点的得分之和，记为 $v(\mathcal T)$。

现在我们在所有互不同构的 $n$ 个节点的 $k_1-k_2$ 叉树中等概率随机生成一棵 $\mathcal T$，记 $v(\mathcal T)$ 的期望值为 $\mathbb{E}(v(\mathcal T))$。

可以证明 $\mathbb{E}(v(\mathcal T))$ 为有理数。当 $\mathbb{E}(v(\mathcal T))$ 不为零时，令答案 $\mathbb{E}(v(\mathcal T)) = p/q$，其中 $p$ 与 $q$ 互质。你需要输出最小的自然数 $x$ 使得 $p\equiv qx\pmod P$，其中 $P=998244353$，可以证明这样的自然数 $x$ 必定存在。

## 说明/提示

**样例说明**

具有 $6$ 个结点的不同构 $2-3$ 叉树共有 $5$ 棵，每棵得分均为 $3$ 分，则 $\mathbb{E}(v(\mathcal T))=15/5=3$，故 $p=3$ 且 $q=1$，则 $x=3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/nqywy0df.png)

------------

**数据范围**

共 $10$ 个测试点。

对于测试点 $1$，满足 $1 \le k_1,\ k_2<n\leq 10$。

对于测试点 $2$，满足 $1 \le k_1,\ k_2<n\leq 15$。

对于测试点 $3\sim 4$，满足 $1 \le k_1,\ k_2<n\leq 5 \times 10^3$。

对于测试点 $5\sim 6$，满足 $a=b=1,\ 1 \le k_1,\ k_2<n\leq 10^5$。

对于 $100\%$ 的数据，满足 $1 \le k_1,\ k_2<n\leq 10^7,\ k_1 \ne k_2, \ k_1+k_2 \le n, \  \ 1 \le \ a,\ b\leq 10^7$。


------------

**约定**

- 测试数据保证 $\mathbb{E}(v(\mathcal T))$ 不为零。


## 样例 #1

### 输入

```
2 3 6 1 2```

### 输出

```
3```

# 题解

## 作者：Aleph1022 (赞：13)

不妨设 $F$ 为方案数的 GF，用 $x$ 计量点数，用 $y$ 计量 $k_1$ 叉的点数，那么显然
$$
G = x(yG^{k_1} + G^{k_2} + 1)
$$

根据拉格朗日反演
$$
[x^n] G = \frac1n [x^{n-1}] (1+yx^{k_1}+x^{k_2})^n
$$

提取系数
$$
\begin{aligned}
[x^{n-1} y^k] (1+yx^{k_1}+x^{k_2})^n
&= [x^{n-1} y^k] \sum\limits_{i=0}^n \binom ni (yx^{k_1}+x^{k_2})^i \\
&= \sum\limits_{i=0}^n \binom ni \binom ik [kk_1 + (i-k)k_2 = n-1]
\end{aligned}
$$

容易发现使艾佛森括号取到 $1$ 的 $i$ 唯一，直接提取即可。  
时间复杂度 $O(n)$。

---

## 作者：serverkiller (赞：5)

虽然形式化题意很神奇但是我们还是可以直接设出二元生成函数 $\mathcal F(u,t)=\sum_{i}\sum_{j}f_{i,j}x^{i}x^{j}$ 其中 $f_{i,j}$ 表示 $i$ 个点权值为 $j$ 的树对应的本质不同括号序列数量 不难得到:

$$
\mathcal F(u,t)=u(1+t^a\mathcal F^{k_1}(u,t)+t^b\mathcal F^{k_2}(u,t))
$$

这个 $u$ 显然是放着给我们拉反玩的:
$$
[u^n]\mathcal F(u,t)=\frac{1}{n}[u^{n-1}](1+t^au^{k_1}+t^{b}u^{k_2})^n
$$
我们要的答案实际是:
$$
\frac{[u^n]\left.\frac{\operatorname{\partial}\mathcal F(u,t)}{\operatorname{\partial} t}\right |_{t=1}}{[u^n]\mathcal F(u,1)}
$$
对于分母直接把 $t=1$ 带进去算就好了

分子的话对拉反的式子左右同时用 $\frac{\operatorname{\partial}}{\operatorname{\partial} t}$ 可以得到:
$$
\begin{aligned}
[u^n]\left.\frac{\operatorname{\partial}\mathcal F(u,t)}{\operatorname{\partial} t}\right |_{t=1}&=\frac{1}{n}[u^{n-1}]\left.\frac{\operatorname{\partial}(1+t^au^{k_1}+t^{b}u^{k_2})^n}{\operatorname{\partial} t}\right |_{t=1}\\
&=\frac{1}{n}[u^{n-1}]n(1+u^{k_1}+u^{k_2})^{n-1}(au^{k_1}+bu^{k_2})
\end{aligned}
$$
同样也可以直接算了

---

## 作者：metaphysis (赞：5)

[题目链接](https://www.luogu.com.cn/problem/T170223?contestId=41599)

**前置知识**

（1）生成函数（解决组合或排列问题的一种有力工具）：
- [浅谈生成函数之OGF](https://zhuanlan.zhihu.com/p/52817010)
- [Ordinary Generating Function](http://math.ucsd.edu/~ebender/CombText/ch-10.pdf)


（2）拉格朗日反演（根据复合逆得到函数的某项系数）：
- [拉格朗日反演](https://blog.csdn.net/qq_33229466/article/details/96037367)
- [Lagrange Inversion Formula](https://users.math.msu.edu/users/magyarp/Math880/Lagrange.pdf)

**正文**

浏览一遍题目，可知等概率生成一棵符合题目约束的树，其 $v(\mathcal T)$ 的期望值等于所有树的权值 $v$ 之和除以不同构树的总数 $c$。由于 $a$，$b$ 均为整数，可知 $v$ 必定是整数，而 $c$ 显然是整数，当 $n$ 较小时，可以暴力生成所有可能的树，分别统计权值和得到答案。当 $n$ 较大时，需要寻找高效的方法（附注：测试点 $1$ 是给暴力生成树的解题者设置，测试点 $2$ 是给暴力生成树并加以适当剪枝的解题者设置，测试点 $3$ 和 $4$ 是为潜在的 $\mathcal O(n^2)$动态规划设置；测试点 $5$ 和 $6$ 留给愿意写多项式算法的解题者，时间 $\mathcal O(n\log n)$，要注意常数）。

首先给出结论：

$$\large \mathbb{E}(v(\mathcal T)) = \frac{[x^{n-1}]\left(\left(1+x^{k_1}+x^{k_2}\right)^{n-1}\left(ax^{k_1}+bx^{k_2}\right)\right)}{\dfrac{1}{n}[x^{n-1}]\left(1+x^{k_1}+x^{k_2}\right)^n}$$

先确定分母。令符合题意要求的由 $n$ 个点组成的不同构的树的数量所构成序列的普通生成函数为 $\mathbf F(x)$，由题意，只有 $1$ 个结点的任意 $k_1-k_2~\mathrm{Tree}$ 的数量为 $1$，因此 $\mathbf F(x)$ 的一次幂 $x$ 的系数为 $1$，根结点有 $k_1$ 棵子树（或者 $k_2$ 棵子树），这 $k_1$ 棵子树（或者 $k_2$ 棵子树）总的结点数为 $n - 1$，且子树也是 $k_1-k_2~\mathrm{Tree}$，结合判定同构的规则，
可以得到：

$$\mathbf F(x)=x\left(1+\mathbf F^{k_1}(x)+\mathbf F^{k_2}(x)\right)$$

观察可知 $\mathbf F(x)$ 的零次项系数为 $0$，一次项系数为 $1$，且：

$$x=\dfrac{x\left(1+\mathbf F^{k_1}(x)+\mathbf F^{k_2}(x)\right)}{1+\mathbf F^{k_1}(x)+\mathbf F^{k_2}(x)}=\dfrac{\mathbf F(x)}{1+\mathbf F^{k_1}(x)+\mathbf F^{k_2}(x)}$$

因此其复合逆为：

$$\mathbf{F}^{\langle-1\rangle}(x)=\dfrac{x}{1+x^{k_1}+x^{k_2}}$$

根据拉格朗日反演，有：

$$[x^n]\mathbf F(x)=\dfrac{1}{n}[x^{n-1}]\left(1+x^{k_1}+x^{k_2}\right)^n$$

正是分母。

现在要考虑求所有树的权值和，一个常见的思路是使用多元生成函数，然后求导。

令

$$\mathbf F(x,\ z)=\displaystyle \sum f_{n,m}x^nz^m$$

其中 $f_{n,m}$ 表示 $n$ 个结点的 $k_1-k_2~\mathrm{Tree}$ 权值和为 $m$ 的方案数，由于根结点要么有 $k_1$ 棵子树，要么有 $k_2$ 棵子树，要么没有子树。如果有 $k_1$ 棵子树，加上根结点后，又构成了一个 $k_1$ 叉结点，每种方案增加了 $a$ 分。如果有 $k_2$ 棵子树，加上根结点后，又构成了一个 $k_2$ 叉结点，每种方案增加了 $b$ 分。如果树中只包含根结点，则由于 $1$ 个结点的 $k_1-k_2~\mathrm{Tree}$ 权值和为 $0$ 的方案数为 $1$，故有：

$$\mathbf F(x,\ z)=x\left( 1 + z^{a}\mathbf F^{k_1}(x,z) + z^b\mathbf F^{k_2}(x,z) \right)$$

类似地，容易发现 $x$ 这一维的复合逆是:

$$\mathbf F_x^{\langle -1\rangle}(x,\ z)=\dfrac{x}{1+z^{a}x^{k_1}+z^bx^{k_2}}$$

显然多元生成函数也可以进行拉格朗日反演：

$$[x^n]\mathbf F(x,\ z)=\frac{1}{n}[x^{n-1}]\left( 1+z^ax^{k_1}+z^{b}x^{k_2} \right)^n$$

令：

$$\zeta (x,\ z)=\left(1+z^ax^{k_1}+z^bx^{k_2}\right)^n$$

现在要求权值和，对 $z$ 这一维求导：

$$\frac{\partial\zeta(x,\ z)}{\partial z}=n\left( 1+z^ax^{k_1}+z^bx^{k_2} \right)^{n-1}\left(az^{a-1}x^{k_1}+ bz^{b-1}x^{k_2} \right)$$

显然权值和就是：

$$[x^n]\frac{\partial \mathbf F(x,\ z)}{\partial  z}\biggr\vert_{z=1}=\frac{1}{n}[x^{n-1}]\frac{\partial\zeta(x,\ z)}{\partial z}\biggr\vert_{z=1}=[x^{n-1}]\left ( \left( 1 +x^{k_1}+x^{k_2} \right)^{n-1}\left( ax^{k_1}+bx^{k_2} \right) \right)$$

可以 $\mathcal O(n)$ 枚举 $x^{k_1}$ 选了几次，用多项式系数计算答案即可。由于需要求同余方程的解，可以将求逆元与解题代码有机结合。


出题人给出的标程：
```cpp

#include <bits/stdc++.h>
using namespace std;

const int N = 1e7 + 5, mod = 998244353;

inline int inc(int a, int b) { return (a += b - mod) + (a >> 31 & mod); }
inline int dec(int a, int b) { return (a -= b) + (a >> 31 & mod); }
inline int mul(int a, int b) { return 1ll * a * b % mod; }
inline void Inc(int &a, int b) { return void(a = inc(a, b)); }
inline void Dec(int &a, int b) { return void(a = dec(a, b)); }
inline void Mul(int &a, int b) { return void(a = mul(a, b)); }
inline int Pow(int a, int b) {
    int c = 1;
    for (; b; Mul(a, a), b >>= 1)
        if (1 & b)
            Mul(c, a);
    return c;
}
inline int Inv(int x) { return Pow(x, mod - 2); }

int fac[N], inv[N], n, k1, k2, a, b, tot, Sum;

inline int Polycoef(int n, int m, int k) { return mul(fac[n + m + k], mul(mul(inv[n], inv[m]), inv[k])); }

int main(void) {
    scanf("%d%d%d%d%d", &k1, &k2, &n, &a, &b);
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);
    inv[1] = 1;
    for (int i = 2; i <= n; i++) inv[i] = mul(mod - mod / i, inv[mod % i]);
    inv[0] = 1;
    for (int i = 1; i <= n; i++) Mul(inv[i], inv[i - 1]);
    for (int i = 0; i <= n; i++)
        if (i * k1 <= n - 1) {
            int res = n - 1 - i * k1;
            if (res % k2)
                continue;
            int j = res / k2;
            if (j > n)
                continue;
            Inc(tot, Polycoef(i, j, n - i - j));
        }
    for (int i = 0; i <= n - 1; i++)
        if (i * k1 <= n - 1 - k1) {
            int res = n - 1 - k1 - i * k1;
            if (res % k2)
                continue;
            int j = res / k2;
            if (j > n - 1)
                continue;
            Inc(Sum, mul(Polycoef(i, j, n - 1 - i - j), a));
        }
    for (int i = 0; i <= n - 1; i++)
        if (i * k1 <= n - 1 - k2) {
            int res = n - 1 - k2 - i * k1;
            if (res % k2)
                continue;
            int j = res / k2;
            if (j > n - 1)
                continue;
            Inc(Sum, mul(Polycoef(i, j, n - 1 - i - j), b));
        }
    Mul(tot, Inv(n));
    return printf("%d\n", mul(Sum, Inv(tot))) * 0;
}
```



---

## 作者：ducati (赞：3)

## Description

[传送门](https://www.luogu.com.cn/problem/P7592)

## Solution

令 $f_{n,m}$ 表示，有多少含 $n$ 个点，$m$ 个 $k_1$ 叉节点的 $k_1 - k_2$ 叉树。

令 $g_{n,m}$ 表示，有多少含 $n$ 个点，$m$ 个 $k_2$ 叉节点的 $k_1 - k_2$ 叉树。

令 $h_{n}$ 表示，有多少含 $n$ 个点的 $k_1 - k_2$ 叉树。

则答案为

$$\frac {1} {h_n} \left(\sum_{m \le n} amf_{n,m} + \sum_{m \le n} bmg_{n,m}\right)$$

考虑如何求 $f,g,h$。下以求 $f$ 为例，$g,h$ 的求法可如法炮制。

----

对于根节点，其可以为 $k_1$ 叉，也可为 $k_2$ 叉；同时，每个儿子的子树是互相独立的子问题。从而，若令 $F(x,y)$ 为 $f$ 的**二元 OGF**（即 $F(x,y) = \sum_{n,m} f_{n,m} x^n y^m$），不难发现

$$F(x,y) = x(yF(x,y)^{k_1} + F(x,y) ^ {k_2} + 1)$$

考虑拉格朗日反演，先将方程整合为复合逆的形式。令 $G(x) = \frac {x} {yx^{k_1} + x^{k_2} + 1}$，则

$$G(F(x,y)) = x$$

那么

$$\begin{aligned}[x^n]F(x,y) &= \frac {1} {n} [x^{n-1}] \left(\frac {x} {G(x)}\right)^n \\ &= \frac {1} {n} [x^{n-1}](1 + x^{k2} + yx^{k1})^n \end{aligned}$$

考虑对每个 $m$ 算出 $[x^{n-1}][y^m](1 + x^{k2} + yx^{k1})^n$。

考虑括号被拆开后的每一项，令 $1$ 的幂次为 $u$，$x^{k2}$ 的幂次为 $v$，$yx^{k1}$ 的幂次为 $w$，则有：
- $u + v + w = n$。
- $k_2v + k_1w = n-1$。
- $w = m$。

显然，存在至多一组 $(u,v,w)$ 满足以上条件，此时 $[x^{n-1}][y^m](1 + x^{k2} + yx^{k1})^n$ 为 ${n \choose u,v,w}$。

时间复杂度 $O(n)$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+5,mod=998244353;

int k1,k2,A,B,n,fac[N],ifac[N];
inline int quick_power(int x,int y){
	int res=1;
	for (;y;y>>=1,(x*=x)%=mod) {if(y&1)(res*=x)%=mod;}
	return res;
}
inline int getinv(int x){return quick_power(x,mod-2);}
inline void chksum(int x,int &y){y+=x;if(y>=mod)y-=mod;}
inline void init(){
	fac[0]=1;
	for (int i=1;i<=n;i++)  fac[i]=(fac[i-1]*i)%mod;
	ifac[n]=quick_power(fac[n],mod-2);
	for (int i=n-1;~i;i--)  ifac[i]=(ifac[i+1]*(i+1))%mod;
}
int solve_1(int k1,int k2,int A){
	int ans=0;
	for (int w=0,ret=n-1,num=0;ret>=0;w++,ret-=k1,chksum(A,num))if(!(ret%k2)){
		int v=ret/k2,u=n-v-w;
		if (u>=0)  (ans+=ifac[u]*ifac[v]%mod*ifac[w]%mod*num)%=mod;
	}
	return (ans*fac[n-1])%mod;
}
int solve_2(){
	int ans=0;
	for (int w=0,ret=n-1;ret>=0;w++,ret-=k1)if(!(ret%k2)){
		int v=ret/k2,u=n-v-w;
		if (u>=0)  (ans+=ifac[u]*ifac[v]%mod*ifac[w])%=mod;
	}
	return (ans*fac[n-1])%mod;
}
signed main(){
	cin>>k1>>k2>>n>>A>>B,init();
	cout<<((solve_1(k1,k2,A)+solve_1(k2,k1,B))*getinv(solve_2()))%mod;
	return 0;
}
```


---

## 作者：Petit_Souris (赞：2)

注意到这题中儿子是有顺序的。回忆我们如何解决无标号有根树计数，是利用递归的子问题形式列出了生成函数。

这题中我们可以仿照无标号有根树做类似的事情，只不过由于我们关心 $k_1,k_2$ 叉的节点数量，所以生成函数应当是二元的。我们用 $x$ 记录节点个数，$y$ 记录 $k_1$ 叉的节点个数，可以得到：

$$
F=x(yF^{k_1}+F^{k_2}+1)
$$

左边出来一个 $x$，直接条件反射出拉反。容易发现 $F$ 的复合逆是 $G=\frac{x}{yx^{k_1}+x^{k_2}+1}$，那么：

$$
[x^n]F=\frac{1}{n}[x^{n-1}](x)'(\frac{x}{\frac{x}{yx^{k_1}+x^{k_2}+1}})^n
=\frac{1}{n}[x^{n-1}](yx^{k_1}+x^{k_2}+1)^n
$$

现在要把右边展开，求出 $y$ 的各项系数。我们针对一个 $k$ 进行观察，即求 $[x^{n-1}y^k]$。此时设 $n$ 次幂括号里 $x^{k_1},x^{k_2},1$ 分别取了 $a,b,c$ 次，那么需要满足：

$$
\begin{aligned}
a+b+c=n\\
ak_1+bk_2=n-1\\
a=k
\end{aligned}
$$

此时三个变量已经确定，因此一个 $k$ 只会被一组 $(a,b,c)$ 贡献，这个方案数和得分是容易预处理阶乘后 $\mathcal O(1)$ 计算的，因此总时间复杂度为 $\mathcal O(n)$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1e7+9,Mod=998244353;
ll k1,k2,n,A,B,fac[N],ifac[N],invn;
ll pw(ll x,ll p){
    ll res=1;
    while(p){
        if(p&1)res=res*x%Mod;
        x=x*x%Mod,p>>=1;
    }
    return res;
}
ll C(ll x,ll y){
    if(x<y||y<0)return 0;
    return fac[x]*ifac[y]%Mod*ifac[x-y]%Mod;
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    k1=read(),k2=read(),n=read(),A=read(),B=read();
    fac[0]=1;
    rep(i,1,n)fac[i]=fac[i-1]*i%Mod;
    ifac[n]=pw(fac[n],Mod-2);
    per(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%Mod;
    invn=ifac[n]*fac[n-1]%Mod;
    ll res1=0,res2=0;
    rep(k,0,n){
        ll o=n-1-k*k1+k*k2;
        if(o%k2)continue;
        ll i=o/k2;
        if(i<0||i<k)continue;
        ll wys=C(n,i)*C(i,k)%Mod*invn%Mod;
        res1=(res1+wys)%Mod;
        res2=(res2+wys*((k*A+(i-k)*B)%Mod))%Mod;
    }
    write(res2*pw(res1,Mod-2)%Mod);
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---


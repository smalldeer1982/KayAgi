# 「Wdoi-6」未知之花魅知之旅

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/glirwa55.png)](https://thwiki.cc/%E6%9C%AA%E7%9F%A5%E4%B9%8B%E8%8A%B1_%E9%AD%85%E7%9F%A5%E4%B9%8B%E6%97%85)

位于太平洋板块和亚欧板块消亡边界的日本，是世界上最多发地震的一个国家之一。2011 年 3 月 11 日，日本时间下午 2 时 46 分 18 秒，一场里氏 9 级的地震袭击了这个国家，随之而来的，是超过 10 米高的巨大海啸。妻离子散，家破人亡，是对这一悲剧性事件的最好描述。

2011 年 5 月，东方 Project 的创作者 ZUN，为地震中的灾民谱写了一张专辑，叫做《未知之花，魅知之旅》，所筹得的善款都被捐赠用于救灾赈灾之中。

-----

而到了近未来的科学世纪，莲子和梅莉在一次聊天之中，又谈论到了这场大地震。这场地震对传统宗教的摧残程度也颇深，数千所神社不同程度遭受到了损毁，也有不少神社的主殿全毁或者半毁。甚至就连外界的博丽神社，也因此被摧毁。

莲子与梅莉决定动身，前往外界的博丽神社，进入幻想乡中，通报这一消息。

## 题目描述

### 简要题意

称一个长度为 $n$ 的正整数数列是「$k$ - 好」的，当且仅当它满足以下条件：  

- 对于 $1< i< n$，满足 $a_{i-1},a_i,a_{i+1}$ 中最大的一个等于其他两个之和。
- 所有元素都不小于 $k$。

$T$ 组询问，每次询问给定 $(a_0,a_1,x,y,k)$，问是否存在「$k$ - 好」数列（长度不小于 $2$），前两项为 $a_0,a_1$ 并且有相邻两项依次为 $x,y$。

-----

### 原始题意

原本就门可罗雀的博丽神社，在地震之后，更显荒凉。莲子与梅莉紧赶慢赶来到了博丽神社，只看到了倒塌的鸟居。由于神社过于荒凉，莲子和梅莉决定先将神社给好好打扫一番，再进入幻想乡。

具体而言，神社中有若干个物件等待被整理，每个物件都有一个正整数魅力值。可以认为，每种魅力值的物件都有**足够多**个。从被遗落的绘马中，莲子得知了，在被地震摧毁前的博丽神社中的物件，应当具有如下特点：

- 每个物件都有一个**不小于** $k$ 的魅力值。
- 三个相邻物件的**最大**魅力值，是其他两个物件的魅力值**之和**。
- 前两个物件的魅力值分别为 $a_0, a_1$。
- 存在**相邻**的两个物件，魅力值依次为 $x, y$。

莲子和梅莉认为，如果能够从所有物件中选出一些进行排列，并满足如上特点的话，那么这样的神社是**美观**的，不会让她们一进入幻想乡就被灵梦退治。

很显然，由于物件的散佚，莲子和梅莉可能无法通过这些信息来使得神社变得**美观**。莲子和梅莉找到了你，希望你能告诉她们，在这样的规则下是否存在一种让神社变得**美观**的方案。

由于灵梦退治得太狠，她们担心自己的生命安全，因此她们会对你询问 $T$ 次，以确保你不是在糊弄她们。

## 说明/提示

### 样例解释

- 针对第一次询问，$a_0=2,a_1=3$，莲子和梅莉可以将物件如下排列构造：$2,3,5,2,7,9,2,11,\dots$，其中 $a_5=7,a_6=9$，从而存在方案让神社变得美观。
- 针对第二次询问，$a_0=4,a_1=9$，莲子和梅莉可以将物件如下排列构造：$4,9,5,4,1,3,2,5,3,8,\dots$，其中 $a_6=2,a_7=5$，从而存在方案让神社变得美观。
- 针对第三次询问，由于要求 $a_i \geq k=2$，第二次询问中的方法失效，同时也可以证明不存在让神社变得美观的方法。
- 针对第四次询问，要求构造出的 $x=1,y=2$ 都小于等于 $3$，从而无法让神社变得美观。
- 针对第五次询问，显然 $a_0=7,a_1=9$ 就已经符合让神社变得美观的要求了。

### 数据范围

**本题采用捆绑测试。**

令 $n=\max(a_0,a_1,x,y,k)$。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{T\le } & \bm{n\le }  & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10  & - & - \cr\hline
2 & 20 & 300 & 1000 & \mathbf{A} & - \cr\hline
3 & 10 & 300 & 10^9 & \mathbf{B} & - \cr\hline
4 & 20 & 300 & 10^8 & \mathbf{C} & 1,2 \cr\hline
5 & 40 & 10^5 & 10^9 & - & 3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：每次询问的 $k$ 相同。
- 特殊性质 $\mathbf{B}$：$k=1$。
- 特殊性质 $\mathbf{C}$：$\sum n \leq 10^8$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^9,1 \leq T \leq 10^5$。

## 样例 #1

### 输入

```
5
2 3 7 9 1
4 9 2 5 1
4 9 2 5 2
6 4 1 2 3
7 9 7 9 7```

### 输出

```
yes
yes
no
no
yes```

# 题解

## 作者：天南星魔芋 (赞：28)

**注意坑点：$a0,a1$ 可能和 $x,y$ 相同并且 $a0$ 或 $a1$ 不大于 k。**

思路：

因为让 $a0,a1$ 凑 $x,y$ 肯定不行（1e9），所以考虑将这两对数化作相同的一对数。

然后想到往小凑。（因为往大凑的话没有上界，肯定不行）

若一数对能构成的最小数对的唯一，并且求最小数对方法正确，所以只要求出 $a0,a1$ 构成的最小数对 和 $x,y$ 构成的最小数对，然后比较他俩是否一样就行了。（注意数对中两个数的先后顺序）

然后就是证明一数对能构成的最小数对的唯一，并且方法正确：

1. 对于一对数，若只考虑减法，那么只有一种构造方案。

2. 加入加法，设当前为 $x,y$ ，加一次后就是 $y,y+x$，然后对 $y,y+x$ 持续做减法：$y,y+x$ 变成 $y+x,x$ 变成 $x,y$，也就是我们发现一次加法可以被两次减法抵消，加法对于结果没有影响。

也就是说只要不断做减法，直到无法运算为止，就能得出构成的最小数对。

因为求最小数对方法唯一，所以构成的最小数对唯一。

然后我们模拟减法，即可拿到 $50$ 分。

$code:$ 50 pts

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int x,y,xx,yy,k;
void cl(int &a,int &b){
	while(1){
		int ABS=abs(a-b);
		if(ABS>=k){
			a=b;
			b=ABS;
		}
		else break;
	}
}
signed main(){
	cin>>T;
	while(T--){
		scanf("%d%d%d%d%d",&x,&y,&xx,&yy,&k);
		if(k>xx||k>yy||k>x||k>y){
			puts("no");
			continue;
		}
		if(x==xx&&y==yy){
			puts("yes");
			continue;
		}
		cl(x,y);cl(xx,yy);
		if(xx!=x||yy!=y)puts("no");
		else puts("yes");
	}
}
```
思考为什么 T 了，发现模拟减法算法复杂度高。（比如一个 1e9 ，一个 1，肯定 T）

然后就是对模拟减法的优化，我们对于连减要分类讨论一下：

* $x,y$ 并且 $x>y$ $x,y$ 变成 $y,x-y$ 变成 $x-y,x-y-y$ 变成 $x-y-y,y$。

* $x,y$ 并且 $x<y$ $x,y$ 变成 $y,y-x$ 变成 $y-x,x$ 变成 $x,y-x-x$。

通过观察发现，若大的超过了小的的两倍，那么大的可以直接减去两个小的并且不做交换。

我们每次可以观察大的可以减去多少个小的，若为奇数个，减完交换，否则就直接减。

$code:$ 100 pts



```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int x,y,xx,yy,k;
void cl(int &a,int &b){
	while(1){
		if(a<b){
			int now=(b-k)/a;
			if(!now)break;
			b-=now*a;
	    	if(now&1)swap(b,a);
		}
		else if(a>b){
			int now=(a-k)/b;
			if(!now)break;
			a-=now*b;
			if(now&1)swap(a,b);
		}
		else break;
	}
}
signed main(){
	cin>>T;
	while(T--){
		scanf("%d%d%d%d%d",&x,&y,&xx,&yy,&k);
		if(k>xx||k>yy||k>x||k>y){
			puts("no");
			continue;
		}
		cl(x,y);cl(xx,yy);
		if(xx!=x||yy!=y)puts("no");
		else puts("yes");
	}
}
```


~~所以这有黑题难度吗？~~

---

## 作者：z_z_b_ (赞：18)

## P8348 「Wdoi-6」未知之花魅知之旅

![A](https://img.picgo.net/2025/05/17/Abe4d8cb8563fbcd1.png)

还是上面那张图好看 /se，但是可惜的是没法交那道题的题解了。

有一说一，梅莉和莲子真的好看 /se。

如果你猜到结论就是猜到了，没猜到就是没猜到，但是这个结论还是很好猜的。

转化一下题目：给定两个数 $(a_0,a_1)$，通过相加 / 减的方式变成 $(x,y)$ 并且中途两个数的取值范围均为 $[k,+\infty)$。

补充一下，这个数对是在操作序列中用长度为 2 的滑动窗口滑出来的，**所以请保证他们的相对位置不变**！

发现没有给上限，那么把 $(a_0,a_1)$ 转成 $(x,y)$ 显然不合理。

转换一下，找到一个中间状态 $(x_1,y_1)$ 满足 $(a_0,a_1)$ 和 $(x,y)$ 都可以通过转换得到这个状态。

反正又没有次数限制 ┑(￣Д ￣)┍。

那就有人要问了，主播主播，你前面都说了 $(a_0,a_1)$ 转成 $(x,y)$ 不合理，那只不过转了一个中间态怎么就合理了？

你说的对，但是我们可以限定 $(x_1,y_1)$ 为 $(a_0,a_1)$ 能变为的最小数对，然后问 $(x,y)$ 的最小数对是否也是 $(x_1,y_1)$ 就行了。

原因就需要推结论了。

> 结论 1：$(x,y)$ 对应的最小数对 $(a,b)$ 唯一。

求最小数对肯定是做减法，但前提是加法对答案不会有影响。

如果对两者做加法再做减法：$(x,y)\stackrel{+}\longrightarrow(y,y+x)\stackrel{-}\longrightarrow(y+x,x)\stackrel{-}\longrightarrow(x,y)$。

可以发现一次加法可以被两次减法抵消掉，不影响最终答案。

如果只剩下减法了，这玩意其实就是裴蜀定理，辗转相减和辗转相除没啥本质区别，改成辗转相除就行了。

> 结论 2：如果 $(x,y)$ 能操作成 $(a,b)$，那么 $(a,b)$ 也能操作成 $(x,y)$。

这个比第一个好证，只需要证明加法和减法可以互相抵消就行了。

结论一中已经证明了一次加法可以被两次减法抵消。

那么两次减法也可以被一次加法抵消：$(x,y)\stackrel{-}\longrightarrow(y,y-x)\stackrel{-}\longrightarrow(y-x,x)\stackrel{+}\longrightarrow(x,y)$。

这就证出来了。

有了这两条，上面的做法的正确性就很显然了。

只不过辗转相减复杂度有点危险，很容易被卡成狗，事实上出题人确实卡掉了直接的辗转相减做法。

主播主播，辗转相减还是太吃操作了，有没有更简单而且强势的做法？

有的兄弟有的，前面说了辗转相减和辗转相除差不多，用类似辗转相除的方法（其实就是能减就一口气减完）就行了。

复杂度 $O(T\log V)$。

需要注意的是别写嗨了，$(x,y)$ 的相对位置不能变，不然你就会跟主播一样盯代码盯了半个小时没找出问题。

同样的，如果你 WA10，那么请检查你是不是改变了数对的相对位置。

总体而言还是一道非常不错的人类智慧题。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

namespace io
{
	inline int read(){int x=0,w=0;char c=0;while(!isdigit(c))w|=c=='-',c=getchar();while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();return w?-x:x;}
	template<typename T>inline void write(T x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10+'0');}
	template<typename T>inline void write_(T x){write(x),putchar(' ');}
	template<typename T>inline void writeln(T x){write(x),putchar('\n');}
}
using namespace io;

int x,y,xx,yy,k;

void check(int&x,int&y)
{
	while(1)
	{
		int f=0,l=0;//l记录操作次数用来还原相对位置，f记录前面有没有交换
		if(x<y) swap(x,y),f=1;//注意不要改了相对位置，让f=1就行了。
		if(x-k<y)
		{
			if(f) swap(x,y);//就这里我调了半个小时
			break;//减不了那就不用减了。
		}
		l=(x-k)/y,x-=l*y;//修改
		if((l+f)%2==1) swap(x,y);//如果修改了奇数次就要注意交换来还原相对位置。
	}
}

void solve()
{
	x=read(),y=read(),xx=read(),yy=read(),k=read();
	if(min({x,y,xx,yy})<k){puts("no");return;}
	check(x,y),check(xx,yy);
	puts(x==xx&&y==yy?"yes":"no");
	return;
}

signed main()
{
	int t=read();
	while(t--) solve();
	return 0;
}
```

---

## 作者：VinstaG173 (赞：8)

以下称 $a=a_0,b=a_1$。只讨论 $a,b,x,y$ 均不小于 $k$ 的情况。

对于连续两项 $a_{i-1},a_i$，知道 $a_{i+1}$ 至多有两种可能：

1. $a_{i+1}=a_i+a_{i-1}$；
2. $a_{i+1}=\lvert a_i-a_{i-1} \rvert$。

称可能性 1 为加操作，可能性 2 为减操作。

下面开始解决此问题。

首先注意到一件事：以 $a,b$ 为开头的数列中存在连续的 $x,y$ 和以 $y,x$ 为开头的数列中存在连续的 $b,a$ 是等价的。

事实上，在这个观察中还包含一件事，那就是

> 当且仅当存在 $c,d$ 使得以 $a,b$ 开头能得到相邻的 $c,d$，以 $y,x$ 开头能得到相邻的 $d,c$ 时，以 $a,b$ 开头能得到相邻的 $x,y$。

这能够让我们寻求一对更简单的 $c,d$ 来刻画 $a,b$ 开头的这个数列的根本性质。

由于题目中给出了一个 $k$ 作为限制，因此自然地想到找整个数列中最小的一组 $c,d$。这个最小的刻画条件有多种，可以选取“和最小”为条件。

接下来我们注意到一个事实：和最小的 $c,d$ 下一步一定不能是减操作。为了不能是减操作，此时要求 $\lvert c-d \rvert<k$，我们称使得 $\lvert c-d \rvert<k$ 的 $(c,d)$ 是极小的，下证明一个结论：对于特定的 $a,b$，能够达到的极小相邻 $c,d$ 是唯一的。

事实上注意到一次加后紧跟的两次减会使得数列当前的最后两项不变，后续操作也不受影响，如下：

$$a,b,a+b,a,b,\dots.$$

如果一次加操作后至多连续一次减操作，我们证明最终得不到极小相邻 $c,d$。假设这样操作得到了 $c,d$ 是极小的，则考虑 $c,d$ 前的操作。若是一次加操作，则有前一项为 $\lvert c-d \rvert \ge k$，故非极小。若是一次减操作，则再进行一次减操作后与去掉最后的一次减操作与一次加操作时相同，故非极小。

故达到的极小相邻 $c,d$ 之前一定经过了两次连续的减操作，则可以与前面的一次加操作抵消。如此抵消下去只要没有将加操作抵消完，就一定会出现一次加后至多连续一次减的情况，矛盾！故加操作一定会被全部抵消。

若一直进行减操作，则显然得到的 $c,d$ 是唯一的。操作到不能再操作即为所求。

然后用类似求 $\gcd$ 的欧几里得算法即可解决此题。

---

upd 2022/5/22

感觉上面的证明过程不算很完整，还有一点并不非常显然的东西需要说明一下。于是来补一发。

必要性如上证明已经是完备的。下只证充分性。

首先有上面证明出的结论：由一个给定的 $a,b$ 只能到唯一的极小 $c,d$。

用反证法，如果存在 $a,b$ 能够到达 $x,y$ 且 $a,b$ 到达极小 $c,d$，$y,x$ 到达的极小并非 $d,c$。根据结论 $y,x$ 不能到达 $d,c$。

我们考虑两种情况：

1. $a,b$ 到 $x,y$ 的过程中经过了 $c,d$。这种情况包含 $x=d$ 或 $x,y=c,d$。

那么显然 $c,d$ 能到达 $x,y$，故我们要求 $y,x$ 能到达 $d,c$。

2. $a,b$ 到 $x,y$ 的过程中未经过 $c,d$。这种情况包含 $y=c$。

那么显然我们要求 $x,y$ 能到达 $c,d$。由于题设操作可逆，因此 $c,d$ 能到达 $x,y$，即 $y,x$ 能到达 $d,c$。

故 $y,x$ 能到达 $d,c$。与反证假设矛盾。结论证毕。

---

## 作者：chu_yh (赞：7)

第一篇黑题题解，虽然这题这题简单且~~好骗分~~，自认为写的比较详细。

### 题意转化

给定两对二元组，一对起始组 $a,b$，一对目标组 $c,d$，问起始组通过**向右延伸**得到的序列的最右端两数是否有可能与目标组相等，序列中所有数都必须满足大于等于 $k$。

这里**向右延伸**的含义是：将序列**最右侧两个数**的**和**或**差**放在这两个数的右边以延伸这个序列。

形式化的讲，将序列 $\cdots,x,y$ 延伸为 $\cdots,x,y,t$，需满足 $t=x+y$（这里称为和延伸）或 $t=|x-y|$（这里称为差延伸）。

### 解题思路

其中将起始组向右和延伸是**无意义**的，分析一下：

||序列|
|:-:|:-:|
|1|$\cdots,x,y$|
|2|$\cdots,x,y,x+y$|
|3|$\cdots,x,y,x+y,x+2y$|
|4|$\cdots,x,y,x+y,x+2y,y$|

由 $1\to2$ 和 $2\to3$ 可知，向右和延伸是无穷无尽的，并且会和差延伸抵消（由 $3\to4$ 可知），回归原始序列。所以，我们只对起始组进行向右差延伸，直至序列中的元素小于 $k$。

有童鞋就会问：如果目标组就是由起始组向右和延伸得到的呢？我们可以将目标组向左差延伸（将序列 $x,y,\cdots$ 延伸为 $t,x,y,\cdots$，需满足 $t=|x-y|$），看是否能和起始组的延伸序列重合（即起始组延伸序列的最右端两数与目标组延伸序列的最左端两数相等）即可。

我们会发现这是一个类似于欧几里得的过程，只不过是在辗转相减（就是不断差延伸）。恭喜你，到这里你已经能拿下 50 分了（50 分代码~~因为懒~~没打，参考其他题解）。

为什么说它好骗分？因为根据上面思路，在 $k=1$ 时，起始组和目标组分别向右向左延伸直至其**最大公约数**，如果 $\gcd(a,b)=\gcd(c,d)$，输出 `yes`，反之输出 `no`（~~我是不会告诉你我的 `yes` 和 `no` 大小写还在错~~）。

### 时间优化

主要的时间复杂度在辗转相减，考虑对它进行优化。

手动模拟算法过程：

||序列|
|:-:|:-:|
|1|$\cdots,x,y$|
|2|$\cdots,x,y,\lvert x-y\rvert$|
|3|$\cdots,x,y,\lvert x-y\rvert,\lvert y-\lvert x-y \rvert\rvert$|
|4|式子太复杂了。|

分情况讨论：

- 若 $x>y$，则序列 2 为 $\cdots,x,y,x-y$；
  - 若 $x>2y$，则序列 4 为 $\cdots,x,y,x-y,x-2y,y$；
  - 若 $x\le2y$，没必要讨论，需要的话自己推。
- 同样，若 $x<y$ 且 $x<2y$，则序列 4 为 $\cdots,x,y,y-x,x,y-2x$。

不断后推，会发现只要 $\max(x,y)>n\min(x,y)$，便可以得到二元组 $\min(x,y),\max(x,y)-n\min(x,y)$ 或 $\max(x,y)-n\min(x,y),\min(x,y)$。

于是，只需要计算出 $n=\lfloor\frac{\max(x,y)}{\min(x,y)}\rfloor$ 就可以将 $2n$ 次减法**一步**到位。

```cpp
inline void f(int &x,int &y){//主要优化
	int n=x/y;
	if(x-n*y<k) n--;//保证不小于k
	x=x-y*n;//一步到位
	if(n&1) swap(x,y);//注意位置可能对调
}
```

### 完整代码

**留意读入的 $a,b,c,d$ 有可能小于 $k$！**

```cpp
#include<bits/stdc++.h>
#define Min(A,B,C,D) min(A>B?B:A,C<D?C:D)
using namespace std;
int T,a,b,c,d,k;
bool o;

inline int gcd(int x,int y){return y?gcd(y,x%y):x;}

inline void f(int &x,int &y){//主要优化
	int n=x/y;
	if(x-n*y<k) n--;
	x=x-y*n;
	if(n&1) swap(x,y);
}

inline void exgcd(int &x,int &y){
	while(abs(x-y)>=k) f(x>y?x:y,x>y?y:x);
}

void Main(){
	scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
	if(Min(a,b,c,d)<k){puts("no");return ;}//注意特判
	if(k==1) o=gcd(a,b)==gcd(c,d);
	else{
		exgcd(a,b),exgcd(d,c);
		o=(a==c&&b==d);
	}
	if(o) puts("yes");
	else puts("no");
}

int main(){
	scanf("%d",&T);
	while(T--) Main();
	return 0;
}
```

---

## 作者：Mortidesperatslav (赞：4)

如果有两项 $a,b$，不考虑大小限制，则下一项只能是：

1. $a+b$。

2. $a-b$。

3. $b-a$。

由于 $k$ 是正整数，所以下一项不能是负数，于是至多有两种情况：$a+b$ 和 $|a-b|$。归纳得出数列中的每一项是若干个 $a$ 和若干个 $b$ 的和。

然后我们需要证明：如果从两项 $(a,b)$ 可以操作得出 $(c,d)$，则 $(c,d)$ 可以通过操作还原成 $(a,b)$。

还原方法：假设 $(b,a)$ 做加法变成了 $(a,a+b)$，我们可以减法变成 $(a+b,b)$ 再变成 $(b,a)$。

如果 $(b,a)$ 做减法变成了 $(a,a-b)$，我们可以做减法变成 $(a-b,b)$，做加法变成 $(b,a)$，做加法变成 $(a,a+b)$，做减法变成 $(a+b,b)$，做加法变成 $(b,a+2b)$，做减法变成 $(a+2b,a+b)$，做减法变成 $(a+b,a)$，做减法变成 $(a,b)$。

如果 $(b,a)$ 做减法变成了 $(a,b-a)$，我们可以做加法变成 $(b-a,b)$，做减法变成 $(b,a)$。

这就表示，每一步都是可逆的。我们只要重复这些步骤，一定能够还原。

那么，我们要如何从 $(a,b)$ 出发，使得相邻两项为 $(x,y)$？

注意到如果 $(a,b)$ 和 $(x,y)$ 都能通过操作达到一个 $(c,d)$，那么 $(a,b)$ 一定能先操作变为 $(c,d)$ 再到 $(x,y)$。

然后，根据 Bezout 定理（大概是叫这个名字），存在一对最小的正整数 $(c,d)$。我们只需要判断 $(a,b)$ 和 $(x,y)$ 操作得到的 $(c,d)$ 是否相同。

于是模拟即可。我采用的是类似 Euclid 算法的方式。

注意如果 $a_0,a_1,x,y$ 中有至少一个小于 $k$ 就无解。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int a0, a1, x, y, k;
void work(int &a, int &b){//求最小数对
	while (1){
		if (a < b){
			if ((b - k) < a)
				break;
			bool fl = ((b - k) / a) & 1;
			b -= (b - k) / a * a;
			if (fl)
				swap(a, b);
		}else if (a != b){
			if ((a - k) < b)
				break;
			bool fl = ((a - k) / b) & 1;
			a -= (a - k) / b * b;
			if (fl)	
				swap(a, b);
		}else
			break;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> t;
	while (t--){
		cin >> a0 >> a1 >> x >> y >> k;
		if (k > min(min(a0, a1), min(x, y))){//不能小于 k
			cout << "no\n";
			continue;
		}
		int ta0 = a0, ta1 = a1, tx = x, ty = y;
		work(ta0, ta1);
		work(tx, ty);
		if (ta0 != tx || ta1 != ty)//判断最小数对是否相等
			cout << "no\n";
		else
			cout << "yes\n";
	}
	return 0;
}
```

---

## 作者：Rnfmabj (赞：4)

做题背景：

赛时没做掉，当时是直接看到题面和数据范围，发现是非 DP 状物但题面又很像，就弃了。

后面发现了辗转相减判状态重复，然后受到了场切爷 @[天南星魔芋 ](https://www.luogu.com.cn/user/399239) 的指点 ~~外加一通魔法调试~~，总算做掉了这道思维题。感觉扔 CF 上应该是 div2 E/F 的样子？



------------
## 思路

首先，题目相当于是给定了一个起始状态和目标状态，需要通过相减 / 相加的操作来转移到目标状态，并给定了状态限制。

那么我们当然不能考虑一直相加并通过相减调整，因为直观上，这样始终不会碰到限制，且连续相加后的相减无异于重复之前的状态，是无用的。这里的证明在下面的 UPD 中给出。

考虑相减。让起始状态和目标状态一起相减，若二者在这个过程中出现的状态集合有交集，且转移过程中没有碰到限制，则有解。因为一个状态直接对应了完整的所有转移，所以若状态集合有交，说明这个状态可以通过初始状态相减得到，并让这个状态相加得到目标状态。

UPD：因为没有证明往大加不行题解被下力，赶紧补上证明。

考虑相加时，新得到的 $x'=x+y,y'=x'+y=2x+y$，而初始的 $x,y$ 是由 $x+y,2x+y$ 转移来的，此时的状态相当于回到两次相减之前，出现了重复状态，故对答案无影响。


而相减由于状态是唯一的，且对应唯一的转移结果，所以相减是可行的。

对于需要初始状态相加的情况，可以转化为目标状态相减，上面的结论同样适用。

至于所谓“一起往大跑”的情况，同样可以由上面的证明得到，这样获得的状态交集也可以由辗转相减构造，在答案上无影响。

而辗转相减的过程中更便于考虑 $k$ 的限制，且辗转相减受限于初始 / 目标状态的大小，当转移到最小合法状态后即可停下，相加没有明确的上限，难以讨论限制，故应考虑相减的情况。

结论得证。

考虑怎么判断是否有交集。

一个朴素的实现是模拟，开两个 set 维护状态集合，每次转移时判断一下是否有交和状态是否满足限制。



我们发现，假如两个集合内出现了第一个相同状态，那么这个相同的状态相减之后的状态也会在这个交集里。同样的，再继续相减下去也是一样，一直到最小的合法状态。所以我们只需要**判断这个最小合法状态是否相同**即可。

如何获得这个最小的合法状态呢？

> 我会辗转相减模拟！

让两个元素一直辗转相减，直到即将碰到限制时即为最小的合法状态。

然而这样最多会做 $2×10^9$ 次辗转相减，妥妥超时。

但是这个暴力居然有50分，而且只会 T 两个点，如果月赛换成没有 subtask 这个暴力将绝杀，可惜换不得。

> 我会辗转相除！

直接用辗转相除加速，然后判断最后的结果是否相同且合法。这个结果等价于 $x'=x÷gcd(x,y) ,y'=y÷gcd(x,y)$，可以快速实现。

然而这样的加速无法保证最后的结果是最小合法状态，只能保证是最小状态，直接判断是否合法将因为跳过了合法状态而当场 WA 掉。

但是这么做可以在 $k=1$ 的测试点得到满分。 

> 我会二进制分解！

在相减时使用类似于倍增的二进制分解加速，依次让 $x$ 在合法的前提下尝试减去 $2^{26}y,2^{25}y,2^{24}y…2y,y$。然后基于这个操作辗转相减。

这样由于每次在操作前都保证了合法，所以最终得到的结果一定是最小合法状态。

在实现的时候要注意状态中 $x,y$ 的相对位置。

------------
## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
#define R read()
#define file(a) freopen(#a".in","r",stdin),freopen(#a".out","w",stdout)
using namespace std;
inline ll read() {
	ll s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f*=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}
inline void write(ll x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10),x%=10;
	putchar('0'+x);
}//Don't use it for CF.
inline void wk(ll x){write(x);putchar(' ');}
inline void we(ll x){write(x);putchar('\n');}
ll T;
ll k;
ll t[5];
void ex_mod(ll &x,ll &y){//辗转相减
    if(abs(x-y)<k)return ;
    bool tp=0;
    if(x>y){
        for(ll i=26;i>=0;i--){//二进制分解加速
            if(x-(1<<i)*y>=k){//判断是否合法
                x-=(1<<i)*y;
                if(i==0)tp=1;
            }
        }
        if(tp)swap(x,y);
        ex_mod(x,y);
    }
    else{
        swap(x,y);
        for(ll i=26;i>=0;i--){
            if(x-(1<<i)*y>=k){
                x-=(1<<i)*y;
                if(i==0)tp=1;
            }
        }
        if(!tp)swap(x,y);
        ex_mod(x,y);
    }
}
signed main(){
    T=R;
    while(T--){
        for(ll i=1;i<=4;i++){
            t[i]=R;
        }
        k=R;
        if(t[1]<k||t[2]<k||t[3]<k||t[4]<k){//不合法提前判断
            cout<<"no"<<endl;
            continue;
        }
        if(t[1]==t[3]&&t[2]==t[4]){
            cout<<"yes"<<endl;
            continue;
        }
        ex_mod(t[1],t[2]);
        ex_mod(t[3],t[4]);
        if((t[1]==t[3])&&(t[2]==t[4]))cout<<"yes"<<endl;
        else cout<<"no"<<endl;

    }
	return 0;
}
```

---

## 作者：robertuu (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8348)

~~这题怎么是黑题？？~~

关键点：所有的元素都需要大于等于 $k$，而上限没有边界，需要判断的元素很大，有 $10^9$。

由于如果同时考虑相邻两项做加法和减法决策太多（你 $O(n)$ 都要 `TLE` 了还能有决策？），应该简化决策。

很明显，题目给出的元素下限就是一个“风向标”，告诉你要化成只做减法（加法都没边界，不知道得加到什么时候）。

可以假设需要使用加法才能判断是否可以位于一个“$k$ 好”数列，观察加法的性质：$x,y,x+y,x+2y,2x+3y,3x+5y,5x+8y$

相信规则已经很明显了，$x$ 和 $y$ 的系数都是斐波那契数列的项，设 $fib_n$ 表示斐波那契数列的第 $n$ 项。

设数对 $x,y$ 进行多次加法后得到的数为 $fib_nx+fib_{n+1}y$。

由于对于第一次加法得到的数 $x+y$，前一个数 $y$ 的系数不是斐波那契数列（不存在对应 $x$ 的系数的 $fib_0$），但是这一组数只需要进行两次减法就可以回到原数对 $x,y$，满足要求。

对于其他情况，它的上一个数一定是 $fib_{n-1}x+fib_ny$。对这个数对不断做减法：

$fib_{n-1}x+fib_ny,fib_nx+fib_{n+1}y,fib_{n-2}x+fib_{n-1}y,fib_{n-1}x+fib_ny,\dots$

可以发现，每进行两次减法，$x$ 和 $y$ 的系数都在斐波那契数列上前移一项，最终肯定能移到 $fib_1x+fib_2y$，即 $x+y$，变为第一种情况，可以操作回原数对。

因此证明了在原数对基础上使用加法后，若能使得读入的两个数对相同，使用减法也一定能达到相同的结果（把加法操作会原数对后再继续减法就相当于在原数对上使用减法），因此，我们可以只使用减法。

使用减法的朴素算法是 $O(n)$ 的，会超时。但是可以发现减法的操作很像辗转相减的感觉，是不是也能用类似辗转相除的办法加速呢？答案是能的。

不妨设数对 $x,y$ 中 $y \ge x,y = ax + b + k$（必须要有这个 $k$，否则会把数对减到 $k$ 一下，不满足题意，这个 $k$ 相当于是个限制）。

对这个数对进行减法：

$x,ax+b+k,(a-1)x+b+k,x,(a-2)x+b+k,\dots$

可以发现 $p$ 为奇数时，每一次出现 $(a-p)x+b+k$ 都在 $x$ 之前，和初始不一样；$p$ 为偶数（包括 $0$）是恰好相反，出现在 $x$ 之后磨合初始一样。因此可以确定“类辗转相除”策略，如果减的次数是偶数次，不用交换，直接减；如果减的次数是奇数次，需要在减完后交换顺序。

减法终止条件：$y = x$（相等了） 或 $y - x < k$（一个也不能再减了）。

AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int k;
void getmin(int &a,int &b) // 要修改具体值，必须传引用
{
	while(true)
		if(a < b)
		{
			int now = (b-k)/a; // 大于k的部分还能减多少次
			if(!now) return; // 减不了也退出
			b -= now * a;
			if(now % 2 == 1) swap(b,a); // 奇数交换偶不换
		}
		else if(a > b)
		{
			int now = (a-k)/b; // 大于k的部分还能减多少次
			if(!now) return; // 减不了也退出
			a -= now * b;
			if(now % 2 == 1) swap(a,b); // 奇数交换偶不换
		}
		else return; // 相等无法变换，退出
}
int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		int x,y,xx,yy;
		scanf("%d%d%d%d%d",&x,&y,&xx,&yy,&k);
		if(k > xx || k > yy || k > x || k > y) // 不满足题目限制
		{
			printf("no\n");
			continue;
		}
		getmin(x,y); getmin(xx,yy); // 全部转化成两个数都大>=k的最小数对
		if(xx == x && yy == y) printf("yes\n"); // 同一个最小数对，满足要求
		else printf("no\n");
	}
}

```



---

## 作者：Miyamizu_Mitsuha (赞：2)

首先，如果 $k$ 大于 $x$、$y$、$a_0$ 或 $a_1$，那么肯定无法构造满足要求的数列，直接 `no`。因为每个数都不小于 $k$。

化简数对的话，直接减肯定不行，太慢了，直接 T 飞。遂辗转相除法化简 $(a_0, a_1)$ 和 $(x, y)$，让他们在满足条件的情况下尽量小。
- 如果 $a_0 > n \times a_1$（其中 $n$ 是一个偶数），则将 $(a_0, a_1)$ 变为 $(a_0 - n \times a_1, a_1)$；
- 如果 $a_1 > n \times a_0$，则将 $(a_0, a_1)$ 变为 $(a_0, a_1 - n \times a_0)$。

以上目的是化简到最小。数对就转变成了大于等于 $k$ 的最小状态。

对 $(x, y)$ 也执行同样的化简操作。

最后，判断化简后的数对 $(a_0, a_1)$ 和 $(x, y)$ 是否相等，输出  `yes`，否则输出 `no`。

```
#include <iostream>
using namespace std;

void sf(int &a, int &b, int k) {//化简
    while (true) {
        if (a < b) {
            int d = (b - k) / a;
            if (!d) break;
            b -= d * a;
            if (d & 1) swap(a, b);
        } else if (a > b) {
            int d = (a - k) / b;
            if (!d) break;
            a -= d * b;
            if (d & 1) swap(a, b);
        } else break;
    }
}

bool pd(int a, int b, int x, int y, int k) {
    if (k > x || k > y || k > a || k > b)//如果不合法直接no
        return false;
    
    sf(a, b, k);
    sf(x, y, k);//辗转除化简
    
    return (a == x && b == y);//返回结果
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        int a0, a1, x, y, k;
        cin >> a0 >> a1 >> x >> y >> k;

        if (pd(a0, a1, x, y, k)) {
            cout << "yes" << endl;
        } else {
            cout << "no" << endl;
        }
    }

    return 0;
}

```


---

## 作者：include13_fAKe (赞：2)

怎么有人 $2025$ 年了才把这个题做出来？


## 思路

### Subtask 1

考点：

- 【4】动态规划的基本思路
- 【5】广度优先搜索

设 $dp_{i,j}$ 表示连续两个数分别为 $i,j$ 的情况是否存在。转移**不记录层数**。得 $10$ 分。

### Subtask 3

考点：

- 【3】因数

直接观察 $\gcd(a_0,a_1)$ 是否等于 $\gcd(x,y)$ 即可。因为 $k=1$，所以所有数可以缩小到相关的 $\gcd$ 的值。

结合上文做法得 $20$ 分。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int x,y,x2,y2,k;
void solve(){
	cin>>x>>y>>x2>>y2>>k;
	if(__gcd(x,y)==__gcd(x2,y2))	puts("yes");
	else	puts("no");
}
int T;
signed main(){
	cin>>T;
	while(T--)	solve();
}
```


### Subtask 1,2,4

考点：

- 【3】辗转相除法（欧几里得算法）
- 【9】构造思想

考虑类辗转相除的方法。可证明加法操作没有任何意义，比如说原来两数为 $(x,y)$，往后可转移至 $(y,x+y)$，但接下来分别为 $(x+y,x)$、$(x,y)$，所以可以考虑将原来两数通过相关操作实现最小化，但要保证两点：

- 两数是有序的。
- 两数均 $\ge k$。

对 $(a_0,a_1)$ 作向后的操作，对 $(x,y)$ 作向前的操作。结合以上做法可得 $60$ 分。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int x,y,x2,y2,k;
void cal(){
	while(1){
		int abs1=abs(x-y);
		if(abs1>=k){
			x=y;
			y=abs1;
		}
		else	break;
	}
	while(1){
		int abs1=abs(x2-y2);
		if(abs1>=k){
			y2=x2;
			x2=abs1;
		}
		else	break;
	}
}
void solve(){
	cin>>x>>y>>x2>>y2>>k;
	if(x<k||y<k||x2<k||y2<k){
		puts("no");
		return;
	}
	cal();
	if(x==x2&&y==y2)	puts("yes");
	else	puts("no");
}
int T;
signed main(){
	cin>>T;
	while(T--)	solve();
	return 0;
}
```
### Subtask 5

考点：

- 【3】辗转相除法（欧几里得算法）
- 【6】时间复杂度分析
- 【9】构造思想

极端数据下，减法操作的时间复杂度很高，考虑将其降为严格的 $\log$ 级。

具体枚举 $(x,y)$ 得 $(x,y)\to(y,x-y)\to(x,y-x-x)$。

所以一次性能减完就减完，若减了奇数次就将两数交换。

预估得分 $100$ 分。

代码不到 1k 还是很好写的。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int x,y,x2,y2,k;
void cal(){
	while(1){
		//要考虑可以减多少次 
		if(abs(x-y)<k)	break;
		if(x>y){
			int now=x/y;
			int lst=x-now*y;
			if(lst<k)	now--;
			x=x-y*now;
			if(now&1)	swap(x,y);
		} 
		if(x<y){
			int now=y/x;
			int lst=y-now*x;
			if(lst<k)	now--;
			y=y-x*now;
			if(now&1)	swap(x,y); 
		}
	}
	while(1){
		if(abs(x2-y2)<k)	break;
		if(x2>y2){
			int now=x2/y2;
			int lst=x2-now*y2;
			if(lst<k)	now--;
			x2=x2-y2*now;
			if(now&1)	swap(x2,y2);
		}
		if(x2<y2){
			int now=y2/x2;
			int lst=y2-now*x2;
			if(lst<k)	now--;
			y2=y2-x2*now;
			if(now&1)	swap(x2,y2);
		}
	}
//	cout<<x<<' '<<y<<' '<<x2<<' '<<y2<<endl;
} 
void solve(){
	cin>>x>>y>>x2>>y2>>k;
	if(x<k||y<k||x2<k||y2<k){
		puts("no");
		return;
	}
	cal();
	if(x==x2&&y==y2)	puts("yes");
	else	puts("no");
}
int T;
signed main(){
	cin>>T;
	while(T--)	solve();
	return 0;
}
```

为什么场上很多人 $40$ 分的？难道真的有大家都想到的能过 Subtask #2 但过不了 Subtask #4 的做法吗。

---

## 作者：Danno0v0 (赞：1)

~~真神奇啊。~~

对于前两位 $x,y$ 求第三位 $z$ 的操作，实际上可以拆成两个操作：

- 两个数之和：$z=x+y$

- 两个数之差绝对值：$z=|x-y|$

于是我们就开始用 $x_0,x_1$ 凑 $a,b$ 。

然后发现凑的复杂度很大。

先证明可逆：

同设 $z=x+y$，则用 $z,y$ 可使用一次差绝对值凑出 $x=|z-y|$，$z=|x-y|$ 时同理。

于是我们就可以从 $x_0,x_1$ 和 $a,b$ 同时开凑。

同时同上，向大了凑（之和）其实可以与向小的凑（差的绝对值）构成可逆，意味着向大了凑能凑到则意味着向小了凑也能凑到，于是相对于那个没有上界的向大凑，显然有下界（$k$）的向小凑更合理一些。

于是我们就可以开始辗转相减直到减到下界为止，看两对数减出来是不是一样的。

然后我们发现减法很慢，于是除法加速。

这里有细节：

![](https://cdn.luogu.com.cn/upload/image_hosting/3lagtzq6.png?x-oss-process=image)

如果能减奇数次（上面的 1,3）最终位置两个数是反转的。

然后就没了。

code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,a,b,x,y,k;
void work(int &x_,int &y_)
{
	while(1)
	{
		if(x_<=y_)
		{
			int p=((y_-k)/x_);
			y_=y_-p*x_;
			if(p&1) swap(x_,y_);
			if(x_>y_) continue;
			else
			{
				if(y_-x_<k) return;
				else y_=y_-x_,swap(x_,y_);
			}
		}
		else
		{
			int p=((x_-k)/y_);
			x_=x_-p*y_;
			if(p&1) swap(x_,y_);
			if(x_<y_) continue;
			else
			{
				if(x_-y_<k) return;
				x_=x_-y_,swap(x_,y_);
			}
		}
	}
}
signed main()
{
	cin>>T;
	while(T--)
	{
		cin>>a>>b>>x>>y>>k;
		if(a<k||b<k||x<k||y<k) 
		{
			cout<<"no"<<endl;
			continue;
		}
		work(a,b),work(x,y);
		if(a==x&&b==y) cout<<"yes"<<endl;
		else cout<<"no"<<endl;
	}
}
/*
12
2 4 3 5 2
6 77 8 9 4
5 6 7 4 2
5 5 6 6 3
22 7 6 88 3
12 6 5 5 4
1 2 4 3 1
*/
```





---

## 作者：Acoipp (赞：1)

诈骗题。。。

考虑找到一个相遇点 $(b_0,b_1)$，使得 $(a_0,a_1)$ 可以变成它，并且 $(x,y)$ 可以反过来延申变成它，那么有解，否则无解，容易发现这是充要条件。

于是问题就在于如何确定 $(b_0,b_1)$，我们考虑对任意一组 $(b_0,b_1)$ 执行减法，即若 $b_0 \ge b_1$，变成 $(b_1,b_0-b_1)$，否则变成 $(b_1,b_1-b_0)$，以此类推，往左延申同理。

设最后变成了 $(c_0,c_1)$，我们考虑证明 $(c_0,c_1)$ 唯一。因为有加法的存在，所以可能会有下面的情况：

$$
(b_0,b_1) \to (b_1,b_0+b_1) \to (b_0+b_1,b_0) \to (b_0,b_1)
$$

我们惊讶的发现，在 $b_0 \ge k,b_1 \ge k$ 的情况下，一次加法可以被两次减法抵消。

于是 $(c_0,c_1)$ 一定唯一，我们对于 $(a_0,a_1)$ 找到它能够生成的最小数对；对于 $(x,y)$ 找到它能够生成的最小数对即可。

下面以 $(a_0,a_1)$ 为例，探讨一下如何快速找到最小数对：

> 设 $\lfloor \frac {a_0}{a_1} \rfloor=c \ge 1$，若 $c$ 是偶数，那么变化是这样的：$(a_0,a_1) \to (a_1,a_0-a_1) \to (a_0-a_1,a_0-2a_1) \to (a_0-2a_1,a_1) \to \dots$，最后一定是 $(a_0-ca_1,a_1)$，并且若 $a_0-ca_1 \ge k$，中途的过程也不会小于 $k$。
>
> 设 $\lfloor \frac {a_0}{a_1} \rfloor=c \ge 1$，若 $c$ 是奇数，同上，最后一定是 $(a_1,a_0-ca_1)$，并且若 $a_0-ca_1 \ge k$，中途的过程也不会小于 $k$。
>
>总结一下，若 $a_0 \ge a_1$，也就是辗转相减后，若 $c \bmod 2=1$，那么就交换两数的位置。对于 $a_1 > a_0$ 的情况同理。

于是只需要辗转相减即可，时间复杂度 $O(T \log n)$，注意当 $a_0,a_1,x,y$ 有一个 $<k$ 的时候请输出 `no`，这应该是本题唯一不好的地方了。

---

## 作者：LastKismet (赞：0)

# Sol
首先我们发现，给出当前序列最后两个值 $x,y$，那么序列下一个值只可能是 $x+y,|x-y|$。

其次我们发现一次加法可以被两次减法抵消：

$$
(x,y)\rightarrow(y,x+y)\rightarrow(x+y,x)\rightarrow(x,y)
$$

因此我们可以认为，可以凑出最后最小对相同的 $(x,y)$ 可以位于同一序列。最后最小对的意思是只考虑减法，在满足题目条件下 $(x,y)$ 能产生的序列的最后两个数。

当最后最小对相同时，由于加法可以被抵消，因此我们可以以原对为起点，任意加减得到给出的要求对。在最后最小对相同的情况下，这是显然可行的。

考虑如何计算最后最小对，每次硬减显然会爆掉，观察后可以发现性质，可以把多次大小关系不变的大减小操作合并，倘若为奇数次操作完后互换二者顺序。这样就不会爆掉了。
# Code
```cpp
pii solve(int x,int y){
    while(x!=y){
        if(x>y){
            int t=(x-k)/y;
            if(!t)break;
            x-=t*y;
            if(t&1)swap(x,y);
        }else{
            int t=(y-k)/x;
            if(!t)break;
            y-=t*x;
            if(t&1)swap(x,y);
        }  
    }
    return {x,y};
}
inline void Main(){
    read(a,b,x,y,k);
    if(a<k||b<k||x<k||y<k)return put("no");
    put(solve(a,b)==solve(x,y)?"yes":"no");
}
```

---

## 作者：czyzh (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P8348)

## 题意
称一个长度为 $n$ 的正整数数列是「$k$ - 好」的，当且仅当它满足以下条件：
对于 $1 < i < n$ ，满足 $a_{i-1}, a_i, a_{i+1}$ 中最大的一个等于其他两个之和。
所有元素都不小于 $k$ 。共 $T$ 组询问，每次询问给定 $(a_0, a_1, x, y, k)$，问是否存在「$k$ - 好」数列（长度不小于 $2$ ），前两项为 $a_0 , a_1$，并且有相邻两项依次为 $x , y$ 。

## 思路
所需数列即连续三数中，一数等于另外两数之和或差。
已知 $a_0 , a_1$，则接下来的数必为前两数和或差。又知道目标状态 $(x , y)$，可考虑倒推。于是考虑将 $(x , y)  ,(a_0 , a_1)$ 化为相同数对，可将两数对化至最简，即大于等于 $k$ 时的最小状态，因而只需将两数对一直减下去。

但直接减时间太长了，因而考虑辗转相除法，两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。这里是其变形：若数对 $(p , q)$ 中 $p > n \times q$（ $p , q$ 均相对于 $k$，且 $n$ 为偶，则可变为 $( p - nq , q )$。

减完之后判断输出即可。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 10;
inline int read(){ // 快读
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}
int T, a0, a1, x, y, k;
void cl(int &p, int &q){ // 辗转相除法
	while(true){
		if(p < q){
			int now = (q - k) / p;
			if(!now) break; // 与 k 相等，退出 
			q -= now * p;
	    	if(now & 1) swap(q, p); // & 可改为 % 
		}
		else if(p > q){
			int now = (p - k) / q;
			if(!now) break;
			p -= now * q;
			if(now & 1) swap(p, q);
		}
		else break;
	}
}
signed main(){ // define int long long 语句不能用 int main() 
	T = read();
	while(T--){
		a0 = read(), a1 = read(), x = read(), y = read(), k = read();
		if(k > x || k > y || k > a0 || k > a1){ // 如果 < k, 跳过 
			printf("no\n");
			continue;
		}
		cl(a0, a1);
		cl(x, y); // 简化数组 
		if(x != a0 || y != a1) printf("no\n");
		else printf("yes\n");
	}
	return 0;
}
```
蒟蒻第一次写题解，若有不对的望谅解，谢谢！

---


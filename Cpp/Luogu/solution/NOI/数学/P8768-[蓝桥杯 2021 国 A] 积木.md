# [蓝桥杯 2021 国 A] 积木

## 题目描述

小蓝有大量正方体的积木（所有积木完全相同），他准备用积木搭一个巨大的图形。

小蓝将积木全部平铺在地面上，而不垒起来，以便更稳定。他将积木摆成一行一行的，每行的左边对齐，共 $n$ 行，形成最终的图形。

第一行小蓝摆了 $H_{1}=w$ 块积木。从第二行开始，第 $i$ 行的积木数量 $H_{i}$ 都 至少比上一行多 $L$，至多比上一行多 $R$ (当 $L=0$ 时表示可以和上一行的积木数量相同)，即

$$
H_{i-1}+L \leq H_{i} \leq H_{i-1}+R_{\circ}
$$

给定 $x, y$ 和 $z$, 请问满足以上条件的方案中，有多少种方案满足第 $y$ 行的积木数量恰好为第 $x$ 行的积木数量的 $z$ 倍。

## 说明/提示

**【样例说明】**

符合条件的积木如图所示
![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_ca697d8d2e5bb8d06fa0g-17.jpg)

**【评测用例规模与约定】**

对于 $10 \%$ 的评测用例, $1 \leq n \leq 10,1 \leq w \leq 10,0 \leq L \leq R \leq 3$;

对于 $20 \%$ 的评测用例, $1 \leq n \leq 20,1 \leq w \leq 10,0 \leq L \leq R \leq 4$;

对于 $35 \%$ 的评测用例, $1 \leq n \leq 500,0 \leq L \leq R \leq 10$;

对于 $50 \%$ 的评测用例, $1 \leq n \leq 5000,0 \leq L \leq R \leq 10$;

对于 $60 \%$ 的评测用例, $1 \leq n \leq 20000,0 \leq L \leq R \leq 10$;

对于 $70 \%$ 的评测用例, $1 \leq n \leq 50000,0 \leq L \leq R \leq 10$;

对于 $85 \%$ 的评测用例, $1 \leq n \leq 3\times10^5,0 \leq L \leq R \leq 10$;

对于所有评测用例, $1 \leq n \leq 5\times10^5, 0 \leq w \leq 10^{9}, 0 \leq L \leq R \leq 40$, $1 \leq x<y \leq n, 0 \leq z \leq 10^{9}$ 。

蓝桥杯 2021 国赛 A 组 J 题。

## 样例 #1

### 输入

```
5 1 1 2 2 5 3```

### 输出

```
4
```

## 样例 #2

### 输入

```
233 5 1 8 100 215 3```

### 输出

```
308810105```

# 题解

## 作者：joke3579 (赞：10)

首先有一个观察是 $1\sim x-1$、$x\sim y$、$y+1\sim n$ 这三段可以分开考虑贡献再合并。  
容易发现 $y + 1\sim n$ 这一段对答案的贡献是 $(R - L + 1) ^{n - y}$，由于没有限制。

随后考虑前两个部分如何计算。

首先可以发现，从第二行开始，每一行的积木数量都落在一个区间 $[l_i,r_i]$ 内。我们尝试生成积木数量的计数。首先设 $f(t) = \sum_{i=L}^R t^i$。不难得到第 $n$ 行的生成函数为 $f(t)^{n-1}$。

我们发现目前的生成函数的最低项是非常数项，因此不妨将系数进行偏移。令

$$f(t) = \sum_{i=0}^{R-L}t^i = \frac{1 - t^{R-L+1}}{1-t}$$

第 $n$ 行的生成函数为 $f(t)^{n-1}$，这样 $[t^k]\left(f(t)^n\right)$ 对应的就是第 $n+1$ 行放 $k + w + n L$ 个积木的计数了。

然后可以枚举 $k$ 表示第 $x$ 行积木数量偏移后为 $k$ 的计数，并以此生成第 $y$ 行积木数量偏移后的值 $r$。我们可以将 $r$ 进行二次偏移，随后提取 $f(x)^{y-x}$ 的第 $r$ 项系数。  
依照上方描述，有 $r = z\times (k + w + (x - 1) \times L) - (k + w + (y - 1)\times L)$。

前两部分的答案就是 
$$\sum_{k\ge 0} [t^k]\left(f(t)^{x-1}\right)\times [t^r]\left(f(t)^{y-x}\right)$$

你可能要问了：上界呢？  
求和的上界是偏移后的上界，也就是 $f(t)^n$ 最高的度数。$f(t)$ 的度数最大是 $R - L$，在自乘最多 $n$ 次后得到求和上界 $N = n(R - L)$。

发现 $N$ 最高可能达到 $2\times 10^7$ 的范围，直接做 NTT 的复杂度是 $O(N\log N)$，显然过不去。  
你问这个方法怎么做？我们发现对 $f(t)$ 的操作只有求幂运算，不难想到首先将 $f$ 进行 DFT 后对点值求幂，再 IDFT 回来。这样就三次 DFT 得到答案。[Submission](https://www.luogu.com.cn/record/96952438).

多项式的次数无法降低，我们就需要寻找一种方法 $O(n)$ 地递推出它的系数。

不妨考虑较广泛的情况，即递推
$$g(x) = \left(\frac{1 - x^n}{1-x}\right)^m$$
的前 $k$ 项系数。

通过与[P5434](https://www.cnblogs.com/joke3579/p/chitchat221209.html)类似的手法，我们可以得到
$$\begin{aligned}

g'(x) &= \left(\left(\frac{1 - x^n}{1-x}\right)^m\right)'
\\ & = m\left(\frac{1 - x^n}{1-x}\right)^{m-1}\left(\frac{1 - x^n}{1-x}\right)'
\\ & = m\left(\frac{1 - x^n}{1-x}\right)^{m-1}\left(\frac{(1 - x^n) - nx^{n-1} (1-x)}{(1-x)^2}\right)
\\ & = m\ g(x)\left(\frac{1 - x^n}{1-x}\right)^{-1}\left(\frac{1 - x^n - nx^{n-1} + nx^n}{(1-x)^2}\right)
\\ & = m\ g(x)\left(\frac{1 - nx^{n-1} + (n-1) x^n}{(x - 1)(x^n - 1)}\right)

\end{aligned}$$

即

$$(x - 1)(x^n - 1)g'(x) = m\left(1 - nx^{n-1} + (n-1) x^n\right) g(x)$$

这自然导出了递推方案。因此可以做到 $O(N)$ 递推。

统计答案并非瓶颈，因此做到了 $O(n(R - L))$ 求解本题。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for (register int i = (a), i##_ = (b) + 1; i < i##_; ++i)
#define pre(i,a,b) for (register int i = (a), i##_ = (b) - 1; i > i##_; --i)
const int N = 2e7 + 10, mod = 998244353, g = 3;
int n, www, l, r, x, y, z, A[N], B[N], ans, len, lim;
int inv[N];

int qp(int a, int b) {
    int ret = 1;
    while (b) {
        if (b & 1) ret = 1ll * ret * a % mod;
        a = 1ll * a * a % mod;
        b >>= 1;
    } return ret;
}

void get(int f[], int n, int m) {
	f[0] = 1; 
	rep(i,1,len) {
		f[i] = f[i - 1];
		if (i - n + 1 >= 0) f[i] = (f[i] - 1ll * n * f[i - n] % mod + mod) % mod;
		if (i - n >= 0)     f[i] = (f[i] + 1ll * (n - 1) * f[i - n - 1]) % mod;
		f[i] = 1ll * f[i] * m % mod;

		if (i - 1 >= 0)     f[i] = (f[i] + 1ll * (i - 1) * f[i - 1]) % mod;
		if (i - n >= 0)     f[i] = (f[i] + 1ll * (i - n) * f[i - n]) % mod;
		if (i - n - 1 >= 0) f[i] = (f[i] - 1ll * (i - n - 1) * f[i - n - 1] % mod + mod) % mod;
		f[i] = 1ll * f[i] * inv[i] % mod;
	}
}

signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> www >> l >> r >> x >> y >> z;
	len = n * (r - l) + 1;
	inv[0] = inv[1] = 1;
	rep(i,2,len) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;

	get(A, r - l + 1, x - 1);
	get(B, r - l + 1, y - x);

	for (int i = 0, p; i < len; ++ i) {
		p = z * (www + (x - 1) * l + i) - (www + (y - 1) * l + i);
		if (p < 0) continue; if (p >= len) break;
		ans = (ans + 1ll * A[i] * B[p]) % mod;
	} cout << 1ll * ans * qp(r - l + 1, n - y) % mod;
}
```

---

## 作者：jijidawang (赞：3)

答案可以分成 $1\dots x-1$，$x\dots y$，$y+1\dots n$ 三部分 .

$y+1\dots n$ 的贡献是 $(R-L+1)^{n-y}$，后面计算 $1\dots y$ 部分 .

根据组合意义，选一次的 OGF 即为 $\displaystyle f(c)=\sum_{i=L}^Rc^i$ .

于是答案为：
$$\sum_{k\ge 0}[c^k]f^x(c)[c^{z(w+(x-1)L+k)-w-k-(y-1)L}]f^{y-x}(c)$$

其中求和因子 $k$ 表示偏移后 $x$ 行的方块个数，$z(w+(x-1)L+k)-w-k-(y-1)L$ 则为偏移后 $y$ 行的方块个数 .

关于「偏移」的详细解释见 [joke3579 闲话](https://www.cnblogs.com/joke3579/p/chitchat221210.html) .

这样有值的 $k$ 只有 $\Theta(n(R-L))$ 个，枚举求即可 .

现在问题变成求一行的 $f^m(c)$ .

这个完全等价于求 $\left(\dfrac{1-c^n}{1-c}\right)^m$，朴素实现是 $\Theta(n\log n)$ 的，然而此处的 $n$ 的范围是原题记号下 $n(R-L)$ 级别的，无法通过 .

注意到 $f^m$ 是 D-finite 的，这表明可以找到一个整式递推来描述它 .

具体的，考察
$$\begin{aligned}\dfrac{\mathrm d}{\mathrm dc}f(c)&=m\left(\dfrac{1-c^n}{(1-c)^2}-\dfrac{nc^{n-1}}{1-c}\right)\left(\dfrac{1-c^n}{1-c}\right)^{m-1}\\&=m\left(\dfrac{1-c^n}{(1-c)^2}-\dfrac{nc^{n-1}}{1-c}\right)\left(\dfrac{1-c}{1-c^n}\right)f(c)\end{aligned}$$
左右提取 $c^k$ 项系数即可得到递推式，直接暴力递推即可，总时间复杂度 $\Theta(n(R-L))$ .

代码看隔壁题解 .

---

## 作者：do_while_true (赞：3)

可能在多项式大手子面前是一个基础内容，可是菜菜只能靠青蛙一步步教导才会......因为没写代码，可能有的式子还推错了。

首先确定 $H_x$ 合法取值范围也就是 $[w+Lx,w+Rx]$，个数是 $\mathcal{O}(Rn)$ 的。

那么求出 $H_x-H_1$ 的可能的差值每种有多少个方案，$H_y-H_x$ 的可能的差值每种有多少个方案，再适当地点积起来就得到了答案。

现在问题就是求 $H_r-H_l=i$ 的方案数，令 $n=r-l$，$F$ 为答案的 OGF，则有：

$$
F=(z^L+z^{L+1}+\cdots +z^R)^n=\left(\frac{z^L-z^{R+1}}{1-z}\right)^n
$$

提出 $z^{Ln}$ 并令 $k=R+1-L$ 那么即为求 $F=\left(\frac{1-z^k}{1-z}\right)^n$ 的各项系数。

考虑对 $F$ 求导，然后尝试化成整式递推的形式。

$$
\begin{aligned}
F'&=n\cdot \left(\frac{1-z^k}{1-z}\right)^{n-1}\cdot \frac{(k-1)z^k-kz^{k-1}+1}{(1-z)^2}
\\
&=\frac{(1-z^k)^n}{(1-z)^n}\cdot \frac{n\cdot ((k-1)z^k-kz^{k-1}+1)}{(1-z)(1-z^k)}
\\
&=F\cdot \frac{n\cdot ((k-1)z^k-kz^{k-1}+1)}{(1-z)(1-z^k)}
\end{aligned}
$$

注意 $F'$ 是 $F$ 乘上一个分子分母仅有 $\mathcal{O}(1)$ 项的有理分式，通分之后得到：

$$
(1-z)(1-z^k)F'=F\cdot n\cdot ((k-1)z^k-kz^{k-1}+1)
$$

左右两边提取 $[z^m]$，即可得到 $F$ 的整式递推：

$$
(m-k)f_{m-k}-(m-k+1)f_{m-k+1}-mf_m+(m+1)f_{m+1}=n(k-1)f_{m-k}-nkf_{m-k+1}+nf_m
$$

可以 $\mathcal{O}(nk)$ 暴力计算。

---

## 作者：_lbw_ (赞：1)

将序列的差分数组分成三段，$1\to x-1,x\to y,y+1\to n$。

若能对于每段差分数组求出和为 $k$ 的方案即可。

对于差分数组每个位置减去 $l$，问题即为求 $(\sum\limits_{i=0}^Vx^i)^k$

我们知道多项式快速幂可以这样求:

$$G=F^k$$
$$(F^k)'=kF^{k-1}F'$$
$$F(F^k)'=kF^{k}F'$$
$$FG'=kGF'$$

考察两边相同项的值，对 $G$ 递推可以做到 $\mathcal{O}(nk^2)$，无法通过。

观察到 $F$ 有性质，我们维护出 $G_i,iG_i$ 的前缀和即可。

但是这种做法很卡空间，两次 DP 的数组占 $3nk$，逆元占 $nk$，完全过不去。

我们考虑每次需要的快速幂值是递增的，并且递推时只会用到前面的 $R-L+1$ 项，每次查询时滚动数组递推即可。

时间复杂度 $\mathcal{O}(n(R-L))$，DP 空间复杂度 $\mathcal{O}(R-L)$。

代码如下，部分头文件删去。

另需要注意题目中的 $w$ 可能为 $0$，数据范围有误。

```cpp
#define ll long long
using namespace std;
#define I ll
#define her1 20081214
#define IV void
#define cht 998244353
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=e[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
mt19937_64 rnd(her1);
using i64 = long long;
const int maxn = 2e7+5;
IV cadd(i64&x,i64 val){x=(x+val)%cht;}
i64 n,w,L,R,x,y,z,dp1[205],dp2[205],s1[205][2],s2[205][2];int inv[maxn];
i64 qpow(i64 n,i64 base=cht-2){
	i64 ans=1;
	while(base){
		if(base&1)ans=ans*n%cht;
		n=n*n%cht;base>>=1;
	}
	return ans;
}
const i64 Mo = 100;
i64 m1,m2,V;
i64 Id(i64 v){return(v%Mo+Mo)%Mo;}
i64 calc1(i64 x,i64 n){
	i64 V=R-L;
	while(m1<x){
		m1++;
		i64 orz=0;
		dp1[Id(m1)]=(
			n*m1%cht*(s1[Id(m1-1)][0]-(m1>=V+1?s1[Id(m1-1-V)][0]:0))%cht-
			(n+1)*(s1[Id(m1-1)][1]-(m1>=V+1?s1[Id(m1-1-V)][1]:0))%cht
		)*inv[m1]%cht;
		s1[Id(m1)][0]=(s1[Id(m1-1)][0]+dp1[Id(m1)])%cht;
		s1[Id(m1)][1]=(s1[Id(m1-1)][1]+dp1[Id(m1)]*m1)%cht;
	}
	return dp1[Id(m1)];
}
i64 calc2(i64 x,i64 n){
	i64 V=R-L;
	while(m2<x){
		m2++;
		i64 orz=0;
		dp2[Id(m2)]=(
			n*m2%cht*(s2[Id(m2-1)][0]-(m2>=V+1?s2[Id(m2-1-V)][0]:0))%cht-
			(n+1)*(s2[Id(m2-1)][1]-(m2>=V+1?s2[Id(m2-1-V)][1]:0))%cht
		)*inv[m2]%cht;
		s2[Id(m2)][0]=(s2[Id(m2-1)][0]+dp2[Id(m2)])%cht;
		s2[Id(m2)][1]=(s2[Id(m2-1)][1]+dp2[Id(m2)]*m2)%cht;
	}
	return dp2[Id(m2)];
}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();w=read();L=read();R=read();x=read();y=read();z=read();
	if(!z){
		if(w||L)return puts("0"),0;
		return cout<<qpow(R-L+1,n-y),0;
	}
	inv[0]=0;inv[1]=1;F(i,2,n*R)inv[i]=(cht-1ll*inv[cht%i]*(cht/i)%cht)%cht;
	dp1[0]=s1[0][0]=1;s1[0][1]=0;
	dp2[0]=s2[0][0]=1;s2[0][1]=0;
	V=R-L;
	
	i64 lim1=(x-1)*R,lim2=(y-x)*R,Ans=0;
	F(i,(x-1)*L,lim1){
		i64 v=(z-1)*(w+i);
		if(v<(y-x)*L||v>lim2)continue;
		cadd(Ans,calc1(i-(x-1)*L,x-1)*calc2(v-(y-x)*L,y-x));
	}
	return cout<<(Ans*qpow(R-L+1,n-y)%cht+cht)%cht,0;
}
```

---

## 作者：Mashu77 (赞：0)

随便推一下，就是求 
$(\sum\limits_{i=0}^{R-L}x^i)^n$
 的各项系数。其长度为 
$2
×
10^
7$
 级别，不能 
$O
(
n
\log
n
)$。这里需要一种 
$O
(
n
)$
 解法。

我们设 
$F(x)=(\sum\limits_{i=0}^{k-1}x^i)^n=(\frac{x^k-1}{x-1})^n$。这里主要利用后面那个等式。

$\begin{aligned}
F'(x)&=\left(\left(\frac{x^k-1}{x-1}\right)^n\right)'\\
&=n\left(\frac{x^k-1}{x-1}\right)^{n-1}\cdot\frac{kx^k-kx^{k-1}-x^k+1}{(x-1)^2}\\
&=nF(x)\cdot\frac{kx^k-kx^{k-1}-x^k+1}{(x-1)(x^k-1)}\\
(x^{k+1}-x^k-x+1)F'(x)&=(nkx^k-nkx^{k-1}-nx^k+n)F(x)
\end{aligned}$

左右提取 
$[
x^
m
]$
 即可得到线性递推式。

此题技巧在于对一个 
OGF
 的两种表达形式求导。

---


# [湖南集训] 图森

## 题目描述

有一个字符串集合 $S$，此处集合的概念与数学中的集合不同，其中可以含有重复的元素。初始时 $S$ 包含 $n$ 个字符串 $s_1, s_2, \cdots, s_n$。有下面两种操作：

- 向 $S$ 中加入一个已经存在于 $S$ 中的字符串。
- 从 $S$ 中选出两个字符串，将这两个字符串拼接得到的字符串加入集合 $S$。

现在想要知道，进行任意多次操作之后，在 $S$ 中的所有字符串中，最长的回文子串可以有多长？如果发现长度可以是无穷大，这时你需要输出 $\text{Infinity}$。

## 说明/提示

#### 样例解释

第一个样例中，将 $\text{ecab}$ 与 $\text{abacde}$ 拼接，得到 $\text{e}\underline{\text{cababac}}\text{de}$，其中下划线的部分就是最长的回文子串，长度为 $7$。可以证明不存在更长的回文子串。

第二个样例中，可以将任意多个 $\text{ha}$ 拼接起来，从而得到 $\underline{\text{h}}\text{a},$ $\underline{\text{hah}}\text{a},$ $\underline{\text{hahah}}\text{a}$ 等任意奇数长度的回文子串。因此答案为无穷大，输出 $\text{Infinity}$。

#### 数据规模与约定
![OvO](https://cdn.luogu.com.cn/upload/pic/55026.png)

## 样例 #1

### 输入

```
3
abc
abacde
ecab```

### 输出

```
7```

## 样例 #2

### 输入

```
1
ha```

### 输出

```
Infinity```

# 题解

## 作者：dspt (赞：4)

据我所知，这题原名叫：图样图森破，意思是：too young too simple

网上题解比较少，感觉略显复杂，于是我写了篇题解，思路应该算比较简单，但有些部分缺少严谨的证明。

约定：对于字符串 $T$，记 $|T|$ 表示 $T$ 的长度，$T_i$ 为 $i$ 个 $T$ 拼接得到的字符串，$T[l:r]$ 表示 $T$ 从第 $l$ 个字符开始到第 $r$ 个字符构成的子串，$s_{i,j}$ 表示 $s_i$ 的第 $j$ 个字符，记 $\text{R}(T)$ 为 $T$ 翻转后得到字符串。

---

考虑 $n=1$ 的情况，手玩可以发现，设仅有的字符串为 $T$，若 $T_2$ 有一个回文子串 $T_2[l:r]$ 满足：$(l=1\lor r=2|T|) \land (r-l+1\ge|T|)$，答案即为 Infinity，否则答案为 $\max|T_2[l:r]|$。 

说人话就是，$n=1$ 并且答案为 Infinity 的情况有如下两种：

1. $T$ 本身是回文串

2. $T_2$ 有一个回文子串，这个回文子串在 $T_2$ 的边界处，并且 $T$ 是这个回文串的子串。

   其实可以感性归纳证明。例如 $|T|=7$，$T_2[1:9]$ 的是一个回文字符串，在 $T_2$ 左侧再拼一个 $T$，则 $T_3[8:16]$ 是一个回文串。由回文串的性质得 $T_3[17:21]=T_3[3:7]=\text R(T_3[3:7])$，即将 $T_3[8:16]$ 拓展到 $T_3[3:21]$，$T_3[3:21]$ 也是一个回文串，这样就把回文串的长度由 $[|T|+1,2|T|)$ 拓展到了 $[2|T|+1,3|T|)$。由归纳法，回文串长度可以无限拓展，故答案为 Infinity。

好消息是第一种情况包含于第二种情况，我们只需要判断一下 $T_2$ 是否有在边界并且长度大于 $|T|$ 的回文字符串即可。如果答案不为 Infinity，则答案为 $T_2$ 的最长回文子串的长度。若 $n>1$，此长度为答案下界（现在的五个 Hack 就是 Hack 这里）。

回文匹配的话可以用 Manacher 或者二分哈希，当然我们后面还需要解决 $n>1$ 的情况，所以用二分哈希更合适。将每个串及其反串分别预处理哈希值，可以在 $O(1)$ 的时间内取出一个子串的哈希值。我们只需要枚举回文中心的一两个字符，二分向两侧拓展至最大长度即可。

至此，$n=1$ 的情况就处理完了，注意到 $n=1$ 的 $L$ 为 100000，比其它情况的 $L$ 要大很多，所以要特判。

---

考虑 $n>1$ 的情况，设某个时刻答案来自于字符串 $T$。容易发现，对于任何一个 $T$，我们并不关心其内部构造，我们只需要知道 $T$ 的端点分别在哪两个字符串中就好了，记 $f_{i,l,j,r}$ 表示左端点为 $s_{i,l}$ ，右端点为 $s_{j,r}$ 的 $T$ 的最大回文子串长度。并且我们限制任意一个状态无法拓展，即 $l=1\lor r=|s_j|\lor s_{i,l-1}\neq s_{j,r+1}$。

那么状态可以转移当且仅当 $l=1\lor r=|s_j|$。若 $l=1\land r=|s_j|$，则 $T$​ 本身为回文串，答案为 Infinity。考虑剩下的转移：

若 $l=1$，代表可在 $T$ 的左侧加上满足 $s_{k,|sk|}=s_{j,r+1}$ 的 $s_k$，并向两侧拓展。

若 $r=|s_j|$，代表可在 $T$ 的右侧加上满足 $s_{k,1}=s_{i,l-1}$ 的 $s_k$，并向两侧拓展。

容易发现转移构成了一个图，并且这个图上是有环的。这时我们令 $w=10^5\ge nL$，若某一时刻答案超过 $w$，则认为答案为 Infinity。

但是这个状态也太多了，我们需要考虑优化。注意到若 $l>1\land r<|s_j|$，这个状态没有出边，在这个答案更新完后我们直接丢弃这个状态。也就是说，现在需要转移的状态要么 $l=1$ 要么 $r=|s_j|$，那就可以舍弃 $l,r$ 这两维，加入一维 $k$ 表示这两种情况是哪种。

这类似于动态规划的过程，但我们没法找到一个合适的 DP 顺序，又因为转移构成了一张图，可以用 BFS 进行这个过程。一开始，我们先对每个字符串本身进行暴力拓展，找到一个可以往下转移的情况，把它加入队列。注意，还有种情况是开始的回文字符串是偶数，且回文分界线在两个字符串之间，比如 $s_1=\tt cedba$，$s_2=\tt bad$，这时就要把  $(1,3,1)$ 加入队列（第三个元素为 0 表示 $l=1$，为 1 表示 $r=|s_j|$）。另外我们还可以使用一些剪枝技巧，若某个状态出队时，发现自己的答案小于 $f_{i,j,k}$，即在它待在队列里的这段时间，状态 $(i,j,k)$ 的答案已经被更新过了，这时可以直接暂时不更新这个状态。

关于此方法的正确性和时间复杂度，我不是特别清楚，但可以通过原题数据和现在的五个 Hack 数据。我的哈希常数比较大，当 $n=1$ 时，$O(L\log L)$ 的算法最慢的点用时在 0.9s 左右，当 $n>1$ 时，$O(n^2L\log L)$ 的算法最慢的点用时在 0.5s 左右。

---

代码：4.08 KB，4.06 s

写了注释，应该算比较简洁易懂了吧。自己写的时候压行压到了 65 行，代码仅有 3.46 KB。

```cpp
#include <queue>
#include <time.h>
#include <random>
#include <iostream>
using namespace std;
typedef const int ci; ci p((1 << 30) - 35); // 哈希模数
int a[200002] = {1}, b[200002] = {1}; // 多项式哈希，每位的幂值和逆元
int c[26], f[101][1001][2];           // 每个字母的哈希值，(i,j,k) 的答案
struct hash {
    int m; string s; vector<int> h[2]; // 哈希表，h0 为正向哈希表，h1 为逆向哈希表
    void init(const int t) { h[0].resize(t + 2); h[1].resize(t + 2); } // 初始化
    void build() // 建哈希表
    {
        for (int i(1); i <= m; ++i) h[0][i] = ((long long)c[s[i] - 'a'] * a[i] + h[0][i - 1]) % p;
        for (int i(m); i; --i) h[1][i] = ((long long)c[s[i] - 'a'] * a[m - i + 1] + h[1][i + 1]) % p;
    }
    void read() { cin >> s; m = s.size(); s = ' ' + s; build(); }
    int get(ci l, ci r, const bool t) // 查询 s[l:r] 的哈希值，t = 0 则为正向，t = 1 则为反向
    {
        return (t ? (long long)(h[1][l] - h[1][r + 1] + p) * b[m - r + 1]
                  : (long long)(h[0][r] - h[0][l - 1] + p) * b[l]) % p;
    }
} e[101];
int expand(ci i, ci l, ci j, ci r) // 二分，现在的状态左端点为 s(i,l) 右端点为 s(j,r)，返回可以向左和向右的最大长度
{
    int L(1), R(min(l - 1, e[j].m - r)), p(0);
    while (L <= R)
        if (ci t(L + R >> 1); e[i].get(l - t, l - 1, 0) == e[j].get(r + 1, r + t, 1)) p = t, L = t + 1;
    	else R = t - 1;
    return p;
}
struct node { int i, j, v; bool k; }; queue<node> q; // BFS 队列
int main()
{
    mt19937 r(time(0)); uniform_int_distribution<int> d(1, p - 1);
    for (int i(0); i < 26; ++i) c[i] = d(r); // 处理每个字符的哈希值，用 mt19937 提高准确性，放止被卡
    for (int i(1); i <= 2e5; ++i)
        a[i] = (long long)a[i - 1] * 1073741783 % p, b[i] = (long long)b[i - 1] * 894784824 % p;
    	// 处理每位的哈希值，1073741783 是一个大质数，894784824 是它在 mod p 意义下的逆元
    int n, w(0); cin >> n;
    // 为了方便，用 e[0] 记录 TT，大小要开两倍
    if (n == 1) e[0].init(2e5); else e[0].init(2e3); // 如果 n = 1，初始化的大小为 2e5
    for (int i(1); i <= n; ++i) e[i].init(n < 2 ? 1e5 : 1e3), e[i].read();
    #define INF { cout << "Infinity\n"; return 0; } // 答案为 Infinity，结束程序
    #define push(x, y) if (L == 1 && R == e[y].m) INF \ 
                       if (t > w) w = t; if (w > 1e5) INF \
                       if (L == 1) if (f[y][R][0] < t) q.emplace((node){y, R, f[y][R][0] = t, false}); \
                       if (R == e[y].m) if (f[x][L][1] < t) { q.emplace((node){x, L, f[x][L][1] = t, true}); }
					 // 将 (x, L, y, R) 弹入队列 更新答案，若答案超过 1e5，答案为 Infinity
    for (int i(1); i <= n; ++i)
    {
        for (int j(1); j <= e[i].m; ++j) e[0].s = e[i].s + e[i].s.substr(1);
        e[0].m = e[i].m << 1; e[0].h[1][e[0].m + 1] = 0; e[0].build(); // 构建 TT
        for (int j(1); j <= e[0].m; ++j) // 长度为奇数
        {
            ci k(expand(0, j, 0, j)), L(j - k), R(j + k); if ((k << 1 | 1) > w) w = k << 1 | 1;
            if (L <= e[i].m && R > e[i].m && (L == 1 || R == e[0].m)) INF
        }
        for (int j(1); j < e[0].m; ++j) if (e[0].s[j] == e[0].s[j + 1]) // 长度为偶数
        {
            ci k(expand(0, j, 0, j + 1)), L(j - k), R(j + 1 + k); if ((k + 1 << 1) > w) w = k + 1 << 1;
            if (L <= e[i].m && R > e[i].m && (L == 1 || R == e[0].m)) INF
        }
        if (n == 1) { cout << w << '\n'; return 0; } // n = 1，程序可以直接结束
        // 用 t 记录拓展后的答案
        for (int j(1); j <= e[i].m; ++j) { ci k(expand(i, j, i, j)), L(j - k), R(j + k), t(k << 1 | 1); push(i, i) }
        for (int j(1); j < e[i].m; ++j) if (e[i].s[j] == e[i].s[j + 1])
        { ci k(expand(i, j, i, j + 1)), L(j - k), R(j + 1 + k), t(k + 1 << 1); push(i, i) }
    }
    // 字符串子串长度为偶数，且中心分界线正好在两个字符串之间的情况分别枚举两个字符串即可
    for (int i(1); i <= n; ++i) for (int j(1); j <= n; ++j)
    { ci k(expand(i, e[i].m + 1, j, 0)), L(e[i].m + 1 - k), R(k), t(k << 1); if (k) { push(i, j); } }
    while (!q.empty()) { // BFS 更新
        const node u(q.front()); q.pop();
        for (int i(1); i <= n; ++i)
        if (u.k) {
            ci k(expand(u.i, u.j, i, 0)), L(u.j - k), R(k), t(u.v + (k << 1));
            if (k) { push(u.i, i) }
        } else {
            ci k(expand(i, e[i].m + 1, u.i, u.j)), L(e[i].m + 1 - k), R(u.j + k), t(u.v + (k << 1));
            if (k) { push(i, u.i) }
    }	} cout << w << endl; return 0;
}
```

---

## 作者：zjy2008 (赞：3)

现有的题解都没有对复杂度的正确证明，我就来补一篇吧。

根据前人的题解，我们知道 dp 状态的转移是一个 $O(nL)$ 个点，$O(n^2L)$ 条边的有向有权图，容易发现这里面没有长度为 $0$ 的环，所以我们可以直接 $1$ 次 bfs 求出所有可能被到达的状态，然后判断是否存在拓扑序以判 ```Infinity```。然后直接按拓扑序 dp 。

综上，此题总复杂度 $O(n^2L)$。代码可以参考 [剪切板](https://www.luogu.com.cn/paste/7kbvnfzz) 。细节很多。

---

## 作者：DiDi123 (赞：2)

这道题相当于让我们求出来这 $n$ 个字符串任意拼接能够成的字符串的最长回文子串的长度。

对于回文子串，首先的想法就是枚举一下对称中心，然后我们就可以交替拼接字符串了。如果当前时刻拼出来的串除了回文子串以外两端都多一点，那么即使继续拼字符串的话也不会是这个中心的回文子串更长了。如果刚好拼出来一个完整的回文串，那么答案一定是 $\infty$。而如果当前拼出来的字符串只比最长的回文子串多出来一端，为了使回文子串更长，我们就需要在另一端继续拼字符串。我们记 $\overline{s}$ 表示 $s$ 的反串。不妨设当前的字符串为 $ts$，其中 $t$ 是回文串。那么我们会想在 $t$ 的左边拼上一些字符串使得回文子串更长。假设我们拼上一个字符串 $s'$ 使得当前的串变为 $s'ts$，那么这个串能继续往下拼有两种情况。第一种就是 $\overline{s}$ 是 $s'$ 的一个后缀，那么下一次我们就往右拼。第二种就是 $\overline{s'}$ 是 $s$ 的一个前缀，这样我们还需要继续拼左边的。

那么我们可以进行一下 dp，记 $f[i][j][k][p]$ 表示已经拼了 $i$ 个字符串，当前露出来（即不属于回文子串的部分）的状态是 $p$（$0$ 代表左边，$1$ 代表右边），露出来第 $j$ 个字符串的 $k$ 个字符时回文子串的最长长度。由于我们还需要枚举对称中心，这样的 dp 是 $\mathcal O(kn^2L^2)$ 的（$k$ 表示最多拼的字符串数），似乎可能只能过 $n=1$ 的点 qwq。

于是我们考虑进行优化。首先第一维的大小不好知道，粗略的估计的话是 $nL$ 的，直接爆炸。但是发现我们能进行的转移其实非常有限，所以很多的空间都被浪费掉了。于是我们考虑直接把第一维扔掉，然后根据转移关系进行建图，然后再跑最长路求得答案。并且，我们发现其实枚举每个回文串的中心也是不必要的，我们可以直接对于每个给定的串求它的回文子串的情况，然后给多个初始的点赋大于等于 $0$ 的 $dis$ 表示可以从这个点出发。

具体来讲，我们设一个点为 $(x,y,z)$ 表示当前串露出的状态为 $z$，并且露出第 $x$ 个字符串的 $y$ 个字符。然后我们枚举 $s_i$ 和 $\overline{s_j}$ 的前后缀匹配情况，根据上文所属的转移方法进行连边，边权就是两倍的匹配长度。特别的，对于无法继续转移的情况，我们需要新建一个点，保证这个点无出边，然后让当前状态的点连向这个点。这个时候确定边权我们需要二分一下第 $i$ 个串的前/后缀和第 $j$ 个串的前/后缀的匹配长度，再进行连边。让后为了确定初始状态，我们需要把所有串的前/后缀回文子串的长度计算出来，设置它们的 $dis$ 为回文串的长度。最后我们再跑一遍 spfa 就行了。需要注意的是需要特判 $n=1,L\leq10^5$ 的那个点。复杂度是 $\mathcal O(kn^2L+n^2L\log L)$（$k$ 是 spfa 的系数）。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define base 131
#define MAXN 400010
typedef unsigned long long ull;
int n,len[110],id[110][1010][2],p[MAXN],pre[MAXN];
ull hs[110][1010],hr[110][1010],pp[1010];
string s[110],rs[110];
struct edge
{
	int to,nex,w;
}Edge[MAXN*100];
int head[MAXN],cnt,ct;
void add(int u,int v,int w)
{
	Edge[cnt].to=v;
	Edge[cnt].w=w;
	Edge[cnt].nex=head[u];
	head[u]=cnt++;
}
int dis[MAXN],v[MAXN];
ull query(int x,int l,int r)
{
	return hs[x][r]-hs[x][l-1]*pp[r-l+1];
}
ull rquery(int x,int l,int r)
{
	l=len[x]-l+1,r=len[x]-r+1;
	swap(l,r);
	return hr[x][r]-hr[x][l-1]*pp[r-l+1];
}
int manacher(string ss)
{
	string t;
	int ans=0;
	t+='*';
	for(int i=0;i<ss.size();i++) t+=ss[i],t+='*';
	int tn=t.size();
	t=' '+t+'!'; //防止溢出
	int rm=0,dm;
	for(int i=1;i<=tn;i++)
	{
		if(i>rm) p[i]=1;
		else p[i]=min(rm-i+1,p[2*dm-i]);
		while(t[i+p[i]]==t[i-p[i]]) p[i]++;
		if(i+p[i]-1>rm) rm=i+p[i]-1,dm=i; 
	}
	for(int i=1;i<=tn;i++)
		ans=max(ans,p[i]-1);
	return ans;
}
queue <int> q;
void spfa()
{
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		v[x]=0;
		for(int i=head[x];i!=-1;i=Edge[i].nex)
		{
			int y=Edge[i].to;
			if(dis[y]<dis[x]+Edge[i].w)
			{
				dis[y]=dis[x]+Edge[i].w;
				pre[y]=x;
				if(dis[y]>=1e6)
				{
					puts("Infinity");
					exit(0);
				}
				if(!v[y]) v[y]=1,q.push(y);
			}
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	memset(dis,0xcf,sizeof(dis));
	cin>>n;
	if(n==1)
	{
		cin>>s[1];
		int t1=manacher(s[1]+s[1]);
		int t2=manacher(s[1]+s[1]+s[1]);
		if(t1!=t2) puts("Infinity");
		else cout<<t1;
		return 0;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i],len[i]=s[i].size();
		ans=max(ans,manacher(s[i]));
		rs[i]=s[i],reverse(rs[i].begin(),rs[i].end());
		s[i]=' '+s[i],rs[i]=' '+rs[i];
	}
	pp[0]=1;
	for(int i=1;i<=1000;i++) pp[i]=pp[i-1]*base;
	for(int i=1;i<=n;i++) id[i][0][0]=++ct,id[i][0][1]=++ct;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=len[i];j++)
		{
			hs[i][j]=hs[i][j-1]*base+s[i][j]-'a'+1;
			hr[i][j]=hr[i][j-1]*base+rs[i][j]-'a'+1;
			id[i][j][0]=++ct,id[i][j][1]=++ct;
		}
	for(int i=1;i<=n;i++)
		dis[id[i][len[i]][0]]=dis[id[i][len[i]][1]]=0;
	for(int i=1;i<=n;i++) //如果能凑出来回文串，答案一定是INF
		for(int k=0;k<=1;k++)
			add(id[i][0][k],id[i][0][k],1e6);
	for(int i=1;i<=n;i++) //枚举第i个串的后k个字符和第j个串匹配
		for(int j=1;j<=n;j++)
			for(int k=1;k<=len[i] && k<=len[j];k++)
				if(query(i,len[i]-k+1,len[i])==rquery(j,len[j]-k+1,len[j]))
					add(id[i][k][1],id[j][len[j]-k][0],2*k);
	for(int i=1;i<=n;i++) //枚举第i个串的前k个字符和第j个串匹配
		for(int j=1;j<=n;j++)
			for(int k=1;k<=len[i] && k<=len[j];k++)
				if(query(i,1,k)==rquery(j,1,k))
					add(id[i][k][0],id[j][len[j]-k][1],2*k);
	for(int i=1;i<=n;i++) //枚举串的包含关系
		for(int j=1;j<=n;j++)
			for(int k=1;k<=len[i] && k<=len[i]-len[j]+1;k++)
				if(query(i,k,k+len[j]-1)==rquery(j,1,len[j]))
					add(id[i][len[i]-k+1][1],id[i][len[i]-len[j]-k+1][1],2*len[j]);
	for(int i=1;i<=n;i++) //枚举串的包含关系
		for(int j=1;j<=n;j++)
			for(int k=len[j];k<=len[i];k++)
				if(query(i,k-len[j]+1,k)==rquery(j,1,len[j]))
					add(id[i][k][0],id[i][k-len[j]][0],2*len[j]);
	ct++; //不能继续转移的点
	for(int i=1;i<=n;i++) //枚举两个串拼起来之后两端都剩下一点的情况
		for(int j=1;j<=n;j++)
			for(int k=1;k<=len[i];k++)
			{
				int l=1,r=min(len[j],len[i]-k+1),mid;
				while(l<=r)
				{
					if(l==r)
					{
						if(l!=min(len[j],len[i]-k+1) && s[i][k]==s[j][len[j]])
							add(id[i][len[i]-k+1][1],ct,2*l);
						break;
					}
					mid=(l+r+1)>>1;
					if(query(i,k,k+mid-1)==rquery(j,len[j]-mid+1,len[j])) l=mid;
					else r=mid-1;
				}
			}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=len[i];k++)
			{
				int l=1,r=min(len[j],k),mid;
				while(l<=r)
				{
					if(l==r)
					{
						if(l!=min(len[j],k) && s[i][k]==s[j][1])
							add(id[i][k][0],ct,2*l);
						break;
					}
					mid=(l+r+1)>>1;
					if(query(i,k-mid+1,k)==rquery(j,1,mid)) l=mid;
					else r=mid-1;
				}
			}
	for(int i=1;i<=n;i++)
		for(int k=1;2*k<=len[i]+1;k++)
		{
			if(2*k<=len[i] && query(i,1,k)==rquery(i,k+1,2*k))
				dis[id[i][len[i]-2*k][1]]=2*k;
			if(query(i,1,k)==rquery(i,k,2*k-1))
				dis[id[i][len[i]-2*k+1][1]]=2*k-1;
			if(2*k<=len[i] && query(i,len[i]-k+1,len[i])==rquery(i,len[i]-2*k+1,len[i]-k))
				dis[id[i][len[i]-2*k][0]]=2*k;
			if(query(i,len[i]-k+1,len[i])==rquery(i,len[i]-2*k+2,len[i]-k+1))
				dis[id[i][len[i]-2*k+1][0]]=2*k-1;
		}
	for(int i=1;i<=ct;i++)
		if(dis[i]>=0) q.push(i),v[i]=1;
	spfa();
	for(int i=1;i<=ct;i++) ans=max(ans,dis[i]);
	cout<<ans;
}
```


---

## 作者：Nephren_Sakura (赞：2)

第一次场切黑题，纪念一下。

题目大意：给定一个字符串的集合 $S$，你可以执行两种操作：

1. 加入一个已经存在于 $S$ 的字符串。

2. 选择 $S$ 中两个字符串，拼接后将其加入 $S$。

求进行任意多次操作后，$S$ 中所有字符串中最长的回文子串长度，如果可以无限长，输出 `Infinity`。

我们首先考虑转化题意。这两种操作可以无限执行，那么等同于你从 $S$ 中选出任意数量且可以重复的字符串，将它们以任意顺序拼接，要求最后的字符串最长回文子串长度尽量长。

看到回文子串，考虑经典 trick，也就是固定回文子串的中间位置，然后往左右拓展。

然后你手模一下这个拓展的过程，你会发现，如果你枚举到的这个位置在它所在的串里被拦截下来了，无法拓展出去，那么无论你加多少别的字符串，都无法使答案增加。

继续思考，如果一个位置没有被拦截下来，那么它所在的字符串一定被消除到了只剩下前缀或后缀，而这样的前缀或后缀总共只有 $n \times L$ 种。

然后你考虑，比如说当你剩下一个后缀 $s1$，在当前串前拼上另一个字符串 $s2$，除非你能把 $s1$ 和 $s2$ 中的一个消除完，否则依旧无法拓展下去。而你消除完之后，剩下的字符串又会是 $s1$ 的后缀或 $s2$ 的前缀！

那么想到这里你就可以进行 dp 了。设 $dp_{i,j,0/1}$ 表示当前剩下的串是第 $i$ 个字符串的第 $j$ 位开始的前缀/后缀，最长的回文子串长度是多少。转移枚举所有 $n$ 个字符串，依次试图加入到另外一边，看**长度较短的一边**是否在加入以后被完全消除。

那么 dp 的初始状态是什么呢？回想一下，我们取一段前后缀是不是必须要**原串中另一段后缀/前缀**被消除了。换言之，就是**另一段后缀/前缀**恰好是一个回文串。那么我们新建一个超级源点（因为等下要判 Infinity），对满足条件的前后缀连边即可。

然后我们把 dp 的转移也抽象成一条边，转移时**回文子串加的长度**就是边权。如果我们发现枚举的前后缀恰好完全抵消，就连一条到超级源点的边。那么如果无解，在最后的图中等同于存在一个经过超级源点的环，可以轻松判定。

还没完，现在求出来的 dp 值是只留下了一段前后缀的。拿前缀举例，我们是可以在这段前缀后面拼接一个字符串的。虽说不能完全消除，但是能消除一部分，使答案增加。我们在最后对每一个前后缀枚举拼接的串，跑一个二分哈希，但这样会多一个 log，并且常数巨大，可能无法通过。

怎么办呢？其实是有简单的处理办法的，直接拿个桶记录一下即可，但笔者场上脑子抽了没想到，下面介绍个人场上的做法，会桶的可以直接跳过了。

我们注意到，如果一次二分哈希不会使答案增大，那么这次二分哈希可以不做。于是我们考虑每次跑二分哈希之前先判断一下最小的 $x$ 使得答案会变大，这样做就需要跑**答案变大次数**次二分哈希。而根据又一个经典 trick，长度为 $len$ 随机序列的前缀 max 变化次数是 $O(\log len)$ 的，也就是我们至多执行 $\log n\times L$ 次二分哈希，这样我们就解决了这道题。

上面那个结论的证明：考虑序列中最大值的出现位置，期望位置在序列中点处。取前一半重复以上操作，可得期望变化次数不会超过 $\log len$ 次。

然后注意一点，有可能你选择不拼接任何字符串，也有可能原串中存在回文串，都需要判一下。而且细节很多，最后会给出一组 hack 数据，可以自行取用。

注：考试时没有单字符串长度不超过 $10^3$，只有总长度不超过 $10^5$，有些地方写的比较抽象。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long base=131;
const long long mod=10000000000002137;
long long dp[200005],hs[200005],pw[1000005];
int Jormungandeur,N,len[1000005];
int in[200005],sum,val;
long long youhua0[200005],youhua1[200005];
bool vis[200005];
int id[105][100005][2],cnt;
long long ls[200005];
queue<int> q;
vector<pair<int,int> > v[1000005];
string s[105];
long long help(int ID,int l,int r,bool f){
	if(!f) return (hs[id[ID][r][f]]-(__int128)hs[id[ID][l-1][f]]*pw[r-l+1]%mod+mod)%mod;
	else return (hs[id[ID][l][f]]-(__int128)hs[id[ID][r+1][f]]*pw[r-l+1]%mod+mod)%mod;
}//哈希
void pre(int cur){
	sum++;
	vis[cur]=true;
	for(auto p:v[cur]) if(!vis[p.first]) pre(p.first);
	return;
}
map<string,bool> mp;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	memset(dp,0xcf,sizeof dp);
	pw[0]=1;
	for(int i=1; i<=1000000; i++) pw[i]=pw[i-1]*base%mod;
	cin>>N;
	for(int i=1; i<=N; i++) cin>>s[i];
	for(int i=1; i<=N; i++) if(!mp[s[i]]) mp[s[i]]=true;else swap(s[i],s[N]),N--;
	random_shuffle(s+1,s+N+1);
	for(int i=1; i<=N; i++) len[i]=s[i].size(),s[i]=" "+s[i];
	for(int i=1; i<=N; i++){
		for(int j=1; j<=len[i]; j++) {ls[j]=(ls[j-1]*base+s[i][j]-'a'+1)%mod,id[i][j][0]=++cnt,hs[cnt]=ls[j];}
		ls[len[i]+1]=0;
		for(int j=len[i]; j>=1; j--) {ls[j]=(ls[j+1]*base+s[i][j]-'a'+1)%mod,id[i][j][1]=++cnt,hs[cnt]=ls[j];}
		if(help(i,1,len[i],0)==help(i,1,len[i],1)){cout<<"Infinity";return 0;}
	}
	for(int i=1; i<=N; i++) for(int j=1; j<=len[i]; j++) youhua0[id[i][j][0]]=help(i,j,len[i],0),youhua1[id[i][j][1]]=help(i,1,j,1);//卡常，哈希常数巨大
	cnt++;
	for(int i=1; i<=N; i++){
		for(int j=1; j<=len[i]; j++){
			if(help(i,j+1,len[i],0)==hs[id[i][j+1][1]]||j==len[i]) v[cnt].push_back({id[i][j][0],len[i]-j});
			for(int k=1; k<=N; k++){
				if(len[k]>j&&hs[id[i][j][0]]==youhua1[id[k][j][1]]) v[id[i][j][0]].push_back({id[k][j+1][1],2*j});
				else if(len[k]<j&&help(i,j-len[k]+1,j,0)==hs[id[k][1][1]]) v[id[i][j][0]].push_back({id[i][j-len[k]][0],2*len[k]});
				else if(len[k]==j&&hs[id[i][j][0]]==hs[id[k][1][1]]) v[id[i][j][0]].push_back({cnt,2*j});
			}
		}
	}//前缀建边
	for(int i=1; i<=N; i++){
		for(int j=1; j<=len[i]; j++){
			if(help(i,1,j-1,0)==help(i,1,j-1,1)||j==1) v[cnt].push_back({id[i][j][1],j-1});
			for(int k=1; k<=N; k++){
				if(len[k]>len[i]-j+1&&hs[id[i][j][1]]==youhua0[id[k][len[k]-len[i]+j][0]]) v[id[i][j][1]].push_back({id[k][len[k]-(len[i]-j+1)][0],2*(len[i]-j+1)});
				else if(len[k]<len[i]-j+1&&help(i,j,j+len[k]-1,1)==hs[id[k][len[k]][0]]) v[id[i][j][1]].push_back({id[i][j+len[k]][1],2*len[k]});
				else if(len[k]==len[i]-j+1&&hs[id[i][j][1]]==hs[id[k][len[k]][0]]) v[id[i][j][1]].push_back({cnt,2*(len[i]-j+1)});
			}
		}
	}//后缀建边
	pre(cnt);//找到那些点从超级源点能走到，用来判环
	for(int i=1; i<=cnt; i++) if(vis[i]) for(auto p:v[i]) if(vis[p.first]){in[p.first]++;if(p.first==cnt){cout<<"Infinity";return 0;}}
	q.push(cnt);dp[cnt]=0;
	while(!q.empty()){
		int cur=q.front();val++;
		q.pop();
		for(auto p:v[cur]){
			in[p.first]--,dp[p.first]=max(dp[p.first],dp[cur]+p.second);
			if(!in[p.first]) q.push(p.first);
		}
	}//拓扑排序
	if(val<sum){cout<<"Infinity";return 0;}
	int vals=0;
	long long ans=0;
	for(int i=1; i<=N; i++){
		for(int j=1; j<=len[i]; j++){
			if(!vis[id[i][j][0]]&&!vis[id[i][j][1]]) continue;
			for(int k=1; k<=N; k++){
				if(vis[id[i][j][0]]){
					int lt=max(0ll,(ans-dp[id[i][j][0]])/2+1),rt=min(len[k],j)+1;
					if(j-lt+1>=1&&lt<=len[k]&&help(i,j-lt+1,j,0)==help(k,1,lt,1)){
						vals++;
						while(lt+1<rt){
							int mid=lt+rt>>1;
							if(help(i,j-mid+1,j,0)==help(k,1,mid,1)) lt=mid;
							else rt=mid;
						}
						ans=max(ans,dp[id[i][j][0]]+2*lt);
					}
				}
				if(vis[id[i][j][1]]){
					int lt=max(0ll,(ans-dp[id[i][j][1]])/2+1),rt=min(len[k],len[i]-j)+1;
					if(j+lt-1<=len[i]&&len[k]-lt+1>=1&&help(i,j,j+lt-1,1)==help(k,len[k]-lt+1,len[k],0)){
						vals++;
						while(lt+1<rt){
							int mid=lt+rt>>1;
							if(help(i,j,j+mid-1,1)==help(k,len[k]-mid+1,len[k],0)) lt=mid;
							else rt=mid;
						}
						ans=max(ans,dp[id[i][j][1]]+2*lt);
					}
				}
			}
		}
	}//二分哈希
	for(int i=1; i<=N; i++){
		for(int j=1; j<=len[i]; j++){
			int lt=ans/2,rt=min(j-1,len[i]-j)+1;
			if(j-lt>=1&&j+lt<=len[i]&&help(i,j-lt,j+lt,0)==help(i,j-lt,j+lt,1)){
						vals++;
				while(lt+1<rt){
					int mid=lt+rt>>1;
					if(help(i,j-mid,j+mid,0)==help(i,j-mid,j+mid,1)) lt=mid;
					else rt=mid;
				}
				ans=max(ans,2ll*lt+1);
			}
			lt=ans/2,rt=min(j,len[i]-j)+1;
			if(j-lt+1>=1&&j+lt<=len[i]&&help(i,j-lt+1,j+lt,0)==help(i,j-lt+1,j+lt,1)){
						vals++;
				while(lt+1<rt){
					int mid=lt+rt>>1;
					if(help(i,j-mid+1,j+mid,0)==help(i,j-mid+1,j+mid,1)) lt=mid;
					else rt=mid;
				}
			}
			ans=max(ans,2ll*lt);
		}
	}//特判回文串居中
	cout<<ans;
	return 0;
}
```

input：
```
10
bcedceccc
eadddc
aedddb
eadcee
ebabbcccd
dbcbdbd
acabadbdda
aabbab
ecedbbaae
adddcea
```
output：
```
1
```
解释：
```
aed[ddb|dbcbdbd|d]bcbdbd
```

中括号是回文串，竖线是字符串之间分隔符。

---

## 作者：takanashi_mifuru (赞：1)

考虑回文子串什么时候会变长。

考虑串 `zabcy`，如果取子串 `abc`，因为前后不能再延展，所以接什么也没有用。

所以这告诉我们至少有一边是空的。

容易发现如果我们确定回文中心，那么根本不在乎已经确认匹配的字符如何，只在乎预备去匹配的字符如何，而这样的字符显然是某个串的前缀或后缀，考虑将状态设成这个 dp，转移细节繁多十分恶心。

显然除去完全匹配，也有可能在这里无法完全匹配，匹配一小段之后就计作答案，这里需要一个二分哈希求最长的相等的串。

像这样子建立一张转移的图，最后的问题当然就是求最长路，然而最长路没法求，又注意到如果我们能搜到一个环的话那就说明可以无限接下去来到无限长，所以我们能搜到的部分肯定是个 DAG，直接拓扑排序求最长路即可。

这样写出来只能够得到 70 分，你考虑搞点剪枝，具体来讲，每次二分的时候起点设置成当前转移点的最大值，并特判最小值是否在当前位置合法，如果不合法就不二分，然后就通过了。

记得特判长度为 0 的点能不能被到达，因为有的时候不一定能通过这个点拼出环来。

hack:

```
2
dabc
cba
```

正确输出显然是 `Infinity`，但是如果少判了东西就会输出 `14` 一类。

```cpp
#include<bits/stdc++.h>
using namespace std;
int testid;
int n;
string S[105];
string rev(string S){
   int st=0,ed=S.size()-1;
   while(st<ed)swap(S[st++],S[ed--]);
   return S;
}

struct node{
   int v,w;
};

vector<node> ljb[200005];
int rd[200005];
int dis[200005];
bool vis[200005];
int calc=0;
void addedge(int u,int v,int w){
   ljb[u].push_back(node{v,w});
   return;
}
class ghas{
   public:
   long long P=1e9+7,base=998244353;
   vector<long long> has,fhas;
   vector<long long> power;
   int n;
   void init(string S){
      n=S.size()-1;
      has.resize(n+1);
      power.resize(n+1);
      fhas.resize(n+2);
      power[0]=1,has[0]=0,fhas[n+1]=0;
      for(int i=1;i<=n;i++){
         has[i]=(has[i-1]*base+S[i])%P;
         power[i]=power[i-1]*base%P;
      }
      for(int i=n;i>=1;i--){
         fhas[i]=(fhas[i+1]+S[i]*power[n-i])%P;
      }
      return;
   }
   long long gethas(int lt,int rt){
      calc++;
      long long tmp=(has[rt]-has[lt-1]*power[rt-lt+1]%P+P)%P;
      return tmp;
   }
}A[200005],gA[200005];
vector<int> dp[2][200005];
vector<int> id[2][200005];
void getvis(int cur){
   if(vis[cur])return;
   vis[cur]=true;
   for(node v:ljb[cur]){
      rd[v.v]++;
      getvis(v.v);
   }
   return;
}
int tot;
int fck=0;
int Max[200005];
int main(){
   scanf("%d",&testid);
   scanf("%d",&n);
   int qeta=0;
   for(int i=1;i<=n;i++){
      cin>>S[i];
      qeta+=S[i].size();
      A[i].init("?"+S[i]);
      gA[i].init("?"+rev(S[i]));
   }
   // cerr<<qeta<<'\n';
   for(int i=1;i<=n;i++){
      dp[0][i].resize(S[i].size()+1);
      dp[1][i].resize(S[i].size()+1);
      for(int j=0;j<dp[0][i].size();j++){
         id[0][i].push_back(++tot);
      }
      for(int j=0;j<dp[1][i].size();j++){
         id[1][i].push_back(++tot);
      }//
   }
   int st=++tot;
   int ed=++tot;
   for(int i=1;i<=n;i++){
      for(int j=0;j<S[i].size();j++){//
         int len=j+1;
         for(int k=1;k<=n;k++){
            if(S[k].size()<len){//
               int need=S[k].size();
               if(A[i].gethas(len-need+1,len)==gA[k].fhas[S[k].size()-need+1]){
                  addedge(id[0][i][len],id[0][i][len-need],2*need);
               }
               else{
                  int lt=Max[id[0][i][len]],rt=need;//
                  if(lt+1>=rt||(A[i].gethas(len-(lt+1)+1,len) xor gA[k].fhas[S[k].size()-(lt+1)+1])){
                     continue;
                  }
                  lt++;
                  fck+=(rt-lt+1);
                  while(lt+1<rt){
                     int mid=lt+rt>>1;
                     if(A[i].gethas(len-mid+1,len)==gA[k].fhas[S[k].size()-mid+1]){
                        lt=mid;
                     }
                     else{
                        rt=mid;
                     }
                  }
                  if(lt>Max[id[0][i][len]]){
                     Max[id[0][i][len]]=lt;
                     addedge(id[0][i][len],ed,2*lt);
                  }
               }
               continue;
            }
            if(gA[i].gethas(S[i].size()-len+1,S[i].size())==A[k].has[len]){
               if(len==S[k].size()){
                  addedge(id[0][i][len],id[0][k][0],2*len);
               }
               else{
                  addedge(id[0][i][len],id[1][k][len+1],2*len);
               }
            }
            else{//
               int lt=Max[id[0][i][len]],rt=len;//
               if(lt+1>=rt||(gA[i].gethas(S[i].size()-len+1,S[i].size()-len+(lt+1)) xor A[k].has[lt+1]))continue;
               lt++;
               fck+=rt;
               while(lt+1<rt){
                  int mid=lt+rt>>1;
                  if(gA[i].gethas(S[i].size()-len+1,S[i].size()-len+mid)==A[k].has[mid]){
                     lt=mid;
                  }
                  else{
                     rt=mid;
                  }
               }
               Max[id[0][i][len]]=lt;
               addedge(id[0][i][len],ed,2*lt);
            }
         }
      }
      for(int j=S[i].size()-1;j>=0;j--){
         int len=S[i].size()-j;
         for(int k=1;k<=n;k++){
            int need=len;
            if(S[k].size()<need)need=S[k].size();
            if(A[i].gethas(S[i].size()-len+1,S[i].size()-len+need)==gA[k].has[need]){
               if(S[k].size()<len){
                  addedge(id[1][i][j+1],id[1][i][j+need+1],2*need);
               }
               else{
                  if(len==S[k].size()){
                     addedge(id[1][i][j+1],id[0][k][0],2*len);
                  }
                  else{
                     addedge(id[1][i][j+1],id[0][k][S[k].size()-len],2*len);
                  }
               }
            }
            else{
               int lt=Max[id[1][i][j+1]],rt=need;//
               if(lt+1>=rt||(A[i].gethas(S[i].size()-len+1,S[i].size()-len+(lt+1)) xor gA[k].has[lt+1]))continue;
               lt++;
               fck+=rt;
               while(lt+1<rt){//
                  int mid=lt+rt>>1;
                  if(A[i].gethas(S[i].size()-len+1,S[i].size()-len+mid)==gA[k].has[mid]){
                     lt=mid;
                  }
                  else{
                     rt=mid;
                  }
               }
               addedge(id[1][i][j+1],ed,2*lt);
            }
         }
      }
   }
   for(int i=1;i<=n;i++){
      int now=0;
      addedge(st,id[1][i][1],0);
      addedge(st,id[0][i][S[i].size()],0);
      for(int j=0;j+1<S[i].size();j++){
         if(A[i].gethas(1,j+1)==gA[i].gethas(S[i].size()-j,S[i].size())){
            addedge(st,id[1][i][j+2],j+1);
         }
      }
      // puts("---");
      for(int j=S[i].size()-2;j>=0;j--){//
         if(gA[i].gethas(1,j+1)==A[i].gethas(S[i].size()-j,S[i].size())){
            addedge(st,id[0][i][S[i].size()-(j+1)],j+1);
         }
      }
   }
   queue<int> q;
   q.push(st);
   dis[st]=0;
   getvis(st);
   while(!q.empty()){
      int tmp=q.front();
      q.pop();
      for(node v:ljb[tmp]){
         rd[v.v]--;
         if(!rd[v.v])q.push(v.v);
         dis[v.v]=max(dis[v.v],dis[tmp]+v.w);
      }
   }
   for(int i=0;i<tot;i++){
      if(rd[i]){
         puts("Infinity");
         return 0;
      }
   }
   int ans=0;
   for(int i=0;i<=tot;i++){//
      if(vis[i]){
         ans=max(ans,dis[i]);
      }
   }
   // return 0;
   for(int i=1;i<=n;i++){
      int lt=0,rt=(S[i].size()-1)/2+1;
      while(lt+1<rt){//
         int mid=lt+rt>>1;
         int len=mid*2+1;
         bool flg=false;
         for(int j=0;j+len-1<S[i].size();j++){
            if(A[i].gethas(j+1,j+len)==gA[i].gethas(S[i].size()-j-len+1,S[i].size()-j)){
               flg=true;
               break;
            }
         }
         if(flg){
            lt=mid;
         }
         else{
            rt=mid;
         }
      }
      ans=max(ans,lt*2+1);
      lt=0,rt=(S[i].size())/2+1;
      while(lt+1<rt){
         int mid=lt+rt>>1;
         int len=mid*2;
         bool flg=false;
         for(int j=0;j+len-1<S[i].size();j++){
            if(A[i].gethas(j+1,j+len)==gA[i].gethas(S[i].size()-j-len+1,S[i].size()-j)){
               flg=true;
               break;
            }
         }
         if(flg){
            lt=mid;
         }
         else{ 
            rt=mid;
         }
      }
      ans=max(ans,2*lt);
   }
   for(int i=1;i<=n;i++){
      if(vis[id[0][i][0]]){
         puts("Infinity");
         return 0;
      }
   }
   printf("%d\n",ans);
   return 0;
}

```

---

## 作者：未来姚班zyl (赞：1)

不知道为啥评黑，就是道模拟题。

这题的任务是找出某个最长的回文子串，我们稍微转换以下视角：从回文子串 $t$ 的视角来看，我们尝试用题目中的串拼凑出 $t$。

从回文中心出发，我们构造 $t$ 的过程可以当成两个指针不断往外扩张的过程。这个过程可以直接**模拟**：

 1. 确定回文中心，从 $S$ 的某个串 $s_i$ 中出发，开始向外扩张。
 2. 如果没有扩展到 $s_i$ 的边界，则 $t$ 无法再扩张，扩张结束。
 3. 否则，$t$ 会扩张到 $s_i$ 的左边界或者右边界。如果扩张到左边界，则相当于要在左边接一个串 $s_j$，用 $s_j$ 的后缀匹配 $s_i$ 剩下的后缀，再继续扩张。扩张到右边界则是前缀相匹配。

然后不断重复后两步，直到满足第二个条件中的终止条件。

第三步可以用一张有向图刻画，保留能抵达的状态，则 Infinity 就是出现环，否则直接 Dag 求最长路。

整个过程都只需要二分哈希求最长的匹配/回文串，复杂度 $O(n^2L\log L)$，不过用一些后缀数组，manacher，exkmp 等算法可以把 $\log L$ 消掉，但众所周知，字符串算法只有二分哈希这一个，所以我们不用会这些算法，并且二哈拿了 MVP。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid ((l+r)>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK Ll<=l&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
#define YY puts("Yes"),exit(0)
#define NN puts("No"),exit(0)
#define yy return puts("Yes"),void()
#define nn return puts("No"),void()
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=2e5+5,M=1e6+5,inf=(1LL<<30)-1,mod=1e9+7;
const ll llf=1e18;
inline void add(int &a,int b){((a+=b)>=mod) and (a-=mod);}
inline int Add(int a,int b){return add(a,b),a;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
inline void Mul(int &a,int b){a=mul(a,b);}
inline void red(int &a,int b){add(a,mod-b);}
inline int Red(int a,int b){return red(a,b),a;}
inline int qp(int a,ll b){if(!b)return 1;int c=qp(a,b>>1LL);Mul(c,c);if(b&1)Mul(c,a);return c;}
inline int INV(int x){return qp(x,mod-2);}
inline bool che(int x,int p){return (x>>p)&1LL;}
int n,testid,m,len[105];
string s[105];
const ui base=131;
ui p[N],H[N],A[N];
inline ui getH(int l,int r){
	return H[r]-H[l-1]*p[r-l+1];
}
inline ui getA(int l,int r){
	return A[l]-A[r+1]*p[r-l+1];
}
vector<ui>Ha[105],ha[105];
vector<bitset<101>>vp[105],Vp[105],vs[105],Vs[105];
inline ui getHa(int x,int l,int r){
	if(l>r)return 0;
	return Ha[x][r]-Ha[x][l-1]*p[r-l+1];
}
inline ui getha(int x,int l,int r){
	if(l>r)return 0;
	return ha[x][l]-ha[x][r+1]*p[r-l+1];
}
vector<int>dis[105][2],rd[105][2];
vector<bool>v[105][2];
struct node{
	int x,ty,p;
};
inline void bfs(int x,int ty,int ps){
	v[x][ty][ps]=1;
	if(ty==0){
		repn(y)if(vp[x][ps][y]&&!v[y][1][ps+1])bfs(y,1,ps+1);
		repn(y)if(Vp[x][ps][y]&&!v[x][0][ps-len[y]])bfs(x,0,ps-len[y]);
	}else {
		repn(y)if(vs[x][ps][y]&&!v[y][0][len[y]-(len[x]-ps+1)])bfs(y,0,len[y]-(len[x]-ps+1));
		repn(y)if(Vs[x][ps][y]&&!v[x][1][ps+len[y]])bfs(x,1,ps+len[y]);
	}
}
inline void subtaskall(){
	int Ans=0;
	p[0]=1;
	rep(i,1,N-5)p[i]=p[i-1]*base;
	repn(x){
		m=s[x].length()-1,p[0]=1,len[x]=m;
		repm(i)H[i]=H[i-1]*base+s[x][i];
		A[m+1]=0;
		per(i,m,1)A[i]=A[i+1]*base+s[x][i];
		repm(i){
			int l=1,r=min(i-1,m-i),ans=1;
			while(l<=r)if(getH(i-mid,i+mid)==getA(i-mid,i+mid))ans=mid*2+1,l=mid+1;
			else r=mid-1;
			Ans=max(Ans,ans);
		}
		repm(i){
			int l=1,r=min(i-1,m-i+1),ans=0;
			while(l<=r)if(getH(i-mid,i+mid-1)==getA(i-mid,i+mid-1))ans=mid*2,l=mid+1;
			else r=mid-1;
			Ans=max(Ans,ans);
		}
		rep(i,0,m+1)Ha[x].pb(H[i]),ha[x].pb(A[i]),dis[x][0].pb(-inf),dis[x][1].pb(-inf),rd[x][0].pb(0),rd[x][1].pb(0),v[x][0].pb(0),v[x][1].pb(0);
		vp[x].resize(m+2),vs[x].resize(m+2),Vs[x].resize(m+2),Vp[x].resize(m+2);
	}
	repn(x){
		m=len[x];
		repn(i)vp[x][0][i]=vs[x][m+1][i]=1;
		repm(pre)repn(y)vp[x][pre][y]=len[y]>=pre&&getHa(x,1,pre)==getha(y,1,pre),vs[x][pre][y]=len[y]>=m-pre+1&&getHa(x,pre,m)==getha(y,len[y]-(m-pre),len[y]),Vp[x][pre][y]=len[y]<=pre&&getHa(x,pre-len[y]+1,pre)==getha(y,1,len[y]),Vs[x][pre][y]=len[y]<=m-pre+1&&getHa(x,pre,pre+len[y]-1)==getha(y,1,len[y]);
	}
	queue<node>q;
	repn(x){
		m=len[x];
		rep(ps,0,m)if(getHa(x,1,ps)==getha(x,1,ps)){
			if(!v[x][1][ps+1])bfs(x,1,ps+1);
		}
		rep(ps,1,m+1)if(getHa(x,ps,m)==getha(x,ps,m)){
			if(!v[x][0][ps-1])bfs(x,0,ps-1);
		}
	}
	repn(x){
		m=len[x];
		rep(ps,0,m)if(v[x][0][ps])repn(y)if(vp[x][ps][y])rd[y][1][ps+1]++;
		rep(ps,0,m)if(v[x][0][ps])repn(y)if(Vp[x][ps][y])rd[x][0][ps-len[y]]++;
		rep(ps,1,m+1)if(v[x][1][ps])repn(y)if(vs[x][ps][y])rd[y][0][len[y]-(m-ps+1)]++;
		rep(ps,1,m+1)if(v[x][1][ps])repn(y)if(Vs[x][ps][y])rd[x][1][ps+len[y]]++;
	}
	repn(x){
		m=len[x];
		rep(ps,0,m)if(getHa(x,1,ps)==getha(x,1,ps)){
			dis[x][1][ps+1]=ps;
			if(!rd[x][1][ps+1])q.push({x,1,ps+1});
		}
		rep(ps,1,m+1)if(getHa(x,ps,m)==getha(x,ps,m)){
			dis[x][0][ps-1]=m-ps+1;
			if(!rd[x][0][ps-1])q.push({x,0,ps-1});
		}
	}
	while(!q.empty()){
		int x=q.front().x,ty=q.front().ty,ps=q.front().p,d=dis[x][ty][ps];q.pop();
		Ans=max(Ans,d),m=len[x];
		if(ty==0){
			repn(y){
				if(Vp[x][ps][y]){
					dis[x][0][ps-len[y]]=max(dis[x][0][ps-len[y]],d+len[y]*2);
					if(!--rd[x][0][ps-len[y]])q.push({x,0,ps-len[y]});
				}
				if(vp[x][ps][y]){
					dis[y][1][ps+1]=max(dis[y][1][ps+1],d+ps*2);
					if(!--rd[y][1][ps+1])q.push({y,1,ps+1});
					continue;
				}
				int l=1,r=min(ps,len[y]),ex=0;
				while(l<=r)if(getHa(x,ps-mid+1,ps)==getha(y,1,mid))ex=mid*2,l=mid+1;
				else r=mid-1;
				Ans=max(Ans,ex+d);
			}
		}else {
			repn(y){
				if(Vs[x][ps][y]){
					dis[x][1][ps+len[y]]=max(dis[x][1][ps+len[y]],d+len[y]*2);
					if(!--rd[x][1][ps+len[y]])q.push({x,1,ps+len[y]});
				}
				int psy=len[y]-(len[x]-ps+1);
				if(vs[x][ps][y]){
					dis[y][0][psy]=max(dis[y][0][psy],d+(m-ps+1)*2);
					if(!--rd[y][0][psy])q.push({y,0,psy});
					continue;
				}
				int l=1,r=min(m-ps+1,len[y]),ex=0;
				while(l<=r)if(getHa(x,ps,ps+mid-1)==getha(y,len[y]-mid+1,len[y]))ex=mid*2,l=mid+1;
				else r=mid-1;
				Ans=max(Ans,ex+d);
			}
		}
	}
	repn(x)rep(ty,0,1)rep(j,0,len[x]+1)if(rd[x][ty][j])return puts("Infinity"),void();
	cout <<Ans;
}
inline void Main(){
	n=read();
	repn(i)cin>>s[i],s[i]='#'+s[i];
	return subtaskall();
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}

```

---


# [HEOI2016/TJOI2016] 字符串

## 题目描述

佳媛姐姐过生日的时候，她的小伙伴从某东上买了一个生日礼物。生日礼物放在一个神奇的箱子中。箱子外边写了一个长为 $n$ 的字符串 $s$，和 $m$ 个问题。佳媛姐姐必须正确回答这 $m$ 个问题，才能打开箱子拿到礼物，升职加薪，出任 CEO，嫁给高富帅，走上人生巅峰。

每个问题均有 $a,b,c,d$ 四个参数，问你子串 $s[a..b]$ 的所有子串和 $s[c..d]$ 的最长公共前缀的长度的最大值是多少？佳媛姐姐并不擅长做这样的问题，所以她向你求助，你该如何帮助她呢？


## 说明/提示

对于 $10\%$ 的数据，$1\le n,m\le 300$。

对于 $40\%$ 的数据，$1\le n,m\le 3,000$，字符串中仅有 `a`,`b`。

对于 $100\%$ 的数据，$1\le n,m\le 100,000$，字符串中仅有小写英文字母，$a\le b$，$c\le d$，$1\le a,b,c,d\le n$。


## 样例 #1

### 输入

```
5 5
aaaaa
1 1 1 5
1 5 1 1
2 3 2 3
2 4 2 3
2 3 2 4```

### 输出

```
1
1
2
2
2```

# 题解

## 作者：shadowice1984 (赞：37)

作为一道码农题……

(SA+二分套(主席树+二分))怕不是真·理论复杂度O(Nlog^2N)

如果熟练的压行的话应该可以做到百行以内吧

那么我们来讲解一下这道题：设我们的答案为mid(注意这里有坑是\[a,b]的**所有**子串和\[c,d]**这个**子串的最长lcp),那么我们会发现一个很有趣的事实: _如果mid可行的话，那么任意一个比mid小的数也可行_ 

也就是说，问题满足**可二分性**，那么我们可以二分答案，将原问题转化为一个**判定性问题**:mid这个答案行不行？

那么我们发现，如果mid这个答案可以的话，就**会存在**一个后缀S，

1.它的开头在\[a,b-mid+1]当中。

2.lcp(S,c)>=mid。

再次转化一步，就是询问满足以上两个条件的后缀S的个数，经典的二元限制统计问题，我们的思路很简单，摁死一个再去管下一个，发现一件有趣的事实：如果把这些后缀排好序，那么lcp符合要求的一定是一段连续的区间，(为什么？，因为我们发现排好序以后，lcp这个函数是单峰的，并且峰值在自己这里)

那么我们似乎可以二分左端点和右端点，为此我们需要O(1)求出区间最小值，为此我们还得写一个St表QAQ

那么最后我们发现现在两个限制都是区间型的了，而且是静态区间，没有修改，所以可以用主席树查询一发……

### 下面是科普

 _只是介绍一些关于数据结构/算法的引申，并不会详细介绍原理，如果不会的话看对应的膜板吧，解释的都很详细_ 
 
######  关于后缀数组

ht数组的意义是，lcp(rk\[i-1],rk\[i])，所以ht数组是在按sa序排出来之后才有意义的，另外我们会发现ht数组是“向上”匹配的，所以我们使用区间min来查询任意两个串的lcp时查询的是(rk\[a],rk\[b]]即**左开右闭**区间。

###### 关于st表

考虑到ht数组向上匹配的特性，我们的区间min也写成左开右闭就好了

###### 关于主席树

主席树其实是线段树的前缀和，我们的线段树通常是一个权值线段树以满足我们对权值的区间限制要求，那么我们建主席树的时候通常是一个点一个点插入，以满足每一个实际区间的要求，对于这道题来讲，我们对sa建主席树，因为最后实际上第二次二分的区间是一个在sa序上连续的区间，查询限制的则是这个后缀的实际编号，所以我们的权值线段树的权值是后缀的编号。

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int N=100010;int n;int m;
char mde[N];int sa[N];int rk[2*N];int ht[N];
int x[N];int y[N];queue <int> q[N];
inline bool cmp(int i,int j){return (x[i]==x[j])&&(y[i]==y[j]);}
inline void rixs()//这里的后缀数组用的是队列实现，常数较大
{
    for(int i=1;i<=n;i++){q[y[i]].push(i);}
    int cnt=0;for(int i=0;i<=n;i++)
    {for(;!q[i].empty();q[i].pop()){sa[++cnt]=q[i].front();}}
    for(int i=1;i<=n;i++){q[x[sa[i]]].push(sa[i]);}
    cnt=0;for(int i=0;i<=n;i++)
    {for(;!q[i].empty();q[i].pop()){sa[++cnt]=q[i].front();}}
    rk[sa[1]]=1;for(int i=2;i<=n;i++)
    {rk[sa[i]]=(cmp(sa[i-1],sa[i]))?rk[sa[i-1]]:i;}
}
inline void create_sa()//板子啥的问度娘吧
{
    for(int i=1;i<=n;i++){q[mde[i]-'a'+1].push(i);}
    int cnt=0;for(int i=1;i<=26;i++)
    {for(;!q[i].empty();q[i].pop()){sa[++cnt]=q[i].front();}}
    rk[sa[1]]=1;for(int i=2;i<=n;i++)
    {rk[sa[i]]=(mde[sa[i-1]]==mde[sa[i]])?rk[sa[i-1]]:i;}
    for(int k=1;k<=n;k*=2)
    {for(int i=1;i<=n;i++){x[i]=rk[i];y[i]=rk[i+k];}rixs();}
}
inline void calch()
{
    int j=0;int k=0;for(int i=1;i<=n;ht[rk[i++]]=k)
    {for(k=k?k-1:k,j=sa[rk[i]-1];mde[i+k]==mde[j+k];k++);}
}
int st[22][N];int log[N];
inline void calclog()//打表log，方便使用
{int i=0;for(int j=1;j<=n;j++){if((1<<(i+1))<=j)i++;log[j]=i;}}
inline void create_st()//对ht建st表
{
    for(int i=0;i<=n-1;i++){st[0][i]=ht[i+1];}
    for(int i=1;i<=log[n];i++)
    {for(int j=0;j<n-(1<<(i-1));j++){st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);}}
}
inline int rmq(int l,int r)//左开右闭的rmq
{int len=r-l;int res=min(st[log[len]][l],st[log[len]][r-(1<<log[len])]);return res;}
struct per_linetree//主席树的板子，这个真的是纯板子了
{
    int s[2][44*N];int fa[44*N];int root[N];int cnt;int val[44*N];
    per_linetree(){root[0]=1;cnt=1;}
    inline void insert(int p1,int p2,int l,int r,int pos)
    {
        val[p2]=val[p1]+1;if(r-l==1)return;int mid=(l+r)/2;
        if(pos<=mid){s[0][p2]=++cnt;s[1][p2]=s[1][p1];insert(s[0][p1],cnt,l,mid,pos);}
        else {s[1][p2]=++cnt;s[0][p2]=s[0][p1];insert(s[1][p1],cnt,mid,r,pos);}
    }
    inline void add(int t1,int t2,int pos)
    {root[t2]=++cnt;insert(root[t1],root[t2],0,n,pos);}
    inline int sum(int p1,int p2,int l,int r,int dl,int dr)
    {
        if(dl==l&&dr==r){return val[p2]-val[p1];}int mid=(l+r)/2;int res=0;
        if(dl<mid)res+=sum(s[0][p1],s[0][p2],l,mid,dl,min(dr,mid));
        if(mid<dr)res+=sum(s[1][p1],s[1][p2],mid,r,max(dl,mid),dr);
        return res;
    }
    inline int query(int t1,int t2,int l,int r)
    {return sum(root[t1-1],root[t2],0,n,l-1,r);}
}plt;
inline bool jud(int x,int a,int b,int c)//检测mid是否可行
{
    int l=1;int r=rk[c];int up;int down;//二分上边界，注意是左开右闭
    while(l<r){int mid=(l+r)/2;if(rmq(mid,rk[c])<x){l=mid+1;}else {r=mid;}}
    up=r;
    l=rk[c];r=n;//二分下边界
    while(l<r){int mid=(l+r+1)/2;if(rmq(rk[c],mid)<x){r=mid-1;} else{l=mid;}}
    down=r;
    return plt.query(up,down,a,b-x+1)!=0;//主席树查一发是否存在符合要求的后缀
}
inline int solve(int a,int b,int c,int d)//主二分过程
{
    int l=0;int r=min(b-a+1,d-c+1);//这个就是裸的二分答案了
    while(l<r){int mid=(l+r+1)/2;if(jud(mid,a,b,c)){l=mid;}else {r=mid-1;}}
    return r;
}
int main()
{
    scanf("%d%d",&n,&m);scanf("%s",mde+1);
    create_sa();calch();calclog();create_st();//上来先预处理
    for(int i=1;i<=n;i++){plt.add(i-1,i,sa[i]);}//对sa建主席树
    for(int i=1;i<=m;i++)
    {
        int a;int b;int c;int d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        printf("%d\n",solve(a,b,c,d));
    }return 0;//拜拜程序~
}
```


---

## 作者：nofind (赞：24)

## [题意](https://www.luogu.com.cn/problem/P4094)

考虑二分答案$mid$,现在我们要判断$s[c...c+mid-1]$是否在$s[a...b]$出现过。


首先找到$s[c...c+mid-1]$所在的状态：  
建出$parent\ tree$，从$s[1...c+mid-1]$的节点（这个可以记录）用倍增向上跳到最后一个$len\geqslant mid$的节点即可，记这个节点为$now$。

之后我们要判断$now$的$endpos$中是否含有$[a+mid-1,b]$中的某个数，我们给每个节点开个权值线段树用来维护该节点$endpos$（相当于桶），从$parent\ tree$向上合并线段树即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=500010;
int n,m,tot,cnt,t;
int id[maxn],root[maxn],head[maxn];
int f[maxn][20];
char s[maxn];
struct edge{int to,nxt;}e[maxn<<1];
struct Seg
{
	#define lc(p) (seg[p].lc)
	#define rc(p) (seg[p].rc)
	#define sum(p) (seg[p].sum)
	int lc,rc,sum;
}seg[maxn*60];
inline int read()
{
	char c=getchar();int res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
inline void add_edge(int u,int v)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
inline void up(int p){sum(p)=sum(lc(p))+sum(rc(p));}
void insert(int &p,int l,int r,int pos)
{
	if(!p)p=++tot;
	sum(p)++;
	if(l==r)return;
	int mid=(l+r)>>1;
	if(pos<=mid)insert(lc(p),l,mid,pos);
	else insert(rc(p),mid+1,r,pos);
}
int query(int p,int l,int r,int ql,int qr)
{
	if(l>=ql&&r<=qr)return sum(p);
	int mid=(l+r)>>1,res=0;
	if(ql<=mid)res+=query(lc(p),l,mid,ql,qr);
	if(qr>mid)res+=query(rc(p),mid+1,r,ql,qr);
	return res;
}
int merge(int p,int q,int l,int r)
{
	if(!p||!q)return p+q;	
	int x=++tot,mid=(l+r)>>1;sum(x)=sum(p)+sum(q);
	if(l==r)return x; 
	lc(x)=merge(lc(p),lc(q),l,mid);
	rc(x)=merge(rc(p),rc(q),mid+1,r);
	return x;
}
struct SAM
{
	int tot,last;
	int fa[maxn],len[maxn];
	int ch[maxn][30];
	SAM(){last=tot=1;}
	inline void add(int c)
	{
		int now=++tot;len[now]=len[last]+1;
		int p=last;last=now;
		while(p&&!ch[p][c])ch[p][c]=now,p=fa[p];
		if(!p){fa[now]=1;return;}
		int q=ch[p][c];
		if(len[q]==len[p]+1)fa[now]=q;
		else
		{
			int nowq=++tot;
			len[nowq]=len[p]+1;
			memcpy(ch[nowq],ch[q],sizeof(ch[q]));
			fa[nowq]=fa[q];fa[q]=fa[now]=nowq;
			while(p&&ch[p][c]==q)ch[p][c]=nowq,p=fa[p];
		}
	}
}sam;
void dfs(int x)
{
	for(int i=1;i<=t;i++)f[x][i]=f[f[x][i-1]][i-1];
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		f[y][0]=x;dfs(y);
		root[x]=merge(root[x],root[y],1,n);
	}
}
inline bool check(int mid,int a,int b,int c,int d)
{
	int now=id[c+mid-1];
	for(int i=t;~i;i--)if(f[now][i]&&sam.len[f[now][i]]>=mid)now=f[now][i];
	return query(root[now],1,n,a+mid-1,b)>0;
}
int main()
{
	n=read(),m=read();
	scanf("%s",s+1);
	id[0]=1;
	for(int i=1;i<=n;i++)sam.add(s[i]-'a'),id[i]=sam.last,insert(root[sam.last],1,n,i);
	for(int i=2;i<=sam.tot;i++)add_edge(sam.fa[i],i);
	t=(int)log2(sam.tot)+1;dfs(1);
	while(m--)
	{
		int a=read(),b=read(),c=read(),d=read();
		int l=0,r=min(b-a+1,d-c+1),ans=0;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(mid,a,b,c,d))ans=mid,l=mid+1;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：试试事实上吗 (赞：16)

### SAM

怎么题解都没有几篇SAM的，SAM会伤心的。

### Part.1

首先观察询问，好像非常不可做，但是可以发现答案有可二分性，具体来说，可以二分最长公共前缀的长度，然后就是询问$c$到$c+mid-1$有没有在$[a,b]$出现过，然而SAM更擅长后缀，所以可以把串翻转过来求后缀匹配数。

如果对SAM敏感的就可以发现这其实就可以发现这是一个在SAM上线段树合并预处理然后倍增跳$parent$树查询的裸题了。

~~于是就完了（不是~~

### Part.2

具体来说，我们知道一个$endpos$的父亲肯定是她的后缀，即如果当前点可以匹配，她的父亲肯定可以匹配。SAM上每个点我们都开一棵线段树，统计她可以匹配哪些前缀，首先前缀对应的节点肯定可以匹配自己，然后我们线段树合并答案。

每次假设我们钦定了右端点为$r$，我们就倍增的往上跳到最上面的$r-maxlen+1\le l$的节点，这个点包含了我们所有的需要的东西，直接查一遍即可。

做完了可以去做一下[这个](https://www.luogu.com.cn/problem/CF666E)，跟这个比较像。

```cpp
const int maxn=1e5+5;

struct SegmentTree
{
    int lc[maxn*40],rc[maxn*40],wife[maxn*40],cnt;
    void modify(int &u,int l,int r,int x)
    {
        if(!u) u=++cnt;
        ++wife[u];
        if(l==r) return;
        int mid=(l+r)>>1;
        if(x<=mid) modify(lc[u],l,mid,x);
        else modify(rc[u],mid+1,r,x);
    }
    int merge(int u,int v)
    {
        if(!u||!v) return u|v;
        int x=++cnt;
        wife[x]=wife[u]+wife[v];
        lc[x]=merge(lc[u],lc[v]);
        rc[x]=merge(rc[u],rc[v]);
        return x;
    }
    int query(int u,int l,int r,int x,int y)
    {
        if(!u) return 0;
        if(x<=l&&r<=y) return wife[u];
        int mid=(l+r)>>1,res=0;
        if(x<=mid) res+=query(lc[u],l,mid,x,y);
        if(y>mid) res+=query(rc[u],mid+1,r,x,y);
        return res;
    }
}wife;

int tr[maxn<<1][26],maxlen[maxn<<1],link[maxn<<1],cnt=1,las=1,tax[maxn<<1],a[maxn<<1];
int fa[maxn<<1][21],n,pos[maxn],rt[maxn<<1];
char s[maxn];

void insert(int c)
{
    int u=las,nu=las=++cnt;
    maxlen[nu]=maxlen[u]+1;
    for(;u&&!tr[u][c];u=link[u]) tr[u][c]=nu;
    if(!u) return link[nu]=1,void();
    int v=tr[u][c];
    if(maxlen[u]+1==maxlen[v]) return link[nu]=v,void();
    int nv=++cnt;
    maxlen[nv]=maxlen[u]+1;link[nv]=link[v];link[v]=link[nu]=nv;
    memcpy(tr[nv],tr[v],sizeof(tr[v]));
    for(;u&&tr[u][c]==v;u=link[u]) tr[u][c]=nv;
}

inline bool check(int lim,int u,int l,int r)
{
    for(int i=20;i>=0;--i) if(fa[u][i]&&maxlen[fa[u][i]]>=lim) u=fa[u][i];
    return wife.query(rt[u],1,n,l+lim-1,r);
}

int main()
{
    int q,x,y,c,d;
    scanf("%d%d%s",&n,&q,s+1);
    reverse(s+1,s+n+1);
    for(int i=1;i<=n;++i) insert(s[i]-'a'),pos[i]=las,wife.modify(rt[las],1,n,i);
    for(int i=1;i<=cnt;++i) ++tax[maxlen[i]],fa[i][0]=link[i];
    for(int i=1;i<=cnt;++i) tax[i]+=tax[i-1];
    for(int i=cnt;i;--i) a[tax[maxlen[i]]--]=i;
    for(int i=cnt;i>1;--i) rt[link[a[i]]]=wife.merge(rt[a[i]],rt[link[a[i]]]);
    for(int j=1;j<=20;++j)
        for(int i=1;i<=cnt;++i)
            fa[i][j]=fa[fa[i][j-1]][j-1];
    while(q--)
    {
        scanf("%d%d%d%d",&x,&y,&c,&d);
        x=n-x+1;y=n-y+1;c=n-c+1;d=n-d+1;
        int l=0,r=min(x-y+1,c-d+1),mid,ans=0;
        while(l<=r)
        {
            int mid=(l+r)>>1;
            if(check(mid,pos[c],y,x)) l=mid+1,ans=mid;
            else r=mid-1;
        }
        printf("%d\n",ans);
    }
    return 0,QAQ;
}
```



---

## 作者：Labelray (赞：15)

[首先安利一波blog](http://labelray.top/2018/09/27/heoi2016-tjoi2016%e5%ad%97%e7%ac%a6%e4%b8%b2/)

听说这题正解是主席树什么的，但是不太会写，所以就写了一个暴力试着骗分，没想到竟然过了而且比主席树快好多2333

看到什么最长公共前缀（LCP）第一反应就应该是后缀数组

题目要求$s[a\dots b]$的一个子串与$s[c\dots d]$的LCP，其实也就是$s[e\dots b](a\leq e\leq b)$与$s[c\dots d]$的LCP。

我们将从$x$开始的后缀称为$\text{Suffix}(x)$，令$L=|\text{LCP}(\text{Suffix}(e), \text{Suffix}(c))|$，则$|\text{LCP}(s[e\dots b], s[c\dots d])|=\min\{b-e+1, d-c+1, L\}$

假设有最优解时，$rk[e]<rk[c]$。因为$L=\min\limits_{rk[e]< i\leq rk[c]}height[i]$，所以$L$就可以直观理解为从$rk[c]$向前扫到$rk[e]+1$其中经历的$height$最小值


所以我们可以这样操作，在`for(int i=rk[c];i>=2;i--)`的过程中，如果遇到$a\leq sa[i]\leq b$，就可以用$|\text{LCP}(s[sa[i]\dots b], s[c\dots d])|$的值更新答案；如果当前的$height[i]<ans$，则再继续扫下去也不会产生更优的答案,可以中断循环。

因为当前是我们假设$rk[e]<rk[c]$，实际上还有两种情况，$rk[e]>rk[c]$和$rk[e]=rk[c](e=c)$。对于前一种情况，按相同的方法向后扫一次即可；对于后一种情况，单独用$\min\{d-c+1, b-c+1\}$更新一下答案即可

~~我才不会说这个暴力做法我在luogu最优解拿到rank4，而且要卡这种暴力也不是很容易2333~~


```
#include <iostream>
#include <cstdio>
#include <algorithm>

const int MX=100010;
int N, M, s[MX], sa[MX], rk[MX], height[MX];

void get_int(int &_){
	char c=getchar(); _=0;
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	_=_*10+c-'0', c=getchar();
}

void input(){
	char c[MX];
	int _[MX];
	get_int(N);get_int(M);
	scanf("%s", c+1);
	std::copy(c+1, c+N+1, _+1);
	std::copy(_+1, _+N+1, s+1);
	std::sort(_+1, _+N+1);
	_[0]=std::unique(_+1, _+N+1)-_-1;
	for(int i=1; i<=N; i++)
		s[i]=std::lower_bound(_+1, _+_[0]+1, s[i])-_;
}

void SuffixSort(){
	int buc[MX], fir[MX], sec[MX], tmp[MX];
	std::fill(buc, buc+N+1, 0);
	for(int i=1; i<=N; i++)	buc[s[i]]++;
	for(int i=1; i<=N; i++)	buc[i]+=buc[i-1];
	for(int i=1; i<=N; i++)	rk[i]=buc[s[i]-1]+1;
		
	for(int t=1; t<=N; t<<=1){
		for(int i=1; i<=N; i++)
			fir[i]=rk[i], sec[i]=i+t<=N ? rk[i+t] : 0;
		
		std::fill(buc, buc+N+1, 0);
		for(int i=1; i<=N; i++)	buc[sec[i]]++;
		for(int i=1; i<=N; i++)	buc[i]+=buc[i-1];
		for(int i=1; i<=N; i++)	tmp[N- --buc[sec[i]]]=i;
		
		std::fill(buc, buc+N+1, 0);
		for(int i=1; i<=N; i++)	buc[fir[i]]++;
		for(int i=1; i<=N; i++)	buc[i]+=buc[i-1];
		for(int i=1; i<=N; i++)	sa[buc[fir[tmp[i]]]--]=tmp[i];
		
		bool fl=true;
		for(int i=1, k=0; i<=N; i++){
			int j=sa[i];
			if(!k)	rk[j]=1;
			else if(fir[j]==fir[k] && sec[j]==sec[k])
				fl=false, rk[j]=rk[k];
			else	rk[j]=rk[k]+1;
			k=j;	
		}
		if(fl)	break;
	}
	
	for(int i=1, k=0; i<=N; i++){
		if(rk[i]==1)	k=0;
		else{
			int j=sa[rk[i]-1];
			k=k>0 ? k-1 : k;
			while(s[j+k]==s[i+k] && i+k<=N && j+k<=N)
				k++;
		}
		height[rk[i]]=k;
	}
}

int solve(int a, int b, int c, int d){
	int len=0x3f3f3f3f, ans=0;
	if(a<=c && c<=b)	ans=std::max(ans, std::min(d-c+1, b-c+1));
	for(int i=rk[c]; i>=2; i--){
		if(height[i]<=ans)	break;
		len=std::min(len, height[i]);
		if(sa[i-1]<=b && sa[i-1]>=a)
			ans=std::max(ans, std::min(std::min(b-sa[i-1]+1, d-c+1), len));
	}len=0x3f3f3f3f;
	for(int i=rk[c]+1; i<=N; i++){
		if(height[i]<=ans)	break;
		len=std::min(len, height[i]);
		if(sa[i]<=b && sa[i]>=a)
			ans=std::max(ans, std::min(std::min(b-sa[i]+1, d-c+1), len));
	}
	return ans;
}

int main(){
	int a, b, c, d;
	input();
	SuffixSort();
	while(M--){
		get_int(a);	get_int(b);	get_int(c);	get_int(d);
		printf("%d\n", solve(a, b, c, d));
	}
	return 0;
}
```

---

## 作者：foreverlasting (赞：12)

题解同步发在[新博客](https://foreverlasting1202.github.io/)

[题面](https://www.luogu.org/problemnew/show/P4094)

后缀自动机。

这还算是一道比较好想的题吧。首先直接求最长肯定不行，那么就二分一下长度，然后判断$s[c,d+l-1]$是否在$s[a,b]$出现过。这是基本套路吧，前缀不好搞那么变成后缀，是否出现直接线段树合并+倍增就好了。

code:
```
//2018.11.18 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=1e5+10;
namespace MAIN{
    int n,m;
    struct SAM{
        struct Sam{
            int vis[26],par,len;
        }sam[N<<1];
        int cnt,las,rt;
        SAM() {cnt=las=rt=1;}
        inline void extend(const res &x){
            res p=las,np=++cnt;
            las=np,sam[np].len=sam[p].len+1;
            for(;p&&!sam[p].vis[x];p=sam[p].par)sam[p].vis[x]=np;
            if(!p)sam[np].par=rt;
            else {
                res q=sam[p].vis[x];
                if(sam[q].len==sam[p].len+1)sam[np].par=q;
                else {
                    res nq=++cnt;
                    memcpy(sam[nq].vis,sam[q].vis,sizeof(sam[nq].vis));
                    sam[nq].par=sam[q].par;
                    sam[nq].len=sam[p].len+1;
                    sam[q].par=sam[np].par=nq;
                    for(;p&&sam[p].vis[x]==q;p=sam[p].par)sam[p].vis[x]=nq;
                }
            }
        }
    }A;
    char str[N];
    int ls[N<<6],rs[N<<6],sum[N<<6],rt[N<<1],tot;
    inline void pushup(const res &rt){
        sum[rt]=sum[ls[rt]]+sum[rs[rt]];
    }
    int merge(const res &x,const res &y,const res &l,const res &r){
        if(!x||!y)return x+y;
        if(l==r){sum[x]+=sum[y];return x;}
        res mid=(l+r)>>1,z=++tot;
        ls[z]=merge(ls[x],ls[y],l,mid);
        rs[z]=merge(rs[x],rs[y],mid+1,r);
        pushup(z);
        return z;
    }
    void update(res &rt,const res &l,const res &r,const res &p){
        if(!rt)rt=++tot;
        if(l==r){sum[rt]++;return;}
        res mid=(l+r)>>1;
        if(p<=mid)update(ls[rt],l,mid,p);
        else update(rs[rt],mid+1,r,p);
        pushup(rt);
    }
    int query(const res &rt,const res &l,const res &r,const res &L,const res &R){
        if(!rt)return 0;
        if(L<=l&&r<=R)return sum[rt];
        res mid=(l+r)>>1,ret=0;
        if(L<=mid)ret+=query(ls[rt],l,mid,L,R);
        if(R>mid)ret+=query(rs[rt],mid+1,r,L,R);
        return ret;
    }
    int buc[N<<1],rnk[N<<1];
    int F[N<<1][21],pos[N];
    inline bool check(const res &lim,res p,const res &l,const res &r){
        for(res i=20;~i;i--)if(A.sam[F[p][i]].len>=lim&&F[p][i])p=F[p][i];
        return query(rt[p],1,n,l+lim-1,r);
    }
    inline void MAIN(){
        n=read(),m=read();
        scanf("%s",str+1);
        reverse(str+1,str+n+1);
        for(res i=1;i<=n;i++)A.extend(str[i]-'a'),update(rt[A.las],1,n,i),pos[i]=A.las;
        for(res i=1;i<=A.cnt;i++)buc[A.sam[i].len]++;
        for(res i=1;i<=A.cnt;i++)buc[i]+=buc[i-1];
        for(res i=1;i<=A.cnt;i++)rnk[buc[A.sam[i].len]--]=i;
        for(res i=A.cnt;i>=1;i--)if(A.sam[rnk[i]].par)rt[A.sam[rnk[i]].par]=merge(rt[A.sam[rnk[i]].par],rt[rnk[i]],1,n),F[i][0]=A.sam[i].par;
        for(res j=1;j<=20;j++)
            for(res i=1;i<=A.cnt;i++)
                F[i][j]=F[F[i][j-1]][j-1];
        while(m--){
            res a=n-read()+1,b=n-read()+1,c=n-read()+1,d=n-read()+1;
            res l=0,r=_min(a-b+1,c-d+1),ret=0;
            while(l<=r){
                res mid=(l+r)>>1;
                if(check(mid,pos[c],b,a))l=mid+1,ret=mid;
                else r=mid-1;
            }
            printf("%d\n",ret);
        }
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：Alex_Wei (赞：9)

> [P4094 [HEOI2016/TJOI2016]字符串 题面传送门](https://www.luogu.com.cn/problem/P4094)

> 题意简述：给出字符串 $s$，多次询问 $a,b,c,d$ 求 $s[a:b]$ 的所有子串与 $s[c:d]$ 的最长公共前缀的最大值。

> [我的 SAM 学习笔记 例题 X.](https://www.cnblogs.com/alex-wei/p/Suffix_Automaton.html)

---

首先，SAM 不太方便处理前缀，所以将整个串翻转（询问不要忘记翻转），这样就转化为了最长公共后缀。接下来求 $s[1:d]$ 所代表的状态，设为 $p$，直接在建 SAM 时预处理即可。

直接不管 $c$ 的限制，问题转化为求出 $s[a:b]$ 所有子串与 $s[1:d]$ 的最长公共后缀长度，并与 $d-c+1$ 取 $\min$。

根据 SAM 的性质，$link$ 树上所有 $p$ 的祖先都表示 $s[1:d]$ 的一个或多个后缀。我们可以找到一个状态 $q$ 满足 $q$ 是 $p$ 的祖先且 $\left(\max_{x\in endpos(q),x\leq b}x\right)-a+1\leq len(q)$（也就是该状态所表示的字符串在 $b$ 或 $b$ 之前出现的最靠右的结束位置，至于为什么要最靠右显而易见（右边的出现位置肯定优于左边的出现位置，因为有左端点 $a$ 的限制），读者可自行理解），**且 $len(q)$ 的值最小，那么最长公共后缀肯定在 $q$ 或 $link(q)$ 所表示的子串中。**

- 先说说为什么要 $len(q)$ 最小：假设存在 $q'$ 满足上述条件，但 $len(q')>len(q)$，即 $q$ 是 $q'$ 的祖先（同时 $q'$ 是 $p$ 的祖先）。记 $\max_{x\in endpos(q),x\leq b}x$ 为 $maxp(q,b)$，那么根据 $endpos$ 和 $link$ 的性质，即 $endpos(q')\subsetneq endpos(q)$，因此，$maxp(q',b)\leq maxp(q,b)$，即 $q'$ 点所表示字符串在 $b$ 或 $b$ 之前出现的最大结束位置，一定不大于 $q$ 点所表示的字符串在 $b$ 或 $b$ 之前出现的最大结束位置。因此 $maxp(q',b)-a+1\leq maxp(q,b)-a+1$。又因为 $len(q)\ (len(q'))\geq maxp(q,b)\ (maxp(q',b)) -a+1$，即 $q$ 和 $q'$ 所表示的的最长字符串超出了 $a$ 的限制，所以我们是用 $maxp$ 值 $-a+1$ 求出在 $a$ 的限制下该状态对答案的贡献。故 $q$ 一定比 $q'$ 更优。

- 再说说为什么要算上 $link(q)$：![](https://cdn.luogu.com.cn/upload/image_hosting/2ggzru0w.png)
  一 目 了 然，不 言 而 喻。

- 同时，因为 $link(q)$ 的贡献已经是 $len(q)$ 了，如果再往上跳 $maxp$ 递增，贡献也一定是该点的 $len$ 值，这是递减的，所以不需要再往上考虑。

说完了思路，接下来讲讲怎么实现：用线段树合并维护 $endpos$ 集合可以轻松在 $\log$ 时间内求出 $maxp$。同时，因为满足条件的 $q$ 满足二分条件，所以求 $q$ 直接用 $p$ 在 $link$ 树上倍增即可。那么最后答案即为 $\min(\max(maxp(q,b)-a+1,len(link(q))),d-c+1)$。（不需要特判答案为 $0$ 的情况，因为此时 $maxp(q,b)-a+1$ 不小于 $0$，而 $len(link(q))$ 显然为 $0$）

时间复杂度 $\mathcal{O}(q\log^2 n)$。

```cpp
/*
	Powered by C++11.
	Author : Alex_Wei.
*/

#include <bits/stdc++.h>
using namespace std;

//#pragma GCC optimize(3)

//using int = long long
//using i128 = __int128;

using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
using db = double;
using ld = long double;
using pii = pair <int,int>;
using pll = pair <ll,ll>;
using pdd = pair <double,double>;
using vint = vector <int>;
using vpii = vector <pii>;

#define fi first
#define se second
#define pb emplace_back
#define mpi make_pair
#define all(x) x.begin(),x.end()
#define sor(x) sort(all(x))
#define rev(x) reverse(all(x))
#define mem(x,v) memset(x,v,sizeof(x))
#define mcpy(x,y) memcpy(x,y,sizeof(y))
#define Time 1.0*clock()/CLOCKS_PER_SEC

pii operator + (pii a,pii b){return {a.fi+b.fi,a.se+b.se};}
pll operator + (pll a,pll b){return {a.fi+b.fi,a.se+b.se};}

namespace IO{
	char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<24],*O=obuf;
	#ifdef __WIN32
		#define gc getchar()
	#else
		#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
	#endif
	#define pc(x) (*O++=x)
	#define flush() fwrite(obuf,O-obuf,1,stdout)
	inline ll read(){
		ll x=0; bool sign=0; char s=gc;
		while(!isdigit(s))sign|=s=='-',s=gc;
		while(isdigit(s))x=(x<<1)+(x<<3)+(s-'0'),s=gc;
		return sign?-x:x;
	}
	inline void print(ll x){
		if(x<0)pc('-'),print(-x);
		else{
			if(x>9)print(x/10);
			pc(x%10+'0');
		}
	}
} using namespace IO;

const int N=2e5+5;
const int S=26;

int node,rt[N],ls[N<<5],rs[N<<5],val[N<<5];
void push(int x){
	val[x]=max(val[ls[x]],val[rs[x]]);
} void ins(int l,int r,int p,int &x){
	x=++node;
	if(l==r)return val[x]=p,void();
	int m=l+r>>1;
	if(p<=m)ins(l,m,p,ls[x]);
	else ins(m+1,r,p,rs[x]);
	push(x);
} int merge(int l,int r,int x,int y){
	if(!x||!y)return x|y;
	int z=++node,m=l+r>>1;
	if(l==r)return val[z]=max(val[x],val[y]),z;
	ls[z]=merge(l,m,ls[x],ls[y]),rs[z]=merge(m+1,r,rs[x],rs[y]);
	return push(z),z;
} int query(int l,int r,int ql,int qr,int x){
	if(!x)return 0;
	if(ql<=l&&r<=qr)return val[x];
	int m=l+r>>1,ans=0;
	if(ql<=m)ans=query(l,m,ql,qr,ls[x]);
	if(m<qr)ans=max(ans,query(m+1,r,ql,qr,rs[x]));
	return ans;
}

// Suffix_Automaton
int a,b,c,d;
int n,m,K,cnt,las;
int fa[N],len[N],son[N][S];
int buc[N],id[N],f[N][S],ed[N];
vector <int> e[N];
void ins(int it){
	int p=las,cur=++cnt;
	len[cur]=len[las]+1,las=cur;
	ins(1,n,len[cur],rt[cur]),ed[len[cur]]=cur;
	while(p&&!son[p][it])son[p][it]=cur,p=fa[p];
	if(!p)return fa[cur]=1,void();
	int q=son[p][it];
	if(len[p]+1==len[q])return fa[cur]=q,void();
	int cl=++cnt;
	fa[cl]=fa[q],fa[q]=fa[cur]=cl,len[cl]=len[p]+1;
	mcpy(son[cl],son[q]);
	while(p&&son[p][it]==q)son[p][it]=cl,p=fa[p];
} void build(char *s){
	las=cnt=1,K=log2(n);
	for(int i=1;i<=n;i++)ins(s[i]-'a');
	for(int i=1;i<=cnt;i++)buc[len[i]]++;
	for(int i=1;i<=n;i++)buc[i]+=buc[i-1];
	for(int i=cnt;i;i--)id[buc[len[i]]--]=i;
	for(int i=cnt;i>1;i--)rt[fa[id[i]]]=merge(1,n,rt[fa[id[i]]],rt[id[i]]);
	for(int j=0;j<=K;j++)for(int i=1;i<=cnt;i++)f[i][j]=j?f[f[i][j-1]][j-1]:fa[i];
} int qpos(int pos){
	return query(1,n,1,b,rt[pos]);
}

char s[N];
int main(){
	cin>>n>>m,scanf("%s",s+1);
	reverse(s+1,s+n+1),build(s);
	while(m--){
		cin>>a>>b>>c>>d;
		a=n-a+1,b=n-b+1,c=n-c+1,d=n-d+1,swap(a,b),swap(c,d);
		int p=ed[d];
		for(int i=K;~i;i--)if(f[p][i]){
			int pp=f[p][i],pos=qpos(pp);
			if(len[pp]>=pos-a+1)p=pp;
		} int pos=qpos(p);
		cout<<min(d-c+1,max(pos-a+1,len[f[p][0]]))<<endl;
	}
	return 0;
}
```

---

## 作者：Sol1 (赞：7)

黑题竟然不看题解切了，感动。

问题：给定一个字符串 $s$ 和两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$。请求出一个子串 $[l_3,r_3]$ 使得 $l_1\leq l_3\leq r_3\leq r_1$ 且 $\operatorname{lcp}(s_{[l_3,r_3]},s_{[l_2,r_2]})$ 最大。

首先，这个 $r_3$ 没有用，显然有一个最优方案使得 $r_3=r_1$。

所以需要决策的只剩下 $l_3$。

考虑求出原字符串的后缀数组和 Height。

这时会有一个比较直接的思路是这样：因为求 $\text{lcp}(x,y)$ 等价于在 Height 数组上求 $(r_x,r_y]$ 区间的最小值（其中 $r$ 对应 rank 数组），而由于区间的一端已经固定为 $r_c$，所以考虑维护出 rank 的主席树，每次在区间 $[a,b]$ 中查找 $r_c$ 的前驱和后继，查出 lcp 然后对两个区间长度取 $\min$ 就可以了，复杂度 $O(n\log n)$。

~~可惜这样是错的。~~

为什么是错的呢？

因为这样只保证了在 **不对区间长度取 min** 时得到最优答案，而无法保证 **取完 min 之后** 的答案仍是最优的。

例如如下数据：

```plain
12 1
abcabcabcdef
1 5 4 12
```

正确答案是 $5$，而我们的算法会给出 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/w4capja7.png)

卡点大概是匹配得更多的那个字符串有很多都超出了区间，于是就还不如匹配得更少的那个。

但是我们可以改进我们的算法。考虑二分答案 $x$，每次利用上述算法对区间 $[a,b-x+1]$ 求解，如果得到的答案 $\geq x$ 就认为合法。

会有疑问，上面那个算法不是依然得不到最优解吗？

**但是，此时可以保证，即使由于上面的叉点导致解不是最优，也一定可以满足二分的限制，所以仍然可以做出正确的判定，而这就足够了。**

所以最后我们算法的复杂度是二分一个 $\log$，主席树一个 $\log$，故总复杂度 $O(n\log n+m\log^2n)$，空间 $O(n\log n)$，足以通过本题。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int N = 100005;
int n, m, suf[N], rnk[N], a[N], b[N], cnt[N], h[N], st[N][25], suftmp[N];
char s[N];

#define Sum(p) (p ? p->sum : 0)
#define Lc(p) (p ? p->l : NULL)
#define Rc(p) (p ? p->r : NULL)
struct Node {
	int sum;
	Node *l, *r;
	inline void Update() {
		sum = Sum(l) + Sum(r);
	}
};
Node nd[30 * N];
int top;
struct Segtree {
	Node *_root[N];
	inline void Ins(Node *&p1, Node *p2, int pl, int pr, int v) {
		p1 = &nd[++top];
		if (p2) nd[top] = *p2;
		if (pl == pr) {
			p1->sum++;
			return;
		}
		int mid = pl + pr >> 1;
		if (v <= mid) Ins(p1->l, Lc(p2), pl, mid, v);
		else Ins(p1->r, Rc(p2), mid + 1, pr, v);
		p1->Update();
	}
	inline int Rnk(Node *p1, Node *p2, int pl, int pr, int l, int r) {
		if (pl == l && pr == r) return Sum(p2) - Sum(p1);
		int mid = pl + pr >> 1;
		if (mid >= r) return Rnk(Lc(p1), Lc(p2), pl, mid, l, r);
		else if (mid + 1 <= l) return Rnk(Rc(p1), Rc(p2), mid + 1, pr, l, r);
		else return Rnk(Lc(p1), Lc(p2), pl, mid, l, mid) + Rnk(Rc(p1), Rc(p2), mid + 1, pr, mid + 1, r);
	}
	inline int Kth(Node *p1, Node *p2, int pl, int pr, int k) {
		if (k <= 0) return 0;
		if (k > Sum(p2) - Sum(p1)) return n + 1;
		if (pl == pr) return pl;
		int cntl = Sum(Lc(p2)) - Sum(Lc(p1)), mid = pl + pr >> 1;
		if (cntl >= k) return Kth(Lc(p1), Lc(p2), pl, mid, k);
		else return Kth(Rc(p1), Rc(p2), mid + 1, pr, k - cntl);
	}
	inline int Lower(int l, int r, int x) {
		return Kth(_root[l - 1], _root[r], 1, n, Rnk(_root[l - 1], _root[r], 1, n, 1, x));
	}
	inline int Upper(int l, int r, int x) {
		return Kth(_root[l - 1], _root[r], 1, n, Rnk(_root[l - 1], _root[r], 1, n, 1, x) + 1);
	}
};
Segtree sgt;

inline void Read() {
	scanf("%d%d", &n, &m);
	scanf("%s", s + 1);
}

inline bool cmp(int i, int j) {
	return s[i] < s[j];
}

inline void Prefix() {
	for (int i = 1;i <= n;i++) suf[i] = i;
	sort(suf + 1, suf + n + 1, cmp);
	for (int i = 1;i <= n;) {
		int l = i;
		while (i <= n && s[suf[l]] == s[suf[i]]) rnk[suf[i++]] = l;
	}
	for (int k = 1;k <= 19;k++) {
		for (int i = 1;i <= n;i++) b[i] = (i + (1 << k - 1) > n ? 0 : rnk[i + (1 << k - 1)]);
		memset(cnt, 0, sizeof(cnt));
		for (int i = 1;i <= n;i++) cnt[b[i]]++;
		for (int i = 1;i <= n;i++) cnt[i] += cnt[i - 1];
		for (int i = n;i >= 1;i--) suftmp[cnt[b[i]]--] = i;
		for (int i = 1;i <= n;i++) a[i] = rnk[i];
		memset(cnt, 0, sizeof(cnt));
		for (int i = 1;i <= n;i++) cnt[a[i]]++;
		for (int i = 1;i <= n;i++) cnt[i] += cnt[i - 1];
		for (int i = n;i >= 1;i--) suf[cnt[a[suftmp[i]]]--] = suftmp[i];
		for (int i = 1;i <= n;) {
			int l = i;
			while (i <= n && a[suf[l]] == a[suf[i]] && b[suf[l]] == b[suf[i]]) rnk[suf[i++]] = l;
		}
	}
	for (int i = 1;i <= n;i++) {
		h[rnk[i]] = Max(h[rnk[i - 1]] - 1, 0);
		while (s[i + h[rnk[i]]] == s[suf[rnk[i] - 1] + h[rnk[i]]]) h[rnk[i]]++;
	}
	//for (int i = 1;i <= n;i++) printf("%d ", h[i]); puts("");
	for (int i = 1;i <= n;i++) st[i][0] = h[i];
	for (int j = 1;j <= 19;j++) {
		for (int i = 1;i <= n;i++) {
			if (i + (1 << j - 1) > n) break;
			st[i][j] = Min(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
		}
	}
	for (int i = 1;i <= n;i++) sgt.Ins(sgt._root[i], sgt._root[i - 1], 1, n, rnk[i]);
}

inline int Lcp(int l, int r) {
	if (l == r) return n - suf[r] + 1;
	if (l > r) swap(l, r);
	l++;
	int k = 31 - __builtin_clz(r - l + 1);
	return Min(st[l][k], st[r - (1 << k) + 1][k]);
}

inline void Solve() {
	while (m--) {
		int a, b, c, d;
		scanf("%d%d%d%d", &a, &b, &c, &d);
		int l = 0, r = Min(b - a + 1, d - c + 1) + 1;
		while (l < r - 1) {
			int mid = l + r >> 1;
			int x1 = sgt.Lower(a, b - mid + 1, rnk[c]), x2 = sgt.Upper(a, b - mid + 1, rnk[c]);
			if (Max(Min(Min(Lcp(x1, rnk[c]), b - suf[x1] + 1), d - c + 1), Min(Min(Lcp(x2, rnk[c]), b - suf[x2] + 1), d - c + 1)) >= mid) l = mid;
			else r = mid;
		}
		printf("%d\n", l);
	}
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：x7103 (赞：4)

[**不知道更好还是更差的阅读体验**](https://www.cnblogs.com/VCLS01/p/14757453.html)
## 题目描述
给定长度为 $n$ 的由小写字母组成的字符串 $s$，有 $m$ 个询问，每次询问给定 $a,b,c,d$，求 $s[a\ldots b]$ 的所有子串与 $s[c\ldots d]$ 的最长公共前缀。

**数据范围：**$1\le n,m\le10^5$，$1\le a<b\le n$，$1\le c<d\le n$。

**时间限制：**$2000\operatorname{ms}$。
## Solution
对于每个子串求 $LCP$ 最大值比较复杂，时间复杂度为 $\Theta(n^2\log n)$，难以接受。

有一个很显然的性质：若 $k$ 为可行答案，则任何比 $k$ 小的值都为可行答案。

因此考虑**二分**。二分答案的最大值，假设当前答案为 $len$，会有如下的性质：

1. 我们可以找到一个子串 $ans$ 完全位于 $[a,b]$ 之间，则 $ans$ 的开头应该位于 $[a,b-len+1]$ 之间。
2. $LCP(ans,s[c\ldots n])\ge len$。

由 $height$ 数组的性质，我们可以发现，满足第二个性质的 $ans$ 开头一定是一段包含 $c$ 的连续区间。

我们可以二分出这个区间，然后检验第一个性质是否成立，这步可以通过主席树来实现。主席树存储可能存在答案的区间内是否有 $i$ 使 $sa[i]\in[a,b-len+1]$。

时间复杂度为 $\Theta(n\log^2n)$，期望得分 $100\operatorname{pts}$。
## Code（实现极丑）
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=100010;
char s[maxn];
int sa[maxn],c[maxn],x[maxn],y[maxn],n,m;
int rk[maxn],height[maxn];
int q,tot,st[maxn][18],lg2[maxn],root[maxn];
template<class T>inline T Min(const T &a,const T &b){return a<b?a:b;}
inline void GetSA(){
	for(int i=1;i<=n;++i)++c[x[i]=s[i]];
	for(int i=2;i<=m;++i)c[i]+=c[i-1];
	for(int i=n;i;--i)sa[c[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1){
		int num=0;
		for(int i=n-k+1;i<=n;++i)y[++num]=i;
		for(int i=1;i<=n;++i)
			if(sa[i]>k)y[++num]=sa[i]-k;
		for(int i=1;i<=m;++i)c[i]=0;
		for(int i=1;i<=n;++i)++c[x[i]];
		for(int i=2;i<=m;++i)c[i]+=c[i-1];
		for(int i=n;i;--i)sa[c[x[y[i]]]--]=y[i],y[i]=0;
		swap(x,y);
		x[sa[1]]=1,num=1;
		for(int i=2;i<=n;++i)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
		if(num==m)break;
		m=num;
	}
}
inline void GetHeight(){
	for(int i=1;i<=n;++i)rk[sa[i]]=i;
	for(int i=1,k=0;i<=n;++i){
		if(rk[i]==1)continue;
		if(k)--k;
		int j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])++k;
		height[rk[i]]=k;
	}
}
struct SegmentTree{
	int lc,rc,v;
}tr[maxn*20];
inline void pushup(int u){
	tr[u].v=tr[tr[u].lc].v+tr[tr[u].rc].v;
}
inline int Insert(int p,int l,int r,int x){
	int u=++tot;
	if(l==r){tr[u].v=tr[p].v+1;return u;}
	int mid=(l+r)>>1;
	if(x<=mid){
		tr[u].rc=tr[p].rc;
		tr[u].lc=Insert(tr[p].lc,l,mid,x);
	}
	else{
		tr[u].lc=tr[p].lc;
		tr[u].rc=Insert(tr[p].rc,mid+1,r,x);
	}
	pushup(u);
	return u;
}
inline int query(int p,int q,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)return tr[q].v-tr[p].v;
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid)ans=query(tr[p].lc,tr[q].lc,l,mid,ql,qr);
	if(mid<qr)ans+=query(tr[p].rc,tr[q].rc,mid+1,r,ql,qr);
	return ans;
}
inline void InitST(){
	for(int i=1;i<=n;++i)st[i][0]=height[i],lg2[i]=log2(i);
	for(int i=1;i<18;++i)
		for(int j=1;j+(1<<i)-1<=n;++j)
			st[j][i]=Min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
}
inline int queryST(int l,int r){
	if(l>r)swap(l,r);
	if(l==r)return n-l+1;
	++l;
	int t=lg2[r-l+1];
	return Min(st[l][t],st[r-(1<<t)+1][t]);
}
inline bool check(int len,int a,int b,int c,int d){
	int l=1,r=rk[c],ql,qr;
	while(l<r){
		int mid=(l+r)>>1;
		if(queryST(mid,rk[c])<len)l=mid+1;
		else r=mid;
	}
	ql=r;
	l=rk[c],r=n;
	while(l<r){
		int mid=(l+r+1)>>1;
		if(queryST(rk[c],mid)<len)r=mid-1;
		else l=mid;
	}
	qr=l;
	if(query(root[ql-1],root[qr],1,n,a,b-len+1)>0)return true;
	else return false;
}
inline int solve(int a,int b,int c,int d){
	int l=0,r=Min(b-a+1,d-c+1);
	while(l<r){
		int mid=(l+r+1)>>1;
		if(check(mid,a,b,c,d))l=mid;
		else r=mid-1;
	}
	return l;
}
int main(){
	scanf("%d%d",&n,&q);
	scanf("%s",s+1);m='z';
	GetSA();GetHeight();
	for(int i=1;i<=n;++i)
		root[i]=Insert(root[i-1],1,n,sa[i]);
	InitST();
	while(q--){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		printf("%d\n",solve(a,b,c,d));
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

SAM做法不一定要用反串构建SAM。给出一种正串建SAM的做法。

如果直接求询问的答案似乎很困难，因为 $s[a \dots b]$ 的所有子串数量级是 $O(n^2)$ 级别的，一个个算  LCP (即使是在SAM上) 肯定也是不行的。

考虑二分答案。易知答案的范围在 $[0,\min \{ b-a+1,d-c+1\}]$ 之间，假设现在二分答案 $mid$ ，即答案是否大于等于 $mid$ 。若答案大于等于 $mid$ ，那么根据题意，**$s[c \dots c+mid-1]$ 必定是 $s[a \dots b]$ 的子串。** 那么我们可以在SAM上找到表示 $s[c \dots c+mid-1]$ 的点，假设为点 $p$ ，然后查询点 $p$ 包不包含 $s[a \dots b]$ ，即 $p$ 的 $endpos$ 集合在区间 $[a+mid-1,b]$ 中有没有元素。这个判断用线段树合并即可完成。

那么如何求点 $p$ 呢？根据SAM的Parent Tree的性质，若 $u$ 是 $v$ 的祖先，那么 $u$ 所能代表的字符串一定都是 $v$ 所能代表的后缀。那么我们可以找到表示前缀 $c[1 \dots c+mid-1]$ 的点，设其为 $u$ ，然后不断往上跳 
$\texttt{fa}$ ，直到跳到代表 $s[c \dots c+mid-1]$ 的 (即 $p$ ) 点。但怎么判断这个节点是不是代表 $s[c \dots c+mid-1]$ 的 (即 $p$ ) 节点呢？稍加分析即可得知， $p$ 一定是 $u$ 的祖先中， **$\texttt{maxLen}$ 大于等于 $mid$ 且深度最浅(最靠上)的点。** 但还剩一个问题，一个个跳 $\texttt{fa}$ 的复杂度显然是错的，考虑倍增。类似于倍增求 LCA ，从 $fa_{u\ 18}$ 到 $fa_{u\ 0}$ 枚举，只要 $fa_{u\ i}$ 的 $len$ 大于等于 $mid$ ，那么就往上跳到 $fa_{u\ i}$ 。

```cpp
#include <vector>
#include <stdio.h>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

inline bool islower (char &ch) { return ch >= 'a' && ch <= 'z'; }
inline bool isdigit (char &ch) { return ch >= '0' && ch <= '9'; }
inline int idx (char &ch) { return ch - 'a'; } // idx是每个字符在SAM中对应的编号(如'a'对应0)

inline char gc () {
	static char buf[1048576], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1048576, stdin), p1 == p2) ? EOF : *p1 ++ ;
}

int readi () {
	int ans = 0; char ch = gc();
	while(!isdigit(ch)) ch = gc();
	while(isdigit(ch)) ans = ans * 10 + ch - '0', ch = gc();
	return ans;
}

int reads (char *S) {
	int p = 0; char ch = gc();
	while(!islower(ch)) ch = gc();
	while(islower(ch)) S[++ p] = ch, ch = gc();
	S[p + 1] = 0; return p;
}

//以上全是快读

const int N = 1e5 + 5;
int rt[N << 1]; // SAM中每个节点在线段树上的root
struct SegmentTree { // 线段树合并
	int sum[N * 80];
	int lch[N * 80], rch[N * 80];
	int cnt;
	
	inline void pushup (int u) { sum[u] = sum[lch[u]] + sum[rch[u]]; }
	void update (int &u, int x, int l, int r, int v) {
		if(!u) u = ++ cnt;
		if(l == r) { sum[u] += v; return; }
		
		int mid = l + r >> 1;
		if(mid >= x) update(lch[u], x, l, mid, v);
		else update(rch[u], x, mid + 1, r, v);
		pushup(u);
	}
	
	int merge (int u, int v, int l, int r) {
		if(!u || !v) return u | v;
		int w = ++ cnt;
		if(l == r) { sum[w] = sum[u] + sum[v]; return w; }
		
		int mid = l + r >> 1;
		lch[w] = merge(lch[u], lch[v], l, mid);
		rch[w] = merge(rch[u], rch[v], mid + 1, r);
		pushup(w); return w;
	}
	
	int query (int u, int ql, int qr, int l, int r) {
		if(!u) return 0;
		if(l >= ql && r <= qr) return sum[u];
		
		int mid = l + r >> 1, ret = 0;
		if(mid >= ql) ret += query(lch[u], ql, qr, l, mid);
		if(mid < qr) ret += query(rch[u], ql, qr, mid + 1, r);
		return ret;
	}
} seg;

int n, q;
int ed[N]; // ed[i]代表前缀s[1...i]在SAM中的对应哪个点

struct SAM {
	int ch[N << 1][26];
	int fa[N << 1][19] /*倍增*/, len[N << 1];
	vector <int> g[N << 1]; // Parent Tree
	int cnt, lst;
	SAM () { cnt = lst = 1; }
	
	void insert (int c) { // 标准SAM构建
		int p = lst, np = ++ cnt; lst = np;
		len[np] = len[p] + 1; seg.update(rt[np], len[np], 1, n, 1);
		
		for(; p && !ch[p][c]; p = fa[p][0])
			ch[p][c] = np;
		
		if(!p) fa[np][0] = 1;
		else {
			int q = ch[p][c];
			
			if(len[q] == len[p] + 1) fa[np][0] = q;
			else {
				int nq = ++ cnt;
				memcpy(ch[nq], ch[q], sizeof ch[q]);
				fa[nq][0] = fa[q][0];
				len[nq] = len[p] + 1;
				fa[np][0] = fa[q][0] = nq;
				
				for(; p && ch[p][c] == q; p = fa[p][0])
					ch[p][c] = nq;
			}
		}
	}
	
	void buildSAM (char *S) { // 建SAM
		for(int i = 1; S[i]; ++ i)
			insert(idx(S[i]));
	}
	
	void updEndPos (char *S) { // ed的含义在上面(这个EndPos不是SAM中的endpos)
    //个人习惯在建完SAM之后再更新ed[i]，因为SAM的结构可能随着字符的增多而改变之前的形态(endpos出现歧义时候的分裂)
		for(int i = 1, p = 1; S[i]; ++ i) {
			p = ch[p][idx(S[i])];
			ed[i] = p;
		}
	}
	
	void buildParentTree () { // 建Parent Tree
		for(int i = 2; i <= cnt; ++ i)
			g[fa[i][0]].push_back(i);
	}
	
	void dfsParentTree (int u) { // dfs，预处理倍增和endpos集合
		for(int i = 1; i < 19; ++ i)
			fa[u][i] = fa[fa[u][i - 1]][i - 1];
		
		for(int i = 0; i < g[u].size(); ++ i) {
			int v = g[u][i];
			dfsParentTree(v);
			rt[u] = seg.merge(rt[u], rt[v], 1, n);
		}
	}
	
	int findNode (int c, int mid) { // 找符合条件的点p(代表s[c...c+mid-1]的点)
		int p = ed[c + mid - 1];
		for(int i = 18; ~i; -- i) 
			if(fa[p][i] && len[fa[p][i]] >= mid) // 只要len[fa[p][i]]大于等于mid就往上跳
            	p = fa[p][i];
		
		return p;
	}
} sam;

bool check (int a, int b, int c, int mid) { // 查询mid是否合法
	int p = sam.findNode(c, mid);
	return (bool)(seg.query(rt[p], a + mid - 1, b, 1, n)); // s[c...c+mid-1]是否在s[a...b]出现过
}

void solve () {
	int a, b, c, d; a = readi(); b = readi(); c = readi(); d = readi();

	int l = 0, r = min(b - a + 1, d - c + 1);
	int mid;
	while(l < r) {
		mid = l + r + 1 >> 1; // 向上取整
		if(check(a, b, c, mid)) l = mid;
		else r = mid - 1;
	}
	
	printf("%d\n", l);
}

char S[N];

int main () {

	n = readi(); q = readi();
	reads(S);
	sam.buildSAM(S);
	sam.buildParentTree();
	sam.dfsParentTree(1);
	sam.updEndPos(S);
	//全是预处理
    
	while(q -- ) solve();

	return 0;
}
```

---

## 作者：_LHF_ (赞：2)

一道不错的题。

看到题多半会想到后缀数组吧。

首先先求出 sa,rk,height 数组，，我们现在其实就是要在$[a..b]$中选一个位置 $w$，最大化 $\min(b-w+1,d-c+1,lcp(w,c))$，考虑到$lcp(sa[i],sa[j])=\min_{k=i+1}^jht[k]$ 变一下得到 $lcp(i,j)=\min_{k=rk[i]+1}^{rk[j]}ht[k]$，很显然，我们现在就是要选最接近 $rk[c]$ 的位置 $w$，显然，有两个（一个比 $rk[w]$ 大，一个比 $rk[w]$ 小，也就是找区间内的前驱后继）

还有一个问题：我们还有取 $\min$ 操作，直接搞会很复杂……

不过这个也挺好弄，我们可以先二分一个答案，判断它是否可行即可。

问题是如何在一个 $\log$ 内找出前驱后继。

显然数组是静态的，所以我们可以直接用可持久化线段树实现，具体实现比较简单，不再赘述。

上代码：
```cpp
#include<cstdio>
#include<algorithm>
#define mid ((l+r)>>1)
#define N 300010
#define M 4000010
using namespace std;
namespace chair_man_tree
{
	int t[M],ls[M],rs[M],w,cnt;
	void update(int now)
	{
		t[now]=t[ls[now]]+t[rs[now]];
	}
	void add(int l,int r,int&p,int q)
	{
		if(!p) p=++cnt;
		if(l==r){t[p]++;return;}
		if(w<=mid)
		{
			rs[p]=rs[q];
			add(l,mid,ls[p],ls[q]);
		}
		else
		{
			ls[p]=ls[q];
			add(mid+1,r,rs[p],rs[q]);
		}
		update(p);
	}
	int sum(int l,int r,int p,int q)
	{
		if(r<=w) return t[q]-t[p];
		if(l>w||t[q]-t[p]==0) return 0;
		return sum(l,mid,ls[p],ls[q])+sum(mid+1,r,rs[p],rs[q]);
	}
	int kth(int l,int r,int k,int p,int q)
	{
		if(l==r) return l;
		if(k<=t[ls[q]]-t[ls[p]]) return kth(l,mid,k,ls[p],ls[q]);
		else return kth(mid+1,r,k-(t[ls[q]]-t[ls[p]]),rs[p],rs[q]);
	}
}
int n;
namespace ST
{
	int f[20][N],lg[N],x;
	void init(int*a)
	{
		f[0][1]=1;
		for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1,f[0][i]=a[i];
		for(int i=1;(1<<i)<=n;i++)
			for(int j=1;j+(1<<(i-1))<=n;j++)
				f[i][j]=min(f[i-1][j],f[i-1][j+(1<<(i-1))]);
	}
	int query(int l,int r)
	{
		x=lg[r-l];
		return min(f[x][l],f[x][r-(1<<x)+1]);
	}
}
char s[N];
int sa[N],rk[N],ht[N];
namespace SA
{
	int id[N],px[N],ork[N],t[N];
	bool cmp(int a,int b,int c)
	{return ork[a]==ork[b]&&ork[a+c]==ork[b+c];}
	void main()
	{
		int i,w,p,m=300;
		for(i=1;i<=n;i++) t[rk[i]=s[i]]++;
		for(i=1;i<=m;i++) t[i]+=t[i-1];
		for(i=n;i;i--) sa[t[rk[i]]--]=i;
		for(w=1;w<n;w<<=1,m=p)
		{
			for(i=1;i<=m;i++) t[i]=0;
			for(p=0,i=n;i>n-w;i--) id[++p]=i;
			for(i=1;i<=n;i++) if(sa[i]>w) id[++p]=sa[i]-w;
			for(i=1;i<=n;i++) t[px[i]=rk[id[i]]]++;
			for(i=1;i<=m;i++) t[i]+=t[i-1];
			for(i=n;i;i--) sa[t[px[i]]--]=id[i];
			for(i=1;i<=n;i++) ork[i]=rk[i];
			for(p=0,i=1;i<=n;i++) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p;
		}
		for(i=1,p=0;i<=n;i++)
		{
			if(p) p--;
			while(s[i+p]==s[sa[rk[i]-1]+p]) p++;
			ht[rk[i]]=p;
		}
	}
}
using namespace chair_man_tree;
int a,b,c,d,rt[N],T,l,r;
bool check(int len)
{
	register int ans=0,x,y;
	w=rk[c];
	x=sum(1,n,rt[a-1],rt[b-len+1]);
	if(x>0)
	{
		y=kth(1,n,x,rt[a-1],rt[b-len+1]);
		if(w==y) return 1;
		ans=ST::query(y+1,w);
	}
	if(x<=b-len-a+1)
	{
		y=kth(1,n,x+1,rt[a-1],rt[b-len+1]);
		if(w==y) return 1;
		ans=max(ans,ST::query(w+1,y));
	}
	return ans>=len;
}
int main()
{
	scanf("%d%d%s",&n,&T,s+1);
	SA::main();
	ST::init(ht);
	for(int i=1;i<=n;i++)
	{
		w=rk[i];
		add(1,n,rt[i],rt[i-1]);
	}
	while(T--)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		l=1,r=min(b-a+1,d-c+1);
		while(l<r)
		{
			if(check(mid)) l=mid+1;
			else r=mid;
		}
		if(!check(l)) l--;
		printf("%d\n",l);
	}
}
```


---

## 作者：KokiNiwa (赞：2)

# [HEOI2016/TJOI2016] 字符串

[题目链接](https://www.luogu.com.cn/problem/P4094)

## 题目叙述

给你一个字符串$s$，每次给你一段区间$[a,b]$和$[c,d]$，求$s[a,b]$的子串和$[c,d]$这个字符串的最长公共前缀。

## 题解

首先二分答案$l$，那么问题转化为开头在$[a,b-l+1]$这个区间内的所有后缀和开头为$c$的后缀的最长公共前缀最大长度是否比$l$大。然后就变成一个点和几个点和几个其他点中深度最大的点的神都是否大于$l$。但显然这样做不出来。所以考虑转变，我们知道二分之后最终的那个公共前缀就变成了$[c,c+l-1]$这个字符串。所以就看这个字符串是否被$[a,b-l+1]$为开头的一个后缀包含就行了。就相当于，判断$[c,c+l-1]$这个字符串在后缀树上对应的那个节点的子树中是否有一个节点是一个开头在$[a,b-l+1]$的后缀的节点。

最后由衷地感谢一下@[EternalAlexander](https://www.luogu.com.cn/user/48355)这位巨佬。

## 代码
```cpp
#include <cstdio>
#include <iostream>

const int maxLen = 1e5 + 5, maxNode = maxLen << 1, inf = 1e8;
int len, queNum;
char str[maxLen];
struct SuffixTree {
	int curLen, tail, now, actLen;
	int curStr[maxLen], link[maxNode], start[maxNode], len[maxNode], ch[maxNode][27];
	SuffixTree () {
		now = tail = 1;
		curLen = actLen = 0;
		len[0] = inf;
	}
	int NewNode(int st, int le) {
		link[++tail] = 1;
		start[tail] = st;
		len[tail] = le;
		return tail;
	}
	void Extend(int ins) {
		curStr[++curLen] = ins;
		++actLen;
		for (int last = 1; actLen; ) {
			while (actLen > len[ch[now][curStr[curLen - actLen + 1]]])
				actLen -= len[now = ch[now][curStr[curLen - actLen + 1]]];
			int &son = ch[now][curStr[curLen - actLen + 1]], val = curStr[start[son] + actLen - 1];
			if (!son || val == ins) {
				link[last] = now;
				last = now;
				if (!son)
					son = NewNode(curLen - actLen + 1, inf);
				else
					break;
			} else {
				int split = NewNode(start[son], actLen - 1);
				ch[split][val] = son;
				ch[split][ins] = NewNode(curLen, inf);
				start[son] += actLen - 1;
				len[son] -= actLen - 1;
				link[last] = son = split;
				last = split;
			}
			if (now == 1)
				--actLen;
			else
				now = link[now];
		}
	}
} sft;
struct SegmentTree {
	int tail, ch[maxNode << 6][2];
	void Create(int &now) {
		ch[++tail][0] = ch[now][0], ch[tail][1] = ch[now][1], now = tail;
	}
	void Insert(int &now, int lEP, int rEP, int pos) {
		Create(now);
		if (lEP == rEP)
			return ;
		int mid = (lEP + rEP) >> 1;
		if (pos <= mid)
			Insert(ch[now][0], lEP, mid, pos);
		else
			Insert(ch[now][1], mid + 1, rEP, pos);
	}
	void Merge(int &uId, int vId) {
		if (!uId || !vId) {
			//因为这次合并并没有进行，所以不会损坏结构，就是 ch不会改变 
			uId |= vId;
			return ;
		}
		Create(uId);
		Merge(ch[uId][0], ch[vId][0]);
		Merge(ch[uId][1], ch[vId][1]);
	}
	int Query(int now, int lEP, int rEP, int askL, int askR) {
		if (!now)
			return 0;
		if (lEP > askR || rEP < askL)
			return 0;
		if (askL <= lEP && rEP <= askR)
			return 1;
		int mid = (lEP + rEP) >> 1;
		return Query(ch[now][0], lEP, mid, askL, askR) | Query(ch[now][1], mid + 1, rEP, askL, askR);
	}
} seg;
int depth[maxNode], depToNod[maxLen], rt[maxNode], fa[maxNode][20]; //这个存每个长度的后缀对应的点的编号 
void dfs(int now, int dep) {
	for (int up = 1; up <= 17; ++up)
		fa[now][up] = fa[fa[now][up - 1]][up - 1];
	dep += std::min(sft.len[now], len - sft.start[now] + 1);
	depth[now] = dep;
	bool isLeaf = 1;
	for (int sonId = 0; sonId <= 26; ++sonId)
		if (sft.ch[now][sonId]) {
			isLeaf = 0;
			fa[sft.ch[now][sonId]][0] = now;
			if (now == 1 && sonId == 26)
				continue ;
			dfs(sft.ch[now][sonId], dep);
			seg.Merge(rt[now], rt[sft.ch[now][sonId]]);
		}
	if (isLeaf) {
		seg.Insert(rt[now], 1, len, dep);
		depToNod[dep] = now;
	}
}
int locate(int lpos, int rpos) {
	int now = depToNod[len - lpos + 1];
	for (int up = 17; up >= 0; --up)
		if (fa[now][up] && depth[fa[now][up]] >= rpos - lpos + 1)
			now = fa[now][up];
	return now;
}
bool Check(int lcpLen, int begA, int endB, int begC, int endD) {
	//begC + lcpLen - 1是那个最长公共前缀 
	int pos = locate(begC, begC + lcpLen - 1);
	endB -= lcpLen - 1;
	//这里是 rt[pos]而不是 pos！ 
	if (seg.Query(rt[pos], 1, len, len - endB + 1, len - begA + 1))
		return endB += lcpLen - 1, 1;
	else
		return endB += lcpLen - 1, 0;
}

int main() {
	freopen("string.in", "r", stdin);
	scanf("%d%d", &len, &queNum);
	scanf("%s", str + 1);
	for (int pos = 1; pos <= len; ++pos)
		sft.Extend(str[pos] - 'a');
	sft.Extend(26);
	dfs(1, 0);
	while (queNum--) {
		int begA, endB, begC, endD;
		scanf("%d%d%d%d", &begA, &endB, &begC, &endD);
		int lEP = 0, rEP = std::min(endD - begC + 1, endB - begA + 1);
		while (rEP > lEP) {
			int mid = (lEP + rEP + 1) >> 1;
			if (Check(mid, begA, endB, begC, endD))
				lEP = mid;
			else
				rEP = mid - 1;
		}
		printf("%d\n", lEP);
	}
	return 0;
}
```

## 知识点

+ 不能直接搞的最大值问题想一下二分。
+ 如果要把问题转化成后缀树上的问题，要充分利用已知条件，做不出来了要换一个转化方法。


---

## 作者：CrTsIr400 (赞：1)

[P4094 [HEOI2016/TJOI2016] 字符串](https://www.luogu.com.cn/problem/P4094)

后缀自动机典题。首先二分一下 LCP 长度，问题就变成了求 $s[a\dots b]$ 中有没有和 $s[l\dots r]$ 相等的子串。

这个时候利用 parent tree 的性质，直接定位到 `endpos` 只有 $r$ 的那个点（显然可以 $O(1)$ 查询）。

然后往上跳到保证 $len\ge mid$ 的最后一个祖先，此时其 `endpos` 集合就是整个串可能包含 $s[l\dots r]$ 的位置集合。

此时我们把询问 $s[a\dots b]$ 变为区间 $[a+mid-1,b]$ 挂到这个节点上。`endpos` 集合可以先转 dfn 序，然后主席树维护一下，就变成了区间查询。时间复杂度 $O(n\log n+m\log^2 n)$。

实现上：

+ 建出原串的 SAM；
+ 扣出 parent tree，叶子节点上挂一个 `endpos`，得到每个点所能覆盖的 `endpos` 的 `dfn` 序区间；
+ 顺便维护一下 $f[p][k]$ 表示 $p$ 的 $k$ 级祖先；
+ 建立主席树；
+ 二分 `mid` 求判定：
  + $O(1)$ 找到 $s[1\dots c+mid-1]$ 这个前缀的位置；
  + $O(\log n)$ 跳祖先；
  + $O(\log n)$ 查询这个祖先所属区间内有没有 $[a+mid-1,b]$ 区间内的数。

于是这题就结束了。

但是直接递归主席树会被卡出翔，所以我们化为循环二分的形式，因为循环始终是要比递归快的。

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for(I i(a),_ed(b);i<=_ed;++i)
char buf[1<<23],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p1=buf,p2=p1+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
#define gch(k) for(;(k);CH=getchar())
using namespace std;using I=int;using LL=long long;using V=void;I CH;
I in(){I a=0;gch(!isdigit(CH));gch(isdigit(CH))a=a*10+CH-'0';return a;}
I n,m;char c;
const I N=2e5+10,inf=1e9+7; 
namespace pt{
	const I S=N*10;
	I ls[S],rs[S],s[S],cnt;
	#define mid ((l+r)>>1)
	V ins(I&p,I q,I x,I l=1,I r=n){
		p=++cnt;s[p]=s[q]+1;
		if(l==r)return;
		if(x<=mid)ins(ls[p],ls[q],x,l,mid),rs[p]=rs[q];
		else ins(rs[p],rs[q],x,mid+1,r),ls[p]=ls[q];}
	I L,R;
	I qry(I pp,I qq){I l=1,r=n,ans=0,p=pp,q=qq;
		while(l<r){
			if(mid<=R)ans+=s[ls[p]]-s[ls[q]],l=mid+1,p=rs[p],q=rs[q];
			else r=mid,p=ls[p],q=ls[q];}
		if(l<=R)ans+=s[p]-s[q];
		l=1;r=n;p=pp;q=qq;
		while(l<r){
			if(mid<L)ans-=s[ls[p]]-s[ls[q]],l=mid+1,p=rs[p],q=rs[q];
			else r=mid,p=ls[p],q=ls[q];}
		if(l<L)ans-=s[p]-s[q];
		return ans;}
}
I las=1,cnt=1,tr[N][26],fa[N],s[N],len[N],dw[N];
V ins(I c,I id){I p=las;
	s[las=++cnt]=id;dw[id]=cnt;
	len[cnt]=len[p]+1;
	for(;p&&!tr[p][c];p=fa[p])tr[p][c]=cnt;
	if(!p)return fa[las]=1,V();
	I q=tr[p][c];
	if(len[q]==len[p]+1)return fa[las]=q,V();
	++cnt;copy(tr[q],tr[q]+26,tr[cnt]);
	fa[cnt]=fa[q];fa[q]=fa[las]=cnt;
	len[cnt]=len[p]+1;
	for(;tr[p][c]==q;p=fa[p])tr[p][c]=cnt;}
I f[N][19],clk,seq[N],dst[N],ded[N],rt[N],hd[N],ey[N],ec,nx[N];
V conn(I x,I y){ey[++ec]=y;nx[ec]=hd[x];hd[x]=ec;}
V dfs(I x){dst[x]=inf;ded[x]=-inf;
	if(s[x])seq[++clk]=s[x],dst[x]=ded[x]=clk;
	fo(i,1,18)f[x][i]=f[f[x][i-1]][i-1];
	for(I i=hd[x],y;y=ey[i],i;i=nx[i])
		f[y][0]=x,dfs(y),
		dst[x]=min(dst[x],dst[y]),
		ded[x]=max(ded[x],ded[y]);}
V bld(){
	fo(i,2,cnt)conn(fa[i],i);
	dfs(1);
	fo(i,1,clk)pt::ins(rt[i],rt[i-1],seq[i]);
}
bool pd(I c,I d){I p=dw[d];
	for(I i=18;~i;--i)if(len[f[p][i]]>=d-c+1)p=f[p][i];
	return pt::qry(rt[ded[p]],rt[dst[p]-1])>0;
}
I main(){
	n=in();m=in();
	fo(i,1,n){
		while(!isalpha(CH))CH=getchar();
		c=CH;CH=getchar();
		ins(c-'a',i);}
	bld();
	fo(i,1,m){I a=in(),b=in(),c=in(),d=in();
		I l=1,r=d-c+1,ans=0;
		pt::R=b;
		while(l<=r){pt::L=a+mid-1;
			if(pd(c,c+mid-1))ans=mid,l=mid+1;
			else r=mid-1;}
		printf("%d\n",ans);}
	return 0;}
```

---

upd：还有一种基于线段树合并维护 endpos 等价类的做法，它的常数小很多，直接合并复杂度是（均摊？） $O(\log n)$ 的且卡不满。

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for(I i(a),_ed(b);i<=_ed;++i)
char buf[1<<23],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p1=buf,p2=p1+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
#define gch(k) for(;(k);CH=getchar())
using namespace std;using I=int;using LL=long long;using V=void;I CH;
I in(){I a=0;gch(!isdigit(CH));gch(isdigit(CH))a=a*10+CH-'0';return a;}
I n,m;char c;
const I N=2e5+10,inf=1e9+7; 
namespace pt{
const I SZ=N*20;
I ls[SZ],rs[SZ],s[SZ],cnt,L,R;
#define mid ((l+r)>>1)
V ins(I&p,I x,I l=1,I r=n){p=++cnt;++s[p];
	if(l==r)return;
	if(x<=mid)ins(ls[p],x,l,mid);
	else ins(rs[p],x,mid+1,r);}
I mrg(I p,I q,I l=1,I r=n){
	if(!p||!q)return p|q;
	I x=++cnt;s[x]=s[p]+s[q];
	if(l==r)return x;
	ls[x]=mrg(ls[p],ls[q],l,mid);
	rs[x]=mrg(rs[p],rs[q],mid+1,r);
	return x;}
I qry(I p,I l=1,I r=n){if(!p)return 0; 
	if(L<=l&&r<=R)return s[p];
	if(r<L||l>R)return 0;
	return qry(ls[p],l,mid)+qry(rs[p],mid+1,r);}
}I las=1,cnt=1,tr[N][26],fa[N],s[N],len[N],dw[N];
V ins(I c,I id){I p=las;
	s[las=++cnt]=id;dw[id]=cnt;
	len[cnt]=len[p]+1;
	for(;p&&!tr[p][c];p=fa[p])tr[p][c]=cnt;
	if(!p)return fa[las]=1,V();
	I q=tr[p][c];
	if(len[q]==len[p]+1)return fa[las]=q,V();
	++cnt;copy(tr[q],tr[q]+26,tr[cnt]);
	fa[cnt]=fa[q];fa[q]=fa[las]=cnt;
	len[cnt]=len[p]+1;
	for(;tr[p][c]==q;p=fa[p])tr[p][c]=cnt;}
I f[N][19],clk,rt[N],hd[N],ey[N],ec,nx[N];
V conn(I x,I y){ey[++ec]=y;nx[ec]=hd[x];hd[x]=ec;}
V dfs(I x){
	if(s[x])pt::ins(rt[x],s[x]);
	fo(i,1,18)f[x][i]=f[f[x][i-1]][i-1];
	for(I i=hd[x],y;y=ey[i],i;i=nx[i])
		f[y][0]=x,dfs(y),rt[x]=pt::mrg(rt[x],rt[y]);
}V bld(){
	fo(i,2,cnt)conn(fa[i],i);
	dfs(1);
}bool pd(I c,I d){I p=dw[d];
	for(I i=18;~i;--i)if(len[f[p][i]]>=d-c+1)p=f[p][i];
	return pt::qry(rt[p])>0;
}I main(){
	n=in();m=in();
	fo(i,1,n){
		while(!isalpha(CH))CH=getchar();
		c=CH;CH=getchar();
		ins(c-'a',i);}
	bld();
	fo(i,1,m){I a=in(),b=in(),c=in(),d=in();
		I l=1,r=d-c+1,ans=0;
		pt::R=b;
		while(l<=r){pt::L=a+mid-1;
			if(pd(c,c+mid-1))ans=mid,l=mid+1;
			else r=mid-1;}
		printf("%d\n",ans);}
	return 0;}
```



---


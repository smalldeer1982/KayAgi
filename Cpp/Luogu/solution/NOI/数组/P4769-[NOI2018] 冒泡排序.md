# [NOI2018] 冒泡排序

## 题目背景

请注意，题目中存在 $n=0$ 的数据。

## 题目描述

最近，小 S 对冒泡排序产生了浓厚的兴趣。为了问题简单，小 S 只研究对 **$1$ 到 $n$ 的排列**的冒泡排序。

下面是对冒泡排序的算法描述。

```plain
输入：一个长度为 n 的排列 p[1...n]
输出：p 排序后的结果。
for i = 1 to n do
	for j = 1 to n - 1 do
		if(p[j] > p[j + 1])
			交换 p[j] 与 p[j + 1] 的值
```

冒泡排序的交换次数被定义为交换过程的执行次数。可以证明交换次数的一个下界是 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$，其中 $p_i$ 是排列 $p$ 中第 $i$ 个位置的数字。如果你对证明感兴趣，可以看提示。

小 S 开始专注于研究长度为 $n$ 的排列中，满足交换次数 $= \frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 的排列（在后文中，为了方便，我们把所有这样的排列叫「好」的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？

小 S 想要对于一个给定的长度为 $n$ 的排列 $q$，计算字典序严格大于 $q$ 的“好”的排列个数。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 3

见附加文件中的 `inverse3.in` 与 `inverse3.ans`。

### 样例 1 解释

字典序比 $1 \ 3 \ 2$ 大的排列中，除了 $3 \ 2 \ 1$ 以外都是「好」的排列，故答案为 $3$。

### 数据范围

下面是对本题每个测试点的输入规模的说明。

对于所有数据，均满足 $T = 5$（样例可能不满足）。

记 $n_\mathrm{max}$ 表示每组数据中 $n$ 的最大值，$\sum n$ 表示所有数据的 $n$ 的和。

::cute-table{tuack}

| 测试点 | $n_\mathrm{max} =$ | $\sum n \leq$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1$ | $8$ | $5 \ n_\mathrm{max}$ | 无 |
| $2$ | $9$ | ^ | ^ |
| $3$ | $10$ | ^ | ^ |
| $4$ | $12$ | ^ | ^ |
| $5$ | $13$ | ^ | ^ |
| $6$ | $14$ | ^ | ^ |
| $7$ | $16$ | ^ | ^ |
| $8$ | $16$ | ^ | ^ |
| $9$ | $17$ | ^ | ^ |
| $10$ | $18$ | ^ | ^ |
| $11$ | $18$ | ^ | ^ |
| $12$ | $122$ | $700$ | $\forall i \enspace q_i = i$ |
| $13$ | $144$ | ^ | 无 |
| $14$ | $166$ | ^ | ^ |
| $15$ | $200$ | ^ | ^ |
| $16$ | $233$ | ^ | ^ |
| $17$ | $777$ | $4000$ | $\forall i \enspace q_i = i$ |
| $18$ | $888$ | ^ | 无 |
| $19$ | $933$ | ^ | ^ |
| $20$ | $1000$ | ^ | ^ |
| $21$ | $266666$ | $2000000$ | $\forall i \enspace q_i = i$ |
| $22$ | $333333$ | ^ | 无 |
| $23$ | $444444$ | ^ | ^ |
| $24$ | $555555$ | ^ | ^ |
| $25$ | $600000$ | ^ | ^ |

### 提示

下面是对交换次数下界是 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 的证明。

排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 pi，那么我们需要将这个数字移动到第 $p_i$ 个位置上，移动的距离是 $\lvert i - p_i \rvert$。从而移动的总距离就是 $\sum_{i=1}^n \lvert i - p_i \rvert$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离至多减少 $2$。因此 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 是冒泡排序的交换次数的下界。

并不是所有的排列都达到了下界，比如在 $n = 3$ 的时候，考虑排列 $3 \ 2 \ 1$，这个排列进行冒泡排序以后的交换次数是 $3$，但是 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 只有 $2$。

## 样例 #1

### 输入

```
1
3
1 3 2```

### 输出

```
3```

## 样例 #2

### 输入

```
1
4
1 4 2 3```

### 输出

```
9```

# 题解

## 作者：LittleDino (赞：111)

感谢给我讲了这个题的神仙跳瓜 $\textrm{jumpmelon}$。
 
首先看给的提示，我们可以发现在这样的排序方式下，对于每一个数都只向目标位置方向走，不换向。那么对于一个数 $x$，如果有一个比它大的数在它前面，那么它必须向左走；如果有一个比它小的数在它后面，那么它必须向右走。这样的排列是不合法的，即要求不存在长度超过 $2$ 的下降子序列。

根据 $\textrm{Dilworth}$ 定理，最长下降子序列的长度不超过 $2$，即整个排列最多被划分成 $2$ 个上升子序列。

先不考虑字典序严格大于 $q$ 的限制。

我们记 $f_{i, j}$ 为前 $i$ 个的最大值为 $j$ 后面 $n - i$ 个位置的方案数。我们考虑第 $i$ 个数填什么。注意 $i \leqslant j$

如果填比 $j$ 大的数，那么一定可以接在 $j$ 的后面；如果要填比 $j$ 小的数，那么必须填当前还没有填的中最小的，否则上升子序列将不止 $2$ 个，所以

$$ 
\begin{aligned}
f_{i, j} &= 
\begin{cases}
f_{i + 1, k} \ \ \ \ \ (k > j) \\
f_{i + 1, j} \ \ \ \ \ 
\end{cases}
\\
&= \sum_{k = j}^n f_{i + 1, k}
\end{aligned}
$$


但是直接这样递推是 $O(n^2)$ 的。我们把它以图像的形式表示，$f_{i, j}$ 即表示从点 $(i, j)$ 开始，每次向右走一步，向上走 $x(x \leqslant 0)$ 步，不与直线 $y = x - 1$ （因为 $i \leqslant j$） 相交，走到点 $(n, n)$ 的方案数。

![](https://i.loli.net/2019/06/03/5cf51e86409b878351.png)

如图，即从点 $A(i, j)$ 走到 $B(n, n)$ 的不与直线 $y = x - 1$ 相交的方案数。

首先，如果不考虑与直线不相交，即为走 $n - i$ 次，每次选择向上走 $x (x \geqslant 0)$ 步，一共走了 $n - j$ 步的方案数。模仿插板法，因为 $x$ 可以取 $0$，我们把总个数加上划分数 $n - i$，变成 $n - i + n - j$ 个物品划分成 $n - i$ 块的方案数，即 $\dbinom{2n - i - j - 1}{n-i-1}$。

再模仿 $\textrm{Catalan}$ 数的推法，看第一个与直线 $y = x - 1$ 相交的位置。找点 $(i, j)$ 关于直线 $y = x - 1$ 的对称点 $(j + 1, i - 1)$, 由于方案一一对应，所以，从点 $(i, j)$ 出发，经过直线的方案数即为从点 $(j + 1, i - 1)$ 出发到点 $(n, n)$ 的方案数。

得到 

$$ 
\begin{aligned}
f_{i, j} 
&= calc(i, j) - calc(j + 1, i - 1) \\
&= \dbinom{2n - i - j - 1}{n - i - 1} - \dbinom{2n - i - j - 1}{n - j - 2} \\
\end{aligned}
$$

这样就得到 $f$ 的 $O(1)$ 求解啦！（然而 $O(n^2)$ 有足足 $80$ 分，真香)

可以发现 $f_{0, 0}$ 即为 $\textrm{Catalan}$ 数，可以得到 $12$ 分。

回到有限制字典序严格大于 $q$ 的原题上来。考虑一位一位枚举，假设当前枚举到第 $i$ 项，我们计数证前 $i - 1$ 项与 $q$ 相同，第 $i$ 项大于 $q_i$ 的排列个数。

记 $mx = \max_{j = 1}^{i - 1} q_j$，$mn$ 为当前还没有用过的最小的数，$v = q_i$。第 $i$ 位只能填 $mn$ 或大于 $mx$ 的数。分类讨论

* $v = mn$ 
  
  （因为 $mn$ 是最小可以填的，所以 $v$ 的下界是 $mn$。）
  
  此时，第 $i$ 项不能填 $mn$，只能大于 $mx$，故后面 $n - i$ 项的填法有 $\sum_{k = mx + 1}^n f_{i, k}$ 种（$k$ 为第 $i$ 位填的数）。

* $mn < v < mx$ 
  
  此时第 $i$ 位没有可以填的，后面不再存在合法方案。（但是还是要读完）

* $v \geqslant mx$
  
  此时第 $i$ 位可以填 $mn$ 或大于 $mx$ 的数，方案数为 $\sum_{k = mx}^n f_{i, k}$。

问题又来了，怎么求 $f$ 的前缀和呢？考虑 $f$ 的递推式 $f_{i, j} = \sum_{k = j}^n f_{i + 1, k}$，这正是一个前缀和的形式。所以

$$ \sum_{k = lim}^n f_{i, k} =  f_{i - 1, lim} $$

不用像其他题解上说的要用树状数组，复杂度 $O(Tn)$（还好写)

完结撒花~

# 代码

注意数组要开 $2n$，写起来很简单，但是最开始由于没彻底搞懂想了半天

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace TYC
{
    typedef long long ll;
    const int N = 1.2e6, p = 998244353;

    int fac[N + 5], inv[N + 5], vis[N + 5];

    inline int read()
    {
        int v = 0, fl = 0, ch = getchar();
        while (!isdigit(ch))
            fl |= (ch == '-'), ch = getchar();
        while (isdigit(ch))
            v = v * 10 + ch - '0', ch = getchar();
        return fl ? -v : v;
    }

    inline int qpow(int v, int tim)
    {
        int ans = 1;
        for (; tim; tim >>= 1, v = (ll)v * v % p)
            if (tim & 1)
                ans = (ll)ans * v % p;
        return ans;
    }

    void init()
    {
        fac[0] = 1;
        for (int i = 1; i <= N; i++)
            fac[i] = (ll)fac[i - 1] * i % p;
        inv[N] = qpow(fac[N], p - 2);
        for (int i = N; i; i--)
            inv[i - 1] = (ll)inv[i] * i % p;
    }

    inline int C(const int n, const int m)
    {
        return (n < 0 || m < 0 || n < m) ? 0 : int((ll)fac[n] * inv[m] % p * inv[n - m] % p);
    }

    int n;
    inline int F(const int i, const int j)
    {
        return i <= j && j <= n ? (C(2 * n - i - j - 1, n - i - 1) - C(2 * n - i - j - 1, n - j - 2) + p) % p : 0;
    }

    void work()
    {
        init();
        int T = read();
        while (T--)
        {
            n = read();
            memset(vis, 0, sizeof(int[n + 1]));
            int ans = 0, mx = 0, mn = 1, flag = 0, v;
            for (int i = 1; i <= n; i++)
            {
                v = read();
                if (flag)
                    continue;
                ans = (ans + (F(i - 1, max(mx, v) + 1) + p) % p) % p;
                if (mx > v && v > mn)
                    flag = 1;
                mx = max(mx, v);
                vis[v] = 1;
                while (vis[mn]) mn++;
            }
            printf("%d\n", ans);
        }
    }
}

int main()
{
    TYC::work();
    return 0;
}
```

P.S.  
upd 2023.8.5 我已经退役很多年了，一次碰巧上洛谷看到有同学提醒组合数写反了，现特为纠正，希望同学们都能看明白。

---

## 作者：liuzhangfeiabc (赞：58)

~~一道绝好的打表找规律题。~~

题目可以转化为：要求排列中不存在长度>=3的下降子序列。

因为如果出现的话，那么这个下降子序列中间的元素需要先与左边比它大的元素交换再与右边比它小的元素交换，需要折返一下，显然就不合法了。

这又等价于可以将序列划分为2个上升子序列。

首先我们先不看那个字典序的性质，~~相信大家打一下表就能~~发现答案是卡特兰数。

然后我们再想想它的本质是什么：

假设前i个位置中，最大的数是j，那么我们会发现，>j的数目前是可以随便填的，然而<j的数只能限制从小到大按顺序填入（因为这些元素一定被归入同一个上升子序列）。

于是我们就可以设f(i,j)表示还剩余i个数没填，其中后j个是大于当前最大值的“非限制元素”的答案。

转移就是枚举下一个位置填一个限制元素或某一个非限制元素。

如果填限制元素，非限制元素的数量不变；否则假设填入第k个非限制元素，非限制元素的数量就会减少k个（这是因为最大值发生了变化，使得前面k-1个非限制元素变成了限制元素）。

f(i,j) = sigma k=0~j f(i-1,j-k)

边界是f(0,0) = 1

这其实就是个前缀和：

f(i,j) = f(i,j-1) + f(i-1,j)

~~擅长打表~~熟悉组合数的人会很快发现，这东西就是两个组合数相减：

f(i,j) = c(i+j-1,j) - c(i+j-1,j-2)

它的正确性容易验证：

f(i,j-1) + f(i-1,j) = c(i+j-2,j-1) + c(i+j-2,j) - c(i+j-2,j-3) - c(i+j-2,j-2) = c(i+j-1,j) - c(i+j-1,j-2) = f(i,j)

特别地，f(i,0) = 1,f(i,1) = i

这也解释了为什么没有限制时答案是卡特兰数：只需注意到此时的所求是f(n,n)

f(n,n) = c(2×n-1,n) - c(2×n-1,n-2) = C(n)

我们再考虑限制，假设当前做到第i位，给定的排列中这一位是ai，后面有bi个数比它大，前面有ci个数比它小（这两个数组可以用树状数组方便地计算出来）并且现在的“非限制元素”还有nw个。

我们先计算填入的数字pi>ai的情况，然后再令pi=ai继续计算下一位。

首先nw可以与bi取个min，因为填完这一位后非限制元素一定不超过bi个。

然后此时如果nw=0（最大的数被填进去了）,则意味着我们后面将别无选择地只能按顺序填入，而这个排列的字典序是严格不大于给定排列的，因此就可以退出了。

否则，我们相当于要求sigma j=0~nw-1 f(n-i,j),根据前缀和它等于f(n-i+1,nw-1),可以O（1）计算。

然后，我们考虑填入pi=ai是否合法：

如果刚刚bi更新了nw，说明ai本身就是一个“非限制元素”，当然合法；

否则，如果ai是当前未填入的元素中最小的（对应ci==ai-1）,相当于填了一个最小的“限制元素”，也是合法的；

否则，就是乱序填入“限制元素”，不合法，就可以退出了。

总复杂度O(n log n),瓶颈其实在于树状数组求bi和ci的部分。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[600010];
#define li long long
#define gc getchar()
#define pc putchar
int read(){
	int x = 0,c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = gc;
	}
	return x;
}
void print(int x){
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
int tt[1200010];
void xg(int q){
	for(int i = q;i <= n;i += i & (-i)) ++tt[i];
}
int cx(int q){
	int as = 0;
	for(int i = q;i;i -= i & (-i)) as += tt[i];
	return as;
}
int b[600010],c[600010];
li jc[1200010],nj[1200010];
const int mo = 998244353;
li ksm(li q,li w){
	li as = 1;
	while(w){
		if(w & 1) as = as * q % mo;
		q = q * q % mo;
		w >>= 1;
	}
	return as;
}
int mx1 = 1200005;
inline li zh(li q,li w){
	return jc[q] * nj[w] % mo * nj[q - w] % mo;
}
inline li wk(li q,li w){
	if(w == 0) return 1;
	if(w == 1) return q;
	return (zh(q + w - 1,w) - zh(q + w - 1,w - 2) + mo) % mo;
}
int main(){
	int i,j;
	jc[0] = 1;
	for(i = 1;i <= mx1;++i) jc[i] = jc[i - 1] * i % mo;
	nj[mx1] = ksm(jc[mx1],mo - 2);
	for(i = mx1 - 1;i >= 0;--i) nj[i] = nj[i + 1] * (i + 1) % mo;
	t = read();
	while(t--){
		n = read();
		for(i = 1;i <= n;++i) a[i] = read(),tt[i] = 0;
		for(i = n;i;--i){
			b[i] = n - i - cx(a[i]);
			xg(a[i]);
			c[i] = i - 1 - (n - a[i] - b[i]);
			
		}
		li as = 0;int nw = n; 
		for(i = 1;i <= n;++i){
			bool fg = b[i] < nw;
			nw = min(nw,b[i]);
			if(nw <= 0) break;
			(as += wk(n - i + 1,nw - 1)) %= mo;
			if(!fg && c[i] != a[i] - 1) break;
		} 
		print(as);pc('\n');
	} 
	return 0;
}
```

---

## 作者：shadowice1984 (赞：35)

让我们来尝试理性理解一下这道题

其实这道题的难点就是两个神仙的转化,理解这两个转化之后做这道题就不难了

______________

### 前置芝士:一颗冷静的头脑和一张草稿纸

计数题的代码不一定长但是思维难度一定不小，建议不懂的地方画图理解

### 前置芝士:树状数组

~~那个，做noi题真的不会树状数组吗？~~

___________________

## 本题题解

首先我们先来证明一个结论，题目中实际上是要求我们求出符合下列条件的排列个数

**1.这个排列的字典序严格大于输入的排列**

**2.这个排列不含有长度超过3的下降子序列**

那么条件1十分好说，就是题目要求

问题来了条件2呢？我们需要证明两件事情:

第一就是如果这个排列含有长度超过3的下降子序列那么这个排列一定非法

第二就是如果这个排列不含有长度超过3的下降子序列那么这个排列一定合法

#### 先来尝试着证明第一点:

根据题目中给出证明我们可以知道，一个排列是合法的当且仅当我们在交换两个位置$(i,i+1)$的时候满足$a(i)>i,a(i+1)<i+1$，换句话说我们不会做出把这个数字向与最后位置相反的方向移动的行为


假设这里有3个元素从左到右值分别为$a,b,c$并且$a>b>c$

那么在最后排好序的排列当中这三个元素的位置必须是$c,b,a$

那么我们知道冒泡排序只能交换相邻的两个元素，那么必然存在一个时刻这个三个元素长这样$b,a,c$或者是$a,c,b$

问题来了我们迟早要把三个元素变成$c,b,a$的，这就意味着b这个元素向两个不同的方向移动了，无论b的初始位置在哪里也无论b的目标位置在哪里b元素总是会浪费几步，因此这个排列就非法了

### 接着证明第二点:

可以观察出一个事实就是如果这个排列不含有长度超过3的下降子序列那么这个排列一定可以被拆分成两个或者一个上升的子序列，构造方法如下:

对于每一个位置i，**如果这个数字是$(1,i)$的前缀最大值**，就将这个数字丢到第一个子序列当中,否则将这个数字丢到第二个子序列当中

显然第一个子序列肯定是单调的，现在我们需要证明为什么第二个子序列单调

采用反证法，如果第二个子序列不单调那么存在一对位置$(i,j)$满足i在j的前面但是i却比j大。

那么我们知道$i$肯定是小于$(1,i)$的前缀最大值的，因此$(1,i)$的前缀最大值,$i$,$j$构成了一个长度为3的下降子序列，与假设不符，所以第二个子序列也是单调的

接下来我们证明为什么我们的排列不含有长度超过3的下降子序列这个排列一定合法

首先我们知道冒泡排序只交换相邻的逆序元素，那么我们可以轻松的得到一个事实是这个排列在冒泡排序的任意时刻都不含有长度超过3的下降子序列

接下来我们证明两件事情，如果$i$属于第一个子序列那么$i \leq a(i)$

这其实十分的显然因为$a(i)$是前缀最大值

另一件事情不怎么平凡，如果$i$属于第二个子序列那么$a(i) < i$

证明其实也比较简单考虑$(1,i)$的权值的分布，比如说可能长这样


![](https://cdn.luogu.com.cn/upload/pic/47298.png)

其中红色点表示这个值属于第一个子序列而蓝色点表示这个点属于第二个子序列，白色点表示这个权值不在$(1,i)$这个权值当中出现

然而打叉的那种权值分布是不可能出现的，因为蓝色点的位置是单调的红色点的位置是单调的，一共只有n种权值，如果蓝色点之间有白色点，那么后面将没有权值可以填上白色的空隙，

所以我们可以知道:如果i是第二个子序列的数字，那么$a(i)<i$

因为既然出现了第二个子序列,那么$(1,i)$当中一定有红色点在最大的蓝色点前面

那么接下来的事情就十分简单了，我们冒泡排序的时候交换的元素$(i,i+1)$属于两个不同的子序列并且$i$属于第一个而$i+1$属于第二个子序列，根据刚才证明的两个结论我们可以推出交换的每一步都是合法的

好了千辛万苦我们终于证明了这个结论是对的

接下来我们把精力集中在第一个限制上，也就是字典序严格大于$p$这个条件上，显然我们需要枚举目标排列和p的lcp长度

假如我们钦定了lcp长度恰好为$i$那么我们发现$a(i+1)>p(i+1)$并且$p$的前i位是合法的，并且我们还需要满足一件事情是$(i+1,n)$当中所有比$(1,i)$中最大值小的数字必须有序，否则不行

那么我们不妨设计一个$dp(n,k)$表示长度为$n$以$k$开头的合法排列数量

我们会有一个神奇的转移方程

$$dp(n,k)=\sum_{i=\max(1,k-1)}^{n-1}dp(n-1,i)$$

哇这个转移方程真的肥肠神仙啊

让我们来尝试理解它

#### case1:排列以1开头

如果这个排列以1开头那么1不可能出现在下降子序列当中，所以后面随便什么开头都行

#### case2:排列以k开头

此时如果我们发现下一位比k小的话,$(k,\text{下一位},1)$会构成一个长度为3的下降子序列此时我们gg了

如果更加不巧，我们下一位填了1,那么其实等价于这样一个要求:对于剩下的元素如果这些元素比k小，那么这些元素之间必须有序

似乎这个限制也在枚举字典序的要求当中出现了啊，让我们康康有没有什么办法可以处理它

然后我们仔细观察一下发现还真的有……

那就是符合上面要求的排列个数恰好等于$dp(n-1,k-1)$

证明是这样的，我们要求$(1,k-1)$这些元素有序的要求相当于不存在一对$(i,j),i<j$使得$j$排在$i$的前面

那么我们令$(1,k-1)$当中值为i的元素挪到值为i+1的元素上，k-1挪到1的位置上，我们发现如果刚才非法的$(i,j)$对中不含1那么做这样的变换之后$(k-1,i-1,j-1)$构成了一个长度为3的下降子序列

如果刚才的非法的$(i,j)$对中含1,这显然是不可能的因为原序列当中1排在序列的开头

所以我们转移的方程就真了

好了那么我们处理字典序限制时候也可以如法炮制

事实上我们的答案就是这些数字加起来

对于输入的排列当中的每一个位置$i$假设在$(i,n)$当中有$k$个数字比$(1,i)$的前缀最大值小,那么答案加等于

$$\sum_{t=k+1}^{n-i+1}dp(n-i+1,t)$$

证明方式也是类似的，如果$P(i)$就是前缀最大值那么为了满足字典序限制，我们需要满足这一位排列的开头在离散化之后比$P(i)$大

如果$P(i)$不是前缀最大值那么根据刚才的结论我们会发现开头必须必前缀最大值大否则(前缀最大值,当前位,后缀最小值)构成一个长度为3的下降子序列

然后我们仔细想想会发现这一位是不能填后缀最小值的，因为后缀最小值是小于等于$P(i)$的,填了我们就不满足字典序限制了

### 求出dp数组的后缀和

好了现在我们来解决最后一个问题，$O(1)$的求出这个式子

$$\sum_{t=k+1}^{n-i+1}dp(n-i+1,t)$$

哇，好棒哎，我们现在只能$O(N^2)$的刷出dp数组的每一个值您现在让我$O(1)$求出后缀和？

没关系啊我们使用最常见的套路求什么设什么为了方便起见我们令$dp(n,0)=0$这样可以规避掉诡异的下界问题

$$s(n,m)=\sum_{i=m}^{n}dp(n,i)$$

$$dp(n,i)=\sum_{k=i-1}^{n-1}dp(n-1,k)$$

$$s(n,m)=\sum_{i=m}^{n}\sum_{k=i-1}^{n-1}dp(n-1,k)$$

接下来该会会我们的老朋友交换求和号了

$$s(n,m)=\sum_{k=m-1}^{n-1}dp(n-1,k)\sum_{i=m}^{k+1}1$$

让我们稍微倒腾一下求和上下界

$$s(n,m)=\sum_{k=m-1}^{n-1}dp(n-1,k)+\sum_{k=m}^{n-1}dp(n-1,k)\sum_{i=m+1}^{k+1}1$$

$$s(n,m)=s(n-1,m-1)+\sum_{i=m+1}^{n}\sum_{k=i-1}^{n-1}dp(n-1,k)$$

$$s(n,m)=s(n-1,m-1)+s(n-1,m+1)$$

~~不要觉得上面的推倒很简单，请自己交换几次求和号康康自己能不能不把求和上下界搞对~~

哇，我们搞出了一个关于后缀和的递推式！

边界条件$s(0,0)=1$

那么我们发现其实s数组是有实际意义的

也就是从$(0,0)$到$(n,m)$每次可以向上走一步或者向右再向下走一步，中间不能经过x轴之下的方案数

那么我们发现单独向上走一步实在是不优美……

不如这样，我们每次向上走一步的时候接着向右走一步，这样$s(n,m)$就是从$(0,0)$走到$(2n-m,m)$的方案数

那么我们需要从$2n-m$步当中选出n-m步来走，这一步的方案数就是

$${2n-m\choose n-m}$$

对于一个不合法的方案也就是触碰了y=-1的方案，我们将第一次触碰y=-1之前的操作全部取反，向上走改成向下走，我们向下走的总步数变为n-m-1,这部分的方案数为

$${2n-m \choose n-m-1}$$

这样我们得到了

$$s(n,m)={2n-m \choose n-m}-{2n-m \choose n-m-1}$$

然后就可以$O(1)$计算辣~

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=6*1e5+10;typedef long long ll;const ll mod=998244353;
ll fac[N<<1];ll ifac[N<<1];int n;int T;int a[N];int mi[N];
inline ll c(int n,int m){return (m>=0)?(fac[n]*ifac[m]%mod*ifac[n-m]%mod):0;}
inline ll s(ll n,ll m){if(m>n)return 0;return (c((n<<1)-m,n-m)+mod-c((n<<1)-m,n-m-1))%mod;}
struct treearray
{
    int ta[N];
    inline void c(int x,int t){for(;x<=n;x+=x&(-x))ta[x]+=t;}
    inline int q(int x){int r=0;for(;x;x-=x&(-x))r+=ta[x];return r;}
    inline void clr(){for(int i=1;i<=n;i++)ta[i]=0;}
}ta;
inline void solve()//直接按照推出的式子模拟即可 
{
    scanf("%d",&n); 
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=n;i>=1;i--)ta.c(a[i],1);
    mi[n]=a[n];for(int i=n-1;i>=1;i--)mi[i]=min(mi[i+1],a[i]);
    int mx=0;int cmx=0;ll ans=0;
    for(int i=1;i<=n;i++)//注意判断前缀是否是合法的 
    {
        if(cmx>mi[i])break;(ans+=s(n-i+1,ta.q(max(mx,a[i]))+1))%=mod;
        if(a[i]<mx)cmx=max(cmx,a[i]);mx=max(mx,a[i]);ta.c(a[i],-1);
    }printf("%lld\n",ans);
}
inline void clr(){ta.clr();}
int main()
{
    fac[0]=1;for(int i=1;i<=(N<<1)-10;i++)fac[i]=fac[i-1]*i%mod;
    ifac[0]=1;ifac[1]=1;for(int i=2;i<=(N<<1)-10;i++)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;
    for(int i=1;i<=(N<<1)-10;i++)(ifac[i]*=ifac[i-1])%=mod;
    scanf("%d",&T);for(int z=1;z<=T;z++)solve(),clr();return 0;//拜拜程序~ 
}
    
```















---

## 作者：LPA20020220 (赞：31)

提供一个复杂度为$O(N)$的题解。

证明已经基本上告诉我们了， 如果可以达到下界， 那么最长下降子序列的长度不能超过$2$， 否则由于要交换最小最大的两个元素中间的那个元素会多交换， 无法达到最优。

那么设$dp[i][j]$表示已选$i$个数放入序列， 其中最大值为$j$的方案数， 如果下一个可选的数比$j$大， 显然是合法的。 但如果下一个数比$j$小，为了保证最长下降子序列的长度不超过$2$， 显然应该选当前未选的元素中最小的一个， 因此这个转移是唯一的。所以$dp[i][j]$可转移至$dp[i+1][j+k](j+k\le n,k\ge 0)$。

把$(i,j)$视为一个点， 那么发现实际上我们要求的就是$(0,0)$到$(n,n)$且**不跨过**$y=x$这条直线， 始终保持在其上方的， 只能向右或向右上走的方案数。 这实际上就是$Catalan(n)$。

那么如果加上字典序限制怎么办呢？类似数位$dp$，我们可以先算一部分最高位比限制大的方案数， 这样之后的数位是不会受到影响的， 然后假设这位恰好为当前位限制的大小继续推下一位。

例如下面这个例子：
![](https://i.loli.net/2018/12/19/5c19d8f43e092.png)



假设我们现在在考虑$E$处的限制， 那么其上面的三个点都不受后面字典序的限制。我们只需要求出这三个点只向右或向右上走到$D$点， 且不跨过$y=x$这条直线的方案数。 显然这个值也就等于$M$点到$D$点的方案数。

这个方案数怎么算？ 就是[这道题](https://www.luogu.org/problemnew/show/P1641)......预处理逆元， 阶乘即可$O(1)$计算。

另外， 注意如果我们强制卡满限制， 填数也是需要满足上面我们$dp$的要求的， 如果某次填入的限制比当前最大的限制小， 且不是最小的一个未填的元素， 直接$break$即可， 因为这样根本不能满足要求， 一定会在这一位选取到一个更大的数。

代码如下：

```cpp
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <algorithm>
#define R register
#define IN inline
#define W while
#define gc getchar()
#define MX 1205000
#define MOD 998244353ll
#define ll long long
template <class T>
IN void in(T &x)
{
	x = 0; R char c = gc;
	for (; !isdigit(c); c = gc);
	for (;  isdigit(c); c = gc)
	x = (x << 1) + (x << 3) + c - 48;
}
template <class T> IN T max(T a, T b) {return a > b ? a : b;}
int fac[MX], inv[MX], bd[MX];
bool used[MX];
IN void pre()
{
	fac[0] = fac[1] = inv[0] = inv[1] = 1;
	for (R int i = 2; i <= 1200000; ++i)
	{
		fac[i] = 1ll * fac[i - 1] * i % MOD;
		inv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;
	}
	for (R int i = 2; i <= 1200000; ++i) inv[i] = 1ll * inv[i] * inv[i - 1] % MOD;
}
IN int C(R int n, R int m)
{
	if (n < m) return 0;
	return 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;
}
int main(void)
{
	int T, n, lim, mn, mx, ans; pre(), in(T);
	W (T--)
	{
		in(n); mx = ans = 0, mn = 1;
		std::memset(used, false, sizeof(bool) * (n + 1));
		for (R int i = 1; i <= n; ++i) in(bd[i]);
		for (R int i = 1; i <= n; ++i)
		{
			lim = max(mx + 1, bd[i] + 1); used[bd[i]] = true;
			if (lim <= n)
			(ans += ((C(2 * n - i - lim + 1, n - i + 1) - C(2 * n - i - lim + 1, n - i + 2) + MOD) % MOD)) %= MOD;
			if (mx < bd[i]) mx = bd[i];
			else if (bd[i] != mn) break;
			W (used[mn]) ++mn;
		}
		printf("%d\n", ans);
	}
}

```

---

## 作者：wu3412790 (赞：17)

  不知道大家是怎么做的，退役已久的老博士硬推了3小时。
  首先分析一个排列$P$什么时候达到最少交换次数，按照下界的证明，每一次交换都应该使得$\delta(P):=\sum_{i=1}^n |i-p_i|$减少2，否则就并不能达到下界。
  
  这样一来，我们可以观察到，如果$p_i\leq i$，那么这个数从始至终向右移动。类似地，如果$p_i\geq i$，这个数只能向左移动。所以如果$p_i\leq i$，那么$p_i$之前的数应该都比它小，否则会迫使$p_i$向左移动。同样，如果$p_i\geq i$，那么$p_i$之后的数都应该比他大。
  
  这可以总结为，不存在三个指标$i<j<k$满足$p_i>p_j>p_k$，否则考虑$p_j$若$p_j\geq j$则它后面的数$p_k$比它大，若$p_j\leq j$则它前面的数$p_i$比它小，都将导致矛盾。反之如果排列中不存在三个下降的数，那么任意一次交换，必然都使得$\delta(P)$减少2，这是因为，如果我们交换了$p_i$和$p_{i+1}$，那么必有$p_i>p_{i+1}$,这时由于不存在三个下降的数，应有$p_i$前的数都比它小，$p_{i+1}$后的数都比它大。所以$i<p_i$且，$p_{i+1}<i+1$，这表明这次交换使得$\delta(P)$减少了2。从而每一次交换都会使$\delta(P)$减少2，故交换次数达到了下界。
  
  这样一来，我们面对的将是一个纯粹的组合问题，问字典序大于某个排列的排列中，有多少排列不包含长度为3的下降子序列，下文中将称这个性质为"漂亮的“。字典序的处理比较常规，只需要枚举从哪一位开始第一次大于给定串就可以，这样我们就需要处理如下子问题: 固定前缀的排列中，有多少个是“漂亮的”？
  
  首先应判断前缀中是否有长度$\geq 3$的下降子序列，如果有，方案数为0，还需判断一下，剩下数中的最小者是否能和前缀中的两个数组成下降子序列，这些都可以用简单的前缀数组解决，属于基本功。
  
  接下来，如果上述情况未发生，注意到前缀对我们的影响将只剩下前缀中的最大数，因为我们已经判断前缀中取两数或三数，无法组成下降子序列。所以问题进一步简化为，在$m$个数的排列中，如果第一个数是$x$，有多少这样的排列不包含长度为3的下降子序列？这个问题递归性明显，我们尝试建立递推式。以下记上述子问题的方案数为$f(x,m)$。
  
  当$x=m$时，$\{1,2,...,m-1\}$都在$m$后面，所以他们必然是有序的，这样只有$1$方案，故$f(m,m)=1$。
  
  当$x=1,2$时，后面的$m-1$个数不可能和$x$形成长度为3的下降子序列，故后面$m-1$的排列方案为$\sum_{i=1}^{n-1} f(i,n-1)$种，即长度为$n-1$的不包含长度为$3$的下降子序列的排列总数。
  
  当$3\leq x\leq n-1$时，考虑$x$后第一个大于x的数，设它的位置为$i\in \{2,...,x+1\}$，大小是$j\in \{x+1,...,m\}$。注意到$\{1,2,...,x-1\}$在$x$之后，故他们在排列中必然有序，这表明第$2$到第$i-1$个数必然是$1$到$i-2$，这也说明了为什么i的取值范围是$2$到$x+1$。这样一来，前$i$个数对后面的影响，可以简化为一个$j$，这样就把方案数转化到子问题$f(j-i+1,m-i+1)$上。所以我们得到递推式:
  $
  f(x,m)=\sum_{2\leq i\leq x+1\leq j \leq m}f(j-i+1,m-i+1)
  $
  ，直接按照这个公式递推，复杂度较高，期望得分60分左右。
  我们注意到$f$的相邻项之间存在大量重复，可将递推式简化为，
  $
  f(x,m)=f(x-1,m-1)+f(x+1,m)
  $
  按照这个公式递推，可以得到80分。
  
 想要得到满分，我们还需要进一步求出$f$的通项。观察上式，我们容易联想到组合数的递推关系，
   $
  C(n,m)=C(n-1,m-1)+C(n-1,m)
  $
  于是我们试图将递推式往这个方向变形。令$g(x,m)=f(m-x,m)$，则我们可以得到$g(x,m)=g(x-1,m)+g(x,m-1)$, 其中边界条件为$g(0,i)=1$以及$g(j,i)=0,j\geq i$。至此，递推式已经完全拥有的组合数的组合解释，考虑一个$n\times m$的方格，要从点$(0,1)$走到点$(x,m)$，每次只能向右或向下行走，且不能碰到对角线(即横坐标永远小于纵坐标，对应上面的边界条件
 $g(j,i)=0,j\geq i$)，问有几种方案。这个模型相当的经典，他就是我们的老朋友"卡塔兰数"，当然这里是广义的：有$x$个$-1$和$m$个$+ 1$，$m>x$,问有多少序列的任意前缀和都大于0。这可以用我们熟悉的翻转第一个碰到对角线的点的前缀的方法，或者构造满足边界条件的公式并使用数学归纳法证明，无论使用哪种方案，我们都可以得到
$
g(a,b)=C(a,a+b-1)-C(a-1,a+b-1)
$
验证一下·，带入$a=b-1=n$ (注意我们是从(0,1）出发)，我们就得到了常规的卡塔兰数的公式$C_n=C(n,2n)-C(n-1,2n)$。

在推出上述公式以后，代码方面难度极低，只需要处理好一些必备的前缀数组，会算组合数模$P$就行，这都在提高组的要求以内，想必对NOI选手是小菜一碟。
```cpp
#include <iostream>
#include <cstring>
using namespace std;
long long const N=1e6+3e5,P=998244353;
int n,t,p[N],r[N],sr[N],pr[N];
long long ans,fac[N],inv[N];
long long power(long long x, long long k){
	k=(k+P-1) % (P-1);  
	long long ans=1;
	for (long long i=1;i<=k;i*=2,x=(x*x) % P)
		 if (k & i) ans=(ans*x) % P;
	return ans;
}
long long c(long long a, long long b){
	if (a<0) return 0;
	return fac[b]*inv[a] % P * inv[b-a] % P; 
}
long long g(long long a, long long b){
	return (c(a,a+b-1)-c(a-1,a+b-1)+P) % P;
}
int main(){
	ios::sync_with_stdio(false);
	fac[0]=inv[0]=1;
	for (int i=1;i<N;i++){
		fac[i]=fac[i-1]*i % P;
		inv[i]=power(fac[i],P-2);
	}
	cin>>t;
	while (t--){
		cin>>n;
		ans=0;
		for (int i=1;i<=n;i++){
			cin>>p[i];
			r[i]=max(r[i-1],p[i]);
			if (r[i-1]>p[i]) pr[i]=max(pr[i-1],p[i]); else pr[i]=pr[i-1];
		}
		sr[n]=p[n];
		for (int i=n-1;i>=1;i--)
			sr[i]=min(sr[i+1],p[i]);
		for (int i=1;i<=n;i++){
			if (r[i]<n) ans=(ans+g(n-r[i]-1,n-i+2)) % P;
			if (pr[i-1]>p[i]) break;
			if (i<n && p[i]<r[i-1] && (p[i]>sr[i+1])) break;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```



---

## 作者：BruceW_07 (赞：11)

# 「解题报告」[NOI2018]冒泡排序 (DP + Catalan 数)

[更好的阅读体验](https://www.cnblogs.com/BruceW/p/13288630.html)

[传送门](https://www.luogu.com.cn/problem/P4769)

## 题意

已知排列 $p$ 冒泡排序的一个交换次数的下界是 $\frac{1}{2} \sum_{i=1}^{n} |i - p_i |$.

给定一个长度为 $n$ 排列 $q$, 求字典序严格大于 $q$ 且满足冒泡排序交换次数为 $\frac{1}{2} \sum_{i=1}^{n} |i - p_i |$ 的排列 $p$ 的个数.

$n \le 6 \times 10^5$.

</br>

## 思路

### 基本思路

首先, 冒泡排序交换次数为 $\frac{1}{2} \sum_{i=1}^{n} |i - p_i |$ 这个条件显然不能直接用, 所以我们考虑把它转化一下.

由题目中对于这个下界的证明可以得到, 当且仅当在排序过程中 $p$ 中的数只朝一个方向移动 (即数 $p_i$ 的移动次数是 $| i - p_i |$) 时, 排列 $p$ 能达到这个下界.

为了方便描述 & 理解, 我们设 $pl_i$ 为**数字** $i$ 在排列 $p$ 中的位置.

1. 若 $pl_i \le i$, 则 $pl_i$ 前面不存在大于 $i$ 的数字 $j$ (否则会使 $i$ 往前移动一位);

2. 若 $pl_i \ge i$, 则 $pl_i$ 后面不存在小于 $i$ 的数组 $k$ (否则会时 $i$ 往后移动一位).

现在条件稍微直观了一点, 但它还是对于单个数的条件, 我们看看能不能把它变成对于排列整体的条件.

我们可以根据上面的条件得到它的逆否命题, 即

1. 若 $pl_i$ 前面存在大于 $i$ 的数字 $j$, 即 $\exists j >i$ 满足 $pl_j < pl_i$, 则 $pl_i > i$;
2. 若 $pl_i$ 后面存在小于 $i$ 的数字 $k$, 即 $\exists k < i$ 满足 $pl_k > pl_i$, 则 $pl_i < i$.

当上面两个条件同时成立时 $pl_i \in \empty$.

所以 $\not \exists k < i < j$ 满足 $ pl_k > pl_i > pl_j$. 

用人话来说, 就是排列 $p$ 中不存在长度 $\ge 3$ 的下降序列.

所以,可以把排列 $p$ 分为 $ \le 2$ 个上升序列.


这样, 我们就把原条件变为了排列 $p$ 能够被分为 $ \le 2$ 个上升序列, 可以用 DP 解决.

先不考虑字典序的限制. 设 $f[i][j]$ 为已经填上了前 $i$ 位数,  大于 $\max_{k=1}^{i} p_k$  且未被填上的数有 $j$ 个.

设我们已经求出了 $f[i-1][j]$, 考虑如何转移到 $f[i][j']$.

有两种情况

1. 在第 $i$ 位填上一个大于 $max_{k=1}^{i-1} p_k$ 的数, 转移到 $f[i][j-1 \sim 0]$;
2. 在第 $i$ 位填上一个小于 $max_{k=1}^{i-1} p_k$ 的数. 由于排列中最多只能有 $2$ 个上升序列, 所以我们只能填上目前未被选上的数中的最小值, 否则就会产生 $3$ 个上升序列. 转移到 $f[i][j]$.

注意 : 当 $j=n-(i-1)$ 时, 未被选上的数都大于 $max_{k=1}^{i-1} p_k$, 所以不能进行第二种转移.

边界条件 : $f[0][n]=1$. 最终答案 : $ans = f[n][0]$.


再来考虑字典序的限制. 

考虑模仿数位 DP. 对排列 $q$ 求出 $s[i]$, 表示 $i$ 后面比 $\max_{k=1}^{i} q_k$ 更大的数的个数. 这可以用树状数组求, 也可以模仿上述 DP 的实际过程线性求得.

当 DP 进行到 $i$ 时, 我们对 $f[i][s[i]-1 \sim 0]++$, 表示前 $i-1$ 位与 $q$ 相同, 第 $i$ 位大于 $q$ 的情况. 剩余部分按照过程转移就行了.

这个 DP 的时间复杂度是 $O(n^3)$ 的, 加上前缀和优化可以达到 $O(n^2)$, 获得 $80pts$.



### 优化

数形结合.

我们再来看一下上述 DP 的转移方程
$$
f[i][j] \rightarrow f[i+1][j \sim 0]
$$
$i \in [0,n],\ j \in [0,n-i]$.

我们把 $f[i][j]$ 看作是平面直角坐标系上的点 $(i,j)$, 可以画出来一张这样的图.

![1](https://cdn.luogu.com.cn/upload/image_hosting/jn6dv1sq.png)

当不考虑字典序限制时, 答案为从点 $(0,n)$ 到 $(n,0)$ 且不穿过直线 $y=-x+n$ 的最短路径方案数, 也就是 $Catalan$ 数.

考虑字典序限制时, 相当于固定了若干个起点 $(i, s[i-1] \sim 0)$, 然后求这些起点到 $(n,0)$ 的方案数之和.

求点 $(i,j)$ 到 $(n,0)$ 的不穿过直线 $y=-x+n$ 的方案数, 我们可以模仿 $Catalan$ 数的求法.

作点 $(i,j)$ 关于直线 $y = -x + n-1$ 的对称点, 易得其坐标为 $(n-j+1,n-i+1)$.

![2](https://cdn.luogu.com.cn/upload/image_hosting/f19lvuc0.png)

由图可知, 点 $(n-j+1,n-i+1)$ 到 $(n,0)$ 的每条最短路径都会穿过直线 $y = -x + n-1$, 并且每条路径都会对应着一条从 $(i,j)$ 到 $(n,0)$ 的穿过直线 $y = -x + n$ 的最短路径.

所以, $(i,j)$  到 $(n,0)$ 的不穿过直线 $ y = -x + n$ 的最短路径数量为
$$
C(n-i+j,j) - C(n-i+j,n-i+1)
$$
设其为 $F(i,j)$, 那么我们的最终答案就是 
$$
\sum_{i=1}^{n} \sum_{j=0}^{s[i]-1} F(i,j)
$$
这样做还是 $O(n^2)$ 的. 但我们注意到, 点 $(i,s[i]-1 \sim 0)$ 到 $(n,0)$ 的路径数量之和其实就相当于 $(i-1,s[i]-1)$ 到 $(n,0)$ 的路径数量. 所以答案式可以改写为
$$
\sum_{i=1}^{n} F(i-1,s[i]-1)
$$
可以 $O(n)$ 完成.



## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

const int _=2e6+7;
const int mod=998244353;

int n,q[_],s[_],fac[_],invf[_];
bool b[_];

int gi(){
	int x=0; char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x;
}

int Pw(int a,int p){
	int res=1;
	while(p){
		if(p&1) res=(ll)res*a%mod;
		a=(ll)a*a%mod; p>>=1;
	}
	return res;
}

void Pre(){
	int n=2e6;
	fac[0]=1; for(int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;
	invf[n]=Pw(fac[n],mod-2); for(int i=n-1;i>=0;i--) invf[i]=(ll)invf[i+1]*(i+1)%mod;
}

void Init(){
	memset(s,-1,sizeof(s));
	memset(b,0,sizeof(b));
	
	n=gi();
	for(int i=1;i<=n;i++)
		q[i]=gi();

	int j=n,minx=1;
	for(int i=1;i<=n;i++){
		int x=n-q[i];
		if(x<j) s[i]=x-1,j=x;
		else if(q[i]==minx)	s[i]=j-1;
		else{ s[i]=j-1; break; }
		b[q[i]]=1;
		while(b[minx]) minx++;
	}
}

int C(int n,int m){
	if(n<m) return 0;
	return (ll)fac[n]*invf[m]%mod*invf[n-m]%mod;
}

int f(int i,int j){ return (C(n-i+j,j)-C(n-i+j,n-i+1)+mod)%mod; }

void pls(int &x,int y){ x=(ll)(x+y)%mod; }

void Run(){
	int ans=0;
	for(int i=1;i<=n;i++)
		if(s[i]!=-1)
			pls(ans,f(i-1,s[i]));
	printf("%d\n",ans);

}	

int main(){
#ifndef ONLINE_JUDGE
	freopen("inverse.in","r",stdin);
	freopen("inverse.out","w",stdout);
#endif
	Pre();
	int T=gi();
	while(T--){
		Init();
		Run();
	}
	return 0;
}
```



---

## 作者：xyz32768 (赞：10)

网上有各种不同的题解，来写一发自己的思路。

~~一道打表找规律好题~~

~~感觉题解比代码还长~~

首先通过 (zhao) 证 (gui) 明 (lv) ，可以得到：

一个排列的操作数达到下界，

当且仅当该排列不存在任意一个长度大于等于 $3$ 的下降子序列。

一个不严谨的证明：

设第一个数为 $x$ ， $x$ 右边第一个比 $x$ 的**位置**为 $d$ 。

那么第一轮排序会把 $x$ 移到位置 $d-1$ ，

原先 $[2,d]$ 位置区间内的数整体左移，相对顺序不变。

由于操作数达到下界相当于每次交换的两个数都朝着自己的方向移动，

故只有 $[2,d]$ 内按顺序填着 $[1,d-1]$ 内的数才合法。

以此类推，得出结论。

~~这证明确实不严谨，还是打表找规律快且简单~~

这种题~~当然~~要从下往上考虑，从暴力推出正解~~啦~~。

先考虑 $i=p_i$ （不考虑字典序）及 $n\le 1000$ 。

首先，通过一定的规律可以发现，长度为 $n$ 的排列第一个数为 $1$ 和 $2$ 时方案数相同，为 $3$ 时明显没有为 $2$ 时多，为 $4$ 时方案数继续下降，…，为 $n$ 时只有 $1$ 个合法方案。

我们可以设 (luan) 计 (gao) 出一个状态：

$f[i][j]$ 表示 $i$ 个数的排列，以 $j$ 为开头，合法方案数。

继续利用爆搜打出 $1\le j\le i\le10$ 的 dp 值。

可以通过找规律，得出：

$$f[1][1]=1$$

$$\forall i\ge j\ge2,f[i][j]=\sum_{k=j-1}^{i-1}f[i-1][k]$$

$$\forall i\ge 2,f[i][1]=\sum_{k=1}^{i-1}f[i-1][k]$$

利用前缀和优化，我们解决了 $n\le 1000$ 且 $i=p_i$ 的数据。

如果对字典序有限制，我们就必须要证明。

首先如果第 $1$ 个数为 $1$ ，那么后面的 $i-1$ 个数只要不产生长度大于等于 $3$ 的下降子序列即可。（ $1$ 无法作为长度为 $3$ 的下降子序列的第一个数）

如果把后面 $i-1$ 个数同时减去 $1$ ，那么后 $i-1$ 个数构成了一个合法的 $i-1$ 个数的排列。

如果第 $1$ 个数为 $j$ ，我们分情况讨论：

（1）如果第 $2$ 个数 $\in(1,j)$ ，那么 $1$ 一定出现在第 $2$ 个数的右边，这样第 $1$ 个数 $j$ 、第 $2$ 个数、以及 $1$ 构成了一个长度为 $3$ 的下降子序列。不合法。

（2）如果第 $2$ 个数 $\in(j,i]$ ，那么如果第一个数右边存在两个值 $x,y$ 可以和 $j$ 构成下降子序列，那么第二个数也一定能和 $x,y$ 构成下降子序列（第二个数大于第一个数）。如果把从第二个数开始的所有大于 $j$ 的数都减一，那么后 $i-1$ 个数一定构成了一个合法排列，首位数的取值为 $[j,i-1]$ 。

（3）如果第 $2$ 个数为 $1$ ，就比较难讨论了。但思考一下，这时候后面的数满足的条件为：$[1,j-1]$ 范围的数按照相对顺序出现。也就是说， 数 $2$ 在 $1$ 后面出现，数 $3$ 在 $2$ 后面出现，…，数 $j-1$ 在 $j-2$ 后面出现，但不一定出现在序列的一段连续区间内。同样地，如果把从第二个数开始的所有大于 $j$ 的数都减掉 $1$ ， 并把 $1$ 移到 $2$ 的所在位置， $2$ 移到 $3$ 所在的位置，…， $j-1$ 移到 $1$ 的所在位置，那么这样得到的排列就是一个 $i-1$ 个数的排列，并且第一个数为 $j-1$ 。同样地，我们证了必要性后也可以用差不多的方法证充分性。于是第 $2$ 个数为 $1$ 时的贡献为 $f[i-1][j-1]$ 。

至此，我们已经证完了转移方程。

开始考虑字典序限制。

我们知道， $f[i][j]$ 可以从 $f[i-1][k]$ 转移，其中 $k\in[\max(1,j-1),i-1]$ 。

其中如果 $k$ 为 $\max(1,j-1)$ ，那么表示从「第 $2$ 个数为 $1$ 」转移，否则表示从「第 $2$ 个数为  $k$ 转移 」。

注意：下面我们把 $f[i][j]$ 广义化：表示 $i$ 个不同的数的排列，第一个数排名为 $j$ 的方案数， $rk_i$ 的定义为 $p$ 在位置区间 $[i,n]$ （以 $i$ 为开头的后缀）内 $i$ 位置上数的排名。当然， $rk_1=p_1$ 。

做法：首先考虑 $f[n][...]$ 。

对于 $i>rk_1$ ，根据字典序的定义，如果排列的第 $1$ 个数填了 $i$ ，那么之后不管怎么填字典序都不会小于等于 $p$ 。

而对于 $i=rk_1$ ，我们需要继续去寻求 $j>rk_2$ ，让第二个数填 $j$ 。

于是从 $f[n][i]$ 向上走，转移到 $f[n-1][\max(1,i-1)...n-1]$ 继续处理。

但这一步 $j$ 的取值只能是 $1∪(\max(1,i-1)+1,n-1]$ 。

同样把 $j>rk_2$ 和 $j=rk_2$ 分开处理，如果 $j>rk_2$ ，那么直接把 $f[n-1][j]$ 加入即可。

如果 $rk_2=1$ ，那么从 $f[n-1][\max(1,i-1)]$ 向上一层转移。

否则在 $f[n-1][rk_2]$ 向上一层转移。

必须注意 $rk_x=1$ 时向上转移的方式，如上。

~~本蒟蒻的代码里使用总方案数减去了字典序小于等于 p 的方案数，请见谅~~

像这样从下往上~~迭代~~转移，就能统计答案。

我们实现了 $O(Tn^2)$ 的复杂度，可以得到 80 分。

为了拿到 100 分，我们先解决掉俩小问题：

（1）求 $rk_i$ 使用树状数组，就可以把单次求 $rk$ 的复杂度降到 $O(\log n)$ 。

（2）上面的过程中，我们对于每一层（第一维下标） $f$ 其实都是进行了一次区间求和。我们记录下 $f$ 每一层的前缀和即可快速求得 $f$ 某一层的区间和。同时，我们从 $f$ 的转移方程里可以知道， $f$ 的某一层内的区间和，就是下一层的单点值。

这两个小问题解决了，我们就剩下一个待解决的问题：

前面的 $f$ 是要通过平方的时间预处理的，但是实际上会用到的 dp 值只有 $O(Tn)$ 个。故我们考虑如何单点快速求 $f$ ，即 $f$ 的通项公式。

我们之前打出 $f$ 的时候忘记说了一个性质：

$$f[i][1]=Catalan(i+1)$$

$Catalan$ 表示卡特兰数。

预处理阶乘及其逆元即可。

但我们要求的不仅仅是 $f[i][1]$ ，

故我们还是要证明为什么 $f$ 是卡特兰数。

我们注意到 $f$ 的转移中用到的其他 dp 值个数为 $O(n)$ 级别。

故考虑记录 $s[i][j]$ 表示 $f$ 第 $i$ 层的后缀和：

$$s[i][j]=\sum_{k=j}^if[i][k]$$

根据上面，我们有 $s[n][1]=Catalan(n)$ 。

这样转移方程就简化了：

$$s[1][1]=1$$

$$\forall i\ge j\ge2,s[i][j]=s[i-1][j-1]+s[i][j+1]$$

$$\forall i\ge 2,s[i][1]=s[i-1][j]+s[i][j+1]$$

这是一个显然的路径模型！

$s[i][j]$ 可以看做从 $(1,1)$ 出发，每一步走的规则如下：

（1）可以往右上 45 度走 $\sqrt2$ 个长度单位（ $x$ 坐标和 $y$ 坐标各加 $1$ ）

（2）可以往下走（ $y$ 坐标减 $1$ ）

（3）如果当前 $y$ 坐标为 $1$ （触碰直线 $y=1$ ），那么可以往右走（ $x$ 坐标加 $1$ ）

（4）不得走到直线 $y=1$ 的下方。

走到 $(n,1)$ 的方案数。

![这里写图片描述](https://img-blog.csdn.net/20180809172148967?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ejMyNzY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

发现规则（3）让我们很难推出性质。

所以我们把  $0$ 扩充进 $i,j$ 的取值，规定 $s[0][0]=1,s[i][0]=s[i][1]$ （ $i>0$ ）

那么所有的转移都被整成一样的，不会有（3）那样 GAYGAY 的条件：

$$s[i][j]=s[i-1][j-1]+s[i][j+1]$$

我们的走法也简单了。

从 $(0,0)$ 走到 $(n,0)$ ，

（1）可以向右上 45 度走 $\sqrt2$ 个长度单位或者向下走 $1$ 个长度单位。

（2）不得越到 $x$ 轴的正下方。

求方案数。

![这里写图片描述](https://img-blog.csdn.net/20180809172201795?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ejMyNzY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

为了使 $x$ 坐标 $+=n$ ，我们要使用 45 度走法走 $n$ 步，但这样导致 $y$ 坐标加一了 $n$ 次，故我们还要使用向下走的操作 $n$ ，才能到达 $(n,0)$ 。

这相当于在 $2n$ 步中选出 $n$ 步向下走。方案数 $C_{2n}^n$ 。

如何去除掉越到 $x$ 轴下方（触碰直线 $y=-1$ ）的方案数呢？

显然，走了 $k$ 步之后，到达点的 $y$ 坐标为前 $k$ 步中， 45 度的步数减去向下的步数。

把操作序列转化成 01 序列， $0$ 表示走 45 度， $1$ 表示向下走，显然这是一个 Catalan 序列，即任意前缀中 $0$ 的个数都 $\ge$ $1$ 的个数的长度为 $2n$ 的序列。

对于一个不合法的序列，我们可以找到第一个满足 $0$ 的个数 $+1=$ $1$ 的个数的前缀 $[1,k]$ 。

将 $[1,k]$ 内的数全部取反，我们得到了一个 $n+1$ 个 $0$ 和 $n-1$ 个 $1$ 构成的序列。

于是有：

$$s[n][0]=Catalan(n)=C_{2n}^n-C_{2n}^{n-1}$$

拓展到一般情况：

$$s[n][m]=C_{2n-m}^{n-m}-C_{2n-m}^{n-m-1}$$

至此，我们实现了单点求 $s$ ，故查询一个 $f$ 值可以在线性预处理阶乘及其逆元后 $O(1)$ 求出。

由于求 $rk$ 时要用树状数组，故复杂度 $O(Tn\log n)$ 。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
#define Rof(i, a, b) for (i = a; i >= b; i--)
using namespace std;
inline int read() {
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}
const int N = 6e5 + 5, M = 12e5 + 5, ZZQ = 998244353;
int n, a[N], fac[M], inv[M], A[N], rk[N];
int C(int n, int m) {
	return 1ll * fac[n] * inv[m] % ZZQ * inv[n - m] % ZZQ;
}
int sum(int n, int m) {
	return (C((n << 1) - m, n - m) - C((n << 1) - m, n - 1 - m) + ZZQ) % ZZQ;
}
void change(int x, int v) {
	for (; x <= n; x += x & -x)
		A[x] += v;
}
int ask(int x) {
	int res = 0;
	for (; x; x -= x & -x) res += A[x];
	return res;
}
void work() {
	int i, j, lst = 1, ans = 0;
	n = read();
	if (!n) return (void) puts("0");
	For (i, 1, n) a[i] = read(), A[i] = 0;
	Rof (i, n, 1) change(a[i], 1), rk[i] = ask(a[i]);
	For (i, 1, n) {
		if (lst < rk[i]) ans = (ans + (sum(n - i + 1, lst) -
			sum(n - i + 1, rk[i]) + ZZQ) % ZZQ) % ZZQ, lst = rk[i];
		else if (rk[i] > 1) {
			ans = (ans + sum(n - i, lst - 1)) % ZZQ;
			break;
		}
		else if (i == n) ans = (ans + 1) % ZZQ;
		if (lst > 1) lst--;
	}
	printf("%d\n", (sum(n, 0) - ans + ZZQ) % ZZQ);
}
int main() {
	int i, j, T = read();
	fac[0] = inv[0] = inv[1] = 1;
	For (i, 1, 1200000) fac[i] = 1ll * fac[i - 1] * i % ZZQ;
	For (i, 2, 1200000) inv[i] = 1ll * (ZZQ - ZZQ / i) * inv[ZZQ % i] % ZZQ;
	For (i, 1, 1200000) inv[i] = 1ll * inv[i] * inv[i - 1] % ZZQ;
	while (T--) work();
	return 0;
}
```

---

## 作者：Sol1 (赞：9)

结论题还是要理性理解一下的嘛。

考虑题目里面给的那个下界显然要求每一个元素都不能多走一步，必须沿那个方向走到自己排好序之后所在的位置。

那么如果一个元素要向右走，那么它左边就不能有一个元素需要跨过它，否则它至少需要向左走一步。反之也一样：如果一个元素要向左走，那么它右边就不能有一个元素需要跨过它。特殊的，如果一个元素位于原位，那么它两边都不能跨过它。

但是这个结果的形式并不友好，考虑能不能简化一下。

首先最后一种的简化是很明显的：如果一个元素位于原位，那么左边不能有比它大的，右边不能有比它小的。

那么考虑剩下两种有没有相同的形式。观察到，如果一个元素要向右走，那么它的右边一定有比它小的，因为所有比它小的全放到左边它就不可能需要向右走了；而如果左侧有要跨过它的，那么这个元素一定比它大，否则不需要跨过它。对于向左走的是类似的。

整合一下，可以得到结论：**如果出现了长度为 3 的下降子序列，那么一定无法达到下界。**

而如果没有长度为 3 的下降子序列，那么每一个元素的贡献都可以达到下界，因此整个排列就可以达到下界。

~~当然我个人认为这一步打表还是比直接看出来要容易，至少我是通过打表搞出来的。~~

到这一步，我们有一个简单的状压 DP，可以得到 44 分。

然后由 dilworth，这样的排列一定可以被拆分成两个上升子序列。考虑对这样的排列进行多项式复杂度的计数。

设计 $O(n^2)$ DP：$f_{i,j}$ 表示填了排列的前 $j$ 个数，最大值是 $i$。有两种转移：

- 填个比最大值更大的，对 $k>i$ 转移到 $f_{k,j+1}$。
- 填个目前没填进去的最小的，如果 $i>j$，则转移到 $f_{i,j+1}$。

前缀和优化可以做到 $O(n^2)$。考虑一下这个前缀和的形式，它本质是把转移改成了 $f_{i,j}$ 向 $f_{i+1,j}$ 和 $f_{i,j+1}$ 转移。

这玩意看起来非常格线游走。$f_{i,j}$ 表示的是从 $(0,0)$ 开始，每次向上或向右移动 1 单位距离，不能走到 $y=x$ 上侧，走到 $(i,j)$ 的方案数。

套用卡特兰数的通项的证明方式可以类似得到 $f_{i,j}=\dbinom{i}{j}-\dbinom{i}{j-1}$。

那么现在就可以 $O(n)-O(1)$ 计算 $f$ 了。

最后考虑 $q$ 的限制。枚举一段前缀 $[1,i]$ 强制其和 $q$ 一样，然后强制 $i+1$ 放个比 $q_{i+1}$ 大的，然后后面就跟 $q$ 没关系了。

首先前面的部分需要合法。考虑递增枚举 $i$。如果 $q_i$ 比它前面所有 $q$ 都大，那么显然可以放。如果 $q_i$ 是前 $i-1$ 个数里面没出现过的数里面最小的数，那么也可以放。别的都不能放。如果发现需要放一个不能放的就 break 掉就可以了。

如果能放，那么计算强制 $i+1$ 放个比它大的数的方案数。显然不能放没出现过的最小的（因为前面都和 $q$ 一样，所以这个数一定 $\leq q_{i+1}$），所以方案数就是从 $(i,\max\limits_{j\leq i}q_j+1)$ 游走到 $n,n$，而且不走到线以上的方案数。这个稍微对称一下就能用上面的方法算了。

那么这题就做完了，复杂度 $O(\sum n)$。

```cpp
const long long mod = 998244353;
const int N = 1200005, mxN = 1200000;
int n, a[N];
long long f[N], fac[N], ifac[N];
bool vis[N];

inline void Prefix() {
    ifac[1] = 1;
    for (int i = 2;i <= mxN;i++) ifac[i] = (mod - mod / i) * ifac[mod % i] % mod;
    fac[0] = fac[1] = ifac[0] = 1;
    for (int i = 2;i <= mxN;i++) {
        fac[i] = fac[i - 1] * i % mod;
        ifac[i] = ifac[i - 1] * ifac[i] % mod;
    }
}

inline void Read() {
    n = qread();
    for (int i = 1;i <= n;i++) a[i] = qread();
}

inline long long C(int n, int r) {
    if (n < r || r < 0) return 0;
    return fac[n] * ifac[r] % mod * ifac[n - r] % mod;
}

inline long long Walk(int n, int m) {
    if (n < m || m < 0) return 0;
    return (C(n + m, m) - C(n + m, m - 1) + mod) % mod;
}

inline void Solve() {
    memset(vis, 0, sizeof(vis));
    long long ans = 0, minx = 1, mxv = 0;
    for (int i = 1;i <= n;i++) {
        if (a[i] > mxv) {
            ans = (ans + Walk(n - i + 1, n - a[i] - 1)) % mod;
            mxv = a[i];
            vis[mxv] = 1;
            while (vis[minx]) minx++;
        } else if (a[i] == minx) {
            ans = (ans + Walk(n - i + 1, n - mxv - 1)) % mod;
            vis[minx] = 1;
            while (vis[minx]) minx++;
        } else {
            ans = (ans + Walk(n - i + 1, n - mxv - 1)) % mod;
            break;
        }
    }
    cout << ans << endl;
}
```

总之感觉这题最难的地方还是在于猜出那个两个上升子序列的结论。这里我通过从简单的情况，尝试用类似的形式进行推广的方式解决了这个问题。

其实这个方法挺通用的。我相信数学应该是简单的，是优美的，而不应该是繁杂的分类讨论。所有的答案最终都应能够整合到一个统一、简洁、漂亮的形式。因而也可以从一个统一的形式来寻求一个猜测答案的方向。可能正是这种由简单推至复杂而最终又回归于简单的结论，才是 OI 最美妙的一面吧。













---

## 作者：shadyqwq (赞：6)

day1最有意思的题！看了[如何评价 NOI2018？ - 武弘勋的回答 - 知乎](https://www.zhihu.com/question/285383359/answer/445463846)会的。很喜欢这道题！

我在场上发现的性质是一个p_i它前面与它相关的逆序对数必须正好等于max(0, p_i - i)，因为每次一轮冒泡之后，一个点最多向前移动一步，那么若一个点在它原本位置的后面，它就至少需要距离大小这么多轮，也就是前面有这么多与它相关的逆序对，而它必须取到下界，到这里我们就可以用状压dp解决这个问题 。之后看题解发现这其实是半个结论。

真正的性质应该是每个点与它相关的逆序对的总个数为|i - p_i|，考虑若一个点该去的位置在它的后面，它也至少需要i - p_i这么多个后面与它相关的逆序对，而它也要取到下界。那么我们设一个数它目前位置前面小于等于它的数目为k，那么它的逆序对个数为前面比它大的加后面比它小的(p_i - k) + (i - k)。

可以发现k等于min(p_i, i)，这意味着一个数它要么前面的数都比它小，要么比它小的都在它前面，也就是说如果前面有一个数比它大，那后面的数一定比它大。然后发现这个问题等价于终序列中不存在长度大于2的下降序列，为什么呢，首先这个问题等价于原序列可以划分为最多两个上升子序列（这里指的是贪心划分，例如能合并成一个我们就不算它两个）。充分性很好证明，必要性可以通过反证法证明。

那么我们就可以写出一个dp，``f[i][j]``表示已经放了前i个数，在剩余可取的数中有j个数比它大，那么我们每次加入一个数可以选择更新一个最大值，或者选一个比它小的里面最小的那个（因为不选最小的话就存在大于2的下降序列了），当j = n - i时，我们只能选择更新最大值。

dp已经可以得到80分了，下面是真正有趣的地方qwq。

记j'为剩下的数中比最大值小的数的个数，我们可以发现，我们每次进行一个操作，j'要么-1（不更新最大值），要么加上任意一个自然数(可以是0)，即更新最大值；因为j'=(n - i) - j。那么我们的合法方案数就是从(0,0)通过上述操作，不超过y = 0这条线的，到(n,0)的方案数。

然后这玩意儿居然等于长度为2n的括号序列方案数......这其实并不是那么显然，因为我们每次还可以加一个数0。然后你发现它其实是在每一个i一定会减1的基础上再去操作的，0相当于+1-1，这其实就等价于卡特兰数了。

若我们要通过一个更加具象的东西来理解的话，其实可以发现它其实就是一个出栈序列。感受下我们每次加入一个最大值其实分为两步，把剩余数中的数从小到大一个个入栈，若我们要把它钦定为最大值就把它出栈（放到序列末尾），这一操作相当于加一任意数；然后我们也可以选择将栈里之前的最小一个元素出栈（虽然我们这里貌似变成了是先入栈的先出栈，但是由于它的出栈顺序是一定的，元素等价，所以我们也可以把它视为是栈顶的出栈了），这一操作相当于给序列减1，然后只有当我们栈里有元素的时候才可以出栈（-1），所以它不能超过y=0这条直线。而之前0的问题相当于，我们入栈一个元素立马把它出栈了。

来举个栗子吧！比如我现在有一个合法序列：41253，它的路径其实长成这样：

![嘿嘿嘿](https://www.shadyqwq.pw/_cache/thumbnails/b/036a4e5637636378b9dbf0493d1015b_1370_none_true_86.png)

这实在是太有趣了！

现在我们的问题就变成了如何处理字典序。这其实非常简单，只需要枚举它的前缀即可，这相当于我们每次要计算从一个定点开始到(2n,0)的路径，用沿y=-1翻转这个常用套路计算贡献即可。如果给出的限制本身就是个合法序列，那么我们可以直接模拟出它的折线，枚举它的每一个折线上斜率为1的部分的 除上凸拐点外的每一个整点，钦定在这个地方向下拐然后算方案数。然后如果不是一个合法序列的话，那么我们直接在不合法的地方统计它的所有方案就行了。

感觉我最后处理字典序这个地方做法的奇奇gaygay，太蠢了。。你们也就这么一看。。感觉应该有比我更聪明的做法。

复杂度是线性的

```cpp
# include <bits/stdc++.h>

using namespace std;

# define REP(i, a, b) for(int i = a; i <= b; ++ i)
# define CLR(i, a) memset(i, a, sizeof(i))
# define REPD(i, a, b) for(int i = a; i >= b; -- i)

const int N = 6e5 + 3, NR = 6e5;

typedef long long LL;

# define gc getchar
inline int rd() {
	char ch = gc(); int ret = 0, sgn = 1;
	while(ch < '0' || ch > '9') { if(ch == '-') sgn = -1; ch = gc(); }
	while(ch <= '9' && ch >= '0') ret = ret * 10 + ch - '0', ch = gc();
	return sgn * ret;
}

int h, up, dwn, t;
struct mp { 
	int x, y; 
	mp() {}  
	mp(int _x, int _y) : x(_x), y(_y) {}
} ;
const int MOD = 998244353;
inline void inc(LL &x, LL y) { x = x + y >= MOD ? x + y - MOD : x + y;  }

inline int pow_(int x, int k) {
	int ret = 1;
	for(; k; k >>= 1, x = (LL)x * x % MOD)
		if(k & 1) ret = (LL)ret * x % MOD;
	return ret;
}
int invfac[N << 1], fac[N << 1];
inline int binom(int x, int y) { return x < y ? 0 : (LL)fac[x] * invfac[y] % MOD * (LL)invfac[x - y] % MOD; }

LL ans;
int n;

bool gone, out[N];
void precise(LL &ret, int x, int y) {
	int len = 2 * n - x, d = 2 + y; 
	inc(ret, ((binom(len, n - up) - binom(len, (len + d) >> 1)) % MOD + MOD) % MOD);
}
inline void calc(LL &ret, mp pre, mp cur) {
	if(pre.y == 0) pre = mp(pre.x + 1, pre.y + 1), ++ up;
	for(; pre.x < cur.x; ++ up, ++ pre.x, ++ pre.y) {
		if(pre.x + 1 > 2 * n) break;
		precise(ret, pre.x + 1, pre.y - 1);
	}
}

const int RA = NR * 2 + 1;

int q[N];
int main() {
	freopen("inverse.in", "r", stdin);
	freopen("inverse.out", "w", stdout);

	fac[0] = invfac[0] = 1;
	REP(i, 1, RA) fac[i] = (LL)fac[i - 1] * i % MOD;
	invfac[RA] = pow_(fac[RA], MOD - 2);
	REPD(i, RA - 1, 1) invfac[i] = (LL)invfac[i + 1] * (i + 1) % MOD;
	
	for(int tt = rd(); tt; -- tt) {
		// cout << tt <<" ??"<<endl;
		h = t = ans = up = dwn = 0;
		REP(i, 1, n) out[i] = 0;
		gone = false;
		n = rd();
		mp cur = mp(0, 0);

		int lst = 0;
		REP(i, 1, n) {
			int a = rd();
			if(gone) continue; 
			if(a > lst) {
				mp pre = cur;
				cur = mp(cur.x + a - t, cur.y + a - t);
				int befup = up + a - t;
				calc(ans, pre, cur); 
				up = befup;
				cur = mp(cur.x + 1, cur.y - 1);
				++ dwn;
				t = a;
				out[t] = 1;
			}
			else { 
				cur = mp(cur.x + 1, cur.y - 1), ++ dwn;
				while(out[h + 1]) ++ h;
				if(a != h + 1 || h + 1 > t) {
					precise(ans, cur.x, cur.y);
					gone = 1;
					// assert(gone == 0);
				}
				h = h + 1;
			}
			lst = max(lst, a);
			// printf("pos:[%d, %d, %d]\n", cur.x, cur.y, i);
		}
		if(!gone) precise(ans, cur.x, cur.y);
		int hh = ((binom(n << 1, n) - binom(n << 1, n + 1) % MOD) + MOD) % MOD;
		printf("%lld\n", ((hh - (LL)ans) % MOD + MOD) % MOD);

	}
	return 0;
}

```


---

## 作者：Kubic (赞：5)

一个简单小清新做法。

首先考虑什么样的排列 $p$ 能够满足要求。

达到下界的要求就是对于某一个数，只能始终往左移动或者始终往右移动。

由于冒泡排序对于每个逆序对都要进行一次交换，所以上面的条件等价于：**不存在** $i<j<k$ 满足 $p_i>p_j>p_k$。因为如果有这样的情况，$p_j$ 就会既往左移动又往右移动。

我们考虑满足这个条件的 $p$ 的更加显式的性质。

如果一个 $p_i$ 不是前缀最大值，那么一定 $\exists i>j,p_i<p_j$。此时显然 $p_i=\operatorname{mex}\{p_{1\dots i-1}\}$，否则就不满足条件。因此我们只要确定了所有前缀最大值，就能唯一对应一个合法的 $p$。

需要注意的是，如果我们上面钦定了 $p_i$ **不是**前缀最大值，那么它就必须要**严格小于**当前的最大值。

也就是说，假设我们钦定了 $k$ 个前缀最大值**下标**为 $a_{1\dots k}$。那么 $\forall i\in [1,n]$，我们找到最大的 $j$ 满足 $a_j\le i$，一定有 $p_{a_j}\ge i$，否则就会多出来一些前缀最大值。

我们先忽视 $p>q$ 的限制。

把它转化成一个格路计数问题：令 $f(x_0,y_0)$ 表示从 $(x_0,y_0)$ 走到 $(n,n)$，**可以触碰**但**不能越过**直线 $y=x-1$ 的方案数。

利用经典套路可知 $f(x,y)=\binom{2n-x-y}{n-x}-\binom{2n-x-y}{n-x+2}$。

答案就是 $f(1,0)$。

此时再考虑限制了 $p>q$ 之后怎么处理。

我们枚举满足 $p_i\neq q_i$ 的最小的 $i$ 出现的位置。先根据限制条件判断 $q_{1\dots i-1}$ 是否满足条件。设 $w=\max\limits_{j=1}^{i-1} q_j$，那么 $i$ 的答案就是 $f(i,w)$。

时间复杂度 $O(\sum n)$。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1200005
#define LIM 1000005
#define MOD 998244353
#define gc() (P1==P2 && (P2=(P1=buf)+fread(buf,1,LIM,stdin),P1==P2)?EOF:*P1++)
const int lim=1.2e6;char *P1,*P2,buf[LIM];
int T,n,ans,fc[N],invF[N],a[N];bool vs[N];
int rd()
{
	int res=0;char c=0;while(!isdigit(c)) c=gc();
	while(isdigit(c)) res=res*10+c-48,c=gc();return res;
}
int add(int x,int y) {x+=y;return x<MOD?x:x-MOD;}
int qPow(int x,int y)
{int res=1;for(;y;y/=2,x=1ll*x*x%MOD) if(y&1) res=1ll*res*x%MOD;return res;}
int C(int x,int y) {return x<y?0:1ll*fc[x]*invF[y]%MOD*invF[x-y]%MOD;}
int f(int x,int y) {return add(C(n*2-x-y,n-x),MOD-C(n*2-x-y,n-x+2));}
void slv()
{
	n=rd();ans=0;for(int i=1;i<=n;++i) vs[i]=0,a[i]=rd();
	for(int i=1,t=1,mx=0;i<n;++i)
	{
		while(vs[t]) ++t;vs[a[i]]=1;mx=max(mx,a[i]);
		ans=add(ans,f(i,mx+1));if(mx<i || (mx>a[i] && a[i]>t)) break;
	}printf("%d\n",ans);
}
int main()
{
	fc[0]=invF[0]=1;for(int i=1;i<=lim;++i) fc[i]=1ll*fc[i-1]*i%MOD;
	invF[lim]=qPow(fc[lim],MOD-2);
	for(int i=lim-1;i;--i) invF[i]=1ll*invF[i+1]*(i+1)%MOD;
	T=rd();while(T--) slv();return 0;
}
```

---

## 作者：zhongyuwei (赞：4)

[my submission on loj.ac](https://loj.ac/submission/779435)

一个排列 $P$ 的冒泡排序交换次数达到下界当且仅当：对于某个位置 $i$ ，在它左边的、比 $P_i$ 大的数的个数不能超过 $\max\{0, i-P_i\}$ 个。

这个条件也等价于：

- 对于 $P_i\le i$ 的元素，它的右侧至少有 $(n-P_i) - (i-P_i) = n-i$ 个比它大的元素，也就是说它是后缀最小值
- 对于 $P_i \ge i$ 的元素，它是前缀最大值

此外一个观察是，对于任意的一个排列，除了 $P_i=i$ 的元素之外，不会有元素既是前缀最大值又是后缀最小值（因为既是前缀最大值又是后缀最小值也就意味着左边有 $P_i-1$ 个比它小的且右边有 $n-P_i$ 个比它大的）。

对于一个冒泡排序交换次数达到下界的排列 $P$ ，考虑把它的所有的前缀最大值都抠掉之后的序列：

- 这些剩下的元素不是前缀最大值，所以它们一定满足 $P_i < i$ ，也就是意味着它们一定是后缀最小值
- 所以，不是前缀最大值的元素一定是升序排列的
- 这也就意味着，只要知道了前缀最大值，就能够唯一地确定一个可能合法的排列 $P$
- 所以只需要对合法的前缀最大值序列计数就可以了

一个前缀最大值序列 $\{ M_i = \max_{j\le i} \{P_j\} \}$ 合法当且仅当 $M_{i-1}\le M_i \wedge M_i\ge i$ ：

- 必要性：因为除了 $P_i = i$ 的元素之外不会有元素同时是前缀最大值和后缀最小值，故而是前缀最大值的元素一定都满足 $P_i \ge i$，所以必须有 $M_i \ge i$
- 充分性：
  - 对于任意排列，是前缀最大值的元素都满足 $P_i \ge i$ ，满足 $P_i\ge i$ 必然是前缀最大值（左边的空位比小于它的数少）
  - 将不是前缀最大值的位置升序填入之后，这些位置必然满足 $P_i < i$ （因为 $i$ 左边的空位置比小于 $i$ 的数少）；$P_i < i$ 的位置必然是后缀最小值（大于它的数的数量超过了它右边的空位的数量）

故而只要统计满足 $M_i \ge i, M_{i-1} \le M_i$ 的 $\{M_i\}$ 的数量即可。

考虑折线模型。例如，对于排列 $\{2,3,1,5,4\}$ ，它前缀最大值序列对应到的折线是这样的：

![0.PNG](https://i.loli.net/2020/04/03/NazDKZ7oySBChLT.png)

发现本质上就是一条从 $(0,1)$ 到 $(n,n)$ 且不经过直线 $y=x-1$ 的折线。

回到原题。设 $ans(x,y)$ 表示从 $(x,y)$ 出发走到 $(n,n)$ 不经过 $y=x-1$ 的方案数，也就是$\binom{2n-x-y}{n-x} - \binom{2n-x-y}{n+1-x}$。我们枚举排列 $p$ 与输入给出的 $q$ 第一个不同的位置 $i$ ，分以下几种情况讨论（设 $mx=\max_{j < i} \{ q_j \}$）：

- $q$ 的长度为 $i-1$ 的前缀不合法：必然也不存在合法的 $p$ ，所以对答案的贡献是 $0$
- $q$ 的长度为 $i-1$ 的前缀合法：
  - $q_i > mx$
    - 由于要求 $p_i > q_i$ ，所以 $p_i$ 也必然是个前缀最大值，所以方案数是 $ans(i-1,q_i + 1)$
  - $q_i < mx$
    - $p_i > mx$ ：此时方案数是 $ans(i-1,mx+1)$
    - $p_i < mx$ ：将不是前缀最大值的数依次升序填入不是前缀最大值的位置，如果到 $i$ 这个位置，该填的数大于 $q_i$ ，这种情况就对答案产生 $ans(i,mx)$ 的贡献；否则贡献为 $0$ 。

预处理阶乘及其逆元就可以在 $O(1)$ 的时间内统计 $i$ 的贡献。总时间复杂度 $O(n)$ 。



---

## 作者：wind_whisper (赞：1)

## 前言
这里是线性做法。  
~~在题解里几句话说清楚的性质愣是推了一上午。~~  
too vegetable.
## 解析
考虑怎样的排列是不合法的。  
一个排列如果不合法，也就是在某次交换时其中一个元素距离目标的距离没有减少反而增大了，那么以后这个数一定会再换回来，也就是这个数会反复横跳。  
考虑怎样的数会反复横跳，不难发现，会反复横跳，也就等价于左边有比自己大的元素，右边有比自己小的元素，也就是存在长度为三的递减子序列。  
所以可以抽象出合法的充要条件：不存在长度为三的递减子序列，也就等价于**排列可以拆分为两个递增序列**。  

这咋算啊？  
打一下表，发现没有字典序的时候，答案就是卡特兰数。  
为什么呢？  
尝试往上嗯套。设 $mx_i=\max_{j=1}^ia_j$，那么一个排列就可以理解为所有的 $(mx_i,i)$ 的点顺次连接的路径，不难发现它和卡特兰数所谓“ $(0,0)\to(n,n)$ 且不超过对角线上方” 的路径是双射的。  

那么本题就好办了，暴力枚举第一个比给出排列大的位置，那么此时必然需要更新 $mx_i$，设 $f((a,b)\to(c,d))$ 是从 $(a,b)$ 走到 $(c,d)$ 且不超过对角线的方案数（可以通过翻折容斥 $O(1)$ 求解），那么这里的方案数就是 $\sum_{j=mx_i+1}^nf((j,i)\to(n,n))=f((mx_i+1,i-1)\to(n,n))$。一直到给出排列的前缀一定无法拆分为两个递增序列是退出。   
总复杂度 $O(n)$。  
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("line: %d\n",__LINE__)

inline ll read(){
  ll x(0),f(1);char c=getchar();
  while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
  while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
  return x*f;
}
bool mem1;

const int N=2e6+100;
const int inf=1e9+100;
const int mod=998244353;
const bool Flag=0;

#define add(x,y)  ((((x)+=(y))>=mod)&&((x)-=mod))
inline ll ksm(ll x,ll k){
  ll res(1);
  while(k){
    if(k&1) res=res*x%mod;
    x=x*x%mod;
    k>>=1;
  }
  return res;
}

int n;

int a[N];
ll jc[N],ni[N];
void init(int n){
  jc[0]=1;
  for(int i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;
  ni[n]=ksm(jc[n],mod-2);
  for(int i=n-1;i>=0;i--) ni[i]=ni[i+1]*(i+1)%mod;
}
inline int C(int n,int m){
  return n<m||m<0?0:jc[n]*ni[m]%mod*ni[n-m]%mod;
}

inline int walk(int i,int j){
  return (C(n-i+n-j,n-i)+mod-C(n-1-i+n+1-j,n-1-i))%mod;
}
bool vis[N];
void work(){
  n=read();
  for(int i=1;i<=n;i++) a[i]=read(),vis[i]=0;
  int mx(0),sec(1);
  int ans(0);
  for(int i=1;i<=n;i++){
    vis[a[i]]=1;
    if(a[i]>mx) mx=a[i];
    else if(a[i]!=sec){
      add(ans,walk(mx+1,i-1));
      break;
    }
    while(vis[sec]) ++sec;

    add(ans,walk(mx+1,i-1));
  }
  printf("%lld\n",ans);
}

bool mem2;
signed main(){
#ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
#endif
  init(2e6);
  int T=read();
  while(T--) work();
  return 0;
}

```


---

## 作者：aaaaaaaawsl (赞：0)

前言：本人水平较差，在做这道题的时候查阅题解时很困难，每篇都只能看懂一点，因为有些东西题解默认会或者对最终形态影响不大就略过了，所以本篇尽可能详细的写，如果各位看到本身会的可以跳过。

-------------------------

### 题目大意

给定一个长度为 $n$ 的排列 $q$，求排列的个数，满足：

- 字典序大于给定排列。

- 对序列进行冒泡排序时没有多余操作（即操作个数达到下界）。

-------

### 题目分析

首先考虑第二个限制可以转化成哪种我们可以使用的形式。

没有多余操作也就是每一个数都只向目标位置方向走，不换向。

如果一个数前面有比它大的数，后面有比它小的数，那么它一定会和大的数交换而往前走一次，和小的数交换往后走一次，换向了一定代表是多余的。

所以第二个限制也就是要求一个排列，其中每个数不同时存在前面比他大的和后面比他小的，规范的说是该排列没有长度大于二的下降子序列，也就是由两个上升序列组成，这两个序列**不需要**连续。

根据第二条限制考虑构造一个序列，假设现在构造到了第 $i$ 位，数为 $a_i$，取 $mx = \max(a_1 ……a_i)$ 如果下一个放比 $mx$ 大的数，那么随便放，如果放一个比 $mx$ 小的数，那么必须放目前没放的最小的数。

这种构造方法一定符合限制。因为考虑如果放了一个数，和之前的某两个数构成长度为三的下降序列，那么中间那个数一定小于第一个数，那么在放中间那个数的时候就应该放最小的数，与第三个小于中间这个数矛盾。

接下来根据构造，用平常的思路，设 $f_{i,j}$ 为当前考虑第 $i$ 位，此时还未放置的，大于 $mx$ 的数有 $j$ 个。

初始为 $f_{0, n} = 1$，结束为 $f_{n, 0}$。

考虑状态转移，对于 $f_{i - 1, j'}$ 怎么转移到 $f_{i, j}$。

有构造可得，有两种情况：

1.放一个大于当前最大值的数，此时 $mx$ 变成 $a_i$，大于 $mx$ 的数有 $j = n - mx \in [j' - 1, 0]$ 个。即 $f_{i - 1, j'}$ 转移到 $f_{i, j} (j \in [j' - 1, 0])$。

2.放最小的数，$j$ 不变，即 $f_{i - 1, j'}$ 转移到 $f_{i, j'}$。

综合上述两种情况，即 $f_{i - 1, j'}$ 转移到 $f_{i, j'}(j \in [j', 0])$。

即 $f_{i, j} = \Sigma_{s=j}^{n}f_{i-1,s}$

考虑 $f_{i, j+1} = \Sigma_{s=j+1}^{n}f_{i-1,s}$

所以 $f_{i, j} = f_{i, j+1} + f_{i-1,j}$。

即前缀和优化，可以做到 $O(n^2)$。看着不习惯就把 $j$ 的定义反过来即可。

考虑第一个字典序限制，我们可以从第一位枚举，把最后的答案分成两部分，一是对于当前枚举的这一位，填比给定排列这一位更大的数的方案，二是填给定排列这一位上数的方案，考虑下一位的时候默认之前和给定排列一样，稍微想一下可以想出来这是可以不重不漏的包含所有方案的选法。

具体来说，对于 $f_{i,j}$，枚举 $i$，通过给定的排列限制 $j$ 的范围，根据之前求出的 $f$ 得到现在的 $f$ 累加到 $ans$ 里即可。

以上是 80pts 做法。

-------

### 优化

看状态转移方程 $f_{i, j} = f_{i, j+1} + f_{i-1,j}$，等效于走格子的时候，只能由 $(i, j + 1)$ 或 $(i - 1, j)$ 走到 $(i,j)$ 即向下向右走的方案数。再观察 $i, j$ 特性，对于一个状态 $i, j$，设 $i$ 位上的数为 $a_i$，此时 $j$ 为 $n-mx$，当 $mx = ai = i$ 时取得。

形象的理解是，对于某个随机的排列，在第 $i$ 位时 $j$ 能取得理论最大值只有排列为 $1,2,3,……n$，此时 $j = n-1, n-2, ……0$，对于其他形式的排列，第 $i$ 位 $j$ 的值只能对应的小于这些值，结合到走格子的思想上，只考虑第二限制，答案就是从点 $(0, n)$ 到 $(n, 0)$ 且不穿过直线 $y = -x + n$ 的最短路径方案数, 也就是 $Catalan$ 数。但是想到格子就行，由于第一个限制，这道题不完全是 $Catalan$ 数，不过用到了 $Catalan$ 数的计算思路。

在这里联想的时候注意，**一次转移不代表在格子上走了一步，而是由当前列转移到下一列。**

如何把格子这种形式优化上去呢？

看上文的最后做法，“对于 $f_{i,j}$,枚举 $i$，通过给定的排列限制 $j$ 的范围，根据之前求出的 $f$ 得到现在的 $f$ 累加到 $ans$ 里即可。”

和“对于其他形式的排列，第 $i$ 位 $j$ 的值只能对应的小于这些值。”

即求点 $(i,j-1∼0)$ 到 $(n,0)$ 的路径数量之和，其实就相当于 $(i-1,j-1)$ 到 $(n,0)$ 的路径数量。(上一列可以往下走到 $i-1, j-1∼0$)，同时为不穿过直线 $y=-x+n$ 的最短路径数量。

对于 $(i,j)$ 到 $(n, 0)$ 的路径数量为 $C(n - i + j, j)$。

把 $(i, j)$ 关于直线 $y=-x+n-1$ 对称，易得其坐标为 $(n-j+1,n-i+1)$，可以发现，$(i, j)$ **穿过**直线 $y=-x+n$ 的最短路径数量。就等于 $(n-j+1,n-i+1)$ 到 $(n, 0)$ 的最短路径数量。

于是 $(i, j)$ 的贡献为 $C(n-i+j,j)-C(n-i+j,n-i+1)$。

总算法流程是:

1.枚举 $i$。

2.由给出的排列得出 $j$ 的范围。

3.把 $i, j$ 看做点的坐标，把 $i-1, j-1$ 带入式子统计答案。

-------

### 代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define Mod 998244353ll

using namespace std;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

const int N = 2000001;

int T, n, ans;
int mul[N], inv[N];
int arr[N];
int vis[N]; 

void init(){
	mul[1] = inv[1] = inv[0] = 1;
	for(int i = 2; i <= 2000000; ++ i) {
		inv[i] = 1ll * (((-(Mod / i) * inv[Mod % i]) % Mod) + Mod) % Mod;
		mul[i] = 1ll * mul[i - 1] * i % Mod;
	}
	for(int i = 2; i <= 2000000; ++ i) inv[i] = 1ll * inv[i] * inv[i - 1] % Mod; // 预处理阶乘逆元O1求组合数 
}

int C(int n, int m){ // n! * (1/m!) * (1/(n-m)!
	return ((n < m) ? 0 : (1ll * mul[n] % Mod * inv[m] % Mod * inv[n-m] % Mod));
}

void clear(){
	memset(vis, 0, sizeof vis);
	ans = 0;
}

signed main(){
	init();
	T = read();
	while(T --){
		n = read();
		if(n == 0) {printf("0\n"); continue;}
		clear();
		for(int i = 1; i <= n; ++ i) arr[i] = read();
		int j = n, mi = 1, s = -1; // 可以在下一位随便填的数的个数，最小值 
		for(int i = 1; i <= n; ++ i){
			int g = n - arr[i];
			if(g < j) j = g, s = g, vis[arr[i]] = 1;
			else if(arr[i] == mi) s = j, vis[arr[i]] = 1;
			else s = j, j = -1;
			if(s != -1) ans = 1ll * (((ans + C(n - (i - 1) + (s - 1), (s - 1)) - C(n - (i - 1) + (s - 1), n - (i - 1) + 1)) % Mod) + Mod) % Mod;
			while(vis[mi]) mi ++;
		}
		printf("%d\n", ans);
	}
} 
```

---

## 作者：AzusaCat (赞：0)

我们先来考虑，好的排列满足什么性质。不难发现，如果这个排列的最长下降子序列长度大于 2，那么这个排列一定不是好的排列，设不满足的 3 个数为 $c,b,a(c>b>a)$，那么 $c$ 要移到 $b$ 的右面，一定会和 $b$ 交换一次，然后 $a$ 和 $c$ 再交换一次，这时变成了 $b,a,c$，还需要额外交换一次。现在我们再来证明一下这个条件也是充分条件：

我们发现，如果要保证这个排列是好的排列，我们改变任何一个数的位置的时候，都需要让它往它应该在的位置移动，也就是说，如果 $p_i<i$，那么 $p_i$ 一定只会向左移动，$p_i>i$ 同理，当 $p_i=i$ 时，这个位置不能移动，反之，如果不是好的排列，至少有一次交换使得某一个数距离它应该在的位置变远了。

考虑任何一次交换，设我们交换的数为 $p_i$ 和 $p_{i+1}$，那么我们有 $p_i>p_{i+1}$，由不存在长度为 3 的下降子序列我们可知 $p_1\dots p_{i-1}<p_i$，$p_{i+2}\dots p_n>p_{i+1}$，这样就有 $p_{i+1}<i+1$，$p_i>i$，故这一次交换两个数都往应该走的方向走了，显然这样的交换不会增加最长下降子序列的长度。 

这样我们就证明了不存在长度为 3 的最长下降子序列是好的排列的充要条件。



现在我们考虑计算方案数。我们先忽略字典序的限制，即让 $p_i=i$，设 $f(i,j)$ 为填了前 $i$ 个位置，填过的最大的数为 $j$ 的方案数，我们先给出递推式：
$$
f(i,j)=\sum\limits_{k=i-1}^jf(i-1,k)
$$
这个的意思是，如果我们现在填的数比之前都大，显然不会造成影响，所以可以任意填一个比当前最大值大的数；如果我们现在填的数比之前小，那么一定只能填没有填过的最小的数，因为如果填了一个不是最小的数，迟早要把最小的数填上，这样就构成了一个长度为 3 的下降子序列。不难证明按照这样填也一定不会出现长度为 3 的下降子序列（考虑反证，第三个数一定是最小的数转移的，如果在之前已经存在了长度为 2 的下降子序列，那说明填第二个数的时候填的不是当前最小值）。

然后我们可以改写一下 dp 的转移方程。
$$
f(i,j)=f(i,j-1)+f(i-1,j)
$$
且 $f(i,j)=0,j<i$。

我们发现，这等价于在平面直角坐标系中，只能向右或向上走，从 $(0,0)$ 走到 $(i,j)$，且一直在直线 $y=x$ 上方的方案数。我们要求的是 $f(n,n)$，这个的方案数便是卡特兰数 $C_n$。



现在我们要把字典序的限制加上，经典的处理方法是枚举实际排列和要求排列的 LCP。我们假定在第 $i$ 位实际排列和要求排列不同，那么我们这一位一定比之前大。设从第 $i+1$ 位开始不同，前 $i$ 位中最大值为 $mx$，那么方案数就是 $(i-1,mx+1)$ 到 $(n,n)$ 一直在 $y=x$ 下方的方案数。这实际上是卡特兰数的一个扩展，可以发现所有跨过 $y=x$ 的路径都经过了 $y=x-1$，所以对这些路径关于 $y=x-1$ 对称，这样就等价于 $(i-1,mx+1)$ 到 $(n+1,n-1)$ 的方案数，这样的总方案数为 $\dbinom{2n-i-mx}{n-i+1}-\dbinom{2n-i-mx}{n-i+2}$。

需要注意的是如果给定的排列某一位比前缀最大值小，而且这一位并不是剩余的最小值，这样后面全部不合法，需要直接 `break` 掉。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int const p=998244353;
int pw(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1)res=1ll*res*x%p;
        x=1ll*x*x%p;
        y>>=1;
    }
    return res;
}
int fac[1200005],inv[1200005],r[1200005],mx[1200005],mn[1200005];
int c(int n,int m)
{
    return 1ll*fac[n]*inv[m]%p*inv[n-m]%p;
}
int main()
{
    fac[0]=inv[0]=1;
    for(int i=1;i<=1200000;i++)fac[i]=1ll*fac[i-1]*i%p;
    inv[1200000]=pw(fac[1200000],p-2);
    for(int i=1199999;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%p;
    int _;
    scanf("%d",&_);
    while(_--)
    {
        int n,mx=0,ans=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&r[i]);
        mn[n]=r[n];
        for(int i=n-1;i>=1;i--)mn[i]=min(mn[i+1],r[i]);
        for(int i=1;i<=n;i++)
        {
            mx=max(mx,r[i]);
            ans+=(1ll*c(2*n-i-mx,n-i+1)-c(2*n-i-mx,n-i+2)+p)%p;
            ans%=p;
            if(r[i]<mx&&r[i]!=mn[i])break;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---


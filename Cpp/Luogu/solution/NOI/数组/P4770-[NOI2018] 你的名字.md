# [NOI2018] 你的名字

## 题目背景

实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。

## 题目描述

小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。

由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。

由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。

由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 2

见附加文件中的 `name2.in` 与 `name2.ans`。

### 数据范围

::cute-table{tuack}

|测试点|$\vert S\vert \leq$　|$Q\leq $　|$\sum \vert T\vert \leq $ |询问限制　|其他限制|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$200$|$200$|$40000$|对于所有询问有 $l = 1, r=\vert S\vert$|$T\leq 200$|
|$2$|$1000$|^|^|^|^|
|$3$|^|^|^|^|^|
|$4$|^|^|$5 \times 10^5$|^|无|
|$5$|^|^|^|^|^|
|$6$|$5 \times 10^5$|$1$|^|^|^|
|$7$|^|^|^|^|^|
|$8$|$10^5$|$10^5$|$2 \times 10^5$|^|^|
|$9$|^|^|^|^|字符串随机|
|$10$|$2 \times 10^5$|^|$4 \times 10^5$|^|无|
|$11$|^|^|^|^|字符串随机|
|$12$|$3 \times 10^5$|^|$6 \times 10^5$|^|无|
|$13$|^|^|^|^|字符串随机|
|$14$|$4 \times 10^5$|^|$8 \times 10^5$|^|无|
|$15$|^|^|^|^|字符串随机|
|$16$|$5 \times 10^5$|^|$10^6$|^|无|
|$17$|^|^|^|^|字符串随机|
|$18$|$2 \times 10^5$|^|^|无|无|
|$19$|$3 \times 10^5$|^|^|^|^|
|$20$|$4 \times 10^5$|^|^|^|^|
|$21$|$5 \times 10^5$|^|^|^|^|
|$22$|^|^|^|^|^|
|$23$|^|^|^|^|^|
|$24$|^|^|^|^|^|
|$25$|^|^|^|^|^|

对于所有数据，保证 $1\leq l \leq r \leq |S|$，$1\leq |T|\leq 5 \times 10^5$

感谢 @Wen_kr 提供的一组 hack 数据。

## 样例 #1

### 输入

```
scbamgepe
3
smape 2 7
sbape 3 8
sgepe 1 9```

### 输出

```
12
10
4```

# 题解

## 作者：shadowice1984 (赞：93)

显然这种后缀自动机duliu题几句话是说不清的……

所以我们还是来慢慢分析这题的性质好了

____________________

### 前置芝士:后缀自动机(sam)

蛤？做noi的字符串题不会sam,建议出门左转你站模板区学习一下

### 前置芝士:线段树合并

很多题目都是后缀自动机和线段树合并套在一起进行的，这是因为线段树合并这个算法可以很方便的维护后缀自动机的right集合，如果你不会线段树合并的话，可以翻一翻往期的咕咕日报，有非常详细的讲解

不过值得注意的是这道题用的线段树合并和大家惯用的合并写法不是很一致，后面会具体讲这部分内容

_____________________

# 本题题解

先来重新描述一下模糊不清的题意

给定一个模板串$S$,多组询问,每次给出一个询问字符串$T$和一个区间$(l,r)$

要求你输出$T$有多少个**本质不同**的子串,满足这个子串没有在S的$(l,r)$这段区间当中出现

然后我们接着转化一波就是询问你有几个T的本质不同的子串满足这个子串在$S$的给定区间当中出现了，然后我们求出这个东西之后拿T的所有本质不同子串去减就能得到答案了(如果连求T本质不同子串数目这点都不会的建议重新学一遍sam)

对于这题来讲我们先来考虑几个比较特殊的部分分再来解决最后的问题会比较有效，所以让我们一个部分分一个部分分的解决这题

## Case1:$l=1,r=|S|$

这样的话我们可以先对字符串$S$建一个后缀自动机然后对询问串$T$建一个后缀自动机，由于$T$的总长不是特别长因此我们的复杂度是对的

接下来为了做这道题我们需要知道一个知识，就是给定一个模板串$S$和一个匹配串$T$，现在我们希望对于$T$的每一个前缀$(1,i)$求出一个最长的字符串P，满足P是$(1,i)$的后缀并且$P$是S的子串

通俗点说就是把$T$放到$S$上去跑匹配

那么其实这个东西也十分的简单，我们仔细观察一下parent树的性质就会发现parent树的性质和ac自动机的fail树性质相当的像，甚至我们可以说sam其实就是把一个字符串的所有子串抽出来建了一个ac自动机

那么我们向前添加一个字符的时候只需要看sam上对应的节点有没有对应的出边:

如果有对应的出边我们直接走上去并且让匹配长度+1,

否则我们**不停的跳parent树**直到parent树上一个节点有对应的出边为止，此时我们把匹配长度更新为parent树上节点len值+1。

如果跳到了根依然失配那么我们将匹配长度更新为0

这样我们就求出了$T$的每一个前缀的匹配长度了

那么我们有了这个匹配长度之后有什么用呢？

我们在T的后缀自动姬的每一个节点上维护一个ans值表示这个节点的最长合法长度,

解释一下ans的含义就是这样

我们知道给定一个后缀自动机节点再给定一个字符串长度可以唯一确定一种本质不同子串,那么一个节点的ans值就表示所有长度小于ans并且也被这个节点表示的字符串都是S的子串

我们在S的后缀自动机上跑匹配的同时我们也在T的后缀自动机上跑T这个串,并且每次匹配串的长度减小的时候我们在T的parent树上跳直到这个节点的len值变的合法,然后用当前匹配的长度去更新这个点到根路径上节点的ans值

显然暴力跳链复杂度是假的，但是我们发现当一个点的ans值等于len值的时候这个节点的祖先的ans值也全部等于len值，因此我们暴力跳链如果这个点的ans值等于len我们就停止跳链，这样复杂度就真了

最后的答案就是所有点ans值-父亲的len值之和了，当然由于我们做了个补集转化还要用本质不同的子串数目减去我们求出的数才能输出

### Case2:l,r任意

我们发现其实我们只要知道$(l,r)$这段区间的后缀自动机长什么样就可以直接执行上面的算法了，但是问题是我们没有办法轻松的得知一个区间的后缀自动机

但是仔细想想我们上面算法流程真的需要后缀自动机本身吗？

其实并不是，我们只是借助S的后缀自动机求出了T的每个前缀的匹配长度

我们在$L=1,r=|S|$所用的算法仅仅对S的后缀自动机执行了这样几个操作

1.检查S的一个节点是否有某一个字符的出边，如果有那就转移上去

2.跳parent树

3.读取一个节点的len值

换句话说我们如果能够实现上面几个操作，并且保证我们读取的len值是这个节点在以$(l,r)$这个区间为模板串意义下的len,转移到的节点也是这个节点在$(l,r)$意义下的出边，我们的算法就还是对的

现在我们来考虑如何实现这几个操作

我们使用线段树合并来维护每一个后缀自动机节点的right集合，线段上维护的是区间最大值

当我们判断是否存在一条在$(l,r)$意义下指向p的转移边的时候，我们只需要查找节点p的righ集合在$(1,r)$的区间最大值然后和l进行比较如果这个最大值比$l$小就证明这个转移边在$(l,r)$作为模板串的时候并不合法，不能进行转移

同样的，当我们读取一个节点的len值的时候我们还是找出$(1,r)$的区间最大值,在$(l,r)$作为模板串的意义下，这个节点的len值应该是$\min(len,l-maxpos(1,r)+1)$

至于跳parent树的过程，我们仔细研究一下parent树的定义就会发现其实在整个大的后缀自动机上跳就肥肠符合我们的需要了，所以跳原来后缀自动机上的parent树即可

然后我们发现这里的线段树合并和我们平常写的可能不是很一样，平常我们合并两个线段树的时候是将某一个线段树插入到另一个线段树里，然后我们一般的套路是一边在树上dfs一边合并线段树，然后当我们dfs到节点u的时候我们就get到u子树中的信息

那么我们会发现当我们按照平常的线段树合并算法合并两个线段树u和v的时候原来的两个线段树都会**被销毁**

您可能一开始像我一样naive的认为我们在线段树合并的时候是把u的一些孩子指针指向了v线段树，所以被销毁的只有u线段树而没有v线段树

然鹅这种想法是相当错误的，当我们合并了u和v之后v的一些节点就成为了u线段的一部分，如果此时我们把u和另外一个线段树v'合并,那么同时属于u和v的线段树节点就会被修改，此时v就相当于被销毁了

为了避免这种尴尬的情况发生(显然如果出现这个bug你会看着线段树合并的代码挠半天头而依然不知所措，并且小数据你有很大的概率wa不了)我们需要将线段树合并的过程**可持久化**

具体来讲每次我们需要修改u节点的孩子指针的时候我们新开一个节点然后把这个节点的孩子指针指向合并左子树和右子树产生的节点，这样我们就保留了每一个版本的线段树，此时我们就可以读取任意一个节点的right集合了~

代码的话不是很好写，细节也比较多，请注意封装和细节的分类讨论

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e6+10;typedef long long ll;char mde[N];int n;int nl;int nr;int m;
struct suffixautomaton//简易后缀自动机板子 
{
    int mp[N][27];int ct;int fa[N];int len[N];int n;
    inline int& operator [](const int& x){return len[x];}
    inline void ih(int x){n=x;for(int i=1;i<=n;i++)len[i]=i;ct=n+1;}
    inline void clr()
    {
        for(int i=1;i<=ct;i++)for(int j=1;j<=26;j++)mp[i][j]=0;
        for(int i=1;i<=ct;i++)fa[i]=0;for(int i=1;i<=ct;i++)len[i]=0;
    }
    inline void ins(int x,int c)
    {
        int p=(x==1)?n+1:x-1;for(;p&&mp[p][c]==0;p=fa[p])mp[p][c]=x;
        if(p==0){fa[x]=n+1;return;}int q=mp[p][c];
        if(len[q]==len[p]+1){fa[x]=q;return;}len[++ct]=len[p]+1;
        for(int i=1;i<=26;i++)mp[ct][i]=mp[q][i];
        for(;p&&mp[p][c]==q;p=fa[p])mp[p][c]=ct;fa[ct]=fa[q];fa[q]=fa[x]=ct;
    }
};
namespace SM
{
    suffixautomaton sam;int s[40*N][2];int va[40*N];int cnt;
    int v[N];int x[N];int al[N];int ct;
    inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
    # define mov(p,c) (p=sam.mp[p][c])
    # define jup(p) (p=sam.fa[p])
    inline void ins(int p,int l,int r,int pos) 
    {
        va[p]=pos;if(r-l==1){return;}int mid=(l+r)/2;
        if(pos<=mid)ins(s[p][0]=++cnt,l,mid,pos);else ins(s[p][1]=++cnt,mid,r,pos);
    }
    inline int mg(int p1,int p2,int isr)//这里的合并是可持久化的，不会销毁任意一颗线段树 
    {
        int nw=(isr)?p1:++cnt;
        if(s[p1][0]&&s[p2][0])s[nw][0]=mg(s[p1][0],s[p2][0],0);
            else s[nw][0]=(s[p2][0])?s[p2][0]:s[p1][0];
        if(s[p1][1]&&s[p2][1])s[nw][1]=mg(s[p1][1],s[p2][1],0);
            else s[nw][1]=(s[p2][1])?s[p2][1]:s[p1][1];
        va[nw]=max(va[s[nw][0]],va[s[nw][1]]);return nw;
    }
    inline int qry(int p,int l,int r,int dl,int dr)//查询区间最大值 
    {
        if((p==0)||(dl==l&&r==dr))return va[p];int mid=(l+r)/2;int res=0;
        if(dl<mid)res=max(res,qry(s[p][0],l,mid,dl,min(dr,mid)));
        if(mid<dr)res=max(res,qry(s[p][1],mid,r,max(dl,mid),dr));
        return res;
    }
    inline void dfs(int u){for(int i=al[u];i;i=x[i])dfs(v[i]),mg(u,v[i],1);}
    inline void build()
    {
        sam.ih(n);for(int i=1;i<=n;i++)sam.ins(i,mde[i]-'a'+1);
        cnt=sam.ct;for(int i=1;i<=sam.ct;i++)add(sam.fa[i],i);
        for(int i=1;i<=n;i++)ins(i,0,n,i);dfs(n+1);
    }
    inline void trs(int& p,const int& c,int& len)//暴力跳fail树进行转移 
    {
        for(;p!=n+1;jup(p),len=sam[p])
            if(sam.mp[p][c])
            {
                int mle=qry(sam.mp[p][c],0,n,0,nr)-nl+1;
                if(sam[sam.fa[p]]<mle){len=min(len+1,mle);mov(p,c);return;}
            }
        if(p==n+1&&(sam.mp[p][c]==0||qry(sam.mp[p][c],0,n,0,nr)<nl)){len=0;return;}
        mov(p,c);len++;
    }
    # undef mov
    # undef jup
}
namespace SM2
{
    suffixautomaton sam;char mde[N];int le;
    int v[N];int x[N];int al[N];int ct;int mx[N];
    inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
    # define mov(p,c) (p=sam.mp[p][c])
    # define jup(p) (p=sam.fa[p])
    inline void build()
    {
        for(int i=1;i<=sam.ct;i++)al[i]=0;ct=0;sam.clr();scanf("%s",mde+1);
        scanf("%d%d",&nl,&nr);le=1;for(;mde[le+1]!='\0';le++);sam.ih(le);
        for(int i=1;i<=le;i++)sam.ins(i,mde[i]-'a'+1);
        for(int i=1;i<=sam.ct;i++)add(sam.fa[i],i),mx[i]=sam[sam.fa[i]];
    }
    inline void aju(int p,const int& lim)//打标记 
    {
        for(;p!=le+1&&sam[sam.fa[p]]>=lim;jup(p));
        for(;p!=le+1&&sam[p]>mx[p];jup(p))mx[p]=max(mx[p],min(sam[p],lim));
    }
    inline ll dfs(int u)
    {ll ret=0;for(int i=al[u];i;i=x[i])ret+=mx[v[i]]-sam[u]+dfs(v[i]);return ret;}
    inline ll dfs2(int u)
    {ll ret=0;for(int i=al[u];i;i=x[i])ret+=sam[v[i]]-sam[u]+dfs2(v[i]);return ret;}
    inline void solve(int z)
    {
        for(int i=1,p1=n+1,p2=le+1,nle=0;i<=le;i++)
            mov(p2,mde[i]-'a'+1),SM::trs(p1,mde[i]-'a'+1,nle),aju(p2,nle);
        printf("%lld\n",dfs2(le+1)-dfs(le+1));
    }
    # undef mov
    # undef jup
}
int main()
{
    scanf("%s",mde+1);for(n=1;mde[n+1]!='\0';n++);SM::build();scanf("%d",&m);
    for(int i=1;i<=m;i++)SM2::build(),SM2::solve(i);return 0;//拜拜程序~ 
}
```






















---

## 作者：mrsrz (赞：56)

来一发后缀数组的~~大常数~~写法。

我们考虑对于一个询问，先求出$T$中本质不同的子串个数，然后减去是$S(l,r)$子串的。

本质不同的子串个数，直接用height数组的性质就可以求。具体见2408那题。

我们考虑，对于$T$的每一个后缀，求出其最长的前缀长度$L$，使得该后缀长度为$L$的前缀是$S(l,r)$的子串。

把$S$和所有$T$连起来建后缀数组。为了方便计算每个询问，我们用链表的方法，记录每个位置在同一个串中的前驱后继。

然后我们**按顺序**考虑$T$的每一个后缀。

如果$a$位置的后缀的满足条件的最长前缀为$L$,，则$a+1$位置的至少为$L-1$。原理和求height数组相同，两边都同时去掉第一个字符，至少还留下$L-1$。

所以考虑每个位置的话，用双指针扫描一下即可。

然后，假如我们现在考虑位置$a$的长度为$L$的前缀是否可行，就是相当于在$S$的$[l,r-L+1]$内找一个位置$b$，满足$LCP(a,b)\geqslant L$。

满足$LCP(a,b)\geqslant L$条件的在后缀数组上的区间$[ll,rr]$，可以二分，配合height数组的ST表在$O(\log n)$的时间内求出。

然后问题转化为询问在后缀数组上的区间$[ll,rr]$内，是否存在一个在$S$的$[l,r-l+1]$中的字符。这个问题可以用建主席树然后询问，单次查询时间复杂度$O(\log n)$。

对于一个位置，它与后缀数组上一个位置可能会算重，所以要减掉它们的$LCP$。由于两个位置可能不连续，这部分也要用ST表来查。

所以总时间复杂度$O(n\log n)$。$n=|S|+\sum|T|$。

常数巨大，几乎卡着时限过的QAQ。

## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 500505
#define M 1800505
#define reg register
#define lg2(x)(31-__builtin_clz(x))
typedef long long LL;
int n,sa[M],height[M],x[M],s[M],mgk,bel[M],m,QL[N],QR[N],y[M],st[22][M],nxt[M],head[N],node=0,rt[M],pp[M],len[N];
int ls[M*20],rs[M*20],sz[M*20];
char ss[N];
bool isk;
int _L,_R;
void add(int&o,int pr,int l,int r,int pos){
	sz[o=++node]=sz[pr]+1;
	if(l<r){
		const int mid=l+r>>1;
		if(pos<=mid)add(ls[o],ls[pr],l,mid,pos),rs[o]=rs[pr];else add(rs[o],rs[pr],mid+1,r,pos),ls[o]=ls[pr];
	}
}
void sort(){
	int m=mgk,c[M];
	for(int i=1;i<=m;++i)c[i]=0;
	for(int i=1;i<=n;++i)++c[x[i]=s[i]];
	for(int i=1;i<=m;++i)c[i]+=c[i-1];
	for(int i=n;i;--i)sa[c[x[i]]--]=i;
	for(int k=1,p;k<=n;k<<=1){
		p=0;
		for(int i=n-k+1;i<=n;++i)y[++p]=i;
		for(reg int i=1;i<=n;++i)if(sa[i]>k)y[++p]=sa[i]-k;
		for(reg int i=1;i<=m;++i)c[i]=0;
		for(reg int i=1;i<=n;++i)++c[x[i]];
		for(reg int i=1;i<=m;++i)c[i]+=c[i-1];
		for(reg int i=n;i;--i)sa[c[x[y[i]]]--]=y[i];
		std::swap(x,y);
		x[sa[1]]=p=1;
		for(int i=2;i<=n;++i)
		x[sa[i]]=y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]?p:++p;
		if(p==n)break;
		m=p;
	}
	for(int i=1,k=0;i<=n;++i)
	if(x[i]>1){
		k-=!!k;
		const int j=sa[x[i]-1];
		while(s[i+k]==s[j+k])++k;
		height[x[i]]=k;
	}
}
inline int find(int l,int r){
    if(l>r)return n;
    const int lg=lg2(r-l+1);
    return std::min(st[lg][l],st[lg][r-(1<<lg)+1]);
}
void init(){
	for(reg int i=1;i<=n;++i)st[0][i]=height[i];
    for(int i=0;i<21;++i)
    for(reg int j=1;j<=n;++j)
    if(j+(1<<i)<=n)st[i+1][j]=std::min(st[i][j],st[i][j+(1<<i)]);else break;
    int pre[N];
    memset(pre,0,sizeof pre);
    for(int i=1;i<=n;++i)
    if(s[sa[i]]<='z'){
    	if(pre[bel[sa[i]]])
    	nxt[pre[bel[sa[i]]]]=i,pp[i]=pre[bel[sa[i]]];else head[bel[sa[i]]]=i;
    	pre[bel[sa[i]]]=i;
    }
}
void query(const int&ri,const int&le,int l,int r){
	if(sz[ri]==sz[le]||isk)return;
	if(_L<=l&&r<=_R)return(void)(isk=1);
	const int mid=l+r>>1;
	if(_L<=mid)query(ls[ri],ls[le],l,mid);
	if(mid<_R&&!isk)query(rs[ri],rs[le],mid+1,r);
}
bool check(int pos,int len,int l,int r){
	int L,ll,rr;
	ll=1,rr=pos-1;
	while(ll<=rr){
		const int mid=ll+rr>>1;
		if(find(mid+1,pos)>=len)rr=mid-1;else ll=mid+1;
	}
	L=rr;
	ll=pos+1,rr=n;
	while(ll<=rr){
		const int mid=ll+rr>>1;
		if(find(pos+1,mid)>=len)ll=mid+1;else rr=mid-1;
	}
	isk=0;
	_L=l,_R=r;
	query(rt[ll-1],rt[L],1,n);
	return isk;
}
int main(){
	memset(bel,-1,sizeof bel);
	mgk='z'+1;
	scanf("%s",ss);
	for(int i=0;ss[i];++i)
	s[++n]=ss[i],bel[n]=0;
	s[++n]=mgk++;
	scanf("%d",&m);
	for(int i=1;i<=m;++i){
		scanf("%s%d%d",ss,QL+i,QR+i);
		for(int j=0;ss[j];++j)
		s[++n]=ss[j],bel[n]=i;
		len[i]=n;
		s[++n]=mgk++;
	}
	sort();
	init();
	for(reg int i=1;i<=n;++i)
	if(!bel[sa[i]])add(rt[i],rt[i-1],1,n,sa[i]);else rt[i]=rt[i-1];
	for(int i=1;i<=m;++i){
		LL ans=len[i]-sa[head[i]]+1;
		int mnid=sa[head[i]];
		for(int j=nxt[head[i]];j;j=nxt[j]){
			ans+=len[i]-sa[j]+1;
			ans-=find(pp[j]+1,j);
			mnid=std::min(mnid,sa[j]);
		}
		for(int j=mnid,L=mnid;s[j]<='z';++j){
			if(L<j)L=j;
			while(s[L]<='z'&&check(x[j],L-j+1,QL[i],QR[i]-L+j))++L;
			if(x[j]!=head[i])ans-=std::max(L-j-find(pp[x[j]]+1,x[j]),0);else
			ans-=L-j;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：bztMinamoto (赞：41)

更好的阅读体验->[这里](https://www.cnblogs.com/bztMinamoto/p/9682480.html)

我有种自己根本没学过SAM的感觉……最后还是抄了老半天的题解……

首先，对$S$和每一次的$T$都建一个SAM

先考虑一下$l=1,r=\left| S \right|$的情况

设$lim_i$表示字符串$T[1..i]$能在$S$中匹配到的最长后缀（即$T[i-lim_i+1,i]$是$S$的子串且$lim_i$最大）（有可能不存在这个字符那么$lim_i=0$）

这个$lim_i$可以不断地在$S$的后缀自动机上跳来求出。当无法向下匹配时，一直跳parent树直到可以匹配为止

我们假设对于$T$的后缀自动机，每一个节点的$endpos$集合中所能代表的最长的字符串长度为$l_i$，$tag_i$表示该集合字符串第一次出现的结尾位置（因为集合里字符串互为后缀所以结尾相同），$fa_i$表示parent树上的父亲，$cnt$表示自动机节点总个数

那么答案就是$$ans=\sum_{i=2}^{cnt}max(0,l_i-max(l_{fa_i},lim_{tag_i}))$$

ps：这里的lim指的并不是上文的lim而是最长后缀的长度

上面式子的意思是，对于每一个节点，它不属于$S$的子串的总个数为当前节点代表的集合字符串个数减去与$S$有匹配的子串个数

然后只要在$T$的后缀自动机上枚举每一个节点就可以了

现在来考虑$l$和$r$任意的情况该怎么做

这个时候就要用线段树维护后缀自动机的$endpos$集合了（不明白这个怎么做的我简单说一下，就是搞一个动态开点线段树，如果一个节点的$endpos$集合里有某一个位置就把它加入以该点为根的树中，parent树上父亲节点的$endpos$集合必然包含儿子的$endpos$集合所以将每个点的$endpos$集合与它儿子的合并。然后查询这个节点是否有$endpos$位于某个区间中只要在线段树上查询看看这个区间代表的节点是否被开出来过就好了（因为线段树上只有存在的位置的节点被开出来过））

我们在处理$lim_i$集合的时候要注意，要判断当前节点是否在$S[l..r]$区间中出现过。设$p$为当前在$S$的自动机上跑到的节点，$len$表示匹配了$[i-len+1..i]$，因为要看能否转移到下一个节点，所以要匹配$[i-len,i]$，且$[l+len,r]$中有后继节点的$endpos$存在才行（可能说的烦了点，仔细想想为什么）

差不多就这样
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x){
    if(C>1<<20)Ot();
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e6+5,M=2e7+5,inf=0x3f3f3f3f;
int q,n,m,rt[N],lim[N];char S[N];ll ans;
namespace tree{
	int cnt,L[M],R[M];
	void ins(int &p,int l,int r,int x){
		if(!p) p=++cnt;
		if(l==r) return;
		int mid=(l+r)>>1;
		if(x<=mid) ins(L[p],l,mid,x);
		else ins(R[p],mid+1,r,x);
	}
	int merge(int x,int y){
		if(!x||!y) return x+y;
		int p=++cnt;
		L[p]=merge(L[x],L[y]);
		R[p]=merge(R[x],R[y]);
		return p;
	}
	bool query(int p,int l,int r,int ql,int qr){
		if(!p||ql>qr) return false;
		if(ql<=l&&qr>=r) return true;
		int mid=(l+r)>>1;
		if(ql<=mid&&query(L[p],l,mid,ql,qr)) return true;
		if(qr>mid&&query(R[p],mid+1,r,ql,qr)) return true;
		return false;
	}
}
namespace SAM{
	int cnt=1,last=1;
	int ch[N][26],l[N],fa[N],c[N],a[N],in[N];
	void ins(int c){
		int p=last,np=++cnt;last=np,l[np]=l[p]+1,in[np]=1;
		for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=np;
		if(!p) fa[np]=1;
		else{
			int q=ch[p][c];
			if(l[q]==l[p]+1) fa[np]=q;
			else{
				int nq=++cnt;l[nq]=l[p]+1;
				memcpy(ch[nq],ch[q],sizeof(int)*(26));
				fa[nq]=fa[q],fa[q]=fa[np]=nq;
				for(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
			}
		}
	}
	inline void calc(){
		for(int i=1;i<=n;++i) ins(S[i]-'a');
		for(int i=1;i<=cnt;++i) ++c[l[i]];
		for(int i=1;i<=cnt;++i) c[i]+=c[i-1];
		for(int i=1;i<=cnt;++i) a[c[l[i]]--]=i;
		for(int i=cnt,p;i;--i){
			p=a[i];
			if(in[p]) tree::ins(rt[p],1,n,l[p]);
			rt[fa[p]]=tree::merge(rt[fa[p]],rt[p]);
		}
	}
}
namespace solve{
	int cnt=1,last=1;
	int ch[N][26],l[N],fa[N],c[N],a[N],tag[N];
	inline void init(){
		cnt=last=1,memset(ch[1],0,sizeof(int)*(26));
	}
	inline int newnode(){
		++cnt;memset(ch[cnt],0,sizeof(int)*(26));return cnt;
	}
	void ins(int c){
		int p=last,np=newnode();last=np,tag[np]=l[np]=l[p]+1;
		for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=np;
		if(!p) fa[np]=1;
		else{
			int q=ch[p][c];
			if(l[q]==l[p]+1) fa[np]=q;
			else{
				int nq=newnode();l[nq]=l[p]+1,tag[nq]=tag[q];
				memcpy(ch[nq],ch[q],sizeof(int)*(26));
				fa[nq]=fa[q],fa[q]=fa[np]=nq;
				for(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
			}
		}
	}
	ll solve(){
		int L,R;
		scanf("%s%d%d",S+1,&L,&R);
		init();
		m=strlen(S+1);
		for(int len=0,p=1,i=1;i<=m;++i){
			int c=S[i]-'a';
			ins(c);
			while(true){
				if(SAM::ch[p][c]&&tree::query(rt[SAM::ch[p][c]],1,n,L+len,R)){
					++len,p=SAM::ch[p][c];break;
				}
				if(len==0) break;
				--len;
				if(len==SAM::l[SAM::fa[p]]) p=SAM::fa[p];
			}
			lim[i]=len;
		}
		ans=0;
		for(int i=2;i<=cnt;++i)
		ans+=max(0,l[i]-max(l[fa[i]],lim[tag[i]]));
		return ans;
	}
}
int main(){
//	freopen("testdata.in","r",stdin);
	scanf("%s",S+1);
	n=strlen(S+1);
	SAM::calc();
	scanf("%d",&q);
	while(q--) print(solve::solve());
	Ot();
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：31)

题解里好像都是线段树合并

这里提供一个转化为二维偏序问题然后只用一棵线段树维护的做法

感谢**E_Space**在FJ冬令营的讲解

后缀自动机的**匹配**：**找T的所有前缀中最长的是S子串的后缀**

**双指针扫描法**：

“比如对于T的第i个前缀，匹配的状态为x
设c为T的第i+1个字符
如果xc是S的子串，那么显然T的第i+1个前缀最长的（是S的子串的）后缀是xc
这同时意味着x所在节点有关于c的转移边
于是你只需要将x沿着这条边走一步，再将其长度加上1即可
否则说明T的第i+1个前缀最长的（是S的子串的）后缀比xc短
考虑不断删去xc的首字符，直到它是S的子串为止
这也相当于**不断删去x的首字符，直到它有c的转移边为止**，当然要注意特判删到空以后仍然没有c的转移边的情况
在删首字符的时候注意判断是否要跳到所在节点的父亲，当然你也可以把删去首字符改成**直接跳父亲并修改当前串长度为父亲的len**来节省常数”

——摘自Espace课件

弱化版问题：

**求S和T有多少个本质不同的非空公共子串**

考虑枚举T的每个本质不同的子串询问其是否是S的子串

“先建出T的后缀自动机，然后考虑每个节点接受的字符串中有哪些是S的子串

由于一个节点接受的字符串都是某个子串的后缀，所以我们可以找到这些字符串在T中的一个右端点（即节点的at），然后查询一下T的长度为at的前缀最长的（是S的子串的）后缀的长度len

这样我们就可以知道T的以at为右端点的子串中长度不超过len的都是S的子串，长度大于len的都不是S的子串

于是我们就可以把(0,len]和节点接受字符串长度的区间（即(父亲的max,自己的max]）的交中的整数个数计入答案

至于如何求len，只要预处理的时候建出S的自动机，用T在上面跑一遍就可以了”

——摘自E_Space课件

### [NOI2018]你的名字：

**给定S(Len(S)<=5e5),Q(Q<=1e5)次询问(T,l,r)求T(∑Len(T)<=1e6)和S[l,r]有多少个本质不同的非空子串**

“仍然考虑之前的双指针扫描法，从Lj开始，不断删去其首字符，直到它加上T的第j+1位是S[li:ri]的子串

原先我们的判断方法是判断当前状态所在的节点是否有T(j+1)的转移边

但是现在不能这么判了，因为**转移边指向的状态（如果有的话）是S的子串但不一定是S[li:ri]的子串**

我们的问题是，如何判断一个状态x是否在S[li:ri]中出现

考虑x在S中出现的所有（右端点的）位置，即x所在节点的Right集合

Right集合中什么样的位置p才会让x在S[li:ri]中出现呢？

x在S[li:ri]中出现当且仅当x所在节点的Right集合中存在p使得 **p≤ri 并且 p-len(x)+1≥li**（其中len(x)是x的长度）

那么就是**判断Right集合中不超过ri的p中最大的(p-len(x)+1)是否大于等于li**

当然，(p-len(x)+1)最大当且仅当p最大

这是个经典的**二维偏序**问题

一维是**p≤ri**，另一维是at值为p的节点必须要在x所在节点的子树中（这样Right集合中才会有p）”

对于第一维：把所有询问存下来，离线处理，按照r从小到大排序，然后把S的后缀自动机中所有at<=r的np节点激活，插入到线段树中

对于第二维：建S后缀自动机后 我们把所有节点的fa和它自己连边，形成一棵树,利用树的**dfs序**，我们能将树的一棵子树范围转化成一段区间，从而用线段树求区间最大值

时间复杂度O(∑Len(T) log Len(S))
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using std::max;
using std::sort;
typedef long long ll;
const int LS=5e5+10,LT=1e6+10,Q=1e5+10;
template<int maxn>struct Suffix_Automaton
{
	int son[maxn][26],fa[maxn],back[maxn],right[maxn],len[maxn],last,cnt;
	inline const void clear(int p)
	{
		fa[p]=right[p]=back[p]=len[p]=0;
		memset(son[p],0,sizeof(son[p]));
	}
	inline const void insert(int c,int k)
	{
		int p=last,np=++cnt;clear(np);
		len[last=np]=len[p]+1;back[right[np]=k]=np;
		for (;p&&!son[p][c];p=fa[p])son[p][c]=np;
		if (!p)return (void)(fa[np]=1);
		int q=son[p][c];
		if (len[q]==len[p]+1)return (void)(fa[np]=q);
		int nq=++cnt;len[nq]=len[p]+1;
		memcpy(son[nq],son[q],sizeof(son[q]));fa[nq]=fa[q];
		fa[q]=fa[np]=nq;right[nq]=k;
		for (;p&&son[p][c]==q;p=fa[p])son[p][c]=nq;
	}
	inline const void build(char *s)
	{
		int n=strlen(s+1);
		for (int i=1;i<=n;i++)insert(s[i]-97,i);
	}
	inline const void clear()
	{
		clear(last=cnt=1);
	}
	inline Suffix_Automaton(){last=cnt=1;}
};
Suffix_Automaton<LS<<1>S,T;
int to[LS<<1],next[LS<<1],head[LS<<1],cnt;
inline const void addedge(int u,int v)
{
	next[++cnt]=head[u];to[head[u]=cnt]=v;
}
inline const void build()
{
	for (int i=1;i<=S.cnt;i++)if (S.fa[i])addedge(S.fa[i],i);
}
int dfn[LS<<1],end[LS<<1];
inline const void dfs(int p)
{
	dfn[p]=++cnt;
	for (int i=head[p];i;i=next[i])dfs(to[i]);
	end[p]=cnt;
}
class Segment_Tree
{
	private:
		struct tree
		{
			int mx;
			tree *lson,*rson;
			inline const void pushup()
			{
				mx=max(lson->mx,rson->mx);
			}
			inline const void update(int l,int r,int pos,int key)
			{
				if (l==r)return (void)(mx=key);
				int mid=l+r>>1;
				if (pos<=mid)lson->update(l,mid,pos,key);
				else rson->update(mid+1,r,pos,key);
				pushup();
			}
			inline const int query(int l,int r,int L,int R)
			{
				if (l>R||r<L)return 0;
				if (l>=L&&r<=R)return mx;
				int mid=l+r>>1;
				return max(lson->query(l,mid,L,R),rson->query(mid+1,r,L,R));
			}
		}*root,memory_pool[LS<<3],*tail;
		inline const void build(tree *&p,int l,int r)
		{
			p=tail++;
			if (l==r)return;
			int mid=l+r>>1;
			build(p->lson,l,mid);
			build(p->rson,mid+1,r);
		}
	public:
		inline Segment_Tree(){tail=memory_pool;}
		inline const void build(){build(root,1,S.cnt);}
		inline const void update(int pos,int key){root->update(1,S.cnt,pos,key);}
		inline const int query(int l,int r){return root->query(1,S.cnt,l,r);}
}sgt;
char s[LS],t[LT],*tail=t;
ll ans[Q];
int m;
struct query
{
	char *t;int l,r,len,id;
	inline query(char *a=0,int b=0,int c=0,int d=0,int e=0):t(a),l(b),r(c),len(d),id(e){}
	inline const bool operator<(const query &q)const
	{
		return r<q.r;
	}
}q[Q];
int f[LT];
int main()
{
	scanf("%s",s+1);S.build(s);
	build();cnt=0;dfs(1);sgt.build();
	scanf("%d",&m);
	for (int i=1;i<=m;i++)
	{
		int l,r;
		scanf("%s%d%d",tail+1,&l,&r);
		q[i]=query(tail,l,r,strlen(tail+1),i);
		tail+=q[i].len+1;
	}
	sort(q+1,q+m+1);cnt=1;
	for (int i=1;i<=m;i++)
	{
		for (;cnt<=q[i].r;cnt++)sgt.update(dfn[S.back[cnt]],cnt);
		T.build(q[i].t);
		int now=1,len=0;
		for (int j=1;j<=q[i].len;j++)
		{
			while (1)
			{
				if (!now){len=0;now=1;break;}
				int nxt=S.son[now][q[i].t[j]-97];
				if (!nxt)if (now=S.fa[now],now)len=S.len[now];else;
				else {now=nxt;len++;break;}
			}
			while (1)
			{
				int mx=sgt.query(dfn[now],end[now]);
				if (mx&&mx-len+1>=q[i].l)break;
				if (mx&&mx-S.len[S.fa[now]]+1>q[i].l){len=mx-q[i].l+1;break;}
				now=S.fa[now];len=S.len[now];
			}
			f[j]=len;
		}
		ll nowans=0ll;
		for (int j=2;j<=T.cnt;j++)
		{
			int right=T.right[j],len=T.len[j],flen=T.len[T.fa[j]];
			if (f[right]<=flen)nowans+=1ll*len-flen;
			else if (f[right]<len)nowans+=len-f[right];
		}
		ans[q[i].id]=nowans;
		T.clear();
	}
	for (int i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：mrclr (赞：22)

（这个行间距有点诡异，推荐到[我的博客](https://www.cnblogs.com/mrclr/p/10946572.html)瞅瞅）

这题以前写过弃掉了，后来竟然连自己的68分写法都看不懂了……
这次回首这道题，心想怎么说也得把这题切了，~~哪怕抄题解也行。~~

但没想到别人的题解自己怎么也看不懂，最终还是自己搞出来了（我真nb）。

总用时前一天下午到第二天凌晨0:30+第二天半个上午。

我们先来回顾$L = 1, R = n$的情况。

大体思路就是求出本质不同的公共子串数目，然后用$T$串的本质不同的子串减去即可。

$T$的本质不同的子串个数大家都会求，就不在这唠叨了。我们重点看前面的怎么求。

我们在$T$的后缀自动机中插入一个字符$t[i]$之后，马上记录$t[i]$所在结点的父亲的长度，即$len[link[pos[i]]]$。这个是什么东西呢？记前面那个值为$Len$，他表示的是左端点为$1$~$Len - 1$，右端点为$i$的这些子串第一次的出现位置都是$i$。因为新建的这个结点的endpos必定只有这个$i$，那么属于这个结点的所有子串的出现位置也就只有$i$了。

注意，一定是插入完后马上统计。如果把后缀自动机建完后再一个个统计就不对了。因为有的结点的父亲已经改变。
我们记上面求出的这个数组为$ha[i]$。

求出了上面这个东西后就好办了。我们把$T$放在$S$的后缀自动机上跑，记$T$到位置$i$时的匹配长度为$l$，那么如果$l >ha[i]$的话，就表示在在$T$的第$i$个位置，本质不同的公共子串数目增加了$l - ha[i]$，把他加到答案里即可。
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 5e5 + 5;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}

char s[maxn], t[maxn];
int ha[maxn];
struct Sam
{
  int cnt, las;
  int tra[maxn << 1][27], len[maxn << 1], link[maxn << 1];
  In void init()
  {
    link[cnt = las = 0] = -1;
    Mem(tra[0], 0);
  }
  In void insert(int c)
  {
    int now = ++cnt, p = las; Mem(tra[cnt], 0);
    len[now] = len[las] + 1;
    while(~p && !tra[p][c]) tra[p][c] = now, p = link[p];
    if(p == -1) link[now] = 0;
    else
      {
        int q = tra[p][c];
        if(len[q] == len[p] + 1) link[now] = q;
    	else
      	{
          int clo = ++cnt; Mem(tra[cnt], 0);
          memcpy(tra[clo], tra[q], sizeof(tra[q]));
          len[clo] = len[p] + 1;
          link[clo] = link[q], link[q] = link[now] = clo;
          while(~p && tra[p][c] == q) tra[p][c] = clo, p = link[p];
        }
      }
    las = now;
  }
  int pos[maxn << 1], buc[maxn << 1];
  In ll lcs(char* s)
  {
    ll ret = 0;
    int n = strlen(s);
    for(int i = 0, l = 0, p = 0; i < n; ++i)
      {
	    int c = s[i] - 'a';
	    while(~p && !tra[p][c]) p = link[p], l = len[p];
	    if(p == -1) p = l = 0;
	    else ++l, p = tra[p][c];
	    if(l > ha[i]) ret += l - ha[i];
      }
    return ret;
  }
}S, T;

In void work0()
{
  int len = strlen(t);
  ll tp = 0;
  for(int i = 0; i < len; ++i) tp += i + 1 - ha[i];    //根据ha[i]的定义，我们也可以这么求本质不同的子串个数
  write(tp - S.lcs(t)), enter;
}

int main()
{
  scanf("%s", s);
  int n = strlen(s); S.init();
  for(int i = 0; i < n; ++i) S.insert(s[i] - 'a');
  int m = read();
  for(int i = 1; i <= m; ++i)
    {
      scanf("%s", t); int len = strlen(t);
      T.init();
      for(int j = 0; j < len; ++j) T.insert(t[j] - 'a'), ha[j] = T.len[T.link[T.las]];
      int L = read(), R = read();
      if(L == 1 && R == n) {work0(); continue;}
    }
  return 0;
}
```

当当当当！下面开始讲正解！

现在有了$L, R$的限制。一个直观的想法就是线段树合并求出每一个结点的endpos集合。然后匹配的时候除了满足这个节点有字符$c$的转移，还要保证转移后到达的结点的endpos有在$[L, R]$里面的。

这样一直跳，如果他最终在位置$i$时的匹配长度为$l$，我们要考虑从endpos向前$l$长度的字符串超没超出$L$的限制，即$endpos - l$是否小于$L$，如果小于，那么匹配的长度实际是$endpos - L + 1$。然后看这个长度是否大于$ha[i]$，如果大于，就减去$ha[i]$加到答案里。

那么为了让匹配的长度尽量不超过下界$L$，我们要找的是在$[L, R]$区间内尽量靠右的endpos。这个线段树维护最大值即可。

表面上看这么做似乎就万事大吉了。但实际上68分以后照样WA。
为啥咧？

因为我们查找endpos的时候，是在能匹配的最长长度的结点上的线段树查询的，长度越长，endpos就越少，也就说明，我们在较长的匹配上查到的endpos减去$l$后会超过$L$的限制，而且可能超出很多，导致剩下的部分比$ha[i]$小。但是如果我们在匹配长度较短的线段树上查找的话，反而能找到一个endpos，在$L$的限制之内匹配的长度比$ha[i]$大，或者所有的匹配长度干脆都不会超出$L$。这时候就需要把这些长度加到答案里。

因此，匹配的时候，我们不仅要在这个结点的线段树上查找endpos计算贡献。还要到他的祖先结点上执行同样的过程，直到匹配长度不受$L$的限制再退出。接着去匹配下一位。

自认为码风还是十分工整的。
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 5e5 + 5;
const int maxt = 4e7 + 5;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}
In void MYFILE()
{
#ifndef mrclr
  freopen("name.in", "r", stdin);
  freopen("name.out", "w", stdout);
#endif
}

int n, L, R;
char s[maxn], t[maxn];
int ha[maxn];

struct Tree
{
  int ls, rs;
  int rpos;
}seg[maxt];
int root[maxn << 1], cur[maxn], tcnt = 0;
#define LS seg[now].ls
#define RS seg[now].rs
In void update(int& now, int l, int r, int id)
{
  now = ++tcnt;
  seg[now].rpos = -1;
  if(l == r) {seg[now].rpos = l; return;}
  int mid = (l + r) >> 1;
  if(id <= mid) update(LS, l, mid, id);
  else update(RS, mid + 1, r, id);
  seg[now].rpos = max(seg[LS].rpos, seg[RS].rpos);
}
In int merge(int x, int y, int l, int r)
{
  if(!x || !y) return x | y;
  if(l == r) {seg[x].rpos |= seg[y].rpos; return x;}
  int mid = (l + r) >> 1, z = ++tcnt;
  seg[z].ls = merge(seg[x].ls, seg[y].ls, l, mid);
  seg[z].rs = merge(seg[x].rs, seg[y].rs, mid + 1, r);
  seg[z].rpos = max(seg[x].rpos, seg[y].rpos);
  return z;
}
In int query(int now, int l, int r, int L, int R)
{
  if(!now) return -1;
  if(l == L && r == R) return seg[now].rpos;
  int mid = (l + r) >> 1;
  if(R <= mid) return query(LS, l, mid, L, R);
  else if(L > mid) return query(RS, mid + 1, r, L, R);
  else return max(query(LS, l, mid, L, mid), query(RS, mid + 1, r, mid + 1, R));
}

struct Sam
{
  int cnt, las;
  int tra[maxn << 1][27], len[maxn << 1], link[maxn << 1];
  In void init()
  {
    link[cnt = las = 0] = -1;
    Mem(tra[0], 0);
  }
  In void insert(int c, int id)
  {
    int now = ++cnt, p = las; Mem(tra[cnt], 0);
    len[now] = len[las] + 1;
    while(~p && !tra[p][c]) tra[p][c] = now, p = link[p];
    if(p == -1) link[now] = 0;
    else
      {
		int q = tra[p][c];
		if(len[q] == len[p] + 1) link[now] = q;
		else
		  {
		    int clo = ++cnt; Mem(tra[cnt], 0);
		    memcpy(tra[clo], tra[q], sizeof(tra[q]));
		    len[clo] = len[p] + 1;
		    link[clo] = link[q], link[q] = link[now] = clo;
		    while(~p && tra[p][c] == q) tra[p][c] = clo, p = link[p];
		  }
      }
    las = now;
    if(~id) cur[id] = now;
  }
  int pos[maxn << 1], buc[maxn << 1];
  In void solve()
  {
    for(int i = 1; i <= cnt; ++i) ++buc[len[i]];
    for(int i = 1; i <= cnt; ++i) buc[i] += buc[i - 1];
    for(int i = 1; i <= cnt; ++i) pos[buc[len[i]]--] = i;
    for(int i = cnt; i; --i)
      {
		int now = pos[i], fa = link[now];
		root[fa] = merge(root[fa], root[now], 0, n - 1);
      }
  }
  In ll calc(char* s)
  {
    ll ret = 0;
    int m = strlen(s);
    for(int i = 0, l = 0, p = 0, pos = 0; i < m; ++i)
      {
		int c = s[i] - 'a';
		while(~p && (!tra[p][c] || (pos = query(root[tra[p][c]], 0, n - 1, L, R)) == -1))
		  p = link[p], l = len[p];	//没有转移边或者[L, R]内没有endpos，就一直失配 
		if(p == -1) p = l = 0;
		else
		  {
		    ++l, p = tra[p][c];
		    int tp = min(l, pos - L + 1);
		    if(tp > ha[i]) ret += tp - ha[i];
		    if(l > pos - L + 1)	//匹配长度仍受L的限制 
		      {
				int tp3 = max(tp, ha[i]), q = link[p], l2 = len[q];
				while(~q)
				  {
				    int pos2 = query(root[q], 0, n - 1, L, R), tp2 = min(l2, pos2 - L + 1);
				    if(tp2 > tp3) ret += tp2 - tp3;
				    else if(l2 <= pos2 - L + 1) break;	//匹配长度不受L的限制了，退出 
				    q = link[q], l2 = len[q], tp3 = max(tp2, ha[i]);
				  }
		      }
		  }
      }
    return ret;
  }
}S, T;

int main()
{
  MYFILE();
  scanf("%s", s);
  n = strlen(s); S.init();
  for(int i = 0; i < n; ++i)
    {
      S.insert(s[i] - 'a', i);
      update(root[cur[i]], 0, n - 1, i);
    }
  S.solve();
  int m = read();
  for(int i = 1; i <= m; ++i)
    {
      scanf("%s", t); int len = strlen(t);
      T.init();
      for(int j = 0; j < len; ++j) T.insert(t[j] - 'a', -1), ha[j] = T.len[T.link[T.las]];
      L = read() - 1, R = read() - 1;
      ll tp = 0;
      for(int j = 0; j < len; ++j) tp += j + 1 - ha[j];
      write(tp - S.calc(t)), enter;
    }
  return 0;
}
```

---

## 作者：little_gift (赞：15)

题意: 给你一个字符串$S$, 有很多组询问, 每次给定一个$T$, 求$T$中不在$S[l:r]$中出现的本质不同的子串个数.

$|S| \leq 500000, \sum{|T|} \leq 1000000$.

考虑两件事.

- 在$S$中匹配$T$
- 去重

匹配就是要计算出一个$p_i$, 表示$T[1:i]$中在$S[l:r]$中存在的最长后缀的长度.

或者说, $p_i=\max \{x|T[i-x+1:i]\text{在}S[l:r]\text{中出现}\}$.

(得出$p_i$后如何去重在下面可以先看)

如果$l = 1, r = |S|$.

发现这个过程就是用SAM跑两个字符串最长公共子串的过程.

所以用类似的方法就可以求出每个$p_i$.

具体地说, 对$S$建立后缀自动机, 按顺序以$T$的每一个字符进行转移.

设当前字符为$c$， 正在$S$的后缀自动机上的节点$p$($p$初始值为根), 当前匹配长度为$l$.

如果$p$存在$c$这个转移, 那么直接沿转移边走, 并将$l$加一.

否则沿后缀链接向上跳, 并把$l$的值更新为后缀链接的$len$(最长字符串长度), 直到能够转移为止.

现在考虑对于一般的$l, r$怎么做.

转移时增加一个判断, 只有目标节点所表示的字符串完全包含在$S[l:r]$中才能够转移.

如何判断? 只要处理出每个节点的$right$集合(或者其他名字, 只要表示的意义相同), 判断一下$right$集合中是否有区间内的数即可.

考虑线段树合并, 建立权值线段树表示每个位置是否在$right$集合中出现.

初始值是每次的$last$的$right$集合包含当前处理到的字符的下标(建立后缀自动机的时候传入当前下标然后线段树$ins$一下即可).

然后拓扑排序(按$len$排序)/$dfs$, 将每个节点的所有孩子(后缀链接指向它)的线段树都合并到它自己上.

然后这个操作是不会破坏它孩子的线段树的结构的, 所以全部合并完之后就得到了每个节点的$right$集合.

因为后缀自动机状态个数线性, 拥有初始值的节点个数也是线性, 所以复杂度是一个$\log$级别, 可以承受.

但是如果这样的话上面转移需要有一些小变化.

- 查询的时候查询的是$right$集合中是否存在$[L+l, R]$($L, R$是给定的区间, $l$是当前匹配长度).
- 匹配失败的时候不能直接跳到后缀链接而是要减小$l$, 这样区间增大, 可能成功匹配(这一步复杂度目测可以优化但是因为复杂度已(hao)经(xiang)对了所以就没写)(事实上如果不判断这个能够拿到$96pts(WA\ on\ 21)$).

那么现在已经求出了$p_i$, 如何去重呢?

本质不同的子串……考虑用SAM求.

那么再对每次的$T$建后缀自动机, 设$tot$是节点总数, $1$表示根节点.

答案就是$\sum\limits_{k=2}^{tot}{\max(len[k]-\max(p[minr[k]], len[fa[k]]), 0)}$.

$minr$表示$right$集合中的最小数, 可以比较方便地处理出来. $fa$表示后缀链接.

~~感性~~理解: 遍历每个节点就是遍历了所有子串, 对于某个节点$k$, 长度不比$p[minr[k]]$大的串是不可行的(至于为什么是$minr$也可以感性理解, 判断后面的匹配长度可能出锅), 长度不比$len[fa[k]]$大的串不在这个节点中. 外面要再取一个$\max$是因为$p[minr[k]]$可能比$len[k]$大.

~~讲的混乱代码也丑……~~

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
namespace Segment_Tree {
    const int N = 1000000 * 20;
    int rt[N], ls[N], rs[N], tot, n;
    inline void init(const int& len) {n = len;}
    void ins(int& h, const int& x, const int& l = 1, const int& r = n) {
        if (!h) h = ++tot;
        if (l == r) return;
        int mid = (l + r) >> 1;
        if (x <= mid) ins(ls[h], x, l, mid);
        else ins(rs[h], x, mid + 1, r);
    }
    inline int add(const int& x) {int ret = ++tot; ins(tot, x); return ret;}
    int merge(const int& x, const int& y) {
        if (!x || !y) return x | y;
        int h = ++tot;
        ls[h] = merge(ls[x], ls[y]); rs[h] = merge(rs[x], rs[y]);
        return h;
    }
    bool query(const int& h, const int& L, const int& R, const int& l = 1, const int& r = n) {
        if (!h || R < l || r < L) return 0;
        if (L <= l && r <= R) return 1;
        int mid = (l + r) >> 1;
        return query(ls[h], L, R, l, mid) | query(rs[h], L, R, mid + 1, r);
    }
}
template<int N>
struct Suffix_Automaton {
    int len[N], fa[N], minr[N], ch[N][26], rt[N], tot, last;
    void clear() {tot = last = 1; memset(ch[1], 0, sizeof(ch[1]));}
    Suffix_Automaton() {clear();}
    void ins(const int& c, const int& pos = 0) {
        int p = last, np = last = ++tot; minr[np] = len[np] = len[p] + 1;
        if (pos) rt[np] = ::Segment_Tree::add(pos);
        memset(ch[np], 0, sizeof(ch[np]));
        for (; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;
        if (!p) return void(fa[np] = 1);
        int q = ch[p][c];
        if (len[p] + 1 == len[q]) return void(fa[np] = q);
        int nq = ++tot; len[nq] = len[p] + 1; minr[nq] = minr[q]; fa[nq] = fa[q];
        memcpy(ch[nq], ch[q], sizeof(ch[q]));
        fa[np] = fa[q] = nq;
        for (; p && ch[p][c] == q; p = fa[p]) ch[p][c] = nq;
    }
    void find(int& p, int& l, const int& L, const int& R, const int& c) {
        while (1) {
            if (ch[p][c] && ::Segment_Tree::query(rt[ch[p][c]], L + l, R)) {
                ++l; p = ch[p][c]; return;
            }
            if (!l) return;
            if (--l == len[fa[p]]) p = fa[p];
        }
    }
    long long calc(int p[]) {
        long long ret = 0;
        for (register int i = 2; i <= tot; ++i) {
            ret += std::max(0, len[i] - std::max(len[fa[i]], p[minr[i]]));
        }
        return ret;
    }
};
Suffix_Automaton<1000001> sam;
Suffix_Automaton<2000001> sam2;
char S[500002], T[1000002];
int p[1000002];
int c[500002], rk[1000002];
int main() {
    scanf("%s", S + 1);
    int len = strlen(S + 1); Segment_Tree::init(len);
    for (register int i = 1; i <= len; ++i) {
        sam.ins(S[i] - 'a', i);
    }
    for (register int i = 1; i <= sam.tot; ++i) ++c[sam.len[i]];
    for (register int i = 1; i <= len; ++i) c[i] += c[i - 1];
    for (register int i = 1; i <= sam.tot; ++i) rk[--c[sam.len[i]]] = i;
    for (register int i = sam.tot; --i; ) {
        sam.rt[sam.fa[rk[i]]] = Segment_Tree::merge(sam.rt[sam.fa[rk[i]]], sam.rt[rk[i]]);
    }
    int Q;
    for (scanf("%d", &Q); Q--; ) {
        sam2.clear();
        int l, r;
        scanf("%s%d%d", T + 1, &l, &r);
        int _len = strlen(T + 1), _ = 1;
        for (register int i = 1; i <= _len; ++i) {
            p[i] = p[i - 1];
            sam.find(_, p[i], l, r, T[i] - 'a');
            sam2.ins(T[i] - 'a');
        }
        printf("%lld\n", sam2.calc(p));
    }
}
```

---

## 作者：nofind (赞：13)

## [题意](https://www.luogu.com.cn/problem/P4770)

不妨先考虑$l=1,r=|S|$的情况：  
这时我们要求的其实是$S,T$的本质不同的公共子串数量。

首先对$S$建一个后缀自动机，同时对于每个$T$，我们也建一个自动机。

根据后缀自动机的性质，后缀自动机的所有节点的代表的字符串的集合代表了$T$的全部子串，因此我们可以考虑$T$后缀自动机的上的每一个点代表的字符串中有多少是和$S$的公共子串。

于是考虑怎么求这个东西：  
我们对于$T$的每一个前缀$T[1...i]$求出$match_i$表示这个前缀的后缀能跟$S$匹配的最长长度，这个东西可以在$S$的后缀自动机上匹配$T$来求出，见[这题](https://www.luogu.com.cn/problem/SP1811)。

对于一个节点$x$，我们设它的字符串长度范围为$[minlen_x,maxlen_x]$，$endpos$集合的第一个为$firpos_x$。

这时我们发现这个节点长度在$match_{firpos_x}+1$往上的字符串都不可能和$S$匹配，因此这个节点的贡献为$\max(len_x-\max(len_{fa_x},match_{firpos_x}),0)$。

现在考虑$[l,r]$的限制，我们按照套路用线段树维护$S$的后缀自动机每个节点$endpos$集合，求$match$的时候只走合法的点即可。

求match时注意个细节，写在注释里了。

code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+10;
int n,m,Q,tot,cnt_edge;
int head[maxn<<1],root[maxn<<1],match[maxn];
char s[maxn];
struct edge{int to,nxt;}e[maxn<<2];
struct Seg
{
	#define lc(p) (seg[p].lc)
	#define rc(p) (seg[p].rc)
	#define sum(p) (seg[p].sum)
	int lc,rc,sum;
}seg[maxn*50];
inline void add_edge(int u,int v)
{
	e[++cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
	e[cnt_edge].to=v;
}
void insert(int &p,int l,int r,int pos)
{
	if(!p)p=++tot;
	sum(p)++;
	if(l==r)return;
	int mid=(l+r)>>1;
	if(pos<=mid)insert(lc(p),l,mid,pos);
	else insert(rc(p),mid+1,r,pos);
}
int merge(int p,int q,int l,int r)
{
	if(!p||!q)return p+q;
	int x=++tot;sum(x)=sum(p)+sum(q);
	if(l==r)return x;
	int mid=(l+r)>>1;
	lc(x)=merge(lc(p),lc(q),l,mid);
	rc(x)=merge(rc(p),rc(q),mid+1,r);
	return x;
}
int query(int p,int l,int r,int ql,int qr)
{
	if(!p)return 0;
	if(l>=ql&&r<=qr)return sum(p);
	int mid=(l+r)>>1,res=0;
	if(ql<=mid)res+=query(lc(p),l,mid,ql,qr);
	if(qr>mid)res+=query(rc(p),mid+1,r,ql,qr);
	return res;
}
void dfs(int x)
{
	for(int i=head[x];i;i=e[i].nxt)
		dfs(e[i].to),root[x]=merge(root[x],root[e[i].to],1,n);
}
struct SAM
{
	int tot,last;
	int fa[maxn<<1],len[maxn<<1],firpos[maxn<<1];
	int ch[maxn<<1][30];
	inline void clear()
	{
		for(int i=1;i<=tot;i++)
		{
			fa[i]=len[i]=firpos[i]=0;
			memset(ch[i],0,sizeof(ch[i]));
		}
		last=tot=1;
	}
	inline void add(int c,int id)
	{
		int now=++tot;len[now]=len[last]+1;firpos[now]=id;
		int p=last;last=now;
		while(p&&!ch[p][c])ch[p][c]=now,p=fa[p];
		if(!p){fa[now]=1;return;}
		int q=ch[p][c];
		if(len[q]==len[p]+1)fa[now]=q;
		else 
		{
			int nowq=++tot;len[nowq]=len[p]+1;firpos[nowq]=firpos[q];
			memcpy(ch[nowq],ch[q],sizeof(ch[q]));
			fa[nowq]=fa[q];fa[q]=fa[now]=nowq;
			while(p&&ch[p][c]==q)ch[p][c]=nowq,p=fa[p];
		}
	}
}sam1,sam2; 
inline int read()
{
	char c=getchar();int res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
inline void getmatch(char* s,int l,int r)
{
	int len=strlen(s+1),now=1,nowl=0;
	for(int i=1;i<=len;i++)
	{
		while(2333)
		{
			if(sam1.ch[now][s[i]-'a']&&query(root[sam1.ch[now][s[i]-'a']],1,n,l+nowl,r))//注意是l+nowl，这是endpos的集合。
			{
				now=sam1.ch[now][s[i]-'a'],nowl++;
				break;
			}
			if(!nowl)break;
			nowl--;//注意不要直接跳fa[now],因为区间缩小可能产生答案。
			if(nowl==sam1.len[sam1.fa[now]])now=sam1.fa[now];
		}
		match[i]=nowl;
	}
}
int main()
{
	scanf("%s",s+1);n=strlen(s+1);
	sam1.clear();
	for(int i=1;i<=n;i++)sam1.add(s[i]-'a',i),insert(root[sam1.last],1,n,i);
	for(int i=2;i<=sam1.tot;i++)add_edge(sam1.fa[i],i);
	dfs(1);
	Q=read();
	while(Q--)
	{
		ll ans=0;
		scanf("%s",s+1);m=strlen(s+1);
		int l=read(),r=read();
		sam2.clear();
		for(int i=1;i<=m;i++)sam2.add(s[i]-'a',i);
		getmatch(s,l,r);
		for(int i=2;i<=sam2.tot;i++)
			ans+=max(0,sam2.len[i]-max(match[sam2.firpos[i]],sam2.len[sam2.fa[i]]));
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：E.Space (赞：11)

先考虑 $l=1,r=|S|$ 的情况。

对于询问，可以考虑枚举 $T$ 的所有子串，询问其是否在 $S$ 中出现。

为了不重不漏以及做到较优秀的复杂度，可以建出 $T$ 的后缀自动机，然后枚举每个节点上对应的子串。

注意到每个节点上对应的子串拥有相同的后缀，所以我们可以求出 $f(i)$ 表示 $T$ 的第 $i$ 个前缀最长的在 $S$ 中作为子串出现的后缀的长度，来快速算出这些串中有多少个不在 $S$ 中出现。

$f(i)$ 其实就是把 $T$ 的第 $i$ 个前缀放到 $S$ 的后缀自动机中匹配结果的长度。

在建 $T$ 的后缀自动机时，可以求出每个节点对应的子串在 $T$ 中任意一个对应位置 $at$，这样就可以利用 $f(at)$ 计算了。

如果当前节点的 $min>f(at)$，则当前节点对应的所有串都未在 $S$ 中出现过，所以当前节点对答案的贡献为 $max-min+1$。

如果当前节点的 $max \le f(at)$，则当前节点对应的所有串都在 $S$ 中出现过，所以当前节点对答案的贡献为 $0$。

否则当前节点对应的所有串中，长度大于 $f(at)$ 的所有串都未在 $S$ 中出现过，所以当前节点对答案的贡献为 $max-f(at)$。

总的来说，一个节点对答案的贡献是 $\max\{0,max-\max\{min-1,f(at)\}\}$。

时间复杂度为 $O(|S|+\sum |T|)$。可以得到 $68$ 分。这是我考场上的做法。

现在考虑一般情况。

还是考虑如何求出 $f$。如果求出了 $f$，之后的做法就和 $l=1,r=|S|$ 的做法一样了。

当匹配长度一定时，我们显然优先考虑匹配一个尽量靠右（但不超过 $r$）的子串，这样才能最大化该子串在 $[l,r]$ 中的长度。

考虑把询问按照 $r$ 从小到大排序，动态更新 $S$ 的后缀自动机的每个节点的 right 集合中不超过 $r$ 的最大元素。更新一次相当于是对某个点在 fail 树上的所有祖先赋值。这个可以改成单点修改，然后在查询时询问子树最大值。这个可以用 dfs 序 + zkw 线段树解决。

现在考虑把 $T$ 的每个前缀放到 $S$ 的后缀自动机里匹配的结果。

该结果是一个字符串 $R$，并且你可以知道它的长度和在 $S$ 的第 $r$ 个前缀中最后一次出现的位置（也可能是未出现）。

并且我们知道， $T$ 的第 $i$ 个前缀最长的在 $S[l,r]$ 中作为子串出现的后缀，一定是 $R$ 的一个后缀。

我们考虑用一个类似双指针扫描的方式，在 $T$ 的右边加入一个新字符后，一个一个地删去 $R$ 的首字符，直到它变成 $S[l,r]$ 的子串，然后准备加入下一个字符。这样出现的所有字符串对应的节点都是 $R$ 的对应节点或者 $R$ 在 fail 树上的祖先，每删一个字符，这个对应节点要么不变，要么往 fail 树上移动一条边。

所以我们可以从 $R$ 对应的节点暴力往上跳，直到节点中存在一个对应的字符串 $R'$ 完全在 $S[l,r]$ 中。这样我们就可以求出一个 $f(i)$ 的值。

然后我们可以像双指针扫描法中的那样直接以 $R'$ 为上一个前缀的匹配结果，然后在后面加入新的字符来得到新的 $R$。这样复杂度就是均摊的了。

由于有 zkw 线段树的修改和查询，所以最后的总时间复杂度是 $O((|S|+|T|)\log|S|)$。

---

## 作者：ニヒル (赞：10)

emmm，这题其实也不是特别难，个人感觉比之前做过的两道线段树合并right的后缀自动机都要简单不少（另两道都至少长2k……     
首先考虑一下询问区间就是整串的情况     
我们先对长串S建SAM     
然后把询问串T在长串上跑匹配，假设$1-T_i$能匹配的长度为len，显然$i-len$个串不会在$S$中出现，我们把答案加上即可     
但是吧，你仔细一看题，发现他要统计的是串的种类，要去重    
那么的话可以考虑对$T$再建一个后缀自动机    
我们把每个i对应的$1-T_i$能匹配的长度$len$放到$T$的后缀自动机上对应串的节点上，显然一个点被覆盖的长度就是他所有子树里最长的$len$，这样子我们把parent树建出来，在树上跑遍dfs，显然每个点的贡献就是这个点管辖的字符串数与他的最大长度减去被覆盖长度取min，加到答案上就可以了。  
 现在来考虑一下询问的是给定区间$l,r$的情况  
 我们还是跑匹配，一般的匹配思路是看看有没有这条转移边，没有的话跳父亲  
 现在只用线段树合并一下right集合，匹配的时候看看区间里有没有这个转移后缀，没有的话把后缀长度减一再匹配，如果这个点最小长度都匹配不上就跳父亲，这样子就做完了  
复杂度一只log

代码如下：
```cpp
#include<bits/stdc++.h>
#define lson tr[now].l
#define rson tr[now].r
#define N 500050
using namespace std;

struct SM
{
	struct point
	{
		int len,fa,son[26];
	}t[N<<1],t1[N<<1];

	struct tree
	{
		int l,r,sum;
	}tr[N*60];

	int last=1,cnt=1,last1=1,cnt1=1,tot=0,len1,len2,rt[N<<1],pos[N],mx[N<<1];
	int ttt;
	long long ans=0;
	vector<int> g[N<<1],g1[N<<1];
	char s[500050],ss[500050];

	void push_up(int now)
	{
		tr[now].sum=tr[lson].sum|tr[rson].sum;
	}

	void insert(int &now,int l,int r,int pos)
	{
		if(!now) now=++tot;
		if(l==r)
		{
			tr[now].sum=1;
			return ;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)
		{
			insert(lson,l,mid,pos);
		}
		else
		{
			insert(rson,mid+1,r,pos);
		}
		push_up(now);
	}

	int query(int now,int l,int r,int ll,int rr)
	{
		if(ll>rr) return 0;
		if(ll<=l&&r<=rr)
		{
			return tr[now].sum;
		}
		int mid=(l+r)>>1;
		if(rr<=mid)
		{
			return query(lson,l,mid,ll,rr);
		}
		else
		{
			if(mid<ll)
			{
				return query(rson,mid+1,r,ll,rr);
			}
			else
			{
				return query(lson,l,mid,ll,mid)|query(rson,mid+1,r,mid+1,rr);
			}
		}
	}

	int merge(int a,int b,int l,int r)
	{
		if(!a) return b;
		if(!b) return a;
		int now=++tot;
		if(l==r)
		{
			tr[now].sum=1;
			return now;
		}
		int mid=(l+r)>>1;
		tr[now].l=merge(tr[a].l,tr[b].l,l,mid);
		tr[now].r=merge(tr[a].r,tr[b].r,mid+1,r);
		push_up(now);
		return now;
	}

	void mem()
	{
		for(int i=1;i<=cnt1;i++)
		{
			memset(t1[i].son,0,sizeof(t1[i].son));
			g1[i].clear();
			mx[i]=0;
		}
		cnt1=1,last1=1;
	}

	void add(int c,int pos)
	{
		int p=last,np=++cnt;
		t[np].len=t[p].len+1;
		insert(rt[np],1,len1,pos);
		while(p&&(!t[p].son[c]))
		{
			t[p].son[c]=np;
			p=t[p].fa;
		}
		if(!p) t[np].fa=1;
		else
		{
			int q=t[p].son[c],nq;
			if(t[q].len==t[p].len+1)
			{
				t[np].fa=q;
			}
			else
			{
				nq=++cnt;
				t[nq]=t[q];
				t[nq].len=t[p].len+1;
				t[np].fa=t[q].fa=nq;
				while(p&&t[p].son[c]==q)
				{
					t[p].son[c]=nq;
					p=t[p].fa;
				}
			}
		}
		last=np;
	}

	void add1(int c)
	{
		int p=last1,np=++cnt1;
		t1[np].len=t1[p].len+1;
		while(p&&(!t1[p].son[c]))
		{
			t1[p].son[c]=np;
			p=t1[p].fa;
		}
		if(!p) t1[np].fa=1;
		else
		{
			int q=t1[p].son[c],nq;
			if(t1[q].len==t1[p].len+1)
			{
				t1[np].fa=q;
			}
			else
			{
				nq=++cnt1;
				t1[nq]=t1[q];
				t1[nq].len=t1[p].len+1;
				t1[np].fa=t1[q].fa=nq;
				while(p&&t1[p].son[c]==q)
				{
					t1[p].son[c]=nq;
					p=t1[p].fa;
				}
			}
		}
		last1=np;
	}

	void dfs1(int now)
	{
		for(int i=0;i<g[now].size();i++)
		{
			dfs1(g[now][i]);
			rt[now]=merge(rt[now],rt[g[now][i]],1,len1);
		}
	}

	void dfs2(int now,int fa)
	{
		for(int i=0;i<g1[now].size();i++)
		{
			dfs2(g1[now][i],now);
			mx[now]=mx[now]<mx[g1[now][i]]?mx[g1[now][i]]:mx[now];
		}
		int len=t1[now].len-t1[t1[now].fa].len;
		int tmp=t1[now].len-mx[now];
		if(tmp<0) tmp=0;
		ans+=tmp<len?tmp:len;
	}

	void solve()
	{
		int l,r;
		scanf("%s",s+1);
		len1=strlen(s+1);
		for(int i=1;i<=len1;i++) add(s[i]-'a',i);
		for(int i=1;i<=cnt;i++) g[t[i].fa].push_back(i);
		dfs1(1);
		scanf("%d",&ttt);
		while(ttt--)
		{
			ans=0;
			scanf("%s",ss+1);
			len2=strlen(ss+1);
			mem();
			for(int i=1;i<=len2;i++) add1(ss[i]-'a'),pos[i]=last1;
			for(int i=1;i<=cnt1;i++) g1[t1[i].fa].push_back(i);
			scanf("%d %d",&l,&r);
			int now=1,lenn=0;
			for(int i=1;i<=len2;i++)
			{
				int c=ss[i]-'a';
				lenn++;
				while(lenn)
				{
					if(query(rt[t[now].son[c]],1,len1,l+lenn-1,r))
					{
						break;
					}
					lenn--;
					if(lenn-1<=t[t[now].fa].len) now=t[now].fa;
				}
				if(lenn) now=t[now].son[c];
				else now=1;
				mx[pos[i]]=lenn;
			}
			dfs2(1,0);
			printf("%lld\n",ans);
		}
	}
}sam;

int main()
{
	sam.solve();
}
```

---

## 作者：xtx1092515503 (赞：9)

# [Portal](https://www.luogu.com.cn/problem/P4770)

~~我居然能独立AC NOI的黑题，后缀数组果然可爱~~

我们将命名串与所有的询问串，中间插上从未出现的字符然后放在一起跑SA。则对于来自询问串的某一条后缀$i$，我们需要求出一个数组$res_i$，表示所有出现在**命名串**以及**该询问串**中的**后缀**，与其$\operatorname{LCP}$的最大值。则对于一条询问串$T$，它的答案即为$\sum\limits_{i\in T}len_i-res_i$，其中$len_i$为后缀$i$的长度。

则现在问题被转换为求出所有的$res_i$。我们先考虑来自**命名串**的贡献。设当前我们讨论的后缀为$suf[i]$。则我们要求的即为区间$[l,r]$内所有后缀$suf[j]$，求$\min\Big(\operatorname{LCP}(suf[i],suf[j]),r-j+1\Big)$的最大值。

我们考虑二分这个最大值，设为$mid$。现在要来判断$mid$这个值是否合法。则只有区间$[l,l+mid-1]$中的$\operatorname{LCP}$才可能达到这么长，故只要找到其中的$\max\text{LCP}$，如果其长度大于等于$mid$，则$mid$合法。

到现在我们已经可以构思出一个$O(n\log^2n)$的二分套线段树的做法了。具体思路是，因为$\max\text{LCP}$一定在两个后缀的$rk$最接近时取到，所以我们将它拆成两半，一半是$rk_j\leq rk_i$的，一半是$rk_j\geq rk_i$的，并写两颗线段树分别维护。

则我们需要按顺序将位置插入线段树并统计答案，在前一棵中查询区间中$rk_i$的最大值，后一棵中查询$rk_i$的最小值（这里的线段树是以**原串位置**为下标的）。在查询到这个最大值/最小值后，就可以通过ST表求出$\text{LCP}$了。当然，这一切都是建立在二分的基础上，即，我们每次询问的区间都是二分出来的区间$[l,l+mid-1]$。

但是这样子得写两棵线段树，再加上ST表，太难受了。我们不如这样，直接在线段树上维护$\text{LCP}$长度。办法很简单，当新加入一个位置后，直接将线段树中所有$\text{LCP}$长度与它取$\min$即可。这样，ST表可以省掉了，两颗线段树要支持的操作也一致了（全局取$\min$，区间求$\max$）。

在这样写后，我们发现干脆连二分都可以省掉了（因为这里线段树的对应位置储存的值就是**真实答案**，所以可以省掉），直接在线段树上二分即可（这部分线段树上二分的代码比较神奇，建议看一下代码）。

（不知道大家有没有做过[[HEOI2016/TJOI2016]字符串](https://www.luogu.com.cn/problem/P4094)这道题，实际上思路是差不多的）。

然后就是来自该询问串内部的其它后缀的$\operatorname{LCP}$，这个也可以通过类似手法写出来。

则总复杂度$O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2001000;
int n,m,q,t,id[N],res[N],len[N];
ll ans[N];
int x[N],y[N],buc[N],sa[N],ht[N],rk[N],s[N];
char str[N];
bool mat(int a,int b,int k){
	if(y[a]!=y[b])return false;
	if((a+k<n)^(b+k<n))return false;
	if((a+k<n)&&(b+k<n))return y[a+k]==y[b+k];
	return true;
}
void SA(){
	for(int i=0;i<n;i++)buc[x[i]=s[i]]++;
	for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
	for(int i=n-1;i>=0;i--)sa[--buc[x[i]]]=i;
	for(int k=1;k<n;k<<=1){
		int num=0;
		for(int i=n-k;i<n;i++)y[num++]=i;
		for(int i=0;i<n;i++)if(sa[i]>=k)y[num++]=sa[i]-k;
		for(int i=0;i<=m;i++)buc[i]=0;
		for(int i=0;i<n;i++)buc[x[y[i]]]++;
		for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
		for(int i=n-1;i>=0;i--)sa[--buc[x[y[i]]]]=y[i];
		swap(x,y);
		x[sa[0]]=num=0;
		for(int i=1;i<n;i++)x[sa[i]]=mat(sa[i],sa[i-1],k)?num:++num;
		if(num>=n-1)break;
		m=num;
	}
	for(int i=0;i<n;i++)rk[sa[i]]=i;
	for(int i=0,k=0;i<n;i++){
		if(!rk[i])continue;
		if(k)k--;
		int j=sa[rk[i]-1];
		while(i+k<n&&j+k<n&&s[i+k]==s[j+k])k++;
		ht[rk[i]]=k;
	}
}
#define lson x<<1
#define rson x<<1|1
#define mid ((l+r)>>1)
#define change(x,y) seg[x].mn=min(seg[x].mn,y),seg[x].tag=min(seg[x].tag,y)
struct SegTree{
	int tag,mn;
}seg[N<<2];
void build(int x,int l,int r){
	seg[x].tag=0x3f3f3f3f,seg[x].mn=0;
	if(l!=r)build(lson,l,mid),build(rson,mid+1,r);
}
void pushdown(int x){
	change(lson,seg[x].tag),change(rson,seg[x].tag),seg[x].tag=0x3f3f3f3f;
}
void turnon(int x,int l,int r,int P,int val){
	if(l>P||r<P)return;
	seg[x].mn=max(seg[x].mn,val);
	pushdown(x);
	if(l!=r)turnon(lson,l,mid,P,val),turnon(rson,mid+1,r,P,val);
}
int getans(int x,int l,int r,int L,int R){
	if(l==r)return min(seg[x].mn,R-r+1);
	pushdown(x);
	if(seg[lson].mn>=R-mid+1)return getans(lson,l,mid,L,R);
	else return max(seg[lson].mn,getans(rson,mid+1,r,L,R));
}
int query(int x,int l,int r,int L,int R,bool &findans){
	if(l>R||r<L)return -1;
	if(L<=l&&r<=R){
		if(seg[x].mn>=R-r+1){findans=true;return getans(x,l,r,L,R);}
		return seg[x].mn;
	}
	pushdown(x);
	int tmp=query(lson,l,mid,L,R,findans);
	if(findans)return tmp;
	return max(tmp,query(rson,mid+1,r,L,R,findans));
}
int pointask(int x,int l,int r,int P){
	if(l>P||r<P)return 0;
	if(l==r)return seg[x].mn;
	pushdown(x);
	return pointask(lson,l,mid,P)+pointask(rson,mid+1,r,P);
}
pair<int,int>p[500100];
void read(int &x){
	x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar(); 
}
int main(){
	scanf("%s",str),t=strlen(str);for(int i=0;i<t;i++)s[n++]=str[i]-'a'+1;
	read(q);
	for(int i=1;i<=q;i++){
		scanf("%s",str),read(p[i].first),read(p[i].second),m=strlen(str),p[i].first--,p[i].second--;
		id[n]=-1,s[n]=i+26,n++;
		for(int j=0;j<m;j++)id[n]=i,s[n]=str[j]-'a'+1,len[n]=m-j,n++;
	}
	m=q+26;
	SA();
	bool tmp;
	build(1,0,t-1);
	for(int i=1;i<n;i++){
		change(1,ht[i]);
		if(!id[sa[i-1]])turnon(1,0,t-1,sa[i-1],ht[i]);
		if(id[sa[i]]>=1)tmp=false,res[sa[i]]=max(res[sa[i]],query(1,0,t-1,p[id[sa[i]]].first,p[id[sa[i]]].second,tmp));
	}
	build(1,0,t-1);
	for(int i=n-1;i>=0;i--){
		if(id[sa[i]]>=1)tmp=false,res[sa[i]]=max(res[sa[i]],query(1,0,t-1,p[id[sa[i]]].first,p[id[sa[i]]].second,tmp));
		change(1,ht[i]);
		if(!id[sa[i]])turnon(1,0,t-1,sa[i],ht[i]);
	}
	build(1,1,q);
	for(int i=1;i<n;i++){
		change(1,ht[i]);
		if(id[sa[i-1]]>=1)turnon(1,1,q,id[sa[i-1]],ht[i]);
		if(id[sa[i]]>=1)res[sa[i]]=max(res[sa[i]],pointask(1,1,q,id[sa[i]]));
	}
	for(int i=0;i<n;i++)if(id[i]>=1)ans[id[i]]+=len[i]-res[i];
	for(int i=1;i<=q;i++)printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：asuldb (赞：5)

可能是一个乱搞做法，同时也跪求有人能帮我分析一下复杂度

还是先来看比较简单的$68pts$，也就是$l=1,r=|S|$的情况

我们可以直接把$S$串和所有的$T$串一起建一个广义$SAM$，用一个$vector$维护每个$T$加入$SAM$时新产生的节点

我们只需要求出来这些新增节点没有在$S$串出现的本质不同的子串个数就好了

我们提前处理好每一个节点的$endpos$，标记一下其是否在$S$中出现过

对于那些新出现在$SAM$上的节点$x$我们可以直接判断一下其是否在$S$中出现过，经典操作自然是$ans+=len[x]-len[fa[x]]$

但是考虑到$x$在$parent$树上的祖先自然也在当前的$T$中出现过，于是我们还需要考虑这些节点的贡献

倍增？看起来好像非常可行，但是还有一个问题，就是判重

显然在处理一个$T$的时候$parent$树上的一个节点不能被计算两次，于是在$parent$树上倍增又不太可行了，因为不太方便我们打标记来判重

倍增不行我们就暴力啊，我们直接暴力访问$x$的祖先们，一旦有一个祖先在之前被访问过或者是在$S$中出现过，那么我们就不在往上跳了

至于复杂度我也不知道是什么，我甚至都觉得这个样子最坏会导致每次都把$parent$树遍历一遍，所以求有神仙能帮忙分析一下这个玄学的复杂度

$68pts$代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#define maxn 3000005
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
char S[maxn],T[maxn];
int n,m,l,r,cnt=1,lst=1,num;
struct E{int v,nxt;}e[maxn];
std::vector<int> v[100005];
int fa[maxn],len[maxn],endpos[maxn],son[maxn][26],head[maxn],vis[maxn];
int top,st[maxn];
inline void add(int x,int y) {e[++num].v=y;e[num].nxt=head[x];head[x]=num;}
inline void ins(int c,int o)
{
    int p=++cnt,f=lst; lst=p;
    len[p]=len[f]+1,endpos[p]=o;
    if(o>1) v[o-1].push_back(p);
    while(f&&!son[f][c]) son[f][c]=p,f=fa[f];
    if(!f) {fa[p]=1;return;}
    int x=son[f][c];
    if(len[f]+1==len[x]) {fa[p]=x;return;}
    int y=++cnt;
    if(o>1) v[o-1].push_back(y);
    len[y]=len[f]+1,fa[y]=fa[x],fa[x]=fa[p]=y;
    for(re int i=0;i<26;i++) son[y][i]=son[x][i];
    while(f&&son[f][c]==x) son[f][c]=y,f=fa[f];
}
void dfs(int x) {if(endpos[x]!=1) endpos[x]=0; for(re int i=head[x];i;i=e[i].nxt) dfs(e[i].v),endpos[x]|=endpos[e[i].v];}
int main()
{
    scanf("%s",S+1);n=strlen(S+1);
    for(re int i=1;i<=n;i++) ins(S[i]-'a',1);
    scanf("%d",&m);
    for(re int i=1;i<=m;i++)
    {
        scanf("%s",T+1),n=strlen(T+1);
        scanf("%d%d",&l,&r);
        lst=1;
        for(re int j=1;j<=n;j++) 
            ins(T[j]-'a',i+1);
    }
    for(re int i=2;i<=cnt;i++) add(fa[i],i); dfs(1);
    for(re int i=1;i<=m;i++)
    {
        LL ans=0;top=0;
        for(re int j=0;j<v[i].size();j++)
        {
            int t=v[i][j];
            if(endpos[t]||vis[t]) continue;
            ans+=len[t];st[++top]=t;vis[t]=1;
            while(!vis[fa[t]]&&fa[t]&&!endpos[fa[t]]) t=fa[t],vis[t]=1,st[++top]=t;
            ans-=len[fa[t]];
        }
        for(re int j=1;j<=top;j++) vis[st[j]]=0;
        printf("%lld\n",ans);
    }
    return 0;
}
```

再来看看剩下的非特殊情况

看到$S$串里的区间我们就知道我们不能只是粗略维护$endpos$集合了，我们有时候甚至得关心$endpos$里到底有哪些元素

于是我们得用一个可持久化数据结构来维护一下$endpos$集合

这里选择的是主席树，至于做法和上面差不多

我们还是对$SAM$上新增的节点以及其祖先算贡献，每次用主席树找出当前节点$x$的$endpos$集合里小于等于$r$的最大值$now$

根据$now$和$l$的关系进行讨论

1. 如果$now-len[fa[x]]>=l$，那么就说明当前这个节点表示的子串里已经有一些完全出现在了$[l,r]$中，所以我们没有必要往上进行了，在这里计算贡献就好了，减掉那些完全出现在$[l,r]$里的子串，也就是$now-l+1$，但是可能这个节点根本产生不了这些子串，于是需要和$len[x]$取一个$min$

1. 否则的话这个节点表示的子串里没有一个完全出现在$[l,r]$中，所以还要继续算下去

但是这样每次都需要在主席树里二分，可以加一个小优化，一旦$endpos$集合的最大值小于$l$，或者最小值大于$r$，我们就不在主席树里二分了

这里的复杂度和上面相比多了一个$log$，于是更加玄学了，并不保证代码能随时不T

交上去能获得取决于评测机稳定程度的分数的代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#define maxn 3000005
#define M 10000005
#define re register
#define LL long long
inline int min(int a,int b) {return (a<b)?a:b;}
inline int max(int a,int b) {return (a>b)?a:b;}
char S[500005],T[500005];
int n,m,cnt=1,lst=1,num,U,__,tot;
struct E{int v,nxt;}e[maxn];
std::vector<int> a[100005];
int x[100005],y[100005];
int fa[maxn],len[maxn],endpos[maxn],son[maxn][26],head[maxn];
int rt[maxn],sz[maxn],to[maxn],_to[maxn],mx[maxn],tx[maxn];
unsigned short vis[maxn];
int top,st[500005];
int l[M],r[M],d[M];
inline void add(int x,int y) {e[++num].v=y;e[num].nxt=head[x];head[x]=num;}
inline void ins(int c,int pos,int o)
{
	int p=++cnt,f=lst; lst=p;
	len[p]=len[f]+1,endpos[p]=tx[p]=mx[p]=pos;
	if(o) a[o].push_back(p);
	while(f&&!son[f][c]) son[f][c]=p,f=fa[f];
	if(!f) {fa[p]=1;return;}
	int x=son[f][c];
	if(len[f]+1==len[x]) {fa[p]=x;return;}
	int y=++cnt;
	len[y]=len[f]+1,fa[y]=fa[x],fa[x]=fa[p]=y;
	for(re int i=0;i<26;i++) son[y][i]=son[x][i];
	while(f&&son[f][c]==x) son[f][c]=y,f=fa[f];
}
void dfs(int x)
{
	to[x]=++__;_to[__]=x;sz[x]=1;
	if(!tx[x]) tx[x]=U+1;
	for(re int i=head[x];i;i=e[i].nxt) 
	{
		int v=e[i].v;
		dfs(v),sz[x]+=sz[v];
		mx[x]=max(mx[v],mx[x]);
		tx[x]=min(tx[x],tx[v]);
	}
}
int change(int pre,int x,int y,int pos)
{
	int root=++tot;
	d[root]=d[pre]+1;
	if(x==y) return root;
	l[root]=l[pre],r[root]=r[pre];
	int mid=x+y>>1;
	if(pos<=mid) l[root]=change(l[pre],x,mid,pos);
		else r[root]=change(r[pre],mid+1,y,pos);
	return root;
}
int query(int p1,int p2,int x,int y,int pos)
{
	if(x==y) return d[p2]-d[p1];
	int mid=x+y>>1;
	if(pos<=mid) return query(l[p1],l[p2],x,mid,pos);
	return d[l[p2]]-d[l[p1]]+query(r[p1],r[p2],mid+1,y,pos);
}
int ask(int p1,int p2,int x,int y,int k)
{
	if(x==y) return x;
	int now=d[l[p2]]-d[l[p1]];
	int mid=x+y>>1;
	if(k>now) return ask(r[p1],r[p2],mid+1,y,k-now);
	return ask(l[p1],l[p2],x,mid,k);
}
inline int find(int X,int o) 
{
	if(y[o]<tx[X]||x[o]>mx[X]) return -1;
	int Y=to[X]+sz[X]-1;
	X=to[X];
	int T=query(rt[X-1],rt[Y],1,U,y[o]);
	if(!T) return -1;return ask(rt[X-1],rt[Y],1,U,T);
}
int main()
{
	scanf("%s",S+1);n=strlen(S+1);U=n;
	for(re int i=1;i<=n;i++) ins(S[i]-'a',i,0);
	scanf("%d",&m);
	for(re int i=1;i<=m;i++)
	{
		scanf("%s",T+1),n=strlen(T+1);
		scanf("%d%d",&x[i],&y[i]);lst=1;
		for(re int j=1;j<=n;j++) ins(T[j]-'a',0,i);
	}
	for(re int i=2;i<=cnt;i++) add(fa[i],i); dfs(1);
	for(re int i=1;i<=cnt;i++)
		if(endpos[_to[i]]) rt[i]=change(rt[i-1],1,U,endpos[_to[i]]);else rt[i]=rt[i-1];
	for(re int i=1;i<=m;i++)
	{
		LL ans=0;top=0;int now=0;
		for(re int j=0;j<a[i].size();j++)
		{
			int t=a[i][j];
			if(vis[t]) continue;
			vis[t]=1,st[++top]=t;ans+=len[t];
			now=find(t,i);
			if(now!=-1&&now-len[fa[t]]>=x[i]) 
			{ans-=min(len[t],now-x[i]+1);continue;}
			while(1) 
			{
				if(vis[fa[t]]||!fa[t]) {ans-=len[fa[t]];break;}
				t=fa[t],vis[t]=1,st[++top]=t;
				now=find(t,i);
				if(now!=-1&&now-len[fa[t]]>=x[i]) {ans-=min(now-x[i]+1,len[t]);break;}
			}
		}
		for(re int j=1;j<=top;j++) vis[st[j]]=0;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：zhongyuwei (赞：4)

### Sol

答案相当于 $T$ 中不被 $S_{l\cdots r}$ 包含的本质不同的子串数量。

求出 $T$ 中被 $S_{l\cdots r}$ 包含了的本质不同的子串数量，用 $T$ 的本质不同的子串数量减去它就是答案。后者容易求，我们考虑怎么求前者。

#### 部分分：$l=1,r=|S|$

对 $T$ 建出 SAM ，然后对 SAM 中的每个节点，考虑这个节点代表的子串集合的贡献。这个集合形如“ $T$ 的某个子串 $w$ 的所有长度不小于 $minlen$ 的后缀”。我们只需要知道 $w$ 最长的、在 $S$ 中出现过的后缀是谁，就能够统计这个集合中有多少个串在 $S$ 中出现过（长度更短的都出现过，长度更长的都没有出现过）。更进一步观察发现，我们其实只需要知道，以 $w$ 结尾的那个前缀，它的最长的、在 $S$ 中出现过的后缀是谁，就可以了（ $w$ 的最长的在 $S$ 中出现过的后缀长度就是那个后缀的长度和 $|w|$ 的较小值）。

这是个经典的后缀自动机问题。对 $S$ 建出 SAM ，然后让 $T$ 在 $S$ 上面跑匹配就可以了。具体地，维护一个 `u` 表示当前的位置，`len` 表示当前匹配上了的长度。每次从 `u` 走向 `ch[u][T[i]]` 的时候，就把变成 `len+1`；如果转移不存在，就从 `u` 跳到 `fail[u]` ， `len` 变成现在的 `u` 中最长的子串的长度。复杂度分析：一次跳 `fail` 会让匹配长度至少减少 1 ，而一次 `u -> ch[u][T[i]]` 则会让匹配长度 + 1 ，匹配长度总是非负并且整个过程中匹配的长度只会增加 $|T|$ 次，所以复杂度是 $O(|T|)$ 的。

#### $l,r$ 任意

考虑对前面在 SAM 的匹配做一些修改：我们称一个节点“存在”，当且仅当它所代表的子串集合中，最短的那个串在 $S_{l\cdots r}$ 中出现过。那么匹配过程中我们相当于需要支持：

- 查询一个点是否存在
- 查询一个点所代表的子串集合中，在 $S_{l\cdots r}$ 中出现过的、最长的串

第一问：设这个节点的子串集合中最短的串长度是 $minlen$ 。用可持久化线段树合并维护出每个节点的 endpos 集合，查询 $[l+minlen-1, r]$ 这个区间内是否有这个节点的 endpos 即可。

第二问：找出 $[l+minlen-1, r]$ 中最靠右的那个 endpos ，它到 $l$ 的距离和这个节点代表的最长子串长度的较小值即为答案。

具体细节见代码。

#### 附：可持久化线段树合并的空间复杂度

可能有锅，欢迎指正。

分成两个部分：

1. 将 $n$ 个节点插进 $n$ 棵不同的树。
2. 合并两棵树，并复制两棵树的公共部分，得到一棵新的树。

第一部分会用到至多 $n\lceil\log_2 n\rceil$ 个节点。

第二部分中，考虑每个非叶子节点：每一次复制它，它子树内的叶子节点数量一定变多了，所以它被复制的次数至多是它子树内的叶子节点数量。每个叶子至多在 $\lceil \log_2 n\rceil$ 个节点的子树中，所以复制节点的次数至多是 $n\lceil\log_2 n\rceil$ 次。

### Code

[link](https://loj.ac/submission/756501)

---

## 作者：lory1608 (赞：4)

$NOI2018$的你的名字确实有点~~毒瘤~~

本题是一道出的很好的字符串题，非常符合$NOI$考查难度。

考查后缀自动机和线段树合并综合掌握。

对于本题求出所有**本质不同的字符串**其中他在$T$中出现过，在$S$中未出现过。

对于样例：

$\texttt{sgepe}$相对于$\texttt{scbamgepe}$在整个串之内，有$\texttt{sg},\texttt{sge},\texttt{sgep},\texttt{sgepe}$满足题意。

先分析子任务$l=1,r=|s|$,那么只需要对$S$建立$SAM$，然后对于每一个询问$T$也建立$SAM$,$T$在$S$的自动机部分跑，这个做法可以参照[CF666E Forensic Examination](https://www.luogu.com.cn/problem/CF666E),如果$u$点$son[u][c]\not=0$那么就直接往下走，否则往上跳$parent$，知道出现$son[u][c]\not=0$,复杂度证明参见建立$SAM$时暴力往上跳的复杂度，均摊$\Theta(n)$。

对于到达的$S$的自动机的$u$点，那么记录$ans[last]=len[u]$ $($其中$last$为插入当前字符后，$T$的自动机的$last)$，表示当前节点的在$S$中出现的**最长的后缀长度**，然后合并即可。

运用**补集关系**，答案为$T$的所有本质不同子串$-S$中所包含$T$子串。

```cpp
void dfs(int u)
{
	for(int i=p[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		dfs(v);
		ans[u]=max(ans[u],ans[v]);
	}
	ans[u]=min(ans[u],len[u]);
	res+=len[u]-len[fa[u]];
	res-=max(0,ans[u]-len[fa[u]]);
}
```

注意此处要取$\max$,因为有可能他被之前减过了。

这样就可以用$\Theta(n)$的复杂度获得~~优秀的68分(原始数据)~~。

对于$100\%$的数据：

显然可以沿用上述思路，建立一颗线段树，对每个节点进行主席树式合并，然后查询是否满足条件即可。

复杂度$\Theta((|S|+|T|)\log|S|)$。

条件：当前子树中是否有$l \ r$，**以及该子串是否在$\texttt{l r}$之间**。

**注意：在查询时有可能出现如下情况**

~~我在这里卡了好久~~

$hack:$

#### hack1.in
```
vwv
1
vw 2 3
```
#### hack1.out
```
1
```

注意这里答案是$1$,不是$0$。

因为在查询到表示$\texttt{vw}$节点时它对应原区间为$1\ 2$，所以这里的$ans$只能设置为$1$。

#### hack2.in
```
aabcabbacc
1
abcd 3 6
```
#### hack2.out
```
5
```

注意这里答案是$5$,不是$6$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<vector>
#define ll long long
#define ull unsigned long long
using namespace std;
inline int getint()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
inline int max(int a,int b)
{
	return a>b?a:b;
}
inline int min(int a,int b)
{
	return a<b?a:b;
}
const int maxn=1e6+5;
char s[maxn],t[maxn];
int p[maxn],sz,rt[maxn],Q,l,r,n;
ll res;
struct edge
{
	int v,nxt;
	edge(){}
	edge(int vv,int nn)
	{
		v=vv,nxt=nn;
	}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}

struct segmentree
{
	int tot;
	int sum[maxn*20],ls[maxn*20],rs[maxn*20],maxv[maxn*20];
	inline void pushup(int u)
	{
		sum[u]=sum[ls[u]]+sum[rs[u]];
		maxv[u]=max(maxv[ls[u]],maxv[rs[u]]);
	}
	inline void update(int &u,int l,int r,int x,int v)
	{
		if(!u)u=++tot;
		if(l==r)
		{
			sum[u]+=v;
			maxv[u]=l;
			return;
		}
		else
		{
			int mid=(l+r)>>1;
			if(x<=mid)update(ls[u],l,mid,x,v);
			else update(rs[u],mid+1,r,x,v);
			pushup(u);
		}
	}
	inline int query(int u,int l,int r,int x,int y)
	{
		if(x<=l&&y>=r)return sum[u];
		if(u==0||l>r)return 0;
		else
		{
			int mid=(l+r)>>1,val=0;
			if(x<=mid)val+=query(ls[u],l,mid,x,y);
			if(y>mid)val+=query(rs[u],mid+1,r,x,y);
			return val;
		}
	}
	inline int query2(int u,int l,int r,int x,int y)
	{
		if(x<=l&&y>=r)return maxv[u];
		if(u==0||l>r)return 0;
		else
		{
			int mid=(l+r)>>1,val=0;
			if(x<=mid)val=max(val,query2(ls[u],l,mid,x,y));
			if(y>mid)val=max(query2(rs[u],mid+1,r,x,y),val);
			return val;
		}
	}
	inline int merge(int &x,int &y,int l,int r)
	{
		if(!x||!y)return x+y;
		int u=++tot;
		if(l==r)
		{
			sum[u]=sum[x]+sum[y];
			maxv[u]=l;
			return u;
		}
		else
		{
			int mid=(l+r)>>1;
			ls[u]=merge(ls[x],ls[y],l,mid);
			rs[u]=merge(rs[x],rs[y],mid+1,r);
			pushup(u);
		}
		return u;
	}
}tree;
namespace SAM1
{
	int fa[maxn],len[maxn],son[maxn][26],tot=1,last=1;
	inline void insert(int c)
	{
		int np=++tot,p=last;
		len[np]=len[p]+1,last=np;
		while(p&&!son[p][c])son[p][c]=np,p=fa[p];
		if(p==0)fa[np]=1;
		else
		{
			int q=son[p][c];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				int nq=++tot;
				len[nq]=len[p]+1;
				fa[nq]=fa[q];
				fa[q]=fa[np]=nq;
				memcpy(son[nq],son[q],sizeof(son[nq]));
				while(p&&son[p][c]==q)son[p][c]=nq,p=fa[p];
			}
		}
	}
	inline void dfs(int u)
	{
		for(int i=p[u];i!=-1;i=e[i].nxt)
		{
			int v=e[i].v;
			dfs(v);
			rt[u]=tree.merge(rt[u],rt[v],1,n);
		}
	}
}
namespace SAM2
{
	int fa[maxn],len[maxn],son[maxn][26],tot=1,last=1;
	int ans[maxn];
	inline void clear()
	{
		for(int i=1;i<=tot;++i)fa[i]=0,len[i]=0,ans[i]=0,p[i]=-1;
		for(int i=1;i<=tot;++i)memset(son[i],0,sizeof(son[i]));
		tot=last=1;
		sz=0;
	}
	inline void insert(int c)
	{
		int np=++tot,p=last;
		len[np]=len[p]+1,last=np;
		while(p&&!son[p][c])son[p][c]=np,p=fa[p];
		if(p==0)fa[np]=1;
		else
		{
			int q=son[p][c];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				int nq=++tot;
				len[nq]=len[p]+1;
				fa[nq]=fa[q];
				fa[q]=fa[np]=nq;
				memcpy(son[nq],son[q],sizeof(son[nq]));
				while(p&&son[p][c]==q)son[p][c]=nq,p=fa[p];
			}
		}
	}
	inline void dfs(int u)
	{
		for(int i=p[u];i!=-1;i=e[i].nxt)
		{
			int v=e[i].v;
			dfs(v);
			ans[u]=max(ans[u],ans[v]);
		}
		ans[u]=min(ans[u],len[u]);
		res+=len[u]-len[fa[u]];
		res-=max(0,ans[u]-len[fa[u]]);
	}
}
int main()
{
//	freopen("name.in","r",stdin);
//	freopen("name.out","w",stdout);
	memset(p,-1,sizeof(p));
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;++i)
	{
		SAM1::insert(s[i]-'a');
		tree.update(rt[SAM1::last],1,n,i,1);
	}
	Q=getint();
	for(int i=1;i<=SAM1::tot;++i)add(SAM1::fa[i],i);
	SAM1::dfs(1);
	memset(p,-1,sizeof(p));
	for(int i=1;i<=Q;++i)
	{
		scanf("%s",t+1);
		int len=strlen(t+1);
		l=getint(),r=getint();
		SAM2::clear();
		int pos=1,nowlen=0;
		res=0;
		for(int j=1;j<=len;++j)
		{
			SAM2::insert(t[j]-'a');
			while(!SAM1::son[pos][t[j]-'a']&&pos)
			{
				pos=SAM1::fa[pos];
				nowlen=SAM1::len[pos];
			}
			if(SAM1::son[pos][t[j]-'a'])pos=SAM1::son[pos][t[j]-'a'],nowlen++;
			if(pos==0)pos=1,nowlen=0;
			while((!tree.query(rt[pos],1,n,l,r))&&pos)
			{
				pos=SAM1::fa[pos];
				nowlen=SAM1::len[pos];
			}
			while(tree.query2(rt[pos],1,n,l,r)-(SAM1::len[SAM1::fa[pos]])+1<l&&pos)
			{
				pos=SAM1::fa[pos];
				nowlen=SAM1::len[pos];
			}
			if(pos==0)pos=1,nowlen=0;
			SAM2::ans[SAM2::last]=min(nowlen,tree.query2(rt[pos],1,n,l,r)-l+1);
		}
		for(int j=1;j<=SAM2::tot;++j)add(SAM2::fa[j],j);
		SAM2::dfs(1);
		printf("%lld\n",res);
	}
	return 0;
}
```

随便提一下：

最好在写线段树合并的时候，加上区间，如果$l=r$，那么直接返回，以防不必要的错误。

---

## 作者：KokiNiwa (赞：4)

# [NOI 2018]你的名字

[题目链接](https://www.luogu.com.cn/problem/P4770)

## 题目叙述

给你一个大字符串，每次询问给几个小字符串，求大字符串的一个区间$[l,r]$中的字符组成的字符串中没有出现的小字符串的子串的数量。

## 一些想法

其实可以每一个大字符串和一个小字符串连起来（其实就是两个合起来建一个广义后缀树），然后看子树中既包含第一个结尾符又包含第二个结尾符的字符串有多少个。但是不知道如何多个询问搞，应该这撤销不了。

## 题解

答案就是$T$的本质不同子串数量减去既是$T$的子串又是$S$的本质不同子串数。

首先$T$的本质不同字串是$T$的后缀树大小。对$S$和$T$的公共子串按照开头分类，然后对于每个类别统计数量。那么统计的就是一个位置向后多少个在$S$里面。这个可以通过在后缀树上匹配完成。具体的，设$lim_i$为以$i$为开头最多向后匹配多少个还是在$S[l,r]$里面，我们知道匹配串的结尾$i+lim_i-1$是单调向后的，所以每次匹配到一个点可以延续上一个串匹配到的位置继续匹配，但在树上的位置需要变一变，因为首字母向后移了一个，所以应该跳到后缀链接上继续。但是由于有区间$[l,r]$的限制，在匹配长度为$len$的时候，最终匹配成的字符串（如果能匹配成的话）的开头一定在$[l,r-len]$之间，也就是看在$[l,r-len]$中是否有一个后缀，其前缀为该字符串。那么每次匹配向下走的时候要看当前节点的子树中是否有一个后缀的开头属于$[l,r-len]$。这样$lim$数组就求完了。

剩下的问题就是求所有的不行的字符串的本质不同子串数量。这个可以放到后缀树上去考虑，给每一个$T$都搞一个后缀树，那么不行的字符串（就是既是$S$的子串也是$T$的子串）一定是后缀树上的前面一段（大概解释一下，就是每一个不行的子串都是后缀树上的从根开始的一段）（可以画图理解一下，说的极其抽象）。剩下的字符数量就是答案。

## 知识点

+ 如果在区间$[l,r]$区间内匹配一个字符串，可以利用线段树合并匹配。
+ 一个字符串的许多子串的子串合起来的不同子串数量可以理解为后缀树上的前面一段。
+ 后缀树上的匹配。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long ll;
const int maxLen = 5e5 + 5, maxNode = maxLen << 1, inf = 1e8;
int len, queNum, rt[maxNode], lim[maxLen], fa[maxNode], depth[maxNode];
ll ans;
char str1[maxLen], str2[maxLen];
struct SuffixTree {
	int tail, curLen, now, actLen, lastLeaf;
	int curStr[maxLen], ch[maxNode][27], start[maxNode], len[maxNode],
	    link[maxNode];
	SuffixTree () {
		lastLeaf = now = tail = 1;
		curLen = actLen = 0;
		len[0] = inf;
	}
	void Clear() {
		lastLeaf = now = 1;
		while (curLen) {
			curStr[curLen] = 0;
			--curLen;
		}
		curLen = actLen = 0;
		while (tail != 0) { //这里必须是 tail != 0！！！因为 1号节点也要清空！！！
			memset(ch[tail], 0, sizeof(ch[tail]));
			start[tail] = len[tail] = link[tail] = 0;
			--tail;
		}
		tail = 1;
		len[0] = inf;
	}
	int NewNode(int st, int le) {
		link[++tail] = 1;
		start[tail] = st;
		len[tail] = le;
		return tail;
	}
	void Extend(int ins) {
		curStr[++curLen] = ins;
		++actLen;
		for (int last = 1; actLen; ) {
			while (actLen > len[ch[now][curStr[curLen - actLen + 1]]])
				actLen -= len[now = ch[now][curStr[curLen - actLen + 1]]];
			int &son = ch[now][curStr[curLen - actLen + 1]],
			     val = curStr[start[son] + actLen - 1];
			if (!son || val == ins) {
				link[last] = now;
				last = now;
				if (!son) {
					son = NewNode(curLen - actLen + 1, inf);
					link[lastLeaf] = son;
					lastLeaf = son;
				} else
					break;
			} else {
				int split = NewNode(start[son], actLen - 1);
				ch[split][val] = son;
				ch[split][ins] = NewNode(curLen, inf);
				link[lastLeaf] = tail;
				lastLeaf = tail;
				start[son] += actLen - 1;
				len[son] -= actLen - 1;
				link[last] = son = split;
				last = split;
			}
			if (now == 1)
				--actLen;
			else
				now = link[now];
		}
	}
} sft, sft2;
struct SegmentTree {
	int tail, ch[maxNode << 6][2];
	void Create(int &now) {
		ch[++tail][0] = ch[now][0];
		ch[tail][1] = ch[now][1];
		now = tail;
	}
	void Insert(int &now, int lEP, int rEP, int pos) {
		Create(now);
		if (lEP == rEP)
			return ;
		int mid = (lEP + rEP) >> 1;
		if (pos <= mid)
			Insert(ch[now][0], lEP, mid, pos);
		else
			Insert(ch[now][1], mid + 1, rEP, pos);
	}
	int Query(int now, int lEP, int rEP, int askL, int askR) {
		if (!now)
			return 0;
		if (lEP > askR || rEP < askL)
			return 0;
		if (askL <= lEP && rEP <= askR)
			return 1;
		int mid = (lEP + rEP) >> 1;
		return Query(ch[now][0], lEP, mid, askL, askR) | Query(ch[now][1], mid + 1, rEP,
		        askL, askR);
	}
	void Merge(int &uId, int vId) {
		if (!uId || !vId) {
			uId |= vId;
			return ;
		}
		Create(uId);
		Merge(ch[uId][0], ch[vId][0]);
		Merge(ch[uId][1], ch[vId][1]);
	}
} seg;
void dfs(int now, int dep, int from) {
	fa[now] = from;
	dep += min(sft.len[now], len - sft.start[now] + 1);
	depth[now] = dep;
	bool isLeaf = 1;
	for (int ch = 0; ch <= 26; ++ch)
		if (sft.ch[now][ch]) {
			isLeaf = 0;
			if (ch == 26 && now == 1)
				continue;
			dfs(sft.ch[now][ch], dep, now);
			seg.Merge(rt[now], rt[sft.ch[now][ch]]);
		}
	if (isLeaf)
		seg.Insert(rt[now], 1, len, len - dep + 1);
}
int dfs2(int now, int dep, int len2) {
	bool flag = 1;
	int orig = dep, length;
	dep += length = min(sft2.len[now], len2 - sft2.start[now] + 1);
	int big = 0;
	bool isLeaf = 1;
	for (int ch = 0; ch <= 26; ++ch)
		if (sft2.ch[now][ch]) {
			flag = 0;
			isLeaf = 0;
			if (now == 1 && ch == 26)
				continue ;
			big = max(dfs2(sft2.ch[now][ch], dep, len2), big);
		}
	if (isLeaf)
		big = lim[len2 - dep + 1];
	ans += length - max(0, min(big - orig, length));
	return big;
}

int main() {
	freopen("name.in", "r", stdin);
	freopen("name.out", "w", stdout);
	scanf("%s", str1 + 1);
	len = strlen(str1 + 1);
	for (int pos = 1; pos <= len; ++pos)
		sft.Extend(str1[pos] - 'a');
	sft.Extend(26);
	dfs(1, 0, 0);
	scanf("%d", &queNum);
	for (int qId = 1; qId <= queNum; ++qId) {
		int lEP, rEP, len2;
		scanf("%s%d%d", str2 + 1, &lEP, &rEP);
		len2 = strlen(str2 + 1);
		for (int pos = 1; pos <= len2; ++pos)
			sft2.Extend(str2[pos] - 'a');
		sft2.Extend(26);
		int now = 1, pt = 0;
		for (int pos = 1; pos <= len2; ++pos) {
			pt = max(pt, pos - 1);
#define pei (pt - pos + 1)
			while (pt < len2 && pei < rEP - lEP + 1 &&
			        ((pei + 1 > depth[now] && sft.ch[now][str2[pt + 1] - 'a']
			          && seg.Query(rt[sft.ch[now][str2[pt + 1] - 'a']], 1, len, lEP, rEP - pei)) ||
			         (pei + 1 <= depth[now]
			          && str1[sft.start[now] + pei - depth[fa[now]]] ==
			          str2[pt + 1] //第一块是 str1而不是 str2
			          && seg.Query(rt[now], 1, len, lEP, rEP - pei)))) {
				if (pei + 1 > depth[now])
					now = sft.ch[now][str2[pt + 1] - 'a'];
				++pt;
			}
			lim[pos] = pt - pos + 1;
			if (sft.link[now]) //首先走到最长真后缀的节点上
				now = sft.link[now];
			if (pt == pos - 1)
				now = 1;
			while (fa[now] && depth[fa[now]] >= pei - 1) //然后向上跳，跳到 len - 1的位置
				now = fa[now];
		}
		dfs2(1, 0, len2);
		printf("%lld\n", ans);
		sft2.Clear();
		for (int pos = 1; pos <= len2; ++pos)
			lim[pos] = 0;
		ans = 0;
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

注意：

+ 写匹配的时候还是老老实实的按照最麻烦的方法写吧。首先记录一个$now$表示当前边到达的那个点，每次匹配的时候分为两种情况讨论：
  + 再匹配一个边就出这个边了
  + 再匹配一个没有出这个边

---

## 作者：whyl (赞：3)

最近一直在学后缀自动机。。。。

感觉这道题很不错。。。。然后发现不会做~~（捂脸）~~

感觉这个去重的方法非常的厉害

所以来写一篇题解，成为我后缀自动机的第一篇题解

Part1 

首先考虑l=1，并且r=n的怎么做（不考虑去重）

就是对S建后缀自动机，让T对他跑匹配

如果有字符直接跳，并让l++；没有的话跳parent，并让l=maxlen（l），如果为0就重新开始

这个可以l表示对于T中每一个前缀1...i的可以匹配到的最长后缀长度

那么用sigma（i-l） 就是答案（当然没有考虑去重）

Part2

考虑如果l，r任意的话怎么做。这次就没有方法直接转移了，因为你不知道你的这个节点所表示出的串是不是在l-r的范围内

那么我们用线段树合并维护对于每一个节点的所有endpos的值

在跳的时候就是看转移到下一个的内个字符的endpos集合是不是有在（L+l，R）这个区间内部的，如果有的话，就转移

但是失配了怎么办。。。那就让l--，含义就相当与是在已经匹配好的后缀删除第1个字符（注意不能直接跳到parent上，因为可能删除一个字符endpos就可以满足了），如果删除到和他（parent的len==l） 的话就得跳parent了。

Part3 

去重。。。。考虑对T建自动机

对那么根据本质不同字串做法就是len（i）-len（fa）

但是要减去相同的

就是len（i）-（max（len（fa），和可以与S匹配的最大值））的和

那么我们把刚刚的内个l放到节点上我们显然不可以把它放到前缀上暴力跳parent（但是据说复杂度也是对的）

所以我们考虑在建自动机的时候除了分裂出的节点都是前缀。。。
所以我们只需要考虑分裂出来的节点

我们知道分裂出来的节点nq是np和q的parent，也就是他们的后缀

我们考虑用谁来继承发现都可以！！！因为nq被q和np完全包涵

所以直接用q的和np的任意一个来给nq就可以了（不懂的要好好思考这一步）

好了，就这些，这题就解决了。。。（如果有错误请指出，谢谢）

代码，完结撒花

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){
	int x=0,f=1;
	char p=getchar();
	while(!isdigit(p)){
		if(p=='-') f=-1;
		p=getchar();
	}
	while(isdigit(p)) x=(x<<3)+(x<<1)+(p^48),p=getchar();
	return x*f;
}

const int maxn=1e6+5;

#define mid ((l+r)>>1)

int node_cnt,ls[maxn<<5],rs[maxn<<5],n,m;
int siz[maxn<<5],root[maxn],A[maxn],mx[maxn];
char s[maxn],T[maxn];

struct xx{
	int las=1,tot=1,t[maxn];
	struct node{
		int len,fa,ch[26];
	}dian[maxn];
	inline void modify(int c){
		int p=las,np=las=++tot;dian[np].len=dian[p].len+1;
		for(;p&&!dian[p].ch[c];p=dian[p].fa) dian[p].ch[c]=np;
		if(!p) dian[np].fa=1;
		else{
			int q=dian[p].ch[c];
			if(dian[q].len==dian[p].len+1) dian[np].fa=q;
			else{
				int nq=++tot;dian[nq]=dian[q];dian[nq].len=dian[p].len+1;
				dian[q].fa=dian[np].fa=nq;
				for(;p&&dian[p].ch[c]==q;p=dian[p].fa) dian[p].ch[c]=nq;
			}
		}
	}
	inline void Qsort(){
		for(int i=1;i<=tot;i++) t[dian[i].len]++;
		for(int i=1;i<=n;i++) t[i]+=t[i-1];
		for(int i=tot;i>=1;i--) A[t[dian[i].len]--]=i;
	}
}SA1;

struct xxx{
	int las=1,tot=1,tag[maxn<<1];
	struct node{
		int len,fa,ch[26];
	}dian[maxn<<1];
	inline void clear(){
		for(int i=1;i<=tot;i++){
			dian[i].len=dian[i].fa=0;
			for(int j=0;j<26;j++) dian[i].ch[j]=0;
			tag[i]=0;
		}
		las=tot=1;
	}
	inline void modify(int c,int id){
		int p=las,np=las=++tot;dian[np].len=dian[p].len+1;tag[np]=id;
		for(;p&&!dian[p].ch[c];p=dian[p].fa) dian[p].ch[c]=np;
		if(!p) dian[np].fa=1;
		else{
			int q=dian[p].ch[c];
			if(dian[q].len==dian[p].len+1) dian[np].fa=q;
			else{
				int nq=++tot;dian[nq]=dian[q];dian[nq].len=dian[p].len+1;tag[nq]=tag[np];
				dian[q].fa=dian[np].fa=nq;
                //当然用tag[nq]=tag[q]也对啊
				for(;p&&dian[p].ch[c]==q;p=dian[p].fa) dian[p].ch[c]=nq;
			}
		}
	}
}SA2;

inline void insert(int &x,int l,int r,int pos){
	if(!x) x=++node_cnt;siz[x]++;
	if(l==r) return;
	if(pos<=mid) insert(ls[x],l,mid,pos);
	else insert(rs[x],mid+1,r,pos);
}

inline int merge(int x,int y){
	if(!x||!y) return x+y;
	int z=++node_cnt;siz[z]=siz[x]+siz[y];
	ls[z]=merge(ls[x],ls[y]);
	rs[z]=merge(rs[x],rs[y]);
	return z;
}

inline int query(int x,int l,int r,int L,int R){
	if(L<=l&&r<=R) return siz[x];
	int ans=0;
	if(L<=mid) ans+=query(ls[x],l,mid,L,R);
	if(R>mid) ans+=query(rs[x],mid+1,r,L,R);
	return ans;
}

int main(){
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i<=n;i++) SA1.modify(s[i]-'a'),insert(root[SA1.las],1,n,i);
	SA1.Qsort();
	for(int i=SA1.tot;i>=1;i--) root[(SA1.dian[A[i]].fa)]=merge(root[(SA1.dian[A[i]].fa)],root[A[i]]);
	int tim=read();
	while(tim--){
		SA2.clear();scanf("%s",T+1);m=strlen(T+1);
		for(int i=1;i<=m;i++) SA2.modify(T[i]-'a',i);
		for(int i=1;i<=SA2.tot;i++) mx[i]=0;
		int cur=1,l=0;long long ans=0;
		int L=read(),R=read();
		for(int i=1;i<=m;i++){
			while(1){
				if((SA1.dian[cur].ch[T[i]-'a'])&&(query(root[SA1.dian[cur].ch[T[i]-'a']],1,n,L+l,R))){
					cur=SA1.dian[cur].ch[T[i]-'a'];l++;
					break;
				}
				if(l==0) break;
				l--;
				if(l==SA1.dian[SA1.dian[cur].fa].len) cur=SA1.dian[cur].fa;
			}
			mx[i]=l;
		}
		for(int i=2;i<=SA2.tot;i++){
			ans+=max(0,SA2.dian[i].len-max(SA2.dian[SA2.dian[i].fa].len,mx[SA2.tag[i]]));
		}
		printf("%lld\n",ans);
	}
	return 0;
}


```



























---

## 作者：JoaoFelix (赞：1)

题解为何不是sa就是sam+线段树合并啊？这里是主席树做法，核心思想类似

多串问题第一感觉是要把所有的串都建在广义sam里面，结果发现降智了...

首先我们要做一点重要的转换！

我们设S串是原始串，T串是询问的串

就是我们需要两个sam，具体这个答案的求法就是T串的par树上去重，并且减去最长的在S串匹配的长度，剩余的显然就是新的一种不同类型的串

然后如果68pts，我们直接类似于CTSC2012那题求一个最长匹配，并且在par树上减去贡献即可，但是100pts，我们需要对sam的endpos分类，具体就是要判断当前这个点，这个长度这个endpos的范围有没有出现过？

然后就相当于求子树里的endpos集合的一段区间和，然后这是一段很裸的线段树合并，然而作者很菜，就把他转换成了DFS序+主席树。

（有一点易错的容易wa，现在是97pts以前是96pts的原因，大概是我们在求最长匹配far数组的时候要一个一个像会跳，就是长度-1，不能直接跳par树，这个作者大概感性理解了一下，不太会具体说明原因，会证明或者有详细解释的juju可以在讨论区，欢迎！！！）

这复杂度是一个log的，和线段树合并的复杂度一样！

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 1000005;

int n, pos[N], far[N], sp[N]; char str[N];

struct SuffixAutomaton {
	int ch[N][26], par[N], len[N], tot, lst, root;
	
	int newnode(int l) {
		len[tot] = l; memset(ch[tot], par[tot] = 0, sizeof(ch[tot]));
		return tot++;
	}
	void extend(int c) {
		int p = lst, np = newnode(len[p] + 1);
		while (!ch[p][c]) ch[p][c] = np, p = par[p];
		if (p == root && ch[p][c] == np) par[np] = root;
		else {
			int q = ch[p][c];
			if (len[q] == len[p] + 1) par[np] = q;
			else {
				int nq = newnode(len[p] + 1);
				par[nq] = par[q], par[q] = par[np] = nq;
				memcpy(ch[nq], ch[q], sizeof(ch[nq]));
				while (ch[p][c] == q) ch[p][c] = nq, p = par[p];
			}
		}
		lst = np;
	}
	void init() {
		tot = 0, lst = root = newnode(0);
	}
} S, T;
struct PersistenceTree {
	int rt[N], ls[N << 5], rs[N << 5], sz[N << 5], tot;
	
	void build(int rt, int l, int r) {
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(ls[rt] = ++tot, l, mid);
		build(rs[rt] = ++tot, mid + 1, r);
	}
	void insert(int rt, int pre, int l, int r, int x) {
		sz[rt] = sz[pre] + 1; if (l == r) return;
		ls[rt] = ls[pre], rs[rt] = rs[pre];
		int mid = (l + r) >> 1;
		if (x <= mid) insert(ls[rt] = ++tot, ls[pre], l, mid, x);
		else insert(rs[rt] = ++tot, rs[pre], mid + 1, r, x);
	}
	int ask(int rt, int pre, int l, int r, int ql, int qr) {
		if (ql <= l && r <= qr) return sz[rt] - sz[pre];
		int mid = (l + r) >> 1, ret = 0;
		if (ql <= mid) ret += ask(ls[rt], ls[pre], l, mid, ql, qr);
		if (qr > mid) ret += ask(rs[rt], rs[pre], mid + 1, r, ql, qr);
		return ret;
	}
} pst;

int lnk[N], nxt[N], fst[N], tote;
int dl[N], dr[N], rev[N], dfc;

void adde(int u, int v) {
	lnk[++tote] = v; nxt[tote] = fst[u]; fst[u] = tote;
}
void DFS(int u) {
	dl[u] = ++dfc, rev[dfc] = u;
	for (int i = fst[u]; i; i = nxt[i]) DFS(lnk[i]);
	dr[u] = dfc;
}
bool go(int u, int l, int r, int cur) {
	l += cur - 1; if (l > r) return false;
	int rtl = pst.rt[dl[u] - 1], rtr = pst.rt[dr[u]];
	return pst.ask(rtr, rtl, 1, n, l, r) > 0; 
}
void solve() {
	scanf("%s", str + 1); int l = read(), r = read();
	int nn = strlen(str + 1); T.init();
	for (int i = 1; i <= nn; i++) T.extend(str[i] - 'a'), pos[i] = T.par[T.lst];
	int now = 0, cur = 0;
	for (int i = 1; i <= nn; i++) {
		int c = str[i] - 'a';
		while (true) {
			if (S.ch[now][c] && go(S.ch[now][c], l, r, cur + 1)) {
				now = S.ch[now][c], cur++; break;
			}
			if (!now) break;
			cur--; if (cur == S.len[S.par[now]]) now = S.par[now];
		}
		far[i] = cur;
	}
	ll ans = 0;
	for (int i = 1; i <= nn; i++) {
		int lstl = max(T.len[pos[i]], far[i]);
		// printf("%d %d %d\n", i, T.len[pos[i]], far[i]);
		if (lstl < i) ans += (ll)i - lstl;
	}
	printf("%lld\n", ans);
}

int main() {
	scanf("%s", str + 1); n = strlen(str + 1);
	S.init(); for (int i = 1; i <= n; i++) S.extend(str[i] - 'a'), sp[S.lst] = i;
	for (int i = 1; i < S.tot; i++) adde(S.par[i], i);
	DFS(0), pst.build(pst.rt[0] = pst.tot = 1, 1, n);
	for (int i = 1; i <= S.tot; i++)
		if (sp[rev[i]]) pst.insert(pst.rt[i] = ++pst.tot, pst.rt[i - 1], 1, n, sp[rev[i]]);
		else pst.rt[i] = pst.rt[i - 1];
	int qq = read(); while (qq--) solve();
	return 0;
}
```



---


# [SDOI2017] 遗忘的集合

## 题目描述

小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。

众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。

例如，当 $S=\{1,2,3,4,5\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。

再例如，当 $S=\{1,2,5\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。

麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。

具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。

然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。

对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。


## 说明/提示

对于 $100\%$ 的数据，有 $1 \leq n < 2^{18} , 10^6 \leq p < 2^{30} , 0 \leq f(i) < p\quad (i=1,2, \cdots , n)$。

![](https://cdn.luogu.com.cn/upload/pic/5548.png)


## 样例 #1

### 输入

```
5 1000003
1 2 3 5 7```

### 输出

```
5
1 2 3 4 5```

## 样例 #2

### 输入

```
9 1000003
1 2 2 3 4 5 6 7 8```

### 输出

```
3
1 2 5```

# 题解

## 作者：Salamander (赞：8)

令$a_i=0/1$表示元素$i$是否在集合$S$中，元素$i$的生成函数，为$\displaystyle\left(\frac{1}{1-x^i}\right)^{a_i}$，那么$f$的生成函数$\displaystyle F(x)=\prod_{i\geq 1}\left(\frac{1}{1-x^i}\right)^{a_i}$，现在我们知道了$F(x)$，要求$a_i$。
	
两边同时取负对数，得到$\displaystyle-\ln F(x)=\sum_{i\geq 1}a_i\ln(1-x^i)$，对右边的$\ln(1-x^i)$泰勒展开，得到$\displaystyle-\ln F(x)=\sum_{i\geq 1}a_i\sum_{j\geq 1}-\frac{x^{ij}}{j}$，枚举$ij$的值，得到$\displaystyle\ln F(x)=\sum_{T\geq 1}x^T\sum_{i\mid T}a_i\times\frac{i}{T}$。我们对$F$求一个多项式的$\ln$，那么就可以知道右边$x^T$的系数，即对于所有$T$知道了$\frac{1}{T}\sum_{i\mid T}a_i\times i$，设$G(x)=\ln F(x)$，即有$[x^T]G(x)=\frac{1}{T}\sum_{i\mid T}a_i\times i$，那么只需要莫比乌斯反演即可求出$a_i$。最后只需要对于每个$a_i\neq 0$输出$i$即为答案。由生成函数的构造过程即可证明方案唯一。
	
复杂度$O(n\log n)$，多项式求$\ln$。
```
#include<bits/stdc++.h>

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
	T f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	x*=f;
}

typedef long long LL;
const int maxn=1<<19|1,N=1<<19;
const double pi=acos(-1);
struct E{
	double x,y;
	E(){}
	E(double a,double b){x=a;y=b;}
	E operator=(const int &a){x=a;y=0;return *this;}
	E conj(){return E(x,-y);}
}A[maxn],B[maxn],dfta[maxn],dftb[maxn],dftc[maxn],o[maxn];
E operator+(const E &a,const E &b){return E(a.x+b.x,a.y+b.y);}
E operator-(const E &a,const E &b){return E(a.x-b.x,a.y-b.y);}
E operator*(const E &a,const E &b){return E(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
int n,p,s[maxn],a[maxn],f[maxn],g[maxn],r[maxn],tmp[maxn];
int prime[maxn],cnt,mu[maxn],ans;
bool ok[maxn];

int power(int,int);
void Init(int);
void fft(E*,int);
void mul(int*,int,int*,int,int*,int);
void ln(int*,int,int*);
void inverse(int*,int,int*);

int main(){
	read(n);read(p);
	Init(n);f[0]=1;
	For(i,1,n) read(f[i]);
	ln(f,n,g);
	For(i,1,n) g[i]=1LL*g[i]*i%p;
	For(i,1,n) for(int j=i;j<=n;j+=i) a[j]+=mu[i]*g[j/i];
	For(i,1,n) if(a[i]) ans++;
	printf("%d\n",ans);
	For(i,1,n) if(a[i]) printf("%d ",i);
	putchar(10);
	return 0;
}

void ln(int *x,int n,int *res){
	int inv[maxn],d[maxn];
	For(i,1,n) d[i-1]=1LL*i*x[i]%p;
	memset(inv,0,sizeof inv);
	inverse(x,n+1,inv);
	mul(d,n,inv,n,res,n);
	Rep(i,n,1) res[i]=1LL*res[i-1]*power(i,p-2)%p;
}
void inverse(int *x,int y,int *res){
	if(y==1)return res[0]=power(x[0],p-2),void();
	inverse(x,(y+1)>>1,res);
	mul(x,y-1,res,y-1,tmp,y-1);
	tmp[0]=2-tmp[0]+p;
	For(i,1,y-1) tmp[i]=p-tmp[i];
	mul(tmp,y-1,res,y-1,res,y-1);
}
void fft(E *a,int n){
	For(i,0,n-1) if(i<r[i]) std::swap(a[i],a[r[i]]);
	for(int i=1;i<n;i<<=1)
		for(int j=0,tmp=i<<1;j<n;j+=tmp)
			For(k,0,i-1){
				E x=a[j+k],y=o[N/i*k]*a[j+k+i];
				a[j+k]=x+y;a[j+k+i]=x-y;
			}
}
void mul(int* a,int n,int *b,int m,int *res,int k){
	int M=sqrt(p),nn=n,mm=m,L=-1;
	For(i,0,n) A[i].x=a[i]/M,A[i].y=a[i]%M;
	For(i,0,m) B[i].x=b[i]/M,B[i].y=b[i]%M;
	for(m+=n,n=1;n<=m;n<<=1) L++;
	For(i,0,n-1) r[i]=(r[i>>1]>>1)|((i&1)<<L);
	For(i,nn+1,n-1) A[i]=0;
	For(i,mm+1,n-1) B[i]=0;
	fft(A,n);fft(B,n);
	For(i,0,n-1){
		int j=(n-i)&(n-1);
		E ai=(A[i]+A[j].conj())*E(0.5,0);
		E bi=(A[i]-A[j].conj())*E(0,-0.5);
		E ci=(B[i]+B[j].conj())*E(0.5,0);
		E di=(B[i]-B[j].conj())*E(0,-0.5);
		dfta[i]=ai*ci;
		dftb[i]=ai*di+bi*ci;
		dftc[i]=bi*di;
	}
	For(i,0,n) A[i]=dfta[i]+dftb[i]*E(0,1);
	fft(A,n);fft(dftc,n);
	For(i,0,k){
		int j=(n-i)&(n-1);
		int ai=(LL)(A[j].x/n+0.5)%p;
		int bi=(LL)(A[j].y/n+0.5)%p;
		int ci=(LL)(dftc[j].x/n+0.5)%p;
		res[i]=(1LL*M*M*ai+1LL*M*bi+ci)%p;
	}
	For(i,k+1,n-1) res[i]=0;
}
int power(int x,int y){
	int res=1;
	for(;y;y>>=1,x=1LL*x*x%p) if(y&1) res=1LL*res*x%p;
	return res;
}
void Init(int n){
	mu[1]=1;
	For(i,2,n){
		if(!ok[i]) prime[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++){
			ok[i*prime[j]]=true;
			if(i%prime[j]) mu[i*prime[j]]=-mu[i];
			else mu[i*prime[j]]=0;
		}
	}
	For(i,0,N) o[i]=E(cos(pi*i/N),sin(pi*i/N));
}
```

---

## 作者：litble (赞：6)

# 题面分析

安利博客->[这里](https://blog.csdn.net/litble/article/details/85777386)

对于集合内的数$i$，考虑取多少个它，生成函数为$\sum_{j=0}^{inf} x^{ij}=\frac{1}{1-x^i}$。

设$t_i \in[0,1]$表示集合里是否存在数字$i$，则$f$对应的生成函数就是：

$$F(x)=\prod_{i=1}^{n} (\frac{1}{1-x^i})^{t_i}$$

两边同时取ln（为什么想到取ln？我也不知道啊QAQ）得：

$$-\ln{F(x)}=\sum_{i=1}^{n} t_i \ln{(1-x^i)}$$

对$\ln{(1-x^i)}$求导得：

$$\frac{-ix^{i-1}}{1-x^i}$$

展开得：$$(-ix^{i-1})\sum_{j=0}^{inf} x^{ji} = -\sum_{j=0}^{inf} ix^{ij+i-1}$$

然后积分得：$$-\sum_{j=0}^{inf} \frac{ix^{i(j+1)}}{i(j+1)}=-\sum_{j=1}^{inf} \frac{x^{ij}}{j}$$

将$\ln{(1-x^i)}-\sum_{j=1}^{inf} \frac{x^{ij}}{j}$带入原式得：

$$\ln{F(x)}=\sum_{i=1}^{n}t_i \sum_{j=1}^{inf} \frac{x^{ij}}{j}$$

令$T=ij$，得：

$$\ln{F(x)}=\sum_{T=1}^{inf} (\sum_{d|T} t_i \frac{i}{T}) x^T$$

设$F(x)$求ln后第$i$项为$g_i$，则$g_i=\sum_{d|T} t_i \frac{i}{T}$

那么求$t_i$只用反演即可，发现没必要用莫比乌斯，用每次求出来的$t_i$去减掉它在$i$的倍数项的$g$中的贡献，调和级数复杂度地求$t_i$即可。

这题烦的一点就是……要用MTT。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
int read() {
	int q=0;char ch=' ';
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q;
}
const int N=524300,M=32767;
typedef long long LL;
typedef long double db;
const db pi=acos(-1);
int n,mod,ans;
int rev[N],len[N],F[N],G[N],inv[N];
int k1[N],k2[N],k3[N],k4[N],k5[N];
struct com{db r,i;}a[N],b[N],Aa[N],Ab[N],Ba[N],Bb[N];
com operator + (com A,com B) {return (com){A.r+B.r,A.i+B.i};}
com operator - (com A,com B) {return (com){A.r-B.r,A.i-B.i};}
com operator * (com A,com B) {return (com){A.r*B.r-A.i*B.i,A.r*B.i+A.i*B.r};}
com conj(com A) {return (com){A.r,-A.i};}

int qm(int x) {return x>=mod?x-mod:x;}
int ksm(int x,int y) {
	int re=1;
	for(;y;y>>=1,x=1LL*x*x%mod) if(y&1) re=1LL*re*x%mod;
	return re;
}

void FFT(com *a,int n) {
    for(RI i=0;i<n;++i) if(rev[i]>i) swap(a[i],a[rev[i]]);
    for(RI i=1;i<n;i<<=1) {
        com wn=(com){cos(pi/i),sin(pi/i)};
        for(RI j=0;j<n;j+=(i<<1)) {
            com t1,t2,w=(com){1,0};
            for(RI k=0;k<i;++k,w=w*wn)
                t1=a[j+k],t2=w*a[j+i+k],a[j+k]=t1+t2,a[j+i+k]=t1-t2;
        }
    }
}
void mul(int *ka,int *kb,int *kc,int n) {
    for(RI i=0;i<n;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<(len[n]-1));
    for(RI i=0;i<(n>>1);++i) {
        a[i]=(com){(db)(ka[i]&M),(db)(ka[i]>>15)};
        b[i]=(com){(db)(kb[i]&M),(db)(kb[i]>>15)};
        a[i+(n>>1)]=b[i+(n>>1)]=(com){0,0};
    }
    FFT(a,n),FFT(b,n);
    for(RI i=0;i<n;++i) {
        int j=(n-i)&(n-1);
        com kAa=(a[i]+conj(a[j]))*(com){0.5,0};
        com kAb=(a[i]-conj(a[j]))*(com){0,-0.5};
        com kBa=(b[i]+conj(b[j]))*(com){0.5,0};
        com kBb=(b[i]-conj(b[j]))*(com){0,-0.5};
        Aa[j]=kAa*kBa,Ab[j]=kAa*kBb,Ba[j]=kBa*kAb,Bb[j]=kAb*kBb;
    }
    for(RI i=0;i<n;++i)
        a[i]=Aa[i]+Ab[i]*(com){0,1},b[i]=Ba[i]+Bb[i]*(com){0,1};
    FFT(a,n),FFT(b,n);
    for(RI i=0;i<n;++i) {
        int kAa=(LL)(a[i].r/n+0.5)%mod;
        int kAb=(LL)(a[i].i/n+0.5)%mod;
        int kBa=(LL)(b[i].r/n+0.5)%mod;
        int kBb=(LL)(b[i].i/n+0.5)%mod;
        kc[i]=qm(((LL)kAa+((LL)(kAb+kBa)<<15)+((LL)kBb<<30))%mod+mod);
    }
}

void getJF(int *a,int *b,int n)
	{for(RI i=1;i<n;++i) b[i]=1LL*a[i-1]*inv[i]%mod; b[0]=0;}
void getdao(int *a,int *b,int n)
	{for(RI i=1;i<n;++i) b[i-1]=1LL*a[i]*i%mod; b[n-1]=0;}
void getinv(int *a,int *b,int n) {
	if(n==1) {b[0]=ksm(a[0],mod-2);return;}
	getinv(a,b,n>>1),mul(a,b,k3,n<<1),mul(k3,b,k4,n<<1);
	for(RI i=0;i<n;++i) b[i]=qm(qm(b[i]+b[i])-k4[i]+mod),b[i+n]=0;
}
void getln(int *a,int *b,int n)
	{getdao(a,k1,n),getinv(a,k2,n),mul(k1,k2,k5,n<<1),getJF(k5,b,n);}

int main()
{
	n=read(),mod=read();
	for(RI i=1;i<=n;++i) F[i]=read();
	int kn=1;while(kn<=n) kn<<=1,len[kn]=len[kn>>1]+1;
	len[kn<<1]=len[kn]+1;
	inv[1]=1;for(RI i=2;i<(kn<<1);++i) inv[i]=1LL*inv[mod%i]*qm(mod-mod/i)%mod;
	F[0]=1,getln(F,G,kn);
	for(RI i=1;i<=n;++i) G[i]=1LL*G[i]*i%mod;
	for(RI i=1;i<=n;++i)
		for(RI j=i+i;j<=n;j+=i) G[j]=qm(G[j]-G[i]+mod);
	for(RI i=1;i<=n;++i) if(G[i]) ++ans;
	printf("%d\n",ans);
	for(RI i=1;i<=n;++i) if(G[i]) printf("%d ",i);
	return 0;
}
```

---

## 作者：zhiyangfan (赞：4)

## P3784 [SDOI2017] 遗忘的集合
调了一下午，这不得写篇题解 ~~祭奠~~ 纪念一下。
### 题意
有一个非空集合 $S$，设 $f(x)$ 表示由集合中的数表示出 $x$ 的方案数，数可以重复使用，但不考虑顺序。给出 $f(1\sim n)\bmod{p}$，构造出一个字典序最小的集合 $S$ 满足它对应的 $f$ 与给出的在模 $p$ 意义下相同，题目保证有解。($1\le n<2^{18},10^6\le p<2^{30}$)
### 题解
这道题的正向版，不需要 $\rm MTT$：[P4389 付公主的背包](https://www.luogu.com.cn/problem/P4389)，可以先去那边思考一下再来，会顺畅很多的！

考虑用 $\rm OGF$ 表示出每个数，数 $i$ 的对应的 $\rm OGF$，$F_i(x)$ 为：
$$F_i(x)=\left(\sum_{n\ge 0}x^{ni}\right)^{a_i}=\left(\dfrac{1}{1-x^i}\right)^{a_i}$$
其中 $a_i=[i\in S]$。这样 $f(x)$ 对应的 $\rm OGF$，$F(x)$ 就能被这样表示出来了：
$$F(x)=\sum_{n\ge 0}f(n)x^n=\prod_{i\ge 1}F_i(x)$$
但这个式子很丑，乘法也没法处理，考虑用 $\ln$ 把乘法变成加法：
$$\ln F(x)=\sum_{i\ge 1}\ln F_i(x)=\sum_{i\ge 1}\ln\left(\left(\dfrac{1}{1-x^i}\right)^{a_i}\right)=-\sum_{i\ge 1}a_i\ln(1-x^i)$$
现在我们的重点就放在了 $\ln(1-x^i)$ 上，这玩意是能求出来另一种形式的。个人最近做到的题，涉及到 $\ln$ 化简的，大部分就是尝试求导看看：
$$\ln(1-x^i)=\int\dfrac{\mathrm{d}}{\mathrm{d}x}\ln(1-x^i)=\int\dfrac{-ix^{i-1}}{1-x^i}$$
我们能看到现在积分号里面的就是一个我们知道对应幂级数的封闭形式了：
$$\int\dfrac{-ix^{i-1}}{1-x^i}=-\int\sum_{n\ge 0}ix^{(n+1)i-1}=-\int\sum_{n\ge 1}ix^{ni-1}$$
现在这个式子就很好看了，只需要把积分号算进去：
$$-\int\sum_{n\ge 1}ix^{ni-1}=-\sum_{n\ge 1}\dfrac{ix^{ni-1+1}}{ni-1+1}=-\sum_{n\ge 1}\dfrac{x^{ni}}{n}$$
可喜可贺，这个形式真是好看，我们快点把它带回原式：
$$-\sum_{i\ge 1}a_i\ln(1-x^i)=\sum_{i\ge 1}a_i\sum_{n\ge 1}\dfrac{x^{ni}}{n}$$
好像又没有办法继续了。但我们发现，这个幂级数形式很奇怪，它的 $x$ 指数并不是单独一个字母。所以我们考虑把它变成一个字母，枚举 $t=ni$：
$$\sum_{t\ge 1}\sum_{i|t}a_i\dfrac{x^t}{t/i}=\sum_{t\ge 1}\left(\sum_{i|t}a_i\dfrac{i}{t}\right)x^t$$
诶，看起来是 $\rm OGF$ 的样子了，还记得等式左边的 $\ln F(x)$ 吗？是时候请它回来了：
$$\begin{aligned}\ln F(x)&=\sum_{t\ge 1}\left(\sum_{i|t}a_i\dfrac{i}{t}\right)x^t\\ [x^t]\ln F(x)&=\sum_{i|t}a_i\dfrac{i}{t}\\t[x^t]\ln F(x)&=\sum_{i|t}a_ii\end{aligned}$$
诶这个式子一出来我们就发现左边的 $t[x^t]\ln F(x)$ 是已知的，而右边是待求的，不仅如此，好像还能看到狄利克雷卷积的样子。这都引导着我们考虑莫比乌斯反演。

考虑两个数论函数 $f,g$（这个 $f$ 跟题目中的 $f$ 没关系哈）：
$$f(n)=n[x^n]\ln F(x)\qquad g(n)=a_nn$$
则上面的等式可以用狄利克雷卷积的形式等价表示为：
$$f=g\ast 1$$
由莫比乌斯反演枚举因数的形式：
$$f\ast \mu=g$$
这样我们就得到了算 $g$ 的方法，也进而就得到了答案，注意从这里可以看出题目所给的非空集合是唯一且一定存在的。（因为 $f_0=1$）

总结一下吧，首先我们要对 $f(x)$ 的 $\rm OGF$，$F(x)$ 做一遍多项式 $\ln$ 并求出 $f$，再把它跟 $\mu$ 做狄利克雷卷积就得到了 $g$，用 $g$ 的信息即可得到答案，时间复杂度 $\mathcal{O}(n\log n)$。注意本题要用 $\rm MTT$，代码里采用的是 $9$ 次 $\rm NTT$ 求 $\rm MTT$，非常 low 和慢/kk

```cpp
#include <cstdio>
#include <algorithm>
const int mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, N = 2e6 + 10;
typedef long long ll; const ll mod12 = (ll)mod1 * mod2; int mod;
int ksm(int a, int b, int mod)
{
	int ret = 1;
	while (b)
	{
		if (b & 1) ret = (ll)ret * a % mod;
		a = (ll)a * a % mod; b >>= 1;
	}
	return ret;
}
const int inv1 = ksm(mod1, mod2 - 2, mod2), inv2 = ksm(mod12 % mod3, mod3 - 2, mod3);
struct Int
{
	int A, B, C;
	Int(int x = 0) : A(x), B(x), C(x) { }
	Int(int A, int B, int C) : A(A), B(B), C(C) { }
	friend Int reduce(const Int& x) { return Int(x.A + (x.A >> 31 & mod1), x.B + (x.B >> 31 & mod2), x.C + (x.C >> 31 & mod3)); }
	friend Int operator+(const Int& x1, const Int& x2) { return reduce(Int(x1.A + x2.A - mod1, x1.B + x2.B - mod2, x1.C + x2.C - mod3)); }
	friend Int operator-(const Int& x1, const Int& x2) { return reduce(Int(x1.A - x2.A, x1.B - x2.B, x1.C - x2.C)); }
	friend Int operator*(const Int& x1, const Int& x2) { return Int((ll)x1.A * x2.A % mod1, (ll)x1.B * x2.B % mod2, (ll)x1.C * x2.C % mod3); }
	int get()
	{
		ll x = (ll)(B - A + mod2) % mod2 * inv1 % mod2 * mod1 + A;
		return ((ll)(C - x % mod3 + mod3) % mod3 * inv2 % mod3 * (mod12 % mod) % mod + x) % mod;
	}
	Int rev() { return Int(ksm(A, mod1 - 2, mod1), ksm(B, mod2 - 2, mod2), ksm(C, mod3 - 2, mod3)); }
}A[N], B[N], C[N], D[N]; int rev[N], mu[N], vis[N], p[N], ans[N], f[N], g[N], h[N], F[N], G[N], tp, lim, m;
inline void getLR(int n)
{
	lim = 1; m = 0; while (lim <= n) lim <<= 1, ++m;
	for (int i = 0; i < lim; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (m - 1));
}
inline void NTT(Int* f, int len, int on)
{
	for (int i = 0; i < len; ++i) if (i < rev[i]) std::swap(f[i], f[rev[i]]);
	for (int h = 2; h <= len; h <<= 1)
	{
		Int wn(ksm(3, (mod1 - 1) / h, mod1), ksm(3, (mod2 - 1) / h, mod2), ksm(3, (mod3 - 1) / h, mod3));
		if (on == -1) wn = wn.rev();
		for (int j = 0; j < len; j += h)
		{
			Int w(1);
			for (int k = j; k < j + h / 2; ++k, w = w * wn)
			{
				Int u = f[k], t = w * f[k + h / 2];
				f[k] = u + t; f[k + h / 2] = u - t;
			}
		}
	}	
	if (on == -1) { Int inv(len); inv = inv.rev(); for (int i = 0; i < len; ++i) f[i] = f[i] * inv; }
}

inline void mul(Int* F, Int* G, int* f, int len)
{
	NTT(F, len, 1); NTT(G, len, 1);
	for (int i = 0; i < len; ++i) F[i] = F[i] * G[i];
	NTT(F, len, -1); for (int i = 0; i < len; ++i) f[i] = F[i].get();
}
void getInv(int* f, int* g, int len)
{
    if (len == 1) return g[0] = ksm(f[0], mod - 2, mod), void();
    getInv(f, g, len >> 1); getLR(len);
    for (int i = 0; i < len; ++i) C[i] = f[i], D[i] = g[i];
    for (int i = len; i < lim; ++i) C[i] = D[i] = 0;
    mul(C, D, h, lim); for (int i = 0; i < len; ++i) h[i] = (mod - h[i]) % mod; h[0] += 2;
	for (int i = 0; i < len; ++i) C[i] = g[i], D[i] = h[i];
	for (int i = len; i < lim; ++i) C[i] = D[i] = 0;
	mul(C, D, g, lim);
}
inline void getDer(int* A, int* B, int len) { for (int i = 1; i < len; ++i) B[i - 1] = (ll)i * A[i] % mod; B[len - 1] = 0; }
inline void getInt(int* A, int* B, int len) { for (int i = 1; i < len; ++i) B[i] = (ll)A[i - 1] * ksm(i, mod - 2, mod) % mod; B[0] = 0; }
inline void getLn(int* f, int* g, int len)
{
    getDer(f, F, len); getInv(f, G, len);
    for (int i = 0; i < len; ++i) A[i] = F[i], B[i] = G[i];
    getLR(len); mul(A, B, h, lim); getInt(h, g, len); 
}
inline void getMu(int n)
{
	mu[1] = 1;
	for (int i = 2; i <= n; ++i)
	{
		if (!vis[i]) p[++tp] = i, mu[i] = -1;
		for (int j = 1; j <= tp && (ll)p[j] * i <= n; ++j)
		{
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) { mu[i * p[j]] = 0; break; }
			mu[i * p[j]] = -mu[i];
		}
	}
}
int main()
{
 	int n, m = 1, cnt = 0; scanf("%d%d", &n, &mod);  f[0] = 1; 
 	for (int i = 1; i <= n; ++i) scanf("%d", &f[i]); 
 	while (m <= n) m <<= 1; getLn(f, g, m); getMu(N - 1);
 	for (int i = 1; i <= n; ++i) g[i] = (ll)g[i] * i % mod;
 	for (int i = 1; i <= n; ++i) for (int j = i; j <= n; j += i)
 		(ans[j] += g[i] * mu[j / i]) %= mod, (ans[j] += mod) %= mod;
 	for (int i = 1; i <= n; ++i) if (ans[i]) ++cnt;
 	printf("%d\n", cnt);
 	for (int i = 1; i <= n; ++i) if (ans[i]) printf("%d ", ans[i]);
	puts(""); return 0;
}
```

---

## 作者：jun头吉吉 (赞：4)

## 题意
对于一个集合$S$，每个数有无限个，现在给出组成$x(1\le x\le n)$的方案数$f_x\pmod p$，求$S$
## 题解
生成函数神仙题。stO出题人

首先考虑$a_i\in\{0,1\}$表示第$i$个数选还是不选，不难发现第$i$个数的生成函数就为$1+a_i(x^i+x^{2i}+x^{3i}+\ldots)$，封闭形式为$(\frac{1}{1-x^i})^{a_i}$

题目给出的方案看做生成函数，记做$F$，有
$$F(x)=\prod_{i=1}^n(\frac{1}{1-x^i})^{a_i}$$

两边同取$ln$，得到：

$$\ln F(x)=\sum_{i=1}^na_i\ln \frac{1}{1-x^i}$$

~~我们知道~~$\ln\frac{1}{1-x^i}=\sum_{j=1}^{+\infty}\frac{x_{ij}}{j}$，简单证明一下：

$\ln \frac{1}{1-x_i}=-\ln(1-x_i)$

对右式求导得到：$(-\ln(1-x_i))^\prime=\frac{ix^{i-1}}{1-x^i}$

我们知道：$\frac{1}{1-x^i}$就是$1+x^i+x^{2i}+\ldots$的封闭形式，即$\sum_{j=0}^{+\infty}x^{ij}$

带回，有：$\frac{ix^{i-1}}{1-x^i}=\sum_{j=0}^{+\infty}ix^{i(j+1)-1}=\sum_{j=1}^{+\infty}ix^{ij-1}$

那么$\ln\frac{1}{1-x^i}=\int \sum_{j=1}^{+\infty}ix^{ij-1}=\sum_{j=1}^{+\infty}\frac{x_{ij}}{j}$

$$\ln F(x)=\sum_{i=1}a_i\sum_{j=1}\frac{x^{ij}}{j}$$

做过莫反的都知道，可以设$T=ij$
$$\ln F(x)=
\sum_{T=1}(\sum_{i|T}a^i\times\frac iT)x^T$$

$$T[x^T]\ln F(x)=\sum_{i|T}a_i\times i$$

中间的狄利克雷卷积已经很明显了。设两个数论函数$f(T)=T[x^T]\ln F(x)$，$g(T)=a_T\times T$，那么：

$$f=g * I$$

两边同乘$\mu$得到：

$$f*\mu=g*I*\mu=g*(I*\mu)=g*\varepsilon=g$$

$O(n\ln n)$求$f*\mu$即可
## 代码
U1S1`vector`常数就是大
```cpp
#include<bits/stdc++.h>
namespace in{
    #ifdef slow
    inline int getc(){return getchar();}
    #else
    char buf[1<<21],*p1=buf,*p2=buf;
    inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    #endif
    template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+(ch-48);ch = getc();}if(f)t=-t;
	}
    template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
namespace Math{
	const int N=300000+50;
	int prime[N],tot,miu[N];
	bool isprime[N];
	void init(){
		memset(isprime,0xff,sizeof isprime);
		tot=0;miu[1]=1;
		for(int i=2;i<N;i++){
			if(isprime[i])
				prime[++tot]=i,miu[i]=-1;
			for(int j=1;j<=tot&&i*prime[j]<N;j++){
				isprime[i*prime[j]]=false;
				if(i%prime[j])
					miu[i*prime[j]]=-miu[i];
				else
					miu[i*prime[j]]=0;
			}
		}
	}
}
typedef std::complex<double>complex;
const int N=4e6+10;const double PI=acos(-1);const complex I=complex(0,1);
int rev[N];complex Wn[N];int M,mod;
int ksm(int x,int y) {
	int re=1;
	for(;y;y>>=1,x=1LL*x*x%mod)if(y&1)re=1LL*re*x%mod;
	return re;
}
inline long long num(complex x){double d=x.real();return d<0?(long long)(d-0.5)%mod:(long long)(d+0.5)%mod;}
struct poly{
	std::vector<complex>a0,a1;
	int size(){return a0.size();}
    void resize(int n){a0.resize(n);a1.resize(n);}
	void set(int x,long long y){
		y%=mod;
		a0[x]=y/M;
		a1[x]=y%M;
	}
	long long get(int x){return (M*M*num(a0[x].real())%mod +
				M*(num(a0[x].imag())+num(a1[x].real()))%mod+num(a1[x].imag()))%mod;}
	long long val(int x){return (long long)(M*a0[x].real()+a1[x].real()+mod)%mod;}
};
poly operator+(poly a,poly b){
    int n=std::max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a.set(i,a.val(i)+b.val(i));return a;
}
poly operator-(poly a,poly b){
    int n=std::max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a.set(i,a.val(i)-b.val(i));return a;
}
inline poly one(){poly a;a.resize(1);a.set(0,1);return a;}
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){
	int n=1<<k;
	for(int i=0;i<n;i++)
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
	for(int i=0;i<n;i++)
		Wn[i]={cos(PI/n*i),sin(PI/n*i)};
}
void FFT(std::vector<complex>&A,int n,int t){
	if(t<0)for(int i=1;i<n;i++)if(i<(n-i))std::swap(A[i],A[n-i]);
	for(int i=0;i<n;i++)
		if(i<rev[i])std::swap(A[i],A[rev[i]]);
	for(int m=1;m<n;m<<=1)
		for(int i=0;i<n;i+=m<<1)
			for(int k=i;k<i+m;k++){
				complex W=Wn[1ll*(k-i)*n/m];
				complex a0=A[k],a1=A[k+m]*W;
				A[k]=a0+a1;A[k+m]=a0-a1; 
			}
	if(t<0)for(int i=0;i<n;i++)A[i]/=n;
}
void MTT(poly &A,int n,int t){
	for(int i=0;i<n;i++)A.a0[i]=A.a0[i]+I*A.a1[i];
	FFT(A.a0,n,t);
	for(int i=0;i<n;i++)A.a1[i]=std::conj(A.a0[i?n-i:0]);
	for(int i=0;i<n;i++){
		complex p=A.a0[i],q=A.a1[i];
		A.a0[i]=(p+q)*0.5;A.a1[i]=(q-p)*0.5*I;
	}
}
inline poly operator*(poly a,poly b){
    int n=a.size()+b.size()-1,k=ext(n);
    a.resize(1<<k),b.resize(1<<k),init(k);
    MTT(a,1<<k,1);MTT(b,1<<k,1);
	for(int i=0;i<(1<<k);i++){
		complex p=a.a0[i]*b.a0[i]+I*a.a1[i]*b.a0[i];
		complex q=a.a0[i]*b.a1[i]+I*a.a1[i]*b.a1[i];
		a.a0[i]=p,a.a1[i]=q;
	}
    FFT(a.a0,1<<k,-1);FFT(a.a1,1<<k,-1);a.resize(n);
	long long tmp;for(int i=0;i<n;i++)
		tmp=a.get(i),a.set(i,tmp);
	return a;
}
inline poly deriv(poly a){//求导 
    int n=a.size()-1;
    for(int i=0;i<n;i++)a.set(i,a.val(i+1)*(i+1));
    a.resize(n);return a;
}
inline poly inter(poly a){//求原 
    int n=a.size()+1;a.resize(n);
    for(int i=n;i>=1;i--)a.set(i,a.val(i-1)*ksm(i,mod-2));
    a.set(0,0);return a;
}
poly inv(poly F,int k){
    int n=1<<k;F.resize(n);
    if(n==1){F.set(0,ksm(F.val(0),mod-2));return F;}
    poly G,H=inv(F,k-1);
    G.resize(n),H.resize(n<<1),F.resize(n<<1);
    for(int i=0;i<n/2;i++)G.set(i,H.val(i)*2);
    H=H*H;H.resize(n);H=H*F;H.resize(n);
    G=G-H;return G;
}
inline poly inv(poly a){
    int n=a.size();
    a=inv(a,ext(n)),a.resize(n);return a;;
}
inline poly ln(poly a){
    int n=a.size();
    a=inter(deriv(a)*inv(a));
    a.resize(n);return a;
}
int n;poly F,G;
int f[N],g[N];
signed main(){
	Math::init();
	in::read(n,mod);M=sqrt(mod);F.resize(n+1);F.set(0,1);
	for(int i=1,x;i<=n;i++)in::read(x),F.set(i,x);
	G=ln(F);
	//for(int i=1;i<=n;i++)std::cout<<G.val(i)<<" ";
	//return 0;
	for(int i=1;i<=n;i++)g[i]=1ll*G.val(i)*i%mod;
	for(int i=1;i<=n;i++)for(int j=1;i*j<=n;j++)
		f[i*j]=(f[i*j]+Math::miu[i]*g[j])%mod;
	int ans=0;
	for(int i=1;i<=n;i++)if(f[i])ans++;
	out::write(ans);out::putc('\n');
	for(int i=1;i<=n;i++)if(f[i])out::write(i),out::putc(' ');
	out::flush();
}
```

---

## 作者：ニヒル (赞：4)

emmm，只要做过付公主的背包，这题就还算清真了  
首先还是对生成函数求逆，我们知道$ln(f(x))=\sum_{i=1}^{n}{\frac{a_i}{x}*[x\, \%a_i\,=0]}$
假设我们已经求出了这个逆  
感受一下上面那个式子，显然求逆以后第一个有值的位置对应的数字一定是被选的，这个应该很好理解。  
然后这个数字i会对他的每个倍数j产生$\frac{i}{j}$的贡献  
把他从对应的位置减掉就可以了，然后显然下一个要选的肯定是他之后第一个有值的位置，如此搞下去可以调和级数求解。  
最后把有数字的位置输出来就可以了  
这个用贪心的思路去想一定是字典序最小的最优解。  
而且，应该也是唯一解吧

然后每次都被卡常……
三模NTT要整整十秒 
```cpp
#include<bits/stdc++.h>
#define gg 3
#define N 600030
using namespace std;

long long ans[N],f[3][N],g[3][N],mod1[]={998244353,469762049,1004535809};
long long inv[N],tmp1[N],tmp2[N],s[N],ln[N],de[N],in[N]; 
int r[N],n,m,p;

inline long long mul(long long a,long long b,long long mod)
{
    long long res=a*b-(long long)((long double)a*b/mod+0.5)*mod;
    return res<0?res+mod:res;
}

long long kasumi(long long a,long long b,long long mod)
{
    long long ans=1;
    while(b)
    {
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}

void NTT(long long *a,int kd,int mod,int lim)
{
    for(int i=0;i<lim;i++)
    {
        if(i<r[i]) swap(a[i],a[r[i]]);
    }
    for(int mid=1;mid<lim;mid<<=1)
    {
        long long wn=kasumi(gg,(mod-1)/(mid<<1),mod);
        if(kd) wn=kasumi(wn,mod-2,mod);
        for(int i=0;i<lim;i+=mid<<1)
        {
            long long w=1;
            for(int j=0;j<mid;j++,w=wn*w%mod)
            {
                long long x=a[i+j];
                long long y=a[i+j+mid]*w%mod;
                a[i+j]=(x+y)%mod;
                a[i+j+mid]=(x-y+mod)%mod;
            }
        }
    }
    if(kd)
    {
        int inv=kasumi(lim,mod-2,mod);
        for(int i=0;i<lim;i++) a[i]=a[i]*inv%mod;
    }
}

void mul1(long long *a,long long *b,int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        f[0][i]=f[1][i]=f[2][i]=a[i];
        g[0][i]=g[1][i]=g[2][i]=b[i];
        ans[i]=0;
    }
    for(int i=0;i<lim;i++)
    {
        r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
    }
    for(int i=0;i<=2;i++)
    {
        NTT(f[i],0,mod1[i],lim);NTT(g[i],0,mod1[i],lim);
        for(int j=0;j<lim;j++)
        {
            f[i][j]=f[i][j]*g[i][j]%mod1[i];
        }
        NTT(f[i],1,mod1[i],lim);
    }
    long long inv1=kasumi(mod1[0],mod1[1]-2,mod1[1]);
    long long inv2=kasumi(mod1[1],mod1[0]-2,mod1[0]);
    long long mul1=mod1[0]*mod1[1];
    for(int i=0;i<lim;i++)
    {
        ans[i]+=mul(f[0][i]*inv2%mul1,mod1[1],mul1);
        ans[i]+=mul(f[1][i]*inv1%mul1,mod1[0],mul1);
        ans[i]%=mul1;
    }
    long long inv3=kasumi(mul1%mod1[2],mod1[2]-2,mod1[2]);
    for(int i=0;i<lim;i++)
    {
        ans[i]=((f[2][i]-ans[i]%mod1[2]+mod1[2])%mod1[2]*inv3%mod1[2]*(mul1%p)%p+ans[i]%p)%p;
    }
}

void der(const long long *a,int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        de[i]=a[i+1]*(i+1)%p;
    } 
}

void inte(const long long *a,int cnt)
{
    int lim=1<<cnt;
    for(int i=lim-1;i>=1;i--)
    {
        in[i]=a[i-1]*kasumi(i,p-2,p)%p;
    }
}

void get_inv(const long long *a,int len)
{

    int cnt=0;
    for(int i=0;i<len;i++) tmp1[i]=tmp2[i]=inv[i]=0;
    inv[0]=kasumi(a[0],p-2,p);
    int lim=1;
    while(lim<len)
    {
        cnt++;
        lim<<=1;
        for(int i=0;i<lim>>1;i++)
        {
            tmp1[i]=inv[i];
            tmp2[i]=a[i];
        }
        mul1(tmp1,tmp2,cnt);
        for(int i=0;i<lim>>1;i++)
        {
            tmp2[i]=ans[i];
        }
        mul1(tmp1,tmp2,cnt);
        for(int i=0;i<lim>>1;i++)
        {
            inv[i]=(inv[i]*2ll%p-ans[i]+p)%p;
        }
    }
}

void get_ln(const long long *a,int len)
{
    int lim=1,cnt=0;
    while(lim<len) lim<<=1,cnt++;
    get_inv(a,lim);
    der(a,cnt);
    mul1(inv,de,cnt);
    inte(ans,cnt);
}

int main()
{
    scanf("%d%d",&n,&p);
    s[0]=1;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&s[i]);
    }
    get_ln(s,(n+1)*2);
    for(int i=1;i<=n;i++) in[i]=in[i]*i%p;
    for(int i=1;i<=n;i++)
    {
        for(int j=i*2;j<=n;j+=i)
        {
            in[j]=(in[j]-in[i]+p)%p;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(in[i]) ans++;
    }
    printf("%d\n",ans);
    for(int i=1;i<=n;i++) if(in[i]) printf("%d ",i);
}
```

换上不加黑科技的拆系数FFT就三秒左右了
```cpp
#include<bits/stdc++.h>
#define sz 32768
#define N 600030
using namespace std;

long long ans[N];
long long inv[N],tmp1[N],tmp2[N],s[N],ln[N],de[N],in[N]; 
int r[N],n,m,p;

long long kasumi(long long a,long long b,long long mod)
{
    long long aa=1;
    while(b)
    {
        if(b&1) aa=aa*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return aa;
}

const long double pi=std::acos(-1);

struct comp
{
    long double r,i;
    comp(){}
    comp(long double a,long double b):r(a),i(b){}
}f[2][N],g[2][N],t1[N],t2[N],t3[N];

inline comp operator +(const comp a,const comp b) {return comp(a.r+b.r,a.i+b.i);}

inline comp operator -(const comp a,const comp b) {return comp(a.r-b.r,a.i-b.i);}

inline comp operator *(const comp a,const comp b) {return comp(a.r*b.r-a.i*b.i,a.r*b.i+b.r*a.i);}

void FFT(comp *a,int kd,int lim)
{
    for(int i=0;i<lim;i++) if(i<r[i]) swap(a[i],a[r[i]]);
    for(int mid=1;mid<lim;mid<<=1)
    {
        comp wn=comp(std::cos(pi/mid),kd*std::sin(pi/mid));
        for(int i=0;i<lim;i+=(mid<<1))
        {
            comp w=comp(1.0,0.0);
            for(int j=0;j<mid;j++,w=wn*w)
            {
                comp x=a[i+j];
                comp y=a[i+j+mid]*w;
                a[i+j]=x+y;
                a[i+j+mid]=x-y;
            }
        }
    }
    if(kd==-1)
    {
        for(int i=0;i<lim;i++)
        {
            a[i].r/=lim;
        }
    }
}


void mul1(long long *a,long long *b,int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        f[0][i].r=a[i]/sz;
        f[0][i].i=0;
        f[1][i].r=a[i]%sz;
        f[1][i].i=0;
        g[0][i].r=b[i]/sz;
        g[0][i].i=0;
        g[1][i].r=b[i]%sz;
        g[1][i].i=0;
        ans[i]=0;
    }
    for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
    FFT(f[0],1,lim);FFT(f[1],1,lim);
    FFT(g[0],1,lim);FFT(g[1],1,lim);
    for(int i=0;i<lim;i++)
    {
        t1[i]=f[0][i]*g[0][i];
        t2[i]=f[0][i]*g[1][i]+g[0][i]*f[1][i];
        t3[i]=f[1][i]*g[1][i];
    }
    FFT(t1,-1,lim);FFT(t2,-1,lim);FFT(t3,-1,lim);
    for(int i=0;i<lim;i++)
    {
        ans[i]=(((long long)(t1[i].r+0.5))%p*sz%p*sz%p+(((long long)(t2[i].r+0.5))%p*sz%p)+(long long)(t3[i].r+0.5)%p)%p;
    }
}

void der(const long long *a,int cnt)
{
    int lim=1<<cnt;
    for(int i=0;i<lim;i++)
    {
        de[i]=a[i+1]*(i+1)%p;
    } 
}

void inte(const long long *a,int cnt)
{
    int lim=1<<cnt;
    for(int i=lim-1;i>=1;i--)
    {
        in[i]=a[i-1]*kasumi(i,p-2,p)%p;
    }
}

void get_inv(const long long *a,int len)
{

    int cnt=0;
    for(int i=0;i<len;i++) tmp1[i]=tmp2[i]=inv[i]=0;
    inv[0]=kasumi(a[0],p-2,p);
    int lim=1;
    while(lim<len)
    {
        cnt++;
        lim<<=1;
        for(int i=0;i<lim>>1;i++)
        {
            tmp1[i]=inv[i];
            tmp2[i]=a[i];
        }
        mul1(tmp1,tmp2,cnt);
        for(int i=0;i<lim>>1;i++)
        {
            tmp2[i]=ans[i];
        }
        mul1(tmp1,tmp2,cnt);
        for(int i=0;i<lim>>1;i++)
        {
            inv[i]=(inv[i]*2ll%p-ans[i]+p)%p;
        }
    }
}

void get_ln(const long long *a,int len)
{
    int lim=1,cnt=0;
    while(lim<len) lim<<=1,cnt++;
    get_inv(a,lim);
    der(a,cnt);
    mul1(inv,de,cnt);
    inte(ans,cnt);
}

int main()
{
    scanf("%d%d",&n,&p);
    s[0]=1;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&s[i]);
    }
    get_ln(s,(n+1)*2);
    for(int i=1;i<=n;i++) in[i]=in[i]*i%p;
    for(int i=1;i<=n;i++)
    {
        for(int j=i*2;j<=n;j+=i)
        {
            in[j]=(in[j]-in[i]+p)%p;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(in[i]) ans++;
    }
    printf("%d\n",ans);
    for(int i=1;i<=n;i++) if(in[i]) printf("%d ",i);
}
```


---

## 作者：Lyrella (赞：2)

# 简要题意

你有若干中不同的物品，每个物品都有体积。每种体积为 $V_i$ 的物品都有无限种。但是现在你只知道恰好装满一个体积为 $S,S\in[1,n]$ 的背包的方案数，求物品的种类数以及每种物品的体积。

# 题解

首先你可以联想到[这道题的简单版](https://www.luogu.com.cn/problem/P4389)。考虑“付公主的背包”（简单版）是给你物品求体积不同的背包的方案数，此题要求的是这个的逆过程。这或许能给人一些启发。

首先我们可以用生成函数刻画出每种物品，即使我们还不知道物品的体积。对于一个体积为 $i$ 的物品，其生成函数为：

$$
\sum_{j>0}x^{ij}
$$

但是我们还不确定这类物品是否存在，于是我们设计一个函数 $g_i$ 表示体积为 $i$ 的物品是否存在，注意 $g_i$ 的值为 $0/1$。如果 $i$ 存在贡献就是上面的生成函数，否则就是 $1$，于是我们巧妙地将 $g_i$ 放进生成函数中：

$$
\left(\sum_{j>0}x^{ij}\right)^{g_i}
$$

然后考虑背包的生成函数 $F$，这就是“付公主的背包”那道题：

$$
F(x)=\prod_{i=1}^{n}\left(\sum_{j>0}x^{ij}\right)^{g_i}=\prod_{i=1}^{n}\left({1\over1-x^i}\right)^{g_i}
$$

我们还是熟悉的套路：对于 $\prod$ 我们不好处理于是套上 $\ln\exp$ 使其变成 $\sum$（下文对两边求 $\ln$）：

$$
\ln F(x)=g_i\sum_{i=1}^{n}\ln\left({1\over1-x^i}\right)=g_i\sum_{i=1}^{n}\sum_j{x^{ij}\over j}
$$

上面这个式子的推导可看[我写的“付公主的背包”的题解](https://www.cnblogs.com/Lyrella/p/18779868)。

因为我们已知的是 $f_i$ 但要求的是 $g_i$，所以我们整理一下等式得到：

$$
\sum_{i=1}^nf_ix^i=\sum_{i=1}^{n}{x^i\over i}\sum_{d|i}g_d\times d
$$

我们对每一项提取系数得到：

$$
i\times f_i=\sum_{d|i}g_d\times d
$$

发现右边是卷积的形式于是用莫反 $f(i)=\sum_{d|i}g(d)\Leftrightarrow\sum_{d|i}f(d)\times\mu({i\over d})=g(i)$ 即可得到 $g$。实际算的时候可以枚举因数这样时间复杂度就是 $O(n\ln n)$ 的，再加上前面多项式求 $\ln$ 的复杂度一共 $O(n\log n+n\ln n)$，注意模数。

---

## 作者：Terac (赞：2)

[$\texttt{link}$](https://www.luogu.com.cn/problem/P3784)

## 题意

集合 $S$ 中有若干种物品，每种物品体积为 $v_i$，且有无限个，$\forall i\in\left[1,m\right]$，用 $S$ 中的物品装 $i$ 体积的方案数为 $f_i$，现给出 $f_i \bmod p$，求 $S$。

$1\le m<2^{18},10^6\le p<2^{30},p\in \mathbf{Prime}$

## 题解

题意本来不是这样表述的，我改成这样是为了与 [P4389](https://www.luogu.com.cn/problem/P4389) 对比，可以看下我那题的 [Solution](https://www.luogu.com.cn/blog/WaterAche/solution-p4389)，这道题就是逆了过来。

考虑若给出 $S$，求 $f_i$ 该怎么做，设 $n=|S|$。

写出 $f$ 的 OGF $F(x)=\sum\limits_{i=0}^\infty f_ix^i$。

若仅有一个体积为 $v$ 的物品，$F(x)=\sum\limits_{i=0}^\infty \left[v|i\right]x^i=\sum\limits_{i\ge 1}x^{iv}$。

如果表为 $1+x^v+x^{2v}+\cdots$，这个等比数列求和很熟悉吧？乘个 $x^v$ 相减得 $F(x)=\sum\limits_{i\ge 1} x^{iv}=\dfrac{1}{1-x^v}$。

那么答案即为 $n$ 个这样的生成函数的卷积。

如果直接暴力乘，复杂度为 $O(nm\log m)$，肯定不行。

前面的形式幂形式不大好搞，我们考虑怎么卷这个封闭形式。

一个经典 trick，可以用取 $\ln$ 的方式把乘变成加，令 $G(x)=\ln F(x)$，有

$$\begin{aligned}G'(x)&=\ln'F(x)\\&=\dfrac{F'(x)}{F(x)}\\&=\dfrac{F'(x)}{\frac{1}{1-x^v}}\\&=(1-x^v)\sum\limits_{i\ge1}iv\cdot x^{iv-1}\\&=\sum\limits_{i\ge1}iv\cdot x^{iv-1}-\sum\limits_{i\ge1}iv\cdot x^{(i+1)v-1}\\&=\sum\limits_{i\ge1}iv\cdot x^{iv-1}-\sum\limits_{i\ge2}(i-1)v\cdot x^{iv-1}\\&=v\cdot x^{v-1}+\sum\limits_{i\ge2}iv\cdot x^{iv-1}-\sum\limits_{i\ge2}(i-1)vx^{iv-1}\\&=\sum\limits_{i\ge1}vx^{iv-1}\end{aligned}$$

两边积回来

$$G(x)=\sum\limits_{i\ge 1}\dfrac{1}{i}x^{iv}$$

于是枚举 $m$ 种体积，如果有该体积的物品直接在对应次项系数上加，最后做一次 $\exp$ 即可，时间复杂度 $O(m\log m)$。

那反过来想，现在知道 $F(x)$，先做一次 $\ln$ 求出 $G(x)$，思考能否根据 $G(x)$ 求出 $S$。

考虑一个贪心的取法，因为每一项的系数都是由它的次数的因数所贡献的，所以我们从小到大扫一遍。

设 $a=\min\{k|\left[ x^k\right]G(x)\not=0\}$，即当前次数最小的，且系数不为 $0$ 的项。

因为 $a$ 次以下的项系数均为 $0$ 肯定没有它的因数可以给它贡献了，说明 $S$ 中必有体积为 $a$ 的物品，将所有 $a$ 的倍数次项的贡献都减掉，再去看下一个，重复这个过程直到 $G(x)=0$。

容易证明这样构造是合法的，且是唯一解。

时间复杂度 $O(m\log m)$。

但这道题的恶心之处在于它任意模数，要 MTT，不想写也不会写，所以没有代码。

---

## 作者：Leasier (赞：2)

前置芝士：[多项式对数函数](https://oi-wiki.org/math/poly/ln-exp/)

不难想到这是一个无限背包，令 $F(x) = 1 + \displaystyle\sum_{i = 1}^n f(i) x^i$，则根据无限背包的生成函数可知：$F(x) \equiv \displaystyle\prod_{i \in S} \frac{1}{1 - x^i} \pmod{x^{n + 1}}$。

套路地，我们对两边分别取对数，有：$\ln F(x) \equiv -\displaystyle\sum_{i \in S} \ln (1 - x^i) \pmod{x^{n + 1}}$。

根据多项式对数函数的公式，有：$\ln F(x) \equiv \displaystyle\sum_{i \in S} \sum_{j = 1} \frac{x^{ij}}{j} \pmod{x^{n + 1}}$。

枚举 $T = ij$，有：$\ln F(x) \equiv \displaystyle\sum_{T = 1}^n x^T \sum_{j \mid T} \frac{[\frac{T}{j} \in S]}{j} \equiv \displaystyle\sum_{T = 1}^n \frac{x^T}{T} \sum_{j \mid T} [\frac{T}{j} \in S] \frac{T}{j} \equiv \displaystyle\sum_{T = 1}^n \frac{x^T}{T} \sum_{i \mid T} [i \in S] i \pmod{x^{n + 1}}$。

于是我们直接求出 $F(x)$ 的对数函数，将其每个系数乘上其下标，并对其系数做狄利克雷前缀差分（这里可以直接暴力枚举倍数），答案为所有有值的做差分后的下标。时间复杂度为 $O(n \log n)$。

注意要写 MTT，因为这道题模数不保证为 NTT 质数。

代码：
```cpp
#include <iostream>
#include <cmath>

using namespace std;

typedef long long ll;

typedef struct {
	int n;
	ll a[524297];
	
	inline void clear(int limit){
		for (register int i = n + 1; i < limit; i++){
			a[i] = 0;
		}
	}
} Polynomial1;

typedef struct Complex_tag {
	double re;
	double im;
	Complex_tag(){
		re = im = 0.0;
	}
	Complex_tag(double re_, double im_){
		re = re_;
		im = im_;
	}
} Complex;

typedef struct {
	int n;
	Complex a[524297];
	
	inline void clear(int limit){
		for (register int i = n + 1; i < limit; i++){
			a[i] = Complex();
		}
	}
} Polynomial2;

const double pi = acos(-1.0);
Polynomial1 f, g, temp1, temp2, temp3;
Polynomial2 temp4, temp5, temp6, temp7;
int rev[524297];
ll number_inv[262147];
Complex w[524297];

Complex operator *(const Complex a, const Complex b){
	return Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
}

Complex operator +(const Complex a, const Complex b){
	return Complex(a.re + b.re, a.im + b.im);
}

Complex operator -(const Complex a, const Complex b){
	return Complex(a.re - b.re, a.im - b.im);
}

Complex operator *=(Complex &a, const Complex b){
	return a = a * b;
}

Complex operator /(const Complex a, const int b){
	return Complex(a.re / b, a.im / b);
}

Complex operator /=(Complex &a, const int b){
	return a = a / b;
}

inline void init1(int n){
	int m = n >> 1;
	for (register int i = 1; i < n; i++){
		rev[i] = rev[i >> 1] >> 1;
		if (i & 1) rev[i] += m;
	}
}

inline void FFT(Polynomial2 &a, int limit, int type){
	for (register int i = 0; i < limit; i++){
		if (i < rev[i]) swap(a.a[i], a.a[rev[i]]);
	}
	w[0] = Complex(1.0, 0.0);
	for (register int i = 1; i < limit; i <<= 1){
		int j = i << 1;
		Complex wn(cos(2 * pi / j), type * sin(2 * pi / j));
		for (register int k = j - 2; k >= 0; k -= 2){
			w[k] = w[k >> 1];
			w[k + 1] = w[k] * wn;
		}
		for (register int k = 0; k < limit; k += j){
			int r = k + i;
			for (register int l = k; l < r; l++){
				int x = l + i;
				Complex y = a.a[l], z = w[l - k] * a.a[x];
				a.a[l] = y + z;
				a.a[x] = y - z;
			}
		}
	}
	if (type == -1){
		for (register int i = 0; i < limit; i++){
			a.a[i] /= limit;
		}
	}
}

inline void MTT(Polynomial1 &a, Polynomial1 &b, int mod){
	int limit = 1, t = a.n + b.n;
	while (limit <= t) limit <<= 1;
	init1(limit);
	temp4.n = a.n;
	temp5.n = b.n;
	temp6.n = temp7.n = t;
	temp4.clear(limit);
	temp5.clear(limit);
	temp6.clear(limit);
	temp7.clear(limit);
	for (register int i = 0; i <= a.n; i++){
		temp4.a[i] = Complex(a.a[i] >> 15, a.a[i] & 32767);
	}
	a.n = t;
	for (register int i = 0; i <= b.n; i++){
		temp5.a[i] = Complex(b.a[i] >> 15, b.a[i] & 32767);
	}
	FFT(temp4, limit, 1);
	FFT(temp5, limit, 1);
	for (register int i = 0; i < limit; i++){
		int t = (limit - i) % limit;
		Complex x = temp4.a[i] * temp5.a[i], y = temp4.a[i] * Complex(temp5.a[t].re, -temp5.a[t].im);
		temp6.a[i] = (x + y) / 2;
		temp7.a[i] = (x - y) / 2;
	}
	FFT(temp6, limit, -1);
	FFT(temp7, limit, -1);
	for (register int i = 0; i <= a.n; i++){
		a.a[i] = ((1 << 30) * ((ll)round(temp6.a[i].re) % mod) % mod + (1 << 15) * ((ll)(round(temp6.a[i].im) + round(temp7.a[i].im)) % mod) % mod + (ll)(mod - round(temp7.a[i].re)) % mod) % mod;
	}
}

inline void init2(int n, int mod){
	number_inv[0] = number_inv[1] = 1;
	for (register int i = 2; i <= n; i++){
		number_inv[i] = mod - (mod / i) * number_inv[mod % i] % mod;
	}
}

inline void derivative(Polynomial1 &a, Polynomial1 &b, int mod){
	b.n = a.n - 1;
	for (register int i = 0; i <= b.n; i++){
		b.a[i] = (i + 1) * a.a[i + 1] % mod;
	}
}

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

void poly_inv(Polynomial1 &a, Polynomial1 &b, int len, int mod){
	if (len == 0){
		b.n = 0;
		b.a[0] = quick_pow(a.a[0], mod - 2, mod);
		return;
	}
	poly_inv(a, b, len / 2, mod);
	b.n = len;
	temp1.n = len;
	for (register int i = 0; i <= len; i++){
		temp1.a[i] = a.a[i];
	}
	MTT(temp1, b, mod);
	temp1.n = len;
	temp1.a[0] = ((2 - temp1.a[0]) % mod + mod) % mod;
	for (register int i = 1; i <= temp1.n; i++){
		temp1.a[i] = (mod - temp1.a[i]) % mod;
	}
	MTT(b, temp1, mod);
	b.n = len;
}

inline void integrate(Polynomial1 &a, Polynomial1 &b, int mod){
	b.n = a.n + 1;
	b.a[0] = 0;
	for (register int i = 1; i <= b.n; i++){
		b.a[i] = a.a[i - 1] * number_inv[i] % mod;
	}
}

inline void ln(Polynomial1 &a, Polynomial1 &b, int len, int mod){
	derivative(a, temp2, mod);
	poly_inv(a, temp3, len, mod);
	MTT(temp2, temp3, mod);
	temp2.n = len;
	integrate(temp2, b, mod);
}

int main(){
	int n, p, ansm = 0;
	cin >> n >> p;
	f.n = n;
	f.a[0] = 1;
	init2(n, p);
	for (register int i = 1; i <= n; i++){
		cin >> f.a[i];
	}
	ln(f, g, n, p);
	for (register int i = 1; i <= n; i++){
		g.a[i] = i * g.a[i] % p;
	}
	for (register int i = 1; i * 2 <= n; i++){
		for (register int j = i * 2; j <= n; j += i){
			g.a[j] = ((g.a[j] - g.a[i]) % p + p) % p;
		}
	}
	for (register int i = 1; i <= n; i++){
		if (g.a[i] != 0) ansm++;
	}
	cout << ansm << endl;
	for (register int i = 1; i <= n; i++){
		if (g.a[i] != 0) cout << i << " ";
	}
	return 0;
}
```

---

## 作者：Union_Find (赞：1)

# 题意

有一个集合 $S$，其元素最大不超过 $n$。定义 $f(k)$ 表示从 $S$ 中选择任意多个数，同一个数可以选择多次，这些数字的和为 $k$ 的方案数对 $p$ 取模的结果。

现在给定 $f(1),f(2),\cdots,f(n)$，你要求出原来的集合 $S$，保证有解。

$1 \le n \le 2^{18}$，保证 $p$ 是质数。

# 分析

首先你要做过 [付公主的背包](https://www.luogu.com.cn/problem/P4389)，。

设 $f(n)$ 的生成函数为 $F(x)$，$a_i$ 表示 $i$ 是否在集合 $S$ 中。我们有下面的结论。

$$\begin{equation}\begin{matrix}\begin{aligned}
F(x) &= \prod_{k=1} a_k\frac{1}{1-x^k}\\
\ln F(x) &= \sum_{i=1} a_i \sum_{j=1} \frac{x^{ij}}{j}
\end{aligned}\end{matrix}\end{equation}$$

这个时候我们是知道 $F(x)$ 的，要求 $a_i$，也就是类似于反演的操作。定义 $G(x) = \ln F(x)$，可以多项式求 $\ln$。

我们按照反演的思路，枚举 $T=ij$，就有

$$\begin{equation}\begin{matrix}\begin{aligned}
G(x) &= \sum_{T=1} \sum_{i|T} a_i\frac{i}{T}\\
     &= \sum_{T=1} \frac{1}{T} \sum_{i|T} a_ii
\end{aligned}\end{matrix}\end{equation}$$

我们定义 $f_T = T[x^T]G(x),g_i = a_ii$，那么我们就有

$$f_T = \sum_{i|T} g(i)$$

这是一个**狄利克雷卷积**的形式，即 $f = g \ast I$，然后我们两边同时卷 $\mu$，就有 $f \ast \mu = g \ast (I \ast \mu) = g \ast \varepsilon = g$。

所以直接将 $f$ 卷上 $\mu$ 即可，可以调和级数 $O(n\log n)$ 解决。

但是我们发现模数不是 NTT 模数，所以该~~谴责无良出题人~~写三模 NTT 了。

```cpp
// 上面是三模 NTT 板子，包括求 ln
int n, f[N], g[N], mu[N], pr[N], isp[N], tot;
poly F;
il void init(int n){
	isp[1] = mu[1] = 1;
	for (int i = 2; i <= n; i++){
		if (!isp[i]) pr[++tot] = i, mu[i] = -1;
		for (int j = 1; j <= tot && i * pr[j] <= n; j++){
			isp[i * pr[j]] = 1;
			if (i % pr[j] == 0){
				mu[i * pr[j]] = 0;
				break;
			}
			mu[i * pr[j]] = -mu[i];
		}
	}
}
signed main(){
	n = rd(), P = rd(), F = get(n), F[0] = 1, init(n);
	for (int i = 1; i <= n; i++) F[i] = rd();
	F = ln(F, n + 1);
	for (int i = 1; i <= n; i++) f[i] = 1ll * F[i] * i % P;
	for (int i = 1; i <= n; i++) for (int j = 1; i * j <= n; j++) g[i * j] = (g[i * j] + mu[i] * f[j]) % P;
	int cnt = 0;
	for (int i = 1; i <= n; i++) if (g[i]) cnt++;
	printf ("%d\n", cnt);
	for (int i = 1; i <= n; i++) if (g[i]) printf ("%d ", i);
	return 0;
}

```

---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:P3784](https://www.luogu.com.cn/problem/P3784)

* **【解题思路】**

我们设集合的第 $i$ 个数为 $a_i$。设给定的方案数的生成函数为 $F$，我们考虑枚举每一个数选多少个，得到

$$F=\prod_{i=1}^{|S|}\sum_{j=0}^{\infty}x^{ja_i}=\prod_{i=1}^{|S|}(1-x^{a_i})^{-1}$$

非常自然地，这种求积式一般使用取 $\ln$ 化简，结合 [$\rm P4389$ 付公主的背包](https://www.luogu.com.cn/problem/P4389) 对于 $\ln$ 化简的结论，我们得到

$$\ln F=-\sum_{i=1}^k\ln(1-x^{a_i})=\sum_{i=1}^k\sum_{j=1}^\infty\frac{x^{ja_i}}{j}$$

接下来我们交换求和顺序，考虑枚举 $ja_i$，设 $i$ 在集合中出现的次数为 $c_i$，我们有

$$\ln F=\sum_{j=1}^nx^j\sum_{k|j}c_k\frac kj$$

于是我们得到了对于 $1\leq j\leq n$ 的

$$f(j)=\sum_{k|j}c_k\frac kj$$

我们需要让 $\sum$ 里面只有关于 $k$ 的东西才能莫比乌斯反演。

$$jf(j)=\sum_{k|j}kc_k\iff jc_j=\sum_{k|j}\mu(k)\frac jkf\left(\frac jk\right)\iff c_j=\sum_{k|j}\frac{\mu(k)}kf\left(\frac jk\right)$$

直接计算即可得出每个数出现的次数并得出答案。

* **【实现细节】**

注意本题需要任意模数 $\ln$。~~任意模数多项式乘法差点让我自闭了~~

大家的代码都好快啊……

* **【代码实现】**

给一个主要代码。

```cpp
for(int i=1;i<=cnt;i++)
		cin>>poly[i];
poly[0]=1;
ln(cnt+1,poly,poly_ln);
for(int i=1;i<=cnt;i++)
	for(int j=1;j*i<=cnt;j++)
		answer[i*j]=(answer[i*j]+mu[i]*poly_ln[j]*inverse(i,prime)%prime+prime)%prime;
int cnt_ans=0;
for(int i=1;i<=cnt;i++)
	cnt_ans+=answer[i];
cout<<cnt_ans<<'\n';
for(int i=1;i<=cnt;i++)
	while(answer[i]--)
		cout<<i<<' ';
```

---

## 作者：Kun_9 (赞：0)

### 题意
给定只用 $S$ 中元素的分拆方案数，求 $S$。

### 分析
考虑设题目中的分拆方案的 OGF 为 $F(x)$，众所周知，不设限制的分拆方案是 $\prod_{i=1}^\infty \frac{1}{1-x^i}$，本题中的唯一限制“元素一定出现在集合 $S$ 中”也很好处理，直接套在指数上即可，为了方便起见我们设 $g(i)$ 为 $[i \in S]$，这样就能表示出 $F(x)$ 了：
$$
F(x) = \prod_{i=1}^\infty (\frac{1}{1-x^i})^{g(i)}
$$

之后是对这个式子进行化简， $\prod$ 不好处理，直接取 $\ln$：
$$
\ln(F(x)) = -\sum_{i=1}^\infty g(i)\ln(1-x^i)
$$

后面是一个经典的形式，我们知道它等于 $-\sum_{j=1}^\infty \frac{x^{ij}}{j}$，果断展开：

$$
\ln(F(x)) = \sum_{i=1}^\infty g(i)\sum_{j=1}^\infty \frac{x^{ij}}{j}
$$

变量上两个指标比较烦，换元试试：
$$
\ln(F(x)) = \sum_{i=1}^\infty x^i \sum_{d \mid i}\frac{g(d)d}{i}
$$

提取系数：

$$
[x^n]\ln(F(x)) = \sum_{d \mid n} \frac{g(d)d}{n}
$$

这不是莫反嘛，我们设 $G(n) = g(n) * n,H(n) = n[x^n]\ln(F(x)) $，那么：
$$
H=G*I \Leftrightarrow G = H * \mu
$$

反演出来就做完了，注意到我们只要求那些位置有值，可以直接枚举有值的位置在它的倍数处减去这个值，调和级数的求即可。

---


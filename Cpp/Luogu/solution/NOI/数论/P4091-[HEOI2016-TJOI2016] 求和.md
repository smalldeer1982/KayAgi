# [HEOI2016/TJOI2016] 求和

## 题目描述

在2016年，佳媛姐姐刚刚学习了第二类斯特林数，非常开心。

现在他想计算这样一个函数的值:

$$f(n)=\sum_{i=0}^n\sum_{j=0}^i S(i,j)\times 2^j \times (j!)$$

S(i, j)表示第二类斯特林数，递推公式为:

$S(i, j) = j \times S(i - 1, j) + S(i - 1, j - 1), 1 \le j \le i - 1$。

边界条件为：$S(i, i) = 1(0 \le i), S(i, 0) = 0(1 \le i)$

你能帮帮他吗?


## 说明/提示

对于 $50\%$ 的数据，$1\leq n \leq5\times10^3$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$。


## 样例 #1

### 输入

```
3```

### 输出

```
87```

# 题解

## 作者：NaCly_Fish (赞：49)

这是一篇搬运的题解。  
原作者：@[EntropyIncreaser](https://www.luogu.org/space/show?uid=21423)  
原文链接：[[TJOI2016/HEOI2016] 求和 线性解法](https://blog.csdn.net/EI_Captain/article/details/87906472)   
orz EI！！！
****   
先来推式子：  
$$ans=\sum\limits_{i=0}^n\sum\limits_{j=0}^iS(i,j)\times j! \times 2^j$$  
$$=\sum\limits_{i=0}^n\sum\limits_{j=0}^nS(i,j)\times j! \times 2^j$$  
$$=\sum\limits_{i=0}^n\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^j(-1)^{j-k}k^i \binom{j}{k} $$  
$$=\sum\limits_{j=0}^n\sum\limits_{k=0}^j(-1)^{j-k} \binom{j}{k} 2^j[n+1]_k$$  
$$[n]_q=\sum\limits_{i=0}^{n-1}q^i\space\text{is }\color{#66CCFF}\text{q-analog}$$

大部分人的推导在这里就结束了，因为这个式子可以卷积。   
但是其实这个式子还可以不卷积进行计算。这个东西的要点就是我们要看清楚形如  
$$\sum\limits_{j=i}^nq^{j-i}\binom{j}{i}a_j$$  
的形式是什么。  
设数列$\langle a_n \rangle$的生成函数是$G(z)$，那么这个和式其实就是带入了$G(z+q)$。  
反观我们的式子中：  
$$q=-1,G(z)=[n+1]_{2z}=\frac{(2z)^{n+1}-1}{2z-1}$$  
因此，我们得到的$[n+1]_k$项的系数就由  
$$G(z-1)=\frac{(2z-2)^{n+1}-1}{2z-3}$$  
分子可以用二项式定理化开，然后再除一个一次式，这是可以递推的。  

至于把所有的  
$$[n+1]_k=\frac{k^{n+1}-1}{k-1}$$  
算出来为什么没有快速幂的$\Theta(n\log n)$，那是因为$k^{n+1}$关于$k$是完全积性函数，合数的$k$是可以被筛出来的。这部分的复杂度就是$\pi (n) \cdot\Theta(\log n)=\Theta(n)$  
****  
解法部分到这里就结束了。  
下面是EI巨佬的代码，不要抄哦  
```cpp
#include <cstdio>
#include <cstring>

#include <functional>
#include <vector>

#define LOG(FMT...) fprintf(stderr, FMT)

using namespace std;

typedef long long ll;

const int P = 998244353;

void exGcd(int a, int b, int& x, int& y) {
  if (!b) {
    x = 1;
    y = 0;
    return;
  }
  exGcd(b, a % b, y, x);
  y -= a / b * x;
}

int inv(int a) {
  int x, y;
  exGcd(a, P, x, y);
  if (x < 0)
    x += P;
  return x;
}

int mpow(int x, int k) {
  int ret = 1;
  while (k) {
    if (k & 1)
      ret = ret * (ll)x % P;
    x = x * (ll)x % P;
    k >>= 1;
  }
  return ret;
}

struct Simple {
  int n;
  vector<int> fac, ifac, inv;

  void build(int n) {
    this->n = n;
    fac.resize(n + 1);
    ifac.resize(n + 1);
    inv.resize(n + 1);
    fac[0] = 1;
    for (int x = 1; x <= n; ++x)
      fac[x] = fac[x - 1] * (ll)x % P;
    inv[1] = 1;
    for (int x = 2; x <= n; ++x)
      inv[x] = -(P / x) * (ll)inv[P % x] % P + P;
    ifac[0] = 1;
    for (int x = 1; x <= n; ++x)
      ifac[x] = ifac[x - 1] * (ll)inv[x] % P;
  }

  Simple() {
    build(1);
  }

  void check(int k) {
    int nn = n;
    if (k > nn) {
      while (k > nn)
        nn <<= 1;
      build(nn);
    }
  }

  int gfac(int k) {
    check(k);
    return fac[k];
  }

  int gifac(int k) {
    check(k);
    return ifac[k];
  }

  int ginv(int k) {
    check(k);
    return inv[k];
  }

  int binom(int n, int m) {
    if (m < 0 || m > n)
      return 0;
    return gfac(n) * (ll)gifac(m) % P * gifac(n - m) % P;
  }
} simp;

const int N = 100010, PC = 30010;

int n;
int pc;
int a[N];
bool vis[N];
int p[PC];
int pw[N];

void sieve() {
  pw[1] = 1;
  for (int x = 2; x <= n; ++x) {
    if (!vis[x]) {
      p[++pc] = x;
      pw[x] = mpow(x, n + 1);
    }
    for (int i = 1; x * p[i] <= n; ++i) {
      vis[x * p[i]] = true;
      pw[x * p[i]] = pw[x] * (ll)pw[p[i]] % P;
      if (x % p[i] == 0)
        break;
    }
  }
}

int main() {
  scanf("%d", &n);
  simp.check(n + 1);
  for (int i = 0; i <= n; ++i)
    a[i] = ((n + 1 - i) & 1) ? (P - simp.binom(n + 1, i)) : simp.binom(n + 1, i);
  int pw = mpow(2, n + 1);
  for (int i = 0; i <= n; ++i)
    a[i] = a[i] * (ll)pw % P;
  --a[0];
  for (int i = 0; i <= n; ++i)
    a[i] = (P - a[i]) % P;
  int q = inv(3) * 2 % P;
  for (int i = 1; i <= n; ++i)
    a[i] = (a[i - 1] * (ll)q + a[i]) % P;
  int ans = (a[0] + a[1] * (ll)(n + 1)) % P;
  sieve();
  for (int i = 2; i <= n; ++i)
    ans = (ans + simp.ginv(i - 1) * (::pw[i] - 1LL) % P * a[i]) % P;
  if (ans < 0)
    ans += P;
  ans = ans * (ll)inv(3) % P;
  printf("%d\n", ans);

  return 0;
}
```  
ps：如果谁对这篇题解有更加易懂的解释，请在讨论区写出来qwq

---

## 作者：Kelin (赞：37)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79931185)

求

$$\sum_{i=0}^n\sum_{j=0}^iS_i^j2^jj!\mod 998244353$$

$S_n^m$表示第二类斯特林数

---

## 题解

考虑到当$i\lt j$时$S_i^j=0$

$$\Rightarrow\sum_{i=0}^n\sum_{j=0}^nS_i^j2^jj!$$

$$\Rightarrow\sum_{j=0}^n2^jj!\sum_{i=0}^nS_i^j$$

考虑到
$$S_n^m=\frac1{m!}\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n=\sum_{i=0}^m\frac{(-1)^i}{i!}\frac{(m-i)^n}{(m-i)!}$$

那么

$$\Rightarrow\sum_{j=0}^n2^jj!\sum_{i=0}^n\sum_{k=0}^j\frac{(-1)^k}{k!}\frac{(j-k)^i}{(j-k)!}$$

$$\Rightarrow\sum_{j=0}^n2^jj!\sum_{k=0}^j\frac{(-1)^k}{k!}\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}$$

设$f(i)=\frac{(-1)^i}{i!},g(i)=\frac{\sum_{j=0}^ni^j}{i!}=\frac{i^{n+1}-1}{(i-1)i!},$特别的$g(0)=1,g(1)=n+1$

$$\Rightarrow\sum_{j=0}^n2^jj!(f\times g)(j)$$

这样求一遍$NTT$即可

```cpp
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=3e5+5,P=998244353,G=3;
typedef int arr[N];
typedef long long ll;
int n,ans,K;arr a,b,R,wn,Mi,fac,inv,ifac;
inline int pls(int a,int b){return a+=b,a<P?a:a-P;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
inline int fpm(int a,int b){int x=1;for(;b;b>>=1,a=(ll)a*a%P)if(b&1)x=(ll)x*a%P;return x;}
inline void init(){for(int i=0,j=0;i<K;++i){R[i]=j;for(int l=K>>1;(j^=l)<l;l>>=1);}}
inline void dft(int*a,int ty=1){
    fp(i,0,K-1)if(i>R[i])swap(a[i],a[R[i]]);
    for(int i=2;i<=K;i<<=1){
        const int d=i>>1,e=ty==1?fpm(G,(P-1)/i):fpm(G,P-1-(P-1)/i);int o;
        fp(i,1,d-1)wn[i]=(ll)wn[i-1]*e%P;
        for(int*x=a;x!=a+K;x+=i)fp(k,0,d-1)
            o=(ll)x[k+d]*wn[k]%P,x[k+d]=sub(x[k],o),x[k]=pls(x[k],o);
    }if(ty^1){
        const int inv=fpm(K,P-2);
        fp(i,0,K-1)a[i]=(ll)a[i]*inv%P;
    }
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d",&n);
    inv[1]=a[0]=b[0]=wn[0]=Mi[0]=1;a[1]=P-1;b[1]=n+1;
    fac[0]=1;fp(i,1,n)fac[i]=(ll)fac[i-1]*i%P,Mi[i]=pls(Mi[i-1],Mi[i-1]);
    ifac[n]=fpm(fac[n],P-2);fd(i,n,1)ifac[i-1]=(ll)ifac[i]*i%P;
    fp(i,2,n)inv[i]=(ll)(P-P/i)*inv[P%i]%P;
    fp(i,2,n)a[i]=i&1?P-ifac[i]:ifac[i],
             b[i]=(ll)(fpm(i,n+1)-1)*inv[i-1]%P*ifac[i]%P;
    K=1;while(K<=n)K<<=1;K<<=1;init();
    dft(a),dft(b);fp(i,0,K-1)a[i]=(ll)a[i]*b[i]%P;dft(a,-1);
    fp(i,0,n)ans=pls(ans,(ll)Mi[i]*fac[i]%P*a[i]%P);
    printf("%d\n",ans);
return 0;
}
```
---
$upd:2019.7.18$

感谢$@PhantasmDragon$指出我的错误 已更正

---

$upd:2020.1.7$

感谢$@test12345$指出我的错误 已更正

---

## 作者：qwaszx (赞：22)

这里是一个没什么思维难度的线性做法.

前置知识:斯特林数的简单性质，有限微积分

$$\begin{aligned}&\sum_{i=0}^n\sum_{j=0}^i2^jj!S(i,j)\\=&\sum_{i=0}^n\sum_{j=0}^n2^jj!S(i,j)\\=&\sum_{i=0}^n\sum_{j=0}^n2^j\sum_{k=0}^j(-1)^{j-k}\binom{j}{k}k^i\\=&\sum_{j=0}^n2^j\sum_{k=0}^n(-1)^{j-k}\binom{j}{k}f(k)\\=&\sum_{k=0}^nf(k)(-1)^k\sum_{j=0}^n(-2)^j\binom{j}{k}\end{aligned}$$

其中

$$f(k)=\sum_{i=0}^nk^i,0^0=1$$

剩下的事情就是考虑一下后面那个$\sum$怎么算.考虑有限微积分.

$$\sum (-2)^j\binom{j}{k}\delta j$$

分部积分，设$u=\dbinom{j}{k},\Delta v=(-2)^j$，则有$\Delta u=\dbinom{j}{k-1},v=\dfrac{(-2)^j}{-3}$，于是

$$\sum (-2)^j\binom{j}{k}\delta j=\frac{(-2)^j}{-3}\binom{j}{k}-\frac{-2}{-3}\sum (-2)^j\binom{j}{k-1}\delta j$$

$$\sum(-2)^j\binom{j}{0}\delta j=\frac{(-2)^j}{-3}$$

于是可以递推.

然后关于$f$怎么算...$O(n)$筛出来$k^{n+1}$就好了.

目前是最优解.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=5e5,mod=998244353;
int inv[N],prime[N],p[N],n,cnt,pw[N];
int qpower(int a,int b)
{
    int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
    return ans;
}
void make()
{
    inv[1]=1;for(int i=2;i<=n+2;i++)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])prime[++cnt]=i,pw[i]=qpower(i,n+1);
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
        {
            p[i*prime[j]]=1;pw[i*prime[j]]=1ll*pw[i]*pw[prime[j]]%mod;
            if(i%prime[j]==0)break;
        }
    }
}
int main()
{
    scanf("%d",&n);if(n==0){puts("1");return 0;}
    make();
    int t1=-1ll*qpower(-2,n+1)*inv[3]%mod,t2=-2*inv[3]%mod;
    int f0=-inv[3],fn=t1,ans=(fn-f0)%mod,bin=n+1;
    f0=1ll*t2*f0%mod,fn=(1ll*t1*(n+1)+1ll*t2*fn)%mod;
    ans=(ans-1ll*(n+1)*(fn-f0))%mod;
    for(int i=2;i<=n;i++)
    {
        bin=1ll*bin*(n+2-i)%mod*inv[i]%mod,f0=1ll*t2*f0%mod,fn=(1ll*t1*bin+1ll*t2*fn)%mod;
        ans=(ans+((i&1)?-1:1)*(1ll*inv[i-1]*(pw[i]-1)%mod*(fn-f0)))%mod;
    }
    cout<<(ans+mod)%mod<<endl;
}
```

---

## 作者：y2823774827y (赞：17)

## 题目
[[HEOI2016/TJOI2016]求和](https://www.luogu.org/problemnew/show/P4091)

关于斯特林数与反演的更多姿势$\Longrightarrow$[点这里](https://www.cnblogs.com/y2823774827y/p/10700231.html)
## 做法

$$
\begin{aligned}
Ans&=\sum_{i=0}^n \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix}2^j×j!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~1\\
&=\sum_{i=0}^n \sum_{j=0}^n \begin{Bmatrix}i\\j\end{Bmatrix}2^j×j!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2\\
&=\sum_{j=0}^n 2^j×j!\sum_{i=0}^n \begin{Bmatrix}i\\j\end{Bmatrix}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~3\\
&=\sum_{j=0}^n 2^j×j!\sum_{i=0}^n \sum_{k=0}^j\frac{(-1)^k}{k!}\cdot\frac{(j-k)^i}{(j-k)!}~~~~~~~~~~~~~~~4\\
&=\sum_{j=0}^n 2^j×j!\sum_{k=0}^j\frac{(-1)^k}{k!}\cdot\frac{  \sum_{i=0}^n (j-k)^i}{(j-k)!}~~~~~~~~~~~~~5\\
&=\sum_{j=0}^n 2^j×j!\sum_{k=0}^j\frac{(-1)^k}{k!}\cdot \frac{(j-k)^{n+1}-1}{(j-k-1)(j-k)!}~~~~6\\
\end{aligned}
$$

- $2$：$\displaystyle \begin{Bmatrix}i\\j\end{Bmatrix}=0(i>j)$
- $3$：移项
- $4$：[第二类斯特林的性质](https://www.cnblogs.com/y2823774827y/p/10700231.html)
- $5$：移项化卷积
- $6$：等比公式


## 总结
这题非常有意思，最后一步对于蒟蒻来说还是少见的，推到$4$谁都会，然后就无从下手了
以至于会从头考虑$2^j×j!$的性质，特别容易想偏
## Code
```cpp
#include<bits/stdc++.h>
typedef int LL;
typedef long long L;
const LL maxn=3e5+9,mod=998244353,g=3,_g=332748118;
inline LL Pow(LL base,LL b){
    LL ret(1);
    while(b){
        if(b&1) ret=(L)ret*base%mod; base=(L)base*base%mod; b>>=1;
    }return ret;
}
LL fac[maxn],fav[maxn],r[maxn],F[maxn],G[maxn],W[maxn];
inline void NTT(LL *a,LL n,LL type){
    for(LL i=0;i<n;++i) if(i<r[i]) std::swap(a[i],a[r[i]]);
    for(LL mid=1;mid<n;mid<<=1){
        LL wn(Pow(type?g:_g,(mod-1)/(mid<<1)));
        W[0]=1; for(LL i=1;i<mid;++i) W[i]=(L)W[i-1]*wn%mod;
        for(LL R=mid<<1,j=0;j<n;j+=R)
            for(LL k=0;k<mid;++k){
            	LL x(a[j+k]),y((L)W[k]*a[j+mid+k]%mod);
            	a[j+k]=x+y; if(a[j+k]>=mod) a[j+k]%=mod;
				a[j+mid+k]=x-y; if(a[j+mid+k]<0) a[j+mid+k]+=mod;
            }
    }
}
inline LL Fir(LL n){
    LL limit(1),len(0);
    while(limit<n){
        limit<<=1; ++len;
    }
    for(LL i=0;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<len-1);
    return limit;
}
inline LL Solve_fg(LL n){
    for(LL i=0;i<=n;++i) F[i]=(L)(i&1?mod-1:1)*fav[i]%mod;
    for(LL i=0;i<=n;++i) G[i]=(L)(Pow(i,n+1)+mod-1)%mod*Pow(i-1<0?i+mod-1:i-1,mod-2)%mod*fav[i]%mod;
    G[1]=n+1;
    LL limit(Fir(n+1<<1));
    NTT(F,limit,1); NTT(G,limit,1);
    for(LL i=0;i<limit;++i) F[i]=(L)F[i]*G[i]%mod;
    NTT(F,limit,0);
    LL ty(Pow(limit,mod-2)); for(LL i=0;i<=n;++i) F[i]=(L)F[i]*ty%mod;
    
    LL ret(0);
    for(LL i=0;i<=n;++i) ret=(L)(ret+(L)Pow(2,i)*fac[i]%mod*F[i]%mod)%mod;
    return ret;
}
LL n;
int main(){
    scanf("%d",&n);
    fac[0]=fac[1]=1;
    for(LL i=2;i<=n;++i) fac[i]=(L)fac[i-1]*i%mod;
    fav[n]=Pow(fac[n],mod-2);
    for(LL i=n;i>=1;--i) fav[i-1]=(L)fav[i]*i%mod;
    
    printf("%d",Solve_fg(n));
    return 0;
}
```

---

## 作者：AubRain (赞：16)

**题意：** 求

$$\sum_{i=0}^n \sum_{j=0}^i S(i,j) \times 2^j\times j!$$

**推式子环节：**

1、因为 $S(i,j)=0(j>i)$，所以原式等于

$$\sum_{i=0}^n \sum_{j=0}^n S(i,j) \times 2^j\times j!$$

2、改变枚举顺序，上式等于

$$\sum_{j=0}^n2^j\times j! \sum_{i=0}^n S(i,j)$$

3、因为$S(n,m)=\sum_{i=0}^m(-1)^{i}\times \frac{1}{i!(m-i)!}\times (m-i)^n$（第二类斯特林数的通项公式），所以上式等于

$$\sum_{j=0}^n2^j\times j! \sum_{i=0}^n \sum_{k=0}^j(-1)^k\times \frac{1}{k!(j-k)!}\times (j-k)^i$$

4、把 $k$ 的枚举提前，上式等于

$$\sum_{j=0}^n2^j\times j! \sum_{k=0}^j(-1)^k\times \frac{1}{k!(j-k)!}\times \sum_{i=0}^n (j-k)^i$$

5、看起来不好看，把后面的东西换成和 $j$ 有关的式子，令
$$g[j]=\sum_{k=0}^j(-1)^k\times \frac{1}{k!(j-k)!}\times \sum_{i=0}^n (j-k)^i$$

于是答案就是
$$\sum_{j=0}^n2^j\times j!\times g[j]$$

问题转换为:**如何求 $g[i]$ ?**

换个变量名应该更好看一些。

$$g[i]=\sum_{j=0}^i \frac{(-1)^j}{j!}\times  \frac{\sum_{k=0}^n (i-j)^k}{(i-j)!} $$

嗯这里就很明显了，$g$ 是个卷积形式。

再详细一点：

令
$$a[i]=\frac{(-1)^i}{i!}$$
,
$$b[i]=\frac{\sum_{k=0}^n i^k}{i!}=\frac{i^{n+1}-1}{(i-1)i!}$$

注：$b[i]$ 的推导用到了等比数列求和，且 $b[1]=n+1$。

于是 $g[i]=\sum_{j=0}^ia[j]\times b[i-j]$

用 $NTT$ 优化多项式乘法即可。

**代码**：（还是很好写的，$50$ 行

```cpp
#include<bits/stdc++.h>
#define N 400005
#define p 998244353
#define G 332748118
#define int long long
using namespace std;

int n,ans,lim;
int a[N],b[N],r[N];
int f[N],inv[N],g[N];

inline int POW(int a,int b=p-2,int ans=1){
	for(;b;b>>=1,a=a*a%p)
		if(b&1) ans=ans*a%p;
	return ans;
}
void NTT(int *f,int opt,int n)
{
    for(int i=0;i<n;i++)
        if(i<r[i]) swap(f[i],f[r[i]]);
    for(int w,len=1;len<n;len<<=1){
        w=POW(opt==1?3:G,(p-1)/(len<<1));
        for(int b=1,k=0;k<n;k+=(len<<1),b=1)
            for(int i=k;i<k+len;i++,b=1ll*b*w%p){
                int now=1ll*b*f[i+len]%p;
                f[i+len]=(f[i]-now+p)%p;f[i]=(f[i]+now)%p;
            }
    }
}
void mul(int *a,int *b,int n)
{
    for(lim=1;lim<=n+n;lim<<=1);
    for(int i=0;i<lim;i++)
        r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);
    NTT(a,1,lim);NTT(b,1,lim);
    for(int i=0;i<lim;i++) b[i]=a[i]*b[i]%p;
    NTT(b,-1,lim); int inv=POW(lim,p-2);
    for(int i=0;i<=n;i++) g[i]=b[i]*inv%p;
}
signed main(){
	cin>>n;
	b[0]=f[0]=inv[0]=1;b[1]=n+1;
	for(int i=1;i<=n;i++)
		f[i]=f[i-1]*i%p,inv[i]=POW(f[i]);
	for(int i=0;i<=n;i++)
		a[i]=POW(p-1,i)*inv[i]%p;
	for(int i=2;i<=n;i++)
		b[i]=(POW(i,n+1)-1)*POW(i-1)%p*inv[i]%p;
	mul(a,b,n);
	for(int now=1,i=0;i<=n;i++,now=(now<<1)%p)
		(ans+=now*f[i]%p*g[i])%=p;
	cout<<ans;	
}
```

---

## 作者：EndSaH (赞：9)

[欢迎光临博客](http://endsah.tk/blog/HEOI2016-%E6%B1%82%E5%92%8C/)

比较简单易懂的线性做法。

下面用 $\begin{Bmatrix} i \\ j \end{Bmatrix}$ 表示第二类斯特林数，也即将 $i$ 划分成 $j$ 个非空集合的方案数。

首先我想吐槽一下，这真的不是随手化式子化到一半出出来的题吗……

$2$ 的次幂是友好的，主要是把这个斯特林数给处理掉。

关于第二类斯特林数，有一个为大家所熟知的公式：
$$
i ^k = \sum _{j = 0} ^k \begin{Bmatrix} k \\ j \end{Bmatrix} j! {i \choose j}
$$
其组合意义相当于 $i$ 个盒子 $k$ 个球任放，左边显然，右边枚举有 $j$ 个盒子非空并将球分到这 $j$ 个盒子里去。

注意右边的上界可以改写成 $i$。考虑若 $k$ 为一定值，可以通过二项式反演得到：
$$
\begin{Bmatrix} k \\ j \end{Bmatrix} j! = \sum _{i = 0} ^j (-1) ^{j - i} {j \choose i} i ^k
$$
把这个式子代入到题目所给的式子中（顺便修改 $j$ 的枚举上界为 $n$，斯特林数确保了改变上界不会出错）：
$$
\sum _{i = 0} ^n \sum _{j = 0} ^n 2 ^j \sum _{k = 0} ^j (-1) ^{j - k} {j \choose k} k ^i
$$
看上去式子只是变的更复杂了……其实不然，注意到 $i$ 的枚举可以提到后面去：
$$
\sum _{j = 0} ^n 2 ^j \sum _{k = 0} ^j (-1) ^{j - k} {j \choose k} \sum _{i = 0} ^n k ^i
$$
发现后面这个等比数列求和是非常友好的。令 $a _k = \sum \limits _{i = 0} ^n k ^i$，上式就变成了一个易于卷积的形式，可以做到 $O(n \log n)$。

实际上还能做到更好。再交换一下和式：
$$
\begin{aligned}
& \sum _{k = 0} ^n a _k \sum _{j = k} ^n 2 ^j (-1) ^{j - k} {j \choose k} \\
=& \sum _{k = 0} ^n a _k 2^k \sum _{j = k} ^n (-2) ^{j - k} {j \choose k}
\end{aligned}
$$
看一下后面的那一块怎么算。

令
$$
b _j = \sum _{i = j} ^n {i \choose j} q ^{i - j}
$$
考虑如何在线性时间内求出 $b$。

$b _0$ 是易于计算的，而考虑 $b _j$：
$$
\begin{aligned}
b _j &= \sum _{i = j} ^n {i \choose j} q ^{i - j} \\
&= \sum _{i = j} ^n {i - 1 \choose j} q ^{i - j} + \sum _{i = j} ^n {i - 1 \choose j - 1} q ^{i - j}
\end{aligned}
$$
两部分分开计算。

左部分：
$$
\begin{aligned}
& \sum _{i = j} ^n {i - 1 \choose j} q ^{i - j} \\
=& \sum _{i = j - 1} ^{n - 1} {i \choose j} q ^{i - j + 1} \\
=& q \sum _{i = j} ^{n - 1} {i \choose j} q ^{i - j} \\
=& q (a _j - {n \choose j} q ^{n - j})
\end{aligned}
$$
右部分：
$$
\begin{aligned}
& \sum _{i = j} ^n {i - 1 \choose j - 1} q ^{i - j} \\
=& \sum _{i = j - 1} ^{n - 1} {i \choose j - 1} q ^{i - j + 1} \\
=& \sum _{i = j - 1} ^{n - 1} {i \choose j - 1} q ^{i - (j - 1)} \\
=& b _{j - 1} - {n \choose j - 1} q ^{n - (j - 1)}
\end{aligned}
$$
所以
$$
b _j = qb _j - {n \choose j} q ^{n - j + 1} + b _{j - 1} - {n \choose j - 1} q ^{n - j + 1}
$$
于是
$$
(1 - q) b _j = b _{j - 1} - q ^{n - j + 1} \left( {n \choose j} +{n \choose j - 1} \right)
$$

预处理好组合数和 $q$ 的幂次即可做到 $O(n)$ 的求出 $b$。

求出 $b$ 之后原式也易于在 $O(n)$ 内求出，故总复杂度 $O(n)$。注意求 $a _k$ 时需要线性筛。

为了避免占用过大版块，代码就不放了……要看去 loj 搜或者去博客看吧。


---

## 作者：TheLostWeak (赞：5)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ4555.html)

**大致题意：** 计算$\sum_{i=0}^n\sum_{j=0}^iS(i,j)*2^j*(j!)$，其中$S$为第二类斯特林数。

------

#### 推式子

首先让我们来推一波式子：

因为当$i<j$时，$S(i,j)=0$，所以，为了方便式子的化简，我们可以先将第二个$\sum$的上限全部改成$n$，即：

$$\sum_{i=0}^n\sum_{j=0}^nS(i,j)*2^j*(j!)$$

这样一来，$\sum_{j=0}^n2^j*(j!)$这个式子就与$i$无关，则我们可以将其提前：

$$\sum_{j=0}^n2^j*(j!)\sum_{i=0}^nS(i,j)$$

套用第二类斯特林数的通项公式$S(n,m)=\sum_{i=0}^m\frac{(-1)^i*(m-i)^n}{i!(m-i)!}$可以得到：

$$\sum_{j=0}^n2^j*(j!)\sum_{i=0}^n\sum_{k=0}^j\frac{(-1)^k*(j-k)^i}{k!(j-k)!}$$

接下来，我们可以考虑再将所有与$i$无关的项提前，得到下面这个式子：

$$\sum_{j=0}^n2^j*(j!)\sum_{k=0}^j\frac{(-1)^k}{k!(j-k)!}*\sum_{i=0}^n(j-k)^i$$

我们可以枚举$j$，这样前面的$\sum_{j=0}^n2^j*(j!)$一项就可以轻松搞定。

那么接下来的问题就是如何对于给定的$j$，求出下面这个式子的值：

$$\sum_{k=0}^j\frac{(-1)^k}{k!(j-k)!}*\sum_{i=0}^n(j-k)^i$$

仔细观察，可以发现似乎这个式子前半部分的分母和后半部分都有$(j-k)$这个因式，则容易想到将它们移到一起，即：

$$\sum_{k=0}^j\frac{(-1)^k}{k!}*\sum_{i=0}^n\frac{(j-k)^i}{(j-k)!}$$

这样一移的效果是显著的，因为此时这个式子的前半部分只与$k$有关，后半部分只与$(j-k)$有关。

则可以设$f$和$g$如下：

$$f_x=\frac{(-1)^x}{x!}$$

$$g_x=\sum_{i=0}^n\frac{x^i}{x!}=\frac{\sum_{i=0}^nx^i}{x!}=\frac{\frac{x^{n+1}-1}{x-1}}{x!}=\frac{x^{n+1}-1}{(x-1)x!}$$

带入原式就可以得到：

$$\sum_{k=0}^jf_{k}*g_{j-k}$$

而这个式子实际上就相当于：

$$(f*g)(j)$$

至此化简完毕，最终的式子就是：

$$\sum_{j=0}^n2^j*(j!)*(f*g)(j)$$

------

#### 具体实现

我们可以先$O(n)$（$O(nlogn)$？）预处理出$f$和$g$两个数组，然后$NTT$即可。

这应该还是比较简单的吧。

------

#### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define X 998244353
#define Qinv(x) (Qpow(x,X-2))
#define swap(x,y) (x^=y^=x^=y)
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define XSum(x,y) ((x)+(y)>=X?(x)+(y)-X:(x)+(y))
#define XSub(x,y) ((x)-(y)<0?(x)-(y)+X:(x)-(y))
using namespace std;
int n,a[(N<<2)+5],b[(N<<2)+5],Fac[N+5],Inv[N+5];
I int Qpow(RI x,RI y) {RI res=1;W(y) y&1&&(res=1LL*res*x%X),x=1LL*x*x%X,y>>=1;return res;}
class NTT//NTT求模意义下的卷积
{
    private:
        static const int SZ=N,PR=3,IP=(X+1)/3;int P,L,R[(SZ<<2)+5];
        I void Transform(int* s,CI op)
        {
            RI i,j,k,U,S,tx,ty;for(i=0;i^P;++i) i<R[i]&&swap(s[i],s[R[i]]);
            for(i=1;i^P;i<<=1) for(U=Qpow(~op?PR:IP,(X-1)/(i<<1)),j=0;j^P;j+=(i<<1))
                for(S=1,k=0;k^i;++k,S=1LL*S*U%X) tx=s[j+k],ty=1LL*S*s[i+j+k]%X,s[j+k]=XSum(tx,ty),s[i+j+k]=XSub(tx,ty);
        }
    public:
        I void Solve(CI n,CI m,int* a,int* b)
        {
            RI i,t;P=1,L=0,memset(R,0,sizeof(R));
            W(P<=n+m) P<<=1,++L;for(i=0;i^P;++i) R[i]=(R[i>>1]>>1)|((i&1)<<L-1);
            for(Transform(a,1),Transform(b,1),i=0;i^P;++i) a[i]=1LL*a[i]*b[i]%X;
            for(Transform(a,-1),t=Qinv(P),i=0;i<=n+m;++i) a[i]=1LL*a[i]*t%X;
        }
}NTT;
int main()
{
    RI i,t,ans=0;for(scanf("%d",&n),Fac[0]=1,i=1;i<=n;++i) Fac[i]=1LL*Fac[i-1]*i%X;//预处理阶乘
    for(Inv[n]=Qpow(Fac[n],X-2),i=n-1;~i;--i) Inv[i]=1LL*Inv[i+1]*(i+1)%X;//预处理阶乘的逆元
    for(t=1,i=0;i<=n;++i,t=1LL*t*(X-1)%X) a[i]=1LL*t*Inv[i]%X;//预处理第一个数组
    for(b[0]=1,b[1]=n+1,i=2;i<=n;++i) b[i]=1LL*(Qpow(i,n+1)-1)*Qinv(i-1)%X*Inv[i]%X;//预处理第二个数组
    for(NTT.Solve(n,n,a,b),t=1,i=0;i<=n;++i,(t<<=1)>=X&&(t-=X)) Inc(ans,1LL*a[i]*t%X*Fac[i]%X);//做一遍NTT，然后统计答案
    return printf("%d",ans),0;//输出答案
}
```

---

## 作者：Y_B_X (赞：3)

原题：[luogu4091](https://www.luogu.com.cn/problem/P4091)

求：
$\sum\limits_{i=0}^{n}{\sum\limits_{j=0}^{i}{S(i,j)\times 2^j \times (j!)}}$

其实要求的式子即
$\sum\limits_{i=0}^{n}{[\frac{y^i}{i!}]\frac{1}{1-2(e^y-1)}}$=$\sum\limits_{i=0}^{n}{i!\times[y^i]\frac{1}{3-2e^y}}$

证明：

在$\sum\limits_{n}{S(m,n)n!x^n}$ 中对$m$取$egf$得

  $\sum\limits_{n}{x^nn!}\sum\limits_{m}{S(m,n)\frac{y^m}{m!}}$=$\sum\limits_{n}{x^nn!\frac{(e^y-1)^n}{n!}}$=$\frac{1}{1-x(e^y-1)}$

而原题中$x=2$，得证

于是求出mod($y^{n+1}$)意义下的$\frac{1}{3-2e^y}$ , 再如上处理即可

时间复杂度$O(nlogn)$

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
const int mod=998244353;
int n,n1,g,ans;
int a[N],b[N],tmp[N];
int rev[N];
int inv[N];
int frac[N];
int ifrac[N];
int qpow(int x,int k){
	int cnt=1;
	while(k){
		if(k&1)cnt=(cnt*x)%mod;
		x=(x*x)%mod;
		k>>=1;
	}
	return cnt;
}
void ntt(int n,int *a,int t){
	for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	if(t==1)g=3;
	else g=332748118;
	for(int mid=1;mid<n;mid<<=1){
		int wn=qpow(g,(mod-1)/(mid<<1));
		for(int j=0;j<n;j+=(mid<<1)){
			int w=1;
			for(int k=0;k<mid;k++){
				int x=a[j+k],y=w*a[j+k+mid]%mod;
				a[j+k]=(x+y)%mod;
				a[j+k+mid]=(x-y+mod)%mod;
				w=w*wn%mod;
			}
		}
	}
	if(t==1)return;
	int invn=qpow(n,mod-2);
	for(int i=0;i<n;i++)a[i]=a[i]*invn%mod;
}
void work(int n,int *f,int *g){
	if(n==1){
		g[0]=qpow(f[0],mod-2);
		return;
	}
	work((n+1)>>1,f,g);
	int n1=1,len=0;
	while(n1<(n<<1))n1<<=1,len++;
	for(int i=0;i<n1;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(len-1));
	for(int i=0;i<n;i++)tmp[i]=f[i];
	for(int i=n;i<n1;i++)tmp[i]=0;
	ntt(n1,tmp,1);
	ntt(n1,g,1);
	for(int i=0;i<n1;i++)g[i]=(2ll-tmp[i]*g[i]%mod+mod)%mod*g[i]%mod;
	ntt(n1,g,-1);
	for(int i=n;i<n1;i++)g[i]=0;
}
signed main(){
	scanf("%d",&n);
	inv[1]=1;
	for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	frac[0]=ifrac[0]=1;
	for(int i=1;i<=n;i++)frac[i]=frac[i-1]*i%mod,ifrac[i]=ifrac[i-1]*inv[i]%mod;
	a[0]++;
	for(int i=1;i<=n;i++)a[i]=mod-2*ifrac[i]%mod;
	work(n+1,a,b);
	for(int i=0;i<=n;i++)ans=(ans+b[i]*frac[i]%mod)%mod;
	printf("%d",ans);
}
```

---

## 作者：tzc_wk (赞：3)

这题我竟然自己推出来了！incredible！

首先你要了解 $S(n,k)$ 的含义，$S(n,k)$，即第二类斯特林数，表示将 $n$ 个**不同的球**放入 $k$ 个**相同的盒子**中，且不允许有空盒的方案数。

那么 $S(n,k)$ 有递推式 $S(n,k)=S(n-1,k-1)+S(n-1,k)\times k$。考虑最后一个球怎么放。如果它单独放在一个盒子中，那么方案数就是 $S(n-1,k-1)$，如果它与其它某些球放在同一个盒子中，那么相当于将 $n-1$ 个球放入 $k$ 个盒子中，方案数为 $S(n-1,k)\times k$，将二者一加即可得到第二类 stirling 数的递推式。

$S(n,k)$ 的通项公式：$S(n,k)=\dfrac{1}{k!}\sum\limits_{i=0}^ki^n\times\dbinom{k}{i}\times(-1)^{k-i}$。

考虑怎样证明这个公式：

令 $b_k=k^n=\sum\limits_{i=0}^k\dbinom{k}{i}\times S(n,i)\times i!$，即将 $n$ 个球放入 $k$ 个**不同的**盒子，对是否有空盒也不做要求的方案数，显然 $b_k$ 就是 $k^n$，即每个球都随便放入一个盒子的方案数乘在一起。

而 $b_k=\sum\limits_{i=0}^k\dbinom{k}{i}\times (-1)^i\times S(n,i)\times i!\times (-1)^i$（将 $1$ 拆成 $(-1)^i\times (-1)^i$）

再令 $a_k=S(n,k)\times k!\times (-1)^k$。

由二项式反演可得：

$\because b_k=\sum\limits_{i=0}^k(-1)^i\dbinom{k}{i}a_i$

$\therefore a_k=\sum\limits_{i=0}^k(-1)^i\dbinom{k}{i}b_i$

即 $S(n,k)\times k!\times (-1)^k=\sum\limits_{i=0}^k(-1)^i\dbinom{k}{i}i^n$

故 $S(n,k)=\dfrac{1}{k!}\sum\limits_{i=0}^ki^n\times\dbinom{k}{i}\times(-1)^{k-i}$

知道了这个公式之后，把它代入题目要求的式子，可得

$ans=\sum\limits_{i=0}^n\sum\limits_{j=0}^i2^j\times j!\times \dfrac{1}{j!}\sum\limits_{k=0}^jk^i\times\dbinom{j}{k}\times (-1)^{j-k}$

由于当 $j>i$ 时 $S(i,j)=0$，故 $\sum\limits_{j=0}^i$ 可直接改为 $\sum\limits_{j=0}^n$，进而又可以得到：

$ans=\sum\limits_{i=0}^n\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^jk^i\times\dbinom{j}{k}\times (-1)^{j-k}$

拆组合数可得：

$ans=\sum\limits_{i=0}^n\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^jk^i\times\dfrac{j!}{k!(j-k)!}\times (-1)^{j-k}$

我们发现这里的 $i$ 只在 $k^i$ 中出现过，故转化枚举顺序，先枚举 $j,k$ 再枚举 $i$：

$ans=\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^j(\sum\limits_{i=0}^nk^i)\times\dfrac{j!}{k!(j-k)!}\times (-1)^{j-k}$

显然 $(\sum\limits_{i=0}^nk^i)$ 可以用等比数列求和公式 $\mathcal O(\log n)$ 地算出，记其为 $c_k$。

$ans=\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^jc_k\times\dfrac{j!}{k!(j-k)!}\times (-1)^{j-k}$

看到了我们很喜欢的 $k$ 与 $j-k$，故考虑将带 $k$ 的合并，带 $j-k$ 的合并，与 $k$ 无关的丢到外面，又可以得到：

$ans=\sum\limits_{j=0}^n2^j\times j!\times\sum\limits_{k=0}^j(c_k\times\dfrac{1}{k!})\times (\dfrac{1}{(j-k)!}\times(-1)^{j-k})$

令 $a_k=c_k\times\dfrac{1}{k!},b_k=\dfrac{1}{k!}\times (-1)^k$，则

$ans=\sum\limits_{j=0}^n2^j\times j!\times\sum\limits_{k=0}^ja_kb_{j-k}$

是不是感觉后面那俩玩意儿可以卷？对 $a$ 和 $b$ 求个多项式卷积 $h$，然后 $ans=\sum\limits_{j=0}^n2^j\times j!\times h_j$。

然后这题就做完了。

注意，当 $k=0,1$ 时候 $c_k$ 需进行特判。显然 $c_1=n+1$，但是 $c_0$ 的值需要特别注意。我一直把它当 $0$ 算，结果就总 WA。其实你代入特殊值 $n=0$ 可手算得 $ans=1$，而将 $n=0$ 代入上式可得 $ans=c_0$，故 $c_0=1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int pr=3;
const int MOD=998244353;
const int MAXN=1e5;
const int MAXP=1<<18;
int qpow(int x,int e){int ret=1;for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;return ret;}
int n,pw[MAXN+5],f[MAXN+5],ff[MAXN+5];
int calc(int x,int y){return 1ll*f[x]*ff[y]%MOD*ff[x-y]%MOD;}
int LEN=1,LOG=0,ipr,inv[MAXP+5],prs[MAXP+5][2],rev[MAXP+5];
int A[MAXP+5],B[MAXP+5],C[MAXP+5];
void NTT(int *a,int len,int type){
	int lg=log2(len);
	for(int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(lg-1));
	for(int i=0;i<len;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		int W=prs[i][type<0];
		for(int j=0;j<len;j+=i){
			int w=1;
			for(int k=0;k<(i>>1);k++,w=1ll*w*W%MOD){
				int X=a[j+k],Y=1ll*w*a[(i>>1)+j+k]%MOD;
				a[j+k]=(X+Y)%MOD;a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
			}
		}
	}
	if(type==-1) for(int i=0;i<len;i++) a[i]=1ll*a[i]*inv[len]%MOD;
}
int main(){
	scanf("%d",&n);ipr=qpow(pr,MOD-2);
	f[0]=1;for(int i=1;i<=n;i++) f[i]=1ll*f[i-1]*i%MOD;
	ff[n]=qpow(f[n],MOD-2);for(int i=n-1;~i;i--) ff[i]=1ll*ff[i+1]*(i+1)%MOD;
	pw[0]=1;for(int i=1;i<=n;i++) pw[i]=pw[i-1]*2%MOD;
	while(LEN<=n+n) LEN<<=1,LOG++;
	for(int i=1;i<=LEN;i<<=1){
		inv[i]=qpow(i,MOD-2);
		prs[i][0]=qpow(pr,(MOD-1)/i);
		prs[i][1]=qpow(ipr,(MOD-1)/i);
	}
	A[0]=1;A[1]=n+1;
	for(int i=2;i<=n;i++) A[i]=1ll*(qpow(i,n+1)-1+MOD)*qpow(i-1,MOD-2)%MOD*ff[i]%MOD;
	for(int i=0;i<=n;i++){if(i&1) B[i]=MOD-ff[i];else B[i]=ff[i];}
	NTT(A,LEN,1);NTT(B,LEN,1);
	for(int i=0;i<LEN;i++) C[i]=1ll*A[i]*B[i]%MOD;
	NTT(C,LEN,-1);int ans=0;
	for(int i=0;i<=n;i++) ans=(ans+1ll*C[i]*pw[i]%MOD*f[i]%MOD)%MOD;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ニヒル (赞：3)

排行第一的题解感觉有点锅啊  
求
$$\sum_{i=0}^{n}\sum_{j=0}^{n}S(i,j)\times2^j\times(j!)$$
emmm，显然后面两个只带j的跟i没啥关系，扔到前面去
$$\sum_{j=0}^{n}2^j\times(j!)\sum_{i=0}^{n}S(i,j)$$
根据第二类斯特林数的通项公式
$$S(i,j)=\frac{1}{j!}\sum_{k=0}^{j}(-1)^k{j\choose k}(j-k)^i$$
展开后面的
$$\sum_{j=0}^{n}2^j\times(j!)\sum_{i=0}^{n}S(i,j)$$
$$=\sum_{j=0}^{n}2^j\times(j!)\sum_{i=0}^{n}\frac{1}{j!}\sum_{k=0}^{j}(-1)^k{j\choose k}(j-k)^i$$
$$=\sum_{j=0}^{n}2^j\times(j!)\sum_{i=0}^{n}\frac{1}{j!}\sum_{k=0}^{j}(-1)^k\frac{j!}{k!(j-k)!}(j-k)^i$$
$$=\sum_{j=0}^{n}2^j\times(j!)\sum_{i=0}^{n}\sum_{k=0}^{j}(-1)^k\frac{1}{k!(j-k)!}(j-k)^i$$
$$=\sum_{j=0}^{n}2^j\times(j!)\sum_{i=0}^{n}\sum_{k=0}^{j}\frac{(-1)^k}{k!}\frac{(j-k)^i}{(j-k)!}$$
发现又有和只带k和i没啥关系的式子了，提出来
$$=\sum_{j=0}^{n}2^j\times(j!)\sum_{k=0}^{j}\frac{(-1)^k}{k!}\frac{\sum_{i=0}^{n}(j-k)^i}{(j-k)!}$$
后面那东西有点像卷积啊，看看卷哪两个函数吧
$$f(i)=\frac{(-1)^i}{i!}$$
$$g(i)=\frac{\sum_{j=0}^{n}i^j}{i!}=\frac{i^{(n+1)}-1}{(i-1)i!}$$
这两个都是可以在合法复杂度内递推的，那么直接NTT就可以啦  
然后根据g的第一个式子  
$g(0)=\frac{1}{1}=1$  
$g(1)=\frac{n+1}{1}=n+1$

代码如下：
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define g 3
using namespace std;

long long fac[400030],inv[400030],x[400030],y[400030],m2[400030];
int n,lim=1,r[400030],cnt;

long long kasumi(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

void init()
{
	fac[0]=1;
	for(int i=1;i<=150000;i++)
	{
		fac[i]=fac[i-1]*i%mod;
	}
	inv[150000]=kasumi(fac[150000],mod-2);
	for(int i=149999;i>=0;i--)
	{
		inv[i]=inv[i+1]*(i+1)%mod;
	}
}

long long NTT(long long *a,long long kd)
{
	for(long long i=0;i<lim;i++)
	{
		if(i<r[i])
		{
			swap(a[i],a[r[i]]);
		}
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		long long wn=kasumi(g,(mod-1)/(mid<<1));
		if(kd) wn=kasumi(wn,mod-2);
		for(int i=0;i<lim;i+=mid*2)
		{
			long long w=1;
			for(int j=0;j<mid;j++,w=w*wn%mod)
			{
				long long gg1=a[i+j];
				long long gg2=a[i+j+mid];
				a[i+j]=(gg1+gg2*w%mod)%mod;
				a[i+j+mid]=(gg1-gg2*w%mod+mod)%mod;
			}
		}
	}
	if(kd)
	{
		long long invl=kasumi(lim,mod-2);
		for(long long i=0;i<lim;i++)
		{
			a[i]=a[i]*invl%mod;
		}
	}
}

int main()
{
	init();
	scanf("%d",&n);
	while(lim<=2*n) lim<<=1,cnt++;
	for(int i=0;i<lim;i++)
	{
		r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
	}
	x[0]=1;x[1]=(-inv[1]+mod)%mod;
	y[0]=1;y[1]=n+1;
	m2[0]=1;m2[1]=2;
	for(int i=2;i<=n;i++)
	{
		x[i]=(i&1)?-inv[i]:inv[i];
		x[i]=(x[i]+mod)%mod;
		y[i]=(kasumi(i,n+1)-1+mod)*kasumi(i-1,mod-2)%mod*inv[i]%mod;
		m2[i]=m2[i-1]*2%mod;
	}
	NTT(x,0);
	NTT(y,0);
	for(int i=0;i<lim;i++)
	{
		x[i]=x[i]*y[i]%mod;
	}
	NTT(x,1);
	long long ans=0;
	for(int i=0;i<=n;i++)
	{
		ans+=m2[i]*fac[i]%mod*x[i]%mod;
		ans%=mod;
	}
	printf("%lld\n",ans);
}
```


---

## 作者：Fading (赞：2)

如果你不知到第二类斯特林数，可以看看我的[组合数学的一些小知识总结](https://www.luogu.org/blog/wohaocaia/zu-ge-shuo-xue-di-yi-suo-xiao-zhi-shi-zong-jie-wei-wan-post)才刚开始写，未完待续，大佬轻喷。

这道题求

## $\sum_{i=0}^n\sum_{j=0}^iS_i^j2^jj!\mod 998244353$

反正$i<j$的时候$S_i^j=0,$于是呢，用套路把东西拉到一边

$$=\sum_{i=0}^n\sum_{j=0}^nS_i^j2^jj!$$

没有依赖性，直接替换枚举方式

$$=\sum_{j=0}^n\sum_{i=0}^nS_i^j2^jj!$$

直接提出来

$$=\sum_{j=0}^n2^jj!\sum_{i=0}^nS_i^j$$

根据第二类斯特林数的通项公式（博客里有证明）

有$S_i^j=\sum_ {k=0}^j \frac {(-1)^{k}\times (j-k)^i}{k!\times (j-k)!}$

代入
$$=\sum_{j=0}^n2^jj!\sum_{i=0}^n\sum_ {k=0}^j \frac {(-1)^{k}\times (j-k)^i}{k!\times (j-k)!}$$

发现枚举$i$的部分可以提上去

$$=\sum_{j=0}^n2^jj!\sum_ {k=0}^j \frac {(-1)^{k}\times \sum_{i=0}^n(j-k)^i}{k!\times (j-k)!}$$

没有任何联系，可以分开计算

$$=\sum_{j=0}^n2^jj!(\sum_ {k=0}^j \frac {(-1)^{k}}{k!}\times \frac{\sum_{i=0}^n(j-k)^i}{(j-k)!})$$


后面比较毒瘤

设
$$f(k)=\frac{(-1)^k}{k!},g(k)=\frac{\sum_{i=0}^n(k)^i}{k!}=[\frac{k^{n+1}-1}{k!(k-1)}]$$

上面用到了等比数列求和公式qwq

求$f(k)$把$k!$逆元求出来就好了，$g(k)$只需要求$k!(k-1)$逆元就好了，上面的东西可以快速幂，也可以循环的时候顺带求出。

然后后面这一陀是一个卷积，设$h(j)=f(k)\times g(j-k),NTT$搞一搞复杂度$O(nlog_2n)$

不过注意一下$g(0)=1,g(1)=n+1,f(1)=1$

最后暴力代入一次就好了。

$$=\sum_{j=0}^n2^jj!h(j)$$

注意到$n$很小，直接扫一发就完事了。

代码居然一遍过编译一遍过样例交上去~~(除了复制出错导致CE)~~一A？？？

舒服~

代码如下:

```
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
int n,m,r[4000006],lim;
ll f[2000001],h[2000001],w[2000001],g[2000001],c[2000001];
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1;a%=p;
    while (b){
        if (b&1) t=t*a%p;
        b>>=1;a=a*a%p;
    }
    return t;
}
inline void NTT(ll f[],int lim,int id){
    for (int i=0;i<lim;i++){
        if (i<r[i]) swap(f[r[i]],f[i]);
    }
    w[0]=1;
    for (int len=1;len<lim;len<<=1){
    	ll gen=fast_pow(3,(ljc-1)/(len<<1)*id+ljc-1,ljc);
    	for (int i=1;i<lim;i++) w[i]=w[i-1]*gen%ljc;
        for (int i=0;i<lim;i+=len<<1){
            ll *f1=f+i,*f2=f1+len;
            for (int j=0;j<len;j++){
                ll x=f1[j]%ljc,y=f2[j]*w[j]%ljc;
                f1[j]=(x+y)%ljc;f2[j]=(x-y+ljc)%ljc;
            }
        }
    }
    if (id==1) return;
    ll Inv=fast_pow(lim,ljc-2,ljc);
    for (int i=0;i<lim;i++) f[i]=f[i]*Inv%ljc;
}
int main(){
	cin>>n;
	f[0]=1;g[0]=1;g[1]=n+1;
	ll fac=1;
	for (int i=2;i<=n;i++){
		fac=fac*i%ljc;//循环顺带求出阶乘
		ll Iv=fast_pow(fac*(i-1)%ljc,ljc-2,ljc);//求逆元
		g[i]=(fast_pow(i,n+1,ljc)-1+ljc)%ljc*Iv%ljc;
	}
	fac=1;
	for (int i=1;i<=n;i++){
		fac=fac*i%ljc;
		f[i]=(ljc+(i%2?-1:1)*fast_pow(fac,ljc-2,ljc)%ljc)%ljc;
	}
	ll lim=1,len=0;
	while (lim<=(n<<1)) lim<<=1,len++;
	for (int i=0;i<lim;i++){
        r[i]=(r[i>>1]>>1)|((i&1)<<(len-1));
    }
    NTT(f,lim,1);NTT(g,lim,1);
    for (int i=0;i<=lim;i++) h[i]=f[i]*g[i]%ljc;
	NTT(h,lim,-1);
	fac=1;ll ans=0,two=1;//two是记录2的幂次的答案
	for (int j=0;j<=n;j++){
		ans=(ans+h[j]*fac%ljc*two%ljc)%ljc;
		two=two*2%ljc;fac=fac*(j+1)%ljc;
	}
	cout<<ans<<endl;
}
```

---

## 作者：Orion545 (赞：2)

# 广告

[蒟蒻のblog](https://www.cnblogs.com/dedicatus545/p/9152505.html)

# 思路

首先，我们发现这个式子中大部分的项都和$j$有关（尤其是后面的$2^j\ast j!$），所以我们更换一下枚举方式，把这道题的枚举方式变成先$j$再$i$

$f(n)=\sum_{j=0}^n2^j\ast j!\sum_{i=0}^nS_i^j$

第二类斯特林数有一个基于组合意义的公式：

$S_i^j=\frac1{j!}\sum_{k=0}^j(-1)^kC_j^k(j-k)^i=\sum_{k=0}^j\frac{(-1)^k(j-k)^i}{k!(j-k)!}$

把这个公式代回原式中，得到：

$f(n)=\sum_{j=0}^n2^j\ast j!\sum_{i=0}^n\sum_{k=0}^j\frac{(-1)^k(j-k)^i}{k!(j-k)!}$

再次更换一下枚举方式，变成：

$f(n)=\sum_{j=0}^n2^j\ast j!\sum_{k=0}^j\frac{(-1)^k}{k!}\sum_{i=0}^n\frac{(j-k)^i}{(j-k)!}$

$f(n)=\sum_{j=0}^n2^j\ast j!\sum_{k=0}^j\frac{(-1)^k}{k!}\ast\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}$

此时，设两个函数$a$和$b$，令：

$a(i)=\frac{(-1)^i}{i!}$

$b(i)=\frac{\sum_{j=0}^ni^j}{i!}=\frac{i^{n+1}-1}{(i-1)i!}$

那么，

$f(n)=\sum_{j=0}^n 2^j\ast j!\ast(a\ast b)(j)$

其中(a\ast b)(j)表示$a$和$b$的$0-j$项的卷积

模数为$998244353$，用$NTT$做一遍卷积即可，时间效率为$O(nlog_2n)$

### 注意事项

$b(0)=1,b(1)=n+1$

这两个要提前保存一下，因为用公式推的话会div 0

还有一个奇怪的问题我没有解决，具体看代码最后面吧

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
#define ll long long
ll MOD=998244353,g=3,inv[400010],f[400010],finv[400010];
int qpow(ll a,ll b){//快速幂
    ll re=1;
    while(b){
        if(b&1) re=re*a%MOD;
        a=a*a%MOD;b>>=1;
    }
    return re;
}
ll n,A[400010],B[400010],C[400010],r[400010],limit,cnt;
void ntt(ll *a,ll type){
    int i,j,k,mid;ll y,w,wn;
    for(i=0;i<limit;i++) if(i<r[i]) swap(a[i],a[r[i]]);
    for(mid=1;mid<limit;mid<<=1){
        wn=qpow((type==1)?g:inv[g],(MOD-1)/(mid<<1));
        for(j=0;j<limit;j+=(mid<<1)){
            w=1;
            for(k=0;k<mid;k++,w=w*wn%MOD){
                y=a[j+k+mid]*w%MOD;
                a[j+k+mid]=(a[j+k]-y+MOD)%MOD;
                a[j+k]=(a[j+k]+y)%MOD;
            }
        }
    }
    if(type==-1) for(i=0;i<limit;i++) a[i]=a[i]*inv[limit]%MOD;
}
void init(){
    limit=1;cnt=0;int i;
    while(limit<=(n<<1)) limit<<=1,cnt++;
    for(i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(cnt-1)));
    inv[1]=A[0]=B[0]=f[1]=finv[1]=1;A[1]=MOD-1;B[1]=n+1;
    for(i=2;i<=limit;i++) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
    for(i=2;i<=limit;i++){
        f[i]=f[i-1]*i%MOD;
        finv[i]=finv[i-1]*inv[i]%MOD;
    }
}
int main(){
    n=read();
    init();int i;
    for(i=2;i<=n;i++) A[i]=(((i%2)?-1:1)*finv[i]+MOD)%MOD;
    for(i=2;i<=n;i++) B[i]=((qpow(i,n+1)-1)*inv[i-1]%MOD*finv[i])%MOD;
    ntt(A,1);ntt(B,1);
    for(i=0;i<limit;i++) C[i]=A[i]*B[i]%MOD;
    ntt(C,-1);
    ll ans=0;
    for(i=0;i<=n;i++) ans=(ans+qpow(2,i)*f[i]%MOD*C[i]%MOD)%MOD;
    printf("%lld\n",(ans+1)%MOD);//这里不知道为什么，一定要加个1，我也没有搞明白
}
```

---

## 作者：autoint (赞：2)

# 前置：第二类斯特林数
表示把$n$个小球放入$m$个不可区分的盒子的方案数

使用容斥原理分析，假设盒子可区分枚举至少有几个盒子为空，得到通项：
$$S(n,m)=\frac{1}{m!}\sum_{k=0}^{m}(-1)^k\binom{m}{k}(m-k)^n$$
# 分析
$$f(n)=\sum_{i=0}^n\sum_{j=0}^iS(i,j)2^jj!$$
注意到$S(n,m)=0\quad(m>n)$，因此第二个求和上限可改为$n$，并代入第二类斯特林数的通项，得到
$$f(n)=\sum_{i=0}^n\sum_{j=0}^n\frac{1}{j!}\sum_{k=0}^j(-1)^k\frac{j!}{k!(j-k)!}(j-k)^i2^jj!$$
$$=\sum_{j=0}^n2^jj!\sum_{k=0}^{j}\frac{(-1)^k}{k!(j-k)!}\sum_{i=0}^n(j-k)^i$$
$$=\sum_{j=0}^n2^jj!\sum_{k=0}^{j}\frac{(-1)^k}{k!}\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}$$
令$g(j)=\sum_{k=0}^{j}\frac{(-1)^k}{k!}\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}$,则$f(n)=\sum_{j=0}^n2^jj!g(j)$

令$a_k=\frac{(-1)^k}{k!},b_k=\frac{\sum_{i=0}^nk^i}{k!}=\frac{k^{n+1}-1}{(k-1)k!}\quad (k>1)$
则$g=a \otimes b$
然后先求出$g$，再求出$f$
# 代码
```cpp
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<ctime>
#include<iostream>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<stack>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
#include<complex>
#pragma GCC optimize ("O3")
#define rg register
using namespace std;
template<class T> inline T read(T&x){
    T data=0;
	int w=1;
    char ch=getchar();
    while(!isdigit(ch))
    {
		if(ch=='-')
			w=-1;
		ch=getchar();
	}
    while(isdigit(ch))
        data=10*data+ch-'0',ch=getchar();
    return x=data*w;
}
typedef long long ll;

const int mod=998244353,g=3;

int rev[1<<18|7];

inline void calrev(int lim,int l)
{
	rev[0]=0;
	for(int i=1;i<lim;++i)
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
}

inline int qpow(int x,int k)
{
	int ans=1;
	while(k)
	{
		if(k&1)
			ans=(ll)ans*x%mod;
		x=(ll)x*x%mod,k>>=1;
	}
	return ans;
}

inline void FFT(int*t,int lim,int type)
{
	for(rg int i=0;i<lim;++i)
		if(i<rev[i])
			swap(t[i],t[rev[i]]);
	for(rg int i=1;i<lim;i<<=1)
	{
		int gn=qpow(g,(mod-1)/(i<<1));
		if(type==-1)
			gn=qpow(gn,mod-2);
		for(rg int j=0;j<lim;j+=(i<<1))
		{
			int gi=1;
			for(rg int k=0;k<i;++k,gi=(ll)gi*gn%mod)
			{
				int x=t[j+k],y=(ll)gi*t[j+i+k]%mod;
				t[j+k]=x+y,t[j+i+k]=x-y+mod;
				if(t[j+k]>=mod)
					t[j+k]-=mod;
				if(t[j+i+k]>=mod)
					t[j+i+k]-=mod;
			}
		}
	}
	if(type==-1)
	{
		int inv=qpow(lim,mod-2);
		for(rg int i=0;i<lim;++i)
			t[i]=(ll)t[i]*inv%mod;
	}
}

int fac[100010],inv[100010],pow2[100010];

int a[1<<18|7],b[1<<18|7];

int main()
{
	int n;
	read(n);
	fac[0]=inv[0]=pow2[0]=a[0]=b[0]=1;
	for(rg int i=1;i<=n;++i)
	{
		fac[i]=(ll)fac[i-1]*i%mod;
		inv[i]=qpow(fac[i],mod-2);
		pow2[i]=pow2[i-1]<<1;
		if(pow2[i]>=mod)
			pow2[i]-=mod;
		a[i]=inv[i];
		if(i&1)
			a[i]=mod-a[i];
		b[i]=(ll)(qpow(i,n+1)-1)%mod*inv[i]%mod*qpow(i-1,mod-2)%mod;
	}
	b[1]=n+1; 
	int lim=1,l=0;
	while(lim<=n*2) 
		lim<<=1,++l;
	calrev(lim,l);
	FFT(a,lim,1);
	FFT(b,lim,1);
	for(rg int i=0;i<lim;++i)
		a[i]=(ll)a[i]*b[i]%mod;
	FFT(a,lim,-1);
	int f=0;
	for(rg int i=0;i<=n;++i)
	{
		f+=(ll)pow2[i]*fac[i]%mod*a[i]%mod;
		if(f>=mod)
			f-=mod;
	}
	printf("%d\n",f);
    return 0;
}


```
# Hint

b1不能用等比数列公式计算，必须单独处理。

我只需要n项，但是只算到n项是错的，举例答案是3次函数，我只需要2项就只求求2项，算出来就是一个1次函数，就是错的 

总结：lim必须至少是待卷积式子长度的两倍 

---

## 作者：Rayment (赞：2)

# Solution
**安利个人博客[Blog](https://blog.csdn.net/As_A_Kid)**

发现我的思路比较清奇？可能是我数学太差了想不到

首先可以用容斥推出第二类斯特林数的通项公式~~(没见过就是真·推不出来)~~
$$S_n^m=\frac 1 {m!}\sum_{i=0}^m (-1)^iC_m^i (m-i)^n=\sum_{i=0}^m (-1)^i(i!)\frac {(m-i)^n} {(m-i)!}$$
这是一个卷积的形式，那么我们可以利用NTT在$O(n\log n)$的时间求出第n行的斯特林数。

我们考虑把$2^j\times (j!)$看作一个系数，根据递推公式，把斯特林数往下一行推。

然后如果你手动模拟一下，就像这样：

![表](https://cdn.luogu.com.cn/upload/pic/27967.png)

其中，$S_i^i$的系数会有剩余，但我们知道它恒等于1，所以只需要知道它的系数即可。

又容易发现，这些系数是有规律的，我们可以用递推来模拟做这样的一个事情，复杂度$O(n)$。转移方程可以参考代码，其中a数组为$s_i^i$的系数，b数组为最后一行的系数，c为第i列向第i+1列的转移系数。唯一需要注意的是第n项的系数是没有得到加成的，还是$2^n(n!)$。

时间复杂度$O(n\log n)$。
# Code
```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
#define rg register
using namespace std;
typedef long long ll;
const int maxn=100010,mod=998244353,G=3;
template <typename Tp> inline void getmin(Tp &x,Tp y){if(y<x) x=y;}
template <typename Tp> inline void getmax(Tp &x,Tp y){if(y>x) x=y;}
template <typename Tp> inline void read(Tp &x)
{
	x=0;char ch=getchar();int f=0;
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') f=1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	if(f) x=-x;
}
int n,m,tmp,N=1,l,ans,f[maxn<<2],g[maxn<<2],rev[maxn<<2];
int fac[maxn],inv[maxn],mi[maxn],a[maxn],b[maxn],c[maxn];
inline int pls(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
int power(int x,int y)
{
	int res=1;
	for(;y;y>>=1,x=(ll)x*x%mod)
	  if(y&1)
	    res=(ll)res*x%mod;
	return res;
}
void init()
{
	fac[0]=mi[0]=1;
	for(rg int i=1;i<=n;i++)
	  fac[i]=(ll)fac[i-1]*i%mod,mi[i]=pls(mi[i-1],mi[i-1]);
	inv[n]=power(fac[n],mod-2);
	for(rg int i=n-1;~i;i--) inv[i]=(ll)inv[i+1]*(i+1)%mod;
	a[0]=1;b[0]=1;c[0]=1;
	for(rg int i=1;i<=n;i++)
	{
		a[i]=dec((ll)fac[i]*mi[i]%mod,(ll)i*c[i-1]%mod);
		b[i]=pls((ll)fac[i]*mi[i]%mod,c[i-1]%mod);
		c[i]=dec(b[i],(ll)i*c[i-1]%mod);
	}
	for(rg int i=0;i<n;i++) ans=pls(ans,a[i]);
}
void ntt(int *a,int f)
{
	for(rg int i=0;i<N;i++)
	  if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(rg int i=1;i<N;i<<=1)
	{
		int gn=power(G,(mod-1)/(i<<1));
		for(rg int j=0;j<N;j+=(i<<1))
		{
			int g=1;
			for(rg int k=0;k<i;k++,g=(ll)g*gn%mod)
			{
				int x=a[j+k],y=(ll)g*a[j+k+i]%mod;
				a[j+k]=pls(x,y);a[j+k+i]=dec(x,y);
			}
		}
	}
	if(f==-1)
	{
		int inv=power(N,mod-2);reverse(a+1,a+N);
		for(int i=0;i<N;i++) a[i]=(ll)a[i]*inv%mod;
	}
}
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
	#endif
	read(n);
	init();
	while(N<(n<<1)) N<<=1,l++;
	for(rg int i=1;i<N;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	for(rg int i=0;i<n;i++)
	{
		f[i]=inv[i];
		if(i&1) f[i]=dec(0,f[i]);
		g[i]=(ll)power(i,n)*inv[i]%mod;
	}
	ntt(f,1);ntt(g,1);
	for(rg int i=0;i<N;i++) f[i]=(ll)f[i]*g[i]%mod;
	ntt(f,-1);
	for(rg int i=0;i<n;i++) ans=pls(ans,(ll)f[i]*b[i]%mod);
	ans=pls(ans,(ll)mi[n]*fac[n]%mod);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：撤云 (赞：1)

[点我食用效果更佳](https://www.cnblogs.com/hbxblog/p/11204162.html)
### $Solution$

先化简式子:

$$f(n)=\sum_{i=0}^n\sum_{j=0}^i\begin{Bmatrix} i \\ j \end {Bmatrix}*2^j*j!$$

$$f(n)=\sum_{j=0}^n2^j*j!\sum_{i=0}^n\begin{Bmatrix} i \\ j \end {Bmatrix}$$

根据第二类斯特林数的公式:

$$f(n)=\sum_{j=0}^n2^j*j!\sum_{i=0}^n\sum_{k=0}^j\frac{(-1)^k}{k!}*\frac{(j-k)^i}{(j-k)!}$$

$$f(n)=\sum_{j=0}^n2^j*j!\sum_{k=0}^j\frac{(-1)^k}{k!}*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}$$
我们令$F(i)=\frac{(-1)^k}{i!},G(i)=\frac{\sum_{j=0}^ni^j}{i!}$

根据等比数列求和公式可得：

$\sum_{j=0}^ni^j=\frac{i^{n+1}-1}{i-1}$

所以$G(i)=\frac{i^{n+1}-1}{(i-1)*i!}$

$G(0)=1,G(1)=n+1$

那么

$$f(n)=\sum_{j=0}^n2^j*j!\sum_{k=0}^jF(k)*G(j-k)$$

因为当$j>k$时$G(j-k)=0$

所以原式等价于:

$$f(n)=\sum_{j=0}^n2^j*j!\sum_{k=0}^nF(k)*G(j-k)$$

这个东西直接$NTT$搞一搞就好了

### $Code$
``` cpp
#include<bits/stdc++.h>
#define int long long
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int mod=998244353;
const int N=500010;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int f[N],g[N],r[N],limit=1,w[N],inv[N],a[N],b[N],jc[N];
int ksm(int a,int b){
    int ans=1;
    while(b){
        if(b&1) ans=ans*a%mod;
        a=a*a%mod,b>>=1;
    }
    return ans;
}
void ntt(int *a,int opt){
    for(int i=0;i<=limit;i++)
        if(i<r[i])
            swap(a[i],a[r[i]]);
    for(int i=1;i<limit;i<<=1){
        int w=ksm(3,(mod-1)/(i*2));
        if(opt==-1) w=ksm(w,mod-2);
        for(int j=0;j<limit;j+=i<<1){
            int l=1;
            for(int k=j;k<j+i;k++){
                int p=l*a[k+i]%mod;
                a[k+i]=(a[k]-p+mod)%mod;
                a[k]=(a[k]+p)%mod;
                l=l*w%mod;
            }
        }
    }
}
main(){
    int n=read(),l=0,ans=0;
    while(limit<=(n<<1))
        limit<<=1,l++;
    jc[0]=1;
    for(int i=1;i<=limit;i++)
        jc[i]=jc[i-1]*i%mod;
    inv[limit]=ksm(jc[limit],mod-2);
    for(int i=limit-1;i>=0;i--)
        inv[i]=inv[i+1]*(i+1)%mod;
	g[0]=1,g[1]=n+1,f[1]=mod-1,f[0]=1;
	for(int i=2;i<=n;i++)
		g[i]=(ksm(i,n+1)-1)%mod*inv[i]%mod*ksm(i-1,mod-2)%mod,f[i]=i&1?mod-inv[i]:inv[i];
    for(int i=0;i<limit;i++)
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    ntt(f,1),ntt(g,1);
    for(int i=0;i<limit;i++)
        f[i]=f[i]*g[i]%mod;
    ntt(f,-1);
	int inv=ksm(limit,mod-2);
    for(int i=0;i<=n;i++)
		ans=(ans+ksm(2,i)*jc[i]%mod*f[i]%mod*inv%mod)%mod;
    printf("%lld",ans);
}
```

---

## 作者：Ebola (赞：1)

首先你要有信仰，你要相信原式中的j是可以枚举到n的。原因很简单，当j>i时，S(i,j)=0，所以对答案不造成贡献。为什么要这么做，后面就会知道

你要知道第二类斯特林数展开这种东西。也就是$\left\{\begin{aligned}n\\m\end{aligned}\right\}m!=\sum\limits_{i=0}^m(-1)^i\left(\begin{aligned}m\\i\end{aligned}\right)(m-i)^n$

然后把它代入原式，得到：$f(n)=\sum\limits_{i=0}^n\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^j(-1)^k\left(\begin{aligned}j\\k\end{aligned}\right)(j-k)^i$

把组合数公式代入，得到：$f(n)=\sum\limits_{i=0}^n\sum\limits_{j=0}^n2^j\sum\limits_{k=0}^j(-1)^k\frac{j!}{k!(j-k)!}(j-k)^i$

把$j!$提到前面来，把$\sum\limits_{i=0}^n$丢到后面去（这就是为什么一开始要把j枚举到n，如果不这么干，枚举i是不能丢到后面去的），得到：$\sum\limits_{j=0}^n2^jj!\sum\limits_{k=0}^j\frac{(-1)^k}{k!}\times\frac{\sum\limits_{i=0}^n(j-k)^i}{(j-k)!}$

接下来我们定义两个函数：$A(x)=\frac{(-1)^k}{k!}\qquad B(x)=\frac{\sum_{i=0}^nx^i}{k!}$

代入原式，得到：$f(n)=\sum\limits_{j=0}^n2^jj!\sum\limits_{k=0}^jA(k)B(j-k)$

哇，后面这个求和，居然是美妙的卷积！于是我们定义$C(k)=\sum\limits_{x+y=k}A(x)B(y)$，然后原式就可以化为$f(n)=\sum\limits_{j=0}^n2^jj!C(j)$

预处理阶乘及阶乘逆元，$A$就可以在$O(n)$的时间内算出。至于$B$的话，用一下等比数列求和公式，也可以在$O(n)$的时间内算出。然后用$FFT$对$A,B$做一下多项式乘法，可以在$O(n\;\log\;n)$的时间内求出$C$。再预处理出$2$的所有次幂在模意义下的值，最后就可以$O(n)$算出$f(n)$

时间复杂度瓶颈在于$FFT$，最终总的复杂度就是$O(n\;\log\;n)$

```cpp
#include<bits/stdc++.h>
#define ha 998244353
using namespace std;

const int N=270010;
int A[N],B[N],C[N],r[N];
int fac[N],ifac[N],pw[N];

int Pow(int a,int b)
{
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%ha)
		if(b&1) ans=1ll*ans*a%ha;
	return ans;
}

void NTT(int *A,int n,bool IDFT)
{
	for(int i=0;i<n;i++) r[i]=(r[i>>1]>>1)|((i&1)*(n/2));
	for(int i=0;i<n;i++) if(i<r[i]) swap(A[i],A[r[i]]);
	for(int i=1;i<n;i<<=1)
	{
		int wn=Pow(3,(ha-1)/(i<<1));
		if(IDFT) wn=Pow(wn,ha-2);
		for(int j=0;j<n;j+=(i<<1))
			for(int k=0,w=1;k<i;k++)
			{
				int x=A[j+k],y=1ll*w*A[i+j+k]%ha;
				A[j+k]=(x+y)%ha;
				A[i+j+k]=(x-y+ha)%ha;
				w=1ll*w*wn%ha;
			}
	}
	int inv=IDFT?Pow(n,ha-2):0;
	if(IDFT) for(int i=0;i<n;i++) A[i]=1ll*A[i]*inv%ha;
}

void InitFac(int n)
{
	fac[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=1ll*fac[i-1]*i%ha;
	ifac[n]=Pow(fac[n],ha-2);
	for(int i=n-1;i>=0;i--)
		ifac[i]=1ll*ifac[i+1]*(i+1)%ha;
}

void InitABC(int n)
{
	for(int i=0;i<=n;i++)
		A[i]=1ll*(i&1?ha-1:1)*ifac[i]%ha;
	B[0]=1;B[1]=n+1;
	for(int i=2;i<=n;i++)
		B[i]=1ll*(Pow(i,n+1)-1)*Pow(i-1,ha-2)%ha*ifac[i]%ha;
	int len;
	for(len=1;len<=(n<<1);len<<=1);
	NTT(A,len,0);NTT(B,len,0);
	for(int i=0;i<len;i++)
		C[i]=1ll*A[i]*B[i]%ha;
	NTT(C,len,1);
}

int main()
{
	int n,ans=0;
	scanf("%d",&n);
	InitFac(n);
	InitABC(n);
	pw[0]=1;
	for(int i=1;i<=n;i++)
		pw[i]=2ll*pw[i-1]%ha;
	for(int i=0;i<=n;i++)
		ans=(ans+1ll*pw[i]*fac[i]%ha*C[i])%ha;
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Great_Influence (赞：1)

下面那位式子好像挂了，帮忙补一下。

根据组合意义，第二类斯特林数具有以下公式:

$S(n,m)=\frac{1}{m!}\sum\limits_{k=0}^m(-1)^{m-k}{m\choose k}k^n$

$=\frac{1}{m!}\sum\limits_{k=0}^m(-1)^{m-k}\frac{m!}{k!(m-k)!}k^n$

$=\sum\limits_{k=0}^m\frac{(-1)^{m-k}}{(m-k)!}*\frac{k^n}{k!}$


再注意当$m>n$时，$S(n,m)=0$。

然后就可以化式子了。

$ans=\sum\limits_{i=0}^n\sum\limits_{j=0}^i S(i,j)2^j(j!)$

$=\sum\limits_{i=0}^n\sum\limits_{j=0}^n S(i,j)2^j(j!)$

$=\sum\limits_{j=0}^n2^j(j!)\sum\limits_{i=0}^n S(i,j)$

$=\sum\limits_{j=0}^n2^j(j!)\sum\limits_{i=0}^n \sum\limits_{k=0}^j\frac{(-1)^{j-k}}{(j-k)!}*\frac{k^i}{k!}$

$=\sum\limits_{j=0}^n2^j(j!)\sum\limits_{k=0}^j\frac{(-1)^{j-k}}{(j-k)!}*\sum\limits_{i=0}^n\frac{k^i}{k!}$

$=\sum\limits_{j=0}^n2^j(j!)\sum\limits_{k=0}^j\frac{(-1)^{j-k}}{(j-k)!}*\frac{\sum\limits_{i=0}^nk^i}{k!}$

设函数$f(x)=\frac{(-1)^x}{x!}$，$g(x)=\frac{\sum\limits_{i=0}^n x^i}{x!}$，则

$ans=\sum\limits_{i=0}^n 2^j(j!)(f*g)(x)$

预处理f和g,运用NTT求解即可。

代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
	T f=1;x=0;char c;
	for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+(c^48);
	x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
	freopen("b.in","r",stdin);
	freopen("b.out","w",stdout);
#endif
}
const int MAXN=(1<<19)+7;
const int mod=998244353,g=3;
static int n,m,rev[MAXN],a[MAXN],b[MAXN];
inline int power(int a,int b)
{
	static int sum;
	for(sum=1;b;b>>=1,a=1ll*a*a%mod)if(b&1)
		sum=1ll*sum*a%mod;
	return sum;
}
inline void NTT(int X[],int type)
{
	Rep(i,1,m-1)if(i<rev[i])swap(X[i],X[rev[i]]);
	static int i,j,k,t,w,wn,kk;
	for(i=2;i<=m;i<<=1)
	{
		kk=i>>1;wn=power(g,(mod-1)/i);
		if(type==-1)wn=power(wn,mod-2);
		for(j=0;j<m;j+=i)
		{
			w=1;
			for(k=0;k<kk;++k,w=1ll*w*wn%mod)
			{
				t=1ll*X[j+k+kk]*w%mod;
				X[j+k+kk]=(X[j+k]-t+mod)%mod;
				X[j+k]=(X[j+k]+t)%mod;
			}
		}
	}
	if(type==-1)
	{
		static int inv=power(m,mod-2);
		Rep(i,0,m-1)X[i]=(1ll*X[i]*inv)%mod;
	}
}
inline void solve()
{
	a[0]=1;
	Rep(i,1,n)a[i]=1ll*a[i-1]*i%mod;
	a[n]=power(a[n],mod-2);
	Repe(i,n-1,0)a[i]=1ll*a[i+1]*(i+1)%mod;
	Rep(i,0,n)
	{
		b[i]=a[i];
		if(i==1)b[i]=1ll*b[i]*(n+1)%mod;
		else b[i]=1ll*b[i]*(power(i,n+1)-1)%mod*power(i-1,mod-2)%mod;
	}
	Rep(i,0,n/2)a[(i<<1)|1]=1ll*(mod-1)*a[(i<<1)|1]%mod;
	static int len=0,ans=0,las=1;
	for(m=2;m<=(n<<1);m<<=1,++len);
	Rep(i,1,m-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<len);
	NTT(a,1);NTT(b,1);
	Rep(i,0,m-1)a[i]=(1ll*a[i]*b[i])%mod;
	NTT(a,-1);
	Rep(i,0,n)
	{
		ans=((ans+1ll*las*a[i]%mod)%mod+mod)%mod;
		las=1ll*(las<<1)%mod*(i+1)%mod;
	}
	printf("%d\n",ans);
}
int main()
{
	file();
	read(n);
	solve();
	return 0;
}
```

---

## 作者：zhendelan (赞：0)

求  
$$\sum_{i=0}^n \sum_{j=0}^i S(i,j)2^jj!$$  

$S(i,j)$表示第二类斯特林数。表示$i$个不同的球放在$j$个相同盒子的方案数（没有空盒）。  

递推式：$S(i,j) = S(i-1,j-1)+j*S(i-1,j-1)$  

放一个新盒子或者放在之前$j$个相同的中。  

可以求一下他的公式。。 

用容斥原理，设有$k$个空盒：  
$$S(n,m)=\frac 1 {m!}\sum_{k=0}^m(-1)^k*C_m^k*(m-k)^n $$ 
$$=\sum_{k=0}^m \frac {(-1)^k*(m-k)^n}{(m-k)!k!}$$  

代入。。。。。  
因为当$i<j$时$S(i,j)=0$。所以把$j$的上界设为$n$。   
 
  
     
     
原式为：
$$\sum_{j=0}^n 2^jj!\sum_{i=0}^n  S(i,j)$$  

我们可以枚举$j$。  

如果可以快速求出$S(i,j)$就好了。  

继续推式子：  

$$\sum_{j=0}^n 2^jj!\sum_{i=0}^n \sum_{k=0}^j \frac{(-1)^k(j-k)^i}{(j-k)!k!}$$  

 $$=\sum_{j=0}^n 2^jj!\sum_{k=0}^j \frac{(-1)^k}{(j-k)!k!}\sum_{i=0}^n (j-k)^i$$  
 
$$=\sum_{j=0}^n 2^jj!\sum_{k=0}^j \frac{(-1)^k}{k!}\sum_{i=0}^n \frac {(j-k)^i} {(j-k)!}$$   

设  
$$F(x)=\frac {(-1)^x}{x!}\ \ \ \ \ G(x)=\frac {x^i} {x!}$$    

那么式子就是 $\sum_{j=0}^n2^jj! (F*G(j))$  

卷积就好了。。  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
ll ksm(ll a,ll b=mod-2)
{
	ll ret = 1;
	while(b)
	{
		if(b&1)ret=ret*a%mod;
		a=a*a%mod;
		b>>=1;
	}	
	return ret;
} 
const ll G = 3,invG=ksm(G);
const int N = 280020;
void clr(ll *f,int n)
{
	for(int i=0;i<n;i++)f[i]=0;
}
void cpy(ll *f,ll *g,int n)
{
	for(int i=0;i<n;i++)f[i]=g[i];
}
int rev[N],rev_last; 
void revinit(int n)
{
	#define last rev_last
	if(last==n)return;
	last=n;
	for(int i=0;i<n;i++)
	  rev[i] = (rev[i>>1]>>1)|((i&1)*n/2);
	#undef last 
}
void ntt(ll *a,int n,int inv)
{
	revinit(n);
	for(int i=0;i<n;i++)
	  if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int mid=1;mid<n;mid*=2)
	{
		ll temp=ksm(inv>0?G:invG,(mod-1)/(2*mid));
		for(int i=0;i<n;i+=mid*2)
		{
			ll omega = 1;
			for(int j=0;j<mid;omega=omega*temp%mod,j++)
			{
				ll x = a[i+j],y=omega*a[i+j+mid]%mod;
				a[i+j] = (x+y) %mod;
				a[i+j+mid] = ((x-y)%mod+mod)%mod;
			}			
		}
	}
	if(inv<0)
	{
		ll invn = ksm(n);
		for(int i=0;i<n;i++)
		  a[i]=a[i]*invn%mod;
	}
}
void px(ll *f,ll *g,int n)
{
	for(int i=0;i<n;i++)
	  f[i] = f[i] * g[i]%mod;
}
ll time_sav[N];
void times(ll *f,ll *g,int len,int lim)
{
	#define sav time_sav
	int n=1;
	for(n;n<len+len;n<<=1);
	cpy(sav,g,n);
	for(int i=len;i<n;i++)sav[i]=0;
	ntt(f,n,1);
	ntt(sav,n,1);
	px(f,sav,n);
	ntt(f,n,-1);	
	for(int i=lim;i<n;i++)f[i]=0;
	clr(sav,n);
	#undef sav
}
ll fac[N],inv[N],F[N],H[N];
int main()
{
	int n;
	scanf("%d",&n);
	fac[0]=1;
	for(int i=1;i<=n;i++)
	  fac[i]=fac[i-1]*i%mod;
	inv[n] = ksm(fac[n]);
	for(int i=n-1;i>=0;i--)
	  inv[i] = (inv[i+1]*(i+1))%mod;
	for(int i=0;i<=n;i++)
	  if(i&1)F[i] = (mod-1)*inv[i]%mod;
	  else F[i]=inv[i];
	H[0] =  1;H[1] = n+1;
	for(int i=2;i<=n;i++)
	  H[i] = (ksm(i,n+1)-1)*ksm(i-1)%mod*inv[i]%mod;
	times(F,H,n+1,n+1);
	ll ans = 0;
	for(int i=0;i<=n;i++)
	{
		ans = (ans + ksm(2,i)*fac[i]%mod*F[i])%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

  
   
    
     
      
       
        
         
          
          

---

## 作者：crashed (赞：0)

# 【 HEOI2016 / TJOI2016 】求和
# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4091)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二类斯特林数$S(i,j)$本身的意义是——将$i$个不同球放入$j$个相同盒子中，使得盒子不为空的方案数。因此，我们可以得到$S(i,j)$的容斥式：  
$$S(i,j)=\frac1{j!}\sum_{k=0}^j(-1)^kC_j^k(j-k)^i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中我们先将$j$个盒子看成不同的。我们枚举空盒子数量$k$，容斥系数为$(-1)^k$，$C_j^k$为选出$k$个盒子的方案数，$(j-k)^i$为在剩下的盒子中放$i$个球的方案数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来化式子： 
$$\sum_{i=0}^n\sum_{j=0}^i2^j\times S(i,j)\times j!$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到若$j>i$，则$S(i,j)=0$。  
$$\Rightarrow \sum_{i=0}^n\sum_{j=0}^n2^j\times S(i,j)\times j!$$  
$$= \sum_{i=0}^n\sum_{j=0}^n2^j\sum_{k=0}^j(-1)^kC_j^k(j-k)^i$$  
$$= \sum_{i=0}^n\sum_{j=0}^n2^j\sum_{k=0}^j(-1)^k\frac{j!}{k!(j-k)!}(j-k)^i$$  
$$= \sum_{i=0}^n\sum_{j=0}^n2^j\times j!\sum_{k=0}^j\frac{(-1)^k}{k!}\frac{(j-k)^i}{(j-k)!}$$  
$$= \sum_{j=0}^n2^j\times j!\sum_{k=0}^j\frac{(-1)^k}{k!}\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$f(x)=\sum_{i=0}^{+\infty}\frac{(-1)^i}{i!}x, g(x)=\sum_{i=0}^{+\infty}\frac{\sum_{k=0}^ni^k}{i!}$，并记$[x^k]f(x)$表示多项式函数$f(x)$在$x^k$项上的系数，可以参考生成函数。于是式子会被化为如下带卷积形式：  
$$\Rightarrow \sum_{j=0}^n2^j\times j!\times [x^j](f*g)(x)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现$(f*g)(x)$可以 NTT 预处理。但是首当其冲的是如何快速求出$[x^k]g(x)$：  
$$[x^k]g(x)=\frac{\sum_{i=0}^nk^i}{k!}$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用等比数列求和公式：  
$$\Rightarrow [x^k]g(x)=\begin{cases}\frac{k^{n+1}-1}{k!(k-1) }&k\not= 1\\n+1&k=1\end{cases}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是$g(0)=1$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间是$O(n\log_2n)$。  
# 代码
```cpp
#include <cmath>
#include <cstdio>

typedef long long LL;

const int mod = 998244353, phi = mod - 1;
const int MAXN = 1e5 + 5, g = 3;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

int F[MAXN << 2], G[MAXN << 2], H[MAXN << 2];
int fac[MAXN], inv[MAXN], invFac[MAXN];
int N;

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

int fix( const int a ) { return ( a % mod + mod ) % mod; }
int inver( const int a ) { return a <= N ? inv[a] : qkpow( a, phi - 1 ); }
int getS( const int q, const int n ) { return 1ll * fix( qkpow( q, n ) - 1 ) * inver( fix( q - 1 ) ) % mod; }

void NTT( int *coe, const int len, const int type )
{
	const int phi = mod - 1;
	int lg2 = log2( len );
	for( int i = 0, rev ; i < len ; i ++ )
	{
		rev = 0;
		for( int j = 0 ; j < lg2 ; j ++ ) rev |= ( ( i >> j ) & 1 ) << ( lg2 - j - 1 );
		if( rev < i ) swapp( coe[rev], coe[i] );
	}
	int wp, w, we, wo;
	for( int s = 2, p ; s <= len ; s <<= 1 )
	{
		p = s >> 1, wp = type > 0 ? qkpow( 3, phi / s ) : inver( qkpow( 3, phi / s ) );
		for( int i = 0 ; i < len ; i += s )
		{
			w = 1;
			for( int j = 0 ; j < p ; j ++, w = 1ll * w * wp % mod )
			{
				we = coe[i + j], wo = coe[i + j + p];
				coe[i + j] = ( we + 1ll * w * wo % mod ) % mod, coe[i + j + p] = fix( we - 1ll * w * wo % mod );
			}
		}
	}
	if( ~ type ) return ;
	int in = inver( len );
	for( int i = 0 ; i <= len ; i ++ ) coe[i] = 1ll * coe[i] * in % mod;
}

void init()
{
	fac[0] = fac[1] = invFac[0] = invFac[1] = inv[1] = 1;
	for( int i = 2 ; i <= N ; i ++ ) fac[i] = ( LL ) fac[i - 1] * i % mod, inv[i] = ( LL ) ( mod - mod / i ) * inv[mod % i] % mod;
	for( int i = 2 ; i <= N ; i ++ ) invFac[i] = ( LL ) invFac[i - 1] * inv[i] % mod;
	for( int i = 0 ; i <= N ; i ++ ) 
		F[i] = ( i & 1 ) ? ( mod - invFac[i] ) : invFac[i];
	G[0] = 1, G[1] = N + 1;
	for( int i = 2 ; i <= N ; i ++ ) 
		G[i] = ( LL ) ( qkpow( i, N + 1 ) - 1 ) * inv[i - 1] % mod * invFac[i] % mod;
}

int main()
{
	read( N );
	init();
	int K = N * 2, len = 1;
	while( len < K ) len <<= 1;
	NTT( F, len, 1 ), NTT( G, len, 1 );
	for( int i = 0 ; i <= len ; i ++ ) H[i] = 1ll * F[i] * G[i] % mod;
	NTT( H, len, -1 );
	init();
	int ans = 0;
	for( int i = 0, two = 1 ; i <= N ; i ++, two = two * 2 % mod ) 
		ans = ( ans + 1ll * two * fac[i] % mod * H[i] % mod ) % mod;
	write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：yyxmy (赞：0)

### 求和

题意：求以下这个式子$f(n)=\sum_{i=0}^{n}\sum_{j=0}^{i}S(i, j)\times 2^j\times j!$

貌似有一个神仙的 $dp$做法，可是我并不会。。。

考虑把$S(i,j)$的组合意义拆掉：

可以得到式子为：$f(n)=\sum_{i=0}^{n}\sum_{j=0}^{i}2^j\sum_{k=0}^{j}(-1)^{j-k}k^i*C(j, k)$

交换一下枚举项可以得到：$\sum_{k=0}^{n}\sum_{j=0}^{n}(-1)^{j-k}C(j, k)\sum_{i=0}^{n}k^i$

然后发现后面那个东西是可以预处理的， 那么前面就是一个卷积的形式，

然后这道题就愉快的求解了。

具体可以见代码
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define G 3
#define Gi 332748118
#define reg register
#define maxn 1000001
using namespace std;
int fac[maxn], ifac[maxn], inv[maxn], n, len;
int lim, rev[maxn], x, y, ans, a[maxn], b[maxn];
int ksm(int u, int v){
	int s = 1;
	for(int i = v; i; i >>= 1){
		if(i & 1) s = 1ll * s * u % mod;
		u = 1ll * u * u % mod;
	}
	return s;
}
int C(int u, int v){
	int s = 1ll * fac[u] * ifac[v] % mod * ifac[u - v] % mod;
	return s;
}
int ntt(int *a, int type){
	for(int i = 1; i < lim; i++) 
		if(i < rev[i]) swap(a[i], a[rev[i]]);
	for(int i = 1; i < lim; i <<= 1){
		int x = ksm(type == 1 ? G : Gi, (mod - 1) / (i << 1));
		for(int j = 0; j < lim; j += i << 1)
			for(int k = 0, y = 1; k < i; k++, y = 1ll * y * x % mod){
				int p = a[j + k], q = 1ll * a[j + k + i] * y % mod;
				a[j + k] =	(p + q) % mod; a[j + k + i] = (p - q + mod) % mod;
			}
	}
	if(type == -1){
		int x = ksm(lim, mod - 2);
		for(int i = 0; i < lim; i++) a[i] = 1ll * a[i] * x % mod;
	}
}
int main()
{
	cin >> n;
	inv[0] = 1; ifac[0] = 1; fac[0] = 1;
	for(int i = 1; i <= n; i++){
		inv[i] = (i == 1) ? 1 : 1ll * inv[mod % i] * (mod - mod / i) % mod;
		fac[i] = 1ll * fac[i - 1] * i % mod;
		ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; 
	}
	for(int i = 0; i <= n; i++) {
		if(i == 1) {a[i] = n + 1; continue;}
		a[i] = 1ll * (ksm(i, n + 1) - 1) * ksm(i - 1, mod - 2) % mod;
		a[i] = 1ll * a[i] * ifac[i] % mod;
	}
	for(int i = 0; i <= n; i++) b[i] = 1ll * ksm(2, i) * fac[i] % mod;
	for(lim = 1, len = 0; lim <= (n << 1); lim <<= 1, len++);
	for(int i = 1; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (len - 1));
	reverse(a, a + n + 1); 
	ntt(a, 1); ntt(b, 1);
	for(int i = 0; i < lim; i++) a[i] = 1ll * a[i] * b[i] % mod;
	ntt(a, -1); 
	for(int i = 0; i <= n; i++)
	 a[i] = a[i + n];
	for(int i = 0; i <= n; i++){
		a[i] = 1ll * a[i] * ifac[i] % mod;
		if(i & 1) ans = (ans + mod - a[i]) % mod;
		else ans = (ans + a[i]) % mod;
	}
	cout << ans << endl;
}
```


---

## 作者：yzhang (赞：0)

[原题传送门](https://www.luogu.org/problem/P4091)

$$\begin{aligned} a n s &=\sum_{i=0}^{n} \sum_{j=0}^{i}\left\{\begin{array}{c}{i} \\
{j}\end{array}\right\} 2^{j} \times j ! \\ 
&=\sum_{i=0}^{n} \sum_{j=0}^{n}\left\{\begin{array}{c}{i} \\ 
{j}\end{array}\right\} 2^{j} \times j ! \\
&=\sum_{j=0}^{n} 2^{j} \times j ! \sum_{i=0}^{n}\left\{\begin{array}{c}{i} \\ {j}\end{array}\right\} \\
&=\sum_{j=0}^{n} 2^{j} \times j ! \sum_{i=0}^n(\frac{1}{m !} \sum_{k=0}^j(-1)^k \tbinom{m}{k} (m-k)^n) \\
&=\sum_{j=0}^{n} 2^{j} \times j ! \sum_{i=0}^{n} \sum_{k=0}^{j} \frac{(-1)^{k}}{k !} \cdot \frac{(j-k)^{i}}{(j-k) !} 
\\ &=\sum_{j=0}^{n} 2^{j} \times j ! \sum_{k=0}^{j} \frac{(-1)^{k}}{k !} \cdot \frac{(j-k)^{n+1}-1}{(j-k-1)(j-k) !} \end{aligned}$$

这就是一个很明显的卷积形式，NTT求一下即可

要注意一下最后一步，因为用了等比数列求和，所以$1$要特判

```cpp
#include <bits/stdc++.h>
#define N 100005
#define mod 998244353
#define G 3
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int power(register int a,register int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
int n,fac[N],invf[N],f[N<<2],g[N<<2],R[N<<2],ans;
inline void NTT(register int *a,register int n,register int f)
{
    for(register int i=0;i<n;++i)
        if(i<R[i])
            swap(a[i],a[R[i]]);
    for(register int i=1;i<n;i<<=1)
    {
        int T=power(G,(mod-1)/(i<<1));
        if(f==-1)
            T=power(T,mod-2);
        for(register int j=0;j<n;j+=(i<<1))
        {
            int t=1;
            for(register int k=0;k<i;++k,t=1ll*t*T%mod)
            {
                int Nx=a[j+k],Ny=1ll*t*a[i+j+k]%mod;
                a[j+k]=(0ll+Nx+Ny)%mod;
                a[i+j+k]=(0ll+Nx-Ny+mod)%mod;
            }
        }
    }
}
int main()
{
    n=read();
    fac[0]=fac[1]=1;
    for(register int i=2;i<=n;++i)
        fac[i]=1ll*fac[i-1]*i%mod;
    invf[n]=power(fac[n],mod-2);
    for(register int i=n-1;i>=0;--i)
        invf[i]=1ll*invf[i+1]*(i+1)%mod;
    for(register int i=0;i<=n;++i)
        f[i]=1ll*(i&1?mod-1:1)*invf[i]%mod;
    for(register int i=0;i<=n;++i)
        g[i]=1ll*(power(i,n+1)+mod-1)*power(i-1<0?i+mod-1:i-1,mod-2)%mod*invf[i]%mod;
    g[1]=n+1;
    int lim=1,ct=0;
    while(lim<n<<1)
        lim<<=1,++ct;
    for(register int i=0;i<lim;++i)
        R[i]=(R[i>>1]>>1)|((i&1)<<(ct-1));
    NTT(f,lim,1),NTT(g,lim,1);
    for(register int i=0;i<lim;++i)
        f[i]=1ll*f[i]*g[i]%mod;
    NTT(f,lim,-1);
    int inv=power(lim,mod-2);
    for(register int i=0;i<=n;++i)
        ans=(0ll+ans+1ll*power(2,i)*fac[i]%mod*f[i]%mod*inv%mod)%mod;
    write(ans);
	return 0;
}
```

---

## 作者：ysy20021208 (赞：0)

# [Tjoi2016&Heoi2016]求和

首先我们思考什么是第二类斯特林数，它的定义为把$n$个不同的小球放在$m$个相同的盒子里方案数，我们回头看式子，发现$S(i，j)\times (j!)$就是将$n$个不同的小球放在$m$个不同的盒子里的方案数，现在我们假设$ g[i]$表示将$i$个不同小球划分在任意多个盒子中得方案数，我们先考虑暴力转移，我们可以枚举最后一个盒子有多少个小球。这样我们就得到：

$$
g[i]=\sum \limits _{j=1}^{j\le i}g[i-j]\times C_i^j
$$

现在我们令$G[i]=\frac{g[i]}{i!}$，则我们可以得到：

$$
G[i]=\frac{g[i]}{i!}=\sum \limits _{j=1}^{j\le i}g[i-j]\times \frac{i!}{(i-j)!}
$$

$$
G[i]=\frac{g[i]}{i!}=\sum \limits _{j=1}^{j\le i}i!\times \frac{g[i-j]}{(i-j)!}
$$

$$
G[i]=\frac{g[i]}{i!}=\sum \limits _{j=1}^{j\le i}i!\times G[i-j]
$$

$$
G[i]=\sum \limits _{j=1}^{j\le i}i!\times G[i-j]
$$

我们可以发现上面的式子$G[i]$就和我们题目中要求的多项式的第$i$位相差$2^j$。我们考虑$2^j$的含义，它的实质就是$2$的我们分得盒子数次方，这样我们只需要对上述式子略加修改：
$$
G[i]=\sum \limits _{j=1}^{j\le i}2\times i!\times G[i-j]
$$

我们可以发现上面的式子可以看做自卷积，我们令$H[i]=2\times i!$。这样每一次转移就是$G=G\times H+1$，我们考虑最后的$1$是什么东西，这个$1$是$G[0]$的值，我们发现上面的式子中没有更新$G[0]$的。我们进行变形可以得到$G=\frac{1}{1-H}$，最后用多项式求逆做一下就好了。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define mod 998244353
#define N 1000010
int a[N],b[N],A[N],B[N],inv[N],len,n,ans;
int qpow(int x,int y)
	{int tmp=1; while(y) {if(y&1) tmp=1ll*tmp*x%mod; x=1ll*x*x%mod,y>>=1;} return tmp;}
void ntt(int *a,int len,int miku)
{
	for(int i=0,k=0;i<len;i++)
	{
		if(i>k) swap(a[i],a[k]);
		for(int j=len>>1;(k^=j)<j;j>>=1);
	}
	for(int k=2;k<=len;k<<=1)
	{
		int t=k>>1,x=qpow(3,(mod-1)/k);
		if(miku==-1) x=qpow(x,mod-2);
		for(int i=0;i<len;i+=k)
		{
			int w=1;
			for(int j=i;j<i+t;j++)
			{
				int tmp=1ll*a[j+t]*w%mod;
				a[j+t]=(a[j]-tmp+mod)%mod;
				a[j]=(a[j]+tmp)%mod;
				w=1ll*w*x%mod;
			}
		}
	}
	if(miku==-1)
		for(int i=0,t=qpow(len,mod-2);i<len;i++)
			a[i]=1ll*a[i]*t%mod;
}
void get_inv(int *a,int *b,int len)
{
	if(len==1) {b[0]=qpow(a[0],mod-2);return;}
	get_inv(a,b,len>>1); int t=len<<1;
	for(int i=0;i<len;i++) A[i]=a[i],B[i]=b[i];
	ntt(A,t,1),ntt(B,t,1);
	for(int i=0;i<t;i++) A[i]=((1ll*A[i]*B[i])%mod*B[i])%mod;
	ntt(A,t,-1);
	for(int i=0;i<len;i++)
		b[i]=((b[i]<<1)%mod-A[i]+mod)%mod;
}
int main()
{
	scanf("%d",&n),inv[0]=inv[1]=len=a[0]=1;
	while(len<=n) len<<=1;
	for(int i=2;i<=n;i++) inv[i]=mod-1ll*inv[mod%i]*(mod/i)%mod;
	for(int i=3;i<=n;i++) inv[i]=1ll*inv[i-1]*inv[i]%mod;
	for(int i=1;i<=n;i++) a[i]=(mod-inv[i])*2%mod;
	get_inv(a,b,len),ans=b[n];
	for(int i=n;i;i--) ans=(1ll*ans*i%mod+b[i-1])%mod;
	printf("%d\n",ans);
}
```

---

## 作者：Jμdge (赞：0)

困难的地方其实就在于推式子（推到一半的我居然忘记了等比数列求和公式，完蛋）

# derivation

$$\sum_{i=0}^n \sum_{j=0}^i 2^j j! \begin{Bmatrix} i \\j \end{Bmatrix} $$

斯特林数 $\begin{Bmatrix} i \\j \end{Bmatrix}$ 中的 i 如果小于 j 的话是为 0 的，所以 j 开到 n 没关系

$$\sum_{i=0}^n \sum_{j=0}^n 2^j j! \begin{Bmatrix} i \\j \end{Bmatrix} $$

接下来是套路的移项

$$ \sum_{j=0}^n 2^j j!\sum_{i=0}^n \begin{Bmatrix} i \\j \end{Bmatrix} $$

然后就是用第二类斯特林数的公式带入

$$ \sum_{j=0}^n 2^j j!\sum_{i=0}^n {1\over j!}\sum_{k=0}^j (-1)^k \Big( \begin{matrix} j\\k \end{matrix}  \Big) (j-k)^i $$

各种化简之后就是


$$ \sum_{j=0}^n 2^j j!\sum_{i=0}^n \sum_{k=0}^j {(-1)^k\over k!}  {(j-k)^i\over (j-k)!} $$

再来一波移项

$$ \sum_{j=0}^n 2^j j!\sum_{k=0}^j {(-1)^k\over k!}  {\sum_{i=0}^n (j-k)^i\over (j-k)!} $$


后面就是我说的那个等比公式了...我们看到 $ {\sum_{i=0}^n (j-k)^i}$ 等于 $ { (j-k)^{n+1} -1 \over (j-k)-1}$

$$ \sum_{j=0}^n 2^j j!\sum_{k=0}^j {(-1)^k\over k!}  {{ (j-k)^{n+1} -1 }\over  ((j-k)-1)(j-k)!} $$

虽然后面的式子看起来有点诡异，但还是可以看出后面是一个卷积的形式，卷的是 j ，我们令 $f(i)={(-1)^i\over i!}$ , $g(i)={i^n\over i!}$ （这里的 n 其实是上面式子里的 i ），所以原式就是

$$ \sum_{j=0}^n 2^j j! (f* g)(j) $$


那么我们一遍 NTT 求出所有的 $(f* g)(i), i∈[0,n]$ 然后带入式子求解就好了

这里用了预处理 $fac$ 、 $inv$ 、$finv$ 的方法

# 卡常须知

>可以考虑预处理出 NTT 中使用的 g 数组

>可以考虑多加几个 register （但要做好代码变慢的准备）

>感觉别的地方都没有卡常（因为平时就是这么写的）


# code

当然是没卡过常的那份【滑稽

话说为什么我卡常越卡越慢的。。。

代码压的太起劲，但其实没什么参考价值，两个多项式构造一下 NTT 就好了，没什么特别（要抄）的地方

注意 limit 要开的 n* 2 大...（我就是这么挂的）

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=27e4+3;
typedef int arr[M];
int n,limit,ans; arr f,g,r,fac,inv,finv;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x<y?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int qpow(int x,int p=mod-2,int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void get_rev(int n){ int len=-1;
	for(limit=1;limit<=n<<1;limit<<=1)++len;
	fp(i,1,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<len);
}
inline void prep(){ get_rev(n),fac[0]=fac[1]=inv[0]=inv[1]=finv[0]=finv[1]=1;
	fp(i,2,n) fac[i]=mul(fac[i-1],i),inv[i]=mul(inv[mod%i],mod-mod/i),finv[i]=mul(finv[i-1],inv[i]);
}
inline void NTT(int* a,int tp){ fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1;mid<limit;mid<<=1){ int Gn=qpow(tp?3:iG,(mod-1)/(mid<<1));
		for(int j=0,x,y;j<limit;j+=mid<<1) for(int k=0,g=1;k<mid;++k,g=mul(g,Gn))
			x=a[j+k],y=mul(g,a[j+k+mid]),a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	} if(tp) return ; int inv=qpow(limit); fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
int main(){ scanf("%d",&n),prep(); int now=1;
	f[0]=g[0]=1,g[1]=n+1; fp(i,1,n) f[i]=mul(finv[i],i&1?mod-1:1);
	fp(i,2,n) g[i]=mul(dec(qpow(i,n+1),1),mul(inv[i-1],finv[i]));
	NTT(f,1),NTT(g,1); fp(i,0,limit-1) f[i]=mul(f[i],g[i]); NTT(f,0);
	fp(i,0,n) ans=inc(ans,mul(mul(now,fac[i]),f[i])),now=mul(now,2);
	return !printf("%d\n",ans);
}
```



---


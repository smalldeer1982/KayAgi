# WD与积木

## 题目背景

WD整日沉浸在积木中，无法自拔……

## 题目描述

WD想买 $n$ 块积木，商场中每块积木的高度都是 $1$，俯视图为正方形（边长不一定相同）。由于一些特殊原因，商家会给每个积木随机一个大小并标号，发给 WD。

接下来 WD 会把相同大小的积木放在一层，并把所有层从大到小堆起来。WD 希望知道所有不同的堆法中层数的期望。**两种堆法不同当且仅当某个积木在两种堆法中处于不同的层中，由于WD只关心积木的相对大小，因此所有堆法等概率出现，而不是随机的大小等概率（可以看样例理解）。**   
输出结果 $\bmod \space 998244353$ 即可。

（如果还是不能够理解题意，请看样例）

## 说明/提示

接下来用大括号表示分在一层。

对于$n=1$，合法的分法只有$\{1\}$；

对于$n=2$，合法的序列有$\{1,2\}$，$\{1\}\{2\}$，$\{2\}\{1\}$，期望层数为$\frac{1+2+2}{3}=665496237(mod~998244353)$；

对于$n=3$，合法的序列有$\{1\}\{2\}\{3\}$，$\{1\}\{3\}\{2\}$，$\{2\}\{1\}\{3\}$，$\{2\}\{3\}\{1\}$，$\{3\}\{1\}\{2\}$，$\{3\}\{2\}\{1\}$

$\{1,2\}\{3\}$，$\{1,3\}\{2\}$，$\{2,3\}\{1\}$，$\{1\}\{2,3\}$，$\{2\}\{1,3\}$，$\{3\}\{1,2\}$，$\{1,2,3\}$共13种。因此期望就是$\frac{6\times3+6\times2+1}{13}=307152111(mod~998244353)$

~~对于$n=4$，我想到了一个绝妙的解释，可惜这里写不下。~~

$subtask1(21pts):~1\le T\le 1,000,~1\le n\le 1,000$

$subtask2(37pts):~1\le T\le 10,~1\le n\le 100,000$

$subtask3(42pts):~1\le T\le 100,000,~1\le n\le 100,000$

## 样例 #1

### 输入

```
4
1
2
3
4```

### 输出

```
1
665496237
307152111
186338949```

# 题解

## 作者：Weng_Weijie (赞：27)

由于是选出积木有标号，所以使用指数型生成函数

先考虑选的方案数

显然每一层的生成函数为 $F(x)=\displaystyle\sum_{k=1}^{\infty}\dfrac 1{k!}x^k=e^x-1$

枚举层数，答案即为 $\displaystyle\sum_{k=0}^{\infty}F^k(x)=\dfrac 1{1-F(x)}=\dfrac 1{2-e^x}$

接下来求所有方案的层数总和

枚举层数，答案即为 $\displaystyle\sum_{k=0}^{\infty}kF^k(x)=\dfrac {F(x)}{(1-F(x))^2}=\dfrac{e^x-1}{(2-e^x)^2}$

然后就可以用 FFT+多项式求逆 做完了

---

## 作者：Leianha (赞：14)

### [博客阅读](https://www.cnblogs.com/wljss/p/12036854.html)

$NTT$ 神仙题，orz  memset0。

题面没看太懂，大概意思就是求有n个不同的小球，放进 $1$、$2$、$……n $ 个不同的盒子，不可空的情况下，期望用了几个盒子。

按照套路，我们应该分别求出总的方案数$g_i$和总共用的盒子数 $f_i$ ,答案就是 $f_i\times g_i^{-1}$。

我们先来求总的方案数，设 $S$ 是第二类斯特林数，则

$\displaystyle g_n=\sum_{i=1}^nS[n][i]\times i!$

就是我们枚举用了几个盒子，在乘上 $i!$ 将盒子看成是不一样的。

但是我们没办法进行下去了，我们考虑一下递推式。

$\displaystyle g_n=\sum_{i=1}^nC_n^ig_{n-i}$

含义就是我们枚举第一个盒子里都有哪些球，再乘上剩下的球的方案数 $g_{n-i}$ 。我们尝试化简一下式子。

$\displaystyle g_n=\sum_{i=1}^n \frac{n!}{i!(n-i)!}g_{n-i}$
$\displaystyle \frac{g_n}{n!}=\sum_{i=1}^n \frac{1}{i!}\frac{g_{n-i}}{(n-i)!}$

设 $\displaystyle G_n=\frac{g_n}{n!}$   $\displaystyle H_n=\frac{1}{n!}$ ,注意 $H_0=1,G_0=1$ 那么

$\displaystyle G_n=\sum_{i=1}^nH_iG_{n-i}$

有点像分治 $FFT$ ，~~但我们会多项式求逆~~,我们按照分治 $FFT$ 的套路来。

设 $\displaystyle G=\sum_{i=0}^{\infty}G_ix^i$   $\displaystyle H=\sum_{i=0}^{\infty}H_ix^i$

$\displaystyle G*H=\sum_{i=0}^{\infty}(\sum_{j+k=i}G_jH_k)x^i$

当 $i>0$ 时，$\displaystyle \sum_{j+k=i}G_jH_k=\sum_{j=0}^iH_jG_{i-j}=\sum_{j=1}^iH_jG_{i-j}+H_0G_i=2G_i$

当 $i=0$ 时，$G_0H_0=1=2G_0-1$

所以

$G*H=2G-1$

$G=(2-H)^{-1}$

多项式求逆一波带走。 

我们再来看看怎么求总共的盒子数。

$\displaystyle f_n=g_n+\sum_{i=1}^nC_n^if_{n-i}$

含义就是首先我们每一种方案至少有一个盒子，所以我们先加上 $g_n$ ,对于剩下的 $n-i$ 个小球，对答案的贡献就是 $f_{n-i}$ ,因为第一个盒子有 $C_n^i$ 种选法，所以就是 $\displaystyle f_n=g_n+\sum_{i=1}^nC_n^if_{n-i}$

我们再来搞一搞。现将 $\displaystyle g_n=\sum_{i=1}^nC_n^ig_{n-i}$ 带进去。

$\displaystyle f_n=\sum_{i=1}^nC_n^ig_{n-i}+\sum_{i=1}^nC_n^if_{n-i}$

$\displaystyle \frac{f_n}{n!}=\sum_{i=1}^{n}\frac{1}{i!}\frac{g_{n-i}}{(n-i)!}+\sum_{i=1}^{n}\frac{1}{i!}\frac{f_{n-i}}{(n-i)!}$

设 $\displaystyle F_n=\frac{f_n}{n!}$

$\displaystyle F_n=\sum_{i=1}^nH_i(F_{n-i}+G_{n-i})$

设 $\displaystyle F=\sum_{i=0}^{\infty}F_ix^i$

那么

$\displaystyle H*(F+G)=\sum_{i=0}^{\infty}(\sum_{j+k=i}((F_k+G_k)H_j))x^i$ （注意看清大括号）

当 $i>0$ 时，$\displaystyle \sum_{j+k=i}(F_k+G_k)H_j=\sum_{j=0}^i(F_{i-j}+G_{i-j})H_{j}=\sum_{j=1}^i(F_{i-j}+G_{i-j})H_{j}+F_i+G_i=2F_i+G_i$

当 $i=0$ 时，$(F_0+G_0)H_0=1=2F_0+G_0$

所以

$\displaystyle H*(F+G)=2F+G$

$\displaystyle F=\frac{G-GH}{H-2}$

因为 $G=(2-H)^{-1}$

所以 $G-GH=1-G$

带进去

$\displaystyle F=(1-G)(H-2)^{-1}$

最后答案就是 $F_nG_n^{-1}$

推这些式子我竟然推了一下午，我还是太菜了。

```cpp
#include<iostream>
#include<cstdio>
#define DB double
#define LL long long
using namespace std;
int T, n;
const int N = 400010, M = 100000, mod = 998244353, YY = 3, YYinv = (mod + 1) / 3;
int r[N];
LL jc[N], inv[N], H[N], g[N], G[N], F[N];
inline int read() 
{
	int res = 0; char ch = getchar(); bool XX = false;
	for (; !isdigit(ch); ch = getchar())(ch == '-') && (XX = true);
	for (; isdigit(ch); ch = getchar())res = (res << 3) + (res << 1) + (ch ^ 48);
	return XX ? -res : res;
}
void Write(int x, int opt) 
{
	if (opt && !x)putchar('0');
	if (!x)return;
	Write(x / 10, 0);
	putchar((x - x / 10 * 10) + '0');
}
LL ksm(LL a, LL b, LL mod) 
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
void NTT(LL *A, int lim, int opt) 
{
	for (int i = 0; i < lim; ++i)
		r[i] = (r[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);
	for (int i = 0; i < lim; ++i)
		if (i < r[i])swap(A[i], A[r[i]]);
	int len;
	LL wn, w, x, y;
	for (int mid = 1; mid < lim; mid <<= 1) 
	{
		len = mid << 1;
		wn = ksm(opt == 1 ? YY : YYinv, (mod - 1) / len, mod);
		for (int j = 0; j < lim; j += len) 
		{
			w = 1;
			for (int k = j; k < j + mid; ++k, w = w * wn % mod) 
			{
				x = A[k]; y = A[k + mid] * w % mod;
				A[k] = (x + y) % mod;
				A[k + mid] = (x - y + mod) % mod;
			}
		}
	}
	if (opt == 1)return;
	int ni = ksm(lim, mod - 2, mod);
	for (int i = 0; i < lim; ++i)A[i] = A[i] * ni % mod;
}
LL c[N];
void INV(int siz, LL *A, LL *B) 
{
	if (siz == 1) 
	{
		B[0] = ksm(A[0], mod - 2, mod);
		return;
	}
	INV((siz + 1) >> 1, A, B);
	int lim = 1;
	while (lim < (siz << 1))lim <<= 1;
	for (int i = 0; i < siz; ++i)c[i] = A[i];
	for (int i = siz; i < lim; ++i)c[i] = 0;
	NTT(c, lim, 1); NTT(B, lim, 1);
	for (int i = 0; i < lim; ++i)B[i] = B[i] * (2 - c[i] * B[i] % mod + mod) % mod;
	NTT(B, lim, -1);
	for (int i = siz; i < lim; ++i)B[i] = 0;
}
void MUL(LL *A, int n, LL *B, int m) 
{
	int lim = 1;
	while (lim < (n + m))lim <<= 1;
	NTT(A, lim, 1); NTT(B, lim, 1);
	for (int i = 0; i < lim; ++i)A[i] = A[i] * B[i] % mod;
	NTT(A, lim, -1);
}
void YYCH() 
{
	inv[0] = inv[1] = jc[0] = jc[1] = 1;
	for (int i = 2; i <= M; ++i)jc[i] = jc[i - 1] * i % mod;
	inv[M] = ksm(jc[M], mod - 2, mod);
	for (int i = M - 1; i >= 1; --i)inv[i] = inv[i + 1] * (i + 1) % mod;
	for (int i = 0; i <= M; ++i) 
	{
		H[i] = inv[i];
		g[i] = mod - H[i];
	}
	g[0] += 2;
	INV(M + 1, g, G);
	for (int i = 0; i <= M; ++i) 
	{
		F[i] = G[i]; g[i] = G[i];
	}
	F[0]--;
	MUL(F, M, g, M);
}
int main() 
{
	YYCH();
	cin >> T;
	while (T--) 
	{
		n = read();
		printf("%lld\n", F[n]*ksm(G[n], mod - 2, mod) % mod);
	}
	return 0;
}
```


---

## 作者：Owen_codeisking (赞：7)

论如何用 $OEIS$ 做题

主讲人：$Owen\_codeisking$

方法提出者：$ljc1301$

第二天 $ljc1301$ 向我传授了这种方法，不用写什么暴力，会抄板子就能 $A$ 掉此题

我们可以以各种方式得到 $n=4$ 时分子为 $233$，分母为 $75$

分子的数列：$1,5,31,233,...$

分母的数列：$1,3,13,75,...$

我们在 $OEIS$ 用数列的前四项找到分子式只有一个数列，分母有十个等价的数列。找到分子 $FORMULA$ 那里有 `(exp(x)-1)/((2-exp(x))^2)`，分母 $FORMULA$ 那里有 ` 1/(2-exp(x))`

分子的通项公式：$\Large\frac{e^x-1}{(2-e^x)^2}$

分母的通项公式：$\Large\frac{1}{2-e^x}$

然后我们发现出题人非常良心，不需要我们用任意模数 $NTT$，所以我们用朴素的 $NTT$ 就行了

$P.S:e^n=\sum_{i=0}^{n}\Large\frac{1}{i!}x^{i}$

预处理一下逆元，对 $\Large\frac{1}{2-e^x}$ 多项式求逆，然后用分母的式子推到分子的式子就好了

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=500000+10;
const int mod=998244353;
int n,fac[maxn],inv[maxn],a[maxn],b[maxn],c[maxn],f[maxn],r[maxn];

inline void read(int &x){
    x=0;int f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    if(f==-1) x=-x;
}
void print(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline int add(int x,int y){
    x+=y;x>=mod?x-=mod:0;
    return x;
}
inline int sub(int x,int y){
    x-=y;x<0?x+=mod:0;
    return x;
}
inline int mul(int x,int y){
    x=1ll*x*y%mod;
    return x;
}
inline int fast_pow(int a,int b){
    int ret=1;
    for(;b;b>>=1,a=mul(a,a))
        if(b&1) ret=mul(ret,a);
    return ret;
}

void NTT(int *f,int n,int op){
    for(int i=0;i<n;i++)
        if(i<r[i]) swap(f[i],f[r[i]]);
    int buf,tmp,x,y;
    for(int len=1;len<n;len<<=1){
        tmp=fast_pow(3,(mod-1)/(len<<1));
        if(op==-1) tmp=fast_pow(tmp,mod-2);
        for(int i=0;i<n;i+=len<<1){
            buf=1;
            for(int j=0;j<len;j++){
                x=f[i+j];y=mul(buf,f[i+j+len]);
                f[i+j]=add(x,y);f[i+j+len]=sub(x,y);
                buf=mul(buf,tmp);
            }
        }
    }
    if(op==1) return ;
    int inv=fast_pow(n,mod-2);
    for(int i=0;i<n;i++) f[i]=mul(f[i],inv);
}

void work(int n,int *a,int *b){
    if(n==1){
        b[0]=fast_pow(a[0],mod-2);
        return ;
    }
    work((n+1)>>1,a,b);
    int lim=1;
    for(;lim<(n<<1);lim<<=1);
    for(int i=1;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?(lim>>1):0);
    for(int i=0;i<n;i++) c[i]=a[i];
    for(int i=n;i<lim;i++) c[i]=0;
    NTT(b,lim,1);NTT(c,lim,1);
    for(int i=0;i<lim;i++) b[i]=mul(sub(2,mul(b[i],c[i])),b[i]);
    NTT(b,lim,-1);
    for(int i=n;i<lim;i++) b[i]=0;
}

int main()
{
    n=100001;
    int T;read(T);fac[0]=1;
    for(int i=1;i<n;i++) fac[i]=mul(fac[i-1],i);
    inv[n-1]=fast_pow(fac[n-1],mod-2);
    for(int i=n-2;i>=0;i--) inv[i]=mul(inv[i+1],i+1);
    for(int i=0;i<n;i++) a[i]=mod-inv[i];
    a[0]=add(a[0],2);work(n,a,b);
    for(int i=0;i<n;i++) a[i]=f[i]=b[i];
    a[0]=add(a[0],mod-1);
    int lim=1;
    while(lim<=n) lim<<=1;
    NTT(f,lim<<1,1);NTT(a,lim<<1,1);
    for(int i=0;i<(lim<<1);i++) f[i]=mul(f[i],a[i]);
    NTT(f,lim<<1,-1);
    while(T--){
    	read(n);
    	print(mul(f[n],fast_pow(b[n],mod-2)));putchar('\n');
	}
    return 0;
}
```

---

## 作者：qwaszx (赞：5)

水一发爆算题解(其实挺好算

分子分母分开算，分子就枚举分了几层然后第二类斯特林数搞搞，分母也一样，写出式子来即

$$\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}i!\qquad\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}i!\cdot i$$

然后不知道该干啥就大力对$n$套一个生成函数，这题带标号所以选EGF，有

$$\begin{aligned}&\sum_{n\geq 0}\frac{x^n}{n!}\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}i!\\=&\sum_{i\geq 0}i!\sum_{n\geq 0}\frac{x^n}{n!}\begin{Bmatrix}n\\i\end{Bmatrix}\\=&\sum_{i\geq 0}\sum_{n\geq 0}\frac{x^n}{n!}\sum_{k=0}^i(-1)^k\binom{i}{k}(i-k)^n\\=&\sum_{i\geq 0}\sum_{k=0}^i(-1)^{i-k}\binom{i}{k}\sum_{n\geq 0}\frac{(kx)^n}{n!}\\=&\sum_{i\geq 0}\sum_{k=0}^i(-1)^{i-k}\binom{i}{k}(e^x)^k\\=&\sum_{i\geq 0}(e^x-1)^i\\=&\frac{1}{2-e^x}\end{aligned}$$

另一个同理，算出来是

$$\frac{e^x-1}{(2-e^x)^2}$$

求逆就完了.

代码带着个又臭又长的多项式板子就不放了(((

---

## 作者：lkytxdy (赞：3)

## P5162 WD与积木


设 $f_{i,j}$ 表示用了 $i$ 层放了 $j$ 个积木的方案数，每层非空，$f_{i,j}=\sum_{k=1}^j \binom j kf_{i-1,k}$，$\{0,1,1,1,\cdots\}$ 的 EGF 为 $F(x)=\sum_{i=1}^{\infty}\large\frac{x^i}{i!}$，$f_i$ 的 EGF 实际上是 $f_{i-1}$ 的 EGF 与 $F$ 的卷积，也就是 $F^i$。

方案总数为 $n!\times [x^n]\sum_{i\geq 0}F^i=n!\times [x^n]\large\frac{1}{1-F}$。

所有方案层数之和为 $\sum_{i=1}^n if_{i,n}=n!\normalsize\times [x^n]\sum_{i\geq 1}iF^i=n!\times [x^n]\large\frac{F}{(1-F)^2}$，最后一步是错位相减 & $\sum_{i\geq 1}F^i=\frac{F}{1-F}$ 得到的。

多项式求逆即可。

```cpp
//lkytxdy
#include<bits/stdc++.h>
using namespace std;
const int N=(1<<20)+5,mod=998244353;
int t,n=1e5,fac[N],iv[N],a[N],b[N],c[N],d[N],len,r[N],A[N],B[N],p[N],q[N];
int qpow(int x,int n){
	int ans=1;
	for(;n;n>>=1,x=1ll*x*x%mod) if(n&1) ans=1ll*ans*x%mod;
	return ans;
}
void NTT(int *a,int n,int op){
	for(int i=0;i<n;i++) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int k=2;k<=n;k<<=1){
		int m=k>>1,v=qpow(~op?3:qpow(3,mod-2),(mod-1)/k),w=1,x,y; 
		for(int i=0;i<n;i+=k,w=1)
			for(int j=i;j<i+m;j++)
				x=a[j],y=1ll*w*a[j+m]%mod,a[j]=(x+y)%mod,a[j+m]=(x-y+mod)%mod,w=1ll*w*v%mod;
	}
	if(op==-1){
		int inv=qpow(n,mod-2);
		for(int i=0;i<n;i++) a[i]=1ll*a[i]*inv%mod;
	}
} 
void mul(int *a,int *b,int len){
	for(int i=0;i<len;i++)
		p[i]=a[i],q[i]=b[i],r[i]=r[i>>1]>>1|(i&1?len>>1:0);
	NTT(p,len,1),NTT(q,len,1);
	for(int i=0;i<len;i++) a[i]=1ll*p[i]*q[i]%mod;
	NTT(a,len,-1);
}
void inv(int *a,int *b,int len){
	for(int i=0;i<len;i++) b[i]=0;
	b[0]=qpow(a[0],mod-2);
	for(int i=2;i<=len;i<<=1){
		for(int j=0;j<(i<<1);j++) A[j]=j<i?a[j]:0,B[j]=j<(i>>1)?b[j]:0; 
		mul(B,B,i),mul(A,B,i<<1);
		for(int j=0;j<i;j++) b[j]=(2ll*b[j]%mod-A[j]+mod)%mod;
	}
}
signed main(){
	scanf("%d",&t),fac[0]=iv[0]=iv[1]=1;
	for(int i=2;i<=n;i++) iv[i]=1ll*iv[mod%i]*(mod-mod/i)%mod;
	for(int i=1;i<=n;i++)
		fac[i]=1ll*fac[i-1]*i%mod,a[i]=iv[i]=1ll*iv[i-1]*iv[i]%mod,b[i]=mod-a[i];
	for(len=1;len<=n;len<<=1);
	b[0]++,inv(b,c,len),mul(b,b,len<<1),inv(b,d,len<<1),mul(a,d,len<<2);
	while(t--){
		scanf("%d",&n);
		printf("%lld\n",1ll*a[n]%mod*qpow(c[n],mod-2)%mod);
	}
	return 0;
}
```



---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

问题可以退化成两个部分：

 - 给定 $n$，求 $[1,2,\dots,n]$ 有多少个有序划分；
 - 给定 $n$，求这些有序划分中所有有序划分里面集合数量之和。

其中一个有序划分是一个非空集合序列 $A=[S_1,S_2,\dots,S_k]$ ，满足任意一个在 ${1,2,\dots,n}$ 里面的元素在恰好一个 $S_1,S_2,\dots,S_k$ 里面。两个有序划分 $A,B$ 不同当且仅当它们的长度不同或者存在一个 $k$ 使得 $A_k\neq B_k$。注意集合无序，但是序列有序。

第一个答案为输出分母，第二个答案为输出分子。

分别推式子。

## 第一部分

枚举划分成多少集合，叫 $k$。如果无序的话，那么这里的答案 $\left\{{n\atop k}\right\}$，但是因为有序，这个不够。由于所有集合互不相同，可以直接乘 $k!$ 来补起来。

因为这道题目有多组数据，时间复杂度更快来直接考虑生成函数（这里用 egf 因为显然更方便）

$$F(z)=\sum_{n=0}^\infty(\sum_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}k!)\frac{z^n}{n!}$$

推

$$F(z)=\sum_{k=0}^\infty(e^z-1)^k$$

$$F(z)=\frac{1}{2-e^z}$$

## 第二部分

这个可以从上面微微改变来推出来。每一次枚举 $n,k$ 的时候在考虑一下对这个 $n$ 的答案贡献。这个贡献就是序列多长：$k$。所以 $\left\{{n\atop k}\right\}k!$ 变成 $\left\{{n\atop k}\right\}k!k$ 就可以了。

$$G(z)=\sum_{n=0}^\infty(\sum_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}k!k)\frac{z^n}{n!}$$

$$G(z)=\sum_{k=0}^\infty k(e^z-1)^k$$

用式子 $\sum kc^k=\frac{c}{(1-c)^2}$

$$G(z)=\frac{e^z-1}{(2-e^z)^2}$$

好了，直接做多项式 exp&逆元&乘法 就够，然后注意一堆细节就可以，我调试了好长时间（

最终答案：

$$a(n)=n!\frac{[x^n]\frac{1}{2-e^z}}{[x^n]\frac{e^z-1}{(2-e^z)^2}}$$

特别注意

$$\frac{[x^n]F(x)}{[x^n]G(x)}\neq[x^n]\frac{F(x)}{G(x)}$$

代码由于板子太长，就不放在这里了。

---

## 作者：p_b_p_b (赞：2)

[$$\large \color{purple} My\;Blog$$](https://www.cnblogs.com/p-b-p-b/p/10352594.html)

---------


## 题解

真是非常套路的一道题……

考虑$DP$：设$f_n$为$n$个积木能搭出的方案数，$g_n$为所有方案的高度之和。

容易得到转移方程：

$$f_n=[n=0]+\sum_{i=1}^n {n \choose i} f_{n-i}$$
$$g_n=\sum_{i=1}^n {n \choose i} (f_{n-i}+g_{n-i})$$
发现$f_n$似乎更容易搞出来，我们先搞$f_n$。

由转移方程可以得到：

$$\frac{f_n}{n!}=[n=0]+\sum_{i=1}^n \frac{1}{i!} \frac{f_{n-i}}{(n-i)!}$$

设

$$F(x)=\sum_n \frac{f_n}{n!} x^n$$
$$S(x)=\sum_{n=1}^{\infty} \frac{1}{n!} x^n$$

则有

$$F(x)-1=F(x)S(x)$$
$$F(x)=\frac{1}{1-S(x)}$$

多项式求逆即可。

接下来是求$g_n$。

令$t_n=f_n+g_n$，则有

$$\frac{g_n}{n!}=\sum_{i=1}^n \frac{1}{i!} \frac{t_{n-i}}{(n-i)!}$$

设

$$G(x)=\sum_n \frac{g_n}{n!} x^n$$
$$T(x)=\sum_n \frac{t_n}{n!}=F(x)+G(x)$$

可以得到

$$G(x)=S(x)T(x)=S(x)F(x)+S(x)G(x)$$
$$G(x)=\frac{S(x)F(x)}{1-S(x)}=S(x)[F(x)]^2=F(x)(F(x)-1)$$

NTT即可。

最后$ans_n=\frac{g_n}{f_n}$。

-----------

## 代码

```cpp
#include<bits/stdc++.h>
namespace my_std{
	using namespace std;
	#define pii pair<int,int>
	#define fir first
	#define sec second
	#define MP make_pair
	#define rep(i,x,y) for (int i=(x);i<=(y);i++)
	#define drep(i,x,y) for (int i=(x);i>=(y);i--)
	#define go(x) for (int i=head[x];i;i=edge[i].nxt)
	#define sz 400404
	typedef long long ll;
	const ll mod=998244353;
	template<typename T>
	inline void read(T& t)
	{
		t=0;char f=0,ch=getchar();
		double d=0.1;
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
		if(ch=='.')
		{
			ch=getchar();
			while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();
		}
		t=(f?-t:t);
	}
	template<typename T,typename... Args>
	inline void read(T& t,Args&... args){read(t); read(args...);}
	void file()
	{
		#ifndef ONLINE_JUDGE
		freopen("a.txt","r",stdin);
		#endif
	}
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

inline ll ksm(ll x,int y)
{
	ll ret=1;
	for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;
	return ret;
}
ll inv(ll x){return ksm(x,mod-2);}

int r[sz],limit;
void NTT_init(int n)
{
	limit=1;int l=-1;
	while (limit<=n+n) limit<<=1,++l;
	rep(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<l);
}
void NTT(ll *a,int type)
{
	rep(i,0,limit-1) if (i<r[i]) swap(a[i],a[r[i]]);
	for (int mid=1;mid<limit;mid<<=1)
	{
		ll Wn=ksm(3,(mod-1)/mid>>1);if (type==-1) Wn=inv(Wn);
		for (int len=mid<<1,j=0;j<limit;j+=len)
		{
			ll w=1;
			for (int k=0;k<mid;k++,w=w*Wn%mod)
			{
				ll x=a[j+k],y=w*a[j+k+mid]%mod;
				a[j+k]=(x+y)%mod;a[j+k+mid]=(mod+x-y)%mod;
			}
		}
	}
	if (type==1) return;
	ll I=inv(limit);
	rep(i,0,limit-1) a[i]=a[i]*I%mod;
}
ll tmp1[sz],tmp2[sz];
void PolyInv(ll *a,ll *f,int n)
{
	if (n==1) return (void)(f[0]=inv(a[0]));
	int mid=(n+1)>>1;
	PolyInv(a,f,mid);
	NTT_init(n);
	rep(i,0,mid-1) tmp1[i]=f[i];
	rep(i,0,n-1) tmp2[i]=a[i];
	NTT(tmp1,1);NTT(tmp2,1);
	rep(i,0,limit-1) tmp1[i]=tmp1[i]*(mod+2-tmp1[i]*tmp2[i]%mod)%mod;
	NTT(tmp1,-1);
	rep(i,0,n-1) f[i]=tmp1[i];
	rep(i,0,limit-1) tmp1[i]=tmp2[i]=0;
}

ll fac[sz],_fac[sz];
void init(){fac[0]=_fac[0]=1;rep(i,1,sz-1) _fac[i]=inv(fac[i]=fac[i-1]*i%mod);}

ll f[sz],g[sz],s[sz];
ll t1[sz],t2[sz],t3[sz],t4[sz];

int main()
{
	file();
	init();
	int n=1e5+5,T;
	rep(i,1,n) s[i]=mod-_fac[i];
	++s[0];
	PolyInv(s,t1,n);
	rep(i,1,n) f[i]=t1[i];f[0]=1;
	rep(i,0,n) t2[i]=t3[i]=f[i];--t3[0];
	NTT_init(n);
	NTT(t2,1);NTT(t3,1);
	rep(i,0,limit-1) t4[i]=t2[i]*t3[i]%mod;
	NTT(t4,-1);
	rep(i,1,n) g[i]=t4[i];
	read(T);
	while (T--) read(n),printf("%lld\n",g[n]*inv(f[n])%mod);
}
```

看完你谷神仙的题解后突然感觉我的方法真麻烦……

---

## 作者：Lyrella (赞：1)

# 要点总结

1. 元素有序用 EGF
2. 组合组成的序列的 EGF 封闭形式

# 题意

将 $n$ 个有标号的积木放若干层，求期望层数。

# 题解

因为积木有标号所以用 EGF，对于一层的生成函数为：
$$
F(x)=\sum_i{x^i\over i!}
$$
对于 n 层的生成函数就是：
$$
G(x)=\sum_iF(x)^i={1\over1-(e^x-1)}={1\over2-e^x}
$$
对于 n 层的答案是：
$$
H(x)=\sum_iiF(x)^i={e^x-1\over2-e^x}
$$
求期望就是 $H(x)\over G(x)$，时间复杂度 $O(n\log n)$。

---

## 作者：xuyiyang (赞：0)

### [P5162 WD与积木](https://www.luogu.com.cn/problem/P5162)
多项式好玩！$\\$
首先算出情况总数 $g_n$。
那么有 $g_n = \sum \limits _ {i = 1} ^ n \binom{n}{i}g_{n-i}$。注意到这是个二项的半在线卷积，那么可以考虑分治 FFT，也可以多项式求逆。令 $g_n$ 的 EGF 为 $G$。那么有 $G * e^x = 2G - 1$，于是 $G = \frac{1}{2 - e^x}$。然后考虑层数总和 $f_n$。那么显然可以枚举第一层有多少积木，于是有 $f_n = g_n + \sum \limits _{i = 1} ^ n \binom{n}{i}f_{n-i}$，于是同理有 $F = \frac{G - G * e^x}{e^x - 2}$，那么答案就是 $\frac{[x^n]F}{[x^n]G}$。$\mathcal O(n \log n)$。
```cpp
int V = 1e5;
int fc[N], f[N], g[N], h[N];

int main() {
	fc[0] = 1;
	for (int i = 1; i <= V; i ++ ) fc[i] = 1ll * fc[i - 1] * i % mod;
	for (int i = 0; i <= V; i ++ ) h[i] = inv(fc[i]), g[i] = mod - h[i];
	g[0] = (g[0] + 2) % mod; inv(g, V + 1);
	for (int i = 0; i <= V; i ++ ) f[i] = mod - g[i];
	f[0] = (f[0] + 1) % mod; h[0] = (h[0] + mod - 2) % mod; inv(h, V + 1);
	mul(f, h, V + 1, V + 1);
	int q; scanf("%d", &q);
	while (q -- ) {
		int n; scanf("%d", &n);
		printf("%lld\n", 1ll * f[n] * inv(g[n]) % mod);
	}
	return 0;
}
```

---

## 作者：TianTian2008 (赞：0)

设 $f_k$ 表示层数为 $k$ 的方案数，那显然层数的期望为 $\frac XY$，其中 $X=\sum\limits_{k=1}^nkf_k$ 即所有方案层数的总和，$Y=\sum\limits_{k=1}^nf_k$ 即所有方案数。

考虑 $f_k$ 怎么算，即求有多少方案满足有 $k$ 层积木、每层都非空、积木数总和为 $n$。显然 $f_k=\sum\limits_{\small\begin{matrix}x_1,x_2,\cdots,x_k\in\mathbb{N^+}\\x_1+x_2+\cdots+x_k=n\end{matrix}}\binom n{x_1,x_2,\cdots,x_k}=[\frac{x^n}{n!}](e^x-1)^k$。

$\begin{aligned}X&=\sum\limits_{i=1}^nif_i\\&=\sum\limits_{i=1}^ni[\frac{x^n}{n!}](e^x-1)^i\\&=[\frac{x^n}{n!}]\sum\limits_{i=0}^\infty i(e^x-1)^i\\&=[\frac{x^n}{n!}]\sum\limits_{i=0}^\infty\sum\limits_{j=1}^i(e^x-1)^i\\&=[\frac{x^n}{n!}]\sum\limits_{j=1}^\infty\sum\limits_{i=j}^\infty(e^x-1)^i\\&=[\frac{x^n}{n!}]\sum\limits_{j=1}^\infty\frac{(e^x-1)^j}{2-e^x}\\&=[\frac{x^n}{n!}]\frac{e^x-1}{(2-e^x)^2}\end{aligned}$

$\begin{aligned}Y&=\sum\limits_{i=1}^nf_i\\&=\sum\limits_{i=1}^n[\frac{x^n}{n!}](e^x-1)^i\\&=[\frac{x^n}{n!}]\sum\limits_{i=0}^\infty (e^x-1)^i\\&=[\frac{x^n}{n!}]\frac1{2-e^x}\end{aligned}$

直接多项式求逆计算即可。

---

## 作者：Imiya (赞：0)

定义 $f_{i,j}$ 表示分成 $i$ 个有序集合，总共有 $j$ 个元素 的方案数。

$$
f_{i,j}=\sum_{k=0}^{j-1}if_{i-1,j-k-1}\binom{j-1}{k}\\
f_{i,j}=\sum_{k=0}^{j-1}if_{i-1,j-k-1}\frac{(j-1)!}{k!(j-k-1)!}\\
\frac{f_{i,j}}{i(j-1)!}=\sum_{k=0}^{j-1}\frac{f_{i-1,j-k-1}}{(j-k-1)!}\frac{1}{k!}\\
$$

使用生成函数。

$$
F_i(x)=\sum_{j=0}\frac{f_{i,j}}{j!}x^j\\
\frac{F_i'(x)}{i}=e^xF_{i-1}(x)\\
f_{0,0}=1,f_{t,0}=0,F_0(x)=1,F_t(0)=0\\
F_i'(x)=ie^xF_{i-1}(x)\\
$$

尝试递推几项找规律。

$$
F_1(x)=e^x-1\\
F_2'(x)=2e^x(e^x-1)=2e^{2x}-2e^x\\
F_2(x)=e^{2x}-2e^x+1\\
$$

发现是二项式系数，直接猜 $F_i(x)=(e^x-1)^i$，归纳证明。

$$
F_i(x)=(e^x-1)^i\\
F_i'(x)=ie^x(e^x-1)^{i-1}=ie^xF_{i-1}(x)\\
$$

求和算出答案。

$$
ans_1=\sum_{i=0}^nf_{i,n}=n!\sum_{i=0}^nF_i(x)[x^n]\\
=n!\sum_{i=0}^n(e^x-1)^i[x^n]=n!\frac{(e^x-1)^{n+1}-1}{e^x-2}[x^n]\\
$$
注意到 $((e^x-1)^{n+1}-1)\cdot(e^x-2)^{-1}\equiv-(e^x-2)^{-1}\mod x^{n+1}$，所以直接算 $-(e^x-2)^{-1}$ 就行。
$$
ans_2=\sum_{i=0}^nif_{i,n}=n!\sum_{i=0}^ni(e^x-1)^i[x^n]\\
$$

算求和式。

$$
S_n=\sum_{i=0}^nia^i\\
S_{n+1}-aS_n=\sum_{i=0}^{n+1}ia^i-\sum_{i=1}^{n+1}(i-1)a^{i}=\sum_{i=1}^{n+1}a^i=\frac{a^{n+2}-a}{a-1}\\
S_{n+1}=aS_n+\frac{a^{n+2}-a}{a-1}\\
\frac{S_{n+1}}{a^{n+1}}=\frac{S_n}{a^n}+\frac{a^{n+1}-1}{a^n(a-1)}=\frac{S_n}{a^n}+\frac1{a-1}(a-a^{-n})\\
S_n=a^n(\frac{1}{a-1}\sum_{i=0}^{n-1}(a-a^{-i}))\\
=\frac{a^n}{a-1}(na-\sum_{i=0}^{n-1}(a^{-1})^i)\\
=\frac{a^n}{a-1}(na-\frac{a^{-n}-1}{a^{-1}-1})\\
=\frac{na^{n+1}}{a-1}-\frac{a^{n+1}-a}{(a-1)^2}\\
=\frac{(a-1)(na^{n+1})-a^{n+1}+a}{(a-1)^2}\\
$$

令 $a=e^x-1$ 再模掉 $a^{n+1}$ 即可算出 $ans_2=(e^x-1)(e^x-2)^{-2}[x^n]$。

$$
ans=\frac{ans_2}{ans_1}
$$

只需写多项式求逆。

---


# 多项式反三角函数

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\equiv\text{asin}\:A(x)$ 或 $F(x)\equiv\text{atan}\:A(x)$。

所有运算在 $\bmod\ 998244353$ 意义下进行。

## 说明/提示

对于 $100\%$ 的数据：$n\leq10^5$，$a_i\in[0,998244352]\cap\mathbb{Z}$。

前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。

## 样例 #1

### 输入

```
8 0
0 4 2 6 1 5 3 7```

### 输出

```
0 4 2 665496252 17 399297879 332748370 570426983```

## 样例 #2

### 输入

```
8 1
0 4 2 6 1 5 3 7```

### 输出

```
0 4 2 665496220 998244322 399297839 332748518 570424795```

# 题解

## 作者：NaCly_Fish (赞：16)

$\text{updated:}$   
之前的代码数组开的不够大，导致某些抄代码的同学RE了，在此表示非常抱歉！现已修复。

要做这道题，得先知道 [多项式开根](https://www.luogu.org/problemnew/show/P5205) 怎么做。

给定一个多项式 $F(x)$，求一个 $G(x)$，满足  
$$G(x)\equiv\sin^{-1}F(x)\space (\text{mod }x^n)$$  

考虑将两遍求导，得到  
$$G'(x)\equiv \frac{F'(x)}{\sqrt{1-F(x)^2}}\space ({\text{mod }x^n})$$  
然后再积分回来     
$$G(x)\equiv \int \frac{F'(x)}{\sqrt{1-F(x)^2}}\text dx\space ({\text{mod }x^n})$$   
这里用到的思想，和求多项式 $\ln$ 的地方很类似。  

求 $\tan^{-1}$ 的方式，也差不多   
$$ H(x)\equiv\tan^{-1}F(x)\space (\text{mod }x^n)$$  
$$ H'(x)\equiv\frac{F'(x)}{1+F(x)^2}\space (\text{mod }x^n)$$   
$$H(x)\equiv\int\frac{F'(x)}{1+F(x)^2} \text dx\space (\text{mod }x^n)$$   
然后直接计算即可。  
Code：  
```cpp
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define N 262147
#define ll long long
#define reg register
#define p 998244353
using namespace std;

inline int add(const int& x,const int& y){ return x+y>=p?x+y-p:x+y; }
inline int dec(const int& x,const int& y){ return x<y?x-y+p:x-y; }

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

int rt[N],rev[N],inv[N];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = power(3,(p-1)>>siz);
    inv[1] = rt[lim>>1] = 1;
    for(reg int i=lim>>1|1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
}

inline void NTT(int *f,int type,int lim){
    if(type==-1) reverse(f+1,f+lim);
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
    if(type==1) return;
    x = p-((p-1)>>(siz-shift));
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void inverse(const int *f,int n,int *R){
    static int g[N],h[N],s[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void sqrt(const int *f,int n,int *R){
    static int g[N],h[N];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    int s[30];
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,g,(n+1)<<2);
        for(int i=0;i<=n;++i) h[i] = add(h[i],h[i]);
        inverse(h,n,h);
        NTT(g,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*g[i]%p;
        NTT(g,-1,lim);
        for(reg int i=0;i<=n;++i) g[i] = add(g[i],f[i]);
        memset(g+n+1,0,(lim-n)<<2);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void asin(const int *f,int n,int *R){
    static int g[N],h[N];
    int lim = getlen(n<<1);
    memcpy(g,f,(n+1)<<2);
    memset(g+n+1,0,(lim-n)<<2);
    NTT(g,1,lim);
    for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*g[i]%p;
    NTT(g,-1,lim);
    memset(g+n+1,0,(lim-n)<<2);
    for(reg int i=0;i<=n;++i) g[i] = g[i]?p-g[i]:0;
    ++g[0];
    sqrt(g,n,g);
    inverse(g,n,g);
    for(reg int i=0;i!=n;++i) h[i] = (ll)(i+1)*f[i+1]%p;
    memset(h+n,0,(lim-n+1)<<2);
    NTT(g,1,lim),NTT(h,1,lim);
    for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
    NTT(g,-1,lim);
    for(reg int i=1;i<=n;++i) R[i] = (ll)g[i-1]*inv[i]%p;
    R[0] = 0;
}

inline void atan(const int *f,int n,int *R){
    static int g[N],h[N];
    int lim = getlen(n<<1);
    memcpy(g,f,(n+1)<<2);
    memset(g+n+1,0,(lim-n)<<2);
    NTT(g,1,lim);
    for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*g[i]%p;
    NTT(g,-1,lim);
    memset(g+n+1,0,(lim-n)<<2);
    ++g[0];
    inverse(g,n,g);
    for(reg int i=0;i!=n;++i) h[i] = (ll)(i+1)*f[i+1]%p;
    memset(h+n,0,(lim-n+1)<<2);
    NTT(g,1,lim),NTT(h,1,lim);
    for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
    NTT(g,-1,lim);
    for(reg int i=1;i<=n;++i) R[i] = (ll)g[i-1]*inv[i]%p;
    R[0] = 0;
}

int n,tp;
int F[N];

int main(){
    scanf("%d%d",&n,&tp);
    init(n<<2);
    for(reg int i=0;i!=n;++i) scanf("%d",&F[i]);
    if(tp==0) asin(F,n-1,F);
    else atan(F,n-1,F);
    for(reg int i=0;i!=n;++i) printf("%d ",F[i]);
    return 0;   
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

AC 800 纪念

根本不需要啥微积分（

首先，有几个式子：

$$\arcsin(x)=-i\ln(ix+\sqrt{1-x^2})$$
$$\arctan(x)=\frac i2[\ln(1-ix)-\ln(1+ix)]$$

一个一个的证明

## $\arcsin$

$$\sin\theta=x\implies\arcsin x=\theta$$
$$\sin\theta=x\iff\frac{e^{\theta i}-e^{-\theta i}}{2i}=x$$
$$p=e^{\theta i}$$
$$\frac{p-\frac 1p}{2i}=x$$
$$p-2xi-\frac 1p=0$$
$$p^2-2xip-1=0$$
$$p=e^{i\theta}=ix\pm\sqrt{1-x^2}$$
选取 $+$  
$$i\theta=\ln(ix+\sqrt{1-x^2})$$
$$\theta=-i\ln(ix+\sqrt{1-x^2})$$
$\boxed{}$

## $\arctan$

$$\tan\theta=x\implies\arctan x=\theta$$
$$\tan\theta=x\iff\frac{e^{\theta i}-e^{-\theta i}}{2i}\frac{2}{e^{\theta i}+e^{-\theta i}}=x$$
$$\frac{e^{\theta i}-e^{-\theta i}}{i(e^{\theta i}+e^{-\theta i})}=x$$
$$p=e^{\theta i}$$
$$\frac{p-\frac 1p}{i(p+\frac 1p)}=x$$
$$\frac{p^2-1}{p^2+1}=xi$$
（扔到 w|a 里
$$p=\pm\frac{\sqrt{-xi-1}}{\sqrt{xi-1}}$$
选取 $+$
$$p=e^{i\theta}=\frac{\sqrt{-xi-1}}{\sqrt{xi-1}}$$
$$i\theta=\ln\frac{\sqrt{-xi-1}}{\sqrt{xi-1}}=\frac 12\ln\frac{-xi-1}{xi-1}$$
$$\theta=-\frac i2\ln\frac{1+xi}{1-xi}$$
$$\theta=-\frac i2[\ln(1+xi)-\ln(1-xi)]$$
$$\theta=\frac i2[\ln(1-xi)+\ln(1+xi)]$$
$\boxed{}$

完结，套板子。

代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) { *s = __c; } *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) { x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; } return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) { qu[++ qr] = x % 10 + '0',  x /= 10; } while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian


#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define fi first
#define se second
#define pb push_back
 
#define ll long long
#define pii pair<int, int>
//#define int ll

namespace poly {
	const int MOD = 998244353;
	const int IMAG = 86583718;
	const int NTTG = 3;
	
	int rev[262160];
	int minv[262160];
	int w[20][2][262160];
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
	void constructrev(int n) {
		for(int i=1, j=0; i < n; i++) {
			int bit=n>>1;
			for(;j&bit;bit>>=1)j^=bit;
			j^=bit; rev[i] = j;
		}
	}

	void constructroot(int n) {
		minv[1] = 1;
		iter(i, 2, n+1)
			minv[i]=1ll*(MOD-MOD/i)*minv[MOD%i]%MOD;
		for(int l=1; (1<<l)<=n; l++)
			rep(inv, 2) {
				int re = inv?qpow(minv[NTTG],(MOD-1)>>l):qpow(NTTG,(MOD-1)>>l);
				w[l][inv][0] = 1;
				rep1(i,(1<<(l-1))-1) w[l][inv][i] = 1ll*w[l][inv][i-1]*re%MOD;
			}
	}
	
	void ntt(int *v, int n, bool inv) {
		rep(i, n) if(i < rev[i]) swap(v[i], v[rev[i]]);
		for(int l=1;(1<<l)<=n;l++)
			for(int i=0;i<n;i+=(1<<l)) {
				int p=i+(1<<(l-1));
				iter(j, i, p) {
					int a=v[j],b=1ll*v[j+(1<<(l-1))]*w[l][inv][j-i]%MOD;
					v[j]=(a+b>=MOD?a+b-MOD:a+b);
					v[j+(1<<(l-1))]=(a<b?a+MOD-b:a-b);
				}
			}
		if(inv) rep(i, n) v[i] = 1ll*v[i]*minv[n]%MOD;
	}
	
	void mult(int *a, int as, int *b, int bs, int *o, bool construct, bool clean = 0, int th = 100000000) {
		int n = as+bs-1;
		while(n - (n & (-n))) n += (n & (-n));
		if(construct) constructroot(n);
		constructrev(n);
		ntt(a, n, 0); ntt(b, n, 0);
		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
		ntt(o, n, 1);
		iter(i, th, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(int* a, int as, int *o) {
		static int tmp[262160];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); int le = 0;
		while((1 << le) < (as << 1)) le++;
		constructrev(1 << le);
		rep(i, as) tmp[i] = a[i];
		iter(i, as, 1<<le) tmp[i] = o[i] = 0;
		ntt(tmp, 1<<le, 0); ntt(o, 1<<le, 0);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		ntt(o, 1<<le, 1);
		iter(i, as, 1<<le) o[i] = 0;
	}

	void deriv(int *a, int as, int *o) { rep1(i, as-1) { o[i-1] = 1ll * i * a[i] % MOD; } o[as-1] = 0; }
	void integ(int *a, int as, int *o) { for(int i=as-2; i>=0; i--) { o[i+1] = 1ll * minv[i+1] * a[i] % MOD; } o[0] = 0; }

	void ln(int *a, int as, int *o) {
		static int iv[262160]; 
		cfn(a, as, iv); 
		deriv(a, as, a);
		mult(iv, as, a, as, o, 0, 1, as);
		integ(o, as, o);
	}
	
	void exp(int *a, int as, int *o) {
		static int tmp[262160], tmp2[262160], tmp3[262160];
		if(as == 1) { o[0] = 1; return; }
		exp(a, (as+1)/2, o);
		rep(i, as) tmp[i] = o[i], tmp3[i] = 0; 
		ln(tmp, as, tmp3);
		rep(i, as) tmp3[i] = (MOD + a[i] - tmp3[i] + (i == 0)) % MOD, tmp2[i] = o[i];
		mult(tmp2, as, tmp3, as, o, 0, 1);
	}
	
	void sqrt(int *a, int as, int *o) {
		static int tmp[262160];
		ln(a, as, tmp);
		rep(i, as) tmp[i] = 1ll * minv[2] * tmp[i] % MOD;
		exp(tmp, as, o);
		iter(i, as, 2*as) o[i] = 0;
	}
	
	void asin(int *a, int as, int *o) {
		static int v[262160], sq[262160];
		int li = 1; while(li < (2*as-1)) li <<= 1;
		rep(i, as) v[i] = a[i];
		constructrev(li);
		ntt(v, li, 0);
		rep(i, li) v[i] = (MOD + 1 - 1ll * v[i] * v[i] % MOD) % MOD;
		ntt(v, li, 1);
		iter(i, as, li) v[i] = 0;
		sqrt(v, as, sq);
		rep(i, as) sq[i] = (sq[i] + 1ll * IMAG * a[i]) % MOD;
		ln(sq, as, o);
		rep(i, as) o[i] = 1ll * (MOD - IMAG) * o[i] % MOD;
	}

	void atan(int *a, int as, int *o) {
		static int v[262160], o1[262160], o2[262160];
		rep(i, as) v[i] = (1ll * (MOD - IMAG) * a[i] + (i == 0)) % MOD;
		ln(v, as, o1);
		rep(i, as) v[i] = (1ll * IMAG * a[i] + (i == 0)) % MOD;
		ln(v, as, o2);
		ll p = 1ll * minv[2] * IMAG % MOD;
		rep(i, as) o[i] = p * (MOD + o1[i] - o2[i]) % MOD;
	}

	void init(int n) { constructroot(n); }
}

int a[262160];
int b[262160];

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n, t; gi(n), gi(t);
    int f = 1; while(f <= (n << 1)) f <<= 1;
    rep(i, n) gi(a[i]);
    poly::init(f);
    if(t) poly::atan(a, n, b);
    else poly::asin(a, n, b);
    rep(i, n) print(b[i]), pc(' ');
}

```

---

## 作者：cainiaoshanglu (赞：2)

# P5265 题解
~~什么时候蒟蒻也能写黑题题解了~~
### 前置芝士：多项式求根，多项式对数函数，欧拉恒等式
其实这道题不需要微积分，只需要一些小技巧就可以了，其中的关键点在于欧拉恒等式。

三角函数和反三角函数并不是很好处理，如果我们把它转换成其他函数就会比较容易。欧拉恒等式能够实现指数函数和三角函数之间的转换，所以以此为切入点开始推柿子。应对指数函数我们有许多工具，即可解决这个问题。

当然，我们也可以使用牛顿迭代法，以类似多项式求根的方式实现反三角函数，但这样实测常数较大，而且码量较大，不进行一些毒瘤卡常比较难AC，
~~果然系统性的方法都有这些那些缺点~~。
## 1.arcsin(x)
考虑欧拉恒等式：
$$ e^{i\theta}=\cos\theta+i\sin\theta $$
稍加变换可得：
$$ \sin\theta=\frac{e^{i\theta}-e^{-i\theta}}{2i} $$
$$ \cos\theta=\frac{e^{i\theta}+e^{-i\theta}}{2} $$
令 $ e^{i\theta}=t $ 则有：
$$ \sin\theta=\frac{t-\frac{1}{t}}{2i} $$
变换可得：
$$ t^2-2i\sin\theta-1=0 $$
解得：
$$ t=\frac{2i\sin\theta\pm\sqrt{4-4\sin^2\theta}}{2} $$
或：
$$ t=i\sin\theta\pm\sqrt{1-\sin^2\theta} $$
选取 $\pm$ 中的 $+$ ,同时带入 $ e^{i\theta}=t $ ：
$$ e^{i\theta}=i\sin\theta+\sqrt{1-\sin^2\theta} $$
两边取 $\ln$ 后除以 $i$：
$$ \theta=\frac{\ln(i\sin\theta+\sqrt{1-\sin^2\theta})}{i} $$
即：
$$ \arcsin x=\frac{\ln(ix+\sqrt{1-x^2})}{i} $$
可能有人有问题：对于复数的对数函数不是不唯一吗？其实我们这里的所谓“单位虚数”只不过是模意义下 $-1$ 的二次剩余，从来都没有出现过什么复数，多项式 $ln$ 自然也是良定义的。

可以利用多项式 $\ln$ 和多项式开方求解，时间复杂度 $O(n \log n)$。
## 2.arctan(x)：
由上结论有：
$$ \sin\theta=\frac{e^{i\theta}-e^{-i\theta}}{2i} $$
$$ \cos\theta=\frac{e^{i\theta}+e^{-i\theta}}{2} $$
即：
$$ \tan\theta= \frac{e^{i\theta}-e^{-i\theta}}{i(e^{i\theta}+e^{-i\theta})} $$
令 $t=e^{i\theta}$ 则有：
$$ \tan\theta=\frac{t-\frac{1}{t}}{it+\frac{i}{t}} $$
变换可得：
$$ (1-i\tan\theta)t^2-(1+i\tan\theta)=0 $$
解得：
$$ t=\pm\sqrt{\frac{1+i\tan\theta}{1-i\tan\theta}} $$
选取 $\pm$ 中的 $+$ ,同时带入 $ e^{i\theta}=t $：
$$ e^{i\theta}=\sqrt{\frac{1+i\tan\theta}{1-i\tan\theta}} $$
两边取 $\ln$ 后除以 $i$：
$$ \theta=i\ln{\sqrt{\frac{1+i\tan\theta}{1-i\tan\theta}}} $$
注意到 $ \ln{\sqrt{x}}=\frac{1}{2}\ln{x} $：
$$ \theta=\frac{i}{2}\ln{\frac{1+i\tan\theta}{1-i\tan\theta}} $$
即：
$$ \arctan x=\frac{i}{2}(\ln(1+ix)-\ln(1-ix)) $$
可以利用多项式 $\ln$ 求解，时间复杂度 $O(n \log n)$ 。
## Code
~~看我这糟糕的码风~~
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;

void read(int &x){
	x=0;
	char c=getchar();
	while(!('0'<=c && c<='9')){
		c=getchar();
	}
	while('0'<=c && c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
}
const int md=998244353,g=3,rg=332748118;
int powr(int b,int k){
	int res=1;
	for(;k;b=(1ll*b*b)%md,k>>=1){
		if(k%2){
			res=(1ll*res*b)%md;
		}
	}
	return res;
}
int mod(int k){
	if(k>md){
		return k-md;
	}else{
		return k;
	}
}
int flp[2100010],inv[200010];
inline void flip(int siz){
	for(int i=0;i<siz;i++){
		flp[i]=flp[i>>1]>>1;
		if(i&1){
			flp[i]|=siz>>1;
		}
	}
}
struct Poly{
	vector<int> val;
	Poly(){}
	Poly(const vector<int>& v){
		val=v;
	}
	Poly(int* v,int siz){
		for(int i=0;i<siz;i++){
			val.push_back(v[i]);
		}
	}
	Poly(int k){
		val.push_back(1);
	}
	void show(){
		for(int i=0;i<val.size();i++){
			printf("%d ",val[i]);
		}
	}
	int size(){
		return val.size();
	}
	int& operator[](int k){
		while(val.size()<=k){
			val.push_back(0);
		}
		return val[k];
	}
	friend Poly operator+(Poly a,Poly b){
		Poly res;
		if(a.size()<b.size()){
			swap(a,b);
		}
		for(int i=0;i<a.size();i++){
			res[i]=(a[i]+b[i])%md;
		}
		return res;
	}
	friend Poly operator-(Poly a,Poly b){
		Poly res;
		for(int i=0;i<max(a.size(),b.size());i++){
			res[i]=mod(a[i]-b[i]+md);
		}
		return res;
	}
	friend Poly operator*(Poly a,int b){
		for(int i=0;i<a.size();i++){
			a[i]=(1ll*a[i]*b)%md;
		}
		return a;
	}
	friend Poly operator*(int b,Poly a){
		return a*b;
	}
	vector<int> NTT(){
		int siz=val.size();
		vector<int> res=val;
		for(int i=0;i<siz;i++){
			if(i<flp[i]){
				swap(res[i],res[flp[i]]);
			}
		}
		for(int i=1;i<siz;i<<=1){
			int rt=powr(g,(md-1)/(i<<1));
			for(int j=0;j<siz;j+=(i<<1)){
				int cur=1;
				for(int k=0;k<i;k++){
					cur=(1ll*cur*rt)%md;
					int x=res[j+k],y=1ll*cur*res[i+j+k]%md;
					res[j+k]=mod(x+y);
					res[i+j+k]=mod(x-y+md);
				}
			}
		}
		return res;
	}
};
Poly INTT(const vector<int> &val){
	int siz=val.size();
	Poly res(val);
	for(int i=0;i<siz;i++){
		if(i<flp[i]){
			swap(res[i],res[flp[i]]);
		}
	}
	for(int i=1;i<siz;i<<=1){
		int rt=powr(rg,(md-1)/(i<<1));
		for(int j=0;j<siz;j+=(i<<1)){
			int cur=1;
			for(int k=0;k<i;k++){
				cur=(1ll*cur*rt)%md;
				int x=res[j+k],y=1ll*cur*res[i+j+k]%md;
				res[j+k]=mod(x+y);
				res[i+j+k]=mod(x-y+md);
			}
		}
	}
	return Poly(res);
}
Poly operator*(Poly a,Poly b){
	int tt=a.size()+b.size()-1,siz=1;
	while(siz<tt){
		siz<<=1;
	}
	a[siz-1];
	b[siz-1];
	flip(siz);
	vector<int> an=a.NTT(),bn=b.NTT(),res(siz,0);
	swap(an[0],an[siz-1]);
	for(int i=siz-1;i>1;i--){
		swap(an[i],an[i-1]);
	}
	swap(bn[0],bn[siz-1]);
	for(int i=siz-1;i>1;i--){
		swap(bn[i],bn[i-1]);
	}
	for(int i=0;i<siz;i++){
		res[i]=1ll*an[i]*bn[i]%md;
		//printf("%lld ",res[i]);
	}
	Poly k=INTT(res);
	swap(k[0],k[siz-1]);
	for(int i=siz-1;i>1;i--){
		swap(k[i],k[i-1]);
	}
	int inv=powr(siz,md-2);
	for(int i=0;i<siz;i++){
		k[i]=(1ll*k[i]*inv)%md;
	}
	return k;
}
Poly derivative(Poly a){
	Poly res;
	for(int i=1;i<a.size();i++){
		res[i-1]=1ll*a[i]*i%md;
	}
	return res;
}
Poly integral__(Poly a){
	Poly res;
	for(int i=0;i<a.size();i++){
		res[i+1]=1ll*a[i]*inv[i+1]%md;
	}
	return res;
}
Poly rev(Poly a){
	int n=a.size(),siz=1;
	while(siz<n){
		siz<<=1;
	}
	a[siz-1];
	Poly res,tot;
	res[0]=powr(a[0],md-2);
	tot[0]=2;
	while(res.size()<siz){
		Poly ct;
		for(int i=0;i<2*res.size();i++){
			ct[i]=a[i];
		}
		Poly k=1ll*res*(tot-res*ct);
		int ss=res.size();
		for(int i=0;i<ss*2;i++){
			res[i]=k[i];
		}
	}
	Poly cc;
	for(int i=0;i<n;i++){
		cc[i]=res[i];
	}
	return res;
}
Poly Ln(Poly a){
	Poly res=integral__(derivative(a)*rev(a));
	Poly cc;
	for(int i=0;i<a.size();i++){
		cc[i]=res[i];
	}
	return cc;
}
Poly Exp(Poly a){
	int len=a.size();
	Poly res,cnst;
	res[0]=cnst[0]=1;
	int siz=1;
	while(siz<a.size()){
		siz<<=1;
	}
	siz<<=1;
	a[siz-1];
	while(res.size()<siz){
		Poly kt=cnst-Ln(res)+a;
		Poly tmp;
		for(int i=0;i<res.size();i++){
			tmp[i]=kt[i];
		}
		Poly k=tmp*res;
		int cc=res.size();
		for(int i=0;i<cc*2;i++){
			res[i]=k[i];
		}
	}
	Poly cck;
	for(int i=0;i<len;i++){
		cck[i]=res[i];
	}
	return cck;
}
Poly powr(Poly a,int k){
	Poly y=Exp(Ln(a)*k),cc;
	for(int i=0;i<a.size();i++){
		cc[i]=y[i];
	}
	return cc;
}
Poly rt(Poly a){
	Poly res;
	res[0]=1;
	int siz=1,len=a.size();
	while(siz<a.size()){
		siz<<=1;
	}
	siz<<=1;
	a[siz-1];
	while(res.size()<siz){
		Poly kt=a+res*res,tmp;
		for(int i=0;i<res.size();i++){
			tmp[i]=kt[i];
		}
		Poly k=tmp*rev(2*res);
		int cc=res.size();
		for(int i=0;i<cc*2;i++){
			res[i]=k[i];
		}
	}
	Poly rr;
	for(int i=0;i<len;i++){
		rr[i]=res[i];
	}
	return rr;
} 
Poly sin(Poly k){
	int img=powr(3,(md-1)/4);
	Poly kk=Exp(k*img);
	return (kk-rev(kk))*powr(2,md-2)*(md-img);
}
Poly cos(Poly k){
	int img=powr(3,(md-1)/4);
	Poly kk=Exp(k*img);
	return (kk+rev(kk))*powr(2,md-2);
}
Poly asin(Poly k){
	int img=powr(3,(md-1)/4);
	return (md-img)*Ln(rt(1-k*k)+img*k);
}
Poly atan(Poly k){
	int img=powr(3,(md-1)/4);
	return (Ln(1-img*k)-Ln(1+img*k))*img*powr(2,md-2);
}
signed main(){
	int n,t;
	Poly a;
	read(n);
	inv[1]=1;
	for(int i=2;i<=2*n;i++){
		inv[i]=1ll*(md-md/i)*inv[md%i]%md;
	}
	read(t);
	for(int i=0;i<n;i++){
		read(a[i]);
	}
	if(t){
		Poly res=atan(a);
		for(int i=0;i<n;i++){
			printf("%d ",res[i]);
		}
	}else{
		Poly res=asin(a);
		for(int i=0;i<n;i++){
			printf("%d ",res[i]);
		}
	}
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：2)

前置知识：[FFT/NTT](https://www.luogu.com.cn/problem/P3803)，[多项式开根](https://www.luogu.com.cn/problem/P5205)，[多项式乘法逆](https://www.luogu.com.cn/problem/P4238)，多项式求导/积分，[反三角函数求导公式和复合函数求导公式](https://www.luogu.com.cn/paste/wun0hgni)。

~~不会来做这题的人不会这些吧，不会吧不会吧（~~

---

### $Solution:$

模仿多项式 $\ln$ 时的做法：先求导再积分！

首先求 $\arcsin :$

$$F(x)\equiv \arcsin A(x)(\bmod \ x^n)$$

这里需要运用反三角函数求导公式和复合函数求导公式：

$$F'(x)\equiv\dfrac{A'(x)}{\sqrt{1 - A(x)^2}}(\bmod\ x^{n-1})$$

积回去：

$$F(x)\equiv\int\dfrac{A'(x)}{\sqrt{1-A(x)^2}}dx(\bmod \ x^n)$$

然后是 $\arctan :$

$$F(x)\equiv \arctan A(x)(\bmod \  x^n)$$

$$F'(x)\equiv \dfrac{A'(x)}{1 + A(x)^2}(\bmod \ x^{n-1})$$

$$F(x)\equiv \int \dfrac{A'(x)}{1+A(x)^2}dx(\bmod\ x^n)$$

由于每一个操作的复杂度是 $O(n\log n)$，所以总时间复杂度是 $O(n \log n)$。

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
#define ll long long
const ll N = 300010, mod = 998244353, g_ = 3, invg = 332748118, I = 86583718;
inline ll read(){
    ll x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9'){x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * f;
}
inline ll fpow(ll n, ll p){
    ll ans = 1, base = n;
    while(p){
        if(p & 1) ans = ans * base % mod;
        base = base * base % mod;
        p >>= 1;
    }
    return ans;
}
ll n, m, r[N], A[N], B[N], a[N], b[N], f[N], rev, c[N], d[N], e[N], inv[N], g[N], h[N], C[N], D[N];
bool is_inv;
inline void clr(ll *A, ll x, ll y){
    for(int i = x; i < y; ++i) A[i] = 0;
}
inline void cpy(ll *A, ll *B, ll x, ll y){
    for(int i = x; i < y; ++i) A[i] = B[i];
}
inline void NTT(ll typ, ll *a, ll lim){
    if(lim != rev){
        rev = lim;
        for(int i = 0; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0); 
    }
    for(int i = 0; i < lim; ++i) if(i < r[i]) swap(a[i], a[r[i]]);
    for(int mid = 1; mid < lim; mid <<= 1){
        int R = mid << 1; ll rt = fpow(typ == 1 ? g_ : invg, (mod - 1) / R);
        for(int j = 0; j < lim; j += R){
            ll w = 1;
            for(int k = 0; k < mid; k++, w = w * rt % mod){
                ll x = a[j | k], y = w * a[j | k | mid] % mod;
                a[j | k] = (x + y) % mod;
                a[j | k | mid] = (x - y + mod) % mod;
            }
        }
    }
    if(typ < 0) for(ll i = 0, k = fpow(lim, mod - 2); i < lim; ++i) a[i] = a[i] * k % mod; 
}
inline void ptm(ll *A, ll *B, ll len){
    for(int i = 0; i < len; ++i) A[i] = A[i] * B[i] % mod; 
} 
inline void print(ll *A, ll len){
    for(int i = 0; i < len; ++i) printf("%lld ", A[i]);
    printf("\n");
}
inline void Polymul(ll *A, ll *B, ll len, ll m){
    int lim = 1; while(lim < len) lim <<= 1;
    cpy(e, B, 0, lim); clr(e, len, lim);
    NTT(1, A, lim); NTT(1, e, lim); ptm(A, e, lim);
    NTT(-1, A, lim); clr(A, m, lim);
}
inline void Polyinv(ll *A, ll len){
    int lim = 1; while(lim < len) lim <<= 1;
    a[0] = fpow(A[0], mod - 2);
    for(int m = 2; m <= lim; m <<= 1){
        for(int i = 0; i < (m >> 1); ++i) b[i] = (a[i] << 1) % mod;
        cpy(f, A, 0, m);
        NTT(1, a, m << 1); ptm(a, a, m << 1);
        NTT(1, f, m << 1); ptm(a, f, m << 1);
        NTT(-1, a, m << 1); clr(a, m, m << 1);
        for(int i = 0; i < m; ++i) a[i] = (b[i] - a[i] + mod) % mod;
    }
    cpy(A, a, 0, len);
    clr(f, 0, lim << 1); clr(a, 0, lim << 1); clr(b, 0, lim << 1);
}
inline void Polyder(ll *A, ll len){
    for(int i = 1; i < len; ++i) A[i - 1] = A[i] * i % mod;
    A[len - 1] = 0;
} 
inline void prework(){
    if(is_inv) return; is_inv = 1; inv[0] = inv[1] = 1ll;
    for(int i = 2; i <= N; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}
inline void Polyint(ll *A, ll len){
    prework();
    for(int i = len; i >= 1; --i) A[i] = A[i - 1] * inv[i] % mod;
    A[0] = 0;
}
inline void Polysqrt(ll *A, ll len){
    int lim = 1; while(lim < len) lim <<= 1;
    c[0] = 1;
    for(int m = 2; m <= lim; m <<= 1){
        for(int i = 0; i < (m >> 1); ++i) d[i] = (c[i] << 1) % mod;
        Polyinv(d, m);
        NTT(1, c, m); ptm(c, c, m); NTT(-1, c, m);
        for(int i = 0; i < m; ++i) c[i] = (A[i] + c[i]) % mod;
        Polymul(c, d, m << 1, m);
    }
    cpy(A, c, 0, len); clr(c, 0, lim << 1); clr(d, 0, lim << 1);
}
inline void Polyasin(ll *A, ll len){
	cpy(C, A, 0, len); Polyder(A, len);
	Polymul(C, C, len << 1, len); 
	for(int i = 0; i < len; ++i) C[i] = mod - C[i]; 
	C[0] = (C[0] + 1) % mod;
	Polysqrt(C, len); Polyinv(C, len);
	Polymul(A, C, len << 1, len); Polyint(A, len - 1); clr(C, 0, len);
}
inline void Polyatan(ll *A, ll len){
	cpy(C, A, 0, len); Polyder(A, len);
	Polymul(C, C, len << 1, len); C[0] = (C[0] + 1) % mod;
	Polyinv(C, len); Polymul(A, C, len << 1, len);
	Polyint(A, len - 1); clr(C, 0, len); 
}
signed main(){
	n = read(); m = read();
	for(int i = 0; i < n; ++i) A[i] = read();
	if(m == 0) Polyasin(A, n);
	else Polyatan(A, n);
	print(A, n); 
    return 0;
}
```

---

## 作者：密期望 (赞：2)

# 想要写代码请先学会[多项式开根](https://www.luogu.org/problemnew/show/P5205)，多项式的微积分(必备前置条件)

原理很简单

先由

$\dfrac{dsin(x)}{dx}=cos(x)$

$\dfrac{dtan(x)}{dx}=sec^2(x)$

$\dfrac{dy}{dx}*\dfrac{dx}{dy}=1$

可得到

$\dfrac{dasin(x)}{dx}=\dfrac{1}{(1-x^2)^{\frac{1}{2}}}$

$\dfrac{datan(x)}{dx}=\dfrac{1}{1+x^2}$

然后用

$\dfrac{dy}{dx}=\dfrac{dy}{du}*\dfrac{du}{dx}$

算出将多项式带入反三角函数的导数，最后积分一下。

# 结论

$asin(A(x))=\int{\dfrac{dA(x)}{(1-A(x)^2)^\frac{1}{2}}}$

$atan(A(x))=\int\dfrac{dA(x)}{1+A(x)*A(x)}$

核心代码在这里

```
friend polymerization asin(const polymerization &a){
	polymerization up(a),down(-(a*a).resize(a.len));//resize用来保证运算结果的次数
	up.differential();
	down[0]=(down[0]+1)%P;
	down=pow(down,pow(2,P-2)).resize(a.len);
	return (up*down.inverse()).resize(a.len).integral();
}
friend polymerization atan(const polymerization &a){
	polymerization up(a),down((a*a).resize(a.len));
	up.differential();
	down[0]=(down[0]+1)%P;
	return (up*down.inverse()).resize(a.len).integral();
}
```

[完整代码](https://www.luogu.org/paste/2jwxubxq)

---

## 作者：critnos (赞：1)

~~你是？~~

萌新刚学牛顿迭代，写个板子 O_o

求 $G(x)$ 满足 $\sin G(x)=A(x)$。

设 $F(G(x))=\sin G(x)-A(x)$，然后牛顿迭代：

$$G(x)=G_0(x)-\dfrac {F(G_0(x))} {F'(G_0(x))}$$

$$G(x)=G_0(x)-\dfrac {\sin G_0(x)-A(x)} {\cos G_0(x)}$$

即可。

$\tan$ 同理可得

$$G(x)=G_0(x)-\cos G_0(x)(\sin G_0(x)-\cos G_0(x)A(x))$$

套隔壁三角函数的板子，需要一点常数优化。

---

## 作者：Convergent_Series (赞：1)

## arcsin

$$\begin{aligned}
F(x)&\equiv\arcsin A(x)\pmod{x^n}\\
\\
F'(x)&\equiv(\arcsin A(x))'\pmod{x^n}\\
\end{aligned}$$



$y=\arcsin x$

$$(\arcsin x)'= \dfrac{1}{(\sin y)'}= \dfrac{1}{\cos y}= \dfrac{1}{\sqrt{1-\sin^2 y}}= \dfrac{1}{\sqrt{1-\sin^2 (\arcsin x)}}= \dfrac{1}{\sqrt{1-x^2}}$$

$$\begin{aligned}
F'(x)&\equiv(\arcsin A(x))'\\
\\
&\equiv\dfrac{A'(x)}{\sqrt{1-A(x)^2}}\pmod{x^n}\\
\\
F(x)&\equiv\int\dfrac{A'(x)}{\sqrt{1-A(x)^2}}\text{ d}x\pmod{x^n}\\
\end{aligned}$$


## arctan


$$\begin{aligned}
G(x)&\equiv\arctan A(x)\pmod{x^n}\\
\\
G'(x)&\equiv(\arctan A(x))'\pmod{x^n}\\
\end{aligned}$$

$y=\arctan x$

$$(\arctan x)'= \dfrac{1}{(\tan y)'}= \dfrac{1}{\dfrac{1}{\cos^2 y}}= \dfrac{1}{1+\tan^2 y}= \dfrac{1}{1+\tan^2 (\arctan x)}= \dfrac{1}{1+x^2}$$

$$\begin{aligned}
G'(x)&\equiv(\arctan A(x))'\\
\\
&\equiv\dfrac{A'(x)}{1+A(x)^2}\pmod{x^n}\\
\\
G(x)&\equiv\int\dfrac{A'(x)}{1+A(x)^2}\text{ d}x\pmod{x^n}\\
\end{aligned}$$

---

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define clr(f,n) memset(f,0,sizeof(int)*(n))
#define cpy(f,g,n) memcpy(f,g,sizeof(int)*(n))
#define bceil(n) (1<<(__lg(n-1)+1))
using namespace std;
int read(){
	int a=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') a=(a<<3)+(a<<1)+(ch^'0'),ch=getchar();
	return a;
} 
void write(int a){
	if(a>9) write(a/10); 
	putchar(a%10+'0');
}
const int MAXN=1e6+10,P=998244353,G=3,Gi=332748118,Img=86583718;
int l,r[MAXN],inv[MAXN],sav[MAXN<<1];
ll qpow(ll a,ll b=P-2){
	if(a==1) return 1;
	ll ans=1;
	while(b){if(b&1) ans=ans*a%P;a=a*a%P;b>>=1;}
	return ans;
}
void tpre(int lim){
    if(l==lim) return;l=lim;
    for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?lim>>1:0);
}
void px(int *A,int *B,int n){for(int i=0;i<n;i++) A[i]=1ll*A[i]*B[i]%P;} 
void NTT(int *A,int lim,int type){
	tpre(lim);
	static ull f[MAXN<<1],w[MAXN];w[0]=1;
	for(int i=0;i<lim;i++) f[i]=(((ll)P<<5)+A[r[i]])%P;
	for(int mid=1;mid<lim;mid<<=1){
		ull Wn=qpow(type+1?G:Gi,(P-1)/(mid+mid));
		for(int i=1;i<mid;i++)w[i]=w[i-1]*Wn%P;
		for(int j=0;j<lim;j+=mid+mid){
			for(int k=0;k<mid;k++){
				int x=w[k]*f[j|mid|k]%P;
				f[j|mid|k]=f[j|k]+P-x;
				f[j|k]+=x;
			}   
		}if(mid==(1<<10)){for(int i=0;i<lim;i++) f[i]%=P;}
	}if(type-1){
		ull inv=qpow(lim);
		for(int i=0;i<lim;i++) A[i]=f[i]%P*inv%P;
	}else for(int i=0;i<lim;i++) A[i]=f[i]%P;
}
void mul(int *A,int *B,int la,int lb){//乘法 
	int lim=bceil(la+la);
	cpy(sav,B,lim);clr(sav+la,lim-la);
    NTT(A,lim,1);NTT(sav,lim,1);
    px(A,sav,lim);NTT(A,lim,-1);
    clr(A+lb,lim-lb);clr(sav,lim);
} 
void invp(int *A,int lim){//逆元 
	int n=bceil(lim);
	static int w[MAXN<<1],r[MAXN<<1];
	w[0]=qpow(A[0]);
	for (int ln=2;ln<=n;ln<<=1){
		for(int i=0;i<(ln>>1);i++) r[i]=w[i];
		cpy(sav,A,ln);NTT(sav,ln,1);NTT(r,ln,1);px(r,sav,ln);
		NTT(r,ln,-1);clr(r,ln>>1);cpy(sav,w,ln);NTT(sav,ln,1);
	    NTT(r,ln,1);px(r,sav,ln);NTT(r,ln,-1);
	    for(int i=ln>>1;i<ln;i++) w[i]=(w[i]*2ll-r[i]+P)%P;
	}cpy(A,w,lim);clr(sav,n);clr(w,n);clr(r,n);
}
void rev(int *A,int lim){
    cpy(sav,A,lim);
    for (int i=0;i<lim;i++) A[i]=sav[lim-i-1];
    clr(sav,lim);
}
void mof(int *A,int *B,int n,int m){
	static int q[MAXN<<1],t[MAXN<<1],_s[MAXN]; 
	int l=n-m+1;cpy(_s,B,m);
	rev(B,m);cpy(q,B,l);rev(B,m);
	rev(A,n);cpy(t,A,l);rev(A,n);
	invp(q,l);mul(q,t,l,l);rev(q,l);
	mul(B,q,n,n);
	for(int i=0;i<m-1;i++) A[i]=(A[i]-B[i]+P)%P;
	clr(B+m-1,l);cpy(B,_s,m);clr(B+m,n-m); 
}//A<-A%B.
void dao(int *A,int lim){//导数 
	for(int i=1;i<lim;i++) A[i-1]=1ll*A[i]*i%P;
	A[lim-1]=0;
}
void inv_init(int lim){
	inv[1]=1;
	for(int i=2;i<=lim;i++) inv[i]=1ll*inv[P%i]*(P-P/i)%P;
}
void jifen(int *A,int lim){//积分 
	for(int i=lim;i;i--) A[i]=1ll*A[i-1]*inv[i]%P;
	A[0]=0;
}
void lnp(int *A,int lim){//ln 
	static int w[MAXN<<1];
	cpy(w,A,lim);
	invp(w,lim);dao(A,lim);
	mul(A,w,lim,lim);
	jifen(A,lim-1);
	clr(w,lim);
}
void exp(int *A,int lim){//exp
	static int s[MAXN<<1],s2[MAXN<<1];
	int n=bceil(lim);
	s2[0]=1;
	for(int ln=2;ln<=n;ln<<=1){
		cpy(s,s2,ln>>1);lnp(s,ln);
		for(int i=0;i<ln;i++) s[i]=(A[i]-s[i]+P)%P;
		s[0]=(s[0]+1)%P;
		mul(s2,s,ln,ln);
	}cpy(A,s2,lim);clr(s,n);clr(s2,n);
}
void sqrtp(int *A,int lim){
	int n=bceil(lim);
	static int s[MAXN<<1],s2[MAXN<<1];
	s[0]=1;
	for(int ln=2;ln<=n;ln<<=1){
		for(int i=0;i<(ln>>1);i++) s2[i]=(s[i]<<1)%P;
		invp(s2,ln);NTT(s,ln,1);px(s,s,ln);NTT(s,ln,-1);
		for(int i=0;i<ln;i++) s[i]=(A[i]+s[i])%P;
		mul(s,s2,ln,ln);
	}cpy(A,s,lim);clr(s,n+n);clr(s2,n+n);
}
void arcsin(int *A,int lim){
	static int S[MAXN];cpy(S,A,lim);dao(S,lim);
	int n=bceil(lim*2);
	NTT(A,n,1);px(A,A,n);NTT(A,n,-1);clr(A+lim,n-lim);
	for(int i=0;i<lim;i++) A[i]=(P-A[i])%P;
	A[0]=(A[0]+1)%P;sqrtp(A,lim);invp(A,lim);
	mul(A,S,lim,lim);jifen(A,lim);clr(S,lim);
}
void arctan(int *A,int lim){
	static int S[MAXN];cpy(S,A,lim);dao(S,lim);
	int n=bceil(lim*2);
	NTT(A,n,1);px(A,A,n);NTT(A,n,-1);clr(A+lim,n-lim);
	A[0]=(A[0]+1)%P;invp(A,lim);
	mul(A,S,lim,lim);jifen(A,lim);clr(S,lim);
}
int n,type,a[MAXN],b[MAXN];
int main(){
	n=read();type=read();inv_init(n);
	for(int i=0;i<n;i++) a[i]=read();
	if(type) arctan(a,n);
	else arcsin(a,n);
	for(int i=0;i<n;i++) write(a[i]),putchar(' ');
    return 0;
}
```

---

## 作者：Terac (赞：1)

[$\texttt{link}$](https://www.luogu.com.cn/problem/P5265)

这个题很简单，几个板子套一套就做完了，需要了解一些简单微积分。

首先两个结论
$$\arcsin'x=\dfrac{1}{\sqrt{1-x^2}}$$
$$\arctan'x=\dfrac{1}{1+x^2}$$

证明也很好证，经典隐函数证明。

先看 $\arcsin'x$ 的，设 $\sin y=x$，则

$$\sin'y=x'$$
$$y'\cos y=1$$
$$y'=\dfrac{1}{\cos y}$$
$$y'=\dfrac{1}{\sqrt{1-\sin^2y}}$$
$$\arcsin'x=\dfrac{1}{\sqrt{1-x^2}}$$

$\arctan'x$ 同理，设 $\tan y=x$，则
$$\tan'y=x'$$
$$y'\sec^2y=1$$
$$y'=\dfrac{1}{\sec^2y}$$
$$y'=\dfrac{1}{1+\tan^2y}$$
$$\arctan'x=\dfrac{1}{1+x^2}$$

回到这题，设 $G=\arcsin F$，则
$$\begin{aligned}G'&=\arcsin'F\\&=\dfrac{F'}{\sqrt{1-F^2}}\end{aligned}$$

积回来

$$G=\int \dfrac{F'}{\sqrt{1-F^2}}dx$$


同理，设 $G=\arctan F$，则
$$\begin{aligned}G'&=\arctan'F\\&=\dfrac{F'}{1+F^2}\end{aligned}$$

积回来

$$G=\int\dfrac{F'}{1+F^2}dx$$
套一下多项式求导，积分，开根，乘法，求逆即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO {
	//read and write
} using namespace IO;
const int N = 2.7e5 + 10;
namespace Polynomial {
    const int mod = 998244353, G = 3, Gi = 332748118, inv2 = 499122177;
    int lim, rev[N], a[N], b[N], c[N];
    int qpow(int n, int k) {
        int res = 1;
        for(; k; n = 1ll * n * n % mod, k >>= 1)
            if(k & 1) res = 1ll * res * n % mod;
        return res;
    }
    void NTT(int *f, int T) {
        for(int i = 0; i < lim; i++)
            if(i < rev[i]) 
                swap(f[i], f[rev[i]]);
        for(int mid = 1; mid < lim; mid <<= 1) {
            int wn = qpow(T == 1 ? G : Gi, (mod - 1) / (mid << 1));
            int len = mid << 1;
            for(int i = 0; i < lim; i += (mid << 1)) {
                int w = 1;
                for(int j = 0; j < mid; j++, w = 1ll * w * wn % mod) {
                    int x = f[i + j], y = 1ll * w * f[i + j + mid] % mod;
                    f[i + j] = (x + y) % mod;
                    f[i + j + mid] = (x - y + mod) % mod;
                }
            }
        }
        if(T == -1) {
            int inv = qpow(lim, mod - 2);
            for(int i = 0; i < lim; i++) 
                f[i] = 1ll * f[i] * inv % mod;
        }
    }
    void init(int n) {
        for(lim = 1; lim < n; lim <<= 1);
        for(int i = 0; i < lim; i++)
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (lim >> 1));
    } 
    void mul(int *f, int *g, int *h, int n, int m) {
        static int a[N], b[N];
        init(n + m - 1);
        memset(a, 0, lim << 2);
        memcpy(a, f, n << 2);
        memset(b, 0, lim << 2);
        memcpy(b, g, m << 2);
        NTT(a, 1), NTT(b, 1);
        for(int i = 0; i < lim; i++) 
            h[i] = 1ll * a[i] * b[i] % mod;
        NTT(h, -1);
    }
    void inv(int *f, int *g, int n) {
        if(n == 1) { g[0] = qpow(f[0], mod - 2); return; }
        inv(f, g, n + 1 >> 1);
        init(n << 1);
        copy(f, f + n, a);
        fill(a + n, a + lim, 0);
        NTT(a, 1), NTT(g, 1);
        for(int i = 0; i < lim; i++)
            g[i] = (2 - 1ll * a[i] * g[i] % mod + mod) % mod * g[i] % mod;
        NTT(g, -1);
        fill(g + n, g + lim, 0);
    }
    void sqrt(int *f, int *g, int n) {
        if(n == 1) { g[0] = 1; return; }
        sqrt(f, g, n + 1 >> 1);
        memset(b, 0, n << 2);
        inv(g, b, n);
        mul(f, b, b, n, n);
        for(int i = 0; i < n; i++)
            g[i] = 1ll * (g[i] + b[i]) * inv2 % mod;
    }
    void dev(int *f, int *g, int n) {
        for(int i = 1; i < n; i++)
            g[i - 1] = 1ll * i * f[i] % mod;
        g[n - 1] = 0;
    }
    void invdev(int *f, int *g, int n) {
        for(int i = n - 1; i; i--)
            g[i] = 1ll * f[i - 1] * qpow(i, mod - 2) % mod;
        g[0] = 0;
    }
    void arcsin(int *f, int *g, int n) {
    	static int a[N], b[N], c[N];
    	dev(f, a, n); 
    	mul(f, f, b, n, n);
    	for(int i = 0; i < n; i++)
    		b[i] = (mod - b[i]) % mod;
    	b[0] = (b[0] + 1) % mod;
    	sqrt(b, c, n);
    	memset(b, 0, lim << 2);
    	inv(c, b, n);
    	memset(c, 0, lim << 2);
    	mul(a, b, c, n, n);
    	invdev(c, g, n);
	}
	void arctan(int *f, int *g, int n) {
		static int a[N], b[N], c[N];
		dev(f, a, n); 
    	mul(f, f, b, n, n);
    	b[0] = (b[0] + 1) % mod;
    	inv(b, c, n);
    	memset(b, 0, lim << 2);
    	mul(a, c, b, n, n);
    	invdev(b, g, n);
	}
} using namespace Polynomial;
int n, type, f[N], g[N];
int main() {
	n = read(), type = read();
	for(int i = 0; i < n; i++)
		f[i] = read();
	if(!type) arcsin(f, g, n);
	else arctan(f, g, n);
	for(int i = 0; i < n; i++)
		write(g[i]), putc(' ');
	flush();
	return 0;
}
```


---

## 作者：Spasmodic (赞：1)

[可能更好的阅读体验。](https://www.luogu.com.cn/blog/happydef-blog/duo-xiang-shi-quan-jia-tong-xue-xi-bi-ji)

和多项式$\ln$差不多。。。

首先推一发$\arcsin$
$$y=\arcsin x$$
$$\sin y=x$$
$$d(\sin y)=dx$$
$$dy\times \cos y=dx$$
$$\frac{dy}{dx}=\frac{1}{\cos y}=\frac{1}{\sqrt{1-\sin y^2}}=\frac{1}{\sqrt{1-x^2}}$$
返回原题
$$G\equiv \arcsin F\pmod {x^n}$$
$$G'\equiv \frac{F'}{\sqrt{1-F^2}}\pmod {x^{n-1}}$$
$$G\equiv \int \frac{F'}{\sqrt{1-F^2}}dx\pmod {x^n}$$
over。

下面是$y=\arctan x$：
$$y=\arctan x$$
$$\tan y=x$$
$$d(\tan y)=dx$$
$$dy\times \sec^2 y=dx$$
$$\frac{dy}{dx}=\frac{1}{\sec^2 y}=\frac{1}{1+\tan^2 y}=\frac{1}{1+x^2}$$
返回原题
$$G\equiv \arctan F\pmod {x^n}$$
$$G'\equiv \frac{F'}{1+F^2}\pmod {x^{n-1}}$$
$$G\equiv \int \frac{F'}{1+F^2}dx\pmod {x^n}$$
over。

总复杂度依然是$O(n\log n)$。

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std; 
typedef long long ll; 
const ll N=100005*3,P=998244353,G=3;
ll n,tp,f[N],g[N],inv[N]={1,1};
namespace Poly{
	const ll P=998244353,G=3;
	ll lmt,rev[N],a[N],b[N],c[N],d[N],e[N],h[N],x[N],y[N],z[N];
	inline ll qpow(ll a,ll k){
		ll ret=1;
		while(k){
			if(k&1)ret=ret*a%P;
			a=(a*a)%P;
			k>>=1;
		}
		return ret%P;
	}
	inline void init(ll n){
		lmt=1;ll t=0;
		while(lmt<n)lmt<<=1,t++;
		for(ll i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
	}
	inline void NTT(ll *A,ll lmt,ll tp){
		for(ll i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
		for(ll m=1;m<lmt;m<<=1)
			for(ll j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
				for(ll k=0,w=1,x,y;k<m;k++,w=w*Wn%P)
					x=A[j+k],y=w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
		if(tp==1)return;
		reverse(A+1,A+lmt);
		for(ll i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=A[i]*inv%P;
	} 
	inline void mul(ll *f,ll *g,ll len){
		init(len);
		NTT(f,lmt,1);NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)f[i]=(f[i]*g[i])%P;
		NTT(f,lmt,-1);
	} 
	void getinv(ll*f,ll*g,ll len){
		if(len==1){g[0]=inv[f[0]];return;}
		getinv(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<len;i++)c[i]=f[i];
		for(ll i=len;i<lmt;i++)c[i]=0;
		NTT(c,lmt,1),NTT(g,lmt,1);
		for(ll i=0;i<lmt;i++)g[i]=(2LL-g[i]*c[i]%P+P)%P*g[i]%P;
		NTT(g,lmt,-1);
		for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	inline void getdev(ll*f,ll*g,ll len){
		for(ll i=1;i<len;i++)g[i-1]=i*f[i]%P;
		g[len-1]=g[len]=0;
	}
	inline void getinvdev(ll*f,ll*g,ll len){
		for(ll i=1;i<=len;i++)g[i]=f[i-1]*inv[i]%P;
		g[0]=0;
	}
	inline void getln(ll*f,ll*g,ll len){
		memset(a,0,(len*3)<<3);
		memset(b,0,(len*3)<<3);
		getdev(f,a,len);
		getinv(f,b,len);
		mul(a,b,len<<1);
		getinvdev(a,g,len);
	}
	void getexp(ll*f,ll*g,ll len){
		if(len==1){g[0]=1;return;}
		getexp(f,g,len+1>>1);
		init(len<<1);
		for(ll i=0;i<(len<<1);i++)d[i]=e[i]=0;
		getln(g,d,len);
		for(ll i=0;i<len;i++)e[i]=f[i];
	    NTT(g,lmt,1),NTT(d,lmt,1),NTT(e,lmt,1);
    	for(ll i=0;i<lmt;i++)g[i]=(1-d[i]+e[i]+P)*g[i]%P;
    	NTT(g,lmt,-1);
    	for(ll i=len;i<lmt;i++)g[i]=0; 
	}
	inline void getsqrt(ll*f,ll*g,ll len){
		getln(f,h,len);
		for(ll i=0;i<len;i++)h[i]=h[i]*inv[2]%P;
		getexp(h,g,len);
	}
	inline void arcsin(ll*f,ll*g,ll len){
		getdev(f,x,len);
		init(len<<1);
		NTT(f,lmt,1);
		for(ll i=0;i<lmt;i++)y[i]=(1+P-f[i]*f[i]%P)%P;
		NTT(y,lmt,-1);
		for(ll i=len;i<lmt;i++)y[i]=0;
		getsqrt(y,z,len);
		memset(y,0,(len+1)<<3);
		getinv(z,y,len);
		NTT(x,lmt,1),NTT(y,lmt,1);
		for(ll i=0;i<lmt;i++)x[i]=x[i]*y[i]%P;
		NTT(x,lmt,-1);
		getinvdev(x,g,len);
	}
	inline void arctan(ll*f,ll*g,ll len){
		getdev(f,x,len);
		init(len<<1);
		NTT(f,lmt,1);
		for(ll i=0;i<lmt;i++)y[i]=(1+f[i]*f[i]%P)%P;
		NTT(y,lmt,-1);
		for(ll i=len;i<lmt;i++)y[i]=0;
		getinv(y,z,len);
		NTT(x,lmt,1),NTT(z,lmt,1);
		for(ll i=0;i<lmt;i++)x[i]=x[i]*z[i]%P;
		NTT(x,lmt,-1);
		getinvdev(x,g,len);
	}
}
using Poly::arcsin;
using Poly::arctan;
int main(){
	scanf("%lld%lld",&n,&tp);
	ll lmt=1;
	while(lmt<n)lmt<<=1;
	for(ll i=2;i<lmt;i++)inv[i]=(P-P/i)*inv[P%i]%P;
	for(ll i=0;i<n;i++)scanf("%lld",&f[i]);
	if(tp==0)arcsin(f,g,n);
	else arctan(f,g,n);
	for(ll i=0;i<n;i++)printf("%lld ",g[i]); 
	return 0;
}
```

---

## 作者：Jμdge (赞：0)



→_→ OI 生涯晚期才开始刷板子题的咱


其实这题就是道公式题，搞过多项式全家桶的同学贴贴板子照着公式码两下都能过...

至于公式的证明嘛...总之贴上公式：

$$Arcsin(F)=\int{F'\over \sqrt{1-F^2}}$$

$$Arctan(F)=\int{F'\over 1+F^2}$$

然后可以康出这里就是一个要用 Sqrt、 Inv、Inter、Direv 的 ~~普通~~ 多项式题


# Code

```
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=3e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int dec(int x,int y){return (x-=y)<0?x+mod:x;}
inline int inc(int x,int y){return (x+=y)>=mod?x-mod:x;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr=' '){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,tp,d,limit; arr a,b,r[21],lg,inv,G[2];
inline int qpow(Rg int x,Rg int p=mod-2,Rg int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
namespace Poly{
	inline void init(Rg int n){ d=0;
		for(limit=1;limit<=n<<1;limit<<=1)++d;
	}
	inline void prep(int n){ inv[1]=1,init(n);
		fp(i,2,limit) inv[i]=mul(mod-mod/i,inv[mod%i]);
		fp(d,1,19){ lg[1<<d]=d; fp(i,0,(1<<d)-1)
			r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
		}
		for(Rg int t=(mod-1)>>1,i=1,x,y;i<262144;i<<=1,t>>=1){
			x=qpow(3,t),y=qpow(iG,t),G[0][i]=G[1][i]=1;
			fp(k,1,i-1) G[1][i+k]=mul(G[1][i+k-1],x),G[0][i+k]=mul(G[0][i+k-1],y);
		}
	}
	inline void NTT(int* a,int tp){ fp(i,0,limit-1) if(i<r[d][i]) swap(a[i],a[r[d][i]]);
		for(Rg int mid=1,I=2;mid<limit;mid<<=1,I<<=1) for(Rg int j=0,y;j<limit;j+=I) fp(k,0,mid-1)
			y=mul(G[tp][mid+k],a[j+k+mid]),a[j+k+mid]=dec(a[j+k],y),a[j+k]=inc(a[j+k],y);
		if(tp) return ; fp(i,0,limit-1) a[i]=mul(a[i],inv[limit]);
	}
	void Inv(int* a,int* b,int n){
		static arr C,D; if(n==1) return b[0]=qpow(a[0]),void();
		Inv(a,b,(n+1)>>1),init(n); fp(i,0,n-1) C[i]=a[i],D[i]=b[i];
		fp(i,n,limit-1) C[i]=D[i]=0; NTT(C,1),NTT(D,1);
		fp(i,0,limit-1) C[i]=mul(C[i],mul(D[i],D[i])); NTT(C,0);
		fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),C[i]); fp(i,n,limit-1) b[i]=0;
	}
	void Sqrt(int* a,int* b,int n){
		static arr D,F; if(n==1) return b[0]=sqrt(a[0]),void();
		Sqrt(a,b,(n+1)>>1); fp(i,0,n<<1) F[i]=0;
		Inv(b,F,n),init(n); fp(i,0,n-1) D[i]=a[i];
		fp(i,n,limit-1) D[i]=0; NTT(D,1),NTT(b,1),NTT(F,1);
		fp(i,0,limit-1) b[i]=mul(inc(b[i],mul(D[i],F[i])),inv[2]);
		NTT(b,0); fp(i,n,limit-1) b[i]=0;
		memset(D,0,limit<<2),memset(F,0,limit<<2);
	}
	inline void Direv(int* a,int* b,int n){
		fp(i,1,n-1) b[i-1]=mul(a[i],i); b[n-1]=b[n]=0;
	}
	inline void Inter(int* a,int* b,int n){
		fp(i,1,n-1) b[i]=mul(a[i-1],inv[i]); b[0]=0;
	}
	inline void Arcsin(int* a,int* b,int n){
		static arr A,B,C; Direv(a,A,n),init(n),NTT(a,1);
		fp(i,0,limit-1) B[i]=dec(1,mul(a[i],a[i])); NTT(B,0);
		fp(i,n,limit-1) B[i]=0; Sqrt(B,C,n),Inv(C,B,n),NTT(A,1),NTT(B,1);
		fp(i,0,limit-1) A[i]=mul(A[i],B[i]); NTT(A,0); Inter(A,b,n);
	}
	inline void Arctan(int* a,int* b,int n){
		static arr A,B,C; Direv(a,A,n),init(n),NTT(a,1);
		fp(i,0,limit-1) B[i]=inc(mul(a[i],a[i]),1);
		NTT(B,0),Inv(B,C,n),NTT(A,1),NTT(C,1);
		fp(i,0,limit-1) A[i]=mul(A[i],C[i]);
		NTT(A,0); Inter(A,b,n);
	}
} using namespace Poly;
int main(){
	n=read(),tp=read(),prep(n);
	fp(i,0,n-1) a[i]=read();
	if(tp) Arctan(a,b,n);
	else Arcsin(a,b,n);
	fp(i,0,n-1) print(b[i]);
	return Ot(),0;
}


```


底层优化了一下才跑到第一页...



顺便等咱康懂了证明之后可能会 Update 一下题解（虽说感觉咱永远也康不懂就是了）


# Upd

在神鱼的帮助下康懂了求导过程...orz 神鱼 Nacly_Fish

首先咱都知道对于一个函数存在：

$$F(x)=\int F'(x)$$

>不要在意边界、定不定和什么余项不余项的...

好吧正确的式子应该是这个丫子的：

$$F(x)=\int F'(x)  +R(x)$$

其中 $R(x)$ 就是个~~弟弟~~余项，你可以认为这是强行对于积分后的末项进行补差（因为求导之后常数项信息丢失，积分之后信息被搞成了 0 ）


由于三角函数与反三角函数的优良性质（艹，无限项数），这个 R 就木有掉了


然后咱考虑原问题：

首先对于 arcsin ， 咱可以这么求出它的导数，然后进行积分求解，那么这个玩意儿的导数怎么求呢？

算了不废话了直接一顿证明完事儿好了：

$$\begin{aligned}     \begin{cases} sin'(x)={dy\over dx}  \\sin'(x) =cos(x)  \end{cases}    \\        \Rightarrow  {dy\over dx}=cos(x) \\ {dx\over dy} ={1\over cos(x)}  \\{d ~arcsin (y)\over dy} ={1\over \sqrt{1-y^2}}          \end{aligned}$$

也就是说，对于一个已知值 x ，存在：

$$\begin{aligned}  arcsin'(x)={1\over \sqrt{1-x^2}}  \\arcsin(x)=\int{1\over \sqrt{1-x^2}} \end{aligned}$$

令 $Arcsin(x)$ 表示以 $x$ 为变量的 $arcsin(F(x))$ 那么对于一个多项式有：

$$\begin{aligned}Arcsin(x)&=arcsin(F(x))  \\     Arcsin'(x) &=arcsin(F(x))' \\   Arcsin'(x) &=arcsin'(F(x)) F'(x)\\   Arcsin'(x) &={F'(x)\over \sqrt{1-F^2(x)}}  \\  Arcsin(x) &=\int{F'(x) \over \sqrt{1-F^2(x)}} \end{aligned}$$

证毕



然后啃啃 $Arctan$ ? 这个您可以自己啃，只要用类似的方法，把 $tan'(x)={1\over cos^2(x)}$ 套一套就好了

您可以自己推一推，如果想看咱的推导可以移步咱的 [$cnblogs$](https://www.cnblogs.com/Judge/p/11615446.html)










---


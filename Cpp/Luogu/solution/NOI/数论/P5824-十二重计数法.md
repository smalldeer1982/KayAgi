# 十二重计数法

## 题目背景

组合数学是一门古老而迷人的学科。

传说早在 $114514$ 年前，一位名为忆哀的神灵来到地球，发现了人类——另一种有智慧的物种。  

她觉得这很有趣，为了加速人类文明的发展，她向人间传下了一类计数问题——十二重计数，这也正是组合数学的开端。  

而只有搞明白这类问题，才能在组合数学上继续深入。

## 题目描述

有 $n$ 个球和 $m$ 个盒子，要全部装进盒子里。  
还有一些限制条件，那么有多少种方法放球？（与放的先后顺序无关）  

限制条件分别如下：    

$\text{I}$：球之间互不相同，盒子之间互不相同。    
$\text{II}$：球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。   
$\text{III}$：球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。  

$\text{IV}$：球之间互不相同，盒子全部相同。        
$\text{V}$：球之间互不相同，盒子全部相同，每个盒子至多装一个球。   
$\text{VI}$：球之间互不相同，盒子全部相同，每个盒子至少装一个球。

$\text{VII}$：球全部相同，盒子之间互不相同。  
$\text{VIII}$：球全部相同，盒子之间互不相同，每个盒子至多装一个球。  
$\text{IX}$：球全部相同，盒子之间互不相同，每个盒子至少装一个球。   

$\text{X}$：球全部相同，盒子全部相同。   
$\text{XI}$：球全部相同，盒子全部相同，每个盒子至多装一个球。  
$\text{XII}$：球全部相同，盒子全部相同，每个盒子至少装一个球。

由于答案可能很大，所以要对 $998244353$ 取模。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2\times 10^5$。

orz $\mathsf E \color{red}\mathsf{ntropyIncreaser}$

## 样例 #1

### 输入

```
13 6```

### 输出

```
83517427
0
721878522
19628064
0
9321312
8568
0
792
71
0
14```

# 题解

## 作者：CYJian (赞：70)

$n$ 个球， $m$ 个盒子

#### 一、球不同，盒子不同，无其他限制

显然为 $m^n$

#### 二、球不同，盒子不同，每个盒子至多装一个球

考虑相当于每个球找一个没有被选过的盒子放进去。不难发现，方案数为 $m^{\underline{n}}$

#### 三、球不同，盒子不同，每个盒子至少装一个球

考虑容斥：枚举多少个盒子空了，然后剩下的部分就是第一个部分了。然后就可以得到下面这个式子：

$$ \sum_{i=0}^{m} (-1)^{i} \binom{m}{i} (m-i)^{n} $$

#### 四、球不同，盒子相同，无其他限制

考虑第二类斯特林数： $S_{n,m}$ 表示 $n$ 个不同的元素组成 $m$ 个非空集合的方案数。

考虑枚举多少个盒子里头装了球，那么答案为：

$$ \sum_{i=1}^{m} S_{n,i} $$

蒯 第二类斯特林数 · 行 就行了

#### 五、球不同，盒子相同，每个盒子至多装一个球

~~最思博的部分了~~不论放到哪个盒子里头都是一样的，所以答案就是 $[n \leq m]$

#### 六、球不同，盒子相同，每个盒子至少装一个球

根据第二类斯特林数的定义，显然答案为 $S_{n,m}$

#### 七、球相同，盒子不相同，无其他限制

利用插板法，我们可以知道，答案为 $\binom{n+m-1}{m-1}$

#### 八、球相同，盒子不相同，每个盒子至多装一个球

盒子不同，我们相当于要选出 $n$ 个盒子装球，剩下 $m-n$ 个盒子不装球。

所以答案就是 $\binom{m}{n}$

#### 九、球相同，盒子不相同，每个盒子至少装一个球

同样利用插板法，我们先钦定每个盒子里头放一个球，剩下 $n-m$ 个球按照第七个做就行了。

答案即为 $\binom{n-1}{m-1}$

#### 十、球相同，盒子相同，无其他限制

设 $p_{n,m}$ 表示“划分数”——即将 $n$ 划分成 $m$ 个自然数的可重集的方案数。那么我们要的答案就是 $p_{n,m}$

这个东西有一个非常经典的时空复杂度为 $O(n^2)$ 的 $dp$：

$$ p_{i,j} = p_{i-j,j} + p_{i,j-1} $$

两者的意思分别为：将 $j$ 个 自然数同时 $+1$、加入一个 $0$ 到可重集中。

不难发现这样的确可以不重不漏地计数。

再考虑优化：我们构造一个多项式为：

$$ F_i(x)=p_{0,i}+p_{1,i}x+p_{2,i}x^{2}+p_{3,i}x^{3} \dots $$

那么根据上面的转移，我们有：

$$ F_i(x) = F_{i-1}(x) \times (1+x^i+x^{2i}+x^{3i}\dots) $$

$$ F_i(x) = \frac{F_{i-1}(x)}{1-x^{i}} $$

那么也就不难得到：

$$ F_{i}(x) = \prod_{j=1}^{i} \frac{1}{1-x^{j}} $$

这个东西和 [付公主的背包](https://www.luogu.com.cn/problem/P4389) 是一样的。具体做法就是求 $\ln$ ，加起来再 $\exp$ 回去，最后求个逆就完了。

考虑这个东西如何快速求 $\ln$：

$$ G(x) = \ln (1-x^{i}) $$

$$ G'(x) = \frac{-ix^{i-1}}{1-x^{i}} $$

$$ G'(x) = (-ix^{i-1}) \times \frac{1}{1-x^{i}} $$

$$ G'(x) = (-ix^{i-1}) \times \sum_{j=0}^{\infty} x^{ij} $$

$$ G'(x) = -\sum_{j=1}^{\infty} ix^{ij-1} $$

$$ G(x) = -\sum_{j=1}^{\infty} \frac{x^{ij}}{j} $$

然后在模 $x^{n+1}$ 意义下做这个东西就完事了。

#### 十一、球相同，盒子相同，每个盒子至多装一个球

和第五个是一样的东西，就是 $[n\leq m]$。

#### 十二、球相同，盒子相同，每个盒子至少装一个球

考虑就是将上面的“划分数”中的自然数变成正整数，我们强制现在每个盒子里头放一个球，就是同样的问题了。答案即为 $p_{n-m,m}$。

[完整代码](https://www.luogu.com.cn/paste/aszwjcqg) 比较长，这里略去多项式板子以及基础数论部分的代码（因为用的是 vim，所以可能有很多折叠标记）

```cpp
/********************************************************************************
	
	Code by a weak man who named CYJian, and he hopes the code can get more scores.

	Algorithm: 

 ********************************************************************************/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

//{{{ FAST IO
const int __SIZE = 1 << 18;
char ibuf[__SIZE], *iS, *iT;

#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
#define ri read_int()
#define rl read_ll()
#define FILE(s) freopen(s"in", "r", stdin), freopen(s"out", "w", stdout)

template<typename T>
inline void read(T &x) {
	char ch, t = 0; x = 0;
	while(!isdigit(ch = ge)) t |= ch == '-';
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;
	x = t ? -x : x;
}
inline int read_int() { int x; return read(x), x; }
inline ll read_ll() { ll x; return read(x), x; }
//}}}

template<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }
template<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }

const int MAXN = 530010;
const int mod = 998244353;

inline int Mod(int x) { return x >= mod ? x - mod : x; }
inline void Add(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }

int n, m;

int fac[MAXN];
int inv[MAXN];
int ifac[MAXN];

int tN;
int N, InvN;
int p[MAXN];
int G[MAXN];
int S[MAXN];
int F[MAXN];

int A[MAXN];
int B[MAXN];
int tA[MAXN];
int tB[MAXN];
int tC[MAXN];
int tD[MAXN];

//{{{ Math And Prework
inline int fsp(int x, int k = mod - 2) {}// 快速幂
inline int C(int n, int m) {} // 组合数
inline void Combine_init(int n) {} // 预处理阶乘以及逆元
inline void Prework() {} // 预处理原根
inline void NTT_init(int n) {}
inline void NTT(int a[], int k) {} // 快速数论变换
inline void GetInv(int A[], int B[], int n) {} // 多项式求逆
inline void GetLn(int A[], int B[], int n) {} // 多项式求对数
inline void GetExp(int A[], int B[], int n) {} // 多项式 exp

inline void init(int n, int m) {
	Prework(), Combine_init(n + m), NTT_init(max(n, m));
    
	for(int i = 0; i <= n; i++) {
		A[i] = i & 1 ? mod - ifac[i] : ifac[i];
		B[i] = 1LL * fsp(i, n) * ifac[i] % mod;
	} NTT(A, 1), NTT(B, 1);
	for(int i = 0; i < N; i++) A[i] = 1LL * A[i] * B[i] % mod;
	NTT(A, -1);
	for(int i = 0; i <= n; i++) S[i] = A[i]; // 第二类斯特林数
    
	memset(A, 0, sizeof(A));
	for(int i = 1; i <= m; i++)
		for(int j = i; j <= n; j += i)
			Add(A[j], mod - inv[j / i]);
	memset(B, 0, sizeof(B)), GetExp(A, B, n + 1);
	memset(A, 0, sizeof(A)), GetInv(B, A, n + 1);
	for(int i = 0; i <= n; i++) F[i] = A[i]; // p_{i, m}
}
//}}}

//{{{ solve01
inline int solve01() { return fsp(m, n); }
//}}}

//{{{ solve02
inline int solve02() {
	int res = 1;
	for(int i = 0; i < n; i++)
		res = 1LL * res * (m - i) % mod;
	return res;
}
//}}}

//{{{ solve03
inline int solve03() {
	int res = 0;
	for(int i = 0; i < m; i++)
		res = (res + 1LL * (i & 1 ? mod - C(m, i) : C(m, i)) * fsp(m - i, n)) % mod;
	return res;
}
//}}}

//{{{ solve04
inline int solve04() {
	int res = 0;
	for(int i = 1; i <= m; i++) Add(res, S[i]);
	return res;
}
//}}}

//{{{ solve05
inline int solve05() { return n <= m; }
//}}}

//{{{ solve06
inline int solve06() { return S[m]; }
//}}}

//{{{ solve07
inline int solve07() { return C(n + m - 1, m - 1); }
//}}}

//{{{ solve08
inline int solve08() { return C(m, n); }
//}}}

//{{{ solve09
inline int solve09() { return C(n - 1, m - 1); }
//}}}

//{{{ solve10
inline int solve10() { return F[n]; }
//}}}

//{{{ solve11
inline int solve11() { return n <= m; }
//}}}

//{{{ solve12
inline int solve12() { return n >= m ? F[n - m] : 0; }
//}}}

int main() {
#ifdef LOCAL
	FILE("");
#endif
	n = ri, m = ri, init(n, m);
	cout << solve01() << endl;
	cout << solve02() << endl;
	cout << solve03() << endl;
	cout << solve04() << endl;
	cout << solve05() << endl;
	cout << solve06() << endl;
	cout << solve07() << endl;
	cout << solve08() << endl;
	cout << solve09() << endl;
	cout << solve10() << endl;
	cout << solve11() << endl;
	cout << solve12() << endl;
	return 0;
}
```

---

## 作者：鏡音リン (赞：35)

经典球盒模型大合集题。很久之前自己就整理过类似的东西，今天突然发现洛谷上有这么个题，来水一篇题解。

注意，下面的讲解顺序不完全按照题目中的顺序。讲解不是非常详细，需要读者对计数原理有基本了解。

#### I 球不同盒不同

每个球都可以独立选择 $m$ 个盒，答案是 $ans_1=m^n$。

#### II, VIII 盒不同，盒最多放一个球

在问题 II 中球不同，按顺序把每个球所在的盒的编号排出来，相当于在 $m$ 个数里选 $n$ 个组成排列，答案就是 $ans_2=A(m,n)=\frac{m!}{(m-n)!}$。

如果球相同还要除以球的顺序，相当于在 $m$ 个数里选 $n$ 个数没有顺序，那么 $ans_8=C(m,n)=\frac{m!}{n!(m-n)!}$。

#### V, XI 盒相同，盒最多放一个球

如果 $n>m$ 必然放不进去，否则所有合法方案都没区别，只有一种方案，那么 $ans_5=ans_{11}=[n\le m]$。

#### VII, IX 球相同盒不同

对于问题 IX 盒非空，考虑把 $n$ 个球摆成一排然后在中间插 $m-1$ 个板子（相邻两个球只间最多插一个板子），插好后相邻两个板子之间的球放入一个盒，这样盒是有顺序的。那么就是在 $n-1$ 个空位选出 $m-1$ 个位置放板子，有 $ans_9=C(n-1,m-1)$。

如果盒可以为空，先增加 $m$ 个球按照问题 IX 求出来，然后把每个盒里拿出来一个球，这时就是盒可空的方案数了。拿出来球是不影响方案数的，即 $ans_7=C(n+m-1,m-1)$。

#### X, XII 球相同盒相同

先看问题 X。设 $n$ 个相同球分入 $m$ 个相同盒的方案数是 $T(n,m)$。按照有没有空盒来分类，如果有空盒就去掉这个空盒（加号左边），如果没有就所有盒取出一个球（加号右边），可以得到递推式 $T(n,m)=T(n,m-1)+T(n-m,m)$。

它是一个背包的形式，等价于用重量为 $1,2,3\dots m$ 的物品填满容量为 $n$ 的完全背包的方案数。

对它的第 $m$ 列做生成函数，这个很好推就不在这里推了，直接写出结果：

$$G_m(x)=\sum_{n=0}^\infty T(n,m)x^n=\prod_{i=1}^m\frac{1}{1-x^i}$$

$$ans_{10}=[x^n]G_m(x)$$

那么这个东西该怎么处理呢？请参见模板题[P4389 付公主的背包](https://www.luogu.com.cn/problem/P4389 )及其下的题解。

对于问题 XII, 类似问题 VII 的处理方法，这回我们要先减少 $m$ 个球，然后按照问题 X 算，然后再把每个盒里加一个球。答案是 $ans_{12}=[x^{n-m}]G_m(x)$。

#### III, VI 球不同，盒非空

这两个问题本质上是一样的。这里给出第二类斯特林数的定义：$S_2(n,m)$ 是 $n$ 个不同元素分成 $m$ 个非空集合的方案数。

根据定义 $ans_6=S_2(n,m)$。我们可以先求问题 III，盒是有区别的，枚举有多少个盒是空的，容斥计算：

$$ans_3=\sum_{i=0}^m(-1)^iC(m,i)(m-i)^n$$

因为球有区别，此时每个盒都是独一无二的，所以可以直接除去盒的顺序：

$$ans_6=S_2(n,m)=\frac{1}{m!}ans_3=\frac{1}{m!}\sum_{i=0}^m(-1)^iC(m,i)(m-i)^n$$

这就是第二类斯特林数的通项公式，关于它的更多性质和应用可以自行上网搜索资料。

#### IV 球不同盒相同

考虑对于每一种方案，放完之后都把所有空盒扔掉，剩下的盒不超过 $m$ 个。那么就相当于 $n$ 个不同的球放到不超过 $m$ 个非空盒子里的方案数，直接用上面的第二类斯特林数做和就可以了。

$$ans_4=\sum_{i=0}^mS_2(n,m)$$

如何快速求第二类斯特林数的一行呢，注意到这个通项公式展开后是一个卷积的形式，可以用 NTT 优化卷积。具体做法参见另一道模板题[P5395 第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395 )及其下的题解。顺便说一句，当 $m\ge n$ 的时候，它就是贝尔数。

毕竟是式子题，代码就不放了。

---

## 作者：NaCly_Fish (赞：31)

依然是《组合数学》上搬运的裸题（  
好了话不多说，下面是题解。  

****
$\text{I}$：  
没什么好说的，显然为 $m^n$。  

$\text{II}$：  
依次取球装进盒子，每次方案数都少一种，乘起来答案为 $m^{\underline n}$。  

$\text{III}$：  
这里要求盒子都非空，根据第二类 Stirling 数的定义，答案为 $\begin{Bmatrix} n \\ m \end{Bmatrix}m!$。  
这里顺便说一下第二类 Stirling 数的算法。  
选出 $k$ 个盒子非空，然后把 $n$ 个球装进去，这 $k$ 个盒子还可以随便排列，加起来得到：
$$m^n=\sum\limits_{k=0}^m\binom{m}{k}\begin{Bmatrix} n \\ k \end{Bmatrix}k!$$
二项式反演可得（其实就是容斥）：
$$\begin{Bmatrix} n \\ m \end{Bmatrix}=\frac{1}{m!}\sum\limits_{k=0}^m\binom{m}{k}(-1)^{m-k}k^n$$
$$=\sum\limits_{k=0}^m\frac{k^n}{k!}\times\frac{(-1)^{m-k}}{(m-k)!}$$

$\text{IV}$：   
根据 $\text{III}$ 的式子，直接卷积计算出 $n$ 固定的所有第二类 Stirling 数，显然加起来就是答案。


$\text{V}$：   
这个就是来搞笑的，，由于盒子相同且最多放一个球，无论怎么装，都可以排列盒子得到同一种方案，所以答案为 $[n \leqslant m]$。

$\text{VI}$：  
第二类 Stirling 数就是这么定义的，不用我说什么了吧。 

$\text{VII}$：   
现在球都相同，每个盒子都只看球的数量。  
每个盒子装进任意个球都只有一种方案，生成函数为 $\frac{1}{1-x}$。  
于是答案为：  
$$[x^n]\left( \frac{1}{1-x} \right)^m=\binom{n+m-1}{n}$$

$\text{VIII}$：  
从 $m$ 个盒子里面选出 $n$ 个来装球，答案自然为 $\binom{m}{n}$。

$\text{IX}$:  
每个盒子都至少装一个了，方案的生成函数就变为 $\frac{x}{1-x}$。   
$$[x^n]\left( \frac{x}{1-x} \right)^m=\binom{n-1}{m-1}$$

$\text{X}$:  
~~前面都是基础，下面才是重点~~  

由于球与盒子都没有区分，不难想到将其等价为分拆数的问题：  
> 将 $n$ 拆分为 $m$ 个无序的正整数的方案数 $p(n,m)$

直接做好像很难，这里引入一个叫 Ferrers 图的东西。  

一个分拆的 Ferrers 图，是把分拆出的每一项，用点（或方格）组成的行来表示。一般分拆写为递减正整数和，所以 Ferrers 图也用长度递减的行来表示。  

很容易发现，Ferrers 图与分拆之间是一一对应的。  
如 $12$ 的一个分拆 $12=5+4+2+1$ 的 Ferrers 图如下：  
（不要吐槽为什么没居中）
$$\quad\quad\quad\ \ \  \ \bullet \ \bullet \ \bullet \ \bullet \ \bullet$$
$$\quad\quad\quad \bullet \ \bullet \ \bullet \ \ \bullet$$
$$\ \ \ \ \bullet \ \ \bullet$$
$$\bullet$$
通过读它的列，得到的 Ferrers 图与原图互为**共轭**：
$$\quad\quad\quad \bullet \ \bullet \ \bullet \ \ \bullet$$
$$\quad \quad \bullet \ \bullet \ \bullet$$
$$\ \ \ \ \bullet \ \ \bullet$$
$$\ \ \ \ \bullet \ \ \bullet$$
$$\bullet$$
那么对于所有行数不超过 $m$ 的 Ferrers 图，对应的都有一个列数不超过 $m$ 的共轭图。  
由此直接引出如下定理：  
> 将 $n$ 拆分为若干个不超过 $m$ 的正整数的方案数等于 $p(n,m)$。  

然后得到 $p(n,m)$ 的计算方法：  
$$p(n,m)=[x^{n-m}]\prod_{i=1}^m\frac{1}{1-x^i}$$  
由于要求是正整数不太好搞，先给每个盒子分配一个球，就化为了拆分成自然数。  
这是个经典形式，多项式 $\exp$ 解决。  
因为这里要拆分成自然数，不用提前分配，所以答案要取上面那个多项式的 $n$ 次项，而非 $n-m$。

$\text{XI}$：  
同 $\text V$，答案为 $[n \leqslant m]$。

$\text{XII}$：  
显然等于 $p(n,m)$。
***
总时间复杂度为 $\Theta(n\log n)$（这里认为 $n,m$ 同阶）。  
参考代码：
```cpp
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 524293
#define p 998244353
#define ll long long
#define reg register
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
using namespace std;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

struct poly{
    int a[N];
    int t;
    inline int operator [] (const int& x) const{ return a[x]; }
    inline int& operator [] (const int& x){ return a[x]; }
};

int rev[N],rt[N],inv[N],fac[N],ifac[N],pw[N],pr[N>>1];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    inv[1] = rt[lim>>1] = 1;
    w = power(3,(p-1)>>siz);
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=lim;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
}

inline int getlen(int n){
	return 1<<(32-__builtin_clz(n));
}

inline void NTT(poly &f,int type,int lim){
    if(type==1) reverse(f.a+1,f.a+lim);
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]-x+p;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
    if(type==1) return;
    x = inv[lim];
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

poly inverse(poly f){
	poly g,h,q;
	memset(g.a,0,sizeof(g.a));
	int lim = 1,n = f.t,top = 0;
	int s[30];
	while(n){
		s[++top] = n;
		n >>= 1;
	}
	g[0] = power(f[0],p-2);
	while(top--){
		g.t = n = s[top+1];
		while(lim<=(n<<1)) lim <<= 1;
		memcpy(h.a,f.a,(n+1)<<2);
		memcpy(q.a,g.a,(n+1)<<2);
		memset(h.a+n+1,0,(lim-n)<<2);
		NTT(g,1,lim),NTT(h,1,lim);
		for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*g[i]%p*h[i]%p;
		NTT(g,-1,lim);
		for(reg int i=0;i<=n;++i) g[i] = dec(add(q[i],q[i]),g[i]);
		memset(g.a+n+1,0,(lim-n)<<2);
	}
	return g;
} 

inline poly deriv(poly f){
	for(reg int i=0;i!=f.t;++i) f[i] = (ll)f[i+1]*(i+1)%p;
	f[f.t] = 0;
	return f;
}

inline poly integ(poly f){
	for(reg int i=f.t;i;--i) f[i] = (ll)f[i-1]*inv[i]%p;
	f[0] = 0;
	return f;
}

inline poly log(poly f){
	poly g = inverse(f);
	f = deriv(f);
	int lim = getlen(f.t<<1);
	NTT(f,1,lim),NTT(g,1,lim);
	for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
	NTT(f,-1,lim);
	memset(f.a+f.t+1,0,(lim-f.t)<<2);
	return integ(f);
}

poly exp(poly f){
	poly g,h;
	memset(g.a,0,sizeof(g.a));
	int n = f.t,lim = 1,top = 0;
	int s[30];
	while(n){
		s[++top] = n;
		n >>= 1;
	}
	g[0] = 1;
	while(top--){
		g.t = n = s[top+1];
		while(lim<=(n<<1)) lim <<= 1;
		memcpy(h.a,g.a,(n+1)<<2);
		memset(h.a+n+1,0,(lim-n)<<2);
		g = log(g);
		for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
		g[0] = add(g[0],1);
		NTT(g,1,lim),NTT(h,1,lim);
		for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
		NTT(g,-1,lim);
		memset(g.a+n+1,0,(lim-n)<<2);
	}
	return g;
}

inline int C(int n,int m){
    if(n<m) return 0;
    return (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;
}

inline int A(int n,int m){
    if(n<m) return 0;
    return (ll)fac[n]*ifac[n-m]%p;
}

void sieve(int lim,int k){
    int cnt = 0;
    pw[1] = 1;
    for(reg int i=2;i<=lim;++i){
        if(!pw[i]){
            pr[++cnt] = i;
            pw[i] = power(i,k);
        }
        for(reg int j=1;j<=cnt&&i*pr[j]<=lim;++j){
            pw[i*pr[j]] = (ll)pw[i]*pw[pr[j]]%p;
            if(i%pr[j]==0) break;
        }
    }
}

int n,m,lim,sum;
poly F,G;

int main(){
    scanf("%d%d",&n,&m);
    lim = max(n,m);
    sieve(lim,n);
    printf("%d\n",pw[m]); // I
    init(lim<<1);
    fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
    for(reg int i=2;i<=n+m;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[n+m] = power(fac[n+m],p-2);
    for(reg int i=n+m-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
    printf("%d\n",A(m,n)); // II
    for(reg int i=0;i<=n;++i){
        F[i] = (ll)pw[i]*ifac[i]%p;
        G[i] = (i&1)?p-ifac[i]:ifac[i];
    }
    lim = getlen(n<<1);
    NTT(F,1,lim),NTT(G,1,lim);
    for(reg int i=0;i!=lim;++i) F[i] = (ll)F[i]*G[i]%p;
    NTT(F,-1,lim);
    memset(F.a+n+1,0,(lim-n+2)<<2);
    printf("%lld\n",(ll)fac[m]*F[m]%p); // III
    for(reg int i=1;i<=m;++i) sum = add(sum,F[i]);
    printf("%d\n",sum); // IV
    printf("%d\n",n<=m); // V
    printf("%d\n",F[m]);  // VI
    printf("%d\n",C(n+m-1,n)); // VII
    printf("%d\n",C(m,n)); // VIII
    printf("%d\n",C(n-1,m-1)); // IX
	F.t = n;
	memset(F.a,0,sizeof(F.a));
	for(reg int i=1;i<=m;++i){
		for(reg int j=i;j<=n;j+=i)
			F[j] = add(F[j],inv[j/i]);
	}
	F = exp(F);
	printf("%d\n",F[n]); // X
	printf("%d\n",n<=m); // XI
	printf("%d\n",n<m?0:F[n-m]); // XII
	return 0;	
}
```

---

## 作者：Aleph1022 (赞：29)

写一篇纯 GF 题解！

## I

一个盒子是 $\mathrm e^z$，则
$$
\left[\frac{z^n}{n!}\right] \mathrm e^{mz} = m^n
$$

## II

一个盒子是 $1+z$，则
$$
\left[\frac{z^n}{n!}\right] (1+z)^m = n! \binom mn = m^{\underline n}
$$

## III

一个盒子是 $\mathrm e^z - 1$，则
$$
\begin{aligned}
\left[\frac{z^n}{n!}\right] (\mathrm e^z-1)^m
&= \left[\frac{z^n}{n!}\right] \sum\limits_{k=0}^m \binom mk \mathrm e^{kz} (-1)^{m-k} \\
&= \sum\limits_{k=0}^m \binom mk k^n (-1)^{m-k}
\end{aligned}
$$

## IV

所有空盒不可区分，而所有非空盒事实上被盒中的球的标号区分，则
$$
\begin{aligned}
\left[\frac{z^n}{n!}\right] \sum\limits_{k=0}^m \frac1{k!}(\mathrm e^z-1)^k
&= \left[\frac{z^n}{n!}\right] \sum\limits_{k=0}^m \frac1{k!} \sum\limits_{i=0}^k \binom ki \mathrm e^{iz} (-1)^{k-i} \\
&= \left[\frac{z^n}{n!}\right] \sum\limits_{i=0}^m \frac{\mathrm e^{iz}}{i!} \sum\limits_{k=i}^m \frac{(-1)^{k-i}}{(k-i)!} \\
&= \sum\limits_{i=0}^m \frac{i^n}{i!} \sum\limits_{k=0}^{m-i} \frac{(-1)^k}{k!}
\end{aligned}
$$

## V

$$
\left[\frac{z^n}{n!}\right] \sum\limits_{k=0}^m \frac1{k!}z^k
= [n\le m]
$$

## VI

$$
\begin{aligned}
\left[\frac{z^n}{n!}\right] \frac1{m!}(\mathrm e^z-1)^m
&= \left[\frac{z^n}{n!}\right] \frac1{m!}\sum\limits_{k=0}^m \binom mk \mathrm e^{kz} (-1)^{m-k} \\
&= \frac1{m!}\sum\limits_{k=0}^m \binom mk k^n (-1)^{m-k}
\end{aligned}
$$

## VII

一个盒子是 $\frac1{1-z}$，则
$$
[z^n] \frac1{(1-z)^m} = \binom{n+m-1}n
$$

## VIII

一个盒子是 $1+z$，则
$$
[z^n] (1+z)^m = \binom mn
$$

## IX

一个盒子是 $\frac z{1-z}$，则
$$
[z^n] \frac{z^m}{(1-z)^m} = \binom{n-1}{m-1}
$$

## X

令二元 GF
$$
F(z,q) = \prod\limits_{k\ge 0} \frac1{1-qz^k}
$$

那么
$$
F(z,q) = \frac1{1-q} F(z,qz)
$$

令 $F_m(z) = [q^m] F(z,q)$，则
$$
F_m(z) = \frac1{1-z^m} F_{m-1}(z)
$$

由于 $F_0(z)=1$，则
$$
F_m(z) = \prod\limits_{k=1}^m \frac1{1-z^k}
$$

故答案为
$$
[z^n] F_m(z)
$$

而
$$
\begin{aligned}
F_m(z) &= \prod\limits_{k=1}^m \frac1{1-z^k} \\
&= \exp\left[\sum\limits_{k=1}^m \ln \frac1{1-z^k}\right] \\
&= \exp\left[\sum\limits_{k=1}^m \sum\limits_{i\ge 1} \frac{z^{ki}}i\right]
\end{aligned}
$$

## XI

令二元 GF
$$
F(z,q) = \frac1{1-q}\frac1{1-qz}
$$

则
$$
[z^n q^m] F(z,q) = [n\le m]
$$

## XII

令二元 GF
$$
F(z,q) = \prod\limits_{k\ge 1} \frac1{1-qz^k}
$$

那么
$$
F(z,q) = \frac1{1-qz} F(z,qz)
$$

令 $F_m(z) = [q^m] F(z,q)$，则
$$
F_m(z) = \frac z{1-z^m} F_{m-1}(z)
$$

由于 $F_0(z)=1$，则
$$
F_m(z) = \prod\limits_{k=1}^m \frac z{1-z^k}
$$

故答案为
$$
[z^n] F_m(z)
$$

而
$$
\begin{aligned}
F_m(z) &= \prod\limits_{k=1}^m \frac z{1-z^k} \\
&= z^m \exp\left[\sum\limits_{k=1}^m \ln \frac1{1-z^k}\right] \\
&= z^m \exp\left[\sum\limits_{k=1}^m \sum\limits_{i\ge 1} \frac{z^{ki}}i\right]
\end{aligned}
$$

---

## 作者：Spasmodic (赞：7)

十二重计数法 ×

[刻刻帝](https://zh.moegirl.org.cn/%E6%97%B6%E5%B4%8E%E7%8B%82%E4%B8%89) 十二种子弹 √

![](https://cdn.luogu.com.cn/upload/image_hosting/s24cxv9g.png)

---

**以下复杂度均在已经预处理完逆元、阶乘逆元和阶乘的情况下计算。**

咋一股 [这玩意的味道](http://oeis.org/transforms2.html)。。。不过简单多了

1. 球之间互不相同，盒子之间互不相同。

显然是 $m^n$。复杂度 $O(\log n)$。

```cpp
ll Aleph(){return qpow(m,n);}
```

2. 球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。

一个一个放，所以是 $m^{\underline{n}}$。复杂度 $O(n)$。

```cpp
ll Bet(){
	ll ret=1;
	rep(i,m-n+1,m)ret=ret*i%P;
	return ret;
}
```

3. 球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。

对 1 考虑做容斥，所以答案是
$$
\sum_{i=0}^m(-1)^i\binom{m}{i}(m-i)^n
$$
复杂度 $O(m\log n)$。

另外你也可以考虑用斯特林数，答案就是 $\begin{Bmatrix}n\\m\end{Bmatrix}\times m!$，这里采用的是前面的做法。

```cpp
ll Gimel(){
	ll ret=0;
	rep(i,0,m)
		if(i&1)ret=(ret-C(m,i)*qpow(m-i,n)%P+P)%P;
		else ret=(ret+C(m,i)*qpow(m-i,n)%P)%P;
	return ret;
}
```

4. 球之间互不相同，盒子全部相同。

枚举非空盒子个数，所以是
$$
\sum_{i=1}^{m}\begin{Bmatrix}n\\i\end{Bmatrix}
$$
来一发 第二类斯特林数·行，求个前缀和即可。复杂度 $O(n\log n)-O(1)$（固定 $n$）。

```cpp
void Zaphkiel(){
	vec f(n+1),g(n+1);
	rep(i,0,n){
		f[i]=1ll*qpow(i,n)*invfac[i]%P;
		g[i]=invfac[i];
		if(i&1)g[i]=P-g[i];
	}
	S=mul(f,g,n<<1);
	S.resize(n+1);
}
ll Dalet(){
	ll ret=0;
	rep(i,1,min(m,n))ret=(ret+S[i])%P;
	return ret;
}
```

同时第三题的代码也可以简化为：

```cpp
ll Gimel(){return 1ll*(m>n?0:S[m])*fac[m]%P;}
```

5. 球之间互不相同，盒子全部相同，每个盒子至多装一个球。

显然是 $[n\le m]$​​。复杂度 $O(1)$​​。

```cpp
ll He(){return (n<=m);}
```



6. 球之间互不相同，盒子全部相同，每个盒子至少装一个球。

显然是 $\begin{Bmatrix}n\\m\end{Bmatrix}$，可以使用通项（不过也可以用 4 中算的整），复杂度 $O(n\log m)/O(n\log n)-O(1)$（固定 $n$）。

```cpp
ll Vav(){return S[m];}
```

7. 球全部相同，盒子之间互不相同。

小学奥数插板法可知为 $\dbinom{n+m-1}{m-1}$，复杂度 $O(1)$。

```cpp
ll Zayin(){return C(n+m-1,m-1);}
```

8. 球全部相同，盒子之间互不相同，每个盒子至多装一个球。

显然是 $\dbinom{m}{n}$，复杂度 $O(1)$。

```cpp
ll Het(){return C(m,n);}
```

9. 球全部相同，盒子之间互不相同，每个盒子至少装一个球。

小学奥数插板法可知为 $\dbinom{n-1}{m-1}$，复杂度 $O(1)$。

```cpp
ll Tet(){return C(n-1,m-1);}
```

10. 球全部相同，盒子全部相同。

本题唯一有点意思的东西。~~所以另外十一题放这干啥，搁这十二合一恶心人呢~~

考虑一个经典的 dp：$f_{i,j}$ 表示 $i$ 个球，$j$ 个盒子。那么容易得到
$$
f_{i,j}=f_{i,j-1}+f_{i-j,j}
$$
那么考虑设 $F_j(x)$ 为 $\{f_{i,j}\}_{i=0}^{\infty}$ 的 OGF，可得：
$$
\begin{aligned}
[x^i]F_j(x)&=[x^i]F_{j-1}(x)+[x^{i-j}]F_j(x)\\
F_j(x)&=F_{j-1}(x)+x^jF_j(x)\\
F_j(x)&=F_{j-1}(x)\frac{1}{1-x^j}\\
F_j(x)&=\prod_{i=1}^{j}\frac{1}{1-x^j}\\
\ln F_k(x)&=\sum_{i=1}^k\ln(1-x^i)\\
\ln F_k(x)&=\sum_{i=1}^k\sum_{j=1}^{\infty}\frac{x^{ij}}{j}
\end{aligned}
$$
暴力计算出 $\ln F_m(x)$ 对其求 exp 即可，复杂度 $O(n\log n)-O(1)$（固定 $m$）。

```cpp
void Zaphkiel(){
    ...
	rep(i,0,n)f[i]=0;
	rep(i,1,m)for(ll j=1;i*j<=n;j++)f[i*j]=(f[i*j]+inv[j])%P;
	getexp(f,F,n+1);
}
ll Yod(){return F[n];}
```

11. 球全部相同，盒子全部相同，每个盒子至多装一个球。

显然是 $[n\le m]$。复杂度 $O(1)$。

```cpp
ll Yod_Alef(){return (n<=m);}
```

12. 球全部相同，盒子全部相同，每个盒子至少装一个球。

每个盒子扔掉一个球就变成了 10。复杂度 $O(n\log n)-O(1)$（固定 $m$​）。

```cpp
ll Yod_Bet(){return n<m?0:F[n-m];}
```

最后缝合一下就是完整代码了，如下：

```cpp
// Problem: P5824 十二重计数法
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5824
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define endl '\n' 
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define Rep(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
typedef long long ll;
inline void chkmax(ll &x,ll y){if(x<y)x=y;}
inline void chkmin(ll &x,ll y){if(x>y)x=y;}
struct IO_Tp {
    const static int _I_Buffer_Size = 2 << 22;
    char _I_Buffer[_I_Buffer_Size], *_I_pos = _I_Buffer;

    const static int _O_Buffer_Size = 2 << 22;
    char _O_Buffer[_O_Buffer_Size], *_O_pos = _O_Buffer;

    IO_Tp() { fread(_I_Buffer, 1, _I_Buffer_Size, stdin); }
    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }

    IO_Tp &operator>>(ll &res) {
    	ll f=1;
        while (!isdigit(*_I_pos)&&(*_I_pos)!='-') ++_I_pos;
        if(*_I_pos=='-')f=-1,++_I_pos;
        res = *_I_pos++ - '0';
        while (isdigit(*_I_pos)) res = res * 10 + (*_I_pos++ - '0');
        res*=f;
        return *this;
    }

    IO_Tp &operator<<(ll n) {
    	if(n<0)*_O_pos++='-',n=-n;
        static char _buf[10];
        char *_pos = _buf;
        do
            *_pos++ = '0' + n % 10;
        while (n /= 10);
        while (_pos != _buf) *_O_pos++ = *--_pos;
        return *this;
    }

    IO_Tp &operator<<(char ch) {
        *_O_pos++ = ch;
        return *this;
    }
} IO;
ll n,m;
typedef vector<int> vec;
const int N=4194304,P=998244353;
int inv[N],fac[N],invfac[N],pw[N];
namespace Poly{
    const int G=3,img=86583718;
    int lmt,rev[N];
	inline int qpow(int a,int k){
		int ret=1;
		while(k){
			if(k&1)ret=1LL*ret*a%P;
			a=1LL*a*a%P;
			k>>=1;
		}
		return ret%P;
	}
	inline void init(int n){
		lmt=1;int t=0;
		while(lmt<n)lmt<<=1,t++;
		for(int i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(t-1);
	}
	inline void NTT(vec&A,int lmt,int tp){
		if(A.size()<lmt)A.resize(lmt);
        for(int i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
        for(int m=1,t=0;m<lmt;m<<=1,t++)
            for(int j=0,Wn=pw[t+1];j<lmt;j+=m<<1)
                for(int k=0,w=1,x,y;k<m;k++,w=1LL*w*Wn%P)
                    x=A[j+k],y=1LL*w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
        if(tp==1)return;
        reverse(A.begin()+1,A.begin()+lmt);
        for(int i=0,inv=qpow(lmt,P-2);i<lmt;i++)A[i]=1LL*A[i]*inv%P;
    } 
	vec mul(vec f,vec g,int len){
		init(len);
		f.resize(lmt),g.resize(lmt);
		NTT(f,lmt,1);NTT(g,lmt,1);
		for(int i=0;i<lmt;i++)f[i]=1LL*f[i]*g[i]%P;
		NTT(f,lmt,-1);
		return f;
	} 
	void getinv(vec&f,vec&g,int len){
		if(f.size()<(len<<2))f.resize(len<<2);
		if(g.size()<(len<<2))g.resize(len<<2);
		if(len==1){g[0]=qpow(f[0],P-2);return;}
		getinv(f,g,len+1>>1);
		init(len<<1);
		vec c(lmt);
		copy(f.begin(),f.begin()+len,c.begin());
		NTT(c,lmt,1),NTT(g,lmt,1);
		for(int i=0;i<lmt;i++)g[i]=1LL*(2LL-1LL*g[i]*c[i]%P+P)%P*g[i]%P;
		NTT(g,lmt,-1);
		for(int i=len;i<lmt;i++)g[i]=0;
	}
	vec getdev(vec f,int len){
		vec g(len-1);
		for(int i=1;i<len;i++)g[i-1]=1LL*i*f[i]%P;
		return g;
	}
	vec getinvdev(vec f,int len){
		vec g(len+1);
		for(int i=1;i<len;i++)g[i]=1LL*f[i-1]*inv[i]%P;
		return g;
	}
	vec getln(vec f,int len){
		vec a=getdev(f,len),b;
		getinv(f,b,len);
		return getinvdev(mul(a,b,len<<1),len);
	}
	void getexp(vec f,vec&g,int len){
		if(g.size()<(len<<2))g.resize(len<<2);
		if(len==1){g[0]=1;return;}
		getexp(f,g,len+1>>1);
		init(len<<1);
		vec d=getln(g,len),e(f.begin(),f.begin()+len);
	    NTT(g,lmt,1),NTT(d,lmt,1),NTT(e,lmt,1);
    	for(int i=0;i<lmt;i++)g[i]=1LL*(1-d[i]+e[i]+P)*g[i]%P;
    	NTT(g,lmt,-1);
    	for(int i=len;i<lmt;i++)g[i]=0;
	}
	vec getpow(vec f,int len,int k){
		vec g(len),h=getln(f,len);
		for(int i=0;i<len;i++)h[i]=1LL*h[i]*k%P;
		getexp(h,g,len);
		return g;
	}
}
using namespace Poly;
vec S,F;
int Kurumi(int n){
    int lmt=1;
    inv[0]=inv[1]=1;
    while(lmt<n)lmt<<=1;
    for(int i=2;i<lmt;i++)inv[i]=1LL*(P-P/i)*inv[P%i]%P;
    fac[0]=invfac[0]=1;
    for(int i=1;i<lmt;i++)fac[i]=1LL*fac[i-1]*i%P,invfac[i]=1LL*invfac[i-1]*inv[i]%P;
    pw[23]=Poly::qpow(Poly::G,119);
    for(int i=22;i>=0;i--)pw[i]=1LL*pw[i+1]*pw[i+1]%P;
    return lmt;
}
ll C(ll n,ll m){return 1ll*fac[n]*invfac[m]%P*invfac[n-m]%P;}
void Zaphkiel(){
	vec f(n+1),g(n+1);
	rep(i,0,n){
		f[i]=1ll*qpow(i,n)*invfac[i]%P;
		g[i]=invfac[i];
		if(i&1)g[i]=P-g[i];
	}
	S=mul(f,g,n<<1);
	S.resize(n+1);
	rep(i,0,n)f[i]=0;
	rep(i,1,m)for(ll j=1;i*j<=n;j++)f[i*j]=(f[i*j]+inv[j])%P;
	getexp(f,F,n+1);
}
ll Aleph(){return qpow(m,n);}
ll Bet(){
	ll ret=1;
	rep(i,m-n+1,m)ret=ret*i%P;
	return ret;
}
ll Gimel(){return 1ll*(m>n?0:S[m])*fac[m]%P;}
ll Dalet(){
	ll ret=0;
	rep(i,1,min(m,n))ret=(ret+S[i])%P;
	return ret;
}
ll He(){return (n<=m);}
ll Vav(){return m>n?0:S[m];}
ll Zayin(){return C(n+m-1,m-1);}
ll Het(){return C(m,n);}
ll Tet(){return C(n-1,m-1);}
ll Yod(){return F[n];}
ll Yod_Alef(){return (n<=m);}
ll Yod_Bet(){return n<m?0:F[n-m];}
int main(){
	IO>>n>>m;
	Kurumi(n+m<<1);
	Zaphkiel();
	IO<<Aleph()<<endl;
	IO<<Bet()<<endl;
	IO<<Gimel()<<endl;
	IO<<Dalet()<<endl;
	IO<<He()<<endl;
	IO<<Vav()<<endl;
	IO<<Zayin()<<endl;
	IO<<Het()<<endl;
	IO<<Tet()<<endl;
	IO<<Yod()<<endl;
	IO<<Yod_Alef()<<endl;
	IO<<Yod_Bet()<<endl;
	return 0;
}


```

最后，简单讲一下这题和 more transformations of integer sequences 的关系（不知道的人可以看下 rqy 课件，或者[这里](https://www.cnblogs.com/happydef/p/poly3.html#21-%E6%95%B0%E5%88%97%E7%9A%84%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2)也可以）：

1. $\operatorname{AIJ}_m(a)$，其中 $a_x=1,\forall x$。
2. $\operatorname{AIJ}_m(a)$，其中 $a_1=1,a_x=0,x>1$。
3. $\operatorname{AIJ}_m(a)$，其中 $a_1=0,a_x=1,x>1$。
4. $\operatorname{AIK}_m(a)$，其中 $a_x=1,\forall x$。
5. $\operatorname{AIK}_m(a)$，其中 $a_1=1,a_x=0,x>1$。
6. $\operatorname{AIK}_m(a)$，其中 $a_x=0,a_x=1,x>1$。
7. $\operatorname{EIJ}_m(a)$，其中 $a_x=1,\forall x$。
8. $\operatorname{EIJ}_m(a)$，其中 $a_1=1,a_x=0,x>1$。
9. $\operatorname{EIJ}_m(a)$，其中 $a_x=0,a_x=1,x>1$。
10. $\operatorname{EIK}_m(a)$，其中 $a_x=1,\forall x$。
11. $\operatorname{EIK}_m(a)$，其中 $a_1=1,a_x=0,x>1$。
12. $\operatorname{EIK}_m(a)$，其中 $a_x=0,a_x=1,x>1$。

如以上有问题请指出，谢谢。

---

## 作者：xtx1092515503 (赞：7)

这里是一种与斯特林数无关的题解。（我才不会告诉你我是推式子时太蠢没有想到斯特林数呢）

# I.球之间互不相同，盒子之间互不相同

每个球可以有 $m$ 种放法，故答案为 $m^n$。

# II.球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。

我们第一个球有 $m$ 种放法，第二个有 $m-1$ 种，第三个有 $m-2$ 种……

于是你发现答案就是 $m^{\underline{n}}$。

# III.球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。

我们考虑容斥。

它就等于

$$(\text{钦定}0\text{个盒子强制空置的方案数})-(\text{钦定}1\text{个盒子强制空置的方案数})+\dots$$

即

$$\sum\limits_{i=0}^m(-1)^i(m-i)^n\dbinom{m}{i}$$

直接计算即可。

马上我们先跳过IV和V，看一下VI。

# VI.球之间互不相同，盒子全部相同，每个盒子至少装一个球。

我们发现如果假设盒子不同的话（即III），则不会出现任何相同的一对盒子（因为球都不同，又没有空盒子）；故实际上球的某组分配方式的所有**排列**都是不同的。所以这个的答案就直接是III的答案除以 $m!$。

然后再来看IV。

# IV.球之间互不相同，盒子全部相同。

我们发现IV可以借鉴VI的思路。即，我们枚举有多少个空盒子，然后剩下的就是VI了。

即，

$$\operatorname{IV}(n,m)=\sum\limits_{i=0}^m\operatorname{VI}(n,i)=\sum\limits_{i=0}^m\dfrac{\operatorname{III}(n,i)}{i!}=\sum\limits_{i=0}^m\dfrac{\sum\limits_{j=0}^i(-1)^j(i-j)^n\dbinom{i}{j}}{i!}$$

下面就开始推式子了。

$$\sum\limits_{i=0}^m\dfrac{\sum\limits_{j=0}^i(-1)^j(i-j)^n\dbinom{i}{j}}{i!}$$

我们拆开组合数，就会得到

$$\sum\limits_{i=0}^m\dfrac{\sum\limits_{j=0}^i(-1)^j(i-j)^n\dfrac{i!}{j!(i-j)!}}{i!}$$

然后约分得到

我们拆开组合数，就会得到

$$\sum\limits_{i=0}^m\sum\limits_{j=0}^i(-1)^j(i-j)^n\dfrac{1}{j!(i-j)!}$$

分离各项

$$\sum\limits_{i=0}^m\dfrac{(-1)^j}{j!}\sum\limits_{j=0}^i\dfrac{(i-j)^n}{(i-j)!}$$

改变枚举顺序

$$\sum\limits_{j=0}^m\dfrac{(-1)^j}{j!}\sum\limits_{i=j}^m\dfrac{(i-j)^n}{(i-j)!}$$

在内层换成枚举 $i-j$

$$\sum\limits_{j=0}^m\dfrac{(-1)^j}{j!}\sum\limits_{i=0}^{m-j}\dfrac{i^n}{i!}$$

完成！对于内层循环预处理前缀和即可做到 $O(n)$ 求出。

# V.球之间互不相同，盒子全部相同，每个盒子至多装一个球。

因为盒子全部相同，所以没啥好说的，就是 $[n\leq m]$。

# VII.球全部相同，盒子之间互不相同。

经典的小学奥数隔板法，答案即为

$$\dbinom{n+m-1}{m-1}$$

# VIII.球全部相同，盒子之间互不相同，每个盒子至多装一个球。

从 $m$ 个盒子中选出 $n$ 个放球，答案即为

$$\dbinom{m}{n}$$

# IX.球全部相同，盒子之间互不相同，每个盒子至少装一个球。

仍然是隔板法。

$$\dbinom{n-1}{m-1}$$

# X.球全部相同，盒子全部相同。

我们发现它就是[整数拆分问题](https://www.luogu.com.cn/problem/P1025)（虽然这题的数据范围较NOIP原题实在大了许多）。

整数拆分，我们可以DP，设 $f[i][j]$ 表示 $j$ 个数和为 $i$ 的方案数。则有转移式

$$f[i][j]=f[i-j][j]+f[i][j-1]$$

其中前一个是将当前序列中所有数全部加一，而后一个是在序列末尾添加一个 $0$。可以发现这么做可以生成所有的不增的拆分序列。

然后我们发现这实际上是对 $1,2,\dots,m$ 这所有的数做的一个完全背包问题。

然后就是[付公主的背包](https://www.luogu.com.cn/problem/P4389)，讲解可以参见本人的[生成函数学习笔记](https://www.luogu.com.cn/blog/Troverld/duo-xiang-shi-quan-jia-tong-sheng-cheng-han-shuo-xue-xi-bi-ji)或者自行翻阅题解。

# XI.球全部相同，盒子全部相同，每个盒子至多装一个球。

同V相同，仍是 $[n\leq m]$。

# XII.球全部相同，盒子全部相同，每个盒子至少装一个球。

我们事先往所有的盒子中扔一个球，这样就被转换成了X。

于是答案就是

$$\operatorname{X}(n-m,m)$$

[代码戳这儿](https://www.luogu.com.cn/record/37907519)

---

## 作者：gxy001 (赞：6)

做完这道题，感觉自己对计数的掌握又深了一些呢。

$\text{I}$：球互不相同，盒子互不相同。

显然，对于每个球都有 $m$ 种选择，根据乘法原理，答案即 $m^n$。

$\text{II}$：球互不相同，盒子互不相同，每个盒子至多装一个球。

对于每个球，可以从未被选择的盒子中任选一个，即 $\prod\limits_{i=0}^{n-1}(m-i)$。

$\text{III}$：球互不相同，盒子互不相同，每个盒子至少装一个球。 

容斥一下枚举几个空盒，$\sum\limits_{i=0}^m(-1)^i\binom{m}{i}(m-i)^n$。

$\text{IV}$：球互不相同，盒子全部相同。

枚举几个盒子有球，$\sum\limits_{i=0}^m \begin{Bmatrix}n\\i\end{Bmatrix}$，[第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395)。

$\text{V}$：球互不相同，盒子全部相同，每个盒子至多装一个球。 

由于盒子没有区别，所以答案为 $[n\le m]$。

$\text{VI}$：球互不相同，盒子全部相同，每个盒子至少装一个球。

根据斯特林数定义，$\begin{Bmatrix}n\\m\end{Bmatrix}$。

$\text{VII}$：球全部相同，盒子互不相同。

插板法，$\binom{n+m-1}{m-1}$。

$\text{VIII}$：球全部相同，盒子互不相同，每个盒子至多装一个球。 

选出 $n$ 个盒子装球，$\binom{m}{n}$

$\text{IX}$：球全部相同，盒子互不相同，每个盒子至少装一个球。 

插板法，$\binom{n-1}{m-1}$。

$\text{X}$：球全部相同，盒子全部相同。

问题等价于将 $n+m$ 拆分为 $m$ 个无序的正整数，根据 Ferrers 图的理论，等价于将 $n+m$ 拆分成若干个不超过 $m$ 的正整数，直接生成函数做就行了。

$$[x^{n+m-m}]\prod\limits_{i=1}^m\frac{1}{1-x^i}$$

不会求这个的可以去看[付公主的背包](https://www.luogu.com.cn/problem/P4389)。

$\text{XI}$：球全部相同，盒子全部相同，每个盒子至多装一个球。

和 $\text{V}$ 相同，盒子没有区别，$[n\le m]$。

$\text{XII}$：球全部相同，盒子全部相同，每个盒子至少装一个球。

同 $\text{X}$:

$$[x^{n-m}]\prod\limits_{i=1}^m\frac{1}{1-x^i}$$

### 代码

```cpp
#include<cstdio>
#include<algorithm>
int n,m,fac[400010],minv[400010];
int const mod=998244353,g=3,gi=(mod+1)/g;
int C(int x,int y){
	if(x<0||y<0||x<y) return 0;
	else return 1ll*fac[x]*minv[y]%mod*minv[x-y]%mod;
}
int pow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
struct NTT{
	int r[800010],lim;
	NTT():r(),lim(){}
	void getr(int lm){
		lim=lm;
		for(int i=0;i<lim;i++)r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));
	}
	void operator()(int *a,int type){
		for(int i=0;i<lim;i++)if(i<r[i])std::swap(a[i],a[r[i]]);
		for(int mid=1;mid<lim;mid<<=1){
			int rt=pow(type==1?g:gi,(mod-1)/(mid<<1));
			for(int j=0,r=mid<<1;j<lim;j+=r){
				int p=1;
				for(int k=0;k<mid;k++,p=1ll*p*rt%mod){
					int x=a[j+k],y=1ll*a[j+mid+k]*p%mod;
					a[j+k]=(x+y)%mod,a[j+mid+k]=(x-y+mod)%mod;
				}
			}
		}
		if(type==-1)for(int i=0,p=pow(lim,mod-2);i<lim;i++)a[i]=1ll*a[i]*p%mod;
	}
}ntt;
void inv(int const *a,int *ans,int n){
	static int tmp[800010];
	for(int i=0;i<n<<1;i++)tmp[i]=ans[i]=0;
	ans[0]=pow(a[0],mod-2);
	for(int m=2;m<=n;m<<=1){
		int lim=m<<1;
		ntt.getr(lim);
		for(int i=0;i<m;i++)tmp[i]=a[i];
		ntt(tmp,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=ans[i]*(2-1ll*ans[i]*tmp[i]%mod+mod)%mod,tmp[i]=0;
		ntt(ans,-1);
		for(int i=m;i<lim;i++)ans[i]=0;
	}
}
void inte(int const *a,int *ans,int n){
	for(int i=n-1;i;i--)ans[i]=1ll*a[i-1]*pow(i,mod-2)%mod;
	ans[0]=0;
}
void der(int const *a,int *ans,int n){
	for(int i=1;i<n;i++)ans[i-1]=1ll*i*a[i]%mod;
	ans[n-1]=0;
}
void ln(int const *a,int *ans,int n){
	static int b[800010];
	for(int i=0;i<n<<1;i++)ans[i]=b[i]=0;
	inv(a,ans,n);
	der(a,b,n);
	int lim=n<<1;
	ntt.getr(lim);
	ntt(b,1),ntt(ans,1);
	for(int i=0;i<lim;i++)b[i]=1ll*ans[i]*b[i]%mod,ans[i]=0;
	ntt(b,-1);
	for(int i=n;i<lim;i++)b[i]=0;
	inte(b,ans,n);
}
void exp(int const *a,int *ans,int n){
	static int f[800010];
	for(int i=0;i<n<<1;i++)ans[i]=f[i]=0;
	ans[0]=1;
	for(int m=2;m<=n;m<<=1){
		int lim=m<<1;
		ln(ans,f,m);
		f[0]=(a[0]+1-f[0]+mod)%mod;
		for(int i=1;i<m;i++)f[i]=(a[i]-f[i]+mod)%mod;
		ntt.getr(lim);
		ntt(f,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=1ll*ans[i]*f[i]%mod,f[i]=0;
		ntt(ans,-1);
		for(int i=m;i<lim;i++)ans[i]=0;
	}
}
void solve1(){printf("%d\n",pow(m,n));}
void solve2(){if(m<n)puts("0");else printf("%lld\n",1ll*fac[m]*minv[m-n]%mod);}
void solve3(){
	if(n<m)return puts("0"),void();
	int ans=0;
	for(int i=0;i<=m;i++)
		ans=(ans+1ll*pow(mod-1,i)*C(m,i)%mod*pow(m-i,n))%mod;
	printf("%d\n",ans);
}
int s[800010];
void solve4(){
	static int tmp[800010]; 
	for(int i=0;i<=n;i++)tmp[i]=(i&1?mod-1ll:1ll)*minv[i]%mod,s[i]=1ll*pow(i,n)*minv[i]%mod;
	int lim=1;
	for(lim=1;lim<=n+n;lim<<=1);
	ntt.getr(lim);
	ntt(tmp,1),ntt(s,1);
	for(int i=0;i<lim;i++)s[i]=1ll*s[i]*tmp[i]%mod;
	ntt(s,-1);
	for(int i=n+1;i<lim;i++)s[i]=0;
	int ans=0;
	for(int i=0;i<=m;i++)ans=(ans+s[i])%mod;
	printf("%d\n",ans);
}
void solve5(){printf("%d\n",int(m>=n));}
void solve6(){printf("%d\n",s[m]);}
void solve7(){printf("%d\n",C(n+m-1,m-1));}
void solve8(){printf("%d\n",C(m,n));}
void solve9(){printf("%d\n",C(n-1,m-1));}
int ans[800010];
void solve10(){
	static int tmp[800010];
	for(int i=1;i<=m;i++)
		for(int j=1;j*i<=n;j++)
			ans[i*j]=(ans[i*j]-1ll*minv[j]*fac[j-1]%mod+mod)%mod;
	int lim=1;
	for(;lim<=n;lim<<=1);
	exp(ans,tmp,lim);
	for(int i=0;i<lim;i++)ans[i]=0;
	inv(tmp,ans,lim);
	printf("%d\n",ans[n]);
}
void solve11(){printf("%d\n",int(m>=n));}
void solve12(){
	printf("%d\n",n-m>=0?ans[n-m]:0);
}
int main(){
	scanf("%d%d",&n,&m);
	fac[0]=1;
	for(int i=1;i<=n+m;i++)fac[i]=1ll*fac[i-1]*i%mod;
	minv[n+m]=pow(fac[n+m],mod-2);
	for(int i=n+m;i;i--)minv[i-1]=1ll*minv[i]*i%mod;
	solve1();
	solve2();
	solve3();
	solve4();
	solve5();
	solve6();
	solve7();
	solve8();
	solve9();
	solve10();
	solve11();
	solve12();
	return 0;
} 
```

---

## 作者：Warriors_Cat (赞：5)

[题面传送门](https://www.luogu.com.cn/problem/P5824)。

> 题意：$n$ 球 $m$ 盒，球要全部装进盒。球是否相同；盒是否相同；每个盒子内球个数 $\le 1$、$\ge 1$、无限制；共十二种情况均需讨论。

> $1 \le n, m\le 2\times 10^5$。

~~感觉自己做多项式和组合计数做上瘾了。~~

组合计数毒瘤题。

---

### $Solution:$

直接分类讨论：

$\mathrm{I}.$ **球不同，盒不同。**

每个球有 $m$ 种选择， $n$ 个球就有 $m^n$ 种选择。

$\mathrm{II}.$ **球不同，盒不同，每个盒至多装 $1$ 个球。**

相当于从 $m$ 个盒中选 $n$ 个盒再和球匹配，不难得到答案为：

$$\binom{m}{n}n! =\dfrac{m!}{(m-n)!}$$

其实这个东西也等价于 $A_m^n$。

$\mathrm{III}.$ **球不同，盒不同，每个盒至少装 $1$ 个球**。

考虑容斥。枚举空盒，然后剩下的随便填，答案即为：

$$\sum_{i=0}^m(-1)^i\binom{m}{i}(m-i)^n$$

$\mathrm{IV}.$ **球不同，盒相同。**

考虑第二类斯特林数  $\begin{Bmatrix}n\\m\end{Bmatrix}$ 的定义：$n$ 个不同球放进 $m$ 个非空盒的方案数。

考虑枚举有哪些盒装了球，直接第二类斯特林数即可，答案为：

$$\sum_{i=1}^m\begin{Bmatrix}n\\i\end{Bmatrix}$$

这个东西和 [第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395) 是一样的，这里也稍微说明一下。

根据第二类斯特林数的定义，显然有：

$$m^n = \sum_{i=0}^m\binom{m}{i}i!\begin{Bmatrix}n\\i\end{Bmatrix}$$

记 $f(x)=x^n$，$g(x)=x!\begin{Bmatrix}n\\x\end{Bmatrix}$，那么就有：

$$f(m)=\sum_{i=0}^m\binom{m}{i}g(i)$$

二项式反演一下就有：

$$g(m)=\sum_{i=0}^m(-1)^{m-i}\binom{m}{i}f(i)$$

$$m!\begin{Bmatrix}n\\m\end{Bmatrix}=\sum_{i=0}^m(-1)^{m-i}\binom{m}{i}i^n$$

$$\begin{Bmatrix}n\\m\end{Bmatrix}=\sum_{i=0}^m\dfrac{i^n}{i!}\cdot\dfrac{(-1)^{m-i}}{(m-i)!}$$

右边是个卷积的形式，所以可以在 $O(n\log n)$ 的时间内求出 $\begin{Bmatrix}n\\0\end{Bmatrix}, \begin{Bmatrix}n\\1\end{Bmatrix}....\begin{Bmatrix}n\\n\end{Bmatrix}$。

$\mathrm{V}.$ **球不同，盒相同，每个盒至多装 $1$ 个球。**

简单题，由于球放到哪个盒子都一样，所以答案为 $[n \le m]$。

$\mathrm{VI}.$ **球不同，盒相同，每个盒至少装 $1$ 个球。**

第二类斯特林数的定义，答案就是 $\begin{Bmatrix}n\\m\end{Bmatrix}$。

$\mathrm{VII}.$ **球相同，盒不同。**

考虑隔板法。这个东西相当于 $n$ 个相同球和 $m-1$ 个相同板排列方案数，答案就为 $\dbinom{n+m-1}{n}$。

$\mathrm{VIII}.$ **球相同，盒不同，每个盒子至多装 $1$ 个球。**

等价于选 $n$ 个盒子出来装球，答案即为 $\dbinom{m}{n}$。

$\mathrm{IX}.$ **球相同，盒不同，每个盒子至少装 $1$ 个球。**

还是隔板法。$n$ 个球先排成一排，中间有 $n-1$ 个空，其中要放 $m-1$ 个板，方案数就是 $\dbinom{n-1}{m-1}$。

$\mathrm{X}.$ **球相同，盒相同。**

最麻烦的部分了。

记 $f(n,m)$ 为 $n$ 个相同球放进 $m$ 个相同盒的方案数。

考虑这些盒中有没有空盒。如果有空盒就把空盒删掉，否则从每个盒中拿掉一个球，于是这个东西有递推式：

$$f(n, m)=f(n, m - 1)+f(n-m, m)$$

众所周知，刚入门的时候学过一个东西叫做完全背包。考虑一个小问题：$m$ 种东西，容积分别为 $v_i$，每种东西都有无限个，总容积为 $n$，问填满的方案数。这个东西显然有递推式：

$$f(n, m)=f(n, m - 1)+f(n-v_m, m)$$

跟上式对比一下，发现在这里就相当于 $v_i=i$ 的情况。

然后这个东西就是 [P4389 付公主的背包](https://www.luogu.com.cn/problem/P4389)，直接套这里的结论即可。

简单来说，构造生成函数 $g(k)=\sum\limits_{i=0}^\infty[i\mid k]x^i=\dfrac{1}{1-x^k}$。

然后再次构造生成函数：

$$F(x)=\sum_{n=0}^\infty f(n, m)x^n=\prod_{i=1}^m\dfrac{1}{1-x^i}$$

两边同时取对数：

$$\ln F(x)=\sum_{i=1}^m\ln\dfrac{1}{1-x^i}$$

又有 $\ln\dfrac{1}{1-x^i}=\sum\limits_{j=1}^\infty \dfrac{1}{j}x^{ij}$（[证明](https://www.luogu.com.cn/paste/a40u61wb)），可得：

$$\ln F(x)=\sum_{i=1}^m\sum_{j=1}^\infty\dfrac{1}{j}x^{ij}$$

在 $\bmod\ x^{n+1}$ 的意义下，右边这个东西可以 $O(n\log n)$ 求出来。

然后搞个多项式 exp 就知道 $F(x)$ 长什么样了。在这里即求 $[x^n]F(x)$。

$\mathrm{XI}.$ **球相同，盒相同，每个盒至多装 $1$ 个球。**

和 $\mathrm{V}.$ 是一样的，答案为 $[n \le m]$。

$\mathrm{XII.}$ **球相同，盒相同，每个盒至少装 $1$ 个球。**

先强制往每个盒放一个球，就和 $\mathrm{X.}$ 是一个东西了，这里答案为 $[x^{n-m}]F(x)$。

over，时间复杂度只有 $1\log$。

---

### $Code:$

代码较长，请耐心食用。

一千个人就有一千个多项式板子，这里省去多项式部分。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 600010, mod = 998244353, g_ = 3, invg = 332748118;
int n, m, fac[N], inv[N], ifac[N], e[N], r[N], rev, a[N], b[N], f[N], c[N], g[N], h[N], S[N], B[N], A[N]; bool isinv;
inline int fpow(int x, int p){ int ans = 1; for(; p; p >>= 1, x = 1ll * x * x % mod) if(p & 1) ans = 1ll * ans * x % mod; return ans; }
inline void clr(int *A, int x)
inline void cpy(int *A, int *B, int x)
inline void NTT(int typ, int *a, int lim)
inline void ptm(int *A, int *B, int len)
inline void print(int *A, int len)
inline void Polymul(int *A, int *B, int len, int m)
inline void Polyinv(int *A, int len)
inline void Polyder(int *A, int len)
inline void Polyint(int *A, int len)
inline void Polyln(int *A, int len)
inline void Polyexp(int *A, int len)
inline void initinv(){
	if(!isinv){
		isinv = 1; inv[0] = inv[1] = 1;
		rep(i, 2, N - 10) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
	}
}
inline void initfac(int n){
	fac[0] = 1;
	rep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % mod;
	ifac[n] = fpow(fac[n], mod - 2);
	per(i, n - 1, 0) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;
}
inline void prework(){
	initfac(n + m); initinv();
	rep(i, 0, n){
		S[i] = (i & 1) ? mod - ifac[i] : ifac[i];
		B[i] = 1ll * fpow(i, n) * ifac[i] % mod;
	}
	Polymul(S, B, n + 1 << 1, n + 1); 
	rep(i, 1, m) for(int j = i; j <= n; j += i) A[j] = (A[j] + inv[j / i]) % mod;
	Polyexp(A, n + 1);
}
inline int AA(int n, int m){ return n < m ? 0 : 1ll * fac[n] * ifac[n - m] % mod; }
inline int C(int n, int m){ return n < m ? 0 : 1ll * fac[n] * ifac[n - m] % mod * ifac[m] % mod; }
inline int sol1(){ return fpow(m, n); }
inline int sol2(){ return AA(m, n); } 
inline int sol3(){
	int ans = 0;
	rep(i, 0, m) ans = (ans + ((i & 1) ? mod - 1ll * C(m, i) * fpow(m - i, n) % mod : 1ll * C(m, i) * fpow(m - i, n) % mod)) % mod;
	return ans;
} 
inline int sol4(){ int ans = 0; rep(i, 1, m) ans = (ans + S[i]) % mod; return ans; }
inline int sol5(){ return n <= m; }
inline int sol6(){ return S[m]; }
inline int sol7(){ return C(n + m - 1, n); }
inline int sol8(){ return C(m, n); }
inline int sol9(){ return C(n - 1, m - 1); }
inline int sol10(){ return A[n]; }
inline int sol11(){ return n <= m; }
inline int sol12(){ return n < m ? 0 : A[n - m]; }
inline void mian(){
	n = read(); m = read(); prework();
	printf("%d\n%d\n%d\n%d\n", sol1(), sol2(), sol3(), sol4());
	printf("%d\n%d\n%d\n%d\n", sol5(), sol6(), sol7(), sol8());
	printf("%d\n%d\n%d\n%d\n", sol9(), sol10(), sol11(), sol12());
}
int main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---

## 作者：_quasar_ (赞：5)

前置知识：
- $O(n\log n)$ 求一行第二类斯特林数
- 多项式 $\exp$ 。

本题不建议写代码~~如果你很闲的话或者喜欢敲多项式板子的话当我没说~~

### Solve 1：

**Problem：**

球之间互不相同，盒子之间互不相同。

**Solution：**

相当于每个球选一个盒子：
$$
ans_1=m^n
$$

### Solve 2：

**Problem：**

球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。

**Solution：**

从 $m$ 个盒子中选出 $n$ 个盒子放球即可：
$$
ans_2={m\choose n}n!
$$

### Solve 3：

**Problem：**

球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。

**Solution：**

考虑容斥，枚举空盒子的个数：
$$
ans_3=\sum_{i=0}^{m}(-1)^{i}{m\choose i}(m-i)^n
$$

### Solve 4：

**Problem：**

球之间互不相同，盒子全部相同。

**Solution：**

枚举空盒子个数，剩下的就是第二类斯特林数：
$$
ans_4=\sum_{i=0}^{m-1}\begin{Bmatrix}n\\i\end{Bmatrix}
$$

### Solve 5：

**Problem：**

球之间互不相同，盒子全部相同，每个盒子至多装一个球。

**Solution：**

显然方案数是 $1$ （不过注意判断 $n,m$ 的大小
$$
ans_5=[n\leq m]
$$

### Solve 6：

**Problem：**

球之间互不相同，盒子全部相同，每个盒子至少装一个球。

**Solution：**

跟 **Solve 4** 差不多，因为没有空盒子，所以答案为：
$$
ans_6=\begin{Bmatrix}n\\m\end{Bmatrix}
$$

### Solve 7：

**Problem：**

球全部相同，盒子之间互不相同。

**Solution：**

只需要在意每个盒子的球个数了：
$$
ans_7={n+m-1\choose m-1}
$$

### Solve 8：

**Problem：**

球全部相同，盒子之间互不相同，每个盒子至多装一个球。

**Solution：**

盒子有标号，只需要在意哪些盒子有球即可：
$$
ans_8={m\choose n}
$$
球全部相同，盒子之间互不相同，每个盒子至多装一个球。

### Solve 9：

**Problem：**

球全部相同，盒子之间互不相同，每个盒子至少装一个球。

**Solution：**

也是插板法：
$$
ans_9={n-1\choose m-1}
$$

### Solve 10：

**Problem：**

球全部相同，盒子全部相同。

**Solution：**

定义 $f(n,m)$ 表示将整数 $n$ 划分成不超过 $m$ 个正整数的方案数。

考虑对"将其划分后的每个 $a_i$ 从大到小排序后"的不同局面个数计数，也就是统计的时候一定得满足每一个 $a_i$ 不比上一个大。

发现 $f$ 的转移可以往后面加一个 $0$，也可以全体加 $1$，容易发现这样是可以凑足所有方案的，即有转移：

$$
f(n,m)=f(n,m-1)+f(n-m,m)
$$

考虑令 $F_k(x)=\sum\limits_{i=0}^{\infty}  x^if(i,k)$，有：

$$
\begin{aligned}
F_m(x)&=F_{m-1}(x)+x^mF_m(x)\\
&=\frac{F_{m-1}(x)}{1-x^m}\\
\end{aligned}
$$

不难想到：

$$
\begin{aligned}
F_m(x)&=F(1)\prod_{i=2}^{m}\frac{1}{1-x^i}\\
&=\frac{1}{1-x}\prod_{i=2}^{m}\frac{1}{1-x^i}\\
&=\prod_{i=1}^{m}\frac{1}{1-x^i}\\
\end{aligned}
$$

大概和 付公主的背包 是一个套路吧，令 $G_k(x)=\frac{1}{1-x^k}$：

$$
\begin{aligned}
(\ln G_k(x))'&=\frac{G_k'(x)}{G_k(x)}\\
&=(1-x^k)G_k'(x)\\
&=(1-x^k)\left(\sum_{i\geq 0}(ik)x^{ik-1}\right)\\
&=\sum_{i\geq 1}(ik)x^{ik-1}-\sum_{i\geq 1}((i-1)k)x^{ik-1}\\
&=\sum_{i\geq 1}kx^{ik-1}\\
\end{aligned}
$$

又因为有：

$$
\begin{aligned}
F_m(x)&=\prod_{i=1}^{m}G_i(x)\\
\ln F_m(x)&=\sum_{i=1}^{m}\ln G_i(x)\\
(\ln F_m(x))'&=\left(\sum_{i=1}^{m}\ln G_i(x)\right)'\\
(\ln F_m(x))'&=\sum_{i=1}^{m}(\ln G_i(x))'\\
\end{aligned}
$$

容易发现求 $G_i$ 需要的复杂度是 $O(\lfloor\frac{n}{i}\rfloor)$ 的，求出所有的 $G_i$ 便是 $O(n\log n)$ 的。将 $G_i$ 相积分回来再 $\exp$ 即可。

### Solve 11：

**Problem：**

球全部相同，盒子全部相同，每个盒子至多装一个球。

**Solution：**

感觉像凑数的：
$$
ans_{11}=[n\leq m]
$$

### Solve 12：

**Problem：**

球全部相同，盒子全部相同，每个盒子至少装一个球。

**Solution：**

先给每个盒子一个球就好了：

$$
ans_{12}=P(n-m,m)
$$

---


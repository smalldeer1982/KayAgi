# 烯烃计数

## 题目背景

你可能需要：

+ [烷基计数](https://loj.ac/problem/6538)

+ [烷烃计数](https://loj.ac/problem/6512)

由于洛谷没有上面两个题，所以就弄了这个题。

## 题目描述

求化学式为 $\text{C}_n \text{H}_{2n}$ 的 **烯烃（乙烯的同系物）** 的同分异构体个数。

本题中不考虑空间异构和顺反异构。

答案对 $998244353$ 取模。

## 说明/提示

#### 样例 1 解释

+ $n=2$：乙烯。
+ $n=3$：丙烯。
+ $n=4$：1-丁烯；2-丁烯；2-甲基-1-丙烯。
+ $n=5$：1-戊烯；2-戊烯；2-甲基-1-丁烯；3-甲基-1-丁烯；2-甲基-2-丁烯。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n\le 100000$。


## 样例 #1

### 输入

```
5```

### 输出

```
1
1
3
5```

# 题解

## 作者：Zi_Gao (赞：7)

## 0x00 有机物

不会化学？没关系哦，我也不会。本人在化学月考和期中考试中分别获得了 37/100 和 61/100 的成绩。你只需要知道：

1. 键：链接两个原子的东西，对应 OI 中的边。XY 键就是连接 X 原子和 Y 原子的键，可以同时链几根键，变成 XY 双键、三键等。
2. 碳原子：必须要连 4 根键，不能连自己但是两个碳原子可以连多根键。
3. 氢原子：只能连 1 根键。
4. 烷烃：每个碳原子都连了 4 根键，所有的碳碳都是单键。实际上有环的也叫烷烃，但是这次我们只考虑链状烷烃，形态是 OI 里面的一棵树，那么烷烃的通式为 $C_{n}H_{2n+2}$。
5. 烷基：去掉一个碳的一个氢原子，烷基的通式为 $C_{n}H_{2n+1}$。
6. 烯烃：有一个碳碳双键，这两个碳原子又分别链接了两个烷基。
7. 同分异构体：有相同分子式，但是结构不同的有机物，对应 OI 中的无标号树同构问题。

## 0x01 烷基计数

想一下去掉了一个氢原子的那个碳给我们带来了什么？答案是，把一个无根树变成一个有根树。我们把这个有机物从这个没连接的碳键拎起来，那么这个无根树就变成了每个非叶子点都链接了三个儿子。

设 $F(x)$ 是答案的生成函数，考虑每次把三个儿子填进去的方案数，要考虑是否同构所以用 Burnside 引理。枚举 6 种置换：

1. $(1,2,3)$：三个置换环，三个都任意，答案 $xF^3(x)+1$。
2. $(1,3,2),(2,1,3),(3,2,1)$：有两个儿子相同，一个任意，答案 $3(xF(x^2)F(x)+1)$。
3. $(2,3,1),(3,1,2)$：三个都相同，答案 $2(xF(x^3)+1)$。

全部加起来取平均数：

$$
F(x)=\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))+1
$$

使用牛顿迭代求解，首先令

$$
G(x,F(x))=F(x)-\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))-1
$$

那么已知 $G(x,F(x))\equiv 0 \pmod{x^n}$，那么可知：

$$
F_1=F(x)-\frac{G(x,F(x))}{\frac{\partial G}{\partial F(x)}G(x,F(x))} \bmod{x^{2n}}
$$

注意这里的求导是形势求导，把 $F(x)$ 当做变量求导，$F(x^2),F(x^3)$ 都当做常量，整理一下：

$$
\begin{align}
F_1&=F(x)-\frac{F(x)-\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))-1}{1-\frac{x}{6}(3F^2(x)+3F(x^2))}\\
&=\frac{F(x)-\frac{x}{6}(3F^3(x)+3F(x^2)F(x))-F(x)+\frac{x}{6}(F^3(x)+3F(x^2)F(x)+2F(x^3))+1}{1-\frac{x}{6}(3F^2(x)+3F(x^2))}\\
&=\frac{1-\frac{x}{3}(F^3(x)-F(x^3))}{1-\frac{x}{2}(F^2(x)+F(x^2))}
\end{align}
$$

倍增迭代即可得到烷基计数的生成函数，我们记为 $A(x)$。

## 0x02 烯烃计数

从碳碳双键的地方把这个有机物拎起来，那么这两个碳原子再链接两个烷基就行，先用 Burnside 引理对一个碳原子进行计数：

$$
F(x)=x\frac{A^2(x)+A(x^2)}{2}
$$

继续用 Burnside 引理对两个碳原子进行计数：

$$
G(x)=\frac{F^2(x)+F(x^2)}{2}
$$

得到答案。

---

## 作者：9AC8E2 (赞：5)

感觉这题比烷烃计数水好多啊,只要会[烷基计数](https://loj.ac/problem/6538)就行
## 烯烃计数

已知碳原子个数 $n$，求对应的烯烃有多少种同分异构体

不考虑空间异构

### 题解

把碳-碳双键看作关键边,断开这条关键边,两边分别是一棵根节点的子节点个数 $\leq 2$ ,除根节点外子节点个数 $\leq 3$ 的无标号有根树

先用 $Burnside$ 引理求出这棵树的方案再合并即可

设 $n$ 个点的烷基计数的$OGF$为$A(x)$,要求的树的 $OGF$ 为 $P(x)$

$$P(x)=x\frac{A(x)^2+A(x^2)}{2}$$

设答案的 $OGF$ 为 $Q(x)$

$$Q(x)=\frac{(P(x)-1)^2+P(x^2)-1}{2}$$

同样,$-1$是因为$0$个点不能被算入方案

[代码](https://www.luogu.com.cn/paste/qvm2pjej)

---

## 作者：Anoshag_Ruwan (赞：3)

前天 whk 学到有机化学入门（~~但我有机不会~~），老师使用穷举法讲了如何数 $n≤7$ 时的烷烃计数、烷基计数，于是想到了个人数学题单里这道一直没动的题。就从难度低一些的烯烃计数开始吧。

## 烷基计数（$ -C_nH_{2n+1} $）

将失掉一个氢的碳作为根,$f$ 等价于非叶结点共 $n$ 个，每个非叶结点恰有 $3$ 个儿子的**无标号有根树计数**，设其生成函数为 $F(x)$ （$n=0$ 时 $f_n=1$，即单个氢原子）。

设想如果求的是**有标号有根树计数**，则答案显然为
 $F(x)=xF^3(x)+1$，可惜求的是无标号，也就是求通过随意交换 $3$ 棵子树位置后不能与另一种相同的，**本质不同的方案数**。

将**无标号计数**用这种方式描述，容易想到动用群论解决该问题。所求即在置换群 $G=$ {任意重排子树}下的**等价类数**，这里专业对口的是 **Burnside 定理**。

$|X/G|=\frac{1}{|G|}\sum\limits_{g∈G}|X^g|$

 $|X/G|$ 表示 $X$ 在作用于 $X$ 的置换群 $G$ 下的等价类数,$|X^g|$ 表示 $X$ 在置换 $g$ 作用下的稳定子数，关于群论基础知识和 Burnside 与 Põlya 定理推导可以参考[这道题下的神仙题解们](https://www.luogu.com.cn/problem/solution/P4980 )，（其实从群论零基础学到推导 burnside 和 põlya 也基本只是用一种新的角度看待常见的问题，并不恐怖）。

现在 $G$ 中有 6 种置换（就是排列），可以分为三类：

啥都不干 $\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix}$,此时所有有标号方案数都是稳定子，$F(x)=xF^3(x)+1$。

交换两个，第三个不动如 $\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}$，共 3 个，稳定子须满足至少2棵子树相同，$F(x)=xF(x)F(x^2)+1$。

全部移动位置如 $\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix}$，共 2 个，稳定子须满足 3 棵子树相同，$F(x)=xF(x^3)+1$。

代入原式求平均值，得到最终答案 $F(x)=x\frac{F^3(x)+3F(x)F(x^2)+2F(x^3)}{6}+1$。

对于这个吓人的式子，暴力分治 FFT 固然可行，但可以用更基础也更优的[多项式牛顿迭代法](https://www.cnblogs.com/lfri/p/9804801.html)为何不用呢（相信大家多项式求逆和多项式 exp 都写过吧）。

要求解的方程是 $x(F(x^3)+3F(x)F(x^2)+2F(x^3))+6-6F(x)=0$,
把已知 $n$ 阶近似 $x_n$ 求 $x_{n+1}$ 的过程转化成已知 $F(x)(\bmod$ $x^{k})$ 求 $F(x)(\bmod$ $x^{2k})$ 的过程再递归倍增求解，令 $H(x)$ 表示已知的 $F(x)$ 前半边,求导时可以把 $H(x^2)$ 和 $H(x^3)$ 都当成常数，对原方程求导再带进牛顿迭代的式子里，得到 $F(x)=H(x)-\frac{x(H^3(x)+3H(x^2)H^2(x)+2H(x^3))+6-6H(x)}{x(3H^2(x)+3H(x^2))-6} (\bmod$  $x^{2k})$ 就能~~不那么轻轻松松地~~实现了。

## 烯烃计数（$C_nH_{2n}$）

等价于这样一棵有根树：根节点为双键，第 $2$ 层 $2$ 个无标号子节点对应双键两边的碳，每个下面再连接 $2$ 个无标号烷基有根树（可以为单个氢）。

求出烷基的生成函数后，基本大功告成，现在只需要分 $2$ 层，使用同样方式处理，不过不需要牛顿迭代了，设 $G(x)$ 表示第 $2$ 层子树的生成函数，此时只有 $2$ 个子树，根据 burnside 定理，不难得出 $G(x)=x\frac{F(x^2)+F^2(x)}{2}$ (双键不能连单个氢，显然不能 $+1$ )，设答案的生成函数为 $E(x)$,注意双键本身不计入 $n$，不难得出 $E(x)=\frac{G(x^2)+G^2(x)}{2}$，Q.E.D。

代码如下
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int a1[500011],k1,q[500011],b1[500011],c[500011],p=998244353,b3[500011],b2[500011],c2[500011],c3[500011],c1[500011],r[500011];
int u[500011],dn[500011],fl,n;
inline int add(int x,int y){return x+y>=p?x+y-p:x+y;}
inline int minn(int x,int y){return x<y?x:y;}
inline void bter(){int i;
	for(i=0;i<k1;i++)r[i]=(r[i>>1]>>1)|(i&1?k1>>1:0);
} //处理蝴蝶变换数组 
inline int ksm(int x,int y){
	int k=1,l=x;if(x==1||y==1)return x;
	while(y){if(y&1)k=1ll*k*l%p;l=1ll*l*l%p,y>>=1;}
	return k;
}
inline void bz(int *f){int i,j;
	for(i=0,j=ksm(k1,p-2);i<k1;i++)f[i]=1ll*f[i]*j%p;
} //函数名随便写的,处理逆变换之后除以k1操作 
inline void ntt(int *f,bool m){
	int i,j,h,k,l;
	for(i=0;i<k1;i++)if(i<r[i])k=f[i],f[i]=f[r[i]],f[r[i]]=k;
	for(i=1;i<k1;i<<=1){
		l=ksm(m?3:332748118,(p-1)/(i<<1));
		for(j=q[0]=1;j<i;j++)q[j]=1ll*q[j-1]*l%p;//q数组是习惯性防卡常的，虽然这题不卡常 
		for(j=0;j<k1;j+=i<<1)
			for(h=j;h<j+i;h++)
				k=1ll*f[h+i]*q[h-j]%p,f[h+i]=add(f[h],p-k),f[h]=add(f[h],k);}
}
inline void dxsinv(int k,int *a,int *b){
	int i,j;
	if(k==1){b[0]=ksm(a[0],p-2);return;}
	dxsinv(k+1>>1,a,b);
	for(k1=1;k1<k<<1;k1<<=1);
	for(i=0;i<k;i++)c[i]=a[i];
	for(i=k;i<k1;i++)c[i]=0;
	for(i=k+1>>1;i<k1;i++)b[i]=0;
	bter();ntt(c,1);ntt(b,1);
	for(i=0;i<k1;i++)b[i]=1ll*b[i]*add(2,p-1ll*c[i]*b[i]%p)%p;
	ntt(b,0);bz(b);
}//多项式求逆 
inline void dxsane(int k,int *b){
	int i,j;if(k==1){b[0]=1;return;}
	dxsane(k+1>>1,b);
	memset(c1,0,sizeof(c1));memset(c2,0,sizeof(c2));memset(c,0,sizeof(c));
	for(i=0;i<k+1>>1;i++)
		c1[i<<1]=i<<1<k?b[i]:0,c2[i*3]=i*3<k?b[i]:0;
	for(k1=1;k1<k<<1;k1<<=1);
	for(i=k+1>>1;i<k1;i++)b[i]=0;
	bter();ntt(b,1);ntt(c1,1);ntt(c2,1);
	for(i=0;i<k1;i++)
		b2[i]=1ll*b[i]*b[i]%p,b3[i]=1ll*b2[i]*b[i]%p;//b2为F^2(x),b3为F^3(x),c1为F(x^2),c2为F(x^3) 
	for(i=0;i<k1;i++)
		u[i]=add(add(b3[i],c2[i]),add(c2[i],3ll*c1[i]*b[i]%p)),\
		dn[i]=add(3ll*b2[i]%p,3ll*c1[i]%p);
	ntt(u,0);ntt(dn,0);bz(u);bz(dn);
	for(i=k-1;i;i--)u[i]=u[i-1],dn[i]=dn[i-1];
	u[0]=6,dn[0]=p-6;
	for(i=k;i<k1;i++)u[i]=dn[i]=0;
	ntt(u,1);dxsinv(k,dn,c3);
	for(i=k;i<k1;i++)c3[i]=0;ntt(c3,1);
	for(i=0;i<k1;i++)
		u[i]=1ll*add(u[i],p-6ll*b[i]%p)*c3[i]%p,b[i]=add(b[i],p-u[i]);
	ntt(b,0);bz(b);
}//烷基计数 
inline void dxsene(){
	long long i,j,k;
	memset(c1,0,sizeof(c1));
	for(i=0;i<n+1>>1;i++)
		c1[i<<1]=i<<1<n?b1[i]:0; 
	for(k1=1;k1<n<<1;k1<<=1);
	for(i=n;i<k1;i++)b1[i]=c1[i]=0;
	bter();ntt(b1,1);ntt(c1,1);
	for(i=0;i<k1;i++)
		b1[i]=1ll*b1[i]*b1[i]%p,a1[i]=add(b1[i],c1[i]);
	ntt(a1,0);bz(a1);
	memset(c1,0,sizeof(c1));
	for(i=n-1;i;i--)
		a1[i]=1ll*a1[i-1]*499122177%p;a1[0]=0;
	for(i=n;i<k1;i++)a1[i]=0;//处理第2层 
	for(i=0;i<n+1>>1;i++)
		c1[i<<1]=i<<1<n?a1[i]:0; 
	for(i=n;i<k1;i++)a1[i]=c1[i]=0;
	bter();ntt(a1,1);ntt(c1,1);
	for(i=0;i<k1;i++)
		a1[i]=1ll*add(1ll*a1[i]*a1[i]%p,c1[i])*499122177%p;
	ntt(a1,0);bz(a1);//处理答案 
}//烯烃计数 
int main()
{
	int i,j,k,m;scanf("%d",&n);
	dxsane(++n,b1);
	dxsene();
	for(i=2;i<n;i++)printf("%d\n",a1[i]);
	return 0;
}
```
p.s. 跑了一遍后，发现 $n≥26$ 时答案就破 $10^9$ 了，所以 whk 试卷大抵是不会考 $n≥8$ 的情况的。

---

## 作者：gxy001 (赞：3)

## 烷基计数

求 $n$ 个点的每个点度数不超过 $4$ 且根的度数不超过 $3$ 的无标号有根树的数目。

设答案的 $\text{OGF}$ 为 $A(x)$，考虑根的子节点，使用 $\text {Burside}$ 引理得到：
$$
A(x)=x\frac{A(x)^3+3A(x^2)A(x)+2A(x^3)}{6}+1
$$
考虑牛顿迭代，设 $A_*(x)$ 为 $\bmod x^{\frac{n}{2}}$ 的答案。
$$
F(A(x))=x\frac{A(x)^3+3A(x^2)A(x)+2A(x^3)}{6}+1-A(x)=0\\
A(x)=A_*(x)-\frac{F(A_*(x))}{F'(A_*(x))}\pmod{x^n}\\
F'(A(x))=x\frac{A(x)^2+A(x^2)}{2}-1
$$

## 烯烃计数

断开碳-碳双键两边是根节点度数不超过 $2$，其他点子节点个数小于等于 $3$ 的无标号有根树。

这棵树的 $\text{OGF}$ 为 $P(x)$：
$$
P(x)=x\frac{A(x)^2+A(x^2)}{2}+1
$$
烯烃的 $\text{OGF}$ 为 $G(x)$：
$$
G(x)=x\frac{(P(x)-1)^2+P(x^2)-1}{2}
$$

```cpp
#include<cstdio>
#include<algorithm>
int const mod=998244353,g=3,gi=998244354/3,inv2=998244354/2,inv6=998244354/6,maxn=800010;
int pow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*x*res%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return res;
}
struct NTT{
	int r[maxn],lim;
	NTT():r(),lim(){}
	void getr(int const &li){
		lim=li;
		for(int i=0;i<lim;i++)r[i]=(r[i>>1]>>1)|((i&1)*(lim>>1));
	}
	void operator ()(int *a,int const &type)const{
		for(int i=0;i<lim;i++)if(i<r[i])std::swap(a[i],a[r[i]]);
		for(int mid=1;mid<lim;mid<<=1){
			int rt=pow(type==1?g:gi,(mod-1)/(mid<<1));
			for(int r=mid<<1,j=0;j<lim;j+=r){
				int p=1;
				for(int k=0;k<mid;k++,p=1ll*p*rt%mod){
					int x=a[j+k],y=1ll*p*a[j+k+mid]%mod;
					a[j+k]=(x+y)%mod,a[j+mid+k]=(x-y+mod)%mod;
				}
			}
		}
		if(type==-1)for(int p=pow(lim,mod-2),i=0;i<lim;i++)a[i]=1ll*a[i]*p%mod;
	}
}ntt;
void inv(int const *a,int *ans,int const &m){
	static int tmp[maxn];
	for(int i=0;i<m<<1;i++)tmp[i]=ans[i]=0;
	ans[0]=pow(a[0],mod-2);
	for(int n=2,lim;n<=m;n<<=1){
		for(int i=0;i<n;i++)tmp[i]=a[i];
		ntt.getr(lim=n<<1);
		ntt(tmp,1),ntt(ans,1);
		for(int i=0;i<lim;i++)ans[i]=ans[i]*(2-1ll*ans[i]*tmp[i]%mod+mod)%mod;
		ntt(ans,-1);
		for(int i=n;i<lim;i++)ans[i]=0;
	}
}
void solve(int *ans,int const &m){
	static int a3[maxn],a2[maxn],a1[maxn],fz[maxn],fm[maxn];
	ans[0]=1;
	for(int n=2,lim;n<=m;n<<=1){
		for(int i=0;i<n<<1;i++)a1[i]=a2[i]=a3[i]=fz[i]=fm[i]=0;
		for(int i=0;i<n;i++)a1[i]=ans[i];
		for(int i=0;i<n;i+=2)a2[i]=ans[i/2];
		for(int i=0;i<n;i+=3)a3[i]=ans[i/3];
		ntt.getr(lim=n<<2);
		ntt(a1,1);
		for(int i=0;i<lim;i++)a1[i]=1ll*a1[i]*a1[i]%mod*a1[i]%mod;
		ntt(a1,-1);
		for(int i=0;i<n;i++)fz[i]=a1[i],a1[i]=ans[i],fm[i]=a2[i];
		for(int i=n;i<lim;i++)a1[i]=0;
		ntt.getr(lim=n<<1);
		ntt(a1,1),ntt(a2,1);
		for(int i=0;i<lim;i++)a2[i]=1ll*a2[i]*a1[i]%mod,a1[i]=1ll*a1[i]*a1[i]%mod;
		ntt(a1,-1),ntt(a2,-1);
		for(int i=n-1;i;i--)fz[i]=(1ll*inv6*fz[i-1]+1ll*inv2*a2[i-1]+1ll*gi*a3[i-1])%mod;
		fz[0]=1;
		for(int i=0;i<n;i++)fz[i]=(fz[i]-ans[i]+mod)%mod;
		for(int i=n-1;i;i--)fm[i]=1ll*inv2*(a1[i-1]+fm[i-1])%mod;
		fm[0]=mod-1;
		for(int i=n;i<lim;i++)fz[i]=fm[i]=0;
		inv(fm,a1,n);
		ntt.getr(lim);
		ntt(a1,1),ntt(fz,1);
		for(int i=0;i<lim;i++)a1[i]=1ll*a1[i]*fz[i]%mod;
		ntt(a1,-1);
		for(int i=0;i<n;i++)ans[i]=(ans[i]-a1[i]+mod)%mod;
	}
}
int a[maxn],b[maxn],lim=1<<17;
int main(){
	solve(a,lim);
	for(int i=0;i<lim;i++)b[i]=a[i];
	for(int i=0;i<lim;i++)a[i]=0;
	for(int i=0;i<lim;i+=2)a[i]=b[i>>1];
	ntt.getr(lim<<1);
	ntt(b,1);
	for(int i=0;i<lim<<1;i++)b[i]=1ll*b[i]*b[i]%mod;
	ntt(b,-1);
	for(int i=lim-1;i;i--)a[i]=1ll*inv2*(a[i-1]+b[i-1])%mod;
	a[0]=0;
	for(int i=0;i<lim<<1;i++)b[i]=0;
	for(int i=0;i<lim;i+=2)b[i]=a[i>>1];
	ntt(a,1);
	for(int i=0;i<lim<<1;i++)a[i]=1ll*a[i]*a[i]%mod;
	ntt(a,-1);
	for(int i=lim-1;~i;i--)a[i]=1ll*inv2*(a[i]+b[i])%mod;
	int t;
	scanf("%d",&t);
	for(int i=2;i<=t;i++)printf("%d\n",a[i]);
	return 0;
}
```



---

## 作者：Arghariza (赞：1)

感谢 @[kkio](https://www.luogu.com.cn/user/343060) 的精彩讲解。

考虑把唯一的碳碳双键拉出来，忽略双键对面的那个碳，两边为 $1$ 位置上的碳相连了不超过 $2$ 个碳的烷基，即根节点儿子数 $\le$ 2，其余节点儿子数 $\le 3$ 的无标号有根树。设其生成函数为 $H(x)$，对双键旁边的两棵树进行无标号计数，施 Burnside 引理：

$$\text{Ans}(x)=\frac{H^2(x)-H(x^2)}{2}$$

可以 $O(n\log n)$ 卷积求出。

即若原本的 $(1,2)$ 置换后为 $(2,1)$，则不动点要求两边子树同构；否则任意即可。

考虑如何求 $H(x)$，假设我们求出烷基个数（即根节点儿子数 $\le 3$，其余节点儿子数 $\le 4$ 的无标号有根树个数）的生成函数 $F(x)$（假设 $0$ 个碳的烷基个数为 $1$，即 $[x^0]F(x)=1$），再用和刚才类似的 Burnside 讨论根的 $2$ 个儿子（允许有空）：

$$H(x)=x\frac{F^2(x)-F(x^2)}{2}$$

同样可以 $O(n\log n)$ 卷积求出。

于是问题转化为烷基计数，讨论根节点的 $3$ 个儿子，再施 Burnside 引理：

- $(1,2,3)\to (1,2,3)$，三棵子树任意选择即可，为 $F^3(x)$。
- $(1,2,3)\to (1,3,2)$，要求 $2,3$ 儿子子树同构，为 $F(x^2)F(x)$。
- $(1,2,3)\to (2,1,3)$，要求 $1,2$ 儿子子树同构，为 $F(x^2)F(x)$。
- $(1,2,3)\to (2,3,1)$，要求 $1,2,3$ 儿子子树同构，为 $F(x^3)$。
- $(1,2,3)\to (3,1,2)$，要求 $1,2,3$ 儿子子树同构，为 $F(x^3)$。
- $(1,2,3)\to (3,2,1)$，要求 $1,3$ 儿子子树同构，为 $F(x^2)F(x)$。

即：

$$F(x)=x\frac{F^3(x)+3F(x^2)F(x)+2F(x^3)}{6}+1$$

考虑牛顿迭代，令 $M=\left\lceil\frac{N}{2}\right\rceil$，注意到求出 $F_0(x)=F(x)\pmod{x^M}$ 时 $H_2,H_3=F(x^2),F(x^3)\pmod{x^N}$ 也已知，当作常数处理即可。最后应该是个类似这样的东西：

$$F\equiv \frac{1-\frac{x}{3}\left(F_0^3-H_3\right)}{1-\frac{x}{2}\left(F_0^2+H_2\right)}\pmod{x^N}$$

于是复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define eb emplace_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> pi;
typedef tuple<int, int, int> tu;
bool Mbe;

const int N = 1e6 + 5;
const int P = 998244353;
const int G = 114514;
const int i2 = (P + 1) / 2;
const int i3 = (P + 1) / 3;

int qpow(int p, int q) {
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

const int iG = qpow(G, P - 2);
typedef vector<int> poly;

void Get(int n, int &len, int &lim) {
	len = 1, lim = 0;
	while (len <= n) len <<= 1, lim++;
}

void Cpx(int *p, poly q, int len) {
	memset(p, 0, sizeof(int) * len);
	for (int i = 0; i < (int)q.size(); i++) p[i] = q[i];
}

void Cpy(poly &p, int *q, int len) {
	p.clear();
	for (int i = 0; i < len; i++) p.eb(q[i]);
}

void NTT(int *f, int op, int len, int lim) {
	static int tr[N];
	for (int i = 1; i < len; i++)
		tr[i] = (tr[i >> 1] >> 1) | ((i & 1) << (lim - 1));
	for (int i = 0; i < len; i++)
		if (i < tr[i]) swap(f[i], f[tr[i]]);
	for (int o = 2, k = 1; k < len; o <<= 1, k <<= 1) {
		int tG = qpow(op == 1 ? G : iG, (P - 1) / o);
		for (int i = 0; i < len; i += o) {
			for (int j = 0, w = 1; j < k; j++, w = 1ll * w * tG % P) {
				int x = f[i + j], y = 1ll * w * f[i + j + k] % P;
				f[i + j] = (x + y) % P, f[i + j + k] = (x - y + P) % P;
			}
		}
	}
	if (op == 1) return;
	int iv = qpow(len, P - 2);
	for (int i = 0; i < len; i++)
		f[i] = 1ll * f[i] * iv % P;
}

poly Add(poly x, poly y) {
	if (x.size() < y.size()) swap(x, y);
	for (int i = 0; i < (int)y.size(); i++) (x[i] += y[i]) %= P;
	return x;
}

poly Sub(poly x, poly y) {
    int fl = 0;
	if (x.size() < y.size()) swap(x, y), fl = 1;
	for (int i = 0; i < (int)y.size(); i++) (x[i] += P - y[i]) %= P;
    if (fl) for (int &i : x) if (i) i = P - i;
	return x;
}

poly Mul(poly x, poly y) {
	static int tx[N], ty[N]; int lx, ly, len, lim; poly res;
	lx = x.size(), ly = y.size();
	Get(lx + ly - 1, len, lim), Cpx(tx, x, len), Cpx(ty, y, len);
	NTT(tx, 1, len, lim), NTT(ty, 1, len, lim);
	for (int i = 0; i < len; i++) tx[i] = 1ll * tx[i] * ty[i] % P;
	NTT(tx, -1, len, lim), Cpy(res, tx, lx + ly - 1);
	return res;
}

poly Inv(poly x) {
	static int tx[N], ty[N]; int lx, ly, len, lim; poly res;
	if ((int)x.size() == 1) return poly { qpow(x[0], P - 2) };
	poly y; lx = x.size(), ly = (lx + 1) / 2;
	for (int i = 0; i < ly; i++) y.eb(x[i]); y = Inv(y);
	Get(lx << 1, len, lim), Cpx(tx, x, len), Cpx(ty, y, len);
	NTT(tx, 1, len, lim), NTT(ty, 1, len, lim);
	for (int i = 0; i < len; i++) ty[i] = 1ll * (2 - 1ll * tx[i] * ty[i] % P + P) % P * ty[i] % P;
	NTT(ty, -1, len, lim), Cpy(res, ty, lx);
	return res;
}

poly operator + (const poly x, const poly y) { return Add(x, y); }
poly operator - (const poly x, const poly y) { return Sub(x, y); }
poly operator * (const poly x, const poly y) { return Mul(x, y); }

poly Nt(int n) {
	if (n == 1) return poly { 1 };
    if (n == 2) return poly { 1, 1 };
	int m = (n + 1) / 2;
	poly f0 = Nt(m), h2, h3;
	h2.resize(n), h3.resize(n);
	for (int i = 0; i < n; i += 2) h2[i] = f0[i / 2];
	for (int i = 0; i < n; i += 3) h3[i] = f0[i / 3];
	poly p = (poly { 1 } - poly { 0, i3 } * (f0 * f0 * f0 - h3));
    poly q = (poly { 1 } - poly { 0, i2 } * (f0 * f0 + h2));
    p.resize(n), q.resize(n);
    poly res = p * Inv(q); res.resize(n);
	return res;
}

void solve() {
	int n; cin >> n;
    poly F = Nt(n + 1), G; G.resize(n + 1);
    for (int i = 0; i <= n; i += 2) G[i] = F[i / 2];
    poly H = poly { 0, i2 } * (F * F + G), H2; H.resize(n + 1), H2.resize(n + 1); 
    for (int i = 0; i <= n; i += 2) H2[i] = H[i / 2];
    poly res = poly { i2 } * (H * H + H2);
    for (int i = 2; i <= n; i++) cout << res[i] << '\n';
}

bool Med;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen(".in", "r", stdin);
		freopen(".out", "w", stdout);
	#endif
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：XYQ_102 (赞：0)

## 烯烃计数

题目链接：[洛谷 P6597 烯烃计数](https://www.luogu.com.cn/problem/P6597)。

对于 $n=1\sim N$，求 $n$ 个碳原子的烯烃的同分异构体数，不考虑空间异构。

$1\le N\le 10^5$。

## 题解

考虑碳碳双键的这条“关建边”，相当于这条边左右两边分别做“烷基计数”，然后再合并起来。

因此，合并的部分再用一次 Burnside 引理。令 $G(x)$ 表示答案，则：

$$G(x)=\frac{(F(x)-1)^2+F(x^2)-1}{2}$$

时间复杂度 $\mathcal O(n\log n)$。

---


# 「C.E.L.U-03」布尔

## 题目描述

给你 $n$ 个布尔变量和 $m$ 个限制，设 $s_i$ 为 $i$ 的取值。第 $i$ 个限制形如 $s_{u_i}$ 为 $x_i$ 则 $s_{v_i}$ 必须为 $y_i$，同时如果 $s_{v_i}$ 为 $y_i$ 则 $s_{u_i}$ 必须取 $x_i$。  
一共 $q$ 次询问，每次询问给出一个区间 $l,r$。求最少把 $l,r$ 划分成多少段连续的区间，使得每段里的限制都可以得到一组合法解。如果无论如何都无法得到合法解，输出 `-1`。

## 说明/提示

**样例解释一**   
对于第一个询问，可以分成 $[1,2]$ 和 $3$ 两段。  
对于第二个询问，分成 $[3,4]$  一段。  

**样例解释二**   
对于第一个询问，分成 $[1,4]$  一段。  
对于第二个询问，可以分成 $[2,3]$ 和 $[4,5]$ 两段。  
对于第三个询问，分成 $[3,5]$  一段。  

| 数据编号| $n\leq$ | $m\leq$| $q\leq$|
|:---:|:---:|:---:|:---:|
|$1$|$30$|$100$|$300$|
|$2\sim 4$|$300$|$10^3$|$10^3$|
|$5\sim 7$|$10^4$|$5\times10^4$|$10^6$|  
|$8\sim 10$|$10^5$|$6\times10^5$|$10^6$|   

对于 $100\%$ 的数据，$1\le n\le10^5,1\le m\le6\times10^5,1\le q\le10^6,1\le u,v\le n,1\le l\le r\le m,x,y\in \{0,1\}$

## 样例 #1

### 输入

```
3 4 2
1 0 2 0
1 1 3 0
3 0 2 0
1 1 2 1
1 3
3 4```

### 输出

```
2
1```

## 样例 #2

### 输入

```
4 5 3
1 1 2 1
2 0 3 0
4 1 1 0
2 1 4 0
4 0 3 0
1 4
2 5
3 5```

### 输出

```
1
2
1```

# 题解

## 作者：abruce (赞：19)

简要题意：问区间能最少划分成段，每一段 2-SAT 判断为 $1$。  
### 10~40pts  
很明显需要维护一个 $f$ 数组，$f_i=k$ 代表 $[i,k]$ 这段区间非法且 $k$ 最小，然后用倍增跳。直接对于每个 $i$ 暴力求出 $f_i$ 即可。  
求的方法是用 2-SAT，每次 $u\rightarrow v,v\rightarrow u,u'\rightarrow v',v'\rightarrow u'$。  
当然由于连的是双向边可以把 tarjan 换成并查集。  
## 100pts  
进行分析，发现 $f$ 数组具有决策单调性。简要证明一下：我们考虑从右往左看，每次会新加入一条边，也就更有可能在更近的地方非法，而且不可能在更远的地方达到第一个非法点，所以 $f_i\le f_j(i<j)$。二分单调队列/单调栈很明显不好维护这个信息，我们考虑用整体二分去求。  
定义 $cal(l,r,L,R)$ 代表当前是 $l,r$ 区间，$f_i\in [L,R](i\in [l,r])$。递归时往 $cal(l,mid-1,L,f_{mid})$ 和 $cal(mid+1,r,f_{mid},R)$ 这样就可以用一个并查集进行撤销和继承。  
求 $f_{mid}$ 的时候从 $L$ 开始一直加边，加到非法为止。注意有可能加到末尾依然合法，需要特判。  
非法的判定可以用加边后 $u,u'$ 是否连通来判断。考虑反证法，若存在 $w,w'$ 在加边后连通，且 $u,u'$ 不连通，那么 $w,w'$ 分别与 $u$ 和 $v$ 或者 $u'$ 和 $v'$ 连通。根据我们的连边方式，若 $u,v$ 连通则 $u',v'$ 连通。所以 $u,u'$ 连通。  
时间复杂度 $O(m\log m\log n+q\log m)$。具体实现可以看代码。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6e5+5,maxm=1e5+5;
char __buf[1<<21],*__p1,*__p2;
#define getchar() (__p1==__p2?(__p2=__buf+fread(__p1=__buf,1,1<<21,stdin),__p1==__p2?EOF:*__p1++):*__p1++)
inline int read() {
	int __x=0;
	char __c=getchar();
	while(__c<'0'||__c>'9') __c=getchar();
	while(__c>='0'&&__c<='9') {
		__x=__x*10+__c-'0';
		__c=getchar();
	}
	return __x;
}
inline char pc(char ch,bool bj) {
	static char buf[1<<18],*p1=buf,*p2=buf+(1<<18);
	return ((bj)||(*p1++=ch)&&p1==p2)&&fwrite(p1=buf,1,p1-buf,stdout),0;
}
void print(int x) {
	if(x<0)x=-x,pc('-',0);
	if(x>9)print(x/10);
	pc(x%10^48,false);
}
inline void printnum(int x,int ch) {
	print(x),pc(ch,false);
}
struct oper {
	int op,x,y;
	oper() {}
	oper(int Op,int X,int Y) {
		op=Op,x=X,y=Y;
	}
} o[maxn*4];
int u[maxn],v[maxn],oc,n,m,ans[maxn],f[maxm*2],siz[maxm*2],q,g[maxn][20],zm[maxn];
int getf(int x) {
	return f[x]==x?x:getf(f[x]);
}
int opp(int x) {
	return x&1?x+1:x-1;
}
void merge(int x,int y) {
	x=getf(x),y=getf(y);
	if(x==y)return;
	if(siz[x]<siz[y])swap(x,y);
	o[++oc]=oper(0,y,0),f[y]=x;
	o[++oc]=oper(1,x,siz[y]),siz[x]+=siz[y];
}
void replace(int cas) {
	while(oc>cas) {
		int op=o[oc].op,x=o[oc].x,y=o[oc].y;
		if(!op)f[x]=x;
		if(op==1)siz[x]-=y;
		oc--;
	}
}
bool check(int x) {
	return getf(x)==getf(opp(x));
}
void solve(int l,int r,int L,int R,bool lst) {
	if(L==R) {
		for(register int i=l; i<=r; i++)ans[i]=L;
		return;
	}
	if(l>r)return;
	int mid=(l+r)/2,cas=oc;
	bool now=lst;
	for(register int i=mid; i<=r&&i<L; i++) {
		merge(u[i],v[i]),merge(opp(u[i]),opp(v[i]));
		now|=check(u[i]);
		if(now)break;
	}//mid~min(r,L-1) 的边是一定要用的，先加上
	int tmp=oc,sum=now;
	for(register int i=max(L,mid); i<=R; i++) {
		merge(u[i],v[i]),merge(opp(u[i]),opp(v[i]));
		now|=check(u[i]);
		if(now) {
			ans[mid]=i;
			break;
		}
	}//从 max(L,mid) 一直加到 R 来寻找 mid 处答案
	bool pd=0;
	if(!ans[mid]) {
		ans[mid]=m+1;
		for(register int i=mid+1; i<=r; i++)ans[i]=m+1;
		pd=1;
	}//如果到最右边仍然合法，那么它的右区间也合法
	replace(tmp);
	solve(l,mid-1,L,ans[mid],sum);//l~mid-1 需要 mid~min(r,L-1) 的边
	replace(cas);
	if(pd)return;
	now=lst;
	for(register int i=max(r+1,L); i<ans[mid]; i++) {
		merge(u[i],v[i]),merge(opp(u[i]),opp(v[i]));
		now|=check(u[i]);
		if(now)break;
	}
	solve(mid+1,r,ans[mid],R,now);//mid+1,~r 需要 max(r+1,L)~ans[mid]-1 的边
	replace(cas);
}
int main() {
	int U,x,V,y;
	bool p=0;
	n=read(),m=read(),q=read();
	for(register int i=1; i<=2*n; i++)f[i]=i,siz[i]=1;
	for(register int i=1; i<=m; i++) {
		U=read(),x=read(),V=read(),y=read();
		zm[i]=zm[i-1]+(U==V&&x!=y);
		u[i]=U*2-1+x,v[i]=V*2-1+y;
		merge(u[i],v[i]),merge(opp(u[i]),opp(v[i]));
		p|=check(u[i]);
	}
	if(!p) {
		while(q--)printnum(1,'\n');
		return pc(0,1),0;
	}
	replace(0);
	u[m+1]=1,v[m+1]=2;
	solve(1,m,1,m+1,0);
	for(register int i=0; i<20; i++)g[m+1][i]=m+1;
	for(register int i=m; i; i--) {
		g[i][0]=ans[i];
		for(register int j=1; j<20; j++)g[i][j]=g[g[i][j-1]][j-1];
	}
	while(q--) {
		x=read(),y=read();
		if(zm[y]-zm[x-1]>0) {
			printnum(-1,'\n');
			continue;
		}
		int w=1;
		for(register int i=19; i>=0; i--)
			if(g[x][i]<=y)x=g[x][i],w+=(1<<i);
		printnum(w,'\n');
	}
	pc(0,1);
	return 0;
}
```

---

## 作者：LJC00101 (赞：8)

发一个理论复杂度更优但因为常数过大导致最后几乎是最劣解的写法。

它的时间复杂度为 $O(m\log(n+m)+q)$  ，空间复杂度为 $ O(n+m)$ 。

首先对于每一个询问我们考虑朴素的贪心做法，因为每一段限制都是连续的而且我们不能跳过任何限制，所以我们从 $l$ 开始对当前段能加限制就往里加，直到 $r$ 被加入，这样的段数显然是最少的。

注意到每次我们对每段的开头都求了以它为开头最多往后到那个限制可以保证有解，那么我们定义对于第 $i$ 个限制以它为开头最多往后到第 $w_i$ 限制可以保证有解，考虑如何用更少的时间对 $1-n$ 求出 $w_i$ 。显然，因为减少限制后会更容易有解，所以 $w_i$ 是单调递增的。

一个限制根据 2-sat 中的意义可以表示为两条无向边，多个限制有解则需保证对 $1-n$ 表示它真和它假的点不联通。我们考虑用 LCT 维护一张图，不断往后加限制直至下一个限制加入后会冲突，即可求出 $w_i$ ，之后我们把当前限制对应的边删掉求 $w_{i+1}$ 。

判断冲突时我们不可能对 $1-n$ 都检查，但经过 YY 可知，如果有冲突，那么当前限制的两个变量肯定都产生了冲突。另一个问题是正常的图可能不是森林，那么我们维护它按限制编号的最大生成树可以保持它连通性和原图相同同时每次删除当前限制的对应的边后连通性仍旧和实际的图相同。

此时，暴力跳 $w_i$ 就可以获得 **90** 分的好成绩

[提交记录](https://www.luogu.com.cn/record/62318575)

当我们求出 $w_i$ 后，我们自然可以用倍增来求解，但我们也可以将询问离线至线段树上同时包含 $l$ 和 $r$ 的对应了最小区间的结点来处理，对于 $\leq mid$ 的点，我们求出它要几段才能将 $\leq mid$ 的限制满足完，对于 $>mid$ 的点，我们求出它要几段才能将 $>mid$ 的限制满足完，可以发现 $l$ 、 $r$ 必在  $mid$ 两侧，答案最多与两者对应段数之和相差一(横跨了 $mid$ 和 $mid+1$ 的段会同时在 $l$ 和 $r$ 各记一次)。

耗时主要在第一部分。

代码如下

[代码](https://www.luogu.com.cn/paste/0watpv98)

---

## 作者：QAQQWQ (赞：5)

对于每个变量我们用 $u$ 和 $u'$ 表示它取值为 $0$ 或 $1$ ，那么一个限制就相当于对 $u$ 和 $v$ ，$u'$ 和 $v'$ 连边，最后我们要保证没有一对点联通。

我们考虑对于每个 $i$ 求出 $f_i$ 表示它最远到哪一条边是合法的，容易发现 $f_i$ 单调。然后询问时倍增。用并查集维护。

我们要如何快速求出 $f_i$ ？容易想到的是在每次算 $f_{i+1}$ 时将第 $i$ 条边撤销，然后就可以从第 $f_i+1 $条边开始添加。但可撤销并查集只支持把最后的一条边撤销。其他题解在这里用整体二分等做法实现，但我用的是一个比较玄学的做法。

考虑可撤销并查集相当于一个栈，那么我们就是要用一个栈实现队列。在[UR #23 地铁规划](https://uoj.ac/problem/693)这题的官方题解 $subtask2$ 中有一个最差大概 $O(\sqrt{n})$ 的做法可以实现单栈模拟队列。

具体方法是我们在栈中额外记录一个标记表示是否翻转过（相当于双栈模拟队列时元素在那个栈中），然后弹出时如果栈顶翻转过就直接弹出，否则我们不断弹出并记录下未翻转和翻转过的元素，直到栈空或者未翻转和翻转过的元素个数相同。如果最后栈空我们就将未翻转的全部翻转放入栈中,否则直接放回栈中，再将翻转过的元素放回栈中然后弹出栈顶。

那么我们用这个方法来维护可撤销并查集即可。最坏复杂度应该是 $O(n\sqrt{n}\log{n})$ 。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100009
#define maxm 600009
int n,m,q,u[maxm],v[maxm],x[maxm],y[maxm],f[maxm];
int fa[maxn*2],siz[maxn*2];
#define mp make_pair
typedef pair<int ,int > pii;
pair<int ,pair<pii ,pii > > edg[2*maxm];
pii edg1[2*maxm],edg0[2*maxm];
int top=0,top1=0,top0=0;
int qwq(int a){
	return (((a-1)/n)^1)*n+(a-1)%n+1;
}
int lf(int a){
	return fa[a]==a?a:lf(fa[a]);
}
void meg(int a,int b){
	a=lf(a),b=lf(b);
	if(a==b)return ;
	if(siz[a]<siz[b])swap(a,b);
	fa[b]=a;siz[a]=siz[a]+siz[b];
	return ;
}
void dele(pii a){
	if(a.first==a.second)return ;
	if(fa[a.first]==a.second)swap(a.first,a.second);
	fa[a.second]=a.second;siz[a.first]-=siz[a.second];
	return ;
}
void pushin(pii a,int opt){
	pii b;
	b.first=lf(a.first),b.second=lf(a.second);
	meg(b.first,b.second);edg[++top]=mp(opt,mp(a,b));
	return ;
}
void poptop(){
	if(!top)return ;
	dele(edg[top].second.second);
	top--;
	return ;
}
void popback(){
	if(edg[top].first==1){
		poptop();return ;
	}
	edg0[++top0]=edg[top].second.first;poptop();
	while(top&&top0>top1){
		if(edg[top].first){
			edg1[++top1]=edg[top].second.first;poptop();
		}
		else{
			edg0[++top0]=edg[top].second.first;poptop();
		}
	}
	if(top==0){
		for(int i=1;i<=top0;i++){
			pushin(edg0[i],1);
		}
		top0=0;
	}
	else{
		while(top0){
			pushin(edg0[top0--],0);
		}
	}
	while(top1){
		pushin(edg1[top1--],1);
	}
	poptop();
	return ;
}
int kf[maxm][21];
void www(){
	int l,r,ans=0;cin>>l>>r;		
	for(int i=20;i>=0;i--){
		if(kf[l][i]<=r){
			ans+=(1<<i);
			if(l==kf[l][i]){
				puts("-1");
				return ;
			}
			l=kf[l][i];
		}
	}
	cout<<ans+1<<endl;
	return ;
}
int main(){
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++){
		cin>>u[i]>>x[i]>>v[i]>>y[i];
	}
	for(int i=1;i<=2*n;i++){
		fa[i]=i;siz[i]=1;
	}
	for(int i=1;i<=m;i++){
		if(i!=1){
			popback();popback();
		}
		f[i]=f[i-1];
		for(int j=f[i-1]+1;j<=m;j++){
			int uid=u[j]+x[j]*n,vid=v[j]+y[j]*n;
			pushin(mp(uid,vid),0);pushin(mp(qwq(uid),qwq(vid)),0);
			if(lf(uid)==lf(qwq(uid))){
				poptop();poptop();
				break;
			}
			f[i]=j;
		}
		kf[i][0]=f[i]+1;
	}
	kf[m+1][0]=m+1;
	for(int i=1;i<=20;i++){
		for(int j=1;j<=m+1;j++){
			kf[j][i]=kf[kf[j][i-1]][i-1];
		}
	}
	while(q--){
		www();
	}
	return 0;
}
```


---

## 作者：altgo (赞：5)

## 题目大意

询问一个区间边可以分成多少个有解的 2-sat 。

边比较特殊。

多组询问。

## 解题过程

### 首先

分析题目，容易知道最优秀的划分策略一定是从 $l$ 找到一个最远的可以达到的点 $p_l$，将答案累加，$l=p_l+1$，重复这个过程，一直到 $l>r$ 。

发现由于没有修改操作，所以每一个 $l$ 对应的 $pl$ 都是确定的。完全可以先预处理出来，然后倍增跳就好了。那么询问的复杂度就是 $O(q\log m)$ 的。

但是，怎么求 $pl$ 呢？

### 进一步考虑

发现很明显对于一个确定的 l ，随着 r 的增大，[l, r] 区间的限制一定会更加严格；那么，很明显，对于 $i<j$ ，$p_i\le p_j$ 。

那么我们现在只需要解决这样一个问题：我们需要实时判断目前的图是否会发生冲突，并支持加边与删边。

并且，由于这种边很有特点，每次 $u,t0,v,t1$ 的限制都会产生 $(u[t0],v[t1])$ 与 $(u[1-t0],v[1-t1])$ 的两条双向边。经过简单分析可以知道，我们想要判断加入这条边是否会产生矛盾，只需要判断 $u$ $v$ 两个点即可。

同理，想要知道删除一条边是否会消除矛盾，同样也只需要判断 $u$ $v$ 两个点。
这一切似乎都可以使用并查集进行简单的维护，当然，由于有删除操作，所以需要按秩合并。

然后再使用双指针就可以再 $O(m\log m)$ 的时间预处理。

Done!

但是...真的是这样吗？

### 发现问题

很可惜，出现了一点问题。

比方说我们求出了 $i$ 的 $p_i$，那么我们现在并查集里已经加入了 $[i,p_i]$ 的边。

然而，到下一步，我们希望删除第 $i$ 个限制带来的边，单纯重置 $u_i,v_i$ 的父亲是不够的。

我们会有一大堆的信息需要更改。

这是因为 $[i+1,p_i]$ 的连边可能基于 $i$ 边带来的并查集中的连通性。

我们无法消去这个连通性在后继造成的影响。

怎么办呢？

### 解决问题

既然优雅的方式无法实现，那么不妨考虑暴力一点吧！

我们可以根据决策单调性的基本套路：使用整体二分进行求解。

$solve(l,r,L,R)$ 表示 $[l,r]$ 区间的答案在 $[L,R]$ 区间中。

那么每次我们进入这个函数之前我们需要保证 $[r+1,L-1]$ 区间中的所有限制已经加入并查集。

可以发现，如果这样做，就可以通过实现保证每次删除最新加入的边。

使用并查集按秩合并就可以做到 $O(m\log m\log n)$ 的预处理时间，已经足够通过这道题目。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define fo(i,a,b) for(int i=a;i<=b;++i)
#define fd(i,a,b) for(int i=a;i>=b;--i)

inline char gc() {
 static char buf[1048576 * 16], *p1, *p2;
 return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1048576 * 16, stdin),
p1 == p2) ? EOF : *p1++;
}
inline int read() {
 char ch = gc(); int r = 0, w = 1;
 for (; ch < '0' || ch > '9'; ch = gc()) if (ch == '-') w = -1;
 for (; '0' <= ch && ch <= '9'; ch = gc()) r = r * 10 + (ch - '0');
 return r * w;
}

const int N = 6e5 + 5, Maxlog = 19;

int n, m, q;
int u[N], v[N], t1[N], t2[N];
int f[N];
int sum[N];
int fa[N*2], siz[N*2];
int eff[N][2];
int g[N][Maxlog];

int Find (int x) {
	return fa[x] == x ? x : Find (fa[x]);
}

void Flip (int x) {
	if (eff[x][0]) {
		if (fa[eff[x][0]] != eff[x][0]) {
			fa[eff[x][0]] = eff[x][0];
		}
		if (fa[eff[x][1]] != eff[x][1]) {
			fa[eff[x][1]] = eff[x][1];
		}
		eff[x][0] = eff[x][1] = 0;
	} else {
		int u1 = Find (2 * u[x] - t1[x]);
		int v1 = Find (2 * v[x] - t2[x]);
		if (siz[u1] > siz[v1]) swap (v1, u1);
		siz[v1] += siz[u1];
		fa[u1] = v1; eff[x][0] = u1;
		u1 = Find (2 * u[x] - (1^t1[x]));
		v1 = Find (2 * v[x] - (1^t2[x]));
		if (siz[u1] > siz[v1]) swap (v1, u1);
		siz[v1] += siz[u1];
		fa[u1] = v1; eff[x][1] = u1;
	}
	return;
}

bool illegal (int x) {
	if (Find (u[x] * 2) == Find (u[x] * 2 - 1) ||
		Find (v[x] * 2) == Find (v[x] * 2 - 1))
			return 1;
	return 0;
}

int mymin (int a, int b) {
	return a < b ? a : b;
}

int mymax (int a, int b) {
	return a > b ? a : b;
}

void solve (int l, int r, int L, int R) {//[r+1,L-1]has already done
	if (l > r) return;
	if (L == R) { fo (i, l, r) f[i] = L; return; }
	int mid = l + r >> 1, tmp = mymin (r, L - 1);
	fo (l, mid, tmp) Flip (l);
	int j = mymax (mid, L);
	for (; j <= R; ++j) {
		Flip (j);
		if (illegal (j)) break;
	}
	f[mid] = j;
	tmp = mymax (mid, L);
	fd (l, j, tmp) Flip (l);
	solve (l, mid - 1, L, j);
	fd (l, mymin (r, L - 1), mid) Flip (l);
	fo (l, mymax (L, r + 1), j - 1) Flip (l);
	solve (mid + 1, r, j, R); 
	tmp = mymax (L, r + 1);
	fd (l, j - 1, tmp) Flip (l);
	return;
}

int main () {
//	freopen ("7843.in", "r", stdin);
//	freopen ("7843.out", "w", stdout);
	n = read (), m = read (), q = read ();
	fo (i, 1, m) {
		u[i] = read ();
		t1[i] = read ();
		v[i] = read ();
		t2[i] = read ();
		if (u[i] == v[i] && t1[i] != t2[i]) sum[i] = 1;
	}
	u[m + 1] = v[m + 1] = t1[m + 1] = 1, t2[m + 1] = 0;
	sum[0] = 0;
	fo (i, 1, m) sum[i] += sum[i-1];
	fo (i, 1, n * 2) fa[i] = i, siz[i] = 1;
	solve (1, m, 1, m + 1);
	fo (i, 1, m) g[i][0] = f[i];
	g[m + 1][0] = m + 1;
	fo (i, 1, Maxlog - 1) {
		fo (j, 1, m + 1) {
			g[j][i] = g[g[j][i - 1]][i - 1];
		}
	}
	fo (T, 1, q) {
		int l = read (), r = read ();
		if (sum[r] - sum[l - 1] > 0) {
			puts ("-1");
			continue;
		}
		int now = l, ans = 0;
		fd (i, Maxlog - 1, 0) {
			if (g[now][i] <= r)
				now = g[now][i], ans += 1 << i;
		}
		printf ("%d\n", ans + 1);
	}
	return 0;
}

/*

For King and Glory!
*/

```


---

## 作者：P2441M (赞：2)

## 题意
有 $n$ 个布尔变量和 $m$ 条限制，设 $s_i$ 表示第 $i$ 个布尔变量的取值，每条限制 $(u,x,v,y)(x,y\in\{0,1\})$ 表示 $s_u=x\Rightarrow s_v=y$ 且 $s_v=y\Rightarrow s_u=x$。$q$ 次询问 $l,r$，问第 $[l,r]$ 条限制最少可以被划分成多少段使得每一段的限制都找得到合法解，或报告无解。$1\leq n\leq 10^5,1\leq m\leq 6\times 10^5,1\leq q\leq 10^6$。

## 题解
好题。

显然无解当且仅当区间内存在形如 $u=v\land x\neq y$ 的限制，预处理前缀和 $s_i=\sum_{j=1}^i[u_j=v_j\land x_j\neq y_j]$，则当 $s_r>s_{l-1}$ 时无解。

观察到给出的限制是**无向**限制，所以可以扩展域并查集维护。

划段可以直接贪心，即对于当前位置 $x$，我们找到最小的使得 $[x,y]$ 不合法的 $y$，把 $[x,y-1]$ 划作一段，再令 $x\leftarrow y$。暴力跳无法承受，考虑倍增优化，预处理出 $g_{i,j}$ 表示从 $i$ 开始跳 $2^j$ 次跳到的位置，那么就可以做到单次询问 $\mathcal{O}(\log{m})$。对于边界问题，我们把第 $m+1$ 条限制搞成一个不合法限制即可。

问题转化为求出 $f_i$ 表示**最小**的 $j$ 使得 $[i,j]$ 不合法。注意到 $f_i$ 单调不减。

**证明**：反证。若存在 $i<j$ 且 $f_i>f_j$，说明 $[j,f_j]$ 不合法，那么 $[i,f_j]$ 也不合法，这和 $f_i$ **最小**的定义矛盾。**证毕。**

于是套路地考虑决策单调性二分，也即整体二分：$\operatorname{solve}(l,r,L,R)$ 表示 $\forall i\in[l,r],f_i\in[L,R]$，令 $mid=\left\lfloor\frac{l+r}{2}\right\rfloor$，我们求出 $f_{mid}$ 后递归下去。我们从 $mid$ 开始暴力加边，若 $u$ 和 $\lnot u$ 连通则无解。当然，这样暴力加边时间复杂度是错的，那么我们再次套路地考虑用可撤销并查集回滚。可以发现，如果在 $\operatorname{solve}$ 之前保证 $[r+1,L-1]$ 中的限制都被加入，我们就可以做到只增不删。具体来说，我们先依次加入 $[mid,\min(r,L-1)]$ 中的边，再依次加入 $[\max(mid,L),R]$ 中的边，加到不合法为止时记录答案。然后我们按需撤销并查集即可。一些题解继承了 $[r+1,L-1]$ 是否合法，这是不必要的，因为整体二分保证了答案不出现在这当中。

时间复杂度 $\mathcal{O}(n\log{n}\log{m}+(m+q)\log{m})$。

## 代码
放一下整体二分部分的代码。

```cpp
void solve(int l, int r, int L, int R) {
	if (l > r) return;
	if (L == R) {
		for (int i = l; i <= r; ++i) f[i] = L;
		return;
	}
	int mid = (l + r) >> 1, t1 = d.top;
	for (int i = mid; i <= min(r, L - 1); ++i)
		d.unite(u[i], v[i]), d.unite(inv[u[i]], inv[v[i]]);
	int t2 = d.top; bool cur = 1;
	for (int i = max(mid, L); i <= R; ++i) {
		d.unite(u[i], v[i]), d.unite(inv[u[i]], inv[v[i]]);
		cur &= (d.find(u[i]) != d.find(inv[u[i]]));
		if (!cur) { f[mid] = i; break; }
	}
	d.undo(t2), solve(l, mid - 1, L, f[mid]);
	d.undo(t1);
	for (int i = max(r + 1, L); i < f[mid]; ++i)
		d.unite(u[i], v[i]), d.unite(inv[u[i]], inv[v[i]]);
	solve(mid + 1, r, f[mid], R);
	d.undo(t1);
}
```

---

## 作者：farfarqwq (赞：2)

提供一种线段树分治做法。

### Sol

暴力可以对于每个询问，从 $l$ 开始不断加边，直到不合法清空边集，答案 +1。维护可以使用扩展域并查集，加完后判断 $u$ 和 $u+n$ 是否联通即可（容易证明此方法是正确的）。

对每个左端点求出最远的右端点，发现具有单调性。假如我们能类似双指针的过程求每个点的答案，询问的时候倍增一下就做完了。

但是我们无法从左边撤销，所以考虑使用线段树分治代替撤销。

具体地，递归到叶子结点，将其作为左端点（记为 $l$），进行右端点的后移，现在加入了一条边（编号为 $id$）由单调性得加入后使边集仍然合法的边在 $[l,id]$ 这段区间都出现在边集中。于是我们边分治边修改，把这条边 update 到 $[l+1,id]$ 上（$l$ 的位置已经计算过了）。

线段树分治不需要 pushdown，类似于标记永久化地维护，进入一个节点时加入它上面的所有边，回溯时撤销即可。

时间复杂度 $O(n\log^2 n)$。

关联题目：[CF603E](https://www.luogu.com.cn/problem/CF603E)。

### Code

注意 $n$ 和 $m$ 不要弄混。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int N = 100005, M = 600005, mod = 1e9 + 7;
int n, m, u[M][2], v[M][2];
int st[20][M];
int f[N << 1], sz[N << 1];
int t, s[M << 1];
inline int find(int x) {
    return f[x] == x ? x : find(f[x]);
}
inline void mrg(int x, int y) {
    x = find(x), y = find(y);
    if (x == y)
        return ;
    if (sz[x] < sz[y])
        swap(x, y);
    f[y] = x, sz[x] += sz[y];
    s[++t] = y;
}
inline void undo() {
    sz[f[s[t]]] -= sz[s[t]];
    f[s[t]] = s[t];
    --t;
}
int now = 0;
int cnt, head[M << 2];
struct edge {
    int v, next;
} e[M * 40];
inline void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
void upd(int p, int L, int R, int l, int r, int x) {
    if (r < L || R < l)
        return ;
    if (l <= L && R <= r) {
        add(p, x);
        return ;
    }
    int mid = (L + R) >> 1;
    upd(p << 1, L, mid, l, r, x), upd(p << 1 | 1, mid + 1, R, l, r, x);
}
void solve(int p, int l, int r) {
    int t0 = t;
    for (int i = head[p]; i; i = e[i].next)
        mrg(u[e[i].v][0], v[e[i].v][0]), mrg(u[e[i].v][1], v[e[i].v][1]);
    if (l == r) {
        while (now <= m) {
            if (++now <= m)
                mrg(u[now][0], v[now][0]), 
                mrg(u[now][1], v[now][1]);
            if (now > m || find(u[now][0]) == find(u[now][1]))
                break;
            upd(1, 1, m, l + 1, now, now);
        }
        st[0][l] = now--;
    } else {
        int mid = (l + r) >> 1;
        solve(p << 1, l, mid);
        solve(p << 1 | 1, mid + 1, r);
    }
    while (t > t0)
        undo();
}
int main() {
    int q;
    fin >> n >> m >> q;
    for (int i = 0; i <= n + n; i++)
        sz[i] = 1, f[i] = i;
    for (int i = 1; i <= m; i++) {
        int s, x, t, y;
        fin >> s >> x >> t >> y;
        if (x == y)
            u[i][0] = s, u[i][1] = s + n, v[i][0] = t, v[i][1] = t + n;
        else
            u[i][0] = s, u[i][1] = s + n, v[i][0] = t + n, v[i][1] = t;
    }
    solve(1, 1, m);
    st[0][m + 1] = m + 1;
    for (int i = 1; i < 20; i++)
        for (int j = 1; j <= m + 1; j++)
            st[i][j] = st[i - 1][st[i - 1][j]];
    while (q--) {
        int l, r;
        fin >> l >> r;
        int res = 0;
        for (int i = 19; ~i; i--)
            if (st[i][l] <= r)
                l = st[i][l], res |= 1 << i;
        fout << (st[0][l] <= r ? -1 : res + 1) << '\n';
    }
    return 0;
}
```

---

## 作者：forest114514 (赞：0)

### 「C.E.L.U-03」布尔


首先是一个 2-SAT，但是你发现限制是双向的，直接并查集就能找 SCC。

我们找出 $nxt_{i}$ 表示从 $i$ 开始最段不合法子段的右端点，给 $m+1$ 加上一个一定不合法的限制就能保证不会越界了，如果求出了就可以倍增维护 $O(\log m)$ 回答询问了。 

首先判断限制不合法的话，不难发现如果加入了 $(u,x,v,y)$ 的限制变得不合法，那么一定有 $u$ 和 $¬u$ 在同一连通块，就能判断了。

但是你发现直接双指针是不行的因为不能删除，而且不能合并所以不能 baka‘s trick，但是能加边和撤销，考虑决策单调性分治的时候回滚一下，只加不删。

如何保证只加不删？每次走到 `solve(l,r,L,R)` 区间的时候保证指针区间在 $[r,L]$ 即可，如果出现了 $r>L$ 的情况特判一下不连边，使用可撤销并查集，时间复杂度 $O(m\log m\log n+q\log m)$。

有一个很重要的细节！要提前记录 $[r,L]$ 是否合法！

感觉这题细节比较多，放一下分治部分代码：

```cpp
int getf(int x){return x==fa[x]?x:getf(fa[x]);}
int merge(int x,int y){
	x=getf(x),y=getf(y);
	if(x==y) return -1;
	if(siz[x]>siz[y]) swap(x,y);
	siz[y]+=siz[x],fa[x]=y;
	return x;
}
#define id(x,y) ((x)+(y)*(n+1))
void back(){
	pii p=st[top--];
	if(p.sc!=-1)siz[fa[p.sc]]-=siz[p.sc],fa[p.sc]=p.sc;
	if(p.fi!=-1)siz[fa[p.fi]]-=siz[p.fi],fa[p.fi]=p.fi;
}
void solve(int l,int r,int L,int R,bool can){
	//目前在[r,L] 
	int mid=l+r>>1,pos;
	bool op=can;
	per(i,r-1,mid){//[mid,L]
		--cl;
		if(cl<=cr) st[++top]=mp(merge(id(a[i].u,a[i].x),id(a[i].v,a[i].y)),merge(id(a[i].u,a[i].x^1),id(a[i].v,a[i].y^1)));
		else st[++top]={-1,-1};
		if(cl<=cr)op&=(getf(id(a[i].u,0))!=getf(id(a[i].u,1)));
	}
	bool cur=op;
	rep(i,L,R){//[mid,pos]
		if(i>L){
			++cr;
			if(cl<=cr) st[++top]=mp(merge(id(a[i].u,a[i].x),id(a[i].v,a[i].y)),merge(id(a[i].u,a[i].x^1),id(a[i].v,a[i].y^1)));
			else st[++top]={-1,-1};
		}
		if(cl<=cr) cur&=(getf(id(a[i].u,0))!=getf(id(a[i].u,1)));
		if(!cur){pos=i;break;}
	}
	nxt[0][mid]=pos;
	per(i,pos,L+1) back(),--cr;//[mid,L]
	if(l==r){
		rep(i,mid,r-1) back(),++cl;//[r,L]
		return;
	}
	solve(l,mid,L,pos,op);//[mid,L]
	rep(i,mid,r-1) back(),++cl;//[r,L]
	op=can;
	rep(i,L+1,pos){//[r,pos]
		++cr;
		if(cl<=cr) st[++top]=mp(merge(id(a[i].u,a[i].x),id(a[i].v,a[i].y)),merge(id(a[i].u,a[i].x^1),id(a[i].v,a[i].y^1)));
		else st[++top]={-1,-1};
		if(cl<=cr) op&=(getf(id(a[i].u,0))!=getf(id(a[i].u,1)));
	}
	solve(mid+1,r,pos,R,op);//[r,pos]
	per(i,pos,L+1) back(),--cr;//[r,L]
}
```

---


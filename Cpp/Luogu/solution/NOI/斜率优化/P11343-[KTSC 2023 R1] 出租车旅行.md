# [KTSC 2023 R1] 出租车旅行

## 题目背景

**请勿用 C++14 (GCC 9) 提交。**

请在程序开头加入如下代码：

```cpp
#include<vector>
std::vector<long long> travel(std::vector<long long> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W);
```

## 题目描述

**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T3 「[택시 여행](https://assets.ioikorea.kr/ioitst/2023/1/taxi/taxi_statement.pdf)」**

IOI 国由 $N$ 个城市和连接这些城市的 $N-1$ 条双向道路组成，任意两个不同的城市都可以通过这些道路互相到达。也就是说，IOI 国的道路网络是一个树结构。

每个城市都有一个编号，从 $0$ 到 $N-1$，其中 $0$ 号城市是 IOI 国的首都。对于每个 $i$ $(0 \leq i \leq N-2)$，第 $i$ 条道路连接 $U[i]$ 号城市和 $V[i]$ 号城市，道路长度为 $W[i]$ 公里。

在 IOI 国，不同城市的出租车费用不同。具体来说，对于每个 $i$ $(0 \leq i \leq N-1)$，从 $i$ 号城市出发的出租车有一个基本费用 $A[i]$ 元和每公里的费用 $B[i]$ 元。这意味着，如果从 $i$ 号城市出发并行驶 $d$ 公里，需要支付 $A[i] + d \times B[i]$ 元。

小明目前住在首都 $0$ 号城市，他计划乘坐出租车去其他城市旅行。当他到达一个城市时，可以选择继续乘坐当前的出租车，或者换乘该城市出发的出租车。当然，换乘出租车需要支付基本费用，并且每公里的费用也可能不同。请计算从 0 号城市出发到达其他所有城市的最小费用。

你需要实现以下函数：

```cpp
vector<long long> travel(vector<long long> A, vector<int> B, vector<int> U, vector<int> V, vector<int> W);
```

- 该函数只会被调用一次。
- `A`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-1)$，$A[i]$ 是从 $i$ 号城市出发的出租车的基本费用。
- `B`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-1)$，$B[i]$ 是从 $i$ 号城市出发的出租车的每公里费用。
- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-2)$，$U[i]$ 号城市和 $V[i]$ 号城市之间有一条长度为 $W[i]$ 公里的道路。
- 该函数返回一个大小为 $N-1$ 的数组 $C$。对于每个 $i$ $(0 \leq i \leq N-2)$，$C[i]$ 是从 $0$ 号城市出发到达 $i+1$ 号城市的最小费用。

注意，提交的代码中不应包含任何输入输出操作。

## 说明/提示

### 样例解释

考虑 $N=5, A=[10,5,13,4,3], B=[10,7,5,9,1], U=[1,0,3,2], V=[0,2,2,4], W=[1,5,10,3]$ 的情况。

评测程序将调用如下函数：

```cpp
travel([10, 5, 13, 4, 3], [10, 7, 5, 9, 1], [1, 0, 3, 2], [0, 2, 2, 4], [1, 5, 10, 3]);
```

- 从 $0$ 号城市到 $1$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $20$ 元。
- 从 $0$ 号城市到 $2$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $60$ 元。
- 从 $0$ 号城市到 $4$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，总费用为 $88$ 元。
- 从 $0$ 号城市到 $3$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，再换乘，经过 $2$ 号城市到达 $3$ 号城市，总费用为 $104$ 元。

函数应返回 `[20, 60, 104, 88]`。

### 数据范围

对于所有输入数据，满足：

- $2 \leq N \leq 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-1)$，$0 \leq A[i] \leq 10^{12}$
- 对于所有 $i$ $(0 \leq i \leq N-1)$，$0 \leq B[i] \leq 10^6$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq U[i], V[i] \leq N-1 ; U[i] \neq V[i]$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$1 \leq W[i] \leq 10^6$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $7$ | $N \leq 20$ |
| $2$ | $8$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$U[i]=i ; V[i]=i+1$ |
| $3$ | $13$ | $N \leq 2000$ |
| $4$ | $17$ | 对于所有 $i$ $(0 \leq i \leq N-1)$，$B[i] \leq 30$ |
| $5$ | $29$ | $B[i] \neq 0$ $(0 \leq i \leq N-1)$ 的 $i$ 不超过 $2000$ 个 |
| $6$ | $26$ | 无附加限制 |

## 样例 #1

### 输入

```
5
10 5 13 4 3
10 7 5 9 1
1 0 1
0 2 5
3 2 10
2 4 3```

### 输出

```
20
60
104
88```

# 题解

## 作者：EuphoricStar (赞：3)

给定一棵 $n$ 个点的树，边有边权。有一个 $n$ 个点的有向完全图，$i \to j$ 边权为 $a_i + \operatorname{dis}(i, j) \times b_i$。对于所有 $2 \le i \le n$，求 $1 \rightsquigarrow i$ 的最短路。

$2 \le n \le 10^5$，2s，1G。

----

**性质**：最短路除了终点的其他点 $b_i$ 递减。

考虑 DP，设 $f_u$ 为 $1 \rightsquigarrow u$ 且路径所有点 $b_u$ 递减的最短路长度，有：

$$
f_u = \min\limits_{b_v > b_u} f_v + a_v + \operatorname{dis}(u, v) \times b_v
$$

再设 $g_u$ 为 $1 \rightsquigarrow u$ 的最短路长度，有：

$$
g_u = \min\limits_{v} f_v + a_v + \operatorname{dis}(u, v) \times b_v
$$

看到树上距离考虑点分治。

点分树上每个点 $u$ 维护子树内 $(-b_v, f_v + a_v + \operatorname{dis}(u, v) \times b_v)$ 的凸包。由于 $b_v$ 有序所以凸包可以用支持 pop_back 的 vector 维护。

算 $f_u$ 就枚举 $u$ 在点分树上的祖先 $v$，相当于查询斜率为 $\operatorname{dis}(u, v)$ 的直线与凸包的最大截距。二分即可。

算 $g_u$ 可以用同样的方法。

时间复杂度 $O(n \log^2 n)$，空间复杂度 $O(n \log n)$。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef __int128 lll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 100100;
const int logn = 20;

ll n, a[maxn], b[maxn], dep[maxn], f[maxn], h[maxn];
int st[logn][maxn], dfn[maxn], tim;
vector<pii> G[maxn];
vector<int> T[maxn];

inline int get(int i, int j) {
	return dfn[i] < dfn[j] ? i : j;
}

inline int qlca(int x, int y) {
	if (x == y) {
		return x;
	}
	x = dfn[x];
	y = dfn[y];
	if (x > y) {
		swap(x, y);
	}
	++x;
	int k = __lg(y - x + 1);
	return get(st[k][x], st[k][y - (1 << k) + 1]);
}

inline ll qdis(int x, int y) {
	return dep[x] + dep[y] - dep[qlca(x, y)] * 2;
}

void dfs(int u, int t) {
	dfn[u] = ++tim;
	st[0][tim] = t;
	for (pii p : G[u]) {
		ll v = p.fst, d = p.scd;
		if (v == t) {
			continue;
		}
		dep[v] = dep[u] + d;
		dfs(v, u);
	}
}

struct node {
	ll x, y;
	node(ll a = 0, ll b = 0) : x(a), y(b) {}
};

inline node operator + (const node &a, const node &b) {
	return node(a.x + b.x, a.y + b.y);
}

inline node operator - (const node &a, const node &b) {
	return node(a.x - b.x, a.y - b.y);
}

inline lll operator * (const node &a, const node &b) {
	return (lll)a.x * b.y - (lll)a.y * b.x;
}

int rt, g[maxn], sz[maxn], fa[maxn], p[maxn];
bool vis[maxn];

void dfs2(int u, int fa, int t) {
	sz[u] = 1;
	g[u] = 0;
	for (pii p : G[u]) {
		int v = p.fst;
		if (v == fa || vis[v]) {
			continue;
		}
		dfs2(v, u, t);
		sz[u] += sz[v];
		g[u] = max(g[u], sz[v]);
	}
	g[u] = max(g[u], t - sz[u]);
	if (!rt || g[u] < g[rt]) {
		rt = u;
	}
}

void dfs3(int u) {
	vis[u] = 1;
	for (pii p : G[u]) {
		int v = p.fst;
		if (vis[v]) {
			continue;
		}
		rt = 0;
		dfs2(v, u, sz[v]);
		dfs2(rt, u, sz[v]);
		fa[rt] = u;
		T[u].pb(rt);
		dfs3(rt);
	}
}

vector<node> S[maxn];
node c[maxn];
int stk[maxn], top, tot, pt[maxn], K;
ll e[maxn];

void dfs5(int u, int fa, ll d) {
	c[++tot] = node(-b[u], f[u] + a[u] + b[u] * d);
	e[u] = d;
	pt[++K] = u;
	for (pii p : G[u]) {
		ll v = p.fst, k = p.scd;
		if (v == fa || vis[v]) {
			continue;
		}
		dfs5(v, u, d + k);
	}
}

inline void work(int u) {
	tot = 0;
	K = 0;
	dfs5(u, -1, 0);
	sort(c + 1, c + tot + 1, [&](const node &a, const node &b) {
		return a.x < b.x || (a.x == b.x && a.y < b.y);
	});
	top = 0;
	for (int i = 1; i <= tot; ++i) {
		while (top >= 2 && (c[i] - c[stk[top - 1]]) * (c[stk[top]] - c[stk[top - 1]]) >= 0) {
			--top;
		}
		stk[++top] = i;
	}
	tot = top;
	for (int i = 1; i <= tot; ++i) {
		c[i] = c[stk[i]];
	}
	for (int i = 1; i <= K; ++i) {
		int v = pt[i], l = 2, r = tot, p = 1;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (c[mid].y - c[mid - 1].y <= (c[mid].x - c[mid - 1].x) * e[v]) {
				p = mid;
				l = mid + 1;
			} else {
				r = mid - 1;
			}
		}
		h[v] = min(h[v], c[p].y - c[p].x * e[v]);
	}
}

void dfs4(int u) {
	vis[u] = 1;
	work(u);
	for (int v : T[u]) {
		dfs4(v);
	}
}

vector<ll> travel(vector<ll> _a, vector<int> _b, vector<int> _u, vector<int> _v, vector<int> _w) {
	n = (int)_a.size();
	for (int i = 1; i <= n; ++i) {
		a[i] = _a[i - 1];
		b[i] = _b[i - 1];
	}
	for (int i = 0; i < n - 1; ++i) {
		int u = _u[i] + 1, v = _v[i] + 1, d = _w[i];
		G[u].pb(v, d);
		G[v].pb(u, d);
	}
	dfs(1, -1);
	for (int j = 1; (1 << j) <= n; ++j) {
		for (int i = 1; i + (1 << j) - 1 <= n; ++i) {
			st[j][i] = get(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
		}
	}
	dfs2(1, -1, n);
	int x = rt;
	dfs2(x, -1, n);
	dfs3(x);
	for (int i = 1; i <= n; ++i) {
		p[i] = i;
	}
	sort(p + 2, p + n + 1, [&](const int &x, const int &y) {
		return b[x] > b[y];
	});
	mems(f, 0x3f);
	for (int i = 1; i <= n; ++i) {
		int u = p[i];
		if (i > 1 && b[u] > b[1]) {
			continue;
		}
		if (i == 1) {
			f[u] = 0;
		} else {
			for (int v = u; v; v = fa[v]) {
				if (S[v].empty()) {
					continue;
				}
				int l = 1, r = (int)S[v].size() - 1, p = 0;
				ll k = qdis(u, v);
				while (l <= r) {
					int mid = (l + r) >> 1;
					if (S[v][mid].y - S[v][mid - 1].y <= (S[v][mid].x - S[v][mid - 1].x) * k) {
						p = mid;
						l = mid + 1;
					} else {
						r = mid - 1;
					}
				}
				f[u] = min(f[u], S[v][p].y - S[v][p].x * k);
			}
		}
		for (int v = u; v; v = fa[v]) {
			node w(-b[u], f[u] + a[u] + b[u] * qdis(u, v));
			while ((int)S[v].size() >= 2 && (w - S[v][(int)S[v].size() - 2]) * (S[v].back() - S[v][(int)S[v].size() - 2]) >= 0) {
				S[v].pop_back();
			}
			S[v].pb(w);
		}
	}
	mems(h, 0x3f);
	mems(vis, 0);
	dfs4(x);
	vector<ll> vc;
	for (int i = 2; i <= n; ++i) {
		vc.pb(h[i]);
	}
	return vc;
}

// int main() {
	// int n;
	// scanf("%d", &n);
	// vector<ll> a(n);
	// vector<int> b(n);
	// for (ll &x : a) {
		// scanf("%lld", &x);
	// }
	// for (int &x : b) {
		// scanf("%d", &x);
	// }
	// vector<int> u(n - 1), v(n - 1), w(n - 1);
	// for (int i = 0; i < n - 1; ++i) {
		// scanf("%d%d%d", &u[i], &v[i], &w[i]);
	// }
	// auto ans = travel(a, b, u, v, w);
	// for (ll x : ans) {
		// printf("%lld\n", x);
	// }
	// return 0;
// }
```

---

## 作者：happybob (赞：2)

经过路径中除了终点外，其他点的 $b$ 应该单调下降。

按照 $b$ 从大到小 DP，可以得到 $f_i = \min \limits_{j} \{f_j + a_j + b_j \times \mathrm{dis}(i,j)\}$。

这个 DP 直接点分树每个点维护子树的动态开点李超树就行。由于这里加入的直线是全局加入，所以李超树是一个 $\log$ 的，总复杂度 $O(n \log n \log V)$。


```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

constexpr int N = 1e5 + 5, M = 1e7 + 5;

std::vector<long long> travel(std::vector<long long> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W);

int n, wc, tot;
array<ll, N> a, b, ans;
array<vector<pair<int, ll>>, N> G;
array<vector<int>, N> NG;
array<array<int, 20>, N> faf;
array<int, N> dep, sz, vis, dfa;
array<ll, N> dist, f;

void dfs(int u, int fa)
{
    faf[u][0] = fa;
    dep[u] = dep[fa] + 1;
    for (auto &[j, w] : G[u])
    {
        if (j ^ fa) dist[j] = dist[u] + w, dfs(j, u);
    }
}

inline int LCA(int u, int v)
{
    if (dep[u] < dep[v]) swap(u, v);
    int k = dep[u] - dep[v], c = 0;
    while (k)
    {
        if (k & 1) u = faf[u][c];
        k >>= 1;
        c++;
    }
    if (u == v) return u;
    for (int i = 19; i >= 0; i--) if (faf[u][i] ^ faf[v][i]) u = faf[u][i], v = faf[v][i];
    return faf[u][0];
}

inline ll qdis(int u, int v){return dist[u] + dist[v] - 2ll * dist[LCA(u, v)];}

inline void dfs2(int u, int fa)
{
    sz[u] = 0;
    if (vis[u]) return;
    sz[u] = 1;
    for (auto &[j, w] : G[u])
    {
        if (j ^ fa)
        {
            dfs2(j, u);
            sz[u] += sz[j];
        }
    }
}

inline void dfs3(int u, int fa)
{
    if (vis[u]) return;
    int maxn = tot - sz[u];
    for (auto &[j, w] : G[u])
    {
        if (j == fa) continue;
        dfs3(j, u);
        maxn = max(maxn, sz[j]);
    }
    if (maxn <= (tot >> 1)) wc = u;
}

inline void dc(int u, int fav)
{
    if (vis[u]) return;
    dfs2(u, 0);
    tot = sz[u];
    dfs3(u, 0);
    u = wc;
    vis[u] = 1;
    if (~fav) NG[fav].emplace_back(u), dfa[u] = fav;
    for (auto &[j, w] : G[u]) dc(j, u);
}

class Lichao_SegmentTree
{
public:
    int idx;
    struct Node
    {
        int ls, rs;
        ll k, b; // kx + b
        Node()
        {
            ls = rs = k = 0, b = (ll)3e18;
        }
    };
    array<Node, M> tr;
    inline void crt(int u)
    {
        if (!tr[u].ls) tr[u].ls = ++idx;
        if (!tr[u].rs) tr[u].rs = ++idx;
    }
    inline ll qry(ll k, ll b, ll x)
    {
        return k * x + b;
    }
    inline void pushtag(int u, ll l, ll r, ll k, ll b)
    {
        ll mid = l + r >> 1;
        if (qry(k, b, l) <= qry(tr[u].k, tr[u].b, l) && qry(k, b, r) <= qry(tr[u].k, tr[u].b, r))
        {
            tr[u].k = k, tr[u].b = b;
            return;
        }
        else if (qry(k, b, l) >= qry(tr[u].k, tr[u].b, l) && qry(k, b, r) >= qry(tr[u].k, tr[u].b, r)) return;
        if (qry(k, b, mid) < qry(tr[u].k, tr[u].b, mid))
        {
            swap(k, tr[u].k);
            swap(b, tr[u].b);
            crt(u);
            if (qry(k, b, r) < qry(tr[u].k, tr[u].b, r)) pushtag(tr[u].rs, mid + 1, r, k, b);
            if (qry(k, b, l) < qry(tr[u].k, tr[u].b, l)) pushtag(tr[u].ls, l, mid, k, b);
        }
        else
        {
            crt(u);
            if (qry(k, b, r) < qry(tr[u].k, tr[u].b, r)) pushtag(tr[u].rs, mid + 1, r, k, b);
            if (qry(k, b, l) < qry(tr[u].k, tr[u].b, l)) pushtag(tr[u].ls, l, mid, k, b);
        }
    }
    inline void ins(int& u, ll k, ll b)
    {
        if (!u) u = ++idx;
        pushtag(u, 1ll, (ll)1e11, k, b);
    }
    inline ll query(int u, ll l, ll r, ll x)
    {
        if (!u) return (ll)3e18;
        ll res = qry(tr[u].k, tr[u].b, x);
        if (l == r) return res;
        ll mid = l + r >> 1;
        if (x <= mid) res = min(res, query(tr[u].ls, l, mid, x));
        else res = min(res, query(tr[u].rs, mid + 1, r, x));
        return res;
    }
}sgt;

array<int, N> rt, p;

inline void upd(int u, ll val)
{
    f[u] = val;
    for (int x = u; x; x = dfa[x])
    {
        sgt.ins(rt[x], b[u], f[u] + a[u] + qdis(u, x) * b[u]);
    }
}

inline ll query(int u)
{
    ll res = (ll)3e18;
    for (int x = u; x; x = dfa[x]) res = min(res, sgt.query(rt[x], 1, (ll)1e11, qdis(u, x)));
    return res;
}

std::vector<long long> travel(std::vector<long long> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W)
{
    n = A.size();
    for (int i = 1; i <= n; i++) a[i] = A[i - 1], b[i] = B[i - 1];
    for (int i = 0; i < n - 1; i++)
    {
        G[U[i] + 1].emplace_back(V[i] + 1, W[i]);
        G[V[i] + 1].emplace_back(U[i] + 1, W[i]);
    }
    dfs(1, 0);
    for (int j = 1; j < 20; j++) for (int i = 1; i <= n; i++) faf[i][j] = faf[faf[i][j - 1]][j - 1];
    dc(1, -1);
    for (int i = 1; i <= n; i++) p[i] = i, f[i] = (ll)3e18;
    upd(1, 0);
    sort(p.begin() + 1, p.begin() + n + 1, [&](const int& x, const int& y){return b[x] > b[y];});
    for (int i = 1; i <= n; i++)
    {
        int j = p[i];
        if (j != 1) upd(j, query(j));
    }
    vector<ll> ret;
    for (int i = 2; i <= n; i++)
    {
        ans[i] = min(f[i], query(i));
        ret.emplace_back(ans[i]);
    }
    return ret;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

设我们当前以 $(A_i, B_i)$ 的代价行驶的，那么我们显然不可能走到一个 $(A_j, B_j)$ 使得 $B_j > B_i$，这意味着不仅每单位时间要多给一些，且还要交一个过路费，肯定不优。

故考虑动态规划，令 $dp_i$ 表示走到 $i$ 点且使得走过的 $B$ 单减时的最小代价，那么有状态转移：

$$dp_i = \min\limits_{B_j > B_i} \left( dp_j + A_j + B_j \operatorname{dis}(i, j)\right)$$

令 $ans_i$ 表示走到 $i$ 点的最短距离，注意最后一步不一定要保证 $B_i$ 比前面的都小（因为用不到了），故有：

$$ans_i = \min_{j = 1}^n \left( dp_j + [j \ne i] A_j + B_j \operatorname{dis}(i, j) \right)$$

这个 $\operatorname{dis}(i, j)$ 在树上不好转移啊，故考虑点分治拆位 $dep_u + dep_v$，但是这个 $dp$ 是动态的，故考虑点分树。

对于一个分治中心 $u$ 来说，可以将 $\operatorname{dis}(i, j)$ 拆位 $dep_i + dep_j$，那么有：

$$dp_i = \min_{B_j > B_i} \left(B_j dep_i + (dp_j + A_j + B_jdep_j)\right)$$

这是什么？直线 $kx + b$ 啊，相当于询问对于所有 $B_j > B_i$ 的直线 $j$ 中 $dep_i$ 位置的最小值。

故考虑按照 $B$ 从大到小进行转移，然后若计算出了 $dp_j$，然后在点分树上对每个父亲 $u$ 插入一条 $B_j x + (dp_j + A_j + B_j dep(u)_i)$ 的直线。

然后转移 $dp_i$ 的时候，访问 $i$ 在点分树上的每个父亲 $u$ 查询挂在这个父亲上所有直线 $dep(u)_i$ 位置的最小值。

维护凸包后二分或者使用动态开点李超树即可，时间复杂度为 $O(N \log N \log W)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const int N = 1e5 + 10, M = 20;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
ll all;
int n, u, v, w;
int p[N]; 
ll a[N], b[N], dp[N];
vector<pair<int, int>> E[N];
inline bool cmp(int x, int y){
	return b[x] > b[y];
}
inline void link(int u, int v, int w){
	E[u].push_back({v, w});
	E[v].push_back({u, w});
}
namespace Seg{
	int cnt;
	struct Node{
		int lson, rson;
		pair<int, ll> data;
	}X[N << 7];
	inline ll get(ll x, pair<int, ll> v){
		return x * v.fi + v.se;
	}
	inline void update(int &k, ll l, ll r, pair<int, ll> v){
		if(!k){
			k = ++cnt;
			X[k].data = v;
		}
		ll mid = (l + r) >> 1;
		if(get(mid, v) < get(mid, X[k].data))
		  swap(v, X[k].data);
		if(l == r)
		  return ;
		if(get(l, v) < get(l, X[k].data))
		  update(X[k].lson, l, mid, v);
		else if(get(r, v) < get(r, X[k].data))
		  update(X[k].rson, mid + 1, r, v);
	}
	inline ll ask(int k, ll l, ll r, ll i){
		if(!k)
		  return 5e17;
		ll now = get(i, X[k].data);
		if(l == i && i == r)
		  return now;
		ll mid = (l + r) >> 1;
		if(i <= mid)
		  return min(now, ask(X[k].lson, l, mid, i));
		else
		  return min(now, ask(X[k].rson, mid + 1, r, i));
	}
}
namespace LCA{
	ll d[N];
	int fa[N], son[N], siz[N], dep[N], top[N];
	inline void dfs1(int u, int f){
		siz[u] = 1;
		for(auto t : E[u]){
			int v = t.fi, w = t.se;
			if(v == f)
			  continue;
			fa[v] = u;
			d[v] = d[u] + w;
			dep[v] = dep[u] + 1;
			dfs1(v, u);
			siz[u] += siz[v];
			if(siz[v] > siz[son[u]])
			  son[u] = v;
		}
	}
	inline void dfs2(int u, int k){
		top[u] = k;
		if(!son[u])
		  return ;
		dfs2(son[u], k);
		for(auto t : E[u]){
			int v = t.fi;
			if(v == fa[u] || v == son[u])
			  continue;
			dfs2(v, v);
		}
	}
	inline int LCA(int u, int v){
		while(top[u] != top[v]){
			if(dep[top[u]] < dep[top[v]])
			  swap(u, v);
			u = fa[top[u]];
		}
		return dep[u] < dep[v] ? u : v;
	}
	inline ll getdis(int u, int v){
		return d[u] + d[v] - (d[LCA(u, v)] << 1ll);
	}
	inline void init(){
		dfs1(1, 1);
		dfs2(1, 1);
	}
};
namespace Tree{
	int rt, sum, Max;
	int fa[N], siz[N], dep[N], root[N];
	ll dis[N][M];
	bool del[N];
	inline void getroot(int u, int fa){
		int s = 0;
		siz[u] = 1;
		for(auto t : E[u]){
			int v = t.fi;
			if(v == fa || del[v])
			  continue;
			getroot(v, u);
			siz[u] += siz[v];
			s = max(s, siz[v]);
		}
		s = max(s, sum - siz[u]);
		if(s < Max){
			Max = s;
			rt = u;
		}
	}
	inline void Get(int u, int p){
		rt = 0;
		sum = Max = p;
		getroot(u, 0);
		getroot(rt, 0);
	}
	inline void solve(int u){
		del[u] = 1;
		for(auto t : E[u]){
			int v = t.fi;
			if(del[v])
			  continue;
			Get(v, siz[v]);
			fa[rt] = u;
			dep[rt] = dep[u] + 1;
			solve(rt);
		}
	}
	inline void init(){
		LCA::init();
		Get(1, n);
		solve(rt);
		for(int i = 1; i <= n; ++i)
		  for(int j = i; j; j = fa[j])
		    dis[i][dep[i] - dep[j]] = LCA::getdis(i, j);
	}
	inline ll ask(int u){
		ll ans = 5e17;
		for(int v = u; v; v = fa[v])
		  ans = min(ans, Seg::ask(root[v], 0, all, dis[u][dep[u] - dep[v]]));
		return ans;
	}
	inline void update(int u){
		for(int v = u; v; v = fa[v])
		  Seg::update(root[v], 0, all, {b[u], a[u] + b[u] * dis[u][dep[u] - dep[v]]});
	}
};
std::vector<ll> travel(std::vector<ll> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W){
	vector<ll> ans;
	n = A.size();
	for(int i = 1; i <= n; ++i){
		a[i] = A[i - 1];
		b[i] = B[i - 1];
		p[i] = i;
	}
	for(int i = 1; i < n; ++i){
		u = U[i - 1] + 1, v = V[i - 1] + 1, w = W[i - 1];
		link(u, v, w);
		all += w;
	}
	Tree::init();
	sort(p + 1, p + n + 1, cmp);
	for(int i = 1; i <= n; ++i){
		u = p[i];
		if(u != 1)
		  a[u] += dp[u] = Tree::ask(u);
		Tree::update(u);
	}
	for(int i = 2; i <= n; ++i)
	  ans.push_back(min(Tree::ask(i), dp[i]));
	return ans;
}
/*int main(){
	auto t = travel({10, 5, 13, 4, 3}, {10, 7, 5, 9, 1}, {1, 0, 3, 2}, {0, 2, 2, 4}, {1, 5, 10, 3});
	for(auto v : t){
		write(v);
		putchar('\n');
	}
	return 0;
}*/
```

---

## 作者：Mirasycle (赞：1)

> 给定一颗 $n$ 个节点的树，从 $u$ 一步走到 $v$ 的权值为 $a_u\times dis(u,v)+b_u$。求从 $1$ 走到其他所有点所需的最小权值和。$n\le 10^5$。

注意本篇题解包括上述描述中的 $a,b$ 数组和题面中的相反，读者自行 $\rm {swap}$ 一下即可。

去年暑假集训遇到的题目，洛谷居然搬了。

感受一下这个过程，本来可以一步到位的，我们之所以选择一些途径点，可能是因为当前点的 $a_u$ 太大了，我们需要走到一些 $a_u$ 比较小的点上再出发（和 $b_u$ 无关，因为从一个点出发，不管往哪里走都需要支付 $b_u$）。于是可以得到一个结论，我们途径点的顺序必然是从 $a_u$ 大的走到 $a_u$ 小的点，当然最后的终点不一定满足这个条件。

于是考虑按照 $a_u$ 从大到小加入每个点作为途径点的信息，对于每个点要从 $a_u$ 大于它的点中求出到它的最小距离，也要把它加入后续点的选择中。直接做不好求，可以用点分治思想，如果经过 $rt$，从 $u$ 到 $v$ 的代价就是 $a_u\times d_v+(a_ud_u+b_u)$，这是一个一次函数可以用李超线段树维护。这启发我们建立点分树，每个点维护其子树内的一次函数，每次暴力跳父亲求其最短路，然后暴力跳父亲插入该点信息。

注意每次求完 $dis(1,u)$ 之后，需要 $b_u\gets dis(1,u)$，因为最短路需要类加上之前的路径之和。

上面插入的是途径点的信息，最后需要每个点作为终点再查询一下就行了。

时间复杂度 $O(n\log n\log V)$。其中 $V=\sum w_i$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int maxlog=20;
const ll lim=1e11+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(ll &x,ll y){ x=x<y?x:y; }
int a[maxn],p[maxn],S,C,n,num=0,ID=0;
vector<pair<int,int> > G[maxn];
vector<ll> ans; int rt[maxn];
pair<int,ll> line[maxn<<7]; ll b[maxn]; 
ll val(int id,ll x){ return line[id].fi*x+line[id].se; }
struct SegmentTree{
	#define mid ((l+r)>>1)
	int ls[maxn<<7],rs[maxn<<7],id[maxn<<7];
	void ins(int& p,ll l,ll r,int x){
		if(!p) p=++num,id[p]=x;
		if(val(x,mid)<val(id[p],mid)) swap(x,id[p]);
		if(l==r) return ;
		if(val(x,l)<val(id[p],l)) ins(ls[p],l,mid,x);
		else if(val(x,r)<val(id[p],r)) ins(rs[p],mid+1,r,x);
	}
	ll query(int p,ll l,ll r,ll x){
		if(!p) return 1e18;
		ll res=val(id[p],x);
		if(l==r) return res;
		if(x<=mid) cmin(res,query(ls[p],l,mid,x));
		else cmin(res,query(rs[p],mid+1,r,x));
		return res;
	}
}seg;
struct LCA{
	int dfn[maxn],pa[maxlog][maxn];
	int lg[maxn],tot=0; ll dep[maxn];
	void dfs(int u,int Fa){
		pa[0][dfn[u]=++tot]=Fa;
		for(auto z:G[u]){
			int v=z.fi,w=z.se;
			if(v==Fa) continue;
			dep[v]=dep[u]+w; dfs(v,u);
		}
	}
	int cmp(int x,int y){ return dfn[x]<dfn[y]?x:y; }
	int lca(int u,int v){
		if(u==v) return u;
		u=dfn[u]; v=dfn[v];
		if(u>v) swap(u,v);
		u++; int k=lg[v-u+1];
		return cmp(pa[k][u],pa[k][v-(1<<k)+1]);
	}
	void init(){
		dfs(1,0); lg[1]=0; 
		for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
		for(int k=1;(1<<k)<=n;k++)
			for(int i=1;i+(1<<k)-1<=n;i++)
				pa[k][i]=cmp(pa[k-1][i],pa[k-1][i+(1<<(k-1))]);
	}
	ll dis(int x,int y){ return dep[x]+dep[y]-2*dep[lca(x,y)]; }
}t;
struct Tree{
	int vis[maxn],fa[maxn],sz[maxn];
	int calc(int u,int Fa){
		int mx=0; sz[u]=1;
		for(auto z:G[u]){
			int v=z.fi;
			if(v==Fa||vis[v]) continue;
			int tmp=calc(v,u); sz[u]+=tmp; cmax(mx,tmp);
		}
		cmax(mx,S-sz[u]); if(mx<=S/2) C=u;
		return sz[u];
	}
	int find(int u){ S=calc(u,0); calc(u,0); return C; }
	void build(int u){
		vis[u]=1;
		for(auto Z:G[u]){
			int v=Z.fi;
			if(vis[v]) continue;
			int z=find(v);
			fa[z]=u; build(z);
		}
	}
	void modify(int x){
		int u=x;
		while(u){
			line[++ID]=mp(a[x],b[x]+a[x]*t.dis(u,x));
			seg.ins(rt[u],0,lim,ID); 
			u=fa[u];
		}
	}
	ll query(int x){
		int u=x; ll ans=1e18;
		while(u){
			cmin(ans,seg.query(rt[u],0,lim,t.dis(u,x)));
			u=fa[u];
		}
		return ans;
	}
}T;
bool cmp(int x,int y){ return a[x]>a[y]; }
vector<ll> travel(vector<ll> A, vector<int> B, vector<int> U, vector<int> V, vector<int> W){
	n=A.size(); ans.resize(n-1);
	for(int i=1;i<=n;i++) a[i]=B[i-1],b[i]=A[i-1],p[i]=i;
	for(int i=0;i<n-1;i++){
		U[i]++; V[i]++;
		G[U[i]].pb(V[i],W[i]);
		G[V[i]].pb(U[i],W[i]);
	}
	sort(p+1,p+1+n,cmp);
	t.init(); T.build(1); T.modify(1);
	for(int i=1;i<=n;i++){
		int u=p[i];
		if(u==1) continue;
		b[u]+=T.query(u);
		T.modify(u);
	}
	for(int i=2;i<=n;i++) ans[i-2]=T.query(i);
	return ans;
}
```

---

## 作者：Zaunese (赞：1)

参考了 <https://qoj.ac/blog/znstz/blogs/680>。

你搭乘出租车的过程是：从 $0$ 号点坐出租车出发，到达另一个点，换乘出租车到达下一个点，直至终点。

由于出租车能走的距离是无限的，所以有一个显然的事实：对于所有你搭乘的出租车，其 $B_i$ 关于你搭乘的顺序单调不增。

故将所有点的 $B_i$ 从大到小排，令 $f_i$ 表示到达点 $i$ 所需的最小代价，转移就是

$$f_i=\min_{j|B_j>B_i}\{f_j+A_j+B_j\cdot \operatorname{dis}(i,j)\}$$

这个转移的问题是，终点的 $B_i$ 不一定满足单调性，最后再转移一下就行了，即 $ans_u=\min_{j}\{f_j+A_j+B_j\cdot \operatorname{dis}(u,j)\}$。

直接转移可以做到 $O\left(N^2\right)$。

考虑优化。$\operatorname{dis}(i,j)$ 的计算涉及到 LCA，不难想到点分树。

应用点分树时，先想一下普通点分治怎么转移。对于分治中心 $u$，考虑一个子树内的点 $s$ 到另一个子树内的点 $t$ 的转移，发现代价形式是关于 $\operatorname{dis}(u,t)$ 的一次函数，不难想到李超树。

回到点分树上来，按 $B_i$ 从大到小转移时，可以把转移代价记在所有祖先上，接受转移时查询所有祖先，这意味差要对每个点维护一棵李超树。

现在应该差不多了，梳理一下过程：

1. 按 $B_i$ 从大到小枚举转移点 $u$。
2. 从 $u$ 的每个点分树上的祖先查询最小代价，作为 $f_u$。
3. 对 $u$ 的每个点分树上的祖先更新最小代价。

一份 [QOJ](https://qoj.ac/problem/6660) 上可过的代码。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>

#define fi first
#define se second
#define mkp std::make_pair
using ll=long long;
using std::max;
using std::min;
template<class T> void cmax(T&a,T b){a=max(a,b);}
template<class T> void cmin(T&a,T b){a=min(a,b);}

std::vector<ll> travel(std::vector<ll> A, std::vector<int> B, std::vector<int> U,std::vector<int> _V, std::vector<int> W){
    const ll INF=1e18;
    int N=A.size();
    std::vector<std::vector<std::pair<int,int> > > G(N);
    std::vector<std::vector<std::pair<int,ll> > > cdv(N);
    std::vector<int> siz(N),vis(N);
    int Gc;
    auto dfsgc=[&](auto&&self,int x,int p,int als)->void{
        siz[x]=1;
        bool F=1;
        for(auto e:G[x]) if(e.fi!=p&&!vis[e.fi]){
            self(self,e.fi,x,als);
            siz[x]+=siz[e.fi];
            if(siz[e.fi]*2>als) F=0;
        }
        if(F&&(als-siz[x])*2<=als&&!Gc) Gc=x;
    };
    auto dfsval=[&](auto&&self,int x,int p,ll d,int s)->void{
        cdv[x].emplace_back(s,d);
        for(auto e:G[x]) if(!vis[e.fi]&&e.fi!=p) self(self,e.fi,x,d+e.se,s);
    };
    auto dfz=[&](auto&&self,int x,int als)->void{
        Gc=0;
        dfsgc(dfsgc,x,-1,als);
        x=Gc;
        vis[x]=1;
        dfsval(dfsval,x,-1,0,x);
        for(auto e:G[x]) if(!vis[e.fi]){
            int tsiz=siz[e.fi]>siz[x]?als-siz[x]:siz[e.fi];
            self(self,e.fi,tsiz);
        }
    };
    for(int i=0;i<N-1;++i){
        G[U[i]].emplace_back(_V[i],W[i]);
        G[_V[i]].emplace_back(U[i],W[i]);
    }

    struct LINE{
        ll k,b;
        LINE(ll a=-1,ll _b=0){
            k=a;
            b=_b;
        }ll operator()(ll x){
            return k==-1?INF:k*x+b;
        }
    };
    struct SEGN{
        LINE v;
        int l,r;
    };
    static SEGN tr[40000000];
    std::vector<int> rt(N);
    int trcnt=0;
    const ll V=1e12;
    auto trins=[&](auto&&self,int&x,ll l,ll r,LINE z)->void{
        if(z.k==-1||l==r) return;
        ll mid=l+r>>1;
        if(!x) x=++trcnt;
        if(z(mid)<tr[x].v(mid)) std::swap(tr[x].v,z);
        if(z.k==-1||l==r) return;
        if(z(l)<tr[x].v(l)) self(self,tr[x].l,l,mid,z);
        if(z(r)<tr[x].v(r)) self(self,tr[x].r,mid+1,r,z);
    };
    auto trque=[&](auto&&self,int x,ll l,ll r,ll p)->ll{
        ll ans=INF;
        if(!x) return ans;
        ans=tr[x].v(p);
        ll mid=l+r>>1;
        if(p<=mid) return min(ans,self(self,tr[x].l,l,mid,p));
        else return min(ans,self(self,tr[x].r,mid+1,r,p));
    };

    dfz(dfz,0,N);
    //for(int i=0;i<N;++i){
    //    printf("%d:",i);
    //    for(auto p:cdv[i]) printf("%d %lld|",p.fi,p.se);
    //    puts("");
    //}
    std::vector<int> pi(N);
    for(int i=0;i<N;++i) pi[i]=i;
    std::sort(pi.begin(),pi.end(),[&](int x,int y){return B[x]>B[y];});
    for(auto p:cdv[0]) trins(trins,rt[p.fi],0,V,LINE{B[0],A[0]+B[0]*p.se});
    for(int x:pi){
        ll val=INF;
        for(auto p:cdv[x]) cmin(val,trque(trque,rt[p.fi],0,V,p.se));
        for(auto p:cdv[x]) trins(trins,rt[p.fi],0,V,LINE{B[x],A[x]+val+B[x]*p.se});
    }
    std::vector<ll> ans(N-1);
    for(int x=1;x<N;++x){
        ans[x-1]=INF;
        for(auto p:cdv[x]) cmin(ans[x-1],trque(trque,rt[p.fi],0,V,p.se));
    }
    return ans;
}
```

---


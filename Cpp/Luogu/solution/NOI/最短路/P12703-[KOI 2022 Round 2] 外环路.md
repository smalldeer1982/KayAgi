# [KOI 2022 Round 2] 外环路

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 城市由 $N$ 个十字路口和 $N - 1$ 条双向道路组成，任意两个不同的十字路口之间都可以仅通过道路到达。也就是说，城市的道路网络结构是一棵树。这些道路位于二维平面上，除了端点外互不相交。每条道路都有一个不小于 0 的整数权重，表示通过这条道路所需的时间。

KOI 城市在几十年前还是一个小村庄，随着人口流入和城市规模的迅速扩张，市长为了行政便利，为所有十字路口编号为 1 到 $N$。这个编号系统满足以下性质：

- 1 号十字路口是城市的中心，保证至少连接了两条道路。
- 各个十字路口的编号是以 1 号十字路口为根进行先序遍历（Preorder Traversal）所得到的一种顺序。
- 对于每个十字路口，设其直接相邻（即通过一条道路连接）的十字路口中编号最小的为基准，从该点出发按逆时针方向依次列出其相邻的十字路口编号，这些编号应是递增的。

随着 KOI 城市人口迅速增长，交通拥堵问题日益严重。为了解决这一问题，市长决定通过建设外环道路将交通设施最为薄弱的地区连接起来。

设所有仅连接一条道路的十字路口的编号按升序排列为 $\{v_1, v_2, \dots, v_k\}$，市长将为所有的 $1 \leq i \leq k$ 建设一条连接 $v_i$ 和 $v_{(i \bmod k) + 1}$ 的双向道路。每条道路的权重为不小于 0 的整数 $w_i$，这些权重将作为输入给出。

由于编号系统的特殊性，可以保证这些新增的外环道路在非端点处互不相交。

你打算为 KOI 城市构建一套导航系统。该系统需要回答 $Q$ 个查询，每个查询给出两个十字路口 $u$ 和 $v$，你需要输出从 $u$ 号十字路口到 $v$ 号十字路口所需的最短时间。这个最短时间是指从 $u$ 到 $v$ 所经过路径的所有道路权重之和的最小值。

请你编写程序，在给定城市道路结构和查询的前提下，快速回答所有 $Q$ 个查询。

## 说明/提示

**样例 1 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/fcuqax1l.png)

上面的地图对应于示例 1。示例 1 满足子任务 2、5、6 的约束条件。

**样例 2、3 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/5b0ae9y3.png)

上面的地图对应于示例 2 和示例 3。示例 2 的情况下，满足 $w_i = 0$；示例 3 的情况下，满足 $w_i = 10^{12}$。示例 2 满足子任务 4、5、6 的约束条件，示例 3 满足子任务 3、5、6 的约束条件。

请注意，示例 3 中从第 12 行开始的数列：

```
1000000000000 1000000000000 1000000000000 1000000000000 1000000000000 1000000000000
```

在实际中是作为一行输入给出的，但由于篇幅限制，在此被分成了多行显示。（本段内容在正式比赛中并未提供。）

**约束条件**

- $4 \leq N \leq 100\,000$
- $1 \leq p_i \leq i$
- $0 \leq c_i, w_i \leq 10^{12}$
- $1 \leq Q \leq 250\,000$
- $1 \leq u, v \leq N$ 且 $u \ne v$

**子任务**

1. （6 分）所有查询满足 $u = 1$
2. （8 分）对所有 $1 \leq i \leq N - 1$，$p_i = 1$
3. （5 分）对所有 $1 \leq i \leq N - 1$，$c_i \leq 10^6$，并且对所有 $1 \leq i \leq k$，$w_i = 10^{12}$
4. （15 分）对所有 $1 \leq i \leq k$，$w_i = 0$
5. （57 分）不存在连接 4 条及以上道路的十字路口
6. （9 分）无额外约束条件

## 样例 #1

### 输入

```
4
1 9
1 8
1 0
9 9 9
6
1 2
1 3
1 4
2 3
2 4
3 4```

### 输出

```
9
8
0
9
9
8```

## 样例 #2

### 输入

```
11
1 9
1 8
3 0
4 7
4 1
3 6
1 0
8 7
8 1
10 6
0 0 0 0 0 0
21
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
1 11
7 1
8 2
9 3
10 4
11 5
1 6
2 7
3 8
4 9
5 10
6 11```

### 输出

```
7
8
8
7
7
7
0
7
1
7
7
7
1
7
0
7
0
8
1
6
0```

## 样例 #3

### 输入

```
11
1 9
1 8
3 0
4 7
4 1
3 6
1 0
8 7
8 1
10 6
1000000000000 1000000000000
1000000000000 1000000000000
1000000000000 1000000000000
21
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
1 11
7 1
8 2
9 3
10 4
11 5
1 6
2 7
3 8
4 9
5 10
6 11```

### 输出

```
9
8
8
15
9
14
0
7
1
7
14
9
15
9
22
9
23
8
15
16
16```

# 题解

## 作者：Rainbow_qwq (赞：9)

这题的图是 Halin Graph，树宽为 $3$，可以构造 Halin Graph 树分解（[code1](https://qoj.ac/submission/106050)），然后用逛公园一题树分解的做法解决（[code2](https://uoj.ac/submission/622279)），复杂度 $O(n\log n+q)$。 

下面讲一点更 oi 的做法。

画图会发现这是一张平面图，由最外面的一个环（连起了所有叶子）和中间的一棵树组成。

对于这题，可以对树三度化，进行边分治。

对于树上被切开的两个连通块，两部分之间最多有三条边相连（环上两条边，一条树边）。

对于 $O(1)$ 个这几条边上的点，作为起点跑一遍最短路，然后把当前的询问答案都 chkmin 一下。

跨越两边的询问不必再递归，在同一边的询问递归下去，每个询问最多被递归 $\log$ 次。

复杂度 $O(n\log^2 n+q\log n)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(int i=(a);i>=(b);--i)
#define int long long
using namespace std;

#define fi first
#define se second
#define pb push_back
#define mkp make_pair
typedef pair<int,int>pii;
typedef vector<int>vi;

#define maxn 400005
#define inf 0x3f3f3f3f3f3f3f3f

int n,nn,m,res[maxn];
int qu[maxn],qv[maxn];
int fa[maxn];
vector<pii>G[maxn];

struct edge{
	int to,nxt,w;
}e[maxn<<1];
int tot=1,head[maxn];
void adde(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}
void add(int u,int v,int w){
	adde(u,v,w);
	adde(v,u,w);
}

void rebuild(int u,int pa){
	int lst=u;
	for(auto it:G[u]){
		int v=it.fi,w=it.se; 
		if(v==pa)continue;
		rebuild(v,u);
		add(lst,++nn,0),add(nn,v,w);
		lst=nn;
	}
}

vector<pii>go[maxn];

#define iter(i,u,v,w) for(int i=head[u],v=e[i].to,w=e[i].w;i;i=e[i].nxt,v=e[i].to,w=e[i].w)

int allsz,mn,id,sz[maxn];
bool vis[maxn<<1];
void gete(int u,int pa){
	sz[u]=1;
	iter(i,u,v,w){
		if(v==pa || vis[i])continue;
		gete(v,u); sz[u]+=sz[v];
		if(mn>max(sz[v],allsz-sz[v])) mn=max(sz[v],allsz-sz[v]),id=i;
	}
}

int col[maxn];
int st[maxn],top;

namespace D{

struct edge{
	int to,nxt,w;
}e[maxn<<1];
int tot,head[maxn];
void adde(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}
bool vis[maxn];
void dij(int u,int*dis){
	For(i,1,top) vis[st[i]]=0,dis[st[i]]=inf;
	dis[u]=0;
	priority_queue<pii,vector<pii>,greater<pii>>q;
	q.push(mkp(0,u));
	while(q.size()){
		int u=q.top().se;q.pop();
		if(vis[u])continue; vis[u]=1;
		iter(i,u,v,w){
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(mkp(dis[v],v));
			}
		}
	}
}

}

void color(int u,int pa,int c){
	col[u]=c;
	st[++top]=u;
	iter(i,u,v,w)if(!vis[i]&&v!=pa)color(v,u,c);
}


pii tmp[999]; int len,tw[999];
int dis[9][maxn];
void clear(){
	For(i,1,top){
		int u=st[i];
		col[u]=0; D::head[u]=0;
	}top=0; D::tot=0; len=0;
}

void solve(int u,vi qs){
	if(allsz==1||!qs.size())return;
	mn=inf,gete(u,0);
	int x=e[id].to,y=e[id^1].to;
	vis[id]=vis[id^1]=1;
	vi qx,qy;
	color(x,0,1);
	color(y,0,2);
	For(i,1,top){
		int u=st[i];
		iter(i,u,v,w){
			if(!col[v])continue;
			D::adde(u,v,w);
			if(col[u]==1&&col[v]==2) tmp[++len]=mkp(u,v),tw[len]=w,assert(len<=3);
		}
		for(auto it:go[u]){
			int v=it.fi,w=it.se;
			if(!col[v])continue;
			D::adde(u,v,w);
			if(col[u]==1&&col[v]==2) tmp[++len]=mkp(u,v),tw[len]=w,assert(len<=3);
		}
	}
	assert(len<=3);
	For(i,1,len){
		D::dij(tmp[i].fi,dis[i*2-1]);
		D::dij(tmp[i].se,dis[i*2]);
	}
	for(auto it:qs){
		int u=qu[it],v=qv[it];
		if(col[u]>col[v])swap(u,v);
		if(col[u]!=col[v]){
			For(i,1,len){
				res[it]=min(res[it],dis[i*2-1][u]+dis[i*2][v]+tw[i]);
			}
		}else{
			if(col[u]==1){
				For(i,1,len) res[it]=min(res[it],dis[i*2-1][u]+dis[i*2-1][v]);
				qx.pb(it);
			}else{
				For(i,1,len) res[it]=min(res[it],dis[i*2][u]+dis[i*2][v]);
				qy.pb(it);
			}
		}
	}
	clear();
	allsz=sz[x],solve(x,qx);
	allsz=sz[y],solve(y,qy);
}

int leaf[maxn],lcnt;

signed main()
{
	n=read();nn=n;
	For(i,2,n){
		fa[i]=read(); int w=read();
		G[i].pb(mkp(fa[i],w));
		G[fa[i]].pb(mkp(i,w));
	}
	For(i,1,n) if(G[i].size()==1) leaf[lcnt++]=i;
	For(i,0,lcnt-1){
		int u=leaf[i],v=leaf[(i+1)%lcnt];
		int w=read();
		go[u].pb(mkp(v,w)),go[v].pb(mkp(u,w));
	}
	rebuild(1,0);
	allsz=nn;
	vi orz;
	m=read();
	For(i,1,m){
		qu[i]=read(),qv[i]=read();
		orz.pb(i);
		res[i]=inf;
	}
	solve(1,orz);
	For(i,1,m){
		printf("%lld\n",res[i]);
	}
	return 0;
}
```

---


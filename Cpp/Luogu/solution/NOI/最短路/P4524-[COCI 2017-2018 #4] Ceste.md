# [COCI 2017/2018 #4] Ceste

## 题目描述

有一个无向图，给定 $n$ 个顶点和 $m$ 条边，第 $i$ 条边连接 $A_i$ 和 $B_i$ 两个点且有两个代价 $T_i$ 和 $C_i$。

从第 $i$ 个顶点经过一些边到第 $j$ 个顶点花费的代价为这些边的 $T$ 之和乘以 $C$ 之和。

问题是，对于每一个 $k(2 \le k \le n)$，求从1号点出发到 $k$ 号点花费的最小代价。

## 说明/提示

对于 $40\%$ 的数据，满足 $1 \le n,m,T_i,C_i \le 100$。

对于 $100\%$ 的数据，满足 $1 \le n,m,T_i,C_i \le 2000,1 \le A_i,B_i \le n$。

样例2解释：

为了到达城市2，我们选择第一条道路，花费1T与7C，代价为7。

为了到达城市3，我们选择第二条道路，花费3T与2C，代价为6。

为了到达城市4，我们选择道路2，4，5，花费11T与4C，代价为44。

## 样例 #1

### 输入

```
4 4
1 2 2 4
3 4 4 1
4 2 1 1
1 3 3 1
```

### 输出

```
8
3
14```

## 样例 #2

### 输入

```
4 5
1 2 1 7
3 1 3 2
2 4 5 2
2 3 1 1
2 4 7 1```

### 输出

```
7
6
44```

## 样例 #3

### 输入

```
3 2
1 2 2 5
2 1 3 3```

### 输出

```
9
-1```

# 题解

## 作者：TLEWA (赞：15)

## 观前注意

本篇题解是乱搞题解，具有错误的复杂度。如果要学习正经的解题思路可以选择跳过本篇题解。

## 解题思路

发现这个东西我们直接跑传统单源最短路是不对的，因为一个 $dis$ 数值显然难以完全描述全部两种边权的大小关系。如何把这个东西描述完全？

我们考虑到达点 $u$ 的 $\sum T$ 和 $\sum C$ 取何值时才有可能对最短路径做贡献，发现当存在另一组 $\sum T$ 和 $\sum C$ 均小于现取值时这个取值显然无意义，换言之，我们只需要对每个点维护一个凸包即可囊括所有可能的更新情况。

于是我们直接跑最短路，把传统最短路的入队条件改为对应 $\sum T,\sum C$ 是否在这个点的凸包上，然后一样更新最短路即可。

这个东西的最坏复杂度是 $O(Vnm \log Vnm)$，但是在一般的数据下凸包的点数显然远小于上界，跑得很快（时限 2.5s，最慢点 414ms），于是顺利通过了该题。

具体实现细节看代码。

## AC 代码


```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N=2005,INF=1e16;

int n,m; 
vector<tuple<int,int,int>> vec[N];

struct Node {
	int u,w1,w2;
	inline bool operator < (const Node& b) const {
		return w1*w2 > b.w1*b.w2;
	}
};

priority_queue<Node> que;
int dis[N];
set<pair<int,int>> S[N]; // 维护凸包 

void dij(int s) {
	que.push({s,0,0});
	memset(dis,63,sizeof(dis));
	S[s].insert({0,0});
	
	int v1,v2;
	while(!que.empty()) {
		auto [u,p,q]=que.top();
		que.pop();
		
		if(!S[u].count({p,q})) continue;
		dis[u]=min(dis[u],p*q);
		
		for(auto& [v,w1,w2]:vec[u]) {
			v1=p+w1,v2=q+w2;
			auto p=S[v].lower_bound({v1,v2});
			if(p!=S[v].begin() && (*prev(p)).second<v2) continue; // 无法更新
			while(p!=S[v].end() && (*p).second>v2) p=S[v].erase(p);
			S[v].insert({v1,v2});
			que.push({v,v1,v2});
		}
	}
}

signed main() {
	cin >> n >> m;
	
	int u,v,w1,w2;
	for(int i=1;i<=m;++i) {
		cin >> u >> v >> w1 >> w2;
		vec[u].push_back(make_tuple(v,w1,w2));
		vec[v].push_back(make_tuple(u,w1,w2));
	}
	
	dij(1);
	
	for(int i=2;i<=n;++i) {
		if(dis[i]<=INF) cout << dis[i] << endl;
		else cout << -1 << endl;
	}
	return 0;
}
```

---

## 作者：x义x (赞：8)

首先，之前那篇题解是假的，这篇题解主要是防止那篇假题解误导大家。下面的算法来自300iq。有一些结论我也不会证明，欢迎各位大爷来发题解把我这篇题解爆踩。

首先，一看到这道题，我们马上就会想到[P5540](https://www.luogu.org/problem/P5540)和[P3236](https://www.luogu.org/problem/P3236)。然而这题没有这么简单：一个决策点对其中一个顶点好并不代表它对另一个顶点好，于是似乎必须跑$n-1$遍之前的算法。可以拿到56分。

可以发现，这个算法的问题在于跑了太多次最短路（在测试点\#14我的代码跑了1e5次……）。

重新考虑一下。

**【结论】：**首先，对于顶点$v$来说，那条使得$\sum t\cdot \sum c$最小的路径$g$肯定满足：存在一个实数$0\le x\le 1$使得，如果把边权设为$xt[i]+(1-x)c[i]$后，这条路径是这种边权下的最短路。

如何证明？在新边权下的最短路就是$x\sum t+(1-x)\sum c$最小的路径。取$x=\dfrac{gc}{gt+gc}$，如果$g$并不在这个$x$下最短，即存在$h$满足

$$2\dfrac{gt\cdot gc}{gt+gc}>\dfrac{ht\cdot gc+hc\cdot gt}{gt+gc}$$

$$(ht-gt)(hc-gc)>ht\cdot hc-gt\cdot gc$$

分类讨论：

- 如果$ht<gt,hc<gc$。那么$h$显然比$g$优，矛盾。

- 如果$ht>gt,hc>gc$。那么$h$显然不是$x$下的最短路，矛盾。

- 如果都不是，那么有$(ht-gt)(hc-gc)<0$，于是根据上式有$ht\cdot hc<gt\cdot gc$，$h$比$g$优，矛盾。

于是原命题成立。□

于是，我们现在的目标就是：找到这个$x$。

可以发现我们刚才的证明和P5540，P3236那个几何方法很像，尤其是$\frac{gc}{gt+gc}$在P5540，P3236中重跑最小生成树/KM算法的时候，也有类似的形式出现。然而我们发现之前的那个方法会跑太多次最短路于是效率差得吓人，于是接下来考虑一件事情：

**什么是“有用”的$x$？**

如果一个新的$x'$，甚至不能使任何一个$u$的答案更新，那么它完完全全是无用的。

于是，我们认为：

一个使得$dis[u]+x't(u,v)+(1-x')c(u,v)<dis[v]$的$x'$是有用的。（$dis[u],dis[v]$都是对于上一个$x$而言的）

（为什么用$x$下的距离$+x'$下的边权？欢迎来补充解释。据说是拉格朗日乘子法但我不会orz）

于是我们不断找比当前$x$大且最小的$x'$，重跑最短路即可。

下面是人丑常数大，吸了氧才过的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
using namespace std;

int N,M;

int lnk[2005];
int pre[4005],tgt[4005],cnt;
int T[2005],C[2005];
db val[4005];
void add_E(int u,int v){pre[++cnt]=lnk[u],tgt[cnt]=v,lnk[u]=cnt;}

int disT[2005],disC[2005];
ll ANS[2005];
db dis[2005];
set<pair<int,db> > q;
void Dijkstra(){
	for(int i=2;i<=N;i++) dis[i]=1e20;
	dis[1]=0;q.insert(make_pair(1,0.0));
	while(!q.empty()){
		int u=q.begin()->first;
		q.erase(q.begin());
		for(int e=lnk[u];e;e=pre[e])
			if(dis[u]+val[e]<dis[tgt[e]]){
				q.erase(make_pair(tgt[e],dis[tgt[e]]));
				dis[tgt[e]]=dis[u]+val[e];
				disT[tgt[e]]=disT[u]+T[(e+1)>>1];
				disC[tgt[e]]=disC[u]+C[(e+1)>>1];
				q.insert(make_pair(tgt[e],dis[tgt[e]]));
			}
	}
	for(int i=2;i<=N;i++) if(dis[i]<1e19)
		if(1LL*disT[i]*disC[i]<ANS[i]) ANS[i]=1LL*disT[i]*disC[i];
}

void init_G(db x){
	for(int i=1;i<=M;i++) val[2*i-1]=val[2*i]=x*T[i]+(1-x)*C[i];
}

int main(){
	memset(ANS,0x3f,sizeof(ANS));
	scanf("%d%d",&N,&M);
	for(int i=1;i<=M;i++){
		int u,v;scanf("%d%d%d%d",&u,&v,&T[i],&C[i]);
		add_E(u,v);add_E(v,u);
	}
	
	db x=0;
	while(1){
		init_G(x);Dijkstra();
		db new_x=1;
		for(int i=1;i<=M;i++){
			int v=tgt[2*i-1],u=tgt[2*i],t=T[i],c=C[i];
			if(ANS[v]!=ANS[0]){
				db tmp_x=(db)(disC[v]-disC[u]-C[i])/(db)(disT[u]+T[i]-disC[u]-C[i]-disT[v]+disC[v]);
				if(x<tmp_x&&tmp_x<=new_x) new_x=tmp_x;
			}
			if(ANS[u]!=ANS[0]){
				db tmp_x=(db)(disC[u]-disC[v]-C[i])/(db)(disT[v]+T[i]-disC[v]-C[i]-disT[u]+disC[u]);
				if(x<tmp_x&&tmp_x<=new_x) new_x=tmp_x;
			}
		}
		if(x==new_x) break;
		x=new_x;
	}
	
	for(int i=2;i<=N;i++)
		if(ANS[i]==ANS[0]) printf("-1\n");
		else printf("%lld\n",ANS[i]);
	
	return 0;
}
```

~~话说之前代码放的是300iq的结果被拒了……题解审核真的神奇~~


---

## 作者：aaaaaaaawsl (赞：6)

题意：一个 $n$ 个点，$m$ 条边的有向图，每条边有权值 $a, b$，求其他点到 $1$ 号点的最短路。这里最短路定义为 $\Sigma_{ai} * \Sigma_{bi}$。

数据范围：$1 \leq n, m\leq 2000,1\leq a_{i}\leq b_{i} \leq n$。

-----------

看到这么小的数据范围就可以考虑乱搞了，普通的 Dijkstra 思想是往堆里扔边，用最小的来更新其他的。我们迁移一下，既然他要求两个权值的乘积，我们就把两个权值乘积扔到堆里，sigma 也好办，只要在遍历出边的时候把两个值分别加上再扔进堆里就行。

接下来考虑怎么保证每次拿来更新的点是 **有效** 的。

如果这个点当前积累的值为 $a, b$， 现在要查看 $c, d$ 是否能产生有效更新，有三种情况。

1.$a > c$ && $b > d$. 

2.$a \leq c$ && $b > d$. 

3.$a > c$ && $b \leq d$.

即观察到只要有一者小都是可能产生贡献的。所以可以有很多组合可能产生贡献，我们用 set 把他们都记下来（这里的作用是来用这些判断之后的点是否可能产生贡献）查询的时候，我们到对应的 set 里面找是否有两者都比他小的，但是直接遍历所有元素会 TLE，只能拿到 30pts。

这里采用下分段的思想，我们将两个关键字以其中一个分段，然后当新进来要查询的两个值的时候，我们找到它所处的那一段(如果它是本段第一个就找到前一段），这里可以用 lower_bound 实现，然后向后遍历去删除第二关键字比他大的，因为他们已经不可能对判断起有效作用了。

在结束完后，看当前的迭代器的值是否比判断的值大，如果小说明进来判断的这个值无用，否则把它扔进去，然后退出去更新。

这样你就可以拿到 96pts。开 O2 可以AC，但是我们不满意。T 一个点的原因是 ans 被进行重复无效更新。考虑到堆的性质，我们每次取出来的一定是最小值，所以我们记录下 **第一次更新某个 ans** 更新了几次，判断然后退出即可。

部分细节自己看代码吧。

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<set>
#define int long long
using namespace std;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch > '9' || ch < '0'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

const int N = 2e3 + 10;

int n, m;
int rt;
int cnt = 1;

int head[N], e[N << 1], Next[N << 1], idx, val1[N << 1], val2[N << 1];
inline void add(int a, int b, int c, int d){
	e[++ idx] = b; Next[idx] = head[a]; head[a] = idx; val1[idx] = c; val2[idx] = d;
}

int fa[N];

struct node{
	long long pos, t, c;
	inline bool operator < (const node &a) const {
		return (a.t * a.c < t * c);
	}
};

struct Node{
	long long t, c;
	inline bool operator < (const Node &a) const {
		return ((a.t == t) ? (a.c > c) : (a.t > t)); // 注意重载的运算符 
	}
};

int find(int x){
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

priority_queue<node> q;
set<Node> st[N];

bool check(int x, Node u){
	set<Node> :: iterator it;
	for(it = st[x].lower_bound(u); it != st[x].end() && it -> c >= u.c; it ++ ){
		set<Node> :: iterator itt = it; // 直接删迭代器会RE 
		it ++;
		st[x].erase(itt);
	}
	if(it != st[x].begin()){
		-- it;
		if(it -> c < u.c) return false;
	}
	st[x].insert(u); return true;	
}

int vis[N];
long long ans[N], tcnt;

void dij(){
	q.push((node){1, 0, 0});
	while(!q.empty()){
		node now = q.top(); q.pop();
		if(!check(now.pos, (Node){now.t, now.c})) continue; // 在这里检查 
		if(!vis[now.pos]) vis[now.pos] = 1, ans[now.pos] = now.t * now.c, ++ tcnt;
		if(tcnt == cnt) return;
		for(int i = head[now.pos]; i; i = Next[i]){
			int j = e[i];
			q.push((node){j, now.t + val1[i], now.c + val2[i]});
		}
	}
}

signed main(){
	n = read();
	m = read();
	for(int i = 1; i <= n; ++ i) fa[i] = i, ans[i] = -1;
	for(int i = 1; i <= m; ++ i){
		int a = read(), b = read(), c = read(), d = read();
		add(a, b, c, d); add(b, a, c, d);
		if(find(a) != find(b)) fa[fa[a]] = fa[b];
	}
	rt = find(1);
	for(int i = 2; i <= n; ++ i) if(find(i) == rt) ++ cnt; // 图可能不连通 
	dij();
	for(int i = 2; i <= n; ++ i) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：sunzihang (赞：5)

将代价中 $T$ 之和看作横坐标，$C$ 之和看作纵坐标。

容易发现，对终点相同的任意三种路径，记它们的代价点分别为 $a,b,c$，若存在 $\overrightarrow{ba}\times\overrightarrow{bc}\ge0$ ，则 $b$ 对应的路径一定不优。

因此考虑如何求出以每个点 $i(2\le i\le n)$ 为终点的路径，其代价点构成的凸包。

类似 wqs 二分，从大向小（即从贴近 $x$ 轴向远离 $x$ 轴）处理凸包上的每种斜率，每次用 $dijkstra$ 跑出当前的最短路。

然后找到一条边 $(u,v)$，使得用其从 $u$ 转移到 $v$ 得到的代价点 $Q$，在 $v$ 最短路径的代价点 $P$ 的左上方，且构成的向量 $\overrightarrow{PQ}$ 的斜率最大（即最贴近 $x$ 轴），并用这个斜率进行下一次处理。

因为每条边最多只会被我们找到一次，所以时间复杂度 $O(m^2\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
struct op{
	int x,y;
	op(const int&aa=0,const int&bb=0):x(aa),y(bb){}
	op operator+(const op&aa)const{return op(x+aa.x,y+aa.y);}
	LL operator*(const op&aa)const{return 1ll*x*aa.x+1ll*y*aa.y;}
}ux[4005],li[2005];
struct po{
	LL x;int y;
	po(const LL&aa=0,const int&bb=0):x(aa),y(bb){}
	bool operator<(const po&aa)const{return x>aa.x;}
};
int s,d,o,i,bx[4005],ax[2005],cx[4005];priority_queue<po>A;const int inf=5e6;bool us[2005];LL an[2005];
const LL nf=2e13;
template<typename T>inline void read(T &n){
	T w=1;n=0;char ch=getchar();
	while(!isdigit(ch)&&ch!=EOF){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)&&ch!=EOF)n=(n<<1)+(n<<3)+(ch&15),ch=getchar();
	n*=w;
}
void wk(op x){
	A.push(po(0,1)),memset(us,0,sizeof us);for(int g=2;g<=s;g++)li[g]=op(inf,inf);
	while(!A.empty()){
		po kk=A.top();A.pop();while(us[kk.y]&&!A.empty())kk=A.top(),A.pop();if(us[kk.y])break;us[kk.y]=1;
		for(int g=ax[kk.y];g;g=bx[g]){
			op ki=li[kk.y]+ux[g];LL kz=ki*x;
			if(kz<li[cx[g]]*x||kz==li[cx[g]]*x&&ki.y>li[cx[g]].y)li[cx[g]]=ki,A.push(po(kz,cx[g]));
		}
	}
	for(int g=2;g<=s;g++)if(li[g].x<inf)an[g]=min(an[g],1ll*li[g].x*li[g].y);
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	read(s),read(d);for(int g=2;g<=s;g++)an[g]=nf;
	for(int g=1;g<=d;g++)read(o),read(i),read(ux[g*2].x),read(ux[g*2].y),ux[g*2-1]=ux[g*2],bx[g*2-1]=ax[o],
	ax[o]=g*2-1,cx[g*2-1]=i,bx[g*2]=ax[i],ax[i]=g*2,cx[g*2]=o;
	wk(op(1,inf));
	while(1){
		op kz(0,1);
		for(int g=1;g<=s;g++)for(int h=ax[g];h;h=bx[h]){
			op ki=li[g]+ux[h];
			if(ki.x<li[cx[h]].x&&ki.y>li[cx[h]].y){
				op k1(ki.x-li[cx[h]].x,ki.y-li[cx[h]].y);if(1ll*kz.x*k1.y-1ll*kz.y*k1.x>0)kz=k1;
			}
		}
		if(!kz.x)break;wk(op(kz.y,-kz.x));
	}
	for(int g=2;g<=s;g++)if(an[g]<nf)cout<<an[g]<<'\n';else cout<<"-1\n";
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：2)

### 简化题意

给定一个有 $n$ 个点 $m$ 条边的无向图。每条边的边权为一个二元组 $(a, b)$，求从 $1$ 到其他所有点的最短路。

其中 $s$ 到 $t$ 的路径权值记为 $\sum{a_i} \times \sum{b_i}$。

### 题目分析

最短路。

考虑单源最短路（这里说的是 `dijkstra`）的步骤：找到一个有效的点 $a$，然后对它周围的点进行遍历，如果满足三角不等式（$d_a + w_i < d_b$），那么更新 $b$ 且入优先队列。

但是对于这道题，我们发现，我们并不知道哪些点会满足三角形不等式。换言之，我们不知道当前这个点是否应该入队。但是我们可以发现下面的性质：

 > 对于点 $a$，设可以到达 $a$ 的路径集合为 $S$，当前有到 $a$ 的路径长度 $(d_a, d_b)$。
 > 
 > 1. $\exists (S_a, S_b), S_a < d_a, S_b < d_b$，则 $(d_a, d_b)$ 一定不满足三角不等式。
 >
 > 2. $\forall(S_a, S_b), S_a > d_b, S_b > d_b$，则 $(d_a, d_b)$ 一定满足三角不等式。
 
 这样，我们可以对每个点搞一个 `set`，在里面存上每个到这个点的路径权值。然后每当得到一个新的长度，就去里面查一查，看看满不满足即可。
 
 感觉复杂度有点玄学，可能是因为数据太弱了。如果数据加强了，我立即删题解。
 
### 参考代码

```
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#include <ctime>
#include <set>
#define itset set<PLL>::iterator

using namespace std;

using LL = long long;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;

const int N = 2010, M = N << 1;
const LL INF = 1e12;
LL dist[N]; int n, m;
set<PLL> s[N];
bool st[N];

namespace Edges {
	int h[N], e[M], ne[M], idx; PLL w[M];
	void add(int a, int b, LL w1, LL w2) {
		e[ ++ idx] = b, ne[idx] = h[a], h[a] = idx;
		w[idx] = {w1, w2};
	}
} using namespace Edges;

struct Node {
	int ver; LL a, b;
	bool operator < (const Node &tmp)const {
		return tmp.a * tmp.b < a * b;
	}
};

bool check(int u, LL a, LL b) {
	itset it = s[u].upper_bound({a, b});
	if (it != s[u].begin()) {
		it -- ;
		if (it -> second < b) return false;
	}
	return true;
}

void dij() {
	priority_queue<Node, vector<Node>> q;
	fill(dist + 1, dist + n + 1, INF);
	s[1].insert({0, 0}); dist[1] = 0;
	q.push({1, 0, 0});
	
	while (q.size()) {
		auto t = q.top(); q.pop();
		int ver = t.ver, a = t.a, b = t.b;
		
		for (int i = h[ver]; i; i = ne[i]) {
			int j = e[i];
			if (!check(j, a + w[i].first, b + w[i].second)) continue;
			s[j].insert({a + w[i].first, b + w[i].second});
			dist[j] = min(dist[j], (a + w[i].first) * (b + w[i].second));
			q.push({j, a + w[i].first, b + w[i].second});
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);
	while (m -- ) {
		int a, b; LL w1, w2;
		scanf("%d%d%lld%lld", &a, &b, &w1, &w2);
		add(a, b, w1, w2), add(b, a, w1, w2);
	}
	
	dij();
	
	for (int i = 2; i <= n; i ++ )
		printf("%lld\n", dist[i] == INF ? -1 : dist[i]);
	
	return 0;
}
```

---


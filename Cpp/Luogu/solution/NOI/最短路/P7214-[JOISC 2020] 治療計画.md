# [JOISC 2020] 治療計画

## 题目背景

因为本题数据点过多，另外 $3$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127700) 测试。

JOI 村庄的村民们最近发生了 COVILLAGE-19 疫情！

## 题目描述

JOI 村庄有 $N$ 个房屋，编号为 $1$ 到 $N$，每个房屋住有一个村民，第 $i$ 个房屋居住编号为村民 $i$。

现在，这 $N$ 个房屋里的村民全部感染 COVILLAGE-19 病毒，有 $M$ 个治疗方案被提出，第 $i$ 个治疗方案描述为，在第 $T_i$ 天的晚上，编号在 $[L_i,R_i]$ 区间内的村民被治愈。

COVILLAGE-19 病毒还会继续传播，在某天早上，如果村民 $i$ 被感染，那么村民 $i+1$ 和村民 $i-1$ 也会被感染，因为病毒威力巨大，所以被治愈的村民有可能再次被感染。

您是 JOI 国的总理，您要选择一些方案使得 JOI 村庄所有村民全部被治愈，一天可以进行很多方案。

第 $i$ 个方案要花费 $C_i$，求最小花费。

## 说明/提示

#### 样例 1 解释

执行过程如下（红色为被病毒感染，绿色为治愈）：

1. 在第二天晚上，执行第 $1$ 个方案，情况如下：

$$\color{Red}1\ 2\ 3\ 4\color{Green}\ 5\ 6\ 7\ 8\ 9\ 10$$

2. 在第三天早上，村民 $5$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\color{Green}\ 6\ 7\ 8\ 9\ 10$$

3. 在第四天早上，村民 $6$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

4. 在第四天晚上，执行第 $5$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\color{Red}\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

5. 第五天早上，村民 $3,7$ 被感染，情况如下：

$$\color{Green}1\ 2\color{Red}\ 3\ 4\ 5\ 6\ 7\color{Green}\ 8\ 9\ 10$$

6. 在第五天晚上，执行第 $3$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$$

全部治愈，这三个方案花费为 $7$，为最小花费。

#### 样例 2 解释

无法使得所有村民全部治愈。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$T_i=1$|$4$|
|$2$|$M \le 16$|$5$|
|$3$|$M \le 5000$|$30$|
|$4$|无|$61$|

对于 $100\%$ 的数据，$1 \le N,T_i,C_i \le 10^9$，$1 \le M \le 10^5$，$1 \le L_i \le R_i \le N$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 C 治療計画](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
10 5
2 5 10 3
1 1 6 5
5 2 8 3
7 6 10 4
4 1 3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
10 5
2 6 10 3
1 1 5 5
5 2 7 3
8 6 10 4
4 1 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 5
1 5 10 4
1 1 6 5
1 4 8 3
1 6 10 3
1 1 3 1```

### 输出

```
7```

# 题解

## 作者：George1123 (赞：13)

驯狗 $\to$ [`George1123`](https://www.cnblogs.com/George1123/p/14234926.html)

---

## 题面

> [JOISC2020 治療計画](https://www.luogu.com.cn/problem/P7214)

> 有 $m$ 个染病的染病的村民，有 $n$ 个治疗计划，$(t_i,l_i,r_i,c_i)$ 表示第 $t_i$ 天晚上 $[l_i,r_i]$ 的村民被治疗好，耗费 $c_i$。如果一个村民第 $i$ 天早上染病，就会传染村民 $i-1$ 和 $i+1$，求最小的代价，治疗所有的村民。

> 数据范围：$1\le m,t_i,c_i\le 10^9$，$1\le n\le 10^5$。

---

## 题解

狗的 $n$ 和 $m$ 与题目中的相反，且区间左闭右开，狗感觉这样更合适一些。 

### Subtask $2,3$

想象一下一张时间-村民的二维图，一个格子是黑色或白色，黑色表示染病。

可以发现，这个曲折的边界就是一条从图左端到右端的路径。

如果把每个治疗计划当作节点，题目就转化为了求点权最短路。

如果 $r_u-l_v\ge |t_u-t_v|$，有边 $(u,v)$。

直接建图跑图时间复杂度 $\Theta(n^2\log n)$，可以拿到 $35$ 分。

### Subtask $1,4$

势能线段树优化建图。

为什么能保证松弛次数为 $\Theta(n)$？

因为权在点上，如果用 `dijkstra` 堆优化，每个点进队一次即可，并且第一次得到的距离就是真距离。

所以可以建一棵势能线段树，维护两个值，分别解决 $v<u$ 和 $v>u$ 的情况。

线段树的下标是节点，维护的是限制值的最小值，每次连完边以后把维护值置为 $+\infty$。

时间复杂度 $\Theta(n\log n)$。

---

## 代码

注意 $+\infty$ 的大小和 `long long` 的问题啊，啊啊啊，啊啊啊啊啊啊啊啊啊啊。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define x first
#define y second
#define bg begin()
#define ed end()
#define pb push_back
#define mp make_pair
#define sz(a) int((a).size())
#define R(i,n) for(int i(0);i<(n);++i)
#define L(i,n) for(int i((n)-1);i>=0;--i)
const int iinf=0x3f3f3f3f;
const ll linf=0x3f3f3f3f3f3f3f3f;

//Data
const int N=1e5;
int m,n;
ll f[N];
struct info{
    int t,l,r,c;
    info(){}
    info(int t,int l,int r,int c):
        t(t),l(l),r(r),c(c){}
}a[N];

//Graph
/*
    思考：什么时候 i 后面可以接 j？
        a[i].r-a[j].l>=abs(a[i].t-a[j].t)
    如果 a[j].t<a[i].t，要求就是
        a[i].r-a[i].t>=a[j].l-a[j].t ->up
    如果 a[j].t>a[i].t，要求就是
        a[i].r+a[i].t>=a[j].l+a[j].t ->dn
    
    这题有个关键点：权在点上，所以 dijkstra 可以爽一点
*/
vector<int> adj; // 记得清空
priority_queue<pair<ll,int>> q;

//SegmentTree
struct tree{
    int l,r,mid,ma,mb; tree *ls,*rs;
    tree(int l,int r):l(l),r(r),ma(iinf*2),mb(iinf*2){
        if(r-l==1) return;
        mid=(l+r)>>1,ls=new tree(l,mid),rs=new tree(mid,r);
    }
    void pushup(){
        ma=min(ls->ma,rs->ma);
        mb=min(ls->mb,rs->mb);
    }
    void fix(int i,int a,int b){
        if(r-l==1) return ma=a,mb=b,void();
        i<mid?ls->fix(i,a,b):rs->fix(i,a,b),pushup();
    }
    void adde(int x,int y,int mx,bool t){
        if((t?ma:mb)>mx) return;
        if(r-l==1) return ma=mb=iinf*2,adj.pb(l);
        if(x<mid) ls->adde(x,y,mx,t);
        if(y>mid) rs->adde(x,y,mx,t);
        pushup();
    }
};

//Function

//Main
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>m>>n;
    R(i,n) cin>>a[i].t>>a[i].l>>a[i].r>>a[i].c,--a[i].t,--a[i].l;
    sort(a,a+n,[&](info p,info q){return p.t<q.t;});
    tree *rt=new tree(0,n);
    R(i,n){
        if(a[i].l==0) f[i]=a[i].c,
            q.push(mp(-f[i],i)),rt->fix(i,iinf*2,iinf*2);
        else rt->fix(i,a[i].l-a[i].t,a[i].l+a[i].t),f[i]=linf;
    }
    while(sz(q)){
        int u=q.top().y; q.pop(),adj.clear();
        rt->adde(0,u,a[u].r-a[u].t,true);
        rt->adde(u+1,n,a[u].r+a[u].t,false);
        for(int v:adj) f[v]=f[u]+a[v].c,q.push(mp(-f[v],v));
    }
    ll ns=linf;
    R(i,n)if(a[i].r==m) ns=min(ns,f[i]);
    if(ns==linf) ns=-1;
    cout<<ns<<'\n';
    return 0;
}
```

---

**祝大家学习愉快！**

---

## 作者：Komomo (赞：8)

先把这玩意儿放在平面上看一看。

一个治疗计划 $(t_i,l_i,r_i)$，对应的是平面上的一条线段 $((l_i,t_i), (r_i,t_i))$，以这条线段为斜边做一个等腰直角三角形，就是能治疗的二维范围。

![](https://cdn.luogu.com.cn/upload/image_hosting/v9dzruyl.png)

我们对这些割边一样的东西连边，每个三角形就是一个点，令 $dis_i$ 表示在 $t_i$ 时刻能治疗好前缀为 $r_i$ 所有人的最小代价，跑出来的最短路就是答案，但是连边是 $n^2$ 的。观察到连边的条件是 $|t_i-t_j|\le r_i-l_j+1$，排序 $t$ 可以把绝对值拆开。

![](https://cdn.luogu.com.cn/upload/image_hosting/eci6rgpi.png)

而且红色路径不一定连续，对于出现上面那种相离但是连边的情况，能保证 $i$ 和左侧一定联通，$j$ 和右侧一定联通，说明 $i$ 的“着陆点”一定是在 $j$ 与右侧联通的路径上的。如下图，一红一蓝的点对应上面路径的“着陆点”，即使相离也是合法的。

然后这里有一个关键结论：点权最短路能保证每个点只被松弛一次，这个是容易理解的，于是我们把开头的都入队，然后直接线段树上找决策点就好。

---

## 作者：xht (赞：5)

我们以横坐标为时间轴，纵坐标为位置轴构建平面直角坐标系。

考虑一个治疗方案 $(T_i,L_i,R_i)$ 单独在这样一个坐标系中的覆盖区域，可以发现其覆盖的区域为以 $(T_i,L_i),(T_i,R_i)$ 为两个 $45^\circ$ 角向右的一个等腰直角三角形。

特别地，对于 $L_i = 1$ 的方案，它还能多覆盖一点三角形下方的区域；对于 $R_i = n$ 的方案，它还能多覆盖一点三角形上方的区域。具体可以自己手画一下。

由于最终要求所有人都被治愈，因此一个方案合法当且仅当这些区域可以**拼接**起来且使某个 $L_i=1$ 的方案与某个 $R_i = n$ 的方案**连通**。

注意，这里的**拼接**并不是指**有交**，对于方案 $i,j$，$i$ 可以与 $j$ 单向地拼接当且仅当 $|T_i-T_j|\le R_i - L_j + 1$，具体也可以自己手画一下。

显然，求解这个问题就是一个最短路。

直接连边边数是 $\mathcal O(m^2)$ 的，显然无法承受，用线段树 + `set` 优化连边即可。

这个优化连边的 Trick 跟 [P5471 [NOI2019]弹跳](https://www.luogu.com.cn/problem/P5471) 很像。具体来说，在点权最短路上，每个点最多只会被松弛一次，即对于每个点，第一次更新到它时的值就是它的最短路（在边权最短路中这显然是不一定的）。于是我们可以在某一个点被更新过就立刻删掉它，这样时间复杂度就与边数无关，为 $\mathcal O(n \log n)$ 了。

这两道题都有一个共同点是，二维平面上从一个点到一个区域连边跑点权最短路，于是我们可以用一棵线段树维护第一维，线段树中每个节点用一个 `set` 存下在第一维里这个区间内的所有点，这样每个点被复制了 $\mathcal O(\log m)$ 次，总点数为 $\mathcal O(m \log m)$，跑上述所说的点权最短路，总时间复杂度为 $\mathcal O(m \log^2 m)$。

```cpp
const int N = 1e5 + 7;
const ll inf = 1e18;
int n, m;
struct P {
	int t, l, r, c;
	inline void in() { rd(t), rd(l), rd(r), rd(c); }
	inline bool operator < (const P o) const { return t < o.t; }
} p[N];
struct T {
	int l, r;
	set<pi> s;
} t1[N<<2], t2[N<<2];
ll d[N], ans = inf;
pq<pair<ll, int>> q;
bool v[N], w[N];

void build(T* t, int p, int l, int r) {
	t[p].l = l, t[p].r = r;
	if (l == r) return;
	build(t, ls, l, md), build(t, rs, md + 1, r);
}

void ins(T *t, int p, int x, pi k) {
	t[p].s.insert(k);
	if (t[p].l == t[p].r) return;
	if (x <= md) ins(t, ls, x, k);
	if (x > md) ins(t, rs, x, k);
}

void upd(T *t, int p, int l, int r, int x, ll k) {
	if (l <= t[p].l && r >= t[p].r) {
		while (t[p].s.size() && t[p].s.begin() -> fi <= x) {
			int y = t[p].s.begin() -> se;
			t[p].s.erase(t[p].s.begin());
			if (w[y]) continue;
			d[y] = k + ::p[y].c, q.push(mp(-d[y], y)), w[y] = 1;
		}
		return;
	}
	if (l <= md) upd(t, ls, l, r, x, k);
	if (r > md) upd(t, rs, l, r, x, k);
}

int main() {
	rd(m), rd(n);
	for (int i = 1; i <= n; i++) p[i].in();
	sort(p + 1, p + n + 1);
	build(t1, 1, 1, n), build(t2, 1, 1, n);
	for (int i = 1; i <= n; i++)
		ins(t1, 1, i, mp(p[i].l - p[i].t, i)),
		ins(t2, 1, i, mp(p[i].l + p[i].t, i));
	for (int i = 1; i <= n; i++)
		if (p[i].l != 1) d[i] = inf;
		else d[i] = p[i].c, q.push(mp(-d[i], i)), w[i] = 1;
	while (q.size()) {
		int x = q.top().se;
		q.pop();
		if (v[x]) continue;
		v[x] = 1;
		if (x != 1) upd(t1, 1, 1, x - 1, p[x].r - p[x].t + 1, d[x]);
		if (x != n) upd(t2, 1, x + 1, n, p[x].r + p[x].t + 1, d[x]);
	}
	for (int i = 1; i <= n; i++)
		if (p[i].r == m) ans = min(ans, d[i]);
	print(ans == inf ? -1 : ans);
	return 0;
}
```

---

## 作者：7KByte (赞：4)

有删减，原文见[**我的博客**](https://www.cnblogs.com/SharpnessV/p/14882600.html)。

最关键的一步，转化为最短路。

对于每个方案我们看成一个点，对于两个方案 $i,j$ ，当且仅当 $R_i-L_j+1\ge|T_i-T_j|$ 时，从点 $i$ 向点 $j$ 连边。

形象化的，我们将时间作为纵轴，房屋作为横轴，发现一次治疗就是一条平行于横轴的路径，而两次治疗之间的衔接恰好是一条斜率为 $1$ 或 $-1$ 的直线。所以最短路就是答案。

直接建图跑最短路是 $\mathcal{O}(N^2)$ 的，考虑优化建图。

我们对所有点按 $T_i$ 排序，那么当 $T_i\ge T_j$ 时，有 $R_i-T_i+1\ge L_j-T_j$ ，否则是 $R_i+T_i+1\ge L_j+T_j$ 。

式子一边只与 $i,j$ 中的一个有关，可以看作点的属性，那么我们只需要再满足 $T_i$ 和 $T_j$ 的大小关系。

直接线段树优化建图。线段树优化的最短路有一个优美的性质就是线段树上的边只会转移一次，所以时间复杂度是 $\mathcal{O}(N\log N)$ 。

关于这个性质可以参考这道[**经典题**](https://www.luogu.com.cn/problem/P5471)，也是线段树优化最短路。

---

## 作者：mazihang2022 (赞：4)

先从 DP 考虑。以计划做状态不好，因为表示不了具体的感染人数。

发现关键在于两端，最后必然是 $1$ 这一端病毒没了，然后只会有病毒从另一边往 $1$ 扩散，$n$ 那一端同理。

所以 DP 就应该设计成 $f_i$ 表示使得 $[1,i]$ 中没有病毒的最小代价。注意这个 DP 不一定是按时间转移的，只要两段治疗计划拼的上就行。

从另一个角度考虑。可能会想到每天感染者的段会扩张。不如反过来，相当于每天之前的治疗计划会缩小，直到某次用新的计划和它拼接起来，直到最终拼成 $[1,n]$。

综合起来，我们的方案是：从 $1$ 这一端开始，每次拼接一段治疗计划直到拼到 $n$ 端，这样的话，每次拼完之后一定是 $[1,i]$ 的一段。

其实这玩意有点像最短路：推一下能知道 $i,j$ 能拼在一起的条件是 $r_i-l_j+1\ge |t_j-t_i|$，代价在点上。

大概是可以直接主席树优化建图的？

权在点上的最短路有一个性质：每个点最多被松弛一次。

拆开绝对值，以 $r_i-l_j+1\ge t_j-t_i\Rightarrow r_i+t_i+1\ge t_j+l_j$ 为例，按照 $t$ 为下标建立线段树，线段树上每个点维护 $t_j+l_j$ 的最小值，只要最小值 $\le r_i+t_i+1$ 就暴力递归松弛，松弛完最小值直接设为 $\inf$。时间复杂度 $O(n\log n)$。

---

## 作者：wjyppm1403 (赞：1)

[可能更好的阅读体验](https://worldcpu.github.io/posts/d30abee3/)

把未感染和感染抽象为 $0/1$，那么原问题可以转化为初始有一个全为 $1$ 的序列，可以在特定时间进行一次区间覆盖操作（有代价），$1$ 会向左右扩散，问能不能将整个序列全部覆盖为 $0$ 且使得操作代价最小。

对于选择区间进行覆盖的问题，这一类经典问题有一种状态设计就是设 $f(i)$ 表示将 $[1,i]$ 这个前缀进行覆盖的最小代价。但是问题在于这样转移是 $O(nm)$ 的不太好搞，考虑这个 $m$ 的瓶颈就是在于我们需要知道每一个覆盖区间右端点在哪里。考虑切换一下 dp 状态，设 $f(i)$ 表示将 $[1,r_i]$ 覆盖的最小代价，转移通过 $t$ 的偏序关系进行转移：

$$\begin{aligned}f(i) & \leftarrow f(j)+c_i & r_j -l_i+1 \ge |t_i -t_j| \end{aligned}$$

时间复杂度还是 $O(nm)$，无敌了。而且还自带两个偏序关系更是逆天。但是观察这个 DP 是一个类似于最短路形式的转移（不说人话就是转移代价只和目标的代价有关），考虑用 Dijkstra 优化这个 DP。让后绝对值可以通过对 $t$ 排序去掉，对于转移可以用线段树优化这个最小值转移，势能分析有时间复杂度 $O(n \log n)$。

这个题目有一个巨大的卡阻就是在于 DP 容易选择会以时间作为主体，这样的话你无论怎么都无法优化掉时间这一维。一开始想的就是 $f(i,j)$ 添加了时间 $j$ 这一个维度，但是发现这个枚举时间反而成为了瓶颈。这个时候，我们需要分析，**我们知道什么就够了**。分析下来 $j$ 反而可以从转移中天然的去掉，这样我们就做到了优化 DP 的过程。

```cpp
#include<bits/stdc++.h>
#include <queue>
#define int long long
#define pir pair<int,int>
using namespace std;
constexpr int MN=5e5+15,INF=1e18;
struct Node{
    int l,r,c,t;
}a[MN];
int n,m,f[MN],ans=INF;
bool vis[MN];
priority_queue<pir,vector<pir>,greater<pir>> q;

struct Segment{
    #define ls p<<1
    #define rs p<<1|1
    struct Node{
        int l,r,mn[2];
    }t[MN<<2];

    void pushup(int p){
        t[p].mn[0]=min(t[ls].mn[0],t[rs].mn[0]);
        t[p].mn[1]=min(t[ls].mn[1],t[rs].mn[1]);
    }

    void build(int p,int l,int r){
        t[p].l=l;
        t[p].r=r;
        t[p].mn[0]=t[p].mn[1]=INF;
        if(l==r) return;
        int mid=(l+r)>>1;
        build(ls,l,mid);
        build(rs,mid+1,r);
    }

    void modify(int p,int pos,int x,int y){
        if(t[p].l==t[p].r){
            t[p].mn[0]=x-y;
            t[p].mn[1]=x+y;
            return;
        }
        int mid=(t[p].l+t[p].r)>>1;
        if(mid>=pos) modify(ls,pos,x,y);
        else modify(rs,pos,x,y);
        pushup(p);
    }

    void update(int p,int fl,int fr,int op,int v,int w){
        if(t[p].mn[op]>v) return;
        if(t[p].l==t[p].r){
            f[t[p].l]=w+a[t[p].l].c;
            q.push(pir(f[t[p].l],t[p].l));
            t[p].mn[0]=t[p].mn[1]=INF;
            return;
        }
        int mid=(t[p].l+t[p].r)>>1;
        if(mid>=fl) update(ls,fl,fr,op,v,w);
        if(mid<fr) update(rs,fl,fr,op,v,w);
        pushup(p);
    }

    #undef ls
    #undef rs
}sg;

bool cmp(Node x,Node y){
    return x.t<y.t;
}

void dijkstra(){
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=m;i++){
        if(a[i].l==1){
            f[i]=a[i].c;
            q.push(pir(f[i],i));
            sg.modify(1, i, INF, 0);
        }else sg.modify(1, i, a[i].l, a[i].t);
    }
    while(!q.empty()){
        auto fr=q.top();
        q.pop();
        int u=fr.second;
        if(vis[u]) continue;
        vis[u]=1;
        sg.update(1,1,u-1,0,a[u].r-a[u].t+1,f[u]);
        sg.update(1,u+1,m,1,a[u].r+a[u].t+1,f[u]);
    }
}

signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a[i].t>>a[i].l>>a[i].r>>a[i].c;
    }
    sort(a+1,a+1+m,cmp);
    sg.build(1,1,m);
    dijkstra();
    for(int i=1;i<=m;i++){
        if(a[i].r==n){
            ans=min(ans,f[i]);
        }
    }
    if(ans>=INF) cout<<-1;
    else cout<<ans;

    return 0;
}
```

---

## 作者：AC_love (赞：1)

题解区大家都是线段树做法，这里提供一个有点劣但很好理解的 KDT 做法。

先考虑简化版的问题：如果没有时间限制，把每个计划抽象成一条线段，我们要做的其实就是选代价最小的线段覆盖 $[1, m]$ 的区间。

这个东西本质就是带权最小线段覆盖，我们考虑一个最短路做法。

考虑每条线段接下来的后一条线段可以是哪些，显然只要两条线段相交，我们就可以从前面的线段向后面的线段连边，连好所有边之后跑一遍点权最短路即可。但这样连出来的边数是 $O(n^2)$ 的，考虑线段树优化建图，这样就确保连出的边数是 $O(n \log n)$ 的。

现在有了时间限制，加一维时间轴，此时每个治疗计划都可以抽象成一个斜边的两个端点为 $(l_i, t_i), (r_i, t_i)$ 的等腰直角三角形。此时我们仍然要覆盖 $[1, m]$ 的区间，不过从选代价最小的线段变成了选代价最小的等腰直角三角形。

这个东西怎么做？其实和刚才差不多，仍然是每个等腰直角三角形向它能覆盖的等腰直角三角形连边，注意到 $i$ 能向 $j$ 连边当且仅当 $|t_i - t_j| \le r_i - l_j + 1$。

更形象地说，每个点连边的区间，应该在一个斜边与时间轴重合的等腰直角三角形中。

一个点向一个一维的线段连边，我们可以用线段树优化建图解决。而一个点向一个二维的区域连边，我们考虑用 KDT 或二维线段树优化建图。

但 KDT 只能解决四边与坐标轴平行的矩形的问题，目前我们的二维区域是一个斜边与时间轴重合的等腰直角三角形，所以我们考虑将坐标轴旋转 $45\degree$，然后再用 KDT 优化建图。

此时我们发现：这个问题完全被转化成了 [P5471](https://www.luogu.com.cn/problem/P5471)。事实上，我的本题代码也是完全照搬自我写的那道题的代码，稍加修改就能 AC。

不过一个需要注意的细节是：由于这个做法涉及到旋转坐标轴，旋转之后的坐标是个浮点数，会产生精度误差，所以需要设置一个允许存在误差的范围来避免在这个地方挂掉。而且不要设置的太小，我设置成 $10^{-7}$ 时会在一些点上挂掉，设成 $10^{-5}$ 才能 AC。

还有更多代码上的细节，无法一一赘述，因此提供一份参考代码。

[code](https://atcoder.jp/contests/joisc2020/submissions/62904145)

---


# 「Wdoi-1.5」旅人 1977

## 题目背景

深邃的星空中划出了一道灿烂的弧线，而后又同这广袤境界溶为一体，二十世纪的旅行者，承载着期待与不安向着外太空飞去。这是一份来自一个遥远的小小世界的礼物。上面记载着我们的声音、我们的科学、我们的影像、我们的音乐、我们的思想和感情。我们正努力生活过我们的时代，进入你们的时代。或许人类将失去对它的联系，它也将像一个漂流瓶一样，向着宇宙深处孤独的走下去，直到被「另一个人」所捡起。而它为我们留下的最后一张「自拍」，也只是一个 $0.12$ 像素大的、淡蓝色的光点 —— 这是我们迄今所知的唯一家园。

$\kern{80pt}$![](https://cdn.luogu.com.cn/upload/image_hosting/qbelj85l.png)  
$$\scriptscriptstyle\text{暗淡蓝点，旅行者 1 号，1990年 2 月 14 日}$$
「已经分不清现实与梦境了呢。」  
「或许，梦与现之间的境界，本就没有那么明晰。」

……

「真是的，莲子你不是自称亲近星光与月亮的嘛，怎么也不抬头看看。」

正欲向笔记本上添加几行，借以目视的月光陡然暗淡。眼前垂落的金色长发挡住了我的视线。轻咳了一声，抬起手在面前挥舞，把他们从视野中赶走，我转头看着后背。
眼前戴着白色帽子的少女便是我的同伴梅莉。我常常打趣她有着奇异的眼睛，可以看到我们所看不到的「境界」。尽管我自己的眼睛也十分特殊——我有着通过星光与月亮就知道我们现处何时何地的能力。忘了说了，我们是学生秘密社团『秘封俱乐部』，专门探寻科学世纪下的隐藏结界。  
在这个夏夜，我本着履行对她承诺的想法，来到野外，观察天体的运行。

「在想什么呢？」  
这个问题不好回答呢。不过，既然今天和梅莉约好出来观赏星空，那么，思路被引向人们曾经的探索和求知，便是十分自然的了。  
「唔，我在想，我们现今，科学世纪的起源。」  
「嗯？莲子你不是研究物理的吗，怎么突然思考其这种问题了？」  
梅莉把头朝右侧一歪，我指指天空，她随即坐在了一旁，把目光投向灿烂的星海。  
「唔，我在想，我们现今，科学世纪的起源。还记得我和你说过的那两位旅人吗？」  
「旅行者一号与旅行者二号？」  
「没错。直到如今都没有人为任何深空计划取名为旅行者。带着如此诗意而感性名称的它们代表的是人们对未来的期许与对真理的渴望。面对未知与迷茫，义无反顾冲向了星海。」 

梅莉站了起来，举起了双筒望远镜。她的身影在暗淡而幽静的夜色中来回移动，皎白得似有彩色光晕的月光从穹顶透过树叶与树枝的缝隙在她身上落下光斑，看着让人心醉。  

超新星爆发是恒星生命的终点，也是新生恒星生命的起点。谁能说科学已经到了尽头，无法解释的事物不存在呢？科学的核心在于那些被视为空花阳焰，藏在迷雾中的东西，而绝非那些狂妄自大的老头们所说，科学是我们掌握的一切已知。  
对我们而言，这是不言而喻的。我们追随那位初代社长的脚步，探寻遍布四处的结界，寻求隐藏在未知背后真理的一角，正是出于这样的信念。

晷刻渐移，点点星尘围绕着北极星作着圆周运动。仔细看的话，北极星也在微微运动。在我的视线前方，梅莉兴奋地对着从英仙座辐射而出，偶尔划过天穹的流星发出惊叹。我不禁思索起来，现在勾陈一作为最接近北天极的恒星行使着为旅人指点方向的责任，但在永恒的运动中，永远会有新的谜题，新的未知，新的探索等着我们去发现。  

物如此，事犹是，人亦然。前路永远有着未知的事物等着我们去探索。如果解明了所有的秘密，之后就会什么都不剩。知晓万物什么的，只不过是空空如也的虚无罢了。未知，才是驱动人类的原动力 $\scriptscriptstyle{}^{[{\color{grey}{1}}]}$。我们希冀着如同那两位先行者一般，作为开拓者，唤起根植于人们心中对未知的好奇与探索精神，并将它薪火相传。  
身虽位于苍穹一粟，心亦向往若尘繁星。  
身旁的梅莉靠在一棵树下，已经发出规律的鼾声，身体规律地微微起伏着。我伸手拨开她的手掌，撩开她垂下的头发，拿出她的笔记本。
>从夜晚走向清晨。  
从清晨走向夜晚。  
从现实走向梦境。  
从梦境走向现实。  
终有一天，我们会在梦中，邂逅那片未经观测的星空。$\scriptscriptstyle{}^{[{\color{grey}{2}}]}$

$\scriptscriptstyle{[1],[2]}\text{：引用自 }$ [here](https://bbs.nyasama.com/forum.php?mod=viewthread&tid=308054&page=2)

## 题目描述

深邃的星空可以被视作一张有向图，图上的节点就是点点恒星。点无点权，边有边权。图的点数为 $n$，边数为 $m$，图可能有重边自环。但保证至少有一条路径可以从 $s$ 走到 $t$（$s$、$t$ 在输入中给定）。第 $i$ 条有向边起点为 $u_i$，终点为 $v_i$，它的权值用一个有序三元组 $(l_i,r_i,w_i)$ 表示。

莲子要从点 $s$ 出发，经过了若干条边到达点 $t$。她带有一个初始值均为 $0$ 的长度为 $k$ 的数组 $a$，每次经过编号为 $i$ 的边，就会执行将 $a$ 数组的区间 $[l_i,r_i]$ 加 $w_i$ 的操作。她使用了一棵**带懒标记**的线段树来维护这一操作。线段树的写法会在接下来给出。

你需要构造一条从 $s$ 到 $t$ 的路径，满足达到结点 $t$ 时，其线段树上所有标记的和的最小。输出这个最小值。

以下是线段树的伪代码：（为了方便选手阅读，题目附件中给出了线段树的 C++ 源代码）

$$
\begin{array}{l}\hline\hline\\[-0.8em]
\textbf{Algorithm: }\text{SegTree}\\\hline\\[-0.5em]
\begin{array}{rl}
1& \mathbf{Input.} \text{ 长度为 $k$ 的 $a$ 数组，初始全为 $0$}\\
2& \mathbf{Output.} \text{ $a$ 数组进行若干次区间加操作后得到的结果}\\
3& \mathbf{Method.}\\
4& \mathrm{Add}(L,R,x)\\
5& \quad\mathrm{Add0}(L,R,x,root,1,k)\\
6& \mathrm{Add0}(L,R,x,u,l,r)\\
7& \quad\mathbf{if}\ L \le l\ \mathbf{and}\ r\le R\\
8& \quad\quad \mathrm{tag}(u) \gets \mathrm{tag}(u) + x\\
9& \quad\quad \mathbf{return}\\
10& \quad mid \gets \lfloor\frac{l+r} 2\rfloor\\
11& \quad \mathrm{tag}(\mathrm{lson}(u)) \gets \mathrm{tag}(\mathrm{lson}(u))+\mathrm{tag}(u)\\
12& \quad \mathrm{tag}(\mathrm{rson}(u)) \gets \mathrm{tag}(\mathrm{rson}(u))+\mathrm{tag}(u)\\
13& \quad \mathrm{tag}(u) \gets 0\\
14& \quad\mathbf{if}\ L \le mid\\
15& \quad\quad\mathrm{Add0}(L,R,x,\mathrm{lson}(u),l,mid)\\
16& \quad\mathbf{if}\ mid < R\\
17& \quad\quad\mathrm{Add0}(L,R,x,\mathrm{rson}(u),mid+1,r)\\
\end{array}\\\hline\hline
\end{array}
$$

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/npzajpom.png)

容易发现，样例 $1$ 中有且仅有两条可能的路径：$1\to 2\to 4$ 与 $1\to 3\to 4$。下面分别计算这两条路径最终 $\text{tag}$ 的权值和。

![](https://cdn.luogu.com.cn/upload/image_hosting/2fq7okad.png)

考虑画出这棵 $k=5$ 的线段树。

![](https://cdn.luogu.com.cn/upload/image_hosting/ys42i046.png)

走了边 $1\to 2$ 后，$[1,2]$ 节点被打上了权值为 $2$ 的 $\text{tag}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/02sqysh5.png)

走了 $2\to 4$ 后，$[2,2]$ 节点和 $[3,3]$ 节点被打上了值为 $1$ 的 $\text{tag}$；但是 $[1,2]$ 节点的标记进行了下推（因为使 $[2,3]$ 区间 $+1$ 的时候会访问到 $[1,2]$ 节点，而 $[1,2]\nsubseteq[2,3]$，故而发生标记下推），因此 $[1,1]$ 节点和 $[2,2]$ 节点的 $\text{tag}$ 分别加上了 $2$，最终成了如图所示的模样。

因此走到 $4$ 之后所有结点的 $\text{tag}$ 之和为 $2+3+1=6$。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/3va7fa03.png)

对于另外一条路径，首先对 $[4,5]$ 加上 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/o1cw3s03.png)

接着对 $[3,5]$ 加上 $2$。未发生带有 $\text{tag}$ 的节点的标记下推，因此最终的权值为 $2+3=5$。

由于 $6>5$，因而最终的答案为 $5$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{subtask}& \textbf{分值}& {\bm n\le} & {\bm m\le} & {\bm k\le} & \textbf{特殊性质} & \textbf{subtask 依赖}\cr\hline
1 & 10& 10 & 30 & 5 & - & -\cr\hline
2 & 5&30 & 30 & 12 & \textbf{AB} &-\cr\hline
3 & 20&30 & 500 & 12 & \textbf{B} &2 \cr\hline
4 & 15&200 & 3\times 10^3 & 25 & \textbf{B}&3\cr\hline
5 & 50&200 & 3\times 10^3 & 25 & - &4\cr\hline
\end{array}
$$

- **特殊性质** $\textbf{A}$：保证有且仅有一条从 $s$ 到 $t$ 的路径。
- **特殊性质** $\textbf{B}$：保证图中不存在环。

对于 $100\%$ 的数据，有 $1 \le s,t,u_i,v_i \leq n \leq 200$，$1 \leq m \leq 3\times 10^3$，$1 \leq l_i\le r_i \leq k \leq 25$，$1 \leq w_i \leq 10^3$。

### 提示

在附件中有两个版本的线段树。$\text{Lite}$ 版本**仅**包含了在本题中你会用到的下推标记的操作，而标准版则较为完整地支持区间加、区间求和。选手可根据自己的喜好使用。

## 样例 #1

### 输入

```
4 4 5 1 4
1 2 1 2 2
1 3 4 5 1
2 4 2 3 1
3 4 3 5 2```

### 输出

```
5```

## 样例 #2

### 输入

```
10 19 5 6 1
2 1 1 3 592
6 8 3 5 488
10 9 4 4 548
10 4 1 4 442
6 5 1 3 422
9 7 1 4 529
5 8 1 1 559
5 9 1 5 560
5 8 2 3 434
5 9 3 3 592
4 7 2 2 594
7 9 5 5 595
4 1 4 4 501
3 9 1 2 410
10 6 2 4 509
6 10 4 5 455
2 4 2 5 444
4 3 4 5 541
8 7 1 1 463
```

### 输出

```
2295
```

# 题解

## 作者：囧仙 (赞：9)

## 题解

### $\textbf{Subtask 1}$

容易发现一条边走多次总是不优的。因此可以直接暴力 $\text{dfs}$。

### $\textbf{Subtask 2}$

用来给选手确认一下题意是否理解正确，因此设置了这个相当于是骗分的点。

### $\textbf{Subtask 3 \& 4}$

开始进入正题。考虑一条边究竟会对最终的结果产生多大的贡献。容易发现，一条边产生的贡献会受到这条边之后的边对 $\text{tag}$ 的更新的影响。因此正着推是非常困难的（无法消除后效性）。不妨反过来想，只要知道了从一个点到达终点到底有哪些位置被更新了 $\text{tag}$，就可以很好地计算出 $w_i$ 产生的贡献的次数。

于是可以把所有的边反过来然后 $\text{dp}$，对于点 $i$ 记录一个状态 $u$，表示从它到达终点会有哪些节点**会被产生更新**。更新过程有这样一个特点：每次更新是自上而下的，下边某个节点的向下更新肯定是在它父亲节点向下更新之后。同时还有一个特点，每当一个带有 $\text{tag}$ 的节点向下更新后，带有这个 $\text{tag}$ 的节点个数恰好会增加 $1$ 个。但是会有一些实现细节上的问题，这也就区分了这两个 $\text{Subtask}$。

值得注意的是，所有的叶子节点是不会被更新的，因此维护的状态不需要存储最底下这一层，下文把非叶节点称作**有效节点**。也就是下图当中红色的部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/z8sfu6fv.png)

首先使用 $\text{dfs}$ 对**有效节点**进行编号。记有效节点个数为 $s$，那么 $s$ 大约是 $k$ 左右。可以发现有效节点可以进行状压，放到一个 $\text{unsigned}$ 里边。对于这两个 $\text{Subtask}$，图上是一个 $\text{DAG}$，因此可以按照拓扑排序的顺序进行处理。对于每条边 $(u_i,v_i,l_i,r_i,w_i)$，考虑枚举 $v_i$ 的状态（设枚举的状态为 $y$），由此更新出 $u_i$ 对应状态的结果（设为 $x$）。那么我们需要计算这两个东西：

- $[l_i,r_i]$ 作用于线段树上会给多少个节点打上 $\text{tag}$。记为 $\mathit{num}_{l,r}$。
- $[l_i,r_i]$ 作用于线段树上后，哪些节点向下更新会导致 $w_i$ 贡献次数 $+1$。记为 $\mathit{A}_{l,r}$。
- $[l_i,r_i]$ 作用于线段树上会推动哪些节点向下更新 $\text{tag}$。记为 $\mathit{B}_{l,r}$。

其中 $A_{l,r}$ 和 $B_{l,r}$ 都是状态压缩后的状态。由于 $1\le l_i\le r_i\le k$，因此可以直接 $k^3$ 暴力预处理出这三个东西。放一个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/46kelr1f.png)

这张图展现了 $(2,6)$ 这样一条边的情况。我们应该预处理出被标成**浅蓝色**的这些节点所组成的状态为 $A_{l,r}$，深蓝色的节点组成的状态为 $B_{l,r}$。同时还需要计算出这条边实际给多少个节点打上了 $\text{tag}$，这个例子当中是 $2$（$[2,5)$ 和 $[5,7)$）。要注意，统计 $\mathit{num}_{l,r}$ 时**不能忽略**叶子节点被打上 $\text{tag}$ 的情况（这个例子里没有出现这样的情况而已）。

![](https://cdn.luogu.com.cn/upload/image_hosting/if902fls.png)

$(u,v,l,r,w)$ 是原图上的一条边。现在是 $\mathit{dp}$ 的一个更新过程。此时 $v$ 的状态为 $y$，边权为 $(l,r,w)$。现在需要从 $v:y$ 反向向前推导出 $u:x$ 并更新。重申一下这里记号的含义：$y$ 表示从 $v$ 到中点，会有哪些有效节点向下更新；$A_{l,r}$ 记录的是哪些有效节点被更新会导致 $w$ 的贡献次数 $+1$；$B_{l,r}$ 记录的是 $[l,r]$ 作用于线段树上会有哪些有效节点向下更新；$\mathit{num}_{l,r}$ 记录的是 $[l,r]$ 作用于线段树上会给多少个节点打上 $\text{tag}$。那么可以得到，$x=y\operatorname{or} B_{l,r}$，同时该边产生的贡献为 $w_i\cdot(\operatorname{popcount}(y\operatorname{and} A_{l,r})+\mathit{num}_{l,r})$。因此有：

$$\mathit{dp}_{u,y\operatorname{or} B_{l,r}}\gets\min\{\mathit{dp}_{u,y\operatorname{or} B_{l,r}},\mathit{dp}_{v,y}+w_i\cdot(\operatorname{popcount}(y\operatorname{and} A_{l,r})+\mathit{num}_{l,r})\}$$

其中 $\operatorname{popcount}(x)$ 表示 $x$ 在二进制下 $1$ 的个数。一种快速的实现方法是，预处理出 $0\sim 255$ 中每个数字二进制下 $1$ 的个数记为 $\mathit{pop}_0(x)$，那么 $\operatorname{popcount}(x)$ 就等于把 $x$ 分成四部分（用位运算实现）分别取 $\mathit{pop}_0$ 数组得到结果相加。这样复杂度几乎可以认为是常数。当然也可以用一些内置函数。

如果直接暴力枚举 $2^k$ 种状态，那么时间复杂度应当是 $\mathcal O(k^3+2^{k-1}\cdot m)$ 的，可以通过 $\text{Subtask 3}$。但可以发现一些状态是不可能实现的（诸如一个有效节点所对应的二进制值为 $1$，而它的父亲节点对应的二进制值却是 $0$）。我们称可以实现的状态为**有效状态**。考虑怎么计算长度为 $k$ 的线段树的有效状态总个数。

设 $f(x)$ 为长度为 $x$ 对应的线段树的**非空的**有效状态数。容易发现，

$$
f(x)=\begin{cases}
0 & x\le 1 \cr
(f(\lfloor\frac{x}{2}\rfloor)+1)\cdot (f(\lceil\frac{x}{2}\rceil)+1) & x> 1
\end{cases}
$$

经过计算，可以得到 $f(\left.s\right|_{k=30})\approx 1.74\times 10^5$，这是远远小于 $2^{\left.s\right|_{k=30}}\approx 2.68\times 10^8$ 的。（$\left.s\right|_{k=30}=28$）下一步是如何枚举出所有有效状态。

这一步并不太难。你可以仿照 $\text{dp}$ 计算有效状态数的方法递归地计算出所有状态，但是比较麻烦。这里提供另外一种简单粗暴的方案。直接用 $\text{dfs}$ **依次**枚举 $0\sim s-1$ 位应当是填充 $0$ 还是 $1$。**当某个节点的父亲节点为** $\bm 0$，**则该节点只能填** $\bm 0$。经过这样一个剪枝可以剪掉所有无用方案而恰好保留所有有效状态，复杂度是 $\mathcal O(f(s))$。

总时间复杂度为 $\mathcal O(f(s)\cdot m)$，空间复杂度为 $\mathcal O(f(s)\cdot n)$。

### $\textbf{Subtask 5 \& 6}$

小清新 $\text{Subtask}$。可以发现瓶颈在于该子任务不再是有向无环图。

使用分层图，将每个点拆成 $f(s)$ 个点，每个点对应于一个状态。按照刚刚 $\text{dp}$ 的方式进行连边，总共连了 $f(s)\cdot m$ 条边。如果你直接使用堆优化 $\text{Dijsktra}$ 跑最短路，复杂度上会多一只 $\log$。但是可以发现本题答案不超过 $n\cdot 2k\cdot \max\{w_i\}$，估摸一下最大为 $50\cdot 60\cdot 10^3=3\times 10^5$，因此可以直接上桶排。复杂度降为 $\mathcal O(f(s)\cdot m)$。

总时间复杂度分析：

- 使用 $\mathcal O(k)$ 的复杂度计算出所有有效节点的标号。  
- 使用 $\mathcal O(f(s))$ 的复杂度计算出所有有效状态。
- 使用 $\mathcal O(k^3)$ 暴力预处理出所有可能的 $(l,r)$ 对应的 $A,B,\mathit{num}$。  
- 建立分层图跑最短路，复杂度为 $\mathcal O(f(s)\cdot m)$。

然而如果你先连边再跑最短路，空间复杂度达到了惊人的 $\mathcal O(f(s)\cdot m)$，然后发现你只能过 $\text{Subtask 5}$。但是完全可以在计算最短路的同时进行边的生成，此时空间复杂度降到了 $\mathcal O(n\cdot f(s))$，可以通过本题。



## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
typedef unsigned int       u32;
typedef unsigned long long u64;
namespace Hsh{
    const int SIZ =3e6-3;
    int H[SIZ],N[SIZ],W[SIZ],t; u32 V[SIZ];
    void add(int u,u32 v,int w){
        V[++t]=v,W[t]=w,N[t]=H[u],H[u]=t;
    }
    int get(u32 w){
        for(int i=H[w%SIZ];i;i=N[i]) if(V[i]==w) return W[i];
        return 0;
    }
}
namespace IIT{
    const int MAXN=16261+3,MAXS=32+3;
    int L[MAXS],R[MAXS],P[MAXS],Q[MAXS],F[MAXS],s,g;
    u32 A[MAXS][MAXS],B[MAXS][MAXS],N[MAXS][MAXS],C[MAXN];
    map<u32,int> M;
    int bld(int t,int l,int r){
        L[t]=l,R[t]=r; if(l!=r){
            int c=l+r>>1;
            if(l!=c  ) P[t]=bld(++s,l,c  ),F[P[t]]=t;
            if(r!=c+1) Q[t]=bld(++s,c+1,r),F[Q[t]]=t;
        }
        return t;
    }
    int T[MAXS],o;
    void clc(int t,int l,int r){
        if(l<=L[t]&&R[t]<=r){T[t]=-1,++o;} else {
            int c=L[t]+R[t]>>1; T[t]=1;
            if(l<=c&&P[t]) clc(P[t],l,r); else if(l<=c) ++o;
            if(r> c&&Q[t]) clc(Q[t],l,r); else if(r> c) ++o;
        }
    }
    void dfs(int x,u32 u,int k){
        if(x==s+1) {C[++g]=u,Hsh::add(u%Hsh::SIZ,u,g); return;}
        if(u&(1u<<F[x])) dfs(x+1,u|1u<<x,k);
        dfs(x+1,u,k);
    }
    void iit(int k){
        bld(0,1,k),dfs(1,1,k);
        up(1,k,i) up(i,k,j){
            memset(T,0,sizeof(T)),clc(0,i,j);
            N[i][j]=o,o=0; up(0,s,x){
                if(T[F[x]]==-1) T[x]=-1;
                if(T[x]==-1) A[i][j]|=1u<<x;
                if(T[x]== 1) B[i][j]|=1u<<x;
            }
        }
    }
}
namespace Lst{
    const int MAXN =4e6+3,SIZ =2e7+3;
    int H[MAXN],V[SIZ],N[SIZ],t;
    void add(int u,int v){
        V[++t]=v,N[t]=H[u],H[u]=t;
    }
}
namespace Gra{
    const int MAXN=1000+3,MAXM=3000+3;
    const int SIZ =16261+3;
    int H[MAXN],V[MAXM],T[MAXM],L[MAXM],R[MAXM],W[MAXM],s,t;
    void add(int u,int v,int l,int r,int w){
        V[++t]=v,L[t]=l,R[t]=r,W[t]=w,T[t]=H[u],H[u]=t;
    }
    const int MAXW=65536;
    int D[MAXN*SIZ],G[MAXW];
    int ppc(u32 u){
        return G[u>>16]+G[u&0xFFFF];
    }
    int dij(int a,int b){
        using IIT::g; using IIT::C; using IIT::A;
        using IIT::B; using IIT::M; using IIT::N;
        up(0,65535,i) G[i]=G[i>>1]+(i&1); Lst::add(1,b*(g+1));
        up(1,Lst::MAXN,d) for(int oo=Lst::H[d];oo;oo=Lst::N[oo]){
            int o=Lst::V[oo]; if(D[o]&&D[o]<d) continue; D[o]=d;
            int u=o/(g+1),x=o%(g+1); if(u==a) return d-1;
            for(int i=H[u];i;i=T[i]){
                int v=V[i],l=L[i],r=R[i],y=Hsh::get(C[x]|B[l][r]);
                int w=W[i]*(ppc(C[x]&A[l][r])+N[l][r]);
                int p=v*(g+1)+y;
                if(D[p]>d+w||!D[p]) Lst::add(d+w,p),D[p]=d+w;
            }
        }
        return -1;
    }
}
namespace Slv{
    const int MAXN=1000+3,MAXM=16261+3,MAXK=3000+3;
    int U[MAXK],V[MAXK],L[MAXK],R[MAXK],K[MAXK];
    int qread(){
        int w=1,c,ret;
        while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
        while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
        return ret*w;
    }
    int n,m,k,a,b,t,ans=1e9;
    void mian(){
        n=qread(),m=qread(),k=qread(),a=qread(),b=qread(); IIT::iit(k);
        up(1,m,i){
            int u=qread(),v=qread(),l=qread(),r=qread(),w=qread();
            Gra::add(v,u,l,r,w);
        }
        printf("%d\n",Gra::dij(a,b));
    }
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    Slv::mian(); return 0;
}
```

---

## 作者：_LiWenX_ (赞：2)

好题！做法和唯一一篇题解在最后一步的处理略有不同，所以写一个题解（写这个题的时候刚好在听密封曲？）。

首先会发现，从 $s\to t$ 行动是困难的，因为你曾经走过的边，会在之后走边的时候进行标记下放，导致权值根本无法计算。

但是我还是仍然希望能确切的知道每一条边经过它的边权从而把问题变成一个最短路模型。发现加入一条边的时候，你知道此时哪些位置是需要被 `pushdown` 的，所以不妨倒着去做，即从 $t$ 走向 $s$，将边全部反向，此时走到一个节点 $x$ 的时候记录线段树上哪些节点是在 $x\to t$ 路径中被 `pushdown` 的。

现在我们直接把点 $x$ 变成二元组点 $(x,t)$，$t$ 表示哪些位置会被 `pushdown`，那么就可以建图求最短路了。

注意到 $k$ 实际非常小，所以感觉这个想法很正确，进一步的，发现目前状态数为 $O(n2^k)$（线段树叶子节点不会进行 `pushdown`），不太能接收，但是发现，每次修改操作都是将与线段树根节点相连的一个连通块放上 `pushdown` 标记，所以我们只用存储这个连通块的叶子节点，所以规模再次缩小，状态数变成 $n2^{\frac{k}{2}}$，打表发现是 $16262$，配合这个数据范围，感觉确实可以接受！

算算复杂度，大概是 $O(2^{\frac{k}{2}}m\log(2^{\frac{k}{2}}m))=O(2^{\frac{k}{2}}m\log m+k2^{\frac{k}{2}}m)$，感觉也没那么能过/ll。

怎么办呢？

看眼特殊性质，这个 DAG 的性质虽然没啥用了，但是启发我们把图尽量变成 DAG。

具体来说，对于 `pushdown` 局面相同的节点，内部是普通图，但是局面之间形成 DAG 关系！

所以直接对局面再建图跑拓扑排序，然后每个按 topu 序更新最短路，同层的点直接暴力 dij，外部边直接更新即可，分析一下复杂度变成了 $O(2^{\frac{k}{2}}m\log m)$，虽然没变太多，但是因为边被分类了，$m$ 的常数非常小，感觉可以过了，写了一下确实可以。

实现细节挺多的，写着写着就容易写混一些东西，建议想清楚后再写，我就被一个编号关系调了好久/ll。

```cpp
#include<bits/stdc++.h>
using namespace std;
int tree[30<<2],D,fa[30<<2],ls[30<<2],rs[30<<2];
#define mid ((l+r)>>1) 
void build(int now,int l,int r,int F){
	if(l==r) return ;
	tree[now]=++D;
	fa[now]=F;
	build(now<<1,l,mid,now);build(now<<1|1,mid+1,r,now);
	ls[tree[now]]=tree[now<<1],rs[tree[now]]=tree[now<<1|1];
}
vector<int> vec[30][30],ask[30][30];
void add(int now,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		ask[x][y].push_back(tree[now]);
		return ;
	}
	vec[x][y].push_back(now);
	if(mid>=x) add(now<<1,l,mid,x,y);
	if(mid<y) add(now<<1|1,mid+1,r,x,y);
}
#undef mid
vector<int> E[16265];
int id[1<<25],cnt,du[16265];
int to[16265][30][30];int val[16265][30<<2];
int n,m,k,s,t;
int wt[16265],CC;
int dis[16265][205],vis[205];
int x[3005],y[3005],le[3005],re[3005],w[3005];
int ys(int now,int l,int r,int w){
	int ret=0;
	for(int u:ask[l][r]){
		ret+=val[now][u];
	}return ret*w;
}
struct edge{
	int from,to,val;
}e[3005];int head[3005],siz;
void addedge(int x,int y,int z){
	e[++siz].to=y,e[siz].val=z;
	e[siz].from=head[x],head[x]=siz;
}
void clear(){
	for(int i=1;i<=n;i++) head[i]=0;
	for(int i=1;i<=siz;i++) e[i].from=e[i].to=e[i].val=0;
	siz=0;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>m>>k>>s>>t;
	build(1,1,k,0);
	for(int l=1;l<=k;l++) for(int r=l;r<=k;r++) add(1,1,k,l,r);
	queue<int> q;q.push(0);id[0]=++cnt;
	while(!q.empty()){
		int now=q.front();q.pop();
		for(int l=1;l<=k;l++){
			for(int r=l;r<=k;r++){
				int nxt=now;
				for(int u:vec[l][r]){
					nxt|=(1<<tree[u]);
				}
				if(nxt==now){
					to[id[now]][l][r]=id[now];
					continue;
				}
				if(!id[nxt]) id[nxt]=++cnt;
				to[id[now]][l][r]=id[nxt];
				E[id[now]].push_back(id[nxt]);du[id[nxt]]++;
				if(id[nxt]!=cnt) continue;
				q.push(nxt);
			}
		}
		int N=now;
		now=id[now];
		for(int i=0;i<=(k<<2);i++) val[now][i]=1;
		for(int i=D;i;i--){
//			if(now==2){
//				cout<<((N>>i)&1)<<" "<<i<<' '<<ls[i]<<' '<<rs[i]<<'\n'; 
//			}
			if((N>>i)&1) val[now][i]=val[now][ls[i]]+val[now][rs[i]];
		}
	}
	cout<<cnt<<'\n';
	return 0;
	for(int i=1;i<=cnt;i++){
		if(!du[i]) q.push(i);
	}
	while(!q.empty()){
		int now=q.front();q.pop();
		wt[++CC]=now;
		for(int u:E[now]){
			du[u]--;
			if(!du[u]){
				q.push(u);
			}
		}
	}
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=n;j++) dis[i][j]=1e9;
	}
	dis[1][t]=0; 
//	cout<<ys(2,1,16,1);
//	return 0;
	for(int i=1;i<=m;i++){
		cin>>x[i]>>y[i]>>le[i]>>re[i]>>w[i];
		swap(x[i],y[i]);
	}
	for(int tt=1;tt<=cnt;tt++){
		int ti=wt[tt];
		clear();
		for(int i=1;i<=m;i++){
			if(ti!=to[ti][le[i]][re[i]]) continue;
			addedge(x[i],y[i],ys(ti,le[i],re[i],w[i]));
		}
		priority_queue<pair<int,int> > q;
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=n;i++){
			if(dis[ti][i]<1e9) q.push({-dis[ti][i],i});
		}
		while(!q.empty()){
			int now=q.top().second;q.pop();
			if(vis[now]) continue;
			vis[now]=1;
			for(int i=head[now];i;i=e[i].from){
				int u=e[i].to;
				if(dis[ti][u]>dis[ti][now]+e[i].val){
					dis[ti][u]=dis[ti][now]+e[i].val;
					q.push({-dis[ti][u],u});
				}
			}
		}
		for(int i=1;i<=m;i++){
			if(ti==to[ti][le[i]][re[i]]) continue;
			int nxt=to[ti][le[i]][re[i]];
//			cout<<ti<<' '<<nxt<<" "<<x[i]<<" "<<y[i]<<' '<<dis[ti][x[i]]<<'\n';
			dis[nxt][y[i]]=min(dis[nxt][y[i]],dis[ti][x[i]]+ys(ti,le[i],re[i],w[i]));
		}
	}
	int ans=1e9;
	for(int i=1;i<=cnt;i++) ans=min(ans,dis[i][s]);
	cout<<ans;
}
/*
3 2 25 1 3
1 2 1 16 1
2 3 1 1 1
*/
```

---

## 作者：nullqtr_pwp (赞：2)

floyd 看上去很不现实，你希望这个最终是一个 dijkstra 的单源最短路。

注意到关于线段树大小的 $k$ 非常小，然而线段树标记下传的结构是难以刻画的，因此考虑暴力状压线段树状态。另一方面，一起 maketag 然后 pushdown 是困难的。而标记的具体值也是难以维护的。那么考虑倒序处理整个路径，在加入时直接确定这条边的贡献，也就是已经确定后缀的操作序列。

对于最终答案我们考虑拆到每一个 $w$ 上。对于 $w$ 定义其权值为最终在多少个 tag 上出现，那么最终答案为所有路径上边的权值之和。从这个方向进一步考虑，我们有一个线段树点集 $S$，表示被 $[l,r]$ 标记到的节点集合。后面你会对这个进行 pushdown，只会进行 pushdown 而不是 maketag。你要计算贡献的话，相当于在 $\log k$ 个节点上放球，每次 pushdown 相当于将这个球复制一份往两边进行传递，然后这 $\log k$ 个球的传递情况由于是不同不交子树所以互相独立，一个很厉害的性质是，事实上最终有球的节点个数就是在后继操作中，这个球子树中的被 pushdown 过的节点数量，原因是每次都会进行一次分裂，然后考虑一个虚树状物，可以用 $|V|-|E|=1$ 来理解，那么就是有被 pushdown 过的节点数量 $+1$。那么记这个有节点的集合是 $S$，感受一下数量是少的。

那么考虑这个上有效的 $S$ 的数量，就是有可能达成的状态。显然不能出现有一个递推式 $f_x$ 表示对根节点线段长度为 $x$ 的线段树子树，在根节点 maketag，在若干次操作之后子树中所有可能有标记的节点集合的方案数，有 $f_x=f_{\lfloor \frac{x}{2}\rfloor}f_{\lceil \frac{x}{2}\rceil}+1$，可以计算得到 $T=\max f_k=f_{25}=16262$。然后倒过来跑最短路，拆成 $nV$ 个点表示 $(u,P)$ 为：$u$ 在后续状态满足 $P$ 集合有 tag，到 $t$ 的最短路。所以直接跑 $\mathcal O(Tm\log m)$ 的最短路即可。

``` cpp
// Problem: P8117 「Wdoi-1.5」旅人 1977
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8117
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

// 私は猫です

#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define pb push_back
#define mkp make_pair
#define fi first
#define se second
#define inf 1000000000
#define infll 1000000000000000000ll
#define pii pair<int,int>
#define rep(i,a,b,c) for(int i=(a);i<=(b);i+=(c))
#define per(i,a,b,c) for(int i=(a);i>=(b);i-=(c))
#define F(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define dF(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define cmh(sjy) while(sjy--)
#define lowbit(x) ((x)&(-(x)))
#define HH printf("\n")
#define eb emplace_back
#define poly vector<int>
#define SZ(x) ((int)x.size())
using namespace std;
template<typename T>inline void chkmax(T &x,const T &y){ x=std::max(x,y); }
template<typename T>inline void chkmin(T &x,const T &y){ x=std::min(x,y); }
const int mod=998244353,maxn=20005,NR=205,KR=25;
int tr[NR],fa[NR],zsy,n,k,cnt,S,T;
#define ls ((u<<1)+1)
#define rs ((u<<1)+2)
ll via[KR+2][KR+2],que[maxn],sta[maxn];
vector<int>qu[NR][NR];
unordered_map<ll,int>mp;
void update(int u,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r)return qu[ql][qr].push_back(u),void();
	int mid=(l+r)>>1; via[ql][qr]|=(1ll<<u);
	if(ql<=mid)update(ls,l,mid,ql,qr);
	if(qr>mid)update(rs,mid+1,r,ql,qr);
}
vector<array<int,4>>g[maxn];
int siz[maxn][NR],nxt[maxn][KR+2][KR+2];
ll dis[NR][maxn];
bool vis[NR][maxn];
void solve(){
	cin>>n>>zsy>>k>>S>>T;
	F(i,1,zsy){
		int u,v,l,r,w; cin>>u>>v>>l>>r>>w;
		g[v].push_back({u,l,r,w});
	}
	F(l,1,k)F(r,l,k)update(0,1,k,l,r);
	int qL=1,qR=0; que[++qR]=0,mp[0]=++cnt,sta[cnt]=0;
	const int mx=(k<<1)-2;
	while(qL<=qR){
		const ll cur=que[qL++]; const int pos=mp[cur];
		F(l,1,k)F(r,l,k){
			ll to=cur|via[l][r];
			if(cur==to){ nxt[pos][l][r]=pos; continue; }
			if(!mp.count(to))mp[to]=++cnt,que[++qR]=to,sta[cnt]=to;
			nxt[pos][l][r]=mp[to];
		}
		F(i,0,mx)siz[pos][i]=(cur>>i)&1;
		dF(u,mx,0)siz[pos][u]+=siz[pos][ls]+siz[pos][rs];
	}
	memset(dis,0x3f,sizeof dis);
	priority_queue<pair<int,pii>>q; q.push(mkp(dis[T][1]=0,mkp(T,1)));
	ll ans=infll;
	while(!q.empty()){
		const auto [u,s]=q.top().se; q.pop();
		if(S==u)break;
		if(vis[u][s])continue; vis[u][s]=1;
		if(ans<dis[u][s])continue;
		for(auto [v,l,r,w]:g[u]){
			ll t=sta[s]|via[l][r],co=0;
			for(int i:qu[l][r])co+=w*(siz[s][i]+1);
			t=mp[t];
			if(dis[v][t]>dis[u][s]+co){
				dis[v][t]=dis[u][s]+co;
				if(v==S)chkmin(ans,dis[v][t]);
				q.push(mkp(-dis[v][t],mkp(v,t)));
			}
		}
	}
	cout<<ans;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int zsy=1;
	F(____,1,zsy)solve();
}
```

---


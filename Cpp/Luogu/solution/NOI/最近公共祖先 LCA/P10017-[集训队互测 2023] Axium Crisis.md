# [集训队互测 2023] Axium Crisis

## 题目背景

在那灰暗的塔楼前，对立见到了些许光芒碎片。

那些光芒碎片萦绕在对立身旁，宛如繁花点缀。

步入那扭曲的迷宫，对立试图收集其中的纷争碎片，并尝试摧毁这个迷宫。

对立的身旁充斥着光芒和纷争碎片，交错纷飞。

终于，对立来到了那迷宫的最深处。

在那片形状极其古怪的记忆残片上，反射的，是一个世界走向灭亡的回忆。

末日来临，天空撕裂，大地崩坠。

由于这块残片上所承载的「能量」实在过于巨大，对立试图使用其身旁的光芒和纷争碎片来缓和这份巨大的精神上的冲击。

具体的，这块扭曲的残片形成一个「树」的结构，对立将在树的每条边上放上一片光芒或者纷争碎片。

对立将会把这颗树上的边切割成若干条链，使得最终每条边恰好属于其中的某一条链。由于残片的特殊结构，树上的一个节点可以同时属于多条链。

对立会取出一部分链，将放置碎片相同的前缀段进行合并，最后形成一颗新的树，也就是所谓的「Trie 树」。

这颗新的树上的节点越多，就越能缓和对立的情绪，让其冷静下来。

在疯狂中，对立已经给残片上的某些边放上了光芒碎片或者纷争碎片。

一刹那的清醒间，对立意识到了些许不对。因此对立还可以往剩下的边上任意选择光芒或者纷争碎片。

在恍惚间，对立发现自己并不知道如何放置并切割是最优的。

思绪飞快地运转起来。怎样是最优的呢？

相信你已有答案。

## 题目描述

给定一颗 $n$ 个节点的树，节点编号 $0\sim n-1$。

边有边权，边权一般为 $0$ 或者 $1$；但有的边的边权还未确定。

你要给每条未被确定边权的边确定一个 $0$ 或者 $1$ 的边权，然后从树上取出若干条有向路径，使得这些链两两之间满足**边不相交**。

然后你会把这些路径插入一颗 0/1-Trie，你希望最大化这颗 0/1-Trie 上的节点数。（0/1-Trie 定义略）

你可能需要构造具体的选择方案。

## 说明/提示

#### 样例解释

这组样例对应的答案文件为：

```plain
8
9
5
16
14
16
15
16
18
```

样例输出即 `.out` 文件，也就是你要输出的结果，在 $c=1$ 时需要构造一组合法方案。

样例答案即 `.ans` 文件，该文件中仅会给出每组数据的答案，不会给出构造方案。

接下来依次附上这 $9$ 组样例的图示（选择边权前 / 后各一张）。

![sample0_1_1.png](https://sy.hhwdd.com/RequireFile.do?fid=01t7zGM4)![sample0_1_2.png](https://sy.hhwdd.com/RequireFile.do?fid=EHOyk2Uz)

![sample0_2_1.png](https://sy.hhwdd.com/RequireFile.do?fid=FP2WnHn3)![sample0_2_2.png](https://sy.hhwdd.com/RequireFile.do?fid=c4cKvUgH)

![sample0_3_1.png](https://sy.hhwdd.com/RequireFile.do?fid=U4UoWyyU)![sample0_3_2.png](https://sy.hhwdd.com/RequireFile.do?fid=59JlIWvn)

![sample0_4_1.png](https://sy.hhwdd.com/RequireFile.do?fid=cm5NQIRx)![sample0_4_2.png](https://sy.hhwdd.com/RequireFile.do?fid=jM6lGPo8)

![sample0_5_1.png](https://sy.hhwdd.com/RequireFile.do?fid=7jKRZ9i9)![sample0_5_2.png](https://sy.hhwdd.com/RequireFile.do?fid=Fb1HkD1s)

![sample0_6_1.png](https://sy.hhwdd.com/RequireFile.do?fid=CbEmirO0)![sample0_6_2.png](https://sy.hhwdd.com/RequireFile.do?fid=4GrzzBbe)

![sample0_7_1.png](https://sy.hhwdd.com/RequireFile.do?fid=hRWoM1xi)![sample0_7_2.png](https://sy.hhwdd.com/RequireFile.do?fid=8OgPPrFB)

![sample0_8_1.png](https://sy.hhwdd.com/RequireFile.do?fid=ws6t9q9g)![sample0_8_2.png](https://sy.hhwdd.com/RequireFile.do?fid=RkDgZv7G)

![sample0_9_1.png](https://sy.hhwdd.com/RequireFile.do?fid=MlI0m1pW)![sample0_9_2.png](https://sy.hhwdd.com/RequireFile.do?fid=KJLtHLs7)

#### 更多样例

**因为本题数据规模太大，直接提交评测会对评测机带来很大压力，本题将提供很多大样例；请尽量减少本题的提交次数。**

更多样例请参见下发文件 `axiumcrisis*.in/ans`，共 $20$ 组，基本按照部分分的方法造。

注意下发的答案文件中**没有给出构造方案**，仅会给出每组数据的答案。

下发了一个 `checker.cpp`，你可以自行编译并在终端运行校验合法性。具体使用方法请参考「数据范围与提示」一节的描述。正式测评时使用的 Special Judge 与其并不相同。

为了方便你更好地理解题意，此处额外附一个手搓的样例，这份样例未被放入下发文件。

**建议使用该组样例及样例解释校验你对题意的理解，以免误读**。

#### 数据范围与提示

与[互测实际使用的版本](https://qoj.ac/problem/7769)不同，本题此处将采用数据范围更大的版本。

对于所有的数据，保证 $2\le n\le18$，$1\le T\le3000$。

具体的数据规模分布可以见下表，**各子任务等分，即满分均为 $\rm5pts$**。其中形如 $(l,r)$ 的一列对应的数据表示 $l\le n\le r$ 的数据组数，「无限制」表示无额外限制。

各子任务**捆绑评测**，其分数为该子任务各测试点分数最小值。子任务依赖意味着只有所依赖的子任务分数均非 $0$ 才会评测当前子任务，且分数与所依赖的子任务也取最小值。$o$ 的含义将在之后注明。

|子任务|$(2,4)$|$(5,6)$|$(7,8)$|$(9,11)$|$(12,14)$|$(15,17)$|$(18,18)$|$o$|子任务依赖|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$\le1000$|$=0$|$=0$|$=0$|$=0$|$=0$|$=0$|$=0$|无|
|$2$|无限制|$\le15$|$=0$|$=0$|$=0$|$=0$|$=0$|$=0$|$1$|
|$3$|无限制|$\le500$|$\le10$|$=0$|$=0$|$=0$|$=0$|$=0$|$2$|
|$4$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=2$|无|
|$5$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=3$|无|
|$6$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=4$|$4$|
|$7$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=0$|$3,5,6$|
|$8$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=2$|$4$|
|$9$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=3$|$5$|
|$10$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=4$|$6,8$|
|$11$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=0$|$7,9,10$|
|$12$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=2$|$8$|
|$13$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=3$|$9$|
|$14$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=4$|$10,12$|
|$15$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=0$|$11,13,14$|
|$16$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=1$|无|
|$17$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=2$|$12$|
|$18$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=3$|$13,16$|
|$19$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=4$|$14,16,17$|
|$20$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=0$|$15,18,19$|

接下来阐述关于 $o$ 的特殊性质。
* $o=0$ 时，不保证特殊性质。
* $o=1$ 时，保证输入中 $w=0$。
* $o=2$ 时，保证输入中 $w=2$。
* $o=3$ 时，保证输入中 $w=0$ 或 $w=1$。
* $o=4$ 时，保证输入中 $w=0$ 或 $w=2$。

接下来阐述是否输出方案对答案带来的影响。
* 如果选择了 $c=0$，则答案正确时，你将获得该测试点 $80\%$ 的分数，否则该测试点不得分。
* 如果选择了 $c=1$，则答案和构造方案**均正确**时，你将获得该测试点的全部分数，**否则该测试点不得分**。

因此如果你的输出方案可能写错，请慎重考虑是否改为不输出方案。

接下来介绍 `checker.cpp` 使用方法。

`checker.cpp` 使用类似于 Testlib 的命令行格式，但是并不基于 Testlib，因此**不需要 `testlib.h` 文件**；同时**兼容 Lemon 格式**。具体的，你可以这么使用：

打开终端，进入 `checker.cpp` 所在文件夹后，首先使用 `g++ checker.cpp -o checker` 命令生成可执行文件（需要本地默认采用 C++11 及以上标准）。

假设输入文件为 `data.in`，输出文件为 `data.out`，标准答案文件为 `data.ans`，则你需要将可执行文件 `checker` 和 `data.in/out/ans` 文件放置于同一文件夹下，然后在终端中输入如下命令执行：
* 如果你使用 Windows 操作系统，请在 cmd 中使用 `checker data.in data.out data.ans 5` 执行。
* 如果你使用 Linux 操作系统，请在 bash 中使用 `./checker data.in data.out data.ans 5` 执行。

如命令中去掉最后的这个 `5` 将认为 $c=0$ 时也为 AC。

稍等片刻即会返回提示信息。

如果你使用 Lemon 来进行本地评测，可以把 `checker.cpp` 的可执行文件直接作为 Lemon 中的「自定义校验器」使用。

#### 后记

透过指缝观看着那世界末日之景。对立咽了口口水，靠着那股不知名的勇气，将手从自己的脸上移开。

对立伸出了手，把那世界尽头收入了自己所搜集的无数回忆之中。

其余的悲惨记忆，在这枚残片的映衬下显得不足一提。

对立确信自己已经变得足够强大，理所当然地想立刻把一切都摧毁。

就这样，伴随着那抹真诚的微笑与疲惫的笑声，对立从天空中降落到了地面上。

那座古老的塔楼在这般力量驱使下逐渐陨落。

而对立则怀抱着英雄般的信念，坚定不移地迈步向前。



## 样例 #1

### 输入

```
9 0
9
1 2 1
3 4 1
5 6 1
7 8 1
2 0 0
4 0 0
6 0 0
8 0 0
9
1 2 2
3 4 1
5 6 1
7 8 1
2 0 0
4 0 0
6 0 0
8 0 0
5
1 2 2
3 4 1
0 3 1
2 3 0
17
1 2 1
2 3 0
3 4 1
4 0 0
5 6 1
6 7 0
7 8 1
8 0 0
9 10 1
10 11 0
11 12 1
12 0 0
13 14 1
14 15 0
15 16 1
16 0 0
17
1 2 1
2 0 0
3 4 1
4 0 0
5 6 1
6 0 0
7 8 1
8 0 0
9 10 1
10 11 0
11 12 1
12 0 0
13 14 1
14 15 0
15 16 1
16 0 0
17
1 2 2
2 0 2
3 4 2
4 0 2
5 6 2
6 0 2
7 8 2
8 0 2
9 10 2
10 11 2
11 12 2
12 0 2
13 14 2
14 15 2
15 16 2
16 0 2
18
1 2 1
2 0 0
3 4 1
4 0 0
5 6 1
6 0 0
7 8 1
8 0 0
9 10 1
10 11 0
11 12 1
12 0 0
13 14 1
14 15 0
15 16 1
16 0 0
0 17 2
18
1 2 2
2 0 2
3 4 2
4 0 2
5 6 2
6 0 2
7 8 2
8 0 2
9 10 2
10 11 2
11 12 2
12 0 2
13 14 2
14 15 2
15 16 2
16 0 2
17 0 2
18
1 2 2
2 3 2
3 4 2
4 5 2
5 6 2
6 7 2
7 8 2
8 9 2
9 10 2
10 11 2
11 12 2
12 13 2
13 14 2
14 15 2
15 16 2
16 17 2
17 0 2```

### 输出

```
1
8
3
1 1 1 1 0 0 0 0
1 3
5 6
6 7
9
2
0 1 1 1 0 0 0 0
3 5
1 7
5
2
0 1 1 0
4 3
1 0
16
3
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
5 1
13 14
14 9
14
5
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
3 1
5 6
14 13
14 7
6 9
16
3
0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0
7 5
1 3
13 9
15
4
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 0
13 3
1 7
0 5
17 9
16
4
1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1
1 7
17 0
5 3
13 9
18
1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0```

# 题解

## 作者：AFewSuns (赞：7)

终于加强了，很高兴！来水一篇题解。

[不一定会更好的阅读体验。](https://www.cnblogs.com/AFewSuns/p/17803920.html#d6t2-axium-crisis)

---

### 题目大意

给定一颗 $n$ 个点的树，节点编号为 $0\sim n-1$。

边有边权，边权为 $0$ 或 $1$ 或不确定。

你要给每条未被确定边权的边确定一个 $0$ 或 $1$ 的边权，然后从树上取出若干条有向路径，使得这些链两两之间满足边不相交。

然后你会把这些路径插入一颗 01-Trie，你希望最大化这颗 01-Trie 上的节点数。需要输出方案。

$1 \leq T \leq 10,2 \leq n \leq 18$。

### 题目分析

先考虑如何做 $w\in \{0,1\},c=0$。

拿出树上的每一条有向路径，将它们按照字典序排序，那么原问题变成从中选出若干条边不相交的路径，它们的权值为长度之和减去相邻两项 $\operatorname{lcp}$，求权值最大值。

直接从前往后 dp，设 $f_{i,S}$ 表示只考虑前 $i$ 条路径，选了第 $i$ 条路径，且当前选取的路径边集并为 $S$ 的最大权值。转移时枚举上一个选的是什么，时间复杂度 $\mathcal O(n^42^n)$。

设字典序第 $i$ 小的字符串为 $s_i$，那么 $\operatorname{lcp}(s_i,s_j)=\min\limits_{i \leq k < j}{\operatorname{lcp}(s_k,s_{k+1})}$。于是就可以一步步转移了，设 $f_{i,S,j}$ 表示考虑了前 $i$ 条路径，选取的边集并为 $S$，且当前路径与上一个选择的路径的 $\operatorname{lcp}$ 为 $j$ 的答案。转移如下：

1. $f_{i-1,S,j} \to f_{i,S,\min(j,\operatorname{lcp}(s_{i-1},s_i))}$，预转移，处理一下 $\operatorname{lcp}$；

2. $f_{i-1,S,j}+len_i-j \to f_{i,S\cup E_i,len_i}(S\cap E_i=	\emptyset)$，表示选第 $i$ 条路径，其中 $E_i$ 表示第 $i$ 条路径的边集，$len_i$ 表示第 $i$ 条路径的字符串长度。

时间复杂度 $\mathcal O(n^32^n)$，需要滚动数组优化空间。字符串排序直接塞 trie 里就行了。

---

然后考虑 $w\in \{0,1,2\},c=0$。

当所有 $w\neq 2$ 时，每条边都是确定的，所以总共只会有 $n(n-1)$ 个串；而当存在 $w=2$ 时，需要枚举边集的所有情况，这样可能会有 $\mathcal O(n^22^n)$ 个串。

实际上只会有 $\mathcal O(2^n)$ 个串。考虑剥叶子，第一个次剥的叶子最多往外连 $2\times (2^1+\cdots+2^{n-1})<2^{n+1}$ 个串，乘 $2$ 是因为路径有向。而第二次剥的叶子最多往外连 $2^n$ 个串，以此类推，所以最后不会超过 $2^{n+2}$ 个串，即 $\mathcal O(2^n)$。

然后优化一下转移，第一维完全可以不记，让 $f$ 数组自转：

1. $f_{S,j} \to f_{S,\operatorname{lcp}(s_{i-1},s_i)}(j>\operatorname{lcp}(s_{i-1},s_i))$

2. $f_{S/E_i,j}+len_i-j \to f_{S,len_i}(E_i \subseteq S)$

当然 $i$ 还是要枚举的，这样就不担心空间了。考虑分析时间复杂度。

对于第 $2$ 部分，考虑树上一条长度为 $len$ 的路径 $x\to y$，它中间最多会产生 $2^{len}$ 个串，其中每个串都要枚举 $2^{n-1-len}$ 个超集，于是它们的总转移时间复杂度为 $\mathcal O(n2^n)$。有 $\mathcal O(n^2)$ 对 $(x,y)$，所以总转移时间复杂度就是 $\mathcal O(n^32^n)$ 的。

对于第 $1$ 部分，考虑只保留有用的 dp 状态。将每次通过第 $2$ 步转移得到的 dp 状态为“关键状态”，由上面可知“关键状态”只有 $\mathcal O(n^22^n)$ 个，而每个关键状态经过第 $1$ 步转移时第二维至少减 $1$，所以最多经过 $n$ 次第一步转移，于是总转移时间复杂度就是 $\mathcal O(n^32^n)$ 的了！

大概需要精细实现，当然不那么精细也可以，毕竟卡不满。

---

之后考虑 $c=1$，即如何构造方案。

显然不能开一个 $\mathcal O(n4^n)$ 的数组记录从哪转移过来的，不然就又退化了。

于是考虑用一个操作栈来维护有效的 dp 转移，之后从后往前推就可以得到方案了。

直接记录的空间复杂度为 $\mathcal O(n^32^n)$，不可接受。考虑再分析一下有效状态数。

对于转移的第 $2$ 部分，容易发现在枚举超集 $S$ 后可以不用对每个 $f_{S/E_i,j}$ 都尝试转移 $f_{S,len_i}$，直接取最大值记录在栈里就行了，空间复杂度 $\mathcal O(n^22^n)$；

而对于第 $1$ 部分，考虑树上一条长度为 $len$ 的路径 $x\to y$，最坏情况下中间会有 $2^{len}$ 个串，其分布在 trie 树上的第 $len$ 层。模拟一下这些串在第 $1$ 部分贡献的转移复杂度，发现在遍历每个串的时候会先转移到所有 $f_{S,len}$，其中 $S$ 为这条路径的超集；之后根据先前的复杂度分析，这些 $f_{S,len}$ 最多在第 $1$ 部分转移 $n$ 次，于是就有先前分析的复杂度。

实际上，对于 trie 树第 $len$ 层的前两个节点，遍历完它们之后，它们转移到的“关键状态”是完全相等的！换句话说，由于 dp 转移是取 $\max$，所以对于每个 $S$，这两个节点对应的“关键状态”都是 $f_{S,len}$，通过取 $\max$ 合并到一个状态了，于是它们总的复杂度贡献是 $n$。

同理，对于 trie 树上第 $i$ 层的一个节点，它下面有 $2^{len-i}$ 个第 $len$ 层的节点，这些节点对应的“关键状态”在第二维减到 $i$ 的时候就全合并成一个 dp 状态了（对不同的超集 $S$ 而言）。于是实际上 $x\to y$ 的这些串在第 $1$ 部分贡献的总复杂度为它们在 trie 上的虚树大小（对不同的超集 $S$ 而言），即 $\mathcal O(2^{len})$。而总共有 $2^{n-1-len}$ 个超集，于是时间复杂度就是 $\mathcal O(2^n)$，所有 $(x,y)$ 的总时间复杂度就是 $\mathcal O(n^22^n)$，空间复杂度也就变成 $\mathcal O(n^22^n)$ 的了。

时间复杂度 $\mathcal O(n^32^n)$，空间复杂度 $\mathcal O(n^22^n)$。实际上栈的大小大概开 $2\times 10^7$ 就够了，然后时间空间复杂度写得没那么精细也能过。

---

以上是原题部分，考虑继续优化。

不难发现现在唯一的复杂度瓶颈在于第 $2$ 步转移，需要枚举超集 $S$ 后再枚举 $j\in [0,n-1]$ 进行转移。但其实只需要对于每个 $S$，维护出 $g_S$ 表示 $f_{S,j}-j$ 最大的 $j$ 就行了，由于 dp 值只会变大，所以是很好维护的。时空复杂度 $\mathcal O(n^22^n)$。

不难精细实现。栈的大小开 $3\times 10^6$ 就够了。

一些剪枝：对 trie 树上每个节点的边集去重；不难证明一定存在最优方案使得每条链都有端点是叶子。

[提交记录](https://www.luogu.com.cn/record/143037010)

---


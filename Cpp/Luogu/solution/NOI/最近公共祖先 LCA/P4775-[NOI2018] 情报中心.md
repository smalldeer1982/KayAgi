# [NOI2018] 情报中心

## 题目描述

C 国和 D 国近年来战火纷飞。

最近，C 国成功地渗透进入了 D 国的一个城市。这个城市可以抽象成一张有 $n$ 个节点，节点之间由 $n − 1$ 条双向的边连接的无向图，使得任意两个点之间可以互相到达。也就是说，这张无向图实际上是一棵树。

经过侦查，C 国情报部部长 GGB 惊讶地发现，这座看起来不起眼的城市竟然是 D 国的军事中心。因此 GGB 决定在这个城市内设立情报机构。情报专家 TAC 在侦查后，安排了 $m$ 种设立情报机构的方案。这些方案中，第 $i$ 种方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径的所有边上安排情报人员收集情报，这种方案需要花费 $v_i$ 元的代价。

但是，由于人手不足，GGB 只能安排上述 $m$ 种方案中的两种进行实施。同时 TAC 指出，为了让这两个情报机构可以更好的合作，它们收集情报的范围应**至少有一条公共的边**。为了评估一种方案的性能，GGB 和 TAC 对所有的边进行了勘察，给每一条边制定了一个情报价值 $c_i$，表示收集这条边上的情报能够带来 $c_i$ 元的收益。注意，情报是唯一的，因此当一条边的情报被两个情报机构收集时，也同样只会有 $c_i$ 的收益。

现在，请你帮 GGB 选出两种合法的设立情报机构的方案进行实施，使得这两种方案收集情报的范围至少有一条公共的边，并且在此基础上**总收益减去总代价的差**最大。

注意，这个值可能是负的，但仍然是合法的。如果无法找到这样的两种方案，请输出 `F`。


## 说明/提示

### 样例 1 解释

这个样例中包含两组数据。这两组数据的城市相同，只是在情报的价值和情报机构的方案上有所不同。城市地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)

* 对于第一组数据，方案一中的节点 $1$ 到节点 $4$ 的最短路径为 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4$，方案二中的节点 $3$ 到节点 $5$ 的最短路径为 $3 \rightarrow 2 \rightarrow 1 \rightarrow 5$。选择这两种方案需要花费 $5 + 8 = 13$ 的代价，并且每一条边的情报都被收集从而得到 $1 + 3 + 2 + 8 = 14$ 的收益，因此总收益减去总代价为 $14 − 13 = 1$。
* 对于第二组数据，方案一中的节点 $1$ 到节点 $5$ 的最短路径为 $1 \rightarrow 5$，方案二中的节点 $2$ 到节点 $3$ 的最短路径为 $2 \rightarrow 3$。这两种方案收集情报的范围没有公共的边，因此非法，所以这组数据不存在合法方案，应输出 `F`。

### 样例 2 解释

见附加文件中的 `center2.in` 与 `center2.ans`。

这个样例只包含一组数据。这一数据中，最优方案为选择第 $2$ 种和第 $3$ 种方案。

这组数据的城市地图如下，其中**加粗**的边表示被情报中心收集情报的边，红色的边表示只被第 $2$ 种方案的情报中心收集情报的边，蓝色的边表示只被第 $3$ 种方案的情报中心收集情报的边，紫色的边表示同时被两个情报中心收集情报的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)

### 样例 3

见附加文件中的 `center3.in` 与 `center3.ans`。

这个样例和第 $4$ 个测试点的性质相同。每个测试点的性质见下文的表格。

### 样例 4

见附加文件中的 `center4.in` 与 `center4.ans`。

这个样例，无疑是善良的出题人无私的馈赠。大量精心构造的 $n\le 100,m\le 200$ 的测试数据，涵盖了测试点中所有出现性质的组合。你可以利用这个测试点，对自己的程序进行全面的检查。足量的数据组数、不大的数据范围和多种多样的数据类型，能让程序中的错误无处遁形。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。

### 数据范围

各测试点的数据规模和性质如下表：

::cute-table{tuack}

| 测试点 | $n \le$ | $m \le$ | $T \le 50$ | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |
| 1 | $2$ | $3$ | 保证 | 无 |
| 2 | $10$ | $30$ | ^ | ^ |
| 3 | $200$ | $300$ | ^ | ^ |
| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |
| 5 | $10^4$ | $3 \times 10^4$ | ^ | ^ |
| 6 | $5 \times 10^4$ | $10^5$ | ^ | ^ |
| 7 | $10^4$ | $3 \times 10^4$ | ^ | $c_i=0$ |
| 8 | $5 \times 10^4$ | $10^5$ | ^ | ^ |
| 9 | ^ | ^ | ^ | ^ |
| 10 | $10^4$ | $n$ | ^ | $S_1$ |
| 11 | $5 \times 10^4$ | ^ | 不保证 | ^ |
| 12 | ^ | ^ | ^ | ^ |
| 13 | $10^4$ | $3 \times 10^4$ | 保证 | $S_2$ |
| 14 | ^ | ^ | ^ | ^ |
| 15 | $5 \times 10^4$ | $10^5$ | 不保证 | ^ |
| 16 | ^ | ^ | ^ | ^ |
| 17 | $10^4$ | $3 \times 10^4$ | 保证 | 无 |
| 18 | $5 \times 10^4$ | $ 10^5$ | ^ | ^ |
| 19 | ^ | ^ | 不保证 | ^ |
| 20 | ^ | ^ | ^ | ^ |

表格中的特殊性质如下：
* 特殊性质 $S_1$：对于任意 $i, j$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点不同于 $x_j$ 到 $y_j$ 的最短路径所经过的编号最小的节点；

* 特殊性质 $S_2$：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点为节点 $1$。

对于所有的数据，$1 \le n \le 5 \times 10^4$，$0 \le m \le 10^5$，$0 \le c_i \le 10^9$，$0 \le v_i \le 10^{10} \times n$。每个测试点中，所有 $n$ 的和不会超过 $1\,000\,233$，所有 $m$ 的和不会超过 $2\,000\,233$。


## 样例 #1

### 输入

```
2
5
1 2 1
2 3 3
3 4 2
1 5 8
2
1 4 5
3 5 8
5
1 2 1
2 3 3
3 4 3
1 5 9
2
1 5 5
2 3 8```

### 输出

```
1
F```

## 样例 #2

### 输入

```
1
11
1 2 2
1 3 0
2 4 1
3 5 7
1 6 0
1 7 1
1 8 1
6 9 3
4 10 2
4 11 8
10
7 10 2
10 7 0
2 11 1
8 6 7
7 7 0
10 1 1
8 2 1
7 8 3
7 7 3
3 9 9
```

### 输出

```
13
```

# 题解

## 作者：command_block (赞：55)

本大胖题的阳间做法，不用分类讨论了！

**题意** ：给出一棵 $n$ 个点的树，边有正边权。

给出树上的 $m$ 条路径，每条路径有一个花费。

选出两条路径，使得两条路径至少有一条公共边，且两条路径的**并**的边权和减去花费和最大。或指出不存在满足要求的方案。

多组数据，$n\leq 5\times 10^4,m\leq 10^5,\sum n\leq 10^6,\sum m\leq 2\times 10^6$。时限$\texttt{8s}$。

------------

对于给出的花费为 $w$ 的路径 $(u,v)$ ，我们记 $c_{(u,v)}=dis(u,v)-2w$。

![](https://cdn.luogu.com.cn/upload/image_hosting/y7p06ph9.png)

可能的两种合法方案如图。对于两种情况，收益**的两倍**均为 ： 

$$c_{(u_1,v_1)}+c_{(u_2,v_2)}+dis(u_1,u_2)+dis(v_1,v_2)$$

考虑枚举 $t={\rm lca}(u_1,u_2)$ （即相交部分最深的点）

然后求出最大的

$$c_{(u_1,v_1)}+c_{(u_2,v_2)}+dep_{u_1}+dep_{u_2}+dis(v_1,v_2)$$

还要加上此时确定的 $-2dep_{{\rm lca}(u_1,u_2)}$。

这可以看做将 $v_1$ 的权值定为 $w_{v_1}=c_{(u_1,v_1)}+dep_{u_1}$ ，而 $v_2$ 的权值定为 $w_{v_2}=c_{(u_2,v_2)}+dep_{u_2}$。

选择 $v_1,v_2$ 两者配对的贡献为 $w_{v_1}+w_{v_2}+dis(v_1,v_2)$。

这是经典的树上（带权）最远点对问题，有结论 ：

- 记 ${\rm diam}(S)$ 为树上点集 $S$ 的最远点对。

  对于 $S=S_1∪S_2$ ，有 ${\rm diam}(S)={\rm diam}\big({\rm diam}(S_1)∪{\rm diam}(S_2)\big)$

  可见 [P2056 [ZJOI2007]捉迷藏](https://www.luogu.com.cn/problem/P2056)。
  
利用这个结论，只需计算 $O(1)$ 次两点距离，就能合并点集最远点对，或者计算两个点集之间的最远点对。

使用 $O(1)\ \rm LCA$ ，这个复杂度就是 $O(1)$。

记 $S_u$ 为子树内的路径提供的匹配候选点集。

对于 $t$ ，要计算 $t$ 的各个子分支之间的贡献。

对于路径 $(u,v)$ ，记 $t={\rm lca}(u,v)$。则 $u$ 会出现在 $S_{[v\rightarrow t)}$ 中， $v$ 会出现在 $S_{[u\rightarrow t)}$ 中。

它们不能出现在 $t$ 的祖先的 $S$ 中，否则会产生错误的匹配。

使用树上差分，我们在 $u$ 点加入，在 $u$ 到 $t$ 的路径上的倒数第二个点删除。

用线段树合并维护，在合并时即可获得不同子分支之间的贡献。

复杂度 $O\big((n+m)\log n\big)$。

不到 $\rm 4Kb$ 的代码 ：

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#define pb push_back
#define ll long long
#define MaxN 50050
#define MaxM 100500
using namespace std;
const ll INF=1ll<<60;
vector<int> g[MaxN],l[MaxN];
int dep[MaxN],f[16][MaxN]
   ,dfn[MaxN],out[MaxN],id[MaxN<<1],tim;
ll dist[MaxN];
void pfs(int u)
{
  id[dfn[u]=++tim]=u;
  for (int i=0,v;i<g[u].size();i++)
    if (!dfn[v=g[u][i]]){
      dep[v]=dep[f[0][v]=u]+1;
      dist[v]=dist[u]+l[u][i];
      pfs(v);id[++tim]=u;
    }
  out[u]=tim;
}
#define Pii pair<int,int>
#define Pr pair<int,ll>
#define fir first
#define sec second
#define mp make_pair
int lg2[MaxN<<1];
Pii t[18][MaxN<<1];
void Init()
{
  for (int i=2;i<=tim;i++)lg2[i]=lg2[i>>1]+1;
  for (int i=1;i<=tim;i++)t[0][i]=mp(dep[id[i]],id[i]);
  for (int j=1;(1<<j)<=tim;j++)
    for (int i=1;i+(1<<j)-1<=tim;i++)
      t[j][i]=min(t[j-1][i],t[j-1][i+(1<<(j-1))]);
}
int lca(int u,int v){
  u=dfn[u];v=dfn[v];if (u>v)swap(u,v);
  int k=lg2[v-u+1];
  return min(t[k][u],t[k][v-(1<<k)+1]).second;
}
int up(int u,int t){
  int k=15;
  while(k--)while(dep[f[k][u]]>dep[t])u=f[k][u];
  return u;
}
ll dis(int u,int v)
{return dist[u]+dist[v]-2*dist[lca(u,v)];}
inline ll dis(Pr u,Pr v)
{return dis(u.fir,v.fir)+u.sec+v.sec;}
struct Data{Pr u,v;}Z;
ll merge(Data &S,const Data &A,const Data &B)
{
  if (!A.u.fir&&!A.v.fir){S=B;return -INF;}
  if (!B.u.fir&&!B.v.fir){S=A;return -INF;}
  ll ret,mx=-INF,s;int op=-1;
  #define chk(u,v,w) if (u.fir&&v.fir){s=dis(u,v);if (s>mx){mx=s;op=w;}}
  chk(A.u,B.u,3);chk(A.u,B.v,4);
  chk(A.v,B.u,5);chk(A.v,B.v,6);
  ret=mx;
  chk(A.u,A.v,1);chk(B.u,B.v,2);
  if (op==1)S=A;if (op==2)S=B;
  if (op==3)S=(Data){A.u,B.u};if (op==4)S=(Data){A.u,B.v};
  if (op==5)S=(Data){A.v,B.u};if (op==6)S=(Data){A.v,B.v};
  return ret;
}
struct Node{int l,r;Data x;}a[MaxM*40];
int rt[MaxN],tn,to;Pr wfc;
void up(int u){
  if (!a[u].l||!a[u].r){a[u].x=a[a[u].l|a[u].r].x;return ;}
  merge(a[u].x,a[a[u].l].x,a[a[u].r].x);
}
void add(int l,int r,int &u)
{
  if (!u)u=++tn;
  if (l==r){a[u].x.u=wfc;return ;}
  int mid=(l+r)>>1;
  if (to<=mid)add(l,mid,a[u].l);
  else add(mid+1,r,a[u].r);
  up(u);
}
void del(int l,int r,int &u)
{
  if (l==r){a[u].x.u=mp(0,0);return ;}
  int mid=(l+r)>>1;
  if (to<=mid)del(l,mid,a[u].l);
  else del(mid+1,r,a[u].r);
  up(u);
}
int merge(int u,int v)
{
  if (!u||!v)return u|v;
  merge(a[u].x,a[u].x,a[v].x);
  a[u].l=merge(a[u].l,a[v].l);
  a[u].r=merge(a[u].r,a[v].r);
  return u;
}
ll ans;
vector<int> b[MaxN];
int n,m;
void dfs(int u)
{
  for (int i=0,v;i<g[u].size();i++)
    if (dep[v=g[u][i]]>dep[u]){
      dfs(v);
      ans=max(ans,merge(Z,a[rt[u]].x,a[rt[v]].x)-2*dist[u]);
      rt[u]=merge(rt[u],rt[v]);
    }
  for (int i=0;i<b[u].size();i++)
    {to=b[u][i];del(1,m,rt[u]);}
}
void solve()
{
  scanf("%d",&n);
  for (int i=1,u,v,w;i<n;i++){
    scanf("%d%d%d",&u,&v,&w);
    g[u].pb(v);l[u].pb(w);
    g[v].pb(u);l[v].pb(w);
  }dep[1]=1;pfs(1);Init();
  for (int j=1;j<15;j++)
    for (int i=1;i<=n;i++)
      f[j][i]=f[j-1][f[j-1][i]];
  scanf("%d",&m);
  ans=-INF;
  for (int i=1;i<=m;i++){
    int u,v;ll w;
    scanf("%d%d%lld",&u,&v,&w);
    if (u==v)continue;
    w=dis(u,v)-2*w;
    int t=lca(u,v),tu=up(u,t),tv=up(v,t);
    to=i;
    if (u!=t){
      wfc=mp(v,w+dist[u]);
      ans=max(ans,merge(Z,(Data){wfc,mp(0,0)},a[rt[u]].x)-2*dist[u]);
      add(1,m,rt[u]);b[tu].pb(i);
    }
    if (v!=t){
      wfc=mp(u,w+dist[v]);
      ans=max(ans,merge(Z,(Data){wfc,mp(0,0)},a[rt[v]].x)-2*dist[v]);
      add(1,m,rt[v]);b[tv].pb(i);
    }
  }
  dfs(1);
  if (ans<=-INF/10)puts("F");
  else printf("%lld\n",ans/2);
  for (int i=1;i<=n;i++){
    g[i].clear();l[i].clear();b[i].clear();
    dfn[i]=rt[i]=0;
  }memset(a,0,sizeof(Node)*(tn+5));tn=tim=0;
}
int main()
{
  int T;scanf("%d",&T);
  while(T--)solve();
  return 0;
}
```

所以，2018 年最难题还应该是 D2T3 (

---

## 作者：Heartlessly (赞：28)

 _ **~~这题在NOI2018中可以算是最难的题目了。蒟蒻当然做不来，仅仅是转发一下官方题解。~~**_ 
## 题意简述
 - 给出一个 $n$ 个点的树，每条边上有非负边权
 - 再给出 $m$ 条树上的链，用端点表示，每条链都有价值
 - 要求选出两条链，满足这两条链**至少有一条边相交**
 - 最大化选出的**链的权值和** + 被**至少一条链覆盖**的边的**边权和**
 - 一个测试点可能有很多组数据，$n\leq 50,000$、$m\leq 100,000$
 - 测试点内的 $n$ 和 $m$ 的和的数量级达到 $10^{6}$
 - 时间限制 $8$ 秒，空间限制 $512$ MB
 
## 大暴力
 - 测试点 $1$、$2$、$3$ 数据范围非常非常非常小
 - 可以枚举两条链，到树上去统计覆盖的边
 - $O(nm^{2}) = 15'$
 
## 聪明的暴力
 - 测试点 $1$、$2$、$3$、$4$ 数据范围有点小
 - 考虑在枚举链的时候加优化
 - 枚举第一条链，把每条边的权值 $w(e)$ 改成 $↓$
 - $w'(e) = [e$在第一条链上$]w(e)$并预处理求出树上距离的数据结构
 - 然后枚举第二条链求树上距离，注意判断是否相交
 - $O(nm) = 20'$
 
 
 ## 真·暴力
 - 仔细观察数据范围
 - 我们相信出题人为了卡乱搞，不会卡暴力
 - 于是只枚举有公共部分的链
 - 注意使用树链剖分求 LCA 来减小常数
 - 可以通过测试点 $1,2,3,4,7,8,9,10,11,12,17$
 - $55'$
 - 加上一条链的情况可以 $65'$
 ![luogu](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fukuinl96qj30e10n8dhi.jpg)


 ## 基于迭代的乱搞♂
 - 前一个暴力中，我们事实上是求出了"确定了一条链后的最大答案"
 - 不难直接把这个过程改成乱搞♂
 - 随机取若干条链分别求答案取 $max$
 - 随机若干次，每次取一条链，找另一条链使得两条链答案最大，然后从另一条链出发执行操作，迭代多次并在每一步更新答案
 - 把链按照 {链代价，链长度，链经过边数} 的 {$-1,0,1$} 的系数组合排序，对前面一些链求出这些链的答案
 - 构造数据时，只需要保证每条链的答案接近，这样就能让链交部分的影响扩大到极致，从而卡掉所有这样的迭代乱搞♂
 - $\leq 30'$
 
## 链的数据
- 测试点 $4,5,6$ 中，树是一条链
- 从而每条链都是一个区间
- 枚举一条链后，直接用线段树维护即可
- $O(m$ $log$ $n) = 15'$

## 边权为 $0$
- 测试点 $4,5,6$ 中边权为 $0$
- 只需要两条链的权值和最小，链只要相交即可
- 枚举一条边，求所有经过这条边的链的最大值和次大值，用他们的和更新答案
- 求经过一条边的链可以用树上差分 + 启发式合并/可并堆完成
- $O(m$ $log$ $n) = 15'$

## 基于边的乱搞♂
- 这一个暴力同样也可以改成乱搞♂
- 对每条边求出经过它的按 {链代价，链长度，链经过边数} 的  {$-1,0,1$} 的系数组合排序的前若干大，两两之间求答案
- 然而，前面的构造方法同样可以把这个乱搞♂卡的痛不欲生
- $\leq 35'$

## LCA 两两不同 $(S_{1})$
- 对于 LCA 不同的两条链，两条链的交必然是直上直下的一段
- 因此可以把一条链拆成两条直上直下的链考虑
- 在树上枚举较下的交点 ($\color{red}\colorbox{white}{红点}$)
- 要求两条链的下端点必须在$\color{red}\colorbox{white}{红点}$的不同儿子子树中
- 长度和 + 权值和 - $\color{red}\colorbox{white}{红点}$深度 + $max$($\color{green}\colorbox{white}{绿点}$深度, $\color{blue}\colorbox{white}{蓝点}$深度 )
- 于是可以想到对每个点记 $f(i,j)$
- 下端点在 $i$ 子树内，上端点深度为 $j$ 的最大的链长度 + 权值
- 用启发式合并或线段树合并维护这个数组，$O(m$ $log$ $n) = 30'$
![luogu](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fukvjr8uamj306708yq34.jpg)


## LCA 全部相同 $(S_{2})$
- 对于这一部分数据，两条链的交可能不是直上直下的
- 关键性质 : 链并的两倍 = 两条链长 + $\color{blue}\colorbox{white}{蓝点}$距离 + $\color{green}\colorbox{white}{绿点}$距离
- 那么可以考虑枚举$\color{red}\colorbox{white}{红点}$，即$\color{blue}\colorbox{white}{蓝点}$的 LCA
- 要求两个$\color{blue}\colorbox{white}{蓝点}$属于$\color{red}\colorbox{white}{红点}$不同儿子的子树
- 这时候要考虑$\color{green}\colorbox{white}{绿点}$的距离
- 如果仍然用深度减去 LCA 深度考虑，无从下手
- 事实上可以**强行树链剖分**套线段树维护，但这样太难写
- 但我们是要最大化$\color{green}\colorbox{white}{绿点}$的距离，可以直接从$\color{green}\colorbox{white}{绿点}$的**最远点对**入手
![luogu](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fukvljd5ipj30bf06twev.jpg)
- 枚举$\color{red}\colorbox{white}{红点}$之后，我们的任务是 $↓$
- 选出两个属于$\color{red}\colorbox{white}{红点}$不同儿子子树的$\color{blue}\colorbox{white}{蓝点 a,b}$
- 使得它们对应$\color{green}\colorbox{white}{绿点}$ $p_{a},p_{b}$ 的距离 + 两条链链长和权值和 + 两个$\color{blue}\colorbox{white}{蓝点}$深度 $-$ $2$ $×$ $\color{red}\colorbox{white}{红点}$深度最大

- 注意到$\color{red}\colorbox{white}{红点}$深度是常数无需考虑
- 对于其他项，可以通过添加附加点 $p_{a}',p_{b}'$ 向 $p_{a},p_{b}$ 连接边权为自己所在链长 + 权值的边，转化为找**最远点对** $p_{a}',p_{b}'$
- 要求支持集合合并
- 在合并的时候，求出跨越两个集合的最远点对
![luogu](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fukvsbgxmuj30cp07kq3c.jpg)
- 对于非负边权的树，两个点集的并的最远点对的一端，一定是原来两个点集中，某个点集的最远点对的一端，一定是原来两个点集中，某个点集最远点对的一端
- 只需要对点集记录最远点对端点，即可支持合并
- 这个算法只需要在树上进行 DFS，以及求 $m$ 次的 LCA
- $O(n+m) = 20'$

## 满分算法
- 两条相交的链，要么 LCA 相同，要么 LCA 不同
- 对于 **LCA 不同**的**所有情况**已经可以处理了
- 对于 **LCA 相同**的情况，考虑**同时处理**以每个点为两条链的共同 LCA 的情况
- 对每个点 $p$ 记录 $f(p,j)$ 表示在点 $p$ 处理 **LCA 为 $j$ 时**保存的$\color{blue}\colorbox{white}{蓝点}$的集合（记录的是最远点信息）
- 对 $f$ 数组进行启发式合并，复杂度 $O(n + m$ $log$ $n)$
- 也可以进行点分治，考虑所有过重心的链，转化为全过一个点的情况，复杂度 $O(n$ $log$ $n+m$ $log$ $n)$
- $O(n + m$ $log$ $n)=$ $\color{green}\colorbox{white}{100}$ $'$ 

---

## 作者：Nemlit (赞：17)

~~纪念我逝去的一天~~

可以借助官方题解的图来理解>_<

题目问的实际上是给定$m$条链，链有权值，对于每两条相交的链，最大化链的权值和加上并集的边权和。

这类题目往往是分成两类来实现的，分别是$LCA$不同的两条链和$LCA$相同的两条链。

一、对于$LCA$不同的情况

我们要求的实际上是最大化两条链的权值和加上经过的边权和减去交集的边权和。

考虑到交集一定是一条直上直下的链，那么我们将原来的链拆成两条直上直下的链显然对答案没有影响。

由于所有链都是直上直下的，那么我们枚举两条链底端的$LCA$(设为$x$)，于是贡献就是两条链的权值和加上两条链的长度和$-dep[x]+max(\text{两条链顶端的深度})$。于是记录$f(i, j)$表示以$i$为根，向上拓展深度到$j$的最大权值。

对其做线段树合并，线段树上每个节点记录拓展深度在$j$的链长+链的权值，每次合并的时候相当于找一个前缀$max$。每次合并的时候更新答案。具体的，每次暴力每次记录两个值，一个是$max(val_i)$，另一个是$max(val_i+dep_i)$。每次合并答案的时候，右子树的深度显然更大，所以我们用左子树的第一个值加上右子树的第二个值即可。

注意$LCA$相同的不能合并，也就是到底之后我们不能选择。

二、对于$LCA$相同的情况

发现这些链已经不是直上直下的了，我们考虑优化这个柿子。我们对于每个$LCA$分开处理。

设每条链的长度为$len_i$，那么答案可以通过一种神奇的构造写成：$\dfrac{1}{2}(len_x+len_y+dis(LCA\text{一端底部两个点})+dis(LCA\text{另一端底部两个点}))-c_x-c_y$

枚举完$LCA$之后，建出所有询问点的虚树，枚举虚树上的每一个点作为$LCA$，也就是枚举一段底部两点的$LCA'$。

枚举完$LCA'$之后，发现$\dfrac{1}{2}(len_x+dep_x)-c_x$已经和$y$没有关系了，有关系的只剩下另一边两个端点，于是我们新挂一个节点挂到另一边端点下面去，然后问题转化为求树的直径。由于两个节点一定要来自两个不同的点，相当于求两个独立的点集构成的直径，可以证明这个直径一定产生于原来两个直径之中的，我们直接枚举一下即可。

需要注意的一点是，上述的结论只有在没有负权边的时候成立。但是由
于负权边只有可能在叶子节点出现，所以结论仍然成立。

### [丑陋无比的代码](https://loj.ac/submission/941851)

---

## 作者：Little_Cancel_Sunny (赞：16)

## 题解：P4775 [NOI2018] 情报中心

~~标程是人能写出来的吗。~~

### 简化题意

给你一棵有边权的树，然后给你 $m$ 个点对，选取一个点对有相应的代价，每个点对的收益为两点在树上经过的最短路径权值和。

需要你选出两个点对，使两个点对的最短路径有交，问收益减去代价的最大值。

注：重复的边权值只算一次。

### 思路

遇到这种复杂的题，我们先将问题分割成若干个子问题：

1. 如何找到合法点对？

2. 如何计算两个合法点对的收益以及寻找最大值？

合法点对，我们先来画几张图来观察一下合法点对的性质：

![](https://cdn.luogu.com.cn/upload/image_hosting/nbp50r3c.png)

这几种情况貌似就可以说明所有的情况了。

不难发现，两条线如果有交，那么其中一条的 lca 必然在另外一条的路径上。

所以我们的方向就逐渐转向 lca。

如何解决收益呢？重合的部分可能因为相交的形态不同而计算方式不同，所以我们果断放弃计算重合部分的方法。继续观察上图，不难发现：
$$
2 \cdot ans=val=dis(u_1,v_1)+dis(u_2,v_2)+dis(u_1,u_2)+dis(v_1,v_2)-2 \cdot cost_1-2 \cdot cost_2
$$
~~这好发现吗。~~

这式子有用吗？我们来化一化，首先我们先将只与自己有关的点对写在一起，因为它们可以预处理出来，设：
$$
w(u)=dis(u,v)-2 \cdot cost
$$
所以：
$$
val=w(u_1)+w(u_2)+dis(u_1,u_2)+dis(v_1,v_2)
$$
我们发现 $dis(u_1,u_2)$ 可以化为只与 $u$ 有关的式子：
$$
dis(u_1,u_2)=dis(u_1,rt)+dis(u_2+rt)-dis(lca,rt)
$$
然后我们发现这不是也可以预处理吗，我们又设：
$$
w(u)=dis(u,v)+dis(u,rt)-2 \cdot cost
$$
所以：
$$
val=w(u_1)+w(u_2)-2 \cdot dis(lca(u_1,u_2),rt)+dis(v_1,v_2)
$$
但是此时 $-2 \cdot dis(lca(u_1,u_2),rt)+dis(v_1,v_2)$ 这个式子已经不再好化了，我们上文提到过由于我们需要保证选的点对合法，最简单的方向就是向 lca 靠。所以如果此时我们枚举 lca 那么$-2 \cdot dis(lca(u_1,u_2),rt)$ 就会变为一个我们已知的定值，然后此时我们就只需要维护 $dis(v_1,v_2)$ 了。

那这不就是树上最远点对了吗？你爱咋做咋做，像啥淀粉树，线段树呀维护一下就可以了。

我们这里考虑线段树合并的做法，对于每一个点开一颗线段树，树上维护最终组合对即可。

当然我们需要保证点对的合法性，所以考虑在某些位置删除掉不会做贡献的点的贡献。这里可以考虑树上差分，在询问时将点的贡献拍入该点的线段树上，在其到 lca 路径中的 lca 的儿子节点打上删除标记，到了就删就行了。

至于为什么要在儿子结点删除，看一下面的图吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/yhbfw0rm.png)

这种组合显然不合法，但是如果我们在 lca 处删除 $u$，$v$ 的贡献，这种情况就会被统计入答案，所以我们要在 lca 的儿子结点删除。

但是还有问题，我们的 $u$，$v$ 不都像我们画的图一样有序，这是考虑对四种不同的组合方式枚举即可。

### 代码

喜滋滋的代码时间。

写完后才发现倍增求 lca 似乎更好写？

```cpp
#include<bits/stdc++.h>
namespace fast_IO {
#define IOSIZE 1000000
	char ibuf[IOSIZE], obuf[IOSIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
#define isdigit(ch) (ch>47&&ch<58)
#define isspace(ch) (ch<33)
	template<typename T> inline T read() { T s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s * w; }
	template<typename T> inline bool read(T &s) { s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s *= w, true; }
	template<typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; if (x > 9) print(x / 10); putchar(x % 10 + 48); }
	inline bool read(char &s) { while (s = getchar(), isspace(s)); return true; }
	inline bool read(char *s) { char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) *s++ = ch, ch = getchar(); *s = '\000'; return true; }
	inline void print(char x) { putchar(x); }
	inline void print(char *x) { while (*x) putchar(*x++); }
	inline void print(const char *x) { for (int i = 0; x[i]; i++) putchar(x[i]); }
	inline bool read(std::string& s) { s = ""; char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) s += ch, ch = getchar(); return true; }
	inline void print(std::string x) { for (int i = 0, n = x.size(); i < n; i++) putchar(x[i]); }
	inline bool read(bool &b) { char ch; while(ch=getchar(), isspace(ch)); b=ch^48; return true; }
	inline void print(bool b) { putchar(b+48); }
	template<typename T, typename... T1> inline int read(T& a, T1&... other) { return read(a) + read(other...); }
	template<typename T, typename... T1> inline void print(T a, T1... other) { print(a), print(other...); }
	struct Fast_IO { ~Fast_IO() { fwrite(obuf, p3 - obuf, 1, stdout); } } io;
	template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) { return read(b), io; }
	template<typename T> Fast_IO& operator << (Fast_IO &io, T b) { return print(b), io; }
#define cout io
#define cin io
#define endl '\n'
} using namespace fast_IO;
using namespace std;
#define lson t[k].ls
#define rson t[k].rs
#define int long long
//对于两个点对，如果合法，那么其贡献为val=dis(u_1,v_1)+dis(u_2,v_2)+dis(u_1,u_2)+dis(v_1,v_2)-2cost_1-2cost_2
//继续转化我们设一点对中一个点的贡献为w(u)=dis(u,v)-2cost,对于v是一样的
//所以val=w(u_1)+w(u_2)+dis(u_1,u_2)+dis(v_1,v_2)
//此时如果我们加入v_1,v_2的lca
//那么式子为val=w(u_1)+w(u_2)+dis(u_1,u_2)+dis(v_1,rt)+dis(v_2,rt)-2*dis(lca,rt)
//我们再次定义设w(u)=dis(u,v)-2cost+dis(v,rt)
//则val=w(u_1)+w(u_2)+dis(u_1,u_2)-2*dis(lca,rt)
//那么对于每个点的w我们均可以预处理出来。
//而如果我们枚举lca，则2*dis(lca,rt)为定值，那么我们需要维护的就只有dis(u_1,u_2)了

const int N=1e6+15;
const int inf=1e18;

int h[N],to[N],ne[N],w[N],idx=0;
int siz[N],son[N],fa[N],topfa[N],dep[N];
int in[N],out[N],dis[N],tim;
queue<int> rub;
vector<int> del[N];
struct pair_point
{
	pair<int,int> u,v;
}ansp;
struct segment_tree
{
	int ls,rs;
	pair_point sum;
}t[N<<3];
int rt[N];
int n,m,T,cnt;
int ans;

void init()
{
	while(!rub.empty())
		rub.pop();
	for(int i=1;i<=n;i++)
	{
		del[i].clear();
		son[i]=fa[i]=0;
		dis[i]=dep[i]=0;
		fa[i]=topfa[i]=0;
		in[i]=out[i]=0;
		h[i]=-1;
		rt[i]=0;
	}
	for(int i=1;i<=cnt;i++)
		t[i].ls=t[i].rs=0,t[i].sum={{0,0},{0,0}};
	tim=cnt=idx=0;
	ans=-inf;
}

void add(int u,int v,int val)
{
	to[++idx]=v;
	ne[idx]=h[u];
	h[u]=idx;
	w[idx]=val;
}

void get_fa(int u,int f)
{
	fa[u]=f;
	siz[u]=1;
	dep[u]=dep[f]+1;
	in[u]=++tim;
	for(int i=h[u];i!=-1;i=ne[i])
	{
		int v=to[i];
		if(v==f)
			continue;
		dis[v]=dis[u]+w[i];
		get_fa(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]||!son[u])
			son[u]=v;
	}
	out[u]=tim;
}	

void get_topfa(int u,int topf)
{
	topfa[u]=topf;
	if(son[u])
		get_topfa(son[u],topf);
	for(int i=h[u];i!=-1;i=ne[i])
	{
		int v=to[i];
		if(v==son[u]||v==fa[u])
			continue;
		if(!topfa[v])
			get_topfa(v,v);
	}
}

pair<int,pair<int,int>> get_lca(int x,int y)
//返回<lca,<x->lca中lca的儿子 >,<y->lca 中lca的儿子>>
{
	bool fl=0;
	int resx=x;
	int resy=y;
	while(topfa[x]!=topfa[y])
	{
		if(dep[topfa[x]]<dep[topfa[y]])
			swap(x,y),swap(resx,resy),fl^=1;
		resx=topfa[x];
		x=fa[topfa[x]];
	}
	int lca;
	if(x==y)
		lca=x;
	else if(dep[x]<dep[y])
		lca=x,resy=son[x];
	else
		lca=y,resx=son[y];
	if(fl)
		swap(resx,resy);
	return {lca,{resx,resy}};
}

int new_node()
{
	if(!rub.empty())
	{
		int l=rub.front();
		rub.pop();
		return l;
	}
	else 
		return ++cnt;
}

bool check(pair<int,int> x,pair<int,int> y,int &maxx)
{
	if(x.first&&y.first)
	{
		int lca=get_lca(x.first,y.first).first;
		int res=dis[x.first]+dis[y.first]-2*dis[lca]+x.second+y.second;
		if(res>maxx)
		{
			maxx=res;
			return 1;
		}
		else 
			return 0;
	}
	return 0;
}

int merge_ans(pair_point &ans,pair_point x,pair_point y)
{
	if(!x.u.first&&!x.v.first)
	{
		ans=y;
		return -inf;
	}
	if(!y.u.first&&!y.v.first)
	{
		ans=x;
		return -inf;
	}
	int maxx=-inf;
	int res;
	int opt=0;
	if(check(x.u,y.u,maxx))
		opt=1;
	if(check(x.u,y.v,maxx))
		opt=2;
	if(check(x.v,y.u,maxx))
		opt=3;
	if(check(x.v,y.v,maxx))
		opt=4;
	res=maxx;
	if(check(x.u,x.v,maxx))
		opt=5;
	if(check(y.u,y.v,maxx))
		opt=6;
	if(opt==1)
		ans={x.u,y.u};
	if(opt==2)
		ans={x.u,y.v};
	if(opt==3)
		ans={x.v,y.u};
	if(opt==4)
		ans={x.v,y.v};
	if(opt==5)
		ans={x.u,x.v};
	if(opt==6)
		ans={y.u,y.v};
	return res;
}

void clear(int k)
{
	t[k].ls=t[k].rs=0;
	t[k].sum={{0,0},{0,0}};
	rub.push(k);
}

void push_up(int k)
{
	if(!lson||!rson)
		t[k].sum=t[lson+rson].sum;
	merge_ans(t[k].sum,t[lson].sum,t[rson].sum);
}

void update_add(int &k,int l,int r,int pos,pair<int,int> x)
{
	if(!k)
		k=new_node();
	if(l==r)
	{
		t[k].sum.u=x;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)
		update_add(lson,l,mid,pos,x);
	else 
		update_add(rson,mid+1,r,pos,x);
	push_up(k);
}

void update_del(int &k,int l,int r,int pos)
{
	if(!k)
		k=new_node();
	if(l==r)
	{
		t[k].sum.u={0,0};
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)
		update_del(lson,l,mid,pos);
	else 
		update_del(rson,mid+1,r,pos);
	push_up(k);
}

int merge_tree(int x,int y)
{
	if(!x||!y)
		return x+y;
	merge_ans(t[x].sum,t[x].sum,t[y].sum);
	t[x].ls=merge_tree(t[x].ls,t[y].ls);
	t[x].rs=merge_tree(t[x].rs,t[y].rs);
	clear(y);
	return x;
}

void get_ans(int u)
{
	for(int i=h[u];i!=-1;i=ne[i])
	{
		int v=to[i];
		if(v==fa[u])
			continue;
		get_ans(v);
		ans=max(ans,merge_ans(ansp,t[rt[u]].sum,t[rt[v]].sum)-2*dis[u]);
		rt[u]=merge_tree(rt[u],rt[v]);
	}
	for(auto v:del[u])
		update_del(rt[u],1,m,v);
}

signed main()
{
	// freopen("center.in","r",stdin);
	// freopen("center.out","w",stdout);
	cin>>T;
	while(T--)
	{
		cin>>n;
		init();
		for(int i=1;i<n;i++)
		{
			int u,v,w;
			cin>>u>>v>>w;
			add(u,v,w);
			add(v,u,w);
		}
		get_fa(1,0);
		get_topfa(1,1);
		// int x,y;
		// cin>>x>>y;
		// cout<<get_dis(x,y);
		cin>>m;
		for(int i=1;i<=m;i++)
		{
			int u,v,cost;
			cin>>u>>v>>cost;
			pair<int,pair<int,int>> res=get_lca(u,v);
			int lca=res.first;
			int w=dis[u]+dis[v]-2*dis[lca]-2*cost;
			int lu=res.second.first;
			int lv=res.second.second;
			// cout<<"e le mi "<<lca<<" "<<lu<<" "<<lv<<endl;
			if(u!=lca)
			{
				pair<int,int> val={v,w+dis[u]};
				ans=max(ans,merge_ans(ansp,{val,{0,0}},t[rt[u]].sum)-2*dis[u]);
				update_add(rt[u],1,m,i,val);
				del[lu].push_back(i);
			}
			if(v!=lca)
			{
				pair<int,int> val={u,w+dis[v]};
				ans=max(ans,merge_ans(ansp,{val,{0,0}},t[rt[v]].sum)-2*dis[v]);
				update_add(rt[v],1,m,i,val);
				del[lv].push_back(i);
			}
		}
		get_ans(1);
		if(ans==-inf)
			cout<<"F"<<endl;
		else
			cout<<ans/2<<endl;
	}
	return 0;
}
```

---

## 作者：Time_tears (赞：15)

这是一篇不需要分类讨论的做法，而且空间复杂度是 $O(n+m)$ 的，借鉴了 @command_block 巨佬的做法并加以改进，希望对大家有帮助。

考虑两条路径并的贡献应该是：
$$\dfrac{dis(x_1,y_1)+dis(x_2,y_2)+dis(x_1,x_2)+dis(y_1,y_2)-2\times v_1-2\times v_2}{2}$$

其中 $dis(x,y)$ 表示 $x$ 到 $y$ 的边权和。

然后我们考虑枚举 $t=lca(x_1,x_2)$，同时把常数 $\dfrac{1}{2}$ 提到最后处理，此时贡献变为：

$$(dis(x_1,y_1)-2\times v_1+dep_{x_1})+(dis(x_2,y_2)-2\times v_2+dep_{x_2})+dis(y_1,y_2)-2\times dep_t$$

考虑到对于固定的 $x_1$，$w_{x_1}=dis(x_1,y_1)-2\times v_1+dep_{x_1}$ 是个定值，所以此时我们可以求出在 $t$ 固定的情况下的直径端点来更新答案。

考虑快速的维护这个直径，由于边权都是正权，所以直径是有可合并性的（即使点权为负），所以利用这个结论，只需计算 $6$ 次两点距离，就能合并点集最远点对，使用 $O(n\log n)-O(1)$ 求 LCA，复杂度为 $O(1)$。

我们现在把 $x-y$ 的链拆成 $x-lca,y-lca$ 的两条链，这样交的 $x_1,x_2$ 的 $lca$ 只会在这两条链的其中一条上,所以可以使用树上差分，在 $x$ 加入，在 $x$ 到 $lca$ 的路径上的倒数第二个点删除。

现在要维护的就是对于每个 $t$，$t$ 的不同子树合并的贡献，所以这个地方可以使用线段树合并，但是有更好的做法。

我们直接对所有树上差分的操作开一个位置来统计，这样总的位置数是 $O(2m)$ 的，然后修改就直接单点修改清为 $0$，查询两个子树的直径并就变成了查询两个区间的直径并，这个直接用单修区查线段树维护即可，并不需要使用线段树合并。


时间复杂度 $O(n\log n+m\log m)$，空间复杂度 $O(n+m)$，应该是空间复杂度最优秀的代码，只是时间复杂度上因为要维护直径导致常数较大，不过也能无压力的通过此题，同时代码也清晰易懂，只有 4k，~~这不比 8k 的分类讨论优秀？~~

```cpp
#include<bits/stdc++.h>
#define N 100005
#define ll long long
#define mp make_pair
#define pr pair<int,ll>
#define fi first
#define se second
using namespace std;
const ll inf=1e18;const int Mxdt=1000000;
int h[N],cnt,to[N<<1],nx[N<<1],vl[N<<1];
int n,m,Log[N],fa[20][N],dep[N],X,Y;
int in[N],out[N],P[N],fp[N],dfn[N],U[N];
ll ans,dis[N],Z;pr p[N];vector<int>g[N],del[N];
struct ET {
	int x,d;
	ET(int X=0,int D=0) {x=X,d=D;}
	bool operator<(ET a) const {return d<a.d;}
} f[20][N<<1];
struct Pair {pr x,y;} tmp,rt[N],t[N<<3];
inline char gc() {
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline char pc(char ch,bool bj) {
	static char buf[Mxdt],*p1=buf,*p2=buf+Mxdt;
	return (bj||(*p1++=ch)&&p1==p2)&&fwrite(p1=buf,1,p1-buf,stdout),0;
}
inline ll read() {
	ll res=0;char ch=gc();
	while(ch<'0')ch=gc();
	while(ch>='0')res=(res<<3)+(res<<1)+(ch^48),ch=gc();
	return res;
}
void Addedge(int x,int y,int z) {
	nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z;
	nx[++cnt]=h[y],to[h[y]=cnt]=x,vl[cnt]=z;
}
void Dfs(int x,int p) {
	P[++X]=fp[dfn[x]=++cnt]=x,dep[x]=dep[fa[0][x]=p]+1;
	for(int i=h[x]; i; i=nx[i])if(to[i]!=p)dis[to[i]]=dis[x]+vl[i],Dfs(to[i],x),fp[++cnt]=x;
}
void Build() {
	Log[0]=-1;for(int i=1; i<=cnt; ++i)f[0][i]=ET(fp[i],dep[fp[i]]),Log[i]=Log[i>>1]+1;
	for(int i=1; (1<<i)<=cnt; ++i)
		for(int j=1; j+(1<<i)<=cnt+1; ++j)fa[i][j]=fa[i-1][fa[i-1][j]],f[i][j]=min(f[i-1][j],f[i-1][j+(1<<i-1)]);
}
int Lca(int x,int y) {x=dfn[x],y=dfn[y];if(x>y)swap(x,y);int len=Log[y-x+1];return min(f[len][x],f[len][y-(1<<len)+1]).x;}
int Findk(int x,int k) {for(; k>0; k-=k&-k)x=fa[Log[k&-k]][x];return x;}
ll Dis(int x,int y) {return dis[x]+dis[y]-2*dis[Lca(x,y)];}
ll Dis(pr x,pr y) {return Dis(x.fi,y.fi)+x.se+y.se;}
ll Merge(Pair&a,Pair A,Pair B) {
	if(!A.x.fi&&!A.y.fi)return a=B,-inf;
	if(!B.x.fi&&!B.y.fi)return a=A,-inf;
	ll ans,mx=-inf,tmp;
	if((tmp=Dis(A.x,B.x))>mx)mx=tmp,a=(Pair){A.x,B.x};
	if((tmp=Dis(A.x,B.y))>mx)mx=tmp,a=(Pair){A.x,B.y};
	if((tmp=Dis(A.y,B.x))>mx)mx=tmp,a=(Pair){A.y,B.x};
	if((tmp=Dis(A.y,B.y))>mx)mx=tmp,a=(Pair){A.y,B.y};ans=mx;
	if((tmp=Dis(A.x,A.y))>mx)mx=tmp,a=(Pair){A.x,A.y};
	if((tmp=Dis(B.x,B.y))>mx)mx=tmp,a=(Pair){B.x,B.y};return ans;
}
void Build(int P,int l,int r) {
	if(l==r)return t[P].x=t[P].y=p[U[l]],void();
	int mid=(l+r)>>1;Build(P<<1,l,mid),Build(P<<1|1,mid+1,r);
	Merge(t[P],t[P<<1],t[P<<1|1]);
}
void Change(int p,int l,int r,int x) {
	if(l==r)return t[p].x=t[p].y=mp(0,0),void();
	int mid=(l+r)>>1;(x<=mid)?Change(p<<1,l,mid,x):Change(p<<1|1,mid+1,r,x);
	Merge(t[p],t[p<<1],t[p<<1|1]);
}
Pair Ask(int p,int l,int r,int ql,int qr) {
	if(ql>qr)return (Pair){mp(0,0ll),mp(0,0ll)};
	if(ql<=l&&r<=qr)return t[p];int mid=(l+r)>>1;
	if(qr<=mid)return Ask(p<<1,l,mid,ql,qr);
	if(ql>mid)return Ask(p<<1|1,mid+1,r,ql,qr);
	return Merge(tmp,Ask(p<<1,l,mid,ql,qr),Ask(p<<1|1,mid+1,r,ql,qr)),tmp;
}
void Solve(int x,int fa) {
	for(int i=h[x],y; i; i=nx[i])
		if((y=to[i])!=fa)Solve(y,x),ans=max(ans,Merge(tmp,Ask(1,1,cnt,in[x],out[x]),Ask(1,1,cnt,in[y],out[y]))-2*dis[x]),out[x]=out[y];
	for(int i:del[x])Change(1,1,cnt,fp[i]);
}
void Solve(int T) {
	for(int i=(n=read())-1; i; --i)X=read(),Y=read(),Z=read(),Addedge(X,Y,Z);
	ans=-inf,Dfs(1,X=cnt=0),Build(),m=read(),cnt=0;
	for(int i=1; i<=m; ++i) {
		if(X=read(),Y=read(),Z=read(),X==Y)continue;Z=Dis(X,Y)-2*Z;
		int lca=Lca(X,Y),tx=Findk(X,dep[X]-dep[lca]-1),ty=Findk(Y,dep[Y]-dep[lca]-1);
		if(X!=lca)p[++cnt]=mp(Y,Z+dis[X]),ans=max(ans,Merge(rt[X],rt[X],(Pair){p[cnt],p[cnt]})-2*dis[X]),g[X].push_back(cnt),del[tx].push_back(cnt);
		if(Y!=lca)p[++cnt]=mp(X,Z+dis[Y]),ans=max(ans,Merge(rt[Y],rt[Y],(Pair){p[cnt],p[cnt]})-2*dis[Y]),g[Y].push_back(cnt),del[ty].push_back(cnt);
	}
	cnt=0;for(int i=1; i<=n; ++i){in[P[i]]=cnt+1;for(int j:g[P[i]])U[fp[j]=++cnt]=j;out[P[i]]=cnt;}
	if(!cnt)puts("F");else {Build(1,1,cnt),Solve(1,0);if(ans<=-inf/100)puts("F");else cout<<ans/2<<"\n";}
	for(int i=1; i<=n; ++i)h[i]=0,rt[i].x=rt[i].y=mp(0,0),g[i].clear(),del[i].clear();cnt=0;
}
int main() {
	for(int T=read(); T; --T)Solve(T);
	return 0;
}
```

---

## 作者：__stick (赞：4)



## 题意

给出一颗带边权的树，和树上若干路径。问选择两条有交集（边） 的路径，路径并集上的边权和减去路径成本的最大值。

## 思路

首先是这个并集边权和的算法。

![img](https://cdn.luogu.com.cn/upload/image_hosting/y7p06ph9.png)

（偷的 command_block 的）

然后两个路径的权值（乘以 2）就是：
$$
dis(x_1,x_2)+dis(x_1,y_1)+dis(x_2,y_2)+dis(y_1,y_2)-2\cdot v_1-2\cdot v_2
$$
则枚举 lca t，将贡献拆开：
$$
dep_{x_1}+dep_{x_2}+dis(x_1,y_1)-2\cdot v_1+dis(x_2,y_2)-2\cdot v_2+dis(y_1,y_2)-2\cdot dep_t
$$
发现 $x_1,x_2$ 的形式完全一样并且可以计算，所以将这个设为权值。

$w(x_1)=dep_{x_1}+dis(x_1,y_1)-2\cdot v_1$ 

这样问题就变成了选择两个 lca 是 t 的 $x_1,x_2$ 使得他们的权值和加上  $dis(y_1,y_2)$ 最大。

然后会发现问题变成了直径问题，将 $y_1,y_2$ 看做带权值的端点即可。

这里直径的经典性质就是点集和的直径一定在两个集合的直径中产生。

所以使用一些数据结构维护子树点集和的直径即可。

其余大佬使用线段树。

然而可以简单使用左偏树来实现。

具体做法就是在 $x_1$ 处塞进堆里，然后在路径 lca 处删除，就是树上差分，堆使用深度进行比较就行了。

这样在 dfs 的时候当前节点 $u$ 和即将合并上来的 $v$ 子树只要满足路径  lca 是 $u$ 的祖先即可，这样交集一定至少有这一条边，然后再使用直径算法计算答案，这里只能统计跨集合的直径，内部的 lca 已经不是当前点了。

然后直接左偏树合并并且维护当前堆中点集的直径即可，这个在 merge 函数中写个合并直径的东西就行了，想咋写咋写。

注意使用 $O(n\log n)-O(1)$ 的 LCA 算法降低复杂度。

总复杂度 $O(n\log n)$。

## code

写完才发现左偏树部分的数组开小了，但是能过，比较神奇。

注意这个题读入会有 $50$ 多 MB，快读可以大大减小运行时间，目前是 luogu 最优解。

```
const int MAXN=5e4+10;
struct edge{int from,v,w;}e[MAXN*2];
int cntp;
int head[MAXN];
inline void add(int u,int v,int w){e[++cntp]={head[u],v,w},head[u]=cntp;}
int dfn[MAXN];
const int K=16;
int F[K+1][MAXN];
int d[MAXN];
inline int Min(int x,int y){return d[x]<d[y]?x:y;}
int tt;
ll val[MAXN];
void dfs(int u,int fa)
{
    F[0][dfn[u]=++tt]=fa;d[u]=d[fa]+1;
    for(int i=head[u];i;i=e[i].from)val[e[i].v]=val[u]+e[i].w,dfs(e[i].v,u);
}
inline int LCA(int x,int y)
{
    if(x==y)return x;
    x=dfn[x],y=dfn[y];if(x>y)swap(x,y);
    int k=31-__builtin_clz(y-x);
    return  Min(F[k][x+1],F[k][y-(1<<k)+1]);
}
inline ll dis(int x,int y){return val[x]+val[y]-2ll*val[LCA(x,y)];}
const int MAXM=MAXN*2;
int id;
int dep[MAXM],son[MAXM][2];
int w[MAXM];
array<int,2>a[MAXM];
array<ll,2>b[MAXM];
int merge(int x,int y)
{
    if(!x||!y)return x|y;
    if(w[x]<w[y])swap(x,y);
    for(int i=0;i<2;i++)if(~a[y][i])
    {
        int z=-1;
        if(a[x][1]<0)z=1;
        else
        {
            ll v=dis(a[x][0],a[x][1])+b[x][0]+b[x][1];
            array<ll,2>t;
			for(int j=0;j<2;j++)t[j]=dis(a[x][j],a[y][i])+b[x][j]+b[y][i];
			if(t[0]>t[1])t[0]>v?z=1:1;
			else t[1]>v?z=0:0;
        }
        if(~z)a[x][z]=a[y][i],b[x][z]=b[y][i];
    }
    son[x][1]=merge(son[x][1],y);
    if(dep[son[x][0]]<dep[son[x][1]])swap(son[x][0],son[x][1]);
    dep[x]=dep[son[x][0]]+1;
    return x;
}

struct node
{
    int from,l,x;ll v;
}ve[MAXM*2];
int hd[MAXN];
int tot;
int rt[MAXN];
ll ans;
int cnt=0;
void dfs2(int u,int fa)
{
    rt[u]=0;
    for(int i=hd[u];i;i=ve[i].from)
    {
    	auto p=ve[i];
        for(int i=0;i<2;i++)if(rt[u]&&~a[rt[u]][i])
        {
            cmax(ans,dis(p.x,a[rt[u]][i])+b[rt[u]][i]+p.v-2ll*val[u]);  
        }
        cnt++;
        dep[cnt]=0;w[cnt]=p.l;
        son[cnt][0]=son[cnt][1]=0;
        a[cnt]={p.x,-1},b[cnt]={p.v,0};
        rt[u]=merge(rt[u],cnt);
    }
    for(int i=head[u];i;i=e[i].from)
    {
    	int v=e[i].v;
        dfs2(v,u);
        if(fa)
        {
            while(rt[v]&&w[rt[v]]>=u)rt[v]=merge(son[rt[v]][0],son[rt[v]][1]);
            for(int i=0;i<2;i++)if(rt[u]&&~a[rt[u]][i])
                for(int j=0;j<2;j++)if(rt[v]&&~a[rt[v]][j])
                    cmax(ans,dis(a[rt[u]][i],a[rt[v]][j])+b[rt[u]][i]+b[rt[v]][j]-2ll*val[u]);
            rt[u]=merge(rt[u],rt[v]);
        }
    }
}
inline void solve()
{
    int n=R();
    for(int i=1;i<=n;i++)head[i]=0;
    for(int i=1;i<=n;i++)hd[i]=0;
    cntp=0;
    for(int i=1,u,v,w;i<n;i++)u=R(),v=R(),w=R(),add(u,v,w);
    tt=0;
    dfs(1,0);
    for(int i=1;i<=K;i++)
        for(int j=1;j+(1<<i)-1<=n;j++)
            F[i][j]=Min(F[i-1][j],F[i-1][j+(1<<(i-1))]);
    int m=R();
    int u,v;ll w;
    tot=0;
    while(m--)
    {
        u=R(),v=R(),w=R();
        int l=LCA(u,v);
        ll x=dis(u,v)-2ll*w;
        if(u!=l)ve[++tot]={hd[u],l,v,x+val[u]},hd[u]=tot;
        if(v!=l)ve[++tot]={hd[v],l,u,x+val[v]},hd[v]=tot;
    }
    ans=LONG_LONG_MIN;
    cnt=0;
    dfs2(1,0);
    if(ans==LONG_LONG_MIN)
    {
        cout<<"F\n";
        return;
    }
    cout<<ans/2<<'\n';
}
int main()
{
	//ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(10);
	int T=R();while(T--)solve();
	return 0;
} 
```





---

## 作者：liruixiong0101 (赞：0)

首先将路径并长度转化。由于两条路径**有边相交**，所以考虑这四个端点的虚树，虚树的所有边之和就等于路径并长度。

又有结论，若干个点按照 DFS 序排序，相邻两点（最后一个点和第一个点也相邻）的路径长度之和为虚树所有边之和的两倍。

那么对于两条，我们可以求出其贡献为：
$$
\frac{\operatorname{dis}(x_1,y_1)+\operatorname{dis}(x_2,y_2)+\operatorname{dis}(x_1,x_2)+\operatorname{dis}(x_1,y_2)}2-v_1-v_2
$$

将 $2$ 提出，并将其分成 $\operatorname{dis}(x_1,y_1)-2v_1$、$\operatorname{dis}(x_2,y_2)-2v_2$ 、$\operatorname{dis}(x_1,x_2)$ 和 $\operatorname{dis}(y_1,y_2)$ 的和。

前两者很好计算，因为没有交叉项。$\operatorname{dis}(x_1,x_2)$ 我们可以通过枚举 $l=\operatorname{lca}(x_1,x_2)$ 的方式，将其转化为 $d_{x_1}+d_{x_2}-2d_l$。

如果我们令 $f_i=\operatorname{dis}(x_i,y_i)+d_{x_i}-2v_i$。

那么贡献就转化为 $f_1+f_2+\operatorname{dis}(y_1,y_2)-2d_l$，由于 $d_l$ 是常数可以不管。

---

接着考虑这两条路径需要满足什么要求。

1. $\operatorname{lca}(x_1,x_2)=l$。
2. 两条路径有边相交。

第一个条件表明 $x_1,x_2$ 在 $l$ 的不同儿子的子数内；或者有其中一个为 $l$，另一个在 $l$ 的子树内。

第二个条件中相交的边显然为 $l$ 到根的路径上靠近 $l$ 的边。

我们考虑每条路径对 $l$ 的贡献，由上可知路径 $(x_i,y_i)$ 会对 $(x_i,\operatorname{lca}(x_i,y_i))$（不包含 $\operatorname{lca}(x_i,y_i)$，否则只有点相交）上的所有点产生贡献。

又因为贡献 $f_i+f_j+\operatorname{dis}(y_i,y_j)$ 具有合并性（跟直径类似），我们可以用线段树维护一个子集的“直径”端点，并结合树上差分和线段树合并，维护出每一个 $l$ 被子树中的点的贡献。

---

这道题有一点细节，由于 $x_1,x_2$ 不能在 $l$ 的同一颗子树内，所以在 单点修改和查询的时候需要注意一下。

---

## 作者：2018ljw (赞：0)

观察特殊性质不难想到基于每条链的 lca 考虑。

共两种情况，LCA 相同或不同。

记 $cost_x$ 表示路径 $x$ 的支出，$sum_x$ 为 路径 $x$ 的权值和，$val_x=sum_x-cost_x$，$dep_x$ 为**节点** $x$ 到根的权值和。

## LCA 不同

此时，两条链一旦有交，必定是直上直下的一段交集，且其中一个交点为两条链中较深者的 lca。

![](https://cdn.luogu.com.cn/upload/image_hosting/uzw36yfa.png)

此时 $p$ 即为交点，这对路径的答案为 $val_1+val_2-(dep_p-dep_{r1})=val_1+dep_{r1}+val_2-dep_p$。

前三项都只与路径本身有关，那么第四项呢？

好办，枚举 $p$，相当于从 $p$ 的不同子树中各选一条路径，使得前三项之和最大。

考虑线段树，$x$ 处分别维护当前子树内，所有 $dep_{lca}=x$ 的链中，$val$ 和 $val+dep_r$ 的最大值。当我们合并两个子树时，要对每个 $x$ 找到 $<x$ 且最大的 $val$，加上 $x$ 的 $val+dep$ 更新答案，不难发现放到线段树合并的过程中，实际上就是统计左子树对右子树的贡献。

是不是忘了什么？

$p$ 不能和 $r_1$ 相等，否则此时两条路径边集不交。也不能统计 lca 比 $p$ 还深的路径，这些路径根本上不来。

不难发现，实际上，只需要每次合并前，把待合并的线段树的 $dep_p$ 位置更新为 $(-\inf,-\inf)$ 即可规避。

复杂度 $O(n\log n)$。

## LCA 相同

两条链的交集长的奇形怪状，但注意到此时两条路径的 $lca$ 只有 $O(n)$ 个，因此我们枚举 $r=lca$，对有用的路径两端点建立虚树。

![](https://cdn.luogu.com.cn/upload/image_hosting/fuukktps.png)

$p_1,p_2$ 等效，考虑枚举 $p=p_1$ 计算，答案为 $val_1+val_2-dep_{p}-dep_{p2}+2\times dep_r$。但我们似乎也没什么好的办法搞掉这个 $p_2$。

关注到路径总和实际上还有一种写法：$\frac 12\left(sum_1+sum_2+dis(x_1,x_2)+dis(y_1,y_2)\right)$。因此答案为 $\frac{1}{2}(val_1+val_2-cost_1-cost_2+dep_{x_1}+dep_{x_2}+dis(y_1,y_2))-dep_p$

枚举 $p$ 的时候，似乎只有 $dis(y_1,y_2)$ 是未知项了，但怎么求呢？

考虑如下转化：我们给 $y$ 节点添加一个儿子 $y^\prime$，边权为 $val-cost+dep_x$。那么左边整体就变成了 $\frac 12dis(y_1^\prime,y_2^\prime)$。

因此我们需要最大化左半，就相当于求树上由特定叶子为两端点的直径。由于这题只有叶子到父节点的边权可以为负，并且直径两端点要求为叶子，因此很多结论都可以直接用。

比较经典的就是点集 $S_1$ 的直径为 $(x_1,y_1)$，$S_2$ 的直径为 $(x_2,y_2)$，则 $S_1\cup S_2$ 总有一条直径 $(x,y)$ 使得 $x,y\in\{x_1,x_2,y_1,y_2\}$。

因此 dfs 流程中记录每个子树对应的直径，合并即可。

但实际上还是有些细节的惹。

我们依旧不能令 $p=r$，此时两条路径边无交集。若是左半交在 $r$ 右半交在 $p_2$，则会在 $p=p_2$ 时被计算。

此外，式子第一部分的最大值并不是单纯的该点维护的直径长度，因为路径需要保证 $x_1,x_2$ 以该点为 lca。因此实际值为在该点进行若干次合并时，从两半各选出一个点的距离的最大值。别忘了除以二。

另外记得初值是 $-\inf$ 不是 $0$。

复杂度 $O(n\log n)$。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cassert>
#define ls(x) tre[x].ls
#define rs(x) tre[x].rs
const long long inf=1e18;
using namespace std;
int n,m;
int hed[300001],net[600001],ver[600001],tot;
long long e[600001],res;
void add(int x,int y,long long z){
	ver[++tot]=y;
	e[tot]=z;
	net[tot]=hed[x];
	hed[x]=tot;
}
struct path{
	int x,y,r,rx,ry;
	long long sum,cost;
}a[100001];
long long dis[300001];
int dfn[300001],pos[300001],cnt;
int fa[300001],lg[300001],sz[300001];
namespace LCA{
	int dep[300001];
	int st[300001][20],bst[300001][20];
	void dfs0(int x){
		int i;
		sz[x]=1;
		dep[x]=dep[fa[x]]+1;
		dfn[++cnt]=x;
		pos[x]=cnt;
		for(i=hed[x];i;i=net[i]){
			int y=ver[i];
			if(y==fa[x])continue;
			fa[y]=x;
			dis[y]=dis[x]+e[i];
			dfs0(y);
			sz[x]+=sz[y];
		}
	}
	void init(){
		cnt=0;
		dfs0(1);
		int i,j;
		for(i=1;i<=cnt;i++){
			st[i][0]=dep[fa[dfn[i]]];
			bst[i][0]=fa[dfn[i]];
		}
		for(j=1;j<=lg[cnt];j++){
			for(i=1;i+(1<<j)-1<=cnt;i++){
				if(st[i][j-1]<=st[i+(1<<j-1)][j-1]){
					st[i][j]=st[i][j-1];
					bst[i][j]=bst[i][j-1];
				}
				else{
					st[i][j]=st[i+(1<<j-1)][j-1];
					bst[i][j]=bst[i+(1<<j-1)][j-1];
				}
			}
		}
	}
	int lca(int x,int y){
		if(x==y)return x;
		x=pos[x];y=pos[y];
		if(x>y)swap(x,y);x++;
		int k=lg[y-x+1];
		if(st[x][k]<=st[y-(1<<k)+1][k])return bst[x][k];
		return bst[y-(1<<k)+1][k];
	}
}
using LCA::lca;
namespace LCA_Dif{
	vector<int>ins[100001];
	struct sgt1{
		int ls,rs;
		long long valmax,valdepmax;
	}tre[10000001];
	int rt[100001],num;
	void pushup(int k){
		tre[k].valdepmax=max(tre[ls(k)].valdepmax,tre[rs(k)].valdepmax);
		tre[k].valmax=max(tre[ls(k)].valmax,tre[rs(k)].valmax);
	}
	void insert(int &k,int l,int r,int x,long long v1,long long v2,bool tp){
		if(!k)k=++num,tre[k]={0,0,-inf,-inf};
		if(l==r){
			if(!tp)tre[k].valmax=tre[k].valdepmax=-inf;
			else{
				tre[k].valmax=max(tre[k].valmax,v1);
				tre[k].valdepmax=max(tre[k].valdepmax,v2);
			}
			return;
		}
		int mid=l+r>>1;
		if(x<=mid)insert(ls(k),l,mid,x,v1,v2,tp);
		else insert(rs(k),mid+1,r,x,v1,v2,tp);
		pushup(k);
	}
	int merge(int x,int y,int l,int r,long long xs){
		if(!x||!y)return x+y;
		if(l==r){
			tre[x].valmax=max(tre[x].valmax,tre[y].valmax);
			tre[x].valdepmax=max(tre[x].valdepmax,tre[y].valdepmax);
			return x;
		}
		res=max(res,tre[ls(x)].valmax+tre[rs(y)].valdepmax-xs);
		res=max(res,tre[ls(y)].valmax+tre[rs(x)].valdepmax-xs);
		int mid=l+r>>1;
		ls(x)=merge(ls(x),ls(y),l,mid,xs);
		rs(x)=merge(rs(x),rs(y),mid+1,r,xs);
		pushup(x);
		return x;
	}
	void dfs1(int x){
		int i;
		for(i=0;i<ins[x].size();i++){
			int d=ins[x][i];
			if(a[d].r==x)continue;
			insert(rt[0],1,n,a[d].r,a[d].sum-a[d].cost,a[d].sum-a[d].cost+dis[a[d].r],1);
			rt[x]=merge(rt[x],rt[0],1,n,dis[x]);rt[0]=0;
		}
		ins[x].resize(0);
		for(i=hed[x];i;i=net[i]){
			int y=ver[i];
			if(y==fa[x])continue;
			dfs1(y);
			insert(rt[y],1,n,x,0,0,0);
			rt[x]=merge(rt[x],rt[y],1,n,dis[x]);
		}
	}
	void solve(){
		int i;tre[0]={0,0,-inf,-inf};
		for(i=1;i<=num;i++)tre[i]={0,0,-inf,-inf};
		num=0;
		for(i=1;i<=n;i++)rt[i]=0;
		for(i=1;i<=m;i++){
			ins[a[i].x].push_back(i);
			ins[a[i].y].push_back(i);
		}
		dfs1(1);
	}
}
namespace LCA_Sim{
	vector<int>bl[300001],is[300001];
	vector<int>g[300001];
	int cn;
	bool cmp(int x,int y){return pos[x]<pos[y];}
	long long dist(int x,int y){
		int r=lca(x,y);
		return dis[x]+dis[y]-dis[r]*2;
	}
	struct dim{
		int zx,zy;
		long long zz;
	};
	dim cross(dim x,dim y){
		if(!x.zx||!y.zx)return {0,0,-inf};
		dim res;
		long long mx=-inf,d;
		d=dist(x.zx,y.zx);
		if(d>mx)mx=d,res={x.zx,y.zx,d};
		d=dist(x.zy,y.zx);
		if(d>mx)mx=d,res={x.zy,y.zx,d};
		d=dist(x.zx,y.zy);
		if(d>mx)mx=d,res={x.zx,y.zy,d};
		d=dist(x.zy,y.zy);
		if(d>mx)mx=d,res={x.zy,y.zy,d};
		return res;
	}
	dim operator+(dim x,dim y){
		if(!x.zx)return y;
		if(!y.zx)return x;
		dim res=x;
		if(y.zz>x.zz)res=y;
		dim tr=cross(x,y);
		if(tr.zz>res.zz)res=tr;
		return res;
	}
	int kp[1000001],ct;
	int stk[3000001],top;
	dim dfs(int x,int rt){
		int i;
		dim ans={0,0,-inf};
		for(i=0;i<g[x].size();i++){
			int y=g[x][i];
			dim tr=dfs(y,rt);
			if(x==rt)continue;
			dim md=cross(tr,ans);
			res=max(res,md.zz/2-dis[x]);
			ans=ans+tr;
		}
		g[x].resize(0);
		for(i=0;i<is[x].size();i++){
			if(x==rt)continue;
			int d=is[x][i];
			dim ts;
			if(a[d].x==x)ts={a[d].ry,a[d].ry,-inf};
			else ts={a[d].rx,a[d].rx,-inf};
			dim md=cross(ts,ans);
			res=max(res,md.zz/2-dis[x]);
			ans=ans+ts;
		}
		is[x].resize(0);
		return ans;
	}
	void calc(int x){
		if(bl[x].size()==1)bl[x].resize(0);
		if(!bl[x].size())return;
		int i,j;ct=0;
		for(i=0;i<bl[x].size();i++){
			int d=bl[x][i];
			kp[++ct]=a[d].x;
			kp[++ct]=a[d].y;
			is[a[d].x].push_back(d);
			is[a[d].y].push_back(d);
		}
		sort(kp+1,kp+ct+1);ct=unique(kp+1,kp+ct+1)-kp-1;
		sort(kp+1,kp+ct+1,cmp);
		int tt=ct;
		for(i=1;i<=tt;i++){
			int nx=(i==tt?kp[1]:kp[i+1]);
			kp[++ct]=lca(kp[i],nx);
		}
		sort(kp+1,kp+ct+1);ct=unique(kp+1,kp+ct+1)-kp-1;
		sort(kp+1,kp+ct+1,cmp);top=1;
		int rt=kp[1];stk[1]=rt;
		for(i=2;i<=ct;i++){
			int lst=stk[top],d=kp[i];
			int tl=pos[lst],tr=pos[lst]+sz[lst]-1;
			while(pos[d]<tl||pos[d]>tr){
				lst=stk[--top];
				tl=pos[lst];
				tr=pos[lst]+sz[lst]-1;
			}
			g[lst].push_back(d);
			stk[++top]=d;
		}
		bl[x].resize(0);
		dfs(rt,rt);
	}
	void solve(){
		int i;cn=n;
		for(i=1;i<=m;i++){
			int x=a[i].x,y=a[i].y;
			add(x,++cn,a[i].sum+dis[y]-2*a[i].cost);
			add(y,++cn,a[i].sum+dis[x]-2*a[i].cost);
			a[i].rx=cn-1;
			a[i].ry=cn;
			bl[a[i].r].push_back(i);
		}
		LCA::init();
		for(i=1;i<=n;i++)calc(i);
	}
}
void init(){
	int i;
	scanf("%d",&n);
	for(i=1;i<=tot/2+1;i++)hed[i]=0;
	res=-inf;tot=0;
	for(i=1;i<n;i++){
		int x,y;
		long long z;
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	LCA::init();
	scanf("%d",&m);
	for(i=1;i<=m;i++){
		int x,y;
		scanf("%d%d%lld",&x,&y,&a[i].cost);
		if(x==y){
			m--;i--;
			continue;
		}
		a[i].x=x;a[i].y=y;
		int r=lca(x,y);
		a[i].r=r;
		a[i].sum=dis[x]+dis[y]-2*dis[r];
	}
}
void solve(){
	int i;
	init();
	LCA_Dif::solve();
	LCA_Sim::solve();
	if(res<=-inf/10)printf("F\n");
	else printf("%lld\n",res);
}
int main(){
	int i,t;
	for(i=2;i<=300000;i++)lg[i]=lg[i>>1]+1;
	scanf("%d",&t);
	while(t--)solve();
}
```

---

## 作者：9AC8E2 (赞：0)

所有链对的状态只有两种.
1. ${\color{grey}{lca}}$ 不同,即性质 $S1$
2. ${\color{grey}{lca}}$ 相同,按 ${\color{grey}{lca}}$ 分别建虚树即为性质 $S2$

## S1

所有链的 ${\color{grey}{lca}}$ 不同.

![](https://cdn.luogu.com.cn/upload/image_hosting/ph3eep8t.png)

枚举$\color{red}{{\color{red}{R}}}$(两条链最下方的交点),要最大化的是 $len_1+len_2+\max\{dep_{{\color{blue}{B_1}}},dep_{{\color{blue}{B_2}}}\}-dep_{\color{red}{R}}$

设 $mx=\max\{dep_{{\color{blue}{B_1}}},dep_{{\color{blue}{B_2}}}\}$

对于每个${\color{red}{R}}$,维护
$$f({\color{red}{R}},mx)=\max_{mx=\max\{dep_{{\color{blue}{B_1}}},dep_{{\color{blue}{B_2}}}\}}\{len_1+len_2+mx\}$$
,满足 ${\color{green}{G_1}},{\color{green}{G_2}}$ 不在 ${\color{red}{R}}$ 的同一棵子树内

拿线段树合并维护这个东西

线段树上的每个节点记两个值


$$A_{s}=\max_{dep_B\in s}\{len+dep\}$$
$$B_{s}=\max_{dep_B\in s}\{len\}$$

### 如何更新答案?

$$ans\leftarrow B_{T1,[l,mid]}+A_{T2,(mid,r]}$$
这是$T2$的链较深

$$ans\leftarrow B_{T2,[l,mid]}+A_{T1,(mid,r]}$$
这是$T1$的链较深



## S2

所有链的${\color{grey}{lca}}$相同.

![盗的图](https://00ffcc.cf/images/P4775/S2.png)

$$ans=\frac{dis_{{\color{blue}{B_1}},{\color{green}{C_1}}}+dis_{{\color{blue}{B_2}},{\color{green}{C_2}}}+dis_{{\color{blue}{B_1}},{\color{blue}{B_2}}}+dis_{{\color{green}{C_1}},{\color{green}{C_2}}}}{2}-v_{\textnormal{{\color{orange}{橙}}链}}-v_{\textnormal{{\color{blue}{蓝}}链}}$$

枚举红点$\color{red}{A}$

$$ans=\frac{1}{2}\times \max\{lenth_{\textnormal{{\color{orange}{橙}}链}}+lenth_{\textnormal{{\color{blue}{蓝}}链}}+depth_{{\color{blue}{B_1}}}+depth_{{\color{blue}{B_2}}}-depth_{\color{red}{A}}\times 2+dis_{{\color{green}{C_1}},{\color{green}{C_2}}}-2\times v_{\textnormal{{\color{orange}{橙}}链}}-2\times v_{\textnormal{{\color{blue}{蓝}}链}}\}$$

对于每个绿点 ${\color{green}{C}}$,建一个新点 ${\color{green}{C}}'$,连边 ${\color{green}{C}},{\color{green}{C}}'$,边权为 $lenth+depth-2\times v$,这样 $ans=\frac{1}{2}\times \max\{dis({\color{green}{C_1}}',{\color{green}{C_2}}')-depth_{\color{red}{A}}\times 2\}$.

其中需要保证的是两个蓝点属于红点的两个不同子树.

```cpp
#include<bits/stdc++.h>
using namespace std; 
#define Ri register
template<typename T>inline T read(Ri T&t)
{Ri T f=1;Ri char ch=getchar();t=0;
while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
while(ch>='0'&&ch<='9')t=t*10+ch-'0',ch=getchar();t*=f;return t;}
template<typename T,typename...Args>
inline void read(T&t,Args&...args)
{read(t);read(args...);}
typedef long long ll;
int n,m;
template<int T>
struct ST
{
	int val[T],lg2[T];
	int st[20][T];
	inline int MIN(int x,int y){if(val[x]<val[y])return x;return y;}
	void build(int n,int * X)
	{
		lg2[1]=0;
		for(int i=2;i<=n;i++)lg2[i]=lg2[i>>1]+1;
		for(int i=1;i<=n;i++)val[i]=X[i];
		for(int i=1;i<=n;i++)st[0][i]=i;
		for(int i=1;i<=lg2[n];i++)
			for(int j=1;j+(1<<i)-1<=n;j++)
				st[i][j]=MIN(st[i-1][j],st[i-1][j+(1<<i-1)]);
	}
	int ask(int l,int {\color{red}{R}}){int len=lg2[{\color{red}{R}}-l+1];return MIN(st[len][l],st[len][{\color{red}{R}}-(1<<len)+1]);}
};
namespace T1
{
	int head[50004],ne[100005],to[100005];
	ll val[100005];
	int total=1;
	inline void add(int a,int b,ll {\color{green}{C}})
	{
		total++;
		to[total]=b;
		val[total]={\color{green}{C}};
		ne[total]=head[a];
		head[a]=total;
	}
	int deep[50004];
	ll depth[500005];
	int dfn[100005],dfn_top;
	int in[50004];
	int id[100005],id_top;
	void dfs(int now,int fa)
	{
		deep[now]=deep[fa]+1;
		id[now]=++id_top;
		dfn[++dfn_top]=now;
		in[now]=dfn_top;
		for(int i=head[now];i;i=ne[i])
			if(to[i]!=fa)
			{
				depth[to[i]]=depth[now]+val[i];
				dfs(to[i],now);
				dfn[++dfn_top]=now;
			}
	}
	int ideep[100005];
	ST<200005>st;
	void build_st()
	{
		dfn_top=id_top=0;dfs(1,0);
		for(int i=1;i<=dfn_top;i++)ideep[i]=deep[dfn[i]];
		st.build(dfn_top,ideep);
	}
	inline int {\color{grey}{lca}}(int x,int y)
	{
		x=in[x];y=in[y];if(x>y)swap(x,y);
		return dfn[st.ask(x,y)];
	}
	inline ll dis(int x,int y){return depth[x]+depth[y]-depth[{\color{grey}{lca}}(x,y)]*2;}
	void build()
	{
		for(int i=1;i<=n;i++)head[i]=0;
		total=1;
		for(int i=1,x,y;i<n;i++)	
		{
			ll z;
			read(x,y,z);
			add(x,y,z);
			add(y,x,z);
		}	
		build_st();
	}
}
vector<vector<ll> >links[50004];
namespace T2
{
	int head[500005],ne[1000005],to[1000005];
	ll val[1000005];
	ST<1000005>st;
	int total=1;
	inline void add(int a,int b,ll {\color{green}{C}})
	{
		total++;
		to[total]=b;
		val[total]={\color{green}{C}};
		ne[total]=head[a];
		head[a]=total;
	}
	inline void Add(int a,int b,ll {\color{green}{C}}){add(a,b,{\color{green}{C}});add(b,a,{\color{green}{C}});}
	int deep[500005];
	ll depth[500005];
	int dfn[1000005],dfn_top;
	int in[500005];
	int ideep[500005];
	vector<int>rev;
	vector<int>par[500005];
	pair<int,int>dia[500005];
	void dfs(int now,int fa)
	{
		deep[now]=deep[fa]+1;
		dfn[++dfn_top]=now;
		in[now]=dfn_top;
		for(int i=head[now];i;i=ne[i])
			if(to[i]!=fa)
			{
				
				depth[to[i]]=depth[now]+val[i];
				dfs(to[i],now);
				dfn[++dfn_top]=now;
			}
	}
	void build_st(int rt)
	{
		dfn_top=0;dfs(rt,0);
		for(int i=1;i<=dfn_top;i++)ideep[i]=deep[dfn[i]];
		st.build(dfn_top,ideep);
	}
	inline int {\color{grey}{lca}}(int x,int y)
	{
		x=in[x];y=in[y];if(x>y)swap(x,y);
		return dfn[st.ask(x,y)];
	}
	inline ll dis(int x,int y)
	{
		if(x==0&&y==0)return -4e18;
		if(x==0||y==0)return -2e18;
		return depth[x]+depth[y]-depth[{\color{grey}{lca}}(x,y)]*2;
	}
	ll ans=-2e18;
	void clear()
	{
		total=1;
		ans=-2e18;
		for(int i:rev)
			head[i]=0,
			par[i].clear(),
			dia[i]=make_pair(0,0),
			depth[i]=deep[i]=0;
		rev.clear();
	}
	ll dis(pair<int,int>A){return dis(A.first,A.second);}
	pair<int,int>merge(pair<int,int>A,pair<int,int>B)
	{
		ll a,b,{\color{green}{C}},d,e,f;
		ll re=max({
				a=dis(A),
				b=dis(B),
				{\color{green}{C}}=dis({A.first,B.first}),
				d=dis({A.first,B.second}),
				e=dis({A.second,B.first}),
				f=dis({A.second,B.second})});
		if(a==re)return A;
		if(b==re)return B;
		if({\color{green}{C}}==re)return {A.first,B.first};
		if(d==re)return {A.first,B.second};
		if(e==re)return {A.second,B.first};
		if(f==re)return {A.second,B.second};
	}
	pair<int,int> solve(vector<int>&pos)
	{
		if(pos.size()==0)return {0,0};
		auto re=make_pair(0,0);
		for(int i:pos)re=merge(re,make_pair(0,i));
		return re;
	}
	inline ll calc(pair<int,int>A,pair<int,int>B)
	{
		return max({
				dis(A.first,B.first),
				dis(A.first,B.second),
				dis(A.second,B.first),
				dis(A.second,B.second)});
	}
	void solve(int now,int fa)
	{
		dia[now]=solve(par[now]);
		ll depth=T1::depth[now];
		ans=max(ans,dis(dia[now])-depth*2);
		for(int i=head[now];i;i=ne[i])
			if(to[i]!=fa)
			{
				solve(to[i],now);
				ans=max(ans,calc(dia[now],dia[to[i]])-depth*2);
				dia[now]=merge(dia[now],dia[to[i]]);
			}
	}
	ll build(vector<vector<ll> >& links,int rt)
	{
		static int opt[500005];int opt_top=0;
		for(auto&i:links)
			opt[++opt_top]=i[0],
			opt[++opt_top]=i[1];
		sort(opt+1,opt+opt_top+1);
		opt_top=unique(opt+1,opt+opt_top+1)-opt-1;
		sort(opt+1,opt+opt_top+1,[&](int x,int y){return T1::id[x]<T1::id[y];});
		rev.clear();
		static int st[500005];int st_top;
		st[st_top=1]=rt;rev.push_back(rt);
		for(int i=(opt[1]==rt?2:1);i<=opt_top;i++)
		{
			int x=opt[i],y=T1::{\color{grey}{lca}}(st[st_top],x);
			while(st_top>1&&T1::id[y]<=T1::id[st[st_top-1]])
				Add(st[st_top-1],st[st_top],T1::dis(st[st_top],st[st_top-1])),
				rev.push_back(st[st_top--]);
			if(st[st_top]!=y)
				Add(st[st_top],y,T1::dis(y,st[st_top])),
				rev.push_back(st[st_top]),
				st[st_top]=y;
			st[++st_top]=x;
		}
		while(st_top>1)
			Add(st[st_top-1],st[st_top],T1::dis(st[st_top],st[st_top-1])),
			rev.push_back(st[st_top--]);
		int cnt=n;
		for(auto & i:links)
		{
			ll lenth=T1::dis(i[0],i[1]);
			Add(i[0],++cnt,lenth+T1::depth[i[1]]-i[2]*2);
			par[i[1]].push_back(cnt);rev.push_back(cnt);
			Add(i[1],++cnt,lenth+T1::depth[i[0]]-i[2]*2);
			par[i[0]].push_back(cnt);rev.push_back(cnt);
		}
		build_st(rt);
		for(int i=head[rt];i;i=ne[i])solve(to[i],rt);
		ll re=ans;clear();return re/2;
	}
}
namespace S1
{
	vector<pair<int,ll> >jav[50005];
	ll ans=-1e18;
	struct SGT
	{
		int lcs,rcs;
		ll AF,BF;
		#define mid ((l+{\color{red}{R}})>>1)
		#define lc v[p].lcs
		#define rc v[p].rcs
		#define A v[p].AF
		#define B v[p].BF
	}v[2000005];
	int tot=0;
	inline void push_up(int p)
	{
		A=B=-1e18;
		if(lc)A=max(v[lc].AF,A),B=max(v[lc].BF,B);
		if(rc)A=max(v[rc].AF,A),B=max(v[rc].BF,B);
	}
	ll Ans;
	void revise(int l,int {\color{red}{R}},int&p,ll len,ll dep,int pos)
	{
		if(p==0)p=++tot,A=B=-2e18,lc=rc=0;
		if(l=={\color{red}{R}})return A=max(A,len+dep),B=max(B,len),void();
		if(pos<=mid)
		{
			if(rc)Ans=max(Ans,len+v[rc].AF);
			revise(l,mid,lc,len,dep,pos);
		}
		if(mid+1<=pos)
		{
			if(lc)Ans=max(Ans,len+dep+v[lc].BF);
			revise(mid+1,{\color{red}{R}},rc,len,dep,pos);
		}
		push_up(p);
	}
	void merge(int l,int {\color{red}{R}},int & p,int q)
	{
		if(q==0)return;if(p==0)return p=q,void();
		if(l=={\color{red}{R}})return A=max(A,v[q].AF),B=max(B,v[q].BF),void();
		if(v[p].lcs&&v[q].rcs)Ans=max(Ans,v[v[p].lcs].BF+v[v[q].rcs].AF);
		if(v[p].rcs&&v[q].lcs)Ans=max(Ans,v[v[p].rcs].AF+v[v[q].lcs].BF);
		merge(l,mid,lc,v[q].lcs);
		merge(mid+1,{\color{red}{R}},rc,v[q].rcs);
		push_up(p);
	}
	void remove(int l,int {\color{red}{R}},int p,int pos)
	{
		if(p==0)return;
		if(l=={\color{red}{R}})return A=B=-2e18,lc=rc=0,void();
		if(pos<=mid)remove(l,mid,lc,pos);
		if(mid+1<=pos)remove(mid+1,{\color{red}{R}},rc,pos);
		push_up(p);
	}
	#undef mid
	#undef lc
	#undef rc
	#undef A
	#undef B
	int root[50005];
	void solve(int now,int fa)
	{
		Ans=-2e18;
		for(auto&i:jav[now])
			revise(1,n,root[now],i.second,T1::depth[i.first],T1::deep[i.first]);
		ll tmp=Ans;
		for(int i=T1::head[now];i;i=T1::ne[i])
			if(T1::to[i]!=fa)
			{
				solve(T1::to[i],now);
				Ans=-2e18;
				merge(1,n,root[now],root[T1::to[i]]);
				tmp=max(Ans,tmp);
			}
		ans=max(ans,tmp-T1::depth[now]);
		if(now!=1)remove(1,n,root[now],T1::deep[now]-1);
	}
	void clear()
	{
		tot=0;
		ans=-1e18;
		for(int i=1;i<=n;i++)root[i]=0;
	}
	ll solve()
	{
		clear();
		solve(1,0);
		return ans;
	}
}
void solve()
{
	read(n);
	T1::build();
	for(int i=1;i<=n;i++)links[i].clear();
	read(m);
	for(int i=1;i<=m;i++)
	{
		ll x,y,z;
		read(x,y,z);
		if(x==y)continue;
		int lc=T1::{\color{grey}{lca}}(x,y);
		links[lc].push_back({x,y,z});
		ll lenth=T1::dis(x,y);
		if(x!=lc)S1::jav[x].push_back({lc,lenth-z});
		if(y!=lc)S1::jav[y].push_back({lc,lenth-z});
	}
	ll ans=-1e18;
	ans=max(ans,S1::solve());
	for(int i=1;i<=n;i++)S1::jav[i].clear();
	fprintf(stderr,"S1::ans=%lld\n",S1::ans);
	for(int i=1;i<=n;i++)
		if(links[i].size()>1)
			ans=max(ans,T2::build(links[i],i));	
	if(ans<=-1e17)printf("F\n");
	else printf("%lld\n",ans);
}
int main()
{
	int T;read(T);
	while(T--)solve();
	return 0;
}
```

---


# [集训队互测 2015] 胡策的小树

## 题目描述

在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷。

胡策最近从一名自称是小 O 的神秘男子那里收到了一棵神奇的小树苗。

这是一棵 $n$ 个节点的有根树，节点标号为 $1, \dots, n$，其中 $1$ 号点为根。

这棵有根树上每个点都有一个权值，点 $i$ 的权值为 $a_i$。$a_1, \dots, a_n$ 构成了一个 $0\sim n-1$ 的排列，且 $a_1=0$。

胡策大爷十分喜欢猴子，他打算在这棵树上养 $n$ 只猴子。初始时，每个节点上将放着恰好一只猴子。猴子们十分好动，每过一秒，每只在 $i$ 节点的猴子会设法往 $i$ 的父亲节点上跳，有 $p(i)$ 的概率成功跳到父亲节点；否则跳跃失败，将等概率地随机落到子树 $i$ 里某个节点上（包括点 $i$）。

因为根节点没有父亲，所以 $p(1)=0$。对于 $2\leq i\leq n$，有 $p(i)=\frac{a_i}{n}$；

在第 $i$ 秒，胡策会观察并记录这 $n$ 只猴子中成功跳上父亲结点的猴子所占的比例 $g_i$。胡策认为 $g_0, \dots, g_T$ 的平均值就是这群猴子们生活的幸福指数，为保证准确，其中 $T$ 为很大很大的值，为 $(n+1)^{99999^{99999^{99999}}}$

为了让猴子们的幸福指数的期望更大，胡策又从那名自称是小 O 的神秘男子那里买来了一袋叫“金坷垃”的肥料。如果给这棵有根树掺 $x$ 克的金坷垃，那么这棵树每个点 $i$ 的权值将变化成 $(a_i+x)\bmod n$。因为胡策是土豪有钱任性，$x$ 可以取任意非负整数。

请你告诉胡策，他该掺多少克的金坷垃，才能使猴子们幸福指数的期望最大呢？

## 说明/提示

- 对于 $10\%$ 的数据：$n = 2$。
- 对于 $20\%$ 的数据：$n\leq 5$。
- 对于 $30\%$ 的数据：$n\leq 100$。
- 对于 $50\%$ 的数据：$n\leq 2000$。
- 对于 $70\%$ 的数据：$n\leq 100000$。
- 对于 $100\%$ 的数据：$2\leq n\leq 500000$。

数据保证有一定梯度。

数据都是随机生成的。即：节点 $i$ 的父亲是从 $1\sim i-1$ 中随机选取的，$a_1 \dots a_n$ 是一个 $0 \sim n-1$ 的随机排列。

## 样例 #1

### 输入

```
3
0 1 1
0 1 2```

### 输出

```
0.266666667```

# 题解

## 作者：Glacy (赞：4)

先不管 $x$ 我们来算一下答案。

设猴子在充分长时间后，随机一个时刻（显然时刻之间是等价的）点 $i$ 的概率为 $f_i$，此时期望值应为 $\sum f_ip_i$。至于初始局面不满足该分布的问题，由于题目中的操作数相对于精度过于巨大，可以忽略掉最开始这一部分局面的贡献。

如何求解 $f_i$ 是容易的。具体地，考察一次移动，显然这两次之间 $f$ 是相同的，所以可以直接写出方程（这么做的正确性并不显然，读者可自行思考此部分）：

$$
\sum_{v\in \text{subtree}(u)}f_v
=\sum_{v\in\text{subtree}(u),v\neq u} f_v+\sum_{u\in \text{subtree}(v)} f_v(1-p_v)sz_u/sz_v
$$

两边减去 $\sum_{v\in\text{subtree}(u),v\neq u}f_v$，得到：

$$
f_u=\sum_{u\in \text{subtree}(v)} f_v(1-p_v)sz_u/sz_v
$$

将右侧关于 $f_u$ 的项提出来：

$$
f_u=\frac{\sum_{u\in \text{subtree}(v),u\neq v} f_v(1-p_v)sz_u/sz_v}{p_u}
$$

因此，有：

$$
\frac{p_u}{sz_u}f_u = \sum_{u\in \text{subtree}(v),u\neq v}\frac{f_v(1-p_v)}{sz_v}=\frac{p_{fa_u}}{sz_{fa_u}}f_{fa_u}+\frac{f_{fa_u}(1-p_{fa_u})}{siz_{fa_u}}=\frac{f_{fa_u}}{sz_{fa_u}}
$$

于是可以使用树上高斯消元 $O(n)$ 计算。

现在考虑有 $x$ 的情况，枚举所有 $x$，因为题目中的式子是一个置换，所以恰好会有一个 $u$ 满足 $p_u=0$。显然只有该点的子树内 $f$ 非 $0$，所以只需要对这棵子树计算答案。总复杂度为所有子树的大小之和，由数据随机方式可知为期望 $O(n\log n)$。

---

## 作者：5k_sync_closer (赞：2)

群里都说是树上高消基础题？

设 $P(u)$ 表示 $u$ 的祖先集合，$S(u)$ 表示 $u$ 的集合，$s_u$ 表示 $u$ 的子树大小，

首先答案是所有猴子在所有时刻的成功次数除以时间除以 $n$，

而时间足够长时每只猴子是等价的，不妨假设只有一只从根节点出发的猴子，

则答案是这只猴子在所有时刻的成功次数除以时间，也就是这只猴子在所有时刻成功的比例，

考虑每个点的贡献，设 $f_u$ 表示在 $u$ 点停留的时间的比例，则答案为 $\sum f_up_u$，

考虑到 $u$ 上一步在哪，则 $f_u=\sum\limits_{v\in P(u)}f_v\dfrac{1-p_v}{s_v}+\sum\limits_{v\in S(u)}f_vp_v$，

设 $g_u=\sum\limits_{v\in P(u)}f_v\dfrac{1-p_v}{s_v}$，则 $f_u=\dfrac{s_u}{1-p_u}(g_u-g_{fa_u})$，

代入上式，则 $\dfrac{s_u}{1-p_u}(g_u-g_{fa_u})=g_u+\sum\limits_{v\in S(u)}\dfrac{s_v}{1-p_v}(g_v-g_u)p_v$，

发现这个式子里只有 $g_u,g_v,g_{fa_u}$，考虑树上高斯消元，设 $g_v=k_vg_u$，

整理得 $\left(\dfrac{s_u}{1-p_u}-1+\sum\limits_{v\in S(u)}p_v\dfrac{s_v}{1-p_v}(1-k_v)\right)g_u=\dfrac{s_u}{1-p_u}g_{fa_u}$，

也就是说 $k_u=\dfrac{\dfrac{s_u}{1-p_u}}{\left(\dfrac{s_u}{1-p_u}-1+\sum\limits_{v\in S(u)}p_v\dfrac{s_v}{1-p_v}(1-k_v)\right)}$，

但是这样根节点 $r$ 上的式子是 $0\times g_r=\dfrac{s_r}{1-p_r}\times 0$，也就是说 $k_r$ 分母为 $0$，无法算出 $g_r$，

但是还有 $\sum f_u=1$ 的条件没用，不妨设 $g_u=h_ug_r$，则 $h_u$ 就是根链 $k$ 之积，

然后 $\sum f_u=\sum\dfrac{s_u}{1-p_u}(g_u-g_{fa_u})=\sum\dfrac{s_u}{1-p_u}(h_u-h_{fa_u})g_r=1$，

然后就可以算出 $g_r$，然后就可以算出所有 $g$，然后就可以算出所有 $f$ 了。

但是最开始还需要枚举一个 $x$，可以发现 $x\ne 0$ 时一定有一个非根节点 $u$ 满足 $p_u=0$，

那么猴子跳到 $u$ 子树内后就出不去了，时间足够长时可以认为猴子只在 $u$ 子树内，

所以去掉 $u$ 子树外的点，以 $u$ 为根算答案即可，

数据随机，所以子树大小之和是 $O(n\log n)$ 的，可以通过。

---

## 作者：_lmh_ (赞：1)

参考了官方题解。下文中，令 $p_u=\frac{a_u}{n},q_u=\frac{1-p_u}{s_u}$，其中 $s_u$ 为 $u$ 所在子树大小。

先考虑 $x=0$ 的做法。

假设第 $i$ 步时处在 $u$ 节点的猴子的期望数量为 $n\cdot f_{i,u}$，那么

$$f_{i+1,u}=\sum_{v\in anc(u)}q_vf_{i,v}+\sum_{v\in son(u)}p_vf_{i,v}$$

其中 $son(u)=\{v\in [1,n]:fa_v=u\}$ 为 $u$ 的儿子组成的集合，$anc(u)=anc(fa_u)\cup \{u\}(anc(1)=\{1\})$ 为 $u$ 和 $u$ 的祖先组成的集合。$f$ 的初始值为 $f_{0,u}=\frac{1}{n}$。

发现这个转移方程会让数列 $f_{i,u}$ 趋向于一个固定的数列 $g_u$，并且 $T$ 足够大以至于我们可以只考虑数列 $g$ 对答案的贡献。

现在我们要解这一个方程：

$$g_u=\sum_{v\in anc(u)}q_vg_v+\sum_{v\in son(u)}p_vg_v$$

高斯消元可以做到 $O(n^3)$，但我们有更好的做法。令 $h_{u}=\sum_{v\in anc(u)}q_vg_v$，则 $g_u=\frac{h_u-h_{fa_u}}{q_u}$，原式等价于

$$\frac{h_u-h_{fa_u}}{q_u}=h_u+\sum_{v\in son(u)}p_v\frac{h_v-h_u}{q_v}$$

整理得

$$\frac{h_{fa_u}}{h_u}=(1-q_u(1-\sum_{v\in son(u)}\frac{p_v}{q_v}(1-\frac{h_v}{h_u})))$$

这样我们就可以求出所有的 $\frac{h_u}{h_{fa_u}}$，进而求出 $\frac{h_u}{h_1}$ 和 $\frac{g_u}{h_1}$，利用 $\sum_{u}g_u=1$ 即可解出所有的 $g_u$。

最终答案即为 $\sum_{u}p_ug_u$。

但我们还要对每个 $x$ 进行求解。

注意到对于所有的 $x$ 恰好有一个 $(a_u+x)\bmod n=0$，这样一旦落入它的子树就没法跳出来，因此我们只需要对一个子树进行求解。

树随机生成，所以所有子树大小之和是 $O(n\log n)$ 的，这样 $n$ 次树上高斯消元也可以做到 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
const ll N=500007;
ll n,a[N],fa[N],id[N],tI[N],tO[N],timer,b[N],sz[N];
vector<ll> son[N];
ld p[N],q[N],r[N],f[N],ans;
void dfs(int u){
	id[tI[u]=++timer]=u;
	for (auto v:son[u]) if (v!=fa[u]) dfs(v);
	tO[u]=timer;sz[u]=tO[u]-tI[u]+1;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>p[1];
	for (int i=2;i<=n;++i){
		cin>>fa[i];son[fa[i]].emplace_back(i);
	}
	for (int i=1;i<=n;++i){cin>>a[i];b[a[i]]=i;}
	dfs(1);
	for (int i=0;i<n;++i){
		int u=b[i];
		for (int v,i=tI[u];i<=tO[u];++i){
			v=id[i];
			int o=a[v]-a[u];
			if (o<0) o+=n;
			p[v]=(ld)o/n;
			q[v]=(1-p[v])/sz[v];
			r[v]=p[v]/q[v];
		}
		for (int v,i=tO[u];i>tI[u];--i){
			v=id[i];
			f[v]=1-q[v];
			for (auto w:son[v]) f[v]+=r[w]*q[v]*(1-f[w]);
			f[v]=1/f[v];
		}
		ld sum=0,now=0;
		f[u]=1;f[fa[u]]=0;
		for (int i=tI[u]+1;i<=tO[u];++i) f[id[i]]*=f[fa[id[i]]];
		for (int i=tO[u];i>=tI[u];--i) f[id[i]]=(f[id[i]]-f[fa[id[i]]])/q[id[i]];
		for (int i=tI[u];i<=tO[u];++i) sum+=f[id[i]];
		for (int i=tI[u];i<=tO[u];++i) now+=f[id[i]]/sum*p[id[i]];
		ans=max(ans,now);
	}
	cout<<fixed<<setprecision(10)<<ans<<endl;
	return 0;
}
```

---

## 作者：forgotmyhandle (赞：0)

[洛谷题目链接](https://www.luogu.com.cn/problem/P11736)

## 分析
考虑用完金坷垃之后，树上必然存在一个 $a_i = 0$ 的点。则所有猴子都会在有限步之内来到这个子树，然后再也出不去。由于 $T$ 可以认为是 $+\infty$，因此进入这个子树之前的事情就算忽略也不会对答案产生影响。也就是我们只需要考虑这棵子树内的情况。当所有猴子都进入这个子树之后，它们就是完全相同的了。

先把题目要求的转化一下。题目求的比例的平均值可以视为所有猴子的总成功次数比上所有猴子跳的总次数，也就是每个猴子成功跳跃的比例的平均值。由于所有猴子都是一样的，所以如果设 $P$ 为一只猴子 $T$ 次跳跃中成功跳跃的占比，则答案即为 $\frac{nP}{n}$，也就是 $P$。

考虑二分答案，则变成跳成功一次获得 $1 - mid$ 的收益，否则获得 $-mid$ 的收益，问最后收益是否非负。设 $f_i$ 表示从 $i$ 开始，第一次跳出 $i$ 子树时期望获得了多少收益。转移方程 $f_i = p_i(1 - mid) + \frac{1 - p_i}{size_i}\sum\limits_{u \in subtree(i)}(-mid + \sum\limits_{v \in path(u, i)} f_v)$。其中 $subtree(x)$ 是 $x$ 的子树集合，包含自己。$path(u, v)$ 是路径上点的集合，包含端点。

转移方程容易化简，化简结果只和子树有关，可以从下往上递推。因此对一个给定的根 $x$ 做一次的复杂度关于 $size_x$ 线性。由于数据随机，每个点的 $size$ 之和是 $\mathcal{O}(n \log n)$ 级别。因此枚举 $x$ 后二分直接做即可做到双 $\log$。然后会发现二分时的 $check(rt, mid)$ 能够在 $\mathcal{O}(size_{rt})$ 的时间内检查 $mid$ 是否合法，因此可以以随机顺序枚举 $x$，先 $check$ 对应的 $rt$ 能否达到当前最优答案 $ans$，若能再进去二分。由于随机数列的前缀最大值个数是期望 $\log$，这样做的复杂度就变成 $\mathcal{O}(n\log n + \log^2n\log V)$，可以通过。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <random>
using namespace std;
const double eps = 1e-10;
random_device rd;
mt19937 mtrand(rd());
int n;
int head[500005], nxt[1000005], to[1000005], ecnt;
void add(int u, int v) { to[++ecnt] = v, nxt[ecnt] = head[u], head[u] = ecnt; }
int o[500005], _a[500005], a[500005];
int sz[500005], fa[500005];
void dfs(int x) {
    sz[x] = 1;
    for (int i = head[x]; i; i = nxt[i]) dfs(to[i]), sz[x] += sz[to[i]];
}
int X, rt;
double s[500005], f[500005], e;
void dfs1(int x) {
    double p = ((a[x] + X) % n) / (n * 1.0);
    s[x] = 0;
    for (int i = head[x]; i; i = nxt[i]) {
        int v = to[i];
        dfs1(v);
        s[x] += s[v];
    }
    if (x != rt) {
        f[x] = 1 - e + (1 - p) / p * (-e + s[x] / sz[x]);
        s[x] += f[x] * sz[x];
    }
}
bool chk(int x, double mid) {
    rt = x, e = mid;
    dfs1(x);
    return s[rt] / sz[x] - e > 0;
}
int main() {
    freopen("tree.in", "r", stdin);
    freopen("tree.out", "w", stdout);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> fa[i], add(fa[i], i);
    for (int i = 1; i <= n; i++) cin >> a[i], _a[a[i]] = i, o[i] = i - 1;
    dfs(1);
    shuffle(o + 1, o + n + 1, mtrand);
    double ans = 0;
    for (int i = 1; i <= n; i++) {
        X = o[i];
        int x = _a[(n - X) % n];
        if (chk(x, ans)) {
            double l = ans, r = 1, mid;
            while (r - l > eps) {
                mid = (l + r) / 2;
                if (chk(x, mid)) 
                    ans = mid, l = mid;
                else 
                    r = mid;
            }
        }
    }
    cout << fixed << setprecision(10) << ans << "\n";
    return 0;
}
```

---


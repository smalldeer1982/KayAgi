# 随机数生成器

## 题目描述

sol 研发了一个神奇的随机数系统，可以自动按照环境噪音生成真·随机数。

现在 sol 打算生成 $n$ 个 $[1,x]$ 的整数 $a_1, ..., a_n$，然后进行一些询问。

$q$ 次询问，每次询问 $i$ 有两个参数 $l_i$ 和 $r_i$，sol 会计算 $\min_{l_i \leq j \leq r_i} a_j$（$a$ 数组中下标在 $l_i, r_i$ 之间的数的最小值）。

最后测试结果会是这些询问得到的结果的最大值。

sol 进行了很多次实验，现在他想问问你测试结果的期望大小是多少，对 $666623333$ 取模。


## 说明/提示

提示：一个分数 $\frac{a}{b}$ 对 $666623333$ 取模的结果为 $a\times b^{666623331}~\mod~666623333$。

对于 $10\%$ 的数据，$n,x,q \leq 6$。

对于另外 $20\%$ 的数据，$q=1$。

对于 $50\%$ 的数据，$n,x,q \leq 300$。

对于 $70\%$ 的数据，$n,x,q \leq 800$。

对于 $100\%$ 的数据，$1 \leq n,x,q \leq 2000$，对于每个 $i$，$1 \leq l_i \leq r_i \leq n$。


## 样例 #1

### 输入

```
2 2 1
1 2```

### 输出

```
499967501```

## 样例 #2

### 输入

```
6 6 6
1 3
2 4
3 5
4 6
5 6
3 4```

### 输出

```
88571635```

# 题解

## 作者：xyz32768 (赞：53)

讲一种不用期望 DP 的做法。

可以考虑对于每个 $i$ ，求出最后的最大值为 $i$ 的概率 $p_i$ ，然后答案就是：

$$\sum_{i=1}^x i\times p_i$$

众所周知，「最大值恰好为 $i$ 」往往是不好处理的。

所以考虑差分：设 $P_i$ 表示最后的最大值 $\le i$ 的概率，这样答案就是：

$$\sum_{i=1}^xi\times(P_i-P_{i-1})$$

现在的问题就是如何求 $P_i$ 。

首先我们知道，如果一个区间包含了其他的区间，那么这个区间对最后的最大值是没有影响的。可以删掉。

这样如果把所有的区间按照左端点排序，那么右端点是严格单调递增的。

发现这个 $P_i$ 其实是一个计数问题（因为方案数除以 $x^n$ 就是概率），设 $h[i]$ 表示最后的最大值 $\le i$ 的**方案数**。

这等价于每个区间的最小值都 $\le i$ ，也就相当于每个区间内都存在一个 $\le i$ 的数。

我们不妨枚举 $j$ 表示有多少个数 $\le i$ ，那么 $h[i]$ 就等于：

$$g[j]\times i^j\times (x-i)^{n-j}$$

其中 $g[j]$ 表示在 $[1,n]$ 内选出 $j$ 个点，使得每个区间至少包含一个点的方案数。

现在可以开始 DP 辣！

定义状态： $f[i][j]$ 表示前 $i$ 个位置放了 $j$ 个点且第 $i$ 个位置必须放点，覆盖所有左端点 $\le i$ 的区间的方案数。

预处理 $fl[i]$ 和 $fr[i]$ 表示覆盖位置 $i$ 的最左区间编号和最右区间编号。特殊地，如果 $i$ 不被任何区间包含，则 $fr[i]$ 为右端点严格小于 $i$ 的最后一个区间， $fl[i]=fr[i]+1$ 。

转移：

$$f[i][j]=\sum_{fr[k]+1\ge fl[i]}f[k][j-1]$$

发现可以参与转移的 $k$ 是一个区间。前缀和优化， $O(n^2)$ 。

$g[j]$ 就很容易算出：

$$g[j]=\sum_{fr[i]=q}f[i][j]$$

复杂度 $O(n^2)$ 。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
#define Rof(i, a, b) for (i = a; i >= b; i--)
using namespace std;

inline int read()
{
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}

template <class T>
T Min(T a, T b) {return a < b ? a : b;}

template <class T>
T Max(T a, T b) {return a > b ? a : b;}

const int N = 2005, ZZQ = 666623333, INF = 0x3f3f3f3f;
int n, m, X, q, fl[N], fr[N], f[N][N], sum[N][N], g[N], h[N], divis, ans;

struct node
{
	int l, r;
} a[N], b[N];

bool comp(node a, node b)
{
	return a.l < b.l || (a.l == b.l && a.r < b.r);
}

int qpow(int a, int b)
{
	int res = 1;
	while (b)
	{
		if (b & 1) res = 1ll * res * a % ZZQ;
		a = 1ll * a * a % ZZQ;
		b >>= 1;
	}
	return res;
}

int main()
{
	int i, j, top = 0;
	n = read(); X = read(); q = read();
	For (i, 1, n) fl[i] = INF, fr[i] = -INF;
	For (i, 1, q) b[i].l = read(), b[i].r = read();
	sort(b + 1, b + q + 1, comp);
	For (i, 1, q)
	{
		if (i > 1 && b[i].l == b[i - 1].l) continue;
		while (top && a[top].r >= b[i].r) top--;
		a[++top] = b[i];
	}
	q = top;
	For (i, 1, q) For (j, a[i].l, a[i].r)
		fl[j] = Min(fl[j], i), fr[j] = Max(fr[j], i);
	top = 0;
	For (i, 1, n)
		if (fl[i] == INF) fl[i] = top + 1, fr[i] = top;
		else top = Max(top, fr[i]);
	f[0][0] = sum[0][0] = 1;
	top = 0;
	For (i, 1, n)
	{
		while (top < i - 1 && fr[top] + 1 < fl[i]) top++;
		For (j, 1, i) f[i][j] = (sum[i - 1][j - 1] - (top ?
			sum[top - 1][j - 1] : 0) + ZZQ) % ZZQ;
		For (j, 0, i) sum[i][j] = (sum[i - 1][j] + f[i][j]) % ZZQ;
	}
	For (i, 1, n) if (fr[i] == q) For (j, 1, n)
		g[j] = (g[j] + f[i][j]) % ZZQ;
	For (i, 1, X) For (j, 1, n)
		h[i] = (h[i] + 1ll * qpow(i, j) * qpow(X - i, n - j) % ZZQ
			* g[j] % ZZQ) % ZZQ;
	Rof (i, X, 1) h[i] = (h[i] - h[i - 1] + ZZQ) % ZZQ;
	divis = qpow(qpow(X, n), ZZQ - 2);
	For (i, 1, X) ans = (ans + 1ll * i * h[i] % ZZQ * divis % ZZQ) % ZZQ;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：bztMinamoto (赞：26)

[传送门](https://www.luogu.org/problemnew/show/P3600)

全世界的题解都看不懂.jpg

题解写到一半莫名刷新结果全都白写了.jpg

首先要知道全概率公式$E(x)=\sum_{i=0}^\infty P(x\geq i)$，证明如下
![](https://i.loli.net/2018/11/15/5bed623410b71.png)
于是对于每一个$i$，我们只要计算出$P(ans\geq i)$即可

然而因为这里要计算的是最小值，如果是大于等于很不方便，于是我们考虑转化为$P(ans\geq i)=1-P(ans<i)$，也就是意味着每一个区间中都至少有一个数小于等于$i-1$

有一个性质，如果区间$a=[l1,r1]$完全包含了区间$b=[l2,r2]$，那么$a$是没有用的，因为$a$的最小值肯定小于等于$b$的最小值，对答案不可能有贡献。于是我们可以先把所有包含了其它区间的区间先去掉，再按左端点排一个序，那么右端点肯定也是递增的

考虑一个数，如果它小于等于$i-1$那么它会对一些区间产生贡献，且这些区间的编号肯定是连续的。我们把点和区间翻转，考虑用点去覆盖区间，那么现在的问题就变成了每个点能覆盖一些区间，且覆盖的概率为$p=\frac{i-1}{x}$，问所有区间都被覆盖的概率

设$l[i]$为$i$能覆盖到的最左边的区间，$r[i]$为最右边的区间，$f[i]$为必选第$i$个点，且$r[i]$及其之前的区间都被覆盖的概率，那么有$$f[i]=p*(\sum_{r[j]\geq l[i]-1} f[j]*(1-p)^{i-j-1}+[l[i]=1]*(1-p)^{i-1})$$

就是说我们枚举上一个选的点$j$，那么必须有$r[j]\geq l[i]-1$才能保证$r[i]$及其之前的区间都被覆盖，又因为$j$是上一个被选的，所以$[j+1,i-1]$都没有被覆盖。

那么最后的答案就是$\sum_{r[i]=m} f[i]*(1-p)^{n-i}$，就是枚举最后一个被选的点，然后因为它是最后一个，所以$[i+1,n]$都没被覆盖

这个东西用双指针的话，可以优化到$O(n)$
```
//minamoto
#include<bits/stdc++.h>
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
int read(){
    int res,f=1;char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
const int N=2005,mod=666623333;
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
int ksm(int a,int b){
    int res=1;
    for(;b;b>>=1,a=mul(a,a))if(b&1)res=mul(res,a);
    return res;
}
struct node{
    int l,r;
    inline bool operator <(const node &b)const
    {return l==b.l?r>b.r:l<b.l;}
}a[N];
int n,k,m,st[N],top,L[N],R[N],f[N],ans,invp[N];
int main(){
//	freopen("testdata.in","r",stdin);
    n=read(),k=read(),m=read();for(int i=1;i<=m;++i)a[i].l=read(),a[i].r=read();
    sort(a+1,a+1+m);
    for(int i=1;i<=m;++i){
        while(top&&a[i].r<=a[st[top]].r)--top;
        st[++top]=i;
    }
    m=top;for(int i=1;i<=m;++i)a[i]=a[st[i]];
    int h=1,t=0;
    for(int i=1;i<=n;++i){
        while(t<m&&a[t+1].l<=i)++t;
        while(h<=t&&a[h].r<i)++h;
        L[i]=h,R[i]=t;
    }
    for(int x=1;x<=k;++x){
        int sum,p,np,fp,leip,tot;
        sum=1,p=mul(dec(x,1),ksm(k,mod-2));
        np=dec(1,p),fp=ksm(np,mod-2);
        invp[0]=1,f[0]=1,leip=1;
        for(int i=1;i<=n;++i)invp[i]=mul(invp[i-1],fp);
        for(int i=1,j=0;i<=n;++i){
            while(j<i&&R[j]<L[i]-1)sum=dec(sum,mul(f[j],invp[j])),++j;
            f[i]=mul(sum,mul(leip,p)),leip=mul(leip,np);
            sum=add(sum,mul(f[i],invp[i]));
        }
        tot=0,leip=1;
        for(int i=n;i&&R[i]==m;--i,leip=mul(leip,np))tot=add(tot,mul(f[i],leip));
        ans=add(ans,dec(1,tot));
    }
    printf("%d\n",ans);return 0;
}
```

---

## 作者：command_block (赞：22)

~~蒟蒻又来肝期望题啦。~~

注意到这题$n,x$(由于本人习惯,下文均改为c)$,q$**同阶**。

非常罕见,一道期望题值域居然只有2000?

我们考虑**在值域上做手脚**。

```cpp
不确定的东西越多,题目就越复杂。
复杂的数学题可以利用枚举降低思考复杂度。
——某数学dalao

离散统计数学三兄弟:方案数,概率,期望
——本蒟蒻
```

喜闻乐见得,这道题有膜,所以不用单行掉精度,方案数,概率,期望可以随意转化。

这道题求的是一番操作后,答案的期望,很明显,答案一定是$[1,c]$内的一个整数(也就是只有c种可能),所以答案是离散期望变量。

离散变量期望公式:$E(x)=\sum{P(?)*W(?)}$,其中$P$是概率,$W$是权值

或者你可以看看[某度百科](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/5362790?fr=aladdin)

比如说如果你抛瓶盖,瓶盖正面朝上的概率0.4,反面0.6;抛到正面得2分,反面得1分。

那么抛一次,得分期望为 $0.4*2+0.6*1=1.4$。

总的来说,概率乘权值(分数)的和就得到期望 。 

- **设**答案有$p[x]$的概率等于$x$ 。

那么答案的期望$\large{E(ans)=\sum\limits_{1<=i<=x}{i*p[i]}}$ 

上面的的式子只有$p[]$是未知的,于是乎,我们**把期望问题转化为了概率问题**。 

我们分别求出$p[1...c]$,再按照上面的式子算就可以了。 

难点在$p$数组的求解上。

-------

这道题有一系列$min/max$操作,都是**基于不等式**的,我们设的状态很乏力(**等于**$x$),考虑转化一下。

概率是可以容斥的(废话),比如这道题里,我们就可以定义一个基于不等式的状态$g[x]$。

- 设$g[x]$表示答案有$g[x]$的概率小于等于x。

这样的话,$\large{p[x]=g[x]-g[x-1]}$。

$g[x]$相对好求一些(~~真香~~)。

我们把数列**大于$x$的数都转化为1,小于等于$x$的都转化为0**,很明显,每个位置有$(c-x)/c$的可能为$1,x/c$的可能为$0$。

由于取$min$操作,每个区间会得到一个0或者1,如果一个区间内有0则必然得到0,**如果这个区间全是1,则得到1**。

后面再对所有的区间取$max$,**如果区间答案有任意一个1,则$ans>x$**(~~坏了一锅粥?~~)。 

所以$ans<=x$的概率等于有**没有一个区间内全是1**的概率。

好像这个概率也不好求,**转化成方案数**吧(zz气息)。

众所周知:事件的概率=**事件发生方案数/总方案数**(这要建立在所有情况概率(权重)相等的情况下)。

-------

- **设**$r[x]$表示答案有$r[x]$种方案小于等于$x$。 

我们把数列大于$x$的数都转化为1,小于等于$x$的都转化为0,很明显,每个位置有$(c-x)$种方案为1,$x$种方案为0。

明显看到,总方案数为$c^n$(每个数字都有c种取值,共n个)

所以$\large{g[x]=r[x]/(c^n)}$。

所以$ans<=x$的方案数等于没有一个区间内全是1的方案数。

我们要保证没有一个区间内全是1,即每个区间内至少有1个0。

现在问题来了:我们有几种方法填写01串,使得每个区间内至少有1个0?

```cpp
不会就多设几个数。
——数学老师 forest·true·stop
```

- **设**$s[i]$为填了$i$个0,$(n-i)$个1,使得每个区间内至少有1个0的方案数。

一个1可以对应原值域中的$(c-x)$个数,一个0可以对应$x$个数。

则$\large{r[x]=\sum\limits_{0<=i<=n}{s[i]*(x^i*(c-i)^{(n-i)})}}$

~~对于$s$,上$O(2^n)$枚举01串求。~~(应该有这个部分分才对)

对于$s$,不就是个填写01串的方案数问题吗?终于可以**dp求解了**!



------

- 设$f[i][j]$为在前i位置内填了j个0(必填第i位),且已经覆盖了左端点小于等于i的所有区间的方案数。

转移:很明显$f[i][j]$要从$f[?][j-1]$转移过来。

具体是那些"?"呢?

如果第i位一个0可以把左端点$posl$满足$?<pos<=i$的所有区间都干掉,这个?就是满足条件的。

把?从$i-1$(两个0不能放在一起)向前枚举就可以了。

判断不合法:

如果有左端点posl满足$?<pos<=i$的区间,右端点端点$posr<i$,则?不在这个区间内,不合法。

因为上一个0没有干掉这个区间,这个0也没有,所以这个区间可以~~苟且偷生~~,所以布星。

那么,求出来?之后 ,得到$\large{f[i][j]=\sum\limits_{?<=j<i}f[j][j-1]}$

正确性满足了,接下来**上优化**。

-------

我们来捋一捋程序过程与复杂度($n,c,q$同阶)。

先$dp$出$f$数组,一共状态$O(n^2)$,乘上转移$O(n)$。 O(n^3)

$s[k]=\sum\limits_{1<=i<=n}{f[i][k]}\text{(i需要满足条件哦)}$ O(n^2)

$r[x]=\sum\limits_{0<=i<=n}{s[i]*(i^k*(x-i)^{(n-k)})}$ O(n^2*logn)(快速幂)

$g[x]=r[x]/(c^n)$ O(n)

$p[x]=g[x]-g[x-1]$ O(n)

$E(ans)=\sum\limits_{1<=i<=x}{i*p[i]}$ O(n)

空间无疑$O(n^2)$时间复杂度$O(n^3)$

**瓶颈在dp**,想办法加速转移。 

回顾:如果有左端点posl满足$?<pos<=i$的区间,右端点端点$posr<i$,则?不在这个区间内,不合法。

很明显具有单调性嘛。

右端点做一个ST表,查处最小值,如果最小值$<i$,则$?$不合法(时间复杂度$O(1)$)。

二分+ST表就可以解决。

$?$的求解降到$O(logn)$剩下的加上前缀和就可以啦。

复杂度优化为$O(n^2logn)$,解决本题。

~~代码有点恶心人~~

------------


其实不用二分优化,大力枚举r就可以了。

由于数据随机,r期望只用枚举$log(n)$次

上暴力版的代码吧,反正也AC了。

~~正常版的太丑,不放了。~~

**Code: **

```cpp
#include<algorithm>
#include<cstdio>
#define mod 666623333
using namespace std;
int n,c,q,h[2050];
long long f[2050][2050]
          ,s[2050],r[2050],g[2050],p[2050],ans;
struct Line
{int l,r;}
b[2050];
long long pow(long long a,long long t)
{
  long long ans=1,buff=a;
  while(t){
    if (t&1) ans=(ans*buff)%mod;
    buff=(buff*buff)%mod;
    t>>=1;
  }return ans;
} 
long long inv(long long num)
{return pow(num,mod-2);}
int main()
{
  scanf("%d%d%d",&n,&c,&q);
  for (int i=1;i<=n;i++)h[i]=1<<30;
  for (int i=1;i<=q;i++){
    scanf("%d%d",&b[i].l,&b[i].r);
    h[b[i].l]=min(h[b[i].l],b[i].r);//这句话是关键 
  }f[0][0]=1;
  for (int j=1;j<=n;j++){
    for (int i=j;i<=n;i++){
   	  int r=i-1;
      while(h[r]>=i&&r){
      	f[i][j]=(f[i][j]+f[r][j-1])%mod;
	    r--;//一开始没有膜还得了80
	  }f[i][j]=(f[i][j]+f[r][j-1])%mod;
	  //追求理论复杂度的话,可以把转移改成ST表+二分+前缀和优化(汗) 
    }
  }for (int k=0;k<=n;k++)
    for (int i=n;i>-1;i--){
      s[k]=(s[k]+f[i][k])%mod;
      if (h[i]<(1<<25))break;
      //如果这里放最后一个0满足不了最后一个区间,在前面放0都不合法。 
    }
  for (int x=1;x<=c;x++)
   for (int i=1;i<=n;i++)
     r[x]=(r[x]+s[i]*pow(x,i)%mod*pow(c-x,n-i))%mod;
  for (int x=1;x<=c;x++)g[x]=r[x]*inv(pow(c,n))%mod;
  for (int x=1;x<=c;x++)p[x]=(g[x]-g[x-1]+mod)%mod;
  for (int x=1;x<=c;x++)ans=(ans+x*p[x])%mod;
  //跟上面的式子一样的。 
  printf("%lld",ans);
  return 0;
}
```


[$AC$记录](https://www.luogu.org/recordnew/show/15145944)










---

## 作者：Yukikaze_ (赞：13)

看到没有 Min-Max 容斥的题解，所以来交一发（

首先列出题目要求的东西：
$$
ans=\max\{\min \{a_{l_i},a_{l_i+1}\dots a_{r_i}\}\}~(i\in[1,n])
$$

对这个式子做 Min-Max 容斥：
$$
ans=\sum_{S}(-1)^{|S|-1}\min_{i\in S}\{\min \{a_{l_i},a_{l_i+1}\dots a_{r_i}\}\}
$$

考虑这个式子的意义：对于每一个询问的子集 $S$ ，它对答案的贡献是 $(-1)^{|S|-1}$ 乘子集中的所有询问的区间的并的期望最小值。

对于 $len$ 个数的期望最小值 $f_{len}$，直接 $dp$ 预处理，复杂度 $O(n^2)$ 。

然后设 $g_{i,0/1,k}$ 表示选到第 $i$ 个询问区间（必须选第 $i$ 个），选了奇数/偶数个区间，区间并长度为 $k$ 的方案数，则答案为 $\sum_{i,j,k}(-1)^{j+1}g_{i,j,k}f_k$ 。

去除所有包含了某个区间的区间并按右端点排序后（显然这种区间对答案没有贡献），直接 $dp$ $g$ 数组复杂度是 $n^3$ 的。

设第 $i$ 个询问的左右端点分别为 $l_i,r_i$ ，列出 $g$ 的转移式：
$$
g_{i,j,k}=\sum_{r_p\ge l_i} g_{p,j\oplus 1,k-r_i+r_p}+\sum_{r_p<l_i}
g_{p,j\oplus 1,k-r_i+l_i}
$$

为了快速处理这两种转移，我们建立两个辅助数组 $h_{i,j}$ 和 $t_{i,j}$

由于 $l_i$ 单调递增，所以我们维护一个单调指针，在求出每一个 $g_{i,j,k}$ 后，先把它加入 $h_{j,r_i-k}$ 中，在被单调指针扫过（即从第一种转移变成第二种转移）后，将它从 $h_{j,r_i-k}$ 中删去，并加入到 $t_{j,k}$ 中，则 $g$ 的转移可以写成：
$$
g_{i,j,k}=h_{j\oplus 1,r_i-k}+t_{j\oplus1,k-r_i+l_i}
$$

复杂度 $O(n^2)$ ，跑的飞快（

代码：
```cpp
#include<bits/stdc++.h>
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)? EOF:*p1++)
#define P pair<ll,ll>
#define A first
#define B second
using namespace std;
typedef long long ll;
const int N=2005,mod=666623333;
char buf[1<<23],*p1=buf,*p2=buf;
ll n,x,q,f[N][N],F[N],jc[N],jv[N],inv[N];
ll g[2][N][N],h[2][N],H[2][N],ans,now;
P sq[N];
int read()
{
	int res=0,fl=0; char a=getchar();
	while(a<'0'||a>'9') fl|=a=='-',a=getchar();
	while(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();
	return fl? -res:res;
}
ll ksm(ll di,ll mi) {ll res=1; for(;mi;mi>>=1,di=di*di%mod) if(mi&1) res=res*di%mod; return res;}
int main()
{
	ll i,j,li,lj,ps;
	n=read(),x=read(),q=read();
	for(jc[0]=i=1;i<N;i++) jc[i]=jc[i-1]*i%mod;
	for(jv[N-1]=ksm(jc[N-1],mod-2),i=N-2;~i;i--) jv[i]=jv[i+1]*(i+1)%mod,i&&(inv[i]=jv[i]*jc[i-1]%mod);
	f[0][x]=1;
	for(i=0;i<n;i++)
		for(j=x,li=f[i][j];j;j--,li=(li+f[i][j])%mod)
			f[i+1][j]=(f[i+1][j]+f[i][j]*(x-j+1)%mod*inv[x])%mod,j>1&&(f[i+1][j-1]=(f[i+1][j-1]+li*inv[x])%mod);
	for(i=1;i<=n;i++)
		for(j=1;j<=x;j++) F[i]=(F[i]+f[i][j]*j)%mod;
	for(i=1;i<=q;i++) sq[i].A=read(),sq[i].B=read();
	for(i=1;i<=q;i++)
	{
		int fl=0;
		for(j=1;j<i;j++) if(sq[i].A<=sq[j].A&&sq[i].B>=sq[j].B) fl=1;
		for(j=i+1;j<=q;j++) if(!(sq[i].A==sq[j].A&&sq[i].B==sq[j].B)&&sq[i].A<=sq[j].A&&sq[i].B>=sq[j].B) fl=1;
		if(fl) for(j=i,q--,i--;j<=q;j++) sq[j]=sq[j+1];
	}
	sort(sq+1,sq+q+1);
	g[0][0][0]=1,h[0][0]=1;
	for(i=1,ps=1;i<=q;i++)
	{
		while(ps<i&&sq[ps].B<sq[i].A)
		{
			for(j=0;j<2;j++)
				for(li=sq[ps].B-sq[ps].A+1;li<=sq[ps].B;li++)
					(h[j][li]+=g[j][ps][li])%=mod,(H[j][sq[ps].B-li]+=mod-g[j][ps][li])%=mod;
			ps++;
		}
		for(j=0;j<2;j++)
			for(li=sq[i].B-sq[i].A+1;li<=sq[i].B;li++)
				g[j][i][li]=(H[j^1][sq[i].B-li]+h[j^1][li-sq[i].B+sq[i].A-1])%mod;
		for(j=1;j<=sq[i].B;j++) ans=(ans+(g[1][i][j]-g[0][i][j]+mod)*F[j])%mod;
		for(j=0;j<2;j++)
			for(li=sq[i].B-sq[i].A+1;li<=sq[i].B;li++) (H[j][sq[i].B-li]+=g[j][i][li])%=mod;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Captain_Paul (赞：12)

题意：随机生成一个长度为$n$，值域为$[1,x]$的数列，每次询问一个区间$[l,r]$的最小值，最终答案为所有询问的最大值，求答案的期望



------------

可以发现包含其他区间的区间对答案是没有影响的，首先把它们去掉

考虑枚举最大值$k$

设所有区间都满足$min_{l,r}<=k$的概率为$P(k)$

那么$k$对答案的贡献就是$k*[P(k)-P(k-1)]$

设$f[i]$表示右端点$<=i$的区间都满足$min_{l,r}<=k$的概率

对于每一个$k$计算，$f[n]$即为$P(k)$

有转移方程：$f[i]=\sum_{p=j}^if[p-1]*(k/x)*(1-k/x)^{i-p}$

直接做是$n^3$的

发现可以拆项，计算$f[p-1]*(1-k/x)^{-p}$的前缀和即可

总复杂度$O(xn^2logn)$

```
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define reg register
using namespace std;
typedef long long ll;
const int N=2005,mod=666623333;
struct node
{
	int l,r;
	inline friend bool operator < (node a,node b)
	{
		return a.l==b.l?a.r<b.r:a.l<b.l;
	}
}q[N],t[N];
int n,T,x,m,fi[N],nxt[N];
ll ans,invx,f[N],sum[N];
inline int read()
{
	int x=0,w=1;
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=-1;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*w;
}
ll quickpow(ll n,ll k)
{
	ll s=1;
	while (k)
	{
		if (k&1) s=s*n%mod;
		n=n*n%mod; k>>=1;
	}
	return s;
}
inline ll Sum(int l,int r){return (sum[r]-(l<1?0:sum[l-1])+mod)%mod;}
inline ll calc(int k)
{
	ll p1=1ll*k*invx%mod,p2=(1-p1+mod)%mod,p3=quickpow(p2,mod-2);
	memset(f,0,sizeof(f)); f[0]=1;
	memset(sum,0,sizeof(sum)); sum[0]=p3;
	for (reg int i=1;i<=n;i++)
	{
		for (reg int j=fi[i];j;j=nxt[j])
		{
			if (i>q[j].l) f[i]=(f[i]+Sum(q[j].l-1,i-2)*p1%mod*quickpow(p2,i)%mod)%mod;
			f[i]=(f[i]+f[i-1]*p1%mod)%mod;
		}
		if (!fi[i]) f[i]=f[i-1];
		sum[i]=(sum[i-1]+f[i]*quickpow(p3,i+1)%mod)%mod;
	}
	return f[n];
}
int main()
{
	n=read(),x=read(),T=read();
	for (reg int i=1;i<=T;i++) t[i].l=read(),t[i].r=read();
	sort(t+1,t+T+1);
	for (reg int i=1;i<=T;i++)
	{
		while (q[m].r>=t[i].r) --m;
		if (q[m].l<t[i].l) q[++m]=t[i];
	}
	invx=quickpow(x,mod-2); ll pre=0;
	for (reg int i=1;i<=m;i++) nxt[i]=fi[q[i].r],fi[q[i].r]=i;
	for (reg int i=1;i<=x;i++)
	{
		ll now=calc(i);
		ans=(ans+1ll*i*((now-pre+mod)%mod)%mod)%mod;
		pre=now;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：joe19025 (赞：5)

## Solution

### 区间排序

将所有序列按照左端点排序。

### 转化

这道题要我们求一个最大值的期望，我们认识的期望是这么算的：

$E(x)=\sum_{i=0} i\times P(i)$

但我们可以转化一下这个式子，变成下面这样：

$\because P(x)=P(i<=x)-P(i<=x-1)$

$E(x)=\sum_{i=0}^\infin i\times [P(i<=x)-P(i<=x-1)]$

所以我们只需要求出$P(i<=x)$的值即可。

### 计算

定义$f[i]  $为前i位满足所有的区间的min值都小于k的概率，所以答案就是$f[n]$。

我们按顺序对于每一个区间进行计算：

$f[r]=\sum_{i=l}^r f[i-1]\times (\frac{k}{n})\times(1-\frac{k}{n})^{r-i}$

因为区间是按照左端点排序的，所以我们可以枚举最后一次出现小于等于k的数的位置，这样是不会有重复计算的，同时还需要保证前面能满足条件，也就是$f[i-1]$。

### 优化

再观察上式，我们可以发现：

$f[r]=(1-\frac{k}{n})\times  \sum_{i=l}^r f[i-1]\times (\frac{k}{n})\times(1-\frac{k}{n})^{-i}$

所以我们可以定义前缀和：

$sum[i]=\sum_{i=1}^i f[i]\times (1-\frac{k}{n})^{-i-1}$

$f[r]=(1-\frac{k}{n})\times \frac{k}{n} \times (sum[r-1]-sum[l-1])$

## Code

```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#define int long long 
#define MAXN 2005 
#define MOD 666623333
using namespace std;

struct line{
    int l,r;
    bool operator<(const line a)const
    {
        if(l==a.l)return r<a.r;
        return l<a.l;
    }
}p[MAXN],b[MAXN];

int qpow(int x,int k)
{
    int res=1;
    while(k>0)
    {
        if(k&1)
            res=res*x%MOD;
        x=x*x%MOD;
        k>>=1;
    }
    return res;
}

int n,x,q;
int sum[MAXN];
int head[MAXN],nxt[MAXN];

int getsum(int l,int r){
    return (sum[r]-(l<1?0:sum[l-1])+MOD)%MOD;
}

int inv(int x)
{
    return qpow(x,MOD-2);
}

int calc(int k)
{
    int f[MAXN],p1=k*inv(x)%MOD,p2=(1-p1+MOD)%MOD,p3=inv(p2);
    memset(f,0,sizeof(f));
    memset(sum,0,sizeof(sum));
    f[0]=1,sum[0]=p3;
    for(int i=1;i<=n;i++)
    {
        for(int j=head[i];j;j=nxt[j])
        {
            if(i>p[j].l)f[i]=(f[i]+getsum(p[j].l-1,i-2)*p1%MOD*qpow(p2,i)%MOD)%MOD;
            f[i]=(f[i]+f[i-1]*p1%MOD)%MOD;
        }
        if(!head[i])f[i]=f[i-1];
        sum[i]=(sum[i-1]+f[i]*qpow(p3,i+1)%MOD)%MOD;
    }
    return f[n];
}

signed main()
{
    scanf("%lld%lld%lld",&n,&x,&q);
    for(int i=1;i<=q;i++)
    {
        scanf("%lld%lld",&b[i].l,&b[i].r);

    }
    sort(b+1,b+q+1);
    int m=0;
    for(int i=1;i<=q;i++)
    {
        while(p[m].r>=b[i].r)m--;
        if(p[m].l<b[i].l)p[++m]=b[i];
    }
    //printf("%lld\n",inv(2));
    for(int i=1;i<=m;i++)
    {
        //printf("%lld %lld\n",p[i].l,p[i].r);
        nxt[i]=head[p[i].r];
        head[p[i].r]=i;
    }
    int pre=0;
    int ans=0;
    for(int i=1;i<=x;i++)
    {
        int now=calc(i);
        ans=(ans+i*((now-pre+MOD)%MOD)%MOD)%MOD;
        pre=now;
    }
    printf("%lld",ans);
    return 0;
}

```



---

## 作者：w (赞：5)

官方题解： https://www.luogu.org/discuss/show?postid=7867


---

## 作者：tzc_wk (赞：3)

[题面传送门](https://www.luogu.com.cn/problem/P3600)

~~我竟然独立搞出了这道黑题！incredible！~~

u1s1 这题是我做题时间跨度最大的题之一……

首先讲下我四个月前想出来的 $n^2\log n$ 的做法吧。

记 $f(a)=\max\limits_{i=1}^q\min\limits_{j=l_i}^{r_i}a_j=x$

首先期望转概率，设 $p_i$ 表示 $f(a)=x$ 的概率，答案即为 $\sum p_i\times i$。

注意到这题直接求 $f(a)=x$ 的概率不是特别容易，故考虑换个思路，求出 $f(a)\geq x$ 的概率 $t_x$ 然后求个差分即可。是我们的任务转化为求 $t_x$ 的值。

记序列中 $<x$ 的数为 $0$，$\ge x$ 的数为 $1$，那么原题等价于这样一个问题，有一个长度为 $n$ 的随机 $01$ 序列，每一位生成 $0$ 的概率为 $p_0=\dfrac{x-1}{m}$，生成 $1$ 的概率为 $p_1=\dfrac{m-x+1}{m}$，给定 $q$ 个区间 $[l_i,r_i]$，问有多大概率满足这 $q$ 个区间中**至少存在一个区间中全是 $1$**。

这个问题可以用 $dp$ 求解，设 $dp_{i,j}$ 表示当前填好了前 $i$ 位，上一个 $0$ 的位置为 $j$，并且到现在为止不存在全为 $1$ 的区间的概率。

考虑转移，记 $mx_R$ 表示 $\max\limits_{i=1}^ql_i(r_i=R)$，分三种情况转移：

- $j<mx_i$，那么显然已经存在全 $1$ 的区间了（$[mx_i,j]$），故 $dp_{i,j}=0$ 并让 $t_x$ 加上 $dp_{i-1,j}\times p_1$。
- $mx_i\le j<i$，显然 $dp_{i,j}=dp_{i-1,j}\times p_1$。
- $j=i$，考虑枚举在 $i$ 前面上一个为 $0$ 的位置 $k$，那么有 $dp_{i,j}=\sum\limits_{k=0}^{i-1}dp_{i-1,k}\times p_0$。

这样暴力转移复杂度是 $n^2$ 的，不过考虑借鉴 CF115E 的套路，可以建一棵**线段树**在枚举 $i$ 的过程中实时维护 $dp_{i,j}$ 的值。具体来说，对于 $j<mx_i$ 的部分就查询 $[0,mx_i-1]$ 的和 $sum$，将 $sum\times p_1$ 累加入答案中并将 $[0,mx_i-1]$ 全部赋上 $0$；对于 $mx_i\le j<i$ 的部分令线段树上 $[mx_i,j)$ 位置上的值乘上 $p_1$；对于 $j=i$ 的部分就查询一遍 $[0,i-1]$ 的和 $sum$ 并在线段树上 $i$ 位置的值赋上 $sum\times p_1$，这样即可实现 $\mathcal O(\log n)$ 转移，DP 的复杂度也就降到了 $n\log n$，再加上外层求解 $t_x$ 所枚举的 $x$ 可知总复杂度为 $n^2\log n$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
typedef pair<int,int> pii;
typedef long long ll;
const int MAXN=2e3+5;
const int MOD=666623333;
int n,m,q,l[MAXN+5],r[MAXN+5],inv,p[MAXN+5],ans[MAXN+5];
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int add(int x,int y){return ((x+=y)>=MOD)?(x-MOD):x;}
struct node{int l,r,val,lz;} s[MAXN*4+5];
void build(int k,int l,int r){
	s[k].l=l;s[k].r=r;s[k].val=0;s[k].lz=1;if(l==r) return;
	int mid=(l+r)>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);
}
void pushdown(int k){
	if(!s[k].lz){
		s[k<<1].lz=0;s[k<<1|1].lz=0;
		s[k<<1].val=0;s[k<<1|1].val=0;
		s[k].lz=1;return;
	}
	if(s[k].lz^1){
		s[k<<1].lz=1ll*s[k<<1].lz*s[k].lz%MOD;
		s[k<<1].val=1ll*s[k<<1].val*s[k].lz%MOD;
		s[k<<1|1].lz=1ll*s[k<<1|1].lz*s[k].lz%MOD;
		s[k<<1|1].val=1ll*s[k<<1|1].val*s[k].lz%MOD;
		s[k].lz=1;
	}
}
void modify(int k,int l,int r,int x){
	if(l>r) return;
	if(l<=s[k].l&&s[k].r<=r){
		s[k].lz=1ll*s[k].lz*x%MOD;
		s[k].val=1ll*s[k].val*x%MOD;return;
	} pushdown(k);int mid=(s[k].l+s[k].r)>>1;
	if(r<=mid) modify(k<<1,l,r,x);
	else if(l>mid) modify(k<<1|1,l,r,x);
	else modify(k<<1,l,mid,x),modify(k<<1|1,mid+1,r,x);
	s[k].val=add(s[k<<1].val,s[k<<1|1].val);
}
void update(int k,int ind,int x){
	if(s[k].l==s[k].r){s[k].val=x;return;}
	pushdown(k);int mid=(s[k].l+s[k].r)>>1;
	if(ind<=mid) update(k<<1,ind,x);
	else update(k<<1|1,ind,x);
	s[k].val=add(s[k<<1].val,s[k<<1|1].val);
}
int query(int k,int l,int r){
	if(l>r) return 0;
	if(l<=s[k].l&&s[k].r<=r) return s[k].val;
	pushdown(k);int mid=(s[k].l+s[k].r)>>1;
	if(r<=mid) return query(k<<1,l,r);
	else if(l>mid) return query(k<<1|1,l,r);
	else return add(query(k<<1,l,mid),query(k<<1|1,mid+1,r));
}
void solve(int x){
	int p1=1ll*(m-x+1)*inv%MOD,p0=1ll*(x-1)*inv%MOD;
	modify(1,0,n,0);update(1,0,1);
	for(int i=0;i<=n;i++){
		ans[x]=(ans[x]+query(1,0,p[i]-1))%MOD;modify(1,0,p[i]-1,0);
		update(1,i+1,1ll*query(1,p[i],i)*p0%MOD);modify(1,p[i],i,p1);
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);inv=qpow(m,MOD-2);
	for(int i=1;i<=q;i++) scanf("%d%d",&l[i],&r[i]),p[r[i]]=max(p[r[i]],l[i]);
	build(1,0,n);for(int i=m;i;i--) solve(i);int ret=0;
	for(int i=1;i<=m;i++) ret=(ret+1ll*(ans[i]-ans[i+1]+MOD)*i%MOD)%MOD;
	printf("%d\n",ret);
	return 0;
}
/*
4 3 2
1 3
2 4
*/
```

然鹅当我写好了代码，有十足的信心切掉这道题的时候……

…………TLE 70？

当时还以为是自己常数写大了，花了九牛二虎之力卡常却无果，xtbz

于是这道题就光荣地在我【尝试过的题】中躺了四个月。

---

这周三的时候又重新翻到了这个题，顺带着把 $n^2$ 的算法想出来了。

~~于是现在我才知道当时平方对数的算法过不了是出题人故意卡的~~

注意到在之前平方对数的算法中，我们对 $t_x$ 的定义为 $f(a)\geq x$ 的概率，如果换成 $f(a)\le x$ 的概率会有什么区别呢？

这次，我们记序列中 $\le x$ 的数为 $1$，$>x$ 的数为 $0$，那么求解 $f(a)\le x$ 的部分等价于如下的问题：有一个长度为 $n$ 的随机 $01$ 序列，每一位生成 $0$ 的概率为 $p_0=1-\dfrac{x}{m}$，生成 $1$ 的概率为 $p_1=\dfrac{x}{m}$，给定 $q$ 个区间 $[l_i,r_i]$，问有多大概率满足这 $q$ 个区间中**每一个区间中都存在至少一个 $1$**

还是考虑 $dp$，记 $dp_i$ 为当前考虑到第 $i$ 位，且第 $i$ 位是 $1$ 的概率。

考虑转移，我们枚举上一个 $1$ 的位置 $j$，就有 $dp_i=\sum\limits_{j=0}^{i-1}dp_j\times p_0^{i-j-1}\times p_1$。

但事实上这个转移方程是错误的，因为并不是所有的 $j$ 都可以转移，比方说 $i=4,j=1,l_1=2,r_1=3$，那么 $[l_1,r_1]$ 中所有数都是 $0$，不符合要求。

那么问题就来了，究竟什么样的 $j$ 才能转移到 $i$ 呢？

显然 $j$ 可以转移到 $i$ 当且仅当不存在 $i\in[1,q]$ 使得 $[l_i,r_i]\subseteq(j,i)$，并且我们还可以发现一件事，那就是如果 $j$ 可以转移到 $i$，并且 $j<i-1$，那么 $j+1$ 也一定可以，故合法的决策点是一个右端点为 $i-1$ 的区间，记 $i$ 对应决策点区间的左端点为 $L_i$，那么上述方程式可改写为 $dp_i=\sum\limits_{j=L_i}^{i-1}dp_j\times p_0^{i-j-1}\times p_1$。

那么怎么求出 $L_i$ 呢？记 $mx_R$ 表示 $\max\limits_{i=1}^ql_i(r_i=R)$。那么我们只需检验是否存在某个 $k\in(j,i)$ 使得 $mx_k>j$ 即可，我们还可以注意到 $L_i>L_{i-1}$，也就是 $L_i$ 单调递增。故可用 two pointers+ST 表在 $n\log n$ 预处理、$\mathcal O(n)$ 求解的时间内求出 $L_i$，具体来说，ST 表维护 $\max\limits_{i=l}^rmx_i$，然后检验 $\max\limits_{k=j+1}^{i-1}mx_k>j$ 即可。

求出 $L_i$ 之后转移就变得异常容易了。我们可将转移方程式进一步改写为 $dp_i=\sum\limits_{j=L_i}^{i-1}\dfrac{dp_j}{p_0^j}\times p_0^{i-1}\times p_1$，注意到前面 $\dfrac{dp_j}{p_0^j}$ 只与 $j$ 有关，后面 $p_0^{i-1}\times p_1$ 只与 $i$ 有关，故可以维护 $\dfrac{dp_j}{p_0^j}$ 的前缀和，这样即可实现 $\mathcal O(1)$ 转移。

时间复杂度 $n^2$。

~~终于把自爆的心头之恨化解掉了，爽~~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
typedef unsigned int u32;
typedef unsigned long long u64;
namespace fastio{
	#define FILE_SIZE 1<<23
	char rbuf[FILE_SIZE],*p1=rbuf,*p2=rbuf,wbuf[FILE_SIZE],*p3=wbuf;
	inline char getc(){return p1==p2&&(p2=(p1=rbuf)+fread(rbuf,1,FILE_SIZE,stdin),p1==p2)?-1:*p1++;}
	inline void putc(char x){(*p3++=x);}
	template<typename T> void read(T &x){
		x=0;char c=getchar();T neg=0;
		while(!isdigit(c)) neg|=!(c^'-'),c=getchar();
		while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
		if(neg) x=(~x)+1;
	}
	template<typename T> void recursive_print(T x){if(!x) return;recursive_print(x/10);putc(x%10^48);}
	template<typename T> void print(T x){if(!x) putc('0');if(x<0) putc('-'),x=~x+1;recursive_print(x);}
	void print_final(){fwrite(wbuf,1,p3-wbuf,stdout);}
}
const int MAXN=2e3;
const int LOG_N=11;
const int MOD=666623333;
int n,m,q,inv,mx[MAXN+5],st[MAXN+5][LOG_N+2],pre[MAXN+5];
int pw[MAXN+5],ipw[MAXN+5],dp[MAXN+5],sum[MAXN+5],ans[MAXN+5];
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int query_mx(int l,int r){
	if(l>r) return 0;int k=31-__builtin_clz(r-l+1);
	return max(st[l][k],st[r-(1<<k)+1][k]);
}
int solve(int x){
	int p0=1ll*(m-x)*inv%MOD,p1=1ll*x*inv%MOD,ip0=qpow(p0,MOD-2);
	pw[0]=1;for(int i=1;i<=n;i++) pw[i]=1ll*pw[i-1]*p0%MOD;
	ipw[0]=1;for(int i=1;i<=n;i++) ipw[i]=1ll*ipw[i-1]*ip0%MOD;
	memset(dp,0,sizeof(dp));memset(sum,0,sizeof(sum));
	dp[0]=sum[0]=1;
	for(int i=1;i<=n;i++){
		dp[i]=1ll*(sum[i-1]-sum[pre[i]-1]+MOD)*pw[i-1]%MOD*p1%MOD;
		sum[i]=(sum[i-1]+1ll*dp[i]*ipw[i])%MOD;
	} int ret=0,mn=query_mx(1,n);
	for(int i=mn;i<=n;i++) ret=(ret+1ll*dp[i]*pw[n-i])%MOD;
	return ret;
}
int main(){
	scanf("%d%d%d",&n,&m,&q);inv=qpow(m,MOD-2);
	for(int i=1,l,r;i<=q;i++) scanf("%d%d",&l,&r),chkmax(mx[r],l);
	for(int i=1;i<=n;i++) st[i][0]=mx[i];
	for(int i=1;i<=LOG_N;i++) for(int j=1;j+(1<<i)-1<=n;j++)
		st[j][i]=max(st[j][i-1],st[j+(1<<i-1)][i-1]);
	for(int i=1,j=0;i<=n;i++){
		while(j<i&&query_mx(j+1,i-1)>j) ++j;
		pre[i]=j;
	} int res=0;
	for(int i=1;i<m;i++) ans[i]=solve(i);ans[m]=1;
	for(int i=1;i<=m;i++) res=(res+1ll*(ans[i]-ans[i-1]+MOD)*i)%MOD;
	printf("%d\n",res);
	return 0;
}
```



---

## 作者：Mentos_Cola (赞：2)

## 题意

~~太长了自己看题~~

## Solution

这道题求结果的期望大小。

设 $ P(i)=(Ans<=i)$ 的概率
，则　$ Ans=\sum\limits_{i=1}^x(P(i)-P(i-1))\times i $ 

这道题中，生成每一种情况的概率是相等的，因此可将概率转化为方案数之比：

设 $ h(i)=(Ans<=i) $ 的方案数,则
$ P(i)= \dfrac{h(i)}{i^n} $

而 结果 $ \le i \Leftrightarrow $ 对于给定的每个区间内都存在至少一个 $ \le i $ 的数

所以设 $ g(i)= $ 插入符合要求的 $ i $ 个数，满足所有给定区间都存在至少这样一个符合要求的数的方案数

那么 $ h(i)=\sum\limits_{j=1}^ng(j)\times i^j\times (x-i)^{n-j} $ (即枚举生成了 $ j $ 个 $ \le i $ 的数)

接下来考虑如何求 $ g(i) $ ，我们发现这已经跟值域没有关系了，可以直接 $ DP $ 。

我们发现，对于两个区间，如果它们是包含与被包含的关系，那么只需满足那个小区间的限制，大区间的限制就一定可以被满足。因此我们可以删去所有的这种大区间。剩下的区间排序后就是左界右界都不减的了。

如何 $ DP $ 呢？我们设 $ dp[i][j] $ 表示在 $ i $ 位置插入了这样的数，总共已插入了 $ j $ 个这样的数的方案数，

则 $ dp[i][j]= \sum\limits_{k=1}^ndp[k][j-1] $ ，然而需要这个 $ k $ 和 $ i $ 中间没有一个既不含 $ k $，也不含 $ i $ 的区间，因为否则这个区间里就将没有符合要求的数。

随着 $ i $ 的增长， $ k $ 显然也是单调不降的。因此套上一个前缀和，这个 $ DP $ 就可以被优化到 $ O(n^2) $ 。

把上述思路逆过来实现，这道题就被解决了。

在 $ DP $ 前的预处理有些小细节，请参考代码理解。

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2010,Mod=666623333;
struct node{int l,r;}a[N],b[N];
int dp[N][N],g[N],h[N],p[N];
int fl[N],fr[N],sum[N];
bool cmp(node q,node p){
	if(q.l!=p.l)return q.l<p.l;
	return q.r>p.r;
}
int qp(int x,int y){
	if(!y)return 1;
	int t=qp(x,y>>1);
	if(y&1)return t*t%Mod*x%Mod;
	return t*t%Mod;
}
signed main(){
	int n,x,q,m=0;
	cin>>n>>x>>q;
	for(int i=1;i<=q;i++)
		cin>>a[i].l>>a[i].r;
	sort(a+1,a+1+q,cmp);
	for(int i=1;i<=q;i++){
		while(a[i].r<=b[m].r)--m;
		b[++m]=a[i];
	}
	for(int i=1;i<=n;i++)fl[i]=m+1;
	for(int i=1;i<=m;i++)
		for(int j=b[i].l;j<=b[i].r;j++)
			fl[j]=min(fl[j],i),fr[j]=max(fr[j],i);
	for(int i=1;i<=n;i++){
		if(fr[i])continue;
		for(int j=1;j<=m;j++)
			if(b[j].r<i)fr[i]=j;
			else break;
		for(int j=m;j>=1;j--)
			if(b[j].l>i)fl[i]=j;
			else break;
	}
	dp[0][0]=1;
	for(int i=0;i<=n;i++)sum[i]=1;
	for(int j=1;j<=n;j++){
		for(int i=1,k=0;i<=n;i++){
			while(fr[k]+1<fl[i]&&k<i)k++;
			if(k>=i)continue;
			dp[i][j]=(sum[i-1]-(k==0?0:sum[k-1]))%Mod;
		}
		sum[0]=dp[0][j];
		for(int i=1;i<=n;i++)
			sum[i]=sum[i-1]+dp[i][j];
	}
	for(int i=n;i;i--){
		if(fr[i]!=m)break;
		for(int j=1;j<=n;j++)
			(g[j]+=dp[i][j])%=Mod;
	}
	for(int i=1;i<=x;i++){
		for(int j=1;j<=n;j++)
			(h[i]+=qp(i,j)*qp(x-i,n-j)%Mod*g[j]%Mod)%=Mod;
		p[i]=h[i]*qp(qp(x,n),Mod-2)%Mod;
	}
	int ans=0;
	for(int i=1;i<=x;i++)
		(ans+=(p[i]-p[i-1]+Mod)%Mod*i%Mod)%=Mod;
	cout<<ans<<endl;
	return 0;
}

---

## 作者：kczno1 (赞：2)

说一下我骗30分的方法吧。

10分：x^n枚举所有状态，之后O(q)检验。。

20分：枚举答案，之后计算方案数。枚举达到该答案的数的个数i，那么方案数=C(n,i)\*x^(n-i)。

sigma(答案\*对应方案数)除以总方案数就是期望。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define D 666623333
#define N 2010

int n,u,m;
ll mi(ll x,ll y)
{
    ll ans=1;
    while (y)
    {
        if (y&1) (ans*=x)%=D;
        y>>=1;(x*=x)%=D;
    }
    return ans;
}

ll niv(ll x)
{
    return mi(x,D-2);
}

ll i;

int q[10],l[10],r[10];
ll ans;
int get(int l,int r)
{
    int ans=q[l];
    while ((++l)<=r) ans=min(ans,q[l]);
    return ans;
}
void solve()
{
    int now=0;
    for (i=1;i<=m;++i) now=max(now,get(l[i],r[i]));
    ans+=now;
}
int tot;
void dfs(int x)
{
    if (x>n) 
    {
        ++tot;
        solve();
        return ;
    }
    int &i=q[x];
    for (i=1;i<=u;++i)
        dfs(x+1);
}

ll jie[N],njie[N];
void init_jie()
{
    jie[0]=1;
    for (i=1;i<=2000;++i) jie[i]=jie[i-1]*i%D;
    for (i=0;i<=2000;++i) njie[i]=niv(jie[i]);
}

ll c(int y,int x)
{
    return jie[y]*njie[x]%D*njie[y-x]%D;
}

int main()
{ //freopen("1.in","r",stdin);
    scanf("%d%d%d",&n,&u,&m);
    init_jie();
    if (m==1)
    {
        ll l,r;
        scanf("%lld%lld",&l,&r);n=r-l+1;
        ll ans=0,low,i;
        for (low=1;low<=u;++low)
        for (i=1;i<=n;++i)  
         (ans+= low*c(n,i)%D*mi(u-low,n-i)%D )%=D;
        ans=ans*niv(mi(u,n))%D;
        printf("%lld",ans);    
    }
    else
    { 
      for (i=1;i<=m;++i) scanf("%d%d",l+i,r+i);
      dfs(1);
      printf("%lld",ans*niv(tot)%D);
    }
}
```

---

## 作者：cirnovsky (赞：0)

## $\mathcal{Desciption}$

[Link](https://www.luogu.com.cn/problem/P3600).

给定一个值域在 $[1,x]$ 的长度为 $n$ 的序列（由随机数构成），求给定一组区间中的最小值的最大值的期望。

## $\mathcal{Solution}$

记：
$$
w=\max\{\min\{a_{l_{j}},a_{l_{j}+1},\cdots,a_{r_{j}}\}|j\in[1,q]\}
$$
因为我们最后取的是 $\max$，不能直接用全概率公式，转化一下：
$$
E(w)=\sum_{i=0}^{\infty}P(w\ge i)=\sum_{i=0}^{\infty}1-P(w<i)
$$
这意味着每一个被询问区间中的最小值都需 $<i$。也就是说，每一个区间至少需要一个 $<i$ 的数。

这对于每一个区间来说概率为 $\frac{i-1}{x}$。又因为区间可能出现相交，所以我们考虑用点去被包含于区间。

当然，一个区间包含另一个区间，这个区间肯定是没有用的。然后把区间按左右端点分别为第一、第二关键字排序。

枚举 $w$，设 $f_{i}$ 表示区间右端点在 $i$ 之前的所有区间满足条件的概率。
$$
f_{i}=\frac{w-1}{x}\times\sum_{j=0}^{i}f_{j}\times(1-\frac{w-1}{x})^{i-j-1}
$$

## $\mathcal{Code}$

```cpp
#include <cstdio>

using i64 = long long;

const int MOD = 666623333;
const int MAXN = 2e3 + 5;

int n, x, q, ar[MAXN];
i64 f[MAXN][2], ff[MAXN][2];

void imax ( int& a, const int b ) { a = a < b ? b : a; }
int add ( const int a, const int b, const int p = MOD ) { return a + b < p ? a + b : ( a + b ) % p; }
int sub ( const int a, const int b, const int p = MOD ) { return a - b < 0 ? a - b + p : a - b; }
int mul ( const i64 a, const i64 b, const int p = MOD ) { return a * b % p; }
int cpow ( int bas, int idx = MOD - 2 ) {
	int res = 1;
	while ( idx ) {
		if ( idx & 1 )	res = mul ( res, bas );
		bas = mul ( bas, bas ), idx >>= 1;
	}
	return res % MOD;
}

int main () {
	scanf ( "%d%d%d", &n, &x, &q );
	for ( int i = 1, tmpl, tmpr; i <= q; ++ i )	scanf ( "%d%d", &tmpl, &tmpr ), imax ( ar[tmpr + 1], tmpl );
	for ( int i = 1; i <= n + 1; ++ i )	imax ( ar[i], ar[i - 1] );
	i64 ix = cpow ( x ), ans = 0;
	for ( int i = 1; i <= x; ++ i ) {
		i64 p = mul ( i - 1, ix ) % MOD, ip = cpow ( 1 - p ), s;
		ff[0][0] = ff[0][1] = 1;
		for ( int j = 1; j <= n; ++ j )	ff[j][0] = mul ( ff[j - 1][0], 1 - p ) % MOD, ff[j][1] = mul ( ff[j - 1][1], ip ) % MOD;
		f[0][0] = 0, f[0][1] = 1;
		for ( int j = 1; j <= n; ++ j ) {
			f[j][0] = mul ( mul ( p, sub ( f[j - 1][1], ar[j] ? f[ar[j] - 1][1] : 0 ) ) % MOD, ff[j - 1][0] ) % MOD;
			f[j][1] = add ( mul ( f[j][0], ff[j][1] ) % MOD, f[j - 1][1] ) % MOD;
		}
		s = 0;
		for ( int j = ar[n + 1]; j <= n; ++ j )	s = add ( s, mul ( f[j][0], ff[n - j][0] ) % MOD ) % MOD;
		ans = sub ( add ( ans, 1 ) % MOD, s );
	}
	printf ( "%lld\n", ans % MOD );
	return 0;
}
```

---


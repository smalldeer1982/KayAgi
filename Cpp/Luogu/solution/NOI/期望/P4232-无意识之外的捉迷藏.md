# 无意识之外的捉迷藏

## 题目背景

### （五）心与心的对话

旧都还在下着雪。

不知道走了多远的路，已经远离街市了。

眼前隐隐约约能看到一座巨大的宫殿。

那就是，地灵殿吗？

心里突然紧张了起来。

这里住着旧地狱最可怕的觉妖怪。

古明地觉，她拥有读心的能力。人类，妖怪，甚至是怨灵，站在她面前的时候都如同赤身裸体，没有任何秘密可言。而且，听说在战斗中，她还会使用催眠术不断激起对手内心深处的恐怖回忆，从心灵上打垮对手。这样的妖怪自然会被人讨厌啦。

不过，此次地底之旅可不能因为要遇到可怕的妖怪而就此结束。

咚咚咚，敲了敲地灵殿的大门。

“来客吗，真是少见呢。”

眼前，站着一个少女，穿着蓝色的衣服，粉红色的裙子，头发也是粉红色的。

在她的胸前，悬着一只红色的大眼睛，通过眼睛周围的六根管子连接着身体。

她看起来很温柔的样子，完全不像听说的那样恐怖。

“来地底旅行的外面世界的人类吗？真是非常少见呢，居然找到了这里”

“看起来没有别的想法，就是想来转转呢，那就进来吧”

走进大门。

不愧是地灵”殿”，真的是好大的一个宫殿，桃红色和黑色相间的地板，印有花纹的窗户。

眼前是一组很宽的台阶，通向二楼，然后分成左右两个通道。

“很漂亮吧，这里空间大，宠物们都很喜欢呢。”

就这样，我跟着觉进入了她工作的房间，我们坐在沙发上聊了很久，虽然我很少说话。

在聊天的过程中，我了解到她还有一个妹妹古明地恋，由于不愿让别人因为自己会读心而讨厌自己，闭上了觉之瞳。觉为了开导妹妹，经常和宠物陪着她玩。

地灵殿，觉和妹妹，宠物们，一直在过着平静又温馨的生活。

“既然来这里了，就和我们一起玩吧。”觉邀请我们参与她们的游戏。

地底的妖怪会玩怎样的游戏呢？

于是，就这样，我就答应参与觉和恋的“无意识的捉迷藏”了。

说是”捉迷藏”，其实和普通的捉迷藏区别很大，更类似于”捉人游戏”。

就是觉和恋一开始分别站在两个地方，觉要捉到恋就算赢了。

但为什么又说是”捉迷藏”呢？

原来恋恋可以无意识地行动，也就是可以让周围人在潜意识里忽略她的存在，类似隐身，但又不是隐身。真是有趣的能力呢，是不是闭上了觉之瞳的缘故？

我们玩得很开心。有时无意识碰到了恋恋的手，还吓了一跳呢。

一段时间后，姐妹俩累了，觉还有工作要处理，就先回去了。

宠物们似乎意犹未尽，她们还想继续。

“可是在这个旧地狱啊，除了主人的妹妹恋以外，哪里又有妖怪能够操纵无意识呢？

算了,干脆玩普通的捉人游戏吧。”阿燐提议道。

于是宠物们很快又忘我地投入了”无意识之外的捉迷藏”中。

不知什么时候，我感到背后一凉，回过头一看，原来是恋恋。

我们就这样站在这里看着宠物们玩。

虽然不知道为什么能耐心地看那么长时间，但几个小时过去了，我们依然站在这里。

恋恋好像有一些疑问，在经过简单的交流后，我把她的疑问做了一个总结。

(见题目描述)

这个问题对无意识的恋恋来说果然无法解决啊。

能和姐妹俩聊得这么开心，真是很感激呢，那就尽自己的努力思考一下这个问题吧。

(后续剧情见题解，接下来请看T4)


## 题目描述

###问题摘要：

在一个有向无环图上，阿燐和阿空第0个时刻分别站在编号为$s_r$,$s_k$的节点，二人都知道双方的初始位置，对地图完全了解。

从第1个时刻起，每个时刻阿燐和阿空都可以选择站着不动，也可以选择移动到相邻的节点，二人每时刻的移动是同时开始的，并且不能中途改变方向。

阿燐被阿空捉住时，游戏立即结束。如果阿空一直没有捉住阿燐，第$t$个时刻结束后两人就不能再继续移动了，游戏将在第$t+1$个时刻结束。

阿空的目的是尽快捉住阿燐(捉住的定义是与阿燐同一时刻站在同一节点)，而阿燐的目的是尽可能更长时间不被阿空捉住。具体而言，若一场游戏进行了$t_0$时刻，阿燐的得分是$t_0$，阿空的得分是$-t_0$，双方都希望自己得分(或得分的期望值)更高。

我们认为在这个过程中阿燐和阿空随时都能知道对方的位置。两人在第$t$个时刻不能看出第$t+1$个时刻对方要走到哪里。

恋恋想知道，在双方最优决策的情况下，游戏结束时刻的期望值是多少。


## 说明/提示

###样例解释：

样例1：阿燐只要一直不动，阿空在前$t$单位时间内就无法抓到阿燐，答案为$t+1$，即```11.000```

样例2：无可奉告

###数据范围：

对于30%的数据 $n\leqslant3$，捆绑测试

对于100%的数据 $n,t\leqslant20$，前40%的数据和后30%的数据分别捆绑测试

###提示：
本题主要考察你能否使用正确的方法算出答案，对算法运行耗时要求不高。

by orangebird


## 样例 #1

### 输入

```
3 2 1 2 10
1 3
2 3
```

### 输出

```
11.000```

## 样例 #2

### 输入

```
6 8 2 1 2
1 2
1 3
1 5
2 3
3 5
5 6
6 4
2 4
```

### 输出

```
2.333```

# 题解

## 作者：orangebird (赞：28)

后续剧情在下面，首先是不带剧情的题解

先来看看30分

n<=3，我们可以分情况讨论

大部分情况都非常显然，在这里只说一下最复杂的一种情况吧

![](https://cdn.luogu.com.cn/upload/pic/14514.png)

这种情况下，阿空选择原地不动显然严格劣势于选择走到2或者3，因此阿空可能的选择有两种。

阿燐可以选择下一步停在2或者3，同样也是两种。

那么具体选择哪一种呢？

由于双方选择2或者3都不是严格优势的做法，所以这种情况不存在纯策略意义下的最优策略，最优策略一定是2与3的混搭(以一定概率出2，一定概率出3)。

设阿空的期望收益为E。(则阿燐的期望收益为-E)
双方都是最优策略，则任何一方单方面改变策略都无法提高自己的期望收益。

那么这意味着，你所作出的策略应该满足这么一个条件，即对于对方所有可能的策略，你的收益期望值都不会低于E。否则，对方就可以有意改变自己走向2或3的概率，来提高她自己的收益并使其大于-E，这就与上句话矛盾了。
寻找最优策略的过程就是使这个E最大化的过程。

我们设阿燐走向2的概率为x，就可以列出方程

x+2(1-x)>=E

(t+1)x+(1-x)>=E

此例中，排除严格劣势的策略后，两个式子都取到了等号

所以有x+2(1-x)=(t+1)x+(1-x)

可以解出收益的期望值E为(2t+1)/(t+1)。

然后是正解

首先看看图的类型，有向无环图，说明阿燐和阿空只能朝着一个方向走，不可能循环。

又因为游戏时间有限,信息完全，所以状态数量是有限的，为O(n^2*t)级别。
(经提醒，即使有环也不会出现循环依赖，因为时间维度永远在向前走)

计算某种状态的期望值所的依赖的是其所有子状态的期望值，由于无环，不会出现循环依赖，所以子问题的规模比原问题小。

这样就可以通过递归来解决了。

那么具体怎么做呢？

我们来通过样例2进行解释。

用s(r,k,t)来表示阿燐站在第r个节点，阿空站在第k个节点，游戏还剩下t个时刻时阿燐期望生存的时间。

为了计算出s(2,1,4),根据初始状态能转移到的状态，我们画出两人的收益表。

(因为是零和博弈，所以这里以阿燐的收益为准，阿空的收益为相反数)。
![](https://cdn.luogu.com.cn/upload/pic/14515.png)
![](https://cdn.luogu.com.cn/upload/pic/14517.png)

可以看出问题被化为了一个个子问题，规模也变小了。

那么我们递归下去先计算好暂时不知道的每一项。

这里应当使用记忆化搜索来存储已经计算好的子问题，因为同一个子问题可能被计算多次(其实就是DP)。

然后得出一个具体数值的表:

![](https://cdn.luogu.com.cn/upload/pic/14519.png)

根据n<=3中提到的方法，我们同样可以列出式子，然后会发现它就是线性规划。
直接套板子就可以了。

求这个线性规划其实就是在求解纳什均衡。

更详细说明可以参考下文:
http://www.ixueshu.com/document/ea63e86bd7c77896.html

设所用线性规划算法的时间复杂度为O(f(n))

则算法的总时间复杂度O(n^2*t*f(n))

标程用的单纯形，最坏情况下复杂度是指数级别的，但最大规模数据(n=20,边全满,t=20)只跑了不到50ms就过了...

那么这就是本题的解法了。

### 后续剧情
### （六）无意识之外的捉迷藏
这次.....真的没有那么容易了。

这个问题的复杂程度超出了自己的想象... 不得不说，这是一件很痛苦的事情。

我为了解决这个问题，四处查询资料，学习新知识，在中途还因为选择方向错误而碰了壁。

多亏地灵殿有一些空出来的房间，这几天干脆就住在了这里。

这里的饭真香啊。觉说我们是很友好的人，虽然我心里也会胡思乱想一些奇怪的事情，不过她好像并不怎么介意。

嗯，那么话不多说，我们就少绕点弯路，来谈一谈问题最终的解决思路吧。

首先看看图的类型，有向无环图，那么说明阿燐和阿空只能朝着一个方向走，不可能产生循环。有 n 个节点，时间最多为 t。这意味着在这个问题中，所有可能出现的情况数是 n^2*t这个级别。

为什么呢？因为阿燐的位置有 n 个选择，阿空也有 n 个，双方位置确定时，当前
的时间可能有 t 种，所以就是 n*n*t 中状态咯。

我们用 s(r,k,t)来表示阿燐站在第 r 个节点，阿空站在第 k 个节点，游戏还剩下 t 个时刻时阿燐期望生存的时间。

嗯，就以这个图为例吧。

我们最终的目的就是计算 s(2,1,4)。

![](https://cdn.luogu.com.cn/upload/pic/14515.png)

这时阿燐有 3 种选择。走到 3,4 或原地不动。

阿空有 4 种选择，走到 2,3,5 或原地不动。

那么这就产生了 12 种结果

![](https://cdn.luogu.com.cn/upload/pic/14517.png)

那么，为了计算 s(2,1,4)我们需要先计算一系列的 s(x,x,x)。

还记得刚才的结论吗？计算某种状态的期望值所的依赖的是其所有子状态的期望值，由于无环，不会出现循环依赖，所以子问题的规模比原问题小。

这样，我们就可以”递归”来解决了。

那么根据这个表，怎样算出具体的策略和生存时间期望呢？

这又是另一个问题了。

我们可以这样简单理解，何为最优策略？

双方都是最优策略，意味着任何一方单方面改变策略都无法提高自己的收益。

双方达成的这种平衡，就叫做”纳什均衡”。

假如对方可能做出 a,b,c 三种选择。那么无论对方最终做出了怎样的选择，你的收益一定是一样的。因为如果对方选择 a 收益更高，那么她就可以有意地提高做出 a 选择的概率，来提高自己的收益，这和”任何一方单方面改变策略都无法提高自己的收益”相矛盾。

不过很遗憾，最终的解决方案并不是这样的，因为很难用较低的时间代价判断出哪些策略相组合会严格劣于其他策略的组合。最终选用的方案是线性规划，由于比较复杂，就不详细说明了。

好啦，那么这样，恋恋心头的难题就解决了。

真想让你们也看看恋恋笑容洋溢的表情呢。

这次的地底旅行，也快要结束了吧？


---

## 作者：_Arahc_ (赞：15)

题目背景的长度让我不禁回忆起被 ynoi 支配的恐惧。

## 题意

[洛谷传送门](https://www.luogu.com.cn/problem/P4232) and [LOJ 传送门](https://loj.ac/p/6295)。

> 给定一个 DAG，A,B 两人分别在 $s_a,s_b$ 点。每轮两人同时选择走一步或不动，两人互相知道对方位置，但不知道其下一步行动。B 要尽早地抓到 A，A 要尽晚被 B 抓住，若进行 $t$ 轮后 B 还没抓到 A 则游戏强制截止。求双方都用最优策略时，一局游戏期望要多少轮。
>
> $n,t\leqslant20$。

强调一下 A 是被抓的人（原题为阿燐），B 是猎人（原题为阿空），角色不要推着推着就反了。

## 分析

神题，~~我才不会告诉你我纠结了好久为什么这题有期望~~。

先把题目信息整理一下：

+ “A 尽晚被 B 抓住，B 尽早抓住 A” 说明本题是**零和博弈**。
+ 图是 **DAG**。
+ 数据很小。

DAG 是个好东西，考虑 DP。设 $f_{x,y,k}$ 表示当前 A 在 $x$，B 在 $y$，目前已经过了 $k$ 轮，期望的轮数。随便拿出来一张图：

![](https://pic.imgdb.cn/item/61e668452ab3f51d91f3e84d.png)

红色点为 A，蓝色点为 B。

那么对于下一步的决策，有如下表：

|  A\B   |      不动       |     到 $3$      |     到 $5$      |     到 $6$      |
| :----: | :-------------: | :-------------: | :-------------: | :-------------: |
|  不动  | $f_{5,1,t+1}+1$ | $f_{5,3,t+1}+1$ |       $1$       | $f_{5,6,t+1}+1$ |
| 到 $6$ | $f_{6,1,t+1}+1$ | $f_{6,3,t+1}+1$ | $f_{6,5,t+1}+1$ |       $1$       |

发现（当然也显然）它是不会从某一状态节点跳了若干次跳到父亲状态节点，而子问题规模也比原问题小，因此可以记忆搜实现。

双方都是最优策略，说明任意一方改变策略都无法提高自己的收益，双方一直保持自己策略，这恰好是**纳什均衡**的模型。这个策略可能是与概率/频率相关的，这就是为什么这题有“期望”。

而零和博弈+纳什均衡的策略可以考虑线性规划求解。

具体而言，假设双方策略稳定（最终稳定态）时 B 的得分期望为 $E$，B 的策略为：对于第 $i$ 中决策有 $p_i$ 的概率选择，收益矩阵为 $g$，那么：
$$
\text{minimize} E
$$
$$
\begin{cases}
\sum p=1 \\
\forall j,\sum p_i g_{j,i}\leqslant E
\end{cases}
$$
设 $x_i=\frac{p_i}{E}$：
$$
\text{minimize} \sum x
$$
$$
\forall j,\sum x_i g_{j,i}\leqslant1
$$

然后就可以上线性规划板子了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=22,max_m=452,inf=1000000009;
inline int read(){
	int x=0;bool w=0;char c=getchar();
	while(c<'0' || c>'9') w|=c=='-',c=getchar();
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return w?-x:x;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
}
struct graph{
    int ct,hd[max_n],to[max_m],nx[max_m];
    graph(){ct=1;}
    inline void add(int u,int v){
        nx[++ct]=hd[u],hd[u]=ct,to[ct]=v;
    }
}e;

// ----------------以下是线性规划板子----------------

struct LinerPro{
    int n,m,id[max_n*2];
    double a[max_n][max_n];
    inline void init(int x,int y){
        n=x,m=y;
        memset(a,0,sizeof(a));
        for(register int i=1;i<=n;++i)
            id[i]=i;
        for(register int i=1;i<=m;++i)
            id[i+n]=0;
    }
    inline void turn(int x,int y){
        swap(id[y],id[x+n]);
        double k=a[x][y];
        a[x][y]=1;
        for(register int i=0;i<=n;++i)
            a[x][i]/=k;
        for(register int i=0;i<=m;++i)
            if(i!=x){
                double k=a[i][y];
                a[i][y]=0;
                for(register int j=0;j<=n;++j)
                    a[i][j]-=a[x][j]*k;
            }
    }
    inline double ask(){
        while(1){
            double k=0;
            int x=0,y=0;
            for(register int i=1;i<=m;++i)
                if(a[i][0]<k)
                    k=a[i][0],x=i;
            if(!x) break;
            for(register int i=1;i<=n;++i)
                if(a[x][i]<0){
                    y=i;
                    break;
                }
            turn(x,y);
        }
        while(1){
            double k=inf;
            int x=0,y=0;
            for(register int i=1;i<=n;++i)
                if(a[0][i]>0){
                    y=i;
                    break;
                }
            if(!y) break;
            for(register int i=1;i<=m;++i)
                if(a[i][y]>0 && a[i][0]/a[i][y]<k)
                    k=a[i][0]/a[i][y],x=i;
            turn(x,y);
        }
        return -a[0][0];
    }
}lp;

// ----------------上面是线性规划板子----------------

int n,m,sr,sk,t,deg[max_n];
double f[max_n][max_n][max_n];

inline double dfs(int u,int x,int p){
    if(f[u][x][p]!=0) return f[u][x][p];
    if(p>t || u==x) return 0;
    for(register int i=e.hd[u];i;i=e.nx[i])
        for(register int j=e.hd[x];j;j=e.nx[j])
            dfs(e.to[i],e.to[j],p+1);
    lp.init(deg[x],deg[u]);
    for(register int i=e.hd[u],c1=1;i;i=e.nx[i],++c1){
        for(register int j=e.hd[x],c2=1;j;j=e.nx[j],++c2)
            lp.a[c1][c2]=f[e.to[i]][e.to[j]][p+1]+1;
        lp.a[c1][0]=1;
    }
    lp.a[0][0]=0;
    for(register int i=1;i<=deg[x];++i)
        lp.a[0][i]=1;
    return f[u][x][p]=1/lp.ask();
}

signed main(){
	n=read(),m=read(),sr=read(),sk=read(),t=read();
	for(register int i=1;i<=m;++i){
	    int u=read(),v=read();
	    e.add(u,v),++deg[u];
	}
	for(register int i=1;i<=n;++i)
	    e.add(i,i),++deg[i];
	printf("%.3lf",dfs(sr,sk,0)); 
	return 0;
}
```

$\text{20ms,<1MiB}$。



---


# 射命丸文的笔记

## 题目背景

### （七）再见，地底世界的朋友们

在地灵殿住了许多天了呢。

这些日子里，觉分享了很多旧地狱的故事。

此次地底旅行，可以说是非常充实了。

虽然仍旧有些不舍，不过人类总是要见太阳的，再说这样麻烦觉姐姐招待我们也有些过意不去呢。

那么，和觉，恋，阿燐，阿空，以及其他宠物们说再见吧。

......

旧地狱的街市，依旧飘着雪。

已经能看到溶洞了。

环境又变得幽闭起来。

诶，前面不是山女吗？

“啊，你们要回地面了吗，玩的怎样？”

“很开心呢，对了，剩下的问题已经解决了”

我们向山女解释了从荷取那里听到的方法。

“谢谢!”

“不客气，那么再见了~”

世界一片白茫茫的...

阳光是那么的刺眼，以至于几分钟后我们才能睁开眼睛看清楚地面的景色。

沿着魔法森林中的小路向神社走去，这次的旅行也在我们的脚步声中走向了尾声。

前方的地面上忽然出现了一页破损的笔记。

捡起来一看，发现是从文文的笔记本上脱落下来的。

射命丸文，作为（不靠谱的）新闻记者，观察到最近地灵殿里的宠物们偶尔会互相打架，于是将每场决斗的胜负关系写在了她的笔记本上。刚刚捡起来的这页笔记，上面就记录着几场“单循环赛”。

每场循环赛被抽象成一张竞赛图，其中顶点代表参加循环赛的宠物，从顶点 $u$ 指向顶点 $v$ 的边代表在一场比赛中宠物 $u$ 战胜了宠物 $v$。

观察到这页笔记上所有的竞赛图中都至少存在一条经过所有顶点的回路，我们猜想文文只会记录这样的循环赛。

可能是因为文文不清楚宠物们谁能打过谁，于是在那页笔记的最下面留下了一个这样的问题...

(见题目描述)

这最后一个问题，就留给你来解决啦。

博丽大结界，已经在我们身后了。

希望这次地底旅行，能给你留下美好的记忆~

(全文完)

## 题目描述

如果一个竞赛图含有哈密顿回路，则称这张竞赛图为值得记录的。

从所有含有 $n$ 个顶点（顶点互不相同）的，值得记录的竞赛图中等概率随机选取一个。

求选取的竞赛图中哈密顿回路数量的期望值。

由于答案可能过大/丢失精度，只需要输出答案除以 $998244353$ 的余数。

即：设答案为 $\frac{q}{p}$，则你需要输出一个整数 $x$，满足 $px\equiv q \mod 998244353$ 且 $0\leqslant x<998244353$，可以证明恰好存在一个这样的 $x$。

若不存在这样的竞赛图，输出 `-1`。

## 说明/提示

### 样例解释：

$n=1$ 时只有一种满足条件的竞赛图，就是一个点。

$n=2$ 时竞赛图中只有一条边，不能形成哈密顿回路。

$n=3$ 时有两种满足条件的竞赛图，分别为 $1\to2\to3\to1$ 和 $1\to3\to2\to1$，都只有 $1$ 条哈密顿回路，随机取出后期望值为 $1$。

$n=4$ 时有很多种满足条件的的竞赛图，这里写不下了，但是所有满足条件的竞赛图都是同构的，所以随机取出后期望值为 $1$。

### 数据范围：

测试点 1~3 中 $n\leqslant7$。

测试点 4~6 中 $n\leqslant10$。

测试点 7~10 中 $n\leqslant1000$。

测试点 11~16 中 $n\leqslant10000$。

测试点 17~25 中 $n\leqslant100000$。

数据有梯度，每个测试点 $4$ 分。

为防止卡常，最后两个点开 2s 时限。

### 名词解释：

[竞赛图](https://en.wikipedia.org/wiki/Tournament_(graph_theory))：指任意两个顶点间恰有一条有向边的有向图。

[哈密顿回路](https://en.wikipedia.org/wiki/Hamiltonian_cycle)：指除起点和终点外经过所有顶点恰好一次且起点和终点相同的路径。


by oscar


## 样例 #1

### 输入

```
4```

### 输出

```
1
-1
1
1```

# 题解

## 作者：oscar (赞：45)

本题没有剧情版题解qwq

可读题面：

求所有n个点带标号强连通竞赛图中哈密顿回路数量的平均值

解法0：

样例怎么全是1和-1啊

我```if(i==2)puts("-1");else puts("1");```吼不吼啊

期望得分0分，实际得分0分

解法1：

我会枚举！

枚举所有n个点的竞赛图，统计答案

时间复杂度$O(2^{C(n,2)}n!)$，期望得分12分，实际得分8~12分

解法2：

我会剪枝！

在解法1的基础上加一些玄学剪枝

时间复杂度$O($玄学$)$，期望得分24分，实际得分12~24分

解法3：

我会打表！

用解法1在自己电脑上多跑一会

时间复杂度同解法1，期望得分24分，实际得分12~16分

8的情况在我的电脑上要跑3天QWQ

解法4：

我会dp！

考虑所有n个点的竞赛图中哈密顿回路的总数，发现很好求，答案为$\frac{n!}{n}\cdot 2^{C(n,2)-n}$（一共有$\frac{n!}{n}$种哈密顿回路，每种哈密顿回路出现在$2^{C(n,2)-n}$种竞赛图里）

于是问题转化为了求强连通竞赛图的数量$f[n]$

随便推一推式子，发现$f[n]=2^{C(n,2)}-\sum_{i=1}^{n-1}{f[i]\cdot C(n,i)\cdot 2^{C(n-i,2)}}$（总竞赛图数减去不强联通的竞赛图数）

（统计不强连通的竞赛图数时可以枚举拓扑序最小的强连通分量，剩下的边随便连，就出现上面的式子啦$QwQ$）

时间复杂度$O(n^2)$，期望得分64分，实际得分52~64分

FAQ：为什么我只得了52分？

A：想到正解不预处理不还是$O(n^2log(n))$（facepalm）

解法5：

我会分治fft/多项式求逆！

优化一下上面的过程就好啦

时间复杂度$O(nlog^2(n))$或$O(nlog(n))$，期望得分100分，实际得分100分

FAQ：为什么我写了正解只得了76分

A：你很可能没开long long。。

---

## 作者：myee (赞：13)

### 前言

似乎又是道不错的 Symbolic Method 练习题？

大力宣传一下[符号化方法](https://xyix.github.io/posts/?postname=combinatorics)，使用这一方法可以秒掉许多困难的数数题。

### 思路

不是让你求期望吗？直接求比值即可。

注意对 $i=1,2$ 的情况特判。

#### 分子

即竞赛图哈密顿回路计数。

不妨钦定 $1$ 为起点，然后直接枚举接下来的路径中 $n-1$ 个点，最后连回起点。

然后直接把剩下 ${n(n-1)\over2}-n$ 条边任意定向。

即，总哈密顿回路数为 $(n-1)!2^{{n(n-1)\over2}-n}$。

#### 分母

一个结论：竞赛图缩点后会变成一条链状 DAG，其中每个点往其后的**所有**点引出一条边。

另一个结论：竞赛图有哈密顿回路等价于其强连通，即可以缩成单个点。

我们记 $\mathcal T$ 表示带标号强连通竞赛图所对应的组合类，记 $\mathcal U$ 表示带标号竞赛图所对应的组合类。

立刻由结论得到：

$$\mathcal U=\operatorname{SEQ}(\mathcal T)$$

其中 $\operatorname{SEQ}$ 表示**带标号 Sequence 构造**。

于是立刻有：

$$\hat U={1\over1-\hat T}$$

故：

$$\hat T=1-\hat U^{-1}$$

直接做就好了。


---

## 作者：da32s1da (赞：9)

刚学了多项式求逆，找了一道例题。

---

首先n个点的竞赛图中哈密顿回路的总数是$(n-1)!\ 2^{\frac{n(n-1)}{2}-n}\ $条。

我们从起点出发，经过所有点，回到起点，组成一个1~n的排列。共有$n!$个排列。而路径是一个环，所以每条路径被计算了$n$次。

一共有$\frac{n(n-1)}{2}$条边，去掉组成环的$n$条，剩余的边的方向任意。

故总有$\frac{n!}{n}2^{\frac{n(n-1)}{2}-n}=(n-1)!\ 2^{\frac{n(n-1)}{2}-n}$条。

---

下面是求n个点的值得记录的竞赛图的数量。

即存在n个点存在哈密顿回路的竞赛图的数量（强联通竞赛图），令其为$f[n]$。

考虑竞赛图总数是$2^{\frac{n(n-1)}{2}}$，令其为$g[n]$。

则枚举拓扑序最小的强连通分量大小为$i$，则其他的点向该强连通分量连边的方向是固定的，剩下$(n-i)$个点的边任意连，所以

$f[i]=g[i]-\sum_{j=1}^{i-1}f[j]\binom{i}{j}g[i-j]$

$g[i]=\sum_{j=1}^{i}f[j]\binom{i}{j}g[i-j]=\sum_{j=1}^ii!\frac{f[j]}{j!}\frac{g[i-j]}{(i-j)!}$

$\frac{g[i]}{i!}=\sum_{j=1}^i\frac{f[j]}{j!}\frac{g[i-j]}{(i-j)!}$

令$g'[n]=\frac{g[n]}{n!},f'[n]=\frac{f[n]}{n!}$

得到$g'[i]=\sum_{j=1}^ig'[i-j]f'[j]$。

发现这是一个标准的分治FFT。于是令$F[x]=\sum_{i=0}^{\infty}f'[i]x^i,G[x]=\sum_{i=0}^{\infty}g'[i]x^i$

于是$G[n]=\frac{g'[0]}{1-F[n]}$

$F[n]=1-\frac{g'[0]}{G[n]}$

多项式求逆解决。

```
#include<cstdio>
const int N=262150;
const int mod=998244353;
int fac[N],inv[N];
int ksm(int u,int v){
	int res=1;
	for(;v;v>>=1,u=1ll*u*u%mod)
	if(v&1)res=1ll*res*u%mod;
	return res;
}
inline void swap(int &u,int &v){int o=u;u=v;v=o;}
void pre(int u){
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=u;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[u]=ksm(fac[u],mod-2);
	for(int i=u-1;i>=2;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
}
int f[N],g[N],c[N],rnk[N],n;
void Ntt(int *t,int opt,int len){
	int g=3,g_=ksm(3,mod-2);
	for(int i=0;i<len;i++)if(i<rnk[i])swap(t[i],t[rnk[i]]);
	for(int i=1;i<len;i<<=1){
		int wn=ksm(~opt?g:g_,(mod-1)/(i<<1));
		for(int j=0,J=i<<1;j<len;j+=J){
			int w=1;
			for(int k=j;k<i+j;k++,w=1ll*w*wn%mod){
				int r=1ll*w*t[i+k]%mod;
				t[i+k]=(t[k]-r+mod)%mod;
				t[k]=(t[k]+r)%mod;
			}
		}
	}
	if(~opt)return;
	int ny=ksm(len,mod-2);
	for(int i=0;i<len;i++)t[i]=1ll*t[i]*ny%mod;
}
void Inv(int Len,int *a,int *b){
	if(Len==1){b[0]=ksm(a[0],mod-2);return;}
	Inv((Len+1)>>1,a,b);
	int len=1,_2=-1;
	while(len<Len+Len)len<<=1,_2++;
	for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<_2);
	for(int i=0;i<Len;i++)c[i]=a[i];
	for(int i=Len;i<len;i++)c[i]=0;
	Ntt(c,1,len);Ntt(b,1,len);
	for(int i=0;i<len;i++)
	b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)*b[i]%mod;
	Ntt(b,-1,len);
	for(int i=Len;i<len;i++)b[i]=0;
}
int main(){
	scanf("%d",&n);
	pre(n);
	for(int i=0;i<=n;i++)g[i]=ksm(2,1ll*i*(i-1)/2%(mod-1));//得到g[i]
	for(int i=0;i<=n;i++)g[i]=1ll*g[i]*inv[i]%mod;//这里就是g'[i]了
	Inv(n+1,g,f);
	for(int i=0;i<=n;i++)f[i]=(mod-f[i])%mod;
	f[0]=(f[0]+1)%mod;//得到f'[i]
	for(int i=0;i<=n;i++)f[i]=1ll*f[i]*fac[i]%mod;//得到f[i]
	if(n>=1)puts("1");
    if(n>=2)puts("-1");//特判这两个输出
	for(int i=3;i<=n;i++)
	printf("%d\n",1ll*fac[i-1]*ksm(2,1ll*i*(i-3)/2%(mod-1))%mod*ksm(f[i],mod-2)%mod);
    //最后用路径总条数/图数量
}
```

---

## 作者：Dreamunk (赞：8)

[题目](https://www.luogu.org/problem/P4233)

题意：给出 $n$，在 __有哈密顿回路的__ $n$ 个点的竞赛图中等概率选出一个，求哈密顿回路个数的期望。

答案就是 哈密顿回路的总条数 除以 有哈密顿回路的竞赛图的个数。

哈密顿回路的总条数是很好求的，对每个环算贡献，算出 $(n-1)!2^{C_n^2-n}$。

有哈密顿回路的竞赛图的个数，这个有点难办。

结论：一个竞赛图有哈密顿回路 的充要条件是 它强连通。

必要性显然，简单证证充分性。（如果假了或者有更好的证法请告诉我qwq）

>归纳证明。对于点数很小的情况，容易验证是对的。现在假设已经证明了点数在 $n-1$ 以内时结论是对的。
假设去掉 $n$ 号点，这时图仍是竞赛图但不一定强连通，此时图中有若干个强连通分量。
把强连通分量缩点变成拓扑图后，显然拓扑序是唯一的，设为 $(S_1\rightarrow S_2\rightarrow \cdots\rightarrow S_k)$，其中 $S_i$为一个强连通分量。
因为要强连通，$n$ 和 $S_1$ 之间有至少一条边方向是 $(n\rightarrow S_1)$，而 $n$ 和 $S_k$ 之间有至少一条边方向是 $(S_k\rightarrow n)$。
由于 $S_i$ 的点数 $|S_i|$ 小于 $n$ ，所以我们已经证明了它有哈密顿回路。
考虑从每个强连通分量的哈密顿回路中选出一条边 $(u\rightarrow v)$ 删掉，然后让 $v$ 成为这个强连通分量的入点，$u$ 成为这个强连通分量的出点。
对于一个强连通分量只有一个点的情况，这个点既是入点又是出点。
我们按照 $(n\rightarrow S_1\rightarrow S_2\rightarrow \cdots\rightarrow S_k\rightarrow n)$ 的顺序，上一个分量的出点向这一个分量的入点连上边，即构造出一个哈密顿回路。
于是证完了。

所以只要求强连通竞赛图的个数。

考虑容斥，用 $n$ 个点竞赛图总数减去不连通的个数。

不连通的个数又怎么算？我们枚举缩点后拓扑序最靠前的那个强连通分量的大小，则得出式子：

$f_n=2^{C_n^2}-\sum_{i=1}^{n-1} C_n^{i}f_i 2^{C_{n-i}^{2}}$

于是得到一个平方做法。

移项一下，容易得到 $2^{C_n^2}=\sum_{i=1}^{n} C_n^{i}f_i 2^{C_{n-i}^{2}}$

构造 $F(x)=\sum_i \frac{2^{C_i^2}}{i!}x^i,G(x)=\sum_i \frac{f_i}{i!}x^i$，由上面式子可以得到 $F(x)=F(x)G(x)+1$。

$G(x)=\frac{F(x)-1}{F(x)}$

多项式求逆解决。

$n$ 特别小的情况要判一判。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
typedef long long ll;
const int K=18,M=998244353,G=3;
inline int Pow(int a,ll m){int s=1;for(;m;m>>=1)m&1?s=(ll)s*a%M:0,a=(ll)a*a%M;return s;}
namespace poly{
int rev[1<<K],t0[1<<K];
inline void Init(int K){
	for(int i=0;i<(1<<K);i++)rev[i]=rev[i>>1]>>1|(i&1)*(1<<K-1);
}
inline void Ntt(int*a,int f,int K){
	int s,omega,tmp0,tmp1;
	for(int i=0;i<(1<<K);i++)if(i<rev[i])std::swap(a[i],a[rev[i]]);
	for(int k=1;k<(1<<K);k<<=1){
	  omega=Pow(G,f>0?M/2/k:M-1-M/2/k);
	  for(int i=0;i<(1<<K);i+=k+k){
		s=1;
		for(int j=0;j<k;j++,s=(ll)s*omega%M)
		  tmp0=a[i+j],tmp1=(ll)a[i+k+j]*s%M,
		  a[i+j]=(tmp0+tmp1)%M,a[i+k+j]=(tmp0-tmp1+M)%M;
	  }
	}
	if(f<0){
	  tmp0=Pow(1<<K,M-2);
	  for(int i=0;i<(1<<K);i++)a[i]=(ll)a[i]*tmp0%M;
	}
}
inline void Inv(int*c,int*a){
	c[0]=Pow(a[0],M-2);
	for(int i=1;i<(1<<K);i++)c[i]=0;
	for(int j=0;j<K;j++){//
	  Init(j+1);
	  memcpy(t0,a,sizeof(int)*(1<<j));
	  memset(t0+(1<<j),0,sizeof(int)*(1<<j));
	  Ntt(c,1,j+1),Ntt(t0,1,j+1);
	  for(int i=0;i<(1<<K);i++)c[i]=(2ll*c[i]-(ll)c[i]*c[i]%M*t0[i]%M+M)%M;
	  Ntt(c,-1,j+1);
	  memset(c+(1<<j),0,sizeof(int)*(1<<j));
	}
}
inline void Mult(int*c,int*a,int*b){
	Init(K);
	Ntt(a,1,K),Ntt(b,1,K);
	for(int i=0;i<(1<<K);i++)c[i]=(ll)a[i]*b[i]%M;
	Ntt(c,-1,K);
}
}
int t[1<<K],a[1<<K],g[1<<K],f[1<<K],invf[1<<K],k,n;
inline int C(int n,int m){return(ll)f[n]*invf[m]%M*invf[n-m]%M;}
int main(){
	f[0]=1;
	for(int i=1;i<(1<<K);i++)f[i]=(ll)f[i-1]*i%M;
	invf[(1<<K)-1]=Pow(f[(1<<K)-1],M-2);
	for(int i=(1<<K)-1;i;i--)invf[i-1]=(ll)invf[i]*i%M;
	for(int i=0;i<(1<<K-1);i++)a[i]=(ll)Pow(2,(ll)i*(i-1)/2)*invf[i]%M;
	poly::Inv(t,a);
	for(int i=0;i<(1<<K-1);i++)g[i]=!i?1:(ll)Pow(2,(ll)i*(i-1)/2+1)*invf[i]%M;
	memset(g+(1<<K-1),0,sizeof(int)*(1<<K-1));
	memset(t+(1<<K-1),0,sizeof(int)*(1<<K-1));
	poly::Mult(g,t,g);
	memset(g+(1<<K-1),0,sizeof(int)*(1<<K-1));
	for(int i=0;i<(1<<K);i++)g[i]=(ll)g[i]*f[i]%M;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
	  if(i==1){ puts("1");continue;}
	  if(i==2){puts("-1");continue;}
	  printf("%lld\n",(ll)f[i-1]*Pow(2,(ll)i*(i-1)/2-i)%M*Pow(g[i],M-2)%M);
	}
	return 0;
}
```

---

## 作者：x7103 (赞：7)

### 题目描述
给定 $n$，求 $n$ 个点的所有有哈密顿回路的竞赛图中哈密顿回路个数的期望值，对 $998244353$ 取模。

 - 竞赛图：任意两点间有且仅有一条有向边的图。
 - 哈密顿回路：经过图上所有点恰好一次的环。
### Solution
首先算出不同的哈密顿回路的总数量，任意地选取一个环，方案数为 $(n-1)!\times 2^{\binom{n}{2}-n}$，即圆排列数乘边数。

设 $g_i$ 表示有 $i$ 个点的竞赛图的数量，$g_i=2^{\binom{i}{2}}$。

设 $f_i$ 表示有 $i$ 个点的竞赛图强联通的方案数。

由于竞赛图缩点后会形成链状 DAG，枚举第一个连通块的大小来转移。
$$g_i=\sum_{j=1}^{i}\binom{i}{j}f_jg_{i-j}$$
$$g_i=\sum_{i=1}^{i}\frac{i!}{j!(i-j)!}f_jg_{i-j}$$
$$\frac{g_i}{i!}=\sum_{j=1}^{i}{\frac{f_j}{j!}\times\frac{g_{i-j}}{(i-j)!}}$$
设 $F(x)=\sum_{i=1}^{n}{\frac{f_i}{i!}x^i}$，$G(x)=\sum_{i=0}^{n}{\frac{g_i}{i!}}$。
$$G(x)=F(x)G(x)+1$$
$$F(x)=1-\frac{1}{G(x)}$$
多项式求逆即可解决，时间复杂度为 $O(n\log n)$。
## Code
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=500010,MLY=998244353,g=3;
int bit,tot,rev[maxn];
inline int power(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%MLY;
		a=1ll*a*a%MLY;
		b>>=1;
	}
	return ans;
}
inline void Init(int n){
	for(bit=0;(1<<bit)<=(n<<1);++bit);tot=1<<bit;
	for(int i=1;i<tot;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
}
inline void NTT(int *a,int inv){
	for(int i=0;i<tot;++i)
		if(i<rev[i])
			swap(a[i],a[rev[i]]);
	for(int mid=1;mid<tot;mid<<=1){
		int tmp=power(g,(MLY-1)/(mid<<1));
		if(!~inv)tmp=power(tmp,MLY-2);
		for(int i=0;i<tot;i+=mid<<1)
			for(int j=0,w=1;j<mid;++j,w=1ll*w*tmp%MLY){
				int x=a[i+j],y=1ll*a[i+j+mid]*w%MLY;
				a[i+j]=(x+y)%MLY;a[i+j+mid]=(x-y+MLY)%MLY;
			}
	}
	if(!~inv){
		inv=power(tot,MLY-2);
		for(int i=0;i<tot;++i)a[i]=1ll*a[i]*inv%MLY;
	}
}
inline void PolyMul(int *F,int *G,int n,int inv=0){
	Init(n);
	static int a[maxn],b[maxn];
	for(int i=0;i<n;++i)a[i]=F[i],b[i]=G[i];
	for(int i=n;i<tot;++i)a[i]=b[i]=0;
	NTT(a,1);NTT(b,1);
	for(int i=0;i<tot;++i){
		if(inv)a[i]=b[i]*(2-1ll*a[i]*b[i]%MLY+MLY)%MLY;
		else a[i]=1ll*a[i]*b[i]%MLY;
	}
	NTT(a,-1);
	for(int i=0;i<n;++i)G[i]=a[i];
}
inline void PolyInv(int *F,int *G,int n){
	if(n==1){
		G[0]=power(F[0],MLY-2);
		return;
	}
	PolyInv(F,G,(n+1)>>1);
	PolyMul(F,G,n,1);
}
int invG[maxn],G[maxn],F[maxn],fac[maxn],invfac[maxn],n;
int main(){
	scanf("%d",&n);
	fac[0]=invfac[0]=1;
	for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%MLY;
	invfac[n]=power(fac[n],MLY-2);
	for(int i=n-1;i;--i)invfac[i]=invfac[i+1]*(i+1ll)%MLY;
	for(int i=1;i<=n;++i)G[i]=1ll*power(2,i*(i-1ll)/2%(MLY-1))*invfac[i]%MLY;G[0]=1;
	PolyInv(G,invG,n+1);
	for(int i=0;i<=n;++i)F[i]=(MLY-invG[i])%MLY;
	F[0]=(F[0]+1)%MLY;
	if(n>=1)puts("1");
	if(n>=2)puts("-1");
	for(int i=3;i<=n;++i){
		int ans=1ll*fac[i-1]*power(2,i*(i-3ll)/2%(MLY-1))%MLY*power(1ll*F[i]*fac[i]%MLY,MLY-2)%MLY;
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：gorokokoro (赞：6)

想我第一次写这题还是在恰好两年前，现在这东西应该变成 $\mathbf{EGF}$ 例题了，写一点基础教学。

![](https://i.loli.net/2020/05/27/CczxqK6M5wV7t4n.png)

显然题目的模型等价于求至少有一条 $\text{Hamilton}$ 回路的竞赛图数量。而这样的图有且只有一个强连通分量。

考虑普通竞赛图的 $\mathbf{EGF}$：

$$F(x)=\sum_{i=1}^\infty 2^{\mathrm C_i^2}\cdot\frac{x^i}{i!}$$

一个竞赛图缩点之后会变成一条链，强连通分量之间的边只可能由前面连向后面。那么令 $G(x)$ 为强连通竞赛图的 $\mathbf{EGF}$：

$$\begin{aligned}F(x)&=\sum_{i=0}^\infty G(x)^i\\&=\frac{1}{1-G(x)}\\\frac{1}{F(x)}&=1-G(x)\\G(x)&=1-\frac{1}{F(x)}\end{aligned}$$

求逆即可。

点名表扬出题人 @oscar

---

## 作者：FZzzz (赞：5)

感觉其他很多题解都没讲太清楚？我来水篇题解讲一下。

首先我们考虑求出所有竞赛图的哈密顿回路的总数。一个哈密顿回路可以用所有点的一个圆排列表示，然后不在回路上的边可以随便取方向，于是我们得到这一部分是：
$$(n-1)!2^{\frac{n(n-1)}2-n}$$

然后问题转化为求有哈密顿回路的竞赛图的数量。下一步转化就是这个就相当于求强连通竞赛图的数量，证明可以看[这篇](https://www.luogu.com.cn/blog/Ahaaaaaaaaaa/luogu-p4233-ye-ming-wan-wen-di-bi-ji)题解，这是我目前看到唯一的讲了证明的题解。

然后我们还有一个结论：一个竞赛图的强连通分量的拓扑序是唯一的。证明嘛也比较显然，竞赛图缩点后必定还是一个竞赛图，每两个点之间都有连边。

设 $f_n=2^\frac{n(n-1)}2$ 为 $n$ 个点的竞赛图数量，$g_n$ 为 $n$ 个点的强连通竞赛图数量，那么我们接下来有三条路可走：

------------
其一，将 $g$ 看作常量，对 $f$ 进行 dp，建立二者之间的关系。我们枚举一个竞赛图拓扑序最小的强连通分量的大小，则根据之前的结论，其他强连通分量与它之间的边都已唯一确定。加上整个图强连通的情况，我们得到：
$$f_n=\sum\limits_{i=1}^n\binom nif_{n-i}g_i$$
发现这是一个分治 FFT 的形式，也是一个二项卷积的形式。设 $f$，$g$ 的 EGF 分别为 $F$ 和 $G$，则我们~~根据套路显然~~有：
$$F(x)G(x)=F(x)-1\Rightarrow G(x)=1-\frac1{F(x)}$$
求逆即可。证明略，可以去分治 FFT 板子题的题解区看。

------------
其二，我们可以直接对 $g$ 进行 dp。

然后其实你会发现这个方法跟上面的方法本质相同……所以我们就不讲了（

------------
其三，我们直接根据 EGF 的多项式操作的组合意义，找出 $F$ 与 $G$ 的关系。

与前两种方法不同，我们转而枚举强连通分量的数量。我们可以把强连通分量看成盒子，而点看成球，则不难发现我们只需要确定了哪个盒子装哪个球，并且每个盒子里怎么装，就能确定这个竞赛图。由于有拓扑序，所以盒子是不同的；由于有标号，所以球是不同的。不同的球装到不同的盒子里，每个盒子内如果有一定数量的球就会对答案造成一定数量的贡献：这正是 EGF 的乘方的组合意义！所以我们可以得到：
$$F(x)=\sum\limits_{i=1}^nG(x)^i=\frac1{1-G(x)}\Rightarrow G(x)=1-\frac1{F(x)}$$
求逆即可。

------------
~~这篇题解不就是把其他几篇题解东拼西凑了一下怎么可能过审嘛。~~

---

## 作者：Hiraeth (赞：3)

题目的背景写得很优秀......

一直觉得洛谷的背景相当走心（hhhhh)

记得之前有一条题目叫有机化学之神也会作弊  （一个被有机化学折磨得痛不

欲生的蒟蒻差点笑死！）

言归正传

大概解释一下题意：求n个点的强连通图的哈密顿回路条数的期望。

一条比较水的数学题，楼上的题解已经比较详细了，在这个贴一下代码已经

自己的计算思路。（ntt)

这个期望就是所有竞赛图的 哈密顿回路数量/存在哈密顿回路的竞赛图的数

量。 

前面那个挺好做，考虑每条哈密顿回路的贡献，就是

[![P8Y3i4.png](https://s1.ax1x.com/2018/07/21/P8Y3i4.png)](https://imgchr.com/i/P8Y3i4)

那么就是要找存在哈密顿回路的竞赛图的数量。 

图的一个强连通分量一定能找到一个简单环。 

所以就是求强联通的竞赛图个数。而将一个竞赛

图强联通缩点后显然是一条链。 

考虑容斥，枚举这条链最下面的的scc的大小，于是得到式子： 

[![P8Y8JJ.png](https://s1.ax1x.com/2018/07/21/P8Y8JJ.png)](https://imgchr.com/i/P8Y8JJ)

将组合数展开，求逆即可。

代码如下

```cpp
#include<bits/stdc++.h>
 
using namespace std;

const int maxn=1000000;
const long long M=998244353;
const long long g=3;
typedef long long LL;

LL A[maxn];
LL B[maxn];

int Rev[maxn];
int N,Lg;

LL F[maxn];
LL G[maxn];

LL fac[maxn];
LL nfac[maxn];
int n;

LL Pow(LL x,LL y)
{
    if (!y) return 1LL;
    LL temp=Pow(x,y>>1);
    temp=temp*temp%M;
    if (y&1) temp=temp*x%M;
    return temp;
}

void DFT(LL *a,int f)
{
    for (int i=0; i<N; i++)
        if (i<Rev[i]) swap(a[i],a[ Rev[i] ]);

    for (int len=2; len<=N; len<<=1)
    {
        int mid=(len>>1);
        LL e=Pow(g,(M-1)/len);
        if (f==-1) e=Pow(e,M-2);

        for (LL *p=a; p!=a+N; p+=len)
        {
            LL wn=1;
            for (int i=0; i<mid; i++)
            {
                LL temp=wn*p[mid+i]%M;
                p[mid+i]=(p[i]-temp+M)%M;
                p[i]=(p[i]+temp)%M;
                wn=wn*e%M;
            }
        }
    }
}

void NTT(bool rev)
{
    for (int i=0; i<N; i++)
    {
        Rev[i]=0;
        for (int j=0; j<Lg; j++)
            if (i&(1<<j)) Rev[i]|=(1<<(Lg-j-1));
    }

    DFT(A,1);
    DFT(B,1);
    if (rev) for (int i=0; i<N; i++) A[i]=A[i]*A[i]%M;
    for (int i=0; i<N; i++) A[i]=A[i]*B[i]%M;
    DFT(A,-1);

    LL inv=Pow(N,M-2);
    for (int i=0; i<N; i++) A[i]=A[i]*inv%M;
}

void Poly_Rev(int m)
{
    if (m==1) F[0]=Pow(G[0],M-2);
    else
    {
        Poly_Rev(m>>1);

        N=2*m,Lg=0;
        while ((1<<Lg)!=N) Lg++;
        for (int i=0; i<m; i++) A[i]=F[i],B[i]=G[i];
        for (int i=m; i<N; i++) A[i]=B[i]=0;
        NTT(true);

        for (int i=0; i<m; i++) F[i]=2LL*F[i]%M,F[i]=(F[i]-A[i]+M)%M;
    }
}

int main()
{
    freopen("4233.in","r",stdin);
    freopen("4233.out","w",stdout);

    scanf("%d",&n);

    N=1;
    while (N<=n+2) N<<=1;
    fac[0]=1;
    for (LL i=1; i<N; i++) fac[i]=fac[i-1]*i%M;
    for (int i=0; i<N; i++) nfac[i]=Pow(fac[i],M-2);
    for (LL i=0; i<N; i++) G[i]=Pow(2LL, i*(i-1LL)/2LL )*nfac[i]%M;
    Poly_Rev(N);

    N=1,Lg=0;
    while (N<2*n+2) N<<=1,Lg++;
    for (int i=0; i<=n; i++) A[i]=F[i],B[i]=G[i];
    for (int i=n+1; i<N; i++) A[i]=B[i]=0;
    B[0]=0;
    NTT(false);
    for (LL i=1; i<=n; i++)
    {
        A[i]=A[i]*fac[i]%M;
        if (!A[i]) printf("-1\n");
        else
        {
            LL ans=fac[i-1]*Pow(2LL, max(i*(i-1LL)/2LL-i,0LL) )%M;
            ans=ans*Pow(A[i],M-2)%M;
            printf("%I64d\n",ans);
        }
    }

    return 0;
}
```

希望这次审核能过......


---

## 作者：wrpwrp (赞：2)

+ 考虑每一条哈密顿回路在所有竞赛图中的出现次数。
+ 发现如果确定一个环， 其他的边乱选就可以保证出现哈密顿回路。所以对于一条哈密顿回路， 出现次数为$2^{C_n^2-n}$, 减去的$n$为那$n$条边。哈密顿回路是$1-n$的一个排列首尾拼在一起， 共有$n!/n$种。于是总贡献可以直接得出。
+ 总贡献算好了， 问题转化为求有多少个存在哈密顿回路的竞赛图。
+ 显然， 存在哈密顿回路的竞赛图一定强连通， 强连通的竞赛图一定有哈密顿回路。
+ 所以问题就是求有多少个强连通的$n$个点的竞赛图。
+ 设$n$个点的强连通的竞赛图个数为$f_n$。
+ 考虑用所有图减去不是强连通的竞赛图， 可以得到:
	$$ f_n =2^{C_n^2} - \sum_{i=1}^{n - 1}f_i\times C_n^i\times 2^{C_{n - i}^2}$$
+ 这个式子的意思是枚举一个其他点无法到达的强连通图，也就是缩点之后拓扑序最小的强连通图，由于是任意的， 所以乘以组合数， 然后剩下的点数为$n - i$的图乱选。之所以可以这样是因为每个图一定会有一个最小的强连通图， 而且由于对于每个图我们只统计最小的， 所以做到不重不漏。
+ 考虑如何计算$f_i$
+ 设$g_i=2^{C_i^2}$, 有：
$$ f_n=g_n-\sum_{i=1}^{n-1}f_i\times C_n^i\times g_{n-i}$$
$$g_n=\sum_{i=1}^nf_i\times C_n^i\times g_{n-i}$$
$$\frac{g_n}{n!}=\sum_{i=1}^n\frac{f_i}{i!}\times \frac{g_{n-i}}{(n-i)!}$$
+ 设$G_n=\frac{g_n}{n!}$, $F_n=\frac{f_n}{n!}$。
+ 所以有：
  $$ G_n = \sum_{i=1}^nF_iG_{n-i}$$
+ 设$A=\sum_{i = 0}^{inf}F_ix^i$, $B=\sum_{i=0}^{inf}G_ix^i$, 然后有：
$$ A * B=\sum_{i=0}^{inf}x^i\sum_{j+k=i}F_j\times G_k = B - G_0$$
+ 这里$F_0 = 0$
+ 移项，多项式求逆就好了。
```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define R register
const int N = 4e5 + 10;
const int P = 998244353;
const int G = 3;
inline int read() {
	int x = 0, f = 1; char a = getchar();
	for(; a > '9' || a < '0'; a = getchar()) if(a == '-') f = -1;
	for(; a >= '0' && a <= '9'; a = getchar()) x = x * 10 + a - '0';
	return x * f;
}
template <typename T>
inline int qpow(int x, T k) {
	int res = 1;
	while(k) {
		if(k & 1) res = 1LL * res * x % P;
		x = 1LL * x * x % P; k >>= 1;
	} return res;
} 
struct Poly {
	int lim, rev[N];
	inline void init(int Lim) {
		lim = Lim;
		for(R int i = 0; i < lim; i ++)
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? lim >> 1 : 0);
	}
	inline void NTT(int *A, int type = 1) {
		for(R int i = 0; i < lim; i ++) if(i > rev[i]) swap(A[i], A[rev[i]]);
		for(R int dep = 1; dep < lim; dep <<= 1) {
			int Wn = qpow(type == 1 ? G : qpow(G, P - 2), (P - 1) / (dep << 1));
			for(R int j = 0, len = dep << 1; j < lim; j += len) {
				int w = 1;
				for(R int k = 0; k < dep; k ++, w = 1LL * w * Wn % P) {
					int x = A[j + k], y = 1LL * w * A[j + k + dep] % P;
					A[j + k] = (x + y) % P;
					A[j + k + dep] = (x - y + P) % P;
				}
			}
		}
		if(type == -1) {
			int inv = qpow(lim, P - 2);
			for(R int i = 0; i < lim; i ++) A[i] = 1LL * A[i] * inv % P;
		}
	}
	int C[N];
	inline void getinv(int dep, int *F, int *G) {
		if(dep == 1) {
			G[0] = qpow(F[0], P - 2); return ;
		}
		getinv((dep + 1) >> 1, F, G);
		int lim = 1;
		while(lim < (dep << 1)) lim <<= 1; init(lim);
		for(R int i = 0; i < dep; i ++) C[i] = F[i]; 
		for(R int i = dep + 1; i < lim; i ++) C[i] = 0;
		NTT(C); NTT(G);
		for(R int i = 0; i < lim; i ++) 
			G[i] = 1LL * (2 - 1LL * C[i] * G[i] % P + P) % P * G[i] % P;
		NTT(G, -1);
		for(R int i = dep; i < lim; i ++) G[i] = 0;
	}
}T;
int n;
int f[N], g[N], F[N];
int fac[N], ifac[N];
int main() {
		freopen("hamilton.in", "r", stdin);
		freopen("hamilton.out", "w", stdout);
		n = read(); fac[0] = 1;
		if(n >= 1) cout << 1 << endl;
		if(n >= 2) cout << -1 << endl;
		for(R int i = 1; i <= n; i ++) fac[i] = 1LL * fac[i - 1] * i % P;
			ifac[n] = qpow(fac[n], P - 2);
		for(R int i = n - 1; i >= 0; i --) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % P;
		for(R int i = 0; i <= n; i ++) g[i] = 1LL * qpow(2, 1LL * i * (i - 1) / 2) * ifac[i] % P;
		T.getinv(n + 1, g, F);
		for(R int i = 0; i <= n; i ++) F[i] = (P - F[i]) % P;
		for(R int i = 0; i <= n; i ++) f[i] = 1LL * F[i] * fac[i] % P;
		for(R int i = 0; i <= n; i ++) g[i] = 1LL * g[i] * fac[i] % P;
		for(R int i = 3; i <= n; i ++) 
			printf("%lld\n", 1LL * fac[i] * qpow(i, P - 2) % P * qpow(2, 1LL * i * (i - 1) / 2 - i) % P * qpow(f[i], P - 2) % P) ;
	return 0;
}

```


---

## 作者：Sym_Je (赞：2)

# P4233 射命丸文的笔记    

## 题目大意   
求 $1\to n$ 大小为 $i$ 的竞赛图中强连通的个数 。   

## $solution$    
竞赛图 ：点与点两两之间都有且只有一条有向边 。   
竞赛图的强连通图 ：显然会有一条哈密顿回路 。    
好，我们先算一下我们有多少种回路 。也就是大小为 $n$ 的竞赛图中不同哈密顿回路个数 。    
首选先因为我们的每个点都是不同的 ，所以每一个回路都是一个排列 ，呢么个数就是 $\frac{n!}{n}2^{\frac{(n)* (n-1)}{2}-n}$       
因为他是一个环所以每个会重复 $n$ 次 。其他的边的方向可以随便选 。仔细想想，当我们的环已经确定时，他其他的边随意选后不可能与之前重复，因为其他的边不可能再把组成一个环了 .      
 $Let's~go~on~!$   
我们设 $g[n]$ 为大小为 $n$ 的竞赛图的个数 $2^{\frac{n(n-1)}{2}}$ 。     
我们设 $f[n]$ 为大小为 $n$ 的竞赛图强连通的方案数 。    
我们可以发现当我们对一个竞赛图缩点后，会形成一个 $DAG$ , $DAG$ 呈链状 。 所以我们枚举他的拓扑序中的第一个联通块的大小 ，然后肯定是他向其他的所有点连边，其他的点随便连就好啦 。   

$$g[i]=\sum_{j=1}^{i}C_{i}^{j}f[j]* g[i-j]$$    
$$g[i]=\sum_{j=1}^{i}\frac{i!}{j!(i-j)!}f[j]* g[i-j]$$   

$$\frac{g[i]}{i!}=\sum_{j=1}^{i}\frac{f[j]}{j!}\frac{g[i-j]}{(i-j)!}$$

好，我们设 $g{'}[i]$ 为 $\frac{g[i]}{i!}$ ,$f{'}[i]$ 为 $\frac{f[i]}{i!}$       
$F$ 为 $f$ 的多项式， $G$ 为 $g$ 的多项式 。   
我们可以发现    
$$g{'}[i]=\sum_{j=1}^{i}f{'}[j]g{'}[i-j]$$   
因为上面是 $1\to i$ 的少了 第 $0$ 项的，所以我们得加回来 。
$$G(x)=G(x)* F(x)+g{'} _ 0$$     
$$F(x)=\frac{G(x)-g{'}_ 0}{G(x)}$$   
$$F(x)=1-\frac{g{'}_ 0}{G(x)}$$      

好，我们整理出来 $G$ 求个逆，然后按题目处理一下就好啦 。   

* $code$    

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
#define add(x,y) (x+y)%mod
#define dec(x,y) (x-y+mod)%mod
#define mul(x,y) x*y%mod
using namespace std;
const ll mod=998244353,G=3,Gi=332748118;
const ll maxn=2e6+10;
inline ll read() {
	ll data=0,f=1;char c=getchar();
	while('0'>c||c>'9') {
		if(c=='-') f=-1;c=getchar();
	} while('0'<=c&&c<='9') {
		data=data*10+c-'0';c=getchar(); 
	} return data*f; 
}
ll n;
ll poww(ll x,ll k) {
	ll ans=1;
	while(k) {
		if(k&1) ans=mul(ans,x);
		x=mul(x,x);
		k>>=1;
	}
	return ans;
}
ll X[maxn],Y[maxn],l,r[maxn],limit=1,A[maxn],B[maxn];
void NTT(ll *A,ll type,ll len) {
	limit=1,l=0;
	while(limit<=len) limit<<=1,l++;
	for(ll i=0;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(ll i=0;i<limit;++i) if(i<r[i]) swap(A[i],A[r[i]]);
	for(ll mid=1;mid<limit;mid<<=1) {
		ll Wn=poww(type==1?G:Gi,(mod-1)/(mid<<1));
		for(ll R=mid<<1,j=0;j<limit;j+=R) {
			ll w=1;
			for(ll k=0;k<mid;++k,w=mul(w,Wn)) {
				ll x=A[j+k],y=mul(w,A[j+k+mid]);
				A[j+k]=add(x,y);A[j+k+mid]=dec(x,y);
			}
		}
	}
	if(type==-1) {
		for(ll inv=poww(len<<1,mod-2),i=0;i<limit;++i) A[i]=mul(A[i],inv);
	}
}

void Inv(ll *a,ll *b,ll len) {
	if(len==1) {
		b[0]=poww(a[0],mod-2);
		return ;
	}
	Inv(a,b,len>>1);
	for(ll i=0;i<len;++i) A[i]=a[i],B[i]=b[i]; 
	NTT(A,1,len);NTT(B,1,len);
	for(int i=0;i<=limit;++i) A[i]=mul(mul(A[i],B[i]),B[i]);
	NTT(A,-1,len);
	for(int i=0;i<len;++i) b[i]=dec(mul(2,b[i]),A[i]);
}
ll jc[maxn],inv[maxn],g[maxn],f[maxn];
int main() {
	n=read();
	jc[0]=1;
	for(int i=1;i<=n;++i) jc[i]=jc[i-1]*i%mod;
	inv[n]=poww(jc[n],mod-2);
	for(int i=n;i;i--) inv[i-1]=inv[i]*i%mod;
	inv[0]=1;
	for(int i=0;i<=n;++i) g[i]=poww(2,1ll*(i-1)*i/2)*inv[i]%mod;
	ll Len;for(Len=1;Len<=n;Len<<=1);
	Inv(g,f,Len);
	for(int i=0;i<=n;++i) f[i]=(mod-f[i]);
	f[0]=(f[0]+1)%mod;
	for(int i=0;i<=n;++i) f[i]=f[i]*jc[i]%mod;
	if(n>=1) cout<<"1"<<"\n";
	if(n>=2) cout<<"-1"<<"\n";
	for(int i=3;i<=n;++i) cout<<jc[i-1]*poww(2,1ll*i*(i-3)/2)%mod*poww(f[i],mod-2)%mod<<"\n";
	return 0;
}

```



---

## 作者：zzw4257 (赞：1)

> $n$点带标号强连通**竞赛图**中哈密顿回路数量期望

期望的线性性麻烦了，直接当成平均数

对总个数考虑有$n$边已定向,其余边方案$2^{\binom{n}{2}-n}$

总的$\displaystyle \frac{n 2^{\binom{n}{2}-n}}{n!}$

考虑个数用之前计数$dp$枚举不合法点的思路

对$i$个点的强连通**竞赛图**可以强制选出$j$个点联通，剩下的点随便
$$
f_i=2^{\binom{i}{2}}-\sum\limits_{j}\binom{i}{j}f_j2^{\binom{i-j}{2}}
$$
考虑引入$g_i$表示无限制**竞赛图**个数

则
$$
f_i=g_i-\sum\limits_{j=0}^{i-1}\binom{i}{j}f_jg_{i-j}$$

$$g_i=\sum\limits_{j=0}^{i}\binom{i}{j}f_jg_{i-j}$$

强拆C,这里是一个EDF技巧可以让两边对称
$$
\begin{aligned}
g_i=\sum\limits_{j=0}^{i}i!\frac{f_j}{j!}\frac{g_{i-j}}{(i-j)!}\\
\frac{g_i}{i!}=\sum\limits_{j=0}^{i}\frac{f_j}{j!}\frac{g_{i-j}}{(i-j)!}\\
\end{aligned}
$$
然后$G=FG+1$

$G=1-\frac{1}{F}$

发现完美的替代了分治FFT

---

## 作者：Early (赞：1)

没有「分治 NTT」的题解？来一发。

## 题意

求在 $n$ 个点带标号强连通竞赛图中，哈密顿回路数量的期望。

## 思路

在 @oscar 的题解中，已经写出：

>- $n$ 个点的竞赛图中哈密顿回路的总数为 $\frac{n!}n\cdot2^{C(n,2)-n}$；
>- $n$ 个点的强连通竞赛图的数量为 $f_n=2^{C(n,2)}-\sum_{i=1}^{n-1}f_i\cdot2^{C(n-i,2)}\cdot C(n,i)$。

啊！这不是个标准的「分治 NTT」吗？

推一波式子：

$$
\begin{aligned}
f_i&=2^{C(i,2)}-\sum_{j=1}^{i-1}f_j\cdot C(i,j)\cdot2^{C(i-j,2)}\\
f_i&=2^{C(i,2)}-\sum_{j=1}^{i-1}f_j\cdot2^{C(i-j,2)}\cdot\frac{i!}{j!\cdot(i-j)!}\\
f_i&=2^{C(i,2)}-i!\cdot\sum_{j=1}^{i-1}\frac{f_j}{j!}\cdot\frac{2^{C(i-j,2)}}{(i-j)!}\\
\frac{f_i}{i!}&=\frac{2^{C(i,2)}}{i!}-\sum_{j=1}^{i-1}\frac{f_j}{j!}\cdot\frac{2^{C(i-j,2)}}{(i-j)!}
\end{aligned}
$$

设：

$$
\begin{aligned}
F(i)&=\frac{f_i}{i!}\\
G(i)&=\frac{2^{C(i,2)}}{i!}\\
H(i)&=\sum_{j=1}^{i-1}F(j)G(i-j)\\
F(i)&=G(i)-H(i)
\end{aligned}
$$

便可以愉快的「分治 NTT」了！

答案为 $\large\frac{(i-1)!\cdot2^{C(i,2)-i}}{F(i)\cdot i!}$。

时间复杂度 $O(n\log^2n)$，自己的代码最大点跑了 `430ms`。

## 代码

```cpp
#include<cstdio>
using namespace std;
const int N=1<<18,G=3,mod=998244353,invG=(mod+1)/G;
int n,fac[N],invf[N];
int rev[N],f[N],g[N],h[N];
inline void swap(int &x,int &y)
{
	x^=y^=x^=y;
	return;
}
int pow(int x,int times)
{
	int ret=1;
	while(times) {
		if(times&1) {
			ret=1ll*ret*x%mod;
		}
		times>>=1,x=1ll*x*x%mod;
	}
	return ret;
}
void init_pow()
{
	fac[0]=1;
	for(int i=1;i<=n;++i) {
		fac[i]=1ll*fac[i-1]*i%mod;
	}
	invf[n]=pow(fac[n],mod-2);
	for(int i=n;i;--i) {
		invf[i-1]=1ll*invf[i]*i%mod;
	}
	return;
}
void init(int len)
{
	for(int i=0;i<len;++i) {
		rev[i]=(rev[i>>1]>>1)|(i&1?len>>1:0);
	}
	return;
}
void ntt(int f[],int n,bool flag)
{
	for(int i=0;i<n;++i) {
		if(i<rev[i]) {
			swap(f[i],f[rev[i]]);
		}
	}
	for(int len=2,k=1;len<=n;len<<=1,k<<=1) {
		for(int i=0,uni=pow(flag?G:invG,(mod-1)/len);i<n;i+=len) {
			for(int j=i,w=1;j<i+k;++j,w=1ll*w*uni%mod) {
				int tem=1ll*w*f[j+k]%mod;
				f[j+k]=(f[j]-tem)%mod,f[j]=(f[j]+tem)%mod;
			}
		}
	}
	return;
}
void cdq(int l,int r)
{
	static int temf[N],temg[N];
	if(r-l==1) {
		f[l]=(g[l]-h[l])%mod;
		return;
	}
	int mid=(l+r)/2,siz=r-l;
	cdq(l,mid);
	int len;
	for(len=1;len<siz;len<<=1);
	init(len);
	for(int i=l;i<mid;++i) {
		temf[i-l]=f[i];
	}
	for(int i=mid-l;i<len;++i) {
		temf[i]=0;
	}
	for(int i=0;i<siz;++i) {
		temg[i]=g[i];
	}
	for(int i=siz;i<len;++i) {
		temg[i]=0;
	}
	ntt(temf,len,true),ntt(temg,len,true);
	for(int i=0;i<len;++i) {
		temf[i]=1ll*temf[i]*temg[i]%mod;
	}
	ntt(temf,len,false);
	for(int i=0,invlen=pow(len,mod-2);i<len;++i) {
		temf[i]=1ll*temf[i]*invlen%mod;
	}
	for(int i=mid;i<r;++i) {
		h[i]=(h[i]+temf[i-l])%mod;
	}
	cdq(mid,r);
	return;
}
int main()
{
	scanf("%d",&n);
	init_pow();
	for(int i=1;i<=n;++i) {
		g[i]=1ll*pow(2,1ll*i*(i-1)/2%(mod-1))*invf[i]%mod;
	}
	cdq(0,n+1);
	if(n>=1) {
		puts("1");
	}
	if(n>=2) {
		puts("-1");
	}
	for(int i=3;i<=n;++i) {
		printf("%d\n",(int)(1ll*fac[i-1]*pow(2,(1ll*i*(i-1)/2-i)%(mod-1))%mod*pow(1ll*f[i]*fac[i]%mod,mod-2)%mod+mod)%mod);
	}
	return 0;
}
```

~~顺便膜我校 @Dreamunk 大佬用「多项式求逆」切了本题。~~

---

## 作者：xuyiyang (赞：0)

### [P4233 射命丸文的笔记](https://www.luogu.com.cn/problem/P4233)
### Solution
多项式好玩！$\\$
考虑记有标号竞赛图的 GF 为 $F$，有标号强联通竞赛图的 GF 为 $G$。那么有 $[x^n]F=2^{\frac{n(n-1)}{2}}$。然后寻找 $F,G$ 的关系。注意到竞赛图缩点后是一条成链状的 DAG，而强联通竞赛图缩点后就是其中的一个点，所以 $F = \sum \limits _ {k = 0} G^k = \frac{1}{1 - G}$。其实这就是 Sequence 构造。那么有 $G=1-\frac{1}{F}$，多项式求逆即可。所以分母就做完了。分子考虑钦定哈密顿回路的形状后对于剩下的边随便定方向，那就是 $(n-1)!2^{\frac{n(n-1)}{2}-n}$。$\mathcal O(n \log n)$。
```cpp
int n, f[N];
int fc[N], ifc[N];

int main() {
	scanf("%d", &n); fc[0] = ifc[0] = 1;
	for (int i = 1; i <= n; i ++ ) {
		fc[i] = 1ll * fc[i - 1] * i % mod;
		ifc[i] = inv(fc[i]);
	}
	for (int i = 0; i <= n; i ++ ) {
		f[i] = 1ll * qmi(2, 1ll * i * (i - 1) / 2 % (mod - 1)) * ifc[i] % mod;
	} inv(f, n + 1);
	for (int i = 0; i <= n; i ++ ) f[i] = (mod - f[i]) % mod;
	(f[0] += 1) %= mod; for (int i = 0; i <= n; i ++ ) f[i] = 1ll * f[i] * fc[i] % mod;
	puts("1"); puts("-1");
	for (int i = 3; i <= n; i ++ ) {
		int cur = (1ll * i * (i - 1) / 2 - i) % (mod - 1);
		int p = 1ll * fc[i - 1] * qmi(2, cur) % mod;
		if (!f[i]) puts("-1");
		else printf("%lld\n", 1ll * p * inv(f[i]) % mod);
	} return 0;
}
```

---

## 作者：Mivik (赞：0)

[欢迎到我的博客查看](https://mivik.gitee.io/2020/solution/notes-of-syameimaru-aya/)

> 对于所有 $1\le i\le n$ 求出 $i$ 个点的有哈密顿回路的竞赛图的哈密顿回路数量的期望。
>
> $1\le n\le 100000$

（这篇题解主要就是补一下大多数题解不屑于提到的证明）

首先 $n$ 个点所有图的哈密顿回路总数可求，就是 $(n-1)!\cdot2^{\binom n2-n}$。因为哈密顿回路一共有 $(n-1)!$ 种，然后定下一个哈密顿回路其它的边随便定向即可。

我们考虑求有哈密顿回路的图的数量。首先有个定理：
$$
\text{竞赛图有哈密顿回路}\iff\text{竞赛图强联通}
$$
充分性显然，考虑证必要性。我们考虑归纳，删掉 $n$ 号点后剩下的点会形成一些极大的强联通块，并且有唯一的拓扑序，假设按这个序排出来是 $S_1,S_2,\cdots,S_k$，且 $S_i$ 的每个点都向 $S_{i+1}$ 的每个点有连边。

首先考虑 $k>1$ 的情况，那么由于整个图强联通，所以 $n$ 号点必然向 $S_1$ 中至少连了一条边，$S_k$ 中至少向 $n$ 连了一条边，又由于对于所有 $S_i$ 我们已经归纳证明了它有一条哈密顿回路，那么我们可以构造出 $n\rightarrow S_1\rightarrow S_2\rightarrow\cdots\rightarrow S_k\rightarrow n$ 的一条哈密顿回路。

然后是 $k=1$ 的情况。我们考虑到由于至少有一条 $S_1\rightarrow n$ 的边和一条 $n\rightarrow S_1$ 的边，那么设 $S_1$ 的哈密顿回路序列 $a_i$（循环），那么必定有一个 $i$ 使得存在 $a_i\rightarrow n$ 且存在 $a_{i+1}\leftarrow n$，那么这样子我们就可以构造出一条哈密顿回路。

证明完毕。现在我们就是要求 $n$ 个点的强联通竞赛图数量。我们考虑计算非强联通竞赛图的数量，发现一个非强联通竞赛图是唯一地由一个 **极大的** 强联通竞赛图和其它点任意连边构成的。写出来是：
$$
f_i=2^{\binom i2}-\sum_{j=0}^{i-1} \binom ij f_j\cdot 2^{\binom{i-j}2}
$$
然后拆一下再移项：
$$
\sum_{j=0}^i\frac{f_j}{j!}2^{\binom {i-j}2}=2^{\binom i2}
$$
然后设 $f_i$ 的 EGF $F(x)$，$G(x)=\sum_{i=0}^\infty 2^{\binom i2}x^i$，那么我们有（注意常数项）：
$$
\begin{aligned}
F(x)\cdot G(x)+1&=G(x)\\
F(x)&=\frac{G(x)-1}{G(x)}
\end{aligned}
$$
然后多项式求逆就做完了。注意 $n$ 比较小要特判。

[mivik.h](https://mivik.gitee.io/mivik.h)

[代码](https://paste.ubuntu.com/p/hYYg8KwYzj/)

---


# 玩游戏

## 题目背景

### 警告：恶意提交评测将被封号。

## 题目描述

Alice 和 Bob 又在玩游戏。

对于一次游戏，首先 Alice 获得一个长度为 $n$ 的序列 $a$，Bob 获得一个长度为 $m$ 的序列 $b$。之后他们各从自己的序列里随机取出一个数，分别设为 $a_x, b_y$，定义这次游戏的 $k$ 次价值为 $(a_x + b_y)^k$。

由于他们发现这个游戏实在是太无聊了，所以想让你帮忙计算对于 $i = 1, 2, \cdots, t$，一次游戏的 $i$ 次价值的期望是多少。

由于答案可能很大，只需要求出模 $998244353$ 下的结果即可。

## 样例 #1

### 输入

```
1 1
1
2
3```

### 输出

```
3
9
27```

## 样例 #2

### 输入

```
2 8
764074134 743107904
663532060 183287581 749169979 7678045 393887277 27071620 13482818 125504606
6```

### 输出

```
774481679
588343913
758339354
233707576
36464684
461784746```

# 题解

## 作者：Jacob233 (赞：33)

前置技能：NTT，多项式求逆，多项式对数函数，多项式求导。

首先我们按题意写出答案的式子：$$ans_k=\frac{\sum_{i = 1}^n\sum_{j = 1}^m(a_i+b_j)^k}{nm}$$

先不管分母，把分子用二项式定理展开：

$$ans_k=\sum_{r = 0}^k\sum_{i = 1}^n\sum_{j = 1}^m\binom r ka_i^rb_j^{k-r}$$

$$ans_k=k!\times\sum_{r = 0}^k(\sum_{i = 1}^n\frac{a_i^r}{r!})(\sum_j^m\frac{b_j^{k-r}}{(k-r)!})$$

这样子就写成了卷积的形式，那么我们只要能快速求出$\sum_{k=1}^na^k$，就可以用NTT计算卷积了。

我们写出这个东西的生成函数：$$1+a^1x+a^2x^2+...+a^\infty x^\infty$$

$x^k$的系数表示$k$次幂和，那么我们用等比数列求和公式解出来可以得到：$$\frac{1}{1-ax}$$

令$f(x)$为这些生成函数的和，那么：
$$f(x) = \sum_{i = 1}^n\frac{1}{1-a_ix}$$

这个东西不好算，我们发现$$\ln'(1-a_ix)=\displaystyle\frac{1}{1-a_ix}$$

我们从对数函数角度考虑，又可以发现：
$$(\ln(1-a_ix))'=\frac{-a_i}{1-a_ix}$$
设$g(x)=\displaystyle\sum_{i = 1}^n\displaystyle\frac{-a_i}{1-a_ix}$，那么$f(x)=-x\times g(x)+n$

$g(x)$也很好算，化一下式子就变成了：

$$g(x)=\sum_{i = 1}^n(\ln(1-a_ix))'$$
$$=(\ln(\prod_{i = 1}^n(1-a_ix)))'$$

这样子$g$就可以用分治+NTT算，算出$g$后再推出$f$，$f$中$x_i$的系数就是$\displaystyle\sum_{j = 1}^na_j^i$，那么我们代回原式再做一遍卷积就好了，总的复杂度为$O(n\log^2n)$。

贴一下代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1 << 19 | 1; 
const int M = log2(N) + 3; 
const int mod = 998244353;

int n, m, t, cnt = -1, tp[M << 1][N];
int a[N], b[N], ans[N], Sa[N], Sb[N];
int rev[N], A[N], B[N], fac[N], ifac[N];

inline int inv(int x) { return 1ll * ifac[x] * fac[x - 1] % mod; }
inline int add(int x, int y) { return (x += y) < mod ? x : x - mod; }

inline int qpow(int _, int __) {
	int ___ = 1; 
	for (; __; _ = 1ll * _ * _ % mod, __ >>= 1) 
		if (__ & 1) ___ = 1ll * ___ * _ % mod;
	return ___;
}

inline void Math_Init(int n) {
	fac[0] = ifac[0] = 1; 
	for (int i = 1; i <= n; ++ i) 
		fac[i] = 1ll * fac[i - 1] * i % mod;
	ifac[n] = qpow(fac[n], mod - 2);
	for (int i = n; i; -- i) 
		ifac[i - 1] = 1ll * ifac[i] * i % mod;
}

inline void NTT(int *a, int n, int fh) {
	for (int i = 0; i < n; ++ i) 
		if (i < rev[i]) swap(a[i], a[rev[i]]);;
	for (int Wn, limit = 2; limit <= n; limit <<= 1) {
		Wn = qpow(fh ^ 1 ? qpow(3, mod - 2) : 3, (mod - 1) / limit);
		for (int W = 1, j = 0; j < n; j += limit, W = 1) 
			for (int i = j; i < j + (limit >> 1); ++ i, W = 1ll * W * Wn % mod) {
				int a1 = a[i], a2 = 1ll * W * a[i + (limit >> 1)] % mod;
				a[i] = add(a1, a2), a[i + (limit >> 1)] = add(a1, mod - a2);
			}
	}
	if (fh ^ 1) for (int i = 0; i < n; ++ i) 
		a[i] = 1ll * a[i] * inv(n) % mod;
}

inline void Invpoly(int *a, int *b, int len) {
	int limit = 1, k = 0;
	if (len ^ 1) {
		Invpoly(a, b, len >> 1);
		while (limit < len * 2) limit <<= 1, ++ k;
		for (int i = 0; i < limit; ++ i) {
			A[i] = B[i] = 0;
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));
		}
		for (int i = 0; i < len; ++ i) 
			A[i] = a[i], B[i] = b[i];
		NTT(A, limit, 1), NTT(B, limit, 1);
		for (int i = 0; i < limit; ++ i) 
			A[i] = 1ll * A[i] * B[i] % mod * B[i] % mod;
		NTT(A, limit, -1);
		for (int i = 0; i < len; ++ i) 
			b[i] = add(b[i], add(b[i], mod - A[i]));
	}	
	else b[0] = qpow(a[0], mod - 2);
}

inline void Derpoly(int *a, int len) {
	for (int i = 0; i < len - 1; ++ i) 
		a[i] = 1ll * (i + 1) * a[i + 1] % mod;
	a[len - 1] = 0;
}

inline void Solve(int l, int r, int *a, int *b) {
	if (l == r) return (void) (a[0] = 1, a[1] = mod - b[l]); 
	int mid = (l + r) >> 1, *a1 = tp[++ cnt], *a2 = tp[++ cnt], limit = 1, k = 0; 
	Solve(l, mid, a1, b), Solve(mid + 1, r, a2, b);
	while (limit <= r - l + 1) limit <<= 1, ++ k;
	for (int i = 0; i < limit; ++ i) 
		rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));
	NTT(a1, limit, 1), NTT(a2, limit, 1);
	for (int i = 0; i < limit; ++ i) 
		a[i] = 1ll * a1[i] * a2[i] % mod, a1[i] = a2[i] = 0;
	NTT(a, limit, -1), cnt -= 2;
}

inline void Get_S(int *a, int *f, int n) {
	int invf[N] = {0}, limit = 1, k = 0;
	while (limit < max(n, t) * 2) limit <<= 1, ++ k;
	Solve(1, n, f, a), Invpoly(f, invf, limit >> 1), Derpoly(f, limit);
	for (int i = 0; i < limit; ++ i) 
		rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));
	NTT(f, limit, 1), NTT(invf, limit, 1);
	for (int i = 0; i < limit; ++ i) 
		f[i] = 1ll * f[i] * invf[i] % mod;
	NTT(f, limit, -1);
	for (int i = limit - 2; ~i; -- i) 
		f[i + 1] = 1ll * f[i] * (mod - 1) % mod;
	f[0] = n;
	for (int i = 0; i < limit; ++ i) {
		if (i > t) f[i] = 0;
		f[i] = 1ll * f[i] * ifac[i] % mod;
	}
}

int main() {
	int limit = 1, k = 0;

	Math_Init(N - 5), scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++ i) scanf("%d", &a[i]);
	for (int i = 1; i <= m; ++ i) scanf("%d", &b[i]);
	scanf("%d", &t), Get_S(a, Sa, n), Get_S(b, Sb, m);

	while (limit <= t * 2) limit <<= 1, ++ k;
	for (int i = 0; i < limit; ++ i) 
		rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));
	NTT(Sa, limit, 1), NTT(Sb, limit, 1);
	for (int i = 0; i < limit; ++ i) 
		Sa[i] = 1ll * Sa[i] * Sb[i] % mod;
	NTT(Sa, limit, -1);

	for (int i = 1; i <= t; ++ i) 
		printf("%lld\n", 1ll * Sa[i] * fac[i] % mod * inv(n) % mod * inv(m) % mod);

	return 0;
}

```

---

## 作者：NaCly_Fish (赞：23)

这个题的式子都推了好久，感觉自己水平越来越低了，，
****
很容易得出这样暴力计算的一个式子，最后除一个 $nm$ 就是期望值。

$$c_k=\sum_{i=1}^n\sum_{j=1}^m(a_i+b_j)^k$$
$$c_k=\sum_{i=1}^n\sum_{i=1}^m\sum_{r=0}^k\binom{k}{r}a_i^rb_j^{k-r}$$
交换一下求和顺序就有
$$c_k=k!\sum_{r=0}^k\sum_{i=1}^n\frac{a_i^r}{r!}\sum_{j=1}^m\frac{b_j^{k-r}}{(k-r)!}$$
后面两个和式可以将其看为两部分的乘积
$$c_k=k!\sum_{r=0}^k\left( \frac{1}{r!}\sum_{i=1}^na_i^r\right)\left( \frac{1}{(k-r)!}\sum_{j=1}^mb_j^{k-r}\right)$$
这样就是一个卷积的形式，设
$$A(x)=\sum_{r=0}^\infty x^r\sum_{i=1}^na_i^r \quad B(x)=\sum_{r=0}^\infty x^r\sum_{i=1}^mb_i^r$$
把它们变成 EGF，乘起来就是 $\{c_k\}_{k=0}^\infty$ 的 EGF。  
考虑快速计算 $A(x)$，另一个也是一样的做法。

$$A(x)=\sum_{i=1}^n\sum_{r=0}^\infty a_i^rx^r=\sum_{i=1}^n\frac{1}{1-a_ix}$$
直接加是没法计算的（真的吗？），可以用这样一个取 $\ln$ 的套路（就是这里我想了好久）
$$A(x)=n-x\sum_{i=1}^n\frac{-a_i}{1-a_ix}=n-x\sum_{i=1}^n\ln(1-a_ix)'$$
因为导数之和等于和的导数，再把 $\ln$ 移到外面去，式子就能化成这样
$$A(x)=n-x\left( \ln\prod_{i=1}^n(1-a_ix)\right)'$$
分治乘 + 多项式 $\ln$ 即可，时间复杂度 $\Theta(n \log^2 n)$。

如果想不到上面的多项式 $\ln$ 做法，也可以这样暴力计算分式：
$$\frac{A(x)}{B(x)}+\frac{C(x)}{D(x)}=\frac{A(x)D(x)+B(x)C(x)}{B(x)D(x)}$$
合并两项需要六次 dft，常数大了一倍，但是好想了很多。  

```cpp
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define N 262147
#define ll long long
#define p 998244353
#define reg register
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

int rev[N],rt[N],inv[N],fac[N],ifac[N];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = power(3,(p-1)>>siz);
    fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = rt[lim>>1] = 1;
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i){
        inv[i] = (ll)(p-p/i)*inv[p%i]%p;
        fac[i] = (ll)fac[i-1]*i%p;
        ifac[i] = (ll)ifac[i-1]*inv[i]%p;
    }
}

inline void NTT(int *f,int type,int lim){
    if(type==-1) reverse(f+1,f+lim);
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;
    if(type==1) return;
    x = p-(p-1)/lim;
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline void inverse(const int *f,int n,int *R){
    static int g[N],h[N],s[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        NTT(g,1,lim),NTT(h,1,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        NTT(g,-1,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void log(int *f,int n){
    static int g[N];
    int lim = getlen(n<<1);
    inverse(f,n,g);
    memset(g+n+1,0,(lim-n)<<2);
    for(reg int i=0;i<=n;++i) f[i] = (ll)f[i+1]*(i+1)%p;
    NTT(f,1,lim),NTT(g,1,lim);
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
    NTT(f,-1,lim);
    memset(f+n+1,0,(lim-n)<<2);
    for(reg int i=n;i;--i) f[i] = (ll)f[i-1]*inv[i]%p;
    f[0] = 0;
}

#define mid ((l+r)>>1)
#define ls (u<<1)
#define rs (u<<1|1)
int len[N];

void solve(int l,int r,int u,const int *a,int *R){
    len[u] = r-l+1;
    if(l==r){
        R[0] = 1,R[1] = p-a[l];
        return;
    }
    int f[N],g[N];
    solve(l,mid,ls,a,f);
    solve(mid+1,r,rs,a,g);
    int lim = getlen(len[u]);
    memset(f+len[ls]+1,0,(lim-len[ls]+2)<<2);
    memset(g+len[rs]+1,0,(lim-len[rs]+2)<<2);
    NTT(f,1,lim),NTT(g,1,lim);
    for(reg int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
    NTT(f,-1,lim);
    memcpy(R,f,(len[u]+1)<<2);
}
#undef ls
#undef rs
#undef mid

int n,m,k,t;
int a[N],b[N],F[N],G[N];

int main(){
    read(n),read(m);
    init(200000);
    for(reg int i=1;i<=n;++i) read(a[i]);
    for(reg int i=1;i<=m;++i) read(b[i]);
    read(k);
    t = k,k = max(max(k,n),m);
    solve(1,n,1,a,F);
    solve(1,m,1,b,G);
    log(F,k+1),log(G,k+1);
    for(reg int i=0;i<=k;++i){
        F[i] = (ll)F[i+1]*(i+1)%p;
        G[i] = (ll)G[i+1]*(i+1)%p;
    }
    F[k+1] = G[k+1] = 0;
    for(reg int i=k;i;--i){
        F[i] = p-F[i-1];
        G[i] = p-G[i-1];
    }
    F[0] = n,G[0] = m;
    for(reg int i=2;i<=k;++i){
        F[i] = (ll)F[i]*ifac[i]%p;
        G[i] = (ll)G[i]*ifac[i]%p;
    }
    int lim = getlen(k<<1);
    NTT(F,1,lim),NTT(G,1,lim);
    for(reg int i=0;i!=lim;++i) F[i] = (ll)F[i]*G[i]%p;
    NTT(F,-1,lim);
    int tmp = power((ll)n*m%p,p-2);
    for(reg int i=0;i<=k;++i) F[i] = (ll)F[i]*fac[i]%p*tmp%p;
    for(reg int i=1;i<=t;++i) print(F[i]),putchar('\n');
    return 0;	
}
```

---

## 作者：WinXP (赞：17)

基础前置技能

1.基础数学  
2.NTT(FFT)  
3.多项式求逆  
4\*.Taylor展开


设 $ans_k$，为

$$ans_k=\sum_{i=1}^n \sum_{j=1}^m (a_i+b_j)^k$$

设 $Ans(x)$ 为 $ans$ 的生成函数

答案即为求多项式 $Ans(x) * \frac{1}{nm}$ 

然后....首先这个式子....

$$ans_k= \sum_{i=1}^n \sum_{j=1}^m (a_i+b_j)^k$$

考虑二项式展开

$$ans_k= \sum_{i=1}^n \sum_{j=1}^m \sum_{t=0}^k C_k^t a_i^{k-t} b_j^t$$

考虑交换求和顺序，把 $k$ 提到前面

$$ans_k= \sum_{t=0}^k \sum_{i=1}^n \sum_{j=1}^m C_k^t a_i^{k-t} b_j^t$$


$$ans_k= \sum_{t=0}^k C_k^t \sum_{i=1}^n a_i^{k-t}\sum_{j=1}^m b_j^t$$

可以发现，如果计两个新的多项式为 $A(x),B(x)$，令

$$A(x)=\sum_{i=1}^n a_i^x$$
$$B(x)=\sum_{i=1}^m b_i^x$$

就可以得到一个很优美的化简:

$$ans_k= \sum_{t=0}^k C_k^t\ A(k-t)\ B(t)$$

组合数直接拆出来

$$ans_k= \sum_{t=0}^k \frac{k!}{t!(k-t)!}\ A(k-t)\ B(t)$$

$$=k! \sum_{t=0}^k \frac{A(k-t)}{(k-t)!}\ \frac{B(t)}{t!}$$

非常好。现在的问题变成了$A(x)=\sum_{i=1}^n a_i^x$这个看起来非常不友好的多项式怎么求。~~(说实话不会的话真的是没法想出来的...)(Drench说是非常经典的问题)~~

先考虑一个多项式，即为$F(x)$，为

$$F(x)=\prod_{i=1}^n(a_ix+1)$$

这个东西可以分治求出来。具体一点大概就是...

$$F_l(x)=\prod_{i=1}^{(n/2)}\ (a_ix+1)$$
$$F_r(x)=\prod_{i=(n/2)+1}^{n}(a_ix+1)$$
$$F(x)=F_l(x)F_r(x)$$

求出这个东西之后，再对这个东西取$ln$....

$$ln(F(x))=G(x)$$

这是个多项式求$ln$，具体来说...

$$(ln(x))'=\frac{1}{x}$$

链式法则：如果

$$h(x)=f(g(x))$$

那么就会有

$$h'(x)=f'(g(x))g'(x)$$

这里的$ln(x)$就相当于$f(x)$

因为$G(x)=f(F(x))$
$$G'(x)=f'(F(x))F'(x)=\frac{F'(x)}{F(x)}$$

可能需要反应一下  

然后，

$$G(x)=\int \frac{F'(x)}{F(x)}$$

至于多项式的求导和积分，其实非常简单，求导的时候$a_{i}=(i+1)a^{(i+1)},$ 积分的时候$a_i=inv(i)a_{i-1}$。关键是求出$\frac{1}{F(x)}$是一个多项式求逆的过程。[P4238 【模板】多项式求逆](https://www.luogu.org/problemnew/show/P4238)

这么费劲求出 $G(x)$ 干嘛呢？

......

泰勒($taylor$)展开：

首先约定用$f^{(n)}(x)$表示$f(x)$的$n$阶导数。

若函数 $f(x)$ 在包含 $x0$ 的某个闭区间 $[a,b]$ 上具有 $n$ 阶导数，且在开区间 $(a,b)$ 上具有 $(n+1)$ 阶导数，则对闭区间 $[a,b]$ 上任意一点 $x$ ，成立下式：

![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D561/sign=143f6442fadeb48fff69a1d8c11e3aef/a686c9177f3e670920f8bbdc32c79f3df8dc551d.jpg)

上面是百度百科抄的~~(顺手引用了图片。)~~。

用非常不准确的人话来说，就是有一个函数$f(x)$，这个函数随便是什么$log,sin,cos$，只要这个$f(x)$可在任意点导任意次，我们就可以用一个非常奇怪的无穷项的多项式$g(x)$从某一个点$x_0$来拟合这样的一个函数。$g(x)$的每一项$a_i$为：

$$\frac{f^{(n)}(x_0)}{n!}$$

合起来就是

$$f(x)=\sum_{k=1}^{+\infty} \frac{f^{(k)}(x_0)}{k!}(x-x_0)^k$$

这个东西的大致思路就是让$g(x_0)=f(x_0)$，让$g'(x_0)=f'(x_0)$，让$g''(x_0)=f''(x_0)$，直到让$g^{(+\infty)}(x_0)=f^{(+\infty)}(x_0)$，这两个函数就可以说一样了。满足这个条件的$g(x)$写出来就是泰勒展开。当然没有这么简单，关于taylor展开知乎上有讲的非常好的，如果想学建议自己去看一看。

回到这个东西 $F(x)=\prod_{i=1}^n(a_ix+1)$ 。用分治NTT计算出 $F(x)$ 之后再对它多项式求$ln$得到 $G(x)$ :

$$G(x)=ln(\ \ \prod_{i=1}^n(a_ix+1)\ \ )$$

非常明显的化简  

$$G(x)=\sum_{i=1}^nln(a_ix+1)$$

然后我们考虑把里面的这个函数 $ln(x)$ 在 $1$ 这个点进行Taylor展开。

原始的公式

$$f(x)=\sum_{k=1}^{+\infty} \frac{f^{(k)}(x_0)}{k!}(x-x_0)^k$$

$ln(x)$求导的通项公式
$$(ln(x))'=x^{-1}\ \ \ \ \ \ \ (x^a)'=(a-1)x^{a-1}$$

$$(ln(x))^{(n)}=(-1)^{(n+1)}n!x^{-n}$$

带入
$$ln(a_ix+1)=\sum_{k=1}^{+\infty} \frac{(-1)^{(k+1)}(k-1)!}{k!}(a_ix)^k$$

$$ln(a_ix+1)=\sum_{k=1}^{+\infty} \frac{(-1)^{(k+1)}}{k}a_i^kx^k$$

因为在求$G(x)$的时候用到了多项式求逆，对$x^{K+1}$取模后，这个式子中大于$K$次的项没有意义.  

对于单独的一项

$$ln(a_ix+1)=\sum_{k=1}^{K} \frac{(-1)^{(k+1)}}{k}a_i^kx^k$$

所以

$$G(x)=\sum_{i=1}^nln(a_ix+1)=\sum_{i=1}^n\sum_{k=1}^{K} \frac{(-1)^{(k+1)}}{k}a_i^kx^k$$

为了表达的清楚一点随便找一个$t$把$t(k)$记为$\frac{(-1)^{(k+1)}}{k}$

$$G(x)=\sum_{i=1}^nln(a_ix+1)=\sum_{i=1}^n\sum_{k=1}^{K} t(k)a_i^kx^k$$

显然可以交换一下顺序

$$G(x)=\sum_{k=1}^{K} t(k)\sum_{i=1}^na_i^kx^k$$

$$G(x)=\sum_{k=1}^{K} t(k)A(k)x^k$$

哇！

然后我的代码写的巨型丑，常数莫名巨型大，卡了一次才A,仅供对拍...

```cpp
#include <bits/stdc++.h>
#define rap(i,s,n) for(int i=s;i<=n;i++)
#define drap(i,n,s) for(int i=n;i>=s;i--)
#define N 410000
#define P 998244353
#define lb(x) ((x&(-x)))
#define ll long long
#define m(s,k) memset(s,k,sizeof s)
using namespace std;
char xB[1<<15],*xS=xB,*xTT=xB;
#define getc() (xS==xTT&&(xTT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xTT)?0:*xS++)
#define isd(c) ((c>='0'&&c<='9')||(c=='-'))
template<typename T>
inline bool rd(T& xa){
    char xchh; T f=1; while(xchh=getc(),(!isd(xchh))&&(xchh!=0));
    if(xchh==0) return 0; if(xchh=='-') xchh=getc(),f=-1; xa=xchh-'0';
    while(xchh=getc(),isd(xchh)) xa=xa*10+xchh-'0'; xa*=f; return 1;
}
ll mpow(ll a,ll k,ll p){ll res=1; while(k){if(k&1) res=res*a%p; k>>=1; a=a*a%p;} return res%p;}
ll Inv(ll x){return mpow(x,P-2,P);}
ll fac[N],inv[N],finv[N];
void Finit(int n){
    fac[0]=1; rap(i,1,n) fac[i]=fac[i-1]*i%P;
    inv[1]=1; rap(i,2,n) inv[i]=inv[P%i]*(P-P/i)%P;
    finv[0]=1; rap(i,1,n) finv[i]=finv[i-1]*inv[i]%P;
}
namespace Poly{
    ll c[N],f[N],f1[N],fi[N];
    int rev[N],lim,l;
    void init(int n){
        lim=1,l=0; while(lim<=n) lim<<=1,l++;
        rap(i,1,lim-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
    }
    void NTT(ll *A,int k){
        rap(i,1,lim-1) if(i<rev[i]) swap(A[i],A[rev[i]]); for(int l=1;l<lim;l<<=1){
            ll gn=mpow(3,(P-1)+k*(P-1)/l/2,P); for(int j=0;j<lim;j+=l*2){
                ll g=1; for(int k=0;k<l;k++,g=g*gn%P){
                    ll x=A[k+j],y=A[k+j+l]*g%P;
                    A[k+j]=(x+y)%P; A[k+j+l]=(x-y+P)%P;
                }
            }
        }
        if(k==-1) {ll tinv=Inv(lim); rap(i,0,lim-1) A[i]=A[i]*tinv%P;}
    }
    void MUL(ll *A,int n,ll *B,int m,ll *C){
        init(n+m); NTT(A,1); NTT(B,1); rap(i,0,lim-1) C[i]=A[i]*B[i]%P; NTT(A,-1); NTT(B,-1); NTT(C,-1);
    }
    void MUL(ll *A,int n,ll *B,int m){
        init(n+m); NTT(A,1); NTT(B,1); rap(i,0,lim-1) B[i]=B[i]*A[i]%P; NTT(A,-1); NTT(B,-1);
    }
    void INV(ll *A,ll *B,int n){
        if(n==1){B[0]=Inv(A[0]); return;} INV(A,B,(n+1)>>1);
        init(2*n); m(c,0); rap(i,0,n-1) c[i]=A[i]; NTT(c,1); NTT(B,1);
        rap(i,0,lim-1) B[i]=(2-B[i]*c[i]+P)%P*B[i]%P;
        NTT(B,-1); rap(i,n,lim-1) B[i]=0; return;
    }
    void MUL(ll *A,int *a,int n){
        int len=1; while(len<n) len<<=1; ll *f[N];
        rap(i,1,len){f[i]=new ll[lb(i)<<2]; f[i][0]=1; f[i][1]=a[i];}
        for(int l=1;l<len;l<<=1){init(2*l); for(int j=l*2;j<=len;j+=l*2){
            NTT(f[j-l],1); NTT(f[j],1);
            rap(i,0,lim-1) f[j][i]=f[j][i]*f[j-l][i]%P; NTT(f[j],-1);
        }}
        rap(i,0,n) A[i]=f[len][i];
        return;
    }
    void DEAL(ll *A,int *a,int n,int k){
        m(f,0); MUL(f,a,n); m(f1,0); rap(i,0,n-1) f1[i]=f[i+1]*(i+1)%P;
        m(fi,0); INV(f,fi,k+1); MUL(f1,n-1,fi,k,A); drap(i,k,1) A[i]=A[i-1]*inv[i]%P;
        rap(i,k+1,lim-1) A[i]=0;
        rap(i,1,k){A[i]=A[i]*i%P; if((i&1)==0) A[i]=P-A[i];}
    }
}
int n,m,K,a[N],b[N];
ll A[N],B[N],ans[N];
int main(){
    rd(n); rd(m); rap(i,1,n) rd(a[i]); rap(i,1,m) rd(b[i]); rd(K);
    Finit(max(max(n,m),K)+100);
    Poly::DEAL(A,a,n,K); Poly::DEAL(B,b,m,K);
    rap(i,1,K) A[i]=A[i]*finv[i]%P,B[i]=B[i]*finv[i]%P;
    A[0]=n; B[0]=m; Poly::MUL(A,K,B,K,ans);
    ll tinv=Inv(1ll*n*m%P); rap(i,1,K) ans[i]=ans[i]*fac[i]%P*tinv%P;
    rap(i,1,K) printf("%lld\n",ans[i]);
    return 0;
}

```

---

## 作者：totorato (赞：12)

# 更简单的算法和更快的NTT

### 期望的线性性

设$a,b$是两个**不相关**的随机变量，$E(x)$为$x$的期望取值，则：
$$E(a\cdot b)=E(a)\cdot E(b)$$
证明：

如果$a,b$的取值是离散的（比如题目中的$a,b$，只能从给定的有限个数中选择），那么可以设$P_a(x)$为$a$取到$x$的概率

则我们要求的$E(a\cdot b)=\sum_{\forall x,y}{P_a(x)P_b(y)}$

又因为$E(a)\cdot E(b)=\sum_{\forall x} P_a(x)\sum_{\forall y} P_b(y)$

将下面的式子的$P_a(x)$乘进后面的$\sum$即可发现两个式子是相等的。

但是，要注意，如果$a,b$是相关的，那么上述性质就不再适用了。

### 整数$k$次幂和

对于一个数列，如果我们要求：对于所有的$t\in [0,k]$，$A_i^t$的和，怎么做呢？

对于这个问题，我们有一个$O(nlog^2n)$的做法。

写出这个和关于$t$的生成函数(函数中$x^c$系数是$c$次幂和)
$$1+a_1^1x+a_1^2x^2+a_1^3x^3+\cdots+$$

$$1+a_2^1x+a_2^2x^2+a_2^3x^3+\cdots+$$

$$\cdots $$

根据等比数列求和公式(在生成函数中的推广)，我们可以知道，上面的式子实际上是：
$$\frac{1}{1-a_1x}+\frac{1}{1-a_2x}+\cdots+\frac{1}{1-a_nx}$$
如果我们暴力从左往右合并这个式子，时间复杂度是：$O(n^2)$的，因为每进行一次通分，分子最高项次数必然增加。

如果逐层合并这个式子，时间复杂度可以变成$O(nlog^2n)$。逐层的意思，即每一层合并所有相邻的分式，且不重复合并。复杂度证明同分治FFT。

### 题目分析

首先，由于我们要求$(x+y)^t$的期望，根据第一个前置知识，我们就可以先将这个式子展开
$$E(x+y)^t=\sum_{i=0}^tC_t^iE(x^i)E(y^{t-i})$$
所以，我有种预感，就是为了求对于所有$t$ 的答案，我们只要分别求出对于所有的$t$，$x^t$的期望和$y^t$的期望，就可以用卷积的方式快速求出$(x+y)^t$的期望。

实际上，的确是这样的：
$$F(t)=\sum_{i=0}^tC_t^iA(i)B(t-i)$$
$$F(t)=\sum_{i=0}^t\frac{t!}{i!(t-i)!}A(i)B(t-i)$$
$$\frac{1}{t!}F(t)=\sum_{i=0}^t\frac{1}{i!}A(i)\cdot\frac{1}{t-i}B(t-i)$$
这是一个卷积的形式，被卷积的两函数分别是$\frac{1}{i!}A(i)$和$\frac{1}{t-i}B(t-i)$

所以下面的任务就是求$A(i),B(i)$，也就是$a,b$的$i$次幂期望。这个期望就是$i$次幂和除以项数，用第二个前置知识解决即可，总复杂度$O(nlog^2n)$。实际上，这个方法大概有2倍于本题另一种方法的常数，因此需要在NTT的效率上做优化才可以AC。

### 更快的NTT

考虑到一般的NTT都略慢于FFT，优化NTT的常数以加速计算势在必行。

本题中由于需要进行分治FFT，NTT执行次数将非常多，所以优化的主要方法有两个：

- 1.将一切可以预处理的东西预处理
- 2.将一切可以省略的取模省略

经过我比较彻底的常数优化后，成了这样：

```cpp
void dft(int f)
{
    for(int i=0;i<len;i++)if(i<rev[i])swap(x[i],x[rev[i]]);
    for(int w=1,b=1;w<len;w<<=1,b++)
    {
        ll *wx=(f==1?wi[b]:wii[b]);		//wi和wii为原根的幂及幂的逆
        for(int j=0;j<len;j+=(w<<1))
        {
            for(int i=j;i<j+w;i++)
            {
                ll a=x[i],b=wx[i-j]*x[i+w];
                x[i]=(a+b)%MOD;
                x[i+w]=(a-b+MOD*MOD)%MOD;
            }
        }
    }
    if(f==-1)
    {
        ll mul=ksm(len,MOD-2);
        for(int i=0;i<len;i++)x[i]=x[i]*mul%MOD;
    }
}
```

在洛谷"【模板】多项式乘法"中，效率提升20%

在洛谷"玩游戏"中，效率提升48%

### 代码
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC target("sse3","sse2","sse")
#pragma GCC target("avx","sse4","sse4.1","sse4.2","ssse3")
#pragma GCC target("f16c")
#pragma GCC optimize("inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC diagnostic error "-fwhole-program"
#pragma GCC diagnostic error "-fcse-skip-blocks"
#pragma GCC diagnostic error "-funsafe-loop-optimizations"
#pragma GCC diagnostic error "-std=c++14"

#include <cstdlib>
#include <iostream>
#include <cstring>
#include <cstdio>
#define MX (524288+10)
#define MOD 998244353LL
#define G 3

using namespace std;

typedef long long ll;

int len,bit,rev[MX];
int n1,n2,m,A[MX],B[MX];
ll fac[MX];
ll EA[MX],EB[MX];
ll gp[MX],gpi[MX],wi[22][MX],wii[22][MX];

ll read()
{
	ll x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return x;
}

void qm(ll& x){x%=MOD;if(x<0)x+=MOD;}

void init(int l)
{
	len=1,bit=0,rev[0]=0;
	while(len<l)len<<=1,bit++;
	for(int i=1;i<len;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
}

ll ksm(ll x,ll t)
{
	ll ans=1;
	while(t)
	{
		if(t&1)ans=ans*x%MOD;
		x=x*x%MOD;
		t>>=1;
	}
	return ans;
}

ll inv(ll x){return ksm(x,MOD-2);}

struct poly
{
	ll *x;
	void resize(){delete x;x=new ll[len];memset(x,0,len*sizeof(ll));}
	void reset(){memset(x,0,len*sizeof(ll));}
	void input(int s){for(int i=0;i<s;i++)scanf("%lld",&x[i]),qm(x[i]);}
	void output(int s){for(int i=0;i<s;i++)printf("%lld ",x[i]);putchar('\n');}
	void dft(int f)
	{
		for(int i=0;i<len;i++)if(i<rev[i])swap(x[i],x[rev[i]]);
		for(int w=1,b=1;w<len;w<<=1,b++)
		{
			ll *wx=(f==1?wi[b]:wii[b]);
			for(int j=0;j<len;j+=(w<<1))
			{
				for(int i=j;i<j+w;i++)
				{
					ll a=x[i],b=wx[i-j]*x[i+w];
					x[i]=(a+b)%MOD;
					x[i+w]=(a-b+MOD*MOD)%MOD;
				}
			}
		}
		if(f==-1)
		{
			ll mul=ksm(len,MOD-2);
			for(int i=0;i<len;i++)x[i]=x[i]*mul%MOD;
		}
	}
};

poly up[MX],dn[MX];
poly dl,ul,dr,ur,dv,f1,f2;
poly tmp;

void get_inv(poly &a,poly &b,int nx)
{
	if(nx==1)b.x[0]=inv(a.x[0]);
	else
	{
		get_inv(a,b,nx>>1);
		for(int i=0;i<nx;i++)tmp.x[i]=a.x[i],tmp.x[i+nx]=0;
		init(nx<<1);
		tmp.dft(1);
		b.dft(1);
		for(int i=0;i<len;i++)
			tmp.x[i]=(b.x[i]*2-tmp.x[i]*b.x[i]%MOD*b.x[i]%MOD+MOD)%MOD;
		tmp.dft(-1);
		for(int i=0;i<nx;i++)b.x[i]=tmp.x[i],b.x[i+nx]=0;
	}
}

void work(int *val,ll *tar,int sz,int ori)
{
	init(2);
	for(int i=0;i<sz;i++)
	{
		up[i].resize();
		dn[i].resize();
		if(i<ori)up[i].x[0]=1;
		dn[i].x[0]=1;
		dn[i].x[1]=-val[i],qm(dn[i].x[1]);
	}
	for(int i=1;i<sz;i<<=1)
	{
		init(min(i<<2,sz<<1));
		dl.resize();
		dr.resize();
		ul.resize();
		ur.resize();
		for(int j=0;j+i<sz;j+=(i<<1))
		{
			dl.reset();
			dr.reset();
			ul.reset();
			ur.reset();
			for(int k=0;k<(len>>1);k++)dl.x[k]=dn[j].x[k];
			for(int k=0;k<(len>>1);k++)dr.x[k]=dn[j+i].x[k];
			for(int k=0;k<(len>>1);k++)ul.x[k]=up[j].x[k];
			for(int k=0;k<(len>>1);k++)ur.x[k]=up[j+i].x[k];
			dn[j].resize();
			up[j].resize();
			dl.dft(1);
			dr.dft(1);
			ul.dft(1);
			ur.dft(1);
			for(int k=0;k<len;k++)dn[j].x[k]=dl.x[k]*dr.x[k]%MOD;
			for(int k=0;k<len;k++)up[j].x[k]=(ul.x[k]*dr.x[k]+dl.x[k]*ur.x[k])%MOD;
			dn[j].dft(-1);
			up[j].dft(-1);
		}
	}
	
	dv.resize();
	tmp.resize();
	get_inv(dn[0],dv,len>>1);
	
	dv.dft(1);
	up[0].dft(1);
	for(int i=0;i<len;i++)tmp.x[i]=dv.x[i]*up[0].x[i]%MOD;
	tmp.dft(-1);
	
	for(int i=0;i<sz;i++)tar[i]=tmp.x[i];
}

void calc_ans()
{
	init(max(max(n1,m),n2));
	int slen=len;
	work(A,EA,slen,n1);
	work(B,EB,slen,n2);
	init(slen*2);
	f1.resize();
	f2.resize();
	for(int i=0;i<len>>1;i++)f1.x[i]=EA[i]*inv(fac[i])%MOD*inv(n1)%MOD,f2.x[i]=EB[i]*inv(fac[i])%MOD*inv(n2)%MOD;
	f1.dft(1);
	f2.dft(1);
	for(int i=0;i<len;i++)f1.x[i]=f1.x[i]*f2.x[i]%MOD;
	f1.dft(-1);
	for(int i=1;i<m;i++)printf("%lld\n",f1.x[i]*fac[i]%MOD);putchar('\n');
}

void prework()
{
	fac[0]=1;
	for(int i=1;i<MX;i++)fac[i]=fac[i-1]*(ll)i%MOD;
	for(int i=0;i<MX;i++)gp[i]=ksm(G,(MOD-1)>>i),gpi[i]=inv(gp[i]);
	for(int w=1,i=1;w<MX;i++,w<<=1)
	{
		wi[i][0]=1;
		wii[i][0]=1;
		for(int j=1;j<w;j++)
		{
			wi[i][j]=wi[i][j-1]*gp[i]%MOD;
			wii[i][j]=wii[i][j-1]*gpi[i]%MOD;
		}
	}
}

int main()
{
	prework();
	scanf("%d%d",&n1,&n2);
	for(int i=0;i<n1;i++)A[i]=read();
	for(int i=0;i<n2;i++)B[i]=read();
	scanf("%d",&m);m++;
	calc_ans();
	return 0;
}
```

---

## 作者：wishapig (赞：9)

你谷题解界面aligned不能用，所以这里的（会挂的）公式都用图片代替，见谅

~~感觉写的还是很详细的awa~~

来全面写一下这道题的所有推导过程和思考方式罢（包括那个奇怪转化的思考方式）

题意写的挺清晰的，对于每个$k(1\le k\le t)$求

![](https://i.loli.net/2020/04/30/QiFXspMO5vzAZCW.jpg)

首先要化化式子，可以把解释与公式对照着看

- 第一行，抄下式子

- 第二行，二项式展开

- 第三行，展开组合数

- 第四行，（~~按直觉~~）合并一些项

- 第五行，弄成卷积的形式

![](https://i.loli.net/2020/04/30/euNmQWyo6UsDKvd.jpg)

若令

![](https://i.loli.net/2020/04/30/jGfxMdICsJikOg3.jpg)

则

![](https://i.loli.net/2020/04/30/aJZjwFLWyPHpfiI.jpg)

就是用卷积表示原式

那现在就要求$A(x),B(x)$，只要我们能求出这两个生成函数，我们就能得到所有的$ans(k)$了

由于求法类似，这里仅给出求解$A(x)$的方法

首先就是考虑交换求和次序了

![](https://i.loli.net/2020/04/30/fzgxk3LRV4ErsQ1.jpg)

咦？貌似$\sum\limits_jx^ja_i^j=\dfrac{1}{1-a_ix}$我们是知道的，但这里多了一个$j!$怎么弄？重新设一个$A_1(x)$好了。

令

![](https://i.loli.net/2020/04/30/tFOaZ1yd27KBH4I.jpg)

那么$[x^n]A(x)=\dfrac{1}{n!}[x^n]A_1(x)$

也就是求出$A_1(x)$就可以求$A(x)$了

那重新改写一下上面交换求和顺序的过程

![](https://i.loli.net/2020/04/30/W38t6ZyEFwVzlna.jpg)

下面怎么做？直接求逆是不行的，貌似卡住了...

我们来思考一个问题，怎么把讨厌的分式去掉？那就是说，有什么方法可以弄出一个分式？

欸！有这么一个：$\ln'(x)=\dfrac{1}{x}$，那就往$\ln$和导数上靠吧，比如这一个尝试：

$$
\ln'(1-a_ix)=\frac{1}{1-a_ix}
$$

这是最直接的尝试，代到上面的式子里试试？

![](https://i.loli.net/2020/04/30/It61iXceTbRNof4.jpg)

看起来也没法做...这个尝试不能解决问题

不过再想想，为什么做不了？我们其实可以想方法把导数弄到$\sum$外面去，这样就好做了。那怎么弄呢？那就整个求导吧...

注意，使用了$[f(g(x))]'=g'(x)f'[g(x)]$

$$
\begin{aligned}
[\ln(1-a_ix)]'
&=(1-a_ix)\ln'(1-a_ix) \cr
&=\frac{-a_i}{1-a_ix}
\end{aligned}
$$

有点接近了...，尝试把$\dfrac{-a_i}{1-a_ix}$弄成$\dfrac{1}{1-a_ix}$

根据基本的小学（初中？）的知识，有

$$
\frac{1}{1-a_ix}=1-x\frac{-a_i}{1-a_ix}
$$

欸，可以了！

那把所有的东西整理起来，重写式子，得到

![](https://i.loli.net/2020/04/30/seOfxPG2ZWyTKhk.jpg)

呼...现在就只剩$\prod\limits_{i=1}^n(1-a_ix)$要求了

直接按顺序乘肯定是会T的

$T(n)=T(n-1)+O(n\log n)$

我们按每次从中间分成两边分治下去乘，再合并起来

$T(n)=2T(\dfrac{n}{2})+O(n\log n)=O(n\log^2 n)$

那这题终于解决了...

总结：得到的思考方向：有什么方法可以弄出一个题目要求的形式，就往那个方法上靠（比如这题就是$\ln$求导出分式）

代码仅供参考，不喜勿喷

```cpp
#include<cstdio>
using namespace std;
const int N=265005;
#define mod 998244353
int a[N],b[N],f[N],g[N],M[N],L[N],A[19][N],fil[N],Inv[N],fac[N],w[N],r[N],stk[19][N];
int n,m,Inv3,t;
inline int Plus(int x, int y){ x+=y; return (x>=mod?x-mod:x); }
inline int fastpow(int x, int y){ int z=1; for (; y; y>>=1,x=1ll*x*x%mod) if (y&1) z=1ll*z*x%mod; return z; }
inline void Qiudao(int* a, int n){ for (int i=1; i<n; i++) a[i-1]=1ll*i*a[i]%mod; a[n-1]=0;}
inline void Jifen(int* a, int n){ for (int i=n-1; i; i--) a[i]=1ll*fastpow(i,mod-2)*a[i-1]%mod; a[0]=0; }
inline void Swap(int& a, int& b){ a^=b; b^=a; a^=b; }
inline void NTT(int* a, int n, bool op){
	for (int i=0; i<n; i++)
		if (i<fil[i]) Swap(a[i],a[fil[i]]);
	for (int len=2; len<=n; len<<=1){
		int g=fastpow(op?Inv3:3,(mod-1)/len),l=len>>1,now=1,res;
		for (int i=0; i<n; i+=len,now=1)
			for (int j=i; j<i+l; j++){
				res=1ll*now*a[j+l]%mod;
				a[j+l]=Plus(a[j],mod-res);
				a[ j ]=Plus(a[j],res);
				now=1ll*now*g%mod;
			}
	}
}
inline void Mutiply(int* a, int* b, int len1, int len2, int lim){
	int m=len1+len2,n; for (n=1; n<m; n<<=1);
	for (int i=0; i<len2; i++) M[i]=b[i];
	for (int i=len2; i<n; i++) M[i]=0;
	for (int i=0; i<n; i++) fil[i]=(fil[i>>1]>>1)|((i&1)?(n>>1):0);
	NTT(a,n,0); NTT(M,n,0);
	for (int i=0; i<n; i++) a[i]=1ll*a[i]*M[i]%mod;
	NTT(a,n,1); int Invn=fastpow(n,mod-2);
	for (int i=0; i<lim; i++) a[i]=1ll*a[i]*Invn%mod;
	for (int i=lim; i<n; i++) a[i]=0;
}
inline void Inverse(int* a, int m){
	int n; for (n=1; n<m; n<<=1);
	w[0]=fastpow(a[0],mod-2);
	for (int len=2; len<=n; len<<=1){
		int l=len>>1;
		for (int i=0; i<l; i++) r[i]=Plus(w[i],w[i]);
		Mutiply(w,w,l,l,len);
		Mutiply(w,a,len,len,len);
		for (int i=0; i<len; i++) w[i]=Plus(r[i],mod-w[i]);
	}
	for (int i=0; i<m; i++) a[i]=w[i];
	for (int i=m; i<n; i++) a[i]=0;
	for (int i=0; i<n; i++) w[i]=r[i]=0;
}
inline void Ln(int* a, int m){
	int n; for (n=1; n<m; n<<=1);
	for (int i=0; i<m; i++) L[i]=a[i];
	for (int i=m; i<n; i++) L[i]=0;
	Qiudao(a,m); Inverse(L,m);
	Mutiply(a,L,m-1,m,m); Jifen(a,m);
	for (int i=m; i<n; i++) a[i]=0;
}
int solve(int l, int r, int* a, int dep){
	if (l==r){ stk[dep][0]=1; stk[dep][1]=mod-a[l]; return 2; }
	int mid=(l+r)>>1;
	int len1=solve(l,mid,a,dep+1);
	for (int i=0; i<len1; i++) A[dep][i]=stk[dep+1][i],stk[dep+1][i]=0;
	int len2=solve(mid+1,r,a,dep+1);
	for (int i=0; i<len2; i++) stk[dep][i]=stk[dep+1][i],stk[dep+1][i]=0;
	Mutiply(stk[dep],A[dep],len2,len1,len1+len2);
	for (int i=0; i<len1+len2; i++) A[dep][i]=0;
	return len1+len2;
}
inline void Make(int* a, int* b, int n){
	int len=solve(1,n,a,0);
	for (int i=0; i<t; i++) b[i]=stk[0][i];
	for (int i=0; i<len; i++) stk[0][i]=0;
	Ln(b,t); Qiudao(b,t);
	for (int i=t-1; i; i--) b[i]=mod-b[i-1]; b[0]=n;
	for (int i=0; i<t; i++) b[i]=1ll*b[i]*Inv[i]%mod;
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
	for (int i=1; i<=m; i++) scanf("%d",&b[i]);
	scanf("%d",&t); t++;
	fac[0]=Inv[0]=1; Inv3=fastpow(3,mod-2);
	for (int i=1; i<t; i++) Inv[i]=fastpow(fac[i]=1ll*fac[i-1]*i%mod,mod-2);
	Make(a,f,n); Make(b,g,m);
	Mutiply(f,g,t,t,t); int res=1ll*fastpow(n,mod-2)*fastpow(m,mod-2)%mod;
	for (int i=1; i<t; i++) printf("%d\n",1ll*res*f[i]%mod*fac[i]%mod);
	return 0;
}
```

~~不要脸地求赞~~

---

## 作者：longlongzhu123 (赞：3)

UPD：LaTeX 锅了

>   Github 博客原文链接：[[Link↗]](https://longlongzhu123.github.io/sol-luogu-P4705-brief/)

入门稍进阶，挺有意思的一道题。

# 推导 I

记“$k$ 次价值”的答案为 $c _ k$。根据期望的定义得到式子：

$$ c _ k = \sum _ {x = 0} ^ {n - 1} \sum _ {y = 0} ^ {m - 1} (a _ x + b _ y) ^ k \cdot \frac {1} {nm} $$

进行推导。

$$ \begin {aligned} c _ k &= \sum _ {x = 0} ^ {n - 1} \sum _ {y = 0} ^ {m - 1} (a _ x + b _ y) ^ k \cdot \frac {1} {nm} \\ &= \sum _ {x = 0} ^ {n - 1} \sum _ {y = 0} ^ {m - 1} \sum _ {i + j = k} \binom {k} {i} a _ x ^ i b _ y ^ j \cdot \frac {1} {nm} \\ &= \sum _ {i + j = k} \sum _ {x = 0} ^ {n - 1} \sum _ {y = 0} ^ {m - 1} \binom {k} {i} a _ x ^ i b _ y ^ j \cdot \frac {1} {nm} \\ &= \frac {1} {nm} \sum _ {i + j = k} \binom {k} {i} \sum _ {x = 0} ^ {n - 1} a _ x ^ i \sum _ {y = 0} ^ {m - 1} b _ y ^ j \\ &= \frac {1} {nm} \sum _ {i + j = k} \frac {k!} {i! j!} \sum _ {x = 0} ^ {n - 1} a _ x ^ i \sum _ {y = 0} ^ {m - 1} b _ y ^ j \\ &= \frac {k!} {nm} \sum _ {i + j = k} \frac {1} {i!} \sum _ {x = 0} ^ {n - 1} a _ x ^ i \frac {1} {j!} \sum _ {y = 0} ^ {m - 1} b _ y ^ j \\ &= \frac {k!} {nm} \sum _ {i + j = k} \left ( \frac {1} {i!} \sum _ {x = 0} ^ {n - 1} a _ x ^ i \right ) \left ( \frac {1} {j!} \sum _ {y = 0} ^ {m - 1} b _ y ^ j \right ) \\ &= \frac {k!} {nm} \sum _ {i + j = k} \left ( \frac {1} {i!} a' _ i \right ) \left ( \frac {1} {j!} b' _ j \right ) \end {aligned} $$

看得出这是一个卷积的形式。其中相乘的两项分别为 $\left < \frac {1} {i!} a' _ i \right >$ 和 $\left < \frac {1} {j!} b' _ j \right >$。（这里 $\left < x \right >$ 表示序列）

考虑怎么求 $\displaystyle a' _ i = \sum _ {x = 0} ^ {n - 1} a _ x ^ i$。

# 推导 II

不妨利用生成函数的数学工具。

将需要求解的序列放入生成函数，并利用其性质对式子进行变换，从而得到**快速求解系数**的算法。此时我们就可以使用 FFT 等算法进行计算。

设 $\left < a' _ i \right >$ 的生成函数为 $A(X)$，那么：

$$ \begin {aligned} A(X) &= \sum _ {i = 0} ^ {\infty} a' _ i X ^ i \\ &= \sum _ {i = 0} ^ {\infty} \sum _ {x = 0} ^ {n - 1} a _ x ^ i X ^ i \\ &= \sum _ {x = 0} ^ {n - 1} \sum _ {i = 0} ^ {\infty} a _ x ^ i X ^ i \\ &= \sum _ {x = 0} ^ {n - 1} \frac {1} {1 - a _ x X} \end {aligned} $$

不妨记作 $\displaystyle A(x) = \sum _ {i = 0} ^ {n - 1} \frac {1} {1 - a _ i x}$。

**（最关键也是最困难的一步）**考虑：

$$ \begin {aligned} \ln' (1 - a _ i x) &= \frac {1} {1 - a _ i x} = F \\ (\ln (1 - a _ i x))' &= \frac {-a _ i} {1 - a _ i x} = G \end {aligned} $$

则 $F + x \cdot G = 1$。即 $F = 1 - x \cdot G$。

>   容易陷入的一个误区：用 $F = \frac {G} {-a _ i}$ 来表示 $F$。
>   
>   理论上这是可行的。然而将其代入式子 $\sum _ {i = 0} ^ {n - 1} F$ 中，就会发现这对解题没有任何帮助。
>   
>   正确的方法应该要让 $F$ 和 $G$ 之间不与 $i$ 发生任何关系，从而提取因式实现 $F$ 到 $G$ 的转换。

$$ \begin {aligned} A(x) &= \sum _ {i = 0} ^ {n - 1} \frac {1} {1 - a _ i x} \\ &= \sum _ {i = 0} ^ {n - 1} \ln' (1 - a _ i x) \\ &= \sum _ {i = 0} ^ {n - 1} (1 - x \cdot (\ln (1 - a _ i x))') \\ &= \sum _ {i = 0} ^ {n - 1} 1 - \sum _ {i = 0} ^ {n - 1} x \cdot (\ln (1 - a _ i x))' \\ &= n - x \sum _ {i = 0} ^ {n - 1} (\ln (1 - a _ i x))' \end {aligned} $$

考虑计算 $\displaystyle \sum _ {i = 0} ^ {n - 1} (\ln (1 - a _ i x))'$。

# 推导 III

运用套路：$\displaystyle \sum \ln (\text {xxx}) \iff \ln \prod (\text {xxx})$。参考**付公主的背包**一题对这个方法的运用 [[Link↗]](https://longlongzhu123.github.io/sol-luogu-P4389/#%E5%B9%B2%E5%98%9B%E8%A6%81%E7%9B%B8%E4%B9%98)。

$$ \begin {aligned} \sum _ {i = 0} ^ {n - 1} (\ln (1 - a _ i x))' &= \left ( \sum _ {i = 0} ^ {n - 1} \ln (1 - a _ i x) \right )' \\ &= \left ( \ln \prod _ {i = 0} ^ {n - 1} (1 - a _ i x) \right )' \end {aligned} $$

有一个经典的分治算法可以解决 $\prod _ {i = 0} ^ {n - 1} (1 - a _ i x)$。具体来说，若 $n$ 是 $2$ 的 $k$ 次幂，令 $m = \frac {n} {2}$，将式子拆成 $\prod _ {i = 0} ^ {m - 1} (1 - a _ i x)$ 和 $\prod _ {i = m} ^ {n - 1} (1 - a _ i x)$ 两部分递归求解。回溯时将这两部分用 FFT 乘起来即可。

# 归纳算法流程

整理一下我们需要做什么：

1.  递归求 $\prod _ {i = 0} ^ {n - 1} (1 - a _ i x)$。
2.  多项式 Ln，得到 $\ln \prod _ {i = 0} ^ {n - 1} (1 - a _ i x)$。
3.  求导，得到 $\left ( \ln \prod _ {i = 0} ^ {n - 1} (1 - a _ i x) \right )'$
4.  用 $F = 1 - x \cdot G$ 得到 $n - x \cdot \left ( \ln \prod _ {i = 0} ^ {n - 1} (1 - a _ i x) \right )'$。即为 $a _ i'$ 的生成函数 $A(x)$。
5.  将所有 $a _ i'$ 乘上 $\frac {1} {i!}$。求 $a _ i'$ 和 $b _ i'$ 的卷积。答案乘以 $\frac {k!} {nm}$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int kMaxN = 100000 * 16 + 10; // 开足空间！
const int kMod = 998244353;
const int kPri = 3;
const int kPriInv = 332748118;
inline LL Read() {
  int get = getchar();
  LL res = 0;
  while (!isdigit(get)) get = getchar();
  while (isdigit(get)) {
    res = res * 10 + get - '0';
    get = getchar();
  }
  return res;
}
inline LL Fpow(LL x, LL k) {
  LL ans = 1;
  for (; k; k >>= 1) {
    if (k & 1) ans = ans * x % kMod;
    x = x * x % kMod;
  }
  return ans;
}
inline LL Fadd(LL x, LL y) {
  return (x += y) >= kMod ? x - kMod : x;
}
inline LL Fdec(LL x, LL y) {
  return (x -= y) < 0 ? x + kMod : x;
}
inline void RaderSort(LL* a, int n) {
  int j = 0;
  for (int i = 0; i < n; ++i) {
    if (i < j) swap(a[i], a[j]);
    for (int l = (n >> 1); (j ^= l) < l; l >>= 1)
      continue;
  }
}
inline void Ntt(LL* a, int n, bool opt) {
  RaderSort(a, n);
  LL pri = opt ? kPri : kPriInv;
  for (int len = 2; len <= n; len <<= 1) {
    LL unit = Fpow(pri, (kMod - 1) / len);
    for (int i = 0; i < n; i += len) {
      LL w = 1;
      int mid = i + (len >> 1);
      for (int j = 0; j < (len >> 1); ++j) {
        LL tmp = w * a[mid + j] % kMod;
        a[mid + j] = Fdec(a[i + j], tmp);
        a[i + j] = Fadd(a[i + j], tmp);
        w = w * unit % kMod;
      }
    }
  }
  if (!opt) {
    LL inv = Fpow(n, kMod - 2);
    for (int i = 0; i < n; ++i)
      a[i] = a[i] * inv % kMod;
  }
}
LL inv_t[kMaxN];
inline void InvIter(LL* a, LL* b, int n) {
  int lim = (n << 1);
  fill(inv_t, inv_t + lim, 0);
  copy(a, a + n, inv_t);
  Ntt(inv_t, lim, true);
  Ntt(b, lim, true);
  for (int i = 0; i < lim; ++i)
    b[i] = Fdec(2, inv_t[i] * b[i] % kMod) * b[i] % kMod;
  Ntt(b, lim, false);
  fill(b + n, b + lim, 0);
}
inline void Inv(LL* a, LL* b, int n) {
  fill(b, b + n, 0);
  b[0] = Fpow(a[0], kMod - 2);
  for (int len = 2; len <= n; len <<= 1)
    InvIter(a, b, len);
}
inline void Deri(LL* a, int n) {
  for (int i = 0; i < n - 1; ++i)
    a[i] = (i + 1) * a[i + 1] % kMod;
  a[n - 1] = 0;
}
inline void Inte(LL* a, int n) {
  for (int i = n - 2; i >= 0; --i)
    a[i + 1] = a[i] * Fpow(i + 1, kMod - 2) % kMod;
  a[0] = 0;
}
LL log_t[kMaxN];
inline void Log(LL* a, int n) {
  int lim = (n << 1);
  fill(log_t, log_t + lim, 0);
  Inv(a, log_t, n);
  Deri(a, lim);
  fill(a + n, a + lim, 0);
  Ntt(a, lim, true);
  Ntt(log_t, lim, true);
  for (int i = 0; i < lim; ++i)
    a[i] = a[i] * log_t[i] % kMod;
  Ntt(a, lim, false);
  Inte(a, n);
  fill(a + n, a + lim, 0);
}
LL exp_t[kMaxN], exp_a[kMaxN]; // 总要记得清空临时数组！
inline void ExpIter(LL* a, LL* b, int n) {
  int lim = (n << 1);
  fill(exp_t, exp_t + lim, 0);
  copy(b, b + n, exp_t);
  Log(exp_t, n);
  for (int i = 0; i < n; ++i)
    exp_t[i] = Fdec(a[i], exp_t[i]);
  Ntt(b, lim, true);
  Ntt(exp_t, lim, true);
  for (int i = 0; i < lim; ++i)
    b[i] = b[i] * (exp_t[i] + 1) % kMod;
  Ntt(b, lim, false);
}
inline void Exp(LL* a, LL* b, int n) {
  fill(b, b + n, 0); // 总要记得清空输出数组！
  b[0] = 1;  // a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.
  for (int len = 2; len <= n; len <<= 1)
    ExpIter(a, b, len);
}
// res = (1 - a_0 x) (1 - a_1 x) (1 - a_2 x) ... (1 - a_{n - 1} x)
// res 的长度预留 4 倍（乘法留空间△）
void Solve(LL* a, LL* res, int n) {
  if (n == 1) {
    res[0] = 1;
    res[1] = kMod - a[0];
    res[2] = res[3] = 0;
  } else {
    int mid = (n >> 1), lim = mid * 4; // lim 即为留空间
    Solve(a, res, mid);
    Solve(a + mid, res + lim, mid);
    Ntt(res, lim, true);
    Ntt(res + lim, lim, true);
    for (int i = 0; i < lim; ++i)
      res[i] = res[i] * res[lim + i] % kMod;
    Ntt(res, lim, false);
    fill(res + lim, res + 2 * lim, 0);
  }
}
int n, m, t, lim;
LL a0[kMaxN], b0[kMaxN];
LL a[kMaxN], b[kMaxN];
LL fac[kMaxN];
void Calc(LL* a0, LL* a, int lim, int n) {
  Solve(a0, a, lim);
  Log(a, lim);
  Deri(a, lim);
  for (int i = lim - 1; i >= 1; --i)
    a[i] = kMod - a[i - 1];
  a[0] = n;
  for (int i = 0; i < lim; ++i)
    a[i] = a[i] * Fpow(fac[i], kMod - 2) % kMod;
}
int main() {
  scanf("%d %d", &n, &m);
  for (int i = 0; i < n; ++i)
    scanf("%lld", &a0[i]);
  for (int i = 0; i < m; ++i)
    scanf("%lld", &b0[i]);
  scanf("%d", &t);
  int maxn = max(max(n, m), t) + 10;
  lim = 1;
  while (lim < maxn) lim <<= 1;
  fac[0] = 1;
  for (int i = 1; i < lim; ++i)
    fac[i] = fac[i - 1] * i % kMod;
  Calc(a0, a, lim, n);
  Calc(b0, b, lim, m);
  Ntt(a, (lim << 1), true); // 留空间！！！！！！！！
  Ntt(b, (lim << 1), true);
  for (int i = 0; i < (lim << 1); ++i)
    a[i] = a[i] * b[i] % kMod;
  Ntt(a, (lim << 1), false);
  for (int i = 1; i <= t; ++i)
    printf("%lld\n", a[i] * Fpow(1ll * n * m % kMod, kMod - 2) % kMod * fac[i] % kMod);
  // 请注意这个 1ll * n * m！！！！！！！！
  // 类型强制转换！！！！！
  return 0;
}
```


---

## 作者：Memory_of_winter (赞：3)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10372741.html)

**题目大意：**对于每个$k\in[1,t]$，求：
$$\dfrac{\sum\limits_{i=1}^n\sum\limits_{j=1}^m(a_i+b_j)^k}{nm}$$
$n,m,t\leqslant10^5$

**题解：**发现这个$nm$是一个定值，可以先不考虑，先对每一个$k$来求
$$\begin{aligned}&\sum\limits_{i=1}^n\sum\limits_{j=1}^m(a_i+b_j)^k\\=&\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{s=0}^k\binom ksa_i^sb_j^{k-s}\\=&\sum\limits_{s=0}^k\binom ks\sum\limits_{i=1}^na_i^s\sum\limits_{j=1}^mb_j^{k-s}\\=&\sum\limits_{s=0}^k\dfrac{k!}{s!(k-s!)}\sum\limits_{i=1}^na_i^s\sum\limits_{j=1}^mb_j^{k-s}\\=&k!\sum\limits_{s=0}^k\sum\limits_{i=1}^n\dfrac{a_i^s}{s!}\sum\limits_{j=1}^m\dfrac{b_j^{k-s}}{(k-s)!}\\\end{aligned}$$
令$A_k=\sum\limits_{i=0}^n\dfrac{a_i^k}{k!},B_k=\sum\limits_{i=0}^m\dfrac{b_i^k}{k!}$式子就变成了
$$k!\sum\limits_{s=0}^kA_sB_{k-s}\\$$
就可以很简单的求出来了，现在的问题变成了如何求$A,B$。接下来就讲求$A$的方法，$B$的相同。

令$A(x)$为$A$的生成函数，即$A(x)=\sum\limits_{k=0}^{\infty}\dfrac{\sum\limits_{i=0}^na_i^k}{k!}x^k$，这一个$k!$也很好解决，下面就省略不写
$$\begin{aligned}f(x)=&\sum\limits_{k=0}^{\infty}\sum\limits_{i=0}^na_i^kx^k\\=&\sum\limits_{i=0}^n\sum\limits_{k=0}^{\infty}a_i^kx^k\\=&\sum\limits_{i=0}^n\dfrac1{1-a_i}\end{aligned}$$
发现$\ln'(x)=\dfrac1x,\ln'(1-ax)=\dfrac{-a_i}{1-a_i}$

令$g(x)=\sum\limits_{i=0}^n\dfrac{-a_i}{1-a_i}$，然后$f(x)=-g(x)x+n$，而$g(x)$可以比较简单的求出来：
$$\begin{aligned}g(x)=&\sum\limits_{i=0}^n\dfrac{-a_i}{1-a_i}\\=&\sum\limits_{i=0}^n\ln'(1-a_ix)\\=&\ln'(\prod\limits_{i=1}^n(1-a_ix))\end{aligned}$$
令$M(x)=\prod\limits_{i=1}^n(1-a_ix)$，这可以用分治$FFT$求出
$$\begin{aligned}g(x)=&\ln'(M(x))\\=&(\int\dfrac{M'(x)}{M(x)})'\\=&\dfrac{M'(x)}{M(X)}\end{aligned}$$
然后把$g(x)$转成$f(x)$，再变成指数型生成函数卷一下就好了，注意别忘记上面省略掉的一些东西



**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <vector>
#define maxn 262144
const int mod = 998244353;

#define mul(x, y) static_cast<long long> (x) * (y) % mod

namespace Math {
	inline int pw(int base, int p) {
		static int res;
		for (res = 1; p; p >>= 1, base = mul(base, base)) if (p & 1) res = mul(res, base);
		return res;
	}
	inline int inv(int x) { return pw(x, mod - 2); }
}
inline void reduce(int &x) { x += x >> 31 & mod; }
inline void clear(register int *l, const int *r) {
	if (l >= r) return ;
	while (l != r) *l++ = 0;
}

int inv[maxn], ifac[maxn], fac[maxn];
int A[maxn], B[maxn];
namespace Poly {
#define N maxn
	int lim, s, rev[N], Wn[N];
	inline void init(const int n) {
		lim = 1, s = -1; while (lim < n) lim <<= 1, ++s;
		for (register int i = 1; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const int t = Math::pw(3, (mod - 1) / lim);
		*Wn = 1; for (register int *i = Wn + 1; i != Wn + lim; ++i) *i = mul(*(i - 1), t);
	}
	inline void FFT(int *A, const int op = 1) {
		for (register int i = 1; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			for (register int i = 0; i < lim; i += mid << 1)
				for (register int j = 0; j < mid; ++j) {
					const int X = A[i + j], Y = mul(A[i + j + mid], Wn[t * j]);
					reduce(A[i + j] += Y - mod), reduce(A[i + j + mid] = X - Y);
				}
		}
		if (!op) {
			const int ilim = Math::inv(lim);
			for (register int *i = A; i != A + lim; ++i) *i = mul(*i, ilim);
			std::reverse(A + 1, A + lim);
		}
	}

	std::vector<int> P1[maxn], P2[maxn];
#define __DC_FFT(x, A) \
	void DC_FFT##x(int rt, int l, int r) { \
		if (l == r) { \
			P##x[rt] = {1, A[l]}; \
			return ; \
		} \
		static int C[N], D[N]; \
		const int mid = l + r >> 1, L = rt << 1, R = rt << 1 | 1; \
		DC_FFT##x(L, l, mid), DC_FFT##x(R, mid + 1, r); \
		const int n = P##x[L].size(), m = P##x[R].size(); \
		init(n + m); \
		std::copy(P##x[L].begin(), P##x[L].end(), C), clear(C + n, C + lim); \
		std::copy(P##x[R].begin(), P##x[R].end(), D), clear(D + m, D + lim); \
		FFT(C), FFT(D); \
		for (int i = 0; i < lim; ++i) C[i] = mul(C[i], D[i]); \
		FFT(C, 0); \
		P##x[rt].assign(C, C + n + m - 1); \
	}
	__DC_FFT(1, A)
	__DC_FFT(2, B)

	inline void DER(int *A, int *B, int n) {
		B[n - 1] = 0; for (int i = 1; i < n; ++i) B[i - 1] = mul(A[i], i);
	}

	void INV(int *A, int *B, int n) {
		if (n == 1) { *B = Math::inv(*A); return ; }
		static int C[N], D[N];
		const int len = n + 1 >> 1;
		INV(A, B, len), init(len * 3);
		std::copy(A, A + n, C), clear(C + n, C + lim);
		std::copy(B, B + len, D), clear(D + len, D + lim);
		FFT(C), FFT(D);
		for (int i = 0; i < lim; ++i) D[i] = (2 - mul(C[i], D[i]) + mod) * D[i] % mod;
		FFT(D, 0); std::copy(D + len, D + n, B + len);
	}

	void solve(std::vector<int> P, int *A, int t) {
		static int B[N], C[N];
		const int n = P.size();
		std::copy(P.begin(), P.end(), A); clear(A + n, A + t);
		DER(A, B, n), INV(A, C, t);
		init(n + t);
		clear(B + n, B + lim), clear(C + t, C + lim);
		FFT(B), FFT(C);
		for (int i = 0; i < lim; ++i) A[i] = mul(B[i], C[i]);
		FFT(A, 0);
		for (int i = t; i; --i) reduce(A[i] = -A[i - 1]);
		A[0] = n - 1;
		for (int i = 0; i < t; ++i) A[i] = mul(A[i], ifac[i]);
	}
	void TANG_Yx(int n, int m, int t) {
		DC_FFT1(1, 0, n - 1), DC_FFT2(1, 0, m - 1);
		static int A[N], B[N];
		solve(P1[1], A, t), solve(P2[1], B, t);
		init(t << 1);
		clear(A + t, A + lim), clear(B + t, B + lim);
		FFT(A), FFT(B);
		for (int i = 0; i < lim; ++i) A[i] = mul(A[i], B[i]);
		FFT(A, 0);
		const int nm = mul(Math::inv(n), Math::inv(m));
		for (int i = 1; i < t; ++i) printf("%lld\n", mul(A[i], fac[i]) * nm % mod);
	}
#undef N
}

int n, m, t;
int main() {
	std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);
	inv[0] = inv[1] = ifac[0] = ifac[1] = fac[0] = fac[1] = 1;
	for (int i = 2; i < maxn; ++i) {
		inv[i] = mul(mod - mod / i, inv[mod % i]);
		ifac[i] = mul(ifac[i - 1], inv[i]);
		fac[i] = mul(fac[i - 1], i);
	}
	std::cin >> n >> m;
	for (int i = 0; i < n; ++i) std::cin >> A[i], reduce(A[i] = -A[i]);
	for (int i = 0; i < m; ++i) std::cin >> B[i], reduce(B[i] = -B[i]);
	std::cin >> t; ++t;
	Poly::TANG_Yx(n, m, t);
	return 0;
}

```



---

## 作者：lhm_ (赞：2)

先化简答案的式子：
$$
ans_k=\frac{1}{nm}\sum_{i=1}^n\sum_{j=1}^m(a_i+b_j)^k 
	
	=\frac{1}{nm}\sum_{i=1}^n\sum_{j=1}^m\sum_{l=0}^k\binom{k}{l}a_i^lb_j^{k-l} 
	
	=\frac{k!}{nm}\sum_{l=0}^k\left (\sum_{i=1}^n\frac{a_i^l}{l!}\right )\left (\sum_{j=1}^m\frac{b_j^{k-l}}{(k-l)!} \right )
$$
发现是卷积的形式，那么只要能快速计算 $s_k=\sum\limits_{i=1}^n a_i^k$，然后进行卷积计算答案即可。

构造生成函数 $f(x)=\sum\limits_{i \geqslant 0} s_ix^i$，进行化简：
$$
f(x)=\sum_{i \geqslant 0} s_ix^i =\sum_{i \geqslant 0} \sum_{j=0}^{n-1} a_j^ix^i 	=\sum_{j=0}^{n-1}\frac{1}{1-a_jx}
$$
注意到：
$$
{(\ln (1-a_ix))}'= \frac{-a_i}{1-a_ix}
$$
代入得：
$$
f(x)=\sum_{i=0}^{n-1}\frac{1}{1-a_ix} 
	
	=\sum_{i=0}^{n-1}1-x{(\ln (1-a_ix))}' 
	
	=n-x{\left (\sum_{i=0}^{n-1}\ln (1-a_ix)\right )}' 
	
	=n-x\left (\ln\prod_{i=0}^{n-1} (1-a_ix)\right )'
$$
对于 $\prod\limits_{i=0}^{n-1} (1-a_ix)$，可以通过分治来求解，即先算出左右两半后乘起来。

最后通过多项式对数函数即可求解答案。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 800010
#define P 998244353
#define G 3
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,m,k,all;
ll rev[maxn],a[maxn],b[maxn],f[maxn],g[maxn],fac[maxn],ifac[maxn];
ll qp(ll x,ll y)
{
    ll v=1;
    while(y)
    {
        if(y&1) v=v*x%P;
        x=x*x%P,y>>=1;
    }
    return v;
}
int calc(int n)
{
    int lim=1;
    while(lim<=n) lim<<=1;
    for(int i=0;i<lim;++i)
        rev[i]=(rev[i>>1]>>1)|((i&1)?lim>>1:0);
    return lim;
}
void NTT(ll *a,int lim,int type)
{
    for(int i=0;i<lim;++i)
        if(i<rev[i])
            swap(a[i],a[rev[i]]);
    for(int len=1;len<lim;len<<=1)
    {
        ll wn=qp(G,(P-1)/(len<<1));
        for(int i=0;i<lim;i+=len<<1)
        {
            ll w=1;
            for(int j=i;j<i+len;++j,w=w*wn%P)
            {
                ll x=a[j],y=w*a[j+len]%P;
                a[j]=(x+y)%P,a[j+len]=(x-y+P)%P;
            }
        }
    }
    if(type==1) return;
    ll inv=qp(lim,P-2);
    for(int i=0;i<lim;++i) a[i]=a[i]*inv%P;
    reverse(a+1,a+lim);
}
void Inv(int deg,ll *a,ll *b)
{
    static ll t[maxn];
    if(deg==1)
    {
        b[0]=qp(a[0],P-2);
        return;
    }
    Inv((deg+1)>>1,a,b);
    int lim=calc(deg<<1);
    for(int i=0;i<deg;++i) t[i]=a[i];
    for(int i=deg;i<lim;++i) t[i]=b[i]=0;
    NTT(t,lim,1),NTT(b,lim,1);
    for(int i=0;i<lim;++i)
        b[i]=b[i]*(2-t[i]*b[i]%P+P)%P;
    NTT(b,lim,-1);
    for(int i=deg;i<lim;++i) b[i]=0;
}
void Ln(int deg,ll *a,ll *b)
{
    static ll inva[maxn],dera[maxn];
    Inv(deg,a,inva);
    for(int i=0;i<deg-1;++i) dera[i]=a[i+1]*(i+1)%P;
    dera[deg-1]=0;
    int lim=calc(deg<<1);
    for(int i=deg;i<lim;++i) dera[i]=inva[i]=0;
    NTT(dera,lim,1),NTT(inva,lim,1);
    for(int i=0;i<lim;++i) b[i]=dera[i]*inva[i]%P;
    NTT(b,lim,-1);
    for(int i=deg-1;i>=1;--i) b[i]=b[i-1]*qp(i,P-2)%P;
    b[0]=0;
    for(int i=deg;i<lim;++i) b[i]=0;
}
void solve(int l,int r,ll *a,ll *b)
{
    if(l==r)
    {
        b[0]=1,b[1]=P-a[l];
        return;
    }
    int mid=(l+r)>>1;
    ll a1[maxn],a2[maxn];
    solve(l,mid,a,a1),solve(mid+1,r,a,a2);
    int lim=calc(r-l+1);
    for(int i=mid-l+2;i<lim;++i) a1[i]=0;
    for(int i=r-mid+1;i<lim;++i) a2[i]=0;
    NTT(a1,lim,1),NTT(a2,lim,1);
    for(int i=0;i<lim;++i) b[i]=a1[i]*a2[i]%P;
    NTT(b,lim,-1);
    for(int i=r-l+2;i<lim;++i) b[i]=0;
}
void get(int n,ll *a,ll *b)
{
    static ll t[maxn];
    solve(1,calc(all),a,t),Ln(all+1,t,b);
    for(int i=0;i<=all;++i) b[i]=b[i+1]*(i+1)%P;
    b[all+1]=0;
    for(int i=all;i;--i) b[i]=P-b[i-1];
    b[0]=n;
    for(int i=0;i<=all;++i) b[i]=b[i]*ifac[i]%P;
}
void init()
{
    fac[0]=ifac[0]=1;
    for(int i=1;i<=all;++i) fac[i]=fac[i-1]*i%P;
    ifac[all]=qp(fac[all],P-2);
    for(int i=all-1;i;--i) ifac[i]=ifac[i+1]*(i+1)%P;
}
int main()
{
    read(n),read(m);
    for(int i=1;i<=n;++i) read(a[i]);
    for(int i=1;i<=m;++i) read(b[i]);
    read(k),all=max(k,max(n,m)),init();
    get(n,a,f),get(m,b,g);
    int lim=calc(all<<1);
    NTT(f,lim,1),NTT(g,lim,1);
    for(int i=0;i<lim;++i) f[i]=f[i]*g[i]%P;
    NTT(f,lim,-1);
    ll inv=qp(n*m%P,P-2);
    for(int i=1;i<=k;++i) printf("%lld\n",fac[i]*inv%P*f[i]%P);
    return 0;
}
```

---

## 作者：Jμdge (赞：2)

这题是真的神仙啊...居然用的 stl 来卡常？

话说 998244353 真的可以一眼 NTT ？

# noteskey

所以说只要推柿子就好了但是有的地方的推导根本就想不到...

我们令第 t 个答案为 $ANS_t\over nm$ ，除去 nm 其实就是算期望时要除去的方案数

那么有：

$$\begin{aligned}{}ANS_t=&\sum_{i=1}^{n} \sum_{j=1}^m (a_i+b_j)^t \\=&\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=0}^{t} \begin{pmatrix} t\\k \end{pmatrix} a_i^{k}b_{j}^{t-k}  \\=&\sum_{k=0}^{t} \begin{pmatrix} t\\k \end{pmatrix} \sum_{i=1}^{n}a_i^{k} \sum_{j=1}^{m}  b_{j}^{t-k} \\=& \sum_{k=0}^{t} \begin{pmatrix} t\\k \end{pmatrix}  \Big( \sum_{i=1}^{n}a_i^{k} \Big) \Big(\sum_{j=1}^{m}  b_{j}^{t-k} \Big) \\=&\sum_{k=0}^{t} t! \Big({ \sum_{i=1}^{n}a_i^{k}\over k! } \Big) \Big( {\sum_{j=1}^{m}  b_{j}^{t-k} \over (t-k)!} \Big)                     \end{aligned}$$

那么我们发现这个东西就是卷积的形式了，于是我们的任务就是快速算出后面两个表达式所对应的的多项式

我们设：

$$\begin{aligned} f(k)=\sum_{i=1}^n a_i ^{k} \\ g(k)=\sum_{i=1}^{m}b_{i}^{k} \end{aligned}$$

那么我们只要求出 $f(1...t) ,g(1...t)$ 即可

但是求出来没有这么简单...

我们考虑先求出：

$$f_j(x)=\sum_{i=1}^{k}a_j^{i}$$

然后我们令：

$$F(x)= \sum_{i=1}^{n} f_{i}(x)$$

那么 $F(x)$ 的第 k 项就表示了

$$\sum_{i=1}^{i} a_{i}^{k} x^k$$

即：

$$[x^{k}]F(x)=\sum_{i=1}^{i} a_{i}^{k}$$

那么我们现在发现要求出 $f_{j=1...n}(x)$ ，但是没有什么高效的办法能解决这个问题

于是我们把 $f_{j}(x)$ 中的上限 k 改掉，变成 $\infty$ ，这样我们就能用生成函数来解决了：

$$f_{j}(x)={1\over 1- a_i x} $$

然后就是把这些 $f_j(x)$ 加起来了：

$$F(x)={1\over 1-a_1x} +{1\over 1-a_2x} + ...+{1\over 1-a_nx}$$

最后就是怎么合并这些 $f_j(x)$ 的问题了，我们发现： 

$$ln(1-a_ix)'={-a_i\over 1-a_ix}$$

发现这个东西和我们要求的东西蛮像的，那么这里又有：

$$\begin{aligned}G(x)=&\sum_{i=1}^{n} ln(1-a_ix)' \\ F(x)=&-x·G(x)+n                         \end{aligned}$$

那么我们的任务就已经是求出 G(x) 了

$$G(x)=\sum_{i=1}^{n} ln(1-a_ix)'= ln(\prod_{i=1}^n (1-a_ix))'$$

然后我们就要在优秀的时间内求出$\prod_{i=1}^n (1-a_ix)$ ，然后取个 Ln 再求个 Inv ，右移一位让最低项为 n ， $F(x)$ 就构造好了

至于对 b 数组也是同样的求法，两个要求的多项式求出来后，我们还要让两个多项式除去对应的阶乘，然后再去卷积

卷完积后也和最开始的式子一样，第 t 项乘上 t! ，然后别忘了我们还要除去 nm 才是最终的答案...

最后就是顺序输出就好了




# code
这没救了的压行【雾


```cpp
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=524288+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int inc(int x,int y){return (x+y)%mod;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return (x-y+mod)%mod;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,t,qq,rev,d,limit;
arr a,b,f,g,fac,ifac,lg,r[20],D[21],G[2];
inline int qpow(Rg int x,Rg int p=mod-2,Rg int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void prep(int n=262143){ for(limit=1;limit<=n;limit<<=1);
	fac[0]=fac[1]=1; fp(i,2,limit) fac[i]=mul(fac[i-1],i);
	fp(d,1,19){ lg[1<<d]=d; fp(i,0,(1<<d)-1)
		r[d][i]=(r[d][i>>1]>>1)|((i&1)<<(d-1));
	}
	for(Rg int t=(mod-1)>>1,i=1,x,y;i<limit;i<<=1,t>>=1){
		x=qpow(3,t),y=qpow(iG,t),G[0][i]=G[1][i]=1;
		fp(k,1,i-1) G[1][i+k]=mul(G[1][i+k-1],x);
		fp(k,1,i-1) G[0][i+k]=mul(G[0][i+k-1],y);
	}
}
inline void init(int n){
	for(limit=1;limit<n;limit<<=1); d=lg[limit];
}
inline void NTT(int* a,int tp){
	fp(i,0,limit-1) if(i<r[d][i]) swap(a[i],a[r[d][i]]);
	for(Rg int mid=1,I=2;mid<limit;mid<<=1,I<<=1)
		for(Rg int j=0,x,y;j<limit;j+=I) fp(k,0,mid-1)
			x=a[j+k],y=mul(a[j+k+mid],G[tp][mid+k]),
			a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	if(tp) return ; int inv=qpow(limit);
	fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
inline void Mul(int* a,int* b,int* c,int n){
	static arr A,B; fp(i,0,n-1) A[i]=a[i],B[i]=b[i];
	fill(A+n,A+limit,0),fill(B+n,B+limit,0),NTT(A,1),NTT(B,1);
	fp(i,0,limit-1) A[i]=mul(A[i],B[i]); NTT(A,0),copy(A,A+limit,c);
}
void Inv(int* a,int* b,int n){
	if(n==1) return b[0]=qpow(a[0]),void();
	Inv(a,b,n>>1),init(n<<1); static arr c,d;
	fp(i,0,n-1) c[i]=a[i],d[i]=b[i];
	fp(i,n,limit-1) c[i]=d[i]=0; NTT(c,1),NTT(d,1);
	fp(i,0,limit-1) c[i]=mul(c[i],mul(d[i],d[i])); NTT(c,0);
	fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),c[i]);
}
inline void Derv(int* a,int* b,int n){
	fp(i,1,n-1) b[i-1]=mul(a[i],i); b[n-1]=0;
}
inline void Ln(int* a,int* b,int n){ static arr c,d;
	memset(c,0,(n+1)<<2),memset(d,0,(n+1)<<2);
	Derv(a,c,n),Inv(a,d,n),init(n<<1);
	Mul(c,d,b,n),fill(b+n,b+limit,0);
}
inline void solv(int* a,int d,int l,int r){
	if(l==r) return D[d][0]=1,D[d][1]=mod-a[l],void(); static arr A,B;
	int mid=(l+r)>>1; solv(a,d,l,mid),solv(a,d+1,mid+1,r),init(r-l+2);
	fp(i,0,mid-l+1) A[i]=D[d][i]; fp(i,0,r-mid) B[i]=D[d+1][i];
	fill(A+mid-l+2,A+limit,0),fill(B+r-mid+1,B+limit,0);
	Mul(A,B,D[d],r-l+1),fill(D[d]+r-l+2,D[d]+limit,0);
}
int main(){ n=read(),m=read(),rev=qpow(mul(n,m)),prep();
	fp(i,1,n) a[i]=read(); fp(i,1,m) b[i]=read();
	solv(a,1,1,n),copy(D[1],D[1]+n+1,f);
	solv(b,1,1,m),copy(D[1],D[1]+m+1,g);
	t=read(),qq=max(max(n,m),t); init(qq+1),qq=limit;
	Ln(f,f+1,qq),Ln(g,g+1,qq),f[0]=n,g[0]=m;
	fp(i,1,qq-1) f[i]=dec(mod,f[i]),g[i]=dec(mod,g[i]);
	fac[0]=ifac[0]=ifac[1]=1; fp(i,1,qq-1) fac[i]=mul(fac[i-1],i);
	fp(i,2,qq-1) ifac[i]=mul(mod-mod/i,ifac[mod%i]);
	fp(i,1,qq-1) ifac[i]=mul(ifac[i],ifac[i-1]);
	fp(i,0,qq-1) f[i]=mul(f[i],ifac[i]),g[i]=mul(g[i],ifac[i]);
	fp(i,qq,qq<<1) f[i]=g[i]=0; init(qq<<1),NTT(f,1),NTT(g,1);
	fp(i,0,limit-1) f[i]=mul(f[i],g[i]); NTT(f,0);
	fp(i,1,t) print(mul(f[i],mul(fac[i],rev))); return Ot(),0;
}
```


---

## 作者：Owen_codeisking (赞：2)

提供一个常数是别人 $3$ 倍但是能过的思路……

没关系，思路超级好想，就是代码长了点。 ~~握着4K的代码爆蛋~~

首先列出式子：

$$ans_t\times nm=\sum_{i=1}^{n}\sum_{j=1}^{m}(a_i+b_j)^t$$

由二项式定理：

$$ans_t\times nm=\sum_{k=0}^{t}C_t^k\sum_{i=1}^{n}a_i^k\sum_{j=1}^{m}b^{t-k}$$

继续推式子：

$$ans_t\times nm=\sum_{k=0}^{t}\frac {t!}{k!(t-k)!}\sum_{i=1}^{n}a_i^k\sum_{j=1}^{m}b^{t-k}$$

$$ans_t\times nm=t!\sum_{k=0}^{t}(\sum_{i=1}^{n}\frac {a_i^k}{k!})(\sum_{j=1}^{m}\frac {b^{t-k}}{(t-k)!})$$

这是我们都喜欢看到的卷积形式。我们可以把问题转化成 $f(k)=\sum_{i=1}^{n}a_i^k$，快速求出 $f(1),f(2),...,f(t)$

我们构造生成函数 $\Large\frac {1}{1-a_i}$，也就是 $1+a_ix+a_i^2x^2+...$

现在我们求的是 $\Large\frac {1}{1-a_1}+\Large\frac {1}{1-a_2}+...+\Large\frac {1}{1-a_n}$

然后我就不会什么高端的对数函数了……

这时候我们用小学的通分了！

$\Large\frac{P_1(x)}{Q_1(x)}+\Large\frac{P_2(x)}{Q_2(x)}=\Large\frac{P_1(x)*Q_2(x)+P_2(x)*Q_1(x)}{Q_1(x)*Q_2(x)}$

当然显然不能这么直接合并啊……不然时间复杂度变成了 $O(n^2\log n)$

我们发现开始时分子是常数，分母是一次式，那么可以借用分治的思想，将左区间和右区间合并！

因为一次合并需要三次 $NTT$，每次 $NTT$ 的最高次不超过 $len_{l,r}\times 2$，所以 $T(n)=2\times (\frac n2)+n\log n$，由主定理得时间复杂度 $O(n\log^2 n)$

分治完了以后对分母求个逆，与分子卷起来就可以得到 $f(1),f(2),...,f(t)$ 了！

最后还要 $NTT$ 一次。实际上计算常数的话，时间应该是 $2\times 3\times 200000\log^2 200000$，所以常数巨大，建议拿一个稍微快一些的 $NTT$ 板子。。。

~~一不小心就写了175行~~

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=400000+10;
const int maxT=100001;
const int mod=998244353;
int n,m,T,a[maxn],b[maxn],f[maxn],fac[maxn],inv[maxn],r[maxn],G[40][2];
vector<int> P[maxn],Q[maxn];

inline int read(){
    register int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return (f==1)?x:-x;
}

inline int add(int x,int y){
	x+=y;x>=mod?x-=mod:0;
	return x;
}

inline int sub(int x,int y){
	x-=y;x<0?x+=mod:0;
	return x;
}

inline int mul(int x,int y){
	x=1ll*x*y%mod;
	return x;
}

inline void calcrev(int lim){
	for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?(lim>>1):0);
}

inline int fpow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=mul(a,a))
		if(b&1) ret=mul(ret,a);
	return ret;
}

inline void Gpre(){
	for(int len=1,l=0;len<=mod;len<<=1,l++){
		G[l][0]=fpow(3,(mod-1)/len);
		G[l][1]=fpow(G[l][0],mod-2);
	}
}

inline void NTT(int *f,int n,int op){
	for(int i=0;i<n;i++)
		if(i<r[i]) swap(f[i],f[r[i]]);
	int buf,tmp,x,y;
	for(int len=1,l=1;len<n;len<<=1,l++){
		tmp=(op==1)?G[l][0]:G[l][1];
		for(int i=0;i<n;i+=len<<1){
			buf=1;
			for(int j=0;j<len;j++){
				x=f[i+j];y=mul(buf,f[i+j+len]);
				f[i+j]=add(x,y);f[i+j+len]=sub(x,y);
				buf=mul(buf,tmp);
			}
		}
	}
	if(op==1) return ;
	int inv=fpow(n,mod-2);
	for(int i=0;i<n;i++) f[i]=mul(f[i],inv);
}

inline void Mul(int *A,int *B,int *C,int n,int m){
	int lim;
	for(lim=1;lim<(n+m);lim<<=1);
	calcrev(lim);
	NTT(A,lim,1);NTT(B,lim,1);
	for(int i=0;i<lim;i++) C[i]=mul(A[i],B[i]);
	NTT(C,lim,-1);
}

inline void Clear(int *A,int *B,int *C,int *D,int n){
	int lim=1;
	for(lim=1;lim<(n<<1);lim<<=1);
	for(int i=0;i<lim;i++) A[i]=B[i]=C[i]=0;
	for(int i=n;i<lim;i++) D[i]=0;
}

inline void Clear(int *A,int *B,int *C,int n){
	int lim;
	for(lim=1;lim<n;lim<<=1);
	for(int i=0;i<lim;i++) A[i]=B[i]=C[i]=0;
}

inline void Inv(int *a,int *b,int n){
	b[0]=fpow(a[0],mod-2);
	static int A[maxn],B[maxn],C[maxn],len,lim;
	for(len=1;len<(n<<1);len<<=1){
		lim=len<<1;
		for(int i=0;i<len;i++) A[i]=a[i],B[i]=b[i];
		calcrev(lim);
		NTT(A,lim,1);NTT(B,lim,1);
		for(int i=0;i<lim;i++) C[i]=mul(sub(2,mul(A[i],B[i])),B[i]);
		NTT(C,lim,-1);
		for(int i=0;i<len;i++) b[i]=C[i];
	}
	Clear(A,B,C,b,n);
}

inline void solve(int *a,int l,int r,int x){
	if(l==r){
		P[x].push_back(1);
		Q[x].push_back(1);
		Q[x].push_back(mod-a[l]);
		return ;
	}
	int mid=(l+r)>>1,n,m;
	static int A[maxn],B[maxn],C[maxn],D[maxn];
	solve(a,l,mid,x<<1);solve(a,mid+1,r,x<<1|1);
	n=Q[x<<1].size();m=Q[x<<1|1].size();
	for(int i=0;i<n;i++) A[i]=Q[x<<1][i];
	for(int i=0;i<m;i++) B[i]=Q[x<<1|1][i];
	Mul(A,B,C,n,m);
	for(int i=0;i<n+m-1;i++) Q[x].push_back(C[i]);
	Clear(A,B,C,n+m);
	n=P[x<<1].size();m=Q[x<<1|1].size();
	for(int i=0;i<n;i++) A[i]=P[x<<1][i];
	for(int i=0;i<m;i++) B[i]=Q[x<<1|1][i];
	Mul(A,B,C,n,m);
	for(int i=0;i<n+m-1;i++) D[i]=add(D[i],C[i]);
	Clear(A,B,C,n+m);
	n=P[x<<1|1].size();m=Q[x<<1].size();
	for(int i=0;i<n;i++) A[i]=P[x<<1|1][i];
	for(int i=0;i<m;i++) B[i]=Q[x<<1][i];
	Mul(A,B,C,n,m);
	for(int i=0;i<n+m-1;i++) D[i]=add(D[i],C[i]);
	Clear(A,B,C,n+m);
	for(int i=0;i<n+m-1;i++) P[x].push_back(D[i]);
	Clear(D,D,D,n+m);
	P[x<<1].clear();Q[x<<1].clear();
	P[x<<1|1].clear();Q[x<<1|1].clear();
}

inline void calc(int *a){
	int n=P[1].size(),m=Q[1].size();
	static int A[maxn],B[maxn],C[maxn];
	for(int i=0;i<m;i++) A[i]=Q[1][i];
	Inv(A,B,maxT);
	for(int i=0;i<n;i++) A[i]=P[1][i];
	for(int i=n;i<maxT;i++) A[i]=0;
	Mul(A,B,C,n,maxT);
	for(int i=0;i<maxT;i++) a[i]=C[i];
	Clear(A,B,C,n+maxT);
	P[1].clear();Q[1].clear();
}

int main()
{
	Gpre();
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++) b[i]=read();
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<maxT;i++) fac[i]=mul(fac[i-1],i);
	for(int i=2;i<maxT;i++) inv[i]=mul(mod-mod/i,inv[mod%i]);
	for(int i=2;i<maxT;i++) inv[i]=mul(inv[i],inv[i-1]);
	static int A[maxn],B[maxn],C[maxn];
	solve(a,1,n,1);calc(A);
	solve(b,1,m,1);calc(B);
	for(int i=0;i<maxT;i++) A[i]=mul(A[i],inv[i]);
	for(int i=0;i<maxT;i++) B[i]=mul(B[i],inv[i]);
	Mul(A,B,C,maxT,maxT);
	int invnm=fpow(mul(n,m),mod-2);
	for(int i=1;i<maxT;i++) f[i]=mul(fac[i],mul(C[i],invnm));
	Clear(A,B,C,maxT<<1);
	T=read();
	for(int i=1;i<=T;i++) printf("%d\n",f[i]);
    return 0;
}
```

---

## 作者：qwaszx (赞：1)

只需要求出

$$
\sum_{i=1}^n\sum_{j=1}^m(a_i+b_j)^k,k\in[1,t]
$$

对 $k$ 建立 EGF:

$$
\begin{aligned}&\sum_{k\geq 0}\frac{x^k}{k!}\sum_{i=1}^n\sum_{j=1}^m(a_i+b_j)^k\\=&\sum_{i=1}^n\sum_{j=1}^m\sum_{k\geq 0}\frac{((a_i+b_j)x)^k}{k!}\\=&\sum_{i=1}^n\sum_{j=1}^ne^{a_ix}e^{b_jx}\\=&\left(\sum_{i=1}^ne^{a_ix}\right)\left(\sum_{i=1}^me^{b_ix}\right)\end{aligned}
$$

展开得到

$$
\sum_{i=1}^ne^{a_ix}=\sum_{i=1}^n\sum_{k\geq 0}\frac{a_i^kx^k}{k!}=\sum_{k\geq 0}\frac{x^k}{k!}\sum_{i=1}^na_i^k
$$

那么只需要求出

$$
\sum_{i=1}^na_i^k,k\in[1,t]
$$

考虑幂级数

$$
\sum_{k\geq 1}\frac{x^k}{k}\sum_{i=1}^na_i^k=\sum_{i=1}^n\sum_{k\geq 1}\frac{(a_ix)^k}{k}=-\sum_{i=1}^n\ln(1-a_ix)=-\ln\left(\prod_{i=1}^n(1-a_ix)\right)
$$

可以分治 NTT 计算.

复杂度 $O(n\log^2n+t\log t)$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
const int mod=998244353,N=5e5;
vector<int>fa[N],fb[N];
int fac[N],ifac[N],rev[N],w[N],inv[N],limn,ea[N],eb[N],a[N],b[N],n,m,T;
int qpower(int a,int b){int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;}
void NTT_prework(int n)
{
    limn=1;while(limn<=n)limn<<=1;
    for(int i=1;i<limn;i++)rev[i]=rev[i>>1]>>1|((i&1)?(limn>>1):0);
    for(int i=1;i<limn;i<<=1)
    {
        int omg=qpower(3,(mod-1)/(i<<1));
        w[i]=1;
        for(int j=1;j<i;j++)w[i+j]=1ll*omg*w[i+j-1]%mod;
    }
    inv[1]=1;for(int i=2;i<=n;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
    fac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
}
namespace NTTtmp{int tmp[N];}
void NTT(int a[],int l)
{
    using namespace NTTtmp;
    for(int i=0;i<l;i++)tmp[rev[i]/(limn/l)]=a[i];
    for(int i=1;i<l;i<<=1)
        for(int j=0;j<l;j+=i<<1)
            for(int k=0;k<i;k++)
            {
                int x=tmp[j+k],y=1ll*w[i+k]*tmp[i+j+k]%mod;
                tmp[j+k]=(x+y)%mod,tmp[i+j+k]=(x-y)%mod;
            }
    for(int i=0;i<l;i++)a[i]=tmp[i];
}
namespace MULtmp{int tmpa[N],tmpb[N];}
void mul(const vector<int>A,const vector<int>B,vector<int>&c)
{
    using namespace MULtmp;
    int la=A.size(),lb=B.size(),n=la+lb-1;
    int l=1;while(l<n)l<<=1;
    for(int i=0;i<la;i++)tmpa[i]=A[i];for(int i=la;i<l;i++)tmpa[i]=0;
    for(int i=0;i<lb;i++)tmpb[i]=B[i];for(int i=lb;i<l;i++)tmpb[i]=0;
    NTT(tmpa,l),NTT(tmpb,l);
    for(int i=0;i<l;i++)tmpa[i]=1ll*tmpa[i]*tmpb[i]%mod;
    reverse(tmpa+1,tmpa+l);NTT(tmpa,l);int ivl=mod-(mod-1)/l;
    c.resize(n);
    for(int i=0;i<n;i++)c[i]=1ll*tmpa[i]*ivl%mod;
}
void solve1(int rot,int lt,int rt)
{
    if(lt==rt){fa[rot].resize(2);fa[rot][0]=1,fa[rot][1]=-a[lt];return;}
    int mid=(lt+rt)>>1;
    solve1(rot<<1,lt,mid),solve1(rot<<1|1,mid+1,rt);
    mul(fa[rot<<1],fa[rot<<1|1],fa[rot]);
}
void solve2(int rot,int lt,int rt)
{
    if(lt==rt){fb[rot].resize(2);fb[rot][0]=1,fb[rot][1]=-b[lt];return;}
    int mid=(lt+rt)>>1;
    solve2(rot<<1,lt,mid),solve2(rot<<1|1,mid+1,rt);
    mul(fb[rot<<1],fb[rot<<1|1],fb[rot]);
}
void mul(const int A[],const int B[],int c[],int n)
{
    using namespace MULtmp;
    int l=1;while(l<(n<<1))l<<=1;
    for(int i=0;i<n;i++)tmpa[i]=A[i],tmpb[i]=B[i];
    for(int i=n;i<l;i++)tmpa[i]=tmpb[i]=0;
    NTT(tmpa,l),NTT(tmpb,l);
    for(int i=0;i<l;i++)tmpa[i]=1ll*tmpa[i]*tmpb[i]%mod;
    reverse(tmpa+1,tmpa+l);NTT(tmpa,l);int ivl=mod-(mod-1)/l;
    for(int i=0;i<n;i++)c[i]=1ll*tmpa[i]*ivl%mod;
}
namespace Invtmp{int tmpa[N],tmpb[N];}
void Inv(const int a[],int b[],int n)
{
    using namespace Invtmp;
    if(n==1){b[0]=qpower(a[0],mod-2);return;}
    int nn=(n+1)>>1;Inv(a,b,nn);
    int l=1;while(l<(n<<1))l<<=1;
    for(int i=0;i<nn;i++)tmpa[i]=b[i];for(int i=nn;i<l;i++)tmpa[i]=0;
    for(int i=0;i<n;i++)tmpb[i]=a[i];for(int i=n;i<l;i++)tmpb[i]=0;
    NTT(tmpa,l),NTT(tmpb,l);
    for(int i=0;i<l;i++)tmpa[i]=(2-1ll*tmpa[i]*tmpb[i])%mod*tmpa[i]%mod;
    reverse(tmpa+1,tmpa+l);NTT(tmpa,l);int ivl=mod-(mod-1)/l;
    for(int i=0;i<n;i++)b[i]=1ll*tmpa[i]*ivl%mod;
}
namespace Lntmp{int tmpa[N],tmpb[N];}
void Ln(const int a[],int b[],int n)
{
    using namespace Lntmp;
    for(int i=0;i<n-1;i++)tmpa[i]=1ll*(i+1)*a[i+1]%mod;
    tmpa[n-1]=0;
    Inv(a,tmpb,n);
    mul(tmpa,tmpb,tmpa,n);
    for(int i=1;i<n;i++)b[i]=1ll*inv[i]*tmpa[i-1]%mod;
    b[0]=0;
}
int main()
{
    scanf("%d%d",&n,&m);int iv=qpower(1ll*n*m%mod,mod-2);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    for(int i=1;i<=m;i++)scanf("%d",b+i);
    scanf("%d",&T);++T;
    NTT_prework(max(T<<1,max(n,m)));
    solve1(1,1,n),solve2(1,1,m);
    for(int i=0;i<T&&i<=n;i++)a[i]=fa[1][i];
    for(int i=0;i<T&&i<=m;i++)b[i]=fb[1][i];
    Ln(a,ea,T),Ln(b,eb,T);
//    cout<<(-1ll*1*eb[1]%mod+mod)%mod<<endl;
    a[0]=n,b[0]=m;
    for(int i=1;i<T;i++)a[i]=-1ll*ifac[i-1]*ea[i]%mod,b[i]=-1ll*ifac[i-1]*eb[i]%mod;
    mul(a,b,a,T);
    for(int i=1;i<T;i++)printf("%d\n",(1ll*fac[i]*a[i]%mod*iv%mod+mod)%mod);
}
```

---

## 作者：fallleaves01 (赞：1)

我太蒟蒻了，看了题解之后才会做QAQ

看到题目描述之后，可以根据题目列出式子
$$ans_t=\sum_{i=1}^{n}\sum_{j=1}^{m}(a_i+b_j)^t$$
将其展开为
$$ans_t=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=0}^{t}{t\choose k}a_i^kb_j^{t-k}$$
$$ans_t=\sum_{k=0}^{t}{t \choose k}\sum_{i=1}^{n}a_i^k\sum_{j=1}^{m}{b_j^{t-k}}$$
再把组合数拆开为
$$ans_t=\sum_{k=0}^{t}{\frac{t!}{k!(t-k)!}}\sum_{i=1}^{n}a_i^k\sum_{j=1}^{m}{b_j^{t-k}}$$
$$ans_t=t!\sum_{k=0}^{t}\sum_{i=1}^{n}\frac{a_i^k}{k!}\sum_{j=1}^{m}{\frac{b_j^{t-k}}{(t-k)!}}$$
这里就表现出了大家喜闻乐见的卷积形式。随后问题就变为了求$\sum_{i=1}^{n}{a_i^k}$。

这篇题解和以上两篇前面的推导过程是完全相同的，不同之处在于我看了两种不同的做法之后比较喜欢生成函数这种简单易懂的做法，但是那篇题解中求生成函数的和的方法并没有讲得很清楚，~~而且我太菜了不会通分啊~~，因此我根据第一篇题解的思路使用生成函数推导了一遍。

首先，我们要求的是：
$$\sum_{i=1}^{n}{a_i^k}$$
对于一个$i$，可以使用等比数列求和公式求出数列$1,a_i,a_i^2...a_i^t$的生成函数$A_i(x)$。
$$A_i(x)=\sum_{j=0}^{t}{a_i^jx^j}=\frac{1}{1-a_ix}$$
则
$$F(x)=\sum_{i=1}^{n}{A_i(x)}=\sum_{i=1}^{n}{\frac{1}{1-a_ix}}$$
容易发现：
$$\ln^{'}(1-a_ix)=\frac{1}{1-a_ix}$$
代入得:
$$F(x)=\sum_{i=1}^{n}{\ln^{'}(1-a_ix)}$$
但是我们发现还是不能快速地计算，于是为了能够合并$ln$，我们将其变成这样：
$$(\ln(1-a_ix))^{'}=\frac{-a_i}{1-a_ix}$$
然后求
$$G(x)=\sum_{i=1}^{n}{\frac{-a_i}{1-a_ix}}$$

然后我们就可以愉快地计算
$$G(x)=\sum_{i=1}^{n}{(\ln(1-a_ix))^{'}}=(\ln(\prod_{i=1}^{n}(1-a_ix)))^{'}$$
其中$\prod_{i=1}^{n}(1-a_ix)$使用分治即可。

最后观察求得的$G(x)$，发现$F(x)=-xG(x)+n$，就搞定了。

和上面两篇题解的做法对比，首先，第二篇题解中的生成函数
$$F(x)=1+a_i^1x^1+a_i^2x^2+...+a_i^tx^t$$
被我们化成了
$$A(x)=-a_i^1-a_i^2x^1-...-a_i^tx^{t-1}$$
这依然是可以求出答案来的，而且合并的时候也不再需要通分了。

然后第一篇题解中求出来的式子
$$G(x)=\sum_{i=1}^{n}{\ln(a_ix+1)}=\sum_{i=1}^{n}{\frac{(-1)^{(k-1)}}{k}a_i^kx^k}$$
将$a_i$换为$-a_i$后变为
$$G(x)=\sum_{i=1}^{n}{\frac{(-1)^{(k-1)}}{k}(-a_i)^kx^k}=\sum_{i=1}^{n}{\frac{(-1)^{(k\times2-1)}}{k}a_i^kx^k}$$
$$G(x)=\sum_{i=1}^{n}{\frac{-a_i^k}{k}x^k}$$
求导：
$$G(x)=\sum_{i=1}^{n}{\frac{-a_i^kk}{k}x^{k-1}}=\sum_{i=1}^{n}{-a_i^kx^{k-1}}$$
然后就得到了上面的式子，这说明两个做法是完全等价的。~~废话，不然怎么都能A。~~

值得注意的是多项式求$\ln$时先求导再积分，但是求答案那里又求了一遍导，因此求$\ln$时可以省略积分那一步。

代码（写得丑请见谅）：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
const int M=998244353,N=262144;
int gti(void)
{
    char c=getchar();
    int ret=0,st=1;
    for (;!isdigit(c);c=getchar()) if (c=='-') st=-1;
    for (;isdigit(c);c=getchar()) ret=ret*10+c-'0';
    return ret*st;
}

int fpw(int a,int b)
{
    a%=M,b%=M-1;
    if (b<0) b+=M-1;
    int c=1;
    for (;b;b>>=1,a=1ll*a*a%M)
        if (b&1)
            c=1ll*c*a%M;
    if (c<0) c+=M;
    return c;
}

namespace Poly
{
    int id[N<<1];
    int init(int len)
    {
        int ret=0;
        for (;1<<ret<len;ret++);
        for (int i=0;i<1<<ret;i++)
            id[i]=id[i>>1]>>1|((i&1)<<(ret-1));
        return 1<<ret;
    }
    void ntt(int *a,int len,int tag=1)
    {
        for (int i=0;i<len;i++)
            if (id[i]>i)
                swap(a[i],a[id[i]]);
        for (int l=1;l<len;l<<=1)
        {
            int gl=fpw(3,tag*(M-1)/l/2);
            for (int st=0;st<len;st+=l<<1)
                for (int g=1,tmp,i=st;i<st+l;i++,g=g*1ll*gl%M)
                    tmp=a[i+l]*1ll*g%M,a[i+l]=(a[i]-tmp)%M,(a[i]+=tmp)%=M;
        }
        int rev=fpw(len,-(tag<0));
        for (int i=0;i<len;i++)
            a[i]=(1ll*rev*a[i]%M+M)%M;
    }
    void mul(int *ret,int *a,int *b,int len)
    {
        static int c[N<<1],d[N<<1],e[N<<1];
        copy(a,a+len,d),copy(b,b+len,e);
        ntt(d,len),ntt(e,len);
        for (int i=0;i<len;i++)
            c[i]=1ll*d[i]*e[i]%M;
        ntt(c,len,-1);
        copy(c,c+len,ret);
    }
    void inv(int *ret,int *a,int len)
    {
        static int c[N<<1],b[N<<1],b0[N<<1];
        if (len==1)
            ret[0]=fpw(a[0],-1);
        else
        {
            inv(b0,a,len>>1);
            int k=init(len<<1);
            copy(a,a+len,c);
            fill(c+len,c+k,0);
            fill(b0+(len>>1),b0+k,0);
            ntt(c,k),ntt(b0,k);
            for (int i=0;i<k;i++)
                b[i]=((b0[i]*2ll-1ll*b0[i]*b0[i]%M*c[i]%M)%M+M)%M;
            ntt(b,k,-1);
            copy(b,b+len,ret);
        }
    }
    void derv(int *ret,int *a,int len)
    {
        static int c[N<<1];
        for (int i=1;i<len;i++)
            c[i-1]=i*1ll*a[i]%M;
        c[len-1]=0;
        copy(c,c+len,ret);
    }
    void derln(int *ret,int *a,int len)
    {
        static int c[N<<1],d[N<<1],e[N<<1];
        derv(d,a,len),inv(e,a,len);
        init(len<<1);
        mul(c,d,e,len<<1);
        copy(c,c+len,ret);
    }
}

void work(int *ret,int *a,int len)
{
    static int pool[2][N<<4],*p,*q;
    p=pool[0],q=pool[1];
    for (int i=0,*j=p;i<len;i++,j+=4)
        j[0]=1,j[1]=(M-a[i])%M,j[2]=j[3]=0;
    for (int l=1;l<len;l<<=1)
    {
        int k=Poly::init((l+1)<<1);
        for (int *st=p;st<p+len*4;st+=l<<3)
        {
            Poly::mul(q+(st-p),st,st+(l<<2),k);
            fill(q+(st-p)+(l<<2),q+(st-p)+(l<<3),0);
        }
        swap(p,q);
    }
    copy(p,p+len,ret);
}

int a[N<<1],b[N<<1],f[N<<1],g[N<<1],fct[N<<1],ifc[N<<1];
int main(void)
{
    int n=gti(),m=gti(),rev=fpw(n*1ll*m%M,M-2);
    for (int i=0;i<n;i++)
        a[i]=gti();
    for (int i=0;i<m;i++)
        b[i]=gti();
    int k=Poly::init(n+1),l=Poly::init(m+1);
    work(f,a,k),work(g,b,l);
    int t=gti(),r=max(Poly::init(t+1),max(l,k));
    Poly::derln(f+1,f,r),Poly::derln(g+1,g,r);
    for (int i=1;i<r;i++)
        f[i]=(-f[i]+M)%M,g[i]=(-g[i]+M)%M;
    f[0]=n,g[0]=m,fct[0]=1;
    for (int i=1;i<r;i++)
        fct[i]=fct[i-1]*1ll*i%M;
    ifc[r-1]=fpw(fct[r-1],M-2);
    for (int i=r-2;i>=0;i--)
        ifc[i]=ifc[i+1]*(i+1ll)%M;
    for (int i=0;i<r;i++)
        f[i]=f[i]*1ll*ifc[i]%M,g[i]=g[i]*1ll*ifc[i]%M;
    Poly::init(r<<1);
    for (int i=r;i<=r<<1;i++)
        f[i]=g[i]=0;
    Poly::mul(f,f,g,r<<1);
    for (int i=0;i<=t;i++)
        if (i) printf("%lld\n",f[i]*1ll*fct[i]%M*rev%M);
    return 0;
}

```

---

## 作者：silverxz (赞：0)

题解都是清一色的$\ln$，这里提一个不用$\ln$的。式子就不推了，其他题解讲的都很清楚。

现在我们要解决的是$F(x) = \sum_{i=0}^n \sum_{j=0}^\infty a_i^j x^j$怎么快速计算。后面是个常用的级数$\frac{1}{1-x} = \sum_{i=0}^\infty x^i$，代入$a_ix$立刻得到$F(x)=\sum_{i=0}^n \frac{1}{1-a_i x}$。这里其他的题解都是注意到这个形式和对数的导数相近，去凑了一个导数。但其实这个形式已经可以直接分治了。

分治的过程并不是直接求得$F(x)$，而是求出一个通分之后的有理分式$\frac{P(x)}{Q(x)}$。假设分治之后左右两边得到的结果是$\frac{P_l{x}}{Q_l(x)},\frac{P_r(x)}{Q_r(x)}$，则

$$
\frac{P(x)}{Q(x)}=\frac{P_l(x)}{Q_l(x)}+\frac{P_r(x)}{Q_r(x)}=\frac{P_l(x)Q_r(x)+P_r(x)Q_l(x)}{Q_l(x)Q_r(x)}
$$

显然复杂度是$T(n)=2T(n/2)+O(n\lg n) = O(n \lg ^2 n)$，实际上应该比求对数的分治多了两倍的常数（3次NTT->6次NTT），但也不慢，合理实现不会被卡常。

代码主要关注`solve`函数，是分治的部分。其他都是板子。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cassert>
#include <algorithm>
#include <vector>
#define ll long long

inline int to2pow(int n) {
    int ret = 1;
    while(ret < n)  ret <<= 1;
    return ret;
}

template<int Modulo>
ll qpow(ll a, ll b) {
    ll ret = 1;
    for(; b; b >>= 1) {
        if(b&1)  ret = (ret*a) % Modulo;
        a = (a*a) % Modulo;
    }
    return ret;
}

ll qpow(ll a, ll b, int modulo) {
    ll ret = 1;
    for(; b; b >>= 1) {
        if(b&1)  ret = (ret*a) % modulo;
        a = (a*a) % modulo;
    }
    return ret;
}

template<int Modulo>
struct InvArr {
    static std::vector<int> inv;
    int operator[] (int index) {
        if(index >= (int)inv.size())  expand(index+1);
        return inv[index];
    }
    void expand(int size) {
        for(int i = inv.size(); i < size; ++i)
            inv.push_back((ll)(Modulo - Modulo/i) * inv[Modulo%i] % Modulo);
    }
};
template<int Modulo>
std::vector<int> InvArr<Modulo>::inv = {0, 1};

template<class T>
using Poly = std::vector<T>;

template<int Modulo, int Priroot = 3>
struct NTT {
    int expo, n;
    std::vector<int> ind;
    static std::vector<std::vector<int>> omega;

    NTT(int expo, bool): expo(expo), n(1<<expo), ind(n) {
        for(int i = 0; i < n; ++i)  ind[i] = (ind[i>>1]>>1) | ((i&1)<<(expo-1));
        if((int)omega.size() < expo)  setOmega();
    }
    NTT(int n_ = 1): expo(0), n(1) {
        while(n < n_) { n <<= 1; ++expo; }
        ind.resize(n);
        for(int i = 0; i < n; ++i)  ind[i] = (ind[i>>1]>>1) | ((i&1)<<(expo-1));
        if((int)omega.size() < expo)  setOmega();
    }

    void setOmega() {
        int oldsz = omega.size();
        omega.resize(expo);
        for(int i = oldsz, half = (1<<i); i < expo; ++i, half <<= 1) {
            ll unit = qpow<Modulo>(Priroot, (Modulo-1)/(half<<1));
            omega[i].resize(half);
            omega[i][0] = 1;
            for(int j = 1; j < half; ++j) omega[i][j] = omega[i][j-1]*unit % Modulo;
        }
    }

    void doubled() {
        for(int i = 0; i < n; ++i)  ind[i] <<= 1;
        ind.resize(n<<=1);  ++expo;
        for(int i = n>>1; i < n; ++i)  ind[i] = (ind[i>>1]>>1) | ((i&1)<<(expo-1));
        if((int)omega.size() < expo)  setOmega();
    }

    void ntt(Poly<int> &pol, bool isINTT = false) const {
        if((int)pol.size() < n)  pol.resize(n);
        for(int i = 0; i < n; ++i) if(i < ind[i]) std::swap(pol[i], pol[ind[i]]);
        for(int half = 1, e = 0; half < n; ++e, half <<= 1) {
            for(int i = 0; i < n; i += (half<<1)) {
                for(int k = 0; k < half; ++k) {
                    int x = pol[i+k], y = 1ll * omega[e][k] * pol[i+k+half] % Modulo;
                    pol[i+k]      = (x + y) % Modulo;
                    pol[i+k+half] = (x - y + Modulo) % Modulo;
                }
            }
        }
        if(isINTT) {
            ll invn = qpow<Modulo>(n, Modulo-2);
            std::reverse(pol.begin()+1, pol.begin()+n);
            for(int i = 0; i < n; ++i) pol[i] = pol[i] * invn % Modulo;
        }
    }

    void intt(Poly<int> &pol) const { ntt(pol, 1); }

    void swap(NTT<Modulo, Priroot> &ot) {
        expo ^= ot.expo ^= expo ^= ot.expo;
        n ^= ot.n ^= n ^= ot.n;
        std::swap(ind, ot.ind);
    }
};
template<int Modulo, int Priroot>
std::vector<std::vector<int>> NTT<Modulo, Priroot>::omega = {};

template<int Modulo, int Priroot = 3>
inline const NTT<Modulo, Priroot>& newNTT(int expo, bool) {
    static bool inited[25] = {};
    static NTT<Modulo, Priroot> *arr = new NTT<Modulo, Priroot>[25](); // 1<<24 = 16,777,216
    if(inited[expo])  return arr[expo];
    inited[expo] = true;
    return arr[expo] = NTT<Modulo, Priroot>(expo, 0);
}

template<int Modulo, int Priroot = 3>
inline const NTT<Modulo, Priroot>& newNTT(int n) {
    int expo = 0;
    while((1<<expo) < n)  ++expo;
    return newNTT<Modulo, Priroot>(expo, 0);
}

template<int Modulo, int Priroot = 3>
void polyInv(const Poly<int> &pol, Poly<int> &ret, int n = -1) {
    if(n == -1)  n = pol.size();
#ifdef __POLY_OK__
    assert(n > 0 && pol[0]); // no solution
#endif
    int m = to2pow(n); if((int)ret.size() < m) ret.resize(m);
    ret[0] = qpow<Modulo>(pol[0], Modulo-2);
    Poly<int> f(m), r(m);
    for(int len = 2, cond = std::min(2, n); len <= m; len <<= 1, cond = std::min(len, n)) {
        const auto &ntt = newNTT<Modulo, Priroot>(len);
        for(int i = 0; i < cond; ++i)  f[i] = pol[i];
        for(int i = 0; i < (len>>1); ++i)  r[i] = ret[i];
        ntt.ntt(f);  ntt.ntt(r);
        for(int i = 0; i < len; ++i)  f[i] = 1ll*f[i]*r[i]%Modulo;
        ntt.intt(f);  std::fill(f.begin(), f.begin()+(len>>1), 0);  ntt.ntt(f);
        for(int i = 0; i < len; ++i)  f[i] = 1ll*f[i]*r[i]%Modulo;
        ntt.intt(f);
        for(int i = (len>>1); i < len; ++i)  ret[i] = f[i] ? Modulo-f[i] : 0;
    }
}

#define mod 998244353
void solve(Poly<int> &pol, Poly<int> &up, Poly<int> &down, int l, int r) {
    if(l == r-1) {
        down[0] = up[0] = 1;
        down[1] = (mod-pol[l]) % mod;
        return ;
    }
    const auto &ntt = newNTT<mod>(r-l+1);
    int mid = (l+r) >> 1;
    solve(pol, up, down, l, mid);
    Poly<int> up2(ntt.n), down2(ntt.n);
    solve(pol, up2, down2, mid, r);
    ntt.ntt(up);  ntt.ntt(down);  ntt.ntt(up2);  ntt.ntt(down2);
    for(int i = 0; i < ntt.n; ++i) {
        up[i] = (1ll*up[i]*down2[i]+1ll*up2[i]*down[i]) % mod;
        down[i] = (1ll*down[i]*down2[i]) % mod;
    }
    ntt.intt(up);  ntt.intt(down);
}

int main() {
    int n, m, t;
    scanf("%d %d", &n, &m);
    Poly<int> p1(n), p2(m), u1(n), u2(m), d1(n+1), d2(m+1), i1, i2;
    for(int i = 0; i < n; ++i)  scanf("%d", &p1[i]);
    for(int i = 0; i < m; ++i)  scanf("%d", &p2[i]);
    scanf("%d", &t);
    solve(p1, u1, d1, 0, n);  solve(p2, u2, d2, 0, m);
    u1.resize(t+1);  u2.resize(t+1);  d1.resize(t+1);  d2.resize(t+1);
    polyInv<mod>(d1, i1, t+1);  polyInv<mod>(d2, i2, t+1);
    const auto &ntt = newNTT<mod>(2*t+1);
    ntt.ntt(u1);  ntt.ntt(u2);  ntt.ntt(i1);  ntt.ntt(i2);
    for(int i = 0; i < ntt.n; ++i) {
        u1[i] = (1ll*u1[i]*i1[i]) % mod;
        u2[i] = (1ll*u2[i]*i2[i]) % mod;
    }
    ntt.intt(u1);  ntt.intt(u2);
    u1.resize(t+1);  u2.resize(t+1);
    InvArr<mod> inv;
    for(int i = 0, fac = 1; i <= t; ++i, fac = 1ll*fac*inv[i]%mod) {
        u1[i] = (1ll*u1[i]*inv[n]%mod * fac) % mod;
        u2[i] = (1ll*u2[i]*inv[m]%mod * fac) % mod;
    }
    ntt.ntt(u1);  ntt.ntt(u2);
    for(int i = 0; i < ntt.n; ++i) {
        u1[i] = (1ll*u1[i]*u2[i]) % mod;
    }
    ntt.intt(u1);
    for(int i = 1, fac = 1; i <= t; ++i, fac = (1ll*fac*i%mod))
        printf("%lld\n", 1ll*u1[i]*fac%mod);
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：0)

## 题意
给出两个序列$a,b$，长度分别为$n,m$，请求出$x=1,2,\ldots,t$，下式的值
$$\dfrac{\sum_{i=1}^n\sum_{j=1}^m(a_i+b_j)^x}{nm}$$
## 题解
~~看到还能发就来水一篇~~

本人数学比较菜有错误请联系这个屑

我们记$x$的答案为$ans_x$，那么就有：
$$ans_x\times nm=\sum_{i=1}^n\sum_{j=1}^m(a_i+b_j)^x$$
好像也做不了什么，那就把$(a_i+b_j)^x$用二项式定理展开再说：
$$ans_x\times nm=\sum_{i=1}^n\sum_{j=1}^m\sum_{k=0}^x\tbinom{x}{k}a_i^{k}b_j^{x-k}$$
交换顺序，再把万恶的组合数展开。
$$ans_x\times nm=\sum_{k=0}^x\sum_{i=1}^n\sum_{j=1}^m\tbinom{x}{k}a_i^{k}b_j^{x-k}=\sum_{k=0}^x\sum_{i=1}^n\sum_{j=1}^m\frac{x!}{k!(x-k)!}a_i^{k}b_j^{x-k}$$

$$\frac{ans_x\times nm}{x!}=\sum_{k=0}^x\frac{\sum_{i=1}^na_i^k}{k!}\frac{\sum_{j=1}^mb_j^{x-k}}{(x-k)!}$$

如果我们记$A(k)=\sum_{i=1}^na_i^k$,$B(k)=\sum_{i=1}^mb_i^k$，那么就有：

$$\frac{ans_x\times nm}{x!}=\sum_{k=0}^x\frac{A(k)}{k!}\frac{B(x-k)}{(x-k)!}$$

这样卷积就很明显了。

于是剩下的问题就变成求$A(0),A(1),A(2),\ldots,A(t)$，考虑构造下面一个多项式：
$$F(x)=\prod_{i=1}^n(1+a_ix)$$
这个可以分治得到，复杂度~~显然正确~~

两边同取$\ln$得到：

$$\ln F(x)=\sum_{i=1}^n\ln(1+a_ix)$$

两边求导：

$$(\ln F(x))^\prime=\sum_{i=1}^n\frac{a_i}{1+a_ix}$$

又知，$\frac{1}{1+a_ix}=\frac{1}{1-(-a_ix)}$，即为一个首项为$1$，公比为$-a_ix$的数列的和，那么$\frac{1}{1+a_ix}=\sum_{j=0}^{+\infty}(-a_ix)^j$

带带带回去：

$$(\ln F(x))^\prime=\sum_{i=1}^na_i\sum_{j=0}^{+\infty}(-a_ix)^j$$

再积回去：

$$\ln F(x)=\int \sum_{i=1}^na_i\sum_{j=0}^{+\infty}(-a_ix)^jdx=\sum_{i=1}^na_i\sum_{j=1}^{+\infty}\frac{(-a_i)^{j-1}x^j}{j}$$

$$=\sum_{i=1}^n\sum_{j=1}^{+\infty}\frac{(-1)^{j-1}a_i^{j}x^j}{j}=\sum_{j=1}^{+\infty}\frac{(-1)^{j-1}x_j}{j}\sum_{i=1}^na_i^j=\sum_{j=1}^{+\infty}\frac{(-1)^{j-1}A(j)}{j}x^j$$

于是此时求出$A$也不难了，随便乘一下就好了。

$B$也同理。把$A,B$带回去，不难得到答案。
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
    #ifdef slow
    inline int getc(){return getchar();}
    #else
    char buf[1<<21],*p1=buf,*p2=buf;
    inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    #endif
    template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+(ch-48);ch = getc();}if(f)t=-t;
	}
    template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
	template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
	modint<mod> &operator++(int){return *this+=1;}
};
const int N=4e6+5;

const int mod=998244353;
const modint<mod> GG=3,Ginv=modint<mod>(1)/3,I=86583718;
struct poly{
	vector<modint<mod>>a;
	modint<mod>&operator[](int i){return a[i];}
	int size(){return a.size();}
	void resize(int n){a.resize(n);}
};
int rev[N];
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){int n=1<<k;for(int i=0;i<n;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));}
inline void ntt(poly&a,int k,int typ){
	int n=1<<k;
	for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int mid=1;mid<n;mid<<=1){
		modint<mod> wn=(typ>0?GG:Ginv)^((mod-1)/(mid<<1));
		for(int r=mid<<1,j=0;j<n;j+=r){
			modint<mod> w=1;
			for(int k=0;k<mid;k++,w=w*wn){
				modint<mod> x=a[j+k],y=w*a[j+k+mid];
				a[j+k]=x+y,a[j+k+mid]=x-y;
			}
		}
	}
	if(typ<0){
		modint<mod> inv=modint<mod>(1)/n;
		for(int i=0;i<n;i++)a[i]*=inv;
	}
}
inline poly one(){poly a;a.a.push_back(1);return a;}
poly operator +(poly a,poly b){
	int n=max(a.size(),b.size());a.resize(n),b.resize(n);
	for(int i=0;i<n;i++)a[i]+=b[i];return a;
}
poly operator -(poly a,poly b){
	int n=max(a.size(),b.size());a.resize(n),b.resize(n);
	for(int i=0;i<n;i++)a[i]-=b[i];return a;
}
inline poly operator*(poly a,poly b){
	int n=a.size()+b.size()-1,k=ext(n);
	a.resize(1<<k),b.resize(1<<k),init(k);
	ntt(a,k,1);ntt(b,k,1);for(int i=0;i<(1<<k);i++)a[i]*=b[i];
	ntt(a,k,-1),a.resize(n);return a;
}
inline poly operator*(poly a,modint<mod> b){for(int i=0;i<a.size();i++)a[i]*=b;return a; }
inline poly operator/(poly a,modint<mod> b){for(int i=0;i<a.size();i++)a[i]/=b;return a; }
inline poly operator-(poly a){for(int i=0;i<a.size();i++)a[i]=-a[i];return a; }
poly inv(poly F,int k){
	int n=1<<k;F.resize(n);
	if(n==1){F[0]=modint<mod>(1)/F[0];return F;}
	poly G,H=inv(F,k-1);
	G.resize(n),H.resize(n<<1),F.resize(n<<1);
	for(int i=0;i<n/2;i++)G[i]=H[i]*2;
	init(k+1),ntt(H,k+1,1),ntt(F,k+1,1);
	for(int i=0;i<(n<<1);i++)H[i]=H[i]*H[i]*F[i];
	ntt(H,k+1,-1),H.resize(n);
	for(int i=0;i<n;i++)G[i]-=H[i];return G;
}
inline poly inv(poly a){
	int n=a.size();
	a=inv(a,ext(n)),a.resize(n);return a;;
}
inline poly deriv(poly a){//求导 
	int n=a.size()-1;
	for(int i=0;i<n;i++)a[i]=a[i+1]*(i+1);
	a.resize(n);return a;
}
inline poly inter(poly a){//求原 
	int n=a.size()+1;a.resize(n);
	for(int i=n;i>=1;i--)a[i]=a[i-1]/i;
	a[0]=0;return a;
}
inline poly ln(poly a){
	int n=a.size();
	a=inter(deriv(a)*inv(a));
	a.resize(n);return a;
}
#define mid (l+r>>1)
inline poly F(int l,int r,int *a){
	poly G;
	if(l==r){G.resize(2);G[0]=1;G[1]=a[l];}
	else{
		G=F(l,mid,a)*F(mid+1,r,a);
	}
	//printf("[%d,%d] ",l,r);for(int i=0;i<G.size();i++)printf("%d ",G[i].x);puts("");
	return G;
}
int n,m,t,a[N],b[N];
poly A,B;
modint<mod>fac[N];
signed main(){
	fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i;
	in::read(n,m);
	for(int i=1;i<=n;i++)in::read(a[i]);
	for(int i=1;i<=m;i++)in::read(b[i]);
	in::read(t);
	A=F(1,n,a);A.resize(t+1);A=ln(A);
	A[0]=n;for(int i=1;i<=t;i++)if(i&1)A[i]*=i;else A[i]*=i,A[i]=-A[i];
	B=F(1,m,b);B.resize(t+1);B=ln(B);
	B[0]=m;for(int i=1;i<=t;i++)if(i&1)B[i]*=i;else B[i]*=i,B[i]=-B[i];
	//for(int i=0;i<=t;i++)cout<<A[i].x<<" ";cout<<endl;
	//for(int i=0;i<=t;i++)cout<<B[i].x<<" ";cout<<endl;
	for(int i=0;i<=t;i++)A[i]/=fac[i];
	for(int i=0;i<=t;i++)B[i]/=fac[i];
	poly ans=A*B;for(int i=0;i<=t;i++)ans[i]=(ans[i]*fac[i]/n)/m;
	for(int i=1;i<=t;i++)cout<<ans[i].x<<endl;
}
```

---

## 作者：Sym_Je (赞：0)

# P4705 玩游戏  
## 题目大意  
给你连个序列 $a_i~b_i$ . 和 $k$ ,分别问你从 $a,b$ 中取出一个数之和的 $1\to k$ 次幂的期望 。   
## $solution$   
首先这还是让我们求   

$$\frac{1}{nm}\sum_{i=1}^{n}\sum_{j=1}^{m}(a_i+b_j)^t~(t\in[1,k])$$   

如果我们直接暴力求出来显然复杂度很糟糕 $O(n^2)$ 级别的 。所以我们考虑改变他的形式 。    
$$\frac{1}{nm}\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{z=0}^{t}C_{t}^{z}~a_i^z~b_j^{t-z}~(t\in[1,k])$$  

$$\frac{1}{nm}\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{t=0}^{z}\frac{t!}{(t-z)!z!}~a_i^z~b_j^{t-z}$$    

$$\frac{t!}{nm}\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{t=0}^{z}\frac{b_j^{t-z}}{(t-z)!}~\frac{a_i^z}{z!}~$$     

我们设 $A_k=\sum_{t=0}^{k}a^t$   
呢么多项式 $A$ 为其的生成函数 。  
$B$ 同理 。   
呢么答案就是   

$$\frac{t!}{nm}\sum_{t=0}^{z}\frac{B_{t-z}}{(t-z)!}~\frac{A_z}{z!}~$$    

这就是一个卷积的形式， 所以只要我们可以快速求出 $A,B$ 呢么复杂度就是 $O(nlogn)$ ，下面除阶乘最后处理一下就好了。  

我们要求   
$A_k=\sum_{t=1}^{k}a_i^t=\frac{1}{1-a_ix}$ 的生成函数 $A$ .    
$A=\sum_{i=1}^{n}\frac{1}{1-a_ix}$  

好，我就直接说套路了 。     

$ln(1-a_ix)'=\frac{1}{1-a_ix}$  
$A=\sum_{i=1}^{n}ln'(1-a_ix)$   
但是 $ln'(1\-a_ix)$ 无法快速合并 。 
所以我们找一个可以快速合并的 ，且与其相关 ，可以互相转换的 。 
我们设     

$G=\sum_{i=1}^{n}ln(1-a_ix)'$    
$G=ln(\Pi(1-a_ix))'$    
$G=\sum_{i=1}^n\frac{-a_i}{1-a_ix}$  
$A=Gx+n$

显然我们求导只是将其降低一维，所以这样是不影响答案的 。他同时改变了维度罢了 。   
后面这个 $\Pi(1-a_ix)$ 我们直接分治做出来好了 ，
最后我们求出 $G$ 再转成 $A$ ,对于 $B$ 的话同理  。    

最后 $A,B$ 第 $i$ 位 $ * inv[i!] $ 好了 。     

代码为了方便调试所以有很多数组都可以省略 ， 所以空间可能会有点大 。

* $code$   

```cpp


// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long 
#define lb(x) (x&(-x))
#define dec(x,y) (x-y+mod)%mod
#define add(x,y) (x+y)%mod
#define mul(x,y) (x*y)%mod  
#define de() cout<<"2333" 
using namespace std;
const ll maxn=2e6+10;
const ll mod=998244353,G=3,Gi=332748118;

ll poww(ll x,ll k) {
    ll ans=1;
    while(k) {
        if(k&1) ans=mul(ans,x);
        x=mul(x,x);
        k>>=1;
    }
    return ans;
}
inline ll read() {
    ll data=0,f=1;char c=getchar();
    while('0'>c||c>'9') {
        if(c=='-') f=-1;c=getchar();
    }while('0'<=c&&c<='9') {
        data=data*10+c-'0';c=getchar(); 
    }return data*f;
}
ll n;
ll aa[maxn],bb[maxn],cc[maxn],rev[maxn],A[maxn],B[maxn],l,limit;
void NTT(ll *A,ll type,ll len) {
    l=0,limit=1;
    while(limit<=len) l++,limit<<=1;
    for(ll i=0;i<limit;++i) rev[i]=(rev[i>>1]>>1)|((1&i)<<(l-1));
    for(ll i=0;i<limit;++i) if(rev[i]>i) swap(A[i],A[rev[i]]);
    for(ll mid=1;mid<limit;mid<<=1) {
        ll Wn=poww(type==1?G:Gi,(mod-1)/(mid<<1));
        for(ll R=mid<<1,j=0;j<limit;j+=R) {
            ll w=1;
            for(ll k=0;k<mid;++k,w=mul(w,Wn)) {
                ll x=A[j+k],y=mul(w,A[j+k+mid]);
                A[j+k]=add(x,y);A[j+k+mid]=dec(x,y);
            }
        }
    }
    if(type==-1) {
        ll inv=poww(len<<1,mod-2);
        for(ll i=0;i<limit;++i) {
            A[i]=mul(A[i],inv);
        }
    }
}
void Inv(ll *a,ll *b,ll len) {
    if(len==1) {
        b[0]=poww(a[0],mod-2);
        return ;
    }
    Inv(a,b,len>>1); 
    for(ll i=0;i<(len<<1);++i) A[i]=B[i]=0;
    for(ll i=0;i<len;++i) A[i]=a[i],B[i]=b[i];
    NTT(A,1,len);NTT(B,1,len);
    for(ll i=0;i<=limit;++i) A[i]=mul(mul(A[i],B[i]),B[i]);
    NTT(A,-1,len);
    for(ll i=0;i<len;++i) b[i]=dec(mul(2,b[i]),A[i]);
}
ll AA[maxn],BB[maxn]; 

ll inv[maxn];
void Direv(ll *A,ll *B,ll len){
    for(ll i=1;i<len;++i) B[i-1]=mul(A[i],i);B[len-1]=0; 
}
void Inter(ll *A,ll *B,ll len){
    for(ll i=1;i<len;++i) B[i]=mul(A[i-1],inv[i]);B[0]=0; 
}
void Ln(ll *a,ll *b,ll len){
    Direv(a,AA,len),Inv(a,BB,len);
    NTT(AA,1,len),NTT(BB,1,len);
    for(ll i=0,l=len<<1;i<l;++i) AA[i]=mul(AA[i],BB[i]);
    NTT(AA,-1,len),Inter(AA,b,len<<1);
    for(ll i=0,l=len<<1;i<l;++i) AA[i]=BB[i]=0;
}
void init(ll limit){
    for(ll i=0,l=limit<<1;i<=l;++i) inv[i]=poww(i,mod-2);
}
ll F[maxn];
ll a[maxn],b[maxn],Fa[maxn],Fb[maxn],Ga[maxn],Gb[maxn];
ll iv[maxn],m,K;
void wo(ll n,ll *aa,ll *A) {
    ll len=1; while(len<n) len<<=1; ll *f[maxn];
    for(ll i=1;i<=len;++i){f[i]=new ll[lb(i)<<2];// new 函数表示动态开出long long 类型空间为 (lb(i)<<2)
    f[i][0]=1; f[i][1]=mod-aa[i];}
    for(ll l=1;l<len;l<<=1){ 
        for(ll j=l*2;j<=len;j+=l*2){
        	NTT(f[j-l],1,l*2); NTT(f[j],1,l*2);
        	for(ll i=0;i<=limit-1;++i) f[j][i]=f[j][i]*f[j-l][i]%mod; NTT(f[j],-1,l*2);
    	}
    }
    for(ll i=0;i<=n;++i) A[i]=f[len][i];
    return;
}

ll MAX;
void Mul(ll *A,ll *B,ll *C,ll n) {
    NTT(A,1,n);
    NTT(B,1,n);
    for(ll i=0;i<=limit;++i) C[i]=A[i]*B[i]%mod;
    NTT(C,-1,n); 
}
ll jc[maxn],ANS[maxn],INV,GGa[maxn],GGb[maxn];
int main()
{
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;++i) a[i]=read();
    for(ll i=1;i<=m;++i) b[i]=read();
    scanf("%lld",&K);
    MAX=max(K+1,max(n,m));
    limit=1;
    while(limit<=MAX) limit<<=1;
    init(limit);
    jc[0]=1;
    for(ll i=1;i<=limit+1;++i) jc[i]=jc[i-1]*i%mod;
    INV=poww(n*m%mod,mod-2)%mod;
    iv[limit+1]=poww(jc[limit+1],mod-2);
    for(int i=limit;i;i--) iv[i]=iv[i+1]*(i+1)%mod;
    iv[0]=1; 
    wo(n+1,a,GGa);
    limit=1;
    while(limit<=MAX) limit<<=1;
    Ln(GGa,Ga,limit<<1);limit=1;while(limit<=MAX) limit<<=1;
    for(ll i=1;i<=limit;++i) Ga[i-1]=1ll*Ga[i]*(i)%mod;
    Fa[0]=n;
    for(ll i=1;i<limit;i++){Fa[i]=1ll*(mod-Ga[i-1]+mod)%mod*iv[i]%mod;} 
    wo(m+1,b,GGb);
    limit=1;
    while(limit<=MAX) limit<<=1;
    Ln(GGb,Gb,limit<<1);limit=1;while(limit<=MAX) limit<<=1;
    for(ll i=0;i<=limit;++i) Gb[i]=Gb[i+1]*(i+1)%mod; 
    Fb[0]=m; 
    for(ll i=1;i<=limit;++i) Fb[i]=1ll*(mod-Gb[i-1]+mod)*iv[i]%mod;//for(ll i=0;i<=limit;++i) cout<<Fb[i]<<" ";puts("");
    Mul(Fa,Fb,ANS,limit<<1);

    for(ll i=1;i<=K;++i)ANS[i]=1ll*ANS[i]*INV%mod*jc[i]%mod;
    for(ll i=1;i<=K;++i) cout<<ANS[i]<<"\n";
    return 0;
}





```









---


# [Code+#8 决赛] 生成树

## 题目背景

搬运自 [Code+ #8 决赛](https://gitlink.org.cn/thusaa/codeplus8final)。

## 题目描述

小 I 既喜欢生成树，又喜欢他的幸运数字 $k$，所以小 I 想造出一个**可以有重边自环**的有向图，点从 $1$ 到 $n$ 编号，使得以 $1$ 为根的**外向**生成树数量**恰好**为 $k$。但小 I 太穷了，手边只有 100 条有向边，所以他请求你的帮助，请你帮他造出这样的一个有向图，或者告诉他这是不可能的。

## 说明/提示

**【数据范围】**

对于所有数据，$1 \le q \le 100$，$1 \leq k \le 7 \times 10^{15}$。

本题采用 $\text{Subtask}$ 捆绑测试。

|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$3$|$k\le100$|
|$2$|$7$|存在整数 $0 \le a,b \le 20$ 使得 $k = 2^a3^b$|
|$3$|$10$|$q=1, k = 101$|
|$4$|$10$|$k \le 10^3$|
|$5$|$7$|$k \le 10^4$|
|$6$|$7$|$k \le 10^6$|
|$7$|$8$|$k \le 3 \times 10^7$|
|$8$|$8$|$k \le 8 \times 10^9$|
|$9$|$10$|$k \le 10^{12}$|
|$10$|$10$|$k \le 3 \times 10^{14}$|
|$11$|$20$|$k \le 7 \times 10^{15}$|

## 样例 #1

### 输入

```
2
1
7```

### 输出

```
1 0
3 6
1 2
1 2
2 3
2 3
1 3
3 2```

# 题解

## 作者：dAniel_lele (赞：1)

神秘 adhoc。

首先你考虑一下最大多少，然后你会发现每个非 $1$ 点至少选择一条入边，那么最大值就是 $3^{32}\times 4$，刚好略大于 $k$ 的那个限制。由此猜测，不会有 $-1$，他就是让我们构造的。

然后你会发现你搓个 DAG 答案必然是每个点入边数量之积，所以你不能搓 DAG。

这引导我们去搓一个环。对于一个单独的环（$2\sim n$ 组成的环），外向生成树数量是每个点入边之积减去环上两两之间边的积。

但是这样还是不够，我们只能弄出 $3^{32}\times 4-\prod x_i$，其中 $x_1,x_2,\dots,x_{32}\leq 3$，$x_{33}\leq 4$。

考虑搓一个环，然后加一条 $2\to 4$ 的边的后果。此时方案数是总数减去出现 $2,3,4,\dots,n$ 这个环的方案数再减去 $2,4,5,\dots,n$ 这个环的方案数。也就是，减去 $\prod x_i+3\prod_{i\neq 3}x_i$。

我们钦定 $x_i=1$，即可得到 $1+3$。

然后再加上 $2\to 5$ 的边，以及加两条 $2\to 4$ 的边，通过一定计算会发现可以得到 $1+3^2$ 和 $1+3\times 2$。

这启发我们求出要减去的部分，然后对减去的部分三进制分解，依次加入边。也就是，对于第 $i$ 位，$2\to i+2$ 的边数为减去部分第 $i$ 位的值。

构造会有一些 corner case，所以可以找到比 $n$ 大的第一个 $3^x$ 或 $3^x\times 2$ 或 $3^x\times 4$ 然后去构造。具体细节可以看代码。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
int a[40],b[40],c[40],cnt;
void solve(){
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	int n; cin>>n;
	if(n==1){
		cout<<1<<" "<<0<<"\n";
		return ;
	}
	int now=1,cnted=0;
	cnt=0;
	while(now<n){
		if(now*2>=n){
			now*=2;
			a[++cnt]=3;
			a[1]=2;
			cnted+=2;
		}
		else{
			now*=3;
			a[++cnt]=3;
			cnted+=3;
		}
	}
	if(now==n){
		cout<<cnt+1<<" "<<cnted<<"\n";
		for(int i=1;i<=cnt;i++){
			for(int j=1;j<=a[i];j++) cout<<1<<" "<<i+1<<"\n";
		}
		return ;
	}
	if(cnted==101){
		cnt--;
		a[1]=3;
		a[cnt]=4;
		cnted=100;
	}
	for(int i=1;i<=cnt;i++) c[i]=1;
	c[2]=0;
	int ex=now-n,it=2;
	while(ex){
		int md=ex%3; ex/=3;
        b[it]=md;
		it++;
	}
	cout<<cnt+1<<" "<<cnted<<"\n";
	for(int i=1;i<=cnt;i++){
		if(i==1){
			if(a[1]==3) cout<<1<<" "<<2<<"\n";
			cout<<1<<" "<<2<<"\n";
			cout<<cnt+1<<" "<<2<<"\n";
			continue;
		}
		for(int j=1;j<=c[i];j++) cout<<i<<" "<<i+1<<"\n";
		for(int j=1;j<=b[i];j++) cout<<2<<" "<<i+1<<"\n";
		for(int j=1;j<=a[i]-c[i]-b[i];j++) cout<<1<<" "<<i+1<<"\n";
	}
}
signed main(){
	int t; cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

这也太牛了。

首先 $7\times 10^{15}$ 看上去就很奇怪。我们分析一下一场图地答案不大于 $\prod_{i=2}^nin_i$，即每个点从所有入边中随便选一个。由于 $\sum in_i\leq 100$。所以 $\prod_{i=2}in_i\leq 4·3^{32}$ 刚好略大于 $7\times 10^{15}$。于是我们猜想肯定存在。

考虑构造方法。一开始肯定是先尝试搞个 DAG。但是 DAG 外向树个数刚好是 $\prod in_i$。很显然我们倒闭了。

考虑不是 DAG 的情况下，外向树个数就是 $\prod in_i-C$。其中 $C$ 是每个点随便选一个入边选出了环的图的个数。

我们先假设 $in_2=in_3=\dots=in_{33}=3,in_{34}=in_{35}=2$。则 $C=4·3^{32}-n$。考虑这个 $C$ 怎么算。

有多个环太难了。考虑如果我们所有可能的环必须经过一个点。那么我们的工作量会大大减少。不妨设所有点必需经过 $35$。

首先对每个 $i\to i+1$ 连一条边。然后考虑每个点会余下 $1\sim 2$ 条入边分配，怎么处理。

首先如果钦定这条边不会成为环上的边，就直接 $1\to i$。否则就 $35\to i$。考虑 $35\to i$ 这种边对 $C$ 的贡献。

由于 $35\to i$，$i\to 35$ 只能是 $i\to i+1\to i+2\to\dots\to n$。所以 $i\sim n$ 贡献是 $1$。然后 $1\sim i-1$ 不会出现环，所以贡献是 $\prod_{t=2}^{i-1}in_t$。

然后你发现这玩意刚好满足进制拆分。就做完了。

---


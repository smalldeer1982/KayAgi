# 巅峰手速

## 题目背景

“老妹儿啊，今天该你做家务吧……”

龙牙哥于是自愿体验了阿绫为他量身定制的游戏，把做家务的命运推上赌桌——

## 题目描述

阿绫给了龙牙哥 $n$ 张卡牌，它们已经整齐码在了桌上，从左至右第 $i$ 张的卡牌上的数字为 $a_i$，龙牙哥需要通过一系列操作让卡牌上的数字从左至右**不降**。每次操作中，他可以抽出从左至右第 $k$（$k$ 为给定常数）张卡牌，然后将它放在这些牌的最左侧或最右侧。请帮助龙牙判断自己是否有可能完成目标，如果能，请顺便告诉他一种比较简单的操作方案。

## 说明/提示

### 样例解释

对于第一组样例：

将第二张卡牌（$2$）放到最左侧，卡牌数字变为 $2,3,1$。  
将第二张卡牌（$3$）放到最右侧，卡牌数字变为 $2,1,3$。  
将第二张卡牌（$1$）放到最左侧，卡牌数字变为 $1,2,3$。

此时卡牌上的数字不降，操作结束。

### 得分计算方式

在一个测试数据中，是否有解判断正确可获得 $20\%$ 的分数。如果操作方案也正确，则会跟据操作方案的行数（不包含最后一行的 `o`）按下表得分。

| 行数 | 得分 |
| :-----------: | :-----------: |
| $>7n$ | $40\%$ |
| $\le7n$ | $60\%$ |
| $\le5n$ | $80\%$ |
| $\le3n$ | $100\%$ |

一个测试点的得分是其中每组测试数据得分的最小值。

### 注意事项

为了方便选手调试，本题下发了校验器用于本地自测校验得分，使用方法见后。需要注意下发的校验器与实际使用校验器的可能并不相同。我们保证实际使用的校验器在输出的操作序列行数不超过 $7n$ 的情况下用时不超过 500ms。

如果输出格式有误，你将会获得 $0$ 分。因此，如果你会判断是否有解但无法给出操作方案，也需要在判断有解后输出一行 `o` 表示操作结束。

为了避免无意义的反复操作，你需要保证每一次操作均有 $1\leq c \leq n$，否则将会获得 $0$ 分。

### 校验器使用方法

下载文件 `testlib.h` 与 `checker.cpp` 并将其置于同一文件夹。在该目录下运行命令 `g++ checker.cpp -o checker -std=c++14` 编译得到可执行文件 `checker.exe` (windows) / `checker` (linux)。

假如自测输入为 `in.txt`，程序输出为 `out.txt`。由于校验器无法判断是否有解，你需要创建一个答案文件（假如叫作 `ans.txt`），并在其中每行一个地写入每组数据的有解情况。例如对于样例，答案文件应为

```plain
Yes
No
No
Yes
Yes
```

将上述提到的输入、输出、答案三个文件与刚刚编译出来的校验器可执行文件置与同一文件夹。

- 如果是 Windows Powershell，输入 `.\checker.exe in.txt out.txt ans.txt`。

- 如果是 Linux 终端，输入 `./checker in.txt out.txt ans.txt`。

校验器有三种可能的输出：`wrong answer` / `ok` / `points x`，分别表示对于该测试点你没有分 / 满分 / 获得了占比为 `x` 的分。

### 数据规模与约定

**本题采用捆绑测试并开启所有合理的子任务依赖**

对于 $100\%$ 的数据，$1\le T\le10^5$，$1\le k\le n\le 2\times10^5$，$\sum n\le5\times10^{5}$，$1\le a_i\le 10^9$。

对于不同的子任务，作如下约定：

| 子任务编号	| $n$ | $k$ | 子任务分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $=5$ | $\in[1,n]$ | $10$ |
| $2$ | $\le200$ | $\in[1,n]$ | $40$ |
| $3$ | $\le2\times10^5$ | $=2$ | $20$ |
| $4$ | $\le2\times10^5$ | $\in[1,n]$ | $30$ |

## 样例 #1

### 输入

```
5
3 2
3 2 1
7 3
4 1 3 2 5 7 6
3 3
2 1 3
7 5
1 2 3 4 5 6 7
6 4
1 1 4 5 1 4```

### 输出

```
Yes
l 1
r 1
l 1
o
No
No
Yes
o
Yes
r 1
l 1
o```

# 题解

## 作者：E_firework (赞：24)

### 简要题意

给你一个长为 $n$ 的序列，每次可以取出第 $k$ 个元素放在序列开头或者末尾（$k$ 为常数）。请给出一种排序方案或者判断无解，输出方案时可以将相邻的相同操作绑在一起视作一次操作。

### 算法一

我会暴力搜索！

期望得分：$10$。

### 算法二

考虑 $k=2$ 的情况。

首先把序列元素变为 $1$ 到 $n$ 的排列。

我们从 $n$ 到 $3$ 枚举元素 $i$，先用不超过两次操作把 $i$ 移动到 $1$ 号位，再把 $i+1$ 移动到 $3$ 号位。然后把 $i$ 移动到 $2$ 号位。最后再用一次操作把 $3$ 到 $n$ 的元素移动到正确位置，看 $1$ 和 $2$ 需不需要再交换。

这样做操作次数不超过 $4n$。

期望得分：$16$。

### 算法三

很多时候这种判断是否有解的排序题你找一个跟逆序对有关的必要条件就得到了正确的结论，于是考虑猜结论。

在这之前，首先要特判 $k=1$ 或者 $k=n$ 的情况。

如果序列有相同元素，你可以钦定相同元素的大小，这样初始状态的逆序对数既可以是奇数也可以是偶数。如果序列没有相同元素，当 $k$ 为偶数时你把元素放在序列开头会改变逆序对数的奇偶性，当 $n-k$ 为奇数时你把元素放在序列末尾会改变逆序对数的奇偶性，而排序后逆序对数为 $0$，是偶数。如果无论如何逆序对数的奇偶性都只能是奇数那就一定无解。所以无解的充分条件是序列没有相同元素且逆序对数为奇数且 $k$ 为奇数且 $n-k$ 为偶数。

你提交代码，发现这个结论是对的。至于条件的充分性可以通过后面的构造证明。

期望得分：$20$。

### 算法四

这里给出一种操作次数不超过 $6n$ 的构造方案。

还是先把序列元素变为 $1$ 到 $n$ 的排列。

然后用算法二的方法先把 $1$ 到 $k-2$ 的元素移动到正确位置，再把 $k+1$ 到 $n$ 的元素移动到正确位置，这时如果运气好 $k-1$ 和 $k$ 在正确位置就完事了。否则如果 $n-k$ 为奇数，可以找到这样一种操作序列来交换 $k-1$ 与 $k$ 的位置。

```plain
r 1
l 1
r 1
l k-1
r 1
l 1
r 1
l k-1
……
l k-1
r 1
```

如果 $n-k$ 为偶数并且 $k$ 是偶数则可以先把 $k+2$ 到 $n$ 的元素移动到正确位置，再把 $1$ 到 $k-1$ 的元素移动到正确位置，再用同样的方法交换 $k$ 和 $k+1$。

如果 $n-k$ 为偶数并且 $k$ 是奇数，因为初始状态下逆序对数是偶数且操作过程不会改变逆序对数的奇偶性，所以最后两个元素位置一定是对的，不需要特殊处理。

直接暴力维护序列是 $O(n^2)$ 的，但是可以用平衡树优化到 $O(n\log n)$。

期望得分：$30\sim60$。

### 算法五

有一个比平衡树更优美的维护序列的方法。

我们分开维护 $1$ 到 $k$ 和 $k$ 到 $n$ 的序列，并在序列上维护第 $k$ 个位置的指针。每次操作会移动一边的指针，并把另外一边指针指向的数字改为移动后指针指向的数字。这样做的好处是每次操作只有常数个元素的位置改变了，可以直接用数组存下每个元素的位置。具体实现中，我们可以钦定最后需要把指向第 $k$ 个位置的指针移到初始位置，移动元素 $i$ 时就直接把他移动到序列的第 $i$ 个位置，最后再判断是否需要交换 $k-1$ 和 $k$。

虽然这样做并不能优化操作次数，但是能帮助我们更好的理解问题。

期望得分：$60$。

### 算法六

我们可以对算法五做两个优化。

1. 因为我们限定指向第 $k$ 个位置的指针最后要回到初始位置，也就是限定他在左右两边的序列上都转整数圈。转一整圈时逆序对数奇偶性不会改变。如果一开始逆序对数是偶数一定不需要交换 $i-1$ 和 $i$。如果一开始逆序对数是奇数就先操作一次把他变成偶数，这样操作次数不会超过 $4n$。

2. 每次把 $i$ 移动到正确位置时都会把原本在第 $i$ 个位置的元素移动到序列的另外一边，如果被移出来的元素也和 $i$ 在同一批次的移动中，这时我们立即把他移动到正确的位置，就减少了 $2$ 次可能的移动。所以在把元素移动到正确位置时，先移动已经在序列另一端的元素。剩下的还没排序的元素形成了若干个置换环，对每个环随便选一个元素先移动。这样操作次数不会超过 $5n$。

两个优化加在一起再调整一下常数，操作次数就不会超过 $3n$。

因为要算逆序对数，时间复杂度是 $O(\sum n\log n)$。

期望得分：$100$。

std:

```cpp
#include <bits/stdc++.h>
#define LL long long
#define mes(s, x) memset(s, x, sizeof(s))
#define lb(i) (i & -(i))
#define Maxn 200005
using namespace std;
inline LL read(){char c;c = getchar();while(!(('0' <= c && c <= '9') || c == '-')) c = getchar();bool flag = 0;if(c == '-'){flag = 1;c = getchar();}LL tot = 0;while('0' <= c && c <= '9'){tot = 10 * tot + c - '0';c = getchar();}return flag ? -tot : tot;}
int a0[Maxn], a[Maxn], re[Maxn], b[Maxn], lst[Maxn], n, k;
int s[Maxn];
void add(int i){
	while(i <= n){
		s[i]++;
		i += lb(i);
	}
}
int sum(int i){
	int t = 0;
	while(i){
		t += s[i];
		i -= lb(i);
	}
	return t;
}
int l[Maxn], r[Maxn], p[Maxn], lp, rp;
void swp(){
	if(l[lp]) p[l[lp]] = rp;
	else p[r[rp]] = -lp;
	swap(l[lp], r[rp]);
}
char nt;
int nx;
void f(char t, int i){
	int x;
	if(t == 'l'){
		x = (lp - i + k) % k;
		if(l[lp] == 0) swp();
		lp = i;
	}else{
		x = (i - rp + (n - k + 1)) % (n - k + 1);
		if(r[rp] == 0) swp();
		rp = i;
	}
	if(x && nt != t){
		if(nx) printf("%c %d\n", nt, nx);
		nt = t, nx = 0;
	}
	nx += x;
	if(nt == 'l') nx %= k;
	else nx %= n - k + 1;
}
void solvel(int i){
	if(p[i] <= 0){
		f('l', -p[i]);
		f('r', rp == k ? k + 1 : k);
	}
	int x;
	while(i <= k - 2){
		x = l[i];
		f('l', i);
		f('r', p[i]);
		i = x;
	}
}
void solver(int i){
	if(p[i] >= 0){
		f('r', p[i]);
		f('l', lp == k ? k - 1 : k);
	}
	int x;
	while(i >= k + 1){
		x = r[i];
		f('r', i);
		f('l', -p[i]);
		i = x;
	}
}
int main(){
    #ifndef ONLINE_JUDGE
        freopen("in","r",stdin);
        freopen("out","w",stdout);
    #endif
	int T = read(), m, x;
	LL tot;
	while(T--){
		n = read(), k = read();
		for(int i = 1; i <= n; i++) re[i] = a0[i] = read();
		if(k == 1 || k == n){
			x = 0;
			if(a0[n] > a0[1]) x = 1;
			for(int i = 2; i <= n; i++){
				if(a0[i - 1] > a0[i]){
					if(x) x = -1;
					else x = i;
				}
			}
			if(x == 0) x = 1;
			if(x == -1) printf("No\n");
			else{
				printf("Yes\n");
				if(k == 1){
					if(x != 1) printf("r %d\n", x - 1);
				}else{
					if(x != 1) printf("l %d\n", n - x + 1);
				}
				printf("o\n");
			}
			continue;
		}
		sort(re + 1, re + n + 1);
		m = unique(re + 1, re + n + 1) - re - 1;
		for(int i = 1; i <= m; i++) b[i] = 0;
		for(int i = 1; i <= n; i++) b[a0[i] = lower_bound(re + 1, re + m + 1, a0[i]) - re]++;
		for(int i = 1; i <= m; i++) b[i] += b[i - 1];
		for(int i = n; i >= 1; i--) a[i] = b[a0[i]]--;
		for(int i = 1; i <= n; i++) s[i] = 0;
		tot = 0;
		for(int i = n; i >= 1; i--){
			tot += sum(a[i]);
			add(a[i]);
		}
		nx = 0;
		if(tot % 2){
			if(m != n){
				for(int i = 1; i <= m; i++) lst[i] = 0;
				for(int i = 1; i <= n; i++){
					if(lst[a0[i]]){
						swap(a[i], a[lst[a0[i]]]);
						break;
					}
					lst[a0[i]] = i;
				}
			}else if(k % 2 == 0){
				nt = 'l', nx = 1;
				a[0] = a[k];
				for(int i = k; i >= 1; i--) a[i] = a[i - 1];
			}else if(n % 2 == 0){
				nt = 'r', nx = 1;
				a[n + 1] = a[k];
				for(int i = k; i <= n; i++) a[i] = a[i + 1];
			}else{
				printf("No\n");
				continue;
			}
		}
		printf("Yes\n");
		for(int i = 1; i < k; i++) p[l[i] = a[i]] = -i;
		l[k] = 0;
		for(int i = k; i <= n; i++) p[r[i] = a[i]] = i;
		lp = rp = k;
		if(r[k] <= k - 2){
			for(int j = k + 1; j <= n; j++){
				if(r[j] > k - 2){
					f('r', j);
					solvel(r[k]);
					break;
				}
			}
		}
		for(int i = n; i >= k; i--) if(r[i] <= k - 2 && !(i == rp && r[i] == lp)) solvel(r[i]);
		for(int i = k; i >= 1; i--) if(l[i] && l[i] <= k - 2 && l[i] != i) solvel(l[i]);
		if(l[k - 1] >= k + 1){
			f('l', k);
			solver(l[k - 1]);
			if(l[k] >= k + 1 && lp != k) solver(l[k]);
		}else{
			f('l', k - 1);
			if(l[k] >= k + 1) solver(l[k]);
		}
		for(int i = k; i <= n; i++) if(r[i] >= k + 1 && r[i] != i) solver(r[i]);
		f('r', k);
		f('l', k);
		if(nx) printf("%c %d\n", nt, nx);
		printf("o\n");
	}
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：4)

先不妨假设 $a_i$ 是个排列。

首先考虑是否合法。特判 $k=1/n$。然后我们猜这玩意之和逆序对数有关。具体地如果 $k$、$n$ 都是奇数且 $a_i$ 恰有奇数个逆序对那么是无解的。其余情况猜测优解，交个代码获得 $20$ 分就能验证了。

考虑先转换这个操作。我们把 $1\sim k$、$k\sim n$ 看成两个数组 $p,q$。然后这两个数组恰有一个公共元素，我们分别用 $p_{ls}=q_{rs}$ 来表示。初始时 $ls=rs=k$。

一次旋转操作相当于去移动 $ls/rs$，以移动 $p_{ls}$ 为例子，把 $ls\leftarrow x$ 会让 $q_{rs}\leftarrow p_x$。

如果操作结束之后 $ls/rs$ 在别的位置会比较难以描述，所以我们应该 **所有操作结束后有 $ls=rs=k$**。那么我们的操作目标就是 $p_i=i$、$q_i=i$。

这样做的好处是，由于 $ls=rs=k$，那么即所有两个环都转了整数圈。而一个环转整数圈是不影响逆序对数目的。所以如果 $a_i$ 一个是就有奇数个逆序对，我们只要在操作的开头转一圈改变逆序对数目就行了。所以接下来只需要考虑 $a_i$ 逆序对数是偶数的问题。

由于有逆序对的缘故，所以当我们成功归位 $1\sim k-2$、$k+1\sim n$ 的时候 $k-1,k$ 就会自动归位。我们先视作 $k-1,k$ 为自由元。

首先考虑对 $1\sim k-2$ 的元素归位，记 $id_i$ 为元素 $i$ 当前所处的位置。枚举 $i=1,2,\dots,k-2$：

- 如果 $i$ 目前在 $q$ 序列上。$ls\leftarrow i$、$rs\leftarrow id_i$ 即可。
- 如果 $i$ 目前在 $p$ 序列上。$ls\leftarrow id_i$（把 $i$ 先传送过去）、$rs\leftarrow k/k+1$（把 $i$ 留到左部分）再和上面操作类似地即可。

对 $i=k+1,\dots,n$ 是同理的。上面操作最坏会使用 $4n$ 次操作。考虑优化。

首先我们先传输在异侧的元素。每次归位这样元素的成本是 $2$。然后考虑传输同侧元素，不难发现我们传输同侧元素的时候，实际上把 $p_i$ 给丢到了异侧。即我们把 $p_i$ 变成了异侧元素。我们这时候直接归位 $p_i$ 平均成本就是 $(2+4)/2=3$。

---


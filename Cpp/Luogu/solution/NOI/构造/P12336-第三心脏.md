# 第三心脏

## 题目背景

[第三心脏](https://music.163.com/#/song?id=1849700898)。

## 题目描述

mikage 喜欢构造题，这天她想到了一个简单的构造题：

给定 $a$ 试构造正整数**四元组** $(a,b,c,d)$ 满足：

1. $\sqrt{a^2+b^2+c^2+d^2}=a\oplus b\oplus c\oplus d$。

2. $a<b<c<d<2^{63}$。

无解输出 $-1$，$\oplus$ 是二进制按位异或。

## 说明/提示

### 样例解释

依题面得。


### 数据范围

本题开启数据捆绑，你只有通过了一个 Subtask 内所有的测试点才能获取该 Subtask 的分数。

|Subtask|$a$ 的范围|特殊性质|分数|
| :----------: | :----------: | :----------: |:--:|
|0|$a\le 10$|无|5|
|1|$a\le 300$|无|5|
|2|$a\le 4\times 10^3$|A|10|
|3|$a\le 10^7$|B|10|
|4|$a\le 2\times 10^8$|C|20|
|5|$a\le 10^9$|D|10|
|6|$a\le 10^9$|无|40|

对于所有数据有 $1\le a \le 10^9$。

特殊性质 A：存在大于等于 $2$ 的整数 $k$ 满足 $a = 2^k$。

特殊性质 B：$a \equiv 0 \pmod{4}$。

特殊性质 C：$a \equiv 1 \pmod{4}$。

特殊性质 D：存在大于等于 $2$ 的整数 $k$ 满足 $a = 2^k-1$。

## 样例 #1

### 输入

```
31```

### 输出

```
172 484 632```

# 题解

## 作者：寄风 (赞：15)

upd on 2025.6.5 修正了一个笔误，感谢 @[Cuxhin](https://www.luogu.com.cn/user/225375) 的指出。

场切并获得了首 A。

挺好的锻炼脑力题。

考虑推一个柿子，那么：

$$\sqrt{a^2+b^2+c^2+d^2}=a\oplus b\oplus c\oplus d$$

$$a^2+b^2+c^2+d^2=(a\oplus b\oplus c\oplus d)^2$$

因为 $\forall{x>0},x^2>0$，所以 $(a\oplus b\oplus c\oplus d)>d$。

令 $(a\oplus b\oplus c\oplus d)=d+x$。

那么我们考虑把柿子拆开：

$$a^2+b^2+c^2+d^2=(d+x)^2$$

$$a^2+b^2+c^2+d^2=d^2+2\times x\times d+x^2$$

$$a^2+b^2+c^2=2\times x\times d+x^2$$

获得了这个之后我们该怎么做？

首先任意一个 $x$ 我们都可以构造，设 $\log_{2}(x)+1=y$，那么我们让 $d$ 的后 $y$ 位都是 $0$，然后 $a\oplus b\oplus c$ 就是 $x$ 就可以了。

那么你发现 $x$ 越小构造难度应该也是越小的。

那么先令 $x=0$，那么 $a^2+b^2+c^2=0$，显然是不可以的。

那么考虑让 $x=1$。

那么我们获得了两个条件，就是 $a\oplus b\oplus c=1$ 和 $a^2+b^2+c^2=2\times d+1$；同时我们还获得了一个约束，就是 $d \bmod 2$ 必须是 $0$。

保险起见，我们先把 $a=1$ 判掉，这个直接写个暴力找解即可。

那么因为 $a\oplus b\oplus c=1$，$a$ 又大于 $1$，所以如果 $a$ 的最高位和 $b,c$ 的最高位相同我们是不好构造的。所以我们只能考虑从比 $a$ 的最高位更高的位入手，设 $a$ 的最高位是第 $q$ 位，那么 $b$ 和 $c$ 的第 $q+1$ 位都是 $1$ 就可以了。

然后因为我们要保证 $a<b<c$，所以我们考虑将 $b$ 的第 $q$ 位置为 $0$，将 $c$ 的第 $q$ 位置为 $1$ 就可以了。

那么剩下的位的话，因为二进制的按位考虑，所以我们可以将 $b$ 的第 $0$ 位到第 $q-1$ 位都设成和 $a$ 一样，这样子 $a\oplus b$ 就是 $2^q+2^{q+1}$ 了。

那么我们再将 $c$ 的第 $0$ 位置 $1$ 就可以满足 $a\oplus b\oplus c=1$ 了。

$d$ 的求法就是 $d=\frac{a^2+b^2+c^2-1}{2}$。

这显然满足 $c<d$。

总结下，就是构造 $b=a+2^q,c=2^{q+1}+2^q+1$ 即可。

那么看上去对完了？这真的是对的吗？

这个正确性非常显然，用屁股都能想到。

写一发，[结果](https://www.luogu.com.cn/record/215040327)。

其实这个做法是**错的**。

为啥会错呢？我们发现我们上面推导的一切，都有一个前提：$d \bmod 2$ 必须是 $0$。而我们上面并没有保证 $d \bmod 2$ 是 $0$。

难道我们的努力白费了？

并不是。

我们考虑 $d \bmod 2$ 是 $0$ 的限制，也就是说 $d^2 \bmod 4$ 必须是 $0$，也就是说 $d^2 \bmod 4+1$ 必须是 $1$。

在我们上面的构造中，我们保证了 $b \equiv a \pmod 2$ 和 $c \bmod 2=1$。

所以如果 $a \bmod 2=0$，那么带回原式，我们的构造是有效的，$a^2\bmod 4=0$，$b^2\bmod 4=0$，$c^2\bmod 4=1$，$a^2+b^2+c^2 \equiv 2\times d+1 \pmod 4$。

但是如果 $a \bmod 2=1$ 我们的构造就无效了。

考虑将 $b$ 与 $c$ 进行微调，由于 $a \bmod 2=1$，所以如果我们将 $b$ 和 $c$ 的值同时减小 $1$ 的话，并不会影响 $a\oplus b\oplus c$ 的结果。

重新带回，当 $a \bmod 2=1$ 时，$a^2\bmod 4=1$，$b^2\bmod 4=0$，$c^2\bmod 4=0$，$a^2+b^2+c^2 \equiv 2\times d+1 \pmod 4$。

那么就做完了，不难证明大小关系依然满足 $a<b<c<d$。

代码：
```cpp
#include <bits/stdc++.h>

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using i128 = __int128;
using u128 = unsigned __int128;

i64 a, b, c, d;

inline void debug() {
    std::cerr << "check:\n";

    std::cerr << a * a + b * b + c * c + d * d << '\n';

    std::cerr << (a ^ b ^ c ^ d) * (a ^ b ^ c ^ d) << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);

    std::cin >> a;

    if (a == 1) {
        for (int b = a + 1; b <= 500; b++) {
            for (int c = b + 1; c <= 500; c++) {
                for (int d = c + 1; d <= 500; d++) {
                    int xx = (a ^ b ^ c ^ d);
                    if (a * a + b * b + c * c + d * d == xx * xx) {
                        std::cout << b << ' ' << c << ' ' << d << '\n';
                        return 0;
                    }
                }
            }
        }
        std::cout << -1 << '\n';
        return 0;
    }

    //b=a+(1<<q),c=(1<<(q+1))+(1<<q)+1
    
    int q = std::__lg(a);

    if (a % 2 == 0) {
        b = a + (1ll << q), c = (1ll << (q + 1)) + (1ll << q) + 1;

        d = (a * a + b * b + c * c - 1) / 2;
        //我靠，要保证 d 最后一位是 0

        if (d % 2 == 0) {
            std::cout << b << ' ' << c << ' ' << d << '\n';
            debug();
            return 0;
        } 
        assert(0);
    } else {
        b = a + (1ll << q) - 1, c = (1ll << (q + 1)) + (1ll << q);

        d = (a * a + b * b + c * c - 1) / 2;
        //我靠，要保证 d 最后一位是 0

        if (d % 2 == 0) {
            std::cout << b << ' ' << c << ' ' << d << '\n';
            debug();
            return 0;
        } 
        exit(114);
    }

    // for (int d = c + 1; d <= 100000; d++) {
    //     int xx = (a ^ b ^ c ^ d);
    //     if (a * a + b * b + c * c + d * d == xx * xx) {
    //         std::cout << d << '\n';
    //         return 0;
    //     }
    //     std::cerr << a * a + b * b + c * c + d * d << " " << xx * xx << '\n';
    // }

    // std::cout << a << ' ' << b << ' ' << c << ' ' << d << '\n';

    // std::cerr << (a ^ b ^ c) << ' ' << a * a + b * b + c * c << '\n';

    return 0;
}
```

[有心路历程的代码](https://www.luogu.com.cn/paste/fwv8jy3k)，大家可以看看我赛时心态。

---

## 作者：ty_mxzhn (赞：11)

我知道你要喷我，但你先别急。

## 算法 1

使用奇怪枚举方法可以拿到很多分。

## 算法 2

显然如果 $a$ 是偶数，我们可以通过每次除以 $2$ 将其规约到 $a$ 是奇数的情况。做完这一步就可以拿到 $a=2^k$ 的分了。

## 算法 3


注意到题目放的视频 MV 是《第三心脏》，所以考虑将 $a\oplus b\oplus c$ 设置为一个定值。（？）

显然不能设置 $a\oplus b\oplus c=0$，因为这样子怎样都构造不出来的。猜测我们要设计 $a\oplus b\oplus c=1$。

容易想到令 $b=2^p,c=a+b-1$。

猜测我们可以构造 $d$ 是偶数，则原式子变为 $a^2+b^2+c^2+d^2=(d+1)^2$，移项，得到 $2d+1=a^2+b^2+c^2$。

于是我们要证明的就是 $a^2+b^2+c^2 \equiv 1\pmod{4}$。（这里是对 $4$ 同余是因为 $d$ 是偶数）

$b^2$ 不用管，问题在于 $a^2+c^2$，可以化成 $a^2+(a-1)^2$，那么第二项也不用管，所以只看 $a^2$。

$a\equiv1,3\pmod{4}$，所以 $a^2\equiv 1\pmod{4}$，所以这样做就是对的。

稍微思考一下会发现 $a<b<c<d$ 被自动完成了。

算一下上界吧，可以发现 $d$ 大概可以到 $8\times 10^{18}$ 级别，卡的还是挺紧的。

## 杂项

感谢 not_clever_syl 提供了另一个做法。

关于剩下三个特殊性质。二三个是启发思考的，而且似乎 syl 的做法可以通过这两个特殊性质启发。第四个是构造 $b$ 的时候方便一点。

难度：绿难一点。个人差似乎比较大？ty_ak 说他认为是紫。

## 代码

$a=1$ 的解要找一个。

```cpp
#include <cstdio>
using namespace std;

typedef long long ll;
int a,k;
ll b,c,d;
signed main(){
	scanf("%d",&a);
	while(!(a&1)) a>>=1,k++;
	if(a==1){
		b=5,c=7,d=37;
	}else{
		for(int j=30;j>=0;j--){
			if(((a>>j)&1)){
				b=(1<<(j+1));
				break;
			}
		}
		c=a+b-1;
		d=a*c+b*(b-1);	
	}
	b<<=k;
	c<<=k;
	d<<=k;
	printf("%lld %lld %lld\n",b,c,d);
	return 0;
} 
```

---

## 作者：not_clever_syl (赞：7)

验题人题解。

当 $a$ 是偶数时，令 $a=a'\times2^k(a' \bmod 2 \equiv 1)$，用 $a'$ 构造出 $b',c',d'$，显然 $a,b' \times 2^k,c' \times 2^k, d' \times 2^k$ 是合法的解，所以我们只考虑 $a \bmod 2 \equiv 1$ 即可。

下面默认 $a \bmod 2 \equiv 1$。

考虑一下 $b,c,d$ 的奇偶性，因为 $a$ 是奇数，所以 $b,c,d$ 要么全偶，要么全奇。

不妨假设 $b,c,d$ 均为偶数，则令 $a=2A+1,b=2B,c=2C,d=2D$。

条件还是太少了，观察右边的式子，发现 $a \oplus b \oplus c$ 等于常数会好很多，于是我们~~钦定~~不妨令 $a \oplus b \oplus c = 1$，这样我们可以拿到 $C=A \oplus B$。

把题目里的式子化一下：$(2A+1)^2+4B^2+4C^2+4D^2=(2D+1)^2 \to A^2+A+B^2+C^2=D$。

那么只需要让 $A,B,C$ 满足 $A<B<C$ 即可，$D$ 显然比 $A,B,C$ 都大，发现此时 $\operatorname{highbit}(B)=\operatorname{highbit}(C)>\operatorname{highbit}(A)$，随便构一构即可。

一种可能的方法是：令 $B=2A,C=A \oplus B$，若 $B>C$ 则交换。

但是发现 $a=1$ 时 $A=0$，则不能直接构造，判一下跑个暴力即可。

于是此题就做完了。

---

## 作者：ni_ju_ge (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P12336)。
## 思路
先拆根号，变为 $a^2+b^2+c^2+d^2=(a\oplus b\oplus c\oplus d)^2$，那么有 $a\oplus b\oplus c\oplus d>d$，式子化成 $a^2+b^2+c^2+d^2=(d+x)^2$，即 $a^2+b^2+c^2=2xd+x^2$，取 $x=1$ 较为容易，那么考虑构造 $b,c$ 以满足条件 $a\oplus b\oplus c=1$。

设 $a$ 在二进制下共有 $p$ 位，为满足 $a<b<c$ 且 $a\oplus b\oplus c=1$ 的条件，容易想到构造 $b=2^p,c=2^p+a\oplus 1$，这样就能满足以上条件。

构造出了 $b,c$，就可以得到 $d=\dfrac{a^2+b^2+c^2-1}{2}$ 了。不难证到 $d$ 满足 $d\oplus 1=d+1$ 且 $c<d$ 的条件。

注意 $a=1$ 时上述方法并不满足 $b<c$（这是因为 $a\oplus 1=0,c=2^p=b$），所以需要特别处理。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d;
int l;
int main() {
	cin>>a;
	if(a==1) {cout<<"5 7 37";return 0;}
	int f=a;
	while(f) l++,f/=2;//计算 a 的位数
	b=1;
	for(int i=1;i<=l;i++) b*=2;//计算 b
	c=a^1+b;//计算 c
	d=(a*a+b*b+c*c-1)/2;//计算 d
	cout<<b<<" "<<c<<" "<<d;
}
```

---

## 作者：xxgirlxx (赞：2)

第一版题解写到一半，对面的同学一脚把我电源线踢掉了（没保存）······

第二版题解马上写完，学校停电了（没保存）······

好好好，“第三心脏”所以要写三遍题解是吧（这下不敢忘记随时保存了）。

感觉这题脑电波非常抽象，个人差异会非常大（个人亲身经历，刚开始推了好几天都没有思路，后面一对上脑电波半小时就推完了）。

给出 $a$，求一组 $b,c,d$ 满足 $0<a<b<c<d<2^{63}$ 和下面这个式子：

$$\sqrt{a^2+b^2+c^2+d^2}=a\oplus b \oplus c \oplus d$$

根号太麻烦了，用平方去掉：

$$a^2+b^2+c^2+d^2=(a\oplus b \oplus c \oplus d)^2$$

异或的 $1\oplus 1=0$ 很难搞，考虑提前定好哪些位置是存在 $1\oplus 1=0$ 的运算的，也就基本上是定下一些数运算后的值，运算的数的个数可以是 $0,1,2,3,4$ 中的一个，$0,1,4$ 显然不行这里不赘述，主要来排除掉 $2$。

发现定下 $2$ 个数运算后的值后打开平方会出现的系数太多难以控制，将值定为 $0$ 虽然可以减少系数但是会不合法，所以排除掉 $2$。

所以我们选择定下 $3$ 个数运算后的值，但是定哪三个数呢？我们肯定不想搞大的数，因为数越大越难以控制，所以最大的 $d^2$ 肯定是在抵消名单之内的，因此考虑定下 $a,b,c$ 三个数运算后的值，经过简单证明发现不能定为 $0$，因为这样最终会导致 $a=b=c=0$，不合法。

然后考虑定值为 $1$，这样的话式子化出来是：

$$a^2+b^2+c^2=\pm 2\times d +1$$

然后因为 $0<d$，所以不能出现 $d$ 前的系数为负的情况，所以我们需要先强制使 $d$ 为偶数，这样式子就是：

$$a^2+b^2+c^2=2\times d +1$$

然后就可以得出 $d=\frac{a^2+b^2+c^2-1}{2}$。

接下来有两个事情需要证明：搞出 $a\oplus b \oplus c=1$ 的构造方法，证明 $d$ 是偶数。

先构造 $a\oplus b \oplus c=1$。经过大量手玩可以得出：$b=2^x>a$，然后让 $c$ 等于 $a+b$ 取反最后一位的值就可以了（更易理解的说法就是若 $a$ 为奇数则 $c=a+b-1$，若 $a$ 为偶数则 $c=a+b+1$）。

接下来证 $d$ 为偶数。先将 $c^2$ 换成 $a,b$ 构成的，得出：

$$d=\frac{a^2+b^2+a^2+a\times b \pm a+b\times a+b^2\pm b\pm a\pm b+1-1}{2}$$

稍微推一下：

$$d=\frac{2\times a^2+2\times b^2+2\times a\times b \pm 2\times a\pm 2\times b+1-1}{2}$$

$$d=a^2+b^2+a\times b \pm a\pm b$$

$b=2^x$ 必定为偶数，所以无影响，$a^2$ 和 $a$ 的奇偶性必定相同，所以最终 $d$ 必定为偶数。

还有注意特判 $a=1$ 的情况，这种情况下用以上方法会导致 $b=c=2$，所以要另外找一组解（手玩或暴力跑都可以）。

最终 $d$ 的最大值为 $3226663330680588800<9223372036854775807=2^{63}$。

```cpp
#include<iostream>
long long a,b=1<<30,c,e[3]={1,-1};
int main(){
	std::cin>>a,c=a+b+e[a%2];
	(a==1?printf("4 28 40"):std::cout<<b<<" "<<c<<" "<<(a*a+b*b+c*c-1)/2);
}
```
做题游记：
```cpp
P12336 第三心脏
好的如你所见这是一道构造题
啊
sqrt(a^2+b^2+c^2+d^2)=a xor b xor c xor d且a<b<c<d？
好抽象的式子
令人难以猜透作者想表达什么
（这里省略掉前面几天的游记，主要是因为全是废话，没有营养，且含m量极大）
根号肯定是要平方去掉的
不然太难搞了
另外这个异或也很抽象啊
但可以肯定的是异或中的计算肯定都是我们设定好的
可以肯定的是最重要的性质就是1 xor 1=0
（这不废话嘛不然不就成加法了）
那先把根号去了
a^2+b^2+c^2+d^2=(a xor b xor c xor d)^2
然后对面这个异或很烦人啊
想办法去掉
一个很好的办法就是固定几个数异或后的值
定四个数肯定不行
不然你玩什么？
bcd好说是你自己定
但a是变的啊
你怎么保证你a^2+b^2+c^2+d^2之后是你的那个定值？
一个不定也不可能
那不就回去了嘛
定一个也不行
定一个不就等于定了一个数的值吗？
a<b<c<d这让你怎么玩？
定两个数也不太现实
毕竟定两个数的话三个数之和的平方搞出来系数太多了不好控制
值定为0的话两个数就又相等了
不满足a<b<c<d
那就只能定三个数了
肯定不定0
定0的话式子化出来是a^2+b^2+c^2=0
那不就是说a=b=c=0么？
肯定不对啊
定为0肯定不对
因为不管是哪三个数定值都会导致化出来三个数分别平方后的和为0
从而导致三个数都为0
那定什么值呢？
还有我们定那三个数的异或值呢？
可以肯定的是我们不会希望去处理太大的数
所以最大的d^2肯定是约掉最好
所以我们是定a xor b xor c的值
但是0又不能定
定什么值呢？
试点特殊的值吧
既然异或是二进制上的东西
那么我们就试试定为2^x
x先等于0
那就是a xor b xor c=1
式子化出来就是a^2+b^2+c^2=2*d+1
欸等等
这个a xor b xor c=1怎么保证啊？
哦哦哦这里得用异或的1^1=0
就是令b是一个大于a的2^y
然后c=a+b-1就可以了
欸等等这样的话a是奇数确实可行
但一旦a不是奇数怎么办？
哦哦哦可以改成a+b+1
这样a<b<c也完成了
然后d就很好算了
也很容易证明或构造bc使得d>c
重要的变成了后面的那个+1
也就是说a^2+b^2+c^2得是奇数（因为2*d必为偶数所以+1就成奇数了）
b^2不用管因为b本来就是偶数
主要的是ac只能有一个是奇数
这个非常好证啊
毕竟异或出来是1就证明了三个数中只有一个数是奇数
那不就做完啦？
woc
前几天乱推推不出来一点
认为黑的很值啊
今天怎么跟开挂了似的
《绿难一点》
对上脑电波了还真是
这次做题游记才写了2K
前两次都写了3K+
哦哦哦a=1倒是和corner
主要是a=1的话c就成b了
所以a=1还得特判一下找另一组解
跑个暴力找一组解：
1 4 28 40
还可以！
哦哦哦好像还要证d得是偶数
不然你xor 1凭啥是+1
把c换成a+b+(-)1
那总的化出来就是d=(2a^2+2*b^b+2*a*b+1-1+(-)2a+(-)2b)/2
然后把无影响的都去掉
d=(2a^2+(-)2a)/2 
b去掉是因为b是偶数且都带偶数系数
然后剩下的部分就是d=a^2+(-)a
你会发现a^2和a的奇偶性必定相同
所以d是偶数
```

---

## 作者：Tokisaki__kurumi (赞：1)

# [题目链接](https://www.luogu.com.cn/problem/P12336)

比较吃电波的一道题。

首先看到根号，立马平方，得到

$$
a^2+b^2+c^2+d^2=(a\oplus b\oplus c \oplus d )^2
$$

因为 $a<b<c<d$ 且 $a,b,c,d$ 都为正整数，则

$$
(a\oplus b\oplus c \oplus d )^2=a^2+b^2+c^2+d^2 >d^2
$$

所以考虑将 $a\oplus b\oplus c \oplus d$ 设为 $d+x$，则

$$
a^2+b^2+c^2+d^2=(a\oplus b\oplus c \oplus d )^2
$$

$$
a^2+b^2+c^2+d^2=( d+x )^2
$$

$$
a^2+b^2+c^2=2dx+x^2
$$

考虑将 $x$ 设为 $1$，因为比较好做，则

$$
a\oplus b \oplus c =1
$$

$$
b\oplus c= a\oplus1
$$

这样这道题就做完了，令 $pos$ 为 $a$ 二进制下最高位，令 $b=2^{pos+1},c=b+a\oplus 1$，那么 $d=\frac{a^2+b^2+c^2-1}{2}$。

那怎么保证 $d$ 为整数呢？

对 $a$ 分讨一下即可，$a$ 奇数时 $c$ 为偶数，$a$ 为偶数时 $c$ 为奇数，再 $-1$，一定是 $2$ 的倍数。最后特判一下 $1$ 就 A 了。

#### code

```cpp
#define int long long
int a,b,c,d,pos;
inline void solve(){
    read(a);
    if(a==1){
        cout<<"4 28 40"<<endl;
    }else{
        while((1ll<<pos)<=a) ++pos;
        b=(1ll<<pos);
        c=b+a^1;
        d=(a*a+b*b+c*c-1)/2;
        cout<<b<<' '<<c<<' '<<d<<endl;
    }
}
```

---

## 作者：RainySoul (赞：0)

抽象的，困难的，无法战胜的。

限制条件 

$$\left\{\begin{matrix}
a^2+b^2+c^2+d^2=(a\oplus b\oplus c\oplus d)^2
\\
a<b<c<d<2^{63}
\end{matrix}\right.$$

不妨设 $(a\oplus b\oplus c\oplus d)=d+x$，原式即为 $a^2+b^2+c^2+d^2=(d+x)^2=d^2+2dx+x^2$，即 $a^2+b^2+c^2=2dx+x^2$。

然后怎么简单怎么来，让 $\text{lowbit}(d)>x$ 就可以直接有 $a \oplus b \oplus c=x$，显然 $x$ 位数越小越好构造，$x=0$ 时完全不能构造，$x=1$ 时可以动一动了。现在相当于有

$$\left\{\begin{matrix}
 a \oplus b \oplus c=1
 \\
 a<b<c<d<2^{63}
 \\
 a^2+b^2+c^2\equiv 1 \pmod 4
 \\
 d\equiv 0\pmod 2
\end{matrix}\right.$$

首先对着 $a\oplus b\oplus c=1$，直接构造长这样的，$b$ 的后半部分与 $a$ 完全一样：

```
a= 1????
b=10????
c=110001
```

$c^2 \mod 4=1$ 是显然的，当 $a\mod 2=0$ 时 $a^2\mod 4=0,b^2 \mod 4=0$，下面两个限制直接满足了。

$a\mod 2=1$ 时 $a^2 \mod 4=1,b^2 \mod 4 =1$，$(a^2+b^2+c^2) \mod 4=3$，这不太棒，本来的构造是这样的：

```
a= 1???1
b=10???1
c=110001
```

将 $b$ 和 $c$ 同时减 $1$ 就可以了。

然后挂了一个点，发现当 $a=1$ 时会出现要求 $c$ 最后一位既是 $0$ 又是 $1$ 这种鬼畜行为，对于 $a=1$ 打个暴力特判掉就可以了。

$a=0$ 的情况也会错的吧，哎我是不是击杀了几乎所有题解？哦哦 $a\ge 1$ 我是唐石。可惜了，差点成为传奇击杀王。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a;
signed main(){
    cin>>a;
    int temp=__lg(a);
    int b=a+(1ll<<temp),c=1+(1ll<<temp)+(1ll<<(temp+1));
    if(a==1)cout<<"4 28 40";
    else if(a%2==0){
        int d=(a*a+b*b+c*c-1)/2;
        cout<<b<<" "<<c<<" "<<d;
    }
    else{
        b--,c--;
        int d=(a*a+b*b+c*c-1)/2;
        cout<<b<<" "<<c<<" "<<d;
    }
    return 0;
}
```

---


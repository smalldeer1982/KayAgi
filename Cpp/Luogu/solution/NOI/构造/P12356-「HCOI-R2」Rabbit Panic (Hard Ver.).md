# 「HCOI-R2」Rabbit Panic (Hard Ver.)

## 题目背景

**注意在问题的这个版本中，你需要解决和 Easy Ver. 一样的问题，但是需要最小化步数。**

## 题目描述

你有一个长度为 $n$ 的排列 $\{p_n\}$，初始 $p_i = i$。每次你可以选择 $m$ 个**不同**位置的元素，并**同时**将它们改成它们的平均值（不取整）。

最后你需要使所有元素都相等。

请你构造一组操作方案，并最小化你的操作数量。无解输出 $-1$。

## 说明/提示

### 样例解释 1

- $[1,2,3,4,5,6]\to [3.5,3.5,3,4,3.5,3.5]\to [3.5,3.5,3.5,3.5,3.5,3.5]$。
- 可以证明不存在更优的方案。

### 数据范围

**本题采用捆绑测试。**

注意月赛中本题满分为 $50$ 分。你实际获得的分数为显示的子任务分数的一半。

- Subtask 0 (20 pts)：$1\leq \sum n\leq 10$。
- Subtask 1 (40 pts)：$1\leq \sum n\leq 10^3$。
- Subtask 2 (40 pts)：无特殊限制。

对于所有数据，$1 \leq T \leq 1.2\times 10^4$，$1 \leq m \leq n \leq 2\times 10^5$，$1 \leq \sum n \leq 10^6$。

## 样例 #1

### 输入

```
1
6 4```

### 输出

```
2
1 2 5 6
2 3 4 5```

# 题解

## 作者：IvanZhang2009 (赞：16)

这个题两三年前出出来的时候还是我做出来的。

翻了一下之前的题解。

除了 $n,m$ 都是奇数的情况都是简单的，直接去看 easy version 的题解即可。

不妨仅考虑 $m=3$。对于 $m>3$ 的情况，我们仿照 $m$ 是偶数的情况，我们对中间的区间求解 $m=3$，然后在每次操作都加入 $\frac{m-3}{2}$ 对 $i$ 和 $n-i+1$ 即可。

$m=3$ 时答案是 $\lceil\frac{n-1}{3}\rceil$。这个在 $n=6x+1$ 的时候是最严的（$x$ 是整数），再次只考虑 $n$ 模 $6$ 余 $1$ ~~因为剩下的很简单~~。

我们需要把 $1\sim(6x+1)$ 的所有数除了 $3x+1$ 分成 $2x$ 组，每组有三个数，且和都相等。我的思路是将这些数先分成三组：$[1,2x]$ 的数分为第一组，$[4x+2,6x+1]$ 分为第三组，剩下的是第二组。可以构造出每个三元组的三个数分别选自三个组的方案。

列出限制 $a\in [1,2x],b\in[2x+1,4x+1],c\in[4x+2,6x+1],b\neq 3x+1,a+b+c=9x+3$。

稍加变化得到：$a\in [-x+1,x],b\in[-x,x],c\in[-x,x-1],b\neq 0,a+b+c=0$。（这一步只需要把 $a,b,c$ 各自减掉一个常数）

把 $b,c$ 取反得到：$a,c\in[-x+1,x],b\in[-x,x],b\neq 0,a-c=b$。

这个形式就很好看了。这相当于我们要求一个长度为 $2x$ 的排列 $p_{1\dots 2x}$ 使得 $p_i-i$ 恰好是 $\pm [1,x]$ 的所有数。

手玩一下可以发现 $2,4,6,\dots,2x,1,3,5,\dots 2x-1$ 恰好符合条件。那么做完了。

代码找不到了。

---

## 作者：xxgirlxx (赞：3)

代码内附主播的做题游记（逃。

一律认为读者已经通过了 [Easy Ver.](https://www.luogu.com.cn/problem/P12352)。

所以这里只讲 $n,m$ 都为奇数的情况，其它情况详见 [Easy Ver.](https://www.luogu.com.cn/problem/P12352)。

容易发现其它情况的操作次数在 [Easy Ver.](https://www.luogu.com.cn/problem/P12352) 的做法中就已经是最优的了，因为操作的数中重复的很少，只有必定会重复的部分才重复，所以从这个方面来改进 $n,m$ 都为奇数的情况。

先不管别的，只管 $m=3$，因为剩下的部分可以一个个对应来操作。

然后只考虑刚好能操作完，那么根据我们尽量不重复的做法，操作数就是 $\lceil \frac{n-1}{3}\rceil$（$-1$ 是因为最中间的数不需要操作）。那么最不能重复的情况就是 $n=3\times a+1$ 的情况，但是如果 $a$ 为奇数就不符合我们 $n$ 为奇数的前提，所以其实是 $n=6\times a+1$ 的情况。

那么就需要将 $1$ 到 $6\times a+1$ 中除了 $3\times a+1$（这就是最中间的那个数）以外的数分为三组，然后排好顺序，使得 $x_i+y_i+z_i=9\times a+3$（为什么是等于 $9\times a+3$ 呢？因为最终的平均数是这个，所以三个数的和就得是三倍的平均数），但是这个 $9\times a+3$ 不好搞，考虑给每个数都减掉 $3\times a+1$，这样就变成了将 $-3\times a$ 到 $3\times a$ 中除了 $0$（这就是最中间的那个数）以外的数分为三组，然后排好顺序，使得 $x_i+y_i+z_i=0$。

现在就明朗的多了，然后仔细想想：我们肯定是 $0$ 前后各一个，还有一个用于使他们的和再加上这个数为 $0$。那么后面填补的这个数必然不会太大，肯定是一边的最大值与一边的最小值构成了上下界，稍微想一下，推一下，手玩一下就能发现从小到大排序后三等分是恰好满足的。

这样的话就有了：$-3\times a\le x_i\le -a-1,-a\le y_i\le a(y_i\neq 0),a+1\le z_i\le 3\times a,x_i+y_i+z_i=0$

将最后的式子转化为：$y_i=-x_i-z_i$

然后我们发现 $x_i$ 的范围和 $z_i$ 的范围刚好是相反的，所以考虑将 $x_i$ 整个取个反。

于是就变成了：$-a\le y_i\le a(y_i\neq 0),a+1\le x_i,z_i\le 3\times a,y_i=x_i-z_i$

然后发现 $x_i$ 和 $z_i$ 是相减的，所以我们可以尝试着将范围上下界调小一点，调成 $1\le x_i,z_i\le 2\times a$。

所以就变成了求出两个 $2\times a$ 的排列，使得相减后出现的数包含了 $-a$ 到 $a$ 中除了 $0$ 以外的所有数。

考虑固定一个排列，比如固定 $z_i=i$，那么再推一下，手玩一下，假设第一个差值为 $1$，那么 $x_i$ 就是 $2$，接下来 $z_i$ 加了 $1$，我们肯定希望差值要有规律的变，所以我们希望下一个差值是 $2$，那么下一个 $x_i$ 就要加 $2$，也就是 $4$。那么加加加一直加到 $2\times a$，就搞出了 $1$ 到 $a$，但使用了所有的偶数。那么接下来就要用剩下的奇数和 $a+1$ 到 $2\times a$ 配对搞出 $-a$ 到 $-1$。手玩一下发现第一个放 $1$，第一个差值是 $-x$，后面 $z_i$ 还在加 $1$，但是我们仍旧希望差值要有规律的变，所以我们希望下一个差值是 $-x+1$，然后发现下一个刚好是奇数 $3$。

然后反推回去就可以得到 $x_i$，$y_i$ 和 $z_i$ 了。

然后上面说的可以理解为是 $n-1 \operatorname{mod} 3=0$ 的情况，至于 $\operatorname{mod}=1/2$ 的情况也好说，$\operatorname{mod}=1$ 就拿出两次操作来跟最中间的数配在一起就可以了，$\operatorname{mod}=2$ 就拿出一次操作来跟最中间的数配在一起就可以了。

然后具体的实现看代码吧，这题细节感觉还是挺多的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
vector<int>ans[1000010];
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(m==1){
			if(n==1)cout<<"0\n";
			else cout<<"-1\n";
		}
		else if(n%2==1&&m%2==1){
			int num,f,cnt,sum,s,now,tmp;
			for(int i=1;i<=n;i+=2){
				num=(i-1)/3+((i-1)%3!=0);
				if(num*(m-3)+i>=n){
					f=i;
					break;
				}
			}
			cout<<num<<"\n";
			sum=(3-(f-1)%3)%3,cnt=(n-f)/2;
			for(int i=1;i<=num;i++)ans[i].clear();
			for(int i=1;i<=sum;i++){
				ans[i].push_back((n-f)/2+f);
				ans[i].push_back((n-f)/2+1);
				ans[i].push_back(n/2+1);
				f-=2;
			}
			now=1;
			for(int i=1;i<=num;i++){
				for(int j=1;j<=(m-3)/2;j++){
					ans[i].push_back(now);
					ans[i].push_back(n-now+1);
					now=now%cnt+1;
				}
			}
			s=(f-1)/6,tmp=(n-f)/2;
			for(int i=1;i<=(num-sum)/2;i++){
				ans[i+sum].push_back(-s-i*2+3*s+1+tmp);
				ans[i+sum].push_back(i+3*s+1+tmp);
				ans[i+sum].push_back(s+i+3*s+1+tmp);
			}
			for(int i=(num-sum)/2+1;i<=num-sum;i++){
				ans[i+sum].push_back(-s-((i-(num-sum)/2)*2-1)+3*s+1+tmp);
				ans[i+sum].push_back(-(num-sum-i+1)+3*s+1+tmp);
				ans[i+sum].push_back(s+i+3*s+1+tmp);
			}
			for(int i=1;i<=num;i++){
				for(int j=0;j<ans[i].size();j++)cout<<ans[i][j]<<" ";
				cout<<"\n";
			}
		}
		else if(n%2==1&&m%2==0){
			int num=0;
			cout<<((n-1)/m)+((n-1)%m!=0)<<"\n";
			for(int i=1,j=n;;){
				if(j-i+1<m){
					for(;i<j;i++,j--)cout<<i<<" "<<j<<" ",num++;
					break;
				}
				for(int k=1;k<=m/2;k++,i++,j--)cout<<i<<" "<<j<<" ";
				cout<<"\n";
			}
			if(num!=0){
				for(int i=1,j=n;i<=m/2-num;i++,j--)cout<<i<<" "<<j<<" ";
				cout<<"\n";
			}
		}
		else if(n%2==0&&m%2==1)cout<<"-1\n";
		else{
			int num=0;
			cout<<(n/m)+(n%m!=0)<<"\n";
			for(int i=1,j=n;;){
				if(j-i+1<m){
					for(;i<j;i++,j--)cout<<i<<" "<<j<<" ",num++;
					break;
				}
				for(int k=1;k<=m/2;k++,i++,j--)cout<<i<<" "<<j<<" ";
				cout<<"\n";
			}
			if(num!=0){
				for(int i=1,j=n;i<=m/2-num;i++,j--)cout<<i<<" "<<j<<" ";
				cout<<"\n";
			}
		}
	}
	return 0;
}
/*
P12356[Rabbit Panic (Hard Ver.)] 
Easy Ver.是怎么评上绿的？
而且这个Hard Ver.也非常奇怪啊
就是这个Hard Ver.和Easy Ver.说是要输出最小操作情况
但是真正会被最小操作所影响的只有一种情况
这就很难绷了
就是nm都为奇数的情况
因为别的情况下直到一步才会重复用数
所以一定是最优的
只有nm都为奇数才会使得每一轮都会选n/2+1
重复了太多次
比如说讨论区hack:
7 3
你Easy Ver.就是： 
3
1 7 4
2 6 4
3 5 4
但是Hard Ver.却是：
2
1 5 6
2 3 7
所以就是说需要让重复的数尽可能的少
那就很不好搞了
主要是m为偶数就得是两轮操作对称
很不好控啊
但是转化一下不就是-n/2到n/2吗？
每轮选m个使得和为0
这不好搞啊
能发现的只有一个大的数必定能够抵掉另一边两个小的数
但是这很难保证不重复啊
只能说优先从大的开始消
消大的时候尽量选两个接近的消
就是如果要消x
跟x相抵消的就最好是x/2-1到x/2+1之类的
因为这样消掉的数足够大
不会出现后面小的数无法消掉的情况
试着写写看吧
绷
这玩意真不好写啊
弘文了
再仔细想想
我们有没有一些可以扔掉的东西
比如说实际上我们奇数只用考虑3
因为其它的多的部分直接对应就好了
然后我们最佳的情况肯定是重复的最少
所以答案大胆猜测一下是y-1/3上取整
其中y是去掉m-3的部分处理的数后剩下的数的数量
-1是因为最中间的数不需要操作
可以发现当y=3的倍数加一的时候是卡的最死的
但是如果是奇数就不满足我们n是奇数的限制了
所以y其实是6的倍数+1
设y=6x+1
那么操作次数就是2x
那么6x+1个数用2x步怎么可能呢？
哦哦哦要把最中间的数去掉
那就是6x个数用2x步操作出来
那么刚好每个数都操作一次
那么就尝试把6x个数分成三组
每次操作从三组中分别取一个数操作
但这不好分啊
还要保证每次操作的三个数的和是相等的（即为最中间那个数的3倍）
不好搞
考虑按大小刚好分成三份
设取x,y,z
那么x在[-3x,-x-1]
y在[-x,x]且不为0
z在[x+1,3x]
那么就有x+y+z=0
发现x和z的值域是恰好相反的
所以-x+y+z=0
并且x在[x+1,3x]
转化一下成y=x-z
值域去掉一个x
那么就是x和z在[1,2x]
y在[-x,x]且不为0
那么发现是两个[1,2x]的排列相减后刚好出现了[-x,x]中除了0之外的所有数
那么假定z这个排列是1到2x
那么就只需要搞x就可以了
手玩找一下
发现2,4,6,8···2x,1,3,5···2x-1是可行的
转化一下
x:2,4,6,8···2x,1,3,5···2x-1
y:1,2,3,4···x,-x,-x+1,-x+2···-1
z:1,2,3,4···x,x+1,x+2,x+3···2x
然后把值域上去掉的x加回去
x:x+2,x+4,x+6,x+8···3x,x+1,x+3,x+5···3x-1
y:1,2,3,4···x,-x,-x+1,-x+2···-1
z:x+1,x+2,x+3,x+4···2x,2x+1,2x+2,2x+3···3x
再把x给反回去
x:-x-2,-x-4,-x-6,-x-8···-3x,-x-1,-x-3,-x-5···-3x+1
y:1,2,3,4···x,-x,-x+1,-x+2···-1
z:x+1,x+2,x+3,x+4···2x,2x+1,2x+2,2x+3···3x
最后再把值化为下标（其实就是给值加上3x+1啦）
但是没有卡死怎么搞呢？
哦哦哦反正是/3
所以差的肯定是1或2
好说
差1就拿两次带上最中间的数
差2就只拿一次就可以了
谔谔这个东西怎么这么难写啊
主要是你这个x不好判啊
***
有一种可以尝试的做法是枚举我们的3处理的数的数量
说白了就是3处理的是2x个数
然后我们枚举2x
**
给自己都搞晕了
**好不容易写出来了凭啥WA？
哦那个边界要在扔之前算
*
怎么还是WA？
哦哦哦后面得重算
哦Easy Ver.好像已经降黄了？
道爷
我成啦！
*/
```

---

## 作者：forest114514 (赞：0)

首先我们得知道 easy Ver 怎么做：

特判 $m=1$ 的情况，然后：

$n$ 偶数，$m$ 偶数，显然每次对称选 $m$ 个就行了，不超过 $\lceil\frac{n}{m}\rceil$ 次一定最优。

$n$ 偶数，$m$ 奇数，无解。

$n$ 奇数，$m$ 偶数，每次对称选 $m$ 个，不超过 $\lceil\frac{n-1}{m}\rceil$ 次一定最优。

$n$ 奇数，$m$ 奇数，对称选 $m$ 个，要把中间那个选上其他参照 $m$ 为偶数这样次数变成了 $\lceil\frac{n-1}{m-1}\rceil$，但是实际上不是最优的。

比如 $n=7,m=3$ 的情况，其实最优操作是先操作 $1,5,6$ 再操作 $2,3,7$ 这样只用操作两次而非 $3$ 次。

发现本质就是能找出多少个 $3$ 个数平均数为 $\frac{n+1}{2}$，这样在 $m>3$ 的时候也一样的。

我们多手玩几组 $m=3$：

$n=9,m=3$，我们的操作是 $1,5,9/2,6,7/3,4,8$。

$n=11,m=3$，我们的操作是 $1,6,11/2,6,10/3,7,8/4,5,9$。

$n=13,m=3$，我们的操作是 $1,9,11/2,6,13/3,8,10/4,5,12$。

首先我们发现最小操作次数都是都是 $\lceil\frac{n-1}{m}\rceil$，所以我们猜测这就是答案，先试图构造取到到这个下界。

对于 $m>3$，我们设 $t=\lceil\frac{n-1}{m}\rceil$，我们先取走最小的和最大的 $\frac{(m-3)}{2}t$ 个数，然后不难发现最坏情况又变成了证明 $m=3$ 的问题可以取到下界。

发现限制最强的时候在 $m=3,n=6k+1$，其他时候 $6k+3,6k+5$ 都存在构造是先取若干次当前最小和最大和 $\frac{n+1}{2}$ 使得最后又变回了 $n=6k+1$ 的问题。

然后考虑怎么解决 $m=3,n=6k+1$ 的问题。

然后对于 $n=13,n=7$ 这两个 $n=6k+1$ 的问题，我们发现我们的构造都是在 $[1,2k],[2k+1,3k+1)\cup(3k+1,4k+1],[4k+2,6k+1]$ 中各选一个数，最后得到若干三元组和为 $9k+3$。

观察到 $1+2k+1+4k+2=6k+3=(9k+3)-3k$，我们不妨给第一二三段的数分别减去 $k,3k+1,5k+2$。

这样变成了值域 $[-k+1,k],[-k,0)\cup (0,k],[-k,k-1]$，选出的数和为 $0$，这样好考虑了。

发现 $[-k+1,k]$ 和 $[-k,k-1]$ 是一段对称的区间，我们取反一下得到：

选择 $x\in [-k+1,k],y\in [-k,0)\cup (0,k],z\in [-k+1,k]$，使得 $x-z+y=0\to x-z=y$，后者因为 $y$ 是关于原点对称的，相当于就是 $[-k+1,k]$ 的数选一个错排使得 $a_i-a_{p_i}$差不重复而且在 $[-k,0)\cup (0,k]$ 之间。

我们发现错排 $2,4,6,8,\ldots,2k,1,3,5,7,\ldots,2k-1$ 是合法的，这个还是要画半天的/ll。

对于 $m>3$ 如何转化到 $m=3$，本人的做法是我们考虑我们 $m=3$ 的时候 $t$ 次操作需要至少 $2t$ 个空位，而 $t$ 次操作 $m-3$ 个数最多覆盖 $(m-3)t$ 个位置，于是我们把一共 $\min(n-1-2t,(m-3)t)$ 个空位用于处理每次操作多余的 $m-3$ 个数，剩下的数我们找到一个最大的 $2k\leq t$  使得 $6k+2(t-2k)\leq n-\min(n-1-2t,(m-3)t)$，我们此时相当于只需要构造 $n=6k+1,m=3$ 的情况，其余情况都可以通过对称两两完成。

感觉通过手玩小数据后每一步都貌似不是很难，但是综合一下就变大 bot 构造题了。

实现细节可以看代码：

```cpp
void solve(){
	read(n,m);
	if(m==1){
		if(n==1) return puts("0"),void();
		else return puts("-1"),void();
	}
	
	if(n%2==0&&(m&1)) return puts("-1"),void();
	int t;
	if(m%2==0){
		write(t=(n-(n&1)+m-1)/m,'\n');
		for(int i=1;i<=n/2;i+=m/2){
			bool fl=0;
			if(i+m/2-1>n/2){
				i=n/2-m/2+1;
				fl=1;
			}
			rep(j,1,m/2) write(i+j-1,' '),write(n+1-(i+j-1),' ');puts("");
			
			if(fl) break;
		}		
		return;
	}
	write(t=(n-1+m-1)/m,'\n');
	int nn=n;
	int opt=min(n-1-t*2,(m-3)*t),ad=opt/2,lim=ad;
	int tot=t;
	while((tot&1)||tot*3+(t-tot)*2>nn-1-opt) --tot;
//	n=tot*3+1;	
	

	int cur=1;	
	rep(i,1,t-tot){
		rep(j,1,(m-3)/2) write(cur+j-1,' '),write(nn+1-(cur+j-1),' ');
		cur+=(m-3)/2,cur=min(lim-(m-3)/2+1,cur);
		
		write(ad+i,' '),write((nn+1)/2,' '),write(nn+1-(i+ad),'\n');
	}
	
	ad+=t-tot;
	int k=tot/2;
//	cerr<<t<<" "<<tot<<endl;
	rep(i,1,k){
		rep(j,1,(m-3)/2) write(cur+j-1,' '),write(nn+1-(cur+j-1),' ');
		cur+=(m-3)/2,cur=min(lim-(m-3)/2+1,cur);
		
		int x=-k+i,z=-k+2*i,y=x-z;
		y=-y,z=-z;
//		cerr<<x<<" "<<y<<" "<<z<<" "<<x+y+z<<endl;
		write(x+k+ad,' '),write(y+3*k+1+ad,' '),write(z+5*k+2+ad,'\n');
		
		rep(j,1,(m-3)/2) write(cur+j-1,' '),write(nn+1-(cur+j-1),' ');
		cur+=(m-3)/2,cur=min(lim-(m-3)/2+1,cur);
		
		x=i,z=-k+2*i-1,y=x-z;
		y=-y,z=-z;
//		cerr<<x<<" "<<y<<" "<<z<<" "<<x+y+z<<endl;
		write(x+k+ad,' '),write(y+3*k+1+ad,' '),write(z+5*k+2+ad,'\n');
	}
}
```

---


# 基础构造练习题 1

## 题目背景

2025.5.6：加强操作次数限制，并调整了部分分设计。

2025.5.8：再次加强操作次数限制，并调整了部分分设计。之前的提交记录已经全部重测。


## 题目描述

有一列实数，对于**每一次**操作，可以选择两个实数，把它们同时变为两数之积。

例如，给定 $7, 4, 5$，对 $7$ 和 $5$ 进行一次操作，原数列变为 $35, 4, 35$。

给定数列的长度 $n$，你的目标是找到一种操作方案，使得对于任意长度为 $n$ 的实数列，按照该操作方式操作之后，数列的每一项数值都相同。


## 说明/提示

Idea：Milmon，Solution：Milmon & _fewq，Code：Milmon & _fewq，Data：Milmon，Check：Konata28。

对于所有测试数据，保证 $T = 20$，$2 \leq n \leq 2^{10}$。本题共包含 $3$ 个子任务：

| 子任务编号 | 分值 | 测试点数目 |
| :-: | :-: | :-: |
| $1$ | $10$ | $1$ |
| $2$ | $30$ | $1$ |
| $3$ | $60$ | $3$ |

对于子任务 1，选手只需要正确回答是否存在操作方案即可获得满分。

对于子任务 2，对于每组测试数据分别计分：对于一组测试数据，只要选手正确回答是否存在操作方案，并且给出的操作方案均合法，就可以得到该测试点 $5 \%$ 的分数。选手在该测试点得到的分数等于每组测试数据得分的总和。

对于子任务 3：

- 若存在一组测试数据，选手没有正确回答是否存在操作方案，或者给出的操作方案不合法，那么选手在该测试点不得分；
- 否则，若对于所有存在操作方案的测试数据，选手都给出了操作次数不超过 $2n - 1$ 的方案，那么选手在该测试点得到全部分数；
- 否则，设所有存在操作方案的测试数据中选手给出的最大操作次数为 $s$，定义函数：

  $$
  f(x) = \frac{2 \times 10^7}{(x + 4\,000)^{0.7}}
  $$

  则选手在该测试点的得分为：

  $$
  \frac{f(s) - f(500\,000)}{f(2\,047) - f(500\,000)} \times 55
  $$

  下表为在一些特殊的 $s$ 中选手在该测试点得到的分数：

  | $s =$ | 选手得分 |
  | :-: | :-: |
  | $500\,000$ | $0$ |
  | $400\,000$ | $0.436$ |
  | $300\,000$ | $1.106$ |
  | $200\,000$ | $2.302$ |
  | $100\,000$ | $5.258$ |
  | $50\,000$ | $9.836$ |
  | $10\,000$ | $29.402$ |
  | $5\,000$ | $41.003$ |
  | $3\,000$ | $49.391$ |
  | $2\,047$ | $55$ |

提示：若能够完成正确性判断，但是无法完成构造的，也需要按照输出格式输出，例如你可以输出一个 $m = 0$ 的构造。类似地，输出时请判定 $0 \leq m \leq 5 \times 10^5$ 是否成立，若评分时存在一组数据的 $m > 5 \times 10^5$，则你无法得到任何分数。


## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
1
1 2
0
1
4
1 2
3 4
1 3
2 4```

# 题解

## 作者：xxgirlxx (赞：20)

## 题外话

非常好的题目，使我的草稿本骤减一半。

非常好的题目，是真的，头一次见到成长类的构造题（个人感觉这种感觉非常新奇啊）。

这题主播的步数经历是：$392960\rightarrow 391426\rightarrow 295554\rightarrow 14855\rightarrow 3577\rightarrow 2053\rightarrow 2050\rightarrow 2047$，总共写了八版代码，主播也是神人了，但是这样一步步推出来的感觉确实比直接看出来要有成就感的多。

最后的代码里附有主播的做题游记（逃。

## 题目思路

首先搞清楚：奇数无解，具体地：

因为操作的性质导致，我们操作后必定产生的是跟原来两个不同的数不同的两个相同的数，除非有 $1$，但是题目要求的是通解，所以不能考虑有 $1$ 这种特殊情况。那么，我们可以得出：最终的最大值一定是由 $n$ 个数两两配对组成的，因为奇数个数无法做到两两配对，所以奇数无解。

$392960$ 做法：

样例中的 $2$ 和 $4$ 都是 $2^x$，太特殊，所以从 $6$ 开始考虑并模拟。

首先用 $4$ 的方法使得前四个相等在用一步使得后两个数相等，即可得到：

$$a,a,a,a,b,b$$

然后根据 $4$ 的做法我们可以让后四个相等，因此我们需要让前面两个相乘后跟后面的结果相等。

发现第一个 $b$ 在经过 $4$ 的操作后必定乘一个 $ab$（如果后面四个都不变的话），也就必定有一个 $b^2$，因此我们要让前面两个乘起来后有一个 $b^2$，一种可行的操作是让前两个数分别和第一个 $b$ 操作一次，这样就有两个 $b$ 了，即：

$$ab,a^2b,a,a,a^2b,b$$

这个时候我们发现：前两个数相乘第二个数恰好也是乘了一个 $ab$，而且初始值跟倒数第二个数是一样的。所以最终的值也一定是一样的。

然后我们尝试扩展，然后发现不管留四个后前面有几个，都是可以通过这种方式来成功构造的，具体地：

$$a,a,\cdots,a,a,a,b,b$$

然后将除了最后四个数之外的所有数都与倒数第二个数操作：

$$ab,a^2b,\cdots a^{n-4}b,a,a,a^{n-4}b,b$$

然后将除了最后四个数之外的所有数首尾相乘：

$$a^{n-3}b^2,a^{n-3}b^2,\cdots a^{n-3}b^2,a,a,a^{n-4}b,b$$

再对最后四个数使用 $4$ 的方式：

$$a^{n-3}b^2,a^{n-3}b^2,\cdots a^{n-3}b^2,a^{n-3}b^2,a^{n-3}b^2,a^{n-3}b^2,a^{n-3}b^2$$

最终步数在 $n^2$ 级别，最大步数 $392960$，得分 $40$。

$391426$ 做法：

观察样例并扩展可以发现如果 $n=2^x$ 就不用一个个加，所以特判一下这种情况，但是优化不大且只有部分数据受到优化。

最终步数在 $n^2$ 级别，最大步数 $391426$，得分 $40$。

$295554$ 做法：

考虑把 $n=2^x$ 融进通解里，发现我们在末尾加两个数的做法是只要求最后两个数相等且除了最后两个数之外其他的所有数也相等即可，因此我们可以先用 $n=2^x$ 的做法快速将前面的 $2^x$ 个做完，剩下的再用在末尾加两个数的做法做。这样就所有都有优化，但是优化不大。

最终步数在 $n^2$ 级别，最大步数 $295554$，得分 $41$。

$14855$ 做法：

发现 $2^x$ 做法之所以快是因为其是把两个内部所有数分别相等的区间合并了，因此考虑把这个做法放到通解上，考虑分治，如果该区间分开后是奇数，那么就去掉最后两个再分治，分治完后再把这两个数加上去，如果该区间是偶数，那么就直接分治。每个数据都能得到巨大的优化。

最终步数在 $n \log n$ 级别，最大步数 $14855$，得分 $63$。

$3577$ 做法：

发现我们在末尾加两个数的方法是非常浪费的，一次就要 $\frac{3}{2}n$ 的操作步数，这肯定是无法接受的。

我们从最开始的性质入手：两两配对，这个令人想到两个差相等的等差头接尾。欸！等差还真可以，但是差的不是值，是因子数，我们从 $1$ 一路操作到 $n$ 就会使得 $2$ 到 $n$ 中，前一个数比后一个数少一个因子，这恰是我们想要的，但是我们需要两个等差来配对，所以需要分成两段，一半做前半段，一半做后半段，具体地：

前一半：$abcde,ab,abc,abcd,abcde$

后一半：$fghij,ghij,hij,ij.fghij$

但是前后的数不相等啊，这怎么做到互补呢？我们可以使他们相等，因为只是要互补，所以只要底子是相等的即可：

前一半：$abcde,ab,abc,abcd,abcde$

后一半：$abcde,bcde,cde,de,abcde$

翻译：其实就是操作 $i(1\le i\le \frac{n}{2})$ 和 $i+\frac{n}{2}$。

感觉对互补讲的非常抽象的，这里附一张关于讲互补的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9km7m321.png)

可以看到除了差一个因子之外的所有数都可以变成 $\prod_{1}^{n}a_i$，但是差一个因子的那两个数怎么办呢？先用加两个数的方法垫上。

注意特判 $2$！

最终步数在 $n$ 级别，最大步数 $3577$，得分 $86$。
$2053$ 做法：

发现加两个数还是太浪费了，有没有更好的做法呢？有的兄弟有的，不是差一个因子吗？我们给它留不就好了，留出两个数并使它们跟构成差一个因子的两个数所差的两个因子的四个数相等，用一个 $6$ 的 $11$ 步操作（之前的代码就能跑出来），这样就不用用加两个数的做法了。

注意因为前面的数是两个数互相乘了的，所以留的两个数也要互相乘。

特判 $2,4,6$。

最终步数在 $n$ 级别，最大步数 $2053$，得分 $94$。

$2050$ 做法：

发现有我们乘的目的就是使他们相等，而经过 $6$ 的操作就使得有第一个数的因子和有第 $n-2$ 个数的因子构成这两个因子的四个数相等了，也就不需要乘了，留下来的两个数也不需要乘了。

特判 $2,4,6$。

最终步数在 $n$ 级别，最大步数 $2050$，得分 $94$。

$2047$ 做法：

发现还是多了，但是别的地方已经优化到极限了，问题只能出现在这个 $6$ 的 $11$ 步操作上，发现我们留下来的两个数是分别给缺的那两个数作补充，因此没必要让六个数都相等，所以分个组，三个数无解就再拉一个数进来，两组 $4$ 的操作共 $8$ 步刚好又省下 $3$ 步。

特判 $2,4,6$。

最终步数在 $n$ 级别，最大步数 $2047$，得分 $100$。

[代码](https://www.luogu.me/paste/7phxy251)

---

## 作者：UnyieldingTrilobite (赞：17)

首先来考虑这样一个问题：我们现在手上有数 $a_1,a_2,a_3,a_4,\cdots,a_{t-1}$ 各两个，另有 $a_t$ 四个，我们要如何构造一个比较好的操作次数来完成题目的要求？

记 $x=a_t$。我们先把三个 $x$ 放着不动，一个 $x$ 依次和 $a_1,a_2,\cdots,a_{t-1}$ 操作。此时我们剩下的数形如：$x,x,a_1x,a_1a_2x,\cdots,(\prod_{j=1}^ia_j)x,\cdots,(\prod_{i=1}^ta_i),(\prod_{i=1}^ta_i),a_1,a_2,\cdots,a_t$。这一步一共 $t-1$ 次操作。

记 $y=\prod_{i=1}^ta_i$。我们令 $y$ 依次和 $a_t,a_{t-1},\cdots,a_1$ 操作。此时我们剩下的数形如：$x,x,a_1x,a_1a_2x,\cdots,(\prod_{i=1}^{t-2}a_i)x,y,xy,a_{t-1}a_ty,\cdots,(\prod_{j=i}^ta_j)y,\cdots,(\prod_{i=1}^ta_i)y,(\prod_{i=1}^ta_i)y$。其中最后两项实际上就是 $y^2$。这一步一共 $t$ 次操作。

$\forall 1\le i\le t$，将 $(\prod_{j=1}^{i-1}a_j)x$ 与 $(\prod_{j=i}^ta_j)y$ 操作，得到两个 $xy^2$。这一步一共 $t$ 次操作。

此时场上不为 $xy^2$ 的数还有 $x$ 和 $y^2$ 各一个，操作一次即可。这一步一共 $1$ 次操作。

以上加起来一共 $3t$ 次操作。

回到原题，$n$ 为奇数时显然无解（因为 $n>1$），$n\le 2$ 显然特判，接下来考虑 $n$ 是 $\ge 4$ 的偶数，记为 $2t+2$（$t\ge 1$）。

对于 $1\le i\le t+1$，我们对 $a_{2i-1}$ 和 $a_{2i}$ 操作，这一步一共 $t+1$ 次操作。接下来我们对 $a_{n-3}$ 和 $a_{n-1}$ 操作，$a_{n-2}$   和 $a_n$ 操作，这一步一共 $2$ 次操作。加起来一共 $t+3$ 次操作，此时我们把问题化归为了一开始解决的那个。于是一共 $4t+3$ 次操作，我们在 $2n-1$ 步内对原问题完成了解决。

代码对着这个东西实现就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int T, n;
  for (cin >> T; T; --T) {
    if (cin >> n, n & 1) {
      cout << "0\n";
      continue;
    }
    if (cout << 1 << '\n', n == 2) {
      cout << "1 1 2\n";
      continue;
    }
    cout << (n << 1) - 1 << '\n';
    auto op = [](int x, int y) { cout << x << ' ' << y << '\n'; };
    int t = (n >> 1) - 1;
    for (int i = 1; i <= t + 1; ++i) op((i << 1) - 1, i << 1);
    op(n - 3, n - 1), op(n - 2, n);
    for (int i = 1; i <= t - 1; ++i) op(n - 1, (i << 1) - 1);
    for (int i = t; i; --i) op(n - 1, i << 1);
    for (int i = 1; i < t; ++i) op((i << 1) - 1, (i + 1) << 1);
    op(2, n - 3), op(n - 1, n);
  }
  return cout << flush, 0;
}
```

---

## 作者：Hoks (赞：16)

## 前言
好玩构造题。

摘自[交互、构造、博弈](https://www.luogu.com.cn/training/676672)。

后记：根本没想到这么能优化，目前流程是 $392960\rightarrow295554\rightarrow14855\rightarrow3577\rightarrow2050\rightarrow2047$，应该是全流程了。
## 思路分析
没有很多思路，那就先随便手玩看看性质。

看一眼样例发现 $2,4$ 的情况的构造很规整，好像比较容易推出 $2^n$ 如何构造。

对于 $2^n$ 的情况，我们考虑先构造出两块 $2^{n-1}$ 个相等的数，然后再将这两块对应位置的数用操作合并即可。

这样不断递归的做就可以做出序列长度为 $2^n$ 的情况。

那对于非 $2$ 的幂次的情况呢？难道都是无解吗？

考虑到我们每次操作是合并两个数让两个数变为相同的值，所以奇数看起来貌似很不行的样子？

那么就来尝试证明下奇数是不可行的（下列思路启发来自于出题人，猫猫想了半天差一步）。

其实我们只需要令 $a_i$ 为第 $i$ 个质数，那么如果给出的方案可以使这样的 $a$ 序列满足条件，就一定是都满足条件的。

这点不难理解，因为在这个限制条件下对于一项 $a_i$，并不能用其他的项凑出来，也就是其是唯一的。

为了证明 $n$ 为奇数不可行，我们考虑找到一个当 $n$ 为奇数时并不满足的必要不充分的条件。

考虑到最后的数是都相同的，也就是说**最大值出现了 $n$ 次**，接着就是尝试证明**最大值的出现次数不可能为奇数**。

在未操作前最大值出现次数为 $1$ 次恰为奇数，这是一个极端的边界，我们先给这部分搞掉。

因为 $n\ge3$，以及 $a_n$ 不可能用其他数凑出来和他相等，所以总有一步你是要操作到 $a_n$ 或是通过操作别的数得到比 $a_n$ 更大的值。

或者说在可能的操作过程中，最大值**总会在**某一时刻被一个操作更新，而不可能一直是 $a_n$。

所以在这一步操作完之后，操作的两个数都变成了最大值，此时的最大值出现次数是偶数次。

接下来影响最大值的操作大概有如下三种：
1. 我们操作产生了更大的值，此时出现次数回到 $2$。
2. 我们操作产生了当前最大值，此时出现次数增加 $2$ 次，仍然为偶数。
3. 我们操作了当前最大值和另一个数，此时操作出来的值一定比当前最大值更大，出现次数回到 $2$。

所以综合上述情况，我们知道最大值的出现次数肯定是偶数次。

也就是说 $n$ 为奇数的情况一定是不可行的。

接下来我们尝试来构造 $n$ 为偶数的情况。

构造是怎么样的一个过程？

肯定是将 $n$ 划分为两个数 $x,y$，然后构造出 $x$ 个相同的数，构造出 $y$ 个相同的数，再将这两个情况合并在一起。

这是一个分割子问题的思想。

根据前面的证明我们知道 $x,y$ 肯定是偶数。

构造而言不妨来考虑一些极端的情况，我们直接令 $y=2$，相当于是尝试往 $x$ 个相同的数后面拼上 $2$ 个数。

设这相同的数分别为 $a,b$，当前序列即为：
$$\underbrace{a,a,\dots,a}_{x},b,b$$
考虑到最后合并完后是一定有 $b$ 存在的，而 $b$ 只有两个，必然是要围绕着 $b$ 去一直操作先让 $b$ 在前面 $x$ 个数中都出现的。

这样想还是太困难了，让我们先来试试 $x=2$ 的情况。

此时序列为：
$$a,a,b,b$$
我们的构造方式为 $1,3$ 操作 $2,4$ 操作，即可变为：
$$ab,ab,ab,ab$$
然后推广一下来考虑 $x=4$ 的情况。

此时序列为：
$$a,a,a,a,b,b$$
第一步操作肯定是操作一个 $a$ 一个 $b$（不然都是和原序列本质相同的无意义的）。

那么我们得到：
$$ab,a,a,a,ab,b$$
这时 $3,4$ 位置上的 $a$ 可以考虑用 $x=2$ 时的方法搞掉，还需要变动的是 $2$ 号位置。

因为最后的操作是 $3,5$ 和 $4,6$，会使最后 $4$ 个数都相同，所以我们想要让 $1,2$ 操作后的 $1,2$ 也能和后面的数相同。

那就需要让 $1$ 的 $a$ 的次数加上 $2$ 的 $a$ 的次数等于 $3$ 的 $a$ 的次数加上 $5$ 的 $a$ 的次数。

对于 $b$ 也同理要满足这点。

注意到什么？

注意到当前情况下 $1,3$ 的 $a$ 的次数是相同的，所以进行一次 $2,5$ 操作，就可以让 $5$ 上 $a$ 的次数和 $2$ 相同。

当前序列即为：
$$ab,a^2b,a,a,a^2b,b$$
接下来我们让 $5,6$ 相等，再套用 $x=2$ 的操作，变化步骤即为：
$$ab,a^2b,a,a,a^2b^2,a^2b^2$$
$$ab,a^2b,a^3b^2,a,a^3b^2,a^2b^2$$
$$ab,a^2b,a^3b^2,a^3b^2,a^3b^2,a^3b^2$$
不难发现，在我们的精心构造下此时刚好满足了 $1,2$ 操作后和剩下四个数都相同，$a,b$ 的次数都恰好满足。

这下构造方案就呼之欲出了，我们考虑对于一般的情况。

构造一个 $a$ 的次数等差的一个序列，这样我们可以通过首尾操作的方法让 $a$ 的次数都变得相同。

具体的，考虑对于序列：
$$\underbrace{a,a,\dots,a}_{x},b,b$$
我们先进行操作 $i,x+i(i\le x-2)$，那么序列就变成了：
$$\underbrace{ab,a^2b,\dots,a^{x-2}b,a,a}_{x},a^{x-2}b,b$$
然后我们套用 $x=2$ 的构造：
$$\underbrace{ab,a^2b,\dots,a^{x-2}b,a,a}_{x},a^{x-2}b^2,a^{x-2}b^2$$
$$\underbrace{ab,a^2b,\dots,a^{x-2}b,a^{x-1}b^2,a}_{x},a^{x-1}b^2,a^{x-2}b^2$$
$$\underbrace{ab,a^2b,\dots,a^{x-2}b,a^{x-1}b^2,a^{x-1}b^2}_{x},a^{x-1}b^2,a^{x-1}b^2$$
最后我们进行操作 $i,x-1-i(i\le\frac{x-2}{2})$。

也就是将 $a$ 的次数为 $i$ 次的和为 $x-i-1$ 次的拼在一次，恰好得到 $a^{x-1}b^2$。

这样我们最后就得到了 $\underbrace{a^{x-1}b^2,\dots,a^{x-1}b^2}_{x+2}$，完成了 $x$ 个和 $2$ 个的合并。

于是我们就完成了这题。

[猫猫的代码（392960 次）](https://www.luogu.com.cn/paste/euj99sx8)。

### update（小优化）

由于题目修改了计分方式，把次数限制从 $5\times10^5$ 改为了 $3\times10^5$，所以更新一下构造方案。

先算一下上面那种情况我们的构造方案。

我们是枚举了左端长度 $x$，然后每次合并一个 $2$ 进来花费的步数是 $1+x-2+3+\frac{x-2}{2}=\frac{3x}{2}+1$。

总的步数也就是 $\sum\limits_{i=1}^{\frac{n}{2}} 3i-2$（请注意这里加上了最开始的第一步整体平移了一下重写了式子，所以是 $3i-2$ 不是 $3i+1$）。

这是一个简单的等差数列求和，拆开可以得到为 $\frac{3n^2-2n}{8}$。

代入极限数据 $n=1024$ 可以得到操作次数为 $392960$，直接被卡爆了。

所以我们来考虑优化。

不难发现其实这个次数相差也不是特别多，所以随便加点小优化就能过了（笔者也不知道还能不能再优化了，目前是就想了 $5$ 分钟搓出来的）。

我们考虑到前面最大的浪费是在什么地方？

就是说比如我们想要让 $256$ 个数字都变相等，选择了 $2$ 个 $2$ 个的加，这也太浪费了。

考虑到最初我们写过一个 $2^n$ 的处理方法，这个次数显然少的多了。

直接把这个 $2^n$ 的做法套上来先把这部分搞掉就可以做到优化很多步数了。

算一下大概是多少步。

在卡满的极限数据下，我们把最初的 $512$ 个数合并的这一步跳过了，也就是节约了 $98176$ 步，并用 $2304$ 步完成了这个部分。

再加上卡满的极限次数实际上是 $n=1022$，所以最后的次数来到 $391426-98176+2304=295554$ 步，极限压过去。

[猫猫的代码（295554 次）](https://www.luogu.com.cn/paste/yvcykdxo)。

### update（$O(n\log n)$ 做法）

目前我们有哪些操作手段，只有末尾增加 $2$ 个数这种操作吗？

考虑溯源。

在这题的最开始，我们想到的 $2^n$ 做法中，可以用 $m$ 次实现两段长为 $m$ 的相同的数的合并。

这个操作是非常优秀的，设 $f_n$ 表示长为 $2^n$ 的序列需要的合并次数，可以得到 $f_{i}=2f_{i-1}+2^{i-1}$。

最后求一个通项可以得到 $f_n=2^{n-1}n$，也就是 $O(n\log n)$ 级别。

如何推广这个合并操作呢？

我们尝试尽可能的将原本的序列均分，把分割出的两部分都搞成相同后再用上述的合并操作，最后再修改末尾可能需要加上的 $2$ 个数，就可以得到一个更为优秀的做法。

这时我们需要考虑怎样分割序列最为优秀了。

具体的，对于一个长度为 $i$ 的序列，我们可以取掉最后的 $j$ 个数先不管，把前面的 $i-j$ 个数均分为两半，操作完合并后再把最后的 $j$ 个数合并进来。

设长为 $n$ 的序列答案为 $f_i$，转移式即为：
$$f_i=\min\limits_{j=0}^i 2f_{\frac{i-j}{2}}+h(i)-h(i-j)+\frac{i-j}{2}$$
其中 $h(n)=\frac{3n^2-2n}{8}$，即为上面做法中只使用合并末尾两个数做法的代价。

感性理解/直接跑 dp 打表/拆开 $h(i)$ 配方取最小值等方法，都可以得到当 $i\equiv0\pmod4$ 时，取 $j=0$ 最优，否则取 $j=2$ 最优。

此时的操作次数可以跑一遍 dp 算一下，在 $n=1022$ 时取最大值为 $14855$ 次，已经做到了 $O(n\log n)$，是一个比较重大的飞跃了。

[猫猫的代码（14855 次）](https://www.luogu.com.cn/paste/2wayfx9v)。

### update（$\frac{7}{2}n-7$ 做法）

$O(n\log n)$ 还不够优秀，这题能否线性呢？

我们考虑到前面的合并操作递归调用的话，$\log$ 在这是跑不了的。

而末尾加 $2$ 的操作就更劣了，每次都是 $O(n)$ 的。

所以我们考虑能否先线性构造出 $n-2$，最后再用一次加 $2$ 操作，这样就可以把复杂度控制在 $O(n)$。

那么如何快速构造 $n-2$ 个相同的数？

我们设最开始的序列为 $a_1,a_2,\dots,a_n$ 这样。

那么最后的序列得到的唯一的数肯定可以写做 $\prod\limits_{i=1}^n a_i^{b_i}$ 的形式，其中 $\forall i\in[1,n],b_i\ge1$。

我们有一个想法是，先把 $1$ 和其他的所有数都操作一遍，这样就可以得到 $\prod\limits_{i=1}^n a_i,\prod\limits_{i=1}^2 a_i,\prod\limits_{i=1}^3 a_i,\dots,\prod\limits_{i=1}^n a_i$ 的一个序列。

但这样接下来就没法做了。

所以我们考虑类似于前面末尾加 $2$ 的想法灵感，尝试构建一个次数等差的序列。

也就是说，我们尝试让由 $i$ 个数乘起来得到的数和由 $n-i$ 个数乘起来得到的数配对，这样给他们两两乘一下就可以都变成 $\prod\limits_{i=1}^n a_i$。

现在的问题就是如何让他们刚好不重不漏。

不难发现我们前面的那个想法大概是一个前缀的状物，为了与他互补，我们尝试构建一个后缀状物。

或者说，我们先以 $\frac{n}{2}$ 为断点，将序列划分为长度相同的两段。

对于前面一段我们前缀相邻操作，对于后面一段我们后缀相邻操作，就可以得到：
$$\prod\limits_{i=1}^2 a_i,\prod\limits_{i=1}^3 a_i,\dots,\prod\limits_{i=1}^{\frac{n}{2}} a_i,\prod\limits_{i=\frac{n}{2}+1}^n a_i,\dots,\prod\limits_{i=n-2}^n a_i,\prod\limits_{i=n-1}^n a_i$$

这样的一个序列。

但这样前后还是不互补的，该怎么办呢？

可以发现的是，对于前面一半的一个位置 $i$，和后面的一个倒着对应的位置乘起来后缺少的因子，刚好就是在后一半对应的前 $i+1$ 个数。

所以我们先把 $i,i+\frac{n}{2}(1\le i\le\frac{n}{2})$ 先操作了，就能保证互补。

这样之后再进行上面的前后缀操作，最后再操作一下 $i,i+\frac{n}{2}+3(1\le i\le\frac{n}{2}-3)$ 就可以使其互补了。

这样刚好可以构造出 $n-2$ 个 $\prod\limits_{i=1}^n a_i$。

还没构造出来的两个不同的位置就是 $\frac{n}{2}-2$ 和 $\frac{n}{2}+3$。

我们套用上面的末尾加两个数的做法即可。

这样的总代价是 $h(n)-h(n-2)+\frac{n}{2}+2(\frac{n}{2}-1)+\frac{n}{2}-3=\frac{7}{2}n-7$，已经来到线性。

[猫猫的代码（3577 次）](https://www.luogu.com.cn/paste/5ey6b192)。

### update（$2n+2\sim 2n-1$ 做法）

其实 $2n+2$ 做法还是比较好想的。

考虑 $3577$ 次操作的时候，最浪费操作步数的还是末尾的加 $2$ 操作。

那为什么最后面的两个数不能用类似的构造只能用加 $2$ 操作呢？

因为他们的次数都是 $n-2$ 次，已然没有次数为 $2$ 次的数来和他们调平了。

所以思路就有了，我们考虑先保留 $n-1,n$ 这两个数用来补足最后出现的 $n-2$ 次的数。

但这里就有一个问题，由于最后两个 $n-2$ 次的数他所需要的两个因子分别是 $a_1a_{\frac{n}{2}}$ 与 $a_{\frac{n}{2}-1}a_{n-2}$，所以我们需要保证 $a_{n-1},a_n$ 可补足这两个因子，即需要保证他们都相等。

使用一次 $n=6$ 的 $11$ 次操作先钦定这些数都相等，就可以做到 $11+\frac{n}{2}-3+2(\frac{n}{2}-2)+\frac{n}{2}-4+2=2n+2$。

注意这里的第二部分中的 $-3$，是因为在 $3577$ 次的做法中，我们的操作是 $\forall i\in[1,\frac{n}{2}],(i,i+\frac{n}{2})$，而在这里我们保证了相等后，就不需要操作左右两个边界了，省下来两次。

[猫猫的代码（2050 次）](https://www.luogu.com.cn/paste/zextcbnf)。

接下来就是最后的一步优化了，这个优化就比较显然了。

我们发现还是有浪费啊，到底是在哪里浪费了呢？

注意到我们需要的是让 $a_{n-1},a_{1},a_{\frac{n}{2}}$ 相等，以及 $a_{n},a_{\frac{n}{2}-1},a_{n-2}$ 相等，并不需要让这六个数都相等。

这意味着什么，我们可以把一次 $n=6$ 的操作拆开，拆成两个 $n=3$ 的操作。

但是 $n=3$ 的时候是不可构造的，所以我们要令 $n=4$ 去构造，不妨把 $a_3,a_4$ 也拿过来，这样就刚好 $4$ 个一组可以调用 $n=4$ 时的操作了。

通过这样的方法我们可以把原来的 $11$ 次操作换成 $4+4=8$ 次操作，也就是抠出来了 $3$ 次操作，最后刚好 $2n-1$ 次操作，可以通过本题。

写代码的时候注意一下如果 $a_{n-1}$ 是和 $a_{\frac{n}{2}-3}$ 调平的话，他需要的因子是 $a_{\frac{n}{2}-1}a_{n-2}$，恰好是反过来的。

[猫猫的代码（2047 次）](https://www.luogu.com.cn/paste/9z29mq02)。

至此，我们完成了这题。

回顾一下整题的流程，我们刻画了 $2^n$ 时的合并操作，构造了末尾加 $2$ 的一般性操作，围绕着次数等差数列展开思考，通过调平配出了线性做法，尝试了一切可能的切入点最后完成这题，是非常好的构造练习题了。

---

## 作者：Pyrf_uqcat (赞：12)

### 前记（题外）

一觉醒来我重生了。只见眼前出现了一道基础构造练习题，这一世，我要夺回属于我的一切。

确实是构造好题。提交次数和经历的分数都挺多的，反倒可以当游记了。

分数经历：$14 \to 16 \to 33 \to 36 \to 63 \to 0 \to 100$

[共交了 34 次，起到了拉低通过率的作用。](https://www.luogu.com.cn/record/list?pid=P12417&user=1137860&page=1)


---


### 对于存答案的方式

本来是用二维数组存的，需要一个变量记录答案总数。还是改成 `vector< pair<int,int> > ans` 更好。可以通过输出长度体现答案。

存储似乎定义函数更好：


```cpp
inline void add(int x,int y)
{
    ans.push_back(make_pair(x,y));
}
```

输出答案（先输出长度）：


```cpp
cout<<ans.size()<<"\n";
for(int i=0;i<ans.size();i++)
{
    cout<<ans[i].first<<' '<<ans[i].second<<"\n";
}
```

**注意：每组数据请先清空。**

### 14 pts 

先看一眼**子任务一**，尝试先过一。

提供两种做法：

做法一：根据**样例**中 `2` 和 `4` 有解，`3` 无解可得：**偶数有解，奇数无解**。

做法二（证明）：最终的序列一定是由两两配对二次，奇数通过分割后必然存在奇数无法配对，故奇数无法成立。

### 16 pts

我还以为 $O(n^2)$ 把每个都乘上一遍就好了，后来发现只有 $n = 2$ 时成立。（

### 33 pts

发现当 $n = 2 ^ k$ 时规律还挺好找的。

可以采取反复**对半开分治**的方法：

先将每 $2$ 个数配对，在通过 $2$ 次操作可以将四个数合并成一样的。然后再通过 $4$ 操作将 $8$ 个数合并直至合并出 $2 ^ k$ 个一样的数。


```cpp
void dfs(int l,int r)
{
	if(l==r-1)
	{
		add(l,r);
		return ;
	}
	int mid=(l+r)>>1;
	dfs(l,mid),dfs(mid+1,r);
	for(int i=l;i<=mid;i++) add(i,mid+i-l+1);
}
```

### 36 pts

由 33 pts 做法得到我们已经会了 $2 ^ k$ 个数的合并，这时想到我如果会 $2 ^ k + 2$ 就可以通过分治解决所有的 $n$。毕竟分来分去都是偶数，处理长度的二分之一进行奇数和偶数分讨即可。

然后尝试爆推 $n = 10$，不推 $6$ 是因为太小了出不了规律。搞了两个小时的规律：

$$x,x,x,x,x,x,x,x,y,y$$

将前 $6$ 个 $x$ 与最后一个 $y$ 配对：

$$xy,x^2y,x^3y,x^4y,x^5y,x^6y,x,x,y,x^6y$$

前 $6$ 个首尾配对：

$$x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x,x,y,x^6y$$

采取 `9` 和 `10`，`7` 和 `9` 再 `9` 和 `10`。

$$x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2,x^7y^2$$

**然后得出了普遍规律**：

当遇到一堆 $x$ 和 $2$ 个 $y$ 时，将其**分为两部分**：$p$ 个 $x$ 为一部分，$2$ 个 $x$ 和 $2$ 个 $y$ 为一部分。将 $p$ 个 $x$ 都乘一遍最后一个 $y$，得到 $xy,x^2y,\dots,x^py$。采取**首尾配对**（有点像求和公式的推导），第一部分全部变成 $x^{p+1}y^2$。第二部分将最后两个先变成 $x^py^2$，再以一三二四配对得到 $4$ 个 $x^{p+1}y^2$，这样整个序列都变成了 $x^{p+1}y^2$。

关于我为什么过不了子任务二，那是因为有部分合并写错了（

代码放在 63 pts 处。

### 63 pts

把 26 pts 调了一下，就是上面的思路。


```cpp
void f(int l,int r)
{
	if(l==r-1)
	{
		add(l,r);
		return ;
	}
	if(l==r) return ;
	int len=r-l+1;
	if((len/2)%2==1)
	{
        int mid=(l+r)>>1;
		f(l,r-2),f(r-1,r);
		for(int i=l;i<=r-4;i++) add(i,r);
		for(int i=l;i<=(r-4)-(r-4-l+1)/2;i++) add(i,r-4+l-i);
		add(r-1,r),add(r-3,r-1),add(r-2,r);
	}
	else
	{
		int mid=(l+r)>>1;
		f(l,mid),f(mid+1,r);
		for(int i=l;i<=mid;i++) add(i,mid+i-l+1);
	}
}
```

### 0 pts

尝试重构。重构，重构！

每添加 $2$ 个数就要把整个序列都扫一篇，还是太劣了。不过偶然间看到别人所说的**互补**使我有些思路。

还是和 63 pts 一样，爆推 $n = 10$。那就先不把前 $8$ 个变成一样的。

$$a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9,a_{10}$$

像之前的分部分一样，将最后的 $a_9,a_{10}$ 提出，以 $a_1,a_2,\dots,a_{\frac{n-2}{2}}$ 也就是前 $4$ 个为第一部分，剩下 $\frac{n-2}{2}$ 个也就是 $4$ 个分为第二部分。且将两部分通过 $\frac{n-2}{2}$ 此操作变成一样。

**注意：不需要把每个数变成一样浪费次数**

第一部分正着过一遍 $a_{10}$，第二部分倒着过一遍 $a_{10}$。依次操作。

$$a_1a_{10},a_1a_2a_{10},a_1a_2a_3a_{10},a_1a_2a_3a_4a_{10}$$

$$a_1a_2a_3a_4a_5a_6a_7a_8a_{10},a_1a_2a_3a_4a_6a_7a_8a_{10},a_1a_2a_3a_4a_7a_8a_{10},a_1a_2a_3a_4a_8a_{10}$$

赶紧简化第二部分：

$$a_1^2a_2^2a_3^2a_4^2a_{10},a_1a_2^2a_3^2a_4^2a_{10},a_1a_2a_3^2a_4^2a_{10},a_1a_2a_3a_4^2a_{10}$$

显然这个时候将第 $i$ 个和第 $(i+\frac{n}{2})$ 个操作一遍是不一样的。

先看 $a_1$，第一个乘积为 $a_1^3$ 但是后面都是 $a_1^2$，看来 $a_1$ 先操作使得所有都是三次方。然后后面多出来的 $a_2$ 至 $a_{\frac{n-2}{2}}$ 都不会有多出来的三次方（其实是意外之举，效果出其不意）。

将先乘的与第一组最后一个操作，后面全部错位。

现在前 $n-2$ 项就都是 $a_1^3a_2^2a_3^2a_4^2a_{10}^2$。后两项为 $a_1^2a_2^2a_3^2a_4^2a_{10}^2$，那我们开始时就把 $a_1$ 和 $a_{n-2}$ 操作一下，这样就不会少 $a_1$ 了。

同理得 $n$ 时答案。

解决了。。。吗？？

怎么是零分啊，啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！

### 100 pts

样例过不了，特判 $2,4$。我果然不太聪明。

---

## 作者：Vct14 (赞：7)

构造题好玩，就是有点费草稿纸（

操作次数：$392959\to(391425)\to295554\to14855\to(5120)\to3577\to2047$。

---

首先提供一个测试用的代码。先输入 $n$，然后每次输入两个数进行操作。为了方便，数列中的每个数我是用字母代替的，但是这样只可以输出 $n\le26$ 的情况。你可以将它略作修改再使用。

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[28][28];

int main(){
	int nn,l,r;cin>>nn;//n <= 26
	for(int i=1; i<=nn; i++) a[i][i]=1;
	while(cin>>l>>r){
		for(int i=1; i<=nn; i++){
			int h=a[l][i]+a[r][i];
			a[l][i]=a[r][i]=h;
		}
		for(int i=1; i<=nn; i++){
			if(i<=9) cout<<" ";
			cout<<i<<" ";
			for(int j=1; j<=12; j++){
				if(!a[i][j]) continue;
				cout<<(char)(j+'a'-1);
				if(a[i][j]>=2) cout<<"^"<<a[i][j];
				cout<<" ";
			}
			cout<<"\n";
		}
		cout<<"\n";
	}
	return 0;
}
```

---

### Part 1：有解性判断

首先可以发现 $n$ 为奇数无解。感性理解一下，这是因为每次操作后数列中相同的数的个数一定为偶数。

这样你就可以获得 $14$ 分了。

### Part 2：对于 $n=2^k$ 的构造

观察样例容易想到，我们把序列分成两半，递归使得前一半和后一半都分别相等，最后再操作位置 $i$ 和 $i+\frac{n}{2}$（$1\le i\le\frac{n}{2}$）即可。

这样操作的次数 $f_1(n)$ 满足递推式 $f_1(n)=2f_1(\frac{n}{2})+\frac{n}{2}$，即 $f_1(n)=\frac{n}{2}\log_2n$。显然这个函数单调递增，因此操作次数最大值为 $f_1(1024)=5120$。可以获得 $23$ 分。[记录](https://www.luogu.com.cn/record/216173333)。

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans[1111];

int main(){
    ans[2]=1;
    for(int i=4; i<=1024; i*=2) ans[i]=ans[i/2]*2+i/2;
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){
            cout<<"0\n";
            continue;
        } 
        cout<<"1\n";
        if(!ans[n]){
            cout<<"0\n";
            continue;
        }
        cout<<ans[n]<<"\n";
        if(n==2){
            cout<<"1 2\n";
            continue;
        }
        for(int i=2; i<=n; i*=2){
            for(int j=1; j<=n; j+=i){
                for(int k=j; k<=j+i/2-1; k++){
                    cout<<k<<" "<<k+i/2<<"\n";
                }
            }
        }
    }
	return 0;
}
```

代码实现得比较复杂，实际上可以递归解决。


### Part 3：构造 $\texttt{1.0}$（最大操作次数 $392959$）

考虑 $n=6$ 时如何构造。首先由 $n=2^k$ 的构造方法猜测要把数列分为两部分，即四个相等的数和两个相等的数，再将这两部分合并起来。

下面思考怎么合并。现在的数列为：

$$ a,a,a,a,b,b $$

第一步一定操作一个 $a$ 和一个 $b$：

$$ ab,a,a,a,ab,b $$

此时情况不多，枚举一下得到可以按如下方式操作：

操作位置 $2,5$：

$$ ab,a^2b,a,a,a^2b,b $$

操作位置 $1,2$：

$$ a^3b^2,a^3b^2,a,a,a^2b,b $$

操作位置 $5,6$：

$$ a^3b^2,a^3b^2,a,a,a^2b^2,a^2b^2 $$

操作位置 $3,6$ 和 $4,5$：

$$ a^3b^2,a^3b^2,a^3b^2,a^3b^2,a^3b^2,a^3b^2 $$

即可。

我们可以通过将某一个 $b$ 一直与其它 $a$ 操作的方式构造出一个等比数列。而对于一个等比数列，我们可以通过**首尾配对**的方式来使数列中的元素相同。

类比到任意 $n\ge6$ 的情况。首先我们将前 $n-2$ 个数递归变为相同的数并最后两数使它们相等，随后将前 $n-4$ 个数与位置 $n-1$ 操作，形成一个等比数列。这样前 $n-4$ 个数就可以变为相同的。然后我们先操作 $n-1$ 和 $n$，再操作 $n-3$ 和 $n-1$，最后操作 $n-2$ 和 $n$ 即可。

（这也算是我一开始尝试的时候碰运气了，$n=6$ 时 $n-2$ 恰好是 $2$ 的幂。我当时是想尝试能否把 $n$ 分为若干个 $2$ 的幂之和再合并的，没想到误打误撞出了正确的构造方法。）

合并前 $n-2$ 相同的个数和最后两个相同的数的操作次数为 $g(n)=(n-4)+\frac{n-4}{2}+3=\frac{3}{2}n-3$。这样的操作次数 $f_2$ 满足 $f_2(2)=1,f_2(4)=4$，且 $f_2(n)=f_2(n-2)+1+g(n)$（$n\ge6$），即 $f_2(n)=\frac{3}{8}n^2-\frac{1}{4}n-1$（$n\ge4$）。在定义域内这个函数是递增的。因此最大操作次数为 $f_2(1024)=392959$。可以获得 $40$ 分。[记录](https://www.luogu.com.cn/record/216457539)。

```cpp
//luogu P12417
//Code by Vct14(uid=677609)
//2025/05/06 21:09 
#include<bits/stdc++.h>
using namespace std;

int ans[1111];

void work(int x){
	if(x==2){
		cout<<"1 2\n";
		return ;
	}
    if(x==4){
        cout<<"1 2\n";
        cout<<"3 4\n";
        cout<<"1 3\n";
        cout<<"2 4\n";
        return ;
    }
	work(x-2);cout<<x-1<<" "<<x<<"\n";
	for(int i=1; i<=x-4; i++) cout<<i<<" "<<x-1<<"\n";
	for(int i=1; i<=(x-4)/2; i++) cout<<i<<" "<<x-4-i+1<<"\n";
	cout<<x-1<<" "<<x<<"\n";
	cout<<x-3<<" "<<x-1<<"\n";
	cout<<x-2<<" "<<x<<"\n";;
}

int main(){
    ans[2]=1;for(int i=4; i<=1024; i+=2) ans[i]=ans[i-2]+(i-4)+(i-4)/2+4;
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){
            cout<<"0\n";
            continue;
        } 
        cout<<"1\n";
        //n=6
        //a b c d e f
        //a a a a b b 
        //ab a a a ab b
        //ab a^2b a a a^2b b
        //ab a^2b a a a^2b^2 a^2b^2
        //n=2k
        //a a a ... a b b
        //x ab a^2b a3b ... a^(k-1)b ab a^2b a3b... a^(k-1)b a^(k-1)b b
        //x ab a^2b a3b ... a^(k-1)b a^(k-1)b a^(k-2)b a^(k-3)b ... ab a^(k-1)b a^(k-1)b
        //ab a^2b a3b ... a^(n-4)b a a a^(n-4)b b
        //a^(n-3)b^2 a^(n-3)b^2 ... a^(n-3)b^2 a a a^(n-4)b^2 a^(n-4)b^2
        //a^(n-3)b^2 a^(n-3)b^2 ... a^(n-3)b^2
        if(n==2) cout<<"1\n";
        else cout<<ans[n]-1<<"\n";
        work(n);
    }
	return 0;
}
```

此时有一个小小小优化。由于我们之前构造了 $n=2^k$ 的情况的方案，且 $f_1(1024)=5120$ 远小于 $f_2(1024)=392960$，所以在一开始特判是否有 $n=2^k$ 即可。最大操作次数为 $f_2(1022)=391425$。[记录](https://www.luogu.com.cn/record/216260908)。

```cpp
//luogu P12417
//Code by Vct14(uid=677609)
//2025/05/06 21:09 
#include<bits/stdc++.h>
using namespace std;

int ans[1111];
int ans2[1111];

void work(int x){
	if(x==2){
		cout<<"1 2\n";
		return ;
	}
    if(x==4){
        cout<<"1 2\n";
        cout<<"3 4\n";
        cout<<"1 3\n";
        cout<<"2 4\n";
        return ;
    }
	work(x-2);cout<<x-1<<" "<<x<<"\n";
	for(int i=1; i<=x-4; i++) cout<<i<<" "<<x-1<<"\n";
	for(int i=1; i<=(x-4)/2; i++) cout<<i<<" "<<x-4-i+1<<"\n";
	cout<<x-1<<" "<<x<<"\n";
	cout<<x-3<<" "<<x-1<<"\n";
	cout<<x-2<<" "<<x<<"\n";;
}

int main(){
    ans[2]=1;ans[4]=4;for(int i=6; i<=1024; i+=2) ans[i]=ans[i-2]+(i-4)+(i-4)/2+4;
    ans2[2]=1;for(int i=4; i<=1024; i*=2) ans2[i]=ans2[i/2]*2+i/2;
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){
            cout<<"0\n";
            continue;
        } 
        cout<<"1\n";
        //n=6
        //a b c d e f
        //a a a a b b 
        //ab a a a ab b
        //ab a^2b a a a^2b b
        //ab a^2b a a a^2b^2 a^2b^2
        //n=2k
        //a a a ... a b b
        //x ab a^2b a3b ... a^(k-1)b ab a^2b a3b... a^(k-1)b a^(k-1)b b
        //x ab a^2b a3b ... a^(k-1)b a^(k-1)b a^(k-2)b a^(k-3)b ... ab a^(k-1)b a^(k-1)b
        //ab a^2b a3b ... a^(n-4)b a a a^(n-4)b b
        //a^(n-3)b a^(n-3)b ... a^(n-3)b a a a^(n-4)b^2 a^(n-4)b^2
        //a^(n-3)b a^(n-3)b ... a^(n-3)b
        if(ans2[n]){
            cout<<ans2[n]<<"\n";
            for(int i=2; i<=n; i*=2){
                for(int j=1; j<=n; j+=i){
                    for(int k=j; k<=j+i/2-1; k++){
                        cout<<k<<" "<<k+i/2<<"\n";
                    }
                }
            }
            continue;
        }
        cout<<ans[n]<<"\n";
        work(n);
    }
	return 0;
}
```

### Part 3：构造 $\texttt{1.0+}$（最大操作次数 $295554$）

这个时候出题人把最大操作次数降到了 $3\times10^5$。这样怎么办呢？？

我们刚刚提到，$n=2^k$ 时绝大部分情况 $f_1(n)<f_2(n)$。所以如果递归到 $n=2^k$ 我们就直接构造，不再递归了。

设 $k=\left\lfloor\log_2 n\right\rfloor$，这样的操作次数 $f_3(n)=f_2(n)-f_2(2^k)+2^{k-1}k$。跑一下发现最大操作次数为 $f_3(1022)=299954$。也是压线到了 $3\times10^5$ 以内。新数据可以获得 $41$ 分。[记录](https://www.luogu.com.cn/record/216262731)。

```cpp
//luogu P12417
//Code by Vct14(uid=677609)
//ver 2.0
//2025/05/07 12:56 
#include<bits/stdc++.h>
using namespace std;

int ans[1111];
int ans2[1111];

void work(int x){
	if(ans2[x]){
		for(int i=2; i<=x; i*=2){
            for(int j=1; j<=x; j+=i){
                for(int k=j; k<=j+i/2-1; k++){
                    cout<<k<<" "<<k+i/2<<"\n";
                }
            }
        }
		return ;
	}
	work(x-2);cout<<x-1<<" "<<x<<"\n";
	for(int i=1; i<=x-4; i++) cout<<i<<" "<<x-1<<"\n";
	for(int i=1; i<=(x-4)/2; i++) cout<<i<<" "<<x-4-i+1<<"\n";
	cout<<x-1<<" "<<x<<"\n";
	cout<<x-3<<" "<<x-1<<"\n";
	cout<<x-2<<" "<<x<<"\n";;
}

int main(){
    ans[2]=1;ans[4]=4;for(int i=6; i<=1024; i+=2) ans[i]=ans[i-2]+(i-4)+(i-4)/2+4;
    ans2[2]=1;for(int i=4; i<=1024; i*=2) ans2[i]=ans2[i/2]*2+i/2;
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){
            cout<<"0\n";
            continue;
        } 
        cout<<"1\n";
        int z=1;
        while(z*2<=n) z*=2;
        cout<<ans[n]-ans[z]+ans2[z]<<"\n";
        work(n);
    }
	return 0;
}
```

### Part 4：构造 $\texttt{2.0}$（最大操作次数 $14855$）

到目前我们的构造都是 $O(n^2)$ 的，思考怎样进一步优化。

注意到目前 $2^k$ 的操作次数是非常优秀的，因此考虑推广其构造方法，即可以分两半递归（也就是 $4\mid n$ 时）就分两半递归，否则就递归 $n-2$。

这样的操作次数 $f_4(n)$ 是 $O(n\log n)$ 的，具体是啥我也不想算了，所以代码里是用 `vector` 先存下每次操作，得到操作次数再输出操作。跑一下可以发现最大次数为 $f_4(1022)=14855$。可以获得 $63$ 分。[记录](https://www.luogu.com.cn/record/216333587)。

```cpp
//luogu P12417
//Code by Vct14(uid=677609)
//ver 3.0
//2025/05/07 21:26 
#include<bits/stdc++.h>
using namespace std;

vector<pair<int,int>> ans;

void work(int x,int add){
    if(x==2){
        ans.push_back(make_pair(1+add,2+add));
        return ;
    }
	if(x%4==0){
        work(x/2,add),work(x/2,add+x/2);
        for(int i=1; i<=x/2; i++) ans.push_back(make_pair(i+add,i+add+x/2));
    } 
    else{
        work(x-2,add);
        ans.push_back(make_pair(x-1+add,x+add));
    	for(int i=1; i<=x-4; i++) ans.push_back(make_pair(i+add,x-1+add));
    	for(int i=1; i<=(x-4)/2; i++) ans.push_back(make_pair(i+add,x-4-i+1+add));
        ans.push_back(make_pair(x-1+add,x+add));
        ans.push_back(make_pair(x-3+add,x-1+add));
        ans.push_back(make_pair(x-2+add,x+add));
    }
}

int main(){
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){
            cout<<"0\n";
            continue;
        } 
        cout<<"1\n";
        ans.clear();
        work(n,0);int sz=ans.size();cout<<sz<<"\n";
        for(int i=0; i<sz; i++) cout<<ans[i].first<<" "<<ans[i].second<<"\n";
    }
	return 0;
}
```

### Part 4.5：另一种合并方式

（这一部分对于优化做法没什么作用，纯属尝试中的一个发现。大家可以直接跳过本 Part。）

接下来就要往线性做法靠了。之前的做法将题目分成了两部分，即构造 $n-2$ 个相等的数和 $2$ 个相等的数，最后再合并起来。目前合并所用的操作数为 $g(n)=\frac{3}{2}n-3$。我先对优化合并进行了尝试。

分享一下我找到的另一种操作步数相同的合并方式。

为了方便设初始时的数列为：

$$ b,a,a,\cdots,a,a,a,a,b $$

对于任意 $1\le i<n-3$，操作位置 $i$ 与 $i+1$：

$$ ab,a^2b,a^3b,\cdots,a^{n-4}b,a^{n-4}b,a,a,b $$

操作位置 $n-3$ 和 $n$：

$$ ab,a^2b,a^3b,\cdots,a^{n-4}b,a^{n-4}b^2,a,a,a^{n-4}b^2 $$

前 $n-4$ 个数首尾配对，再分别操作 $n-3$ 和 $n-2$ 以及 $n-1$ 和 $n$，就可以得到:

$$ a^{n-3}b^2,a^{n-3}b^2,\cdots,a^{n-3}b^2 $$ 

总操作次数也为 $g(n)=(n-4)+1+\frac{n-4}{2}+2=\frac{3}{2}n-3$。

### Part 5：构造 $\texttt{3.0}$（最大操作次数 $3577$）

我们猜测合并操作已经达到了下界，后面考虑优化如何构造 $n-2$ 个相同的数。

考虑将数列分为完全相同的两半，然后将两半中的数两两互补达到目标。那么对于前一半从前往后依次乘，对于后一半从后往前依次乘即可。

首先将数列两两相乘：

$$ a_1,a_1,a_2,a_2,\cdots,a_{\frac{n}{2}},a_{\frac{n}{2}} $$

对于第一组（$i$ 为奇数）从前往后依次乘，对于第二组（$i$ 为偶数）从后往前依次乘，得：

$$ a_1a_2,\prod\limits_{k=1}^{\frac{n}{2}}a_k,a_1a_2a_3,\prod\limits_{k=1}^{\frac{n}{2}}a_k,a_1a_2a_3a_4,\prod\limits_{k=2}^{\frac{n}{2}}a_k,\cdots,\prod\limits_{k=1}^{\frac{n}{2}-1}a_k,a_{\frac{n}{2}-3}a_{\frac{n}{2}-2}a_{\frac{n}{2}-1}a_{\frac{n}{2}},\prod\limits_{k=1}^{\frac{n}{2}}a_k,a_{\frac{n}{2}-2}a_{\frac{n}{2}-1}a_{\frac{n}{2}},\prod\limits_{k=1}^{\frac{n}{2}}a_k,a_{\frac{n}{2}-1}a_{\frac{n}{2}} $$

第 $n-1,n-3$ 个数为 $\prod\limits_{k=1}^{\frac{n}{2}}a_k$，对于所有 $i\le n-3$ 为奇数，可以发现第 $i$ 个数为 $\prod\limits_{k=1}^{\frac{i+3}{2}}a_k$；第 $2,4$ 个数也为 $\prod\limits_{k=1}^{\frac{n}{2}}a_k$，对于所有 $j\ge6$ 为偶数，可以发现第 $j$ 个数为$\prod\limits_{k=\frac{j}{2}-1}^{\frac{n}{2}}a_k$。那么当 $j=i+7$ 时，两数相乘刚好为 $\prod\limits_{k=1}^{\frac{n}{2}}a_k$。这样对应位置操作即可。

然而你会发现 $i=n-5,n-3,n-1$ 和 $j=2,4,6$ 是无法被操作的，但是其中的 $n-5,n-3,2,4$ 四个位置上本来就是 $\prod\limits_{k=1}^{\frac{n}{2}}a_k$。所以只有 $6$ 和 $n-5$ 两个位置不同。

即对于所有 $i\le n-7$，操作 $i$ 和 $i+7$ 得：

$$ \prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=\color{red}2}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\cdots\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}\color{red}-1}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k,\prod\limits_{k=1}^{\frac{n}{2}}a_k $$

（不同的用红色标注出来了。）

噢噢噢啊！这样我们就用 $h(n)=\frac{n}{2}+(n-2)+\dfrac{n-6}{2}=2n-5$ 次操作完成了对 $n-2$ 个相同的数的构造！

这样的操作次数 $f_5(n)=h(n)+1+g(n)=\frac{7}{2}n-7$，最大操作次数为 $f_5(1024)=3577$。可以获得 $86$ 分。[记录](https://www.luogu.com.cn/record/216354249)。

```cpp
//luogu P12417
//Code by Vct14(uid=677609)
//ver 5.0
//2025/05/07 22:09
//理论 3.5n-7
//max 3577
//怎么又加强了

#include<bits/stdc++.h>
using namespace std;

vector<pair<int,int>> ans;

void ad(int a,int b){
    ans.push_back(make_pair(a,b));
}

void work(int x){
    if(x==2){ad(1,2);return ;}
    if(x==4){ad(1,2),ad(3,4),ad(1,3),ad(2,4);return ;}
    for(int i=1; i<=x; i+=2) ad(i,i+1);
    for(int i=1; i<=x-3; i+=2) ad(i,i+2);
    for(int i=x; i>=4; i-=2) ad(i,i-2);
    for(int i=1; i<=x-7; i+=2) ad(i,i+7);
    //x-5 6
    ad(x-5,6);
//  for(int i=1; i<=x-4; i++) ad(i,x-1);  
    int ls[5]={0},ss=0;
    for(int i=x; i>=1; i--){
        if(i!=6 && i!=x-5) ls[++ss]=i;;
        if(ss==3) break;
    }
    for(int i=1; i<=ls[3]; i++) if(i!=6 && i!=x-5) ad(i,6);
//  for(int i=1; i<=(x-4)/2; i++) ad(i,x-4-i+1);
    int j=ls[3];
    for(int i=1; i<=ls[3]; i++){
        if(i==6 || i==x-5) continue;
        if(j<=i) break;
        ad(i,j);
        j--;
        while(j==6 || j==x-5) j--;
    } 
    ad(6,x-5);
    ad(6,ls[2]);
    ad(x-5,ls[1]);
}

int main(){
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){cout<<"0\n";continue;} 
        ans.clear();work(n);
        int sz=ans.size();cout<<"1\n"<<sz<<"\n";
        for(int i=0; i<sz; i++) cout<<ans[i].first<<" "<<ans[i].second<<"\n";
        //目标：a a ... a b b
        //2n-5
        /*
        n=10
        a a b b c c d d e e 5
        total1 13
        ab a ab b c c d d e e
        ab a abc b abc c d d e e
        ab a abc b abcd c abcd d e e
        ab a abc b abcd c abcde d abcde e
        half 4
        ab abcde abc abcde abcd bcde abcde cde abcde de 8
        abcde abcde abcde abcde abcd bcde abcde abcde abcde abcde 2
        total2 15=2*10-5
        */
    }
	return 0;
}
```

后面合并的部分我写的比较麻烦，但是屎山就屎山吧，过了就好（）

Fun fact 1：在最开始我尝试的是 $n=10$ 的情况，最后发现不同的是 $5$ 和 $6$，于是我认为位置不同的数为 $\frac{n}2$ 和 $\frac n 2+1$，所以一定要多次实验避免偶然性！！

Fun fact 2：在实现该构造的时候我仍然保留着特判 $n=2^k$ 的代码，但是实际 $f_1(1024)=5120>f_5(1024)=3577$，还没有不特判优秀（

### Part 6：构造 $\texttt{4.0}$（最大操作次数 $2047$）

$2n-1$ 做法！！！！！

我们用构造 $\texttt{3.0}$ 的思想来优化构造 $\texttt{1.0}$。即：考虑将数列分为完全相同的两半，都跟另外一个数进行操作，然后将两半中的数两两互补达到目标。

先试试对于前一半从前往后依次乘，对于后一半从后往前依次乘。

以 $n=10$ 为例。

我们先两两相乘，得到：

$$ a,a,b,b,c,c,d,d,e,e $$

除了两个 $e$ 以外，对于第一组（$i$ 为奇数）从前往后依次与第一个 $e$ 操作，随后对于第二组（$i$ 为偶数）从后往前依次与第一个 $e$ 操作，得：

$$ ae,a^2b^2c^2d^2e,abe,ab^2c^2d^2e,abce,abc^2d^2e,abcde,abcd^2e,a^2b^2c^2d^2e,e $$

但是这个时候！我们发现！第一组里每个数都有 $a$ 但第二组里只有一个数有 $a$，第二组里每个数都有 $d^2$ 但第二组里只有一个数有 $d$！这样我们就没法首尾配了，因为每个数中 $a$（还有 $d$）的次数不一定一样！这个时候该怎么办呢？！

灵光一现！！！！我们交换第二组中 $a$ 和 $d$ 的位置，不就行了！！！

也就是说：

对于第一组（$i\le7$ 且为奇数）从前往后依次与第一个 $e$ 操作，得到：

$$ ae,a,abe,b,abce,c,abcde,d,abcde,e $$

然后先让第二个 $a$ 和原来的第一个 $e$ 操作，得到：

$$ ae,a^2bcde,abe,b,abce,c,abcde,d,a^2bcde,e $$

随后对于第二组（$4\le i\le8$ 且为偶数）从后往前依次与原来的第一个 $e$ 操作，得：

$$ ae,a^2bcde,abe,a^2b^2c^2d^2e,abce,a^2bc^2d^2e,abcde,a^2bcd^2e,a^2b^2c^2d^2e,e $$

咱先不管后面两个数，可以发现这个时候我们能配对了！！！！对于所有奇数 $i\le5$，让 $i$ 和 $i+3$ 配，最后的第 $7$ 个数和第 $2$ 个数配，所有的数都是 $a^3b^2c^2d^2e^2$！！！ 

把最后两个数都变为 $a^2b^2c^2d^2e^2$：

$$ a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^3b^2c^2d^2e^2,a^2b^2c^2d^2e^2,a^2b^2c^2d^2e^2 $$

还剩两个数怎么办？再拉两个 $a$ 过来不就行了吗！！！！于是我们就通过对 $n=10$ 的尝试解决了 $n=12$ 的情况！！！

操作次数 $f_6(n)=\frac{n}{2}+2+(n-3)+\frac{n-4}{2}+2=2n-1$，最大操作次数为 $f_6(1024)=2047$！！问题得到了完美的解决！！[记录](https://www.luogu.com.cn/record/216391201)。

```cpp
//luogu P12417
//Code by Vct14(uid=677609)
//ver 6
//2025/05/08 12:44
//2n-1
#include<bits/stdc++.h>
using namespace std;

vector<pair<int,int>> ans;

void ad(int a,int b){
    ans.push_back(make_pair(a,b));
}

void work4(int a,int b,int c,int d){
    ad(a,b);ad(c,d);
    ad(a,c);ad(b,d);
}

void work(int x){
    if(x==2){ad(1,2);return ;}
    if(x==4){work4(1,2,3,4); return ;}
    for(int i=1; i<=x; i+=2) ad(i,i+1);
    ad(1,x-2);ad(2,x-3);
    for(int i=1; i<=x-5; i+=2) ad(i,x-1);
    ad(2,x-1);
    for(int i=x-4; i>=4; i-=2) ad(i,x-1);
    for(int i=1; i<=x-7; i+=2) ad(i,i+3);
    ad(2,x-5);
    ad(x-1,x);
    ad(x-3,x-1);
    ad(x-2,x);
}

int main(){
	int t;cin>>t;
    while(t--){
        int n;cin>>n;
        if(n%2){cout<<"0\n";continue;} 
        ans.clear();work(n);
        int sz=ans.size();cout<<"1\n"<<sz<<"\n";
        for(int i=0; i<sz; i++) cout<<ans[i].first<<" "<<ans[i].second<<"\n";
    }
	return 0;
}
```

由 Part4.5 的合并方法，正解还有另外一种操作相邻数的实现方法，大家可以自行思考。

---

## 作者：fish_love_cat (赞：5)

神仙构造题 /bx

---

容易发现，最普遍的情况是数列内数字两两互质时。

于是我们如果可以在这种情况下构造出方案，那么一定是可以在任何情况下成功的。

猜想 $n$ 为奇数时无解，证明：

设原数列 $a_i$ 单调递增且两两互质，操作后的序列称为 $b_i$，$k_i$ 是 $b_i$ 中所有数里 $a_i$ 的最高次数。

注意到对 $a_n$ 操作后以 ${a_n}^{k_n}$ 为因子的数无论怎样都是偶数个，这是由操作的性质决定的。

但是目标局面显然无论怎样所有 $n$ 个数字都得有 ${a_n}^{k_n}$ 作为因子，此时矛盾了。

于是猜想成立。

## 原做法

然后发现 $n=2^k$ 及其好做，显然只需要相邻块不断合并即可。

考虑 $n=2^k+2$ 怎么做。

我们先按照 $2^k$ 做一轮，现在情况可以看作：

$$a,a,\dots,a,a,a,b,c$$

我们从左到右把 $a$ 和 $b$ 进行 $2^k-2$ 次操作，然后得到了这么一个序列：

$$ab,a^2b,\dots,a^{2^k-2}b,a,a,a^{2^k-2}b,c$$

$n=4$ 很好做对吧，于是我们把倒数四个按这个方式做了得到：

$$ab,a^2b,\dots,a^{2^k-2}b,a^{2^k-1}b^2,a^{2^k-1}b^2,a^{2^k-1}b^2,a^{2^k-1}b^2$$

然后发现前面的 $2^k-2$ 项可以通过首尾相交的方式也变成 $a^{2^k-1}b^2$，然后就同化完成了。

观察操作过程发现，如果初始 $a$ 数量不为 $2^k$ 也是可行的。

所以可以得到我们能在原有的正确序列基础上通过构造来延长 $2$ 的长度。

然后只需要找到最近的 $2^k$ 节点，一直往后延长到 $ n$ 就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(){
    int n;
    cin>>n;
    if(n%2)cout<<"0\n";
    else{
        vector<pair<int,int> >flc;
        int sta;
        int m=n;
        for(int i=1;i<=11;i++)
        if((1<<i)>n){
            i--;
            n=(1<<i);
            for(int j=1;j<n;j*=2){
                for(int k=1;k<=n;k+=j*2){
                    for(int g=0;g<j;g++)
                        flc.push_back(make_pair(k+g,k+j+g));
                }
            }
            sta=1<<i;
            break;
        }
        n=m;
        sta+=2;
        //cout<<sta<<"?\n";
        for(int i=sta;i<=n;i+=2){
            flc.push_back(make_pair(i,i-1));
            for(int j=1;j<=i-4;j++)
                flc.push_back(make_pair(j,i));
            for(int j=1;j<=(i-4)/2;j++)
                flc.push_back(make_pair(j,i-4-j+1));
            flc.push_back(make_pair(i,i-1));
            flc.push_back(make_pair(i-2,i));
            flc.push_back(make_pair(i-3,i-1));
        }
        cout<<"1 "<<flc.size()<<'\n';
        for(int i=0;i<flc.size();i++)
            cout<<flc[i].first<<' '<<flc[i].second<<'\n';
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(),cout.tie();
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

操作次数应该是近似 $O(n\log n+\frac{1}{4}n^2)$ 的吧，太不优秀了，加强后现在只能得 41pts /fad

## 现做法

想到可以尝试构造两个相同序列后正反各跑一遍积，然后使两个序列互为补充。

于是把序列拆成 $a,b$ 两半，长度为 $k=\frac{n}{2}$。

然后令 $a_i=b_i$ 花费 $k$ 步操作。

记 $(x)=\prod^x_{i=1}c_i$，$[x]=\prod^k_{i=x}c_i$，此处 $c$ 代表上面操作后的值，在接下来的操作中不被改变。

使用 $a_k$ 对着 $a$ 正序进行操作，$k-1$ 步后得到：

$$\forall 1\le i\le k-1,a_i\gets(i)c_k$$

然后再拿着 $a_k\gets (k)$ 对着 $b$ 倒序操作，$k$ 步后得到：

$$\forall 1\le i \le k,b_i\gets (k)[i]$$

此时 $a_k\gets b_1= (k)[1]$。

记 $d=\prod^k_{i=1}c_i$。

那么可以得到：

$$\forall 1\le i\le k-1,(i)[i+1]=d$$

特殊的，$[1]=(k)=d$。

观察原式，发现将 $a_i$ 与 $b_{i+1}$ 进行操作后可以得到统一的 $d^2c_k$，此时只会剩下 $a_k$ 与 $b_1$，同时我们有 $a_k=b_1=(k)[1]=d^2$。

此时还差两个 $c_k$，于是我们在最开始处理的时候从 $n$ 里预留两位同化成 $c_k$，留到此时救场就行了。

预留两位不影响做法，等同于在开始做时令 $n\gets n-2$，一切如常。

那么做完了。

哦对了 $n=2$ 要特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(){
    int n;
    cin>>n;
    if(n%2)cout<<"0\n";
    else{
        if(n==2){
            puts("1");
            puts("1");
            puts("1 2");
            return;
        }
        vector<pair<int,int> >flc;
        flc.push_back(make_pair(n,n-1));
        int k=(n-2)/2;
        for(int i=1;i<=k;i++)
        flc.push_back(make_pair(i,i+k));
        flc.push_back(make_pair(k+k,n));
        flc.push_back(make_pair(k,n-1));
        for(int i=1;i<k;i++)
        flc.push_back(make_pair(k,i));
        for(int i=k+k;i>k;i--)
        flc.push_back(make_pair(k,i));
        for(int i=1;i<k;i++)
        flc.push_back(make_pair(i,i+k+1));
        flc.push_back(make_pair(n-1,k));
        flc.push_back(make_pair(n,k+1));
        cout<<"1\n"<<flc.size()<<'\n';
        for(int i=0;i<flc.size();i++)
        cout<<flc[i].first<<' '<<flc[i].second<<'\n';
    }
}
int main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

分析所用次数，分组处理 $O(k)$，处理 $a$ 花费 $O(k-1)$，处理 $b$ 花费 $O(k)$，匹配 $O(k-1)$，预留花费 $O(3)$，救场 $O(2)$。

共计 $O(4k+3)$，由于有预留所以取 $k=\frac{n-2}{2}$。

那么就是 $O(2n-1)$，卡的刚刚好。

应该不会有更爆的做法了吧 /fad

---

后记：

某些抄题解的记得把变量名改一下，不然真的很难绷 /xk

> 怎么现在提交记录有好几个代码都是 `flc.push_back(...)` —— @[Vct14](https://www.luogu.com.cn/user/677609)

---

## 作者：Re_Star (赞：4)

[题面](https://www.luogu.com.cn/problem/P12417)

[更好的阅读体验](https://www.cnblogs.com/Re-Star/p/18902389)

非常有意思的一道题。

- 无解的情况：

首先感性理解当 $n$ 为奇数时是无解的。具体的，我们先钦定这 $n$ 个数都大于 1(因为题目要求对任意序列成立，所以证明某一类情况无解就可以)。

假设最后一次操作后 $n$ 个数都变成了 $x$，因为每次我们都选择两个数相乘，那么得到的一定比原来的数大，也就是说 $x$ 一定是我们操作过程中得到的最大值。考虑每一次操作如果产生了新的最大值，最大值个数就会变成 2 个，如果产生的数是当前最大值，则最大值增加 2 个，否则不变。所以无论如何最大值的个数都不会是奇数个。

- $O(n\log n)$ 步解法：

现在考虑如何构造方案。先考虑比较简单的 $n=2^k$ 的情况，我们可以直接把 $2^k$ 个数两两配对做一次操作，再将这 $2^{k-1}$ 对两两分组，同组的两对一一对应做一次操作，那我们最后就可以操作 $O(n\log n)$ 次解决问题。但是对于一般的 $n$，分成两组可能会产生奇数个数，无解。我们可以单独留下两个，其他的两两分组，分治解决，所以问题变成了对于一个操作好了的序列，增加了两个数后怎么处理。我们可以先对增加的两个数做一次操作，那我们的序列将会形如：
$$
x,x,x,x,x\dots x,x,y,y 
$$
接下来我们让前 $n-4$ 个数依次和第 $n-1$ 个数操作，就可以得到：
$$
xy,x^2y,x^3y\dots x^{n-4}y,x,x,x^{n-4}y,y
$$
然后我们把后 4 个数单拎出来按上述 $n=2^k$ 的情况操作，前 $n-4$ 个数一前一后两两匹配做操作，就会发现它们操作出来是一样的！
$$
x^{n-3}y^2,x^{n-3}y^2\dots x^{n-3}y^2
$$
我们把这两种方式结合到一起就可以 $O(n\log n)$ 次解决一般情况了，可以得到六十多分的好成绩。接下来怎么优化呢？

- 正解($2n-1$ 步解法)：

让我们先来观察一下上面我们加入两个数之后的第一步操作得到的序列：
$$
xy,x^2y,x^3y\dots x^{n-4}y,x,x,x^{n-4}y,y
$$
我们发现这里可以成功，是因为前 $n-4$ 个数中 $x$ 因子数呈等差数列的形式。但是对于一般序列，我们不能保证前 $n-2$ 个数相等，如果我们类似地操作最后不同的因子也不能像这样互补的合并啊。那加入还有一个一样的序列倒着拼过来貌似就可以互补了。

我们先构造两个一样的序列，直接把相邻两数组在一起操作一次就可以得到这样的序列(我们令 $m=\frac n2$)：
$$
a_1,a_1,a_2,a_2,a_3,a_3\dots a_m,a_m
$$
现在我们把最后两个数单拎出来，剩下的数我们称奇数位置为第一组，偶数位置为第二组。按照刚才的思路我们让第一组从前往后和第 $n-1$ 个数操作，第二组从后往前和第 $n-1$ 个数操作,便于观察，这里我们取 $n=12$，并用 $a,b,c,d,e,f$ 分别表示 $a_1,a_2,a_3,a_4,a_5,a_6$。

第一组为：
$$
af,abf,abcf,abcdf,abcdef
$$

第二组为:
$$
abcde^2f,abcd^2e^2f,abc^2d^2e^2f,ab^2c^2d^2e^2f,a^2b^2c^2d^2e^2f
$$
然后我们试着把这两个序列首尾相接分别做操作：
$$
a^3b^2c^2d^2e^2f^2,a^2b^3c^2d^3e^2f^2,a^2b^2c^3d^2e^2f^2,a^2b^2c^2d^3e^2f^2,a^2b^2c^2d^2e^3f^2
$$
比较可惜，我们这样凑出来的 5 对乘积并不相等，但好像比较有规律.直观感受一下问题出在了哪里，第1组每个数都有因子 $a$，所以第二组也应该先让 $a$ 做操作，这样错一下位就可以了。现在第二组为：
$$
a^2bcdef,a^2bcde^2f,a^2bcd^2e^2f,a^2bc^2d^2e^2f,a^2b^2c^2d^2e^2f
$$
我们现在把这两组首尾相接相乘得到的数就都是 $a^3b^2c^2d^3e^2f^2$，而最后两个一开始拎出来的数现在乘起来结果是 $a^2b^2c^2d^2e^2f^2$。差了一个 $a$，怎么办呢？这里有一个技巧，我们可以一开始让两个 $a$ 和 $e$ 分别操作，得到 4 个 $ae$ 并把前面两个 $ae$ 当做新的 $a$ 做上述操作，后面两个 $ae$ 不管，到最后和最后两个数分别相乘就可以把那个 $a$ 补上了。

现在让我们统计一下操作次数：转化为两个相同序列，$\frac n2$步；把 $a$ 存下来，2 步；前 $n-4$ 个数分别和第 $n-1$ 个数操作，$n-4$ 步；首尾相接合并，$\frac {n-4}2$ 步；最后两个数相乘，1 步；最后两个数分别和一开始存下的 $a$ 相乘，2 步。总共 $\frac n2+2+(n-4)+\frac{n-4}2+2+1=2n-1$ 步。

code:

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e4;
int ans[N][2],n,res;
inline ll rd()
{
    char c;ll f=1;
    while((c=getchar())<'0'||c>'9')if(c=='-')f=-1;
    ll x=c-'0';
    while(('0'<=(c=getchar()))&&c<='9')x=x*10+(c^48);
    return x*f;
}

int main()
{
	for(int t=rd();t--;)
	{
		n=rd(),res=0;
		if(n%2==1)printf("0\n");
		else if(n==2)printf("1\n1\n1 2\n");
		else if(n==4)printf("1\n4\n1 2\n3 4\n1 3\n2 4\n");
		else if(n==6)printf("1\n11\n1 2\n3 4\n1 3\n2 4\n5 6\n1 5\n2 5\n1 2\n5 6\n3 5\n4 6\n");
		else
		{
			for(int i=1;i<=n;i+=2) ans[++res][0]=i,ans[res][1]=i+1;
			ans[++res][0]=1,ans[res][1]=n-2;
			ans[++res][0]=2,ans[res][1]=n-3;
			for(int i=1;i<=n-5;i+=2) ans[++res][0]=i,ans[res][1]=n-1;
			ans[++res][0]=2,ans[res][1]=n-1;
			for(int i=n-4;i>=4;i-=2) ans[++res][0]=i,ans[res][1]=n-1;
			for(int i=1;i<=n-7;i+=2) ans[++res][0]=i,ans[res][1]=i+3;
			ans[++res][0]=2,ans[res][1]=n-5;
			ans[++res][0]=n,ans[res][1]=n-1;
			ans[++res][0]=n-3,ans[res][1]=n-1;
			ans[++res][0]=n-2,ans[res][1]=n;
			printf("1\n%d\n",res);
			for(int i=1;i<=res;i++) printf("%d %d\n",ans[i][0],ans[i][1]);
		}
	}
	return 0;
}
/*
这玩意叫基础构造练习题
那我的两个小时算什么
nlogn步不是随便做
貌似有63分
但是2n-1真能做吗
不会
看题解
……
2n-1步好牛牛的一个做法
感觉好像看懂题解了
……
真吗？？
……
最后留两个数啥意思
神秘……
瞟一眼代码似乎懂了
有点意思
怎么不对
现在精神状态良好
第一次在代码里发癫
调不出来欸
算了按题解的写法吧保险点
过了
好题啊
推荐大家都来做这道题
*/
```

---

## 作者：FireFly620 (赞：2)

&zwnj;**叠甲：**&zwnj; 管理员或读者，您好。本题是笔者~~在队友撺掇~~下花费四天思考出来的，当时完全不知道这是黑题，由于本题思维复杂，而对算法要求不高，故侥幸通过。&zwnj;**如本文与现有题解有雷同，还请谅解。侵可删。**&zwnj;

# Question:
有一列实数，对于每一次操作，可以选择两个实数，把它们同时变为两数之积。

例如，给定 $7$，$4$，$5$，对 $7$ 和 $5$ 进行一次操作，原数列变为 $35$，$4$，$35$。

给定数列的长度 $n$，你的目标是找到一种操作方案（其操作次数不大于 $2047$），使得对于任意长度为 $n$ 的实数列，按照该操作方式操作之后，数列的每一项数值都相同。

对于所有测试数据，保证 $T = 20$，$2 \leq n \leq 1024$。

多测。

# Solution:
~~话说我怎么没想出来 $n^2$ 的做法。~~

似乎操作不难，不如从较小的 $n$ 值出发寻找规律。

定义原数列为 $s$，发现 $n = 3$ 时无解，而 $ n=5 $时玩了半天，似乎无解。

于是通过人类智慧猜测 $n$ 为奇数时无解。感性证明一下：

假设 $n > 1$ 且 $n$ 是奇数，且数列中元素均为质数，即它们之间无法相互凑出。这时是最普遍的情况。

此时数列中存在 $1$ 个最大值，而必然的，若我们想要统一就&zwnj;**必须操作**&zwnj;这个最大值（因为其他数无法凑出它），于是存在 $2$ 个最大值。

其后，不论我们如何操作，由于原数列中均为正整数，所以&zwnj;**最大值个数始终为偶数**&zwnj;，而最终必须有 $n$ 个最大值，遂无解。

那么 $n$ 必定为偶数了。

## 法一：
第一想法是弄两个数列，分别滚上所有数的因子再两两配对，像等比数列一样头尾相接再相乘，消掉公因数。

具体地，令 $m = \frac{n}{2}$。 对于 $\forall i\in [1,m]$，操作 $s_{2i-1}$ 和 $s_{2i}$，这样整个数列就"分裂"成了两个相同的数列，不妨定义为 $a,b$。

将 $a$ 的最后一项 $a_m$ 钦定为基数，令 $x = a_m$。将 $x$ 与 $\forall i\in [1,m)$ $a_i$ 依次操作，滚上所有元素的因子，此时数列 $a$ 变为：

$a_1x$，$a_1a_2x$，...， $\prod_{i=1}^{m-1}a_ix$，$\prod_{i=1}^{m-1}a_ix$。

考虑让另一个数列 $b$ 也滚上所有因子，但貌似没有好的方法。先尝试让 $b$ 同 $a$ 一样但反向，即令$ x = b_m $ 与 $\forall i\in [1,m)$ $b_{m-i}$ 依次操作，得到：

$b_{m-1}x$， $b_{m-1}b_{m-2}x$ ，...，$\prod_{i=1}^{m-1}b_ix$，$\prod_{i=1}^{m-1}b_ix$。

将四个 $\prod_{i=1}^{m-1}a_ix$ 拎出来，令 $\forall i\in [1,m-1)$ $a_i$ 与 $b_{m-i}$ 操作，得到  $n-2$ 个 $\prod_{i=1}^{m-1}a_ix^2$。此时，再为四个 $\prod_{i=1}^{m-1}a_ix$ 各配上一个 $x$ 就万事大吉了。

考虑在原本构造的基础上改为预处理 $6$ 个基数 $b$，不妨定为 $x$，$x$，$y$，$y$，$z$，$z$。

经过队友的半天手玩，发现一种 $8$ 步做法：

$xy$，$x$，$xy$，$y$，$z$，$z$。

$xy$，$xy$，$xy$，$xy$，$z$，$z$。

$xyz$，$xy$，$xy$，$xy$，$xyz$，$z$。

$xyz$，$x^2y^2z$，$xy$，$xy$，$x^2y^2z$，$z$。

$xyz$，$x^2y^2z$，$xy$，$xy$，$x^2y^2z^2$，$x^2y^2z^2$。

$x^3y^3z^2$，$x^3y^3z^2$，$xy$，$xy$，$x^2y^2z^2$，$x^2y^2z^2$。

$x^3y^3z^2$，$x^3y^3z^2$，$xy$，$x^3y^3z^2$，$x^2y^2z^2$，$x^3y^3z^2$。

$x^3y^3z^2$，$x^3y^3z^2$，$x^3y^3z^2$，$x^3y^3z^2$，$x^3y^3z^2$，$x^3y^3z^2$。

令 $m = \frac{n}{2}-2$，于是总的操作次数是：

$(m+2)+2(m-1)+(m-2)+4+8 = 2n+2$。

此时我们将做法轻易地变成了线性，但数据要求的操作次数为 $2n-1$。考虑从哪里省下来 $3$ 步。

再一次地，我们发现最终的结果 $\prod_{i=1}^{m-1}a_ix^2$ 似乎过于"整齐"了， $a_m$ 与 $b_m$ 似乎不必相等。事实的确如此，若 $a_m \ne b_m$，则在同样操作下最终值依然一致，为 $\prod_{i=1}^{m-1}a_ia_mb_m$。

这启示我们可以将 $6$ 个基数拆成各 $3$ 个来处理。但是样例告诉我们 $n = 3$ 时是不可做的，所以我们借用 $a_{m-1}$ 和 $b_{m-1}$ 来把 $n = 6$ 转化为两个 $n = 4$。

那么，操作次数由 $3+8 = 11$ 次减少至 $4+4+1-1 = 8$ 次，比原本的处理方法恰少了 $3$ 次。

~~（仰天大笑）世界的真理，我已解明！魔↗术↘技↗巧↘。~~

遂题解......吗？

## 法二：

~~（实则法一是笔者一周后才想到的。）~~

回到 $2n+2$ 做法，我们发现次数浪费的主要原因是预处理的基数太多了，考虑把 $6$ 个基数优化成 $4$ 个，那么就能省下来足够的步数了。

从何处下手？如果我们不再单独把 $b_m$ 单独拿出来依次操作，那就能省掉两个用于配对的 $x$，预处理的步数将从 $8$ 降低为 $2$。

重新考虑构造过程，对数列 $a$ 的操作不变，令 $x' = \prod_{i=1}^{m-1}a_ix$，然后将它与 $\forall i\in [1,m-1)$ $b_{m-i}$ 依次操作再两两配对，得到 $n-4$ 个 $(x')^2$。

~~然后你就会发现剩下三个 $x$ 和一个 $x'$ 根本凑不出两个 $(x')^2$。~~

可恶，既然存在单个 $x'$ 就无法凑出答案，不妨将 $x$ 加到操作序列中，这样就能够消掉最后的 $x$，于是可能可行。

令 $x' = \prod_{i=1}^{m-1}a_ix$，然后将它与 $\forall i\in [0,m-1)$ $b_{m-i}$ 依次操作再两两配对，此时得到 $n-2$ 个 $(x')^2x$。而剩下的元素为 $1$ 个 $(x')^2$ 和 $1$ 个 $x$，恰配为 $2$ 个 $(x')^2x$。

令 $m = \frac{n}{2}-1$，总的操作次数为：

$(m+1)+2+(m-1)+m+m+1 = 2n-1$。

~~（仰天大笑）世界的真理，我已解明！魔↗术↘技↗巧↘。~~

遂题解。
# Coding:

## 法一：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ist push_back
using node=array<int,2>;
int main(){
	int t,n;
	cin>>t;
	while(t--){
		cin>>n;
		if(n&1){puts("0");continue;}
		vector<node>ans;
		puts("1");
		if(n>6){
			int k=n/2-2;
			for(int i=1;i<k-1;i++)
				ans.ist({2*i-1,2*i});
			ans.ist({n-3,n-1});ans.ist({n-7,n-5});
			ans.ist({n-5,n-1});ans.ist({n-7,n-3});
			ans.ist({n-2,n});ans.ist({n-6,n-4});
			ans.ist({n-4,n});ans.ist({n-6,n-2});
			ans.ist({n-7,n-6});
			for(int i=1;i<k;i++)
				ans.ist({2*i,n});
			for(int i=k-1;i>=1;i--)
				ans.ist({2*i-1,n-1});
			for(int i=1;i<k-1;i++)
				ans.ist({2*i,2*i+1});
			ans.ist({1,n-4});ans.ist({n-2,n-1});
			ans.ist({n-6,n-5});ans.ist({n-3,n});
		}else if(n>4){
			ans.ist({1,2});ans.ist({3,4});ans.ist({5,6});
			ans.ist({1,3});ans.ist({2,4});
			ans.ist({1,5});ans.ist({2,5});
			ans.ist({5,6});ans.ist({1,2});
			ans.ist({3,5});ans.ist({4,6});
		}else if(n>2){
			ans.ist({1,2});ans.ist({3,4});
			ans.ist({1,3});ans.ist({2,4});
		}else ans.ist({1,2});
		cout<<ans.size()<<'\n';
		for(auto v:ans)
			cout<<v[0]<<' '<<v[1]<<'\n';
	}
	return 0;
} 
```

## 法二：

```cpp
#include<bits/stdc++.h>
using namespace std;
using node=array<int,2>;
int main(){
	int t,n;
	cin>>t;
	while(t--){
		cin>>n;
		if(n&1){puts("0");continue;}
		vector<node>ans;
		puts("1");
		if(n!=2){
			int k=n/2-1;
			for(int i=1;i<=k+1;i++)
				ans.push_back({2*i-1,2*i});
			ans.push_back({n-3,n-1});
			ans.push_back({n-2,n});
			for(int i=1;i<k;i++)
				ans.push_back({2*i,n});
			for(int i=k;i>0;i--)
				ans.push_back({2*i-1,n});
			for(int i=1;i<k;i++)
				ans.push_back({2*i,2*i+1});
			ans.push_back({1,n-2});
			ans.push_back({n-1,n});
		}else ans.push_back({1,2});
		cout<<ans.size()<<'\n';
		for(auto v:ans)
			cout<<v[0]<<' '<<v[1]<<'\n';
	}
	return 0;
} 
```
# Ending:
思维题真好玩。

---


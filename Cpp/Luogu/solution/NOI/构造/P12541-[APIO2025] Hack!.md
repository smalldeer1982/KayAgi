# [APIO2025] Hack!

## 题目背景

请注意：本题只支持 C++ 语言提交；你不需要也不应该实现 `main` 函数；你需要在程序开头添加如下内容：

```cpp
#include <vector>

int hack();
long long collisions(std::vector<long long> x);
```

## 题目描述

你参加了一场 Codeforces 的编程比赛，现在离比赛结束只有一个小时了。你发现同房间的另外一位选手通过使用 `unordered_set` 通过了一道题目。是时候把他的代码 hack 掉了！

你知道 `unordered_set` 是使用一个包含 $n$ 个桶的哈希表实现的，其中桶的编号为 $0$ 到 $n-1$。不过很可惜，你并不知道 $n$ 具体是多少，所以你希望通过下面的操作将 $n$ 还原出来。

当你将一个整数 $x$ 插入哈希表时，它将会被插入到第 $(x \bmod n)$ 个桶中。如果在这次插入之前这个桶中已经有 $b$ 个元素，这将会导致 $b$ 次哈希冲突的产生。

每次操作中，你可以向交互库提交 $k$ 个不同的整数 $x[0], x[1], \dots, x[k-1]$ 进行查询，交互库会依次将这些整数插入到哈希表中，并返回创建包含这些数字的哈希表会引起的哈希冲突总次数。然而，向交互库提交一次包含 $k$ 个不同的整数的查询需要 $k$ 的花费。

例如，当 $n = 5$ 时，如果你向交互库提交数组 $x = [2, 15, 7, 27, 8, 30]$，将会引起总共 $4$ 次哈希冲突，具体如下：

| 操作                     | 新增哈希冲突次数 | 桶状态                     |
|--------------------------|------------------|----------------------------|
| 初始状态                 | -                | [], [], [], [], []          |
| 插入 $x[0] = 2$          | 0                | [], [], [2], [], []         |
| 插入 $x[1] = 15$         | 0                | [15], [], [2], [], []       |
| 插入 $x[2] = 7$          | 1                | [15], [], [2, 7], [], []    |
| 插入 $x[3] = 27$         | 2                | [15], [], [2, 7, 27], [], []|
| 插入 $x[4] = 8$          | 0                | [15], [], [2, 7, 27], [8], [] |
| 插入 $x[5] = 30$         | 1                | [15, 30], [], [2, 7, 27], [8], [] |

请注意：交互库在每次你提交的时候都将 `unordered_set` 初始化为空集，然后把提交的数字依次插入来创建哈希表。也就是说，每一次的交互查询是相互独立的。

你的任务是使用不超过 $1\,000\,000$ 的花费求出桶的数量 $n$。

### 实现细节

你需要实现以下函数：

```cpp
int hack()
```

- 该函数返回一个整数 $n$。
- 对于每个测试点，评测程序可能会调用该函数多于一次。每次调用都应该当做新的情况分别处理。

在这个函数中，你可能会调用以下交互函数：

```cpp
long long collisions(std::vector<long long> x)
```

- $x$：一个包含不同整数的数组，其中对于所有 $i$，满足 $1 \leq x[i] \leq 10^{18}$。
- 该函数返回一个整数，表示将数组 $x$ 中所有元素依次插入哈希表引起的哈希冲突次数。
- 该函数可以多次调用。在一次 `hack()` 的调用中，多次调用的数组 $x$ 的总长度不能超过 $1\,000\,000$。

注意：由于 `hack()` 函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。

$1\,000\,000$ 的花费限制应用于每一组测试数据。即，如果 `hack()` 函数被调用了 $t$ 次，你可以使用不超过 $t \times 1\,000\,000$ 的总花费，并且每次独立调用 `hack()` 时的花费不能超过 $1\,000\,000$。

$n$ 的值在交互函数调用前已经固定。

## 说明/提示

### 例子

假设有两组测试用例，评测程序将首先调用 `hack()` 函数：

```cpp
hack()
```

在这个函数中，你可以进行以下调用：

| 函数调用                     | 返回值 |
|------------------------------|--------|
| `collisions([2, 15, 7, 27, 8, 30])` | 4      |
| `collisions([1, 2, 3])`             | 0      |
| `collisions([10, 20, 30, 40, 50])`  | 10     |

如果你还原出 $n = 5$，那么函数 `hack()` 返回 5。

接下来，评测程序将再一次调用 `hack()` 函数：

```cpp
hack()
```

在这个函数中，你可以进行以下调用：

| 函数调用          | 返回值 |
|-------------------|--------|
| `collisions([1, 3])` | 1      |
| `collisions([2, 4])` | 1      |

你从上述调用中还原出唯一满足的 $n$ 是 2，那么函数 `hack()` 返回 2。

### 约束条件

- $1 \leq t \leq 10$，其中 $t$ 为每组测试点中的测试用例数量。
- $2 \leq n \leq 10^9$
- 对于每次 `collisions()` 调用，$1 \leq x[i] \leq 10^{18}$

### 子任务

1. (8 分) $n \leq 500\,000$
2. (17 分) $n \leq 1\,000\,000$
3. (75 分) 没有额外的约束条件。

在最后一个子任务中，你可以获得部分分。令 $q$ 为该子任务下所有测试用例 `hack()` 函数中的最大总花费。该子任务的部分分计算如下：

| 条件                     | 分数  |
|--------------------------|-------|
| $1\,000\,000 < q$        | 0     |
| $110\,000 < q \leq 1\,000\,000$ | $75 \cdot \log_{50} \left( \frac{10^6}{x - 90000} \right)$ |
| $q \leq 110\,000$        | 75    |

在任意测试用例中，如果对 `collisions()` 函数调用不满足实现细节中的约束条件，或者 `hack()` 函数调用的返回值错误，该子任务的分数为 0。

### 评测程序示例

评测程序示例按以下格式读取输入：

- 第 1 行：$t$

对于接下来 $t$ 组数据的每一组：

- 第 1 行：$n$

对于每组测试用例，令 $m$ 为函数 `hack()` 的返回值，$c$ 为所有查询的总花费。评测程序示例按以下格式打印你的答案：

- 第 1 行：$m\,c$

# 题解

## 作者：luogu_gza (赞：29)

首先感谢 milmon 老师提示，我才能摸索出更好的做法。

---

考场上冲击 T1，毁我大好青春，只得 77 分。

首先先讲一下怎么判定 $[l,r]$ 中有没有 $n$ 的倍数（note：返回值是否为零等价于序列中数字两两相减，能不能减出 $n$ 的倍数）

取 $C=\sqrt{r-l+1}$，构造序列 $[1,2,\cdots,C,l+C,l+2C,\cdots,r+1]$，根据其返回值是否为零即可判定 $[l,r]$ 中有没有 $n$ 的倍数。注意这里需要保证 $l=1$ 或者 $n>C$ 这个构造才是对的，因为要防止 $1 \sim C$ 这一段能减出来在 $[l,r]$ 之外的 $n$ 的倍数导致误判。

> update：讲一下问什么这是对的。我们称第一部分为 $[1,2,\cdots,C]$，其他的为第二部分。首先第一部分内部没有贡献，第一部分和第二部分互相产生的贡献恰好判断 $[l,r]$ 有没有 $n$ 的倍数。
> 
> 接下来就是要证明第二部分内部贡献不会影响判断。我们把第二部分想象成一个指针在一个长度为 $n$ 的环上走，$1 \sim C$ 已经被标记了，走一步将指针往后动 $C$ 格。如果这个指针走到了被标记的地方就会对返回值产生贡献，或者走到了一个地方两次也会对返回值产生贡献。
> 
> 你发现标记区间长度为 $C$，所以你在这个环上走一圈，一定会走到这上面，使得返回值不为零，因为如果第二部分内部产生了贡献（走了一圈），一定会使得第一部分和第二部分互相产生贡献，所以这是对的。

我们先判一下 $n \leq B$ 还是 $n>B$。

$n \leq B$：直接判。

$n>B$：二分答案，每次判定 $[l,mid]$ 中含不含有 $n$ 的倍数然后动一下边界就行。

以上的做法能做到 $77 \sim 78$ 分，也是我考场做法。

---

我们考虑如果 $n<5 \times 10^8$，那么它一定有一个在 $[5 \times 10^8,1 \times 10^9]$ 之间的倍数，直接将二分初始边界改为 $[5 \times 10^8,1 \times 10^9]$，然后你能算出一个 $n$ 的倍数，枚举其因数然后找出真正的 $n$ 即可。

这样貌似只能获得 99 分，再加一个剪枝，因为我们已经保证了 $n>B$，所以算出来的 $n$ 的倍数的因数中，$\leq B$ 的一定不会是答案，判的时候跳过这些数就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
int hack();
long long collisions(std::vector<long long> x);
#define fo(i,a,b) for(long long i=a;i<=b;i++)
long long get(long long l,long long r)
{
	int C=sqrt(r-l+1);
	vector<long long> v;
	fo(i,1,C) v.pb(i);
	l+=C;
	while(l<=r) v.pb(l),l+=C;
	v.pb(r+1);
	return collisions(v);
}
int hack()
{
	long long B=sqrt(1e9),v=get(1,B);
	if(v)
	{
		fo(i,1,B) if(collisions({1,i+1})) return i;
		return -1;
	}
	else
	{
		long long l=5e8,r=1e9;
		while(l<r)
		{
			long long mid=l+r>>1;
			if(get(l,mid)) r=mid;
			else l=mid+1;
		}
		vector<long long> v;
		for(long long i=1;i*i<=l;i++) if(l%i==0)
		{
			if(i>B) v.pb(i);
			if(i*i!=l&&l/i>B) v.pb(l/i);
		}
		sort(v.begin(),v.end());
		for(auto i:v) if(collisions({1,i+1})) return i;
		return -1;	
	}
}
```

---

然后我们尝试结合一下 @yuanruiqi 题解的做法。

询问的时候把每个数乘上 $2^{29}$，这样你就只需要二分奇数即可，也就是你会得到一个 $n$ 的倍数去除了所有 $2$ 因子的结果，把它乘上 $2^{29}$，枚举其所有质因数，二分 $n$ 有几个枚举的质因子因子即可。

以及你其实根本不用判 $n<\sqrt{10^9}$。为什么呢？

因为长度大于等于 $n$ 的区间内一定存在 $n$ 的倍数，所以你的二分区间会一直缩小到至少 $[l,l+2n)$（此处的 $l$ 是初始二分左端点），而在 $n \geq 2$ 时，此时已经满足 $n<C=\sqrt{2n}$ 了，因此接下来再跑这个算法就是对的。

值得注意的是，为了防止询问的数超出 $10^{18}$，我们需要将二分的下界调低一点，我这里是调了 $10^9 \div 6$ 左右。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
// #include"hack.h" 
int hack();
long long collisions(std::vector<long long> x);
#define fo(i,a,b) for(long long i=a;i<=b;i++)
long long get(long long l,long long r)
{
	int C=ceil(sqrt(r-l+1));
	vector<long long> v;
	fo(i,1,C) v.pb(i);
	l+=C;
	while(l<=r) v.pb(l),l+=C;
	v.pb(r+1);
	return collisions(v);
}
long long get2(long long l,long long r)
{
	int C=sqrt(r-l+1);
	vector<long long> v;
	fo(i,1,C) v.pb((2ll*i)<<29);
	l+=C;
	for(;;l+=C)
	{
		l=min(l,r+1),v.pb((l*2ll-1)<<29);
		if(l-1>=r) break;
	}
	return collisions(v);
}
long long qmi(long long a,long long b)
{
	long long res=1;
	fo(i,1,b) res*=a;
	return res;
}
int hack()
{
	long long B=sqrt(1e9);
	long long l=1e9/6+1,r=5e8;
	while(l<r)
	{
		long long mid=l+r>>1;
		if(get2(l,mid)) r=mid;
		else l=mid+1;
	}
	l=l*2-1;
	l<<=29;
	vector<long long> v;
	long long now=l;
	for(long long i=2;i*i<=l;i++) if(l%i==0)
	{
		long long ori=l;
		long long cnt=0;
		while(l%i==0) l/=i,cnt++;
		long long ll=0,rr=cnt;
		while(ll<rr)
		{
			long long mid=ll+rr+1>>1;
			if(collisions({1,now/qmi(i,mid)+1})) ll=mid;
			else rr=mid-1;
		}
		now/=qmi(i,ll);
		// cout<<now<<endl;
	}
	if(l>1)
	{
		if(collisions({1,now/l+1})) now/=l;
	}
	return now;
}
```

**次数：88186**。

---

## 作者：yuanruiqi (赞：14)

这是一个与 std 不同的做法，取得了最短解。

如果我们可以判断 $n\in[l,r]$ 是否成立，那么就可以二分了。

询问一个序列 $a$，结果非零意味着 $\exists i\lt j,n\mid a_i-a_j$。下面都依赖于这个事实。

受到光速幂的启发，构造一组序列如下：

$$
1,2,3,\cdots,b,l+b,l+2b,l+3b,\cdots,l+\lfloor\frac{r-l}{b}\rfloor b,r+1
$$

询问的结果非零，是 $x\in[l,r]$ 的必要不充分条件，这是因为会有一些杂质出现。事实上，询问结果非零等价于 $x\in[l,r]\cup S$，其中 $S$ 满足所有元素不超过 $r$。

虽然我们得到的形式比 $n\in[l,r]$ 差一点，但是对于二分已经足够了，因为每一层只需要判断是否有 $n\in[l,mid]$。

容易得到代价函数 $f(n)=f(n/2)+2\sqrt{n/2}$，对于 $n=10^9$，计算得到结果为 $152650$，可以获得 $78$ 分。

考场上止步于此，进一步的优化思路主要来自于 @SnowTrace。

由于 $f(5\times 10^8)=107930$，考虑通过某种方式使规模减半。

既然题目允许询问一个 `long long`，而上面的序列都在 `int` 范围内，于是每次都尝试将询问序列中每个数乘 $2^{29}$，回到原式 $\exists i\lt j,n\mid 2^{29}(a_i-a_j)$，这意味着 $n$ 中的 $2$ 因子没有了意义。于是只需要对所有的奇数二分，并对二分结果尝试乘以二的若干次幂。

```cpp
#include "hack.h"

#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

int hack()
{
    int l = 1, r = 500000000;
    while (l < r)
    {
        int m = (l + r) >> 1;
        int b = max((int) sqrt(m - l + 1), 1);
        vector<i64> v;
        for (int i = 1; i <= b; ++i) v.emplace_back((i * 2ll) << 29);
        for (int x = b + l; ; x += b)
        {
            x = min(x, 1 + m);
            v.emplace_back((x * 2ll - 1) << 29);
            if (x - 1 >= m) break;
        }
        if (collisions(v)) r = m;
        else l = m + 1;
    }
    r = r * 2 - 1;
    while (!collisions({1, r + 1})) r <<= 1;
    return r;
}
```

---

## 作者：lsj2009 (赞：12)

## Preface

场上提出了 $\mathcal{O}(\sqrt{n\log{n}})$ 的做法，但是 system test 荣获 25pts/xk

## Description

存在一个初始固定的正整数 $n$，可以进行若干次对交互库的询问，每次询问可以花费 $|a|$ 的代价给出一个序列 $a$，交互库会返回 $\sum\limits_{1\le i<j\le |a|} [a_i\equiv a_j\pmod{n}]$ 的值。

在花费不大于 $1.1\times 10^5$ 的代价下确定 $n$ 的值，$n\le 10^9$。

## Solution

首先非常容易做到是判断一个数 $x$ 是否是 $n$ 的倍数：给出 $a=\{1,x+1\}$ 即可。

则一个核心思想是，**我们尝试找到 $n$ 的一个倍数 $n'$**，则 $n$ 即为 $n'$ 的所有因数中最小的为 $n$ 倍数的数。则可对 $n'$ 的每个质因数分别考虑他在 $n$ 上的幂次，容易做到在不大于 $2\log{n}$ 代价内求出 $n$ 的值。

#### Sol 1

我的考场做法。

钦定一个阈值 $B$，先特判掉 $n\le B$ 的情况（确定 $n$ 直接二分，花费 $B+B\log B$ 的代价）。

对于 $n>B$，**我们尝试找到一个数 $x>10^9$ 使得 $x\bmod{n}\le B$**，则我们可以随 $B'=\Omega{\left(\frac{n}{B}\right)}$ 个数（依据下面算法逻辑，其实还应保证该 $B'$ 个数内没有冲突），此时期望下存在至少一个这样的 $x$，先对于 $B'$ 个数二分确定数 $x$，再对于 $B$ 个数二分确定 $x\bmod{n}$ 的值，则 $n'=x-(x\bmod{n})$。

代价为 $\mathcal{O}(B'+B\log{B'}+B)$，取 $B=\mathcal{O}\left(\sqrt{\frac{n}{\log{n}}}\right)$ 可以获得理论最优复杂度 $\mathcal{O}(\sqrt{n\log{n}})$，实际上应当可以获得还可以的分数，但是由于 pretest 和 system test 数据差异的存在以及 $B'$ 所带的巨大常数，导致我只通过了 sub1,2 而在 sub3 上获得 0pts。

#### Sol 2

事实上 Sol 1 的思路是完全正确的，我们考虑进一步优化。暂且先不考虑 $n\le B$ 的情况，我们发现复杂度里带个 $\log$ 这导致我们代价难以很低，能否去掉？

不妨将问题刻画的更加形式化：

- 有集合 $S_1,S_2$，找到 $x\in S_1,y\in S_2$ 使得 $x \equiv y\pmod{n}$。

考虑将 $S_1$ 对半分为 $S_1^L,S_1^R$，将 $S_2$ 对半分为 $S_2^L,S_2^R$，则进行如下询问：

- 询问 $S_1\cup S_2^L$。
  
  - 如为真：询问 $S_1^L\cup S_2^L$。
  
  - 如为假：询问 $S_1^L\cup S_2^R$。

**则在 $1.5|S_1|+|S_2|$ 代价下可将问题递归到规模为 $\frac{1}{2}$ 的子问题**。

则最终所花费代价为 $3|S_1|+2|S_2|$。

此时复杂度已经降为 $\mathcal{O}(\sqrt{n})$，但所带常数巨大，无法通过。

#### Sol 3

导致常数大的主要问题在于 $S_2$ 集合的确定。

我们能不能不去 **随** $\Omega{\left(\frac{n}{B}\right)}$ 个数而找到一个集合使得其与 $1,2,\cdots,B$ 间必然存在冲突？

令 $m=10^9$，给出集合：

- $S_2=\{\frac{m}{2}+1+B,\frac{m}{2}+1+2B,\cdots,\frac{m}{2}+1+B'B\}$，其中 $B'B\ge \frac{m}{2},B'\ge B$。

注意到 $x\in S_1=\{1,2,\cdots,B\},y\in S_2$ 组成的 $y-x$ 遍历到了 $[\frac{m}{2}+1,m]$ 内的所有数，而其中必有一 $n$ 的倍数。 

此时需 **特判 $S_{1/2}$ 内部存在冲突的情况**。由于 $B'\ge B$，此时很好说明若 $S_1$ 中存在冲突则 $S_2$ 中必然存在冲突，故只需判断 $S_2$ 内部是否有冲突并找到冲突的一对数即可。

类比 $S_{1/2}$ 构造集合：

- $S_3=\{B,2B,\cdots,k_1B\}$。

- $S_4=\{\frac{BB'}{2}+B+k_1B,\cdots,\frac{BB'}{2}+B+k_2k_1B\}$。有 $k_1k_2\ge \frac{B'}{2}$。

则 $x\in S_3,y\in S_4$ 组成的 $y-x$ 遍历到了所有的 $kB,k\in[1,B']$。

取 $k_1=k_2=\sqrt{\frac{B'}{2}}$，查询 $S_3\cup S_4$ 即可判断 $S_2$ 内部是否有冲突。若有冲突再花费 $(k_1+k_2)^2=2B'$ 的代价确定冲突的 $x,y$ 即可。

若无冲突，则再花费 $3B+2B'$ 的代价确定 $S_1,S_2$ 间的冲突即可。由基本不等式，总代价（对于判断 $S_2$ 是否由冲突而产生的 $2\sqrt{\frac{B'}{2}}$ 花费可以忽略）为 $3B+2B'\ge 2\sqrt{6BB'}\ge2\sqrt{6\cdot\frac{m}{2}}=2\sqrt{3m}\approx 109545$ 可以接受。

不等号在 $3B=2B'=\sqrt{3m}$ 时取等。

---

## 作者：SnowTrace (赞：8)

提供一个 99 分的做法，感觉非常清新啊。

upd: 现在可以 100 了。

-----

如果我们能找到一个存在两个点发生哈希冲突的序列，我们该如何从这个序列里找出那两个哈希冲突的位置？

考虑设计一个递归 $solve(S)$，意思是我们已经知道 $S$ 中存在两个冲突的点，要从 $S$ 中找出满足两个哈希冲突的点。然后考虑把 $S$ 分成两半 $S_1,S_2$，先查询这两个集合单独出现时是否会有哈希冲突，如果冲突了就可以继续递归，否则我们就无法直接解决了，此时两个发生冲突的位置其中一个在 $S1$，另一个在 $S2$。

再设计递归 $Solve2(S1,S2)$ 表示我已经知道两个冲突的点一个在 $S1$，一个在 $S2$ 时的求解，我们每次把 $S1$ 拆成两半，$P_1,P_2$，询问 $P1$ 和 $S2$ 合并后的序列是否存在哈希冲突，如果存在递归到 $Solve2(P_1,S_2)$，否则递归到 $Solve2(P_2,S_2)$。

我们每次递归较大的集合，可以分析出来 $Solve2(S_1,S_2)$ 的时间复杂度是 $\dfrac{5}{2}|S_1+S_2|$。

接下来考虑第二个问题，如果我们找到了两个 $a,b$，使得只要插入这两个就会发生哈希冲突，然后我们应该如何确定 $n$ 的值。

注意到这相当于 $a-b$ 是 $n$ 的倍数。

考虑到这个性质和求一个整数的阶类似，我们可以这样考虑：初始设定 $n$ 就等于 $a-b$，然后我们不断枚举 $n$ 的质因子，每次尝试除去 $n$ 的一个质因子，比如除去一个 $d$，那我们再判断 $1$ 和 $\frac{n}{d}+1$ 这两个数是否可以发生冲突，如果发生冲突就代表实际上 $n$ 可以更小，否则就代表当前这个质因子出现的次数恰好就是答案中这个质因子出现的次数。这一部分代价大概是 $O(\log n)$ 可以忽略不计。

再考虑第三个问题，我们需要构造一个序列 $a$ 使得对于 $\forall n\in [1,10^9]，\exist x,y， n \ |    a_x-a_y $。

不妨考虑 $a$ 的差分数组 $b$，那么就是要求存在 $b$ 的一个子段和是 $n$ 的倍数。

考虑到实际上一个长度为 $m$ 的序列可以提供 $O(m^2)$ 个子段。直接给出构造，$b = \{1,1,1,1,1,...,\sqrt{10^9},\sqrt{10^9}，\sqrt{10^9}，\sqrt{10^9}\}$。

其中 $1$ 和 $\sqrt{10^9}$ 都出现了 $\sqrt{10^9}$ 次，显然此时可以满足对于每一个 $n$ 都存在一个子段使其恰好 $=n$（考虑类似分块的结构，或者也可以叫 BSGS）。

注意到实际上这样构造的话，这个子段的左端点只会在那一堆 $1$ 里面，右端点只会在那一堆 $\sqrt{10^9}$ 里面，因此直接调用 $Solve2$ 即可。做到这里可以获得 $76$ 分，前面这部分和大家应该都差不多。

-----

**接下来是一步非常关键的优化。**

感觉这个优化比 APIO 讲题的做法清新多了，而且我认为很容易想到。

我们考虑到我们这样构造的 $a_i$ 实际上值域只在 $[1,10^9]$ 内，而题目允许我们使用到 $10^{18}$。因此我们肯定是想办法让我们 $a_i$ 值域变大（尝试通过扩大值域储存更多信息）。

如果我保证 $n$ 是奇数，我们可以怎么构造？

首先我们假定 $\sqrt{10^9}$ 这个数是个偶数，也就是加上任意个这个数都不会改变奇偶性。（如果是奇数可以给他加上一变成偶数）

原本 $a$ 的前半部分是 $1,2,3,4,5...$，而后半部分的奇偶性都是一样的，不妨设后半部分全部都是偶数，那么为了凑出一个奇数，前半部分的偶数就不必要了，也就是我们此时可以把前半部分的偶数去掉，变成 $1,3,5,7,9$ 这样。取个根号平衡，此时我们序列的长度就只有 $2 \sqrt{\dfrac{10^9}{2}}$ 了。

然而上面这部分到底干了一件什么事情呢？

我们知道我们只需要找到 $a,b$ 使得 $a-b$ 是 $n$ 的倍数。但是假如 $a$ 和 $b$ 都是 $2^{29}$ 的倍数，是不是我们就完全不需要考虑 $n$ 中 $2$ 的因子了？

具体来说，我们把原本的 $a_i$ 每一项都乘上 $2^{29}$，这样 $n$ 里 $2$ 的因子就一定整除 $2^{29}$，这样我们就可以**认为 $n$ 是一个奇数**，因为我们此时不再需要考虑 $2$ 的因子。

从而我们可以把 $a$ 前一半中的所有偶数都去掉，因为现在我们只需要凑出一个奇数，再给 $a$ 中所有数乘上 $2^{29}$，这样就给出了一个长度是 $2 \sqrt{\dfrac{10^9}{2}}$ 的构造。


-----

实际上这个做法还可以再优化，下面一部分是某个面积群老哥教我的。

刚刚我们只去掉了所有 $2$ 的因子，接下来我们尝试去掉 $3$ 的因子，如果我们类似的给所有数再乘上 $3^{18}$，这样我们的 $a$ 数组值域就来到了 $10^{27}$，所以这样做肯定是不行的。

考虑这样一个过程，如果 $n$ 是 $2^{15}$ 的倍数，我们实际上可以把这个问题考虑成一个值域为 $\dfrac {10^9}{2^{15}}$ 次方的问题（我们可以将找到的 $a,b$ 同时除以 $2^{15}$ 次方，这相当于值域按比例缩小了）。

如果我们能在这个规模更小的问题中找到解，就说明此时 $n$ 真的是 $2^{15}$ 的倍数，而此时我们也找到了解。否则它就不是 $2^{15}$ 的倍数，然后这个时候我们就只需要给 $a$ 数组的每个数乘上 $2^{15}$ 即可去除所有 $2$ 的因子。

我们对 $3$ 也做同样的过程，从而我们现在只需要保留前半部分与 $2,3$ 都互质的数，应该可以通过。

----

代码咕咕咕。

---

## 作者：cyffff (赞：7)

场外选手，做了一个下午做出来了！

[$\text{Link}$](https://www.luogu.com.cn/problem/P12541)
## 题意
这是一道交互题。

有一个未知的整数 $n$，你需要在若干次询问后猜出它。每一次询问你可以给出一个任意长的正整数序列 $a_{1\sim k}$，交互库会返回有多少对 $1\le i<j\le k$ 满足 $a_i\equiv a_j\pmod n$，花费的代价为给出的序列长度 $k$。

你需要在不超过 $1.1\times 10^5$ 的代价内返回 $n$。多组数据。

$T\le 10$，$n\le 10^9$。
## 思路

前两个子任务的做法没有什么拓展性，直接观察最大的档，不难猜测需要一个 $O(\sqrt n)$ 代价的算法。
### 算法模型
取模相关不妨考虑 BSGS 算法。设定阈值 $b$，构造两个序列 $F=\{1,2,\dots,b\},G=\{2b,3b,\dots,kb\}$，其中 $k=\left\lceil\dfrac{\max n}{b}\right\rceil$。

如果能找到 $x\in F,y\in G$ 满足询问 $\{x,y\}$ 返回 $1$ 且 $y$ 最小，那么我们就能确定 $n=y-x$。

寻找 $x,y$ 考虑二分，每次将 $|F|,|G|$ 分别减半。将 $F,G$ 分别对半划分为 $F_l,F_r,G_l,G_r$，一个朴素的想法为依次询问 $F_l\cup G_l,F_r\cup G_l,F_r\cup G_r$，若三次询问均不存在哈希冲突则保留 $F_l,G_r$，否则保留存在哈希冲突的一组，需要 $\frac32|F|+\frac32|G|$ 的代价。

注意到这样不是最优的，不妨询问 $F_l\cup G$，若成功存在冲突则询问 $F_l\cup G_l$，否则询问 $F_r\cup G_l$，这样只需要 $|F|+\frac32|G|$ 的代价。
### 细节处理

注意到如果 $F$ 或 $G$ 内部就存在哈希冲突，上述二分算法并不能正确运行，分别考虑处理 $F$ 与 $G$ 内部的问题。

对于 $F$ 的内部，若其存在哈希冲突则有 $n\le b$，这时可以用一次阈值为 $\sqrt b$ 的 BSGS 判断是否有 $n\le b$，若判断成功则直接使用子任务一的算法即可。

对于 $G$ 的内部，若其存在冲突则有 $ib\equiv jb\pmod n$，不妨要求 $b$ 为质数，这样只有 $n$ 是 $b$ 的倍数或者 $n\le \left\lceil\dfrac{\max n}{b}\right\rceil$ 时才可能冲突，后者与 $F$ 的处理方法相同，前者只需要选取一些不同的质数，在其中随机选取 $b$ 即可避免。

### 常数优化

上述算法的代价大致为 $2b+\dfrac{3\max n}{b}+O(\sqrt[4]{\max n})$，取 $b=O(\sqrt{3n/2})$ 得到次数 $2\sqrt{6n}$，约为 $1.5\times 10^5$，无法通过。

注意到我们只需要求出一个 $n$ 的倍数便可一个个试除其质因子得到正确的 $n$，于是我们无需要求求出的 $y$ 最小，并只保留 $G$ 中不小于 $\dfrac{\max n}2$ 的数，代价优化为 $2b+\dfrac{3\max n}{2b}+O(\sqrt[4]{\max n}+\log n)$，取 $b=O(\sqrt{3n/4})$ 得到次数 $2\sqrt{3n}$，约为 $1.09\times 10^5$，可以通过。

以下是一份通过代码：
```cpp
#include<bits/stdc++.h>
#include "grader.cpp"
using namespace std;
#define ll long long
#define vi vector<int>
#define vll vector<ll>
const int N=1e9+10;
int B,Bs[]={27329,27337,27361,27367,27397};
ll collisions(vll v);
ll calc(vi vc){
	vll v;
	for(auto x:vc)
		v.push_back(x);
	return collisions(v);
}
ll calc(vi L,vi R){
	vll v;
	for(auto x:L)
		v.push_back(x);
	for(auto x:R)
		v.push_back(x);
	return collisions(v);
}
inline bool chksub(){
	vi v;
	for(int i=1;i<200;i++)
		v.push_back(i);
	for(int i=1;i<=200;i++)
		v.push_back(i*200);
	return calc(v);
}
int hack(){
	B=Bs[rand()%5];
	if(chksub()){
		for(int i=1;i<=40000;i++)
			if(calc({1,i+1}))
				return i;
		exit(-1);
	}
	vi F,G;
	for(int i=1;i<=B;i++)
		F.push_back(i);
	for(int i=B*2;i<=N+B;i+=B)
		if(i>=N/2)
			G.push_back(i);
	while(F.size()>1||G.size()>1){
		int n=F.size(),m=G.size();
		int cl=n/2,dl=m/2;
		vi Fl,Fr,Gl,Gr;
		for(int i=0;i<cl;i++) Fl.push_back(F[i]);
		for(int i=cl;i<n;i++) Fr.push_back(F[i]);
		for(int i=0;i<dl;i++) Gl.push_back(G[i]);
		for(int i=dl;i<m;i++) Gr.push_back(G[i]);
		if(n==1){ G=calc(F,Gl)?Gl:Gr;continue; }
		if(calc(Fl,G)) F=Fl,G=calc(Fl,Gl)?Gl:Gr;
		else F=Fr,G=calc(Fr,Gl)?Gl:Gr;
	}
	int n=G[0]-F[0],d=n;
	for(int p=2;p*p<=d;p++){
		if(d%p) continue;
		while(d%p==0) d/=p;
		while(n%p==0){
			int np=n/p;
			if(!calc({1,np+1})) break;
			n/=p;
		}
	}
	if(d>1){
		int np=n/d;
		if(calc({1,np+1})) n=np;
	}
	return n;
}
```

---

## 作者：liuzhangfeiabc (赞：5)

题目大意：有一个数 $n$，你不知道是多少；你每次可以向交互库询问一个正整数集合 $A$（其中元素互不相同），交互库返回：将集合中的数对 $n$ 取模后，有多少对数是相同的。也就是 $\sum_{1 \le i < j \le |A|}[A_i \equiv A_j \pmod n]$。你要通过若干次询问求出 $n$。

数据范围：$n \ne 10^9$，询问的开销是集合大小，要求总开销不超过 $110000$。

前两档部分分的做法很多，我们直接跳过部分分来看正解。

首先考虑这样一件事：假设我们得到了某一对数 $(x,y)$ 是冲突的，这意味着什么？

两数冲突意味着两数对 $n$ 取模的值相同，也就是说两数之差是 $n$ 的倍数，换句话说 $n$ 一定是两数之差 $w=|x-y|$ 的因数。

因此我们只需要直接检查所有 $w$ 的因子即可，比较聪明的检查方法是考虑质因数分解 $w=\prod_i p_i^{c_i}$，然后对每个指数 $c_i$ 进行二分。这一部分的开销显然是很小的，所以我们只需要设法找到一对冲突的 $(x,y)$ 即可。

现在假设我们已经得到了一个存在冲突的集合 $A$，如何从中具体找到哪两个数冲突？这里就要用到这类交互题常见的二分技巧：

- 将集合 $A$ 划分为两个子集 $S, T$，分别对每个子集单独检验。如果某个子集内部已经有冲突了，就把问题规模缩小了一半；否则冲突一定发生在 $S$ 和 $T$ 之间。
- 再将 $S, T$ 分别划分为 $S_1, S_2, T_1, T_2$，然后先查询 $S_1\cup T$，如果有冲突就保留 $S_1$，否则保留 $S_2$；再查询 $S_*\cup T_1$ （$S_*$ 是上一步中保留的部分）如果有冲突就保留 $T_1$，否则保留 $T_2$。
- 这样通过两次查询就将 $S$ 和 $T$ 的规模都缩小了一半，开销为 $|S|+1.5|T|$。基于等比数列求和可知，整个二分过程的总开销为 $2|S|+3|T|$。但请注意这没有包含最开始检验 $A$ 集合存在冲突，以及检验 $S$ 和 $T$ 内部是否有冲突的开销；如果 $S$ 或 $T$ 内部确实存在冲突，得到的总开销将有所减小。

总之，花费 $O(|A|)$ 的开销就可以找到一对冲突的数。设 $N=10^9$ 为 $n$ 的最大范围，根据题目允许的查询开销，我们需要找到一个大小约为 $O(\sqrt{N})$ 且存在冲突的初始集合 $A$。

一种容易想到的方案是基于生日悖论：随机选取 $\Theta(\sqrt{n})$ 个 $1\sim n$ 范围内的数，则有较大概率会出现相同的数。这里我们可以直接在 $10^{18}$ 范围内随机选取一组数，那么它们对 $n$ 取模的值也大致是在 $0\sim n-1$ 范围内均匀随机的，当集合足够大时就很有可能出现冲突。

但由于要精确分析总开销，需要合理估计使用的集合大小。设 $|A|=c\sqrt{N}$，则可以不严谨地估计出没有发生冲突的概率大约为 $(\frac{1}{e})^\frac{c^2}{2}$。考虑到评分规则看的是最坏情况，一种方案是选一个较小的 $c$，然后如果没有冲突就重新随机；或者是选一个足够大的 $c$ 然后自信宣称里面一定存在冲突，直接免去检查 $A$ 这一步（OI 赛制下会比较冒险）。但无论如何整个过程都比较看脸，最终得到的最大开销大约会在 $4\times10^5$ 这个级别，只能获得不超过 $50$ 分。

如何做到更优？我们希望免去这样的随机，直接得到一个确定性的存在冲突的集合 $A$；更进一步如果能直接给出 $S$ 和 $T$，使得它们各自内部没有冲突（或很容易检验）而二者之间一定存在冲突，就可以再减少一步检验的开销，只剩下 $2|S|+3|T|$ 的二分开销。

容易看出，我们实际上只需要让每个 $i\in \{1,...,N\}$，都存在 $s\in S, t \in T$ 使得 $|s-t|=i$ 即可。更进一步可以把上述 $i$ 的范围改成 $\{\frac{N}{2} + 1,...,N\}$ 即可，因为不超过 $\frac{N}{2}$ 的数的某个倍数一定都涵盖在内了。

熟悉数论的小伙伴可能已经想到，数论中的大步小步（BSGS）算法本质上就是在做类似的事。具体而言，构造 $S=\{1,2,...,p\}, T=\{\frac{N}{2}+p,\frac{N}{2}+2p,...,\frac{N}{2}+pq\}$，满足 $pq > \frac{N}{2}$ 即可。容易验证这样的构造满足要求。

然后如何检查 $S$ 和 $T$ 各自内部是否有冲突？注意到 $S$ 和 $T$ 都是等差数列，其实就是相当于把问题转化成了“查询 $n$ 是否不超过某个 $N'$”的子问题，只不过这个 $N'$ 比原问题要小得多，只有 $O(\sqrt{N})$ 级别。我们可以再套一层 BSGS 来解决：以检查 $S$ 为例，直接查询 $\{1,2,...,p', \frac{p}{2} + p', \frac{p}{2} + 2p', ..., \frac{p}{2} + p'q'\}$ 即可，至于 $T$ 其实就是把检查的数整体放大 $p$ 倍而已。

如果 $S$ 和 $T$ 内部没有冲突，按照之前的二分流程跑就行；如果有冲突，考虑到 $S$ 和 $T$ 都不大且呈等差数列，可以直接按类似 $\{1,2\}, \{1,3\}, ..., \{1,p\}$ 检查过去，开销比无冲突时正常做二分的流程小得多，就不考虑了。

分析一下目前的总开销：首先是二分的主流程，需要确定 $p,q$ 的大小，使得 $pq>5\times 10^8$，开销为 $2p+3q$；然后是对 $S$ 和 $T$ 内部的开销，只需要取 $p'=q'=\sqrt\frac{p}{2}$（或 $\sqrt\frac{q}{2}$），这一步的开销是 $2\sqrt\frac{p}{2}+2\sqrt\frac{q}{2}$。

最后是得到一对冲突的数之后检查因子的开销：每次检查因子 $w'$ 其实就是查询 $\{1, w'+1\}$ ，而 $10^9$ 范围内检查因子的总开销最大的数是 $901800900=2^2\times 3^2\times 5^2\times 7^2\times 11^2\times 13^2$，总开销为 $24$。

写一个程序精确计算一下，发现当 $p=27512,q=18174$ 时，理论最大总开销……竟然**刚好是精确的** $110000$！当然实际上这是在每次对于奇数的二分都恰好往大的一侧递归，且最终得到的 $w$ 又刚好达到二分质因子的最大开销时才会发生，实际上不会同时达到，实测结果是在在 $n=768398400$ 时会达到最大值 $109996$。

当然有一个小优化可以让它变得不是那么紧：考虑二分时交换 $S$ 和 $T$ 集合的地位，这样开销就变成了 $3p+2q$，这样算出来的 $q$ 会比 $p$ 大。再结合 $S$ 和 $T$ 本身的构造方式，容易发现每一个 $S$ 中可能出现的两数之差，其倍数都出现在 $T$ 中了。因此我们可以只对 $T$ 集合进行检验。此时的精确结果为将上述 $p$ 和 $q$ 颠倒，理论次数上界为 $109809$，实际最大为 $109805$。

注意到上述做法实际上只利用了“集合有没有冲突”而没有利用“具体有多少对冲突”的信息，或许有办法利用这一信息进一步优化。你有更优的做法吗？欢迎讨论~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define li long long
#define vl vector<li>
#define pb push_back
#define pii pair<int,int>
#define vpi vector<pii>
#define mp make_pair
#define fi first
#define se second
const int N = 18174, M = 27512, Q1 = 118, Q2 = 117;
const int QQ = Q1 * Q2 * 2;
int cnt;
long long collisions(std::vector<long long> x);
bool query(vl x){
    cnt += x.size();
    return collisions(x) != 0;
}
bool chkQ(){
    vl A;A.clear();
    for(int i = 1;i <= Q1;++i) A.pb(i * N);
    for(int i = 1;i <= Q2;++i) A.pb((Q1 * Q2 + i * Q1 + 1) * N);
    return query(A);
}
bool chk2(vl A,vl B){
    vl x;x.clear();
    for(int i = 0;i < A.size();++i) x.pb(A[i]);
    for(int i = 0;i < B.size();++i) x.pb(B[i]);
    return query(x);
}
int work(vl A,vl B){
    if(A.size() == 1 && B.size() == 1) return abs(A[0] - B[0]);
    if(A.size() < B.size()) swap(A,B);
    vl A1,A2;A1.clear();A2.clear();
    int nn = A.size() >> 1;
    for(int i = 0;i < A.size();++i){
        if(i < nn) A1.pb(A[i]);
        else A2.pb(A[i]);
    }
    if(chk2(A1,B)) return work(A1,B);
    return work(A2,B);
}
bool chk_vpi(vpi x){
    int a = 1;
    for(int i = 0;i < x.size();++i){
        for(int j = 1;j <= x[i].se;++j) a *= x[i].fi;
    }
    return query({1,a + 1});
}
int final_chk(int x){
    int y = x;
    vpi pi;pi.clear();
    for(int i = 2;i * i <= y;++i) if(y % i == 0){
        pi.pb(mp(i,0));
        while(y % i == 0){
            ++pi[pi.size() - 1].se;
            y /= i;
        }
    }
    if(y > 1) pi.pb(mp(y,1));
	
	for(int i = 0;i < pi.size();++i){
        int l = 0,r = pi[i].se - 1,mid,ans = pi[i].se;
        while(l <= r){
            mid = (l + r) >> 1;
            pi[i].se = mid;
            if(chk_vpi(pi)){
                ans = mid;
                r = mid - 1;
            }
            else l = mid + 1;
        }
        pi[i].se = ans;
    }

    int a = 1;
    for(int i = 0;i < pi.size();++i){
        for(int j = 1;j <= pi[i].se;++j) a *= pi[i].fi;
    }
    return a;
}
int hack(){
    cnt = 0;
    if(chkQ()){
        for(int i = 1;i <= QQ;++i){
            if(query({1,i * N + 1})) return final_chk(i * N);
        }
        return -1; // unreachable
    }
    vl A,B;A.clear();B.clear();
    for(int i = 1;i <= N;++i) A.pb(i);
    for(int i = 1;i <= M;++i) B.pb(N * M + i * N + 1);
    return work(A,B);
}
```

---

## 作者：Zhao_daodao (赞：5)

# [APIO2025] Hack!

题目怎么不是按照难度排序。

---

考场做法。

考虑最简单的情况：一一判断。

对于一次询问 $(1,p+1)$，如果产生哈希冲突，说明此时 $N\mid p$。

然后询问 $p$ 的所有因数 $k$，最小的使得 $(1,k+1)$ 有冲突的数就是 $N$。

考虑一个大数 $X>10^9+\sqrt{10^9}$。

如果知道 $X\bmod N$，那么只需要分解 $(X-X\bmod N)$ 的因数就可以得到答案。

现在问题就是求出 $X\bmod N$。考虑二分这个数。

需要实现函数，判断 $X\bmod N$ 是否在 $[l,r]$ 中。

使用 BSGS 的思想。定义 $len=r-l+1,sq=\lfloor\sqrt{len}\rfloor$。

在集合中加入：

- $X,X-1,X-2,\dots,X-sq+1$ 共 $sq$ 个数。
- 从 $l$ 开始，每次加 $sq$，直到 $r$ 的等差数列。最后一个数跟 $r-sq+1$ 取 $\min$。

不难证明这样恰好能够覆盖 $[l,r]$。

发现这样询问可以用 $2sq+eps$ 次询问得出答案。

定义函数 $T(M)=T(\frac M2)+2\sqrt{M}$，询问次数为 $T(10^9)$。

这样会稍微爆掉一点，总长度大概是 $140000$。考虑常数优化。

对于 $X<2N$，$X\bmod N\le\lfloor\frac X2\rfloor$。

这样就二分区间直接砍半，可以通过。

最后分解因数的部分需要精细实现，可以参考代码。

不然就会被很多因数的询问卡掉，像我一样在考场上获得 99 分。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
#define Pair pair<int,int>
using namespace std;
const int X=1e9+3.2e4,MAX=X/2+1;
inline int collisions(vector<int>A);
inline int get(int N){
	int now=N;vector<Pair>pri;
	for(int i=2;i*i<=now;i++)if(now%i==0){
		int cnt=1;while(now%i==0)now/=i,cnt*=i;
		pri.push_back(Pair(i,cnt));
	}
	if(now>1)pri.push_back(Pair(now,now));
	int ans=1;
	for(int i=0;i<pri.size();i++){
		int pr=pri[i].first,now=1;
		while((N/now)%pr==0&&collisions(vector<int>{1,N/now/pr+1})){
			now*=pr;
		}
		ans*=pri[i].second/now;
	}
	return ans;
}
inline bool check(int l,int r){
	vector<int>qry;
	int len=r-l+1,sq=sqrt(len);
	for(int i=X;i>=X-sq+1;i--)qry.push_back(i);
	for(int i=l;i<=r;i+=sq){
		i=min(i,r-sq+1);qry.push_back(i);
	}
	return collisions(qry);
}
inline int get_ans(int l,int r){
	if(l==r)return get(X-l);
	int mid=l+r>>1;
	if(check(l,mid))return get_ans(l,mid);
	else return get_ans(mid+1,r);
}
signed hack(){
	int l=1,r=MAX;
	return get_ans(l,r);
}
```

---

## 作者：MatrixGroup (赞：4)

这里复原一下考场思路，感觉还是比较自然的。

题意不说了。记 $V=10^9$。

## 随机化！

先考虑一个能拿分的做法，也即代价不超过 $10^6$。

~~才不会告诉你我考场上一开始看成了 1e6 以内就能过。~~

随机 $2\times10^5$ 个 $[1,10^{14}]$ 范围的不同的数，那么不出现冲突的概率大约不超过 $\left(1-10^{-9}\right)^{(2\times10^5)^2/2}\approx \mathrm{e}^{-20}\approx2\times10^{-9}$，可以忽略不计。那么只需要已知有冲突的情况下找出一组，然后在每个质因子上二分或枚举即可，这个代价比较小可以先不管。

怎么找出一组呢？分治，如果两边各自有冲突就可以递归找，如果都没有就转化成了已知两个集合内部没有冲突，之间有冲突，要找出一组冲突。不断把较大的集合折半即可。

稍微分析一下，这个的最坏代价近似是 $f(N)=N+\max(f(N/2),g(N/2,N/2))$ 而 $g(N,M)=\min(N,M)+\max(N,M)/2+g(\min(N,M),\max(N,M)/2)$。这样的话 $g(N,N)=5N$ 而 $f(N)=3.5N$。那么这样就已经可以拿分了。

## 走向确定性

那么随机化很没有前途啊！这是因为就算你只问了一次 $1.1\times10^5$ 的询问，那也大约有 $(1-10^{-9})^{(1.1\times10^5)^2/2}\approx \mathrm{e}^{-6.05}\approx 0.23\%$ 的概率过不去，多测加上这么多组数据够呛的了。~~好吧考场上没有很多组数据只有多测。~~

能不能确定性地有一个序列能让 $1\sim 10^9$ 的所有数造成冲突呢？有的有的。取常数 $A,B,C$，那么所有 $\{(C+iB)-j\}(i=1,2,\cdots,A,j=1,2,\cdots,B)$ 可以生成 $AB$ 个连续的数。这很好了，直接让我们的 $N$ 来到了近似 $2\sqrt V$。不过看起来离正解还是很远啊。

## 省去第一步

别忘了我们的第一步是看两边各自有没有冲突。而实际上 $\{j\}(j=1,2,\cdots,B)$ 和 $\{C+iB\}(i=1,2,\cdots,A)$ 的内部的差其实很少！它们只有 $1,2,\cdots,B-1$ 和 $B,2B,\cdots,(A-1)B$。注意我们只需要保证**冲突**，因此只需要有这些差的**倍数**，那么就是 $B,2B,\cdots,\max(B-1,A-1)B$。而根据之前说的，生成这些差只需要约 $2\sqrt{\max(B-1,A-1)}$ 个数就行了，非常小！

如果有冲突的话就对刚才的「非常小」的集合做就行了，代价显然不会超。否则的话直接调用 $g$ 即可！

## 不相等之谜

之前我们都取 $A,B\approx \sqrt V$，但是这样真的最优吗？考虑代价是不对称的。假设 $A\ge B$ 且轮流折半，那么代价大约是 $\dfrac A2+B+\dfrac A2+\dfrac B2+\dfrac A4+\dfrac B2+\cdots\approx 2A+3B$。那么根据不等式基础知识，$AB$ 固定式应该在 $A:B=3:2$ 时取等。那么这样中间部分的代价就来到了大约 $2\sqrt{6V}$，离目标大概是一个 $\sqrt2$ 的差距了！

## 何以省一半

还记得我们之前说的吗，只需要保证**冲突**，因此只需要有这些差的**倍数**。那么 $1\sim 10^9$ 的整数不断乘 $2$ 总能落到 $[5\times10^8+1,10^9]$ 以内，因此初始只需要 $5\times10^8$ 个连续的数！那么我们就做到了中间部分的贡献大约是 $2\sqrt{3V}\approx 109544$。

诶看起来有点紧，仔细算一下贡献吧。取 $A=\left\lceil\sqrt{3/2V}\right\rceil,B=\left\lceil\sqrt{2/3V}\right\rceil$，也即 $A=27387,B=18258$。此时写个函数计算一下中间部分的代价

```cpp
int f(int x,int y)
{
	if(x==1&&y==1) return 0;
	if(x>y)swap(x,y);
	return x+y/2+f(x,y-y/2);
}
```

则 $f(A,B)=109556$。（当然你也可以枚举然后得到一些更精细的结果，最小值为 $109550$。）

最后一部分的代价如果朴素枚举而不是二分的话是最多 $k=\left\lfloor \log_2 D\right\rfloor$，其中 $D$ 是最大的差值，取 $C=\dfrac 12 V+1$ 的话也即 $C+AB-1$，总之 $k=29$，每次问两个数所以代价是 $58$。

$110000-109556-58=386$，对于 $2\sqrt{\max(A-1,B-1)}$ 是绰绰有余了。这里实现没算它是多少，写了 $200+150$，也是够的了。

## 代码实现

```cpp
long long collisions(std::vector<long long> x);
bool conflict(const std::vector<long long>&x)
{
	return collisions(x)>0;
}
bool divisorof(ll x)
{
	vector<ll> r={1,x+1};return conflict(r);
}
vector<ll> temp;
bool conflict(const vector<ll>&A,const vector<ll>&B)
{
	temp.clear();for(ll x:A)temp.pb(x);for(ll x:B)temp.pb(x);return conflict(temp);
}
ll dif,answer;
void solve_g(const vector<ll>&A,const vector<ll>&B)
{
	if(int(A.size())==1&&int(B.size())==1)
	{
		dif=abs(A[0]-B[0]);
		return ;
	}
	int n=int(A.size()),m=int(B.size()),l;
	vector<ll> test,remain;test.clear();remain.clear();
	if(n>=m)
	{
		l=n/2;for(int i=0;i<l;++i)test.pb(A[i]);for(int i=l;i<n;++i)remain.pb(A[i]);
		if(conflict(test,B)) solve_g(test,B);
		else solve_g(remain,B);		
	}
	else
	{
		l=m/2;for(int i=0;i<l;++i)test.pb(B[i]);for(int i=l;i<m;++i)remain.pb(B[i]);
		if(conflict(test,A)) solve_g(test,A);
		else solve_g(remain,A);	
	}
}
void solve_f(const vector<ll>&A)
{
	vector<ll> test,remain;test.clear();remain.clear();
	int n=int(A.size());
	int l=n/2;
	for(int i=0;i<l;++i)test.pb(A[i]);for(int i=l;i<n;++i)remain.pb(A[i]);
	if(conflict(test)) solve_f(test);
	else if(conflict(remain)) solve_f(remain);
	else solve_g(test,remain);
}
vector<ll> all,arr;
vector<ll> exceptions;
vector<ll> p;
void factorize(ll x)
{
	p.clear();
	for(int i=2;i<=x/i;++i) if(x%i==0)
	{
		p.pb(i);while(x%i==0)x/=i;
	}
	if(x>1)p.pb(x);
}
int hack()
{
	dif=0;
	all.clear();exceptions.clear();arr.clear();
	for(int i=1;i<=200;++i) exceptions.pb(i*18258);
	for(int i=2;i<=150;++i) exceptions.pb(i*200*18258);
	if(conflict(exceptions))
	{
		solve_f(exceptions);
	}
	else
	{
		for(int i=1;i<=18258;++i) all.pb(i);
		for(int i=1;i<=27387;++i) arr.pb(500000001+i*18258);
		solve_g(all,arr);
	}
	factorize(dif);
	answer=dif;
	for(ll x:p)
	{
		while(answer%x==0)
		{
			if(divisorof(answer/x)) answer/=x;
			else break;
		}
	}
	return int(answer);
}
```

---

## 作者：Monomial (赞：4)

先说一下我场上的做法。

考虑二分答案。我们设当前二分区间为 $[l,r]$，中点为 $mid$，那么我们 check 一下 $[l,mid]$ 区间内是否存在 $n$ 即可，因为我们的本意是 check 区间 $[2,mid]$，但是在二分区间的限制下 $n$ 必然不存在于 $[2,l-1]$ 区间内。

对于 check，我的做法是将 $[l,r]$ 区间分为尽量少的长形如 $x^2$ 的区间 $[l_{i},r_{i}]$。然后我们可以构造一个形如 $V,V-1,\dots,V-(x-1)$ 和 $V-r_{i},V-(r_{i}-x),\dots,V-(r_{i}-x\times(x-1))$（$V$ 为值域） 的 vector，容易发现其两部分的差可以覆盖区间内所有差值。

而对于同一部分内的差值 $d$，容易发现 $d \leq x^2$，那么区间内肯定至少有一个差值是 $d$ 的倍数，也就不用去管它。

直接这样做可以获得 $77$ 分，于是想着进一步优化。

我在场上发现 check 形如 $[p+1,2p]$ 的区间可以得出 $[2,2p]$ 区间的答案，便考虑在一开始先询问一次这样的区间，缩小二分范围，取 $p=2.724 \times 10^{8}$，当 $n=2p$ 时可以获得最劣询问次数 $136066$，可以获得 $84$ 分，场上止步于此。

考虑我们刚刚的做法，用 $[p+1,2p]$ 的区间答案得出了 $n$ 是否在 $[2,2p]$ 区间内，是否可以对其进一步利用？答案是肯定的。假设我们在 $[\frac{V}{2}+1,V]$ 区间内二分，那么我们得出的答案 $n_{1}$ ，那么一定有 $n \mid n_{1}$。证明非常容易，因为这个结果相当于有 $y \equiv y+n_{1} \pmod n$，那么有 $n_{1} \equiv 0 \pmod n$，即 $n \mid n_{1}$。

所以我们尝试枚举所有 $n_{1}$ 的因子，从小到大 check 一遍，第一个 check 成功的必然是答案，这样可以做到 $1.1 \times 10^{5} + eps$ 次，可以获得 $98$ 分。

前面一部分不太好优化，我们尝试从优化枚举因子这一部分入手。和之前同理，容易得到任意一个满足 $n \mid x$ 的 $x$，对 $x$ 进行 check 时必然返回值为 $1$。那么，我们只需要对于 $n_{1}$ 的每个质因子枚举或二分次数即可，这样在 $n=2^2 \times 3^2 \times 5^2 \times 7^2 \times 11^2 \times 13^2=901800900$（该做法的最劣情况）时，也可以做到 $< 1.1 \times 10^{5}$ 次，可以获得 $100$ 分。

[代码](https://www.luogu.com.cn/paste/grykixqd)

---

## 作者：qqqaaazzz_qwq (赞：3)

纪念考场上死磕此题的我，最后 T3 得了 16 分（

考场思路如下：

首先我们需要让 `collisions` 函数是有用的。如果我们给出的集合不够精巧，那么 `collisions` 函数大概率返回 `0`，无法得到任何信息。

看到满分线是 $110000$，猜测应该是与根号有关的东西，自然的想到大步小步算法，并构造出这样的集合：

$$
\{x-km,...,x-2m,x-m,x,x+1,x+2,...,x+m-1\}
$$

当 $n < (k+1)m$ 的时候，放进去这个集合一定会产生哈希冲突，因为将 $n$ 表示为 $am+b(b<m)$ 的形式，那么 $x-am$ 和 $x+b$ 一定是同余于 $n$ 的。取 $k+1=m=\sqrt n$，集合最小。

因此就可以二分 $n$ 了。检查 $n$ 是否 $\leq mid$，按照上述方法构造一个集合扔给 `collisions` 函数就好了。实现的好一点能够获得 $78$ 分，`maxcost` 约等于 $152701$，考场上止步于此。

其实优化很简单，把 $l$ 开成 $5 \times 10^8$，这样得到的答案 $n'$ 一定是 $n$ 的倍数，暴力枚举因子并暴力判断就好了。`maxcost` 约等于 $108000$，足以通过本题。

---

## 作者：_Ad_Astra_ (赞：3)

### 写在前面

这道题最难的部分不是在于想到正解的框架，而是在框架的基础上进行卡常/剪枝而得到正确解法。

人傻常数大，来一个比较暴力的做法。过的比较极限，如果想要更好的做法请移步别的题解。可能会稍显啰嗦，轻喷。

（由于笔者并不太会分析极限情况，截至写下这篇题解时这份代码能通过所有测试数据和我已知的 hack。如果有 hack 或出现错误请直接喷我。）

---

### 76 pts

由于前面几档部分分较为显然，且对于正解意义不大，因此略过。

考虑能获得的信息是询问的集合中任意两个数的差是否有 $n$ 的倍数，一次获得的信息量大约是 $O(|x|^2)$ 的，最多也只比 $n$ 多一个数量级。因此我们可以先猜测：复杂度是 $O(\sqrt{n})$ 的。

考虑朴素的问题：如何用 $q$ 个数拼出比较多的互不相同的数？为了稍微直观一点的考虑，我们取原序列 $x$ 排序后的差分数组。相当于我们可以表示出这个差分数组任意一段区间的和，现在要让不同的和尽可能多。

结合我们猜测的复杂度，可以想到我们需要取一个阈值 $B$。考虑每个数 $n$ 可以表示成 $qB+r(q,r \in \mathbb{N}, 0 \le r \lt B)$ 的形式。左边可以堆一些长度为 $B$ 的块（假设有 $K$ 块），右边再放 $B-1$ 个长度为 $1$ 的段。容易发现，这样 $[0,KB)$ 内的所有整数都恰好可以被表示至少一次。

![](https://cdn.luogu.com.cn/upload/image_hosting/mjs8vffh.png)

取 $B=\sqrt{n}$，序列长度就大约是 $2\sqrt{n}$ 左右。

实际上不难看出，这本质上就是 BSGS 算法。（题外话：笔者想到这里的时候其实并没有看出这一点，不过没有影响。）

现在考虑原题。联系到我们需要恰好找到一个满足的数，自然地想到二分。如何二分呢？也许可以每次动态调整块长，但是好像会有点麻烦。因此笔者这里有一个相对暴力的实现。

整体如果不好做，就先考虑对于左边的整块和右边的单点两个部分分开来二分。注意到如果我们确定了需要的答案在 $mid$ 左半边，那么分界线右边的块是没有用处的，可以直接合并成一个大块降低复杂度（具体而言，假设左边整块部分当前的下界是 $l_1$，右边的下界是 $l_2$，那么中间的 $l_1B+l_2$ 部分可以直接合并为一块）。否则的话，答案在分界线右边，那么左边的块可以直接舍弃了。

![](https://cdn.luogu.com.cn/upload/image_hosting/gtv95ks8.png)

问题是这个写法仍然是 $O(\sqrt{n}\log n)$ 的，连一分都拿不到。

注意到我们的损耗主要来源于在一侧二分时，另一侧的所有点都要保留，非常浪费。所以考虑尽量让两边大小平均，不难想到交替着二分，一次左边一次右边，这样子每 $2$ 次询问就可以将大小减半。复杂度就变成了大常数 $O(\sqrt{n})$。具体地，考虑长度为 $m$ 的序列操作次数为 $T(m)=\frac{3}{4}m+\frac{1}{2}m+T(\frac{m}{2})$，大约是 $\frac{5}{2}m$，那么需要的操作次数就是 $T(2\sqrt{n})=5\sqrt{n}$ 次。

这时候交上去发现你全 WA 了。原因在于，我们二分出来的结果并不是最后的答案。因为理论上任何一个 $n$ 的倍数 $n'$ 都能符合条件，所以最后我们还要枚举得到的 $n'$ 的因数进行 check。好在根据 ~~uq 常见问题速查表~~熟知结论，$n \le 10^9$ 时，$max\{d(n)\} = 1344$，因此常数很小。

可以获得 76pts。（实测 $q$ 在 $1.6 \times 10^5$ 左右。）

```cpp
#define ll long long
#define pb push_back
#define fir first
#define sec second
#define chmin(a,b) (a=min(a,b))
#define chmax(a,b) (a=max(a,b))
ll collisions(vector<ll>x);
const int b=30000;
const int maxn=1e9;
const int c=maxn/b;
bool query(int l1,int r1,int l2,int r2)
{
	// 查询：左边整块在 [l1,r1] 内，右边单点在 [l2,r2] 内是否有 n 的倍数
	vector<ll>tmp;
	tmp.pb(1);
	int x=1;
	for(int i=r1;i>l1;i--)tmp.pb(x+=b); 
	if(l1||l2)tmp.pb(x+=l1*b+l2);
	for(int i=l2+1;i<=r2;i++)tmp.pb(++x);
	ll ans=collisions(tmp);
	return (ans>0); 
}
int solve(int l1,int r1,int l2,int r2,int op)
{
   // 左边整块在 [l1,r1] 内，右边单点在 [l2,r2] 内，op=0/1 表示当前二分的位置是左边/右边
	if(l1==r1&&l2==r2)return l1*b+l2;
	if(!op&&l1==r1||op&&l2==r2)solve(l1,r1,l2,r2,op^1);
	if(op==0)// 整块
	{
		int mid=l1+r1>>1;
		bool tmp=query(l1,mid,l2,r2);
		if(tmp)return solve(l1,mid,l2,r2,op^1);
		return solve(mid+1,r1,l2,r2,op^1);
	} 
	else// 单点
	{
		int mid=l2+r2>>1;
		bool tmp=query(l1,r1,l2,mid);
		if(tmp)return solve(l1,r1,l2,mid,op^1);
		return solve(l1,r1,mid+1,r2,op^1);
	}
}
int hack()
{
	int tn=solve(0,c,0,b-1,0);
	// 计算 n'
	vector<int>tmp;
	for(int i=1;i*i<=tn;i++)if(tn%i==0)
	{
		tmp.pb(i);
		if(i*i!=tn)tmp.pb(tn/i);
	}
	sort(tmp.begin(),tmp.end());
	for(auto x:tmp)
	{
		// 枚举因数
		vector<ll>pq;
		pq.pb(1),pq.pb(x+1);
		ll ptq=collisions(pq);
		if(ptq>0)return x;
	}
}
```

### 96 pts

主要的做法已经基本上是正解了，接下来就是一个作用非常显著的优化。

这一个剪枝感觉还是非常精妙的。

考虑到我们实际上只需要询问出一个 $n$ 的倍数。注意到在 $(5\times10^8,10^9]$ 之间至少有一个 $n$ 的倍数。（对于 $n \le 5\times10^8$，$n$ 小于等于区间长度，至少会覆盖一个 $n$ 的倍数，而 $n \gt 5\times10^8$ 则 $n$ 本身满足。）

因此我们可以把左边的下界调到 $\frac{K}{2}$，也就是左边只需要对于 $(\frac{K}{2},K]$ 二分即可，常数上的优化是巨大的，可以获得 96pts。操作次数是 $\sqrt{n}+T(\sqrt{n})=\frac{7}{2}\sqrt{n}$，已经几乎能通过了。我的代码大概只多出来了 $5000$ 次询问，对于前半部分实现的比较好的代码已经可以通过了。

### 100 pts

由于我人傻常数大，所以再加一些小优化。

首先发现没必要枚举所有因数，而是利用答案是 $n'$ 因数这一特点。考虑把 $n'$ 分解质因数，对于每一个质因数去试除，判断是否是 $n$ 的倍数，如果是就除掉。这样子复杂度就从 $O(d(n))$ 降低到了 $O(\log n)$，我的代码可以获得 98pts。

然后由于我们加上剪枝以后，两边的长度并不相等，可以考虑调整块长让两边均衡。对于我本人的代码，取 $B=27000$ 可以通过。当然不同代码可能会有差异，仅供参考。

代码与上面的其实差别不大，这里就只给[提交记录](https://www.luogu.com.cn/record/217776254)了。

---

### 后记

去不了 apio 的场外 vp 选手写的一篇题解。我本人做到 76pts 就跑路了，后来才听说了这些厉害优化。

总体而言由于这个二分的做法很暴力，所以常数自然也很大，被卡常也是在意料之内的。写这一篇题解只是想记录一下一些小的剪枝技巧。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/37s9anq5.png)

有奶龙口胡时把 $O(\sqrt{n})$ 分析成 $O(\sqrt{n}\log n)$ 了。

---

## 作者：SDSXC (赞：3)

首先考虑如何 $N+eps$ 次操作找到答案

考虑二分，每次可以以 $r-l+2$ 的代价检查 $[l,r]$ 这个区间中是否有 $n$ 的倍数。

总共需要 $\frac{N}{2}+1+\frac{N}{4}+1+\frac{N}{8}+1\dots=N+logN$ 次操作，来检查一个大小为 $N$ 的区间。

当然这个做法可能过不了 Subtask 2，因为有个 $logN$ 的小量，但是在后面有一定的用处。

再看 78pts 做法。

我们注意到，我们可以使用 $2B$ 个数来 check 一个大小为 $B^2$ 的区间 $[l,l+B^2-1]$，具体构造如下:$B-0,B-1,B-2,\dots B-(B-1),B+l+0B,B+l+1B,B+l+2B\dots,B+l+(B-1)B$

解释一下这为什么是对的，注意到 $[l,l+B^2-1]$ 中的所有数均可以被写成 $l+xB+y$ 的形式，其中 $x,y\in[0,B-1]$，那么会被 $B+l+xB$ 和 $B-y$ 发生一次碰撞。但是我们还发现 $0~B-1$ 和 $B$ 的一些倍数会被额外算进去，但是这不重要，可以在后续做法中通过一些优化去除这个影响。

注意到我们现在可以二分了，每次检查 $n$ 是否在 $[l,mid]$ 中，$[l,mid]$ 中元素个数不为完全平方数的可以略微将 $mid$ 右移一些。注意一定要 check 左区间，这样做有两个好处。第一是我们一定可以保证二分出来的是最小的 $n$ 的倍数即 $n$ 本身，第二我们还可以去除那些额外的数的影响，因为这些数均 $<B^2\leq l+B^2-1$ ，所以如果 $n$ 是这些数中的某个的约数一定也在左区间中。

注意到剩下最后几个数时，为了保证被二分的数的个数必须是完平，可能很难有效的减小区间大小，所以考虑直接按照开篇提到的的方法暴力。

复杂度由主定理可得时 $O(\sqrt N)$ 的，但是常数略大，无法通过。

然后考察 99 分做法。注意到我们再第一次二分时消耗了大量的询问考虑怎么优化掉它，我们可以直接删去第一次二分，把二分的起始区间改为 $[5\times 10^8,1\times 10^9]$，这样最后二分出来的时答案的倍数，再暴力检查其因数，可以获得 99pts。

最后我们想一下是什么数据把我们卡了，应该是存在比较多的因数。考虑优化，只要检查完某个数不行，那么它的所有约数一定不行，要是某个数可行，那么答案一定是它的约数，我们从大到小一一检查，就可以节省很多无效查询，可以获得 100pts。

~~所以好像返回bool和long long没啥区别？~~

AC代码

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define ll long long
using namespace std;
long long collisions(vector<long long> x);
pair<bool,pii> check(int l,int r){
	int b=min(int(sqrt(r-l+1)+1),r-l+1);
	r=l+b*b-1;vector<ll> q;q.clear();
	for(int i=0;i<b;i++){
		q.push_back(b-i);
	}
	for(int i=0;i<b;i++){
		q.push_back(b+l+i*b);
	}
	if(collisions(q)){
		return make_pair(true,make_pair(l,r));
	}
	else{
		return make_pair(false,make_pair(l,r));
	}
}
int cdq(int x,int y){
	if(x==y) return x;
	int mid=x+y>>1;
	vector<ll> q;q.clear();q.push_back(1);
	for(int i=x;i<=mid;i++) q.push_back(1+i);
	if(collisions(q)) return cdq(x,mid);
	else return cdq(mid+1,y);
}
vector<int> wr,cr;
int chk(int x){
	for(int u:wr){
		if(u%x==0) return -1;
	}
	for(int u:cr){
		if(u%x) return -1;
	}
	return collisions({1,1+x});
}
vector<int> ans;
int hack(){
	int l=5e8+1,r=1e9;
	while(r-l>50){
		int mid=l+r>>1;
		auto t=check(l,mid);
		if(t.fi){
			l=t.se.fi;r=t.se.se;
		}
		else{
			l=t.se.se+1;
		}
	}
	int t=cdq(l,r);ans.clear();
	wr.clear();cr.clear();
	ans.push_back(1);
	for(int i=2;i*i<=t;i++){
		if(t%i==0){
			ans.push_back(i);
			ans.push_back(t/i);
		}
	}
	sort(ans.begin(),ans.end(),greater<int>());
	for(int u:ans){
		int t=chk(u);
		if(t==1){
			cr.push_back(u);
		}
		else if(t==0){
			wr.push_back(u);
		}
	}
	if(cr.empty())return t;
	else return cr[cr.size()-1];
}
```

---

## 作者：lichenghan (赞：2)

我们先试图找到一个 $n$ 的倍数 $m$。由于可以通过直接询问 $\set{1,x+1}$ 来判定一个数 $x$ 是否是 $n$ 的倍数，所以已知 $m$ 求 $n$ 可以在 $O(\log n)$ 的代价内完成。

有一个显然的性质：$[5\times10^8,10^9]$ 中一定存在一个 $n$ 的倍数。

于是考虑在这个区间内二分。考虑如何检查区间 $[l,r]$ 内是否存在 $n$ 的倍数。

取 $b=\lfloor\sqrt{r-l+1}\rfloor$。

考虑询问集合 $S=\set{1,2,\cdots,b,b+l,2b+l,\cdots,\lfloor\frac{r-l}b\rfloor b+l,r+1}$。

（放个代码可能好理解一些）

```cpp
bool chk(int l,int r){
	int b=sqrt(r-l+1);
	vector<int> a;
	for(int i=1;i<=b;i++) a.push_back(i);
	for(int i=b+l;i<r+1;i+=b) a.push_back(i);
	a.push_back(r+1);
	return collisions(a);
}
```

>正确性证明：
>
>显然对于所有 $x\in[l,r]$，一定存在 $a,b\in S,|a-b|=x$。
>
>对于 $a,b\in S$，设 $d=|a-b|$，
>
>可以发现，若 $d\notin [l,r]$，则 $d\in[1,r-l+1]$。
>
>而若 $[1,r-l+1]$ 中存在 $n$ 的倍数，则 $[l,r]$ 中必然存在 $n$ 的倍数。
>
>于是，$S$ 中会发生哈希冲突等价于 $[l,r]$ 中存在 $n$ 的倍数。

这样，一次检查 $[l,r]$ 的代价就是 $2\sqrt{r-l+1}+O(1)$。

记 $N=10^9$，总代价即为 $O(\log N)+\sum_{i=2}^\infty2\sqrt{N\times 2^{-i}}$，

化简得 $\sqrt2(\sqrt2+1)\sqrt N + O(\log N)$。实测总代价是 $108000$ 左右。

题外话：作者赛时没有发现开头那个显然的性质，于是对着 $[1,10^9]$ 二分，代价要乘上 $\sqrt 2$，$78$ 分遗憾离场。

---

## 作者：20_200 (赞：1)

### APIO2025 Hack!

很好的交互题，充分展现人类智慧，但是它并不配被放在T1。

**题意**

有一个正整数 $n\le 10^9$，由交互库初始时生成，而后固定不变，但对你不可见。

你需要编写一个函数 `int hack()` 去猜测 $n$ 的值。

你可以在 `hack()` 中调用交互库提供的 `ll collisions(vector<ll>x)` 函数，要求传入的 $x$ 所有元素互不相同且为正整数，该函数返回 $\sum_{i,j\in x,i\neq j}[x_i\bmod n=x_j\bmod n]$，即该序列中模 $n$ 后会产生哈希冲突的二元组数。

你需要保证所有调用传入的 $x$ 的长度之和不超过 $110000$ 才能获得满分，否则若不超过 $10^6$ 也可获得一部分的分数。

**交互库**

一个可以直接用 VSCode F5/Dev F11 编译运行的交互库。（同目录下的 hack.h 文件为符合洛谷提交格式的文件，题解最后面的代码符合要求）

```cpp
#include "hack.h"
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <vector>
#include <map>
#include <set>

static int n = 0;
static int total_cost = 0;

long long collisions(std::vector<long long> x){
	total_cost += (int) x.size();
	if (total_cost > 1000000){
		printf("Total cost exceeded 1,000,000\n");
		exit(0);
	}
	
	long long res = 0;

	std::map<int, int> table;
	std::set<long long> seen;
	for (long long v : x){
		if (v < 1 || v > (long long)1e18){
			printf("x[i] is out of range\n");
			exit(0);
		}

		if (seen.find(v) != seen.end()){
			printf("x has a duplicate element\n");
			exit(0);
		}

		seen.insert(v);
		
		res += table[v % n];
		table[v % n]++;
	}

	return res;
}

int main(){
	int t=20;
	// assert(1 == scanf("%d", &t));

	std::vector<int> ns(t);
	mt19937 rnd(time(0));
	int mxc=0;
	for (int i = 0; i < t; i++){
		ns[i]=rnd()%(100000000)+9e8;
		ns[0]=735134400;
		ns[1]=768398400;
		// assert(1 == scanf("%d", &ns[i]));
		cout<<ns[i]<<'\n';
		total_cost = 0;
		n = ns[i];
		int ans = hack();
		printf("%d %d\n", ans, total_cost);

		mxc=max(mxc,total_cost);
	}
	cout<<"max:"<<mxc<<'\n';
	cout<<"score:"<<25+75*(mxc<110000?1:log(1e6/(mxc-9e4))/log(50));
	return 0;
}
```

**分析**

以下包含了本题各档不同得分的做法，每一档都是一个做法或者优化，建议看完一档后继续想一想再接着看，可能有利于更好的理解和启发做这类题的思路。

**8pts**

显然只需对 $k=1,2,\dots,5\times10^5$ 全部询问一遍 $\{1,k+1\}$ 即可。

**25pts**

若 $n\le5\times10^5$ ，则存在一个 $n$ 的倍数在 $(5\times10^5,10^6]$ 范围内，则只需对 $(5\times10^5,10^6]$ 内的数询问一遍即可解决 $n\le10^6$。(这个优化非常重要，在后面还会用到，可以让询问次数变为原来的 $\frac{1}{\sqrt2}$ 倍)

**27pts**

对于 $n\le10^9$ 的数据，若要在 $10^6$ 次内猜对，则 $O(n)$ 级别的询问次数是不可接受的。需要设计一个根号或者略高于根号的算法。

题目背景是卡哈希，如果你真的被卡过哈希的话应该了解过**生日悖论**。随机生成 $k$ 个 $[1,10^{14}]$ 整数并对 $n$ 取模，使得存在一对数相同。每一对整数取模后是否相同可近似视为相互独立，则存在两个整数模意义下相同的概率为 $1-(1-\frac{1}{n})^{\binom{k}{2}}\approx1-e^{-\frac{k^2}{2n}}$，若取 $k=120000$，则每次成功的概率大于 $99.9\%$。

那么现在的问题变成了从一个序列中找一对数模 $n$ 相同（称之为**哈希冲突对**），保证存在。因为只要找到一个哈希冲突对就可以通过枚举该对两数之差的因子的方法使用很少的次数询问出 $n$ 的值。

首先有一个非常简单的想法就是二分最短的存在哈希冲突的前缀，这样就可以找到最靠前的存在哈希冲突对的位置，然后再枚举另一个数就能找到一个哈希冲突对。

这个方法是 $O(\sqrt{n}\log n)$ 的，精细调参后可以做到询问次数 $\le10^6$，但是顶多也就 27pts。

**44pts**

使用类似分治的方法把这个 log 去掉。具体的，尝试找到某种方法**在序列长度级别的次数内把整个序列的规模减半**。

对于当前的序列 $S$，把它分成 $4$ 个序列 $S_1,S_2,S_3,S_4$，然后两两拼在一起进行询问就可以确定一个包含哈希冲突对的子序列 $S_xS_y$，然后把它变为新的 $S$ ，则其长度变为原来的一半，继续向下递归直到其长度为 $2$ 即可确定一个哈希冲突对。

这样询问次数的复杂度就变成了 $O(\sqrt{n})$ 。

在两两询问的过程中，一旦当前询问的序列包含哈希冲突对则后面的无需继续询问而可以直接向下递归，且最后一对是无需询问的，因为整个序列中哈希冲突对必定存在。这个算法每次递归期望需要 $\frac{1+2+3+4+5+5}{2\times6}|S|=\frac{5}{3}|S|$ 询问次数，则整个过程的期望次数为 $\frac{10}{3}|S|$，大约为 $400000$，可以获得 44pts 左右。

**62pts**

发现序列长度为 $120000$ ，乘以 $\frac{10}{3}|S|$ 实在太大了。考虑**降低初始序列的长度**，随机生成完后询问整个序列检查是否包含哈希冲突对，若一次不成功则重新随机直到成功为止。则期望询问次数变为了 $(\frac{10}{3}+\frac{1}{1-e^{-\frac{|S|^2}{2n}}})|S|$。由于需要随机生成序列，若失败则要整个重来，所以若序列长度太大，则方差会很大。考场上使用的这个做法，经过几十次 selfeval 精细调参后取了 $|S|=40000$，得分会在 [45,78] 中随机，最终得分 62pts。

**69pts**

找的 $S$ 的一个哈希冲突对用了 $\frac{10}{3}|S|$ 的询问次数，且稳定性很差，得分不高。

将 $S$ 分成 $S_0,T_0$ 。先询问 $S_0,T_0$ 即可判断 $S_0,T_0$ 是否单独包含哈希冲突对，若是的话则直接将其变为新的 $S$ 即可使长度减半。

否则，**哈希冲突对一定在 $S_0$ 和 $T_0$ 之间**，将 $S_0$ 再分成 $S_1,S_2$，$T_0$ 再分成 $T_1,T_2$ 。先将 $S_1$ 和 $T_0$ 拼起来询问即可确定哈希冲突对在 $S_1$ 还是 $S_2$ 中，从而得到长度减半的新的 $S_0$。
然后再将 $T_1$ 和新的 $S_0$ 拼起来询问即可确定哈希冲突对在 $T_1$ 还是 $T_2$ 中，从而得到长度减半的新的 $T_0$。

而且哈希冲突对一旦被确定在 $S_0$ 和 $T_0$ 之间，之后就不需要再判断 $S_0$ 和 $T_0$，那么每次递归需要的询问次数就是 $|S_0|+\frac{3}{2}|T_0|$，总的次数为 $2|S_0|+3|T_0|$。

因为 $|S_0|$ 和 $|T_0|$ 的系数不同，所以初始划分时其最优大小也不相等，所以每次递归之前如果 $|S_0|<|T_0|$ 则交换  $S_0$ 和 $T_0$ 。

加上一开始单独询问的 $|S_0|+|T_0|$ 次和随机生成序列的需要的次数，总的期望次数为 $(\frac{7}{2}+\frac{1}{1-e^{-\frac{|S|^2}{2n}}})|S|$，期望虽略大，但**方差远小于上一个算法**，故在多测取max的情况下得分更高，大约 69pts。

**76pts**

初始随机生成序列时，由于需要检查是否成功而消耗了非常多的次数，且若失败还要重来，非常不稳定。

尝试构造一个初始序列使得其两两之差可以覆盖 $\le10^9$ 的所有正整数。把 25pts 部分的优化加上，只需要覆盖 $(5\times10^8,10^9]$ 的所有正整数即可。

**BSGS 算法的思想** 可以解决这个问题。取一个 $\sqrt{n}$ 级别的阈值 $B$，让 $S_0=\{1,2,\dots,B\},T_0=\{5\times10^8+B,5\times10^8+2B,\dots,5\times10^8+\lceil\frac{5\times10^8}{B}\rceil B\}$，那么容易发现，这样的 $S_0,T_0$ 可以覆盖所有 $5\times10^8+xB-y(x\in[1,\lceil\frac{5\times10^8}{B}\rceil],y\in[1,B])$，即  $(5\times10^8,10^9]$ 的所有正整数。

经过调参，取 $B=18500$ 较优，询问次数可以降低到 $150000$ 左右，获得 76pts。

**97pts**

判断 $S_0,T_0$ 内部是否单独包含哈希冲突对消耗了 $|S_0|+|T_0|$ 次询问，这非常多，尝试优化这个部分。

在上面的构造方法中，$S_0,T_0$ 都是等差数列，**其内部两两之差可以覆盖的数也是等差数列**。由于 $S_0$ 的两两之差都可以乘 $B$ 后在 $T_0$ 的两两之差中找到，因此只需考虑 $T_0$ 内部的情况。

$T_0$ 的两两之差形如 $\{x,2x,\dots,kx\}$ 。可以对这个集合再用一次刚才的 BSGS 构造，用 $\{x,2x,\dots,\sqrt kx,2\sqrt kx,3\sqrt kx,\dots,kx\}$ 即可在 $O(\sqrt{\max(|S_0|,|T_0|)})$ 次的级别内检查 $T_0$ 内部的情况。

那么现在的询问次数是 $2\max(|S_0|,|T_0|)+3\min(|S_0|,|T_0|)+2\sqrt{\max(|S_0|,|T_0|)}$ ，取 $|S_0|=18500,|T_0|=27027$，大约为 $109880$，实际最大值在 $112000$ 左右，可以获得 97pts。

**100pts**

上述询问次数计算中忽略了最后的枚举因子得出 $n$ 的值的部分，这个部分使用的次数为 $2d(m)$ ，其中 $m$ 是我们找到的哈希冲突对的两数之差的绝对值， $d(m)$ 表示 $m$ 因子个数，它的值是期望 $O(\log m)$ 级别但并不总是这样，**某些数的因子个数可能会非常巨大**。例如当 $m=735134400$ 时 $d(m)=1344$（ $\le10^9$ 的数中最多的），这个部分消耗了两千多的询问次数，可以 hack 上述做法。

设我们最后询问得到的 $m$ 的质因数分解形式是 $m=\prod p_k^{v_k}$，则询问所有 $x=m\times p_k^{i-v_k}(0\le i\le v_k)$ 并对所有返回为 $n$ 的倍数的 $x$ 取 gcd 即可得到 $n$ 的值，因为 gcd 之后所有的质因数都得到了它应有的指数。这样这个部分的询问次数就降到了质因子数的严格 $O(\log n)$ 级别，严格不超过 $2(1+\log_2n)$ 。

最终的询问次数的最大值是 $109917$，可以 AC 本题。想不到这个 $110000$ 竟然卡得如此之紧。

**调参**

对于这种次数卡得很紧且式子里需要取整的题目，调参时使用程序暴力枚举参数的值可能会比求导/不等式进行最小值的理论分析得到的结果更优。如果存在随机性，可在程序跑出的理论值附近手动调参使得实际运行结果更优。如果是多测取max，不仅要关注期望，还需要关注方差（随机波动性）带来的影响（当然也可以直接最小化多测取max之后的期望，但是这大概率比较难算）。

**代码**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define pii pair<ll,ll>
#define ve vector<ll>
#define fi first
#define se second
#define pb push_back
#define mid (l+r>>1)
#define lx (x<<1)
#define rx (x<<1|1)
using namespace std;
ll collisions(ve x);
ve meg(ve x,ve y){
	ve z=x;
	for(ll i:y)z.pb(i);
	return z;
}
ve div(ve x,ll t){
	ve y;
	for(ll i=0;i<x.size();i++)
		if((i&1)==t)y.pb(x[i]);
	return y;
}
int hack(){
	ll B=18500,B0=sqrt(max(B,(int)5e8/B+1))+1,w=0;
	ve s,t,z;
	for(ll i=1;i<=B;i++)s.pb(i);
	for(ll i=B;i<=5e8;i+=B)t.pb(i+5e8+B);
	for(ll i=1;i<=B0;i++)z.pb(i*B),z.pb((i+1)*B0*B);
	if(collisions(z)){
		for(ll i:z)for(ll j:z)
			if(i!=j&&collisions({i,j}))w=abs(i-j);
	}
	else{
		while(s.size()>1||t.size()>1){
			if(s.size()<t.size())swap(s,t);
			ve c[2]={div(s,0),div(s,1)};
			if(c[0].size()>c[1].size())swap(c[0],c[1]);
			s=c[collisions(meg(c[0],t))?0:1];
			c[0]=div(t,0),c[1]=div(t,1);
			if(c[0].size()>c[1].size())swap(c[0],c[1]);
			t=c[collisions(meg(c[0],s))?0:1];
		}
		w=abs(s[0]-t[0]);
	}
	s={w};
	ll x=w,ans=0;
	for(ll i=2;i*i<=w;i++)
		if(x%i==0){
			ll v=1;
			while(x%i==0)x/=i,v*=i;
			for(ll j=1;j<=v;j*=i)s.pb(w/v*j);
		}
	for(ll i:s)
		if(collisions({i+1,1}))ans=__gcd(ans,i);
	return ans;
}
```

---

## 作者：_ANIG_ (赞：1)

题意大概是根据冲突次数问出来哈希模数。

实际上，本题中无需知道冲突次数，只需知道是否冲突。

考虑集合 $S$ 冲突的充要条件，可以发现就是看是否存在两个数 $x\in S,y\in S$，且 $x\equiv y\pmod n$。

也就是是否存在两个数 $x\in S,y\in S$，且 $n|x-y$。

如果我们能构造出一个集合，使得所有能表示成这个集合中两数之差的数构成一个前缀，那么就可以通过二分答案求出 $n$。

问题转化为对于给定的 $m$ 求出一个集合 $S$，使得存在 $x\in S,y\in S$，满足 $k=x-y$ 当且仅当 $k\le m$。

一种经典的构造是取 $T=\sqrt m$，取 $S=\{1,2,3,\dots,T,T+1,2T+1,3T+1,\dots,m+1\}$。

这样总共需要 $2\sqrt m$ 个数，总复杂度 $O(\sqrt n\log n)$，只有 $25$ 分。

考虑优化。

这个做法的问题在于当我们二分的区间很小的时候，如果 $l,r$ 都很大，那么集合的大小比较大。

考虑能否构造一个大小与区间长度相关的集合，从而查询这个区间内是否有 $n$ 的倍数。

令 $T=\sqrt {r-l+1}$，构造 $S=\{1,2,3,\dots,T,l+T,l+2T,\dots,r+1\}$。

于是，我们的查询次数为 $\sum\limits_{2^i\le n}\sqrt\frac{n}{2^i}=O(\sqrt n)$。

但是由于常数很大，无法通过。

注意到，由于 $n\le 10^9$，所以一定存在一个 $n$ 的倍数大于 $5\times 10^8$。

于是把初始二分区间设置为 $[5\times 10^8,10^9]$，二分出来一个结果 $N$，枚举 $N$ 的因数，逐个检测是否是答案即可。

这样可以获得神秘的 $99$ 分。

最后一个优化是可以直接试除 $N$ 的质因子，对于质因子 $p$，如果 $\frac Np$ 依然是 $n$ 的倍数就把 $N$ 除去 $p$，这样最后一部分复杂度 $O(\log n)$，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int collisions(vector<int>q);
bool chk(int l,int r){
	int y=sqrt(r-l)+1;
	vector<int>q;
	for(int i=1;i<=y;i++)q.push_back(i);
	for(int i=y+l;i<=r;i+=y)q.push_back(i);
	q.push_back(r+1);
	return collisions(q);
}
signed hack(){
	int l=5e8+1,r=1e9;
	while(l<r){
		int mid=l+r>>1;
		if(chk(l,mid))r=mid;
		else l=mid+1;
	}
	for(int i=2;i*i<=l;i++){
		if(l%i==0){
			while(l%i==0)l/=i;
			while(r%i==0&&r!=i&&collisions({1,r/i+1}))r/=i;
		}
	}
	while(l>1&&r%l==0&&r!=l&&collisions({1,r/l+1}))r/=l;
	return r;
}
```

---

## 作者：紊莫 (赞：1)

观察一：可以询问 $(1,n+1)$ 来确定 $n$ 是否为答案的倍数，也就是说如果知道了答案的倍数，可以枚举其因数知道答案。

观察二：若询问集合 $S$，有冲突，则说明其中存在两个数，其差为答案的倍数。

于是考虑确定这个答案的倍数，我们可以将范围限定在 $(5\times 10^8,10^9]$ 之间，这是因为小于等于 $5\times 10^8$ 的倍数可以乘二得到更大的倍数。

采用分治的方法，每次将这个区间缩小一半，那么问题在于如何构造一个序列使得其两两作差包含了 $[l,r]$ 内的所有数字。

参考 BSGS 的思想，设 $S=\{1, 2, ..., a\}$，$T=\{l + a,l+2a,...,l+ba\}$，满足 $l+ba\ge r$，那么询问 $S\cup T$ 即可，要 $|S\cup T|$ 最小，在 $a=\sqrt{r-l+1}$ 的时候取到，注意可能的边界问题。

确定了一个数的倍数后，不应该直接枚举所有因子，而是二分每个质因子的次幂，这样在 $n\le 10^9$ 时最坏需要 $24$ 次操作。

粗略地分析一下操作次数，设当前余下的序列长度为 $m$，则需要 $2\sqrt m$ 次操作确定下来。

然后每次序列长度折半，也就是总次数是 $4\sqrt{\frac{n}{2}}$ 左右，并不带 $\log$，可以通过。

---

## 作者：_Cheems (赞：1)

介绍一下官解做法。

题意：有 $n$ 个桶，你想知道 $n$ 是多少。为此你可以进行若干次询问，每次你给出 $m$ 个正整数，交互库依次将 $x_i$ 插入第 $x_i\bmod n$ 个桶中，每次插入产生原有元素个数的贡献，最后返回总贡献。询问互相独立。$n\le 10^9$，要求 $\sum m\le 110000$。

首先观察到若贡献为正，说明必然存在两个元素满足它们的差为 $n$ 的倍数。那么不难对问题拆解为：先得到询问 $\{1,x+1\}$ 贡献为正，则 $n\mid x$；然后依次确定 $n$ 的每个质因子次幂。

第二部分是容易的，每次去掉一个质因子查询是否仍为倍数即可。步数是 $2\log n$ 几乎忽略不计。着重考虑第一部分。

我们尝试集合分治，每次划分出一个存在冲突的小集合。

开始前，如何构造覆盖所有元素的集合呢？类似 BSGS，记 $B$ 为块长，记 $S_1=\{1\dots B\},S_2=\{B,2B,3B\dots \}$，$S_1\cup S_2$ 显然覆盖所有数。不过只需考虑 $(5\times  10^8,10^9]$ 范围内的倍数（不在范围就不断翻倍），所以可令 $S_2=\{5\times 10^8+1+B,5\times 10^8+1+2B\dots \}$。

注意 $S_1,S_2$ **之间**一定有冲突，也就是两端分别在 $S_1,S_2$。

现在做划分，将 $S_1$ 分为两部分 $L,R$。判定 $L,S_2$ 之间是否有冲突，有则 $S_1\gets L$；反之 $R$ 与 $S_2$ 之间必然存在冲突，令 $S_1\gets R$。

考虑判定。首先对 $L\cup S_2$ 查询，若为零不可能存在冲突。冲突还可能产生在 $L,S_2$ 内部，不过 $L$ 内部产生冲突意味着所有桶被 $L$ 元素塞满，那么肯定存在 $L,S_2$ 之间的冲突，所以不用管。

不妨假设冲突都在 $S_2$ 内部，注意到 $S_2$ 是一个公差为 $B$ 的等差数列，那么容易列出其内部的冲突总数的式子为 $G(\frac {lcm(n,B)}{B},|S_2|)$。其中 $G(x,y)$ 指依次插入 $1\dots y$ 到 $x$ 个桶的总贡献，是可以 $O(1)$ 计算的。同时 $G$ 固定 $y$ 具有单调性，那么二分 $\frac {lcm(n,B)}B=k$ 即可。得到 $lcm(n,B)=kB$，查询 $\{1,kB+1\}$ 是否真的是 $n$ 的倍数，是那么我们的任务已经完成 $kB$ 就是所求，否则产生矛盾说明 $L,S_2$ 之间必然有冲突。

同理可对 $S_2$ 进行划分。

减少步数肯定 $S_1$ 砍一刀、$S_2$ 砍一刀，做一轮就是 $\frac {|S_1|}2+|S_2|+\frac {|S_1|}{2}+\frac {|S_2|}2=|S_1|+\frac 32 |S_2|$。我们取 $B=27000$ 上面的式子比较平衡，分治的总操作数大概是 $109554‬$。可以接受。

后记：事实上直接二分答案然后大步小步就是对的，每次只检查一个区间代价是根号区间大小，每次区间大小还会折半，总次数大概 $108000$，从任何方面完虐官解。
#### 代码

```cpp
#include "hack.h"
#include<bits/stdc++.h>
using namespace std;

#define LL long long
const int B = 27000;
int n;

long long collisions(std::vector<long long> x);
LL G(int x, int y){
    int h = y / x;
    return 1ll * (h + 1) * h / 2 * (y % x) + 1ll * h * (h - 1) / 2 * (x - y % x);
}
int getF(int S2, LL cnt){
    int L = 1, R = 1e9 + 5, mid;
    while(L + 1 < R){
        mid = L + R >> 1;
        if(G(mid, S2) >= cnt) L = mid;
        else R = mid;
    }
    if(G(L, S2) == cnt) return 1ll * L * B;
    return -1;
}
int hack(){
    vector<LL> S1, S2;
    for(int i = 1; i <= B; ++i) S1.push_back(i);
    int x = 5e8 + 1 + B;
    while(x <= 1e9) {S2.push_back(x); x += B;}     
    S2.push_back(x);
    
    int len = -1;
    vector<LL> SS1, SS2; 
    while(S1.size() > 1 || S2.size() > 1){
        SS1 = S1, SS2 = S2;
        if(S1.size() > 1){
            vector<LL> Lc, L, R;
            for(int i = 0; i < S1.size() / 2; ++i) L.push_back(S1[i]);
            for(int i = S1.size() / 2; i < S1.size(); ++i) R.push_back(S1[i]);
            Lc = L;
            for(auto i : S2) Lc.push_back(i);

            LL Lcnt = collisions(Lc);
            if(Lcnt == 0) S1 = R;
            else{
                int res = getF(S2.size(), Lcnt);
                if(res != -1)
                    if(collisions({1, res + 1}) > 0) {len = res; break;}
                S1 = L;
            }
        }
        if(S2.size() > 1){
            vector<LL> Lc2, L2, R2;
            for(int i = 0; i < S2.size() / 2; ++i) L2.push_back(S2[i]);
            for(int i = S2.size() / 2; i < S2.size(); ++i) R2.push_back(S2[i]);
            Lc2 = L2;
            for(auto i : S1) Lc2.push_back(i);

            LL Lcnt2 = collisions(Lc2);
            if(Lcnt2 == 0) S2 = R2;
            else{ 
                int res2 = getF(L2.size(), Lcnt2);
                if(res2 != -1)
                    if(collisions({1, res2 + 1}) > 0) {len = res2; break;}
                S2 = L2;
            }
        }
    }
    if(len == -1) len = S2[0] - S1[0];
    if(collisions({1, 1 + len}) == 0){
        exit(0);
    }

    vector<int> pc;
    int ljs = len;
    for(int i = 2; i * i <= ljs; ++i)
        if(ljs % i == 0){
            while(ljs % i == 0) ljs /= i;
            pc.push_back(i);
        }
    if(ljs > 1) pc.push_back(ljs);

    for(auto i : pc){
        while(len % i == 0){
            if(collisions({1, len / i + 1}) > 0) len /= i;
            else break;
        }
    }
    return len; 
}
```

---

## 作者：ax_by_c (赞：0)

考场上两个关键点一个都没想对，成功获得 52 分。/dk

大致思路肯定是构造一个得数非零的集合然后往下分治，分到两个数后就得到了答案的一个倍数，试除即可得出答案。

~~然后考场上同时使用了生日悖论和分三块。~~

实际上有确定的得数非零集合：类似 BSGS，取 $A=\{1,2,\dots,X\},B=\{X+1,2X+1,\dots,10^9+1\}$，则 $S=\{x\mid x=q-p,p\in A,q\in B\}$ 中包含了 $[1,10^9]$ 的所有数，因此得数非零。

卡个常：由于只需要关心答案的倍数，所以只需构造 $[5\times 10^8+1,10^9]$ 中的数，变为 $A=\{1,2,\dots,X\},B=\{5\times 10^8+1+X,2X+1,\dots,10^9+1\}$。

然后就构造好了，考虑分治。先要保证 $A,B$ 内部得数为零，注意到它们都是等差的，可以用类似的构造方法构造集合进行判断，如果得数非零规约到新构造的集合即可。

然后考虑每次将较大集合分两块并判断哪一块和另一集合组合后得数非零，共需 $\frac{\lvert A\rvert}{2}+\lvert B\rvert(\lvert A\rvert\ge\lvert B\rvert)$ 的代价。

这个东西极端情况就是轮流做，也就是用 $\lvert A\rvert+\frac{3\lvert B\rvert}{2}$ 的代价各自减半，总代价即为 $2\lvert A\rvert+3\lvert B\rvert$。

平衡一下，取 $X=27306$ 可以通过。

```cpp
#include<bits/stdc++.h>
int hack();
long long collisions(std::vector<long long> x);
#define rep(i,l,r) for(int qwp=(l),pwq=(r),i=qwp;i<=pwq;i++)
#define per(i,r,l) for(int qwp=(l),pwq=(r);i=pwq;i>=qwp;i--)
#define repll(i,l,r) for(ll qwp=(l),pwq=(r),i=qwp;i<=pwq;i++)
#define perll(i,r,l) for(ll qwp=(l),pwq=(r);i=pwq;i>=qwp;i--)
#define pb push_back
#define clr clear
using namespace std;
typedef long long ll;
const ll L=5e8+1;
const ll R=1e9;
const ll X=27306;
vector<ll>A,B,C,P,Q;
void Init(){
    A.clr(),B.clr();
    repll(i,1,X)A.pb(i);
    B.pb(L+X);
    while(B.back()<=R)B.pb(B.back()+X);
}
bool check(vector<ll> a){
    if((int)a.size()<=1)return 0;
    ll L=(a.size()-1)/2+1,R=a.size()-1,X=sqrt(R-L+1),d=a[1]-a[0];
    P.clr(),Q.clr();
    repll(i,1,X)P.pb(i);
    Q.pb(L+X);
    while(Q.back()<=R)Q.pb(Q.back()+X);
    ll t=Q.back();
    Q.pop_back(),Q.pb(min(t,R+1));
    C.clr();
    for(auto it:P)C.pb(it*d);
    for(auto it:Q)C.pb(it*d);
    if(collisions(C)){
        A.clr(),B.clr();
        for(auto it:P)A.pb(it*d);
        for(auto it:Q)B.pb(it*d);
        return 1;
    }
    return 0;
}
int hack(){
    Init();
    while(check(A)||check(B));
    while(A.size()>1||B.size()>1){
        if(A.size()<B.size())swap(A,B);
        P.clr();
        rep(i,0,A.size()/2-1)P.pb(A[i]);
        C.clr();
        for(auto it:P)C.pb(it);
        for(auto it:B)C.pb(it);
        if(collisions(C))A=P;
        else{
            P.clr();
            rep(i,A.size()/2,A.size()-1)P.pb(A[i]);
            A=P;
        }
    }
    ll x=abs(A[0]-B[0]),res=x;
    for(ll i=2;i*i<=x;i++){
        if(x%i==0){
            bool F=1;
            while(x%i==0){
                C.clr(),C.pb(1),C.pb(res/i+1);
                if(F&&collisions(C))res/=i;
                else F=0;
                x/=i;
            }
        }
    }
    if(x!=1){
        C.clr(),C.pb(1),C.pb(res/x+1);
        if(collisions(C))res/=x;
    }
    return res;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

来点简单做法。

考虑二分是显然的。下面我们记 $S[l,r]$ 为 $[l,r]$ 区间内所有数的因数组成的集合，例如 $S[4,5]=\{1,2,4,5\}$。

考虑如何判定 $n$ 是否属于 $S[l,r]$，我们考虑 BSGS 的问。记 $B=\sqrt{r-l+1}$。我们问 $\{1,2,\cdots,B,l+B,l+2B,\cdots l+kB,r+1\}$。其中 $l+kB\leq r$ 且 $l+(k+1)B>r$。

这样子该集合内两两元素差所构成的集合也就恰好覆盖了 $[l,r]$ 内所有数。我们询问一遍该集合自然就得到了 $n$ 是否属于 $S[l,r]$ 的判定。

如此二分下去，自然就可以在 $O(\sqrt{n})$ 的代价内得到答案（这是因为 $\sum(\sqrt{\dfrac{n}{2^i}}$) 是 $O(\sqrt{n})$ 量级的）。

实测出来直接实现上面的做法需要 $152697$ 次询问，可以获得 $78.09$ 分。

考虑卡常数，第一次我们不问 $[1,10^9]$，而是问 $[5\times10^8,10^9]$，然后我们就能得到一个 $x$，满足 $n|x$。我们再花 $O(d(x))$ 的代价得到真实 $n$ 即可。

注意最后的 $O(d(x))$ 部分要精细实现一下，随时筛掉当前已经可以判定不合法的答案，不然你会获得 $99.37$ 分。

---


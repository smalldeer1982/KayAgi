# [NOI2012] 骑行川藏

## 题目描述

蛋蛋非常热衷于挑战自我，今年暑假他准备沿川藏线骑着自行车从成都前往拉萨。

川藏线的沿途有着非常美丽的风景，但在这一路上也有着很多的艰难险阻，路况变化多端，而蛋蛋的体力十分有限,因此在每天的骑行前设定好目的地，同时合理分配好自己的体力是一件非常重要的事情。

由于蛋蛋装备了一辆非常好的自行车，因此在骑行过程中可以认为他仅在克服风阻做功（不受自行车本身摩擦力以及自行车与地面的摩擦力影响）。

某一天他打算骑 $n$ 段路，每一段内的路况可视为相同：对于第 $i$ 段路,我们给出有关这段路况的 $3$ 个参数 $s_i,k_i,v_i'$，其中 $s_i$ 表示这段路的长度，$k_i$ 表示这段路的风阻系数，$v_i'$ 表示这段路上的风速（$v_i'\gt 0$ 表示在这段路上他遇到了顺风，反之则意味着他将受逆风影响）。

若某一时刻在这段路上骑车速度为 $v$，则他受到的风阻
大小为 $F=k_i(v-v_i')^2$（这样若在长度为 $s$ 的路程内保持骑行速度 $v$ 不变,则他消耗能量（做功）$E=k_i(v-v_i')^2s$ ）。

设蛋蛋在这天开始时的体能值是 $E_U$，请帮助他设计一种行车方案,使他在有限的体力内用最短的时间到达目的地。请告诉他最短的时间 $T$ 是多少。

## 说明/提示

### 样例说明

一种可能的方案是：蛋蛋在三段路上都采用匀速骑行的方式,其速度依次为 $5.12939919,8.03515481,6.17837967$。

### 评分方法

本题没有部分分,你程序的输出只有和标准答案的差距不超过 $10^{-6}$ 时，才能获得该测试点的满分，否则不得分。

### 数据规模与约定

对于 $10\%$  的数据，$n=1$。

对于 $40\%$  的数据，$n\le2$。

对于 $60\%$  的数据，$n\le100$。

对于 $80\%$  的数据，$n\le 1000$。

对于 $100\%$  的数据，$n\le 10^4$，$E_U\le 10^8$，$s_i\in[0,10^5]$，$k_i\in(0,15]$，$v_i'\in(-100,100)$。

数据保证最终的答案不会超过 $10^5$。

### 提示

必然存在一种最优的体力方案满足：蛋蛋在每段路上都采用匀速骑行的方式。

## 样例 #1

### 输入

```
3 10000
10000 10 5
20000 15 8
50000 5 6```

### 输出

```
12531.34496464```

# 题解

## 作者：RabbitHu (赞：71)

（本题解同步发布于 http://www.cnblogs.com/RabbitHu/p/9019762.html, 欢迎交流）

楼上这堆题解都太难了！作为一个数学不及格选手！我来提供一个能看的题解！

预备知识只有高中数学的【导数】。不用什么偏导数/拉格朗日乘子法之类的我看不懂的东西( •̀∀•́ )！

如果你不知道什么是导数，可以找本高中数学选修2-2来看一下！看第一章第1、2节就好啦。传送门：[选修2-2](http://jfpdf.yousi.com/160424030303585634.pdf)

---

感性理解一下这道题：

一开始，我们可以给所有路段随便分配一个速度。

接下来，我们需要在一些路段上**耗费一定能量**用来提速，以此**缩短一定时间**。不同路段上，花费单位能量能缩短的时间（简称“**性价比**”）是不同的，所以如果我们要模拟这个过程，一定是每时每刻都在**当前性价比最高**的路段上花费能量，直到能量花完为止。（似乎……也可以花费负的能量，增加某路段所需时间，然后把能量用到别的地方去。）

注意到一个性质：随着花费能量增加，性价比会越来越低。

这样的话，只要按照上面这种贪心策略，时时刻刻在性价比最高的路段花费能量（并使它的性价比降低），最后达到最优解时，**各路段性价比会一样**。

暴力模拟似乎是写不出来的，考虑更正常的做法。

这个性价比是什么呢？如果我们对每段路画出一个$t-E$函数图象，表示该路段**需要的时间$t$**与**花费的能量$E$**的函数关系，那么花费一定能量$e$之后的“性价比”是什么呢？就是函数图像上横坐标为$e$处切线的斜率——导数。

那么最优解就满足——**各路段导数一样！**

同时，这个公共导数（是负的）绝对值越小（性价比越低），所需能量越多，总时间越小。

于是二分这个导数，求出每段速度，以此求出所需能量，和手里的总能量比较一下，就可以二分得到答案了！

---

以上是思路。现在开始数学。

要求出每段导数关于$v$的关系。

对于一段路来说（方便起见，把$k$乘上$s$作为新的$k$，就可以少写一个字母了2333）：

$$E = k(v - v')^2$$
$$t = \frac{s}{v}$$

那么

$\frac{dt}{dE}$

$=\frac{dt}{dv} / \frac{dE}{dv} $

$= -\frac{s}{v^2} / 2k(v - v')$

$= -\frac{s}{2kv^2(v-v')}$

然后二分公共导数$x$，对于每段路解方程$-\frac{s}{2kv^2(v-v')} = x$（可二分）得到$v$，进而求出需要的能量。

---

代码：

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#define enter putchar('\n')
#define space putchar(' ')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
        if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
        x = x * 10 + c - '0';
    if(op == 1) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 10005, INF = 0x3f3f3f3f;
int n;
double E, s[N], k[N], u[N];

double getv(double x, int i){
    double l = max(u[i], double(0)), r = 100005, mid;
    int cnt = 60;
    while(cnt--){
        mid = (l + r) / 2;
        if(2 * k[i] * x * mid * mid * (mid - u[i]) > -s[i]) l = mid;
        else r = mid;
    }
    mid = (l + r) / 2;
    return (l + r) / 2;
}
double calc(double x){
    double sum = 0;
    for(int i = 1; i <= n; i++){
        double v = getv(x, i);
        sum += k[i] * (v - u[i]) * (v - u[i]);
    }
    return sum;
}

int main(){

    scanf("%d%lf", &n, &E);
    for(int i = 1; i <= n; i++)
        scanf("%lf%lf%lf", &s[i], &k[i], &u[i]), k[i] *= s[i];
    double l = -INF, r = 0, mid;
    int cnt = 100;
    while(cnt--){
        mid = (l + r) / 2;
        if(calc(mid) <= E) l = mid;
        else r = mid;
    }
    mid = (l + r) / 2;
    double ans = 0;
    for(int i = 1; i <= n; i++)
        ans += s[i] / getv(mid, i);
    printf("%.10lf\n", ans);

    return 0;
}
```

---

## 作者：Karry5307 (赞：34)

### 题意

给定 $n$ 个路段，每个路段用三个实数 $s_i,k_i,v^\prime_i$ 描述，最小化

$$F(v_1,\cdots v_n)=\sum\limits_{i=1}^{n}\frac{s_i}{v_i}$$

其中 $v_1,\cdots v_n$ 均为非负实数而且需要满足

$$\varphi(v_1,\cdots,v_n)=\sum\limits_{i=0}^{n}k_i(v_i-v^{\prime}_i)^2s_i-E_U=0$$

$\texttt{Data Range:}1\leq n\leq 1000$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13860407.html)

拉格朗日乘子法。

我们来形象的讲一下这个东西到底是什么，你可能需要一些关于多元函数微积分的知识。

假设我们现在有一个二元函数 $F(x,y)=x^2+y^2$，需要求这个东西的最小值。

如果没有限制的话，最小值就是 $0$。但是我如果需要让 $x,y$ 满足 $x^2y=3$ 的话呢？

一个很显然的想法就是去逐一枚举一个最小值 $r$，然后看这个 $r$ 满不满足条件。于是我们只需要看看 $x^2y=3$ 和 $x^2+y^2=r$ 是否相交。

注意到后者的图像是一个圆，从小到大枚举 $r$ 的过程可以看做是圆的半径逐渐扩大。如果扩大到某个 $r$ 刚好与 $x^2y=3$ 相交了的话就可以取这个 $r$ 作为最小值。

这里有一个 [demo](https://www.desmos.com/calculator/2usqo7bbqu)，拖动 $r_0$ 的滑动条相当于是圆的半径逐渐扩大。注意到随着半径的扩大，圆与曲线的位置关系是先相离再相切最后相交。所以说，**在极值点，圆与曲线相切**。

注意到这些圆是可以看做 $F(x,y)=x^2+y^2$ 的等高线的。注意到 $\nabla F$（也就是梯度）是等高线的法线。同时 另一个函数 $G(x,y)=x^2y$ 的梯度向量 $\nabla G$ 也会垂直于 $x^2y=3$ 这条等高线。

因为梯度向量是等高线的法线，所以**梯度与等高线的切线垂直**。结合两个加粗的条件我们可以知道**在相切点，圆的梯度向量和曲线的梯度向量平行**。这个时候我们可以列方程了：

$$\nabla F=\lambda\nabla G$$

也就是说

$$\begin{cases}\frac{\partial F}{\partial x}=\lambda\frac{\partial G}{\partial x}\\\frac{\partial F}{\partial y}=\lambda\frac{\partial G}{\partial y}\\x^2y=3\end{cases}$$

解出来即可。

这个时候我们可以考虑构造约束函数 $\varphi(x,y)=x^2y-3$。由于 $3$ 是常数在对任何一个变量求偏导数的时候都会消去所以不会对上面两个方程产生影响。

由于偏导数的可加性，我们增加一个新的变量 $\lambda$ 并且将原来的函数写成这样：（也就是将等式的右边移到了左边）

$$F(x,y,\lambda)=F(x,y)+\lambda\varphi(x,y)$$

这个时候很容易看出对 $F(x,y,\lambda)$ 求三个偏导数得到的方程与上面的方程组是一样的。

对于这个题目来说，构造函数

$$F(v_1,\cdots,v_n,\lambda)=F(v_1,\cdots,v_n)+\lambda\varphi(v_1,\cdots,v_n)=\sum\limits_{i=1}^{n}\frac{s_i}{v_i}+\lambda\left(\sum\limits_{i=0}^{n}k_i(v_i-v^{\prime}_i)^2s_i-E_U\right)$$

根据对称性我们可以很方便的求出这个东西对 $v_i$ 和 $\lambda$ 的偏导数：

$$\frac{\partial F}{\partial v_i}=2\lambda k_i(v_i-v^\prime_i)s_i-\frac{s_i}{v_i^2}$$

$$\frac{\partial F}{\partial \lambda}=\sum\limits_{i=0}^{n}k_i(v_i-v^\prime_i)^2s_i-E_U$$

按照上面讲的东西，这些偏导数都应该等于 $0$ 的，所以得到两个方程：

$$2\lambda k_iv_i^2(v_i-v^\prime_i)=1$$

$$\sum k_i(v_i-v^{\prime})^2s_i=E_U$$

将第一个方程移项得到

$$v_i^2(v_i-v^\prime_i)=\frac{1}{2\lambda k_i}$$

左边那个东西当 $v_i\in [0,+\infty)$ 的时候通过对导数进行分析可以看出是单调递增的。

当 $\lambda$ 固定的时候，$v_i\uparrow$ 则等式左边 $\uparrow$。当 $\lambda\uparrow$ 时，因为等式右边 $\downarrow$，所以 $v_i\downarrow$。因为 $v_i>v^\prime_i$，所以第二个等式的左边整体是 $\downarrow$ 的。

于是我们可以考虑二分 $\lambda$，然后二分解出 $v_i$ 利用第二个等式再 check 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef long double db;
const ll MAXN=2e5+51;
const db eps=1e-12;
ll n;
db eu,l,r,mid,res;
db s[MAXN],kk[MAXN],v[MAXN],vl[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
#define sqr(x) (x)*(x)
inline db calcDeriv(db lambda,db vel,ll x)
{
	return 2.0*lambda*kk[x]*sqr(vel)*(vel-v[x]);
}
inline ll check(db lambda)
{
	db e=0,l,r,mid;
	for(register int i=1;i<=n;i++)
	{
		l=max(v[i],0.0L),r=100000;
		while(l+eps<=r)
		{
			mid=(l+r)/2.0;
			calcDeriv(lambda,mid,i)<=1?l=mid:r=mid;
		}
		vl[i]=l,e+=kk[i]*sqr(vl[i]-v[i])*s[i];
	}
	return e<=eu;
}
int main()
{
	n=read(),scanf("%Lf",&eu),l=0,r=100000;
	for(register int i=1;i<=n;i++)
	{
		scanf("%Lf%Lf%Lf",&s[i],&kk[i],&v[i]);
	}
	while(l+eps<=r)
	{
		mid=(l+r)/2.0;
		check(mid)?r=mid:l=mid;
	}
	for(register int i=1;i<=n;i++)
	{
		res+=s[i]/vl[i];
	}
	printf("%.9Lf\n",res);
}
```

---

## 作者：lhm_ (赞：13)

题意为在满足$\sum\limits_{i=1}^nk_i(v_i-v_i^\prime)^2s_i\leqslant E_U$的条件下最小化$\sum\limits_{i=1}^n\frac{s_i}{v_i}$

先考虑贪心，因为最小化$\sum\limits_{i=1}^n\frac{s_i}{v_i}$，所以$\sum\limits_{i=1}^nk_i(v_i-v_i^\prime)^2s_i=E_U$时为最优情况。

发现是一个有约束的极值问题，考虑用拉格朗日乘数法来解决。

设$f(v)=\sum\limits_{i=1}^n\frac{s_i}{v_i}$，$φ(v)=\sum\limits_{i=1}^nk_i(v_i-v_i^\prime)^2s_i-E_U$

设拉格朗日函数为$L(v,λ)=f(v)+λφ(v)$

代入得$L(v,λ)=\sum\limits_{i=1}^n\frac{s_i}{v_i}+λ[\sum\limits_{i=1}^nk_i(v_i-v_i^\prime)^2s_i-E_U]$

根据拉格朗日乘数法得，当拉格朗日函数$L$梯度为$0$时，$f(v)$最优

$$\begin{cases}\nabla_{v_1}L(v,λ)=0\\\nabla_{v_2}L(v,λ)=0\\......\\\nabla_{v_n}L(v,λ)=0\\\nabla_λL(v,λ)=0\end{cases}$$

求偏导后可得（这里将有关$v$的写成一个式子了）

$$\begin{cases}\nabla_vL(v,λ)=2λk_i(v_i-v_i^\prime)s_i-\frac{s_i}{v_i^2}=0\\\nabla_λL(v,λ)=\sum\limits_{i=1}^nk_i(v_i-v_i^\prime)^2s_i-E_U=0\end{cases}$$

进一步化简后得

$$\begin{cases}2λk_iv_i^2(v_i-v_i^\prime)=1\ (1)\\\sum\limits_{i=1}^nk_i(v_i-v_i^\prime)^2s_i=E_U\ (2)\end{cases}$$

那么将上面的方程组解出来，即为我们要求的答案。

考虑到在$(1)$式中$v_i$必须大于等于$v_i^\prime$，所以为保证式子成立$λ$必须大于$0$，同时发现$(1)$式左边关于$v_i$单调递增，所以我们二分求出每一个$v_i$，再代入$(1)$式来检验。

但发现$λ$的值也不确定，于是要在二分$v_i$的外层再套上一层$λ$的二分，这里代入$(2)$式来检验。

实现细节看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 10010
#define eps 1e-12
using namespace std;
template<typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag)x=-x;
}
int n;
double E,ans;
double s[maxn],k[maxn],v[maxn],u[maxn];
double calc(double x)
{
    return x*x;
}
bool judge(double p,double v,double k,double u)
{
    return 2*p*k*calc(v)*(v-u)<=1;
}
bool check(double p)
{
    double e=0;
    for(int i=1;i<=n;++i)
    {
        double l=max(u[i],(double)0),r=1e5,ans;
        while(l+eps<=r)
        {
            double mid=(l+r)/2.0;
            if(judge(p,mid,k[i],u[i])) ans=l=mid;
            else r=mid;
        }
        v[i]=ans;
        e+=k[i]*calc(v[i]-u[i])*s[i];
    }
    return e<=E;
}
int main()
{
	read(n);
    scanf("%lf",&E);
    for(int i=1;i<=n;++i)
        scanf("%lf%lf%lf",&s[i],&k[i],&u[i]);
    double l=0,r=1e5;
    while(l+eps<=r)
    {
        double mid=(l+r)/2.0;
        if(check(mid)) r=mid;
        else l=mid;
    }
    for(int i=1;i<=n;++i) ans+=s[i]/v[i];
    printf("%.8lf",ans);
	return 0;
}
```

---

## 作者：huyufeifei (赞：10)

题解全是拉格朗日乘数法......搞不倒搞不倒，我们来简单粗暴一点的。  

# 模拟退火！  

这个问题可以转化为能量的分配问题。一共有E的能量，我们要给每条路分配若干能量，使得它们合起来的总时间最短。

如果风速为负的话，想要前进就必须要有一个能量下限。我们把这些能量提出来，剩下的就是可自由分配的能量了。

先给每条路平均分配自由能量，作为初始解。然后每次通过这样的方式产生出一个新解：

+ 随机得到两条路a和b。
+ 随机一个在(0 , a目前自由能量)之间的能量值，把这些能量给b

这里我们随机出来的能量值要随着温度降低而降低，于是我采用了这个公式：

$ deltaE = min(nowE_{a},c * nowT) * Rand(0,1) $

nowT是指当前温度，nowE是目前自由能量，Rand(0,1)是一个0~1之间的随机实数，c是一个自己决定的参数。

然后经过一波玄学调参，疯狂尝试，终于找到了一组精度较高的参数，过掉了此题......

代码：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>

const int N = 10010, INF = 0x3f3f3f3f;

double k[N], s[N], vv[N], E;
int n;

namespace n1 {
    inline void solve() {
        double v = vv[1] + sqrt(E / s[1] / k[1]);
        printf("%.10f\n", s[1] / v);
        return;
    }
}

namespace n2 {

    inline double cal(double v) {
        double ans = s[1] / v;
        double delta = k[1] * s[1] * (vv[1] - v) * (vv[1] - v);
        double v2 = vv[2] + sqrt((E - delta) / s[2] / k[2]);
        if(v2 < 0) return 1e14;
        return ans + s[2] / v2;
    }

    inline void solve() {

        double l = 0, r = vv[1] + sqrt(E / s[1] / k[1]);
        for(int i = 1; i <= 100; i++) {
            double mid = (l + r) / 2;
            //printf("l = %.10f r = %.10f \n", l, r);
            double ml = mid - (r - l) / 6, mr = mid + (r - l) / 6;
            double vl = cal(ml), vr = cal(mr);
            if(vl > vr) {
                l = ml;　　
            }
            else {
                r = mr;　
            }
        }
        printf("%.10f\n",　cal(r));
        return;
    }
}

namespace Fire {
    const double eps = 1e-13;
    double T = 1, dT = 0.999992;
    double nowE[N], temp[N], lm[N];
    int test[N];　

    inline int rd(int　l, int　r) {
        return rand() % (r - l + 1) + l;
    }

    inline double Rand() {
        return 1.0 * rand() / RAND_MAX;
    }

    inline double calv(int i, double e) {
        return vv[i] + sqrt(e / k[i] / s[i]);
    }
　
    inline double calt(int i, double e) {
        return s[i] / (vv[i] + sqrt(e / k[i] / s[i]));
    }
　
    inline double init() {
        for(int　i = 1; i <= n; i++) {
            if(vv[i] < -eps) {
                lm[i] = k[i] * s[i] * vv[i] * vv[i];
                E -= lm[i];
            }
        }
        double dt = E / n, ans = 0;
        for(int i = 1; i <= n; i++) {
            nowE[i] = dt;
            ans += calt(i, lm[i] + nowE[i]);
        }
        return ans;
    }

    inline void solve() {
        double ans, fin = 1e14;
        srand(69);
        for(int A = 1; A <= 1; A++) {
            ans = init();
            fin = std::min(ans, fin);
            while(T > eps) {
                /// Random a new solution
                int a = rd(1, n), b = rd(1, n);
                while(a == b) {
                    a = rd(1, n), b = rd(1, n);
                }
                double deltaE = std::min((long double)nowE[a], (long double)T * 1e8) * Rand();　
                temp[a] = nowE[a] - deltaE;
                temp[b] = nowE[b] + deltaE;

                double New = ans - calt(a, lm[a] + nowE[a]) - calt(b, lm[b] + nowE[b])
                                 + calt(a, lm[a] + temp[a]) + calt(b, lm[b] + temp[b]);

                fin = std::min(fin, New);
                if(New < ans || Rand() < exp((ans - New) / T)) {
                    ans = New;
                    nowE[a] = temp[a];
                    nowE[b] = temp[b];
                }
                T = T * dT;
            }
        }
        printf("%.10f\n", fin);
        return;
    }
}

int main() {
　
    scanf("%d%lf",　&n,　&E);
    for(int i = 1; i <= n; i++) {
        scanf("%lf%lf%lf", &s[i], &k[i], &vv[i]);
    }

    if(n == 1) {
        n1::solve();
        return 0;
    }

    if(n == 2) {
        n2::solve();
        return 0;
    }

    Fire::solve();
    return　0;
}

```


---

## 作者：2021cjx (赞：6)

## 0x01 分析题目

做题首先要排除文中的冗余信息，用最短的语言描述一道题。

对于这道题，我们可以在阅读后得到这样的三条信息：

> $E_i = k_i(v_i-v_i^{'})^2s_i$

> $\sum_{i=1}^{n}E_i \leq E$

> 要求 $t$ 尽可能小。

## 0x02 做法的推导

初步分析完后，我们就要着手从初始条件开始推答案。

在两条初始信息中，信息 3 是和答案有关的,信息 1、2 是约束条件，所以我们的思路自然转移到如何将约束条件与答案关联到一起。

使用~~脑子~~思考可以得到一个结论：

> 每段路上消耗的能量（做的功）$E_i$ 越大，消耗的时间 $t_i$ 越小。

上面这句话换种方式表达，就有了：

> 我们可以在某段路上增加能量以缩短时间。（推论 1）

有了推论 1，我们就将约束条件与答案关联到一起了。

但又由推论 1 引出了一个新的问题：**在哪条路上增加能量呢？**

由于增加某条路的能量不会干扰到另一条路，所以我们可以贪心的想：

> 把能量加到价值（或说性价比）最高的路上去。

那对于一条路来说，此刻增加能量的价值又如何体现呢？

显然是增加的时间。

于是我们很容易想到：若时间是关于能量的函数，那么函数在 $E_i$ 处的切线的斜率，也就是导数，就是在此条路增加能量的价值（性价比）。

推论 1 告诉我们：$t$ 随 $E$ 的增大而减小。

由此可以知道：价值（或性价比）只会越来越小。

我们总会将能量加到性价比大的路段上去，不断如此操作，我们可以想象最后所有路的价值（或性价比）会是一个相同值！

于是我们可以开始推式子了！

$$
\frac{dt}{dE} = x
$$

$x$ 为最后的公共导数。

因为 $E_i = k_i(v_i-v_i^{'})^2s_i$，且 $t$ 也可以表达为关于 $v$ 的函数 $t=\frac{s}{v}$。

所以：

$$
\frac{dt}{dE} = \frac{dt}{dv}\frac{dv}{dE} = \frac{dt}{dv} / \frac{dE}{dv} = x
$$

$$
\frac{dt}{dv} = -\frac{s}{v^2} , \frac{dE}{dv} = 2ks(v-v^{'})
$$

所以：

$$
-\frac{s}{2ksv^2(v-v^{'})} = x
$$

如果我们知道了公共导数 $x$，就可以解出每段路的 $v$ 值（懒得解方程？直接二分 $v$ 不就行了）。

知道了每段的 $v$ 值，就可以检验当前的 $x$ 是否可行。

于是，$x$ 也可以二分了。

最后看看代码，就很容易明白了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
double s[10005], k[10005], u[10005];
double e;
double solve(double x, int i) { //公共导数x与当前路段i
	double l = 0, r = 100005, v;//题目保证v<=100005
	int batch = 60;//浮点数二分的批次
	while(batch--) {
		v = (l + r) / 2;
		if(2 * k[i] * s[i] * x * v * v * (v - u[i]) > -s[i]) l = v;//刚推导出来的式子稍加变形
		else r = v;
	}
	v = (l + r) / 2;//最后得到结果
	return v;
}
double work(double x) {//二分出的公共导数得到的能量总值
	double sum = 0;
	for(int i = 1; i <= n; i++) {
		double v = solve(x, i);
		sum += k[i] * s[i] * (v - u[i]) * (v - u[i]);
	}
	return sum;
}
signed main() {
	cin>>n>>e;
	for(int i = 1; i <= n; i++) {
		cin>>s[i]>>k[i]>>u[i];
	}
	double l = -0x3f3f3f, r = 0, dc;//注意：函数t呈下降趋势，导数显然为负
	int batch = 100;
	while(batch--) 
	{
		dc = (l + r) / 2;
		if(work(dc) <= e) l = dc;
		else r = dc;
	}
	dc = (l + r) / 2;
	double ans = 0;
	for(int i = 1; i <= n; i++)
		ans += s[i] / solve(dc, i);
	printf("%.12lf\n", ans);
	return 0;
}
```

---

## 作者：Kelin (赞：5)

### 题意

在满足$\sum_{i=1}^ns_ik_i(x_i-v_i)^2\le E_U$的条件下最小化$\sum_{i=1}^n\frac{s_i}{x_i}$

---

### 题解

可以贪心地想一定是当$\sum_{i=1}^ns_ik_i(x_i-v_i)^2=E_U$时最优

因为如果小于的话那么某个$x_i$还可以大一点,使得答案更小

有限制的条件极值通常用[拉格朗日乘数法](https://blog.csdn.net/benoble_/article/details/79718758)来解决

设$f(x_1,\ldots,x_n)=\sum_{i=1}^n\frac{s_i}{x_i},g(x_1,\ldots,x_n)=\sum_{i=1}^ns_ik_i(x_i-v_i)^2=E_U$

在这题里面

$$\frac{\partial f+\lambda g}{\partial x_i}=-\frac{s_i}{x_i^2}+2\lambda s_ik_i(x_i-v_i)=0$$

$$\Rightarrow2\lambda k_i(x_i-v_i)x_i^2-1=0$$

$$\Rightarrow\lambda=\frac1{2k_i(x_i-v_i)x_i^2}$$

可以看出$\lambda$是关于$x_i$的函数是一个单调函数(不然没法求啊)

而且由于$x_i$一定要大于$v_i$

(如果$x_i\lt v_i$,根据$g$的式子可以看出一定可以找到一个对称的$x_i'$使得答案更优,且不超过限制)

可以认为$g$关于$x_i$单调递增,即关于$\lambda$单调递减

所以我们可以二分$\lambda$,然后再解出$x_i$

这是一个关于$x_i$的单调递增的函数

所以解$x_i$的方法可以用二分法或者牛顿迭代法

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=1e4+5;
const double eps=1e-13,inf=1e5;
typedef double d;
int n;d Eu,ans,s[N],k[N],x[N],v[N];
inline d sqr(const d a){return a*a;}
inline d bf(const int i,const d lb){
	d L=max(v[i],0.0),R=inf,mid;
	while(R-L>eps){
		mid=(L+R)*0.5;
		if(lb*k[i]*(mid-v[i])*sqr(mid)>1)R=mid;
		else L=mid;
	}return L;
}
inline bool chk(const d la){
	d tp=0;
	fp(i,1,n)x[i]=bf(i,la);
	fp(i,1,n)tp+=k[i]*sqr(x[i]-v[i])*s[i];
	return tp<Eu;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%lf",&n,&Eu);
    fp(i,1,n)scanf("%lf%lf%lf",s+i,k+i,v+i);
    d L=0,R=inf,mid;
    while(R-L>eps){
    	mid=(L+R)*0.5;
    	if(chk(2*mid))R=mid;
    	else L=mid;
    }
    fp(i,1,n)ans+=s[i]/x[i];
    printf("%.6lf",ans);
return 0;
}
```

---

## 作者：硫代硫酸钠 (赞：4)

预备知识:

	1.在数学中，一个多变量的函数的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定（相对于全导数，在其中所有变量都允许变化）。

2.拉格朗日乘数法:

对于函数 $f(x_1,x_2,x_3...x_n),$存在约束$\phi_1,\phi_2......\phi_m$ 则引入$\lambda_1,\lambda_2...\lambda_m$.
令函数$g(x_1,x_2...,x_n,\lambda_1,\lambda_2,...,\lambda_m)$=$f(x_1,x_2,...x_n)+\sum\limits_{i=1}^m\lambda_i \phi_i$

对函数的每个变量求出一阶偏导数.当且仅当函数的每个偏导数都等于0时,函数$g(x_1,x_2...x_n,\lambda_1,\lambda_2...\lambda_m)$取得极值,即求出每个变量的一阶偏导数后,一阶偏导数等于0的点是方程的一个解.

$c(v_1,v_2,...,v_n)=\sum\limits_{i=1}^n k_i(v_i-v_i')^2 s_i \leq E_0$ 满足上述条件下

使得$t(v_1,v_2,...,v_n)=\sum\limits_{i=1}^n \frac{s_i}{v_i}$ 取最小值

由贪心可知,$c(v_1,v_2,...v_n)=E$最优.故$\phi(x_1,...x_n)=c(v_1,v_2,...v_n)=E  $


upd.本题的限制条件只有一个,即$\sum E\leq E_0$,所以令m=1即可.
~~我居然zz到这种地步~~

运用拉格朗日乘数法,令限制为$\Lambda$,

则得到关于$v_i$的函数:(其中$\Lambda$也是变量)

$s(v_1,v_2,...v_n,\Lambda)=-E+\sum\limits_{i=1}^n(\frac{s_i}{v_i}+\Lambda k_i(v_i-v_i')^2s_i)$.

对上式的$v_i$求偏导得到方程组:

$-\frac{s_i}{v_i^2}+\Lambda k_i(2v_i-2v_i')s_i=0$

即:$2\Lambda k_is_i(v_i-v_i')=\frac{s_i}{v_i^2}$

即:$2\Lambda k_i(v_i-v_i')=\frac{1}{v_i^2}$

即$2\Lambda k_i(v_i-v_i')v_i^2=1$ 

注意到上式关于$v_i$单调递增.故如果$\Lambda$已知二分求解$v_i$即可.



据贪心原则,如果存在$u>v$,使得$\Delta E_u=\Delta E_v$,车速一定为 $u$

即$c(v_i)$关于$v_i$递增,故$\Lambda$也可以二分

时间复杂度$O(n(log_2n)^2)$,虽然因为实数运算慢,但是足够通过本题



qwq

如果觉得这个题到这里就大功告成的话...还差一点,精度误差eps.

本蒟蒻亲测,$10^{-10}10$分,$10^{-11}40$分,$10^{-12}100$分.


下面是本蒟蒻的代码

```
#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define size 500010
#define debug(x) cerr<<#x<<"="<<x
#define gc getchar()
#define inf 1e5
#define db double
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
#define eps 1e-12
using namespace std;

il int read()
{
	char c; int x,f=1;
	for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
	for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
	return f*x;
}

int n;
db k[size],s[size],u[size],Eu,v[size],ans;

db solve(int i,db lam)
{
	db lb=max(u[i],0.0),rb=inf,mid;
	while (rb-lb>eps)
	{
		mid=(lb+rb)/2; 
		if (2.0*lam*k[i]*mid*mid*(mid-u[i])<=1.0) lb=mid; else rb=mid;
	}
	return mid;
}

bool judge(db Lam)
{
	db Es=0;
	rep(i,1,n) v[i]=solve(i,Lam);
	rep(i,1,n) Es+=k[i]*s[i]*(v[i]-u[i])*(v[i]-u[i]);
	return Es>=Eu;
} 

int main()
{
	n=read(); scanf("%lf",&Eu); rep(i,1,n) scanf("%lf%lf%lf",&s[i],&k[i],&u[i]);
	db l=0.0,r=inf;
	while (r-l>eps) 
	{
		db mid=(l+r)/2; if (judge(mid)) l=mid; else r=mid;
	}
	rep(i,1,n) ans+=s[i]/v[i]; printf("%.11lf\n",ans);
	return 0;
}
```






---

## 作者：GKxx (赞：4)

### 题意：

给出$u_1,u_2,\cdots,u_n,k_1,k_2,\cdots,k_n,s_1,s_2,\cdots,s_n$，

最小化函数$T=\sum\limits_{i=1}^n\frac{s_i}{v_i}$的值，并满足条件$\varphi=\sum\limits_{i=1}^nk_is_i(v_i-u_i)^2-E_U=0$。

原本题目描述是说$\varphi\leq0$，但一个简单的贪心思想就是能量消耗越多时间肯定越少，所以直接令$\varphi=0$即可。

### 题解：

这是裸的条件极值，考虑拉格朗日乘数法。

首先介绍偏导数的概念：对于多元函数$y=f(x_1,x_2,\cdots,x_n)$，可以选定其中一个$x_i$视为变量，将其它的$x_j(j\neq i)$都视为常数，将$y$关于$x_i$求导，称为偏导函数，记作$\frac{\partial f}{\partial x_i}$或$f_{x_i}(x_1,x_2,\cdots,x_n)$。

拉格朗日乘数法：求函数$f(x_1,x_2,\cdots,x_n)$在满足条件$\varphi(x_1,x_2,\cdots,x_n)=0$的情况下的可能极值点，可以构造函数$L=f(x_1,x_2,\cdots,x_n)+\lambda\varphi(x_1,x_2,\cdots,x_n)$，然后联立方程组：

$$\begin{cases}\frac{\partial L}{\partial x_1}=0\\\frac{\partial L}{\partial x_2}=0\\\cdots\\\frac{\partial L}{\partial x_n}=0\\\varphi(x_1,x_2,\cdots,x_n)=0\end{cases}$$

这里一共有$(n+1)$个方程，并且算上$\lambda$一共有$(n+1)$个未知数，可以解出若干组解，它们就是函数$f$在满足条件$\varphi=0$的情况下的所有可能极值点。

对于本题而言，设$L=T+\lambda\varphi=\sum\limits_{i=1}^n\frac{s_i}{v_i}+\lambda\left(\sum\limits_{i=1}^nk_is_i(v_i-u_i)^2-E_U\right)$

那么$L$关于$v_i$的偏导数为

$$
\frac{\partial L}{\partial x_i}=-\frac{s_i}{v_i^2}+2\lambda k_is_i(v_i-u_i)
$$

令上式为$0$，稍作变形得到方程

$$
2\lambda k_i(v_i-u_i)v_i^2-1=0
$$

注意到$v_i$必须大于等于$u_i$。因为如果$u_i\leq0$，$v_i>0>u_i$显然；而当$u_i>0$时，$v_i<u_i$意味着你在反向使劲。

并且这个方程要有解必须$\lambda>0$，因为$\lambda\leq0$时左边必然是负的。

考虑函数$g(x)=2\lambda k_i(x-u_i)x^2-1$，求导$g'(x)=6\lambda k_ix^2-4\lambda k_iu_ix$。当$\lambda>0,x\geq u_i$时$g'(x)>0$，$g(x)$单调递增。

所以对于给定的$\lambda$，我们可以二分来求解方程$g(v_i)=0$的解。

可是$\lambda$并没有给定怎么办？没有关系。从上面这个方程我们看出，$\lambda$越大，$v_i$越小，相应的$\varphi=\sum\limits_{i=1}^nk_is_i(v_i-u_i)^2-E_U$就越小。现在我们要使得$\varphi=0$，可以二分$\lambda$。

```cpp
#include <cstdio>
#include <climits>
#include <cmath>
#include <algorithm>

const int maxn = 1e4 + 7;
const double eps = 1e-12, inf = 1e5;

int n;
double eu, s[maxn], k[maxn], u[maxn], v[maxn];

inline bool check(double lambda) {
    double e = 0;
    for (int i = 1; i <= n; ++i) {
        double left = std::max(u[i], 0.0), right = inf;
        while (right - left >= eps) {
            double mid = (left + right) / 2.0;
            if (2 * lambda * k[i] * (mid - u[i]) * mid * mid >= 1)
                right = mid;
            else left = mid;
        }
        v[i] = left;
        e += k[i] * s[i] * (v[i] - u[i]) * (v[i] - u[i]);
    }
    return e >= eu;
}

int main() {
    scanf("%d%lf", &n, &eu);
    for (int i = 1; i <= n; ++i) scanf("%lf%lf%lf", s + i, k + i, u + i);
    double left = 0, right = inf;
    while (right - left >= eps) {
        double mid = (left + right) / 2.0;
        if (check(mid)) left = mid;
        else right = mid;
    }
    double t = 0;
    for (int i = 1; i <= n; ++i) t += s[i] / v[i];
    printf("%.8lf\n", t);
    return 0;
}
```

求解那个偏导数$=0$的方程可能还可以用牛顿迭代法来提高效率，可是我好像WA了...

---

## 作者：aiyougege (赞：4)

### 骑行川藏
因为看不明白下面题解的来龙去脉因此钻了一晚上加一个上午的**拉格朗日乘数子法**, 发现这里面水实在是太深了, 设计到数学多个方面的内容, 太吓人了.

但是因为我菜的不行因此只能将一些**关键点**写出来.而且我关注的只有**数学推导过程**, 如果您想**背过结论**而且直接用的话请看其他人的题解.
#### 多元函数的极值问题
这应该是属于**数学分析**的内容.大概是数学专业的专业课程.

求多元函数$f(x_1,\cdots,x_n)$极值
$$df=0$$

**有约束的极值**问题, 多组约束形如$g(x_1,\cdots,x_n)=0$可用**拉格朗日乘数子法**解决.

- [Zhihu](https://www.zhihu.com/question/38586401)
- [Cnblogs](http://www.cnblogs.com/maybe2030/p/4946256.html#undefined)
- [WenKu](https://wenku.baidu.com/view/6dd13bef551810a6f52486e1.html?from=search)
- [Baike](https://baike.baidu.com/item/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95/1946079?fr=aladdin)
- 数学分析课本

##### 偏导数
**导数属于微积分的内容, 水实在是太深了, 完全不是高中课本上那些一元函数.**

例如:
二元函数$f(x,y)$在某一点$(x_0,y_0)$处对$x$的偏导数.
$$f_x(x_0,y_0)=\lim_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}$$
二元函数$f(x,y)$对$x$的偏导函数记为
$$\frac{\partial f}{\partial x}\text{ or }f_x(x,y).$$
##### 梯度
$\nabla $是劈型算子, $\nabla f$可表示函数在某一点的梯度,梯度也就是某一点的法向量.也就是在这个方向上函数值上升最快.
$$\nabla f=f_x(x_0,y_0)i+f_y(x_0,y_0)j$$
$i,j$为单位向量.
根据$f$在$g$的约束条件下取得极值等价于(为什么?看[例子](https://www.luogu.org/blog/aiyoupass/li-zi))
![png](https://cdn.luogu.com.cn/upload/pic/18873.png)

其中$F$为拉格朗日函数, 它拥有和$f$一样的极值.

##### Solution
　　所以终于步入正题了, 分析这个题, 会发现其时间$f$是关于速度$v_1,v_2,\cdots ,v_n$的多元函数.能量$g$是也是关于$v_1,v_2,\cdots,v_n$的多元函数.但是要求$g\leq \text{E}$

　　接下来会发现如果如果$g<\text{E}$, 那么增大能量$g$, $f$一定会减小, 也就是说会得到更优秀的答案, 因此取得最终答案$v_{01},v_{02},\cdots ,v_{0n}$时能量$g$一定等于$E$.

　　所以接下来问题就转变为了为了
$$\max\ f(v_1,\cdots,v_n)$$
$$\text{s.t. }\ \ g(v_1,\cdots,v_n)-E=0$$
所以就可以构造出拉格朗日函数
$F(v_1,\cdots,v_n,\lambda)=f(v_1,\cdots,v_n)+\lambda \left(g(v_1,\cdots,v_n)\right)$

求其极值.
$\text{d}F=0$

得到$n+1$个分量的方程.
$$\frac{\partial F}{\partial v_1}=0$$
$$\frac{\partial F}{\partial v_2}=0$$
$$\cdots \cdots$$
$$\frac{\partial F}{\partial v_n}=0$$
$$\frac{\partial F}{\partial \lambda}=0$$

这$n+1$个方程可统一表示成一种形式, 即
$$\frac{\partial F}{\partial v_i}=0\text{和}\frac{\partial F}{\partial \lambda}=0$$
在这个题目中可根据上面的方程求出$v_1,\cdots,v_n,\lambda$从而得到答案.


$$\frac{\partial F}{\partial v_i}=(\frac{s_i}{v_i})'+(\lambda k_i(v_i-u_i)^2s_i)'=-\frac{s_i}{v_i^2}+2\lambda k_is_i(v_i-u_i)=0$$
$$\Rightarrow 2\lambda k_i(v_i-u_i)k_i=1$$
接下来就是二分$\lambda $的值,接着求出$v_1,v_2,\cdots,v_n$的值.然后判断是否满足$\text{E=E}_u$

说实话, 这道题的需要的数学的难度远远大于代码难度.代码不是重点.
#### 代码实现
**小技巧**: ***实数二分最好不用eps, 二分个50-100次基本上精度再大都够了.***
```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 500010
#define inf 100000008
using namespace std;

int n;
double k[N],s[N],u[N],Eu,v[N];

bool check(double a,double b,int i){
    return 2.0*a*k[i]*b*b*(b-u[i])<=1.0?true:false;
}

double TwoPoint(int i,double lambda){
    double l=max(u[i],0.0),r=inf,mid;
    for(int j=1;j<=100;++j){
        mid=(l+r)/2;
        if(check(lambda,mid,i))l=mid;
        else r=mid;
    }
    return mid;
}

bool Check(double mid){
    double E=0;
    for(int i=1;i<=n;++i)v[i]=TwoPoint(i,mid);
    for(int i=1;i<=n;++i)E+=k[i]*s[i]*(v[i]-u[i])*(v[i]-u[i]);
    return E>=Eu;
}

int main(){
    scanf("%d",&n);
    scanf("%lf",&Eu);
    for(int i=1;i<=n;++i)
        scanf("%lf%lf%lf",&s[i],&k[i],&u[i]);
    double l=0.0,r=inf,mid;
    for(int j=1;j<=100;++j){
        mid=(l+r)/2;
        if(Check(mid))l=mid;
        else r=mid;
    }
    double ans=0;
    for(int i=1;i<=n;++i)
        ans+=s[i]/v[i];
    printf("%.8f\n",ans);
    return 0;
}
```

---

## 作者：littlez_meow (赞：3)

# 导数萌新也能看懂的题解TwT

考场上的奇妙贪心做法

这是给完全没有接触过高中数学知识的人准备的，讲解较为详细，请耐心观看，初中生也能懂。

[题目指路](https://www.luogu.com.cn/problem/P2179)

## step 1:导数

dalao可跳过本节。

一般而言，导数都以下面的例子引入：

“假设有一辆车，它通过的路程 $(m)$ 与时间 $(s)$ 的关系是 $y=x^2$，则它在 $t$ 时刻的速度是多少？”

考虑使用速度公式 $v=\frac s t$，但直接除肯定不对，那求出来的是整段路程的平均速度，那怎么求呢？

我们把时间无限缩短，车通过的路程也无限缩短，但它们的比值也越来越接近那一瞬间的速度。当缩到不能再缩后，求出的值就是在那个时刻的速度。

怎么求呢？我们可以让车再走 $\Delta x$ 秒，它就再前进 $\Delta y$ 米，这两个值都是无法再缩小的无穷小量。此时的瞬间速度就是 $\frac{\Delta y}{\Delta x}$ 米每秒。

带回原式，就是如下的计算过程

$y+\Delta y=(x+\Delta x)^2$

$=x^2+2x\Delta x+\Delta x^2$

因为 $\Delta x^2$ 相比于 $x^2+2x\Delta x$ 来说，它的大小不值一提，我们可以把它忽略。等式两边同时减 $y$，即减 $x^2$。

$\Delta y=2x\Delta x$

两边同时除以 $\Delta x$，得

$\frac{\Delta y}{\Delta x}=2x$

也就是说，在 $t$ 时刻，车的速度为 $2t$ 米每秒。

如果要展开讲导数，需要极限一系列前置知识，在此篇幅受限，无法详细讲解。因此，下面直接给出导数的严谨定义，看不懂也没关系。

$f'(x)=\lim\limits_{h \to 0} \dfrac{f(x+h)-f(x)} h$

其中，$h$ 就是上文的 $\Delta x$。

依照同样的方法，我们可以再对速度求时间的导数来得出加速度和时间的关系。

让我们考虑导数的代数意义。速度是衡量路程随时间变化快慢的量，加速度是衡量速度随时间变化快慢的量。因此，我们可以说，导数的作用，是求出变化率。至于几何意义，感兴趣的同学可以再平面直角坐标系上模拟走一段无穷小的时间的过程，自行观察。

## step 2:转化

让我们考虑在道路上发生了什么。

首先让我们列出式子，记 $E_i$ 为第 $i$ 段路耗费的能量， $t_i$ 为第 $i$ 段路耗费的时间，记 $v_i$ 为第 $i$ 段路的速度，则有如下式子:

$E_i=k_i s(v_i-v_i')$

$t_i=\dfrac{s_i}{v_i}$

如果我们想用更少的时间通过这个路程，那么就要速度更大，那么消耗能量也就要更多。有的时候，时间减少很多，但能量消耗不一定增加很多；有时时间减少一点，能量消耗却增加了很多。使用作比定义法，不妨记 $w_i=\frac{t_i\text{变化量}}{E_i\text{变化量}}$，显然，其值永远为负。$|w_i|$ 越小，我们将时间减少，增大的能量就越小。速度不同时，$w_i$ 也不一样。如果能求出 $t_i$ 随 $E_i$ 的变化率，用 $v_i$ 表示出来，我们就能决定出速度为多少时，改变时间的收益最大。

既然是变化率，立刻想到导数。这里要求 $t_i$ 对于 $E_i$ 的导数。在这里就要用到导数的的另一个性质了。看到上面导数既然是一种商，那么就可以用以下求法。

$\dfrac{\Delta t_i}{\Delta E_i}=\dfrac{\frac{\Delta t_i}{\Delta v_i}}{\frac{\Delta E_i}{\Delta v_i}}$

课堂练习，用step 1的方法求导并用 $v_i$ 表示。

下面直接给出结论：

$\dfrac{\Delta t_i}{\Delta E_i}=-\dfrac 1 {2k_i(v_i-v_i')v_i^2}$

问题是，接下来怎么办？

## step 3:贪心与二分

骑行的过程可以这样理解。

我们每次选出一个无穷小的能量 $\Delta E$，将其分给收益最高的一段以减少时间。此时根据公式，那条路段的收益会降低。因此达到最优解后，我们要做到每段导数相等。否则，我们在上一步分配给导数较大的那一段，就可以获得更优解。这与我们已找到最优解的假设矛盾。所以，最终状态下，每段的速度必然使每段的导数相等。

再看导数图像
![导数图像](https://cdn.luogu.com.cn/upload/image_hosting/s5c3h2y9.png)

其瑕点为 $v_i=v_i'$，当 $v_i>v_i'$ 时，也就是我们需要的负数值，导数值单调递增。因此，我们可以二分导数值，上节取0，下界取一个很小的负数值，在本题取 $4\times 10^6$ 即可。

二分出导数值 $d$ 后，解关于 $v_i$ 的方程 $-\dfrac 1 {2k_i(v_i-v_i')v_i^2}=d$，再用 $E_i=k_i s(v_i-v_i')$ 求出能量。如果 $\sum_{i=1}^n E_i\le E_U$ 就二分右区间，反之二分左区间，到达精度就停。本题对精度要求较高，建议取 $\varepsilon=1\times 10^{-12}$。

至于怎么解方程，早在初三课本二次函数那章就已经接触过二分法，高中必修一有详细介绍了，在此不做赘述，具体步骤大概是:
1. 若 $f(l)\times f(r)<0$，则在 $[l,r]$ 区间内有解。
2. 记 $m=\dfrac {l+r} 2$。
3. 若 $f(m)=0$，则 $m$ 就是解。
4. 若 $f(m)\times f(l)<0$，令 $r=m$，否则令 $l=m$，重复第二、三、四步，直到到达指定精度，即 $|l-r|<\varepsilon$。

## step 4:附上代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a);i<=b;++i)
#define R(i,a,b) for(int i(a);i>=b;--i)
#define _ 0
using namespace std;
const double EPS=1e-12;
const int INF=4e6;
double e,s[10001],v_wind[10001],k[10001],t;
int n;
inline double func(double x,int i,double right){
	return -1.0/(2*k[i]*(x-v_wind[i])*x*x)-right;
}
inline bool check(double d){
	double energy(0);
	t=0;
	F(i,1,n){
		double l(max(v_wind[i],(double)0)),r(INF),mid=(l+r)/2,fl=func(l,i,d);
		while(fabs(r-l)>EPS){
			double fmid=func(mid,i,d);
			if(fabs(fmid)<=EPS) break;
			if(fmid*fl<0) r=mid;
			else l=mid,fl=fmid;
			mid=(l+r)/2;
		}
    	mid=(l+r)/2;
		energy+=k[i]*s[i]*(mid-v_wind[i])*(mid-v_wind[i]);
		t+=s[i]/mid;
	}
	return energy<=e;
}
int main(){
// 	freopen("bicycling.in","r",stdin);
// 	freopen("bicycling.out","w",stdout);
	scanf("%d%lf",&n,&e);
	F(i,1,n) scanf("%lf%lf%lf",s+i,k+i,v_wind+i);
	double l(-INF),r(0),mid=(l+r)/2;
	while(fabs(r-l)>EPS){
		if(check(mid)) l=mid;
		else r=mid;
		mid=(l+r)/2;
	}
	printf("%.8lf",t);
	return ~~(0^_^0);//卖个萌OwO
}
```

不喜勿喷awa~

---

## 作者：Fheiwn (赞：3)

先讲一讲拉格朗日乘数法：
拉格朗日乘数法是用来解决多元函数的最优值问题（最大、最小）
一般形式为：函数$f(x_1,x_2,x_3..x_n)$满足限制$g_i(x_1,x_2,x_3...x_n)=0,(i\in 1,2,3....m)$  
解法：定义$h(x_1,x_2,x_3...x_n,\lambda_1,\lambda_2,\lambda_3...\lambda_m)=f(x_1,x_2,x_3...x_n)+\Sigma_{i=1}^m\lambda_ig_i(x_1,x_2,x_3...x_n)$  
函数$h$的极值就是函数$f$的最优值
$h$极值用导数求  

再回到这道题，只需要满足一种限制：$g(x)=\Sigma_{i=1}^n s_i\ast k_i(x_i-v_i')^2\leq Eu$，并且，当$g(x)=Eu$时最优；
于是就有$g(x)$函数：$g(x)=\Sigma_{i=1}^n s_i\ast k_i(x_i-v_i')^2-Eu=0$
$f(x)$函数为：$f(x)=\Sigma_{i=1}^n \frac {s_i}{x_i}$，$x_i$为每段路的骑行速度   

则$h(x)=\Sigma_{i=1}^n \frac{s_i}{x_i}+\lambda\ast\Sigma s_i\ast k_i(x_i-v_i')^2-Eu$  
将它求导：$h'(x)=-\Sigma_{i=1}^n \frac{s_i}{x_i^2}+2\ast\lambda\ast\Sigma_{i=1}^n s_i\ast k_i(x_i-v_i')$

二分求$h'(x)=0$时的$x$值
二分时每一个$x_i$也是二分求

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<queue>
#include<stack>
#include<set>
#include<bitset>
#include<vector>
#include<cstdlib>
#define QAQ int
#define TAT long long
#define OwO bool
#define ORZ double
#define F(i,j,n) for(QAQ i=j;i<=n;++i)
#define E(i,j,n) for(QAQ i=j;i>=n;--i)
#define MES(i,j) memset(i,j,sizeof(i))
#define MEC(i,j) memcpy(i,j,sizeof(j))
using namespace std;
const QAQ N=10005;
QAQ n;
ORZ m;
struct data{
    ORZ s,k,v;
}a[N];
ORZ l,r,ans,v[N];
OwO pd(ORZ lmd){
    F(i,1,n){
        ORZ l=a[i].v,r=1000000,ans=0;
        F(j,1,100){
            ORZ mid=(l+r)/2.0;
            if(2*lmd*a[i].k*mid*mid*(mid-a[i].v)<=1.0) l=mid,ans=mid;
            else r=mid;
        }
        v[i]=ans;
    }
    ORZ ans=0;
    F(i,1,n) ans+=a[i].k*(v[i]-a[i].v)*(v[i]-a[i].v)*a[i].s;
    return ans>=m;
}
QAQ main(){
    scanf("%d%lf",&n,&m);
    F(i,1,n) scanf("%lf%lf%lf",&a[i].s,&a[i].k,&a[i].v);
    l=0;r=10000000;
    F(i,1,100){
        ORZ mid=(l+r)/2.0;
        if(pd(mid)) l=mid;
        else r=mid;
    }
    F(i,1,n) ans+=a[i].s/v[i];
    printf("%.6lf\n",ans);
    return 0;
}
```


---

## 作者：寄风 (赞：1)

身体（神题）。

首先我们可以把每个路段的速度都设置成 $v_i$，这个时候我们的体能值满足最小，也就是 $0$。

然后，我们考虑花费我们的体力值去给一些地方增加速度。减少速度是不可能的，不然的话花费了体力值又增加了时间，显然是不优的。

然后有一个比较显然的贪心：每次都挑选花费单位体力值可缩短时间最大的地方加速。

贪心证明：$E_u$ 显然是可以用完的，因为速度可以是小数。而体力值用完的时候，我们的增速路段每一次都是时间减少的最多的，所以贪心策略正确。

然后发现到每一次加速之后这个路段的花费单位体力值可缩短时间是在不断减小的。

所以到最后的最优解时，我们每一个路段的花费单位体力值可缩短时间应该都是一样的。

然后画出关于花费体力值 $E$ 和缩短时间 $t$ 的函数图像，发现其实花费了 $x$ 体力值时的花费单位体力值可缩短时间其实就是过点 $(x,0)$ 的切线的斜率，也就是导数。

然后我们考虑二分这个导数。

然后我们只要求得每一个地方花费的体力值个这个地方的速度就做完了。

然后对于任意的一个地方，如果我们确定了速度，那么花费的体力值是好求的。

所以我们考虑求速度。

我们来考虑对单独的一块地方的花费单位体力值可缩短时间，它等于 $\frac{t}{E}$。


根据 $E=k_i(v-v_i')^2s$，$t=\frac{s}{v}$，所以我们知道：

$\frac{dt}{dE}=\frac{dt}{dv} \frac{dv}{dE}$（链式求导法则）

$\frac{dt}{dv} \frac{dv}{dE}=\frac{d\frac{s}{v}}{dv} \frac{dv}{dk_i(v-v_i')^2s}=-\frac{s}{v^2} \frac{1}{2k_i(v-v_i')s}=-\frac{1}{2k_iv^2(v-v_i')}$（商法则、化简）

然后这个花费单位体力值可缩短时间的值必定小于等于我们之前二分出来的导数（设为 $q$），所以 $-\frac{1}{2k_iv^2(v-v_i')}<q$，把分母移过去得 $-1<2k_iqv^2(v-v_i')$。

所以二分直接算 $v$ 即可。

然后就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
double E , s[100005] , k[100005] , v[100005];
inline double work(double x , double v , double k){
    double l = max(v , 0.0) , r = 100000;
    int cnt = 100;
    while(cnt--){
        double  mid = (l + r) / 2;
        if(-1 < 2 * k * x * mid * mid * (mid - v)) l = mid;
        else r = mid;
    }
    return l;
}
inline double getE(double mid){
    double sum = 0;
    for(int i = 1;i <= n;i++){
        double vv = work(mid , v[i] , k[i]);
        sum += k[i] * s[i] * (vv - v[i]) * (vv - v[i]);
    }
    return sum;
}
inline bool check(double mid){
	return getE(mid) <= E;
}
signed main(){
	cin >> n >> E;
    for(int i = 1;i <= n;i++){
    	cin >> s[i] >> k[i] >> v[i];	
	}
    double l = INT_MIN , r = 0;
    int cnt = 100;
    while(cnt--){
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    double sum = 0;
    for(int i = 1;i <= n;i++){
        sum += s[i] / work(l , v[i] , k[i]);
    }
    printf("%.6lf\n", sum);
}
```

---

## 作者：Xu_brezza (赞：1)

**本题解着重于理解掌握拉格朗日乘数法的应用！！**

# 题意
在满足 $\sum_{i=1}^{n} {k_{i} \times s_{i} \times (v_{i} - v_{i}{}' )^2} \le E_{U} $ 的条件下，
使得 $\sum_{i=1}^{n} {\frac{s_{i}}{v{i}} } $ 最小，
其中 $k_{i},s_{i},v_{i}{}'$ 为给定的常数，未知量就是 $v_{i}$。

# 分析

其实学过拉格朗日乘数法的已经能看出来了，求这种多元函数的极值，有了给定的约束条件，直接拉乘就可以了。

那么**拉格朗日乘数法**是什么呢？

首先你得学会导数([传送门](http://www.gaosan.com/gaokao/244831.html)），只需要记住几个基本函数的求导法则就行了，比如幂函数，指数函数，对数函数，$sin$，$cos$，再学会函数加和、乘积、作比的求导法则，基本够用了。

其实从高等数学的角度来讲，~~我不会~~，如果好奇可以去[这里](https://zhuanlan.zhihu.com/p/449683167)。

 所以从通俗角度来讲，我们只需要掌握套路，知道这个东西可以求极值就行了。

 那么套路是什么呢？

首先题中给出了**约束条件**，也就是未知量的一个等式，在本题中，我们可以贪心的想：

我们消耗的体力越多，肯定跑的越快，也就是那个式子越小。

所以我们不妨令约束条件为 $\sum_{i=1}^{n} {k_{i} \times s_{i} \times (v_{i} - v_{i}{}' )^2} = E_{U}$。

接下来引出拉格朗日乘数法最核心的部分：

 我们要求上面式子的极值，就要引入一个 $\lambda $，

然后得到这样的一个函数：

$\sum_{i=1}^{n} {\frac{s_{i}}{v{i}} }  + \lambda (\sum_{i=1}^{n} {k_{i} \times s_{i} \times (v_{i} - v_{i}{}' )^2} - E_{U})$

观察一下是怎么得来的？

首先把要求极值的式子抄过来，再写一个 $\lambda$，再用它乘上约束条件的量都移项到左边的样子。

接下来我们要对这个函数中的每一个变量，也就是我们要求的 $v_{i}$ 和 $\lambda$，求**偏导**。

“偏导是什么？我不会啊啊啊！！！”

“不，你会！”

偏导其实就是只考虑**当前一个**变量，把其他所有的**无关变量**以及原有的常量**统一**认为是**常量**，然后求导。

所以我们推导理解一下：

对于 $v_{i}$：

首先忽略与他无关的常数式子，得到:

${\frac{s_{i}}{v_{i}} }  + \lambda \times {k_{i} \times s_{i} \times (v_{i} - v_{i}{}' )^2}$

此时进行求导，可以得到:

$-\frac{s_{i}}{v_{i}^ {2}}  + 2\times \lambda \times {k_{i} \times s_{i} \times (v_{i} - v_{i}{}' )}$

注意这里有个小技巧就是 

如果 $f(x) = (x + b)^2$ 那么 $ f{}'(x) = 2(x + b)$，手推一下就知道了。

接下来对 $\lambda$ 求导就没什么了，把系数抄下来就OK:

$\sum_{i=1}^{n} {k_{i} \times s_{i} \times (v_{i} - v_{i}{}' )^2} - E_{U}$

众所周知，函数求极值在导函数的零点处取得，所以我们要让所有的 $v_{i}$ 还有 $\lambda$ 都使得他们的导函数为 $0$，也就是说我们所求的式子的极值，在我们求偏导得出的所有式子同时为 $0$ 时取得。

接下来考虑怎么求：

首先我们发现，直接找每一个 $v_{i}$，如同我们脱裤子放屁，是不可行的。

我们看看对 $v_{i}$ 导数的式子可以得到什么？

$2\times \lambda \times {k_{i} \times {v_{i}^2} \times (v_{i} - v_{i}{}' )} = 1$ 

非常滴amazing啊，这不反比例吗？

当然不全是，至少我们肯定能看出来随着 $\lambda$ 递增，$v_{i}$ 肯定递减，且这个时候的 $v_{i}$ 最便于确定。

好！那就二分 $\lambda$ 吧！

然后在二分答案的时候，在里面二分 $v_{i}$ 就好了，因为内外都有单调性，都可以二分，这样我们肯定能逼近到所有方程都为 $0$ 也就是取到极值的时候啦。

代码部分，其实和之前的神犇好像都差不多啦，重在理解学习！

[代码在这里~](https://www.luogu.com.cn/paste/qj9q4e0a)

管理大大求过qwq。

---

## 作者：_sys (赞：1)

最小化

$$F(\mathrm v)=\sum \frac{\mathrm s^i}{\mathrm v^i}$$

当

$$G(\mathrm v)=\sum \mathrm k^i\mathrm s^i(\mathrm v^i-\mathrm v'^i)^2-E_U=0$$

使用 Lagrange 乘子法。令 $H: \mathbb R^n\times \mathbb R\to \mathbb R$ 为

$$H(\mathrm v, \lambda)=F(\mathrm v)-\lambda G(\mathrm v)$$

则需要满足

$$\mathrm DH=0$$

才能满足 $G$ 的限制，且 $F$ 取到临界点。

$$\frac{\partial H}{\mathrm v^i}=-\frac {\mathrm s^i}{(\mathrm v^i)^2}-2\lambda\mathrm k^i\mathrm s^i(\mathrm v^i-\mathrm v'^i)$$

$$\frac{\partial H}{\lambda}=-\sum \mathrm k^i\mathrm s^i(\mathrm v^i-\mathrm v'^i)^2$$

也就是解方程

$$\begin{cases}A(\mathrm v, \lambda)=-\frac {\mathrm s^i}{(\mathrm v^i)^2}-2\lambda\mathrm k^i\mathrm s^i(\mathrm v^i-\mathrm v'^i)=0\\ B(\mathrm v)=-\sum \mathrm k^i\mathrm s^i(\mathrm v^i-\mathrm v'^i)^2=0\end{cases}$$

一式得：

$$\lambda=\frac 1{2\mathrm k^i}(\mathrm v^i)^2(\mathrm v^i-\mathrm v'^i)$$

也就是说，所有的 $\frac 1{2\mathrm k^i}(\mathrm v^i)^2(\mathrm v^i-\mathrm v'^i)$ 应该相同。在这个条件下，我们还要求其满足二式。

根据隐函数定理发现一式中 $\frac{\partial \mathrm v^i}{\partial \lambda} > 0$，且二式中 $\frac{\partial B}{\partial \mathrm v^i} > 0$。故 $\frac{\partial B}{\partial \lambda}>0$。对 $\lambda$ 二分即可。

---


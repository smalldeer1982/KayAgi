# [WFOI - 01] 翻转序列（requese）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/kmmn8pyd)。

为什么做完这题你不去做做[这题](https://www.luogu.com.cn/problem/P8223)呢

## 题目描述

你需要在一台奇怪的电脑上排序一个 $1\sim n$ 的排列。

你可以选择一个数 $x$，然后你每次可以翻转一段长为 $x+1$ 或一段长为 $x-1$ 的序列。

请在 $20\times n$ 次内还原成 $1\sim n$ 的序列。

（出题人注：现在最优可以达到15000次以下，请尝试优化您的算法）

## 说明/提示

- **样例 $1$ 解释：**
	
    翻转 $(1,2)$ 序列变成 $1,2$；
    
- **样例 $2$ 解释：** 

    翻转 $(1,5)$ 序列变成 $1,4,3,2,5$；

	翻转 $(2,4)$ 序列变成 $1,2,3,4,5$；
    
**本题采用 Subtask 捆绑测试。**

Subtask 编号 | 数据规模与约定
:-: | :-:
**Subtask #0** ($\texttt{1 pts}$) | $n=1$
**Subtask #1** ($\texttt{2 pts}$) | $n=2$
**Subtask #2** ($\texttt{3 pts}$) | $n=3$
**Subtask #3** ($\texttt{4 pts}$) | $n=4$
**Subtask #4** ($\texttt{20 pts}$) | $1\le n\le 50$
**Subtask #5** ($\texttt{20 pts}$) | $1\le n\le 100$
**Subtask #6** ($\texttt{50 pts}$) | $1\le n\le 10^3$

对于 $100\%$  的数据，$1\le n,a_i\le 10^3$，数据保证 $a$ 是一个 $1\sim n$ 的排列。

## 样例 #1

### 输入

```
2
2 1```

### 输出

```
1
1
1 2```

## 样例 #2

### 输入

```
5
5 2 3 4 1```

### 输出

```
4
2
1 5
2 4```

# 题解

## 作者：wlxhkk (赞：24)

## 题意

你有一个长度为 $n$ 的排列，现在你可以选择一个数 $x$，你每次可以翻转一段长为 $x+1$ 或一段长为 $x-1$ 的子串。

请在 $20 \times n$ 次内还原成 $1\sim n$ 的序列。

## 部分分

对于 $n \le 100$ 的部分，注意到上界非常松，直接用 $x=3$ 解决。

假设我们已经将 $1$ 到 $u-1$ 的数归位，现在要处理 $u$。

每次，我们可以翻转长 $x+1=4$ 的区间使 $u$ 前移 $x=3$ 格，最后剩下的部分可以用 $x-1=2$ 的 swap 补齐。

次数约为 $2n+\lfloor \frac{n}{3} \rfloor \times n \times \frac{1}{2}$，足以拿到 50 分。

## 正解

我们从 $n \le 100$ 的部分推广，现在认为序列足够长。

处理 $u$ 的时候，同样先用 $x+1$ 的翻转操作不断将 $u$ 左移 $x$ 格。

假设最后 $u$ 的位置是 $v \in (u,u+x)$，这时我们需要特殊处理。

如果 $u$ 和 $v$ 奇偶性不同，我们可以用一次 $[l,r] ,l > u$ 的翻转操作将其放到 $u+x$ 上。

否则，我们可以操作 $[v,v+x]$ 将 $u$ 移到 $v+x$ 上，使奇偶性正确，然后进行上述操作。

但上述操作对剩余位置的长度有要求，注意到 $2x$ 的长度一定是足够的。

因此，我们取 $x$ 为 $\le n/4$ 的最大奇数。

方便起见，我们先用类似的操作处理序列的后半部分，使 $\lceil \frac{n}{2} \rceil$ 到 $n$ 归位，这时位置是足够的。

然后处理前半部分，然而虽然序列长度足够，但是后半部分已经处理好，不能够随意翻转。

注意到我们倒着做操作可以复原序列，运用这个性质，我们尝试交换 $u$ 上和 $v$ 上的值。

一个至关重要的操作是同时使用 $x+1$ 和 $x-1$ 可以仅交换 $i$ 与 $i+x$ 上的值。因此，当 $u$ 已经位于 $u+x$ 上时，直接用该操作交换，然后复原序列。

由于我们的操作 $[l,r]$ 均保证 $l > u$，因而该过程不会出现冲突。

复原一个数的次数上界是 $\lfloor \frac{n}{x} \rfloor +2 +1 +2$，总和会带上约 $1/2$ 的常数，理论上界不超过 $5.5n$，非常优秀。

代码实现时对 $n \le 4$ 的情况进行了特判。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int n,a[N],x,y;
vector<pair<int,int> > op;
inline void oper(int u,int v){
	reverse(a+u,a+v+1);
	op.push_back(make_pair(u,v));
}
inline void prt(){
	for(int i=1;i<=n;i++) if(a[i]!=i){
		puts("wrong operations !!");
		exit(-1);
	}
	printf("%d\n",(int)op.size());
	for(auto u:op) printf("%d %d\n",u.first,u.second);
}
inline void force(){
	puts("3");
	for(int u=1,v;u<n;u++){
		for(v=u;v<=n;v++) if(a[v]==u) break;
		while((v-u)%3) oper(v-1,v),v--;
		while(v>u) oper(v-3,v),v-=3;
	}
	prt();
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	if(n<=4) force(),exit(0);
	x=n>>2;
	if(!(x&1)) x--;
	printf("%d\n",x);
	y=(x+1)>>1;
	//后半部分 
	for(int u=n,v;u>(n/2);u--){
		for(v=u;v;v--) if(a[v]==u) break;
		while(v+x<=u) oper(v,v+x),v+=x;
		if(v==u) continue;
		int l=u,r=u-x;
		if((l-v)&1) oper(v-x,v),v-=x;//同下 
		oper((v+r)/2-y+1,(v+r)/2+y);
		oper(r,r+x);
	}
	//前半部分 
	for(int u=1,v,rv;u<=(n/2);u++){
		for(v=u;v<=n;v++) if(a[v]==u) break;
		while(v-x>=u) oper(v-x,v),v-=x;
		if(v==u) continue;
		int l=u,r=u+x;rv=0;
		if((l-v)&1) oper(v,v+x),v+=x,rv=1;//调整奇偶性 
		oper((v+r)/2-y+1,(v+r)/2+y);//将 u 放到位置 u+x 上 
		oper(l,l+x);oper(l+1,l+x-1);//交换 u 和 u+x 上的值 
		oper((v+r)/2-y+1,(v+r)/2+y);//复原序列 
		if(rv) oper(v-x,v);//复原序列 
	}
	prt();
}
```

---

## 作者：樱雪喵 (赞：13)

思路来自 @[茫茫星辰1208](https://www.luogu.com.cn/user/323204)，拜谢模拟赛踩 std 的神仙。

## Description

给一个 $1$ 到 $n$ 的排列 $p$，你可以选择一个数 $x$，每次可以翻转一个长度为 $x+1$ 或 $x-1$ 的区间。构造一个方案，在 $20n$ 次操作内使排列有序。

## Solution

首先可以发现我们选的 $x$ 一定是奇数。

考虑若 $x$ 为偶数，无论如何翻转区间都无法改变一个数下标的奇偶性。故当数 $x$ 与其位置的奇偶性不同时，会导致无解。

---


假设该序列足够长，考虑如何在不影响其他数的情况下交换 $p_a$ 和 $p_b$。

规定 $a<b$，则 $a$ 与 $b$ 之间的距离为 $b-a$。  
当 $b-a=x$ 时，可以通过依次操作 $[a,b]$、$[a+1,b-1]$ 交换它们的位置。设该操作为 $\text{swap}(a,b)$，代价为 $2$，要求 $b-a=x$。  
显然，当 $\operatorname{dis}(a,b)\ge x$ 时，可以先通过重复操作 $\operatorname{swap}(b-x,b)$ 使它们的距离小于 $x$。故我们只讨论 $\operatorname{dis}(a,b)<x$ 的情况。

设 $r=a+x$，那么我们只需要考虑怎么把 $b$ 换到 $r$ 的位置上。  
当 $b$ 与 $r$ 奇偶性不同时，容易求出一个区间 $[L,R]$，使 $b,r$ 关于区间中点对称。那么，我们先 $\operatorname{reverse}(L,R)$，此时的 $b$ 在 $r$ 的位置上。那么我们 $\operatorname{swap}(a,r)$ 把 $a,b$ 交换，最后再把 $[L,R]$ 翻回来即可。  
考虑 $b$ 与 $r$ 奇偶性相同怎么办。其实操作前先 $\operatorname{swap}(b,b+x)$ 就好了，因为这样 $\operatorname{dis}(b,r)$ 还是小于 $x$，可以直接套用上面操作。

至此我们解决了交换任意 $p_a,p_b$ 的问题。

---

注意到这个方法需要在 $a$ 后面有大约 $2x$ 长度的额外空间。把序列分为两半，分别从两端向中间构造，两边都可以获得 $\dfrac{n}{2}$ 的额外空间。

$x$ 的取值满足 $\dfrac{n}{2}\ge 2x$，解得 $x\le\dfrac{n}{4}$。  
对于每个数 $b$，使其与 $a$ 的距离小于 $x$ 的 $\text{swap}$ 需要至多 $2\times \dfrac{n}{x}$ 次操作，后续需要至多 $6$ 次操作。  
总操作次数的上限约为 $\dfrac{n(n+1)}{x}+6n$，在 $x$ 取 $\dfrac{n}{4}$ 时最优，上界不足 $10n$。实测操作数稳定在 $5000$ 左右，可以通过。



---

## 作者：_O_v_O_ (赞：12)

好好好好好好好好好题。

## Subtask#0~3

没啥技术含量，直接选择 $x=1$ 然后冒泡排序即可。

## Subtask#4~5

我们发现 $n^2$ 冒泡排序不行了。

我们不妨直接取 $x=3$。

那么我们注意到假如我们有一段长度为 $4$ 的子序列：$\{a_i,a_{i+1},a_{i+2},a_{i+3}\}$。

那么我们可以先操作 $[i,i+3]$，然后就变成了 $\{a_{i+3},a_{i+2},a_{i+1},a_i\}$。

然后操作 $[i+1,i+2]$，变成了 $\{a_{i+3},a_{i+1},a_{i+2},a_i\}$。

我们发现我们用了两次操作交换了 $a_i$ 和 $a_{i+3}$！

那么我们就可以先把一个数换到它该去的位置，如果换不到，那么再交换一次长度为 $2$ 的序列即可。

次数大约为 $\sum_{i=1}^n \frac n3+n=\frac{n\times (n-1)}{6}+n\approx \frac{n^2}6$，可以过。

## Subtask#6

先假定 $x$ 已被选。

从上面推广过来，假如我们有一个长度为 $x$ 的序列 $\{a_i,a_{i+1},a_{i+2},\cdots,a_{i+x}\}$，我们可以先做 $[i,i+x]$，再做 $[i+1,i+x-1]$，这样我们就交换了 $a_i$ 和 $a_{i+x}$。我们发现，这样 $x$ 只能是奇数。

那我们也推广方法，我们先把 $a_i$ 位移到 $a_{a_i\pm (x-1)}$ 处，然后在放到 $a_{a_i}$，那么这题就只剩选 $x$ 就做完了……

不对，我们注意到此时 $x\neq 2$，也就是说我们将 $a_i$ 位移到 $a_{a_i\pm (x-1)}$ 处后，无法进行接下来的操作！


为了方便，我们就设 $a_i$ 的位置在 $u$，应该换到 $v$ 位置。

我们就先假设 $v$ 操作后在 $u$ 后面

我们注意到，因为 $u$ 离 $v$ 的距离 $<x$，那么我们就可以把 $v$ 翻到 $u+x$ 再交换。

否则，我们就可以做一次左端点在 $u$ 右边，且包含到 $v$ 的翻转使得改变 $v$ 的奇偶性。

我们发现，这样很依赖区间的长度，因为在把 $v$ 换到 $u+x$ 已经被排好就难办了。

所以我们取 $x$ 为 $\frac n4$，由于 $x$ 为奇数，所以 $x$ 最终就是 $\le \frac n4$ 的最大奇数。

那么我们就可以先用这种操作做完后半部分，在倒着做前半部分。这题就做完了。

操作大约为 $n\times \lfloor\frac nx\rfloor+3n\approx\frac{n^2}{x}$，即每个都用了，在 $n\le 1000$ 的情况下很显然超不过 $20n$，我们的做法很显然爆标了。（

## 代码

我们注意到我们这样会 MLE on Subtask#1~3，因为 $\lfloor\frac n4\rfloor=0$，我们特判一下就行了。


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e3+5;
int n,a[N],x,y;
vector<pair<int,int>> opt;
void add(int u,int v){
	reverse(a+u,a+v+1);
	opt.push_back({u,v});
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	if(n<=4){
		cout<<1<<endl;
		for(int i=1;i<=n;i++){
			for(int j=2;j<=n;j++){
				if(a[j]<a[j-1]){
					add(j-1,j);
				}
			}
		}
		cout<<opt.size()<<endl;
		for(pair<int,int> i:opt) cout<<i.first<<' '<<i.second<<endl;
		return 0;
	}
	x=n/4;
	if(x%2==0) x--;
	cout<<x<<endl;
	y=(x+1)/2;
	for(int i=n,j;i>(n/2);i--){
		for(j=i;j;j--) if(a[j]==i) break;
		while(j+x<=i) add(j,j+x),j+=x;
		if(i==j) continue;
		int l=i,r=i-x;
		if((l-j)%2) add(j-x,j),j-=x;
		add((j+r)/2-y+1,(j+r)/2+y);
		add(r,r+x);
	}
	for(int i=n,j;i>(n/2);i--){
		for(j=i;j;j--) if(a[j]==i) break;
		while(j+x<=i) add(j,j+x),j+=x;
		if(i==j) continue;
		int l=i,r=i-x;
		if((l-j)%2) add(j-x,j),j-=x;
		add((j+r)/2-y+1,(j+r)/2+y);
		add(r,r+x);
	}
	for(int i=1,j;i<=(n/2);i++){
		for(j=i;j<=n;j++) if(a[j]==i) break;
		while(j-x>=i) add(j-x,j),j-=x;
		if(i==j) continue;
		int l=i,r=i+x,fg=0;
		if((l-j)%2) add(j,j+x),j+=x,fg=1;
		add((j+r)/2-y+1,(j+r)/2+y);
		add(l,l+x);add(l+1,l+x-1);
		add((j+r)/2-y+1,(j+r)/2+y);
		if(fg) add(j-x,j);
	}
	cout<<opt.size()<<endl;
	for(pair<int,int> i:opt) cout<<i.first<<' '<<i.second<<endl;
	return 0;
}
```

---

## 作者：€€£ (赞：10)

### 题解（requese）

我们定义一个数如果已经在自己最后的位置上，那么他的状态是 **done**；如果这个数所处的位置奇偶性与这个数的奇偶性相同，那么他的状态是 **half done**；一个数的**半契合性**表示的是这个数的奇偶性与他所处位置的奇偶性是否相同。

我们考虑两种操作：

1、get，对于一个点，暴力地将其 **done**，一个数get代价约为 $\dfrac{n}{x}+1 \to 0$ 不等；

2、swap，花 $4$ 的代价，交换距离为 $2$ 的两个数，并不打乱其他数的顺序。以下给出一例：

```
取 x=5：
1 2 3 4 5 8 7 6
reverse(2,7):
1 7 8 5 4 3 2 6
reverse(3,8):
1 7 6 2 3 4 5 8
reverse(2,7):
1 5 4 3 2 6 7 8
reverse(2,5):
1 2 3 4 5 6 7 8
```

3、change，花 $2$ 的代价，改变 $2$ 个相邻位置上的数的半契合性，并不打乱其他数的半契合性。以下给出一例：

```
取 x=7:
1 2 3 4 5 6 8 7
reverse(1,8):
7 8 6 5 4 3 2 1
reverse(3,8):
7 8 1 2 3 4 5 6
```

于是，我们考虑进行以下步骤：

对于数 $1\to (n-\dfrac{3}{2}x-1)$​​​​​​​​ ，我们将他们 **get**，总次数约为 $\dfrac{n^2}{2x}$​​​​​；

对于数 $(n-\dfrac{3}{2}x) \to n$，我们用 **swap** 将尽可能多的 **half done** 的数都尽可能的往左，使得最后前面 $y$ 个位置全为 **half done** 状态的数，后面 $n-y$ 个位置全部是**非 half done** 状态，总次数约为 $\dfrac{9x^2}{4}$；

然后由于**非 half done** 状态是成对出现的，在此我们考虑：如果**非 half done** 状态个数 $\ge x+1$，那么我们可以用一次翻转操作使得前 $x+1$ 个**非 half done** 状态变为 **half done** 状态；此时如果 **非half done** 状态个数 $\ge \dfrac{x+1}{2}$，那么我们可以再对最后 $x+1$ 个数进行一次翻转，这样 **非half done** 状态个数 $\le \dfrac{x+1}{2}$；

接着我们对后面 **非half done** 状态的数使用 $\dfrac{n-y}{2}$ 次 **change** 操作，总次数约为 $\dfrac{1}{2}x$，此时所有数都是 **half done** 状态；

最后由于后面 $\dfrac{3}{2}x$​ 个数还不是 **done** 状态，所以我们暴力地用 **swap** 将这些数类似于插入排序一下，总次数约为 $\dfrac{9x^2}{4}$​​，此时所有数都是 **done** 状态；

用均值不等式平衡一下，在 $x=\sqrt[3]{\dfrac{n^2}{18}}$​​​ 时较优，最大约为 $19700$​​​ 次；实际上由于前面几个有互相制约性（即一个取满另一个很可能取不满），~~也很难造很卡的数据，~~实际表现远低于 $20000$​​​。

时间复杂度 $O(20n^2)$。

---

upd3.20：

事实上如果我们在一开始加上一定数量的随机翻转区间操作，实际表现甚至不到 $15000$ 步。

---

## 作者：一休哥777 (赞：1)

[\[WFOI - 01\] 翻转序列（requese）](https://www.luogu.com.cn/problem/P7999)

官方题解：[sol](https://www.luogu.com.cn/blog/ccfnb/solution-p7999)。这里更多的是对该题解的补充说明。建议先阅读官方题解后再阅读本篇。

先定义：如果一个数在自己应该在的位置上，即 $a_i=i$，那么他的状态是 **done**。如果一个数的奇偶性和其所在位置的奇偶性相同，那么他的状态是 **half done**，也称为这个数的半契合性。

首先选定的 $x$ 一定是奇数，如果 $x$ 是偶数那么翻转的区间长度都是奇数，无法改变任何数的半契合性。

假设已经选定了一个 $x$，由于 $x$ 的取值会影响到总体操作的数量，到最后再给出对于 $x$ 的取值说明。

第一部分是暴力让较小的一些数字 **done**。设当前 $a_i=j$，要让 $i$ 位置上的数字转移到 $j$ 位置上，同时由于 $1 \sim i-1$ 上的数字已经 **done**，不能改变他们。

具体方法：如果可以进行一次以 $i$ 为右端点，长度为 $x+1$ 的区间翻转，就进行操作，相当于让 $i$ 往前跳，一直向前跳，如果 $i=j$ 已经满足条件直接结束，否则只能让 $i$ 到 $j+x$ 的位置上然后 $\mathrm{reverse}(j,j+x)$ 完成。因为翻转区间的长度为偶数，也就是说翻转一次之后区间内所有数的半契合性都会发生改变，如果 $i$ 和 $j+x$ 的奇偶性相同不可能完成，此时需要转换一下 $i$ 的奇偶性才可以，转换的方式是进行一次操作 $\mathrm{reverse}(j,j+x)$。然后通过一个长为 $x+1$ 的区间翻转即可让 $i$ 到达 $j+x$，最后 $\mathrm{reverse}(j,j+x)$ 结束。

上述描述了让 $j$ 归位的过程，操作次数大约是 $\frac{n}{x}+0/1/2/3$。中间要注意：在操作的时候会需要 $j$ 之后的一些位置作为操作的空间，如果没有这些位置上述操作将不成立，其中最需要空间的一步是当 $j < i < j+x$ 且 $i$ 和 $j+x$ 已经有不同奇偶性的时候，如果 $i=j+x-1$，那么这一步向后需要大约 $\frac{x}{2}$ 的空间，加上 $j+x$ 所需要的 $x$ 长度的空间，上述过程的要求是 $j+ \frac{3x}{2} \le n$，也就是说后面 $\frac{3x}{2}$ 的位置将不能直接 **done** 完成，需要另外的方法。

为了让后 $\frac{3x}{2}$ 的数字完成 **done**，需要一些其他的方法来操作。引出下面构造出的两个组合操作：

1. swap 交换距离为 2 的两个数字，不改变其他数字。代价为 4。

具体方法：假设交换位置为 $i$ 和 $i+2$ 上的数字，那么需要以下操作：

- 翻转以 $i+1$ 为右端点，长为 $x+1$ 的区间。

- 翻转以 $i+2$ 为右端点，长为 $x+1$ 的区间。

- 翻转以 $i+1$ 为右端点，长为 $x+1$ 的区间。

- 翻转以 $i-1$ 为右端点，长为 $x-1$ 的区间。

注意这个操作需要左边的长为 $x$ 的空间。

2. change 改变相邻两个位置上的数字的半契合性，并且不改变其他数字的半契合性，但是会影响顺序。代价为 2。

具体方法：假设改变位置为 $i$ 和 $i+1$ 上的数字的半契合性，那么需要以下操作：

- 翻转以 $i+1$ 为右端点，长为 $x+1$ 的区间。

- 翻转以 $i+1$ 为右端点，长为 $x-1$ 的区间。

注意这个操作需要左边的长为 $x$ 的空间，同时会打乱左方长为 $x$ 空间内数的顺序。

让后 $\frac{3x}{2}$ 的数字 **done**，我们进行以下操作：

1. 用 swap 将所有的 **half done** 的数字集中到左侧。

2. 此时最后有 $y$ 个数字是**非 half done**，如果 $x+1 \le y$ 就翻转一次最左侧的 $x+1$ 个**非 half done** 数，如果 $y > \frac{x+1}{2}$，就翻转序列末尾的 $x+1$ 个数使得 $y \le \frac{x+1}{2}$。

3. 暴力 change 最后所有**非 half done** 的数字，将其全部转换成 **half done**。

4. 对奇偶位置上的数字分别用 swap 进行冒泡排序。

对以上的操作做出几点说明：首先要让所有数字 **half done** 这样最后可以使用 swap 进行冒泡排序。因为 change 操作会改变左边 $x$ 个数的顺序，所以 change 操作只能在最后 $\frac{x}{2}$ 个数之间使用，于是要用其他方法使得 $n-\frac{3x}{2} \sim n-\frac{x}{2}$ 位置上的数字变成 **half done**。我们先使用 swap 操作将**非 half done** 的数字集中到最右侧，如果还是多于 $\frac{x}{2}$，就进行一次末尾的区间翻转，这样最后**非 half done** 的数字的个数控制在了小于 $\frac{x}{2}$ 个，使用 change 暴力更改即可。换句话说，前面的 swap 和区间翻转操作都是为了弥补 change 操作只能在最后 $\frac{x}{2}$ 个数上使用的缺点从而在最后使用 change 操作进行契合性变换。

不难发现中间所有操作次数都与 $x$ 有关系。第一部分让前面的数暴力 **done**，每个数需要 $\frac{n}{x}$ 次操作，一共需要 $\frac{n^2}{x}$ 次操作，第二部分让后 $\frac{3x}{2}$ 的数 **done** 中，第 2 步只需要 1 次操作，第 3 步只需要 $\frac{x}{2}$ 次操作，第 1,4 步是操作次数的瓶颈，各自需要 $(\frac{3x}{2})^2 \times 4 $ 次操作，也就是 $18x^2$。平衡一下两者，$\frac{n^2}{x}=18x^2$，$x=\sqrt[3]{\frac{n^2}{18}}$ 时最优。如果在开始操作前随机几次无意义的区间翻转，可以将初始序列变成一个较为随机的序列，会更优。

---


# [WFOI - 02] I wanna moqueve（位移序列）

## 题目背景

> It's my fiesta.
>
> 一场前，kid 在 WFOIR1 的地图上，折戟沉沙；一场后，kid 从倒下的地方爬起。
> 
> kid 成功了，他不再是从前那个他了。

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/dlxx9pm0)

为什么做完这题你不去做做[这题](https://www.luogu.com.cn/problem/P7999)呢

## 题目描述

kid 需要在一台奇怪的电脑上排序一个 $1\sim n$ 的排列，下一个存档点才会出现。

kid 可以选择一个数 $x$，然后接下来的每次操作，kid 可以向左或向右循环位移一段长为 $x$ 的序列（最左/右边的会平移至最右/左边）（位移量是 $1$）。

如果 kid 的操作次数超过了 $23\times n$，排列就会爆炸，kid 将会再次倒下。所以，请告诉 kid 一种还原序列的方案，剩下的操作就交给 €€£ 吧！

## 说明/提示

- **样例 $1$ 解释：**
	
    左移 $(2,3)$ 序列变成 $2,1,3$；
    
    左移 $(1,2)$ 序列变成 $1,2,3$；
    
- **样例 $2$ 解释：** 

    右移 $(3,5)$ 序列变成 $4,2,1,3,5$；

	右移 $(1,3)$ 序列变成 $1,4,2,3,5$；
    
    左移 $(2,4)$ 序列变成 $1,2,3,4,5$；
    
**本题采用 Subtask 捆绑测试。**

Subtask 编号 | 数据规模与约定
:-: | :-:
**Subtask #0** ($\texttt{1 pts}$) | $n=1$
**Subtask #1** ($\texttt{2 pts}$) | $n=2$
**Subtask #2** ($\texttt{3 pts}$) | $n=3$
**Subtask #3** ($\texttt{4 pts}$) | $n=4$
**Subtask #4** ($\texttt{20 pts}$) | $1\le n\le 50$
**Subtask #5** ($\texttt{20 pts}$) | $1\le n\le 100$
**Subtask #6** ($\texttt{50 pts}$) | $1\le n\le 10^3$

对于 $100\%$ 的数据，$1\le n,a_i\le 10^3$，数据保证 $a$ 是一个 $1\sim n$ 的排列。

## 样例 #1

### 输入

```
3
2 3 1```

### 输出

```
2
2
2 0
1 0```

## 样例 #2

### 输入

```
5
4 2 3 5 1```

### 输出

```
3
3
3 1
1 1
2 0```

# 题解

## 作者：€€£ (赞：5)

### 题解（moqueve）

我们定义一个数如果已经在自己最后的位置上，那么他的状态是 **done**；

我们考虑两种操作：

1、get，对于一个点，暴力地将其 **done**，一个数get代价约为 $\dfrac{n}{x}+\dfrac{x}{2} \to 0$​​​​​​​ 不等；

2、twin-swap，花 $4$​​ 的代价，同时交换两对距离为 $2$​​​ 的两个数，并不打乱其他数的顺序。以下给出一例：

```
取 x=6：
* * 1 3 2 5 4 6 * *
move(1,6,1):
5 * * 1 3 2 4 6 * *
move(5,10,0):
5 * * 1 2 4 6 * * 3
move(1,6,0):
* * 1 2 4 5 6 * * 3
move(5,10,1):
* * 1 2 3 4 5 6 * *
```

3、double-swap，花 $8$ 的代价，依次交换两对距离为 $2$ 的两个数，并不打乱其他数的顺序。以下给出一例：

```
取 x=6：
* * * 1 3 2 5 4 6
move(3,8,1):
* * 4 * 1 3 2 5 6
move(4,9,1):
* * 4 6 * 1 3 2 5
move(3,8,0):
* * 6 * 1 3 2 4 5
move(4,9,0):
* * 6 1 3 2 4 5 *
move(1,6,1):
2 * * 6 1 3 4 5 *
move(4,9,1):
2 * * * 6 1 3 4 5
move(1,6,0):
* * * 6 1 2 3 4 5
move(4,9,0):
* * * 1 2 3 4 5 6
```

_注：以上两条仅在一定条件下成立；_

于是，我们考虑进行以下步骤：

对于较小的数据规模，我们选择 $x=2$ 暴力进行操作即可；

否则，我们选定一个**偶数** $x$​；

首先我们前后依次 **get**，即先 **get** $1$​，然后 $n$​，然后 $2$​，然后 $n-1$​……直到不能再归位为止；

然后对于中间的 $x-1$​ 个数 $h \sim t$，我们考虑：

如果存在两对逆序对，那我们直接用 **twin-swap** 交换即可；

否则，我们先用 **double-swap** 交换一对，此时：

- 如果没有逆序对了，则交换 $h,h+1$；
- 如果还有逆序对，则交换这个逆序对；

如果操作到只剩最前面两个位置不对，我们对此 `move(h,h+x-1,0)`，然后进行 $\dfrac{x-2}{2}$ 次 **double-swap** 操作即可。

这样差不多是 $\dfrac{n^2}{2x}+\dfrac{nx}{2}+x^2+2x$​​ 次，在 $n=1000$​​ 时取 $x=30$​​ 粗略估计约为 $33000$​ 次，精确一点差不多是 $31650$​ 次左右；​

但是，我们发现这玩意在随机数据下优秀许多；

所以，我们可以在开始添加 $50$​ 次随机循环位移，这样就降到了 $25000$​ 次以下；

我不知道怎么证明……但是我试了很多次都没超过 $25000$​ ……

但是实际上我们还可以优化：

我们发现在随机后由于总体位置改变不大，所以每次移动 $x-1$ 位的期望次数不会怎么变，但是由于随机对最后平移一个点到指定位置的影响还是挺大的，期望只需要 $\dfrac{nx}{4}$，所以次数期望变成了 $\dfrac{n^2}{2x}+\dfrac{nx}{4}+x^2+2x$；

所以我们取 $x=\sqrt{2\times n}$ 的时候次数还可以优化，降到了 $23000$ 次以下；

时间复杂度 $O(23n^2)$​​​​。

---


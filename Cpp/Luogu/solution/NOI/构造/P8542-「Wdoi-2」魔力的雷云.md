# 「Wdoi-2」魔力的雷云

## 题目背景

道具会自己活动，本来温顺的妖怪突然大闹起来原来都是因为万宝槌的影响。  
唆使小人的天邪鬼虽然最后逃走了，但因为真正使用万宝槌的是小人，所以灵梦决定对其进行监视。但是总感觉也没再有什么不良企图的样子。  

但就在那时，天空再次出现了诡异的云团。  
是与逆城出现之时一样的，魔力风暴。

“那不是我干的”，少名针妙丸这样解释着  
到底，又是谁再次掀起了这样的风暴？  
灵梦她们，为了调查清楚原因，再次冲进了风暴之中。

小人的末裔、逆转的城、为反抗而反抗的天邪鬼。  
这背后又隐藏着什么呢。

## 题目描述

### 简要题意

$n$ 块磁铁排列成了一个环。每块磁铁都有磁力，用 $4^{a_i}$ 表示。相邻两块磁铁**磁力大小不同**。磁铁大小一致，长度均为 $1$ 单位长度。摆放时分为北极朝左和北极朝右。当两块磁铁互相吸引时，它们会紧紧靠拢，互相排斥时，记这两块磁铁的磁力为 $u$ 和 $v$，那么它们会相距 $u+v$ 单位长度。

目前已知**整个环**的长度（包括**每个**磁铁的长度，以及相邻磁铁之间的距离），记这个长度为 $d_0$ 个单位长度。对于第 $i$ 块磁铁，也已知若拿去这块磁铁，剩余磁铁组成的环的长度，记这个长度为 $d_i$ 个单位长度。

找到找到任意一种可能的磁铁排列方法满足这些已知的数据，（也要满足相邻两块磁铁磁力大小不同），并且可以决定所用磁铁的磁力。保证有解。

### 原始题意

在堀川雷鼓引发的雷暴中，一架架周围附带着电磁场的鼓正随着节奏摇摆着。在强大的电磁干扰下，巫女和魔法使与地面失去了联系。

这些尺寸完全相同（可以视作为单位长度 $1$）的带有磁力的鼓一共有 $n$ 架，它们排列成了一个环。为了让弹幕美观，第 $i$ 架鼓上带有的磁力是 $4^{a_i}$，而且相邻两架鼓带有的磁力大小不同。

每一架鼓都有磁性上的南北两极，而且在摆放的时候有北极朝左和北极朝右的两种情况。若两架鼓相互吸引它们会紧紧靠拢；而若它们相互排斥，这两架鼓之间的距离就是它们的磁力之和的单位长度。

灵梦记录下了整个环的长度 $d_0$，这包括了每架鼓的长度和相邻的鼓之间的距离，而魔理沙正在使用自己的火力击碎这些鼓。然而这些鼓的质量非常皮实，魔理沙一次只能击碎一个鼓，随后堀川雷鼓会用一个尺寸和磁力完全一致的鼓替代这个被击碎的鼓。但是在击碎第 $i$ 架鼓的时候，受到磁力的作用环的长度会发生变化，魔理沙会记录此时剩余的鼓组成的环的长度 $d_i$（假设磁力的作用是瞬间完成的）。

在战斗的间隙，灵梦和魔理沙希望通过她们记录下的数据，找到任意一种鼓的排布情况满足这些数据。为了降低难度，她们可以自由决定每架鼓上的磁力多少。数据保证有解。

尽快解出鼓的分布，从而结束这场异变吧！

## 说明/提示

### 样例 1 解释

一种合法的方案中，$c=\{1,1,0,1\}$，$a=\{1,0,1,0\}$。以下是这种方案的图解。

初始时磁铁的状态如下图所示，磁铁上方的数字是它的磁力大小（即 $4^{a_i}$ 的值），磁铁上标记的 $\textsf{N/S}$ 是它的磁极。由于笔者能力有限，无法还原出环形，只能用这种传送门的方式扭曲时空了。

![](https://cdn.luogu.com.cn/upload/image_hosting/tdbb4nqb.png)

容易发现，总长度为 $14$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wmagcu24.png)

拿掉第一块磁铁后的情形如图所示。容易发现，总长度为 $13$。

![](https://cdn.luogu.com.cn/upload/image_hosting/eipnbj08.png)

拿掉第二块磁铁后的情形如图所示。由于缺少了第二块磁铁的阻挡，第一块和第三块磁铁直接相邻，产生了更大的间距。可以发现，总长度为 $16$。

![](https://cdn.luogu.com.cn/upload/image_hosting/830j9rz5.png)

拿掉第三块磁铁后的情形如图所示。值得注意的是，所有磁铁北极方向相同，于是直接互相接触，总长度为 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/afqw0jx4.png)

拿掉第四块磁铁后的情形如图所示。由于第三块和第一块磁铁直接相邻（因为是形成了环。在图上则是扭曲后的空间里相邻），因此形成了这种模样。总长度为 $16$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值} \\\hline
1 & 10 & - & 10 \\\hline
2 & 10^5 & - & 30 \\\hline
3 & 10^6 & \text{A} & 5 \\\hline
4 & 10^6 & - & 55 \\\hline
\end{array}$$

**特殊性质** $\textbf{A}$：保证存在一种方案，所有磁铁的方向一致。

对于所有数据，保证 $1\leq n\leq 1\times10^6$，存在至少一种合法方案。此外，保证 $d_i< 2^{63}$，你构造的 $a_i$ 大小应该在 $[0,10^9]$。

## 样例 #1

### 输入

```
4
14
13
16
3
16```

### 输出

```
1 1
1 0
0 1
1 0```

# 题解

## 作者：离散小波变换° (赞：8)

## 题解

考虑每个 $d_i$ 到底可以给我们提供多少信息。具体而言，从左往右考虑每一块磁铁。每次选择三块磁铁进行讨论。

### 情况一：$\boxed\to\boxed\to\boxed\to$

此时完全无法推断第二块和第三块磁铁的磁力大小，直接忽略。

### 情况二：$\boxed\to\boxed\to\boxed\gets$

- 保留第二块磁铁，总贡献为 $x=p+1+b+c+q$；
- 拿掉第二块磁铁，总贡献为 $y=p+a+c+q$。

做差，发现 $x-y-1=b-a$。可以直接推断出第一块和第二块磁铁的磁力大小。

### 情况三：$\boxed\to\boxed\gets\boxed\gets$

- 保留第二块磁铁，总贡献为 $x=p+a+b+1+q$；
- 拿掉第二块磁铁，总贡献为 $y=p+a+c+q$。

做差，发现 $x-y-1=b-c$。可以直接推断出第二块和第三块磁铁的磁力大小。

### 情况四：$\boxed\to\boxed\gets\boxed\to$

- 保留第二块磁铁，总贡献为 $x=p+a+b+1+b+c+q$；
- 拿掉第二块磁铁，总贡献为 $y=p+q$。

做差，发现 $x-y-1=a+2b+c$。感觉不一定有用阿。但是只要我们知道了 $a$ 或者 $c$ 的大小，就可以计算出剩余磁铁的磁力大小。



---

但是从这些地方，我们可以发现一些结论：

- 如果出现了形如 $\text{AAAAA}$ 形式的方向摆放，最中间的磁铁的磁力大小无需得知。因此可以将所有长度大于 $4$ 的连续段缩成长度为 $4$ 的连续段。
- 如果出现了形如 $\text{ABB}$ 形式的方向摆放，就可以一次性推断出后两块磁铁的磁力。
- 如果出现了形如 $\text{BBA}$ 形式的方向摆放，就可以一次性推断出前两块磁铁的磁力。
- 结合上述三点，对于缩完之后的长度在 $2\sim 4$ 之间的连续段，如果它两端有磁铁，就可以一口气把这一段内所有磁铁的磁力计算出来。
- 那么目前计算不出来磁力的磁铁，肯定都是长度为 $1$ 的互相交错的连续段。他们的两侧就是磁力大小都被计算出来的磁铁，或者是整条磁铁链的顶端。
- 那么结合情形 $3$，可以推知所有磁铁的磁力大小。

---

接着是特殊情况的讨论：

- 如果所有磁铁方向相同，那么所有磁铁的磁力大小都是无关紧要的，可以随便赋值。
- 排除以上一点，肯定会出现不同方向的磁铁。如果磁铁方向呈现了 $\text{ABAB}\cdots$ 的交替情形，那么我们只能枚举某个磁铁的磁力大小来破局。但是你没必要 $\mathcal O(\log n)$ 枚举；事实上，由于情形 $4$，可以发现 $b$ 的可能性是非常有限的。
- 排除以上两点，肯定会出现长度不小于 $2$ 的连续段。可以从这里作为突破口，首先进行链的缩减，接着计算出所有 $2\sim 4$ 段磁铁的磁力大小，接着计算出所有磁铁的磁力大小。

初始时设第一块磁铁方向向左即可。容易发现这不会对结果产生任何影响。不过有可能出现第一块磁铁左右两侧恰好有一块方向和它不同，你却不知道是哪个。那也问题不大，对两种情况分别求解判断合法性即可。

---

如何判断连续段的长度：

- 如果一个磁铁与周围两块磁铁方向都相同，那么拿掉他后，$d$ 只会减小 $1$；
- 如果一个磁铁仅与周围一块磁铁方向不同，那么拿掉他后，$d$ 的减小值模 $3$ 与 $1$ 同余；
- 如果一个磁铁与周围两块磁铁方向都不同，那么拿掉他后，$d$ 的减小值模 $3$ 与 $2$ 同余。

读者可以自行证明。这里不再赘述。

---

如何根据 $a+2b,a\neq b$ 知晓 $a$ 和 $b$ 的值：

- 注意到 $a,b$ 均为 $4$ 的整数次幂，可以设 $a=2^{2u},b=2^{2v}$，相加后为 $2^{2u}+2^{2v+1}$。那么找二进制下两个 $1$，偶数位置的 $1$ 是属于 $a$ 的，奇数位置的 $1$ 是属于 $b$ 的。

如何根据 $a-b,a\neq b$ 知晓 $a$ 和 $b$ 的值：

- 若 $a-b>0$，那么 $b=\text{lowbit}(a-b)$，同时推出 $a=(a-b)+b$。
- 若 $a-b<0$，那么取反后的值为 $b-a>0$，根据上一种情况即可得解。

读者可以自行验证/证明，这里不再赘述。

## 代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef unsigned int       u32;
typedef unsigned long long u64;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e6+3;
i64 D[MAXN],E[MAXN],A[MAXN]; bool F[MAXN]; int n,O[MAXN];
i64 qread(){
    i64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
i64 lowbit(i64 t){return t&-t;}
int countz(i64 t){return __builtin_ctzll(t);}
bool check(){
    A[0]=A[n],F[0]=F[n],A[n+1]=A[1],F[n+1]=F[1];
    i64 d0=n,d1=0,dn=0,dx=0;
    up(1,n,i){
        if(A[i]==-1) continue;
        if(A[i]!=(1ll<<(O[i]<<1))) return false;
        if(A[i]==A[i==1?n:i-1]||A[i]==A[i==n?1:i+1])
            return false;
    }
    up(1,n,i) if(F[i]!=F[i+1]) d0+=A[i]+A[i+1];
    if(d0!=D[0]) return false;
    up(1,n,i){
        dx=d0-1;
        if(F[i  ]!=F[i-1]) dx-=A[i  ]+A[i-1];
        if(F[i  ]!=F[i+1]) dx-=A[i  ]+A[i+1];
        if(F[i-1]!=F[i+1]) dx+=A[i-1]+A[i+1];
        if(dx!=D[i]) return false;
    }
    return true;
}
void find_add(i64 w,i64 &p,i64 &q){ // w=p+2q -> p,q
    i64 a=lowbit(w),b=w-a;
    if(countz(a)&1) q=a/2,p=b; else q=b/2,p=a;
}
void find_min(i64 w,i64 &p,i64 &q){ // w=p- q -> p,q
    if(w>0) q=lowbit( w),p=w+q;
    else    p=lowbit(-w),q=p-w;
}
int N[MAXN],M[MAXN];
void maintain1(){
    up(1,n,i) if(A[i]!=-2&&A[i]!=-1){
            int a=i,b=N[a],c=N[b];
            if(F[a]!=F[b]&&F[a]==F[c]){
                find_add(D[0]-D[b]-A[a]-1,A[c],A[b]);
            }
        }
}
void maintain2(){
    up(1,n,i){
        if(A[i]==-1) O[i]=114514+i; else O[i]=countz(A[i])/2;
    }
}
void showshowway(){
    up(1,n,i){
        printf("%lld, %d\n",A[i],F[i]);
    }
}
bool solve2(){
    up(1,n,i) N[i]=i+1; N[n]=1;
    up(1,n,i) M[i]=i-1; M[1]=n;
    up(2,n,i){
        if(  D[0]-D[i]        ==1) F[i+1]= F[i  ]; else
        if(((D[0]-D[i])%3+3)%3==1) F[i+1]=!F[i-1]; else
        if(((D[0]-D[i])%3+3)%3==2) F[i+1]=!F[i  ];
    }
    F[0]=F[n],F[n+1]=F[1]; bool g=0,h=0;
    up(1,n,i) g|=F[i],h|=F[i]==F[i+1];
    if(g==0){
        up(1,n,i) A[i]=-1; maintain2(); return check();
    } else if(h==0){
        i64 w=D[0]-D[1]-1;
        up(0,20,i){
            bool f=false;
            up(0,20,j){
                up(0,20,k){
                    i64 a=1ll<<(j<<1);
                    i64 b=1ll<<(i<<1);
                    i64 c=1ll<<(k<<1);
                    if(w==a+2*b+c) f=true;
                }
            }
            if(f){
                A[1]=(1ll<<(i<<1));
                maintain1(),maintain1(),maintain2();
                if(check()) return true;
            }
        }
    } else {
        up(1,n,i) if(F[i]!=F[M[i]]){
            int l=i,r=i,p=i;
            for(;F[r]==F[N[r]];r=N[r]); if(l==r) continue;
            find_min(D[0]-D[r]-1,A[r],A[M[r]]);
            find_min(D[0]-D[l]-1,A[l],A[N[l]]);
            for(;F[p]==F[N[p]];p=N[p]) if(A[p]==-2) A[p]=-1;
            if(l<r) i=r; else break;
        }
        maintain1(),maintain1(),maintain2();
        return check();
    }
    return 0;
}
void solve1(bool f){
    up(1,n,i) A[i]=-2,F[i]=-1; F[1]=false,F[2]=f;
    if(solve2()){
        up(1,n,i) printf("%d %d\n",F[i],O[i]); exit(0);
    }
}
i64 p1,p2,q1,q2;
int main(){
    n=qread(); up(0,n,i) D[i]=qread();
    if(n==1){puts("1");exit(0);}
    F[1]=false;
    if(  D[0]-D[1]        ==1)              solve1(false); else
    if(((D[0]-D[1])%3+3)%3==1) solve1(true),solve1(false); else
    if(((D[0]-D[1])%3+3)%3==2) solve1(true)              ;
    return 0;
}
```

---

## 作者：Alex_Wei (赞：6)

> [P8542 「Wdoi-2」魔力的雷云](https://www.luogu.com.cn/problem/P8542)

首先特判掉 $n = 2$ 的情况，数据没有 $n = 1$。如果有也平凡。

设 $b_i = 4 ^ {a_i}$，$c_i = d_0 - d_i$。

考虑一段方向相同的磁铁 $l\sim r$。我们发现将 $l + 1\sim r - 1$ 当中任意一个拿去，均使得总长减少 $1$，反之根据磁力为 $4$ 的幂且相邻磁力不同可证其充分性。据此可找出长度 $\geq 3$ 的极长的方向相同的磁铁。

**法一**：进一步地，考虑长度为 $2$ 的极长的方向相同的磁铁 $l, l + 1$。设 $u = b_{l - 1}$，$v = b_l$，$w = b_{l + 1}$，$x = b_{l + 2}$。当不拿去任何磁铁时，$l - 1$ 和 $l + 2$ 之间的距离为 $u + v + 2 + w + x$。拿去磁铁 $l$ 时，距离为 $u + w + 1 + w + x$，拿去磁铁 $l + 1$ 时，距离为 $u + v + 1 + v + x$。据此得必要条件 $c_l + c_{l + 1} = 2$。问题在于它并不是充分条件。例如 $(1, u), (1, v), (0, u), (0, v)$，撤去中间两个磁铁的 $c$ 分别为 $1 + v - u$ 和 $1 + u - v$。但分类讨论后可知仅有这种情况为特例（$4$ 的幂模 $3$ 余 $1$），因此除去长度 $\geq 3$ 的连续段之后，考虑极长的 $c_i + c_{i + 1} = 2$ 的连续段 $[l, r]$，可知 $[l, l + 1], [l + 2, l + 3], \cdots, [r - 1, r]$ 为连续段。据此可找出长度 $\geq 2$ 的极长的方向相同的磁铁。则剩下来的磁铁相邻两个方向均不同。

**法二**：换种角度考虑，我们检查长度为 $1$ 的极长连续段 $[l, l]$ 的性质。设 $u = b_{l - 1}$，$v = b_l$，$w = b_{l + 1}$。当不拿去任何磁铁时，$l - 1$ 与 $l + 1$ 之间的距离为 $u + v + 1 + v + w$。拿去磁铁 $l$ 时，$l - 1$ 与 $l + 1$ 之间的距离为 $0$。因此 $c_l = 1 + u + 2v + w$。我们要将其与存在与 $l$ 相邻的方向相同的磁铁区分开来。当 $f_{l - 1} = f_l = f_{l + 1}$ 时 $c_l = 1$，这个在第一步判过了。因此，考虑恰存在一个与 $l$ 相邻的方向相同的磁铁，不妨设为 $l - 1$，则此时 $c'_l = 1 + v - u$。看起来不是很好判断，但注意到 $b_i$ 为 $4$ 的幂，所以 $b_i\equiv 1\pmod 3$，则 $c_l \equiv 2\pmod 3$ 且 $c_{l'} \equiv 1\pmod 3$。结合 $f_{l - 1} = f_l = f_{l + 1}$ 情况的 $c_l = 1$，可知若 $c_l\equiv 2\pmod 3$ 则与 $i$ 相邻的两个磁铁方向均不同，即 $[i, i]$ 为极长连续段。则剩下未被任何连续段覆盖的磁铁形成了为若干长度为 $2$ 的极长连续段，容易得到每个磁铁的方向。

综上，我们确定了所有磁铁的方向，接下来确定磁力。

对于 $l < r$，模拟可知 $c_l - 1 = b_l - b_{l + 1}$，$c_r - 1 = b_r - b_{r - 1}$。因为相邻磁铁磁力不同，所以容易确定 $b_l, b_{l + 1}, b_{r - 1}, b_r$。具体地，设 $u = 4 ^ v$，$x = 4 ^ y$，已知 $u > x$ 和 $u - x$，求 $u, x$。根据 $2$ 的幂的性质，易证 $x = \mathrm{lowbit}(u - x)$，进而可知 $u = (u - x) + x$。磁铁 $l + 2\sim r - 2$ 的磁力任意选取均符合要求，只需满足相邻不相等即可。

对于 $l = r$，模拟可知 $c_l - 1 = b_{l - 1} + 2b_l + b_{l + 1}$。因为 $b_l\neq b_{l - 1}, b_{l + 1}$ 且 $b_i$ 为 $4$ 的幂，所以 $\mathrm{popcount}(c_l - 1)$ 等于 $2$ 或 $3$。当等于 $2$ 时 $b_{l - 1} = b_{l + 1}$，我们无法区分 $b_{l - 1}$ 和 $b_l$；当等于 $3$ 时可知 $a_l$ 为 $c_l - 1$ 唯一为 $1$ 的奇数位除以 $2$，即 $a_l = 2 ^ x$，其中 $c_l - 1$ 的第 $2x + 1$ 位为 $1$。但如果 $\mathrm{popcount}(c_l - 1) = 2$ 时已知 $b_{l - 1}$ 或 $b_{l + 1}$，则可以确定 $b_l$。

综合上述所有结论，当且仅当所有相邻磁铁方向不同，且所有 $\mathrm{popcount}(c_i - 1) = 2$ 时，上述结论无法给出确定解。此时所有 $c_i$ 全部相同。因为 $c_i - 1 = 2(4 ^ {a_i} + 4^ {a_{i + 1}})$，令偶数位置 $a_i$ 为 $c_i - 1$ 较低位减 $1$ 除以 $2$，令奇数位置 $a_i$ 为较高位减 $1$ 除以 $2$ 即可。

时间复杂度 $\mathcal{O}(n)$。代码使用法二。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using ull = unsigned long long;
inline ll read() {
  ll x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 1e6 + 5;
ll low(ll x) {return x & -x;}
int lg(ll x) {return __builtin_ctzll(x);}
int ppc(ll x) {return __builtin_popcountll(x);}
int n, f[N], g[N], a[N];
ll d[N], c[N];
int id(int x) {return x < 1 ? x + n : x > n ? x - n : x;}
void done() {
  for(int i = 1; i <= n; i++) {
    putchar(f[i] + '0'), putchar(' ');
    print(a[i]), putchar('\n');
  }
  exit(0);
}
pii dis(ll v) {return {lg(low(v)), lg(v ^ low(v))};}
void sub(int x, int y, ll v) { // a[x] - a[y] = v
  if(v < 0) swap(x, y), v = -v;
  a[id(y)] = lg(low(v)) >> 1, a[id(x)] = lg(v + low(v)) >> 1;
}
void ded(int x) {
  ll v = c[id(x)] - 1;
  if(ppc(v) == 3) {
    for(int _ : {0, 0, 0}) {
      ll u = low(v);
      a[id(x)] = lg(u) >> 1, v ^= u;
      if(lg(u) & 1) return;
    }
  }
  int nei = a[id(x - 1)] = a[id(x + 1)] = max(a[id(x - 1)], a[id(x + 1)]);
  if(nei == -1) return;
  pii res = dis(v);
  a[id(x)] = ((nei << 1) ^ res.first ^ res.second) >> 1;
}
void ded2(int l, int r) {
  sub(l, l + 1, c[id(l)] - 1);
  sub(r, r - 1, c[id(r)] - 1);
  for(int p = l + 2; p <= r - 2; p++) a[id(p)] = p + 1064;
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  cin >> n >> d[0];
  for(int i = 1; i <= n; i++) d[i] = read();
  if(d[0] == n) {
    for(int i = 1; i <= n; i++) a[i] = i < n ? i & 1 : 2;
    done();
  }
  if(n == 2) {
    d[0] = d[0] - 2 >> 1;
    ll low = d[0] & -d[0];
    a[1] = lg(low), a[2] = lg(d[0] ^ low), f[2] = 1;
    done();
  }
  for(int i = 1; i <= n; i++) c[i] = d[0] - d[i], g[i] = 2, a[i] = -1;
  for(int i = 1; i <= n; i++)
    if(c[i] == 1) g[i] = g[id(i - 1)] = g[id(i + 1)] = 3;
    else if((c[i] % 3 + 3) % 3 == 2) g[i] = 1;
  int pos = 1;
  for(int i = 2; i <= n; i++) if(g[i] != g[i - 1]) pos = i;
  for(int i = pos; i < pos + n;) {
    f[id(i)] = f[id(i - 1)] ^ 1;
    if(g[id(i)] == 1) ded(i++);
    else if(g[id(i)] == 2) {
      f[id(i + 1)] = f[id(i)];
      ded2(i, i + 1), i += 2;
    }
    else {
      f[id(i + 1)] = f[id(i)];
      int r = i + 2;
      while(c[id(r - 1)] == 1) f[id(r++)] = f[id(i)];
      ded2(i, r - 1), i = r;
    }
  }
  for(int i = 1; i <= n; i++) if(a[i] == -1) ded(i);
  if(a[1] == -1) {
    pii res = dis(c[1] - 1);
    for(int i = 1; i <= n; i++) a[i] = (i & 1 ? res.first : res.second) >> 1;
  }
  done();
  cerr << TIME << " ms\n";
  return 0;
}
```

---


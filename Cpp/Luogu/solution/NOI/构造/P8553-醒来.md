# 醒来

## 题目背景


“那羡慕的烟火去哪了，那信任的朋友疏远了。

我年幼时坚持过什么，你们还记不记得。”

回想自己儿时的样子，已和现在大不相同了；但想想昨天的自己，却与今天没什么差异。这不经意的改变，让我们已经是另一个样子了。

## 题目描述

赫尔德用一个长为 $r-l+1$ 的数列 $a$ 来描述自己性格的变化。但赫尔德记忆不好，她已经记不清 $a$ 了，只记得非负整数 $l,r$，其中 $l<r$。

不过，她还记得：

1.  $l\le a_i\le r$，且 $a_i$ 互不相同。换言之，$a$ 是一个 $l\sim r$ 的排列。
2.  对于所有 $1\le i\le r-l$，有 $\operatorname{popcount}(a_i \mathbin{\mathrm{xor}} a_{i+1})=1$。换言之，$a$ 中相邻的两个数二进制下只相差一位。

请你告诉她一个可能的 $a$，或告诉她其实不存在这样的 $a$。

## 说明/提示

**【样例解释 \#1、\#2、\#3】**

样例输出 \#1 和 \#2 对应同一个数列，即 $\{ 0, 1, 3, 2, 6, 7, 5, 4 \}$，它们均能获得该测试点 $100 \%$ 的分数。

样例输出 \#3 能获得该测试点 $40 \%$ 的分数。

----

**【数据范围】**

对于所有数据，保证 $0\le l<r\le 10^7$。

设 $n=r-l+1$。

| 子任务编号 | $ n \leq $ | 特殊限制 | 分数 |
|:---:|:---:|:---:|:---:|
| $1$ | $ 10 $ | — | $ 9 $ |
| $2$ | $ 20 $ | — | $ 9 $ |
| $3$ | $ 10^5 $ | $\textsf{A, B}$ | $ 10 $ |
| $4$ | $ 10^5 $ | $\textsf{A}$ | $ 10 $ |
| $5$ | $ 2000 $ | $\textsf{C}$ | $ 25 $ |
| $6$ | $ 5 \times 10^5 $ | $\textsf{D}$ | $ 20 $ |
| $7$ | $ 3 \times 10^6 $ | — | $ 10 $ |
| $8$ | — | — | $ 7 $ |



$\textsf A$：保证 $l=0$。

$\textsf B$：保证 $n$ 是 $2$ 的整数次幂。

$\textsf C$：保证 $l$ 是偶数，$r$ 是奇数。

$\textsf D$：本子任务有 5 个测试点，从所有 $n\ge 2\times 10^5$ 且有解的数据中随机生成。

---

即使一直在改变，赫尔德也许仍似儿时的自己。

## 样例 #1

### 输入

```
0 7
```

### 输出

```
Yes
0 1 3 2 6 7 5 4
```

## 样例 #2

### 输入

```
0 7
```

### 输出

```
yEs
0 abacaba
```

## 样例 #3

### 输入

```
0 7
```

### 输出

```
yes
```

## 样例 #4

### 输入

```
3 5
```

### 输出

```
No
```

# 题解

## 作者：dottle (赞：20)

我们给所有数减去 $l\sim r$ 的按位与。因为这些位没有影响。

我们给二进制下 1 个数为奇数的数涂上黑色，其余涂上白色。设 $r$ 的最高位是 $p=2^q$。

做好准备以后，先来看看两个显然无解的情况：

1.  答案排列一定是黑白相间的，所以如果原排列中黑色点的个数与白色点相差了 $2$ 及以上，那寄。
2.  如果 $l+p> r$，那大于等于 $p$ 的和小于 $p$ 的根本连不上。 

排除掉这两种情况后，其他的情况都是有解的。接下来，先介绍构造的方法，再来证明构造的充分性。

1.  答案排列可以分为两部分，左边一部分小于 $p$，右边一部分大于等于 $p$。

2.  若 $p-l$ 是奇数，则选取 $l$ 作为左边部分最后一个数，$l+p$ 作为右边部分第一个数。

    否则，选取 $r-p$ 作为左边部分最后一个数，$r$ 作为右边部分第一个数。

3.  确定好接口以后，只需解决此问题：构造 $0\sim m$ 的，以 $k$ 作为一个端点的符合要求的排列。

证明：

1. 对于 $0\sim n $ 的排列，考察其中的黑白点个数。若一样多，则任意数都可以作为端点，否则多的那一个数的任意数可以作为端点。

    充分性：仿造构造的方法归纳证明。

2. 左右只会有异色点连边，因为我们已经排除了左右无连边的情况，因此我们只会担心一种情况：

    - 仅有左侧黑色点连向右侧白色点的边，且左侧只能以白色开头，右侧只能以黑色开头。

    我们尝试说明这种情况是不存在的。

    首先考虑左右两侧数的个数，有一边是偶数的话上面已经说了不会有问题，那么考虑两边都是奇数的情况：

    我们证明此时，$(l,l+p)$ 一定满足条件：$l$ 显然可以作为左边的开头，因为 $l$ 右侧的数可以两两配对颜色不同，因此 $l$ 一定是较多的那个。不失一般性地认为 $l$ 是黑色。然后考虑对面那个白色点能否作为开头，可以，否则右边也是黑色点较多，就无解了。

3. 由上述论断，再加上 $l,l+p,r,r-p$ 这四个数一定都在 $[l,r]$ 内，我们就证明了一定可以选择个数为奇数一侧的端点作为开头。

接下来，我们给出构造 $0\sim m-1$ 的，以 $k$ 作为一个端点的符合要求的排列的方法。其充分性的归纳证明蕴含在此构造之中。

先介绍这样一个问题，构造 $0\sim M-1$ 的，**$0$ 开头**，$k$ 为**最后一个元素**的排列，其中 $M$ 是 $2$ 的次幂。设构造出的排列为 ${\rm build2^k}(M,k)$。

考虑 $k$ 与 $M/2$ 的大小关系：

1.  若 $k\ge M/2$，只需求出 ${\rm build2^k}(M/2,1)$ 和 ${\rm build2^k}(M/2,k~{\rm xor}~ (M/2+1))$，然后将后者全部异或上 $M/2+1$，然后拼接起来即可。

    例如：$M=8,k=7$

    ${\rm build2^k}(M/2,1)=\{0,2,3,1\}$

    ${\rm build2^k}(M/2,k~{\rm xor}~ (M/2+1))={\rm build2^k}(4,2)=\{0,1,3,2\}$

    ${\rm build2^k}(M,k)=\{0,2,3,1,0{~\rm xor~}5,1{~\rm xor~}5,3{~\rm xor~}5,2{~\rm xor~}5\}=\{0,2,3,1,5,4,6,7\}$

2.  若 $k<M/2$，只需求出 ${\rm build2^k}(M/2,k)$，然后 $a_1,a_1+M/2,a_2+M/2,a_2,\dots$ 这样拼起来即可。

    例如：$M=8,k=2$

    ${\rm build2^k}(M/2,k)=\{0,1,3,2\}$

    ${\rm build2^k}(M,k)=\{0,0+4,1+4,1,3,3+4,2+4,2\}=\{0,4,5,1,3,7,6,2\}$。

设构造出的排列为 ${\rm build}(m,k)$，此排列的**第一个元素**是 $k$。

考虑 $m-1$ 的最高位 $p=2^q$，分类讨论：

1.  若 $k\ge p$，先求出 $A={\rm build}(m-p,k-p)$，然后再求出 $B={\rm build2^k}(p,1)$，然后根据 $A$ 另一个端点的值 $x$，给 $B$ 全部异或上 $x$，再给 $A$ 全部加上 $p$，就可以了。

    例如：$m=6,k=4$

    $A={\rm build}(2,0)=\{0,1\}$

    $B={\rm build2^k}(4,1)=\{0,2,3,1\}$

    ${\rm build}(m,k)=\{0+4,1+4,0{~\rm xor~}1,2{~\rm xor~}1,3{~\rm xor~}1,1{~\rm xor~}1\}=\{4,5,1,3,2,0\}$

2.  若 $k<p$，设一个 01 变量 $o$。先求 $k$ 的黑白情况，如果是白色（$0$ 也是白色），那就令 $o=1$；否则 $o=0$。 求 ${\rm build2^k(p,k{~\rm xor~ }o)}$ 和 ${\rm build}(m-p,o)$ ，将前者异或上 $o$，后者加上 $p$，拼在一起即可。就不举例子了。

时间复杂度 $O(n)$。

```
#include<bits/stdc++.h>
using namespace std;
using vi=basic_string<int>;
#define rev(A) reverse(A.begin(),A.end())
void no(){cout<<"No"<<endl;exit(0);}
int l,r,n;
void yes(vi a){
	cout<<"Yes"<<endl;
	cout<<a[0]<<' ';
	string res;
	for(int i=1;i<a.size();i++)
		res+=(char)('a'+(int)log2(a[i]^a[i-1]));
    cout<<res;
	exit(0);
}

vi operator ^ (vi a,int b){for(auto&i:a)i^=b;return a;}

vi build(int n,int k){
	if(n==1)return {0};
	if(n==2)return {0,1};
	int _n=n>>1;
	if(k&_n)
		return build(_n,1)+(build(_n,k^_n^1)^_n^1);
	else{
		vi a=build(_n,k),res;
		for(int i=0;i<_n;i++)
			res+=a[i]^((i&1)*_n),res+=a[i]^((i+1&1)*_n);
		return res;
	}
}

vi buildn(int n,int k){
	int t=log2(n),_t=1<<t;
	if(_t==n)return build(n,1)^k;
	if(k&_t){
		vi x=buildn(n-_t,k-_t),y=build(_t,1);
		y=y^x.back();x=x^_t;
		return x+y;
	}else{
		int p=!(__builtin_popcount(k)&1);
		vi y=build(_t,k^p);y=y^p;rev(y);
		return y+(buildn(n-_t,p)^_t);
	}
}

int main(){
	cin>>l>>r;
	n=r-l+1;
	if(l==r)yes({l});
	
	int yu=~0;
	for(int i=l;i<=r;i++)yu&=i;
	l-=yu,r-=yu;
	int m=1<<(int)log2(r);
	
	int c=0;for(int i=l;i<=r;i++)c+=__builtin_popcount(i)&1;
	if(n<m||abs(c-(n-c))>1)no();
	
	int L=m-l,R=r-m+1,X;
	if((m-l)&1)X=l;else X=r-m;
	vi resA=buildn(L,m-1-X),resB=buildn(R,X);
	rev(resA);for(auto&x:resA)x=m-1-x;
	yes((resA+(resB^m))^yu);
}
```


---

## 作者：zhiyangfan (赞：8)

## P8553 醒来 题解
补充一点强大出题人多哥题解的细节。
### 题意
给出 $l,r$，构造出 $l\sim r$ 的排列 $p$，满足 $|p_i\operatorname{xor}p_{i+1}|=1(i\le r-l)$ 或报告无解，其中 $||$ 表示二进制下 $1$ 的个数，$\operatorname{xor}$ 表示按位异或。($0\le l<r\le 10^7$)

### 题解
首先强大出题人多哥写过一个构造任意长度格雷码的博客，[https://www.luogu.com.cn/blog/dottle/GrayCode](https://www.luogu.com.cn/blog/dottle/GrayCode)。这个故事告诉我们可以多翻一翻月赛出题人的博客。

我们不妨令 $l,r$ 中所有数二进制位下均无交集（如果一开始有交集就去掉，最后输出答案的时候加上即可）。这样在构造的时候会方便很多。

这道题可以从类似的思路切入，即考虑把序列分成长度为 $2^m$ 的部分和剩余部分。不过在此之前，我们先来看看怎么判断无解。

首先，让我们构造一张图 $G=(V,E)$，$V$ 中的元素是所有 $l,r$ 之间的整数，$(u,v)\in E$，当且仅当 $|u\operatorname{xor}v|=1$。即两点之间有边当且仅当它们在最终排列可以相邻。可以观察到这张图一定是二分图。（显然相邻的点二进制下 $1$ 的个数一定奇偶性不同，所以不可能出现奇环）则黑白染色后我们要找的一条经过所有点恰好一次的哈密顿路一定是黑白相间的，从而如果黑点个数与白点个数相差大于 $1$ 则一定无解。

还有什么情况是找不到哈密顿路的呢？图不连通的时候。图什么时候不连通呢？注意到 $l,r$ 之间所有数二进制下无交集，这样我们一定可以把 $[l,r]$ 分成 $[l,p-1],[p,r]$ 两个部分，其中 $p=2^{\lfloor\log_2 r\rfloor}$，即按最高位分组。因为无交集，所以两个区间之间的边只能由 $(x,x+p)(x<p)$ 来提供。这样一来，如果 $l+p>r$，即一条边都连不出来，显然前后不连通。

然后多哥就说这两个条件够了，证明比较复杂就没有讲，我也不会。但感觉下面的构造过程其实就能证了。~~猜完交一发发现拿到了 38 分的高分所以条件够了。~~

无解判掉之后我们就开始按照上述博客提供的切入点思考，即分成两个部分 $[l,p-1],[p,r]$。首先考虑这么分的两个区间内有没有解，注意到 $[p,r]$ 可以集体异或上 $p$ 变成 $[0,p\operatorname{xor}r]$，根据上面的博客，这个一定存在构造方案。类似地，$[l,p-1]$ 可以整体异或 $p-1$，从而得到 $[0,l\operatorname{xor}(p-1)]$。

然后是端点，即怎么把两个区间连起来。一种方法是，如果 $p-l$ 为奇数，则用 $l,l+p$ 连，否则用 $r-p,r$ 连。

在证明之前，我们先明确一点，那就是对于一个存在方案的区间，如果黑色数目等于白色数目，那任意一个点都可以作为端点，否则必须用多的那个颜色。证明还算简单吧，就跟多哥说的一样，仿造构造的方法归纳证明。然后对于上述结论的证明就可以分讨奇偶性解决了。

这样，我们的问题就转化成了，构造出一个 $[0,n]$ 的符合条件的排列，使得开头是 $x$。设这样的排列是 $\mathrm{seq}(n,x)$，则如果用 $x(x=l,r-p)$ 连，答案即为：
$$\mathrm{rev}(\mathrm{seq}(p-l,(p-1)\operatorname{xor}x)\operatorname{xor}(p-1))+(\mathrm{seq}(r-p+1,x)\operatorname{xor}p)$$
其中 $\rm rev$ 表示翻转序列，$+$ 可以表示序列拼接，$\operatorname{xor}$ 可以表示给序列整体异或上一个数。原因可以考虑上面对于存在性的证明反过来。

接下来就是求解 $\rm seq$ 了。在此之前，我们还想讨论一个更简单的情况，即 $\mathrm{seq_2}(m,x)$ 表示构造出一个 $[0,2^m-1]$ 的符合条件的排列，使得开头是 $0$ 结尾是 $x$。注意下文中利用 $\operatorname{xor}$ 对序列值域的平移。注意根据我们的黑白理论，这里应该要保证 $x$ 是黑色。
- 如果 $x<2^{m-1}$，令 $a=\mathrm{seq_2}(m-1,x)$，则可以构造出符合条件的序列 $\left<a_1,a_1+2^{m-1},a_2+2^{m-1},a_2,a_3,a_3+2^{m-1},\cdots\right>$。容易发现只要 $m>1$，最后一位一定是 $a_{|a|}$，即 $x$。$m\le 1$ 时排列只有一种情况。
- 如果 $x\ge 2^{m-1}$，此时考虑把整个序列分成两个子部分。从而像上面一样缩小 $m$：
  $$\mathrm{seq_2}(m-1,1)+(\mathrm{seq_2}(m-1,x\operatorname{xor}(2^{m-1}+1))\operatorname{xor}(2^{m-1}+1))$$
  这里异或的值是根据前一个序列的最后一个数是 $1$ 决定的。

然后我们进入正题，怎么构造 $\mathrm{seq}(n,x)$ 呢？刚刚的 $\rm seq_2$ 是我们为了上述博客的方法进行的准备工作，所以构造方案肯定也是类似的。为了方便，令 $q=\lfloor\log_2 m\rfloor,p=2^q$。
- 如果 $x\ge p$，则我们可以用 $\mathrm{seq}(n-p,k-p)\operatorname{xor} p$ 作为左半部分，$\mathrm{seq_2}(q,1)$ 作为右半部分。而连接部分，只需让后半部分异或上前半部分的最后一个元素即可。注意到后半部分是一整个 $0\sim 2^n-1$，所以异或上一个数还是同一个序列的排列。
- 如果 $x<p$，则略微复杂。我们要考虑一下黑白的问题。基本思路应该是 $\mathrm{rev}(\mathrm{seq_2}(q,k))+(\mathrm{seq}(n-p,0)\operatorname{xor}p)$。但问题在 $k$ 不一定是黑色。但我们可以调整一下，如果 $k$ 是白色，把式子变为 $\mathrm{rev}(\mathrm{seq_2}(q,k\operatorname{xor}1)\operatorname{xor}1)+(\mathrm{seq}(n-p,1)\operatorname{xor} p)$，依然合法。
- 当 $n$ 是 $2$ 的次幂时直接用 $\rm seq_2$ 算再翻转回来。

然后这题就做完了。最后别忘了把去掉的共同位异或回来。时间复杂度 $\mathcal{O}(n)$。
```cpp
#include <cstdio>
#include <vector>
typedef std::vector<int> vi;
vi operator+(const vi& x, const vi& y)
{
	vi ret; 
	for (auto& v : x) ret.push_back(v);
	for (auto& v : y) ret.push_back(v);
	return ret;
}
vi operator^(const vi& x, int y)
{
	vi ret;
	for (auto& v : x) ret.push_back(v ^ y);
	return ret;
}
vi rev(const vi& x)
{
	vi ret;
	for (int i = (int)x.size() - 1; ~i; --i) ret.push_back(x[i]);
	return ret;
}
vi build1(int m, int k)
{
	if (!m) return vi({0});
	if (m == 1) return vi({0, 1});
	int p = 1 << (m - 1); 
	if (k < p)
	{
		vi ret = build1(m - 1, k), ans; int now = 0;
		for (auto& v : ret)
		{
			if (!now) ans.push_back(v), ans.push_back(v + p);
			else ans.push_back(v + p), ans.push_back(v);
			now ^= 1;
		}
		return ans;
	}
	return build1(m - 1, 1) + (build1(m - 1, k ^ (p + 1)) ^ (p + 1));
}
vi build(int m, int k)
{
	if (!(m & (m - 1))) return build1(31 - __builtin_clz(m), 1) ^ k;
	int q = 31 - __builtin_clz(m), p = 1 << q;
	if (k >= p) 
	{
		vi ret = build(m - p, k - p); int x = ret.back();
		return (ret ^ p) + (build1(q, 1) ^ x);
	}
	int o = (__builtin_popcount(k) & 1) == 0;
	return rev(build1(q, k ^ o) ^ o) + (build(m - p, o) ^ p);
}
inline void print(const vi& x)
{
	puts("Yes");
	printf("%d ", x[0]);
	for (int i = 1; i < (int)x.size(); ++i) putchar('a' + 31 - __builtin_clz(x[i] ^ x[i - 1]));
	puts("");
}
int main()
{
	int l, r, n, cnt = 0, x; scanf("%d%d", &l, &r); n = r - l + 1;
	if (n == 1) return print({l}), 0;
	int t = l; for (int i = l + 1; i <= r; ++i) t &= i;
	l -= t; r -= t; int p = 1 << (31 - __builtin_clz(r));
	for (int i = l; i <= r; ++i) cnt += (__builtin_popcount(i) & 1) == 0;
	if (cnt - 1 > n - cnt || cnt + 1 < n - cnt || l + p > r) return puts("No"), 0;
	if ((p - l) & 1) x = l; else x = r - p;
	print((rev(build(p - l, (p - 1) ^ x) ^ (p - 1)) + (build(r - p + 1, x) ^ p)) ^ t); 
	return 0;
}
```

---

## 作者：FireBladeMaster (赞：2)

先看看怎么判断有无解。

多头告诉我们，显然 $l$ 和 $r$ 的公共前缀我们是不用考虑的，因为他们永远相同。

所以记 $l,r$ 是去掉公共前缀之后的值。

考虑 $r$ 的最高位，若有 $h+1$ 位，我们把区间拆分成 $[l,2^h-1]$ 和 $[2^h,r]$。

这样有什么性质呢，你发现两个区间中分别取出一个数相邻，那么他们的低 $h$ 位相同。

这启发我们构造一组解使得第一个区间是答案的前缀，第二个区间是后缀，并且交界处低位相同。

为什么这个是对的？可以先考虑有解的充分条件：
1. 要满足 $[l,r]$ 中 $\operatorname{popcount}$ 奇偶性为 $0,1$ 的个数差不超过 $1$。
2. 存在一个“交界处低位相同。”的值。如果不存在显然是构造不出来的。

然后两个区间都有性质，一个右端点最后 $h$ 位全是 $1$，一个左端点最后 $h$ 位全是 $0$，可以简单转换到 $[0,r']$ 的问题。


这样问题转换成在一段区间上并且指定序列的一个端点上的值 $v$，并且现在区间有个性质，$l=0$。

看上去还是很奇怪，我们仍然考虑新区间的 $h$。

如果 $v\ge 2^h$，我们可以先递归 $[2^h,v]$，然后用一次 $h$ 转换到 $[0,2^h-1]$，而这个是好做的，按照样例给的那个串就是可以的。

如果 $v<2^h$ 看上去就不是这么好做了，我们考虑先处理掉 $[0,2^h-1]$，然后再加入一个 $h$ 转到另一半。但是现在有个问题就是你处理完左半边之后要满足 $end+2^h\le r$。这个怎么办呢？

我们可以让 $end$ 尽量小。如果能是 $0$ 就取 $0$，否则就取 $1$。这一部分有个 AGC031C 是一样的。大致做法就是你仍然分成左右两边，如果在右边就 solve 右边然后加一个 $h$ solve 左边，如果在左边就先 solve 左边，然后在倒数第二个位置穿插一个 solve 右边，就好了。

这一堆奇奇怪怪的东西最后还是线性的……所以跑的飞快，是最优解。

```cpp
#ifndef ONLINE_JUDGE
#define DEBUG
#endif
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>
#include <math.h>
#include <set>
int read() {
    int x;
    scanf("%d", &x);
    return x;
}
char a[10000005], b[10000005];
int cc, dd;
void RG(int p, char *a, int &cc, int q = -1) {
    int pre = cc;

    for (int i = (1 << p); i >= 2; i--) {
        int f = (std::__lg(i & -i));

        if (i == (1 << p))
            f = p - 1;

        if (f == q)
            f = 0;
        else if (f == 0 && q >= 0)
            f = q;

        a[++cc] = 97 + f;
    }
}
void RG1(int p, char *a, int &cc) {
    int pre = cc;
    a[++cc] = 97 + (p) - 1;

    for (int i = 1; i < (1 << p); i++)
        a[++cc] = 97 + std::__lg(i & -i);
}
int solve(int r, int v, char *a, int &cc) {
    if (r == 0 || r == 1)
        return v;

    if (r == 2) {
        a[++cc] = 97;
        return v ^ 1;
    }

    int d = 1, p = 0;

    while ((d << 1) < r)
        d <<= 1, p++;

    if ((r & r - 1) == 0) {
        if (v >= r / 2) {
            RG(p, a, cc);
            a[++cc] = 97 + p;
            return solve(r / 2, (v ^ 1) & (d - 1), a, cc);
        } else {
            int rs = solve(r / 2, v, a, cc);
            int z = a[cc] - 97;
            a[cc] = 97 + p;
            RG(p, a, cc, z);
            a[++cc] = 97 + p;
            return rs;
        }
    }

    if (v >= d) {
        int end = solve(r - d, v - d, a, cc);
        a[++cc] = 97 + p;
        return solve(d, end, a, cc);
    }

    int P = __builtin_parity(v) ^ 1;

    a[++cc] = 97 + p;
    return d + solve(r - d, __builtin_parity(v) ^ 1, a, cc);
}
int l = read(), r = read(), F = 0;
signed main() {
    int h = 30;

    for (; h >= 0; h--) {
        if ((l ^ r) >> h & 1)
            break;

        F |= l & (1 << h);
    }

    h++;
    int L = l & ((1 << h) - 1);
    int R = r & ((1 << h) - 1);

    {
        int n = R - L + 1;
        int N = n * (n + 1) / 2;
        int C = 0;

        for (int i = L; i <= R; i++)
            if (__builtin_parity(i))
                C++;
            else
                C--;

        if (R - L >= (1 << h - 1) && (-1 <= C && C <= 1 | L == 0 || R == ((1 << h) - 1))) {
            puts("Yes");
            int fj = 1 << h - 1;
            int ls = 0, rs = 0;

            for (int i = L; i < fj; i++)
                if (__builtin_parity(i))
                    ls++;
                else
                    ls--;

            for (int i = fj; i <= R; i++)
                if (__builtin_parity(i))
                    rs++;
                else
                    rs--;

            for (int i = L; i + (1 << h - 1) <= R; i++) {
                int I = i, J = i + (1 << h - 1);

                if (__builtin_parity(I) * 2 - 1 == -ls)
                    continue;

                if (__builtin_parity(J) * 2 - 1 == -rs)
                    continue;

                int A = solve(fj - L, fj - 1 - I, a, cc) ^ ((1 << h - 1) - 1);
                int B = solve(R - fj + 1, J - fj, b, dd);
                std::reverse(a + 1, a + 1 + cc);
                printf("%d ", A |= F);
                printf("%s%c%s\n", a + 1, 97 + h - 1, b + 1);
                break;
            }
        }

        else {
            puts("No");
        }
    }
    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

首先考虑对 $0\sim 2^n-1$ 的情况。不难发现构造是极其容易的，大概可以使用分治。我们尝试去加强这个结论，下面说明我们可以做到**构造一个以 $0$ 开头，$k$ 结尾的合法序列**（$k\neq 0$）

证明如下：

- 如果 $k<2^{n-1}$，构造 $[p_0,p_1,\dots,p_{2^{n-1}-1}]$ 为 $0\sim 2^{n-1}-1$，且以 $0$ 开头，$k$ 结尾的数列。那么，我们只需要往 $(p_0,p_1),(p_2,p_3),\dots$ 中间插入左右两个数加上 $2^{n-1}$ 即可满足。
- 如果 $k\geq 2^{n-1}$，构造一个以 $0$ 开头，$1$ 的 $0\sim 2^{n-1}-1$ 的排列，然后构造以 $1$ 开头，$k-2^{n-1}$ 的 $0\sim 2^{n-1}-1$ 的排列，把后面排列每个元素异或 $2^{n-1}+1$ 再拼接起来即可。

这说明任意不同的数作为开头，结尾都是可行的。

然后考虑 $0\sim x$ 这种情况，如果 $\text{popcount}(x)$ 为奇数就把 $x$ 染黑，否则染白色。那么我们说明：**我们可以找到一个以 $x$ 开头的合法序列，当且仅当 $x$ 的颜色的数量不少于 $x$ 的反色的数量**。

证明如下：假设我们需要以 $x$ 为开头，并且假设 $n=2^k+r$（$r<2^k$），$p(n)$ 表示 $\text{popcount(n)}$ 的奇偶性，那么：

- 如果 $x<2^k$，那么先随便构造一个以 $f(r)$ 为结尾的 $0\sim r-1$ 的合法排列。然后构造一个以 $f(r)$ 开头，$x$ 结尾的 $0\sim 2^k-1$ 的合法排列，把前面的排列集体加上 $2^k$ 即可。
- 如果 $x\geq 2^k$，那么构造一个以 $x-2^k$ 作为结尾的 $0\sim r-1$ 的合法排列，假设开头是 $t$，构造一个 $t$ 结尾的 $0\sim 2^k-1$ 的合法排列即可，前面的加上 $2^k$，把后面的拼接上前面的即可。

最后考虑区间的情况，我们把 $l\sim r$ 之间所有数二进制下的 lcp 去掉，这样子就必然存在一个 $k$ 使得 $l<2^k\leq r$。

我们不难发现如果满足一下两种条件之一是不可能存在合法序列的：

- 黑白数字相差 $\geq 2$；
- $l+2^k>r$（这样子 $[l,2^k-1]$ 和 $[2^k,r]$ 不连通）。

如果这两个条件都不满足，我们总可以构造一下两对合法排列之一：

- 以 $l$ 结尾，$[l,2^k-1]$ 的排列拼接 $l+2^k$ 开头，$[2^k,r]$ 的排列；
- 以 $r-2^k$ 结尾，$[l,2^k-1]$ 的排列凭借 $r$ 开头，$[2^k,r]$ 的排列。

这些构造总能转成 $l=0$ 的形式。

于是这题就做完了，时间复杂度 $T(n)=T(n/2)+\mathcal O(n)=\mathcal O(n)$。 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
#define vint basic_string<int>
mt19937 rnd(time(0));
vint operator ^(vint a,int x){for(auto &i:a)i^=x;return a;}
void rev(vint &a){reverse(a.begin(),a.end());}
vint build(int n,int k){
	// 构造一个长度为 2^n，以 0 开始，k 结尾的序列
	if(n==0) return {0};
	if(n==1) return {0,1};
	if(k<(1<<n-1)){
		vint tmp=build(n-1,k),ans;
		for(int i=0;i<(1<<n-1);i++){
			ans+=(tmp[i]^((i&1)<<n-1)),ans+=(tmp[i]^((i+1&1)<<n-1));
		}
		return ans;
	}else{
		return build(n-1,1)+(build(n-1,k^(1<<n-1)^1)^((1<<n-1)^1));
	}
}
vint buildn(int n,int k){
	// 构造一个长度为 n，值域为 [0,n-1]，且以 k 开头的数列
	int t=log2(n),m=1<<t;
	if(m==n) return build(t,1)^k;
	if(k<m){
		int p=~__builtin_popcount(k)&1;
		vint le=build(t,k^p)^p,ri=buildn(n-m,p)^m;rev(le);
		return le+ri;
	}else{
		vint le=buildn(n-m,k-m),ri=build(t,1)^le.back();
		return (le^m)+ri;
	}
}
int main(){
	ios::sync_with_stdio(false);
	int l,r;cin>>l>>r;
	int n=r-l+1,fl=-1,c=0;
	for(int i=l;i<=r;i++) fl&=i,c+=(__builtin_popcount(i)&1);
	l-=fl,r-=fl;
	int q=log2(r),p=1<<q;
	if(l+p>r||abs(n-2*c)>1){
		cout<<"No\n";
		return 0;
	}
	cout<<"Yes\n";
	int L=p-l,R=r-p+1,X;
	if(L&1) X=l; else X=r-p;
	vint le=buildn(L,X^(p-1))^(p-1),ri=buildn(R,X)^p;
	rev(le);
	le+=ri;le=le^fl;
	cout<<le[0]<<' ';
	for(int i=0;i<n-1;i++) cout<<(char)('a'+__builtin_ctz(le[i]^le[i+1]));cout<<endl;
	return 0;
}
```

---


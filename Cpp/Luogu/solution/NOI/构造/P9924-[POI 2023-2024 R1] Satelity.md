# [POI 2023/2024 R1] Satelity

## 题目背景

译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Satelity](https://sio2.mimuw.edu.pl/c/oi31-1/p/sat/)。

## 题目描述

有 $2n$ 个卫星，$1\sim n$ 属于 A 公司，$n+1\sim 2n$ 属于 B 公司。

两个卫星**应当**能够通信**当且仅当**它们属于同一个公司或者有额外要求。

你需要给每个卫星分配一个等长的**独一无二**的识别码，识别码应当只包含字母 `ABC`，两个卫星**实际**能够通信**当且仅当**识别码有至少一位相同。要求你的识别码方案满足要求。输出你的方案。

## 说明/提示

单个输入文件不超过 40MB，请使用较快的输入输出方式。

对于所有测试点，$1\leq\sum n\leq 2\times 10^6$，$1\leq\sum n^2\leq10^7$。

对于所有数据，$2\leq n\leq1000$，$1\leq p\leq n^2$。

| 子任务编号 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n\leq100$，$M=n^2+2n$ | 7 |
| 2 | $M=3n$ | 11 |
| 3 | $M=n+2\lceil\log_2n\rceil$ | 23 |
| 4 | $M=n+2$ | 41 |
| 5 | $M=n+1$ | 18 |

## 样例 #1

### 输入

```
3 4 4
1 4
2 6
3 4
3 6
```

### 输出

```
3
ABA
AAC
BAA
BBB
CCB
BCC
```

## 样例 #2

### 输入

```
见附件```

### 输出

```
见附件```

## 样例 #3

### 输入

```
见附件```

### 输出

```
见附件```

## 样例 #4

### 输入

```
2 1 4
1 4
```

### 输出

```
2
AB
AC
BA
BB
```

# 题解

## 作者：_•́へ•́╬_ (赞：12)

wyr 巨。

被 hack 后参考了官方题解进行优化。

第零个包里有几个点是我和 wyr 加的 hack，都很小，$M=n+1$。

## 思路

不要求互不相同是简单的。对于一个卫星，新开一列识别码，同公司填 `A`，自己和有边的填 `B`，没边的填 `C`。埋个伏笔：这里有 A 对 B 和 B 对 A 两种方法。

直接在识别码后面加编号的二进制表示可以做到 $n+2\log n$。

考虑缩等价类。两个等价类之间识别码一定不同，等价类之内一定相同。然后给每个卫星加上自己在等价类内的编号即可。需要消耗的长度为 $\log\max sz_A+\log\max sz_B$。

（式子自带上取整，$\log$ 底数为 $2$）

令 A 公司的等价类个数为 $l$，B 为 $r$。缩等价类后需要的长度为 $\min(l,r)$。取 $\min$ 是因为有两种方法。下面不妨令 $l\leq r$。

（下面开始搬运官方题解）

令 $\alpha=n+1-l$。有 $\max sz_A+(l-1)\leq \sum sz_A=n$ 即 $\max sz_A\leq \alpha$。

- 当 $\max sz_B=1$ 时，$m\leq\log\alpha+l{\color{red}{}+1}=(\log\alpha-\alpha+1)+n+1\leq n+2$。红色的 ${}+1$ 是为了保证公司内部的卫星必须能通信。
- 当 $\max sz_B>1$ 时，还有 $\max sz_B\leq n+1-r\leq n+1-l$。所以 $m=\log\max sz_A+\log\max sz_B+l\leq2\log\alpha+l=(2\log\alpha-\alpha)+n+1\leq n+2$。

这样我们就几乎解决了这道题。上面那两坨，能卡到 $n+2$ 当且仅当 $\alpha\in\{3,5\}$，并且 $l=r=n+1-\alpha$ 且两个公司都有且仅有一个等价类大小为 $\alpha$，其他等价类大小为 $1$。对于这两个 case 特殊构造一下即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/e3p206qu.png)

## code

```cpp
#include<stdio.h>
#include<bitset>
#define N 2029
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline int read(int&x)
{
	char c=nc();for(;(c<'0'||'9'<c)&&(c^EOF);c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());return c==EOF;
}
int n,p,lim,m,f[N],id[N],cnt[N],l,r;std::bitset<N>v[N];char s[N][N];
inline void max(int&x,int y){if(x<y)x=y;}
main()
{
	if(read(n))return 0;
	read(p);read(lim);m=0;
	for(int i=0;i<n<<1;v[i++].reset());
	l=r=0;for(int i=0;i<n<<1;id[i]=cnt[i]=f[i]=0,++i);
	for(int u,v;p--;read(u),read(v),--u,--v,::v[u][v]=::v[v][u]=1);
	for(int i=0;i<n;l+=i==f[i],id[i]=cnt[f[i]]++,++i)
		for(f[i]=0;v[i]!=v[f[i]];++f[i]);
	for(int i=n;i<n<<1;r+=i==f[i],id[i]=cnt[f[i]]++,++i)
		for(f[i]=n;v[i]!=v[f[i]];++f[i]);
	if(l<r)
	{
		for(int i=0;i<n;++i)if(i==f[i])
		{
			for(int j=0;j<n;++j)s[j][m]='A'+(f[i]==f[j]);
			for(int j=n;j<n<<1;++j)s[j][m]='C'-v[i][j];++m;
		}
		l=r=0;for(int i=0;i<n<<1;++i)max(i<n?l:r,id[i]);
		if(l)for(int o=32-__builtin_clz(l);o--;)
		{
			for(int i=n;i<n<<1;++i)s[i][m]='A';
			for(int i=0;i<n;++i)s[i][m]='B'+(id[i]>>o&1);++m;
		}
		if(r)for(int o=32-__builtin_clz(r);o--;)
		{
			for(int i=0;i<n;++i)s[i][m]='A';
			for(int i=n;i<n<<1;++i)s[i][m]='B'+(id[i]>>o&1);++m;
		}
		else
		{
			for(int i=0;i<n;++i)s[i][m]='A';
			for(int i=n;i<n<<1;++i)s[i][m]='B';++m;
		}
	}
	else
	{
		for(int i=n;i<n<<1;++i)if(i==f[i])
		{
			for(int j=n;j<n<<1;++j)s[j][m]='A'+(f[i]==f[j]);
			for(int j=0;j<n;++j)s[j][m]='C'-v[i][j];++m;
		}
		l=r=0;for(int i=0;i<n<<1;++i)max(i<n?l:r,id[i]);
		if(l)for(int o=32-__builtin_clz(l);o--;)
		{
			for(int i=n;i<n<<1;++i)s[i][m]='A';
			for(int i=0;i<n;++i)s[i][m]='B'+(id[i]>>o&1);++m;
		}
		else
		{
			for(int i=0;i<n;++i)s[i][m]='A';
			for(int i=n;i<n<<1;++i)s[i][m]='B';++m;
		}
		if(r)for(int o=32-__builtin_clz(r);o--;)
		{
			for(int i=0;i<n;++i)s[i][m]='A';
			for(int i=n;i<n<<1;++i)s[i][m]='B'+(id[i]>>o&1);++m;
		}
		if(m>lim)
		{
			m=0;int laoda;
			for(int i=0;i<n;++i)if(i==f[i])if(cnt[i]==1)
			{
				for(int j=0;j<n;++j)s[j][m]='A'+(i==f[j]);
				for(int j=n;j<n<<1;++j)s[j][m]='C'-v[i][j];++m;
			}
			else laoda=i;
			if(l==2)//alpha=3
			{
				for(int j=0;j<n;++j)s[j][m]='A'+(f[j]==laoda&&id[j]<2);
				for(int j=n;j<n<<1;++j)s[j][m]='C'-v[laoda][j];++m;
				for(int j=0;j<n;++j)s[j][m]='A'+(f[j]==laoda&&id[j]);
				for(int j=n;j<n<<1;++j)s[j][m]='C'-v[laoda][j];++m;
			}
			else//alpha=5
			{
				for(int j=0;j<n;++j)s[j][m]='A'+(f[j]==laoda&&id[j]<3);
				for(int j=n;j<n<<1;++j)s[j][m]='C'-v[laoda][j];++m;
				for(int j=0;j<n;++j)s[j][m]='A'+(f[j]==laoda&&id[j]&&id[j]<4);
				for(int j=n;j<n<<1;++j)s[j][m]='C'-v[laoda][j];++m;
				for(int j=0;j<n;++j)s[j][m]='A'+(f[j]==laoda&&id[j]>1);
				for(int j=n;j<n<<1;++j)s[j][m]='C'-v[laoda][j];++m;
			}
			if(r)for(int o=32-__builtin_clz(r);o--;)
			{
				for(int i=0;i<n;++i)s[i][m]='A';
				for(int i=n;i<n<<1;++i)s[i][m]='B'+(id[i]>>o&1);++m;
			}
		}
	}
	for(int i=0;i<n<<1;s[i++][m]=0);
	printf("%d\n",m);
	for(int i=0;i<n<<1;printf("%s\n",s[i++]));
	main();
}
```

---

## 作者：DaiRuiChen007 (赞：11)

[Problem Link](https://www.luogu.com.cn/problem/P9924)

**题目大意**

> 给定左右各 $n$ 个点，$m$ 条边二分图，给每个点构造长度为 $n+1$ 的字符串（字符集 $\texttt{A,B,C}$），使得：
>
> - 两个字符串之间存在至少一位相等当且仅当对应的两个节点属于二分图同一侧，或者有边相连。
> - 字符串两两不同。
>
> 数据范围：$n\le 1000,m\le n^2$。

**思路分析**

一个朴素的做法是对左部点 $1\sim n$，给第 $i$ 个串第 $i$ 位填 $\texttt C$，其他填 $\texttt A$。

对于每个右部点，如果其和左部第 $i$ 个点有边，填 $\texttt{C}$，否则填 $\texttt B$。

第 $0$ 位左部点填 $\texttt A$，右部点填 $\texttt B$ ，这样一个长度为 $n+1$ 的串就能得到答案。

但此时我们无法保证每个右部点字符串两两不同，我们可以额外用 $\lceil\log_2 n\rceil$ 位对第 $i$ 个右部点表示 $i$ 的二进制表示（用 $\texttt{B,C}$ 代替 $0,1$），且左部点这些位填 $\texttt A$。

这样的的串长是 $n+1+\lceil\log_2n\rceil$ 的，无法通过。

考虑什么样的右部点会得到相同的字符串，当且仅当他们的邻域相同，把这些点称为“等价类”。

注意到只有同一个等价类中的点才需要区分，因此我们可以直接传递其在等价类中排名的二进制表示，而不是 $i$ 的二进制表示。

那么假设右部点最大的等价类大小是 $R_s$，那么我们只要 $n+1+\lceil\log_2 R_s\rceil$ 个位，但这不够，需要继续优化。

考虑把左部点的等价类也划分出来，容易发现一个等价类可以共用一个位置填 $\texttt C$，但我们要对相同的。

那么设左、右部点的等价类数量是 $L_c,R_c$，等价类大小最大为 $L_s,R_s$。

那么花费位数为 $L_c+\lceil \log_2L_s\rceil+\lceil\log_2 R_s\rceil$，在 $R_c<L_c$ 的时候可以交换左右部点得到更优的次数。

综上我们得到的花费位数为 $\min(L_c,R_c)+\lceil \log_2L_s\rceil+\lceil\log_2 R_s\rceil$。

分析一下这个东西的量级，注意到 $L_s\le n-L_C+1\le n-\min(L_c,R_c)+1$。

因此设 $x=n-\min(L_c,R_c)+1$，那么花费位数不超过 $n-x+1+2\lceil \log_2x\rceil$。

当 $x\ge 2\lceil\log_2x\rceil$ 时花费位数 $\le n+1$。

我们只要考虑 $x<2\lceil\log_2x\rceil$ 的情况，发现此时一定有 $x=3/x=5$。

不妨设 $x=3$，那么此时左右部点都是 $n-3$ 个大小为 $1$ 的等价类和一个大小为 $3$ 的等价类。

考虑左部大小为 $3$ 的等价类 $\{x,y,z\}$，我们需要 $1$ 个位传递其连边信息，并且需要 $2$ 个位区分标号。

如果我们对每个点分别传递连边信息，那么不需要区分标号，但是要 $3$ 个位传递连边。

结合一下两种做法，第一位传递 $x,y$ 的连边信息，第二位传递 $y,z$ 的连边信息，此时两次传递即可令所有字符串不同。

对 $x=5$ 的情况类似，对于五元等价类 $\{a,b,c,d,e\}$，第一位传递 $a,b,c$，第二位传递 $c,d,e$，第三位传递 $b,d$ 即可。

综上，我们得到了串长 $\le n+1$ 时完整的构造方案。

时间复杂度 $\mathcal O(n^2+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int MAXN=2005;
int n,m,lim,id[MAXN];
vector <int> G[MAXN],lq[MAXN],rq[MAXN];
string s[MAXN];
mt19937_64 rnd(time(0));
ull hs[MAXN],hv[MAXN];
bool vis[MAXN];
int lg(int x) { return __lg(x)+!!(x&(x-1)); }
void solve() {
	for(int i=0;i<2*n;++i) {
		G[i].clear(),s[i].clear();
		lq[i].clear(),rq[i].clear();
		vis[i]=false,hs[i]=0,id[i]=-1;
	}
	for(int i=1,u,v;i<=m;++i) {
		cin>>u>>v,--u,--v;
		G[u].push_back(v),hs[u]^=hv[v];
		G[v].push_back(u),hs[v]^=hv[u];
	}
	cout<<lim<<"\n";
	for(int i=0;i<2*n;++i) s[i]=string(lim,(i<n?'A':'B'));
	int lc=0,rc=0,ls=0,rs=0;
	for(int i=0;i<n;++i) if(id[i]<0) {
		for(int j=i;j<n;++j) if(hs[i]==hs[j]) {
			id[j]=lc,lq[lc].push_back(j);
		}
		ls=max(ls,(int)lq[lc++].size());
	}
	for(int i=n;i<2*n;++i) if(id[i]<0) {
		for(int j=i;j<2*n;++j) if(hs[i]==hs[j]) {
			id[j]=rc,rq[rc].push_back(j);
		}
		rs=max(rs,(int)rq[rc++].size());
	}
	int len=min(lc,rc)+lg(ls)+lg(rs);
	if(len>lim) {
		assert(ls==rs&&lc==n-ls+1&&rc==n-rs+1&&(ls==3||ls==5));
		int k=0,x=lg(ls),y=lg(rs);
		for(int i=0;i<lc;++i) if(lq[i].size()>1) k=i;
		if(ls==3) {
			//ls=rs=3,lc=rc=n-2
			for(int i=0;i<n;++i) if(id[i]!=k) s[i][id[i]]='C';
			int a=lq[k][0],b=lq[k][1],c=lq[k][2];
			s[a][k]=s[b][k]=s[b][lc]=s[c][lc]='C';
			for(int i=n;i<2*n;++i) for(int j:G[i]) {
				s[i][id[j]]='C';
				if(id[j]==k) s[i][lc]='C';
			}
		} else {
			//ls=rs=5,lc=rc=n-4
			for(int i=0;i<n;++i) if(id[i]!=k) s[i][id[i]]='C';
			int a=lq[k][0],b=lq[k][1],c=lq[k][2],d=lq[k][3],e=lq[k][4];
			s[a][k]=s[b][k]=s[c][k]='C';
			s[c][lc]=s[d][lc]=s[e][lc]='C';
			s[b][lc+1]=s[d][lc+1]='C';
			for(int i=n;i<2*n;++i) for(int j:G[i]) {
				s[i][id[j]]='C';
				if(id[j]==k) s[i][lc]=s[i][lc+1]='C';
			}
		}
		for(int o=0;o<rc;++o) for(int i=0;i<(int)rq[o].size();++i) {
			for(int j=0;j<y;++j) {
				s[rq[o][i]][j+lc+x-1]="BC"[i>>j&1];
			}
		}
	} else if(lc<rc) {
		for(int i=0;i<n;++i) s[i][id[i]]='C';
		for(int i=n;i<2*n;++i) {
			for(int j:G[i]) s[i][id[j]]='C';
		}
		int x=lg(ls),y=lg(rs);
		for(int o=0;o<lc;++o) for(int i=0;i<(int)lq[o].size();++i) {
			for(int j=0;j<x;++j) {
				s[lq[o][i]][j+lc]="AC"[i>>j&1];
			}
		}
		for(int o=0;o<rc;++o) for(int i=0;i<(int)rq[o].size();++i) {
			for(int j=0;j<y;++j) {
				s[rq[o][i]][j+lc+x]="BC"[i>>j&1];
			}
		}
	} else {
		for(int i=n;i<2*n;++i) s[i][id[i]]='C';
		for(int i=0;i<n;++i) {
			for(int j:G[i]) s[i][id[j]]='C';
		}
		int x=lg(ls),y=lg(rs);
		for(int o=0;o<lc;++o) for(int i=0;i<(int)lq[o].size();++i) {
			for(int j=0;j<x;++j) {
				s[lq[o][i]][j+rc]="AC"[i>>j&1];
			}
		}
		for(int o=0;o<rc;++o) for(int i=0;i<(int)rq[o].size();++i) {
			for(int j=0;j<y;++j) {
				s[rq[o][i]][j+rc+x]="BC"[i>>j&1];
			}
		}
	}
	for(int i=0;i<2*n;++i) cout<<s[i]<<"\n";
}
signed main() {
	for(int i=0;i<MAXN;++i) hv[i]=rnd();
	ios::sync_with_stdio(false);
	while(cin>>n>>m>>lim) solve();
	return 0;
}
```

---

## 作者：happybob (赞：2)

题意：给定三个整数 $n,m,k$ 以及 $m$ 个二元组 $(x,y)$。你需要构造 $2n$ 个**互不相同且长度相等的**长度不超过 $k$ 的只包含 ABC 的字符串，前 $n$ 个是公司 A 的字符串，后 $n$ 个是公司 B 的字符串。你要使得公司 A 的任意两个字符串至少有一个位置相同，公司 B 同理。同时对于给定的所有 $(x,y)$，公司 A 的第 $x$ 个和公司 B 的第 $y$ 个的字符串也要有相同的位置。其余的 $n^2-m$ 种都没有相同的位置。多测。

范围：$\sum \limits n^2 \leq 10^7$，$k \geq n+1$。

解法：

假如没有互不相同怎么做？

考虑先花费 $1$ 的操作，左侧都是 A，右侧都是 B。此时两侧内部都连通。然后对于左侧每个点，选择其为 A，左侧其他点为 B，右侧和其连通的点也是 A，其他是 C。这样我们就可以做到 $n+1$ 的长度。

然而这样做可能存在相同的字符串。一个简单的想法是我们考虑二进制，考虑左侧每个点二进制每一位，此时右侧全选 C，左侧二进制下是 $1$ 的填 A，不是的就填 B，注意到此时我们之前的给两边同时编 A 和 B 的操作就不需要了，总花费 $n+2\lceil \log_2 n\rceil$，期望得分 $41$。

然后我们发现，对于左侧每个点，如果其右侧相邻的点相同，他们可以在一起编号，我们称这些点是一个等价类。

不妨设左侧等价类个数小于等于右侧（因为我们可以交换两侧），左侧等价类个数为 $a$，右侧等价类个数为 $b$，左侧最大等价类大小为 $y$，右侧最大等价类大小为 $z$。

则现在我们需要的长度是 $a+\lceil \log_2 y\rceil + \lceil \log_2 z\rceil$。

注意到 $y \leq n-a+1$，而 $z \leq n-b+1$，由于 $a \leq b$，所以 $z \leq n-a+1$。总长度 $\leq a+2\lceil \log_2 (n-a+1)\rceil$。

令 $c=n-a+1$，则总长度为 $n+1-c + 2\lceil \log_2 c \rceil$，当且仅当 $2 \lceil \log_2 c \rceil - c > 0$ 时长度会超限。容易发现此时 $c=3$ 或者 $c=5$。

对着 $c=3$ 和 $c=5$ 手玩一下即可，其他都用上述做法。然而有问题在于我们是不是没保证左右两侧内部连通？因为如果一侧等价类最大大小等于 $1$，那么这一侧就没有进行二进制编号了。细想发现这种情况成立当且仅当一侧有两个等价类，另一侧有 $n$ 个等价类。分类讨论一下即可。

Corner case 很多，放一个代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cassert>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
using namespace std;

const int N = 4005;

int n, m, p;
int idx;
string ans1[N], ans2[N];
vector<int> G[N], dd1[N], dd2[N];
int id[N], d1, d2;
bool rev = 0;

void output()
{
	cout << ans1[1].size() << "\n";
	if (!rev)
	{
		for (int i = 1; i <= n; i++)
		{
			cout << ans1[i] << "\n";
		}
		for (int i = 1; i <= n; i++)
		{
			cout << ans2[i] << "\n";
		}
	}
	else
	{
		for (int i = 1; i <= n; i++)
		{
			cout << ans2[i] << "\n";
		}
		for (int i = 1; i <= n; i++)
		{
			cout << ans1[i] << "\n";
		}
	}
}

bool vis[N];

int main()
{
	int cc = 0;
	ios::sync_with_stdio(0), cin.tie(0);
	while (cin >> n >> m >> p)
	{
		rev = 0;
		cc++;
		for (int i = 1; i <= 2 * n; i++)
		{
			ans1[i] = ans2[i] = "";
			G[i].clear(), G[i].shrink_to_fit();
			id[i] = vis[i] = 0;
			dd1[i].clear(), dd2[i].clear();
		}
		d1 = d2 = 0;
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			cin >> u >> v;
			G[u].emplace_back(v);
			G[v].emplace_back(u);
		}
		for (int i = 1; i <= n; i++)
		{
			if (id[i]) continue;
			id[i] = ++d1;
			dd1[d1].emplace_back(i);
			for (int j = i + 1; j <= n; j++)
			{
				if (G[i] == G[j]) id[j] = d1, dd1[d1].emplace_back(j);
			}
		}
		for (int i = n + 1; i <= 2 * n; i++)
		{
			if (id[i]) continue;
			id[i] = ++d2;
			dd2[d2].emplace_back(i);
			for (int j = i + 1; j <= 2 * n; j++)
			{
				if (G[i] == G[j]) id[j] = d2, dd2[d2].emplace_back(j);
			}
		}
		if (d1 > d2)
		{
			rev = 1;
			for (int i = 1; i <= n; i++)
			{
				swap(dd1[i], dd2[i]);
				swap(id[i], id[i + n]);
				swap(G[i], G[i + n]);
				for (auto& j : G[i]) j += n;
				for (auto& j : G[i + n]) j -= n;
				for (auto& j : dd1[i]) j -= n;
				for (auto& j : dd2[i]) j += n;
			}
			swap(d1, d2);
		}
		// corner case:
			//special: when x=3
		int m1 = 0, m2 = 0;
		for (int i = 1; i <= d1; i++) m1 = max(m1, (int)dd1[i].size());
		for (int i = 1; i <= d2; i++) m2 = max(m2, (int)dd2[i].size());
		if (m1 == m2 && m1 == 3 && m2 == 3 && d1 == n - 2 && d2 == n - 2) // 3 1 1 …… 3 1 1 ……
		{
			for (int i = 1; i <= d1; i++)
			{
				if (dd1[i].size() == 1) ans1[dd1[i][0]] += "B";
				else
				{
					ans1[dd1[i][0]] += "A";
					ans1[dd1[i][1]] += "A";
					ans1[dd1[i][2]] += "B";
					for (auto& j : G[dd1[i][0]]) vis[j - n] = 1;
				}
			}
			for (int i = 1; i <= n; i++)
			{
				if (vis[i]) ans2[i] += "A";
				else ans2[i] += "C";
				vis[i] = 0;
			}
			for (int i = 1; i <= d1; i++)
			{
				if (dd1[i].size() == 1) ans1[dd1[i][0]] += "B";
				else
				{
					ans1[dd1[i][0]] += "B";
					ans1[dd1[i][1]] += "A";
					ans1[dd1[i][2]] += "A";
					for (auto& j : G[dd1[i][0]]) vis[j - n] = 1;
				}
			}
			for (int i = 1; i <= n; i++)
			{
				if (vis[i]) ans2[i] += "A";
				else ans2[i] += "C";
				vis[i] = 0;
			}
			for (int i = 1; i <= d1; i++)
			{
				if (dd1[i].size() != 1) continue;
				int x = dd1[i][0];
				for (int j = 1; j <= 2 * n; j++) vis[j] = 0;
				for (int j = 1; j <= n; j++)
				{
					if (j == x) ans1[j] += "B";
					else ans1[j] += "A";
				}
				for (auto& j : G[x]) vis[j] = 1;
				for (int j = 1; j <= n; j++)
				{
					if (vis[j + n]) ans2[j] += "B";
					else ans2[j] += "C";
				}
			}
			for (int i = 1; i <= n; i++) ans1[i] += "AA";
			for (int i = 1; i <= d2; i++)
			{
				if (dd2[i].size() == 1) ans2[dd2[i][0] - n] += "CC";
				else
				{
					ans2[dd2[i][0] - n] += "BC";
					ans2[dd2[i][1] - n] += "CB";
					ans2[dd2[i][2] - n] += "CC";
				}
			}
			output();
			continue;
		}
		else if (m1 == m2 && m1 == 5 && m2 == 5 && d1 == n - 4 && d2 == n - 4)
		{
			for (int i = 1; i <= d1; i++)
			{
				if (dd1[i].size() == 5)
				{
					ans1[dd1[i][0]] += "ABB";
					ans1[dd1[i][1]] += "AAB";
					ans1[dd1[i][2]] += "BAA";
					ans1[dd1[i][3]] += "BBA";
					ans1[dd1[i][4]] += "BAB";
					for (auto& j : G[dd1[i][0]]) vis[j] = 1;
				}
				else
				{
					ans1[dd1[i][0]] += "BBB";
				}
			}
			for (int i = 1; i <= n; i++)
			{
				if (vis[i + n]) ans2[i] += "AAA";
				else ans2[i] += "CCC";
			}
			for (int i = 1; i <= d1; i++)
			{
				if (dd1[i].size() == 5) continue;
				for (int j = 1; j <= n; j++)
				{
					if (j != dd1[i][0]) ans1[j] += "A";
					else ans1[j] += "B";
				}
				for (int j = 1; j <= 2 * n; j++) vis[j] = 0;
				for (auto& j : G[dd1[i][0]]) vis[j] = 1;
				for (int j = 1; j <= n; j++)
				{
					if (vis[j + n]) ans2[j] += "B";
					else ans2[j] += "C";
				}
			}
			for (int i = 1; i <= n; i++) ans1[i] += "AAA";
			for (int i = 1; i <= d2; i++)
			{
				if (dd2[i].size() == 1) ans2[dd2[i][0] - n] += "CCC";
				else
				{
					ans2[dd2[i][0] - n] += "BBB";
					ans2[dd2[i][1] - n] += "BBC";
					ans2[dd2[i][2] - n] += "CBB";
					ans2[dd2[i][3] - n] += "CBC";
					ans2[dd2[i][4] - n] += "BCB";
				}
			}
			output();
			continue;
		}
		//cout<<"ok\n";
		//cout << "??: " << d1 <<"\n";
		int maxn = 0;
		for (int i = 1; i <= d1; i++)
		{
			for (int j = 1; j <= n; j++) vis[j] = 0;
			bool flag = 0;
			int cnt = 0;
			for (int j = 1; j <= n; j++)
			{
				//cout << "???: " << j << " " << id[j] << "\n";
				if (id[j] == i)
				{
					cnt++;
					maxn = max(maxn, cnt);
					ans1[j] += "C";
					if (!flag)
					{
						for (auto& k : G[j])
						{
							vis[k - n] = 1;
						}
					}
					flag = 1;
				}
				else ans1[j] += "A";
			}
			for (int j = 1; j <= n; j++)
			{
				if (vis[j]) ans2[j] += "C";
				else ans2[j] += "B";
			}
		}
		//cout << ans1[1].size() << " " << ans2[1].size() << "\n";
		// 二进制编号
		// 先给左侧编号
		int lim = ceil(log2(maxn));
		//if (lim == 0 && maxn == 1) exit(n);
		for (int c = 0; c < lim; c++)
		{
			for (int i = 1; i <= n; i++) ans2[i] += "C";
			for (int i = 1; i <= d1; i++)
			{
				for (int j = 0; j < dd1[i].size(); j++)
				{
					if ((j >> c) & 1) ans1[dd1[i][j]] += "A";
					else ans1[dd1[i][j]] += "B";
				}
			}
		}
		// right
		maxn = 0;
		for (int i = 1; i <= d2; i++) maxn = max(maxn, (int)dd2[i].size());
		lim = ceil(log2(maxn));
		for (int c = 0; c < lim; c++)
		{
			for (int i = 1; i <= n; i++) ans1[i] += "C";
			for (int i = 1; i <= d2; i++)
			{
				for (int j = 0; j < dd2[i].size(); j++)
				{
					if ((j >> c) & 1) ans2[dd2[i][j] - n] += "A";
					else ans2[dd2[i][j] - n] += "B";
				}
			}
		}
		if ((d1 == 2 && d2 == n) || (ans1[1].size() < p)) for (int i = 1; i <= n; i++) ans1[i] += "A", ans2[i] += "B";
		output();
	}
	return 0;
}
```

---


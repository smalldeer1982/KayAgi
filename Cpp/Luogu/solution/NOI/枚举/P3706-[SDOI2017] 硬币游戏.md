# [SDOI2017] 硬币游戏

## 题目描述

周末同学们非常无聊，有人提议，咱们扔硬币玩吧，谁扔的硬币正面次数多谁胜利。


大家纷纷觉得这个游戏非常符合同学们的特色，但只是扔硬币实在是太单调了。


同学们觉得要加强趣味性，所以要找一个同学扔很多很多次硬币，其他同学记录下正反面情况。


用 $\texttt H$ 表示正面朝上，用 $\texttt T$ 表示反面朝上，扔很多次硬币后，会得到一个硬币序列。比如 $\texttt{HTT}$ 表示第一次正面朝上，后两次反面朝上。


但扔到什么时候停止呢？大家提议，选出 $n$ 个同学，每个同学猜一个长度为 $m$ 的序列，当某一个同学猜的序列在硬币序列中出现时，就不再扔硬币了，并且这个同学胜利，为了保证只有一个同学胜利，同学们猜的 $n$ 个序列两两不同。


很快，$n$ 个同学猜好序列，然后进入了紧张而又刺激的扔硬币环节。你想知道，如果硬币正反面朝上的概率相同，每个同学胜利的概率是多少。


## 说明/提示

对于 $10\%$ 的数据，$1\le n,m\le 3$。

对于 $40\%$ 的数据，$1\le n,m\le 18$。

另有 $20\%$ 的数据，$n=2$。

对于 $100\%$ 的数据，$1\le n,m\le 300$。


## 样例 #1

### 输入

```
3 3
THT
TTH
HTT```

### 输出

```
0.3333333333
0.2500000000
0.4166666667```

# 题解

## 作者：Kelin (赞：31)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79837558)

给你一个字符串集

构造一个$01$串$S,$每个位置等概率的插入$01$

问字符串集中每个字符串最先出现在构造的串中的概率

---

怎么感觉和[$[JSOI2009]$有趣的游戏](https://blog.csdn.net/benoble_/article/details/79827083)"一模一样"

写完交一发只有$40ptsTLE,$原来这题是[$[JSOI2009]$有趣的游戏](https://blog.csdn.net/benoble_/article/details/79827083)数据范围的加强版

---

## 题解

$TLE$原因在于方程个数的$nm$的,这样显然是不行的

考虑到合法状态其实只有$n$个$,$其余的状态可以合并成一个状态——"不合法的状态"

如果能这样列出方程$,$那么复杂度就是$O(n^3)$是可以接受的

设$S$为一种不合法的状态(即没人赢)$,A=101,B=110$

>引理:构造出一个长的$l$特定$01$串的概率是$\frac1{2^l}$

**到$S+101$状态一定会停止游戏,但不一定要等到$101$加完才停止**

如果$S$的后缀是$1$或者$10$那么就会提前结束

也就是说可能会有这些情况

$$S101=(S+A)+(S'+A+01)+(S''+B+1)$$

其中$S=S'+10=S''+1$

根据上面的引理$,$可以得到方程$\frac18S=(1+\frac14)A+\frac12B$

也就是说对与每一个$S+x_i,len(x_i)=m$

如果$x_j$存在长度为$a$的后缀能匹配$x_i$的前缀$,$那么就有$\frac1{2^{m-a}}$的概率提前结束

设$pre_{a,x_i}$表示$x_i$长度为$a$的前缀$,$后缀同理

写成通式就是

$$x_i+\sum_{j=1}^n\sum_{a=1}^m[pre_{a,x_i}=suf_{a,x_j}]\frac1{2^{m-a}}x_j=\frac1{2^m}S$$

这样我们就只有$n+1$个方程了

最后再把其中一个方程替换为$\sum x_i=1$

至于如何快速匹配前缀和后缀可以~~根据套路~~使用字符串哈希

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=305,sed=time(0),S=(1<<30)-1;
const double eps=1e-10,P=0.5;
typedef int arr[N];
typedef double db;
int n,m;arr pw,pre[N],suf[N];db p[N],ans[N],G[N][N];char s[N];
inline int cmp(const db x){return fabs(x)<eps?0:x<0?-1:1;}
inline void Gauss(int n){
	db t;int mx;
	fp(i,1,n){mx=i;
		fp(j,i,n)if(cmp(G[mx][i]-G[j][i]))mx=j;
		if(mx^i)swap(G[mx],G[i]);
		fp(j,i+1,n)if(cmp(G[j][i])){
			t=G[j][i]/G[i][i];
			fp(k,i,n+1)G[j][k]-=G[i][k]*t;
		}
	}
	fd(i,n,1){
		fp(j,i+1,n)G[i][n+1]-=G[i][j]*ans[j];
		ans[i]=G[i][n+1]/G[i][i];
	}
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d",&n,&m);
    p[0]=pw[0]=1;
    fp(i,1,m)pw[i]=pw[i-1]*sed&S,p[i]=p[i-1]*P;
    fp(i,1,n){
    	scanf("%s",s+1);
    	fp(j,1,m)pre[i][j]=(pre[i][j-1]+s[j]*pw[j])&S;
    	fp(j,1,m)suf[i][j]=(suf[i][j-1]+s[m-j+1])*sed&S;
    }
    fp(i,1,n)fp(j,1,n)fp(k,1,m)
    	if(pre[i][k]==suf[j][k])
    		G[i][j]+=p[m-k];
   	fp(i,1,n)G[i][n+1]=-p[m],G[n+1][i]=1;G[n+1][n+2]=1;
   	Gauss(n+1);
   	fp(i,1,n)printf("%.10lf\n",ans[i]);
return 0;
}
```

当然如果你觉得慢的话我也可以用$AC$自动机来求匹配

这个嘛$,$怎么开心怎么玩是把

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=305,M=1e5+5;
const double eps=1e-10,P=0.5;
typedef int arr[M];
typedef double db;
struct eg{int nx,to;}e[M];
int n,m,ce,Cnt,ch[M][2];arr fi,mx,pos,fail;db p[N],ans[N],G[N][N];char s[N];
inline void add(int u,int v){static int ce=0;e[++ce]={fi[u],v},fi[u]=ce;}
#define v (ch[u][i])
inline void ins(int p){
	scanf("%s",s+1);int u=0,i;
	fp(j,1,m)i=s[j]=='H',mx[!v?v=++Cnt:v]=mx[u]+1,add(u=v,p);
	pos[p]=u;
}
inline void gf(){
	static int q[M];int h=1,t=0,u=0,i;
	fp(i,0,1)if(v)q[++t]=v;
	while(h<=t)for(u=q[h++],i=0;i<2;++i)v?fail[q[++t]=v]=ch[fail[u]][i]:v=ch[fail[u]][i];
}
#undef v
inline void calc(int x){
	for(int u=pos[x];u;u=fail[u])
		go(u)G[v][x]+=p[m-mx[u]];
}
inline int cmp(const db x){return fabs(x)<eps?0:x<0?-1:1;}
inline void Gauss(int n){
	db t;int mx;
	fp(i,1,n){mx=i;
		fp(j,i,n)if(cmp(G[mx][i]-G[j][i]))mx=j;
		if(mx^i)swap(G[mx],G[i]);
		fp(j,i+1,n)if(cmp(G[j][i])){
			t=G[j][i]/G[i][i];
			fp(k,i,n+1)G[j][k]-=G[i][k]*t;
		}
	}
	fd(i,n,1){
		fp(j,i+1,n)G[i][n+1]-=G[i][j]*ans[j];
		ans[i]=G[i][n+1]/G[i][i];
	}
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d",&n,&m);
    p[0]=1;fp(i,1,m)p[i]=p[i-1]*P;
    fp(i,1,n)ins(i);gf();
    fp(i,1,n)calc(i);
   	fp(i,1,n)G[i][n+1]=-p[m],G[n+1][i]=1;G[n+1][n+2]=1;
   	Gauss(n+1);
   	fp(i,1,n)printf("%.10lf\n",ans[i]);
return 0;
}
```

---

## 作者：bztMinamoto (赞：27)

## 题面

[传送门](https://www.luogu.org/problemnew/show/P3706)

## 题解

这里介绍一下简单易懂的概率生成函数

### 概率生成函数

我们定义一个形式幂级数$A(x)$，称它为离散随机变量$X$的概率生成函数，当且仅当对于$A(x)$的每一项$a_i$，都有$a_i=P(X=i)$

容易发现以下几个性质

1.$$A(1)=\sum_{i=0}^\infty P(X=i)=1$$

2.$$A'(x)=\sum_{i=0}^\infty iP(X=i)x^{i-1}=E(X)$$

## 本题

我们先来考虑一个弱化版的问题，即$n=1$

这也太弱化了吧你随便抓个$js$都知道这是$1$啊……

不过我们现在考虑的是求此时扔硬币的期望次数是多少（实际上这个问题就是[P4548 [CTSC2006]歌唱王国](https://www.luogu.org/problemnew/show/P4548)，你可以一并解决了）

这里我们假设它扔的不是个硬币而是个有$m$面的骰子，那么本题就是$m=2$的特殊情况了

我们定义一个字符串的前缀$S[1,i]$为这个字符串的$border$当且仅当$S[1,i]=S[L-i+1,L]$，其中$L$为串长

定义$a_i$，当且仅当$S[1,i]$是$S$的$border$时$a_i$为$1$，否则$a_i$为$0$

定义答案的概率生成函数为$F(x)$，即$f_i$表示掷了$i$次骰子游戏结束的概率，以及$G(x)$，$g_i$表示掷了$i$次骰子游戏仍未结束的概率

那么容易发现两个性质

1.$$G(x)+F(x)=1+xG(x)$$

也就是说$g_i=g_{i+1}+f_{i+1}$，即如果第$i$次未结束，那么第$i+1$次只有结束或未结束，$+1$是因为常数项

2.$$G(x)\left({1\over m}x\right)^L=\sum_{i=1}^La_iF(x)\left({1\over m}x\right)^{L-i}$$

即如果我们在一个未结束的串后面加上整个$A$肯定结束，然而还有可能没有加完整个串就已经结束了。通过分析可知，如果我们加了$A$的前$i$个字符之后结束，即有$A[L-i+1,L]=A[1,i]$，那么根据定义，$A[1,i]$是一个$border$，然后再把剩下的$L-i$个字符加进去就行了

对于$1$式，我们对两边求导，再把$x=1$代入，得

$$G'(x)+F'(x)=G(x)+xG'(x)$$

$$F'(1)=G(1)$$

即我们所需要求的$E(x)=F'(1)=G(1)$

对于$2$式，我们把$1$代入，在两边同乘上$m^L$，得

$$G(1)=\sum_{i=1}^La_im^iF(1)$$

又因为$F(1)=1$，最终可以化作

$$E(x)=\sum_{i=1}^La_im^i$$

那么只要哈希就可以$O(L)$求出$a_i$了

## $n> 1$

以上是$n=1$的情况，接下来我们就考虑串的个数大于$1$的情况

~~因为证明基本和上面差不多，下面我就不给证明直接放柿子了~~

定义$P(A_i)=\prod_{i\in A_i}P_i$

定义$a_{i,j,k}$，当且仅当$A_i[1,k]=A_j[m-k+1,m]$时值为$1$否则为$0$，可以用$hash$从而在$O(n^3)$的时间内解得

定义$f_{i,j}$表示首次出现的序列是$A_i$且随机序列长度为$j$的概率，$F_i(x)$为其生成函数，定义辅助序列$g_i$表示随机序列长度为$i$时仍未结束的概率，生成函数为$G(x)$

容易得到

$$G(x)+\sum_{i=1}^nF_i(x)=1+xG(x)$$

以及

$$G(x)P(A_i)x^m=\sum_{j=1}^n\sum_{k=1}^ma_{i,j,k}F_j(x)P(A_i[k+1,m])x^{L_i-k}$$

前一个柿子这里就不用管了，我们考虑后一个柿子，把$x=1$代入，可以得到

$$G(1)=\sum_{j=1}^n\sum_{k=1}^ma_{i,j,k}F_j(1)P({1\over A_i[1,k]})$$

对于每一个$i$都有这么一个方程，我们需要解出$F_i(1)$和$G(1)$，那么总共有$n$个方程和$n+1$个变量

等会儿好像还是不能解啊……

我们再转过头来看看……$F_i(1)$表示第$i$个人获胜的概率……那么似乎有

$$\sum_{i=1}^nF_i(1)=1$$

这样就有$n+1$个方程了，高斯削元就是了，时间复杂度$O(n^3)$

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
const int N=305,P=1e9+7;const double eps=1e-10;
double mp[N][N],b[N];char s[N];int bin[N],h[N][N],n,m;
inline int Hash(R int i,R int l,R int r){return ((h[i][r]-1ll*h[i][l-1]*bin[r-l+1])%P+P)%P;}
void Gauss(int n){
	fp(i,1,n){
		if(mp[i][i]>-eps&&mp[i][i]<eps){
			fp(j,i+1,n)if(mp[j][i]<-eps||mp[j][i]>eps){
				fp(k,i,n+1)swap(mp[i][k],mp[j][k]);
				break;
			}
		}
		double t=1.0/mp[i][i];fp(j,i,n+1)mp[i][j]*=t;
		fp(j,i+1,n){
			t=mp[j][i];
			fp(k,i,n+1)mp[j][k]-=mp[i][k]*t;
		}
	}
	fd(i,n-1,1)fp(j,i+1,n)mp[i][n+1]-=mp[j][n+1]*mp[i][j];
}
int main(){
//	freopen("testdata.in","r",stdin);
	scanf("%d%d",&n,&m);
	bin[0]=b[0]=1;
	fp(i,1,m)bin[i]=(bin[i-1]<<1)%P,b[i]=b[i-1]*2;
	fp(i,1,n){
		scanf("%s",s+1);
		fp(j,1,m)h[i][j]=((h[i][j-1]<<1)+(s[j]=='H'))%P;
	}
	fp(i,1,n){
		fp(j,1,n)fp(k,1,m)(Hash(i,1,k)==Hash(j,m-k+1,m))?mp[i][j]+=b[k]:0;
		mp[i][n+1]=-1;
	}
	fp(i,1,n)mp[n+1][i]=1;mp[n+1][n+2]=1;
	Gauss(n+1);
	fp(i,1,n)printf("%.8lf\n",mp[i][n+2]);
	return 0;
}
```

---

## 作者：DeaphetS (赞：19)

卡了半天最优解_(:з」∠)_ 结果最后还是并列的109ms QAQ

### Task 1 $1\le n,m\le 3$

枚举最后几位的情况，或者枚举三个字符串当前已经匹配了多少位，可以得出状态转移的形式，高斯消元即可。

### Task 2 $1\le n,m\le 18$

做法与 `[JSOI2009]有趣的游戏` 相同，时间复杂度 $O(n^3m^3)$，具体的因为本弱不会 AC 自动机所以略过。

### Task 3 $n=2$

**这一部分较为重要**

设两个人的串分别是 $A,B$，假设当前游戏还没结束，且字符串为 $S$，我们知道如果直接在 $S$ 后面加上一个 $A$ 游戏一定能结束，但是可能会出现在中途结束游戏的情况。

例：`A=101,B=110`

- 如果当前 $S$ 以 `10` 结尾，那么加入第一个 `1` 的时候就直接结束，第一个人获胜，多加了 `01` ；
- 如果当前 $S$ 以 `1` 结尾，那么加入 `10` 时结束，第二个人获胜，多加了 `1` ；
- 其余情况，第一个人获胜。

于是可以得到一个等式：$S101=A01+B1+A$，就有 $S\cdot \frac{1}{8}=A\cdot \frac{1}{4}+B\cdot \frac{1}{2}+A$。

这个式子的来源是，每个形如 $S101$ 的字符串都可以不重不漏地分解成三种不同的类型，于是这些字符串出现的概率必然相同。

我们再来看看直接在 $S$ 后面加上一个 $B$ 的情况，同样能够得到 $S110=A10+B$，于是就有 $S\cdot \frac{1}{8}=A\cdot \frac{1}{4}+B$，$\frac{1}{8}$ 和 $\frac{1}{4}$ 分别为在一个状态后面添加 $3$ 个或 $2$ 个给定字母的概率。

通过上述两个式子我们是能够知晓 $A,B$ 之间的关系的，但是并不方便我们直接得出结果。

我们还知道，一定有 $P_A+P_B=1$ ，所以能够得到一个三元一次方程组 $\begin{cases} A+B=1\\ S=10A+4B\\ S=2A+8B\\ \end{cases} $，解得 $\begin{cases} S=6\\A=\frac{1}{3}\\ B=\frac{2}{3}\\ \end{cases} $。

于是在这种情况下，我们就得出了两人获胜的概率。

总结一下不难得出，当我们考虑加 $A$ 串的时候，能够对式子产生贡献的情况是 $A$ 串的一个前缀和 $x$ 串（可能是 $A$ 或 $B$）的一个后缀发生了重合，假设重合部分的长度为 $L$ ，那么式子右边就会多上 $x\cdot \frac{1}{2^{m-L}}$ ，因为剩下还有 $m-L$ 长度的串可以加进去。

于是我们就可以得出一个标准化的式子：

$$S\cdot \frac{1}{2^m}=\sum_{pre(A,L)=suf(A,L)} A\cdot \frac{1}{2^{m-L}}+\sum_{pre(A,L)=suf(B,L)} B\cdot \frac{1}{2^{m-L}}$$

对加 $B$ 串的情况，也能得到类似的结果，于是我们通过枚举 $L$ 判断对应前后缀是否相同，并手工计算这两个方程里 $A$ 和 $B$ 的系数，就能算出 $A,B$ 之间的比值，从而求解。

### Task 4 $1\le n,m\le 300$

实际上**Task 3**的做法离正解已经无限接近了。

设 $pre(i,L)$ 表示第 $i$ 个字符串长度为 $L$ 的前缀，$suf(i,L)$ 同理，那么根据**Task 3**的结论，可以得出方程组的第 $i$ 个式子为：
$$S\cdot \frac{1}{2^m}=\sum_{j=1}^{n}\sum_{pre(i,L)=suf(j,L)} P_j\cdot \frac{1}{2^{m-L}}$$

再结合式子 $\sum_{i=1}^{n}P_i=1$，即可联立方程组高斯消元求解。

接下去问题就在于如何快速判定 $pre(i,L)=suf(j,L)$，用各类字符串科技或者直接 $\texttt{hash}$ 即可，本人用的是 $\texttt{hash}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 310
#define ld double
const long long P=37;
const int MOD=1000000007;
int n,m,pre[N][N],suf[N][N];
ld a[N][N],p[N],T;
char s[N];
void Gauss(int n)
{
	for(int i=1;i<=n;i++){
		int t=0;
		for(int j=i;j<=n;j++)
			if(a[j][i]!=0){
				t=j;
				break;
			}
		swap(a[i],a[t]);
		T=1.0/a[i][i];
		for(int j=i+1;j<=n+1;j++)
			a[i][j]*=T;
		a[i][i]=1; 
		for(int j=1;j<=n;j++)if(i!=j){
			T=a[j][i],a[j][i]=0;
			for(int k=i+1;k<=n+1;++k)
				a[j][k]-=T*a[i][k];
		}
	}
	for(int i=1;i<n;i++)printf("%.6f\n",a[i][n+1]);
}
int main()
{
	for(int i=0;i<N;i++)
		p[i]=pow(0.5,i);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)
			pre[i][j]=(P*pre[i][j-1]+s[j]-'A')%MOD;
		for(long long j=1,k=1;j<=m;j++,k=P*k%MOD)
			suf[i][j]=(k*(s[m-j+1]-'A')+suf[i][j-1])%MOD;
		a[i][n+1]=-p[m];
		a[n+1][i]=1;
	}
	a[n+1][n+2]=1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	for(int L=1;L<=m;L++)
	if(pre[i][L]==suf[j][L])
		a[i][j]+=p[m-L];
	Gauss(n+1);
}
```

其实可以发现，关于 $S$ 的系数是可以任取的，因为在方程中 $S$ 相当于只是一个辅助变量，所以代码中的 `a[i][n+1]=-p[m];` 是可以把系数改成任意数字的（如 $114514$）。

---

## 作者：shadowice1984 (赞：12)

目前应该是你站里跑的最快的代码，吸氧后仅需 60ms

 _(不吸氧的话240ms,但是在这份代码之前的代码都是吸过氧才跑的比我快的233)_ 

真是一道神题……

## 暴力

我们对所有的模式串建一只trie图

就变成了经典的图上随机游走求到达每一个点概率的问题

然后我们可以暴力的列方程，高斯削元，算法复杂度$O(n^3m^3)$不可接受

_(如果你不是很熟练的话，可以忽略这个暴力，因为掌握正解不需要掌握暴力)_ 

当问题变得辣手的时候，我们需要想一些机智的办法

# 本题题解

我们的思路是这样的

 _令$p(i)$表示第i个人获胜的概率_ 

我们发现最后游戏结束时的字符串肯定是一个不可匹配任意一个串的串+一个模式串

那么我们发现直接求这个不可匹配串+模式串的出现概率是极其不好求的，因为我们对这个串基本一无所知，所以也根本计算不了概率

~~(因为这就是答案啊……233)~~

但是，不知道大家小学的时候有没有学过这样的一种列方程技巧

一开始先摆出一个毫无争议的等式

比如 **xx的总数=xx的总数**

然后等式两边换不同的形式表达这个"总数"于是便可以神奇的解出x

我们在这道题里也会采取类似的思路

从3个毫无争议的等式开始

#### 任意串出现的概率=任意串出现的概率

#### a+b串出现的概率=a出现的概率×b出现的概率

#### 所有模式串出现的概率相等

我们可以推出

### (任意串+任意模式串)出现的概率=(任意串+任意模式串)出现的概率

现在要做的就是如何表达这个显而易见的式子

我们发现，任意串+模式串i可以由使点j胜利的串+一些其他的字符串表示

所以我们枚举这个(任意串+模式串i)是由哪一个使j胜利的串表示的

这样我们可以列出n个等式，而使j胜利的串出现的概率=$P(j)$我们就可以解方程解出$P(j)$了

我们发现每个使j胜利的串都可以直接怼上一个模式串i来达成任意串+模式串i的形式。这种情况太trival了，所以我们对于每一个等式都减去这个trival情况出现的概率，此时等式依然成立

排除了这种情况，我们会发现此时我们可以通过使j胜利的串+一些字符串的形式来构造一个任意字符串+模式串i形式的字符串。

并且我们会发现，此时被构造出来的串中的模式串部分(就是被构造的串的**长度为m的**后缀)一定有一个前缀，是**使j胜利的串的**一个后缀，(换句话说，这个前缀和后缀相等，显然这个前缀和后缀长度小于m)

而我们发现，**使j胜利的串的长度为m的**后缀，是模式串j。

换句话来讲，只要我们的模式串j的一个后缀=模式串i的一个前缀，并且这个前缀(或者后缀)长度=k，我们就可以通过给一个使j胜利的串后添加m-k个字符的方式构造出一个任意字符串+模式串i形式的字符串

(如果看不懂以上描述，可以看图)

![](https://cdn.luogu.com.cn/upload/pic/16387.png)

由于绿色+浅蓝色部分=红色部分，我们可以推出深蓝色部分=紫色部分

而深蓝色部分是j的后缀，紫色部分是i的前缀

那么我们现在可以枚举公共前后缀，从而求出由模式串j+特定字符串构造出任意串+模式串i形式的字符串的概率(假设i，j的前的第k个公共前后缀长度为$len_{i,j,k}$)

那么我们可以得到这样一个式子

## $P(N+i)=\sum_{j=1}^{n}\sum_{k=1}^{n}2^{(m-len_{i,j,k})}P(j)$

其中$P(N+i)$表示任意串+模式串i形式的串出现的概率，P(j)已经定义过了

方程的意义就是为了构造i我们枚举j，枚举i，j的公共前后缀k，在j后添加一个长度为$m-len_{i,j,k}$的特定字符串从而构造了一个任意串+模式串i形式的串

还记的我们一开始摆出的毫无争议的等式吗？，他可以写成这样

### $P(N+1)=P(N+2)=……P(N+n-1)=P(N+n)$

于是我们有了N个等式，但是我们发现有N+1个变量……(最后一个变量是我们设的$P(N+i)的值$)

没关系，我们此时暴力高斯削元可以把$P(j)$用$P(N+i)$表示，也就是说我们知道各个$P(j)$间的比例关系

此时仔细观察还有一个隐藏的等式

## $\sum_{i=1}^{n}P(i)=1$

我们已经知道各个p的比例关系，直接按比例分配就行了

## 关于枚举i，j的公共前后缀问题

上述的算法已经成功的将时间复杂度降到了$O(n^3)$

但是会有一个问题，如何枚举i，j的公共前后缀？

一种可行的做法是接在一起跑kmp，然后通过跳next数组的方式来玄学的枚举公共前后缀

但是你们不觉得kmp的next十分玄学，而且不好把控吗……?而且不觉得每次跑一边kmp麻烦吗？

# 为什么不试试神奇的hash呢？

hash又好写又好调,还很好理解，不知道比kmp高到哪里去了。

而且关键是我们可以预处理每个前缀和后缀的hash值，此时只需枚举i，j和公共前缀的长度k，**常数极小**(当然这也是为什么这份代码跑的比香港记者还快的原因了)

然后我们就可以列方程然后去解了……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=310;typedef double db;const db eps=1e-10;
typedef long long ll;ll mod[2]={998244353,1e9+7};
ll mi[2][N];ll inv[2][N];int n;int m;db len[N];db res;
ll key[2][N][N];ll hash[2][N];char mde[N];db t[N][N];
int main()
{
    scanf("%d%d",&n,&m);len[0]=1;//保险起见用了双hash，欧皇们可以尝试单hash 
	inv[1][0]=inv[0][0]=mi[1][0]=mi[0][0]=1;
    for(int i=1;i<=m;i++){len[i]=len[i-1]*0.5;}
    for(int i=1;i<=m;i++){mi[0][i]=(mi[0][i-1]*4LL)%mod[0];}//打表次幂 
    for(int i=1;i<=m;i++){mi[1][i]=(mi[1][i-1]*4LL)%mod[1];}
    for(int i=1;i<=m;i++){inv[0][i]=(inv[0][i-1]*748683265LL)%mod[0];}//打标逆元 
    for(int i=1;i<=m;i++){inv[1][i]=(inv[1][i-1]*250000002LL)%mod[1];}
    for(int z=1;z<=n;z++)
    {
        scanf("%s",mde+1);//处理出前缀和后缀的hash值 
        for(int i=1;i<=m;i++){hash[0][i]=(hash[0][i-1]+((mde[i]=='H')+1)*mi[0][i-1])%mod[0];}
        for(int i=1;i<=m;i++){hash[1][i]=(hash[1][i-1]+((mde[i]=='H')+1)*mi[1][i-1])%mod[1];}
        for(int i=1;i<=m;i++){key[0][z][i]=hash[0][i]*hash[1][i];}//前缀hash 
        for(int i=1;i<=m;i++)
        {
            ll val0=((hash[0][m]+mod[0]-hash[0][i-1])*inv[0][i-1])%mod[0];
            ll val1=((hash[1][m]+mod[1]-hash[1][i-1])*inv[1][i-1])%mod[1];
            key[1][z][m-i+1]=val0*val1;//后缀hash 
        }
    }
    for(int i=1;i<=n;i++)//暴力枚举i,j,k列方程 
    {
        for(int j=1;j<=n;j++)
        {
            for(int k=1;k<=m;k++)//判一下hash值是否相等 
            {if(key[0][i][k]==key[1][j][k]){t[i][j]+=len[m-k];}}
        }
    }
    for(int i=1;i<=n;i++){t[i][n+1]=1;}//这里用单位1来代替P(N+i)了 
    for(int i=1;i<=n;i++)//高斯削元的板子，不会的话出门左转luogu膜板区 
    {
        if(-eps<t[i][i]&&t[i][i]<eps)
        {
            for(int j=i+1;j<=n;j++)
            {
                if(-eps<t[j][i]&&t[j][i]<eps){continue;}
                for(int k=1;k<=n+1;k++){swap(t[j][k],t[i][k]);}break;
            }
        }
        db div=t[i][i];for(int k=1;k<=n+1;k++){t[i][k]/=div;}
        for(int j=1;j<=n;j++)
        {
            if(j==i||(-eps<t[j][i]&&t[j][i]<eps)){continue;}
            db mult=t[j][i];for(int k=1;k<=n+1;k++){t[j][k]-=mult*t[i][k];}
        }
    }
    for(int i=1;i<=n;i++){res+=t[i][n+1];}//按比例分配一下就是答案 
    for(int i=1;i<=n;i++){printf("%.10lf\n",t[i][n+1]/res);}return 0;//拜拜程序~ 
}
```



















---

## 作者：5ab_juruo (赞：11)

讲一种不用脑子的做法。

暴力怎么做？建出 ACAM，对每个节点设一个变量，为包含该节点对应字符串的概率，每个点的概率会平均对其后继产生贡献，再套个高斯消元即可。复杂度 $O(n^3m^3)$。

如果你做过 [Boring Problem](https://codeforces.com/gym/103119/problem/B) 的话，你会发现相同的套路可以直接搬过来用。我们优化的核心在于减少变量的个数，即仅对每个终止状态设变量，并用这 $n$ 个变量表示其余所有节点。

ACAM 有很好的性质：对所有节点标记上在 Trie 树（不是 fail 树！）上的深度，则所有的转移要么直接指向儿子，要么指向深度小于等于自己的节点。对应到该题，即为所有的前驱要么是 Trie 树上的父亲，要么是深度大于等于自己的节点。按照深度从大到小遍历的话，对每个节点都可以保证，除了父亲以外，所有前驱都已经被遍历。

直接转移的式子为 $p=1/2\left(\sum_{x} p_x\right)$，单独拎出父亲写成 $p_{fa}=2p-\sum_{x\neq fa}p_x$，我们按照深度从大到小遍历，对于一个节点，用自己的值和其他前驱的值去表示父亲，这样就可以用 $n$ 个变量表示 ACAM 上所有节点的值。

那方程在哪里？来源有二：

1. 不同的点可能有共同的父亲，此时两组值必然是相同的。由于一共有 $n$ 个叶子，所以共会有 $n-1$ 次这样的合并；
2. $\sum p=1$。

完事以后直接消元就好了，注意消元时的精度问题，时空复杂度均为 $\mathcal{O}(n^3)$。LOJ 上可以过，洛谷上被卡空间了。

upd（感谢 @[阿丑](https://www.luogu.com.cn/user/364963)）：对每一个 $x_i$ 都分别跑 bfs，存系数的空间就可以降到 $\mathcal{O}(nm)$，就可以过了。

```cpp
using db = double;

const int max_n = 300, max_l = 300, max_nd = max_n * max_l + 1, cs = 2;

int tr[max_nd][cs], fail[max_nd], fa[max_nd], ind = 1;
int hd[max_nd], des[max_nd + 1], nxt[max_nd + 1], st[max_n], e_cnt = 0;
db ce[max_nd], m[max_n][max_n + 1];
bool ok[max_nd];

void add(int s, int t)
{
	des[e_cnt] = t;
	nxt[e_cnt] = hd[s];
	hd[s] = e_cnt++;
}

char s[max_l + 1];
signed main()
{
	memset(tr, -1, sizeof tr);
	
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int n, l;
	
	cin >> n >> l;
	fa[0] = -1;
	
	for (int i = 0; i < n; i++)
	{
		cin >> s;
		
		int ptr = 0;
		for (int j = 0; j < l; j++)
		{
			int d = (s[j] == 'H');
			if (tr[ptr][d] == -1)
			{
				fa[ind] = ptr;
				tr[ptr][d] = ind++;
			}
			ptr = tr[ptr][d];
		}
		ok[ptr] = true;
		st[i] = ptr;
	}
	fill(hd, hd + ind, -1);
	
	queue<int> q;
	for (int i = 0; i < cs; i++)
		if (tr[0][i] == -1)
			tr[0][i] = 0;
		else
		{
			fail[tr[0][i]] = 0;
			q.push(tr[0][i]);
		}
	while (!q.empty())
	{
		int cur = q.front(); q.pop();
		for (int i = 0; i < cs; i++)
			if (tr[cur][i] == -1)
			{
				tr[cur][i] = tr[fail[cur]][i];
				if (!ok[cur])
					add(tr[cur][i], cur);
			}
			else
			{
				fail[tr[cur][i]] = tr[fail[cur]][i];
				q.push(tr[cur][i]);
			}
	}
	
	for (int cp = 0; cp < n; cp++)
	{
		fill(ok, ok + ind, false);
		for (int i = 0; i < n; i++)
		{
			q.push(st[i]);
			ok[st[i]] = true;
			ce[st[i]] = (cp == i);
		}
		int fc = 0;
		while (!q.empty())
		{
			int cur = q.front(); q.pop();
			if (cur == 0)
				break;
			db tmp = ce[cur] * 2;
			for (int p = hd[cur], dst; p != -1; p = nxt[p])
			{
				dst = des[p];
				tmp -= ce[dst];
			}
			if (!ok[fa[cur]])
			{
				ok[fa[cur]] = true;
				ce[fa[cur]] = tmp;
				q.push(fa[cur]);
			}
			else
				m[fc++][cp] = ce[fa[cur]] - tmp;
		}
	}
	fill(m[n - 1], m[n - 1] + n + 1, 1);
	
	for (int i = 0; i < n; i++)
	{
		int mxp = -1;
		double mxc = fabs(m[i][i]);
		for (int j = i + 1; j < n; j++)
			if (fabs(m[j][i]) > mxc)
				mxc = fabs(m[j][i]), mxp = j;
		if (mxp != -1)
			swap(m[mxp], m[i]);
		for (int j = i + 1; j < n; j++)
		{
			db rto = m[j][i] / m[i][i];
			for (int k = i; k <= n; k++)
				m[j][k] -= rto * m[i][k];
		}
	}
	for (int i = n - 1; i >= 0; i--)
		for (int j = 0; j < i; j++)
		{
			db rto = m[j][i] / m[i][i];
			for (int k = i; k <= n; k++)
				m[j][k] -= rto * m[i][k];
		}
	
	cout << fixed;
	for (int i = 0; i < n; i++)
		cout << setprecision(10) << m[i][n] / m[i][i] << "\n";
	
	return 0;
}
```

---

## 作者：K8He (赞：11)

# 「题解报告」[P3706 [SDOI2017]硬币游戏](https://www.luogu.com.cn/problem/P3706)

[更好的阅读体验](https://www.cnblogs.com/Keven-He/p/ProbabilityAndExpectation.html#p3706-sdoi2017%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F)

## 思路

首先为了方便，我们把“不包含任意一个同学猜的串的字符串”称为“合法串”。

$f_i$ 表示第 $i$ 个同学胜利的概率，$f_0$ 表示任意长度的一个串为合法串的概率。

一个很显然的性质是，第 $i$ 个同学胜利时的字符串一定是**一个合法串加上第 $i$ 个同学猜的串**，其概率为 $\dfrac{f_0}{2^{m}}$。

但是 $f_i$ 并不等于这个数，因为一个合法串的后缀和第 $i$ 个同学猜的串的前缀可能可以组成一个别的同学猜的串！这个时候就不是第 $i$ 个同学胜利了。

那么我们考虑算出这种情况的概率，令 $f_0$ 与之相减即可得到 $f_i$。

设 $pre_{i,j}$ 表示第 $i$ 个同学猜的串的长度为 $j$ 的前缀，$suf_{i,j}$ 表示第 $i$ 个同学猜的串的长度为 $j$ 的后缀。

$$
f_i + \sum_{j = 1}^{n}f_j\sum_{k = 1}^{m}[pre_{i, k} = suf_{j, k}]\dfrac{1}{2^{m - k}} = \dfrac{f_0}{2^{m}}
$$

然后冲一个高斯消元即可。

## 代码

```cpp
const ll N = 310, inf = 1ll << 40, P = 1e9 + 7;

namespace HASH {
	ll z[N];
	inline void PreZ (ll m) {
		z[1] = 1;
		_for (i, 2, m) z[i] = z[i - 1] * 3 % P;
		return;
	}
	class Hash {
	public:
		ll pre[N], suf[N];
		inline void In (char *s, ll m) {
			_for (i, 1, m) {
				pre[i] = (pre[i - 1] * 3 % P + (s[i] == 'H' ? 1 : 2)) % P;
				suf[i] = (suf[i - 1] + (s[m - i + 1] == 'H' ? 1 : 2) * z[i] % P) % P;
			}
			return;
		}
	};
}

namespace SOLVE {
	char s[N][N];
	ll n, m, ans;
	HASH::Hash h[N];
	ldb a[N][N], x[N];
	inline ll rnt () {
		ll x = 0, w = 1; char c = getchar ();
		while (!isdigit (c)) { if (c == '-') w = -1; c = getchar (); }
		while (isdigit (c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar ();
		return x * w;
	}

	inline void GetMatrix () {
		_for (i, 1, n) {
			_for (j, 1, n) {
				_for (k, 1, m) {
					if (h[i].pre[k] != h[j].suf[k]) continue;
					a[i][j] += x[m - k];
				}
			}
			a[i][n + 1] = -x[m];
		}
		_for (i, 1, n) a[n + 1][i] = 1;
		a[n + 1][n + 2] = 1;
		return;
	}
	inline void Gauss () {
		_for (i, 1, n + 1) {
			ll l = i;
			_for (j, i + 1, n + 1) if (a[l][i] < a[j][i]) l = j;
			std::swap (a[i], a[l]);
			_for (j, i + 1, n + 2) a[i][j] /= a[i][i];
			a[i][i] = 1.0;
			_for (j, 1, n + 1) {
				if (i == j) continue;
				_for (k, i + 1, n + 2) a[j][k] -= a[j][i] * a[i][k];
			}
		}
		return;
	}

	inline void In () {
		n = rnt (), m = rnt ();
		_for (i, 1, n) scanf ("%s", s[i] + 1);
		return;
	}
	inline void Solve () {
		x[0] = 1.0;
		_for (i, 1, m) x[i] = x[i - 1] * 0.5;
		HASH::PreZ (m);
		_for (i, 1, n) h[i].In (s[i], m);
		GetMatrix ();
		Gauss ();
		return;
	}
	inline void Out () {
		_for (i, 1, n) printf ("%.12Lf\n", a[i][n + 2]);
		return;
	}
}
```

---

## 作者：ez_lcw (赞：7)

很神奇的一道题目。

首先先举一个例子，等会结合着讲：只有两个人猜，猜的串分别是 $A=\texttt{TTH}$，$B=\texttt{HTT}$。

设所有人猜的序列为 $s_1,s_2,\cdots,s_n$。

首先对于这种可能存在无限情况的题目，我们要学会归类：

把所有可能的硬币序列（可能有无限种）分成两类：未终止状态和已终止状态。

其中未终止状态表示：当前的硬币序列（设为 $T$）还没有胜者。即不存在任意一个 $s_i$，使得 $s_i$ 在 $T$ 中出现过。例如在上述例子中，$\texttt{TT}$、$\texttt{HHT}$、$\underbrace{\texttt{HHH...}}_{\text{无限个}}$ 都是未终止状态。

终止状态表示：当进行到当前的硬币序列（设为 $T$）时，决出了胜者。即存在一个 $i$ 使得 $s_i$ 是 $T$ 的后缀，且不存在任意的 $j\neq i$，使得 $s_j$ 在 $T$ 中出现过。例如在上述例子中，$\texttt{TTH}$、$\underbrace{\texttt{HH...H}}_{\text{若干个}}\texttt{TT}$ 都是终止状态。

可以发现未终止状态和终止状态并不能包含所有由 $\texttt{H}$ 和 $\texttt{T}$ 构造出来的字符串。例如在上述例子中，$\texttt{TTHT}$、$\texttt{THTHTHTTH}$ 都是不可达状态。发现不可达状态其实就是在某个终止状态后加上任意非空字符串构造出来的。

然后我们要找出这些情况之间的关系，然后用 dp 或解方程来求解。

如何建立未终止状态和已终止状态之间的关系？

设 $N$ 是任意一个未终止状态。

不妨 $N$ 后面加上某一个 $s_i$，就能达到一个终止状态了。

但是你发现，在一些特殊情况下，这个 $N+s_i$ 可能是一个不可达状态。

什么意思呢？那我们刚刚那个样例来分析：

对于 $N+\texttt{TTH}$，它可能是两种状态：

1. 它是一个以 $A=\texttt{TTH}$ 为终止的终止状态，即 $N+A$。

2. 它是一个以 $B=\texttt{HTT}$ 为终止的终止状态后面再接上一个字符串达到的不可达状态，即 $N'+B+\texttt{H}$，其中可知 $N'$ 同样是一个未终止状态，且满足 $N'+\texttt{H}=N$。

也就是说，$\dfrac{1}{8}N=P(A)+\dfrac{1}{2}P(B)$。（其中 $P(A)$ 是 $A$ 获胜的概率，$P(B)$ 同理）

按照类似的思路，我们可以两两枚举每个串，比较他们的前缀和后缀，如果相同就加上一个系数。

形式化地，设 $pre_{i,j}$ 表示 $s_i$ 的长度为 $j$ 的前缀$suf_{i,j}$ 表示 $s_i$ 的长度为 $j$ 的后缀，$x_i$ 表示以 $s_i$ 结尾的终止状态出现的概率（即 $i$ 获胜的概率）。

对于每一个 $i$，我们可以列出如下方程：

$$\dfrac{1}{2^m}N=\sum_{j=1}^nx_j\sum_{k=1}^m[pre_{i,k}=suf_{j,k}]\dfrac{1}{2^{m-k}}$$

（对于中间那个判断我们可以用哈希处理）

然后还有一条方程：$\sum\limits_{i=1}^nx_i=1$。

所以一共有 $n+1$ 个未知数 $n+1$ 个方程，就能用高斯消元解出每一个 $x_i$ 了。

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 310

using namespace std;

const unsigned int base=19260817;

int n,m;
char s[N][N];
unsigned int poww[N],sum[N][N];
double div2[N],x[N],a[N][N];

unsigned int get(int i,int l,int r)
{
	if(l>r) return 0;
	return sum[i][r]-sum[i][l-1]*poww[r-l+1];
}

void Gauss()
{
	for(int i=1;i<=n+1;i++)
	{
        for(int j=i;j<=n+1;j++)
		{
            if(!a[j][i]) continue;
            for(int k=i;k<=n+2;k++) 
				swap(a[i][k],a[j][k]);
            break;
        }
        for(int j=i+1;j<=n+2;j++)
		{
            if(!a[j][i]) continue;
            double tmp=a[j][i]/a[i][i];
            for(int k=i;k<=n+2;k++)
				a[j][k]-=a[i][k]*tmp;
        }
    }
    x[n+1]=a[n+1][n+2]/a[n+1][n+1];
    for(int i=n;i>=1;i--){
        for(int j=i+1;j<=n+1;j++)
			x[i]-=a[i][j]*x[j];
        x[i]/=a[i][i];
    }
}

int main()
{
	scanf("%d%d",&n,&m);
	poww[0]=div2[0]=1;
	for(int i=1;i<=m;i++)
		poww[i]=poww[i-1]*base,div2[i]=div2[i-1]/2.0;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s[i]+1);
		for(int j=1;j<=m;j++)
			sum[i][j]=sum[i][j-1]*base+s[i][j];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			double ans=0;
			for(int k=1;k<=m;k++)
				if(get(i,1,k)==get(j,m-k+1,m))
					ans+=div2[m-k];
			a[i][j]=ans;
		}
		a[i][n+1]=-div2[m];
	}
	for(int i=1;i<=n;i++)
		a[n+1][i]=1;
	a[n+1][n+2]=1;
	Gauss();
	for(int i=1;i<=n;i++)
		printf("%.10lf\n",x[i]);
	return 0;
}
/*
2 2
TTH
HTT
*/
```

---

## 作者：ViXbob (赞：6)

[可以去我的博客看吖](http://www.vixbob-lwc.pw/2019/05/15/LOJ-2004/)

把$\text{AC}$自动机建出来暴力高消复杂度是$O((nm)^3)$的,有$40$分.实际上$\text{AC}$自动机上记录了很多我们并不需要的状态和转移,所以复杂度降不下来.

考虑增加一个辅助变量$x_0$表示经过一个任意长度但没有包含任意一个给定序列的末尾节点的期望.$x_i$表示经过第$i$个同学的串的末尾节点的期望(数值上等于它获胜的概率,因为经过后游戏就结束了).

引理一:

结尾包含一个长度为$L$的指定串但没有包含任意一个给定序列的概率为$\frac{1}{2^L}$.

证明一:

不会啊....感性理解一下就好了....

首先我们有一个非常$naive$的想法,如果我们想要一个串出现那我们直接在一个没有包含任意指定序列的后面加上我们想要的串不就好了吗?~~太有道理了吧~~

但是很显然你可能在加上这个串之后,它已经经过了**另外**一个串的结尾字符.(这个是导致每个同学的期望不同的本质原因,否则每个人的期望应该是都是$\frac{1}{2^m}x_0$)

这样那我们用$\frac{1}{2^m}x_0$减去冲突(指加上这个串之后已经包含另外一个串的情况)的期望不就是我们要求的真正期望吗?

考虑冲突在什么情况下会发生:

设我们当前考虑$i$串,会和$j$串发生冲突.会发生冲突当且仅当:如果一个没有包含任意指定序列包含了$j$串的一个前缀,而恰好$j$串除去被包含的前缀后的串又是$i$串的前缀.

说人话就是$j$串的后缀和$i$串的前缀匹配,而没有包含任意指定序列的后缀又和$j$串的前缀部分相同.则对于每个$i$有如下方程:
$$x_i+\sum_{j=1}^nx_j\left(\sum_{k=1}^{m-[i=j]}\left[\text{prefix(i,k)=suffix(j,k)}\right]\frac{1}{2^{m-k}}\right)=\frac{1}{2^m}x_0$$
PS:$\text{prefix(i,j)}$表示$i$串的长为$j$的前缀,$\text{suffix(i,j)}$同理.$\frac{1}{2^{m-k}}$表示序列结尾和$\text{prefix(j,m-k)}$相同的概率(使用引理一).

PS:判断匹配直接哈希就好了.

当然还有一个方程:
$$\sum_{i=1}^nx_i=1$$
然后直接高斯消元即可.

复杂度$O\left((n+1)^3\right)$

代码:

```cpp
/*
 * 4818.cpp
 * This file is part of 4818
 *
 * Copyright (C) 2019 - ViXbob
 *
 * 4818 is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * 4818 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with 4818. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * There is no end though there is a start in space. ---Infinity.
 * It has own power, it ruins, and it goes though there is a start also in the star. ---Finite.
 * Only the person who was wisdom can read the most foolish one from the history.
 * The fish that lives in the sea doesn't know the world in the land.
 * It also ruins and goes if they have wisdom.
 * It is funnier that man exceeds the speed of light than fish start living in the land.
 * It can be said that this is an final ultimatum from the god to the people who can fight.
 *
 * Steins;Gate
 */
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define dep(i, j, k) for(int i = j; i >= k; --i)
#define SIZE(x) ((int)x.size())
#define mp(x, y) make_pair(x, y)

typedef long long ll;
typedef unsigned long long ull;

using namespace std;

const int maxn = 3e2 + 5;
const int P = 998244353;
const ull seed = 255;

int n, m;
char s[maxn][maxn];
long double mi[maxn], a[maxn][maxn], ans[maxn];
ull Hash[maxn][maxn], seedi[maxn];

inline int read() {
	char ch = getchar(); int u = 0, f = 1;
	while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch))  { u = u * 10 + ch - 48; ch = getchar(); } return u * f;
}

inline int pls(int x, int y) { x += y; return x >= P ? x - P : x; }
inline int dec(int x, int y) { x -= y; return x < 0 ? x + P : x; }

inline bool Gauss(long double a[maxn][maxn], int n) {
	rep(i, 1, n) {
		int p = i;
		rep(j, i + 1, n) if(fabs(a[j][i]) > fabs(a[p][i])) p = j;
		if(p != i) swap(a[p], a[i]);
		rep(j, i + 1, n) {
			long double ratio = a[j][i] / a[i][i];
			rep(k, i, n + 1) a[j][k] -= ratio * a[i][k];
		}
	}
	dep(i, n, 1) {
		ans[i] = a[i][n + 1] / a[i][i];
		dep(j, i - 1, 1) a[j][n + 1] -= a[j][i] * ans[i];
	} return true;
}

int main() {
//	freopen("1.in", "r", stdin);
	n = read(); m = read(); mi[0] = 1; seedi[0] = 1;
	rep(i, 1, m) mi[i] = mi[i - 1] * 0.5;
	rep(i, 1, m) seedi[i] = seedi[i - 1] * seed;
	rep(i, 1, n) {
		scanf("%s", s[i] + 1);
		rep(j, 1, m) Hash[i][j] = Hash[i][j - 1] * seed + s[i][j];
	}
	rep(i, 1, n) a[i][n + 1] = -mi[m], a[i][i]++;
	rep(i, 1, n) a[n + 1][i] = 1; a[n + 1][n + 2] = 1;
	rep(i, 1, n) rep(j, 1, n)
		rep(k, 1, m - (i == j)) if(Hash[i][k] == Hash[j][m] - Hash[j][m - k] * seedi[k])
			a[i][j] += mi[m - k];
//	rep(i, 1, n + 1) {
//		rep(j, 1, n + 2) cerr << a[i][j] << " ";
//		cerr << endl;
//	}
	Gauss(a, n + 1);
	rep(i, 1, n) printf("%.10lf\n", (double)(ans[i]));
	return 0;
}
```

---

## 作者：花淇淋 (赞：6)

# Solution
 - 将所有可能的硬币序列分成 $3$ 类：
    $1.$终止态：生成这个序列后**刚好**结束游戏。
    $2.$非终止态：生成这个序列后**还没**结束游戏。
    $3.$非法态：这个序列**还没生成完**就结束游戏，即存在一个比它短的前缀是终止态。
 - 记 $P_i$ 表示第 $i$ 个人获胜的概率，记 $P_0$ 表示生成所有**非终止态**序列的概率之和。记 $A$ 为**任意一个非终止态**序列，可以为空。
 - $n+1$ 个变量需要 $n+1$ 个方程，先列一个 $\sum_{i=1}^nP_i=1$。
 - 剩下的举个例子：
   $S_1=THT,S_2=TTH,S_3=HTT$
   使 $2$ 获胜的串一定是 $ATTH$，但 $ATTH$ 可能是**非法态**。
 
    $P(2$ 获胜$)=$ $P($生成以 $TTH$ 为后缀的**终止态**串$)$
   $=P($生成 $ATTH)-P($生成 $ATTH$，且 $AT$ 或 $ATT$ 为**终止态**的串，即 $ATTH$ 是**非法态**$)$
   
   $(1).AT$ 为**终止态**的条件是 $A$ 有后缀 $TH$ 或 $HT$，这样 $AT$ 会使 $1$ 或 $3$ 获胜，生成一个**终止态 $AT$** 的概率就是 $P_1+P_3$，再生成一个 $TH$ 的概率是 $0.25$， 于是生成这种 $ATTH$ 的概率为 $0.25(P_1+P_3)$。
   
   $(2).ATT$ 为**终止态**的条件是 $A$ 有后缀 $H$，这样会使 $3$ 获胜，生成一个**终止态 $ATT$** 的概率就是 $P_3$，于是生成这种 $ATTH$ 的概率为 $0.5P_3$。

    $(3).P($生成 $ATTH)=0.125P_0$。

	于是就有：$P_2=0.125P_0-0.25P_1-0.75P_3$。
	
 - 类似地，可以列出 $n$ 个 $P_i=...$ 的方程。可以发现，如果 $S_i$ 有一个前缀和 $S_j$ 的一个后缀相等，则会对方程 $P_i=...$ 中 $P_j$ 的系数有贡献。
 - 注意当$S_i$ 有一个**长度小于本身的前缀后缀**相同，则方程右边也会出现 $P_i$，例如 $P_1$，如果 $A$ 以 $TH$ 为后缀，那么 $ATHT$ 也是一个**非法态**。
 
 
# Code
 
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

const ll z1 = 29, z2 = 31;
const int e = 605, h1 = 1e9 + 7, h2 = 1e9 + 9;
double p[e], b[e], a[e][e], ans[e];
int nxt[e], m, n, len, s1[e][e], s2[e][e], p1[e], p2[e];
char s[e][e], c[e];

inline void gauss()
{
    int i, j, k;
    for (i = 1; i < n; i++)
    {
        int x = i;
        for (j = i; j <= n; j++) if (fabs(a[j][i]) > fabs(a[x][i])) x = j;
        if (a[x][i] == 0) continue;
        if (x != i)
        {
            for (j = i; j <= n; j++) swap(a[x][j], a[i][j]);
            swap(b[x], b[i]);
        }
        for (j = i + 1; j <= n; j++)
        {
            double y = a[j][i] / a[i][i];
            for (k = i; k <= n; k++) a[j][k] -= a[i][k] * y;
            b[j] -= b[i] * y;
        }
    }
    for (i = n; i >= 1; i--)
    {
        ans[i] = b[i];
        for (j = i + 1; j <= n; j++) ans[i] -= a[i][j] * ans[j];
        ans[i] /= a[i][i];
    }
}

inline int calc1(int i, int l, int r)
{
    int res = s1[i][r];
    res -= (ll)s1[i][l - 1] * p1[r - l + 1] % h1;
    if (res < 0) res += h1;
    return res;
}

inline int calc2(int i, int l, int r)
{
    int res = s2[i][r];
    res -= (ll)s2[i][l - 1] * p2[r - l + 1] % h2;
    if (res < 0) res += h2;
    return res;
}

int main()
{
    scanf("%d %d\n", &n, &m);
    int i, j, k; 
    for (i = 1; i <= n; i++) scanf("%s", s[i] + 1);
    p[0] = p1[0] = p2[0] = 1; n++;
    for (i = 1; i <= m; i++) 
    p[i] = 0.5 * p[i - 1], p1[i] = z1 * p1[i - 1] % h1, p2[i] = z2 * p2[i - 1] % h2;
    for (i = 1; i < n; i++)
    for (j = 1; j <= m; j++)
    s1[i][j] = (z1 * s1[i][j - 1] + s[i][j]) % h1, s2[i][j] = (z2 * s2[i][j - 1] + s[i][j]) % h2;
    for (i = 1; i < n; i++)
    for (j = 1; j < n; j++)
    {
        for (k = 1; k <= m; k++)
        if (calc1(i, 1, k) == calc1(j, m - k + 1, m) && calc2(i, 1, k) == calc2(j, m - k + 1, m))
        {
            if (k == m) a[i][j]++;
            else a[i][j] += p[m - k];
        }
        a[i][n] = -0.125; a[n][i] = 1;
    } 
    b[n] = 1.0;
    gauss();
    for (i = 1; i < n; i++) printf("%.7lf\n", ans[i]);
    return 0;
}
```


---

## 作者：FjswYuzu (赞：5)

失去了语言表达能力，被笑了 /kk。所以来写篇题解。

令 $P$ 为同学押的 $s$ 的集合。

一个局面 $S$ 是结束态，当且仅当 $\operatorname{suf}(S,m) \in P$ 且没有其他的子串 $t \in P$；非结束态即不存在子串 $t \in P$；一个结束态扩展出来的新字符串被称作非法态。

在讲的时候，我没有点明 $T$ 这个变量（就是下面的 $q_S$）的含义。在下面会解释。

有些题只考虑概率是非常野蛮的，我们将其转移到期望上面。假设答案是 $p_1,p_2,\cdots ,p_n$，那么每个字符串 $s_i$ 出现的期望次数的值是等于 $p_i$ 的（显然？），记作 $q_i$。

假设现在有一个非结束态 $S$，我们强制在后面加一个字符串 $s_i$，变成 $Ss_i$。注意到 $Ss_i$ 可能是一个非法态（即，$Ss_i$ 有一个另外的子串 $s_j$），那么假设 $Ss_i$ 是一个结束态，那么 $q_i = q_S \times 2^{-m}$（因为我们要刚好拼出 $s_i$，所以是 $2^{-m}$），其中，$q_S$ 表示，任意一个非结束态出现的期望次数，即所有非结束态出现的概率之和（感性理解一下）。

但是可能会被截胡，也就是 $Ss_i$ 是一个非法态，其已经存在一个 $s_j$ 为子串了。此时 $s_i,s_j$ 满足存在一个 $k$，使得 $\operatorname{pre}(s_i,k) = \operatorname{suf}(s_j,k)$。这样的话胜利的就是 $j$ 了。于是我们的 $q_i$ 还要减去所有 $j$ 造成的不合法贡献。注意到在这个时候我们钦定了 $j$ 的胜利，也就是说前面 $|S| + k$ 个字符已经被确定了（这样才能保证 $j$ 的胜利，同时贡献还要乘上 $p_j=q_j$），同时在此时我们钦定了后面 $m$ 个字符构成的字符串为 $s_i$，因此还有 $m-k$ 个字符需要被确定，因此其贡献还要乘上满足限制的概率（就是 $2^{-(m-k)}$）。我们枚举 $j,k$，不难发现：
$$
q_S \times 2^{-m} - \sum_{j=1}^n q_j \sum_{k=1}^{m-[i=j]} [\operatorname{pre}(s_i,k) = \operatorname{suf}(s_j,k)] 2^{-(m-k)} = q_i
$$

注意到我们直接拼出来了 $s_i$ 不应该被算作被排除的贡献，所以在 $i=j$ 的时候要保证 $k \neq m$。

移项改写成一种好看的形式是：
$$
q_S \times 2^{-m} - \sum_{j=1}^n q_j \sum_{k=1}^{m} [\operatorname{pre}(s_i,k) = \operatorname{suf}(s_j,k)] 2^{-(m-k)} = 0
$$

现在有 $n$ 个有 $n+1$ 个未知数的方程。观察样例可以知道 $\sum_{i=1}^n p_i = 1$。因此可以直接高斯消元。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
typedef unsigned long long LL;
typedef double db;
const LL base=1145141;
LL pw[305],hsh[305][305];
int n,m;
char s[305][305];
double a[305][305],pw2[305],ret[305];
void Gauss(int N)
{
	for(int i=1;i<=N;++i)
	{
		int maxn=i;
		for(int j=i+1;j<=N;++j)	if(fabs(a[j][i])>fabs(a[maxn][i]))	maxn=j;
		swap(a[i],a[maxn]);
		if(a[i][i]==0)	assert(false);
		for(int j=1;j<=N;++j)
		{
			if(j==i)	continue;
			double del=a[j][i]/a[i][i];
			for(int k=i+1;k<=N+1;++k)	a[j][k]-=a[i][k]*del;
		}
	}
	for(int i=1;i<=N;++i)	ret[i]=a[i][N+1]/a[i][i];
}
LL getHash(int id,int l,int r){return hsh[id][r]-hsh[id][l-1]*pw[r-l+1];}
int main(){
	pw[0]=pw2[0]=1;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)	scanf("%s",s[i]+1);
	for(int i=1;i<=m;++i)	pw2[i]=pw2[i-1]/2.0;
	for(int i=1;i<=m;++i)	pw[i]=pw[i-1]*base;
	for(int i=1;i<=n;++i)	for(int j=1;j<=m;++j)	hsh[i][j]=hsh[i][j-1]*base+(s[i][j]^'a')+1;
	for(int i=1;i<=n;++i)	a[i][n+1]=-pw2[m];
	for(int i=1;i<=n;++i)	a[n+1][i]=1;a[n+1][n+2]=1;
	for(int i=1;i<=n;++i)	for(int j=1;j<=n;++j)	for(int k=1;k<=m;++k)	if(getHash(i,1,k)==getHash(j,m-k+1,m))	a[i][j]+=pw2[m-k];
	Gauss(n+1);
	for(int i=1;i<=n;++i)	printf("%.12f\n",ret[i]);
	return 0;
}
```

---

## 作者：juju527 (赞：5)

### 前置知识
概率生成函数，kmp/hash

建议做完[[CTSC2006]歌唱王国](https://www.luogu.com.cn/problem/P4548)后食用该篇文章

### $\texttt{Solution}$
考虑设$f_{i,k}$表示第i个人在第k轮后胜利的概率

其生成函数为$F_i(x)=\sum_{k=0}f_{i,k}x^k$

$F_i(1)$即为答案

易知$\sum_{i=1}^nF_i(1)=1$

考虑类似歌唱王国的思路，设出一个辅助生成函数$G(x)=\sum_{k=0}g_kx^k$

$g_k$表示在第i轮后仍未有人胜利的概率

可以得到 $g_k=g_{k+1}+\sum_{i=1}^nf_{i,k+1}$

考虑我们在第c轮后强制后面选第t个人的字符串

概率为$g_c2^{-m}$

同样，由于可能提前结束，我们可以用f表示出这个概率

$\sum_{i=1}^n\sum_{j=1}^m[S_t[1,k]=S_i[m-k+1,m]]f_{c+j}2^{j-m}$

即
$G(x)=\sum_{i=1}^n\sum_{j=1}^m[S_t[1,k]=S_i[m-k+1,m]]F_i(x)x^{-j}2^j$

代入$x=1$

总共n+1个方程，n+1个未知数

高斯消元即可

### 小结
"算两次"是一个非常优秀的思考方式

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=305,maxm=305;
const int base=233,mod=998244353;
const double eps=1e-10;
char s[maxn][maxm];
int pw[maxm];
int h[maxn][maxm];
int b[maxn][maxn][maxm];
double a[maxn][maxn],P[maxm];
int read(){
    int x=0,y=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x*y;
}
inline int add(int x){
    if(x>=0)x-=mod;
    return x;
}
inline int sub(int x){
    if(x<0)x+=mod;
    return x;
}
int get(int p,int l,int r){
    return sub(h[p][r]-1ll*h[p][l-1]*pw[r-l+1]%mod);
}
void solve(int n){
    for(int i=1;i<=n;i++){
        int p=i;
        for(int j=i+1;j<=n;j++)if(fabs(a[j][i])-fabs(a[p][i])>eps)p=j;
        swap(a[p],a[i]);
        double v=1.0/a[i][i];
        for(int j=i;j<=n+1;j++)a[i][j]*=v;
        for(int j=i+1;j<=n;j++){
            double t=a[j][i];
            for(int k=i;k<=n+1;k++)a[j][k]-=t*a[i][k];
        }
    }
//    for(int i=1;i<=n;i++,cout<<endl)for(int j=1;j<=n+1;j++)cout<<a[i][j]<<" ";
    for(int i=1;i<=n;i++){
        for(int j=1;j<i;j++){
            double t=a[j][i];
            for(int k=i;k<=n+1;k++)a[j][k]-=t*a[i][k];
        }
    }
    return ;
}
int main(){
    int n,m;
    n=read();m=read();
    for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
    pw[0]=1;
    for(int i=1;i<=m;i++)pw[i]=1ll*pw[i-1]*base%mod;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)h[i][j]=add(1ll*h[i][j-1]*base%mod+s[i][j]);
    P[0]=1;
    for(int i=1;i<=m;i++)P[i]=P[i-1]*2;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=m;k++)
                a[i][j]+=(get(i,1,k)==get(j,m-k+1,m))?P[k]:0;
    for(int i=1;i<=n;i++)a[n+1][i]=1;a[n+1][n+1]=0;a[n+1][n+2]=1;
    for(int i=1;i<=n;i++)a[i][n+1]=-1,a[i][n+2]=0;
//    for(int i=1;i<=n+1;i++,cout<<endl)for(int j=1;j<=n+2;j++)cout<<a[i][j]<<" ";
    solve(n+1);
//    for(int i=1;i<=n+1;i++,cout<<endl)for(int j=1;j<=n+2;j++)cout<<a[i][j]<<" ";
    for(int i=1;i<=n;i++)printf("%.10lf\n",a[i][n+2]);
    return 0;
}
```

---

## 作者：Log_x (赞：5)

# Solution
- 尝试把这题讲得更为清楚些。
- 访问[博客](https://blog.csdn.net/bzjr_Log_x/article/details/100007360)，阅读体验更佳。

## Part 1

- 左转这道题的弱化版 [BZOJ1444 [JSOI2009]有趣的游戏](https://www.lydsy.com/JudgeOnline/problem.php?id=1444)。
- 考虑建出 AC 自动机，则一个长度任意的字符串对应了 AC 自动机上的一条有向路径（可经过重复点）。
- 直观的想法是设 $P_i$ 表示到达 AC 自动机上结点 $i$ 的概率，最后答案即为那些被标记过的节点的 $P$ 值。
- 但我们注意到，转移是会成环的，尽管我们能够用高斯消元解决成环的转移，但我们计算的概率是不能在 AC 自动机上走一圈再加回来的。
- 归根结底，是我们设计的状态出现了问题。
- 实际上应该设 $E_i$ 表示经过 AC 自动机上结点 $i$ 的期望次数，就允许了一个结点被经过多次，并且到达被标记过的结点之后游戏就会结束，所以被标记过的结点的 $E$ 值在数值上就等于到达这个结点的概率。
- 设 $G[i][j]$ 表示 AC 自动机上的结点 $i$ 经过字符为 $j$ 的转移边到达的结点， 则对于每个未被标记过的结点 $i$，显然有转移：$E_{G[i][j]} += \frac{1}{2} E_i$
- 根据这些转移我们就能对于每个节点列出一个方程，注意我们的起点是根节点，所以关于根节点的方程的常数项要加一。
- 用高斯消元解方程组即可， 因为 AC 自动机的结点数为 $O(nm)$ 级别，时间复杂度 $O(n^3m^3)$。

## Part 2

- 上一个做法的问题在于未知量的数量过多，实际上我们并不关心那些未被标记过的结点的 $E$ 值，而被标记过的结点只有 $O(n)$ 级别。
- 考虑设 $E_i$ 表示经过 AC 自动机上第 $i$ 个被标记过的结点的期望次数，另外记 $E_0$ 表示经过 AC 自动机上未被标记的结点的期望次数的和。
- 现在我们需要根据这些变量的关系列出 $n + 1$ 个方程，最后同样用高斯消元解出答案。
- 注意到 $E_i$ 的实际意义是第 $i$ 个人获胜的概率。尽管我们也许能够构造出一个无穷长的序列使得没有人获胜，但这样必须不停地抛硬币，概率无限趋近于0。于是我们可以得到第一个方程：$\sum \limits_{i = 1}^{n} E_i  = 1$
- 考虑从 AC 自动机上一个未被标记的结点出发，按照第 $i$ 个人给定的硬币序列，依次经过 $m$ 条转移边，如果不考虑在这一过程中已经经过了被标记过的点而导致游戏结束，最后一定能走到第 $i$ 个被标记过的结点，即 $E_i = \frac{1}{2^m}E_0$（每走一步的概率都是 $\frac{1}{2}$）。
- 现在要扣除那些不合法的情况（这也正是 $E_i$ 可能互不相同的原因），考虑枚举这一过程中经过的第一个被标记过的点，假定它是第 $j$ 个被标记的点（$j$ 可以等于 $i$），那么一定存在一个 $k(1 \le k < m)$ 使得第 $j$ 个硬币序列长度为 $k$ 的后缀等于第 $i$ 个硬币序列长度为 $k$ 的前缀，据此可以对于每一个 $i$ 列出一个方程：$E_i + \sum \limits_{j = 1}^{n} (\sum \limits_{k = 1}^{m - 1}[pre(i,k)=suf(j,k)] \frac{1}{2^{m - k}})E_j - \frac{1}{2^m}E_0 = 0$
- 其中 $pre(i, k)$ 即表示第 $i$ 个硬币序列长度为 $k$ 的前缀，$suf(j,k)$ 同理。
- 实现时可以通过哈希暴力判断前后缀相等，时间复杂度 $O(n^3)$。

# Code

```cpp
#include <bits/stdc++.h>

const int mod1 = 1e9 + 7;
const int mod2 = 1e9 + 9;
const int N = 305;
char s[N][N]; double ex[N], f[N][N];
int a[N], p1[N], p2[N];
int pre1[N][N], pre2[N][N], suf1[N][N], suf2[N][N];
int n, m;

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		scanf("%s", s[i] + 1);
	ex[0] = 1;
	for (int i = 1; i <= m; ++i)
		ex[i] = 0.5 * ex[i - 1];

	p1[0] = p2[0] = 1;
	for (int i = 1; i <= m; ++i)
	{
		p1[i] = 29ll * p1[i - 1] % mod1;
		p2[i] = 31ll * p2[i - 1] % mod2;
	}
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= m; ++j)
			a[j] = s[i][j] == 'T' ? 5 : 7;
		for (int j = 1; j <= m; ++j)
		{
			pre1[i][j] = (29ll * pre1[i][j - 1] + a[j]) % mod1;
			pre2[i][j] = (31ll * pre2[i][j - 1] + a[j]) % mod2;
		}
		for (int j = 1; j <= m; ++j)
		{
			int tmp = m - j + 1;
			suf1[i][j] = (1ll * p1[j - 1] * a[tmp] + suf1[i][j - 1]) % mod1;
			suf2[i][j] = (1ll * p2[j - 1] * a[tmp] + suf2[i][j - 1]) % mod2;
		}
	}
	for (int i = 1; i <= n; ++i)
	{
		f[i][i] = 1.0;
		for (int j = 1; j <= n; ++j)
			for (int k = 1; k < m; ++k)
				if (suf1[j][k] == pre1[i][k] && suf2[j][k] == pre2[i][k])
					f[i][j] += ex[m - k];
		f[i][n + 1] -= ex[m];
	}
	for (int i = 1; i <= n; ++i)
		f[n + 1][i] = 1.0;
	f[n + 1][n + 2] = 1.0;

	++n;
	for (int i = 1; i <= n; ++i)
	{
		int p = i;
		for (int j = i + 1; j <= n; ++j)
			if (fabs(f[p][i]) < fabs(f[j][i]))
				p = j;
		if (p != i)
		{
			for (int j = i; j <= n + 1; ++j)
				std::swap(f[p][j], f[i][j]);
		}

		double tmp = f[i][i];
		for (int j = i; j <= n + 1; ++j)
			f[i][j] /= tmp;

		for (int j = 1; j <= n; ++j)
			if (j != i)
			{
				tmp = f[j][i];
				for (int k = i; k <= n + 1; ++k)
					f[j][k] -= tmp * f[i][k];
			}
	}
	for (int i = 1; i < n; ++i)
		printf("%.10lf\n", f[i][n + 1]);
}
```

---

## 作者：fengwu (赞：3)

#solutions

[题面(luogu)](https://www.luogu.com.cn/problem/P3706)

这个题吧是我很久很久以前留下的坑了，到了今天才补好。（~~是不是太菜了~~）

### 暴力

这个和之前的题解一样，确实可以用 trie 树，这复杂度是$\mathcal{O(n^3m^3)}$。

您就是初学OI，也不应该看到数据范围之后想到这样的复杂度。

所以这个暴力就直接舍弃吧。

但是如果别的题用到了，还是可以试一试的，毕竟考试的时候部分分还是比较重要的。

### 正解

不知道咱也不知道为啥这个题的思路可以如此的妙。

首先考虑，每一个合法的能够让一个玩家赢的字符串序列一定是由一个啥也匹配不上的序列和当前玩家的序列构成并且当前玩家的序列是整个序列的后缀。

但是你发现，完全无法找全这样的每一个序列，并且序列是无限个的。

假如我当前有一个序列 S ，那么我可以得到一个合法的序列。

设这个合法的序列为 $N=S+a_j$，$a_j$ 为每一个玩家的序列。

可能你会认为，这样不就是 $j$ 玩家获胜的概率了？？？？

你错了，你不知道这个 $S$ 里面会发生什么，也许这个 $S$ 中已经满足了另外一个玩家的序列

所以一切都在不可测之中。

但是你并不关心前面的序列究竟是什么，因为他的末尾一定是 $a_j$。

这样的话我们就需要把前面所有的情况都算上，全部！！！

比如说我们这里有两个人 $HT$ ， $TH$。

那么我们就有这样一个不太好的序列 $HTH$ ，这种序列就是我所说的那种坏坏的序列

虽然他是以 $TH$ 结尾的，但是他前面包含了 $HT$ 这个序列，所以我们会发现，

在以 $TH$ 结尾的所有序列中（前面可以加入任意多个字符，当然也可以不加），

我们发现，这种序列的贡献由两部分组成，一部分是 $TH$ 结尾的贡献，

另一部分就是 $HT$ 结尾的贡献，那么现在最大的问题就是如何计算这个贡献。

你发现这时候想着想着正解就在眼前了。

这时候你不确定这些序列会造成多少贡献，就是你不知道这些以玩家序列结尾的序列的贡献

所以这里也是一个未知数N，那其他的玩家胜利的概率 $x_i$ ，这时候我们已经找到了 $n+1$ 个未知数了。

接下来的任务就是如何求解这些未知数了，一般遇到这么多未知数，一眼就是高斯消元。

所以我们就要寻找这些未知数之间的关系。

第一个方程，一定会有一个玩家胜利，那么 $\sum\limits_{i=1}^{n}x_i=1$

根据刚才我们的分析，我们发现，对于以玩家序列结尾的序列可以根据每两个玩家的序列分为很多部分，

这个序列出现的概率就是 $\frac{1}{n}N$ 而如果当前玩家的前缀和其他玩家的后缀相同，

那这个概率就可以表示为这些玩家胜出的概率再乘上出现当前情况的概率，

我们设 $fro_{ij}$ 表示 $i$ 玩家的长度为 $j$ 的前缀，后缀同样处理为 $beh_{ij}$

于是我们就有 $\frac{1}{n}N=\sum\limits_{i=1}^{n}x_i\sum\limits_{j=1}^{n}\sum\limits_{k=0}^{m}[fro_{ik}==beh_{jk}]\frac{1}{2^{m-k}}$

这时候我们就有 $n+1$ 条方程了，就是直接高斯消元即可

<details>
<summary>AC_code</summary>
<code>

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register int
#define ull unsigned long long
#define double long double
const int N=305;
int n,m;
char ch[N][N];
ull hs[N][N],bas=131,ba[N];
double a[N][N],x[N],mse[N];
signed main(){
	scanf("%d%d",&n,&m);
	ba[0]=1;mse[0]=1;
	for(re i=1;i<=m;i++)
		ba[i]=ba[i-1]*bas,
		mse[i]=mse[i-1]/2.0;
	for(re i=1;i<=n;i++){
		scanf("%s",ch[i]+1);
		for(re j=1;j<=m;j++)
			hs[i][j]=hs[i][j-1]*bas+ch[i][j];
	}
	for(re i=1;i<=n;i++){
		for(re j=1;j<=n;j++){
			double ans=0;
			for(re k=0;k<=m;k++){
				ull tmpf=hs[i][k];
				ull tmpb=hs[j][m]-hs[j][m-k]*ba[k];
				if(tmpf==tmpb)ans+=mse[m-k];//cout<<k<<" ";
			}
			//cout<<endl;
			//cout<<ans<<" "<<mse[0]<<endl;
			a[i][j]=ans;
		}
		a[i][n+1]=-mse[m];
	}
	for(re i=1;i<=n;i++)a[n+1][i]=1.0;
	a[n+1][n+2]=1.0;n++;
	int h,z;
	for(h=1,z=1;h<=n&&z<=n;h++,z++){
		int maxn;
		for(re i=h;i<=n;i++)
			if(a[i][z]!=0){
				maxn=i;break;
			}
		if(maxn!=h)
			for(re i=1;i<=n+1;i++)
				swap(a[maxn][i],a[h][i]);
		//if(fabs(a[h][z])==0){
		//	h--;continue;
		//`}
		for(re i=h+1;i<=n;i++)
			if(a[i][z]!=0){
				double t=a[i][z]/a[h][z];
				for(re j=z;j<=n+1;j++)
					a[i][j]-=a[h][j]*t;
			}
	}
	//cout<<h<<" "<<z<<endl;
	for(re i=n;i>=1;i--){
		double t=a[i][n+1];
		for(re j=n;j>i;j--)
			t-=a[i][j]*x[j];//cout<<t<<" "<<a[i][j]<<endl;
		x[i]=t/a[i][i];
		//cout<<t<<endl;
	}
	for(re i=1;i<=n-1;i++){
		printf("%.10Lf\n",x[i]);
	}
}
```
</code>
</details>

---

## 作者：zJx_Lm (赞：3)

### 所需算法 ：
- [HASH](https://www.cnblogs.com/moyujiang/p/11213535.html)
- 概率与期望
- 高斯消元

hash 主要用来判断字符串的前后是否匹配。
 
------------

### First：
我们知道，在理想状态下，每位小朋友获胜的概率应该是相等的 $ \frac{k}{2^{m}} $，因为要保证小朋友的胜率之和为一嘛，所以乘个 $ k $。
   
   ~~但是 细思极恐  . . . . . .~~
   
我们不知道在这位小朋友等待胜利到来的同时，其他小朋友会不会乘虚而入，
   
举个例子 ：
   
令 $ I_{i} $ 为小朋友 $ i $ 选的字符串，$ S' $ 为没有任何小朋友胜利的字符串

$ S = S' + I_{i}  $。

$ S $ 的后几位可能与 $ I_{i} $ 的前几位促使另外一个小朋友获胜，
也就是说，各小朋友的胜率具有很大的不等性。
   
但答案加上以上这些情况应为一个相等的概率，也就是是上面的那个式子。
   
   
### Second：

我们设 $ f $ 数组为小朋友的胜算，则：
$
f_{i}=\frac{k}{2^{m}}-\sum_{j=1}^{n}\;\left(f_{j}\times \sum_{k=1}^{m-1}[left_{i,k}=right_{j,k}]\frac{1}{2^{m-k}}\right)
$ 

也就是原本胜算减去其他使胜算减少的情况的概率。

 $ left_{i,k} = right_{j,k} $ 表示字符串 $ i $ 的左 $ k $ 位与字符串 $ j $ 的右 $ k $ 位相等，这个操作可以用 hash 来实现。

主要思路是枚举与其他小朋友相同的字符段，而后剩下的 $ m - k $ 段是随机的，所以再乘个 $ \frac{1}{2^{m-k}} $。

这时我们发现我们有 $ n+1 $ 个未知数，而仅有 $ n $ 个式子。回归本源，凡游戏均有胜负，再加上所有小朋友胜率和为一的式子，即：
$
\sum_{i=1}^{n}fi=1
$

最后高斯消元即可。

*CODE :*
```cpp
#include <cmath>
#include <cstdio>
#define maxn 308
#define re register
using namespace std;
int n,m,as[maxn]; char c[maxn];
double a[maxn][maxn],bin[maxn],f[maxn];
unsigned long long P=13331,hash[maxn][maxn],seek[maxn];
inline int read() {
	int s=0,w=1; char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-')w=-1;ch=getchar(); }
	while(ch>='0'&&ch<='9') { s=s*10+ch-'0';ch=getchar(); }
	return s*w;
}

inline void guass() {
	for(re int i=1;i<=n;i++) {
		for(re int j=i+1;j<=n;j++) {
			double b=a[j][i]/a[i][i];
			for(re int k=i+1;k<=n+1;k++) a[j][k]-=a[i][k]*b; 
		}
	}
	for(re int i=n;i>=1;i--) {
		f[i]=a[i][n+1]/a[i][i];
		for(re int j=i-1;j>=1;j--) a[j][n+1]-=a[j][i]*f[i];
	}
}

signed main(void) {
	n=read(),m=read();
	bin[0]=1.0;seek[0]=1;
	for(re int i=1;i<=maxn;i++) bin[i]=bin[i-1]*0.5;
	for(re int i=1;i<=maxn;i++) seek[i]=seek[i-1]*P;
	for(re int i=1;i<=n;i++) {
		scanf("%s",c+1);
		for(re int j=1;j<=m;j++) {
			as[j]= (c[j]=='T') ? 1:2;
			hash[i][j]=hash[i][j-1]*P+as[j];
		}
	}
	for(re int i=1;i<=n;i++) {
		a[i][i]=1.0;a[i][n+1]=-bin[m];
		for(re int j=1;j<=n;j++) {
			for(re int k=1;k<m;k++) 
			if(hash[i][k]==(hash[j][m]-hash[j][m-k]*seek[k])) {
				a[i][j]+=bin[m-k];
			} 
		} 
	} 
	n++;	
	for(re int i=1;i<=n+1;i++) { a[n][i]=1.0; } 
	a[n][n]=0;
	guass();
	for(re int i=1;i<=n-1;i++) printf("%.10lf\n",f[i]);
} 




```




---

## 作者：i207M (赞：1)

有N个预先给定的、长度均为M的模式串。

现在系统逐位随机生成 01 串，直到某个模式串成为生成的串

问每个模式串被首先生成的概率

300 个串，每个串不超过 300

**可参见寒假集训Part2**

和CTSC2006Singleland类似，我们列出函数$G_i$表示字符串在长度为k处以第i个串结尾；$F$表示在长度为k处出现了模式串（之前可以也出现过），$F=\frac{x^2}{1-2x}$；$P_{ab}=\sum _i[a[i+1...m]=b[1,m-i]]x^i$

则有递推式：$G_i=F-\sum_jG_j(F+P_{ji})$

我们要求所有的$G_i(0.5)$。去分母，使用洛必达法则，微分并做一番操作后可得（S为字符集大小）：

$-SG_i=Sx^{S-1}-x^S\sum_j G'_j-Sx^{S-1}\sum_jG_j+S\sum G_jP_{ij}$

这样我们就有了n个方程，

我们发现$\sum_j G'_j$是定值，我们可以把它也视作未知数，它的含义是期望结束长度。

我们再补一个方程：$\sum g_i=1$，原因是这个游戏一定会结束。

```cpp
#define N 305
#define eps 1e-10
double g[N][N];
void gauss(int n)
{
	for(ri i=1; i<=n; ++i)
	{
		if(fabs(g[i][i])<eps)
		{
			for(ri j=i+1; j<=n; ++j)
				if(fabs(g[j][i])>eps)
				{
					for(ri k=i; k<=n+1; ++k)
						swap(g[i][k],g[j][k]);
				}
		}
		for(ri j=i+1; j<=n+1; ++j) g[i][j]/=g[i][i];
		g[i][i]=1;
		for(ri j=i+1; j<=n; ++j)
			if(fabs(g[j][i])>eps)
			{
				for(ri k=i+1; k<=n+1; ++k) g[j][k]-=g[j][i]*g[i][k];
				g[j][i]=0;
			}
	}
	for(ri i=n; i>=1; --i)
	{
		for(ri j=i+1; j<=n; ++j) g[i][n+1]-=g[i][j]*g[j][n+1];
		g[i][n+1]/=g[i][i];
	}
}
const int bas=3;
int m,pw[N];
struct H
{
	int h[N];
	void init(const char s[])
	{
		for(ri i=1; i<=m; ++i) h[i]=add(mul(h[i-1],bas),(s[i]=='H'?1:2));
	}
	il int geth(int l,int r)
	{
		return sub(h[r],mul(h[l-1],pw[r-l+1]));
	}
} h[N];
double pw2[N];
double solve(int a,int b)
{
	double res=0;
	for(ri i=1; i<m; ++i)
		if(h[a].geth(i+1,m)==h[b].geth(1,m-i))
		{
			res+=pw2[i-1];
			// out(a,b,i);
		}
	return res;
}
int n;
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);
#endif
	in(n,m);
	pw[0]=1;
	for(ri i=1; i<=m; ++i) pw[i]=mul(pw[i-1],bas);
	pw2[0]=1;
	for(ri i=1; i<=m; ++i) pw2[i]=pw2[i-1]*0.5;
	for(ri i=1; i<=n; ++i)
	{
		static char tc[N];
		scanf("%s",tc+1);
		h[i].init(tc);
	}
	for(ri i=1; i<=n; ++i) g[n+1][i]=1; g[n+1][n+2]=1;
	for(ri i=1; i<=n; ++i)
	{
		g[i][n+1]=1;
		for(ri j=1; j<=n; ++j) g[i][j]=solve(j,i)-1;
		g[i][i]+=2;
	}
	// for(ri i=1; i<=n+1; ++i)
	// {
	// 	for(ri j=1; j<=n+2; ++j)
	// 		printf("%.3f ",g[i][j]);
	// 	enter;
	// }
	gauss(n+1);
	for(ri i=1; i<=n; ++i) printf("%.10f\n",g[i][n+2]);
	return 0;
}
```

---

## 作者：kyEEcccccc (赞：0)

[根号的月读体验](https://www.cnblogs.com/kyeecccccc/p/16951773.html)

## 题意
有 $n$ 个人，第 $k$ 个人猜一个长度为 $m$ 的01串 $A_k$ ，互不相同；接下来依次生成一列随机变量 $\{X_i\}$ ，其中每一个等概率为0或1。当$A_k$在这一列随机变量中连续出现时$k$胜利，并且其他人不再胜利。问每个人胜利的概率 $\{P_k\}$ 。( $1\le n,m\le 300$ )

## 题解
有一个朴素做法。建出 AC 自动机，在每一个时刻，随着随机变量的产生，状态会进行一系列转移，停留在一个特定节点。所以在自动机上依据转移边构造一系列方程，其中每个变量表示某个特定节点被经过次数的期望。

注意这一步转化很重要，因为在状态转移过程中会不止一次经过一个节点。设想，如果在大多情况会多次经过一个节点 $a$ ，但是往往只经过一次节点 $b$ ，然而两者“被经过”的概率相同，那么假设终止状态 $x$ 从 $a$ 转移， $y$ 从 $b$ 转移，则转移到$x$的概率显然比 $y$ 更高。然而，如果只记录转移过程中“是否经过”某个节点，就不能体现多次经过的贡献。而经过次数的数学期望，就体现了转移次数这个重要信息。

那么怎样体现胜利概率呢？很简单，只要不允许终止状态产生任何后续转移，那么每种情况只会有唯一的一个终止状态被经过唯一一次，符合题意，而终止节点被经过次数的期望就是胜利概率。高斯消元即可。这道题是《JSOI2009 有趣的游戏》。

然而这题数据范围太大了，高斯消元 $\Omicron(n^3m^3)$ 不能接受。当遇到这种情况时，往往要考虑压缩状态，忽略冗余信息的方法。这道题需要的仅仅是每个人的终止节点的次数期望，这些变量必须保留，而前面那些状态只要转移到最终状态就行了，至于如何转移，从哪里转移，互相怎么转移，这些信息应该试图去简化、合并。设到达一个状态 $S$ 的次数为随机变量 $Tot(S)$ ，第 $k$ 个人赢的概率（也就是它的状态到达次数）为 $f(k)$ 。

如果做过《CTSC2006 歌唱王国》（我也写过题解）那么对于它的生成函数做法一定记忆犹新（虽然洛谷第一篇用离散时间鞅的做法也很巧妙）。这里也考虑这种思路。考虑当前正停留在任意一个没有结束的状态 $Y$ ，接下来发生了一个特殊事件 $V_k$ ，也就是接下来随机出的长度为 $m$ 的序列恰好就是 $A_k$ 。**注意这时可能已经终止，仍然无条件继续生成序列，但是正如上面所说，胜利以后状态不转移，也不继续累计到达次数。** 正如《歌唱王国》的处理思路，事件 $V_k$ 发生次数的期望有两种计算方法，第一种（这是显然的）：

$$
E(Tot(V_k)) = \left(\sum\limits_{Y}E\left(Y\right)\right)\cdot 2^{-m}
$$

第二种则是考虑，根据 $V_k$ 的定义，设有人胜利的时间是随机变量 $T$ ，则 $V_k$ 发生的条件下，有 $T\in [|Y|+1, |Y|+m]$ ，胜利者一定已经产生（不一定是 $k$ ），所以考虑枚举$T$的取值为 $|Y|+t$ 和获胜的人 $p$ ，然后让胜利以后继续生成出剩下的状态，于是得到：

$$
E(Tot(V_k)) = \sum\limits_{p=1}^{n}\sum\limits_{t=1}^{m}[Pre_t(A_k) = Suf_t(A_p)]2^{-(m-t)}f(p)
$$

结合第一个式子，我们就能得到一个 $n$ 个方程。其中唯一不知道的量就是 $\left(\sum\limits_{Y}E\left(Y\right)\right)$ ，直接设它为一个未知量，再结合游戏必定终止，得到 $\sum\limits_{k=1}^n f_k = 1$ ，总共 $n+1$ 个方程和未知量，高斯消元即可。

## 代码
```cpp
// Author: kyEEcccccc

#include <bits/stdc++.h>

using namespace std;

using LL = long long;
using ULL = unsigned long long;

int t0 = clock();

const int N = 305, PP = 131;

int n, m;
ULL hsh[N][N], rhsh[N][N], kp[N];
double pw2[N], mat[N][N];

int main(void)
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(nullptr);

	pw2[0] = 1; kp[0] = 1;
	for (int i = 1; i <= 300; ++i)
		pw2[i] = pw2[i-1] / 2, kp[i] = kp[i-1] * PP;

	cin >> n >> m;
	for (int i = 0; i < n; ++i)
	{
		string s;
		cin >> s;
		for (int j = 1; j <= m; ++j)
			hsh[i][j] = hsh[i][j-1] * PP + (s[j-1] == 'H' ? 3 : 5);
		for (int j = m; j >= 1; --j)
			rhsh[i][j] = rhsh[i][j+1] + kp[m-j] * (s[j-1] == 'H' ? 3 : 5);
	}

	for (int i = 0; i <= n; ++i)
		for (int j = 0; j <= n+1; ++j)
			mat[i][j] = 0;
	for (int i = 0; i < n; ++i)
		mat[n][i] = 1;
	mat[n][n+1] = 1;
	for (int i = 0; i < n; ++i)
	{
		for (int j = 0; j < n; ++j)
			for (int k = 1; k <= m; ++k)
				if (hsh[i][k] == rhsh[j][m-k+1])
					mat[i][j] += pw2[m-k];
		mat[i][n] += -pw2[m];
	}

	// for (int i = 0; i < n; ++i)
	// 	for (int j = 0; j <= n+1; ++j)
	// 		cout << mat[i][j] << " \n"[j==n+1];

	for (int i = 0; i <= n; ++i)
	{
		double t = mat[i][i];
		for (int j = 0; j <= n+1; ++j)
			mat[i][j] /= t;
		for (int j = 0; j <= n; ++j)
		{
			if (j == i) continue;
			double d = mat[j][i];
			for (int k = 0; k <= n+1; ++k)
				mat[j][k] -= mat[i][k] * d;
		}
	}

	// for (int i = 0; i <= n; ++i)
	// 	for (int j = 0; j <= n+1; ++j)
	// 		cout << mat[i][j] << " \n"[j==n+1];

	for (int i = 0; i < n; ++i)
		cout << fixed << setprecision(10) << mat[i][n+1] << '\n';

	// cerr << double(clock() - t0) / CLOCKS_PER_SEC << '\n';
	return 0;
}
```

---

## 作者：不存在之人 (赞：0)

这种东西是概率dp，看个数据范围似乎还要扯上和概率经常玩耍的高斯消元 

这个题目的关键是设一个变量P(N)表示所有没有到达终止点的概率

假如说A同学猜的是TTH，B同学猜的是HTT，设P(A)表示A取胜的概率，P(B)同理

那么如果是N没有达到终止点，加上一个TTH就结束了，因为A赢了，但是在A赢的路上B可能已经赢了，比如说N如果已经有了H或者HT，那么赢的就是B了，那么我们可以列出：

$$P(N+TTH)=P(A)+P(B+TT)+P(B+T)$$

化简一下就是：

$$0.125P(N)=P(A)+0.25P(B)+0.5P(B)=P(A)+0.75P(B)$$

这个东西可以用来构造系数，我们发现有前缀和后缀有相同的两个字符串可以有系数关系

怎么构造系数呢？kmp/AC自动机都OK的，KMP好写一些

有了系数就可以高斯消元了，针对n个人n种系数方程再加上所有可能相加为1，一共n+1个未知数，n+1个方程
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int N=350;
char w[N*2],st[N][N];
int len,t[N*2];
double a[N][N],b[N],ans[N],mi[N];
void kmp()
{
    t[0]=-1;
    for (int i=0;i<len;i++)
    {
        int j=t[i];
        while (j!=-1&&w[i]!=w[j]) j=t[j];
        t[i+1]=j+1;
    }
}
void gauss(int n)
{
    n++;
    for (int i=1;i<=n;i++)
    {
        int k=i;
        for (int j=i+1;j<=n;j++)
          	if (a[j][i]>a[k][i]) k=j;
        for (int j=i;j<=n;j++) swap(a[i][j],a[k][j]);
        swap(b[i],b[k]);
        for (int j=i+1;j<=n;j++)
        {
            double t=a[j][i]/a[i][i];
            for (int k=i;k<=n;k++) a[j][k]-=t*a[i][k];
            b[j]-=t*b[i];
        }
    }
    for (int i=n;i>=1;i--)
    {
        ans[i]=b[i]/a[i][i];
        for (int j=1;j<i;j++) b[j]-=ans[i]*a[j][i];
    }
}
int main()
{
    int n,m;
	scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) scanf("%s",st[i]+1);
    mi[0]=1.0;for (int i=1;i<=m;i++) mi[i]=mi[i-1]*0.5;
    for (int i=1;i<=n;i++)
    {
        a[i][n+1]=-mi[m];
        int lj=0;
        for (int k=1;k<=m;k++) w[lj++]=st[i][k];w[lj++]='&';
        for (int j=1;j<=n;j++)
        {
            len=lj;
            for (int k=1;k<=m;k++) w[len++]=st[j][k];
            kmp();
            int now=t[len];
            while (now>0)
            {
                a[i][j]+=mi[m-now];
                now=t[now];
            }
        }
    }
    for (int i=1;i<=n;i++) a[n+1][i]=1.0;b[n+1]=1.0;
    gauss(n);
    for (int i=1;i<=n;i++) printf("%.10lf\n",ans[i]);
    return 0;
}
```

---


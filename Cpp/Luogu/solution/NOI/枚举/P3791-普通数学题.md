# 普通数学题

## 题目背景

一天 zzq 没有题可以出了。于是他随便写了一个式子，求$\sum_{i=0}^n \sum_{j=0}^m i \operatorname{xor}j\operatorname{xor}x$，其中 $\operatorname{xor}$ 表示异或。

zzy 一看，这不是水题吗，就随便加了一个函数：$\sum_{i=0}^n \sum_{j=0}^m d(i \operatorname{xor}j\operatorname{xor}x)$，其中 $\operatorname{xor}$ 表示异或，$d(x)$ 表示 $x$ 的约数个数。**注意 $d(0)=0$。**

现在 zzq 不会做了，只好写了一个暴力造了数据，然后把这道题丢给了你。


## 题目描述

输入三个数 $n,m,x$，要求计算 $\sum_{i=0}^n \sum_{j=0}^m d(i \operatorname{xor}j\operatorname{xor}x)$，其中 $\operatorname{xor}$ 表示二进制下的异或，$d(x)$ 表示 $x$ 的约数个数。

由于答案比较大，要求输出答案模 $ 998244353$ 后的结果。


## 说明/提示

对于 $20\%$ 的数据，$n,m,x \leq 2000$。

对于 $50\%$ 的数据，$n,m,x \leq 10^6$。

对于 $80\%$ 的数据，$n,m,x \leq 10^8$。

对于 $100\%$ 的数据，$1 \leq n,m,x \leq 10^{10}$。


## 样例 #1

### 输入

```
0 2 233```

### 输出

```
14```

## 样例 #2

### 输入

```
123 234 345```

### 输出

```
205761```

# 题解

## 作者：fjzzq2002 (赞：19)

$\leq n,m$不方便，不妨将它改为<。

类似在二进制下数位dp，<a的一个限制，我们可以将它拆解为log个“前若干位为abc，后若干位任意”的限制。

我们对于两维都这样拆解，然后$O(log^2n)$进行枚举。

考虑对于i和j的两个这样的限制如何计算∑d(i xor j xor x)。

首先考虑只有i的限制，∑d(i xor x)如何计算，那么我们可以注意到“后若干位任意”的那些位异或完仍然是“后若干位任意”，只要将前面的若干位进行异或，后面若干位仍然任意。

然后注意到例如所有形如010xxxx的d之和可以简单地用0101111和(0100000-1)的前缀和相减得到，所以我们可以直接计算两个d的前缀和，相减即可。

接下来加入了j和j的限制，那么假设i最后a位是任意的，j最后b位是任意的。

不妨设a>=b，那么我们注意到不管j最后b位是啥，只要是任何一个确定的值，异或完i的“任意”的最后a位，仍然是任意的。所以我们只要像上面一样，假设j最后b位是任意一个数，将前若干位异或之后，最后任意的a位直接用前缀和相减。最后乘上$2^b$即可。

d的前缀和可以简单地$O(\sqrt{n})$计算：$\sum_{i=1}^n d(i)=\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$，那么这样做就是$O(\sqrt{n}log^2n)$的。

如何去掉一个log呢？只要将计算d前缀和的函数记忆化即可。原因自己思考吧。


---

## 作者：zombie462 (赞：7)

由于题目中有万恶的异或操作，所以我们考虑类似于数位 $\text{dp}$ 的二进制操作。

先枚举一个 $a$ 和一个 $b$，表示 $i$ 的最后 $a$ 位任意，$j$ 的最后 $b$ 位任意。

那么在前若干位确定的情况下，末几位全取 $1$ 时的答案 $-$ 末几位全取 $0$ 时的答案减 $1$，就是中间一段的答案。

求解的过程显然是可以用前缀的形式来维护的。

对于 $d$ 数组的前缀和则可以用形如杜教筛的方式搞出来，然后加一个 $\text{map}$ 来记忆化就可以了。

然后就可以愉快地求解了。

更为具体的过程上面的 $\text{T}\color{red}\text{LE}$ （$\text{zzq}$）大佬讲得够详细了，所以这里不多加赘述。

这里主要讲讲代码实现上的问题，具体详见注释：

```cpp
//程序中的a,b代指题目中的i,j，程序中的n,m代指题目中的a,b
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("O2")
#define LL long long
#define p 998244353
#define reg register
unordered_map <LL,LL> mp; //开map搞记忆化
LL n,m,xx;
LL read(){
	LL x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=x*10+ch-'0';ch=getchar();
	}
	return x*f;
}
LL doing(LL n){ //求d[1..n]的前缀，模板一样的存在，应该容易理解
	if (n<0) return 0;
	if (mp.count(n)) return mp[n]; //记忆化部分
	LL ans=0,i=1,pos=0;
	while (i<=n){
		LL pos=n/(n/i);
		ans=(ans+(n/i)*(pos-i+1))%p;
		i=pos+1;
	}
	return mp[n]=ans;
}
LL solve(LL x,LL lenx,LL y,LL leny){ //x,y表示待计算的数，lenx,leny表示x,y的位数；下面的i等价于lenx，j等价于leny
	if (lenx>leny) swap(x,y),swap(lenx,leny); //总是使x,y满足x>=y，这样y的末i位和x的末j位异或起来，依旧是任意的。这样的话，最后的答案就是算出来的前缀和乘以2^i
	LL pre=(x^y^xx)&(~((1LL<<leny)-1));//把开始的值算出来，也就是前面几位确定，后面全为0的那个二进制数
	return ((doing(pre+(1LL<<leny)-1)-doing(pre-1)+p)%p*((1LL<<lenx)%p))%p;//pre+(1LL<<leny)-1这部分是把结束的值算出来，也就是前面几位确定，后面全为1的那个二进制数。它的前缀和减去pre-1的前缀和就是中间的前缀和，乘上2^i就是答案	
	/*
	这样子可能更清楚一些：
	LL r=pre+(1LL<<leny)-1,l=pre;
	LL lans=doing(l-1),rans=doing(r);
	return ((rans-lans+p)%p)*(1<<lenx)%p;
	*/
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	
	n=read()+1,m=read()+1,xx=read();
	LL ans=0;
	for (LL i=0;i<=50;++i){
		if (!(n&(1LL<<i))) continue; //如果n的二进制位数都比不过i了，自然不必做了
		for (LL j=0;j<=50;++j){
			if (!(m&(1LL<<j))) continue; //同理
			ans=(ans+solve(n^(1LL<<i),i,m^(1LL<<j),j))%p; //将n的末i位，m的末j位都反一下，以达到可以前缀处理的目的
		}
	}
	cout<<ans<<endl;
	
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```





---

## 作者：JWRuixi (赞：6)

~~晕，位运算尽然要写 ```1ll << s```。~~

- 题意：

给定 $n$，$m$，$x$，求 $\sum_{i=0}^n \sum_{j=0}^m d(i\bigoplus j\bigoplus x)$。

- 分析

考虑换个枚举顺序，变成对于每个不同的 $c=i\bigoplus j\bigoplus x$，求其出现次数 $cnt$ 再乘上对应的 $d(c)$，总贡献 $cnt \times d(c)$。

因为涉及到位运算，所以考虑拆位，然后发现很想数位 dp，但偏偏 dp 不了。于是我们来拆分一下数位 dp 的具体过程，其中很关键的参量就是 $lim$ 判断是否达上限和 $lead$ 是否为前导零。前导零在这道题中是没地位的，直接扔了，而是否达上线，我们可以发现，是统计 $cnt$ 的关键。

于是我们枚举一个 $i$ 和 $j$，不妨假设 $j \le i$，分别代表 $n$ 和 $m$ 在什么位置打破上限，即接下来的数可以随便选。而我们发现由于进行的是位运算，所以区间 $[1,j-1]$ 显然可以覆盖所以可能的值，共 $2^{j-1}$，$n$ 和 $m$ 的取值共 $4^{j-1}$ 种组合，所以每种值有 $2^{j-1}$ 个。同理区间 $[j,i-1]$ 因为 $m$ 这边定死了，所以每种值只有 $1$ 个，但仍然能覆盖到所有可能的数。

于是我们得出了一种可行的做法：枚举 $i$ 和 $j$，满足 $n_i=1$，$m_i=1$，不妨假设 $j \le i$，可以发现从第 $i$ 位开始全部定死，前面可以选任何数，每种不同的数的 $cnt$ 为 $2^{j-1}$。只需求 $2^j\sum\limits_{i=L}^R d(i)$（$L$、$R$ 具体见代码），显然可以差分然后整除分块，应为本质不同的数量很少所以可以记忆化。

设 $suf_i$ 为后 $i$ 位三个数异或起来的后缀和，那么 $L$ 就是 $suf_i$，$R$ 则是 $suf_i + 2^{i-1}-1$，因为显然区间 $[1,i-1]$ 全取 $1$ 就这么大，注意因为在 $n_i=1$ 且 $m_i=1$，又在此处打破限制，所以实际上计算时 $n_i=0$，$m_i=0$，要从后缀和中去掉。

复杂度 $O(\log^2 n+\sqrt n \log n)$。

- code

```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#define int long long
using namespace std;

namespace IO{
	char ibuf[(1 << 20) + 1], *iS, *iT;
	#if ONLINE_JUDGE
	#define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read () {
		reg char ch = gh();
		reg long long x = 0;
		reg char t = 0;
		while (ch < '0' || ch > '9')   t |= ch == '-', ch = gh();
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
		return t ? -x : x;
	}
	inline void write(long long x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
}

using IO::read;
using IO::write;

const int N = 80, mod = 998244353;
int n, m, ct, A, B, X, a[N], b[N], x[N], mi[N], h[N], ans;
__gnu_pbds::gp_hash_table <int, int> sd;

int D (int x) {
	if (!(~x) || !x) return 0;
	if (sd.find(x) != sd.end()) return sd[x];
	int res = 0;
	for (int l = 1, r; l <= x; l = r + 1) {
		r = x / (x / l);
		res = (res + (r - l + 1) % mod * (x / l) % mod) % mod;
	}
	return sd[x] = res;
}

signed main () {
	A = read() + 1, B = read() + 1, X = read();
	for (; A; A >>= 1) a[++n] = A & 1;
	for (; B; B >>= 1) b[++m] = B & 1;
	for (; X; X >>= 1) x[++ct] = X & 1;
	mi[0] = 1; for (int i = 1; i < N; i++) mi[i] = mi[i - 1] * 2 % mod;
	for (int i = max(max(n, m), ct); i; i--) h[i] = h[i + 1] + ((long long)(a[i] ^ b[i] ^ x[i]) << (i - 1));
	for (int i = 1; i <= n; i++) {
		if (!a[i]) continue;
		for (int j = 1; j <= m; j++) {
			if (!b[j]) continue;
			int s = max(i, j), t = min(i, j), H = h[s] ^ (1ll << (s - 1));
			if (s == t) H ^= (1ll << (s - 1));
			ans = (ans + (D(H + (1ll << (s - 1)) - 1) - D(H - 1) + mod) % mod * mi[t - 1] % mod) % mod;
		}
	}
	write(ans);
}
```

---

## 作者：Vidoliga (赞：3)

~~这题感觉评黑有点~~

反正口胡了一个做法就感觉十分对。

具体思路：

考虑枚举 $i \bigoplus j \bigoplus x$。

那么答案即为 $\sum_{k} d(k) \times cnt_k$。

其中 $cnt_k$ 表示出现异或和为 $k$ 的方案数。

整体统计 $cnt$ 有点困难，考虑分块，对于每个块 $cnt_k$ 相等。

对于 $\sum d(i)$ ，你考虑整除分块可做到 $O(\sqrt{n})$。

然而我们只需要构造这种分块方式即可。

我们观察到数位 $dp$ 时的技巧，对于前面位随便选的情况，后面位一定是固定的。

对于第 $i$ 位，当 $i-1$ 位随便取，$i$ 位固定时，我们定义为第 $i$ 位打破限制。

那么考虑到 $i,j$ 分别打破的限制为 $p_i,p_j$。

前面的位置 $k$ 随便取当且仅当 $\max(i,j)\geq k$，因为这时 $i,j$ 有一个数必定可以随便取。

而什么时候方案数会增加呢？我们设 $x_i$ 表示 $x$ 的第 $i$ 位二进制。

考虑到两个数都可以随便取时，那么对于 $k \leq \min(i,j)$，必定是有：

$\begin{cases}0\bigoplus 0\bigoplus x_k=x_k\\0\bigoplus 1\bigoplus x_k=!x_k\\1\bigoplus 0\bigoplus x_k=!x_k\\ 1\bigoplus 1\bigoplus x_k=x_k\end{cases}$

所以此时对答案贡献为 $\times 2$。

可以发现对于固定的 $p_i,p_j$，必定有 $L,R$ 为定值，且 $\forall a,b \in [L,R] \ a \not = b,cnt_a=cnt_b$。

而 $L,R,cnt$ 的计算过程则如下：

发现 $[\max(p_i,p_j),+\infty)$ 的二进制位是固定的，$[\max(p_i,p_j)-1,\min(p_i,p_j)]$ 的二进制位可以取任意数，方案唯一，$(\min(p_i,p_j)-1,0]$ 的二进制位可以取任意数，方案数则每位可由两种不同的 $i,j$ 得出。故 $cnt=2^{\min(p_i,p_j)}$。$L$ 则是在固定的位数后面填 $0$，$R$ 则是在固定的位数后面填 $1$。

于是你得到了一个 $O(\sqrt{n}\log ^2 n)$ 的做法。

但是这东西过不去，于是考虑优化。

对于 $\forall p_i$，可以发现 $\forall p_j > p_j$ 时，$L,R$ 是固定的，$\forall p_j < p_j$ 时，$L,R$ 是固定的，$\forall p_j = p_j$ 时，$L,R$ 有 $1$ 种。

所以本质不同的 $L,R$ 为 $O(\log n)$ 个。

所以你上了个记忆化就过了。

复杂度 $O(\sqrt{n} \log n+\log ^2n \log \log n)$。

~~代码就不放了。~~

---

## 作者：Starrykiller (赞：2)

约定：本文中所有字母均指代非负整数，区间默认与 $\mathbb{Z}$ 取交。

---

异或和 $\sigma_0$ 显然不兼容，硬算显然是行不通的。

联想到二维的树状数组，我们有良好的性质：

> **性质。**
> 记 $\operatorname{lowbit}(n)$ 表示正整数 $n$ 的最低一位二进制代表的数。
> 
> 取正整数 $r,d$，命 $l=r-\operatorname{lowbit}(r)$，$u=d-\operatorname{lowbit}(d)$。不失一般性地设 $\operatorname{lowbit}(r)\le \operatorname{lowbit}(d)$。
> 
> 则有以下结论：
> - $S(r,d)=\{i \operatorname{xor} j : (i,j) \in [l,r)\times [u,d) \}$ 填满了一段区间（也就是存在 $[s,t)$，使得 $S(r,d)=[s,t)$）。
> - $S(r,d)$ 中每个元素实际上出现了 $\operatorname{lowbit}(r)$ 次。
> - $s$ 实际上就是将 $(l \operatorname{xor} u)$ 的最低 $\log_2 \operatorname{lowbit}(d)$ 位抹掉（意思是全设为 $0$）得到的。$t=s+\operatorname{lowbit}(d)$。

> **证明。**
> $\operatorname{xor}$ 是可逆的线性变换。
>
> 考虑将 $[u,d)$ 划分为 $\operatorname{lowbit}(u)/\operatorname{lowbit}(r)$ 段连续段，每段长度为 $\operatorname{lowbit}(r)$。任取一段 $[a,b)$，任取元素 $x\in [l,r)$，则显然 $\{x \operatorname{xor} y: y\in [a,b)\}=[a,b)$。由此即证明了前两条。
> 
> 根据前两条结论，第三条是显然的。

再异或上 $x$ 的结论仿照证明易得。

如此，我们不难将 $[0,n)\times [0,m)$ 划分成 $\mathcal{O}(\log n\log m)$ 个区间，每个区间内我们只需要计算 $\sigma_0$ 的前缀和。

全题最难的地方来了：怎么算 $\sigma_0$ 的前缀和？？这东西杜教筛和 PN 筛都筛不了，只能上 min_25 了吗/jk

非也。注意到 $\displaystyle \sum_{1\le i\le n} \sigma_0(i)=\sum_{1\le i\le n}\sum_{d\mid i} 1=\sum_{1\le d\le n}\lfloor n/d\rfloor$，**这是不难 $\Theta(n^{0.5})$ 计算的。**（事实上，存在 $\mathcal{O}(n^{1/3}\log n)$ 计算的方法，但是我不会（）

命 $m=\Theta(n)$，直接做是 $\Theta(n^{0.5}\log^2 n)$ 的。加上记忆化就是 $\Theta(n^{0.5}\log n)$ 的（根据上面的证明易证），可以通过。

[代码](https://www.luogu.com.cn/paste/zmowzsi9)。

---

## 作者：xujindong_ (赞：1)

假设只有一个求和，对于 $i\in[0,n)$，我们可以把 $i\operatorname{xor}x$ 分为 $\operatorname{popcount(i)}$ 个区间：枚举 $i,x$ 的 LCP，在 $x$ 的某个为 $1$ 的位上钦定 $i$ 为 $0$，更低的位自由。则异或 $x$ 后更低的位仍然自由选，这一位及以上固定。

类似地，钦定 $i$ 的第 $a$ 位和 $j$ 的第 $b$ 位，不妨设 $a\geq b$，则 $a$ 位及以上固定，$a-1\sim b$ 位 $i$ 可以自由选，$b$ 位以下 $i,j$ 都自由选。异或 $x$ 后，$a+1$ 位以下都自由选，每个数会被算 $2^b$ 次。注意到这个区间只和 $\max(a,b)$ 和 $[a\ne b]$ 有关，因此最后只有 $O(\log n)$ 次区间求和。枚举 $\max(a,b)$，假设 $a>b$，则每个 $b$ 产生 $2^b$ 次，这个区间被算的次数就是 $m$ 低于 $a$ 位的部分，$a<b$ 同理，$a=b$ 单独算。

约数个数前缀和是经典问题，容易 $O(\sqrt n)$ 整除分块。更好的做法是启动 DIVCNT1，有 $O(\sqrt[3]n\log n)$ 做法。总复杂度 $O(\sqrt[3]n\log^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int ans,top;
long long n,m,x;
struct vec{
  long long x,y;
}st[1005];
int f(long long n,long long ans=0){
  long long bn=sqrt(n),bn1=cbrt(n),x=n/bn,y=bn+1;
  top=0,st[++top]=(vec){1,0},st[++top]=(vec){1,1};
  while(1){
    vec l=st[top],r=st[--top];
    while((x+l.x)*(y-l.y)>n)ans+=x*l.y+(l.x-1)*(l.y+1)/2,x+=l.x,y-=l.y;
    if(y<=bn1)break;
    while((x+r.x)*(y-r.y)<=n)l=r,r=st[--top];
    while(1){
      vec mid=(vec){l.x+r.x,l.y+r.y};
      if((x+mid.x)*(y-mid.y)>n)r=mid,st[++top]=r;
      else{
        if(n*r.x<=(x+mid.x)*(x+mid.x)*r.y)break;
        l=mid;
      }
    }
  }
  for(int i=1;i<y;i++)ans+=n/i;
  return (2*ans-bn*bn)%mod;
}
int main(){
  cin>>n>>m>>x,n++,m++;
  for(int i=max(__lg(n),__lg(m));i>=0;i--){
    if(n>>i&1||m>>i&1)ans=(ans+((n>>i&1)*(m&((1ll<<i)-1))+(m>>i&1)*(n&((1ll<<i)-1)))%mod*(f((n^m^x^1ll<<i)|((1ll<<i)-1))-f(((n^m^x^1ll<<i)|((1ll<<i)-1))-(1ll<<i))+mod))%mod;
    if(n>>i&1&&m>>i&1)ans=(ans+(1ll<<i)%mod*(f((n^m^x)|((1ll<<i)-1))-f(((n^m^x)|((1ll<<i)-1))-(1ll<<i))+mod))%mod;
  }
  return cout<<ans<<'\n',0;
}
```

---

## 作者：封禁用户 (赞：1)

## 题目
[link](https://www.luogu.com.cn/problem/P3791)


## 分析
可以想到将 $d$ 函数的前缀和转化一下：

$S_d(i)=\sum_{i=1}^n d(i)=\sum_{i=1}^n \left\lfloor\frac{n}{i}\right\rfloor $
那么就可以求出 $O(\sqrt{n})$ 求出每一个前缀和了（整除分块），加上一个 unordered_map 去除不必要的计算。

将问题修改一下： $i \leq n, j \leq m \longrightarrow i < n + 1, j < m + 1$

接下来解决 $\mathrm{xor}$ 的问题，首先可以发现，我们可以转化一下问题，求出每一个 $d(i)$ 的贡献。可以（比较难）想到使用数位 dp 的思想，设定前面几位是相同的，然后固定某一位比原数小，然后后面的所有位随便放。

这里设定 $len_a, len_b, a, b$，其中 $a$ 的后 $len_a$ 是随便放的，强制令 $a$ 是第 $0$ 到 $len_a-1$ 都是 $0$ , 第 $len_a$ 位比 $n$ 小（只能是 $0$ 了），然后 $len_a$（含）之后的位都和 $n$ 相同, $len_b, b$ 同理。

设 $mx=\max\{len_a, len_b\}, mn=\min\{len_a, len_b\}$，一个数 $num$ 的二进制第 $p$ 位是 $num_p$。

那么可以发现，对于 $mx$(含）之后的位，都是可以确定的（废话），使用题目的公式计算出来就好了，我们设计算出的结果是 $pre$。那么公式可以是：

$pre=a \land b \land x \land \lnot2^{mx}$

 但是对于第 $1$ 到 $mx-1$ 的位，可以不管题目提供的 $x$，因为任何一种可能都能够配出来。设一种可能为 $val$，考虑第 $p$ 位，若 $p>mn$，那么只有一种可能，就是在 $len$ 的那个数(现在假设为 $len_a$ 较大)中配一个                           $ v~\mathrm{xor}~x_p~\mathrm{xor}~b_p$。    假设 $p\leq mn$，那么就有两种可能 $ v~\mathrm{xor}~x_p=a_p~\mathrm{xor}~b_p$。
 那么对于任何一种可能，都有 $2^{mn}$ 种 $a,b$ 的配合情况。所有的可能就是 $[pre,pre+2^{mx}-1]$ 中的整数了。那么一组 $len_a, len_b, a, b$ 的答案就是：
 
 $ ans(len_a, len_b, a, b)=\left(S_d\left(pre+2^{mx}-1\right)-S_d(pre-1)\right)\times 2^{mn}$
 
那么最终答案就是所有合法的 $len_a, len_b, a,b$ 答案之和了。
 
 
##  Code
```cpp
#include <bits/stdc++.h>
#define LL long long

using namespace std;

const LL MOD = 998244353;
unordered_map<LL, LL> mp;

LL n, m, vl;

LL calc_sd(LL n) {
	if (n < 0) return 0;
	if (mp.count(n)) return mp[n];
	LL ans = 0;
	for (LL l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		ans = (ans + (r - l + 1) * (n / l) % MOD) % MOD;
	}
	return mp[n] = ans;
}

LL calc_ans(LL x, LL y, LL lx, LL ly) {
	if (lx > ly) swap(x, y), swap(lx, ly);
	LL pre = (x ^ y ^ vl) & (~((1ll << ly) - 1));
	LL val1 = calc_sd(pre + (1ll << ly) - 1), val2 = calc_sd(pre - 1);
	return (val1 - val2 + MOD) % MOD * (1ll << lx) % MOD;
}
int main() {
	scanf("%lld%lld%lld", &n, &m, &vl), n++, m++;
	LL ans = 0;
	for (int i = 0; i <= 50; i++) if (n & (1ll << i)) 
		for (int j = 0; j <= 50; j++) if (m & (1ll << j)) 
			ans = (ans + calc_ans(n ^ (1ll << i), m ^ (1ll << j), i, j)) % MOD;
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：ACtheQ (赞：1)

## 前言

在课上 [@grass8cow](https://www.luogu.com.cn/user/223624) 老师表演了 5min 切黑，可惜失败，被卡常了，好在卡了15min 后过去了 %%%

## 正文

#### 简要题意

给定 $n,m,x$ 求 $\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{m} d(i \oplus j \oplus x)$

$d(i)$ 表示为 $i$ 的约数个数。

$1 \le n,m,x \le 10^{10}$

#### 解法

首先你会发现异或这个运算非常恶心，对于直接求约数十分困难。

不如考虑拆贡献！

对于每一个可能是出现的 $i \oplus j \oplus x$，我们将它设为 $p$，设它的出现次数为 $K_p$ 设所有可能出现的 $p$ 的集合为 $P$。

那么问题的答案就变为 $\sum _{p\in P} d(p) \times K_p$。

对于枚举异或运算可能会出现的数，我们很容易想到数位dp

我们因为 $x$ 是固定的，我们先不考虑它，然后将 $i \oplus j$ 拆成 $i$ 和 $j$，再考虑朴素的从上往下 dp。

分别设后面 $i$ 和 $j$ 的后 $x-1$ 与 $y-1$ 位顶着上限，而第 $x$ 与 $y$ 位小于上限，则剩下的位置都可以随便填！

为了讨论方便，我们不妨定义一下 $x$ 和 $y$ 的位置关系，$x \le y$。

对于前 $x-1$ 时，后面的部分，两个数都能随便取，有 $2^{x-1} \times 2^{x-1} = 4^{x-1}$ 种情况，对于异或完之后这部分所有的 $2^{x-1}$ 情况都能取到，所以每种数出现过 $\frac{4^{x-1}}{2^{x-1}}=2^{x-1}$ 次。

当在 $x \sim y-1 $ 时 $i$ 是固定的，而 $j$ 随便取，有 $1^{x-1} \times 2^{x-1} = 2^{x-1}$ 种情况，显然对于异或完还是能取到所有的 $2^{x-1}$ 情况，所以每种数出现过 $\frac{2^{x-1}}{2^{x-1}}=1$ 次。

对于后面的只有一种情况，且仅出现 $1$ 次。

最后还有个小尾巴，求 $d$！

求 $d$ 其实是幼儿园数学题，非常好求。

$$\sum\limits_{i=1}^n d(i)=\sum\limits_{i=1}^n \sum\limits_{j=1}^n (j\mid i)=\sum\limits_{i=1}^n \lfloor\frac{n}{i}\rfloor$$

这个显然可以数论分块！

总复杂度 $O(\sqrt{n} \log^2 n)$

注意常数！小心不要像牛吃草老师被卡常！

---


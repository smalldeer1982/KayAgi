# 采集矿石

## 题目背景

**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。

题目来源：[Zhang\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~


## 题目描述

**ZRQ** 发现这里有 $N$ 块排成一排的矿石。

他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。

**ZRQ** 想采集一段连续的矿石回研究所。

他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**

**这里多个出现在不同位置的本质相同串的字典序排名相同。**

比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。

**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？

**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**

比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。

我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。

那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。

串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。

串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。

其他串则不满足这个条件，故有三个串可以被采集。


## 说明/提示

共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。

![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)

对于所有测试点，有 $N\leq 10^5$，$0 \le V_i \le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。


**样例#1解释**放在题面里了。

**样例#2解释：**

每个子串都不满足条件。

串 `a` 的排名是 $4$，重要度和都是 $1$。

串 `aa` 的排名是 $3$，重要度和都是 $2$。

串 `aaa` 的排名是 $2$，重要度和都是 $3$。

串 `aaaa` 的排名是 $1$，重要度和都是 $4$。

**样例 #3解释：**

串 `a` 的排名是 $3$，重要度和都是 $1$。

串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。

串 `aaa` 的排名是 $1$，重要度和都是 $3$。

**样例 #4解释：**

可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。


## 样例 #1

### 输入

```
abcd
10 0 1 1```

### 输出

```
3
1 1
3 4
4 4```

## 样例 #2

### 输入

```
aaaa
1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
aaa
1 1 1```

### 输出

```
2
1 2
2 3```

## 样例 #4

### 输入

```
aaa
1 1 2```

### 输出

```
1
1 2```

# 题解

## 作者：Zhang_RQ (赞：11)

1. **一句话题意:给定一个字符串和其每个位置相应的权值，求满足以下条件的子串个数:**


1. 子串所对应的权值和等于其在所有字串中的排名(从大到小)


(也就是第K大的子串权值和为K)


2. 注意:相同的子串排名时算一个，但统计答案是分开算。


2. **30pts做法**


~~(暴力模拟)~~


3. **正解**


首先看到是字符串的题，又没有匹配问题，那么肯定就和后缀有关了。~~(因为我只会这么多)~~


考虑后缀数组。

    
我们考虑如何用后缀数组求一个串的本质不同的子串个数。

    
一个串的本质不同的子串个数应为

    
$ \sum_{i=1}^{n} n-sa[i]-height[i]+1 $

    
观察题目中的条件，可以发现若固定一个起始点，那么从它的开始的后缀的排名时单调下降的，而因为权值为非负的，所以子串的权值和是单调不降的，大概如下图所示。

    
接下来，我们就可以二分这个交点，如果有交点，那么 $ ans++ $ ，并记录当前方案，否则枚举下一个端点。

    
并且如果按照Rank的顺序来枚举，可以发现一个后缀之前的子串个数是可以用前缀和进行优化的。

    
经过 ~~严谨的~~ 推导，可以得出一个子串 $ (lpos,r) $ 的排名为 $ sum[n]-(sum[Rank[lpos]-1]+pos-lpos-height[Rank[lpos]]) $ 。

    
**注意：这个式子仅适用于该子串不是与当前串的前一个排名的串的LCP的子串时成立。**

    
即该式当且仅当 $ pos-lpos+1>height[Rank[lpos]] $ 时成立。

    
接下来考虑如何处理 $ LCP $ 部分。

    
第一个思路：

    
开一个临时数组，记一下前面 $ LCP $ 部分的 $ Rank $ 然后在枚举时每次看一下当前临时数组的大小的 $ Height[i+1] $ 的大小，来判断是否需要更新临时数组。如果 $ size<height[i+1] $ 那么暴力更新临时数组，直至 $ size=height[i+1] $。

    
可以发现，这种暴力处理的复杂度有可能被卡成 $ O(n^2) $。

    
**这个思路的得分为76分**

    
第二个思路：

    
依照第一的思路，可以发现你要更新的这一段其实是一段连续下降的序列，且公差是 $ 1 $。

    
可以使用线段树，该线段树支持区间赋值和区间加等差数列。

    
也可以在线段树上维护这个位置所在 **增加** 的 $ LCP $ 的第一个位置，然后只在临时数组中记一下每次增加的第一位置的 $ Rank $ ，之后可以通过位置计算出当前位置的 $ Rank $ 。

    
现在已经处理完了 $ LCP $ 部分的 $ Rank $ 了。我们发现，其实 $ LCP $ 部分的 $ Rank $ 也是单调下降的，这样我们可以在处理非 $ LCP $ 部分时一起二分。

    
总复杂度 : $ O(nlogn) $

    
至此，该问题已被完全解决。

    
STD:
    
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<bitset>
#include<ctime>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define get_val(l,r) sumv[r]-sumv[l-1]
const int MAXN=100010;
struct O{
    int l,r;
    bool operator < (O a)
    {
        return l<a.l;
    }
}ot[MAXN];
int t[MAXN<<2];
inline void pushup(int x)
{
    t[x]=t[x<<1]*(t[x<<1]==t[x<<1|1]);
}
inline void pushdown(int x,int l,int r)
{
    if(!t[x])
        return;
    t[x<<1]=t[x<<1|1]=t[x];
}
inline void change(int x,int l,int r,int ql,int qr,int val)
{
    if(ql>r||qr<l)
        return;
    if(ql<=l&&r<=qr){
        t[x]=val+1;
        return;
    }
    pushdown(x,l,r);
    int mid=(l+r)>>1;
    if(ql<=mid)
        change(x<<1,l,mid,ql,qr,val);
    if(qr>=mid+1)
        change(x<<1|1,mid+1,r,ql,qr,val);
    pushup(x);
}
inline int query(int x,int l,int r,int pos)
{
    if(t[x])
        return t[x]-1;
    pushdown(x,l,r);
    int mid=(l+r)>>1;
    if(pos<=mid)
        return query(x<<1,l,mid,pos);
    else
        return query(x<<1|1,mid+1,r,pos);
}
char str[MAXN];
int Rank[MAXN],sa[MAXN];
int sum[MAXN],tp[MAXN];
int height[MAXN],h[MAXN];
int val[MAXN],sumv[MAXN];
int tmprank[MAXN],tot;
int n;
ll ans=0;
void get_sa(int n)
{
    int m=127;
    for(int i=1;i<=n;i++) Rank[i]=str[i],tp[i]=i;
    for(int i=0;i<=m;i++) sum[i]=0;
    for(int i=1;i<=n;i++) sum[Rank[tp[i]]]++;
    for(int i=1;i<=m;i++) sum[i]+=sum[i-1];
    for(int i=n;i>=1;i--) sa[sum[Rank[tp[i]]]--]=tp[i];
    int p=1;
    for(int len=1;p<n;len<<=1,m=p)
    {
        p=0;
        for(int i=n-len+1;i<=n;i++) tp[++p]=i;
        for(int i=1;i<=n;i++) if(sa[i]>len) tp[++p]=sa[i]-len;
        for(int i=0;i<=m;i++) sum[i]=0;
        for(int i=1;i<=n;i++) sum[Rank[tp[i]]]++;
        for(int i=1;i<=m;i++) sum[i]+=sum[i-1];
        for(int i=n;i>=1;i--) sa[sum[Rank[tp[i]]]--]=tp[i];
        swap(Rank,tp);Rank[sa[1]]=1;p=1;
        for(int i=2;i<=n;i++)
            Rank[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+len]==tp[sa[i-1]+len])?p:++p;
    }
    int lst=0,j;
    for(int i=1;i<=n;h[i]=lst,height[Rank[i++]]=lst)
        for(lst=lst?lst-1:lst,j=sa[Rank[i]-1];str[j+lst]==str[i+lst];++lst);
}
int get_rank(int lpos,int pos)
{
    if(pos-lpos+1>height[Rank[lpos]]) return sum[n]-(sum[Rank[lpos]-1]+pos-lpos-height[Rank[lpos]]);
    else
    {
        int pre=query(1,1,n,pos-lpos+1);
        return tmprank[pre]+pre-(pos-lpos+1);
    }
}
int tttt;
int main()
{
    scanf("%s",str+1);
    n=strlen(str+1);
    for(int i=1;i<=n;i++)
        scanf("%d",&val[i]),sumv[i]=sumv[i-1]+val[i];
    get_sa(n);
    for(int i=1;i<=n;i++)
        sum[i]=n-sa[i]-height[i]+1+sum[i-1];
    for(int i=1;i<=n;i++) //枚举Rank
    {
        int L=sa[i],R=n,lpos=sa[i];
        while(L<R)
        {
            int mid=(L+R)>>1;
            if(get_val(lpos,mid)<get_rank(lpos,mid))
                L=mid+1;
            else R=mid;
        }

        if(get_val(lpos,L)==get_rank(lpos,L))
            ot[++ans]={lpos,L};
        if(i!=n&&height[i]<height[i+1])
            tmprank[height[i]+1]=get_rank(sa[i],sa[i]+height[i]),
            change(1,1,n,height[i]+1,height[i+1],height[i]+1);
    }
    sort(ot+1,ot+1+ans);
    printf("%lld\n",ans);
    for(int i=1;i<=ans;i++)
        printf("%d %d\n",ot[i].l,ot[i].r);
}
```

---

## 作者：Alex_Wei (赞：5)

> [P4143 采集矿石](https://www.luogu.com.cn/problem/P4143)

字典序排名从大到小使得对于固定的 $l$，随着 $r$ 增大，$[l, r]$ 的排名 **严格递减**，重要度之和 **非严格递增**。因此考虑二分出 $[l, r]$ 的排名与重要度之和的交点，再检查是否符合要求。

考虑如何求某个子串 $[l, r]$ 在所有本质不同子串中的排名。对于子串 $[l', r']$，其字典序 **非严格大于** $[l, r]$ 当且仅当后者是前者的前缀，或者去掉 LCP 后前者的第一个字符大于后者。

满足第一种条件的子串对应后缀 $[l', n]$ 的排名是包含 $[l, n]$ 的一段排名区间 $[L, R]\ (L \leq \mathrm{rank}(l) \leq R)$，满足第二种条件的子串对应后缀的排名是排名后缀 $[R + 1, n]$。

因此，求出排名为 $[L, n]$ 的后缀的本质不同前缀数量，减去 $r - l$（$[l, r]$ 真前缀被多算了）即为所求。前者根据后缀数组经典结论，为 $\left(\sum\limits_{i = L} ^ n n - sa_i +1 \right) - \left(\sum\limits_{i = L + 1} ^ n ht_i\right)$。

求出 $L$ 只需二分找到不大于 $rk_l$ 的最小排名，使得排名为 $L\sim rk_l$ 之间所有后缀的 LCP 不小于 $r - l + 1$。对 $ht$ 预处理 ST 表求 RMQ + 二分即可。

综上，总复杂度 $\mathcal{O}(n\log ^ 2 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int K = 17;
constexpr int N = 1e5 + 5;
int sa[N], rk[N], ork[N], buc[N], id[N];
int lg[N], ht[N], mi[K][N];
bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}
void build(int n, char *s) {
  int m = 1 << 7, p = 0;
  for(int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;
  for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
  for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
  for(int w = 1; ; w <<= 1, m = p, p = 0) {
    for(int i = n - w + 1; i <= n; i++) id[++p] = i;
    for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
    memset(buc, 0, sizeof(buc));
    memcpy(ork, rk, sizeof(rk));
    p = 0;
    for(int i = 1; i <= n; i++) buc[rk[i]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
    for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;
    if(p == n) break;
  }
  for(int i = 1, k = 0; i <= n; i++) {
    if(k) k--;
    while(s[i + k] == s[sa[rk[i] - 1] + k]) k++;
    ht[rk[i]] = mi[0][rk[i]] = k;
  }
  for(int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
  for(int i = 1; i <= lg[n]; i++)
    for(int j = 1; j + (1 << i) - 1 <= n; j++)
      mi[i][j] = min(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);
}
int lcp(int i, int j) { // i, j are ranks
  int d = lg[j - i++];
  return min(mi[d][i], mi[d][j - (1 << d) + 1]);
}
int n, v[N];
char s[N];
long long sh[N], sp[N];
long long calc(int p, int L) {
  int l = 1, r = p = rk[p];
  while(l < r) {
    int m = l + r >> 1;
    if(lcp(m, p) >= L) r = m;
    else l = m + 1;
  }
  return sp[l] - sh[l + 1] - L + 1;
}
bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
#endif
  cin >> s + 1, n = strlen(s + 1);
  build(n, s);
  for(int i = n; i; i--) sh[i] = sh[i + 1] + ht[i], sp[i] = sp[i + 1] + n - sa[i] + 1;
  for(int i = 1; i <= n; i++) cin >> v[i], v[i] += v[i - 1];
  vector<pair<int, int>> ans;
  for(int i = 1; i <= n; i++) {
    int l = 1, r = n - i + 1;
    while(l < r) {
      int m = l + r + 2 >> 1;
      if(calc(i, m) >= v[i + m - 1] - v[i - 1]) l = m;
      else r = m - 1;
    }
    if(calc(i, l) == v[i + l - 1] - v[i - 1]) ans.push_back({i, i + l - 1});
  }
  cout << ans.size() << "\n";
  for(auto it : ans) cout << it.first << " " << it.second << "\n";
  return cerr << "Time: " << clock() << "\n", 0;
}
/*
2022/7/6
start coding at 7:41
finish debugging at 8:07
*/

```

---

## 作者：lhm_ (赞：5)

对于一个固定的左端点，右端点向右移动时，其子串权值和不断增大，字典序降序排名不断减小，因此对于一个左端点，最多存在一个右端点使其满足条件。

所以可以枚举左端点，然后二分右端点的位置，权值和通过前缀和来查询，现在的问题就是如何快速查询一个子串的排名。

考虑用后缀数组来解决，对于一个子串$[l,r]$，对于在位置$l$对应的后缀排名之前的后缀中的子串是能对该子串的排名产生贡献的。

若该子串的长度比$l$对应的后缀和前一个后缀的$LCP$大，即$len>ht_{rk_l}$，也就是该子串没有被$LCP$所包括，则其排名为$sum_l-(n-l+1-len)$，其中$sum_l$表示$l$所对应的后缀之前所有的后缀中本质不同的子串个数，然后再减去右端点$r$右边多算的部分，即为该子串的排名。然后求降序排名时，用本质不同子串个数减去正序排名即可。

若该子串被$LCP$所包括，那么直接像上面那样计算是不对的，则需向前二分到第一个和$l$所对应的后缀的$LCP$恰好等于$len$的位置，然后和上面一样用该位置计算排名。

最终的复杂度为$O(n\ log^2\ n)$

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 400010
#define mk make_pair
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,m,ans,tot;
int v[maxn],b[maxn],rk[maxn],sa[maxn],tp[maxn],ht[maxn];
int lg[maxn],f[maxn][25];
ll sum[maxn];
char s[maxn];
vector<pair<int,int> > ve;
void rsort()
{
    for(int i=0;i<=m;++i) b[i]=0;
    for(int i=1;i<=n;++i) b[rk[i]]++;
    for(int i=1;i<=m;++i) b[i]+=b[i-1];
    for(int i=n;i;--i) sa[b[rk[tp[i]]]--]=tp[i];
}
void SA()
{
    for(int i=1;i<=n;++i) rk[i]=s[i],tp[i]=i;
    rsort();
    for(int k=1;k<=n;k<<=1)
    {
        int num=0;
        for(int i=n-k+1;i<=n;++i) tp[++num]=i;
        for(int i=1;i<=n;++i) 
            if(sa[i]>k)
                tp[++num]=sa[i]-k;
        rsort(),memcpy(tp,rk,sizeof(rk)),rk[sa[1]]=num=1;
        for(int i=2;i<=n;++i)
            rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+k]==tp[sa[i-1]+k])?num:++num;
        if(num==n) break;
        m=num;
    }
    int k=0;
    for(int i=1;i<=n;++i) rk[sa[i]]=i;
    for(int i=1;i<=n;++i)
    {
        if(rk[i]==1) continue;
        if(k) k--;
        int j=sa[rk[i]-1];
        while(s[i+k]==s[j+k]) k++;
        ht[rk[i]]=k;
    }
    tot=n*(n+1)/2;
    for(int i=1;i<=n;++i) tot-=ht[i];
    sum[sa[1]]=n-sa[1]+1;
    for(int i=2;i<=n;++i)
        sum[sa[i]]=sum[sa[i-1]]+n-sa[i]+1-ht[i];
}
void init()
{
    lg[0]=-1;
    for(int i=1;i<=n;++i) lg[i]=lg[i>>1]+1;
    for(int i=1;i<=n;++i) f[i][0]=ht[i];
    for(int j=1;j<=20;++j)
        for(int i=1;i+(1<<j)-1<=n;++i)
            f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
}
int lcp(int l,int r)
{
    if(l>r) swap(l,r);
    l++;
    int len=lg[r-l+1];
    return min(f[l][len],f[r-(1<<len)+1][len]);
}
ll get(int L,int R)
{
    int len=R-L+1;
    if(len>ht[rk[L]]) return tot-(sum[L]-(n-L+1-len))+1;
    else
    {
        int l=1,r=rk[L]-1,p;
        while(l<=r)
        {
            int mid=(l+r)>>1;
            if(lcp(rk[L],mid)>=len) p=mid,r=mid-1;
            else l=mid+1;
        }
        return tot-(sum[sa[p]]-(n-sa[p]+1-len))+1;
    }
    
}
void work()
{
    for(int i=1;i<=n;++i)
    {
        int l=i,r=n;
        while(l<=r)
        {
            int mid=(l+r)>>1;
            ll rank=get(i,mid),val=v[mid]-v[i-1];
            if(rank==val)
            {
                ans++,ve.push_back(mk(i,mid));
                break;
            }
            else if(rank>val) l=mid+1;
            else r=mid-1;
        }
    }
}
int main()
{
    scanf("%s",s+1),n=strlen(s+1),m=150;
    for(int i=1;i<=n;++i) read(v[i]),v[i]+=v[i-1];
    SA(),init(),work();
    printf("%d\n",ans),sort(ve.begin(),ve.end());
    for(int i=0;i<ve.size();++i)
        printf("%d %d\n",ve[i].first,ve[i].second);
    return 0;
}
```

---

## 作者：hzoi_liuchang (赞：2)

## 分析
[前置知识：后缀数组](https://www.cnblogs.com/liuchanglc/p/14190528.html)

要求出所有排名等于重要度的子串并输出方案

首先可以证明这样的子串不会超过 $n$ 个

因为假如我们固定了左端点，那么随着右端点的增大，重要度不会变小，但是排名会变小

因此对于一个确定的左端点，最多只会有一个右端点满足条件

又因为重要度和排名都是单调的，所以只需要固定左端点，二分合法的右端点就可以了

考虑如何快速求出一个子串的重要度和排名

重要度可以用前缀和 $O(1)$ 查询

排名可以用后缀数组求出

在计算一个字符串的本质不同的子串时，我们会用到一个式子

 $\sum_{i=1}^nn-sa[i]+1-height[i]$

 一个很有用的性质就是这样求出的本质不同字串是按顺序的

所以对于一个子串，只需要算出它的前面有多少本质不同的子串即可

先用一个数组记录一下这个式子的前缀和，然后分情况讨论

设 $fir[i]$ 为 $i$ 号后缀的排名

如果 $len \geq height[fir[l]]$，那么排名为 $sum_{fir[l]}-(n-r)$

否则向前二分找到一个位置 $pos$，使得它恰好满足 $len \geq height[pos]$，那么排名为 $(sum_{pos}-(n-sa[pos]-len+1))$

后面减去的那一部分是左端点相同但是长度比当前子串长的

因为排名是按照字典序从大到小来的，所以还要拿总的本质不同的子串减去求出的结果

时间复杂度 $O(nlog^2n)$

## 代码

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}	
const int maxn=1e5+5;
int sa[maxn],fir[maxn],sec[maxn],tax[maxn],n,heig[maxn],lg[maxn],mmin[maxn][20],m;
int a[maxn],sum1[maxn],sta1[maxn],sta2[maxn],tp;
char s[maxn];
long long tot,sum2[maxn];
void Qsort(){
	for(rg int i=0;i<=m;i++) tax[i]=0;
	for(rg int i=1;i<=n;i++) tax[fir[i]]++;
	for(rg int i=1;i<=m;i++) tax[i]+=tax[i-1];
	for(rg int i=n;i>=1;i--) sa[tax[fir[sec[i]]]--]=sec[i];
}
void getsa(){
	m=1e5;
	for(rg int i=1;i<=n;i++) fir[i]=s[i],sec[i]=i;
	Qsort();
	for(rg int len=1,p=0;p<n;len<<=1,m=p){
		p=0;
		for(rg int i=n-len+1;i<=n;i++) sec[++p]=i;
		for(rg int i=1;i<=n;i++) if(sa[i]>len) sec[++p]=sa[i]-len;
		Qsort();
		memcpy(sec,fir,sizeof(sec));
		fir[sa[1]]=p=1;
		for(rg int i=2;i<=n;i++) fir[sa[i]]=(sec[sa[i]]==sec[sa[i-1]] && sec[sa[i]+len]==sec[sa[i-1]+len])?p:++p;
	}
}
void getheight(){
	rg int j,k=0;
	for(rg int i=1;i<=n;i++){
		if(k) k--;
		j=sa[fir[i]-1];
		while(s[i+k]==s[j+k]) k++;
		heig[fir[i]]=k;
	}
	tot=1LL*n*(n+1)/2LL;
	for(rg int i=2;i<=n;i++) tot-=heig[i];
	for(rg int i=1;i<=n;i++) sum2[i]=sum2[i-1]+n-sa[i]+1-heig[i];
}
void pre(){
	for(rg int i=1;i<=n;i++) mmin[i][0]=heig[i];
	for(rg int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(rg int j=1;j<=18;j++){
		for(rg int i=1;i+(1<<j)-1<=n;i++){
			mmin[i][j]=std::min(mmin[i][j-1],mmin[i+(1<<(j-1))][j-1]);
		}
	}
}
int getans(rg int l,rg int r){
	l++;
	rg int k=lg[r-l+1];
	return std::min(mmin[l][k],mmin[r-(1<<k)+1][k]);
}
int getval(rg int l,rg int r){
	return sum1[r]-sum1[l-1];
}
long long getrk(rg int l,rg int r){
	rg int len=r-l+1;
	if(heig[fir[l]]<=len) return tot-(sum2[fir[l]]-(n-r))+1;
	rg int nl=1,nr=fir[l]-1,mids;
	while(nl<=nr){
		mids=(nl+nr)>>1;
		if(getans(mids,fir[l])<=len) nl=mids+1;
		else nr=mids-1;
	}
	return tot-(sum2[nr]-(n-sa[nr]-len+1))+1;
}
void solve(rg int id){
	rg int l=id,r=n,mids;
	while(l<=r){
		mids=(l+r)>>1;
		if(getrk(id,mids)==getval(id,mids)){
			sta1[++tp]=id,sta2[tp]=mids;
			return;
		} else if(getrk(id,mids)>getval(id,mids)){
			l=mids+1;
		} else {
			r=mids-1;
		}
	}
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(rg int i=1;i<=n;i++) a[i]=read();
	getsa(),getheight(),pre();
	for(rg int i=1;i<=n;i++) sum1[i]=sum1[i-1]+a[i];
	for(rg int i=1;i<=n;i++) solve(i);
	printf("%d\n",tp);
	for(rg int i=1;i<=tp;i++) printf("%d %d\n",sta1[i],sta2[i]);
	return 0;
}
```



---

## 作者：yszs (赞：1)

### 来篇非线段树的单 $\log$ 做法。

### 只需后缀数组就可简单实现。

对于每一个后缀单独考虑，设这个后缀的开始位置为 $i$。

用后缀数组表示所有子串就考虑一个后缀的所有前缀，假如当前的前缀终止位置为 $i$。

那么现在的子串是 $s[i \sim j]$。

不难发现，如果再在后面加入一个字符，那么它对应的字典序排名单调下降，权值单调递增，那么这两个函数一定会有一个交点，这个交点就是我们需要的。

那么我们考虑二分这个位置，权值不难用前缀和求出，但是字典序不好搞，然后套路的就是用 $ht$ 数组建出笛卡尔树，或者叫后缀树，然后求出这棵后缀树的 $\text{dfs}$ 序，就求出了字典序。

那么我们在序列上二分就对应着在后缀树对应的终止节点上倍增二分，这样字典序也就求出来了。

要注意好实现细节，因为后缀树是一棵压缩的 $\text{trie}$ 树，所以我们在求出节点后要继续向上二分。

具体可以看代码，写的还是蛮简洁的。

[code](https://www.luogu.com.cn/paste/hl4jh0jm)


---

## 作者：TLE自动机 (赞：1)

既然SA能做，那么SAM能不能做呢？

当然是能的。考虑左端点相同的子串，右端点增大，权值和不减，降序排名单增（前面的串是后面的前缀）。那么2-1仍然单增，二分找到差值$\leq 0$的最后一个，判断是否等于0（相等）即可。

快速找子串排名我用的是反串的SAM的parent树上倍增+预处理出这个节点取到len最大的排名。具体加边方法画个SAM就知道了。总复杂度$n\log^2n$，勉强卡过。

然后后半部分SA能做到$\log n$，SAM就暴力许多（我事无脑选手）。

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define ROF(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
using namespace std;
const int N = 4e5+200;
int read(){
	int x=0,pos=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;
	for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';
	return pos?x:-x; 
} 
char s[N];int n,w[N],pos[N],f[N][20];
ll val[N],vs[N],rk[N];
int las=1,tot=1;
struct typ{
	int ch[26],fa,len,pos;
	typ(){
		memset(ch,0,sizeof(ch));fa=len=0;
	}
}t[N];
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
vector<pii> edge[N];
void insert(int c,int id){
	int p=las,np=las=++tot;pos[id]=np;w[np]=1;t[np].pos=id;
	t[np].len=t[p].len+1;
	for(;p&&!t[p].ch[c];p=t[p].fa) t[p].ch[c]=np;
	if(!p){
		t[np].fa=1;
	}else{
		int q=t[p].ch[c];
		if(t[p].len+1==t[q].len) t[np].fa=q;
		else{
			int nq=++tot;
			t[nq]=t[q];
			t[nq].len=t[p].len+1,t[q].fa=t[np].fa=nq;
			for(;t[p].ch[c]==q;p=t[p].fa) t[p].ch[c]=nq;
		}
	}
}
int ti[N],lnk[N];
ll rn=0;
void dfs1(int now){
	for(int i=0;i<edge[now].size();i++){
		int v=edge[now][i].se;
		dfs1(v),w[now]+=w[v];if(!t[i].pos) t[i].pos=t[v].pos;
	}
}
int cmp(pii a,pii b){
	return a.fi>b.fi;
}
void dfs(int now){
	sort(edge[now].begin(),edge[now].end(),cmp);
	for(int i=0;i<edge[now].size();i++){
		int v=edge[now][i].se;
		dfs(v);
	}
	rk[now]=rn;
	rn+=1ll*(t[now].len-t[t[now].fa].len);//*w[now];
}
ll calcrk(int l,int r){
	int len=r-l+1,x=pos[l];
	ROF(i,19,0){
		if(t[f[x][i]].len>=len) x=f[x][i];
	}
	return 1ll+rk[x]+1ll*(t[x].len-len);//*w[x];
}
ll calcv(int l,int r){
	return vs[r]-vs[l-1];
}
ll calc(int l,int r){
	return calcv(l,r)-calcrk(l,r);
}
vector<pii> ans;
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	FOR(i,1,n){
		val[i]=read();vs[i]=vs[i-1]+val[i];
	}
	ROF(i,n,1){
		insert(s[i]-'a',i);
	}
	FOR(i,2,tot){
		f[i][0]=t[i].fa;
		edge[t[i].fa].push_back({0,i});
	}
	dfs1(1);
	FOR(i,1,tot) edge[i].clear();
	FOR(i,2,tot){
		edge[t[i].fa].push_back({s[t[i].pos+t[t[i].fa].len]-'a',i});
	}
	dfs(1);
	FOR(i,1,19){
		FOR(j,1,tot){
			f[j][i]=f[f[j][i-1]][i-1];
		}
	}
	FOR(i,1,n){
		int l=i,r=n+1;
		while(l<r-1){
			int mid=(l+r)>>1;
			if(calc(i,mid)<=0) l=mid;
			else r=mid;
		}
		if(calc(i,l)==0){
			ans.push_back({i,l}); 
		}
	}
	printf("%d\n",ans.size());
	if(!ans.size()) return 0;
	FOR(i,0,ans.size()-1){
		printf("%d %d\n",ans[i].fi,ans[i].se); 
	}
	return 0;
}
```

---

## 作者：OldDriverTree (赞：0)

# Solution

感觉这道题后缀树上倍增的做法会比较好理解，同时时间复杂度也更优。

这里讲一下后缀树吧，后缀树其实就是字符串中的所有子串组成的 $\text{Trie}$ 上每个后缀对应的节点构成的虚树，所以建后缀树就和建虚树方式差不多，众所周知，建虚树时我们要先对所有节点按 $\text{dfs}$ 序排序，并对相邻节点求 $\text{LCA}$，后缀树上的 $\text{dfs}$ 序大小关系就是对应的字符串的字典序大小关系，$\text{LCA}$ 就为 $\text{lcp}$，所以我们先对这个字符串跑一遍后缀数组，然后按字典序依次加入每个后缀，并用一个单调栈维护当前的后缀树上最右边的链即可，具体实现可以看一下代码。

然后考虑这个题怎么做，注意到当左端点固定，右端点向右移动时，字典序的降序排名单调递增，这段矿石的重要度之和单调不降，所以右端点显然是有单调性的，先在后缀树上 $\text{dfs}$ 一遍求出所有节点的字典序排名，然后枚举左端点，在后缀树上这个后缀对应的节点到根的链上倍增跳即可，注意找到一个深度最小的满足条件的节点后，还要在这个点到这个点的父亲的边上再倍增，因为建出来的实际上是一棵虚树。

# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
const int N=1e5+2,M=2e5+1;
int rnk[M],dis[M],fa[M][18];
int sum[N],sa[N],height[N];
int n,m,tax[N],rk[N],x[N];
char s[N]; int now,stk[M];
vector<int> g[M];
vector<P> ans;

struct custom_hash
{
	static uint64_t splitmix64(uint64_t x) {
		x+=0x9e3779b97f4a7c15;
		x=(x^(x>>30) )*0xbf58476d1ce4e5b9;
		x=(x^(x>>27) )*0x94d049bb133111eb;
		return x^(x>>31);
	}
	size_t operator() (uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x+FIXED_RANDOM);
	}
};
int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
void SA()
{
	for (int i=1;i<=n;i++) tax[rk[i]=s[i] ]++;
	for (int i=2;i<=m;i++) tax[i]+=tax[i-1];
	for (int i=n;i;i--) sa[tax[rk[i] ]--]=i;
	for (int l=1;l<=n;l<<=1)
	{
		int len=0; for (int i=n-l+1;i<=n;i++) x[++len]=i;
		for (int i=1;i<=n;i++) if (sa[i]>l) x[++len]=sa[i]-l;
		for (int i=1;i<=m;i++) tax[i]=0;
		for (int i=1;i<=n;i++) tax[rk[i] ]++;
		for (int i=2;i<=m;i++) tax[i]+=tax[i-1];
		for (int i=n;i;i--) sa[tax[rk[x[i] ] ]--]=x[i];
		swap(rk,x),rk[sa[1] ]=1,m=1; for (int i=2;i<=n;i++)
		if (x[sa[i] ]==x[sa[i-1] ]&&x[sa[i]+l]==x[sa[i-1]+l]) rk[sa[i] ]=m;
		else rk[sa[i] ]=++m; if (m==n) break;
	}
	for (int i=1,k=0;i<=n;i++) {
		if (rk[i]==1) continue; if (k) k--; int j=sa[rk[i]-1];
		while (i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++; height[rk[i] ]=k;
	}
}
void build()
{
	vector<int> pos; //保证子节点间的字典序大小关系
	int cnt=n+1,top=1; stk[1]=n+1; //令根节点为 n+1
	for (int i=1;i<=n;i++) {
		while (dis[stk[top] ]>height[i]) top--;
		if (dis[stk[top] ]==height[i]) fa[i][0]=stk[top],dis[i]=n-sa[i]+1,stk[++top]=i,pos.push_back(i);
		else fa[++cnt][0]=stk[top],dis[cnt]=height[i],fa[stk[top+1] ][0]=cnt,fa[i][0]=cnt,dis[i]=n-sa[i]+1,
		stk[++top]=cnt,stk[++top]=i,pos.push_back(cnt),pos.push_back(i);
	}
	for (int x:pos) g[fa[x][0] ].push_back(x);
}
void dfs(int u) {
	for (int i=1;i<18;i++) fa[u][i]=fa[fa[u][i-1] ][i-1];
	for (int v:g[u]) now+=dis[v]-dis[u],rnk[v]=now,dfs(v);
}
main()
{
	scanf("%s",s+1),n=strlen(s+1);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+read();
	m='z',SA(),build(),dfs(n+1);
	for (int l=1;l<=n;l++) {
		int rt=rk[l]; for (int i=17;~i;i--)
		if (fa[rt][i]&&sum[l+dis[fa[rt][i] ]-1]-sum[l-1]>=now-rnk[fa[rt][i] ]+1)
		rt=fa[rt][i]; int pos=l+dis[rt]-1,nowrk=now-rnk[rt]+1; for (int i=17;~i;i--)
		if (pos-(1<<i)>=l+dis[fa[rt][0] ]&&sum[pos-(1<<i)]-sum[l-1]>=nowrk+(1<<i) )
		pos-=1<<i,nowrk+=1<<i; if (sum[pos]-sum[l-1]==nowrk) ans.push_back({l,pos});
	}
	printf("%d",ans.size() );
	for (auto [l,r]:ans) printf("\n%d %d",l,r);
	return 0;
}
```

---

## 作者：lzyqwq (赞：0)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/p/17872098.html)**

**[题目传送门](https://www.luogu.com.cn/problem/P4143)**

> - 给出字符串 $s$，以及数组 $a_1\sim a_{|s|}$。
>
> - 定义一个子串的排名为：字典序比它大的**本质不同**的子串个数 $+1$。
>
> - 定义一个子串 $s[l,r]$ 的权值为 $\sum\limits_{i=l}^ra_i$。
>
> - 求有多少个子串的排名等于权值。
>
> - $|s|\le 10^5,0\le a_i\le 1000$。

首先对 $s$ 进行后缀排序，然后考虑每一个左端点 $l$，不难发现随着右端点 $r$ 的增大，子串的排名单调递减，权值单调不降。

所以可以二分出满足条件的最小 / 大右端点。

考虑如何求出一个子串 $t$ 的排名。可以用本质不同子串数减去比它小的。

前半部分运用经典结论即为 $\sum\limits_{i=1}^n (|s|-sa_i+1-\text{height}_i)$，我们考虑如何求比它小的本质不同子串数。

可以二分出以这个子串为前缀的后缀排名区间 $[L,R]$。**答案即为排名为 $\boldsymbol{[1,L)}$ 的后缀带来的本质不同子串个数加上排名为 $L$ 的后带来的本质不同字串中她的前缀。**

后面那条是显然的，下证前面的条件。

- 充分性：

  若一个子串 $str$ 在排名为 $[1,L)$ 的后缀中作为前缀出现，那么这个后缀 $s[i,|s|]$ 与 $s[l,|s|]$ 的 $\text{LCP}$ 长度**一定小于 $\boldsymbol{|t|}$**。即两个后缀可以在第 $|t|$ 个位置之前可以找到不相同的位置。而由于 $s[i,|s|]$ 这个后缀排名更小，在这个位置一定 $s[i,|s|]$ 这个后缀小于 $s[l,|s|]$。
  
  考虑 $str$ 是否跨过这个位置，若不是，则在前 $|str|$ 位两串相同，第 $|str|+1$ 位 $str$ 为空，字典序极小。
  
  若跨过，则 $str$ 在这个位置小于 $t$。

- 必要性：

  考虑这两个子串第一次不同是在某个位置，这个位置一定在两个后缀中。
  
正确性证好了。这个东西也是考虑每个后缀带来的本质不同子串。即可以这么求：

$$\sum\limits_{i=1}^{L-1}(|s|-sa_i+1-\text{height}_i)$$

于是做完了。时间复杂度为 $\mathcal{O}(|s|\log^2|s|)$，空间复杂度为 $\mathcal{O}(|s|)$。

**[提交记录](https://www.luogu.com.cn/record/137868836) [代码](https://www.luogu.com.cn/paste/cmnbu8es)**

---


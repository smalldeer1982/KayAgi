# 期望逆序对

## 题目背景

WXH大定理定律n

## 题目描述

mcfx领导的修道院试图通过古老的膜法阵召唤出传说中的膜法处佬WXH。在他把召唤用具准备齐全后，mcfx在众人的键盘声中启动了召唤阵。

这时，天地突然暗了下来，膜法阵中心电闪雷鸣。一道金光从天而降，金色的代码飘在了半空中。不一会，一个登陆界面显现了出来。mcfx仔细观察后发现上面有如下文字：

"WXHCoder是过去到未来所有的题目都有的题库。如果想要登陆它，你们必须解决接下来这道题。"

这道题目是这样子的：给你一个长为$n$的排列，有$k$次操作，每次随机选择两个不同的数交换，问期望逆序对数乘${{n}\choose{2}}^k$的结果。

mcfx发现数据范围是$n,k≤10^{20010910}$，他打算先探究更小的$n,k$。

${n}\choose{2}$表示在$n$个球中选两个的方案数

## 说明/提示

$n≤500000,k≤10^9$

## 样例 #1

### 输入

```
5 4 
1 5 4 3 2```

### 输出

```
50000```

# 题解

## 作者：Yukikaze_ (赞：26)

目前这题的两篇题解一篇过于简略（至少对我这种菜鸡来说），~~一篇有一些错误~~（是我当时太菜了看不懂QAQ），所以在自己摸索出这题的做法后，在这里对第二篇题解做一些补充：

首先，期望数乘以 $\tbinom{n}{2}^k$ 后，变为统计所有方案下的逆序对数量的计数问题。

然后，我们现在有一个排列 $\{x_i\}$ ， 对于初始状态下的 $x_A$ 和 $x_B$ ，我们定义一个数对 $(p,q)$ 表示这两个数最终的位置，由于除了 $A,B$ 之外的任意位置对于 $a_A,a_B$ 都是等价的，所以我们所有其它位置为 $C$，于是我们最后的位置对只有 $7$ 种：$(A,B),(B,A),(C,B),(B,C),(A,C),(C,A),(C,C)$ 。

尝试构造矩阵利用矩阵快速幂求出转移 $k$ 次后出现这些情况的方案数，由于构造较为显然，这里不详细展开，具体矩阵如下（第 $1$ 到 $7$ 行、列分别对应 $(A,B),(B,A),(C,B),(B,C),(A,C),(C,A),(C,C)$ 七个状态）：

$
\left|
\begin{matrix}
	\tbinom{n-2}{2}&1&n-2&0&n-2&0&0\\
	1&\tbinom{n-2}{2}&0&n-2&0&n-2&0\\
	1&0&\tbinom{n-2}{2}+(n-3)&1&0&1&n-3\\
	0&1&1&\tbinom{n-2}{2}+(n-3)&1&0&n-3\\
   1&0&0&1&\tbinom{n-2}{2}+(n-3)&1&n-3\\
   0&1&1&0&1&\tbinom{n-2}{2}+(n-3)&n-3\\
   0&0&1&1&1&1&\tbinom{n-2}{2}+2(n-4)+1
\end{matrix}
\right|
$

做完了矩阵快速幂之后，我们已经知道了这七种位置对所对应的方案数，接下来就是统计答案的~~折磨~~快乐时间：

设以上七种位置对的方案数分别为 $p_0,p_1 \dots p_6$，并令 $a_B,fa_B,ga_B$ 表示初始状态下 $B$ 前面的数中，比 $x_B$ 小的数的个数，比 $x_B$ 小的数（位置用 $pos$ 表示）的 $pos-1$ 的和以及比 $x_B$ 小的数的位置的 $n-pos-1$ 的和。同理处理出大于 $x_B$ 意义下的数 $b_B,fb_B,fb_B$ ，然后我们枚举每一个位置 $B$ ，并考虑与它配对的位置在它前面的贡献和（式子中省略下标 $B$ ）：


结束状态为 $(A,B)$ 的贡献（后面直接省略为状态了QAQ）：$p_0 * b$

解释：对于所有大于 $x_B$ 的数，在该结束状态下都有 $1$ 的贡献。

$(B,A)$ ：$p_1 * a$ 

解释：对于所有小于 $x_B$ 的数，在该结束状态下都有 $1$ 的贡献。

$(C,B)$ ：$p_2*(b\frac{(B-2)}{n-2}+a\frac{(n-B)}{n-2})$ 

解释：该结束状态下，对于大于 $x_B$ 的数，不是 $x_B$ 的那一个数共有 $B-2$ 个位置与 $x_B$ 构成逆序对，而对于所有 $C$ 类位置，落在上面的概率应该是相等的（显然），于是贡献即为 $p_2 * b\frac{(B-2)}{n-2}$ ，同理分析小于 $x_B$ 的数即可。

$(B,C)$ ：$p_3*(a\frac{(B-2)}{n-2}+b\frac{(n-B)}{n-2})$ 

解释：对于所有小于 $x_B$ 的数， $x_B$ 都有 $B-2$ 个位置与它构成逆序对，于是分析与上题类似。

$(A,C)$ ：$p_4*(\frac{gb}{n-2}+\frac{fa}{n-2})$ 

解释：对于一个位置为 $pos~(pos<B,x_{pos}<x_B)$ 的数，如果选择它与 $x_B$ 配对，那么 $x_B$ 共有 $pos-1$ 个位置与它构成逆序对，然后用类似于情况 $3$ 的分析，总贡献为 $\displaystyle(\sum_{x_{pos}<x_B,pos<B}\frac{pos-1}{n-2})=\frac{fa_B}{n-2}$ ，同理分析大于 $x_B$ 的数即可。 

$(C,A)$ ：$p_5*(\frac{fb}{n-2}+\frac{ga}{n-2})$ 

解释：同上。

$(C,C)$ ：该情况最后单独统计即可，答案为 $\frac{p_6*\tbinom{n}{2}}{2}$ 

由于 $a,b,fa,fb,ga,gb$ 可以用树状数组 $O(n\log n)$ 地求出，所以总复杂度是 $O(n\log n)$ 的，但有些卡常，注意 $b,fb,gb$ 可以用 $a,fa,ga$ 推出，然后可以减小一半常数，就能通过本题了。

代码：
```cpp
#include<bits/stdc++.h>
#define lb(x) (x&(-x))
#define M(x) (now.dt[0][x])
using namespace std;
typedef long long ll;
const int mod=1e9+7,N=5e5+10;
ll inv2,n,k,nm[N],dt[2][N];
ll ans;
struct aa
{
	ll dt[10][10];
	aa operator *(const aa &b)const
	{
		aa res; memset(res.dt,0,sizeof(res.dt));
		for(int i=0;i<7;i++)
			for(int j=0;j<7;j++)
				for(int li=0;li<7;li++) res.dt[i][j]=(res.dt[i][j]+dt[i][li]*b.dt[li][j])%mod;
		return res;
	}
}mt,now;
int read()
{
	int res=0,fl=0; char a=getchar();
	while(a<'0'||a>'9') {if(a=='-') fl=1;a=getchar();}
	while(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();
	return fl? -res:res;
}
ll ksm(ll di,ll mi) {ll res=1; for(;mi;mi>>=1,di=di*di%mod) if(mi&1) res=res*di%mod; return res;}
ll c2(ll x) {return x*(x-1)/2%mod;}
void add(ll fl,ll x,ll k) {for(;x<=n;x+=lb(x)) dt[fl][x]=(dt[fl][x]+k)%mod;}
ll query(ll fl,ll x) {ll res=0; for(;x;x-=lb(x)) res=(res+dt[fl][x])%mod; return res;}
int main()
{
	ll i,j,ff=0,gg=0;
	n=read(),k=read(),inv2=ksm(2,mod-2);
	for(i=1;i<=n;i++) nm[i]=read();
	mt=aa{{
	{c2(n-2),1,n-2,0,n-2,0,0},
	{1,c2(n-2),0,n-2,0,n-2,0},
	{1,0,(c2(n-2)+(n-3))%mod,1,0,1,n-3},
	{0,1,1,(c2(n-2)+(n-3))%mod,1,0,n-3},
	{1,0,0,1,(c2(n-2)+(n-3))%mod,1,n-3},
	{0,1,1,0,1,(c2(n-2)+(n-3))%mod,n-3},
	{0,0,1,1,1,1,(c2(n-2)+2*(n-4)+1)%mod}
	}},now.dt[0][0]=1;
	for(;k;k>>=1,mt=mt*mt) if(k&1) now=now*mt;
	for(i=1;i<=n;i++)
	{
		ll a=query(0,nm[i]),b=i-1-a,fa=query(1,nm[i]),fb=(ff-fa+mod)%mod,ga=((n-2)*a-fa)%mod,gb=(gg-ga+mod)%mod;
		ans=(ans+b*M(0)+a*M(1)+((b*(i-2)+a*(n-i))%mod*M(2)%mod+(a*(i-2)+b*(n-i))%mod*M(3)%mod+(gb+fa)*M(4)%mod+(ga+fb)*M(5)%mod)%mod*ksm(n-2,mod-2))%mod;
		add(0,nm[i],1),add(1,nm[i],i-1),ff=(ff+i-1)%mod,gg=(gg+n-i-1)%mod;
	}
	cout<<(ans+c2(n)*inv2%mod*M(6))%mod;
	return 0;
}
```


---

## 作者：ComeIntoPower (赞：14)

这是我在$\texttt{post-icpc.org}$上看到的$\texttt{idea}$,只不过来宣传一下罢了。。。

先想暴力，$O(n^2)$考虑每一对数的贡献，那么对于每一对数，序列实际上被分成了3部分:CCCCACCCBCCC，A,B是这两个数，C是其他数。那么只需要考虑A,B在k次交换后到了哪一部分即可（因为C部分无论在哪都等价）这样一共有7种情况：最后在(A,B)(A,C)(B,A)(B,C)(C,A)(C,B)(C,C)。矩阵快速幂即可（矩阵要推一推）

$O(nlogn)$只需要改成树状数组就行了

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define maxn 1001000
using namespace std;
struct matrix{
    int a[7][7];
    matrix(){memset(a,0,sizeof(a));}
    matrix operator*(const matrix& ma)const{
        matrix ret;
        for(int i=0;i<7;++i)
            for(int j=0;j<7;++j)
                for(int k=0;k<7;++k)
                    ret.a[i][j]=(ret.a[i][j]+1ll*a[i][k]*ma.a[k][j])%mod;
        return ret;
    }
}A,B;
int n,a[maxn],k,ans,tr[10][maxn];
void add(int x,int A,int b,int C,int D,int E,int F,int G){
    B.a[x][0]+=A,B.a[x][1]+=b,B.a[x][2]+=C,B.a[x][3]+=D;
    B.a[x][4]+=E,B.a[x][5]+=F,B.a[x][6]+=G;
}
int qpow(int a,int b){
    int ans=1,tmp=a;
    for(;b;b>>=1,tmp=1ll*tmp*tmp%mod)
        if(b&1)ans=1ll*ans*tmp%mod;
    return ans;
}
void add(int tr[],int x,int a){for(;x<=n;x+=x&-x)tr[x]=(tr[x]+a)%mod;}
int query(int tr[],int x){int ans=0;for(;x;x-=x&-x)ans=(ans+tr[x])%mod;return ans;}
int main(){
//	freopen("in.txt","r",stdin);
    scanf("%d%d",&n,&k);
    for(int i=0;i<7;++i)A.a[i][i]=1;
    for(int i=0;i<7;++i)B.a[i][i]=1ll*(n-2)*(n-3)/2%mod;
    add(0,0,n-2,0,n-2,0,1,0);
    add(1,1,n-3,1,0,n-3,0,1);
    add(2,0,1,n-3,1,n-3,1,0);
    add(3,1,0,1,n-3,n-3,0,1);
    add(4,0,1,1,1,2*(n-4)+1,0,1);
    add(5,1,0,n-2,0,0,0,n-2);
    add(6,0,1,0,1,n-3,1,n-3);
    int inv=qpow(n-2,mod-2),inv2=qpow(2,mod-2);
    for(;k;k>>=1,B=B*B)
        if(k&1)A=A*B;
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]);
//	for(int i=0;i<7;++i)printf("[%d]",A.a[0][i]);puts("");
    long long sum1=0,sum2=0;
    for(int i=1;i<=n;++i){
        int x=query(tr[0],n+1-(a[i]+1)),_x=i-1-x,pans=0;
        ans=(ans+1ll*x*A.a[0][0])%mod;
        ans=(ans+1ll*_x*A.a[0][5])%mod;
        int y=query(tr[1],n+1-(a[i]+1));//p>q:Y+Z
        int z=query(tr[2],n+1-(a[i]+1));//p>q:X
        int _y=sum1-y,_z=sum2-z;
//		printf("[%d,%d,%d]",y,_z,sum2);
        pans=(pans+1ll*(y+_z)*A.a[0][1])%mod;
        pans=(pans+1ll*(_y+z)*A.a[0][2])%mod;
        pans=(pans+1ll*(1ll*(i-2)*x+1ll*(n-i)*_x)%mod*A.a[0][3])%mod;
        pans=(pans+1ll*(1ll*(i-2)*_x+1ll*(n-i)*x)%mod*A.a[0][6])%mod;
        sum1=(sum1+n-i-1)%mod;
        sum2=(sum2+i-1)%mod;
        add(tr[0],n+1-a[i],1);
        add(tr[1],n+1-a[i],n-i-1);
        add(tr[2],n+1-a[i],i-1);
        ans=(ans+1ll*pans*inv)%mod;
    }
    ans=(ans+1ll*n*(n-1)/2%mod*A.a[0][4]%mod*inv2)%mod;
    printf("%d",(ans+mod)%mod);
}
```

---

## 作者：litble (赞：11)

# 题目分析

神仙题。

我们考虑一下一个特定的数对(A,B)，原来在A位置和在B位置的数在k次交换之后，会在哪些位置。可以发现，如果它们没有落在A位置和B位置，落在其他位置的概率是一样的，那么我们把所有其他位置都记做C位置。

初始状态是(A,B)，现在我们要算出结束状态分别是(A,B),(A,C),(B,A),(B,C),(C,A),(C,B),(C,C)的方案数。

考虑矩阵乘法，可以构造转移矩阵表示一次交换操作之后到达某个状态的方案数。

行代表起始状态列表示终止状态，从0号到6号状态分别是(A,B),(A,C),(B,A),(B,C),(C,A),(C,B),(C,C)，转移矩阵应该是：

QAQ我不会在洛谷上写矩阵，所以请移步：[这里](https://blog.csdn.net/litble/article/details/80876793)

好的，现在我们枚举其中的B，假设当前B位置的权值为$x$，然后考虑A的情况。用树状数组维护比$x$小的数的个数$a$，比$x$小的所有数前面的位置数和$fa$，比$x$小的所有数后面（除去B位置以外）的位置数和$ga$。同时算出对应的比$x$大的数的这些相关量$b$，$fb$，$gb$。

设矩阵的$k$次幂的第0行i列为$t(i)$，那么我就知道了统计答案的方法：

$(A,B):b*t(0)$

$(A,C):(a*(n-B)+b*(B-2))*t(1)*\frac{1}{n-2}$

$(B,A):a*t(2)$

$(B,C):(fb+ga)*t(3)*\frac{1}{n-2}$

$(C,A):(a*(B-2)+b*(n-B))*t(4)*\frac{1}{n-2}$

$(C,B):(gb+fa)*t(5)*\frac{1}{n-2}$

枚举完了B后，再统一算$(C,C)$的贡献。

$(C,C):C_{n}^2*\frac{1}{2}*t(6)$

呃，理解就不写了，不然今天就废了......反正解释一下要乘以$\frac{1}{n-2}$的原因，是抵消掉矩阵乘法里已经计算过的选位置的影响。

# 代码

似乎还要额外考虑一下$n$比较小的情况？但是反正过了我就懒得管了=。=

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
int read() {
	int q=0;char ch=' ';
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q;
}
typedef long long LL;
const int mod=1000000007,N=500005;
int n,K,inv,inv2,ans,w[N];LL tr[3][N];
struct matrix{int t[7][7];}re,X;
int qm(int x) {return x>=mod?x-mod:x;}
int ksm(int x,int y) {
	int re=1;
	for(;y;y>>=1,x=1LL*x*x%mod) if(y&1) re=1LL*re*x%mod;
	return re;
}
matrix operator * (matrix a,matrix b) {
	matrix c;
	for(RI i=0;i<7;++i)
		for(RI j=0;j<7;++j) {
			c.t[i][j]=0;
			for(RI k=0;k<7;++k)
				c.t[i][j]=qm(c.t[i][j]+1LL*a.t[i][k]*b.t[k][j]%mod);
		}
	return c;
}

void build() {//矩阵乘法
	for(RI i=0;i<7;++i) re.t[i][i]=1;
	for(RI i=0;i<7;++i) X.t[i][i]=1LL*(n-2)*(n-3)%mod*inv2%mod;
	X.t[0][1]=n-2,X.t[0][2]=1,X.t[0][5]=n-2;
	X.t[1][0]=1,X.t[1][1]=qm(X.t[1][1]+n-3),X.t[1][3]=X.t[1][4]=1,X.t[1][6]=n-3;
	X.t[2][0]=1,X.t[2][3]=X.t[2][4]=n-2;
	X.t[3][1]=X.t[3][2]=1,X.t[3][3]=qm(X.t[3][3]+n-3),X.t[3][5]=1,X.t[3][6]=n-3;
	X.t[4][1]=X.t[4][2]=1,X.t[4][4]=qm(X.t[4][4]+n-3),X.t[4][5]=1,X.t[4][6]=n-3;
	X.t[5][0]=1,X.t[5][3]=X.t[5][4]=1,X.t[5][5]=qm(X.t[5][5]+n-3),X.t[5][6]=n-3;
	X.t[6][1]=X.t[6][3]=X.t[6][4]=X.t[6][5]=1,X.t[6][6]=(X.t[6][6]+n+n-7)%mod;
	for(RI i=K;i;i>>=1,X=X*X) if(i&1) re=re*X;
}

#define lowbit(x) (x&(-x))
void add(int o,int x,LL num) {
	while(x<=n) tr[o][x]=qm(tr[o][x]+num),x+=lowbit(x);
}
LL query(int o,int x) {
	LL re=0;
	while(x) re=qm(re+tr[o][x]),x-=lowbit(x);
	return re;
}
int main()
{
	n=read(),K=read();
	for(RI i=1;i<=n;++i) w[i]=read();
	inv=ksm(n-2,mod-2),inv2=ksm(2,mod-2),build();
	LL sumf=0,sumg=0;
	for(RI i=1;i<=n;++i) {
		LL a=query(0,w[i]),b=i-1-a;
		LL fa=query(1,w[i]),fb=sumf-fa;
		LL ga=query(2,w[i]),gb=sumg-ga;
		ans=qm(ans+1LL*b*re.t[0][0]%mod);
		ans=qm(ans+1LL*(a*(n-i)%mod+b*(i-2)%mod)%mod*re.t[0][1]%mod*inv%mod);
		ans=qm(ans+1LL*a*re.t[0][2]%mod);
		ans=qm(ans+1LL*(fb+ga)%mod*re.t[0][3]%mod*inv%mod);
		ans=qm(ans+1LL*(a*(i-2)%mod+b*(n-i)%mod)%mod*re.t[0][4]%mod*inv%mod);
		ans=qm(ans+1LL*(gb+fa)%mod*re.t[0][5]%mod*inv%mod);
		sumf+=(LL)(i-1),sumg+=(LL)(n-i-1);
		add(0,w[i],1),add(1,w[i],i-1),add(2,w[i],n-i-1);
	}
	ans=qm(ans+1LL*n*(n-1)%mod*inv2%mod*inv2%mod*re.t[0][6]%mod);
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Sol1 (赞：5)

BJ 集训考了这个题，考场上瞎 DP 得到了 $O(n^3k)$ 的优秀算法/cy。

观察到对于两个数 $x_A,x_B$，如果它们原来分别在 $A,B$ 位置，那么其他位置都是等价的。

所以将其他所有位置全定义为 $C$，那么可能的位置对就只有 $7$ 个：$(A,B)$，$(B,A)$，$(A,C)$，$(C,A)$，$(B,C)$，$(C,B)$，$(C,C)$，依次编号为状态 $1-7$。

然后考虑转移：

1. $(A,B)$ 的转移
	1. 没换到这两个数，$f_{1,1}=\binom{n-2}{2}$；
   1. $A$ 和 $B$ 对调，$f_{1,2}=1$；
   1. $B$ 换到一个 $C$，$f_{1,3}=n-2$；
   1. $A$ 换到一个 $C$，$f_{1,6}=n-2$；
1. $(B,A)$ 的转移
	1. $A$ 和 $B$ 对调，$f_{2,1}=1$；
	1. 没换到这两个数，$f_{2,2}=\binom{n-2}{2}$；
   1. $B$ 换到一个 $C$，$f_{2,4}=n-2$；
   1. $A$ 换到一个 $C$，$f_{2,5}=n-2$；
1. $(A,C)$ 的转移
	1. $C$ 换到 $B$ 的位置上，$f_{3,1}=1$；
   1. 没换到这两个数或者 $C$ 换到另外一个 $C$，$f_{3,3}=\binom{n-2}{2}+n-3$；
   1. 对调，$f_{3,4}=1$；
   1. $A$ 换到 $B$ 上，$f_{3,5}=1$；
   1. $A$ 换到 $C$ 上，$f_{3,7}=n-3$；
1. $(C,A)$ 的转移
	1. $C$ 换到 $B$ 的位置上，$f_{4,2}=1$；
   1. 对调，$f_{4,3}=1$；
   1. 没换到这两个数或者 $C$ 换到另外一个 $C$，$f_{4,4}=\binom{n-2}{2}+n-3$；
   1. $A$ 换到 $B$ 上，$f_{4,6}=1$；
   1. $A$ 换到 $C$ 上，$f_{4,7}=n-3$；
1. $(B,C)$ 的转移：
	1. $C$ 换到 $A$ 的位置上，$f_{5,2}=1$；
   1. $B$ 换到 $A$ 上，$f_{5,3}=1$；
   1. 没换到这两个数或者 $C$ 换到另外一个 $C$，$f_{5,5}=\binom{n-2}{2}+n-3$；
   1. 对调，$f_{5,6}=1$；
   1. $B$ 换到 $C$ 上，$f_{5,7}=n-3$；
1. $(C,B)$ 的转移：
	1. $C$ 换到 $A$ 的位置上，$f_{6,1}=1$；
   1. $B$ 换到 $A$ 上，$f_{6,4}=1$；
   1. 对调，$f_{6,5}=1$；
   1. 没换到这两个数或者 $C$ 换到另外一个 $C$，$f_{6,6}=\binom{n-2}{2}+n-3$；
   1. $B$ 换到 $C$ 上，$f_{6,7}=n-3$；
1. $(C,C)$ 的转移：
	1. 第一个 $C$ 换到 $A$，$f_{7,3}=1$；
   1. 第二个 $C$ 换到 $A$，$f_{7,4}=1$；
   1. 第一个 $C$ 换到 $B$，$f_{7,5}=1$；
   1. 第二个 $C$ 换到 $B$，$f_{7,6}=1$；
   1. 没换到这两个数或者其中一个 $C$ 被换到不同于这两个 $C$ 的 $C$ 或者两个 $C$ 对调，$f_{7,7}=\binom{n-2}{2}+2(n-4)+1$。
   
于是根据这个构造出转移矩阵 $T$，初始矩阵为 $A=[1,0,0,0,0,0,0]$，就可以得到转移 $k$ 次的 7 种情况的方案数 $B=A\times T^k$。

接下来考虑统计答案。

对于一对数 $(i,j)$，如果 $a_i<a_j$，考虑它在 $7$ 种方案中的贡献：

1. $(A,B)$，不可能有贡献，系数为 $0$；
2. $(B,A)$，必然有贡献，系数为 $1$；
3. $(A,C)$，$C$ 换到 $i$ 前面才有贡献，系数为 $\dfrac{i-1}{n-2}$；
4. $(C,A)$，$C$ 换到 $i$ 后面才有贡献，同时不能换到 $j$，系数为 $\dfrac{n-i-1}{n-2}$；
5. $(B,C)$，$C$ 换到 $j$ 前面有贡献，同时不能换到 $i$，系数为 $\dfrac{j-2}{n-2}$；
6. $(C,B)$，$C$ 换到 $j$ 后面有贡献，系数为 $\dfrac{n-j}{n-2}$；
7. $(C,C)$，相当于固定两个元素的顺序关系，系数为 $\dfrac{1}{2}$。

$a_i>a_j$ 同理，不再赘述。

这个形式显然可以树状数组维护，于是这题就做完了，时间复杂度 $O(n\log n)$。

注意一个小细节：$\binom{n-2}{2}$ 可能会爆模数，注意取模。~~我们教练考场上因为这个 100→56~~

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const long long mod = 1000000007, inv2 = 500000004;
int n, k, a[500005];
long long c[3][500005];
struct Matrix {
	long long a[10][10];
	int n, m;
	Matrix() {
		memset(a, 0, sizeof(a));
		n = m = 0;
	}
	inline Matrix operator * (const Matrix& b) const {
		Matrix c;
		c.n = n;
		c.m = b.m;
		for (int i = 1;i <= n;i++) {
			for (int j = 1;j <= b.m;j++) {
				for (int k = 1;k <= m;k++) c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j] % mod) % mod;
			}
		}
		return c;
	}
};
Matrix ans, trans;

inline Matrix Unit(int n) {
	Matrix res;
	res.n = res.m = n;
	for (int i = 1;i <= n;i++) res.a[i][i] = 1;
	return res;
}

inline Matrix Power(Matrix x, long long y) {
	Matrix ans = Unit(x.n);
	while (y) {
		if (y & 1) ans = ans * x;
		x = x * x;
		y >>= 1;
	}
	return ans;
}

inline long long Power(long long x, long long y) {
	long long ans = 1;
	while (y) {
		if (y & 1) ans = ans * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ans;
}

inline void Read() {
	n = qread(); k = qread();
	for (int i = 1;i <= n;i++) a[i] = qread();
}

inline void Prefix() {
	trans.n = trans.m = ans.m = 7;
	ans.n = 1;

	long long tmp = 1ll * (n - 2) * (n - 3) / 2 % mod;

	trans.a[1][1] = tmp;
	trans.a[1][3] = n - 2;
	trans.a[1][6] = n - 2;
	trans.a[1][2] = 1;

	trans.a[2][2] = tmp;
	trans.a[2][5] = n - 2;
	trans.a[2][4] = n - 2;
	trans.a[2][1] = 1;

	trans.a[3][1] = 1;
	trans.a[3][3] = (tmp + n - 3) % mod;
	trans.a[3][5] = 1;
	trans.a[3][7] = n - 3;
	trans.a[3][4] = 1;

	trans.a[4][2] = 1;
	trans.a[4][6] = 1;
	trans.a[4][4] = (tmp + n - 3) % mod;
	trans.a[4][7] = n - 3;
	trans.a[4][3] = 1;

	trans.a[5][2] = 1;
	trans.a[5][3] = 1;
	trans.a[5][5] = (tmp + n - 3) % mod;
	trans.a[5][6] = 1;
	trans.a[5][7] = n - 3;

	trans.a[6][1] = 1;
	trans.a[6][4] = 1;
	trans.a[6][5] = 1;
	trans.a[6][6] = (tmp + n - 3) % mod;
	trans.a[6][7] = n - 3;

	trans.a[7][3] = 1;
	trans.a[7][4] = 1;
	trans.a[7][5] = 1;
	trans.a[7][6] = 1;
	trans.a[7][7] = (tmp + n - 4 + n - 4 + 1) %mod;

	ans.a[1][1] = 1;
	ans = ans * Power(trans, k);
	//printf("%lld %lld %lld %lld %lld %lld %lld\n", ans.a[1][1], ans.a[1][2], ans.a[1][3], ans.a[1][4], ans.a[1][5], ans.a[1][6], ans.a[1][7]);
}

inline int Lowbit(int x) {
	return x & -x;
}

inline void Update(int k, int i, int x) {
	for (int j = i;j <= n;j += Lowbit(j)) c[k][j] += x;
}

inline long long Query(int k, int i) {
	long long ans = 0;
	for (int j = i;j >= 1;j -= Lowbit(j)) ans += c[k][j];
	return ans;
}

inline void Solve() {
	long long res = 0, invn = Power(n - 2, mod - 2);
	for (int i = 1;i <= n;i++) {
		long long s1l = Query(0, a[i]), sil = Query(1, a[i]), snil = Query(2, a[i]), s1r = Query(0, n) - s1l, sir = Query(1, n) - sil, snir = Query(2, n) - snil;
		sil %= mod; sir %= mod; snil %= mod; snir %= mod;
		res = (res + s1r * ans.a[1][1]) % mod;
		res = (res + s1l * ans.a[1][2]) % mod;
		res = (res + (s1l * (i - 2) + s1r * (n - i)) % mod * invn % mod * ans.a[1][5]) % mod;
		res = (res + (s1r * (i - 2) + s1l * (n - i)) % mod * invn % mod * ans.a[1][6]) % mod;
		res = (res + (sil + snir) % mod * invn % mod * ans.a[1][3] % mod) % mod;
		res = (res + (snil + sir) % mod * invn % mod * ans.a[1][4] % mod) % mod;
		Update(0, a[i], 1);
		Update(1, a[i], i - 1);
		Update(2, a[i], n - i - 1);
	}
	printf("%lld", (res + inv2 * n % mod * (n - 1) % mod * inv2 % mod * ans.a[1][7] % mod) % mod);
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}
```

---

## 作者：I_am_Accepted (赞：3)

## （一）每两个初始位置最终的位置状态

设原序列为 $a_1,a_2,\dots,a_n$。

只考虑两个数 $a_L,a_R(L<R)$，我们分类讨论最后这两个数跑哪里去了（前者为 $a_L$ 去的地方，后者为 $a_R$ 的，$O$ 为除了 $L,R$ 剩下的位置）：

$$(L,R),(R,L),(O,R),(R,O),(L,O),(O,L),(O,O)$$

这一步 Swap 前各个状态的方案数和这一步后的方案数

$$Bef=\begin{bmatrix}
LR
\\RL
\\OR
\\RO
\\LO
\\OL
\\OO
\end{bmatrix}
,Aft=\begin{bmatrix}
LR'
\\RL'
\\OR'
\\RO'
\\LO'
\\OL'
\\OO'
\end{bmatrix}$$

则

$$M^k\cdot Bef=Aft$$

而且不论 $L,R$ 取啥，转移矩阵 $M$ 始终不变：

$$\begin{aligned}
A&=n-2
\\
B&=n-3
\\
C&=\binom{n-2}{2}
\\
D&=\binom{n-2}{2}+n-3
\\
E&=\binom{n-2}{2}+2(n-4)+1
\end{aligned}$$

$$M=\begin{bmatrix}
C&1&1&0&1&0&0
\\
1&C&0&1&0&1&0
\\
A&0&D&1&0&1&1
\\
0&A&1&D&1&0&1
\\
A&0&0&1&D&1&1
\\
0&A&1&0&1&D&1
\\
0&0&B&B&B&B&E
\end{bmatrix}$$

通过矩阵快速幂 $O(7^3\log k)$ 得出每两个初始位置最终的位置状态。

后面为方便列式子，将 $Aft$ 中第 $i(=0,\dots,6)$ 个元素的值设为 $p_i$。

## （二）每两个初始位置最后是否是逆序对

我们这里设 $a_L<a_R$，反之不再赘述。

按最终状态分类（开头为贡献）：

### LR

$$p_0\cdot 0$$

### RL

$$p_1\cdot 1$$

### OR

$$p_2\cdot\frac{n-R}{n-2}$$

解释：

$a_L$ 要跑到 $R$ 右边才形成逆序对。

因为 $n-2$ 个 $O$ 的位置完全等价（对于 $a_L$ 出现的概率等），所以$a_L$ 要跑到 $R$ 后面的概率为 $\frac{n-R}{n-2}$。

### RO

$$p_3\cdot\frac{R-2}{n-2}$$

解释：

$a_R$ 要跑到 $R$ 左边才形成逆序对。

剩下同理。

### LO

$$p_4\cdot\frac{L-1}{n-2}$$

解释：

$a_R$ 要跑到 $L$ 左边才形成逆序对。

### OL

$$p_5\cdot\frac{n-1-L}{n-2}$$

解释：

$a_L$ 要跑到 $L$ 右边才形成逆序对。

### OO

$$p_6\cdot\frac{1}{2}$$

解释：

相当于在 $O$ 位置之间取两个位置 $x,y(x\ne y)$，$a_x<a_y$ 的概率。

由于不存在 $a_x=a_y$ 的情况（题面说排列），易知 $a_x<a_y$ 的概率为 $\frac{1}{2}$。

* * *

这些柿子又臭又长？把她们写成矩阵的形式吧！

由于上面的贡献均可写成（$c$ 均为常数）

$$p_*(c_0^*+c_1^*L+c_2^*R)$$

的形式，最后 $a_L,a_R$ 之间的贡献可以表示为

$$c_0+c_1L+c_2R$$

所以我们

$$
T\begin{bmatrix}p_0\\p_1\\ \vdots\\ p_6\end{bmatrix}=\begin{bmatrix}c_0\\c_1\\ c_2\end{bmatrix}
$$

其中 $T$ 为 $3$ 行 $7$ 列的常数矩阵（其实已经暗含在上面分类中的贡献里了）。

详见代码 `init()` 和 `solve()` 部分。 

## （三）树状数组统计贡献

~~书接上回~~，我们得到两个位置之间的贡献可表示为常数、两个下标的线性组合。

所以我们通过树状数组求出每个位置前面比她大的个数 和 下标和，然后计算答案即可。

## （四）代码

2KB ~~简短~~代码。

```cpp
//We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i>=i##_;i--)
#define int long long
const int mod=1e9+7,iv2=(mod+1)/2;
inline int pw(int x,int y){int r=1;while(y){if(y&1)r=r*x%mod;x=x*x%mod;y>>=1;}return r;}
#define N 500005
struct ma{
	int a[7][7];
	void init(){For(i,0,6)For(j,0,6)a[i][j]=(i==j);}
	void clear(){For(i,0,6)For(j,0,6)a[i][j]=0;}
	ma mul(ma x){
		ma res;res.clear();
		For(i,0,6)For(j,0,6)For(k,0,6)(res.a[i][j]+=a[i][k]*x.a[k][j])%=mod;
		return res;
	}
}M,R;
int k,p[7];
void kasumi(){
	R.init();
	while(k){
		if(k&1) R=R.mul(M);
		k>>=1; M=M.mul(M);
	}
	For(i,0,6) p[i]=R.a[i][0];
}
int n,a[N],c[N],cnt[N],pos[N],coe[3],m[3][7];
#define low (x&-x)
void add(int x,int y){
	while(x<=n) c[x]+=y,x+=low;
}
int que(int x){
	int res=0;
	while(x) res+=c[x],x-=low;
	return res;
}
int ans=0;
void solve(){
	For(i,0,2){
		coe[i]=0;
		For(j,0,6) (coe[i]+=m[i][j]*p[j])%=mod;
	}
	For(i,1,n) (ans+=cnt[i]*(coe[0]+i*coe[2]%mod)%mod+pos[i]%mod*coe[1]%mod)%=mod;
}
void reve(){
	For(i,1,n) cnt[i]=i-1-cnt[i];
	For(i,1,n) pos[i]=i*(i-1)/2-pos[i];
	For(i,0,6) m[0][i]=(1-m[0][i]+mod)%mod;
	For(j,1,2) For(i,0,6) m[j][i]=(-m[j][i]+mod)%mod;
}
void init(){
	int iv=pw(n-2,mod-2);
	m[0][1]=1,m[0][2]=n*iv%mod,m[0][3]=(mod-2)*iv%mod,m[0][4]=(mod-1)*iv%mod,m[0][5]=(n-1)*iv%mod,m[0][6]=iv2;
	m[1][4]=iv,m[1][5]=(mod-1)*iv%mod;
	m[2][2]=(mod-1)*iv%mod,m[2][3]=iv;
}
int32_t main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>k;
	int A=n-2,B=n-3,C=((n-2)*(n-3)+mod)%mod*iv2%mod,D=(C+n-3+mod)%mod,E=(C+2*n-7+mod)%mod;
	M=(ma){{
	{C,1,1,0,1,0,0},
	{1,C,0,1,0,1,0},
	{A,0,D,1,0,1,1},
	{0,A,1,D,1,0,1},
	{A,0,0,1,D,1,1},
	{0,A,1,0,1,D,1},
	{0,0,B,B,B,B,E},
	}};
	kasumi();
	For(i,1,n) cin>>a[i];
	For(i,1,n) cnt[i]=que(a[i]),add(a[i],1);
	For(i,1,n) c[i]=0;
	For(i,1,n) pos[i]=que(a[i]),add(a[i],i);
	For(i,1,n) c[i]=0;
	init();solve();
	reve();solve();
	cout<<ans<<endl;
return 0;}
```

---

## 作者：SamHJD (赞：2)

# [P4423 期望逆序对](https://www.luogu.com.cn/problem/P4223)

## 简化题意

对一个序列进行 $k$ 次操作，每次操作交换 $a_i,a_j$，求所有操作情况后的序列的逆序对数量之和。

## 解题思路

我们将此题分为两个部分解答：

* 找出一对 $a_i,a_j$ 变化后的情况数和种类。

* 对我们找出的种类和情况求解答案。

### 1.找出一对 $a_i,a_j$ 变化后的情况数和种类

不妨假设一对数 $(A,B)$。数组其余的数均为 $C$。那么进行 $k$ 次操作后原来 $A,B$ 的位置可能有如下几种情况。

$(A,B)\ (B,A)\ (A,C)\ (C,B)\ (C,A)\ (B,C)\ (C,C)$ 

我们将上面 $7$ 中情况编号为 $1\dots 7$。列出一张 $7\times 7$ 的表，第 $i$ 行 $j$ 列表示从第 $i$ 种情况经过一次操作变为第 $j$ 种情况的不同操作数。举 $(A,B)$ 为例：

$(A,B)\to(A,B)$：只要操作选取的两个数不是 $A$ 或 $B$ 即可，一共有 $(n-2)\times(n-3)$ 中情况。

$(A,B)\to(B,A)$：交换 $A,B$，仅有一种情况。

$(A,B)\to(A,C)$：把 $B$ 换成一个 $C$，$C$ 不为 $A,B$，因此有 $n-2$ 中情况。

$(A,B)\to(C,B)$：同上，换走 $A$，一共 $n-2$ 中情况。

$(A,B)\to(C,A)$：显然一次操作不可完成，有 $0$ 中情况。

$(A,B)\to(B,C)$：同上，$0$ 种情况。

$(A,B)\to(C,C)$：同上，$0$ 种情况。

根据我们得出的一张 $7\times 7$ 的表，想要求出交换 $k$ 次的情况数，容易想到矩阵快速幂。第一步解决。

### 2.求解

我们从 $1\dots n$ 枚举 $k$ 次操作后最终 $B$ 的位置，再根据 $A$ 计算贡献，分情况讨论：

$(A,B)$：

对于 $B$ 前的任意一个比 $B$ 大的数，都可以作为 $A$ 和 $B$ 组成一个逆序对。

对答案的贡献便是 $(A,B)$ 的操作情况数乘 $B$ 前比 $B$ 小的数的个数。

$(B,A)$：

和 $(A,B)$ 基本同理，这次要构成逆序对 $A$ 要比 $B$ 小，因此是 $(B,A)$ 的操作情况数乘 $B$ 前比 $B$ 大的数。

$(A,C)$：

若 $A<B$，那么只有 $B$ 被换到 $A$ 前面才能构成一个逆序对。因此答案是所有满足 $A<B,id_A<id_B$ 的 $A$ 的 $id_A-1$ 之和。

若 $A>B$，那么 $B$ 还在 $A$ 前便可构成逆序对。因此答案是所有满足  $A>B,id_A<id_B$ 的 $A$ 的 $n-id_A-1$ 之和（不能 $B$ 换 $B$，所以要减一）。

$(C,B)$：

和 $(A,C)$ 基本同理。

若 $A<B$，那么 $A$ 必须换到 $B$ 后面才能构成逆序对。因此答案是所有满足 $A<B,id_A<id_B$ 的 $A$ 的个数乘 $n-id_B$。

若 $A>B$，那么 $A$ 还在 $B$ 前便可构成逆序对。因此答案是所有满足 $A>B,id_A<id_B$ 的 $A$ 的个数乘 $id_B-2$（不能 $A$ 换 $A$）。

$(B,C)$：

相当于交换了 $(C,B)$ 情况的 $C,B$。只不过是 $id_B$ 发生了变化，答案相同。

$(C,A)$：

相当于交换了 $(A,C)$ 情况的 $A,C$，略有不同：

若 $A<B$ 则 $B$ 需要在 $A$ 的前面才能贡献，答案是 $n-id_A-1$ 的和。

若 $B<A$ 则 $A$ 需要在原来 $A$ 的位置（即 $B$ 换到的位置）后面才能产生贡献，答案为 $n-id_A-1$ 的和。

若 $A<B$ 则 $A$ 需要在原来 $A$ 的位置的前面，答案为 $id_A-1$ 的和。

$(C,C)$：

在循环外求解，从数组中找出不是 $A,B$ 的两个数，交换后有 $50\%$ 的概率贡献逆序对，答案为 $\dfrac{(n-2)\times(n-3)}{2}$。 

---

梳理完所有的情况后，我们便可以思考如何 $O(n^2)$ 一下计算。

我们循环确定了开始 $(A,B)$ 中 $B$ 的位置，对于 $A$，我们在上面梳理的式子需要计算 $B$ 前比 $B$ 大、小的数，这些数的 $n-id_A-1$ 和 $id_A-1$。考虑树状数组。

那么本题就解决了，用 $3$ 个树状数组维护上面 $6$ 个量，按照式子求解即可。

### 3.细节

在除 $(A,B),(B,A),(C,C)$ 的情况下，我们最终的两个数都有一个 $C$ 出现，由于我们要计算矩阵乘法的出来的总操作数有多少可以产生贡献，需要乘的是一个概率。

整个数组中有 $n-2$ 个 $C$，设我们有 $x$ 中情况可以将 $(A,B)$ 转为逆序对，然而一种操作情况相当于只选了一个 $C$ 交换，因此答案需要除以 $n-2$。

在取模运算下不能直接做除法，因此我们将除以 $n-2$ 的操作转为乘以 $n-2$ 模 $10^9+7$ 的逆元，由于 $10^9+7$ 是一个质数，根据费马小定理，直接用 $(n-2)^{10^9+7-2}$ 计算逆元，使用快速幂。

别少取模！否则你会卡在 $80pts$。

### [代码](https://www.luogu.com.cn/paste/867eewix)

---

## 作者：wsy_jim (赞：2)

P4223 期望逆序对

题意：给定一个长度为 $n$ 的排列，进行 $k$ 次操作，每次操作随机从排列里选两个数交换位置，求操作后逆序对个数的期望乘上 $\binom n2^k$，对 $10^9+7$ 取模，数据范围：$n\leq 500000,k\leq 10^9$ 

考虑点对 $(A,B)$ 的贡献，设 $k$ 次操作后，在 $(A,B)$ 位置上的两个数被移动到了 $(p,q)$，发现整个字符串如果只考虑他俩，那就只有三个部分了，$CCCCCACCCCCBCCCCC$，移动后那俩数的位置只有 $(A,B),(B,A),(C,B),(B,C),(A,C),(C,A),(C,C)$ 这七种情况，可以通过矩阵快速幂处理出所有情况的方案数，转移矩阵如第一篇题解

然后是处理答案，枚举原序列上 $B$ 的位置，然后用树状数组来搞 $A$，设 $a$ 为 $B$ 前面比 $B$ 这个位置上数小的数的个数，$fa$ 表示 $B$ 前面比 $B$ 这个位置上数小的数的 $pos-1$ 的和，$ga$ 表示 $B$ 后面比 $B$ 这个位置上数小的 $pos-1$ 的和，然后再搞出来比 $B$ 数大的三个值，就可以处理答案了

操作完位置是 $(A,B)$ 的情况：$B$ 前面比 $B$ 数大的数都可以贡献 $1$ 

操作完位置是 $(B,A)$ 的情况：$B$ 前面比 $B$ 数小的数都可以贡献 $1$ 

操作完位置是 $(C,B)$ 的情况：$B$ 前面比 $B$ 数大的数在 $B-2$ 个位置上可以对答案贡献 $1$，比 $B$ 数小的数在 $n-B$ 个位置上可以对答案贡献 $1$ 

操作完位置是 $(B,C)$ 的情况：确定了 $B$ 之前的一个小于它的数的位置，$B$ 的位置可以有 $B-2$ 种，确定了 $B$ 之前的一个大于它的数的位置，$B$ 的位置可以有 $n-B$ 种

操作完位置是 $(A,C)$ 的情况：若这个 $A$ 是小于 $B$ 的，那么 $B$ 需要在 $A$ 前面才能贡献 $1$，也就是 $pos-1$ 个位置，就是 $B$ 前面小于它的数的 $pos-1$ 的和，若这个 $A$ 是大于 $B$ 的，那么 $B$ 需要在 $A$ 后面才能贡献 $1$，也就是 $n-pos-1$ 个位置，就是 $B$ 前面大于它的数的 $n-pos-1$ 的和

操作完位置是 $(C,A)$ 的情况：若这个 $A$ 是小于 $B$ 的，那么 $A$ 需要在 $B$ 后面才能贡献 $1$，也就是 $n-pos-1$ 个位置，就是 $B$ 前面小于它的数的 $n-pos-1$ 的和，若这个 $A$ 是大于 $B$ 的，那么 $A$ 需要在 $B$ 前面才能贡献 $1$，也就是 $pos-1$ 个位置，就是 $B$ 前面大于它的数的 $pos-1$ 的和

操作完位置是 $(C,C)$ 的情况：这个单独算，从序列里随便挑两个数，它们有 $\frac 12$ 的几率换成逆序对

统计答案即可

码：

```c++
//头文件
const int Mod=1e9+7;

int fpow(int x,int y){
    int res=1%Mod;x%=Mod;
    for(;y;y>>=1,x=x*x%Mod) if(y&1) res=res*x%Mod;
    return res%Mod;
}

int n,k,s[N],ans=0;
int sumf=0,sumg=0;
int inv1,inv2;

struct Matrix{
    int n,m;
    int a[10][10];

    Matrix(int _n=0,int _m=0){
        n=_n,m=_m;
        memset(a,0,sizeof a);
    }
    
    Matrix operator * (const Matrix &x)const{
        Matrix res(n,x.m);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x.m;j++){
                for(int k=1;k<=m;k++){
                    (res.a[i][j]+=a[i][k]*x.a[k][j]%Mod)%=Mod;
                }
            }
        }
        return res;
    }

    void id(){
        for(int i=1;i<=m;i++) a[i][i]=1;
    }

    Matrix fpow(int t){
        Matrix res(n,n);
        res.id();
        Matrix op=*this;
        for(;t;t>>=1,op=op*op) if(t&1) res=res*op;
        return res;
    }
}goal,pro;

int t[N][4];

void add(int x,int y,int id){
    while(x<=n+10){
        (t[x][id]+=y)%=Mod;
        x+=x&(-x);
    }
}

int query(int x,int id){
    int res=0;
    while(x){
        (res+=t[x][id])%=Mod;
        x-=x&(-x);
    }
    return res;
}

void mat_init(){
    pro.n=pro.m=7;goal.n=1,goal.m=7;
    pro.a[1][2]=pro.a[2][1]=pro.a[3][1]=pro.a[3][4]=pro.a[3][6]=pro.a[4][2]=1;
    pro.a[4][3]=pro.a[4][5]=pro.a[5][1]=pro.a[5][4]=pro.a[5][6]=pro.a[6][2]=1;
    pro.a[6][3]=pro.a[6][5]=pro.a[7][3]=pro.a[7][4]=pro.a[7][5]=pro.a[7][6]=1;
    pro.a[1][1]=pro.a[2][2]=((n-2)*(n-3)%Mod*inv2)%Mod;
    pro.a[1][3]=pro.a[1][5]=pro.a[2][4]=pro.a[2][6]=n-2;
    pro.a[3][7]=pro.a[4][7]=pro.a[5][7]=pro.a[6][7]=n-3;
    pro.a[3][3]=pro.a[4][4]=pro.a[5][5]=pro.a[6][6]=((n-2)*(n-3)%Mod*inv2%Mod+n-3+Mod)%Mod;
    pro.a[7][7]=((n-2)*(n-3)%Mod*inv2%Mod+n+n-7)%Mod;
    goal.a[1][1]=1;
}

signed main(){

    read(n),read(k);
    for(int i=1;i<=n;i++) read(s[i]);
    inv1=fpow(n-2,Mod-2),inv2=fpow(2,Mod-2);

    mat_init();

    goal=goal*pro.fpow(k);

    for(int i=1;i<=n;i++){
        int a=query(s[i],1),b=i-a-1;
        int fa=query(s[i],2),fb=sumf-fa;
        int ga=query(s[i],3),gb=sumg-ga;
        (ans+=(goal.a[1][1]*b%Mod))%=Mod;
        (ans+=(goal.a[1][2]*a%Mod))%=Mod;
        (ans+=(goal.a[1][3]*((b*(i-2)%Mod+a*(n-i)%Mod)*inv1%Mod)%Mod))%=Mod;
        (ans+=(goal.a[1][4]*((a*(i-2)%Mod+b*(n-i)%Mod)*inv1%Mod)%Mod))%=Mod;
        (ans+=(goal.a[1][5]*(fa+gb)%Mod*inv1%Mod))%=Mod;
        (ans+=(goal.a[1][6]*(fb+ga)%Mod*inv1%Mod))%=Mod;
        sumf+=(i-1);sumg+=(n-i-1);
        add(s[i],1,1),add(s[i],i-1,2),add(s[i],n-i-1,3);
    }

    (ans+=(goal.a[1][7]%Mod*n%Mod*(n-1)%Mod*inv2%Mod*inv2%Mod))%=Mod;

    printf("%lld\n",ans);

    return 0;
}
```

---

## 作者：zifanwang (赞：0)

大分讨题。

期望 $\times {n\choose 2}^k$，即求每种情况的逆序对数之和。

考虑枚举所有 $i<j$ 计算最终 $a_i>a_j$ 的方案数。记 $A=a_i,B=a_j$，$C$ 表示除了 $a_i,a_j$ 以外的任意一个数，发现最终 $(a_i,a_j)$ 只有 $7$ 种情况：

$(A,B),(A,C),(B,C),(C,A),(C,B),(B,A),(C,C)$。

容易得到一个 $7\times 7$ 的转移矩阵，快速幂求出 $(A,B)$ 转移到每种情况的方案数。接下来枚举 $i<j\land a_i<a_j$ 考虑每种情况的贡献（$a_i>a_j$ 类似）：

- $(A,B)$：无贡献。
- $(A,C)$：$C$ 可取 $[1,a_i-1]$ 中的任意一数，贡献为 $\frac{a_i-1}{n-2}$。
- $(B,C)$：$C$ 可取 $[1,b_j-1]$ 中除了 $a_i$ 的任意一数，贡献为 $\frac{b_j-2}{n-2}$。
- $(C,A)$：同理 $\frac{n-a_i-1}{n-2}$。
- $(C,B)$：同理 $\frac{n-b_j}{n-2}$。
- $(B,A)$：一定为逆序对，贡献为 $1$。
- $(C,C)$：$>$ 和 $<$ 的对数相等，贡献为 $\frac 1 2$。

考虑将 $i$ 和 $j$ 的贡献分开算，发现对于一个指定的 $i$，只需要知道前后 $>a_i$ 和 $<a_i$ 的个数就能求出贡献，树状数组维护即可。

时间复杂度 $\mathcal O(n\log n+\log k)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 500003
#define md 1000000007
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
inline int read(){
	int x=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
struct node{
	ll a[8][8];
	inline void init(){
		memset(a,0,sizeof(a));
		rep(i,1,7)a[i][i]=1;
	}
	inline node operator*(node x){
		node s;
		rep(i,1,7)rep(j,1,7)s.a[i][j]=0;
		rep(i,1,7)rep(k,1,7)if(a[i][k])
			rep(j,1,7)s.a[i][j]=(s.a[i][j]+a[i][k]*x.a[k][j])%md;
		return s;
	}
}s,d,bs;
int n,k,q,a[mxn],c[mxn];
ll ans,n2,ni,cc,f[8];
inline ll pw(ll x,ll y){
	ll s=1;
	for(;y;y>>=1){
		if(y&1)s=s*x%md;
		x=x*x%md;
	}
	return s;
}
inline void power(int k){
	s.init(),bs=d;
	for(;k;k>>=1){
		if(k&1)s=s*bs;
		bs=bs*bs;
	}
}
inline void add(int x,int y){
	for(;x<=n;x+=x&-x)c[x]+=y;
}
inline int ask(int x){
	int s=0;
	for(;x;x-=x&-x)s+=c[x];
	return s;
}
void solve(){
	power(k);
	rep(i,1,n)c[i]=0;
	memset(f,0,sizeof(f));
	f[7]=n*(n-1ll)/2%md*((md+1ll)/2)%md;
	rep(i,1,n){
		ll c1=ask(a[i]),c2=i-1-c1;
		f[2]=(f[2]+(a[i]-1)*(n-a[i]-c2)+(a[i]-2)*(a[i]-1-c1))%md;
		f[3]=(f[3]+(a[i]-2)*c1+(a[i]-1)*c2)%md;
		f[4]=(f[4]+(n-a[i]-1)*(n-a[i]-c2)+(n-a[i])*(a[i]-1-c1))%md;
		f[5]=(f[5]+(n-a[i])*c1+(n-a[i]-1)*c2)%md;
		f[6]=(f[6]+c1)%md;
		add(a[i],1);
	}
	ans=0;
	ans=(ans+(cc-f[6])*s.a[1][1])%md;
	ans=(ans+f[2]*n2%md*s.a[1][2])%md;
	ans=(ans+f[3]*n2%md*s.a[1][3])%md;
	ans=(ans+f[4]*n2%md*s.a[1][4])%md;
	ans=(ans+f[5]*n2%md*s.a[1][5])%md;
	ans=(ans+f[6]*s.a[1][6])%md;
	ans=(ans+f[7]*s.a[1][7])%md;
	cout<<(ans%md+md)%md<<'\n';
}
signed main(){
	n=read(),k=read();
	n2=pw(n-2,md-2),cc=n*(n-1ll)/2%md,ni=pw(cc,md-2);
    rep(i,1,n)a[i]=read();
    d.a[1][1]=(n-2ll)*(n-3)/2%md,d.a[1][2]=n-2,d.a[1][5]=n-2,d.a[1][6]=1;
	d.a[2][1]=1,d.a[2][2]=((n-2ll)*(n-3)/2+n-3)%md,d.a[2][3]=1,d.a[2][4]=1,d.a[2][7]=n-3;
	d.a[3][2]=1,d.a[3][3]=((n-2ll)*(n-3)/2+n-3)%md,d.a[3][5]=1,d.a[3][6]=1,d.a[3][7]=n-3;
	d.a[4][2]=1,d.a[4][4]=((n-2ll)*(n-3)/2+n-3)%md,d.a[4][5]=1,d.a[4][6]=1,d.a[4][7]=n-3;
	d.a[5][1]=1,d.a[5][5]=((n-2ll)*(n-3)/2+n-3)%md,d.a[5][3]=1,d.a[5][4]=1,d.a[5][7]=n-3;
	d.a[6][1]=1,d.a[6][3]=n-2,d.a[6][4]=n-2,d.a[6][6]=(n-2ll)*(n-3)/2%md;
	d.a[7][2]=d.a[7][3]=d.a[7][4]=d.a[7][5]=1,d.a[7][7]=n*(n-1ll)/2%md-4;
    solve();
	return 0;
}
```

---


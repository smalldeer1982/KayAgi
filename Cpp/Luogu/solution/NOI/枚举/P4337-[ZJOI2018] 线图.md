# [ZJOI2018] 线图

## 题目背景

九条可怜是一个热爱出题的女孩子。

## 题目描述

今天可怜想要出一道和图论相关的题。在一张无向图 $G$ 上，我们可以对它进行一些非常有趣的变换，比如说对偶，又或者说取补。这样的操作往往可以赋予一些传统的问题新的活力。例如求补图的连通性、补图的最短路等等，都是非常有趣的问题。

最近可怜知道了一种新的变换：求原图的线图 (line graph)。对于无向图 $G = ⟨V, E⟩$，它的 线图 $L(G)$ 也是一个无向图：
- 它的点集大小为 $|E|$，每个点唯一对应着原图的一条边。 
- 两个点之间有边当且仅当这两个点对应的边在原图上有公共点（注意不会有自环）。 下图是一个简单的例子，左图是原图，右图是它对应的线图。其中点 $1$ 对应原图的边 $(1, 2)$，点 $2$ 对应 $(1, 4)$，点 $3$ 对应 $(1, 3)$，点 $4$ 对应 $(3, 4)$。

![](https://cdn.luogu.com.cn/upload/pic/16013.png )

经过一些初步的摸索，可怜发现线图的性质要比补图复杂很多，其中突出的一点就是补图 的补图会变回原图，而 $L(L(G))$ 在绝大部分情况下不等于 $G$，甚至在大多数情况下它的点数和边数会以很快的速度增长。

因此，可怜想要从最简单的入手，即计算 $L^k(G)$ 的点数（$L^k(G)$ 表示对 $G$ 求 $k$ 次线图）。 然而遗憾的是，即使是这个问题，对可怜来说还是太困难了，因此她进行了一定的弱化。她给出了一棵 $n$ 个节点的树 $T$，现在她想让你计算一下 $L^k(T)$ 的点数。


## 说明/提示

如下图所示，左图为原树，中图为 $L(G)$，右图为 $L^2(G)$。这儿并未画出 $L^3(G)$，但是由于 $L^2(G)$ 有 5 条边，因此 $L^3(G)$ 中有 5 个点。

![](https://cdn.luogu.com.cn/upload/pic/16014.png )

![](https://cdn.luogu.com.cn/upload/pic/16015.png )

## 样例 #1

### 输入

```
5 3 
1 2 
2 3 
2 5
3 4```

### 输出

```
5```

# 题解

## 作者：shadowice1984 (赞：17)

stO jry Orz

这题真的是神仙题,爆肝了160行调了一天半才淦出来，可能是我太菜了吧……

顺便说一句jyy的题解里面的式子就没几个系数是对的所以写篇题解至少把题解里的式子修正了

________________________

# 本题题解

首先我们需要通过观察获得一些性质

我们在线图变化的时候将每个点标上一些号，然后重新考虑一下题目中给出的变换的本质是什么


让我们来手玩一下一个6个点的树的前3阶线图(第4阶时候点就要开始爆炸了实在画不动)


![](https://cdn.luogu.com.cn/upload/pic/44716.png)

![](https://cdn.luogu.com.cn/upload/pic/44718.png)

![](https://s1.ax1x.com/2018/11/28/FVRUsA.png)

![](https://s1.ax1x.com/2018/11/28/FVR0dP.png)

凝视一下这四张图，除了发现点数越来越多以及图越来越乱之外你还发现了什么？

这里为了方便你发现问题的本质每个点的编号并没有重新编号而是使用原图的点对线图中的点进行编号

我们发现到$L3(G)$的时候有3个点的编号全部相同都是$1,4,5,6$为什么呢？

看一眼原图当中$1,4,5,6$这个联通块，手玩下它的三阶线图，你会发现一件事就是这个联通块的3阶线图当中恰好有3个点的标号是$1,4,5,6$

同理$1,2,3,4$这个的联通块的3阶线图只有1个点的标号对应了$1,2,3,4$

同理我们手玩了$1,2,4,5$和$1,2,4,6$之后也能得到相同的结论

这个神奇的标号对应着什么呢？

似乎刚好是原图当中一个大小为$k+1$的联通块

但是这个结论似乎有些不对，考虑一个3元环的无限阶线图还是个3元环，因此我们可以得出一个结论是我们给点的标号对应的点集其实是原图当中一个**大小不超过k+1个点的联通块**

那么我们还能得出一个结论是原图当中一个大小不超过$k+1$的联通块在做k次线图变换之后会对应着线图当中的x个点，x为这个联通块做k次线图变化之后**标号中的数字个数为k+1**的点的数目

那么我们有了一个初步的暴力就是枚举原图中所有联通块然后考虑这些联通块对答案的贡献

似乎k=1,2,3的时候联通块的种类不会特别多？

你看k=1的时候合法点联通块就一种，一条边,这东西对答案贡献是1

k=2的时候合法的连通块就一种，一个两条边构成的链,对答案贡献是1

k=3的时候合法的联通块有两种,一种是3条边构成的链，对答案贡献是1

另一种是形如我们之前手玩的$1,4,5,6$这样的三叉形状，对答案的贡献是3，

还有一种是3元环，对答案的贡献是3

所以根据这个我们可以列出k=1,2,3的时候答案的式子，设有n个点m条边

~~你会发现k=3的时候吉老师题解中的式子是假的~~

$$ans=n-1$$

$$ans=\sum_{i=1}^{n}{d_{i}\choose 2}$$

$$ans=\sum_{i=1}^{m}(d(u_{i})-1)(d(v_{i})-1)+\sum_{i=1}^{n}3{d_{i}\choose 3}$$

好了让我们再来考虑另一个辣手的情况，能不能凭借人类的智慧算出$k=4$时的答案呢？

答案是可行的，我们把$L^{4}(G)$转化成$L^{3}(L(G))$~~(这里吉老师题解里的式子又错了)~~来算

首先我们可以将每个边在$L(G)$中的度数算出来,设这东西是$d1(u,v)$则显然有

$$d1(u,v)=d(u)+d(v)-2$$

~~(这里吉老师题解里的式子双错了)~~

然后我们接下来算出每个点周围一圈边在$L(G)$当中的度数之和，为了方便起见我们令

$$d2(u)=\sum_{v \in alist(u)}d1(u,v)-1$$

(其中alist(u)是u的出边集合)

那么我们接下来考虑k=3时候每一个$(d(u)-1)(d(v)-1)$对答案的贡献我们可以推出来这样一个式子

$$0.5\sum_{i=1}^{n}d2(i)^2-\sum_{i=1}^{m}(d1(u_{i},v_{i})-1)^2+\sum_{i=1}^{m}3{d1(u_{i},v_{i}) \choose 3}$$

之所以前面的平方要乘0.5是因为每个交叉项被算了两边并且每条边自己的平方也在两个点处各被算了一遍，然后后面的式子减去了每个边自己的平方

然后这东西就是$k=4$时候的答案式子了

好了我们现在借助人类智慧手玩完了$k=1,2,3,4$时候的答案了

现在让我们来考虑k=9的鬼畜数据

我们的思想依然不变，考虑每个联通块对答案的贡献

不过显然$2^n$暴力枚举联通块显然t飞了

那么我们发现一个一个相当重要的信息，两个联通块如果图同构，那么这两个联通块对答案的贡献显然相同

那么我们似乎可以枚举所有不同构并且点不超过$k+1$的**有根树**,然后计算**每一种**有根树对答案的贡献，这样似乎看起来可以很快的求出答案

且慢……你怎么枚举所有不同构的有根树啊

## Part1 枚举不同构的有根树

首先我们发现树的点最多10个，因此可以大力dfs所有不同的树的欧拉序(有人也叫括号序列),复杂度显然是卡特兰数级别的，在$n=10$的时候可以轻松的搜出来

当我们dfs出来一个树之后，我们把它树哈希一下,然后判断这个hash值是否已经搜过了，如果已经搜过了我们就不枚举他

~~注意一件事是树hash的函数搞的越乱越好，一开始疯狂撞hash……~~

如果不会树hash的话可以自己yy/看我代码/去你站模板区/自行百度

_______________________

好了我们兴奋的打了个搜索上去，发现一件事情，合法的树出乎意料的少，只有$1205$种(你可以用这个数字检验一下你的dfs有没有写错)

因此似乎枚举每一种树对答案的贡献是可行的

那么我们知道一个联通块对答案的贡献是它做k次线图变换之后对应着自身的点的数目

那么我们怎么对这$1205$种树都求出它对答案的贡献呢？

假设我们想要求树T对答案的贡献，设他是$w(T)$

## Part2 求解w(T)

其实我们思路暴力的很，假设我们所有的树T是按照点数进行枚举的话，我们可以求出这个图的k阶线图中有几个点，然后把这个树中子图的$w$之和算出来然后减掉就能求出$w(T)$了

然后我们发现算所有子图的$w$之和实在是很容易，因为任意一个子图的点数肯定小于$T$的点数，所以这个$w$值你之前算过，我们拿map存每一个hash值对应的w值即可完成任务

因此现在的任务就落在了如何求出T的k阶线图当中的点数

这个东西的思路更加暴力，$L^9(G)=L^4(L^5(G))$

所以直接硬算出5阶线图，然后去套4阶线图的公式

注意一件事最坏情况下5阶线图大概会有几百万条边(我的邻接表直接开了1e7)，但是这样的树非常少，因此总的复杂度可以接受

然后给你求线图的过程当中加点特技实现个$O(m)$求线图，你就能在时限内跑出来了，具体细节可以看我代码里的line_gr::getline()

~~(吉老师std真的是可怕,9阶线图居然只有600多毫)~~

______________

好了千辛万苦我们终于把每种树对答案的贡献求出来了，现在我们只需要dp出每种树在大的树当中出现了多少次就可以算出答案了，假设这个数$T$在大树当中出现了$time(T)$次，那么我们该怎么求解答案呢？

##  part3 求解time(T)

依然是更加暴力的思路，我们采用状压dp来实现这个东西的求解

我们设$dp(i,j)$表示$i$的子树当中匹配小树当中$j$的子树有多少种方案

那么转移似乎需要使用一个状压的辅助数组来帮助我们合并一条父子边$(u,v)$

这样直接大力转移似乎复杂度最满的时候是$O(2^k)$的，可能我们需要卡卡常数卡到$O(2^{0.5k})$

当我们转移$j$的时候先忽略到和$j$相连的所有叶子，然后此时假设我们的点j还剩下$p$个剩下的子树，然后和$j$相连的叶子一共有$lf$个，当前的i有$son$个儿子

那么我们dp之后应该要把答案乘上${son-p \choose lf}lf!$才能保证我们的答案是对的？

## 显然不对，因为你重复计数了

这里不是因为我们多乘了一个lf的阶乘，而是因为另外一个原因

考虑一个长这样的树

![undefined](https://cdn.luogu.com.cn/upload/pic/44723.png)

我们在dp根节点的时候并不会删掉任何的叶子，然而我们发现答案比真实答案大24倍，为什么呢？

因为根节点的所有子树完全同构……但是我们dp的时候强行认为每个子树都不同构，这样的话同一个方案会被重复的计算24次也就是4!次

所以我们在每一次转移之后都要把$dp(i,j)$除上这个式子

$$\prod_{i}cnt_{i}!$$

其中$cnt_{i}$表示子树中第$i$种$hash$值的出现次数，这个东西可以在树hash的时候顺手求出来

这就是为什么我们在丢掉叶子的时候乘上一个阶乘的原因了，因为我们需要把这两个系数抵消掉(不然我们的系数算起来会炒鸡恶心)

~~当然只要你足够聚这题还有很多的去重方式可以用~~

然后我们一通树形dp之后我们就求出了time(T)了

然后我们就做完了这题……

上代码~(这题真的很肝……)


```C
#include<cstdio>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;const int N=5010+10;const int E=1e7+10;const int M=13;typedef long long ll;
typedef unsigned long long ull;ll fac[N];
const ll mod=998244353;const ll bas=467;set <ull> book;int psiz[12];
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
ull tr[15];int hd;ll ch[N][25];ll xs[15];int lb[N];int siz[N];int k;ll ans;int n;
# define ctwo(x) ((((ll)x*(x-1))>>1)%mod)
# define ctre(x) ((ll)x*(x-1)%mod*(x-2)%mod*499122177%mod)
struct tree1
{
	int gr[15];ull nhsh[15];int siz[15];int rot;int vis;
	inline int& operator [](const int& x){return gr[x];}
	inline void ins(int u,int v){gr[u]|=(1<<v);}
	inline void clr(){for(int i=0;i<13;i++)gr[i]=0;}
	inline void pre(int u)//处理hash值 
	{
		siz[u]=1;for(int t=gr[u];t;t-=t&(-t))pre(lb[t]),siz[u]+=siz[lb[t]];
		hd=0;for(int t=gr[u];t;t-=t&(-t))tr[++hd]=nhsh[lb[t]];
		nhsh[u]=0;sort(tr+1,tr+hd+1);xs[u]=1;
		ull mi=1;for(int i=1;i<=hd;i++,mi=mi*bas)nhsh[u]+=mi*tr[i];
		int fac=1;for(int i=1,cnt=0;i<=hd;i++)
			if(tr[i]==tr[i-1])cnt++,fac*=cnt;else xs[u]*=fac,cnt=1,fac=1;
		nhsh[u]=(siz[u]!=1)?7+nhsh[u]*siz[u]:13;
		xs[u]=po(xs[u]*fac,mod-2);
	}
	inline void cst(int u,const int& lim)//求出一个联通块的hash 
	{
		vis|=(1<<u);psiz[u]=1;
		for(int t=gr[u]&lim;t;t-=t&(-t))cst(lb[t],lim),psiz[u]+=psiz[lb[t]];
		hd=0;for(int t=gr[u]&lim;t;t-=t&(-t))tr[++hd]=nhsh[lb[t]];
		nhsh[u]=0;sort(tr+1,tr+hd+1);
		ull mi=1;for(int i=1;i<=hd;i++,mi=mi*bas)nhsh[u]+=(ll)mi*tr[i];
		nhsh[u]=(psiz[u]!=1)?7+nhsh[u]*psiz[u]:13;
	}
	inline int ck(const int& lim)//检查联通性 
	{
		int mx=lb[lim&(-lim)];
		for(int i=0;i<=12;i++)if((lim>>i)&1)mx=siz[mx]<siz[i]?i:mx;
		vis=0;cst(mx,lim);return (vis==lim)?mx:-1;
	}
}ntr,sub;
namespace line_gr
{
	int al[2][E];int x[2][E];int ct[2];int v[2][E];int d1[E];int d2[E];map <ull,int> mp;
	inline void spadd(int u,int V){v[0][++ct[0]]=V,x[0][ct[0]]=al[0][u],al[0][u]=ct[0];}
	inline void get_line(int* v1,int* x1,int* al1,int ct1,
	int* v,int* x,int* al,int& ct)//从一个图迭代到它的线图 
	{
		for(int i=1;i<=ct+1;i++)al[i]=0;ct=0;
		for(int i=2;i<=ct1;i+=2)
		{
			int tu=v1[i];int tv=v1[i-1];int p=i>>1;
			for(int j=al1[tu],q=(j+1)>>1;j;j=x1[j],q=(j+1)>>1)
				if(q<p)v[++ct]=q,x[ct]=al[p],al[p]=ct,v[++ct]=p,x[ct]=al[q],al[q]=ct;
			for(int j=al1[tv],q=(j+1)>>1;j;j=x1[j],q=(j+1)>>1)
				if(q<p)v[++ct]=q,x[ct]=al[p],al[p]=ct,v[++ct]=p,x[ct]=al[q],al[q]=ct;
		}
	}
	inline ll calcline4(int* v,int ct)//求4阶线图 
	{
		ll ret=0;for(int i=1;i<=ct;i++)d1[v[i]]++;
		for(int i=2;i<=ct;i+=2)d2[i>>1]=d1[v[i]]+d1[v[i-1]]-2;
		for(int i=1;i<=(ct>>1);i++)(ret+=ctre(d2[i])*2)%=mod;
		for(int i=1;i<=(ct>>1);i++)d2[i]--;
		for(int i=1;i<=ct+1;i++)d1[i]=0;
		for(int i=1;i<=ct;i++)d1[v[i]]+=d2[(i+1)>>1];
		for(int i=1;i<=ct+1;i++)(ret+=(ll)d1[i]*d1[i])%=mod;
		(ret*=499122177)%=mod;
		for(int i=1;i<=(ct>>1);i++)(ret+=mod-(ll)d2[i]*d2[i]%mod)%=mod;
		for(int i=1;i<=ct+1;i++)d1[i]=0;for(int i=1;i<=ct;i++)d2[i]=0;return ret;
	}
	inline ll subcalc(tree1& ter,int tt)//求一个图的k阶线图 
	{
		for(int i=1;i<=ct[0]+1;i++)al[0][i]=0;ct[0]=0;
		for(int i=0;i<tt;i++)	
			for(int t=ter[i];t;t-=t&(-t))
			{spadd(i+1,lb[t]+1),spadd(lb[t]+1,i+1);}
		for(int i=1,p=1,q=0;i<=k-4;i++,p^=1,q^=1)
			get_line(v[q],x[q],al[q],ct[q],v[p],x[p],al[p],ct[p]);
		return calcline4(v[(k-4)&1],ct[(k-4)&1]);	
	}
	inline ll calcw(tree1& ter)//容斥 
	{
		int tt=ter.siz[ter.rot];ll ret=subcalc(ter,tt);sub=ter;
		for(int i=1;i<(1<<tt)-1;i++)
			{sub.rot=sub.ck(i);if(sub.rot==-1)continue;(ret+=mod-mp[sub.nhsh[sub.rot]])%=mod;}
		return mp[ter.nhsh[0]]=ret;
	}
}
int v[2*N];int x[2*N];int ct;int al[N];ll dp[N][12];ll tdp[N];int d[N];int lf[N];
int st[N];int tp;int eu[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;d[V]++;}
inline void dfs(int u,int f)//树形dp 
{
	int son=0;for(int i=al[u];i;i=x[i])if(v[i]!=f)dfs(v[i],u),son++;
	for(int rt=0;rt<ntr.siz[0];rt++)//去重 
	{
		if(ntr.siz[rt]==1)continue;if(son<siz[sub[rt]]){dp[u][rt]=0;continue;}
		for(int k=sub[rt];k;k=(k-1)&sub[rt])tdp[k]=0;tdp[0]=1;
		for(int i=al[u];i;i=x[i])
		{
			if(v[i]==f)continue;
			for(int k=sub[rt];k;k=(k-1)&sub[rt])
				for(int p=k,lob;p;p-=lob)lob=p&(-p),(tdp[k]+=tdp[k^lob]*dp[v[i]][lb[p]])%=mod;
		}dp[u][rt]=tdp[sub[rt]]*xs[rt]%mod*ch[son-siz[sub[rt]]][lf[rt]]%mod;
	}
}
inline ll calct(const tree1& ter)//计算time 
{
	sub=ter;for(int i=0;i<sub.siz[0];i++)lf[i]=0;
	for(int i=0;i<sub.siz[0];i++)
		for(int p=sub[i];p;p-=p&(-p))
			if(sub.siz[lb[p]]==1)lf[i]++,sub[i]^=p&(-p);
	dfs(1,0);ll ans=0;for(int i=1;i<=n;i++)(ans+=dp[i][0])%=mod;return ans;
}
inline void solve(int hd,int cur,int sum,int tar)//搜出所有不同构的树 
{
	if(sum==0&&cur!=-1)
	{
		if(cur!=tar)return;tp=0;ntr.clr();
		for(int i=1;i<hd;i++)
			if(eu[i]>=0)st[++tp]=eu[i];else if(tp!=1)tp--,ntr.ins(st[tp],st[tp+1]);	
		ntr.rot=0;ntr.pre(0);
		if(book.count(ntr.nhsh[0])==0)
		{book.insert(ntr.nhsh[0]),(ans+=calct(ntr)*line_gr::calcw(ntr))%=mod;}return;
	}if(sum!=0){eu[hd]=-1;solve(hd+1,cur,sum-1,tar);}
	if(cur!=tar){eu[hd]=cur+1;solve(hd+1,cur+1,sum+1,tar);}
}
inline ll calcline2()//二阶线图 
{ll ans=0;for(int i=1;i<=n;i++)(ans+=ctwo(d[i]))%=mod;return ans;}
inline ll calcline3()//三阶线图 
{
	ll ans=0;for(int i=1;i<=n;i++)(ans+=ctre(d[i]))%=mod;
	for(int i=2;i<=ct;i+=2)(ans+=(ll)(d[v[i]]-1)*(d[v[i-1]]-1))%=mod;return ans;
}
int main()
{
	for(int i=0;i<=11;i++)lb[1<<i]=i;
	for(int i=1;i<2048;i++)lb[i]=lb[i&(-i)];
	for(int i=1;i<2048;i++)siz[i]=siz[i>>1]+(i&1);
	for(int i=0;i<=5000;i++)
	{
		ch[i][0]=1;if(i<=20)ch[i][i]=1;
		for(int j=1;j<=min(i-1,20);j++)ch[i][j]=(ch[i-1][j-1]+ch[i-1][j])%mod;
	}fac[0]=1;for(int i=1;i<=20;i++)fac[i]=fac[i-1]*i%mod;
	for(int i=0;i<=5000;i++)for(int j=0;j<=20;j++)(ch[i][j]*=fac[j])%=mod;
	scanf("%d%d",&n,&k);
	for(int i=1,u,V;i<n;i++)scanf("%d%d",&u,&V),add(u,V),add(V,u);
	switch(k)//1,2,3,4大力算然后剩下的搜 
	{
		case 1:{printf("%d",n-1);break;}
		case 2:{printf("%lld",calcline2());break;}
		case 3:{printf("%lld",calcline3());break;}
		case 4:{printf("%lld",line_gr::calcline4(v,ct));break;}
		default:{for(int i=0;i<=k;i++)solve(1,-1,0,i);printf("%lld",ans);break;}
	}return 0;//再见这道毒瘤题…… 
}
```














---

## 作者：zj余能 (赞：17)

这题的数据范围很有趣啊，谁叫标算的复杂度也是指数级的呢？

假如用人类智慧是容易做出前 30 分的，高水平的选手再发现一些性质能拿到 50 分，而显然我并不是，因为我在考场上只有 20 分。

 那我们来看一看线图的高妙之处：

 

**考虑 $L^{k}(G)$ 中的每一个点在 $G$ 中代表的形状。**

 显然，$L(G)$ 的点数对应了原图中的一条边。
 
容易发现，$L^{2}(G)$ 的点数对应了原图中的一条折线（即一对相邻的两条边）。

稍加推敲得到，$L^{3}(G)$ 的点数对应了原图中的一条长度为三的链或一组相互相邻的三条边。

以此类推不难发现，在 $L^{k}(G)$ 中的每一个点对应的是 $G$ 中的一个不超过 $k$ 条边的联通导出子图。由于原图 $G$ 是棵树，所以 $L^{k}(G)$ 中每一个点对应的是 $G$ 中的一颗边数不超过 $k+1$ 的子树。一个简单的结论是：两个结构相同（即同构）的导出子图，它们在 $L^{k}(G)$ 中对应的节点个数一定也是相同的。

 

**于是我们考虑了一个初步的做法：**

枚举所有的边数不超过 $k+1$ 的无根树，假设为 $T_{i}$，算出 $T_{i}$ 在 $L^{k}(G)$ 中对应的点数 $w_{i}$。
算出 $T_{i}$ 在 $G$ 中出现了的次数 $t_{i}$。
$Ans = \sum_{T_{i}}^{} w_{i} * t_{i}$。
 枚举不同构的有根树可以枚举括号序列然后用树哈希来去重，因此主要考虑给定 $T_{i}$，如何 求解 $w_{i}$ 和 $t_{i}$。

 

**求解 $w_{i}$ ：**

因为 $T_{i}$ 的大小很小，我们能够求解 $L^{k}(T_{i})$ 的点数。但是这并不是我们要求的 $w_{i}$，因为这中的每一个点对应了 $T_{i}$ 中的每一个联通子图，也就是说这中间有 $T_{i}$ 的子图的贡献，我们需要减掉它们，我们可以 $O(2^{|T_{i}|})$ 枚举 $T_{i}$ 的子图，减掉它们的贡献，计算出 $w_{i}$ 的值。

容斥的复杂度并不是瓶颈，关键在于现在考虑如何求出 $L^{k}(T_{i})$ 的点数，如果暴力做的话，复杂度大概是 $O(k^{k})$，不太行。

我们可以沿用之前做部分分时的做法：

$L(T_{i})$ 的点数是 $m$。

$L^{2}(T_{i})$ 的点数是 $\sum_{i \in V}^{} C_{d_{i}}^{2}$，其中 $d_{i}$ 为 $i$ 的度数。

$L^{3}(T_{i})$ 的点数是 $\sum_{(u,v) \in E}^{} (d_{u}-1)(d_{v}-1) + \sum_{i \in V}^{} C_{d_{i}}^{3}$

$L^{4}(T_{i})$ 的点数同样也可以用人类智慧直接算出来。

这样我们就只需要算 $L^{k-4}(T_{i})$ 就可以了。

这里有一个可以剪枝的地方，就是曾经算过的无根树与当前有同构时，就不必再算了。

 

**求解 $t_{i}$：**

想要直接把 $T_{i}$ 当无根树计算出它在另一个无根树 $G$ 中出现的次数是很难的，毕竟无根树的计数比有根树更复杂。

我们可以发现，如果我们把两颗无根树都当成有根树来做，即枚举有根树，却也是对的。因为无根树在另一颗无根树上一个成功的匹配，我们把某一棵无根树拉成有根树，另一棵无根树此时呈现出的有根形态一定会被枚举到恰好一次。于是问题得到了简化。

 我们可以用树形dp直接解决它，由于 $T_{i}$ 的大小很小，用状压dp就可以了。

令 $f_{i,j}$ 为 $G$ 上第 $i$ 个点为第 $j$ 种有根树的根的嵌入方案数。

由于 $j$ 的孩子中可能存在两棵同构的子树，由于是没有标号的，故答案只能算一次，这是在dp时要注意的。然而我的实现方法并不优越，我的做法是，暴力合并所有同构的子树，每次dp时枚举之前所有状态中不包含这些同构子树中任意一个的状态。于是我就枚举子集了，复杂度变劣了一点。
然而在dp中有很多可以剪枝的地方，比如很显然，$i$ 的孩子数肯定不会少于 $j$ 的儿子数，或者在 $T_{i}$ 中存在一个子树和 $j$ 的子树同构，那可以不用重复计算了。

最后还有一个优化，就是当 $j$ 的亲生儿子中有叶子节点时，可以不用状压进去，直接用组合数算就可以啦。

 

于是我们就解决的这道题了，我在UOJ上勉强卡过去了，UOJ跑得还挺快的呢！~~反正我本地T飞了~~

---

## 作者：行吟啸九州 (赞：3)

想要知道正解的请去看另外两位大佬的题解。

我只是想说一下如何用人类智慧，步步套娃，来骗到一些部分分。

先说一个事情，这个图一定没有重边与自环。我的个人能力只想到了30-50分的办法，不过作为$ZJOI$，6个题每个题骗50，就进省队了。

算法一：k = 1，n = 5000嘛，你可以暴力把图建出来，然后就可以获得0分的好成绩了。

算法二：k = 2，不难发现一个图的线图的点数就是这个图的边数，利用算法一里的图，输出边数，期望得分10分。

算法三：k = 3，我们想要$L^2(G)$的点数，就是需要知道$L(G)$的边数，不难发现$L(G)$的边数与G每个点的度数有关，点$i$的度数为$d[i]$，对答案的贡献是$C_{d[i]}^2$，期望得分20分。聪明的你一定要预处理逆元的，要不然常数不优秀的话就会收到$TLE$好礼。

算法四：k = 4，我想要$L(G)$的点的度数，不难发现，这与$G$的共点边数有关。对于每个边，它变成的点的度数就是与它相邻的边（与它有公共点的边）的数量，期望得分30分。共点边是我自己口胡定义的，不过我相信聪明的你一定可以理解的。

算法五: k = 5，这个是重头戏，值20分呢。我想要$L(G)$的共点边数，不难发现这可以枚举G的两条邻边进行统计，不过复杂度是糟糕的O($n ^ 4$)，就算是你的复杂度是O(松)的，都过不去。

然后这个时候你需要一些信仰，还需要一些卡常能力，你要相信图上的边和点会很少，O($n ^ 2logn$)是能过的，因为没有写过，我也不确定能不能过，如果有人写完，请告诉我一声，非常感谢。

不过我们不难发现，对于同一个点，共点边数量的相同的边，是等价的。而一对相邻的公共点为x的边的贡献是$g[i] + g[j] - 2$, $g[x]$含义是x的共点边数，不难发现这个答案是可以$NTT$的, $g[x] <= n$，所以复杂度O($n ^ 2logn$)的。相信信仰的力量，奥利给一下就完事了。

最后没有代码，因为懒得敲了，要是在考场上就敲了。

---

## 作者：Larunatrecy (赞：1)

很久之前就觉得是很有意思的题，但是一直没有写。

感觉这个题从题目到解法都非常自然，做起来也很舒服。

首先，我们不难发现：

- $L(G)$ 的每个点都对应了原图的一条边

- $L^2(G)$ 的每个点都对应了原图两条有公共点的边

……

以此类推，我们不难做出合理的猜测，$L^k(G)$ 中的每一个点都对应了原图的一个边数不超过 $k$ 的连通导出子图，之所以说是 **不超过**，是因为会有三元环这样子的特殊情况存在。我们可以通过打表验证结论的正确性。


由于原图是一棵树，所以 $L^k(G)$ 对应的就是一个点数不超过 $k+1$ 的连通子树。


当然，$L^k(G)$ 中的不同的点可能是由相同的一个子图变成的，并且显然这些点在 $L^k(G)$ 中都是连通的。更进一步的，因为子图和图在连通性上区别不大，我们可以大胆猜测，一棵子树 $T$ 在 $L^k(G)$ 中的出现次数就是 $T$ 在 $L^k(T')$ 中的出现次数，这是很容易理解的。


倘若我们可以求出 $f(T)$ 代表 **树** $T$ 在 $L^k(T)$ 中的出现次数，显然同构的 $T$ 的 $f(T)$ 是相等的，如果我们求出 $T$ 在 $G$ 中的出现次数 $c(T)$，那么 $\sum c(T)f(T)$ 就是答案。

因为无根树处理起来比较麻烦，我们不妨把 $T$ 按照有根树处理，显然这样是加强限制，除了复杂度外不影响别的。

考虑我们先求出 $L^k(T)$ 的点数，然后减掉所有 $T$ 的子树 $T'$ 的 $f(T')$，求出的就是 $f(T)$ 。具体做法和上面是相似的，我们可以求出不同的 $T'$ 在 $T$ 中的出现次数，乘上 $f(T')$ 再集体减去。

因此我们爆搜出来所有不超过 $k+1$ 个点的不同构有根树，具体方法也很简单，就是每次给根新加入一个子树，如果我们保证子树之间有序，譬如按照生成顺序排列，那么就会不重不漏的生成出来，一共最多有 $1209$ 个。

接下来，我们的任务就分为两部分：

- 求出某棵树 $T'$ 在另一棵树 $T$ 中的出现次数，这里的 $T$ 可以是我们搜出来的树，也可以是题目输入的树。

这个问题解决起来也不复杂，设 $dp_{x,i}$ 表示在 $x$ 子树内，有根树 $i$ 的根节点为 $x$ 时的出现次数，换言之就是 $x$ 上 "挂" 了多少个 $i$ 。转移时，枚举 $x$ 的儿子 $y$，$i$ 的子树 $j$，然后把 $j$ 分配给 $y$ 再合并起来就行了，注意 $x$ 可能有相同的 $j$，但是为了不重我们要保证每种 $j$ 只出现一次。

- 求出一个 $T$ 的 $L^k(G)$ 的点数

通过手模我们不难得出 $L(G),L^2(G),L^3(G)$ 的点数表达式，$L^4(G)$ 虽然推导起来比较复杂但还是可以算出来的，这里不多赘述，因为没什么技术含量。

然后，因为 $L^k(G)=L^4(L^{k-4}(G))$，我们模拟求出 $L^{k-4}(G)$ 长什么样子，然后套用公式就行了。

然后就解决了，复杂度比较玄学。

```
#include<bits/stdc++.h>
using namespace std;
const int S = 5070;
const int N = 12;
int vcnt[S],T=0;//树的种类数以及每种树的点数
int compose[S][N],cnt[S],subtree[N],cur=0;//每种树的构成 
int add[S][S],del[S][S];//第i种树加上第j种树变成了什么，第i种树删掉第j种树变成了什么
int f[S];//第i种树对于K阶线图的贡献
int dp[S][S];//树上 x 的子树内，匹配第 i 种树的方案数
const int mod = 998244353;
inline int plu(int a,int b){return a+b>=mod?a+b-mod:a+b;}
inline int dec(int a,int b){return a-b<0?a-b+mod:a-b;}
const int E = 3e7+7;
vector<int> G[S];
int dfs(int x,int pre)
{
	dp[x][1]=1;
	for(int i=2;i<=T;i++)dp[x][i]=0;
	int res=0;
	for(int y:G[x])
	{
		if(y==pre)continue;
		res=plu(res,dfs(y,x));
		for(int A=T;A>=1;A--)
		for(int i=1;i<=cnt[A];i++)if(compose[A][i]^compose[A][i-1])
		dp[x][A]=plu(dp[x][A],1ll*dp[x][del[A][compose[A][i]]]*dp[y][compose[A][i]]%mod);
	}
	for(int i=1;i<=T;i++)if(f[i])res=plu(res,1ll*dp[x][i]*f[i]%mod);
	return res;
}
int Per;
namespace gener
{
	int n,m;
	inline int binom(int x){return 1ll*x*(x-1)/2%mod;}
	int deg[E],d[E],A[E],B[E];
	int U[2*E],V[2*E];
	struct edge 
	{
		int y,next;
	}e[2*E];
	int Link[E],t=0;
	void storage(int x,int y)
	{
		e[++t].y=y;
		e[t].next=Link[x];
		Link[x]=t;
	}
	int calc()
	{
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			ans=plu(ans,1ll*deg[i]*deg[i]*21%mod);
			ans=plu(ans,1ll*deg[i]*B[i]%mod);
			ans=dec(ans,1ll*deg[i]*A[i]*13%mod);
			ans=plu(ans,1ll*A[i]*A[i]%mod);
			ans=dec(ans,1ll*B[i]*2%mod);
			ans=plu(ans,1ll*A[i]*13%mod);
			ans=dec(ans,1ll*deg[i]*21%mod);
		}
		return 1ll*ans*((mod+1)/2)%mod;
	}
	int LineGraph(int K)
	{
		int res=0;
		for(int i=1;i<=n||i<=m;i++)
		deg[i]=d[i]=A[i]=B[i]=0;
		for(int i=1;i<=m;i++)
		{
			deg[U[i]]++;
			deg[V[i]]++;
		}
		if(K==1) return m;
		if(K==2) 
		{
			for(int i=1;i<=n;i++)
			res=plu(res,binom(deg[i]));
			return res;
		}
		if(K==3)
		{
			for(int i=1;i<=m;i++)
			res=plu(res,binom(deg[U[i]]+deg[V[i]]-2));
			return res;
		}
		if(K==4)
		{
			for(int i=1;i<=m;i++)
			{
				int W=deg[U[i]]+deg[V[i]];
				A[U[i]]=plu(A[U[i]],deg[U[i]]+deg[V[i]]);
				A[V[i]]=plu(A[V[i]],deg[U[i]]+deg[V[i]]);
				B[U[i]]=plu(B[U[i]],1ll*W*W%mod);
				B[V[i]]=plu(B[V[i]],1ll*W*W%mod);
			}
			return calc();
		}
		return 0;
 	}
	int construct(int x)
	{
		int u=++n;
		for(int i=1;i<=cnt[x];i++)
		{
			int y=compose[x][i];
			int v=construct(y);
			++m;
			U[m]=u;G[u].push_back(v);
			V[m]=v;G[v].push_back(u);
		}
		return u;
	}
	void treemaker(int p,int C,int L)//当前到了第几种树，点数是多少，目标点数是多少 
	{
		if(C==L)
		{
			++T;
			vcnt[T]=C;
			cnt[T]=cur;
			for(int i=1;i<=cur;i++)compose[T][i]=subtree[i];
			for(int i=1;i<=cur;i++)if(subtree[i]^subtree[i-1])
			{
				int P=1;
				for(int j=1;j<=cur;j++)if(i^j)P=add[P][subtree[j]];
				add[P][subtree[i]]=T;
				del[T][subtree[i]]=P;
			}
			for(int i=1;i<=m;i++)U[i]=V[i]=0;
			n=m=0;
			construct(T);
			int v=dfs(1,0);
			f[T]=dec(0,v);
			for(int i=1;i<=n;i++)G[i].clear();
			int R=Per;
			for(R=Per;R>4;R--)
			{
				for(int i=1;i<=n;i++)Link[i]=0;t=0;
				for(int i=1;i<=m;i++)
				{
					storage(U[i],V[i]);
					storage(V[i],U[i]);
				}
				int idx=0;
				for(int x=1;x<=n;x++)
				for(int i=Link[x];i;i=e[i].next)
				for(int j=e[i].next;j;j=e[j].next)
				{
					++idx;
					U[idx]=(i+1)/2;
					V[idx]=(j+1)/2;
				}
				n=m;m=idx;
			}
			f[T]=plu(f[T],LineGraph(R));
			return;
		}
		for(int i=p;i<=T&&C+vcnt[i]<=L;i++)
		{
			subtree[++cur]=i;
			treemaker(i,C+vcnt[i],L);
			cur--;
		}
	}	
}
int n,K;
void init()
{
	cin>>n>>K;Per=K;
	vcnt[++T]=1;
	for(int D=2;D<=K+1;D++)
	gener::treemaker(1,1,D);
}
int main()
{
	init();
	cout<<T<<endl;
	for(int i=1;i<=n;i++)G[i].clear();
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
	}
	printf("%d",dfs(1,0));
	return 0;
}
```


---


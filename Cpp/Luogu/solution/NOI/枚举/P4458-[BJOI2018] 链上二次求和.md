# [BJOI2018] 链上二次求和

## 题目描述

有一条长度为 $n$ 的链（ $\forall 1 \leq i < n$ ，点 $i$ 与点 $i+1$ 之间有一条边的无向图）， 每个点有一个整数权值，第 $i$ 个点的权值是 $a_i$ 。现在有 $m$ 个操作，每个操作如下：

操作 1（修改）：给定链上两个节点 $u,v$ 和一个整数 $d$，表示将链上 $u$ 到 $v$ 唯一的简单路径上每个点权值都加上 $d$。

操作 2（询问）：给定两个正整数 $l,r$，表示求链上所有节点个数大于等于 $l$ 且小于等于 $r$ 的简单路径节点权值和之和。由于答案很大，只用输出对质数 $1000000007$ 取模的结果即可。

一条节点个数为 $k$ 的简单路径节点权值和为这条上所有 $k$ 个节点（包括端点）的权值之和，而本题中要求是对所有满足要求的简单路径，求这一权值和的和。

由于是无向图，路径也是无向的，即点 $1$ 到点 $2$ 的路径与点 $2$ 到点 $1$ 的路径是同一条，不要重复计算。

## 说明/提示

### 样例解释：
节点个数为 $5$ 的简单路径只有 $1$ 条，权值和为 $5$，故第1次询问输出 $5$。

节点个数为 $1$ 的简单路径有 $5$ 条，每条权值和都是 $1$；节点个数为 $2$ 的简单路径有 $4$ 条，每条权值和都是 $2$，故第2次询问输出 $13 $。

在将点 $1$ 和点 $2$ 的权值加 $2$ 后， $5$ 条节点个数为 $1$ 的简单路径权值和分别为 $3$、$3$、$1$、$1$、$1$，故第 3 次询问输出 $9$。

### 数据范围：
记操作 1（修改）的次数为 $m^\prime$。

对于全部数据， 保证 $n \leq 200000$，$m \leq 500000$，$ m^\prime \leq 100000$，$ 0 \leq a_i < 1000000007$。

$1 \leq u \leq n$，$ 1\leq v \leq n$，$ 0 \leq d < 1000000007$，$l \leq r \leq n$。

对于每个数据点的详细规模与约定见下表。

![pic](https://cdn.luogu.com.cn/upload/pic/17580.png)

## 样例 #1

### 输入

```
5 5
1 1 1 1 1
2 5 5
2 1 2
1 1 2 2
2 1 1
1 1 5 3```

### 输出

```
5
13
9```

# 题解

## 作者：Elegia (赞：26)

考虑在 $u$ 节点单点修改，对于答案数组 $a_l$ 处的贡献，即该节点有多少条长度为 $x$ 的路径穿过它。可以考虑这一条路径的最左端点位置取值范围。

最左可以取到 $\max(1,u-x+1)$ ，而最右可以取到 $\min(u,n-x+1)$ ，故对答案的贡献是 $\min(u, n - x + 1)$ - $\max(1, u - x + 1) + 1$ 。

这个东西画出关于 $l$ 的函数图像应该是一个三段函数（通常），两个拐点显然在 $\min$ 中两项相等或 $\max$ 中两项相等时候取得。

不过直接分析也可以求出来上面这个式子对应的差分，其实是在答案数组上影响了其二阶差分，即 $\Delta_2 a_1=1$ ， $\Delta_2 a_{u+1} = -1$ ， $\Delta_2 a_{n-u+2} = -1$ 。

那么对于一次单点修改，我们可以 $\Theta(1)$ 更新差分数组，然后 $\Theta(n)$ 重构答案数组顺便再扫一遍前缀和。对于区间修改，就先统一更新，再重新重构就可以做到单次修改 $\Theta(n)$ 完成而单次查询 $\Theta(1)$ 完成。这个做法按照分点拿到了 50 分。

而为了通过此题，注意到区间修改的本质是增进了一个维度，结合前缀和我们实际需要在一个四阶差分上做单点修改。

其实曾经研究的树状数组进行区间修改区间查询，就是在二阶前缀和上的探索。注意到前缀和或差分具有可累加性，不妨直接讨论对于一个数列 $a_1=1$ ， $i>2,a_i=0$ 的数列的 k 阶前缀和 $\sigma_{k,n}=\sum_{i=1}^n\sigma_{k-1,i}$ 的表示。

容易注意到 $\sigma_{1,n}=1,\sigma_{2,n}=n$ ，而结合小学知识我们进一步知道 $\sigma_{3,n}=\frac{n(n+1)}2$ 以及 $\sigma_{4,n}=\frac{n(n+1)(n+2)}6$ 。

我们只需要用树状数组累加地维护一个 $k-1$ 阶多项式，那么多项式平移时预处理需要 $\Theta(nk^2)$ ，而单次修改和查询都是 $\Theta(k\log n)$ 的。

实测跑的比 std 以及大部分不加优化的标准思路快很多。

代码:

```cpp
#include <cstdio>
#include <cstring>

#include <algorithm>

#define LOG(FMT...) // fprintf(stderr, "[LOG] "FMT)

using namespace std;

typedef long long ll;

const int K = 4;

struct Poly {
	int a[K];
	
	Poly() { memset(a, 0, sizeof(a)); }
	
	Poly(const Poly& x) { memcpy(a, x.a, sizeof(a)); }
	
	int val(int x) const;
	
	Poly operator+(const Poly& rhs) const;
	Poly operator*(int k) const;
	
	Poly operator+=(const Poly& rhs);
	Poly operator*=(int k);
};

const int N = 200010, R24 = 41666667;
const int P = 1000000007;

int n, m;
int comb[K][K];
Poly unit[N];
Poly fw[N];

int lowBit(int k);
void change(int k, const Poly& x);
Poly query(int k);
void init();
void change(int k, int x);
void change(int l, int r, int a);
void exGcd(int a, int b, int& x, int& y); 
int rev(int a);

int main() {
	scanf("%d%d", &n, &m);
	init();
	for (int i = 1; i <= n; ++i) {
		int a;
		scanf("%d", &a);
		change(i, i, a);
	}
	while (m--) {
		int opt, l, r;
		scanf("%d%d%d", &opt, &l, &r);
		if (l > r)
			swap(l, r);
		if (opt == 1) {
			int a;
			scanf("%d", &a);
			change(l, r, a);
		} else {
			printf("%d\n", (query(r).val(r) - query(l - 1).val(l - 1) + P) % P);
		}
	}
	return 0;
}

void change(int l, int r, int a) {
	change(1, a * (ll)(r - l + 1) % P);
	change(2, a * (ll)(r - l + 1) % P * (P - 1) % P);
	change(l + 1, a * (ll)(P - 1) % P);
	change(r + 2, a);
	change(n - r + 2, a * (ll)(P - 1) % P);
	change(n - l + 3, a);
}

int rev(int a) {
	int x, y;
	exGcd(a, P, x, y);
	if (x < 0)
		x += P;
	return x;
}

void exGcd(int a, int b, int& x, int& y) {
	if (b == 0) {
		x = 1;
		y = 0;
		return;
	}
	exGcd(b, a % b, y, x);
	y -= a / b * x;
}

void change(int k, int x) {
	change(k, unit[k - 1] * x);
}

void init() {
	for (int i = 0; i < K; ++i) {
		comb[i][0] = 1;
		for (int j = 1; j <= i; ++j)
			comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];
	}
	unit[0].a[1] = rev(3);
	unit[0].a[2] = rev(2);
	unit[0].a[3] = rev(6);
	for (int i = 1; i <= n; ++i)
		for (int j = 0; j < K; ++j) {
			int ix = unit[0].a[j];
			for (int k = j; k >= 0; --k) {
				unit[i].a[k] += ix * (ll)comb[j][k] % P;
				if (unit[i].a[k] >= P)
					unit[i].a[k] -= P; 
				ix = ix * (ll)(P - i) % P;
			}
		}
	LOG("%d\n", unit[0].val(2)); 
}

int Poly::val(int x) const {
	int ret = 0, xxp = 1;
	for (int i = 0; i < K; ++i) {
		ret = (ret + a[i] * (ll)xxp) % P;
		xxp = xxp * (ll)x % P;
	}
	return ret;
}

Poly Poly::operator+(const Poly& rhs) const {
	Poly ret(*this);
	return ret += rhs;
}

Poly Poly::operator*(int k) const {
	Poly ret(*this);
	return ret *= k;
}

Poly Poly::operator+=(const Poly& rhs) {
	for (int i = 0; i < K; ++i) {
		a[i] += rhs.a[i];
		if (a[i] >= P)
			a[i] -= P;
	}
	return *this;
}

Poly Poly::operator*=(int k) {
	for (int i = 0; i < K; ++i)
		a[i] = a[i] * (ll)k % P;
	return *this;
}

int lowBit(int k) {
	return k & -k;
}

void change(int k, const Poly& x) {
	for (; k <= n; k += lowBit(k))
		fw[k] += x;
}

Poly query(int k) {
	Poly ret = Poly();
	for (; k; k -= lowBit(k))
		ret += fw[k];
	return ret;
}
```

---

## 作者：Raymondzll (赞：24)

## P4458 链上二次求和

### 前言

尽量做到一气呵成，会 sigma 的小学生都能看懂，因为真的就是线段树和推式子。

### 解题思路

记原链表为 $a$，一次前缀和 $S_a$ 记为 $S$，二次前缀和 $S_{S_a}$ 记为 $SS$。

$\begin{aligned}
&\sum\limits_{k=l}^{r}\sum\limits_{i=k}^{n}\sum\limits_{j=i-k+1}^{i}a_j
\\&=\sum\limits_{k=l}^{r}\sum\limits_{i=k}^{n}S_i-S_{i-k}
\\&=\sum\limits_{k=l}^{r}(\sum\limits_{i=k}^{n}S_i-\sum\limits_{j=0}^{n-k}S_j)
\\&=\sum\limits_{k=l}^{r}(SS_n-SS_{k-1}-SS_{n-k})
\\&=(r-l+1)SS_n-\sum\limits_{k=l-1}^{r-1}SS_k-\sum\limits_{k=n-r}^{n-l}SS_k
\end{aligned}$

我们要维护 $\sum\limits_{k=l}^{r}SS_k$，支持区间修改。

当对 $l\sim r$ 加上 $\Delta$ 时，

对于 $l\le i\le r$ 的 $i$，$SS_i$ 加上 $\frac{(i-l+1)(i-l+2)}{2}\times\Delta$。

对于 $r< i\le n$ 的 $i$，$SS_i$ 加上 $\frac{(r-l+1)(r-l+2)}{2}\times\Delta+(i-r)(r-l+1)\times\Delta$。

最后一点，```lazy``` 数组可以用三个数 ```la,lb,lc``` 三个数表示，代表 ```val[id]``` 需要加上 $\sum\limits_ {i=l}^r{la\times i^2+lb\times i+lc}$。

相信没有什么疑问了吧。

### 细节

1. 可能出现 $l>r$。

2. 除以 $2$ 和 $6$ 就算出 $2$ 和 $6$ 在 $\pmod{1000000007}$ 下的逆元就行。

3. 注意负数和各种奇怪的溢出。

4. 不要写着写着忘了式子，坚定信念，也就一百多行。

### 代码部分

```cpp
#include <bits/stdc++.h>
using namespace std;
void file(string str){
	freopen((str+".in").c_str(),"r",stdin);
	freopen((str+".out").c_str(),"w",stdout);
}
const int MAXN=200010;
const int mod=1e9+7,inv2=5e8+4,inv6=inv2/3;
int n,m,init[MAXN],s[MAXN],ss[MAXN];
int val[MAXN<<2],laa[MAXN<<2],lab[MAXN<<2],lac[MAXN<<2];
inline int ad(int a,int b){return (a+b)%mod;}
inline int add(int a,int b,int c=0,int d=0){return ad(ad(a,b),ad(c,d));}
inline int mu(int a,int b){return 1ll*a*b%mod;}
inline int mul(int a,int b,int c=1,int d=1){return mu(mu(a,b),mu(c,d));}
int p1sum(int a){return mul(a,a+1,inv2);}
int p2sum(int a){return mul(a,a+1,2*a+1,inv6);}
int p1sum(int a,int b){return p1sum(b)-p1sum(a-1);}
int p2sum(int a,int b){return p2sum(b)-p2sum(a-1);}
void ___(int &a){a%=mod;if(a<0)a+=mod;}
void pushup(int id){val[id]=add(val[id<<1],val[id<<1|1]);}
void tag(int id,int l,int r,int la,int lb,int lc){
	val[id]=add(val[id],mul(la,p2sum(l,r)),mul(lb,p1sum(l,r)),mul(lc,r-l+1));
	___(val[id]);laa[id]=add(laa[id],la);lab[id]=add(lab[id],lb);lac[id]=add(lac[id],lc);
}
void pushdown(int id,int l,int r){
	if(laa[id]||lab[id]||lac[id]){
		int mid=(l+r)>>1;
		tag(id<<1,l,mid,laa[id],lab[id],lac[id]);
		tag(id<<1|1,mid+1,r,laa[id],lab[id],lac[id]);
		laa[id]=lab[id]=lac[id]=0;
	}
}
void update(int id,int l,int r,int ql,int qr,int la,int lb,int lc){
	if(r<ql||l>qr)return;
	if(l>=ql&&r<=qr){tag(id,l,r,la,lb,lc);return;}
	int mid=(l+r)>>1;pushdown(id,l,r);
	update(id<<1,l,mid,ql,qr,la,lb,lc);
	update(id<<1|1,mid+1,r,ql,qr,la,lb,lc);
	pushup(id);
}
int query(int id,int l,int r,int ql,int qr){
	if(r<ql||l>qr)return 0;
	if(l>=ql&&r<=qr)return val[id];
	int mid=(l+r)>>1;pushdown(id,l,r);
	return add(query(id<<1,l,mid,ql,qr),query(id<<1|1,mid+1,r,ql,qr));
}
void build(int id,int l,int r){
	if(l==r){val[id]=ss[l];return;}
	int mid=(l+r)>>1;
	build(id<<1,l,mid);build(id<<1|1,mid+1,r);pushup(id);
}
void UPDATE(int l,int r,int d){
	int inv2_d=mul(inv2,d);
	update(1,1,n,l,r,inv2_d,mul((mod+3-2*l),inv2_d),mul(l-1,l-2,inv2_d));
	int tmp1=mul(p1sum(r-l+1),d),tmp2=mul(r-l+1,d);
	if(r<n)update(1,1,n,r+1,n,0,tmp2,tmp1-mul(tmp2,r));
}
int QUERY(int l,int r){
	int res=mul(r-l+1,query(1,1,n,n,n));
	res-=query(1,1,n,l-1,r-1);res-=query(1,1,n,n-r,n-l);
	___(res);return res;
}
void initt(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&init[i]);
		s[i]=add(s[i-1],init[i]);ss[i]=add(ss[i-1],s[i]);
	}
	build(1,1,n);
}
int main(){
	initt();
	for(int i=1;i<=m;i++){
		int op,a,b,c;
		scanf("%d%d%d",&op,&a,&b);
		if(op==1){scanf("%d",&c);if(a>b)swap(a,b);UPDATE(a,b,c);}
		else printf("%d\n",QUERY(a,b));
	}
	return 0;
}

```

---

## 作者：暴力出奇迹 (赞：23)

### **前言：**

本初二蒟蒻对数论一窍不通，本题解推导过程都是无脑数学式，**似乎比别的题解长得多**。

这是本蒟蒻 AC 的第一道黑题，也是本蒟蒻的第一篇题解，希望大家对文中的不足提出建议吧。

~~（话说我怎么第一篇题解就要写辣么多数学柿子呀）~~

### **题目大意：**
给一条长度为 $n$ 的链，从 $1$ 到 $n$ 依次连接而成。每个结点有一个点权。要求实现两种操作：
1. 将结点 $u$ 到 $v$ 之间的所有结点（包括 $u$ 和 $v$）的点权都 $+d$。
1. 求出所有长度在 $[l,r]$ 范围内的链的二次求和。从 $u$ 到 $v$ 和从 $v$ 到 $u$ 被视作同一条链。

数据范围：$n\le2\times10^5$，$m\le5\times10^5$，$m'\le1\times10^5$，$l \le r$。
($m$ 表示两种操作的总次数，$m'$ 表示操作 $1$ 的次数）

## **题解：**

### 1. **写在最前面：一定要注意！**

读完这道题目，大家可能会直呼：这不就是个序列吗！为什么出题人非要说成链呢？

因为他要埋伏陷害你啊！

如果仔细看一下冗长的数据范围，你会发现，好像只说了 $l \le r$，并没有说 $u \le v$？

$l$ 和 $r$ 是操作 $2$ 的参数，$u$ 和 $v$ 是操作 $1$ 的参数，说明什么？

**在修改的时候，可能存在 $u>v$！这时需要交换 $u$ 和 $v$！**

据本人实测，如果没有考虑 $u>v$，$100$ 分降到 $25$ 分！所以说，**代码写错非实弱，细节想假毁一生。**

### 2. 前置芝士：**线段树**

~~（话说不会线段树的就先别开黑题了吧）~~

先预告一下本题需要维护的东西：

三棵线段树：

$sp[0]$ 记录：$\sum\limits_{}a_i$，

$sp[1]$ 记录：$\sum\limits_{}a_i \times i$，

$sp[2]$ 记录：$\sum\limits_{}a_i \times i^2$。

其中 $a_i$ 表示原序列中的每一个数。

令：

$$\operatorname{sum(0,i)}=i$$

$$\operatorname{sum(1,i)}=\sum\limits_{j=1}^ij$$

$$\operatorname{sum(2,i)}=\sum\limits_{j=1}^ij^2$$

$sum$ 数组的预处理长这样：
```cpp
for(LL i = 1; i <= n; i++) {
	sum[0][i] = (sum[0][i - 1] + 1) % mod;
	sum[1][i] = (sum[1][i - 1] + i) % mod;
	sum[2][i] = (sum[2][i - 1] + i * i) % mod;
}
```
注：$mod$ 表示本题模数，$mod=10^9+7$。

线段树的板子不啰嗦了，放上我巨丑的代码：

一些变量的定义：
```cpp
#define MAXN 200010
#define mod 1000000007
#define LL long long
LL sp[3][MAXN << 2], lazy[MAXN << 2], sum[3][MAXN];
LL n, m;
```
$up$ 函数及建树：

```cpp
inline void up(LL p) {
	for(LL i = 0; i < 3; i++)
		sp[i][p] = (sp[i][p << 1] + sp[i][p << 1 | 1]) % mod;
}
inline void build(LL p, LL l, LL r) {
	if(l == r) {
		scanf("%lld", &sp[0][p]);
		sp[1][p] = sp[0][p] * l % mod;
		sp[2][p] = sp[0][p] * l % mod * l % mod;
		return;
	}
	LL m = (l + r) >> 1;
	build(p << 1, l, m);
	build(p << 1 | 1, m + 1, r);
	up(p);
}
```
下传懒惰标记：

```cpp
inline void down(LL p, LL l, LL r) {
	if(lazy[p]) {
		lazy[p << 1] = (lazy[p << 1] + lazy[p]) % mod;
		lazy[p << 1 | 1] = (lazy[p << 1 | 1] + lazy[p]) % mod;
		LL m = (l + r) >> 1;
		for(LL i = 0; i < 3; i++) {
			sp[i][p << 1] = (sp[i][p << 1] + (sum[i][m] - sum[i][l - 1] + mod) % mod * lazy[p] % mod) % mod;
			sp[i][p << 1 | 1] = (sp[i][p << 1 | 1] + (sum[i][r] - sum[i][m] + mod) % mod * lazy[p] % mod) % mod;
		}
		lazy[p] = 0;
	}
}
```
$update$ 函数：
```cpp
inline void update(LL p, LL l, LL r, LL x, LL y, LL d) {
	if(x <= l && r <= y) {
		lazy[p] = (lazy[p] + d) % mod;
		for(LL i = 0; i < 3; i++)
			sp[i][p] = (sp[i][p] + (sum[i][r] - sum[i][l - 1] + mod) % mod * d % mod) % mod;
		return;
	}
	down(p, l, r);
	LL m = (l + r) >> 1;
	if(x <= m) update(p << 1, l, m, x, y, d);
	if(y > m) update(p << 1 | 1, m + 1, r, x, y, d);
	up(p);
}
```
$query$ 函数：
```cpp
inline LL query(LL id, LL p, LL l, LL r, LL ql, LL qr) { //id表示询问的线段树的编号。
	if(ql <= l && r <= qr) return sp[id][p];
	down(p, l, r);
	LL m = (l + r) >> 1, ret = 0;
	if(ql <= m) ret = (ret + query(id, p << 1, l, m, ql, qr)) % mod;
	if(qr > m) ret = (ret + query(id, p << 1 | 1, m + 1, r, ql, qr)) % mod;
	return ret;
}
```
（线段树板子部分自行理解吧，那不是最主要的部分）

### 3.重点部分：推式子

先给一道我以前做过的题目：
[P2221 [HAOI2012]高速公路](https://www.luogu.com.cn/problem/P2221)

我从这道题目中得出了一些宝贵的经验：**类似于这种类型的二次求和题，一般从每一个点对最终答案的贡献来考虑。**

~~所以我就坚定不移地沿着这个思路疯狂地无脑推式子，所以这篇题解特别长 QwQ。~~

首先简化一下需要求的答案：
设 $\operatorname{solve(x)}$ 表示所有长度在 $[1,x]$ 范围内的链的二次求和。

对于询问 $[l,r]$，$Ans=\operatorname{solve(r)}-\operatorname{solve(l-1)}$。

如果没有这一步，恐怕下面就没办法做了。

但是由于我们会在 $\operatorname{solve}$ 函数中把答案取模，所以写代码的时候应该这样写：
```cpp
printf("%lld\n", (solve(r) - solve(l - 1) + mod) % mod);
```
由于题目保证了 $l \le r$，所以不用特判 $l>r$ 的情况了。

接下来就是对 $\operatorname{solve(x)}$ 求解。

为了避免考虑一些奇奇怪怪的边界情况偷个小懒，我就直接特判 $x=0$ 的时候返回值为 $0$ 了。

设 $C_i$ 表示 $a_i$ 对最终答案的贡献次数，意思就是$a_i$在所有符合条件的链中的出现次数。则有：

$$C_i=\sum\limits_{j=\max(i-x+1,1)}^i \min(j+x-1,n)-i+1$$

这个柿子是什么意思呢？

$j$ 枚举符合条件的链的左端点，显然只有当 $j \ge i-x+1$ 时，右端点才能够达到 $i$。同样显然的是 $j \ge 1$。

$j+x-1$ 表示此时右端点最多能到达哪里，但是右端点显然不能超过 $n$，所以和 $n$ 取一个 $\min$。

$\min(j+x-1,n)-i+1$ 表示的就是：以 $j$ 为左端点时，$a_i$ 对答案的贡献次数。

显然，$\max$ 和 $\min$ 的存在严重阻碍了我们化简式子，所以接下来需要进行复杂的分类讨论：

## 一. 当 $x \le n - x + 1$ 时：
### 1. $j \in [1,x]$
则有：
$$j-x+1 \le 1$$

$$\therefore C_i=\sum\limits_{j=1}^i \min(j+x-1,n)-i+1$$

$\because j \le x$

$\therefore j+x-1 \le 2x-1$

$\because x \le n - x + 1$

$\therefore 2x-1 \le n$

$\therefore j+x-1 \le n$

$\therefore $
$$\therefore C_i=\sum\limits_{j=1}^i j+x-i$$

（现在应该知道为什么前面要分类 $x \le n-x+1$ 了吧）

手推一下，得：
$$C_i=\frac{1}{2}i(2x-i+1)$$

这一段对答案的贡献（为了节省篇幅，过程略）：
$$\sum\limits_{j=1}^x C_ia_i$$
$$=\frac{1}{2}\sum\limits_{i=1}^x[(2x+1)ia_i-i^2a_i]$$

于是可以在 $sp[1]$ 中查询$\sum\limits_{i=1}^xia_i$，在 $sp[2]$ 中查询 $\sum\limits_{i=1}^xi^2a_i$。

这一部分的代码：
```cpp
LL s1 = query(1, 1, 1, n, 1, x);
LL s2 = query(2, 1, 1, n, 1, x);
ret = (ret + ((x << 1 | 1) * s1 % mod - s2 + mod) % mod * P % mod) % mod;
```
$P$ 的含义将会在后文提及。

万事开头难，现在我们已经推导出了第一段，以下就如法炮制了。**为节省篇幅，以下会省略大量简单过程，建议自行手推一下加深印象。**

### 2. $i \in [x+1,n-x+1]$
则有：
$$C_i=\sum\limits_{j=i-x+1}^i \min(j+x-1,n)-i+1$$

显然，$j+x-1 \le i+x-1 \le n-x+1+x-1=n$

所以愉快地拆掉 $\min$ 啦：
$$C_i=\sum\limits_{j=i-x+1}^i j+x-i$$

$$C_i=\frac{1}{2}x(x+1)$$

这一段对答案的贡献：

$$\sum\limits_{i=x+1}^{n-x+1}C_ia_i$$
$$=\frac{1}{2}\sum\limits_{i=x+1}^{n-x+1}a_ix(x+1)$$

调用 $sp[0]$ 查一下
$$\sum\limits_{i=x+1}^{n-x+1}a_i$$
就搞定啦。

这一部分的代码：
```cpp
if(x < n - x + 1) ret = (ret + query(0, 1, 1, n, x + 1, n - x + 1) * x % mod * (x + 1) % mod * P % mod) % mod;
```
注意先特判一下 $x<n-x+1$。

### 3. $i \in [n-x+2,n]$
则有：
$$C_i=\sum\limits_{j=i-x+1}^i \min(j+x-1,n)-i+1$$

这个就比较麻烦了，要进一步分类讨论。

(1) $j+x-1 \le n$

$\because i-x+1 \le j \le n-x+1$

$\therefore$
$$C_i=\sum\limits_{j=i-x+1}^{n-x+1}j+x-i$$
$$C_i=\frac{1}{2}(n-i+1)(n-i+2)$$
令：$X=n+1$，$Y=n+2$，

则：$C_i=XY-(X+Y)i+i^2$。

这一段对答案的贡献：
$$\sum\limits_{i=n-x+2}^nC_ia_i$$
$$=\frac{1}{2}\sum\limits_{i=n-x+2}^nXYa_i-(X+Y)ia_i+i^2a_i$$

(2) $j+x-1>n$
$$C_i=\sum\limits_{n-x+2}^in-i+1$$
$$C_i=(n-i+1)(i-n+x-1)$$
令：$E=n+1$，$F=x-n-1$，则：
$$C_i=EF+(E-F)i-i^2$$

这一段对答案的贡献：
$$\sum\limits_{i=n-x+2}^nC_ia_i$$
$$=\sum\limits_{i=n-x+2}^nEFa_i+(E-F)ia_i-i^2a_i$$

放一下整个 $3.$ 的代码：
```cpp
if(n - x + 2 <= n) {
	LL X = n + 1, Y = n + 2;
	LL s0 = query(0, 1, 1, n, n - x + 2, n);
	LL s1 = query(1, 1, 1, n, n - x + 2, n);
	LL s2 = query(2, 1, 1, n, n - x + 2, n);
	ret = (ret + (X * Y % mod * s0 % mod - (X + Y) * s1 % mod + s2 + mod) % mod * P % mod) % mod;
	LL E = n + 1, F = x - n - 1;
	ret = (ret + (E * F % mod * s0 % mod + (E - F) * s1 % mod - s2 + mod * 2) % mod) % mod; //这里必须要+mod*2，因为F=x-n-1是负数，导致前面E*F%mod也会产生一个负数，所以要+mod*2扳回来。如果+mod，就只剩25分了！
}
```
话说我们终于把 $x \le n-x+1$ 推完了 QAQ。

## 二. $x>n-x+1$
### 1. $i \in [1,n-x+1]$

$\because x>n-x+1$

$\therefore i<x$

$\therefore$
$$C_i=\sum\limits_{j=1}^i min(j+x-1,n)-i+1$$

$\because i<n-x+1$

$\therefore i+x-1 \le n$

$\therefore j+x-1 \le n$

$\therefore$

$$C_i=\sum\limits_{j=1}^i j+x-i$$

$$C_i=\frac{1}{2}(2xi-i^2+i)$$

这一段对答案的贡献：
$$\sum\limits_{i=1}^{n-x+1}C_ia_i$$
$$=\frac{1}{2}\sum\limits_{i=1}^{n-x+1}[(2x+1)ia_i-i^2a_i]$$

这一段的代码放一下：
```cpp
LL s1 = query(1, 1, 1, n, 1, n - x + 1);
LL s2 = query(2, 1, 1, n, 1, n - x + 1);
ret = (ret + ((x << 1 | 1) * s1 % mod - s2 + mod) % mod * P % mod) % mod;
```
### 2. $i \in [n-x+2,x]$

则有：
$$C_i=\sum\limits_{j=1}^i min(j+x-1,n)-i+1$$

(1) $j+x-1 \le n$

则有：
$$C_i=\sum\limits_{j=1}^{n-x+1}j+x-i$$
$$C_i=\frac{1}{2}(n-x+1)(n+x-2i+2)$$

令：$A=n-x+1$，$B=n+x+2$，则：
$$C_i=\frac{1}{2}A(B-2i)$$

这一段对答案的贡献：
$$\sum\limits_{i=n-x+2}^xC_ia_i$$
$$=\frac{1}{2}\sum\limits_{i=n-x+2}^xABa_i-2Aia_i$$

(2) $j>n-x+1$

则有：
$$C_i=\sum\limits_{j=n-x+2}^i n-i+1$$
$$C_i=(n-i+1)(i-n+x-1)$$

令：$S=n+1$，$T=x-n-1$。

~~（话说我令的都是些啥字母）~~

则有：
$$C_i=ST-(S-T)i+i^2$$

这一段对答案的贡献：
$$\sum\limits_{i=n-x+2}^xC_ia_i$$
$$=\sum\limits_{i=n-x+2}^xSTa_i+(S-T)ia_i-i^2a_i$$

整个 $2.$ 的代码放上来：
```cpp
LL A = n - x + 1, B = n + x + 2;
LL s0 = query(0, 1, 1, n, n - x + 2, x);
LL s1 = query(1, 1, 1, n, n - x + 2, x);
LL s2 = query(2, 1, 1, n, n - x + 2, x);
ret = (ret + (A * B % mod * s0 % mod - 2 * A * s1 % mod + mod) % mod * P % mod) % mod;
LL S = n + 1, T = x - n - 1;
ret = (ret + (S * T % mod * s0 % mod + (S - T) * s1 % mod - s2 + mod * 2) % mod) % mod; //同样注意+mod*2。
```
### 3. $i \in [x+1,n]$
则有：
$$C_i=\sum\limits_{j=i-x+1}^imin(j+x-1,n)-i+1$$
继续分类讨论：

(1) $j+x-1 \le n$

则有：
$$C_i=\sum\limits_{j=i-x+1}^{n-x+1}j+x-i$$
$$C_i=\frac{1}{2}(n-i+1)(n-i+2)$$

令：$M=n+1$，$N=n+2$。则有：
$$C_i=\frac{1}{2}[MN-(M+N)i+i^2]$$

这一部分对答案的贡献：
$$\sum\limits_{i=x+1}^nC_ia_i$$
$$=\frac{1}{2}\sum\limits_{i=x+1}^nMNa_i-(M+N)ia_i+i^2a_i$$

(2) $j>n-x+1$，则有：
$$C_i=\sum\limits_{j=n-x+2}^in-i+1$$
$$C_i=(i-n+x-1)(n-i+1)$$
令：$G=x-n-1$，$H=N+1$，则有：
$$C_i=GH+(H-G)i-i^i$$

这一段对答案的贡献：
$$\sum\limits_{i=x+1}^nC_ia_i$$
$$=\sum\limits_{i=x+1}^nGHa_i+(H-G)ia_i-i^2a_i$$

把整个 $3.$ 的代码放一下：
```cpp
if(x < n) {
	LL M = n + 1, N = n + 2;
	LL s0 = query(0, 1, 1, n, x + 1, n);
	LL s1 = query(1, 1, 1, n, x + 1, n);
	LL s2 = query(2, 1, 1, n, x + 1, n);
	ret = (ret + (M * N % mod * s0 % mod - (M + N) * s1 % mod + s2 + mod) % mod * P % mod) % mod;
	LL G = x - n - 1, H = n + 1;
	ret = (ret + (G * H % mod * s0 % mod + (H - G) * s1 % mod - s2 + mod * 2) % mod) % mod; //又是恶心的+mod*2。
}
```
### **终于推完式子了！**

简单讲一下代码中 $P$ 的含义：

由于答案要对 $p=10^9+7$ （**这是个质数**）取模，又因为式子中含有大量的 $\dfrac{1}{2}$，所以我们要计算 $P=\dfrac{1}{2} \bmod p$的值。显然可以套一下[费马小定理](https://baike.so.com/doc/5743090-5955843.html)来解决。
$$P=\dfrac{1}{2} \bmod p=2^{-1} \bmod p=2^{p-2} \bmod p$$
写个快速幂就行了。

于是代码就出来了：
```cpp
#include <cstdio>
using namespace std;
#define MAXN 200010
#define mod 1000000007
#define LL long long
LL sp[3][MAXN << 2], lazy[MAXN << 2], sum[3][MAXN];
LL n, m, P;
inline LL pow(LL x, LL y) {
	LL ret = 1;
	while(y) {
		if(y & 1) ret = ret * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ret;
}
inline void swap(LL &x, LL &y) {
	x ^= y ^= x ^= y;
}
inline void up(LL p) {
	for(LL i = 0; i < 3; i++)
		sp[i][p] = (sp[i][p << 1] + sp[i][p << 1 | 1]) % mod;
}
inline void build(LL p, LL l, LL r) {
	if(l == r) {
		scanf("%lld", &sp[0][p]);
		sp[1][p] = sp[0][p] * l % mod;
		sp[2][p] = sp[0][p] * l % mod * l % mod;
		return;
	}
	LL m = (l + r) >> 1;
	build(p << 1, l, m);
	build(p << 1 | 1, m + 1, r);
	up(p);
}
inline void down(LL p, LL l, LL r) {
	if(lazy[p]) {
		lazy[p << 1] = (lazy[p << 1] + lazy[p]) % mod;
		lazy[p << 1 | 1] = (lazy[p << 1 | 1] + lazy[p]) % mod;
		LL m = (l + r) >> 1;
		for(LL i = 0; i < 3; i++) {
			sp[i][p << 1] = (sp[i][p << 1] + (sum[i][m] - sum[i][l - 1] + mod) % mod * lazy[p] % mod) % mod;
			sp[i][p << 1 | 1] = (sp[i][p << 1 | 1] + (sum[i][r] - sum[i][m] + mod) % mod * lazy[p] % mod) % mod;
		}
		lazy[p] = 0;
	}
}
inline void update(LL p, LL l, LL r, LL x, LL y, LL d) {
	if(x <= l && r <= y) {
		lazy[p] = (lazy[p] + d) % mod;
		for(LL i = 0; i < 3; i++)
			sp[i][p] = (sp[i][p] + (sum[i][r] - sum[i][l - 1] + mod) % mod * d % mod) % mod;
		return;
	}
	down(p, l, r);
	LL m = (l + r) >> 1;
	if(x <= m) update(p << 1, l, m, x, y, d);
	if(y > m) update(p << 1 | 1, m + 1, r, x, y, d);
	up(p);
}
inline LL query(LL id, LL p, LL l, LL r, LL ql, LL qr) {
	if(ql <= l && r <= qr) return sp[id][p];
	down(p, l, r);
	LL m = (l + r) >> 1, ret = 0;
	if(ql <= m) ret = (ret + query(id, p << 1, l, m, ql, qr)) % mod;
	if(qr > m) ret = (ret + query(id, p << 1 | 1, m + 1, r, ql, qr)) % mod;
	return ret;
}
inline LL solve(LL x) {
	if(x == 0) return 0;
	LL ret = 0;
	if(x <= n - x + 1) {
		LL s1 = query(1, 1, 1, n, 1, x);
		LL s2 = query(2, 1, 1, n, 1, x);
		ret = (ret + ((x << 1 | 1) * s1 % mod - s2 + mod) % mod * P % mod) % mod;
		if(x < n - x + 1) ret = (ret + query(0, 1, 1, n, x + 1, n - x + 1) * x % mod * (x + 1) % mod * P % mod) % mod;
		if(n - x + 2 <= n) {
			LL X = n + 1, Y = n + 2;
			LL s0 = query(0, 1, 1, n, n - x + 2, n);
			LL s1 = query(1, 1, 1, n, n - x + 2, n);
			LL s2 = query(2, 1, 1, n, n - x + 2, n);
			ret = (ret + (X * Y % mod * s0 % mod - (X + Y) * s1 % mod + s2 + mod) % mod * P % mod) % mod;
			LL E = n + 1, F = x - n - 1;
			ret = (ret + (E * F % mod * s0 % mod + (E - F) * s1 % mod - s2 + mod * 2) % mod) % mod;
		}
	}
	else {
		LL s1 = query(1, 1, 1, n, 1, n - x + 1);
		LL s2 = query(2, 1, 1, n, 1, n - x + 1);
		ret = (ret + ((x << 1 | 1) * s1 % mod - s2 + mod) % mod * P % mod) % mod;
		LL A = n - x + 1, B = n + x + 2;
		LL s0 = query(0, 1, 1, n, n - x + 2, x);
		s1 = query(1, 1, 1, n, n - x + 2, x);
		s2 = query(2, 1, 1, n, n - x + 2, x);
		ret = (ret + (A * B % mod * s0 % mod - 2 * A * s1 % mod + mod) % mod * P % mod) % mod;
		LL S = n + 1, T = x - n - 1;
		ret = (ret + (S * T % mod * s0 % mod + (S - T) * s1 % mod - s2 + mod * 2) % mod) % mod;
		if(x < n) {
			LL M = n + 1, N = n + 2;
			LL s0 = query(0, 1, 1, n, x + 1, n);
			LL s1 = query(1, 1, 1, n, x + 1, n);
			LL s2 = query(2, 1, 1, n, x + 1, n);
			ret = (ret + (M * N % mod * s0 % mod - (M + N) * s1 % mod + s2 + mod) % mod * P % mod) % mod;
			LL G = x - n - 1, H = n + 1;
			ret = (ret + (G * H % mod * s0 % mod + (H - G) * s1 % mod - s2 + mod * 2) % mod) % mod;
		}
	}
	return ret;
}
int main() {
	P = pow(2, mod - 2);
	scanf("%lld %lld", &n, &m);
	for(LL i = 1; i <= n; i++) {
		sum[0][i] = (sum[0][i - 1] + 1) % mod;
		sum[1][i] = (sum[1][i - 1] + i) % mod;
		sum[2][i] = (sum[2][i - 1] + i * i) % mod;
	}
	build(1, 1, n);
	while(m--) {
		LL opt, l, r, x;
		scanf("%lld", &opt);
		if(opt == 1) {
			scanf("%lld %lld %lld", &l, &r, &x);
			if(l > r) swap(l, r);
			update(1, 1, n, l, r, x);
		}
		else {
			scanf("%lld %lld", &l, &r);
			printf("%lld\n", (solve(r) - solve(l - 1) + mod) % mod);
		}
	}
	return 0;
}
```
别 Ctrl+C/V 啊！这个是 $60$ 分的！TLE！

问题出在哪里了呢？

一方面，对同一区间在三棵线段树中分别求和，很浪费时间；另一方面，虽然古话说**不取模见祖宗**，但是这样疯狂取模未免过分了点？

比如说，以下是从 $down$ 函数里面抄来的一条语句：
```cpp
sp[i][p << 1] = (sp[i][p << 1] + (sum[i][m] - sum[i][l - 1] + mod) % mod * lazy[p] % mod) % mod;
```
可以改成：
```cpp
sp[i][p << 1] = (sp[i][p << 1] + (sum[i][m] - sum[i][l - 1] + mod) * lazy[p]) % mod;
```
一下子干掉了 $2$ 个取模！

对于问题 $1$，其实很好解决：可以询问一次，用结构体返回 $3$ 个和，这样可以大幅度提速。

修改后的代码如下（AC，最大测试点约 $3.5s$）：
```cpp
#include <cstdio>
using namespace std;
#define MAXN 200010
#define mod 1000000007
#define LL long long
struct ans {
	LL s0, s1, s2;
};
LL sp[3][MAXN << 2], lazy[MAXN << 2], sum[3][MAXN];
LL n, m, P;
inline LL pow(LL x, LL y) {
	LL ret = 1;
	while(y) {
		if(y & 1) ret = ret * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ret;
}
inline void swap(LL &x, LL &y) {
	x ^= y ^= x ^= y;
}
inline void up(LL p) {
	for(LL i = 0; i < 3; i++)
		sp[i][p] = (sp[i][p << 1] + sp[i][p << 1 | 1]) % mod;
}
inline void build(LL p, LL l, LL r) {
	if(l == r) {
		scanf("%lld", &sp[0][p]);
		sp[1][p] = sp[0][p] * l % mod;
		sp[2][p] = sp[0][p] * l % mod * l % mod;
		return;
	}
	LL m = (l + r) >> 1;
	build(p << 1, l, m);
	build(p << 1 | 1, m + 1, r);
	up(p);
}
inline void down(LL p, LL l, LL r) {
	if(lazy[p]) {
		lazy[p << 1] = (lazy[p << 1] + lazy[p]) % mod;
		lazy[p << 1 | 1] = (lazy[p << 1 | 1] + lazy[p]) % mod;
		LL m = (l + r) >> 1;
		for(LL i = 0; i < 3; i++) {
			sp[i][p << 1] = (sp[i][p << 1] + (sum[i][m] - sum[i][l - 1] + mod) * lazy[p]) % mod;
			sp[i][p << 1 | 1] = (sp[i][p << 1 | 1] + (sum[i][r] - sum[i][m] + mod) * lazy[p]) % mod;
		}
		lazy[p] = 0;
	}
}
inline void update(LL p, LL l, LL r, LL x, LL y, LL d) {
	if(x <= l && r <= y) {
		lazy[p] = (lazy[p] + d) % mod;
		for(LL i = 0; i < 3; i++)
			sp[i][p] = (sp[i][p] + (sum[i][r] - sum[i][l - 1] + mod) * d) % mod;
		return;
	}
	down(p, l, r);
	LL m = (l + r) >> 1;
	if(x <= m) update(p << 1, l, m, x, y, d);
	if(y > m) update(p << 1 | 1, m + 1, r, x, y, d);
	up(p);
}
inline ans query(LL p, LL l, LL r, LL ql, LL qr) {
	if(ql <= l && r <= qr) return (ans){sp[0][p], sp[1][p], sp[2][p]};
	down(p, l, r);
	LL m = (l + r) >> 1, s0 = 0, s1 = 0, s2 = 0;
	if(ql <= m) {
		ans now = query(p << 1, l, m, ql, qr);
		s0 += now.s0;
		s1 += now.s1;
		s2 += now.s2;
	}
	if(qr > m) {
		ans now = query(p << 1 | 1, m + 1, r, ql, qr);
		s0 += now.s0;
		s1 += now.s1;
		s2 += now.s2;
	}
	return (ans){s0 % mod, s1 % mod, s2 % mod};
}
inline LL solve(LL x) {
	if(x == 0) return 0;
	LL ret = 0;
	if(x <= n - x + 1) {
		ans t1 = query(1, 1, n, 1, x);
		LL s1 = t1.s1, s2 = t1.s2;
		ret = (ret + ((x << 1 | 1) * s1 % mod - s2 + mod) * P) % mod;
		if(x < n - x + 1) {
			ans t2 = query(1, 1, n, x + 1, n - x + 1);
			ret = (ret + t2.s0 * x % mod * (x + 1) % mod * P) % mod;
		}
		if(n - x + 2 <= n) {
			LL X = n + 1, Y = n + 2;
			ans t3 = query(1, 1, n, n - x + 2, n);
			LL s0 = t3.s0, s1 = t3.s1, s2 = t3.s2;
			ret = (ret + (X * Y % mod * s0 % mod - (X + Y) * s1 % mod + s2 + mod) % mod * P) % mod;
			LL E = n + 1, F = x - n - 1;
			ret = (ret + E * F % mod * s0 % mod + (E - F) * s1 % mod - s2 + mod * 2) % mod;
		}
	}
	else {
		ans t4 = query(1, 1, n, 1, n - x + 1);
		LL s1 = t4.s1, s2 = t4.s2;
		ret = (ret + ((x << 1 | 1) * s1 % mod - s2 + mod) % mod * P) % mod;
		LL A = n - x + 1, B = n + x + 2;
		ans t5 = query(1, 1, n, n - x + 2, x);
		LL s0 = t5.s0;
		s1 = t5.s1; s2 = t5.s2;
		ret = (ret + (A * B % mod * s0 % mod - 2 * A * s1 % mod + mod) % mod * P) % mod;
		LL S = n + 1, T = x - n - 1;
		ret = (ret + S * T % mod * s0 % mod + (S - T) * s1 % mod - s2 + mod * 2) % mod;
		if(x < n) {
			LL M = n + 1, N = n + 2;
			ans t6 = query(1, 1, n, x + 1, n);
			LL s0 = t6.s0, s1 = t6.s1, s2 = t6.s2;
			ret = (ret + (M * N % mod * s0 % mod - (M + N) * s1 % mod + s2 + mod) % mod * P) % mod;
			LL G = x - n - 1, H = n + 1;
			ret = (ret + G * H % mod * s0 % mod + (H - G) * s1 % mod - s2 + mod * 2) % mod;
		}
	}
	return ret;
}
int main() {
	P = pow(2, mod - 2);
	scanf("%lld %lld", &n, &m);
	for(LL i = 1; i <= n; i++) {
		sum[0][i] = (sum[0][i - 1] + 1) % mod;
		sum[1][i] = (sum[1][i - 1] + i) % mod;
		sum[2][i] = (sum[2][i - 1] + i * i) % mod;
	}
	build(1, 1, n);
	while(m--) {
		LL opt, l, r, x;
		scanf("%lld", &opt);
		if(opt == 1) {
			scanf("%lld %lld %lld", &l, &r, &x);
			if(l > r) swap(l, r);
			update(1, 1, n, l, r, x);
		}
		else {
			scanf("%lld %lld", &l, &r);
			printf("%lld\n", (solve(r) - solve(l - 1) + mod) % mod);
		}
	}
	return 0;
}
```

~~这下可以放心 Ctrl+C/V 了。~~

复制粘贴有意思吗？

## 总结：

1. 对于这样的二次求和题，一般从**每个数对最后答案的贡献**考虑。
1. 如果需要对同一个区间询问多次，可以仿照此题，**用一个结构体把若干个答案一次算出来**。
1. 虽说不取模见祖宗，但是**进行无意义的取模也会拖慢代码效率**！
1. 如果没有考虑 $u>v$ 会只剩下 $25$ 分，如果没有 $+mod \times 2$ 也会只剩下 $25$ 分，~~都没考虑到还剩多少分？~~

**最重要的一句话：代码写错非实弱，细节想假毁一生！**

### 后记：
本蒟蒻花了 $1.5days$ 解决这道题目，又花了 $1.5days$ 写这篇题解，希望大家能够大力支持，也欢迎各位提出宝贵的意见和建议。

~~（话说为了一道黑题推这么多式子不为过吧）~~

---

## 作者：Jμdge (赞：21)

这道题原来是个 公式化简题啊 ，话说洛咕开 O2 都跑不过 loj 是什么鬼（话说 luogu 出结果倒是比 loj 快很多，必然的嘛...）

打了好久的暴力...感受了一下自己做的话 $40$ 分已经是上限了

我们先令 S 数组记录 a 数组的前缀和，然后再让 SS 作为 a 的前缀和

然后再看看我们要求的 $ANS$，它的表达式如下：

$$ANS=\sum_{i=l}^r \sum_{j=i}^{n} S_j-S_{j-i}$$

意思就是先枚举长度 i 然后枚举左边界，前缀和相减得到数值然后全部相加

但是复杂度你看到了呗...（修改反倒还比询问快些呢）

那么我们用之前的 $SS$ 来优化这个表达式：

$$ANS=\sum_{i=l}^r SS_n-SS_{i-1}-SS_{n-i}$$

怎么变过来的？还是考虑前缀和相减吧...看个两三遍就看懂了

但是我们发现这样只是将询问的复杂度降成 $O(n)$ 了，并没有什么软用

但是这已经可以用线段树维护了啊，然后询问直接变 $O(log\ n)$

但是修改呢...

那么我们就要考虑给一个区间加上 d 时，d 对每个数的贡献了

经过一系列的推导（数学归纳法）可以得到：一个区间整体加上 d 后， SS 数组变化如下：

> 令 G(i) 表示 $\dfrac{n(n+1)}{2}$

> $\text{对于任意的}\ SS_i ∈ [l,r]\ ,\ SS_i\ \text{增加}\ \ d * G(i-l+1) $

> $\text{对于任意的}\ SS_i ∈ (r,n]\ ,\ SS_i\ \text{增加}\ \ d * G(r-l+1) + v * (i-r)(r-l+1) $

依旧是考虑贡献（鉴于读者非常聪明~~且本人太懒~~就不列出推导过程了）

再考虑一下区间贡献，代码就出来了（这个标算可不会被暴力碾...）

然后我们开开心心地在线段树上维护这些东西咯？

别急，还有一个坑点呢...藏得可深了

相信大家看完题目都会想这道题不就是对数列进行操作么，为什么题目要说成是链啊？（当然是为了坑你啊！）

我们看到 u v 是链上的两个点，所以 v 可以在 u 前面，且数据范围并没有写 u<=v ，所以...才说藏得很深嘛

如果没看出这点的话，最多 25 分

```
//by Judge
#include<bits/stdc++.h>
#define ll long long
const int M=2e5+3,mod=1e9+7;
const int inv6=166666668;
const int inv2=5e8+4;
using namespace std;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1,*p2;
#define swap(x,y) (x)^=(y)^=(x)^=(y)
template<class T>inline void ADD(T& a,T b){a+=a+b>=mod?b-mod:b;}
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[21]; int Z,C=-1;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x,char ch='\n'){
    if(C>1<<20) Ot(); if(x<0) sr[++C]='-',x=-x;
    for(;z[++Z]=x%10+48,x/=10;);
    for(;sr[++C]=z[Z],--Z;); sr[++C]=ch;
} int n,m; ll a[M<<2],b[M<<2],c[M<<2],t[M<<2],ss[M];
inline ll s1(ll n){return n>0?n*(n+1)%mod*inv2%mod:0;}
inline ll s2(ll n){return n>0?n*(n+1)%mod*(n<<1|1)%mod*inv6%mod:0;}
#define ls k<<1
#define rs k<<1|1
#define mid (l+r>>1)
#define lson ls,l,mid
#define rson rs,mid+1,r
inline void ad(int k,int l,int r,ll da,ll db,ll dc){
	(a[k]+=da)%=mod,(b[k]+=db)%=mod,(c[k]+=dc)%=mod;
	(t[k]+=(s2(r)-s2(l-1))*da%mod+(s1(r)-s1(l-1))*db%mod+(r-l+1)*dc%mod)%=mod;
}
inline void pushdown(int k,int l,int r){
	if(a[k]|b[k]|c[k]) ad(lson,a[k],b[k],c[k]),
		ad(rson,a[k],b[k],c[k]),a[k]=b[k]=c[k]=0;
}
void build(int k,int l,int r){
	if(l==r) return t[k]=ss[l],void();
	build(lson),build(rson),t[k]=(t[ls]+t[rs])%mod;
}
void update(int k,int l,int r,int L,int R,ll a,ll b,ll c){
	if(L>r||l>R) return ; if(L<=l&&r<=R) return ad(k,l,r,a,b,c);pushdown(k,l,r);
	update(lson,L,R,a,b,c),update(rson,L,R,a,b,c),t[k]=(t[ls]+t[rs])%mod;
}
ll query(int k,int l,int r,int L,int R){
	if(L>r||l>R) return 0; if(L<=l&&r<=R) return t[k];
	return pushdown(k,l,r),(query(lson,L,R)+query(rson,L,R))%mod;
}
inline void update(ll l,ll r,ll v){ ll len=r-l+1;
	update(1,0,n,l,r,inv2*v%mod,(3-2*l)*inv2%mod*v%mod,(l*l-3*l+2)%mod*inv2%mod*v%mod);
	if(r<n) update(1,0,n,r+1,n,0,len*v%mod,((len+1)*inv2%mod-r)*len%mod*v%mod);
}
inline int query(ll l,ll r){
	return (((r-l+1)*query(1,0,n,n,n)%mod-query(1,0,n,l-1,r-1)
		-query(1,0,n,n-r,n-l))%mod+mod)%mod;
}
int main(){ n=read(),m=read();
	for(int i=1;i<=n;++i) ss[i]=read(),ADD(ss[i],ss[i-1]);
	for(int i=1;i<=n;++i) ADD(ss[i],ss[i-1]); build(1,0,n); 
	for(int op,l,r,d;m;--m){
		op=read(),l=read(),r=read();
		if(l>r) swap(l,r);
		if(op&1) d=read(),update(l,r,d);
		else print(query(l,r));
	} return Ot(),0;
}


```

---

## 作者：shadowice1984 (赞：9)

话说凌晨终于卡完这道题的常数的时候真的有一股松爷附体的感觉……

第一次感觉到了信仰的力量……

另外这道题说的是链加，其实就是区间加，但是要注意的一点是因为是唯一路径，所以l，r可以是反的……如果一直在WA可以注意一下……
_________________________

# 这道题可以使用根号算法通过

## 本题题解

这道题乍一看是个线段树题……，因为区间加什么的本来就有非常好的性质可以让我们使用线段树维护它，但是由于询问十分鬼畜(所有长度在l,r的连续子段和的和)，因此我们发现线段树并不是非常的好处理修改和询问的关系……

但是注意到询问的时候总是询问了一段连续的长度区间，所以我们可以考虑把所有答案变成一个序列$\{a\}$,其中$a_{i}$表示长度恰好为i的连续子段和的和，那么我们的询问操作就变成了询问a序列的区间和，此时我们发现在原序列上的区间加将会引起a数组一系列复杂的变化……，这样线段树其实就不是非常的好做了

(情况开始变得辣手)

那么此时让我们来想两个具有启发意义的$O(n^2)$暴力

### 暴力1

如果所有询问在修改之后呢？

通过将原数组差分，我们可以$O(1)$的记录下每个修改

然后在所有修改结束之后我们可以$O(n)$的对差分数组做一遍前缀和从而还原出原序列，此时我们希望可以快速的处理出答案序列$a$这样的话我们就可以对a数组做一遍前缀和，从而$O(1)$的回答每个区间询问了

那么我们暴力的枚举左端点来求$a_{i}$应该可以得到这样一个式子,其中sum_{i}表示原数组的前缀和数组

## $a_{i}=\sum_{j=0}^{n-i}sum_{j+i}-sum{j}$

拆开Σ可以得到

## $a_{i}=\sum_{j=i}^{n}sum_{j}-\sum_{j=0}^{n-i}sum{j}$

发现我们对前缀和数组再做一遍前缀和就可以$O(1)$的计算出$a_{i}$

此时我们$O(n)$的计算出所有的$a_{i}$就可以$O(n)$的计算出$a_{i}$的前缀和

然后此时我们就可以O(n)的计算出前缀和了，然后$O(1)$回答每个询问即可

对于每个修改我们都重复一遍刚才的流程，算法复杂度$O(n^2)$显然会T飞

### 暴力2

如果修改很少呢？当然我们可以使用刚才的算法，但是我们注意到这里还有另外一个暴力，我们可以考虑每一个修改对当前的贡献，这样的话我们处理修改的时候暴力的扫一遍之前的所有的修改，累加所有的贡献就是答案了

我们假设在原数组的某个点i加1，那么我们观察答案数组a的一位j会变化多少

我们令$C_{i,j}$表示点i加1的时候答案数组的第j位的变化量

那么我们把C这个方阵打出来之后大概长这样


1 1 1 1 1 1 1

1 2 2 2 2 2 1

1 2 3 3 3 2 1

1 2 3 4 4 3 1

1 2 3 4 4 3 1

1 2 3 3 3 3 1

1 2 2 2 2 2 1

1 1 1 1 1 1 1

大概就是最外边一圈是一圈1，里面是一圈2，再里面是一圈3……这样的规律

那么我们考虑我们一个修改(l1,r1,delta)对询问(l2,r2)的贡献的时候，我们会发现这其实就是我们这个C矩阵在(l1,l2)(r1,r2)这个子矩阵的权值和再去乘上一个delta

感性理解以下就是我们把这个区间加操作看成单点加的集合，然后考虑每一个单点加对这个询问区间的贡献，然后发现这就是这个贡献矩阵的子矩阵之和乘上修改的权值delta了

所以我们会自然的想到这样一个暴力，对于每一个询问，我们暴力的考虑在它之前的询问对他的贡献，对于最开始的序列，我们直接处理出静态的解

问题来了，我们如何$O(1)$的求出这个系数矩阵的和呢？

我们首先发现这个矩阵是中心对称的，因此可以把这个子矩阵矩阵切成4块，每块按照右上角的方阵的形式来算

那么问题来了，如何快速求出右上角的一个子矩阵的和呢？

我们发现这个子矩阵的和并不是非常的好算，因此我们考虑可不可以快速的求出这个1/4方阵的二维前缀和，这样就可以快速计算出这个矩阵的子矩阵和了

那么我们不妨设这个1/4方阵的第N行第M列的二维前缀和为$F_{N,M}$，既然要求二位前缀和我们就需要了解一下第i行第j列的元素是什么，通过大胆推结论我们可以得到这个元素就是min(i,j)

所以我们发现$F_{N,M}$就是

## $\sum_{i=1}^{N}\sum_{j=1}^{M}min(i,j)$

我们不妨设M<N，那么我们可以把式子拆成这个样子

## $\sum_{i=1}^{M}\sum_{j=1}^{M}min(i,j)+\sum_{i=M+1}^{N}\sum_{j=1}^{M}min(i,j)$

然后因为min运算具有结合律，我们可以采取一个非常传统的操作，将类似于方阵的Σ形式只算一个三角部分然后乘2，最后减去对角线部分，这样我们的式子就变成了这样


### $2\sum_{i=1}^{M}\sum_{j=1}^{i}min(i,j)-\sum_{i=1}^{M}min(i,i)+\sum_{i=M+1}^{N}\sum_{j=1}^{M}min(i,j)$

然后发现3个Σ当中的j均小于i，所以min运算就被消掉了

## $2\sum_{i=1}^{M}\sum_{j=1}^{i}j-\sum_{i=1}^{M}i+(N-M)\sum_{j=1}^{M}j$

然后我们令$F_{1}(i)=\sum_{j=1}^{i}j$,$F_{2}(i)=\sum_{j=1}^{i}F_{1}(j)$
显然这两个函数都是非常好预处理或者直接利用数学公式计算的

那么我们发现最后$F(N,M)$是这样的

## $F_(N,M)=2F_{2}(M)+(N-M-1)F_{1}(M)$

至此，我们可以$O(1)$的计算前缀和了，因此我们就可以在常数事件内完成这个求子矩阵和的工作

但是到现在为止，我们只是有两个看似并无卵用的$O(n^2)$暴力，所以我们接下来要如何优化这些基本已经没有优化空间的暴力，从而让我们过掉这个$N=2×10^5,m'<10^5,m<5×10^5$的鬼畜数据呢？

## 定期重构

对，我们直接用暴力来优化暴力，当一道题有两个不同的$O(n^2)$暴力时，我们可以通过将这两个暴力结合到一起来创造一个优秀的$O(n\sqrt{n})$的暴力算法

我们发现这道题的修改操作并不是非常的多，因此我们可以使用差分数组$O(1)$的记录下每一个修改，同时将它们惰性的push到一个栈当中，每次询问的时候先使用答案数组得到一个静态的解，然后暴力的扫一遍这个栈，查询每个修改对询问的贡献，如果在一次询问开始前，发现我们已经做了超过275次操作，那么清空整个栈，直接暴力重构这个数组

听起来这个东西非常的暴力，我们冷静分析一波复杂度，会发现这个算法的复杂度大概是 $O(363n+275(m-m')+m')$的，然后分析到这里我们也不会觉得这个算法可以通过，因为这个算法实在是太像一个高分暴力了，然而其实它就是一个高分暴力，但是问题是这道题的正解的常数也不小，因此我们可以利用常数这点来成功的卡过去

所以下面要介绍的部分才是这篇乱搞AC题解的重点，卡常数！

## 卡常数

先解释一下为什么不是每根号m'(即316)次重构一次，而是采用了275这个偏小的数，另外200也可以，但是十分玄学的250并不行

因为我们仔细观察一下我们考虑询问对修改的贡献这个地方的常数，会发现是大于我们重构的复杂度的，因此我们只能尽量多的重构，具体来讲就是倾斜一下我们的重构常数，使得算法向多重构这个方向倾斜

然后我们加上了这个伪优化，发现还是t，事实上这个时候一般会有一个非常大的常数出在取膜运算上，因此我们去掉了重构函数中第一次计算ans值的取膜运算

以及查询子矩阵函数的取膜运算仅做一次，另外我们计算二维前缀和的时候仅仅在使用减法的时候才进行取膜操作，这样的话一次询问最多进行9次取模操作，而原来是21次，这个时候我们的常数就不是非常大了，可以在3600ms左右的时间通过本题

当然了这个写法有一个好处就是代码复杂度极低，全程不需要任何数据结构做支持，只需要几个简单的函数就可以完成实现了

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;const int N=2*1e5+10;typedef unsigned long long ll;
const ll mod=1e9+7;const int M=200;ll del[N];ll sum[N];ll ans[N];int n;int m;//这里的M采用了200
int ml[N];int mr[N];ll val[N];ll f1[N];ll f2[N];int tp;int mid;
inline void rebuild()//重构函数，对差分数组做3遍前缀和，构造ans
{
    for(int i=1;i<=n;i++)sum[i]=(sum[i-1]+del[i])%mod;
    for(int i=1;i<=n;i++)(sum[i]+=sum[i-1])%=mod;
    for(int i=1;i<=n;i++)(sum[i]+=sum[i-1])%=mod;//省了一个取膜
    for(int i=1;i<=n;i++)ans[i]=sum[n]+mod-sum[i-1]+mod-sum[n-i];
    for(int i=1;i<=n;i++)(ans[i]+=ans[i-1])%=mod;
}
inline ll sqrs(int a,int b)//查询二维前缀和
{if(a<b)swap(a,b);return (a==b)?2*f2[b]+mod-f1[b]:2*f2[b]+(a-b-1)*f1[b];}
inline ll subquery(int xl,int xr,int dl,int dr)//1/4矩阵查询，优化两个取膜
{return sqrs(xl,dl)+sqrs(xr,dr)+mod-sqrs(xr,dl)%mod+mod-sqrs(xl,dr)%mod;}
inline ll query(int xl,int xr,int dl,int dr)//矩阵查询，切成4份
{
	//减少了4次取膜运算
    ll ret=0;int cxl=n-max(xl,mid);int cxr=min(xr,mid);
    int cdl=n-max(dl,mid);int cdr=min(dr,mid);
    if(xl<=mid&&dl<=mid)ret+=subquery(xl,cxr,dl,cdr);
    if(xl<=mid&&mid<dr)ret+=subquery(xl,cxr,n-dr,cdl);
    if(mid<xr&&dl<=mid)ret+=subquery(n-xr,cxl,dl,cdr);
    if(mid<xr&&mid<dr)ret+=subquery(n-xr,cxl,n-dr,cdl);
    return ret%mod;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)f1[i]=(f1[i-1]+i)%mod;//预处理f数组减少常数
    for(int i=1;i<=n;i++)f2[i]=(f2[i-1]+f1[i])%mod;
    for(int i=1;i<=n;i++)scanf("%lld",&del[i]);
    for(int i=n;i>=1;i--)(del[i]+=mod-del[i-1])%mod;
    rebuild();mid=n/2;
    for(int i=1,t,l,r;i<=m;i++)
    {
        scanf("%d",&t);
        if(t==1)//惰性的加入到栈中
        {
            ++tp;scanf("%d%d%lld",&ml[tp],&mr[tp],&val[tp]);
            if(ml[tp]>mr[tp]){swap(ml[tp],mr[tp]);}//注意判掉这种情况
            (del[ml[tp]]+=val[tp])%=mod;(del[mr[tp]+1]+=mod-val[tp])%=mod;//使用差分数组记录修改
        }
        else
        {
            int l;int r;ll ret=0;scanf("%d%d",&l,&r);//先处理出静态的解
            if(tp>=M){tp=0;rebuild();}ret=(ans[r]+mod-ans[l-1])%mod;
            for(int i=1;i<=tp;i++)(ret+=val[i]*query(ml[i]-1,mr[i],l-1,r))%=mod;//暴力考虑修改对询问的贡献
            printf("%lld\n",ret);
        }
    }return 0;//拜拜程序~
}

```






















---

## 作者：Sai0511 (赞：7)

一道挺好的数据结构题。  
先用数学式子把题目里要求的答案表示出来，设$S_i=\sum_{j=1}^{i}a_j$：
$$\text{ans}=\sum_{i=l}^{r}\sum_{j=i}^{n}S_j-S_{j-i}$$
$$\text{ans=}\sum_{j=l}^{r}(\sum_{j=i}^{n}S_j-\sum_{j=0}^{n-i}S_j)$$
然后设$SS_i=\sum_{j=1}^{i}S_i$  
于是
$$\text{ans}=\sum_{j=l}^{r}(SS_n-SS_{i-1}-SS_{n-i})$$
$$\text{ans}=(r-l+1)SS_{n}-\sum_{i=l-1}^{r-1}SS_i-\sum_{i=n-r}^{n-l}SS_i$$
这个东西可以直接用线段树维护，复杂度一个$\text{log}$，接着考虑修改。  
如果修改的区间是$[l,r,d]$的话，那么它对$SS_i(i\in [1,n])$的影响就是：   
$1:i\in[1,l)$，无影响。  
$2:i\in[l,r]$，因为$a_i(i\in[l,r])$增加了$\text{d}$，所以$S_i(i\in[l,r])$相当于增加了$i-l+1$个$\text{d}$，所以$SS_i$就增加了$\sum_{j=1}^{i}d*(j-l+1)$  
$3:i \in(r,n]$，我们可以想象一下，在$>d$之后$SS_i$的增加就固定了，所以再加上前面的贡献就是$\sum_{j=l}^{r}d*(j-l+1)+(i-r)*d*(r-l+1)$  
然后可以把这两个式子化成一个关于$i$的二次函数形式（这一步上了小学的人应该都会，这里就略去了），可以在线段树上维护这个二次函数的$\text{a,b,c}$值，这道题就做完了。   
所以除了代码细节多多多多多多多多之外也没有什么特别恶心的地方。（顺便提个醒，这题的屑数据还会出现$l>r$，要判掉）。  
### My Code
```cpp
#include <bits/stdc++.h> 

typedef long long ll;
const int mod = 1e9 + 7;
const int inv2 = 5e8 + 4;
const int N = 2e5 + 10;
int n, m, i, j, k;  
int s[N], ss[N], sum[N << 2], a[N];
int sa[N << 2], sb[N << 2], sc[N << 2];
inline int add(int a, int b) { ll c = a + b; if (c < 0) c += mod; return c >= mod ? c - mod : c; }
struct tag {
  int a, b, c; 
  tag() { a = b = c = 0; } 
  tag(int _a, int _b, int _c) { a = _a, b = _b, c = _c; }
  inline void init() {
    a = add(a, 0);
    b = add(b, 0);
    c = add(c, 0);
  }
} laz[N << 2], mdy;
inline void down(int u, tag t) { 
  int a = t.a, b = t.b, c = t.c;
  sum[u] = add(add(add(sum[u], 1ll * a * sa[u] % mod), 1ll * b * sb[u] % mod), 1ll * sc[u] * c % mod);  
  laz[u].a = add(laz[u].a, a); 
  laz[u].b = add(laz[u].b, b);
  laz[u].c = add(laz[u].c, c);  
}
inline void push_down(int u) {
  if (laz[u].a || laz[u].b || laz[u].c) {
    down(u << 1, laz[u]);
    down(u << 1 | 1, laz[u]);
    laz[u] = tag(0, 0, 0);
  }
}
void build(int l, int r, int u) {
  if (l == r) {
    sum[u] = ss[l], sc[u] = 1, sb[u] = l, sa[u] = 1ll * l * l % mod;
    return;
  }
  int mid = (l + r) >> 1;
  build(l, mid, u << 1);
  build(mid + 1, r, u << 1 | 1);
  sum[u] = add(sum[u << 1], sum[u << 1 | 1]);
  sa[u] = add(sa[u << 1], sa[u << 1 | 1]);
  sb[u] = add(sb[u << 1], sb[u << 1 | 1]);
  sc[u] = add(sc[u << 1], sc[u << 1 | 1]);
  return;
}
void modify(int ml, int mr, int l, int r, int u) {
  if (ml <= l && r <= mr) { down(u, mdy); return; }
  int mid = (l + r) >> 1;
  push_down(u);    
  if (ml <= mid) modify(ml, mr, l, mid, u << 1);
  if (mid < mr)  modify(ml, mr, mid + 1, r, u << 1 | 1);
  sum[u] = add(sum[u << 1], sum[u << 1 | 1]); 
}
int query(int ql, int qr, int l, int r, int u) {    
  if (ql > qr) return 0; if (ql > r || qr < l) return 0;  
  if (ql <= l && r <= qr) return sum[u];
  push_down(u);
  int mid = (l + r) >> 1, res = 0;
  if (ql <= mid) res = add(res, query(ql, qr, l, mid, u << 1));
  if (mid < qr)  res = add(res, query(ql, qr, mid + 1, r, u << 1 | 1));
  return res;
}

int main() {
 scanf("%d %d", &n, &m);
  for (int i = 1; i <= n; i++) scanf("%d", a + i), s[i] = add(s[i - 1], a[i]), ss[i] = add(ss[i - 1], s[i]);
  build(1, n, 1);
  for (int i = 1, opt, l, r, z; i <= m; i++) {
    scanf("%d %d %d", &opt, &l, &r);
    if (l > r) std::swap(l, r);  
    if (opt == 1) {
      scanf("%d", &z); int len = r - l + 1, a = (ll)z * inv2 % mod;
      mdy = tag(a, (ll)a * (3 - 2 * l + mod) % mod,((ll)l * l - 3 * l + 2) % mod * a % mod);
      modify(l, r, 1, n, 1);   
      if (r == n) continue;
      mdy = tag(0, (ll)len * z % mod, ((ll)len * (len + 1) / 2 % mod * z % mod - (ll)len * r % mod * z % mod + mod) % mod);
      modify(r + 1, n, 1, n, 1);      
    } else {
      int len = r - l + 1;
      ll ans = ((ll)len * query(n, n, 1, n, 1) % mod - query(std::max(l - 1, 1), r - 1, 1, n, 1) + mod - query(std::max(n - r, 1), n - l, 1, n, 1) + mod) % mod;
      printf("%lld\n", ans);      
    }
  }
  return 0;
}
```


---

## 作者：Y_B_X (赞：5)

[原题链接](https://www.luogu.com.cn/problem/P4458)

>题意：  
维护一个序列，支持区间加，  
以及查询所有长度在 $[l,r]$ 范围内的子区间权值和 之和。

由于是区间加，容易想到差分，设 $\displaystyle a_i=\sum\limits_{j=1}^it_j$。

再设 $\displaystyle A_1(m)=\sum\limits_{i=1}^ma_i\ ,A2(m)=\sum\limits_{i=1}^mA1(i)\ ,A3(m)=\sum\limits_{i=1}^mA2(i)$。

把查询的东西写出来，枚举长度，起始位置：

$$\sum\limits_{k=l}^r\ \sum\limits_{i=1}^{n-k+1}\ \sum\limits_{j=i}^{i+k-1}a_j=\sum\limits_{k=l}^r\ \sum\limits_{i=1}^{n-k+1}A_1(i+k-1)-A_1(i-1)$$
$$=\sum\limits_{k=l}^r\ \sum\limits_{i=k}^nA_1(i)-\sum\limits_{k=l}^r\sum\limits_{i=0}^{n-k}A_1(i)=\sum\limits_{k=l}^rA_2(n)-A_2(k-1)-A_2(n-k)$$
$$=(r-l+1)A_2(n)-A_3(r-1)+A_3(l-2)-A_3(n-l)+A_3(n-r-1)$$

这就是说，只需要能实时求出 $A_3(i)$ 与 $A_2(i)$，问题就能轻松解决。

但由于维护的只是个差分数组，维护 $A_2(i)$ 与 $A_3(i)$ 就相当于维护 $3$ 阶前缀和以及 $4$ 阶前缀和。

然后可以手推一下式子（只需交换一下求和顺序，然后大量的运算）：

设 $\displaystyle S_x(m)=\sum\limits_{i=1}^mi^xt_i$

$$\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{i}\sum\limits_{k=1}^{j}t_k=\dfrac{1}{2}\Big((m+1)(m+2)S_{0}(m)-(2m+3)S_1(m)+S_2(m)\Big)$$

$$\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{i}\sum\limits_{k=1}^{j}\sum\limits_{r=1}^{k}t_r=\dfrac{1}{6}\Big((m+1)(m+2)(m+3)S_0(m)-(3m^2+12m+11)S_1(m)+(3m+6)S_2(m)-S_3(m)\Big)$$

而关于 $S_x(m)$ 的维护，树状数组是十分便捷的。

然后就可以过了这题：[代码](https://www.luogu.com.cn/paste/1bfv6e19)。

但不应仅仅止步于此，上面的 $3$ 阶前缀和与 $4$ 阶前缀和都有一个规律：

+ 最初括号外的系数是阶乘形式。
+ $S0(m)$ 的系数都是 $m+1$ 的一个上升幂，符号为正。
+ $S1(m)$ 的系数都是 $S0(m)$ 的系数不看一项求和得到，符号为负。
+ $S2(m)$ 的系数都是 $S0(m)$ 的系数不看两项求和得到，符号为正。

$\dots$

于是尝试证明一个关于 $k+1$ 阶前缀和的式子：

$$\sum\limits_{i_1=0}^n\sum_{i_2=0}^{i_1}\dots\sum_{i_{k+1}=0}^{i_k}t_{i_{k+1}}=\dfrac{1}{k!}\sum\limits_{j=0}^{k}(-1)^jS_j(n)\dfrac{\mathrm{d}^j (n+1)^{\overline{k}}}{\mathrm{d}^j n}\dfrac{1}{j!}$$

后面那个 $\displaystyle \dfrac{\mathrm{d}^j(n+1)^{\overline{k}}}{\mathrm{d}^jn}\dfrac{1}{j!}$ 就相当于 $(n+1)^{\overline{k}}$ 不看 $j$ 项后求和。

$\text{Prove:}$

$$\dfrac{1}{k!}\sum\limits_{j=0}^{k}(-1)^jS_j(n)\dfrac{\mathrm{d}^j (n+1)^{\overline{k}}}{\mathrm{d}^j n}\dfrac{1}{j!}$$
$$=\dfrac{1}{k!}\sum\limits_{j=0}^{k}\dfrac{(-1)^j}{j!}\sum\limits_{r=0}^{n}r^jt_r\sum
\limits_{s}\left[\begin{matrix}k\\s\end{matrix}\right]\dfrac{\mathrm{d}^j(n+1)^s}{\mathrm{d}^jn}$$
$$=\dfrac{1}{k!}\sum_{j=0}^{k}\dfrac{(-1)^j}{j!}\sum\limits_{r=0}^{n}r^jt_r\sum\limits_{s}\left[\begin{matrix}k\\s\end{matrix}\right]s^{\underline{j}}(n+1)^{s-j}$$
$$=\dfrac{1}{k!}\sum\limits_{r=0}^{n}t_r\sum\limits_{s}\left[\begin{matrix}k\\s\end{matrix}\right](n+1)^{s}\sum\limits_{j=0}^{k}\binom{s}{j}(-r)^j(n+1)^{-j}$$
$$=\dfrac{1}{k!}\sum\limits_{r=0}^{n}t_r\sum\limits_{s}\left[\begin{matrix}k\\s\end{matrix}\right](n+1-r)^s$$
$$=\dfrac{1}{k!}\sum_{r=0}^nt_r(n+1-r)^{\overline{k}}$$
$$=\sum\limits_{r=0}^{n}\binom{n+k-r}{k}t_r$$

设 $\ \displaystyle\sum_{n\geq 0}t_nx^n=T(x)$，则有：
$$\sum\limits_{n\geq 0}x^n\sum\limits_{r=0}^n\binom{n+k-r}{k}t_r=T(x)\sum\limits_{n\geq 0}\binom{n+k}{k}x^n=\dfrac{1}{(1-x)^{k+1}}T(x)$$
最后的式子就是 $T(x)$ 的 $k+1$ 阶前缀和。

于是对于 $k$ 阶动态的前缀和，维护 $k$ 个树状数组就能在 $O(k\log n)$ 的时间内单次处理询问与修改，复杂度优异。

---

## 作者：dtcxzyw (赞：5)

这题确实是道好题（~~我想了三个晚上~~）。

我们可以写出一个系数矩阵，其中第i行第j列为第j个结点对长度为i的链的贡献。

n==5时矩阵如下：

||||||
|:--:||:--:||:--:||:--:||:--:|
| 1 | 1 | 1 | 1 | 1 |
| 1 |2 |2 | 2 | 1 |
| 1 | 2 | 3 | 2 | 1 |
| 1 | 2 | 2 | 2 | 1 |
| 1 | 1 | 1 | 1 | 1 |

然后我就联想到了点到矩阵中心的切比雪夫距离（其实和它并没有什么关系），~~又联想到了转为曼哈顿距离~~。

**做法1**：我们可以O(1)计算系数矩阵的子矩阵和然后O((m-m')(m'+n))计算每个修改对查询的贡献；

**做法2**：使用二维线段树维护（会爆空间）；

**做法3**：使用vector存储lazy标记，可参考[R6883986 评测详情](https://www.luogu.org/record/show?rid=6883986)，最后因为throw std::bad_alloc而RE;

**我的AC做法（非正解）**：

首先，我们发现这个矩阵是**中心对称**的。所以可以把它切成四个子矩阵，并把每个矩阵的1旋转到左上角，这样只要对于每个矩阵进行相同的操作即可。

我们直接维护所有长度为i的链的权值和之和，query与普通线段树相同。

下表是一个分割后的矩阵，其权值从左上到右下递增：

||||||
|:--:||:--:||:--:||:--:||:--:|
| 1 | 1 | 1 | 1 | 1 |
| 1 |2 |2 | 2 | 2 |
| 1 | 2 | 3 | 3 | 3 |
| 1 | 2 | 3 | 4 | 4 |
| 1 | 2 | 3 | 4 | 5 |

修改l~r意味着将第l列至第r列的所有数+d***每个位置的系数**

为了简便，可把$[l,r]+=d$转换为$[1,l-1]-=d,[1,r]+=d$

考虑矩阵所有行前$x$列系数和之差，可以发现对于前i行，系数和之差每增加一行就会减少1，之后每行的系数和相等。

据此可以推出第$n$行前$x$列系数和：

$c[n]=\sum_{i=1}^{min(n,x)}x+1-i$

展开后得

$c[n]=\begin{cases}n(x+\frac{1}{2})-\frac{1}{2}n^2,\quad n\leq x\\x(x+1), \quad n>x\end{cases}$

对于常数项，一次项，二次项，都用线段树维护即可。

最后附上常数超大的代码（28900ms,估计是初始化时使用modify代替build的缘故）

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
int read(){
    int res=0,c;
    do c=getchar();
    while(c<'0'||c>'9');
    while('0'<=c&&c<='9'){
        res=res*10+c-'0';
        c=getchar();
    }
    return res;
}
const int size=100005,mod=1000000007;
const long long inv2=500000004;
struct Block{
    int bx,ex,by,ey,siz;
    int sum[size<<2],lazy[size<<2][3],weight1[size<<2],weight2[size<<2];
    Block(){
        memset(sum,0,sizeof(sum));
        memset(lazy,0,sizeof(lazy));
    }
    #define ls l,m,id<<1
    #define rs m+1,r,id<<1|1
    void pre(int l,int r,int id){
    	if(l==r){
    		weight1[id]=l;
    		weight2[id]=static_cast<long long>(l)*l%mod;
    	}
    	else{
    		int m=(l+r)>>1;
    		pre(ls);
    		pre(rs);
    		weight1[id]=(weight1[id<<1]+weight1[id<<1|1])%mod;
    		weight2[id]=(weight2[id<<1]+weight2[id<<1|1])%mod;
    	}
    }
    void color0(int l,int r,int id,int val){
    	sum[id]=(sum[id]+static_cast<long long>(r-l+1)*val)%mod;
        lazy[id][0]=(lazy[id][0]+val)%mod;
    }
    void color1(int l,int r,int id,int val){
    	sum[id]=(sum[id]+static_cast<long long>(weight1[id])*val)%mod;
        lazy[id][1]=(lazy[id][1]+val)%mod;
    }
    void color2(int l,int r,int id,int val){
        sum[id]=(sum[id]+static_cast<long long>(weight2[id])*val)%mod;
        lazy[id][2]=(lazy[id][2]+val)%mod;
    }
    void push(int l,int r,int m,int id){
        if(lazy[id][0]){
            color0(ls,lazy[id][0]);
            color0(rs,lazy[id][0]);
            lazy[id][0]=0;
        }
        if(lazy[id][1]){
            color1(ls,lazy[id][1]);
            color1(rs,lazy[id][1]);
            lazy[id][1]=0;
        }
        if(lazy[id][2]){
            color2(ls,lazy[id][2]);
            color2(rs,lazy[id][2]);
            lazy[id][2]=0;
        }
    }
    int query(int l,int r,int id,int nl,int nr){
        if(nl<=l && r<=nr)return sum[id];
        else{
            int m=(l+r)>>1;
            push(l,r,m,id);
            int res=0;
            if(nl<=m)res+=query(ls,nl,nr);
            if(m<nr)res+=query(rs,nl,nr);
            return res%mod;
        }
    }
    void modify0(int l,int r,int id,int p,int val){
    	if(p<=l)color0(l,r,id,val);
        else{
            int m=(l+r)>>1;
            push(l,r,m,id);
            if(p<=m)modify0(ls,p,val);
            modify0(rs,p,val);
            sum[id]=(sum[id<<1]+sum[id<<1|1])%mod;
        }
    }
    void modify1(int l,int r,int id,int p,int val){
    	if(r<=p)color1(l,r,id,val);
        else{
            int m=(l+r)>>1;
            push(l,r,m,id);
            modify1(ls,p,val);
            if(m<p)modify1(rs,p,val);
            sum[id]=(sum[id<<1]+sum[id<<1|1])%mod;
        }
    }
    void modify2(int l,int r,int id,int p,int val){
        if(r<=p)color2(l,r,id,val);
        else{
            int m=(l+r)>>1;
            push(l,r,m,id);
            modify2(ls,p,val);
            if(m<p)modify2(rs,p,val);
            sum[id]=(sum[id<<1]+sum[id<<1|1])%mod;
        }
    }
    void doModifyImpl(int p,int val){
    	modify1(1,siz,1,p,val*(p+1-inv2)%mod);
    	modify2(1,siz,1,p,-val*inv2%mod);
    	if(p+1<=ey-by+1)modify0(1,siz,1,p+1,(static_cast<long long>(p)*(p+1)>>1)%mod*val%mod);
    }
    void doModify(int l,int r,int val){
        doModifyImpl(r,val);
    	if(l-1)doModifyImpl(l-1,-val);
    }
    int doQuery(int l,int r){
        return query(1,siz,1,l,r);
    }
} T[2][2];
void doModify(int n,int l,int r,int val){
    for(int i=0;i<2;++i){
        for(int j=0;j<2;++j){
            int ibx=std::max(l,T[i][j].bx);
            int iex=std::min(r,T[i][j].ex);
            if(ibx<=iex)
                T[i][j].doModify(i?n-iex+1:ibx,i?n-ibx+1:iex,val);
        }
    }
}
int doQuery(int n,int l,int r){
    int res=0;
    for(int i=0;i<2;++i){
        for(int j=0;j<2;++j){
            int iby=std::max(l,T[i][j].by);
            int iey=std::min(r,T[i][j].ey);
            if(iby<=iey)
                res=(res+T[i][j].doQuery(j?n-iey+1:iby,j?n-iby+1:iey))%mod;
        }
    }
    return (res+mod)%mod;
}
int main(){
    int n=read();
    int mid=(n+1)>>1;
    for(int i=0;i<2;++i)
        for(int j=0;j<2;++j){
            T[i][j].bx=(i?mid+1:1);
            T[i][j].ex=(i?n:mid);
            T[i][j].by=(j?mid+1:1);
            T[i][j].ey=(j?n:mid);
            T[i][j].siz=T[i][j].ey-T[i][j].by+1;
            T[i][j].pre(1,T[i][j].siz,1);
        }
    int m=read();
    for(int i=1;i<=n;++i)
        doModify(n,i,i,read());
    for(int i=0;i<m;++i){
        int op=read();
        int l=read();
        int r=read();
        if(op==1){
            if(l>r)std::swap(l,r);
            int d=read();
            doModify(n,l,r,d);
        }
        else printf("%d\n",doQuery(n,l,r));	
    }
    return 0;
}

```


---

## 作者：WeLikeStudying (赞：4)

- 感谢[奆佬](https://www.luogu.com.cn/user/371852)，[奆佬](https://www.luogu.com.cn/user/58705)，[奆佬](https://www.luogu.com.cn/user/283913)的提醒，祝愿其信息学之路光芒璀璨。
- 有同志觉得这样做并没有必要，不过我其实只是想增加对差分与前缀和的了解而已，愚蠢的事情，我早已做过很多，不必怕多这一。

**qwq 1**
- 树状数组维护单点修改，求 $k$ 阶前缀和。
- 设 $f(n)$ 的 $k$ 阶前缀和为 $\sigma^kf(n)$。
$$\sigma^kf(n)=\sum_{i=0}C(k+i-1,k-1)f(n-i)$$
- 容易根据组合意义（或推式子）归纳证明，你会发现 $C(k+i-1,k-1)$ 是一个关于 $i$ 的 $k$ 次多项式，直接代入换成 $C(k-(n-i)+n-1,k-1)$，然后你发现它也是一个关于 $n-i$ 的多项式，且对于单独的 $n$，各项系数固定，且我们可以一开始 $O(nk^2)$ 预处理各项系数。
- 那么现在我们的任务只剩下分别维护 $n^if(n)$ 的前缀和了对吧，强行树状数组分别维护即可，总的复杂度应该是 $O(nk^2+qk\log n)$，[代码实现](https://www.luogu.com.cn/paste/lva6iyhq)。~~不如根号~~。

**qwq 2**
- 维护单点修改，求 $k$ 阶差分。
- 设 $f(n)$ 的 $k$ 阶差分为 $\delta^kf(n)$。
$$\delta^kf(n)=\sum_{i=0}C(k,i)(-1)^{k-i}f(n+i)$$
- 这玩意你要树状数组？直接暴力更新复杂度就有 $O(nk+qk)$，直接略去。

**qwq 3**
- 用多项式似乎可以快速求出一个数组的 $k$ 阶差分或前缀和（在 $k$ 很大时），~~原因已经被你看到了~~。

**[水题](https://www.luogu.com.cn/problem/P4458)**
- 不知道怎么变黑的，做完了就把它降紫。
- 假设我们区间加直接对数组 $f$ 进行维护，那么我们相当于查询：
$$\sum_{i=l}^r\sum_{j=1}^{n-i+1}\sum_{k=j}^{j+i-1}f(k)$$
- 利用[这题](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/lgjoid1t2-li-shi)的做法，我们可以将问题化为：
$$\sum_{i=l}^r\sum_{j=1}^{n-i+1}\sigma f(j+i-1)-\sigma f(j-1)$$
$$\sum_{i=l}^r\sigma^2 f(n)-\sigma^2 f(i-1)-\sigma^2 f(n-i)$$
$$(r-l+1)\sigma^2 f(n)-\sigma^3 f(r-1)+\sigma^3 f(l-2)-\sigma^3 f(n-l)+\sigma^3f(n-r-1)$$
- 强行设差分数组 $g(n)=f(n)-f(n-1)$，我们要求的：
$$(r-l+1)\sigma^3 g(n)-\sigma^4 g(r-1)+\sigma^4 g(l-2)-\sigma^4 g(n-l)+\sigma^4g(n-r-1)$$
- 因此我们的问题即为单点修改，查询单点的四次前缀和~~还是不如根号~~，[代码实现](https://www.luogu.com.cn/paste/96fl6zj2)。

---

## 作者：FreeTimeLove (赞：3)

## 一、题意

给定一个序列，要求支持区间加，查询序列长度属于 $[l,r]$ 的**子段和之和** $S$。

区间修改的左右端点**不保证** $l\le r$（给定链）。

## 二、思路

线段树基础加~~快乐~~推式子题。

我们设 $pre_1(x)=\sum_{i=1}^x a_i$，$pre_2(x)=\sum_{i=1}^x pre_1(x)$，
$pre_3(x)=\sum_{i=1}^x pre_2(x)$。

对于子段和之和 $S$，可以得到
$$
S=\sum_{x=l}^r\sum_{i=x}^n\sum_{j=i-x+1}^i a_j
$$
$$
=\sum_{x=l}^r\sum_{i=x}^n(pre_1(i)-pre_1(i-x))
$$
$$
=\sum_{x=l}^r(\sum_{i=x}^npre_1(i)-\sum_{i=x}^{n}pre_1(i-x))
$$
$$
=\sum_{x=l}^r(pre_2(n)-pre_2(x-1)-\sum_{i=0}^{n-x}pre_1(i))
$$
$$
=\sum_{x=l}^r(pre_2(n)-pre_2(x-1)-pre_2(n-x))
$$
$$
=(r-l+1)pre_2(n)-\sum_{i=l-1}^{r-1}pre_2(i)-\sum_{i=n-r}^{n-l}pre_2(i)
$$
$$
=(r-l+1)\times pre_2(n)-pre_3(r-1)+pre_3(l-2)-pre_3(n-l)+pre_3(n-r-1)
$$

那么我们只需求 $pre_2$ 与 $pre_3$。

设 $S_0(x)=\sum_{i=1}^x a_i$，$S_1(x)=\sum_{i=1}^x a_i\cdot i$，$S_2(x)=\sum_{i=1}^x a_i\cdot i^2$。

发现
$$
pre_2(x)=\sum_{i=1}^x \sum_{j=1}^i a_j=\sum_{i=1}^xa_i\cdot (x+1-i)
$$
$$
=(x+1)\cdot\sum_{i=1}^xa_i-\sum_{i=1}^xa_i\cdot i
$$
$$
=(x+1)\cdot S_0(x)-S_1(x)
$$
$$
pre_3(x)=\sum_{i=1}^x \sum_{j=1}^i\sum_{k=1}^j a_k=\sum_{i=1}^x\sum_{j=1}^i a_j\cdot(i+1-j)
$$
$$
=\sum_{j=1}^x a_j\cdot\sum_{i=j}^x(i+1-j)
=\sum_{j=1}^x a_j\cdot\sum_{i=1}^{x-j+1}i
$$
$$
=\sum_{j=1}^xa_j\cdot \dfrac{(x-j+1)(x-j+2)}{2}
$$
$$
=\dfrac 12\sum_{j=1}^x a_j\cdot(j^2-(2x+3)j+(x+1)(x+2))
$$
$$
=\dfrac 12(S_2(x)-(2x+3)\cdot S_1(x)+(x+1)(x+2)\cdot S_0(x))
$$

我们只需维护 $S_0,S_1,S_2$ 即可。对于 $a_i$，在 $S_1,S_2$ 中所乘的 $i,i^2$ 是**固定**的，因此我们可以预处理 $i,i^2$ 的前缀和，在 pushdown 时求出区间 $i,i^2$ 的和并更新 $S_1,S_2$。

注意及时取模。

### AC code

```cpp
//written_by_FTL
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<vector>
#include<map>
#define ll long long
#define LD long double
#define i7 __int128
#define re return
using namespace std;
const int N=2e5+5;
int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	re f?-ans:ans;
}
int n,m;
ll l,r,pre1[N],pre2[N],ans,mod=1e9+7;
char s[3];
ll a[N];
void MD(ll &x){//取模
	if(x>=mod)x-=mod;
}
namespace SGT{
	#define vl v<<1
	#define vr v<<1|1
	#define t d[v]
	#define tl d[vl]
	#define tr d[vr]
	#define z lz[v]
	#define zl lz[vl]
	#define zr lz[vr]
	#define mid ((l+r)>>1)
	struct data{
		int l,r;ll s[3];
	}d[N<<2];
	struct lazy{
		ll x;
	}lz[N<<2];
	void pu(int v){
		t.s[0]=tl.s[0]+tr.s[0];
		t.s[1]=tl.s[1]+tr.s[1];
		t.s[2]=tl.s[2]+tr.s[2];
		MD(t.s[0]),MD(t.s[1]),MD(t.s[2]);
	}
	void pd(int v){
		if(z.x==0)re;
		zl.x+=z.x,zr.x+=z.x;
		MD(zl.x),MD(zr.x);
		tl.s[0]=(tl.s[0]+z.x*(tl.r-tl.l+1))%mod;
		tr.s[0]=(tr.s[0]+z.x*(tr.r-tr.l+1))%mod;
		tl.s[1]=(tl.s[1]+z.x*(pre1[tl.r]-pre1[tl.l-1]+mod))%mod;
		tr.s[1]=(tr.s[1]+z.x*(pre1[tr.r]-pre1[tr.l-1]+mod))%mod;
		tl.s[2]=(tl.s[2]+z.x*(pre2[tl.r]-pre2[tl.l-1]+mod))%mod;
		tr.s[2]=(tr.s[2]+z.x*(pre2[tr.r]-pre2[tr.l-1]+mod))%mod;
		z.x=0;
	}
	void bd(int l,int r,int v){
		t.l=l,t.r=r,z.x=0;
		if(l==r){
			t.s[0]=a[l];
			t.s[1]=a[l]*l%mod;
			t.s[2]=t.s[1]*l%mod;
			re;
		}
		bd(l,mid,vl),bd(mid+1,r,vr);
		pu(v);
	}
	ll qry(int l,int r,int v,int p){//更新
		if(t.l>=l&&t.r<=r)re t.s[p];
		pd(v);
		re (tl.r>=l?qry(l,r,vl,p):0ll)+(tr.l<=r?qry(l,r,vr,p):0ll);
	}
	void ud(int l,int r,int v,ll k){//修改
		if(t.l>=l&&t.r<=r){
			t.s[0]=(t.s[0]+k*(t.r-t.l+1))%mod;
			t.s[1]=(t.s[1]+k*(pre1[t.r]-pre1[t.l-1]+mod))%mod;
			t.s[2]=(t.s[2]+k*(pre2[t.r]-pre2[t.l-1]+mod))%mod;
			z.x+=k;MD(z.x);re;
		}
		pd(v);
		if(tl.r>=l)ud(l,r,vl,k);
		if(tr.l<=r)ud(l,r,vr,k);
		pu(v);
	}
	#undef t
	#undef mid
}
ll P2(){//pre2(n)
	ll tmp=SGT::qry(1,n,1,0)%mod;
	re (tmp*(n+1)-SGT::qry(1,n,1,1)%mod+mod)%mod;
}
ll P3(int x){//pre3
	if(x<=0)re 0;
	ll tmp=(SGT::qry(1,x,1,2)-SGT::qry(1,x,1,1)%mod*(x+x+3)+SGT::qry(1,x,1,0)%mod*(x+1)%mod*(x+2))%mod;
	re (tmp*500000004%mod+mod)%mod;
}
int main(){
	n=rd(),m=rd();
	for(int i=1;i<=n;i++)a[i]=rd();
	SGT::bd(1,n,1);
	for(ll i=1;i<=n;i++)pre1[i]=(pre1[i-1]+i)%mod;  //i 前缀和
	for(ll i=1;i<=n;i++)pre2[i]=(pre2[i-1]+i*i)%mod;//i^2 前缀和
	for(int i=1;i<=m;i++){
		if(rd()==1){
			l=rd(),r=rd();
			if(l>r)swap(l,r);
			SGT::ud(l,r,1,rd());
		}
		else{
			l=rd(),r=rd();
			if(l>r)swap(l,r);
			ans=P2()*(r-l+1)-P3(r-1)+P3(l-2)-P3(n-l)+P3(n-r-1);
			printf("%lld\n",(ans%mod+mod)%mod);
		}
	}
	re 0;
}
```

### $\text{The End.}$


---

## 作者：Feyn (赞：3)

[link](https://www.luogu.com.cn/problem/P4458)

首先处理那个奇怪的询问操作。我们可以对于那个奇怪的东西进行暴力推式：

$$ans(l,r)=\sum\limits_{len=l}^r\sum\limits_{i=1}^{m-len+1}\sum\limits_{j=i}^{i+len-1}{a_j}$$

用前缀和搞一下就是

$$\sum\limits_{len=l}^r\sum\limits_{i=1}^{m-len+1}{sum_{i+len-1}-sum_{i-1}}$$

分离一下

$$\sum\limits_{len=l}^r{(\sum\limits_{i=len}^m{sum_i}-\sum\limits_{i=0}^{m-len}sum_i)}$$

发现它似乎仍然具有前缀和的性质，考虑搞个前缀和的前缀和（我把它叫做 $su$ 数组，为 $sum$ 数组的前缀和）：

$$\sum\limits_{len=l}^r{su_{m}-su_{len-1}-su_{m-len}}$$

展开：

$$su_m\times(r-l+1)-\sum\limits_{i=l-1}^{r-1}su_i-\sum\limits_{i=m-r}^{m-l}{su_i}$$

于是那个奇怪的询问就变成了单纯的对于 $su$ 数组的区间和查询。

按照思考此类问题的惯常方法，考虑假如我们给 $[l,r]$ 中的数都加了一个 $a$ ,会发生些什么？

$$\Delta sum_i=\begin{cases}0&i\in[1,l-1]\\d\times(i-l+1)&i\in[l,r]\\d\times(r-l+1)&i\in[r+1,m]\end{cases}$$

同样可以得出,为了方便表述，假如令 $s(i)=i\times(i+1)/2$ 那么：

$$\Delta su_i=\begin{cases}0&i\in[1,l-1]\\d\times s(i-l+1)&i\in[l,r]\\d\times s(r-l+1)+d\times(r-l+1)\times(i-r)&i\in[r+1,m]\end{cases}$$

开心地发现 $i\in[1,l-1]$ 部分不用管，所以对于剩下的两个部分进行处理。首先是 $i\in[r+1,M]$ 部分，令 $len=r-l+1$ 。

$$\Delta su_i=d\times s(len)+d\times len\times(i-r)$$
$$=d\times s(len)-d\times len\times r+d\times len\times r$$

发现前半部分是个定值，相当于是普通区间加；后半部分相当于是区间加 $d\times len$ 倍的下标。如何实现后面再说。再看一下对于 $i\in[r+1,m]$ 部分怎么处理。

$$\frac{2\Delta su_i}{d}=(i-l+1)^2+(i-l+1)$$
$$=i^2+(l-1)^2+2i(1-l)+i+(1-l)$$
$$=i^2+(3-2l)i+(l-1)(l-2)$$

所以总结一下就是

$$2\Delta su_i=di^2+(3d-2ld)i+(l-1)(l-2)d$$

发现 $(l-1)(l-2)$ 是固定的，相当于是区间加。于是整理一下结论，我们需要可以完成区间加下标平方和区间加下标的数据结构。这应该是可以做到的，个人觉得思考难度并没有那么高。打懒标记应该很简单，主要就是 pushnow 函数的写法。区间加下标好办，相当于是求个等差数列的和，那区间加下标平方怎么搞？有平方和公式啊。

$$\sum\limits_{i=1}^{m}{i^2}=\frac{m(m+1)(2m+1)}{6}$$

最后我们发现，上面推出来的柿子为真正增量的两倍。取模意义下除法灰常麻烦，于是我的做法是线段树中维护的是增量的两倍，询问时乘上 2 的逆元就可以了。

最后说明一点，由于这道题对取模的要求苛刻得有些丧心病狂，一定要认真取模。然后本蒟蒻代码能力极差，不得已开了三棵线段树来维护上面增量的三个部分。码风氢气，见谅。
```
#include<cstdio>
//#define zczc
#define int long long
const int N=200010;
const int yy=500000004;
const int mod=1000000007;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,n,a[N];

#define lc (wh<<1)
#define rc (wh<<1|1)
#define mid (t[wh].l+t[wh].r>>1)
//直接区间加的那棵树
namespace ta{
	struct node{
		int l,r,data,lazy;
	}t[N<<2];
	inline void pushup(int wh){
		t[wh].data=(t[lc].data+t[rc].data)%mod;
		return;
	}
	inline void pushnow(int wh,int val){
		t[wh].lazy+=val;
		t[wh].lazy%=mod;
		t[wh].data+=val*(t[wh].r-t[wh].l+1)%mod;
		t[wh].data%=mod;
		return;
	}
	inline void pushdown(int wh){
		if(t[wh].lazy){
			pushnow(lc,t[wh].lazy);
			pushnow(rc,t[wh].lazy);
			t[wh].lazy=0;
		}
		return;
	}
	inline void build(int wh,int l,int r){
		t[wh].l=l,t[wh].r=r;
		if(l==r){
			t[wh].data=a[l];
			return;
		}
		build(lc,l,mid);
		build(rc,mid+1,r);
		pushup(wh);
		return;
	}
	inline void change(int wh,int wl,int wr,int val){
		if(wl<=t[wh].l&&t[wh].r<=wr){
			pushnow(wh,val);
			return;
		}
		pushdown(wh);
		if(wl<=mid)change(lc,wl,wr,val);
		if(wr>mid)change(rc,wl,wr,val);
		pushup(wh);
		return; 
	}
	inline int work(int wh,int wl,int wr){
		if(wl<=t[wh].l&&t[wh].r<=wr){
			return t[wh].data;
		}
		pushdown(wh);
		int an=0;
		if(wl<=mid)an+=work(lc,wl,wr);
		if(wr>mid)an+=work(rc,wl,wr);
		return an%mod; 
	}
	inline int ask(int wh,int pl){
		if(t[wh].l==t[wh].r)return t[wh].data;
		pushdown(wh);
		if(pl<=mid)return ask(lc,pl);
		else return ask(rc,pl);
	}
}
//区间加下标的那棵树 
namespace tb{
	struct node{
		int l,r,data,lazy;
	}t[N<<2];
	inline void pushup(int wh){
		t[wh].data=(t[lc].data+t[rc].data)%mod;
		return;
	}
	inline int s(int l,int r){
		return (l+r)*(r-l+1)/2%mod;
	}
	inline void pushnow(int wh,int val){
		t[wh].lazy+=val;t[wh].lazy%=mod;
		t[wh].data+=val*s(t[wh].l,t[wh].r)%mod;
		t[wh].data%=mod;
		return;
	}
	inline void pushdown(int wh){
		if(t[wh].lazy){
			pushnow(lc,t[wh].lazy);
			pushnow(rc,t[wh].lazy);
			t[wh].lazy=0;
		}
		return;
	}
	inline void build(int wh,int l,int r){
		t[wh].l=l,t[wh].r=r;
		if(l==r)return;
		build(lc,l,mid);
		build(rc,mid+1,r);
		pushup(wh);
		return;
	}
	inline void change(int wh,int wl,int wr,int val){
		if(wl<=t[wh].l&&t[wh].r<=wr){
			pushnow(wh,val);
			return;
		}
		pushdown(wh);
		if(wl<=mid)change(lc,wl,wr,val);
		if(wr>mid)change(rc,wl,wr,val);
		pushup(wh);
		return; 
	}
	inline int work(int wh,int wl,int wr){
		if(wl<=t[wh].l&&t[wh].r<=wr){
			return t[wh].data;
		}
		pushdown(wh);
		int an=0;
		if(wl<=mid)an+=work(lc,wl,wr);
		if(wr>mid)an+=work(rc,wl,wr);
		return an%mod; 
	}
	inline int ask(int wh,int pl){
		if(t[wh].l==t[wh].r)return t[wh].data;
		pushdown(wh);
		if(pl<=mid)return ask(lc,pl);
		else return ask(rc,pl);
	}
}
//区间加下标平方的那棵树
namespace tc{
	struct node{
		int l,r,data,lazy;
	}t[N<<2];
	inline void pushup(int wh){
		t[wh].data=(t[lc].data+t[rc].data)%mod;
		return;
	}
	inline int s(int wh){
		return wh*(wh+1)/2*(2*wh+1)/3%mod;
	}
	inline void pushnow(int wh,int val){
		t[wh].lazy+=val;t[wh].lazy%=mod;
		t[wh].data+=val*(s(t[wh].r)-s(t[wh].l-1)+mod)%mod;
		t[wh].data%=mod;
		return;
	}
	inline void pushdown(int wh){
		if(t[wh].lazy){
			pushnow(lc,t[wh].lazy);
			pushnow(rc,t[wh].lazy);
			t[wh].lazy=0;
		}
		return;
	}
	inline void build(int wh,int l,int r){
		t[wh].l=l,t[wh].r=r;
		if(l==r)return;
		build(lc,l,mid);
		build(rc,mid+1,r);
		pushup(wh);
		return;
	}
	inline void change(int wh,int wl,int wr,int val){
		if(wl<=t[wh].l&&t[wh].r<=wr){
			pushnow(wh,val);
			return;
		}
		pushdown(wh);
		if(wl<=mid)change(lc,wl,wr,val);
		if(wr>mid)change(rc,wl,wr,val);
		pushup(wh);
		return; 
	}
	inline int work(int wh,int wl,int wr){
		if(wl<=t[wh].l&&t[wh].r<=wr){
			return t[wh].data;
		}
		pushdown(wh);
		int an=0;
		if(wl<=mid)an+=work(lc,wl,wr);
		if(wr>mid)an+=work(rc,wl,wr);
		return an%mod; 
	}
	inline int ask(int wh,int pl){
		if(t[wh].l==t[wh].r)return t[wh].data;
		pushdown(wh);
		if(pl<=mid)return ask(lc,pl);
		else return ask(rc,pl);
	}
} 
#undef lc
#undef rc
#undef mid

inline int solve(int l,int r){
	if(l==r){
		return (ta::ask(1,l)+(tb::ask(1,l)+tc::ask(1,l))%mod*yy%mod)%mod;
	}
	else{
		return (ta::work(1,l,r)+(tb::work(1,l,r)+tc::work(1,l,r))%mod*yy%mod)%mod;
	}
}

signed main(){
	
	#ifdef zczc
	freopen("a.in","r",stdin);
	#endif
	
	read(m);read(n);
	for(int i=1;i<=m;i++){read(a[i]);a[i]+=a[i-1];a[i]%=mod;}
	for(int i=1;i<=m;i++)a[i]+=a[i-1],a[i]%=mod;
	//for(int i=1;i<=m;i++)printf("%d ",a[i]);
	ta::build(1,0,m);
	tb::build(1,0,m);
	tc::build(1,0,m);
	int op,l,r,val;
	
	while(n--){
		read(op);read(l);read(r);
		if(l>r){int s1=l;l=r;r=s1;}
		if(op==2){
			int an=solve(m,m)*(r-l+1)-solve(l-1,r-1)-solve(m-r,m-l);
			printf("%lld\n",(an%mod+mod)%mod);
		}
		else{
			read(val);
			if(r<m){
				int len=r-l+1;
				ta::change(1,r+1,m,((val*len%mod*(len+1)%mod*yy%mod-val*len%mod*r%mod)%mod+mod)%mod);
				tb::change(1,r+1,m,2*val*len%mod);
			}
			ta::change(1,l,r,(l-1)*(l-2)%mod*val%mod*yy%mod);
			tb::change(1,l,r,val*(3-2*l)%mod);
			tc::change(1,l,r,val);
		}
	}
	
	return 0;
}
```

---

## 作者：一串数字 (赞：2)

~~审核辛苦了，刚刚那一版有点问题我重交一下~~

### 此题思路复杂，以下内容建议一行一行读，保证上一行理解后再看下一行。

[题目传送门](https://www.luogu.com.cn/problem/P4458)

~~如果哪里写的不详细，欢迎留言（我太菜了~~

题意大概就是维护一个序列 $a$，支持区间修改和查询：

$\sum_{len=l}^{r}\sum_{i=1}^{n-len+1}\sum_{j=i}^{i+len-1}a[j] $。

~~然后我就盯着这个公式看了十分钟~~

我们先不管修改操作，这个公式暴力计算是 $O(n^3)$ 的复杂度。观察一下这个公式，有个 $\sum_{j=i}^{i+len-1}a[j] $ 。既然是区间求和，不妨先用前缀和干掉一维，变成 $O(n^2)$ 。我们将原数组的前缀和记作 $sum$ ，则原公式转化为：

$\sum_{len=l}^{r}\sum_{i=1}^{n-len+1} ( sum[i+len-1] - sum[i-1] ) $。

成功转化成了 $O(n^2)$ 。观察到似乎还有一层区间求和。原式如果再拆一下就会变成：

$\sum_{len=l}^{r} ( \sum_{i=len}^{n}sum[i] - \sum_{i=0}^{n-len} sum[i]) $。

里面又有区间求和，再前缀和一下下。将 $sum$ 的前缀和记为 $ssum$ 。

$\sum_{len=l}^{r} (ssum[n] - ssum[len-1]-ssum[n-len]) $

$ = ssum[n] \times (r-l+1) - \sum_{len=l}^{r} ssum[len-1]  - \sum_{len=l}^{r}ssum[n-len]$

$ = ssum[n] \times (r-l+1) - \sum_{i=l-1}^{r-1} ssum[i]  - \sum_{i=n-r}^{n-l}ssum[i]$


------------


~~如果再搞个 sssum 单次查询能做到 O(1) 但这辈子都别想修改了~~ 如果加上修改操作，就必须用线段树代替前缀和。我们用线段树维护这个 $ssum$ 数组，使查询操作做到 $O(logn)$ 。

我们对 $a$ 数组的“区间加”操作，会对 $ssum$ 产生怎样的影响呢？

不妨先看看 $sum$ 的变化。我们给 $a$ 的原区间 $[L,R]$ 加上 $d$，显然不会影响到 $sum[0]$ 到 $sum[L-1]$ 的任何一个值。根据前缀和的定义，$sum[L]$ 会加上 $d$，$sum[L+1]$ 会加上 $2d$，$sum[L+2]$ 会加上 $3d$ ......也就是 $[L,R]$ 范围内的每个 $sum[L+i] $ 会加上 $ (i+1)\times d$ 。$sum[R]$ 之后的值增加量和 $sum[R]$ 相同 (为 $len \times d$ )，因为同位置的 $a$ 值不再增加。

然后再来看看 $ssum$ 的变化。同样的，$ssum[0]$ 到 $ssum[L-1]$ 不受影响。$ssum[L]$ 则会加上 $d$，$ssum[L+1]$会加上 $3d$......

观察到，在 $[L,R]$ 范围内的每一个 $ssum[L+i]$ 会被加上 $d$ 的次数 ( 记为 $delta[i]$ ) 的通项公式：$delta[i] = \frac{(i+1)\times(i+2)}{2}$ 

同时，在 $(R,n]$ 范围内，每个 $ssum[R+i]$ 的增加值为：

$(delta[len] + i \times (R-L+1) )\times d$

这也很好理解，$delta[len]$ 是 $ssum[R]$ 被加 $d$ 的次数，$sum[R]$ 后面每个 $sum[i]$ 均增加 $len\times d$，累计加了 $i$ 次，总共加了 $i\times len \times d$ 。



------------


把 $[L,R]$ 和 $(R,n]$ 这两部分分开处理。先看前一部分。难点在于 $lazy$ 标签的设计，必须满足以下条件（不理解也没关系，往下看）：

- 能够累加：即多次操作对区间的影响可以叠加反映到 $lazy$ 标签上。
- 能够下放：这个标签能够被下放到两个子区间

每个位置加的值都不一样，如何设计 $lazy$ 标签呢？在第一部分中，每个位置 $ssum[L+i]$ 加的值为 $\frac{(i+1)\times(i+2)}{2} \times d$ ，将这个式子展开后得到 $\frac{i^2+3i+2}{2}\times d$。

所以，对于每个位置 $ssum[idx]$ ，因为 $idx=L+i$，所以这个位置在一次操作后的增加量为：

$\frac{d(idx-L)^2+3d(idx-L)+2d}{2}$

把 $idx$ 视作主元，将上式转化为：

$\frac{d\times idx^2 + (3d-2Ld)\times idx -3dL+2d+dL^2}{2}$

分子是一个关于 $idx$ 的二次三项式，我们可以把这个多项式的 $a,b,c$ 设计为 $lazy$ 标签。令 $a,b,c$ 代表这个线段树节点所维护区间内每个 $ssum[idx]$ 应被加上 $\frac{a\times idx^2 + b\times idx +c}{2}$

则一次操作后：$a=d$ ；$b=3d-2Ld$ ；$c=dL^2-3dL+2d$

因为多项式的性质，这个标签是可以累加的，如果有多个操作，直接把多个 $d$、$3d-2Ld$、$dL^2-3dL+2d$ 加起来作为新的 $a,b,c$ 就可以。

同样，这个标签也是可下放的，因为 $a,b,c$ 的值与位置 $idx$ 无关，可以让两个子节点的 $a,b,c$ 直接加上当前节点的 $a,b,c$ 。（如果还是不理解可以先看看代码）

再来看看第二部分。每个位置加的值为 $\frac{d(R-L)^2+3d(R-L)+2d}{2} + (idx-R)\times (R-L+1)\times d$

同样把 $idx$ 视为主元：

$(R-L+1)\times d \times idx + \frac{d(R-L)^2+3d(R-L)+2d}{2} - R\times (R-L+1)\times d$

则 $a=0$ ；$b=2(R-L+1)\times d$ ；$c=d(R-L)^2+3d(R-L)+2d - 2\times R\times (R-L+1)\times d$ 。根据上面 $a,b,c$ 的定义，这里要乘以 $2$

最后，假设现在线段树的某个节点 $[l,r]$ 被加上了一组 $a,b,c$，它的权值应该被加上：

- $[l,r]$ 区间内所有 $idx$ 平方和乘以 $a$；
- $[l,r]$ 区间内所有 $idx$ 和乘以 $b$；
- $[l,r]$ 长度乘以 $c$；

别忘了最后要除以 $2$。

第一个可以用平方和公式算，第二个用等差数列求和公式，时间复杂度均为 $O(1)$

当时我以为这道题已经做完了，提交代码，10pts WA

然后再看一眼题面，要求膜 $1e9+7$。以为加上这个就能 AC

结果还是我太菜了，原式中有除法，怎能随便膜呢？上逆元吧。$2$ 在膜 $1e9+7$ 意义下的逆元为 $5e8+4$ 。还有最后算完答案如果是负的，应该加上 $1e9+7$

用乘以 $5e8+4$ 代替除以 $2$，提交，AC。

上 Code : 

```cpp
#include<iostream>
#include<assert.h>

using namespace std;

const int mod = 1e9+7;
const long long niYuan = 5e8+4;

inline long long sqrSum(long long n){ //自然数平方和公式
	return (n*(n+1)*(2*n+1)/6) % mod; 
}

struct seg{
	seg* lson=NULL,*rson=NULL;
	
	long long lazyA=0,lazyB=0,lazyC=0;
	long long val;
	int segL,segR;
	
	inline void update(){
		assert(!(lazyA|lazyB|lazyC)); //调试用
		val = (lson->val + rson->val) % mod;
	}
	
	inline long long idxSqrSum(){ //编号平方和
		return (sqrSum(segR) - sqrSum(segL-1)) % mod; 
	}
	
	inline long long len(){ //区间长度
		return (segR - segL + 1) % mod; 
	}
	
	inline long long idxSum(){ //编号和
		return ((segL+segR)*len()/2) % mod; 
	}
	
	inline void add(int a,int b,int c){
		lazyA += a;lazyB += b;lazyC += c;
		lazyA %= mod;lazyB %= mod;lazyC %= mod;
		
		val += ((a*idxSqrSum()%mod + b*idxSum()%mod + c*len()%mod) %mod * niYuan) % mod; //除以二等价于乘以 5e8+4 
		val %= mod;
	}
	
	inline void pushdown(){ 
		lson->add(lazyA,lazyB,lazyC);
		rson->add(lazyA,lazyB,lazyC);
		
		lazyA=lazyB=lazyC = 0;
	}
}*root;

long long a[200009],sum[200009],ssum[200009];

seg* BuildTree(int L,int R){
	seg* cur = new seg();cur->segL=L;cur->segR=R;
	if(L==R){
		cur->val = ssum[L];
		return cur;
	}
	
	int mid = L+R>>1;
	cur->lson = BuildTree(L,mid);
	cur->rson = BuildTree(mid+1,R);
	cur->update();
	return cur;
}

int n,m;

// [L,R]
void Add1(seg* cur,long long L,long long R,long long d){
	if(cur->segR < L || cur->segL > R){
		return;
	}
	if(cur->segL >= L && cur->segR <= R){
		
		cur->add( //算一步膜一步防炸
			d, //a
			(3*d%mod - 2*L%mod*d%mod) % mod, //b
			(d*L%mod*L%mod - 3*d%mod*L%mod + 2*d%mod) % mod //c
		);
		return;
	}
	cur->pushdown();
	Add1(cur->lson,L,R,d);
	Add1(cur->rson,L,R,d);
	cur->update();
}

// (R,n]
void Add2(seg* cur,long long L,long long R,long long d){
	if(cur->segR <= R){ //注意这里加的是 (R,n] 
		return;
	}
	if(cur->segL > R){
		cur->add( 
			0, //a
			(2 * (R-L+1) % mod * d ) % mod, //b
			(d * (R-L) %mod *(R-L) %mod + 3*d %mod *(R-L) % mod + 2*d %mod - 2*R %mod *(R-L+1) %mod *d %mod) % mod //c
		);
		return;
	}
	cur->pushdown();
	Add2(cur->lson,L,R,d);
	Add2(cur->rson,L,R,d);
	cur->update();
}

long long QuerySum(seg* cur,int L,int R){
	if(cur->segL > R || cur->segR < L)return 0;
	
	if(cur->segL >= L && cur->segR <=R){
		return cur->val;
	}
	cur->pushdown();
	long long ans = (QuerySum(cur->lson,L,R) + QuerySum(cur->rson,L,R)) % mod;
	cur->update();
	return ans;
}

void dfs(seg* cur){ // 遍历，调试用的
	
	if(!cur->lson){
		cout<<"["<<cur->segL<<","<<cur->segR<<"]: "<<cur->val<<endl;
		return;
	}
	
	cur->pushdown();
	dfs(cur->lson);
	dfs(cur->rson);
	cur->update();
	cout<<"["<<cur->segL<<","<<cur->segR<<"]: "<<cur->val<<endl;
}

void displaySsum(){ // 调试用
	for(int i=1; i<=n; i++){
		cout<<ssum[i]<<' ';
	}cout<<endl;
}

void edit(int L,int R,int d){ // 对拍用的暴力版
	for(int idx=L; idx<=R; idx++){
		ssum[idx] += (d*(idx-L)*(idx-L)+3*d*(idx-L)+2*d) / 2;
	}
	for(int idx=R+1; idx<=n; idx++){
		ssum[idx] += (d*(R-L)*(R-L)+3*d*(R-L)+2*d) / 2 + (idx-R) * (R-L+1) * d;
	}
}

int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){
		cin>>a[i];
//		a[i] = rand();
		sum[i]= (sum[i-1] + a[i]) % mod;
		ssum[i]= (ssum[i-1] + sum[i]) % mod;
	}
	root = BuildTree(1,n);
	
	while(m--){
		char cmd;cin>>cmd;
		switch(cmd){
			case '1':{
				int u,v,d;cin>>u>>v>>d;
				if(u>v)swap(u,v);
				Add1(root,u,v,d);
				Add2(root,u,v,d);
				
//				edit(u,v,d);
				
				break;
			}
			case '2':{
				int max,min;cin>>min>>max;
				long long ans = ((QuerySum(root,n,n)*(max-min+1))%mod - QuerySum(root,min-1,max-1) - QuerySum(root,n-max,n-min))%mod;
				while(ans<0)ans += mod;
				cout<<ans%mod<<endl;
				break;
			}
		}
	}
	
	return 0;
}
```


---

## 作者：devout (赞：1)

大毒瘤题。

区间不太好做，因此先考虑在 $p$ 位置 $+k$。

设 $D=\min(p,n-p+1),U=\max(p,n-p+1)$。

那么对于长度 $x\leq D$ 的区间，恰有 $x$ 个是包含 $p$ 的，贡献为 $kx$。

对于长度 $x\in(D,U)$ 的区间，包含 $p$ 的中有一边已经被固定，所以贡献为 $Dk$。

对于长度为 $x\geq U$ 的区间，有 $n-x+1$ 个是包含 $p$ 的，贡献为 $(n-x+1)k$。

不难发现这是一个分段一次函数。

对于 $[l,r]$ 中进行区间加，只需要把这些情况都叠加起来就好了，所以应该是分段二次函数。

考虑 $l,r$ 均在 $n/2$ 的同一侧的情况。

设 $D1=\min(D_l,D_r),D2=\max(D_l,D_r),U2=\min(U_l,U_r),U1=\max(U_l,U_r)$。

$x\in[1,D1],\Delta=(r-l+1)kx$

$x\in(D1,D2),\Delta=-\frac{1}{2}kx^2+k(r-l+D1+\frac{1}{2})x-\frac{1}{2}k(D1-1)D1$

$x\in[D2,U2],\Delta=\dfrac{(D1+D1)(D2-D1+1)}{2}k$

$x\in(U2,U1),\Delta=-\frac{1}{2}kx^2-k(r-l-U1+\frac{1}{2})x+\frac{1}{2}k(D1+n)U1+k(r-l+1-U1)(n+1)$

$x\in[U1,n],\Delta=-k(r-l+1)x+k(r-l+1)(n+1)$

于是线段树维护区间加二次函数即可

```cpp
#include <bits/stdc++.h>

using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;
typedef double db;

# define chkmax(a,b) a=max(a,b)
# define chkmin(a,b) a=min(a,b)
# define PII pair<int,int>
# define mkp make_pair

const int N=2e5+5;
const int mod=1e9+7;
const int inv2=5e8+4;

template<typename T> void read(T &x){
    x=0;int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,q;
int a[N];
int sum[N],sum2[N];

int inc(int x,int y){
    return x+y>=mod?x+y-mod:x+y;
}

int dec(int x,int y){
    return x<y?x-y+mod:x-y;
}

int linsum(int x){
    return 1ll*x*(x+1)/2%mod;
}

int sqrsum(int x){
    return 1ll*x*(x+1)*(2*x+1)/6%mod;
}

struct node{
    int l,r,sum;
    int a,b,c;
}seg[N<<2];

# define lc (u<<1)
# define rc (u<<1|1)

void pushup(int u){
    seg[u].sum=inc(seg[lc].sum,seg[rc].sum);
}

void renew(int u,int a,int b,int c){
    seg[u].sum=inc(seg[u].sum,1ll*c*(seg[u].r-seg[u].l+1)%mod);
    seg[u].sum=inc(seg[u].sum,1ll*b*dec(linsum(seg[u].r),linsum(seg[u].l-1))%mod);
    seg[u].sum=inc(seg[u].sum,1ll*a*dec(sqrsum(seg[u].r),sqrsum(seg[u].l-1))%mod);
    seg[u].a=inc(seg[u].a,a);
    seg[u].b=inc(seg[u].b,b);
    seg[u].c=inc(seg[u].c,c);
}

void pushdown(int u){
    renew(lc,seg[u].a,seg[u].b,seg[u].c);
    renew(rc,seg[u].a,seg[u].b,seg[u].c);
    seg[u].a=seg[u].b=seg[u].c=0;
}

void build(int u,int l,int r){
    seg[u].l=l,seg[u].r=r;
    if(l==r){
        seg[u].sum=dec(dec(sum2[n],sum2[l-1]),sum2[n-l]);
        return;
    }
    int mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
    pushup(u);
}

void update(int u,int l,int r,int a,int b,int c){
    if(seg[u].l>=l&&seg[u].r<=r){
        renew(u,a,b,c);
        return;
    }
    pushdown(u);
    int mid=seg[u].l+seg[u].r>>1;
    if(l<=mid)update(lc,l,r,a,b,c);
    if(r>mid)update(rc,l,r,a,b,c);
    pushup(u);
}

int query(int u,int l,int r){
    if(seg[u].l>=l&&seg[u].r<=r)return seg[u].sum;
    pushdown(u);
    int mid=seg[u].l+seg[u].r>>1;
    if(r<=mid)return query(lc,l,r);
    else if(l>mid)return query(rc,l,r);
    else return inc(query(lc,l,r),query(rc,l,r));
}

void solve(int l,int r,int k){
    int D1=min(l,n-l+1),D2=min(r,n-r+1),U1=max(l,n-l+1),U2=max(r,n-r+1);
    if(D1>D2)swap(D1,D2);
    if(U1<U2)swap(U1,U2);
    update(1,1,D1,0,1ll*k*(r-l+1)%mod,0);
    if(D1<D2)
    update(1,D1+1,D2,mod-1ll*inv2*k%mod,1ll*k*inc(inv2,r-l+D1)%mod,mod-1ll*k*inv2%mod*D1%mod*(D1-1)%mod);
    if(D2<U2)
    update(1,D2+1,U2,0,0,1ll*k*(D1+D2)%mod*(D2-D1+1)%mod*inv2%mod);
    if(U2<U1)
    update(1,U2+1,U1,mod-1ll*inv2*k%mod,mod-1ll*k*dec(r+inv2,l+U1)%mod,
    inc(1ll*inv2*(D1+n)%mod*U1%mod*k%mod,1ll*k*dec(r+1,l+U1)%mod*(n+1)%mod));
    if(U1<n)
    update(1,U1+1,n,0,mod-1ll*k*(r-l+1)%mod,1ll*k*(r-l+1)%mod*(n+1)%mod);
}

int main()
{
    read(n),read(q);
    Rep(i,1,n)read(a[i]);
    Rep(i,1,n)sum[i]=inc(sum[i-1],a[i]);
    Rep(i,1,n)sum2[i]=inc(sum2[i-1],sum[i]);
    build(1,1,n);
    while(q--){
        int opt,l,r,k;
        read(opt),read(l),read(r);
        if(opt==1){
            read(k);
            if(l>r)swap(l,r);
            if(l<=n/2&&r>n/2)solve(l,n/2,k),solve(n/2+1,r,k);
            else solve(l,r,k);
        }
        else printf("%d\n",query(1,l,r));
    }
    return 0;
}
```

---


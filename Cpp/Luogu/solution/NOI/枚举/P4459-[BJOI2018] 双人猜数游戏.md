# [BJOI2018] 双人猜数游戏

## 题目背景

本题为提交答案题。可在「附件」中下载输入文件。

## 题目描述

Alice 和 Bob 是一对非常聪明的人，他们可以算出各种各样游戏的最优策略。现在有个综艺节目《最强大佬》请他们来玩一个游戏。主持人写了三个正整数 $s,m,n$，然后一起告诉 Alice 和 Bob $s\le m\le n$ 以及 $s$ 是多少。（即，$s$ 是接下来要猜的 $m,n$ 的下限。）之后主持人单独告诉 Alice $m\times n$ 是多少，单独告诉 Bob $m+n$ 是多少。

当然，如果一个人同时知道 $m\times n$ 以及 $m+n$ 的话就能很容易地算出 $m$ 和 $n$ 分别是多少，但现在 Alice 和 Bob 只分别知道其中一个，而且他们只能回答主持人的问题，不能交流。主持人从他们中的一人开始，轮流询问回答者“知不知道 $m$ 和 $n$ 分别是多少”（回答者只能回答知道/不知道）。

为了节目效果，以及显示出 Alice 和 Bob 的绝顶聪明，主持人希望 Alice 和 Bob 一共说了 $t$ 次“不知道”以后两个人都知道 $m$ 和 $n$ 是多少了。现在主持人找到你，希望让帮他构造一组符合条件的 $m$ 和 $n$。

## 说明/提示

#### 样例 1 解释
主持人告诉 Alice 和 Bob $5\le m\le n$，单独告诉 Alice $m\times n=60$，单独告诉 Bob $m+n=16$。询问过程：
- 主持人问 Bob，Bob 说不知道。
- 主持人问 Alice，Alice 说不知道。
- 主持人问 Bob，Bob 说知道。
- 主持人问 Alice，Alice 说知道。

#### 样例 2 解释
主持人告诉 Alice 和 Bob $2\le m\le n$，单独告诉 Alice $m\times n=16$，单独告诉 Bob $m+n=8$。询问过程：
- 主持人问 Alice，Alice 说不知道。
- 主持人问 Bob，Bob 说不知道。
- 主持人问 Alice，Alice 说不知道。
- 主持人问 Bob，Bob 说知道。
- 主持人问 Alice，Alice 说知道。

#### 数据规模与约定
对于 $40\%$ 的数据，$t=2$；

对于 $100\%$ 的数据，$1\le s\le 200$，$2\le t\le 15$，保证有解。

## 样例 #1

### 输入

```
5 Bob 2
```

### 输出

```
6 10```

## 样例 #2

### 输入

```
2 Alice 3```

### 输出

```
4 4
```

# 题解

## 作者：dlhham (赞：30)

这个题最早在 LRJ 的黑书上看到过类似的，当时看的一脸懵逼，不过这次就不是那么懵了。

对着题解看了好久，总觉得哪里还不是太理解，觉得有些地方和自己理解的不一样，于是按自己的理解写一份题解。

实际上这个题的内在逻辑，只要我们拆分出来所有的情况，就很简单了。

用 $f[i][j][k]$ 表示在第 $i$ 回合（每个人回答一次知道或不知道，算一个回合），第 $i$ 个人能否确定答案是不是 $j,k(j\leq k)$ 这两个数。

那么，这个东西一共就4种情况（拿 Bob 举例）：

 - CASE1：$f[i-2][j][k]$，也就是如果上一轮这个人已经知道了，那这回合必然也知道。

-  CASE2：$f[i-1][j+t][k-t](s\leq j+t \leq k-t)$ 中，仅有 $f[i-1][j][k]$ 这一项是不知道的，那么 Bob 就能根据上一回合， Alice 回答“不知道”，而得知他的答案是 $j,k$。

- CASE3：$f[i-2][j+t][k-t](s\leq j+t \leq k-t)$ 中，仅有 $f[i-2][j][k]$ 这一项是不知道的，那么 Bob 显然也能在这一回合确定自己的答案是 $j,k$。

- CASE4：$f[i-1][j+t][k-t](s\leq j+t \leq k-t)$ 中，$f[i-1][j][k]$ 是确定的，但 $(j,k)$ 是第 $i-1$ 个回合中，Alice __唯一的新增“确定”__，那么 Bob 也就能确定自己的答案是 $j,k$ 了。这一种情况最容易忽视，我因为这个卡了好久。具体怎么理解呢，举个例子：Bob 认为答案可能有 (1,5),(2,4),(3,3) 三种情况，而对于 Alice，假设他第一次回答时，只能确定答案是不是 (1,5)，也就是  $f[1][1][5]=1$，第二次回答时，只能确定答案是不是 $(1,5)$ 以及 $(3,3)$，也就是 $f[3][1][5]=1,f[3][3][3]=1$，那么，Bob 就能在第4回合确定答案是不是 $3,3$ 了，因为如果答案是 $3,3$，那么 Alice 会在第一回合说“不知道”，第三回合说“知道”。

Alice 视角的推法一样。

情况讨论清楚就可以预处理答案了，预处理结束之后就可以按顺序枚举了，只要

```c++
f[t+1][j][k]==1 and f[t+2][j][k]==1 and f[i(for all i < t)][j][k]==0
```

这对 $j,k$ 就是一组合法解。



这个做法有一个瑕疵是，对于乘法的分解，有可能分解出来的数很大，数组存不下，按道理说是应该按 yhw 的题解那样，拿 map + 记忆化来实现的，但是因为懒，所以就不想改了。

```cpp
//如果上一轮，你只在这一种情况不知道，那我就知道了
//如果上上一轮，我只有在这一种情况不知道，那我也知道了 
//如果上一轮，这是你的“首次 ”新增确定，那么我也知道了 
#include <bits/stdc++.h>
using namespace std;
bool f[18][305][305];
string S;
int s,t,flag;
void work1(int turn,int j,int  k) //alice
{
	int num1=0,X1=0,Y1=0; //上一回合有几个不确定
	int num3=0,X3=0,Y3=0; //上上回合有几个不确定
	int num4=0,X4=0,Y4=0; //有几个新增确定
	int tot=j*k;
	for (int x=s;x*x<=tot;x++)
	if (tot%x==0 && tot/x<=300)
	{
		int y=tot/x;
		if (turn==1 || f[turn-1][x][y]==0) {num1++; X1=x; Y1=y;}
		if (turn>=3 && f[turn-2][x][y]==0) {num3++; X3=x; Y3=y;}
		if (f[turn-1][x][y]==1) //确定
		if (turn<=3 || f[turn-3][x][y]==0){num4++; X4=x; Y4=y;}
	}
	if (num1==1 && X1==j && Y1==k) f[turn][j][k]=1;
	if (num3==1 && X3==j && Y3==k) f[turn][j][k]=1;
	if (num4==1 && X4==j && Y4==k) f[turn][j][k]=1;
	return;
}

void work2(int turn,int j,int k) //bob
{
	int num1=0,X1=0,Y1=0;
	int num3=0,X3=0,Y3=0;
	int num4=0,X4=0,Y4=0; 
	for (int x=s;x<=j+k-x;x++)
	{
		int y=j+k-x;
		if (turn==1 || f[turn-1][x][y]==0) {num1++; X1=x; Y1=y;}
		if (turn>=3 && f[turn-2][x][y]==0) {num3++; X3=x; Y3=y;}
		if (f[turn-1][x][y]==1) //确定
		if (turn<=3 || f[turn-3][x][y]==0) {num4++; X4=x; Y4=y;}
	}
	if (num1==1 && X1==j && Y1==k) f[turn][j][k]=1;
	if (num3==1 && X3==j && Y3==k) f[turn][j][k]=1;
	if (num4==1 && X4==j && Y4==k) f[turn][j][k]=1;
	return;
}

int main()
{
	cin>>s>>S>>t;
	if (S=="Alice")  flag=0; else flag=1;
	for (int turn=1;turn<=t+2;turn++)
	{
		for (int j=s;j<=300;j++)
			for (int k=j;k<=300;k++)
			{
				if (turn>=3) f[turn][j][k]|=f[turn-2][j][k];
				if (f[turn][j][k]) continue;
				if (flag==0) work1(turn,j,k);
				else work2(turn,j,k);
			}
		flag=1-flag;	
	}
	int sum=s+s;
	while (true)
	{
		if (sum>=1000) break;
		for (int i=s;i<=sum-i;i++)
		{
			int j=sum-i;
			if (f[t+1][i][j]==0  || f[t+2][i][j]==0) continue;
			int flag=0;
			for (int k=1;k<=t;k++) if (f[k][i][j]==1) flag=1;
			if (flag) continue;
			cout<<i<<" "<<j<<endl;
			return 0;
		}
		sum++;
	}
}
```


---

## 作者：Delov (赞：29)


可以发现，每次是在根据“不知道”来排除决策集合中的某些东西，例如：

---
第一轮 A 说不知道，那么积拆分不唯一。

第二轮 B 说不知道，那么说明和对于所有和拆分 $(a,b)$，$a \times b$ 的和拆分不唯一的 $(a,b)$ 不唯一。

第三轮 A 又说不知道，那么对于所有的积拆分 $(a,b)$，$a+b$ 的所有积拆分中，其和拆分不唯一的的积拆分不唯一的 $(a,b)$ 不唯一。

---

我们发现每次说不知道，就是在嵌套上一个"和/积拆分...不唯一"，那么可以尝试递归解决问题。

函数 $\operatorname {DfsA}(dep,vec)$ 表示之前一共说过 $dep$ 次不知道，剩余决策集合为 $vec$，此时轮到 A 判断，返回 A 此时的决策集合。

$\operatorname {DfsB}(dep,vec)$ 同理。

考虑如何排除，就是枚举剩余决策集合的每个元素 $(a,b)$，将其和/积算出并作和/积拆分，考虑满足要求的拆分是否唯一，若不唯一则其仍是一个合法决策，否则排除之。是否满足要求则是一个递归问题，递归边界即为之前没有说过“不知道”，此时判断条件就是和/积拆分方案数。

我们通过这样的处理可以找出前 $t$ 次两人都说不知道之后两人各自的剩余决策集合，现在我们需要看他们是否“知道”了。

判断方法相同，我们就枚举所有决策，看是否存在唯一一个满足要求的，判断是否满足的处理要求同上，递归处理即可。发现递归过程中，除了第一层决策集合可能是特殊的，往下递归后每层的决策集合实际上就是某个数的和/积拆分的所有方案，于是我们可以对这些过程记忆化。

跑的甚至比提交答案快？应该是所有提交代码里最快的。

### code


```cpp
#include <bits/stdc++.h>
typedef long long ll;typedef unsigned long long ull; typedef double db;typedef long double ldb;
#define fre(x) freopen(#x ".in","r",stdin),freopen(#x ".out","w",stdout)
#define Rep(i,a,b) for(int i=a;i<=b;++i) 
#define Dwn(i,a,b) for(int i=a;i>=b;--i)
#define pii pair<int,int>
#define mair make_pair
#define fir first
#define sec second
using namespace std;

int Lim,Ned;
string str;

unordered_map<int,int>MapB,MapC;

int ExpandB(int x){
	if(MapB.count(x))return MapB[x];
	int res=0;for(int i=Lim;x-i>=i;++i)++res;
	return MapB[x]=res;
}

int ExpandC(int x){
	if(MapC.count(x))return MapC[x];
	int res=0;for(int i=Lim;x/i>=i;++i)if(x%i==0)++res;
	return MapC[x]=res;
}

vector<pii> DfsA(int ,const vector<pii>&);
vector<pii> DfsB(int ,const vector<pii>&);

vector<pii>ExA(int x){ vector<pii>res;for(int i=Lim;i*i<=x;++i)if(x%i==0)res.emplace_back(i,x/i);return res; }
vector<pii>ExB(int x){ vector<pii>res;for(int i=Lim;i+i<=x;++i)res.emplace_back(i,x-i);return res; }

unordered_map<int,int>MapAx[20],MapBx[20];

int CfsA(int,int);
int CfsB(int,int);

int CfsA(int dep,int x){
	if(dep==0)return ExpandC(x);
	if(MapAx[dep].count(x))return MapAx[dep][x];
	vector<pii>vec=ExA(x);int res=0;
	for(auto it : vec)res+=(CfsB(dep-1,it.fir+it.sec)>1);
	return MapAx[dep][x]=res;
}

int CfsB(int dep,int x){
	if(dep==0)return ExpandB(x);
	if(MapBx[dep].count(x))return MapBx[dep][x];
	vector<pii>vec=ExB(x);int res=0;
	for(auto it : vec)res+=(CfsA(dep-1,it.fir*it.sec)>1);
	return MapBx[dep][x]=res;
}

vector<pii> DfsA(int dep,const vector<pii> & vec){
	if(dep==0)return vec;
	vector<pii>res;
	for(auto it : vec)if(CfsB(dep-1,it.fir+it.sec)>1)res.emplace_back(it);
	/*for(auto it : vec){
		vector<pii> tmp=DfsB(dep-1,ExB(it.fir+it.sec));
		if(tmp.size()>1)res.emplace_back(it);
	}*/
	return res;
}

vector<pii> DfsB(int dep,const vector<pii> & vec){
	if(dep==0)return vec;
	vector<pii>res;
	for(auto it : vec)if(CfsA(dep-1,it.fir*it.sec)>1)res.emplace_back(it);
	/*for(auto it : vec){
		vector<pii> tmp=DfsA(dep-1,ExA(it.fir*it.sec));
		if(tmp.size()>1)res.emplace_back(it);
	}*/
	return res;
}

int Get(int n,int m){
	vector<pii>vecA=ExA(n*m),vecB=ExB(n+m);
	if(n==78 && m==108){ cerr<<"\n"; }
	if(str=="Alice"){
		Rep(i,1,Ned){
			if((i&1)){ vecA=DfsA(i-1,vecA);if(vecA.size()<=1)return 0; }
			else{ vecB=DfsB(i-1,vecB);if(vecB.size()<=1)return 0; }
		}
		if(!(Ned&1)){
			vecA=DfsA(Ned,vecA);int res=0;
			for(auto it : vecB){
				if(DfsA(Ned,ExA(it.fir*it.sec)).size()==1)++res;
			}
			if(vecA.size()==1 && res==1)return Ned;
			else return 0;
		}else{
			vecB=DfsB(Ned,vecB);int res=0;
			for(auto it : vecA){
				if(DfsB(Ned,ExB(it.fir+it.sec)).size()==1)++res;
			}
			if(vecB.size()==1 && res==1)return Ned;
			else return 0;
			
		}
	}
	if(str=="Bob"){
		Rep(i,1,Ned){
			if((i&1)){ vecB=DfsB(i-1,vecB);if(vecB.size()<=1)return 0; }
			else { vecA=DfsA(i-1,vecA);if(vecA.size()<=1)return 0; }
		}
		if(!(Ned&1)){
			vecB=DfsB(Ned,vecB);int res=0;
			for(auto it : vecA){
				if(DfsB(Ned,ExB(it.fir+it.sec)).size()==1)++res;
			}
			if(vecB.size()==1 && res==1)return Ned;
			else return 0;
		}else{
			vecA=DfsA(Ned,vecA);int res=0;
			for(auto it : vecB){
				if(DfsA(Ned,ExA(it.fir*it.sec)).size()==1)++res;
			}
			if(vecA.size()==1 && res==1)return Ned;
			else return 0;
		}
	}
	return 0;
}

void solve(){
	cin>>Lim>>str>>Ned;
	for(int s=Lim+Lim;;++s){
		for(int i=Lim;s-i>=i;++i)
			if(Get(i,s-i)==Ned)return cout<<i<<" "<<s-i<<"\n",void();
	}
}

int main (){ ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);return solve(),0; }
```


---

## 作者：TheLostWeak (赞：12)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu4459.html)

**大致题意：** 一直有两个数$m,n$，已知$s\le m\le n$，且$Alice$和$Bob$二个“最强大佬”各知道$mn$和$m+n$。每轮依次询问二人是否知道$m$和$n$是多少，求构造一对合法的$m,n$，使他们两个共说恰好$t$次不知道。

### 手玩样例

这题看起来真是神仙，差不多就是两个神仙人不停地说不知道，然后突然就知道了。。。

所以我们要来手（解）玩（释）一下样例。

这里先不讲如何求答案，就来讲一下这答案为什么可以，以样例$1$为例。

最后得到的$m,n$分别为$6,10$，也就是说$Alice$和$Bob$分别得到的是$60$和$16$。

那我们来模拟一下他们的思路：

#### 第$1$轮

- $Bob$：对于$Bob$来说，$16=5+11=6+10=7+9=8+8$，在没有任何信息的情况下，无法排除任何一种答案。
- $Alice$：对于$Alice$来说，$60=5*12=6*10$，这两种情况下的和分别为$17$和$16$，而如果$Bob$得到的是$17$或$16$，都不能一次确定答案，因此$Alice$也无法排除任何一种答案。

#### 第$2$轮

- $Bob$：上面提到过的$4$种情况，所对应的积分别为$55,60,63,64$，而除了$60$以外，其余$3$种情况在$5\le m\le n$的情况下都只有一种分解方式，所以$Alice$可以直接确定。而$Alice$依然不知道，因此可以将这$3$种情况排除，就得出答案为$6,10$。
- $Alice$：同理，在$Bob$确定之后也可以通过类似的方式确定。

### 动态规划

我们可以考虑用**动态规划+剪枝**来做这题。

设$f_{i,j,k}$表示**已经说过$i$次不知道，且两个数分别为$j,k$时是否能确定**。

显然，对于每个人的询问是隔两次出现一次的。

而一个人如果上次被询问时已经知道答案了，下一次询问自然也知道。

于是可以推出第一个转移式：$f_{i,j,k}=f_{i-2,j,k}$。

而光这一个式子显然是不够的（废话），考虑上面手玩样例的过程，我们可以发现，以$Alice$为例，如果与$j,k$乘积相等的其他情况（设为$x,y$）都可以使$f_{i-1,x,y}=1$（即如果是这种情况，上一次询问时另一个人就能得出答案），且$f_{i-1,j,k}=0$，就可以排除其他所有情况，确定$f_{i,j,k}=1$。

对于$Bob$同理。

这样就可以通过动态规划来预处理出$f$数组了。

### 求出答案

考虑到题目首先要求$m+n$最小，其次要求$m$最小，因此考虑先枚举$m+n$，然后枚举$m$。

于是就变成了判断一对$m,n$是否符合题目要求。

首先，由于要恰好说$t$次不知道，因此我们要保证对于任一$i<t$，$f_{i,m,n}=0$。

然后，还要特判一下$f_{t+1,m,n}$是否确定，即判断此时的情况是否唯一，不然依然无法做到恰好说$t$次不知道。

这与之前动态规划的第二种转移方式的代码类似，具体实现详见代码。

### 代码

不知道出了什么问题提答交不上去。。。只能直接交代码了（反正也跑得挺快，能$AC$）。

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 15
#define V 300
using namespace std;
int n,t,k,f[N+5][V+5][V+5];char s[10];
I bool CheckA_Init(CI t,CI x,CI y)//预处理时对Alice的判断
{
    RI i,v=x*y,lim=sqrt(v),flag=0;for(i=k;i<=lim;++i)//枚举情况
    {
        if(v%i||(t&&f[t-1][i][v/i])) continue;//如果x*y不是i的倍数（即不存在这种情况），或者这种情况会使f[t-1][i][v/i]=1，就说明不符合条件
        if(i^x||flag) return false;flag=1;//如果符合条件的答案不为x,y，或有多种答案符合条件，说明不合法，返回false
    }return flag;//若只有x,y未确定，则可将其确定
}
I bool CheckB_Init(CI t,CI x,CI y)//预处理时对Bob的判断
{
    RI i,v=x+y,lim=v>>1,flag=0;for(i=k;i<=lim;++i)//枚举情况
    {
        if(t&&f[t-1][i][v-i]) continue;//如果这种情况会使f[t-1][i][v-i]=1，就说明不符合条件
        if(i^x||flag) return false;flag=1;//如果符合条件的答案不为x,y，或有多种答案符合条件，说明不合法，返回false
    }return flag;//若只有x,y未确定，则可将其确定
}
I bool CheckA_Answer(CI t,CI x,CI y)//求答案时对Alice的判断
{
    RI i,v=x*y,lim=sqrt(v),flag=0;for(i=k;i<=lim;++i)//枚举情况
    {
        if(v%i||!f[t][i][v/i]||(t>=2&&f[t-2][i][v/i])) continue;//如果x*y不是i的倍数（即不存在这种情况），或者这种情况无法确定f[t][i][v/i]=1，或者在上一轮已经可以确定f[t-2][i][v/i]=1，就说明不符合条件
        if(i^x||flag) return false;flag=1;//如果符合条件的答案不为x,y，或有多种答案符合条件，说明不合法，返回false
    }return flag;//若只有x,y合法，则可确定f[t+1][m][n]为1
}
I bool CheckB_Answer(CI t,CI x,CI y)//求答案时对Bob的判断
{
    RI i,v=x+y,lim=v>>1,flag=0;for(i=k;i<=lim;++i)//枚举情况
    {
        if(!f[t][i][v-i]||(t>=2&&f[t-2][i][v-i])) continue;//如果这种情况无法确定f[t][i][v-i]=1，或者在上一轮已经可以确定f[t-2][i][v-i]=1，就说明不符合条件
        if(i^x||flag) return false;flag=1;//如果符合条件的答案不为x,y，或有多种答案符合条件，说明不合法，返回false
    }return flag;//若只有x,y合法，则可确定f[t+1][m][n]为1
}
int main()
{
    RI i,j,l,STO,ORZ,op,flag;scanf("%d%s%d",&k,&s,&n),t=s[0]=='B';//读入数据
    for(i=0,op=t;i<=n;++i,op^=1) for(STO=k;STO<=V;++STO) for(ORZ=k;ORZ<=V;++ORZ)
        f[i][STO][ORZ]=i>=2&&f[i-2][STO][ORZ]?1:(op?CheckB_Init(i,STO,ORZ):CheckA_Init(i,STO,ORZ));//动态规划预处理
    for(i=k<<1;;++i) for(j=1;j<=(i>>1);++j)//枚举答案
    {
        for(flag=f[n][STO=j][ORZ=i-j],l=0;l^n&&flag;++l) f[l][STO][ORZ]&&(flag=0);if(!flag) continue;//若存在更早的情况，说明无法做到恰好t个，跳过
        if(!((n&1?!t:t)?CheckA_Answer(n,STO,ORZ):CheckB_Answer(n,STO,ORZ))) continue;//特判
        return printf("%d %d",STO,ORZ),0;//输出答案并结束程序
    }return 0;
}
```

---

## 作者：zhaotiensn (赞：8)

这题一眼看下去很神，其实~~看过题解后觉得~~还好。

就先拿样例一举例来理解Alice和Bob的思维方式：

因为两个数分别是6和10，所以Alice拿到的是60，Bob拿到的是16。

主持人问Bob，因为16分解为两个大于等于5的数可以是：5 11；6 10；7 9；8 8。所以Bob不知道。

主持人问Alice，因为60分解出：5 12；6 10。然后Bob答不知道无法排除任何一个。所以Alice不知道。

主持人问Bob，因为Alice答不知道，所以肯定不是只有一种分解方案的数（例如55，如果Alice拿到的为55，55只能为5*11，Alice就知道了，反之），所以上面的5 11；7 9；8 8三个组合排除，只剩下了6 10。所以Bob知道了。

主持人问Alice，因为Bob知道了，所以可以排除5 12（因为如果Bob拿到的是17，Bob应该还有5 12；7 10；8 9可能，所以Bob应该是不知道），只剩下了6 10，所以Alice也知道了。

从上面的过程中可以看出方案的可能在保证有解的情况下一定是越来越少的，然后我们可以尝试着用f[i][j][k]表示一个数为i，另一个数为j，在k个不知道时是否被确定。

然后根据上面的过程写出暴力的转移方程：

1.如果f[i][j][k-2]已经确定了，那么f[i][j][k]肯定也是确定的（上一轮已经确定的，多一轮肯定也确定）

2.暴力枚举i和j其他的可能方案，拿Bob来举例，如果除f[i][j][k-2]外所有f[i-num][j+num][k-2]都已确定，那么f[i][j][k]就确定了，参考样例一中Bob回答知道的那一次，同样道理也使用于Alice。

将f数组处理出来然后就只要找到最小的那一组在t次不知道下首次被确定的i和j就好了。

另外因为f[i][j][k]与f[i][j][k-1]无关，所以可能存在f[i][j][k]确定，f[i][j][k-1]不确定的情况，需要判一下。

复杂度什么的不重要，好像后面的点一分钟一个，跑完20分钟左右

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>

#define Max 2005//最大值看心情，越大越慢，最大的答案好像也就300不到，数组小一点也没有关系

using namespace std;

inline char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define gc getchar
inline int read(){
    int x=0;char ch=gc();bool positive=1;
    for(;!isdigit(ch);ch=gc())if(ch=='-')positive=0;
    for(;isdigit(ch);ch=gc())x=x*10+ch-'0';
    return positive?x:-x;
}

inline void write(int x){
    if(x<0)x=-x,putchar('-');
    if(x>9)write(x/10);putchar(x%10+'0');
}

inline void writeln(int x){
    write(x);puts("");
}
//以上皆没用
int s,t;
bool flag,f[Max][Max][20];
char a[10];

inline bool check1(int x,int y,int t){
    int num=x*y,len=sqrt(x*y),xx=0,yy=0,cnt=0;
    for(int i=s;i<=len;i++){
        if(num%i==0){
        //枚举方案，然后暴力
            if((!f[i][num/i][t-1])||(!t)){
                xx=i;yy=num/i;
                cnt++;
            }
        }
    }//当只有x和y一种方案没有确定时f[x][y][t]就确定了
    if(cnt==1&&xx==x&&yy==y){
        return true;
    }else{
        return false;
    }
}//Alice的暴力转移

inline bool check2(int x,int y,int t){
    int num=x+y,len=(x+y)/2,xx=0,yy=0,cnt=0;
    for(int i=s;i<=len;i++){
    //转移同上
        if((!f[i][num-i][t-1])||(!t)){
            xx=i;yy=num-i;
            cnt++;
        }
    }
    if(cnt==1&&xx==x&&yy==y){
        return true;
    }else{
        return false;
    }
}//Bob的

inline bool check3(int x,int y,int t){
    int num=x*y,len=sqrt(x*y),xx=0,yy=0,cnt=0;
    for(int i=s;i<=len;i++){
        if(num%i==0){
        //与暴力转移差不多
            if(f[i][num/i][t]&&(t<2||(!f[i][num/i][t-2]))){
                xx=i;yy=num/i;
                ++cnt;
            }
        }
    }
    if(cnt==1&&xx==x&&yy==y){
        return true;
    }else{
        return false;
    }
}//特判

inline bool check4(int x,int y,int t){
    int num=x+y,len=(x+y)/2,xx=0,yy=0,cnt=0;
    for(int i=s;i<=len;i++){
        if(f[i][num-i][t]&&(t<2||(!f[i][num-i][t-2]))){
            xx=i;yy=num-i;
            ++cnt;
        }
    }
    if(cnt==1&&xx==x&&yy==y){
        return true;
    }else{
        return false;
    }
}//同上

int main(){
    freopen("guess.in","r",stdin);
    freopen("guess.out","w",stdout);
    s=read();
    scanf("%s",a+1);
    t=read();
    if(a[1]=='A')flag=true;else flag=false;//flag表示当前是Alice还是Bob
    for(int i=0;i<=t;i++,flag^=1){//dp
        for(int j=s;j<=1000;j++){
            for(int k=s;k<=1000;k++){
                if(i>=2)f[j][k][i]=f[j][k][i-2];//转移方程1
                if(flag){//根据Alice和Bob分开转移
                    f[j][k][i]=f[j][k][i]|check1(j,k,i);
                }else{
                    f[j][k][i]=f[j][k][i]|check2(j,k,i);
                }
            }
        }
    }
    int sum=2*s,x=0,y=0;
    while(true){//枚举i+j的值
        for(int i=s;i<=sum/2;i++){//枚举i
            x=i,y=sum-i;
            flag=f[x][y][t];//是否在t轮被确定
            if(!flag)continue;
            for(int j=0;j<t;j++){//是否在t轮首次被确定
                if(f[x][y][j]){
                    flag=false;
                    break;
                }
            }
            if(!flag)continue;
            if(((t&1)&&a[1]=='A')||((!(t&1))&&a[1]=='B')){//特判
                flag=check3(x,y,t);
            }else{
                flag=check4(x,y,t);
            }
            if(!flag)continue;
            write(x);putchar(' ');writeln(y);
            return 0;
        }
        sum++;
    }
    return 0;
}

```

---

## 作者：qinyubo (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P4459)

题意简述：

有两个绝顶聪明的人 $\text{Alice}$ 和 $\text{Bob}$ 玩游戏，

主持人偷偷想两个整数 $n,m$，

告诉他们 $s$ 表示 $s\le n\le m$（即要猜的数的下界），

然后告诉 $\text{Alice}$ $n\times m$，告诉 $\text{Bob}$ $n+m$。

接着，由他们两个轮流说自己知不知道这两个数是什么，

一堆不知道不知道不知道之后两个人就突然知道了，

现在告诉你 $s$ 和谁先说，要你构造一组 $n$ 和 $m$ 使得两人恰好说了 $t$ 次不知道之后两人都知道了。

$1\le s\le200$，$2 \le t\le15$，输入数据保证有解。

~~瑟瑟发抖的我想起了被小学奥数支配的恐惧。~~

首先，我们肯定要理解一下样例。

$n=6$，$m=10$，主持人告诉这两个人下界是 $5$，告诉 $\text{Alice}$ $60$，告诉 $\text{Bob}$ $16$。

$\text{Alice}$ 列出了她认为可能的 $(n,m)$：$(5,12)$，$(6,10)$

$\text{Bob}$ 列出了他认为可能的 $(n,m)$：$(5,11)$，$(6,10)$，$(7,9)$，$(8,8)$

第一轮：$\text{Bob}$ 说：不知道

此时 $\text{Alice}$ 看看她的两组解，当 $(n,m)=(5,12)$ 时，$\text{Bob}$ 得到 $17$，无法确定任何一组解，第一轮会说出不知道；当 $(n,m)=(6,10)$ 亦然。

第二轮：$\text{Alice}$ 说：不知道

此时 $\text{Bob}$ 看看她的四组解，当 $(n,m)=(5,11)$ 时，$\text{Alice}$ 获得 $55$，$\text{Alice}$ 会认为在 $5\le n\le m$ 时只有 $(5,11)$ 一组解而知道，但她刚刚说不知道，所以 $(5,11)$ 排除；同理，$(7,9)$、$(8,8)$ 排除，只剩下 $(6,10)$ 一组解。

第三轮：$\text{Bob}$ 说：知道

此时 $\text{Alice}$ 看看她的两组解，当 $(n,m)=(5,12)$ 时，$\text{Bob}$ 得到 $17$，可以得出 $(5,12)$，$(6,11)$，$(7,10)$，$(8,9)$ 四种情况，那么他在她第二轮说不知道后应该排除 $(6,11)$，剩下 $3$ 组解，不会在第三轮说知道，所以 $(5,12)$ 排除，只剩下 $(6,10)$ 一组解。

第四轮：$\text{Alice}$ 说：知道

~~话音刚落，全场观众掌声雷鸣，喜极而泣，深深折服于 $\text{Alice}$ 和 $\text{Bob}$ 的深邃而充满智慧的大脑。~~

所以，我们知道了这个游戏的玩法。然后，我们明确两点：

- 对于相同的 $n,m,s$，游戏的进程将一模一样。~~（废话~~

- 一个人要是知道了，另一个人如果不能立马知道，他就永远不会知道了，因为接下来知道的人会一直说知道。~~（还是废话~~

所以先知道的那个人是怎么知道的？

看看他是怎么想的：

>当 $(n,m)=(5,11)$ 时，$\text{Alice}$ 获得 $55$，$\text{Alice}$ 会认为在 $5\le n\le m$ 时只有 $(5,11)$ 一组解而知道，但她刚刚说不知道，所以 $(5,11)$ 排除；同理，$(7,9)$、$(8,8)$ 排除，只剩下 $(6,10)$ 一组解。

来，我们抽象化一下：

>当 $(n,m)=(\operatorname{xx},\operatorname{xx})$ 时，他会 $\operatorname{xxxx}$，从而在第 $\operatorname{xx}$ 轮就知道，但他刚刚说不知道，所以 $(\operatorname{xx},\operatorname{xx})$ 排除，同理 $(\operatorname{xx},\operatorname{xx})$、$(\operatorname{xx},\operatorname{xx})$ 排除，只剩下 $(\operatorname{xx},\operatorname{xx})$ 一组解。

所以，排除一组解的依据是

>如果是这组解的话，那么他早该知道了

顺着这个想，很容易想到 $\text{DP}$，于是设 $f_{i,j,k}$ 表示如果解是 $(j,k)$ 的话，第 $i$ 轮那个人作为先知道的那个人在第 $i$ 轮知不知道。

首先，如果这个人在上一次他说话时就知道了，那么这一次他肯定也知道，即如果 $f_{i-2,j,k}$ 为真，那么 $f_{i,j,k}$ 为真；

然后，如果在当前这个人看来的所有可行解中，只有 $(j,k)$ 是上一个人在上一轮无法确定的，如果是其他解那么上一个人在上一轮就知道了。

而由于我们的假设（这个人是先知道的那个人），上一个人会在上一轮说不知道，所以这个人就会把上一个人在上一轮就知道的解排除，只剩下 $(j,k)$，而变得知道。

假设当前是 $\text{Alice}$ 说话，那么如果 $f_{i-1,j,k}$ 为假，且对于任意 $x\ge s,y\ge s,x\times y=j\times k,(x,y)\neq(j,k)$ 的 $(x,y)$ 都有 $f_{i-1,x,y}$ 为真，就有 $f_{i,j,k}$ 为真；

假设当前是 $\text{Bob}$ 说话，那么如果 $f_{i-1,j,k}$ 为假，且对于任意 $x\ge s,y\ge s,x+y=j+k,(x,y)\neq(j,k)$ 的 $(x,y)$ 都有 $f_{i-1,x,y}$ 为真，就有 $f_{i,j,k}$ 为真；


然后，就可以愉快的 $\text{DP}$ 了。。。吗？

别忘了，我们假设这个人是先知道的那个人，如果他是后知道的那个人呢？

如果他是后知道的那个人，那么他应该要在先知道的那个人后立马知道，即在他看来的所有可行解中，只有 $(j,k)$ 是先知道者在上一轮才知道的，其他解先知道者要么早知道了，要么直到上一轮都不知道，所以可以立马判定是 $(j,k)$。

所以，我们还要额外多做一遍不同的 $\text{DP}$，否则：

>$\text{Alice}$ 一脸懵逼的看着主持人，表示你坑我呢，我咋知道是哪种？

代码：

```cpp
#include <bits/stdc++.h>
#define MAXN 500 // 怕万一所以把答案的上界设成了 500
using namespace std;
namespace QYB {
    int s, t; bool f[25][MAXN + 5][MAXN + 5]; string name;
    int main() {
        cin >> s >> name >> t; int cur = (name == "Alice");
        // f 就是 DP 数组，cur 表示当前是哪个人，1 为 Alice，0 为 Bob
        for (int i = 0; i <= t; i++, cur = 1 - cur) {
            for (int j = s; j <= MAXN; j++) {
                for (int k = j; k <= MAXN; k++) {
                    if (i >= 2 && f[i - 2][j][k]) {
                        f[i][j][k] = true; continue; // 如果上一次说话（也就是两轮前）就知道了
                    } bool ok = !i || !f[i - 1][j][k];
                    if (cur) for (int x = s; ok && x * x <= j * k; x++) {
                        ok &= j * k % x != 0 || x == j || i && f[i - 1][x][j * k / x];
                        // 枚举 Alice 看来的可行解，判断是否只有 (j, k) 是上一个人在上一轮无法确定的
                    } else for (int x = s; ok && x + x <= j + k; x++) {
                        ok &= x == j || i && f[i - 1][x][j + k - x];
                        // 枚举 Bob 看来的可行解，判断是否只有 (j, k) 是上一个人在上一轮无法确定的
                    } f[i][j][k] = ok;
                }
            }
        } for (int sum = 2 * s; sum <= 2 * MAXN; sum++) {
            for (int m = s, n = sum - s; m <= n; m++, n--) {
                if (f[t][m][n] && !f[t - 1][m][n] && !f[t - 2][m][n]) {
                    // 判断是否确实是第 t 轮才知道的，而不是两个人像个 SB 一样说知道说了半天 （/doge
                    bool ok = true;
                    if (cur) for (int x = s; ok && x * x <= m * n; x++) {
                        ok &= m * n % x != 0 || x == m || !f[t][x][m * n / x] || f[t - 2][x][m * n / x];
                        // !f[t][x][m * n / x] 即为最后一轮先知道者仍然不知道
                        // f[t - 2][x][m * n / x] 即为最后一轮前先知道者就已经知道了
                        // 如果有不同于 (m, n) 的 (x, y) 不满足上述两个条件
                        // 那么后知道者会无法区分 (m, n) 和 (x, y)，故不合法
                    } else for (int x = s; ok && x + x <= m + n; x++) {
                        ok &= x == m || !f[t][x][m + n - x] || f[t - 2][x][m + n - x]; // 同上
                    } if (ok) return !printf("%d %d\n", m, n);
                }
            }
        } return !printf("Orz, I cannot find a solution!\n"); // 显然不可能执行到这里
    }
} int main() {
    return QYB::main();
}
```

---

## 作者：Chen_jr (赞：6)


乍一看题感觉很懵逼，这两个人怎么通过知道和不知道判断数的？

从头思考一下。

首先，两个人根据下界和自己知道的信息，能够确定出可能的答案的集合。

他们能够用来筛选答案的信息只有对方的回答。

所以他们一定是通过之前另外一个人的回答去掉集合中与当前情况不符的答案。

当一个人的集合中只有唯一的一种答案时，他就会“知道”了。

这大概是一个递归的过程。

我们需要实现一个函数，能够对确定的 $n$ 和 $m$ 返回前若干次两个人的回答。

具体一点就是先通过已知信息（和或积）确定初始答案集合。

如果只需要一个回答，那么直接返回集合中是否只有一组解。

否则的话两个人开始依次筛选自己的答案集合，通过递归调用该函数删去不符合的部分。

每一轮的回答也是看自己的答案集合中是否只有一个数。

函数之外枚举答案进行检查，看看返回的回答是否为 $t$ 个 $0$ 后面两个 $1$ 即可。

然后加上记忆化就能过了。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;
int s, fi;
unordered_map<int, vector<bool>>mp[505][505];
vector<bool> work(int n, int m, int round){
	if(mp[n][m].count(round))return mp[n][m][round];
	vector<pii>x1, x2;		
	int x = n * m;
	for(int a = s; a <= x; ++a)if(x % a == 0){
		int b = x / a; if(a > b)break;
		x1.push_back(pii(a, b));
	}
	x = n + m;
	for(int a = s; a <= x; ++a){
		int b = x - a; if(b < a)break;
		x2.push_back(pii(a, b));
	}
	vector<bool>ans;
	if(fi & 1)ans.push_back(x1.size() == 1);
	else ans.push_back(x2.size() == 1);
	if(round == 1)return ans;
	vector<pii>tmp;
	for(int i = 2; i <= round; ++i){
		if((i & 1) == (fi & 1)){
			for(pii x : x1)if(work(x.first, x.second, i - 1) == ans)tmp.push_back(x);
			swap(tmp, x1); tmp.clear(); ans.push_back(x1.size() == 1);
		}else{
			for(pii x : x2)if(work(x.first, x.second, i - 1) == ans)tmp.push_back(x);
			swap(tmp, x2); tmp.clear(); ans.push_back(x2.size() == 1);
		}
	}
	return mp[n][m][round] = ans;
}
char name[10];
int main(){ 
	int round;
	scanf("%d%s%d",&s, name, &round);
	if(name[0] == 'A')fi = 1;
	else fi = 2;
	for(int sum = s + s; true; ++sum){
		for(int n = s; n <= sum; ++n){
			int m = sum - n;
			if(m < n)break;
			vector<bool>ans = work(n, m, round + 2);
			for(int i = 0; i < round; ++i)if(ans[i])goto X;
			if(ans[round] && ans[round + 1]){
				printf("%d %d\n", n, m); return 0;
			}
			X:;
		}
	}
	return 0;
}

```

---

## 作者：_•́へ•́╬_ (赞：5)

## 题意翻译

这两个人是咋猜出来的？

这个【不知道】~~不可以总司令~~传递的信息，是酱紫的：

每个人手上都有若干个备选答案。

当备选答案只剩一个，就知道了。

反过来，如果不知道，那么备选答案就不可能只剩一个。

所以可以把备选答案只剩一个的情况毙了。

然后就会产生另一些备选答案只剩一个的情况。

## 思路

判断一对 $n,m$ 是否合法：

如此做 $t$ 次。如果在 $t$ 次中就已经猜出来了，那么不合法。

然后判断在第 $t+1$ 次，是否能猜出来。

把备选答案恰好剩一个的留下来，其他的删了，判断在第 $t+2$ 次，是否能猜出来。（不判这个 88pts）

暴力枚举 $n,m$，暴力模拟判断。

## 运行效率

我这份代码交上去能过。

硬要算复杂度的话，粗略计算是 $\mathcal O(n^3\times\log n\times t)$。

我手捏的数据全超时了。但是这里的数据好像是设计好的，跑的飞快。

## code

```cpp
#include<stdio.h>
#include<string.h>
#define N 401
int s,t,f[N*N],g[N+N],pf[N*N],pg[N+N];char x[9],v[N][N*N];
main()
{
	scanf("%d%s%d",&s,x,&t);
	for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
		++pf[i*j],++pg[i+j];
	for(int a=s<<1;a<N+N;++a)for(int n=s,m,o;n<=a-n;++n)
	{
		m=a-n;
		for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
			v[i][j]=1;
		for(int i=s*s;i<N*N;++i)f[i]=pf[i];
		for(int i=s+s;i<N+N;++i)g[i]=pg[i];
		for(o=0;o<t;++o)if(o&1^(x[0]=='A'))
		{
			if(f[n*m]==1)break;
			for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
				if(v[i][j]&&f[i*j]==1)--f[i*j],--g[i+j],v[i][j]=0;
		}
		else
		{
			if(g[n+m]==1)break;
			for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
				if(v[i][j]&&g[i+j]==1)--f[i*j],--g[i+j],v[i][j]=0;
		}
		if(o<t)continue;
		if((o&1^(x[0]=='A'))&&f[n*m]==1)
		{
			for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
				if(v[i][j]&&(f[i*j]^1))v[i][j]=-1;
			for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
				if(v[i][j]>>8)--f[i*j],--g[i+j],v[i][j]=0;
			if(g[n+m]==1){printf("%d %d\n",n,m);return 0;}
		}
		if(!(o&1^(x[0]=='A'))&&g[n+m]==1)
		{
			for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
				if(v[i][j]&&(g[i+j]^1))v[i][j]=-1;
			for(int i=s;i<N;++i)for(int j=i;i*j<N*N&&i+j<N+N;++j)
				if(v[i][j]>>8)--f[i*j],--g[i+j],v[i][j]=0;
			if(f[n*m]==1){printf("%d %d\n",n,m);return 0;}
		}
	}
}
```

---

## 作者：zyctc (赞：4)

### 前言

是本题的一个奇怪的类似图论的理解法。

模考这套题的时候想到但写挂了，翻题解区看到一堆 dp 还以为是算法假了……感谢 @Mr_Stranger_CW 帮调代码

下文称 Alice 拿到的数为 $A$，Bob 拿到的数为 $B$。

### 从样例开始

样例中 $m=6$，$n=10$，$s=5$，从 Bob 开始。于是 $A=60$，$B=16$。

在第一轮，Bob 可以想到可能的组合有 $B=16=5+11=6+10=7+9=8+8$。显然是不可能直接推测出 $m$ 和 $n$ 具体是多少了，于是他决定推测一下 $A$ 遇到这几种可能都会做出什么样的反应（雾）

1. $m=5$，$n=11$。如果是这样，$A=55$。而 $55$ 要分解成两个 $\ge 5$ 的数只能是 $5\times 11$，因此 **Alice 会直接说知道**。
2. $m=6$，$n=10$。如果是这样，$A=60$。分解成两个 $\ge 5$ 的数可以是 $A=5\times 12=6\times10$。而 $6$ 和 $10$ 的情况已经分析过，Bob 会说不知道；$5$ 和 $12$ 则有 $B=5+12=6+11=7+10=8+9$，也会说不知道。所以在 Bob 说过一轮不知道以后两种情况都没有排除，**Alice 会说不知道**。
3. $m=7$，$n=9$。与第一种情况类似，$A=63$ 要分解成两个 $\ge 5$ 的数只能是 $7\times 9$，因此 **Alice 会直接说知道**。
4. $m=8$，$n=8$。同上，$A=64=8\times 8$，因此 **Alice 会直接说知道**。

而第二轮刚刚已经分析过了（第二种情况），拿了 $60$ 的 Alice 会说**不知道**。这时 Bob 就能锁定唯一的 Alice 会说不知道的情况，即 $m=6$、$n=10$，然后说**知道**。

### 换一个考虑方式

做到这儿了可以考虑画个图（是 $s=5$ 的情况），图中节点为 Alice/Bob 手上的数，边为 Alice/Bob 根据 $s\le m\le n$​ 推测出的可能情况。即 $A=x$​ 向 $B=y$​ 连边表示 $A$​ 手上拿到 $x$​ 后有某种分解因数的方式得到 $x=m\times n$​，$y=m+n$​。不难发现这样的推测是双向的（$A=x$​ 时会认为有可能 $B=y$​，$B=y$​ 时会认为有可能 $A=x$），所以下图边均为双向边。

![P4459-1](https://cdn.luogu.com.cn/upload/image_hosting/r8dxeabm.png)

> 图画的很好，下次不要画了

不妨假设第一轮为 Alice 来重新从这个图的角度考虑问题。可以发现，如果一个 A 节点只连出了一条双向边，并且 Alice 在这个节点（指如果 Alice 拿到了这个节点上的数字，下同），那么 Alice 将会在第一轮就说知道。因此如果 Alice 在第一轮说不知道，所有度数为 $1$​ 的 A 点都会被排除（排除时还要删除与之相连的边，因为与之相连的 B 点不会再认为这种情况可能发生了）。

> 同时我们也知道了若钦定第一轮为 Alice 且二人说过的不知道的次数 $t\ge1$，那么 Alice 最开始拿到的数不可能是这些节点上的值。 

此时考察第二轮，发现在若干 A 点被排除后，若此时某一 B 点度数为 $1$​​，也就是有可能的并且在前一轮没有被排除的情况只有一种，那么 Bob 在这个节点会说知道。反之，如果 Bob 说了不知道，那么 Alice 就可以排除掉当前度数为 $1$​​​ 的 B 点。

> 与上面类似，我们此时也知道了若 $t\ge2$​​，那么 Bob 拿到的数不可能是此时度数为 $1$ 的 B 节点上的值。 

依次类推，每轮说过的不知道都可以帮助二人排除当前说不知道的人的、度数为 $1$ 的点。我们也能确定这些节点不可能是 Alice 或 Bob 拿到的值。

### 很多轮不知道后

回到原题面，主持人钦定了二人一共说过 $t$​​ 次不知道以及第一轮开始的人。因此我们可以通过上述的方式删 $t$ 轮当前回合的人的度数为 $1$​ 的点，然后剩下一张可能的图 $S$。

此时下一个人（不妨设为 Alice）必须要说知道了，因此 Alice 所在的节点一定度数为 $1$。而考虑到 Bob 如果在 Alice 说完知道后还不知道，就没有人提供新信息了，所以 Bob 必须在知道 Alice 是 $S$ 中某一度数为 $1$ 的 A 点后确定是哪个度数为 $1$ 的 A 点。Bob 在 Alice 说知道前认为的可能情况就是与 Bob 所在节点相连的 A 节点。要想让 Bob 唯一确定，只能让 $\{S$ 中度数为 $1$ 的 A 点$\}$ 和 $\{S$ 中与 Bob 所在节点相连的 A 节点$\}$ 二者交集大小为 $1$。因此只与一个度数为 $1$​ 的 A 节点相连的 B 节点均为可行初值。

按照题目要求在这些可行的初值中取最优即可。代码实现考虑到题目中范围较小，直接暴力建边即可。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5,maxn=N+5,inf=0x3f3f3f3f;
int Min,t;
string Name;
int deg[2][maxn];
vector<int>e[2][maxn];
void init_map(){
    //Alice
    for(int i=Min;i<=N;i++)
    for(int j=i;j<=N;j+=i)//m=i,n=j/i
        if(j/i>=i)e[0][j].push_back(i+j/i);
    //Bob
    for(int i=Min;i<=N;i++)
    for(int j=i;j<=N&&1ll*i*j<=N;j++)//m=i,n=j
        e[1][i+j].push_back(i*j);
    //初始化度数
    for(int tp=0;tp<2;tp++)
        for(int x=1;x<=N;x++)
        for(auto i:e[tp][x])++deg[tp][x];
}
inline void Delete(int x,bool tp){//删点
    for(auto i:e[tp][x])if(deg[tp^1][i])
        --deg[tp^1][i],--deg[tp][x];
}
int ans1=inf,ans2=inf;
inline void ANS(int A,int B,bool t){//计算答案
    if(t)swap(A,B);
    int dec=sqrt(1ll*B*B-4ll*A),m,n;
    n=(dec+B)/2;m=B-n;
    if(m+n<ans1+ans2)ans1=m,ans2=n;
    else if((m+n==ans1+ans2)&&m<ans1)ans1=m,ans2=n;
}
int main(){
    ios::sync_with_stdio(0);
    cin>>Min>>Name>>t;
    init_map();
    int Turn=(Name[0]=='B');
    for(int i=1;i<=t;i++,Turn^=1)//筛掉度数为1的点
        for(int x=1;x<=N;x++)
        if(deg[Turn][x]==1)Delete(x,Turn);
    Turn^=1;//直接考虑第二个说知道的人
    for(int x=1;x<=N;x++)
    if(deg[Turn][x]>0){//如果当前点还能选
        int cnt=0,nx=0;
        for(auto i:e[Turn][x])
            if(deg[Turn^1][i]==1)
            	cnt++,nx=i;
        if(cnt==1)ANS(x,nx,Turn);
    }
    cout<<ans1<<" "<<ans2<<'\n';
    return 0;
}
```



---

## 作者：CXY07 (赞：4)

> 题目链接：[\[BJOI2018\] 双人猜数游戏](https://www.luogu.com.cn/problem/P4459)

> **本题解同步发布于 [My Blog](http://www.cxy07.blog/index.php/archives/528/)**

题意：

> 提交答案题。

> 现有 $\text{Alice},\text{Bob}$ 两人，要猜出两个数字 $m,n\ (m\le n)$。一开始 $\text{Alice}$ 知道 $m\times n$，$\text{Bob}$ 知道 $m+n$，两人同时知道一个下界 $s$，即 $s\le m\le n$。

> 从 $\text{Alice}$ 或 $\text{Bob}$，交替回答现在自己是否已经知道了 $m,n$。要求是两人在说了总共 $t$ 次“不知道”之后，同时知道了 $m,n$。

> 给出 $s,t$ 和从谁开始，构造一组合法的 $m,n$，使得 $m+n$ 最小的情况下，$m$ 的值最小。

> 对于 $100\%$ 的数据，满足 $1\le s\le 200,\ 2\le t\le 15$，数据保证有解。

挺有意思的题。

首先需要意识到，之所以在说了若干次“不知道”之后，知道了 $m,n$ 的取值，是因为之前另一人所说的“不知道”能够减少可能的 $(m,n)$。

以 $\text{Alice}$ 开头为例，考虑一些简单的情形。以下不考虑两数之间的大小关系。

如果第一轮 $\text{Alice}$ 就知道了呢？说明满足 $a\times b=m\times n$ 且 $a,b\ge s$ 的方案是唯一的。

如果第二轮 $\text{Bob}$ 就知道了呢？$\text{Bob}$ 知道的是 $m+n$，在所有 $a+b=m+n$ 且 $a,b\ge s$ 的 $(a,b)$ 中，“合法”的数对方案唯一。

这里的合法，意思是这对数在这轮之前还不能被另一个人猜到。例如在第二局中，数对 $(a,b)$ “合法”就指“满足 $c\times d=a\times b$ 且 $c,d\ge s$ 的方案不唯一”。

如果我们简单地称 $\{(a,b)|a+b=m+n,\ a,b\ge s\}$ 为“和拆分”，$\{(a,b)|a\times b=m\times n,\ a,b\ge s\}$ 为“积拆分”，那么：

- 第 $1$ 轮 $\text{Alice}$ 没猜到 $\to$ 积拆分不唯一。
- 第 $2$ 轮 $\text{Bob}$ 没猜到 $\to$ 和拆分中“积拆分不唯一”的元素不唯一。
- 第 $3$ 轮 $\text{Alice}$ 没猜到 $\to$ 积拆分中“和拆分中‘积拆分不唯一’的元素不唯一”的元素不唯一。

以此类推。虽然这样写下去非常绕，但是我们容易从中观察出类似递归的形式。

于是，尝试使用递归函数的形式描述上面的文字。

我们称“已经完成 $t$ 轮后，下一个回答”的人称为 $p$，另一人称为 $q$。

设 $f(t,a,b)$ 表示说了 $\le t$ 轮“不知道”后，$p$ 是否已经能猜到 $a,b$。注意到一个人只有在另外一个人说完话之后才会得到新信息。

先判掉边界情况，$f(0,a,b)$ 就意味着和拆分 / 积拆分中元素唯一。

然后，如果当前这个人在 $t-2$ 局后就已经能猜出了，那么这一轮肯定也行。

接着，枚举积拆分 / 和拆分，判断有多少个元素在当前这轮“合法”。如果这样的元素唯一，那么 $p$ 就猜到了，否则就是暂时还猜不到。

于是，我们就可以使用 $f(t,a,b)$ 来初步判断在 $t$ 次“不知道”后，当前 $p$ 能否猜出 $a,b$ 了。

怎么判断 $(a,b)$ 满足“在恰好 $t$ 次‘不知道’后，两个人**同时**猜到了”呢？

首先，$f(t,a,b)$ 应为真：这能保证在第 $t$ 轮的时候 $p$ 能够猜到。

其次，$f(t-2,a,b),f(t-1,a,b)$ 均应为假：这保证要恰好第 $t$ 轮之后两人才可能猜到。

我们使用 $g(a,b)$ 表示上述三个条件是否同时满足。

容易想到还有一个条件：在 $p$ 说完“我知道了”之后，$q$ 应该立即也知道了。但是这不代表 $f(t+1,a,b)$ 为真，因为此时有人说出“我知道了”，与 $f$ 的定义情形不符。

于是需要特殊判断，这相当于和拆分 / 积拆分中，“$g(a,b)$ 为真”的元素唯一。

套上记忆化，暴力从小到大枚举 $m+n$，并从小到大枚举 $m$ 即可通过。跑的很快，~~所以这题是提交答案题是不是因为出题人没法证明答案上界啊~~。

```cpp
//Code By CXY07 - It's My Fiesta.
#include<bits/stdc++.h>
using namespace std;

//#define FILE
//#define int long long
#define randint(l, r) (rand() % ((r) - (l) + 1) + (l))
#define abs(x) ((x) < 0 ? (-(x)) : (x))
#define popc(x) __builtin_popcount(x)
#define inv(x) qpow((x), mod - 2)
#define lowbit(x) ((x) & (-(x)))
#define ull unsigned long long
#define pii pair<int, int>
#define LL long long
#define mp make_pair
#define pb push_back
#define scd second
#define vec vector
#define fst first
#define endl '\n'
#define y1 _y1

const int MAXN = 20;
const int INF = 2e9;
const double eps = 1e-6;
const double PI = acos(-1);
//const int mod = 1e9 + 7;
//const int mod = 998244353;
//const int G = 3;
//const int base = 131;

int n, m, S, T, opt;
map<pii, bool> ok[MAXN];
string who;

template<typename T> inline bool read(T &a) {
	a = 0; char c = getchar(); int f = 1;
	while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { a = a * 10 + (c ^ 48); c = getchar(); }
	return a *= f, true;
}

template<typename A, typename ...B>
inline bool read(A &x, B &...y) { return read(x) && read(y...); }

bool f(int t, int a, int b) { // 说了 t 次之后,下个人是否已经知道
	if(a > b) swap(a, b);
	if(ok[t].count(mp(a, b))) return ok[t][mp(a, b)];
	if(t >= 2 && f(t - 2, a, b)) return true;
	int cnt = 0, sum = a + b, prod = a * b;
	if(t == 0) {
		if(!opt) {
			for(int i = S; i * i <= prod; ++i)
				if(prod % i == 0 && prod / i >= S) ++cnt;
			return ok[t][mp(a, b)] = (cnt == 1);
		} else {
			for(int i = S; i <= (sum >> 1); ++i)
				if(sum - i >= S) ++cnt;
			return ok[t][mp(a, b)] = (cnt == 1);
		}
	}
	if(!((t & 1) ^ opt)) { // Alice
		for(int i = S; i * i <= prod; ++i)
			if(prod % i == 0 && prod / i >= S && !f(t - 1, i, prod / i)) ++cnt;
		return ok[t][mp(a, b)] = (cnt == 1);
	} else { // Bob
		for(int i = S; i <= (sum >> 1); ++i)
			if(sum - i >= S && !f(t - 1, i, sum - i)) ++cnt;
		return ok[t][mp(a, b)] = (cnt == 1);
	}
} 

bool valid(int a, int b) { return f(T, a, b) && (!f(T - 2, a, b)) && (!f(T - 1, a, b)); }

signed main () {
#ifdef FILE
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
#endif
	read(S); cin >> who; read(T); opt = (who == "Bob");
	for(int sum = (S << 1); ; ++sum) {
		for(int a = S, b, prod, cnt; a <= (sum >> 1); ++a) {
			b = sum - a; prod = a * b, cnt = 0;
			if(!valid(a, b)) continue;
			if((T & 1) ^ opt) { // Alice
				for(int i = S; i * i <= prod; ++i)
					if(prod % i == 0 && prod / i >= S && valid(i, prod / i)) ++cnt;
				if(cnt != 1) continue;
			} else {
				for(int i = S; i <= (sum >> 1); ++i)
					if(sum - i >= S && valid(i, sum - i)) ++cnt;
				if(cnt != 1) continue;
			}
			printf("%d %d\n", a, b);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：a___ (赞：3)

水题，直接爆搜。   

根据题意，我们需要求出（$A/B$）在是否知道（$B/A$）知道（$A/B$）知道……的情况下仍然不知道的情况下仍然不知道的情况下仍然不知道。换句话说，就是将一个数拆成两个数的和，再将拆出的两个数的积拆成两个数的积，再将拆出的两个数的和拆成两个数的和……（$k$ 次）是否有不止一种方案。      

于是我们有如下爆搜代码：    
```cpp
std::unordered_map<int,std::unordered_map<int,bool>>ansA,ansB;//记忆化
int dfsA(int,int,int);
int dfsB(int,int,int);
int dfsB(int k,int sum,int mul)
{
    if(!k)return 1;
    if(ansB[k].count(sum))return ansB[k][sum];
    int cnt=0;
    for(int i=s;i<=sum-i;i++)
    {
        int n=i,m=sum-i;
        cnt+=dfsA(k-1,n+m,n*m);
    }
    return ansB[k][sum]=cnt>1;//超过一种方案时则不知道
}
int dfsA(int k,int sum,int mul)
{
    if(!k)return 1;
    if(ansA[k].count(mul))return ansA[k][mul];
    int cnt=0;
    for(int i=s;i*i<=mul;i++)if(mul%i==0)
    {
        int n=i,m=mul/i;
        cnt+=dfsB(k-1,n+m,n*m);
    }
    return ansA[k][mul]=cnt>1;
}
```

然后考虑如何判断恰好 $k$ 次才知道。   

> 以下讨论均基于 Bob ，Alice 同理。   

首先，我们要先判小于等于 $k$ 次时不知道。   
```cpp
bool flg=false;
for(int i=1;i<=k;i++)
if(((i&1)&&dfsB(i,sum,mul))||((((i&1)^1))&&dfsA(i,sum,mul)))continue;
else {flg=true;break;}
if(flg)continue;
```

然后要判下一个人知道。
>> 以下讨论基于 $k$ 为偶数，奇数时同理。  

```cpp
int cnt1=0;
for(int i=s;i<=sum-i;i++)
{
    int n=i,m=sum-i;
    cnt1+=dfsA(k,n+m,n*m);
}
if(cnt1!=1)continue;//仅有一种方案时，显然已经知道
```

然后要判下一个人也知道。   
```cpp
int cnt2=0,cntt;
for(int i=s;i*i<=mul;i++)//一次分解
if(mul%i==0)
{
    cnt1=0;cntt=0;
    int n=i,m=mul/i,sum=n+m;
    for(int i=s;i<=sum-i;i++)//二次分解
    {
        int n=i,m=sum-i;
        cnt1+=dfsA(k,n+m,n*m);//这次知道
        cntt+=dfsB(k-1,n+m,n*m);//上次不知道
    }
    if(cntt<=1||cnt1!=1)continue;
    ++cnt2;
}
if(cnt2!=1)continue;
```

然后就完了，剩下的就是分类讨论然后复制粘贴复制粘贴复制粘贴就好了。    

关于快速生成答案文件：   
```cpp
int main()
{
    char in[20],out[20];
    for(int i=1;i<=25;i++)
    {
        sprintf(in,"guess%d.in",i);
        sprintf(out,"guess%d.out",i);
        freopen(in,"r",stdin);
        freopen(out,"w",stdout);
        work();
        fflush(stdout);
        fclose(stdin);fclose(stdout);
        fprintf(stderr,"%d\n",i);
    }
    return 0;
}
```

其实不记忆化也能跑出来，就是会很慢，记忆化后提交代码，能过。   
[AC记录](https://www.luogu.com.cn/record/44999704)
[代码](https://www.luogu.com.cn/paste/8v2rw1dy)

---

## 作者：xzCyanBrad (赞：1)

视频题解。

![](bilibili:BV1zP4oeDEUW)

[上面视频崩了的话到 B 站看](https://www.bilibili.com/video/BV1zP4oeDEUW/)

复杂度 $O\left((\max ans)^2t\log t\right)$，上界很松（因为后面基本删完了）。

---

## 作者：myee (赞：1)

### 引言

思维题。

**这个做法跑得飞快，还不用 dp，也不是爆搜！**

复杂度（可能）为 $O(s^2t)$ 或 $O(s^2)$，实际效率也是飞快。

~~不过这题我直接提交答案了。~~

**注意：** 由于题解数学公式渲染版本过老，请在[此处](https://www.luogu.com.cn/paste/w5jkdqsg)查看附表。

### 思路

考虑 $A=mn,B=m+n$。

假设 $A$ 先手。

从 $A$ 中枚举分解方案，假设有 $(m_1,n_1)(m_2,n_2)\cdots(m_k,n_k)$ 这些合法。

如 $k>1$，会说不知道，称这样的 $A$ 构成集合 $A_{>0}$；否则知道，称这样的 $A$ 构成集合 $A_0$。

对 $B$ 分解，其有 $(s,B-s)(s+1,B-s-1)\cdots(\lfloor B/2\rfloor,\lceil B/2\rceil)$ 这些合法。

从中选出相乘为 $A_0$ 中元素的数对，若唯一，记这样的 $B$ 构成 $B_0'$，说明知道；若多于 $1$ 个，则无法计算；若不存在，若解集大小为 $1$，则构成集合 $B_0$，说明知道；若解集大小大于 $1$，构成集合 $B_{>0}$。

对 $B_0$ 集合类似地反推 $A_1'$，对 $B_{>0}$ 反推出 $A_1,A_{>1}$。

刚才的描述不够清晰，让我们形式化地说：

【附表 1】

查询 $t=0$，就是查询 $A_0/B_0'$；查询 $t=1$，就是查询 $B_0/A_1'$；查询 $t=2$，就是查询 $A_1/B_1'$；等等。

$A_{\ge1}$ 就是 $A$ 报了一次不知道后的可能集合；$B_{\ge1}$ 就是 $B$ 报了一次不知道后的可能集合；$A_{\ge2}$ 就是 $A$ 报了两次不知道后的可能集合；等等。

B 先手同理。

### 试看看！

~~你已经学会基本的思考方法了，让我们来做一些小练习吧！~~

实战一些数据。

#### 测试点 $2$

```plain
1 Alice 2
```

~~对，先 $2$ 再 $1$。~~

主要是因为啊，这个东西嘛，和我们刚刚说的一样，是 A 先手，不用重新转换视角。

对这种东西，我们可以考虑对下面的东西列表格：

$$f(A)=\max\{k|A\in A_{\ge k}\}$$

$$g(B)=\max\{k|B\in B_{\ge k}\}$$

这样的手算会简单一点。（？）

【附表 2】

因此 $m=1,n=4$ 最优。

#### 测试点 $1$

```plain
1 Bob 2
```

反过来枚举顺序，即得如下。

【附表 3】

$m=n=2$ 最优。

#### 测试点 $3$

```plain
2 Bob 2
```

类似，但是要手枚更多项。

【附表 4】

$m=3,n=4$ 最优。

注意不是 $2,4$——$8$ 已经置 $0$ 了！

#### 测试点 $4$

```plain
11 Bob 2
```

已经不能指望手算了——刚刚的那组数据都很困难。

考虑代码实现以上过程。

$t=2$ 时，$B=m+n$ 在 $4s$ 内较有可能，考虑仅计算 $mn\le4s^2+100,m+n\le5s+100$ 的部分解集。

首先提取范围内的 $A_{\ge0}$ 与 $B_{\ge0}$，并算出对应的 $X(A),Y(B)$。

然后枚举 $B_0$，得到 $B_{\ge1}$。

枚举 $A_0$，得到 $A_{\ge1}$。

枚举 $B_1$，进而得解。

成功地，给出了解 $n=15,m=16$。

#### 测试点 $5$

```plain
18 Bob 2
```

这个给出的解为 $n=21,m=24$，交了一下是错的，是不是我们给的界不够大？

不是，其实是因为，我们没有再校验 $A_1'$！

在从 $B_1$ 推断 $A_1'$ 后，我们还要校验其合法性：$A_1'$ 不一定可以被唯一决策！

验证完后即得正解 $n=20,m=27$。

#### 测试点 $6\sim10$

```plain
28 Bob 2
28 Alice 2
57 Alice 2
111 Alice 2
200 Alice 2
```

把从 $A$ 出发的情况实践一下 容易依次得解。

这样我们就解决了 $t=2$ 的部分（测试点 $1\sim10$），答案依次为

```plain
2 2
1 4
3 4
15 16
20 27
35 40
28 45
65 72
114 140
200 242
```

可以拿到 $\rm40pts$。

以下是暴力代码。

```cpp
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    static chr Op[50];
    uint s,t;scanf("%u%s%u",&s,Op,&t);
    if(t!=2)exit(0);
    static std::vector<std::pair<uint,uint> >X[1000005],Y[1000005];
    uint Lim1=4*s*s,Lim2=5*s;
    for(uint m=s;m<=Lim2;m++)for(uint n=m;n*m<=Lim1&&n+m<=Lim2;n++){
        X[n*m].push_back({m,n});
        Y[n+m].push_back({m,n});
    }
    static bol Xi[1000005],Yi[1000005];
    std::vector<uint>Ag,Bg;
    for(uint i=1;i<=Lim1;i++)if(X[i].size())Ag.push_back(i),Xi[i]=1;
    for(uint i=1;i<=Lim2;i++)if(Y[i].size())Bg.push_back(i),Yi[i]=1;
    if(Op[0]=='B'){
        std::vector<uint>User;
        User.clear();
        for(auto b:Bg){
            uint c=0;
            for(auto g:Y[b])c+=Xi[g.first*g.second];
            if(c>=2)User.push_back(b);
            else Yi[b]=0;
        }
        Bg=User,User.clear();
        for(auto a:Ag){
            uint c=0;
            for(auto g:X[a])c+=Yi[g.first+g.second];
            if(c>=2)User.push_back(a);
            else Xi[a]=0;
        }
        Ag=User,User.clear();
        for(auto b:Bg){
            uint c=0;
            for(auto g:Y[b])c+=Xi[g.first*g.second];
            if(c==1)User.push_back(b);
            else Yi[b]=0;
        }
        for(auto b:User)for(auto g:Y[b])if(Xi[g.first*g.second]){
            uint c=0;
            for(auto p:X[g.first*g.second])c+=Yi[p.first+p.second];
            if(c==1){
                printf("%u %u\n",g.first,g.second);
                return 0;
            }
        }
    }
    else{
        std::vector<uint>User;
        User.clear();
        for(auto a:Ag){
            uint c=0;
            for(auto g:X[a])c+=Yi[g.first+g.second];
            if(c>=2)User.push_back(a);
            else Xi[a]=0;
        }
        Ag=User;
        User.clear();
        for(auto b:Bg){
            uint c=0;
            for(auto g:Y[b])c+=Xi[g.first*g.second];
            if(c>=2)User.push_back(b);
            else Yi[b]=0;
        }
        Bg=User,User.clear();
        for(auto a:Ag){
            uint c=0;
            for(auto g:X[a])c+=Yi[g.first+g.second];
            if(c==1)User.push_back(a);
            else Xi[a]=0;
        }
        uint x=-1,y=-1;
        for(auto a:User)for(auto g:X[a])if(Yi[g.first+g.second]){
            uint c=0;
            for(auto p:Y[g.first+g.second])c+=Xi[p.first*p.second];
            if(c==1){
                if(g.first+g.second<x+y||(g.first+g.second==x+y&&g.first<x))
                    x=g.first,y=g.second;
            }
        }
        printf("%u %u\n",x,y);
    }
    return 0;
}
```

#### 测试点 $11\sim25$

看下面 $5$ 组数据（$11\sim15$）。

```plain
1 Bob 3
69 Alice 3
147 Alice 4
88 Alice 5
109 Bob 6
```

考虑到刚刚的做法，其不能进一步应用于 $t>2$，主要是因为我们无法确定答案的值域，刚刚的做法是挂掉的（必须得有数目足够多的元素在外围“盖住”当前的答案，使得不会有更小解被误选择）。

我们猜测实际值域不会很大，尝试把刚才的过程再做几轮，试着跑一跑？

这部分代码如下：

```cpp
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    static chr Op[50];
    uint s,t;scanf("%u%s%u",&s,Op,&t);
    if(t>6)exit(0);
    static std::vector<std::pair<uint,uint> >X[1000005],Y[1000005];
    uint Lim1=4*s*s+100,Lim2=5*s+100;
    for(uint m=s;m<=Lim2;m++)for(uint n=m;n*m<=Lim1&&n+m<=Lim2;n++){
        X[n*m].push_back({m,n});
        Y[n+m].push_back({m,n});
    }
    static bol Xi[1000005],Yi[1000005];
    std::vector<uint>Ag,Bg;
    for(uint i=1;i<=Lim1;i++)if(X[i].size())Ag.push_back(i),Xi[i]=1;
    for(uint i=1;i<=Lim2;i++)if(Y[i].size())Bg.push_back(i),Yi[i]=1;
    std::vector<uint>User;
    for(uint i=0;i<t;i++)if(!(i&1)==(*Op=='B')){
        for(auto b:Bg){
            uint c=0;
            for(auto g:Y[b])c+=Xi[g.first*g.second];
            if(c>=2)User.push_back(b);
            else Yi[b]=0;
        }
        Bg=User,User.clear();
    }
    else{
        for(auto a:Ag){
            uint c=0;
            for(auto g:X[a])c+=Yi[g.first+g.second];
            if(c>=2)User.push_back(a);
            else Xi[a]=0;
        }
        Ag=User,User.clear();
    }
    if((t&1)==(*Op=='B')){
        for(auto a:Ag){
            uint c=0;
            for(auto g:X[a])c+=Yi[g.first+g.second];
            if(c==1)User.push_back(a);
            else Xi[a]=0;
        }
        uint x=-1,y=-1;
        for(auto a:User)for(auto g:X[a])if(Yi[g.first+g.second]){
            uint c=0;
            for(auto p:Y[g.first+g.second])c+=Xi[p.first*p.second];
            if(c==1){
                if(g.first+g.second<x+y||(g.first+g.second==x+y&&g.first<x))
                    x=g.first,y=g.second;
            }
        }
        printf("%u %u\n",x,y);
    }
    else{
        for(auto b:Bg){
            uint c=0;
            for(auto g:Y[b])c+=Xi[g.first*g.second];
            if(c==1)User.push_back(b);
            else Yi[b]=0;
        }
        for(auto b:User)for(auto g:Y[b])if(Xi[g.first*g.second]){
            uint c=0;
            for(auto p:X[g.first*g.second])c+=Yi[p.first+p.second];
            if(c==1){
                printf("%u %u\n",g.first,g.second);
                return 0;
            }
        }
    }
    return 0;
}
```

依次分别得到

```plain
1 4
80 84
162 170
100 110
126 128
```

似乎……也不是很大？

交一下……是对的！

胆子放大点，继续来做 $16\sim20$！

把代码改一下，运行

```plain
4 Bob 7
117 Alice 8
161 Alice 9
134 Alice 10
77 Bob 11
```

得到输出

```plain
4 12
128 135
182 184
135 176
78 108
```

还是很小啊！

直接把剩下的（$21\sim25$）都跑一遍。

```plain
177 Bob 12
178 Bob 13
179 Bob 14
180 Bob 15
178 Alice 15
```

得到输出

```plain
185 216
180 222
192 210
180 224
196 208
```

直接就过了！！！

总复杂度不会证明，但应该是 $O(s^2t)$ 或 $O(s^2)$ 的。

### Code

最终代码不给了，把上面那个 $t\le6$ 的代码改一改就是了。

~~提交答案题一份代码速通的艺术是怎样的啊~~。


---

## 作者：ainivolAGEM (赞：0)

### 题目大意

Alice 和 Bob 两个人在玩“最强大佬”猜数游戏，主持人会先想两个数 $N, M$，告诉两个人一个数 $S$，保证 $S \leq\ M \leq\ N$。然后告诉 Alice $N \times M$ 的值，告诉 Bob $N + M$ 的值。接着主持人进行 $T$ 个提问，由 Alice 和 Bob 轮流回答，每次都回答“知道”或“不知道”。请构建出一组 $N, M$，使主持人在 $T$ 个提问后两个人都知道 $N, M$ 的值了。

### 解题思路

这道题乍一看还挺玄学的，就两个人在那说着说着不知道然后突然就都知道了。

认真分析一下，既然知道 $N$ 与 $M$ 的范围，那两个人就可以根据自己的信息求出所有可能的组合，然后根据别人知不知道排除与信息不符的选项，从而得出结果了。

举个样例 1 例子：

- 第一次提问，Bob 拿到的信息为 $N + M = 16$，他可以知道 $N,M$ 为 $5 + 11$ 或 $6 + 10$ 或 $7 + 9$ 或 $8 + 8$，但是此时 Bob 没有任何信息排除任意一个选项，所以 Bob 不知道。

- 第二次提问，Alice 拿到的信息为 $N \times M = 60$，他可以知道 $N,M$ 为 $5 \times 12$ 或 $6 \times 10$，但是 Bob 的不知道对于 Alice 并没有什么帮助，不能排除选项，所以 Alice 也不知道。

- 第三次提问，鉴于 Bob 的信息乘积分别为 $55$，$60$，$63$ 和 $64$，而 Alice 却不知道，所以可以得出乘积分解情况肯定不止一种，但是除了 $60$ 以外，其余三个数在合法的乘积分解情况中都只有一种，所以 Bob 可以确定。

- 第四次提问，鉴于 Alice 可得的和为 $17$ 或 $16$，而且 Bob 可以确定了，那么可以直接排除 $17$。因为如果 Bob 得到的和为 $17$，$17$ 还有 $N = 8 , M = 9$ 的情况，Bob 应该不知道，但是 Bob 直接知道了，所以绝对不是 $17$。排除完之后，Alice 就也可以确定了。

所以大致思路就是，每日根据自己的信息解出所有可能的组合，通过对方的信息筛掉其他的组合，最后剩下一个情况时就可以确定了。

看看这道题的数据，看起来范围并不是很大。所以我们直接**枚举** $N$ 和 $M$ 的所有情况，然后使用一个函数判断即可。

怎么判断呢？可以用**递归**！这个递归的目的就是求出指定的 $N$ 和 $M$ 前若干次两个人的回答情况。

如果只需要一次回答了，就返回当前所有情况集合中是否只有一个元素。否则就两个人轮流搜索递归调用，把不符合的情况删去，把答案保存在一个 `vector` 里，在函数结束后检查 $T$ 次询问的最后两个是否为两个 $1$ 就可以了。

最后就是每个点用程序跑一遍，直接提交即可。

### 注意事项

递归需要加上记忆化，否则会 TLE。

### AC code

这里给出用来跑的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef pair<ll,ll> P;
const int N=504;
ll s,beg;
unordered_map<ll,vector<bool>>mp[N][N];
string name;
vector<bool> dfs(ll n,ll m,ll t){
	if(mp[n][m].count(t)){
		return mp[n][m][t];
	}
	vector<P> a;
	vector<P> b;	
	ll x=n*m;
	for(int i=s;i<=x;i++){
		if(x%i==0){
			ll j=x/i;
			if(i>j){
				break;
			}
			a.push_back(P(i,j));
		}
	}
	x=n+m;
	for(int i=s;i<=x;i++){
		ll j=x-i;
		if(j<i){
			break;
		}
		b.push_back(P(i,j));
	}
	vector<bool> ans;
	if(beg&1){
		ans.push_back(a.size()==1);
	}else{
		ans.push_back(b.size()==1);
	}
	if(t==1){
		return ans;
	}
	vector<P> tmp;
	for(int i=2;i<=t;i++){
		if((i&1)==(beg&1)){
			for(P x:a){
				if(dfs(x.first,x.second,i-1)==ans){
					tmp.push_back(x);
				}
			}
			swap(tmp,a);
			tmp.clear();
			ans.push_back(a.size()==1);
		}else{
			for(P x:b){
				if(dfs(x.first,x.second,i-1)==ans){
					tmp.push_back(x);
				}
			}
			swap(tmp,b);
			tmp.clear();
			ans.push_back(b.size()==1);
		}
	}
	return mp[n][m][t]=ans;
}
int main(){ 
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0); 
	ll t;
	cin>>s>>name>>t;
	if(name[0]=='A'){
		beg=1;
	}else{
		beg=2;
	}
	for(int sum=s+s;true;sum++){
		for(int n=s;n<=sum;n++){
			ll m=sum-n;
			if(m<n){
				break;
			}
			vector<bool> ans=dfs(n,m,t+2);
			for(int i=0;i<t;i++){
				if(ans[i]){
					goto X;
				}
			}
			if(ans[t]&&ans[t+1]){
				cout<<n<<' '<<m;
				exit(0);
			}
			X:;
		}
	}
}
```

最后，祝各位能 AC 这道题！

---


# [CTSC2006] 歌唱王国

## 题目描述

在歌唱王国，所有人的名字都是一个非空的仅包含整数 $1\sim n$ 的字符串。

王国里生活着一大群咕噜兵，他们靠不停地歌唱首领——牛人酋长们的名字来获取力量。咕噜兵每一次歌唱过程是这样的：首先，他从整数生成器那儿获得一个数字，然后花一个时间单位将此数字唱出来，如果他发现某个牛人酋长的名字已经被歌唱出来（即此名字是歌唱序列的一个连续子串），那么这次歌唱过程就立即结束。

相关名词定义：

- 歌唱序列：如果某人歌唱了 $x$ 个数字，第 $i$ 次歌唱的数字为 $a_i$，那么歌唱序列 $=(a_1,a_2,\cdots,a_x)$。
- 整数生成器：歌唱王国的神物，它有一个按钮，如果你按一下按钮，将从 $1\sim n$ 数字中等概率的随机返回一个整数。
- 歌唱时间：在一次歌唱过程中花费的时间。

歌唱时间是随机的，无法预料；不过歌唱时间的期望值是固定的，此期望值即平均来说歌唱时间有多长，亦可称作平均歌唱时间。

王国里的人非常喜欢歌唱，他们希望歌唱的时间越长越好，所以他们决定罢免一些牛人酋长，使得平均歌唱时间变长。但是他们不能罢免掉所有的牛人酋长，否则他们每次歌唱都无法停止，无法获取力量；于是他们决定只保留一个牛人酋长而罢免其余的牛人酋长。

你的任务是：对于给定的 $n$、牛人酋长的个数 $t$ 以及每一个牛人酋长的名字，告诉王国里的人们，对于 $1\leq i\leq t$，如果保留第 $i$ 个牛人酋长，罢免掉其余的，那么平均歌唱时间将是多少。

提示：此数为一个非负整数！

输出要求：由于这个数字太大，所以你只需输出这个数的末 $4$ 位数字。如果不足 $4$ 位，则前面补 $0$（见样例）。


## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$t\leq 50$，$1\leq m_i\leq 10^5$。

## 样例 #1

### 输入

```
2 2
1 1
3 1 2 1```

### 输出

```
0002
0010```

# 题解

## 作者：WYXkk (赞：108)

其他题解都是生成函数做的，这里给个更加直观的方法（[事实上可以严格化](https://www.luogu.com.cn/blog/WYXkk/p4548-di-zhi-guan-li-xie-di-tong-su-yan-ge-hua)，不过需要更高层次的数学知识）。

这个方法是从[这篇知乎回答](https://www.zhihu.com/question/330408241/answer/777567811)里看来的。

假设已经只保留了一个牛人酋长，其名字为 $A=a_1a_2\cdots a_l$。

假设王国旁边开了一座赌场，每单位时间（就称为“秒”吧）会有一个赌徒带着 $1$ 铜币进入赌场。

赌场规则很简单：可以支付 $x$ 铜币赌下一秒会唱出 $y$，如果猜对了就返还 $nx$ 铜币，否则不返还。显然，这是一个公平赌博。

每个赌徒会如下行动：支付 $1$ 铜币赌下一秒会唱出 $a_1$，如果赌对了就支付得到的 $n$ 铜币赌下一秒会唱出 $a_2$，如果还对了就支付得到的 $n^2$ 铜币赌下一秒会唱出 $a_3$，等等，以此类推，最后支付 $n^{l-1}$ 铜币赌下一秒会唱出 $a_l$。

一旦连续唱出了 $a_1a_2\cdots a_l$，赌场老板就会认为自己亏大了而关门，并驱散所有赌徒。

那么关门前发生了什么呢？以 $A=\{1,4,1,5,1,1,4,1\},n=5$ 为例：

- 最后一位赌徒拿着 $5^1$ 铜币离开；
- 倒数第三位赌徒拿着 $5^3$ 铜币离开；
- 倒数第八位赌徒拿着 $5^8$ 铜币离开；
- 其他所有赌徒空手而归。

$1,3$ 实际上就是原序列的所有 border 的长度。

这时候最神奇的一步来了：由于这个赌博游戏是公平的，因此赌场应该期望下不赚不赔，因此关门时期望来了 $5+5^3+5^8$ 个赌徒，因此期望需要 $5+5^3+5^8$ 单位时间唱出这个名字。

同理，即可知道对于一般的 $A$，答案为：

$$\sum\limits_{a_{[1,c]}=a_{[n-c+1,n]}} n^c$$

直接跑一遍 KMP 求出 border 就好了。代码很短也很好写，略了。

---

## 作者：Sweetlemon (赞：57)

### 神奇的概率生成函数——歌唱王国

#### 题意

字符集大小为 $n$。有 $t$ 组数据。

每一组数据包含一个长度为 $m$ 的字符串 $S$。现在有一个空串 $T$，每一次在字符集内随机一个字符加入到 $T$ 的末尾，当 $S$ 是 $T$ 的子串时停止。求停止时 $T$ 的期望长度。

#### 做法简述

思路太清奇了，我也不知道怎么描述这个思路。这篇题解只能做到“尽量讲清楚这个做法”吧。

需要用到：生成函数基本知识（包括求导等）、KMP。

##### 概率生成函数的性质

首先让我们认识一个叫概率生成函数的东西：$f(x)=\sum_{i=0}^{+\infty} \mathrm{P}(X=i)x^i$，也就是 $i$ 次项的系数是随机变量 $X$ 等于 $i$ 的概率。

这个东西有什么用呢？这道题着重用到它的两个性质。

1. $f(1)=1$。$f(1)$ 其实就是把 $f(x)$ 的所有系数加起来，而这里的系数就是概率；因此 $f(1)$ 实际上就是把所有可能情况的概率加起来，于是 $f(1)=1$。

2. 我们要求的是期望，和这个概率生成函数有什么关系呢？想一想，上面的式子想出现期望，是不是需要在 $\mathrm{P}(X=i)$ 上乘一个 $i$ 呀？如何让这个 $i$ 出现呢？求导啊。于是这个式子也就可以理解了：$f'(x)=\sum_{i=1}^{+\infty}i\mathrm{P}(X=i)x^{i-1}$。为了全部加起来，我们令 $x=1$，得到 $f'(1)=\sum_{i=1}^{+\infty}i\mathrm{P}(X=i)=\mathrm{E}(X)$。

总结一下，概率生成函数和它的导函数在 $x=1$ 处的取值都很特殊，分别是 $f(1)=1,f'(1)=\mathrm{E}(X)$。

##### 引入概率生成函数

先设一个变量 $Y$ 表示（任意一次随机的过程中）停止的时候 $T$ 的长度，也就是随机了 $Y$ 个字符的时候恰好随机出 $S$。

引入两个概率生成函数 $f(x)$ 和 $g(x)$，分别表示 $Y=i$ 的概率和 $Y>i$ 的概率。也就是 $f(x)=\sum_{i=0}^{+\infty}\mathrm{P}(Y=i)x^i$，$g(x)=\sum_{i=0}^{+\infty}\mathrm{P}(Y>i)x^i$。

方便起见，我们用 $f_i$ 表示 $f(x)$ 的 $x^i$ 项系数，$g_i$ 同理。那么，$f_i$ 就表示随机了 $i$ 个字符恰好停止的概率，$g_i$ 表示随机了 $i$ 个字符还没有停止的概率。

##### 第一个式子

接下来我们建立一个 $f$ 和 $g$ 的递推式。

$g_{i}=\mathrm{P}(Y>i)=\mathrm{P}(Y\ge i+1)=\mathrm{P}(Y=i+1)+\mathrm{P}(Y>i+1)=f_{i+1}+g_{i+1}$。每一个等号分别是用了定义、整数的离散性、分类讨论（或者说全概率公式）和定义。$i$ 的范围是 $i\ge 0$。

把这个式子整理成生成函数，那么就有 $xg(x)+1=f(x)+g(x)$。$+1$ 是处理边界项 $g_0=1$（因为不可能一个字符也没有就停止了，$Y$ 必定大于 $0$，因此 $g_0=1$）。

由于我们要求的是 $f'(1)$，因此上面的式子整理成 $f(x)=(x-1)g(x)+1$，再求导得 $f'(x)=g(x)+(x-1)g'(x)$，于是有 $f'(1)=g(1)$，这是不是非常好？

##### 第二个式子

接下来的过程就非常奇妙了。

我们设一个新的数列 $h_i\ (i\ge 0)$，表示同时满足以下两个条件（记为事件 $A$）的概率：

1. 随机了 $i$ 个字符还没有出现 $S$
2. 接着**无条件**随机 $m$ 个字符（注意 $m$ 是 $S$ 的长度），且这 $m$ 个字符恰好是 $S$

什么叫“无条件”呢？就是随机这 $m$ 个字符的过程中，有可能还没随机够 $m$ 个，就已经出现 $S$ 了。这种情况下我们强迫它一定要随机够 $m$ 个。

相当于，$h_i$ 表示的是这一个事件 $A$ 的发生概率：

有一天你开始随机，随机了 $i$ 个字符还没有随机出 $S$，你失去了耐心，说：“无论如何，再给我随机 $m$ 个！”然后 $m$ 个过后，你发现这 $m$ 个字符恰好是 $S$！

解释了 $h_i$ 的含义，如何计算 $h_i$ 呢？

**第一种方法**比较简单。上面两个条件是彼此独立的，因此可以把“随机了 $i$ 个字符都没有停止”和“无条件随机 $m$ 个字符，恰好得到 $S$”的概率乘起来，也就是 $h_i=g_i n^{-m}$（注意，$n$ 是字符集大小）。

**第二种方法**比较神奇，运用了分类讨论（或者说全概率公式）。

我们注意到，如果事件 $A$ 发生，那么第一次出现 $S$ 的时刻（也就是上面定义的 $Y$）一定满足 $i<Y\le i+m$（$i+m$ 的时候一定已经出现了 $S$，所以 $Y\le i+m$）。因此我们讨论 $Y$ 的每一个取值。

假设 $Y=y$，那么这个前提的概率就是 $f_y$。下面只需要求出在这个前提下事件 $A$ 发生的概率，再把这个概率乘以 $f_y$ 并全部加起来（根据全概率公式）就好了。

这个前提下事件 $A$ 发生的概率是多少呢？

记 $t=y-i\ (0<t\le m)$。那么 $y$ 时刻（也就是第一次出现 $S$ 的时候），已经随机了这 $m$ 个字符中的 $t$ 个了。如果要发生事件 $A$，就得满足，这 $t$ 个字符恰好是 $S$ 的前 $t$ 个（条件 a），并且后面再随机的 $m-t$ 个字符恰好是 $S$ 的剩余 $m-t$ 个字符（条件 b）。

然而，由于 $y$ 时刻恰好出现了 $S$，那也就意味着这 $t$ 个新的字符也恰好是 $S$ 的那个长度为 $t$ 的后缀。也就是说，这 $t$ 个字符是确定的。条件 a 能够满足，就等价于，这个后缀必须同时也是 $S$ 的前缀——想到了什么？这就是说，这个后缀必须是 $S$ 的 border！（注意，这里和 border 的一些定义有所不同的是，我们认为 $S$ 本身也是 $S$ 的一个 border。也就是说，只要一个串既是 $S$ 的前缀，又是 $S$ 的后缀，那么我们就把这个串叫做 $S$ 的 border。）总结一下，条件 a 等价于这个长度为 $t$ 的后缀是 $S$ 的 border。

条件 b 是概率性的，剩下来的字符和前面的是独立的，因此这 $m-t$ 个字符满足要求的概率就是 $n^{-(m-t)}=n^{t-m}$。

因此，$Y=y,\ t=y-i$ 的**前提下**，同时满足条件 a 和 b 的概率（也就是事件 $A$ 发生的概率）是 $\mathrm{isborder}(t)\times n^{t-m}$，其中 $\mathrm{isborder}(t)$ 的取值为 $1$ 或 $0$，表示长度为 $t$ 的后缀是否是 $S$ 的一个 border。

根据全概率公式，把所有可能情况的概率加起来，事件 $A$ 发生的概率就是 $\sum_{t=1}^{m}f_{i+t}n^{t-m}\mathrm{isborder}(t)$（注意 $t=y-i,\ y=i+t$，因此 $f_y=f_{i+t}$）。

上面的式子换一种写法就是 $h_i=\sum_{S\text{的} t \text{长border}} f_{i+t}n^{t-m}$，这个求和号的意思是对所有 $S$ 的 border 求和，求和的时候把这个 border 的长度带入到被求和式当中的 $t$ 中。

整理一下，我们用两种方法计算 $h_i$，分别得到了 $h_i=g_i n^{-m}$ 和 $h_i=\sum_{S\text{的} t \text{长border}} f_{i+t}n^{t-m}$，因此 $g_i n^{-m}=\sum_{S\text{的} t \text{长border}} f_{i+t}n^{t-m}$。这又是一个关于 $g$ 和 $f$ 的式子！

上面这个式子两边乘以 $n^m$ 得到 $g_i=\sum_{S\text{的} t \text{长border}} f_{i+t}n^{t}$，看上去好多了。

接下来要把这个式子弄成生成函数的形式。注意到下标不一样，那肯定是移位了。

把 $g(x)$ 乘以 $x^m$，第 $i+m$ 项的系数变成了 $g_i$。

把 $f(x)$ 乘以 $x^{m-t}$，第 $i+m$ 项的系数变成了 $f_{(i+m)-(m-t)}=f_{i+t}$。

因此，上面的式子整理成生成函数就是 $x^mg(x)=\sum_{S\text{的} t \text{长border}} x^{m-t}f(x)n^{t}$。

##### 得到答案

上面的式子看上去还是很丑是吧？别忘了我们只要求出 $g(1)$ 就是答案了。

将 $x=1$ 代入上面的式子得到 $g(1)=\sum_{S\text{的} t \text{长border}} f(1)n^{t}$，又根据概率生成函数的性质，$f(1)=1$，因此 $g(1)=\sum_{S\text{的} t \text{长border}} n^{t}$。太神奇了！

根据这个式子，答案就是 $\sum_{S\text{的} t \text{长border}} n^{t}$。因此我们只需要找出 $S$ 的所有 border，把 $n^t$ 累加到答案里就可以了。这个可以用 KMP，或者由于我们可以枚举 border 长度，用哈希判断前后缀是否相等。

时间复杂度 $O(m)$。

特别注意：如果用 KMP 求，一定记得这道题中 $S$ 本身也算 $S$ 的一个 border！

#### 代码实现

式子推完了，代码应该非常容易写。提供我用 KMP 写的代码。

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define MAXIOLG 25
#define FILENAME(x) \
freopen(x".in","r",stdin); \
freopen(x".out","w",stdout);
#define MAXN 100005
#define MOD 10000
#define N 100000
#define MD(x) (((x)>=MOD)?((x)-=MOD):(0))
using namespace std;

typedef long long ll;
typedef long double ld;
typedef ll io_t;
io_t shin[MAXIOLG];
io_t seto(void); //快读，实现略去
void ayano(io_t x,char spliter='\n'); //快写，本题没用到

int spw[MAXN]; // 字符集大小（题目中的 n）的幂的预处理
int knxt[MAXN]; // KMP 的 next 数组
int arr[MAXN]; // 字符串

int main(void){
    int s,testdatas; //s 表示题目中的 n
    s=seto()%MOD,testdatas=seto();
    spw[0]=1;
    for (int i=1;i<=N;i++)
        spw[i]=spw[i-1]*s%MOD;
    while (testdatas--){
        int n=seto(); //表示题目中的 m
        // KMP 计算 next
        knxt[0]=-1;
        for (int i=1;i<=n;i++){
            int cur=seto();
            arr[i]=cur;
            int tnxt=knxt[i-1];
            while (tnxt>=0){
                if (arr[tnxt+1]==cur)
                    break;
                tnxt=knxt[tnxt];
            }
            knxt[i]=tnxt+1;
        }
        int t=n;
        int ans=0;
        // 在 next 数组上跳，枚举每一个 border
        while (t)
            ans+=spw[t],MD(ans),t=knxt[t];
        //输出答案
        putchar(ans/1000+'0'),putchar(ans/100%10+'0'),
        putchar(ans/10%10+'0'),putchar(ans%10+'0'),putchar('\n');
    }
    return 0;
}
```

---

## 作者：crashed (赞：27)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4548)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;据说这道题正解是生成函数，可惜我不是很熟这个东西。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以说，我对这道题的解法跟生成函数没啥关系。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们很容易看出来一个$DP$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i)$：当前字符串已经匹配上了前$i$个字符串之后还需的期望步数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始$f(k)=0$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移：  
$$f(i)=\frac 1 n\sum_{c=1}^nf(trans(i,c))+1$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中$trans(i,c)$表示$KMP$中，前$i$个字符已经匹配上后，再加入一个$c$之后，转移到的位置。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接转移需要用上高斯消元，时间$O(n^3t)$，$T$了。考虑优化。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熟悉$KMP$和$trans$的朋友应该知道，$trans$的转移是： 
$$trans(i,c)=\begin{cases}i+1&c=s[i+1]\\trans(fail(i),c)&otherwise\end{cases}$$   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以$trans(i)$和$trans(fail(i))$只有$s[i+1]$这一位不同。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这个性质，我们可以得到：  
$$f(fail(i))=f(i)-\frac 1 nf(trans(i,s[i+1]))+\frac 1 nf(trans(fail(i),s[i+1]))$$  
$$\Rightarrow f(fail(i))=f(i)-\frac 1 nf(i+1)+\frac 1 nf(trans(fail(i),s[i+1]))$$  
$$\Rightarrow f(fail(i))-f(i)=\frac 1 n(f(fail(i+1))-f(i+1))$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做一个差分，设：  
$$g(i)=f(fail(i))-f(i)$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是就有转移:  
$$g(i)=\frac {g(i+1)} n$$  
$$\Rightarrow g(i+1)=ng(i)$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑边界：  
$$g(1)=f(fail(1))-f(1)=f(0)-f(1)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为： 
$$f(0)=\frac 1 n\sum_{c=1}^nf(trans(0,c))+1$$  
$$\Rightarrow f(0)=\frac{n-1}nf(0)+\frac 1 nf(1)+1$$  
$$\Rightarrow f(0)-f(1)=n$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以： 
$$g(1)=n$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是： 
$$g(i)=n^i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为$f(k)=0$，故有：  
$$g(k)=f(fail(k))-f(k)=f(fail(k))$$  
$$\Rightarrow f(fail(k))=n^k$$  
$$\Rightarrow f(fail(fail(k)))=n^k+n^{fail(k)}$$  
$$\dots$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直这样推下去，就可以得到$f(0)$。所以我们一直跳$fail$链，标记经过的位置，再倒过来累加出$f(0)$。单次时间$O(n)$，总时间$O(nt)$。  
# 代码
```cpp
#include <cstdio>

const int mod = 1e4;
const int MAXL = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int a[MAXL], fail[MAXL];
int N, T, K;
bool f[MAXL];

int main()
{
	int ans;
	read( N ), read( T );
	N %= mod;
	while( T -- )
	{
		read( K );
		for( int i = 1 ; i <= K ; i ++ ) f[i] = fail[i] = 0, read( a[i] );
		ans = fail[1] = 0;
		for( int i = 2, p = 0 ; i <= K ; i ++ )
		{
			while( p && a[p + 1] != a[i] ) p = fail[p];
			if( a[p + 1] == a[i] ) fail[i] = p + 1, p = fail[i];
		}
		for( int i = K ; i ; i = fail[i] ) f[i] = true;
		for( int i = 1, tmp = N ; i <= K ; i ++, tmp = tmp * N % mod ) 
			if( f[i] ) ans = ( ans + tmp ) % mod;
		printf( "%04d\n", ans );
	}
	return 0;
}
```

---

## 作者：shuidi (赞：16)

概率生成函数好题。

**前置芝士：概率生成函数**

首先普通生成函数（$\text{OGF}$）的一般形式为

$A(x) = \sum \limits_{i = 0}^\infty a_ix^i$

而概率生成函数则是普通生成函数的一种变形，具体来说，其中每一项的系数 $a_i$ 所代表的都是某一离散随机变量取值为 $i$ 的概率，用公式来表达即为：

$A(x) = \sum \limits_{i = 0}^\infty Pr(x = i)x^i$

**一些性质**：

我们考虑概率的一些基本定义，不难发现，若 $F(x)$ 是某一事件的概率生成函数，那么就有：

- $F(1) = 0$

- $E(x) = F^{'}(1)$

有了这些基本性质，我们开始考虑这道题。

首先令 $F(x)$ 表达结束时序列长度，其中每一项的系数刻画最终长度为 $i$ 的概率，那么由上面的性质即可知，$E(x) = F^{'}(1)$ 即为所求。

定义一个辅助的概率生成函数 $G(x)$ 刻画序列长度达到 $i$ 还没有结束的概率。

那么我们容易得到第一个等式，刻画 $F(x)$ 与 $G(x)$ 之间的关系。

$F(x) + G(x) = 1 + G(x) \times x$

从每一项的意义出发，这一等式描述的就是到达第 $i$ 项时的概率即为第 $i - 1$ 项还没有结束的概率。

下面的分析需要利用到字符串本身的一些性质。对于序列 $A$，如果 $A[1, i] = A[len - i + 1, len]$，那么成 $A[1, i]$ 为一个 $\text{border}$。

我们令一个 $0/1$ 序列 $a$，其中第 $i$ 项表示 $[1, i]$ 是否是一个 $\text{border}$，定义字符串长度为 $L$，字符集大小为 $m$。

那么有

$G(x) \times (\frac{1}{m}x)^L = \sum \limits_{i = 1}^L a_i \times F(x) \times (\frac{1}{m}x)^{L - i}$

emmm...这个式子看起来很不友好，但是从添加字符的角度上来看，这个等式刻画的就是在一个未结束的序列结尾添加上期望的序列，那么这个序列一定会结束，即左式。然鹅由于 $\text{border}$ 的存在，那么它有可能提前结束，即右式。

吼哇那么我们继续来推柿子：

对 $1$ 式求导，可得：

$F^{'}(x) + G^{'}(x) = G^{'}(x) \times x + G(x)$

$\therefore F'(1) = G'(1) \times (1 - 1) + G(1) = G(1)$

这看起来就十分友好了有木有！

接着推第二个式子：

$G(1) \times (\frac{1}{m})^L = \sum \limits_{i = 1} ^ L a_i \times F(1) \times (\frac{1}{m})^{L - i}$

由 $F(1) = 1$，可得

$G(1) = \sum \limits_{i = 1} ^ L a_i \times m^i$

既可以在 $\Theta(L)$ 的时间内求解答案惹！

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

#define MAXN 100005
#define MOD 10000
#define INF 0x3f3f3f3f
#define ri register int
#define chkmin(a, b) (a < b ? a : a = b)
#define chkmax(a, b) (a > b ? a : a = b)

typedef long long ll;
typedef unsigned long long ull;

const ull base = 19260817;

using namespace std;

int N, M, T;
ll ans;
ll a[MAXN];
ll mpow[MAXN];
ull s[MAXN];
ull pw[MAXN];
ull _hash_[MAXN];

inline int read_int()
{
	register int ret = 0, f = 1; register char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {ret = (ret << 1) + (ret << 3) + int(c - 48); c = getchar();}
	return ret * f;
}

inline void init()
{
	N = read_int(), T = read_int();
	pw[0] = 1;
	for(ri i = 1; i < MAXN; i++)
		pw[i] = pw[i - 1] * base;
}

inline bool cmp(int l1, int r1, int l2, int r2)
{
	return pw[MAXN - r1] * (_hash_[r1] - _hash_[l1 - 1]) == pw[MAXN - r2] * (_hash_[r2] - _hash_[l2 - 1]);
}

inline void calc()
{
	while(T--)
	{
		M = read_int();
		ans = 0;
		for(ri i = 1; i <= M; i++)
			s[i] = read_int();
		mpow[0] = 1;
		for(ri i = 1; i <= M; i++)
			mpow[i] = mpow[i - 1] * N % MOD;
		for(ri i = 1; i <= M; i++)
			_hash_[i] = _hash_[i - 1] + s[i] * pw[i];
		for(ri i = 1; i <= M; i++)
			a[i] = cmp(1, i, M - i + 1, M);
		for(ri i = 1; i <= M; i++)
			ans += a[i] * mpow[i], ans %= MOD;
		if(ans < 1000)
			printf("0");
		if(ans < 100)
			printf("0");
		if(ans < 10)
			printf("0");
		printf("%d\n", ans);
	}
}

int main()
{
	init();
	calc();
	return 0;
}
```

---

## 作者：C20203030 (赞：15)

其实小粉兔已经讲得很清楚了，那我为什么要发一篇博客呢？因为我在做题的时候不知道方程是怎么列出来的，列方程困扰了我很久，所以写这篇博客来帮助你理解生成函数方程究竟是怎么列出来的。

__题目描述__

[点此看题](https://www.luogu.com.cn/problem/P4548)

__解法__

这种题一般有套路的：__列方程解生成函数__ ，设 $f[i]$ 表示结束时长度是 $i$ 的概率，$g[i]$ 表示长度是 $i$ 还没有结束的概率，设 $F(x)$ 为 $f[i]$ 的生成函数，$G(x)$ 为 $g[i]$ 的生成函数，现在的任务是列出方程。

首先根据定义有：$f[i]=g[i-1]-g[i],f[0]=0,g[0]=1$，那么可以推出 $F(x)=xG(x)-G(x)+1$

还要有一个方程才行，考虑 $f,g$ 之间的联系，我们必须列一个方程来表示 $f,g$ 之间的相互转化，考虑在 $g$ 后面直接加入牛头人的名字 $A$，设牛头人的名字长度是 $L$，但是要考虑一种情况，就是没有加到 $L$ 就已经合法了，但这时候 $f$ 的后缀一定是 $A$ 的一个 $\tt border$，建议结合图来理解这个方程怎么来的：

![](https://cdn.luogu.com.cn/upload/image_hosting/qqoekhde.png)

那么我们枚举 $\tt border$ 的长度 $i$ 就可以写出下列方程，注意我们列的是生成函数的方程，但原理是根据单个项的等式关系来的，所以要注意 __对齐项数__ ，设 $a_i$ 表示 $[1,i]$ 是否是 $A$ 的一个 $\tt border$：

$$(\frac{x}{m})^LG(x)=\sum_{i=1}^La_i(\frac{x}{m})^{L-i}F(x)$$

剩下的问题就是解方程了，由于求的是结束时间的期望那么答案是 $F'(1)$，我们先把第一个方程求导：

$$F'(x)=G(x)+xG'(x)-G'(x)=(x-1)G'(x)+G(x)$$

然后将 $x=1$ 带入上面的式子：

$$F'(1)=G(1)$$

那么问题变成了求 $G(1)$，尝试用第二个式子把 $x=1$ 带进去：

$$(\frac{1}{n})^mG(1)=\sum_{i=1}^ma_i\cdot F(1)\cdot(\frac{1}{n})^{m-i}$$

$$G(1)=\sum_{i=1}^ma_i\cdot F(1)\cdot n^i$$

$$G(1)=\sum_{i=1}^ma_i\cdot n^i$$

$$F'(1)=\sum_{i=1}^ma_i\cdot n^i$$

大功告成啦！~~所以代码还需要我给么~~

---

## 作者：WYXkk (赞：13)

在[这篇题解](https://www.luogu.com.cn/blog/WYXkk/solution-p4548)内，我提到了这里的情景“事实上可以严格化”。这里我打算用比较通俗的方式（感觉 Union_of_Britain 的题解有点不讲人话）来说明如何将这个直观证明严格化。不过仍然有许多可省略的细节被略去了。

先简单回顾一下细节：假设有一个提供公平赌博的赌场，每秒会来一个带着 1 元的新赌徒，赌徒会连续全部押注，赌从他来的那一刻起正好能够连续唱出给定字符串，在此之后就不再参与押注。

以下记字符集大小为 $c$，字符串长度为 $l$。

## 停时

一列不断加细的样本空间的一个停时 $T$，指的是，细分到第 $n$ 个样本空间后，一定可以完整检查 $T=n$ 是否成立。

比如你投硬币，检查何时第一次出现“正正反”的连续子串，则第一次出现的时间 $T$ 就是一个停时。

## 鞅

一列不断加细的样本空间的一个鞅 $\{X_n\}$，指的是，第 $n$ 个样本空间上有一个随机变量 $X_n$，且细分到第 $n$ 个样本空间后，对于任意 $m>n$，$X_m$ 的期望都等于 $X_n$ 的已确定值，那么这一列随机变量是一个鞅。

比如你还是投硬币，设正面加 1 分反面扣 1 分，令 $X_n$ 为第 $n$ 轮时的得分，那么 $\{X_n\}$ 是一个鞅。

## 应用定义

本题中唱出的无限字符串可以用来逐个细分样本空间。

第一次出现需求的字符串的时间 $T$ 当然是一个停时。

对于第 $k$ 个赌徒，设他在第 $n$ 轮结束时拥有 $W_n^{(k)}$ 元。容易验证，$\{W_n^{(k)}\}$ 是一个鞅。

给一个鞅加一个常数，以及对几个鞅进行求和，得到的显然还是一个鞅。那么，$M_n=\sum\limits_{k}(W_n^{(k)}-1)$ 是一个鞅。它的含义是所有赌徒的总利润。

$M_0=0$ 是显然的。在 $T$ 时刻除了 border 处的赌徒赢到现在其余都输光了，于是 $M_T=\sum\limits_{a[1,k]=a[l+1-k,l]}c^k-T$。

## 可选停止定理

可选停止定理有几个不同的条件。下面验证以下条件：

- 停时的期望是有限的，且鞅中每一项与前一项的差的期望都有限

前半句：$T$ 至少比每 $l$ 轮再检查一次要好，这样的话每次检查都是独立的 $c^{-l}$ 概率，此时的期望为有限的 $lc^l$，所以 $T$ 的期望也是有限的。

后半句：最新的结果只会影响最近的 $l$ 个赌徒的资产，而单个赌徒的资产有上界 $c^l$ 和下界 $0$，因此每一步最多导致 $M_n$ 产生 $lc^l$ 的变化。

于是，应用可选停止定理，即得 $E[M_T]=E[M_0]$。

这也就是说 $\sum\limits_{a[1,k]=a[l+1-k,l]}c^k-E[T]=0$，所以 $E[T]=\sum\limits_{a[1,k]=a[l+1-k,l]}c^k$。

这就得到了本题需求的结论了。

---

## 作者：xtx1092515503 (赞：12)

这里是一种从DP出发的思路。

我们设酋长的名字长为 $n$，每位依次编号为 $1\sim n$。再设字符集大小是 $m$。

然后，我们先来看一道题作为本题的模型：[[Cnoi2020]线形生物](https://www.luogu.com.cn/problem/P6835)。

我们将会发现这两题是很相似的——具体来说，本题可以被抽象成一个与上题一模一样的模型：

有 $n+1$ 个点，编号为 $0\sim n$。其中，对于每个 $0\leq i<n$，都有边 $(i,i+1)$。这条边表示刚好抽到了序列中的下一个字符。

但是，我们发现它还有可能没有抽到下一个字符。此时，它不一定必须从头开始，而是有概率成为前 $i$ 个字符构成的串的一个 $\text{border}$（$\text{border}$ 定义为某个串相同的前缀与后缀）的下一位。

比如，设一个串为 ```ABAABAB```，且当前我们位于第 $6$ 位。

显然，如果这时摇出一个 `B`，就直接结束了；于是有一条边 $(6,7)$。

但是，如果摇出一个 `A`，我们就得找到前 $6$ 位的串 ```ABAABA``` 的一个 $\text{border}$，使得该 $\text{border}$ 结尾的下一个字符是 `A`。我们发现 ```ABA``` 这个 $\text{border}$ 刚好符合要求。于是我们连一条边 $(6,4)$。

那么假如字符集中还有一个 `C` 呢？我们将会发现不得不再连一条边 $(6,0)$。

于是我们对于一个串，可以找到它关于 `A` 的 $\text{border}$（```ABA```），关于 `B` 的 $\text{border}$（```ABAABA```），关于 `C` 的 $\text{border}$（```一个长度为-1的串```），然后各自往这些 $\text{border}$ 结尾字符的下一个位置连边。

（需要注意的是，一个串并不是所有的 $\text{border}$ 都需要连边。举例来说，上例中的 ```A``` 与 ```ABAABA``` 同是关于 `B` 的 $\text{border}$，但显然我们选择**长度最长的那个**——这也是我特意标注“关于 `B` 的 $\text{border}$”的原因，因为**关于同一个字符能且只能连出一条边**）

于是我们便成功将一道黑题转成了一道蓝题（并不，因为接下来还有很长的路要走）

我们先来看一下那道蓝题怎么做——

我们设 $h_i$ 表示当前在位置 $i$，期望要多少步才能走到位置 $i+1$。再设 $g_i$ 表示 $h_i$ 的前缀和（从起点期望多少步走到位置 $i+1$）。

于是如果有一条边 $(i,j)$ 且 $j<i$，则我们如果走上了这条边，就需要期望 $g_{i-1}-g_{j-1}$ 的时间来回到 $i$。

因为每条边都是等概率（$\dfrac{1}{deg_i}$）选到的，所以我们期望需要 $deg_i$ 次才能选到唯一有用的边（$(i,i+1)$），则相当于每一条边都会被走一次。

于是就有

$$h_i=deg_i+\sum\limits_{(i,j),j<i}g_{i-1}-g_{j-1}$$

其中，外面那个 $deg_i$ 是因为每一条边本身就需要 $1$ 的时间走过。

下面回到本题。显然，对于每个位置 $i$，都有 $deg_i=m$。（回忆一下，$m$ 是字符集大小）

于是就有

$$h_i=m+(m-1)g_{i-1}-\sum g_{j-1}$$

因为 $j$ 是 $\text{border}$ 的下一个字符；所以 $j-1$ 就是 $\text{border}$ 的结尾；故我们就可以直接在下面令 $j$ 表示所有 $i$ 的 $\text{border}$ 的结尾（前提是这些 $\text{border}$ 的下一个字符必须互不相同，这点我们之前已经讨论过了。这样处理后，我们便不需要考虑什么“长度为 $-1$ 的串”诸如此类的奇怪东西）

这样处理之后，我们下面定义一个 $\text{border}$ 的**结尾字符**表示它末尾字符的下一个字符。

故我们有

$$h_i=m+(m-1)g_{i-1}-\sum g_j$$

显然在 $n=10^5$ 的条件下，暴力连边是不可取的，故我们要想办法优化。

有什么求 $\text{border}$ 的算法吗？

对，没错，就是你们想的那个，**KMP**。

众所周知（并不），KMP的 $next$ 数组构成了一棵树，我们称作 $next$ 树。一个节点在 $next$ 树中的所有祖先即为它的所有 $\text{border}$。

但是根据我们之前所说，这些 $\text{border}$ 中结尾的下一个数相同的只能保留一个，故我们应该开一个桶表示对于当前节点，它（所有祖先 $\text{border}$ 中）（以每个字符作为结尾字符）的串的下标。

但是这样复杂度仍然是 $O(nm)$ 的。

我们考虑一些优化。我们设 $f_i$ 表示 $i$ 节点时的 $\sum g_j$。则有

$$h_i=m+(m-1)g_{i-1}-f_i$$

但是 $f_i$ 怎么求呢？我们考虑从它 $next$ 树上的父亲（设为 $fa$ ）转移过来。

我们考虑 $f_i$ 相较于 $f_{fa}$ 改变了什么——

1. 原本的 $f_{fa}$ 中并没有考虑 $g_{fa}$ 其本身，而对于 $i$ 来说，$g_{fa}$ 也是其 $\text{border}$，故应加上 $g_{fa}$；

2. $f_{i}$ 中不应包含 $i$ 本身的结尾字符。故我们可以预处理出来 $rep_i$ 表示 $i$ 的所有祖先中，最深的那个和 $i$ 拥有相同结尾字符的 $\text{border}$ 的位置（通过上文提到的桶，在 $next$ 树上dfs即可得到）（假如不存在这样的 $\text{border}$，设为 $-1$ 即可）。则 $f_i$ 应该减去 $g_{rep_i}$。

这样我们便成功求出了 $f_i$。套用前面的式子，便可在 $O(n)$ 时间内DP完成。

我们最后梳理一下过程——

1. 对原串进行KMP，建出 $next$ 树；

2. dfs $next$ 树，用桶求出 $rep_i$；

3. 初始化（$f_0=0,g_0=h_0=m$）

4. 枚举 $i$，从它的父亲求出 $f_i$，然后求出 $h_i$，然后前缀和得到 $g_i$。（实际操作中直接把 $g$ 和 $h$ 开在同一个数组里即可）

5. 答案即为 $g_{n-1}$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10000;
int T,n,m,a[100100],kmp[100100],f[100100],g[100100],rep[100100],buc[100100];
vector<int>v[100100];
void dfs(int x){
	int tmp=buc[a[x+1]];
	buc[a[x+1]]=x;
	for(auto y:v[x]){
		rep[y]=buc[a[y+1]];
		dfs(y);
	}
	buc[a[x+1]]=tmp;
}
int main(){
	scanf("%d%d",&m,&T);
	while(T--){
		scanf("%d",&n);
		for(int i=0;i<=n;i++)v[i].clear();
		for(int i=1;i<=n;i++)scanf("%d",&a[i]),rep[i]=0;
		for(int i=1;i<=m;i++)buc[i]=-1;
		for(int i=2,j=0;i<=n;i++){
			while(j&&a[j+1]!=a[i])j=kmp[j];
			if(a[j+1]==a[i])j++;
			kmp[i]=j;
		}
		for(int i=1;i<n;i++)v[kmp[i]].push_back(i);
		dfs(0);
//		for(int i=0;i<n;i++)printf("%d ",rep[i]);puts("");
		f[0]=0,g[0]=m;
		for(int i=1;i<n;i++){
			f[i]=(f[kmp[i]]+g[kmp[i]])%mod;
			if(rep[i]>=0)f[i]=(f[i]-g[rep[i]]+mod)%mod;
			g[i]=(1ll*(m-1)*g[i-1]+m-f[i]+mod)%mod;
			(g[i]+=g[i-1])%=mod;
		}
//		for(int i=0;i<n;i++)printf("%d ",f[i]);puts("");
//		for(int i=0;i<n;i++)printf("%d ",g[i]);puts("");
		printf("%04d\n",g[n-1]);
	}
	return 0;
} 
```


---

## 作者：Illusory_dimes (赞：9)

#### （注：本题解废话有点多，因为我只是想讲得能让我都明白，所以大佬可以跳过，上面有许多更简洁的题解）
### 题目描述
给定一个取值范围 $[1,n]$ 和一个长度为 $m$ 的正整数序列 $A$ 。每次从取值范围内随机取一个正整数加入一个初始为空的序列 $B$ ，当序列 $B$ 包含了序列 $A$ 时停止，问序列 $B$ 的期望长度。

多组数据（最多 50 ）

$1\leq n\leq 10^5\ \ \ \ 1\leq A_i\leq 10^5$

### 前置芝士
概率生成函数（其实知道那些神奇的结论就行）

### solution
令函数 $f_i$ 为序列 $B$ 长度为 $i$ 时停止的概率，其概率生成函数为 $F(x)$ 。

其实很容易看出来答案就是 $\mathrm{d^1} F(1)$ ，但目前我们肯定求不了。

那么，相对地，再来设一个函数 $g_i$ 表示序列 $B$ 长度为 $i$ 时未停止的概率，其概率生成函数为 $G(x)$ 。

怎么把两个概生函联系起来呢？？

因为假如序列 $B$ 在长度为 $i$ 的时候没有停止，那么要么在 $i+1$ 的时候停止，要么不停。

所以就有了 $g_i=f_{i+1}+g_{i+1}$ 。

于是就有了 $F(x)-f_0+G(x)=x\cdot G(x)$ 。

根据定义有 $f_0=g_0=1$ ，所以，

$$F(x)+G(x)=x\cdot G(x)+1$$

对上式求个导，

$$\big(x\cdot \mathrm{d^1} G(x)+\mathrm{d^1} x\cdot G(x)\big)+\mathrm{d^1} 1=\mathrm{d^1} F(x)+\mathrm{d^1} G(x)$$

$$\Rightarrow x\cdot \mathrm{d^1} G(x)+G(x)=\mathrm{d^1} F(x)+\mathrm{d^1} G(x)$$

$$\Rightarrow \mathrm{d^1} F(x)=(x-1)\mathrm{d^1} G(x)+G(x)$$

带入 $x=1$ 。

$$\Rightarrow \mathrm{d^1} F(1)=G(1)$$
此时我们已经对答案又进行了进一步转化，但仍然求不了答案。

来认识一个新东西 [$border$](https://oi-wiki.org/string/kmp/#_9) 。

设 $a_i$ 为序列 $A$ 在 $[1,i]$ 上的子序列是否是序列 $A$ 的 $border$ 。

易知在未结束的序列 $B$ 后面添加序列 $A$ 一定会结束。

但有可能发生未添加完所有字符就结束的情况，这种情况只有可能是已添加的序列 $\varphi$ 为序列 A 的一个 $border$ 。

所以可以枚举此时序列的长度，然后再乘上多余字符的概率。

于是就有了，

$$\Big(\frac{1}{n}\cdot x\Big)^m\cdot G(x)=\sum_{i=1}^{m}a_i\cdot \Big(\frac{1}{n}\cdot x\Big)^{m-i}\cdot F(x)$$

再次带入 x=1 。

$$\Big(\frac{1}{n}\Big)^m\cdot G(1)=\sum_{i=1}^{m}a_i\cdot \Big(\frac{1}{n}\Big)^{m-i}\cdot F(1)$$

$$\Rightarrow G(1)=\sum_{i=1}^{m}a_i\cdot n^i\cdot F(1)$$

易知 $F(1)=1$ ，带入。

$$\Rightarrow G(1)=\sum_{i=1}^{m}a_i\cdot n^i$$

$$\Rightarrow \mathrm{d^1} F(1)=\sum_{i=1}^{m}a_i\cdot n^i$$

最后 KMP 求一下 $a_i$ 就能算了。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10,mod=1e4;
int n,t,m,a[N],fac[N],nxt[N],ans;
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline ll read()
{
	ll s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void keep_my_position(int m)
{
	for(int i=2,k=0;i<=m;++i)
	{
		while(k&&a[i]!=a[k+1])k=nxt[k];
		if(a[i]==a[k+1])nxt[i]=k+1,++k;
	}
}
int main()
{
	n=read()%mod,t=read(),fac[0]=1;
	for(int i=1;i<N;++i)fac[i]=mul(fac[i-1],n);
	for(;t;--t)
	{
		m=read(),ans=0;
		for(int i=1;i<=m;++i)a[i]=read(),nxt[i]=0;
		keep_my_position(m);
		for(int i=m;i;i=nxt[i])ans=inc(ans,fac[i]);
		printf("%04d\n",ans);
	}
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：Mivik (赞：9)


[欢迎到我的博客查看](https://mivik.gitee.io/2020/solution/ctsc2006-kingdom-of-singing/)

> 给定 $n$ ，代表有 $n$ 种字符。再给出多个数组 $a$ ，记其长度为 $m$，$1\le a_i\le n$。每次随机写下出一个字符，求第一次写下这个数组（即写下的字符串后缀为该数组）期望要写多少个字符。

考场上遇到的题稍微有点不一样，是让你对每个前缀都求出其第一次被写下的时间，并且数据范围比较小。当时 yy 了一个理论最劣 $O(n\cdot m^2)$ 的做法，当时还以为是 $O(n\cdot m)$ 的（草），然后莫名奇妙就卡过去了。考完后神仙说是论文题，$O(m)$ 的。然后想了想发现自己的做法是可以做到 $O(m)$ 的。

啊，标准做法可以去看洛谷一大片生成函数详解，甚至知乎上也有（？）。这里提供一个小白做法。

我们令 $f_i$ 为写下前 $i$ 个字符期望要多少步，然后可以写出转移方程：
$$
f_{i+1}=f_i+1+\frac{1}{n}\sum_{c\ne s_{i+1}}f_{i+1}-f_{tar(i,c)}
$$
也就是说，在写下前 $i$ 个字符的情况下，首先需要再写一个字符，如果这个字符恰好为 $s_{i+1}$ ，那么就没有额外贡献了，否则的话会失配跳到 $tar(i, c)$ 。

然后我们移一下项，乘一个 $n$：
$$
f_{i+1}=n(f_i+1)-\sum_{c\ne s_{i+1}}f_{tar(i, c)}
$$
注意到 $tar(i, c)\le i$ ，因此我们就可以依次递推求得 $f$ 了。时间复杂度 $O(n\cdot m)$。

考虑优化。我们发现每次枚举 $c$ 是我们算法的时间复杂度瓶颈。我们记 $\sum_c f_{tar(i, c)}$ 为 $sum_i$，然后动态维护这个 $sum$ 。我们发现，每次新扫到一个位置 $i$ ，只且只会对 $sum_{i-1}$ 造成影响（ $tar(i-1, c)$ 从 $pre_i$ 变为了 $i$ ，$pre$ 代表 kmp 中所求的所有前缀的 border ）。于是我们每次先把 $f_{pre_i}$ 从 $sum_{i-1}$ 中减去，然后再加上 $f_i$ 即可。于是得出下面的代码：

```cpp
const int mod_n = n % lp - lp; // 注意 n 可能大于 mod
sum[0] = 0;
for (int i = 1; i <= m; ++i) {
	upd(sum[i - 1] -= f[pre[i]]); // 首先减去
	f[i] = (qe)f[i - 1] * n % lp;
	upd(f[i] -= sum[i - 1]); // 递推式中要求 c != s[i + 1]，这里正好
	upd(f[i] += mod_n); // 算完 f[i] 了

	upd(sum[i - 1] += f[i] - lp); // 加上
	sum[i] = sum[pre[i]]; // 继承自己 pre 的 sum
}
```

然后就是 $O(m)$ 的复杂度了。所求答案即为 $f_m$，然后每个前缀对应的答案也分别对应到 $f_i$。

完整代码（[mivik.h](https://mivik.gitee.io/mivik.h)）：

```cpp
// Mivik 2020.9.18
#include <mivik.h>

#include <iomanip>

#ifdef MIVIK
MI cin(popen("xsel -ob", "r"));
#else
MI cin;
#endif

typedef long long qe;

const int mmax = 100001;
const int lp = 10000;

int n, m;
int a[mmax], pre[mmax], f[mmax], sum[mmax];
inline void upd(int &x) { x += (x >> 31) & lp; }
inline int pro(int x) { return x + ((x >> 31) & lp); }
inline void work() {
	cin>m;
	for (int i = 1, j = 0; i <= m; ++i) {
		cin>a[i];
		while (j && a[i] != a[j + 1]) j = pre[j];
		if (i != j + 1 && a[i] == a[j + 1]) ++j;
		pre[i] = j;
	}
	const int mod_n = n % lp - lp;
	sum[0] = 0;
	for (int i = 1; i <= m; ++i) {
		upd(sum[i - 1] -= f[pre[i]]);
		f[i] = (qe)f[i - 1] * n % lp;
		upd(f[i] -= sum[i - 1]);
		upd(f[i] += mod_n);

		upd(sum[i - 1] += f[i] - lp);
		sum[i] = sum[pre[i]];
	}
	cout<std::setw(4)<std::setfill('0')<f[m]<endl;
}
int main() {
	cin>n;
	for (int T = R; T; --T) work();
	return 0;
}
```

---

## 作者：Union_of_Britain (赞：7)

注：本文中，未指定鞅 $\{(X_n,\mathscr{F}_n)\}$ 适应的流 $\mathscr{F}_n$，我们默认是包含其最小的 $\sigma-$ 代数，即 $\mathscr{F}_n=\sigma(X_1,X_2,X_3,\dots,X_n)$。

声明：本人接触鞅的时间不久，理解不深刻，若本文有谬误，请不吝指出。

## 题意简述

随机一个数 $1\sim n$ 接在歌唱序列后面，问歌唱序列出现给定序列作为子序列的期望随机次数。

## Solution

### 前置知识

关于鞅、停时的基础知识和此定理的证明等可以参见[本人博客](https://www.cnblogs.com/british-union/p/posiibility.html)和[北京大学的讲义](https://www.math.pku.edu.cn/teachers/lidf/course/stochproc/stochprocnotes/html/_book/martingale.html)。

Doob 停时定理：

如果 $\{M_n\}$ 是关于 $\{\mathscr{F}_n=\sigma(X_1,X_2,\dots,X_n)\}$ 的鞅，$T$ 为其停时 ，若：
$$E|M_T|<\infty$$
$$P(T<\infty)=1$$
$$\lim_{n\to\infty}E(M_n\mid I_{[T>n]})=0$$

那么

$$
E(M_T)=E(M_1)
$$

### Solution 

这是 PGF 的经典题目，但是也可以应用 Doob 停时定理做。

设目标串是 $T[1:L]$。

考虑这样一个以 $k$ 为参数的随机变量列 $\{A_m^{(k)}\}_{m\ge 1},\forall k\ge 1$，$\Omega=\{s[1:+\infty]\mid s[i]\in[1,n]\cap\mathbb{Z}\}$。

$$
A_m^{(k)}=
\left\{\begin{matrix}
  C&(k\le m\land t[1:L]=s[k:k+L-1]\land m-k+1>L)\\
  n^{m-k+1}&(k\le m\land t[1:m-k+1]=s[k:m]\land m-k+1\le L)\\
  1&(m<k)\\
  0&(otherwise)\\
\end{matrix}\right.
$$

$C$ 是任意值。

容易证明这在**停时前**是鞅，即除去第一条，而停时后的部分是不关心的。

我们知道，鞅的线性组合是鞅。

所以
$$
M_n=\sum_{k\ge 1}A_n^{(k)}-1
$$
是鞅。构造 $T$ 为其一停时，为
$$
T(s[])=\min_{s[i-L+1:i]=t[1:L]}i
$$

容易验证其是停时，且适用 Doob 停时定理，注意 $P(T(s[])<+\infty)=1$。

不难发现，其实际意义正好适配本题。

$$E(M_T)=E(M_0)=0$$

$$M_T=\sum_{k=1}^{T}A_T^{(k)}-1$$

$$=\sum_{t[1:i]=t[L-i+1:L]} n^{i}-T$$

$$E(M_T)=\sum_{t[1:i]=t[L-i+1:L]} n^{i}-E(T)=0$$

$$\therefore E(T)=\sum_{t[1:i]=t[L-i+1:L]} n^{i}$$

第三个等号成立，因为每个 $A_T^{(k)}$ 产生贡献的条件是（已经略去 $1$ 的情况）
$$
s[1:T-k+1]=s[k:T]
$$
注意到
$$
T(s[])=\min_{s[i-L+1:i]=t[1:L]}i
$$
所以每个 $A_T^{(k)}$ 产生贡献当且仅当其为 border（第一部分是不需要考虑的，因为停时是 $\min$）

最后的答案就是

$$E(T)=\sum_{t[1:i]=t[L-i+1:L]} n^{i}$$


---

## 作者：FZzzz (赞：7)

这题的主流做法是概率生成函数，最后可以得到一个简洁的式子。但同时也存在一个 kmp 自动机上 dp 的做法，非常套路，很字符串，我甚至更喜欢这个做法一点。

直觉上肯定有一个从这个 dp 推到最终的式子的办法。但是我推了一下发现这玩意其实比较蠢，不过既然没人写这个我就还是来水一下咯。

------------
生成函数做法就略过了。

建出 kmp 自动机，问题变成了在这个 kmp 自动机上随机游走，期望啥时候能从 $0$ 走到 $m$。记点 $u$ 在 $c$ 字符的转移为 $t_{u,c}$，那么 $t_{u,s_{u+1}}=u+1$，其他 $t_{u,c}\le u$。对于 $c\ne s_{u+1}$，$t_{u,c}$ 的实际意义就是 $s[1,u]+c$ 的最长 border 的长度（不包含自身）。

设 $f_i$ 为从 $0$ 走到 $i$ 的期望。因为从 $0$ 到任意点只有一条简单路，所以从 $i$ 走到 $j$（$i<j$）的期望就是 $f_j-f_i$。考虑从 $i-1$ 走到 $i$ 的期望，我们有
$$f_i-f_{i-1}=1+\frac 1n\sum_{c\ne s_i}f_i-f_{t_{i-1,c}}$$
$$f_i=nf_{i-1}+n-\sum_{c\ne s_i}f_{t_{i-1,c}}$$
接下来可以对着这个 dp 优化。我们把后面那个 sigma 挂在 $i-1$ 上，记它为 $g_{i-1}$。那么我们有
$$g_u=g_{nxt_u}+f_{nxt_u+1}-f_{nxt_{u+1}}$$
这是说 $t_u$ 和 $t_{nxt_u}$ 的区别只有 $s_{u+1}$ 和 $s_{nxt_u+1}$ 两处，$t_{nxt_u,s_{u+1}}=nxt_{u+1}$，$t_{u,s_{nxt_u+1}}=nxt_u+1$，我们需要加上后者的贡献而减去前者的贡献。那么我们按这个东西 dp，时空复杂度就都是 $O(m)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5;
int n,m,s[maxn],nxt[maxn];
const int mod=1e4;
int f[maxn],g[maxn];
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	int T=read();
	while(T--){
		m=read();
		for(int i=1;i<=m;i++) s[i]=read();
		int u=0;
		for(int i=2;i<=m;i++){
			while(u&&s[i]!=s[u+1]) u=nxt[u];
			if(s[i]==s[u+1]) u++;
			nxt[i]=u;
		}
		for(int i=1;i<=m;i++){
			if(i>1) g[i-1]=(g[nxt[i-1]]+f[nxt[i-1]+1]-f[nxt[i]]+mod)%mod;
			f[i]=(f[i-1]*n+n-g[i-1]+mod)%mod;
		}
		printf("%04d\n",f[m]);
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```
题外话，这个代码其实非常快，比直接套式子还快，现在能进最优解第一面。

但是这里到标算的式子其实已经只有一步之遥。我们先把式子摆出来：
$$\sum_{s[1,i]=s[m-i+1,m]}n^i$$
使用归纳法证明这个式子。$f_i$ 其实就是 $s[1,i]$ 的答案，我们假设 $i$ 前面的 $f$ 都满足这个式子，考虑证明 $f_i$ 也满足。

记 $\operatorname{bd}(s)$ 为 $s$ 的 border 集合（包含自身），$h(s)=\sum\limits_{t\in\operatorname{bd}(s)}n^{|t|}$，$\operatorname{mxbd}(s)$ 是 $s$ 的最长 border（不包含自身）。那么我们知道对于 $j<i$ 有 $f_j=h(s[1,j])$。

欲计算 $h(s[1,i])$，我们在 $h(s[1,i-1])$ 的基础上，每个 border 加上在原串中后面一个字符，然后减掉加上的这个字符不是 $s_i$ 的情况。若加上的这个字符是 $c$，要减掉的实际就是 $h(\operatorname{mxbd}(s[1,i-1]+c))$。

但是有两种边界情况。若 $s_1=s_i$，那么空串的贡献不在 $h(s[1,i-1])$ 中，但 $s[1,1]$ 的贡献要在 $h(s[1,i])$ 中，额外加上一个 $n$。若 $s_1\ne s_i$，那么空串的贡献不在 $h(s[1,i-1])$ 中，但 $s[1,1]$ 的贡献在 $h(s[1,i-1]+s_1)$ 中，也就是说我们多减了一个 $n$，所以也要加上一个 $n$。所以最后的式子即：
$$\begin{aligned}h(s[1,i])=&nh(s[1,i-1])+n-\sum_{c\ne s_i}h(\operatorname{mxbd}(s[1,i-1]+c))\\=&nf_{i-1}+n-\sum_{c\ne s_i}f_{t_{i-1,c}}=f_i\end{aligned}$$
于是根据归纳法 $f_m=h(s)$，这就用自动机 dp 的方式证明了标算用 PGF 推出的式子。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5;
int n,m,s[maxn],nxt[maxn];
bool vis[maxn];
const int mod=1e4;
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	int T=read();
	while(T--){
		m=read();
		for(int i=1;i<=m;i++) s[i]=read();
		int u=0;
		for(int i=2;i<=m;i++){
			while(u&&s[i]!=s[u+1]) u=nxt[u];
			if(s[i]==s[u+1]) u++;
			nxt[i]=u;
		}
		memset(vis,0,sizeof(vis));
		u=m;
		while(u){
			vis[u]=1;
			u=nxt[u];
		}
		int ans=0,pw=1;
		for(int i=1;i<=m;i++){
			pw=pw*n%mod;
			if(vis[i]) ans=(ans+pw)%mod;
		}
		printf("%04d\n",ans);
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```
我还尝试直接对两种做法建立联系，但是并没有得到什么结果。我觉得这非常困难，有没有老哥教教我啊。

---

## 作者：zimujun (赞：2)

在外站看到一个直接基于式子本身变换的方法，因此我按照自己的理解整理了一下，本文同步发表于 [Hydro bzoj](https://hydro.ac/d/bzoj/p/1152/solution)。

设随机变量 $X$ 表示随机恰好 $X$ 个字符后，歌唱结束。

设 $F(x)  = \sum\limits_{i = 1} ^ \infty P(X = i)x^i, G(x) = \sum\limits_{i = 0} ^ \infty P(X > i)x^i$，即随机恰好 $X$ 个数后歌唱结束/不结束的 $\text{PGF}$，那么易知 $F(x) + G(x)$ 的系数就是 $F(x)$ 系数的后缀和，于是现在既可以考虑它们表示的意义，也可以直接从这两个式子本身出发，得到下面这个式子，这里采用的是后者：

$$F(x) + G(x) = 1 + xG(x)$$

考虑 $F(x)$ 的系数后缀和又等于 $G(x)$ 系数整体向右偏移一位，然后再在最前面加上 $F(x)$ 所有系数的和，即 $F(1) = 1$。

进行简单的变换就得到了：

$$F(x) = (x - 1)G(x) + 1$$

$$F'(x) = G(x) + (x - 1)G'(x)$$

$$E(X) = F'(1) = G(1)$$

考虑在一个没有结束的序列上接下来强行接上 $S$ 使其结束，有：

$$\left(\dfrac{x}{n}\right)^{|S|}G(x) = \sum_{i = 1} ^ {|S|}\left[pre_i = suf_i\right]\left(\dfrac{x}{n}\right)^{|S| - i}F(x)$$

其中 $pre_i = suf_i$ 表示字符串 $S$ 存在长为 $i$ 的公共前后缀。

最后把 $x = 1$ 代入简单变形即得：

$$\dfrac{1}{n^{|S|}}E(X) = \sum_{i = 1} ^ {|S|}[pre_i = suf_i]\dfrac{1}{n^{|S| - i}}$$

$$E(X) = \sum_{i = 1} ^ {|S|}[pre_i = suf_i]n^i$$

---

## 作者：b6e0_ (赞：1)

主要是记录一下自己的思考流程。

记字符集大小为 $m$，模式串为 $a$，$n=|a|$，$a$ 的小于 $n$ 的周期集合为 $P$，border 集合为 $B$。定义 $a$ 在 $b$ 中的第 $i$ 个位置出现当且仅当 $b[i,i+|a|-1]=a$。

考虑期望的线性性质，问题转化为计算

$$
\sum_{N\ge0}p(N)
$$

其中 $p(N)$ 表示长度为 $N$ 的串，模式串不在其中出现的概率。

关于 $p(N)$ 的计算，考虑容斥原理，用 $1$ 减去钦定一个位置（或者说区间）出现 $a$ 的串的概率，加上钦定两个位置，等等。

考虑对于一个确定的 $N$ 和钦定位置的集合，记被至少一个钦定区间包含的位置个数为 $t$，那么生成出这样的串的概率为 $m^{-t}$，和 $N$ 无关。那么对于一个钦定位置的集合 $S$，定义 $W(S)$ 为满足这个钦定位置集合的串的概率乘上它的容斥系数，即 $(-1)^{|S|}m^{-t}$。答案为：

$$
\sum_{N\ge0}\sum_SW(S)
$$

其中第二维枚举的 $S$ 需要满足在字符串长度为 $N$ 的情况下是一个合法的钦定集合，即钦定区间不能超过 $N$。

我们不妨把钦定集合用一个长为 $N$ 的 $\texttt{01}$ 字符串 $s$ 表示，$s_i=\texttt{1}\iff i\in S$。定义 $w(s)=W(S)$，则答案为

$$
\sum_sw(s)
$$

其中 $s$ 要满足最后 $n-1$ 位没有 $\texttt{1}$。

对于所有 $i(1\le i<|s|)$，若没有钦定区间同时包含 $i,i+1$，则在 $i$ 和 $i+1$ 中间切一刀，这样 $s$ 被分为了若干**独立**的子串，$w(s)$ 为每个子串的 $w$ 的乘积。

称这些划分出的不可再划分的子串为本原串，那么每个 $s$ 都由若干个本原串组成。记所有本原串的 $w$ 值的和为 $b$，那么答案为

$$
\sum_{i\ge0}b^i=\frac1{1-b}
$$

下面我们计算 $b$。

首先有且仅有一个不存在 $\texttt{1}$ 的本原串，为 $\texttt{0}$，$w(\texttt{0})=1$。

对于其他本原串，第一位一定为 $\texttt{1}$，我们先把 $-m^{-n}$ 乘进总和。对于剩下的 $\texttt{1}$，它们与上一个 $\texttt{1}$ 的距离 $d$ 一定是 $a$ 的一个周期，每添加一个 $\texttt{1}$ 也会让本原串的长度增加 $d$，$w(s)$ 乘上 $-m^{-d}$。从只有一个 $\texttt{1}$ 的本原串 $\texttt{100}\cdots\texttt{0}$ 开始，我们可以添加任意的 $\texttt{1}$。对于一次添加，所有可能的方案对 $w(s)$ 的贡献（即让 $w(s)$ 乘上的数）的总和为

$$
\sum_{d\in P}-m^{-d}
$$

记这个数为 $c$，那么所有含 $\texttt{1}$ 的本原串的 $w$ 和为

$$
-m^{-n}\sum_{i\ge0}c^i=\frac{-m^{-n}}{1-c}
$$

$b$ 即为上式加上 $w(\texttt{0})$。化简后原题的答案为

$$
\sum_{i\in B}m^i
$$

于是我们推出了结论。

---

## 作者：wurzang (赞：0)

不会所以来写一篇题解（

由于这个做法感觉很牛逼就只讲一讲做法，至于为什么能想到我就不知道

题意：

~~字符含义可能与题目不符~~

给定一个大小为 $m$ 的骰子和一个长度为 $n$ 的模式串 $b$，文本串为空，不断扔骰子，扔出的数字放进文本串的末尾，如果模式串为文本串的子串则停止扔骰子，问文本串的期望长度...



------------


设概率型生成函数 $F(x)$ ，其中 $F(x)$ 的第 $i$ 项系数表示在长度为 $i$ 时停止的概率。

那么答案（即期望停止长度）就是 $F'(1)$

再设一个概率型生成函数 $G(x)$，其中 $G(x)$ 表示在长度为 $i$ 时**不**停止的概率


那么就有下面两个式子：

$$
F(x)+G(x)=1+x \cdot G(x) 
$$

对于这个式子的解释：长度 $i$ 由长度 $i-1$ 转移而来

$$
G(x) \cdot (\frac{1}{m})^n =\sum_{j=1}^n a_j  F(x) \cdot (\frac{1}{m})^{n-j}
$$

其中 $a_j$ 表示 $b[1...j]$  是否是一个 border

对这个式子的解释：

左边很显然，是在给不停止的串加上模式串，强行令它停止；

而右边则是给停止的串加上模式串末尾 $n-j$ 的字符，因为 $b[1..j]$ 是一个 border 所以这个新串末尾 $n$ 个字符刚好就组成了模式串，可以自己画图想一想。意义显然与左边相同。



对于第一个式子可以求导。

设 $G(x)=\sum_{i}x^i g_i$

那么 $x \cdot G(x)=\sum_{i}x^{i+1}g_i$


把这个东西求导一下就是 $\sum_{i}(i+1) x^i g_i$，也就是 $x \cdot G'(x)+G(x)$


那么就得出

$$
F'(x)+G'(x)=x \cdot G'(x)+G(x)
$$

把 $x=1$ 代入上式，得：

$$
F'(1)=G(1)
$$

显然 $G'(1)=1 \cdot G'(1)$


对于第二个式子，考虑对两边同时乘 $m^n$ ，得：

$$
G(x) =\sum_{j=1}^n a_j F(x) \cdot m^j
$$

把 $x=1$ 代入上式，得：

$$
G(1)=\sum_{j=1}^n a_j \cdot m^j
$$

至于为什么，是因为 $F(1)=\sum_{i}f_i=1$（其中 $f_i$ 为长度为 $i$ 时停止的概率，显然所有的概率加起来就是 $1$ ）



就可以得出答案 $\sum_{j=1}^n a_j\cdot m^j$


代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=10000;
const int N=1e5+5;
int kmp[N],a[N];
ll ans;
ll ksm(ll b,int n){
	ll res=1;
	while(n){
		if(n&1) res=res*b%mod;
		b=b*b%mod; n>>=1;
	}
	return res;
}
int main(){
	int m,t,n;
	cin>>m>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;++i)
			cin>>a[i];
		for(int i=2,j=0;i<=n;++i){
			while(j && a[j+1]!=a[i]) j=kmp[j];
			if(a[j+1]==a[i]) ++j;
			kmp[i]=j;
		}
		ans=0;
		int j=n;
		while(j) ans+=ksm(m,j),ans%=mod,j=kmp[j];	
		if(ans<1000) putchar('0');
		if(ans<100) putchar('0');
		if(ans<10) putchar('0');
		cout<<ans<<endl;
	}
	return 0;
}
```


---


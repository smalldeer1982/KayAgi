# [省选联考 2022] 最大权独立集问题

## 题目描述

小 E 喜欢出最大权独立集问题。

接下来，他还想了 $n$ 道最大权独立集问题。

小 E 有 $n$ 个 AI，编号为 $1 \sim n$。

开始时第 $i$ 个 AI 里面存有 $d_i$ 道小 E 事先出好的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \leq i \leq n$ ，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。其中 $c_i < i$，且相同的 $c_i$ 出现不超过 $2$ 次。所以，这些 AI 连成了一个二叉树的形状。此外，其他对 AI 不可以互相通信。

小 E 需要暂时断开这些 AI 之间的连接。他只能逐一断开 AI 之间的连接。两个原本能够互相通信的 AI 在断开它们之间的连接之前，会互相交换存在里面的所有题目，具体请见样例。

小 E 希望在断掉所有连接之后，参与交换的题目数量最少。
他想叫你帮他解决这个问题，还说如果你成功解决了这个问题，那么在出那些最大权独立集问题的时候，他会帮你提交一份标程代码。

## 说明/提示

**【样例解释 #1】**

一种最优的方案是：断开 $1$ 号与 $2$ 号 AI 之间的连接，这样需要交换 $2 + 1 = 3$ 道题；然后断开 $1$ 号与 $3$ 号 AI 之间的连接，这样需要交换 $1 + 3 = 4$ 道题。所以答案是 $7$。

**【数据范围】**

保证 $1 \le c_i \le i$，且相同的 $c_i$ 最多出现两次。

保证 $1 \le d_i \le {10}^9$。

| 测试点编号 | $n \leq$ |
|:-:|:-:|
| $1 \sim 3$ | $10$ |
| $4 \sim 7$ | $100$ |
| $8 \sim 11$ | $500$ |
| $12 \sim 16$ | $1000$ |
| $17 \sim 25$ | $5000$ |

## 样例 #1

### 输入

```
3
2 1 3
1 1```

### 输出

```
7```

# 题解

## 作者：KaguyaH (赞：31)

### Problem Statement

给定 $n$ 个点的二叉树，点有权值 $d_{1 \dots n}$。需要依次删除所有边。删边代价为两端点权值和；删边前会交换两端点权值。求最小总代价。

### Constraints

$1 \le n \le 5 \times 10^3, 1 \le d_i \le 10^9$。

---

### Solution

> Changelog: 修正了部分笔误，提供了避免斜率优化的做法。

记 $S_r$ 表示以 $r$ 为根的子树。认为点权是在树上移动的。

设 $f_{u, v}$ 表示 $S_{\operatorname{lca}(u, v)}$ 中，将 $d_u$ 移出，移入的点权最终停留在 $v$，删去子树中所有边以及 $\operatorname{lca}(u, v)$ 入边的最小总代价（不包括换入的点权）。

按 $r = \operatorname{lca}(u, v)$ 自下而上的顺序转移。下文中「朴素转移」意为枚举所有合法转移。下文 $d$ 可能表示节点，但不会造成歧义，请注意区分。由于公式较多，有可能出现笔误。

- 若 $\deg r = 0$：$f_{r, r} = d_r$。

- 若 $\deg r = 1$：

  - 记 $d$ 为 $r$ 的孩子。
  - 若 $u = r$：$f_{u, v} = \min \lbrace d_u + f_{w, v} \rbrace \pod { \operatorname{lca}(v, w) = d }$。枚举 $v, w$，总时间复杂度 $O(n^2)$。
  - 若 $v = r$：$f_{u, v} = \min \lbrace f_{u, w} + d_u + d_v(\operatorname{dep}_w - \operatorname{dep}_v) \rbrace \pod {\operatorname{lca}(u, w) = d}$。枚举 $u, w$，总时间复杂度 $O(n^2)$。

- 若 $\deg r = 2$：

  - 若 $u = r$：

    记 $d$ 为 $r$ 在 $v$ 一侧的孩子，$d'$ 为另一侧的孩子。易知：应先删掉 $r$ 的入边；再删掉 $r \to d$ 的边；再删掉 $r \to d'$ 的边。

    枚举 $w$ 使得 $d_w$ 由 $S_d$ 移至 $S_{d'}$；枚举 $x$ 由 $S_{d'}$ 移至 $r$；枚举 $d_w$ 移至的点 $y$；则有：
    $$
    \begin{aligned}
    f_{u, v} &= \min_{w, x, y} \lbrace d_u + f_{w, v} + f_{x, y} + d_w({\operatorname{dep}}_y - {\operatorname{dep}}_u) \rbrace \cr
    &= d_u + \min_{y} \lbrace \min_x f_{x, y} + \min_w \lbrace ({\operatorname{dep}}_y - {\operatorname{dep}}_u) \cdot d_w + f_{w, v} \rbrace \rbrace \cr
    &= d_u + \min_w \lbrace f_{w, v} + \min_y \lbrace (\operatorname{dep}_y - \operatorname{dep}_u) \cdot d_w + \min_x f_{x, y} \rbrace \rbrace
    \end{aligned}
    \pod{ \operatorname{lca}(v, w) = d, \operatorname{lca}(x, y) = d'}
    $$
    按照第二行的式子，发现 $v$ 确定时第二层大括号内部形如一个关于 $\operatorname{dep}_y - \operatorname{dep}_u$ 的一次函数。可以斜率优化。枚举 $w$ 预处理；枚举 $y$ 转移；总时间复杂度 $O(n^2)$。
    
    此外，若按照第三行的式子，发现第三层 $\min$ 仅与 $y$ 有关，第二层 $\min$ 仅与 $w$ 有关；可以枚举 $y, x$ 预处理每个 $y$ 对应的第三层的值，枚举 $w, y$ 预处理每个 $w$ 对应的第二层的值，枚举 $v, w$ 进行转移，即可避免斜率优化。总时间复杂度 $O(n^2)$。

  - 若 $v = r$：

    记 $d$ 为 $r$ 在 $u$ 一侧的孩子，$d'$ 为另一侧的孩子。易知：应先删掉 $r \to d'$ 的边；再删掉 $r \to d$ 的边；再删掉 $r$ 的入边。

    枚举 $w$ 使得 $d_w$ 由 $S_{d'}$ 移至 $S_d$；枚举 $d_r$ 移至的点 $x$；枚举 $d_w$ 移至的点 $y$；则有：
    $$
    \begin{aligned}
    f_{u, v} &= \min_{w, x, y} \lbrace f_{w, x} + d_v(\operatorname{dep}_x - \operatorname{dep}_v) + f_{u, y} + d_w(\operatorname{dep}_y - \operatorname{dep}_v) + d_u \rbrace\cr
    &= d_u + \min_y \lbrace f_{u, y} + \min_w \lbrace d_w (\operatorname{dep}_y - \operatorname{dep}_v) + \min_x \lbrace f_{w, x}  + d_v (\operatorname{dep}_x - \operatorname{dep}_v) \rbrace \rbrace \rbrace
    \end{aligned}
    \pod{\operatorname{lca}(w, x) = d', \operatorname{lca}(u, y) = d}
    $$

    发现第二层 $\min$ 与 $u$ 无关，第三层 $\min$ 与 $y$ 无关。枚举 $w, x$ 预处理；枚举 $y, w$ 预处理；枚举 $u, y$ 转移；总时间复杂度 $O(n^2)$。

  - 若 $u \ne r, v \ne r$：

    记 $d$ 为 $r$ 在 $u$ 一侧的孩子，$d'$ 为 $r$ 在 $v$ 一侧的孩子。易知：应先删掉 $r \to d$ 的边；再删掉 $r$ 的入边；再删掉 $r \to d'$ 的边。

    枚举 $d_r$ 移至的点 $w$；枚举 $x$ 使得 $d_x$ 由 $S_{d'}$ 移至 $r$；则有：
    $$
    f_{u, v} = \min_{w, x} \lbrace f_{u, w} + d_r (\operatorname{dep}_w - \operatorname{dep}_r) + d_u + f_{x, v} \rbrace
    \pod{ \operatorname{lca}(u, w) = d, \operatorname{lca}(v, x) = d' }
    $$

    枚举 $u, w$ 预处理；枚举 $u, v$ 转移；总时间复杂度 $O(n^2)$。

时空复杂度 $O(n^2)$。

---

## 作者：WeLikeStudying (赞：14)

- 对自己的问题没有新的体会。
- 风从大地卷来，
- 雨从大地奔来。
- 郊原如海，
- 房舍如舟。
- 我有年轻舵手的心，
- 在大地风雨的海上。
- 感谢[大佬](https://www.luogu.com.cn/user/52170)的一些指导，祝愿其信息学之路光芒璀璨。
- 正解真的很妙，相比之下这个大暴力写挂也没啥好说的。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P8294)。
- 给出一个二叉树，每个点有点权，按顺序切断它的 $n-1$ 条边，代价是边所连的两个点的权值和，且断边之后两点会交换权值，你的目的是最小化权值和。

**分析**
- 你迅速想到了树形 $\text{DP}$ 的思路，但似乎难以入手。
- 二叉树的性质使得它便于合并，你尝试思考，发现对于一个节点（旁边的 $3$ 条边），断边的次序情况至多有 $3!$ 种情况，尝试根据它列一个简单的动态规划。
![](https://cdn.luogu.com.cn/upload/image_hosting/d2xdvf1a.png)
- 比如说：$f(u,a,b)$ 表示子树 $u$ 在断掉上面连的一条边之前原来节点 $a$ 跑到了这里，断掉之后，节点 $b$ 跑到这里的最短距离，就是算答案有点麻烦，最暴力的实现是 $O(n^4)$ 的，[代码](https://www.luogu.com.cn/paste/y5umj0dn)，但是对于 $6$ 种转移稍微针对下，容易优化到 $O(n^3)$，[代码](https://www.luogu.com.cn/paste/hkoli7b2)。
- 但是很悲剧的问题是我们这个动态规划的状态总数就是 $O(n^3)$，所以继续沿着这条道路优化就行不通了……
- 你迅速地发现，在对原本的动态规划进行转移的时候，有几种情况是不必设 $O(n^3)$ 的状态的：
- 比如说：第二个位移图暗示它只会输出节点 $u$，第三个位移图暗示输入的节点根本无法动弹。
- 而第一种位移似乎是最复杂的，但是它给的暗示也最明确：它暗示它的左子树只会接受它父亲的给予，而右子树输出的节点根本无法动弹。
- 它的实质就是利用三种位移图的那个不连续的“断边”优化状态。
- 因此你用一种极其奇怪的方式做到了 $O(n^2)$ 的状态数，但是它的复杂度是否真的更好一点呢？
- 那当然取决于我们的动态规划方法，你列出了如下方程（以上所有式子都不严格，具体实现要另外考虑）：
- $f(u,i,j)$ 表示子树 $u$ 在断掉上面连的一条边之前原来节点 $i$ 跑到了这里，断掉之后，节点 $j$ 跑到这里的最短距离。
- $f_0(u,i)=f(u,u,i)$，输出 $u$ 的情况。
- $f_1(u,i)$ 表示子树 $u$ 会输出节点 $i$，同时只让外来节点在 $u$ 上停留的情况。
- $f_2(u,i)=f(u,i,\text{fa}(u))$，直接与它父亲交换的情况。
- $f_3(u,i)=\min_{j=1}^nf(u,j,i)+w_i+w_j$，考虑输出节点无法动弹的情况。
- 然后你发现：
- $f_0(u,i)\to f(u,u,i)$，$f_1(u,i)+w_i+w_j\to f(u,i,j)$。
- 如果 $u$ 有两个儿子 $a,b$：$f_2(a,i)+f_3(b,j)\to f(u,i,j)$。
- 刚才的推导告诉我们只需要这三类贡献就可以计算出 $f(u,i,j)$，也就是说它实际上可以 $O(1)$ 计算，如果直接暴力推导的话我们就牺牲了一点常数换来了空间复杂度 $O(n^2)$ 的 $O(n^3)$ 做法（因为 $f_2,f_3$ 很有用），[代码](https://www.luogu.com.cn/paste/t2ex2woi)。
- 然后它可以优化为 $O(n^2)$（只有一个 $f$ 的求值其实很好优化），大概就是把里面的函数暴力展开下就好了（如果你想听的详细点的话：里面的式子要么只和 $i$ 有关要么之和 $j$ 有关，可以先一次循环求出最值，再一次循环更新），怎么说呢，思维难度极低（这个 DP 优化甚至可以在一些黄题里找到），代码难度低（绝大部分的情况都是复制粘贴）[代码](https://www.luogu.com.cn/paste/abrb2kbq)。

---

## 作者：柳下惠 (赞：12)

[题目链接](https://www.luogu.com.cn/problem/P8294)。

### 正文

其它两篇已经讲的很详细了，本篇题解主讲 `dp` 的设计状态。

一个比较好的理解是 `dp[x][v][i]` 表示 $x$ 子树被扔到子树外的是 $v$ 这个点的值，然后被扔进来的数在子树内对答案贡献了 $i$。

我们注意到这个状态是 $n^2$ 的，但由于是二叉树，我们可以 $3!$ 阶乘枚举子树根节点周围的边断边顺序。

只要把需要在转移时用的数据预处理出来就可以了。

个人感觉还是很好理解的。

---

## 作者：tzc_wk (赞：9)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P8294)

巨大精神污染题。

首先考虑 $n^3$ 做法：$dp_{i,j,k}$ 表示目前已经断掉了 $i$ 子树内所有边以及 $i$ 与父亲的边，假设初始时 $k$ 被换到了 $i$ 的父亲的位置，要将 $j$ 换出 $i$ 的子树，$k$ 换入 $i$ 的子树所需的最小代价。列出状态后，转移应该是比较显然的：
$$
dp_{i,j,k}=
\begin{cases}
d_j+d_k&(\text{leftson}=\varnothing,\text{rightson}=\varnothing)\\
d_j+d_k+\min\limits_{l\in\text{subtree}(i),l\ne i}dp_{ls,l,k}&(\text{leftson}\ne\varnothing,\text{rightson}=\varnothing,j=i)\\
d_j+d_k+dp_{ls,j,i}&(\text{leftson}\ne\varnothing,\text{rightson}=\varnothing,j\ne i)\\
d_j+d_k+\min\limits_{x\in\text{subtree}(ls_i)}\min\limits_{y\in\text{subtree}(rs_i)}\min(dp_{ls,x,k}+dp_{rs,y,x},dp_{rs,y,k}+dp_{ls,x,y})&(\text{leftson}\ne\varnothing,\text{rightson}\ne\varnothing,j=i)\\
d_j+d_k+\min\limits_{x\in\text{subtree}(rs_i)}\min(dp_{ls,j,i}+dp_{rs,x,k},dp_{rs,x,i}+dp_{ls,j,x})&(\text{leftson}\ne\varnothing,\text{rightson}\ne\varnothing,j\in\text{subtree}(ls))\\
\end{cases}
$$
其中 $son_i$ 表示 $i$ 点的儿子个数，上面转移方程中可能有一些对称的转移没有列出来，这是无关紧要的。

直接这样写可以获得 44 分，代码如下：

```cpp
const int MAXN = 500;
int n, d[MAXN + 5], fa[MAXN + 5], sub[MAXN + 5][MAXN + 5];
int ls[MAXN + 5], rs[MAXN + 5];
ll dp[MAXN + 5][MAXN + 5][MAXN + 5];
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i]);
	for (int i = 2; i <= n; i++) scanf("%d", &fa[i]);
	for (int i = 1; i <= n; i++) sub[i][i] = 1;
	for (int i = 2; i <= n; i++) {
		if (!ls[fa[i]]) ls[fa[i]] = i;
		else rs[fa[i]] = i;
	}
	memset(dp, 63, sizeof(dp));
	for (int i = n; i; i--) {
		for (int j = 1; j <= n; j++) sub[fa[i]][j] |= sub[i][j];
		for (int j = 1; j <= n; j++) if (sub[i][j])
			for (int k = 1; k <= n; k++) if (!sub[i][k]) {
				if (!ls[i]) dp[i][j][k] = d[j] + d[k];
				else if (!rs[i]) {
					int a = ls[i];
					if (j == i) {
						for (int l = 1; l <= n; l++) if (sub[a][l])
							chkmin(dp[i][j][k], d[j] + d[k] + dp[a][l][k]);
					} else {
						dp[i][j][k] = dp[a][j][i] + d[j] + d[k];
					}
				} else {
					int a = ls[i], b = rs[i];
					if (j == i) {
						for (int x = 1; x <= n; x++) if (sub[a][x])
							for (int y = 0; y <= n; y++) if (sub[b][y]) {
								chkmin(dp[i][j][k], d[j] + d[k] + dp[a][x][k] + dp[b][y][x]);
								chkmin(dp[i][j][k], d[j] + d[k] + dp[b][y][k] + dp[a][x][y]);
							}
					} else if (sub[a][j]) {
						for (int x = 1; x <= n; x++) if (sub[b][x]) {
							chkmin(dp[i][j][k], dp[a][j][i] + d[j] + d[k] + dp[b][x][k]);
							chkmin(dp[i][j][k], dp[b][x][i] + dp[a][j][x] + d[j] + d[k]);
						}
					} else {
						for (int x = 1; x <= n; x++) if (sub[a][x]) {
							chkmin(dp[i][j][k], dp[b][j][i] + d[j] + d[k] + dp[a][x][k]);
							chkmin(dp[i][j][k], dp[a][x][i] + dp[b][j][x] + d[j] + d[k]);
						}
					}
				}
//				printf("dp[%d][%d][%d] = %lld\n", i, j, k, dp[i][j][k]);
			}
	}
	ll mn = 1e18;
	if (!rs[1]) {
		int a = ls[1];
		for (int i = 2; i <= n; i++) chkmin(mn, dp[a][i][1]);
	} else {
		int a = ls[1], b = rs[1];
		for (int i = 2; i <= n; i++) if (sub[a][i])
			for (int j = 2; j <= n; j++) if (sub[b][j]) {
				chkmin(mn, dp[a][i][1] + dp[b][j][i]);
				chkmin(mn, dp[b][j][1] + dp[a][i][j]);
			}
	}
	printf("%lld\n", mn);
	return 0;
}
```

考虑优化，我们考虑在每一轮 DP 的时候处理出以下数组：

- $f0_{i,j}$ 表示根节点为 $i$，把 $i$ 换出去，$j$ 换进来的最小代价，即 $dp_{i,i,j}$。
- $f1_{i,j}$ 表示根节点为 $i$，把 $j$ 换出去，$fa_i$ 换进来的最小代价，即 $dp_{i,j,fa_i}$。
- $f2_{i,j}$ 表示把 $i$ 子树内任何一个点换出去，$j$ 换进来的最小代价，即 $\min\limits_{x\in\text{subtree}(i)}dp_{i,x,j}$。
- $f3_{i,j}$ 表示先交换 $j$ 相对于 $i$ 的另一侧子树内某个节点 $x$，并把 $x$ 换出去、把 $i$ 换进另一侧子树，再将 $x$ 换进 $j$ 这一侧子树，$j$ 换出去的最小代价。这句话读起来稍微有点拗口，写成式子的形式就是如果 $j$ 在 $x$ 左儿子子树内，那么 $f3_{i,j}=\min\limits_{x\in\text{subtree}(rs_i)}dp_{rs,x,i}+dp_{ls,j,x}$，对于右子树的情况也类似。

求出这四个数组有什么好处呢？不难发现有了这四个数组后我们就可以 $\mathcal O(1)$ 地求出 $dp_{i,j,k}$，即
$$
dp_{i,j,k}=
\begin{cases}
f0_{i,k}&(j=i)\\
f1_{ls,j}+d_j+d_k&(\text{leftson}\ne\varnothing,\text{rightson}=\varnothing)\\
\min(f1_{ls,j}+f2_{rs,k},f3_{ls,j})+d_j+d_k&(\text{leftson}\ne\varnothing,\text{rightson}=\varnothing,j\in\text{subtree(ls)})\\
\end{cases}
$$
这样空间复杂度就降到了 $n^2$，但是时间复杂度还是 $n^3$，大概取决于实现可以通过部分 $n\le 1000$ 的测试点。

附：这部分的代码：

```cpp
const int MAXN = 5000;
int n, d[MAXN + 5], fa[MAXN + 5], sub[MAXN + 5][MAXN + 5];
int ls[MAXN + 5], rs[MAXN + 5];
vector<int> vec[MAXN + 5];
ll f0[MAXN + 5][MAXN + 5], f1[MAXN + 5][MAXN + 5], f2[MAXN + 5][MAXN + 5], f3[MAXN + 5][MAXN + 5];
ll calc(int i, int j, int k) {
	if (j == i) return f0[i][k];
	else if (!rs[i]) return f1[ls[i]][j] + d[j] + d[k];
	else {
		int a = ls[i], b = rs[i];
		if (sub[a][j]) return min(f1[a][j] + f2[b][k], f3[i][j]) + d[j] + d[k];
		else return min(f1[b][j] + f2[a][k], f3[i][j]) + d[j] + d[k];
	}
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i]);
	for (int i = 2; i <= n; i++) scanf("%d", &fa[i]);
	for (int i = 1; i <= n; i++) sub[i][i] = 1, vec[i].pb(i);
	for (int i = 2; i <= n; i++) {
		if (!ls[fa[i]]) ls[fa[i]] = i;
		else rs[fa[i]] = i;
	}
	for (int i = n; i > 1; i--) {
		for (int j = 1; j <= n; j++) sub[fa[i]][j] |= sub[i][j];
		for (int x : vec[i]) vec[fa[i]].pb(x);
		for (int k = 1; k <= n; k++) if (!sub[i][k]) {
			if (!ls[i]) f0[i][k] = d[i] + d[k];
			else if (!rs[i]) f0[i][k] = d[i] + d[k] + f2[ls[i]][k];
			else {
				int a = ls[i], b = rs[i];
				f0[i][k] = 1e18;
				for (int x : vec[a]) for (int y : vec[b]) {
					chkmin(f0[i][k], d[i] + d[k] + calc(a, x, k) + calc(b, y, x));
					chkmin(f0[i][k], d[i] + d[k] + calc(b, y, k) + calc(a, x, y));
				}
			}
		}
		if (rs[i]) {
			int a = ls[i], b = rs[i];
			for (int x : vec[a]) f3[i][x] = 1e18;
			for (int x : vec[b]) f3[i][x] = 1e18;
			for (int x : vec[a]) for (int y : vec[b]) chkmin(f3[i][x], calc(b, y, i) + calc(a, x, y));
			for (int x : vec[a]) for (int y : vec[b]) chkmin(f3[i][y], calc(a, x, i) + calc(b, y, x));
		}
		for (int j : vec[i]) f1[i][j] = calc(i, j, fa[i]);
		for (int j = 1; j <= n; j++) if (!sub[i][j]) {
			f2[i][j] = 1e18;
			for (int x : vec[i]) chkmin(f2[i][j], calc(i, x, j));
		}
	}
	ll mn = 1e18;
	if (!rs[1]) {
		int a = ls[1];
		for (int i = 2; i <= n; i++) chkmin(mn, calc(a, i, 1));
	} else {
		int a = ls[1], b = rs[1];
		for (int i : vec[a])  for (int j : vec[b]) {
			chkmin(mn, calc(a, i, 1) + calc(b, j, i));
			chkmin(mn, calc(b, j, 1) + calc(a, i, j));
		}
	}
	printf("%lld\n", mn);
	return 0;
}
/*
10
9 5 6 3 8 7 1 4 1 3
1 2 2 4 1 4 3 8 5
*/
```

接下来就是略微有点 dirty work 的地方了，注意到在上面的 DP 过程中，求解 $f1$ 的部分复杂度肯定不会出错，$f3$ 部分的复杂度分析类似于树形 DP，也是 $\mathcal O(n^2)$ 的，复杂度瓶颈在于 $f0$ 和 $f2$，因此我们需要着手去优化它。以 $f2$ 为例，我们固定了 $i$，要对于每个 $j$，求出 $\min\limits_{x\in\text{subtree}(i)}dp_{i,x,j}$，不妨先特判 $x=i$，对于 $x\ne i$，按照上面的公式展开 $dp_{i,x,j}$，分情况讨论：

- 如果 $i$ 没有右儿子，那么 $dp_{i,x,j}=d_x+d_j+f1_{ls,x}$，因此我们遍历所有 $x$ 并维护 $d_x+f1_{ls,x}$ 的最小值。
- 如果 $i$ 有右儿子，那么这里不妨考虑 $x$ 在 $i$ 左子树内情况，另一部分镜像一下即可。则 $dp_{i,x,j}=\min(f1_{ls,x}+f2_{rs,j},f3_{i,x})+d_x+d_j$，我们将两部分分别求 $\min$，即求 $f1_{ls,x}+f2_{rs,j}+d_x+d_j$ 和 $f3_{i,x}+d_x+d_j$ 的最小值，这样我们只用遍历 $x$ 的同时维护 $f1_{ls,x}+d_x$ 和 $f3_{i,x}+d_x$ 的最小值即可。

$f0$ 的处理也是类似的，类似于一个参变分离的思想。这样时空复杂度均降到了 $\mathcal O(n^2)$。细节很多。

```cpp
const int MAXN = 5000;
int n, d[MAXN + 5], fa[MAXN + 5], sub[MAXN + 5][MAXN + 5];
int ls[MAXN + 5], rs[MAXN + 5];
vector<int> vec[MAXN + 5];
ll f0[MAXN + 5][MAXN + 5]; // f0[i][j] 表示根节点为 i，把 i 换出去，j 换进来的最小代价。 
ll f1[MAXN + 5][MAXN + 5]; // f1[i][j] 表示根节点为 i，把 j 换出去，fa[i] 换进来的最小代价 
ll f2[MAXN + 5][MAXN + 5]; // f2[i][j] 表示可以把 i 子树内任何一个点换出去，j 换进来的最小代价 
ll f3[MAXN + 5][MAXN + 5];
// f3[i][j] 表示先交换 j 相对于 i 的另一侧子树内某个节点 x，并把 x 换出去、把 i 换进另一侧子树，再将 x 换进 j 这一侧子树，j 换出去的最小代价。
ll calc(int i, int j, int k) {
	if (j == i) return f0[i][k];
	else if (!rs[i]) return f1[ls[i]][j] + d[j] + d[k];
	else {
		int a = ls[i], b = rs[i];
		if (sub[a][j]) return min(f1[a][j] + f2[b][k], f3[i][j]) + d[j] + d[k];
		else return min(f1[b][j] + f2[a][k], f3[i][j]) + d[j] + d[k];
	}
}
int main() {
	freopen("mis.in", "r", stdin);
	freopen("mis.out", "w", stdout);
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i]);
	for (int i = 2; i <= n; i++) scanf("%d", &fa[i]);
	for (int i = 1; i <= n; i++) sub[i][i] = 1, vec[i].pb(i);
	for (int i = 2; i <= n; i++) {
		if (!ls[fa[i]]) ls[fa[i]] = i;
		else rs[fa[i]] = i;
	}
	for (int i = n; i > 1; i--) {
		for (int j = 1; j <= n; j++) sub[fa[i]][j] |= sub[i][j];
		for (int x : vec[i]) vec[fa[i]].pb(x);
		if (!ls[i]) {
			for (int k = 1; k <= n; k++) if (!sub[i][k])
				f0[i][k] = d[i] + d[k];
		}
		else if (!rs[i]) {
			for (int k = 1; k <= n; k++) if (!sub[i][k])
				f0[i][k] = d[i] + d[k] + f2[ls[i]][k];
		}
		else {
			int a = ls[i], b = rs[i];
			for (int k = 1; k <= n; k++) if (!sub[i][k]) f0[i][k] = 1e18;
			ll mn1 = 1e18, mn2 = 1e18, mn3 = 1e18;
			for (int x : vec[a]) {
				ll mn = 1e18;
				for (int y : vec[b]) chkmin(mn, calc(b, y, x));
				if (x == a) {
					for (int k = 1; k <= n; k++) if (!sub[i][k])
						chkmin(f0[i][k], d[i] + d[k] + calc(a, x, k) + mn);
					continue;
				}
				if (!rs[a]) chkmin(mn1, mn + d[i] + f1[ls[a]][x] + d[x]);
				else {
					int aa = ls[a], ab = rs[a];
					if (sub[aa][x]) {
						// calc(a, x, k) = min(f1[aa][x] + f2[ab][k], f3[a][x]) + d[x] + d[k]
						chkmin(mn2, f1[aa][x] + d[x] + mn + d[i]);
						chkmin(mn1, d[x] + mn + d[i] + f3[a][x]);
					} else {
						chkmin(mn3, f1[ab][x] + d[x] + mn + d[i]);
						chkmin(mn1, d[x] + mn + d[i] + f3[a][x]);
					}
				}
			}
			if (!rs[a]) {
				for (int k = 1; k <= n; k++) if (!sub[i][k])
					chkmin(f0[i][k], mn1 + d[k] + d[k]);
			} else {
				int aa = ls[a], ab = rs[a];
				for (int k = 1; k <= n; k++) if (!sub[i][k]) {
					chkmin(f0[i][k], mn1 + d[k] + d[k]);
					chkmin(f0[i][k], mn2 + f2[ab][k] + d[k] + d[k]);
					chkmin(f0[i][k], mn3 + f2[aa][k] + d[k] + d[k]);
				}
			}
			swap(a, b);
			mn1 = 1e18, mn2 = 1e18, mn3 = 1e18;
			for (int x : vec[a]) {
				ll mn = 1e18;
				for (int y : vec[b]) chkmin(mn, calc(b, y, x));
				if (x == a) {
					for (int k = 1; k <= n; k++) if (!sub[i][k])
						chkmin(f0[i][k], d[i] + d[k] + calc(a, x, k) + mn);
					continue;
				}
				if (!rs[a]) chkmin(mn1, mn + d[i] + f1[ls[a]][x] + d[x]);
				else {
					int aa = ls[a], ab = rs[a];
					if (sub[aa][x]) {
						// calc(a, x, k) = min(f1[aa][x] + f2[ab][k], f3[a][x]) + d[x] + d[k]
						chkmin(mn2, f1[aa][x] + d[x] + mn + d[i]);
						chkmin(mn1, d[x] + mn + d[i] + f3[a][x]);
					} else {
						chkmin(mn3, f1[ab][x] + d[x] + mn + d[i]);
						chkmin(mn1, d[x] + mn + d[i] + f3[a][x]);
					}
				}
			}
			if (!rs[a]) {
				for (int k = 1; k <= n; k++) if (!sub[i][k])
					chkmin(f0[i][k], mn1 + d[k] + d[k]);
			} else {
				int aa = ls[a], ab = rs[a];
				for (int k = 1; k <= n; k++) if (!sub[i][k]) {
					chkmin(f0[i][k], mn1 + d[k] + d[k]);
					chkmin(f0[i][k], mn2 + f2[ab][k] + d[k] + d[k]);
					chkmin(f0[i][k], mn3 + f2[aa][k] + d[k] + d[k]);
				}
			}
		}
		if (rs[i]) {
			int a = ls[i], b = rs[i];
			for (int x : vec[a]) f3[i][x] = 1e18;
			for (int x : vec[b]) f3[i][x] = 1e18;
			for (int x : vec[a]) for (int y : vec[b]) chkmin(f3[i][x], calc(b, y, i) + calc(a, x, y));
			for (int x : vec[a]) for (int y : vec[b]) chkmin(f3[i][y], calc(a, x, i) + calc(b, y, x));
		}
		for (int j : vec[i]) f1[i][j] = calc(i, j, fa[i]);
		for (int j = 1; j <= n; j++) if (!sub[i][j]) f2[i][j] = calc(i, i, j);
		if (!rs[i]) {
			ll mn = 1e18;
			for (int v : vec[ls[i]]) chkmin(mn, d[v] + f1[ls[i]][v]);
			for (int k = 1; k <= n; k++) if (!sub[i][k]) chkmin(f2[i][k], mn + d[k]);
		} else {
			ll mn1 = 1e18, mn2 = 1e18, mn3 = 1e18;
			int a = ls[i], b = rs[i];
			for (int v : vec[a]) chkmin(mn1, f1[a][v] + d[v]), chkmin(mn3, f3[i][v] + d[v]);
			for (int v : vec[b]) chkmin(mn2, f1[b][v] + d[v]), chkmin(mn3, f3[i][v] + d[v]);
			for (int k = 1; k <= n; k++) if (!sub[i][k]) {
				chkmin(f2[i][k], mn1 + f2[b][k] + d[k]);
				chkmin(f2[i][k], mn2 + f2[a][k] + d[k]);
				chkmin(f2[i][k], mn3 + d[k]);
			}
		}
	}
	ll mn = 1e18;
	if (!rs[1]) {
		int a = ls[1];
		for (int i = 2; i <= n; i++) chkmin(mn, calc(a, i, 1));
	} else {
		int a = ls[1], b = rs[1];
		for (int i : vec[a])  for (int j : vec[b]) {
			chkmin(mn, calc(a, i, 1) + calc(b, j, i));
			chkmin(mn, calc(b, j, 1) + calc(a, i, j));
		}
	}
	printf("%lld\n", mn);
	return 0;
}
/*
10
9 5 6 3 8 7 1 4 1 3
1 2 2 4 1 4 3 8 5
*/
```



---

## 作者：山田リョウ (赞：6)

省选破防后独立做出来的第一道题。

我的评价是这一场 d2t3 << d2t1。

显然这些操作是对 $d$ 做一个置换 $p$，所求即为最小化 $\sum\limits_{i=1}^n\text{dist}(i,p_i)d_i$。

简单分析下可知 $p$ 满足恰有一个置换环（考察操作开始前有 $n$ 个置换环，由于是树故每次操作恰好拼接两个置换环，于是经过 $n-1$ 次操作后只剩一个置换环），而且任意一条边的某一侧所有点在环上都恰好是连续段。更进一步地，可以发现这些限制是充要的。[The 2nd UCup Finals 有道类似的题。](https://qoj.ac/contest/1919/problem/10110)

于是我们先定根为 $1$（这样根据题目可知一定是二叉树），容易设计出状态 $f_{u,v_1,v_2}$ 表示满足首位是 $v_1$ 且末位是 $v_2$ 的 $u$ 子树点排列，只计内部置换边的贡献和的最小值。

这样看起来是 $O(n^3)$ 的不太能接受，但是不难发现必有 $\text{LCA}(v_1,v_2)=u$，于是可以缩掉 $u$ 那一维，故有效状态量是 $O(n^2)$ 的。

接下来考虑如何转移，我们应当重新阅读题目条件并发现这是一棵二叉树！！！

叶子和恰有一个儿子的点的转移均是容易的，只考虑有两个儿子时怎么做。

第一种情况是两个子树间夹着 $u$，不妨这几个端点是 $v_1,v_2,u,v_3,v_4$，只需先对 $v_1$ 和 $v_4$ 分别预处理出最优的 $v_2$ 和 $v_3$ 即可。

第二种情况是 $u$ 在开头或结尾，不妨设是前者，端点有 $u,v_1,v_2,v_3,v_4$，仿照第一种情况预处理出对于 $v_2$ 最优的 $v_1$，再对 $v_3$ 预处理出最优的 $v_2$，然后转移即可。

综上所述，我们的复杂度为 $O(n^2)$，精细实现可以通过。

[submission.](https://qoj.ac/submission/933364)

---

## 作者：Renshey (赞：6)

#### 题解

首先不难想到 dp：$f_{u,x,y}$ 表示子树 $u$ 内 $x$ 换出去，$y$ 换进来的最小代价。

$x$ 这一维类似于树上背包，不会影响效率，但 $y$ 这一维显然无法继续优化了。于是 $y$ 改为记录换进来的点最终位置为 $y$，在换进来时再考虑这个点产生的贡献。

转移时需要枚举两个儿子的 $x,y$，但注意到这四个信息总是有若干个是相互独立的，因此预处理类似于前缀 $\min$ 的东西之后只需要枚举两维。这样两维的合并依旧与树形背包类似，考虑点对间的贡献可以得到时间复杂度为 $O(n^2)$。

实现时为了方便可以直接记录 $y$ 距离 $u$ 的深度而非节点，但需要注意对 $y$ 的范围进行限制。

时间和空间复杂度均为 $O(n^2)$。

#### 代码

```cpp
#include <bits/stdc++.h>
const long long inf = 1LL << 60;
int n, a[5010], fa[5010], ch[5010][2], dep[5010]; long long ans = inf;
std::vector<int> S[5010]; std::vector<long long> f[5010][5010];
signed main ()
{
	scanf("%d", &n); dep[0] = -1;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 2; i <= n; i++) scanf("%d", &fa[i]), ch[fa[i]][ch[fa[i]][0] > 0] = i;
	for (int i = n; i; i--)
	{
		S[i].push_back(i);
		dep[i] = std::max(dep[ch[i][0]], dep[ch[i][1]]) + 1;
		for (int j : S[ch[i][0]]) S[i].push_back(j);
		for (int j : S[ch[i][1]]) S[i].push_back(j);
		f[i][i].resize(dep[i] + 1);
		for (int j : S[ch[i][0]]) f[i][j].resize(dep[ch[i][1]] + 2);
		for (int j : S[ch[i][1]]) f[i][j].resize(dep[ch[i][0]] + 2);
		for (int d = 0; d <= dep[i]; d++) f[i][i][d] = inf;
		for (int j : S[ch[i][0]]) for (int d = 0; d <= dep[ch[i][1]] + 1; d++) f[i][j][d] = inf;
		for (int j : S[ch[i][1]]) for (int d = 0; d <= dep[ch[i][0]] + 1; d++) f[i][j][d] = inf;
		if (!ch[i][0]) f[i][i][0] = a[i];
		else if (!ch[i][1])
		{
			for (int j : S[ch[i][0]]) for (int d = 0; d < (int)f[ch[i][0]][j].size(); d++)
				f[i][i][d + 1] = std::min(f[i][i][d + 1], f[ch[i][0]][j][d] + a[i]),
				f[i][j][0] = std::min(f[i][j][0], f[ch[i][0]][j][d] + a[j] + 1LL * (d + 1) * a[i]);
		}
		else
		{
			int maxp = 0, maxq = 0; long long tmp1[5010] = {0}, tmp2[5010] = {0}, tmp3[5010] = {0}, tmp4[5010] = {0};
			for (int j : S[ch[i][0]]) maxp = std::max(maxp, (int)f[ch[i][0]][j].size()), tmp3[j] = inf;
			for (int k : S[ch[i][1]]) maxq = std::max(maxq, (int)f[ch[i][1]][k].size()), tmp4[k] = inf;
			for (int p = 0; p < maxp; p++) tmp1[p] = inf;
			for (int q = 0; q < maxq; q++) tmp2[q] = inf;
			for (int j : S[ch[i][0]]) for (int p = 0; p < (int)f[ch[i][0]][j].size(); p++) tmp1[p] = std::min(tmp1[p], f[ch[i][0]][j][p]);
			for (int k : S[ch[i][1]]) for (int q = 0; q < (int)f[ch[i][1]][k].size(); q++) tmp2[q] = std::min(tmp2[q], f[ch[i][1]][k][q]);
			for (int j : S[ch[i][0]]) for (int p = 0; p < (int)f[ch[i][0]][j].size(); p++) tmp3[j] = std::min(tmp3[j], f[ch[i][0]][j][p] + 1LL * (p + 1) * a[i]);
			for (int k : S[ch[i][1]]) for (int q = 0; q < (int)f[ch[i][1]][k].size(); q++) tmp4[k] = std::min(tmp4[k], f[ch[i][1]][k][q] + 1LL * (q + 1) * a[i]);
			for (int j : S[ch[i][0]])
			{
				long long tmp = inf;
				for (int q = 0; q < maxq; q++) tmp = std::min(tmp, tmp2[q] + 1LL * (q + 1) * a[j]);
				for (int p = 0; p < (int)f[ch[i][0]][j].size(); p++) f[i][i][p + 1] = std::min(f[i][i][p + 1], f[ch[i][0]][j][p] + a[i] + tmp);
			}
			for (int j : S[ch[i][0]])
			{
				long long tmp = inf;
				for (int p = 0; p < (int)f[ch[i][0]][j].size(); p++) tmp = std::min(tmp, f[ch[i][0]][j][p] + 1LL * (p + 1) * a[i]);
				for (int q = 0; q < maxq; q++) f[i][j][q + 1] = std::min(f[i][j][q + 1], a[j] + tmp2[q] + tmp);
			}
			for (int k : S[ch[i][1]])
			{
				long long tmp = inf;
				for (int p = 0; p < maxp; p++) tmp = std::min(tmp, tmp1[p] + 1LL * (p + 1) * a[k]);
				for (int q = 0; q < (int)f[ch[i][1]][k].size(); q++) f[i][i][q + 1] = std::min(f[i][i][q + 1], f[ch[i][1]][k][q] + a[i] + tmp);
			}
			for (int k : S[ch[i][1]])
			{
				long long tmp = inf;
				for (int q = 0; q < (int)f[ch[i][1]][k].size(); q++) tmp = std::min(tmp, f[ch[i][1]][k][q] + 1LL * (q + 1) * a[i]);
				for (int p = 0; p < maxp; p++) f[i][k][p + 1] = std::min(f[i][k][p + 1], a[k] + tmp1[p] + tmp);
			}
			for (int p = 0; p < maxp; p++) tmp1[p] = inf;
			for (int q = 0; q < maxq; q++) tmp2[q] = inf;
			for (int p = 0; p < maxp; p++) for (int k : S[ch[i][1]]) tmp1[p] = std::min(tmp1[p], tmp4[k] + 1LL * (p + 1) * a[k]);
			for (int q = 0; q < maxq; q++) for (int j : S[ch[i][0]]) tmp2[q] = std::min(tmp2[q], tmp3[j] + 1LL * (q + 1) * a[j]);
			for (int k : S[ch[i][1]]) for (int q = 0; q < (int)f[ch[i][1]][k].size(); q++) f[i][k][0] = std::min(f[i][k][0], tmp2[q] + f[ch[i][1]][k][q] + a[k]);
			for (int j : S[ch[i][0]]) for (int p = 0; p < (int)f[ch[i][0]][j].size(); p++) f[i][j][0] = std::min(f[i][j][0], tmp1[p] + f[ch[i][0]][j][p] + a[j]);
		}
	}
	for (int d = 0; d < (int)f[1][1].size(); d++) ans = std::min(ans, f[1][1][d] + 1LL * (d - 1) * a[1]);
	return !printf("%lld\n", ans);
}
```

---

## 作者：Sharpsmile (赞：5)

喜欢树形 dp 的小朋友们你们好啊。

被迫把这个题做出来了。

第一眼先决定搞一个 $n^3$ 暴力看看能多少分然后卡卡常看看多少分。

最后经过精湛卡常获得了$52$。

先来一点奶龙 $n^3$ 做法。

直觉告诉我需要把当前节点上目前的权值是哪个点的塞进状态里。

观察到是二叉树，这个东西肯定是有用的，考虑把边是否被断开塞进状态中。一开始想的状态就是三个边都塞进去，但是发现这样好像不太好转移，或者说不够无脑。

所以我做出了如下状态：$f_{i,j,0/1,0/1}$ 表示 $i$ 子树中，考虑了 $i$ 相连的边被断掉的子树内的所有断边情况，达到第 $i$ 个节点的当前权值是第 $j$ 个点的，左右儿子的断边情况分别是 $0/1$ 的最小代价。$g_{i,j,0/1,0/1}$ 表示 $i$ 子树中，从第 $i$ 个节点的当前权值是第 $j$ 个点的，左右儿子的断边情况分别是 $0/1$ 的状态开始，到整个 $i$ 子树所有边都被断掉的最小代价（只考虑这个过程中被断掉的儿子边子树）。

定义比较抽搐，其实本质就是按照父边断的时间分作两半，求一半前面求一半后面。

这里的转移并不是很难。

对于 $f$，这里只需要考虑断掉哪边的儿子边，儿子边断掉之前两个节点的权值分别是啥。然后被断掉的儿子边子树的代价可以用儿子的 $f,g$ 来计算。

对于 $g$，这里只需要考虑上一个被断掉的儿子边是哪个，儿子边断之前两个节点的权值分别是啥。然后被断掉的儿子边子树的代价可以用儿子的 $f,g$ 来计算，和上面一样。

更细致的。

$f$ 加左儿子的断边就是 $f_{u,v,1,q}=\min\limits_{z,ip,iq}(f_{u,z,0,q}+f_{l_u,v,ip,iq}+g_{l_u,z,ip,iq}+d_v+d_z)$。

$f$ 加右儿子的断边就是 $f_{u,v,p,1}=\min\limits_{z,ip,iq}(f_{u,z,p,0}+f_{r_u,v,ip,iq}+g_{r_u,z,ip,iq}+d_v+d_z)$。

$g$ 加左儿子的断边就是 $g_{u,v,0,q}=\min\limits_{z,ip,iq}(g_{u,z,1,q}+f_{l_u,z,ip,iq}+g_{l_u,v,ip,iq}+d_v+d_z)$。

$g$ 加右儿子的断边就是 $g_{u,v,p,0}=\min\limits_{z,ip,iq}(g_{u,z,p,1}+f_{r_u,z,ip,iq}+g_{r_u,v,ip,iq}+d_v+d_z)$。

注意转移的顺序，$f$ 的 $p,q$ 从小到大，$g$ 的 $p,q$ 从大到小。

不难发现这东西是 $O(n^3)$的，但是带有一个大约是 $2^4\times 4$ 的常数，稍加卡常可以获得 $52$ 分。

然后这个时候因为我的写法和这个转移其实关系不大，长得很拧巴，所以我并没有观察到一些比较重要的东西，所以我不会了。

打开题解发现貌似没人跟我一个做法，/yun。然后神仙们的做法都不太看的懂。被迫回来继续做。

然后突然发现自己会了。加一个很糖的优化。

观察一下上面四个转移式子，长得都差不多，先看 $f$。发现转移其实是 $f_{u,v,1,q}=\min\limits_{ip,iq}(\min\limits_{z}(f_{u,z,0,q}+g_{l_u,z,ip,iq}+d_z)+f_{l_u,v,ip,iq}+d_v)$。

然后因为 $p,q$ 转移只会从小的来，所以当 $p,q$ 不变的时候其实中间那坨 $\min\limits_{z}(f_{u,z,0,q}+g_{l_u,z,ip,iq}+d_z)$ 是不变的。每次先枚举 $u,p,q,ip,iq$ 然后求出这个定值，然后再枚举 $v$ 进行转移即可。

剩下三个式子是一样的。

然后不难发现这坨东西仍然常数巨大，使用一些状态剪枝之类的东西可以有效加速，比如对于 $f$ 来讲，因为用到的状态都是父亲边没被断掉，所以第二维只能是 $i$ 子树里的点，所有转移涉及到 $f$ 的部分如果不符合这个都可以不枚举，预处理一下 $i$ 子树里都有哪些点即可。其次因为循环顺序的问题，把第二维放在第四维会快很多。

在 `loj` 上这样就可以过了，但是在尼姑需要使用 `C++98` 和稍微卡卡评测机波动，否则会 `TLE` 三个点。

有趣的是我 `T` 的仨点和别人 `T` 的仨点貌似不一样（）。

然后可能需要好好排布一下数组的定义顺序啥的反正就是要卡常。

下面这版代码为了美观性把能整合的东西都整合了。所以并不一定能过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MXN=5010;
ll f[MXN][2][2][MXN],g[MXN][2][2][MXN],LMN[2][2],RMN[2][2];
int l[MXN],r[MXN],n,d[MXN],dfn[MXN],tk,siz[MXN];
bool l1[MXN],r1[MXN],l2[MXN],r2[MXN];
vector<int>T[MXN];
inline void init(int u){
    dfn[u]=++tk;
    siz[u]=1;
    if(l[u])init(l[u]),siz[u]+=siz[l[u]];
    if(r[u])init(r[u]),siz[u]+=siz[r[u]];
}
inline bool chk(int u,int v){return dfn[u]<=dfn[v]&&dfn[v]<=dfn[u]+siz[u]-1;}
inline void chkmn(ll &x,ll y){x=min(x,y);}
inline void dfs(int u){
    f[u][l1[u]][l2[u]][u]=0;
    for(int v=1;v<=n;v++)
    g[u][1][1][v]=0;
    if(l[u])dfs(l[u]);
    if(r[u])dfs(r[u]);
    for(int p=l1[u];p<=r1[u];p++)
        for(int q=l2[u];q<=r2[u];q++){
            memset(LMN,0x3f,sizeof(LMN));
            memset(RMN,0x3f,sizeof(RMN));
            int k=T[u].size();
            for(int ip=l1[l[u]];ip<=r1[l[u]];ip++)
                for(int iq=l2[l[u]];iq<=r2[l[u]];iq++)
                    for(int i=0;i<k;i++){int v=T[u][i];chkmn(LMN[ip][iq],f[u][p][q][v]+g[l[u]][ip][iq][v]+d[v]);}
            for(int ip=l1[r[u]];ip<=r1[r[u]];ip++)
                for(int iq=l2[r[u]];iq<=r2[r[u]];iq++)
                    for(int i=0;i<k;i++){int v=T[u][i];chkmn(RMN[ip][iq],f[u][p][q][v]+g[r[u]][ip][iq][v]+d[v]);}
                if(!p&&l[u]){
                    int k=T[l[u]].size();
                    for(int ip=l1[l[u]];ip<=r1[l[u]];ip++)
                        for(int iq=l2[l[u]];iq<=r2[l[u]];iq++)
                            for(int i=0;i<k;i++){
                                int z=T[l[u]][i];
                                chkmn(f[u][1][q][z],LMN[ip][iq]+d[z]+f[l[u]][ip][iq][z]);
                            }
                }
                if(!q&&r[u]){
                    int k=T[r[u]].size();
                    for(int ip=l1[r[u]];ip<=r1[r[u]];ip++)
                        for(int iq=l2[r[u]];iq<=r2[r[u]];iq++)
                            for(int i=0;i<k;i++){
                                int z=T[r[u]][i];
                                chkmn(f[u][p][1][z],RMN[ip][iq]+f[r[u]][ip][iq][z]+d[z]);
                            }
                }
        }
        for(int p=r1[u];p>=l1[u];p--)
            for(int q=r2[u];q>=l2[u];q--){
                memset(LMN,0x3f,sizeof(LMN));
                memset(RMN,0x3f,sizeof(RMN));
                int k=T[l[u]].size();
                for(int ip=l1[l[u]];ip<=r1[l[u]];ip++)
                    for(int iq=l2[l[u]];iq<=r2[l[u]];iq++)
                        for(int i=0;i<k;i++){int v=T[l[u]][i];chkmn(LMN[ip][iq],g[u][p][q][v]+f[l[u]][ip][iq][v]+d[v]);}
                k=T[r[u]].size();
                for(int ip=l1[r[u]];ip<=r1[r[u]];ip++)
                    for(int iq=l2[r[u]];iq<=r2[r[u]];iq++)
                        for(int i=0;i<k;i++){int v=T[r[u]][i];chkmn(RMN[ip][iq],g[u][p][q][v]+f[r[u]][ip][iq][v]+d[v]);}
                
                    if(p&&l[u])
                        for(int ip=l1[l[u]];ip<=r1[l[u]];ip++)
                            for(int iq=l2[l[u]];iq<=r2[l[u]];iq++)
                                for(int z=1;z<=n;z++)
                                chkmn(g[u][0][q][z],LMN[ip][iq]+g[l[u]][ip][iq][z]+d[z]);
                    if(q&&r[u])
                        for(int ip=l1[r[u]];ip<=r1[r[u]];ip++)
                            for(int iq=l2[r[u]];iq<=r2[r[u]];iq++)
                                for(int z=1;z<=n;z++)
                                chkmn(g[u][p][0][z],RMN[ip][iq]+g[r[u]][ip][iq][z]+d[z]);  
        }
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin>>n;
    memset(f,0x3f,sizeof(f));
    memset(g,0x3f,sizeof(g));
    for(int i=1;i<=n;i++)cin>>d[i];
    for(int i=2;i<=n;i++){
        int f;cin>>f;
        if(l[f])r[f]=i;
        else l[f]=i;
    }
    for(int i=1;i<=n;i++)l1[i]=l[i]==0,l2[i]=r[i]==0,r1[i]=r2[i]=1;
    init(1);
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(chk(i,j))T[i].push_back(j);
    dfs(1);
    ll res=1e18;
    for(int i=1;i<=n;i++)
    res=min(res,f[1][1][1][i]);
    cout<<res<<endl;
    cout.flush();  
    return 0;
}
```



这版是过了的，但是很丑。直接提交评测机波动也不一定能过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define short int 
#define double long double
const int MXN=5010;
ll f[MXN][2][2][MXN];
ll g[MXN][2][2][MXN];
int l[MXN],r[MXN];
bool l1[MXN],r1[MXN],l2[MXN],r2[MXN];
int n,d[MXN];
int dfn[MXN],tk,siz[MXN];
vector<int>T[MXN];
inline void init(int u){
    dfn[u]=++tk;
    siz[u]=1;
    if(l[u])init(l[u]),siz[u]+=siz[l[u]];
    if(r[u])init(r[u]),siz[u]+=siz[r[u]];
}
inline bool chk(int u,int v){
    return dfn[u]<=dfn[v]&&dfn[v]<=dfn[u]+siz[u]-1;
}
inline void chkmn(ll &x,ll y){
    x=min(x,y);
}
ll LMN[2][2],RMN[2][2];
inline void dfs(int u){
    f[u][l1[u]][l2[u]][u]=0;
    for(int v=1;v<=n;v++)
    g[u][1][1][v]=0;
    if(l[u])dfs(l[u]);
    if(r[u])dfs(r[u]);
    for(short p=l1[u];p<=r1[u];p++)
        for(short q=l2[u];q<=r2[u];q++){
            memset(LMN,0x3f,sizeof(LMN));
            memset(RMN,0x3f,sizeof(RMN));
            int k=T[u].size();
            for(short ip=l1[l[u]];ip<=r1[l[u]];ip++)
                for(short iq=l2[l[u]];iq<=r2[l[u]];iq++)
                    for(int i=0;i<k;i++){int v=T[u][i];chkmn(LMN[ip][iq],f[u][p][q][v]+g[l[u]][ip][iq][v]+d[v]);}
            for(short ip=l1[r[u]];ip<=r1[r[u]];ip++)
                for(short iq=l2[r[u]];iq<=r2[r[u]];iq++)
                    for(int i=0;i<k;i++){int v=T[u][i];chkmn(RMN[ip][iq],f[u][p][q][v]+g[r[u]][ip][iq][v]+d[v]);}
                if(!p&&l[u]){
                    int k=T[l[u]].size();
                    for(short ip=l1[l[u]];ip<=r1[l[u]];ip++)
                        for(short iq=l2[l[u]];iq<=r2[l[u]];iq++)
                            for(int i=0;i<k;i++){
                                int z=T[l[u]][i];
                                chkmn(f[u][1][q][z],LMN[ip][iq]+d[z]+f[l[u]][ip][iq][z]);
                            }
                }
                if(!q&&r[u]){
                    int k=T[r[u]].size();
                    for(short ip=l1[r[u]];ip<=r1[r[u]];ip++)
                        for(short iq=l2[r[u]];iq<=r2[r[u]];iq++)
                            for(int i=0;i<k;i++){
                                int z=T[r[u]][i];
                                chkmn(f[u][p][1][z],RMN[ip][iq]+f[r[u]][ip][iq][z]+d[z]);
                            }
                }
        }
        for(short p=r1[u];p>=l1[u];p--)
            for(short q=r2[u];q>=l2[u];q--){
                memset(LMN,0x3f,sizeof(LMN));
                memset(RMN,0x3f,sizeof(RMN));
                int k=T[l[u]].size();
                for(short ip=l1[l[u]];ip<=r1[l[u]];ip++)
                    for(short iq=l2[l[u]];iq<=r2[l[u]];iq++)
                        for(int i=0;i<k;i++){int v=T[l[u]][i];chkmn(LMN[ip][iq],g[u][p][q][v]+f[l[u]][ip][iq][v]+d[v]);}
                k=T[r[u]].size();

                for(short ip=l1[r[u]];ip<=r1[r[u]];ip++)
                    for(short iq=l2[r[u]];iq<=r2[r[u]];iq++)
                        for(int i=0;i<k;i++){int v=T[r[u]][i];chkmn(RMN[ip][iq],g[u][p][q][v]+f[r[u]][ip][iq][v]+d[v]);}
                
                    if(p&&l[u])
                        for(short ip=l1[l[u]];ip<=r1[l[u]];ip++)
                            for(short iq=l2[l[u]];iq<=r2[l[u]];iq++)
                                for(short z=1;z<=n;z++)
                                chkmn(g[u][0][q][z],LMN[ip][iq]+g[l[u]][ip][iq][z]+d[z]);
                    if(q&&r[u])
                        for(short ip=l1[r[u]];ip<=r1[r[u]];ip++)
                            for(short iq=l2[r[u]];iq<=r2[r[u]];iq++)
                                for(short z=1;z<=n;z++)
                                chkmn(g[u][p][0][z],RMN[ip][iq]+g[r[u]][ip][iq][z]+d[z]);
                
        }
    
    
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin>>n;
    memset(f,0x3f,sizeof(f));
    memset(g,0x3f,sizeof(g));
    for(int i=1;i<=n;i++)cin>>d[i];
    for(int i=2;i<=n;i++){
        int f;
        cin>>f;
        if(l[f])r[f]=i;
        else l[f]=i;
    }
    for(int i=1;i<=n;i++)
        l1[i]=l[i]==0,l2[i]=r[i]==0,
        r1[i]=r2[i]=1;
    init(1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        if(chk(i,j))T[i].push_back(j);
    dfs(1);
    ll res=1e18;
    for(int i=1;i<=n;i++)
    res=min(res,f[1][1][1][i]);
    cout<<res<<endl;
    cout.flush();  
    return 0;
}
```

---

## 作者：feecle6418 (赞：4)

显然做这题是 waste of time。

首先，有一个 dp 方法是，设里面交换出来的是 $p$，外面交换进去的是 $q$。遗憾的是状态 $n^3$ 个。

这个 dp 考场上都不会，intuition 应该是因为子树内和外界的联系仅仅只与“内外交换”这一次有关。

考虑其实 dp 状态的复杂度来源于 q，改成定义外面交换进去的**那个**对内部贡献有 $q$ 的贡献。

设 $f(x,p,q)$ 表示子树内往外换出去的是 $p$，往里换进来的系数在内部交换中（包括根和父亲的交换）贡献系数是 $q$。注意 $q$ 不超过 $p$ 另一边儿子大小，所以状态数对的。

来转移。

- $x$ 是叶子，$f(x,x,1)=a_x$。

- $x$ 只有左儿子 $y$。

  - 父边 - 儿子边。外面进来的 $u$ 换一次之后换进儿子。$f(y,w,q-1)+a_x\to f(x,x,q)$，暴力转移。
  - 儿子边 - 父边。$f(y,w,q)+qa_x+a_w\to f(x,w,1)$。（这种可以直接暴力转移）

- $x$ 有两个儿子 $y,z$。

  - 父边 - 左儿子 - 右儿子。$f(y,w,p-1)+f(z,v,q)+a_x+a_wq\to f(x,x,p)$。

    预处理 $g3(q)=\min f(z,v,q)$。
    $$
    f(y,w,p-1)+g3(q)+a_x+a_wq\to f(x,x,p)
    $$

    枚举 $w,q$ 预处理 $g4(w)=\min g3(q)+a_wq$。这部分是 $O(ls\times rs)$。
    $$
    f(y,w,p-1)+g4(w)+a_x\to f(x,x,p)
    $$

  - 左儿子 - 父边 - 右儿子。$f(y,w,p)+f(z,v,q-1)+pa_x+a_w\to f(x,w,q)$。

    与 $p$ 有关的只有 $a_xp$。预处理 $g1(w)=\min f(y,w,p)+pa_x$。预处理 $g3(q)=\min f(z,v,q)$。
    $$
    g1(w)+a_w+g3(q-1)\to f(x,w,q)
    $$

  - 左儿子 - 右儿子 - 父边。$f(y,w,p)+f(z,v,q)+a_xp+a_wq+a_v\to f(x,v,1)$。

    与 $p$ 有关的只有 $a_xp$。预处理 $g1(w)=\min f(y,w,p)+a_xp$。
    $$
    g1(w)+f(z,v,q)+a_wq+a_v\to f(x,v,1)
    $$
    预处理 $g2(q)=\min g1(w)+a_wq$。这里复杂度是 $O([q]\times [w])=O(ls\times rs)$。
    $$
    g2(q)+f(z,v,q)+a_v\to f(x,v,1)
    $$

- 求答案。

  - 只有左儿子。$f(y,w,q)+a_1q$。

  - 都有。左儿子 - 右儿子：$f(y,w,q)+g3(p)+a_wp+a_1q$。

    预处理 $g4(w)=\min g3(p)+a_wp$ 即可。
    
https://uoj.ac/submission/576207

---

## 作者：居然有个高手 (赞：0)

超级分讨题吗，哈哈那无敌了。

这种题可以先想一下怎么做多项式复杂度。考虑一个点的度数至多为 $3$，因此我们可以分类讨论一下有关其交换的顺序。我们发现在交换了 $x$ 与 $fa_x$ 之间的边后 $x$ 子树内为独立问题，可以想到记录子树型状态。

那么我们要记录什么样的状态呢？显然我们关心 $x$ 与 $fa_x$ 交换时的值，同时还有 $x$ 的儿子的交换状态。同时我们又发现，若钦定交换时 $d_x = i,d_{fa_x}=j$，则在二者交换前，对于 $x$ 子树内，我们只关心让 $x$ 留下的值为 $i$ 时的最小代价；交换后我们只关心 $x$ 目前带的值为 $j$ 时的最小代价。

因此我们可以记录 $f_{x,i,0/1/2}$ 与 $g_{x,i,0/1/2}$ 表示 $x$ 初始时带的权值为 $a_i$，进行了 $0/1/2$ 状态的交换操作后子树内的最小代价；$g_{x,i,0/1/2}$ 表示 $x$ 进行了 $0/1/2$ 状态的操作后，最终保留权值为 $a_i$ 时子树内的最小代价。（$0$ 表示只换左子树，$1$ 表示只换右子树，$2$ 表示都换）

显然，$f_{x,i,op}$ 状态有效当且仅当 $i=x$ 或 $i$ 在 $x$ 子树外，$g_{x,i,op}$ 状态有效当且仅当 $i$ 在 $x$ 子树内。

开始分讨转移了。对于 $f_{x,i,0}$，我们枚举此时左子树 $ls$ 的交换情况：

未交换：$f_{x,i,0}=a_{ls}+a_i+f_{ls,i,2}$。

交换一边（记作 $op$）：$f_{x,i,0}=a_i+\underset j\min\{g_{ls,j,op} + a_j + f_{ls,i,1-op}\}$。

交换两边：$f_{x,i,0}=a_i + \underset j \min\{g_{ls,j,2}+a_j\}$。

容易发现上式中 $i,j$ 不同时出现，因此预处理 $g_{ls,j,op}+a_j$ 的最小值即可。

对于 $g_{x,i,0}$，我们同样枚举交换情况：

未交换：此时 $i=ls$，$g_{x,i,0}=a_{ls}+a_x+f_{ls,x,2}$。

交换一边：$g_{x,i,0}=a_i + a_x + g_{ls,i,op} + f_{ls,x,1-op}$。

交换两边：$g_{x,i,0} = a_i+a_x+g_{ls,i,2}$。

$f_{x,i,1}$，$g_{x,i,1}$ 均为对偶情况，不多加赘述。

而对于 $f_{x,i,2}$ 我们分讨先交换左子树还是右子树，则对于另一侧子树而言是 $f_{x,i,op}$ 的情况，我们可以仿照上文分讨，并进行适当预处理即可解决。

对于 $g_{x,i,2}$，我们应当考虑其来自哪颗子树，那么自然钦定了左右子树的先后顺序；若其恰好为 $ls$ 或 $rs$ 时则钦定了 $i$ 点的交换顺序，进行上文中大小为 $4$ 的分讨即可（有两种对偶情况，因此文中只呈现 $3$ 种，代码中可以得到完整体现）；否则对两侧子树进行大小为 $12$ 的分类讨论。仿照上文稍加讨论即可得到，具体细节可参考代码。

在一切计算中，我们容易发现虽然会出现临时变量 $j$，但其总不与 $i$ 相关，因此我们可以预处理多种 $j$ 相关的计算式最小值，枚举 $i$ 计算时简单调用即可保证复杂度。

最终答案即为 $f_{1,1,2}$，本题在 $O(n^2)$ 的时空复杂度内得到解决。

贴一份代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5005;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
long long f[N][N][3],g[N][N][3],mn1[N][3],mn2[N][3],mn3[N][3][3],mn4[N][3],a[N];
int n,dfn[N],ed[N],cnt;
vector<int>e[N];
inline void pre(int x){
	dfn[x]=++cnt;
	for(auto y : e[x])pre(y);
	ed[x]=cnt;
}
inline void dfs(int x){
	for(auto y : e[x])dfs(y);
	if(e[x].empty()){
		for(int i = 1;i<=n;i++)f[x][i][0]=f[x][i][1]=f[x][i][2]=0;
		g[x][x][0]=g[x][x][1]=g[x][x][2]=0;
	}
	if(e[x].size()>=1){
		int ls = e[x][0];
		for(int i = 1;i<=n;i++){
			if(dfn[i]<dfn[ls]||dfn[i]>ed[ls]){
				f[x][i][0]=a[i]+a[ls]+f[ls][i][2];
				f[x][i][0]=min(f[x][i][0],a[i] + min(mn1[ls][0] + f[ls][i][1],min(mn1[ls][1] + f[ls][i][0],mn1[ls][2])));
			}
			else if(i==ls)g[x][ls][0]=a[x]+a[ls]+f[ls][x][2];
			else{
				g[x][i][0]=a[x]+a[i]+min(g[ls][i][0] + f[ls][x][1],min(g[ls][i][1] + f[ls][x][0],g[ls][i][2]));
			}
		}
	}
	if(e[x].size()==1){
		int ls = e[x][0];
		for(int i = 1;i<=n;i++){
			if(dfn[i]<dfn[ls]||dfn[i]>ed[ls])f[x][i][2]=f[x][i][0],f[x][i][1]=0;
			else g[x][i][2]=g[x][i][0],g[x][i][1]=1e18;
		}
	}
	if(e[x].size()==2){
		int ls=e[x][0],rs=e[x][1];
		for(int i = 1;i<=n;i++){
			if(dfn[i]<dfn[rs]||dfn[i]>ed[rs]){
				f[x][i][1]=a[i] + a[rs] + f[rs][i][2];
				f[x][i][1]=min(a[i] + min(mn1[rs][0] + f[rs][i][1],min(mn1[rs][1] + f[rs][i][0],mn1[rs][2])),f[x][i][1]);
			}
			else if(i==rs)g[x][rs][1]=a[x]+a[rs]+f[rs][x][2];
			else{
				g[x][i][1]=a[x]+a[i]+min(g[rs][i][0] + f[rs][x][1],min(g[rs][i][1] + f[rs][x][0],g[rs][i][2]));
			}
		}
		for(int j = 1;j<=n;j++){
			if(dfn[ls]<=dfn[j]&&dfn[j]<=ed[ls]){
				for(int k = 0;k<3;k++){
					mn2[ls][k]=min(mn2[ls][k],g[ls][j][k]+a[j]+f[x][j][1]);
					mn4[ls][k]=min(mn4[ls][k],g[ls][j][k]+a[j]*2);
					for(int o = 0;o<3;o++)mn3[ls][k][o]=min(mn3[ls][k][o],g[ls][j][k] + 2*a[j] + f[rs][j][o]);
				}
			}
			else if(dfn[rs]<=dfn[j]&&dfn[j]<=ed[rs]){
				for(int k = 0;k<3;k++){
					mn2[rs][k]=min(mn2[rs][k],g[rs][j][k]+a[j]+f[x][j][0]);
					mn4[rs][k]=min(mn4[rs][k],g[rs][j][k]+a[j]*2);
					for(int o = 0;o<3;o++)mn3[rs][k][o]=min(mn3[rs][k][o],g[rs][j][k] + 2*a[j] + f[ls][j][o]);
				}
			}
		}
		for(int i = 1;i<=n;i++){
			if(dfn[i]<=dfn[x]||dfn[i]>ed[x]){
				f[x][i][2] = a[i] + f[ls][i][2] + a[ls] + f[x][ls][1];
				f[x][i][2]=min(f[x][i][2],min(a[i] + mn2[ls][0] + f[ls][i][1],a[i] + mn2[ls][1] + f[ls][i][0]));
				f[x][i][2]=min(f[x][i][2],a[i] + mn2[ls][2]);
				f[x][i][2] = min(f[x][i][2],a[i] + f[rs][i][2] + a[rs] + f[x][rs][0]);
				f[x][i][2]=min(f[x][i][2],min(a[i] + mn2[rs][0] + f[rs][i][1],a[i] + mn2[rs][1] + f[rs][i][0]));
				f[x][i][2]=min(f[x][i][2],a[i]+mn2[rs][2]);
			}
			else if(dfn[ls]<=dfn[i]&&dfn[i]<=ed[ls]){
				if(i==ls){
					g[x][i][2]=a[x] + f[rs][x][2] + a[rs] + f[ls][rs][2] + a[rs] + a[i];
					g[x][i][2]=min(g[x][i][2],min(a[x] + mn3[rs][0][2] + f[rs][x][1] + a[i],a[x] + mn3[rs][1][2] + f[rs][x][0] + a[i]));
					g[x][i][2]=min(g[x][i][2],mn3[rs][2][2] + a[x] + a[i]);
				}
				else{
					g[x][i][2]=a[x]+a[i]+a[rs]*2+f[rs][x][2]+min(g[ls][i][2],min(g[ls][i][0]+f[ls][rs][1],g[ls][i][1]+f[ls][rs][0]));
					g[x][i][2]=min(g[x][i][2],a[x]+a[i]+g[ls][i][2]+min(min(f[rs][x][1]+mn4[rs][0],f[rs][x][0]+mn4[rs][1]),mn4[rs][2]));
					g[x][i][2]=min(g[x][i][2],a[x]+a[i]+min(min(mn3[rs][2][0]+g[ls][i][1],mn3[rs][2][1]+g[ls][i][0]),mn4[rs][2]+g[ls][i][2]));
					for(int o = 0;o<2;o++)for(int k = 0;k<2;k++)g[x][i][2]=min(g[x][i][2],a[x]+a[i]+f[rs][x][o^1]+mn3[rs][o][k^1]+g[ls][i][k]);
				}
			}
			else{
				if(i==rs){
					g[x][i][2]=a[x] + f[ls][x][2] + a[ls] + f[rs][ls][2] + a[ls] + a[i];
					g[x][i][2]=min(g[x][i][2],min(a[x] + mn3[ls][0][2] + f[ls][x][1] + a[i],a[x] + mn3[ls][1][2] + f[ls][x][0] + a[i]));
					g[x][i][2]=min(g[x][i][2],mn3[ls][2][2] + a[x] + a[i]);
				}
				else{
					g[x][i][2]=a[x]+a[i]+a[ls]*2+f[ls][x][2]+min(g[rs][i][2],min(g[rs][i][0]+f[rs][ls][1],g[rs][i][1]+f[rs][ls][0]));
					g[x][i][2]=min(g[x][i][2],a[x]+a[i]+g[rs][i][2]+min(min(f[ls][x][1]+mn4[ls][0],f[ls][x][0]+mn4[ls][1]),mn4[ls][2]));
					g[x][i][2]=min(g[x][i][2],a[x]+a[i]+min(min(mn3[ls][2][0]+g[rs][i][1],mn3[ls][2][1]+g[rs][i][0]),mn4[ls][2]+g[rs][i][2]));
					for(int o = 0;o<2;o++)for(int k = 0;k<2;k++)g[x][i][2]=min(g[x][i][2],a[x]+a[i]+f[ls][x][o^1]+mn3[ls][o][k^1]+g[rs][i][k]);
				}
			}
		}
	}
	for(int j = 1;j<=n;j++){
		if(dfn[x]<=dfn[j]&&dfn[j]<=ed[x]){
			for(int o = 0;o<3;o++)mn1[x][o]=min(mn1[x][o],g[x][j][o]+a[j]);
		}
	}
}
int main(){
	n=read();
	for(int i = 1;i<=n;i++)a[i]=read();
	for(int i = 2;i<=n;i++)e[read()].push_back(i);
	pre(1);
	memset(f,0x3f,sizeof f);memset(g,0x3f,sizeof g);
	memset(mn1,0x3f,sizeof mn1);memset(mn2,0x3f,sizeof mn2);memset(mn3,0x3f,sizeof mn3);memset(mn4,0x3f,sizeof mn4);
	dfs(1);
	cout<<f[1][1][2];
	return 0;
}
```

---


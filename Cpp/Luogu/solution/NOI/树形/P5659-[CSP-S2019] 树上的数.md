# [CSP-S2019] 树上的数

## 题目描述

给定一个大小为 $n$ 的树，它共有 $n$ 个结点与 $n - 1$ 条边，结点从 $1 \sim n$ 编号。初始时每个结点上都有一个 $1 \sim n$ 的数字，且每个 $1 \sim n$ 的数字都只在**恰好**一个结点上出现。

接下来你需要进行**恰好** $n - 1$ 次删边操作，每次操作你需要选一条**未被删去**的边，此时这条边所连接的两个结点上的数字将会**交换**，然后这条边将被删去。

$n - 1$ 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 $1 \sim n$ 所在的结点编号依次排列，就得到一个结点编号的排列 $P_i$。现在请你求出，在最优操作方案下能得到的**字典序最小**的 $P_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/flbxosct.png)

如上图，蓝圈中的数字 $1 \sim 5$ 一开始分别在结点②、①、③、⑤、④。按照 (1)(4)(3)(2) 的顺序删去所有边，树变为下图。按数字顺序得到的结点编号排列为①③④②⑤，该排列是所有可能的结果中字典序最小的。

![](https://cdn.luogu.com.cn/upload/image_hosting/tu338qm9.png)

## 说明/提示

【数据范围】

| 测试点编号 | $n \leq$ | 特殊性质 |
| :----------- | :----------- | :----------- |
| $1 \sim 2$ | 10 | 无 |
| $3 \sim 4$ | 160 | 树的形态是一条链 |
| $5 \sim 7$ | 2000 | 同上 |
| $8 \sim 9$ | 160 | 存在度数为 $n - 1$ 的结点 |
| $10 \sim 12$ | 2000 | 同上 |
| $13 \sim 16$ | 160 | 无 |
| $17 \sim 20$ | 2000 | 无 |

对于所有测试点：$1 \leq T \leq 10$，保证给出的是一个树。

## 样例 #1

### 输入

```
4
5
2 1 3 5 4
1 3
1 4
2 4
4 5
5
3 4 2 1 5
1 2
2 3
3 4
4 5
5
1 2 5 3 4
1 2
1 3
1 4
1 5
10
1 2 3 4 5 7 8 9 10 6
1 2
1 3
1 4
1 5
5 6
6 7
7 8
8 9
9 10```

### 输出

```
1 3 4 2 5
1 3 5 2 4
2 3 1 4 5
2 3 4 5 6 1 7 8 9 10```

# 题解

## 作者：Mihari (赞：234)

# Day1 T3 树上的数

## 题目

[点这里](https://ac.nowcoder.com/acm/contest/2344/C)

## 考场经历+思考

这道题的输入感觉很恶心。
大概思路就是用 $O(n!\times n)$ 的复杂度，全排列删边顺序，再用 $n$ 来计算。
处理了输入很久，但是还是没有调出来。
然后，花费了差不多 $1h$ 但是还是没有什么结果。
但是却把 $T2$ 的 $100pts$ 全部丢掉了...
代码就不贴了。

## 正解
$PS:$老师目前并未讲正解，但是部分分讲完了。

`方法 1 : 10pts`

这 $10pts$ 是这一次考试 $T3$ 的满分了...

很少有超过 $10pts$ 的人。

思路很好想，用一个 $dfs$ 枚举删边的顺序，再用 $O(N)$ 来检查即可。

代码见下：（个人代码风格严重）

```cpp
/*
	10pts code
*/
#include<cstdio>
#include<utility>
using namespace std;
 
#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
//#define FILEOI
 
typedef pair<int,int> pii;
 
#define cg (c=getchar())
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)if(c=='-')f=1;
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)if(c=='-')f=-1;
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
#undef cg
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);putchar(x%10^48);
}
 
const int MAXN=2000;
 
struct edge{
    int to,nxt;
    edge(){}
    edge(const int T,const int N):to(T),nxt(N){}
}e[(MAXN<<1)+5];
int tail[MAXN+5],ecnt,in[MAXN+5],maxin,tcnt;
pii t[MAXN+5];
inline void add_edge(const int u,const int v){
    ++in[u],++in[v];//更改点的入度
    e[++ecnt]=edge(v,tail[u]);tail[u]=ecnt;
    e[++ecnt]=edge(u,tail[v]);tail[v]=ecnt;
 
    maxin=Max(maxin,Max(in[u],in[v]));//特判菊花图
    t[++tcnt]=mp(u,v);//记录一条边连接的两个点
}
 
int N,a[MAXN+5],ans[MAXN+5];
//a[i] : 点 i 的数字是多少
//ans[i] : 记录答案
 
inline void init(){
    qread(N);
 
    //清空图
    ecnt=0,tcnt=0,maxin=0;
    rep(i,1,N)tail[i]=0,in[i]=0,ans[i]=N-i+1;
 
    //输入
    rep(i,1,N)a[qread()]=i;
    rep(i,1,N-1)add_edge(qread(),qread());
}
 
bool vis[MAXN+5];int mir[MAXN+5];
void dfs(const int);
inline void getDfs(){
    dfs(1);
    rep(i,1,N)writc(ans[i],' ');
    putchar('\n');
}
inline void chk(){
    rep(i,1,N)mir[a[i]]=i;
    rep(i,1,N){
        if(mir[i]<ans[i]){
            rep(j,1,N)ans[j]=mir[j];
            break;
        }
        if(mir[i]>ans[i])break;
    }
    return;
}
void dfs(const int p){
    if(p==N)return chk();
    rep(i,1,N-1)if(!vis[i]){
        swap(a[t[i].ft],a[t[i].sd]);vis[i]=true;
        dfs(p+1);
        swap(a[t[i].ft],a[t[i].sd]);vis[i]=false;
    }
}
 
int T;
 
signed main(){
#ifdef FILEOI
    freopen("file.in","r",stdin);
    freopen("file.out","w",stdout);
#endif
    qread(T);
    while(T--){
        init();
        if(N<=10) getDfs();//暴力
        else puts("gugugu~~~");//减少测试时间
    }
    return 0;
}
```

-----

`方法 2 : 35pts`

在拿到暴力的 $10pts$ 之后，我们应该朝着更高的得分奋斗。

那么接下来，我们看到**链**和**菊花图**。

哪个更好想？

各位即将进入省队的大佬们，你们应该思考过吧。

下一个部分分，**应该拿下菊花图**。

怎么做？ ~~这是一个好问题~~

不妨看一看菊花图有什么特性。

假如说我们有这样一个菊花图：

![graph.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMTEvMjAvN05vSGZYRGxzM1BTV0NjLnBuZw?x-oss-process=image/format,png)

我们考虑随便删一些边。

假如我们删除边 $\{1,4\}$ ，那么 $P_4->Y_7$ 是一定可以保证的，因为除了这一条边 $\{1,4\}$ 以外，没有边和 $4$ 号点有关。

再随便来，把边 $\{1,2\}$ 删掉，那么 $P_2->Y_1$ 也是一定保证了，理由同上。

再试几次，发现在菊花图上，除了花心以外，其他点一定固定了是删边时花心的值，而它本身的数跑到花心，作为下一次固定的值。

仔细想想，是不是有点像一个**环**，或者说是一条**单链**？

为什么这么说？

我们这样看，删 $\{1,4\}$ ，等于加边 $\{Y_7->P_4\}$ ，此时 $P_1->Y_1$ 。

再删边 $\{1,2\}$ ，等于加边 ${Y_1->P_2}$ ，此时 $P_1->Y_3$ .

再枚举几次，发现每个数字 $Y_i$ 只会最多向外连出一条边。

这相当于是一条单链，但是最后连 $Y_n$ 时，整个图一定会连成一个大环。

但是在连边的时候，我们要注意提前成环的情况——用并查集解决这个问题。

代码见下：

```cpp
#include<cstdio>
#include<utility>
using namespace std;
 
#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
//#define FILEOI
 
typedef pair<int,int> pii;
 
#define cg (c=getchar())
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)if(c=='-')f=1;
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)if(c=='-')f=-1;
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
#undef cg
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);putchar(x%10^48);
}
 
const int MAXN=2000;
 
struct edge{
    int to,nxt;
    edge(){}
    edge(const int T,const int N):to(T),nxt(N){}
}e[(MAXN<<1)+5];
int tail[MAXN+5],ecnt,in[MAXN+5],maxin,tcnt;
pii t[MAXN+5];
inline void add_edge(const int u,const int v){
    ++in[u],++in[v];//更改点的入度
    e[++ecnt]=edge(v,tail[u]);tail[u]=ecnt;
    e[++ecnt]=edge(u,tail[v]);tail[v]=ecnt;
 
    maxin=Max(maxin,Max(in[u],in[v]));//特判菊花图
    t[++tcnt]=mp(u,v);//记录一条边连接的两个点
}
 
int N,a[MAXN+5],ans[MAXN+5];
//a[i] : 点 i 的数字是多少
//ans[i] : 记录答案
 
inline void init(){
    qread(N);
 
    //清空图
    ecnt=0,tcnt=0,maxin=0;
    rep(i,1,N)tail[i]=0,in[i]=0,ans[i]=N-i+1;
 
    //输入
    rep(i,1,N)a[qread()]=i;
    rep(i,1,N-1)add_edge(qread(),qread());
    /*
    rep(i,1,N)writc(a[i],' ');
    putchar('\n');
    */
}
 
int pre[MAXN+5];
inline void buildSet(){rep(i,1,N)pre[i]=i;}
int findSet(const int u){return u==pre[u]?u:pre[u]=findSet(pre[u]);}
inline void unionSet(const int u,const int v){return (void)(pre[findSet(u)]=findSet(v));}
 
bool vis[MAXN+5];
int tmp[MAXN+5],pt[MAXN+5];
 
inline void work(){//处理菊花图
    buildSet();
    rep(i,1,N)tmp[a[i]]=i,vis[i]=0;
    rep(i,1,N-1){
        rep(j,1,N)if(!vis[j]&&findSet(tmp[i])!=findSet(j)){
            vis[j]=true,pt[tmp[i]]=j;
            unionSet(tmp[i],j);
            break;
        }
    }
    rep(i,1,N-1)writc(pt[tmp[i]],' ');
    rep(i,1,N)if(!vis[i]){
        writc(i,'\n');
        break;
    }
}
 
int mir[MAXN+5];
void dfs(const int);
inline void getDfs(){
    rep(i,1,N)vis[i]=0;
    dfs(1);
    rep(i,1,N-1)writc(ans[i],' ');
    writc(ans[N],'\n');
}
inline void chk(){
    rep(i,1,N)mir[a[i]]=i;
    rep(i,1,N){
        if(mir[i]<ans[i]){
            rep(j,1,N)ans[j]=mir[j];
            break;
        }
        if(mir[i]>ans[i])break;
    }
    return;
}
void dfs(const int p){
    if(p==N)return chk();
    rep(i,1,N-1)if(!vis[i]){
        swap(a[t[i].ft],a[t[i].sd]);vis[i]=true;
        dfs(p+1);
        swap(a[t[i].ft],a[t[i].sd]);vis[i]=false;
    }
}
 
int T;
 
signed main(){
#ifdef FILEOI
    freopen("file.in","r",stdin);
    freopen("file.out","w",stdout);
#endif
    qread(T);
    while(T--){
        init();
        if(N<=10)getDfs();
        else if(maxin==N-1)work();
        else puts("gugugu~~~");
    }
    return 0;
}
```

-----

`方法 3 : 60pts`

在得到 $45pts$ 之后，你一定很开心，但是如果这是考试，那是一定不够的。

但是如果这是考试，那是一定不够的。

我们继续朝更高的得分奋斗，那么我们现在开始分析**链**。

首先，链有什么特性？似乎这是很简单的一个问题。

它的特性显然：

- 它是一条类似于线的东西；
- 除了两个端点之外，其他的点**度**都为 $2$（分出度和入度）；
- ...（作者太弱，只想得出这几种情况）

那么，针对这些情况进行分析：

针对**特性1**，我们为了方便处理，可以把这个单链拍到树上，代码如下：

```cpp
int lt[MAXN+5],lcnt;//链表和下标
inline void getlist(const int u,const int pre){
	lt[pt[u]=++lcnt]=u;//pt[i] : 点 i 在链表数组中的位置
	for(int i=tail[u],v;i;i=e[i].nxt)if((v=e[i].to)!=pre)
		getlist(v,u);
}
```

这个地方很简单。

那么**特性2**？

所谓入度、出度为 $2$ 即除端点以外，每个点都有两条边与其相连，而这两条边可以保证的是删除时间一定不同。

那么，我们可以对于这两条边进行标记，分几种情况：

- 左边的边先删，右边的边后删（左先右后）
- 左后右先
- 没有过标记

针对这个，我们用一个数组来存

```cpp
short int mark[MAXN+5];//标记 : 0-无标记 ; 1-左先右后 ; 2-左后右先
```

此处选用 `short int` 为的是节省内存 ~~其实省不了多少~~

为什么这样标记呢？我们来分析一种情况。

假设数 $x$ 要到点 $i$ 去，如下图：

![graph _1_.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMTEvMjAvUUhJQldZZTlBSzRSdVBvLnBuZw?x-oss-process=image/format,png)

边上的数字是边的编号。

重复一遍问题：**数字** $x$ 要去 $i$ **点**

那么首先，$edge_1$ 一定是在 $edge_2$ 之后删，不然数字 $x$ 就跑到其他地方去了。

根据 $mark[]$ 数组的定义，可得 $mark[x]=2$ 

同理，$edge_2、edge_3、edge_4、edge_5$ 一定是依次删除的，那么可得 $mark[p1]=mark[p2]=mark[p3]=1$

而点 $i$ ，要保证的是 $edge_6$ 在 $edge_5$ 之前删除，为什么？

因为当 $x$ 到 $i$ 点之后，如果 $edge_6$ 还存在，那么 $x$ 就会跑到 $p_4$ 那里去。

由此推出，$mark[i]=2$

这是 $x$ 往右走的情况，$x$ 往左的情况可自行推导 ~~要看代码我也不拦你，推荐自己推一下，很简单~~

而最后，我们判定一个方法是否可行，只需要判断它和前面的边的标记是否冲突即可。

```cpp
#include<cstdio>
#include<utility>
using namespace std;

#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
// #define FILEOI

typedef pair<int,int> pii;

#define cg (c=getchar())
template<class T>inline void qread(T& x){
	char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	if(f)x=-x;
}
inline int qread(){
	int x=0;char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=-1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	return f?-x:x;
}
#undef cg
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline void getInv(int inv[],const int lim,const int MOD){
	inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
	if(x<0)return (void)(putchar('-'),fwrit(-x));
	if(x>9)fwrit(x/10);putchar(x%10^48);
}

const int MAXN=2000;

struct edge{
	int to,nxt;
	edge(){}
	edge(const int T,const int N):to(T),nxt(N){}
}e[(MAXN<<1)+5];
int tail[MAXN+5],ecnt,in[MAXN+5],maxin,tcnt;
pii t[MAXN+5];
inline void add_edge(const int u,const int v){
	++in[u],++in[v];//更改点的入度
	e[++ecnt]=edge(v,tail[u]);tail[u]=ecnt;
	e[++ecnt]=edge(u,tail[v]);tail[v]=ecnt;

	maxin=Max(maxin,Max(in[u],in[v]));//特判菊花图
	t[++tcnt]=mp(u,v);//记录一条边连接的两个点
}

int N,a[MAXN+5],ans[MAXN+5];
//a[i] : 点 i 的数字是多少
//ans[i] : 记录答案

inline void init(){
	qread(N);

	//清空图
	ecnt=0,tcnt=0,maxin=0;
	rep(i,1,N)tail[i]=0,in[i]=0,ans[i]=N-i+1;

	//输入
	rep(i,1,N)a[qread()]=i;
	rep(i,1,N-1)add_edge(qread(),qread());
	/*
	rep(i,1,N)writc(a[i],' ');
	putchar('\n');
	*/
}

int pre[MAXN+5];
inline void buildSet(){rep(i,1,N)pre[i]=i;}
int findSet(const int u){return u==pre[u]?u:pre[u]=findSet(pre[u]);}
inline void unionSet(const int u,const int v){return (void)(pre[findSet(u)]=findSet(v));}

bool vis[MAXN+5];
int tmp[MAXN+5],pt[MAXN+5];

inline void work(){//处理菊花图
	buildSet();
	rep(i,1,N)tmp[a[i]]=i,vis[i]=0;
	rep(i,1,N-1){
		rep(j,1,N)if(!vis[j]&&findSet(tmp[i])!=findSet(j)){
			vis[j]=true,pt[tmp[i]]=j;
			unionSet(tmp[i],j);
			break;
		}
	}
	rep(i,1,N-1)writc(pt[tmp[i]],' ');
	rep(i,1,N)if(!vis[i]){
		writc(i,'\n');
		break;
	}
}

int mir[MAXN+5];
void dfs(const int);
inline void getDfs(){
	rep(i,1,N)vis[i]=0;
	dfs(1);
	rep(i,1,N-1)writc(ans[i],' ');
	writc(ans[N],'\n');
}
inline void chk(){
	rep(i,1,N)mir[a[i]]=i;
	rep(i,1,N){
		if(mir[i]<ans[i]){
			rep(j,1,N)ans[j]=mir[j];
			break;
		}
		if(mir[i]>ans[i])break;
	}
	return;
}
void dfs(const int p){
	if(p==N)return chk();
	rep(i,1,N-1)if(!vis[i]){
		swap(a[t[i].ft],a[t[i].sd]);vis[i]=true;
		dfs(p+1);
		swap(a[t[i].ft],a[t[i].sd]);vis[i]=false;
	}
}

int lt[MAXN+5],lcnt;
short int mark[MAXN+5];//标记 : 0-无标记 ; 1-左先右后 ; 2-左后右先
inline void getlist(const int u,const int pre){
	lt[pt[u]=++lcnt]=u;
	for(int i=tail[u],v;i;i=e[i].nxt)if((v=e[i].to)!=pre)
		getlist(v,u);
}
inline bool chkl(const int p1,const int p2){
	if(mark[pt[p1]]==1)return false;

	rep(i,pt[p1]+1,pt[p2]-1)if(mark[i]==2)return false;

	if(mark[pt[p2]]==1)return false;

	return true;
}
inline void getMarkl(const int p1,const int p2){//当 pt[p1]<=pt[p2] 时
	if(pt[p1]!=1&&pt[p1]!=N)mark[pt[p1]]=2;

	rep(i,pt[p1]+1,pt[p2]-1)mark[i]=1;

	if(pt[p2]!=1&&pt[p2]!=N)mark[pt[p2]]=2;
}
inline bool chkr(const int p1,const int p2){//当 pt[p1]>pt[p2] 时
	if(mark[pt[p1]]==2)return false;

	fep(i,pt[p1]-1,pt[p2]+1)if(mark[i]==1)return false;

	if(mark[pt[p2]]==2)return false;

	return true;
}
inline void getMarkr(const int p1,const int p2){
	if(pt[p1]!=1&&pt[p1]!=N)mark[pt[p1]]=1;

	fep(i,pt[p1]-1,pt[p2]+1)mark[i]=2;

	if(pt[p2]!=1&&pt[p2]!=N)mark[pt[p2]]=1;
}
inline void workList(){//解决单链
	lcnt=0;
	rep(i,1,N)if(in[i]==1){//压到数组上面
		getlist(i,0);
		break;
	}
	/*
	printf("this is the list:");
	rep(i,1,N)writc(lt[i],' ');
	putchar('\n');
	printf("this is pt arr:");
	rep(i,1,N)writc(pt[i],' ');
	putchar('\n');
	*/

	rep(i,1,N)vis[i]=false,mir[a[i]]=i,mark[i]=0;

	rep(i,1,N)rep(j,1,N)if(!vis[j]&&pt[j]!=pt[mir[i]]){
		//目标位置不能和本来的位置重合并且目标位置还没有被其他优先级更高的数占有
		// printf("Now the number is %d, the goal position is %d\n",i,j);
		int p1=mir[i],p2=j;bool flg=false;
		if(pt[p1]<=pt[p2]){//如果这个数是往左边走
			if(chkl(p1,p2))
				getMarkl(p1,p2),flg=true;
		}
		else{//反之
			if(chkr(p1,p2))
				getMarkr(p1,p2),flg=true;
		}
		if(flg){//记录答案
			ans[i]=j,vis[j]=true;
			break;
		}
	}
	rep(i,1,N-1)writc(ans[i],' ');//输出答案
	writc(ans[N],'\n');
}

int T;

signed main(){
#ifdef FILEOI
	freopen("rdata.out","r",stdin);
	freopen("file.out","w",stdout);
#endif
	qread(T);
	while(T--){
		init();
		if(N<=10)getDfs();
		else if(maxin==N-1)work();
		else if(maxin==2)workList();
		else puts("gugugu~~~");
	}
	return 0;
}
```

-----

`方法 4 : 100pts`

~~目前尚待讨论...~~

$lj$ 大佬憋了两天，终于舍得把正解讲出来了，接下来是正解：

首先，我们的单链是怎么做的？

维护一个点的两个边删除的先后顺序。

并且，我们可以得到这样一个结论： ~~一个比较容易想到的结论~~

> 只有共用同一个顶点的边才有删除的先后关系

而判定一个方法是否可行，只需看这个方案是否和前面的方案冲突即可。

那么，我们能否将这样的维护扩展到多条边的情况？其实是可以的 ~~不然我为什么要问这个问题~~

只有两条边，我们只需维护 **左前右后** 或者 **左后右前** 的情况，但是对于多条边这样显然是不行的。

那么，对于多个删边的先后关系，我们将其排成一排，比如我们删边顺序是：$1,3,5,4...$

将它们排成一排之后，发现它有点像链表。

考虑用链表维护删除边的先后关系。

但是这里有个问题：如果一个点删除边的顺序不一定是连续的怎么办？

对于这种情况，我们只需要把它们看成有许多个链表，但是它们没有接在一起即可。

那么，我们怎么寻找一条合法路径？

我们把这个方法的寻径算法分成几个部分：

- 对于起飞点（即数字一开始所在的点）
- 对于中转点
- 对于结束点

`部分 1:对于起飞点`

对于一个起飞点 $u$，我们考虑寻找一条**起飞边**，**并且这条起飞边是一定存在**。

那么，这条起飞边需要满足什么条件？

首先，这条起飞边前面不能有什么其他的东西。

即对于点 $u$ 的删边顺序所连成的**链表集**中，这条边必须是其中某一条链的起点。

而且，我们分析，如果这是一条起飞边，那么它一定是所有 $u$ 的边中最先删除的那条边（如果不知道为什么，参考本题链的处理方法）

**还有一种特殊情况，留到后面结束点之后分析。**

`部分 2:对于中转点`

如果这是一个中转点，考虑枚举一条边 $e'$ 在 $e$ (我们之前删除的那条边)

而这个中转点必须满足什么条件呢?

毕竟 $e'$ 是接在 $e$ 之后的，那么一定要保证 $e'$ 之前没有其他的边。

而且，点 $e'$ 与点 $e$ 还没有连在一起，即它们分别所在不同的链上（因为我们本来就是要将他们连在一起）。

并且，$e'$ 是在 $e$ 之后，但是如果 $e'$ 是一条起飞边，即这条边必须是最先删除的，那么 $e'$ 就是不符合的。

**还有一种特殊情况，留到后面结束点之后分析。**

`部分 3:对于降落点`

如果点 $u$ 是一个降落点，那么我们的边 $e$ 必须是最后删除的（如果不知道为什么，参考本题链的处理方式）

即，对于一个点 $u$ ，我们目前还并未指定 $u$ 的某一条边必须是结束边。

但是还有一种情况，这种情况与前面的两个部分都有关。

如果这条结束边 $e$ 是与前面的起飞边在同一条链上，即它们先后顺序已确定，那么我们必须要保证这个删边顺序组成的链中，长度刚好为 $u$ 的边数。

为什么？因为我们最后，必须保证每条边都被删去。

**而上面这种情况，即是我们将最开头所删除的边，与最末尾所删除的边连接在一起而形成一个完整的、已无法再次修改的长链，而如果有剩余的边没有被删去，它们就没有机会再插入到这个链之中，也就是说找不到任何一个机会去删除这条边，与题意不符。**

生动地说，我们不能让这个完整的链出现**提前自闭**的情况。

知道这个之后，我们再反过来补充 `部分 1` 与 `部分 2` 。

`部分 1 补充`

因为我们已经指定起飞边 $e$ ，而我们要将边 $e'$ 接到 $e$ 之后。

但是如果 $e'$ 已经与降落边，即末删边相连，那么我们也要防止**提前自闭**的情况。

所以我们也要特判一下，链长度必须与 $u$ 的边数一样。

`部分 2 补充`

如果我们的边 $e$ 已经连接到起始边，而 $e'$ 已经连接到末删边。

那如果我们要将 $e$ 与 $e'$ 连起来删，也就是将两个完整链连接起来，这也是防止**提前自闭**的情况。

总的时间复杂度 $O(N^2)$ ，常数我就不知道了，但是能过...

代码如下（自带注释）

```cpp
#include<cstdio>
#include<vector>
using namespace std;

#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
#define ull unsigned long long
#define pii pair<int,int>
// #define FILEOI

#define cg (c=getchar())
template<class T>inline void qread(T& x){
	char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	if(f)x=-x;
}
inline int qread(){
	int x=0;char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=-1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	return f?-x:x;
}
#undef cg
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline void getInv(int inv[],const int lim,const int MOD){
	inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
	if(x<0)return (void)(putchar('-'),fwrit(-x));
	if(x>9)fwrit(x/10);putchar(x%10^48);
}

const int MAXN=2000;

struct edge{
	int to,nxt;
	edge(){}
	edge(const int T,const int N):to(T),nxt(N){}
}e[(MAXN<<1)+5];
int tail[MAXN+5],ecnt,siz[MAXN+5];
inline void add_edge(const int u,const int v){
	++siz[u],++siz[v];
	e[++ecnt]=edge(v,tail[u]);tail[u]=ecnt;
	e[++ecnt]=edge(u,tail[v]);tail[v]=ecnt;
}

int N,minp;
int pt[MAXN+5];
int pre[MAXN+5][MAXN+5],nxt[MAXN+5][MAXN+5];
//这条边的 前驱,后继
int rt[MAXN+5][MAXN+5][2];
//点 u 的某一条边的 前根节点、后根节点
int len[MAXN+5][MAXN+5];
//这条边 所在链 的链表长度

inline void init(){
	qread(N);
	ecnt=0;
	rep(i,1,N)qread(pt[i]),tail[i]=siz[i]=0;
	rep(i,1,N+1)rep(j,1,N+1)len[i][j]=pre[i][j]=nxt[i][j]=rt[i][j][0]=rt[i][j][1]=0;

	int u,v;
	rep(i,1,N-1){
		qread(u,v);
		add_edge(u,v);
		pre[u][v]=pre[v][u]=nxt[u][v]=nxt[v][u]=0;
		rt[u][v][0]=rt[u][v][1]=v;
		rt[v][u][0]=rt[v][u][1]=u;
		len[u][v]=len[v][u]=1;
	}
}

void findPath(const int u,const int p){//当前节点、前一个节点
	int a=rt[u][p][0],b=rt[u][p][1],ta,tb;
	//a:来的边的前根 ; b:来的边的后根
	if(p==N+1){//这是起点
		for(int i=tail[u],v;i;i=e[i].nxt){//从哪条边起飞
			v=e[i].to;
			ta=rt[u][v][0],tb=rt[u][v][1];
			if(ta!=v || (pre[u][p]==tb && len[u][ta]<siz[u]))
			//条件一:如果这条边已经有一个起点且不是自己
			//条件二:如果后面的那条边已经连接尾端, 且这条链的长度无法满足将所有边连起来
				continue;//那么就不能把 边{u,p} 与 边{u,v} 连在一起
			findPath(v,u);//否则可行
		}
	}
	else{
		if(p==b){//如果 边{u,p} 的后面还暂时没有指定必须删哪一条边, 那么就可以考虑枚举一条边接在后面
			if(pre[u][N+1]==0 && (nxt[u][N+1]!=a || len[u][a]==siz[u]))//则可以考虑在点 u 进行降落, 满足以下条件:
			//如果这个点的末删边还没有被指定(必须满足)
			//并且:
			//1.如果这条链接上开头，那么如果必须满足所有的边都在这条链上
			//2.如果没有接上开头，那么长度随意
				minp=Min(minp,u);//如果满足, 则 u 可以作为一个降落点

			for(int i=tail[u],v;i;i=e[i].nxt){//假定 u 为一个中转点, 则再枚举一条边作为 边{u,p} 的出边，与其尾相连
				v=e[i].to;
				ta=rt[u][v][0],tb=rt[u][v][1];
				if(a==ta || ta!=v || nxt[u][N+1]==v)//第一种大情况
				//如果这两条边已经在同一条链上
				//或者这个边不是一个起始边, 即枚举边的前面还有东西
				//或者枚举边是一条起飞边, 即保证它是所有对于 u 的边必须最先删除的边
					continue;//那么 当前 边{u,p} 都不能接在这条枚举边之上
				
				if(nxt[u][N+1]==a && pre[u][N+1]==tb && len[u][a]+len[u][ta]<siz[u])
				//如果这两条边分别属于这个点 最先删除、最后删除 的链表上的 尾、头
				//那么它们组合起来必须等于所有边的数量之和
				//否则, 这就是 提前自闭 的情况
					continue;

				findPath(v,u);//如果以上都不满足, 那么这条边是合法的
			}
		}
		else findPath(nxt[u][p],u);//否则我们只能按照之前的规定访问这条边
	}
}

inline void merge(const int u,const int a,const int b){
//函数条件:以 a 所在的链表为前链表
//并且满足 a 是前链表尾, b 是后链表头
	int ta=rt[u][a][0],tb=rt[u][b][1];
	nxt[u][a]=b;
	pre[u][b]=a;
	for(int i=ta;i && i!=N+1;i=nxt[u][i]){
	//访问链表的基本操作
		//更新每个点的前根、后根
		rt[u][i][0]=ta;
		rt[u][i][1]=tb;
	}
	len[u][ta]+=len[u][b];
}

bool getMark(const int u,const int p){//还原路径, 并且给路径打上标记
//如果这条路径找到终点, 返回 1, 否则返回 0
	if(u==minp){//如果找到了终点
		pre[u][N+1]=p;//把这条边设为最后删除的边
		nxt[u][p]=N+1;//并且把这条边的下一条边标记为 N+1, 表示这条边是最后删除的
		return 1;
	}
	int a=rt[u][p][0],b=rt[u][p][1],ta,tb;
	if(p==N+1){//这是起飞点
		for(int i=tail[u],v;i;i=e[i].nxt){
			v=e[i].to;
			ta=rt[u][v][0],tb=rt[u][v][1];
			if(ta!=v || (pre[u][N+1]==tb && len[u][ta]<siz[u]))
			//如果枚举边前面有东西, 那么这肯定不能接在起始边的后面, 因为它前面已经有个什么 逼 了
			//或者是枚举边连接到末尾, 但是这条单链长度不够将所有的边包含到链里面
				continue;//那么这条边肯定不在路径上面, 可直接跳过
			if(getMark(v,u)){//如果这就是正确的路径
				nxt[u][N+1]=v;//因为 u 点是起飞点, 所以把这条边记录为 u 的起飞边
				pre[u][v]=N+1;//同时标记这条边的前驱, 与前面的 if 相互呼应(这不是语文...)
				return 1;
			}
		}
	}
	else{//如果点 u 是中转点, 那么考虑枚举中转边
		if(p==b){//如果这条边在链上后面没有其他边的时候
			for(int i=tail[u],v;i;i=e[i].nxt){
				v=e[i].to;
				ta=rt[u][v][0],tb=rt[u][v][1];
				if(a==ta || ta!=v || nxt[u][N+1]==v)//参考 findPath() 中相同位置的注释
					continue;
				if(nxt[u][N+1]==a && pre[u][N+1]==tb && len[u][a]+len[u][ta]<siz[u])//同样参考 findPath() 中同样位置
					continue;
				if(getMark(v,u)){
					merge(u,p,v);//把链表合并为一个
					return 1;
				}
			}
		}
		else getMark(nxt[u][p],u);
	}
	return 0;
}

signed main(){
#ifdef FILEOI
	freopen("rdata.out","r",stdin);
	freopen("file.out","w",stdout);
#endif
	int T=qread();
	while(T--){
		init();
		if(N==1){
			writc(1,'\n');
			continue;
		}
		rep(i,1,N){
			minp=N+1;
			findPath(pt[i],N+1);
			// printf("%d\n",minp);
			getMark(pt[i],N+1);
			writc(minp,' ');
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：wucstdio (赞：151)

考场想出来 $n^2$ 没调出来，自闭了。

首先考虑一条链的情况。

对于一个点 $x$ ，我们观察一下它上面的数字变动情况。可以发现无论我们先删左边还是先删右边，原来它上面的数字一定会被搬运到了其中一个方向，同时另一个方向一定又过来了一个数，此外还有一个数字反向经过了 $x$ 。

也就是下面这种情况（这里是先删除右边那条边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ase7fq89.png)

接下来我们考虑节点度数不是 $2$ 的情况。

在上面的情况中，经过 $x$ 的 $c$ 实际上确定了应该先删除右边再删除左边。

同理如果 $x$ 的度数不是 $2$ ，那么经过 $x$ 的 $c$ 实际上确定了一个偏序关系，也就是哪条边需要在哪条边之后被删除。

当我们把所有的情况画出来的时候，结果就变得有意思了起来：

![](https://cdn.luogu.com.cn/upload/image_hosting/3y1m9ryj.png)

当我们按照 $c-1$,$c-2$,$c-3$,$c-4$,$c-5$ 的顺序依次删除的时候，原先位于 $x$ 上的数被搬运到了 $1$ 号点的方向（注意只是方向，不一定被搬运到 $1$ 号点），同时还有 $4$ 个数 $c_1,c_2,c_3,c_4$ 经过了 $x$ ，最后从 $5$ 号点的方向又过来了一个数。

概括一下就是对于一个点 $x$ ，把所有经过它的数字连到一起，刚好把它的所有出边连成一条偏序链。

有了这个，我们就可以贪心了。假设我们需要将 $u$ 上面的数搬运到 $v$ 上面，我们需要判断 $u$ 到 $v$ 这条路径是否合法。

对于 $u$ ：

- 如果已经有一个数从它搬运出去了，那就不合法。
- 如果这条出边已经被别的数字沿相同方向走过了一次，那就不合法。
- 如果加上这个数后，当前确定的搬运情况形成了一条**有始有终的**偏序链（也就是上图中，我们已经形成了 $1-2-3-4-5$ 这条链），并且 $u$ 还有别的出边不在这条链上，那就不合法。（因为我们需要把所有出边串到一起）
- 否则，一定合法。

对于 $v$ ，可以对称来看：

- 如果已经有一个数搬运到它，那就不合法。
- 如果这条出边已经被别的数字沿相同方向走过了一次，那就不合法。
- 如果加上这个数后，当前确定的搬运情况形成了一条**有始有终的**偏序链，并且 $v$ 还有别的出边不在这条链上，那就不合法。
- 否则，一定合法。

对于 $u$ 到 $v$ 的路径上的其它点（记为 $x$ ）：

- 如果入边或者出边其中一条已经被别的数字沿相同方向走了一次，那就不合法。
- 如果加上这个数字后，所有**经过** $x$ 的数字连成了一个环，那就不合法。
- 如果加上这个数后，当前确定的搬运情况形成了一条**有始有终的**偏序链，并且 $x$ 还有别的出边不在这条链上，那就不合法。
- 否则，一定合法。

为了判定是否形成了一条偏序链，我们可以对每一个点的所有出边开一个双向链表，记录每一个点当前所在偏序链的开头和结尾，这样所有的操作都可以 $O(1)$ 实现。

直接贪心是 $n^3$ 的，但是我们可以直接以 $u$ 为根对整棵树进行一次 dfs ，然后求出所有合法的 $v$ 中节点编号最小的作为这一轮贪心的答案。

时间复杂度 $O(n^2)$ 。

这道题我大概拿出来了 $2$ 个多小时的时间，中间思路错了几次，最后才形成上面那个成熟的思路。由于时间不够只调过了小样例，大样例死循环了，估计再多给我一段时间的话 Day1 就能 AK 了？（其实 Day2 也是最后十几分钟猜出了 T2 结论没写， ~~所以给我 5 个小时大概能口胡 AK CSP？~~ 然而这和我今年撑死过不了500又有什么关系呢）

考后调好的代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct Edge
{
	int to;
	int nxt;
}e[10005];
int t,n,m,edgenum,head[2005],p[2005],d[2005],d1[2005],d2[2005],from[2005],too[2005],pa[2005];
int edge[2005][2005],en[2005][2005],st[2005][2005];
bool flag[2005];
/*
数组含义如下：
p[i]表示i这个数字在哪个节点上
d[i]表示第i个点还有多少条出边没有被走过
d1[i]表示第i个点还有多少条出边只被一个数字走进来了一次
d2[i]表示第i个点还有多少条出边只被一个数字走出去了一次
from[i]表示搬运到第i个点的数字是从哪个方向来的
too[i]表示第i个点上的数字被搬运到了哪个方向
edge[i][j]表示i到j的这一条边是没有被数字经过(-1)，只有一个数字从i到j经过了一次(i)，只有一个数字从j到i经过了一次(j)，还是被两个数字来回经过了(0)
st[i][j]表示对i号点来说，(i,j)这条边当前所在的偏序链的开头指向哪个节点
en[i][j]表示对i号点来说，(i,j)这条边当前所在的偏序链的结尾指向哪个节点
flag[i]表示i号点是否可行
*/
void add(int u,int v)
{
	e[++edgenum].to=v;
	e[edgenum].nxt=head[u];
	head[u]=edgenum;
}
void dfs(int node,int root)
{
	for(int hd=head[node];hd;hd=e[hd].nxt)
	{
		int to=e[hd].to;
		if(to==pa[node])continue;
		pa[to]=node;
		flag[to]=1;
		if(node!=root)//如果node不是根，我们需要判断这条边经过node是否合法
		{
			if(edge[pa[node]][node]==pa[node]||edge[node][to]==node)flag[to]=0;
			if(edge[pa[node]][node]==0||edge[node][to]==0)flag[to]=0;//这两行判断的是这条边是否已经被别的数字沿相同方向走了一次
			if(en[node][to]==from[node]&&st[node][pa[node]]==too[node]&&d2[node]+d1[node]+d[node]*2-2>0)flag[to]=0;//如果已经形成了偏序链，是否还有别的出边不在这条链上
			if(en[node][to]==pa[node])flag[to]=0;//经过node的数字是否形成了一个环
		}
		else//否则，我们需要判断这条边能否从node出发到to
		{
			if(edge[node][to]==node)flag[to]=0;
			if(edge[node][to]==0)flag[to]=0;//这条边是否已经被别的数字沿相同方向走了一次
			if(from[node])
			{
				if(en[node][to]==from[node]&&d[node]+d1[node]+d2[node]-1!=0)flag[to]=0;//如果已经形成了偏序链，是否还有别的出边不在这条链上
			}
		}
		flag[to]&=flag[node];//如果node不可行，那么to也一定不可行
		dfs(to,root);
	}
    //下面判断的是这条链能否到node终止
	if(node==root)flag[node]=0;//自己到自己肯定不合法
	else
	{
		if(from[node])flag[node]=0;//已经有了入边肯定不合法
		if(too[node])
		{
			if(en[node][too[node]]==pa[node]&&d[node]+d1[node]+d2[node]-1!=0)flag[node]=0;//如果已经形成了偏序链，是否还有别的出边不在这条链上
		}
	}
}
int main()
{
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		edgenum=0;
		for(int i=1;i<=n;i++)head[i]=from[i]=too[i]=d[i]=d1[i]=d2[i]=0;
		for(int i=1;i<=n;i++)
			scanf("%d",&p[i]);
		for(int i=1;i<n;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			add(u,v);
			add(v,u);
			d[u]++,d[v]++;
			edge[u][v]=edge[v][u]=-1;
			en[u][v]=st[u][v]=v;
			en[v][u]=st[v][u]=u;
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)pa[j]=0;
			flag[p[i]]=1;
			dfs(p[i],p[i]);
			int res=0;
			for(int j=1;j<=n;j++)
			{
				if(flag[j])
				{
					res=j;
					break;
				}
			}
			printf("%d ",res);
			from[res]=pa[res];
			while(pa[res]!=p[i])//从res开始一路更新它的所有祖先
			{
				if(edge[pa[res]][res]==-1)
				{
					edge[pa[res]][res]=edge[res][pa[res]]=pa[res];
					d[res]--,d2[res]++;
					d[pa[res]]--,d1[pa[res]]++;
				}
				else
				{
					edge[pa[res]][res]=edge[res][pa[res]]=0;
					d1[res]--;
					d2[pa[res]]--;
				}
				int t=res;
				res=pa[res];
				st[res][en[res][t]]=st[res][pa[res]];
				en[res][st[res][pa[res]]]=en[res][t];//链表的插入
			}
			if(edge[pa[res]][res]==-1)
			{
				edge[pa[res]][res]=edge[res][pa[res]]=pa[res];
				d[res]--,d2[res]++;
				d[p[i]]--,d1[p[i]]++;
			}
			else
			{
				edge[pa[res]][res]=edge[res][pa[res]]=0;
				d1[res]--;
				d2[p[i]]--;
			}
			too[p[i]]=res;
//			华丽的debug：
//			printf("%d:%d\n",i,res);
//			printf("pa:");
//			for(int j=1;j<=n;j++)printf("%d ",pa[j]);
//			printf("\n");
//			printf("from:");
//			for(int j=1;j<=n;j++)printf("%d ",from[j]);
//			printf("\n");
//			printf("to:");
//			for(int j=1;j<=n;j++)printf("%d ",too[j]);
//			printf("\n");
//			printf("d:");
//			for(int j=1;j<=n;j++)printf("%d ",d[j]);
//			printf("\n");
//			printf("d1:");
//			for(int j=1;j<=n;j++)printf("%d ",d1[j]);
//			printf("\n");
//			printf("d2:");
//			for(int j=1;j<=n;j++)printf("%d ",d2[j]);
//			printf("\n");
		}
		printf("\n");
	}
	return 0;
}
```

update:

程序发下来后调了有 20 分钟就 A 掉了……不过貌似能过掉链的数据？

---

## 作者：dsidsi (赞：66)

## Description

给定一棵树和每个节点上的初始数字，删除一条边的效果是交换被这条边连接的两个节点上的数字交换。

设$p_i$表示数字$i$在哪个节点，要求合理安排删除$n-1$条边的顺序，使得排列$p$字典序最小，

$n \leq 2000$

## Solution
考虑把一个数字从一个节点运送到另一个节点的过程。

可以发现，限制总共有$3$种：

 -  对于起点，选择的边要求是这个点所有边中第一条删除的；
 -  对于中间的点，要求选择的两条边的删除顺序必须连续；
 -  对于终点，选择的边要求是这个点所有边中最后一条删除的。

那么考虑对于每个点建立一张图，图上面的点代表这个点连出去的一条边。

在这张图上的一条有向边代表出点要在入点之后马上选择，同时记录这个点钦定的第一条边和最后一条边。每个点的图不相关。

那么考虑贪心，从小到大确定每个数字的最终位置，同时保证不矛盾。

矛盾的情况有三种：

 - 图的形式不是若干条链的形式；
 - 第一个点（边）有入边，最后一个点（边）有出边；
 - 第一个点（边）所在的链的链尾是最后一个点（边），但是还有其他的点不在链中。

从每个数字的起始点出发，保证从根到这个点的路径不会引起矛盾，更新答案即可。

我写的是并查集，如果想写$O(n^2)$的链表写法，那么只要满足每次相连的是两条链的链首和链尾，然后分别记录链首、链尾的所在的链的链尾和链首即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gi()
{
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	int sum = 0;
	while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

const int maxn = 2005;

inline void chkmin(int &a, int b) {if (a > b) a = b;}

int n, nump[maxn];

struct edge
{
	int to, next;
} e[maxn * 2];
int h[maxn], tot;

struct node
{
	int fst, lst, cnt, fa[maxn];
	bool bg[maxn], ed[maxn];
	
	void clear() {fst = lst = cnt = 0; for (int i = 1; i <= n; ++i) fa[i] = i, bg[i] = ed[i] = 1;}
	int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
} t[maxn];

inline void add(int u, int v)
{
	e[++tot] = (edge) {v, h[u]}; h[u] = tot; ++t[u].cnt;
	e[++tot] = (edge) {u, h[v]}; h[v] = tot; ++t[v].cnt;
}

int dfs1(int u, int fe)
{
	int res = n + 1;
	if (fe && (!t[u].lst || t[u].lst == fe)) {
		if (t[u].ed[fe] && !(t[u].fst && t[u].cnt > 1 && t[u].find(fe) == t[u].find(t[u].fst))) 
			res = u;
	}
	for (int i = h[u], v, te; v = e[i].to, i; i = e[i].next) {
		if (fe == (te = (i >> 1))) continue;
		te = i >> 1;
		if (!fe) {
			if (!t[u].fst || t[u].fst == te) {
				if (!t[u].bg[te]) continue;
				if (t[u].lst && t[u].cnt > 1 && t[u].find(te) == t[u].find(t[u].lst)) continue;
				chkmin(res, dfs1(v, te));
			} else continue;
		} else {
			if (fe == t[u].lst || te == t[u].fst || t[u].find(fe) == t[u].find(te)) continue;
			if (!t[u].ed[fe] || !t[u].bg[te]) continue; 
			if (t[u].fst && t[u].lst && t[u].cnt > 2 && t[u].find(fe) == t[u].find(t[u].fst) && t[u].find(te) == t[u].find(t[u].lst)) continue;
			
			chkmin(res, dfs1(v, te));
		}
	}
	return res;
}

int dfs2(int u, int fe, int p)
{
	if (u == p) return t[u].lst = fe, 1;
	for (int i = h[u], v, te; v = e[i].to, i; i = e[i].next)
		if (fe != (te = (i >> 1))) 
			if (dfs2(v, te, p)) {
				if (!fe) t[u].fst = te;
				else {
					t[u].ed[fe] = t[u].bg[te] = 0; --t[u].cnt;
					t[u].fa[t[u].find(fe)] = t[u].find(te);
				}
				return 1;
			}
	return 0;
}

int main()
{
	int T = gi();
	while (T--) {
		tot = 1;
		memset(h + 1, 0, sizeof(int) * n);
		
		n = gi();
		for (int i = 1; i <= n; ++i) t[i].clear();
		for (int i = 1; i <= n; ++i) nump[i] = gi();
		for (int i = 1; i < n; ++i) add(gi(), gi());

		if (n == 1) {puts("1"); continue;}
		
		for (int p, i = 1; i <= n; ++i) {
			p = dfs1(nump[i], 0);
			dfs2(nump[i], 0, p);
			printf("%d ", p);
		}
		puts("");
	}
	
	return 0;
}
```

---

## 作者：lyyi2003 (赞：30)


[>Blog<内食用体验更佳](https://www.cnblogs.com/lishuyu2003/p/12077009.html)

[题面](https://www.luogu.com.cn/problem/P5659?contestId=24103)

这是一道典型的**部分分启发正解**的题。

所以我们先来看两个部分分。

###Part 1 菊花图###

这应该是除了暴力以外最好想的一档部分分了。

![](https://img2018.cnblogs.com/blog/1736016/201912/1736016-20191221153222869-758892039.png)

如上图（节点上的数字已省略），如果我们依次删去边(2)(1)(3)(4)，那么操作完后2号点上的数字就会跑到1号点上，1号点数字会跑到3号点上，3号点数字跑到4号点上……依此累推。那么我们相当于把五个节点连成了一个环( 5 -> 2 -> 1 -> 3 -> 4 -> 5 )，每一个结点上的数字都会跑到环上的下一个结点上去，我们就是要求能使最终得到的排列字典序最小的环。那么我们逐位贪心，先由数字1所在的节点选择它在环上的下一个点是哪一个，在由数字2所在节点选，依此类推。每次在合法的情况下选标号最小的节点即可。具体细节可以见代码。

Part1 代码:
```
#include<bits/stdc++.h>
using namespace std;
#define N 4007
#define mem(x) memset(x,0,sizeof(x))
int p[N],ans[N],vis[N];
int fa[N];
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
int main()
{
    int n,t;
    scanf("%d",&t);
    while(t--)
    {
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	    fa[i]=i;
	mem(vis);
	for(int i=1;i<=n;i++)
	    scanf("%d",&p[i]);
	int x,y;
	for(int i=1;i<n;i++)
	    scanf("%d%d",&x,&y);
	for(int i=1;i<=n;i++)
	{
	    int x=p[i];
	    for(int j=1;j<=n;j++)
	    {
		if(!vis[j]&&(i==n||find(x)!=find(j)))
		{
		    ans[i]=j;
		    fa[find(x)]=find(j);
		    vis[j]=1;
		    break;
		}
	    }
	}
	for(int i=1;i<=n;i++)
	    printf("%d ",ans[i]);
	printf("\n");
    }
    return 0;
}
```

###Part2 链###

这一部分和正解关系紧密，引入了**拓扑序**的模型来描述题目中的限制条件。


![](https://img2018.cnblogs.com/blog/1736016/201912/1736016-20191221160417789-306793148.png)


其中节点中括号里的是节点上的数字。

如果数字1想跑到1号节点上去要怎么办？

那么我们可以依次删去(2)(3)号边，那么数字1就在1号点上了。

只要这样就可以了吗？

其实这里还隐含了两个条件，就是边(1)必须在(2)之后删除，且(4)必须在(3)之前删除，不然数字1就不在它应该在的地方了。

如果我们为每一条边定一个**优先级**，优先级大的先删，那么4条边的优先级大小关系就是：(1) < (2) > (3) < (4)

这样我们就可以保证数字1最终在1号点上了，此外因为我们要逐位贪心，所以在此基础上我们还希望数字2能到2号节点上。

但这是否有可能呢？

发现这样是不可能的，因为要使数字2到达2号点，那么必须满足优先级(3) > (2) ， 与数字1的条件是冲突的，所以不行。

所以我们得到了这部分的算法：

从数字1到数字n逐位贪心，每次选择一个当前数字能到达的、不与之前条件冲突的、标号最小的节点，作为这个数字最终所在的节点。然后将新产生的条件加入。

具体的实现可以在每一个节点上维护一个标记值0,1,2，分别表示这个节点左右的两条边之间的优先级 没有限制、左边大于右边、右边大于左边。然后每次从当前数字所在位置向左右两边找符合条件的点，再把新条件对应的标记值更新即可。具体见代码。


Part2 代码：
```
#include<bits/stdc++.h>
using namespace std;
#define N 4007
int hd[N],pre[N],to[N],num,tag[N],pos[N],id[N],p[N],d[N],cnt,ans[N];
void adde(int x,int y)
{
    num++;pre[num]=hd[x];hd[x]=num;to[num]=y;
}
void dfs(int v,int f)
{
    id[++cnt]=v,pos[v]=cnt;
    for(int i=hd[v];i;i=pre[i])
    {
	int u=to[i];
	if(u==f)continue;
	dfs(u,v);
    }
}
#define mem(x) memset(x,0,sizeof(x))
int main()
{
    int n;
    int t;
    scanf("%d",&t);
    while(t--)
    {
	scanf("%d",&n);
	mem(hd),mem(tag),mem(d);
	num=0,cnt=0;
	for(int i=1;i<=n;i++)
	    scanf("%d",&p[i]);
	for(int i=1;i<n;i++)
	{
	    int x,y;
	    scanf("%d%d",&x,&y);
	    adde(x,y),adde(y,x);
	    d[x]++,d[y]++;
	}
	int rt=0;
	for(int i=1;i<=n ;i++)
	    if(d[i]==1)rt=i;
	dfs(rt,0);
	for(int i=1;i<=n;i++)
	{
	    int x=p[i],b=pos[x];
	    int mi=n+1;
	    if(tag[b]!=1)
	    {
		for(int j=b+1;j<=n;j++)
		{
		    if(tag[j]!=1)mi=min(mi,id[j]);
		    if(tag[j]==2)break;
		}
	    }
	    if(tag[b]!=2)
	    {
		for(int j=b-1;j>=1;j--)
		{
		    if(tag[j]!=2)mi=min(mi,id[j]);
		    if(tag[j]==1)break;
		}
	    }
	    if(pos[mi]>b)
	    {
		for(int j=b+1;j<=pos[mi]-1;j++)tag[j]=1;
		tag[b]=tag[pos[mi]]=2;
	    }
	    else
	    {
		for(int j=pos[mi]+1;j<b;j++)tag[j]=2;
		tag[pos[mi]]=tag[b]=1;
	    }
	    tag[1]=tag[n]=0;
	    ans[i]=mi;
	}
	for(int i=1;i<=n;i++)
	    printf("%d ",ans[i]);
	printf("\n");
    }
    return 0;
}
```

###Part3 正解###

其实从第二部分我们已经看到，形如数字x要到y号节点上所需满足的条件可以描述为一系列边的优先级的大小关系（这里的优先级实际上就是一种拓扑序），并且我们可以把这些条件放在节点上，表示与这个节点相邻的所有边之间的大小关系是怎样的，也就是说**只有与同一个节点相邻的边之间才会有大小关系的限制**。那么我们如何把链上的算法拓展到一般的树上呢？

![](https://img2018.cnblogs.com/blog/1736016/201912/1736016-20191221171353039-1564013267.png)

如果有一个数字想从1号点到3号点，那么需要满足的条件有两种：

1. (3)的优先级是与1号点相邻的边中最大的，(6)的优先级是与3号点相邻的边中最小的；

2. (3)的优先级大于(6)；



对于条件2，这样还不够充分，因为如果删完(3)之后再删(4)的话就不对了。也就是说删完(3)之后要紧接着删(6)

这个限制条件就相当于把与2号点相邻的边按照优先级大小排列，那么(3)和(6)必须是相邻的，且(3)在(6)前面。

怎么做到这一点呢？发现这种要让两条边相邻的条件其实已经在第一部分的菊花图中讨论过了，一样的用并查集判断即可，只不过Part1中只用了一个并查集，而现在我们要维护每一个点周围的边的大小关系，所以要对每一个点开一个并查集。

而对于条件1，我的做法是对每一个并查集建了一个虚点，如果一条边的优先级最大，那么由虚点向它连一条边，如果一条边优先级最小，则由它向虚点连一条边，这样就可以直接套Part1部分的代码了。

然后贪心过程与Part2类似，每次从一个点出发遍历整棵树，每走一条边就判断一下，然后再对一条路径进行修改即可。


Part3 代码：

```
#include<bits/stdc++.h>
using namespace std;
#define N 20007
#define mem(x) memset(x,0,sizeof(x))
int hd[N],pre[N],to[N],num,fa[N],sz[N],d[N],p[N],ver;
bool in[N],out[N];
void adde(int x,int y)
{
    num++;pre[num]=hd[x];hd[x]=num;to[num]=y;
}
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
    int u=find(x),v=find(y);
    fa[u]=v,sz[v]+=sz[u];
    out[x]=in[y]=1;
}
bool check(int x,int y,int l)
{
    if(in[y]||out[x])return false;
    int u=find(x),v=find(y);
    if(u==v&&sz[u]!=l)return false;
    return true;
}
void dfs1(int v,int f)
{
    if(f!=v&&check(f,v,d[v]+1))ver=min(ver,v);
    for(int i=hd[v];i;i=pre[i])
    {
	int u=to[i];
	if(i==f)continue;
	if(check(f,i,d[v]+1))
	{
	    dfs1(u,i^1);
	}
    }
}
bool dfs2(int v,int f,int p)
{
    if(v==p)
    {
	merge(f,v);
	return true;
    }
    for(int i=hd[v];i;i=pre[i])
    {
	int u=to[i];
	if(i==f)continue;
	if(dfs2(u,i^1,p))
	{
	    merge(f,i);
	    return true;
	}
    }
    return false;
}
int main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
	scanf("%d",&n);
	mem(hd),mem(in),mem(out),mem(d);
	num=(n+1)/2*2+1;
	for(int i=1;i<=n;i++)
	    scanf("%d",&p[i]);
	for(int i=1;i<n;i++)
	{
	    int x,y;
	    scanf("%d%d",&x,&y);
	    d[x]++,d[y]++;
	    adde(x,y),adde(y,x);
	}
	for(int i=1;i<=num;i++)
	    fa[i]=i,sz[i]=1;
	for(int i=1;i<=n;i++)
	{
	    int v=p[i];
	    ver=n+1;
	    dfs1(v,v);
	    dfs2(v,v,ver);
	    printf("%d ",ver);
	}
	printf("\n");
    }
    return 0;
}
```


总结：通过这题大家可以发现，此题正解与部分分是紧密相连的，如果没有对部分分的思考，很难直接想到正解。这启发我们当无法直接想到正解时，可以思考一些此题的部分分，找到部分分与正解之间的联系，进而以迂回的方式找到正解。一些人因过于追求正解，直接跳过部分分思考正解，结果反而无法得到正解。~~比如本文作者就是这样一个反面例子~~


---

## 作者：crashed (赞：27)

# upd

- 2021.10.14 感谢 @qinyubo 提出的指正，修复了 $n=1$ 的边界的锅。同时~~现代化~~修正了题解的格式，使之更加符合当下的标准。

# 题目

[点这里](https://www.luogu.org/problem/P5659)看题目。 

# 分析

这道题真的不简单，细节巨多，恶心死你。但是思路并没有太难。 

### 10pts 

~~拿到平均分了！喜闻乐见~~ 

写一个暴力全排把它骗过去就可以了。 

### 35pts：暴力+菊花图 

两个部分分摆在眼前，先做哪一个呢？ 

经验也许告诉你，链的情况比较好做。但是实际上，我强烈推荐写菊花图。 

为什么？~~没有为什么~~因为菊花图需要挖掘的性质并不深。 

不妨设菊花图的花心为$u$，手玩一下菊花图的数据你会发现，假如将拆边描述为一个点的排列 $p_1,p_2,...,p_{n-1}(\forall1\le i<n ,p_i\not=u)$（也就是说，你按顺序拆掉了 $(u,p_1),(u,p_2),..,(u,p_{n-1})$），那么最后，原来根上的数字 $a_u$ 会去到 $p_1$，原来 $p_1$ 上的数字 $a_{p_1}$ 会去到 $p_2$，原来 $p_2$ 上的数字 $a_{p_2}$ 会去到 $p_3$，...，原来 $p_n$ 上的数字 $a_{p_n}$ 会去到 $u$。如果我们将点按照$(u,p_1,p_2,...,p_n)$的顺序排成一个环的话，整个操作就相当于将每个点上的数字向后移了一位！ 

于是很容易地想到一个贪心的构造环的方法。按照 $1,2,3,...,n$ 的顺序，每个数字从自己所在的点选择在环上面的下一个点。这里有两点需要注意： 

- 在环还没有封闭的时候，请注意它们都还是一些链，所以不要出现两个点的后一个点相同的情况。 

- 保证最后会出现一个大环而不是若干个小环，这个可以用并查集维护。 

然后恭喜你，你有 35pts 了。~~比平均分高！喜闻乐见~~ 

### 60pts：暴力+菊花图+链 

下面我们将要攻克单链。 

（敲黑板）这个时候就需要挖掘题目的一个非常重要的性质了。假如我们想要把 $a$ 从它的**起始点 $u$** 运到 $b$ 所在的 $v$，并且**就此终止**，那么这个性质可以如下描述： 

- 对于 $u$，它通向 $v$ 的那一条边一定是 $u$ 所相连的那些边中最先被删除的。不然，$a$ 会被先运走。 

- 对于 $a$ 去往 $v$ 的路径上的中转点 $w$，$a$ 离开 $w$ 的那条边一定会紧跟着 $a$ 进入 $w$ 的那条边被删除。不然 $a$ 也会被运走。 

- 对于 $v$，$a$ 到达它的那条边一定是 $v$ 所相连的那些边中最后被删除的。不然，$a$ 还是会被运走。   

考虑链的情况。由于链上的的点的度最多为 2，所以我们可以直接用一个变量表示两条边的先后关系——左先右后、左后右先或者还未确定。

 同样是从小到大枚举数。假如当前枚举到了 $i$，我们当然希望它去到它所能到的最小的那一个点。现在考虑怎么找到这一个点。 

最暴力的方法，假如当前 $i$ 在 $u$，我们枚举目标点 $v$。这样我们就可以用 $O(n)$ 的时间扫一遍过去检查可不可行。在单链的情况下，不合法方式只会有一种：经过点的已经要求了的删边顺序和当前需要的删边顺序有冲突。这个可以通过检查变量来实现。 

另外，注意链的两个端点需要特殊处理，因为它们的度都是 1，所以就不存在先后关系的说法了。 

这样做是 $O(n^3)$。  

然后发现这个扩展的方式存在单调性——例如在往左边扩展的时候，我们不能经过 $w$ 这个点，那么在左边并且比 $w$ 离 $u$ 更远的那些点就更不可能走到了。 

然后就可以由近及远地枚举点，走不动了就退出，中间选取那些可行的终止点并取出最小的，时间就是 $O(n^2)$。 

### 100pts

终于，我们要直面正解了！ 

根据我们从链的情况中得到的结论，我们会发现，对于删边的顺序，不同的点之间是独立的。也就是说对于边 $(u,v)$ 和 $(u,w)$，如果在$u$点上要求 $(u,w)$ 比 $(u,v)$ 先删除，那么这并不影响在 $v$ 点上，$(u,v)$ 与其它边的先后关系。不同点的邻接边删除的顺序不会互相影响。 

并且，不会存在这种情况：$(u,v)$ 和 $(u,w)$ 都比 $(u,a)$ 先（后）删除，但是我们却还不知道 $(u,v)$ 和 $(u,w)$ 的先后关系。因为这样的情况会导致错误情况，例如原本应当从 $a$ 运进来，运出去到 $v$ 的数，被中途错误地运到了 $w$。假如对于一个点，我们将它的邻接边抽象成一堆点，用一条有向边 $(u,v)$ 表示边 $u$ 会比 $v$ 先删除，那么合法的方案种**绝对不会存在一个代表一条边的点的出度或入度超过$1$** 。 

上面的结论说明，一个点的邻接边抽象成点后，用有向边表示删除先后关系的话，形成的总是一堆链。 

当然，根据上面的性质，我们可以知道，在一个点的邻接边中，有一条会强制被第一个删除，有一条会强制被最后一条删除。它们必须是链的起点（第一个）或终点（最后一个）。 

于是，假如我们当前枚举一个数$i$，像链一样用一个扩 DFS 展可行的点，记录可以走到的最小的点。对于可走不可走，有三条限制： 

- 不能有边比当前的第一条边先删除；不能有边比当前的最后一条边后删除 

- 一条边不能在存在另一条边紧跟着它被删除的情况下，再出现一条边，也要紧跟着它删除。 

- 如果当前的操作会导致当前的第一条边和最后一条边合并在一条链里面，并且除开它们所在的链以外还有一些链没有合并起来，那么这就是不合法的（参考菊花图，这样会导致边删不完） 

用 DFS 扩展的时候判一下这些条件。用并查集和一个表示当前有没有入边/出边的数组来维护这些条件。找到了目标点之后就再用一个 DFS 来更新条件。 

时间是 $O(n^2)$。 

~~这道题其实赛场满分只有 10 分，那么你其实已经完成了 10 道题了。~~ 

# 代码

```cpp
#include <cstdio>

const int INF = 0x3f3f3f3f;
const int MAXN = 2005;

template<typename _T>
void read( _T &x )
{
    x = 0; char s = getchar();int f = 1;
    while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
    while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ) { putchar( '-' ), x = -x; }
    if( 9 < x ) { write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
    return a < b ? a : b;
}

struct edge
{
    int to, nxt;
}Graph[MAXN << 1];

struct UFS
{
    int fa[MAXN];
    bool beg[MAXN], fin[MAXN];
    //记录有没有出边或者入边，true 代表没有
    void operator () ( const int siz ) { for( int i = 1 ; i <= siz ; i ++ ) fa[i] = i, beg[i] = fin[i] = true; }
    int& operator [] ( const int u ) { return fa[u] = ( fa[u] == u ? fa[u] : ( *this )[fa[u]] ); }
    bool operator () ( const int a, const int b ) { return ( *this )[a] == ( *this )[b]; }
    //并查集维护所属链
}info[MAXN];

int stt[MAXN], fir[MAXN], las[MAXN], deg[MAXN];
int head[MAXN];
int N, cnt;

void addEdge( const int from, const int to )
{
    cnt ++;
    Graph[cnt].to = to, Graph[cnt].nxt = head[from];
    head[from] = cnt, deg[from] ++;
}

void clear()
{
    cnt = 1;
    for( int i = 1 ; i <= N ; i ++ ) 
        head[i] = fir[i] = las[i] = 0, info[i]( N - 1 ), deg[i] = 0;
}

int expand( const int u, const int faE )
{
    int res = INF;
    if( faE && ( ! las[u] || las[u] == faE ) )
        if( info[u].fin[faE] && ! ( fir[u] && deg[u] > 1 && info[u][faE] == info[u][fir[u]] ) )
            res = u;
            //判断是否可以作为终点
    int id, v;
    for( int i = head[u] ; i ; i = Graph[i].nxt )
    {
        id = i >> 1, v = Graph[i].to;
        if( id == faE ) continue;
        if( ! faE )
        {
            if( ! fir[u] || fir[u] == id )
            {
                if( ! info[u].beg[id] ) continue;
                if( las[u] && deg[u] > 1 && info[u]( id, las[u] ) ) continue;
                res = MIN( res, expand( v, id ) );
            }
            //起点的移动
        }
        else
        {
            if( faE == las[u] || id == fir[u] || info[u]( faE, id ) ) continue;
            if( ! info[u].beg[id] || ! info[u].fin[faE] ) continue;
            if( fir[u] && las[u] && deg[u] > 2 && info[u]( fir[u], faE ) && info[u]( id, las[u] ) ) continue;
            res = MIN( res, expand( v, id ) );
            //中转点的移动
        }
    }
    return res;
}

bool cover( const int u, const int faE, const int tar )
{
    if( u == tar ) { las[u] = faE; return true; }
    int v, id;
    for( int i = head[u] ; i ; i = Graph[i].nxt )
    {
        v = Graph[i].to, id = i >> 1;
        if( id ^ faE && cover( v, id, tar ) )
        {
            if( ! faE ) fir[u] = id;
            else
            {
                info[u].fin[faE] = false, info[u].beg[id] = false;
                info[u][id] = info[u][faE];
                deg[u] --;
            }
            return true;
        }
    }
    return false;
}

//更新信息

int main()
{
    int T;
    read( T );
    while( T -- )
    {
        int fr, to;
        read( N );
        clear();
        for( int i = 1 ; i <= N ; i ++ ) read( stt[i] );
        for( int i = 1 ; i < N ; i ++ )
            read( fr ), read( to ), addEdge( fr, to ), addEdge( to, fr );
        if( N == 1 )
        {
        	puts( "1" );
        	continue;
		}
        for( int i = 1 ; i <= N ; i ++ )
        {
            int mn = expand( stt[i], 0 ); 
            cover( stt[i], 0, mn );
            write( mn ), putchar( i == N ? '\n' : ' ' );
        }
    }
    return 0;
}```
```

---

## 作者：KSkun (赞：19)

本文同步发布在我的博客：[[CSP-S2 2019]树上的数 题解 | KSkun's Blog](https://ksmeow.moe/tree-csps219-sol/)，欢迎来逛~

广告：CSP-J/S2 2019 志愿者的幕后故事：[CSP-JS2 2019 游记 | KSkun's Blog](https://ksmeow.moe/csp-js2-2019/)

## 题意简述

一棵 $n$ 个节点的树上每个节点有一个 $1 \sim n$ 中的数字，定义对边 $(u, v)$ 进行删边操作为删边且交换 $u, v$ 节点上的数字，定义 $P_i$ 为数字 $i$ 所在的节点编号，求使得 $P_i$ 字典序最小的删边顺序。仅输出字典序最小的 $P_i$ 。

## 题解

*由于作者水平有限，本题解表述、逻辑可能存在不足之处，欢迎读者以自身理解提出改进意见。*

刚看到这个题目的时候，总是想发掘树链上的性质，处理点上的信息，这种惯性思维使我完全没有思路。事实上，这个题处理边上的信息更好。

### 菊花图

本题中，有 $25$ 分的菊花图部分分，在菊花图和链两个部分分中，菊花图事实上相对好思考一些，因此先考虑菊花图的情况。

假如我们已经得到了菊花图上删边的顺序为 $(1, u_1), (1, u_2), \dots, (1, u_m)$ ，则按顺序删边后，容易发现， $1$ 号点的数字移动至 $u_1$， $u_1$ 的数字移动至 $u_2$，……， $u_m$ 的数字移动至 $1$ 。

因此我们可以贪心地构造这个顺序，枚举数字 $1 \sim n$ ，每个数字贪心地选择删边顺序中的下一条边，该数字最后的位置就是该边对应的 $u_i$ 。

### 链

链的情况同样是 $25$ 分。

在链的情况中，分析边的关系是必要的。对于一个数字 $k$ 从初始位置 $u_1$ 移动至 $u_m$ ，在路径 $u_1, u_2, \dots, u_m$ 上有以下性质：

- 对于起点 $u_1$ ，其出边 $(u_1, u_2)$ 一定是这一点先被删掉的边。
- 对于终点 $u_m$ ，其入边 $(u_{m-1}, u_m)$ 一定是这一点后被删掉的边。
- 对于中间点 $u_i$ ，其入边 $(u_{i-1}, u_i)$ 先于出边 $(u_i, u_{i+1})$ 被删。

因此对于每个点可以获得一个删边的顺序，左先于右或右先于左。仍然按 $1 \sim n$ 的顺序枚举数字，检查每个数字从初始位置向左向右能走到的点中的最小编号。不能走仅当该点已确定的顺序不满足当前需要的顺序。

### 一般情况

与链类似，对于一个数字 $k$ 从初始位置 $u_1$ 移动至 $u_m$ ，在路径 $u_1, u_2, \dots, u_m$ 上有以下性质：

- **对于起点 $u_1$ ，其出边 $(u_1, u_2)$ 一定是这一点第一条被删掉的边。** 如果不是，则 $k$ 会被换到其他点上。
- **对于终点 $u_m$ ，其入边 $(u_{m-1}, u_m)$ 一定是这一点最后一条被删掉的边。** 如果不是，则 $k$ 也会被换到其他点上。
- **对于中间点 $u_i$ ，其入边 $(u_{i-1}, u_i)$ 先于出边 $(u_i, u_{i+1})$ 被删，且在该点的所有边里被删除的顺序是相邻的。** 如果不满足后一条性质，则在中间数字 $k$ 会被换到其他点上。

容易发现，这些限制都是应用在某一点的边中的，因此可以单独考虑每个点的情况。依然是 $1 \sim n$ 枚举每个数字，从这个数字的初始位置开始 DFS ，检查路径上的点是否可以作为中间点/终点即可。

这里是这个题的实现中最难的位置，即检查是否满足中间点/终点的条件。这里，我使用了链表+并查集的实现方法管理边的关系。用类似链表的结构存储某个点的边是否被应用了在某边之后/之前被删的限制，用并查集存储某个点的边的限制连成的链式结构，且用两个数组 beg 和 end 存储某个点的边中，被固定为第一条/最后一条被删的边。

对于一个点，它能作为终点的条件为：

- 不是起点；
- 入边必须能作为该点的最后一条被删的边；
- 特殊情况：当该点度数为 $1$ 时第一条/最后一条被删的边为同一条。

对于一个点，它能作为中间点的条件为：

- 入边之后不能有除出边之外的紧接着要删的边；
- 出边之前不能有除入边之外的紧接着要删的边；
- 将入边和出边的限制关系加入后，如果会使该点的第一条和最后一条被删的边加入了同一条关系链，则此时该点的边都在这条关系链中。

根据以上条件进行判断一个点是否能作为中间点/终点，寻找每个数字的最小编号终点，并在路径上应用出入边的限制即可。

由于细节众多，文字描述无法包括所有方面，可以参考代码中的注释来理解。

## 代码

*UPD：被卡常了，开 O2 洛谷可过。*

```cpp
// Code by KSkun, 2019/11
#include <cstdio>
#include <cctype>
#include <cstring>

#include <algorithm>
#include <vector>
#include <utility>

typedef long long LL;
typedef std::pair<int, int> PII;

inline char fgc() {
	static char buf[100000], * p1 = buf, * p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)
		? EOF : *p1++;
}

inline LL readint() {
	LL res = 0, neg = 1; char c = fgc();
	for(; !isdigit(c); c = fgc()) if(c == '-') neg = -1;
	for(; isdigit(c); c = fgc()) res = res * 10 + c - '0';
	return res * neg;
}

inline char readsingle() {
	char c;
	while(!isgraph(c = fgc())) {}
	return c;
}

const int MAXN = 2005;

int T, n, ptn[MAXN], deg[MAXN], beg[MAXN], end[MAXN]; // 每个点的第一条/最后一条被删的边
std::vector<int> gra[MAXN];

struct UnionFindSet {
	int fa[MAXN];
	bool pre[MAXN], nxt[MAXN]; // 一条边有无前后关系
	void clear() {
		for (int i = 1; i <= n; i++) fa[i] = i;
		memset(pre, 0, sizeof(pre));
		memset(nxt, 0, sizeof(nxt));
	}
	int find(int x) {
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	void join(int x, int y) { 
		int fx = find(x), fy = find(y);
		fa[fy] = fx;
		nxt[x] = pre[y] = true;
	}
	bool sameset(int x, int y) {
		return find(x) == find(y);
	}
} ufs[MAXN];

int dfs(int u, int f) {
	int mn = n + 1;
	// 能作为终点的条件：不是起点；入边可以是最后删边；入边之后无必须删边；入边和最后删边不在一条关系链中（只剩一条链时除外）
	if (f != 0 && (end[u] == 0 || end[u] == f) && !ufs[u].nxt[f] && 
		!(beg[u] != 0 && deg[u] > 1 && ufs[u].sameset(f, beg[u]))) {
		mn = std::min(mn, u);
	}	
	for (int v : gra[u]) {
		if (v == f) continue;
		if (f == 0) {
			// 不能作为起点之后的点的条件：起点的最后删边不是这条；这条边之前有必须删的边；这条边与最后删边在同一条关系链中，且仍有未加入关系链中的边
			if (beg[u] != 0 && beg[u] != v) continue;
			if (ufs[u].pre[v]) continue;
			if (end[u] != 0 && deg[u] > 1 && ufs[u].sameset(v, end[u])) continue;
			mn = std::min(mn, dfs(v, u));
		} else {
			// 不能作为中间点的条件：入边是最后删边；出边是最先删边；入边和出边已在同一条关系链中；出边之前有必须删边；入边之后有必须删边；应用出入边关系后让最先删边和最后删边在同一条关系链中，且有其他边未在该关系链中
			if (f == end[u] || v == beg[u] || ufs[u].sameset(f, v)) continue;
			if (ufs[u].pre[v] || ufs[u].nxt[f]) continue;
			if (beg[u] != 0 && end[u] != 0 && deg[u] > 2 && 
				ufs[u].sameset(f, beg[u]) && ufs[u].sameset(v, end[u])) continue;
			mn = std::min(mn, dfs(v, u));
		}
	}
	return mn;
}

bool dfs2(int u, int f, int& tar) {
	if (u == tar) {
		end[u] = f; return true;
	}
	for (int v : gra[u]) {
		if (v == f) continue;
		if (dfs2(v, u, tar)) {
			if (f == 0) {
				beg[u] = v;
			} else {
				ufs[u].join(f, v);
				deg[u]--;
			}
			return true;
		}
	}
	return false;
}

int main() {
	T = readint();
	while (T--) {
		n = readint();

		// init
		memset(beg, 0, sizeof(beg));
		memset(end, 0, sizeof(end));
		memset(deg, 0, sizeof(deg));
		for (int i = 1; i <= n; i++) {
			gra[i].clear();
			ufs[i].clear();
		}
		
		// input
		for (int i = 1; i <= n; i++) ptn[i] = readint();
		for (int i = 1, x, y; i < n; i++) {
			x = readint(); y = readint();
			gra[x].push_back(y);
			gra[y].push_back(x);
			deg[x]++; deg[y]++; // deg 表示一个点的边关系构成的链的数量，初始为度数，之后每加入一个关系就对其减 1
		}

		// process
		for (int i = 1; i <= n; i++) {
			int mn = dfs(ptn[i], 0);
			dfs2(ptn[i], 0, mn);
			printf("%d ", mn);
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：文文殿下 (赞：16)

观察链上的情况，我们发现从一个点$l$到另一个点$r$，我们给他们之间的相邻两条边，添加了一个先后顺序。 比如说我们必须先走$l～l+1$才能走$l+1 ～ l+2$。

对于边界的两个点，他们连接的所有边中，分别要第一个走$l～l+1$ 和最后一个走 $r-1 ～ r$。

那么我们可以从前到后枚举每一位，对于每一位，我们枚举它最终停在哪里，判断和之前的条件是否冲突，贪心选所有能到达节点最小的。

判断条件我们可以用一个链表维护，因为我们每次会把连续一段添加一个先后顺序。

那么判断是否满足就是$O(1)$的了，总复杂度$O(n^2)$



对于菊花图，我们考虑如果想让两个叶子结点$u$到达点$v$，我们一定要走菊花的中心。并且必须连续走边$(u,root)$,$(root,v)$(我们用root表示菊花图中心）。
那么我们就得到了，对于$root$点，它其中某两条边有先后顺序的限制。

对于中心节点$root$的移动，我们实际上是给它所有边的先后顺序确定起点和终点。因为它移动过去就回不来了。

那么我们可以用一个链表配合并查集维护这个限制关系，像链上一样贪心枚举，时间复杂度$O(n^2\alpha(n))$

对于一般图，我们可以认为是一堆菊花和一堆链的结合体，采用菊花图的做法，但是没办法暴力枚举，因为我们没办法$O(\alpha(n))$判断了。

考虑我们如果要进行一次移动$(u->m->v)$，那么我们需要的是，对于$u$连出来的所有边，$(u->m)$是第一个走的，对于$m$连出来的所有边，$(m->v)$紧接着$(u->m)$走，对于$v$连出来的边，$(m->v)$是最后走的。

我们发现对于每个节点，限制都是独立的。我们在每一个节点开一个菊花图那样的并查集配合链表维护，然后不再枚举每个点的落点，而是对每个点dfs,看他能扩展到哪些点，之后找一个编号最小的就行了。

时间复杂度$O(n^2\alpha(n))$。

这道题除了细节特别多多多多多多多多多多，也没什么特别恶心的地方。

代码如下：

```cpp

#include<bits/stdc++.h>
using namespace std;

const int maxn = 2020;
vector<int> E[maxn];
int T,n;
int pos[maxn];
int L[maxn][maxn],R[maxn][maxn],pre[maxn],ans[maxn],num[maxn];
bool vis[maxn];
bool nt[maxn][maxn];
int fst[maxn],lst[maxn];
int fa[maxn][maxn];
int siz[maxn][maxn];
set<pair<int,int> > S;
int find(int pos ,int x) {
	return fa[pos][x]==x ? x: fa[pos][x] = find(pos,fa[pos][x]) ;
}
void dfs(int u,int f) {
	for(auto nx : E[u]) if(nx!=f) 
		pre[nx]=u;
	if(f==0) {
		for(auto nx : E[u]) {
			if(lst[nx]) continue;
			//if(num[u]!=0 && lst[u] == nx) continue;
			if(L[u][nx] != nx) continue;
			//if(S.count(make_pair(u,nx))) continue;
			if(find(nx,fst[nx]) == find(nx,u)) {
				if(siz[nx][find(nx,fst[nx])] != E[nx].size() ) continue;
			}
			if(find(u,lst[u]) ==find(u,nx)) {
				if(siz[u][find(u,lst[u])] != E[u].size()) continue;
			}
			if(R[nx][u] == u) 
				vis[nx]=1;
		}
	}
	else {
		for(auto nx : E[u]) {
			if(nx==f) continue;
			if(lst[nx]) continue;
			//if(num[u] - (nt[u][f]^1) != 0 && lst[u] == nx) continue;
			//if(S.count(make_pair(u,nx))) continue;
			if((R[u][f] == nx && L[u][nx] == f) || (R[u][f] == f && L[u][nx] == nx && find(u,f) != find(u,nx) )) {
				if(find(nx,fst[nx]) == find(nx,u)) {
					if(siz[nx][find(nx,fst[nx])] != E[nx].size() ) continue;
				}
				if(find(u,nx) == find(u,lst[u])) {
					if(find(u,f) == find(u,fst[u])) {
						if(siz[u][find(u,f)] + siz[u][find(u,nx)] != E[u].size()) continue;
					}
				}
				if(find(u,nx) == find(u,fst[u])) {
					if(find(u,f) == find(u,lst[u])) {
						if(siz[u][find(u,f)] + siz[u][find(u,nx)] != E[u].size()) continue;
					}
				}
				if(R[nx][u] == u ) {
					vis[nx]=1;
				}
			}
		}
	}
	if(f==0) {
		for(auto nx : E[u]) {
			//if(S.count(make_pair(u,nx))) continue;
			//if(L[u][nx] == nx ) {
				if(find(u,nx) == find(u,lst[u])) {
					if(siz[u][find(u,lst[u])] != E[u].size()) continue;
				}
				dfs(nx,u);
			//}
		}
	}
	else {
		if(lst[u] != f) 
			for(auto nx : E[u]) {
				if(nx==f) continue;
				//if(S.count(make_pair(u,nx))) continue;
				if(((R[u][f] == f && find(u,f) != find(u,nx) )|| R[u][f] == nx) && ((L[u][nx] == nx && find(u,nx) != find(u,f) )|| L[u][nx] == f)) {
					if(find(u,f) == find(u,lst[u])) {
						if(find(u,nx) == find(u,fst[u]) ) 
							if(siz[u][find(u,nx)] + siz[u][find(u,f)] != E[u].size()) continue;
					}
					if(find(u,f) == find(u,fst[u])) {
						if(find(u,nx) == find(u,lst[u]) ) 
							if(siz[u][find(u,nx)] + siz[u][find(u,f)] != E[u].size()) continue;
					}
					dfs(nx,u);
				}
			}
	}
}

void doChange(int cur,int goal) {
	lst[goal] = pre[goal];
	if(!nt[goal][pre[goal]] ) --num[goal],nt[goal][pre[goal]]=1;
	R[goal][pre[goal]] = -1;
	//S.insert(make_pair(pre[goal],goal));
	int nxt = goal;
	goal = pre[goal];
	while(goal != cur) {
		if(!nt[goal][pre[goal]]) --num[goal],nt[goal][pre[goal]]=1;
		R[goal][pre[goal]] = nxt;
		if(!nt[goal][nxt]) --num[goal],nt[goal][nxt]=1;
		L[goal][nxt] = pre[goal];
		int p = find(goal,pre[goal]);
		int q = find(goal,nxt);
		if(p!=q) {
			if(siz[goal][p]  > siz[goal][q] ) swap(p,q);
			fa[goal][p]=q;
			siz[goal][q] += siz[goal][p];
		}
		//S.insert(make_pair(goal,nxt));
		nxt = goal;
		goal = pre[goal];
	}
	fst[cur] = nxt;
	if(!nt[cur][nxt]) --num[cur],nt[cur][nxt]=1;
	L[cur][nxt]=-1;
	//S.insert(make_pair(cur,nxt));
}
int main() {
	//#ifdef ONLINE_JUDGE
	//freopen("tree.in","r",stdin);
	//freopen("tree.out","w",stdout);
	//#endif
	scanf("%d",&T);
	while(T--) {
		//S.clear();
		memset(siz,0,sizeof siz);
		scanf("%d",&n);
		for(int i=1;i<=n;++i) scanf("%d",pos+i);
		for(int i=1;i<=n;++i) E[i].clear(),fst[i]=lst[i]=ans[i]=0;
		for(int i=1;i<=n;++i) 
			for(int j=1;j<=n;++j) 
				L[i][j]=j,R[i][j]=j,fa[i][j]=j,nt[i][j]=0,siz[i][j]=1;
		for(int i=1;i<=n;++i) assert(E[i].size()==0);
		for(int i=1;i<n;++i) {
			int u,v;
			assert(scanf("%d%d",&u,&v)==2);
			assert(u!=v);
			E[u].push_back(v);
			E[v].push_back(u);
		}
		for(int i=1;i<=n;++i) num[i]=E[i].size();
		for(int i=1;i<=n;++i) {
			int cur = pos[i];
			for(int j=1;j<=n;++j) vis[j]=pre[j]=0;
			dfs(cur,0);
			for(int j=1;j<=n;++j) {
				if(vis[j]) {
					ans[i]=j;
					doChange(cur,j);
					break;
				}
			}
		}
		for(int i=1;i<=n;++i) printf("%d ",ans[i]);
		puts("");
	}
	return 0;
}

```

---

## 作者：cirnovsky (赞：15)

## Part 0

>大致思路

主要的思路就是逐个打破，研究特殊的数据得到普通的结论。

(啊对了博客食用体验更佳：[Click Here](https://www.orchid-any.cf/2020/03/15/SOL-P5659/)

## Part 1

>暴力的部分分

暴力的部分分很好拿，我们可以直接把全排列，然后 $\Theta(n)$ 判断更新答案。

~~恭喜您拿到赛场满分~~

```cpp
namespace SubtaskForce {
	int cmp[MAXN], ans[MAXN];
	bool vis[MAXN];
	void dfs(int now) { // 全排列
		if (now == n) { // 更新答案
			for (R int i = 1; i <= n; ++i) cmp[id[i]] = i;
			for (R int i = 1; i <= n; ++i) {
				if (cmp[i] < ans[i]) {
					for (R int j = 1; j <= n; ++j) ans[j] = cmp[j];
					break;
				}
				if (cmp[i] > ans[i]) break;
			}
			return ;
		}
		for (R int i = 1; i < n; ++i) {
			if (!vis[i]) {
				vis[i] = 1;
				swap(id[nodes[i].x], id[nodes[i].y]);
				dfs(now + 1);
				swap(id[nodes[i].x], id[nodes[i].y]);
				vis[i] = 0;
			}
		}
	}

	void main() { // 初始化
		for (R int i = 1; i <= n; ++i) vis[i] = 0;
		for (R int i = 1; i <= n; ++i) ans[i] = n - i + 1;
		dfs(1);
		for (R int i = 1; i <= n; ++i) printf("%d ", ans[i]);
		puts("");
	}
}
```

## Part 2

>菊花图的部分分

就这道题而言，菊花图其实是比链的数据好想一些的。

我们称菊花图中度数为 $n-1$ 的结点为 $rt$ 罢。

我们可以发现在菊花图上删除边一定是某个结点和 $rt$ 之间。

也就是说无论我们按怎样的顺序删边，最后都会变成一个环。

我做了一个动图演示，如果洛谷博客不支持gif的话就直接到这个网址 [Click Here](https://i.loli.net/2020/03/15/fuU4CgWReOT8X2d.gif)

![point.gif](https://i.loli.net/2020/03/15/fuU4CgWReOT8X2d.gif)

有了环这个结论，就有一个很显然的贪心构造环的方法：

按照 $1,2,\cdots,n$ 的顺序每个数字选择环上自己的下一个点。

在编写代码的时候还需要注意还没有连到 $Y_{n}$ 就提前~~自毙~~~~自闭~~封闭的情况。

```cpp
namespace SubtaskAss { // 菊花的单词太长了，就取了个差不多的/xyx
	bool vis[MAXN];
	int ans[MAXN];
	struct UninoFindSet {
		int fa[MAXN];

		void init(int limit) {
			for (R int i = 1; i <= limit; ++i)
				fa[i] = i;
		}

		int find(int x) {
			if (x ^ fa[x]) fa[x] = find(fa[x]);
			return fa[x];
		}

		void merge(int x, int y) {
			x = find(x);
			y = find(y);
			if (x ^ y) fa[x] = y;
		}
	} ufs;

	void main() {
		ufs.init(n);
		for (R int i = 1; i <= n; ++i) vis[i] = 0;
		for (R int i = 1; i <= n; ++i) {
			for (R int j = 1; j <= n; ++j) {
				if (!vis[j] && (i == n || ufs.find(j) != ufs.find(id[i]))) {
					vis[j] = 1;
					ans[i] = j;
					ufs.merge(j, id[i]);
					break;
				}
			}
		}
		for (R int i = 1; i <= n; ++i) printf("%d ", ans[i]);
		puts("");
	}
}
```

## part 3

>链的部分分

说实话链的部分分其实也挺好拿的，但是还是比菊花图难想一些。

首先，用dfs序把链拍成树是固定操作了。

链有一个性质，就是每个结点(两端点除外)的度数都有且只有二。

也就是说除端点外，每个结点都有两条边。而且这两条边的被删除时间一定不一样（废话

也就是说每个结点的两条边被删除的情况一共有三种。

我们定义 $order_{i}$ 为结点 $i$ 的左右两边的删除情况：

- 0：0表示这个结点的左右边都还没被删除
- 1：1表示这个结点的左边先被删除
- 2：2表示这个结点的右边先被删除

现在我们假设左边的结点 $u$ 要跑到右边的结点 $v$ 那里去，那么在 $u$ 和 $v$ 之间的结点一定是左边先被删除，所以 $order_i=1,i\in (u,v)$

对于 $u$ 和 $v$ 两个结点，一定是右边先被删除，否则就不知道跑哪里去了

所以 $order_{u}=order_{v}=2$

至于从右跑到左就完全同理了。

答案则同样是从小枚举到大(我是从小枚举到大的/xyx)

比如说我们当前枚举到了结点 $x$，我们希望它能去尽量小的一个点

假设当前 $x$ 在 $P_{x}$，我们直接暴力枚举一个 $P_{y}$。

判断一个方案是否可行只需要判断它与前面的删边顺序冲突即可。

这样做是 $\Theta(N^3)$ 的。我们可以在dfs的时候标记，这样就是 $\Theta(n^2)$ 了。

```cpp
namespace SubtaskChain {
	int rnk[MAXN], ans[MAXN], dfn[MAXN];
	int sbc_tot, order[MAXN], vis[MAXN];

	void dfs(int x, int fa) {
		rnk[dfn[x] = ++sbc_tot] = x;
		for (R int i = head[x]; i; i = nxt[i])
			if (to[i] ^ fa) dfs(to[i], x);
	}

	void mark_node(int p1, int p2, int tg) {
		if (p1 != 1 && p1 != n) order[p1] = tg + 1;
		if (p2 != 1 && p2 != n) order[p2] = tg + 1;
		for (R int i = (tg ? p1 + 1 : p2 + 1); i < (tg ? p2 : p1); ++i) order[i] = ((tg ^ 1) + 1);
	}

	int iterate(int x, int tg) {
		int res = n + 1;
		if (order[dfn[x]] == tg + 1) return res;
		for (R int i = dfn[x] + (tg ? -1 : 1); tg ? (i >= 1) : (i <= n); i += (tg ? -1 : 1)) {
			if (order[i] == (tg ^ 1) + 1) {
				if (!vis[i]) res = min(res, rnk[i]);
				break;
			}
			if (!order[i] && !vis[i]) res = min(res, rnk[i]);
		}
		return res;
	}
    int inver_id[MAXN];
	void main() {
		for (R int i = 1; i <= n; ++i) rnk[i] = 0;
		for (R int i = 1; i <= n; ++i) dfn[i] = 0;
		for (R int i = 1; i <= n; ++i) vis[i] = 0;
		for (R int i = 1; i <= n; ++i) order[i] = 0;
		for (R int i = 1; i <= n; ++i) inver_id[id[i]] = i;
		sbc_tot = 0;
		for (R int i = 1; i <= n; ++i) {
			if (in[i] == 1) {
				dfs(i, 0);
				break;
			}
		}
		for (R int i = 1; i <= n; ++i) {
			int left = iterate(inver_id[i], 1);
			int right = iterate(inver_id[i], 0);
			if (left < right) mark_node(dfn[inver_id[i]], dfn[left], 0);
			else left = right, mark_node(dfn[inver_id[i]], dfn[left], 1);
			ans[i] = left;
			vis[dfn[left]] = 1;
		}
		for (R int i = 1; i <= n; ++i) printf("%d ", ans[i]);
		puts("");
	}
}
```

## Part 4

>正解

~~拼凑出的正解~~

（我能说这剩下的40pts我看题解都看了半天吗）

剩下的40pts是我看了这篇题解才会的[Click Here](https://www.luogu.com.cn/blog/wucstdio/solution-p5659)

其实会了链的数据基本就离成功不远了。

仔细想想，我们在处理链的时候，规定了与一个结点的边的删除顺序的数值。

如果放到一般的情况来看，我们可以确定一个类似于拓扑序的删除顺序，即某一条边需要在某一条边删除过后才能被删除。

比如下图：

![889V74.jpg](https://s1.ax1x.com/2020/03/15/889V74.jpg)

当我们把这一删除顺序写出来，就可以发现这其实构成了一个链。

对吧！对吧！

假设我们现在需要把 $x$ 删到 $y$ 结点上。

那么判断法则如下：

#### 不合法的情况：

- 有一个数已经从 $x$ 出去过了
- 有一个数已经到过 $y$ 这里了
- 有一个数从相同方向过了 $x$ 的一条出边
- 有一个数从相同方向过了 $y$ 的一条出边
- 出/入边任意一条被别的数字从相同方向走了一次
- 加上当前数构成的链 $x$ 有任意一边出边不在上面
- 加上当前数构成的链 $y$ 有任意一边出边不在上面
- 加上当前数后，经过 $x$ 的数字自闭了(形成了一个环)
- 加上当前数后，形成了一条链，$x$ 有任意一条出边不在上面

#### 合法的情况

- 排除以上所有情况即合法

直接贪心会死得很惨烈。

我们可以通过dfs找出编号最小的作为本轮的答案。

```cpp
namespace SubtaskRandom {
	int mark[MAXN][MAXN], inver_id[MAXN];
	int lave_unwalked[MAXN], fa[MAXN];
	int lave_in[MAXN], lave_out[MAXN];
	int node_from[MAXN], node_to[MAXN];
	int header[MAXN][MAXN], footer[MAXN][MAXN];
	bool vis[MAXN];

	void dfs(int x, int rt) {
		for (R int i = head[x]; i; i = nxt[i]) {
			int y = to[i];
			if (y ^ fa[x]) {
				fa[y] = x;
				vis[y] = 1;
				if (x ^ rt) {
					if (mark[x][y] == x || mark[fa[x]][x] == fa[x]) vis[y] = 0;
					if (mark[x][y] == 0 || mark[fa[x]][x] == 0) vis[y] = 0;
					if (header[x][fa[x]] == node_to[x] && footer[x][y] == node_from[x]
						&& lave_out[x] + lave_in[x] + (lave_unwalked[x] << 1) > 2) vis[y] = 0;
					if (footer[x][y] == fa[x]) vis[y] = 0;
				}
				else {
					if (mark[x][y] == x) vis[y] = 0;
					if (mark[x][y] == 0) vis[y] = 0;
					if (node_from[x]) {
						if (footer[x][y] == node_from[x] && lave_unwalked[x] + lave_in[x] + lave_out[x] != 1)
							vis[y] = 0;
					}
				}
				vis[y] &= vis[x];
				dfs(y, rt);
			}
		}
		if (rt ^ x) {
			if (node_from[x]) vis[x] = 0;
			if (node_to[x]) {
				if (footer[x][node_to[x]] == fa[x] && lave_unwalked[x] + lave_in[x] + lave_out[x] != 1)
					vis[x] = 0;
			}
		}
		else {
			vis[x] = 0;
		}
	}

	void main() {
		for (R int i = 1; i <= n; ++i) node_from[i] = 0;
		for (R int i = 1; i <= n; ++i) node_to[i] = 0;
		for (R int i = 1; i <= n; ++i) lave_in[i] = 0;
		for (R int i = 1; i <= n; ++i) lave_out[i] = 0;
		for (R int i = 1; i <= n; ++i) lave_unwalked[i] = 0;
		for (R int i = 1; i <= n; ++i) inver_id[id[i]] = i;
		for (R int i = 1; i < n; ++i) {
			lave_unwalked[nodes[i].x]++;
			lave_unwalked[nodes[i].y]++;
			mark[nodes[i].x][nodes[i].y] = -1;
			mark[nodes[i].y][nodes[i].x] = -1;
			header[nodes[i].x][nodes[i].y] = nodes[i].y;
			header[nodes[i].y][nodes[i].x] = nodes[i].x;
			footer[nodes[i].x][nodes[i].y] = nodes[i].y;
			footer[nodes[i].y][nodes[i].x] = nodes[i].x;
		}
		for (R int i = 1; i <= n; ++i) {
			for (R int j = 1; j <= n; ++j) fa[j] = 0;
			vis[inver_id[i]] = 1;
			dfs(inver_id[i], inver_id[i]);
			int res = 0;
			for (R int j = 1; j <= n; ++j) {
				if (vis[j]) {
					res = j;
					break;
				}
			}
			printf("%d ", res);
			node_from[res] = fa[res];
			while (fa[res] ^ inver_id[i]) {
				if (~mark[fa[res]][res]) {
					mark[fa[res]][res] = mark[res][fa[res]] = 0;
					lave_in[res]--;
					lave_out[fa[res]]--;
				}
				else {
					mark[fa[res]][res] = mark[res][fa[res]] = fa[res];
					lave_unwalked[res]--;
					lave_out[res]++;
					lave_unwalked[fa[res]]--;
					lave_in[fa[res]]++;
				}
				int t = res;
				res = fa[res];
				header[res][footer[res][t]] = header[res][fa[res]];
				footer[res][header[res][fa[res]]] = footer[res][t];
			}
			if (~mark[fa[res]][res]) {
				mark[fa[res]][res] = 0;
				mark[res][fa[res]] = 0;
				lave_in[res]--;
				lave_out[inver_id[i]]--;
			}
			else {
				mark[fa[res]][res] = fa[res];
				mark[res][fa[res]] = fa[res];
				lave_unwalked[res]--;
				lave_out[res]++;
				lave_unwalked[inver_id[i]]--;
				lave_in[inver_id[i]]++;
			}
			node_to[inver_id[i]] = res;
		}
		puts("");
	}
}
```

完整代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

char buf[1 << 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is() (ch >= '0' && ch <= '9')
#define R register

template < class Type >
void read(Type& a) {
	a = 0; bool f = 0; char ch;
	while (!(ch = gc(), is())) if (ch == '-') f = 1;
	while (is()) a = (a << 3) + (a << 1) + (ch ^ '0'), ch = gc();
	a = (f ? -a : a);
}

template < class Type, class... Args >
void read(Type& t, Args&... args) {
	read(t), read(args...);
}

const int MAXN = 2000 + 5;
int T, n, max_in, id[MAXN];
int head[MAXN], nxt[MAXN << 1];
int tot, in[MAXN], to[MAXN << 1];
struct EdgeNode {
	int x, y;
} nodes[MAXN];

EdgeNode make_edge(int x, int y) {
	EdgeNode res;
	res.x = x;
	res.y = y;
	return res;
}

void add(int x, int y) {
	to[++tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
}

namespace SubtaskForce {
	int cmp[MAXN], ans[MAXN];
	bool vis[MAXN];
	void dfs(int now) {
		if (now == n) {
			for (R int i = 1; i <= n; ++i) cmp[id[i]] = i;
			for (R int i = 1; i <= n; ++i) {
				if (cmp[i] < ans[i]) {
					for (R int j = 1; j <= n; ++j) ans[j] = cmp[j];
					break;
				}
				if (cmp[i] > ans[i]) break;
			}
			return ;
		}
		for (R int i = 1; i < n; ++i) {
			if (!vis[i]) {
				vis[i] = 1;
				swap(id[nodes[i].x], id[nodes[i].y]);
				dfs(now + 1);
				swap(id[nodes[i].x], id[nodes[i].y]);
				vis[i] = 0;
			}
		}
	}

	void main() {
		for (R int i = 1; i <= n; ++i) vis[i] = 0;
		for (R int i = 1; i <= n; ++i) ans[i] = n - i + 1;
		dfs(1);
		for (R int i = 1; i <= n; ++i) printf("%d ", ans[i]);
		puts("");
	}
}

namespace SubtaskAss {
	bool vis[MAXN];
	int ans[MAXN];
	struct UninoFindSet {
		int fa[MAXN];

		void init(int limit) {
			for (R int i = 1; i <= limit; ++i)
				fa[i] = i;
		}

		int find(int x) {
			if (x ^ fa[x]) fa[x] = find(fa[x]);
			return fa[x];
		}

		void merge(int x, int y) {
			x = find(x);
			y = find(y);
			if (x ^ y) fa[x] = y;
		}
	} ufs;

	void main() {
		ufs.init(n);
		for (R int i = 1; i <= n; ++i) vis[i] = 0;
		for (R int i = 1; i <= n; ++i) {
			for (R int j = 1; j <= n; ++j) {
				if (!vis[j] && (i == n || ufs.find(j) != ufs.find(id[i]))) {
					vis[j] = 1;
					ans[i] = j;
					ufs.merge(j, id[i]);
					break;
				}
			}
		}
		for (R int i = 1; i <= n; ++i) printf("%d ", ans[i]);
		puts("");
	}
}

namespace SubtaskChain {
	int rnk[MAXN], ans[MAXN], dfn[MAXN];
	int sbc_tot, order[MAXN], vis[MAXN];

	void dfs(int x, int fa) {
		rnk[dfn[x] = ++sbc_tot] = x;
		for (R int i = head[x]; i; i = nxt[i])
			if (to[i] ^ fa) dfs(to[i], x);
	}

	void mark_node(int p1, int p2, int tg) {
		if (p1 != 1 && p1 != n) order[p1] = tg + 1;
		if (p2 != 1 && p2 != n) order[p2] = tg + 1;
		for (R int i = (tg ? p1 + 1 : p2 + 1); i < (tg ? p2 : p1); ++i) order[i] = ((tg ^ 1) + 1);
	}

	int iterate(int x, int tg) {
		int res = n + 1;
		if (order[dfn[x]] == tg + 1) return res;
		for (R int i = dfn[x] + (tg ? -1 : 1); tg ? (i >= 1) : (i <= n); i += (tg ? -1 : 1)) {
			if (order[i] == (tg ^ 1) + 1) {
				if (!vis[i]) res = min(res, rnk[i]);
				break;
			}
			if (!order[i] && !vis[i]) res = min(res, rnk[i]);
		}
		return res;
	}
    int inver_id[MAXN];
	void main() {
		for (R int i = 1; i <= n; ++i) rnk[i] = 0;
		for (R int i = 1; i <= n; ++i) dfn[i] = 0;
		for (R int i = 1; i <= n; ++i) vis[i] = 0;
		for (R int i = 1; i <= n; ++i) order[i] = 0;
		for (R int i = 1; i <= n; ++i) inver_id[id[i]] = i;
		sbc_tot = 0;
		for (R int i = 1; i <= n; ++i) {
			if (in[i] == 1) {
				dfs(i, 0);
				break;
			}
		}
		for (R int i = 1; i <= n; ++i) {
			int left = iterate(inver_id[i], 1);
			int right = iterate(inver_id[i], 0);
			if (left < right) mark_node(dfn[inver_id[i]], dfn[left], 0);
			else left = right, mark_node(dfn[inver_id[i]], dfn[left], 1);
			ans[i] = left;
			vis[dfn[left]] = 1;
		}
		for (R int i = 1; i <= n; ++i) printf("%d ", ans[i]);
		puts("");
	}
}

namespace SubtaskRandom {
	int mark[MAXN][MAXN], inver_id[MAXN];
	int lave_unwalked[MAXN], fa[MAXN];
	int lave_in[MAXN], lave_out[MAXN];
	int node_from[MAXN], node_to[MAXN];
	int header[MAXN][MAXN], footer[MAXN][MAXN];
	bool vis[MAXN];

	void dfs(int x, int rt) {
		for (R int i = head[x]; i; i = nxt[i]) {
			int y = to[i];
			if (y ^ fa[x]) {
				fa[y] = x;
				vis[y] = 1;
				if (x ^ rt) {
					if (mark[x][y] == x || mark[fa[x]][x] == fa[x]) vis[y] = 0;
					if (mark[x][y] == 0 || mark[fa[x]][x] == 0) vis[y] = 0;
					if (header[x][fa[x]] == node_to[x] && footer[x][y] == node_from[x]
						&& lave_out[x] + lave_in[x] + (lave_unwalked[x] << 1) > 2) vis[y] = 0;
					if (footer[x][y] == fa[x]) vis[y] = 0;
				}
				else {
					if (mark[x][y] == x) vis[y] = 0;
					if (mark[x][y] == 0) vis[y] = 0;
					if (node_from[x]) {
						if (footer[x][y] == node_from[x] && lave_unwalked[x] + lave_in[x] + lave_out[x] != 1)
							vis[y] = 0;
					}
				}
				vis[y] &= vis[x];
				dfs(y, rt);
			}
		}
		if (rt ^ x) {
			if (node_from[x]) vis[x] = 0;
			if (node_to[x]) {
				if (footer[x][node_to[x]] == fa[x] && lave_unwalked[x] + lave_in[x] + lave_out[x] != 1)
					vis[x] = 0;
			}
		}
		else {
			vis[x] = 0;
		}
	}

	void main() {
		for (R int i = 1; i <= n; ++i) node_from[i] = 0;
		for (R int i = 1; i <= n; ++i) node_to[i] = 0;
		for (R int i = 1; i <= n; ++i) lave_in[i] = 0;
		for (R int i = 1; i <= n; ++i) lave_out[i] = 0;
		for (R int i = 1; i <= n; ++i) lave_unwalked[i] = 0;
		for (R int i = 1; i <= n; ++i) inver_id[id[i]] = i;
		for (R int i = 1; i < n; ++i) {
			lave_unwalked[nodes[i].x]++;
			lave_unwalked[nodes[i].y]++;
			mark[nodes[i].x][nodes[i].y] = -1;
			mark[nodes[i].y][nodes[i].x] = -1;
			header[nodes[i].x][nodes[i].y] = nodes[i].y;
			header[nodes[i].y][nodes[i].x] = nodes[i].x;
			footer[nodes[i].x][nodes[i].y] = nodes[i].y;
			footer[nodes[i].y][nodes[i].x] = nodes[i].x;
		}
		for (R int i = 1; i <= n; ++i) {
			for (R int j = 1; j <= n; ++j) fa[j] = 0;
			vis[inver_id[i]] = 1;
			dfs(inver_id[i], inver_id[i]);
			int res = 0;
			for (R int j = 1; j <= n; ++j) {
				if (vis[j]) {
					res = j;
					break;
				}
			}
			printf("%d ", res);
			node_from[res] = fa[res];
			while (fa[res] ^ inver_id[i]) {
				if (~mark[fa[res]][res]) {
					mark[fa[res]][res] = mark[res][fa[res]] = 0;
					lave_in[res]--;
					lave_out[fa[res]]--;
				}
				else {
					mark[fa[res]][res] = mark[res][fa[res]] = fa[res];
					lave_unwalked[res]--;
					lave_out[res]++;
					lave_unwalked[fa[res]]--;
					lave_in[fa[res]]++;
				}
				int t = res;
				res = fa[res];
				header[res][footer[res][t]] = header[res][fa[res]];
				footer[res][header[res][fa[res]]] = footer[res][t];
			}
			if (~mark[fa[res]][res]) {
				mark[fa[res]][res] = 0;
				mark[res][fa[res]] = 0;
				lave_in[res]--;
				lave_out[inver_id[i]]--;
			}
			else {
				mark[fa[res]][res] = fa[res];
				mark[res][fa[res]] = fa[res];
				lave_unwalked[res]--;
				lave_out[res]++;
				lave_unwalked[inver_id[i]]--;
				lave_in[inver_id[i]]++;
			}
			node_to[inver_id[i]] = res;
		}
		puts("");
	}
}

signed main() {
	for (read(T); T; --T) {
		read(n);
		for (R int i = 1, x; i <= n; ++i) read(x), id[x] = i;
		for (R int i = 1; i <= n; ++i) head[i] = in[i] = 0;
		tot = 0, max_in = 0;
		for (R int i = 1; i < n; ++i) {
			int x, y;
			read(x, y);
			add(x, y);
			add(y, x);
			++in[x], ++in[y];
			nodes[i] = make_edge(x, y);
			max_in = max(max_in, max(in[x], in[y]));
		}
		if (n <= 10) SubtaskForce::main();
		else if (max_in == n - 1) SubtaskAss::main();
		else if (max_in == 2) SubtaskChain::main();
		else SubtaskRandom::main();
	}
}
```

---

## 作者：LCuter (赞：10)

### $\text{D1T3}$ 树上的数

##### $\text{Descripion}$

给定一棵无根树，树上每个点都有一个数，这些数是一个 $[1,n]$ 的全排列。你需要删除所有的边，每次删边会交换边连接的两个点上的数。删完之后，按照点上的数升序排列，使得最后编号组成的字典序最小。

##### $\text{Solution}$ 

考虑一个贪心，我们只会尽量把最小的数送到编号最小的节点。问题转换为，在树中找到一个可行的编号最小的点。现在我们来探讨判断方案是否可行的方法。

事实上我们只需考虑一个点连出的边的删除顺序即可。接下来我们所说的删边序列指的是某一点相邻边的删边序列，并且这个删边序列一开始并没确定，是通过之后可行的运送方案来逐渐确定每条边的先后顺序的。体现在下文中，你可以认为我们实际上是维护了每一个点的若干个删边序列，初始每个点相邻的每条边都是一个单独的删边序列，每次确定了可行的方案后将删边序列合并。我们分别考虑三种情况：

- 这个点是中间点：

1. 连入这个点的边和连出这个点的边必须在删边序列中是相邻的，否则刚送进来一个数就会被送到其它地方。

2. 如果我们通过这两条边将第一条删除的边和最后一条删除的边连在一起，若此时还有边没加入，那么它无法加入删边序列，因为我们保证了删边序列必须是紧接着删除的。

- 这个点是起始点：

1. 它连出的边必须在删边序列中的第一个，否则它会先被送到其它地方。
2. 如果我们通过这条边确认了删边序列的第一条边，若此时删边序列的最后一条边已确定且与删边序列的第一条边同处于一个确定的删边序列中，那么若有边没加入删边序列，那么它无法加入删边序列，理由同上。

- 这个点是结束点：

1. 它连入的边必须在删边序列中的最后一个，否则它最后会被送到其它地方。
2. 如果我们通过这条边确认了删边序列的最后一条边，若此时删边序列的第一条边已确定且与删边序列的最后一条边同处于一个确定的删边序列中，那么若有边没加入这个删边序列，那么它无法加入删边序列，理由同上。

判断就这么解决了，我们来考虑更新。我们只需将方案路径上的每个点按如下方法处理：

- 这个点是中间点：将这个点连出的边所在的删边序列接到连入的边的删边序列。

- 这个点是起始点：确定这个点的最终删边序列的第一条边。

- 这个点是结束点：确定这个点的最终删边序列的最后一条边。

然后你会发现，维护这个，我们只需要对每个节点相邻的边开个双向链表，这样以上操作都是 $O(1)$ 的。但是直接枚举每个点进行判断总时间复杂度是 $O(n^3)$ 的，我们考虑以当前起始点为根进行 $dfs$ ，若一个点不满足作为中转点的条件，那么它的子树内的点显然也不满足，回溯时判断该点是否可以作为结束点，而且这样做可以很好的利用之前的信息，总时间复杂度为 $O(n^2)$ ，可以通过本题。

##### $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
#define MAXN 2005
using namespace std;
inline int read(){
    REG int x(0);
    REG char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x*10)+(c^48),c=getchar();
    return x;
}

struct Edge{
    int v,nxt;
}ed[MAXN<<1];
int head[MAXN],cnt;
inline void adde(int u,int v){
    ed[++cnt]=(Edge){v,head[u]};
    head[u]=cnt;
}
inline void add(int u,int v){adde(u,v),adde(v,u);}

int T,n;
int p[MAXN]; // 该数字在哪个节点上
int Len[MAXN][MAXN],Fir[MAXN][MAXN],Lst[MAXN][MAXN],Pre[MAXN][MAXN],Suf[MAXN][MAXN];
// Len ( u , v ) => 这条边所在的链表长度
// Fir ( u , v ) => 这条边所在的链表开头
// Lst ( u , v ) => 这条边所在的链表末尾 
// Pre ( u , v ) => 这条边所在的链表前驱
// Suf ( u , v ) => 这条边所在的链表后继 
int S[MAXN],E[MAXN];
// S ( i ) => 这个点的删边序列开头
// E ( i ) => 这个点的删边序列结尾
int Can[MAXN]; // Can ( i ) => 这个点是否可行 
int fa[MAXN]; // fa ( i ) => 这个点在深搜过程中的父亲 
int deg[MAXN]; // deg ( i ) => 这个点相邻的边 
int Fin[MAXN]; // Fin ( i ) => 这个数最终所在的节点 

void Init(){
    cnt=0;
    n=read();
    for(REG int i=1;i<=n;++i) p[i]=read(),S[i]=E[i]=head[i]=0,deg[i]=0;
    for(REG int i=1;i<n;++i){
        int u=read(),v=read();
        add(u,v);
        ++deg[u],++deg[v];
        Len[u][v]=Len[v][u]=1;
        Fir[u][v]=Lst[u][v]=v,Fir[v][u]=Lst[v][u]=u;
        Pre[u][v]=Pre[v][u]=Suf[u][v]=Suf[v][u]=-1;
    }
}

void Find_Node(int now,int Start){
    for(REG int i=head[now];i;i=ed[i].nxt){
        int v=ed[i].v;
        if(v==fa[now]) continue;
        fa[v]=now;
        bool Can_Mid=true; // 这个点可以作为起始点或中间点 
        if(now^Start){ // 中间点 
            if((~Suf[now][fa[now]])||(~Pre[now][v])) Can_Mid=false; // 条件 1 
            if((Fir[now][fa[now]]==Fir[now][v])&&(Suf[now][fa[now]]^v)) Can_Mid=false; 
            if(S[now]==v) Can_Mid=false;
            if(S[now]&&E[now])
                if(Fir[now][fa[now]]==S[now]&&Lst[now][v]==E[now])
                    if((Len[now][fa[now]]+Len[now][v])^deg[now]) Can_Mid=false;
            // 条件 2
        }
        else{ // 起始点 
            if(S[now]&&(S[now]^v)) Can_Mid=false; // 条件 1 
            if(E[now]&&Lst[now][v]==E[now])
                if(Len[now][v]^deg[now]) Can_Mid=false;
            // 条件 2 
            if(~Pre[now][v]) Can_Mid=false;
        }
        if(Can_Mid) Find_Node(v,Start); 
    }
    // 判断结束点 
    Can[now]=true;
    if(now^Start){
        if(E[now]&&(E[now]^fa[now])) Can[now]=false; // 条件 1
        if(S[now]&&Fir[now][fa[now]]==S[now])
            if(Len[now][fa[now]]^deg[now]) Can[now]=false;
        // 条件 2 
    }
    else Can[now]=false; // 只要有删边，这个数就不能待在原位 
}

void Update_Path(int End,int Start){ 
    int last=End;
    E[End]=fa[End];
    End=fa[End];
    while(End^Start&&End){
        if(Fir[End][fa[End]]^Fir[End][last]){

            int it=last;
            while(~it)
                Fir[End][it]=Fir[End][fa[End]],
                Len[End][it]+=Len[End][fa[End]],
                it=Suf[End][it];
            it=fa[End];
            while(~it)
                Lst[End][it]=Lst[End][last],
                Len[End][it]=Len[End][last],
                it=Pre[End][it];
            Suf[End][fa[End]]=last;
            Pre[End][last]=fa[End];
            last=End;
            End=fa[End];
        }
    }
    S[End]=last;
}

int main(){
    T=read();
    while(T--){
        Init();
        for(REG int i=1;i<=n;++i){
            int pos=p[i];
            memset(Can,false,sizeof Can);
            memset(fa,0,sizeof fa);
            Find_Node(pos,pos);
            int Goal(1);
            for(;Goal<=n;++Goal)
                if(Can[Goal]) break;
            Update_Path(Goal,pos);
            Fin[i]=Goal;
        }
        for(REG int i=1;i<n;++i) printf("%d ",Fin[i]);
        printf("%d\n",Fin[n]);
    }
}
```


---

## 作者：2018LZY (赞：6)

[更好的阅读体验](https://blog.csdn.net/qq_42886072/article/details/105294392)

[参考博客](https://www.luogu.com.cn/blog/wucstdio/solution-p5659)

# 前言

过了快半年才来补坑.考试的时候卡在第二题的时间过长了,所以这题只打了个10分暴力.

(那时候的自己实在太嫩了,~~现在也是~~ ).

花了大半天才弄懂题解,QAQ~~~

# 正题

首先,作一个简单的转化:

题目中说删除一条边$(x,y)$即交换端点上的数,我们可以理解为

> 一个连续的行为:$x$上的数跑到$y,y$上的数跑到$x$.

>这样处理可以更加方便地进行贪心求解.



之后,还有一个简单的性质:一个数的**最终所在位置**一定与**开始的**不同且**最后一个位置只有一个数**(~~废话~~)

所以我们可以定义:

> $from[x]$表示最后$x$上的数的来源边(一定是邻边)
>
> $to[x]$表示初始时$x$上的数往那边跑(一定也是邻边)



接着,我们来观察一下删边顺序所导致的结果.



对于度数为2的点:

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nL2FzZTdmcTg5LnBuZw?x-oss-process=image/format,png)

如果先删右再左,可以发现有两个数右移,一个数左移.

实际上,通过这个反向移动的数的来源我们即可确定具体的删边顺序.



**升级版**:菊花图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nLzN5MW05cnlqLnBuZw?x-oss-process=image/format,png)



我们可以发现:数的移动顺序$c_1,c_2,c_3,c_4$,确定了以下情况:

> $to[x]=1(x的数往1方向跑了),from[x]=5(5方向跑来一个数)$,删边顺序为(以邻接点来表示边)$1,2,3,4,5$.

这样如果用邻接点表示边,按删除顺序排序的话,则会出现如下情况:

> $to[x],....,from[x]$.(我们称之为偏序链)

显然,如果这条链不能包含所有的邻边的话就不合法.(我们可以称之为**提前自闭**,这样不能再加入边了)



**具体算法流程**:

以上说明提供了具体的判断非法情况的方法,这些将成为整个算法**最重要**的部分.

有一个显然贪心算法:先把小的数挪到尽量小的位置,且保证不与前面的操作矛盾.



那么这个移动就会包括3类点:

1. 起点$x$
2. 中转点$t$
3. 终点$y$

我们逐类讨论如何合法:

首先,对于路径上的所有有向边都不能重复经过.

具体要求:

1. 起点
   1. 保证不提前自闭.
   2. 数还未选择末位置.(顺序每个数的位置即可保证)
2. 中转点
    	1. 保证不提前自闭.
    	2. 数不能重复经过一条边.($x->y,y->x$).
3. 终点
   1. 保证不提前自闭
   2. 位置还未被占领$(from[y]=0)$



之后,我们用双向链表来维护偏序链.

定义:

> $st[x][y]$表示$(x,y)$这条边所在偏序链的开头
>
> $ed[x][y]$表示$(x,y)$这条边所在偏序链的结尾
>
> 初始化:$st[x][y]=ed[x][y]=y$.(一开始都独立)

之所以这样定义是因为我们还不清楚所有的删除顺序,只能这样来存储信息及确定删除的相对顺序.

![](https://img-blog.csdnimg.cn/20200403171948948.png)

假如移动顺序是这样,那么$(x,u),(u,v),(v,w),(w,y)$依次删除.



这样的话:$st[v][u] \sim ed[v][u]$要接在$st[v][w]\sim ed[v][w]$之后.依次类推.



这样保证了不与前面操作的矛盾(相对位置不变),同时符合移动的要求.



具体看代码吧:(~~我帮不了你了~~):



~~~cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=2010;
void qr(int &x) {
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}
void qw(int x) {
	if(x>9) qw(x/10);
	putchar(x%10+'0');
}
void pr1(int x) {qw(x);putchar(' ');}

int T,n,pos[N],from[N],to[N],st[N][N],ed[N][N],d[N],edge[N][N];
/*一波定义:
pos[i]:i的位置 
from[i]:i上的数从哪边来.
to[i]:i上的数去哪儿
st[x][y],ed[x][y]:(x,y)所在偏序链的开头,结尾.
d[x]:x的剩余度数(一条边看作两条有向边)
edge[x][y]:(x,y)的移动情况: 两个方向都未走(-1),两个方向都走了(0),只从x到y(x),只从y到x(y).()内为具体的值 
*/
struct Edge{int y,next;}a[N<<1]; int len,last[N];
void ins(int x,int y) {
	a[++len]=(Edge){y,last[x]};last[x]=len;
	d[x]+=2; edge[x][y]=-1; st[x][y]=ed[x][y]=y;
}

int res,root,fa[N];//最后达到的位置(贪心取最小),根,father
void dfs(int x) {
	for(int k=last[x],y;k;k=a[k].next) {
		y=a[k].y; if(y==fa[x]) continue;
		fa[y]=x;
		if(edge[x][y]==x||edge[x][y]==0) continue; 
		if(x^root) { //作为中转点的要求
			if(ed[x][y]==from[x]&&st[x][fa[x]]==to[x]&&d[x]>2) continue;//如果走fa[x]~x~y,那么d[x]会缩小2. 这个判断是防止提前自闭
			if(ed[x][y]==fa[x]) continue;//偏序链中不能有重复.
		}
		else {
			if(from[x]) {
				if(ed[x][y]==from[x]&&d[x]>1) continue;
				//如果一定有了from[x],那么这条边必须最后访问(起点要求) 
			}
		}
		dfs(y);
	}
	if(x^root&&!from[x]) {//终点要求 
		if(to[x]&&st[x][fa[x]]==to[x]&&d[x]>1) ;//提前自闭
		else res=min(res,x);//更新选择
	}
}

int main() {
	qr(T); while(T--) {
		qr(n); len=0;
		for(int i=1;i<=n;i++) last[i]=from[i]=to[i]=d[i]=0,qr(pos[i]);
		for(int i=1,x,y;i<n;i++)
			qr(x),qr(y),ins(x,y),ins(y,x);
		for(int i=1;i<=n;i++) {
			int x,y,z;  root=x=pos[i];
			memset(fa+1,0,n<<2);
			res=N; dfs(x);
			from[y=res]=fa[res];//res上的数来自fa[res]
			pr1(y);
			while(fa[y]^x) {
				z=fa[y];
				d[y]--;
				d[z]--;
				if(edge[z][y]==-1)
					 edge[z][y]=edge[y][z]=z;
				else edge[z][y]=edge[y][z]=0;
				st[z][ed[z][y]]=st[z][fa[z]];
				ed[z][st[z][fa[z]]]=ed[z][y];
				y=z;
			}
			d[y]--;
			d[x]--;
			if(edge[x][y]==-1)
				 edge[x][y]=edge[y][x]=x;
			else edge[x][y]=edge[y][x]=0;
			
			to[x]=y;
		}
		puts("");
	}
	return 0;
}
~~~







---

## 作者：minstdfx (赞：2)

## 题解
先特判掉只有一个点的情况。

字典序最小，直接想贪心。必然是先考虑 $1$ 放在一号点，$2$ 放在能放的编号最小的点，以此类推。

显而易见的，如果要把数字 $k$ 从 $s$ 号点运到 $t$ 号点**并且以此为最终状态**，我们删边的顺序一定是按照从 $s$ 到 $t$ 的**路径顺序**，并且在操作点 $u$ 路径上的的前驱 $v_1$ 到 $u$ 的边之后直到操作点 $u$ 后继 $v_2$ 到 $u$ 的边之前，我们是不能动 $u$ 上的**其他**边的。除此之外，最终到达 $t$ 的边一定是所有连接到 $t$ 的边中**最晚**删去的，同理最开始连接 $s$ 的边一定是所有连接到 $s$ 的边中**最早**删去的。

发现限制都是对于同一个点上连接的边而言的。因此每次找能放某个数的最小编号的点时应当对每个点单独考虑限制。既然每轮对于所有路径中间的中转点上的边的限制形如一条边需要是另一条边在这个点上所有边的删边顺序的后继，那么就会形成一堆链（假如合法，否则会出现一条边有两个紧邻后继或紧邻前驱，矛盾了）。而对于所有路径的起点终点的限制其实形如对一个点上的所有链最后合并完成后的链头和链尾的限制。实现上可以考虑用并查集维护每条边属于的链的链头，存储每个链头对应的链尾。

接下来考虑如何判断能到达哪些点。一个点能作为中转点，当且仅当入边为某条链的链尾，出边为某条链的链头，且若当前该点上的链**不少于三条**，且该点删去的第一条和最后一条边都已确定（亦即**最终链的头尾确定**），则它们**不能**分别位于两条要合并的链的头尾（就是说，合并链的过程中不能提前合并出一条头尾分别为最终确定的头尾的链，否则就合并不出最终符合条件的链）。一个点能作为终点，当且仅当不是起点（显然某个数最终不可能在原位上，否则这个点没有任何相邻边，与 $n>1$ 矛盾）、能没有矛盾地到达上一个点且上一个点可以作为中间点、入边可以作为最后一条被删除的边。

根据上述条件找出所有可能的终点，取编号最小的，并维护新的限制即可。

时间复杂度 $\Theta(n^2\log n)$，因为并查集必须按顺序合并。如果使用链表可以做到 $\Theta(n^2)$。
## 部分分
我不会做！  
~~不会做这种题可以选择倒闭。~~  
### subtask#1 $n\le 10$
我会暴力！  
直接枚举排列模拟判断即可。
### subtask#4, #5 $n\le 2000$，菊花
是一个置换环。
贪心枚举判断不成环即可。
### subtask#2, #3 $n\le 2000$，链
区间问题。  
限制形如某点的某条边需要比另一条先删。  
直接做。

---

## 作者：Zory (赞：2)


搬运自[个人博客](https://zory.ink/posts/1634d012.html)

考虑一个数从x想恰当地移动到y，直接去移动是不行的，这时候一种很有用的思路就是考虑究竟带来了**哪些限制条件**

**第一条边必须是与x相连的边中第一个被删的，最后一条边必须是与y相连的边中最后一个被删的，而且对于中转节点t的路径上两条边，一定是一条紧接着另一条被删除（注意以上所有的时间，都是以公共点作为参考系而相对的）**

想出这点（本质上就是将每个点作为参考系后限制独立）后基本上就做完了，从小到大枚举每个数字按位确定，在树上dfs找到能去的编号最小节点，边走边判断我新增加的限制是否会导致【对于每个点相邻的边，隐式建图后是若干条链】的性质被破坏（显然是能构造出方案的充要条件），因为是一棵树我们中途判断限制的时候并不需要做修改，因为这个参考系在本轮dfs中不需要再考虑了，关于这部分怎么写代码中有注释

此时你可能产生我当时的一个小疑问：我们的这个check一定能保证以后不会出现【某个数没点可去导致边删不完】的问题吗？搞个并查集维护链的大小（其实在确保不会成环的时候已经要写并查集了），用siz确保合并的时候不会导致一条链过早形成（因为本题是对最后链的头尾有具体限制的）

讲道理这个 **大致思路（即不说上述具体实现）** 如果告诉我是对的，我能很好理解其正确性，但如果我自己想出来，大概会被我莫名叉掉，因为感觉正确性并不显然

具体实现的话，其实认真思考好细节不算多，可以一遍通过

```cpp
//自认为比较简洁的code
int fir[N],lst[N];//链头、链尾，链表编号统一用从父亲到孩子的
struct Edge{int x,y,g,gl,gr;}e[N];int hou[N],deg[N];
int ln;void ins(int x,int y){e[++ln]=(Edge){x,y,hou[x],0,0};hou[x]=ln;}
int solve(int x,int fa,int fm)//fm=(x->fa)
{
    int ret=INF;
    for(int k=hou[x];k;k=e[k].g)
    {
        int y=e[k].y;if(y==fa)continue;
        if(fm>=0)//k紧接着fm
        {
            if(fir[x]==k or lst[x]==fm) continue;
            if(e[fm].gr==k and e[k].gl==fm) ;
            else
            {
                if(e[fm].gr or e[k].gl) continue;
                int fx=dsu.findfa(fm),fy=dsu.findfa(k);
                if(fx==fy) continue;
                if(fir[x] and lst[x] and dsu.findfa(fir[x])==fx and dsu.findfa(lst[x])==fy
                    and dsu.siz[fx]+dsu.siz[fy]<deg[x]) continue;//链过早形成
            }
        }
        else
        {
            int tt=dsu.findfa(k);
            if(lst[x] and dsu.findfa(lst[x])==tt and dsu.siz[tt]<deg[x]) continue;
            if(e[k].gl) continue;
        }
        //看做终点
        if((!lst[y] and !e[k^1].gr) or lst[y]==(k^1))
        {
            int tt=dsu.findfa(k^1);
            if(fir[y] and dsu.findfa(fir[y])==tt and dsu.siz[tt]<deg[y]) ;
            else chmin(ret,y);
        }
        //看做中转点
        chmin(ret,solve(y,x,k^1));
    }return ret;
}
bool modify(int x,int fa,int to,int fm)
{
    if(x==to){lst[x]=fm;return 1;}
    for(int k=hou[x];k;k=e[k].g)
    {
        int y=e[k].y;if(y==fa)continue;
        if(modify(y,x,to,k^1))
        {
            if(fm>=0) e[fm].gr=k,e[k].gl=fm,dsu.merg(fm,k);
            else fir[x]=k;
            return 1;
        }
    }
    return 0;
}
int pos[N];
void main()
{
    int T=qread();
    while(T--)
    {
        int n=qread();fo(i,1,n) pos[i]=qread(),hou[i]=fir[i]=lst[i]=deg[i]=0;dsu.clear();
        ln=1;fo(i,1,n-1){int x=qread(),y=qread();ins(x,y),ins(y,x);deg[x]++,deg[y]++;}
        fo(num,1,n)
        {
            int x=pos[num];
            int mi=solve(x,0,-1);GG(mi!=INF);
            modify(x,0,mi,-1);write1(mi);
        }puts("");
    }
}
```
[完整code](https://zory.ink/code/cspD1T3.html)

---

## 作者：PhantasmDragon (赞：2)

既然是字典序，不妨考虑贪心。

显然小的数字要尽量移到编号小的点上。

这个做法的主要问题就是要解决之前安排好的数字对当前数字的影响。

在一条数字走的路径被确定之后，会对路径上的边产生一系列限制。
![](https://leanote.com/api/file/getImage?fileId=5dd51348ab644109b0001917)

考虑把上图中1号点上的数字换到6号点。

对于起点 $1$ 号点，如果我们想把原来在它上面的数字换到 $6$ 号点，显然与这个点相连的，第一个需要被删掉的边就是边 $A$. 如果其他边比 $A$ 先删除，那么原来在 $1$ 号点上面的数字就会被移走，而且无法再移动回来。

对于路径上的点，比如 $5$ 号点，边 $E$ 必须紧跟在边 $D$ 后删除，否则在删除 $E$, 数字被移动到 $5$ 号点的时候，中途就会有其他边被删除，导致这个数字被移到其他点而永远无法到达目的地 $6$ 号点。

对于终点6号点，与起点同理， $E$ 必须是在与 $6$ 相连的边中最后一个被删除的。

在分析完上面的限制之后，我们发现，对于与一个点，所有与它相连的边会产生一些限制关系：

1.某条边必须是最先被删除的(记为 $fi$ )

2.某条边必须是最后被删除的(记为 $la$ )

3.某条边 $E_1$ 必须紧跟在某条边 $E_2$ 之后被删除(看作一条从 $E_2$ 连向 $E_1$ 的边)

对于每一个树上节点，我们都会得到一个新图，称为限制图，每一条与这个树上节点相连的边在这个图中都会被转化为一个点。 每个点的限制图是互不影响的。

显然，在任何时候，如果对于某个节点的限制图中出现以下任何情况，则不合法

1.限制图的形态不是一条或多条链。

2.有边连向 $fi$ 或者 $la$ 有边连出。

3.$fi$ 和 $la$ 已经确定且形成了一条从 $fi$ 到 $la$ 的链，且链里没有包含限制图中的所有点。(每条边必须删除，也就是限制图中的所有点最终必须形成一条链，如果出现了这样的链，其他点就接不到到这条链上去了)

维护以上限制条件可以使用并查集判环，记录每个点出度和入度是否已经为1，再记下 $fi$ 和 $la$即可。

对于一个数字 $x$ 找它能到的编号最小的点，可以以数字 $x$ 所在的点为根dfs一遍树，边走边看这样走是否非法，找到能到达的最小的点，非法了停下即可。

找到最小点之后再dfs一遍，更新路径上每个点的限制图信息即可。

----------
贴上代码
```
#include<bits/stdc++.h>
#define maxn 2005
using namespace std;
struct node
{
	int fa[maxn],nex[maxn],notrt[maxn];//全部边的编号都除以二 
	int getf(int x) {return fa[x]==x?x:fa[x]=getf(fa[x]);}
	int fi,la,cc;
}pt[maxn];
int pre[maxn<<1],to[maxn<<1],las[maxn],inc=1;
void ins(int a,int b)
{
	pre[++inc]=las[a];
	las[a]=inc,to[inc]=b;
}
int nump[maxn],lk[maxn],n;
int getmin(int x,int la)
{
	int ret=1e9,tmp;
	if(la)
	{
		if(!pt[x].la||la/2==pt[x].la)
		{
			if(!pt[x].nex[la/2]&&(!pt[x].fi||(pt[x].getf(la/2)!=pt[x].getf(pt[x].fi))||pt[x].cc==1)) ret=min(ret,x),lk[x]=0;
		}
	}
	for(int i=las[x];i;i=pre[i])
	{
		int y=to[i]; if(la/2==i/2) continue;
		if(!la&&(!pt[x].fi||pt[x].fi==i/2))
		{
			if(!pt[x].la||(pt[x].getf(i/2)!=pt[x].getf(pt[x].la))||pt[x].cc==1)
			{
				if(pt[x].notrt[i/2]) continue;
				tmp=getmin(y,i);
				if(tmp<ret) ret=tmp,lk[x]=y;				
			}
		}
		else
		{
			if(la/2==pt[x].la||i/2==pt[x].fi||pt[x].getf(la/2)==pt[x].getf(i/2)||pt[x].nex[la/2]||pt[x].notrt[i/2]) continue;
			if(!pt[x].la||!pt[x].fi)
			{
				tmp=getmin(y,i);
				if(tmp<ret) ret=tmp,lk[x]=y;	
			}
			else
			{
				int fx=pt[x].getf(la/2),fy=pt[x].getf(i/2);
				int ffx=pt[x].getf(pt[x].fi),ffy=pt[x].getf(pt[x].la);
				if(fx>fy) swap(fx,fy); if(ffx>ffy) swap(ffx,ffy);
				if((ffx!=fx||ffy!=fy)||pt[x].cc==2)
				{
					tmp=getmin(y,i);
					if(tmp<ret) ret=tmp,lk[x]=y;
				}
			}
		}
	}
	return ret;
}
void update(int x,int la)
{
	if(!lk[x])
	{
		pt[x].la=la/2;
		return;
	}
	for(int i=las[x];i;i=pre[i])
	{
		int y=to[i]; if(y!=lk[x]) continue;
		if(!la) pt[x].fi=i/2;
		else
		{
			pt[x].fa[pt[x].getf(la/2)]=pt[x].getf(i/2);
			pt[x].notrt[i/2]=1,pt[x].nex[la/2]=i/2;
			pt[x].cc--;
		}
		update(y,i); 
	}
}
void Init()
{
	for(int i=1;i<=n;i++)
	{
		las[i]=0;
		memset(pt[i].fa,0,sizeof(pt[i].fa));
		memset(pt[i].notrt,0,sizeof(pt[i].notrt));
		memset(pt[i].nex,0,sizeof(pt[i].nex));
		pt[i].cc=pt[i].fi=pt[i].la=0;
	}
	inc=1;
}
int T;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		Init();
		for(int i=1;i<=n;i++) scanf("%d",&nump[i]); 
		for(int i=1,u,v;i<n;i++) scanf("%d%d",&u,&v),ins(u,v),ins(v,u);
		for(int x=1;x<=n;x++)
			for(int i=las[x];i;i=pre[i])
				pt[x].fa[i/2]=i/2,pt[x].cc++;
		for(int now=1;now<=n;now++)
		{
			printf("%d ",getmin(nump[now],0));
			update(nump[now],0);
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：wyd_forever (赞：1)

咕题解来了~ ~ ~  
  
其实应该还是能~~比较容易地~~找到规律的吧  

目标肯定是尽量把最小的数字给转移到最小的编号上，而且转移的方案（即转移路线）有且仅有一个。既然如此，就容易联想到贪心了：每次从最小的数字的数字出发找到能到达的最小节点，将其输出，再将路线记录下来  

因为如果由于前面的路线使得当前路线不成立，那么当前路线一定不是最优路线，故贪心肯定是合法的  

接下来考虑贪心的性质:
~~很容易~~可以想到一条路径应当划分为初始节点（初点）,初点所连的在该路径上的边（初边），路径上的其它边（途边）与点（途点），以及末点与末边：
1. 对于初边，它应当是初点的第一条被删的边，否则必定无法达成目标，所以任何一个点有且仅有一个初边
2. 对于末边，它应当是末点的最后一条被删边，否则必定无法达成目标，同样任何一个点有且仅有一个末边
3. 对于途边，如果有另一条同一路径上的途边与其连接在同一个途点上，那么对这个途点来说，其所连的所有边的删除顺序中，这两条途边必定是一先一后紧连的，并且一对途边一定只能转运一个数字

所以可以考虑用$st[i](start)$和$en[i](end)$分别记录节点$i$的初边与末边，$pre[i][j]$和$nxt[i][j]$(均为$bool$型)来记录点$i$的边$j$在点$i$连边的删边顺序中是否有连在一起的前驱与后继，以便我们对当前贪心方案的合法性进行判断  

接下来看合法情况是怎样的：  

假设现在我们遍历到了数字$i$的对应节点：
**能将$i$作为初点的条件**：
1. 目前没有初边或初边为当前遍历到的即将作为初边的边（预初边）
2. 预初边在$i$的删除顺序中没有前驱
3. 若预初边与$i$的末边已有直接的删除顺序连接，那么应当$i$的所有边的顺序都已确定（因为要将所有边删完）  

**能将$i$作为途点的条件**：
1. 连接的两条途边分别在$i$无前驱与后继
2. 两条途边没有直接的删除顺序连接
3. 若靠前途边与$i$初边有直接删除顺序连接，靠后途边与$i$末边有直接删除顺序连接，那么应当除这两途边之外所有边的顺序都已确定（因为要将所有边删完）

**能将$i$作为末点的条件**
1. 目前没有末边或末边为当前遍历到的即将作为末边的边（预末边）
2. 预末边在$i$的删除顺序中没有后继
3. 若预末边与$i$的初边已有直接的删除顺序连接，那么应当$i$的所有边的顺序都已确定（因为要将所有边删完）
  

可以发现，前驱与后继都只是需要查看是否有，故仅需对每个点的每条边开个$bool$型数组判断是否有。而每个点的初边与末边我们都是需要知道具体是哪个的，故要对每个点存下这个点的初边与末边编号  

接下来就是一个小问题：是否有直接删除顺序相连。对此，容易想到使用并查集，当两条边确定了在某个点的严格先后顺序之后，将两条边在这个节点的并查集进行合并，同时可以使用并查集查看两条边是否在一个删边系统中  

然后就是最后一个问题：如何确定当前节点删边顺序都已确定？  

首先看删边顺序是怎么确定的：利用途边之间的连接得到一对途边在某一途点的严格先后顺序，然后一段段连接得到完全段。由此我们发现，当前节点的删边顺序是由一个个的严格删边顺序组合成的，而若一个点的删边顺序已完全确定，那么这个点对应得到的严格删边顺序数一定是该点度数减一。于是考虑记录每个点的度数，当确定一对严格删边顺序，度数减一  
  
而当度数仅剩一时则表示该点的所有两边的删边顺序已经确定了

暴力枚举每个点与当前节点是否相通再取$min$的复杂度是$O(n^3)$的，~~我们当然不会这么傻~~，考虑每次以当前节点为根进行$dfs$遍历所有能到的点再取$min$，复杂度降为$O(n^2)$，而每次$dfs$时修改路径上每个点的父亲（$f$）节点，这样在后面更新时会方便一点，直接从末点一个个往上蹦就行了  

由于要开并查集，所以复杂度应当套个$log$，但由于是对每个点的边开并查集，一条边最多开两次，用的次数也很有限，所以总的复杂度应该是$O(Tn^2\alpha n)$，~~怀疑CCF老爷机跑不跑得过~~
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read()
{
	int x=0;char ch=getchar();
	for(;!isalnum(ch);ch=getchar());
	for(;isalnum(ch);ch=getchar()) x=x*10+ch-'0';
	return x;
}

const int xx=2e3+10;

struct node
{
	int fa[xx];
	bool pre[xx],nxt[xx];
	inline void init(int n)
	{
		for(register int i=1;i<=n;++i)
		{
			fa[i]=i;
			pre[i]=nxt[i]=0;
		}
	}
	inline int find(int i)
	{
		return i==fa[i]?i:fa[i]=find(fa[i]);
	}
	inline bool check(int i,int j)
	{
		return find(i)==find(j);
	}
	inline void merge(int i,int j)
	{
		int a=find(i),b=find(j);
		if(a!=b)
			fa[a]=b;
	}
}drop[xx];
int dot[xx],st[xx],en[xx],f[xx],f_l[xx],n;
int hd[xx],to[xx<<1],nt[xx<<1],du[xx],cnt;

inline void init()
{
	cnt=1;
	for(register int i=1;i<=n;++i)
		drop[i].init(n),f[i]=hd[i]=st[i]=en[i]=du[i]=0;
}

inline void add(int u,int v)
{
	nt[++cnt]=hd[u],to[hd[u]=cnt]=v;
	nt[++cnt]=hd[v],to[hd[v]=cnt]=u;
	++du[v],++du[u];
}

inline int dfs(int g,int jt)
{
	int res=xx+1;
	if(jt)
		if(!en[g]||en[g]==jt)
			if(!drop[g].nxt[jt])
				if(!(drop[g].check(jt,st[g])&&st[g]&&du[g]>1))
					res=g;
	for(register int i=hd[g],j;i;i=nt[i])
	{
		j=i>>1;
		if(j==jt)
			continue;
		if(!jt)
		{
			if(!st[g]||st[g]==j)
				if(!drop[g].pre[j])
					if(!(drop[g].check(j,en[g])&&en[g]&&du[g]>1))
						f[to[i]]=g,f_l[to[i]]=j,res=min(res,dfs(to[i],j));
		}
		else
		{
			if(jt!=en[g]&&j!=st[g]&&!drop[g].check(jt,j))
				if(!drop[g].nxt[jt]&&!drop[g].pre[j])
					if(!(du[g]>2&&st[g]&&en[g]&&drop[g].check(st[g],jt)&&drop[g].check(en[g],j)))
						f[to[i]]=g,f_l[to[i]]=j,res=min(res,dfs(to[i],j));
		}
	}
	return res;
}

inline void mate(int g)
{
	int jt;
	jt=en[g]=f_l[g];
	g=f[g];
	while(f[g])
	{
		drop[g].nxt[f_l[g]]=drop[g].pre[jt]=1;
		drop[g].merge(jt,f_l[g]);
		--du[g];
		jt=f_l[g];
		g=f[g];
	}
	st[g]=jt;
}

int main()
{
	int T=read();
	while(T--)
	{
		n=read();
                if(n==1)
                {
                    puts("1");
                    continue;
                }
		init();
		for(register int i=1;i<=n;++i)
			dot[i]=read();
		for(register int i=2,u,v;i<=n;++i)
			u=read(),v=read(),add(u,v);
		for(register int i=1,j;i<=n;++i)
		{
			f[dot[i]]=0;
			j=dfs(dot[i],0);
			mate(j);
			printf("%d ",j);
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：lx_zjk (赞：1)

## 树上的数
 [题面](https://www.luogu.com.cn/problem/P5659)
现在有一棵树，每个点上有一个点权，你切断一条边，就会交换边上两个点的点权，求$1 \to N$点权的最小字典序。

## $\text{subtask1}$ $N \leq 10$
考场上暴力标配，$\Theta(N!)$枚举所有删边顺序，然后取字典序最小的一组。

## $\text{subtask2}$ 存在度数为$N - 1$的节点
存在度数为$N-1$的节点，那么这个图一定是菊花图。

我们设菊花图入度为$N-1$的点为$rt$。

我们每次删边一段必定是$rt$，假设我们删边顺序是$p$，$p_i$表示第$i$次删的点编号。

第$i$次删的边就是$rt -> p_i$。

每次删边，当前$p_i$的点权就确定了，这个性质比较好。

经过几遍模拟，我们发现$a_{p_1}$到了$p_2$，$a_{p_2}$到了$p_3$，$a_{p_{n-1}}$到了$rt$。

这样我们是不是形成了一个环的形式。

$rt->p_1->p_2->p_3...->p_{n-1}->rt$

要想让字典序最小，我们贪心的选择能得到的最小的数字，并且这个环要不能是多个小环。

我们如果想让数字$i$到$j$点的话，那么首先$j$这个点没有用过，并且$j$和$p_i$不在同一个环里(不然形成不了一个大环)。

时间复杂度$\Theta(N^2)$
```cpp
namespace subtask2 {
    int fa[N], ans[N];
    bool vis[N];
    inline int find (int x) {
        return x == fa[x] ? x : fa[x] = find (fa[x]);
    }
    inline void merge (int x, int y) {
        fa[find (x)] = find (y);
    }
    void main () {
        for (int i = 1; i <= n; i ++ ) fa[i] = i, vis[i] = 0;
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= n; j ++ ) {
                if (!vis[j] && (i == n || find (j) != find (p[i]))) {
                    ans[i] = j; vis[j] = 1; merge (j, p[i]);
                    break;
                }
            }
        }
        for (int i = 1; i <= n; i ++ ) printf ("%d%c", ans[i], i == n ? '\n' : ' ');
    }
}
```

## $\text{subtask3}$ 树是一条链 $N \leq 160$
如果想出链的部分分，正解也就不远了。

首先按照菊花图的思路，我们要让数字$i$走向$j$点。

我们规定三类点(正解也要用到)

**1.起点 数字$i$所在的点。**

**2.途经点：从起点到终点路过的那些点。**

**3.终点：$j$点的位置。**

我们先把链$dfs$处理一下，记录链上第$i$个点是$a_i$，$u$点是第$num_u$个。
```CPP
inline void dfs (int u, int f) { 
	a[num[u] = ++ cnt] = u; 
	for (int i = head[u]; i; i = edge[i].nxt) { 
		int v = edge[i].to; 
		if (v == f) continue; 
		dfs (v, u); 
	} 
}
```
首先对于一个点，删边顺序有两种，先删掉左后删右，先删右后删左。

我们用一个$tag$数组表示一下这个点删边顺序。$tag = 0$表示这个点没有标记，$tag = 1$表示先删掉左后删右，$tag = 2$表示先删右后删左。

那么如果我们想让数字$i$走向$j$点的话，我们要分两种情况。
如果$num_{p_i} \leq num_j$ 那么相当于数字$i$向左走。
#### 起点
我们考虑起点$p_i$的删边顺序，$p_i$要往左走，那么必然是先右后左，不然$p_i$上的点就不是$p_i$
#### 途经点
我们考虑途经点，如果$p_i$想往左走，那么必然是先删掉左边然后删掉右边，不然整条路径就断了。
#### 终点
我们考虑终点删边顺序，如果我们先删左后删右的话，那么终点的点就被右边的点替换掉了，所以也要先右后左。

反之$num_{p_i} > num_j$也同理。

然后我们可以对应的打一个$tag$上去。
如果想让数字$i$走向点$j$ 那么就要与先前的$\text{tag}$不重合。

这样时间复杂度为$\Theta (N^3)$ 但是可以过$\text {ccf}$ $N \leq 2000$的数据。

$\Theta (N^3)$的代码
```CPP
namespace subtask3 {
    int cnt, a[N], ans[N], tag[N], num[N];
    bool vis[N];
    inline void dfs (int u, int f) {
        a[num[u] = ++ cnt] = u;
        for (int i = head[u]; i; i = edge[i].nxt) {
            int v = edge[i].to;
            if (v == f) continue;
            dfs (v, u);
        }
    }
//    tag[1] 表示先左后右
//    tag[2] 表示先右后左 
    inline bool check_l (int p1, int p2) { //判断p1->p2的可行性
        if (tag[p1] == 1 || tag[p2] == 1) return false;
        for (int i = p1 + 1; i < p2; i ++ ) if (tag[i] == 2) return false;
        return true;
    }
    inline void push_l (int p1, int p2) { //打标记
        if (p1 != 1 && p1 != n) tag[p1] = 2;
        if (p2 != 1 && p2 != n) tag[p2] = 2;
        for (int i = p1 + 1; i < p2; i ++ ) tag[i] = 1;
        return;
    }
    inline bool check_r (int p1, int p2) {
        if (tag[p1] == 2 || tag[p2] == 2) return false;
        for (int i = p2 + 1; i < p1; i ++ ) if (tag[i] == 1) return false;
        return true;
    }
    inline void push_r (int p1, int p2) {
        if (p1 != 1 && p1 != n) tag[p1] = 1;
        if (p2 != 1 && p2 != n) tag[p2] = 1;
        for (int i = p2 + 1; i < p1; i ++ ) tag[i] = 2;
        return;        
    }
    void main () {
        for (int i = 1; i <= n; i ++ ) tag[i] = vis[i] = 0; cnt = 0;
        for (int i = 1; i <= n; i ++ ) if (in[i] == 1) {dfs (i, 0); break;}
//将数字i移动到j点  
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= n; j ++ ) {
                if (!vis[j] && num[j] != num[p[i]]) {
                    bool flag = false;
                    if (num[p[i]] <= num[j]) {
                        if (check_l (num[p[i]], num[j])) push_l (num[p[i]], num[j]), flag = true;
                    }
                    else {
                        if (check_r (num[p[i]], num[j])) push_r (num[p[i]], num[j]), flag = true;
                    }
                    if (flag) {ans[i] = j; vis[j] = 1;break;}
                }
            }
        }
        for (int i = 1; i <= n; i ++ ) printf ("%d%c", ans[i], i == n ? '\n' : ' ');
    }
}
```

## $\text {subtask4}$ 树是一条链 $N \leq 2000$
那么如何$\Theta (N ^ 2)$解决链的问题呢？

对于数字$i$我们可以$\text{dfs}$遍历整条链找到最小的合法的位置。然后再标记一下。

枚举每一个数字时间复杂度$\Theta (N)$

找点和标记的复杂度$\Theta (N)$

总复杂度$\Theta (N^2)$

```CPP
namespace subtask4 {
    int cnt, a[N], ans[N], tag[N], num[N];
    bool vis[N];
    inline void dfs (int u, int f) {
        a[num[u] = ++ cnt] = u;
        for (int i = head[u]; i; i = edge[i].nxt) {
            int v = edge[i].to;
            if (v == f) continue;
            dfs (v, u);
        }
    }
    inline void push_l (int p1, int p2) { //打标记
        if (p1 != 1 && p1 != n) tag[p1] = 2;
        if (p2 != 1 && p2 != n) tag[p2] = 2;
        for (int i = p1 + 1; i < p2; i ++ ) tag[i] = 1;
        return;
    }
    inline void push_r (int p1, int p2) {
        if (p1 != 1 && p1 != n) tag[p1] = 1;
        if (p2 != 1 && p2 != n) tag[p2] = 1;
        for (int i = p2 + 1; i < p1; i ++ ) tag[i] = 2;
        return;        
    }
    inline int find_l (int u) {
        int res = n + 1;
        if (tag[num[u]] == 2) return res;
        for (int j = num[u] - 1; j >= 1; j -- ) {
            if (tag[j] == 1) {
                if (!vis[j]) res = min (res, a[j]);
                break;
            } 
            if (tag[j] == 0 && !vis[j]) res = min (res, a[j]);
        }
        return res;
    }
    inline int find_r (int u) {
        int res = n + 1;
        if (tag[num[u]] == 1) return res;
        for (int j = num[u] + 1; j <= n; j ++ ) {
            if (tag[j] == 2) {
                if (!vis[j]) res = min (res, a[j]);
                break;
            }
            if (tag[j] == 0 && !vis[j]) res = min (res, a[j]);
        }
        return res;
    }
    void main () {
        for (int i = 1; i <= n; i ++ ) tag[i] = vis[i] = 0; cnt = 0;
        for (int i = 1; i <= n; i ++ ) if (in[i] == 1) {dfs (i, 0); break;}
        for (int i = 1; i <= n; i ++ ) {
            int rt = find_l (p[i]), tp;
            if (rt < (tp = find_r (p[i]))) push_r (num[p[i]], num[rt]);
            else rt = tp, push_l (num[p[i]], num[rt]);
            ans[i] = rt;
            vis[num[rt]] = 1;
        }
        for (int i = 1; i <= n; i ++ ) printf ("%d%c", ans[i], i == n ? '\n' : ' ');
    }
}
```

## $\text{subtask5}$ 树形态任意 $N \leq 2000$
~~fuck 为什么细节这么多~~
我们可以向链$\Theta (N^2)$算法一样考虑，对于一个点，连接它的边，删边必然有顺序，而且每个点的删边顺序互不影响。 我们可以维护一个点的删边顺序集，这个顺序集构成一条链的形式。

我们用并查集维护每个点的删边顺序集，当前点的最先删除的边的序号，最后删除点的边的序号，当前点有多少条边未删除。

$fir_u$为这个点删边集的最先删除的边。

$lst_u$为这个点删边集的最后删除的边。

$pre_p$表示这条边是否有前驱。

$nxt_p$表示这条边是否有后继。

我们还是考虑如何将数字$i$移动到$j$点，还是起点，途经点，终点考虑。

#### 起点
我们考虑起点$p_i$开始存放的是$i$，如果我们有删边的话，那么数字$i$就不会再原位置，说明我们必须让$p_i$走向$j$点的边最先删除。

其次我们要考虑，如果当前点最后删边已经确定$last_u$，如果他们在同一集合，但是还有$>1$，那么说明有点不在删边序列里面，但是$last_u$和起点边在一个集合里面，说明要么有边在起点边前，要么有边在起点边后，否则形成的就不是一条链，但是既然是起点边就不会有比他前的边，终点边也不可能有更后面的边，所以这种情况必定是要排除。

#### 途经点
我们找一个$p_i$到$j$点要经过的点$u$
假设要从$p_i$到$j$点要经过$u$的边$(v,u)$和$(u,w)$设这两条边编号为$p_1$和$p_2$
那么这两条边的编号 一定是连续的，并且先删$p_1$，再删$p_2$，不然到了$u$点的数字$i$就会跑到其他地方去了。

首先如果着两条边已经在同一条关系链里面，因为$p_1$和$p_2$不可能为正确的前后关系，因为树的性质，两两点路径唯一确定。

如果$p2$为删除的起点边，或者$p_1$为删除的终点边，那么必然不合法，不然无法保证$p_1$在$p_2$前面且相邻。

如果$pre_{p_2}$已经确定了，或者$nxt_{p_1}$已经确定了，因为$p_1$和$p_2$不在一个偏序链之中，所以必然不合法。

还有一个就是不能让这条链提前闭合，如果我们已经知道了$fir_u$和$las_u$，并且$fir_u$和$p_1$在同一个集合，$las_u$和$p_2$在同一个集合，那么除非未被删除的点只有两条，否则将$p_1$和$p_2$连在一起，无法形成一条完整的链


#### 终点

终点判断的话只需要他是入边$p$是最后删除的。

如果他要是终点，首先他不能是起点(显然)。

其次终点$u$点的最后删除边$lst_u$要么为$0$(未定义)，要么为$p$，如果有$nxt_p$的话，必然也不能作为终点。

为了防止他提前闭合，如果$fir_u$和$p$在同一个集合里面，那么为加入点的数量必须是$1$(即只有$p$没有加入)。

```CPP
inline  int  dfs (int u, int f) {//f表示上一条边的编号。
	int res = n +  1;
	if (f && (!t[u].lst  ||  t[u].lst  == f) ) {
		if (!t[u].nxt[f] && !(t[u].fir  &&  in[u] >  1  &&  t[u].same (f, t[u].fir)))
			res = u;
	}
	for (int i =  head[u]; i; i =  edge[i].nxt) {
		int v =  edge[i].to, id = i >>  1;
		if (f == id) continue;
		if (!f) {
			if (!t[u].fir  ||  t[u].fir  == id) {
			if (t[u].pre[id]) continue;
			if (t[u].lst  &&  in[u] >  1  &&  t[u].same (t[u].lst, id)) continue;
			chkmin (res, dfs (v, id));
			} else  continue;
	//起点判断
		} else {
	//途经点
			if (t[u].fir  == id ||  t[u].lst  == f ||  t[u].same (id, f)) continue;
			if (t[u].pre[id] ||  t[u].nxt[f]) continue;
			if (t[u].fir  &&  t[u].lst  &&  in[u] >  2  &&  t[u].same (t[u].fir, f) &&  t[u].same (t[u].lst, id)) continue;	
			chkmin (res, dfs (v, id));
		}
	}
	return res;
}
```

然后我们既然找到了终点$i$，接下来就是愉快的删除操作了。
```CPP
inline bool push (int u, int f, int ed) {
	if (u == ed) {
		t[u].lst = f;
		return true;
	}
	for (int i = head[u]; i; i = edge[i].nxt) {
		int v = edge[i].to, id = i >> 1;
		if (id == f) continue;
		if (push (v, id, ed)) {
			if (!f) {
				t[u].fir = id;
			} else {
				t[u].nxt[f] = t[u].pre[id] = 1; in[u] -- ;
				t[u].merge (f, id);
			}
			return true;
		}
	}
	return false;
}
```

终于$AC$了，激动。
```CPP
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <set>
#include <map>
#include <queue>

using namespace std;

typedef long long ll;

const int INF = 2139062143;

template <typename T> void chkmax(T &x, T y) {x = x > y ? x : y;}
template <typename T> void chkmin(T &x, T y) {x = x > y ? y : x;}

template <typename T> void read (T &x) {
    x = 0; bool f = 1; char ch;
    do {ch = getchar(); if (ch == '-') f = 0;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0'; ch = getchar();} while (ch >= '0' && ch <= '9');
    x = f ? x : -x;
}

template <typename T> void write (T x) {
    if (x < 0) x = ~x + 1, putchar ('-');
    if (x > 9) write (x / 10);
    putchar (x % 10 + '0');
}

const int N = 2000 + 50;
const int M = 4000 + 50;

struct EDGE {
    int u, to, nxt;
} edge[M];

int T, n, E, Max_In, p[N], x[N], y[N], in[N], head[N];

inline void addedge (int u, int v) {
    edge[++E].to = v;
    edge[E].nxt = head[u];
    head[u] = E;
}

inline void Clear () {
    E = 1; Max_In = 0;
    for (int i = 0; i <= n; i ++ ) head[i] = in[i] = 0;
}

namespace subtask2 {
    int fa[N], ans[N];
    bool vis[N];
    inline int find (int x) {
        return x == fa[x] ? x : fa[x] = find (fa[x]);
    }
    inline void merge (int x, int y) {
        fa[find (x)] = find (y);
    }
    void main () {
        for (int i = 1; i <= n; i ++ ) fa[i] = i, vis[i] = 0;
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= n; j ++ ) {
                if (!vis[j] && (i == n || find (j) != find (p[i]))) {
                    ans[i] = j; vis[j] = 1; merge (j, p[i]);
                    break;
                }
            }
        }
        for (int i = 1; i <= n; i ++ ) printf ("%d%c", ans[i], i == n ? '\n' : ' ');
    }
}

namespace subtask4 {
    int cnt, a[N], ans[N], tag[N], num[N];
    bool vis[N];
    inline void dfs (int u, int f) {
        a[num[u] = ++ cnt] = u;
        for (int i = head[u]; i; i = edge[i].nxt) {
            int v = edge[i].to;
            if (v == f) continue;
            dfs (v, u);
        }
    }
    inline void push_l (int p1, int p2) { //打标记
        if (p1 != 1 && p1 != n) tag[p1] = 2;
        if (p2 != 1 && p2 != n) tag[p2] = 2;
        for (int i = p1 + 1; i < p2; i ++ ) tag[i] = 1;
        return;
    }
    inline void push_r (int p1, int p2) {
        if (p1 != 1 && p1 != n) tag[p1] = 1;
        if (p2 != 1 && p2 != n) tag[p2] = 1;
        for (int i = p2 + 1; i < p1; i ++ ) tag[i] = 2;
        return;        
    }
    inline int find_l (int u) {
        int res = n + 1;
        if (tag[num[u]] == 2) return res;
        for (int j = num[u] - 1; j >= 1; j -- ) {
            if (tag[j] == 1) {
                if (!vis[j]) res = min (res, a[j]);
                break;
            } 
            if (tag[j] == 0 && !vis[j]) res = min (res, a[j]);
        }
        return res;
    }
    inline int find_r (int u) {
        int res = n + 1;
        if (tag[num[u]] == 1) return res;
        for (int j = num[u] + 1; j <= n; j ++ ) {
            if (tag[j] == 2) {
                if (!vis[j]) res = min (res, a[j]);
                break;
            }
            if (tag[j] == 0 && !vis[j]) res = min (res, a[j]);
        }
        return res;
    }
    void main () {
        for (int i = 1; i <= n; i ++ ) tag[i] = vis[i] = 0; cnt = 0;
        for (int i = 1; i <= n; i ++ ) if (in[i] == 1) {dfs (i, 0); break;}
        for (int i = 1; i <= n; i ++ ) {
            int rt = find_l (p[i]), tp;
            if (rt < (tp = find_r (p[i]))) push_r (num[p[i]], num[rt]);
            else rt = tp, push_l (num[p[i]], num[rt]);
            ans[i] = rt;
            vis[num[rt]] = 1;
        }
        for (int i = 1; i <= n; i ++ ) printf ("%d%c", ans[i], i == n ? '\n' : ' ');
    }
}

namespace subtask5 {
    struct UnionFindSet {
        int fa[N], fir, lst;
        bool pre[N], nxt[N];
        inline void build () {
            for (int i = 1; i <= n; i ++ ) pre[i] = nxt[i] = false, fa[i] = i;
            fir = lst = 0;
        }
        inline int find (int x) {
            return x == fa[x] ? x : fa[x] = find (fa[x]);
        }
        inline bool same (int x, int y) {
            return find (x) == find (y);
        }
        inline void merge (int x, int y) {
            fa[find (x)] = find (y);
        }
    } t[N];

        inline int dfs (int u, int f) {
            int res = n + 1;
            if (f && (!t[u].lst || t[u].lst == f) ) {
                if (!t[u].nxt[f] && !(t[u].fir && in[u] > 1 && t[u].same (f, t[u].fir))) 
                    res = u;
            }
            for (int i = head[u]; i; i = edge[i].nxt) {
                int v = edge[i].to, id = i >> 1;
                if (f == id) continue;
                if (!f) {
                    if (!t[u].fir || t[u].fir == id) {
                        if (t[u].pre[id]) continue;
                        if (t[u].lst && in[u] > 1 && t[u].same (t[u].lst, id)) continue;
                        chkmin (res, dfs (v, id));
                    } else continue;
                } else {
                    if (t[u].fir == id || t[u].lst == f || t[u].same (id, f)) continue;
                    if (t[u].pre[id] || t[u].nxt[f]) continue;
                    if (t[u].fir && t[u].lst && in[u] > 2 && t[u].same (t[u].fir, f) && t[u].same (t[u].lst, id)) continue;
                    chkmin (res, dfs (v, id));
                }
            }
            return res;
        }
    
    inline bool push (int u, int f, int end) {
        if (u == end) {
            t[u].lst = f;
            return true; 
        }
        for (int i = head[u]; i; i = edge[i].nxt) {
            int id = i >> 1, v = edge[i].to;
            if (id == f) continue;
            if (push (v, id, end)) {
                if (!f) t[u].fir = id;
                else {
                    t[u].nxt[f] = t[u].pre[id] = true; in[u] -- ;
                    t[u].merge (f, id);
                }
                return true;
            }
        }
        return false;
    }

    inline void main () {
        for (int i = 1; i <= n; i ++ ) t[i].build ();
        for (int i = 1; i <= n; i ++ ) {
            int ret = dfs (p[i], 0);
            push (p[i], 0, ret);
            printf ("%d%c", ret, i == n ? '\n' : ' ');
        }
    }
}

int main () {
    read (T);
    while (T -- ) {
        read (n); Clear ();
        for (int i = 1; i <= n; i ++ ) read (p[i]);
        for (int i = 1, u, v; i < n; i ++ ) {
            read (u); read (v);
            x[i] = u; y[i] = v;
            addedge (u, v);
            addedge (v, u);
            in[u] ++ ; in[v] ++ ;
            chkmax (Max_In, max (in[u], in[v]));
        }
        if (Max_In == n - 1) subtask2::main ();
        else if (Max_In == 2) subtask4::main ();
        else subtask5::main ();
    }
    return 0;
}
```

---

## 作者：寄风 (赞：0)

## $\texttt{tree}$

### $25\texttt{pts}$(菊花)

考虑对所有点，使其与其的目标点之间连边，那么最后这个图就是一个环。于是考虑贪心，使用并查集判断合法性即可。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2005;
int n , t , a[N] , ans[N] , vis[N];
namespace dsu{
    int fa[N << 4];
    inline int Find(int x){return x == fa[x] ? x : fa[x] = Find(fa[x]);}
    inline void Union(int u , int v){fa[Find(u)] = Find(v);}
    inline bool chk(int u , int v){return Find(u) == Find(v);}
    inline void init(int _n){for(int i = 0;i <= _n;i++) fa[i] = i;}
};
using namespace dsu;
inline void solve(){
    cin >> n;
    init(n);
    memset(vis , 0 , sizeof(vis));
    for(int i = 1;i <= n;i++) cin >> a[i];
    for(int i = 1 , u , v;i < n;i++) cin >> u >> v;
    for(int i = 1;i <= n;i++){
        int x = a[i];
        for(int j = 1;j <= n;j++){
            if(!vis[j] && (i == n || !chk(x , j))){
                ans[i] = j;
                Union(x , j);
                vis[j] = 1;
                break;
            }
        }
        cout << ans[i] << ' ';
    }
    cout << '\n';
}
signed main(){
    cin >> t;
    while(t--) solve();
    return 0;
}
```



### $100\texttt{pts}$

考虑给每一个边钦定优先级。

考虑如何去刻画题目中的一些约束。

对于点 $s$，它要移动到点 $t$，那么对于 $(s,i)$ 与 $(i,j)$ 两条满足 $i,j\in \operatorname{path}_{s,t}$ 的边来说，我们钦定 $(i,j)$ 在 $(s,i)$ 删除完毕之后立马删除，

发现这样子不影响，于是可以同样的刻画 $(i,j)$ 与 $(j,t)$ 的边。

发现这样子也可以刻画 $(i,j)$ 与 $(j,k)$ 的边。

那么考虑如何实现这个刻画，具体的你可以对每个边拆点，搞成入点和出点，然后对于一条路径 $(s,t)$ 去这么刻画：

$s$ 向 $in_{(s,i)}$ 连边。

$in_{(i,j)}$ 向 $out{(j,k)}$ 连边，$out_{(i,j)}$ 向 $in_{(j,k)}$ 连边。

$out_{(i,t)}$ 向 $t$ 连边。注意到这样子是很好判断一个点能否走到的，具体的直接并查集判环即可。

那么直接对于每个点，搜索求出能走到的合法的最优秀的点。

注意到优先级每次只会变化一条路径，所以每次做完更新路径上优先级即可。

时间复杂度 $O(n^2)$，可以通过。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2005;
int deg[N];
namespace dsu{
    int fa[N << 4];
    inline int Find(int x){return x == fa[x] ? x : fa[x] = Find(fa[x]);}
    inline void Union(int u , int v){fa[Find(u)] = Find(v);}
    inline bool chk(int u , int v){return Find(u) == Find(v);}
    inline void init(int _n){for(int i = 0;i <= _n;i++) fa[i] = i;}
};
using namespace dsu;
int a[N] , n , ans , id[N][N] , s[N] , t[N] , fe[N] , vis[N][N] , now;
vector<int>e[N];
inline void add(int u , int v){
    e[u].push_back(v);
    deg[u]++ , deg[v]++;
}
inline void dfs(int u , int fa = 0){
    fe[u] = fa;
    for(auto v : e[u]){
        if(v == fa || vis[u][v]) continue;
        if(u == now && chk(id[u][v] , id[t[u]][u]) && deg[u] > 1) continue;
        if(u != now && ((chk(id[s[u]][u] , id[fa][u]) && chk(id[u][v] , id[t[u]][u]) && deg[u] > 2) || (chk(id[fa][u] , id[u][v])))) continue;
        dfs(v , u);
    }
    if(u != now && !t[u] && (!chk(id[s[u]][u] , id[fa][u]) || deg[u] == 1)) ans = min(ans , u);
}
inline void solve(){
    cin >> n;
    for(int i = 1;i <= n;i++){
        e[i].clear();
        deg[i] = s[i] = t[i] = 0;
    }
    for(int i = 1;i <= n;i++) cin >> a[i];
    init(2 * n);
    for(int i = 1 , u , v;i < n;i++){
        cin >> u >> v;
        add(u , v) , add(v , u);
        id[u][v] = id[v][u] = i;
        vis[u][v] = vis[v][u] = 0;
    }
    for(int i = 1;i <= n;i++){
        ans = INT_MAX;
        now = a[i];
        dfs(a[i]);
        int u = ans;
        cout << u << ' ';
        t[u] = fe[u];
        int tp = Find(id[fe[u]][u]);
        do{
            if(fe[u] == now) s[now] = u;
            vis[fe[u]][u] = 1;
            fa[Find(id[fe[u]][u])] = tp;
            deg[u]-- , deg[fe[u]]--;
            u = fe[u];
        } while(u != now);
    }
    cout << '\n';
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    int T;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

---


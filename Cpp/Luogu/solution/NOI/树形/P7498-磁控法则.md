# 磁控法则

## 题目背景

>那只不过是别人的不幸。

诺顿进入了一个结构复杂的洞穴。在之前的勘察中，他已经得知了这个洞穴里有他梦寐以求的宝藏。

然而这个洞穴是如此的黑暗与复杂，以至于他探索了许久都没有找到宝藏的所在地。但宝藏强大的吸引力仍驱使着他继续搜寻。然而很快他就意识到了不对劲，因为那股吸引力不仅作用在他脑海中，也作用在他身体上——宝藏的防御机关正释放巨大的磁力试图驱逐外来者。

「果然，这就是它自带的保护机制吗？」诺顿笑了笑，拿出了一小块散发着奇特光芒的金属。

「不过，我也是有准备的。」

## 题目描述

诺顿所在的洞穴可以看作是由 $n$ 个洞窟和 $n-1$ 条通道形成的树状结构，诺顿在石窟 $s$，宝藏在石窟 $t$。在宝藏所在的石窟里有一块拥有强大磁场的特殊的磁铁，诺顿身上也有一块小型的同样材质的磁铁。宝藏石窟里的磁铁**只有一个磁极**（N 或 S），并且**磁极不会发生变化**。诺顿身上的磁铁也**只有一个磁极**（N 或 S），但**每个时刻开始时会有 $p$ 的概率切换磁极**（N 变成 S，S 变成 N）。

每个时刻诺顿的移动方式由宝藏石窟磁铁的磁极和诺顿身上磁铁的磁极决定：

1. 两块磁铁磁极不同。此时两块磁铁会触发「吸引」效果。诺顿会因为磁铁间的吸引力移动到与 $s$ 相连的石窟中到 $t$ 距离 $-1$ 的石窟中（即**以 $t$ 为根时 $s$ 的父亲**）。

2. 两块磁铁磁极相同。此时两块磁铁会触发「弹射」效果。诺顿会因为磁铁间的排斥力**等概率**移动到与 $s$ 相连的石窟中到 $t$ 距离 $+1$ 的石窟（即**以 $t$ 为根时 $s$ 的任意一个儿子**）。如果没有满足的石窟，将触发「眩晕」效果，下个时刻诺顿将**不进行任何的移动，也不会进行任何的磁极切换**。

经过一段时间的勘察，诺顿已经知道了整个洞穴的结构以及磁极切换的概率 $p$。为了更好的寻找宝藏，他每次会向你提出询问，你需要回答他如果一开始诺顿在石窟 $x$，身上磁铁磁极为 $c_1$，宝藏在石窟 $y$，石窟内磁铁磁极为 $c_2$，期望在多少时刻后诺顿可以找到宝藏。

## 说明/提示

#### 样例一解释
每个时刻磁极切换概率为 $\dfrac{1}{2}$。

洞窟结构如下：  
![](https://cdn.luogu.com.cn/upload/image_hosting/od4ixuog.png)

对于询问 $1$，诺顿在第 $1$ 个时刻有 $\dfrac{1}{2}$ 的概率移动到 $1$，有 $\dfrac{1}{2}$ 的概率触发「眩晕」进入第 $3$ 个时刻。在第 $3$ 个时刻同样有 $\dfrac{1}{2}$ 的概率移动到 $1$，有 $\dfrac{1}{2}$ 的概率触发「眩晕」进入第 $5$ 个时刻……期望结果为 $1\times\dfrac{1}{2}+3\times\left(\dfrac{1}{2}\right)^2+5\times\left(\dfrac{1}{2}\right)^3+\ldots=3$。

------------
#### 数据范围

**本题采用捆绑测试**。

+ Subtask 1 ( $10\%$ )：$n,q\leq15$。
+ Subtask 2 ( $20\%$ )：$n\leq10^3$。
+ Subtask 3 ( $25\%$ )：对于所有询问，保证 $y=1$。
+ Subtask 4 ( $45\%$ )：无特殊限制。

对于所有数据，$2\leq n\leq5\times 10^5,1\leq q\leq5\times10^5,1\leq u,v,x,y\leq n,x\neq y,2\leq p\leq998244352$。

------------
**本题读入量较大，请使用较快的读入方式。**

## 样例 #1

### 输入

```
6 4 499122177
1 2
1 3
5 3
4 6
4 3
2 N 1 S
3 S 1 S
5 N 6 N
1 S 4 N```

### 输出

```
3
6
17
11```

## 样例 #2

### 输入

```
10 6 199648871
3 7
4 9
2 3
5 6
7 10
5 7
5 9
8 2
1 3
10 S 5 S
1 N 7 S
1 N 4 N
1 S 4 N
4 N 3 S
7 N 4 N```

### 输出

```
332748127
8
665496262
665496261
665496253
831870314```

# 题解

## 作者：littleKtian (赞：7)

显然我们并不需要具体是哪个磁极，只需要只要磁极是否相同。

令 $y$ 为树的根，设 $f_{i,0/1}$ 表示从 $i$ 走到 $y$，磁极相同/不同时的期望步数。

有 $\begin{cases}f_{i,0}=pf_{fa_i,1}+(1-p)(f_{i,0}+1)+1,f_{i,1}=(1-p)f_{fa_i,1}+p(f_{i,0}+1)+1&i\text{是叶子节点}\\f_{i,0}=pf_{fa_i,1}+(1-p)\sum\dfrac{f_{j,0}}{so_i}+1,f_{i,1}=(1-p)f_{fa_i,1}+p\sum\dfrac{f_{j,0}}{so_i}+1&i\text{不是叶子节点}\end{cases}$，其中 $j$ 是 $i$ 的儿子，$fa_i$ 是 $i$ 的父亲，$so_i$ 是 $i$ 的儿子节点个数。特别的，$f_{y,0}=f_{y,1}=0$。

### Subtask 1

直接写式子然后高斯消元。

### Subtask 2&3

（我感觉这两部分做法是一样的）

~~考虑人脑消元。~~

对叶子节点的式子变形，有 $f_{i,0}=f_{fa_i,1}+\dfrac{2-p}{p},f_{i,1}=f_{fa_i,1}+3$。

发现递推式中只涉及到 $f_{fa_i,1}$ 以及常数项，考虑归纳证明每个节点的递推式只与其父亲有关。

对于非叶子节点 $i$，假设其后代节点均满足此规律。设 $\sum\dfrac{f_{j,0}}{so_i}=k_1f_{i,1}+k_2$。

有 $f_{i,0}=pf_{fa_i,1}+(1-p)(k_1f_{i,1}+k_2)+1,f_{i,1}=(1-p)f_{fa_i,1}+p(k_1f_{i,1}+k_2)+1$。

变形，得 $f_{i,0}=\dfrac{p+k_1-2pk_1}{1-pk_1}f_{fa_i,1}+\dfrac{k_1+k_2-2pk_1-pk_2+1}{1-pk_1},f_{i,1}=\dfrac{1-p}{1-pk_1}f_{fa_i,1}+\dfrac{1+pk_2}{1-pk_1}$，得证。

因此我们只需要先进行一次树形dp求出递推式的系数和常数，然后再递推得出结果。

Subtask 2 直接以每个点为根的情况各进行一次dp，Subtask 3 直接以 $1$ 为根进行dp即可。

### Subtask 4

容易发现每个点的递推式实际上只和根的方向有关。

所以可以用换根dp求出所有的递推式再利用一些奇怪的操作来回答每个询问。

这样做还是很麻烦，所以我们考虑再简化递推式。

实际上把每个点的递推式的系数打表打出来会发现都为 $1$。

同样考虑归纳证明容易证得，于是得到 $k_1=1$。

于是有递推式 $f_{i,0}=f_{fa_i,1}+k_2+2,f_{i,1}=f_{fa_i,1}+\dfrac{1+pk_2}{1-p}$。

于是这道题就成了一道换根dp+树上链求和的板题，预处理逆元可以做到 $O(n+q\log n)$。

当然具体实现还有很多细节（特别是要分清 $f_{i,0}$ 和 $f_{i,1}$，以及注意链跳的方向）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 998244353
int lw[1000005],bi[2000005][2],bs;
int s[1000005],tf[1000005],f[1000005][2],ff[1000005][2],sf[1000005][2];
int fa[1000005],so[1000005],si[1000005],de[1000005],to[1000005];
int n,q,p,np,nfp,ny[1000005];
int dr()
{
	int xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
	return xx;
}
int P(int x,int y=mod-2)
{
	int z=1;
	for(;y;x=1ll*x*x%mod,y>>=1)if(y&1)z=1ll*z*x%mod;
	return z;
}
void tj(int u,int v){++bs,bi[bs][0]=lw[u],bi[bs][1]=v,lw[u]=bs;}
void dfs1(int w,int fath,int d)
{
	fa[w]=fath,si[w]=1,de[w]=d;
	int x;
	for(int o_o=lw[w];o_o;o_o=bi[o_o][0])
	{
		int v=bi[o_o][1];
		if(v!=fath)
		{
			++s[w],dfs1(v,w,d+1),tf[w]=(tf[w]+f[v][0])%mod,si[w]+=si[v];
			if(si[v]>si[so[w]])so[w]=v;
		}
	}
	if(s[w])x=1ll*tf[w]*ny[s[w]]%mod,f[w][0]=(2+x)%mod,f[w][1]=1ll*(1+1ll*p*x)%mod*nfp%mod;
	else f[w][0]=1ll*(2-p+mod)*np%mod,f[w][1]=3;
}
void dfs2(int w)
{
	if(s[w]==0)return;
	int ns=ny[s[w]-(fa[w]?0:1)],tt=(tf[w]+ff[w][0])%mod,x;
	for(int o_o=lw[w];o_o;o_o=bi[o_o][0])
	{
		int v=bi[o_o][1];
		if(v!=fa[w])
		{
			if(fa[w]||s[w]>1)x=1ll*(tt-f[v][0]+mod)*ns%mod,ff[v][0]=(2+x)%mod,ff[v][1]=1ll*(1+1ll*p*x)%mod*nfp%mod;
			else ff[v][0]=1ll*(2-p+mod)*np%mod,ff[v][1]=3;
			dfs2(v);
		}
	}
}
void dfs(int w,int t)
{
	to[w]=t,sf[w][0]=(sf[fa[w]][0]+f[w][1])%mod,sf[w][1]=(sf[fa[w]][1]+ff[w][1])%mod;
	if(so[w])dfs(so[w],t);
	for(int o_o=lw[w];o_o;o_o=bi[o_o][0])
	{
		int v=bi[o_o][1];
		if(v!=fa[w]&&v!=so[w])dfs(v,v);
	}
}
int lca(int x,int y)
{
	int fx=to[x],fy=to[y];
	while(fx!=fy)if(de[fx]>de[fy])x=fa[fx],fx=to[x];else y=fa[fy],fy=to[y];
	return de[x]<de[y]?x:y;
}
int gs(int x,int y)
{
	int fx=to[x],fy=to[y];
	while(fx!=fy)
	{
		if(fa[fx]==y)return fx;
		x=fa[fx],fx=to[x];
	}
	return so[y];
}
int main()
{
	n=dr(),q=dr(),p=dr(),np=P(p),nfp=P(mod+1-p);
	ny[1]=1;
	for(int i=2;i<=n;i++)ny[i]=1ll*(mod-mod/i)*ny[mod%i]%mod;
	for(int i=1;i<n;i++)
	{
		int u=dr(),v=dr();
		tj(u,v),tj(v,u);
	}
	dfs1(1,0,1),dfs2(1),dfs(1,1);
	while(q--)
	{
		int x=dr(),y;char c1=getchar(),c2;
		while(c1!='N'&&c1!='S')c1=getchar();
		y=dr(),c2=getchar();
		while(c2!='N'&&c2!='S')c2=getchar();
		int a=lca(x,y),ans=((sf[x][0]-sf[a][0]+sf[y][1]-sf[a][1])%mod+mod)%mod;
		if(c1==c2)
		{
			if(x==a)
			{
				int b=gs(y,a);
				ans=((ans-ff[b][1]+ff[b][0])%mod+mod)%mod;
			}
			else ans=((ans-f[x][1]+f[x][0])%mod+mod)%mod;
		}
		printf("%d\n",ans);
	}
}
```


------------
关于为什么 $p\geq 2$：

其实就是直接帮你们排除了 $p=0$ 以及 $p=1$ 的情况，因为上面所有的式子变形都基于 $p\neq 0$ 和 $p\neq 1$。

---

## 作者：Felix72 (赞：1)

换根树上消元 + 链上信息处理问题，感觉不止紫啊。

我们先考虑暴力怎么做。令一个点为根，设置状态 $f_{pos, 0}$ 表示当前在点 $pos$，若极性不变则下一次触发**吸**，走到根的期望步数。同理设置状态 $f_{pos, 1}$ 表示当前在点 $pos$，若极性不变则下一次触发**弹**，走到根的期望步数。（注意这里和出题人题解的状态是反过来的）

根据树上消元的技巧，我们一定能把每个点的式子都化为只和它的父亲相关。本题中，$f_{pos, 0/1}$ 的值只和 $f_{fa, 0}$ 相关。

具体地，对于非叶子节点，我们有：

$$
f_{pos, 0} = 1 + f_{fa, 0} \times (1 - p) + \frac{p}{sn_{pos}} \times \sum f_{son, 1}
$$
$$
f_{pos, 1} = 1 + f_{fa, 0} \times p + \frac{1 - p}{sn_{pos}} \times \sum f_{son, 1}
$$

把它们化为只和父亲相关的形式。即 $f_{pos, op} = k \times f_{fa, 0} + d$ 的形式。

因为根不是固定的，所以对于一个 $pos$，它的 $fa$ 可能是与其相连的任何一个节点。对于这种情况我们可以换根 dp。

dp 完之后怎么做？我们发现，这个先乘再加的操作形如线段树模板，是有可合并性的，因而可以倍增维护。

设 $g_{0/1, pos, k}$ 为 $f_{pos, 0}$ 和 $f_{ac, 0}$ 之间的 $k$，$d$ 关系，其中 $ac$ 是 $pos$ 的 $2^k$ 级祖先。第一维 $0/1$ 表示方向是从上到下还是从下到上。

倍增解析出链即可。

```cpp
/*有人发现题面是第五人格的剧情嘛qwq*/
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 500010, mod = 998244353;
inline void exgcd(long long a, long long b, long long &x, long long &y)
{
	if(b == 0) {x = 1, y = 0; return ;}
	exgcd(b, a % b, y, x); y -= a / b * x;
}
inline long long Inv(long long num)
{
	long long x, y; exgcd(num, mod, x, y);
	x = (x % mod + mod) % mod; return x;
}
int n, m, dg[N], fa[N][21], dep[N]; short lg[N];
int p; vector < int > edge[N];
struct Rel
{
	long long k, d;
	Rel operator + (const Rel &w) const {return {(k + w.k) % mod, (d + w.d) % mod};}
	Rel operator - (const Rel &w) const {return {(k - w.k + mod) % mod, (d - w.d + mod) % mod};}
	Rel operator * (const long long &w) const {return {k * w % mod, d * w % mod};}
	Rel operator * (const Rel &w) const {return {k * w.k % mod, (d * w.k + w.d) % mod};}
}; Rel f[2][N][2], g[2][N][21], h[N];
inline Rel get(int opt, int sn, Rel rs, Rel f0)
{
	if(opt == 0)
	{
		rs = rs * (p * Inv(sn) % mod);
		long long dv = (1 - rs.k + mod) % mod;
		return (Rel){1 - p + mod, 1 + rs.d} * Inv(dv);
	}
	else
	{
		rs = rs * ((1 - p + mod) * Inv(sn) % mod);
		return (Rel){p + rs.k * f0.k % mod, (1 + rs.k * f0.d + rs.d) % mod};
	}
}
inline void treedp(int now, int prt)
{
	fa[now][0] = prt; dep[now] = dep[prt] + 1;
	for(int i = 1; ; ++i)
	{
		if(fa[fa[now][i - 1]][i - 1]) fa[now][i] = fa[fa[now][i - 1]][i - 1];
		else break;
	}
	if(prt && dg[now] == 1)
	{
		f[0][now][0] = {1, 3};
		f[0][now][1] = {1, (2 - p + mod) * Inv(p) % mod};
		return ;
	}
	Rel cur = {0, 0};
	for(int to : edge[now])
	{
		if(to == prt) continue;
		treedp(to, now);
		cur = cur + f[0][to][1];
	}
	f[0][now][0] = get(0, dg[now] - (prt != 0), cur, {0, 0});
	f[0][now][1] = get(1, dg[now] - (prt != 0), cur, f[0][now][0]);
}
inline void reproot(int now, int prt)
{
	if(prt == 0 && dg[now] == 1)
	{
		for(int to : edge[now])
		{
			f[1][to][0] = {1, 3};
			f[1][to][1] = {1, (2 - p + mod) * Inv(p) % mod};
		}
	}
	else
	{
		Rel sum = {0, 0};
		for(int to : edge[now])
		{
			if(to == prt) continue;
			sum = sum + f[0][to][1];
		}
		if(prt) sum = sum + f[1][now][1];
		for(int to : edge[now])
		{
			if(to == prt) continue;
			Rel cur = sum - f[0][to][1];
			f[1][to][0] = get(0, dg[now] - 1, cur, {0, 0});
			f[1][to][1] = get(1, dg[now] - 1, cur, f[1][to][0]);
		}
	}
	for(int to : edge[now])
	{
		if(to == prt) continue;
		reproot(to, now);
	}
}
inline void init(int now, int prt)
{
	g[0][now][0] = f[0][now][0];
	g[1][now][0] = f[1][now][0];
	for(int i = 1; ; ++i)
	{
		if(!fa[now][i]) break;
		g[0][now][i] = (g[0][fa[now][i - 1]][i - 1] * g[0][now][i - 1]);
		g[1][now][i] = (g[1][now][i - 1] * g[1][fa[now][i - 1]][i - 1]);
	}
	for(int to : edge[now])
	{
		if(to == prt) continue;
		init(to, now);
	}
}

inline int jump(int pos, int dist)
{
	while(dist)
	{
		int k = lg[lowbit(dist)];
		pos = fa[pos][k];
		dist -= lowbit(dist);
	}
	return pos;
}
inline int LCA(int x, int y)
{
	if(dep[x] < dep[y]) swap(x, y);
	x = jump(x, dep[x] - dep[y]);
	if(x == y) return x;
	for(int i = 20; i >= 0; --i)
		if(fa[x][i] != fa[y][i])
			x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}
inline Rel get_chain(int op, int pos, int dist)
{
	Rel res = {1, 0};
	while(dist)
	{
		int k = lg[lowbit(dist)];
		if(op == 0) res = g[0][pos][k] * res;
		else res = res * g[1][pos][k];
		pos = fa[pos][k];
		dist -= lowbit(dist);
	}
	return res;
}
inline long long solve(int x, int y, int opt)
{
	int lca = LCA(x, y);
	if(x == lca)
	{
		if(opt == 0)
		{
			return get_chain(1, y, dep[y] - dep[x]).d;
		}
		else
		{
			Rel res = get_chain(1, y, dep[y] - dep[x] - 1);
			int ps = jump(y, dep[y] - dep[x] - 1);
			return (res * f[1][ps][1]).d;
		}
	}
	else if(y == lca)
	{
		if(opt == 0)
		{
			return get_chain(0, x, dep[x] - dep[y]).d;
		}
		else
		{
			Rel res = get_chain(0, fa[x][0], dep[x] - dep[y] - 1);
			return (res * f[0][x][1]).d;
		}
	}
	else
	{
		if(opt == 0)
		{
			return (get_chain(1, y, dep[y] - dep[lca]) * get_chain(0, x, dep[x] - dep[lca])).d;
		}
		else
		{
			Rel del = get_chain(1, y, dep[y] - dep[lca]);
//			cerr << "D " << del.k << " " << del.d << '\n';
			Rel res = get_chain(0, fa[x][0], dep[x] - dep[lca] - 1);
			return (del * res * f[0][x][1]).d;
		}
	}
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> p;
	for(int i = 1; i <= n; ++i) lg[i] = log2(i);
	for(int i = 1; i < n; ++i)
	{
		int x, y; cin >> x >> y;
		edge[x].push_back(y); ++dg[x];
		edge[y].push_back(x); ++dg[y];
	}
	treedp(1, 0); reproot(1, 0);
	init(1, 0);
	for(int i = 1; i <= m; ++i)
	{
		int x, y, op; char cx, cy;
		cin >> x >> cx >> y >> cy;
		op = ((cx != cy) ? 0 : 1);
		cout << solve(x, y, op) << '\n';
	}
	return 0;
}
/*
6 1 499122177
1 2
1 3
5 3
4 6
4 3
5 N 6 N
*/
```

这样就做完了......吗？

在调试的时候，我们也许会发现这里面维护的 $(k, d)$ 中，$k$ 总是 $1$。这是否是必然的？

通过对式子逐个证明可以解决这个问题。首先假定根固定（因为这是换根，换出来的结果也相当于有一个新的根，所以不用对换根部分单独证了），对于叶子节点，我们推式子得 $k = 1$。而对于非叶子节点，式子中有这一部分：$\frac{\dots}{sn_{pos}} \times \sum f_{son, 1}$。

用归纳法思考，若每个 $f_{son, 1}$ 的 $k$ 值都是 $1$，除以了 $sn_{pos}$ 后也应当是 $1$。而分子的 $p$ 或 $1 - p$ 则和之前的系数抵消。

由此，我们证明了 $k = 1$。倍增维护二元组可以直接改为链上求和。

---


# [CTS2022] 独立集问题

## 题目描述

小 E 喜欢出最大权独立集问题。

接下来，他还想了 $n$ 道最大权独立集问题。

但是和之前不一样，这回他想把 $n$ 道题整合成一道题出出来。

小 E 有 $n$ 个 AI，编号为 $1\sim n$ 。

开始第 $i$ 个 AI 里面存有一道小 E 事先出好的一道难度为 $d_i$ 的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \le i \le n$ ，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。其中 $c_i<i$。所以，这些 AI 连成了一个树的形状。此外，其他对 AI 不可以互相通信。

小 E 每次可以选择一个存有一道最大权独立集问题的 AI，结合它能够直接互相通信的所有 AI 中的问题，变成一道新的最大权独立集问题。整合问题时总有难度损失，不可能是把所有问题的难度直接相加。这道新的最大权独立集问题的难度是那些能够直接互相通信的 AI 中的题目难度和减去原本存在该 AI 上的问题的难度。然后那些能够直接互相通信的 AI 中的问题难度会变成 $0$。

小 E 希望通过若干次操作，把 $n-1$ 个 AI 中的题目难度都变成 $0$，然后把最后一个 AI 中的题目出出来。

由于出题人的丧病心理，小 E 想要出出来的最大权独立集问题的难度尽量大。

他想叫你帮他解决这个问题，还说如果你成功解决了这个问题，那么在出那道最大权独立集问题的时候，他会帮你提交一份标程代码。

## 说明/提示

保证 $1\le n\le 351493$。

保证 $1\le c_i <i$。

保证 $|d_i|\le 10^9$。



子任务 1（13 分）：$c_i=i-1$。

子任务 2（6 分）：$d_i>0$。

子任务 3（11 分）：$n\le 7$。

子任务 4（13 分）：$n\le 16$。

子任务 5（22 分）：$n\le 100$。

子任务 6（35 分）：无特殊性质。



## 样例 #1

### 输入

```
4
-1 2 3 4
1 1 1
```

### 输出

```
10
```

# 题解

## 作者：iyaang (赞：7)

[心动的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/17350961.html)

[题目链接](https://www.luogu.com.cn/problem/P8258)

来自 2023SDPT-Round1-Day4 课上 Qingyu 的讲解。

考虑对于一个点多次操作会发生什么？第一次操作会将周围的点的权值吸过来，自己对答案的贡献乘 $-1$，周围的点的贡献乘 $+1$，得到新的权值 $a_x' = \pm a_x \mp \sum_{y \in son_x} a_y$；再一次操作，我们可以将这个新的贡献取反。于是我们可以得到如果一个点被操作，那么他最后的贡献可以自由控制符号，答案求的是最大值，$|a_i'|$ 的绝对值号可以拆开算贡献。

来点暴力 DP。很自然能够想到分成三种进行讨论：自己的值被父亲吸走，自己的值被儿子吸走，自己吸走别人的值。那么不妨设 $f_{x,0/1/2,0/1}$ 记录，第一维是节点编号，第二维是三种情况讨论，第三维是当前节点是否吸走了父亲的值，DP 的值即为按这种方式转移能够得到的最大答案。接下来考虑如何转移：

- 首先我们钦定如果是 $f_{x,0,0/1}$ 即被父亲吸走后，依旧可以操控这个状态来继续吸取儿子；如果是 $f_{x,1,0/1}$ 即被**某个儿子**吸走后，依旧可以操控这个状态来吸取父亲和其他儿子；
- 能够注意到 $f_{x,0,1}$ 是没有意义的，因为不可能自己的值被父亲吸走，又吸走了父亲的值。这一维恒为 $0$；
- 记 $A_x$ 为 $f_{son_x,0,0} \pm val_{son_x},f_{son_x,1,0},f_{son_x,2,0}$ 中的最大值，$B_x$ 为 $f_{son_x,0,0} \pm val_{son_x},f_{son_x,1,0}$，$C_x$ 为 $f_{son_x,1,1},f_{son_x,2,1}$，其中 $f_{son_x,0,0} \pm val_x$ 并不是对两种运算去最值，而是对应第一段中那个式子的两种情况；
- 对于 $f_{x,0,0}$ 即被父亲吸了，那么儿子对转移过来的值的贡献就是每个儿子的最优值，即 $\sum A_{son_x}$；
- 对于 $f_{son_x,1,0/1}$ 即被儿子吸了的，我们在决策被哪一个儿子吸收的时候，贪心的看一下不加那个儿子的权值最优即可，去掉的儿子即为 $A_{son_x} - C_{son_x}$ 最小的那个，将该值即为 $D_i$，儿子对转移过来的值的贡献即为 $\sum A_{son_x} - D_i$。吸了父亲的情况再加上对应情况的父亲的权值即可；
- 对于 $f_{son_x,2,0/1}$ 即自己吸收的，儿子对转移过来的值的贡献即为 $\sum B_{son_x}$，最后还要对应的加或减去自身的权值。吸了父亲的情况再加上对应情况的父亲的权值即可；
- 对于每个点，分别记录一遍两种情况的 $A_x,B_x,C_x$，再加上对应计算方式（第一段中的式子）的本身节点的权值，看一看选取哪个最优；
- 最后的答案即为 $\max{(f_{root,1,0},f_{root,2,0})}$。

由此我们只需要遍历树一遍，记录和转移 DP 数组，细节还是很多的。时间复杂度为 $\mathcal O(n)$。

upd 2023.7.23 感谢 @trsins，修改了两个错误的式子。

```cpp
#include<bits/stdc++.h>
#define ld long double 
#define ull unsigned long long
#define int long long
#define pb push_back
#define mp make_pair
using namespace std;

inline int read()
{
	int s=0,w=1; char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}
inline void write(int x,char ch)
{
	if(x<0) x=-x,putchar('-');
	static char stk[25]; int top=0;
	do {stk[top++]=x%10+'0',x/=10;} while(x);
	while(top) putchar(stk[--top]);
	putchar(ch);
	return;
}

namespace MyTool
{
	static const int Mod=1e9+7;
	template<typename T> inline void Swp(T &a,T &b) {T t=a;a=b;b=t;}
	inline int  Max(int a,int b)   {return (b&((a-b)>>63))|(a&(~(a-b)>>63));}
	inline int  Min(int a,int b)   {return (a&((a-b)>>63))|(a&(~(a-b)>>63));}
	template<typename T> inline void cmax(T &a,T b) {a=a>b?a:b;}
	template<typename T> inline void cmin(T &a,T b) {a=a<b?a:b;}
	inline int  Abs(int a) {return (a^(a>>63))-(a>>63);}
	inline void Madd(int &a,int b) {a=a+b>Mod?a+b-Mod:a+b;}
	inline void Mdel(int &a,int b) {a=a-b<0?a-b+Mod:a-b;}
	inline void Mmul(int &a,int b) {a=1ll*a*b%Mod;}
	inline void Mmod(int &a) {a=(a%Mod+Mod)%Mod;}
	inline int  Cadd(int a,int b)  {return a+b>=Mod?a+b-Mod:a+b;}
	inline int  Cdel(int a,int b)  {return a-b<0?a-b+Mod:a-b;}
	inline int  Cmul(int a,int b)  {return a*b%Mod;}
	inline int  Cmod(int a)  {return (a%Mod+Mod)%Mod;}
	inline int  gcd(int a,int b)   {return b?gcd(b,a%b):a;}
	inline int  qpow(int a,int b)  {int res=1; while(b) {if(b&1) Mmul(res,a); Mmul(a,a); b>>=1;} return res;}
	inline int  qmul(int a,int b)  {int res=0; while(b) {if(b&1) Madd(res,a); Madd(a,a); b>>=1;} return res;}
	template<typename T> inline T pow(T x)    {return x*x;}
}
using namespace MyTool;

inline void file()
{
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
	return;
}

bool Mbe;

namespace LgxTpre
{
	static const int MAX=500000;
	static const int inf=2147483647;
	static const int INF=4557430888798830399;
	static const int mod=998244353;
	static const int bas=131;
	
	int n,val[MAX],fa[MAX];
	vector<int> G[MAX];
	
	int f[MAX][3][2];
	void dfs(int now)
	{
		int zsum1=0,zsum2=0,zmix=INF;
		int fsum1=0,fsum2=0,fmix=INF; 
		for(auto to:G[now]) 
		{
			dfs(to);
			zsum1+=max({f[to][0][0]+val[to],f[to][1][0],f[to][2][0]});
			zsum2+=max({f[to][0][0]+val[to],f[to][1][0]});
			cmin(zmix,max({f[to][0][0]+val[to],f[to][1][0],f[to][2][0]})-max({f[to][1][1],f[to][2][1]}));
			fsum1+=max({f[to][0][0]-val[to],f[to][1][0],f[to][2][0]});
			fsum2+=max({f[to][0][0]-val[to],f[to][1][0]});
			cmin(fmix,max({f[to][0][0]-val[to],f[to][1][0],f[to][2][0]})-max({f[to][1][1],f[to][2][1]}));
		}
		f[now][0][0]=max(zsum1,fsum1);
		f[now][1][0]=max(zsum1-zmix,fsum1-fmix);
		f[now][1][1]=max(zsum1-zmix+val[fa[now]],fsum1-fmix-val[fa[now]]);
		f[now][2][0]=max(zsum2-val[now],fsum2+val[now]);
		f[now][2][1]=max(zsum2-val[now]+val[fa[now]],fsum2+val[now]-val[fa[now]]);
		return;
	}
	
	inline void lmy_forever()
	{
		n=read();
		for(int i=1;i<=n;++i) val[i]=read();
		for(int i=2;i<=n;++i) fa[i]=read(),G[fa[i]].pb(i);
		dfs(1);
		write(max({f[1][1][0],f[1][2][0]}),'\n');
		return;
	}
}

bool Med;

signed main()
{
//	file();
	fprintf(stderr,"%.3lf MB\n",(&Med-&Mbe)/1048576.0);
	LgxTpre::lmy_forever();  
	cerr<<1e3*clock()/CLOCKS_PER_SEC<<" ms\n";
	return (0-0);
}
```

---

## 作者：zhouhuanyi (赞：6)

首先我们有一些发现，一个点在操作过一次后再操作第二次时周围一圈点都已经归零，意味着操作第二次时该点的权值会直接去反，那么这个点的正负性是可以任意变化的，这也就意味着一个点的周围假如没有其他点的存在，这个点的正负性是自由的。那么我们的最优化目标是尽量让点对最终的答案贡献的正负性与答案的正负性尽量的相同，而且最优化是否取到极值与判定一些点的正负贡献是否合法的难度实际上是等价的，这启发我们先考虑枚举 $2^n$ 的正负状态，判定这个正负状态是否合法。

注意到一次消除实际上是将一个 $+$ 与一圈 $-$ 或一个 $-$ 与一圈 $+$，但在消除完后会产生很多的 $0$，而这些 $0$ 在删去后所对应的子树是几乎独立的，因为一个点的周围一圈都已归零，正负状态可以任意变化，可以将其相加。但一个问题是这样会导致分裂的子树无法确定其究竟选哪个点作为根节点，这样导致了状态数实际上很多。

对此我们尝试想象已经归零的节点为一个广义的通配符 $?$，那么每一次消除时允许 $?$ 自由变为 $0$ 与 $1$ 中的任意一个，每次将一个一个点与周围的一圈点均变 $?$，如果全部能变成 $?$ 则合法，至此我们得到了一个 $O(2^n)$ 的解法。

但一个问题是这样的增广实际上是不好设计状态的，一个启发时考虑增广的过程的形态：一开始将一些点给染黑，然后每一个黑点进行 $\texttt{bfs}$ 扩展，扩展出一颗树，每棵树上的兄弟节点正负性相同，根节点与其儿子正负性不同，实际上可以视为若干棵树的并。

一个错误的想法是用这些树将整棵树的边集给覆盖满，但这样意味着只存在一棵树，另一个错误的想法是将一些边将断开将剩下的树的答案合并，但这样所有的边断开就是一种合法方案，将它们两个在 $\texttt{dp}$ 的过程中合并很有可能也存在一些问题。

一个发现是导致该问题的出现的实质是根节点集合的自由选择，那么我们可以考虑的是对根节点再加一点限制，通过一些找规律我们可以发现如下的限制：

令根节点集合为 $S$ ，则 $S$ 合法的充要条件为对于任意边 $(u,v)$，$u,v$ 不同时属于 $S$。 

我们考虑证明该结论，如果两个根节点相邻，那么意味着它们之间会互相的影响，导致谁都不能先操作，反之如果一个根与另一颗树的非根节点相邻，那么只要满足根在非根节点之前操作即不会出现这样的情况。注意到原图是一颗树，而这样的偏序关系是单向的，所以不会形成环，以拓扑排序的方式增广则可以得到一组合法解。

有了上述结论，我们可以考虑在 $\texttt{dp}$ 时记录如下的状态$:$

$1.$一个点与其父亲节点之间的边不在选中的多棵树的边集中，且该节点不以根的形式出现。

$2.$一个点与其父亲节点之间的边不在选中的多棵树的边集中，且该节点以根的形式出现。

$3.$一个点与其父亲节点之间的边在多棵树的边集中形成了一条父亲向该节点的单向边。

$4.$一个点与其父亲节点之间的边在多棵树的边集中形成了一条该节点向父亲的单向边。

对每种状态分别 $\texttt{dp}$ 即可做到 $O(n)$。

---

## 作者：Larunatrecy (赞：4)

考虑如果我们在结点 $x$ 进行了一次操作，那么再进行一次操作后 $x$ 的权值就会取反，这也就是说我们总是可以控制此时 $x$ 的权值在最后答案里的符号，因此把 $|x|$ 加到答案里即可。并且此时如果删掉 $x$ ，那么形成的若干连通块是彼此独立的。

那么我们可以写出一个 $O(2^nn^2)$ 的做法，记录当前的连通块，每次枚举一个点删掉然后递归，这里需要注意的是当前连通块的非叶子边界点的权值一定是 $0$。

这样我们会得到一个每个点的删除顺序，考虑把每条边定向成从后删的点，然后每个有出边的点会选择一条出边作为它的权值第一次被操作过去的边。反过来，因为这里的先后关系在树上是很局部的信息，对于任意一种定向以及选择出边的方案，总是合法的，即不会有环。

当边的定向以及结点的出边确定之后，每个点 $x$的贡献应当是：

- 如果 $x$ 没有出边，贡献为 $|s-x|$。
- 如果有出边，贡献为 $|s|$。

其中 $s$ 是那些出边为 $x$ 的结点的权值和。

套路的，我们把 $|a|$ 拆成 $\max(a,-a)$，然后问题就是你要给每个点一个符号，并且选择了同一出边的结点的符号要相同。这是很容易做的，直接在树上 $dp$ 的时候记录与父亲的边的方向，是否作为 $x$ 的出边，以及 $x$ 的符号即可，转移有一些细节但总是平凡的。

可能需要特判一下 $n=1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>inline void read(T &x)
{
    x=0;char c=getchar();bool f=0;
    for(;c<'0'||c>'9';c=getchar())f|=(c=='-');
    for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c-'0');
    x=(f?-x:x);
}
const int N = 5e5+7;
typedef long long LL;
int n;
LL a[N];
vector<int> G[N];
LL ans=-1e18;
LL dp[N][2][2],f[N];
LL F[3][3];
void dfs(int x)
{
	for(int i=0;i<=1;i++)for(int j=0;j<=1;j++)dp[x][i][j]=-1e18;
	f[x]=-1e18;
	if(G[x].empty())
	{
		dp[x][0][0]=-a[x];
		dp[x][0][1]=a[x];
		dp[x][1][0]=-a[x];
		dp[x][1][1]=a[x];
		return;
	}
	for(int y:G[x])dfs(y);
	dp[x][1][0]=-a[x];
	dp[x][1][1]=a[x];
	LL sum[2]={0,0};
	for(int y:G[x])
	{
		dp[x][1][0]+=max(dp[y][0][1],f[y]);
		dp[x][1][1]+=max(dp[y][0][0],f[y]);
		sum[0]+=max({dp[y][0][1],f[y],dp[y][1][0],dp[y][1][1]});
		sum[1]+=max({dp[y][0][0],f[y],dp[y][1][0],dp[y][1][1]});
	}
	if(x==1)ans=max(dp[x][1][0],dp[x][1][1]);
	for(int y:G[x])
	{
		LL v[2]={0,0};
		v[0]=max({dp[y][0][1],f[y],dp[y][1][0],dp[y][1][1]});
		v[1]=max({dp[y][0][0],f[y],dp[y][1][0],dp[y][1][1]});
		dp[x][1][0]=max(dp[x][1][0],sum[0]-v[0]+max(dp[y][1][0]+a[x],dp[y][1][1]-a[x]));
		dp[x][1][1]=max(dp[x][1][1],sum[1]-v[1]+max(dp[y][1][0]+a[x],dp[y][1][1]-a[x]));
		f[x]=max(f[x],sum[0]-v[0]+max(dp[y][1][0]+a[x],dp[y][1][1]-a[x]));
		f[x]=max(f[x],sum[1]-v[1]+max(dp[y][1][0]+a[x],dp[y][1][1]-a[x]));
	}
	dp[x][0][0]=-a[x]+max(sum[0],sum[1]);
	dp[x][0][1]= a[x]+max(sum[0],sum[1]);
}
int main()
{
	read(n);
	for(int i=1;i<=n;i++)read(a[i]);
	if(n==1)
	{
		cout<<abs(a[1]);
		return 0;
	}
	for(int i=2;i<=n;i++)
	{
		int x;
		read(x);
		G[x].push_back(i);
	}
	dfs(1);
	cout<<max(f[1],ans);
	return 0;
} 
/*

*/
```

---

## 作者：rizynvu (赞：1)

[cnblogs](https://www.cnblogs.com/fiosiate/p/18962283)。

首先能够发现，如果操作了一个点 $u$，那么能让新的 $a_u$ 是 $\sum\limits_{v\in E_u}a_v - a_u$，也能是 $a_u - \sum\limits_{v\in E_u}a_v$。这是因为在操作一次后 $v\in E_u$ 都有 $a_v = 0$，此时再操作一次 $u$ 就相当于是取反了。

直接考虑过程太难考虑，根据合并贡献的式子可以知道最后的答案一定形如 $\sum\limits_{i = 1}^n d_i a_i(a_i \in \{-1, +1\})$。

于是尝试判定一个 $a$ 数组能否被得到。  
首先如果有一个点 $u$ 满足 $\forall v\in E_u, a_u\not = a_v$，那么肯定是可以在 $u$ 这里合并一次的，虽然此时并不能确定是否能这样操作，不过可以先进行尝试。  
接下来会继续选一个其他的点进行合并，这个点可能会合并上一些还没有合并过的点，但也有可能合并上一个已经合并过的点。  

对于还没有合并过的点，肯定要遵循上述的条件：邻域相等，与中心相反，当然如果已经被合并了就不管了。  
对于已经合并过的点，也要关心这个点的符号，不过会发现如果符号对得上那可以直接合并，否则可以在这个点刚合并出来的时候就先反转符号。

于是会发现在合并的时候，已合并的点可以自行调整出符号，唯一的限制就是还没有合并过的点需要满足“邻域相等，与中心相反”的条件。  

那么就可以发现每次选一个可以合并的点合并，能合并完就是 $a$ 数组合法的充要条件。

于是就有了 $\mathcal{O}(2^n n)$ 的做法，记录 $f_{s}$ 代表 $s$ 二进制下对应的点已经合并过了的贡献最大值，转移就是每次选择一个点 $x$ 并在此合并。

```c++
    for (int s = 0; s < (1 << n); s++) {
        for (int x = 0; x < n; x++) {
            f[s | (1 << x) | G[x]] = std::max(f[s | (1 << x) | G[x]], f[s] + std::abs(sum[G[x] & (~ s)] - sum[(1 << x) & (~ s)]));
        }
    }
```

接下来考虑优化。

刚刚的 dp 其实根本没有用到树的性质，在任意图上都是可行的。

树意味着 $u$ 的贡献只可能给到 $u, v(v\in E_u)$，那么在定根后，就只需要考虑 $u, fa(u), v(v\in son_u)$ 这些点。

于是考虑设计一个树形 dp：

- $f_{u, 0 / 1}$ 代表 $u$ 的贡献给到了 $fa(u)$，$u$ 的子树内的最大权值。
- $g_{u, 0 / 1}$ 代表 $u$ 的贡献给到了 $u$，$u$ 的子树内的最大权值。
- $h_{u, 0 / 1}$ 代表 $u$ 的贡献给到了 $v(v\in son_u)$，$u$ 的子树内的最大权值。
- 第二维的 $0 / 1$ 代表的是中心符号为正号 / 负号，因为此时 dp 的贡献不只有单个合并，不能直接套用绝对值，但是 $|x| = \max(x, -x)$ 刚好满足我们的需求。
- 需要注意，此时不考虑 $fa(u)$ 的贡献。

在 dp 转移的时候，就需要考虑 $u$ 及其邻域的合并顺序（因为顺序只考虑 $u$ 及其邻域，所以任意一种顺序都可以逆推出至少一种满足限制的合并顺序）。  

对于 $f_u$ 的转移：

- $fa(u)$ 一定是 $u$ 及其邻域中操作最早的点。
- 对于 $v(v\in son_u)$，$v$ 的贡献给到 $u, v, w(w\in son_v)$ 都是合法的。

对于 $g_u$ 的转移：

- $u$ 一定是 $u$ 及其邻域中操作最早的点。
- 对于 $v(v\in son_u)$，$v$ 的贡献只能给到 $u, w(w\in son_v)$。如果 $v$ 的贡献也给到 $v$，那么 $u, v$ 的顺序无法调配。

对于 $h_u$ 的转移：

- 考虑先枚举 $v$ 代表 $v$ 是 $u$ 及其邻域中操作最早的点。
- 对于 $v$，$v$ 的贡献只能给到 $v, w(w\in son_v)$。如果给到 $u$ 会无法调配。
- 对于 $v'(v'\in son_u, v'\not = v)$，$v'$ 的贡献能给到 $u, v', w'(w'\in son_{v'})$。

对于 $h$ 的暴力转移是 $\mathcal{O}(\sum |E_u|^2)$ 的，写出转移后容易优化到 $\mathcal{O}(n)$。

$f, g$ 转移也均为 $\mathcal{O}(n)$，最后时间复杂度为 $\mathcal{O}(n)$。

代码中注释的就是 $h$ 的暴力转移，第二维为 $0$ 代表邻域为 $+1$，为 $1$ 代表邻域为 $-1$。

```c++
#include <bits/stdc++.h>

using ll = long long;
constexpr ll inf = 1e15;

constexpr int maxn = 351493 + 10;

int n;
ll d[maxn];
std::vector<int> son[maxn];

ll f[maxn][2], g[maxn][2], h[maxn][2];
// f : d[u] -> fa
// g : d[u] -> u
// h : d[u] -> v
// ...[][2] : p / n

void dfs(int u) {
    for (int v : son[u]) dfs(v);
    
    // case 1 : d[u] -> fa

    std::array<ll, 2> s = {};
    for (int v : son[u]) {
        s[0] += std::max({f[v][0], g[v][0], g[v][1], h[v][0], h[v][1]});
        s[1] += std::max({f[v][1], g[v][0], g[v][1], h[v][0], h[v][1]});
    }
    f[u][0] = d[u] + std::max(s[0], s[1]), f[u][1] = -d[u] + std::max(s[0], s[1]);

    // case 2 : d[u] -> u

    s = {};
    for (int v : son[u]) {
        s[0] += std::max({f[v][0], h[v][0], h[v][1]});
        s[1] += std::max({f[v][1], h[v][0], h[v][1]});
    }
    g[u][0] = -d[u] + s[0], g[u][1] = d[u] + s[1];

    // case 3 : d[u] -> v

    h[u][0] = h[u][1] = -inf;
    s = {};
    for (int v : son[u]) {
        s[0] += std::max({f[v][0], g[v][0], g[v][1], h[v][0], h[v][1]});
        s[1] += std::max({f[v][1], g[v][0], g[v][1], h[v][0], h[v][1]});
    }
    for (int v : son[u]) {
        s[0] -= std::max({f[v][0], g[v][0], g[v][1], h[v][0], h[v][1]});
        s[1] -= std::max({f[v][1], g[v][0], g[v][1], h[v][0], h[v][1]});
        const ll valv = std::max(d[u] + std::max(g[v][0], h[v][0]), -d[u] + std::max(g[v][1], h[v][1]));
        h[u][0] = std::max(h[u][0], valv + s[0]), h[u][1] = std::max(h[u][1], valv + s[1]);
        s[0] += std::max({f[v][0], g[v][0], g[v][1], h[v][0], h[v][1]});
        s[1] += std::max({f[v][1], g[v][0], g[v][1], h[v][0], h[v][1]});
    }

    // h[u][0] = h[u][1] = -inf;
    // for (int v : son[u]) {
    //     s = {};
    //     for (int w : son[u]) {
    //         if (w == v) continue;
    //         s[0] += std::max({f[w][0], g[w][0], g[w][1], h[w][0], h[w][1]});
    //         s[1] += std::max({f[w][1], g[w][0], g[w][1], h[w][0], h[w][1]});
    //     }

    //     const ll valv = std::max(d[u] + std::max(g[v][0], h[v][0]), -d[u] + std::max(g[v][1], h[v][1]));
    //     h[u][0] = std::max(h[u][0], valv + s[0]), h[u][1] = std::max(h[u][1], valv + s[1]);
    // }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &d[i]);
    for (int i = 2, x; i <= n; i++) scanf("%d", &x), son[x].push_back(i);

    dfs(1);
    printf("%lld\n", std::max({g[1][0], g[1][1], h[1][0], h[1][1]}));
    return 0;
}
```

---


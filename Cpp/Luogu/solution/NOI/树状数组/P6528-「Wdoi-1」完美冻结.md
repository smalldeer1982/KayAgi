# 「Wdoi-1」完美冻结

## 题目背景

琪露诺是一个喜欢研究数表的女孩子。

## 题目描述

琪露诺有 $n$ 个正整数 $a_1,a_2,...,a_n$，她会按照如下方式构造一个大小为 $n\times n$ 的数字表格：  

- 定义数表的左下角为 $(1,1)$，右上角为 $(n,n)$，从左向右数第 $x$ 列，从下向上数第 $y$ 行的位置为 $(x,y)$。在数表的每个位置填入数字 $0$，然后在每个 $(i,i) (1\le i\le n)$ 处填入 $a_i$  

- 枚举数表中的每一个 $2\times 2$ 大小的子矩阵，当子矩阵左下角和右上角的数字**都不为 $0$** 时，记该子矩阵中从左到右，从上到下的数字分别为 $a,b,c,d$，进行以下操作：  

	- 若 $a=0$，$d=0$，则在数表中 $a,d$ 所处的位置填入 $b+c$  
    - 若 $a=0$，$d\neq 0$，则在数表中 $a$ 所处的位置填入 $b+c-d$  
    - 若 $a\neq 0$，$d=0$，则在数表中 $d$ 所处的位置填入 $b+c-a$  
    
- 重复第二步操作直至数表中的每一个位置都填有**正整数**  。

- 最后，将数表中的每个数 $a_{ij}$ 变为 $\lfloor \frac{a_{ij}}{k} \rfloor $，其中 $k$ 是一给定常数，$\lfloor x \rfloor$ 表示不超过 $x$ 的最大整数。  

构造完 $n\times n$ 的巨大数表后，琪露诺会进行 $q$ 次查询，每次询问数表中以  $(x_1,y_1)$ 为左下角，$(x_2,y_2)$ 为右上角的子矩阵中所有数字的和。  

头脑简单的琪露诺想了一天又一天，却始终没有头绪，因此她找到了聪明的你帮她解决这个问题。  

当然，由于答案可能很大，你只需要输出答案对 $998244353$ 取模后的结果即可。

## 说明/提示

#### 样例 1 解释
第一步操作后的数表：  

$
\begin{bmatrix}
0 & 0 & 3 \cr  %\cr是换行功能
0 & 2 & 0  \cr
1 & 0 & 0
\end{bmatrix}
$  

进行一次第二步操作后的数表：  

$
\begin{bmatrix}
0 & 5 & 3 \cr  %\cr是换行功能
3 & 2 & 5  \cr
1 & 3 & 0
\end{bmatrix}
$  

进行两次第二步操作后的数表：   

$
\begin{bmatrix}
6 & 5 & 3 \cr  %\cr是换行功能
3 & 2 & 5  \cr
1 & 3 & 6
\end{bmatrix}
$  

进行第三步操作(对 $k=2$ 向下取整)后的数表：  

$
\begin{bmatrix}
3 & 2 & 1 \cr  %\cr是换行功能
1 & 1 & 2  \cr
0 & 1 & 3
\end{bmatrix}
$    

询问 `1 2 2 3` 的答案为 $1+1+3+2=7$  
询问 `1 1 3 3` 的答案为 $0+1+3+1+1+2+3+2+1=14$

#### 数据范围：   

对于 $100\%$ 的数据，$1 \le n,q \le 2\times 10^5$  ，$0 < a_i ,k \le 10^9$  ，$1 \le x_1 \le x_2 \le n$，$1 \le y_1 \le y_2 \le n$。

子任务编号 | $\max(n,q)$  | 特殊限制 | 分值
:-: | :-: | :-: | :-:
$1$ | $100$ | 无特殊限制 | $5$
$2$ | $500$ | 无特殊限制 | $5$
$3$ | $5000$ | 无特殊限制 | $10$
$4$ | $10^5$ | $q=1$ 且询问子矩阵为整个数表 | $20$  
$5$ | $10^5$ | $k=1$ | $15$
$6$ | $10^5$ | $k=2$ | $15$
$7$ | $2*10^5$ | 无特殊限制 | $30$  

**注意：本题采取捆绑测试**

## 样例 #1

### 输入

```
3 2 2
1 2 3
1 2 2 3
1 1 3 3```

### 输出

```
7
14```

## 样例 #2

### 输入

```
6 3 3
1 1 4 5 1 4
1 1 6 6
1 2 3 4
2 2 5 5```

### 输出

```
87
14
32```

# 题解

## 作者：x_angelkawaii_x (赞：11)

- 子任务 $1,2$  

按照题意模拟，构建出数表。查询时暴力枚举。  
复杂度 $\mathcal{O}(n^3+qn^2)$ ，期望得分 $10$ 分。  

- 子任务 $3$  

记 $(i,j)$ 位置处的数字为 $f_{ij}$

则   

$$f_{ij}=\lfloor \frac{\sum_{x=min(i,j)}^{max(i,j)}a_x}{k} \rfloor$$  

所以 $\mathcal{O}(n^2)$ 构造数表，查询时利用二维前缀和即可。  

时间复杂度为 $\mathcal{O}(n^2+q)$，期望得分 $20$ 分。

#### 过渡： 

对于之后的子任务，$n$ 非常大，所以我们很难还原出整个数表。 

为了方便起见我们不妨将问题转化到数列上：  

记 $a_i$ 前缀和为 $s_i$，对于询问 $l_1,r_1,l_2,r_2$，答案为  

$$\sum_{l_1\le i \le r_1}\sum_{l_2 \le j \le r_2}\lfloor \frac{s_j-s_{i-1}}{k} \rfloor$$

根据 $[l_1,r_1]$，$[l_2,r_2]$ 两个区间的位置关系(相离，相交，包含)，我们有不同的容斥策略将所求化为若干个 $\sum_{l\le i \le r}\sum_{l \le j \le r}\lfloor \frac{s_j-s_{i-1}}{k} \rfloor$ 的形式，此处留给读者自行思考。

所以经过一番转化，我们的问题转化成了如下形式，即求解  

$$\sum_{l\le i \le r}\sum_{l \le j \le r}\lfloor \frac{s_j-s_{i-1}}{k} \rfloor$$  

- 子任务 $5$  

$k=1$，要求求解

$$\sum_{l\le i \le r}\sum_{l \le j \le r}( s_j-s_{i-1} )$$    

简单算一下每个 $s$ 的出现次数即可。  

复杂度 $O(q)$ ，期望得分 $35$分。


- 子任务 $6$  

$k=2$，每次询问求解的式子为 $\sum_{i=l}^{r}\sum_{j=i}^{r}\lfloor \frac{s_j-s_{i-1}}{2} \rfloor$，可以很自然地想到分类讨论 $s_j$ 和 $s_{i-1}$ 同奇，同偶或一奇一偶三种情况  

考虑另 $c_i= \lfloor \frac{s_i}{2} \rfloor,d_i=s_i\bmod 2$，则 $s_i=2c_i+d_i$，此时 $\lfloor \frac{s_j-s_{i}}{2} \rfloor=(c_j-c_i)-[d_j<d_i]$  

发现作差的两个 $s$ 是错位的，所以我们进行简单地容斥：  

$$\sum_{i=l}^{r}\sum_{j=i}^{r}\lfloor \frac{s_j-s_{i-1}}{2} \rfloor=\sum_{i=l}^{r-1}\sum_{j=i+1}^{r-1}\lfloor \frac{s_j-s_i}{2} \rfloor+\sum_{j=l}^{r}\lfloor  \frac{s_j-s_{l-1}}{2}\rfloor+\sum_{i=l}^{r}\lfloor  \frac{s_r-s_{i-1}}{2}\rfloor-\lfloor  \frac{s_r-s_{l-1}}{2}\rfloor$$ 

记 $p_i=\sum_{j=1}^{i}c_j$，$P_i=\sum_{j=1}^{i}p_j$，$C_i=\sum_{j=1}^{i}j*c_j$

$$\sum_{j=l}^{r}\lfloor  \frac{s_j-s_{l-1}}{2}\rfloor=\sum_{j=l}^{r}((c_j-c_{l-2})-[d_j<d_{l-1}])=p_r-p_{l-1}-(r-l+1)c_{l-1}-\sum_{j=l}^{r}[d_j<d_{l-1}]$$  

由于 $d_i$ 只有 $01$ 两种取值，因此开一个记录 $1$ 位置的树状数组通过差分即可求出$\sum_{j=l}^{r}[d_j<d_{l-1}]$  

$\sum_{i=l}^{r}\lfloor  \frac{s_r-s_{i-1}}{2}\rfloor$ 求解方式类似，不做展开  


$$\sum_{i=l}^{r}\sum_{j=i+1}^{r}\lfloor \frac{s_j-s_i}{2} \rfloor=\sum_{i=l}^{r}\sum_{j=i+1}^{r}((c_j-c_i)-[d_j<d_i])=\sum_{i=l}^{r}\sum_{j=i+1}^{r}(c_j-c_i)-\sum_{i=l}^{r}\sum_{j=i+1}^{r}[d_j<d_i]$$   

左式 $=\sum_{i=l}^{r}(\sum_{j=i+1}^{r}c_j-(r-i)c_i)=\sum_{i=l}^{r}(p_r-p_i-r*c_i+i*c_i)=(r-l+1)p_r-(P_r-P_{l-1})-r(p_r-p_{l-1})+C_r-C_{l-1}$  

由于 $d_i$ 只有 $01$ 两种取值，因此使用线段树维护区间 $0,1$ 的个数和逆序对个数即可求出右式  

复杂度 $\mathcal{O}(n\log n)$，期望得分 $50$ 分  

- 子任务 $4$  

$q=1$ 且询问区间为 $[1,n]$  

仿照子任务6，求出 $c_i= \lfloor \frac{s_i}{k} \rfloor,d_i=s_i\bmod k$，化简步骤相同  

$\sum_{j=l}^{r}[d_j<d_{l-1}]$ 即全局逆序对  

与子任务 $4$ 算法结合，期望得分 $70$ 分
 

- 子任务 $5$  

在 $6,4$ 的基础上，算法的瓶颈是需要求出 $\sum_{i=l}^{r}\sum_{j=i+1}^{r}[d_j<d_i]$，即区间逆序对个数  

由于询问不强制在线，可以使用二次离线莫队 $\mathcal{O}(n\sqrt{n})$ 求解  

其次就是 $\sum_{j=l}^{r}[d_j<d_{l-1}]$ 的求解，这个可以将 $d_i$ 和询问排序后用双指针+树状数组的方法 $\mathcal{O}(n\log n)$ 求解  

时间复杂度 $\mathcal{O}(n\sqrt{n}+n\log n)$，空间复杂度 $\mathcal{O}(n)$，可以通过此题  

---

## 作者：Suiseiseki (赞：4)

官方题解讲解得十分详细。

但是我将官方题解简化了一下，去掉了一些复杂的式子和显然的部分，希望可以节省大家的阅读时间。

题目大意：求 $\sum_{l_1\leq i \leq r_1}\sum_{l_2\leq j \leq r_2}\left \lfloor \frac{\sum_{l=\min(i,j)}^{\max(i,j)} a_l}{k} \right \rfloor$

为了之后的方便，我们通过~~大量的~~分类讨论来将整个问题转换为 $\sum_{l\leq i \leq r}\sum_{l\leq j\leq r}\left \lfloor \frac{\sum_{l=\min(i,j)}^{\max(i,j)} a_l}{k} \right \rfloor$

我们考虑对 $a$ 做前缀和，令其前缀和数组为 $s$ ，所以我们就是要求 $\left \lfloor \frac{s_j-s_{i-1}}{k}\right \rfloor$ 这个东西，我们考虑令 $c_i=\left \lfloor \frac{s_i}{k}\right \rfloor,d_i=s_i\mod k$

那么我们就可以把原来的式子给换成这个样子：$c_j-c_{i-1}-[d_j<d_{i-1}]$

然后我们发现 $\sum_{l\leq i\leq r}\sum_{l\leq j\leq r}c_j-c_{i-1}$ 这种东西是可以 $O(n)$ 预处理 $O(1)$ 求的。

接下来就只剩下 $\sum_{l\leq i\leq r}\sum_{l\leq j\leq r}[d_j<d_{i-1}]$ 了，我们把第 $l-1$ 位和第 $r$ 位单独拎出来，用主席树求一下，剩下的东西 $l\sim r-1$ 中的区间逆序对，直接套个板子即可。

时间复杂度 $O(n\sqrt{q}+q\log n)$ 。

代码可以去我的博客查看：[洛谷P6528 「Wdoi-1」完美冻结 题解](https://www.cnblogs.com/withhope/p/14148542.html)

---

## 作者：lzyqwq (赞：2)

记数表为 $A$，先说结论：

$$A_{x,y}=\left\lfloor\dfrac{\sum_{i=\min\{x,y\}}^{\max\{x,y\}}a_i}{k}\right\rfloor$$

---
$\bold{Proof}$

其他题解未免太草率了。

感性理解一下这个过程，容易发现第 $i$ 次第二步操作填的位置为斜率为 $1$ 截距为 $i$ 和 $-i$ 的两条直线与矩形的交。

**为了不失严谨性，考虑归纳法证明。**

结合题意，认为枚举 $2\times 2$ 的矩形顺序为从左至右、从下至上。大致思路是先对操作的轮数进行归纳，每一轮内再对行数进行归纳。

即我们要证明：**第 $t$ 次第二步操作后，不为 $0$ 的区域为 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x+b,b\in[-t,t]\}$，且 $A_{x,y}=\sum\limits_{i=\min\{x,y\}}^{\max\{x,y\}}a_i$。**

当 $t=0$ 时（即初始填对角线的操作后），显然成立。

若当 $t=m$ 时成立，则当 $t=m+1$ 时：

> 这里需要证明，**枚举完第 $v$ 行后，不为 $0$ 的区域为 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x+b,b\in[-m,m]\}\cup \{(x,y)\,|\,x\in[1,v-m],y\in[1,n],y=x+m+1\}\cup \{(x,y)\,|\,x\in[1,n],y\in[1,v],y=x-m-1\}$，且符合上述式子**。
> 
> 第一个集合是上一次操作留下的结果，肯定存在。我们只需要证明其交上的两个集合中的点被填充即可。以下讨论中若出现点坐标不存在的情况，直接忽略即可。因为我们的非 $0$ 区域已经对矩形求交。
> 
> 当 $v=0$（即操作刚开始时），显然成立。
>
> 若当 $v=p$ 时成立，则 $v=p+1$ 时：
>
> > 
> > - 若矩形左下角列坐标 $u\in [1,p-m]$，则此时其右上角 $(u+1,p+2)$ 不在非 $0$ 区域内，不会做任何事情。
> > - 若矩形左下角列坐标 $u=p-m+1$，则此时她和其右上角 $(p-m+2,p+2)$ 均在非 $0$ 区域内，其正上方 $(p-m+1,p+2)$ 不在非 $0$ 区域内。
> >   - 若 $m=0$，则其正右方 $(p+2,p+1)$ 也不在非 $0$ 区域内，会填充 $(p+1,p+2),(p+2,p+1)$ 这两个位置，那么有 $A_{p+1,p+2}=A_{p+2,p+1}=A_{p+1,p+1}+A_{p+2,p+2}=a_{p+1}+a_{p+2}$。
> >   - 否则，其正右方 $(p-m+2,p+1)$ 在非 $0$ 区域内，仅会填充 $(p-m+1,p+2)$ 这个位置，注意到这些位置均满足列坐标不超过行坐标，有：
> >   
> >     $$\begin{aligned}A_{p-m+1,p+2}&=A_{p-m+1,p+1}+A_{p-m+2,p+2}-A_{p-m+2,p+1}\\&=\sum\limits_{i=p-m+1}^{p+1}a_i+\sum\limits_{i=p-m+2}^{p+2}a_i-\sum\limits_{i=p-m+2}^{p+1}a_i\\&=\sum\limits_{i=p-m+1}^{p+2}a_i\end{aligned}$$
> >     
> >   均能使得结论成立。
> >  - 若矩形左下角列坐标 $u\in(p-m+1,p+m+1)$，则矩形内四个点均位于非 $0$ 区域内。不会做任何事情。
> >  - 至于 $u=p+m+1$ 和 $u\in (p+m+1,n]$ 的情况，分别和第二、第一种情况是类似的，此处不再赘述。
>
> 那么我们会发现新被填充的点为 $(p-m+1,p+2)$ 和 $(p+m+2,p+1)$，分别满足 $x\in[1,p+1-m],y\in[1,n],y=x+m+1$ 和 $x\in[1,n],y\in[1,p+1],y=x-m-1$。且填上的数也满足结论。故上述结论成立。

所以，对于第 $m+1$ 次第二步操作结束，即枚举完第 $n-1$ 行后，不为 $0$ 的区域为 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x+b,b\in[-m,m]\}\cup \{(x,y)\,|\,x\in[1,n-1-m],y\in[1,n],y=x+m+1\}\cup \{(x,y)\,|\,x\in[1,n],y\in[1,n-1],y=x-m-1\}$，不难发现后面两个集合分别为 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x+m+1\}$ 和 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x-m-1\}$，因为后面的条件在此情境的约束下是等价的。那么可以合并一下。

**所以第 $m+1$ 次第二步操作后的非 $0$ 区域为 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x+b,b\in[-m-1,m+1]\}$，且 $A_{x,y}=\sum\limits_{i=\min\{x,y\}}^{\max\{x,y\}}a_i$。**

因此上述结论成立。综上第 $n-1$ 次第二步操作后的非 $0$ 区域为 $\{(x,y)\,|\,x\in[1,n],y\in[1,n],y=x+b,b\in[-n+1,n-1]\}$，且 $A_{x,y}=\sum\limits_{i=\min\{x,y\}}^{\max\{x,y\}}a_i$。不难发现这个区域就是整个矩形。

那么对所有元素除以 $k$ 下取整后，就得到了：

$$A_{x,y}=\left\lfloor\dfrac{\sum_{i=\min\{x,y\}}^{\max\{x,y\}}a_i}{k}\right\rfloor$$

$\mathcal{Q.E.D.}$

---

那么一次查询 $(x_1,y_1,x_2,y_2)$ 就是求：

$$\sum\limits_{x=x_1}^{x_2}\sum\limits_{y=y_1}^{y_2}\left\lfloor\dfrac{\sum_{i=\min\{x,y\}}^{\max\{x,y\}}a_i}{k}\right\rfloor$$

别的题解都一笔带过拆贡献的部分，这里再详细讲一下。一般的矩形区域查询我们一般差分成四个以 $(1,1)$ 为左下角的矩形。现在只需要支持查询：

$$\sum\limits_{x=1}^X\sum\limits_{y=1}^Y\left\lfloor\dfrac{\sum_{i=\min\{x,y\}}^{\max\{x,y\}}a_i}{k}\right\rfloor$$

然后注意到 $A_{x,y}$ 是关于 $y=x$ 对称的，因此查询 $(X,Y)$ 和查询 $(Y,X)$ 等价。所以不妨认为 $X\le Y$。

当 $X=Y$ 时，查询区域形如红色边围成的矩形：

![](https://cdn.luogu.com.cn/upload/image_hosting/k24hozto.png?x-oss-process=image/resize,m_lfit,h_1700,w_2205)

根据对称性，$(1,1)-(1,X)-(X,X)$ 这个等腰直角三角形区域和 $(1,1)-(X,1)-(X,X)$ 的和相等，因此答案为两倍的 $(1,1)-(1,X)-(X,X)$ 区域的和减去对角线 $(1,1)-(X,X)$ 的和。

当 $X<Y$ 时，查询区域形如红色边围成的矩形：

![](https://cdn.luogu.com.cn/upload/image_hosting/4kzq58a4.png?x-oss-process=image/resize,m_lfit,h_1070,w_2205)

答案为等腰直角三角形 $(1,1)-(X,1)-(X,X)$ 加上一个内角为 $\dfrac{\pi}{4}$ 的直角梯形 $(1,1)-(1,Y)-(X,Y)-(X,X)$ 减去对角线 $(1,1)-(X,X)$。$(1,1)-(X,1)-(X,X)$ 类似对称过去即可，直角梯形可以差分成等腰直角三角形 $(1,1)-(1,Y)-(Y,Y)$ 减去 $(X+1,X+1)-(X+1,Y)-(Y,Y)$。

对角线查询是容易的，只需要维护 $a_i$ 的前缀和 $s_i$。其余的查询形如斜边与 $y=x$ 重合且直角顶点在 $y=x$ 上方的等腰直角三角形区域。记其左下角和右上角分别为 $(l,l)$ 和 $(r,r)$。那么我们要查询的就是：

$$\sum\limits_{i=l}^r\sum\limits_{j=i}^r\left\lfloor\dfrac{s_j-s_{i-1}}{k}\right\rfloor$$

令 $i\leftarrow i-1$，则变成：

$$\sum\limits_{i=l-1}^{r-1}\sum\limits_{j=i+1}^r\left\lfloor\dfrac{s_j-s_{i}}{k}\right\rfloor$$

记 $c_i=\left\lfloor\dfrac{s_i}{k}\right\rfloor,d_i=s_i\bmod k$。则 $\left\lfloor\dfrac{s_j-s_i}{k}\right\rfloor=c_j-c_i-[d_i>d_j]$。就考虑除以 $k$ 之后整数部分是 $c_j-c_i$，小数部分是 $\dfrac{d_j-d_i}{k}$，而根据余数的性质这个值在 $(-1,1)$ 之间，大于等于 $0$ 小数部分被舍去，小于 $0$ 时使得答案不足 $c_j-c_i$ 却仍然超过 $c_j-c_i-1$。

那么查询结果为：

$$\sum\limits_{i=l-1}^{r-1}\sum\limits_{j=i+1}^r(c_j-c_i)-\sum\limits_{i=l-1}^{r-1}\sum\limits_{j=i+1}^r[d_i>d_j]$$

后者是区间逆序对个数，莫二离或分块均可。至于前者，考虑拆成：

$$\sum\limits_{i=l-1}^{r-1}\sum\limits_{j=i+1}^rc_j-\sum\limits_{i=l-1}^{r-1}\sum\limits_{j=i+1}^r c_i$$

考虑每个数的被加和减的次数，变成：

$$\sum\limits_{i=l}^rc_i(i-l+1)-\sum\limits_{i=l-1}^{r-1}c_i(r-i)$$

维护 $c_i\cdot i$ 和 $c_i$ 的前缀和即可单次 $\mathcal{O}(1)$。

但是我们这样拆贡献会导致一个询问被拆成四个矩形，每个矩形再被拆成若干个等腰直角三角形。实际询问数量会非常多，大概率会被卡常。但是你注意到每个矩形拆出来的等腰直角三角形至多有一个的左下角不为 $(1,1)$。对于这些等腰直角三角形使用根号算法，其余的直接扫一遍右端点用 BIT 维护即可 $\mathcal{O}(n\log n)$。这样常数大大减小。

还有根号算法部分一步一取模会非常慢，尤其是像我这种封装 `modint` 的大常数选手。所以考虑先用 `long long` 存下答案，再取模。

那么做完了。认为 $n,q$ 同阶，时间复杂度 $\mathcal{O}(n\sqrt n)$，空间复杂度 $\mathcal{O}(n)$。


```cpp
#include <bits/stdc++.h>
using namespace std; typedef long long ll;
const int N = 200005, M = 998244353; ll s[N], f[N << 2];
int n, q, k, a[N], d[N], cq, b[N], m, rv[N << 2], V, p1[N], p2[N];
struct MI {
	int a; MI(ll x = 0) { a = (x % M + M) % M; }
	void in() { cin >> a; a %= M; } void out(char c) { cout << a << c; }
	MI operator+(const MI &o) const { return MI(a + o.a); }
	MI operator-(const MI &o) const { return MI(a - o.a); }
	MI operator*(const MI &o) const { return MI(1ll * a * o.a); }
	void operator+=(const MI &o) { a = (a + o.a) % M; }
	void operator-=(const MI &o) { a = (a - o.a + M) % M; }
} ans[N], c[N], pr[N], c0[N], c1[N], p[N];
struct QR { int l, r, id, v; } qr[N << 2]; vector<QR> g[N], h[N];
struct BLK {
	int a[N], t[N], B, bl[N], br[N], be[N], n;
	void I(int m) {
		n = m; B = sqrt(n); for (int i = 1; i <= n; ++i) be[i] = (i - 1) / B + 1;
		for (int i = 1; i <= be[n]; ++i)
			bl[i] = br[i - 1] + 1, br[i] = min(n, i * B);
	}
	void U(int x, int v) {
		for (int i = x; i <= br[be[x]]; ++i) a[i] += v;
		for (int i = be[x] + 1; i <= be[n]; ++i) t[i] += v;
	}
	int Q(int l, int r) { return a[r] + t[be[r]] - a[l - 1] - t[be[l - 1]]; }
} ds;
struct BIT {
	int a[N]; int n; void I(int m) { n = m; }
	void U(int x, int v) { for (; x <= n; x += x & -x) a[x] += v; }
	int Q(int l, int r) {
		int o = 0; if (l > r) return 0; for (; r; r -= r & -r) o += a[r];
		for (--l; l; l -= l & -l) o -= a[l]; return o;
	}
} tr;
MI sa(int l, int r) { return p[r] - p[l - 1]; }
MI s0(int l, int r) { return l ? c0[r] - c0[l - 1] : c0[r]; }
MI s1(int l, int r) { return l ? c1[r] - c1[l - 1] : c1[r]; }
MI C(int l, int r) {
	return l >= r ? MI() : s1(l + 1, r) - MI(l) * s0(l + 1, r) +
	                       s1(l, r - 1) - MI(r) * s0(l, r - 1);
}
void ps(int x, int y, int v, int i) {
	if (!x || !y) return; if (x > y) swap(x, y);
	ans[i] += MI(v) * (C(0, x) + C(0, y) - pr[x] - pr[y] - sa(1, x));
	if (x < y) { ans[i] -= MI(v) * C(x, y); rv[++cq] = i; qr[cq] = {x, y, cq, v}; }
}
int main() {
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cin >> n >> q >> k;
	for (int i = 1; i <= n; ++i)
		cin >> a[i], s[i] = s[i - 1] + a[i], c[i] = MI(s[i] / k),
		b[i] = d[i] = s[i] % k, p[i] = p[i - 1] + MI(a[i] / k),
		c0[i] = c0[i - 1] + c[i], c1[i] = c1[i - 1] + MI(i) * c[i];
	b[n + 1] = 0; stable_sort(b + 1, b + n + 2);
	m = unique(b + 1, b + n + 2) - b - 1; ds.I(m); tr.I(m);
	for (int i = 0; i <= n; ++i)
		d[i] = lower_bound(b + 1, b + m + 1, d[i]) - b,
		pr[i] = (i ? pr[i - 1] + tr.Q(d[i] + 1, m) : 0),
		p1[i] = tr.Q(d[i] + 1, m), p2[i] = tr.Q(1, d[i] - 1), tr.U(d[i], 1);
	for (int i = 1, l, r, x, y; i <= q; ++i)
		cin >> l >> x >> r >> y, ps(r, y, 1, i), ps(l - 1, y, -1, i),
		ps(r, x - 1, -1, i), ps(l - 1, x - 1, 1, i);
	V = n / max((int)sqrt(cq), 1);
	stable_sort(qr + 1, qr + cq + 1, [&](QR x, QR y) {
		return x.l / V != y.l / V ? x.l / V < y.l / V :
			                        x.l / V < y.l / V ? x.r < y.r : x.r > y.r;
	});
	for (int i = 1, l = 1, r = 0; i <= cq; ++i) {
		if (r < qr[i].r) {
			g[l - 1].emplace_back(QR{r + 1, qr[i].r, i, -1});
			while (r < qr[i].r) f[i] += p1[++r];
		}
		if (l > qr[i].l) {
			h[r].emplace_back(QR{qr[i].l, l - 1, i, 1});
			while (l > qr[i].l) f[i] -= p2[--l];	
		}
		if (r > qr[i].r) {
			g[l - 1].emplace_back(QR{qr[i].r + 1, r, i, 1});
			while (r > qr[i].r) f[i] -= p1[r--];
		}
		if (l < qr[i].l) {
			h[r].emplace_back(QR{l, qr[i].l - 1, i, -1});
			while (l < qr[i].l) f[i] += p2[l++];
		}
	}
	for (int i = 0; i <= n; ++i) {
		ds.U(d[i], 1);
		for (auto [l, r, k, v] : g[i])
			for (int j = l; j <= r; ++j) f[k] += v * ds.Q(d[j] + 1, m);
		for (auto [l, r, k, v] : h[i])
			for (int j = l; j <= r; ++j) f[k] += v * ds.Q(1, d[j] - 1);
	}
	for (int i = 1; i <= cq; ++i)
		f[0] += f[i], ans[rv[qr[i].id]] += MI(f[0] * qr[i].v);
	for (int i = 1; i <= q; ++i) ans[i].out('\n'); return 0;
}
```

---

## 作者：IdnadRev (赞：2)

好像……挺简单的？

手玩，可以发现位置 $(i,j)$ 上的数字为 $b_{i,j}=\lfloor\frac{\sum_{k=\min(i,j)}^{\max(i,j)}}{k}\rfloor$。

可以发现这个数表是对称的，$(x_1,y_1,x_2,y_2)$ 四个变量的矩形不好处理，可以通过容斥将其表示为若干个斜边与主对角线重合的三角形的加减。

对数列做个前缀和，问题转化为：

$$\sum_{i=l}^r\sum_{j=l}^r\lfloor\frac{s_{max(i,j)}-s_{\min(i,j)-1}}{k}\rfloor$$

将 $s$ 数列除以 $k$ 的商拿出来单独算（显然可以 $O(n)-O(1)$），而 $s$ 的余数相减只会产生 $-1$ 或者 $0$ 的贡献，不难发现其为区间逆序对形式，二次离线莫队即可。

复杂度 $O(n\sqrt n)$。

---


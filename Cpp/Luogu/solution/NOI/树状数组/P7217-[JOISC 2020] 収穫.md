# [JOISC 2020] 収穫

## 题目背景

JOI 君是 IOI 庄园的庄园主。

## 题目描述

现在 IOI 庄园有 $N$ 名员工，在周长为 $L$ 的湖的湖岸边有 $M$ 棵苹果树。

第 $i$ 名员工从湖的最北点顺时针走了 $A_i$ 米，第 $i$ 棵苹果树长在从湖的最北点顺时针的 $B_i$ 米。

因为特殊原因，每棵苹果树上最多长一个苹果，初始时刻每棵苹果树上都有 $1$ 个苹果，如果一棵树上的苹果被摘掉了，在恰好 $C$ s 后会长出一个苹果。

每名员工在初始时刻都在自己原本的位置，每过一个时刻就会顺时针走 $1$ 米，遇到有成熟苹果的苹果树就会把苹果摘下来。

现在 JOI 君给定了 $Q$ 个询问，第 $i$ 个询问为：

- 询问第 $V_i$ 个员工在时刻 $T_i$ 结束后收获到几个苹果。

## 说明/提示

#### 样例 1 解释

- 在时刻 $1$：
	- 员工 $2$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
    - 员工 $3$ 到达第 $1$ 棵苹果树，并采摘了成熟的苹果
- 在时刻 $3$：
	- 员工 $2$ 到达第 $1$ 棵苹果树，但没有成熟的苹果

到时刻 $3$ 结束后，员工 $2$ 共采摘了 $1$ 个苹果，对应样例 $1$ 的第 $2$ 个询问。

- 在时刻 $4$：
	- 员工 $1$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
- 在时刻 $6$：
	 - 员工 $1$ 到达第 $1$ 棵苹果树，并采摘了成熟的苹果
     - 员工 $3$ 到达第 $2$ 棵苹果树，但没有成熟的苹果

到时刻 $7$ 结束后，员工 $1$ 共采摘了 $2$ 个苹果，对应样例 $1$ 的第 $1$ 个询问。

- 在时刻 $8$：
	- 员工 $2$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
    - 员工 $3$ 到达第 $1$ 棵苹果树，但没有成熟的苹果

到时刻 $8$ 结束后，员工 $3$ 共采摘了 $1$ 个苹果，对应样例 $1$ 的第 $3$ 个询问。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N,M,Q \le 3000$|$5$|
|$2$|$T_i \ge 10^{15}$|$20$|
|$3$|无|$75$|

对于 $100\%$ 的数据，$1 \le N,M,Q \le 2 \times 10^5$，$N+M \le L$，$1 \le C,L \le 10^9$，$0 \le A_i,B_i < L$，$A_i<A_{i+1}$，$B_i<B_{i+1}$，$A_i \ne B_i$，$1 \le V_i \le N$，$1 \le T_i \le 10^{18}$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day3 B 収穫](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day3/harvest.pdf)。

## 样例 #1

### 输入

```
3 2 7 3
1 4 6
0 5
3
1 7
2 3
3 8```

### 输出

```
2
1
1```

## 样例 #2

### 输入

```
5 3 20 6
0 4 8 12 16
2 11 14
9
4 1932
2 93787
1 89
5 98124798
1 2684
1 137598
3 2
3 8375
4 237```

### 输出

```
146
7035
7
7359360
202
10320
0
628
18```

## 样例 #3

### 输入

```
8 15 217 33608
0 12 71 96 111 128 152 206
4 34 42 67 76 81 85 104 110 117 122 148 166 170 212
14
2 223544052420046341
3 86357593875941375
4 892813012303440034
1 517156961659770735
7 415536186438473633
6 322175014520330760
7 557706040951533058
6 640041274241532527
5 286263974600593111
8 349405886653104871
1 987277313830536091
5 989137777159975413
2 50689028127994215
7 445686748471896881```

### 输出

```
33230868503053
3
5
1
123542793648997
8
165811220737767
8
7
1
1
7
7535161012043
132506837660717```

# 题解

## 作者：wrpwrp (赞：11)

[My Blog](https://www.cnblogs.com/clover4/p/15521885.html)
### 题目大意
>  [Problem Link](https://loj.ac/p/3278)

> IOI 农场是一个种植苹果的农场，以位于一个巨大的环形湖周边而闻名。
> 在 IOI 农场，共有 $N$ 个员工，从 $1$ 到 $N$ 标号。共有 $M$ 棵苹果树，从 $1$ 到 $M$ 标号。湖的周长为 $L$ 米。
> 在初始时刻，第 $i$ ($1 \leq i \leq N$) 位员工站在离湖最北端顺时针 $A_i \,\mathrm m$ 米的位置，第 $j$ ($1 \leq j \leq M$) 棵苹果树在离湖最北端顺时针 $B_i \,\mathrm m$ 的位置。保证这 $N + M$ 个整数 $A_i, B_i$ 互不相同。
> 由于 IOI 农场苹果树是经过改良的特殊品种，一棵树同时只能结一个苹果。同时，如果一棵树上的苹果被摘掉了，在恰好 $C \,\mathrm s$ 后会长出一个苹果。
> 在初始时刻，每棵树上都有一个苹果，同时每个员工开始沿着顺时针方向移动。员工的移动速度是 $1 \,\mathrm{m/s}$。如果一个员工在某一时刻到达了一颗长有苹果的苹果树，他会摘掉这个苹果 (如果在到达时恰好长出苹果，员工也会摘掉)。这里我们忽略员工摘苹果的时间。
> K 主席是 IOI 农场的股东。因为你是 IOI 农场的一名管理人员，K 主席会不断问你每个员工的工作效率。更一般的，K 主席会有 $Q$ 个问题，第 $k$ ($1 \leq k \leq Q$) 个问题的形式如下：
> 询问前 $T_k \,\mathrm s$ 中，第 $V_k$ 个员工一共收获了多少个苹果 (注意包含第 $T_k \,\mathrm s$ 末收获的苹果)。
> 请编写一个程序来回答这些询问。

### 题解
很震撼的题。

首先默认把 $A, B$ 排序。

#### 问题转化

观察到这个 $C$ 是一个定值，也就是苹果的**生长周期**是一个定值。我们考虑一下这个定值带给了我们什么想法。

因为人的移动速度是相同的， $C$ 为定值，那么一个人摘下这个苹果以后，下一个摘这个苹果的人是固定的。不妨我们令某个人 $i$ 摘完以后下一个摘这个苹果的人的编号是 $p_i$ 。那么我们连边 $i \rightarrow p_i $ 。 

那么我们这样就可以得到一棵关于人的基环内向树。

考虑 $p_i$ 如何计算。在 $A$ 中查找在 $\mod L$ 意义下 $A_i - C$ 前的第一个数的下标就是 $p_i$， 用一个 $\text{set}$ 维护即可。

然后我们考虑确定这棵树的边权， 不妨令边权 $w_i$ 表示两个人之间摘到苹果的时间差， 那么 $w_i$ 是满足如下条件的最小正整数。

+ $w_i \geq C$
+ $w_i \equiv A_i - A_{p_i} \pmod L$

可以直接计算得出 $w_i = \lfloor\frac{C + L - ((A_i - A_{p_i} + L) \mod L) - 1}{L}\rfloor \times L + A_i - A_{p_i}$ 。

可以发现， 一个苹果的路径只会在一棵基环树上面跑， 我们现在对每棵基环树分开考虑。

对于一个人， 我们对于其是否在基环树的环上分开讨论。

#### 对于不在环上的人的处理

不妨对每棵苹果树处理出一个数对 $(v_0, t_0)$ 表示 $t_0$ 时刻 $v_0$ 号人第一次摘下了这个苹果。那么现在我们的问题就是求某个点 $v$ 的子树里有多少数对 $(v_0, t_0)$ 满足 $t_0 + \text{dist}(v_0, v) \leq t$ ， 也就是 $t_0 + dep_{v_0} \leq t + dep_v$ 。加上 $\text{dfs}$ 序的限制，可以在离散化以后二维数点求出。

#### 对于在环上的人的处理

同样考虑处理一个数对 $(v_0, t_0)$ 表示 $t_0$ 时刻 $v_0$ 号人第一次**在环上**摘下了这个苹果。我们可以倍增处理这个东西。然后我们开始讨论这棵基环树的环。不妨设这个环的形态是 $c_0 \leftarrow c_1 \leftarrow c_2 \leftarrow \cdots \leftarrow c_{s - 1} \leftarrow c_s(c_0)$ 。记 $dep_i$ 表示环上边长的前缀和，  $P$ 表示环长。

设这个数对为 $(c_i, t0)$ ， 人的位置为 $c_j$， 不妨设 $i \geq j$ 。那么这个苹果对这个人的贡献如下

$$\max\{0, \lfloor \frac{t - (t_0 + dep_i - dep_j}{P} \rfloor + 1\}$$

考虑对贡献右边进行变化

$$\lfloor \frac{t + dep_j - (t_0 + dep_i)}{P} \rfloor + 1$$

这样一棵苹果树对应一个参数 $\delta_t = t_0 + dep_i$ ， 一个人对应一个参数 $\delta_y = t + dep_j$ 。由于有对 $P$ 做除法的操作， 不妨按照套路，设 $\delta_t = P \times q_t + r_t, \delta_y = P \times q_y + r_y$ 。带进原式得
$$\lfloor\frac{\delta_y - \delta_t}{P}\rfloor = \lfloor \frac{P\times(q_y - q_t) + (r_y - r_t)}{P}\rfloor + 1 = q_y - q_t + [r_y \geq r_t]$$

那么可以先对于 $q_y \geq q_t$ 的点， 求出$q_y - q_t$之和， 然后每次求有多少点满足 $r_y \geq r_t$ 。同样是一个二维数点。

然后再考虑 $i < j$ 的情况，发现把式子化简以后就是所有答案为正数的情况下答案减少了$1$。 那么我们把 $i < j$ 的情况和前面同等考虑， 然后减去满足 $i < j, t_0 + dep_i \leq t + dep_j$ 的点对个数即可。

所有询问全部离线树状数组处理， 时间复杂度 $O(N \log N)$ 。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define lep(i, l, r) for(int i = (l); i <= (r); i ++)
#define rep(i, l, r) for(int i = (l); i >= (r); i --)
#define Lep(i, l, r) for(int i = (l); i <  (r); i ++)
#define Rep(i, l, r) for(int i = (l - 1); i >= (r); i --)
#define pb push_back
#define fi first
#define se second

using i64 = long long;
using uint = unsigned int;
using ui64 = unsigned long long;
using pii = pair<int, int>;
using vi = vector<int>;

namespace io {
	struct io {
		io() {
            ios :: sync_with_stdio(false); 
            cin.tie(0); cout.tie(0);
        }
	} unname;
    struct read {
        operator int () { int x; cin >> x; return x; }
        operator i64 () { i64 x; cin >> x; return x; }
        operator char () { char x; cin >> x; return x; }
        operator double () { double x; cin >> x; return x; }
        operator string () { string x; cin >> x; return x; }
    } rd;
} ;

using io :: rd;

const int N = 4e5 + 10;

namespace Unique {
    vector<i64> unique(vector<i64> &vec) {
        sort(vec.begin(), vec.end());
        auto end = unique(vec.begin(), vec.end());
        vector<i64> res;
        for (auto it = vec.begin(); it != end; ++ it) res.push_back(* it);
        return res;
    }
} ;

#define lowbit(x) (x & -x)

struct Bit {
    i64 c[N];
    vector<int> bck;
    void upd(int x, i64 y) {
        bck.push_back(x);
        for (; x < N; x += lowbit(x)) c[x] += y;
    }
    i64 qry(int x) {
        i64 ans = 0;
        for (; x; x -= lowbit(x)) ans += c[x];
        return ans;
    }
    i64 qry(int l, int r) { return qry(r) - qry(l - 1); }
    void clr(int x) {
        for (; x < N; x += lowbit(x)) c[x] = 0;
    }
    void clr() {
        for (auto x : bck) clr(x); bck.clear(); //n = 0;
    }
} bt;

#undef lowbit

int n, m, L, C;

inline int reduce(int x, int mod) { return (x % mod + mod) % mod; }

int A[N], B[N];
int p[N];
vector<pair<int, int> > e[N];

int bel[N], tree_number, root[N], sz[N], number, dfn[N], oncir[N], fa[N][20], lg[N];
i64 dep[N], ew[N];

void dfs(int x, int fx) {
    dfn[x] = ++ number; sz[x] = 1; bel[x] = tree_number; fa[x][0] = fx;
    Lep (i, 1, 20) fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for(auto p : e[x]) {
        int y = p.first, w = p.second;
        if(y == root[tree_number]) oncir[y] = 1, oncir[x] = 1;
        else dep[y] = dep[x] + w, dfs(y, x), oncir[x] |= oncir[y], sz[x] += sz[y];
    }
}

i64 Ans[N];
struct Three { i64 a, b, c; } ;
struct Qry {
    int v; i64 t; int id;
} ;
vector<Qry> qrys1, qrys2;

struct Point { i64 x, y; } ;
struct Line { i64 l1, r1, h, id, type; } ;
struct Mat { i64 l1, r1, l2, r2; } ;

/* Two-side count nodes */

namespace Count {
    vector<i64> twoside_count(vector<Mat> &mt, vector<Point> &pt) {
        vector<Line> lns;
        vector<i64> ans(mt.size());
        lep (i, 0, (int) mt.size() - 1) {
            lns.push_back( {mt[i].l1, mt[i].r1, mt[i].l2 - 1, i, -1} );
            lns.push_back( {mt[i].l1, mt[i].r1, mt[i].r2, i, 1} );
        }
        sort(lns.begin(), lns.end(), [] (Line a, Line b) { return a.h == b.h ? a.type < b.type : a.h < b.h; } );
        sort(pt.begin(), pt.end(), [] (Point a, Point b) { return a.y < b.y; } );
        int j = 0;
        bt.clr();
        for (auto p : lns) {
            while (j < pt.size() && pt[j].y <= p.h) {
                bt.upd(pt[j].x, 1); j ++;
            }
            ans[p.id] += p.type * bt.qry(p.l1, p.r1);
        }
        return ans;
    }
} 

signed main() {
#ifdef FILEIN
    freopen("1.in", "r", stdin);
#endif
    n = rd; m = rd; L = rd; C = rd;
    lep (i, 1, n) A[i] = rd;
    lep (i, 1, m) B[i] = rd;
    /* Build Tree */
    lep (i, 1, n) {
        auto it = upper_bound(A + 1, A + 1 + n, reduce(A[i] - C, L)) - A - 1;
        if(! it) it = n;
        p[i] = it;
        int w = (C + L - reduce(A[i] - A[p[i]], L) - 1) / L * L + reduce(A[i] - A[p[i]], L);
        e[p[i]].push_back( {i, w} );
        ew[i] = w;
    }
    lep (i, 2, n) lg[i] = lg[i >> 1] + 1;
    lep (i, 1, n) if (! bel[i]) {
        ++ tree_number;
        int j = i;
        while(! bel[j]) { bel[j] = tree_number; j = p[j]; }
        root[tree_number] = j;
        dfs(j, 0);
    } 
    int q = rd;
    lep (i, 1, q) {
        int v = rd; i64 t = rd;
        if(! oncir[v]) qrys1.push_back( {v, t, i} );
        else qrys2.push_back( {v, t, i} );
    }
    /* Not on circle */
    vector<pair<int, i64> > pairs;
    lep (i, 1, m) {
        auto it = upper_bound(A + 1, A + 1 + n, B[i]) - A;
        if (it == 1) it = n; else it --;
        int v0 = it, t0 = reduce(B[i] - A[it], L);
        pairs.push_back( {v0, t0} );
    }
    vector<Mat> mat;
    vector<Point> pnt;
    vector<i64> values, record;
    for (auto p : pairs) pnt.push_back( {dfn[p.first], p.second + dep[p.first]} ), values.push_back(p.second + dep[p.first]);
    for (auto p : qrys1) {
        mat.push_back( {dfn[p.v], dfn[p.v] + sz[p.v] - 1, 1, dep[p.v] + p.t} ), values.push_back(dep[p.v] + p.t);
    }
    values.push_back(1);
    values = Unique :: unique(values);
    for (auto &p : pnt) p.y = lower_bound(values.begin(), values.end(), p.y) - values.begin() + 1;
    for (auto &p : mat) 
        p.l2 = lower_bound(values.begin(), values.end(), p.l2) - values.begin() + 1, 
        p.r2 = lower_bound(values.begin(), values.end(), p.r2) - values.begin() + 1;
    record = Count :: twoside_count(mat, pnt); 
    int cnt = 0;
    for (auto &p : qrys1) Ans[p.id] = record[cnt], cnt ++;

    /* Is on circle */
    for (auto &p : pairs) {
        int &v0 = p.first;
        i64 &t0 = p.second;
        if (! oncir[v0]) {
            rep (i, 19, 0) if (fa[v0][i] && ! oncir[fa[v0][i]]) {
                t0 += dep[v0] - dep[fa[v0][i]];
                v0 = fa[v0][i];
            }
            t0 += ew[v0];
            v0 = fa[v0][0];
        }
    }
    static int vis[N], loc[N];
    memset(dep, 0, sizeof(dep));
    static vector<Qry> link_qry[N];
    static vector<pair<i64, i64> > link_pair[N];
    for (auto p : qrys2) link_qry[bel[p.v]].push_back(p);
    for (auto p : pairs) link_pair[bel[p.first]].push_back(p);
    lep (now, 1, tree_number) {
        int rt = root[now];
        int i = rt;
        vector<int> cir;
        while (! vis[i]) {
            cir.push_back(i);
            vis[i] = 1;
            i = p[i];
        }    
        cir.push_back(cir[0]);
        reverse(cir.begin(), cir.end());
        dep[cir[0]] = 0;
        lep (i, 1, (int) cir.size() - 1) dep[cir[i]] = dep[cir[i - 1]] + ew[cir[i]];
        lep (i, 0, (int) cir.size() - 2) loc[cir[i]] = i;
        i64 P = dep[cir[0]];dep[cir[0]] = 0;
        vector<pair<i64, i64> > tree_node;
        vector<Three> people_node;
        for (auto p : link_pair[now]) tree_node.push_back( {(p.second + dep[p.first]) / P, (p.second + dep[p.first]) % P} );
        for (auto p : link_qry[now]) {
            i64 delta = p.t + dep[p.v];
            people_node.push_back( {delta / P, delta % P, p.id} );
        }
        sort(tree_node.begin(), tree_node.end(), [] (pair<i64, i64> a, pair<i64, i64> b) { return a.first < b.first; } );
        sort(people_node.begin(), people_node.end(), [] (Three a, Three b) { return a.a < b.a; } );
        values.clear();
        for (auto p : tree_node) values.push_back(p.second);
        for (auto p : people_node) values.push_back(p.b);
        values = Unique :: unique(values);
        for (auto &p : tree_node) p.second = lower_bound(values.begin(), values.end(), p.second) - values.begin() + 1;
        for (auto &p : people_node) p.b = lower_bound(values.begin(), values.end(), p.b) - values.begin() + 1;
        bt.clr();
        i64 sum = 0; i = 0;
        for (auto p : people_node) {
            i64 qy = p.a, ry = p.b, id = p.c;
            while (i < tree_node.size() && tree_node[i].first <= qy) {
                sum += tree_node[i].first; 
                bt.upd(tree_node[i].second, 1);
                i ++;
            }
            Ans[id] += 1ll * i * qy - sum + bt.qry(ry);
        }
        tree_node.clear();
        people_node.clear();
        for (auto p : link_pair[now]) tree_node.push_back( {loc[p.first], p.second + dep[p.first]} );
        for (auto p : link_qry[now]) {
            i64 delta = p.t + dep[p.v];
            people_node.push_back( {loc[p.v], p.t + dep[p.v], p.id} );
        }
        values.clear();
        for (auto p : tree_node) values.push_back(p.second);
        for (auto p : people_node) values.push_back(p.b);
        values = Unique :: unique(values);
        for (auto &p : tree_node) p.second = lower_bound(values.begin(), values.end(), p.second) - values.begin() + 1;
        for (auto &p : people_node) p.b = lower_bound(values.begin(), values.end(), p.b) - values.begin() + 1;
        sort(tree_node.begin(), tree_node.end(), [] (pair<i64, i64> a, pair<i64, i64> b) { return a.first < b.first; } );
        sort(people_node.begin(), people_node.end(), [] (Three a, Three b) { return a.a < b.a; } );
        bt.clr(); i = 0;
        for (auto p : people_node) {
            i64 cj = p.a, vj = p.b, id = p.c;
            while (i < tree_node.size() && tree_node[i].first < cj) {
                bt.upd(tree_node[i].second, 1);
                i ++;
            }
            Ans[id] -= bt.qry(vj);
        }
    }

    lep (i, 1, q) printf("%lld\n", Ans[i]);
	return 0;
} 
```


---

## 作者：Yansuan_HCl (赞：3)

**强烈建议在博客中打开。**

这里讲一点细节。

$C$ 是固定的，两个人之间的距离也是固定的；于是一个人摘取之后，下次摘取这棵树的人是固定的。每个人连向下次摘取这棵树的人，构成一棵内向基环树。再将初始的苹果向第一次摘取的人连边。每条边的边权是后一个人摘一次苹果所需的时间。可以看作一个苹果会在边权时间后走向下一个点。

考虑一个询问 $(V,T)$。若 $V$ 不在环上，则苹果至多经过 $V$ 一次，二维数点输出在 $V$ 子树内能在 $T$ 时间内到达 $V$ 的苹果数量即可。

若 $V$ 在环上，则一个从点 $u$ 走上环，之前经过了 $l$ 时间的苹果能到达 $V$ 的次数为

$$[l+D(u \to V)\le t][D(u\to V) \neq 0]+\left\lfloor \dfrac {t-D(u\to V)-l}{H}\right\rfloor[t-D(u\to V)-l \ge 0]$$

。其中 $D(u\to V)$ 为在环上从 $u$ 出发走到 $V$ 的距离，$H$ 为**环长**。具体地，有

$$D(u\to V)=\begin{cases}
s_V-s_u &,s_V\ge s_u \\

s_V+H-s_u &,s_V \lt s_u
\end{cases}$$
。左边的条件可以拆开 $D$ 之后二维数点算。右边的整除可以改写成：

$$\begin{cases}
\left\lfloor \dfrac{t - (s_V - s_u) - l}{H} \right\rfloor[(t+s_u)-(s_V+l)\ge0] &,s_V \ge s_u\\\\

\left\lfloor \dfrac{t - (s_V - s_u) - l - H}{H} \right\rfloor [(t+s_u-H)-(s_V+l)\ge0]\\

=\left\lfloor \dfrac{t - (s_V - s_u) - l}{H} \right\rfloor[(t+s_u)-(s_V+l)\ge0]-[(t+s_u-H)-(s_V+l)\ge0]

&,s_V \lt s_u
\end{cases}
$$

，最后一个减是因为去掉一个 $H$ 以后值会多 $1$ 。下取整乘的条件跟上面一样是因为 $t$ 偏小以后下取整是 $0$。


于是下取整的两部分可以合并，剩下一个条件二维数点。下取整部分形如 $\displaystyle \sum{ \left\lfloor \dfrac{a_i-b_j}{c} \right\rfloor}$，可以拆成 $\displaystyle \sum \left(\left\lfloor \frac{a_i}{c} \right\rfloor-\left\lfloor \frac{b_j}{c} \right\rfloor -[a_i\bmod c \lt b_j \bmod c] \right)$，也能二维数点。于是通过了**拆常数**避免了**三维数点**。

代码：

```cpp
// 代码的拆法参考了其他题解，把第一次走到 $V$ 的贡献放在了下取整部分，和上面的不太一样。附带了这种方式的暴力代码。
#include <bits/stdc++.h>
#define ms(x, v) memset(x, v, sizeof(x))
#define il __attribute__((always_inline)) static
#define U(i,l,r) for(int i(l),END##i(r);i<=END##i;++i)
#define D(i,r,l) for(int i(r),END##i(l);i>=END##i;--i)
using namespace std;

typedef long long ll;
template <class T> using BS = basic_string<T>;

template <class T> void rd(T& s) {
	int c = getchar(); s = 0;
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) { s = s * 10 + (c ^ 48); c = getchar(); }
}
template <class T, class... Y> void rd(T& x, Y&... y) { rd(x), rd(y...); }
#define meow(...) fprintf(stderr, __VA_ARGS__)
#define Assert(e, v) if (!(e)) exit(v);

// #define int ll
const int N = 400005;
#define pb push_back
#define eb emplace_back
#define INF LONG_LONG_MAX / 2
il ll floorDiv(ll x, ll y) { ll z = x / y; if (z * y != x && x < 0) --z; return z; }
il ll mod(ll x, ll y) { return (x % y + y) % y; }
struct Lsh {
    vector<ll> v;
    void push(ll x) { v.pb(x); }
    void lsh() {
        sort(v.begin(), v.end());
        v.erase(unique(v.begin(), v.end()), v.end());
    }
    int query(ll x) { return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; }
};
struct BIT {
    ll tr[N] {};
    void add(int p, ll v) { for (; p < N; p += p & -p) tr[p] += v; }
    ll query(int p) { ll v = 0; for (; p; p ^= p & -p) v += tr[p]; return v; }
};

struct Point {
	ll x, y; int t; ll d;
	bool operator < (const Point &r) {
		return x == r.x ? t < r.t : x < r.x;
	}
};
struct Query { ll x1, x2, y1, y2; int id; };
int sgn(int x) { return x > 0 ? 1 : -1; }

struct Count2D {
	vector<Point> pt;
	vector<Query> qr;
	BIT bit;
	
	void add(ll x, ll y, ll z = 1) { pt.pb({x, y, 0, z}); }
	void ask(ll x1, ll x2, ll y1, ll y2) { qr.pb({x1, x2, y1, y2, qr.size()}); }
	void count2d(vector<ll> &res) {
		res.resize(qr.size());
		for (auto &[x1, x2, y1, y2, id] : qr) {
			++id;
			pt.pb({x2, y2, 1, id});
			pt.pb({x2, y1 - 1, 1, -id});
			pt.pb({x1 - 1, y2, 1, -id});
			pt.pb({x1 - 1, y1 - 1, 1, id});
		}
		
		Lsh lsh;
		for (auto &[x, y, t, d] : pt) lsh.push(y);
		lsh.lsh();
		for (auto &[x, y, t, d] : pt) y = lsh.query(y);
		
		sort(pt.begin(), pt.end());
		
		for (auto &[x, y, t, d] : pt)
			if (t)
				res[abs(d) - 1] += bit.query(y) * sgn(d);
			else
				bit.add(y, d);
		
		for (auto &[x, y, t, d] : pt)
			if (!t) bit.add(y, -d);
		pt.clear(); qr.clear();
	}
};

int n, m, Q, L, C, A[N], B[N], V[N]; ll T[N], answer[N];
vector<pair<ll, int>> qr[N];

int fa[N]; ll cost[N]; int col[N];
BS<pair<int, int>> tr[N];
void buildTree() {
	auto getPre = [&](int x) {
		int y = upper_bound(A + 1, A + n + 1, x) - A;
		if (y == 1) return n;
		return y - 1;
	};
	auto dis = [&](ll x, ll y) { return y > x ? y - x : y + L - x; };
	
	U (i, 1, n) {
		int j = getPre(mod(A[i] - C, L));
		fa[i] = j; cost[i] = dis(A[j], A[i]);
		cost[i] += (C - cost[i] + L - 1) / L * L;
	}
	U (i, 1, m) {
		int j = getPre(B[i]);
		fa[n + i] = j; cost[n + i] = dis(A[j], B[i]);
	}
	
	int stk[N] {}, sp = 0, cc = 0; bool vis[N] {}, ins[N] {};
	function<void(int)> dfs = [&](int u) {
		if (ins[u]) {
			++cc;
			D (i, sp, 1) { col[stk[i]] = cc; if (stk[i] == u) break; }
			return;
		}
		if (vis[u]) return; vis[u] = 1;
		stk[++sp] = u; ins[u] = 1;
		dfs(fa[u]);
		--sp; ins[u] = 0;
	};
	U (i, 1, n) if (!vis[i]) dfs(i);
	
	U (i, 1, n + m) if (!col[i])
		tr[fa[i]] += {i, cost[i]};
}

int dfn[N], siz[N]; ll dep[N];
vector<ll> hook[N];
void solveTree(int p) {
	static int dfp;
	static Count2D c2d; vector<int> num; vector<ll> res;
	function<void(int)> dfs = [&](int u) {
		siz[u] = 1; dfn[u] = ++dfp;
		if (u > n) {
			hook[p].pb(dep[u]);
			c2d.add(dep[u], dfn[u]);
		}
		for (auto [v, w] : tr[u]) {
			dep[v] = dep[u] + w;
			dfs(v);
			siz[u] += siz[v];
		}
		if (p != u)
			for (auto [t, id] : qr[u]) {
				num.pb(id);
				c2d.ask(dep[u], dep[u] + t, dfn[u], dfn[u] + siz[u] - 1);
			}
	};
	
	dfs(p);
	c2d.count2d(res);
	U (i, 0, num.size() - 1)
		answer[num[i]] += res[i];
}

bool vis[N];
void solveCycle(int p) {
	vector<ll> dix; vector<int> pts; ll H = 0;
	{	int u = p;
		do {
			vis[u] = 1; pts.pb(u); 
			dix.pb(H); H += cost[u];
		} while ((u = fa[u]) != p);
	}
	
	static Count2D c[4]; vector<ll> res[4]; vector<int> num; vector<ll> ct;
	U (i, 0, pts.size() - 1) {
		ll di = dix[i];

		for (auto [t, id] : qr[pts[i]]) {
			num.pb(id); ct.pb(floorDiv(t - di, H));
//				U (j, 0, pts.size() - 1) {
//					ll dj = dix[j];
//				 	for (ll l : hook[pts[j]]) {
//				 		if (t - di + dj - l >= 0)
//				 			answer[id] += floorDiv(_t - di - (l - dj), H) + 1;
//				 		if (dj > di) {
//				 			if (t - di + dj - l >= 0)
//				 				answer[id]--;
//				 		}
//				 	}
//				}

			c[0].ask(di + 1, H, -INF, t - di);
			c[1].ask(-INF, t - di, 0, 0);
			c[2].ask(-INF, t - di, 0, 0);
			c[3].ask(-INF, t - di, mod(t - di, H) + 1, H);
		}

		for (auto l : hook[pts[i]]) {
			c[0].add(di, l - di);
			c[1].add(l - di, 0);
			c[2].add(l - di, 0, floorDiv(l - di, H));
			c[3].add(l - di, mod(l - di, H));
		}
	}
	U (k, 0, 3)
		c[k].count2d(res[k]);
	U (i, 0, num.size() - 1) {
		int id = num[i];
		answer[id] += -res[0][i] + (ct[i] + 1) * res[1][i] - res[2][i] - res[3][i];
	}
}

signed main() {	
	rd(n, m, L, C);
	U (i, 1, n) rd(A[i]);
	U (i, 1, m) rd(B[i]);
	rd(Q);
	U (i, 1, Q) {
		rd(V[i], T[i]);
		qr[V[i]].eb(T[i], i);
	}
	
	buildTree();
	
	U (i, 1, n) if (col[i])
		solveTree(i);
	U (i, 1, n) if (col[i] && !vis[i])
		solveCycle(i);
	U (i, 1, Q) printf("%lld\n", answer[i]);
}

---

## 作者：EuphoricStar (赞：1)

很妙的题。但是我今天才补/ll

发现苹果生长的间隔是定值，也就是说，第 $i$ 个人在某个时刻摘了一棵树上的苹果，那么下一个摘到这个苹果的人确定。设其为 $p_i$，连边 $i \to p_i$，就构成了一个**内向基环森林**。还可以顺便给这条边赋一个边权，意义是这两个人摘到苹果的时间差。

再对于每棵苹果树求出第一个摘到它的人 $v_0$ 和时间 $t_0$，于是现在就变成了，苹果树在基环树上走，走的用时是边权。

考虑对于每个询问，把基环树的在环上的点和不在环上的点分开考虑。

- 对于在环上的点：

	- 对于一个询问 $(v, t)$，答案就是有多少棵树在 $t$ 时间内移到 $v$ 点。
   - 以环上的点为根，那么一棵苹果树会不断往父亲走。于是我们要求 $t_0 + \operatorname{dis}(v_0, v) \le t$，设 $dep_u$ 为点 $u$ 到根的距离，那么就是 $t_0 + dep_{v_0} \le t + dep_v$。
   - 显然只有 $v$ 子树内的苹果树可以移到 $v$，于是添加限制 $dfn_{v_0} \in [L_v, R_v]$，其中 $dfn_u$ 为 $u$ 的 dfn 序，$[L_u, R_u]$ 为子树的 dfn 序区间。
   - 这样变成了一个裸的二维数点。对其中一维离散化后扫描线 + 树状数组即可。

- 对于不在环上的点：

	- 把环拎出来，设环为 $c_0 \gets c_1 \gets \cdots \gets c_k$（其中 $c_k = c_0$），设 $dep_i$ 为在环上不断跳出边，点 $i$ 到 $c_0$ 的距离。设环长为 $len$。
   - 把 $v_0$ 不在环上的苹果树移到环上。
   - 于是对于一棵苹果树 $(c_i, t_0)$ 和一个询问 $(c_j, t)$，苹果树对询问的贡献为：
	$$\begin{cases}\max(0, \left\lfloor\dfrac{t - (t_0 + dep_i - dep_j)}{len}\right\rfloor + 1) & i \ge j \\ \max(0, \left\lfloor\dfrac{t - (t_0 + dep_i - dep_j)}{len}\right\rfloor) & i < j\end{cases}$$
   - 发现它们的贡献大体相同。于是我们先暂时把 $i < j$ 的贡献合并到 $i \ge j$ 中一起算。
   - 对 $i \ge j$ 的贡献式子变换得：
   $$\max(0, \left\lfloor\dfrac{t + dep_j - (t_0 + dep_i)}{len}\right\rfloor + 1)$$
   - 下取整有点难搞，考虑一个**分离商和余数的套路**：设 $t + dep_j = q_j \times len + r_j, t_0 + dep_i = q_i \times len + q_i$，其中 $r_i, r_j$ 均 $\le len - 1$。那么式子被化成：
   $$\max(0, q_j - q_i + [r_j \ge r_i])$$
   - 发现若 $q_j \ge q_i$，则 $q_j - q_i + [r_j \ge r_i] \ge 0$；若 $q_j \le q_i$，则 $q_j - q_i + [r_j \ge r_i] \le 0$。于是考虑规定偏序关系 $q_j \ge q_i$，对于询问求出所有满足这条关系的 $q_j - q_i$ 之和。再加上 $r_j \ge r_i$，就变成二维数点了。
   - 对于 $i < j$，发现它与 $i \ge j$ 的贡献的区别仅仅是 $\left\lfloor\dfrac{t + dep_j - (t_0 + dep_i)}{len}\right\rfloor$ 为非负数时减去 $1$。于是减去的就是 $i < j$ 且 $t - dep_j \ge t_0 + dep_i$ 的个数，也变成二维数点了。

至此我们终于完成了。时间复杂度是线性对数。

[code](https://loj.ac/s/1884530)，理清思路后不难写。

---

## 作者：Cry_For_theMoon (赞：1)

很震撼的题。

我用了 20min 独立想到了这题完整解法，等我开始写的时候我才知道真正的险恶。

这题我一共花了三个下午，重构了一次，重构前后码量加起来 > 15k。

不过不得不说，这道日本题妙就妙在想法都很自然，而最后层层嵌套就成了一道各方面碾压 noip t4的 DS（）。

#### Part1：

其实我最初的想法呢，是对于某一颗确定的树，摘到它果子的人按照 $a$ 排序是一段区间，这样比较好做。但是它显然是错误的。

但是这个过程中我们发现一个事情，就是我们可以求出一个 $f_{i}$，代表当第 $i$ 个人经过一颗树并摘到果实后，下一次谁会摘到这棵树的果实（注意不是下次谁第一个走到，走到不意味着能摘，同时可能有 $f_i=i$），并且可以求出这个过程经过了多少时间，记作 $w_i$。

那么 $i\rightarrow f_i$ ，边权 $w_i$ 连边后，会得到一个**内向基环树森林**（注意有些基环树的基环可能是一个自环，不过本题中这种情况没啥特殊性）。

对于每颗果树，我们可以求出它第一次被哪个人摘以及什么时刻被摘到，记作 $x$ 和 $t$。那么一开始有一颗果树在节点 $x$，然后它会在基环树上，不断走到 $f_x$，然后 $x\leftarrow f_x$ 这个过程，走一次花费的时间是边权。这里的转换是自然的。

这是本题思维难度最大的部分了，以下都是烦人的 DS。

#### Part2：

我们自然地会把基环树的基环和树分开来考虑。

我们来考虑树的部分。那么对于一个关于点 $u$ 的询问，只有一开始位于 $u$ 的子树内的果树，可能会对当次询问造成贡献。形式化地，我们定义一个点 $u$ 的深度为根节点到它的简单路径的边权和，这个定义在带权树上也是自然的。

对于一次关于点 $u$，时间为 $t$ 的询问，和一个开始位于点 $v$，且在时刻 $t'$ 被 $v$ 摘的果树，这颗果树能对这个询问造成 $1$ 的贡献，当且仅当：

$$\begin{cases}
v\in subtree(u) \\
t'+(depth_v-depth_u)\le t
\end{cases}$$

对于第二个式子，可以变为 $t'+depth_v\le t+depth_u$，这样就比较方便处理。

注意到这是一个类似偏序的问题，考虑把**询问和果树**的 $t-depth$ 预先离散化然后用 BIT 解决。有一个套路，就是询问子树内一段区间里的点数，可以直接 dfs，然后把 dfs 进子树前和回溯的时候的答案作个差，就可以得到子树符合条件的点数。这个套路好像天天爱跑步那题就有，所以不多讲了（雾）。

容易发现树部分的复杂度是 $O((n+m+q) \log n)$ 的。

#### Part3：

基环部分是本题最大难点。首先我们把开始位置在树部分的果树向上移动到基环上，此时所有果树都位于基环上，然后我们只考虑这一个环本身的询问。

处理环的套路有很多，本题里有一个自然的想法，我们枚举一个点 $i$ 的询问，然后做两次计算，第一次计算的是位于位置 $j<=i$ 的果树对点 $i$ 的询问的贡献，第二次计算的是位于位置 $j>i$ 的果树对点 $i$ 的询问的贡献。这两次计算肯定是类似的，我们考虑第一次计算怎么搞。（注：上面说的点都是同一个基环上的点。为了方便说明，当我说点 $i$ 的时候，实际意义是说环上的第 $i$ 个点。而这里是实现上的一个容易错误的细节。）

由于要求 $j<i$ 所以可以把环看成链了，然后设 $dis_i$ 是第一个点走到第 $i$ 个点的长度，那么从第 $j$ 个点走到第 $i$ 个点的长度就是 $dis_i-dis_j$，这不用说都会（）。

设环长为 $len$，对于在点 $j$ 的一颗果树，其到达点 $j$ 的时间为 $t_j$，和对于一次在点 $i$ 的，询问时间为 $t_i$ 的询问，这颗果树对这个询问的贡献为：

$$\left\lfloor \frac{t_i-t_j-(dis_i-dis_j)}{len} \right\rfloor+1$$

这个式子很自然，但是很丑，而且有一个隐含条件是分子得非负。

还是把分子化成 $(t_i-dis_i)-(tj-dis_j)$，分别记作 $A_i$ 和 $A_j$，然后就是 

$$\left\lfloor \frac{A_i-A_j}{len} \right\rfloor+1$$

不管那个 $+1$，因为容易搞，搞个二维数点好了（雾）。考虑这个下取整，很自然地想到转成：

$$\left\lfloor\frac{A_i}{len} \right\rfloor-\left\lfloor\frac{A_j}{len}\right\rfloor$$

但是上下并不相等，可能下面比上面少 $1$，发现记 $A_i$ 除以 $len$ 的余数为 $r_i$，$A_j$ 的为 $r_j$，那么显然 $r_i<r_j$ 的时候下面要减一。

先不管减一，最后统一算。那么就是简单的二维数点，离散化 BIT 就能解决。最后来看这部分减一，同样先离散化，然后：

$$
\begin{cases}
j<i \\
A_j<=A_i \\
r_j>r_i
\end{cases}
$$

三维数点，cdq分治就可以解决。

那么第二次计算同理，所以你得两次二维数点，两次三维数点（雾）。

这部分复杂度显然是 $O((n+m+q)\log^2 n)$ 的

注意本题的下取整和取模，被除数是可能为负的，所以自己考虑咋办吧（笑）（我调了1h才发现）。

好像这个三维数点都说是假的，但是我还是不知道咋转成二维数点，所以我的程序不开 O2 在 Luogu 会被 T 几个点（流泪）（是不是我自带大常数啊）。

```cpp
//JOISC,2020
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define next Cry_For_theMoon
#define il inline
#define pb(x) push_back(x)
#define is(x) insert(x)
#define sit set<int>::iterator
#define mapit map<int,int>::iterator
#define pi pair<int,int>
#define ppi pair<int,pi>
#define pp pair<pi,pi>
#define fr first
#define se second
#define vit vector<int>::iterator
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef double db;
using namespace std;
const int MAXN=2e5+10;
ll n,m,q,l,c;
int a[MAXN],b[MAXN];
ll ans[MAXN],depth[MAXN];
struct Qry{ll t;int idx;};vector<Qry>qry[MAXN];
vector<ll>ret[MAXN];
vector<pi>g[MAXN],e[MAXN];
int to[MAXN],tag[MAXN],rt[MAXN],tow[MAXN];
ll dis(ll x,ll y){if(x<y)return y-x;return y+l-x;}
namespace DSU{int fa[MAXN];};
namespace D{
    ll val[MAXN*4],tot;
    void clr(){tot=0;}
    void add(ll v){val[++tot]=v;}
    void process(){if(!tot)return;sort(val+1,val+1+tot);tot=unique(val+1,val+1+tot)-val-1;}
    int qry(ll v){return lower_bound(val+1,val+1+tot,v)-val;}
} 
struct BIT{
    ll t[MAXN*4],lim=8e5;
    void clr(){lim=D::tot;rep(i,1,lim)t[i]=0;}
    void upd(int pos,ll val){for(;pos<=lim;pos+=lowbit(pos))t[pos]+=val;}
    ll qry(int pos){ll ret=0;for(;pos;pos-=lowbit(pos))ret+=t[pos];return ret;}
    ll qry(int l,int r){if(l>r)return 0;if(!l)return qry(r);return qry(r)-qry(l-1);}
}tree;
struct BIT2{
    int t[MAXN*4],lim=8e5;
    void clr(){lim=D::tot;rep(i,1,lim)t[i]=0;}
    void upd(int pos,ll val){for(;pos<=lim;pos+=lowbit(pos))t[pos]+=val;}
    ll qry(int pos){ll ret=0;for(;pos;pos-=lowbit(pos))ret+=t[pos];return ret;}
    ll qry(int l,int r){if(l>r)return 0;if(!l)return qry(r);return qry(r)-qry(l-1);}
}
tree2;
ll Div(ll n,ll m){
    if(n>=0)return n/m;
    return n/m-1;
}
ll M(ll n,ll m){return (n%m+m)%m;}
namespace PRE{
    vector<ll>preans[MAXN];
    int dfs1(int u,int to,int fa){
        if(u==to)return (tag[u]=1);
        for(auto p:e[u]){
            int v=p.fr;if(fa==v)continue;
            if(dfs1(v,to,u))return (tag[u]=1);
        }
        return 0;
    }  
    void dfs2(int u,int fa){
        rt[u]=rt[fa];
        for(auto p:e[u]){
            int v=p.fr;if(tag[v] || v==fa)continue;
            depth[v]=depth[u]+p.se;
            dfs2(v,u);
        }
    }
    void dfs3(int u,int fa){
        if(!tag[u])for(auto tmp:qry[u])preans[u].pb(tree.qry(D::qry(tmp.t+depth[u])));
        for(auto p:e[u]){
            int v=p.fr;if(tag[v] || v==fa)continue;
            dfs3(v,u);
        }
        if(!tag[u])for(auto tmp:ret[u])tree.upd(D::qry(tmp+depth[u]),1);
        int sz=qry[u].size();
        if(!tag[u])rep(i,0,sz-1)ans[qry[u][i].idx]+=tree.qry(D::qry(qry[u][i].t+depth[u]))-preans[u][i];
        preans[u].clear();
    }
    ll dis[MAXN],len;
    int b[MAXN],vis[MAXN],tot,cnt;
    struct Node{ll b,r;int tp,idx;}node[MAXN*2];
    bool cmp(const Node& n1,const Node& n2){
        if(n1.b!=n2.b)return n1.b<n2.b;
        else if(n1.tp!=n2.tp)return n1.tp<n2.tp;
        else return n1.r<n2.r;
    }
    void cdq(int l,int r){
        if(l>=r)return;
        int mid=(l+r)>>1;cdq(l,mid);cdq(mid+1,r);
        rep(i,l,mid)node[i].tp=1;rep(i,mid+1,r)node[i].tp=2;
        sort(node+l,node+r+1,cmp);
        rep(i,l,r){
            if(node[i].idx!=-1 && node[i].tp==2)ans[node[i].idx]-=tree2.qry(node[i].r);
        }
        rep(i,l,r){
            if(node[i].idx==-1 && node[i].tp==1)tree2.upd(node[i].r,1);
            else if(node[i].idx!=-1 && node[i].tp==2)ans[node[i].idx]+=tree2.qry(node[i].r);
        }
    }
    void solve(int u){
        if(vis[u])return;
        tot=0;
        while(1){if(vis[u])break;vis[u]=1;b[++tot]=u;u=to[u];}
        dis[1]=0;rep(i,2,tot)dis[i]=dis[i-1]+tow[b[i-1]];
        len=dis[tot]+tow[b[tot]];
        //正着做一次三维数点
        D::clr();
        rep(idx,1,tot){
            int i=b[idx];
            for(auto tmp:qry[i])D::add(tmp.t-dis[idx]),D::add(M(tmp.t-dis[idx],len));
            for(auto tmp:ret[i])D::add(tmp-dis[idx]),D::add(M(tmp-dis[idx],len));
        }
        D::process();tree.clr();tree2.clr();
        rep(idx,1,tot){
            int i=b[idx];
            for(auto tmp:ret[i]){
                tree.upd(D::qry(tmp-dis[idx]),Div((tmp-dis[idx]),len));
                tree2.upd(D::qry(tmp-dis[idx]),1);
            }
            for(auto tmp:qry[i]){
                ans[tmp.idx]+=tree2.qry(D::qry(tmp.t-dis[idx]))*(Div(tmp.t-dis[idx],len));
                ans[tmp.idx]-=tree.qry(D::qry(tmp.t-dis[idx]));
            }
        }tree.clr();tree2.clr();
        cnt=0;
        rep(idx,1,tot){
            int i=b[idx];
            for(auto tmp:ret[i])node[++cnt]=(Node){D::qry(tmp-dis[idx]),D::qry(M(tmp-dis[idx],len)),-1,-1};
            for(auto tmp:qry[i])node[++cnt]=(Node){D::qry(tmp.t-dis[idx]),D::qry(M(tmp.t-dis[idx],len)),-1,tmp.idx};
        }
        cdq(1,cnt);
        //反着做一次三维数点
        D::clr();
        rep(idx,1,tot){
            int i=b[idx];
            for(auto tmp:qry[i])D::add(tmp.t-dis[idx]-len),D::add(M(tmp.t-dis[idx],len));
            for(auto tmp:ret[i])D::add(tmp-dis[idx]),D::add(M(tmp-dis[idx],len));
        }
        D::process();tree.clr();tree2.clr();
        per(idx,tot,1){
            int i=b[idx];
            for(auto tmp:qry[i]){
                ans[tmp.idx]+=tree2.qry(D::qry(tmp.t-dis[idx]-len))*(Div(tmp.t-dis[idx]-len,len));
                ans[tmp.idx]-=tree.qry(D::qry(tmp.t-dis[idx]-len));
            }
            for(auto tmp:ret[i]){ 
                tree.upd(D::qry(tmp-dis[idx]),Div((tmp-dis[idx]),len));
                tree2.upd(D::qry(tmp-dis[idx]),1);
            }
        }tree.clr();tree2.clr();
        cnt=0;
        per(idx,tot,1){
            int i=b[idx];
            for(auto tmp:qry[i])node[++cnt]=(Node){D::qry(tmp.t-dis[idx]-len),D::qry(M(tmp.t-dis[idx],len)),-1,tmp.idx};
            for(auto tmp:ret[i])node[++cnt]=(Node){D::qry(tmp-dis[idx]),D::qry(M(tmp-dis[idx],len)),-1,-1};
        }
        cdq(1,cnt);
        
    }
};
int Find(int x){
    if(DSU::fa[x]==x)return x;
    return DSU::fa[x]=Find(DSU::fa[x]);
}
void Merge(int x,int y){
    int p=Find(x),q=Find(y);
    DSU::fa[q]=p;
}
void build(){
    rep(i,1,n)DSU::fa[i]=i;
    rep(i,1,m){
        ll tmp;
        if(a[1]<b[i])tmp=upper_bound(a+1,a+1+n,b[i])-a-1;
        else tmp=n;
        ret[tmp].pb(dis(a[tmp],b[i]));
    }
    rep(i,1,n){
        ll d=c%l,rest=c-d;
        if(a[1]<=a[i]-d)to[i]=upper_bound(a+1,a+1+n,a[i]-d)-a-1; 
        else to[i]=upper_bound(a+1,a+1+n,a[i]+l-d)-a-1;
        ll w=rest+dis(a[to[i]],a[i]);
        if(d==0)w=rest,to[i]=i;
        tow[i]=w;
        g[i].pb(mp(to[i],w));
        if(Find(i)!=Find(to[i]))Merge(i,to[i]);
        else PRE::dfs1(i,to[i],i);
        e[i].pb(mp(to[i],w));e[to[i]].pb(mp(i,w));
    }
    rep(i,1,n)if(tag[i])rt[i]=i,PRE::dfs2(i,i);
}
void pre(){
    D::clr();
    rep(i,1,n){
        for(auto tmp:ret[i])D::add(tmp+depth[i]);
        for(auto tmp:qry[i])D::add(tmp.t+depth[i]);
    }
    D::process();
    tree.clr();
    rep(i,1,n)if(tag[i])PRE::dfs3(i,i);
    rep(i,1,n){if(tag[i])continue;
        for(auto tmp:ret[i])ret[rt[i]].pb(tmp+depth[i]);
        ret[i].clear();
    }
    rep(i,1,n)e[i].clear(),g[i].clear();
    rep(i,1,n)if(tag[i])PRE::solve(i);
}
int main(){
    scanf("%lld%lld%lld%lld",&n,&m,&l,&c);
    rep(i,1,n)scanf("%d",&a[i]);
    rep(i,1,m)scanf("%d",&b[i]);
    scanf("%lld",&q);
    rep(i,1,q){
        ll v,t;scanf("%lld%lld",&v,&t);
        qry[v].pb(((Qry){t,i}));
    }
    build();
    pre();
    rep(i,1,q)printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：7KByte (赞：1)

有删减，原文见[**我的博客**](https://www.cnblogs.com/SharpnessV/p/14882215.html)

一个环上有 $N$ 个人，$M$ 个苹果树，每一秒每个人顺时针走一米，每隔 $C$ 秒长一个苹果，$Q$ 次询问，每次询问第 $V_i$ 个人在 $T_i$ 秒内能摘多少苹果。

不难发现如果相邻两个人间隔 $\ge C$ ，那么上一个摘的苹果这个人一定能摘到，否则上一个人摘得苹果这个人肯定摘不到。

所以不难完成第一步转化，对于每个人 $i$ 向它后面距离 $\ge C$ 米的第一个人连边，记作 $p_i$。表示第 $i$ 个人吃了一个苹果，那么下一个在这里吃苹果的人是 $p_i$ 。注意可以自己向自己连边。

每个人只有一条出边，那么这就是基环内向树森林。

基环树比较套路的做法是断开一条边使得变成一棵树，然后计算不经过断开边和经过断开边的贡献。

不经过断开边，那么就是子树查询深度在一定区间内的苹果树，经典二维数点，直接离线树状数组即可。

经过断开边，我们可以先将所有苹果树移动到根节点，设移动的距离为 $x_i$ 。

那么对于一个询问 $(V_i,T_i)$ ，设环上根节点到 $V_i$ 的距离为 $y_i$ ，如果 $V_i$ 就是根节点，则距离设为环的长度 $Len $。注意这里是基环树的环长，不是湖的周长。

那么答案显然为 $\sum \max\{0,\left\lfloor\dfrac{T_i-y_i-x_j}{Len}\right\rfloor+1\}$。 

这个式子非常丑，考虑计算偏序，令 $T_i-y_i\ge x_j$ ，那么可以去掉 $\max$ 。再把 $1$ 塞进去，得到一个好看一点的式子。

$$Ans=\sum\left\lfloor\dfrac{T_i-y_i+Len-x_j}{Len}\right\rfloor$$ 

$Len $ 是一个定值，可以式子可以写作 $\sum\limits_{w_i\ge x_j}\left\lfloor\dfrac{w_i-x_j}{k}\right\rfloor$ 。

直接拆开做即可，本质还是二维数点，离线树状数组即可。时间复杂度 $\mathcal{O}((N+M)\log (N+M))$ 。 

---


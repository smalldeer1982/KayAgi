# [ZJOI2018] 历史

## 题目背景

九条可怜是一个热爱阅读的女孩子。

## 题目描述

这个世界有 n 个城市，这 n 个城市被恰好 $n-1$ 条双向道路联通，即任意两个城市都可以 互相到达。同时城市 1 坐落在世界的中心，占领了这个城市就称霸了这个世界。

在最开始，这 n 个城市都不在任何国家的控制之下，但是随着社会的发展，一些城市会崛 起形成国家并夺取世界的霸权。为了方便，我们标记第 i 个城市崛起产生的国家为第 i 个国家。 在第 i 个城市崛起的过程中，第 i 个国家会取得城市 i 到城市 1 路径上所有城市的控制权。

新的城市的崛起往往意味着战争与死亡，若第 i 个国家在崛起中，需要取得一个原本被国 家 $j(j ≠ i)$ 控制的城市的控制权，那么国家 i 就必须向国家 j 宣战并进行战争。

现在，可怜知道了，在历史上，第 i 个城市一共崛起了 $a_i$ 次。但是这些事件发生的相对顺 序已经无从考究了，唯一的信息是，在一个城市崛起称霸世界之前，新的城市是不会崛起的。 

战争对人民来说是灾难性的。可怜定义一次崛起的灾难度为崛起的过程中会和多少不同的国家进行战争（和同一个国家进行多次战争只会被计入一次）。可怜想要知道，在所有可能的崛 起顺序中，灾难度之和最大是多少。

同时，在考古学家的努力下，越来越多的历史资料被发掘了出来，根据这些新的资料，可怜会对 $a_i$ 进行一些修正。具体来说，可怜会对 $a_i$ 进行一些操作，每次会将 $a_x$ 加上 w。她希望 在每次修改之后，都能计算得到最大的灾难度。

然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这些数值。
对题面的一些补充：

- 同一个城市多次崛起形成的国家是同一个国家，这意味着同一个城市连续崛起两次是不会 和任何国家开战的：因为这些城市原来就在它的控制之下。
- 在历史的演变过程中，第 i 个国家可能会有一段时间没有任何城市的控制权。但是这并不 意味着第 i 个国家灭亡了，在城市 i 崛起的时候，第 i 个国家仍然会取得 1 到 i 路径上的城市的控制权。

## 说明/提示

在修正开始之前，如果按照所在城市 4, 1, 5, 3, 2 的顺序崛起，那么依次会和 0, 1, 2, 1, 2 个 国家进行战争。

这时一共会产生 6 对敌对关系。可以证明这是所有崛起顺序中的最大值。

![](https://cdn.luogu.com.cn/upload/pic/16016.png)

## 样例 #1

### 输入

```
5 3 
1 1 1 1 1 
1 2 
1 3 
2 4 
2 5 
2 1 
3 1
4 1```

### 输出

```
6 
7 
9
10```

# 题解

## 作者：Kelin (赞：39)

### 题意

给出一棵树,给定每一个点的$access$次数,计算轻重链切换次数的最大值,带修改.

---

### 题解

#### 先考虑不带修改怎么做

可以发现一个点$u$,只有$u$子树里的点进行$access$才会影响$u$的答案,并且每个点都是独立的,可以分开计算

假设$u$的子树发生了两次$access$,那么当且仅当这两次$access$的点来自$u$的两个不同的儿子的子树,答案才会$+1$

设$A_0=a_u$,$A_i=[u$的第$i$个儿子子树$access$次数之和$],m=|Son_u|$

既然当且仅当两次$access$来自不同子树会使得答案$+1$

要使得答案最大,就是尽量让所有相邻发生的$access$都来自不同子树

转化一下也就是有$[0,m]$种颜色,每种颜色有$A_i$个,最大化相邻的颜色不同次数

设$t=\sum_{i=0}^mA_i,h=\max_{i=0}^m\{A_i\}$

那么答案就是$\min\{t-1,2\times(t-h)\}$

把同类型的数挪到一边就是当$2\times h\ge t+1$时,答案是$2(t-h)$,否则是$t-1$

这里举个例子说明一下答案为啥是那个

第一种情况
> 颜色$A\times3,B\times4,C\times5$
> 
> 一组可行解是$CACBCACBCBAB$
> 
> 答案是$11=12-1$

第二种情况

> 颜色$A\times2,B\times3,C\times7$
> 
> 一组可行解是$CACBCACBCBCC$
> 
> 答案是$10=2\times(12-7)$

至于你说严格的证明~~我可以跟你说我最多只能通过举例子理解了吗,当然你可以~~问数学好的$dalao$吧

这样我们就可以在$O(n)$的时间内$dfs$一下这棵树就可以得到答案了$(ps:$记得开$long\ long)$

#### 考虑待修改怎么做

我们可以根据这个$[2\times h\ge t+1]$的"分界线"去想一想怎么维护答案

令$f_i$表示$i$的子树$access$的总次数,如果$2f_i\ge f_{fa_i}+1$那么连实边$(i,fa_i)$,其他的都是虚边

考虑到如果把$i$子树里的点$j$的权值加上$w$,他只会影响$j$到根路径上的点的答案和虚实边关系

因为$2(f_i+w)\ge(f_{fa_i}+w)+1$,所以实边还是实边,并且答案不会变化$(\Delta=2[(f_{fa_i}+w)-(f_i+w)]-2(f_{fa_i}-f_i)=0)$

所以我们只需要找到路径上的虚边进行修改就好了

并且可以知道一条路径上虚边的数量$\le\log\sum a$(证明和树剖的证明一样,有一个"重儿子")

所以我们可以找到路径上所有虚边,然后暴力修改就好了

至于怎么找到路径上的虚边,可以用树剖$+$在线段树/树状数组上二分找到

当然还可以写$LCT$,因为这里的的操作其实就和$access$差不多,只是不一定会把所有边都变成实边,所以特判一下就好了,然后$ans+=$这个点更新后的答案$-$更新前的答案就好了

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=4e5+5;
typedef int arr[N];
typedef long long ll;
struct eg{int nx,to;}e[N*2];
int n,m,ce,fi[N];ll ans;
struct LCT{
    int fa[N],ch[N][2];ll s[N],val[N],vs[N];
    #define lc(u) (ch[u][0])
    #define rc(u) (ch[u][1])
    inline bool gf(int u){return rc(fa[u])==u;}
    inline bool ir(int u){return lc(fa[u])^u&&rc(fa[u])^u;}
    inline void up(int u){s[u]=s[lc(u)]+s[rc(u)]+val[u]+vs[u];}
    inline void rot(int u){
        int p=fa[u],k=gf(u);
        if(!ir(p))ch[fa[p]][gf(p)]=u;
        if(ch[u][!k])fa[ch[u][!k]]=p;
        ch[p][k]=ch[u][!k],ch[u][!k]=p;
        fa[u]=fa[p],fa[p]=u,up(p);
    }
    void splay(int u){
        for(int f=fa[u];!ir(u);rot(u),f=fa[u])
            if(!ir(f))rot(gf(f)==gf(u)?f:u);
        up(u);
    }
    inline ll calc(int u,ll t,ll h){return rc(u)?(t-h)*2:(val[u]*2>t?(t-val[u])*2:t-1);}
    inline void mdy(int u,int w){
        splay(u);int v;
        ll t=s[u]-s[lc(u)],h=s[rc(u)];
        ans-=calc(u,t,h);s[u]+=w,val[u]+=w,t+=w;
        if(h*2<t+1)vs[u]+=h,rc(u)=0;
        ans+=calc(u,t,h);up(u);
        //access
        for(u=fa[v=u];u;u=fa[v=u]){
            splay(u);t=s[u]-s[lc(u)],h=s[rc(u)];
            ans-=calc(u,t,h);s[u]+=w,vs[u]+=w,t+=w;
            if(h*2<t+1)vs[u]+=h,rc(u)=0,h=0;
            if(s[v]*2>t)vs[u]-=s[v],rc(u)=v,h=s[v];
            ans+=calc(u,t,h);up(u);
        }
    }
    void dfs(int u){
        s[u]=val[u];int p=0;ll mx=val[u];
        go(u)if(v^fa[u]){
            fa[v]=u,dfs(v),s[u]+=s[v];
            if(s[v]>mx)mx=s[p=v];
        }
        ans+=min(s[u]-1,(s[u]-mx)*2);
        if(mx*2>=s[u]+1)rc(u)=p;
        vs[u]=s[u]-val[u]-s[rc(u)];
    }
}t;
inline void add(int u,int v){e[++ce]={fi[u],v},fi[u]=ce;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);int u,v;
    fp(i,1,n)sd(t.val[i]);
    fp(i,2,n)sd(u),sd(v),add(u,v),add(v,u);
    t.dfs(1);we(ans);
    while(m--){
        sd(u),sd(v);
        t.mdy(u,v);
        we(ans);
    }
return Ot(),0;
}
```
那个$calc(u,t,h)$或许这么写会好理解一些$?$
```
inline ll calc(int u,ll t,ll h){
	if(rc(u))return (t-h)*2;
	else if(val[u]>=t+1)return (t-val[u])*2;
	else return t-1
}
```

---

## 作者：FlashHu (赞：24)

ZJOI的考场上最弱外省选手T2 10分成功滚粗。。。。。。

首先要想到30分的结论

~~说实话Day1前几天刚刚刚掉了SDOI2017的树点涂色，考场上也想到了这一点~~

想到了又有什么用？反正想不到最大的贡献是怎么推出来的

然后晚上~~心中怀着九条CNM~~看完了Solution.pdf

貌似对我这个蒟蒻来说也只有这一题可做了。。。。。。

已知书上每个点access的总次数，构造出一个顺序，最大化虚实边的切换总次数

其实如果能发现最优顺序的构造是没有后效性的话，问题便可以进一步简化

考虑每个点的子树。假设已经对所有子树中的点构造出了一个最优顺序（一个序列），那么一定不会和它的所有祖先的子树中的最优序列产生冲突。这个并不好证明，仔细想一想应该能发现。

于是就可以单独考虑每个点$x$。能对$x$的实子边产生影响的是x的所有子树和$x$本身（access(x)会使$x$没有实子边），每切换一次都会使答案$+1$。显然同一个子树中产生的影响是相同的。于是我们要让来自不同子树（或$x$本身）尽可能交替access。当没有某个子树（或$x$本身）的$a$总和过大时，可以构造出使得（除了第一次）每一次access都有贡献的方案。如果某个子树（或$x$本身）的$a$总和过大，大于所有子树总和的一半时，是不可以的，那个子树（或$x$本身）的某几次操作肯定不会有贡献。用数学公式大概表示每个点的贡献为（$S$为子树的$a$之和，$c$为$x$的每个子树）

$$\min\{S_x-1,2*(S_x-\max\{a_x,\forall S_c\})\}$$

当$\max\{a_x,\forall S_c\}\gt {S_x+1\over2}$时$\min$取后者

用树形DP算出来就有30分了

那么怎样快速修改呢？

首先，对某个点的$a$加上一个值$w$，只可能会影响该点到根的路径上的点的贡献。

因为是加一个值，所以假如这些点中某些点的子树$S$大于它父亲子树$S$的一半，那么$S_x+w$，$\max\{a_x,\forall S_c\}$也会$+w$，带入上式发现贡献是不变的！

看到某个子树S大于所有子树总和的一半，有没有想到树剖？树剖的轻重边就是这样划分的啊！（~~反正我这种蒟蒻就是想不到~~）

同样对维护好每个点子树S的树进行轻重链剖分，某些点的子树a之和大于它父亲子树a之和的一半就连重边（否则连轻边），这样每个点至多有一个重儿子。类似树剖的证明，每个点到根的轻边总数（也就是我们可能会修改的点数）是$\log\sum a$级别的！

修改的复杂度也有保障啦！我们只要快速找到这些点就好了。用实链剖分维护子树信息即可（应该不能叫LCT吧，没有makeroot，link和cut，对于这个问题[蒟蒻的LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)对LCT的概念也改了改，欢迎Julao们指正！）。全局保存ans，每次进行类access操作找到虚边，就让ans直接减去以前的贡献，加上w以后判断当前的情况决定是否要切换虚实边并让ans加上新的贡献即可。

为了方便计算以前的贡献，蒟蒻觉得可以保存一下以前贡献的类型（无非就三种，某子树过大、自己过大、都不是很大）算的时候就省去了一些判断的时间。

代码细节巨多，尤其是类access更新答案那部分。所以就算考场上想到了一些东西，我这种蒟蒻也未必写得出来吧！疯狂膜拜考场切T2的laofu爷Orzzzzzzzzzzzz！
```cpp
#include<cstdio>
#define RG register
#define R RG int
#define I inline void
#define lc c[x][0]
#define rc c[x][1]
#define G ch=getchar()
typedef long long L;
const int N=400009,M=N<<1;
int f[N],c[N][2],he[N],ne[M],to[M];
L ans,a[N],si[N],s[N];
short tp[N];
bool r[N];
template<typename T>
I in(RG T&x){
	RG char G;
	while(ch<'-')G;
	x=ch&15;G;
	while(ch>'-')x*=10,x+=ch&15,G;
}
inline bool nroot(R x){
	return c[f[x]][0]==x||c[f[x]][1]==x;
}
I up(R x){
	s[x]=s[lc]+s[rc]+si[x]+a[x];
}
I rot(R x){
	R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
	if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
	up(f[w]=y);f[y]=x;f[x]=z;
}
I splay(R x){
	R y;
	while(nroot(x)){
		if(nroot(y=f[x]))
			rot((c[f[y]][0]==y)^(c[y][0]==x)?x:y);
		rot(x);
	}
	up(x);
}
void dp(R x){//dp预处理答案
	R y,i,mp=x;
	RG L mx=a[x];
	for(i=he[x];i;i=ne[i]){
		if(f[x]==(y=to[i]))continue;
		f[y]=x;dp(y);
		si[x]+=s[y];
		if(mx<s[y])mx=s[y],mp=y;
	}
	if(mx<<1>(s[x]=si[x]+a[x])){
		ans+=(s[x]-mx)<<1;
		if(x!=mp)si[x]-=s[rc=mp];//子树过大
		else tp[x]=1;//自己过大
	}
	else tp[x]=2,ans+=s[x]-1;//都不是很大
}
int main(){
	R n,m,i,p=0,x,y;
	RG L w,S;
	in(n);in(m);
	for(i=1;i<=n;++i)in(a[i]);
	for(i=1;i<n;++i){
		in(x);in(y);
		to[++p]=y;ne[p]=he[x];he[x]=p;
		to[++p]=x;ne[p]=he[y];he[y]=p;
	}
	dp(1);printf("%lld\n",ans);
	while(m--){
		in(x);in(w);
		for(y=0;x;x=f[y=x]){
			splay(x);
			S=s[x]-s[lc];//算原来子树a总和，注意减s[lc]
			ans-=tp[x]<2?(S-(tp[x]?a[x]:s[rc]))<<1:S-1;
			S+=w;s[x]+=w;(y?si:a)[x]+=w;
			if(s[y]<<1>S)si[x]+=s[rc],si[x]-=s[rc=y];//虚实切换
			if(s[rc]<<1>S)   tp[x]=0,ans+=(S-s[rc])<<1;//子树过大
			else{
				if(rc)si[x]+=s[rc],rc=0;//没有子树过大，一定变虚
				if(a[x]<<1>S)tp[x]=1,ans+=(S-a[x])<<1;//自己过大
				else         tp[x]=2,ans+=S-1,rc=0;//都不是很大
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：zhongyuwei (赞：15)

如果$x$号城市崛起，那么这一次崛起发生的战争数量就是这个城市到根的路径上的城市所属于的不同的国家的数量。

由于一个城市崛起过后，会使从这个城市到根的路径上的城市都属于它管辖，所以属于同一个国家的城市，它们一定组成一条链，并且这条链上的点的深度是依次递增的。

为了方便统计答案，在一个城市崛起的过程中，我们只在它与某个国家发生战争的城市中深度最大的那一个城市统计答案。也即是计算有多少个“发生了战争的深度最大的城市”。

![图示1](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fxwsgb1zqgj30w00i0dg2.jpg)

如图，7号点崛起，然后3号点崛起。如果现在6号点崛起，需要统计贡献的点是4号点和1号点。

发现一个点被统计一次贡献，要求它的子树内有两个城市先后崛起，并且这两个城市来自不同的儿子的子树（如果是来自同一个儿子，那么就会在深度更大的位置统计贡献，这个城市虽然管辖的国家变了，但是对答案没有贡献）。

进一步挖掘性质：整个历史进程描述为一些国家依次崛起。考虑一个点的时候，来自这个点的子树以外的点的崛起不需要被关心；这个点的一个儿子的子树内的点的崛起的**相对顺序**也不需要我们关心。我们只关心这个崛起顺序中来自这个点的不同的儿子的子树的点的相对顺序。这就是说，我们对于每个点都按照最优的方式安排它的儿子的崛起，这对于它的祖先、它的儿子都是没有影响的。

问题简化为，对于一个点$u$，有$n$个儿子，每个儿子的子树的所有点总共会崛起$x_i$次，安排一种顺序使得来自不同子树的先后两次崛起的数量最大。

如果这些点的分布比较均匀，我们可以找出一种安排，使得相邻两次崛起一定来自不同的子树。即$ans=(\sum x_i)-1$。那么什么情况下找不出这样的一种安排呢？一定是有来自于某一个子树的点的数量过多，把这些点拿出来，相邻两个之间插一个来自其他子树的点，其他子树的点插完了，这个子树的点还有剩，那么剩下的那一段就必须是连续的、来自同一个子树的点了。设$tot=\sum x_i$，$mx$为所有$x_i$的最大值，这时候$ans=2\times (tot-mx)$。显然此时$2\times (tot-mx)<tot-1$。

综上，$ans=min(tot-1,2\times(tot-mx))$

有一点需要注意，一个点子树内的崛起事件，不仅可以来自这个点的儿子，还可以来自这个点自己，计算答案的时候可以把这个点自己当做它的一个子树，即要求不来自于同一个子树（可以一个来自子树，一个是$u$自己），或者不都来自于$u$。

到这里，我们可以得到不带修改的做法：直接$O(n)$扫一遍，$tot$为$u$子树内所有的崛起次数，$mx$为$u$的崛起次数与$u$的不同儿子的的子树内的崛起次数的最大值，这个节点对答案的贡献就是$min(tot-1,2\times (tot-mx))$。所有节点的贡献加起来就是答案。

考虑如何修改。设$tot_u$表示以$u$为根的子树內所有节点的崛起次数总和。那么修改一个点$u$，就会影响到$u$到根的路径上所有节点的$tot_u$，也会相应地影响这些节点对答案的贡献。

考虑当$tot_u-1>2\times(tot_u-mx)$的时候，如果修改的是$mx$来自的子树的点，那么修改前的贡献是$2\times (tot_u-mx)$，修改后的贡献是$2\times ((tot_u+w)-(mx+w))=2\times(tot_u-mx)$。$u$的贡献是不变的。

这样就启发我们如何优化修改的过程：如果一个点存在一个儿子$son[u]$使得$tot_u-1>2\times(tot_u-tot_{son[u]]})$，那么就在$u$到$son[u]$之间连实边，$u$到其他的儿子连虚边，一次修改中我们只考虑这个点到根的路径上，实链之间（也就是由虚边相连的点）的贡献变化。

我们记录下每个点当前对答案的贡献类型：是$tot-1$，还是$2\times (tot-mx)$且$mx$来自一个子树，还是$2\times(tot-mx)$且$mx$是这个点自己。修改一个点过后，这个点到根的路径上的所有点的$tot$都会$+=w$。由虚边相连的点，它的贡献类型可能会发生变化。直接从当前的答案中减去它原来的贡献，修改，然后重新计算它的贡献类型，加上它现在的贡献。这里对于一条实链上的点，我们需要区间修改、单点查询这些点的$tot$，那么可以利用差分的思想，设$val[u]=tot_u-tot_{son[u]}$，在LCT中维护$val$的和即可。

具体来说，LCT中的某条实链，维护它的splay里面的每个节点的$val$值的和就是这条实链上深度最小的点的$tot$。因而，如果想要得到某一个点的$tot$，就应该计算$splay$里面**深度大于等于它**的点的$val$之和，也就是将这个点splay到根后，这个点的$val$加上它右子树的$val$之和。修改某一条实链（或者某条实链的上半部分），只需要将这条链上待修改的、深度最大的点的$val$加上$delta$，就等价于将这个实链上深度小于这个点的点进行了区间加。

修改过后，要重新考虑实链上被修改的点中深度最低的点：

1.它的虚儿子中有一个的$tot$改变了，这个虚儿子的$tot$是否大于它当前实儿子的$tot$？如果是，则应该将这个点的$val$加上当前实儿子的$tot$，减去那个虚儿子的$tot$（保证$val_u=tot_u-tot_{son[u]}$），然后将那个儿子置为虚儿子。

2.这个点的$tot$改变了，它的贡献类型是否会变化？如果$tot-1<2\times (tot - tot_{son[u]})$，还要记得把$son[u]$置为 0 。

修改的复杂度等于这个点到根的路径上虚边的数量乘以splay的复杂度。如果一个点没有实儿子，那么从它的儿子这一层到它，$tot$至少会增加一倍。如果一个点的父亲有实儿子，但是不是这个点，父亲的$tot$就至少是这个点的两倍。因此，修改的虚边数量是$\log$级别的。

---

## 作者：shadowice1984 (赞：14)

link-cut-tree好题啊……

~~我太菜了从去年zjoi咕到现在的一道题~~

~~果然zjoi只有数据结构题能做~~

________________

### 前置芝士:link-cut-tree(lct)/splay 

由于这道题当中我们仅仅是借用了lct的一些思想而已并没有真正的实现make root/access/link/cut操作所以说你不会标准的lct也可以ac本题

(不过话说回来敢刚zjoi的dalao应该会lct吧……)

但是无论如何splay这个数据结构应该是需要的(除非你有精妙的卡常技巧可以让你a了这题)
______________

# 本题题解

首先有一个简单的结论是:**任意时间内一个城市控制的区域一定是一条它到自己的一个祖先的路径**

原因也很显然:我们每次更改一个点所属的城市的时候也会同时修改它的所有祖先的控制权，不会出现将一个城市控制的区域被截成两半的情况

那么根据这个结论我们可以将同一个城市控制的区域看成一条重链,各个重链之间通过不是重边的轻边相连

此时一次“崛起”操作的权值就是点i到1路径上的重链条数了,当然前提是i没有控制任何城市,如果i控制了一个城市的话权值就需要减1了

似乎这样计算权值需要分情况讨论还是有点麻烦……让我们尝试继续简化题目给出的条件

我们发现**点i到1路径上的重链条数=点i到1路径上的轻边个数+1**

但是此时我们依然需要分情况讨论啊……怎么办呢？

有一个性质是当点i至少控制了一个城市时,点i的崛起不会改变点i下面的边的轻重属性

但是如果点i没有控制任何城市的时候，点i的崛起会改变点i下面边的轻重属性

根据这个性质我们可以绕开分情况讨论了,我们此时可以很快的推出一次“崛起”操作的权值是**本次操作中的轻重边切换次数**

因为点i到1路径上的重边一定不会被切换而轻边一定会被切换并且当点i没有控制任何城市的时候会额外发生一次轻重边切换,所以一次"崛起"操作中的轻重边切换次数就等于**点i到1路径上轻边个数+[点i是否没有控制任何城市]**,这与我们刚才推出来一次"崛起"操作的权值等于**点i到1路径上的重链条数-[点i是否控制了至少一个城市]**是等价的

既然我们最大化的东西轻重边切换次数之和(一开始没有重边所有边都是轻边)那么问题就会变得稍微好考虑一点,我们考虑每个点对答案的贡献，换句话就是最大化每个点下面的边的轻重边切换次数之和(显然一个点下面最多有一条重边也可能一条重边都没有)

那么我们发现一个点$i$的轻重边发生切换只会受到来自自己子树的操作的影响

并且发生切换的条件是时间上相邻的两个操作来自于不同的子树或者其中是一个是来自于点i的操作另一个不是来自点i的操作，换句话说和这个操作到底来自于那个点是无关的而仅仅和这个操作来自的子树有关

那么假设我们可以对一个点i安排出一个最优的操作序列，我们就可以在树上dfs，先对当前dfs到的点u的所有子树做出最优的安排，接下来再把这些操作序列按照一种对点u最优的方式"混合"在一起如此这般递归下去我们就可以构造出一个全局最优的的方案了

所以我们现在唯一需要关心的事情就是如何最大化某一个点i的轻重边切换次数，然后我们把每一个点算出来的次数加起来就是我们要的答案

那么这就是一个比较经典的结论了,给你若干种不同颜色的小球要求你把这些小球摆成一列,最大化相邻的不同色球的数目

那么这里有一个结论是我们设球的总数是$S$最大值是$Mx$的话答案是

$$min(S-1,2(S-Mx))$$

证明的话就是当最大的颜色不过半的时候我们总是可以采取这样的一种贪心策略就是每次都选和上一个球颜色不同的球当中最多的一个球来作为我们放的下一个球，由于最大颜色种类不会过半因此我们总是可以成功构造一种方案出来
此时我们的答案就是$S-1$

但是如果最大种类过半的话我们会发现刚才的做法是失效的,此时我们的策略就是把这种最大的颜色看成一种颜色然后将其余的所有颜色都插入这种最大的颜色当中,采用这种策略构造出来的结果就是$2(S-Mx)$了

因此题目让我们计算的式子就是了

$$\sum_{i=1}^{n}min(S_{i}-1,2(S_{i}-Mx_{i}))$$

修改相当于将一条以1为端点的链上的$S_{i}$值加上$w$

那么我们发现由于我们维护的式子是一个取min的操作,在我们我们取min的分界线就是$S+1 \leq 2Mx_{i}$如果这个式子为真那么我们的答案将不再是$S-1$而是$2(S-Mx)$了

按理说如果是一般的修改我们是没办法维护这个式子的

但是我们的修改有个相当强的性质就是我们每次都给整条链加上一个数字$w$

**注意这里是加而不是减**

那么对于一对父子$(u,v)$如果v是u的带权siz最大的子树的话,v和u的siz同时被加上一个值v依然是u的最大的子树，并且如果v已经已经是u的过半的子树的话，v和u的siz同时加上一个值v依然是u的过半子树

那么我们可以仿照树链剖分中的轻重边定义,定义带权意义下的轻重边

我们定义一个点的所有孩子当中,带权siz最大的点为这个点的**重儿子**

我们定义如果一个点重儿子的siz已经过半，那么这个点和它的重儿子之间的边为一条**重边**,其余的边全部是轻边

注意这个定义下一个点和它重儿子之间的边可以是一条轻边

那么我们会有一个比较显然的结论是每经过一条轻边所在子树的带权siz必然翻倍,所以任意一个点到1的路径上至多有$log(\sum a_{i})$条轻边

让我们接着观察当一对父子$(u,v)$的siz同时被加上w的时候$u$的答案会作何变换

如果$(u,v)$这条边是一条重边的话你会发现答案并不会被改动,同时$u$的重儿子和轻重边关系也不会被改变

所以答案发生变化的边必然是一条轻边,重儿子和轻重边关系发生改变的边也必然是一条轻边

那么我们只需要找到$1~u$路径上的所有轻边然后暴力修改一下即可完成答案的维护工作了

问题是我们如何高效找到一条轻边呢？

答案是使用类似于lct一样的数据结构(但是只是一个类似的数据结构并不是lct)

我们保证在同一条重链中的点都在同一个splay当中,并且按照深度排好序,那么我们寻找下一条轻边的操作就是在splay当中查找最小值,将链上的点加上一个值可以通过打标记来实现,将轻边变成重边就是将两个splay接在一起,将重边变成轻边就是一个splay分裂成两个

这样的话我们只需要在若干个splay当中不停的查找最小值就可以完成寻找轻边的任务了

另外一点就是按照我们刚才的定义可能会出现一个点和它的重儿子之间连了一条轻边但是计算答案却按照$2(S-Mx)$计算的情况,这种情况的出现是因为它自己的点权比较大过半了而不是孩子的点权过大了

那么我们维护这种情况比较麻烦所以我们直接特判掉这种情况

具体来讲我们在检查一条轻边$(u,v)$是否会成为重边的时候我们先判一下是否出现自己的点权过半这种情况出现了就直接修改答案而不是继续我们的分情况讨论

还有一些需要画图才能说清楚的细节写注释里了

剩下的事情就是写一个比较简易的splay了

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=4*1e5+10;typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
int n;int m;ll ans;
struct splaytree//简易splay膜板 
{
    int s[N][2];int fa[N];ll val[N];ll add[N];int st[N];int tp;
    inline ll& operator [](const int& x){return val[x];}
    inline int gc(const int& x){return s[fa[x]][1]==x;}
    inline void pd(const int& x)
    {
        if(add[x]==0)return;val[s[x][0]]+=add[x];val[s[x][1]]+=add[x];
        add[s[x][0]]+=add[x];add[s[x][1]]+=add[x];add[x]=0;
    }
    inline void rt(const int& x)
    {
        int d=fa[x];int t=gc(x);s[d][t]=s[x][t^1];fa[s[x][t^1]]=d;
        s[fa[d]][gc(d)]=x;fa[x]=fa[d];s[x][t^1]=d;fa[d]=x;
    }
    inline void rtup(const int& x){rt(gc(x)^gc(fa[x])?x:fa[x]);rt(x);}
    inline void splay(const int& x)
    {
        tp=0;for(int p=x;p;p=fa[p])st[++tp]=p;for(int i=tp;i>=1;i--)pd(st[i]);
        for(;fa[fa[x]]&&fa[x];rtup(x));if(fa[x])rt(x);
    }
    inline int gmi(int x){for(;s[x][0];x=s[x][0]);splay(x);return x;}
    inline void app(const int& u,const int& w){val[u]+=w;add[u]+=w;}
    inline void meg(const int& x,const int& y){s[x][0]=y;fa[y]=x;}
    inline void spi(const int& x){splay(x);fa[s[x][1]]=0;s[x][1]=0;}
}spt;
int v[2*N];int x[2*N];int ct;int al[N];ll w[N];ll nv[N];ll ola[N];int h[N];int fa[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline void dfs(int u,int f)//dfs一遍预处理信息 
{
    for(int i=al[u];i;i=x[i])
        if(v[i]!=f)dfs(v[i],u),w[u]+=w[v[i]],h[u]=(w[h[u]]<w[v[i]])?v[i]:h[u];spt[u]=w[u];
    if((nv[u]<<1)>=w[u]+1)ola[u]=(w[u]-nv[u])<<1;
    else if((w[h[u]]<<1)>=w[u]+1)ola[u]=(w[u]-w[h[u]])<<1,spt.meg(h[u],u);
    else ola[u]=w[u]-1;ans+=ola[u];fa[u]=f;
}
inline void subsolve(int u,int v,ll w)//检查一条轻边是否成为重边 
{
    spt.splay(u);spt.splay(h[u]);spt.app(u,w);ans-=ola[u];//修改 
    if((nv[u]<<1)>=spt[u]+1)ola[u]=(spt[u]-nv[u])<<1;//检查点权是否过半 
    else if(spt[v]>spt[h[u]])//如果成为重儿子 
    {
        h[u]=v;spt.spi(u);//检测是否成为重边 
        if((spt[v]<<1)>=spt[u]+1)ola[u]=(spt[u]-spt[v])<<1,spt.meg(v,u);
        else ola[u]=spt[u]-1;
    }
    else if((spt[h[u]]<<1)>=spt[u]+1)ola[u]=(spt[u]-spt[h[u]])<<1;//检测重边是否合法 
    else ola[u]=spt[u]-1,spt.spi(u);ans+=ola[u];
}
inline void modify(int u,ll w)
{
    ans-=ola[u];nv[u]+=w;//修改 
    if(h[u])//特判u处的轻重边变化 
    {
        spt.splay(u);spt.splay(h[u]);spt.app(u,w);
        if((nv[u]<<1)>=spt[u]+1)ola[u]=(spt[u]-nv[u])<<1,spt.spi(u);
        else if((spt[h[u]]<<1)>=spt[u]+1)ola[u]=(spt[u]-spt[h[u]])<<1;
        else ola[u]=spt[u]-1,spt.spi(u);
    }else spt.splay(u),spt.app(u,w);ans+=ola[u];//向上跳轻边 
    for(int p=spt.gmi(u);fa[p];p=spt.gmi(fa[p]))subsolve(fa[p],p,w);
}
int main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)read(w[i]);
	for(int i=1;i<=n;i++)nv[i]=w[i];
    for(int i=1,u,v;i<n;i++)read(u),read(v),add(u,v),add(v,u);dfs(1,0);
    printf("%lld\n",ans);
    for(int i=1,u,w;i<=m;i++)
    {read(u),read(w),modify(u,w),printf("%lld\n",ans);}return 0;//拜拜程序~ 
}

```

---

## 作者：lizehon (赞：10)

[[Luogu4338]](https://www.luogu.org/problemnew/show/P4338)  [[BZOJ5212]](https://www.lydsy.com/JudgeOnline/problem.php?id=5212)

[我的博客](https://www.cnblogs.com/lizehon/p/10519171.html)查看效果更佳

附带[LCT小结](https://www.cnblogs.com/lizehon/p/10622022.html) , 不喜勿喷


### 题意

给出一棵树,给定每一个点的 $access$ 次数,计算轻重链切换次数的最大值,带修改.

### 先考虑不带修改怎么做

假设 $u$ 的子树发生了两次 $access$ , 那么当且仅当这两次 $access$ 的点来自 $u$ 的两个不同的儿子的子树 , 答案才会 $+1$

要使得答案最大 , 就是尽量让所有相邻发生的 $access$ 都来自不同子树

把同类型的数挪到一边就是当 $2\times h\ge t+1$ 时,答案是 $2(t-h)$ ,否则是 $t-1$

### 考虑待修改怎么做

令$ f_i$表示 $i$ 的子树 access 的总次数,如果 $2f_i\ge f_{fa_i}+1$ 那么连实边 $(i,fa_i)$ 其他的都是虚边

如果把$i$子树中的点$j$权值加上$w$ , 则只会影响$j$到根节点路径的答案和虚实边关系 , 

因为 $2(f_i+w)\ge(f_{fa_i}+w)+1$所以实边还是实边 , 并且答案不会变化

所以我们只需要找到路径上的虚边进行(暴力)修改就好了 , 然后 $ans+=$ 这个点更新后的答案 $-$更新前的答案

这题难在构造实儿子(边)和虚儿子(边) , 注意到虚边只有$log$条,所以如果转化为只需要修改虚儿子(边)的信息,剩下的通过$splay$或者其他一些操作完成就接近正解了

**本题中有一个贪心 , 就是子树中$size>=$自己的一半的点的贡献的重要性 , 这个点再大也无法影响答案了 , 转化为实儿子(边)对当前点的答案无影响 , 其他的就都定义为轻边**

修改是就是$splay+$暴力中的分类讨论

注意 : 对于$rs$变为虚儿子和$y$变为实儿子的判断都要考虑清楚

还有一个特别容易忽视的点 : 为了使崛起过程中战争次数最多 , 尽量要让所有相邻发生的$access$都来自不同的子树 , 于是统计$maxp$必须考虑$u$这个点 , 否则只有$70$分

可见复杂的题目一定要对每个子问题都分类清楚 , 特别是 **端点 , 边界 , 根节点 , 叶节点** 这些地方一般都要特判

否则甚至可能做不出,比如[[HDU4035]Maze](https://www.cnblogs.com/lizehon/p/10485665.html)和[[HDU4089]Activation](https://www.cnblogs.com/lizehon/p/10486377.html)

**难题就是简单题的叠加** , $ZJOI$的题真神仙

细节详见代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define Debug(x) cout<<#x<<"="<<x<<endl
using namespace std;
typedef long long LL;
const int INF=1e9+7;
inline LL read(){
    register LL x=0,f=1;register char c=getchar();
    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
    while(c>=48&&c<=57)x=(x<<3)+(x<<1)+(c&15),c=getchar();
    return f*x;
}

const int MAXN=4e5+5;
const int MAXM=8e5+5;

struct Edge{
    int v,next;
}e[MAXM];
int first[MAXN],Ecnt=1;
inline void Add_edge(int u,int v){
    e[++Ecnt]=(Edge){v,first[u]};
    first[u]=Ecnt;
}

int n,m;
LL ans;

namespace LCT{
    LL sum[MAXN],aux[MAXN],val[MAXN];
    int ch[MAXN][2],par[MAXN];
#define ls ch[rt][0]
#define rs ch[rt][1]
    inline bool chk(int x){return ch[par[x]][1]==x;}
    inline bool nrt(int x){return ch[par[x]][0]==x||ch[par[x]][1]==x;}
    inline void pushup(int rt){sum[rt]=sum[ls]+sum[rs]+val[rt]+aux[rt];}//全部加起来
    inline void rotate(int x){
        int y=par[x],z=par[y],k=chk(x),w=ch[x][k^1];
        ch[y][k]=w,par[w]=y;
        if(nrt(y)) ch[z][chk(y)]=x; par[x]=z;
        ch[x][k^1]=y,par[y]=x;
        pushup(y);pushup(x);
    }
    inline void splay(int x){
        while(nrt(x)){
            int y=par[x];
            if(nrt(y)){
                if(chk(x)==chk(y)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
    }
#undef ls
#undef rs
}using namespace LCT;

//如果按常规写法会错[https://www.luogu.org/recordnew/show/17153906]
//为了使崛起过程中战争次数最多,尽量要让所有相邻发生的access都来自不同的子树
//于是统计maxp必须考虑u这个点
/*inline void dfs(int u,int pre){
    int maxp=0;
    sum[u]=val[u],par[u]=pre;
    for(int i=first[u];i;i=e[i].next){
        int v=e[i].v;
        if(v==pre) continue;
        dfs(v,u);
        sum[u]+=sum[v];
        if(sum[v]>sum[maxp]) maxp=v;
    }
    ans+=min(sum[u]-1,2*(sum[u]-sum[maxp]));
    if(sum[maxp]*2>=sum[u]+1) ch[u][1]=maxp;
    aux[u]=sum[u]-val[u]-sum[ch[u][1]];
}*/

inline void dfs(int u,int pre){
    LL maxp=val[u];int p=0;
    sum[u]=val[u],par[u]=pre;
    for(int i=first[u];i;i=e[i].next){
        int v=e[i].v;
        if(v==pre) continue;
        dfs(v,u);
        sum[u]+=sum[v];
        if(sum[v]>maxp) maxp=sum[p=v];
    }
    ans+=min(sum[u]-1,2*(sum[u]-maxp));
    if(maxp*2>=sum[u]+1) ch[u][1]=p;//存重儿子
    aux[u]=sum[u]-val[u]-sum[ch[u][1]];//虚边的size
}

#define ls ch[u][0]
#define rs ch[u][1]
inline LL calc(int u,LL total,LL weight){
    if(rs) return (total-weight)*2;
    else if(val[u]*2>=total+1) return(total-val[u])*2;
    else return total-1;
}

inline void modify(int u,int w){
    splay(u);
    LL total=sum[u]-sum[ls],weight=sum[rs];
    ans-=calc(u,total,weight);
    sum[u]+=w,val[u]+=w,total+=w;
    if(weight*2<=total) aux[u]+=weight,rs=0;//变为虚边
    ans+=calc(u,total,weight);
    pushup(u);
    //access
	//重点还是维护虚边或虚儿子信息,即access
    int v;
    for(u=par[v=u];u;u=par[v=u]){
        splay(u);
        total=sum[u]-sum[ls],weight=sum[rs];
        ans-=calc(u,total,weight);
        sum[u]+=w,aux[u]+=w,total+=w;//虚边size+=w;
        if(weight*2<=total) aux[u]+=weight,rs=0,weight=0;
        if(sum[v]*2>=total+1) aux[u]-=sum[v],rs=v,weight=sum[v];
        ans+=calc(u,total,weight);
        pushup(u);
    }
}
#undef ls
#undef rs

int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++) val[i]=read();
    for(int i=1;i<=n-1;i++){
        int x=read(),y=read();
        Add_edge(x,y);
        Add_edge(y,x);
    }
    dfs(1,0);
    printf("%lld\n",ans);
    for(int i=1;i<=m;i++){
        int x=read(),y=read();
        modify(x,y);
        printf("%lld\n",ans);
    }
}
```

---

## 作者：Pengzt (赞：8)

[cnblogs](https://www.cnblogs.com/Pengzt/p/17929879.html)

[P4338](https://www.luogu.com.cn/problem/P4338)

先考虑怎么安排崛起的先后顺序最优。

但是发现好像没有一个很好的顺序去进行崛起，并且由于 $a_i$ 的值域会很大，所以即使知道顺序应该也会难以进行维护。

转换一下方向，正难则反。考虑每个点的贡献，但是颜色不同时只会算一次，所以要钦定是哪一个点造成的贡献。令当前考虑的点为 $u$，发现可以在不影响 $u$ 的祖先的的贡献的情况下对 $u$ 子树内的点的相对操作顺序进行改变。所以 $u$ 点所产生的贡献是很容易计算的：若 $u$ 以及 $u$ 的子树内的所有点的 $a$ 值都没有超过 $sza_u$ 的一半，则贡献为 $sza_u-1$。其中 $sza_u$ 是 $u$ 及 $u$ 的子树的 $a$ 值的和，减一是因为第一次不会产生贡献。否则就是 $2(sza_u-mxa_u)$，因为最大的 $a$ 无法都产生贡献，注意这里的 $mxa_u$ 需要和 $a_u$ 取 $\max$。

这时候就可以有 $30$ 分了。

放一份暴力代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define vi vector<int>
#define eb emplace_back
#define pii pair<int, ll>
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
mt19937_64 rng(35);
constexpr int N = 4e5 + 10;
int n, m;
int sz[N];
ll ans, a[N], sza[N];
vi e[N];
void dfs(int u, int ff) {
	sz[u] = 1, sza[u] = a[u];
	ll mx = a[u];
	for(int v : e[u]) {
		if(v == ff) continue;
		dfs(v, u);
		sz[u] += sz[v];
		sza[u] += sza[v];
		if(sza[v] > mx) mx = sza[v];
	}
	if(2 * mx > sza[u]) ans += 2 * (sza[u] - mx);
	else ans += sza[u] - 1;
}
void work() {
	ans = 0;
	dfs(1, 0);
	cout << ans << "\n";
}
bool Med;
int main() {
	fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
//	freopen("history4.in", "r", stdin);
//	freopen("history.out", "w", stdout);
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	for(int i = 1; i < n; ++i) {
		int u, v;
		cin >> u >> v;
		e[u].eb(v);
		e[v].eb(u);
	}
	work();
	for(int i = 1; i <= m; ++i) {
		int x, w;
		cin >> x >> w;
		a[x] += w;
		work();
	}
	cerr << TIME << "ms\n";
	return 0;
}
```

然后考虑对这个暴力进行优化。

对于 $u\to son$ 的边，若 $sza_{son}>\dfrac{sza_u}{2}$，则称这条边为实边，否则为虚边。

考虑对 $v\in\{\text{path}(1,u)\}$ 进行区间加后虚实边会有什么变化。发现一个很美妙的地方，就是整条路径上至多有 $\log\sum a_i$ 条虚边。然后因为对于一条 $fa\to x$ 的实边，$sza_x$ 和 $sza_{fa}$ 同时增加，$fa$ 的带权的重儿子显然还是 $x$。所以可能发生变化的只有虚边。

于是每次操作至多会修改 $\mathcal{O}(\log\sum a_i)$ 条边，即需要支持单点修改、查询区间中为 $1$ 的数，线段树即可。

然后可能会略有卡常，可以将维护 $sza$ 的数组换为 BIT。

还有一个实现的小技巧，就是因为带权重儿子可能是 $u$ 本身，所以连一个 $i\to i+n$ 的边即可，就能把 $i$ 的点权转到 $i+n$ 上了，这里借鉴了 _Jxsts 的代码。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define vi vector<int>
#define eb emplace_back
#define pii pair<int, ll>
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
mt19937_64 rng(35);
constexpr int N = 8e5 + 10;
int n, m, q;
int dfc, sz[N], hv[N], dfn[N], top[N], fa[N], dep[N], rdfn[N], leaf[N], hva[N];
ll ans, a[N], sza[N], val[N];
vi e[N];
void dfs1(int u, int ff) {
	sz[u] = 1, sza[u] = a[u], dep[u] = dep[ff] + 1, fa[u] = ff;
	for(int v : e[u]) {
		if(v == ff) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		sza[u] += sza[v];
		if(sz[v] > sz[hv[u]]) hv[u] = v;
		if(sza[v] > sza[hva[u]]) hva[u] = v;
		++leaf[u];
	}
	if(leaf[u] <= 1) leaf[u] = 1;
	else leaf[u] = 0;
	if(!leaf[u]) {
		if(2 * sza[hva[u]] > sza[u]) val[u] = 2 * (sza[u] - sza[hva[u]]);
		else val[u] = sza[u] - 1;
		ans += val[u];
		// ans += val[u] = min(2 * (sza[u] - sza[hva[u]]), sza[u] - 1);
	}
}
void dfs2(int u, int f) {
	rdfn[dfn[u] = ++dfc] = u, top[u] = f;
	if(!hv[u]) return;
	dfs2(hv[u], f);
	for(int v : e[u]) {
		if(v == hv[u] || v == fa[u]) continue;
		dfs2(v, v);
	}
}
ll v[N];
void add(int x, ll y) {
	for(; x <= m; x += x & -x) v[x] += y;
}
ll ask(int x) {
	ll res = 0;
	for(; x; x -= x & -x) res += v[x];
	return res;
}
ll ask(int l, int r) {
	return ask(r) - ask(l - 1);
}
int sum[N << 2];
void build(int x, int L, int R) {
	if(L == R) {
		sum[x] = 2 * sza[rdfn[L]] <= sza[fa[rdfn[L]]];
		return;
	}
	int m = (L + R) >> 1;
	build(x << 1, L, m);
	build(x << 1 | 1, m + 1, R);
	sum[x] = sum[x << 1] + sum[x << 1 | 1];
}
void modify(int x, int L, int R, int k, int v) {
	if(L == R) {
		sum[x] = v;
		return;
	}
	int m = (L + R) >> 1;
	if(k <= m) modify(x << 1, L, m, k, v);
	else modify(x << 1 | 1, m + 1, R, k, v);
	sum[x] = sum[x << 1] + sum[x << 1 | 1];
}
int query(int x, int L, int R, int l, int r) {
	if(!sum[x]) return -1;
	if(L == R) return rdfn[L];
	int m = (L + R) >> 1;
	if(r > m) {
		int v = query(x << 1 | 1, m + 1, R, l, r);
		if(~v || (m > r)) return v;
	}
	return l <= m ? query(x << 1, L, m, l, r) : -1;
}
void upd(int x, ll v) {
	int tmp = x;
	while(x) {
		add(dfn[top[x]], v), add(dfn[x] + 1, -v);
		x = fa[top[x]];
	}
	x = tmp;
	int r = dfn[x];
	while(x) {
		if(r < dfn[top[x]]) {
			x = fa[top[x]];
			r = dfn[x];
			continue;
		}
		int u = query(1, 1, m, dfn[top[x]], r);
		if(u == -1) {
			x = fa[top[x]];
			r = dfn[x];
			continue;
		}
		ans -= val[fa[u]];
		ll saf = ask(dfn[fa[u]]), sau = ask(dfn[u]), sahv = ask(dfn[hva[fa[u]]]);
		if(u == hva[fa[u]]) {
			if(2 * sahv > saf && 2 * (sahv - v) <= saf - v) modify(1, 1, m, dfn[u], 0);
			if(2 * sahv > saf) val[fa[u]] = 2 * (saf - sahv);
			else val[fa[u]] = saf - 1;
			ans += val[fa[u]];
		} else {
			if(2 * sahv > saf - v && 2 * sahv <= saf) modify(1, 1, m, dfn[hva[fa[u]]], 1);
			if(2 * sau > saf) modify(1, 1, m, dfn[u], 0);
			if(sau > sahv) {
				hva[fa[u]] = u;
				if(sau * 2 > saf) val[fa[u]] = 2 * (saf - sau);
				else val[fa[u]] = saf - 1;
			} else {
				if(sahv * 2 > saf) val[fa[u]] = 2 * (saf - sahv);
				else val[fa[u]] = saf - 1;
			}
			ans += val[fa[u]];
		}
		r = dfn[fa[u]];
	}
}
bool Med;
int main() {
	fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
//	freopen("history.in", "r", stdin);
//	freopen("history.out", "w", stdout);
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> q;
	m = 2 * n;
	for(int i = 1; i <= n; ++i) {
		cin >> a[i + n];
		e[i].eb(i + n);
		e[i + n].eb(i);
	}
	for(int i = 1; i < n; ++i) {
		int u, v;
		cin >> u >> v;
		e[u].eb(v);
		e[v].eb(u);
	}
	dfs1(1, 0);
	cout << ans << "\n";
	dfs2(1, 1);
	build(1, 1, m);
	for(int i = 1; i <= m; ++i) add(i, sza[rdfn[i]]), add(i + 1, -sza[rdfn[i]]);
//	q = 1; // ...65
	for(int i = 1; i <= q; ++i) {
		int x, w;
		cin >> x >> w;
		upd(x + n, w);
		cout << ans << "\n";
	}
	cerr << TIME << "ms\n";
	return 0;
}
```

---

## 作者：Jsxts_ (赞：5)

树剖做法。

考虑单次询问怎么做。

注意到让 $x,y$ 先后崛起，则 $x$ 对 $y$ 产生贡献的只有 $\operatorname{lca(x,y)}$ 到根的覆盖，有 $1$ 的贡献，我们把它算在 $\operatorname{lca(x,y)}$ 处。

现在考虑每个点 $i$ 最多能产生多少贡献 $a_i$，显然由上面知选的 $x,y$ 必须在 $i$ 的不同子树才能产生 $1$ 的贡献。那么最优肯定是连续两次不选到同一棵子树，答案为 $sz_x-1$。但是有可能有一个儿子满足 $sz_v\times2>sz_x$，这样答案无法取到 $sz_x-1$，为 $2\times(sz_x-sz_v)$。

由于每个点只关心从哪个子树操作，于是每个点的最大贡献互不干扰，都能取到，答案即为每个点 $a_i$ 之和。

现在考虑带修。一次修改 $x$ 会修改 $x$ 到根的所有 $a_i$，先将从 $x$ 到根的 $sz$ 区间加，再对于每个点 $i$ 分类讨论：

若原先 $sz_i\times2>sz_{fa_i}$，又因为修改后 $sz_i\times2$ 增加了 $2w$，$sz_{fa_i}$ 增加了 $w$，所以仍然满足 $sz_i\times2>sz_{fa_i}$，而 $fa_i$ 的贡献为 $2\times((sz_{fa_i}+w)-(sz_i+w))=2\times(sz_x-sz_v)$，保持不变。

若原先 $sz_i\times2\le sz_{fa_i}$，则这样的 $i$ 不会超过 $\log \sum a$，那么我们可以维护每个点 $i$ 的 $[sz_{fa_i}>sz_i\times2]$ （称为 $t_i$），然后树剖再在线段树上二分找到大于零的点暴力修改即可。具体地，我们对于一个 $sz_i\le2\times sz_{fa_i}$ 的点，要做如下修改（设 $fa_i=f$，$son_f$ 表示 $f$ 儿子中 $sz$ 最大的点）：

若 $son_f\neq i$：

- $t_i$ 可能由 $1$ 变 $0$。
- $t_{son_f}$ 可能由 $0$ 变 $1$。
- 答案可能改变。
- $son_f$ 可能变成 $i$。

而对于 $son_f=i$ 的情况，会省去一些讨论，更加简单。

时间复杂度 $O(n\log^2n)$，不开 $O_2$ 最后一个点 2.02s。对于 $sz$，要支持区间加，单点查询，用树状数组维护，常数小。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 2e9;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
int n,m,head[800010],cnt,nt,lef[800010],to[800010];
struct edge {
	int v,nxt;
}ed[1600010];
void add(int u,int v) {
	ed[++cnt] = {v,head[u]};
	head[u] = cnt;
}
ll sza[800010],a[800010],ans,Ans[800010];
int fa[800010],sz[800010],id[800010],rnk[800010],top[800010],son[800010],dep[800010],tot,sona[800010];
void dfs(int x,int f,int d) {
	fa[x] = f, dep[x] = d, sz[x] = 1, sza[x] = a[x];
	int fl = 0;
	for (int i = head[x];i;i = ed[i].nxt) {
		int v = ed[i].v;
		if (v == f) continue;
		dfs(v,x,d + 1);
		sz[x] += sz[v];
		sza[x] += sza[v];
		if (sz[son[x]] < sz[v]) son[x] = v;
		if (sza[sona[x]] < sza[v]) sona[x] = v;
		fl ++;
	}
	lef[x] = fl <= 1;
	if (!lef[x]) {
		if (2 * sza[sona[x]] > sza[x]) Ans[x] = 2 * (sza[x] - sza[sona[x]]);
		else Ans[x] = sza[x] - 1;
		ans += Ans[x];
	}
}
void dfs2(int x,int tp) {
	top[x] = tp;
	id[x] = ++tot, rnk[tot] = x;
	if (!son[x]) return;
	dfs2(son[x],tp);
	for (int i = head[x];i;i = ed[i].nxt) {
		int v = ed[i].v;
		if (v != fa[x] && v != son[x]) dfs2(v,v);
	}
}
ll c[800010];
void upda(int x,ll s) {
	for (;x <= nt;x += (x & -x)) c[x] += s;
}
ll query1(int x) {
	ll res = 0;
	for (;x;x -= (x & -x)) res += c[x];
	return res;
}
struct Seg {
	int l,r,v;
}t[3200010];
void pushup(int x) {
	t[x].v = t[x<<1].v + t[x<<1|1].v;
}
void build(int x,int l,int r) {
	t[x].l = l, t[x].r = r;
	if (l == r) {
		t[x].v = sza[rnk[l]] * 2 <= sza[fa[rnk[l]]];
		return;
	}
	int mid = l + r >> 1;
	build(x << 1,l,mid), build(x<<1|1,mid + 1,r);
	pushup(x);
}
void modify1(int x,int k,int s) {
	if (t[x].l == t[x].r) {
		t[x].v = s;
		return;
	}
	int mid = t[x].l + t[x].r >> 1;
	if (mid >= k) modify1(x<<1,k,s);
	else modify1(x<<1|1,k,s);
	pushup(x);
}
void modify2(int l,int r,ll s) {
	upda(l,s), upda(r + 1,-s);
}
int query2(int x,int l,int r) {//[l,r] 下标最大的 1 
	if (!t[x].v) return -1;
	if (t[x].l == t[x].r) return t[x].v ? rnk[t[x].l] : -1;
	int mid = t[x].l + t[x].r >> 1;
	if (mid >= r) return query2(x<<1,l,r);
	else {
		int t = query2(x<<1|1,l,r);
		if (t != -1) return t;
		return mid >= l ? query2(x<<1,l,r) : -1;
	}
}
void upd(int x,ll s) {
	int y = x;
	while (x) {
		modify2(id[top[x]],id[x],s);
		x = fa[top[x]];
	}
	x = y;
	int R = id[x];
	if (!lef[x]) {
		ll sx = query1(id[x]),sxa = query1(id[sona[x]]);
		ans -= Ans[x];
		if (sxa * 2 <= sx) Ans[x] = sx - 1;
		else Ans[x] = 2 * (sx - sxa);
		ans += Ans[x];
	}
	while (x) {
		if (R < id[top[x]]) {
			x = fa[top[x]], R = id[x];
			continue;
		}
		int p = query2(1,id[top[x]],R);
//		cout << p << endl;
		if (p == -1) {
			x = fa[top[x]], R = id[x];
			continue;
		}
		int f = fa[p];
		ans -= Ans[f];
		ll sp = query1(id[p]),sf = query1(id[f]),sa = query1(id[sona[f]]);
		if (p == sona[f]) {
			if (sp * 2 > sf && sp * 2 - s <= sf) modify1(1,id[p],0);
			if (sp * 2 > sf) Ans[f] = 2 * (sf - sp);
			else Ans[f] = sf - 1;
		}
		else {
			if (sa * 2 > sf - s && sa * 2 <= sf) modify1(1,id[sona[f]],1);
			if (sa < sp) sona[f] = p, sa = sp;
			if (sp * 2 > sf) modify1(1,id[p],0);
			if (sa * 2 > sf) Ans[f] = 2 * (sf - sa);
			else Ans[f] = sf - 1;
		}
		ans += Ans[f];
		R = id[p] - 1;
	}
}
int main() {
	n = read(), m = read(), nt = n;
	for (int i = 1;i <= n;i ++ ) a[++nt] = read(), add(i,nt), add(nt,i), to[i] = nt;
	for (int i = 1;i < n;i ++ ) {
		int u = read(),v = read();
		add(u,v), add(v,u);
	}
	dfs(1,0,1), dfs2(1,1);
	build(1,1,nt);
	for (int i = 1;i <= nt;i ++ ) modify2(i,i,sza[rnk[i]]);
	printf("%lld\n",ans);
	while (m -- ) {
		int x = read(),w = read();
		upd(to[x],w);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：LinkyChristian (赞：5)

难得自己想出来的黑题，祭之。

每一次修改会覆盖数个相同颜色的段，每个相同颜色的段提供一次贡献，我们考虑只在这个相同颜色段的深度最大处统计这个贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/jx2gr6y6.png)

如该图所示，当红绿两次修改操作发生时，将在点 $3$ 处统计一次贡献。

对每个点考虑它的贡献。当且仅当 **它的子树中发生两次修改操作，且这两次修改操作属于不同颜色，操作位置属于不同儿子时** 它会提供一次贡献（这里注意这个节点本身也可以被算入贡献）。

我们设当前的点为 $now$ ，将 $now$ 的每个儿子的子树的次数和设为一类，将自己的次数设为一类。所求的这个节点的最大修改数，即为将这些类内的元素交错摆放，使得相邻两个元素所属的类不同的情况出现的次数最多。

这个讨论本质上是 [CF1649B](https://codeforces.com/contest/1649/problem/B) ，这里不再过多赘述。设所有类的大小之和为 $sum$ ，其中大小最大的类的大小为 $max$ ，则该点所能产生的最大贡献为 $min(sum-1,2 \times (sum-max))$ 。

发现一个点按自己产生最大贡献的标准排列子树内的操作，也只是排列其 **相对位置** ，祖先节点可以任意地在中间插入操作。因此每个节点的贡献之间是 **不相关** 的。于是我们可以用树形 dp 解决，这里就能拿到不带修改的 $30pt$ 。

考虑修改。修改本质上是一个链加。我们将节点的贡献分为三种：由 $sum-1$ 贡献来的，由自己作为 $max$ 贡献来的，由自己的一个儿子作为 $max$ 贡献来的。考虑如果是第三种情况，即用自己儿子贡献来的，我们将这个节点与贡献的儿子连在一起，这样会形成一些 **重链** 。考虑一个修改，如果是对于一个重链一起修改，那么由于 $sum$ 和 $max$ 都会加上 $w$ ，因此重链内部的贡献不变。变的只有重链之间轻边的贡献，因此用一个 LCT 维护轻边贡献并实时更改重链即可，时间复杂度 $O(nlogn)$ 。

$Code$

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 800010
using namespace std;
int cnt,head[N],to[N<<1],nxt[N<<1];
void insert(int u,int v){ 
    cnt++;
    to[cnt]=v;a
    nxt[cnt]=head[u];
    head[u]=cnt;
}
int siz[N],son[N],ans,mx[N],a[ASN],oth[N],type[N];
namespace LinkCutTree{
	int c[N][2],laz[N],f[N];ASD
	bool ntrt(int x) {return cA[f[x]][0]==x||c[f[x]][1]==x;}
	void pushup(int x) {
		siz[x]=siz[c[x][0]]+siz[c[x][1]]+oth[x]+a[x];
	}
	void rotate(int x) {
		int y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
		if(ntrt(y)) c[z][c[z][1]==y]=x;
		c[x][!k]=y,c[y][k]=w;
		if(w) f[w]=y;
		f[y]=x,f[x]=z;
		pushup(y),pushup(x);
	}
	void splay(int x) {
		while(ntrt(x)) {
			int y=f[x],z=f[y];
			if(ntrt(y)) rotate((c[z][0]==y)^(c[y][0]==x)?x:y);
			rotate(x);
		}

	}
	void access(int x,int z) {
		for(int vid=0; x; x=f[vid=x]) {
			splay(x);
			int tot=siz[x]-siz[c[x][0]];
			if(type[x]==0||type[x]==1) {
				ans-=2*(tot-(type[x]?a[x]:siz[c[x][1]]));
			} else ans-=tot-1;
			tot+=z;siz[x]+=z;
			if(vid) oth[x]+=z;
			else a[x]+=z;
			if(2*siz[vid]>=tot+1) oth[x]+=siz[c[x][1]]-siz[vid],c[x][1]=vid;
			if(2*siz[c[x][1]]>=tot+1) type[x]=0,ans+=(tot-siz[c[x][1]])<<1;
			else {
				if(c[x][1]) oth[x]+=siz[c[x][1]],c[x][1]=0;
				if(2*a[x]>=tot+1) type[x]=1,ans+=(tot-a[x])*2;
				else type[x]=2,ans+=tot-1;
			}
		}
	}

}
using namespace LinkCutTree;
inline void dfs(int now,int fa){
	f[now]=fa,siz[now]=a[now],son[now]=0,mx[now]=a[now];
	for(int i=head[now]; i; i=nxt[i]) if(to[i]!=fa) {
		dfs(to[i],now);
		mx[now]=max(mx[now],siz[to[i]]);
		if(siz[to[i]]>siz[son[now]]) son[now]=to[i];
		siz[now]+=siz[to[i]];
	}
	oth[now]=siz[now]-a[now];
	ans+=min(siz[now]-1,siz[now]-(mx[now]-(siz[now]-mx[now])));
	if(2*siz[son[now]]>=siz[now]+1) { type[now]=0,c[now][1]=son[now],oth[now]-=siz[son[now]];return ;}
	if(2*a[now]>=siz[now]+1) {type[now]=1;return ;}
	type[now]=2;
} 
int n,m;
signed main()
{
//	freopen("history.in","r",stdin);
//	freopen("history.out","w",stdout);
	scanf("%lld%lld",&n,&m);
//	siz[0]=-1;
	for(int i=1; i<=n; i++) scanf("%lld",&a[i]);
//	cout<<"End\n";
	for(int i=1; i<n; i++) {
		int u,v;
		scanf("%lld%lld",&u,&v);
		insert(u,v);
		insert(v,u);
	}
//	printf("End\n");
	dfs(1,0);
//	for(int i=1; i<=n; i++) printf("%lld ",type[i]);
//	puts("");
//	printf("END\n");
	printf("%lld\n",ans);
    while(m--) {
    	int x,z;
    	scanf("%lld%lld",&x,&z);
    	access(x,z);
    	printf("%lld\n",ans);
	}
}
```




---

## 作者：tzc_wk (赞：4)

[题面传送门](https://www.luogu.com.cn/problem/P4338)

一道不错的 LCT 练手题。

首先考虑对于没有修改的情况怎么处理。注意到对于一个 $u$，如果我们把 $u$ 的每个儿子的子树染上一种颜色，把 $u$ 点也染上一种颜色，那么当我们 access $u$ 子树内某个点 $v$ 时，点 $u$ 会对答案产生 $1$ 的贡献，当且仅当 $u$ 子树内上一个被 access 的点与 $v$ 不是同一个颜色的，因此如果除了 $1$ 节点之外，每个点都是叶子，那么问题就转化为一个经典问题：有 $n$ 种颜色，第 $i$ 种颜色的点有 $a_i$ 个，现在要将这 $\sum\limits_{i=1}^na_i$ 个点排成一行，最大化相邻异色点数。这是一道经典题，根据经典贪心结论，上面的问题的答案为 $\min(\sum\limits_{i=1}^na_i-1,(\sum\limits_{i=1}^na_i-\max\limits_{i=1}^na_i)\times 2)$。那如果图不是一张菊花怎么办呢？其实也好办，考虑如何钦定 $u$ 子树内点的 access 顺序：我们先递归钦定所有儿子子树内的点的 access 顺序，然后将 $u$ 所有儿子对应的子树看作一个颜色，设 $u$ 点的儿子个数为 $c$，那么我们根据上面的经典结论算出将 $u$ 子树内的点排成一排的最优方案，同一颜色内部 access 顺序则按照我们之前对每个儿子的子树钦定的顺序安排，如此递归下去即可，这就告诉我们，每个点的贡献是可以独立计算的，一遍 DFS 即可解决。具体来说，设 $f(a_1,a_2,\cdots,a_n)=\min(\sum\limits_{i=1}^na_i-1,(\sum\limits_{i=1}^na_i-\max\limits_{i=1}^na_i)\times 2)$，点 $u$ 有 $c_i$ 个儿子 $son_{u,1},son_{u,2},\cdots,son_{u,c_u}$，$u$ 子树内所有点的 $a$ 之和为 $sum_u$，那么答案等于 $\sum\limits_{i=1}^nf(sum_{son_{u,1}},sum_{son_{u,2}},\cdots,sum_{son_{u,c_u}},a_u)$。

接下来考虑带上修改如何处理，可以发现这个问题有点链剖分的意味，因为对于每个点 $u$，根据上面的和式，$u$ 点产生的贡献只与 $sum_u$ 与 $u$ 的儿子中 $sum$ 最大的有关，因此如果我们称 $u$ 的儿子中 $sum$ 最大的为“重儿子”，那么就形成了一个“带权重链剖分”模型。因此我们考虑对于一个点 $u$，记其儿子中 $sum$ 最大的为 $wson_u$，那么如果 $sum_{wson_u}\times 2>sum_u$，我们就连边 $u\to wson_u$，这样显然会形成一条条祖先 $\to$ 后代的链，更具体地，每个点到根路径上最多只有 $\log nV$ 条重链，这个可以用类似于重链剖分的方法分析出来。而当我们修改一个点 $u$ 的点权时，我们考虑 $u$ 到根节点路径上一条重链，那么不难发现，重链中间的点的贡献不会发生变化，唯一可能会发生变化是链顶节点，这启发我们用 LCT 维护每条链，每次修改暴力扣掉原链顶的答案，修改之后再加入新的链顶的答案并更新链剖分的结构。

能做到 $n\log nV$，不过下面的代码是 $n\log n\log nV$ 的：

```cpp
const int MAXN = 5e5;
int n, qu, hd[MAXN + 5], to[MAXN * 2 + 5], nxt[MAXN * 2 + 5], ec, fa[MAXN + 5];
void adde(int u, int v) {to[++ec] = v; nxt[ec] = hd[u]; hd[u] = ec;}
int dfn[MAXN + 5], edt[MAXN + 5], tim, wson[MAXN + 5];
ll res = 0, a[MAXN + 5];
ll t[MAXN + 5];
void add(int x, ll v) {for (int i = x; i <= n; i += (i & (-i))) t[i] += v;}
ll query(int x) {ll ret = 0; for (int i = x; i; i &= (i - 1)) ret += t[i]; return ret;}
ll qry(int x) {return (!x) ? 0 : (query(edt[x]) - query(dfn[x] - 1));}
ll clc(int x) {return min(qry(x) - 1, (qry(x) - max(a[x], qry(wson[x]))) * 2);}
void dfs(int x, int f) {
	dfn[x] = ++tim; add(tim, a[x]); fa[x] = f;
	for (int e = hd[x]; e; e = nxt[e]) {
		int y = to[e]; if (y == f) continue; dfs(y, x);
		if (qry(y) > qry(wson[x])) wson[x] = y;
	}
	edt[x] = tim; res += clc(x);
}
struct node {int ch[2], f;} s[MAXN + 5];
int ident(int k) {return ((s[s[k].f].ch[0] == k) ? 0 : ((s[s[k].f].ch[1] == k) ? 1 : -1));}
void connect(int k, int f, int op) {s[k].f = f; if (~op) s[f].ch[op] = k;}
void rotate(int x) {
	int y = s[x].f, z = s[y].f, dx = ident(x), dy = ident(y);
	connect(s[x].ch[dx ^ 1], y, dx); connect(y, x, dx ^ 1); connect(x, z, dy);
}
void splay(int k) {
	while (~ident(k)) {
		if (!~ident(s[k].f)) rotate(k);
		else if (ident(k) == ident(s[k].f)) rotate(s[k].f), rotate(k);
		else rotate(k), rotate(k);
	}
}
int qrymn(int k) {while (s[k].ch[0]) k = s[k].ch[0]; return k;}
int main() {
	scanf("%d%d", &n, &qu);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1, u, v; i < n; i++) scanf("%d%d", &u, &v), adde(u, v), adde(v, u);
	dfs(1, 0); printf("%lld\n", res);
	for (int i = 1; i <= n; i++) s[i].f = fa[i];
	for (int i = 1; i <= n; i++) if (wson[i] && qry(wson[i]) * 2 > qry(i))
		s[i].ch[1] = wson[i];
	while (qu--) {
		int x, v; scanf("%d%d", &x, &v); map<int, int> vis;
		for (int y = x; y; y = s[y].f) splay(y), res -= clc(y);
		add(dfn[x], v); a[x] += v;
		int pre = 0, prex = 0;
		for (int y = x; y; prex = y, y = s[y].f) {
			splay(y); //printf("! %d\n", y);
			if (pre && qry(pre) > qry(wson[y])) {
				wson[y] = pre; s[y].ch[1] = prex;
			}
			if (qry(wson[y]) * 2 <= qry(y)) s[y].ch[1] = 0;
			res += clc(y); pre = qrymn(y);
		}
		printf("%lld\n", res);
	}
	return 0;
}
/*
5 8
1 1 1 1 1
1 2
2 3
3 4
4 5
3 10
4 100
5 1000
2 10000
3 100000
1 200000
3 300000
5 400000
*/
```



---

## 作者：TheLostWeak (赞：4)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ5212.html)

**大致题意：** 给定一棵树每个节点$Access$的次数，求最大虚实链切换次数，带修改。

------

#### 什么是$Access$？

推荐你先去学一学[$LCT$](https://www.cnblogs.com/chenxiaoran666/p/LCT.html)吧。

------

#### 初始化（不带修改的做法）

首先考虑初始化，即不带修改的做法，~~貌似这样就有30分了~~。

先要注意到一点：我们可以发现，对于每一个节点，它的答案是**独立**的，且只受其**子树内的节点**影响。

这么一说，应该就不难想到**树形$DP$**了吧。

如果有两个相邻$Access$操作，显然当且仅当这两次$Access$来自于当前节点的两个不同子节点的子树，才会对答案造成贡献。

那么如何快速求出答案呢？

设$tot_i$为**以$i$为根的子树内的$Access$操作总次数**，$Sum=\sum tot_{son}$，$Max=max\{tot_{son}\}$。

则对于当前节点的答案有两种情况：

1. $2*Max\le Sum$。

   则显然在最优情况下我们可以每次选择两个**来自不同子树的节点**作为相邻的$Access$节点，因此每一次$Access$都会对答案造成贡献。因此此时的答案就是$Sum-1$。

   例如：$tot_x=3,tot_y=4,tot_z=5$，我们可以这样操作：$xyxzxzyzyzyz$。

2. $2*Max>Sum$。

   此时我们每次必然先每次选择一个**来自非$Max$节点子树内的节点**与一个**来自$Max$节点子树内的节点**作为相邻的$Access$节点，然后将多余的来自$Max$节点子树内的节点全部放在最后面，这样一来造成贡献就是**非$Max$节点子树内的$Access$操作总次数$*2$**，即$2(Sum-Max)$。

   例如：$tot_x=2,tot_y=3,tot_z=7$，我们可以这样操作：$xzxzyzyzyzzz$。易发现只有前面$10$次操作有贡献。

这样，我们就可以完成初始化了。

------

#### 考虑修改

既然涉及到$Access$操作，我们自然要用$LCT$来做这道题啦... ...

只不过这里的$LCT$的$Access$函数要加上一大堆的判断。

这里要给每个节点维护$3$个值：$Val,Sum,Calc$。其中$Val$存储**当前节点的$Access$次数**，$Sum$存储以**在实际树中以当前节点为根的子树**和**在$Splay$中以当前节点的左儿子为根的子树**的$Access$操作总数（包括**当前节点**），$Calc$存储**在实际树中以当前节点为根的子树**除去**在$Splay$中以当前节点的右儿子为根的子树**后的$Access$操作总数。

这样一来，$PushUp$时就可以得到当前节点的$Sum$就等于其**左右儿子$Sum$之和**加上当前节点的$Val$和$Calc$。

对于每一个节点，我们将其向**$Access$操作总数$*2>$当前节点$Access$操作总数**的子节点连一条**实边**（若没有则不连），其余节点连**虚边**。

下面，让我们来考虑如何$Access$。

我们需要记三个变量：$x$表示**当前操作节点**，$son$表示**上一个操作节点**，$val$表示**当前增加的$Access$次数**。

首先，将$x$先$Splay$到根。

然后，我们用一个变量$Sum$存下$x$的$Sum$值减去其左儿子的$Sum$值，这样一来就得到实际树中以$x$为根的子树的$Access$操作总数了。

接下来，我们将$ans$减去当前子树原先的贡献。

其次，将$Sum$，当前节点的$Sum$，以及当前节点的$Val/Calc$（如果为被修改节点则更新$Val$，如果为被修改节点的祖先节点，则更新$Calc$）各加上$val$。

下一步，我们判断$son$是否为当前节点的**实儿子**，如果是，则更新。注意更新时我们要将当前节点$Calc$先加上原右儿子的$Sum$，然后减去$son$的$Sum$。

最后，我们将$ans$加上当前节点的新答案，然后继续处理其父节点即可。

------

#### 代码

```cpp
#include<bits/stdc++.h>
#define Type template<typename I>
#define N 400000
#define LL long long
#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)
#define swap(x,y) (x^=y^=x^=y)
using namespace std;
int n,ee,a[N+5],lnk[N+5];
struct edge
{
    int to,nxt;
}e[(N<<1)+5];
class Class_FIO
{
    private:
        #define Fsize 100000
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,Fsize,stdin),A==B)?EOF:*A++)
        #define pc(ch) (FoutSize^Fsize?Fout[FoutSize++]=ch:(fwrite(Fout,1,Fsize,stdout),Fout[(FoutSize=0)++]=ch))
        #define Isi(x) (typeid(x).name()==typeid(1).name()||typeid(x).name()==typeid(1LL).name())
        #define Isc(x) (typeid(x).name()==typeid('a').name())
        int Top,FoutSize;char ch,*A,*B,Fin[Fsize],Fout[Fsize],Stack[Fsize];
    public:
        Class_FIO() {A=B=Fin;}
        Type inline void read(I& x) {x=0;while(!isdigit(ch=tc()));while(x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));}
        Type inline void write(I x)
        {
            if(Isi(x)) {while(Stack[++Top]=x%10+48,x/=10);while(Top) pc(Stack[Top--]);}
            if(Isc(x)) pc(x);
        }
        template<typename I,typename... A> inline void read(I& x,A&... y) {read(x),read(y...);}
        template<typename I,typename... A> inline void write(I x,A... y) {write(x),write(y...);}
        inline void clear() {fwrite(Fout,1,FoutSize,stdout),FoutSize=0;}
}F;
class Class_LCT
{
    private:
        #define SIZE N
        #define PushUp(x) (node[x].Sum=node[x].Val+node[x].Calc+node[node[x].Son[0]].Sum+node[node[x].Son[1]].Sum)
        #define Rever(x) (swap(node[x].Son[0],node[x].Son[1]),node[x].Rev^=1)
        #define PushDown(x) (node[x].Rev&&(Rever(node[x].Son[0]),Rever(node[x].Son[1]),node[x].Rev=0))
        #define Which(x) (node[node[x].Father].Son[1]==x)
        #define Connect(x,y,d) (node[node[x].Father=y].Son[d]=x)
        #define IsRoot(x) (node[node[x].Father].Son[0]^x&&node[node[x].Father].Son[1]^x)
        LL ans;int Stack[SIZE+5];
        struct Tree
        {
            int Op,Father,Rev,Son[2];LL Val,Calc,Sum;
        }node[SIZE+5];
        inline void Rotate(int x)
        {
            register int fa=node[x].Father,pa=node[fa].Father,d=Which(x);
            !IsRoot(fa)&&(node[pa].Son[Which(fa)]=x),node[x].Father=pa,Connect(node[x].Son[d^1],fa,d),Connect(fa,x,d^1),PushUp(fa),PushUp(x);
        }
        inline void Splay(int x)
        {
            register int fa=x,Top=0;
            while(Stack[++Top]=fa,!IsRoot(fa)) fa=node[fa].Father;
            while(Top) PushDown(Stack[Top]),--Top;
            while(!IsRoot(x)) fa=node[x].Father,!IsRoot(fa)&&(Rotate(Which(x)^Which(fa)?x:fa),0),Rotate(x);
        }
    public:
        inline void Init(int x)//初始化
        {
            register int i,v,Pos=x;register LL Max=node[x].Val=a[x];
            for(i=lnk[x];i;i=e[i].nxt) (v=e[i].to)^node[x].Father&&(node[v].Father=x,Init(v),node[x].Calc+=node[v].Sum,Max<node[v].Sum&&(Max=node[Pos=v].Sum));
            if(node[x].Sum=node[x].Calc+node[x].Val,(Max<<1)<=node[x].Sum) return (void)(ans+=node[x].Sum-1,node[x].Op=1);//若2*Max<=Sum，则为第一种情况，将ans加上Sum-1，并标记op为1，然后退出函数
            ans+=node[x].Sum-Max<<1,x^Pos?(node[x].Calc-=node[node[x].Son[1]=Pos].Sum,node[x].Op=2):(node[x].Op=3);//否则，将ans加上2*(Sum-Max)，若找到的不是这个节点本身，则为第二种情况，更新Calc，并标记op为2，否则标记op为3
        }
        inline void Update(int x,int son,int val)//修改
        {
            Splay(x);//将其旋转到根
            register LL Sum=node[x].Sum-node[node[x].Son[0]].Sum;//记录除去祖先贡献后当前子树内的贡献
            ans-=node[x].Op^1?Sum-(node[x].Op^3?node[node[x].Son[1]].Sum:node[x].Val)<<1:Sum-1,//减去原先的贡献
            Sum+=val,node[x].Sum+=val,son?(node[x].Calc+=val):(node[x].Val+=val),//修改值
            (node[son].Sum<<1)>Sum&&(node[x].Calc+=node[node[x].Son[1]].Sum,node[x].Calc-=node[node[x].Son[1]=son].Sum);
            if((node[node[x].Son[1]].Sum<<1)>Sum) {ans+=Sum-node[node[x].Son[1]].Sum<<1,node[x].Op=2;goto loop;}
            node[x].Son[1]&&(node[x].Calc+=node[node[x].Son[1]].Sum,node[x].Son[1]=0);
            if((node[x].Val<<1)>Sum) {ans+=Sum-node[x].Val<<1,node[x].Op=3;goto loop;}
            ans+=Sum-1,node[x].Op=1;
            loop:node[x].Father&&(Update(node[x].Father,x,val),0);//继续处理祖先
        }
        inline LL GetAns() {return ans;}//返回答案
}LCT;
int main()
{
    register int query_tot,i,x,y;
    for(F.read(n,query_tot),i=1;i<=n;++i) F.read(a[i]);
    for(i=1;i<n;++i) F.read(x,y),add(x,y),add(y,x);
    LCT.Init(1),F.write(LCT.GetAns(),'\n');
    while(query_tot--) F.read(x,y),LCT.Update(x,0,y),F.write(LCT.GetAns(),'\n');
    return F.clear(),0;
}
```

---

## 作者：老莽莽穿一切 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16393477.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P4338)

这个题说模板挺模板的，但是其实也很有思维，这里来讲讲看。

简化题意，给定一棵 LCT，初始都是虚边，给定每个点的 `access` 操作次数，求一个操作顺序使得虚实边转换次数最多。

首先考虑如果不存在修改怎么做，我们考虑按每个点分别考虑，我们发现当相邻两次操作在不同的子树中（或者一个在子树中另一个是自己）都可以产生贡献，我们可以着手构造，然后发现如果没有一个子树（或自己）的操作次数和大于一半，都可以构造满，否则就是剩下的两倍，即 $\min\{S-1,2(S-\max\{a_x,\max_{y\in\operatorname{son}(x)}S_y\})\}$，这样我们就能得到没有修改操作的分。

接下来是修改操作，首先显然这种修改只会影响被修改的点到根的路径，我们考虑对这条路径进行操作。

观察上式，我们发现有一个临界点，就是 $S$ 和 $\max_{y\in\operatorname{son}(x)}S_y\}$，的关系，即有没有一个子树的大小超过一半，另一个特性是这个子树只可能存在一个，我们称这个子树对应的儿子为该点的“重儿子”，与重剖不同的是，重剖中的重儿子是子树最大的儿子，而这里不是，这里是**子树大小超过该树一半的儿子**，且这个重儿子也可以是自己（自己的值超过子树的一半），当然也可以没有。

类比重剖，重儿子组成了一条重链，我们发现一次修改最多只会在每条重链中影响一个点，因为重儿子变大不会影响上式的值，这是保证我们时间复杂度的关键，重剖中每个点到根只会经过至多 $\log n$ 条重链，因为每经过一个轻儿子子树大小就会减半，这其实就是点权等于 $1$ 的特殊情况，在点权不为 $1$ 时同样成立，最多经过 $\log\sum_{i=1}^n a_i$ 条重链，证明同上。

接下来问题就转化成一下几点：

1. 动态维护重链的修改；
2. 查询子树和与重儿子信息。

这其实就很显然了，可以直接套 LCT 解决，时间复杂度大约是 $\mathcal O\left(n\log\sum_{i=1}^n a_i\right)$，不是很会 LCT 的时间复杂度证明，如有错误欢迎指正。

[**c++ 代码**](https://www.cnblogs.com/LaoMang-no-blog/p/16393477.html)

---

## 作者：Ameyax (赞：1)

蒟蒻看了官方题解才会写。 

问题可以看成给定一棵树和每个点$access$的次数，求$access$时轻重链切换次数的最大值。

那么点$i$会开战当且仅当$i$的子树里有城市崛起，并且和上次崛起的城市不同。

设点$u$有$m$个儿子，$u$自己$access$次数为$A_0$，第$i$个儿子的子树的$access$次数为$A_i$

问题转化为有$m+1$个不同颜色的小球，每种有$A_i$个，求一种排列使得相邻颜色不同的个数最多。

令$sum=\sum\limits_{i=0}^{m}A_i$，$mx=\max\limits_{i=0}^{m}A_i$，

则点$u$最大切换次数就是$\min(sum - 1, 2 \times (sum-mx))$。

可以看出每一个点都只和自己的子树有关，也就是说两点之间的贡献都是相互独立的，那么我们就可以用树形$dp$求一次静态的答案了。

这样就有$30$分。

带上修改，只需要动态地维护$dp$值即可，可以用$lct$来维护。

令$sum_u$表示$u$子树里的$a_i$之和，如果$\exists v \in son[u],sum_u+1 \leq 2sum_v$，则$u$，$v$之间连实边，否则为虚边，显然这样的$v$只有一个。

修改时在$lct$上把虚边全部修改一次即可，可以证明虚边的数量是$log \sum a_i$的，和树链剖分的证明方法类似。

最后的时间复杂度是$O(nlogn)$的。

```cpp
#include <bits/stdc++.h>
using namespace std;
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
#define int long long
#define ll long long
const int MAX = 400033;
int n, m, ans, cnt_e, fir[MAX];
struct LinkCutTree
{
    struct edge
    {
        int to, nxt;
        edge() {}
        edge(int a, int b) { to = a, nxt = b; }
    } e[MAX << 1];
    void addedge(int u, int v)
    {
        e[++cnt_e] = edge(v, fir[u]), fir[u] = cnt_e;
        e[++cnt_e] = edge(u, fir[v]), fir[v] = cnt_e;
    }
    struct Node
    {
        int fa, son[2];
        ll val, sum, vsum;
    } t[MAX];
    void pushup(int x) { t[x].sum = t[t[x].son[0]].sum + t[t[x].son[1]].sum + t[x].val + t[x].vsum; }
    bool isroot(int x) { return t[t[x].fa].son[0] != x && t[t[x].fa].son[1] != x; }
    void rotate(int x)
    {
        int y = t[x].fa, z = t[y].fa, op = t[y].son[1] == x;
        t[x].fa = z; if (!isroot(y)) t[z].son[t[z].son[1] == y] = x;
        t[y].son[op] = t[x].son[!op], t[t[y].son[op]].fa = y;
        t[y].fa = x, t[x].son[!op] = y;
        pushup(y);
    }
    void splay(int x)
    {
        while (!isroot(x))
        {
            int y = t[x].fa, z = t[y].fa;
            if (!isroot(y))
            {
                if ((t[z].son[0] == y) ^ (t[y].son[0] == x)) rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
        pushup(x);
    }
    void access(int x, int w, int nxt)
    {
        for (; x; nxt = x, x = t[x].fa)
        {
            splay(x);
            ll sum = t[t[x].son[1]].sum + t[x].val + t[x].vsum;
            
            if (t[x].son[1]) ans -= 2ll * (sum - t[t[x].son[1]].sum);
            else if (sum + 1 <= t[x].val * 2ll) ans -= 2ll * (sum - t[x].val);
            else ans -= sum - 1;
            
            t[x].sum += w, t[x].vsum += w, sum += w;
            if (sum + 1 > t[t[x].son[1]].sum * 2ll)
                t[x].vsum += t[t[x].son[1]].sum, t[x].son[1] = 0;
            if (sum + 1 <= t[nxt].sum * 2ll)
                t[x].son[1] = nxt, t[x].vsum -= t[t[x].son[1]].sum;
                
            if (t[x].son[1]) ans += 2ll * (sum - t[t[x].son[1]].sum);
            else if (sum + 1 <= t[x].val * 2ll) ans += 2ll * (sum - t[x].val);
            else ans += sum - 1;
        }
    }
    void update(int x, int w)
    {
        splay(x);
        ll sum = t[t[x].son[1]].sum + t[x].val + t[x].vsum;
        
        if (t[x].son[1]) ans -= 2ll * (sum - t[t[x].son[1]].sum);
        else if (sum + 1 <= t[x].val * 2ll) ans -= 2ll * (sum - t[x].val);
        else ans -= sum - 1;
        
        t[x].val += w, t[x].sum += w, sum += w;
        if (sum + 1 > t[t[x].son[1]].sum * 2ll)
            t[x].vsum += t[t[x].son[1]].sum, t[x].son[1] = 0;
            
        if (t[x].son[1]) ans += 2ll * (sum - t[t[x].son[1]].sum);
        else if (sum + 1 <= t[x].val * 2ll) ans += 2ll * (sum - t[x].val);
        else ans += sum - 1;
        
        access(t[x].fa, w, x);
    }
    void dfs(int x, int fa)
    {
        t[x].fa = fa;
        t[x].sum = t[x].val;
		ll maxn = t[x].val, maxid = x;
        for (int i = fir[x], v; i; i = e[i].nxt)
            if (e[i].to != fa)
            {
            	v = e[i].to;
                dfs(v, x);
                t[x].sum += t[v].sum;
                if (t[v].sum > maxn) maxid = v, maxn = t[v].sum;
            }
        ans += min(t[x].sum - 1, 2ll * (t[x].sum - maxn));
        if (maxid != x && t[x].sum + 1 <= 2ll * maxn) t[x].son[1] = maxid;
        t[x].vsum = t[x].sum - t[x].val - t[t[x].son[1]].sum;
    }
} lct;
main()
{
    n = read(), m = read();
    for (int i = 1; i <= n; i++)
        lct.t[i].val = read();
    for (int i = 1; i < n; i++)
    {
        int u = read(), v = read();
        lct.addedge(u, v);
    }
    lct.dfs(1, 0);
    printf("%lld\n", ans);
    while (m--)
    {
        int x = read(), w = read();
        lct.update(x, w);
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

~~人类在历史中吸取的教训是人类在历史中没吸取到任何教训。~~

------------
## 警钟敲烂：
这道题不简单，尽管他算是黑题中较逊的一类，但是仍不可小觑，记住，LCT 板子一定要熟练~~不然就会像我一样找半天 bug！~~

------------
## 大致思路：
这道题是一道较为模板的 LCT 题目，题目大致的意思是：给出一棵有根树，给出每个点能够 ```access```（就是那个 LCT 模板中的函数名，意思是**删除x到根路径上所有连向其他点的重链，重新拉一条x到根的重链**）的次数，要你安排顺序，求轻重边切换最多多少次，**动态加次数**。

注意，由于是**动态加次数**，所以怎么绕都绕不过 LCT 树~~除非你能忍受 TLE 七八个点的痛苦~~。

接着，我们今天就直接开始讲解一下怎么用 LCT 树完成这两个操作~~主要是之前一开始总是讲输入遭到投诉太多~~。

第一步其实还挺好想的，思考一下如何**静态**做，发现相当于对于每一个节点，就是**让各个子树的权值和自己的** ```access``` **次数互相建边**，使得**相邻两个不同的个数越多越好**，这个东西想一想就可以知道答案是 $\min(2\times(n - x),n - 1)$（实在看不懂可以去[大佬博客](https://blog.csdn.net/xyz32768/article/details/82718869?ops_request_misc=&request_id=&biz_id=102&utm_term=%5BZJOI2018%5D%E5%8E%86%E5%8F%B2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-82718869.142^v93^insert_down28v1&spm=1018.2226.3001.4187)中看看），**其中** $x$ **是最大的个数**，具体怎么得来，可以直接分类讨论 $x > \frac{n}{2}$、$x = \frac{n}{2}$、$x < \frac{n}{2}$ 三种情况，笔者不多赘述。

第二种情况就比较有意思了，我们可以在 $x > \frac{n}{2}$ 时连实边，否则连虚边（**是 LCT 中的实边和虚边**），然后用类似 LCT 一样维护实边构成的 spaly。每次在 ```access``` 实边的答案都不会变因为 $x$，$n$ 都增加了，虚边可能会变成实边，也有可能将原来的实边断掉，分类讨论即可。这样每次跳虚边，子树权值和必定翻倍，那么总跳跃次数就是 $\log(a_i)$ 总和。每次要进行一次 splay，那么复杂度就很小了（感谢 @Deep_Kevin 大佬的[文章](https://blog.csdn.net/Deep_Kevin/article/details/108369426?spm=1001.2014.3001.5506)对我用 LCT 做这道题思路的启发）。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define ls ch[x][0]
#define rs ch[x][1]
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 450010;
int n, m;
struct edge
{
    int to, next;
} edge[N << 1];
int head[N], cnt, fa[N], lazy[N], sta[N];
long long sum[N], val[N], S[N];
int ch[N][2];
long long ans = 0;
void add(int u, int v)
{
    edge[++cnt].to = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
    edge[++cnt].to = u;
    edge[cnt].next = head[v];
    head[v] = cnt;
}
bool check(int x)
{
    return !(ch[fa[x]][0] != x && ch[fa[x]][1] != x);
}
void update(int x)
{
    sum[x] = val[x] + S[x] + sum[ls] + sum[rs];
}
void dfs(int x)
{
    long long mmax = val[x];
    int p = 0;
    for (int i = head[x]; i; i = edge[i].next)
    {
        if (edge[i].to != fa[x])
        {
            int y = edge[i].to;
            fa[y] = x;
            dfs(y);
            S[x] += sum[y];
            if (sum[y] > mmax)
            {
                mmax = sum[y], p = y;
            }
        }
    }
    if (2 * mmax >= val[x] + S[x] + 1 && p)
    {
        S[x] -= mmax, ch[x][1] = p;
    }
    update(x);
    ans += min(sum[x] - 1, 2 * (sum[x] - mmax));
}

void rotate(int x)
{
    int f = fa[x], ff = fa[f], w = (ch[f][0] == x);
    fa[x] = ff;
    fa[f] = x;
    if (ch[x][w])
    {
        fa[ch[x][w]] = f;
    }
    if (ch[ff][0] == f)
    {
        ch[ff][0] = x;
    }
    else if (ch[ff][1] == f)
    {
        ch[ff][1] = x;
    }
    ch[f][1 - w] = ch[x][w];
    ch[x][w] = f;
    update(f);
    update(x);
}
void splay(int x)
{
    while (check(x))
    {
        if (check(fa[x]))
        {
            if ((ch[fa[x]][0] == x) ^ (ch[fa[fa[x]]][0] == fa[x]))
            {
                rotate(x);
            }
            else
            {
                rotate(fa[x]);
            }
        }
        rotate(x);
    }
}
void access(int x, int t)
{
    splay(x);
    long long Sum = sum[x] - sum[ls];
    ans -= min(Sum - 1, 2 * (Sum - max(sum[rs], val[x])));
    val[x] += t;
    sum[x] += t;
    Sum += t;
    ans += min(Sum - 1, 2 * (Sum - max(sum[rs], val[x])));
    if (sum[rs] * 2 < Sum + 1)
    {
        S[x] += sum[rs], rs = 0;
    }
    int last = x;
    x = fa[x];
    while (x)
    {
        splay(x);
        Sum = sum[x] - sum[ls];
        ans -= min(Sum - 1, 2 * (Sum - max(sum[rs], val[x])));
        sum[x] += t;
        S[x] += t;
        Sum += t;
        ans += min(Sum - 1, 2 * (Sum - max(sum[last], max(val[x], sum[rs]))));
        if (sum[last] * 2 >= Sum + 1)
        {
            S[x] -= sum[last], S[x] += sum[rs], rs = last;
        }
        else if (sum[rs] * 2 < Sum + 1)
        {
            S[x] += sum[rs], rs = 0;
        }
        last = x;
        x = fa[x];
    }
}
int main()
{
    n = read();
    m = read();
    for (int i = 1; i <= n; i++)
    {
        val[i] = read(); // 还是把名字写全一点好一些
    }
    int x, y;
    for (int i = 1; i < n; i++)
    {
        x = read();
        y = read();
        add(x, y);
    }
    fa[1] = 0;
    dfs(1);
    cout << ans << endl;
    while (m--)
    {
        x = read();
        y = read();
        access(x, y);
        cout << ans << endl;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122084128)

---


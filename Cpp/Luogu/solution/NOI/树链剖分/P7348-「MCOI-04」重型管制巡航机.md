# 「MCOI-04」重型管制巡航机

## 题目背景

这是一个作战部署命令。

我们已经从国家安全局获得了有关敌方重型指挥巡洋舰的部分机密情报。

敌方巡航机的正式名称已被确认为 P-1112 Aigaion。

空中舰队中包含一种 Kottos 中型巡航机负责电子支援，还有一种 Gyges 中型巡航机负责近程防空。

Aigaion，作为指挥机，负责一切与巡航导弹相关的事务。

在获得这些情报之后，我们可以草拟一个摧毁 Aigaion 的计划。

仔细听好了。

Aigaion 只能在机体前部接受空中加油。

多架加油机必须同时处在 Aigaion 前方才能进行加油作业。

当加油机在 Aigaion 前部进行加油时，Aigaion 的雷达探测能力会暂时削弱。

这里就是关键点了。

Aigaion 在进行加油时，其雷达基本完全无法探测在其前方飞行的物体。

如果你们能维持在一个固定航线并在一个特定高度上飞行，你们就能在不被敌军发现的情况下，从空中接近 Aigaion。

所以我们解决掉这只怪物的最佳时机就是它进行空中加油的时候。

Aigaion 的预定航线图也包含在这份情报中。

简报结束后，我们将在机库再次检查航线图。

快去准备吧。

…………

Garuda 队，交战！

$$_{{\frac{\large\text{ACE COMBAT }\Large6}{\tiny{\text{F i r e s\quad O f\quad L i b e r a t i o n}}}}}\\ \text{Mission 09} \\\Large\text{Heavy Command Cruiser}\\\tiny -\ The\ Dead\ Sea\ -$$

## 题目描述

在平面上给定一棵有根树，树根为 $1$，根的深度为 $0$。

对于深度为 $x$ 的节点，其 **纵坐标** 为 $n-x+1$。

对于一个节点的所有子节点，**从左到右按照编号升序排列**。每条边都是一条 **连接两个点的线段**。

每一个叶子节点都有一条 **平行于 $y$ 轴且向 $y$ 轴负方向无限延伸的射线**，根节点有一条 **平行于 $y$ 轴且向 $y$ 轴正方向无限延伸的射线**。

**任意两条线段或射线只在树的节点处相交。**

如果你不理解这个树是怎么画的，可以阅读样例 1 解释。

给定 $q$ 组 $u,v$，你现在要从点 $u$ 开始在平面上自由移动，但是你不能经过除 $u,v$ 以外的任何一个点，且每经过一条线段或射线就会产生 $1$ 的代价。

你的目标是移动到点 $v$，你需要求出移动过程产生的最小代价。

## 说明/提示

**For the enhanced version, see [P7434](https://www.luogu.com.cn/problem/P7434).**

#### 样例 1 解释

第二次实际是询问 $u=6,v=3$，其他询问都满足 $u'=u,v'=v$。

![](https://cdn.luogu.com.cn/upload/image_hosting/a98cor2o.png)

- 可以看出，从 $4$ 到 $7$ 需要经过一条线；
- 从 $6$ 到 $3$ 不需要经过直线；
- 从 $5$ 到 $2$ 不需要经过直线；
- 从 $4$ 到 $8$ 需要经过一条线；
- 故答案分别为 $1,0,0,1$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（1 pts）：$f_i=i-1$，$s=-1$。
- Subtask 2（9 pts）：$f_i=1$，$s=-1$。
- Subtask 3（10 pts）：$n,q\leq 2\times 10^3$，$s=-1$。
- Subtask 4（20 pts）：$f_i=\left\lfloor\dfrac{i}{2}\right\rfloor$，$s=-1$。
- Subtask 5（59 pts）：$s=-1$。
- Subtask 6（1 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^5$，$1\leq q\leq 5\times 10^6$，$1\leq u,v\leq n$，$1\leq f_i<i$，$-1\leq s\leq 10^9$，且 $s=-1$ 时 $q\leq 5\times 10^5$。

**对于 $99\%$ 的数据，保证 $s=-1$。**

**IO 量可能很大，请选择合适的读入输出方式。**

#### 说明

[Minecraft OI Round 4](https://www.luogu.com.cn/contest/33344) B         
idea：ClCN solution：ClCN & \_Guoyh\_ check：\_Guoyh\_

---

你问为什么 MCOI 里面混入了 AC6？  
很简单，因为 ClCN 不玩 MC。

## 样例 #1

### 输入

```
9 4 -1
1 1 2 2 2 3 7 7
4 7
7 2
5 2
4 8```

### 输出

```
1
0
0
1```

## 样例 #2

### 输入

```
30 1 -1
1 2 3 4 5 6 7 7 9 9 11 11 12 13 13 14 17 18 19 20 21 19 23 22 22 25 25 28 29 
6 30```

### 输出

```
2```

## 样例 #3

### 输入

```
30 10000 20051130
1 2 3 4 5 6 7 7 9 9 11 11 12 13 13 14 17 18 19 20 21 19 23 22 22 25 25 28 29```

### 输出

```
2 6362```

# 题解

## 作者：Sol1 (赞：9)

真不会写题面了，出题人语文没救/ll

## 算法 1：

输出 $q$ 个 $0$，复杂度为读入复杂度 $O(n+q)$。

当然对于链是正确的，期望得 $1$ 分。

## 算法 2：

对于菊花，只能从两个方向走，分类讨论一下。

复杂度 $O(n+q)$，期望得 $9$ 分。

## 算法 3：

将每一个区域看作一个点建图。

考虑每一条直线，将两侧的区域连一条代价为 $1$ 的边。

每次询问跑 BFS 即可。

时间复杂度 $O(nq)$，期望得 $20$ 分。

## 算法 4：

当树为完全二叉树时，可以将区域按照最顶上的点进行编号。

然后有一个 observation：**对于一个点，在最优移动中，最顶上的点一定一直是 $u$ 或 $v$ 的祖先。**

由于这是二叉树，所以直接按区域编号做一个暴力的 dp 的复杂度是 $O(\log n)$。

于是就可以做了。

期望得 $20$ 分。

当然如果你把区域换成用边表示，缩掉链，并在 dp 的方程上稍微做一点修改就可以过掉前面的所有点并获得 $40$ 分。

## 算法 5：

受到算法 4 的启发，考虑将 $u\rightarrow \text{lca}(u,v)$ 和 $v\rightarrow \text{lca}(u,v)$ 单独提取出来。

如果能做出这两条链的结果，那么就变成了菊花上的问题。

那么怎么求这两条链的结果呢？

首先把链提取出来，然后我们发现，**不与这条链直接相连的节点都是没有用的，因为过它们的边肯定不优于过直接与链相连的边。**

现在就可以考虑一个倍增形式的 DP。

定义一条边的「左区域」为子节点编号更小的区域，同时另外一个区域就是「右区域」。

设 $dp_{u,k,0/1,0/1}$ 表示从 $u\rightarrow f_u$ 的边的左区域（ $0$ ）/右区域（ $1$ ）走到 $f_u^{2^k}\rightarrow f_u^{2^k+1}$ 的左区域（ $0$ ）/右区域（ $1$ ）的最小代价。

那么如何由 $dp_{u,k-1}$ 转移至 $dp_{u,k}$？

可以分类讨论是否跨过中间的边，然后把两条路径连接起来。

于是我们就有如下转移：（由于比较复杂，所以就贴代码了）

```cpp
Segnode operator + (const Segnode& b) const {
	Segnode res;
	int v1 = Min(b.lldis, b.rldis + 1), v2 = Min(b.lldis + 1, b.rldis), v3 = Min(b.lrdis, b.rrdis + 1), v4 = Min(b.lrdis + 1, b.rrdis);
	res.lldis = Min(lldis + v1, lrdis + v2);
	res.lrdis = Min(lldis + v3, lrdis + v4);
	res.rldis = Min(rldis + v1, rrdis + v2);
	res.rrdis = Min(rldis + v3, rrdis + v4);
	return res;
}
```

其中 `lldis` 就是左区域到左区域的最短路径长度，`lrdis` 是左区域到右区域的最短路径长度，`rldis` 是右区域到左区域的最短路径长度，`rrdis` 是右区域到右区域的最短路径长度。

转移思路可以理解为不跨过中间的边，就是左接左，右接右；跨过中间的边，就是左接右，右接左，然后再加 $1$ 代表跨过中间的边产生的代价。

那么边界 $dp_{u,0}$ 就直接讨论一下 $f_u$ 的度数即可。

```cpp
int lw = faid[i] - 1, rw = g[fa[i][0]].size() - faid[i];
dp[i][0].lldis = Min(lw, rw + 2);
dp[i][0].lrdis = 1 + Min(lw, rw);
dp[i][0].rldis = 1 + Min(lw, rw);
dp[i][0].rrdis = Min(lw + 2, rw);
```

于是我们对每一组询问倍增，然后就变成了菊花上的询问，故用菊花的方式 $O(1)$ 合并即可。

时间复杂度 $O((n+q)\log n)$，期望得分 $99$ 分。

## 算法 6：

在算法 5 的基础上继续改进，考虑长链剖分。

类似树上 $k$ 级祖先，保存链顶往上链长个 dp 值和往下链长个 dp 值。

剖分完之后再结合倍增，问题转化为区间求和，但是信息不可减，不能交换，只有结合律。

直接上 sqrt tree，复杂度为 $O(n\log n+q)$。

细节非常多，尤其要注意在预处理时倒序求和（$\text{sum}(l,r)=a_r+a_{r-1}+\cdots+a_l\neq a_l+a_{l+1}+\cdots+a_r$），如果顺序错误（应该）会被第二个样例卡掉。

还有一些神奇的卡常方式，例如链长为 $1$ 的长链不需要保存，以及将单链缩为一个点。

然后要注意 sqrt tree 的写法，如果你直接用 vector 之类的东西去建树那么时空稳稳炸飞，更好的写法是按层开数组。

然后是一个时间上的卡常，由于在询问的链的长度的二进制表示中 1 位数量比较小的时候倍增快于正解，所以正解做了一个分治，在 $k$ 的二进制表示只有 $\leq 3$ 个 $1$ 的时候直接倍增。

最后，在做完上面的卡常之后，可以保证 sqrt tree 查询的区间长度 $\geq 15$，所以 **分块只需要分到块长等于 $8$**。这样可以砍下很多空间。

更进一步，链长 $\leq 7$ 的长链也全都不需要存了。

巨量细节和卡常也是我为什么只给这个 subtask $1$ 分（

期望得分 $100$ 分。

[核心代码](https://www.luogu.com.cn/paste/xihf8gxi)

顺便推一下 Ace Combat 系列，挺好玩的，而且 7 代支持 PC，有意愿的可以一试（

AC6 Ace Of Aces M09 也是值得一试的一作，号称是皇中皇极端变态的难度的巅峰，如果有神仙过了给我来一组图（

---

## 作者：w33z8kqrqk8zzzx33 (赞：7)

核心 observation：**$u$ 到 $v$ 的最优线路只应该经过 $u\to v$ 路径上的直线，或者相邻与 $u\to v$ 的直线**。证明：

 - 反证。设第一个不与 $u\to v$ 相邻的线段为 $a\to b$。
 - 将所有未被经过的线段缩为点。
 - 这条线路经过的区域中，必然有离 $u\to v$ 最远的区域。这个区域仅会走进去然后紧接着走出来。
 - 这样的走进去然后走出来肯定会围绕的相同一个点，因为前面进行缩点。
 - 设走进去所跨过的线段为 $x\to y$。
 - 接下来的几步出来肯定在连续的跨过 $x\to z$ 形式的线段。
 - 终于来到 $x$ 第一个儿子左边的时候，跨过了至少 $1$ 条线段。
 - 但是现在所在的区域与进去前相邻，因为这样等于绕了 $x$ 的所有儿子
 - 于是如果选择直接走与 $u\to v$ 更进的区域，只需要跨过 $1$ 条线段。
 - 于是走到离 $u\to v$ 更远的区域肯定不优于走离 $u\to v$ 更近的区域。
 - 归纳，得到必须沿着 $u\to v$ 相邻的线段走。

于是，对于询问 $u,v$，可以只考虑 $u$ 和 $v$ 上的节点以及与这些节点相邻的线段。在这道题里，往儿子求最短路比往父亲求最短路更难。

分两种情况考虑。如果 $u$ 是 $v$ 祖先，或相反，可以直接从更深的节点往上求。否则，先提取 $u$ 到 $u'$ 的最短路以及 $v$ 到 $v'$ 的最短路，其中 $u'$ 和 $v'$ 分别为最浅，但不为 $v$ 和 $u$ 的祖先，的节点。得到这些链再分类讨论往什么方向转。

如何求 $u$ 到 $u$ 的某个祖先的答案？直接对点操作比较麻烦，因为题目禁止经过节点。我们对每一个节点的坐标系 $(x_i,y_i)$ 反而对着 $(x_i-\epsilon,y_i)$ 和 $(x_i+\epsilon,y_i)$ 算，其中前者为“左侧”，后者为“右侧”。预处理每一个节点的左右侧到父亲的最短路，就可以倍增算。这里信息合并即为最短路路径合并。

更详细的说，从左侧走到 $2^k$ 级父亲左侧，需要枚举对于第 $2^{k-1}$ 级父亲，更优来在中途经过其“左侧”还是其“右侧”。

最终时间复杂度 $O((n+q)\log n)$。由于这是静态树信息合并，可以做到 $O(n\log n+q)$（长链剖分 + sqrt tree or 猫树）或 $O((n+q)\log\log n)$（递归树上分块）。

### 后言

ver3 大概是先做一个换根 dp，将每一条边边权设为经过线段的最小花费。

不得不说这是最巧妙的 dp 题吧

sto ClCN orz

代码先咕咕咕，我连题都还没过（）

---

## 作者：AtomAlpaca (赞：2)

## 题意

[link](https://www.luogu.com.cn/problem/P7348)

给定一棵树，所有叶子节点向下引出一条射线，根节点向上引出一条射线，所有边视作一条线段，保证所有线段都尽在节点处和其它线段相交。

多次询问，每次给定 $u, v$，求从 $u$ 走到 $v$ 最少经过多少条线。

询问强制在线。$n \le 5\times 10^5, q \le 5 \times 10^6$。

## 题解

首先我们提出一个结论：最优解经过的所有边都在 $u$ 到 $v$ 的路径，及这条路径所挂的所有边中。

证明比较感性。首先考虑仅经过上述边集的所有路径中最优的一条。我们令 $u$ 是较左的一个点。如果最优路径是从 $u$ 向左走，然后从上面绕到右边，然后向左走到 $v$。考虑随着深度增加，绕过去需要经过的线一定不会减少，所有最优策略一定是走到 $\operatorname{lca}(u, v)$ 再绕；否则修改最优路径，强制走一段不在边集上的路径，对于第一条不在边集中的边，如果我们跨这条边走到它的某一边，假如最优的路径也需要走到这一边，我们一定可以用边集中的某条边替代这条边，而且答案是不会变劣的；否则，我们一定要走到条边后折返回目标的这一边，那么我们可以用一条边替换这若干条边，答案是更优的。

形式化证明还不会。会了回来补。

所以我们考虑分别求 $u \rightarrow \operatorname{lca}(u, v)$ 和 $v \rightarrow \operatorname{lca}(u, v)$ 两条路径的答案，然后进行合并。

然而我们发现题目不允许经过点，因此我们考虑分别算每个节点的“左边”和“右边”。令 $f_{u, k, 0/1, 0/1}$ 表示从 $u$ 的左/右边，走到它的第 $2^k$ 级祖先的左/右边最少经过多少边。考虑转移，我们有：

$$
f_{u, k, 0, 0} = 
\min\left\{ 
\begin{aligned} 
	&f_{u, k - 1, 0, 0} + f_{fa^{k - 1}, k - 1, 0, 0}, \\
    &f_{u, k - 1, 0, 0} + f_{fa^{k - 1}, k - 1, 1, 0} + 1, \\
    &f_{u, k - 1, 0, 1} + f_{fa^{k - 1}, k - 1, 0, 0} + 1, \\
    &f_{u, k - 1, 0, 1} + f_{fa^{k - 1}, k - 1, 1, 0}
    
\end{aligned}
\right.
$$

其它三种情况是类似的。

然后考虑边界条件。依然用 $f_{u, 0, 0, 0}$ 的情况举例，我们考虑建图的时候处理出每个节点左侧儿子数 $l_u$ 和右侧儿子数 $r_u$，那我们要么穿过左边的所有边，要么穿过右侧的所有边，再从上面走一条边绕到左边。因此：

$$
f_{u, 0, 0, 0} = 
\min\left\{ 
\begin{aligned} 
	&l_u,\\
    &r_u + 2    
\end{aligned}
\right.
$$

其它三种情况依然是类似的。最终合并答案也是类似地处理，要么穿过中间的所有边，要么从两边绕。令 $a, b$ 分别是 $u, v$ 走向 $\operatorname{lca}(u, v)$ 中经过的最后一个节点。考虑两个都最终停留在左侧，那么最后的合并要走的边数为 $\min( \operatorname{abs}(l[u] - l[v]), \deg[fa] + 1 - \operatorname{abs}(l[u] - l[v]))$。其它情况依然是类似的。

综上我们得到了一个 $O(qn\log n)$ 的做法。然后我们可以长链剖分配合一些 $O(1)$ 查询的数据结构（比如猫树）优化到 $O(qn)$。但是 $\log$ 做法实现得足够精细是可以过的！

## 代码
感谢 [Piggy424008](https://www.luogu.com.cn/user/762646) 教我卡常。
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>

const int MAX = 5e5 + 5;
const int LG = 18;

using std::min;

int n, q, s, u, v, lst, xrs, tot, dfc;
long long sum;
int deg[MAX], dep[MAX], lft[MAX], rht[MAX], h[MAX], dfn[MAX], pos[MAX], lg2[MAX];
int fth[MAX][LG + 5], st[LG + 5][MAX];
inline int rd()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f) { x=-x; }
    return x;
}

int abs(int x) { return x > 0 ? x : -x; }
int min(int a, int b, int c, int d)
{
  a < b ? b = a : 0; c < d ? d = c : 0;
  return b < d ? b : d;
}

namespace GenHelper
{
    unsigned z1,z2,z3,z4,b;
    unsigned rand_()
    {
      b=((z1<<6)^z1)>>13;
      z1=((z1&4294967294U)<<18)^b;
      b=((z2<<2)^z2)>>27;
      z2=((z2&4294967288U)<<2)^b;
      b=((z3<<13)^z3)>>21;
      z3=((z3&4294967280U)<<7)^b;
      b=((z4<<3)^z4)>>12;
      z4=((z4&4294967168U)<<13)^b;
      return (z1^z2^z3^z4);
    }
}
void srand(unsigned x)
{using namespace GenHelper;
z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}
int read()
{
    using namespace GenHelper;
    int a=rand_()&32767;
    int b=rand_()&32767;
    return a*32768+b;
}

struct E { int v, x; } e[MAX];
void add(const int u, const int v)
{
  lft[v] = deg[u]; e[++tot] = {v, h[u]}; h[u] = tot; ++deg[u];
}

struct N
{
  int f[2][2] = {{0, 0}, {0, 0}};
  N operator + (const N & y) const
  {
    N res;
    res.f[0][0] = min(f[0][0] + y.f[0][0], f[0][0] + 1 + y.f[1][0], 
                      f[0][1] + y.f[1][0], f[0][1] + 1 + y.f[0][0]);
    res.f[0][1] = min(f[0][0] + y.f[0][1], f[0][0] + 1 + y.f[1][1],
                      f[0][1] + y.f[1][1], f[0][1] + 1 + y.f[0][1]);
    res.f[1][0] = min(f[1][0] + y.f[0][0], f[1][0] + 1 + y.f[1][0], 
                      f[1][1] + y.f[1][0], f[1][1] + 1 + y.f[0][0]);
    res.f[1][1] = min(f[1][0] + y.f[0][1], f[1][0] + 1 + y.f[1][1],
                      f[1][1] + y.f[1][1], f[1][1] + 1 + y.f[0][1]);
    return res;
  }
} f[MAX][LG];

inline int get(const int x, const int y) { return dfn[x] < dfn[y] ? x : y; }

void init()
{
  for (int i = 1; (1 << i) <= n; ++i)
  {
    for (int j = 1; j + (1 << i) <= n + 1; ++j)
    {
      st[i][j] = get(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
    }
  }
}

int lca(int u, int v)
{
  if (dfn[u] > dfn[v]) { std::swap(u, v); }
  const int lg = lg2[dfn[v] - dfn[u]];
  return get(st[lg][dfn[u] + 1], st[lg][dfn[v] - (1 << lg) + 1]);
}

void dfs(const int u)
{
  dfn[u] = ++dfc; pos[dfc] = u;
  st[0][dfc] = fth[u][0];
  dep[u] = dep[fth[u][0]] + 1;
  for (int i = 1; (1 << i) <= dep[u]; ++i) { fth[u][i] = fth[fth[u][i - 1]][i - 1]; }
  for (int i = h[u]; i; i = e[i].x) { int v = e[i].v; dfs(v); }
}

N qry(int & u, const int fa)
{
  N res;
  int d = dep[u] - dep[fa] - 1;
  if (!d) { return res; }
  while (d)
  {
    int t = lg2[(d & -d)];
    res = res + f[u][t];
    u = fth[u][t];
    d ^= (1 << t);
  }
  return res;
}

int solve(int u, int v)
{
  if (u == v) { return 0; }
  if (dep[u] < dep[v]) { std::swap(u, v); }
  int fa = lca(u, v);
  if (fa == v)
  {
    N ru = qry(u, v);
    int ul = min(ru.f[0][0], ru.f[1][0]), ur = min(ru.f[0][1], ru.f[1][1]);
    return min(ul, ur);
  }
  N ru = qry(u, fa), rv = qry(v, fa);
  int ul = min(ru.f[0][0], ru.f[1][0]), ur = min(ru.f[0][1], ru.f[1][1]),
      vl = min(rv.f[0][0], rv.f[1][0]), vr = min(rv.f[0][1], rv.f[1][1]);
  return min(ul + vl + min(abs(lft[u] - lft[v]), deg[fa] + 1 - abs(lft[u] - lft[v])),
             ur + vr + min(abs(lft[u] - lft[v]), deg[fa] + 1 - abs(lft[u] - lft[v])),
             ul + vr + min(abs(lft[u] - (lft[v] + 1)), deg[fa] + 1 - abs(lft[u] - (lft[v] + 1))),
             ur + vl + min(abs(lft[v] - (lft[u] + 1)), deg[fa] + 1 - abs(lft[v] - (lft[u] + 1))));
}

void solve0()
{
  while (q--)
  {
    u = rd(); u ^= lst; 
    v = rd(); v ^= lst;
    lst = solve(u, v);
    printf("%d\n", lst);
  }
}

void solve1()
{
  srand((unsigned)s);
  while (q--)
  {
    u = (read() ^ lst) % n + 1, v = (read() ^ lst) % n + 1;
    lst = solve(u, v);
    sum += lst; xrs ^= lst;
  }
  printf("%d %lld", xrs, sum);
}

int main()
{
  n = rd(); q = rd(); s = rd();
  for (int i = 2; i <= n; ++i) { fth[i][0] = rd(); add(fth[i][0], i); }
  for (int i = 2; i <= n; ++i) { rht[i] = deg[fth[i][0]] - lft[i] - 1; }
  for (int i = 2; i <= n; ++i) { lg2[i] = lg2[i >> 1] + 1; }
  dfs(1); init();
  for (int i = 2; i <= n; ++i)
  {
    f[i][0].f[0][0] = min(lft[i], rht[i] + 2);
    f[i][0].f[0][1] = min(lft[i], rht[i]) + 1;
    f[i][0].f[1][0] = min(lft[i], rht[i]) + 1;
    f[i][0].f[1][1] = min(rht[i], lft[i] + 2);
  }
  for (int i = 2; i <= n; ++i)
  {
    for (int j = 1; (1 << j) <= dep[i]; ++j)
    {
      f[i][j] = f[i][j - 1] + f[fth[i][j - 1]][j - 1];
    }
  }
  s == -1 ? solve0() : solve1();
  return 0;
}
```

---


# 【MX-X6-T7】夏が終わる

## 题目背景

原题链接：<https://oier.team/problems/X6H>。

---

> _夏の終わりを知って$\\$
ラムネの雫に映る僕達は$\\$
見失いそうな$\\$
茜色の頬を追いかけて$\\$
来年もまた此処に来るんだ_
>
>_—— [夏が終わる - Nanatsukaze](https://music.163.com/#/song?id=2614276904)_

一年时间，走一个环，再次回到原点。

在这个世界不间断的变化中，还有机会再遇到你吗？选择一条最优的路径时，又有多大的机会呢？

## 题目描述

给定一棵 $n$ 个点的树 $T$，边带权。定义无向完全图 $G(T)$：

- 包含 $n$ 个点。
- 如果 $T$ 中包含边 $u,v$，则 $G$ 上 $u,v$ 边的权值为这条边的权值；否则为 $0$。

记 $w(T)$ 为 $G(T)$ 的权值最小的哈密顿回路的权值。

给定 $q$ 次修改操作，分为两种：

- 在 $T$ 上删去一条边再加上一条边，**保证每次操作后仍然是一棵树**；
- 给定 $T$ 上的一条路径，给路径上的每一条边的边权增加一个值。

你需要在每次操作之后计算 $w(T)$。

## 说明/提示

**【样例解释 #1】**

第一次操作后，$G(T)$ 的形态如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/0yznosjr.png)

其中树边用红色标出，最优的哈密顿回路之一为 $1-5-4-2-3-1$。

**【数据范围】**

对于所有数据，保证 $5\leq n\leq 1.5\times 10^5$，$1\leq q\leq 3\times 10^5$，$1\leq u,v\leq n$，$1\leq w\leq 2\times 10^{11}$，保证任意时刻边权不超过 $4\times 10^{11}$，保证不会重复删除已经删除的边。

**捆绑测试**，共 5 个 Subtask，具体限制如下所示：

- Subtask 1（6 pts）：$n\leq 10$，$q\leq 500$；
- Subtask 2（27 pts）：$n,q\leq 2000$；
- Subtask 3（15 pts）：所有答案均 $\geq 1$；
- Subtask 4（26 pts）：$n\leq 7.5\times 10^4$，$q\leq 1.5\times 10^5$；
- Subtask 5（26 pts）：无特殊限制。

## 样例 #1

### 输入

```
5 3
1 2 1
2 3 1
3 4 1
4 5 1
1 4 3 5 1
2 1 5 1
1 1 1 3 100```

### 输出

```
1
1
3```

## 样例 #2

### 输入

```
6 12
3 5 18
3 1 8
5 6 3
6 4 10
6 2 8
1 4 3 4 10
1 5 6 2 5
2 2 5 1
1 7 3 2 19
2 4 6 1
1 3 5 6 20
2 3 4 1
1 9 5 6 16
2 3 1 32
2 3 4 30
2 3 5 22
2 3 2 21```

### 输出

```
0
0
0
8
8
8
8
8
12
19
19
40```

# 题解

## 作者：ZLCT (赞：2)

# 【MX-X6-T7】夏が終わる
不清楚这个题如果要卡 LCT 应该怎么卡，正常 `cin/cout` 最慢的点才跑了 $1.5s$。
## 题目分析
首先一个直觉就是只要每个点不在树上边的度数 $\ge 2$ 就一定能找到一条全是 $0$ 的回路。\
这点出题人的题解证明已经比较详尽了，这里给出一个简单强势的证明方法：\
根据奥尔定理，只要一个图对于每对不相邻的顶点 $(u,v)$，满足 $deg_u+deg_v\ge n$ 则该图一定存在一条哈密顿回路。\
在这个题中，不能通过 $0$ 边相邻等价于树上有一条边连接 $(u,v)$。\
而 $deg_u+deg_v\ge n$ 用树上度数去表达就等价于 $(n-1-Deg_u)+(n-1-Deg_v)=2n-2-Deg_u-Deg_v\ge n$。\
也就是 $Deg_u+Deg_v\le n-2$。\
我们设树上度数最大的点度数为 $D$，显然当 $D=n-1/n-2$ 的时候我们不符合条件，并且由于一个哈密顿回路每个点的度数为 $2$，这也明显构不成哈密顿回路。\
那当 $D<n-2$ 时，我们只需要另一个点的度数 $\le n-2-D$ 就可以保证有哈密顿回路了。\
所以当（直径 $>5$）或（直径 $=5$ 且有至少 $2$ 个非直径中心节点度数 $\ge 2$ 时）一定有哈密顿回路。\
接下来我们分类讨论：
- 直径 $=4$。此时一定只存在两个非叶子节点，并且由于一条边连接了这两点，所以它俩至少可以有一个公共节点可以相连，然后你随便将这两个点向其余能连的点连一条边，你会发现其余有用的边全都不在树上，那想构造一个哈密顿回路就易如反掌了。
- 直径 $=5$ 且只有一个非直径中心节点度数 $\ge 2$。那我们可以先将度数最大的点与其树上不相邻的那个点连边，这样以后将它俩看作一个点继续跑上一个方法就行了。\
最后你会发现这两种方法的前提是 $n\ge 5$，一看题面正好，不需要特判了。

那对于 $D=n-1/n-2$ 的情况那就是我们可以转化成要选择其 $2/1$ 条边删除，代价是边权，求最小代价，这是个显然的贪心。只需要选最小的边权即可。
## 实现
实现方面由于有加/删边且修改操作是针对路径的，所以我们选择 LCT。\
首先我们通过边权化点权的技巧把边权转化。\
对于操作 $1,2$ 直接正常 LCT 即可（删边可能需要注意思考一下），我们来看如何维护答案。\
首先这个题要求子树 $\min$，由于 $\min$ 没有逆元，所以我们只能开一个 `multiset` 去存。\
那对于一条链要通过虚边贡献到其子树，我们需要知道其链首节点的权值，这一点我们可以维护。\
但是我们在反转子树后发现无法通过原链首节点的权值得到反转后链首节点的权值，那么我们这里利用双向维护法，发现新的链首就是原链尾，我们只需要再维护一下链尾的点权，反转时也调换一下即可。\
最后统计答案时为了方便，我们还有一个小技巧。\
若当前答案不为 $0$，那一定有个重心 $T$，我们可以通过 `split(T,T)` 的方式规避掉实链上的讨论。
## 总结
本题首先结论还是比较好猜的，感性理解起来也比较容易。\
实现方面我们通过利用：边权转点权，维护子树信息，双向维护法这三种方法也能比较轻松完成代码实现。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+666;
const int inf=5e11+7;
int n,q,deg[N],cnt;
pair<int,int>e[N];
struct node{
    int son[2],fa;
    bool tag;
    int val,tag2,lft,rft,siz;
    multiset<int>si;
}tr[N<<1];
void dfs(int x){
    if(tr[x].son[0])dfs(tr[x].son[0]);
    cout<<x<<" ";
    if(tr[x].son[1])dfs(tr[x].son[1]);
}
bool notroot(int x){
    return tr[tr[x].fa].son[0]==x||tr[tr[x].fa].son[1]==x;
}
void pushup(int x){
    if(!x)return;
    if(tr[x].son[0])tr[x].lft=tr[tr[x].son[0]].lft;
    else tr[x].lft=tr[x].val;
    if(tr[x].son[1])tr[x].rft=tr[tr[x].son[1]].rft;
    else tr[x].rft=tr[x].val;
    tr[x].siz=tr[tr[x].son[0]].siz+tr[tr[x].son[1]].siz+1;
}
void pushdown(int x){
    if(tr[x].tag){
        swap(tr[x].son[1],tr[x].son[0]);
        swap(tr[tr[x].son[0]].lft,tr[tr[x].son[0]].rft);
        swap(tr[tr[x].son[1]].lft,tr[tr[x].son[1]].rft);
        tr[tr[x].son[0]].tag^=1;
        tr[tr[x].son[1]].tag^=1;
        tr[x].tag=0;
    }
    if(tr[x].tag2){
        tr[tr[x].son[0]].tag2+=tr[x].tag2;
        tr[tr[x].son[1]].tag2+=tr[x].tag2;
        tr[tr[x].son[0]].val+=tr[x].tag2;
        tr[tr[x].son[1]].val+=tr[x].tag2;
        tr[tr[x].son[0]].lft+=tr[x].tag2;
        tr[tr[x].son[0]].rft+=tr[x].tag2;
        tr[tr[x].son[1]].lft+=tr[x].tag2;
        tr[tr[x].son[1]].rft+=tr[x].tag2;
        tr[x].tag2=0;
    }
}
void pushall(int x){
    if(notroot(x))pushall(tr[x].fa);
    pushdown(x);
}
void rotate(int x){
    int y=tr[x].fa,z=tr[y].fa;
    int k=tr[y].son[1]==x;
    if(notroot(y)){
        tr[z].son[tr[z].son[1]==y]=x;
    }
    tr[x].fa=z;
    tr[y].son[k]=tr[x].son[k^1];
    tr[tr[x].son[k^1]].fa=y;
    tr[x].son[k^1]=y;
    tr[y].fa=x;
    pushup(y);
    pushup(x);
}
void splay(int x){
    pushall(x);
    while(notroot(x)){
        int y=tr[x].fa,z=tr[y].fa;
        if(notroot(y)){
            rotate((tr[y].son[1]==x)^(tr[z].son[1]==y)?x:y);
        }
        rotate(x);
    }
}
void access(int x){
    for(int y=0;x;x=tr[x].fa){
        splay(x);
        if(y)tr[x].si.erase(tr[x].si.lower_bound(tr[y].lft));
        if(tr[x].son[1])tr[x].si.insert(tr[tr[x].son[1]].lft);
        tr[x].son[1]=y;
        pushup(x);
        y=x;
    }
}
void makeroot(int x){
    access(x);
    splay(x);
    tr[x].tag^=1;
    swap(tr[x].lft,tr[x].rft);
}
void split(int x,int y){
    makeroot(x);
    access(y);
    splay(y);
}
void link(int x,int y){
    makeroot(x);
    makeroot(y);
    tr[x].fa=y;
    tr[y].si.insert(tr[x].lft);
}
void cut(int x,int y){
    makeroot(x);
    access(y);splay(x);
    tr[x].son[1]=0;tr[y].fa=0;
    pushup(x);
}
void Cut(int x){
    int u=e[x].first,v=e[x].second;
    cut(u,x+n);cut(x+n,v);
}
int rt;
signed main(){
    cin>>n>>q;
    for(int i=1;i<=n;++i){
        tr[i].val=inf;
        pushup(i);
    }
    for(int i=1;i<n;++i){
        int u,v,w;cin>>u>>v>>w;
        cnt++;
        e[cnt]={u,v};
        deg[u]++;deg[v]++;
        if(deg[u]==n-2)rt=u;
        if(deg[v]==n-2)rt=v;
        tr[cnt+n].val=w;
        pushup(cnt+n);
        link(u,cnt+n);link(cnt+n,v);
    }
    while(q--){
        int op;cin>>op;
        if(op==1){
            int id,u,v,w;cin>>id>>u>>v>>w;
            Cut(id);
            cnt++;
            e[cnt]={u,v};
            tr[cnt+n].val=w;
            pushup(cnt+n);
            link(u,cnt+n);link(cnt+n,v);
            if(deg[e[id].first]==n-2)rt=0;
            if(deg[e[id].second]==n-2)rt=0;
            deg[e[id].first]--;deg[e[id].second]--;
            deg[u]++;deg[v]++;
            if(deg[u]==n-2)rt=u;
            if(deg[v]==n-2)rt=v;
        }else{
            int u,v,w;cin>>u>>v>>w;
            split(u,v);
            tr[v].val+=w;
            tr[v].tag2+=w;
            tr[v].lft+=w;
            tr[v].rft+=w;
        }
        if(!rt){
            cout<<0<<"\n";
        }else{
            makeroot(rt);access(rt);
            int res=*tr[rt].si.begin();
            if(deg[rt]==n-1){
                res+=*next(tr[rt].si.begin());
            }
            cout<<res<<"\n";
        }
    }
    return 0;
}
```

---

## 作者：Sol1 (赞：2)

很抱歉在出这题的时候没有想到要干掉 LCT。这里给出一个不使用 LCT 的做法。

---

首先我们不难发现答案不为 $0$ 就需要一个很强的条件。

具体分析考虑对树黑白染色。则我们只需要两对黑点和白点 $(b_1,w_1)$ 和 $(b_2,w_2)$，使得 $b_1\neq b_2,w_1\neq w_2$ 且两对点之间都没有边，则答案就是 $0$。

当不存在时，设白点构成集合 $S_1$，黑点构成集合 $S_2$。不妨设 $|S_1|\leq |S_2|$。

如果 $|S_1|=1$，则树是菊花，此时树的补图是一个单点和一个大小为 $n-1$ 的完全图，则必须选择边权最小的两条边。

如果 $|S_1|>1$，再分类讨论：

- 如果 $|S_2|=2$，则 $|S_1|=|S_2|=2$，即 $n=4$，题目限制 $n\geq 5$，故不考虑。
- 如果 $|S_2|\geq 3$，则在 $S_1$ 中任取一个点 $w_1$。如果这个点与 $S_2$ 中至少两个点有连边且与 $S_2$ 中至少一个点没有连边，则从 $S_1$ 中取另一个点 $w_2$，如果答案不为 $0$，则 $w_2$ 必须与所有与 $w_1$ 相邻的点有连边。由于至少有两个这样的点，所以会形成环，矛盾。从而对于 $S_1$ 中任意一点，要么它与 $S_2$ 中所有点有连边，要么它与 $S_2$ 中恰好一个点有连边。由于 $|S_2|\geq 3$，所以最多一个点能够和 $S_2$ 中所有点连边；同时如果有两个点都只向 $S_2$ 连一条边，则可分类讨论得到答案为 $0$。于是答案不为 $0$ 时必满足 $|S_1|=2$，且有一个点向 $S_2$ 内所有点连边。

从而答案不为 0 的情况要么是一个菊花，要么是一个菊花外面再挂一个点。

菊花的情况就是直接选边权最小的两条边。菊花外面挂一个点的情况经过一些简单分析可得应选择与菊花中心相邻的最小的边。

判这两个结构可以直接判度数。这样我们可以直接解决没有路径加的情况。

我们定义有用边的概念：如果一个时刻答案不为 $0$，那么这个时刻树上的所有边都是有用边。注意一条边在最后一次答案不为 $0$ 的时刻之后就变为无用边。不难发现有用边在任意时刻都构成上面的结构，或者是一个菊花和一个孤立的边。那么我们不难发现一次路径加操作修改的有用边不会超过 $3$ 条。我们尝试把这些边找出来。

方便起见我们再定义所有有用边的端点都是有用点。

考虑离线询问后线段树分治分别维护：

- 删去所有有用边之后的图连通性；
- 每一个连通块里面包含的有用点；
- 与每一个有用点相邻的所有有用边。

我们在有用点之间建图：如果一个连通块里面包含两个有用点，则它们之间连边；再连上所有有用边，形成一棵树，然后在这个树上暴力把路径加操作拆成单独修改一条边的边权，然后再做没有路径加的做法即可。为了在 $O(1)$ 时间内搜索到路径，我们可以钦定度数最大的点为根，从一个点开始搜索时，如果搜索到根就停止搜索，这样最多遍历 $O(1)$ 个点。

总复杂度 $O((n+q)\log^2 n)$，实现繁琐。

---


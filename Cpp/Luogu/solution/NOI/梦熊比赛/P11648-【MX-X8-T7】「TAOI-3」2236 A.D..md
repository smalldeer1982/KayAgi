# 【MX-X8-T7】「TAOI-3」2236 A.D.

## 题目背景

原题链接：<https://oier.team/problems/X8H>。

---

公元 2236 年 4 月 1 日，收到了 99 封邮件。

这 99 封内容完全相同的邮件的发件人是......她。

## 题目描述

Masuko 有一棵 $n$ 个结点的树，以 $1$ 为根，每个结点上都有一个 $[1,k]$ 之间的颜色 $c_i$（$\bm{k \le 15}$），同时给定权值数组 $a_1,a_2,\dots,a_{k}$。

定义两个点 $u,v$ 之间的权值 $f(u,v)$ 如下：

- 设 $u=p_1,p_2,\dots,p_m=v$ 是 $u$ 到 $v$ 的最短路径，$f(u,v)=\prod_{i\in\{x|\exists j\in[1,m],c_{p_j}=x\}}a_i$。

即 $u,v$ 最短路径上所有出现过的颜色的权值乘积。

你需要对每个 $u=1,2,3,\dots,n$。求出 $u$ 子树内，所有无序点对的权值和。具体的，假设 $S_u$ 表示所有到根的最短路径上经过 $u$ 的结点组成的集合，你需要输出：

$$
\sum_{x,y\in S_u,x\leq y} f(x,y)
$$

答案对 $998244353$ 取模。

## 说明/提示

**【样例解释 #1】**

- 当 $u=2$ 时，$u$ 子树内只有 $\{2\}$，$f(2,2)=a_{c_2}=1$。
- 当 $u=4$ 时，$u$ 子树内有 $\{2,4\}$，答案为 $f(2,2)+f(4,4)+f(2,4)=1+1+1=3$。


**【数据范围】**

**本题采用捆绑测试**。

- 子任务 1（5 分）：$n\leq 1000$；
- 子任务 2（10 分）：$n\leq 5000$；
- 子任务 3（10 分）：$k=2$；
- 子任务 4（10 分）：$v_i=u_i+1$；
- 子任务 5（10 分）：$u_i=1$；
- 子任务 6（20 分）：$u_i$ 在 $[1,i]$ 中随机生成，$v_i=i+1$；
- 子任务 7（15 分）：$n\leq 10^5$；
- 子任务 8（10 分）：$n\leq 2\times 10^5$；
- 子任务 9（10 分）：无特殊限制。


对于所有数据，保证 $1\leq n\leq 5\times 10^5$，$1\leq k\leq 15$，$0\leq a_i<998244353$，$1\leq c_i\leq k$，$1 \le u_i,v_i \le n$。

## 样例 #1

### 输入

```
5 3
1 4 5
2 1 3 1 1
5 4
5 1
4 2
1 3
```

### 输出

```
107 1 5 3 6
```

## 样例 #2

### 输入

```
10 4
181 339 132 527
2 1 1 1 1 3 1 1 4 4
8 5
5 2
2 9
9 3
8 4
9 1
1 6
2 10
8 7
```

### 输出

```
183192077 480177 181 181 1810 132 181 1086 1720916 527
```

# 题解

## 作者：min_inf (赞：18)

你们萌熊 X 组最后一题都这么唐的吗。。

首先这个 $a_i$ 乘起来的权值看上去有点无敌，我们不管这个，当他是指定 $2^k$ 个权值。

然后我们从下往上 DFS 的时候算一下子树间的贡献，需要做的事情是对一个集合内 $x\gets x|y$ 以及对两个集合算 $\sum w_{x|y}$ 并合并这两个集合。

考虑根号分治，每个集合维护 $\le B$ 个零散的值和一些关于其他值的信息，合并的时候分别暴力合并，散块超过了 $B$ 就暴力重构一下，总共只会重构 $\frac nB$ 次。

考虑怎么算合并的两个集合之间的贡献，散块的贡献暴力求复杂度是只有 $O(nB)$ 的，整块每次暴力 FWT 求，散块一个点到整块的贡献是形如 $\sum a_yb_{x|y}$ 的，就是 [这个题](https://www.luogu.com.cn/article/eom4m2xq)，每次重构大块的时候倒着做一下 FWT 预处理就行了。

时间复杂度 $O(n\sqrt{k2^k})$。[code](https://www.luogu.com.cn/paste/316196kp)

---

## 作者：critnos (赞：10)

弱智做法过了好多天还没人写题解有点怪。dsu on tree 算跨过每个点的路径权值，先考虑重子树的贡献怎么继承，可以发现每个点的权值只会变化 $k$ 次，预处理一下就行了。那就是维护个数据结构支持单点修改 $a_x$，查询 $\sum_y a_yf_{x|y}$。由于 $f$ 是用乘积计算的，显然可以拆成高低 $k/2$ 位维护。

修改 $O(nk)$ 次，查询 $O(n\log n)$ 次，时间复杂度 $O(n(k+\log n)2^{k/2})$。非常，好写。

---

## 作者：eastcloud (赞：5)

写一个详细点的题解。

考虑暴力怎么做，对于每个点 $u$，我们尝试求出 $\text{lca} (x,y) =u$ 的点对 $(x,y)$ 的贡献，每个点的答案就是子树内贡献的和。暴力做法就是每次把点 $u$ 两个子树合并，计算 $x$ 和 $y$ 分别位于这两部分时的贡献。

这里如果你直接枚举两部分子树内的点然后贡献，按照树上背包的方法分析就是 $O(n^2)$ 的，如果你每次合并做 FWT 就是 $O(nk2^k)$ 的。

你注意这两种合并方式中，前者的复杂度与合并的两部分大小有关，后者只与 $k$ 有关，这启发我们结合一下两部分然后平衡一下复杂度。设一个阈值 $B$，每个节点维护两部分，一部分是暴力合并的部分，另一部分是 FWT 合并的部分，记前者为散点，后者为整块，每次合并时二者对应合并，如果散点数量超过阈值了就清空并全部塞到整块里面。

算答案怎么办？散点可以暴力，这部分的复杂度是 $O(nB)$ 的，因为一个散点最多和 $O(B)$ 个点被暴力考虑，否则就会被塞到整块里。整块和整块可以 FWT，这只会操作 $O(\frac{n}{B})$ 次，也是对的。

你发现似乎只有散点和整块的贡献不好处理，而这需要对每个 $x$ 算一个类似 $a_x=\sum_{y} c_{x|y}$ 的东西，注意到 $c_{x|y}$ 可以拆开算，变成 $a_x=c_x\sum_{y} c_{(x|y) -x}$，然后后者可以在一个类似 FWT 的过程中算掉，考虑在 FWT 中你每次对于某一位为 0 和 1 其他位一样的数作变换，设这两个数为 $x$ 和 $y$，令 $x\leftarrow (x+wy)$ 和 $y\leftarrow (x+y)$，其中 $w$ 是这一位的贡献，这部分复杂度是 $O(nB)$ 的。

如果你 T 了可以考虑块长开大点，因为常数有点大。


```cpp

#include<bits/stdc++.h>

#define ll long long
#define pi pair<int,int>
#define vi vector<int>
#define cpy(x,y,s) memcpy(x,y,sizeof(x[0])*(s))
#define mset(x,v,s) memset(x,v,sizeof(x[0])*(s))
#define all(x) begin(x),end(x)
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ary array
#define eb emplace_back
#define IL inline
#define For(i,j,k) for(int i=(j);i<=(k);i++)
#define Fol(i,k,j) for(int i=(k);i>=(j);i--)

using namespace std;

#define B 1400
#define N 500005
#define K 33005
#define mod 998244353

int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9')f=(ch=='-'?-1:f),ch=getchar();
    while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void write(int x){
    if(x<0)x=-x,putchar('-');
    if(x/10)write(x/10);
    putchar(x%10+'0');
}

void debug(auto &&...x){
    ((cerr<<x<<' '),...);
    cerr<<'\n';
}

IL int pls(int x,int y){return (x+y>=mod?x+y-mod:x+y);}
IL int sub(int x,int y){return (x-y<0?x-y+mod:x-y);}
IL void Add(int &x,int y){x=pls(x,y);}
IL void Dec(int &x,int y){x=sub(x,y);}
IL int mul(int x,int y){return x*1ll*y%mod;}
IL int qp(int x,int y=mod-2){int ans=1;while(y){if(y&1)ans=mul(ans,x);x=mul(x,x);y>>=1;}return ans;}

int id[N],w[N],c[N],a[N];
basic_string<int> e[N];
int vis[B][16],f[B][K],_f[B][K],coef[B][K],ans[N],cnt,tmp[K];
vi S[N];
int n,k;

void FWT(int *g,int opt){
    for(int len=2,mid=1;len<=(1<<k);len<<=1,mid<<=1){
        for(int j=0;j<(1<<k);j+=len){
            for(int k=j;k<j+mid;k++){
                if(!opt)Add(g[k+mid],g[k]);
                else Dec(g[k+mid],g[k]);
            }
        }
    }
}

int calc(int u,int v){
    int res=0;
    if(id[u] && id[v]){
        For(i,0,(1<<k)-1)tmp[i]=mul(_f[id[u]][i],_f[id[v]][i]);
        FWT(tmp,1);
        For(i,0,(1<<k)-1)Add(res,mul(tmp[i],w[i]));
    }
    if(id[v])for(auto val:S[u])Add(res,mul(coef[id[v]][val],w[val]));
    if(id[u])for(auto val:S[v])Add(res,mul(coef[id[u]][val],w[val]));
    for(auto val:S[u])for(auto val2:S[v])Add(res,w[val|val2]);
    return res;
}

void rebuild(int u,int v){
    if(!id[u])id[u]=++cnt;
    for(auto val:S[u])f[id[u]][val]++;S[u].clear();
    if(id[v])For(i,0,(1<<k)-1)f[id[u]][i]+=f[id[v]][i];
    For(i,0,(1<<k)-1)_f[id[u]][i]=f[id[u]][i],coef[id[u]][i]=f[id[u]][i];
    FWT(_f[id[u]],0);
    for(int len=2,mid=1;len<=(1<<k);len<<=1,mid<<=1){
        int z=__lg(len);
        for(int j=0;j<(1<<k);j+=len){
            for(int k=j;k<j+mid;k++){
                int x=coef[id[u]][k],y=coef[id[u]][k+mid];
                coef[id[u]][k]=pls(x,mul(y,c[z]));
                coef[id[u]][k+mid]=pls(x,y);
            }
        }
    }
    For(i,1,k)vis[id[u]][i]=0;
}

void opr(int u,int t){
    if(vis[id[u]][t])return;vis[id[u]][t]=1;
    For(S,0,(1<<k)-1)if(!(S&(1<<(t-1))))Add(f[id[u]][(S|(1<<(t-1)))],f[id[u]][S]),f[id[u]][S]=0;
    For(i,0,(1<<k)-1)_f[id[u]][i]=f[id[u]][i],coef[id[u]][i]=f[id[u]][i];
    FWT(_f[id[u]],0);
    for(int len=2,mid=1;len<=(1<<k);len<<=1,mid<<=1){
        int z=__lg(len);
        for(int j=0;j<(1<<k);j+=len){
            for(int k=j;k<j+mid;k++){
                int x=coef[id[u]][k],y=coef[id[u]][k+mid];
                coef[id[u]][k]=pls(x,mul(y,c[z]));
                coef[id[u]][k+mid]=pls(x,y);
            }
        }
    }
}


void dfs(int x,int fa){
    S[x].pb((1<<(a[x]-1)));ans[x]=c[a[x]];
    for(auto v:e[x]){
        if(v==fa)continue;
        dfs(v,x);
        //operate
        if(id[v])opr(v,a[x]);
        for(auto &val:S[v])val|=(1<<(a[x]-1));
        //calculate
        Add(ans[x],calc(x,v));Add(ans[x],ans[v]);
        //merge
        for(auto val:S[v])S[x].pb(val);vector<int>().swap(S[v]);
        if(id[v])swap(id[x],id[v]);
        if(id[v] || S[x].size()>B)rebuild(x,v);
    }
}

int main(){
    #ifdef EAST_CLOUD
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
    #endif

    n=read(),k=read();
    For(i,1,k)c[i]=read();
    For(i,1,n)a[i]=read();
    For(i,1,n-1){
        int u=read(),v=read();
        e[u]+=v;e[v]+=u;
    }
    For(S,0,(1<<k)-1){
        w[S]=1;
        For(j,1,k)if(S&(1<<(j-1)))w[S]=mul(w[S],c[j]);
    }
    dfs(1,0);
    For(i,1,n)write(ans[i]),putchar(' ');
    return 0;
}

```

---

## 作者：cyffff (赞：4)

[$\text{Link}$](https://www.luogu.com.cn/problem/P11648)
## 题意
给你一颗 $n$ 个结点的树，结点 $1$ 为根，结点有 $[1,k]$ 的颜色 $c_i$。给定序列 $a_{1\sim k}$，定义两个结点 $x,y$ 之间的权值 $f(x,y)$ 为所有在 $x\to y$ 的简单路径上出现过的颜色 $c$ 的 $a_c$ 之积。

对 $\forall i\in[1,n]$ 求出 $i$ 子树内的点两两的权值之和，对 $998244353$ 取模。

$n\le 5\times 10^5$，$k\le 15$。
## 题解
直接对每个颜色集合预处理出其权值 $v_s$，考虑计算 $x$ 的不同子树 $i,j$ 间的答案。

维护子树 $i$ 内每个点到 $i$ 的路径颜色集合 $S_i$，需要支持两种操作：将集合 $S_i$ 内所有元素并上 $c_x$；查询 $S_i,S_j$ 之间两两元素 $p,q$ 的 $v_{p\cup q}$ 之和，再合并这两个集合。

一眼可以看出两个暴力，分别是直接枚举和 FWT 卷积，于是考虑根号分治。设置阈值 $b$，若 $S_i,S_j$ 均有 $\ge b$ 个元素便直接卷积；若 $S_i,S_j$ 均有 $\le b$ 个元素则直接枚举；否则对 $S_i$ 内每个元素 $p$ 计算 $\sum_{q\in S_j}cnt_qv_{p\cup q}$，这可以采用 [All Pairs Similarity P](https://www.luogu.com.cn/problem/P11458) 的做法，进行 $O(2^kk)$ 预处理 $O(1)$ 回答。
****
具体地，设 $f_p$ 表示 $p$ 的答案，集合的包含、并集等条件引出一类做法，考虑设计一辅助状态 $g_s$ 满足：

$$f_s=\sum_{T⊇S} g_t$$

仅考虑一个元素 $q\in S_j$，我们希望构造出 $g_t$ 满足其高维后缀和为 $f_s=v_{s\cup q}$。那么我们对 $v_{0\sim 2^k-1}$ 做高维后缀差分得到数组 $w_{0\sim 2^k-1}$ 满足：

$$v_s=\sum_{T⊇S} w_t$$

构造 $g_t=[q\sube T]w_{t}$ 即可，容易验证，所有同时是 $p$ 和 $q$ 的超集的数 $t$ 都会作出 $w_{t}$ 的贡献，它们的和正好等于 $v_{p\cup q}$。

每次预处理都需要做一次高维前缀和和一次高维后缀和，时间复杂度为 $O(2^kk)$，单次查询 $O(1)$。
****

注意每次计算完还需要合并，我们对每个集合分别维护一个 $\le b$ 个元素的零散部分和非零散部分的信息，合并后若零散部分大小 $\ge b$ 直接将其重构入非零散部分即可。将集合内的数取并可以直接暴力对零散部分做，维护非零散部分的取并标记。

重构与卷积次数分别只有 $O(n/b)$ 次，零散部分的枚举量为 $\sum_{i,j}\min(siz_i,b)\min(siz_j,b)$ 即 $O(nb)$。

取 $b=\sqrt{2^kk}$，时间复杂度 $O(n\sqrt{2^kk})$。
****

---

## 作者：251Sec (赞：3)

介绍一下被打爆的 std 做法。下面设 $n$ 和 $k2^k$ 同阶。

容易转化为对每个点算以它为 LCA 的路径的答案。

先树分块。在树上选 $O(\sqrt n)$ 个关键点使得每个不包含关键点的连通块大小是 $O(\sqrt n)$ 级别的，且所有关键点两两的 LCA 也是关键点。这可以通过 DFS 一遍贪心做到。

不经过关键点的路径可以暴力计算，这是 $O(n \sqrt n)$ 的。

LCA 为关键点的路径，考虑对每个关键点单独做。如果只要求 LCA 在关键点子树内部是简单的，一遍 FWT 搞定，但是我们要求 LCA 恰好是它，就需要减掉每个儿子子树内的贡献。在度数很大的时候我们肯定不能对每个子树 FWT。考虑类似根号分治的东西，如果某个儿子的子树内没有关键点，它的大小一定不超过 $O(\sqrt n)$ 可以暴力统计，如果有关键点再 FWT，则每个关键点只会在它祖先里第一个关键点处被 FWT。总复杂度 $O(n \sqrt n)$。

剩下的路径即经过关键点且 LCA 不是关键点的路径。那么路径 LCA 的两侧一定只有恰好一侧有关键点，否则 LCA 也会是关键点。枚举有关键点的那一侧经过的最靠上的关键点是谁，可以 DFS 算出这个关键点往下走到每个点的每种颜色集合出现次数 $f_S$。然后我们可以直接枚举不经过关键点那一侧的端点并处理出另一侧的颜色集合 $x$，贡献为 $\sum_i f_i w_{i \cup x}$。考虑对每个 $x$ 预处理这个贡献，由于 $w$ 是个每位权值相乘的形式，可以类似 FWT 地逐位处理。这样也是 $O(n \sqrt n)$ 的。

综上，我们在 $O(n \sqrt n)$ 的复杂度内解决了原问题。

---


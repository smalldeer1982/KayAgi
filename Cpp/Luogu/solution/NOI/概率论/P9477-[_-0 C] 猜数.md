# [_-0 C] 猜数

## 题目背景

小 $\mathfrak{f}$ 和小 $\mathfrak{g}$ 在玩猜数游戏，但是因为风声太大，他们听不清楚对方说的话……

## 题目描述

评测机在区间 $[1,n]$ 中等概率随机地选择一个整数 $x$，你的任务是猜测这个数。

你可以每次给出一个 $[1,n]$ 中的整数 $y$，询问 $y$ 和 $x$ 的大小关系。你最多可以询问 $q$ 次。

但是，由于某些原因，评测机有 $p\%$ 的概率会出错。

具体地说：

- 如果 $y=x$，那么评测机返回 `=`。
- 如果 $y\ne x$，且当前已经是第 $q$ 次询问，那么评测机返回 `!`。
- **得到以上两种结果后，你应当停止询问。**
- 如果 $y>x$，那么评测机有 $(100-p)\%$ 的概率返回 `>`，有 $p\%$ 的概率返回 `<`。
- 如果 $y<x$，那么评测机有 $(100-p)\%$ 的概率返回 `<`，有 $p\%$ 的概率返回 `>`。

每次询问，你需要向**标准输出**输出一个 $[1,n]$ 中的整数，**然后清空缓冲区**。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。

然后你需要从**标准输入**中输入一个字符，代表评测机返回的结果。

## 说明/提示

**样例 $1$ 解释：**

此时该测试点的状态为 `AC`。

**样例 $2$ 解释：**

$x=37,y=50$ 时，$y>x$，有 $10\%$ 的概率输出 `<`，恰好输出了 `<`。

**样例 $3$ 解释：**

此时该测试点的状态为 `WA`。

**本题采用捆绑测试。**

每个 Subtask 下设有 $5$ 个测试点，你只需通过其中**至少 $3$ 个**测试点即可得到该 Subtask 对应的分数。

本题不使用子任务依赖。

对于所有数据，$n=10^{18}$。

| 编号 | 分值 | $p=$ | $q=$ | 时限 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $0$ | $60$ | $\texttt{1s}$ |
| $1$ | $10$ | $10$ | $500$ | $\texttt{1s}$ |
| $2$ | $10$ | $25$ | $2000$ | $\texttt{1s}$ |
| $3$ | $15$ | $25$ | $1000$ | $\texttt{1s}$ |
| $4$ | $20$ | $25$ | $700$ | $\texttt{1s}$ |
| $5$ | $10$ | $25$ | $400$ | $\texttt{1s}$ |
| $6$ | $10$ | $40$ | $2500$ | $\texttt{1s}$ |
| $7$ | $10$ | $45$ | $10000$ | $\texttt{1s}$ |
| $8$ | $5$ | $48$ | $62500$ | $\texttt{3s}$ |
| $9$ | $5$ | $49$ | $250000$ | $\texttt{10s}$ |

## 样例 #1

### 输入

```
100 0 10

>

<

=```

### 输出

```

50

25

37```

## 样例 #2

### 输入

```
100 10 10

<

<

=```

### 输出

```

50

25

37```

## 样例 #3

### 输入

```
100 0 2

>

!```

### 输出

```

50

25```

# 题解

## 作者：WYXkk (赞：51)

[题目链接](https://www.luogu.com.cn/problem/P9477)

出题人题解实际上在正确性这一块完全是乱说明的，没有任何逻辑，纯粹是名词堆砌：

- 计算信息熵变化不能对事件进行捆绑
  
- 每次询问后信息熵不一定会下降那么多，甚至不一定会下降
  
- 信息熵下降与接近正确答案没有任何关系，概率更集中不一定会集中在正确答案上
  

下面给出一种我想的一种正确性的合理说明方式。

---

贝叶斯公式可以如下理解：有若干件不同的事 $A_1,A_2,\cdots, A_n$，它们之中必定发生且只发生一件。设 $A_i$ 的发生概率为 $p_i$，$A_i$ 发生时 $B$ 的发生概率为 $q_i$，则 $B$ 发生时 $A_i$ 的发生概率，即为将 $p_iq_i$ 进行归一化（全部乘以特定值使得和为 $1$）后的结果。

为了简化下面的说明，用 $p$ 代表原题中的 $p\%$。

对于此题来说，可以定义 $1\le i\le n$ 都对应一个权值 $a_i$，初始 $a_i=1/n$。假设询问 $y$ 后返回了 `<`，那么将 $a_y$ 归零，对所有 $i<y$ 将 $a_i$ 乘上 $p$，对所有 $i>y$ 将 $a_i$ 乘上 $1-p$。这样，任何时刻，$a_i$ 都代表此刻结果是 $i$ 的“概率权值”，归一化后即为实际概率。

直到答对之前，每一次询问后，$a_x$ 将以 $p$ 的概率乘以 $p$，$1-p$ 的概率乘以 $1-p$，即 $\ln a_x$ 将以 $p$ 的概率增加 $\ln p$，$1-p$ 的概率增加 $\ln (1-p)$。

相信大家都听说过大数定律，即一个随机变量多次试验后的均值总是会趋于它的期望。它有一个更“精确”的版本，即中心极限定理：如果随机变量 $X$ 的期望是 $E$，方差是 $\sigma^2$，则 $n$ 次试验求平均后，结果的分布会趋向于正态分布 $N(E,\sigma^2/n)$。

应用在上面即说明，在 $q$ 次询问没猜出来后，

$\dfrac{\ln a_x-\ln(1/n)}{q}\sim N(p\ln p+(1-p)\ln (1-p),p(1-p)\ln^2(1/p-1)/q)$

现在已经搞清楚了概率权值的分布。既然在求出最终结果前需要归一化，那么下面就研究归一化的分母，即 $\sum a_i$。

我们希望最终能够以大概率选中答案，即 $a_x/\sum a_i$ 尽量大，那么应该让归一化的分母尽量小。

以贪心策略来说，在每一步询问时，应该让 $\max(p\sum\limits_{i<y}a_i+(1-p)\sum\limits_{i>y}a_i,(1-p)\sum\limits_{i<y}a_i+p\sum\limits_{i>y}a_i)$ 尽量小。

显然，将 $y$ 选为 $\sum\limits_{i<y}a_i\le \sum a_i/2$ 与 $\sum\limits_{i<y}a_i>\sum a_i/2$ 的交界点时，$\sum\limits_{i<y}a_i\le \sum a_i/2,\sum\limits_{i>y}a_i\le \sum a_i/2$，那么上面的式子就不会超过 $\sum a_i/2$。

如此一来，就能保证每次 $\sum a_i$ 至少减少一半。

现在假设已经按照上面的方法进行了 $q$ 次询问且没猜出来，此时 $\sum a_i\le 2^{-q}$。可以发现， 一旦 $a_x> \sum a_i/2$，下一次询问必定会询问 $x$，即猜中，那么下一次猜中的概率至少为 $a_x> 2^{-q-1}$ 的概率。

根据上面的正态分布结论，将 $p,n,q$ 带进去计算可以就可以得到一个单点通过概率的下界了。

现在就是把各 Subtask 的数据范围一个一个带进去看了。可以使用 [WolframAlpha](https://www.wolframalpha.com/)。

以最后一个 Subtask 为例，带入 $p=0.49,n=10^{18},q=249999$（需要保留最后一次回答）。这里舍入误差相对比较大，考虑移一些项，记 $t=q\left(\dfrac{\ln a_x-\ln (1/n)}{q}-(p\ln p+(1-p)\ln (1-p))\right)$，则 $t\sim N(0,qp(1-p)\ln^2(1/p-1))=N(0,99.9863)$，需要求的概率是 $P(a_x>2^{-q-1})=P(t>-9.24975)=82.2527\%$。那么，通过整个 Subtask 的概率至少为 $(10p^3(1-p)^2+5p^4(1-p)+p^5)|_{p=82.2527\%}=95.7926\%$。

可以算出来通过各个 Subtask 的概率依次至少为 $100\%,100\%,100\%,100\%,100\%,98.751\%,96.39\%,95.9417\%,95.8114\%,95.7926\%$（第一个以后的 $100\%$ 是失败概率低于输出精度了），乘起来也有 $83.8166\%$。而且实际上这些概率被低估了很多，有可能不需要等到最后一次询问就已经猜到了，实际的通过概率可能有 $99\%$ 以上。

由此，就得到了一个正确性有保证的做法。

---

具体实现来讲，使用动态开点线段树即可。为了防止概率权值小于实数精度，每次修改时立即归一化即可，整体乘一个常数并不会改变上面的论证的正确性。实现起来没那么麻烦就不附代码了。

---

## 作者：0x3F (赞：23)

在开始询问之前，每个数出现的概率是相等的，即 $P_1=P_2=\cdots=P_n=\frac{1}{n}$。

假设我们询问 $m$，评测机返回 `<`，那么这些概率会发生怎样的变化呢？

显然，$P'_m=0$。

怎么计算 $P'_i(1\le i\le m-1)$ 呢？为此，我们记事件 $A=[x=i]$，事件 $B=[\texttt{评测机返回"<"}]$。

根据 Bayes 公式，有 $P(A\vert B)=\frac{P(A)P(B\vert A)}{P(B)}$。

其中，$P(A\vert B)$ 是已知评测机返回 `<` 后 $x=i$ 的概率，也就是我们要求的 $P'_i$。

$P(A)$ 是 $x=i$ 原先的概率，也就是 $P_i$。

$P(B\vert A)$ 是已知 $x=i$ 时，评测机返回 `<` 的概率。根据定义，该值为 $p\%$。为了避免混淆，记 $k=p\%$。

$P(B)$ 是评测机返回 `<` 的概率。这有两种情况：

一、实际上 $x<m$，评测机出错。$x<m$ 的概率为 $\sum_{j=1}^{m-1}P_j$，评测机出错的概率为 $k$。

二、实际上 $x>m$，评测机不出错。$x>m$ 的概率为 $\sum_{j=m+1}^{n}P_j$，评测机不出错的概率为 $1-k$。

因此，$P(B)=k\sum_{j=1}^{m-1}P_j+(1-k)\sum_{j=m+1}^{n}P_j$。

故 $P'_i=P_i\times\frac{k}{k\sum_{j=1}^{m-1}P_j+(1-k)\sum_{j=m+1}^{n}P_j}$。

同理，当 $m+1\le i\le n$ 时，$P'_i=P_i\times\frac{1-k}{k\sum_{j=1}^{m-1}P_j+(1-k)\sum_{j=m+1}^{n}P_j}$。

类似地可以计算出评测机返回 `>` 时的情况。

那么选取怎样的 $m$ 询问比较好呢？显然，每次询问“中点”（也就是满足 $\sum_{j=1}^{m-1}P_j\le\frac{1}{2},\sum_{j=m+1}^{n}P_j\le\frac{1}{2}$）是一个不错的选择。

接下来我们从信息熵的角度来估算询问的次数。

初始时，信息熵为 $-\log\frac{1}{n}$，答案被完全确定下来，也就意味着信息熵降为 $0$。

我们不妨设询问前，$P(x<m)=P(x>m)=\frac{1}{2}$，那么询问后，两者一个变为 $k$，一个变为 $1-k$，信息熵从 $-\log\frac{1}{2}$ 降为了 $-k\log k-(1-k)\log(1-k)$。

因此，询问次数 $q\approx\frac{-\log\frac{1}{n}}{(-\log\frac{1}{2})-(-k\log k-(1-k)\log(1-k))}$，经计算，足以通过此题。

可以用动态开点线段树维护 $P$ 数组的值。

时间复杂度为 $O(q\log n)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
long double p, r;
int q;
const int _ = 1e7;
int siz, ls[_], rs[_];
long double sum[_], tag[_];
inline void build(void) {
	siz++;
	sum[siz] = 1.0L;
	tag[siz] = 1.0L / n;
}
inline void pushdown(int p, long long L, long long M, long long R) {
	if (!ls[p]) {
		ls[p] = ++siz;
		sum[ls[p]] = (M - L + 1) * tag[p];
		tag[ls[p]] = tag[p];
	} else {
		sum[ls[p]] *= tag[p];
		tag[ls[p]] *= tag[p];
	}
	if (!rs[p]) {
		rs[p] = ++siz;
		sum[rs[p]] = (R - M) * tag[p];
		tag[rs[p]] = tag[p];
	} else {
		sum[rs[p]] *= tag[p];
		tag[rs[p]] *= tag[p];
	}
	tag[p] = 1.0L;
}
inline void pushup(int p) {
	sum[p] = sum[ls[p]] + sum[rs[p]];
}
inline long long mid(int p, long double lef, long long L, long long R) {
	if (L == R) return L;
	long long M = ((L + R) >> 1LL);
	pushdown(p, L, M, R);
	if (sum[ls[p]] >= lef) {
		return mid(ls[p], lef, L, M);
	} else {
		return mid(rs[p], lef - sum[ls[p]], M+1, R);
	}
}
inline long double que(int p, long long l, long long r, long long L, long long R) {
	if (l > R || r < L) {
		return 0.0L;
	} else if (l <= L && r >= R) {
		return sum[p];
	} else {
		long long M = ((L + R) >> 1LL);
		pushdown(p, L, M, R);
		return que(ls[p], l, r, L, M) + que(rs[p], l, r, M+1, R);
	}
}
inline void mul(int p, long double k, long long l, long long r, long long L, long long R) {
	if (l > R || r < L) {
		return;
	} else if (l <= L && r >= R) {
		sum[p] *= k;
		tag[p] *= k;
	} else {
		long long M = ((L + R) >> 1LL);
		pushdown(p, L, M, R);
		mul(ls[p], k, l, r, L, M);
		mul(rs[p], k, l, r, M+1, R);
		pushup(p);
	}
}
int main() {
	cin >> n >> p >> q;
	p /= 100.0L;
	r = 1.0L - p;
	build();
	while (1) {
		long long m = mid(1, 0.5L, 1, n);
		cout << m << endl;
		char ch;
		cin >> ch;
		if (ch == '=' || ch == '!') {
			break;
		} else {
			long double L = que(1, 1, m-1, 1, n);
			long double R = que(1, m+1, n, 1, n);
			mul(1, 0.0L, m, m, 1, n);
			if (ch == '>') {
				long double S = (L * r + R * p);
				mul(1, r / S, 1, m-1, 1, n);
				mul(1, p / S, m+1, n, 1, n);
			} else {
				long double S = (L * p + R * r);
				mul(1, p / S, 1, m-1, 1, n);
				mul(1, r / S, m+1, n, 1, n);
			}
		}
	}
	return 0;
}
```

---

## 作者：Grand_Dawn (赞：8)

[题目链接](https://www.luogu.com.cn/problem/P9477)。

定义 $a_i$ 为：当前所有获得询问的结果的情况下，目前答案为 $i$ 的概率。

可以发现 $a_i$ 的维护较为繁琐，且 $\sum a_i=1$ 的条件没用，所以可以维护 $b_i$ 满足 $\frac{b_i}{a_i}=k$（$k$ 为常数）。$b_i$ 也可称为**概率权值**。

则可以令初始情况下：$b_i=1$。

以下考虑如果新询问一个 $y$，且询问结果为 `<`，则 $b_i$ 的一种比较容易实现的变换：

$$b_i=\begin{cases}\frac{p}{100-p}\  
b_i&i<y\\0&i=y\\b_i&i>y\end{cases}$$

询问结果为 `>` 同理。该种方法可以尽可能减少精度的影响。

接下来考虑如何选取 $y$：

一种比较显然的考虑在于找到 $y$ 使得 $\sum\limits_{i=1}^{y-1}b_i\leq k\sum\limits_{i=1}^{n}b_i$ 且 $\sum\limits_{i=y+1}^{n}b_i\leq (1-k)\sum\limits_{i=1}^{n}b_i$。其中 $k=\frac{1}{2}$。 

这样利用了每次得到的结果，使得信息熵**尽可能**下降。

在证明上，可以发现是比较困难的。 

@[WYXkk](https://www.luogu.com.cn/user/130151) 的证明**似乎**也存在一个小问题：

我们希望最终能够大概率选中答案，并不是使 $\frac{b_x}{\sum b_i}$ 尽量大，而是使 $\frac{b_x}{\sum b_i}$ 尽量成为最大值。

因为我们并不是按照  $\frac{b_x}{\sum b_i}$ 的概率选取 $x$。实际上这么选，在最后一个 subtask 仅选择一次的话，成功率约为 $10^{-4}$ 量级。

既然可能比较难以证明，试验一下在每个 subtask 的情况下，得到正确答案的概率：

|subtask|获得答案次数|试验次数|频率|
|:-:|:-:|:-:|:-:|
|$0$|$100000$|$100000$|$100\%$|
|$1$|$10000$|$10000$|$100\%$|
|$2$|$10000$|$10000$|$100\%$|
|$3$|$10000$|$10000$|$100\%$|
|$4$|$10000$|$10000$|$100\%$|
|$5$|$9527$|$10000$|$95.27\%$|
|$6$|$9490$|$10000$|$94.90\%$|
|$7$|$1909$|$2000$|$95.45\%$|
|$8$|$491$|$500$|$98.2\%$|
|$9$|$198$|$200$|$99.0\%$|


维护 $b_i$ 需要一个维护 区间乘，区间求和 的动态开点线段树，非常简单不详细说明。

```cpp
#include<bits/stdc++.h>
#define double long double
#define ll long long
#define N 20000009
using namespace std;
bool check(ll x){
	cout<<x<<endl;
	char ch;cin>>ch;
	if(ch=='='||ch=='!')exit(0);
	return ch=='<';
}
int ls[N],rs[N],tot;
double tag[N],sum[N];
void addpoint(int& x,ll l,ll r){
	x=++tot;sum[tot]=r-l+1,tag[tot]=1;
}
void pushdown(int x,ll l,ll r){
	ll mid=(l+r)>>1;
	if(ls[x]==0)addpoint(ls[x],l,mid);
	tag[ls[x]]=tag[ls[x]]*tag[x];
	sum[ls[x]]=sum[ls[x]]*tag[x];
	if(rs[x]==0)addpoint(rs[x],mid+1,r);
	tag[rs[x]]=tag[rs[x]]*tag[x];
	sum[rs[x]]=sum[rs[x]]*tag[x];
	tag[x]=1;
}
void update(int x,ll l,ll r,ll ul,ll ur,double um){
	if(r<ul||ur<l)return;
	if(ul<=l&&r<=ur){
		tag[x]=tag[x]*um;
		sum[x]=sum[x]*um;
		return;
	}
	pushdown(x,l,r);ll mid=(l+r)>>1;
	update(ls[x],l,mid,ul,ur,um);
	update(rs[x],mid+1,r,ul,ur,um);
	sum[x]=sum[ls[x]]+sum[rs[x]];
}
ll query(int x,ll l,ll r,double val){
	if(!ls[x]&&!rs[x])return l+(ll)(val*(r-l+1)/sum[x]); 
	pushdown(x,l,r);ll mid=(l+r)>>1;
	if(sum[ls[x]]>=val)return query(ls[x],l,mid,val);
	else return query(rs[x],mid+1,r,val-sum[ls[x]]);
}
ll n;int p,q;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>p>>q;
	addpoint(tot,1,n);
	for(int gd=1;gd<=q;gd++){
		ll x=query(1,1,n,sum[1]/2);
		update(1,1,n,x,x,0);
		if(check(x))update(1,1,n,1,x-1,p/(100.0-p));
		else update(1,1,n,x+1,n,p/(100.0-p));
	}
	return 0;
}
```

BONUS：

实际上 $k$ 的选取非常松，除了 subtask1 以外，其它 subtask 即使在 $k\in [0,1)$ 中任意选择，得到答案的概率也比较大。[记录](https://www.luogu.com.cn/record/117944116)。

---


# [NOI2013] 小 Q 的修炼

## 题目描述

小 Q 最近发现了一款新游戏，游戏的目标是从一个新手修炼成为武功高强的大侠。面对错综复杂的游戏世界，小 Q 要对他面临的每件事情做出谨慎的选择。例如，是否参加一个陌生人邀请的比武；同意或是拒绝用宝剑交换他人的武功秘籍......而小 Q 做出的每一个选择都有可能影响到他以后的发展：面对一个高手，若主动与之比武，很可能会损失惨重；但若不去比武，也许今后就再也见不到这个高手了。

对着这个游戏，小 Q 玩了很多次仍然玩不出他想要的结局，于是他费尽千辛万苦找到了游戏的剧本。令人惊讶的是,游戏的剧本并不像我们平时见到的剧本，反而很像代码。这个剧本是这样描述的：
- 量：有 $2$ 种量，常数和变量。
- 常数：一个整数。
- 变量：初始值为 $0$ 的可变整数，不同变量用不同正整数编号区分。
- 事件：整个剧本由若干个事件构成。所有的事件按照给定的顺序从 $1$ 开始依次编号。事件共有 $3$ 种：普通事件、选择跳转和条件跳转。
- 执行位置：一个整数，表示接下来将会执行的事件编号，如果不存在这个编号的事件则停止，即游戏到了一个结局。最初的时候执行位置为 $1$。
- 普通事件：一个变量增加或减少一个量的值。之后执行位置增加 $1$。
- 选择跳转：两个整数。执行到这里时玩家需要在这两个整数中选择一个，之后执行位置将被修改为这个整数。
- 条件跳转：两个量和两个整数。执行到这里时，若第一个量小于第二个量，则执行位置将被修改为第一个整数，否则将被修改为第二个整数。

小 Q 认为，整个游戏是希望一个叫做「成就值」的变量（编号为 $1$）最大。

## 说明/提示

### 评分标准

对于每组数据，我们采用如下方式评分：
- 如果你的输出不合法,得 $0$ 分。
- 如果你的输出执行了超过 $10^6$ 行剧本,得 $0$ 分。
- 如果你的输出能让剧本正常结束，得 $1$ 分。
- 如果你的输出能让剧本正常结束，且结束时成就值为正数，得 $2$ 分。

我们设置了 $8$ 个评分参数 $a_3 , a_4 , \ldots , a_{10}$。

如果你的输出能让剧本正常结束，且结束时成就值不小于 $a_s$，得 $s$ 分。

如果以上条目有多项满足，则取满足条件中的最高得分。

### 如何测试你的输出

我们提供 `checker` 这个工具来测试你的输出文件是否是可接受的。使用这个工具的方法是，首先进入终端，在终端中运行下面的命令进入本题的文件夹：

`cd train`

然后运行：

`./checker <case_no>`

其中 `case_no` 是测试数据的编号。例如

`./checker 3`

将测试 `train3.out` 是否可以接受。

在你调用这个程序后，`checker` 将根据你给出的输出文件给出测试的结果，其中包括：
- 非法退出：未知错误。
- `Input/Output file does not exist.`：输入/输出文件不存在。
- `Output invalid.`：输出文件有误,此时可能包含具体错误信息。
- `Correct! Your answer is x.`：输出可接受,最后的成就值为 $x$。

### 更多功能
`checker` 还可以检查任意输入输出文件的测试结果，方法是在终端中运行：

`cd train`

`./checker <input_file_name> <output_file_name>`

其中 `input_file_name` 和 `output_file_name` 分别是输入输出文件的名称。例如

`./checker train3.in train3.out`

将测试 `train3.out` 是否可以接受。

使用 `-w` 可以输出每步运行的结果。用法是

`./checker -w <input_file_name> <output_file_name>`

或者

`./checker -w <case_no>`

例如

`./checker -w train3.in train3.out`

### 特别提示

如果选手使用自己生成输入文件进行调试，有可能因规模过大造成 checker 出错。若发生这类情况，请尝试较小规模的数据。

## 样例 #1

### 输入

```
11 2
v 2 + c 19
i v 2 c 3 7 3
s 4 7
v 1 + c 13
v 2 - c 3
i c 0 c 1 2 0
i v 2 c 5 12 8
s 9 12
v 1 + c 23
v 2 - c 5
i c 0 c 1 7 0
```

### 输出

```
1
1
1
2
1
1
```

# 题解

## 作者：PosVII (赞：299)

**前言**

------------

本题解曾是最高赞题解，最近将网盘的链接更新了，请审核通过。

希望严查本题抄题解情况，其中 uid362162 的题解甚至没有给出全部思路，而他的 AC 代码与最优解后排的几位完全重复，或者说，他所谓的优化是通过打表过题？

耗时 $4$ 天，用时 $6$ 小时 AC，谨以此记录我和我小号获得的两个最优解。

我的代码及答案 [云盘](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/6fwmfxuw)，出于私心我不会把我用一晚上调出来的 $7-10$ 代码给出，但测试点思路及代码使用方法会在正文给出。

# Case 1-7:

文件夹中的 TrainRead-I 的文件可以通过输入文件并将其可视化处理。

而 TrainChange-I 可以将输入文件处理成纯数字输入，每一个 TrainCode 文件的使用都需要先运行它。

**Case 1-2:**

我们不难发现，数据非常的小，体现在选择跳转操作次数极小，可以打 $O(2^n)$ 的暴力 AC。

**Case 3:**

这个点其实有着和 C1，C2 同样的性质，即它可以分成一段一段的，每一个段都会让你做几个选择改变一些变量，而最后答案加上变量的绝对值后所有变量清零。发现每一个段内的选择跳转次数同样很小，那么我们只需要针对每一个段爆搜寻找最大值并输出即可。

**Case 4:**

$m=2$，意味着仅有一个变量需要讨论，我们发现，该变量在整个数据中增加的次数仅有一，再看就发现这实际上就是一个输出序列的背包，数据中可以分成均匀的段模拟一个物品，不难实现。

**Case 5-6:**

我们只是片面的看 C4，但是 C5，C6 却又多出了两个问题，第一个是跳转不再均匀，如果不满足条件可能会跳到任意地方，这个可以通过更改背包实现方法做到，但此时又出现了一些无意义的条件跳转，它使得数据不均匀，可以通过把分段背包改成对每一个操作进行的背包解决，不过这真的很慢。

# Case 7-10：

上次讲到数据中会出现无意义跳转，而放在本文段的数据上直接处理很麻烦，所以我又打了个代码把那些无意义跳转处理掉。

TrainChange-II 就是在 TrainChange-I 的基础上去掉无意义跳转，而TrainRead-II 就是将此时的数据可视化处理。

其实这四个数据大体相同，那么我就合在一起讲。这四个点都有着 C6 的特征，但其中其它的变量明显增加，而它们的具体结构和 C3 很相似，那么只需要将两代码结合即可，但是要注意一点，它的数据在这次富有变化，所以不能直接照搬前面数据的性质敲代码。

**结尾**

------------

很好的找规律的码力题，下次不许再出了。

---

## 作者：tzc_wk (赞：57)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P1335)

一道相对来说难度较低的提答题。

首先碰到提答题我们肯定不能思考一般性解法，只能就事论事，对着对应的数据设计出相应的程序。纵观 10 组数据，我们可以获得一些的结论：

- 对于所有跳转事件，那些目标位置 $<$ 当前位置的事件，都形如 `i c 0 c 1 x 0`，也就是如果 $0<1$ 跳转到 $x$，否则跳转到 $0$​，显然这种事件只能选择前者，也就是说本题的结构实际上是一个有限状态自动机，不会成环。
- 在第 $2,3,7,8,9,10$ 中都出现了一个类似的结构，也就是一段 `v 3 x1, v 4 x2, ..., v 12 x10` 后跟一堆将变量 $v_3,v_4,\cdots,v_{12}$ 累加到 $v_1$ 上的操作，不难发现这可以视作，有若干个大礼包，每个大礼包可以选择或者不选择，如果选择则需要将 $v_3,v_4,\cdots,v_{12}$ 都加上一个固定的值，隔一段时间以后令答案加上 $\sum\limits_{i=3}^{12}|v_i|$，我们称之为 A 结构。
- 在第 $4,5,6,7,8,9,10$​ 中也出现了一个类似的结构，也就是所有与 $v_2$​ 有关的操作，稍加分析可以发现这是一个背包模型，变量 $2$​ 的值就是剩余体积，即，有若干个大礼包，每个大礼包有两个三个属性 $to_i,v_i,w_i$​，每进入一个礼包，如果剩余体积 $<v_i$​ 则直接转到 $to_i$，否则你可以选择到 $i+1$，并花费 $w_i$ 的体积或者 $v_i$ 的价值，也可以选择到 $to_i$。我们称之为 B 结构。

做出这些小观察后本题就容易许多了。

对于第一组数据，选择操作很少，直接爆搜即可。这里直接给出答案。

```
1
1
1
1
```

对于第二组数据，是一个有 25 个大礼包的 A 结构，同样直接 $2^{25}$ 暴力即可。

```cpp
const int MAXN = 3.5e5;
int n, m, pos[MAXN + 5][15];
int val[15];
struct number {
	int opt, id;
	void read() {
		static char str[5]; scanf("%s%d", str + 1, &id);
		opt = (str[1] == 'v');
	}
	int operator () () {return (opt) ? val[id] : id;}
};
struct qry {int opt, A, B; number C, D;} a[MAXN + 5];
int main() {
	freopen("train3.in", "r", stdin);
	freopen("train3.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		static char str[5]; scanf("%s", str + 1);
		if (str[1] == 'v') {
			static char op[5]; scanf("%d%s", &a[i].A, op + 1);
			a[i].B = (op[1] == '-'); // 0 for + and 1 for -
			a[i].C.read(); a[i].opt = 1;
		} else if (str[1] == 's') {
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 2;
		} else {
			a[i].C.read(); a[i].D.read();
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 3;
		}
	}
	vector<vector<int> > vec;
	for (int i = 1; i <= n; ) {
		if (a[i].opt == 2) {
			vector<int> tmp;
			for (int j = a[i].A; j < a[i].B; j++) tmp.pb(a[j].C());
			vec.pb(tmp); i = a[i].B;
		} else {
			ll mx = -1; int msk = -1;
			for (int j = 0; j < (1 << vec.size()); j++) {
				static ll ss[15]; fill0(ss);
				for (int k = 0; k < vec.size(); k++) if (j >> k & 1) {
					for (int l = 0; l < vec[k].size(); l++)
						ss[l] += vec[k][l];
				}
				ll sum = 0;
				for (int k = 0; k < 10; k++) sum += abs(ss[k]);
				if (sum > mx) mx = sum, msk = j;
			}
//			printf("! %lld %d %d\n", mx, msk, (int)vec.size());
			for (int j = 0; j < vec.size(); j++) {
				if (msk >> j & 1) puts("1");
				else puts("2");
			}
			vec.clear();
			i += 50;
		}
	}
	return 0;
}
```

对于第三组数据，相当于几百个 A 类结构，每个 A 类结构里有大概 $10$ 个大礼包，对每个 A 类结构暴力求解加起来即可。

```cpp
const int MAXN = 3.5e5;
int n, m, val[15];
struct number {
	int opt, id;
	void read() {
		static char str[5]; scanf("%s%d", str + 1, &id);
		opt = (str[1] == 'v');
	}
	int operator () () {return (opt) ? val[id] : id;}
};
struct qry {int opt, A, B; number C, D;} a[MAXN + 5];
int id[MAXN + 5], idcnt = 0, bel[MAXN + 5], nxt[MAXN + 5];
ll dp[2005][10005]; int to[2005][10005], cst[MAXN + 5], v[MAXN + 5];
vector<int> vec;
void work(int cur, int lft) {
	if (cur > idcnt) return;
	if (to[cur][lft]) vec.pb(1), work(cur + 1, lft - cst[cur + 1]);
	else {
		if (lft >= cst[cur + 1]) vec.pb(2);
		work(nxt[cur], lft);
	}
}
int main() {
	freopen("train6.in", "r", stdin);
	freopen("train6.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		static char str[5]; scanf("%s", str + 1);
		if (str[1] == 'v') {
			static char op[5]; scanf("%d%s", &a[i].A, op + 1);
			a[i].B = (op[1] == '-'); // 0 for + and 1 for -
			a[i].C.read(); a[i].opt = 1;
		} else if (str[1] == 's') {
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 2;
		} else {
			a[i].C.read(); a[i].D.read();
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 3;
		}
	}
	for (int i = 1; i <= n; i++) if (a[i].opt == 2) id[i] = ++idcnt;
	bel[n + 1] = idcnt + 1;
//	cerr << idcnt << endl;
	for (int i = n; i; i--) bel[i] = ((a[i].opt == 2) ? id[i] : bel[i + 1]);
	for (int i = 1; i <= n; i++) if (a[i].opt == 2) nxt[id[i]] = bel[a[i].B];
	for (int i = 4; i <= n; i++) if (a[i].opt == 1) {
		if (a[i].A == 2) cst[bel[i]] = a[i].C();
		else v[bel[i]] = a[i].C();
	}
	for (int i = idcnt; i; i--) for (int j = 0; j <= 10000; j++) {
		if (j < cst[i + 1]) dp[i][j] = dp[nxt[i]][j];
		else {
			if (dp[nxt[i]][j] < dp[i + 1][j - cst[i + 1]] + v[i + 1]) {
				dp[i][j] = dp[i + 1][j - cst[i + 1]] + v[i + 1];
				to[i][j] = 1;
			} else dp[i][j] = dp[nxt[i]][j];
		}
	}
	ll mx = 0; int mxp = -1;
	for (int i = 0; i <= 10000; i++) if (mx < dp[1][i]) mx = dp[1][i], mxp = i;
	work(1, mxp); cerr << mx << endl;
	for (int x : vec) printf("%d\n", x);
	return 0;
}
```

对于第四、五、六组数据，相当于一个 B 类结构，从后往左背包即可。

```cpp
const int MAXN = 3.5e5;
int n, m, val[15];
struct number {
	int opt, id;
	void read() {
		static char str[5]; scanf("%s%d", str + 1, &id);
		opt = (str[1] == 'v');
	}
	int operator () () {return (opt) ? val[id] : id;}
};
struct qry {int opt, A, B; number C, D;} a[MAXN + 5];
int id[MAXN + 5], idcnt = 0, bel[MAXN + 5], nxt[MAXN + 5];
ll dp[2005][10005]; int to[2005][10005], cst[MAXN + 5], v[MAXN + 5];
vector<int> vec;
void work(int cur, int lft) {
	if (cur > idcnt) return;
	if (to[cur][lft]) vec.pb(1), work(cur + 1, lft - cst[cur + 1]);
	else {
		if (lft >= cst[cur + 1]) vec.pb(2);
		work(nxt[cur], lft);
	}
}
int main() {
	freopen("train6.in", "r", stdin);
	freopen("train6.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		static char str[5]; scanf("%s", str + 1);
		if (str[1] == 'v') {
			static char op[5]; scanf("%d%s", &a[i].A, op + 1);
			a[i].B = (op[1] == '-'); // 0 for + and 1 for -
			a[i].C.read(); a[i].opt = 1;
		} else if (str[1] == 's') {
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 2;
		} else {
			a[i].C.read(); a[i].D.read();
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 3;
		}
	}
	for (int i = 1; i <= n; i++) if (a[i].opt == 2) id[i] = ++idcnt;
	bel[n + 1] = idcnt + 1;
//	cerr << idcnt << endl;
	for (int i = n; i; i--) bel[i] = ((a[i].opt == 2) ? id[i] : bel[i + 1]);
	for (int i = 1; i <= n; i++) if (a[i].opt == 2) nxt[id[i]] = bel[a[i].B];
	for (int i = 4; i <= n; i++) if (a[i].opt == 1) {
		if (a[i].A == 2) cst[bel[i]] = a[i].C();
		else v[bel[i]] = a[i].C();
	}
	for (int i = idcnt; i; i--) for (int j = 0; j <= 10000; j++) {
		if (j < cst[i + 1]) dp[i][j] = dp[nxt[i]][j];
		else {
			if (dp[nxt[i]][j] < dp[i + 1][j - cst[i + 1]] + v[i + 1]) {
				dp[i][j] = dp[i + 1][j - cst[i + 1]] + v[i + 1];
				to[i][j] = 1;
			} else dp[i][j] = dp[nxt[i]][j];
		}
	}
	ll mx = 0; int mxp = -1;
	for (int i = 0; i <= 10000; i++) if (mx < dp[1][i]) mx = dp[1][i], mxp = i;
	work(1, mxp); cerr << mx << endl;
	for (int x : vec) printf("%d\n", x);
	return 0;
}
```

对于第七、八、九、十组数据，相当于一个 B 类结构，但 B 类结构每个礼包内部又是一个 A 类结构，同样道理，先对每个 A 类结构跑一遍第三组数据的求解方法找出其代价，然后再跑四、五、六即可。

```cpp
const int MAXN = 3.6e5;
int n, m, val[15];
struct number {
	int opt, id;
	void read() {
		static char str[5]; scanf("%s%d", str + 1, &id);
		opt = (str[1] == 'v');
	}
	int operator () () {return (opt) ? val[id] : id;}
};
struct qry {int opt, A, B; number C, D;} a[MAXN + 5];
int id[MAXN + 5], idcnt = 0, bel[MAXN + 5], nxt[MAXN + 5];
ll dp[2005][10005]; int to[2005][10005];
ll cst[MAXN + 5], v[MAXN + 5];
vector<int> vec;
bool flg[MAXN + 5];
vector<vector<int> > tt[MAXN + 5];
int mskv[MAXN + 5];
void deal(int id) {
	for (int i = 0; i < tt[id].size(); i++)
		vec.pb((mskv[id] >> i & 1) ? 1 : 2);
}
void work(int cur, int lft) {
	if (cur > idcnt) return;
	if (to[cur][lft]) vec.pb(1), deal(cur + 1), work(cur + 1, lft - cst[cur + 1]);
	else {
		if (lft >= cst[cur + 1]) vec.pb(2);
		work(nxt[cur], lft);
	}
}
int main() {
	freopen("train10.in", "r", stdin);
	freopen("train10.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		static char str[5]; scanf("%s", str + 1);
		if (str[1] == 'v') {
			static char op[5]; scanf("%d%s", &a[i].A, op + 1);
			a[i].B = (op[1] == '-'); // 0 for + and 1 for -
			a[i].C.read(); a[i].opt = 1;
		} else if (str[1] == 's') {
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 2;
		} else {
			a[i].C.read(); a[i].D.read();
			scanf("%d%d", &a[i].A, &a[i].B);
			a[i].opt = 3;
		}
	}
	for (int i = 1; i <= n; i++) if (a[i].opt == 2) {
		flg[i] = 1;
		for (int j = 1; j <= 10; j++) flg[i] &= (a[i + j].opt == 1);
	} 
	for (int i = 1; i <= n; i++) if (a[i].opt == 2 && !flg[i]) id[i] = ++idcnt;
	bel[n + 1] = idcnt + 1;
//	for (int i = 1; i <= n; i++) cerr << id[i] << endl;
//	cerr << idcnt << endl;
	for (int i = n; i; i--) bel[i] = ((a[i].opt == 2 && !flg[i]) ? id[i] : bel[i + 1]);
	for (int i = 1; i <= n; i++) if (a[i].opt == 2 && !flg[i]) nxt[id[i]] = bel[a[i].B];
	for (int i = 1; i <= n; i++) if (a[i].opt == 2 && flg[i]) {
		vector<int> tmp;
		for (int j = 1; j <= 10; j++) tmp.pb(a[i + j].C());
		tt[bel[i]].pb(tmp);
	}
	for (int i = 4; i <= n; i++) if (a[i].opt == 1 && a[i].A == 2)
		cst[bel[i]] = a[i].C();
	for (int i = 1; i <= idcnt + 1; i++) {
		ll mx = -1; int msk = -1;
		for (int j = 0; j < (1 << tt[i].size()); j++) {
			static ll vals[15]; fill0(vals);
			for (int k = 0; k < tt[i].size(); k++) if (j >> k & 1)
				for (int l = 0; l < 10; l++) vals[l] += tt[i][k][l];
			ll ss = 0;
			for (int l = 0; l < 10; l++) ss += abs(vals[l]);
			if (ss > mx) mx = ss, msk = j;
		}
		v[i] = mx; mskv[i] = msk;
	}
	for (int i = 1; i <= idcnt; i++) cerr << v[i] << endl;
	for (int i = idcnt; i; i--) for (int j = 0; j <= 1000; j++) {
		if (j < cst[i + 1]) dp[i][j] = dp[nxt[i]][j];
		else {
			if (dp[nxt[i]][j] < dp[i + 1][j - cst[i + 1]] + v[i + 1]) {
				dp[i][j] = dp[i + 1][j - cst[i + 1]] + v[i + 1];
				to[i][j] = 1;
			} else dp[i][j] = dp[nxt[i]][j];
		}
	}
	ll mx = 0; int mxp = -1;
	for (int i = 0; i <= 1000; i++) if (mx < dp[1][i]) mx = dp[1][i], mxp = i;
	work(1, mxp); cerr << mx << endl;
	for (int x : vec) printf("%d\n", x);
	return 0;
}
```



---

## 作者：littleKtian (赞：35)

### Test 1

没有退回去的循环，`选择跳转数`也很少，直接暴力做就行。

### Test 2&3

第 2 个点的`选择跳转`数也不多，同样可以暴力，但第 3 个点就不一样了，所以我们考虑能不能优化。

观察第 3 个点的结构，发现整个事件序列可以划分成若干段，每段又可以分成积累贡献（修改变量 3~12 的值）和统计贡献（根据变量 3~12 各自的值修改变量 1，同时清空变量 3~12）两部分。

显然各段之间的贡献互不影响，同时每段各自的`选择跳转`数又比较小，所以拆开来分别暴力处理即可。

（这里还有个比较口胡的做法：观察统计过程的部分，实际上就是对所有的变量 3~12，给变量 1 加上其的绝对值。所以我们可以枚举这些变量在统计贡献部分时的正负情况，这样对于积累贡献部分的所有事件，其对于最后变量 1 的贡献就是确定的，直接贪心即可。这样不需要考虑`选择跳转`数的大小）

### Test 4

观察数据，发现整个事件序列很整齐，可以每 6 个分为一组（除去第 1 个事件）。

观察每组事件，发现一组事件相当于一个有大小和价值的物品。也就是说这个点相当于一个 01 背包问题。而第 1 步相当于设置背包的容量。

直接背包问题求方案即可。注意输出时如果当前背包容量塞不下这个物品，那么需要跳过不输出这个物品的选择。

### Test 5&6

一上来看第 5 个点容易看错，以为和第 4 个一样也是个普通的背包，然后你会发现提交的返回结果连格式都不对。

认真观察一遍，容易发现第一组事件的跳转位置是最末尾，而且原来第一组事件的最后一个事件语句不见了。而如果翻到数据点最下面，可以发现这最后一个事件出现在最后。

分析一下此时跳转位置的意义，可以发现如果这个物品没有被选上，可能会导致其他一连串的物品也无法被选取。不妨猜测这时的问题从 01 背包变成树形背包。

把一组事件的前 5 个事件看成一个左括号，最后 1 个看成右括号，根据嵌套关系建立出树，做树形背包即可。第 6 个点同理。

因为是提答，所以并不需要很优秀的复杂度，可以直接写 $O(nm^2)$（$n$ 为物品数，$m$ 为背包大小）的做法。实测这种做法在我的电脑上跑第 6 个点只用 3min。

### Test 7&8

容易发现其实就是第 2 个点和第 4 个点的缝合，先用 2 的方法计算物品的价值再进行背包。

把两份代码合并一下即可。

（闲话：其实第 1 个点也可以看成这种结构）

### Test 9&10

~~我甚至完全可以猜到这个点想让我干什么。~~

显然就是把背包换成树形的，所以直接合并第 2 个点和第 5&6 个点的代码即可。

[全部代码。](https://www.luogu.com.cn/paste/6ucjs3a0)

---

## 作者：SqrT_Pow (赞：0)

讲真？只有 3 篇题解？

[我的盐酸博客](https://blog.csdn.net/2401_82353457/article/details/150072877?spm=1001.2014.3001.5501)

# 题意
一共有 $M$ 个变量。

有一系列的操作，按顺序标为 $1\sim N$。操作分为三种：

①普通操作：将一个变量加上一个量。

②条件跳转：给出两个量 $A$、$B$ 和两个编号 $P$、$Q$。

如果 $A<B$ 那么跳到编号为 $P$ 的操作，否则跳到编号为 $Q$ 的操作。

③选择跳转：给出两个编号 $P$、$Q$。在 $P$ 和 $Q$ 中任选一个跳过去。

注意以上的“量”可以是常量，也可以是目前某一个变量的值。

如果什么时候跳转到的编号不在 $1\sim N$ 之间，则视为退出游戏。

你要给出选择跳转的决策，使退出游戏的时候第一个变量的值尽量的大。

# Case 1~2
C1 的决策只有 $20$ 个，直接 DFS 一下。

（顺便要写一个比较 DJ 的读入和模拟器）

发现 C2 跑了几秒也跑出来了 QAQ。

```cpp
#include<bits/stdc++.h>
#define N 1005
#define x first
#define y second
#define mk make_pair
using namespace std;
typedef pair<bool,int> Pair;
int P[N],Q[N],sign[N],ch[N],ret[N];
Pair A[N],B[N];char str[N][3];
int n,m,ans;
Pair read(){
  char tmp[10];int d;
  scanf("%s%d",tmp,&d);
  if (tmp[0]!='c') fprintf(stderr,"%s %d\n",tmp,d);
  if (tmp[0]=='c') return mk(0,d);
  return mk(1,d);
}
int Read(){
  char tmp[10];
  scanf("%s",tmp);
  return tmp[0]=='+'?1:-1;
}
void DFS(int k,vector<int>now){
  //fprintf(stderr,"%d\n",k);
  for (;k<=n&&str[k][0]!='s';){
    if (str[k][0]=='v') now[A[k].y]+=(B[k].x?now[B[k].y]:B[k].y)*sign[k],k++;
    if (str[k][0]=='i'){
      int t1=A[k].x?now[A[k].y]:A[k].y;
      int t2=B[k].x?now[B[k].y]:B[k].y;
      if (t1<t2) k=P[k];else k=Q[k];
    }
  }
  if (k>n){
    if (now[1]>ans){
      freopen("train2.out","w",stdout);
      fprintf(stderr,"%d\n",ans);
      for (int i=1;i<=*ch;i++)
        printf("%d ",ch[i]);
      ans=now[1];
    }
  }else{
    ch[++*ch]=1;DFS(P[k],now);--*ch;
    ch[++*ch]=2;DFS(Q[k],now);--*ch;
  }
}
int main(){
  freopen("train2.in","r",stdin);
  freopen("train2.out","w",stdout);
  scanf("%d%d",&n,&m);
  for (int i=1;i<=n;i++){
    
    scanf("%s",str[i]);int t;
    if (str[i][0]=='v') scanf("%d",&t),A[i]=mk(1,t),sign[i]=Read(),B[i]=read();
    if (str[i][0]=='i') A[i]=read(),B[i]=read(),scanf("%d%d",&P[i],&Q[i]);
    if (str[i][0]=='s') scanf("%d%d",&P[i],&Q[i]);
    fprintf(stderr,"%d %s\n",i,str[i]);
  }
  fprintf(stderr,"%s\n",str[n]);
  vector<int>now;
  for (int i=0;i<=m+2;i++) 
    now.push_back(i);
  DFS(1,now);
  
}
```
# case 3
观察数据，发现可以分成一些互不干扰的块。

每一个块里有 $10$ 个决策，每个决策会增加或减少编号为 $3\sim 12$ 的变量。

然后块的结尾会依据这 $3\sim 12$ 的变量给最终要求的1变量增加或减少值。

为什么称为“互不干扰”呢？因为每一块结尾都会把 $3\sim 12$ 的变量都清空。

然后只要对每一个块分别爆搜，把答案合并起来即可。

```cpp
//#include<bits/stdc++.h>
#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<vector>
#include "Windows.h"
#define N 350005
#define x first
#define y second
#define mk make_pair
using namespace std;
typedef pair<bool,int> Pair;
int P[N],Q[N],sign[N],ch[66],ret[66],now[66];
Pair A[N],B[N];char str[N][3];
int n,m,ans,best,st;
Pair read(){
  char tmp[10];int d;
  scanf("%s%d",tmp,&d);
  if (tmp[0]=='c') return mk(0,d);
  return mk(1,d);
}
int Read(){
  char tmp[10];scanf("%s",tmp);
  return tmp[0]=='+'?1:-1;
}
void DFS(int x){
  //fprintf(stderr,"%d ",x);
  if (x>10){
    int get=0,b=10*12+st;
    for (int i=b;i<b+170;i++){
      //fprintf(stderr,"%d\n",i);
      if (str[i][0]=='i'){
        int t1=A[i].x?now[A[i].y]:A[i].y;
        int t2=B[i].x?now[B[i].y]:B[i].y;
        if (t1<t2) i=P[i]-1;else i=Q[i]-1;
      }else if (A[i].y==1)
        get+=sign[i]*(B[i].x?now[B[i].y]:B[i].y);
    }
    if (get>best) 
      best=get,memcpy(ret,ch,sizeof(ch));
    return;
  }
  ch[x]=2;DFS(x+1);
  int b=st+(x-1)*12;
  for (int i=1;i<=10;i++)
    now[i+2]+=B[b+i].y;
  ch[x]=1;DFS(x+1);
  for (int i=1;i<=10;i++)
    now[i+2]-=B[b+i].y;
}
int main(){
  freopen("train3.in","r",stdin);
  freopen("train3.out","w",stdout);
  scanf("%d%d",&n,&m);
  for (int i=1;i<=n;i++){
    scanf("%s",str[i]);int t;
    if (str[i][0]=='v') scanf("%d",&t),A[i]=mk(1,t),sign[i]=Read(),B[i]=read();
    if (str[i][0]=='i') A[i]=read(),B[i]=read(),scanf("%d%d",&P[i],&Q[i]);
    if (str[i][0]=='s') scanf("%d%d",&P[i],&Q[i]);
  }fprintf(stderr,"Start\n");
  for (st=1;st<=n;st+=170){
    best=0;
    for (int i=3;i<=12;i++) now[i]=0;
    DFS(1);
    ans+=best;fprintf(stderr,"%d %d\n",st,best);
    for (int k=1;k<=10;k++)
      printf("%d ",ret[k]);
  }fprintf(stderr,"%d\n",ans);
  return 0;
}
```
# case 4~6
发现只有两个变量。

2 变量的增减都比较小，而且所有的条件跳转都只和 2 变量有关。

这就可以想到按顺序 DP 下去，每次记录当前 2 变量的值是多少即可。

最后再回去输出方案。说起来比较轻松，实际还是有很多细节的。

为了方便，DP 的意义可以从“做完第 $i$ 个操作，2 变量的值为 $k$”改成“做第 $i$ 个操作之前，2 变量的值为 $k$”这样。

写完之后大概改一下也可以过第 5 个点。

```cpp
//#include<bits/stdc++.h>
#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<vector>
#define N 10005
#define x first
#define y second
#define mk make_pair
using namespace std;
typedef pair<bool,int> Pair;
int P[N],Q[N],sign[N];
Pair A[N],B[N];char str[N][3];
struct data{
  int v,prei,prek,ch;
  void Min(int _v,int _ch,int _prei,int _prek){
    if (_v<=v) return;
    v=_v;ch=_ch;prei=_prei;prek=_prek;
  }
  int operator < (const data &b)const{return v<b.v;}
}F[6005][N],ans;int n,m;
Pair read(){
  char tmp[10];int d;
  scanf("%s%d",tmp,&d);
  if (tmp[0]=='c') return mk(0,d);
  return mk(1,d);
}
int Read(){
  char tmp[10];
  scanf("%s",tmp);
  return tmp[0]=='+'?1:-1;
}
int Case=0;
void DFS(int i,int k){
  //fprintf(stderr,"%d %d\n",i,k);
  //if ((++Case)==20) return;
  if (i<=2) return;
  DFS(F[i][k].prei,F[i][k].prek);
  if (F[i][k].ch>-1) printf("%d ",F[i][k].ch);
}
int main(){
  freopen("train5.in","r",stdin);
  freopen("train5.out","w",stdout);
  scanf("%d%d",&n,&m);
  for (int i=1;i<=n;i++){
    scanf("%s",str[i]);int t;
    if (str[i][0]=='v') scanf("%d",&t),A[i]=mk(1,t),sign[i]=Read(),B[i]=read();
    if (str[i][0]=='i') A[i]=read(),B[i]=read(),scanf("%d%d",&P[i],&Q[i]);
    if (str[i][0]=='s') scanf("%d%d",&P[i],&Q[i]);
  }
  //F[i][k] 做第i行之前，v2的值为k的最大的v1的值
  //for (int i=0;i<=n+1;i++) F[i]=f[i]+N/2;int bug=0;
  for (int i=0;i<=n+1;i++) for (int k=0;k<N;k++) F[i][k].v=-1e9;
  F[2][5000].v=0;ans.v=-1e9;
  for (int i=2;i<=n;i++)
    for (int k=0;k<N;k++) 
      if (F[i][k].v>-1e9){
        //printf("%d %d %d\n",i,k,F[i][k].v);
        if (str[i][0]=='v'){
          int newk=k,newv=F[i][k].v;
          if (A[i].x&&A[i].y==2)
            newk+=sign[i]*B[i].y;
          else if (A[i].x&&A[i].y==1)
            newv+=sign[i]*B[i].y;
          //if (i==6)
            //fprintf(stderr,"%d %d\n",newv,newk);
          F[i+1][newk].Min(newv,-1,i,k);
        }else if (str[i][0]=='i'){
          //if (bug) fprintf(stderr,"%d %d\n%d %d\n",A[i].x,A[i].y,B[i].x,B[i].y);
          int t1=A[i].x?k:A[i].y;
          int t2=B[i].x?k:B[i].y,newi;
          //if (bug) fprintf(stderr,"%d %d\n",t1,t2);
          if (t1<t2) newi=P[i];else newi=Q[i];
          //if (bug) fprintf(stderr,"Newi:%d\n",newi);
          if (i==8)
            fprintf(stderr,"%d %d %d %d\n",t1,t2,newi,F[i][k].v);
          if (newi>=1&&newi<=n)
            F[newi][k].Min(F[i][k].v,-1,i,k);
          else ans=max(ans,(data){F[i][k].v,i,k});
        }else {
          if (P[i]>=1&&P[i]<=n)
            F[P[i]][k].Min(F[i][k].v,1,i,k);
          else ans=max(ans,(data){F[i][k].v,i,k});
          if (Q[i]>=1&&Q[i]<=n)
            F[Q[i]][k].Min(F[i][k].v,2,i,k);
          else ans=max(ans,(data){F[i][k].v,i,k});
        }
      }
  fprintf(stderr,"Type1Ans:%d %d\n",ans.v,n);
  for (int k=0;k<N;k++)
    ans=max(ans,(data){F[n+1][k].v,n+1,k});
  fprintf(stderr,"Type2Ans:%d\n",ans.v);
  DFS(ans.prei,ans.prek);
}
```
# case 7~8
首先和之前的一个点差不多，发现这些操作可以分成几组，每组格式类似。

发现每组的开头有些和 2 变量有关的判断：若 2 的值怎么怎么样强制你跳到后面一块。

否则的话，你也有对这一块的决策权：即你仍然有机会能跳出这一块。

如果你跳进这一块的话，可以像之前爆搜的那样搜出一些变量的取值。

在最外面再套一个 DP，记录变量 2 的状态、决策是否进去某一块啥的。

找方案的时候可能更加麻烦。

```cpp
//#include<bits/stdc++.h>
#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<vector>
#include "Windows.h"
#define N 35005
#define M 1005
#define x first
#define y second
#define mk make_pair
using namespace std;
typedef pair<bool,int> Pair;
int ret[205][21],best[205];
int P[N],Q[N],sign[N],ch[21],now[66];
Pair A[N],B[N];char str[N][3];
int F[N][M],pre[N][M],walk[N][M],extra[N][M];
int n,m,ans,st,i,k,newk,tmp,tot;
Pair read(){
  char tmp[10];int d;
  scanf("%s%d",tmp,&d);
  if (tmp[0]=='c') return mk(0,d);
  return mk(1,d);
}
int Read(){
  char tmp[10];scanf("%s",tmp);
  return tmp[0]=='+'?1:-1;
}
void DFS(int x){
  //fprintf(stderr,"%d ",x);
  if (x>10){
    int get=0,b=st+12*10;
    for (int i=b;i<st+175;i++){
      //fprintf(stderr,"%d\n",i);
      if (str[i][0]=='i'){
        int t1=A[i].x?now[A[i].y]:A[i].y;
        int t2=B[i].x?now[B[i].y]:B[i].y;
        if (t1<t2) i=P[i]-1;else i=Q[i]-1;
      }else if (A[i].y==1)
        get+=sign[i]*(B[i].x?now[B[i].y]:B[i].y);
    }
    if (get>best[tot]) 
      best[tot]=get,memcpy(ret[tot],ch,sizeof(ch));
    return;
  }
  ch[x]=2;DFS(x+1);
  int b=st+(x-1)*12;
  for (int i=1;i<=10;i++)
    now[i+2]+=B[b+i].y;
  ch[x]=1;DFS(x+1);
  for (int i=1;i<=10;i++)
    now[i+2]-=B[b+i].y;
}
void BACK(int i,int k){
  if (i<=1) return;
  fprintf(stderr,"%d %d %d %d %d\n",i,k,F[i][k],walk[i][k],extra[i][k]);
  BACK(i-1,pre[i][k]);
  if (walk[i][k]!=-1) 
    printf("%d ",walk[i][k]),assert(walk[i][k]>0);
  if (extra[i][k])
    for (int c=1;c<=10;c++)
      printf("%d ",ret[extra[i][k]][c]);
}
int main(){
  freopen("train8.in","r",stdin);
  freopen("train8.out","w",stdout);
  scanf("%d%d",&n,&m);
  for (i=1;i<=n;i++){
    scanf("%s",str[i]);int t;
    if (str[i][0]=='v') scanf("%d",&t),A[i]=mk(1,t),sign[i]=Read(),B[i]=read();
    if (str[i][0]=='i') A[i]=read(),B[i]=read(),scanf("%d%d",&P[i],&Q[i]);
    if (str[i][0]=='s') scanf("%d%d",&P[i],&Q[i]);
  }fprintf(stderr,"Start\n");
  for (st=6;st<=n;st+=175){
    best[++tot]=0;
    assert(str[st][0]=='s');
    for (i=3;i<=12;i++) now[i]=0;
    DFS(1);
    fprintf(stderr,"%d %d\n",st,best[tot]);
    for (k=1;k<=10;k++)
      assert(ret[tot][k]>0);
  }
  for (i=0;i<=tot+1;i++)
    for (k=0;k<M;k++) F[i][k]=-1e9;
  F[1][1000]=0;assert(tot==200);
  for (i=1;i<=tot;i++)
    for (k=0;k<M;k++)
      if (F[i][k]>-1e9){
        //fprintf(stderr,"%d %d %d\n",i,k,F[i][k]);
        st=1+(i-1)*175+1;
        assert(str[st][0]=='i'&&A[st].y==2);
        if (k<B[st].y){
          if (F[i][k]>F[i+1][k])
            F[i+1][k]=F[i][k],pre[i+1][k]=k,walk[i+1][k]=-1,extra[i+1][k]=0;
          continue;
        }st+=2;assert(str[st][0]=='s');
        if (F[i][k]>F[i+1][k])
          F[i+1][k]=F[i][k],pre[i+1][k]=k,walk[i+1][k]=2,extra[i+1][k]=0;
        ++st;assert(A[st].y==2&&B[st].x==0);
        //fprintf(stderr,"%d %d\n",sign[st],B[st].y);
        newk=k+sign[st]*B[st].y;
        if (newk>k) 
          fprintf(stderr,"%d %d\n",i,k);
        assert(newk<=k);
        //fprintf(stderr,"%d\n",F[i][k]+best[i]);
        if (F[i][k]+best[i]>F[i+1][newk])
          F[i+1][newk]=F[i][k]+best[i],pre[i+1][newk]=k,walk[i+1][newk]=1,extra[i+1][newk]=i;
      }
  fprintf(stderr,"%d %d\n",F[tot][500],F[tot+1][500]);
  for (k=0;k<M;k++)
    if (F[tot+1][k]>ans)
      ans=F[tot+1][k],tmp=k;
  fprintf(stderr,"%d\n",ans);
  BACK(tot+1,tmp);
  return 0;
}
```
# case 9~10
这两个点感觉和之前的特别像。

但是我用之前的程序跑怎么也跑不过。后来发现了一些坑。

首先，循环节的长度稍微变化了一下。

然后假设循环节的长度为 $L$，我发现操作数竟然不是 $L$ 的倍数！

这是怎么回事呢？大概看一下，发现几千行的一个地方不是按照原来的规律在变化。

可以称这些地方为"噪点”。

如果再找出一行“噪点”，就可以大概归纳出其性质，然后把它们删掉即可。

对于删掉后的数据我还是搞了很长时间：显然我把每一条操作重新编号了。

因为在跳转的时候，编号还是会按照原先数据的编号，所以要搞一个比较麻烦的映射。

此外我记得还有很多细节，比如在块之间跳跃的时候，好像还可以往后跳好几块啥的，总之特别坑。
```cpp
#include<bits/stdc++.h>
#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<vector>
#include "Windows.h"
#define N 35005
#define M 1005
#define x first
#define y second
#define mk make_pair
using namespace std;
typedef pair<bool,int> Pair;
int ret[205][21],best[205],S[1005];
int P[N],Q[N],index[N],pos[N],sign[N],ch[21],now[66];
Pair A[N],B[N];char str[N][3];
int F[N][M],prei[N][M],prek[N][M],walk[N][M],extra[N][M];
int n,m,ans,st,i,k,newk,newi,tmpi,tmpk,tot,j;
Pair read(){
  char tmp[10];int d;
  scanf("%s%d",tmp,&d);
  if (tmp[0]=='c') return mk(0,d);
  return mk(1,d);
}
int Read(){
  char tmp[10];scanf("%s",tmp);
  return tmp[0]=='+'?1:-1;
}
int bug=0;
void DFS(int x){
  if (x>10){
    if (bug) 
			assert(str[st+12*10][0]=='i'&&A[st+12*10].y==3);
    int get=0,b=st+12*10;
    for (int i=b;i<st+174;i++){
      //fprintf(stderr,"%d\n",i);
      if (str[i][0]=='i'){
        int t1=A[i].x?now[A[i].y]:A[i].y;
        int t2=B[i].x?now[B[i].y]:B[i].y;
        if (t1<t2) i=P[i]-1;else i=Q[i]-1;
      }else if (A[i].y==1)
        get+=sign[i]*(B[i].x?now[B[i].y]:B[i].y);
    }//if (bug) fprintf(stderr,"%d\n",get);
    if (get>best[tot]) 
      best[tot]=get,memcpy(ret[tot],ch,sizeof(ch));
    return;
  }
  ch[x]=2;DFS(x+1);
  int b=st+(x-1)*12;
  for (int i=1;i<=10;i++)
    now[i+2]+=B[b+i].y;
  ch[x]=1;DFS(x+1);
  for (int i=1;i<=10;i++)
    now[i+2]-=B[b+i].y;
}
void BACK(int i,int k){
  if (i<=1) return;
  //fprintf(stderr,"%d %d %d %d %d\n",i,k,F[i][k],walk[i][k],extra[i][k]);
  BACK(prei[i][k],prek[i][k]);
  //fprintf(stderr,"%d\n",i);
  if (walk[i][k]!=-1) 
    printf("%d ",walk[i][k]),assert(walk[i][k]>0);
  if (extra[i][k])
    for (int c=1;c<=10;c++)
      printf("%d ",ret[extra[i][k]][c]);
}
int calc(int x){
	for (int i=1;i<=*S;i++)
		if (S[i]==x){
			int j=i;
			for (;j<*S&&S[j+1]==S[j]+1;++j);
			x=S[j]+1;break;
	  }
	x-=lower_bound(S+1,S+*S+1,x)-(S+1);
	return x;
}
int main(){
  freopen("train10.in","r",stdin);
  scanf("%d%d",&n,&m);n-=8;int last=0;
  for (i=1,j=1;i<=n;i++,j++){
    scanf("%s",str[i]);int t;index[i]=j;
    if (str[i][0]=='v') scanf("%d",&t),A[i]=mk(1,t),sign[i]=Read(),B[i]=read();
    if (str[i][0]=='i') A[i]=read(),B[i]=read(),scanf("%d%d",&P[i],&Q[i]);
    if (str[i][0]=='s') scanf("%d%d",&P[i],&Q[i]);
    if (i%174==2&&i>10) 
      if (!A[i].x) 
        assert(str[i][0]!='s'),i--,n--,S[++*S]=j;
  }printf("%d ",n);
  for (i=1;i<=n;i++)
  	P[i]=calc(P[i]),Q[i]=calc(Q[i]);
  for (st=6;st<=n;st+=174){
    best[++tot]=-1e9;
    assert(str[st][0]=='s');
    for (i=3;i<=12;i++) now[i]=0;
    DFS(1);
    //fprintf(stderr,"%d %d\n",st,best[tot]);
    for (k=1;k<=10;k++)
      assert(ret[tot][k]>0);//fprintf(stderr,"%d ",ret[tot][k]);
  }assert(tot==200);
  bug=0;tot=0;
  for (st=2;st<=n;st+=174) pos[st]=++tot;
  for (i=0;i<=tot+1;i++)
    for (k=0;k<M;k++) F[i][k]=-1e9;
  F[1][1000]=0;
  for (i=1;i<=tot;i++)
    for (k=0;k<M;k++)
      if (F[i][k]>-1e9){
        //fprintf(stderr,"%d %d %d\n",i,k,F[i][k]);
        st=1+(i-1)*174+1;
        assert(str[st][0]=='i'&&A[st].y==2);
        if (k<B[st].y){
        	if (P[st+1]>=1&&P[st+1]<=n){
            //printf("%d %d %d\n",st+1,index[P[st+1]],index[Q[st+1]]);
            newi=pos[P[st+1]];assert(newi);
            if (F[i][k]>F[newi][k])
              F[newi][k]=F[i][k],prei[newi][k]=i,prek[newi][k]=k,
              walk[newi][k]=-1,extra[newi][k]=0;
          }else 
            if (F[i][k]>F[tot+1][k])
              F[tot+1][k]=F[i][k],prei[tot+1][k]=i,prek[tot+1][k]=k,
              walk[tot+1][k]=-1,extra[tot+1][k]=0;
          continue;
        }st+=2;assert(str[st][0]=='s');
        if (Q[st]<1||Q[st]>n){
          if (F[i][k]>F[tot+1][k])
            F[tot+1][k]=F[i][k],prei[tot+1][k]=i,prek[tot+1][k]=k,
            walk[tot+1][k]=2,extra[tot+1][k]=0;
        }else{
          assert(pos[Q[st]]);
          newi=pos[Q[st]];
          if (F[i][k]>F[newi][k])
            F[newi][k]=F[i][k],prei[newi][k]=i,prek[newi][k]=k,
            walk[newi][k]=2,extra[newi][k]=0;
        }
        ++st;assert(A[st].y==2&&B[st].x==0);
        //fprintf(stderr,"%d %d\n",sign[st],B[st].y);
        newk=k+sign[st]*B[st].y;
        assert(newk<=k);
        //fprintf(stderr,"%d\n",F[i][k]+best[i]);
        if (F[i][k]+best[i]>F[i+1][newk])
          F[i+1][newk]=F[i][k]+best[i],prei[i+1][newk]=i,prek[i+1][newk]=k,
          walk[i+1][newk]=1,extra[i+1][newk]=i;
      }
  //fprintf(stderr,"%d %d\n",F[tot][500],F[tot+1][500]);
  for (k=0;k<M;k++)
    if (F[tot+1][k]>ans)
      ans=F[tot+1][k],tmpi=tot+1,tmpk=k;
  fprintf(stderr,"%d\n",ans);
  freopen("train10.out","w",stdout);
  BACK(tmpi,tmpk);
  return 0;
}
```

---


# [CTSC2010] 产品销售

## 题目描述

A 公司正在热销某计算机产品，作为 A 公司 CEO 的小 A 打算为接下来连续的 $N$ 个销售季度制定一份具体的生产和销售方案。 已知第 $i$ 个销售季度该产品的订购量为 $D_i$，在第 $i$ 个季度，A 公司会通过如下几种方式来解决用户的订购需求：

- 在第 $i$ 个季度生产新的产品来销售。
- 若在第 $i$ 个季度以前库存还有多余的产品，则可以直接在第 $i$ 个季度销售（注意第一个季度之前没有任何库存产品）。
- 在第 $i$ 个季度可以不完成全部的订购需求，而将未完成的订购需求推迟，归入到下一个季度 $(i + 1)$ 的产品订购需求中。

A 公司需要考虑以下几种耗费： 生产新产品的成本耗费、库存产品的额外储存耗费以及推迟订购需求而需要赔偿给用户的损失费。另外由于劳力和资源的限制，每个销售季度能够生产新产品的数量是有限的，各季度的耗费和可以生产的产品上限数也不尽相同，具体如下：

- 在第 $i$ 个季度最多可以生产 $U_i$ 件新的产品，每一件的成本为 $P_i$。
- 第 $i$ 个季度保存下来的产品，可以用于以后季度的销售。对于每一件产品，若从第 $i$ 季度保存到第 $i + 1$ 季度， 需要额外支付 $M_i$ 的存储费用（注意产品保存到下个季度后可能再次库存）。
- 对于第 $i$ 个季度需要推迟而归入到下一个季度订购需求的每一件产品，A 公司需要赔偿给用户损失费 $C_i$（注意延迟到下个季度可能再次被延迟, 费用按后面季度的延迟费用计）。

在第 $N$ 个季度结束后， A 公司必须解决之前所有的用户订单。可以保证， A公司能够生产的产品总数不会低于总订购量， 也就是说一定存在一组生产和销售方案使得满足所有的用户订购需求。小 A 想知道如何来安排产品的生产和销售，使得在满足所有订购需求的前提下公司总的耗费最小。

## 说明/提示

【样例说明】

第一个季度生产 $2$ 件产品，第二个季度生产 $5$ 件产品，第三个季度不生产产品，第四个季度生产 $1$ 件产品，成本为 $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$。

因为第一个季度最多只能生产 $2$ 件产品，无法满足 $3$ 件的订购量，因此将 $1$件产品的订购量推迟到第二个季度，赔偿给用户的损失费为 $5$。

第二个季度由于第一个季度推迟了一件产品的订购需求， 因而订购量变为 $3$。该季度生产了 $5$ 件产品，剩下的 $2$ 件保存下来。第三个季度直接销售库存的产品，再多出来的 $1$ 件产品继续储存到第四个季度，加上第四个季度生产了 $1$ 件产品，因此满足了所有订单需求。总的储存费用为 $2 * 2 + 1 * 1 = 5$。

总的费用为 $20 + 5 + 5 = 30$。

【数据规模】

对于 $30\%$的数据， $N \leq 1,000$。

对于 $100\%$的数据， $1 \leq N \leq 100,000$， $1 \leq D_i, U_i, P_i, M_i,C_i \leq  10,000$。

## 样例 #1

### 输入

```
4
3 2 1 2
2 5 2 2
5 1 5 5
1 2 1
5 3 3```

### 输出

```
30```

# 题解

## 作者：dsidsi (赞：12)

# 「CTSC2010」产品销售-线段树+模拟费用流

## Description

有 $n$ 天,每一天商店可以进口最多 $U_i$ 件商品,价格为 $P_i$ ,每一天也有一定的订货量 $D_i$ 。

一件商品进口之后,如果没有立即卖出,每在仓库放置一天要付出代价 $M_i$ 。如果第 $i$ 天某位顾客要买的商品缺了 $k$ 件,那么要付出 $k \times C_i$ 的代价延期一天购买。问最小总耗费。

$n \leq 10^5$

## Solution

建立费用流模型。

 - $s \to i$，流量为 $D_i$，费用为 $0$；
 - $i \to t$，流量为 $U_i$，费用为 $P_i$；
 - $i \to i + 1$，流量为 $\infty$，费用为$C_i$；
 - $i + 1 \to i$，流量为 $\infty$，费用为$M_i$。

定义$1..n$为从左到右。有两条性质

 - 直接与$s,t$相连的边不会被反悔；
 - 按某种顺序依次增广必然要经过的出边，答案不变。


考虑从左至右增广。增广路有两种，分别是从左往右和从右往左。由于是向右增广，向右的边的边权不会发生变化，而向左的边则会有一些边权为负的反悔边。

考虑用线段树维护。

每次向右增广时，会产生一些向左的反悔边。由于这些边边权$<0$，所以在向左增广时一定会被选择。用第一棵线段树维护向右增广到每个点的权值，第二棵线段树向左增广到每个点的权值，第三棵线段树维护反悔边的流量。当某条反悔的流量状态（指是否是$0$）的状态变化时，在第二棵线段树上进行相应的修改。

考虑这样做的复杂度，对于某条反悔边，在增广点在它左边时只会增加它的流量，当增广点在它右边时只会减少它的流量。这样一条反悔边的状态变化是$O(1)$的，总复杂度$O(nlogn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
const int maxn = 100005, Inf = 1e9;

inline int gi()
{
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	int sum = 0;
	while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

int n, D[maxn], U[maxn], P[maxn], A[maxn], B[maxn], det[maxn];
ll ans;

#define mp make_pair
#define fi first
#define se second

#define mid ((l + r) >> 1)
#define lch (s << 1)
#define rch (s << 1 | 1)

struct sgt
{
	
	pii Min[maxn << 2];
	int tag[maxn << 2], vis[maxn << 2], mn[maxn << 2];

	void build(int s, int l, int r, int *A, int b);
	void pushdown(int s);
	void modify(int s, int l, int r, int ql, int qr, int v);
	void modify2(int s, int l, int r, int ql, int qr, int v);
	pii query(int s, int l, int r, int ql, int qr);
	
} s1, s2, s3;

void sgt::build(int s, int l, int r, int *A, int b)
{
	vis[s] = b;
	if (l == r) return Min[s] = make_pair(mn[s] = A[l], l), void();
	build(lch, l, mid, A, b);
	build(rch, mid + 1, r, A, b);
	Min[s] = min(Min[lch], Min[rch]); mn[s] = min(mn[lch], mn[rch]);
}

void sgt::pushdown(int s)
{
	if (!tag[s]) return ;
	tag[lch] += tag[s]; if (Min[lch].fi + tag[s] >= 0) Min[lch].fi += tag[s]; 
	tag[rch] += tag[s]; if (Min[rch].fi + tag[s] >= 0) Min[rch].fi += tag[s]; 
	tag[s] = 0;
}

void sgt::modify(int s, int l, int r, int ql, int qr, int v)
{
	if (ql <= l && r <= qr) return Min[s] = mp(Min[s].fi + v, Min[s].se), tag[s] += v, void();
	pushdown(s);
	if (ql <= mid) modify(lch, l, mid, ql, qr, v);
	if (qr >= mid + 1) modify(rch, mid + 1, r, ql, qr, v);
	Min[s] = min(Min[lch], Min[rch]);
}

void sgt::modify2(int s, int l, int r, int ql, int qr, int v)
{
	if (v < 0 && !vis[s]) return ;
	if ((l == r) || (ql <= l && r <= qr && ((v > 0 && mn[s]) || (v < 0 && Min[s].fi + v > 0)))) {
		Min[s].fi += v; mn[s] += v; tag[s] += v;
		if (!Min[s].fi) vis[s] = 0, s2.modify(1, 1, n, 1, l, A[l] + B[l]);
		if (Min[s].fi == v) vis[s] = 1, det[l] += A[l] + B[l];
		return ;
	}
	pushdown(s);
	if (ql <= mid) modify2(lch, l, mid, ql, qr, v);
	if (qr >= mid + 1) modify2(rch, mid + 1, r, ql, qr, v);
	Min[s] = min(vis[lch] ? Min[lch] : mp(Inf, 0), vis[rch] ? Min[rch] : mp(Inf, 0));
	mn[s] = min(mn[lch], mn[rch]);
	vis[s] = vis[lch] | vis[rch];
}

pii sgt::query(int s, int l, int r, int ql, int qr)
{
	if (!vis[s]) return mp(Inf, 0);
	if (ql <= l && r <= qr) return Min[s];
	pushdown(s);
	pii res(Inf, 0);
	if (ql <= mid) res = min(res, query(lch, l, mid, ql, qr));
	if (qr >= mid + 1) res = min(res, query(rch, mid + 1, r, ql, qr));
	return res;
}

int main()
{
	static int sum[maxn];
	
	n = gi();
	for (int i = 1; i <= n; ++i) D[i] = gi();
	for (int i = 1; i <= n; ++i) U[i] = gi();
	for (int i = 1; i <= n; ++i) P[i] = gi();
	for (int i = 1; i < n; ++i) A[i] = gi();
	for (int i = 1; i < n; ++i) B[i] = gi();

	s2.build(1, 1, n, P, 1);
	s3.build(1, 1, n, sum, 0);
	for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + B[i - 1], sum[i - 1] += P[i - 1];
	sum[n] += P[n]; s1.build(1, 1, n, sum, 1);
	
	for (int i = 1; i <= n; ++i) {
		if (i > 1) {
			s1.modify(1, 1, n, i, n, -B[i - 1]);
			s2.modify(1, 1, n, 1, i - 1, A[i - 1] - det[i - 1]);
		}
		while (D[i]) {
			pii v1 = s1.query(1, 1, n, i, n), v2 = i > 1 ? s2.query(1, 1, n, 1, i - 1) : mp(Inf, 0);
			if (v1 < v2) {
				int w = v1.fi, p = v1.se, f = min(D[i], U[p]);
				D[i] -= f; U[p] -= f; ans += (ll)w * f;
				if (!U[p]) s1.modify(1, 1, n, p, p, Inf), s2.modify(1, 1, n, p, p, Inf);
				if (i < p) s3.modify2(1, 1, n, i, p - 1, f);
			} else {
				int w = v2.fi, p = v2.se, mn = s3.query(1, 1, n, p, i - 1).fi, f = min(mn ? mn : Inf, min(D[i], U[p]));
				D[i] -= f; U[p] -= f; ans += (ll)w * f;
				if (!U[p]) s1.modify(1, 1, n, p, p, Inf), s2.modify(1, 1, n, p, p, Inf);
				if (mn && i > p) s3.modify2(1, 1, n, p, i - 1, -f);
			}
		}
	}

	printf("%lld\n", ans);
	
	return 0;
}
```

---

## 作者：Aleph1022 (赞：7)

考虑 [雪灾与外卖](https://uoj.ac/problem/455) 和 [征服世界](https://www.luogu.com.cn/problem/P6943) 的反悔贪心做法，会发现在本题上复杂度无法保证。

考虑用平衡树批量执行堆的 push 和 pop，则操作形如平衡树分裂和合并。

初看会认为这个合并的值域可能相交，但事实上根据问题性质，可以反证值域不相交（具体地，反悔操作全都会 push 到另一边的堆顶），因此直接使用支持分裂合并的平衡树维护即可。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using uint = unsigned;

const ll inf = 3e9;

const int N = 1e5;

int n, d[N + 5], u[N + 5], p[N + 5], m[N + 5], c[N + 5];

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

struct FHQTreap {
  struct node {
    ll val, sum;
    int cnt, siz;
    bool neg; ll add;
    uint rnd;
    int ls, rs;
  } tr[N * 6 + 5];
  int tot;
  int newNode(ll x, int k) {
    int u = ++tot;
    tr[u].rnd = rng(), tr[u].val = x, tr[u].sum = x * (tr[u].cnt = tr[u].siz = k);
    return u;
  }
  void pushUp(int u) {
    tr[u].sum = tr[tr[u].ls].sum + tr[u].val * tr[u].cnt + tr[tr[u].rs].sum,
    tr[u].siz = tr[tr[u].ls].siz + tr[u].cnt + tr[tr[u].rs].siz;
  }
  void apply(bool neg, ll add, int u) {
    if (!u) return ;
    if (neg) tr[u].neg ^= 1, tr[u].add *= -1, tr[u].val *= -1, tr[u].sum *= -1, swap(tr[u].ls, tr[u].rs);
    if (add) tr[u].add += add, tr[u].val += add, tr[u].sum += add * tr[u].siz;
  }
  void pushDown(int u) {
    apply(tr[u].neg, tr[u].add, tr[u].ls), apply(tr[u].neg, tr[u].add, tr[u].rs),
    tr[u].neg = tr[u].add = 0;
  }
  int join(int u, int v) {
    if (!u || !v) return u | v;
    pushDown(u), pushDown(v);
    if (tr[u].rnd < tr[v].rnd) { tr[u].rs = join(tr[u].rs, v), pushUp(u); return u; }
    else { tr[v].ls = join(u, tr[v].ls), pushUp(v); return v; }
  }
  pair<int, int> split(ll x, int k, int u) {
    if (!u) return {0, 0};
    pushDown(u);
    if (tr[u].val <= x && tr[tr[u].ls].siz < k) {
      if (tr[u].siz - tr[tr[u].rs].siz > k) {
        k -= tr[tr[u].ls].siz;
        int v = newNode(tr[u].val, exchange(tr[u].cnt, k) - k); tr[v].rs = exchange(tr[u].rs, 0);
        pushUp(u), pushUp(v);
        return {u, v};
      }
      int v; tie(tr[u].rs, v) = split(x, k - tr[u].siz + tr[tr[u].rs].siz, tr[u].rs), pushUp(u);
      return {u, v};
    } else {
      int v; tie(v, tr[u].ls) = split(x, k, tr[u].ls), pushUp(u);
      return {v, u};
    }
  }
  int insert(ll x, int k, int u) {
    int v; tie(u, v) = split(x, tr[u].siz, u);
    return join(u, join(newNode(x, k), v));
  }
} treap;

int rt[2];
ll ans;
void update(bool op, ll u, int cu, ll w) {
  int frt; tie(frt, rt[op ^ 1]) = treap.split(-u - w, cu, rt[op ^ 1]);
  int fu = treap.tr[frt].siz; ans += (u + w) * fu + treap.tr[frt].sum, cu -= fu;
  treap.apply(1, -w, frt), rt[op] = treap.join(frt, rt[op]);
  if (fu) rt[op ^ 1] = treap.insert(-u - w, fu, rt[op ^ 1]);
  if (cu) rt[op] = treap.insert(u, cu, rt[op]);
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%d", d + i);
  for (int i = 1; i <= n; ++i) scanf("%d", u + i);
  for (int i = 1; i <= n; ++i) scanf("%d", p + i);
  for (int i = 2; i <= n; ++i) scanf("%d", m + i), m[i] += m[i - 1];
  for (int i = 2; i <= n; ++i) scanf("%d", c + i), c[i] += c[i - 1];
  for (int i = 1; i <= n; ++i) update(0, p[i] - m[i], u[i], c[i] + m[i]), update(1, -c[i] - inf, d[i], c[i] + m[i]), ans += inf * d[i];
  printf("%lld\n", ans);
}
```

---

## 作者：Acetyl (赞：6)

## 题意

有一家公司正在销售产品，在接下来的 $N$ 个季度中，第 $i$ 个季度最多可以生产 $U_i$ 件新产品，每一件有成本 $P_i$，同时也会有 $D_i$ 个订单，每一件产品生产完成后保存到下一个季度需要花费 $M_i$，每一个订单拖到下一个季度需要花费 $C_i$，问满足所有订购需求的情况下，最小的花费是多少。数据范围 $N≤10^5$。

## 思路

### 费用流建图

根据题意，可以建出这样的一张费用流的图：

+ $S \to A_i $，流量限制为 $D_i$，费用为 $0$；
+ $A_i\to T$，流量限制为 $U_i$，费用为 $P_i$；
+ $A_i\to A_{i+1}$，流量限制为 $\infty$，费用为 $C_i$；
+ A_(i+1)→A_i，流量限制为 $\infty$，费用为 $M_i$ 。

对这张图跑一遍最小费用最大流，即可得到答案，时间复杂度 $\mathcal O(N^2 )$，可以得到 30 分。

### 怎么优化？

我们发现，上面这张费用流的图非常特殊，除了源点和汇点以外，剩余的点组成了一条双向的链，源点和汇点与剩下的每个点之间都有一条边，每一条增广路径都是 $S→A_u⟶A_v→T$ 的形式。对于这种特殊的图，如果使用普通的最小费用流，复杂度会很高，但是如果手动模拟费用流，就能降低复杂度，这种做法被称为模拟费用流。

### 模拟费用流

这个费用流模型中，增广路有两种：$u≤v$ 和 $u>v$。设 $A_i→A_{i+1}$ 的边为 $L_i$，其反向边为 $L_i'$，设 $A_{i+1}→A_i$ 的边为 $R_i$，其反向边为 $R_i'$，则每一条 $u≤v$ 的增广路只会包含 $L_i$ 和 $R_i'$（只要 $R_i'$ 的剩余流量不为 $0$ 数就一定会走 $R_i'$，因为 $R_i'$ 的费用是负数，而 $L_i$ 的费用是正数），每一条 $u>v$ 的增广路只会包含 $R_i$ 和 $L_i'$。

整个费用流的过程中，$L_i'$ 和 $R_i'$ 的剩余流量至少有一个是 $0$，假设第一步走的是 $L_i$，则此时 $L_i'$ 的剩余流量被加 $1$，$R_i'$ 的剩余流量还是 $0$，之后如果出现了一条从右边往左边的增广路，这条路在经过第 $i$ 条边的时候也只会走 $L_i'$ 这条边，而不是 $R_i$，所以 $R_i'$ 的剩余流量会一直保持在 $0$，直到 $L_i'$ 的剩余流量回到 $0$ 为止。

考虑使用两棵线段树分别维护从左到右的增广路和从右到左的增广路，由于增广路是连续的一段，所以每次选取增广路等价于区间最小连续和，可以通过在线段树上维护区间和 $sum$、区间前缀最小值 $minl$ 及对应的位置、区间后缀最小值 $minr$ 及对应的位置和区间最小连续和 $minx$ 及对应的区间来解决。对于长度为 $1$ 的区间，如果当前的 $D_i$  或 $U_i$  被用完了，则 $minl$、$minr$ 和 $minx$ 设为 $∞$，否则 $minl$ 设为当前区间对应的边的代价，$minr$ 和 $minx$ 设为 $P_i$  即可。

下面考虑如何维护网络流的剩余流量，对于前两类边，每一条增广路中恰好出现一次，所以可以直接维护。对于第三类和第四类边，可以用一棵支持区间加、区间求最小值的线段树维护。

然后是反向边的问题。由于前面已经证明过，$L_i'$ 和 $R_i'$ 中至少有一个点剩余流量为 $0$，所以我们就可以定义一条边处于“平衡状态”当且仅当这条边对应的 $L_i'$ 和 $R_i'$ 的剩余流量都是 $0$，可以将这些边用一个 set 维护。每次增广一些边的时候，肯定有一些边从平衡状态到达了不平衡状态，对于这些边，我们只需要在 set 中不断 `lower_bound` 找到在增广区间内的平衡边，将这些边反向边的权值和反向边流量更新到线段树上之后，从 set 中删除这条边即可；当然也会有一部分边从不平衡状态回到平衡状态：如果一条 $L_i'$ 或 $R_i'$ 的边在增广完之后剩余流量回到了 $0$，则这些边就会回到平衡状态，此时将边权改回来，将剩余流量改为 $∞$ 即可，查找这些流量回到 $0$ 的边可以在线段树上二分。

这样，我们就成功地用线段树和贪心模拟了这个费用流，操作次数在绝大多数情况下都是 $\mathcal O(n)$ 级别的（目前找不到能卡掉的数据），总时间复杂度 $\mathcal O(n\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define SZ(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define loop(i, a) for (int i = 0; i < (a); ++i)
#define cont(i, a) for (int i = 1; i <= (a); ++i)
#define circ(i, a, b) for (int i = (a); i <= (b); ++i)
#define range(i, a, b, c) for (int i = (a); (c) > 0 ? i <= (b) : i >= (b); i += (c))
#define parse(it, x) for (auto &it : (x))
#define pub push_back
#define pob pop_back
#define emb emplace_back
#define mak make_pair
#define mkt make_tuple
typedef long long ll;
typedef long double lf;
const int Inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3fll;
 
int n;
int d[2][100005], u[2][100005], p[2][100005], c[2][100005];
 
struct Node {
    int sm, ml, mr, mlp, mrp, mn;
    pair<int, int> pos;
 
    friend Node inline operator + (const Node &a, const Node &b) {
        Node res; res.sm = a.sm + b.sm;
        if (a.ml != Inf && a.ml + b.sm < b.ml) {
            res.ml = a.ml + b.sm, res.mlp = a.mlp;
        } else {
            res.ml = b.ml, res.mlp = b.mlp;
        }
        if (b.mr != Inf && a.sm + b.mr < a.mr) {
            res.mr = a.sm + b.mr, res.mrp = b.mrp;
        } else {
            res.mr = a.mr, res.mrp = a.mrp;
        }
        res.mn = min(Inf, a.ml + b.mr);
        res.pos = mak(a.mlp, b.mrp);
        if (a.mn < res.mn) res.mn = a.mn, res.pos = a.pos;
        if (b.mn < res.mn) res.mn = b.mn, res.pos = b.pos;
        return res;
    }
} t[2][1 << 18];
 
int dt[2][1 << 18], wp[2][1 << 18];
 
void inline pd(int id, int now) {
    if (!wp[id][now]) return;
    if (dt[id][now << 1] != Inf) dt[id][now << 1] += wp[id][now], wp[id][now << 1] += wp[id][now];
    if (dt[id][now << 1 | 1] != Inf) dt[id][now << 1 | 1] += wp[id][now], wp[id][now << 1 | 1] += wp[id][now];
    wp[id][now] = 0;
}
 
void change(int id, int to, int x, int now = 1, int nl = 1, int nr = n) {
    if (nl == nr) {
        if (x != Inf) t[id][now].sm = x;
        t[id][now].ml = t[id][now].mr = t[id][now].mn = Inf;
        if (d[id][nl]) t[id][now].ml = t[id][now].sm, t[id][now].mlp = nl;
        if (u[id][nl]) t[id][now].mr = p[id][nl], t[id][now].mrp = nl;
        if (d[id][nl] && u[id][nl]) t[id][now].mn = p[id][nl], t[id][now].pos = mak(nl, nl);
        return;
    }
    int m = (nl + nr) >> 1;
    if (m >= to) change(id, to, x, now << 1, nl, m);
    else change(id, to, x, now << 1 | 1, m + 1, nr);
    t[id][now] = t[id][now << 1] + t[id][now << 1 | 1];
}
 
void chflow(int id, int to, int x, int now = 1, int nl = 1, int nr = n - 1) {
    if (nl == nr) return (void)(dt[id][now] = x);
    pd(id, now); int m = (nl + nr) >> 1;
    if (m >= to) chflow(id, to, x, now << 1, nl, m);
    else chflow(id, to, x, now << 1 | 1, m + 1, nr);
    dt[id][now] = min(dt[id][now << 1], dt[id][now << 1 | 1]);
}
 
int get(int id, int l, int r, int now = 1, int nl = 1, int nr = n - 1) {
    if (nl > r || nr < l) return Inf;
    if (nl >= l && nr <= r) return dt[id][now];
    pd(id, now); int m = (nl + nr) >> 1;
    return min(get(id, l, r, now << 1, nl, m), get(id, l, r, now << 1 | 1, m + 1, nr));
}
 
void add(int id, int l, int r, int x, int now = 1, int nl = 1, int nr = n - 1) {
    if (nl > r || nr < l) return;
    if (nl >= l && nr <= r) return (void)(dt[id][now] += x, wp[id][now] += x);
    pd(id, now); int m = (nl + nr) >> 1;
    add(id, l, r, x, now << 1, nl, m);
    add(id, l, r, x, now << 1 | 1, m + 1, nr);
    dt[id][now] = min(dt[id][now << 1], dt[id][now << 1 | 1]);
}
 
int findzero(int id, int now = 1, int nl = 1, int nr = n - 1) {
    if (nl == nr) return nl;
    pd(id, now); int m = (nl + nr) >> 1;
    if (dt[id][now << 1] == 0) return findzero(id, now << 1, nl, m);
    else return findzero(id, now << 1 | 1, m + 1, nr);
}
 
set<int> bal;
 
int main() {
    scanf("%d", &n);
    cont(i, n) scanf("%d", d[0] + i), d[1][n + 1 - i] = d[0][i];
    cont(i, n) scanf("%d", u[0] + i), u[1][n + 1 - i] = u[0][i];
    cont(i, n) scanf("%d", p[0] + i), p[1][n + 1 - i] = p[0][i];
    cont(i, n - 1) scanf("%d", c[1] + (n - i));
    cont(i, n - 1) scanf("%d", c[0] + i);
    cont(i, n) change(0, i, c[0][i]), change(1, i, c[1][i]);
    cont(i, n - 1) chflow(0, i, Inf), chflow(1, i, Inf), bal.insert(i);
    ll ans = 0;
    while (1) {
        int id = (t[1][1].mn < t[0][1].mn);
        if (t[id][1].mn == Inf) break;
        int x, y; tie(x, y) = t[id][1].pos;
        int fl = min(d[id][x], u[id][y]);
        if (x != y) fl = min(fl, get(id, x, y - 1));
        ans += 1ll * fl * t[id][1].mn;
        assert(fl);
        int rlim = id ? n + 1 - x : y;
        int $$=0;
        while (1) {
            auto it = bal.lower_bound(id ? n + 1 - y : x);
            if (it == bal.end() || *it >= rlim) break;
            int pos = id ? *it : n - *it;
            chflow(!id, pos, 0);
            change(!id, pos, -c[id][n - pos]);
            bal.erase(it);
        }
        if (x != y) {
            add(id, x, y - 1, -fl);
            add(!id, n + 1 - y, n - x, fl);
        }
        while (!dt[id][1]) {
            int pos = findzero(id);
            chflow(id, pos, Inf);
            change(id, pos, c[id][pos]);
            bal.insert(id ? n - pos : pos);
        }
        d[id][x] -= fl; d[!id][n + 1 - x] -= fl;
        if (!d[id][x]) change(id, x, Inf), change(!id, n + 1 - x, Inf);
        u[id][y] -= fl; u[!id][n + 1 - y] -= fl;
        if (!u[id][y]) change(id, y, Inf), change(!id, n + 1 - y, Inf);
    }
    printf("%lld\n", ans);
    return 0;
}
```


---

## 作者：Acoipp (赞：2)

## 分析

首先如果 $n$ 没有这么大的话我们可以用费用流解决，大概就是建立 $4$ 层点，源点单独在第一层，汇点单独在最后一层。

第二层建立 $n$ 个节点代表第 $i$ 天的生产，第三层建立 $n$ 个节点代表第 $i$ 天的任务，那么由源点向第二层连容量 $u_i$，费用 $p_i$ 的边，第二层的第 $i$ 个点向下一个点连容量无限大，费用 $m_i$ 的边，并且连向第三层第 $i$ 个点，容量无限大，费用为 $0$。

同时，为了简化我们后面的讨论，让第三层的点向第二层的点分别连接容量无限大，费用 $0$ 的边，容易发现，这样不影响答案。

第三层的第 $i$ 个点连向上一个点，容量无限大，费用 $c_{i-1}$，并且向汇点连接一条容量为 $d_i$，费用为 $0$ 的边，图就构好了。

最后的图的形态像一个灯笼，如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ze4hxapn.png)

## 优化

直接跑最小费用最大流会超时，我们考虑用数据结构模拟一下费用流。

我们可以枚举连向 $t$ 的边，依次给这些边寻找一个增广路，以上图中的 $8 \to t$ 为例，如果我们选择从 $3 \sim 5$ 号点找增广路，那不论怎样，增广的权值都是可以用前缀和算的，即第三层的一段连续的边，第二层因为我们是按照 $6 \sim 10$ 的顺序枚举增广边，所以 $3$ 后面的边一定不会有可以反悔的边。

还可以由 $1 \sim 3$ 来找对于 $8$ 的增广路，这样的话如果第二层的边所对应的第三层的边有反悔边，那我们肯定去走第三层的边，因为其边权为负数，否则走第二层的边，那么增广的权值也可以计算，增广的流量大小就是源点出来的边的流量，汇点接收的边的流量和中间反悔边的流量取 $\min$ 就可以了。

那么我们可以用几个线段树实现此过程，细节很多，这里就不一一展开了。

## 时间复杂度

容易发现如果我们是从这个点的后面找增广路，因为没有反悔边，所以要么源点出去的某条边满流，要么这个点到汇点的边满流。

如果我们从这个点前面找增广路，每次会有至少一条反悔边或者源点出去的某条边或者到汇点的边满流，而每条反悔边只会满流一次，不可能退流，故操作总数量是 $O(n)$ 的，每次维护增广路用线段树是 $O(\log n)$ 的，故总时间复杂度是 $O(n \log n)$ 的。


## 代码

最后贴一下很丑陋的代码。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#define ll long long
#define inf 10000000000000ll
#define N 100005
using namespace std;
ll n,d[N],u[N],p[N],m[N],c[N],i,ans,used,oth,temp;
struct node{
	ll tr[N<<2],tr2[N<<2],la[N<<2],a[N],ans,ans2;
	inline void pushup(ll p){
		if(tr[2*p]<=-inf){
			tr[p]=tr[2*p+1],tr2[p]=tr2[2*p+1];
			return ;
		}
		if(tr[2*p+1]<=-inf){
			tr[p]=tr[2*p],tr2[p]=tr2[2*p];
			return ;
		}
		if(tr[2*p]<tr[2*p+1]) tr[p]=tr[2*p],tr2[p]=tr2[2*p];
		else tr[p]=tr[2*p+1],tr2[p]=tr2[2*p+1];
	}
	inline void pushtag(ll p,ll c){la[p] += c,tr[p] += c;}
	inline void pushdown(ll p){pushtag(2*p,la[p]),pushtag(2*p+1,la[p]),la[p]=0;}
	inline void build(ll s,ll t,ll p){
		if(s==t){
			tr[p] = a[s],tr2[p] = s;
			return ;
		}
		build(s,(s+t)/2,2*p),build((s+t)/2+1,t,2*p+1);
		pushup(p);
	}
	inline void add(ll x,ll c,ll s,ll t,ll p){
		if(s==t){
			tr[p] = c,tr2[p] = s,a[s] = c;
			return ;
		}
		pushdown(p);
		if(x<=(s+t)/2) add(x,c,s,(s+t)/2,2*p);
		else add(x,c,(s+t)/2+1,t,2*p+1);
		pushup(p);
	}
	inline void modify(ll l,ll r,ll c,ll s,ll t,ll p){
		if(l<=s&&t<=r) return pushtag(p,c);
		pushdown(p);
		if(l<=(s+t)/2) modify(l,r,c,s,(s+t)/2,2*p);
		if(r>(s+t)/2) modify(l,r,c,(s+t)/2+1,t,2*p+1);
		pushup(p);
	}
	inline void query(ll l,ll r,ll s,ll t,ll p){
		if(s==1&&t==n) ans=-1;
		if(l<=s&&t<=r){
			if((ans==-1||tr[p]<=ans2)&&tr[p]>-inf) ans=tr2[p],ans2=tr[p];
			return ;
		}
		pushdown(p);
		if(l<=(s+t)/2) query(l,r,s,(s+t)/2,2*p);
		if(r>(s+t)/2) query(l,r,(s+t)/2+1,t,2*p+1);
	}
}tr1,tr2,tr3,tr4;
set<ll> add,del;
mt19937 rnd(time(0));
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(i=2;i<=n;i++) del.insert(i);
	for(i=1;i<=n;i++) cin>>d[i];
	for(i=1;i<=n;i++) cin>>u[i];
	for(i=1;i<=n;i++) cin>>p[i];
	for(i=2;i<=n;i++) cin>>m[i];
	for(i=2;i<=n;i++) cin>>c[i];
	for(i=2;i<=n;i++) m[i]+=m[i-1],c[i]+=c[i-1];
	for(i=1;i<=n;i++) tr1.a[i]=c[i]+p[i],tr2.a[i]=p[i]+m[n]-m[i],tr3.a[i]=-1e18,tr4.a[i]=p[i]+m[n]-m[i];
	tr1.build(1,n,1),tr2.build(1,n,1),tr3.build(1,n,1),tr4.build(1,n,1);
	for(i=1;i<=n;i++){
		while(d[i]){
			tr4.query(i,i,1,n,1),temp=tr4.ans2-p[i];
			tr1.query(i,n,1,n,1),tr1.ans2-=c[i];
			tr2.query(1,i,1,n,1),tr2.ans2-=temp;
			if(tr1.ans2<tr2.ans2){
				oth = tr1.ans,used = min(d[i],u[oth]),ans += used*tr1.ans2,d[i] -= used,u[oth] -= used;
				if(u[oth]==0){
					tr1.add(oth,1e18,1,n,1);
					tr2.add(oth,1e18,1,n,1);
				}
				while(1){
					auto pos = del.upper_bound(i); 
					if(pos==del.end()||*pos>oth) break;
					tr2.modify(1,*pos-1,-((m[*pos]-m[*pos-1])+(c[*pos]-c[*pos-1])),1,n,1);
					tr4.modify(1,*pos-1,-((m[*pos]-m[*pos-1])+(c[*pos]-c[*pos-1])),1,n,1);
					tr3.add(*pos,0,1,n,1);
					add.insert(*pos),del.erase(pos);
				} 
				if(i<oth) tr3.modify(i+1,oth,used,1,n,1);
			}
			else{
				oth = tr2.ans,used = min(d[i],u[oth]);
				if(oth<i){
					tr3.query(oth+1,i,1,n,1);
					if(tr3.ans!=-1&&tr3.ans2>-inf) used=min(used,tr3.ans2);
				}
				ans += used*tr2.ans2,d[i] -= used,u[oth] -= used;
				if(u[oth]==0){
					tr1.add(oth,1e18,1,n,1);
					tr2.add(oth,1e18,1,n,1);
				}
				if(oth<i){
					while(1){
						tr3.query(oth+1,i,1,n,1);
						if(tr3.ans2!=used) break;
						if(tr3.ans<=oth) break;
						del.insert(tr3.ans),add.erase(tr3.ans);
						tr2.modify(1,tr3.ans-1,((m[tr3.ans]-m[tr3.ans-1])+(c[tr3.ans]-c[tr3.ans-1])),1,n,1),tr3.add(tr3.ans,-1e18,1,n,1),tr4.modify(1,tr3.ans-1,((m[tr3.ans]-m[tr3.ans-1])+(c[tr3.ans]-c[tr3.ans-1])),1,n,1);
					}
					tr3.modify(oth+1,i,-used,1,n,1);
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
/*
Input:
10
1 3 3 4 3 9 3 3 2 4
8 10 9 6 5 1 9 7 2 6
1 1 4 4 7 2 2 6 7 7
3 2 5 4 9 2 7 5 3
9 4 8 7 4 4 1 4 10

Output:
176

5
10 3 6 1 10
2 5 8 8 9
10 9 3 10 7
7 6 3 7
10 3 9 5

20
5 6 4 10 2 9 1 10 3 4 6 4 2 1 1 5 2 7 1 8
4 2 4 8 10 10 3 5 8 3 5 5 5 6 6 4 8 4 8 5
2 4 6 7 5 6 8 1 6 6 4 3 10 10 3 5 2 9 8 6
6 6 6 1 3 1 4 5 6 2 9 3 10 4 8 3 3 2 5
2 10 8 7 6 9 6 9 10 6 10 9 1 10 1 5 7 7 10

10
8 3 3 6 2 1 5 1 9 6
8 6 6 1 8 9 4 1 4 9
9 10 4 7 4 4 1 1 8 10
1 7 8 5 10 3 6 8 2
2 8 5 3 4 2 4 8 2
*/
```

---

## 作者：devout (赞：2)

模拟费用流**好**题

首先这显然是一个费用流问题，可以有以下建边：

- $(S,i,U_i,P_i)$
- $(i,i+1,\infty,M_i)$
- $(i+1,i,\infty,C_i)$
- $(i,T,D_i,0)$

然后注意到 $n\leq 10^5$。

所以我们需要观察这个图的性质，发现其实他长得还是很好看的。

为了方便，我们把整个图反向，从 $T$ 到 $S$ 跑费用流，这样做有一个好处，就是现在所有从 $S$ 出发的边一定是满流的，所以我们可以考虑从 $1\sim n$ 去增广，每次让出边流满。

按照顺序去增广我们发现一共只需要三类边：

- $(i,i+1,\infty,C_i)$
- $(i+1,i,\infty,M_i)$
- $(i+1,i,Cap,-C_i)$

而 $M_i$ 的反向边因为我们是按照顺序增广的，所以虽然会出现，但是我们一定不会跑到。

第三类边是第一类边走出来之后走的反相边，并且显然如果这样的边存在我们是不会去走第二类边的。

考虑现在增广 $i$，$i$ 可以往右走，这相当于是每个点有代价，我们要区间求最小值和最小值的位置，不难想到利用一个线段树来维护，在 $i$ 到 $i+1$ 的时候一个区间加（减）就可以解决

考虑往左走的情况，同样是一个区间我们需要另一个线段树来维护 cost。

但是向左走的边有些是有流量限制的，所以我们需要第三棵线段树来维护每条边当前的流量。

如果向右走，我们就要在第三棵树上区间加，如果向左走就是区间减法。

但是如果第三棵树上的 0/非0 状态变化时需要在第二棵树上做对应的修改。

考虑这个做法的复杂度，观察每一条第三类边，他最多会被加入一次，最多会被删除一次，每次需要 $O(\log n)$ 的时间，所以这道题的总复杂度就是 $\mathcal O(n\log n)$

****

注意有一个非常坑的地方就是当我们往右走的时候如果需要加入一条新的反向边，我们不能直接在 $[1,x]$ 上减掉 $C[x]+M[x]$，因为这个时候在 $[1,i]$ 中的贡献里还没有 $C[x]$ 这条边的贡献，应当开一个数组记录，在枚举到 $x$ 的时候再做修改。


```cpp
#include <bits/stdc++.h>

using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

const int N=1e5+5;
const int inf=1e9+N;

typedef long long ll;
typedef double db;

# define chkmax(a,b) a=max(a,b)
# define chkmin(a,b) a=min(a,b)
# define PII pair<int,int>
# define mkp make_pair

template<typename T> void read(T &x){
    x=0;int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n;
int D[N],U[N],P[N],M[N],C[N];
int del[N];
PII a[N];
int b[N];
ll ans;

struct segment_tree{
    struct node{
        PII min;
        int tag,low;
        bool flag;
    }seg[N<<2];
    # define lc (u<<1)
    # define rc (u<<1|1)
    void pushup(int u){
        seg[u].min=min(seg[lc].flag?seg[lc].min:mkp(inf,0),seg[rc].flag?seg[rc].min:mkp(inf,0));
        seg[u].low=min(seg[lc].low,seg[rc].low);
        seg[u].flag=seg[lc].flag|seg[rc].flag;
    }
    void renew(int u,int k){
        seg[u].min.first+=k,seg[u].tag+=k;
        seg[u].low+=k;
    }
    void pushdown(int u){
        renew(lc,seg[u].tag);
        renew(rc,seg[u].tag);
        seg[u].tag=0;
    }
    void build(int u,int l,int r){
        if(l==r){
            seg[u].min=a[l];
            seg[u].flag=b[l];
            return;
        }
        int mid=l+r>>1;
        build(lc,l,mid);
        build(rc,mid+1,r);
        pushup(u);
    }
    void update(int u,int l,int r,int ql,int qr,int k){
        if(l>=ql&&r<=qr){
            renew(u,k);
            return;
        }
        if(seg[u].tag)pushdown(u);
        int mid=l+r>>1;
        if(ql<=mid)update(lc,l,mid,ql,qr,k);
        if(qr>mid)update(rc,mid+1,r,ql,qr,k);
        pushup(u);
    } 
    PII query(int u,int l,int r,int ql,int qr){
        if(!seg[u].flag)return mkp(inf,0);
        if(l>=ql&&r<=qr)return seg[u].min;
        if(seg[u].tag)pushdown(u);
        int mid=l+r>>1;
        if(qr<=mid)return query(lc,l,mid,ql,qr);
        if(ql>mid)return query(rc,mid+1,r,ql,qr);
        return min(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr));
    }
}T1,T2,T3;

void modify(int u,int l,int r,int ql,int qr,int k){
    if(k<0&&!T3.seg[u].flag)return;
    if((l>=ql&&r<=qr&&((k>0&&T3.seg[u].low>0)||(k<0&&T3.seg[u].min.first+k>0)))){
        T3.renew(u,k);
        return;
    }
    if(l==r){
        T3.seg[u].min.first+=k,T3.seg[u].low+=k;
        if(T3.seg[u].min.first)T3.seg[u].flag=true,del[l]+=C[l]+M[l];
        else T3.seg[u].flag=false,T2.update(1,1,n,1,l,C[l]+M[l]);
        return;    
    }
    if(T3.seg[u].tag)T3.pushdown(u);
    int mid=l+r>>1;
    if(ql<=mid)modify(lc,l,mid,ql,qr,k);
    if(qr>mid)modify(rc,mid+1,r,ql,qr,k);
    T3.pushup(u);
}
//# define hibike
int main()
{
    # ifdef hibike
    freopen("testdata.in","r",stdin);
    // freopen("test1.out","w",stdout);
    # endif
    read(n);
    Rep(i,1,n)read(D[i]);
    Rep(i,1,n)read(U[i]);
    Rep(i,1,n)read(P[i]);
    Rep(i,1,n-1)read(C[i]);
    Rep(i,1,n-1)read(M[i]);
    Rep(i,1,n)a[i]=mkp(a[i-1].first+M[i-1],i);
    Rep(i,1,n)a[i].first+=P[i];
    Rep(i,1,n)b[i]=1;
    T1.build(1,1,n);
    Rep(i,1,n)a[i].first=P[i];
    T2.build(1,1,n);
    Rep(i,1,n)a[i].first=0;
    Rep(i,1,n)b[i]=0;
    T3.build(1,1,n);
    Rep(i,1,n){
        if(i>1){
            T1.update(1,1,n,i,n,-M[i-1]);
            T2.update(1,1,n,1,i-1,C[i-1]-del[i-1]);
        }
        while(D[i]){
            PII v1=T1.query(1,1,n,i,n),v2=i>1?T2.query(1,1,n,1,i-1):mkp(inf,0);
            if(v1<v2){
                int cost=v1.first,x=v1.second,f=min(D[i],U[x]);
                ans+=1ll*f*cost;
                D[i]-=f,U[x]-=f;
                if(!U[x])T1.update(1,1,n,x,x,inf),T2.update(1,1,n,x,x,inf);
                if(x>i)modify(1,1,n,i,x-1,f);
            }
            else{
                int cost=v2.first,x=v2.second,low=T3.query(1,1,n,x,i-1).first,f=min(min(D[i],U[x]),low?low:inf);
                ans+=1ll*cost*f;
                D[i]-=f,U[x]-=f;
                if(!U[x])T1.update(1,1,n,x,x,inf),T2.update(1,1,n,x,x,inf);
                if(x<i)modify(1,1,n,x,i-1,-f);
            }
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：forgotmyhandle (赞：1)

首先考虑一个费用流建模：
1. 源点向第 $i$ 个点连边，容量为 $u_i$，费用为 $p_i$，这代表每季度的生产；
2. 第 $i$ 个点向汇点连边，容量为 $d_i$，费用为 $0$，这代表每个季度客户的要求；
3. $\forall i \neq n$，第 $i$ 个点向第 $i + 1$ 个点连边，容量为 $+\infty$，费用为 $m_i$，这代表这个季度没用完的以 $m_i$ 的代价给下一个季度继续用；
4. $\forall i \neq n$，第 $i + 1$ 个点向第 $i$ 个点连边，容量为 $+\infty$，费用为 $c_i$，这代表以 $c_i$ 的代价把下一个季度的生产拿来满足这个季度的需求。

为了方便，我们把所有边反向，这样从源点出发的所有边都要强制满流。

但是由于 $n$ 开到了 $10^5$，所以直接费用流会 T。所以使用模拟费用流。

具体地，按顺序枚举每一个点 $x$，尝试对这个点进行一个增广。因此我们要找到从 $x$ 到汇点的费用最小的路径。可以发现增广路要么是往左走的，要么是往右走的。我们对两种增广路分别维护。

我们先来讨论如何增广。假设我们已经知道了 $S \rightarrow x \rightarrow y \rightarrow T$ 是 $x$ 到 $T$ 的费用最小的路径，此时有两种情况。

1. $y \ge x$，也就是往右走。由于 $x \rightarrow y$ 上的所有边都没有流量限制，所以这条流的流量就是 $x$ 和 $y$ 的剩余流量的最小值。设为 $f$。由于网络流的特性，此时会多出一条从 $y$ 到 $x$ 的路径，上面每条边的费用是原本的相反数，而流量限制是 $f$。发现这条路径上边的费用永远都是负数，所以只要这种边存在，我们就一定不会走费用为 $m_i$ 的那条边。

2. $y < x$，也就是往左走。这种情况下路径上可能存在有流量限制的边，所以这条流的流量还要再跟路径上的流量限制取 $\min$。这样增广之后路径上可能会有负费用边满流的情况出现。此时我们需要修改这条边的代价，把它从 $-c_i$ 变回 $m_i$。注意到这样也会产生费用为 $-m_i$ 的边，但是由于我们从左往右增广，所以这些边不会被使用到。

在增广之后，可能会出现某些点与汇点的边满流的情况。这种情况只需要把这些点从备选的增广路终点中删去即可。

然后考虑从一个点 $x$ 转向下一个点 $x + 1$ 时代价的变化。首先 $x + 1$ 及以后的点代价减去 $c_x$。其次 $x$ 及以前的点代价根据 $x$ 与 $x + 1$ 之间边的情况来定。如果这条边被用来增广过，那 $x$ 之前点的代价要减去 $c_x$，否则加上 $m_x$。

注意到实际上形如一个区间加，区间 $\min$ 的问题，使用线段树维护。首先开两棵线段树维护当前点两边点的代价，然后第三棵线段树用来维护每条反向边的剩余流量。当增广时新增了反向边，就在第三棵线段树上区间加。如果要往左增广了，就在第三棵线段树上求一个区间 $\min$。当增广时用到了反向边，就在第三棵线段树上减。如果某条反向边满流了，就在第二棵线段树上修改点的代价。如果有一个终点满流了，那就在第二棵线段树上把它的位置加个 $+\infty$。

在实现上，前两棵线段树是好实现的。对于最后一棵，我们先把所有元素赋成 $0$。接下来如果要检查是否有反向边满流，我们就暴力 dfs，找值为 $0$ 的点，把它的流量限制赋为 $+\infty$。如果这是一条满流的反向边，我们就改代价；如果这条反向边根本就没出现过，那我们就不管了。这两种情况可以通过判断每条边有没有被往右增广过来分辨。

## 代码
```cpp
#include <iostream>
#define int long long
using namespace std;
const int inf = 21474836470000;
int d[100005], u[100005], p[100005], m[100005], c[100005], pre[100005];
int n;
struct Segment_Tree1 {
    int mn[400005], mnp[400005];
    int tg[400005];
    inline void tag(int x, int y) { mn[x] += y, tg[x] += y; }
    inline void pushdown(int o) {
        if (!tg[o]) 
            return;
        tag(o << 1, tg[o]);
        tag(o << 1 | 1, tg[o]);
        tg[o] = 0;
    }
    inline void pushup(int o) {
        if (mn[o << 1] < mn[o << 1 | 1]) 
            mn[o] = mn[o << 1], mnp[o] = mnp[o << 1];
        else 
            mn[o] = mn[o << 1 | 1], mnp[o] = mnp[o << 1 | 1];
    }
    void Build(int o, int l, int r) {
        if (l == r) {
            mn[o] = p[l];
            mnp[o] = r;
            return;
        }
        int mid = (l + r) >> 1;
        Build(o << 1, l, mid);
        Build(o << 1 | 1, mid + 1, r);
        pushup(o);
    }
    void Add(int o, int l, int r, int L, int R, int v) {
        if (L > R) 
            return;
        if (L <= l && r <= R) {
            tag(o, v);
            return;
        }
        pushdown(o);
        int mid = (l + r) >> 1;
        if (L <= mid) 
            Add(o << 1, l, mid, L, R, v);
        if (R > mid) 
            Add(o << 1 | 1, mid + 1, r, L, R, v);
        pushup(o);
    }
    int Query(int o, int l, int r, int L, int R, int& p) {
        if (L > R) {
            p = 0;
            return inf;
        }
        if (L <= l && r <= R) {
            p = mnp[o];
            return mn[o];
        }
        pushdown(o);
        int mid = (l + r) >> 1;
        if (R <= mid) 
            return Query(o << 1, l, mid, L, R, p);
        if (L > mid) 
            return Query(o << 1 | 1, mid + 1, r, L, R, p);
        int lp, lv = Query(o << 1, l, mid, L, R, lp);
        int rp, rv = Query(o << 1 | 1, mid + 1, r, L, R, rp);
        if (lv > rv) 
            swap(lv, rv), swap(lp, rp);
        return p = lp, lv;
    }
} seg1, seg2, seg3;
void Deal(int o, int l, int r) {
    if (seg3.mn[o] != 0) 
        return;
    if (l == r) {
        seg3.mn[o] = inf;
        if (pre[l + 1]) 
            seg2.Add(1, 1, n, 1, l, c[l] + m[r]);
        return;
    }
    seg3.pushdown(o);
    int mid = (l + r) >> 1;
    if (seg3.mn[o << 1] == 0) 
        Deal(o << 1, l, mid);
    if (seg3.mn[o << 1 | 1] == 0) 
        Deal(o << 1 | 1, mid + 1, r);
    seg3.pushup(o);
}
void Deal(int o, int l, int r, int L, int R) {
    if (!L || !R || L > R) 
        return;
    if (L <= l && r <= R) {
        Deal(o, l, r);
        return;
    }
    seg3.pushdown(o);
    int mid = (l + r) >> 1;
    if (L <= mid) 
        Deal(o << 1, l, mid, L, R);
    if (R > mid) 
        Deal(o << 1 | 1, mid + 1, r, L, R);
    seg3.pushup(o);
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> d[i];
    for (int i = 1; i <= n; i++) cin >> u[i];
    for (int i = 1; i <= n; i++) cin >> p[i];
    seg1.Build(1, 1, n), seg2.Build(1, 1, n);
    for (int i = 1; i < n; i++) cin >> m[i];
    for (int i = 1; i < n; i++) cin >> c[i], seg1.Add(1, 1, n, i + 1, n, c[i]);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        pre[i] += pre[i - 1];
        seg1.Add(1, 1, n, i, n, -c[i - 1]);
        if (pre[i]) 
            seg2.Add(1, 1, n, 1, i - 1, -c[i - 1]);
        else 
            seg2.Add(1, 1, n, 1, i - 1, m[i - 1]);
        Deal(1, 1, n - 1, i - 1, i - 1);
        while (d[i]) {
            int x;
            int pl, ml = seg2.Query(1, 1, n, 1, i - 1, pl);
            int pr, mr = seg1.Query(1, 1, n, i, n, pr);
            if (mr < ml) {
                int f = min(d[i], u[pr]);
                d[i] -= f, u[pr] -= f;
                ans += f * mr;
                pre[i]++, pre[pr + 1]--;
                seg3.Add(1, 1, n - 1, i, pr - 1, f);
                if (!u[pr]) {
                    seg1.Add(1, 1, n, pr, pr, inf);
                    seg2.Add(1, 1, n, pr, pr, inf);
                }
            } else {
                int x;
                int f = min(seg3.Query(1, 1, n - 1, pl, i - 1, x), min(u[pl], d[i]));
                d[i] -= f, u[pl] -= f;
                seg3.Add(1, 1, n - 1, pl, i - 1, -f);
                Deal(1, 1, n - 1, pl, i - 1);
                ans += f * ml;
                if (!u[pl]) {
                    seg1.Add(1, 1, n, pl, pl, inf);
                    seg2.Add(1, 1, n, pl, pl, inf);
                }
            }
        }
    }
    cout << ans << "\n";
    return 0;
}
```
## 关于复杂度

我代码里写的是 ``while(d[i]) { ... }``。这样复杂度是正确的。每次增广我们要么流满这个点，要么流满增广路的终点，要么流满增广路上的一条反向边。注意到这些东西都至多会被流满一次，所以至多增广 $O(n)$ 次。

---

## 作者：Leasier (赞：1)

首先不难建出一个费用流模型：

- 考虑一条 $1 \sim n$ 的双向链。
- 当 $x < y$，我们用 $x \to y$ 表示损失费；当 $x > y$，我们用 $x \to y$ 表示保存费。
- $\forall 1 \leq i \leq n$，连边 $S \to^{d_i, 0} i, i \to^{u_i, p_i} T$。
- $\forall 1 \leq i < n$，连边 $i \to^{+\infty, c_i} i + 1, i + 1 \to^{+\infty, m_i} i$。
- $S \to T$ 的最小费用最大流即为答案。

由于 $n \leq 10^5$，考虑模拟费用流。

注意到我们强制从 $S$ 出发的边流满，考虑令 $i$ 从 $1$ 到 $n$ 依次增广。

考虑增广路 $S \to i \to j \to T$ 的形态：

- $i \leq j$ 时，设 $c$ 的前缀和为 $c'$，则单位流量的费用为 $c'_{j - 1} + p_j - c'_{i - 1}$。
- $i > j$ 时，设 $m$ 的后缀和为 $m'$，则单位流量的费用为 $m'_j + p_j - m'_i$……吗？

注意到若我们进行了一次 $i \leq j$ 的增广，此时会多出 $\forall i \leq k < j$ 的反悔边。贪心地，若后面要进行 $i > j$ 的增广，我们会尽可能选择这样的反悔边——因为它们的权值是负的。

用两棵线段树分别维护所有还有流量的 $i \to T$ 的 $i$ 对应的 $c'_i + p_i$ 和 $m'_i + p_i$（注意这里的 $m'$ 尽量用 $-c_i$ 替换 $m_i$ 后的 $m$ 的后缀和）的区间最值，再用一棵线段树维护反悔边流量即可。

在增广 $S \to i \to \ ? \to T$ 时，我们依次尝试取两种增广路形态对应最小费用的最大值。

若最终选择第一种增广路，要么 $S \to i$ 流满，要么 $i \to T$ 流满；否则，要么 $S \to i$ 流满，要么 $i \to T$ 流满，要么至少有一条反悔边消失。

第一种增广路的次数显然是 $O(n)$ 的。

对于第二种增广路，设这条反悔边为 $t + 1 \to t$，当 $i \leq t$ 时我们只会增加这条边的流量、当 $i > t$ 时我们只会减小这条边的流量，则增广次数也为 $O(n)$。

综上，时间复杂度为 $O(n \log n)$。

代码：
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

typedef long long ll;

int d[100007], u[100007], p[100007], m[100007], c[100007], summ[100007], sumc[100007];

namespace Tree1 {
	typedef struct {
		int l;
		int r;
		pair<int, int> pr;
	} Node;
	
	Node tree[400007];
	
	inline void update(int x){
		tree[x].pr = min(tree[x * 2].pr, tree[x * 2 + 1].pr);
	}
	
	void build(int x, int l, int r){
		tree[x].l = l;
		tree[x].r = r;
		if (l == r){
			tree[x].pr = make_pair(sumc[l - 1] + p[l], l);
			return;
		}
		int mid = (l + r) >> 1;
		build(x * 2, l, mid);
		build(x * 2 + 1, mid + 1, r);
		update(x);
	}
	
	pair<int, int> get_min(int x, int l, int r){
		if (l <= tree[x].l && tree[x].r <= r) return tree[x].pr;
		int mid = (tree[x].l + tree[x].r) >> 1;
		pair<int, int> ans(0x7fffffff, 0);
		if (l <= mid) ans = get_min(x * 2, l, r);
		if (r > mid) ans = min(ans, get_min(x * 2 + 1, l, r));
		return ans;
	}
	
	void erase(int x, int pos){
		if (tree[x].l == tree[x].r){
			tree[x].pr = make_pair(0x7fffffff, 0);
			return;
		}
		if (pos <= ((tree[x].l + tree[x].r) >> 1)){
			erase(x * 2, pos);
		} else {
			erase(x * 2 + 1, pos);
		}
		update(x);
	}
}

namespace Tree2 {
	typedef struct {
		int l;
		int r;
		int add;
		bool flag;
		pair<int, int> pr;
	} Node;
	
	Node tree[400007];
	
	inline void update(int x){
		int ls = x * 2, rs = x * 2 + 1;
		tree[x].flag = tree[ls].flag && tree[rs].flag;
		tree[x].pr = make_pair(0x7fffffff, 0);
		if (!tree[ls].flag) tree[x].pr = tree[ls].pr;
		if (!tree[rs].flag) tree[x].pr = min(tree[x].pr, tree[rs].pr);
	}
	
	void build(int x, int l, int r){
		tree[x].l = l;
		tree[x].r = r;
		if (l == r){
			tree[x].pr = make_pair(summ[l] + p[l], l);
			return;
		}
		int mid = (l + r) >> 1;
		build(x * 2, l, mid);
		build(x * 2 + 1, mid + 1, r);
		update(x);
	}
	
	inline void pushdown(int x){
		if (tree[x].add != 0){
			int ls = x * 2, rs = x * 2 + 1;
			tree[ls].add += tree[x].add;
			tree[ls].pr.first += tree[x].add;
			tree[rs].add += tree[x].add;
			tree[rs].pr.first += tree[x].add;
			tree[x].add = 0;
		}
	}
	
	pair<int, int> get_min(int x, int l, int r){
		if (tree[x].flag) return make_pair(0x7fffffff, 0);
		if (l <= tree[x].l && tree[x].r <= r) return tree[x].pr;
		int mid = (tree[x].l + tree[x].r) >> 1;
		pair<int, int> ans(0x7fffffff, 0);
		pushdown(x);
		if (l <= mid) ans = get_min(x * 2, l, r);
		if (r > mid) ans = min(ans, get_min(x * 2 + 1, l, r));
		return ans;
	}
	
	int get_val(int x, int pos){
		if (tree[x].l == tree[x].r) return tree[x].pr.first - p[pos];
		pushdown(x);
		if (pos <= ((tree[x].l + tree[x].r) >> 1)) return get_val(x * 2, pos);
		return get_val(x * 2 + 1, pos);
	}
	
	void erase(int x, int pos){
		if (tree[x].l == tree[x].r){
			tree[x].flag = true;
			return;
		}
		pushdown(x);
		if (pos <= ((tree[x].l + tree[x].r) >> 1)){
			erase(x * 2, pos);
		} else {
			erase(x * 2 + 1, pos);
		}
		update(x);
	}
	
	void add(int x, int l, int r, int k){
		if (l <= tree[x].l && tree[x].r <= r){
			tree[x].add += k;
			tree[x].pr.first += k;
			return;
		}
		int mid = (tree[x].l + tree[x].r) >> 1;
		pushdown(x);
		if (l <= mid) add(x * 2, l, r, k);
		if (r > mid) add(x * 2 + 1, l, r, k);
		update(x);
	}
}

namespace Tree3 {
	typedef struct {
		int l;
		int r;
		int add;
		int min1;
		int min2;
	} Node;
	
	Node tree[400007];
	
	inline void update(int x){
		int ls = x * 2, rs = x * 2 + 1;
		tree[x].min1 = min(tree[ls].min1, tree[rs].min1);
		tree[x].min2 = min(tree[ls].min2, tree[rs].min2);
	}
	
	void build(int x, int l, int r){
		tree[x].l = l;
		tree[x].r = r;
		if (l == r){
			tree[x].min1 = 0;
			tree[x].min2 = 0x7fffffff;
			return;
		}
		int mid = (l + r) >> 1;
		build(x * 2, l, mid);
		build(x * 2 + 1, mid + 1, r);
		update(x);
	}
	
	inline void pushdown(int x){
		if (tree[x].add != 0){
			int ls = x * 2, rs = x * 2 + 1;
			tree[ls].add += tree[x].add;
			tree[rs].add += tree[x].add;
			tree[ls].min1 += tree[x].add;
			tree[rs].min1 += tree[x].add;
			if (tree[ls].min2 != 0x7fffffff) tree[ls].min2 += tree[x].add;
			if (tree[rs].min2 != 0x7fffffff) tree[rs].min2 += tree[x].add;
			tree[x].add = 0;
		}
	}
	
	void flows(int x, int l, int r, int k){
		if (l <= tree[x].l && tree[x].r <= r && tree[x].min1 > 0){
			tree[x].add += k;
			tree[x].min1 += k;
			tree[x].min2 += k;
			return;
		}
		if (tree[x].l == tree[x].r){
			tree[x].min1 = tree[x].min2 = k;
			Tree2::add(1, 1, tree[x].l, -m[tree[x].l] - c[tree[x].l]);
			return;
		}
		int mid = (tree[x].l + tree[x].r) >> 1;
		pushdown(x);
		if (l <= mid) flows(x * 2, l, r, k);
		if (r > mid) flows(x * 2 + 1, l, r, k);
		update(x);
	}
	
	int get_min(int x, int l, int r){
		if (l <= tree[x].l && tree[x].r <= r) return tree[x].min2;
		int mid = (tree[x].l + tree[x].r) >> 1, ans = 0x7fffffff;
		pushdown(x);
		if (l <= mid) ans = get_min(x * 2, l, r);
		if (r > mid) ans = min(ans, get_min(x * 2 + 1, l, r));
		return ans;
	}
	
	void rollback(int x, int l, int r, int k){
		if (tree[x].min2 == 0x7fffffff) return;
		if (l <= tree[x].l && tree[x].r <= r && tree[x].min2 > k){
			tree[x].add -= k;
			tree[x].min1 -= k;
			tree[x].min2 -= k;
			return;
		}
		if (tree[x].l == tree[x].r){
			tree[x].min1 = 0;
			tree[x].min2 = 0x7fffffff;
			Tree2::add(1, 1, tree[x].l, m[tree[x].l] + c[tree[x].l]);
			return;
		}
		int mid = (tree[x].l + tree[x].r) >> 1;
		pushdown(x);
		if (l <= mid) rollback(x * 2, l, r, k);
		if (r > mid) rollback(x * 2 + 1, l, r, k);
		update(x);
	}
}

typedef struct Info_tag {
	int type;
	pair<int, int> pr;
	Info_tag(int type_, pair<int, int> pr_){
		type = type_;
		pr = pr_;
	}
} Info;

bool operator <(const Info a, const Info b){
	return a.pr.first < b.pr.first;
}

inline Info go_right(int pos, int n){
	pair<int, int> pr = Tree1::get_min(1, pos, n);
	if (pr.first == 0x7fffffff) return Info(1, make_pair(0x7fffffff, 0));
	return Info(1, make_pair(pr.first - sumc[pos - 1], pr.second));
}

inline Info go_left(int pos){
	if (pos == 1) return Info(2, make_pair(0x7fffffff, 0));
	pair<int, int> pr = Tree2::get_min(1, 1, pos - 1);
	if (pr.first == 0x7fffffff) return Info(2, make_pair(0x7fffffff, 0));
	return Info(2, make_pair(pr.first - Tree2::get_val(1, pos), pr.second));
}

int main(){
	int n;
	scanf("%d", &n);
	for (register int i = 1; i <= n; i++){
		scanf("%d", &d[i]);
	}
	for (register int i = 1; i <= n; i++){
		scanf("%d", &u[i]);
	}
	for (register int i = 1; i <= n; i++){
		scanf("%d", &p[i]);
	}
	for (register int i = 1; i < n; i++){
		scanf("%d", &m[i]);
	}
	for (register int i = 1; i < n; i++){
		scanf("%d", &c[i]);
	}
	if (n == 1){
		cout << d[1] * p[1];
		return 0;
	}
	ll ans = 0;
	for (register int i = n - 1; i >= 1; i--){
		summ[i] = summ[i + 1] + m[i];
	}
	for (register int i = 1; i < n; i++){
		sumc[i] = sumc[i - 1] + c[i];
	}
	Tree1::build(1, 1, n);
	Tree2::build(1, 1, n);
	Tree3::build(1, 1, n - 1);
	for (register int i = 1; i <= n; i++){
		while (d[i] > 0){
			int flow;
			Info info = min(go_right(i, n), go_left(i));
			if (info.type == 1){
				flow = min(d[i], u[info.pr.second]);
				if (i < info.pr.second) Tree3::flows(1, i, info.pr.second - 1, flow);
			} else {
				flow = min(d[i], min(u[info.pr.second], Tree3::get_min(1, info.pr.second, i - 1)));
				Tree3::rollback(1, info.pr.second, i - 1, flow);
			}
			d[i] -= flow;
			u[info.pr.second] -= flow;
			ans += (ll)flow * info.pr.first;
			if (u[info.pr.second] == 0){
				Tree1::erase(1, info.pr.second);
				Tree2::erase(1, info.pr.second);
			}
		}
	}
	cout << ans;
	return 0;
}
```

---


# 一径入繁华

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/68qtrpb7.png)

伴随龙年到来的，还有帆巨很喜欢的九省联考。为了爆踩压轴题。帆巨狠狠地重温了数论。

数论所生，繁华之地！

## 题目描述

帆巨觉得求 $x^a$ 在 $\bmod\ p$ 意义下的值太简单了，所以他想求 $\sigma_0^s(x^t)$ 在 $\bmod\ p$ 意义下的值。

帆帆不满足于只计算一次，于是他列了一个 $n\times n$ 的数表 $A$，保证第 $i$ 行第 $j$ 列（$1\le i,j\le n$）中的元素 $a_{i,j}$ 满足：

$$
a_{i,j}=\sum_{d\mid \gcd(i,j)}\mu\left(\dfrac{\gcd(i,j)}{d}\right)\times (\sigma_0(d^s))^t
$$

帆帆想知道这个数表长什么样子，但这个数表实在太大了，所以请你告诉他 $\det A$ 对 $10^9+7$ 取模后的结果。

注释：

1. 表达式中的各种函数含义在 **[这里](https://oi-wiki.org/math/number-theory/basic/#%E4%BE%8B%E5%AD%90)（$\mu$ 表示莫比乌斯函数，$\sigma_0$ 表示约数个数函数）**。
2. $\det A$ 表示方阵 $A$ 的 **[行列式](https://baike.baidu.com/item/%E8%A1%8C%E5%88%97%E5%BC%8F/2010180)**。

## 说明/提示

### 【样例 $1$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 &3
\end{bmatrix}
$$

行列式为 $1\times 3 - 1\times 1=2$。

### 【样例 $2$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 & 255
\end{bmatrix}
$$

行列式为 $1\times 255 - 1 \times 1=254$。

### 数据范围

本题采用 **子任务捆绑测试**。

对于 $100\%$ 的数据，保证 $1\le n\le 10^{11}$，$0\le s,t< 10^9+7$。


| 子任务编号  |      $n$      | 特殊性质  | 分值 |
| :---------: | :-----------: | :-------: | :--: |
| Subtask #1  |   $\le 500$   |    无     | $8$  |
| Subtask #2  |  $\le 10^7$   | $s=1,t=2$ | $5$  |
| Subtask #3  |  $\le 10^7$   |   $s=1$   | $10$ |
| Subtask #4  | $\le 10^{11}$ | $s=1,t=2$ | $10$ |
| Subtask #5  | $\le 10^{11}$ |   $s=1$   | $10$ |
| Subtask #6  | $\le 10^{11}$ |   $t=1$   | $2$  |
| Subtask #7  | $\le 10^{7}$  | $t\le 9$  | $10$ |
| Subtask #8  | $\le 10^{11}$ | $t\le 9$  | $15$ |
| Subtask #9  |  $\le 10^7$   |    无     | $10$ |
| Subtask #10 | $\le 10^{11}$ |    无     | $20$ |

**特殊性质** 一栏为空则表示没有特殊性质。子任务中没有规定范围的变量的值均在 $[0,10^9+7)$ 范围内生成。

时间限制：$\text{2000 ms}$；

空间限制：$\text{512 MB}$。

## 样例 #1

### 输入

```
2 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 4```

### 输出

```
254```

## 样例 #3

### 输入

```
19 8 10```

### 输出

```
913255725```

## 样例 #4

### 输入

```
10000000000 1 2```

### 输出

```
880793261```

# 题解

## 作者：云浅知处 (赞：12)

对于 $n=\prod p_i^{c_i}$，有：
$$
\sigma_0^t(n^s)=\prod(1+s\times c_i)^{t}
$$
然后设：
$$
f(n)=\sum_{d\mid n} \mu\left(\dfrac{n}{d}\right)\sigma_0^t(n^s)
$$
所以有：
$$
\sigma_0^t(n^s)=\sum_{d\mid n}f(d)
$$
由于 $\sigma_0^t$ 是积性函数，不妨先假设 $n=p^c$。则：
$$
\sigma_0^t(p^{cs})=\sum_{i=0}^{c}f(p^i)
$$
也就是说对于 $n=p^c$，$f(p^c)$ 是 $\sigma_0^t$ 关于 $c$ 的高维差分。

类似的，设：
$$
f(n)=\sum_{d\mid n} g(d)
$$
那个 $g$ 是 $f$ 关于 $c$ 的差分，即 $g$ 是 $\sigma_0^t$ 的二阶高维差分。具体地就有：
$$
g(p^c)=(1+c_is)^t-[c_i\ge 1]2(1+(c_i-1)s)^t+[c_i\ge 2] (1+(c_i-2)s)^t
$$
那么 $g$ 是积性函数，就有：
$$
g(n)=\prod((1+c_is)^t-[c_i\ge 1]2(1+(c_i-1)s)^t+[c_i\ge 2] (1+(c_i-2)s)^t)
$$
矩阵可以拆成：
$$
\begin{aligned}
a_{i,j}&=\sum_{d\mid \gcd(i,j)}g(d)=\sum_{d=1}^{n}[d\mid i][d\mid j]g(d)\\\\
b_{i,j}&=[j\mid i]g(j)\\\\
c_{i,j}&=[i\mid j]\\\\
A&=B*C
\end{aligned}
$$
$*$ 是矩阵乘法。$B,C$ 都是上、下三角矩阵，于是 

- $\text{det}(B)=\prod_{i=1}^n b_{i,i}=\prod_{i=1}^ng(i)$
- $\text{det}(C)=\prod_{i=1}^nc_{i,i}=1$

故答案为：
$$
\det(A)=\text{det} (B)\times \det(C)=\prod_{m=1}^{n}\prod((1+c_is)^t-[c_i\ge 1]2(1+(c_i-1)s)^t+[c_i\ge 2] (1+(c_i-2)s)^t)
$$
依次考虑每个质数的贡献。

对于 $p\le \sqrt{n}$ 的部分暴力枚举 $p$ 和 $c$，暴力求快速幂，复杂度 $\mathcal{O}(\sqrt{n}\log t)$。

对于 $p>\sqrt{n}$，可知 $c\le 1$，当 $c=0$ 时贡献为 $1$ 不用考虑，当 $c=1$ 时 $g(p)=(1+s)^t-2$，故只需要筛素数个数即可，在本题范围内，使用 min25 筛即可。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

const int mod=1e9+7;
int ksm(int x,ll y,int p=mod){
	int ans=1;y%=(p-1);
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
void Mod(int &x){if(x>=mod)x-=mod;}
int cmod(int x){if(x>=mod)x-=mod;return x;}

const int N=1e6+5;
const int B=320000;
ll n;
int cp,pri[N],s,t;
bool vis[N];
void Euler(int V){
	for(int i=2;i<=V;i++){
		if(!vis[i])pri[++cp]=i;
		for(int j=1;j<=cp&&pri[j]*i<=V;j++){
			vis[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
}
ll f[N<<1],num[N<<1];
int id1[N],id2[N];
int getid(ll x){
	if(x>B)return id2[n/x];
	return id1[x];
}
void calcpri(){
	Euler(B);
	int ncnt=0;
	for(ll l=1,r=0;l<=n;l=r+1){
		ll val=(n/l);
		if(val<=B)num[id1[val]=++ncnt]=val;
		else num[id2[n/val]=++ncnt]=val;
		r=n/(n/l);r=min(r,n);
	}
	for(int i=1;i<=ncnt;i++)f[i]=num[i]-1;
	for(int i=1;i<=cp;i++){
		for(int j=1;j<=ncnt&&num[j]>=1ll*pri[i]*pri[i];j++){
			int k=getid(num[j]/pri[i]);
			f[j]-=f[k]-(i-1);
		}
	}
}

int g[100];
void solve(){
	cin>>n>>s>>t;
	if(s==0)return puts(n==1?"1":"0"),void();

	int ans=1;calcpri();
	g[1]=cmod(ksm(s+1,t)+mod-2);
	for(int i=2;i<=40;i++){
		add(g[i],ksm(1ll*i*s%mod+1,t));
		add(g[i],mod-2ll*ksm(1ll*(i-1)*s%mod+1,t)%mod);
		add(g[i],ksm(1ll*(i-2)*s%mod+1,t));
	}
	int lim=n/B;
	for(int i=1;i<=cp&&n/pri[i]>lim;i++){
		ll val=pri[i];int k=1;
		while(val<=n){
			ll cc=n/val-n/(val*pri[i]);
			ans=1ll*ans*ksm(g[k],cc)%mod,val*=pri[i],k++;
		}
	}
	ll cc=0;
	// floor(n/p) >= i <==> i*p <= n <==> p <= floor(n/i)
	// floor(n/p) == i <==> floor(n/(i+1)) < p <= floor(n/i)
	for(int i=1;i<=lim;i++){ // floor(n/p) = i
		ll cnt=f[getid(n/i)]-f[getid(n/(i+1))];
		cc+=1ll*i*cnt;
	}
	ans=1ll*ans*ksm(g[1],cc)%mod;
	cout<<ans<<endl;
}

signed main(void){

	solve();

	return 0;
}
```

---

## 作者：NaCly_Fish (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P10182)

拜谢传奇 OIer Karry5307！

****
看到这个题，第一反应就想到了 [『MdOI R2』Quo Vadis](https://www.luogu.com.cn/problem/P6384) 以及 [Find The Determinant II](https://www.luogu.com.cn/problem/SP1772)。可以看到卡老师给出了详细的资料。

设
$$f(n)=\sum_{d|n}\mu\left( \frac nd\right)\sigma_0(d^s)^t$$
根据前面两题结论的证明方法，我们可以直接得到行列式消元成上三角矩阵后，对角线位置是：
$$g(n)=\sum_{d|n}\mu\left( \frac nd\right)f(d)$$
显然 $g(n)$ 是积性函数。设 $a_k=(ks+1)^t$，则 $g(p^k)=b_k=a_k-2a_{k-1}+a_{k-2}$。最终答案就是

$$\prod_{i=1}^ng(i)$$
线性筛一下，就可以做到 $\Theta(n)$ 的时间复杂度。

****

要优化的话，考虑到 $g(p^k)$ 的值只与 $k$ 有关，所以我们可以统计 $b_k$ 被乘了多少次。设 $b_k$ 的幂次为 $t_k$，可以得到
$$\sum_{i \geq k}t_i=\sum_{p^k\leq n}\left\lfloor \frac{n}{p^k}\right\rfloor$$
等式右边计算的是：对所有 $p$ 求「$n$ 以内有多少数是 $p^k$ 的整数倍」的和。同时它也表示 $n$ 以内所有数「幂次至少为 $k$ 的质因子数量」之和。

设等式右边为 $c_k$，$k$ 有一个显然的上界是 $\lfloor \log_2 n \rfloor$，$k$ 大于这个值时 $c_k$ 必然是 $0$。而对于 $k\geq 2$，整个和式中的项不超过 $\sqrt[k]{n}$ 个，可以筛出前 $\sqrt n$ 个质数后暴力计算。这部分的复杂度不超过 $\sqrt n \log n$。

最后就是要计算 $c_1$，对于 $p\leq \sqrt n$ 的那部分还是可以暴力，而对于 $p>\sqrt n$ 时可以使用整除分块 + [数区间质数](https://loj.ac/p/6235)来处理。即对于 $\lfloor n/l\rfloor = \lfloor n/r \rfloor$ 的一段区间 $[l,r]$，对 $c_1$ 的贡献为 $\lfloor n/l \rfloor (\pi(r)-\pi(l-1))$。

最后答案就是
$$\prod_{k=1}^{\lfloor \log_2 n \rfloor}b_k^{c_k-c_{k+1}}$$
总复杂度取决于数区间质数的那部分，我也不知道现在最优的复杂度是多少，就不写了。

贴一份参考代码（solver 中是从 LOJ 抄的板子，可以不看），除去板子其实很短：   
由于未知原因代码中取 $m=\sqrt n$ 会 TLE，把暴力算的部分调大一些才能通过。
```cpp
#include <cstdio>
#include <vector>
#include <cmath>
#include <unordered_map>
using namespace std;

namespace solver{
    using i64 = long long;
    #define isqrt __builtin_sqrtl

    unordered_map<i64,i64> mpf;
    inline bool primeQ(i64 x){
        for(int i=2;i*i<=x;++i){
            if(x%i==0) return false;
        }
        return true;
    }

    vector<int> smalls(500007);
    vector<int> roughs(500007);
    vector<i64> larges(500007);

    i64 prime_pi(const i64 N) {
        if (N <= 1)
            return 0;

        if (N == 2)
            return 1;
        if(mpf[N]) return mpf[N];
        int v = isqrt(N);
        int s = (v + 1) >> 1;
        for (int i = 1; i ^ s; ++i) smalls[i] = i;
        for (int i = 0; i ^ s; ++i) roughs[i] = 2 * i + 1;
        for (int i = 0; i ^ s; ++i) larges[i] = (N / (2 * i + 1) - 1) >> 1;

        vector<bool> skip(v + 1);
        constexpr auto divide = [](i64 n, i64 d) -> int { return double(n) / d; };
        constexpr auto half = [](int n) -> int { return (n - 1) >> 1; };
        int pc = 0;

        for (int p = 3; p <= v; p += 2)
            if (!skip[p]) {
                int q = p * p;

                if (i64(q) * q > N)
                    break;

                skip[p] = true;

                for (int i = q; i <= v; i += 2 * p)
                    skip[i] = true;

                int ns = 0;

                for (int k = 0; k ^ s; ++k) {
                    int i = roughs[k];

                    if (skip[i])
                        continue;

                    i64 d = i64(i) * p;
                    larges[ns] = larges[k] - (d <= v ? larges[smalls[d >> 1] - pc] : smalls[half(divide(N, d))]) + pc;
                    roughs[ns++] = i;
                }

                s = ns;

                for (int i = half(v), j = ((v / p) - 1) | 1; j >= p; j -= 2) {
                    int c = smalls[j >> 1] - pc;

                    for (int e = (j * p) >> 1; i >= e; --i)
                        smalls[i] -= c;
                }

                ++pc;
            }

        larges[0] += i64(s + 2 * (pc - 1)) * (s - 1) / 2;

        for (int k = 1; k ^ s; ++k)
            larges[0] -= larges[k];

        for (int l = 1; l ^ s; ++l) {
            int q = roughs[l];
            i64 M = N / q;
            int e = smalls[half(M / q)] - pc;

            if (e < l + 1)
                break;

            i64 t = 0;

            for (int k = l + 1; k <= e; ++k)
                t += smalls[half(divide(M, roughs[k]))];

            larges[0] += t - i64(e - l) * (pc + l - 1);
        }
        mpf[N] = larges[0] + 1;
        return larges[0] + 1;
    }
};

#define ll long long

inline ll llpow(ll a,int t){
    ll res = 1;
    while(t){
        if(t&1) res *= a;
        a *= a;
        t >>= 1;
    }
    return res;
}

#define N 20000007
#define p 1000000007

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int pr[N];
bool vis[N];
int cnt;

void sieve(int n){
    for(int i=2;i<=n;++i){
        if(!vis[i]) pr[++cnt] = i;
        for(int j=1;j<=cnt&&i*pr[j]<=n;++j){
            vis[i*pr[j]] = true;
            if(i%pr[j]==0) break;
        }
    }
}

ll n;
int s,t,ans = 1;
int fk[N],a[N],gp[N];

int main(){
    scanf("%lld%d%d",&n,&s,&t);
    sieve(20000000);
    fk[0] = 1;
    for(int i=1;i<=45;++i) fk[i] = power((ll)i*s%p+1,t);
    a[1] = fk[1]-2;
    for(int i=2;i<=45;++i) a[i] = (fk[i]-2ll*fk[i-1]+fk[i-2])%p;
    for(int k=2;k<=45;++k)
    for(int i=1;;++i){
        ll pw = llpow(pr[i],k);
        if(pw>n) break;
        gp[k] = (gp[k]+n/pw)%(p-1);
    }
    int m = max((int)sqrt(n),19500000);
    for(int i=1;pr[i]<=m&&pr[i]<=n;++i) gp[1] = (gp[1]+n/pr[i])%(p-1);
    for(ll l=m+1,r;l<=n;l=r+1){
        r = n/(n/l);
        gp[1] = (gp[1] + (n/l)%(p-1)*(solver::prime_pi(r)-solver::prime_pi(l-1)))%(p-1);
    }
    for(int i=1;i<=45;++i) gp[i] = (gp[i]-gp[i+1]+p-1)%(p-1);
    for(int i=1;i<=45;++i) ans = (ll)ans*power(a[i],gp[i])%p;
    printf("%d",(ans+p)%p);
}
```


---

## 作者：Argon_Cube (赞：2)

省流：SP1772+SP22549。

首先若 $a_{i,j}=f(\gcd(a,b))$ 那么 $\det A=\prod_{i=1}^n(f*\mu)(i)$。证明见 P6384 或 SP1772 的题解。

然后我们发现令 $g(n)=(d(n^s))^t$ 为积性函数，题目里面给的 $f=\mu* g$。于是我们要求一个积性函数前缀积，那么就像求和性函数前缀和一样，对于每个 $f(p^k)$ 计算其贡献，$p\leq \sqrt n $ 时暴力枚举，否则像 SP22459 一样数论分块，容易用 Min_25 筛出每一块中的质数个数。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <bitset>
#include <string>
#include <array>
#include <cmath>

using namespace std;

long long fast_pow(long long base,long long exp,long long moder)
{
    long long result;
    for(result=1;exp;exp&1?result=result*base%moder:true,base=base*base%moder,exp>>=1);
    return result;
}
inline long long inverse(long long num,long long prime)
{
    return fast_pow(num,prime-2,prime);
}

constexpr long long         moder=1e9+7,maxv=1e11,sqrtv=4e5;
array<long long,2*sqrtv+1>  DParr,blkpos;
array<long long,sqrtv+1>    cntmpf,nmpf,d,primes;
array<long long,60>         powkis;
bitset<sqrtv+1>             isprime;
long long                   n,blksz;
int                         divline;

inline int loc_idx(long long idx)
{
	return idx>blksz?n/idx:blksz-idx+divline;
}
inline long long mu2d(int k)
{
    long long result=powkis[k];
    if(k)
        result-=2*powkis[k-1];
    if(k>1)
        result+=powkis[k-2];
    return (result+2*moder)%moder;
}

int main(int argc,char* argv[],char* envp[])
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    long long s,answer=1,t;
    cin>>n>>s>>t;
    int cntp=0,cntb=0;
    blksz=sqrt(n);
    for(int i=0;i<60;i++)
        powkis[i]=fast_pow(i*s%moder+1,t,moder);
    nmpf[1]=d[1]=1;
    for(int i=2;i<=blksz;i++)
    {
        if(!isprime[i])
            primes[++cntp]=i,d[i]=mu2d(1),cntmpf[i]=1,nmpf[i]=1;
        for(int j=1;j<=cntp&&i*primes[j]<=blksz;j++)
        {
            int a=i*primes[j];
            isprime.set(a);
            if(!(i%primes[j]))
            {
                cntmpf[a]=cntmpf[i]+1,nmpf[a]=nmpf[i];
                break;
            }
            cntmpf[a]=1,nmpf[a]=i;
        }
        d[i]=d[nmpf[i]]*mu2d(cntmpf[i])%moder;
    }
	for(long long i=1,j;i<=n;i=n/j+1)
	{
		++cntb,DParr[cntb]=(j=blkpos[cntb]=n/i)-1;
		if(!divline&&j<=blksz)
			divline=cntb;
	}
    // cerr<<DParr[1];
    for(int i=1;i<=cntp;i++)
    {
        // cerr<<i<<'\n';
        for(int j=1;1ll*primes[i]*primes[i]<=blkpos[j];j++)
            DParr[j]=DParr[j]-DParr[loc_idx(blkpos[j]/primes[i])]+i-1;
        for(long long j=n/primes[i],k=1;j;k++,j/=primes[i])
            answer=answer*fast_pow(mu2d(k),j-j/primes[i],moder)%moder;
    }
    long long cnt1=0;
    for(int i=1;n/i>blksz;++i)
		cnt1+=i*(DParr[i]-(n/(i+1)>blksz?DParr[i+1]:cntp));
    cout<<answer*fast_pow(mu2d(1),cnt1,moder)%moder<<'\n';
    return 0;
}
```

---

## 作者：Prean (赞：2)

唐完了。不懂都 4202 年了怎么还有这种唐题。

来踩一下标算。

行列式求值直接消元然后对角线相乘就完了
$$f(p^k)=(ks+1)^t$$
$$a_{i,j}=(\mu*f)(\gcd(i,j))$$
有：
$$\sum_{k=1}^{\infty}b_{i,k}\times a_{k,j}=c_{i,j}$$
众所周知这个矩阵乘法的过程是类似反演的，考虑素数行的结果我们有：
$$c_{p,x}=a_{p,x}-1$$
$$c_{p,x}=[p\mid x]((\mu*f)(p)-1)$$
接着考虑 $pq$ 行的结果有：
$$c_{pq,x}=a_{pq,x}-a_{p,x}-a_{q,x}+1$$
$$c_{pq,x}=[pq\mid x](\mu*\mu*f)(pq)$$
接着考虑 $p^k$ 行的结果有：
$$c_{p^2,x}=a_{p^2,x}-a_{p,x}$$
$$c_{p^3,x}=a_{p^3,x}-a_{p^2,x}$$
$$c_{p^k,x}=[p^k\mid x](\mu*\mu*f)(p^k)$$
于是我们大胆猜测结果矩阵为 $c_{i,j}=[i\mid j](\mu*\mu*f)(i)$。跑一遍暴力是对的。

设 $g=\mu*\mu*f$ 那么答案就是：
$$\prod_{i=1}^ng(i)$$
$$\prod_{p^k\leq n}g(p^k)^{\sum_{x=1}^{\lfloor\frac{n}{p^k}\rfloor}[\gcd(i,p)=1]}$$
$$\prod_{p\leq\sqrt n\And p^k\leq n}g(p^k)^{\lfloor\frac{n}{p^{k}}\rfloor-\lfloor\frac{n}{p^{k+1}}\rfloor}\times\prod_{\sqrt n\leq p\leq n}g(p)^{\lfloor\frac{n}{p}\rfloor}$$
$$\prod_{p\leq\sqrt n\And p^k\leq n}g(p^k)^{\lfloor\frac{n}{p^{k}}\rfloor-\lfloor\frac{n}{p^{k+1}}\rfloor}\times((s+1)^t-2)^{\sum_{\sqrt n\leq p\leq n}\lfloor\frac{n}{p}\rfloor}$$
因此需要获取质数个数的块筛。这一部分复杂度 $O(\sqrt n+\log n)$。

如果最后算的是积性函数前缀和那我觉得出题人至少会筛子，但是只需要统计质数个数是不是有点太 ez 了。

不懂，怎么那么多人比我跑得慢。
```cpp
ll n;
int ans=1,B,s,t,cnt,len=1,g[50];ll F[M],G[M];
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int Del(const int&a,const int&b){
	return b>a?a-b+mod:a-b;
}
inline ll divide(const ll&n,const ll&m){
	return double(n)/m;
}
inline int pow(int a,int b){
	int ans(1);for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;
}
signed main(){
	int sqr;scanf("%lld%d%d",&n,&s,&t);B=sqrt(n);sqr=sqrt(B);
	while((1ll<<len)<=n)g[len]=pow((1ll*s*len+1)%mod,t),++len;g[0]=1;--len;
	for(int k=len;k>=1;--k)g[k]=Del(g[k],g[k-1]);for(int k=len;k>=1;--k)g[k]=Del(g[k],g[k-1]);
	for(int i=1;i<=B;++i)F[i]=divide(n,i)-1,G[i]=i-1;
	for(int i=1;i<=sqr;++i)if(G[i]!=G[i-1]){
		const int p=i,lim=divide(B,i);ll pk=p; 
		for(int k=1;pk<=n;pk*=p,++k)ans=1ll*ans*pow(g[k],(divide(n,pk)-divide(n,pk*p))%MOD)%mod;
		for(int k=1;k<=lim;++k)F[k]-=F[k*p]-cnt;for(int k=lim+1;k<=B;++k)F[k]-=G[divide(n,k*p)]-cnt;
		for(int k=B,e=divide(B,p);e>=p;--e)for(int x=e*p,V=G[e]-cnt;k>=x;--k)G[k]-=V;++cnt;
	}
	for(int i=sqr+1;i<=B;++i)if(G[i]!=G[i-1]){
		const int p=i,lim=divide(B,p),T=divide(n,1ll*p*p);ll pk=p;
		for(int k=1;pk<=n;pk*=p,++k)ans=1ll*ans*pow(g[k],(divide(n,pk)-divide(n,pk*p))%MOD)%mod;
		for(int k=1;k<=lim;++k)F[k]-=F[k*p]-cnt;for(int k=lim+1;k<=T;++k)F[k]-=G[divide(n,k*p)]-cnt;++cnt;
	}
	ll sum(0);for(int i=1;i<=B;++i)sum+=F[i];sum-=B*G[B];
	printf("%d",1ll*ans*pow(g[1],sum%MOD)%mod);
}
```

---

## 作者：可爱的小棉羊 (赞：1)

非常有意(du)思(liu)的一道题。

### 题目描述

有一个 $n \times n$ 的矩阵 $a$，满足：

$$
a_{i,j}=\sum_{d\mid \gcd(i,j)}\mu\left(\dfrac{\gcd(i,j)}{d}\right)\times (\sigma_0^t(d^s))
$$

求这个矩阵的行列式。

### Step 1 转化问题

$n \le 10^{11}$ 无论如何，我们都不可以直接计算行列式。要求的行列式肯定要转化为一个式子然后用杜教，min25，莫反之类的算法来做。

众所周知：

$$
\sigma_0(p^c)=1+c
$$

我们令 $h(i)=\sigma_0^t(i^s)$，那么：

$$
h(p^c)=(1+cs)^t
$$

又令 $f$ 为 $\mu$ 和 $h$ 的狄利克雷卷积，那么：

$$
h(n)=\sum_{d\mid n}f(d)
$$

$$
\begin{aligned}h(p^c)&=\sum_{d\mid p^c}f(i)\\&=\sum_{i=0}^c f(p^i)
\end{aligned}
$$

我们因此可以得到：

$$
f(p^c)=h(p^c)-h(p^{c-1})
$$

那我们再令：

$$
f(n)=\sum_{d\mid n}g(d)
$$

同理我们可以得到：

$$
g(p^c)=f(p^c)-f(p^{c-1})
$$

那我们再把上面一个式子待回去：

$$
g(p^c)=h(p^c)-2h(p^{c-1})+h(p^{c-2})
$$

所以：

$$
g(p^c)=(1+cs)^t-2(1+(c-1)s)^t+(1+(c-2)s)^t
$$

特别地，$c=1$ 时有：

$$
g(p)=(1+s)^t-2
$$

这时我们来看看原来那个式子：

$$
\begin{aligned}
a_{i,j}&=\sum_{d \mid \gcd(i,j)}\mu(\frac{\gcd(i,j)}{d}) \times \sigma^{t}_0(d^s)
\\&=f(\gcd(i,j))
\\&=\sum_{d\mid \gcd{i,j}}g(d)

\end{aligned}
$$

我们令矩阵 $B$ ，$C$：

$$
B_{i,j}=[j \mid i]g(j)
$$

$$
C_{i,j}=[i \mid j]
$$

那么我们得到：

$$
\begin{aligned}
(B \times C)_{i,j}&=\sum_{k=1}^n B_{i,k}\times C_{k,j}
\\&=\sum_{k=1}^{n} [k \mid i][k \mid j]g(k)
\\&=\sum_{k \mid \gcd(i,j)}g(k)
\\&=a_{i,j}
\end{aligned}
$$

所以 $a=B \times C$

又 $B$，$C$ 为两个三角矩阵

$$
det(B)=\prod_{i=1}^n B_{i,i}=\prod^{n}_{i=1}g(i)
$$

$$
det(c)=\prod_{i=1}^n C_{i,i}=1
$$

那么：

$$
det(a)=det(B)\times det(C)=\prod_{i=1}^n g(i)
$$

### Step 2 计算式子

如果我们直接线性筛（注意：$g$ 是一个积性函数），时间复杂度是 $O(n)$ 的那该如何优化呢？

明显对于 $g$ 只对指数有关。

（为表示方便，令 $g(p^c)$ 为 $g_c$，我们只需预处理到 $g_{40}$（$\log_2 n$ 级别） 左右就行）

我们可以计算每个 $p^c$ 在 $1$ 至 $n$ 里有多少个数的有且恰有 $p^c$ 这个因子，有多少个就乘多少个 $g_c$

可要筛质数还是得寄。

这时发挥 min25筛的思想。

对于 $ p \le \sqrt{n}$ 的直接用上面那种方法。

对于$ p > \sqrt{n}$ 的质数，存在 $c =1$ ，所以 $p$ 的贡献为 $g_1^{\lfloor \frac{n}{p}\rfloor}$。

总所周知，形如$\lfloor \frac{n}{x} \rfloor$ 的数的个数只有 $O(\sqrt{n})$ 级别，那我们可以算每个 $\lfloor \frac{n}{x} \rfloor$ 相等的块里有多少个质数。可以计算了。

### Step 3 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
long long prime[400005],cnt;
long long n,sqr,tot,w[800005],g[800005],ind1[400005],ind2[400005],s,t,g_po[45];
bool vis[400005];
long long fpow(long long a,long long b){
	long long ans=1;
	b%=(mod-1);
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
void init(){
	vis[1]=1;
	for(int i=2;i<=sqr;i++){
		if(!vis[i])prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=sqr;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
	long long l=1;
	while(l<=n){
		long long r=(n/(n/l));
		r=min(r,n);
		tot++;
		w[tot]=n/l;
		g[tot]=(n/l-1);
		if(n/l<=sqr)ind1[n/l]=tot;
		else ind2[n/(n/l)]=tot;
		l=r+1;
	}
	
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=tot&&prime[i]*prime[i]<=w[j];j++){
			int k=w[j]/prime[i]<=sqr? ind1[w[j]/prime[i]]:ind2[n/(w[j]/prime[i])];
			g[j]=(g[j]-(g[k]-(i-1)));
		}
	}
}
long long ans=1;
int getid(long long x){
	if(x<=sqr)return ind1[x];
	return ind2[n/x];
}
int main(){
	cin>>n>>s>>t;
	if(s==0){
		if(n==1)cout<<1<<endl;
		else cout<<0<<endl;
		return 0;
	}
	sqr=ceil(sqrt(n));
	init();//min25筛
	g_po[1]=(fpow(1+s,t)+mod-2)%mod;
	for(int i=2;i<=40;i++){
		g_po[i]=(fpow(1+i*s%mod,t)%mod-2*fpow(1+(i-1)*s%mod,t)%mod+fpow(1+(i-2)*s%mod,t)%mod+2*mod)%mod;
	}
	for(int i=1;i<=cnt&&n/prime[i]>n/sqr;i++){
		long long pe=prime[i];
		for(int e=1;pe<=n;pe*=prime[i],e++){
			ans=ans*fpow(g_po[e],(n/pe-n/(pe*prime[i])))%mod;
			
		}
	}
	long long po=0;
	for(int i=1;i<=n/sqr;i++){
		long long cnt=g[getid(n/i)]-g[getid(n/(i+1))];
		po+=1ll*i*cnt;
	}
	ans=ans*fpow(g_po[1],po)%mod;
	cout<<ans<<endl;
	
} 
```

---


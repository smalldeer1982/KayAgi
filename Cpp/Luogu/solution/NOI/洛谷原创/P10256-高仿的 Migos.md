# 高仿的 Migos

## 题目描述

经过刻苦的训练，ZHY 终于成为了一名说唱歌手。但这天，说唱歌手 ZHY 看到了同行说唱组合 Migos 的作品，立刻意识到了自己的差距，于是他要学习 Migos 的说唱技巧，复刻 Migos 的成功。

经过数个日夜的研究，ZHY 最终挑选出了 $n$ 部 Migos 的说唱作品，依次编号为 $1,2,\dots,n$。他认为只要学习完这 $n$ 部作品，就可以成为更加优秀的说唱歌手。于是，他会从第 $1$ 部作品，按编号从小到大的顺序依次进行学习，学习完第 $n$ 部作品就结束学习。

不过，说唱歌手 ZHY 的学习方式很特殊。对于每部作品，他只会听 $1$ 分钟。这种学习方式的问题是，对于第 $i$ 部作品，他在投入 $1$ 分钟后，有可能学习成功，也有可能会失败，具体地，如果 ZHY 学习的是作品 $i$，那么在他花一分钟的时间进行学习后：

- 有 $P_i$ 的概率，ZHY 学习成功了，那么他会接着去学习作品 $i+1$（当然如果 $i=n$ 就直接结束学习）。
- 有 $1-P_i$ 的概率，ZHY 学习失败了。不幸的是，ZHY 脑内的记忆还会因此产生混乱，导致他只会记住前 $x_i$ 部作品，即他必须从第 $x_i+1$ 部作品开始重新学习。

ZHY 在尝试了几次学习后，深受记忆混乱的困扰，于是向脑科学专家 YHZ 求助。经过脑科学专家 YHZ 的研究，他发现所有的 $x_i$ 有一定的规律。具体地，他发现有 $m$ 对自然数 $(l_i,r_i)$, 其中 $i=1,2\dots,m$，满足 $0\leq l_i<r_i\leq n$，那么 $x_i=\max\limits_{j=1}^m\{l_j
\mid l_j+1\leq i\leq r_j\}$，特别地，如果对于所有 $1\leq j\leq m$，都**不满足** $l_j+1\leq i\leq r_j$，那么 $x_i=0$。

现在，ZHY 对自己的学习能力有了充分了解，但刚才的尝试让他疲惫不堪，所以他决定休息 $1$ 秒，并希望你帮他计算一下他期望多少分钟可以结束学习。不过他意识到，自己如果每部作品只学固定的 $1$ 分钟是不够全面的，所以他决定更改一些作品他所会学习的那一分钟，这会导致他学习这一部作品的成功概率发生改变。具体地，现在 ZHY 提出了 $k$ 个要求，每个要求有两种可能：

1. 修改某个作品 $i$ 学习成功的概率 $P_i$。
1. 询问以当前的概率他学习完 $n$ 部作品期望要多少分钟。

由于 ZHY 要休息，所以他找上了你，希望你来解决他的要求。对于他的每个第二种要求，你要告诉他期望时间对 $10^9+7$ 取模的结果。ZHY 给了你 $1$ 秒的时间，因为他只能休息这么久。

## 说明/提示

**本题使用捆绑测试。**

| Subtask 编号 | $n$ | $m$ | $k$ | 特殊性质 |分值 |
| :-----: | :-----: | :-----: | :-----: | :-----: | :-----: |
| $0$ | $\le 300$ | $\le 300$ | $\le 300$ | 无 | $11$ |
| $1$ | $\le 3000$ | $\le 3000$ | $\le 3000$ | 无 | $4$ |
| $2$ | $\le 10^5$ | $\le 10^5$ | $\le 1$ | B | $5$ |
| $3$ | $\le 10^5$ | $\le 10^5$ | $\le 1$ | 无 | $14$ |
| $4$ | $\le 10^5$ | $=0$ | $\le 10^5$ | 无 | $19$ |
| $5$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | A | $19$ |
| $6$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | B | $8$ |
| $7$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | C | $10$ |
| $8$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | 无 | $10$ |

以下的“区间”均指 $[l_i,r_i]$。

特殊性质 A：保证对于 $\forall i \in [1,m]$，$r_i-l_i+1\le 5$。

特殊性质 B：保证这些区间两两的交 $\le 1$。即对于 $\forall i,j \in [1,m]$ 且 $i\ne j$，有 $r_i\le l_j$ 或 $r_j\le l_i$。

特殊性质 C：保证这些区间不存在包含关系。即对于 $\forall i,j \in [1,m]$ 且 $i\ne j$，有 $l_i>l_j$ 或 $r_i<r_j$。

对于 $100\%$ 的数据，$1 \le n,k \le 10^5$，$0 \le m \le 10^5$，$1 \le p_{i} \le q_{i} \lt 10^{9}+7$，$0 \le l_{i} \lt r_{i} \le n$。

## 样例 #1

### 输入

```
3 1 3
1 3
2 3
1 4
2 3
2
1 2 4 5
2```

### 输出

```
10
9```

## 样例 #2

### 输入

```
2 1 1
1 1
1 2
0 2
2```

### 输出

```
4```

## 样例 #3

### 输入

```
2 1 1
1 1
1 2
1 2
2```

### 输出

```
3```

# 题解

## 作者：2022tysc0776 (赞：4)

我觉得还是很难的，但我很菜，没有发言权（

本篇题解借鉴了别的题解并融合了自己的心得。

设 $i$ 失败后从 $L_i$ 开始学习，$f_i$ 则表示从 $i$ 跳到 $i+1$ 的期望时间。

有两种情况：

1. $P_i$ 的概率，成功转移了，对期望的贡献为 $P_i$。

2. $1-P_i$ 的概率，转移失败，则从 $L_i$ 到 $i$ 都要成功转移，$i$ 才能成功转移，则贡献为 $(1-P_i)(1+\sum_{L_i \le j \le i} f_j)$。（加 $1$ 是因为转移失败也要花时间）。

$$
f_i=P_i+(1-P_i)(1+\sum_{L_i \le j \le i} f_j)
$$

转移不了，开始展开。

$$
f_i=P_i+1-P_i+(1-P_i)\sum_{L_i \le j \le i} f_j\\
f_i-(1-P_i)f_i=1+(1-P_i)\sum_{L_i \le j <i} f_j\\
f_i=\frac{1}{P_i}+\frac{1-P_i}{P_i}\sum_{L_i\le j<i} f_j
$$

然后直接 $O(n)$ 递推即可，至于 $L_i$ 的求法，用扫描线可以，用线段树也行，主播用的线段树，切记一定要下传 tag（不要问我怎么知道的 doge

然后通过观察，关于本题有一个有趣的性质：

把 $[L_i,i]$ 看成一个区间，所有区间要么不交，要么包含。

即不会出现：$L_x<L_y<x<y$

证明很显然 $L_y>L_x$ 且 $y>x$ ，所以理论上来说，$L_x$ 应该等于 $L_y$。

那我们就有一个大胆的想法，按照区间的包含关系建树，上面式子中的 $\sum_{L_i\le j<i} f_j$ 就是 $i$ 子树中**不包含 $i$ 点**的**子树和**。

建树方法可以用栈，也可以直接递归建树。递归建树的好处是可以在建树时就直接处理一些信息。

```cpp
for(int i=x-1;i>=L[x];i=L[i]-1){
		ed[x].push_back(i);
		solve(i);
    //这里处理信息
}
```
注：有人可能会问，主播主播，有可能会出现 $L_y<y=L_x<x$ 的情况呀？

解答：是的，但是我们发现事实上，一个点连接的边的范围是 $[L_x,x-1]$，那么结合上述的证明，所有连边范围的区间必然要么包含，要么不交。（所以我们就可以开心建树了）

那我们就可以上**动态 DP**了。

设 $s_x$ 表示树上子树内 $f_x$ 的总和。

$$
f_x=\frac{1}{P_x}+\frac{1-P_x}{P_x}\sum_{v\in son(x)} s_v\\
s_x=f_x+\sum_{v\in son(x)} s_v
$$

然后建一个虚点 $n+1$，$L_{n+1}=1$，$P_{n+1}=1$。

代入一下最终答案就是 $s_{n+1}-1$。

所以去算 $f_x$ 没有意义。

$$
s_x=\frac{1}{P_x}+\frac{1-P_x}{P_x}\sum_{v\in son(x)}s_v+\sum_{v\in son(x)} s_v
$$

则最终转移方程为

$$
s_x=\frac{1}{P_x}+\frac{1}{P_x}\sum_{v\in son(x)}s_v
$$

动态 DP 部分其实就很简单了，设 $lightson(x)$ 表示 $x$ 的轻儿子集合，$hson(x)$ 表示 $x$ 的重儿子。 

$$
g_x=\frac{1}{P_x}+\frac{1}{P_x}\sum_{v\in lightson(x)}s_v\\
s_x=g_x+\frac{1}{P_x} s_{hson(x)}
$$

矩阵就不写了，二维的矩阵自己推一下很好推出来。

[目前最优解](https://www.luogu.com.cn/record/list?pid=P10256&orderBy=1&status=&page=1)。（什么时候被超过了就来把它删掉）。

---

## 作者：唐一文 (赞：4)

这题难度真的有黑吗（

先求出一个点失败后会跳到哪里，随便求。笔者用的扫描线 + multiset。设 $x$ 失败后会从 $L(x)$ 开始学习。

设 $f(x)$ 为 $x$ 学习成功的期望，即从 $x$ 跳到 $x+1$ 的期望步数。转移为

$$
f(x)=P_x+(1-P_x)\left(1+\sum_{L(x)\leq y{\color{red}\leq} x} f(y)\right)
$$

化简后得到
$$
f(x)=\frac{1}{P_x}+\frac{1-P_x}{P_x}\sum_{L(x)\leq y {\color{red}{<}} x}f(y)
$$

直接按这个做不知道如何下手，观察一点性质：

如果将 $[L(x), x]$ 看作一段区间，那么这 $n$ 个区间要么包含，要么不交。

证明：如果存在 $L(x) < L(y) < x < y$，则 $x$ 能够取到 $L(y)$。

那么按包含关系建树，发现 $\sum f(y)$ 实际上就是不包括自身的子树和。设 $g(x)$ 为 $x$ 子树内的 $f$ 之和，转移为：

$$f(x)=\frac{1}{P_x}+\frac{1-P_x}{P_x}\sum_{y\in son(x)}g(y)$$

$$
g(x)=f(x)+\sum_{y\in son(x)}g(y)
$$

为了方便，我们建一个虚点 $n+1$，且 $P_{n+1}=1$，$L(n+1)=1$。那么答案为 $g(n+1)-1$。

这看起来就很 DDP，将 $g(x)$ 转移中的 $f(x)$ 替换掉得到：

$$
g(x)=\frac{1}{P_x}\left(1+\sum_{y\in son(x)}g(y)\right)
$$

至此就可以直接 DDP 了。复杂度 $O(n\log^2n)$，[code](https://www.luogu.com.cn/paste/qw1y3ibd)。可以用全局平衡二叉树优化到 $O(n\log n)$ 但没必要。

---

## 作者：complexor (赞：2)

首先，考虑没有修改时如何进行期望 dp。

以下 $p_i$ 即为题面中 $P_i$，$lst_i$ 即为题面中 $x_{i+1}$。

记 $dp_i$ 为已经学习了前 $i$ 部作品，期望还需要几分钟结束学习，那么有转移方程：
$$
dp_i=
\begin{cases}
0&i=n\\
p_{i+1}\times dp_{i+1}+(1-p_{i+1})\times dp_{lst_i}+1&0\leq i\lt n
\end{cases}
$$

$dp_{lst_i}$ 的存在使得现在的 dp 无法进行，所以先考虑在一个独立的（不与其他区间相交）区间 $[l,r]$，我们知道对于 $l\leq i\lt r$ 有 $lst_i=l$，所以转移方程可以改写为：$dp_i=p_{i+1}\times dp_{i+1}+(1-p_{i+1})\times dp_l+1$。注意到 $p_{i+1}+(1-p_{i+1})=1$，所以可以将 $dp_i$ 看作 $dp_i=dp_l-b_i$，并建立起 $b_i$ 的递推关系，具体地：将 $dp_i=dp_l-b_i$ 代回原转移方程，得到 $b_{i+1}=\frac{1}{p_{i+1}}\times b_i+\frac{1}{p_{i+1}}$。平移一下下标则改为：对于 $l\lt i\leq r$，有 $b_i=\frac{1}{p_i}\times b_{i-1}+\frac{1}{p_i}$。为了方便，我们先把所有题面中的区间 $[l,r]$ 的左端点加一，即记录 $[l+1,r]$。

这时，观察到这个转移式是一个一次函数的形式（此处及以下所有一次函数都有一次项不为 $0$），而一次函数的复合运算满足结合律，所以可以借此进行优化。设 $f_i(x)=\frac{1}{p_i}\times x+\frac{1}{p_i}$，则有 $b_i=f_i(b_{i-1})$。
接着，定义一次函数的“复合”运算 "$\ast$"：
- 对于一次函数 $f(x)$ , $g(x)$，定义一次函数 $f\ast g$，满足 $(f\ast g)(x)=g(f(x))$。注意这里 $f,g$ 的先后顺序。
- 依照定义，容易看出在复合运算下，存在单位元 $\epsilon(x)=x$，即对于所有一次函数 $f$，有 $f\ast\epsilon =\epsilon\ast f=f$ 同时对于所有一次函数 $f$，存在逆元（记为 $f^{-1}$），满足 $f\ast f^{-1}=f^{-1}\ast f=\epsilon$，同时复合运算满足结合律（不满足交换律），所以所有一次函数关于复合运算构成一个群。

那么上面的转移可以直接从 $b_{l-1}(=0)$ 推到 $b_r$，即 $b_r=(f_{l}\ast f_{l+1}\ast\cdots\ast f_r)(b_{l-1})$（这里的 $l$ 是区间左端点加一后的 $l$，而不是输入的 $l$ ）。下文中，记 $f_{[l,r]}$ 表示一次函数 $f_l\ast f_{l+1} \ast\cdots\ast f_r$，则有 $b_r=f_{[l,r]}(0)$。

定义一个记号：
- 对于一次函数 $f$ 记 $[C]f$ 为 $f$ 的常数项，显然有 $[C]f=f(0)$。

接下来，先来考察一下区间（左端点已经加一）之间的性质。可以发现若两个区间有交但不完全包含，可以处理成不交的。具体的，对于两个保护区间 $[l_1,r_1]$ 和 $[l_2,r_2]$，若 $l_1<l_2 \le r_1 < r_2$，则等效于 $[l_1,l_2-1]$ 和 $[l_2,r_2]$。

然后，加入一个大区间 $[1,n]$，并将所有区间进行处理，使得它们之间仅存在完全分离或完整包含的关系，这样这些区间构成一棵嵌套关系的树，这部分是简单的。现在，我们希望对于每一个区间 $[l,r]$，求出 $dp_{l-1}-dp_r$ 的值。这样，对于区间 $[1,n]$（即嵌套关系树的根结点所对应的区间），$dp_0-dp_n$ 即为答案。
我们再补充一些定义：
- 对于一个点 $x$，称它的“归属”为直接包含它的那个区间。更形式化的，我们称区间 $S$ 是点 $x$ 的归属，当且仅当 $x\in S$ 且不存在 $T\subsetneqq S$，使得 $x\in T$。
- 称一个“连续段”为一个区间（为了减少分类讨论，我们将左端点大于右端点的区间看作一个合法的区间，只不过它是空集），满足区间内所有点的归属相同。进一步，若一个区间内所有点的归属都是 $[L,R]$，称这个是一个关于区间 $[L,R]$ 的连续段，也称这个连续段的归属是 $[L,R]$。那么上面独立区间的转移可以推广到连续段上，具体地，对于一个关于 $[L,R]$ 的连续段 $[l,r]$，有：$\forall l\leq i\leq r$，满足 $dp_{L-1}-dp_i=f_i(dp_{L-1}-dp_{i-1})$。
- 称区间 $T$ 为区间 $S$ 的子区间（其实是直接的子区间），当且仅当 $T\subsetneq S$，且不存在另一个区间 $U$，使得 $T\subsetneq U\subsetneq S$。

![](https://cdn.luogu.com.cn/upload/image_hosting/05hls6ld.png)

如图，假设当前所处理区间为 $T$，而我们已经递归地处理完它所嵌套的区间 $S1,S2\cdots$，现在从左往右处理那写关于 $T$ 的 **极长** 连续段（即 $T$ 相邻子区间之间的位置）。设 $S1$ 为 $[l,r]$，$S2$ 为 $[l',r']$，$T$ 为 $[L,R]$，继续前文的计算。

首先，我们已经处理好了 $dp_{L-1}-dp_{l-1}=f_{[L,l-1]}(0)$（回顾我们在一个独立区间时所进行的分析）以及 $dp_{l-1}-dp_r$（递归计算得到），并用我们前面提到的方式表示成一次函数 $dp_{L-1}-dp_{l-1}=f(0)$ 以及 $dp_{l-1}-dp_r=g(0)$。那么我们就可以得到 $dp_{L-1}-dp_r=(f+g)(0)$。

而由于 $[r+1,l'-1]$ 是关于 $[l,r]$ 的连续段，所以有 $\forall r\lt i\lt l'$，有 $(dp_{L-1}-dp_i)=f_i(dp_{L-1}-dp_{i-1})$，那么自然地，我们得到 $dp_{L-1}-dp_{l'-1}=f_{[r+1,l'-1]}(dp_{L-1}-dp_{r})=((f+g)\ast f_{[r+1,l'-1]})(0)$。这样，我们便计算完了 $S1$ 对 $[L,R]$ 内 dp 值的影响。

以此类推，依次考虑 $S2,S3,\cdots$，便可以得到 $dp_{L-1}-dp_R$。而由于区间个数为 $O(n)$，且每个点只会被一个区间直接覆盖，所以总复杂度是 $O(n)$（不包括对区间的预处理）。

如上，我们解决了不含修改的问题。而对于每个修改，仅修改了某个点 $x$ 对应的一次函数 $f_x$，并不影响整体递推和递归的结构，这提示我们将这种结构单独研究，而不考虑具体的 $f_x$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d1438z7x.png)

回到刚才的区间嵌套图。首先，我们发现，可以将一个 **极长** 连续段作为一个整体考虑，并将连续段内所有点的一次函数的复合作为这个连续段的一次函数（空段的一次函数可以定义为 $x$）。其次，在前面的分析中，对于 $l'-1$ 的计算用到了 $l-1$ 与 $r$，所以对 $[L,l-1],[pos,r],[r+1,l'-1]$ （$pos$ 是 $r$ 所在连续段的左端点）这几个位置建点，并连边 $([r+1,l'-1]，[L,l-1])$，$([r+1,l'-1]，[pos,r])$。

一般化地，将所有极长连续段（总共应该有 $2m-1$个，$m$ 为处理后的区间个数）建成一个点，对于每个关于 $T$ 的极长连续段 $S$，如果 $S,T$ 的左端点重合，那么 $S$ 所对应的点为叶子。否则，可以找到 $S$ 左侧的所有关于 $T$ 的极长连续段中最靠右的一个 $S'$，以及 $S$ 左侧所有 $T$ 的子区间中最靠右的一个 $T'$（简单的说，就是上一个关于 $T$ 的极长连续段和是一个 $T$ 的子区间），并建边 $(S,S')$，$(S,T')$。这样，会得到一颗结点数为 $2m-1$ 的二叉树，且每个非叶结点恰有两个子结点。上图为建树方法示意。

现在，可以脱离原来的区间嵌套结构，将所有转移放在新建的树上。对于树上的一个结点 $u$，它对应的连续段为 $[l,r]$，其归属为 $[L,R]$，那么设一次函数 $g_u(x)$，满足 $dp_{L-1}-dp_r=g_u(0)$，将上面得到的转移方式改写成（$Lf$ 表示树上的叶子结点的集合）：
$$
g_u=
\begin{cases}
    f_{[l,r]}&u\in Lf\\
    (g_{lchild(u)}+g_{rchild(u)})\ast f_{[l,r]}&O.W
\end{cases}
$$
而所求即为 $g_{root}(0)=[C]g_{root}$。

这个形式还是不够利于维护，所以进一步发掘性质。考虑三个一次函数 $a,b,c$，不难发现一个类似分配律的性质： $(a+b)\ast c=a\ast c+b\ast c-[C]c$。如果我们只考虑常数项为零的一次函数，那么此时的一次函数复合相当于一次项相乘。记 $h_u$ 为树上“前缀”复合，定义为：
$$
h_u=
\begin{cases}
    f_{[l,r]}&u=root\\
    f_{[l,r]}\ast h_{father(u)}&O.W
\end{cases}
$$
如果所有的 $f$ 常数项都为零，则 $g_{root}=\sum_{u\in Lf}h_u$（证明不难）。不幸的是，现在我们的一次函数有了常数项。好在事实上，$[C]g_{root}$ 仍然有优秀的性质，它满足：$[C]g_{root}=[C](\sum_{u\in Lf}h_u-\sum_{u\notin Lf}h_u)$。[证明在这里。](https://www.luogu.com.cn/paste/tpdp6uns)

现在，做法就很明了了：在二叉树的 $dfs$ 序列上建立线段树，对于原树的叶子结点维护 $h_u$，对于原树上的非叶子结点维护 $-h_u$，并用线段树维护区间和。

那么，每个修改相当于修改一个结点的 $f_{[l,r]}$（这一部分可以另用一棵线段树维护）。设修改前的一次函数为 $s$，修改后为 $s'$，修改的结点为 $u$，对于 $u$ 子树中每个 $v$，将 $h_v$ 修改为 $h_v\ast (s\ast h_{father(u)})^{-1}\ast(s'\ast h_{father(u)})$。利用结合律，我们记 $f=(s\ast h_{father(u)})^{-1}\ast(s'\ast h_{father(u)})$。

当对线段树某个点代表的 $[L,R]$ 这一 $dfs$ 序区间内所有 $h$ 复合上 $f=ax+b$ 时，考虑它对区间函数和的影响。设区间 $[l,r]$ 内有 $c_+$ 个代表叶子结点，$c_-$ 个代表非叶子结点，则只需要将区间函数和 $\times k$（此处乘法是一次项、常数项同时乘 $k$，而不是复合），并将区间函数和的一次函数的常数项加上 $b(c_+-c_-)$，同时打上懒标记即可。

而修改中用到的 $h_{father(u)}$ 正好是线段树所维护的，单点查询即可（注意正负）。

而询问答案即为线段树根节点的值。

处理区间时间复杂度为 $O(m\log n)$，总时间复杂度为 $O((m+q)\log n)$，空间复杂度 $O(n)$。

---


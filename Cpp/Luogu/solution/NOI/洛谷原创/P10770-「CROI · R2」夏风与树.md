# 「CROI · R2」夏风与树

## 题目背景

刺眼的阳光把大地烤得炽热，小 B 走在街上，迎面吹来一阵清风，路旁郁郁葱葱的树叶沙沙地摇晃着。

“夏风扫过树叶的声音就像下雨一样呢。”

## 题目描述

Alice 和 Bob 在种树，同时，他们决定玩一个游戏。

Alice 拥有 $1\sim n$ 号结点，Bob 拥有 $(n+1)\sim 2n$ 号结点，这 $2n$ 个结点的权值恰好构成一个**排列** $a$，其中 $a_i$ 为 $i$ 号点上的权值。

首先，他们约定 $1$ 号点为树根。

然后，由 Alice 为 $2\sim n$ 号点决定父亲，其中 $i$ 号点的父亲只能在 $1\sim(i-1)$ 中选择。

接下来，由 Bob 为 $(n+1)\sim 2n$ 号点决定父亲，其中 $i$ 号点的父亲只能在 $0\sim(i-1)$ 中选择。$0$ 号点不在他们的树上，也就是说，Bob 的结点不一定要与这棵树连通。

最后，Alice 会从 $1$ 号点开始，对这棵树进行深度优先搜索，同时她会维护一个序列，搜索过程中，每遇到一个没访问过的点就将它上面的**权值**加入序列末尾。

Alice 希望最终序列的字典序尽可能小，Bob 希望最终序列的字典序尽可能大，并且他们二人都会采取最优策略。现在 Bob 请求你告诉他，最终序列会是什么样。

以下是关于字典序的定义：

- 对于一个长度为 $n$ 的序列 $a$，若 $i>n$，约定 $a_i=-\infty$。
- 对于两个序列 $a, b$，我们定义 $a$ 的字典序小于 $b$ 当且仅当存在 $i\ge 1$，使得 $\forall 1 \leq j < i$，$a_j = b_j$，且 $a_i < b_i$。

## 说明/提示

样例 #1 中，一种可能的最终树，数字为编号，括号内为权值：

![](https://cdn.luogu.com.cn/upload/image_hosting/gqt4od8n.png)
### 数据范围

| 子任务 | 分值 | $n$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------:  |
| $1$ | $10$ | $\le 4$ |无 |
| $2$ | $10$ | $\le 10^5$ |B|
| $3$ | $30$ | $\le 10^5$ |A |
| $4$ | $20$ | $\le 3000$ |无 |
| $5$ | $30$ | $\le 10^5$ |无 |

特殊性质 A：输入中给定一种 Alice 的最优决策中 $2\sim n$ 号结点的父亲。

特殊性质 B：$a_{n+1}\sim a_{2n}$ 构成 $1\sim n$ 的一个排列。 

对于 $100\%$ 的数据，$1\le n\le 10^5$，保证序列 $a$ 是一个 $1\sim 2n$ 的排列。

## 样例 #1

### 输入

```
0
5
10 5 1 8 4 3 7 6 2 9
1 1 1 3```

### 输出

```
10 1 4 9 7 6 5 8 3 2```

## 样例 #2

### 输入

```
0
4
7 2 4 1 5 6 3 8
0 0 0
```

### 输出

```
7 1 8 2 4 6 5 3
```

## 样例 #3

### 输入

```
0
4
2 7 6 4 5 8 1 3
0 0 0```

### 输出

```
2 4 8 6 7 5 3```

# 题解

## 作者：_fairytale_ (赞：11)

记 Alice 所剩的点组成的序列为 $A$，Bob 所剩的点组成的序列为 $B$。

先考虑 Alice 的树已经给出的情况。

我们约定 Bob 对 $i$ 号点进行决策当且仅当 Alice 已经 dfs 完了 Alice 树上 $i$ 号点子树内的所有点。不难发现按照这样的顺序决策符合了字典序贪心的性质。

同时，Bob 不会在一个结点下挂上两个以上的结点。因为假如挂上了多个，那只保留字典序最大的那个一定更优。

这启示我们 Bob 在每个结点挂上的都是一条链。

# 特殊性质 A

Bob 的策略在 Alice 树给定时就很明显了：

考虑 Alice 最后 dfs 的过程，因为字典序和排列的特性，Alice 的路径一定是唯一的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ji9p2adl.png)

假设 Bob 在决策点 $u$，Alice 树中下一个加入序列的点已经确定了，记它的**权值**为 $nxt$，同时考虑 $u$ 往上跳到的最后一个没有分叉的点 $t$，则**除 $t$ 以外**，Bob 在 $u$ 到 $t$ 这条链上挂的每一条链中的结点都是当时 $B$ 中所剩的权值最大的点，而 $t$ 挂的是 $B$ 中所剩的字典序最大的下降子序列。当然，还要时刻满足这个点挂上去之后不会成为权值更小的儿子，并且权值 $>nxt$。

这些决策可以用线段树快速维护出来。

# 正解

现在考虑无特殊性质的情况。

我们跟随 Alice 的视角进行 dfs，同时处理 Bob 的决策。

假设现在考虑到点 $u$，若 $A$ 中能放的最小权值小于 $B$ 中能放的最大权值，那就一定会给 $u$ 挂上儿子，然后 dfs 这个儿子。

考虑 $u$ 没有要挂的儿子的情况。此时轮到 Bob 进行决策，现在没有了特殊性质 A，就代表我们不知道 Alice 下一个没有分叉的点在哪里和它的权值是多少。

但是我们可以用队列先把这些等待挂上链的结点记录下来，然后回溯到父亲，一直到 $A$ 中能放的最小权值小于 $B$ 中能放的最大权值为止。此时，Alice 下一个点的权值**至多**是 $A$ 中能放的最小权值。

于是我们可以像特殊性质 A 一样处理队列里点的决策。最终要么队列被清空，要么 $B$ 中能放的最大权值小于 $A$ 中能放的最小权值。发现这两种情况都是刚刚讨论过的，队列被清空就可以给 Alice 挂上儿子继续 dfs，否则回溯到父亲即可。

注意根结点要特殊处理一下。

代码写得比较丑，看着很长其实很多地方逻辑是重合的，代码大差不差。应该有更加简洁的实现（

```cpp
#include<bits/stdc++.h>
bool st;
#define ls ((p)<<1)
#define rs (((p)<<1)|1)
#define mid ((l+r)>>1)
#define rep(x,qwq,qaq) for(int (x)=(qwq);(x)<=(qaq);++(x))
using namespace std;
#define maxn 200100
int n,m;
int a[maxn];
int fa[maxn];
int inv[maxn];
int mx[maxn<<2],mn[maxn<<2];
void build(int p,int l,int r) {
	if(l==r)return void(mx[p]=mn[p]=a[l]);
	build(ls,l,mid),build(rs,mid+1,r);
	mx[p]=max(mx[ls],mx[rs]);
	mn[p]=min(mn[ls],mn[rs]);
}
void modify(int p,int l,int r,int x) {
	if(l==r)return mx[p]=0,mn[p]=n+n+1,void();
	if(x<=mid)modify(ls,l,mid,x);
	else modify(rs,mid+1,r,x);
	mx[p]=max(mx[ls],mx[rs]);
	mn[p]=min(mn[ls],mn[rs]);
}
int query(int p,int l,int r,int L,int R) {
	if(L>R)return (R<=n?n+n+1:0);
	if(L<=l&&r<=R)return (R<=n?mn[p]:mx[p]);
	int res=(R<=n?n+n+1:0);
	if(L<=mid)res=(R<=n?min(res,query(ls,l,mid,L,R)):max(res,query(ls,l,mid,L,R)));
	if(mid<R)res=(R<=n?min(res,query(rs,mid+1,r,L,R)):max(res,query(rs,mid+1,r,L,R)));
	return res;
}
void clr(int x) {
	modify(1,1,n+n,x);
}
int getnxt(int x) { //返回 pos
	if(x<=n)return inv[query(1,1,n+n,x+1,n)];
	else {
		if(x==n+n+1)x=n;
		return inv[query(1,1,n+n,x+1,n+n)];
	}
}
bool vis[maxn];
int mson[maxn];//mson[i] 表示 i 字典序最大的 Alice 结点儿子 
int lst[maxn];
queue<int>q;
void dfs(int u) {
	int a_first=getnxt(u),b_first=getnxt(n+n+1);
	for(; a[a_first]<a[b_first]||(u==1&&a_first); a_first=getnxt(u),b_first=getnxt(n+n+1)) {
		if(a[a_first]>=a[b_first])while(!q.empty())q.pop();
		int f=(q.size()?q.front():0);
		if(f&&lst[f]&&b_first>lst[f]) {//直接接在当前正在构造的链下面 
			fa[b_first]=lst[f],lst[f]=b_first;
			clr(b_first);
		} else if(f&&!lst[q.back()]&&a[mson[q.back()]]<a[b_first]) {//新开一条链 
			while(q.size()) {
				f=q.front();
				if(lst[f]||a[mson[f]]>a[b_first]) {
					q.pop();
				} else break;
			}
			fa[b_first]=f,lst[f]=b_first;
			clr(b_first);
		} else if(f&&a[getnxt(lst[f])]>a[a_first]) {//字典序最大的下降子序列 
			int k=getnxt(lst[f]);
			fa[k]=lst[f],lst[f]=k;
			clr(k);
		} else {
			fa[a_first]=u;
			mson[u]=a_first;
			clr(a_first);
			while(!q.empty())q.pop();
			dfs(a_first);
		}
	}
	q.push(u);
}
vector<int>g[maxn];
int dep[maxn];
void prt(int u) {
	cout<<a[u]<<" ";
	dep[u]=dep[fa[u]]+1;
	for(int v:g[u]) {
		prt(v);
	}
}
void out() {
	rep(i,2,n+n) {
		g[fa[i]].emplace_back(i);
	}
	rep(i,1,n+n)sort(g[i].begin(),g[i].end(),[](int x,int y) {
		return a[x]<a[y];
	});
	prt(1);
	cout<<'\n';
}
bool ed;
signed main() {
	cerr<<(&st-&ed)/1024.0/1024.0<<" MB\n";
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	cin>>n;
	rep(i,1,n+n)cin>>a[i];
	a[0]=n+n+1;
	rep(i,0,n+n+1)inv[a[i]]=i;
	build(1,1,n+n);
	rep(i,1,n)mson[i]=n+n+1;
	dfs(1);
	int lst=0;
	while(!q.empty()) {
		int t=q.front();
		q.pop();
		int x=getnxt(n+n+1);
		int Lim=a[mson[t]];
		if(a[x]<=Lim)continue;
		fa[x]=t;
		clr(x);
		lst=x;
		int k=getnxt(n+n+1);
		while(k>x&&k!=n+n+1) {
			fa[k]=x,x=k;
			clr(k);
			lst=x;
			k=getnxt(n+n+1);
		}
	}
	if(lst) {
		int x=lst,t=lst;
		while(1) {
			x=getnxt(x);
			if(x==n+n+1)break;
			fa[x]=t,t=x;
			clr(x);
		}
	}
	out();
	return 0;
}
```

---

## 作者：一只绝帆 (赞：6)

笑话一则：出题人每天看提交记录，看有多少小朋友复制题解代码交上去，并放任之，以此为荣，本题提交记录的代码长度高度重复。

***

确实是一道很好的题，本题的性质很多，但想出来还是很不容易。

顺带一提，我的做法似乎没有出题人做法用到的“队列”，连带着速度也快了不少。

部分分：题目给定 $\text{Alice}$ 输入的树。

先来考虑这个部分分，推这种性质题最好还是用定理化的观察方法，即用已知信息不断观察得到新结论，贸然猜测很强的结论，而后急于证明或证伪容易被绕进去。

- $\text{Alice}$ 的遍历方式是固定的，每次只会选最小编号的儿子，$\text{Alice}$ 的树除根以外一定祖先比子孙小。
- $\text{Bob}$ 在一个点下挂的点必须 $>$ 父亲的其他儿子，否则使答案变小了还不如不挂。
- $\text{Bob}$ 在一个点下最多挂一条链，不会出现分叉，因为分叉的地方我们仅保留更大的叉更优，同时这条链从上往下位置递增，值递减（若某个值大于前面则把前面删掉）。

由于第二条性质，我们无需区分 $\text{Bob}$ 挂的点的 **权值** 对 $\text{Alice}$ 遍历的影响，只需关心其 **形态**（也就是链）的影响即可。

> 一些很容易想错的点，如果这与你的观察不一致可以对拍几组观察反例：
> 
> $\text{Bob}$ 并不会只在叶子上挂点，$\text{Bob}$ 使用的点并不是单调递减的。

我们希望让字典序尽量大，正好越大的点越合法（大于其他儿子即为合法），所以我们取出 $\text{Bob}$ 手中最大的点 $y$，我们一定会在第一个能挂 $y$ 的位置挂上 $y$，这里的“第一个”指的是原树的回溯序（在一个点回溯的时候加入该点）。

按照类似的贪心策略，我们接着贪心次大值即可，但要注意：

- 被 $\text{Bob}$ 挂了的 $\text{Alice}$ 点不能挂。
- 被 $\text{Bob}$ 挂上去的点，挂在其下面必须满足二者在 $\text{Bob}$ 的序列中是逆序对。
- 挂上之后，不能比原来劣。

可以直接在回溯序上插入点来维护，第一个和第三个限制都是逐步关闭可用的缝隙，第二个限制只需分讨插在 $\text{Alice}$ 点下面还是 $\text{Bob}$ 点下面即可，插在 $\text{Bob}$ 点下面的话必须在 $\text{Bob}$ 序列的后缀中询问回溯序上最靠前的位置。

实现上，我们可以模拟 $\text{Alice}$ 的过程，对该树进行 $\rm dfs$，若下一步是回溯则维护会回溯到哪个节点，这样我们每次对一条链进行决策，$\text{Bob}$ 向其中扔进去的点在答案中一定是连续的，所以此时我们要往里面塞一个字典序大尽可能的下降子序列。

设本轮回溯之后会加入 $x$，则我们加入的所有点都要大于 $x$。

我们考虑当前没被扔进去的最大点，能成为上一个点的儿子当然是最好的情况，如果不能但是链上仍有能插入的点，那我们就将它插在最下面的能插的点下面。

直到两种情况都不行，那我们就在最后一个插进去的点下面拉一条末尾 $>x$ 的前缀 $\max$ 序列，具体实现我们可以用线段树单点修改查询后缀 $\max$ 在 $\rm B$ 序列上求出。

***

考虑本题的正解。

我们已经搞定了 $\text{Bob}$ 的策略，直接将 $\text{Bob}$ 视为执行策略的波特，考虑 $\text{Alice}$ 的决策。

由于 $\text{Bob}$ 的决策依赖于最终在树上 $\rm dfs$ 的过程，所以我们仍然在（逐步构建起来的）树上 $\rm dfs$。

于是我们同时还能确定“$\text{Bob}$ 剩余哪些数没填”这个集合。

- 向下走时，若 $\text{Alice}$ 能选的最小儿子（注意是儿子，必须比父亲在 A 序列更靠后） $\lt $ $\text{Bob}$ 能选的最大点，则 $\text{Alice}$ 一定不会留给 $\text{Bob}$ 一个能填的叶子，直接递归到那个儿子。

当我们找不到很牛的儿子时，就只能给 $\text{Bob}$ 留下一个叶子了。

- 此时我们开始回溯，如果不考虑 $x$（回溯到的那个点）对最后一段的影响，回溯过程中 $\text{Bob}$ 会扔出的点是确定的，而向上走的过程中，我们可以选择的儿子范围也会扩大。

但这个过程并不是单增函数和单减函数的相遇过程，可选的最大 $\rm B$ 越来越小，可选的最小 $\rm A$ 也越来越小，所以我们要仔细分析一下这个过程。

首先，我们已知 $x=-\infty$ 的时候（这就是整棵树的结尾）$\text{Bob}$ 会怎么填。

- 在回溯到每个点时，我们都尝试一下：假装在这个点递归最小的儿子（令其为 $x$），这个儿子能否 $<$ $\text{Bob}$ 在这个儿子挂的最大的点。

倘若能，这说明我们如果放任不管，$\text{Bob}$ 一定会那么填，而我们干预的话可以变得更优，所以我们会在此时干预，向下递归最小的儿子，这个时候我们也确定了回溯到哪个点。

此时肯定不会出现“$\text{Bob}$ 填的某个数 $< x$，需要抹掉”，一定是 $\text{Bob}$ 卡在了一个并不小的值，而此时我们走 $\rm A$ 点更优秀，所以我们只需处理“$\text{Bob}$ 没填上的最后一段末尾 $>x$ 的下降子序列”即可。

但是有一些不对劲——倘若 $\text{Bob}$ 直接填完了，那不是回溯到根都不会再填 $\rm A$ 点了吗？

是的，剩下的点就是 $\text{Alice}$ 无法利用希望扔掉的那些点，但 $\text{Alice}$ 必须给出大小为 $n$ 的树，于是 $\text{Alice}$ 剩下的这些比 $\text{Bob}$ 手中所有节点都大的点会挂在 $1$ 下面成为菊花（记得撤回一些最后的很小的 $\text{Bob}$ 点）。

挂成菊花是因为这样既可以使它们之间形成最小的字典序不互相干扰，又缩小了 $\text{Bob}$ 对剩下节点的“施法空间”（只剩最后一个点和根可以插手）。

细节的讨论：倘若 $\text{Bob}$ 没在当前节点填数（当前节点的儿子很大），则 $\text{Alice}$ 的下一个儿子一定更大，所以此时并不满足 $\min_A<\max_B$，从而不会出现“$\text{Bob}$ 不填数，$x$ 和它的父亲都满足 $\min_A<\max_B$，且短期收益一致，需要比较长期收益”的情况。

需要注意的是，尽管 $\text{Bob}$ 会在一段回溯里面先尽可能选最大的，再选一个大于回溯值的前缀最大值下降子序列接在最后一个下面，但我们并不一定将其接在回溯过程的最后一个节点上，所以我们不应将“最后一个节点的最大儿子”作为限制。

自认为各种讨论说的比出题人要详实一点，代码写的好看一点，似乎速度是几乎所有代码的两倍。

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i=a,i##E=b;i<=i##E;i++)
#define UF(i,a,b) for(int i=a,i##E=b;i>=i##E;i--)
#define sz(x) int(x.size())
using namespace std;typedef long long ll;
#define vec vector
#define In(x) freopen(x".in","r",stdin)
#define Out(x) freopen(x".out","w",stdout)
#define File(x) (In(x),Out(x))
#define all(x) begin(x),end(x)
#define ran(x,l,r) begin(x)+l,begin(x)+(r+1)
template<typename T>
void operator+=(vec<T> &a,const T&b) {a.push_back(b);}
#define gc() getchar()
//#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char *p1,*p2,buf[1<<21];
int read() {
    int s=0,w=0;char ch=gc();
    while(ch<'0'||ch>'9') w|=(ch=='-'),ch=gc();
    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=gc();
    return w?-s:s;
} const int N=2e5+5,inf=1e9;
int n,a[N],b[N];
struct ds {
    #define l(x) (x<<1)
    #define r(x) (x<<1|1)
    #define mid (L+R>>1)
    #define up(d) (void)(c[d]=max(c[l(d)],c[r(d)]))
    pair<int,int> c[N<<2];
    void bd(int *b,int L=1,int R=n,int d=1) {
        if(L==R) return void(c[d]={b[L],L});
        bd(b,L,mid,l(d));bd(b,mid+1,R,r(d));up(d);
    }
    void del(int id,int L=1,int R=n,int d=1) {
        if(L==R) return void((c[d]={-inf,L}));
        id<=mid?del(id,L,mid,l(d)):del(id,mid+1,R,r(d));up(d);
    }
    void mo(int id,int x,int L=1,int R=n,int d=1) {
        if(L==R) return void((c[d]={x,L}));
        id<=mid?mo(id,x,L,mid,l(d)):mo(id,x,mid+1,R,r(d));up(d);
    }
    pair<int,int> que(int l,int r,int L=1,int R=n,int d=1) {
        if(R<l||r<L) return {-inf,0};if(l<=L&&R<=r) return c[d];
        return max(que(l,r,L,mid,l(d)),que(l,r,mid+1,R,r(d)));
    }
} Ta,Tb;
int ans[N],tot,ub[N];
void add_decrease_seq(int nxt,int L) {
    while(1) {
        auto[mxb,idb]=Tb.que(L,n);
        if(mxb<nxt) return;
        Tb.del(L=idb);
        ans[++tot]=mxb;
    }
}
void add_decrease_prefix(int lim) {
    if(Tb.c[1].first<lim) return;
    int L=0;
    while(1) {
        auto[mxb,idb]=Tb.c[1];
        if(mxb==-inf||idb<L) return;
        Tb.del(L=idb);
        ans[++tot]=mxb;
    }
}
int mx_son1;
void dfs(int x) {
    Ta.del(x);
    ans[++tot]=a[x];
    int mx_son=0;
    while(1) {
        auto[mna,ida]=Ta.que(x,n);
        mna*=-1;
        auto[mxb,idb]=Tb.c[1];
        if(mna<mxb) {
            if(tot&&ub[ans[tot]]) add_decrease_seq(mna,ub[ans[tot]]);
            mx_son=mna;
            if(x==1) mx_son1=mna;
            dfs(ida);
        } else break;
    }
    if(x!=1) add_decrease_prefix(mx_son);
}
int main() {
    read();n=read();
    F(i,1,n) a[i]=-read();
    F(i,1,n) b[i]=read(),ub[b[i]]=i;
    Ta.bd(a);Tb.bd(b);
    F(i,1,n) a[i]=-a[i];
    dfs(1);
    if(Ta.c[1].first==-inf) {
        add_decrease_prefix(mx_son1);
        if(tot&&ub[ans[tot]]) {
            add_decrease_seq(0,ub[ans[tot]]);
        }
    } else {
        while(tot&&ub[ans[tot]]&&ans[tot]<-Ta.c[1].first) {
            Tb.mo(ub[ans[tot]],ans[tot]);
            tot--;
        }
        while(Ta.c[1].first>-inf) {
            auto[mna,ida]=Ta.c[1];
            mna*=-1;
            mx_son1=mna;
            Ta.del(ida);
            ans[++tot]=mna;
        }
        add_decrease_prefix(0);
        add_decrease_prefix(mx_son1);
        if(tot&&ub[ans[tot]]) {
            add_decrease_seq(0,ub[ans[tot]]);
        }
    }
    F(i,1,tot) printf("%d ",ans[i]);
    return 0;
}

```

---

## 作者：是青白呀 (赞：5)

首先考虑 Alice 的树已经给定的情况。你发现 Bob 显然不会挂一个点，使得它的权值比已有儿子的权值更小。也因此，Alice 一定优先走自己的点，Bob 的点只会在回溯的过程中走到。

于是我们考虑维护一个回溯点的队列，从一个叶子处出发，到其上方首个回溯停止的位置结束。我们设回溯停止后走到的下一个点为 $x$。首先，Bob 在每个点上挂的点一定构成一条链，否则就给 Alice 提供了往权值更小的点走的选择，不优。我们按权值从大往小遍历 Bob 还没有用过的点，依次执行下面的判断：
1. 若 B 中权值最大的点能挂在当前 B 链的末端，或能在回溯点队列队首的 A 点处新开一条 B 链，则贪心地挂上去。否则执行判断 2。
2. 否则，尝试找到队列中最靠前的未开始构造 B 链的点 $t$，满足 $t$ 所有 A 树上的儿子的权值都小于当前 B 点的权值。不难发现由于 Alice 树上父亲节点的权值一定小于儿子节点，且回溯链一定是每次沿着权值最大的那个儿子走而形成的，故一个队列中，每个点**儿子的最大权值**一定是**从队首至队尾单调递减**的（叶子除外），于是可以用队尾判断是否存在合法的 $t$。若找到一个 $t$，则结束当前 B 链的构造，并将队列中 $t$ 之前的所有点出队，将当前 B 点挂在 $t$ 的儿子处，开始构造一个新的 B 链。否则执行判断 3。
3. 若找不到，则持续将当前能挂到该链尾端的权值最大的点找出来，若其权值大于 $v_x$，则将其挂在当前 B 链的尾端。若找不到这样的点，则在判断 2 中找不到的限制下，当前所有回溯点上都无法再新增 B 链了，开始考虑下一个回溯链。

现在要考虑 Alice 的树的最优形态。在没有 Bob 影响的情况下，最优结构是一棵以 $1$ 号点为根的菊花。注意到 Alice 树上越靠近根的节点编号越小，对儿子编号的限制也越小。因此我们在回溯过程中，将点尽可能地靠近根放是更优的。但同时，回溯链越长，则上述判断 2 越可能成立，下一位置能放权值最大的 B 点的可能性越大。并且贪心地，由于我们 dfs 到回溯链上的 B 点先于回溯链顶端的 A 点，故我们需要优先限制回溯链长度；在回溯链长度增大不会使字典序变大的前提下，再将点尽可能靠近根放。

换句话说，我们在某个非根的儿子的位置放一个 A 点，当且仅当 Bob 可以在这个位置放置一个权值更大的点。此时，Alice 会希望通过在此处放置 A 点的方式提供一个 dfs 方向的选择，阻止字典序过大。

考虑一边 dfs，一边维护回溯链，贪心地依次执行下面的判断，直到所有 A 点均被安放完毕：
1. 假设当前点能放的权值最小的 A 点大于能放的最大的 B 点，则此时在这里放置 A 点来限制回溯链长度是没有意义的。因此若当前点不是根节点，我们就将当前点移至父亲处，增长回溯链，然后重新执行这一组判断 1；若当前点是根节点，则上一条回溯链上显然不会再放 B 点，于是直接将最小的 A 点放在根的儿子处，也即执行判断 3。否则执行判断 2。
2. 此时我们先不急着插入一个新的 A 点：由于前面的一系列判断中，回溯链长度有更新，Bob 在回溯链上放点的优先级高于在该位置处放点的优先级。所以我们依次执行上一组的 $3$ 个判断，其中 $v_x$ 显然是当前能放的权值最小的 A 点。若有一个新的 B 点被插入，则该位置能放的最大的 B 点权值可能减小，我们需要重新执行判断 1 看回溯链是否延长，进而影响 Bob 接下来的决策。若没有新的 B 点被插入，则执行判断 3。
3. 此时，要么当前点已经在根的位置，再没有退路；要么在当前点处接一个 A 点可以避免字典序由于 Bob 在此处接 B 点而变大。无论如何，Alice 的策略都应当是在当前点下方放目前可以放的权值最小的点，并清空回溯链，然后重新开始执行判断 1。

最终若还剩了一些 B 点，则此时的回溯链应当是从根节点出发的。我们执行第一组判断，直到不能执行为止，剩余的 B 点连到 $0$ 上去即可。

用线段树维护所有点的权值，单点修改、区间求最大或最小。最终不难通过一次 dfs 求得答案。总复杂度 $O(n\log n)$。

---


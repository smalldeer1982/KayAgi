# [JRKSJ ExR] 七影蝶

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/n7wkxyof.png)


## 题目描述

久岛鸥给了你一个长度为 $n$ 的非负整数序列 $a_{1\sim n}$。

接下来有 $q$ 次询问，每次询问给出非负整数 $L,R$，求

$$\max_{x=L}^R\left(\sum_{i=1}^n\mathrm{popcount}(a_i+x)\right)$$

其中 $\mathrm{popcount}(x)$ 表示 $x$ 在二进制形式下数位 $1$ 的出现次数。

## 说明/提示

### 样例解释

对于样例 $1$，第一组询问取 $x=10$ 时达到最大值，即 $\mathrm{popcount}(11)\times 3+\mathrm{popcount}(14)\times 2+\mathrm{popcount}(15)=3\times 3+2\times 3+4=19$。

容易验证 $x$ 取范围内其他值都不能使答案更大。

### 数据范围
**本题开启捆绑测试。**

令 $V$ 为数组中元素与询问区间端点的最大值。

| $\text{Subtask}$ | $n\le$ | $q\le$ | $V\le$ |$\text{Score}$ |
| :-----------: | :-----------: | :-----------: | :---------: | :----------: |
|$1$ | $10$| $10$ | $10$ | $5$ | $2$
|$2$ | $10^5$| $5\times 10^5$ | $10^3$ | $5$ | $2$
|$3$ | $10^5$| $10^5$ | $10^5$ | $15$ | $2$
|$4$ | $10^4$| $10^4$ | $10^9$ | $10$ | $2$
|$5$ | $10^5$| $1$ | $10^9$ | $15$ | $2$
|$6$ | $10^5$| $5\times 10^5$ | $10^9$ | $20$ |  $5$
| $7$ | $5\times 10^5$ | $10^5$ | $10^9$ | $20$ | $5$
| $8$ | $5\times 10^5$ | $5\times 10^5$ | $10^9$ | $10$ | $2$ |
| $9$ | $5\times 10^5$ | $5\times 10^5$ | $10^{11}$ | $0$ |

对于所有数据，保证 $1\le n,q\le 5\times 10^5$，$0\le L\le R\le 10^{11}$，$0\le a_i\le 10^{11}$。

子任务 $6,7,9$ 的时间限制为 $5$ 秒，其余子任务均为 $3$ 秒。

## 样例 #1

### 输入

```
6 6
1 1 4 5 1 4
1 10
1 5
3 6
4 7
3 9
2 5```

### 输出

```
19
13
16
16
16
13```

## 样例 #2

### 输入

```
10 10
765 523 255 781 647 98 451 636 109 771
394 405
128 161
332 565
996 1003
3 116
403 486
255 582
744 861
399 408
528 996```

### 输出

```
58
59
69
68
66
62
69
75
58
75```

# 题解

## 作者：fjy666 (赞：15)

## Subtask 1,2,3

$V$ 较小，因此可以枚举 $1\le i\le V$，计算出 $\texttt{ans}_i=\sum_{j=1}^n \operatorname{popcount}(a_j+i)$，最后询问做 RMQ。

$\texttt{ans}_i$ 可以通过将所有数插入 01 Trie，然后每次对 01 Trie 做全局 $+1$ 维护答案得到。时间复杂度为 $\mathcal{O}(V\log V+q\log V)$

## Subtask 5

可以通过修改 [Make Equals](https://www.luogu.com.cn/problem/CF1188D) 的做法过这一档分。

## Subtask 4,6

考虑用更高妙的方法维护出 $\texttt{ans}_i$。

拆位，$a_i+j$ 的第 $k$ 位为 $1$ 可以转化为 $j$ 的后 $k$ 位在一个值域区间内，因此假如只考虑第 $k$ 位的话，$\texttt{ans}$ 数组可以被 $n$ 次区间加 $1$ 维护出来。

假设你已经维护出了第 $k$ 位及以下的 $\texttt{ans}_i(0\le i<2^k)$，可以发现第 $k+1$ 位的线段树根节点 $[0, 2^{k+1})$ 的两个儿子 $[0, 2^k)$ 和 $[2^k, 2^{k+1})$ 关于第 $k$ 位及以下的信息都是完全一致的。

因此我们对线段树进行可持久化，然后每次 $k\gets k+1$ 时新建根节点，然后把根节点的两个儿子都指定为前一层的根结点，同时将根节点维护的值域扩大两倍即可。

（我称呼它为值域倍增线段树）

空间，在新建节点的时候需要判一下这个节点是不是这一层已经新建过的，如果是的话就不要新开节点了。

时空复杂度均为 $\mathcal{O}(n\log^2V)$，期望得分 $55\sim 70$。（~~Sub 5 的线段树卡了常~~，这不是出题人本意，被卡的老师们对不起/wq）

[这一部分参考代码。](https://www.luogu.com.cn/paste/j40l9zbl)

## Subtask 7,8 (improved by Zhoukangyang)

观察线段树，第 $k$ 层的 $\mathcal{O}(n)$ 次区间操作会把线段树分成 $\mathcal{O}(n)$ 段，每段所受到的区间加操作是完全相同的。

这些“段”在 $k$ 层的操作相同，在 $>k+1$ 层受到的操作必定也是相同的，因此考虑每次做完区间加后把受到操作相同的值合并起来。 

合并后会有 $\log V$ 层，每层有 $\mathcal{O}(n)$ 段。每一段需要储存：区间 $\max$，以及被打的标记的总和。

查询类似线段树，中间整段做区间 $\max$，左右两端往下递归，递归需要带上标记，类似标记永久化。  

使用双指针与线性 RMQ 优化可以做到 $\mathcal{O}((n+q)\log V)$，不加这些是 $\mathcal{O}(n\log V+q\log^2 V)$。

## Extra

存在 Meet in the middle 做法。大概是后 $26$ 位预处理，然后对于询问枚举前 $6$ 位从而平衡复杂度。

这个是出题人没想到的，出题人在比赛时看到这个做法后上巴吓得掉下去了。

[EuphoricStar](https://www.luogu.com.cn/user/275273) 在赛时最后 1min 用这个做法[绝杀](https://www.luogu.com.cn/record/202248817)了这个题。Orz

~~通过了~~杀了。

****

> 致：鹰原羽依里先生  
> 我愿越过七片大洋，与君相会。  
> 满怀着我的爱意。  
> 胡子猫海盗团 · 久岛鸥

---

## 作者：sqrtDataStructure (赞：6)

基于出题人 Subtask 7 的做法，在此基础上我们往每一层分割点集合里再加上每个询问 $l, r$ 的后 $k$ 位。  

这样会让一层有 $n+q$ 段，但是询问只需要在最上层做一次 RMQ 即可（先用二分找到 $l_i, r_i$ 在最上层的位置，由于只有一次，`lower_bound` 即可）。

不需要离线双指针，也不需要线性 RMQ。代码长度和常数均有显著下降。

---


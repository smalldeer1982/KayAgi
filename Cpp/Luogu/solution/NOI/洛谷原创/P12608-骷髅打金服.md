# 骷髅打金服

## 题目背景

下图是一个经典算法的错误实现。

## 题目描述

长为 $n$ 的序列 $a$ 的一个非空连续子段是合法的，当且仅当其中**所有出现过的元素**出现次数全相等。

求合法的非空子段个数。两个子段不同当且仅当它们在原序列中的出现位置不同。

## 说明/提示

### 样例解释 #1

对于第三组数据，合法的连续非空子序列如下：

- $[1,1]$
- $[1,2]$
- $[1,4]$
- $[2,2]$
- $[2,3]$
- $[2,5]$
- $[3,3]$
- $[3,4]$
- $[4,4]$
- $[4,5]$
- $[5,5]$

### 数据范围

本题采取子任务依赖，未通过当前子任务依赖的子任务会导致当前子任务得零分。

对于 $100\%$ 的数据，$T\ge 1,1\le n,\sum n\le 10^6,1\le a_i\le n$。

|子任务|$n\le$|$\sum n\le$|特殊性质|分值|时限|依赖子任务|
|:-------:|:-:|:-:|:-----:|:--:|:--:|:-:|
|$1$|$100$|$1000$|-|$10$|1s| |
|$2$|$8000$|$4\times 10^4$|-|$10$|1s|$1$|
|$3$|-|$2\times 10^5$|$1\le a_i \le 4$|$20$|1s| |
|$4$|-|$2\times 10^5$|$a$ 的每个元素在 $[1,n]$ 均匀随机|$10$|1s| |
|$5$|-|$2\times 10^5$|$1\le a_i\le 14$|$20$|1s|$3$|
|$6$|-|$2\times 10^5$|-|$10$|1s|$1\sim 5$|
|$7$|-|$5\times 10^5$|-|$10$|2s|$1\sim 6$|
|$8$|-|$10^6$|-|$10$|3s|$1\sim 7$|


## 样例 #1

### 输入

```
5
9
1 1 1 2 2 2 3 3 3
4
1 1 2 2
5
1 1 2 2 1
10
1 2 2 1 1 2 3 2 3 3
12
1 1 2 3 3 2 1 2 3 3 2 1```

### 输出

```
25
8
11
26
34```

# 题解

## 作者：Undead2008 (赞：22)

经 int_R 指正，我原来的题解有一部分在狗叫，已于 5 月 30 日修正。
## 暴力
因为暴力比较有意思就简单说一下。
### Sub #2
固定左端点，枚举右端点，动态使用桶维护所有出现过的元素的种类数 $V$ 和众数出现次数 $T$，如果 $V\times T$ 等于区间长度 $l$，则该区间合法。

由此得到小常数 $O(n^2)$ 做法。Sub #1 是给大常数做法和复杂度更高的做法留的。
### Sub #3
考虑枚举出现过的元素集合 $S$，进行和哈希，给原序列中出现的元素随机赋权，同种元素权值相同。

如果区间所有元素的哈希值总和能被 $S$ 中元素的哈希值总和 $W_S$ 整除即为合法。这个可以转成前缀和模 $W_S$ 相等，然后拿哈希表存储前缀和的哈希值就行了。

### Sub #4
每一种元素的期望出现次数很少。

将每个区间 $[l,r]$ 转成平面上的点 $(l,r)$，将每一种元素的贡献转成矩形取 max 然后扫描线即可。

具体可以去问验题人 cdx123456，我没写过这个做法。
## 正解
对原序列分治，考虑如何拼合左半边和右半边。

首先考虑和哈希，给原序列中出现的元素随机赋权，同种元素权值相同。

对“是否存在某种元素完全出现在左半边/右半边”进行分讨：

![](https://cdn.luogu.com.cn/upload/image_hosting/1qmbcn96.png)

（给个图，看下面的文字感觉恶心看不懂可以看图）

---

如果没有任何一种元素完全出现在左半边/右半边，**则每一种元素必须在左半边和右半边同时出现**，此时满足条件当且仅当：

- 左边出现过的所有元素种类的哈希值和 $L_a$ 等于右边出现过的所有元素种类的哈希值和 $R_a$；
- 左边和右边所有元素的哈希值总和 $L_h+R_h$ 能被 $L_a$ 整除，换句话说，就是 $L_h\bmod L_a=(-R_h)\bmod R_a$。

---

如果有某几种元素完全出现在左半边，没有元素完全出现在右半边，此时满足条件当且仅当：

如果要在左边加入最少的元素使得左边所有元素的出现次数相同，加入的元素哈希值总和记作 $L_r$。

- 有 $L_r=R_h$。

---

如果有某几种元素完全出现在右半边，没有元素完全出现在左半边，此时同上。

---

如果有某几种元素完全出现在左半边，有某几种元素完全出现在右半边，此时满足条件当且仅当：

左边所有出现次数严格小于众数的出现次数的**元素**哈希值总和记作 $L_z$，同理定义 $R_z$。

如果想要添加尽量少的元素使得左边所有元素出现次数相同，需添加的**元素**哈希值总和记作 $L_x$，同理定义 $R_x$。

左边所有众数在右边首次出现的位置记作 $K$。

- 左右两边众数出现次数相同。
- 有 $L_z=R_x$。
- $K$ 大于右边的右端点 $r$。换句话说，就是左边的所有众数均不在右边出现。

上述变量均可以线性预处理，由此得到枚举左右端点然后 check 是否满足上述四种条件其中之一的 $O(n^2)$ 做法。

观察到上述四种情况是独立的，也就是说不可能存在区间同时满足两种或更多情况。所以可以把四种情况拆开算。

观察到上述条件大多都是检验若干个二元组或三元组完全相等，最复杂的第四种情况也只是加了一维偏序，因此可以拿哈希表直接维护，偏序可以基数排序后离线双指针，动态加动态查。

时间复杂度 $O(n\log n)$。哈希表需要手写。

随机赋权单个元素权值值域使用 $10^9$ 级别冲突概率极大，使用 $10^{12}$ 级别即可轻松通过。
## 代码
贺题的小先生太多了，目前已通过的提交中绝大多数都是直接复制粘贴我的题解，故于 2025/5/27 删除所有 $O(n\log n)$ 代码。

下面是一种手写哈希表的实现：

```cpp
//Hash_Table
const int MASK = (1<<19)-1;
int Hd[MASK+1],Idx;
int Ne[maxn],C[maxn];
XI Wx[maxn];
inline void Insert(const XI &X){
	const int p=X&MASK;
	for(int i=Hd[p];i!=-1;i=Ne[i])
		if(Wx[i]==X)
			return C[i]++,void();
	C[++Idx]=1,Wx[Idx]=X,Ne[Idx]=Hd[p],Hd[p]=Idx;
}
inline void Reset(const XI &X){
	Hd[X&MASK]=-1;
}
inline int Query(const XI &X){
	const int p=X&MASK;
	for(int i=Hd[p];i!=-1;i=Ne[i])
		if(Wx[i]==X)
			return C[i];
	return 0;
}
```

$O(n^2)$ 的代码如下：

```cpp
#include"bits/stdc++.h"
using namespace std;
const int maxn = 1e6+10;
int T,n,m;
int Ap[maxn],a[maxn];
int main(){
	ios::sync_with_stdio(0),cin.tie(nullptr);
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		long long Ans=0;
		for(int l=1;l<=n;l++){
			for(int r=l,Mx_=0,Cc_=0;r<=n;r++){
				if(!(Ap[a[r]]++))Cc_++;
				Mx_=max(Mx_,Ap[a[r]]);
				if(Mx_*Cc_==(r-l+1))Ans++;
			}
			for(int r=l;r<=n;r++)Ap[a[r]]=0;
		}
		cout<<Ans<<'\n';
	}
}
```

---

## 作者：王熙文 (赞：2)

如果这题时限压缩到 1s 就真的是卡常神题了。最大点 566ms，记录一下卡常技巧。

## 思路

首先可以感受一下出现过的元素出现次数都相等是什么形态。将相同的数放到一行里列出一个矩形，比如：

```
1 1 1 1
2 2 2 2
3 3 3 3
```

可以很自然地想到每一列的值都是相等的。判定相等可以使用哈希，将每一个值 $x$ 随机一个权值 $qz_x$，设每一个值的出现次数为 $cnt_x$，则判定条件即为 $\sum_x qz_x\cdot cnt_x \bmod \sum_x qz_x = 0$。

但是维护一个值是否出现是比较困难的。因为“出现过”这个信息不可减，所以无法使用前缀和作差的方式。但是这个信息是可加的，所以可以考虑分治。

但是分治后如果两边的数集不相同，还是没法做的，因为需要取并集的过程。那如果两边的数集不相同，有没有什么性质呢？

确实有。假设左边有一个在右边没出现的数 $x$，那么所有数的出现次数就都为 $x$ 在左边出现的次数 $cnt_x$ 了。进一步地，$x$ 应当是众数，而且在左边出现的数在右边的出现次数就都确定了（对于 $y$ 在右边出现的次数为 $cnt_x-cnt_y$）。

但是右边还可以有左边没出现的数。此时它也应当是右边的众数，而且出现次数与左边的众数应当相同。

这两种情况是无法合并的，因为右边的众数既可以出现在左边也可以不出现在左边。这就是剩下的情况还需要分三类的原因。大概的框架清楚了，接下来详细讨论一下四种情况。

* 没有只出现在一边的数：设 $x$ 是左边的数，$y$ 是右边的数，则 $\sum_x qz_x=\sum_y qz_y$ 且 $(\sum_x qz_x\cdot cnt_x+\sum_y qz_y\cdot cnt_y) \bmod \sum_x qz_x=0$。
* 有只出现在左边的数，没有只出现在右边的数：设左边众数出现次数为 $k$，则 $\sum_x qz_x \cdot (k-cnt_x)=\sum_x qz_y \cdot cnt_y$。
* 有只出现在右边的数，没有只出现在左边的数：同理。
* 有只出现在左边的数和只出现在右边的数：设左边、右边众数出现次数分别为 $kx,ky$，则 $kx=ky$ 且 $\sum_x qz_x \cdot (kx-cnt_x)=\sum_y [cnt_x\ne ky] qz_y \cdot cnt_y$。而且需要让两边众数的数集没有交。设左边众数在右边的最小位置为 $wz$，则右端点 $r<wz$。

前三种情况可以使用哈希维护，第四种情况可以在 $wz$ 处记录下来查询并扫描线，也可以使用哈希维护。因此这道题做完了，复杂度为 $\mathcal O(n \log n)$。

## 卡常技巧

* 若分治的区间长度 $\le 100$ 跑 $\mathcal O(n^2)$ 暴力。区间合法等价于一个区间的众数出现次数乘上不同的数的个数等于区间长度。
* 每个数的权值在 $[0,9 \times 10^{12})$ 内随机，这样既不会产生相同的元素，也可以让总和存储在 `long long` 里。
* 对于两个元素的储存，直接将它们异或起来而不是变成一个 `__int128`。
* 使用拉链法（而不是开放寻址法）存储哈希表。
* 将四个哈希表的询问预处理出来，使用一个哈希表重复四次而不是开四个哈希表。这样访问稍微连续一些。
* 哈希表桶的大小开 $2^{18}$。
* 每次分治的时候都将区间内的数离散化，这样可以有效降低值域，增加访问连续性。
* 使用 bfs 进行分治，这样可以让区间长度接近的询问放在一起做，同样增加访问连续性（优化效果存疑）。
* 计算 $\sum_x qz_x\cdot cnt_x \bmod \sum_x qz_x$ 的时候（设两个值分别为 $x,y$），可以记录变量 $z=\lfloor \dfrac{x}{y}\rfloor$，每一次若加入一个以前的数的权值，权值一定 $\le y$，那么 $z$ 最多增加一。若加入一个新的数的权值，则 $z$ 不会增大。那么暴力维护 $z$ 的变化，复杂度是正确的，而且避免了取模。

[提交记录](https://www.luogu.com.cn/record/219595665)

---

## 作者：SDSXC (赞：1)

前言：由于官方题解有些过于简洁且没放代码导致本蒟蒻一开始没有看懂，所以写一篇题解赘述一下官方题解说了些什么，以及一些实现细节。

首先这个问题在 $O(1)$ 次询问时的经典做法是哈希随机化，所以本题我们也考虑随机化。

然后不知道怎么想到的，我们考虑分治。

考虑如何快速计算同时涉及左右两个区间的合法区间数。

分类讨论：

* 如果该合法区间每一个元素都同时出现在左右两边，那么我们记其在左右区间中部分的哈希值和（出现多次的计算多次），和哈希值种类和（出现多次的计算一次）分别为 $L_1,R_1,L_2,R_2$。

那么限制条件几乎等价于 $L_2=R_2$ 且 $L_2 \mid L_1+R_1$ 即 $L_2=R_2$ 且 $L_1 \bmod L_2=-R_1 \bmod R_2$。

对这类区间我们只要先计算出所有的 $[i,mid],i\in[l,mid]$ 的 $L_1,L_2$ 和 $[mid+1,j],j\in[mid+1,r]$ 的 $R_1,R_2$

再将$(L_1 \bmod L_2,L_2)$ 丢入一个桶中，暴力枚举右端点即可计算。

* 如果该合法区间存在一些元素只出现在左边，但不存在元素只出现在右边。

那么我们考虑如何在知道左区间是什么的情况下判断怎样的右区间合法。那么显然右区间应当恰好有哪些左区间和右区间共享的元素，并且每一种元素个数加起来应与左区间独有元素的和相等。哪些如何判断元素是左边独有的，哪些是共享的呢？其实非常简单，左区间独有的元素的个数严格大于共享元素，只要找众数就行了。

那么对每一个 $[i,mid]$ 我们记 $L_3$ 表示它需要补上一些某元素使得它成为一个合法子区间，这些元素的权值和。

那么能和它匹配的 $[mid+1,j]$ 几乎等价于 $R_1=L_3$。

直接计算 $L_3$ 并不那么容易，我们还需要一些辅助来计算它。我们记 $L_4$ 表示个数严格小于众数的元素的哈希值的和，$L_5$ 表示众数种类的哈希值的和，$L_6$ 表示每一种众数元素的元素个数。

那么显然的，我们有 $L_3=L_6\times (L_2-L_5)-L_4$。

然后我们模仿情况 1 中的方法就可以统计这类区间个数。

只有右边有独占元素也是类似的。

* 如果独占元素左右都有。

首先为了方便我们类似 $L_3\sim L_6$ 的定义 $R_3\sim R_6$。

这类区间等价于，左右两侧的共享元素合在一起要恰好补齐，即 $L_3=R_4$ 或 $L_4=R_3$ (这两个式子显然是等价的，我们计数的时候只要检验一个就行)。

然后我们还要求两边的独占元素不能有交集，所以我们定义 $L_7$ 表示该左区间的独占元素第一次在右边出现的位置，我们的 $[mid+1,j]$ 要满足 $j<L_7$。

如何求出 $L_7$ 呢，对每个元素预处理其第一次在右区间中出现的位置，更新众数的时候取 $\min$ 就行。

然后这里需要一个比常规的带 $logn$ 的做法更快的做法，因为观察数据范围我们不难发现如果这里带了 $logn$ 总复杂度就会变成 $log^2 n$，再加上常数肉眼可见的巨大这是无法通过的。

我们注意到 $L_7$ 的值域很小，我们把关于它对 $[i,mid]$ 做基数排序，然后双指针，每次加入新的合法的 $[mid+1,j]$ 到桶中，然后统计。

这样基本的做法终于就讲完了，然后我们整理一下实现细节，并处理一些常数问题。

首先我们需要每次线性的维护一共七个数组，$f_1\sim f_7$ 分别表示：

$f_1$ 哈希值的和，重复算多次。

$f_2$ 哈希值的和，重复算一次。

$f_3$ 将严格个数小于众数元素补齐至个数与众数相同所需的最小集合的哈希值的和，重复算多次。

$f_4$ 个数严格小于众数的元素的哈希值的和，重复算多次。

$f_5$ 众数的哈希值的和，重复算一次。

$f_6$ 每一种众数的元素个数。

$f_7$ （仅左区间需要维护）众数集合中的数第一次出现在右区间中的位置。

然后听官方题解说哈希值需要 64 位，否则非常容易碰撞，然后因为中间有判断整除的需要，所以哈希值在求和之类的时候不能进行取模，必须使用 `__int128`。

然后由于本题常数肉眼可见的大且数据范围卡的比较紧，`unordered_map` 肯定是会完蛋的，我们需要使用 `pb_ds` 提供的 `hash_table` 或者自己手动实现。

到这里如果你实现的比较精细可能是足以通过的，否则你可能还需要以下优化。

众所周知 `__int128` 计算非常的慢，尽可能的减少和它相关的运算，比如说 `hash_table` 中的哈希部分我们只是要判断是否相等而已，64 位完全足够，直接强制类型转换成 `unsigned long long`，`pair<__int128,__int128>` 的哈希也可以做类似优化。

同时我们知道位运算比乘除法和取模快得多，尽量把哈希中的乘除法和取模都改成位运算。

然后这样差不多就可以通过了。

~~然后一写就从晚上七点写和调到了十点。~~

代码


```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#define ll long long
#define ull __int128
#define umap gp_hash_table
#define N 1000009
#define INF 0x3f3f3f3f
using namespace std;
using namespace __gnu_pbds;
int n,a[N];
ull f1[N],f2[N],f3[N],f4[N],f5[N];
int f6[N],f7[N];
ull h[N];
int c[N],d[N];
umap<unsigned ll,int> mp;
inline unsigned ll get(unsigned ll x,unsigned ll y){
	return (x<<7)^(x>>7)^(y<<19)^(y>>19);
}
int cnt[N],p[N];
ll cdq(int l,int r){
	if(r-l<20){
		ll ret=0;
		for(int i=l;i<=r;i++){
			int mx=0,sz=0;
			for(int j=l;j<=r;j++)c[a[j]]=0;
			for(int j=i;j<=r;j++){
				if(!c[a[j]]) ++sz;
				++c[a[j]];mx=max(mx,c[a[j]]);
				if(sz*mx==(j-i+1)) ++ret;
			}
		}
		return ret;
	}
	int mid=l+r>>1;
	ll ret=cdq(l,mid)+cdq(mid+1,r);
	for(int i=l;i<=mid;i++)c[a[i]]=0;
	for(int i=l;i<=mid;i++)d[a[i]]=INF;
	for(int i=mid+1;i<=r;i++){
		if(d[a[i]]>n) d[a[i]]=i;
	}
	f1[mid]=f2[mid]=f5[mid]=h[a[mid]];f7[mid]=d[a[mid]];f6[mid]=c[a[mid]]=1;f3[mid]=f4[mid]=0;
	for(int i=mid-1;i>=l;--i){
		f1[i]=f1[i+1]+h[a[i]];
		if(!c[a[i]]) f2[i]=f2[i+1]+h[a[i]];
		else f2[i]=f2[i+1];
		++c[a[i]];
		if(c[a[i]]>f6[i+1])f4[i]=f4[i+1]+(f5[i+1]-h[a[i]])*f6[i+1],f6[i]=c[a[i]],f5[i]=h[a[i]],f7[i]=d[a[i]];
		else if(c[a[i]]==f6[i+1])f6[i]=f6[i+1],f5[i]=f5[i+1]+h[a[i]],f7[i]=min(f7[i+1],d[a[i]]),f4[i]=f4[i+1]-h[a[i]]*(f6[i]-1);
		else f6[i]=f6[i+1],f5[i]=f5[i+1],f4[i]=f4[i+1]+h[a[i]],f7[i]=f7[i+1];
		f3[i]=f6[i]*(f2[i]-f5[i])-f4[i];
	}
	for(int i=mid+1;i<=r;i++)c[a[i]]=0;
	f1[mid+1]=f2[mid+1]=f5[mid+1]=h[a[mid+1]];f6[mid+1]=c[a[mid+1]]=1;f3[mid+1]=f4[mid+1]=0;
	for(int i=mid+2;i<=r;++i){
		f1[i]=f1[i-1]+h[a[i]];
		if(!c[a[i]]) f2[i]=f2[i-1]+h[a[i]];
		else f2[i]=f2[i-1];
		++c[a[i]];
		if(c[a[i]]>f6[i-1])f4[i]=f4[i-1]+(f5[i-1]-h[a[i]])*f6[i-1],f6[i]=c[a[i]],f5[i]=h[a[i]];
		else if(c[a[i]]==f6[i-1])f6[i]=f6[i-1],f5[i]=f5[i-1]+h[a[i]],f4[i]=f4[i-1]-h[a[i]]*(f6[i]-1);
		else f6[i]=f6[i-1],f5[i]=f5[i-1],f4[i]=f4[i-1]+h[a[i]];
		f3[i]=f6[i]*(f2[i]-f5[i])-f4[i];
	}
	//2
	mp.clear();
	ll tmp=ret;
	for(int i=l;i<=mid;i++)mp[f3[i]]++;
	for(int i=mid+1;i<=r;i++)ret+=mp[f1[i]];
	mp.clear();
	tmp=ret;
	for(int i=mid+1;i<=r;i++)mp[f3[i]]++;
	for(int i=l;i<=mid;i++)ret+=mp[f1[i]];
	//1
	mp.clear();
	tmp=ret;
	for(int i=l;i<=mid;i++)mp[get(f1[i]%f2[i],f2[i])]++;
	for(int i=mid+1;i<=r;i++)ret+=mp[get((f2[i]-f1[i]%f2[i])%f2[i],f2[i])];
	//3
	mp.clear();
	tmp=ret;
	for(int i=mid+1;i<=r+1;i++) cnt[i]=0;
	for(int i=l;i<=mid;i++) cnt[min(r+1,f7[i])]++;
	for(int i=mid+2;i<=r+1;i++) cnt[i]+=cnt[i-1];
	for(int i=mid;i>=l;--i) p[cnt[min(r+1,f7[i])]--]=i;
	for(int i=1,j=mid+1;i<=mid-l+1;i++){
		while(j<min(r+1,f7[p[i]])) mp[get(f6[j],f3[j])]++,j++;
		ret+=mp[get(f6[p[i]],f4[p[i]])];
	}
	return ret;
}
mt19937_64 rnd;
void solve(){
	cin>>n;for(int i=1;i<=n;i++)cin>>a[i],h[i]=rnd();
	cout<<cdq(1,n)<<"\n";
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int T;cin>>T;while(T--) solve();
	return 0;
}
```

---


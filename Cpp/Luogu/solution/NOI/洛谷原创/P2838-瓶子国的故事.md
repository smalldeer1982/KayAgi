# 瓶子国的故事

## 题目背景

这是一道非传统题。

传说有一个国家叫瓶子国，里面有大大小小的瓶子。

现在瓶子国想要学习邻居跳蚤国发展计算机，可是瓶子国没有计算机只有瓶子。

于是瓶子国国王就给了你一些瓶子，让你实现一些计算任务。


## 题目描述

我们用水的量来描述一个数。

- 一个瓶子的容量为它最多可以装的水的数量。

瓶子国国王认为瓶子可以干这些事：

- $\verb!I!$：制造一个新瓶子，它的容量和里面装的水量都为输入的数，这个瓶子的编号为 $\textbf{当前最大编号} +1$。
- $\verb!F !s$；把编号为 $s$ 的瓶子里的水倒满。
- $\verb!E !s$：把编号为 $s$ 的瓶子里的水倒空。
- $\verb!C !s$：制作一个新瓶子，它的容量为 $s$，里面没装水，这个瓶子的编号为 $\textbf{当前最大编号} +1$。注意由于瓶子容积有限，$0\le s\le 10^9$。
- $\verb!M !s$：制作一个新瓶子，它的容量为 $\textbf{s 号瓶子里装的水的数量}$，里面没装水，这个瓶子的编号为 $\textbf{当前最大编号}+1$。
- $\verb!T !a\ b$：把 $a$ 瓶往 $b$ 瓶倒水，直到 $a$ 瓶空或者 $b$ 瓶满为止。（注意 $a\neq b$）。
- $\verb!O !s$：把 $s$ 号瓶子里的水输出。

还有一种昂贵的操作：

- $\verb!K !a\ b$：制作一个新瓶子，它的容量为 $\textbf{a 号瓶子的容量} \times \textbf{b 号瓶子的容量}$，这个瓶子的编号为 $\textbf{当前最大编号}+1$。注意由于瓶子容积有限，$\textbf{a 号瓶子的容量}\times\textbf{b 号瓶子的容量}$，不能超过 $10^9$。（使用这种操作要扣分，评分规则详见下方提示）

现在瓶子国国王把这些操作给了你，你只要输出这些操作，瓶子国的瓶子们就会为你执行！

瓶子国国王给了你一些计算任务，你只需要实现这些任务就行啦！

左边是数据点编号，右边是计算任务。

1. 输入 $a$ 和 $b$，计算 $a+b$。（$0\le a,b\le 10^5$）
2. 输入 $a$ 和 $b$，计算 $|a-b|$。（$0\le a,b\le 10^5$）
3. 输入 $a$ 和 $b$，计算 $\max(a,b)$。（$0\le a,b\le 10^5$）
4. 输入 $a$ 和 $b$，输出 $\gcd(a,b)$。（$1\le a,b\le 1000$）
5. 输入 $a$，输出 $a$ 的 $32$ 位二进制表示。（$0\le a\le 10^5$，例如 $5$ 输出 $\verb!0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1!$）
6. 输入 $a$ 和 $b$，输出 $a\times b$。（$0\le a,b\le 1000$）
7. 输入 $a$ 和 $b$，输出 $a\oplus b$。（$0\le a,b\le 10^5$，$\oplus$ 表示异或）
8. 输入 $a$，输出 $a\div 10$ 下取整。（$1\le a\le 10000$）
9. 输入 $a$ 和 $b$，输出 $a\times b \bmod 262144$。（$0\le a,b\le 10^5$）
10. 输入 $a$ 和 $b$，输出 $a$ 的 $b$ 次方。（$1\le a,b\le 1000$，$a$ 的 $b$ 次方不超过 $10^6$）

瓶子国国王会生成 $30$ 组**左右**的数据对你的程序进行测试，并根据你使用的操作个数进行评分，评分规则详见下方提示。

（**UPD**：如果你没有看懂题目这里有一段补充说明）

你**提交到洛谷的程序**（C/C++/Pascal）需要输出一段操作，格式类似样例输出。

例如第一个点，提交后洛谷上的 checker 会随机生成 $a$ 和 $b$ 作为 $\verb!I!$ **操作的输入**来测试你的操作。

对于本地 checker（下载见提示区），你可以把输出的操作保存成 `a.txt`，然后第一行输入 `a.txt`，第二行如果手玩就输 $0$，如果测试指定点就输编号。


## 说明/提示

请注意提交的是一段**输出操作的程序**！（如果你生成答案之后把生成它的程序删了直接打表输出，可能会输出超限）

灵感来自 NOI2016 旷野大计算（其实我不说你们肯定也知道啊）

为了方便选手本地测试，下面是一个 C++ 的本地checker（需要注意的是，它的测试结果与洛谷上的测试结果不一定一样，洛谷上可能更严格）：

- http://paste.ubuntu.com/23070332/

如果需要下载 exe 的话可戳度盘：

- http://pan.baidu.com/s/1o7HZ1GY 密码为 `kqhl`。

### 评分规则

如果你的算法输出了错误结果（多输出也算）或者发生运行错误（操作不符合要求等）或者行数超过 $5\times 10^6$ 行或者行数太长了 checker 没能在 $1s$ 内测试完 $30$ 组数据，你将获得 $0$ 分。

否则，假设 std 的步数为 $s$，你的步数为 $x$。

- 如果 $x\le s$，你的基准分为 $10$ 分。
- 如果 $s<x\le s+5$，你的基准分为 $9$ 分。
- 如果 $s+5<x\le 3s$，你的基准分为 $8$ 分。
- 如果 $3s<x\le 10s$，你的基准分为 $7$ 分。
- 如果 $10s<x\le 50s$，你的基准分为 $6$ 分。
- 如果 $x>50s$，你的基准分为 $5$ 分。

如果你使用了昂贵的 $\verb!K!$ 操作，你会得到（基准分 $-4$）分。

否则你会得到基准分。

（说人话：步数越少分越高，用K操作扣4分）

（**UPD2：洛谷上的checker常见错误信息**）

```cpp
too many lines：超过500w行（这个似乎还没有触发过）
WTF：就是操作的第一个字符串（I/T/K/F/E/C/M/O）长度大于1
（可能是由于上一个操作多跟了一个操作数？）
wrong operation：操作的第一个字符串长度为1但不是I/T/K/F/E/C/M/O。
expected *****：希望输入一个数/字符串却没有（可能是操作数多打/少打）
nothing to input：I操作数量大于输入的数数量
F/E/C/M/T/O/K wrong bottle：操作的瓶子编号不在[1,当前最大编号]范围内
C exceed [0,10^9]：字面意思
K exceed 10^9：字面意思
wa on test xxx：你在第xxx组随机数据狗带了
wa on extratest xxx：你在第xxx组人工数据（手打的）狗带了
```

## 样例 #1

### 输入

```
233
// 仅作为参考，这里应该填数据编号```

### 输出

```
I
C 1
F 2
C 233333
T 1 3
T 2 3
O 3
（这个程序可以进行x+1！是不是很厉害啊！不过程序中并不能附加任何注释）```

# 题解

## 作者：SSerxhs (赞：26)

思维题，以下数字均指的是瓶子

task1：略，只要会IO就行

task2：利用task3可以得到min和max，后面相减即可

task3：以2为大小制造3，把1倒入3，然后1和2倒入一个无限大的瓶子4中，则4为max而3为min

证明：1多于2时，3的大小只有2，只装了2的水量；1少于2时，3只能倒进1那么多水。1、2剩下的水都进了4，由于$a+b=min(a,b)+max(a,b)$，所以4是max

task4：辗转相减1000次即可，这里甚至不需要task2的绝对值，直接暴力轮换减就好了，从这个task开始需要写代码输出代码

task5：前15个瓶子直接输出0，难点在于如何不使用判断处理去掉当前位的操作。考虑封装一个倍增函数（即可以任意获取$2^k$)（后面很有用），设当前处理x号瓶处理到二进制第k位，设$y=2^k$，则制造一个大小为y的瓶子z把x瓶水倒入，然后按照x剩余水量构造一个瓶子a并把它倍增到足够大，把z倒入a中再把z倒回x中即消除了第k位。证明：当第k位是0时，倍增出来的也是0等于没干；当第k为是1时，相当于瓶子z里的水被消除，大小正好为$2^k$

task6：利用task5转化为二进制然后暴力相乘，相乘方法：设是二进制下第i位与第j位相乘，则取min之后倍增i+j次即可，然后累加到答案瓶

task7：直接用task5+task2即可

task8：这里建议封装一个带余除法，下一个task可以用。除法很好实现（类似task5），关键也在于取模。考虑拓展task5的思路，task5相当于实现了if (x>=p) x-=p，则我们只要多做几次这个过程就可以实现取模。

task9：直接用task6和task8即可

task10：考虑a=2时b<=19，而a=1时b取几都无所谓，不妨设$b\leq19$。则$ans=max(min(a^i,inf*[max(b-i,0)>0)])$，其中i在max中枚举。$a^i$可以调用task6暴力算，$inf*[max(b-i,0)>0)]$可以取出max之后不断倍增。

献上超长代码

```cpp
#include <stdio.h>
#include <string.h>
const int N=1002,inf=1e9;
int n,ps,i,j,x,y,z,k,ans,kk;
int a[N],b[N];
inline void I()
{
    printf("I\n");++ps;
}
inline void O(int x)
{
    printf("O %d\n",x);
}
inline void C(int x)
{
    printf("C %d\n",x);++ps;
}
inline void F(int x)
{
    printf("F %d\n",x);
}
inline void E(int x)
{
    printf("E %d\n",x);
}
inline void M(int x)
{
    printf("M %d\n",x);++ps;
}
inline void T(int x,int y)
{
    printf("T %d %d\n",x,y);
}
inline void minmax(int a,int b,int &c,int &d)
{
    M(b);
    T(a,ps);c=ps;
    C(inf);
    T(a,ps);T(b,ps);d=ps;
}
inline void min(int a,int b,int &c)
{
    M(b);
    T(a,ps);c=ps;
}
inline void fb(int x)
{
    M(x);F(ps);T(ps,x);
}
inline void toer(int x,int *a)
{
    M(x);F(ps);
    C(n);
    while (n)
    {
        M(ps-1);x=ps;
        C(n-1);
        T(ps-3,ps-2);
        T(ps-2,ps);
        M(ps-2);
        F(ps);a[20-j]=ps;
        if (n==1) break;
        T(ps-1,ps-3);
        C(1);
        F(ps);
        T(ps,ps-4);C(inf);T(ps-1,ps);z=ps;
        for (i=1;i<=j;i++) fb(z);
        M(z);
        F(x);
        T(x,ps);
        M(x);
        F(ps);
        n>>=1;--j;
        C(n);
    }
}
inline void times(int x,int y,int &z,int l1,int l2,int spe,int nosplit)
{
    int i,k;
    C(inf);
    z=ps;n=l1;j=l2;
    toer(x,a);
    if (!nosplit)
    {
        n=l1;j=l2;toer(y,b);
    }
    for (i=20-l2;i<=20;i++) for (j=20-l2;j<=20;j++) if (i+j>=21)
    {
        if ((spe)&&(40-i-j>=18)) continue;
        M(a[i]);F(ps);
        min(ps,b[j],x);
        C(inf);T(x,ps);x=ps;
        for (k=1;k<=40-i-j;k++) fb(x);
        T(x,z);
    }
}
inline void yfb(int x,int &y)
{
    M(x);F(ps);C(inf);T(x,ps);T(ps-1,ps);y=ps;
}
inline void divide(int w,int x,int &y,int lim,int anj)
{
    int cz;
    int kkk,sc;
    C(inf);y=ps;
    for (i=1;i<=lim;i++)
    {
        C(x);a[i]=ps;
        T(w,ps);if (anj==0) continue;
        M(ps);F(ps);C(x);T(ps-1,ps);C(1);F(ps);T(ps,ps-1);M(ps);F(ps);
        cz=ps;
        for (j=1;j<=7;j++) yfb(cz,cz);
        C(anj);F(ps);
        min(ps,cz,kkk);
        M(kkk);
        T(kkk,y);
    }
    if (x==10) return;
    for (i=1;i<=lim;i++)
    {
        C(x);F(ps);M(a[i]);T(ps-1,ps);M(a[i]);F(ps);
        min(ps-2,ps,kkk);
        for (j=1;j<=8;j++) yfb(kkk,kkk);
        M(kkk);
        T(a[i],ps);T(ps,w);T(a[i],ps);T(ps,w);T(a[i],ps);T(ps,w);T(a[i],ps);T(ps,w);
    }
}
int main()
{
    scanf("%d",&n);
    if (n==10)
    {
        I();I();
        C(1);F(3);y=3;
        C(1);ans=ps;M(1);F(ps);n=524288;j=19;toer(ps,b);
        for (k=1;k<=19;k++)
        {
            times(y,ps,y,524288,19,0,1);
            M(y);x=ps;F(x);
            C(1);T(2,ps);
            C(inf);T(ps-1,ps);z=ps;
            for (i=1;i<=20;i++) fb(z);
            min(x,z,x);
            minmax(x,ans,x,ans);
        }
        O(ans);
        return 0;
    }
    if (n==1)
    {
        I();
        I();
        printf("C 100000000\n");
        printf("T 1 3\n");
        printf("T 2 3\n");
        printf("O 3\n");
        return 0;
    }
    if (n==2)
    {
        I();
        I();
        printf("M 2\n");
        printf("T 1 3\n");
        printf("C 99999999\n");
        printf("T 1 4\n");
        printf("T 2 4\n");
        printf("M 3\n");
        printf("T 4 5\n");
        printf("O 4\n");
        return 0;
    }
    if (n==3)
    {
        I();
        I();
        printf("M 2\n");
        printf("T 1 3\n");
        printf("C 99999999\n");
        printf("T 1 4\n");
        printf("T 2 4\n");
        printf("O 4\n");
        return 0;
    }
    if (n==4)
    {
        n=2;
        I();I();
        for (i=1;i<N;i++)
        {
            printf("M %d\n",n++);
            printf("T %d %d\n",n-2,n);
            printf("C 99999999\n");++n;
            printf("T %d %d\nT %d %d\n",n-3,n,n-2,n);
            printf("M %d\n",n-1);++n;
            printf("T %d %d\n",n-1,n);
            printf("M %d\n",n-1);++n;
            printf("F %d\n",n);
        }
        printf("O %d\n",n);
        return 0;
    }
    if (n==5)
    {
        n=65536;j=16;
        I();
        C(inf);
        for (i=1;i<=15;i++) O(2);
        toer(1,a);
        for (i=4;i<=20;i++) O(a[i]);
        return 0;
    }
    if (n==6)
    {
        I();
        I();
        times(1,2,x,512,9,0,0);
        O(x);
        return 0;
    }
    if (n==7)
    {
        n=65536;j=16;
        I();
        I();
        C(inf);
        toer(1,a);
        n=65536;j=16;
        toer(2,b);
        for (i=4;i<=20;i++)
        {
            minmax(a[i],b[i],x,y);
            M(x);M(y);
            F(ps);T(ps,ps-1);C(inf);T(ps-1,ps);
            z=ps;
            for (j=1;j<=20-i;j++) fb(z);
            M(z);F(ps);T(ps,3);
        }
        O(3);
        return 0;
    }
    if (n==8)
    {
        I();
        divide(1,1000,x,10,100);
        divide(1,100,y,10,10);
        T(y,x);
        divide(1,10,y,10,1);
        T(y,x);
        O(x);
        return 0;
    }
    if (n==9)
    {
        I();I();
        times(1,2,x,65536,16,1,0);
        divide(x,262144,y,100,0);
        O(x);
        return 0;
    }
}
```


---

## 作者：xkcdjerry (赞：4)

以下列举各任务的解决方法，大多可以独立看，但是为了了解后面的任务的完成方式任务 $5$ 几乎是*必看*的。  
（为了方便寻找，小标题用**粗体**标记）

**板子：**  
先写一个 `struct` 封装瓶子的操作，后面就只会和这个 `struct` 打交道，再也不用碰底层实现了（避免手动输出的奇怪格式问题顺便简化代码）：
```c++
int cnt;
struct bt;

bt init(int sz=1000000000);
bt read();
void print(bt);
struct bt
{
    int i;
    bt(int index=-1){i=index;}
    //复制并返回一个与自己相同的瓶子
    bt copy(bool full=true)
    {
        printf("M %d\n",i); cnt++;
        if(full) printf("F %d\n",cnt);
        return bt(cnt);
    }
    //把b倒到a里
    void operator+=(bt b) {printf("T %d %d\n",b.i,i);}
    void empty(){printf("E %d\n",i);}//倒空瓶子
    void fill(){printf("F %d\n",i);}//灌满瓶子
    void operator<<=(int x)//封装左移（后面会用到）
    {
        bt t=init(); t+=*this;
        while(x--) t+=t.copy();
        i=t.i;
    }
};
//创建一个给定容量的新瓶子
bt init(int sz) {printf("C %d\n",sz);return bt(++cnt);}
bt read() {puts("I");return bt(++cnt);}
void print(bt x) {printf("O %d\n",x.i);}
void pour(bt a,bt b){b+=a;}
```

**任务 $1$：**  
不用解释  
```c++
void _1() //a+b
{
    bt a,b,c;
    a=read(),b=read(),c=init();
    c+=a;c+=b; print(c);
}
```

**任务 $2$：**  
创造空瓶子 `c` 和 `a` 一样大，空瓶子 `d` 和 `b` 一样大，然后 `a` 倒 `d`、`b` 倒 `c`。  
如果 $a>b$，`a` 中就会剩余 $a-b$ 而 `b` 为空，否则 `a` 为空而 `b` 剩余 $b-a$，显然两者中一者为 $|a-b|$ 而另一个为 $0$，两个相加即可。
```c++
void _2() //|a-b|
{
    bt a,b,c,d,e;
    a=read();b=read();c=a.copy(false);d=b.copy(false);
    c+=b;d+=a;e=init();e+=a;e+=b;
    print(e);
}
```

**任务 $3$:**  
创造空瓶子 `c` 和 `a` 一样大，把 `b` 倒入 `c` 中。  
如果 $b<a$，那么 `b` 为空， $a+b=a+0=\max(a,b)$  
如果 $b \geqslant a$，那么 `b` 为 $b-a$，$a+b=a+(b-a)=b=\max(a,b)$
```c++
void _3() //max(a,b)
{
    bt a,b,c,d;
    a=read(),b=read(),c=a.copy(false),d=init();
    c+=b;d+=a;d+=b;
    print(d);
}
```

**任务 $4$：**  
求 $\gcd$ 的常见方法为辗转相除法，但是由于无法取模不能使用此方法，但是可以考虑使用辗转相减法，即每轮使得 $a'=\max(a,b)-\min(a,b)$，$b'=min(a,b)$，至多重复 $\max(a,b)$ 轮即可得到答案。  
```c++
void _4() //gcd(a,b)
{
    bt a,b,c,d,e,f;
    a=read(),b=read();
    for(int i=0;i<1100;i++)
    {
        e=init();e+=a.copy(),e+=b.copy(); //求sum:e
        c=a.copy(false);c+=b;d=init();d+=a;d+=b; //求max:d
        f=d.copy(false);pour(e,f); //求min:e
        e=e.copy(false);pour(d,e); //max-=min
        a=d,b=e;//d:max-min e:min
    }
    print(a);
}
```

**任务 $5$：**   
***（非常重要的任务，后面很多任务都依靠任务 $5$ 完成）***   
首先考虑这个任务的思路：从大到小考虑每个二进制位，如果为 $1$ 就减去对应的数，然后输出二进制位所代表的数。（思路和代码均会反复出现）

对于第 $i$ 位（$2^i$）建立一个大小为 $2^i-1$ 的瓶子和一个大小为 $1$ 的瓶子，从一个复制的瓶子中先后倒入两个，则第二个瓶子中的水量为这一位的值。将大小为 $1$ 的瓶子左移 $i$ 位后用它去减 $a$ 瓶的水量即可。  
（注意 $a \leqslant 10^5$，所以前几位一定为 $0$，可直接输出 $0$ 省去一些步骤，也能避免创造大小 $>10^9$ 的瓶子）
```c++
void _5() //bin(a)
{
    bt a=read();
    //因为a<=1e6所以只有倒数20位可能为1
    bt tmp=init();for(int i=31;i>20;i--) print(tmp);
    for(int i=20;i>=0;i--)
    {
        int v=1<<i;
        bt b=a.copy(),c=init(v-1),d=init(1);
        pour(b,c);pour(b,d);//如果这位为1 d就为1
        print(d); d<<=i; pour(a,d.copy(false));//输出+减去
    }
}
```

**任务 $6$：**  
结合任务 $5$，可以对一个乘数（比如说 $b$）进行二进制拆分，如果第 $i$ 位为 $1$ 加上 $a \times 2^i$ 即可。  
具体方式为把该二进制位左移 $24$ 位（因为 $10^4 \times 10^4 < 2^{24} < 10^9$），然后向一个大小为 $a \times 2^i$ 的空瓶中倒水，最后把这个瓶子倒入答案瓶中。  
代码从任务 $5$ 的代码稍微改一下就行了： 
```c++
bt mul(bt a,bt B) //封装a*B
{
    bt ans=init();
    for(int i=20;i>=0;i--)
    {
        int v=1<<i;
        bt b=a.copy(),c=init(v-1),d=init(1),e,f,g;
        pour(b,c);pour(b,d);e=d.copy();
        d<<=i; pour(a,d.copy(false));
        e<<=25;f=B.copy(false);f+=e;//左移25位，ex现在为d==1?inf:0
        g=init();g+=f;//如果这位为0,g=0,否则g=B
        g<<=i;ans+=g;
    }
    return ans;
}
void _6() //a*b
{
    bt a=read(),B=read();
    print(mul(a,B));
}
```

**任务 $7$：**  
使用任务 $5$ 的代码同时分解 $a$ 和 $b$，然后分别求每一位的异或值，方法为把对应位加起来然后参考任务 $5$ 手写一个两位的二进制分解，第 $0$ 位就是异或值。  
```c++
void _7() //a^b
{
    bt a=read(),b=read();
    bt ans=init();
    for(int i=20;i>=0;i--)
    {
    	//t1为a对应位，t2为b对应位，t3为t1^t2
        bt t1,t2,t3;
        {
            int v=1<<i;
            bt c=a.copy(),d=init(v-1),e=init(1);
            pour(c,d);pour(c,e);//如果这位为1 e就为1
            t1=e.copy();
            e<<=i; pour(a,e.copy(false));//输出+减去
        }
        {
            int v=1<<i;
            bt c=b.copy(),d=init(v-1),e=init(1);
            pour(c,d);pour(c,e);
            t2=e.copy();
            e<<=i; pour(b,e.copy(false));
        }
        //仿照_5手写一个2位的二进制分解
        bt A,B,C,D,E,F;
        A=init();A+=t1;A+=t2;
        B=A.copy();C=init(1);C+=B;D=init(1);D+=B;
        //if D=1:A-=2
        F=init();F+=D; F<<=1;E=F.copy(false);E+=A;
        t3=init();t3+=A;
        t3<<=i;
        ans+=t3;
    }
    print(ans);
}
```

**任务 $8$：**  
先写一个帮手函数 `shear(a,v)`，效果为如果 `a` 中的水量 $\geqslant v$，就去掉 $v$ 的水并返回装 $1$ 水的瓶子，否则返回装 $0$ 水的瓶子。  
接下来利用任务 $5$ 的思路，通过 `shear(a,v)` 从高到低确定商的二进制位即可：
```
bt mul(bt a,int B)
{
    bt ans=init();
    for(int i=30;i>=0;i--) if((B>>i)&1)
        {bt b=init();b+=a.copy();b<<=i;ans+=b;}
    return ans;
}
bt shear(bt a,int v)
{
    //if(a>=v) a-=v,return 1
    //else return 0

    bt x=a.copy(),y=init(v-1),z=init(1),b=init(),c,d;
    y+=x; z+=x;
    b+=z.copy();c=mul(b,v).copy(false);c+=a;
    return z;
}
#define h8(a,ans,v) ans+=mul(shear(a,v),(v)/10)
void _8() //floor(a/10)
{
    //因为a<=10000,a/10<=1000
    bt a=read();
    bt ans=init();
    for(int i=10;i>=0;i--) h8(a,ans,10<<i);
    print(ans);
}
```

**任务 $9$：**  
会发现 $262144=2^{18}$，正常可以先利用任务 $6$ 中封装的 `mul(a,B)` 求出 $a \times b$ 的值然后再使用任务 $5$ 的代码取二进制最后 $18$ 位即可，但是由于 $a,b \leqslant 10^5$，即 $a \times b \leqslant 10^{10}$ 超出了瓶子的大小限制，所以需要边乘边模，具体方式为修改 `mul(a,B)` 的代码，若 `ans+=g<<i`，则先切除 `g` 后 $18-i$ 位前的所有二进制位，然后完成加操作之后再取一遍 `ans` 的后 $18$ 位。  
这里为了比较清晰写了一个帮手函数 `cut(a,v)`，用于切除 `a` 除了后 `v` 位之外的二进制位。
```c++
void cut(bt a,int v)
{
    for(int i=20;i>=v;i--)
    {
        bt b=a.copy(),x=init((1<<i)-1),y=init(1),z=init();
        x+=b;y+=b;z+=y;z<<=i;z.copy(false)+=a;
    }
}
void _9() //a*b mod 262144
{
    bt a=read(),B=read();
    bt ans=init();
    for(int i=20;i>=0;i--)
    {
        int v=1<<i;
        bt b=a.copy(),c=init(v-1),d=init(1),e,f,g;
        pour(b,c);pour(b,d);
        e=d.copy(); d<<=i; pour(a,d.copy(false));
        if(i>=18) continue;
        e<<=24;f=B.copy(false);f+=e;
        //如果这位为0,g=0,否则g=B
        g=init();g+=f;cut(g,18-i);
        g<<=i;ans+=g;cut(ans,18);
    }
    print(ans);
}
```

**任务 $10$：**  
看起来很离谱但是不难，只需要把任务 $5$ 中的加法改成乘法即可，注意 $5$ 中的 $a \times 2^i$ 在此处变为了 $a^{2^i}$，不能直接左移了，需要预处理出 $a^{2^i}$ 的答案。
```c++
void _10()
{
    bt a=read(),B=read();
    bt ans=init(),_1=init(1);
    _1.fill(); ans+=_1;
    bt tmp[30];
    //tmp[i]=a^(2^i)
    tmp[0]=a.copy();
    for(int i=1;i<=20;i++) tmp[i]=mul(tmp[i-1].copy(),tmp[i-1].copy());
    for(int i=20;i>=0;i--)
    {
        int v=1<<i;
        bt b=B.copy(),c=init(v-1),d=init(1),e,f,g;
        pour(b,c);pour(b,d);//如果这位为1 d就为1
        e=d.copy();
        d<<=i; pour(B,d.copy(false));//减去1<<i
        //左移24位，如果d为1的话等效于无穷大，否则为0
        e<<=24;f=tmp[i].copy(false);f+=e;
        //如果这位为0,f=0,否则f=tmp[i]
        _1.fill();f+=_1;//防止f=0，同时f=tmp[i]的话不影响
        ans=mul(ans,f);
    }
    print(ans);
}
```

**主程序：**  
定义一个帮手宏利用 `switch` 语句简单完成，画上完美句号。  
~~三万年了，`switch` 语句终于派上用场了。~~
```c++
#define T(i) case i:_##i();break
int main()
{
    int x;
    scanf("%d",&x);
    switch(x) {T(1);T(2);T(3);T(4);T(5);T(6);T(7);T(8);T(9);T(10);}
}
```

[AC 记录](https://www.luogu.com.cn/record/83713737)

**完结撒花*★,°*:.☆(￣▽￣)/\$:*.°★* 。**

---

## 作者：sky_landscape (赞：3)

在正文之前，有一些小提醒：

不要习惯性的写条件语句，时刻记住只能使用瓶子。

瓶子的水量和容积不要搞混了。

制作瓶子的容积是有限的，上界为 $1e9$。

尽量不要把写一些无意义的操作，可能会导致超过步数上限，一般正常写上限很松。

后面的测试点会经常使用之前的函数，一定要写好封装，最好把各类操作也封装起来。

我封装的操作：
```cpp
int input(){cout<<"I"<<"\n";return ++cnt;}
void output(int x){cout<<"O "<<x<<"\n";}
int make(int siz){cout<<"C "<<siz<<"\n";return ++cnt;}
int copy(int s){cout<<"M "<<s<<"\n";return ++cnt;}
void pour(int x,int y){cout<<"T "<<x<<" "<<y<<"\n";}
void fill(int x){cout<<"F "<<x<<"\n";}
void empty(int x){cout<<"E "<<x<<"\n";}

```
## $1.a+b$
注意到 $a$ 和 $b$ 的范围很小，直接制作一个容积为上界的瓶子都倒进去即可。
```cpp
int add(int a,int b){
    int ans=make(INF);
    pour(a,ans),pour(b,ans);
    return ans;
}
```
再次注意返回的是瓶子。

## $3.max(a,b)$
第 $2$ 个数据点需要调用第 $3$ 个测试点。

注意到 $T$ 操作里 $a$ 瓶水量不够或者 $b$ 瓶已经装满都会停下来。那么把 $a$ 瓶里的水倒到一个和 $b$ 瓶容积相同的水瓶 $c$ 里，这个 $c$ 瓶里的水就是 $a,b$ 瓶水量的较小值。求出了最小值，把剩下的水倒在一起就是最大值。

我觉得读者应该能看懂，但是还是放个图吧，以 $a<b$ 的情况举例。

![](https://cdn.luogu.com.cn/upload/image_hosting/miqforlw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$c$ 瓶是复制的 $b$ 瓶，$d$ 瓶是容积为上界的瓶子，把 $a$ 瓶的水倒进 $c$ 瓶，再把 $a,b$ 瓶里剩下的所有水倒进 $d$ 瓶里，$d$ 瓶里的水量就是 $max(a,b)$。

写操作 $3$ 的时候建议传一个 $pair$ ，同时返回最小值和最大值，后面的测试点有用。
```cpp
pii minmax(int x,int y){
    int nw=copy(y);pour(x,nw);
    return (pii){nw,add(x,y)};
}
```

## $2.\left | a-b \right | $
发现了吗，我们直接用最大值减最小值就行了。
```cpp
int del(int a,int b){
    pii p=minmax(a,b);
    int nw=copy(p.first);pour(p.second,nw);return p.second;
}
```

## $4.\gcd(a,b)$
考虑正常计算最大公因数一般使用辗转相除法。但是我们发现在这题里实现带余除法是一件很困难的操作。

实际上，第 $7$ 个数据点就是对 $10$ 做除法，做一次除法需要约 $1500$ 次操作，辗转相除法需要 $\log a$ 次除法，在 $a,b\le 1000$ 的限制下完全不如直接把一次除法拆成多次减法，实现类似的操作。

至于怎么做减法，上面就有。

```cpp
int gcd(int a,int b){
    pii p=minmax(a,b);
    a=p.first,b=p.second;
    for(int i=1;i<=1000;i++){
        a=copy(a),pour(b,a);
        pii p=minmax(a,b);
        a=p.first,b=p.second;
    }
    return b;
}
```

## $5.$ 二进制表示
到了这个点本题才开始上难度，这同样也是后半部分的重要操作。不难想到肯定是要用倍增，但是关键在于我们现在甚至无法完成这样一个操作：
```cpp
if(a>=b) a-=x;
```
倍增时我们确定一个位置能否填 $1$ 后是没办法更改剩余水量的。

而 $2$ 数据点只能返回绝对值，是无法完成这个操作的。

观察一下现在能做什么，倍增过程中枚举到第 $i$ 位（从低到高数第 $i$ 位）时，可以创建两个瓶子，一个容积是 $2^i-1$，一个容积是 $1$，先倒到前一个瓶子里，再把剩下的水倒到后一个瓶子里，后一个瓶子里的水量就是这个二进制位的值。

还是画个图，把现在的水量记为 $x$，如果 $x<2^i$，就倒不到后一个瓶子：

![](https://cdn.luogu.com.cn/upload/image_hosting/prs8xm6v.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

而如果 $x\ge 2^i$ 就可以：

![](https://cdn.luogu.com.cn/upload/image_hosting/wfu7l2j5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

尝试实现如果后一个瓶子中有水，把 $x$ 的水量减去 $2^i$ 的操作。

不难发现可以新开一个和后一个瓶子一样的瓶子 $a$，把 $a$ 的水量左移 $i$ 位，把 $a$ 倒空，再用 $x$ 填满 $a$ 即可，因为如果后一个瓶子里没有水，$0$ 怎么左移都还是 $0$。

这个操作的实现是简单的，每左移一位创建一个容积无限的瓶子，把 $a$ 倒进去两次，把这个瓶子里的水用 $M$ 操作复制出来即可。

```cpp
int lft(int a,int x){
    int nw=make(INF),aa=copy(a);
    fill(aa);pour(aa,nw);
    for(int i=1;i<=x;i++){
        fill(aa),pour(aa,nw);
        aa=copy(nw);
    }
    return aa;
}
```

请注意，这份代码最后没有把瓶子填满。

下面是数据点 $5$ 的代码：
```cpp
int *split(int x,int maxn=16){
    int zero=make(0);
    x=copy(x);fill(x);
    int *res=new int[K];
    for(int i=31;i>maxn;i--) res[i]=zero;
    for(int i=maxn;i>=0;i--){
        int a=make((1<<i)-1),b=make(1);
        int nw=copy(x);fill(nw);
        pour(nw,a),pour(nw,b),res[i]=b;
        b=lft(b,i),fill(b),x=del(x,b);
    }
    return res;
}
```
这个数据点有个小细节，根据范围二进制只有后 $16$ 位有值，但是这个函数是后面的关键函数，建议传一个开始处理的位置，也就是代码里的 $maxn$。

## $6.a\times b$
不难想到先把 $a$ 二进制分解，如果第 $i$ 位有值把答案加上 $b\times 2^i$ 即可，判断第 $i$ 位有没有值还是之前的套路，把 $a_i$ 左移很多位，如果有值容积会很大，直接把 $b\times 2^i$ 倒进去。

关于处理 $b\times 2^i$，可以从低位向高位枚举，没经过以为把 $b$ 左移一位（左移操作再上面）。
```cpp
int mul(int x,int y,int maxn=16,int siz=16){
    int nw=make(INF);
    int *a=split(x,maxn);
    y=copy(y),fill(y);
    for(int i=0;i<=siz;i++){
        a[i]=lft(a[i],24);
        pour(y,a[i]),fill(y),pour(a[i],nw);
        y=lft(y,1),fill(y);
    }
    return nw;
}
```
## $7.a\oplus b$
这个点纯送分，用数据点 $5$ 把 $a,b$ 二进制拆分后，每一问用数据点 $2$ 相减算绝对值即可。

注意不要输出二进制以后的一串瓶子，最后记得化成十进制数。
```cpp
int _xor(int x,int y,int maxn=16){
    int zero=make(0);
    int *res=new int[K],*a=split(x),*b=split(y);
    for(int i=maxn;i>=0;i--){
        res[i]=del(a[i],b[i]);
    }
    int nw=make(INF);
    for(int i=maxn;i>=0;i--){
        res[i]=lft(res[i],i),fill(res[i]);
        pour(res[i],nw);
    }
    return nw;
}
```

## $8.\left \lfloor \frac{a}{10} \right \rfloor $
如果想骗分的话用数据点 $5$ 实现的：
```cpp
if(a>=b) a-=x;
```
一个个减可以获得 $8$ 分。

我们需要完成一个带余除法（余数后面有用），基础逻辑还是倍增，首先预处理 $y\times 2^i$，循环里算步数太多，然后还是用数据点 $5$ 实现的那个条件语句直接算就行了。
```cpp
int chu(int x,int y,int opt,int maxn=16){
    int nw=make(INF);
    int *res=new int[K];
    res[0]=make(y),fill(res[0]);
    for(int i=1;i<=maxn;i++) res[i]=lft(res[i-1],1),fill(res[i]);
    for(int i=maxn;i>=0;i--){
        //cout<<"i: "<<i<<"\n";
        int a,e=make(1),fx=copy(x);fill(fx);
        pour(res[i],e),empty(e),a=copy(res[i]);
        pour(fx,a),pour(fx,e),e=lft(e,i),fill(e),pour(e,nw),fill(e),e=lft(e,maxn-i+1);
        fill(res[i]),pour(res[i],e),x=del(x,e);
    }
    if(opt==1) return nw;
    else return x;
}
```

代码里 $opt=1$ 算的是商，$opt=2$ 算的是余数。

## $9.a\times b \bmod 2^{18}$
$262144=2^{18}$ 应该都能看出来吧，这个数据点的主要难度在于值域太大，直接乘超过了上限。

如果把 $a,b$ 拆成二进制，答案是 $\sum 2^{i+j}a_ib_j$，如果 $i+j>18$，那么这对 $i,j$是完全没有贡献的。

所以可以把乘法做一点小改动，从低位到高位枚举 $a$ 的每个二进制位 $i$，每次把这个时候 $b$ 中代表原来 $b_{18-i}$ 的 $1$ 删掉，之所以说原来的是因为再前面写乘法的时候循环里会不断把 $b$ 左移，这样操作之后所有使得 $i+j>18$ 的 $j$ 都在之前被删掉了。

这样累加答案就不会超过上限了，最后做一次前面实现的带余除法即可。
```cpp
int mul2(int *a,int y){
    int *b=split(y,18),res=make(INF);
    for(int i=0;i<=18;i++){
        a[i]=lft(a[i],24),b[18-i]=lft(b[18-i],18),fill(b[18-i]),y=del(y,b[18-i]),y=copy(y),fill(y);
        pour(y,a[i]),fill(y),pour(a[i],res),y=lft(y,1),fill(y); 
    }
    return chu(res,(1<<18),2,20);
}
```

## $10.a^b$
终于只剩最后一个数据点了，这个数据点只是看起来可怕，实际上就是普通快速幂的逻辑，预处理出 $a^{2^i}$，把 $b$ 二进制拆分，如果这一位有值处理方法和数据点 $6$ 的一样。
```cpp
int qpow(int x,int y){
    swap(x,y);
    int *b=split(y),res[K],nw=make(INF),e=make(1);
    fill(e),pour(e,nw),res[0]=copy(x),fill(res[0]);
    for(int i=1;i<=5;i++) res[i]=mul(res[i-1],res[i-1]),res[i]=copy(res[i]),fill(res[i]);
    for(int i=5;~i;i--){
        b[i]=lft(b[i],25);
        pour(res[i],b[i]),fill(e);
        int m=minmax(b[i],e).second;
        nw=mul(m,nw,19,19);
    }
    return nw;
}
```

每个部分的代码都放了，就不放全代码了，影响观感。

---

## 作者：UKBwyx (赞：3)

## 前言
有些东西是很显然的，但本文会讲很多。  
并且由于作者比较感性理解，所以本文有些需要**感性理解**的部分。  
~~这两句话是不是有点矛盾~~  
本题的题意在此不再叙述了。
## $a+b$
这是简单的，直接开一个足够大的瓶子并将另外两个瓶子的水倒进去就行了。
```cpp
long long add(long long a,long long b) {//3步
	int t=C(inf);//开一个足够大的瓶子
	T(a,t);//把第一个瓶子的水倒进去
	T(b,t);//把第二个瓶子的水倒进去
	return t;//返回
}
```
读入 $2$ 步，过程 $3$ 步，答案 $1$ 步，总共 $6$ 步。
## $|a-b|$
这个瓶子的系统一看就很能做这个操作（直觉）。  

因为瓶子从 $a$ 往 $b$ 的倒水是倒 $\min(水量_a,容量_b-水量_b)$。

但是再推推应该会让人头晕。

刚好，我们在这里有下一个操作（更简单）。

## $\max(a,b)$
直觉来说，我们肯定要让一个瓶子的水倒到另一个里面。

因为这里的都是有关联的二元操作，而只有倒水是对两个有关联的。

**那就让 $b$ 为空，$a$ 的水倒到 $b$ 里面**。  
这里我用了一个瓶子的容量来表示这个瓶子（$b$ 是这个瓶子的容量）。

你可以想一下，因为除了 $a$ 和 $b$ 之外，你没有任何**比较特殊**的值（感性理解）。   
而 $a$ 、$b$ 都满或都空是意义不大的。

然后分讨一下（**接下来用 $w_x$ 表示容量为 $x$ 的瓶子的水量 或 编号为 $x$ 的瓶子的水量**） 。  
Ps：人话就是 读入的量对应的瓶子 和 我编号的瓶子 。

当 $a\le b$ 时  
$w_a=0$  
$w_b=a$  
当 $a>b$ 时  
$w_a=a-b$  
$w_b=b$

这个时候有两个思路，分别是对于 $w_b$ 和 $w_a$ 的，两个思路都没有那么难想，但也没有哪个更显然之说，但思路二的实现更优秀（步数更少）。

### 思路一

说实话这看起来一点都不好下手。

但是如果只观察 $w_b$ 的话会发现已经可以得到**最小值**了。

那么最大值也是简单的了，回忆一下第一个操作（即让我们求 $a+b$）。

两个数去掉较小的一个可以得到较大的一个（废话）。

$\max(a,b)=(a+b)-\min(a,b)$

但是你可能会发现它有一个减，感觉不太好弄。

这里直接讲一个技巧：  
**开一个容量为 $a$ 的水瓶，再用水量为 $b$ 的水瓶（$b\ge a$）往 $a$ 里倒水就得到了 $b-a$**。
```cpp
long long ma(long long a,long long b){//7步
  int t=C(inf);//开一个足够大的瓶子
  T(b,t);//给 b 清空并加进 t 里
  T(a,b);//a 倒向 b (b 里得到 min(a,b) 的水)
  F(a);//装满 a
  T(a,t);//把 a 加进 t 里(t 里这时有 a+b 的水)
  T(t,M(b));//t-=min(x,y)
  return t;
}
```

当然，这是不够好的（9 pts）。

### 思路二

观察 $w_a$，发现它也是和 $a$ 、$b$ 都相关的。   
前情提要：  
当 $a\le b$ 时  
$w_a=0$  
当 $a>b$ 时  
$w_a=a-b$ 

再看看我们要的答案：  
当 $a\le b$ 时  
$ans=b$  
当 $a>b$ 时  
$ans=a$

对比观察发现 $w_a+b$ 就等于 $ans$ 了。

```cpp
long long ma(long long a,long long b) {//4步
	int t=C(inf);//开一个足够大的瓶子
	T(a,t);//把第一个瓶子的水倒进去
	T(b,a);//这里是 b-min(a,b)，因为这里的 b 瓶子里装的刚好是 b-min(a,b)
	T(b,t);//把 (b-min(a,b)) 加到 a 里，得到 (a+b)-min(a,b)，即max(a,b)
	return t;
}
```
加上读入 $2$ 步，输出 $1$ 步，共 $7$ 步。  

前面的两种思路中，思路二更加的简洁且优雅，但是思路一的每一个地方都可以看作是解决一个**同样广泛的更简单的问题**。无论是求 $\min(a,b)$ 还是在这种系统下做减法，都是一个非常有用的子问题。
## 回到 $|a-b|$
很容易想到 $|a-b|=\max(a,b)-\min(a,b)$。  
最小值在 $\max(a,b)$ 的思路一已经提到过了，$a$ 往 $b$ 倒水后的 $b_w$ 就是 $\min(a,b)$。  
而对应的减法也在 $\max(a,b)$ 的思路一里提到了。  
PS：就是开一个容量为 $a$ 的水瓶，再用水量为 $b$ 的水瓶（$b\ge a$）往 $a$ 里倒水就得到了 $b-a$。

于是我们可以这么写：
```cpp
inline void de(long long a,long long b){//2步
	T(a,M(b));//开一个容量为 b 的水瓶，并用水量为 a 的水瓶往 b 里倒水
}//不会拼减法qwq
long long abs(long long a,long long b){//9步
	int t=ma(a,b);//之前的ma(a,b) 4步
	T(F(a),E(b));//这时 w[b]=min(a,b)
	de(t,b);//t-=b
	return t;
}
```
当然，这也是不够优秀的（9 pts）。

这个时候就需要优化了。

我们之前的操作（即 $\max(a,b)$）**并没有**和下面的代码衔接的这么完美，所以可以尝试从这里入手。

这里步数就算加上 $\max(a,b)$ 也比较小，可以尝试拆开 $\max(a,b)$ 用完后的 $a$、$b$ 的水量。

这个时候最好去**回看一下** $\max(a,b)$ 的四步解法。  

先看求完 $\max(a,b)$ 后剩下的 $w_a$。

（或者如果你先想到了 $w_b$，可以先尝试推一推。）

于是可以发现求 $\max(a,b)$ 其实是要用完 $b$ 的水的，所以 ```E(b)``` 这一步其实是**多余的**。
```cpp
inline void de(long long a,long long b){//2步
	T(a,M(b));//开一个容量为 b 的水瓶，并用水量为 a 的水瓶往 b 里倒水
}//不会拼减法qwq
long long abs(long long a,long long b){//8步
	int t=ma(a,b);//之前的ma(a,b) 4步
	T(F(a),b);//这里在之前 b 被清空过了
	de(t,b);//w[t]-=b
	return t;
}
```
~~当然这还还是不够优秀~~。

但是我们还有另一条路。

求完 $\max(a,b)$ 后 $w_a$ 的值其实也是**可利用的**。

事实上，这时 $w_a$ 就等于 $\min(a,b)$ 了。  
那这样实现也不难了。
```cpp
inline void de(long long a,long long b){//2步
	T(a,M(b));//开一个容量为 b 的水瓶，并用水量为 a 的水瓶往 b 里倒水
}//不会拼减法qwq
long long abs(long long a,long long b){//6步
	int t=ma(a,b);//之前的ma(a,b) 4步
	de(t,a);//w[t]-=min(a,b)
	return t;
}
```
加上读入 $2$ 步，输出 $1$ 步，共 $9$ 步。

我们最开始的做法虽然不够好，但是可以**直接用前面的东西**，这是很有帮助的。
## $\gcd(a,b)$
$\gcd(a,b)$ 看起来就是和前面几个截然不同的东西。

你大概可以猜到它是需要你使用上前面的东西的。

求 $\gcd$ 一般的做法是辗转相除法。

但这题的除法一点都不简单，所以可以用**更相减损术**（它的不需要除法的版本）。

不难发现 $\gcd(a,b)=\gcd(a-b,b)$。  
但是这样会有问题，如果这样递归，最后会变成 $\gcd(0,b)$。   
PS：$a$ 里的水在最后一次倒完了，所以是 $w_a=0$。

不难发现只要是小减大就会变成 $0$。

一种思路是之间算它们之间的绝对值，并保留其中的一个（这样就不用纠结于小减大还是大减小了）。

但是这样有可能会一直保留一个 $a$。

这里可以选择直接选择较小值（即 $\min(a,b)$）。

并且很好的一点是 $\min(a,b)$ 在前面计算 $|a-b|$ 时也可以算出来。
  
这里给一个流程图：  
$\gcd(a,b)\rightarrow \gcd(\min(a,b),|a-b|)\rightarrow \gcd(\min(\min(a,b),|a-b|),||a-b|-\min(a,b)|)$

这样可以证明当 $a$、$b$ 不等于 $0$ 时，一定有 $a+b>\min(a,b)+|a-b|=\max(a,b)$。  
人话就是每次操作 $a+b$ 至少减少 $1$（这里的 $a$、$b$ 指经过一些操作后，$\gcd$ 的第一项和第二项）。

而当 $b=0$ 时，$a$ 就是答案（当然我们不能直接输出 $a$）。  
接着就会在 $\gcd(ans,0)$ 和 $\gcd(0,ans)$ 里反复横跳。

而 $a,b\le1000$，所以不超过 $2000$ 次里一定会有一个变成 $0$，另一个是答案。

（~~其实上面的非常显然，应该不需要我这样讲。~~）

这样跑 $2000$ 次就行了，但怎么找到两个中哪个是答案呢？

这里其实不用很精细，所以取两个中最大值就行了。
```cpp
long long gcd(long long a,long long b) {//20000+4步
	for(int i=1; i<=2000; i++) {//10步
		int t=F(M(abs(a,b)));//这时 t 的上限和是 w[t] 都是 |a-b|
		a=F(M(a));//这时 a 里剩下的刚好就是 min(a,b)
		b=t;//其实这里是递推
	}
	return ma(a,b);//一个值一定是 0 ，另一个就是 ans 且一定>0
}
```
这样已经可以通过这个点了。  

但是这里的 $2000$ 有点误导性，这不是真正的上界，但是 $2000$ 的比较简单一点。

事实上，在辗转相减的过程中不仅是 $a+b$ 减少 $1$。  
前情提要：  
$a+b>\min(a,b)+|a-b|=max(a,b)$  

当 $\min(a,b)$ 和 $|a-b|$ 不等于 $0$ 时，$\max(a,b)=\min(a,b)+|a-b|>\max(\min(a,b),|a-b|)$。  
PS：$a>0$ 且 $b>0$， $a+b>\max(a,b)$

于是每次 $\max(a,b)$ 都至少会减少 $1$，而 $a,b\le 1000$，所以只要进行 $1000$ 次就行了。
```cpp
long long gcd(long long a,long long b) {//10000+4步
	for(int i=1; i<=1000; i++) {//10步
		int t=F(M(abs(a,b)));//这时 t 的上限和是 w[t] 都是 |a-b|
		a=F(M(a));//这时 a 里剩下的刚好就是 min(a,b)
		b=t;//其实这里是递推
	}
	return ma(a,b);//一个值一定是 0 ，另一个就是 ans 且一定>0
}
```
总步数几乎是 $10000$ 步（之后基本上是讲大概步数，因为限制没有那么紧）。
## $a$ 的 $32$ 位二进制表示
这个点个人认为是最有难度的一个点，反而后面的点没有那么难。

做这个点的时候，你可能需要适时地停下来想一想，我会在里面多次提到这点。

我们考虑怎么逐位分解。

通常来说，思路一般是是倒序从低到高，然后不断取最低位并除二，但是问题是我们**很难做到**除法。

这里就是最难的地方了，不能从低位到高位还能怎么搞。

它给我们的瓶子的系统似乎还差了点什么，没有它，我们就不能做到像真正的计算机一样。

但是，先让我们想想假设从高到低大概是怎么做的。

首先，只需要关注最后 $16$ 位。

从第 $16$ 位开始，怎么判断这位是 $0$ 还是 $1$ 呢？

让我们再看看瓶子的最重要的操作。
```
T a b 把 a 瓶往 b 瓶倒水，直到 a 瓶空或者 b 瓶满为止。
```
你在这里需要观察到的一点是 **瓶子的主要操作都是基于大小比较的**。

于是你或许能想到对于最高位，尝试把 $a$ 倒到一个和最高位一样大的瓶子里，然后**判断**这个瓶子是否为满就可以了。

注意到这一个操作**只能**对于最高位，但是可以通过把 $a$ 去掉这一位就可以了（但是现在还做不到）。

这里我已经尽可能的把这个思考过程说的合理了。

让我们把上面模糊的想法说得更清晰一点。

从最高位（第 $16$ 位）开始，一直到最低位：  
设 $i$ 表示当前的位数。  
如果 $w_a\ge2^i$ 那么 $ans_i=1$ 并且 $w_a\rightarrow w_a-2^i$。  
反之 $ans_i=0$。  

整理一下思路（最好再自己想想），这里就是最关键的地方了。  
注：这里给出一段分割用的空白，如果想好了再翻下去。
```
|
|
|
|
|
|
|
|
|
|
|
z
z
z
|
|
|
|
|
|
|
|
|
|
|
```
让我们想想这东西的难点在哪里。

先考虑 $ans$ 怎么求。

我们的大致思路是比较 $w_a$ 与 $2^i$ 的大小。

之前讲过的思路就是从 $w_a$ 倒水到 $2^i$ 的瓶子。

想要判断它是否为满可以让一个容量和水量都等于 $1$ 的瓶子往它里面倒。

再想想这又意味这什么。

我们能得到一个**布尔变量**（这里先不讲布尔变量的运算）作为两个瓶子大小比较的返回值。

接下来只有一个问题了，就是怎么当 $w_a\ge 2^i$ 时给它减去 $2^i$。

其实等价与 当 $ans_i=1$ 时，$w_a\rightarrow w_a-2^i$。

这样的差距看起来很大，因为 $ans$ 仅仅差了 $1$，$w_a$ 却差了 $ 2^i$，似乎是不可能做到的。

但是事实上由于这些东西是离散的，所以是可以做到的（这只是为了便于感性理解）。

或许你不太能想到怎么让 $w_a$ 变成 $w_a-2^i$，但是你应该能想到怎么让 $w_a$ 变成 $w_a-1$（在 $ans=1$ 的情况下）。

直接让 $w_a\rightarrow w_a-ans$ 即可。

那我们只需要让 $ans\rightarrow 2^ians$ 就可以了。

我们要对一个数乘一个常数，这里有一个很显然的做法。

**我们只需要开一个足够大的瓶子并把让 $a$ 往里面倒水 $c$ 次就可以得到 $a\times c$ 了**。

然后就可以算这个了，对于 $2^i$，对 $ans$ 进行 $i$ 次 $\times 2$ 操作。

具体的一些细节和实现可以看代码，不过在这里说一下为什么不能预处理出 $2^i$。

因为造 $2^i$ 中的每一个部分都是由 $ans$ 转化来的（这个是为了方便感性理解）。
```cpp
//返回的是w[x]*(1<<k),而不是x*(1<<k)(x表示x的容量),并且会改变x的水量
long long mul(long long x,long long k) {//5*k+2步
	if(k==0)return F(M(x));//返回一个容量为 x 且满的瓶子
	else {
    	int t=C(inf);//制造一个足够大的瓶子
        T(F(M(x)),t);//制造 1 个瓶子并倒入 t
        T(x,t);//把 x 里的水倒入 t（会改变x的水量）
		return mul(t,k-1);//递归实现
	}
}

struct bottle_2 {
	int a[30];//a 就是 ans
	void turn(int x) {//共大约 12*len+5*len*len/2 步
		for(int i=len; i>=0; i--) {//12+5i步
			int t=C(1<<i),t2=F(M(x));//t 是用来让 x 减少的，t2 是 x 的备份（否则 x 会改变）
			T(t2,t);//准备比较 t2 和 t 的大小
			int t1=F(C(1));//bool 变量
			T(t1,t);//判断 t 是否填满
			a[i]=F(M(t1));//复制一份答案（因为mul会改变t1的水量）
			T(x,M(mul(t1,i)));//x-=2^i*a[i]
		}
	}
	void prt() {//输出，不做解释
		int t=C(1);
		for(int i=31; i>len; i--) {
			O(t);
		}
		for(int i=len; i>=0; i--) {
			O(a[i]);
		}
	}
};
//这题len=16
```
这题大约是 $12\times 16+5\times 16\times 16 \div 2 =832$，但忽略了许多常数，实际跑出来是 $900$ 步，事实上我的实现一点都不优秀。

请允许我恭喜你，已经通过了最难的一部分（个人意见）。
## $a\times b$
一眼看上去很难。

但实际上把数转二进制后就是**高精度**。

我们可以直接返回一个答案，所以并不需要什么进位。

更具体的，直接对于所有 $i+j=k$，$\displaystyle ans\rightarrow ans+(\sum a_i\times b_j)\times 2^k$。  
PS：$a_i$ 表示 $a$ 转二进制后的第 $i$ 位。

然后不难发现两个布尔变量相乘就等于它们 **与** 的值。

所以我们只要能写出 **与门** 就行，这个是很简单的。

$x$ 与（这里的 “与” 是逻辑运算与） $y$ 是 $1$ 的充要条件是两个瓶子都是 $1$，所以直接求 $\min(a,b)$ 就行了。

更多细节见代码。
```cpp
long long ad(long long x,long long y) {
	int t=M(x),t1=M(y);//这里重写了一遍求最小值
	F(t1);
	T(t1,t);
	return t;
}
struct bottle_2 {
	int a[30];//a 就是 ans
	void turn(int x) {//共大约 12*len+5*len*len/2 步
		for(int i=len; i>=0; i--) {//12+5i步
			int t=C(1<<i),t2=F(M(x));//t 是用来让 x 减少的，t2 是 x 的备份（否则 x 会改变）
			T(t2,t);//准备比较 t2 和 t 的大小
			int t1=F(C(1));//bool 变量
			T(t1,t);//判断 t 是否填满
			a[i]=F(M(t1));//复制一份答案（因为mul会改变t1的水量）
			T(x,M(mul(t1,i)));//x-=2^i*a[i]
		}
	}
	void prt() {//输出，不做解释
		int t=C(1);
		for(int i=31; i>len; i--) {
			O(t);
		}
		for(int i=len; i>=0; i--) {
			O(a[i]);
		}
	}
    long long operator*(bottle_2 x) {//大约7*len*len
        int t=C(inf);//这个是答案（不是以二进制形式储存）
        for(int i=0; i<=2*len; i++) {
            int fz=C(inf);
            for(int j=max(0,i-len); j<=min(len,i); j++) {
                T(ad(a[j],x.a[i-j]),fz);//fz+=a[j]*b[i-j]
            }
            T(mul(fz,i),t);//t+=fz<<i;
        }
        return t;
    }
};
//这题 len=9
```
大约 $12\times 11\times 10=1320$ 步，实际跑出来是 $2000$ 步，还是比较多的。  
这里开始就是主要是在二进制下的运算了（第 $8$ 个点除外）。
## $a \oplus b$
这个很明显，主要需要的就是异或门。  
一种比较简单的想法就是用 与 和 非 造出异或。  
PS：非 是容易的，非 $a$ 就等于 $1-a$ 。

当然，我们可以这样写：
```
a^b=!(!(!a&b)&!(!b&a))
```
但这样还是太麻烦了。

还是利用之前写的部分。

其实 $a \oplus b$ 就等于 $|a-b|$。

然后就可以逐位异或了。

```cpp
long long xr(long long x,long long y) {
	return abs(x,y);
	//return nt(ad(nt(ad(nt(F(M(x))),F(M(y)))),nt(ad(F(M(x)),nt(F(M(y)))))));
}
struct bottle_2 {
	int a[30];//a 就是 ans
	void turn(int x) {//共大约 12*len+5*len*len/2 步
		for(int i=len; i>=0; i--) {//12+5i步
			int t=C(1<<i),t2=F(M(x));//t 是用来让 x 减少的，t2 是 x 的备份（否则 x 会改变）
			T(t2,t);//准备比较 t2 和 t 的大小
			int t1=F(C(1));//bool 变量
			T(t1,t);//判断 t 是否填满
			a[i]=F(M(t1));//复制一份答案（因为mul会改变t1的水量）
			T(x,M(mul(t1,i)));//x-=2^i*a[i]
		}
	}
	void prt() {//输出，不做解释
		int t=C(1);
		for(int i=31; i>len; i--) {
			O(t);
		}
		for(int i=len; i>=0; i--) {
			O(a[i]);
		}
	}
    long long operator*(bottle_2 x) {//大约7*len*len
        int t=C(inf);//这个是答案（不是以二进制形式储存）
        for(int i=0; i<=2*len; i++) {
            int fz=C(inf);
            for(int j=max(0,i-len); j<=min(len,i); j++) {
                T(ad(a[j],x.a[i-j]),fz);//fz+=a[j]*b[i-j]
            }
            T(mul(fz,i),t);//t+=fz<<i;
        }
        return t;
    }
  	long long operator^(bottle_2 x) {//5*len*len/2
		int t=C(inf);
		for(int i=0; i<=len; i++) {
			T(mul(xr(a[i],x.a[i]),i),t);//ans+=(a[i]^b[i])<<i（逐位异或）
		}
		return t;
	}
};
//这题 len=16
```
大约 $16\times 16\times 8=2048$ 步。
## $\lfloor \frac x{10}\rfloor$
这个点或许可以在二进制下尝试做除法，应该是可以的。

~~而且应该步数会很优秀~~

但是这里我直接用了另一种思路（不想改了 qwq）。

我们发现在 $2$ 进制下 $\lfloor \frac x2\rfloor$ 是简单的。

于是我们可以把它**转换成 $10$ 进制**。

设 $\displaystyle a=\sum_{i=0}^{4}k_i\times10^{i}(0\le k_i\le9)$。  
PS：就是 $a$ 的十进制分解。

这样的话对于所有 $k_i\times 10^i(i>0)$，我们把 $k_i\times 10^{i-1}$ 加入答案里就行了。

不过让我们先回忆一下**怎么转 $2$ 进制的**。

首先要创造一个大小为 $2^i$ 的瓶子。

对应的，我们在这里创作一个大小为 $10^i$ 的瓶子。

然后我们要让 $a$ 向这个大小为 $2^i$ 的瓶子里倒水，并判断它是否为满。

同样，我们要让 $a$ 向这个大小为 $10^i$ 的瓶子里倒水，并判断它是否为满。

（这里的思路就是仿照转二进制的。）

但是这里 $k_i$ 可能不止 $1$。

这里有一个比较暴力的想法，就是**让 $a$ 往里面尝试倒九次水，然后计数有多少个满的。**

然后转二进制的下一步是将 $w_a\rightarrow w_a-k_i\times 2^{i}$。

我们对应的就是 $w_a\rightarrow w_a-k_i\times 10^i$。

如果你还记得的话，我之前讲转二进制时有这么一段话。

**我们只需要开一个足够大的瓶子并把让 $a$ 往里面倒水 $c$ 次就可以得到 $a\times c$ 了**。

这里也是直接倒水 $10$ 次就行了。

其它的具体细节见代码。

```cpp
long long cf[5]= {1,10,100,1000,10000};//10^i
struct bottle_10 {
	long long mul(long long x,long long k) {//29*k
		if(k==0)return M(x);
		else {
			int t=C(inf);//开一个足够大的瓶子
			x=M(x);
			for(int i=1; i<=10; i++) {//往里面倒水 10 次
				T(F(x),t);
			}
			return mul(t,k-1);//递归实现
		}
	}
	int a[30];
	long long turn(int x) {
		long long res=C(inf);
		for(int i=4; i>=1; i--) {//大约 30*30*2 步
			long long times=9;
			if(i==4)times=1;//10000 做一次就行了
			long long fz=C(inf);
			for(int j=1; j<=times; j++) {//类似二进制的做法
				int t=C(cf[i]),t2=M(x);
				F(t2);
				T(x,t);
				int t1=C(1);
				F(t1);
				T(t1,t);
				a[i]=M(t1);
				F(a[i]);
				T(t2,mul(t1,i));
				T(a[i],fz);
				x=t2;
			}
			T(F(mul(fz,i-1)),res);
		}
		return res;
	}
};
```
大约 $30\times 30\times 2=1800$ 步，实际跑出来只有 $1700$ 步左右，常数还是很优秀的。

这题的解法应该不少，这里的解法实际上是对二进制的一个拓展，~~体现了瓶子系统功能的强大~~。
## $a\times b \mod 262144$
终于，只剩下了两个点。

这里补充一下数据范围（因为比较重要）。  
$0\le a,b\le10^5$

首先你肯定已经敏感地发现模数是什么了。

实际上这是 $2^{18}$。

但是这题的难点是 $a\times b$ 会大于 $10^9$。

于是我们考虑自然溢出（什）。

我们还是要回忆下怎么计算 $a\times b$ 的。

逐位相乘，具体来说是这样的：  
对于所有 $i+j=k$，$\displaystyle ans\rightarrow ans+(\sum a_i\times b_j)\times 2^k$。  
PS：$a_i$ 表示 $a$ 转二进制后的第 $i$ 位。

当然，很容易想到的一个优化当 $k\ge18$ 时，它一定是没有贡献的。

那么这样的最大值是多少呢？

考虑它的每两位相乘，增加的值都不超过 $2^{17}$，然后两个数最多会产生 $18\times 18$ 次贡献（每两位相乘）。

这样答案的最大值只有大约 $4\times 10^8$，不会爆 $10^9$。

但是还是有问题，还是要**给答案取模**。

于是我们可以想到之前的 $\div 10$。 
 
类似的，我们把答案转成二进制。

这次我们只取后 $18$ 位就行了（说实话这个有点废话）。

```cpp
struct bottle_2 {
	int a[30];//a 就是 ans
	void turn(int x) {//共大约 12*len+5*len*len/2 步
		for(int i=len; i>=0; i--) {//12+5i步
			int t=C(1<<i),t2=F(M(x));//t 是用来让 x 减少的，t2 是 x 的备份（否则 x 会改变）
			T(t2,t);//准备比较 t2 和 t 的大小
			int t1=F(C(1));//bool 变量
			T(t1,t);//判断 t 是否填满
			a[i]=F(M(t1));//复制一份答案（因为mul会改变t1的水量）
			T(x,M(mul(t1,i)));//x-=2^i*a[i]
		}
	}
	void prt() {//输出，不做解释
		int t=C(1);
		for(int i=31; i>len; i--) {
			O(t);
		}
		for(int i=len; i>=0; i--) {
			O(a[i]);
		}
	}
    long long operator*(bottle_2 x) {//大约7*len*len
        int t=C(inf);//这个是答案（不是以二进制形式储存）
        for(int i=0; i<=2*len; i++) {
            int fz=C(inf);
            for(int j=max(0,i-len); j<=min(len,i); j++) {
                T(ad(a[j],x.a[i-j]),fz);//fz+=a[j]*b[i-j]
            }
            T(mul(fz,i),t);//t+=fz<<i;
        }
        return t;
    }
  	long long operator^(bottle_2 x) {//5*len*len/2
		int t=C(inf);
		for(int i=0; i<=len; i++) {
			T(mul(xr(a[i],x.a[i]),i),t);//ans+=(a[i]^b[i])<<i（逐位异或）
		}
		return t;
	}
	long long to_int() {//大约 5*len*len/2
		int t=C(inf);
		for(int i=0; i<=len; i++) {
			T(mul(a[i],i),t);//逐位累加 
		}
		return t;
	}
	long long modmul(bottle_2 y) {//大约 26*len+35*len*len/2 
		int t=C(inf);//开一个 1e9 的瓶子作为答案 
		for(int i=0; i<=17; i++) {//枚举 i+j=k 的 k 
			int fz=C(inf);
			for(int j=0; j<=i; j++) {
				if(j>16||i-j>16)continue;//输入的位数不超过 17 位 
				T(ad(a[j],y.a[i-j]),fz);
			}
			T(F(mul(fz,i)),t);
		}
		len=29; 
		bottle_2 t1;
		t1.turn(t);//转 29 位 
		len=17;
		return t1.to_int();
	}
};
```  
由于我在里面加了一个优化导致不太好算。

所以假设去掉这个优化，这里大概是 $26\times 18+35\times 18\times 18\div 2=6138$ 实际上跑出来大概 $7000$ 步，常数也很大。 
## $a^b$
已经到最后一个点了吗。

$a^b$ 不难想到做 $b$ 次乘法。

**大概思路**是这样的：  
假设现在在做第 $i$ 次乘法时。  
如果 $b\le i$ 就让 $ans\rightarrow ans\times a$。  
否则不变。 

虽然 $a,b\le 1000$ 很不可做，但是有了 $a^b\le 10^6$ 后就看起来很可做了。

我们不能直接乘 $1000$ 次，于是考虑优化。

考虑当 $a\ge 2$ 时一定有 $b\le 19$。

而当 $a=1$ 时，无论 $b$ 是多少都一样。

所以我们只需要做 $18$ 次乘法（初值为 $a$）。

接着再来考虑每次乘法的具体实现。

我们利用转二进制时用到的类似思想。   
前情提要：  
我们能得到一个**布尔变量**作为两个瓶子大小比较的返回值。 

我们设这个布尔变量为 $c$。 

一种比较直接的想法就是让 $c=1$ 变成 $c=a$，$c=0$ 变成 $c=1$。

我们可以通过让 $c\rightarrow c\times （a-1）+1$做到这一点。   
 
但是由于我第一遍不是这么写的，所以这里用另一种方法。
 
我们可以这么想：   
在乘法的过程中加入一些东西使得返回的结果和 $c$ **高度相关**。  

我们想让 $c=1$ 时返回正常答案。  

这里的非常显然的一个处理是 $c=0$ 时最好返回一些有迹可循的东西（感性理解）。

我们可以 $c=0$ 时直接把它每一位搞成 $0$，这样返回的结果也就是 $0$ 了。

这个对它二进制分解后的每一位与上 $c$ 就可以了。

接着我这里的一个奇异的做法是把返回的结果和现在的结果取 $\max$。

大概就是，当 $c=0$ 时设 $t=0$。  
当 $c=1$ 时设 $t=a$。  
$ans=\max(ans,ans\times t)$
 
这样当 $c=0$ 时，$ans$ 就不会改变了。
```cpp
long long pw(long long x,long long y) {//大约 18*5*len*len
	long long now=M(x);//now 就是答案
	len=19;
	bottle_2 bas;
	bas.turn(x);
	T(y,C(1));//要做 y-1 次乘法（初值为 x）
	for(int i=1; i<=18; i++) {
		long long t1=C(1);//布尔变量
		T(y,t1);//这里的做法是每次减1，而不是大小比较
		for(int j=0; j<=9; j++) {
			bas.a[j]=ad(bas.a[j],t1);//如果 t1=0 则 bas=0，并且后面一直等于 0
		}
		bottle_2 now1;
		now1.turn(F(now));//用来做乘法的
		now=M(ma(F(now),F(M(now1*bas))));//ans=max(ans,ans*t)
	}
	return F(now);
}
```
最后大约是 $18\times 5\times 20\times 20=36000$ 步。

实际跑出来是 $120000$ 步，如果给乘法加个优化（上界不超过 $19$）那么能跑 $50000$ 步。

最后，在这里写一下我每个点的确切步数。

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 6 | 9 | 7 | 10007 | 935 | 2145 | 2639 | 1763 | 6891 | 49063 |

~~完结撒花~~

---

## 作者：a___ (赞：3)

[python 首A](https://www.luogu.com.cn/record/49422306)

自我感觉实现得很粗糙但比另外两个题解所用步数都少。。。

另外这题抄题解的很多，一眼看过去代码长度全部相同，打开一看全都一样。。。希望各位不要再抄了。

___

进入正题。  

本题包括以下操作：

读入一个数  
```python
def inbt():
    global tot
    print('I')
    tot+=1
    return tot
```

装满一个瓶子  
```python
def fullbt(a):
    print('F '+str(a))
```

清空一个瓶子
```python
def clearbt(a):
    print('E '+str(a))
```

制作一个新的空瓶子
```python
def newbt(a=1000000000):  # 默认容量为INF
    global tot
    print('C '+str(a))
    tot+=1
    return tot
```

制作一个新的空瓶子，容量等于某个瓶子的水量
```python
def copybt(a):
    global tot
    print('M '+str(a))
    tot+=1
    return tot
```

倒水
```python
def pourbt(a,b):
    print('T {} {}'.format(a,b))
```

输出水量
```python
def outbt(a):
    print('O '+str(a))
```

以下复合操作：

新的**满**瓶子
```python
def newfullbt(a):
    c=newbt(a)
    fullbt(c)
    return c
```

制作一个新的**满**瓶子，容量等于某个瓶子的水量
```python
def copyfullbt(a):
    c=copybt(a)
    fullbt(c)
    return c
```

制作一个**容量无限**的瓶子，水量等于某个瓶子的水量
```python
def copynewbt(a):
    c=newbt()
    pourbt(a,c)
    return c
```

___

1. 求 $a+b$   

直接开一个新瓶子，把 $a$ 和 $b$ 都倒进去就行
```python
def addbt(a,b):
    c=newbt()
    pourbt(a,c)
    pourbt(b,c)
    return c
```
1.5. 求 $\min(a,b)$

开一个空瓶子等于其中一个数，将另一个数倒入，之后新瓶子中的就是 $\min(a,b)$。    

解释：  
① 若新瓶子容量 $c=\max(a,b)$  
倒完后原新两瓶水量分别为 $0,\min(a,b)$  
② 若新瓶子容量 $c=\min(a,b)$  
倒完后原新两瓶水量分别为 $|a-b|,\min(a,b)$  

```python
def minbt(a,b):
    c=copybt(b)
    pourbt(a,c)
    return c
```

2. 求 $|a-b|$   

由上可知将两瓶来回倒之后剩余水量分别为 $0$ 和 $|a-b|$，求个和就好

```python
def subbt(a,b):
    c=copybt(a)
    d=copybt(b)
    e=newbt()
    pourbt(a,d)
    pourbt(b,c)
    pourbt(a,e)
    pourbt(b,e)
    return e
```

3. 求 $\max(a,b)$

由 $\max(a,b)=a+b-\min(a,b)$

发现求 $\min(a,b)$ 时倒完后两瓶水量其实为（假设倒的是 $a$） $a-\min(a,b),\min(a,b)$  
所以我们相当于需要新开一个瓶子倒入 $b$，然后倒入 $a-\min(a,b)$。  

```python
def maxbt(a,b):
    c=newbt()
    pourbt(b,c)
    pourbt(a,b)
    pourbt(a,c)
    return c
```

4. 求 $\gcd(a,b)$

更相减损术 $\gcd(a,b)=\gcd(\min(a,b),|a-b|)$  

由上求 $|a-b|,\min(a,b)$ 的方法，由于 $a,b\leq1000$，直接减 $1000$ 次就好

```python
def gcdbt(a,b,T):
    for i in range(T):
        x=subbt(a,b)
        a,b=x-1,x
    return addbt(a,b)
```

4.5.1. 求 $a\cdot2^n$  

将 $a=a+a$ 算 $n$ 次
```python
def pow2(a,n):
    if n>=1:
        a=copynewbt(a)
        for i in range(n):
            pourbt(copyfullbt(a),a)
    return a
```
4.5.1 求 $[a\geq2^n]$

开一个空的大小为 $2^n$ 的瓶子 $b$ 和一个满的大小为 $1$ 的瓶子 $c$，将 $a$ 倒入 $b$ ，再将 $c$ 倒入 $b$，此时的 $c$ 即为答案。
```python
b=newbt(2**n)
c=newfullbt(1)
pourbt(a,b)
pourbt(c,b)
d=copyfullbt(c)
```

4.5.3. 计算 $a=a-2^n[a\geq2^n]$

求出 $[a\geq2^n]$，给它乘一个 $2^n$，再拿 $a$ 减掉它就好。

```python
def modsubpow2bt(a,n):
    b=newbt(2**n)
    c=newfullbt(1)
    pourbt(a,b)
    pourbt(c,b)
    d=copyfullbt(c)
    pourbt(b,c)
    pourbt(b,a)
    pourbt(a,copybt(pow2bt(copyfullbt(d),n)))
    return d
```

5. 求 $a$ 的二进制表示

根据套路，从高往第枚举每一位 $i$，求 $[a\ge2^i]$ 并 $a=a-2^n[a\geq2^n]$。   

```python
def tobinarybt(a,L):
    res=[]
    for i in range(1,L)[::-1]:
        res.append(modsubpow2bt(a,i))
    res.append(a)
    return res
```

6. 求 $a\times b$   

龟速乘。  
对应 C++ 代码：  
```cpp
int mul(int a,int b)
{
    int res=0;
    while(b)
    {
    	res=res+a*(b&1);
        a=a+a;
        b>>=1;
    }
    return res;
}
```

考虑 `minbt(pow2bt(c,20),a)`，当 $c=0$ 时，答案为 $0$；当 $c=1$ 时，答案为 $a$；等价于 $a\cdot [c=1]$。

```python
def mulbt(a,b,L=10):
    b=tobinarybt(b,L)[::-1]
    a=copynewbt(a)
    res=newbt()
    for i in range(L):
        pourbt(copyfullbt(minbt(pow2bt(b[i],20),a)),res)
        pourbt(copyfullbt(a),a)
    return res
```

7. 求 $a\operatorname{xor}b$。

将 $a,b$ 都拆分成二进制，这一位的数应为 $(a[i]+b[i])\bmod2$。  
考虑 $a\bmod2=\min(a,2-a)$，有   
```python
def xorbt(a,b):
    a=tobinarybt(a,17)[::-1]
    b=tobinarybt(b,17)[::-1]
    res=newbt()
    for i in range(17):
        c=newbt(2)
        pourbt(a[i],c)
        pourbt(b[i],c)
        d=copybt(c)
        fullbt(c)
        pourbt(c,d)
        c=minbt(c,d)
        pourbt(pow2bt(c,i),res)
    return res
```

7.5.1. 计算 $a\times b$，其中 $b$ 是一个常数。

类比 $a\cdot2^n,a\times b$ 龟速乘即可。   
```python
def mulnumbt(a,b):
    a=copynewbt(a)
    res=newbt()
    while b:
        if b%2==1:
            pourbt(copyfullbt(a),res)
        pourbt(copyfullbt(a),a)
        b>>=1
    return res
```

7.5.2. 计算 $a=a-p[a\geq p]$，其中 $p$ 是一个常数。

类比 $a=a-2^n[a\geq2^n]$。  
```python
def modsubnumbt(a,p):
    b=newbt(p)
    c=newfullbt(1)
    pourbt(a,b)
    pourbt(c,b)
    d=copyfullbt(c)
    pourbt(b,c)
    pourbt(b,a)
    pourbt(a,copybt(mulnumbt(copyfullbt(d),p)))
    return d
```

7.5.3. 求 $a$ 的 $k$ 进制表示。   

类比 $2$ 进制表示，注意每一位 $a=a-p[a\geq p]$ 要做 $k-1$ 次。   
```python
def todigitsbt(a,k):
    res=[]
    for i in range(1,6)[::-1]:
        now=newbt()
        for j in range(k-1):
            pourbt(modsubnumbt(a,k**i),now)
        res.append(now)
    res.append(a)
    return res
```

7.5.4. 根据 $a$ 的 $k$ 进制表示求 $a$。  

直接每一位乘 $k^i$ 加起来就好。
```python
def tonumbt(a,k):
    res=newbt()
    a=a[::-1]
    for i in range(len(a)):
        pourbt(mulnumbt(a[i],k**i),res)
    return res
```

8. 求 $\lfloor\frac 1{10}a\rfloor$。   

先将 $a$ 拆分成 $10$ 进制表示，去掉最后一位，在组合起来就好。   
```python
b=todigitsbt(a,10)[:-1]
c=tonumbt(b,10)
```

9. 求 $a\times b \bmod 2^{18}$。  

还是龟速乘，一边乘一边取模就好。   
```python
def mulmodnumbt(a,b,p):
    c=tobinarybt(a,17)[::-1]
    a=copynewbt(b)
    res=newbt()
    for i in range(17):
        pourbt(copyfullbt(minbt(pow2bt(c[i],20),a)),res)
        modsubnumbt(res,p)
        pourbt(copyfullbt(a),a)
        modsubnumbt(a,p)
    return res
```

10. 求 $a^b$。   

快速幂，类比龟速乘。  
```python
def powbt(a,b):
    c=tobinarybt(b,10)[::-1]
    res=newfullbt(1)
    for i in range(10):
        b=pow2bt(c[i],20)
        pourbt(newfullbt(1),b)
        res=mulbt(res,copyfullbt(minbt(b,a)),20)
        a=mulbt(a,copyfullbt(a),20)
    return res
```

____
[完整代码 约 4K](https://www.luogu.com.cn/paste/52olxj9w)

---

## 作者：LJC00101 (赞：2)

终于做出了这题……

思路大至都差不多，前几个点是人类智慧乱搞，后几个和乘法有关的点都是基于二进制拆分，不过有几个点只用对一个点拆分，另一个点直接倍增，以减小复杂度。

并且有几个点略卡，要中途记忆化。

如下，对a*2^i这种数，如果a相同又有多次调用，我们可以同时把它的倍增数组处理出来。

```cpp

    int mpa[20][20], mpb[20][20];
    for (int i = 0; i <= 16; ++i)
    {
        printf("M %d\n", ta[i]);
        ++cnt;
        mpa[i][0] = cnt;
        for (int j = 1; j <= 17; ++j)
        {
            printf("F %d\n", mpa[i][j - 1]);
            printf("T %d %d\n", mpa[i][j - 1], rub);
            printf("F %d\n", mpa[i][j - 1]);
            printf("T %d %d\n", mpa[i][j - 1], rub);
            printf("M %d\n", rub);
            ++cnt;
            printf("E %d\n", rub);
            mpa[i][j] = cnt;
        }
    }
```
可以看到，我在这最后几个点即使实现较为粗糙，依然比另一篇题解给出的方案优很多，并且完全可以再卡一卡，可能可以再少一个数量级。
[评测记录](https://www.luogu.com.cn/record/41696799)

至于另一篇题解的实现步数，随便找一下其它人的记录就是了（

代码还是不放了，毕竟实在太长（10k，400多行）

~~做完这道“十分有意思”的人类智慧题后，我想我可以安心地退役了。~~

---

## 作者：Tomle (赞：0)

没有条件语句，但是瓶子在倒来倒去的时候会发生一些奇妙的事情来实现一些简单的操作。

# $a+b$

这个没啥好说的，就是试一下 IO。

# $|a-b|$

实现一个 `abs` 函数，以后会用到。

显然 $|a-b|=\max(0,a-b)+\max(0,b-a)$。$\max(0,a-b)$ 是 $b$ 瓶清空，将 $a$ 瓶倒入 $b$ 瓶后 $a$ 瓶剩下的。$\max(0,b-a)$ 同理。

假设每个瓶的水量等于容量，次可以在 $6$ 次内实现。

# $\max(a,b)$

显然 $\max(a,b)=b+\max(a-b,0)$，然后像 task2 一样做就行了。

# $\gcd(a,b)$

这个可以 $a_n=b_{n-1},b_n=|a_{n-1}-b_{n-1}|$ 迭代 $2000$ 次，然后取 $\max(a,b)$。

# 二进制表示

实现一个奇妙的函数 `getk(x,k)`，若 $x-1$ 最高位为 $2^k$，则提取出来，否则不进行操作。

我们创建一个容量为 $2^k$ 的瓶子 $a$，将 $x$ 瓶倒入 $a$ 瓶，然后创建一个瓶 $b$，容量为 $x$ 的剩余水量。将其容量倍增 $20$ 次，然后将 $a$ 瓶倒入 $b$ 瓶，再将 $a$ 瓶倒入 $x$ 瓶。最后 $b$ 瓶就是提取的 $2^k$。

正确性？考虑 $x-1<2^k$，则 $x\le 2^k$，此时 $x$ 瓶倒入 $a$ 后剩 $0$，这样 $b$ 瓶倍增之后还是 $0$，然后 $a$ 倒入 $b$ 没用，最后再还给 $x$。若 $x>2^k$，则 $x$ 瓶倒入 $a$ 后会剩一点，那么倍增后 $b$ 瓶容量会很大，$a$ 全部倒入 $b$，水量就是 $2^k$。

然后得到 $2^k$ 后倒入一个容量为 $1$ 的空瓶子输出就行。

注意前几位直接输出 $0$，再优化一下倍增方式就能过。

# $a\times b$

模拟龟速乘的过程，将 $b$ 二进制分解，假设第 $k$ 位，对应瓶子位 $c$，将其按照之前的方法倍增，倒入 $a2^k$ 的水，和答案累加。

# $a\operatorname{xor} b$

对每一位 $k$，提取 $a,b$ 的第 $k$ 位，然后类加上其差的绝对值。

# $\lfloor\frac a{10}\rfloor$

前文提到的 `getk` 能提取二进制第 $k$ 位，其实可以将其强化。设 `Try(x,k)`，若 $x\ge k$ 则返回 $k$ 并 $x\gets x-k$，否则返回 $0$。类似 `getk` 的方法做就行。

设 `Try(x,k)` 返回了 $b$，那么创建一个容量为 $\lfloor\frac k{10}\rfloor$ 的瓶子，将 $b$ 倒入。

然后进行 $9$ 次 `Try(a,1000)`，$9$ 次 `Try(a,100)`，$10$ 次 `Try(a,10)` 即可。

# $a\times b\mod 262144$

类似 task6，每次加完 Try 262144 一下就行。

# $a^b$

快速幂，分解 $b$。对于第 $k$ 位，其瓶子为 $c$，首先倍增，放入 $a^{2^k}-1$ 的水，然后创建一个大容量的瓶子 $d$，初始水为 $1$，将 $c$ 倒入 $d$，然后 $ans\gets ans\times d$。

正确性？模拟发现，若 $c=0$ 则 $d=1$，$c=1$ 则 $d=a^{2^k}$，符合快速幂的运算。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for (int i(a); i <= (b); ++i)
#define per(i, a, b) for (int i(a); i >= (b); --i)
typedef vector <int> vi;
#define pb push_back

int now = 0;

int input() { puts("I"); return ++now; }
int create(int s) { printf("C %d\n", s); return ++now; }
void trans(int x, int y) { printf("T %d %d\n", x, y); }
void output(int x) { printf("O %d\n", x); }
void fill(int x) { printf("F %d\n", x); }
void clear(int x) { printf("E %d\n", x); }
int make(int x) { printf("M %d\n", x); return ++now; }
int add(int x, int y) {
	int a = create(1e9);
	trans(x, a), trans(y, a);
	return a;
}
int abs(int x, int y) {
	int a = create(1e9);
	clear(x), trans(y, x), trans(y, a);
	fill(x), trans(x, y), trans(x, a);
	return a;
}
int max(int x, int y) {
	int a = make(y);
	trans(x, a);
	return add(x, y);
}
int gcd(int x, int y) {
	rep(i, 1, 2000) {
		fill(y);
		int a = make(abs(x, y));
		x = y, y = a;
		// std::cerr << x<< " " << y << std::endl;
	}
	fill(x), fill(y);
	return max(x, y);
}
void tobig(int &x, int k) {
	// if a[x] == 0, will return 0
	// else return a big number
	int d = create(1e9);
	rep(i, 1, k) fill(x), trans(x, d), x = make(d);
	clear(x);
}
int getk(int x, int k) {
	int b = create(1 << k);
	trans(x, b);
	int c = make(x);
	tobig(c, 17);
	trans(b, c), trans(b, x);
	return c;
}
vi bit(int X) {
	vi ans;
	int a = create(1), A = create(0);
	rep(i, 1, 12) ans.pb(A);
	int x = create(1e9);
	trans(X, x);
	fill(a), trans(a, x);
	per(i, 19, 0) {
		int b = getk(x, i);
		clear(a);
		trans(b, a);
		int c = make(a); fill(c);
		ans.pb(c);
	}
	return ans;
}
int times(int x, int y) {
	vi a = bit(x);
	int sm = create(1e9);
	per(i, 31, 11) {
		int A = make(a[i]); fill(a[i]);
		tobig(A, 23);
		trans(y, A), trans(A, sm);
		int b = create(1e9);
		fill(y), trans(y, b), fill(y), trans(y, b);
		y = make(b), fill(y);
	}
	return sm;
}
int Xor(int X, int Y) {
	int x = create(1e9), y = create(1e9);
	trans(X, x), trans(Y, y);
	int a = create(1);
	fill(a), trans(a, x);
	fill(a), trans(a, y);
	int sm = create(1e9);
	per(i, 16, 0) {
		int a = make(getk(x, i)), b = make(getk(y, i));
		fill(b), trans(abs(a, b), sm);
	}
	return sm;
}
void Try(int x, int k, int sm) {
	int a = create(k);
	trans(x, a);
	int b = make(x);
	tobig(b, 17);
	trans(a, b), trans(a, x);
	int c = create(k / 10);
	trans(b, c), trans(c, sm);
}
int div10(int X) {
	int x = create(1e9), a = create(1);
	trans(X, x);
	fill(a), trans(a, x);
	int sm = create(1e9);
	rep(i, 1, 9) Try(x, 1000, sm);
	rep(i, 1, 9) Try(x, 100, sm);
	rep(i, 1, 10) Try(x, 10, sm);
	return sm;
}
int mod(int X) {
	int x = create(1e9), A = create(1);
	trans(X, x), fill(A), trans(A, x);
	int a = create(262144);
	trans(x, a);
	int b = make(x);
	tobig(b, 20);
	trans(a, b), trans(a, x);
	trans(x, A);
	return x;
}
int times2(int x, int y) {
	vi a = bit(x);
	int sm = create(1e9);
	per(i, 31, 15) {
		tobig(a[i], 21);
		trans(y, a[i]), trans(a[i], sm);
		sm = mod(sm);
		int b = create(1e9);
		fill(y), trans(y, b), fill(y), trans(y, b);
		y = make(mod(b)), fill(y);
	}
	return sm;
}
int power(int x, int y) {
	vi a = bit(y);
	int R = create(1), b = create(1);
	fill(R);
	per(i, 31, 20) {
		tobig(a[i], 21), fill(a[i]);

		int c = create(1e9); trans(a[i], c);

		fill(b), trans(b, c);

		c = make(c), fill(b), trans(b, c);

		clear(b), trans(x, b);

		int d = make(x); fill(d);
		trans(d, c);

		int e = make(R); fill(e);

		int C1 = make(c), C2 = make(e); fill(C1), fill(C2);
		if (i == 30) cerr << C1 << "   " << C2 << endl;

		fill(R = make(times(c, e)));

		int C3 = make(R); fill(C3);
		if (i == 30) cerr << C3 << endl;

		fill(b), trans(b, x);



		c = make(x), d = make(x), fill(c), fill(d);

		fill(x = make(times(c, d)));
	}
	return R;
}
int main() {
	// freopen("out.out", "w", stdout);
	int c; scanf("%d", &c);
	if (c == 1) {
		int x = input(), y = input();
		int R = add(x, y);
		output(R);
	}
	if (c == 2) {
		int x = input(), y = input();
		int R = abs(x, y);
		output(R);
	}
	if (c == 3) {
		int x = input(), y = input();
		int R = max(x, y);
		output(R);
	}
	if (c == 4) {
		int x = input(), y = input();
		int R = gcd(x, y);
		output(R);
	}
	if (c == 5) {
		int x = input();
		vi R = bit(x);
		for (auto x : R) output(x);
	}
	if (c == 6) {
		int x = input(), y = input();
		int R = times(x, y);
		output(R);
	}
	if (c == 7) {
		int x = input(), y = input();
		int R = Xor(x, y);
		output(R);
	}
	if (c == 8) {
		int x = input();
		int R = div10(x);
		output(R);
	}
	if (c == 9) {
		int x = input(), y = input();
		int R = times2(x, y);
		output(R);
	}
	if (c == 10) {
		int x = input(), y = input();
		int R = power(x, y);
		output(R);
	}
}
```

写代码的使用有一些奇怪的错误调死我了。

---


# 少女与战车

## 题目背景

如果你对山口丁和 G&P 没有兴趣，可以无视题目背景，因为你估计看不懂 ……


 ![](https://cdn.luogu.com.cn/upload/pic/4760.png) 

在第 63 回战车道全国高中生大赛中，军神西住美穗带领大洗女子学院的大家打败了其他所有高中，取得了胜利，当然也就不用废校了。

然而一群战车道的领导表示他们是口胡的，废校还是要废的。

军神的母亲西住志穗怒斥废校男，为了不造个大新闻，废校男承诺如果大洗学院可以打败大学队，就不用废校。

（有种 OI 选手 PK ACM 选手的感觉呀）

然而实力差距太大了，大洗女子学院最强的车是虎式 P 型，而大学队清一色的 M26 潘兴，M24 霞飞，还有能跑到 20 的 T95 和卡尔臼炮，感觉根本没法打呀。

这时候一个光头的胖子谢尔盖 • 布尔卡托夫斯基和一个身患癌症急需钱来治病的王姓 CEO 来帮助她们了。

他们把一堆真实性堪忧的坦克图纸给了大洗学院的妹子们，并说这些图纸是真的，而且还原了历史。

大洗学院汽车部的大家看到了这些图纸后非常高兴，开始膜改她们的战车。


虎式P型 -> 蟋蟀17

四号D型 -> 四号坦克武器运载车

38(t)型 -> 莱茵金属公司武器运载车

B1-bis  -> 105leFH18B2

即使这样，只有 8 辆战车的大洗女子学院仍然无法打败有 30 辆战车的大学队。

这时候按照剧本其他高中的小伙伴要来帮忙了，然而她们最近正在学习 OI，碰到了一道很神奇的数据结构题，不会做所以来不了。

你作为一个三次元的国家队选手，当然能秒杀二次元的 OI 题啦。

请帮帮她们吧！


## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/4761.png) 

给你一个 $n$ 个点的有根树， $1$ 为根，带边权，有 $m$ 次操作。


1、求 $x$ 的子树中第 $k$ 小的深度的值，如果子树中没有 $k$ 个点则输出 $-1$；

2、将 $x$ 与 $x$ 父亲的边权加上 $k$。

保证每次操作 2 的 $k$ 以及原树的边权小于等于一个数 $len$。


如果操作 2 中 $x$ 为 $1$，那么视为将 $x$ 的基础深度加上了 $k$。


## 说明/提示

数据范围与提示

对于 10% 的数据， $n, m \leq 1000$；

对于 30% 的数据， $n, m \leq 30000$；

对于 100% 的数据，$ n, m \leq 100000,len \leq 10$。


本水题采用捆绑测试，你只有通过该部分分的所有数据才可以得到该部分分的分数。


如果你对山口丁和 G&P 没有兴趣，可以无视结局。



如果你做出来了这个题


妹子们看了你的 STD 之后都 A 了这个题，然后去帮助军神。

她们找了 30 个 183 射了对面一脸。


如果你没做出来这个题


妹子们虽然很想帮助军神，但是也爱莫能助，毕竟学战车道不能保送。

没有办法，只能 8 打 30 了。

莱茵蹲在草里，大学队没有人发现它，成功击杀五辆敌方坦克后因为车体无法承受火炮后坐力而解体。

三突也蹲在草里，大学队没有人发现它，它也没有发现任何人，最后蹲不住了去突击，击毁一辆潘兴后被击毁。

四运文艺倒车，大学队看到之后目瞪口呆，成功击杀八辆敌方坦克后因为车体无法承受火炮后坐力而解体。

虎P炮一发带走了 95，然后因为转场的时候发动机故障而烧毁。

最后法五金刺刀了 15 个，成功翻盘。

![](https://cdn.luogu.com.cn/upload/pic/4762.png)


## 样例 #1

### 输入

```
3 5 3
1 3
2 3
1 1 3
2 3 3
1 1 3
2 1 2
1 1 3```

### 输出

```
6
9
11```

# 题解

## 作者：daniel14311531 (赞：13)

#### 此题 1e5，分块逃不过。  

尝试这样分块：  

块内元素数目不超过sqrt(n)个，且块内元素最大值与最小值之差不超过2000。记录块内每个元素比块内元素最小值大多少，记在一个数组里，跑一边前缀和，这样便可以O(1)的时间内查询块内小于k的元素的个数。   

查询很简单，不必赘述。考虑修改，整块修改放懒惰标记，其余的可以这样：每次加一个不超过10的值，那么只进行1000次修改块内元素最大值与最小值之差不会超过20000，依然能用数组存下。那么每进行1000次操作就重新分块，时间复杂度约O(n*sqrt(n)*log(n))，可以跑过。  

代码：  

```
#include<bits/stdc++.h>
#define Min(x,y)	((x)<(y)?	(x):(y))
#define Max(x,y)	((x)>(y)?	(x):(y))
using namespace std;
const int blo=300,s=2000;
const int INF=0x3f3f3f3f;
const int SIZEBLO=2010,N=100010;
int n,m,len,tot;
int cnt=0,hed[N],to[N],nxt[N],val[N];
int dfn[N],idx=0,dep[N],low[N];
int bl[N],L[SIZEBLO],R[SIZEBLO],lz[SIZEBLO],bL[SIZEBLO],bR[SIZEBLO],sum[SIZEBLO][20010];
int sta[N],Dis[N],mark[N],top=0;

inline int read() {
	register int tmp=0;register bool flag=0;register char c=getchar();
	while(c<'0'||c>'9') { if(c=='-')	flag=1;c=getchar(); }
	while(c>='0'&&c<='9')	tmp=(tmp<<1)+(tmp<<3)+(c^48),c=getchar();
	return flag?	-tmp:tmp;
}
inline void add(int x,int y,int z) { to[++cnt]=y,val[cnt]=z,nxt[cnt]=hed[x],hed[x]=cnt; }
void dfs(int u,int dis) {
	dfn[u]=++idx,dep[idx]=dis; for(int i=hed[u];i;i=nxt[i])	dfs(to[i],dis+val[i]);
	low[u]=idx;
}
void Dfs(int u,int dis) {
	sta[++top]=u,Dis[top]=dis;
	while(top) {
		int v1=sta[top],v2=Dis[top],v3=mark[top];
		if(v3) { low[v1]=idx,--top;continue; }
		dfn[v1]=++idx,dep[idx]=v2,mark[top]=1;
		for(int i=hed[v1];i;i=nxt[i])	sta[++top]=to[i],Dis[top]=v2+val[i],mark[top]=0;
	}
}
inline void reset(int x) {
	if(!lz[x])	return ; for(int i=L[x];i<=R[x];i++)	dep[i]+=lz[x]; lz[x]=0;
}
inline void update(int x) {
	bL[x]=INF,bR[x]=-INF;
	for(int i=L[x];i<=R[x];i++)	bL[x]=Min(bL[x],dep[i]),bR[x]=Max(bR[x],dep[i]);
	for(int i=0;i<=bR[x]-bL[x];i++)	sum[x][i]=0;
	for(int i=L[x];i<=R[x];i++)	++sum[x][dep[i]-bL[x]];
	for(int i=1;i<=bR[x]-bL[x];i++)	sum[x][i]+=sum[x][i-1];
}
void build() {
	for(int i=1;i<=bl[n];i++)	reset(i);
	int lx=INF,rx=-INF,u=1;L[1]=1;
	for(int i=1;i<=n;i++) {
		lx=Min(lx,dep[i]),rx=Max(rx,dep[i]);
		if(rx-lx>s||i-L[u]>=blo)	lx=rx=dep[i],R[u]=i-1,L[++u]=i;
		bl[i]=u;
	}
	R[u]=n; for(int i=1;i<=bl[n];i++)	update(i);
}
inline int Getval(int x,int w) {
	if(w<bL[x])	return 0; if(w>=bR[x])	return sum[x][bR[x]-bL[x]];
	return sum[x][w-bL[x]];
}
inline int query(int l,int r,int w) {
	int Count=0;
	if(bl[l]+1>=bl[r]) {
		for(int i=l;i<=r;i++)	if(dep[i]<=w)	++Count;
		return Count;
	}
	for(int i=l;i<=R[bl[l]];i++)	if(dep[i]<=w)	++Count;
	for(int i=L[bl[r]];i<=r;i++)	if(dep[i]<=w)	++Count;
	for(int i=bl[l]+1;i<bl[r];i++)	Count+=Getval(i,w);
	return Count;
}
inline int Kth(int l,int r,int k) {
	if(r-l+1<k)	return -1;
	reset(bl[l]),reset(bl[r]);
	int ll=INF,rr=-INF,midd,tans=0;
	for(int i=bl[l];i<=bl[r];i++)	ll=Min(ll,bL[i]),rr=Max(rr,bR[i]);
	if(ll==rr)	return ll;
	while(ll<=rr) {
		midd=(ll+rr)>>1;
		if(query(l,r,midd)>=k)	tans=midd,rr=midd-1;
		else	ll=midd+1;
	}
	return tans;
}
inline void change(int l,int r,int w) {
	reset(bl[l]),reset(bl[r]);
	if(bl[l]+1>=bl[r]) {
		for(int i=l;i<=r;i++)	dep[i]+=w; update(bl[l]),update(bl[r]);
		return ;
	}
	for(int i=l;i<=R[bl[l]];i++)	dep[i]+=w; update(bl[l]);
	for(int i=L[bl[r]];i<=r;i++)	dep[i]+=w; update(bl[r]);
	for(int i=bl[l]+1;i<bl[r];i++)	lz[i]+=w,bL[i]+=w,bR[i]+=w;
}
int main() {
	n=read(),m=read(),len=read();
	for(int i=2,x,y;i<=n;i++)	x=read(),y=read(),add(x,i,y);
	Dfs(1,0),build();
	for(int i=1,opt,x,y;i<=m;i++) {
		opt=read(),x=read(),y=read();
		if(opt==1)	printf("%d\n",Kth(dfn[x],low[x],y));
		else	++tot,change(dfn[x],low[x],y);
		if(i%1000==0)	tot=0,build();
	}
	return 0;
}
```  

~~祝你们成功~~

---

## 作者：Smallbasic (赞：8)

毒瘤分块。。。~~虽然作为黑题还是挺水~~

写代码倒没什么，查bug和卡常倒弄了很久。

虽然问树，但注意到这题是子树加减和询问。树的dfs序有一条性质是一个点子树内的dfs序一定连续（结合dfs序的定义就很好理解），于是我们先dfs一遍跑出dfs序（记为$dfn[i]$），然后记录下每个点管辖的子树内最大的dfs序(记为$rr[i]$)，我们就把对$i$的子树的操作转化成了对区间$[dfn[i],rr[i]]$的操作。注意直接dfs会爆栈，需要用非递归的方式模拟。

再看题，区间加区间k大，这不就是由乃打扑克原题吗！于是开开心心写了$\Theta(n\sqrt{n}\log n\log A)$(A是值域)的写法交上去TLE完。

先说最暴力的分块，每次询问二分答案$ans$，check是否有大于等于$k$个数少于它。而这个就是教主的魔法了。在每个块内排序，二分一下第一个大于$ans$的数的位置，它前面的数都小于$ans$，对于两边的块就暴力统计。而区间加直接打懒标记，零散块暴力重建就好了。

考虑如何优化。

如果用未来日记那题分块套权值块状数组的方法，修改操作就很难办。既然不能用那个方法优化掉二分答案的$\log$，而上面那个暴力瓶颈就在于区间内二分统计的复杂度。

观察到题目中说：原树边权和增加的边权小于等于一个数$len$，而$len$又非常小，不妨从这里入手。我们大胆的猜测初始每个块内最大值与块内最小值之差不会超过一个数$w$！

那么我们设数组$sum[x][y]$表示块$x$内与块内最小值差值为$y$的数的个数，对它求一遍前缀和。这样我们发现就能$\Theta(1)$统计多少比它小的数！

$sum$数组也很好维护。区间同时加的话差值不变不用管打标记就好。零散的块直接暴力加暴力重构就好。这样也免去了块内排序，复杂度优化到了$\Theta(n\sqrt{n}\log n)$。

但这样就完了吗？

如果每次修改操作在零散块里都加到最大值而非最小值，维护$sum$数组需要的空间就会极大！此时我们用非常暴力的方法。若当前修改操作次数达到于一个值，就暴力重构整个序列。重构的方式还是分块，保证每个块的长度不大于设置的最大块长且块内最大值和最小值的差不能超过$w$

剩下的就是玄学调参和繁琐的细节了。代码改的一塌糊涂，将就看好了。

~~抄题解的能不能过就要看人品了，一会儿T一会儿A的~~

163行应该不算太长

Code：

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize("Ofast") 
#include <bits/stdc++.h>

using namespace std;

int n, m, pos[100005], beg[100005], endd[100005], lazy[100005], a[100005], opt, l, r, k, block = 355, len, gqyak = 0;
int xcyak[100005];
int sum[1005][30015], mn[100005], mx[100005], bl = 0;
const int eps = 4000;

int min_(int a, int b) {
	return a < b ? a : b;
}

int max_(int a, int b) {
	return a > b ? a : b;
}

int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) f = (ch == '-' ? -1 : f), ch = getchar();
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s * f;
}
int tyz = 0;
int check(int l, int r, int x) {
//	cerr << "pre " << x << enddl;
	 int ret = 0;
	if (pos[l] == pos[r]) {
		for (int i = l; i <= r; ++i)
			if (a[i] + lazy[pos[l]] <= x) ++ret;
		//	cerr << "endd in check" << enddl;
		return ret;
	}
	for (int i = l; i <= endd[pos[l]]; ++i)
		if (a[i] + lazy[pos[l]] <= x) ++ret;
	for (int i = r; i >= beg[pos[r]]; --i)
		if (a[i] + lazy[pos[r]] <= x) ++ret;
		
	for ( int i = pos[l] + 1; i < pos[r]; ++i) {
		if (x - mn[i] - lazy[i] < 0) continue;
//		int kt = ret;
		if (x - mn[i] - lazy[i] >= mx[i] - mn[i]) ret += sum[i][mx[i] - mn[i]];
		else ret += sum[i][x - mn[i] - lazy[i]];
	//	if (tyz == 14 && x == 490899) {
	//		cerr << ret - kt << enddl;
	//	}
	}//cerr << "fucker!" << enddl;
	return ret; 
}

int qans(int l, int r, int k) {
	 int ll = 0x3f3f3f3f, rr = -0x3f3f3f3f, ans = -1;
	for ( int i = pos[l]; i <= pos[r]; ++i) ll = min_(ll, mn[i] + lazy[i]), rr = max_(rr, mx[i] + lazy[i]);
	if (ll == rr) return ll; int lll = l, rrr = r;
	//cerr << tyz << ' ' << ll << ' '<< rr << endl;
	//if (tyz == 21363) cout << "beg " << ll << ' ' << rr << endl;
	while (ll <= rr) {
		int mid = ll + rr >> 1;
		if (check(lll, rrr, mid) >= k) ans = mid, rr = mid - 1;
		else ll = mid + 1;
	} //if (tyz == 14) cerr << "ans = " << ans << enddl; 
	return ans;
}

void upd(int i) {
	mn[i] = 0x3f3f3f3f, mx[i] = -0x3f3f3f3f;
	for ( int j = beg[i]; j <= endd[i]; ++j) {
		mn[i] = min_(mn[i], a[j]), mx[i] = max_(mx[i], a[j]);
	}
 	memset(sum[i], 0, sizeof sum[i]);
	for ( int j = beg[i]; j <= endd[i]; ++j)
		++sum[i][a[j] - mn[i]];
	for ( int j = 1; j <= mx[i] - mn[i]; ++j)
		sum[i][j] += sum[i][j - 1];
}

void modify(int l, int r, int k) {
	if (pos[l] == pos[r]) {
		for ( int i = l; i <= r; ++i) a[i] += k;
		upd(pos[l]);
		return ;
	}
	for (int i = l; i <= endd[pos[l]]; ++i) a[i] += k; upd(pos[l]);
	for (int i = r; i >= beg[pos[r]]; --i)  a[i] += k; upd(pos[r]);
	for (int i = pos[l] + 1; i < pos[r]; ++i) lazy[i] += k;
}

void build() {
	for ( int i = 1; i <= n; ++i)
		a[i] += lazy[pos[i]];
	
	for ( int i = 1; i <= bl; ++i) lazy[i] = 0;
	beg[1] = 1; pos[1] = 1;
	int ls = 0x3f3f3f3f, rs = -0x3f3f3f3f;
	bl = 1;
	for ( int i = 1; i <= n; ++i) {
		ls = min_(a[i], ls); rs = max_(a[i], rs);
		if (rs - ls > eps || i - beg[bl] >= block ) ls = rs = a[i], endd[bl] = i - 1, beg[++bl] = i;
		pos[i] = bl;
	}
	endd[bl] = n;
	for ( int i = 1; i <= bl; ++i) {		
		upd(i);
	}
}

//=========================================================tree==================================================

struct edge {
	int head, to, nxt, val;
}ed[100005];

int en = 0;
int dep[100005], dfn[100005], id = 0, rr[100005];
int sta[100005], dis[100005], top = 0;

void addedge(int from, int to, int val) {
	ed[++en].to = to; ed[en].nxt = ed[from].head; ed[from].head = en; ed[en].val = val;
}

void dfs(int u, int v) {
	sta[++top] = u; dis[top] = v;
	while (top) {
		int uu = sta[top], val = dis[top], tmp = xcyak[top];
		if (tmp) { rr[uu] = id; --top; continue; }
		dfn[uu] = ++id; a[id] = val; xcyak[top] = 1;
		for( int i = ed[uu].head; i; i = ed[i].nxt)
			sta[++top] = ed[i].to, dis[top] = val + ed[i].val, xcyak[top] = 0;
	}
}

int main() {
//	freopen("heiheihei.in", "r", stdin);
//	freopen("standard.out", "w", stdout);
	n = read(); m = read(); len = read();
	for ( int i = 2; i <= n; ++i) {
		l = read(); k = read();
		addedge(l, i, k);
	} block = sqrt(n) + 1;
	dfs(1, 0);
	memset(mn, 0x3f, sizeof(mn));
	memset(mx, -0x3f, sizeof(mx));
	bl = n / block + 1;
	build();
	while (m--) {
		opt = read(); l = read(); k = read();
		if (opt == 1) {
		//	cerr << "dfn[l] = " << dfn[l] << ' ' << rr[l] << enddl;
			++tyz;
			if (rr[l] - dfn[l] + 1 < k) puts("-1");
			else printf("%d\n", qans(dfn[l], rr[l], k));
		} else modify(dfn[l], rr[l], k), ++gqyak;
		if (gqyak == 2600) {
////			cerr << "gqyak = " << gqyak << enddl;
			build();// tyz = 0;
			gqyak = 0;
		}
	} //cerr << dfn[l] << endl;
	return 0;
}
```


---

## 作者：lzyqwq (赞：6)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/p/18025831)**

**[我永远喜欢数据结构。](https://www.luogu.com.cn/blog/juruo-lzy/IloveDS)**

[P5356 由乃打扑克](https://www.luogu.com.cn/problem/P5356)加强版。看了神仙 @[5k_sync_closer](https://www.luogu.com.cn/user/388651) 的题解发现 $len\le 10$ 可以忽略，是不是爆标了！5k 好闪，拜谢 5k！

果然根号数据结构照样可爱。

**[题目传送门](https://www.luogu.com.cn/problem/P3712)**

> - 给出 $n$ 个点的有根树，定义一个点的深度为它到根简单路径上的边权和。有 $m$ 次操作，每次询问子树内第 $k$ 小的深度，或是讲某条边权值加 $k$。
>
> - $n,m\le 10^5$。
>
> - $\text{3 s / 500 MB}$。

设值域为 $V$。默认 $\mathcal{O}(\log n)=\mathcal{O}(\log|V|)$。

首先将子树拍平成 $dfn$ 序，则问题就是区间加、查区间 $k$ 小值。考虑分块，设块长为 $B$。

对于整块，维护初始数组 $a$、加标记 $tag$ 以及排序后的数组 $c$。记 $i$ 所在块为 $bel_i$，我们要实时维护 $a_i+tag_{bel_i}$ 为 $i$ 这个位置的真实值，且对于一个整块的下标区间 $[l,r]$，$c_l\sim c_r$ 为 $a_l\sim a_r$ 排序后的结果。

修改时，整块修改标记、散块暴力重构。查询时，二分答案，然后求区间内有多少个小于等于它的数。

**算法一**

- 修改时，暴力枚举整块标记加 $k$，暴力枚举散块使用 `std::stable_sort` 重构散块。单次时间复杂度为 $\mathcal{O}\left(B\log n+\dfrac{n}{B}\right)$。

- 查询的二分答案时，设二分的值为 $mid$，散块暴力枚举，整块在排序的数组上二分最后一个**真实值**不超过 $mid$ 的位置。然后块的起点到这个位置的数都要被统计。单次时间复杂度为 $\mathcal{O}\left(\left(\dfrac{n}{B}\log n+B\right)\log n\right)$。

- 取 $B=\mathcal{O}\left(\sqrt{n\log n}\right)$ 时，时间复杂度为 $\mathcal{O}\left(n+m\sqrt{n\log n}\log n\right)$。无法接受。

- 空间复杂度为 $\mathcal{O}(n)$。

**算法二**

- 修改时，整块仍然暴力标记加 $k$。考虑将散块的 $c$ 数组对应的区间 $[l,r]$ 分成两个子序列：一个子序列内的**原数下标**不在本次修改的区间内，另一个则在。对于这两个子序列而言，它们都是单调非降的。可以归并排序。这样一来，单次时间复杂度变为 $\mathcal{O}\left(B+\dfrac{n}{B}\right)$。

- 二分答案时，对于散块仍然采用类似的方式归并成一个长度为 $\mathcal{O}(B)$ 的有序数组。不需要暴力枚举，直接在数组上二分。整块查询方式不变。这样查询时间复杂度为 $\mathcal{O}\left(\left(\dfrac{n}{B}\log n+\log B\right)\log n\right)$。

- 取 $B=\mathcal{O}\left(\sqrt{n}\log n\right)$ 时，时间复杂度为 $\mathcal{O}\left(n+m\sqrt{n}\log n\right)$ 可以接受。

- 空间复杂度为 $\mathcal{O}(n)$。

- **[AC 记录](https://www.luogu.com.cn/record/147838867)**

- **[AC 代码](https://www.luogu.com.cn/paste/0k06g87r)**

**更多算法**

[P5356 题解区](https://www.luogu.com.cn/problem/solution/P5356)提到了时间复杂度 $\mathcal{O}\left(n+m\sqrt{n\log n}\right)$、$\mathcal{O}\left(n+m\sqrt{n}\right)$（好像有，可能是我看错了）的做法，空间复杂度不清楚。膜拜 DS 大神们，我这个数据结构萌新爬了。



---

## 作者：critnos (赞：4)

一个看起来靠谱点的做法。

下面认为 $n=m$，$b$ 为块长。

冷静分析。

我们有这样一个做法：

每一块维护一个后缀和数组 $a$。边块处理的时候对一个数 $x$ 增加 $k$ 就是对区间 $[x+1,x+k]$ 增加 $1$。

然后查询该块内有多少个 $\le x$ 的数的时候，用块长减去 $>x$ 的数即 $a_{x+1}$。

这看起来是一个对劲的做法。。不过注意到一个数可以去到 $nlen$ 级别。。这意味着我们的空间复杂度是 $O(\dfrac {n^2 len} b)$。

不过冷静一下。。我们维护的其实是这个块减去最小值。也就是说我们要维护的值域是最大值和最小值的差。保证这个差 $\le n$。

不过好像还是不太行。。因为每次操作会让 $O(1)$ 个散块的值域增加 $len$。。

机会来了！我们要用 $\dfrac n {len}$ 的操作次数才能让一个块不满足性质。也就是说，在所有的操作中，我们至多让 $O(m/\dfrac n {len})=O(len)$ 个块不满足性质！

那么对这些块，用块内排序二分的方法维护即可。

还有一个问题：这些块初始的极差是否会过大呢？

有一个很重要的性质，就是这些值是通过一棵树给出的！

也就是说，一个 dfn 的块在树上是一个连通块！

这个连通块的直径为 $\le b$，这意味着极差 $\le blen$。

算一下复杂度：

修改的复杂度，对于排序块的修改是 $O(b)$，对于其它的块是 $O(blen)$。

查询的复杂度，单次区间查询 $\le x$ 的数，散块是 $O(b)$；所有的排序整块是 $O(len\log b)$，这个可以忽略；其它的整块是 $O(\dfrac n b)$。

外面再带上一个二分，就是 $O(\log n(b+\dfrac n b))$。

取 $b=\sqrt n$，修改就是 $O(\sqrt n len)$，查询就是 $O(\sqrt n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int b=317,mx=1e5+5,up=1<<int(log2(b)); 
int a[mx];
pair<int,int> st[mx],st1[mx],st2[mx];
int bl[mx],fl[mx],fr[mx],tag[mx],ks;
int t[mx/b+5][mx+1];
int mxb[mx];
char ibuf[900<<20],*s,out[900<<20];
int wz;
inline int read()
{
    register int u=0,w=1;
    while(*s<48)
	{
		if(*s=='-') w=-1;
		s++;
	} 
    while(*s>32)
        u=u*10+*s++-48;
    return u*w;
}
void print(int x)
{
	if(x<0) 
	{
		out[wz++]='-',print(-x);
		return;
	}
    if(x>9) print(x/10);
	out[wz++]=x%10+'0';
}
int n;
void init()
{
	int i,j,k,mn;
	for(i=1;i<=n;i+=b)
		fl[++ks]=i,fr[ks]=min(n,i+b-1);
	for(i=1;i<=ks;i++)
	{
		mn=2e9;
		for(j=fl[i];j<=fr[i];j++)
			mn=min(mn,a[j]);
		tag[i]=mn;
		for(j=fl[i];j<=fr[i];j++)
		{
			bl[j]=i;
			mxb[i]=max(mxb[i],a[j]-=mn);
			for(k=0;k<=a[j];k++)
				t[i][k]++;
		}
	}				
}
void build(int l,int r)
{
	for(int i=l;i<=r;i++)
		st[i]=make_pair(a[i],i);
	sort(st+l,st+r+1);
}
void add2(int l,int r,int k)
{
	int i,j,w;
	for(i=l;i<=r;i++)
		a[i]+=k;
	j=w=0;
	for(i=fl[bl[l]];i<=fr[bl[l]];i++)
		if(st[i].second>=l&&st[i].second<=r)
			st1[++j]=st[i],st1[j].first+=k;
		else
			st2[++w]=st[i];
	merge(st1+1,st1+1+j,st2+1,st2+1+w,st+fl[bl[l]]);
}
void add(int l,int r,int k)
{
	int i,j,be=bl[l];
	if(be==bl[r])
	{
		if(mxb[be]>mx)
		{
			for(i=l;i<=r;i++)
				a[i]+=k;
			build(fl[be],fr[be]);
			return;
		}
		for(i=l;i<=r;i++)
			mxb[be]=max(mxb[be],a[i]+k);
		if(mxb[be]>mx)	
		{
			add2(l,r,k);
			return;
		}
		for(i=l;i<=r;i++)
		{
			for(j=a[i]+1;j<=a[i]+k;j++)
				t[be][j]++;
			a[i]+=k;
		}
		return;
	}
	add(l,fr[be],k),add(fl[bl[r]],r,k);
	for(i=be+1;i<bl[r];i++)
		tag[i]+=k;
}
int bound(int l,int r,int k)
{
	if(st[l].first>k) return 0;
	if(st[r].first<=k) return r-l+1;
	int i,w=l;
	for(i=up;i>=1;i/=2)
		if(w+i<=r&&st[w+i].first<=k)
			w+=i;
	return w-l+1;
}
bool check(int l,int r,int mid,int k)
{
	int s=0,i;
	if(bl[l]==bl[r])
	{
		for(i=l;i<=r;i++)
			s+=a[i]+tag[bl[i]]<=mid;
	}
	else
	{
		for(i=l;i<=fr[bl[l]];i++)
			s+=a[i]+tag[bl[i]]<=mid;
		for(i=bl[r]-1;i>bl[l];i--)
		{
			if(mxb[i]>mx) s+=bound(fl[i],fr[i],mid-tag[i]);
			else if(mid-tag[i]>=-1)
				s+=(fr[i]-fl[i]+1)-t[i][min(mx,mid-tag[i]+1)];
			if(s>=k) return 1;
		}	
		for(i=fl[bl[r]];i<=r;i++)
			s+=a[i]+tag[bl[i]]<=mid;
	}
	return s>=k;
}
int ask(int l,int r,int k)
{
	int le=0,ri=mx*20,mid,re;
	while(le<=ri)
	{
		mid=le+ri>>1;
		if(check(l,r,mid,k))
			ri=mid-1,re=mid;
		else
			le=mid+1;
	}
	return re;
}
vector<pair<int,int> > tr[100005];
int size[100005],dfn[100005];
int cdfn;
void dfs(int d,int s)
{
	dfn[d]=++cdfn;
	a[cdfn]=s;
	size[d]=1;
	for(int i=0;i<tr[d].size();i++)
		dfs(tr[d][i].first,s+tr[d][i].second),size[d]+=size[tr[d][i].first];
}
int main()
{
	fread(s=ibuf,1,900<<20,stdin);
	int m,i,opt,x,k;
	n=read(),m=read(),read();
	for(i=2;i<=n;i++)
		k=read(),tr[k].push_back({i,read()});
	dfs(1,0);	
	init();
	while(m--)
	{
		opt=read(),x=read(),k=read();
		if(opt==1) print(ask(dfn[x],dfn[x]+size[x]-1,k)),out[wz++]='\n';
		else add(dfn[x],dfn[x]+size[x]-1,k);
	}
	fwrite(out,1,wz,stdout);
} 
```


---

## 作者：5k_sync_closer (赞：2)

这题跟由乃打扑克的唯一区别就是这题不会放错解过了吧……

求出 DFS 序，问题变为区间加区间 k 小值。

考虑分块，维护每个块排序的结果，

修改时散块归并，整块打标记，

查询时先把散块归并起来，然后二分答案，

check 时散块在归并出的数组上二分，整块在其排序的结果上二分，

设块长为 $B$，总复杂度单次 $O(B+\log n(\log B+\dfrac nB\log B))$，

取 $B=\sqrt n\log n$ 即可做到单次 $O(\sqrt n\log n)$。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct E
{
    int v, w, t;
} e[100050];
int n, q, k, u, c, _, l[350], r[350], z[350], a[100050], w[100050], b[100050], t[100050], f[100050], h[100050], d[100050], s[100050];
void A(int u, int v, int w) { e[++c] = {v, w, h[u]}, h[u] = c; }
bool C(int x, int y) { return a[x] < a[y]; }
bool C1(int x, int y) { return a[x] < y; }
void D(int u, int k)
{
    d[u] = ++_;
    s[u] = 1;
    for (int i = h[u], v; i; i = e[i].t)
        w[v = e[i].v] = w[u] + e[i].w, D(v, u), s[u] += s[v];
}
int Q(int x, int y, int k)
{
    int p = lower_bound(f + 1, f + u + 1, k) - f - 1;
    for (int i = t[x] + 1; i < t[y]; ++i)
    {
        if (a[b[l[i]]] + z[i] >= k)
            continue;
        if (a[b[r[i]]] + z[i] < k)
        {
            p += r[i] - l[i] + 1;
            continue;
        }
        p += lower_bound(b + l[i], b + r[i] + 1, k - z[i], C1) - b - l[i];
    }
    return p;
}
int main()
{
    scanf("%d%d%*d", &n, &q);
    k = 3000;
    for (int i = 2, x, w; i <= n; ++i)
        scanf("%d%d", &x, &w), A(x, i, w);
    D(1, 0);
    for (int i = 1; i <= n; ++i)
        a[d[i]] = w[i];
    for (int i = 1; i <= n; ++i)
        b[i] = i, t[i] = (i - 1) / k + 1;
    for (int i = t[1]; i <= t[n]; ++i)
        l[i] = (i - 1) * k + 1, r[i] = min(l[i] + k - 1, n);
    for (int i = t[1]; i <= t[n]; ++i)
        sort(b + l[i], b + r[i] + 1, C);
    for (int i = 0, o, x, y, k, L, R, M; i < q; ++i)
    {
        scanf("%d%d%d", &o, &x, &k);
        y = d[x] + s[x] - 1, x = d[x];
        if (!(o & 1))
            if (t[x] == t[y])
            {
                for (int i = x; i <= y; ++i)
                    a[i] += k;
                int i = l[t[x]], j = l[t[x]];
                while (i <= r[t[x]] && b[i] >= x && b[i] <= y)
                    ++i;
                while (j <= r[t[x]] && (b[j] < x || b[j] > y))
                    ++j;
                u = 0;
                while (i <= r[t[x]] || j <= r[t[x]])
                {
                    if (j > r[t[x]])
                    {
                        f[++u] = b[i++];
                        while (i <= r[t[x]] && b[i] >= x && b[i] <= y)
                            ++i;
                    }
                    else if (i > r[t[x]])
                    {
                        f[++u] = b[j++];
                        while (j <= r[t[x]] && (b[j] < x || b[j] > y))
                            ++j;
                    }
                    else if (a[b[i]] <= a[b[j]])
                    {
                        f[++u] = b[i++];
                        while (i <= r[t[x]] && b[i] >= x && b[i] <= y)
                            ++i;
                    }
                    else
                    {
                        f[++u] = b[j++];
                        while (j <= r[t[x]] && (b[j] < x || b[j] > y))
                            ++j;
                    }
                }
                for (int i = 1; i <= u; ++i)
                    b[l[t[x]] + i - 1] = f[i];
            }
            else
            {
                for (int i = x; i <= r[t[x]]; ++i)
                    a[i] += k;
                for (int i = l[t[y]]; i <= y; ++i)
                    a[i] += k;
                for (int i = t[x] + 1; i < t[y]; ++i)
                    z[i] += k;
                int i = l[t[x]], j = l[t[x]];
                while (i <= r[t[x]] && b[i] >= x)
                    ++i;
                while (j <= r[t[x]] && b[j] < x)
                    ++j;
                u = 0;
                while (i <= r[t[x]] || j <= r[t[x]])
                {
                    if (j > r[t[x]])
                    {
                        f[++u] = b[i++];
                        while (i <= r[t[x]] && b[i] >= x)
                            ++i;
                    }
                    else if (i > r[t[x]])
                    {
                        f[++u] = b[j++];
                        while (j <= r[t[x]] && b[j] < x)
                            ++j;
                    }
                    else if (a[b[i]] <= a[b[j]])
                    {
                        f[++u] = b[i++];
                        while (i <= r[t[x]] && b[i] >= x)
                            ++i;
                    }
                    else
                    {
                        f[++u] = b[j++];
                        while (j <= r[t[x]] && b[j] < x)
                            ++j;
                    }
                }
                for (int i = 1; i <= u; ++i)
                    b[l[t[x]] + i - 1] = f[i];
                i = l[t[y]], j = l[t[y]];
                while (i <= r[t[y]] && b[i] <= y)
                    ++i;
                while (j <= r[t[y]] && b[j] > y)
                    ++j;
                u = 0;
                while (i <= r[t[y]] || j <= r[t[y]])
                {
                    if (j > r[t[y]])
                    {
                        f[++u] = b[i++];
                        while (i <= r[t[y]] && b[i] <= y)
                            ++i;
                    }
                    else if (i > r[t[y]])
                    {
                        f[++u] = b[j++];
                        while (j <= r[t[y]] && b[j] > y)
                            ++j;
                    }
                    else if (a[b[i]] <= a[b[j]])
                    {
                        f[++u] = b[i++];
                        while (i <= r[t[y]] && b[i] <= y)
                            ++i;
                    }
                    else
                    {
                        f[++u] = b[j++];
                        while (j <= r[t[y]] && b[j] > y)
                            ++j;
                    }
                }
                for (int i = 1; i <= u; ++i)
                    b[l[t[y]] + i - 1] = f[i];
            }
        else
        {
            if (y - x + 1 < k)
            {
                puts("-1");
                continue;
            }
            if (t[x] == t[y])
            {
                u = 0;
                for (int i = l[t[x]]; i <= r[t[x]]; ++i)
                    if (b[i] >= x && b[i] <= y)
                        f[++u] = a[b[i]] + z[t[x]];
                printf("%d\n", f[k]);
            }
            else
            {
                L = 2e9;
                R = -2e9;
                for (int i = x; i <= r[t[x]]; ++i)
                    L = min(L, a[i] + z[t[i]]), R = max(R, a[i] + z[t[i]]);
                for (int i = l[t[y]]; i <= y; ++i)
                    L = min(L, a[i] + z[t[i]]), R = max(R, a[i] + z[t[i]]);
                for (int i = t[x] + 1; i < t[y]; ++i)
                    L = min(L, a[b[l[i]]] + z[i]), R = max(R, a[b[r[i]]] + z[i]);
                int i = l[t[x]], j = l[t[y]];
                while (i <= r[t[x]] && b[i] < x)
                    ++i;
                while (j <= r[t[y]] && b[j] > y)
                    ++j;
                u = 0;
                while (i <= r[t[x]] || j <= r[t[y]])
                {
                    if (j > r[t[y]])
                    {
                        f[++u] = a[b[i++]] + z[t[x]];
                        while (i <= r[t[x]] && b[i] < x)
                            ++i;
                    }
                    else if (i > r[t[x]])
                    {
                        f[++u] = a[b[j++]] + z[t[y]];
                        while (j <= r[t[y]] && b[j] > y)
                            ++j;
                    }
                    else if (a[b[i]] + z[t[x]] <= a[b[j]] + z[t[y]])
                    {
                        f[++u] = a[b[i++]] + z[t[x]];
                        while (i <= r[t[x]] && b[i] < x)
                            ++i;
                    }
                    else
                    {
                        f[++u] = a[b[j++]] + z[t[y]];
                        while (j <= r[t[y]] && b[j] > y)
                            ++j;
                    }
                }
                while (L <= R)
                    if (Q(x, y, M = L + (R - L >> 1)) < k)
                        L = M + 1;
                    else
                        R = M - 1;
                printf("%d\n", R);
            }
        }
    }
    return 0;
}
```


---

## 作者：Cute__yhb (赞：1)

## 思路

与 P5356 做法相同。

首先，注意到一个点子树内的点在 DFS 序上是连续的，于是，这道题的树上操作就可以转化为数列上的操作。

所以，$1$ 操作对应求区间 $k$ 小值，$2$ 操作对应区间加。

考虑分块，维护一下每个块内排好序的数组。

设 $B$ 为块长。

对于区间加，直接散块暴力拆开计算，整块记录 $tag$ 即可。时间复杂度 $O(\frac{n}{B}\log B)$。

然后看区间 $k$ 小值。

首先，二分答案。

这里有个优化，答案的上界和下界可以使用这个区间的最大值和最小值。

这样，问题就转化为了求一个区间有多少比他小的值。

由于块内的数是有序的，那就可以再二分查找一下。

对于散块来说，也是直接暴力就行。

时间复杂度 $O(\frac{n}{B}\log B\log V)$，$V$ 为值域。

最后，块长是个玄学的东西，取 $\sqrt{n}$ 时，过不了。

瞎调了一下，发现 $900$ 可以，但 $800$ 和 $1000$ 都不行。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define F(i,l,r) for(int i=l;i<=r;i++)
#define UF(i,r,l) for(int i=r;i>=l;i--)
#define p_q priority_queue
#define pb push_back
#define mk make_pair
#define pii pair<int,ll> 
#define ve vector
#define endl '\n'
#define fi first
#define se second
#define INF 0x3f3f3f3f
#define lowbit(x) (x&(-x))
int n,m,Len,dfn[100005],tot=0,a[100005],siz[100005];
int B,cnt,bol[100005],b[100005],st[100005],en[100005],tag[100005];//分块数组
ve<pii>tr[100005];
void dfs(int x,int sum){//预处理，把树的 dfs 序求出来
	tot++;
	dfn[x]=tot;
	a[tot]=sum;
	siz[x]=1;
	for(int i=0;i<tr[x].size();i++){
		dfs(tr[x][i].fi,sum+tr[x][i].se);
		siz[x]+=siz[tr[x][i].fi];
	}
}
int Lower_bound(int x,int y){//二分查找 x 块中比 y 小的数
	int l=st[x],r=en[x],ans=st[x]-1;
	if(b[l]>y) return 0;
	if(b[r]<y) return r-l+1;
	while(l<=r){
		int mid=(l+r)/2;
		if(b[mid]<=y){
			ans=mid;
			l=mid+1;
		}else r=mid-1;
	}
	return ans-st[x]+1;
}
bool check(int l,int r,int x,int k){//二分检查答案是否可行
	int cnt=0;
	if(bol[l]==bol[r]){
		for(int i=l;i<=r;i++){
			if(a[i]+tag[bol[i]]<x) cnt++;//比x小
		}
		return cnt<=k;
	}
	for(int i=l;i<=en[bol[l]];i++){
		if(a[i]+tag[bol[i]]<x) cnt++;
	}
	for(int i=st[bol[r]];i<=r;i++){
		if(a[i]+tag[bol[i]]<x) cnt++;
	}
	for(int i=bol[l]+1;i<bol[r];i++){
		cnt+=Lower_bound(i,x-tag[i]-1);//整块二分处理
	}
	return cnt<=k;
}
int main(){
	scanf("%d%d%d",&n,&m,&Len);
	for(int i=2;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		tr[x].pb(mk(i,y));
	}
	dfs(1,0);
	B=900;//玄学的块长
	cnt=ceil(1.0*n/B);
	for(int i=1;i<=cnt;i++){
		st[i]=(i-1)*B+1;
		en[i]=min(n,i*B);
		for(int j=st[i];j<=en[i];j++){
			b[j]=a[j];
			bol[j]=i;
		}
		sort(b+st[i],b+1+en[i]);
	}
	while(m--){
		int opt,l,r,k;
		scanf("%d%d%d",&opt,&l,&k);
		int Rr=siz[l];//把树上的结点转化到 dfs 序上
		l=dfn[l];
		r=l+Rr-1;
		if(opt==2){//散块暴力，整块记录tag
			if(bol[l]==bol[r]){
				for(int i=l;i<=r;i++) a[i]+=k;
				for(int i=st[bol[l]];i<=en[bol[l]];i++) b[i]=a[i];
				sort(b+st[bol[l]],b+en[bol[l]]+1);
			}else{
				for(int i=l;i<=en[bol[l]];i++) a[i]+=k;
				for(int i=st[bol[l]];i<=en[bol[l]];i++) b[i]=a[i];
				sort(b+st[bol[l]],b+en[bol[l]]+1);
				for(int i=st[bol[r]];i<=r;i++) a[i]+=k;
				for(int i=st[bol[r]];i<=en[bol[r]];i++) b[i]=a[i];
				sort(b+st[bol[r]],b+en[bol[r]]+1);
				for(int i=bol[l]+1;i<bol[r];i++) tag[i]+=k;
			}
		}else{
			if(r-l+1<k){//不足k个数
				puts("-1");
				continue;
			}
			int L=1e9,R=0;//优化
			if(bol[l]==bol[r]){
				for(int i=l;i<=r;i++){
					L=min(L,a[i]+tag[bol[i]]);
					R=max(R,a[i]+tag[bol[i]]);
				}
			}else{
				for(int i=l;i<=en[bol[l]];i++){
					L=min(L,a[i]+tag[bol[i]]);
					R=max(R,a[i]+tag[bol[i]]);
				}
				for(int i=st[bol[r]];i<=r;i++){
					L=min(L,a[i]+tag[bol[i]]);
					R=max(R,a[i]+tag[bol[i]]);
				}
				for(int i=bol[l]+1;i<bol[r];i++){
					L=min(L,b[st[i]]+tag[i]);
					R=max(R,b[en[i]]+tag[i]);
				}
			}
			k--;//排名=比他小的数+1
			int ans=-1;
			while(L<=R){
				int mid=(L+R)/2;
				if(check(l,r,mid,k)){
					ans=mid;
					L=mid+1;
				}else R=mid-1;
			}
			printf("%d\n",ans);
		}
	}
    return 0;
}
```

---

## 作者：Eterna (赞：0)

先用 dfs 序把树拍成序列，然后问题就是区间加，区间第 $k$ 小。

就是一个由乃打扑克，直接分块，询问外层二分答案，查比 $c$ 小的数的个数。可以维护排序后序列，然后块内二分，散块暴力。修改直接整块打标记，散块重构。

但是 $O(n \sqrt{n} \log^2 n)$ 不太行，还要卡下常。

块长取 $O(\sqrt{n} \log n)$ 时，复杂度降为 $O(n \sqrt{n} \log ^{1.5}n)$。然后每个块记一下上次二分的答案，优化二分边界就过了。

---


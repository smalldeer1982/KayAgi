# 鬼故事

## 题目背景

### _给大家讲个鬼故事_
有一天晚上，下着大暴雨。小 K 正在他那小小的书房里做着老师给他布置的、数也数不完的信息题目。关着门，关着窗难免有些闷热。小 K 起身，将书桌前的窗子打开一个小小的细缝，小到没有雨点能透过缝隙飘进来。

今天正是农历七月十五日，中元节，俗称鬼节。小 K 从来都没有在这种日子这么晚睡过，因为小 K 迷信，害怕午夜之后，便有鬼怪出没。然而今天，小 K 无可奈何。

小 K 看了看时间：$23:54$。看到 $4$，小 K 皱了皱眉眉头。$4$，谐音是“死”，特别不吉利。在这种日子看到这样的字眼，往往都是不祥之兆。

小 K 的眼皮在打架。他从来都不会做毒瘤题。他索性趴到了书桌上面，两只眼睛渐渐朦胧了起来。

“那儿有一个本子。”他想着。不知道何时，他的书桌靠窗的一角上，静静地躺着一个湿漉漉的本子，好像是刚刚淋过雨。“它是怎么进来的？”小 K 喃喃道。他下意识地翻开那本本子，看到里面有写了一些字。不知道为什么，那些字在发黄的纸页上看起来也那么红。

左边的那一页写着：

 $$4^{4-4}\le M\le N\le 4^{4^{(4+4-\frac{4}{4})}},\sqrt{4}\le K\le 4^{\sqrt{4}}\times(4-\frac{4}{4})+\sqrt{4}$$

右边的那一页写着的似乎比左边的要长：

 $$a_{\frac{4}{4}}=a_{\sqrt{4}}=\frac{4}{4},a_n=\frac{\sqrt{4}}{\sqrt{4}}\times a_{n-\frac{4}{4}}+4^{4-4}\times a_{n-\sqrt{4}}(n\ge \sqrt{4}+\frac{4}{4})$$  
  
$$b_n=\prod^{n+K-\frac{4}{4}}_{i=n}a_i$$   

求 $\sum\limits_{i=m}^n b_i$

角落里还有一行小字：**_ 不要翻到最后一页，不然会有可怕的事情发生 _**。但是在这个时候，小 K 早已经闭上了双眼，鼾声和远处的雷声混成一片。

一阵微风吹来，轻轻地，谁也没有意识到。本子的一角被风扬起，滑过一个优美的弧线，落在了本子的另一边。风一阵一阵的吹来，拂过本子发黄的书页。渐渐地，右边的书页少了，左边的书页多了。风停了，本子的倒数第二页停在半空中。在一刹那，似乎一切都静止了。然后，它轻轻地落在了其它书页的最上面。

最后一页上，赫然用鲜红色的歪歪扭扭的大字写着：

# 这道题你已经拖了一个月了！限明天之前做完！

这时候，你夜观天象，预测到了小 K 的这场劫难。时间已是 $23:59:59:400$，如果在这 $1000-400=600$ 毫秒内没有做完，小 K 的检讨将在劫难逃。身为小 K 的好朋友，你能帮他解决这个问题吗？


## 题目描述

给定 $k,m,n$，求：  

$$\sum_{i=m}^n \prod_{j=i}^{i+k-1} a_j$$

答案对 $10^9 + 7$ 取模。   
其中 $\{ a\}$ 为 fibonacci 数列。

## 说明/提示

$a_1=1,a_2=1,a_3=2,a_4=3,a_5=5,a_6=8$。

对于样例1：

$$K=4$$
$$b_1=1\times1\times2\times3=6,b_2=1\times2\times3\times5=30,b_3=2\times3\times5\times8=240$$
$$\sum_{i=1}^{3}b_i=276$$

对于样例2：

$$K=3$$
$$b_2=1\times2\times3=6,b_3=2\times3\times5=30$$
$$\sum_{i=2}^{3}b_i=36$$

本题共有 $20$ 个数据点，每个数据点的分数均为 $5$ 分，总分为 $100$ 分。每个数据点的性质如下：

(**出题人不想再用 $4$ 表示任何数了！**~~真香~~)

| 编号 | $K,M,N$范围 | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
|  $1$ |$1\le m\le n\le 10^6,k=4$|无 |
|  $2$ |$1\le m\le n\le 10^{18},k=4$  | $n-m\le 10^6$ |
|  $3\sim 4$ | $1\le m\le n\le 10^{18},k=4$  |无|
| $5\sim 6$  |  $1\le m\le n\le 4^{4^4},k=4$  | $n-m\le 10^6$ |
|  $7\sim 10$ | $1\le m\le n\le 4^{4^7},k=4$ | 无 |
|  $11\sim 12$ | $1\le m\le n\le 4^{6000},2\le k\le 10$| 无 |
|  $13\sim 14$ | $1\le m\le n\le 10^{41},2\le k\le 10$| 无 |
| $15\sim 20$  |$1\le m\le n\le 10^{41},2\le k\le 50$| 无 |

**（注意，题面中的数据范围只是大致描述，请以以上具体范围为准）**

$a^{b^c}=a^{(b^c)}$

## 样例 #1

### 输入

```
4 1 3```

### 输出

```
276```

## 样例 #2

### 输入

```
3 2 3```

### 输出

```
36```

# 题解

## 作者：NaCly_Fish (赞：29)

update：由于这题标算被爆了多次，就详细详细讲一下各做法吧（合订本既视感）。

****
#### 出题人做法：

构造一个矩阵来做快速幂，时间复杂度 $\Theta(k^3 \log n)$。

****
#### 本人第一次做法：

既然这是线性递推，那我们可以用 [BM 算法](https://www.luogu.com.cn/problem/P5487) 找出这个递推式，利用优化的线性递推算法，时间复杂度为 $\Theta(k^2 \log n)$ 或 $\Theta(k \log k \log n)$。

[提交记录](https://www.luogu.com.cn/record/22823640)
****
#### 能不能给力一点啊？

第二次看这题的时候，已经学习了 [这题](https://www.luogu.com.cn/problem/P5320)  EI 的特征根性质优化做法（orz EI！），下面做详细讲解。

设
$$A=\frac{1}{\sqrt 5} \ , \ \alpha=\frac{1+\sqrt 5}{2}$$
则
$$\prod_{i=n}^{n+k-1}f_i=\prod_{i=0}^{k-1}(A\alpha^{n+i}-A(-\alpha)^{-n-i})$$
$$=A^k\prod_{i=0}^{k-1}(\alpha^n\alpha^i-(-\alpha)^{-n}(-\alpha)^{-i})$$
$$=A^k \alpha^{k(k-1)/2} \prod_{i=0}^{k-1}(\alpha^n-(-\alpha)^{-n}(-\alpha^{-2})^i)$$
分类讨论一下 $n$ 的奇偶性，这个式子就能看成是**关于 $\alpha^n$ 的**一个 $k$ 次多项式。  

再用 $x$ 来代换就有两个多项式：
$$\frac{A^k\alpha^{k(k-1)/2}}{x^k}\prod_{i=0}^{k-1}(x^2-(-\alpha^{-2})^i) \ \ (n \bmod 2 = 0)$$
$$\frac{A^k\alpha^{k(k-1)/2}}{x^k}\prod_{i=0}^{k-1}(x^2+(-\alpha^{-2})^i) \ \ (n \bmod 2 = 1)$$
设这两个多项式的 $n$ 次项系数分别为 $p_n,q_n$，答案就是：
$$\left(\sum_{i=m}^n[2|i]\sum_{j=-k}^kp_j \alpha^{ij}\right)+\left(\sum_{i=m}^n[2|(i-1)]\sum_{j=-k}^kq_j\alpha^{ij} \right)$$
$$=\frac 12\sum_{j=-k}^k\left((p_j+q_j)\sum_{i=m}^n\alpha^{ji}\right)+\left( (p_j-q_j)\sum_{i=m}^n(-\alpha^j)^i\right)$$
还有一点常数优化，就是 $p_n=(-1)^{k-n}q_n$，求出 $q$ 后就可以直接求出 $p$。

现在考虑如何求出那两个多项式的系数，只考虑后面那个乘积，是这样一个形式：
$$f(x)=\prod_{i=0}^{k-1}(x+\beta^i)$$
（虽然原式中是 $x^2$，但是没有关系，算出这个后第 $n$ 项对应原式 $2n$ 项。） 

这个式子可以倍增处理，以 $\Theta(k \log k)$ 的时间复杂度求出系数 —— 不过这是不必要的，它满足典型的 **q-整式递推**，我们这样操作：

$$f(\beta x)= \beta^k \prod_{i=0}^{k-1}(x+\beta^{i-1})=\beta^k \frac{x+\beta^{-1}}{x+\beta^{k-1}}f(x)$$
$$(x+\beta^{k-1})f(\beta x)=\beta^k(x+\beta^{-1})f(x)$$
提取系数即得
$$\beta^{i-1}f_{i-1}+\beta^{k+i-1}f_i=\beta^kf_{i-1}+\beta^{k-1}f_i$$
$$f_{i-1}= \frac{\beta^{k-1}-\beta^{k+i-1}}{\beta^{i-1}-\beta^k}f_i$$
从上边界 $f_k=1$ 往下递推即可，线性处理逆元即可 $\Theta(k)$ 求出 $f(x)$ 的系数。统计答案的部分涉及等比数列求和，可以只计算常数次快速幂，其余都能线性处理。

当然，你会发现计算快速幂时只有两次指数特别大，而
$$a_n =\alpha^n \bmod p$$
显然是有循环节的，所以可以直接把指数对 $4p(p+1)$ 取模再计算。

总时间复杂度为 $\Theta(k +\log n)$。

****

参考代码（稍微改改参数就能直接通过加强版）：  

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 20003
#define ll long long
#define p 1000000007
using namespace std;

inline int add(const int& x,const int& y){ return x+y>=p?x+y-p:x+y; }
inline int dec(const int& x,const int& y){ return x<y?x-y+p:x-y; }

inline int intpow(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

struct complex{
    int r,i;
    inline complex(int _r=0,int _i=0):r(_r),i(_i){}
};

inline complex operator + (const complex& lhs,const complex& rhs){ return complex(add(lhs.r,rhs.r),add(lhs.i,rhs.i)); }
inline complex operator - (const complex& lhs,const complex& rhs){ return complex(dec(lhs.r,rhs.r),dec(lhs.i,rhs.i)); }
inline complex operator * (const complex& lhs,const complex& rhs){ return complex(((ll)lhs.r*rhs.r+5ll*lhs.i*rhs.i)%p,((ll)lhs.r*rhs.i+(ll)lhs.i*rhs.r)%p); }
inline complex operator - (const complex& x){ return complex(dec(0,x.r),dec(0,x.i)); }
inline complex operator * (const complex& lhs,const int& rhs){ return complex((ll)lhs.r*rhs%p,(ll)lhs.i*rhs%p); } 
const complex one = complex(1,0);

inline complex power(complex a,ll t){
    complex res = complex(1,0);
    while(t){
        if(t&1) res = res*a;
        a = a*a;
        t >>= 1;
    }
    return res;
}

inline complex inverse(complex x){
    int d = ((ll)x.r*x.r-5ll*x.i*x.i%p+p)%p;
    return complex(x.r,p-x.i)*intpow(d,p-2);
}

complex pre[N>>1];

void product(int k,complex q,complex *t){
    t[k] = 1;
    static complex pw[N];
    pw[0] = pre[0] = one;
    for(int i=1;i<=k;++i) pw[i] = pw[i-1]*q;
    for(int i=1;i<=k;++i) pre[i] = pre[i-1]*(pw[k]-pw[i-1]);
    complex Inv = inverse(pre[k]),suf = one;
    for(int i=k;i;--i){
        t[i-1] = pw[k-1]*(pw[i]-one)*(Inv*pre[i-1]*suf)*t[i];
        suf = suf*(pw[k]-pw[i-1]);
    }
}

char L[N],R[N];
int k;
complex f[N],g[N],inv1[N>>1],inv2[N>>1],suf[N>>1];
const int ninv2 = p-(p-1)/2;
const ll md = 4ll*p*(p+1);
const __int128_t ten = 10;

int main(){
    scanf("%d",&k);
    scanf("%s%s",L,R);
    int lenl = strlen(L),lenr = strlen(R),lmdp = 0,rmdp = 0;
    ll pwl = 0,pwr = 0;
    for(int i=0;i<lenl;++i) lmdp = (lmdp*10ll+L[i]-'0')%p,pwl = (pwl*ten+L[i]-'0')%md;
    for(int i=0;i<lenr;++i) rmdp = (rmdp*10ll+R[i]-'0')%p,pwr = (pwr*ten+R[i]-'0')%md;
    reverse(L,L+lenl),reverse(R,R+lenr);
    int inv5 = intpow(5,p-2);
    complex alpha = complex(ninv2,ninv2),A = complex(0,inv5);
    complex iva = inverse(alpha),q,beta,ans = 0,a2 = alpha*alpha;
    q = power(iva,k),beta = -iva*iva;
    product(k,beta,g);
    for(int i=0;i<=k;++i) f[i] = (k-i)&1?-g[i]:g[i];
    complex pal = power(alpha,pwl),par = power(alpha,pwr+1);
    complex pa2l = pal*pal,pa2r = par*par,pql = power(inverse(pal),k),pqr = power(inverse(par),k);
    complex pali = one,pari = one,qs,nqs,npql = (L[0]&1)?-pql:pql,npqr = (R[0]&1)?pqr:-pqr;
    inv1[0] = q,inv2[0] = q+one;
    for(int i=1;i<=k;++i){
        inv1[i] = inv1[i-1]*a2;
        inv2[i] = inv1[i]+one;
    }
    for(int i=0;i<=k;++i) inv1[i] = inv1[i]-one;
    if(!(k&1)) inv1[k>>1] = one;
    pre[0] = suf[k+1] = one;
    inv1[0] = inverse(inv1[0]);
    for(int i=1;i<=k;++i) pre[i] = pre[i-1]*inv1[i];
    for(int i=k;i;--i) suf[i] = suf[i+1]*inv1[i];
    complex mul = inverse(pre[k]);
    for(int i=1;i<=k;++i) inv1[i] = pre[i-1]*suf[i+1]*mul;
    inv2[0] = inverse(inv2[0]);
    for(int i=1;i<=k;++i) pre[i] = pre[i-1]*inv2[i];
    for(int i=k;i;--i) suf[i] = suf[i+1]*inv2[i];
    mul = inverse(pre[k]);
    for(int i=1;i<=k;++i) inv2[i] = pre[i-1]*suf[i+1]*mul;
    for(int i=0;i<=k;++i){
        if(q.r==1&&q.i==0) qs = dec(rmdp+1,lmdp);
        else qs = (pqr*pari - pql*pali)*inv1[i];
        nqs = (npqr*pari - npql*pali)*inv2[i];
        ans = ans + (f[i]+g[i])*qs - (f[i]-g[i])*nqs;
        pali = pali*pa2l,pari = pari*pa2r;
        q = q*a2;
    }
    ans = ans*power(A,k)*power(alpha,k*(k-1)>>1)*ninv2;
    printf("%d",ans.r);
    return 0;   
}
```

****

关于「能不能再给力一点啊？」这个问题，我对 q-整式递推 还不甚了解，就不妄议了。如果哪天复杂度再有优化，还会回来补的（

---

## 作者：KesdiaelKen (赞：11)

好像有人没有用矩阵快速幂AC了……这里只是参考解答，非最优解。

**题意：定义一个新数列$b$，$b_i=a_ia_{i+1}...a_{i+K-1}$，也就是从第$i$项开始连续$K$个斐波拉契数列项之积，求第$M$个到第$N$个$b_i$的和。**

## 对于$5\%$数据（$data\space1$）：

暴力枚举，不用多说

## 对于$10\%$数据（$data\space1,2$）：

注意到这一部分数据中，$N-M<=10^6$，所以我们可以先用矩阵快速幂得到斐波拉契数列的第$M$项，然后再从$M$到$N$枚举得到答案。

## 对于$20\%$数据（$data\space1,2,5,6$）：

$N-M<=10^6$仍然保留，只不过$N,M$超出了$long long$表示的范围，所以我们用高精度表示$N,M$,做法同$data\space1,2$。

## 对于另外一种$20\%$数据（$data\space1,2,3,4$）：

易知此题需要用矩阵快速幂做，问题就在于如何构造矩阵。

题目要求的即$s_N-s_{M-1}$，其中$s_n=\sum_{i=1}^{n}b_i$。问题转化为如何求$s_n$。

因为$K=4$,所以$s_n=s_{n-1}+a_na_{n+1}a_{n+2}a_{n+3}$。由于出题人最开始的设定是$S_n=S_{n-1}+a_na_{n-1}a_{n-2}a_{n-3}$，为了方便出题人写题解，我们在这里求$S_n$（$s_n=S_{n+3}$，很容易转换）。

有$S_n=S_{n-1}+a_na_{n-1}a_{n-2}a_{n-3}$，而学过矩阵快速幂的同学肯定知道$S_{n-1}$很容易处理，关键问题就在于如何处理$a_na_{n-1}a_{n-2}a_{n-3}$。

因为矩阵快速幂中的单位矩阵只包含常数，所以我们要想办法把$a_na_{n-1}a_{n-2}a_{n-3}$表示成若干个**多项式$\times$常数**之和的形式。

将$a_na_{n-1}a_{n-2}a_{n-3}$拆分。$a_na_{n-1}a_{n-2}a_{n-3}=(a_{n-1}+a_{n-2})a_{n-1}a_{n-2}a_{n-3}=a_{n-1}^2a_{n-2}a_{n-3}+a_{n-1}a_{n-2}^2a_{n-3}$。同理，将$a_{n-1}$拆成$a_{n-2}+a_{n-3}$：$a_{n-1}^2a_{n-2}a_{n-3}+a_{n-1}a_{n-2}^2a_{n-3}=2a_{n-2}a_{n-3}^3+3a_{n-2}^2a_{n-3}^2+a_{n-2}a_{n-3}^3$。

为了方便，我们设$b_n=a_n^3a_{n-1},c_n=a_n^2a_{n-1}^2,d_n=a_na_{n-1}^3$，则$a_na_{n-1}a_{n-2}a_{n-3}=2b_{n-2}+3c_{n-2}+d_{n-2}$。

既然有了上面这个式子，我们就要想办法把$b_{n-2},c_{n-2},d_{n-2}$表示出来。首先是$b_{n-2}$：

$$b_{n-2}=a_{n-2}^3a_{n-3}=(a_{n-3}+a_{n-4})^3a_{n-3}$$

$$=a_{n-3}^4+3a_{n-3}^3a_{n-4}+3a_{n-3}^2a_{n-4}^2+a_{n-3}a_{n-4}^3$$

为了方便，我们设$e_n=a_n^4$，则$b_{n-2}=e_{n-3}+3b_{n-3}+3c_{n-3}+d_{n-3}$。我们发现这个式子是可以用矩阵乘法实现的！

同理有：

$$c_{n-2}=e_{n-3}+2b_{n-3}+c_{n-3}$$

$$d_{n-2}=e_{n-2}+b_{n-3}$$

$$e_{n-2}=e_{n-3}+4b_{n-3}+6c_{n-3}+4d_{n-3}+e_{n-4}$$

至此，$b_{n-2},c_{n-2},d_{n-2},e_{n-2}$就全部被我们表示出来了。所以，我们发现我们可以构造这样的一个矩阵：

$$\begin{pmatrix}1&?&?&?&?&0\\0&3&3&1&1&0\\0&2&1&0&1&0\\0&1&0&0&1&0\\0&4&6&4&1&1\\0&0&0&0&1&0\end{pmatrix}\times \begin{pmatrix}S_{n-1}\\b_{n-3}\\c_{n-3}\\d_{n-3}\\e_{n-3}\\e_{n-4}\end{pmatrix}=\begin{pmatrix}S_{n}\\b_{n-2}\\c_{n-2}\\d_{n-2}\\e_{n-2}\\e_{n-3}\end{pmatrix}$$

这样，我们就可以达到矩阵快速幂可以进行的要求了。

还有一个问题，就是那几个$?$填什么。因为$S_n=S_{n-1}+a_na_{n-1}a_{n-2}a_{n-3}=S_{n-1}+2b_{n-2}+3c_{n-2}+d_{n-2}$，但我们没有直接的$b_{n-2},c_{n-2},d_{n-2}$，只有$b_{n-3},c_{n-3},d_{n-3},e_{n-3}$，但是我们有之前推出的式子可以表示$b_{n-2},c_{n-2},d_{n-2}$与$b_{n-3},c_{n-3},d_{n-3},e_{n-3}$的关系，所以我们将这几个式子代入回$S_n=S_{n-1}+2b_{n-2}+3c_{n-2}+d_{n-2}$，得到$S_n=S_{n-1}+13b_{n-3}+9c_{n-3}+2d_{n-3}+6e_{n-3}$。所以我们就得到了一个完整的式子：

$$\begin{pmatrix}1&13&9&2&6&0\\0&3&3&1&1&0\\0&2&1&0&1&0\\0&1&0&0&1&0\\0&4&6&4&1&1\\0&0&0&0&1&0\end{pmatrix}\times \begin{pmatrix}S_{n-1}\\b_{n-3}\\c_{n-3}\\d_{n-3}\\e_{n-3}\\e_{n-4}\end{pmatrix}=\begin{pmatrix}S_{n}\\b_{n-2}\\c_{n-2}\\d_{n-2}\\e_{n-2}\\e_{n-3}\end{pmatrix}$$

所以

$$\begin{pmatrix}1&13&9&2&6&0\\0&3&3&1&1&0\\0&2&1&0&1&0\\0&1&0&0&1&0\\0&4&6&4&1&1\\0&0&0&0&1&0\end{pmatrix}^{n-4}\times \begin{pmatrix}S_{4}\\b_{2}\\c_{2}\\d_{2}\\e_{2}\\e_{1}\end{pmatrix}=\begin{pmatrix}S_{n}\\...\\...\\...\\...\\...\end{pmatrix}$$

回到一开始，$s_n=S_{n+3}$，所以：

$$\begin{pmatrix}1&13&9&2&6&0\\0&3&3&1&1&0\\0&2&1&0&1&0\\0&1&0&0&1&0\\0&4&6&4&1&1\\0&0&0&0&1&0\end{pmatrix}^{n-1}\times \begin{pmatrix}s_{1}\\b_{2}\\c_{2}\\d_{2}\\e_{2}\\e_{1}\end{pmatrix}=\begin{pmatrix}s_{n}\\...\\...\\...\\...\\...\end{pmatrix}$$

即：

$$\begin{pmatrix}1&13&9&2&6&0\\0&3&3&1&1&0\\0&2&1&0&1&0\\0&1&0&0&1&0\\0&4&6&4&1&1\\0&0&0&0&1&0\end{pmatrix}^{n-1}\times \begin{pmatrix}6\\1\\1\\1\\1\\1\end{pmatrix}=\begin{pmatrix}s_{n}\\...\\...\\...\\...\\...\end{pmatrix}$$

## 对于$30\%$数据（$data\space1,2,3,4,5,6$）：

加一个高精度就可以了。

## 对于$50\%$数据（$data\space1,2,3,4,5,6,7,8,9,10$）：

压位高精。压$17$位可以通过此部分数据。

## 对于$40\%$数据（$data\space1,2,3,4,5,6,13,14$）：

分$9$种情况讨论……

对于每一种情况，求出对应的矩阵。

**从出题人心理角度入手：**

$K$肯定越大越好，所以只用计算$K=8,9,10$的情况即可。

用普通高精度即可（其实$data\space11,12$）用常数小一点的不压位高精度也可以通过。

## 对于$70\%$数据（$data\space1\sim14$）：

用压位高精分$9$种情况讨论。

# 对于$100\%$数据：

~~分49类讨论~~

因为分类讨论过于复杂，所以我们要找到一个一般的求单位矩阵算法。

我们发现，只有$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$与它们的上一项有互推关系，所以我们要用这些项来表示$s_n$，就如之前我们求$K=4$时问号填什么一样。

## _如果这一部分理解有困难，可以结合$K=4$的部分一起看_

**第一步**：求$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$与它们的上一项的递推式

例如，我们要求$a_n^{k}a_{n-1}^{m-k}$的递推式。按照套路，有$a_n^{k}a_{n-1}^{m-k}=(a_{n-1}+a_{n-2})^ka_{n-1}^{m-k}$。由二项式定理，上式等于$C_k^0a_{n-1}^m+C_k^1a^{m-1}_{n-1}a_{n-2}+...+c_k^ka_{n-1}^{m-k}a_{n-2}^k$。
于是，我们维护一个杨辉三角，对于每一个$a_n^{k}a_{n-1}^{m-k}$单独计算即可。我们称这些求出来的递推式为**那一堆式子**……（如$K=4$中的$b_{n-2}=e_{n-3}+3b_{n-3}+3c_{n-3}+d_{n-3},c_{n-2}=e_{n-3}+2b_{n-3}+c_{n-3},d_{n-2}=e_{n-2}+b_{n-3},e_{n-2}=e_{n-3}+4b_{n-3}+6c_{n-3}+4d_{n-3}+e_{n-4}$）

**第二步**：求$a_na_{n-1}...a_{n-k+1}$与$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$的关系式。

同样我们拆分$a_na_{n-1}...a_{n-k+1}$。在此之前，我们先证明一个东西。

求证：$a_n=a_{k+1}a_{n-k}+a_{k}a_{n-(k+1)}$

证明：用数学归纳法证明

1. 当$k=1$时，即证$a_n=1a_{n-1}+1a_{n-2}$，显然成立

2. 假设$k=s(s>=1)$时，$a_n=a_ka_{n-k}+a_{k+1}a_{n-(k+1)}$成立，则$$a_{s+1}a_{n-s}+a_{s}a_{n-(s+1)}=a_{s+1}(a_{n-(s+1)}+a_{n-(s+2)})+a_{s}a_{n-(s+1)}$$$$=a_{n-(s+1)}(a_{s+1}+a_s)+a_{n-(s+2)}a_{s+1}=a_{s+2}a_{n-(s+1)}+a_{s+1}a_{n-(s+2)}$$，即$k=s+1$时命题成立

3. 综上：命题成立

既然有这个结论，我们就可以得到$a_na_{n-1}...a_{n-k+1}=(a_{k-1}a_{n-k+2}+a_{k-2}a_{n-k+1})(a_{k-2}a_{n-k+2}+a_{k-3}a_{n-k+1})...(a_2a_{n-k+2}+a_1a_{n-k+1})a_{n-k+2}a_{n-k+1})$。观察这个式子，发现它是由很多个类似于$(a_{k-1}a_{n-k+2}+a_{k-2}a_{n-k+1})$的多项式组成的，我们称这样的括号为一个单位多项式，$a_{k-1},a_{k-2}$为一个单位多项式的两个系数。

现在，我们的目标就是求出这个式子展开后每一项的系数是多少。我们考虑用类似于求杨辉三角的方法求每一项的系数。

若$K=3$，则原式$=(a_{n-1}+a_{n-2})a_{n-1}a_{n-2}$，即$a_{n-1}^2a_{n-2}+a_{n-1}a_{n-2}^2$，即前面的系数为$1,1$。$K=4$的我们之前已经推导过了，系数为$2,3,1$。$K=5$的为$6,13,9,2$。我们把这个三角列出来：

$0,1,1(1,1)$

$0,2,3,1(2,1)$

$0,6,13,9,2(3,2)$

我们在每行前面补了一个$0$，后面括号中的数表示这一层所对应的那一个单位多项式的两个系数，我们设第$i$层的两个系数分别为$p1_i,p2_i$。我们发现$k_{i,j}$，即第$i$层第$j$个数等于$k_{i-1,j}p1_i+k_{i-1,j-1}p2_i$。所以，我们就可以用类似于求杨辉三角的方式来求出每一项的系数了。

具体来说，我们可以从$a_{n-1}...a_{n-k+1}=(a_{k-2}a_{n-k+2}+a_{k-3}a_{n-k+1})...(a_2a_{n-k+2}+a_1a_{n-k+1})a_{n-k+2}a_{n-k+1})$的系数推到$a_na_{n-1}...a_{n-k+1}=(a_{k-1}a_{n-k+2}+a_{k-2}a_{n-k+1})(a_{k-2}a_{n-k+2}+a_{k-3}a_{n-k+1})...(a_2a_{n-k+2}+a_1a_{n-k+1})a_{n-k+2}a_{n-k+1})$的系数。后者比前者多了一个$(a_{k-1}a_{n-k+2}+a_{k-2}a_{n-k+1})$，而$a_{k-1},a_{k-2}$恰好就是三角里的$p1_i,p2_i$。于是，类似于杨辉三角的思路，每一个系数只与其上一层同样位置的数与上一层前一位的数有关系；而由于新乘上了$p1_i,p2_i$，每一个系数就等于上一层同样位置的数的$p2_i$倍与上一层前一位的数的$p1_i$倍之和（结合上面列出的三角形与$K=4$的情况来理解）。

强调一下，现在求出来的系数都是带在$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$之前的。

系数求出来了，但还没有完。是否记得$K=4$时，将$2,3,1$求出来之后，还要分别把那一堆式子代入回原式？没错，求出来的系数还要分别乘上**那一堆式子**的系数，而那一堆式子我们已经求出来了。所以$a_na_{n-1}...a_{n-k+1}$与$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$的关系我们就求出来了。于是$s_n$与$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$的关系我们也求出来了。**注意，这里写的$a_n^m,a_n^{m-1}a_{n-1}^1,a_n^{m-2}a_{n-1}^2,...,a_n^1a_{n-1}^{m-1}$都有可能表示的是所有单项式下角标整体减$1$或$2$对应的一串另外的单项式，就比如把$a_{n-2}a_{n-3}$写成$a_{n}a_{n-1}$，因为出题人太懒啦，只会复制黏贴！**

然后矩阵快速幂，加一个压$17$位的高精度，这一题就做完了。是不是很简单啊！

如果仍有不理解的地方，可以结合代码理解。

当然还可以用一些毒瘤的方法来优化高精度矩阵快速幂，比如什么$10$进制的矩阵快速幂之类的（但是常数像$\pi$的位数一样大的出题人打的$10$进制的矩阵快速幂TLE了哦~）。

**请大家注意常数优化！**

标程（这是一份加了一些常数优化的代码，但仍然跑的非常慢）：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
#include<iostream>
using namespace std;
const long long mod=1000000007,gjm=1e18;
int k;
struct GJD
{
    long long shu[585];
    int len;
    GJD(){len=0;memset(shu,0,sizeof(shu));}
}m,n,lcgjd;
struct JZ
{
    long long shu[53][53];
    JZ(){memset(shu,0,sizeof(shu));}
}dw,lcjz,s,lcjzjz;
void mem1()
{
    memset(s.shu,0,sizeof(s.shu));
    for(register int i=1;i<=110;i++)s.shu[i][i]=1;
}
void times(JZ *a,JZ *b)
{
    for(register int i=1;i<=k+2;i++)
    {
        for(register int j=1;j<=k+2;j++)
        {
            lcjzjz.shu[i][j]=0;
            for(register int s=1;s<=k+2;s++)
            {
                lcjzjz.shu[i][j]=(lcjzjz.shu[i][j]+(*a).shu[i][s]*(*b).shu[s][j])%mod;
            }
        }
    }
    for(register int i=1;i<=k+2;i++)for(register int j=1;j<=k+2;j++)(*a).shu[i][j]=lcjzjz.shu[i][j];
}
long long x;
GJD d2(GJD &a)
{
    memset(lcgjd.shu,0,sizeof(lcgjd));
    lcgjd.len=a.len;x=0;
    for(register int i=a.len-1;i>=0;i--)
    {
        x=x*gjm+a.shu[i];
        lcgjd.shu[i]=x/2;
        x&=1;
    }
    while(lcgjd.len&&lcgjd.shu[lcgjd.len-1]==0)lcgjd.len--;
    return lcgjd;
}
void j1(GJD &a)
{
    for(register int i=0;i<a.len;i++)
    {
        a.shu[i]--;
        if(a.shu[i]>=0)break;
        a.shu[i]+=gjm;
    }
    while(a.len&&a.shu[a.len-1]==0)a.len--;
}
char lcm[10000],lcn[10000];
long long lcshu,lcshushu;
long long cmul[200]={0},fb[200]={0},exs[200][200]={0};
long long cal(GJD &a)
{
    if(!a.len)return 0;
    j1(a);
    lcjz=dw;mem1();
    for(;a.len;a=d2(a))
    {
        if(a.shu[0]&1)times(&s,&lcjz);
        times(&lcjz,&lcjz);
    }
    long long ans=0,b=1;
    for(register int i=1;i<=k;i++)b=b*fb[i]%mod;
    for(register int i=1;i<=k+1;i++)ans=(ans+s.shu[k+2][i])%mod;
    ans=(ans+s.shu[k+2][k+2]*b)%mod;
    return ans;
}
int main()
{
    scanf("%d%s%s",&k,lcm,lcn);
    int lclen=strlen(lcm);lcshu=0;lcshushu=1;
    for(register int i=lclen-1;i>=0;i--)
    {
        lcshu=lcshu+((long long)(lcm[i]-'0'))*lcshushu;
        lcshushu*=10;
        if((lclen-i)%18==0)
        {
            m.shu[m.len]=lcshu;
            lcshu=0;lcshushu=1;
            m.len++;
        }
    }
    if(lcshu){m.shu[m.len]=lcshu;m.len++;}
    lclen=strlen(lcn);lcshu=0;lcshushu=1;
    for(register int i=lclen-1;i>=0;i--)
    {
        lcshu=lcshu+((long long)(lcn[i]-'0'))*lcshushu;
        lcshushu*=10;
        if((lclen-i)%18==0)
        {
            n.shu[n.len]=lcshu;
            lcshu=0;lcshushu=1;
            n.len++;
        }
    }
    if(lcshu){n.shu[n.len]=lcshu;n.len++;}
    j1(m);
    cmul[1]=1;fb[1]=1;
    for(register int i=2;i<=k-1;i++)
    {
        fb[i]=(fb[i-1]+fb[i-2])%mod;
        for(register int j=i;j>=1;j--)
        {
            cmul[j]=(cmul[j]*fb[i]+cmul[j-1]*fb[i-1])%mod;
        }
    }
    fb[k]=(fb[k-1]+fb[k-2])%mod;
    exs[1][1]=1;
    for(register int i=2;i<=53;i++)
    {
        for(register int j=1;j<=i;j++)
        {
            exs[i][j]=(exs[i-1][j]+exs[i-1][j-1])%mod;
        }
    }
    for(register int i=1;i<=k;i++)
    {
        for(register int j=1;j<=k+1;j++)
        {
            dw.shu[i][j]=exs[k-i+2][j];
        }
        if(i==1)continue;
        for(register int j=1;j<=k+1;j++)
        {
            dw.shu[k+2][j]=(dw.shu[k+2][j]+dw.shu[i][j]*cmul[i-1])%mod;
        }
    }
    dw.shu[k+1][1]=1;dw.shu[k+2][k+2]=1;
    printf("%lld\n",((cal(n)-cal(m))%mod+mod)%mod);
    return 0;
}
```

（据说原来的标程被卡常了……）

## PS:

应该也可以用斐波拉契数列模$1000000007$的循环节（长度为$2000000016$）来做。怎么算出来的？慢慢枚举就可以了，最多$20s$。记得不是直接取模就可以了，还要乘上中间被忽略的几大块。这样可以直接忽略高精时间复杂度的影响，应该会跑的飞快，大家可以试一试。

---

## 作者：ZnPdCo (赞：1)

因为这个式子可以用矩乘做，但是懒了，所以考虑直接 BM，但是可能会遇到一点挫折。

难点应该在 $N$ 和 $M$ 都很大，那么怎么办：答案的循环节为 $2P(P+1)$，直接将 $N$ 和 $M$ 模一下就好了。

考虑证明，因为在这里斐波那契数列的循环节是 $2(P+1)$，但是答案什么时候才会取到一次 $0$ 呢？发现当连续 $P$ 个斐波那契数列拼起来使得答案取遍 $P$ 中的每一个数最后面就可以取回 $0$ 了，所以循环节为 $2P(P+1)$。

---


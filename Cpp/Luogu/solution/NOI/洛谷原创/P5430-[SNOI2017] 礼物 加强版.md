# [SNOI2017] 礼物 加强版

## 题目背景

原题链接 [P5364](https://www.luogu.org/problemnew/show/P5364)

## 题目描述

热情好客的**小猴子**请森林中的朋友们吃饭，他的朋友被编号为 $1\sim n$，每个到来的朋友都会带给他一些礼物：**大香蕉**。其中，第一个朋友会带给他 $1$ 个**大香蕉**，之后，每一个朋友到来以后，都会带给他之前所有人带来的礼物个数再加他的编号的 $k$ 次方那么多个。所以，假设 $k=2$，前几位朋友带来的礼物个数分别是：

$1,5,15,37,83,\ldots$

假设 $k=3$，前几位朋友带来的礼物个数分别是：

$1,9,37,111,\ldots$

现在，**小猴子**好奇自己到底能收到第 $n$ 个朋友多少礼物，因此拜托于你了。

已知 $n,k$，请输出第 $n$ 个朋友送的礼物个数 $\bmod \ 10^9+7$。

## 说明/提示

$\text{10}\%$ 的数据：$n \le 10^6$。
 
另外 $\text{10}\%$ 的数据：$k \le 3$。

前 $\text{40}\%$ 的数据：$n \le 10^{18}, k \le 10$。

前 $\text{60}\%$ 的数据：$n \le 10^{18}, k \le 1000$。

前 $\text{70}\%$ 的数据：$k \le 1000$。

前 $\text{90}\%$ 的数据：$k \le 10^6$。

$\text{100}\%$ 的数据：$n\le 10^{100000},k \le 2\times10^7$。

最后一个测试点的时限为 $2s$，其余为 $1s$。
****
NaCly\_Fish：本题原数据有误，现已修复。

## 样例 #1

### 输入

```
4 2```

### 输出

```
37```

## 样例 #2

### 输入

```
2333333 2```

### 输出

```
514898185```

## 样例 #3

### 输入

```
1234567890000 3```

### 输出

```
891659731```

## 样例 #4

### 输入

```
1000000013 10```

### 输出

```
616417347```

# 题解

## 作者：Aleph1022 (赞：6)

虽然 EI 已经发了[讲稿](https://www.luogu.com.cn/blog/EntropyIncreaser/review-binomial-sums)但我还是稍微写写。

首先考虑贡献其实有方便的组合意义做法，当然也可以上手来一把大力解递推。  
前者主要就是将「他之前所有人带来的礼物个数」重新定义为选择他之前的某个人的礼物个数进行复制，这样 $i^k$ 对 $n$ 的贡献就是在这中间跨越了一个子集的方案数，即 $2^{n-i-1}$ $(i < n)$。

因此问题变为
$$
n^k + \sum\limits_{i=1}^{n-1} i^k 2^{n-i-1}
$$

我们不妨直接考虑形如
$$
\sum\limits_{i=0}^{n-1} i^k q^i
$$

的问题。显然其为
$$
\left[\frac{z^k}{k!}\right] \sum\limits_{i=0}^{n-1} q^i \mathrm e^{iz} = \left[\frac{z^k}{k!}\right] \frac{1-(q\mathrm e^z)^n}{1-q\mathrm e^z}
$$

令 $F(z) = \frac{1-(qz)^n}{1-qz},P(z)=1-(qz)^n$，考虑
$$
F(z+1) = \frac{P(z+1)}{(1-q)-qz}
$$

考虑其有递推
$$
(1-q)F(z+1) = P(z+1) + qz F(z+1)
$$

且 $P(z+1)$ 有 ODE
$$
(z+1)P'(z+1) = -nP(z+1)-n
$$

不妨设 $\mathscr F(z+1) = F(z+1) \bmod z^{k+1},\mathscr P(z+1) = P(z-1) \bmod z^{k+1}$，那么可以预见到
$$
(1-q)\mathscr F(z+1) = \mathscr P(z+1) + qz \mathscr F(z+1) - qz^{k+1} [z^k] \mathscr F(z+1)
$$

且有
$$
\mathscr P'(z+1) = -z\mathscr P'(z+1) + n\mathscr P(z+1) + n - (n-k)z^{k+1} [z^k] \mathscr P(z+1)
$$

根据 EI 给出的证明，可知 $[z^k] F(\mathrm e^z) = [z^k] \mathscr F(\mathrm e^z)$，而根据如上方程我们可以 $\Theta(k)$ 递推出 $\mathscr F(z)$ 各项系数，从而
$$
\begin{aligned}
\left[\frac{z^k}{k!}\right] \mathscr F(\mathrm e^z)
&= \left[\frac{z^k}{k!}\right] \sum\limits_{i=0}^k \mathrm e^{iz} [z^i]\mathscr F(z) \\
&= \sum\limits_{i=0}^k i^k [z^i]\mathscr F(z)
\end{aligned}
$$

通过线性筛计算 $k$ 次幂，时间复杂度 $\Theta(k)$。

---

## 作者：Prean (赞：6)

新的 $ O(k+\log n) $ 做法。

考虑计算每个猴子对答案的贡献。

打个表：
```
1 1 2 4 8 16 32 ...
```
可以看出第 $ i $ 个猴子对答案的贡献是 $ i^k \times 2^{n-i-1} $，特别地，最后一只猴子对答案的贡献是 $ n^k $。

写成柿子：
$$ n^k+\sum_{i=1}^{n-1}i^k \times 2^{n-i-1} $$
$$ n^k+2^{n-1} \times (\sum_{i=1}^{n-1}i^k \times (2^{-1})^i) $$
我们只需要计算出 $ \sum_{i=1}^{n-1}i^k \times (2^{-1})^i $ 即可。

然后我们发现这个柿子是 CODECHEF qpolysum，然后就做完了。

~~还是把做法写一遍吧~~

qpolysum 和本题有不同之处，即 $ i $ 从 $ 0 $ 开始，不过没啥区别，因为你要减掉的是一个 $ 0 $（
$$ S(n)=\sum_{i=0}^{n-1}i^k \times m^i $$
在本题中相当于 $ m=2^{-1} $。

不过这个做法是猜了一个很奇怪的结论，并且做法来自校 OJ 讨论区（

我们猜 $ S(n)=m^n G(n) - G(0) $，其中 $ G(x) $ 是一个不超过 $ k $ 次的多项式。

证明可以看[这个 blog](https://blog.csdn.net/qq_35649707/article/details/79595192) ~~我才不告诉你是我看不懂~~

然后差分一下：
$$ S(n)-S(n-1)=m^n G(n) - m^{n-1} G(n-1) = (n-1)^k \times m^{n-1} $$
$$ G(n) = \frac {(n-1)^k + G(n-1)} m $$
设 $ G(0)=x $，那么我们在 $ n $ 为任何值的时候用 $ x $ 表示 $ G(n) $。

因为这个多项式的次数最高为 $ k $，而对一个 $ k $ 次多项式差分 $ k+1 $ 次后为 $ 0 $，所以我们把 $ G(x) $ 差分 $ k+1 $ 次后得到：
$$ \sum_{i=0}^{k+1} (-1)^{i+1} \binom {k+1} i G(k+1-i) = 0 $$
我们可以用 $ x $ 表示 $ G(0) \sim G(k+1) $，然后解一个一元一次方程即可得到 $ x $，带入可得到 $ G(1) \sim G(k+1) $ 的值。

现在我们可以使用拉格朗日插值计算 $ G(n) $ 了，答案就是 $ m^nG(n)-G(0) $。

$ i^k $ 可以使用线性筛，所以复杂度是 $ O(k+\log n) $。

什么？你卡我空间？$ 10 $ 个数组太多了？？？

实际上可以缩成 $ 7 $ 个 $ \rm int $ 数组和 $ 1 $ 个 $ \rm bool $ 数组。

我的线性筛使用的是直接纪录最小质因数而非纪录是否为质数，可以改成后者。

然后就是 $ q $ 和 $ p $ 数组在使用的时候，$ x $ 和 $ y $ 数组已经不会使用了，所以直接使用 $ x $ 和 $ y $ 代替 $ q $ 和 $ p $ 即可。

code:
```cpp
#include<cstdio>
#include<cctype>
const int M=2e7+5,mod=1e9+7;
int k,n1,n2,top,x[M],y[M],idk[M],pri[M],fac[M],ifac[M];bool zhi[M];
int G[M];
inline void read(){
	char s;long long t1,t2;
	while(isdigit(s=getchar())){
		t1=n1*10ll+(s^48);n1=t1>=mod?t1%mod:t1;
		t2=n2*10ll+(s^48);n2=t2>=mod-1?t2%(mod-1):t2;
	}
}
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int Del(const int&a,const int&b){
	return b>a?a-b+mod:a-b;
}
inline int C(const int&n,const int&m){
	return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
inline int pow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
inline void sieve(const int&M){
	register int i,j,x;idk[1]=1;
	for(i=2;i<=M;++i){
		if(!zhi[i])pri[++top]=i,idk[i]=pow(i,k);
		for(j=1;j<=top&&(x=i*pri[j])<=M;++j){
			idk[x]=1ll*idk[i]*idk[pri[j]]%mod;zhi[x]=true;
			if(!(i%pri[j]))break;
		}
	}
}
inline int Inter(const int&n){
	register int i,tmp,ans=0;
	x[0]=y[k+2]=1;
	for(i=1;i<=k+1;++i)x[i]=1ll*x[i-1]*Del(n,i)%mod;
	for(i=k+1;i>=1;--i)y[i]=1ll*y[i+1]*Del(n,i)%mod;
	for(i=1;i<=k+1;++i){
		if(k+1-i&1)ans=Del(ans,1ll*1ll*x[i-1]*y[i+1]%mod*G[i]%mod*ifac[i-1]%mod*ifac[k+1-i]%mod);
		else ans=Add(ans,1ll*1ll*x[i-1]*y[i+1]%mod*G[i]%mod*ifac[i-1]%mod*ifac[k+1-i]%mod);
	}
	return ans;
}
signed main(){
	register int i,X=0,Y=0;
	fac[0]=fac[1]=ifac[0]=ifac[1]=1;read();scanf("%d",&k);sieve(k+1);x[0]=1;y[0]=0;
	for(i=1;i<=k+1;++i)x[i]=Add(x[i-1],x[i-1]),y[i]=Add(y[i-1],idk[i-1]),y[i]=Add(y[i],y[i]);
	for(i=2;i<=k+1;++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;
	for(i=2;i<=k+1;++i)ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;
	for(i=0;i<=k+1;++i){
		if(i&1){
			X=Add(X,1ll*C(k+1,i)*x[k+1-i]%mod);
			Y=Add(Y,1ll*C(k+1,i)*y[k+1-i]%mod);
		}
		else{
			X=Del(X,1ll*C(k+1,i)*x[k+1-i]%mod);
			Y=Del(Y,1ll*C(k+1,i)*y[k+1-i]%mod);
		}
	}
	G[0]=mod-1ll*Y*pow(X,mod-2)%mod;
	for(i=1;i<=k+1;++i)G[i]=Add(1ll*x[i]*G[0]%mod,y[i]);
	printf("%d",Add(1ll*Del(1ll*pow(500000004,n2)*Inter(n1)%mod,G[0])*pow(2,n2-1)%mod,pow(n1,k)));
}
```

---

## 作者：_rqy (赞：6)

首先...这题解在原题（非加强版）交过一遍...

$O(k+\log n)$！（如果谁有更优的做法的话请告知我...）

首先，容易发现这个东西可以写成矩阵乘法的形式...（如果你没有发现，那还是别做这题了）...然后可以惊奇的发现，矩阵是上三角矩阵，并且对角线上有一个 $2$ 和 $k+1$ 个 $1$！

因为矩阵是上三角，所以显然其特征值就是主对角线上的元素，所以根据递推通项公式之类的性质，可以发现答案一定是这种形式：

$$c_k2^n+\sum_{i=0}^ka_{k,i}n^i$$

即一个 $2^n$ 的项加上一个 $k$ 次多项式。如果我们知道了 $c_k$ 的值，那么通过预处理 $[1, k+1]$ 项就可以拉格朗日插值得到 $n$ 的值。（拉格朗日插值可以做到 $O(k)$）

众所周知 $c_k2^n$ 的差分仍然是 $c_k2^n$，但是 $k$ 次多项式的差分是 $k-1$ 阶多项式，所以把前 $k+1$ 项进行 $k$ 阶差分（这个可以直接用组合数 $O(k)$ 得到）就可以得到 $c_k$ 的值。

这样的话，复杂度瓶颈还剩下预处理前 $k+1$ 项。而可以发现只需要求出 $1^k\dots (k+1)^k$，而这可以通过欧拉筛只求其中素数的幂，从而做到 $O(\pi(k)\log k+k)=O(k)$。

于是总复杂度就是 $O(k+\log n)$。（$O(\log n)$是计算 $2^n$ ~~和输入n~~）（$n$ 更大也不用高精度，只需要对 $10^9+7$ 取模算插值，$10^9+6$ 取模算 $2$ 的幂即可）

但是还有一个坑：当 $n\bmod 10^9+7\le k+1$ 的时候答案并不是 $n\bmod 10^9+7$ 时的答案，因为 $2^n$ 那一项不一定相同...

代码

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>

typedef long long LL;

const int L = 1000050;
const int K = 20000050;
const int mod = 1000000007;

LL pow_mod(LL a, LL b) {
  LL ans = 1;
  for (; b; b >>= 1, a = a * a % mod)
    if (b & 1) ans = ans * a % mod;
  return ans;
}

char n[L];

int n1_mod(int t) {
  int ans = 0;
  for (char *c = n; *c; ++c)
    ans = ((LL)ans * 10 + *c - '0') % t;
  return ans ? ans - 1 : t - 1;
}

int f[K], inv[K], pr[1500000], cnt;

void Sieve(int k) {
  int *pK = f - 1;
  pK[1] = 1;
  for (int i = 2; i <= k + 1; ++i) {
    if (!pK[i]) pK[pr[cnt++] = i] = pow_mod(i, k);
    for (int j = 0; pr[j] * i <= k + 1; ++j) {
      pK[i * pr[j]] = (LL)pK[i] * pK[pr[j]] % mod;
      if (i % pr[j] == 0) break;
    }
  }
}

int main() {
  int k;
  scanf("%s%d", n, &k);

  LL s = 0, tn = n1_mod(mod), qn = n1_mod(mod - 1);
  Sieve(k);
  for (int i = 0; i <= k; ++i) {
    if ((f[i] += s) >= mod) f[i] -= mod;
    if ((s += f[i]) >= mod) s -= mod;
  }

  LL g = -1; inv[1] = 1;
  for (int i = 2; i <= k; ++i) {
    inv[i] = -(LL)(mod / i) * inv[mod % i] % mod;
    g = g * -inv[i] % mod;
  }

  LL c = 1, p = 0;
  for (int i = 0; i <= k; ++i) {
    // sum_{i=0}^k (-1)^(k-i) C(k, i) f[i+1]
    LL _t = c * f[i] % mod;
    c = c * inv[i + 1] % mod * (k - i) % mod;
    if ((k - i) & 1) p -= _t;
    else p += _t;
  }

  if (tn <= k) {
    LL ans = (f[tn] - p * pow_mod(2, tn) + p * pow_mod(2, qn)) % mod;
    return printf("%lld\n", (ans + mod) % mod) & 0;
  }
  LL ans = 0, p2 = p, t = 1;
  for (int i = 0; i <= k; ++i) {
    LL _y = (f[i] - p2) * g % mod;
    ans = (ans * (tn - i) + _y * t) % mod;

    t = t * (tn - i) % mod;
    p2 = p2 * 2 % mod;
    g = g * (i - k) % mod * inv[i + 1] % mod;
  }
  ans = (ans + p * pow_mod(2, qn)) % mod;
  printf("%lld\n", (ans + mod) % mod);
}

```

---

## 作者：Serenata_Immortale (赞：4)

# Solution P5430

根据题意，很容易写出递推式：

$$ s_n=2s_{n-1}+n^k$$

考虑使用矩乘优化，构造矩阵：

$$\begin{bmatrix}s_n\\\\(n+1)^0\\\\(n+1)^1\\\\\vdots\\\\(n+1)^k\end{bmatrix}
=\begin{bmatrix}
2&0&0&\cdots&1\\\\
0&C_0^0&0&\cdots&0\\\\
0&C_1^0&C_1^1&\cdots&0\\\\
\vdots&\vdots&\vdots&\ddots&\vdots\\\\
0&C_k^0&C_k^1&\cdots&C_k^k
\end{bmatrix}
\begin{bmatrix}s_{n-1}\\\\n^0\\\\n^1\\\\\vdots\\\\n^k\end{bmatrix}$$

直接做复杂度$O(k^3\log n)$，可以通过原题，但本题无法通过。

参考[P4723](https://www.luogu.com.cn/problem/P4723)的做法，假设转移矩阵为$A$

则$Ans=(A^n\times St)_1$，$St$为初始矩阵。

假设有一个序列$c$，使得

$$A^n=\sum\limits_{i=0}^{k+1}c_iA^i$$

那么
$$Ans=\sum\limits_{i=0}^{k+1}c_i(A^i\times St)_1=\sum\limits_{i=0}^{k+1}c_is_i$$

就可以$O(k)$算出答案

根据$Cayley-Hamilton$定理，设$f(x)$为$A$的特征多项式，那么$f(A)=0$

其中$f(\lambda)=\det(A-\lambda E)$

显然，

$$\det(A-\lambda E)=\begin{vmatrix}
2-\lambda &0&0&\cdots&1\\\\
0&1-\lambda &0&\cdots&0\\\\
0&C_1^0&1-\lambda &\cdots&0\\\\
\vdots&\vdots&\vdots&\ddots&\vdots\\\\
0&C_k^0&C_k^1&\cdots&1-\lambda 
\end{vmatrix}=(2-\lambda )(1-\lambda )^{k+1}$$

根据[P4723](https://www.luogu.com.cn/problem/P4723)的思路，$x^n \mod{f(x)}$的系数即为序列$c_i$

然后手玩一下取模过程，$\lambda$在后面太难受了，不妨令

$$f(x)=(x-2)(x-1)^{k+1}$$

$$C(x)=x^n\mod{(x-2)(x-1)^{k+1}}$$

那么

$$C(x+1)=(x+1)^n\mod{(x^{k+2}-x^{k+1})}$$

举个例子：

$(x+1)^6\mod{x^4-x^3}$

$=C_6^6x^6+C_6^5x^5+C_6^4x^4+C_6^3x^3+C_6^2x^2+C_6^1x^1+C_6^0x^0\mod{x^4-x^3}$

$=(C_6^6+C_6^5+C_6^4+C_6^3)x^3+C_6^2x^2+C_6^1x^1+C_6^0x^0$

发现规律了吗？

$$C(x+1)=(C_n^n+C_n^{n-1}+\cdots+C_n^{k+1})x^{k+1}+C_n^kx^k+\cdots+C_n^0x^0$$

假设$g_i$表示$C(x+1)$的系数的话

$$g_{k+1}=2^n-\sum\limits_{i=0}^kC_n^i$$

$$g_i=C_n^i,i\leq k$$

我们终究还是要求$C(x)$，所以在此迭代

$$C(x)=\sum\limits_{i=0}^{k+1}g_i(x-1)^i$$

$$=\sum\limits_{i=0}^{k+1}g_i\sum\limits_{j=0}^iC_i^jx^j(-1)^{i-j}$$

$$=\sum\limits_{j=0}^{k+1}x^j\left(\sum\limits_{i=j}^{k}C_n^iC_i^j(-1)^{i-j}+\left(2^n-\sum\limits_{i=0}^kC_n^i\right)C_{k+1}^j(-1)^{i-j}\right)$$

$$=\sum\limits_{j=0}^{k+1}x^j\left(C_n^j\sum\limits_{i=0}^{k-j}C_{n-j}^i(-1)^i+\left(2^n-\sum\limits_{i=0}^kC_n^i\right)C_{k+1}^j(-1)^{i-j}\right)$$

$$=\sum\limits_{j=0}^{k+1}x^j\left(C_n^jC_{n-j-1}^{k-j}(-1)^{k-j}+\left(2^n-\sum\limits_{i=0}^kC_n^i\right)C_{k+1}^j(-1)^{i-j}\right)$$

$$=\sum\limits_{j=0}^{k+1}x^j\left(\frac{n^{\underline{j}}}{j!}\frac{(n-k)^{\overline{k-j}}}{(k-j)!}(-1)^{k-j}+\left(2^n-\sum\limits_{i=0}^k\frac{n^{\underline{i}}}{i!}\right)C_{k+1}^j(-1)^{i-j}\right)$$


后面一大坨就是我们要求的$c_j$，预处理上升幂和下降幂，时间复杂度$O(k)$



---

## 作者：NaCly_Fish (赞：3)

orz $\mathsf r \color{red}\mathsf{qy}$  
来一篇（自认为）更好理解的题解  
之前的代码有一点细节上的错误，现已修复。

原递推式可以写成这样：  
（$s$ 表示前缀和） 
$$a_n=s_{n-1}+n^k$$
$$s_n=2s_{n-1}+n^k$$  

根据一个 [trick](https://www.luogu.com.cn/blog/NaCly-Fish-blog/solution-p5808)，化为线性齐次递推式，得递推系数：  
$$f_n=[x^n](-1+2x)(1-x)^{k+1}$$
直接得到特征方程（实际上就是翻转系数）
$$x^{k+2}(-1+\frac{2}{x})(1-\frac1x)^{k+1}=0$$
$$(-x+2)(x-1)^{k+1}=0$$
解得 $x_1=2,x_2=1$（$k+1$ 重根）  
$$s_n=r2^n+\sum_{i=0}^{k+1}c_in^i$$
由于 $s$ 是 $a$ 的前缀和，可以得到 $a$ 的通项公式为：    
（此处下标从 $0$ 开始，且 $r,c$ 都与上式不同）
$$a_n=r2^n+\sum_{i=0}^kc_in^i$$
考虑这个 $r$ 怎么算：手玩一下 $k=2$ 的情况，解线性方程组得出 $r=6$。  
再分析消元的过程，发现每次消元其实就是差分，所以 $r$ 就等于 $a_{k+1}$ 在 $k+1$ 阶差分后的值。  
$$r=\sum\limits_{i=0}^{k+1}(-1)^{k+1-i}\binom{k+1}{i}a_i$$
算出来 $r$ 之后，设 $b_n=a_n-r2^n$，那么显然 $b_n$ 关于 $n$ 是一个 $k$ 次多项式，拉格朗日插值求出，最后再加 $r2^n$ 即是答案。  
为了做到严格线性复杂度，需要线性筛，可以参考[此题](https://www.luogu.com.cn/problem/P5437)。

最后需要注意的是：  
- 把 $n$ 取模后需要做一些特判：代入插值的时候要模 $10^9+7$，而算指数的时候要模 $10^9+6$。
- 所有非临时计算的值都必须控制在 $[0,10^9+7)$ 范围内

```cpp
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 20000005
#define p 1000000007
#define ll long long
#define reg register
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
using namespace std;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1; 
    }
    return res;
}

int a[N],inv[N],f[N],pre[N],suf[N];
int n1,n2,k,r,cnt,lim,len;

void readin(){
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        n1 = (n1*10ll+(c^48))%p;
        n2 = (n2*10ll+(c^48))%1000000006;
        c = getchar();
    }
    c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        k = (k<<3)+(k<<1)+(c^48);
        c = getchar();
    }
}

void sieve(int ln){
    inv[1] = inv[0] = f[1] = 1;
    for(reg int i=2;i<=ln;++i){
        inv[i] = (ll)(p-p/i)*inv[p%i]%p;
        if(!f[i]){
            a[++cnt] = i;
            f[i] = power(i,k);
        }
        for(reg int j=1;j<=cnt&&i*a[j]<=ln;++j){
            f[i*a[j]] = (ll)f[i]*f[a[j]]%p;
            if(i%a[j]==0) break;
        }
    }
}

inline int interpolation(int x){
    int res = 0,g;
    pre[0] = suf[lim+1] = 1;
    for(reg int i=1;i<=lim;++i) pre[i] = (ll)pre[i-1]*(x-i)%p;
    for(reg int i=lim;i;--i) suf[i] = (ll)suf[i+1]*(x-i)%p;
    for(reg int i=1;i<=lim;++i){
        g = (ll)a[i]*pre[i-1]%p*suf[i+1]%p*inv[i-1]%p*inv[lim-i]%p;
        res = (lim-i)&1?dec(res,g):add(res,g);
    }
    return res;
}

int main(){
    readin();
    lim = k+1;
    sieve(k+2);
    memset(a,0,sizeof(a));
    int ans,s = a[0] = 1;
    for(reg int i=1;i<=lim;++i){
        a[i] = add(s,f[i+1]);
        s = add(s,a[i]);
    }
    int mul = f[0] = 1;
    for(reg int i=0;i<=lim;++i){
        s = (ll)mul*a[i]%p;
        r = (lim-i)&1?dec(r,s):add(r,s);
        mul = (ll)mul*inv[i+1]%p*(lim-i)%p;
    }
    if(n1<=lim+1){
        ans = (a[n1-1]-(ll)r*(power(2,n1-1)-power(2,n2-1))%p+p)%p;
        printf("%d",ans);
        return 0;
    }
    for(reg int i=1;i<=lim;++i){
        f[i] = add(f[i-1],f[i-1]);
        a[i] = (a[i]-(ll)f[i]*r%p+p)%p;
        inv[i] = (ll)inv[i]*inv[i-1]%p;
    }
    ans = (interpolation(n1-1)+(ll)power(2,n2-1)*r)%p;
    printf("%d",ans);
    return 0;   
}
```


---

## 作者：peterwuyihong (赞：2)

班主任坐对面，开不了車，只能写数学题

题意：

$$a_1=1,a_n=S_{n-1}+i^k$$

求 $a_n\bmod (10^9+7)$，$n\le 10^{18},k\le 10$

解它！

$$a_n=S_{n-1}+n^k$$

$$a_{n-1}=S_{n-2}+(n-1)^k$$

相减得到

$$a_n=2a_{n-1}+n^k-(n-1)^k$$

$$\frac{a_n}{2^n}=\frac{a_{n-1}}{2^{n-1}}+\frac{n^k-(n-1)^k}{2^n}$$

令 $b_n=\dfrac{a_n}{2^n}$，那么 

$$b_n=0.5+\sum_{i=2}^n\frac{i^k-(i-1)^k}{2^i}=\sum_{i=1}^n\frac{i^k-(i-1)^k}{2^i}$$

$$=\frac{n^k}{2^n}-\frac{(n-1)^k}{2^{n}}+\frac{(n-1)^k}{2^{n-1}}-\frac{(n-2)^k}{2^{n-1}}$$

$$=\frac{n^k}{2^n}+\sum_{i=1}^{n-1}\frac{i^k}{2^{i+1}}$$

考虑求一个 $G(n)=\sum_{i=1}^{n-1}i^k/2^i$

这是[P5907 数列求和加强版 / SPOJ MOON4](https://www.luogu.com.cn/problem/P5907)，于是直接套[模板类](https://www.luogu.com.cn/paste/y0f9e3gu)就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Fread{
const int SIZE= 1 << 16;
	char buf[SIZE],*S,*T;
	inline char getchar(){if(S==T){T=(S=buf)+
	fread(buf,1,SIZE,stdin);if(S==T)return'\n';}return *S++;}
} // namespace Fread
#define getchar Fread::getchar
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
const int p=1e9+7;
template<class _Tp,class _tp>void add(_Tp&x,const _tp& y){((x+=y)>=p)&&(x-=p);}template<class _Tp,class _tp>_Tp Add(_Tp x,const _tp y){add(x,y);return x;}
template<class _Tp,class _tp>void sub(_Tp&x,const _tp&y){((x-=y)<0)&&(x+=p);}template<class _Tp,class _tp>_Tp Sub(_Tp x,const _tp y){sub(x,y);return x;}
template<class _Tp,class _tp>void mul(_Tp&x,const _tp&y){x=1ll*x*y%p;}template<class _Tp,class _tp>_Tp Mul(const _Tp x,const _tp y){return 1ll*x*y%p;}
template<class _Tp,class _tp>_Tp ksm(_Tp a,_tp b){_Tp ans(1);for(;b;b>>=1,mul(a,a))if(b&1)mul(ans,a);return ans;} 
template<class _Tp>_Tp div2(_Tp a){if(a&1)a+=p;return a>>1;}
using i64 = long long;
int calc(const int n,const int _n,const int a,const int k){
  assert(a!=1);
  vector<int>jcinv(k+2),pri,idk(k+2);
  vector<bool>v(k+2);idk[1]=1;
  int jc=1;rep(i,1,k+1)mul(jc,i);jcinv[k+1]=ksm(jc,p-2);
  per(i,k,0)jcinv[i]=Mul(jcinv[i+1],i+1);rep(i,2,k+1){
    if(!v[i])pri.push_back(i),idk[i]=ksm(i,k);
    for(int j:pri){
      if(i*j>k+1)break;
      v[i*j]=1;idk[i*j]=Mul(idk[i],idk[j]);
      if(i%j==0)break;
    }
  }
  auto C=[&](int n,int m){return Mul(jc,Mul(jcinv[m],jcinv[n-m]));};
  vector<int>lk(k+6),lt(k+6);int uu=ksm(a,p-2);
  lk[0]=1;rep(i,1,k+1){
    lk[i]=Mul(lk[i-1],uu);
    lt[i]=Mul(lt[i-1],uu);
    add(lt[i],idk[i]);
  }
  int rek=0,ret=0;
  rep(i,0,k+1){
    int dk=Mul(C(k+1,i),lk[k+1-i]);
    int dt=Mul(C(k+1,i),lt[k+1-i]);
    if(i&1)sub(rek,dk),sub(ret,dt);
    else add(rek,dk),add(ret,dt);
  }
  vector<int>g(k+6);g[0]=Sub(0,Mul(ret,ksm(rek,p-2)));
  rep(i,1,k+5)g[i]=Add(Mul(g[i-1],uu),idk[i]);
  int CC=0;
  if(n<=k+1)CC=g[n];
  else{
    int GG=1;
    rep(i,1,k+1)mul(GG,n-i);
    vector<int>si(k+5);int s=1;rep(i,1,k+1)mul(s,Sub(n,i));
    si[k+1]=ksm(s,p-2);
    per(i,k,0)si[i]=Mul(si[i+1],Sub(n,i+1));
    s=1;rep(i,1,k+1){
      int tmp=Mul(jcinv[i-1],jcinv[k+1-i]);
      mul(tmp,Mul(g[i],Mul(s,si[i])));
      if((k+1-i)&1)mul(tmp,Sub(0,GG));
      else mul(tmp,GG);
      add(CC,tmp);
      mul(s,Sub(n,i));
    }
  }
  return Sub(Mul(CC,ksm(a,_n)),g[0]);
}
signed main(){
//  freopen("testdata.in","r",stdin);
  int n=0,_n=0;int k=0;
  char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();
  while(ch>='0'&&ch<='9'){
    n=(n*10ll+ch-'0')%p;
    _n=(_n*10ll+ch-'0')%(p-1);
    ch=getchar();
  }
  while(ch<'0'||ch>'9')ch=getchar();
  while(ch>='0'&&ch<='9'){
    k=(k*10+ch-'0');
    ch=getchar();
  }
  int ans=ksm(n,k);
  add(ans,Mul(ksm(2,_n-1),calc(n-1,_n-1,(p+1)>>1,k)));
  printf("%d",ans);
}
```
卡空间有点小恶心啊。。。

---


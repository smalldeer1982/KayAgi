# [MtOI2019] 幽灵乐团 / 莫比乌斯反演基础练习题

## 题目背景

白玉楼中，冥界的音乐会开始了。

Lunasa，Lyrica 和 Merlin 正在演奏。

## 题目描述

东风谷 早苗(Kochiya Sanae)非常喜欢幽灵乐团的演奏，她想对她们的演奏评分。

因为幽灵乐团有 $3$ 个人，所以我们可以用 $3$ 个正整数 $A,B,C$ 来表示出乐团演奏的分数，她们的演奏分数可以表示为

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}$$

因为音乐在不同的部分会有不同的听觉感受，所以 $type$ 会在 $\{0,1,2\}$ 中发生变化，其中：

$$\begin{aligned}
f(0)&=1 \cr
f(1)&=i \times j \times k \cr
f(2)&=\gcd(i,j,k)
\end{aligned}$$

因为乐团的歌实在太好听了，导致分数特别高，所以她们的分数要对给定的正整数 $p$ 取模。

因为有很多歌曲要演奏，所以早苗给出了 $T$ 组询问。

## 说明/提示

### 数据范围及约定

对于 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 50 $$  

对于 $20\%$ 的数据：  

$$ 1\leq A,B,C\leq 100 $$

另有 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 100\ \ \ \ \ A=B=C $$  

对于 $60\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^3 $$

对于 $100\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^5 \ \ \ \ 10^7 \leq p \leq 1.05\times 10^9\ \ \ \ p\in \{ prime\} \ \ \ \ T =70$$

---

早苗非常善良，就算你不知道所有的正确答案，她也会给你一些分数。 
 
* 如果你的第一列是正确的，她将会给你这个测试点 $20\%$ 的分数。
* 如果你的第二列是正确的，她将会给你这个测试点 $40\%$ 的分数。
* 如果你的第三列是正确的，她将会给你这个测试点 $40\%$ 的分数。  

所以就算你不知道答案是什么，也请你在你不知道的那些地方输出 $[0,2^{31})$ 内的整数，否则可能会造成不可预估的错误。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T5

出题人：CYJian 


## 样例 #1

### 输入

```
3 998244853
1 1 1
2 2 2
3 3 3
```

### 输出

```
1 1 1
16 4096 16
180292630 873575259 180292630
```

# 题解

## 作者：CYJian (赞：78)

先说几句:

如果这道题有哪个神仙用单次 $O(n\log n)$ 的复杂度过了~~我请您抽烟~~。

欢迎大佬吊打垃圾标算。

本片题解中有部分地方由于人懒所以复制粘贴的时候 $td$ 没有换成 $T$, 请各位大佬自行替换一下吧（有时间再补锅）。

----

首先对于 $10$ 分的数据可以直接暴力求。

然后如果打出一张 $\gcd$ 的表，然后 $n^3$ 模拟预处理就可以获得 $30$ 分。

首先，我们注意到原式可以化为下面这样：

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \left(\frac{{\rm lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}$$

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \left(\frac{i\times j}{\gcd(i,j)\times \gcd(i,k)}\right)^{f(type)}$$

然后，显然可以分为两个子问题：

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{f(type)}$$

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)^{f(type)}$$

然后我们就根据 `type` 分别推一推式子吧。

## ${\rm type=0}$

我们先来看看第一个式子吧：

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i$$

$$ \prod_{i=1}^{A}\prod_{j=1}^{B} i^{C}$$

$$ \left(\prod_{i=1}^{A}i\right)^{B \times C}$$

预处理一个阶乘，写个快速幂就完事了。

然后就是第二个式子了。

$$ \left(\prod_{i=1}^{A}\prod_{j=1}^{B} gcd(i,j)\right)^{C}$$

然后这就可以过$10^3$了。然后就可以得到12分了。

然后就可以反演了。

如果不会莫比乌斯反演，那么就请先科普完莫比乌斯反演并且推了几道题后再来看这篇题解。

然后继续吧。

$$ \left(\prod_{i=1}^{A}\prod_{j=1}^{B} \gcd(i,j)\right)^{C}$$

$$ \left(\prod_{d=1}d^{\sum_{i=1}^{A/d}\sum_{j=1}^{B/d} [\gcd(i,j)=1]}\right)^{C}$$

$$ \left(\prod_{d=1}d^{\sum_{t=1}\mu(t)\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor}\right)^{C}$$

$$ \left(\prod_{T=1}\left(\prod_{d|T}d^{\mu(\frac{T}{d})}\right)^{\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor}\right)^{C}$$

显然中间的式子可以像狄利克雷卷积一样 $O(n\log n)$ 预处理出来，然后整除分块可以 $O(\sqrt{n}\log n)$ 做掉。

这两个式子结合一下就有 $20$ 分了。

## ${\rm type=1}$

一样,我们先来考虑第一个式子。

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{i \times j \times k}$$

$$ \prod_{i=1}^{A}\prod_{j=1}^{B} i^{i \times j \times \sum_{k=1}^{C}k}$$

$$ \prod_{i=1}^{A} i^{i \times (\sum_{j=1}^{B}j) \times (\sum_{k=1}^{C}k)}$$

$$ \left(\prod_{i=1}^{A} i^i\right)^{F(B) \times F(C)}$$

其中: $F(x)=\frac{x \times (x + 1)}{2}$。

这个东西可以 $O(n\log n)$ 预处理一下, 再加上快速幂就行了。

记得指数上要对 $mod-1$ 取模。

然后考虑第二个式子。

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)^{i \times j \times k}$$

$$ \left(\prod_{i=1}^{A}\prod_{j=1}^{B} gcd(i,j)^{i \times j}\right)^{F(C)}$$

这里就能做 $n \leq 10^3$ 的数据了。

大概用 $O(n^2\log n)$ 的时间打一个 $n^2$ 的表，然后预处理矩阵的前缀积，询问直接 $O(1)$ 查表后加上一个 $F(C)$ 的快速幂就行了。

然后继续推:

$$ \left(\prod_{d=1}d^{d^2\sum_{i=1}^{A/d}\sum_{j=1}^{B/d} i \times j \times [gcd(i, j)=1]}\right)^{F(C)}$$

$$ \left(\prod_{d=1}d^{\sum_{t=1}d^2\mu(t)t^2F(\left\lfloor\frac{A}{td}\right\rfloor)F(\left\lfloor\frac{B}{td}\right\rfloor)}\right)^{F(C)}$$

$$ \left(\prod_{T=1}\left( \left(\prod_{d|T} d^{\mu(\frac{T}{d})}\right)^{T^2} \right)^{F(\left\lfloor\frac{A}{td}\right\rfloor)F(\left\lfloor\frac{B}{td}\right\rfloor)}\right)^{F(C)}$$

虽然式子看上去麻烦了一点，但是还是能预处理的。

中间那一坨 $\left(\prod_{d|T} d^{\mu(\frac{T}{d})}\right)^{T^2}$ 可以用类似狄利克雷卷积的办法预处理，复杂度还是 $O(n \log n)$。

然后预处理一个前缀积以及逆元啥的就能单次询问 $O(\sqrt{n} \log n)$ 了。

结合以上的所有算法，可以得到 $60$ 分。

## ${\rm type=2}$

还是先康康第一个式子:

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{\gcd(i,j,k)}$$

考虑反演:

$$ \prod_{d=1}\prod_{i=1}^{A/d}(id)^{d\sum_{j=1}^{B/d}\sum_{k=1}^{C/d}[\gcd(i,j,k)=1]}$$

$$ \prod_{d=1}\prod_{t=1}\prod_{i=1}^{A/td}(itd)^{\mu(t)d \left\lfloor\frac{B}{td}\right\rfloor\left\lfloor\frac{C}{td}\right\rfloor}$$

$$ \prod_{T=1}\left(\prod_{d|T}\left(fac\left(\left\lfloor\frac{A}{T}\right\rfloor\right) \times T^{\left\lfloor\frac{A}{T}\right\rfloor}\right)^{\mu(\frac{T}{d})d }\right)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}$$

$$ \prod_{T=1}\left(\left(fac\left(\left\lfloor\frac{A}{T}\right\rfloor\right) \times T^{\left\lfloor\frac{A}{T}\right\rfloor}\right)^{\sum_{d|T}\mu(\frac{T}{d})d }\right)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}$$

$$ \prod_{T=1}\left(\left(fac\left(\left\lfloor\frac{A}{T}\right\rfloor\right) \times T^{\left\lfloor\frac{A}{T}\right\rfloor}\right)^{\varphi(T)}\right)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}$$

然后对于 $T^{\varphi(T)}$ 做个前缀积以及逆元的预处理就行了...再预处理一个模$mod-1$ 意义下的 $\varphi(T)$ 的前缀和, 做整除分块的时候 $\frac{A}{T}$ 的指数.

然后考虑第二个式子.

我们考虑枚举 $\gcd(i,j)$

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i,j)^{\gcd(i,j,k)}$$

$$ \prod_{d=1}d^{\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}[gcd(i,j)=1] \times \sum_{k=1}^{C} \gcd(d,k)}$$

$$ \prod_{d=1}d^{\left(\sum_{t=1}\mu(t)\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor\right) \times \left(\sum_{k=1}^{C} \gcd(d,k)\right)}$$

$$ \prod_{T=1}\left(\prod_{d|T}d^{\mu(\frac{T}{d}) \times \left(\sum_{k=1}^{C} \gcd(d,k)\right)}\right)^{\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor}$$

把里面那个 $\gcd$ 的式子拿出来:

$$\sum_{k=1}^{C} gcd(d,k)$$

$$\sum_{d'|d}d'\sum_{k=1}^{C/d'} [gcd(\frac{d}{d'},k) = 1]$$

$$\sum_{d'|d}d'\sum_{t'|\frac{d}{d'}}\mu(t')\left\lfloor\frac{C}{t'd'}\right\rfloor$$

$$\sum_{T'
|d}\left\lfloor\frac{C}{T'}\right\rfloor\varphi(T')$$

然后套回去。

这样大概能拿个$n \leq 1000$的分数。

其实..我们如果把它套回到前一个式子里头:

$$ \prod_{d=1}d^{\left(\sum_{t=1}\mu(t)\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor\right) \times \left(\sum_{T'|d}\left\lfloor\frac{C}{T'}\right\rfloor\varphi(T')\right)}$$

你会发现,它可以用 $O(n \log n)$ 的时间复杂度完成。

~~如果你常数优化很牛逼，过了我请你抽烟~~

当然还有另外一种做法: 枚举 $\gcd(i,j,k)$。

$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i,j)^{\gcd(i,j,k)}$$

$$ \prod_{d=1}\prod_{i=1}^{A/d}\prod_{j=1}^{B/d} (d \times \gcd(i,j))^{d\sum_{k=1}^{C/d}[\gcd(i,j,k)=1]}$$

$$ \prod_{d=1}\prod_{t=1}\prod_{i=1}^{A/td}\prod_{j=1}^{B/td} (td \times \gcd(i,j))^{\mu(t)d\left\lfloor\frac{C}{td}\right\rfloor}$$

然后我们把底数的td分离出来:

$$ \left(\prod_{d=1}\prod_{t=1}(td)^{\mu(t)d\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor\left\lfloor\frac{C}{td}\right\rfloor}\right)  \times  \left(\prod_{d=1}\prod_{t=1}\prod_{i=1}^{A/td}\prod_{j=1}^{B/td} \gcd(i,j)^{\mu(t)d\left\lfloor\frac{C}{td}\right\rfloor}\right)$$

然后把前面一坨式子拿出来:

$$ \prod_{d=1}\prod_{t=1}(td)^{\mu(t)d\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor\left\lfloor\frac{C}{td}\right\rfloor}$$

$$ \prod_{T=1}T^{\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor\left\lfloor\frac{C}{td}\right\rfloor\sum_{d|T}\mu(\frac{T}{d})d}$$

$$ \prod_{T=1}(T^{\varphi(T)})^{\left\lfloor\frac{A}{td}\right\rfloor\left\lfloor\frac{B}{td}\right\rfloor\left\lfloor\frac{C}{td}\right\rfloor}$$

然后我们拿出前面 $i^{gcd(i,j,k)}$ 的部分:

$$ \prod_{T=1}\left(\left(fac\left(\left\lfloor\frac{A}{T}\right\rfloor\right) \times T^{\left\lfloor\frac{A}{T}\right\rfloor}\right)^{\varphi(T)}\right)^{\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}$$

也把底数拿出来:

$$ \left(\prod_{T=1}\left(fac\left(\left\lfloor\frac{A}{T}\right\rfloor\right)\right)^{\varphi(T)\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}\right) \times \left(\prod_{T=1}\left(T^{\varphi(T)}\right)^{\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}\right)$$

然后发现后面一坨东西是可以约掉的。然后我们就变成了分别计算下面两个部分:

$$ \prod_{T=1}\left(fac\left(\left\lfloor\frac{A}{T}\right\rfloor\right)\right)^{\varphi(T)\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor} $$

$$ \prod_{d=1}\prod_{t=1}\prod_{i=1}^{A/td}\prod_{j=1}^{B/td} \gcd(i,j)^{\mu(t)d\left\lfloor\frac{C}{td}\right\rfloor}$$

显然第一个式子已经可以整除分块做了。

但是第二个还需要再搞搞。

$$ \prod_{d=1}\prod_{t=1}\prod_{d'=1}\prod_{t'=1} d'^{\mu(t')\mu(t)d\left\lfloor\frac{C}{td}\right\rfloor\left\lfloor\frac{A}{tt'dd'}\right\rfloor\left\lfloor\frac{B}{tt'dd'}\right\rfloor}$$

$$ \prod_{T=1}\left(\prod_{T'=1} \left(\prod_{d|T'}d^{\mu(\frac{T'}{d})}\right)^{\left\lfloor\frac{A}{TT'}\right\rfloor\left\lfloor\frac{B}{TT'}\right\rfloor}\right)^{\varphi(T)\left\lfloor\frac{C}{T}\right\rfloor}$$

预处理出中间那一坨 $\prod_{d|T'}d^{\mu(\frac{T'}{d})}$ 之后, 可以两次整除分块 $O(n^{0.75} \log n)$ 做掉了.

---

## 作者：peterwuyihong (赞：53)

应同学邀，写一下这道题 $\text{type=2}$ 的神秘过程。

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C(\frac{\text{lcm}(i,j)}{\gcd(j,k)})^{\gcd(i,j,k)}$$

发扬人类智慧，发现乘法十分复杂，于是你自然而然地想到了 $\exp\&\ln$ 。

对它求 $\ln$ ：

$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\gcd(i,j,k)\ln(\frac{\text{lcm}(i,j)}{\gcd(j,k)})$$

$$\sum_{d=1}^{\min(A,B,C)}\varphi(d)\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k=1}^{\lfloor\frac{C}{d}\rfloor}\ln(\frac{\text{lcm}(id,jd)}{\gcd(jd,kd)})$$

约去 $d$ ：

$$\sum_{d=1}^{\min(A,B,C)}\varphi(d)\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k=1}^{\lfloor\frac{C}{d}\rfloor}\ln(\frac{\text{lcm}(i,j)}{\gcd(j,k)})$$

$\exp$ 一下就是！

$$\prod_{d=1}^{\min(A,B,C)}F_{type=0}(\lfloor\frac{A}{d}\rfloor,\lfloor\frac{B}{d}\rfloor,\lfloor\frac{C}{d}\rfloor)^{\varphi(d)}$$

附上 $type=0,1$ 的书面题解，手动 $\text{latex}$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsc12yqb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/foexad2s.png)

代码：

```cpp
#define int __int128
#define maxn 100010
int T;
int _(){
	int p;
	rd(T),rd(p);
	return p;
}
const int p=_();
int q[70][3],mx,MX;
int min(int a,int b,int c){
	return min(a,min(b,c));
}
int max(int a,int b,int c){
	return max(max(a,b),c);
}
int ksm(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
int pri[maxn],tot,mu[maxn],phi[maxn];
bool v[maxn];
int f1[maxn],f2[maxn];
int invf1[maxn],invf2[maxn];
void shai(int n){
	mu[1]=phi[1]=1;
	for(int i=2;i<=n;i++){
		if(v[i]==0)pri[++tot]=i,mu[i]=-1,phi[i]=i-1;
		for(int j=1;j<=tot&&i*pri[j]<=n;j++){
			v[i*pri[j]]=1;
			if(i%pri[j]==0){
				mu[i*pri[j]]=0;
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			mu[i*pri[j]]=-mu[i];
			phi[i*pri[j]]=phi[i]*phi[pri[j]];
		}
	}
	for(int i=0;i<=n;i++)f1[i]=1;
	for(int i=1;i<=n;i++)phi[i]+=phi[i-1];
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j+=i)
	f1[j]=f1[j]*ksm(i,(p-1+mu[j/i])%(p-1))%p;
	for(int i=0;i<=n;i++)f2[i]=ksm(f1[i],i*i%(p-1));
	invf1[0]=invf2[0]=1;
	for(int i=1;i<=n;i++){
		f1[i]=f1[i]*f1[i-1]%p;
		invf1[i]=ksm(f1[i],p-2);
		f2[i]=f2[i]*f2[i-1]%p;
		invf2[i]=ksm(f2[i],p-2);
	}
}
int fac[maxn];
int ii[maxn];
void SHAI(int n){
	fac[0]=ii[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%p;
	for(int i=1;i<=n;i++)ii[i]=ii[i-1]*ksm(i,i)%p;
}
int F(int A,int B){
	int ans=1;
	int fuck=min(A,B);
	for(int L=1,R;L<=fuck;L=R+1){
		int Aa=A/L,Bb=B/L;
		R=min(A/Aa,B/Bb);
		ans=ans*ksm(f1[R]*invf1[L-1]%p,Aa*Bb%(p-1))%p;
	}
	return ans;
}
int S(int x){
	return x*(x+1)/2%(p-1);
}
int G(int A,int B){
	int ans=1;
	int fuck=min(A,B);
	for(int L=1,R;L<=fuck;L=R+1){
		R=min(A/(A/L),B/(B/L));
		ans=ans*ksm(f2[R]*invf2[L-1]%p,S(A/L)*S(B/L)%(p-1))%p;
	}
	return ans;
}
int s1(int A,int B,int C){
	int tmp;
	int ans1=ksm(fac[A],B*C%(p-1))*ksm(fac[B],A*C%(p-1))%p;
	tmp=ksm(F(A,B),C)*ksm(F(A,C),B)%p;
	ans1=ans1*ksm(tmp,p-2)%p;
	return ans1;
}
int s2(int A,int B,int C){
	int tmp;
	int ans2=ksm(ksm(ii[A],S(B))*ksm(ii[B],S(A))%p,S(C));
	tmp=ksm(G(A,B),S(C))*ksm(G(A,C),S(B))%p;
	ans2=ans2*ksm(tmp,p-2)%p;
	return ans2;
}
int s3(int A,int B,int C){
	int ans3=1;
	int fuck=min(A,B,C);
	for(int L=1,R;L<=fuck;L=R+1){
		R=min(A/(A/L),B/(B/L),C/(C/L));
		ans3=ans3*ksm(s1(A/L,B/L,C/L),(phi[R]-phi[L-1])%(p-1))%p;
	}
	return ans3;
}
int A,B,C;
signed main(){
	for(int i=0;i<T;i++){
		rd(q[i][0]),rd(q[i][1]),rd(q[i][2]);
		mx=max(mx,min(q[i][0],q[i][1],q[i][2]));
		MX=max(MX,max(q[i][0],q[i][1],q[i][2]));
	}
	shai(MX),SHAI(MX);
//	cout<<F(39,124)<<endl;return 0;
	for(int i=0;i<T;i++){
		A=q[i][0],B=q[i][1],C=q[i][2];
		wr(s1(A,B,C)),putchar(' ');
		wr(s2(A,B,C)),putchar(' ');
		wr(s3(A,B,C)),putchar('\n');
	}
}

```

---

## 作者：qwaszx (赞：21)

这题....精神污染....

一个一个来~~我会说我写的时候一口气推完所有式子之后找不着式子在哪吗~~

warning:需要反演基础，最好做过数字表格

首先可以拆成

$$\begin{aligned}{}\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\left(\frac{ij}{\gcd(i,j)\gcd(i,k)}\right)^{f(type)}\end{aligned}$$

因为是连乘所以直接分子分母分开算，要求的就是形如

$$\begin{aligned}\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci^{f(type)}\end{aligned}$$

以及

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(type)}$$

这样的问题.

以下默认$A\leq B$，除法为整除

## type=0

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci=\prod_{i=1}^Ai^{BC}=(A!)^{BC}$$

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)=\left(\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)\right)^C$$

现在请留意括号里面的式子，我们一会还要用.当然这是一个非常经典的式子，我们就写得简单一点

$$\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)=\prod_{d=1}^A\prod\limits_{i=1}^A\prod\limits_{j=1}^Bd^{[\gcd(i,j)=d]}=\prod_{d=1}^A\prod_{k=1}^{A/d}d^{\mu(k)\lfloor\frac{A}{kd}\rfloor\lfloor\frac{B}{kd}\rfloor}=\prod_{T=1}^A\left(\prod_{d\mid T}d^{\mu(T/d)}\right)^{\lfloor\frac{A}{T}\rfloor\lfloor\frac{B}{T}\rfloor}$$

预处理里面这个东西就可以单次$O(\sqrt{n}\log n)$做了.关于预处理有$O(n\log n)$和$O(n\log\log n)$两种做法，可以去看rqy的日报或者我的数字表格题解，这里就不再赘述.

## type=1

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci^{ijk}=\left(\prod_{i=1}^Ai^i\right)^{S(B)S(C)}$$

$$S(n)=\sum\limits_{i=1}^n=\frac{n(n+1)}{2}$$

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{ijk}=\left(\prod_{i=1}^{A}\prod_{j=1}^B\gcd(i,j)^{ij}\right)^{S(C)}$$

$$\prod_{i=1}^{A}\prod_{j=1}^B\gcd(i,j)^{ij}=\prod_{d=1}^A\prod_{i=1}^{A/d}\prod_{j=1}^{B/d}d^{ijd^2[\gcd(i,j)=1]}=\prod_{d=1}^{A}\prod_{k=1}^{A/d}d^{\mu(k)d^2k^2S(A/kd)S(B/kd)}=\prod_{T=1}^A\left(\prod_{d\mid T}d^{\mu(T/d)}\right)^{T^2S(A/T)S(B/T)}$$

预处理$\left(\prod\limits_{d\mid T}d^{\mu(T/d)}\right)^{T^2}$就可以$O(\sqrt{n}\log n)$计算了.预处理的方法是在前面预处理的那个东西上取$T^2$次幂

## type2

为什么要加前两个类型...只留这一个不是更好吗...无端增加代码量...

下面的东西要麻烦一些

$$\begin{aligned}\prod_{i=1}^{A}\prod_{j=1}^B\prod_{k=1}^Ci^{\gcd(i,j,k)}&=\prod_{i=1}^Ai^{\sum_{j=1}^B\sum_{k=1}^C\gcd(i,j,k)}\\&=\prod_{i=1}^Ai^{\sum_{d\mid A}\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}\\&=\prod_{d=1}^A\left(\prod_{i=1}^{A/d}id\right)^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}\\&=\prod_{d=1}^A\left(d^{\lfloor\frac{A}{D}\rfloor}\left\lfloor\frac{A}{d}\right\rfloor!\right)^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}\end{aligned}$$

预处理$d^{\varphi(d)}$的前缀积以及$\varphi$的前缀和即可$O(\sqrt{n})\log n$回答询问

还剩一个最精神污染的式子...

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{\gcd(i,j,k)}=\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{\sum_{k=1}^C\gcd(\gcd(i,j),k)}$$
记
$$G(n,x)=\sum\limits_{i=1}^n\gcd(i,x)=\sum_{i=1}^x\sum_{d\mid i,d\mid x}\varphi(d)=\sum_{d\mid x}\varphi(d)\left\lfloor\frac{n}{d}\right\rfloor$$

回到原式得到

$$\begin{aligned}\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{G(C,\gcd(i,j))}&=\prod\limits_{d=1}^Ad^{G(C,d)\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}[\gcd(i,j)=1]}\\&=\prod_{d=1}^Ad^{G(C,d)\sum_{k=1}^{A/d}\mu(k)\lfloor\frac{A}{kd}\rfloor\lfloor\frac{B}{kd}\rfloor}\\&=\prod_{T=1}^A\left(\prod_{d\mid T}d^{G(C,d)\mu(T/d)}\right)^{\lfloor\frac{A}{T}\rfloor\lfloor\frac{B}{T}\rfloor}\end{aligned}$$

如果能预处理中间那一坨的话这题就做完了，但是很遗憾不能预处理...

我们尝试退一步并且把$G$里面那个枚举因子拽到外面

$$\begin{aligned}\prod_{d=1}^Ad^{\sum_{e\mid d}\varphi(e)\lfloor\frac{C}{e}\rfloor\sum_{k=1}^{A/d}\mu(k)\lfloor\frac{A}{kd}\rfloor\lfloor\frac{B}{kd}\rfloor}&=\prod_{e=1}^A\prod_{d=1}^{A/e}(de)^{\varphi(e)\lfloor\frac{C}{e}\rfloor\sum_{k=1}^{A/de}\mu(k)\lfloor\frac{A}{kde}\rfloor\lfloor\frac{B}{kde}\rfloor}\end{aligned}$$

分离$d,e$并分别处理

对$d$有
$$\prod_{e=1}^A\prod_{d=1}^{A/e}d^{\varphi(e)\lfloor\frac{C}{e}\rfloor\sum_{k=1}^{A/de}\mu(k)\lfloor\frac{A}{kde}\rfloor\lfloor\frac{B}{kde}\rfloor}=\prod_{e=1}^A\left(\prod_{T=1}^{A/e}\left(\prod_{d\mid T}d^{\mu(T/d)}\right)^{\lfloor\frac{A}{Te}\rfloor\lfloor\frac{B}{Te}\rfloor}\right)^{\varphi(e)\lfloor\frac{C}{e}\rfloor}$$

我们发现这个东西的内部就是type=0的时候的东西.如果我们直接整除分块算的话复杂度是

$$\sum_{i=1}^{\sqrt{n}}\sqrt{i}\log i+\sum_{i=1}^{\sqrt{n}}\sqrt{\frac{n}{i}}\log\frac{n}{i}=O(n^{\frac{3}{4}}\log n)$$

当然这样太浪费了，根据type=0的情况我们知道这就是$F(n,m)=\prod_{i=1}^n\prod_{j=1}^m\gcd(i,j)$，于是我们可以预处理出$n,m\leq N^{\frac{2}{3}}$的所有$F(n,m)$，这样复杂度就只剩下

$$\sum\limits_{i=1}^{n^\frac{1}{3}}\sqrt{\frac{n}{i}}\log\frac{n}{i}=O(n^{\frac{2}{3}}\log n)$$

实际上可以直接处理到一个定值，比如我选的是3000.处理的时候记得不要带$log$.

剩下的$e$就好办了

$$\prod_{e=1}^A\prod_{d=1}^{A/e}e^{\varphi(e)\lfloor\frac{C}{e}\rfloor\sum_{k=1}^{A/de}\mu(k)\lfloor\frac{A}{kde}\rfloor\lfloor\frac{B}{kde}\rfloor}=\prod_{e=1}^Ae^{\varphi(e)\lfloor\frac{C}{e}\rfloor\sum_{T=1}^{A/e}\lfloor\frac{A}{Te}\rfloor\lfloor\frac{B}{Te}\rfloor\sum_{k\mid T}\mu(k)}=\prod_{e=1}^Ae^{\varphi(e)\lfloor\frac{A}{e}\rfloor\lfloor\frac{B}{e}\rfloor\lfloor\frac{C}{e}\rfloor}$$

直接$O(\sqrt{n}\log n)$算就好了

于是我们就在$O(n^{\frac{4}{3}}+Tn^{\frac{2}{3}}\log n)$的时间内解决了这道题

下面是卡了一部分常的代码(实在不想卡了)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e6;
struct Q{int a,b,c;}q[N];
int A,B,C,pf[N],pg[N],dphi[N],fac[N],fi[N],g[N],gi[N],f[N],mu[N],phi[N],pphi[N],iphi[N],sphi[N],smu[N],inv[N],T,mod,p[N],prime[N],cnt,s1,s2,s3,ffac[N],gd[3005][3005],sgd[3005][3005],sgi[3005][3005];
int qpower(int a,int b)
{
    if(a==1)return 1;int ans=1;if(b<0)b+=mod-1;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
    return ans;
}
void make(int n)
{
    inv[1]=fac[1]=g[1]=gi[1]=gi[0]=fi[0]=pphi[0]=iphi[0]=mu[1]=phi[1]=ffac[1]=pf[1]=pg[1]=1;
    for(int i=2;i<=n;i++)
    {
        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
        fac[i]=1ll*fac[i-1]*i%mod,ffac[i]=1ll*ffac[i-1]*qpower(i,i)%mod;
        if(!p[i])prime[++cnt]=i,mu[i]=-1,phi[i]=i-1;
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
        {
            int x=i*prime[j];p[x]=1;
            if(i%prime[j])mu[x]=-mu[i],phi[x]=phi[i]*(prime[j]-1);
            else{mu[x]=0,phi[x]=phi[i]*prime[j];break;}
        }
    }
    for(int i=1;i<=n;i++)
        f[i]=i,fi[i]=inv[i],sphi[i]=(sphi[i-1]+phi[i])%(mod-1),smu[i]=(smu[i-1]+mu[i]),
        dphi[i]=qpower(i,phi[i]),pphi[i]=1ll*pphi[i-1]*dphi[i]%mod,iphi[i]=1ll*iphi[i-1]*qpower(inv[i],phi[i])%mod;
    for(int i=1;i<=cnt;i++)
        for(int t=n/prime[i],j=t*prime[i];t;j-=prime[i],t--)
            f[j]=1ll*f[j]*fi[t]%mod,
            fi[j]=1ll*fi[j]*f[t]%mod;
    for(int i=2;i<=n;i++)
        pg[i]=qpower(f[i],1ll*i*i%(mod-1)),g[i]=1ll*g[i-1]*pg[i]%mod,gi[i]=1ll*gi[i-1]*qpower(pg[i],mod-2)%mod,
        pf[i]=f[i],f[i]=1ll*f[i]*f[i-1]%mod,fi[i]=1ll*fi[i]*fi[i-1]%mod;
    int lim=min(n,3000);
    for(int i=0;i<=lim;i++)gd[0][i]=gd[i][0]=i,sgd[i][0]=sgd[0][i]=sgi[0][i]=sgi[i][0]=1;
    for(int i=1;i<=lim;i++)
    {
        for(int j=1;j<i;j++)
        {
            gd[i][j]=j<i-j?gd[i-j][j]:gd[j][i-j];
            sgd[i][j]=1ll*sgd[i-1][j]*sgd[i][j-1]%mod*sgi[i-1][j-1]%mod*gd[i][j]%mod;
            sgi[i][j]=1ll*sgi[i-1][j]*sgi[i][j-1]%mod*sgd[i-1][j-1]%mod*inv[gd[i][j]]%mod;
        }
        gd[i][i]=i;
        sgd[i][i]=1ll*sgd[i][i-1]*sgd[i][i-1]%mod*sgi[i-1][i-1]%mod*i%mod;
        sgi[i][i]=1ll*sgi[i][i-1]*sgi[i][i-1]%mod*sgd[i-1][i-1]%mod*inv[i]%mod;
    }
}
int S(int n){return 1ll*n*(n+1)/2%(mod-1);}
void calc1(int A,int B,int C)
{
    s1=1ll*s1*qpower(fac[A],1ll*B*C%(mod-1))%mod;
    s2=1ll*s2*qpower(ffac[A],1ll*S(B)*S(C)%(mod-1))%mod;
    int n=min(A,min(B,C));
    for(int i=1,lt;i<=n;i=lt+1)
    {
        lt=min(A/(A/i),min(B/(B/i),C/(C/i)));int t=1ll*(B/i)*(C/i)%(mod-1);
        s3=1ll*s3*qpower(1ll*pphi[lt]*iphi[i-1]%mod,1ll*(A/i)*t%(mod-1))%mod*qpower(fac[A/i],(1ll*t*(sphi[lt]-sphi[i-1])%(mod-1)+mod-1)%(mod-1))%mod;
    }
}
int S(int n,int m)
{
    if(n>m)swap(n,m);if(n<=3000&&m<=3000)return sgd[m][n];int s=1,i;
    for(i=1;i*i<=n;i++)
        s=1ll*s*qpower(pf[i],1ll*(n/i)*(m/i)%(mod-1))%mod;
    for(int lt;i<=n;i=lt+1)
    {
        lt=min(n/(n/i),m/(m/i));
        s=1ll*s*qpower(1ll*f[lt]*fi[i-1]%mod,1ll*(n/i)*(m/i)%(mod-1))%mod;
    }
    return s;
}
int Inv(int x){return qpower(x,mod-2);}
void calc2(int A,int B,int C)
{
    int n=min(A,B);int t1=1,t2=1,t3=1,lstans=1,lta=0,ltb=0,i,ta,tb,tc;
    for(i=1;i*i<=n;i++)
    {
        ta=A/i,tb=B/i;
        t1=1ll*t1*qpower(pf[i],1ll*ta*tb%(mod-1))%mod;
        t2=1ll*t2*qpower(pg[i],1ll*S(ta)*S(tb)%(mod-1))%mod;
    }
    for(int lt;i<=n;i=lt+1)
    {
        ta=A/i,tb=B/i;lt=min(A/ta,B/tb);
        t1=1ll*t1*qpower(1ll*f[lt]*fi[i-1]%mod,1ll*ta*tb%(mod-1))%mod;
        t2=1ll*t2*qpower(1ll*g[lt]*gi[i-1]%mod,1ll*S(ta)*S(tb)%(mod-1))%mod;
    }
    s1=1ll*s1*qpower(t1,mod-1-C)%mod;
    s2=1ll*s2*qpower(t2,mod-1-S(C))%mod;
    n=min(min(A,B),C);
    for(i=1;i*i<=n;i++)
    {
        t3=1ll*t3*qpower(lstans=S(A/i,B/i),1ll*(C/i)*phi[i]%(mod-1))%mod;
        t3=1ll*t3*qpower(dphi[i],1ll*(A/i)*(B/i)%(mod-1)*(C/i)%(mod-1))%mod;
    }
    for(int lt;i<=n;i=lt+1)
    {
        ta=A/i,tb=B/i,tc=C/i;lt=min(A/ta,min(B/tb,C/tc));
        if(lta==ta&&ltb==tb)t3=1ll*t3*qpower(lstans,1ll*tc*(sphi[lt]-sphi[i-1])%(mod-1))%mod;
        else
        {
            int t=S(ta,tb);lta=ta,ltb=tb;
            t3=1ll*t3*qpower(t,1ll*tc*(sphi[lt]-sphi[i-1])%(mod-1))%mod;
            lstans=t;
        }
//        t3=1ll*t3*qpower(S(ta,tb),(1ll*tc*(sphi[lt]-sphi[i-1])%(mod-1)+mod-1)%(mod-1))%mod;
        t3=1ll*t3*qpower(1ll*pphi[lt]*iphi[i-1]%mod,1ll*ta*tb%(mod-1)*tc%(mod-1))%mod;
    }
    s3=1ll*s3*qpower(t3,mod-2)%mod;
}
int main()
{
    scanf("%d%d",&T,&mod);int mx=0;
    for(int i=1;i<=T;i++)scanf("%d%d%d",&q[i].a,&q[i].b,&q[i].c),mx=max(mx,max(max(q[i].a,q[i].b),q[i].c));
    make(mx);
    for(int i=1;i<=T;i++)
    {
        A=q[i].a,B=q[i].b,C=q[i].c;s1=s2=s3=1;
        calc1(A,B,C);calc1(B,A,C);
        calc2(A,B,C),calc2(A,C,B);
        printf("%d %d %d\n",s1,s2,s3);
    }
}
```

---

## 作者：asuldb (赞：20)

[题目](https://www.luogu.org/problem/P5518)

一个很暴力的辣鸡做法

考虑到两个数的$\gcd$是所有质数次幂取$\min$，两个数的$\rm lcm$是所有质数次幂取$\max$，于是最后的答案一定是$\prod p_i^{c_i}$，而且这里最大的质数不会超过$n$，于是我们考虑算出每一个质数的次幂是多少

于是我们成功的将$\prod$转换成了$\sum$，指数上得对$\rm mod-1$取模

对于$\rm type=0$，我们枚举一个质数$p$，计算它的次幂

即为

$$\sum_{i=0}\sum_{j=0}\sum_{k=0}\sum_{t_1=1}^{\left \lfloor \frac{A}{p^i} \right \rfloor}\sum_{t_2=1}^{\left \lfloor \frac{B}{p^j} \right \rfloor}\sum_{t_3=1}^{\left \lfloor \frac{C}{p^k} \right \rfloor}\max(i,j)-\min(i,k)[t_1\perp p][t_2\perp p][t_3\perp p]$$

这个很显然啊，就是我们枚举当前这个质数的最大次幂，之后枚举这个拥有这个最大次幂的数，即为$p^i\times t_1$，但是如果$t_1$和$p$不互质，那么$i$就不是$p^i\times t$的最大次幂，于是还必须得保证$t_1\perp p$

我们改变一下求和顺序即为

$$\sum_{i=0}\sum_{j=0}\sum_{k=0}\max(i,j)-\min(i,k)\sum_{t_1=1}^{\left \lfloor \frac{A}{p^i} \right \rfloor}[t_1\perp p]\sum_{t_2=1}^{\left \lfloor \frac{B}{p^j} \right \rfloor}[t_2\perp p]\sum_{t_3=1}^{\left \lfloor \frac{C}{p^k} \right \rfloor}[t_3\perp p]$$

又发现求$\max(i,j)$和$\min(i,k)$是相当独立的，于是我们可以强行拆成

$$C\times \sum_{i=0}\sum_{j=0}\max(i,j)\sum_{t_1=1}^{\left \lfloor \frac{A}{p^i} \right \rfloor}[t_1\perp p]\sum_{t_2=1}^{\left \lfloor \frac{B}{p^j} \right \rfloor}[t_2\perp p]$$

减去

$$B\times \sum_{i=0}\sum_{k=0}\min(i,k)\sum_{t_1=1}^{\left \lfloor \frac{A}{p^i} \right \rfloor}[t_1\perp p]\sum_{t_3=1}^{\left \lfloor \frac{C}{p^k} \right \rfloor}[t_3\perp p]$$

现在思考一下这个$\sum_{t_1=1}^{\left \lfloor \frac{A}{p^i} \right \rfloor}[t_1\perp p]$到底怎么求，和一个质数互质只要不是这个质数的倍数就行了，于是我们简单的减去$1$到$\left \lfloor \frac{A}{p^i} \right \rfloor$里$p$的倍数即可，也就是$\left \lfloor \frac{A}{p^i} \right \rfloor-\left \lfloor \frac{A}{p^{i+1}} \right \rfloor$


也就是我们现在只需要求

$$B\times \sum_{i=0}\sum_{j=0}\max(i,j)(\left \lfloor \frac{A}{p^i} \right \rfloor-\left \lfloor \frac{A}{p^{i+1}} \right \rfloor)(\left \lfloor \frac{B}{p^j} \right \rfloor-\left \lfloor \frac{B}{p^{j+1}} \right \rfloor)$$

我们可以直接$O(\log_p^2 A)$来计算这个柿子，但是我们处理一下$\left \lfloor \frac{A}{p^i} \right \rfloor-\left \lfloor \frac{A}{p^{i+1}} \right \rfloor$的前缀和强行讨论一下也可以做到$O(\log_p A)$

一到$n$内的质数大概有$\frac{n}{\ln n}$个，每一个质数的计算需要$O(\log_p n)$的复杂度，于是做一遍复杂度大概就是$O(n)$的

对于$\rm type=1$，柿子变成了

$$\sum_{i=0}\sum_{j=0}\sum_{k=0}\sum_{t_1=1}^{\left \lfloor \frac{A}{p^i} \right \rfloor}\sum_{t_2=1}^{\left \lfloor \frac{B}{p^j} \right \rfloor}\sum_{t_3=1}^{\left \lfloor \frac{C}{p^k} \right \rfloor}(\max(i,j)-\min(i,k))\times t_1\times t_2\times t_3\times p^{i+j+k}[t_1\perp p][t_2\perp p][t_3\perp p]$$

强行一搞也能变成上面的形式，同样可以在$O(n)$时间求出来

对于$\rm type=2$，我们考虑枚举上面的$\gcd$

设$f(A,B,C)$为第一问的答案，也就是三个上标分别取到$A,B,C$时的贡献

套路枚举$\gcd$为$d$即$d$的倍数时的贡献

$$\sum_{d=1}^{min(A,B,C)}d\sum_{d|i}\mu(\frac{i}{d})f(\left \lfloor \frac{A}{d} \right \rfloor,\left \lfloor  \frac{B}{d}\right \rfloor,\left \lfloor \frac{C}{d} \right \rfloor)$$

就是$\left \lfloor \frac{A}{d} \right \rfloor,\left \lfloor  \frac{B}{d}\right \rfloor,\left \lfloor \frac{C}{d} \right \rfloor$内的数乘上$d$分别不会超过$A,B,C$，且这些数的$\gcd$都是$d$或$d$的倍数

再套路交换一下求和顺序

$$\sum_{i=1}^{\min(A,B,C)}f(\left \lfloor \frac{A}{i} \right \rfloor,\left \lfloor  \frac{B}{i}\right \rfloor,\left \lfloor \frac{C}{i} \right \rfloor)\sum_{d|i}\mu(\frac{i}{d})d=\sum_{i=1}^{\min(A,B,C)}f(\left \lfloor \frac{A}{i} \right \rfloor,\left \lfloor  \frac{B}{i}\right \rfloor,\left \lfloor \frac{C}{i} \right \rfloor)\varphi(i)$$

于是直接大力整除分块，复杂度应该不会超过$O(n\ln n)$

吧。

请大力卡常

代码

```cpp
#include<bits/stdc++.h>
#define re register
#define LL long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#pragma GCC optimize(3)
#pragma GCC optimize("-fcse-skip-blocks")
const int maxn=1e5+5;
int mod,P,T,R;
int is[maxn],p[maxn>>1],pre[maxn],phi[maxn],pw[maxn>>1];
int r[2],tax[2][20],pr[2][20];
inline int ksm(int a,int b) {
	int S=1;
	for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) S=1ll*S*a%mod;
	return S;
}
inline int qm(int x) {return x>=P?x-P:x;}
inline int dqm(int x) {return x+=x>>31&P;}
inline int calc(int n,int p) {
	return dqm(pre[n]-1ll*pre[n/p]*p%P);
}
inline int out(int A) {
	int ans=1;
	for(re int i=1;i<=p[0]&&p[i]<=A;i++) 
		ans=1ll*ans*ksm(p[i],pw[i])%mod;
	return ans;
}
inline void clear(int A) {
	for(re int i=1;i<=p[0]&&p[i]<=A;i++) pw[i]=0;
}
inline void Solve(int A,int B,int C,int v) {
	int ans1=1;
	for(re int t=1;t<=p[0];t++) {
		if(p[t]>A&&p[t]>B&&p[t]>C) break;
		int now=0,tot=0;
		for(re int i=0,aa=A;aa;i++,aa/=p[t]) pr[0][i]=tax[0][i]=aa-aa/p[t],r[0]=i;
		for(re int j=0,bb=B;bb;j++,bb/=p[t]) pr[1][j]=tax[1][j]=bb-bb/p[t],r[1]=j;
		R=max(r[0],r[1]);
		for(re int i=1;i<=R;i++) pr[0][i]=qm(pr[0][i]+pr[0][i-1]);
		for(re int j=1;j<=R;j++) pr[1][j]=qm(pr[1][j]+pr[1][j-1]);
		for(re int i=0;i<=r[0];i++) 
			now=qm(now+1ll*tax[0][i]*pr[1][i]*i%P);
		for(re int j=1;j<=r[1];j++) 
			now=qm(now+1ll*tax[1][j]*pr[0][j-1]*j%P);
		for(re int i=1;i<=R;i++) pr[1][i]=0;
		for(re int i=r[0]+1;i<=R;i++) pr[0][i]=0;	
		now=1ll*now*C%P;
		for(re int k=0,cc=C;cc;k++,cc/=p[t]) pr[1][k]=tax[1][k]=cc-cc/p[t],r[1]=k;
		R=max(r[0],r[1]);
		for(re int i=r[0]+1;i<=R;i++) pr[0][i]=qm(pr[0][i-1]+pr[0][i]);
		for(re int k=1;k<=R;k++) pr[1][k]=qm(pr[1][k]+pr[1][k-1]);
		for(re int i=1;i<=r[0];i++) 
			tot=qm(tot+1ll*i*tax[0][i]*dqm(pr[1][r[1]]-pr[1][i-1])%P);
		for(re int k=1;k<=r[1];k++)
			tot=qm(tot+1ll*k*tax[1][k]*dqm(pr[0][r[0]]-pr[0][k])%P);
		for(re int i=0;i<=R;i++) pr[1][i]=pr[0][i]=0;
		now=dqm(now-1ll*B*tot%P);
		pw[t]=qm(pw[t]+1ll*now*v%P);
	}
}
inline int Calc(int n,int m,int h) {
	int U=min(min(n,m),h);
	for(re int l=2,r;l<=U;l=r+1) {
		r=min(n/(n/l),m/(m/l));
		r=min(r,h/(h/l));
		Solve(n/l,m/l,h/l,dqm(phi[r]-phi[l-1]));
	}
	return out(max(max(n,m),h));
}
int A,B,C;
int main() {
	scanf("%d%d",&T,&mod);P=mod-1;phi[1]=1;
	for(re int i=2;i<maxn;i++) {
		if(!is[i]) p[++p[0]]=i,phi[i]=i-1;
		for(re int j=1;j<=p[0]&&p[j]*i<maxn;j++) {
			is[p[j]*i]=1;if(i%p[j]==0) {
				phi[p[j]*i]=phi[i]*p[j];break;
			}
			phi[p[j]*i]=phi[i]*phi[p[j]];
		}
	}
	for(re int i=1;i<maxn;i++) 
		pre[i]=qm(pre[i-1]+i),phi[i]=qm(phi[i-1]+phi[i]);
	while(T--) {
		scanf("%d%d%d",&A,&B,&C);
		int ans2=1;
		for(re int t=1;t<=p[0];t++) {
			if(p[t]>A&&p[t]>B&&p[t]>C) break;
			int now=0,tot=0;
			for(re LL i=0,a=1;a<=A;i++,a*=p[t])
				for(re LL j=0,b=1;b<=B;j++,b*=p[t]) {
					int v=1ll*max(i,j)*a*b%P;
					tot=qm(tot+1ll*v*calc(A/a,p[t])*calc(B/b,p[t])%P*pre[C]%P);
			}
			for(re LL i=1,a=p[t];a<=A;i++,a*=p[t])
				for(re LL k=1,c=p[t];c<=C;k++,c*=p[t]) {
					int v=1ll*min(i,k)*a*c%P;
				    now=qm(now+1ll*v*calc(A/a,p[t])*calc(C/c,p[t])%P*pre[B]%P);
			}
			ans2=1ll*ans2*ksm(p[t],dqm(tot-now))%mod;
		}
		Solve(A,B,C,1);printf("%d ",out(max(max(A,B),C)));
		printf("%d %d\n",ans2,Calc(A,B,C));clear(max(max(A,B),C));
	}
}
```


---

## 作者：灵乌路空 (赞：17)

更好的阅读体验：[我的 Blog](https://www.cnblogs.com/luckyblock/p/13975070.html)。  
扯一句，题面里将露娜萨（Lunasa）误写成了 Lusana，不人气姐妹连名字都不配拥有（  

## 简述

原题面：[Luogu](https://www.luogu.com.cn/problem/P5518)

>给定参数 $p$，有 $T$ 组数据，每次给定参数 $A,B,C$，求：  
>$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}\pmod p$$  
>其中 $f(type)$ 的取值如下：  
>$$f(type) = \begin{cases}
   1 &type = 0\\
   i\times j\times k &type = 1\\
   \gcd(i,j,k) &type = 2
\end{cases}$$  
>$1\le A,B,C\le 10^5$，$10^7\le p\le 1.05\times 10^9$，$p\in \mathbb{P}$，$T=70$。  
>2.5S，128MB。

## 分析

### 原式

先化下原式，原式等于：  
$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\dfrac{i\times j }{\gcd(i,j)\times \gcd(i,k)}\right)^{f(type)}$$ 

发现每一项仅与两个变量有关，设：  
$$\begin{aligned}
  f_1(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i^{f(type)}\\
  f_2(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)^{f(type)}
\end{aligned}$$
发现 $\prod$ 可以随意交换，则原式等价于：  

$$\dfrac{f_1(a,b,c)\times f_1(b,a,c)}{f_2(a,b,c)\times f_2(a,c,b)}$$

考虑在 $type$ 取值不同时，如何快速求得 $f_1$ 与 $f_2$。  
一共有 $6$ 个需要推导的式子，不妨就叫它们 $1\sim 6$ 面了（

---

### type = 0

$$\begin{aligned}
  f_1(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i\\
  f_2(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)
\end{aligned}$$

对于 1 面，显然有：  

$$\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i = \left(\prod_{i=1}^{a}i\right)^{b\times c}$$  

预处理阶乘 + 快速幂即可，单次计算时间复杂度 $O(\log n)$。  

---

再考虑 2 面，套路地枚举 $\gcd$，显然有：  

$$\large \begin{aligned}
  &\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)\\
  =&\left(\prod_{i=1}^{a}\prod_{j=1}^{b}\gcd(i,j)\right)^c\\
  =& \left(\prod_{d=1} d^{\left(\sum\limits_{i=1}^{a}\sum\limits_{j=1}^{b}[\gcd(i,j) = d]\right)}\right)^c
\end{aligned}$$

指数是个套路，可以看这里：[P3455 [POI2007]ZAP-Queries](https://www.luogu.com.cn/problem/P3455)。于是有：  

$$\begin{aligned}
  &\sum\limits_{i=1}^{a}\sum\limits_{j=1}^{b}[\gcd(i,j) = d]\\
  =& \sum\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}[\gcd(i,j) = 1]\\
  =& \sum\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}\sum_{k\mid \gcd(i,j)}\mu (k)\\
  =& \sum_{k=1}\mu(k)\left\lfloor\dfrac{a}{kd}\right\rfloor\left\lfloor\dfrac{b}{kd}\right\rfloor
\end{aligned}$$  

代回原式，略做处理，则原式等于：  

$$\large \begin{aligned}
  &\left(\prod_{d=1} d^{\left(\sum\limits_{k=1}\mu(k)\left\lfloor\frac{a}{kd}\right\rfloor\left\lfloor\frac{b}{kd}\right\rfloor\right)}\right)^c\\
  =& \left(\prod_{d=1} \left(d^{\sum\limits_{k=1}\mu(k)}\right)^{\left\lfloor\frac{a}{kd}\right\rfloor\left\lfloor\frac{b}{kd}\right\rfloor}\right)^c\\
  =& \prod_{d=1} \left(\prod_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}d^{\left(\mu(k)\left\lfloor\frac{a}{kd}\right\rfloor\left\lfloor\frac{b}{kd}\right\rfloor\right)}\right)^c
\end{aligned}$$

像[「SDOI2017」数字表格](https://www.cnblogs.com/luckyblock/p/13966454.html) 一样，考虑枚举 $t=kd$ 和 $d$，则原式等于：

$$\large \prod_{t=1}^{n}\left(\left(\prod_{d|t} d^{\mu{\left(\frac{t}{d}\right)}}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}\right)^c$$

设：  
$$\large g_0(t) = \prod_{d|t}d^{\mu\left(\frac{t}{d}\right)}$$

线性筛预处理 $\mu$ 后，$g_0(t)$ 可以用埃氏筛预处理，时间复杂度 $O(n\log n)$。再代回原式，原式等于：

$$\large \prod_{t=1}^{a}\left(g_0(t)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}\right)^c$$

预处理 $g_0(t)$ 的前缀积和前缀积的逆元，复杂度 $O(n\log n)$。  
数论分块 + 快速幂计算即可，单次时间复杂度 $O(\sqrt n\log n)$。

---

### type = 1

$$\begin{aligned}
  f_1(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i^{i\times j\times k}\\
  f_2(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)^{i\times j\times k}
\end{aligned}$$

考虑 3 面，把 $\prod k$ 扔到指数位置，有：  

$$\large \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i^{i\times j\times k} = \prod_{i=1}^{a}\prod_{j=1}^{b}i^{\left(i\times j\times \sum\limits_{k = 1}^{c} k\right)}$$
  
再把 $\prod j$ 也扔到指数位置，引入 $\operatorname{sum}(n) = \sum_{i=1}^{n} i = \frac{n(n+1)}{2}$，原式等于：  

$$\left(\prod_{i=1}^{a}i^i\right)^{\operatorname{sum}(b)\times \operatorname{sum}(c)}$$

预处理 $i^i$ 的前缀积，复杂度 $O(n\log n)$。  
指数可以 $O(1)$ 算出，然后快速幂，单次时间复杂度 $O(\log n)$。  

根据费马小定理，指数需要对 $p - 1$ 取模。注意 $p-1$ 不是质数，计算 $\operatorname{sum}$ 时不能用逆元，但乘不爆 `LL`，直接算就行。

---

再考虑 4 面，发现 $k$ 与 $\gcd$ 无关，则同样把 $\prod k$ 扔到指数位置，则有：  

$$\large \begin{aligned}
  &\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)^{i\times j\times k}\\
  =& \left(\prod_{i=1}^a\prod_{j=1}^b\gcd(i,j)^{i\times j}\right)^{\operatorname{sum}(c)}
\end{aligned}$$

套路地枚举 $\gcd$，原式等于：  

$$\large \left(\prod_{d=1}d^{\left(\sum\limits_{i=1}^a \sum\limits_{j=1}^b i\times j[\gcd(i,j)=d]\right)}\right)^{\operatorname{sum}(c)}$$

大力化简指数，有：  

$$\large \begin{aligned}
  &\sum\limits_{i=1}^a \sum\limits_{j=1}^b i\times j[\gcd(i,j)=d]\\
  =& d^2 \sum\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor} \sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor} i\times j[\gcd(i,j)=1\\
  =& d^2 \sum\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor} i \sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor} j\sum\limits_{t|\gcd(i,j)}\mu(t)\\
  =& d^2 \sum\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor} i \sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor} j\sum\limits_{k|\gcd(i,j)}\mu(k)\\
  =& d^2 \sum\limits_{k=1}\mu(k)\sum\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor} i[k|i] \sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor} j[k|j]\\
  =& d^2 \sum\limits_{k=1}k^2\mu(k)\sum\limits_{i=1}^{\left\lfloor\frac{a}{kd}\right\rfloor} i\sum\limits_{j=1}^{\left\lfloor\frac{b}{kd}\right\rfloor} j\\
  =& d^2\sum\limits_{k=1}k^2\mu(k)\operatorname{sum}{\left(\left\lfloor\frac{a}{kd}\right\rfloor\right)} \operatorname{sum}{\left(\left\lfloor\frac{b}{kd}\right\rfloor\right)}\\
\end{aligned}$$

指数化不动了，代回原式，原式等于：  

$$\large \left(\prod_{d=1}d^{\left(d^2\sum\limits_{k=1}k^2\mu(k)\operatorname{sum}{\left(\left\lfloor\frac{a}{kd}\right\rfloor\right)} \operatorname{sum}{\left(\left\lfloor\frac{b}{kd}\right\rfloor\right)}\right)}\right)^{\operatorname{sum}(c)}$$

同 2 面的情况，先展开一下，再枚举 $t=kd$ 和 $d$，原式等于：  

$$\large \begin{aligned}
  &\left(\prod_{d=1}\left(\prod_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}d^{\left(d^2 k^2\mu(k)\right)}\right)^{\left(\operatorname{sum}{\left(\left\lfloor\frac{a}{kd}\right\rfloor\right)} \operatorname{sum}{\left(\left\lfloor\frac{b}{kd}\right\rfloor\right)}\right)}\right)^{\operatorname{sum}(c)}\\
  =& \prod_{t=1}\left(\left(\prod_{d|t}d^{\left(d^2\left(\frac{t}{d}\right)^2\mu\left(\frac{t}{d}\right)\right)}\right)^{\operatorname{sum}{\left(\left\lfloor\frac{a}{t}\right\rfloor\right)} \operatorname{sum}{\left(\left\lfloor\frac{b}{t}\right\rfloor\right)}}\right)^{\operatorname{sum}(c)}\\
  =& \prod_{t=1}\left(\left(\prod_{d|t}d^{\left(t^2\mu\left(\frac{t}{d}\right)\right)}\right)^{\operatorname{sum}{\left(\left\lfloor\frac{a}{t}\right\rfloor\right)} \operatorname{sum}{\left(\left\lfloor\frac{b}{t}\right\rfloor\right)}}\right)^{\operatorname{sum}(c)}
\end{aligned}$$

与二面相同，设：  

$$\large g_1(t) = \prod_{d|t}d^{\left(t^2\mu\left(\frac{t}{d}\right)\right)}$$

$g_1(t)$ 可以用埃氏筛套快速幂筛出，时间复杂度 $O(n\log^2 n)$。再代回原式，原式等于：  

$$\prod_{t=1}\left(g_1(t)^{\operatorname{sum}{\left(\left\lfloor\frac{a}{t}\right\rfloor\right)} \operatorname{sum}{\left(\left\lfloor\frac{b}{t}\right\rfloor\right)}}\right)^{\operatorname{sum}(c)}$$

同样预处理 $g_1(t)$ 的前缀积及其逆元，时间复杂度 $O(n\log n)$。  
整除分块 + 快速幂即可，单次时间复杂度 $O(\sqrt n\log n)$。  

注意指数的取模。

---

### type = 2

$$\begin{aligned}
  f_1(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i^{\gcd(i,j,k)}\\
  f_2(a,b,c) &= \prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)^{\gcd(i,j,k)}
\end{aligned}$$

考虑 5 面，手段同上，大力反演化简一波，再调换枚举对象，则有：  

$$\large \begin{aligned}
  &\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} i^{\gcd(i,j,k)}\\
  =&\prod_{d=1}\prod\limits_{i=1}^{a}i^{\left(\sum\limits_{j=1}^{b}\sum\limits_{k=1}^{c}[\gcd(i,j,k)=d]\right)}\\
  =& \prod_{d=1}\prod\limits_{i=1}^{a}i^{\left(\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac{c}{d}\right\rfloor}[\gcd(\frac{i}{d},j,k)=1]\right)}\\
  =& \prod_{d=1}\prod\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor}(id)^{\left(d\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac{c}{d}\right\rfloor}[\gcd(i,j,k)=1]\right)}\\
  =& \prod_{d=1}\prod\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor}(id)^{\left(d\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac{c}{d}\right\rfloor}\sum\limits_{x|\gcd(i,j,k)}{\mu(x)}\right)}\\
  =& \prod_{d=1}\prod\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor}(id)^{\left(d\sum\limits_{x=1}\mu(x)[x|i]\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}[x|j]\sum\limits_{k=1}^{\left\lfloor\frac{c}{d}\right\rfloor}[x|k]\right)}\\
  =& \prod_{d=1}\prod_{x=1}\prod\limits_{i=1}^{\left\lfloor\frac{a}{d}\right\rfloor}(id)^{\left(d\times \mu(x)[x|i]\sum\limits_{j=1}^{\left\lfloor\frac{b}{d}\right\rfloor}[x|j]\sum\limits_{k=1}^{\left\lfloor\frac{c}{d}\right\rfloor}[x|k]\right)}\\
  =& \prod_{d=1}\prod_{x=1}\prod\limits_{i=1}^{\left\lfloor\frac{a}{xd}\right\rfloor}(ixd)^{\left(d\times \mu(x){\left\lfloor\frac{b}{xd}\right\rfloor}{\left\lfloor\frac{c}{xd}\right\rfloor}\right)}\\
  =& \prod_{t = 1}\prod_{d|T}\prod_{i=1}^{\left\lfloor\frac{a}{t}\right\rfloor}(it)^{\left(d\times \mu\left(\frac{t}{d}\right){\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}\right)}\\
  =& \prod_{t = 1}\prod_{d|T}\left(t^{\left\lfloor\frac{a}{t}\right\rfloor}\prod_{i=1}^{\left\lfloor\frac{a}{t}\right\rfloor}i\right)^{d\times \mu\left(\frac{t}{d}\right){\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}}\\
\end{aligned}$$

引入 $\operatorname{fac}(n) = \prod_{i=1}^{n} i$，再根据枚举对象调整一下指数，原式等于：  

$$\large \begin{aligned}
  &\prod_{t = 1}\prod_{d|t}\left(t^{\left\lfloor\frac{a}{t}\right\rfloor}\times \operatorname{fac}\left(\left\lfloor\frac{a}{t}\right\rfloor\right)\right)^{\left(d\times \mu\left(\frac{t}{d}\right){\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}\right)}\\
  =& \prod_{t = 1}\left(\prod_{d|t}\left(t^{\left\lfloor\frac{a}{t}\right\rfloor}\times \operatorname{fac}\left(\left\lfloor\frac{a}{t}\right\rfloor\right)\right)^{d\times \mu\left(\frac{t}{d}\right)}\right)^{{\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}}\\
  =& \prod_{t = 1}\left(\left(t^{\left\lfloor\frac{a}{t}\right\rfloor}\times \operatorname{fac}\left(\left\lfloor\frac{a}{t}\right\rfloor\right)\right)^{\sum\limits_{d|t}d\times \mu\left(\frac{t}{d}\right)}\right)^{{\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}}
\end{aligned}$$

指数中出现了一个经典的狄利克雷卷积的形式，对其进行反演。  
将 $(\operatorname{Id}\ast \mu) (n)= \varphi (n)$ 代入原式，原式等于：  

$$\large \begin{aligned}
  &\prod_{t = 1}\left(t^{\left\lfloor\frac{a}{t}\right\rfloor}\times \operatorname{fac}\left(\left\lfloor\frac{a}{t}\right\rfloor\right)\right)^{\varphi(t){\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}}\\
  =& \prod_{t = 1}\left(t^{\varphi(t)\left\lfloor\frac{a}{t}\right\rfloor{\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}}\times \operatorname{fac}\left(\left\lfloor\frac{a}{t}\right\rfloor\right)^{\varphi(t){\left\lfloor\frac{b}{t}\right\rfloor}{\left\lfloor\frac{c}{t}\right\rfloor}}\right)
\end{aligned}$$

预处理 $t^{\varphi(t)}$ 的前缀积及逆元，阶乘的前缀积及阶乘逆元，$\pmod {p-1}$ 下的 $\varphi(t)$ 的前缀和（指数
），时间复杂度 $O(n\log n)$。  
同样整除分块 + 快速幂即可，单次时间复杂度 $O(\sqrt n\log n)$。

---

然后是最掉 sans 的 6 面。有 $\gcd(i,j,k) = \gcd(\gcd(i,j), k)$，考虑先枚举 $\gcd(i,j)$，然后套路化式子，则有：  

$$\large \begin{aligned}
  &\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} \gcd(i,j)^{\gcd(i,j,k)}\\
  =& \prod_{d=1}\prod_{i=1}^{a}\prod_{j=1}^{b}\prod_{k=1}^{c} [\gcd(i,j)=d] d^{\gcd(d,k)}\\
  =& \prod_{d=1} \left(d^{\left(\sum\limits_{i=1}^{a}\sum\limits_{j=1}^{b} [\gcd(i,j)=d]\right)}\right)^{\sum\limits_{k=1}^{c}\gcd(d,k)}
\end{aligned}$$

先考虑最外面的指数，这也是个套路，可以参考 [一个例子](https://www.cnblogs.com/luckyblock/p/12654760.html#%E4%BE%8B-1)。用 $\operatorname{Id} = \varphi \ast 1$ 反演，显然有：  

$$\large \begin{aligned}
  &\sum\limits_{k=1}^{c}\gcd(d,k)\\
  =& \sum\limits_{k=1}^{c}\sum_{x|\gcd(d,k)}\varphi(x)\\
  =& \sum_{x=1}\varphi(x)[x|d]\sum_{k=1}^{c}[x|k]\\
  =& \sum_{x|d}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor
\end{aligned}$$

再考虑里面的指数，发现这式子在 2 面已经推了一遍了，于是直接拿过来用，有：  

$$\sum\limits_{i=1}^{a}\sum\limits_{j=1}^{b}[\gcd(i,j) = d]=\sum_{y=1}\mu(y)\left\lfloor\dfrac{a}{yd}\right\rfloor\left\lfloor\dfrac{b}{yd}\right\rfloor$$  

将化简后的两个指数代入原式，原式等于：

$$\large \begin{aligned}
  &\prod_{d=1} \left(d^{\left(\sum\limits_{y=1}\mu(y)\left\lfloor\frac{a}{yd}\right\rfloor\left\lfloor\frac{b}{yd}\right\rfloor\right)}\right)^{\sum\limits_{x|d}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}\\
  =& \prod_{d=1} \left(\prod\limits_{y=1}d^{\left(\mu(y)\left\lfloor\frac{a}{yd}\right\rfloor\left\lfloor\frac{b}{yd}\right\rfloor\right)}\right)^{\sum\limits_{x|d}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}
\end{aligned}$$

与 2、4 面同样套路地，考虑枚举 $t=yd$ 和 $d$，再略作调整，原式等于：  

$$\large \begin{aligned}
  &\prod_{d=1} \left(\prod\limits_{y=1}d^{\left(\mu(y)\left\lfloor\frac{a}{yd}\right\rfloor\left\lfloor\frac{b}{yd}\right\rfloor\right)}\right)^{\sum\limits_{x|d}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}\\
  =& \prod_{t=1}\prod_{d|t} d^{\left(\mu\left(\frac{t}{d}\right)\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor\sum\limits_{x|d}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\\
  =& \prod_{t=1}\left(\prod_{d|t} d^{\left(\mu\left(\frac{t}{d}\right)\sum\limits_{x|d}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}\\
  =& \prod_{t=1}\left(\prod_{d|t} \prod_{x|d}d^{\left(\mu\left(\frac{t}{d}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}
\end{aligned}$$

发现要同时枚举 $d$ 和 $x$，化不动了。  
从题解里学到一个比较神的技巧，考虑把 $d$ 拆成 $x$ 和 $\frac{d}{x}$ 分别计算贡献再相乘，即分别计算下两式：  

$$\large \begin{aligned}
  &\prod_{t=1}\left(\prod_{d|t} \prod_{x|d}x^{\left(\mu\left(\frac{t}{d}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}\\  
  &\prod_{t=1}\left(\prod_{d|t} \prod_{x|d}{\left(\frac{d}{x}\right)}^{\left(\mu\left(\frac{t}{d}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}
\end{aligned}$$

---

先考虑 $x$ 的情况，首先把枚举 $x$ 调整到最外层。设 $\operatorname{lim}=\max(a,b,c)$，则原式等于：  

$$\large \begin{aligned}
  &\prod_{x=1} \prod_{t=1}^{\operatorname{lim}}[x|t]\left(\prod_{d|t} [x|d]{x}^{\left(\mu\left(\frac{t}{d}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}\\
  =& \prod_{x=1} \prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\left(\prod_{d|t} {x}^{\left(\mu\left(\frac{tx}{dx}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor}\\
  =& \prod_{x=1} \prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\prod_{d|t} {x}^{\left(\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor\mu\left(\frac{t}{d}\right)\right)}
\end{aligned}$$

把 $\prod {t}$ 挪到指数位置，原式等于：  

$$\large \begin{aligned}
  &\prod_{x=1}  {x}^{\left(\sum\limits_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\sum\limits_{d|t}\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor\mu\left(\frac{t}{d}\right)\right)}\\
  =& \prod_{x=1}  {x}^{\left(\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\sum\limits_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor\sum\limits_{d|t}\mu\left(\frac{t}{d}\right)\right)}
\end{aligned}$$

指数中又出现了一个经典的狄利克雷卷积的形式，对其进行反演。  
将 $(\mu \ast 1) (n)= \epsilon (n)=[n=1]$ 代入原式，原式等于： 

$$\large \begin{aligned}
  &\prod_{x=1}  {x}^{\left(\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\sum\limits_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor[t=1]\right)}\\
  =& \prod_{x=1}  {x}^{\left(\varphi(x)\left\lfloor\frac{a}{x}\right\rfloor\left\lfloor\frac{b}{x}\right\rfloor\left\lfloor\frac{c}{x}\right\rfloor\right)}
\end{aligned}$$

得到了一个非常优美的式子，而且发现这个式子是 5 面最终答案的一部分。同 5 面的做法，直接整除分块即可。

---

再考虑 $\frac{d}{x}$ 的情况，同上先把枚举 $x$ 放到最外层，并调整一下指数，则原式等于：  

$$\large \begin{aligned}
  &\prod_{x=1} \prod_{t=1}^{\operatorname{lim}}[x|t]\left(\prod_{d|t} [x|d]{\left(\frac{d}{x}\right)}^{\left(\mu\left(\frac{t}{d}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{t}\right\rfloor\left\lfloor\frac{b}{t}\right\rfloor}\\
  =& \prod_{x=1} \prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\left(\prod_{d|tx} [x|d]{\left(\frac{d}{x}\right)}^{\left(\mu\left(\frac{tx}{d}\right)\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor\right)}\right)^{\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor}\\
  =& \prod_{x=1} \left(\prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\left(\prod_{d|tx} [x|d]{\left(\frac{d}{x}\right)}^{\mu\left(\frac{tx}{d}\right)}\right)^{\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor}\right)^{\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}
\end{aligned}$$

考虑枚举 $dx$，替换原来的 $d$，注意一下这里的倍数关系。原式等于：  

$$\large \prod_{x=1} \left(\prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}\left(\prod_{d|t}d^{\mu\left(\frac{t}{d}\right)}\right)^{\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor}\right)^{\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}$$

发现最内层的式子 $\prod_{d|t}d^{\mu\left(\frac{t}{d}\right)}$，即为二面处理过的 $g_0(t)$。直接代入，原式等于：

$$\large \prod_{x=1} \left(\prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}g_0(t)^{\left\lfloor\frac{a}{tx}\right\rfloor\left\lfloor\frac{b}{tx}\right\rfloor}\right)^{\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}$$

一个小结论，证明可以看 [这里](https://www.cnblogs.com/luckyblock/p/12654760.html#%E5%BC%95%E7%90%861)：  

$$\forall a,b,c\in \mathbb{Z},\left\lfloor\dfrac{a}{bc}\right\rfloor = \left\lfloor{\dfrac{\left\lfloor\dfrac{a}{b}\right\rfloor}{c}}\right\rfloor$$

则原式等于：  

$$\large \prod_{x=1} \left(\prod_{t=1}^{\left\lfloor\frac{\operatorname{lim}}{x}\right\rfloor}g_0(t)^{\left\lfloor\frac{\left\lfloor\frac{a}{x}\right\rfloor}{t}\right\rfloor\left\lfloor\frac{\left\lfloor\frac{b}{x}\right\rfloor}{t}\right\rfloor}\right)^{\varphi(x)\left\lfloor\frac{c}{x}\right\rfloor}$$

于是可以先对外层整除分块，再对内层整除分块。

然后就做完了，哈哈哈。

## 实现

一些实现上的小技巧：

- 逆元能预处理就预处理。  
- 注意对指数取模，模数为 $p-1$。  

```cpp
//知识点：莫比乌斯反演 
/*
By:Luckyblock
用了比较清晰易懂的变量名，阅读体验应该会比较好。  
vsc 的自动补全真是太好啦！
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
using std::min;
using std::max;
#define LL long long
const int Lim = 1e5;
const int kN = 1e5 + 10;
//=============================================================
LL A, B, C, mod, ans;
int T, p_num, p[kN];
bool vis[kN];
LL mu[kN], phi[kN], fac[kN], g[2][kN];
LL sumphi[kN], prodt_phi[kN], prodi_i[kN], prodg[2][kN];
LL inv[kN], inv_fac[kN], inv_prodt_phi[kN], inv_prodg[2][kN];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) {
    w = (w << 3) + (w << 1) + (ch ^ '0');
  }
  return f * w;
}
void Chkmax(int &fir_, int sec_) {
  if (sec_ > fir_) fir_ = sec_;
}
void Chkmin(int &fir_, int sec_) {
  if (sec_ < fir_) fir_ = sec_;
}
LL QPow(LL x_, LL y_) {
  x_ %= mod;
  y_ %= mod - 1;
  LL ret = 1;
  for (; y_; y_ >>= 1ll) {
    if (y_ & 1) ret = ret * x_ % mod;
    x_ = x_ * x_ % mod;
  }
  return ret;
}
LL Inv(LL x_) {
  return QPow(x_, mod - 2);
}
LL Sum(LL n_) {
  return ((n_ * (n_ + 1ll)) / 2ll) % (mod - 1);
}
void Euler() {
  vis[1] = true, mu[1] = phi[1] = 1; //初值
  for (int i = 2; i <= Lim; ++ i) {
    if (! vis[i]) {
      p[++ p_num] = i;
      mu[i] = -1;
      phi[i] = i - 1;
    }
    for (int j = 1; j <= p_num && i * p[j] <= Lim; ++ j) {
      vis[i * p[j]] = true;
      if (i % p[j] == 0) {
        mu[i * p[j]] = 0;
        phi[i * p[j]] = phi[i] * p[j];
        break;
      }
      mu[i * p[j]] = -mu[i];
      phi[i * p[j]] = phi[i] * (p[j] - 1);
    }
  }
}
void Prepare() {
  Euler();
  inv[1] = fac[0] = prodt_phi[0] = prodi_i[0] = 1;
  for (int i = 1; i <= Lim; ++ i) {
    g[0][i] = g[1][i] = 1;
    fac[i] = 1ll * fac[i - 1] * i % mod;
    sumphi[i] = (sumphi[i - 1] + phi[i]) % (mod - 1);
    prodi_i[i] = prodi_i[i - 1] * QPow(i, i) % mod;
    if (i > 1) inv[i] = (mod - mod / i) * inv[mod % i] % mod;

    prodt_phi[i] = prodt_phi[i - 1] * QPow(i, phi[i]) % mod;
    inv_prodt_phi[i] = Inv(prodt_phi[i]);
  }

  for (int d = 1; d <= Lim; ++ d) {
    for (int j = 1; d * j <= Lim; ++ j) {
      int t = d * j;
      if (mu[j] == 1) {
        g[0][t] = g[0][t] * d % mod;
        g[1][t] = g[1][t] * QPow(1ll * d, 1ll * t * t) % mod;
      } else if (mu[j] == -1) {
        g[0][t] = g[0][t] * inv[d] % mod;
        g[1][t] = g[1][t] * Inv(QPow(1ll * d, 1ll * t * t)) % mod;
      }
    }
  }
  inv_prodg[0][0] = prodg[0][0] = 1;
  inv_prodg[1][0] = prodg[1][0] = 1;
  inv_prodt_phi[0] = 1;
  for (int i = 1; i <= Lim; ++ i) {
    for (int j = 0; j <= 1; ++ j) {
      prodg[j][i] = prodg[j][i - 1] * g[j][i] % mod;
      inv_prodg[j][i] = Inv(prodg[j][i]);
    }
  }
}
LL f1(LL a_, LL b_, LL c_, int type) {
  if (! type) return QPow(fac[a_], b_ * c_);
  if (type == 1) return QPow(prodi_i[a_], Sum(b_) * Sum(c_));
  LL ret = 1, lim = min(min(a_, b_), c_);
  for (LL l = 1, r = 1; l <= lim; l = r + 1) {
    r = min(min(a_ / (a_ / l), b_ / (b_ / l)), c_ / (c_ / l));
    ret = ret * QPow(prodt_phi[r] * inv_prodt_phi[l - 1], (a_ / l) * (b_ / l) % (mod - 1) * (c_ / l)) % mod;
    ret = ret * QPow(fac[a_ / l], (sumphi[r] - sumphi[l - 1] + mod - 1) % (mod - 1) * (b_ / l) % (mod - 1) * (c_ / l)) % mod;
  }
  return ret;
}
LL f2_2(LL a_, LL b_) { 
  LL ret = 1;
  for (LL l = 1, r = 1; l <= min(a_, b_); l = r + 1) {
    r = min(a_ / (a_ / l), b_ / (b_ / l));
    ret = ret * QPow(prodg[0][r] * inv_prodg[0][l - 1], 1ll * (a_ / l) * (b_ / l)) % mod;
  }
  return ret;
}
LL f2(LL a_, LL b_, LL c_, int type) {
  LL ret = 1;
  if (! type) {
    for (LL l = 1, r = 1; l <= min(a_, b_); l = r + 1) {
      r = min(a_ / (a_ / l), b_ / (b_ / l));
      LL val = QPow(prodg[0][r] * inv_prodg[0][l - 1], 1ll * (a_ / l) * (b_ / l));
      ret = (ret * QPow(val, c_)) % mod;
    }
  } else if (type == 1) {
    for (LL l = 1, r = 1; l <= min(a_, b_); l = r + 1) {
      r = min(a_ / (a_ / l), b_ / (b_ / l));
      LL val = QPow(prodg[1][r] * inv_prodg[1][l - 1], Sum(a_ / l) * Sum(b_ / l));
      ret = (ret * QPow(val, Sum(c_))) % mod;
    }
  } else {
    LL lim = min(min(a_, b_), c_);
    for (LL l = 1, r = 1; l <= lim; l = r + 1) {
      r = min(min(a_ / (a_ / l), b_ / (b_ / l)), c_ / (c_ / l));
      ret = ret * QPow(f2_2(a_ / l, b_ / l), (sumphi[r] - sumphi[l - 1] + mod - 1) % (mod - 1) * (c_ / l)) % mod;
      ret = ret * QPow(prodt_phi[r] * inv_prodt_phi[l - 1], (a_ / l) * (b_ / l) % (mod - 1) * (c_ / l)) % mod;
    }
  }
  return ret;
}
//=============================================================
int main() {
  T = read(), mod = read();
  Prepare();
  while (T -- ) {
    A = read(), B = read(), C = read();
    for (int i = 0; i <= 2; ++ i) {
      ans = f1(A, B, C, i) * f1(B, A, C, i) % mod;
      ans = ans * Inv(f2(A, B, C, i)) % mod * Inv(f2(A, C, B, i)) % mod;
      printf("%lld ", ans);  
    }
    printf("\n");
  }
  return 0;
}
```

---

## 作者：Leasier (赞：13)

前置芝士：[莫比乌斯反演](https://oi-wiki.org/math/mobius/)

**Warning：本题需要一定的莫比乌斯反演基础。建议完成 [P3704](https://www.luogu.com.cn/problem/P3704) 后再来查看本篇题解。**

**注意：由于本蒟蒻比较懒，部分过于基础的转化省略。**

原式 $= \displaystyle\prod_{i = 1}^A \prod_{j = 1}^B \prod_{k = 1}^C (\frac{ij}{\gcd(i, j) \gcd(i, k)})^{f(\operatorname{type})}$

1. $\operatorname{type} = 0$

设 $f_1(A, B) = \displaystyle\prod_{i = 1}^A \prod_{j = 1}^B \gcd(i, j)$。

∴原式 $= \displaystyle\frac{(A!)^{BC} (C!)^{AB}}{f_1(A, B)^C f_1(A, C)^B}$

由 P3704 的套路可得：$f_1(A, B) = \displaystyle\prod_{T = 1}^{\min(A, B)} (\prod_{d\ |\ T} d^{\mu(\frac{T}{d})})^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$。

设 $f(n) = \displaystyle\prod_{d\ |\ n} d^{\mu(\frac{n}{d})}$。

∴$f_1(A, B) = \displaystyle\prod_{T = 1}^{\min(A, B)} f(T)^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$。

预处理 $f$ 的前缀积及其逆元即可。

2. $\operatorname{type} = 1$

设 $g(n) = \displaystyle\prod_{i = 1}^n i^i$，$f_2(A, B) = \displaystyle\prod_{i = 1}^A \prod_{j = 1}^B \gcd(i, j)^{ij}$，$S_1(n) = \frac{1}{2} n (n + 1)$。

∴原式 $= \displaystyle\frac{g(A)^{S_1(B) S_1(C)} g(B)^{S_1(A) S_1(C)}}{f_2(A, B)^{S_1(C)} f_2(A, C)^{S_1(B)}}$

$f_2(A, B) = \displaystyle\prod_{i = 1}^A \prod_{j = 1}^B \gcd(i, j)^{ij}$

$ = \displaystyle\prod_{d = 1}^{\min(A, B)} d^{\prod_{i = 1}^A \prod_{j = 1}^B [\gcd(i, j) = d] ij}$

$ = \displaystyle\prod_{d = 1}^{\min(A, B)} d^{\sum_{p = 1}^{\lfloor \frac{\min(A, B)}{d} \rfloor} \mu(p) \lfloor \frac{A}{dp} \rfloor \lfloor \frac{B}{dp} \rfloor}$

$ = \displaystyle\prod_{T = 1}^{\min(A, B)} (\prod_{d\ |\ T} d^{\mu(\frac{T}{d})})^{S_1(\lfloor \frac{A}{T} \rfloor) S_1(\lfloor \frac{B}{T} \rfloor)}$

$ = \displaystyle\prod_{T = 1}^{\min(A, B)} f(T)^{S_1(\lfloor \frac{A}{T} \rfloor) S_1(\lfloor \frac{B}{T} \rfloor)}$

3. $\operatorname{type} = 2$

设 $f_3(A, B, C) = \displaystyle\prod_{i = 1}^A \prod_{j = 1}^B \prod_{k = 1}^C i^{\gcd(i, j, k)}$，$f_4(A, B, C) = \displaystyle\prod_{i = 1}^A \prod_{j = 1}^B \prod_{k = 1}^C \gcd(i, j)^{\gcd(i, j, k)}$。

∴原式 $= \displaystyle\frac{f_3(A, B, C) f_3(B, A, C)}{f_4(A, B, C) f_4(A, C, B)}$

$f_3(A, B, C) = \displaystyle\prod_{d = 1}^{\min(A, B, C)} (\prod_{d\ |\ i}^A i^d)^{\varphi(d) \lfloor \frac{B}{d} \rfloor \lfloor \frac{C}{d} \rfloor}$

$ = \displaystyle\prod_{d = 1}^{\min(A, B, C)} (d^{\lfloor \frac{A}{d} \rfloor} \lfloor \frac{A}{d} \rfloor !)^{\varphi(d) \lfloor \frac{B}{d} \rfloor \lfloor \frac{C}{d} \rfloor}$

$ = \displaystyle\prod_{d = 1}^{\min(A, B, C)} (d^{\varphi(d)})^{\lfloor \frac{A}{d} \rfloor \lfloor \frac{B}{d} \rfloor \lfloor \frac{C}{d} \rfloor} (\lfloor \frac{A}{d} \rfloor !)^{\varphi(d) \lfloor \frac{B}{d} \rfloor \lfloor \frac{C}{d} \rfloor}$

**加油，这是最后一个~~精神污染~~的式子了！**

$f_4(A, B, C) = \displaystyle\prod_{d = 1}^{\min(A, B)} d^{\sum_{i = 1}^A \sum_{j = 1}^B [\gcd(i, j) = d] \sum_{k = 1}^C \gcd(d, k)}$

$ = \displaystyle\prod_{d = 1}^{\min(A, B)} d^{\sum_{p = 1}^{\lfloor \frac{\min(A, B)}{d} \rfloor} \mu(p) \lfloor \frac{A}{dp} \rfloor \lfloor \frac{B}{dp} \rfloor \sum_{q\ |\ d} \varphi(q) \lfloor \frac{C}{q} \rfloor}$

$ = \displaystyle\prod_{T = 1}^{\min(A, B)} (\prod_{d\ |\ T} d^{\mu(\frac{T}{d}) \sum_{q\ |\ d} \varphi(q) \lfloor \frac{C}{q} \rfloor})^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$

貌似没有什么化简的方法了，但中间~~这一坨~~又不能预处理，所以我们需要考虑玄学方法。

**遇到这种毒瘤东西，可以考虑将 $d$ 拆分成 $q$ 和 $\frac{d}{q}$，分别计算贡献，最后相乘。**

$f_4(A, B, C) = \displaystyle\prod_{T = 1}^{\min(A, B)} ((\prod_{q\ |\ T} q^{\varphi(q) \lfloor \frac{C}{q} \rfloor \sum_{d\ |\ \frac{T}{q}} \mu(\frac{T}{dq})})(\prod_{q\ |\ T} (\prod_{q\ |\ d, d\ |\ T} (\frac{d}{q})^{\mu(\frac{T}{d})})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}))^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$

$ = \displaystyle\prod_{T = 1}^{\min(A, B)} ((\prod_{q\ |\ T} q^{\varphi(q) \lfloor \frac{C}{q} \rfloor  \varepsilon(\frac{T}{q})})(\prod_{q\ |\ T} (\prod_{q\ |\ d, d\ |\ T} (\frac{d}{q})^{\mu(\frac{T}{d})})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}))^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$

$ = \displaystyle\prod_{T = 1}^{\min(A, B)} ((T^{\varphi(T) \lfloor \frac{C}{T} \rfloor})(\prod_{q\ |\ T} (\prod_{q\ |\ d, d\ |\ T} (\frac{d}{q})^{\mu(\frac{T}{d})})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}))^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$

然后就发现左边那个括号里的东西可以跟 $f_3$ 里的一些东西约掉！

设 $f_3^{'}(A, B, C) = \displaystyle\prod_{d = 1}^{\min(A, B, C)} (\lfloor \frac{A}{d} \rfloor !)^{\varphi(d) \lfloor \frac{B}{d} \rfloor \lfloor \frac{C}{d} \rfloor}$，$f_4^{'}(A, B, C) = \displaystyle\prod_{T = 1}^{\min(A, B)} (\prod_{q\ |\ T} (\prod_{q\ |\ d, d\ |\ T} (\frac{d}{q})^{\mu(\frac{T}{d})})^{\varphi(q) \lfloor \frac{C}{q} \rfloor})^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$。

预处理 $\varphi$ 前缀和即可。

∴原式 $= \displaystyle\frac{f_3^{'}(A, B, C) f_3^{'}(B, A, C)}{f_4^{'}(A, B, C) f_4^{'}(A, C, B)}$

$f_4^{'}(A, B, C) = \displaystyle\prod_{T = 1}^{\min(A, B)} (\prod_{q\ |\ T} (\prod_{q\ |\ d, d\ |\ T} (\frac{d}{q})^{\mu(\frac{T}{d})})^{\varphi(q) \lfloor \frac{C}{q} \rfloor})^{\lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor}$

$ = \displaystyle\prod_{q = 1}^{\min(A, B, C)} (\prod_{q\ |\ d}^{\min(A, B, C)} (\frac{d}{q})^{\sum_{d\ |\ T}^{\min(A, B, C)} \mu(\frac{T}{d}) \lfloor \frac{A}{T} \rfloor \lfloor \frac{B}{T} \rfloor})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}$

$ = \displaystyle\prod_{q = 1}^{\min(A, B, C)} (\prod_{q\ |\ d}^{\min(A, B, C)} (\frac{d}{q})^{\sum_{T = 1}^{\lfloor \frac{\min(A, B, C)}{d} \rfloor} \mu(T) \lfloor \frac{A}{dT} \rfloor \lfloor \frac{B}{dT} \rfloor})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}$

$ = \displaystyle\prod_{q = 1}^{\min(A, B, C)} (\prod_{d = 1}^{\lfloor \frac{\min(A, B, C)}{q} \rfloor} d^{\sum_{T = 1}^{\lfloor \frac{\min(A, B, C)}{dq} \rfloor} \mu(T) \lfloor \frac{A}{dqT} \rfloor \lfloor \frac{B}{dqT} \rfloor})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}$

$ = \displaystyle\prod_{q = 1}^{\min(A, B, C)} (\prod_{d = 1}^{\lfloor \frac{\min(A, B, C)}{q} \rfloor} d^{\sum_{T = 1}^{\lfloor \frac{\min(A, B, C)}{dq} \rfloor} \mu(T) \lfloor \frac{A}{dqT} \rfloor \lfloor \frac{B}{dqT} \rfloor})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}$

$ = \displaystyle\prod_{q = 1}^{\min(A, B, C)} (\prod_{U = 1}^{\lfloor \frac{\min(A, B, C)}{q} \rfloor} (\prod_{d\ |\ U} d^{\mu(\frac{U}{d})})^{\lfloor \frac{A}{U} \rfloor \lfloor \frac{B}{U} \rfloor})^{\varphi(q) \lfloor \frac{C}{q} \rfloor}$

$ = \displaystyle\prod_{q = 1}^{\min(A, B, C)} f_1(\lfloor \frac{A}{q} \rfloor, \lfloor \frac{B}{q} \rfloor) ^{\varphi(q) \lfloor \frac{C}{q} \rfloor}$

综上，时间复杂度为 $O(Tn^{\frac{3}{4}} \log p + N \ln N + N \log p)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int N = 1e5 + 7;
int mod;
int prime[N], phi[N], mu[N];
ll sum[N], fac[N], f[N], g[N], product1[N], inv_product1[N], product2[N], inv_product2[N];
bool p[N];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int mod){
	int cnt = 0;
	p[0] = p[1] = true;
	phi[1] = 1;
	mu[1] = 1;
	for (register int i = 2; i < N; i++){
		if (!p[i]){
			prime[++cnt] = i;
			phi[i] = i - 1;
			mu[i] = -1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				phi[t] = phi[i] * prime[j];
				mu[t] = 0;
				break;
			}
			phi[t] = phi[i] * (prime[j] - 1);
			mu[t] = -mu[i];
		}
	}
	for (register int i = 1; i < N; i++){
		sum[i] = sum[i - 1] + phi[i];
	}
	fac[0] = 1;
	for (register int i = 1; i < N; i++){
		fac[i] = fac[i - 1] * i % mod;
	}
	for (register int i = 1; i < N; i++){
		f[i] = 1;
	}
	for (register int i = 1; i < N; i++){
		if (mu[i] == 0) continue;
		for (register int j = i; j < N; j += i){
			f[j] = f[j] * (mu[i] == 1 ? j / i : quick_pow(j / i, mod - 2, mod)) % mod;
		}
	}
	g[0] = 1;
	for (register int i = 1; i < N; i++){
		g[i] = g[i - 1] * quick_pow(i, i, mod) % mod;
	}
	product1[0] = product2[0] = 1;
	inv_product1[0] = inv_product2[0] = 1;
	for (register int i = 1; i < N; i++){
		product1[i] = product1[i - 1] * f[i] % mod;
		inv_product1[i] = quick_pow(product1[i], mod - 2, mod);
		product2[i] = product2[i - 1] * quick_pow(f[i], (ll)i * i % (mod - 1), mod) % mod;
		inv_product2[i] = quick_pow(product2[i], mod - 2, mod);
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

inline ll func1(int a, int b, int mod){
	int ab = min(a, b);
	ll ans = 1;
	for (register int i = 1, j; i <= ab; i = j + 1){
		int ta = a / i, tb = b / i;
		j = min(a / ta, b / tb);
		ans = ans * quick_pow(inv_product1[i - 1] * product1[j] % mod, (ll)ta * tb % (mod - 1), mod) % mod;
	}
	return ans;
}

inline ll solve1(int a, int b, int c, int mod){
	return quick_pow(fac[a], (ll)b * c % (mod - 1), mod) * quick_pow(fac[b], (ll)a * c % (mod - 1), mod) % mod * quick_pow(quick_pow(func1(a, b, mod), c, mod) % mod * quick_pow(func1(a, c, mod), b, mod) % mod, mod - 2, mod) % mod;
}

inline ll sum1(int n){
	return (ll)n * (n + 1) / 2;
}

inline ll func2(int a, int b, int mod){
	int ab = min(a, b);
	ll ans = 1;
	for (register int i = 1, j; i <= ab; i = j + 1){
		int ta = a / i, tb = b / i;
		j = min(a / ta, b / tb);
		ans = ans * quick_pow(inv_product2[i - 1] * product2[j] % mod, sum1(ta) % (mod - 1) * sum1(tb) % (mod - 1), mod) % mod;
	}
	return ans;
}

inline ll solve2(int a, int b, int c, int mod){
	return quick_pow(g[a], sum1(b) % (mod - 1) * sum1(c) % (mod - 1), mod) * quick_pow(g[b], sum1(a) % (mod - 1) * sum1(c) % (mod - 1), mod) % mod * quick_pow(quick_pow(func2(a, b, mod), sum1(c), mod) % mod * quick_pow(func2(a, c, mod), sum1(b), mod) % mod, mod - 2, mod) % mod;
}

inline ll func3(int a, int b, int c, int mod){
	int abc = min(a, min(b, c));
	ll ans = 1;
	for (register int i = 1, j; i <= abc; i = j + 1){
		int ta = a / i, tb = b / i, tc = c / i;
		j = min(a / ta, min(b / tb, c / tc));
		ans = ans * quick_pow(fac[ta], (ll)tb * tc % (mod - 1) * (sum[j] - sum[i - 1]) % (mod - 1), mod) % mod;
	}
	return ans;
}

inline ll func4(int a, int b, int c, int mod){
	int abc = min(a, min(b, c));
	ll ans = 1;
	for (register int i = 1, j; i <= abc; i = j + 1){
		int ta = a / i, tb = b / i, tc = c / i;
		j = min(a / ta, min(b / tb, c / tc));
		ans = ans * quick_pow(func1(ta, tb, mod), tc * (sum[j] - sum[i - 1]) % (mod - 1), mod) % mod;
	}
	return ans;
}

inline ll solve3(int a, int b, int c, int mod){
	return func3(a, b, c, mod) * func3(b, a, c, mod) % mod * quick_pow(func4(a, b, c, mod) * func4(a, c, b, mod) % mod, mod - 2, mod) % mod;
}

int main(){
	int t, p;
	scanf("%d %d", &t, &p);
	init(p);
	for (register int i = 1; i <= t; i++){
		int a, b, c;
		scanf("%d %d %d", &a, &b, &c);
		printf("%lld %lld %lld\n", solve1(a, b, c, p), solve2(a, b, c, p), solve3(a, b, c, p));
	}
	return 0;
}
```

---

## 作者：诱宵美⑨ (赞：10)

作为一个东方众，看到这道题当然要做一下，然后写个题解啊

题解数这么少，（有些大佬还跳步，导致我一开始有些没看懂。。）

我尽量把能写的过程全都写了（管理员大大给过吧）

这题是真的草。。于是我被题解里的大佬给劝到了[这道题](https://www.luogu.com.cn/problem/P3704)

那题我也写了题解->[here](https://www.luogu.com.cn/blog/you-xiao-mei-jiu/p3704-sdoi2017-shuo-zi-biao-ge)<-

***

![](https://cdn.luogu.com.cn/upload/image_hosting/ce80tzhz.png)

原题可以化成这样的式子

然后，显然可以分为两个子问题：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{f(type)}$$

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)^{f(type)}$$


按type的情况分类讨论

让我们愉快的 **推 倒** 式子吧

## type=0
![](https://cdn.luogu.com.cn/upload/image_hosting/rqmy9f8t.png)


(i) 预处理阶乘+快速幂 即可

(ii) 预处理 $\prod_{d|T}d^{μ(\frac{T}{d})}$ 
的前缀积 + 整除分块
***
***

## type=1
![](https://cdn.luogu.com.cn/upload/image_hosting/misxjvin.png)


(i) 预处理 $i^i$ 的前缀积 + 快速幂

***
### 来看（ii）

![](https://cdn.luogu.com.cn/upload/image_hosting/ikmzyk4e.png)

(ii) 预处理 $(\prod_{d|T}d^{μ(\frac{T}{d})})^{T^2}$ 
的前缀积 + 整除分块 + 快速幂
****
***
## type=2
(i)

![](https://cdn.luogu.com.cn/upload/image_hosting/ey504g6o.png)

1) 预处理 $T^{\varphi(T)}$ 的前缀积 

2) 预处理一个模(mod-1)意义下的 $\varphi(T)$ 的前缀和 

3) 整除分块
***
![](https://cdn.luogu.com.cn/upload/image_hosting/xpjqhx1b.png)

我们可以把指数的那坨单独拿出来看

![](https://cdn.luogu.com.cn/upload/image_hosting/89mvwm1c.png)

预处理出中间那一坨$\prod_{d|T'}d^{\mu(\frac{T'}{d})}$
之后, 

两次整除分块就解决啦！

---

## 作者：huangzirui (赞：9)

如果 $\LaTeX$ 崩了就请到[我的博客](https://www.luogu.com.cn/blog/My-luoguBuoke-HZR/solution-p5518)看吧QwQ

题意：

求：

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C(\frac{\text{lcm}(i,j)}{\gcd(i,k)})^X$$

你需要输出 $X$ 分别等于 $1 \ ;\ i\times j\times k\ ;\ \gcd(i,j,k)$ 的值对给定的正整数 $p$ 取模的结果。

数据组数 $T=70\ \ \ A,B,C \leq 10^5\ \ \ 10^7 \leq p \leq 1.05 \times 10^9\ \ \ p\in \{prime\}$

---

吐槽：**这么神的题目我不配做**，饶了我吧QAQ。 [幽灵乐团](https://music.163.com/#/song?id=832877)

首先显然有 $\text{lcm}(a,b)=\dfrac{a\times b}{\gcd(a,b)}$

于是原式等于：

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C(\frac{i \times j}{\gcd( i,j) \times \gcd(i,k))})^X$$

相当于求 $\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z i^X$ 和 $\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z \gcd(i,j)^X$ 。

设 $f(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z i^X\ ,\ g(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z \gcd(i,j)^X$

那么原式等于 $\dfrac{f(A,B,C)f(B,A,C)}{g(A,B,C)g(A,C,B)}$

分类讨论 $X$ 的每一种取值的答案。

### 1. $X=1$

$$f(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z i=\prod_{i=1}^X i^{yz}={(\prod_{i=1}^X i)}^{yz}$$

预处理阶乘后直接计算即可。

$$g(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z \gcd(i,j)=(\prod_{i=1}^x\prod_{j=1}^y\gcd(i,j))^z$$

考虑 $\prod_{i=1}^x\prod_{j=1}^y\gcd(i,j)$ 部分。

考虑先枚举 $\gcd$ 的值。

$$\prod_{d=1}^x d^{\sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}[(i,j)=1]}$$

考虑 $\sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}[(i,j)=1]$ ，这个东西很莫反。

它等于

$$
\sum_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\sum_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum_{p|i,j}
\mu(p)
$$

$$
\sum_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\mu(p)
\left\lfloor{\frac{x}{dp}}\right\rfloor
\left\lfloor{\frac{y}{dp}}\right\rfloor
$$

这时候我们把这个式子和前面的部分连起来，这样就可以设出 $T=dp$

$$
\prod_{d=1}^{x}d^{
	\sum\limits_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
	\mu(p)
	\left\lfloor{\frac{x}{dp}}\right\rfloor
	\left\lfloor{\frac{y}{dp}}\right\rfloor
}
$$

$$
\prod_{T=1}^{x}
\prod_{d|T}
d^{
	\mu(\frac{T}{d})
	\left\lfloor{\frac{x}{T}}\right\rfloor
	\left\lfloor{\frac{y}{T}}\right\rfloor
}
$$

$$
\prod_{T=1}^{x}
(
	\prod_{d|T}
	d^{
		\mu(\frac{T}{d})
	}
)^
{
	\left\lfloor{\frac{x}{T}}\right\rfloor
	\left\lfloor{\frac{y}{T}}\right\rfloor
}
$$

这个式子里面可以 $O(n\log n)$ 预处理。外层数论分块即可。

### 2. $X\!=i\! \times\!j\!\times\!k$

先考虑 $f(x,y,z)$

$$f(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z i^{\ ijk}$$

然后显然：

$$=\prod_{i=1}^x i^{\ i\cdot r(y)\cdot r(z)}$$
$$=(\prod_{i=1}^x i^i)^{r(y)\cdot r(z)}$$

其中 $r(x)=1+2+...+x=\dfrac{1}{2}x(1+x)$

接着考虑 $g(x,y,z)$

$$g(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z \gcd(i,j)^{ijk}$$

$$=\prod_{i=1}^x\prod_{j=1}^y\gcd(i,j)^{ijr(z)}$$

$$={(\prod_{i=1}^x\prod_{j=1}^y\gcd(i,j)^{ij})}^{r(z)}$$

于是我们只要考虑 $\prod_{i=1}^x\prod_{j=1}^y\gcd(i,j)^{ij}$ 就好了。

像之前一样，枚举 $\gcd$ 的取值：

$$
\prod_{d=1}^x
d^
	{
    \sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
    \sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
    ijd^2[(i,j)=1]
    }
$$

然后上面这个式子很套路，就不讲了，把过程写一遍：

$$
\prod_{d=1}^x
d^
	{
    d^2
    \sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
    \sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
    ij
    \sum\limits_{p|i,j}
    \mu(p)
    }
$$

$$
\prod_{d=1}^x
d^
	{
    d^2
    \sum\limits_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
    \mu(p)
    \sum\limits_{i=1}^{\left\lfloor{\frac{x}{dp}}\right\rfloor}
    \sum\limits_{j=1}^{\left\lfloor{\frac{y}{dp}}\right\rfloor}
    ijp^2
    }
$$


$$
\prod_{d=1}^x
d^
	{
    d^2
    \sum\limits_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
    \mu(p)p^2
    r({\left\lfloor{\frac{x}{dp}}\right\rfloor})
    r({\left\lfloor{\frac{y}{dp}}\right\rfloor})
    }
$$

然后设 $T=dp$ ...

$$
\prod_{T=1}^x
\prod_{d|T}
d^
	{
    d^2\mu(\frac{T}{d}){(\frac{T}{d})}^2
    r({\left\lfloor{\frac{x}{T}}\right\rfloor})
    r({\left\lfloor{\frac{y}{T}}\right\rfloor})
    }
$$

$$
\prod_{T=1}^x
\prod_{d|T}
d^
	{
    T^2\mu(\frac{T}{d})
    r({\left\lfloor{\frac{x}{T}}\right\rfloor})
    r({\left\lfloor{\frac{y}{T}}\right\rfloor})
    }
$$

$$
\prod_{T=1}^x
{(
\prod_{d|T}
d^
	{
    \mu(\frac{T}{d})
    })
}^{
	T^2
    r({\left\lfloor{\frac{x}{T}}\right\rfloor})
    r({\left\lfloor{\frac{y}{T}}\right\rfloor})
}
$$

于是像之前那样处理就可以了。。。

### 3. $X\!= \gcd(i,j,k)$

这道题最神的一个部分分来了。

那么先考虑 $f(x,y,z)$

$$f(x,y,z)=\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z i^{\gcd(i,j,k)}$$

之前两个 $f$ 可以直接看出来，这个就要麻烦一点。

但是看到这个形式就会想到直接反演了。

那么依旧先枚举 $\gcd$ 的值。

原式等于：

$$
\prod_{d=1}^x
\prod_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
(id)^{d
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum\limits_{k=1}^{\left\lfloor{\frac{z}{d}}\right\rfloor}
[(i,j,k)=1]}
$$

提出来上面那一坨（？

$$
d
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum\limits_{k=1}^{\left\lfloor{\frac{z}{d}}\right\rfloor}
[(i,j,k)=1]
$$

于是按照套路：

$$
d
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum\limits_{k=1}^{\left\lfloor{\frac{z}{d}}\right\rfloor}
\sum\limits_{p|i,j,k}\mu(p)
$$

然后我们发现这里要把 $p$ 挪到 $i,j,k$ 前面。于是把前面丢掉含有 $i$ 的部分的找回来（我在搞什么

$$
\prod_{d=1}^x
\prod_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
(id)^{d
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum\limits_{k=1}^{\left\lfloor{\frac{z}{d}}\right\rfloor}
\sum\limits_{p|i,j,k}\mu(p)}
$$

$$
\prod_{d=1}^x
\prod_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\prod_{i=1}^{\left\lfloor{\frac{x}{dp}}\right\rfloor}
(id)^{d\cdot\mu(p)
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{dp}}\right\rfloor}
\sum\limits_{k=1}^{\left\lfloor{\frac{z}{dp}}\right\rfloor}
}
$$


$$
\prod_{d=1}^x
\prod_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\prod_{i=1}^{\left\lfloor{\frac{x}{dp}}\right\rfloor}
(idp)^{d\cdot\mu(p)
{\left\lfloor{\frac{y}{dp}}\right\rfloor}
{\left\lfloor{\frac{z}{dp}}\right\rfloor}
}
$$

然后也是相同的套路 —— 设 $T=dp$

$$
\prod_{T=1}^x
\prod_{d|T}
\prod_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT)^{d\cdot\mu(\frac{T}{d})
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}
}
$$

然后就把外层含 $T$ 项的中间加个括号~

$$
\prod_{T=1}^x
(
\prod_{d|T}
\prod_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT)^{d\cdot\mu(\frac{T}{d})}
)^
{
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}
}
$$

考虑中间这一坨： $\prod\limits_{d|T}
\prod\limits_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT)^{d\cdot\mu(\frac{T}{d})}$

这个式子看上去真的不太好搞。。于是你尝试一层层分析：

首先可以把指数剥出来：

$$
\prod\limits_{d|T}(
\prod\limits_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT))^{d\cdot\mu(\frac{T}{d})}
$$

想一下里面这一坨怎么搞，这样一下就清爽多了

$$\prod\limits_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT)=T^{\left\lfloor{\frac{x}{T}}\right\rfloor}({\left\lfloor{\frac{x}{T}}\right\rfloor}!)$$
回顾一下之前的式子：

$$
\prod_{T=1}^x
(
\prod_{d|T}
\prod_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT)^{d\cdot\mu(\frac{T}{d})}
)^
{
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}
}
$$

$d$ 其实只充当了指数项，于是我们又可以搞掉一部分：

$$
\prod_{T=1}^x
((
\prod_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT))^{\sum_{d|T}d\cdot\mu(\frac{T}{d})}
)^
{
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}
}
$$

**然后这个式子有点熟悉，我们发现 $\sum_{d|T}d\cdot\mu(\frac{T}{d})$**

**等价于 $Id*\mu=\varphi$**

于是原式就等于：

$$
\prod_{T=1}^x
((
\prod_{i=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}
(iT))^{\varphi(T)}
)^
{
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}
}
$$

分开计算 $i$ 和 $T$ ：

$$
\prod_{T=1}^x
(\left\lfloor{\frac{x}{T}}\right\rfloor!)^{
\varphi(T)
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}}
\times
(T^{\varphi(T)})^{
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
{\left\lfloor{\frac{z}{T}}\right\rfloor}}
$$

直接数论分块就可以解决。

于是我们终于把 $f$ 函数搞完了QAQ

继续考虑 $g$ 函数：

$$\prod_{i=1}^x\prod_{j=1}^y\prod_{k=1}^z \gcd(i,j)^{\gcd(i,j,k)}$$

我们注意到这里有两个不一样的 $\gcd$ 考虑先枚举 $\gcd(i,j)$ :

$$
\prod_{d=1}^x
d^{
\sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum\limits_{k=1}^{z}
[\gcd(i,j)=1]\gcd(di,dj,k)
}
$$

这个式子特别妙 —— 后面的式子有值当且仅当 $\gcd(i,j)=1$ 因此 $\gcd(di,dj)=d$ 所以就有 $\gcd(di,dj,k)=\gcd(d,k)$，于是可以搞一波：

$$
\prod_{d=1}^x
d^{
\sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
[\gcd(i,j)=1]
\sum\limits_{k=1}^{z}
\gcd(d,k)
}
$$

设 $c(x,y)=\sum\limits_{i=1}^x\gcd(i,y)$

这个 $c$ 肯定可以反演计算的啦。。

算出来结果是：

$$c(x,y)=\sum_{d|y}\varphi(d)\left\lfloor{\frac{x}{d}}\right\rfloor$$

于是我们可以 $O(n \log n) $预处理。接下来看一下剩余的部分：

$$
\prod_{d=1}^x
d^{
\sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
[\gcd(i,j)=1]
(\sum\limits_{k=1}^{z}
\gcd(d,k))
}
$$

这个式子显然也可以反演：

$$
\prod_{d=1}^x
d^{
\sum\limits_{i=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\sum\limits_{j=1}^{\left\lfloor{\frac{y}{d}}\right\rfloor}
\sum\limits_{p|i,j}\mu(p)
(\sum\limits_{k=1}^{z}
\gcd(d,k))
}
$$

$$
\prod_{d=1}^x
d^{
\sum\limits_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\mu(p)
{\left\lfloor{\frac{x}{dp}}\right\rfloor}
{\left\lfloor{\frac{y}{dp}}\right\rfloor}
(\sum\limits_{k=1}^{z}
\gcd(d,k))
}
$$

然后把 $p$ 搞出来：

$$
\prod\limits_{p=1}^{\left\lfloor{\frac{x}{d}}\right\rfloor}
\prod_{d=1}^x
d^{
\mu(p)
{\left\lfloor{\frac{x}{dp}}\right\rfloor}
{\left\lfloor{\frac{y}{dp}}\right\rfloor}
(\sum\limits_{k=1}^{z}
\gcd(d,k))
}
$$

然后设 $T=dp$ 有：

$$
\prod\limits_{T=1}^x
\prod_{d|T}
d^{
\mu(\frac{T}{d})
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
(\sum\limits_{k=1}^{z}
\gcd(d,k))
}
$$

然后分一下层：

$$
\prod\limits_{T=1}^x
{(\prod_{d|T}
d^{
\mu(\frac{T}{d})
(\sum\limits_{k=1}^{z}
\gcd(d,k))
})}
^{
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
}
$$

再代入之前的 $c$ ：

$$
\prod\limits_{T=1}^x
{(\prod_{d|T}
d^{
\mu(\frac{T}{d})
c(z,d)
})}
^{
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
}
$$

$$
\prod\limits_{T=1}^x
{(\prod_{d|T}
d^{
\mu(\frac{T}{d})
(\sum_{p|d}\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor)
})}
^{
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
}
$$

然后把 $p$ 拿出来：

$$
\prod\limits_{T=1}^x
{(\prod_{d|T}
\prod_{p|d}
d^{
\mu(\frac{T}{d})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
})}
^{
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
}
$$

然后你会发现这个式子推不动了qaq

这里有一个有点毒瘤的技巧：把 $d$ 拆成 $\frac{d}{p} $ 和 $p$

先计算 $\frac{d}{p}$

$$
\prod\limits_{T=1}^x
\prod_{d|T}
\prod_{p|d}
(\frac{d}{p})^{
\mu(\frac{T}{d})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
}
$$

把 $T$ 乘上 $p$

$$
\prod_{p=1}^x\ 
\prod_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}\ 
\prod_{p|d\ \&\&\ d|Tp}
(\frac{d}{p})^{
\mu(\frac{Tp}{d})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
}
$$

再把 $d$ 乘上 $p$

$$
\prod_{p=1}^x\ 
\prod_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}\ 
\prod_{d|T}
d^{
\mu(\frac{Tp}{dp})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
}
$$

然后化简一下：

$$
\prod_{p=1}^x\ 
(\prod_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}\ 
(\prod_{d|T}
d^{
\mu(\frac{T}{d})})^{
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
})^{
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
}
$$

然后这个式子十分优美。。可以考虑如何计算了。

首先看内层：

$$\prod_{d|T}d^{\mu(\frac{T}{d})}$$

这个式子显然可以预处理搞出来，复杂度 $O(n \log n)$

${\color{black}\colorbox{black}{\text{其实就是 X=1 的情况}}}$

然后外面的两层只需要数论分块就可以了呢 QwQ

然后我们再看 $p$ 的情况：

$$
\prod\limits_{T=1}^x
\prod_{d|T}
\prod_{p|d}
p^{
\mu(\frac{T}{d})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
{\left\lfloor{\frac{x}{T}}\right\rfloor}
{\left\lfloor{\frac{y}{T}}\right\rfloor}
}
$$

首先把 $p$ 挪到最前面：

（提示：因为 $d|T,p|d$ 所以 $p|T$ ，把 $T$ 和 $d$ 都乘上 $p$ ）

$$
\prod_{p=1}^x
\prod_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}
\prod_{d|T}
p^{
\mu(\frac{Tp}{dp})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
}
$$

然后把底下的 $\prod$ 挪到上面去：

$$
\prod_{p=1}^x
p^{
\sum\limits_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}
\sum\limits_{d|T}
\mu(\frac{T}{d})
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
}
$$

调整顺序：

$$
\prod_{p=1}^x
p^{
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
\sum\limits_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
\sum\limits_{d|T}
\mu(\frac{T}{d})
}
$$

观察 $\sum\limits_{d|T}\mu(\frac{T}{d})$ 这个相当于是 $\mu*1=\epsilon$

于是转换成：

$$
\prod_{p=1}^x
p^{
\varphi(p)\left\lfloor{\frac{z}{p}}\right\rfloor
\sum\limits_{T=1}^{\left\lfloor{\frac{x}{p}}\right\rfloor}
{\left\lfloor{\frac{x}{Tp}}\right\rfloor}
{\left\lfloor{\frac{y}{Tp}}\right\rfloor}
\epsilon(T)
}
$$

接下来因为 $espilon(T) \Leftrightarrow [T=1]$ 可以直接把 $T$ 当作 $1$ 来搞。

$$
\prod_{p=1}^x
p^{
\varphi(p)
{\left\lfloor{\frac{x}{p}}\right\rfloor}
{\left\lfloor{\frac{y}{p}}\right\rfloor}
{\left\lfloor{\frac{z}{p}}\right\rfloor}
}
$$

这个式子真的是超级漂亮啊啊啊。

简单数论分块就 OK 了。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
    char c=getchar();ll x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100010;
int i,j,k,n,m,T,A,B,C,mod;
int prime[N],is_prime[N],mu[N],phi[N],Phi[N],Phi2[N],h[N],H[N],h2[N],H2[N],nH[N],num;
int jc[N],Jc[N],jc2[N],njc2[N],mi[N];
inline ll ksm(ll sum,ll num){
    ll ans=1;
    while(num){
        if(num&1)ans=1ll*ans*sum%mod;
        sum=1ll*sum*sum%mod;
        num>>=1;
    }return ans;
}
inline ll ksm2(ll sum,ll num){
    ll ans=1;
    while(num){
        if(num&1)ans=1ll*ans*sum%(mod-1);
        sum=1ll*sum*sum%(mod-1);
        num>>=1;
    }return ans;
}
void init(){
    mu[1]=jc[0]=Jc[0]=jc2[0]=njc2[0]=jc[1]=Jc[1]=H[0]=nH[0]=H2[0]=Phi[0]=mi[0]=1;
    for(int i=1;i<N;i++)jc[i]=1ll*jc[i-1]*i%mod,Jc[i]=1ll*Jc[i-1]*ksm(i,i)%mod;
    for(int i=2;i<N;i++)is_prime[i]=1;
    phi[1]=1;
    for(int i=2;i<N;i++){
        if(is_prime[i])prime[++num]=i,mu[i]=-1,phi[i]=i-1;
        for(int j=1;j<=num && i*prime[j]<N;j++){
            is_prime[i*prime[j]]=0;
            phi[i*prime[j]]=phi[i]*prime[j];
            if(i%prime[j]==0)break;
            mu[i*prime[j]]=-mu[i];
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    for(int i=1;i<N;i++){
        Phi[i]=(Phi[i-1]+phi[i]>=mod-1? Phi[i-1]+phi[i]-(mod-1) : Phi[i-1]+phi[i]);
        h[i]=H[i]=h2[i]=H2[i]=mi[i]=1;
        jc2[i]=1ll*jc2[i-1]*ksm(i,phi[i])%mod,njc2[i]=ksm(jc2[i],mod-2);
    }
    for(int i=1;i<N;i++)
        if(mu[i])
            for(int j=i;j<N;j+=i){
                if(mu[i]==1)h[j]=1ll*h[j]*j/i%mod,h2[j]=1ll*h2[j]*(j/i)%mod;
                else h[j]=1ll*h[j]*ksm(j/i,mod-2)%mod,h2[j]=1ll*h2[j]*ksm(j/i,mod-2)%mod;
            } 
    for(int i=1;i<N;i++)H[i]=1ll*H[i-1]*h[i]%mod,nH[i]=ksm(H[i],mod-2);
    for(int i=1;i<N;i++){
        h2[i]=ksm(h2[i],1ll*i*i%(mod-1));
        H2[i]=1ll*H2[i-1]*h2[i]%mod;
    }
}
inline int R(int x,bool isksm=0){
    if(isksm)return 1ll*x*(x+1)/2%(mod-1);
    return 1ll*x*(x+1)/2%mod;
}
inline int get_f1(int x,int y,int z){
    return ksm(jc[x],(ll)(1ll*y*z%(mod-1)));
}
inline int get_f2(int x,int y,int z){
    int tmp=ksm(Jc[x],(ll)(1ll*R(y,true)*R(z,true)%(mod-1)));
    return tmp;
}
int q[N],Q[N];
int get_f3(int x,int y,int z){
    register int ans1=1,ans2=1;
    for(register int l=1,r=0;l<=min(min(x,y),z);l=r+1){
        r=min(min(x/(x/l),y/(y/l)),z/(z/l));
        ans1=1ll*ans1*ksm(jc[x/l],1ll*(Phi[r]-Phi[l-1]+mod-1)%(mod-1)*(1ll*(y/l)*(z/l)%(mod-1))%(mod-1))%mod;
//      ans2=1ll*ans2*ksm(1ll*jc2[r]*ksm(jc2[l-1],mod-2)%mod,1ll*(x/l)*(y/l)*(z/l)%(mod-1))%mod;
//      cout<<"get_f3 ans1="<<ans1<<endl;
    }
    return (1ll*ans1*ans2%mod);
}
int get_g1(int x,int y,int z){
    register int ans=1;
    for(int l=1,r=0;l<=min(x,y);l=r+1){
        r=min(x/(x/l),y/(y/l));
        ans=1ll*ans*ksm(1ll*H[r]*nH[l-1]%mod,1ll*(x/l)*(y/l)%(mod-1))%mod;
    }
    return ksm(ans,z);
}
int get_g2(int x,int y,int z){
    register int ans=1;
    for(int l=1,r=0;l<=min(x,y);l=r+1){
        r=min(x/(x/l),y/(y/l));
        int Sum=1ll*H2[r]*ksm(H2[l-1],mod-2)%mod;
        ans=1ll*ans*ksm(Sum,1ll*R(x/l,true)*R(y/l,true)%(mod-1))%mod;
    }return ksm(ans,R(z,true));
}
inline int Getsum(int x,int y){
    register int ans=1;
    for(int l=1,r=0;l<=min(x,y);l=r+1){
        r=min(x/(x/l),y/(y/l));
        ans=1ll*ans*ksm(1ll*H[r]*nH[l-1]%mod,1ll*(x/l)*(y/l)%(mod-1))%mod;
    }return ans;
}
int get_g3(int x,int y,int z){
    register int ans=1;
    for(register int l=1,r=0;l<=min(min(x,y),z);l=r+1){
        r=min(min(x/(x/l),y/(y/l)),z/(z/l));
        ans=1ll*ans*ksm(Getsum(x/l,y/l),1ll*(Phi[r]-Phi[l-1]+(mod-1))%(mod-1)*(z/l)%(mod-1))%mod;
//      ans=1ll*ans*ksm(1ll*jc2[r]*njc2[l-1]%mod,1ll*(x/l)*(y/l)%(mod-1)*(z/l)%(mod-1))%mod;
    }
    return ans;
}
int get_ans1(){
    int ans1=1ll*get_f1(A,B,C)*get_f1(B,A,C)%mod,ans2=1ll*get_g1(A,B,C)*get_g1(A,C,B)%mod;
    return (1ll*ans1*ksm(ans2,mod-2)%mod);
}
int get_ans2(){
    int ans1=1ll*get_f2(A,B,C)*get_f2(B,A,C)%mod,ans2=1ll*get_g2(A,B,C)*get_g2(A,C,B)%mod;
    return (1ll*ans1*ksm(ans2,mod-2)%mod);
}
int get_ans3(){
    int ans1=1ll*get_f3(A,B,C)*get_f3(B,A,C)%mod,ans2=1ll*get_g3(A,B,C)*get_g3(A,C,B)%mod;
    return (1ll*ans1*ksm(ans2,mod-2)%mod);
}
int main(){
    cin>>T>>mod;
    init();
    while(T--){
        cin>>A>>B>>C;
        printf("%d %d %d\n",get_ans1(),get_ans2(),get_ans3());
    }
    return 0;
}
```

于是您终于写完了这道**神题**。

---

## 作者：George1123 (赞：6)

到小蒟蒻的小窝博客里看看：[$\tt George1123$](https://www.cnblogs.com/Wendigo/p/13341419.html)

---
## 题面

> [MtOI2019 幽灵乐团](https://www.luogu.com.cn/problem/P5518)

> 给定 $p$，$Cnt$ 组测试数据，每次给 $a,b,c$，求
> $$\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\left(\frac{{\rm lcm}(i,j)}{\gcd(i,k)}\right)^{f(t)}\bmod p$$
> $t\in\{0,1,2\}$，$f(0)=1,f(1)=ijk,f(2)=\gcd(i,j,k)$。

> 数据范围：$1\le a,b,c\le 10^5$，$10^7\le p\le 105\cdot 10^7$，$p\in\mathbb{P}$，$1\le Cnt\le 70$。

---
## 蒟蒻语

初学莫比乌斯反演是很久之前了，最近集训老师讲了莫比乌斯反演。

那天蒟蒻没去，神 $\tt zhoukangyang$ 说：

> 老师抓了隔壁机房的 $\texttt{x义x}$（$\tt orz$）来现场做「MtOI2019 幽灵乐团」，结果他上来就开了题解……

于是神 $\tt zky$ 和神【数据删除】就干了这题一个晚上。第二天蒟蒻去推了一个下午，终于推出来了，推了一面，细节很多，但不难。最后蒟蒻比他们两个先做出来 $\tt /yx$。

---
## 蒟蒻解

![](https://cdn.luogu.com.cn/upload/image_hosting/9dh8cpb9.png)


所以只需算出:

![](https://cdn.luogu.com.cn/upload/image_hosting/8vosr400.png)

和

![](https://cdn.luogu.com.cn/upload/image_hosting/mxq29y20.png)

即可，共 $2\times 3=6$ 种式子。

---
### t=0

![](https://cdn.luogu.com.cn/upload/image_hosting/ytqagzv0.png)

预处理 $n!$ 时间复杂度 $\Theta(n)$，计算 $\Theta(\log n)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/je8b00o9.png)


预处理 $\prod_{d|T}d^{\mu(\frac{T}{d})}$ 前缀积时间复杂度 $\Theta(n\log\log n)$，分块计算 $\Theta(\sqrt{n}\log n)$。

---
### t=1

令 $S(n)=\frac{n(n+1)}{2}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qvapv06b.png)

预处理 $\prod_{i=1}^a i^i$ 时间复杂度 $\Theta(n)$，计算 $\Theta(\log n)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2hni8c0k.png)

在 $\prod_{d|T}d^{\mu(\frac{T}{d})}$ 的基础上预处理 $\left(\prod_{d|T}d^{\mu(\frac{T}{d})}\right)^{T^2}$ 时间复杂度 $\Theta(n\log n)$，分块计算 $\Theta(\sqrt{n}\log n)$。

---
### t=2

![](https://cdn.luogu.com.cn/upload/image_hosting/2btrvx1z.png)


左边用已经预处理过的阶乘，右边预处理 $T^{\varphi(T)}$ 前缀积时间复杂度 $\Theta(n\log n)$，分块计算 $\Theta(\sqrt{n}\log n)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/weo5w7dz.png)

> 有点跳步，但是有了这点拨并不难推，毕竟前人之述备矣，然则有些细节，确实该细讲。

$T^{\varphi(T)}$ 和 $\prod_{e|G}e^{\mu(\frac{G}{e})}$ 已经预处理过了，分块套分块 $\Theta(n\log n)$。

---
### 细节&优化

注意要模 $p$，但是根据欧拉定理，指数要模 $\varphi(p)=p-1$。

看到一个式子怎么知道该筛什么？看看哪些东西不可以分块统一算。

怎么 $\Theta(n\log \log n)$ 预处理 $\prod_{d|T}d^{\mu(\frac{T}{d})}$？

利用积性函数的性质，同时计算这东西和这东西的逆元（注意还没有求前缀积）：

```cpp
for(int i=1;i<=N;i++) f[i]=i,ivf[i]=in[i];
for(int j=0;j<cp;j++)for(int i=N/p[j];i>=1;i--)
	f[i*p[j]]=(ll)f[i*p[j]]*ivf[i]%P,ivf[i*p[j]]=(ll)ivf[i*p[j]]*f[i]%P;
```

现在的时间复杂度是 $\Theta(Tn\log n)$ 我卡过去了，但是是可以优化到 $\Theta(n^{\frac{4}{3}}+Tn^{\frac{2}{3}}\log n)$。

注意这个式子里面有什么：

![](https://cdn.luogu.com.cn/upload/image_hosting/rypwrruk.png)


所以可以 $\Theta(n^{\frac{4}{3}})$ 用类似辗转相除的方法预处理 $a,b\le n^{\frac{2}{3}}$ 的 $g(a,b)$ 以及前缀积，然后总时间复杂度就 $\Theta(n^{\frac{4}{3}}+Tn^{\frac{2}{3}}\log n)$ 了。

```cpp
for(int i=1;i<=K;i++){
	for(int j=1;j<i;j++){
		g[i][j]=g[max(j,i-j)][min(j,i-j)];
		sg[i][j]=(ll)sg[i-1][j]*sg[i][j-1]%P*isg[i-1][j-1]%P*g[i][j]%P;
		isg[i][j]=(ll)isg[i-1][j]*isg[i][j-1]%P*sg[i-1][j-1]%P*in[g[i][j]]%P;
	}
	g[i][i]=i;
	sg[i][i]=(ll)sg[i][i-1]*sg[i][i-1]%P*isg[i-1][i-1]%P*i%P;
	isg[i][i]=(ll)isg[i][i-1]*isg[i][i-1]%P*sg[i-1][i-1]%P*in[i]%P;
}
```
---
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define be(a) a.begin()
#define en(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=1e5;
int P,fac[N+1],faci[N+1],in[N+1];
int sum(int a){return (ll)a*(a+1)/2%(P-1);}
int Pow(int a,int x){
	if(!a) return 0; int res=1;
	for(;x;a=(ll)a*a%P,x>>=1)if(x&1) res=(ll)res*a%P;
	return res;
}

//Sieve
const int K=2500;
bool np[N+1];
int mu[N+1],phi[N+1],cp,p[N];
int f[N+1],ivf[N+1],fii[N+1],ifii[N+1],dp[N+1],idp[N+1];
int g[K+1][K+1],sg[K+1][K+1],isg[K+1][K+1];
void Sieve(){
	np[1]=true,mu[1]=phi[1]=fii[0]=ifii[0]=dp[0]=idp[0]=f[0]=ivf[0]=in[1]=fac[0]=faci[0]=1;
	for(int i=2;i<=N;i++) in[i]=(ll)(P-P/i)*in[P%i]%P;
	for(int i=1;i<=N;i++) fac[i]=(ll)fac[i-1]*i%P,faci[i]=(ll)faci[i-1]*Pow(i,i)%P;
	for(int i=2;i<=N;i++){
		if(!np[i]) mu[i]=-1,phi[i]=i-1,p[cp++]=i;
		for(int j=0;j<cp&&i*p[j]<=N;j++){
			np[i*p[j]]=1;
			if(i%p[j]==0){mu[i*p[j]]=0,phi[i*p[j]]=phi[i]*p[j];break;}
			mu[i*p[j]]=mu[i]*mu[p[j]],phi[i*p[j]]=phi[i]*phi[p[j]];
		}
	}
	for(int i=1;i<=N;i++) f[i]=i,ivf[i]=in[i];
	for(int j=0;j<cp;j++)for(int i=N/p[j];i>=1;i--)
		f[i*p[j]]=(ll)f[i*p[j]]*ivf[i]%P,ivf[i*p[j]]=(ll)ivf[i*p[j]]*f[i]%P;
	for(int i=1;i<=N;i++){
		fii[i]=Pow(f[i],(ll)i*i%(P-1)),ifii[i]=Pow(ivf[i],(ll)i*i%(P-1));
		dp[i]=Pow(i,phi[i]%(P-1)),idp[i]=Pow(in[i],phi[i]%(P-1));
	}
	for(int i=2;i<=N;i++){
		f[i]=(ll)f[i]*f[i-1]%P,ivf[i]=(ll)ivf[i]*ivf[i-1]%P;
		fii[i]=(ll)fii[i]*fii[i-1]%P,ifii[i]=(ll)ifii[i]*ifii[i-1]%P;
		dp[i]=(ll)dp[i]*dp[i-1]%P,idp[i]=(ll)idp[i]*idp[i-1]%P;
		(phi[i]+=phi[i-1])%=(P-1);
	}
	for(int i=0;i<=K;i++) g[i][0]=g[0][i]=i,sg[i][0]=sg[0][i]=isg[i][0]=isg[0][i]=1;
	for(int i=1;i<=K;i++){
		for(int j=1;j<i;j++){
			g[i][j]=g[max(j,i-j)][min(j,i-j)];
			sg[i][j]=(ll)sg[i-1][j]*sg[i][j-1]%P*isg[i-1][j-1]%P*g[i][j]%P;
			isg[i][j]=(ll)isg[i-1][j]*isg[i][j-1]%P*sg[i-1][j-1]%P*in[g[i][j]]%P;
		}
		g[i][i]=i;
		sg[i][i]=(ll)sg[i][i-1]*sg[i][i-1]%P*isg[i-1][i-1]%P*i%P;
		isg[i][i]=(ll)isg[i][i-1]*isg[i][i-1]%P*sg[i-1][i-1]%P*in[i]%P;
	}
}

//Mobius
int ProdGcd(int a,int b){
	int res=1;
	if(a<=K&&b<=K) res=sg[max(a,b)][min(a,b)];
	else {
		for(int d=1,r;d<=min(a,b);d=r+1){
			r=min(a/(a/d),b/(b/d));
			res=(ll)res*Pow((ll)f[r]*ivf[d-1]%P,(ll)(a/d)*(b/d)%(P-1))%P;
		}
	}
	// cout<<"ProdGcd("<<a<<','<<b<<"):"<<res<<'\n';
	return res;
}
int Geti0(int a,int b,int c){
	int res=Pow(fac[a],(ll)b*c%(P-1));
	// cout<<"Geti0("<<a<<','<<b<<','<<c<<"):"<<res<<'\n';
	return res;
}
int Getg0(int a,int b,int c){
	int res=1;
	for(int d=1,r;d<=min(a,b);d=r+1){
		r=min(a/(a/d),b/(b/d));
		res=(ll)res*Pow((ll)f[r]*ivf[d-1]%P,(ll)(a/d)*(b/d)%(P-1))%P;
	}
	res=Pow(res,c%(P-1));
	// cout<<"Getg0("<<a<<','<<b<<','<<c<<"):"<<res<<'\n';
	return res;
}
int Geti1(int a,int b,int c){
	int res=Pow(faci[a],(ll)sum(b)*sum(c)%(P-1));
	// cout<<"Geti1("<<a<<','<<b<<','<<c<<"):"<<res<<'\n';
	return res;
}
int Getg1(int a,int b,int c){
	int res=1;
	for(int d=1,r;d<=min(a,b);d=r+1){
		r=min(a/(a/d),b/(b/d));
		res=(ll)res*Pow((ll)fii[r]*ifii[d-1]%P,(ll)sum(a/d)*sum(b/d)%(P-1))%P;
	}
	res=Pow(res,sum(c)%(P-1));
	// cout<<"Getg1("<<a<<','<<b<<','<<c<<"):"<<res<<'\n';
	return res;
}
int Geti2(int a,int b,int c){
	int res=1;
	for(int d=1,r;d<=min(a,min(b,c));d=r+1){
		r=min(a/(a/d),min(b/(b/d),c/(c/d)));
		res=(ll)res*Pow(fac[a/d],(ll)(b/d)*(c/d)%(P-1)*(phi[r]-phi[d-1]+P-1)%(P-1))%P;
		res=(ll)res*Pow((ll)dp[r]*idp[d-1]%P,(ll)(a/d)*(b/d)%(P-1)*(c/d)%(P-1))%P;
	}
	// cout<<"Geti2("<<a<<','<<b<<','<<c<<"):"<<res<<'\n';
	return res;
}
int Getg2(int a,int b,int c){
	int res=1;
	for(int d=1,r;d<=min(a,min(b,c));d=r+1){
		r=min(a/(a/d),min(b/(b/d),c/(c/d)));
		res=(ll)res*Pow(ProdGcd(a/d,b/d),(ll)(c/d)*(phi[r]-phi[d-1]+P-1)%(P-1))%P;
		res=(ll)res*Pow((ll)dp[r]*idp[d-1]%P,(ll)(a/d)*(b/d)%(P-1)*(c/d)%(P-1))%P;
	}
	// cout<<"Getg2("<<a<<','<<b<<','<<c<<"):"<<res<<'\n';
	return res;
}

//Main
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int cacnt; cin>>cacnt>>P;
	// clock_t start=clock();
	Sieve();//		cout<<f[2]<<'\n';
	while(cacnt--){
		int a,b,c,ans0,ans1,ans2;
		cin>>a>>b>>c;
		ans0=(ll)Geti0(a,b,c)*Geti0(b,a,c)%P*Pow(Getg0(a,b,c),P-2)%P*Pow(Getg0(a,c,b),P-2)%P;
		ans1=(ll)Geti1(a,b,c)*Geti1(b,a,c)%P*Pow(Getg1(a,b,c),P-2)%P*Pow(Getg1(a,c,b),P-2)%P;
		ans2=(ll)Geti2(a,b,c)*Geti2(b,a,c)%P*Pow(Getg2(a,b,c),P-2)%P*Pow(Getg2(a,c,b),P-2)%P;
		cout<<ans0<<' '<<ans1<<' '<<ans2<<'\n';
	}
	// clock_t end=clock();
	// cout<<db(end-start)/CLOCKS_PER_SEC<<'\n';
	return 0;
}

```
---
**祝大家学习愉快！**

---

## 作者：zimujun (赞：4)

### 写在前面

不愧莫反神仙题，忙活了加起来将近一天时间总算是把这道题 AC 了，真是学到了好多做这类题的一些基本的套路和方法，~~一道顶三道~~。

### 正文


求：

$$\Large\prod_{i = 1}^A\prod_{j = 1}^B\prod_{k = 1}^C\left(\dfrac{\operatorname{lcm}\left(i, j\right)}{\gcd\left(i, k\right)}\right)^{f\left(type\right)}$$

记 $f\left(type\right)$ 为 $p$，稍微转化一下式子

$$\Large\prod_{i = 1}^A\prod_{j = 1}^B\prod_{k = 1}^C\left(\dfrac{\operatorname{lcm}\left(i, j\right)}{\gcd\left(i, k\right)}\right)^{f\left(type\right)}$$

$$\Large=\prod_{i = 1}^A\prod_{j = 1}^B\prod_{k = 1}^C\left(\dfrac{ij}{\gcd\left(i, j\right)\gcd\left(i, k\right)}\right)^{f\left(type\right)}$$

$$\Large = \dfrac{\left(\prod_{i = 1}^A\prod_{j = 1}^B\prod_{k = 1}^Ci^p\right)\left(\prod_{i = 1}^B\prod_{j = 1}^A\prod_{k = 1}^Ci^p\right)}{\left(\prod_{i = 1}^A\prod_{j = 1}^B\prod_{k = 1}^C\gcd\left(i, j\right)\right)\left(\prod_{i = 1}^A\prod_{j = 1}^C\prod_{k = 1}^B\gcd\left(i, j\right)\right)}$$

因此可以转化为求解这两个问题，注意这里的 $a, b, c$ 不完全等同于原题中的 $A, B, C$。

$$\Large\prod_{i = 1} ^ a\prod_{j = 1} ^ b\prod_{k = 1} ^ c i^p$$
$$\Large \prod_{i = 1} ^ a\prod_{j = 1}^b\prod_{k = 1}^c\gcd\left(i,j\right)^p$$


（下文中默认 $a < b < c$，实际上对三者取个最小值做整除分块的上界即可。）

- $p = 1$

第一个式子

将无关的提到指数上去，有关的化为阶乘形式即可。

$$\Large\prod_{i = 1}^ a \prod_{j = 1} ^ b\prod_{k = 1} ^ c i$$

$$\Large=\left(a!\right)^{bc}$$

$$\Large\prod_{i = 1} ^  a\prod_{j = 1} ^ b\prod_{k = 1} ^ c\gcd\left(i, j\right)$$

第二个式子

同样是把无关的 $c$ 提到指数上去。

内部的式子，则又是一个非常经典的莫反模型，相信做到这道题的各位大佬们都很容易处理。

$$=\Large\left(\prod_{d = 1}^a d^{\sum_{i = 1}^a\sum_{j = 1}^b[\gcd\left(i, j\right) = d]}\right)^c$$

$$=\Large\left(\prod_{d = 1}^ad^{\sum_{t = 1}^{a / d} \mu\left(t\right)\lfloor\frac{a}{dt}\rfloor\lfloor\frac{b}{dt}\rfloor}\right)^c$$

$$\Large= \left(\prod_{T = 1}^ a\left(\prod_{d|T}d^{\mu\left(\frac{T}{d}\right)}\right)^{\lfloor\frac{a}{T}\rfloor\lfloor\frac{b}{T}\rfloor}\right)^c$$

内层括号里面是可以 $\mathcal O\left(n\log n\right)$ 预处理的。

具体实现就是类似埃氏筛，预处理逆元后枚举 $d$ 和倍数 $t$，然后把 $d^{\mu\left(t\right)}$ 乘到 $T$ 的答案上即可。

- $p = ijk$

（设 $s\left(n\right) = \sum_{i = 1}^n i =\frac{n\left(n + 1\right)}{2}$）

第一个式子

$$\Large\prod_{i = 1}^ a \prod_{j = 1} ^ b\prod_{k = 1} ^ c i^{ijk}$$

$$\Large= \left(\prod_{i = 1}^ai^i\right)^{s\left(b\right)s\left(c\right)}$$

第二个式子

把无关的 $c$ 提到指数上去，枚举 $\gcd\left(i,j\right)$ 时考虑其对答案的贡献，从而实现统计指数。

$$\Large\prod_{i = 1}^ a\prod_{j = 1}^b\prod_{k = 1}^c\gcd\left(i, j\right)^{ijk}$$

$$\Large= \left(\prod_{d = 1}^ad^{\sum_{i = 1}^a\sum_{j = 1} ^ b ij[\gcd\left(i, j\right) = d]}\right)^{s\left(c\right)}$$

$$\Large = \left(\prod_{d = 1}^a{d^{\sum_{i = 1}^{a / d}\sum_{j =1}^{b / d} d^2ij[\gcd\left(i, j\right) = 1]}}\right)^{s\left(c\right)}$$

$$\Large = \left(\prod_{d = 1}^a{d^{\sum_{t = 1}^{a / d}\mu\left(t\right)\left(td\right)^2s\left(\lfloor\frac{a}{dt}\rfloor\right)s\left(\lfloor\frac{b}{dt}\rfloor\right)}}\right)^{s\left(c\right)}$$

$$\Large = \left(\prod_{T = 1}^a\left(\prod_{d|T}d^{\mu\left(\frac{T}{d}\right)}\right)^{T^2s\left(\lfloor\frac{a}{T}\rfloor\right)s\left(\lfloor\frac{b}{T}\rfloor\right)}\right)^{s\left(c\right)}$$

同样，内层括号里面的式子可以 $O\left(n \log n\right)$ 预处理，这与上一部分所预处理的不同，需要将其结果乘上“下标的平方”次幂。

- $p = \gcd\left(i, j, k\right)$

第一个式子

$$\Large \prod_{i = 1}^a\prod_{j = 1}^b\prod_{k = 1}^ci^{\gcd\left(i, j, k\right)}$$

考虑枚举 $\gcd\left(i, j, k\right)$。

$$\Large= \prod_{d = 1}^a\prod_{i = 1}^a\prod_{j = 1}^b\prod_{k = 1}^ci^{d[\gcd\left(i, j, k\right) = d]}$$

$$\Large= \prod_{d = 1}^a\prod_{i = 1}^ai^{d\sum_{j = 1}^b\sum_{k = 1}^c[\gcd\left(i, j, k\right) = d]}$$

$$\Large= \prod_{d = 1}^a\prod_{i = 1}^{a / d}\left(id\right)^{d\sum_{j = 1}^{b / d}\sum_{k = 1}^{c / d}[\gcd\left(i, j, k\right) = 1]}$$

$$\Large = \prod_{d = 1}^a\prod_{i = 1}^{a / d}\left(id\right)^{d\sum_{j = 1}^{b / d}\sum_{k = 1}^{c / d}\sum_{t|\gcd\left(i, j, k\right)} \mu\left(t\right)}$$

$$\Large = \prod_{d = 1}^a\prod_{i = 1}^{a / dt}\left(idt\right)^{d\mu\left(t\right)\lfloor\frac{b}{dt}\rfloor\lfloor\frac{c}{dt}\rfloor}$$

$$\Large = \prod_{d = 1}^a\prod_{i = 1}^{a / dt}\left(idt\right)^{d\sum_{t = 1}^{a / d}\mu\left(t\right)\lfloor\frac{b}{dt}\rfloor\lfloor\frac{c}{dt}\rfloor}$$

$$\Large = \prod_{d = 1}^a\left(\prod_{i = 1}^{a / dt}\left(idt\right)\right)^{d\sum_{t = 1}^{a / d}\mu\left(t\right)\lfloor\frac{b}{dt}\rfloor\lfloor\frac{c}{dt}\rfloor}$$

（从这句话上面那个式子推到下面那个式子跨度可能比较大，实际上就是连乘号里面跟 $i$ 有关的化成阶乘，无关的提出来，提出来的时候要乘上“连乘的次数”次方）

$$\Large = \prod_{T = 1} ^ a \left(\prod_{d | T}\left(\lfloor\frac{a}{T}\rfloor\right)!T^{\lfloor\frac{a}{T}\rfloor}\right)^{d\mu\left(\frac{T}{d}\right)\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}$$

$$\Large = \prod_{T = 1} ^ a \left(\left(\lfloor\frac{a}{T}\rfloor\right)!T^{\lfloor\frac{a}{T}\rfloor}\right)^{\left(\sum_{d|T}d\mu\left(\frac{T}{d}\right)\right)\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}$$

$$\Large = \prod_{T = 1} ^ a \left(\left(\left(\lfloor\frac{a}{T}\rfloor\right)!T^{\lfloor\frac{a}{T}\rfloor}\right)^{\varphi\left(T\right)}\right)^{\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}$$

$$\Large = \prod_{T = 1} ^ a \left(\left(\left(\lfloor\frac{a}{T}\rfloor\right)!\right)^{\varphi\left(T\right)}\right)^{\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}\prod_{T = 1}^aT^{\varphi\left(T\right)\lfloor\frac{a}{T}\rfloor\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}$$


这里把前面单独拿出来作为第三部分第一个式子的结果。因为后面的那个式子在接下来的过程中可以约掉，具体请看接下来的证明。

所以我们要求的是这个

$$\Large  \prod_{T = 1} ^ a \left(\left(\left(\lfloor\frac{a}{T}\rfloor\right)!\right)^{\varphi\left(T\right)}\right)^{\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}$$

第二个式子

$$\Large\prod_{i = 1}^a\prod_{j = 1}^b\prod_{k = 1}^c\gcd\left(i, j\right)^{\gcd\left(i, j, k\right)}$$

$$\Large=\prod_{d = 1}^a\prod_{i = 1}^{a}\prod_{j = 1}^{b}\left(d\gcd\left(i, j\right)\right)^{d\sum_{k = 1}^{c}[\gcd\left(i, j, k\right) = d]}$$

$$\Large=\prod_{d = 1}^a\prod_{i = 1}^{a/d}\prod_{j = 1}^{b/d}\left(d\gcd\left(i, j\right)\right)^{d\sum_{k = 1}^{c/d}\sum_{t|\gcd\left(i, j, k\right)}\mu\left(t\right)}$$

$$\Large=\prod_{d = 1}^a\prod_{t = 1}^{a / d}\prod_{i = 1}^{a/dt}\prod_{j = 1}^{b/dt}\left(dt\gcd\left(i, j\right)\right)^{d\mu\left(t\right)\lfloor\frac{c}{dt}\rfloor}$$

$$\Large=\prod_{d = 1}^a\prod_{t = 1}^{a / d}\prod_{i = 1}^{a/dt}\prod_{j = 1}^{b/dt}\left(\gcd\left(i, j\right)\right)^{d\mu\left(t\right)\lfloor\frac{c}{dt}\rfloor}\prod_{T = 1}^aT^{\varphi\left(T\right)\lfloor\frac{a}{T}\rfloor\lfloor\frac{b}{T}\rfloor\lfloor\frac{c}{T}\rfloor}$$

后面那部分发现在计算的时候正好可以和分子上约掉。考虑单独计算前面那部分

$$\Large=\prod_{d = 1}^a\prod_{t = 1}^{a / d}\prod_{i = 1}^{a/dt}\prod_{j = 1}^{b/dt}\left(\gcd\left(i, j\right)\right)^{d\mu\left(t\right)\lfloor\frac{c}{dt}\rfloor}$$

$$\Large = \prod_{r = 1}^a r^{\sum_{d = 1}^ad\sum_{t = 1}^{a / d}\mu\left(t\right)\lfloor\frac{c}{dt}\rfloor\sum_{i = 1}^{a/dt}\sum_{j = 1}^{b/dt}[\gcd\left(i, j\right) = r]}$$

$$\Large = \prod_{r = 1}^a \prod_{d = 1}^ar^{d\sum_{t = 1}^{a / d}\mu\left(t\right)\sum_{t_1 = 1}^{a / r}\mu\left(t_1\right)\lfloor\frac{a}{dtrt_1}\rfloor\lfloor\frac{b}{dtrt_1}\rfloor\lfloor\frac{c}{dt}\rfloor}$$

$$\Large = \prod_{T = 1}^a\prod_{T_1 = 1}^a\left(\prod_{r | T_1}r^{\mu\left(\frac{T_1}{r}\right)}\right)^{\left(\sum_{d|T}d\mu\left(\frac{T}{d}\right)\right)\lfloor\frac{a}{TT_1}\rfloor\lfloor\frac{b}{TT_1}\rfloor\lfloor\frac{c}{T}\rfloor}$$

$$\Large = \prod_{T = 1}^a\prod_{T_1 = 1}^a\left(\prod_{r | T_1}r^{\mu\left(\frac{T_1}{r}\right)}\right)^{\varphi\left(T\right)\lfloor\frac{a}{TT_1}\rfloor\lfloor\frac{b}{TT_1}\rfloor\lfloor\frac{c}{T}\rfloor}$$

好了，到此为止了，总结一下需要处理的东西，以为我们编写代码提供方便。

- $\varphi,\mu$。
- 阶乘。（$1.1$ 和 $3.1$）
- $\varphi$ 函数在模 $p - 1$ 意义下的前缀和。（$3.1$）
- $i^i$ 及前缀积。（$2.1$）
- $\prod_{d|T}d^{\mu\left(\frac{T}{d}\right)}$ 及其下标的平方次幂和前缀积。（$1.2$ 和 $2.2$ 和 $3.2$）
- $s\left(n\right) = \dfrac{n\left(n + 1\right)}{2}$。（$2.1$ 和 $2.2$）
- 凡是需要计算前缀积的，还需要倒推逆元前缀积。

### Tips

在大量计算代码的编写时一定要注意随时取模，并尤其要注意减法取模和指数取模。

在做巨大码量的题目时，尤其是像这种多合一的题目时，一定要理清思路，代码要尽可能有条理。

### Code

```cpp
#include <bits/stdc++.h>

#define LL long long

using namespace std;
 
namespace I {
	template <typename Temp> inline void read(Temp & res) {
		Temp fh = 1; res = 0; char ch = getchar();
		for(; !isdigit(ch); ch = getchar()) if(ch == '-') fh = -1;
		for(; isdigit(ch); ch = getchar()) res = (res << 3) + (res << 1) + (ch ^ '0');
		res = res * fh;
	}
}
 
const int Maxn = 1e5 + 5;

int T, n, A, B, C; LL Mod = 1;

namespace M {
	#define N 100000
	inline LL qpow(LL a_qp, LL p_qp) {
		LL res = 1;
		while(p_qp) {
			if(p_qp & 1) res = res * a_qp % Mod;
			a_qp = a_qp * a_qp % Mod;
			p_qp >>= 1; 
		}
		return res;
	}
	
	int prime[Maxn], cnt_pri; LL phi[Maxn], mu[Maxn]; bool isprime[Maxn];
	void sieve() {
		phi[1] = mu[1] = 1;
		for(int i = 2; i <= N; ++i) {
			if(!isprime[i]) {
				prime[++cnt_pri] = i;
				phi[i] = i - 1; mu[i] = -1;
			}
			for(int j = 1; j <= cnt_pri && prime[j] <= N / i; ++j) {
				int cur = i * prime[j];
				isprime[cur] = 1;
				if(i % prime[j] == 0) {
					phi[cur] = phi[i] * prime[j];
					mu[cur] = 0; break;
				} else {
					phi[cur] = phi[i] * (prime[j] - 1);
					mu[cur] = -mu[i]; 
				}
			}
		} 
	}
	
	LL fac[Maxn], invf[Maxn], inv[Maxn];
	void getinv() {
		fac[0] = 1; inv[0] = 1;
		for(int i = 1; i <= N; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;
		invf[N] = qpow(fac[N], Mod - 2);
		for(int i = N - 1; i >= 0; --i) invf[i] = 1ll * invf[i + 1] * (i + 1) % Mod;
		for(int i = 1; i <= N; ++i) inv[i] = invf[i] * fac[i - 1] % Mod; 
	}
	
	LL s(int n_s) {
		return 1ll * n_s * (n_s + 1) / 2 % (Mod - 1);
	}
	
	LL sphi[Maxn]/*Mod by (p - 1)*/, f[Maxn], ftp[Maxn], ip[Maxn], fip[Maxn];/*prod d^mu(T/d), i^i and its prefix*/
	LL ffac[Maxn], ftpfac[Maxn], finvf[Maxn], ftpinvf[Maxn], finv[Maxn], ftpinv[Maxn];
	//fac of f, fac of f^(T^2), fac_inv of f, fac_inv of f^(T^2), inv of f, inv of f^(T^2)
	void Init() {
		sieve(); getinv(); fip[0] = 1; finv[0] = ftpinv[0] = 1;
		for(int i = 1; i <= N; ++i) ip[i] = qpow((LL)i, (LL)i), fip[i] = fip[i - 1] * ip[i] % Mod;
		for(int i = 1; i <= N; ++i) sphi[i] = (sphi[i - 1] + phi[i]) % (Mod - 1);
		for(int i = 1; i <= N; ++i) f[i] = 1;
		for(int d = 1; d <= N; ++d) {
			for(int t = 1; t <= N / d; ++t) {
				if(mu[t] == -1) f[d * t] = f[d * t] * inv[d] % Mod;
				else if(mu[t] == 1) f[d * t] = f[d * t] * d % Mod; 
			}
		}
		for(int i = 1; i <= N; ++i) ftp[i] = qpow(f[i], 1ll * i * i % (Mod - 1)) % Mod;
		ffac[0] = ftpfac[0] = 1;
		for(int i = 1; i <= N; ++i) ffac[i] = ffac[i - 1] * f[i] % Mod,
		ftpfac[i] = ftpfac[i - 1] * ftp[i] % Mod;
		finvf[N] = qpow(ffac[N], Mod - 2); ftpinvf[N] = qpow(ftpfac[N], Mod - 2);
		for(int i = N - 1; i >= 0; --i) finvf[i] = finvf[i + 1] * f[i + 1] % Mod,
		ftpinvf[i] = ftpinvf[i + 1] * ftp[i + 1] % Mod;
		for(int i = 1; i <= N; ++i) finv[i] = finvf[i] * ffac[i - 1] % Mod,
		ftpinv[i] = ftpinvf[i] * ftpfac[i - 1] % Mod;
	}
	#undef N
}

namespace ANS {
	using namespace M;
	LL A1(int a, int b, int c) {
		return qpow(fac[a], 1ll * b * c % (Mod - 1));
	}
	LL A2(int a, int b, int c) {
		LL res = 1;
		if(a > b) swap(a, b);
		for(int l = 1, r = 1; l <= a; l = r + 1) {
			r = min(a / (a / l), b / (b / l)); r = min(r, a);
			res = res * qpow(ffac[r] * finvf[l - 1] % Mod, 1ll * (a / l) * (b / l) % (Mod - 1)) % Mod;
		}
		return qpow(res, (LL)c);
	}
	LL B1(int a, int b, int c) {
		return qpow(fip[a], s(b) % (Mod - 1) * (s(c) % (Mod - 1)) % (Mod - 1));
	}
	LL B2(int a, int b, int c) {
		LL res = 1;
		if(a > b) swap(a, b);
		for(int l = 1, r = 1; l <= a; l = r + 1) {
			r = min(a / (a / l), b / (b / l)); r = min(r, a);
			res = res * qpow(ftpfac[r] * ftpinvf[l - 1] % Mod, s(a / l) * s(b / l) % (Mod - 1)) % Mod;
		}
		return qpow(res, s(c) % (Mod - 1));
	}
	LL C1(int a, int b, int c) {
		int m = min(a, min(b, c)); LL res = 1;
		for(int l = 1, r = 1; l <= m; l = r + 1) {
			r = min(a / (a / l), min(b / (b / l), c / (c / l)));
			LL cur = qpow(fac[a / l], 1ll * (b / l) * (c / l) % (Mod - 1));
			res = res * qpow(cur, ((sphi[r] - sphi[l - 1]) % (Mod - 1) + (Mod - 1)) % (Mod - 1)) % Mod; 
		}
		return res;
	}
	LL C2_0(int a, int b) {
		LL res = 1;
  	for (int l = 1, r = 1; l <= min(a, b); l = r + 1) {
    	r = min(a / (a / l), b / (b / l));
    	res = res * qpow(ffac[r] * finvf[l - 1] % Mod, 1ll * (a / l) * (b / l) % (Mod - 1)) % Mod;
  	}
  	return res;
	} 
	LL C2(int a, int b, int c) {
		int m = min(a, min(b, c)); LL res = 1;
		for(int l = 1, r = 1; l <= m; l = r + 1) {
			r = min(a / (a / l), min(b / (b / l), c / (c / l)));
			LL cur = qpow(C2_0(a / l, b / l), 1ll * (c / l));
			res = res * qpow(cur, ((sphi[r] - sphi[l - 1]) % (Mod - 1) + (Mod - 1)) % (Mod - 1)) % Mod;
		}
		return res;
	}
	LL Solve(int a, int b, int c, int type) {
		if(type == 0) {
			return 1ll * A1(a, b, c) * A1(b, a, c) % Mod * qpow(A2(a, b, c) * A2(a, c, b) % Mod, Mod - 2) % Mod;
		} else if(type == 1) {
			return 1ll * B1(a, b, c) * B1(b, a, c) % Mod * qpow(B2(a, b, c) * B2(a, c, b) % Mod, Mod - 2) % Mod;
		} else {
			return 1ll * C1(a, b, c) * C1(b, a, c) % Mod * qpow(C2(a, b, c) * C2(a, c, b) % Mod, Mod - 2) % Mod;
		}
	}
}

int main() {
	using namespace I;
	read(T); read(Mod); M::Init();
	while(T--) {
		read(A); read(B); read(C);
		for(int i = 0; i <= 2; ++i) printf("%lld ", ANS::Solve(A, B, C, i));
		printf("\n");
	}
	return 0;
}
```

---

## 作者：金珂拉 (赞：3)

**学习车万的最好方法就是**

A了这道题。（大雾）

![](https://cdn.luogu.com.cn/upload/image_hosting/5bp94xos.png)

这题真毒瘤，式子推了我整整一个下午。

~~不愧是冥界的乐团，做完这题我也快去冥界了~~

## 前置知识

欧拉反演、莫比乌斯反演。

简单来说就是这两个式子：

$$
n=\sum_{p|n}\varphi(p)
$$

$$
[n==1]=\sum_{d|n}\mu(p)
$$

## 推式子环节

前方精神污染警告

首先我们先化简一下这个式子

$$
\prod_i^A\prod_j^B\prod_k^C(\frac{\operatorname{lcm}(i,j)}{\gcd(i,k)})^{f(tp)}
$$

$$
\prod_i^A\prod_j^B\prod_k^C(\frac{ij}{\gcd(i,k)\gcd(i,j)})^{f(tp)}
$$

于是可以对分子与分母分别处理了。

## $tp=0$

### $f_{01}$

$$
\prod_i^A\prod_j^B\prod_k^Ci
$$

$$
(A!)^{BC}
$$

预处理阶乘，送走。

### $f_{02}$

$$
\prod_i^A\prod_j^B\prod_k^C\gcd(i,j)
$$

$$
(\prod_i^A\prod_j^B\gcd(i,j))^C
$$

是经典模型，反演即可。

$$
(\prod_dd^{\sum_k\mu(k)\frac{A}{dk}\frac{B}{dk}})^C
$$

经典套路设 $T=dk$

$$
(\prod_T(\prod_{d|T}d^{\mu(T/d)})^{\frac{A}{T}\frac{B}{T}})^C
$$

埃式筛预处里内层括号，整数分块送走。

## $tp=1$

### $f_{11}$

$$
\prod_i^A\prod_j^B\prod_k^Ci^{ijk}
$$

$$
\prod_i^Ai^{i\sum_j^Bj\sum_k^Ck}
$$

$$
(\prod_i^Ai^{i})^{B(B+1)C(C+1)/4}
$$

预处理 $i^i$ 的前缀积，直接送走。

### $f_{12}$

$$
\prod_i^A\prod_j^B\prod_k^C\gcd(i,j)^{ijk}
$$

$$
(\prod_i^A\prod_j^B\gcd(i,j)^{ij})^{C(C+1)/2}
$$

然后经典套路

$$
(\prod_dd^{\sum\mu(k)d^2k^2(\frac{A}{dk})(\frac{A}{dk}+1)(\frac{B}{dk})(\frac{B}{dk}+1)/4})^{C(C+1)/2}
$$

然后接着提出 $T$

$$
(\prod_T(\prod_{d|T}d^{\mu(T/d)})^{T^2(\frac{A}{T})(\frac{A}{T}+1)(\frac{B}{T})/4(\frac{B}{T}+1)})^{C(C+1)/2}
$$

预处理 $(\prod_{d|T}d^{\mu(T/d)})^{T^2}$ 的前缀积，整数分块送走。

## $tp=2$

### $f_{21}$

$$
\prod_i^A\prod_j^B\prod_k^Ci^{\gcd(i,j,k)}
$$

$$
\prod_i^Ai^{\sum_j^B\sum_k^C\gcd(i,j,k)}
$$

先看上面那个玩意

$$
\sum_j^B\sum_k^C\gcd(i,j,k)
$$

明显的是一个欧拉反演。

$$
\sum_j^B\sum_k^C\sum_{d|\gcd(i,j,k)}\varphi(d)
$$

$$
\sum_{d|i}\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor
$$

回代。

$$
\prod_i^Ai^{\sum_{d|i}\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}
$$

$$
\prod_i^A\prod_{d|i}i^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}
$$

$$
\prod_d\prod_i^{\frac{A}{d}}i^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}d^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}
$$

$$
\prod_dd^{\varphi(d)\lfloor\frac{A}{d}\rfloor\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}(\prod_i^{\frac{A}{d}}i)^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}
$$

$$
\prod_dd^{\varphi(d)\lfloor\frac{A}{d}\rfloor\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}((\frac{A}{d})!)^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor}
$$

$$
(\prod_dd^{\varphi(d)\lfloor\frac{A}{d}\rfloor\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor})(\prod_d((\frac{A}{d})!)^{\varphi(d)\lfloor\frac{B}{d}\rfloor\lfloor\frac{C}{d}\rfloor})
$$

前半部分预处理 $d^{\varphi(d)}$ 的前缀积，后半部分预处理出 $\varphi(d)$ 的前缀和，分别进行整数分块，送走。

### $f_{22}$

$$
\prod_i^A\prod_j^B\prod_k^C\gcd(i,j)^{gcd(i,j,k)}
$$


看到 $\gcd$ 在指数上果断欧拉反演。

$$
\prod_i^A\prod_j^B\prod_k^C\gcd(i,j)^{\sum_{p|gcd(i,j,k)}\varphi(p)}
$$

$$
\prod_i^A\prod_j^B\prod_{p|gcd(i,j)}\gcd(i,j)^{\lfloor\frac{C}{p}\rfloor\varphi(p)}
$$

$$
\prod_p\prod_i^{\frac{A}{p}}\prod_j^{\frac{B}{p}}(p\gcd(i,j))^{\lfloor\frac{C}{p}\rfloor\varphi(p)}
$$

然后拆了它。

$$
(\prod_p(p^{\varphi(p)})^{\lfloor\frac{A}{p}\rfloor\lfloor\frac{B}{p}\rfloor\lfloor\frac{C}{p}\rfloor})(\prod_p\prod_i^{\frac{A}{p}}\prod_j^{\frac{B}{p}}\gcd(i,j)^{\lfloor\frac{C}{p}\rfloor\varphi(p)})
$$

发现右边那坨东西很熟悉，左边那坨东西也很熟悉，都是之前求过的东西。

$$
f_{211}(A,B,C)(\prod_pf_{02}(\lfloor\frac{A}{p}\rfloor,\lfloor\frac{B}{p}\rfloor,\lfloor\frac{C}{p}\rfloor)^{\varphi(p)})
$$

然后就接着整数分块，送走。（后面那坨东西因为有嵌套所以复杂度有点难求，但其实是可以过的）

## 代码

代码中 `solvep` 表示 $f_p$, `initp` 和 `invp` 表示为了求 `solvep` 而预处理的东西以及逆元。（部分有实际意义的直接用英文表示）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int mod;
int qpow(int a, int n) {
    int res=1;
    while (n > 0) {
        if (n & 1){
            res = res * a % mod;
        }
        n >>= 1;
        a = (a * a) % mod;
    }
    return res%mod;
}
int fac[100003],facinv[100003],init02[100003],inv02[100003],ans;
int init11[100003],init12[100003],inv12[100003];
int mu[100003],phi[100003];
bool vis[100003];
int prime[100003],cnt;
int sumphi[100003],init211[100003],inv211[100003];
void init(int n){
	fac[0]=1;
	facinv[0]=1;
	init11[0]=1;
	for(int i=1;i<=n;i++)
	fac[i]=fac[i-1]*i%mod,init11[i]=init11[i-1]*qpow(i,i)%mod;
	facinv[n]=qpow(fac[n],mod-2);
	for(int i=n-1;i;i--) facinv[i]=facinv[i+1]*(i+1)%mod;
	mu[1]=1;
	phi[1]=1;
    for(int i=2; i<=n; ++i) {
        if(!vis[i]) prime[++cnt]=i,phi[i]=(i-1)%mod,mu[i]=-1;
        for(int j=1; j<=cnt&&i*prime[j]<=n; j++) {
            vis[i*prime[j]]=1;
            if(i%prime[j]==0){mu[i*prime[j]]=0;phi[i*prime[j]]=phi[i]*prime[j]%(mod-1);break;} 
            mu[i*prime[j]]=mu[i]*mu[prime[j]];
            phi[i*prime[j]]=phi[i]*phi[prime[j]]%(mod-1);
        }
    } 
    for(int i=1;i<=n;i++) init02[i]=1;
    for(int i=1;i<=n;i++)
    for(int j=1;j*i<=n;j++)
    init02[j*i]=init02[j*i]*(mu[j]==1?i:mu[j]==0?1:qpow(i,mod-2))%mod;
    inv02[n]=1;
    for(int i=1;i<=n;i++) inv02[n]=inv02[n]*init02[i]%mod,init12[i]=qpow(init02[i],i*i%(mod-1));
	inv12[0]=1;
    init12[0]=1;
    for(int i=1;i<=n;i++) init12[i]=init12[i]*init12[i-1]%mod,inv12[i]=qpow(init12[i],mod-2);
    inv02[n]=qpow(inv02[n],mod-2);
	init02[0]=1;
    inv02[0]=1;
    for(int i=n-1;i;i--) inv02[i]=inv02[i+1]*init02[i+1]%mod;
    for(int i=1;i<=n;i++) init02[i]=init02[i-1]*init02[i]%mod;
    for(int i=1;i<=n;i++) sumphi[i]=(sumphi[i-1]+phi[i])%(mod-1);
    init211[0]=inv211[0]=1;
    for(int i=1;i<=n;i++) init211[i]=init211[i-1]*qpow(i,phi[i])%mod,inv211[i]=qpow(init211[i],mod-2);
}
int solve01(int a,int b,int c){
	int ans=qpow(fac[a],b*c%(mod-1));
	return ans;
}
int solve02(int a,int b,int c){
	int ans=1,r;
	for(int l=1;l<=a && l<=b;l=r+1){
		r=min(a/(a/l),b/(b/l));
		ans=ans*qpow(init02[r]*inv02[l-1]%mod,(a/l)*(b/l)%(mod-1))%mod;
	}
	ans=qpow(ans,c);
	return ans;
}
int solve0(int a,int b,int c){
	return solve01(a,b,c)%mod*solve01(b,a,c)%mod*qpow(solve02(a,b,c),mod-2)%mod*qpow(solve02(a,c,b),mod-2)%mod;
}
int solve11(int a,int b,int c){
	return qpow(init11[a],(b*(b+1)/2)%(mod-1)*((c*(c+1)/2)%(mod-1))%(mod-1));
}
int solve12(int a,int b,int c){
	int ans=1,r;
	for(int l=1;l<=a && l<=b;l=r+1){
		r=min(a/(a/l),b/(b/l));
		ans=ans*qpow(init12[r]*inv12[l-1]%mod,(a/l)*(a/l+1)/2%(mod-1)*((b/l)*(b/l+1)/2%(mod-1))%(mod-1))%mod;
	}
	ans=qpow(ans,c*(c+1)/2%(mod-1));
	return ans;
}
int solve1(int a,int b,int c){
	return solve11(a,b,c)%mod*solve11(b,a,c)%mod*qpow(solve12(a,b,c),mod-2)%mod*qpow(solve12(a,c,b),mod-2)%mod;
}
int solve211(int a,int b,int c){
	int ans=1,r;
	for(int l=1;l<=a && l<=b && l<=c;l=r+1){
		r=min(c/(c/l),min(a/(a/l),b/(b/l)));
		ans=ans*qpow(init211[r]*inv211[l-1]%mod,(a/l)*(b/l)%(mod-1)*(c/l)%(mod-1))%mod;
	}
	return ans;
}
int solve212(int a,int b,int c){
	int ans=1,r;
	for(int l=1;l<=b && l<=c && l<=a;l=r+1){
		r=min(a/(a/l),min(c/(c/l),b/(b/l)));
		ans=ans*qpow(fac[a/l],(b/l)*(c/l)%(mod-1)*(((sumphi[r]-sumphi[l-1])%(mod-1)+mod-1)%(mod-1))%(mod-1))%mod;
	}
	return ans;
}
int solve21(int a,int b,int c){
	return solve211(a,b,c)%mod*solve212(a,b,c)%mod;
}
int solve221(int a,int b,int c){
	return solve211(a,b,c);
}
int solve222(int a,int b,int c){
	int ans=1,r;
	for(int l=1;l<=a && l<=b && l<=c;l=r+1){
		r=min(c/(c/l),min(a/(a/l),b/(b/l)));
		ans=ans*qpow(solve02(a/l,b/l,c/l)%mod,((sumphi[r]-sumphi[l-1])%(mod-1)+mod-1)%(mod-1))%mod;
	}
	return ans%mod;
}
int solve22(int a,int b,int c){
	return solve221(a,b,c)%mod*solve222(a,b,c)%mod;
}
int solve2(int a,int b,int c){
	return solve21(a,b,c)%mod*solve21(b,a,c)%mod*qpow(solve22(a,b,c),mod-2)%mod*qpow(solve22(a,c,b),mod-2)%mod;
}
signed main(){
	int T;
	cin>>T>>mod;
	init(100000);
	while(T--){
	int A,B,C;
	scanf("%lld%lld%lld",&A,&B,&C);
	printf("%lld %lld %lld\n",solve0(A,B,C),solve1(A,B,C),solve2(A,B,C));
	}
} 
```


---

## 作者：tzc_wk (赞：2)

upd on 2021.8.7：修了个公式的问题

[洛谷题面传送门](https://www.luogu.com.cn/problem/P5518)

[如果 Latex 炸了就到这里查看](https://www.cnblogs.com/ET2006/p/luogu-P5518.html)

一道究极恶心的毒瘤六合一题，式子推了我满满两面 A4 纸……

首先我们可以将式子拆成：

$$
ans=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C(\dfrac{ij}{\gcd(i,j)\gcd(i,j)})^{f(type)}
$$

也就是说我们需要算出以下四项式子的值：

$$
\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{f(type)}
$$

$$
\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Cj^{f(type)}
$$

$$
\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C(\dfrac{1}{\gcd(i,j)})^{f(type)}
$$

$$
\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C(\dfrac{1}{\gcd(i,k)})^{f(type)}
$$

显然前两项与后两项是等价的，因此我们只需算出：

$$
f_1(type)=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{f(type)}
$$

与

$$
f_2(type)=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C(\gcd(i,j))^{f(type)}
$$

即可求出答案。

---

考虑对 $type$ 进行分类讨论，首先是 $type=0$，那么

$$
f_1(0)=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci
$$

考虑每个 $i$ 的贡献，稍微想想即可得到：

$$
f_1(0)=(A!)^{BC}
$$

然后是 $f_2(0)$，套路地枚举 $\gcd(i,j)$ 有

$$
\begin{aligned}
f_2(0)&=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,j)\\
&=(\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^A\sum\limits_{j=1}^B[\gcd(i,j)=d]})^C\\
&=(\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{A/d}\sum\limits_{j=1}^{B/d}[\gcd(i,j)=1]})^C\\
&=(\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{p}\mu(p)\lfloor\frac{A}{dp}\rfloor\lfloor\frac{B}{dp}\rfloor})^C\\
\end{aligned}
$$

最右边那个 $k$ 次方显然可以忽略掉不管它，最后求个快速幂即可。考虑对里面的 $dp$ 进行二维的整除分块，那么答案的式子可以化为：

$$
\begin{aligned}
f_2(0)=(\prod\limits_{dp}g_1(dp)^{\lfloor\frac{A}{dp}\rfloor\lfloor\frac{B}{dp}\rfloor})^C
\end{aligned}
$$

其中

$$
g_1(x)=\prod\limits_{d·p=x}d^{\mu(p)}
$$

考虑整除分块，对于一段区间 $[L,R]$，满足 $\forall x\in[L,R]$ 均有 $\lfloor\dfrac{A}{x}\rfloor=\lfloor\dfrac{A}{L}\rfloor,\lfloor\dfrac{B}{x}\rfloor=\lfloor\dfrac{B}{L}\rfloor$，我们这样计算它们的贡献：

$$
\prod\limits_{i=L}^R(g_1(i)^{\lfloor\frac{A}{i}\rfloor\lfloor\frac{B}{i}\rfloor})^C=(\prod\limits_{i=L}^Rg_1(i))^{\lfloor\frac{A}{i}\rfloor\lfloor\frac{B}{i}\rfloor·C}
$$

预处理前缀积即可 $\mathcal O(1)$ 计算，时间复杂度 $\mathcal O(\log n\sqrt{n})$。

---

接下来是 $type=1$ 的情况，个人感觉与 $type=0$ 的情况大差不差，毕竟指数上都只与 $i,j,k$ 本身而不涉及到它们的 $\gcd$ 之类，只不过指数上枚举变量的次数稍微高了一点点，导致情况较于 $type=0$ 略有一点点繁琐。

首先是 $f_1(1)$

$$
f_1(1)=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{ijk}
$$

还是考虑每个 $i$ 的贡献被累计了多少次：

$$
\begin{aligned}
f_1(0)&=(A!)^{\sum\limits_{j=1}^B\sum\limits_{k=1}^Cjk}\\
&=(A!)^{\frac{B(B+1)}{2}·\frac{C(C+1)}{2}}
\end{aligned}
$$

一波快速幂带走。

其次是 $f_2(1)$

$$
\begin{aligned}
f_2(1)&=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C\gcd(i,j)^{ijk}\\
&=(\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^A\sum\limits_{j=1}^Bij[\gcd(i,j)=d]})^{\sum\limits_{k=1}^Ck}\\
&=(\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{A/d}\sum\limits_{j=1}^{B/d}ijd^2[\gcd(i,j)=1]})^{\frac{C(C+1)}{2}}\\
&=(\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{p}\mu(p)d^2p^2·s(\lfloor\frac{A}{dp}\rfloor)s(\lfloor\frac{B}{dp}\rfloor)})^{\frac{C(C+1)}{2}}\\
\end{aligned}
$$

其中 $s(i)=\dfrac{i(i+1)}{2}$

那么我们还是枚举 $dp$，按照 $f_2(0)$ 的套路设一个 $g_2(x)$，定义如下：

$$
g_2(x)=\prod\limits_{d·p=x}d^{d^2p^2\mu(p)}
$$

那么考虑对 $dp$ 进行整除分块，那么

$$
f_2(1)=(\prod\limits_{dp=1}^{\min(A,B)}g_2(dp)^{s(\lfloor\frac{A}{dp}\rfloor)s(\lfloor\frac{B}{dp}\rfloor)})^{\frac{C(C+1)}{2}}
$$

预处理 $g_2(dp)$ 的前缀积然后对 $dp$ 整除分块即可。

---

最后是 $type=2$ 的情况

先考虑 $f_1(2)$

$$
f_1(2)=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^Ci^{\gcd(i,j,k)}
$$

上来先把 $\gcd$ 反演掉：

$$
\begin{aligned}
f_1(2)&=\prod\limits_{d=1}^{\min(A,B,C)}\prod\limits_{i=1}^{\lfloor\frac{A}{d}\rfloor}(id)^{d·\sum\limits_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum\limits_{k=1}^{\lfloor\frac{C}{d}\rfloor}[\gcd(i,j,k)=1]}\\
&=\prod\limits_{d=1}^{\min(A,B,C)}\prod\limits_{i=1}^{\lfloor\frac{A}{d}\rfloor}(id)^{d·\sum\limits_{p\mid i}\mu(p)\lfloor\frac{B}{dp}\rfloor\lfloor\frac{C}{dp}\rfloor}
\end{aligned}
$$

把 $p$ 提到外面来

$$
\begin{aligned}
f_1(2)&=\prod\limits_{d=1}^{\min(A,B,C)}\prod\limits_{p}(\prod\limits_{i\in[1,\lfloor\frac{A}{d}\rfloor]\&p\mid i}(id)^{d·\mu(p)})^{\lfloor\frac{B}{dp}\rfloor\lfloor\frac{C}{dp}\rfloor}
\end{aligned}
$$

然后按照套路枚举 $\dfrac{i}{p}$

$$
\begin{aligned}
f_1(2)&=\prod\limits_{d=1}^{\min(A,B,C)}\prod\limits_{p}(\prod\limits_{i=1}^{\lfloor\frac{A}{dp}\rfloor}(idp)^{d·\mu(p)})^{\lfloor\frac{B}{dp}\rfloor\lfloor\frac{C}{dp}\rfloor}
\end{aligned}
$$

然后枚举 $dp$，根据 $\mu*i=\varphi$ 可知 $\sum\limits_{d·p=x}d·\mu(p)=\varphi(x)$，于是

$$
f_1(2)=\prod\limits_{x=1}^{\min(A,B,C)}(\prod\limits_{i=1}^{\lfloor\frac{A}{x}\rfloor}(ix)^{\varphi(x)})^{\lfloor\frac{B}{x}\rfloor\lfloor\frac{C}{x}\rfloor}
$$

外面的东西显然整除分块一下就好了，里面的东西

$$
\prod\limits_{i=1}^{\lfloor\frac{A}{x}\rfloor}(ix)^{\varphi(x)}
$$

显然等于

$$
\begin{aligned}
&\prod\limits_{i=1}^{\lfloor\frac{A}{x}\rfloor}i^{\varphi(x)}·x^{\varphi(x)}\\
=&((\lfloor\dfrac{A}{x}\rfloor)!)^{\varphi(x)}·(x^{\varphi(x)})^{\lfloor\frac{A}{x}\rfloor}
\end{aligned}
$$

然后套路地预处理 $g_3=x^{\varphi(x)}$ 的前缀积，以及 $\varphi(x)$ 的前缀和即可在整除分块的过程中 $\mathcal O(1)$ 求出式子的值，注意 $\varphi(x)$ 的前缀和应 $\bmod(MOD-1)$ 而不是 $\bmod MOD$，因为 $\varphi(x)$ 的前缀和作用在指数上。

时间复杂度 $\sqrt{n}\log n$

然后是最精神污染的一个式子：

$$
f_2(2)=\prod\limits_{i=1}^A\prod\limits_{j=1}^B\prod\limits_{k=1}^C(\gcd(i,j))^{\gcd(i,j,k)}
$$

按照 P1587 的套路，碰到两个 $\gcd$ 咱们最好不要莽，要一个个反演，因此考虑先反演下面这个 $\gcd$：

$$
\begin{aligned}
f_2(2)&=\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{B}{d}\rfloor}[\gcd(i,j)=1]\sum\limits_{k=1}^C\gcd(d,k)}\\
&=\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{p}^{\lfloor\frac{\min(A,B)}{d}\rfloor}\mu(p)\lfloor\frac{A}{dp}\rfloor\lfloor\frac{B}{dp}\rfloor\sum\limits_{k=1}^C\gcd(d,k)}
\end{aligned}
$$

发现后面有个 $\sum\limits_{k=1}^C\gcd(d,k)$，考虑对这个东西单独推个式子：

$$
\begin{aligned}
g_4(d,C)&=\sum\limits_{k=1}^C\gcd(d,k)\\
&=\sum\limits_{x\mid d}x·\sum\limits_{i=1}^{\lfloor\frac{C}{x}\rfloor}[i\perp\dfrac{d}{x}]\\
&=\sum\limits_{x\mid d}x·\sum\limits_{y\mid\frac{d}{x}}\mu(y)\lfloor\dfrac{C}{xy}\rfloor
\end{aligned}
$$

套路地枚举 $xy=T$ 可得：

$$
g_4(d,C)=\sum\limits_{T\mid d}\lfloor\dfrac{C}{T}\rfloor\sum\limits_{x\mid T}x\mu(\dfrac{T}{x})
$$

这已经是本题中第二次看到这个式子了：

$$
\sum\limits_{x\mid T}x\mu(\dfrac{T}{x})=\varphi(T)
$$

于是

$$
g_4(d,C)=\sum\limits_{T\mid d}\lfloor\dfrac{C}{T}\rfloor\varphi(T)
$$

带回去

$$
f_2(2)=\prod\limits_{d=1}^{\min(A,B)}d^{\sum\limits_{p}^{\lfloor\frac{\min(A,B)}{d}\rfloor}\mu(p)\lfloor\frac{A}{dp}\rfloor\lfloor\frac{B}{dp}\rfloor\sum\limits_{T\mid d}\lfloor\frac{C}{T}\rfloor\varphi(T)}
$$

按照[这里](https://www.cnblogs.com/ET2006/p/mobius-ycx-nb.html)总结出来的套路，看到先枚举 $i$ 再枚举 $j\mid i$ 的求和/积式我们可以考虑交换求和/积的顺序，先枚举 $j$ 再枚举 $i$，这样会出现下取整，就可以整除分块了。

因此考虑先枚举 $T$ 再枚举 $d$，有：

$$
f_2(2)=\prod\limits_{T=1}^{\min(A,B)}\prod\limits_{d=1}^{\lfloor\frac{\min(A,B)}{T}\rfloor}(dT)^{\sum\limits_{p}\mu(p)\lfloor\frac{A}{dTp}\rfloor\lfloor\frac{B}{dTp}\rfloor\lfloor\frac{C}{T}\rfloor\varphi(T)}
$$

然后考虑拆开来：

$$
f_2(2)=\prod\limits_{T=1}^{\min(A,B)}(T^{\varphi(T)\lfloor\frac{C}{T}\rfloor})^{\sum\limits_{d}\sum\limits_{p}\mu(p)\lfloor\frac{A}{dTp}\rfloor\lfloor\frac{B}{dTp}\rfloor}·\prod\limits_{d=1}^{\lfloor\frac{\min(A,B)}{T}\rfloor}(d^{\sum\limits_{p}\mu(p)\lfloor\frac{A}{dTp}\rfloor\lfloor\frac{B}{dTp}\rfloor})^{\varphi(T)\lfloor\frac{C}{T}\rfloor}
$$

---

先考虑前面的式子：

$$
(T^{\varphi(T)\lfloor\frac{C}{T}\rfloor})^{\sum\limits_{d}\sum\limits_{p}\mu(p)\lfloor\frac{A}{dTp}\rfloor\lfloor\frac{B}{dTp}\rfloor}
$$

考虑枚举 $dp=x$，那么：

$$
\begin{aligned}
\text{原式}&=(T^{\varphi(T)\lfloor\frac{C}{T}\rfloor})^{\sum\limits_{x}\sum\limits_{p\mid x}\mu(p)\lfloor\frac{A}{Tx}\rfloor\lfloor\frac{B}{Tx}\rfloor}\\
&=(T^{\varphi(T)\lfloor\frac{C}{T}\rfloor})^{\epsilon(x)\lfloor\frac{A}{Tx}\rfloor\lfloor\frac{B}{Tx}\rfloor}\\
&=(T^{\varphi(T)\lfloor\frac{C}{T}\rfloor})^{\lfloor\frac{A}{T}\rfloor\lfloor\frac{B}{T}\rfloor}
\end{aligned}
$$

对 $T$ 整除分块一下，预处理 $\varphi(T)$ 的前缀和即可 $\mathcal O(1)$ 算出。

---

然后是后面的式子（胜利就在眼前！）

$$
\prod\limits_{T=1}^{\min(A,B)}\prod\limits_{d=1}^{\lfloor\frac{\min(A,B)}{T}\rfloor}(d^{\sum\limits_{p}\mu(p)\lfloor\frac{A}{dTp}\rfloor\lfloor\frac{B}{dTp}\rfloor})^{\varphi(T)\lfloor\frac{C}{T}\rfloor}
$$

还是对 $T$ 整除分块，然后枚举 $dp=x$，那么上面的式子可以写成：

$$
\prod\limits_{T=1}^{\min(A,B)}\prod\limits_{x=1}^{\lfloor\frac{\min(A,B)}{T}\rfloor}((\prod\limits_{d\mid x}d^{\mu(p)})^{\lfloor\frac{A}{Tx}\rfloor\lfloor\frac{B}{Tx}\rfloor})^{\varphi(T)\lfloor\frac{C}{T}\rfloor}
$$

发现最里面的括号的东西就是在求 $f_2(0)$ 时用到的 $g_1(x)$，那么我们再套一个对 $x$ 的整除分块即可。

根据整除分块里再套一个整除分块复杂度是 $\sum\limits_{x,\exists k,s.t.\lfloor\frac{n}{k}\rfloor=x}\sqrt{x}=n^{0.75}$ 可知这一部分复杂度为 $n^{0.75}\log n$

于是这题就做完了，时间复杂度 $n\log n+Tn^{0.75}\log n$。

---

关于此题的常数问题，由于取模运算较多，可以使用快速取模优化常数，具体可见 chenxia25 神仙的[这篇博客](https://www.cnblogs.com/ycx-akioi/p/fastmod.html)。

```cpp
const int MAXV=1e5;
ll mod;
int pr[MAXV/5+5],prcnt=0,vis[MAXV+5],mu[MAXV+5],smu[MAXV+5],phi[MAXV+5];
int fac[MAXV+5],prd[MAXV+5],prd_inv[MAXV+5],prd_sq[MAXV+5],prd_sq_inv[MAXV+5];
int pre_ii[MAXV+5],inv_pre_ii[MAXV+5],pre_mul[MAXV+5],inv_pre_mul[MAXV+5];
int inv[MAXV+5],prd_phi[MAXV+5],prd_phi_inv[MAXV+5];
int sphi[MAXV+5];
__int128_t _base1=1,_base2=1;
inline int mol1(__int128_t x){return x-mod*(_base1*x>>64);}
inline int mol2(__int128_t x){return x-(mod-1)*(_base2*x>>64);}
int qpow(int x,int e){
	if(e<0) e+=mod-1;int ret=1;
	for(;e;e>>=1,x=mol1(1ll*x*x)) if(e&1) ret=mol1(1ll*ret*x);
	return ret;
}
int work(int x,int y){return (!y)?1:((~y)?x:inv[x]);}
void sieve(int n){
	for(int i=(inv[0]=inv[1]=1)+1;i<=n;i++) inv[i]=mol1(1ll*inv[mod%i]*(mod-mod/i));
	mu[1]=phi[1]=1;
	for(int i=(fac[0]=1);i<=n;i++) fac[i]=mol1(1ll*fac[i-1]*i);
	for(int i=2;i<=n;i++){
		if(!vis[i]) mu[i]=-1,pr[++prcnt]=i,phi[i]=i-1;
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j]==0){phi[i*pr[j]]=phi[i]*pr[j];break;}
			mu[i*pr[j]]=-mu[i];phi[i*pr[j]]=phi[i]*phi[pr[j]];
		}
	}
	for(int i=1;i<=n;i++) smu[i]=smu[i-1]+mu[i];
	for(int i=0;i<=n;i++) prd[i]=prd_sq[i]=1;
	for(int i=1;i<=n;i++) for(int j=i;j<=n;j+=i) prd[j]=mol1(1ll*prd[j]*work(i,mu[j/i]));
	for(int i=1;i<=n;i++) prd[i]=mol1(1ll*prd[i-1]*prd[i]);
	for(int i=0;i<=n;i++) prd_inv[i]=qpow(prd[i],-1);
	for(int i=1;i<=n;i++) for(int j=i;j<=n;j+=i)
		prd_sq[j]=mol1(1ll*prd_sq[j]*
		qpow(qpow(i,mol2(1ll*i*i)),mol2(1ll*mu[j/i]*(j/i)*(j/i))));
	for(int i=1;i<=n;i++) prd_sq[i]=mol1(1ll*prd_sq[i-1]*prd_sq[i]);
	for(int i=0;i<=n;i++) prd_sq_inv[i]=qpow(prd_sq[i],-1);
	pre_ii[0]=1;for(int i=1;i<=n;i++) pre_ii[i]=mol1(1ll*pre_ii[i-1]*qpow(i,i));
	for(int i=0;i<=n;i++) inv_pre_ii[i]=qpow(pre_ii[i],-1);
	pre_mul[0]=1;for(int i=1;i<=n;i++) pre_mul[i]=mol1(1ll*pre_mul[i-1]*work(i,mu[i]));
	for(int i=0;i<=n;i++) inv_pre_mul[i]=qpow(pre_mul[i],-1);
	prd_phi[0]=1;for(int i=1;i<=n;i++) prd_phi[i]=mol1(1ll*prd_phi[i-1]*qpow(i,phi[i]));
	for(int i=0;i<=n;i++) prd_phi_inv[i]=qpow(prd_phi[i],-1);
	for(int i=1;i<=n;i++) sphi[i]=mol2(sphi[i-1]+phi[i]);
}
int calc1(int x,int y){
	int res=1;
	for(int l=1,r;l<=min(x,y);l=r+1){
		r=min(x/(x/l),y/(y/l));
		res=1ll*res*qpow(1ll*prd[r]*prd_inv[l-1]%mod,1ll*(x/l)*(y/l)%(mod-1))%mod;
	}
	return res;
}
int solve1(int a,int b,int c){
	int res=1ll*qpow(calc1(a,b),-c)*qpow(calc1(a,c),-b)%mod;
	res=1ll*res*qpow(fac[a],1ll*b*c%(mod-1))%mod;
	res=1ll*res*qpow(fac[b],1ll*a*c%(mod-1))%mod;
	return res;
}
ll get(int x){return mol2(1ll*x*(x+1)/2);}
int calc2(int x,int y){
	int res=1;
	for(int l=1,r;l<=min(x,y);l=r+1){
		r=min(x/(x/l),y/(y/l));
		res=1ll*res*qpow(1ll*prd_sq[r]*prd_sq_inv[l-1]%mod,
		1ll*get(x/l)*get(y/l)%(mod-1))%mod;
	}
	return res;
}
int solve2(int a,int b,int c){
	int res=1;
	res=1ll*res*qpow(pre_ii[a],(1ll*b*(b+1)>>1)%(mod-1))%mod;
	res=1ll*res*qpow(pre_ii[b],(1ll*a*(a+1)>>1)%(mod-1))%mod;
	res=1ll*res*qpow(calc2(a,b),mod-2)%mod;
	res=qpow(res,(1ll*c*(c+1)>>1)%(mod-1));
	res=1ll*res*qpow(calc2(a,c),-(1ll*b*(b+1)>>1)%(mod-1))%mod;
	return res;
}
int calc3(int x,int y,int z){
	int res=1;
	for(int l=1,r;l<=x;l=r+1){
		r=1e9;
		if(x/l) chkmin(r,x/(x/l));
		if(y/l) chkmin(r,y/(y/l));
		if(z/l) chkmin(r,z/(z/l));
		int mul=qpow(1ll*prd_phi[r]*prd_phi_inv[l-1]%mod,x/l);
		mul=1ll*mul*qpow(fac[x/l],sphi[r]-sphi[l-1])%mod;
		res=1ll*res*qpow(mul,1ll*(y/l)*(z/l)%(mod-1))%mod;
	} return res;
}
int calc4(int x,int y,int z){
	int res=1;
	for(int l=1,r;l<=min(x,y);l=r+1){
		r=1e9;
		if(x/l) chkmin(r,x/(x/l));
		if(y/l) chkmin(r,y/(y/l));
		if(z/l) chkmin(r,z/(z/l));
		res=1ll*res*qpow(1ll*prd_phi[r]*prd_phi_inv[l-1]%mod,1ll*(x/l)*(y/l)*(z/l)%(mod-1))%mod;
		int X=x/l,Y=y/l,Z=z/l,sm=1ll*Z*(sphi[r]-sphi[l-1])%(mod-1);
		for(int L=1,R;L<=min(X,Y);L=R+1){
			R=1e9;
			if(X/L) chkmin(R,X/(X/L));
			if(Y/L) chkmin(R,Y/(Y/L));
			res=1ll*res*qpow(1ll*prd[R]*prd_inv[L-1]%mod,1ll*(X/L)*(Y/L)*sm%(mod-1))%mod;
		}
	}
	return res;
}
int solve3(int x,int y,int z){
	return 1ll*calc3(x,y,z)*calc3(y,x,z)%mod*
	qpow(calc4(x,y,z),-1)%mod*qpow(calc4(x,z,y),-1)%mod;
}
int main(){
	int qu;scanf("%d%lld",&qu,&mod);
	_base1=(_base1<<64)/mod;_base2=(_base2<<64)/(mod-1);
	sieve(MAXV);
	while(qu--){
		int a,b,c;scanf("%d%d%d",&a,&b,&c);
		printf("%d %d %d\n",solve1(a,b,c),solve2(a,b,c),solve3(a,b,c));
	}
	return 0;
}
```



---

## 作者：chenxia25 (赞：2)

做 /tuu 了这题，有被恶心到……真就「一杯茶，一包烟，一（六）道莫反做一天」呗……考场上遇到这种题肯定果断拿个 60pts 跑路……

一开始看成了 $\sum$ 感觉不可做。$\prod$ 是可以拆开的（就像加法遇到 $\sum$ 也可以拆开），设
$$
a=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci^{f(type)}\\
b=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Cj^{f(type)}\\
c=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(type)}\\
d=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,k)^{f(type)}
$$
那么 $ans=\dfrac{ab}{cd}$。又注意到 $a,b$ 和 $c,d$ 这两组是对称的，推柿子的时候每组只需要算一个，实现的时候就把某两个变量调换位置然后 CV 即可。于是任务就是求 $type=0,1,2$ 时的 $a,c$，一共六个任务。$0a$ 和 $1a$ 是小学二年级都会的，不需要莫反；$0c$ 是究极莫反基础，$1c$ 是莫反中等题，想必来挑战这题的人都是会的；这篇题解重点说说 $2a$ 和 $2c$，感觉有有意思又不失难度（同时还会把人推吐）。

---

$2a$：考虑对 $\gcd(i,j,k)$ 施加剧本作用：遇到 gcd 直接枚举。
$$
\begin{aligned}
a&=\prod_o\prod_{i=1}^Ai^{o\sum\limits_{j=1}^B\sum\limits_{k=1}^C[\gcd(i,j,k)=o]}\\
&=\prod_o\prod_{i=1}^{\left\lfloor\frac Ao\right\rfloor}(io)^{o\sum\limits_{j=1}^{\left\lfloor\frac Bo\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac Co\right\rfloor}\sum\limits_{p\mid i,p\mid j,p\mid k}\mu(p)}
\end{aligned}
$$
把 $\prod$ 转化成 $\sum$ 放到指数上反演之后，该放下来更方便地处理了。
$$
\begin{aligned}
a&=\prod_o\prod_{i=1}^{\left\lfloor\frac Ao\right\rfloor}\prod_{j=1}^{\left\lfloor\frac Bo\right\rfloor}\prod_{k=1}^{\left\lfloor\frac Co\right\rfloor}\prod_{p\mid i,p\mid j,p\mid k}(io)^{o\mu(p)}\\
&=\prod_{p}\prod_o\prod_{i=1}^{\left\lfloor\frac A{op}\right\rfloor}(iop)^{o\mu(p)\left\lfloor\frac B{op}\right\rfloor\left\lfloor\frac C{op}\right\rfloor}
\end{aligned}
$$
对 $op$ 整除分块。
$$
\begin{aligned}a&=\prod_q\prod_{p\mid q}\prod_{i=1}^{\left\lfloor\frac Aq\right\rfloor}(iq)^{\frac qp\mu(p)\left\lfloor\frac Bq\right\rfloor\left\lfloor\frac Cq\right\rfloor}\\
&=\prod_q\prod_{p\mid q}\left(\left\lfloor\dfrac Aq\right\rfloor!q^{\left\lfloor\frac Aq\right\rfloor}\right)^{\frac qp\mu(p)\left\lfloor\frac Bq\right\rfloor\left\lfloor\frac Cq\right\rfloor}
\end{aligned}
$$
到这儿就有了个做法的雏形：对 $q$ 整除分块，然后 $p$ 这个 $\prod$ 就是一个类似狄前的函数在 $q$ 处的取值，这里面如果只有 $p,q,\dfrac qp$ 这三者相关的量的话是可以直接预处理的。但是这里面好死不死有 $A,B,C$ 的整除值（在整除分块的时候视作常数，但是对于不同测试点就 GG 了），所以还要继续拆：
$$
a=\prod_q\left(\left\lfloor\dfrac Aq\right\rfloor!\right)^{\left\lfloor\frac Bq\right\rfloor\left\lfloor\frac Cq\right\rfloor q\sum\limits_{p\mid q}\frac{\mu(p)}p}q^{\left\lfloor\frac Aq\right\rfloor\left\lfloor\frac Bq\right\rfloor\left\lfloor\frac Cq\right\rfloor q\sum\limits_{p\mid q}\frac{\mu(p)}p}
$$
居然看到了 $\sum\limits_{p\mid q}\dfrac{\mu(p)}p$ 这个式子，回想起了万年没用过的恒等式 $\sum\limits_{i\mid x}\dfrac{\mu(i)}i=\dfrac{\varphi(x)}x$！！！11 于是 $q\sum\limits_{p\mid q}\dfrac{\mu(p)}p=\varphi(q)$。（u1s1 你可能会说这种模意义下拆出分数次幂再化回整数次幂，考虑到高次剩余存在唯一性问题，不太严谨吧？其实大可这样理解：假设全是在复数域下定义的东西，那么这么推显然没毛病，只是题目保证这个式子的值是整数，故最后推出来计算可以取模。所以是完全严谨的）

那么自行替换一下，只需要对 $q$ 整除分块，对于一块只要求 $\varphi(x)$ 的前缀和与 $x^{\varphi(x)}$ 的前缀积即可，单次询问复杂度 $\mathrm O(\sqrt n\log n)$。

这部分还是不算很难的，只是用到了万年不用的恒等式，感觉很有趣。

---

$2c$：这里面有两个 gcd，是整除关系。zszz 莫反题要谨慎，不能一口气全部反演掉，要一个一个反演然后根据 gcd 之间的关系加限制条件。这个其实先枚举哪个都是能做的，我枚举的是 $\gcd(i,j)$。
$$
\begin{aligned}c&=\prod_o\prod_{p\mid o}o^{p\sum\limits_{i=1}^A\sum\limits_{j=1}^B[\gcd(i,j)=o]\sum\limits_{k=1}^C[\gcd(k,o)=p]}\\
&=\prod_o\prod_{p\mid o}o^{p\sum\limits_{i=1}^{\left\lfloor\frac Ao\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac Bo\right\rfloor}\sum\limits_{q\mid i,q\mid j}\mu(q)\sum\limits_{k=1}^{\left\lfloor\frac Cp\right\rfloor}\sum\limits_{r\mid k,r\mid \frac op}\mu(r)}\\
&=\prod_o\prod_{p\mid o}o^{p\sum\limits_q\mu(q)\sum\limits_{r\mid\frac op}\mu(r)\left\lfloor\frac A{oq}\right\rfloor\left\lfloor\frac B{oq}\right\rfloor\left\lfloor\frac C{pr}\right\rfloor}
\end{aligned}
$$
到目前的最后一步相比于 $2a$ 的处理就爽快很多，$2a$ 的 $i$ 迟迟不能被化掉。不知道导致这个的本质原因是啥（（

反演结束之后 $\sum$ 指数拆下来变成 $\prod$。
$$
c=\prod_o\prod_{p\mid o}\prod_q\prod_{r\mid \frac op}o^{p\mu(q)\mu(r)\left\lfloor\frac A{oq}\right\rfloor\left\lfloor\frac B{oq}\right\rfloor\left\lfloor\frac C{pr}\right\rfloor}
$$
接下来又到了喜闻乐见的将 $x\mid y$ 换元成 $y'=xy$ 时间~
$$
\begin{aligned}c&=\prod_p\prod_o\prod_q\prod_{r\mid o}(op)^{p\mu(q)\mu(r)\left\lfloor\frac A{opq}\right\rfloor\left\lfloor\frac B{opq}\right\rfloor\left\lfloor\frac C{pr}\right\rfloor}\\
&=\prod_p\prod_r\prod_q\prod_o(rop)^{p\mu(p)\mu(r)\left\lfloor\frac A{ropq}\right\rfloor\left\lfloor\frac B{ropq}\right\rfloor\left\lfloor\frac C{pr}\right\rfloor}
\end{aligned}
$$
接下来是喜闻乐见的整除分块——枚举两个变量的乘积时间~
$$
c=\prod_s\prod_t\prod_{p\mid s}\prod_{o\mid t}(so)^{p\mu\left(\frac to\right)\mu\left(\frac sp\right)\left\lfloor\frac A{st}\right\rfloor\left\lfloor\frac B{st}\right\rfloor\left\lfloor\frac C{s}\right\rfloor}
$$
到这儿已经可以做了，并且无法往下继续取得更优复杂度了——因为这儿的整除里面的分母有两种（不可能搞成一种的），需要的是两次整除分块，而不是二维整除分块，即先对一个变量分块，对每个块都对另一个变量分块。这样一般情况下最坏是 $\mathrm O(\sqrt n\times\sqrt n)=\mathrm O(n)$，在这题里面，如果先分块 $s$，那么 $t$ 的分子是 $\dfrac ns$，这和不预处理的杜教筛的复杂度分析是一样的，是 $\mathrm O\!\left(n^{\frac 34}\right)$~~（预处理实在是太晕了，就不搞了）~~。那么考虑对已经分好的每个块对该如何算贡献，那么三个整除都是常数，我们要求的是
$$
\prod_{p\mid s}\prod_{o\mid t}(so)^{p\mu\left(\frac to\right)\mu\left(\frac sp\right)}
$$
这个显然可以用类似狄前 / 狄卷的方式预处理，只不过这样扩展到两个变量的话，需要将变量分类每类独立开来然后分别预处理，分块求值的时候就分别调用两类的前缀和 / 积作用到一起。这个式子还是不难拆的：
$$
\prod_{p\mid s}\prod_{o\mid t}(so)^{p\mu\left(\frac to\right)\mu\left(\frac sp\right)}=\left(\prod_{p\mid s}s^{p\mu\left(\frac sp\right)}\right)^{\sum\limits_{o\mid t}\mu\left(\frac to\right)}\left(\prod_{o\mid t}o^{\mu\left(\frac to\right)}\right)^{\sum\limits_{p\mid s}p\mu\left(\frac sp\right)}
$$
预处理四个前缀和 / 积即可。预处理的话，因为计算量是线对，再加上个快速幂就是线性二次对数了。单次询问也受到快速幂的影响，变成 $\mathrm O\!\left(n^{\frac 34}\log n\right)$。

---

总复杂度是 $\mathrm O\!\left(n\log^2n+n^{\frac 34}\log n\right)$，常数非常大。这题模数是输入的，用了个快模，还逻辑优化了几下才勉强过了，人傻常数大啊。

贴个[代码](https://www.luogu.com.cn/paste/rf2tvd8a)感受一下壮观。

题解写的累趴了。

---

## 作者：Ame__ (赞：2)

### 前言
请确保你在做此题之前做过

[P1390 公约数的和](https://www.luogu.com.cn/problem/P1390)

[P2303 [SDOI2012]Longge的问题](https://www.luogu.com.cn/problem/P2303)

[P1829 [国家集训队]Crash的数字表格 / JZPTAB](https://www.luogu.com.cn/problem/P1829)

[P3704 [SDOI2017]数字表格](https://www.luogu.com.cn/problem/P3704)

并有一定的反演芝士以获得更好的做题体验

由于是断断续续做的可能柿子写的有不对的地方看出来的人可以指出来，谢谢~

### 简化题面
求
$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}$$

对于$f(x)$有
$$f(0)=1$$
$$f(1)=i \times j \times k$$
$$f(2)=\gcd(i,j,k)$$

对于$type$仅有$0,1,2$三种取值

对于数据
$$ 1\leq A,B,C\leq 10^5 \ \ \ \ 10^7 \leq p \leq 1.05\times 10^9\ \ \ \ p\in \{ prime\} \ \ \ \ T =70$$

### 解题思路
~~第一眼看就是大毒瘤题~~

首先对原柿子进行展开
$$ \prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \left(\frac{i\times j}{gcd(i,j)\times gcd(i,k)}\right)^{f(type)}$$

很显然的可以拆成两个柿子
$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{f(type)}$$

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)^{f(type)}$$

所以变成了对于六个子问题的化简，慢慢梳理

#### Type=0

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i$$

$$=\prod_{i=1}^{A}\prod_{j=1}^{B}i^C$$

$$=(\prod_{i=1}^{A}i)^{C\times B}$$
直接预处理阶乘就可以求得


$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)$$

$$=(\prod_{i=1}^{A}\prod_{j=1}^{B} gcd(i,j))^C$$

考虑像数字表格一样进行处理

$$=(\prod_{d=1} d^{\sum_{i=1}^{A/d}\sum_{j=1}^{B/d} [gcd(i,j)=1]})^C$$

$$=(\prod_{d=1} d^{\sum_{p=1}\mu(p)\left\lfloor\frac{A}{dp}\right\rfloor\left\lfloor\frac{B}{dp}\right\rfloor})^C$$

$$=(\prod_{Q=1}(\prod_{d|Q}d^{\mu(\frac{Q}{d})})^{\left\lfloor\frac{A}{Q}\right\rfloor\left\lfloor\frac{B}{Q}\right\rfloor})^{C}$$

预处理然后分块做即可

#### Type=1

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{i\times j \times k}$$

$$=\prod_{i=1}^{A}\prod_{j=1}^{B} i^{i \times j \times \sum_{k=1}^{C}k}$$

$$=\prod_{i=1}^{A} i^{i \times \sum_{j=1}^{B}j \times \sum_{k=1}^{C}k}$$

质数部分处理一个等差数列求，并且预处理$i*i$的阶乘直接求就可以

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)^{i\times j \times k}$$

第一眼看真不知道从哪里下手，思考之后考虑先把没用的东西拿出来

$$=\prod_{i=1}^{A}\prod_{j=1}^{B} gcd(i,j)^{i\times j \times \sum_{k=1}^{C}k}$$

然后你会感觉这个柿子有点眼熟，很像Crash的数字表格，于是我们按照当时的想法进行计算

$$\begin{aligned}=(\prod_{d=1}d^{d^2\sum_{i=1}^{A/d}\sum_{j=1}^{B/d} i \times j \times [gcd(i, j)=1]})^{\sum_{k=1}^{C}k}\end{aligned}$$

$$\begin{aligned}=(\prod_{d=1}d^{\sum_{p=1}d^2\mu(p)p^2sum(\left\lfloor\frac{A}{dp}\right\rfloor)sum(\left\lfloor\frac{B}{dp}\right\rfloor)})^{\sum_{k=1}^{C}k}\end{aligned}$$

$$\begin{aligned}=(\prod_{Q=1}((\prod_{d|Q} d^{\mu(\frac{Q}{d})})^{Q^2})^{sum(\left\lfloor\frac{A}{Q}\right\rfloor)sum(\left\lfloor\frac{B}{Q}\right\rfloor)})^{\sum_{k=1}^{C}k}\end{aligned}$$

显然的和$type0$一样进行预处理然后分块做即可

#### Type=2

这道题最大的亮点~~最大的毒瘤~~的地方

老套路枚举$gcd$

$$\begin{aligned}\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{gcd(i,j,k)}\end{aligned}$$

$$\begin{aligned}=\prod_{d=1}\prod_{i=1}^A i^{d\times \sum_{j=1}^B\sum_{k=1}^C[gcd(i,j,k)=d]}\end{aligned}$$

$$\begin{aligned}=\prod_{d=1}\prod_{i=1}^{(\left\lfloor\frac{A}{d}\right\rfloor)} i\times d ^{d\times \sum_{j=1}^{(\left\lfloor\frac{B}{d}\right\rfloor)}\sum_{k=1}^{(\left\lfloor\frac{C}{d}\right\rfloor)}[gcd(i,j,k)=1]}\end{aligned}$$

$$=\prod_{d=1}\prod_{i=1}^{(\left\lfloor\frac{A}{d}\right\rfloor)} (i\times d) ^{d\times \sum_{p=1}\mu(p)(\left\lfloor\frac{B}{dp}\right\rfloor)(\left\lfloor\frac{C}{dp}\right\rfloor)}$$

考虑把指数上的$\sum$拿到下面来

$$=\prod_{d=1}\prod_{p=1}\prod_{i=1}^{(\left\lfloor\frac{A}{dp}\right\rfloor)} (i\times d\times p) ^{d\times\mu(p)(\left\lfloor\frac{B}{dp}\right\rfloor)(\left\lfloor\frac{C}{dp}\right\rfloor)}$$

$$=\prod_{Q=1}(\prod_{d|Q}(\prod_{i=1}^{(\left\lfloor\frac{A}{Q}\right\rfloor)}i\times Q)^{d\times \mu(\left\lfloor\frac{Q}{d}\right\rfloor)})^{(\left\lfloor\frac{B}{Q}\right\rfloor)(\left\lfloor\frac{C}{Q}\right\rfloor)}$$

考虑再把$\prod$拿上去

$$=\prod_{Q=1}((\prod_{i=1}^{(\left\lfloor\frac{A}{Q}\right\rfloor)}i\times Q)^{d\times \sum_{d|Q}\mu(\left\lfloor\frac{Q}{d}\right\rfloor)})^{(\left\lfloor\frac{B}{Q}\right\rfloor)(\left\lfloor\frac{C}{Q}\right\rfloor)}$$

然后你会发现$d\times \sum_{d|Q}\mu(\left\lfloor\frac{Q}{d}\right\rfloor)$非常的眼熟，$id*\mu=\varphi$

$$=\prod_{Q=1}((\prod_{i=1}^{(\left\lfloor\frac{A}{Q}\right\rfloor)}i\times Q)^{\varphi(Q)})^{(\left\lfloor\frac{B}{Q}\right\rfloor)(\left\lfloor\frac{C}{Q}\right\rfloor)}$$

预处理$\varphi$的前缀和，用之前求得阶乘乱搞就可以了

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} gcd(i,j)^{gcd(i,j,k)}$$

这个题最恶心人的柿子，还是考虑枚举$gcd$，先考虑枚举$gcd(i,j)$

$$=\prod_{d=1}^{A} d^{\sum_{i=1}^A\sum_{j=1}^B [gcd(i,j)=d]\times (\sum_{k=1}^{C} gcd(d,k))}$$

$$=\prod_{d=1}d^{\sum_{i=1}^{(\left\lfloor\frac{A}{d}\right\rfloor)}\sum_{j=1}^{(\left\lfloor\frac{B}{d}\right\rfloor)}[gcd(i,j)=1] \times (\sum_{k=1}^{C} gcd(d,k))}$$

$$=\prod_{d=1}d^{(\sum_{p=1}\mu(p)\left\lfloor\frac{A}{dp}\right\rfloor\left\lfloor\frac{B}{dp}\right\rfloor) \times (\sum_{k=1}^{C} gcd(d,k))}$$

$$=\prod_{Q=1}(\prod_{d|Q}d^{\mu(\left\lfloor\frac{Q}{d}\right\rfloor) \times (\sum_{k=1}^{C} gcd(d,k))})^{\left\lfloor\frac{A}{Q}\right\rfloor\left\lfloor\frac{B}{Q}\right\rfloor}$$

对$\sum_{k=1}^{C} gcd(d,k)$继续进行反演

你会发现这不就是$Longge$的问题里面的那个柿子吗

$$\sum_{d'|d}d'\sum_{k=1}^{C/d'} [gcd(\frac{d}{d'},k) = 1]$$

$$\sum_{d'|d}d'\sum_{p'|d,d'}\mu(p')\left\lfloor\frac{C}{d'p'}\right\rfloor$$

化简后可得到

$$\sum_{T|d}\left\lfloor\frac{C}{T}\right\rfloor\varphi(T)$$ 

然后套回去之后变成了

$$=\prod_{Q=1}(\prod_{d|Q}d^{\mu(\left\lfloor\frac{Q}{d}\right\rfloor) \times (\sum_{T|d}\left\lfloor\frac{C}{T}\right\rfloor\varphi(T))})^{\left\lfloor\frac{A}{Q}\right\rfloor\left\lfloor\frac{B}{Q}\right\rfloor}$$

化简到这里复杂度是$O(nlogn)$的，试了试貌似过不去。。。然后我就呆住了，这怎么继续反演

~~看了看你谷的题解之后我悟了~~

把$d$拆成$\frac{d}{T}$和$T$来做

把指数上的$\sum$拿下来

$$=\prod_{Q=1}(\prod_{d|Q}\prod_{T|d}d^{\mu(\left\lfloor\frac{Q}{d}\right\rfloor) \times (\left\lfloor\frac{C}{T}\right\rfloor\varphi(T))})^{\left\lfloor\frac{A}{Q}\right\rfloor\left\lfloor\frac{B}{Q}\right\rfloor}$$

首先对于$\frac{d}{T}$我们有


$$\prod_{Q=1}(\prod_{d|Q}\prod_{T|d}(\frac{d}{T})^{\mu(\left\lfloor\frac{Q}{d}\right\rfloor) \times (\left\lfloor\frac{C}{T}\right\rfloor\varphi(T))})^{\left\lfloor\frac{A}{Q}\right\rfloor\left\lfloor\frac{B}{Q}\right\rfloor}$$

对于$Q$和$d$我们同时乘上$T$可以得到

$$=\prod_{T=1}^x\ \prod_{Q=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}\ \prod_{d|Q}
d^{\mu(\frac{QT}{dT})\varphi(T)\left\lfloor{\frac{z}{T}}\right\rfloor{\left\lfloor{\frac{x}{QT}}\right\rfloor}{\left\lfloor{\frac{y}{QT}}\right\rfloor}}$$


$$=\prod_{T=1}^x\ \prod_{Q=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}\ \prod_{d|Q}
d^{\mu(\frac{Q}{d})\varphi(T)\left\lfloor{\frac{z}{T}}\right\rfloor{\left\lfloor{\frac{x}{QT}}\right\rfloor}{\left\lfloor{\frac{y}{QT}}\right\rfloor}}$$

然后里面的部分我们在$type0$中已经预处理过了，直接白嫖

对于$T$的话

$$\prod\limits_{Q=1}^x\prod_{d|Q}\prod_{T|d}T^{\mu(\frac{Q}{d})\varphi(p)\left\lfloor{\frac{z}{T}}\right\rfloor{\left\lfloor{\frac{x}{Q}}\right\rfloor}{\left\lfloor{\frac{y}{Q}}\right\rfloor}}$$

枚举$T$

$$=\prod_{T=1}^x\prod_{Q=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}\prod_{d|Q}p^{\mu(\frac{QT}{dT})\varphi(T)\left\lfloor{\frac{z}{T}}\right\rfloor{\left\lfloor{\frac{x}{QT}}\right\rfloor}{\left\lfloor{\frac{y}{QT}}\right\rfloor}}$$

然后把$\prod$移动到指数上

$$=\prod_{T=1}^xT^{\sum\limits_{Q=1}^{\left\lfloor{\frac{x}{T}}\right\rfloor}\sum\limits_{d|Q}\mu(\frac{Q}{d})\varphi(T)\left\lfloor{\frac{z}{T}}\right\rfloor{\left\lfloor{\frac{x}{QT}}\right\rfloor}{\left\lfloor{\frac{y}{QT}}\right\rfloor}}$$

然后整理一下可以得到

$$=\prod_{T=1}^xT^{\varphi(T)\left\lfloor{\frac{z}{T}}\right\rfloor\sum\limits_{Q=1}^{\left\lfloor{\frac{x}{Q}}\right\rfloor}{\left\lfloor{\frac{x}{QT}}\right\rfloor}{\left\lfloor{\frac{y}{QT}}\right\rfloor}\sum\limits_{d|Q}
\mu(\frac{Q}{d})}$$

然后最妙的地方是$\sum\limits_{d|Q}\mu(\frac{Q}{d})$可以替换成$e$，也就是$[Q=1]$，所以当且仅当$Q=1$的时候才会有贡献，所以就变成了

$$=\prod_{T=1}^xT^{\varphi(T){\left\lfloor{\frac{x}{T}}\right\rfloor}{\left\lfloor{\frac{y}{T}}\right\rfloor}{\left\lfloor{\frac{z}{T}}\right\rfloor}}$$

然后这一部分就可以算了，直接分块~~这么做真的是妙~~

### 细节处理
预处理阶乘逆元记得倒叙，其他的就没了

$Code$

```.cpp
#include<bits/stdc++.h>
    
#define LL long long
    
#define _ 0

#define R register

#define int long long

using namespace std;
    
/*Grievous Lady*/
    
template <typename T> void read(T & t){
    t = 0;int f = 1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f =- 1;ch = getchar();}
    do{t = (t << 1) + (t << 3) + ch - '0';ch = getchar();}while(ch >= '0' && ch <= '9');t *= f;
}
    
const int kato = 1e5 + 10;

const int atri = 1e5 + 10;

int a , b , c , t , mod;

int prime[kato] , cnt , phi[kato] , mu[kato] , fac[kato] , Fac[kato] , type0[kato] , type1[kato];

int phi_sum[kato] , fac_0[kato] , fac_1[kato] , fac_0_inv[kato] , fac_1_inv[kato] , inv[kato];

bool ispri[kato];

inline LL quick_pow(LL a , LL b){
    LL res = 1;
    for(; b ; b >>= 1 , a = a * a % mod){
        if(b & 1){
            res = res * a % mod;
        }
    }
    return res % mod;
}

// void put(int x){
// 	if(x < 0) putchar('-') , x =- x;
// 	if(x >= 10) put(x / 10);
// 	putchar((x % 10) + 48);
// }

inline void pri(){
    for(int i = 1;i < atri;i ++){
        fac[i] = fac[i - 1] * i % mod;
        Fac[i] = Fac[i - 1] * quick_pow(i , i) % mod;
    }
    for(int i = 2;i < atri;i ++){
        if(!ispri[i]){
            prime[++ cnt] = i;
            phi[i] = i - 1;
            mu[i] = -1;
        }
        for(int j = 1;j <= cnt && i * prime[j] < atri;j ++){
            ispri[i * prime[j]] = 1;
            if(i % prime[j] == 0){
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            mu[i * prime[j]] = -mu[i];
        }
    }
    for(int i = 1;i < atri;i ++){
        phi_sum[i] = (phi_sum[i - 1] + phi[i]) % (mod - 1);
        type0[i] = fac_0[i] = fac_1[i] = fac_0_inv[i] = fac_1_inv[i] = type1[i] = 1;
    }
    for(int i = 1;i < atri;i ++){
        if(mu[i] == 1){
            for(int j = i , cnt = 1;j < atri;j += i , cnt ++){
                type0[j] = type0[j] * cnt % mod;
                type1[j] = type1[j] * cnt % mod;
            }
        }
        if(mu[i] == -1){
            for(int j = i , cnt = 1;j < atri;j += i , cnt ++){
                type0[j] = type0[j] * inv[cnt] % mod;
                type1[j] = type1[j] * inv[cnt] % mod;
            }
        }
    }
    // cout << "cnt = " << cnt << ' ' << "primemax = " << prime[cnt] <<'\n';
    for(int i = 1;i < atri;i ++){
        // if(i == 46341) cout << i << '\n';
        fac_0[i] = fac_0[i - 1] * type0[i] % mod;
        type1[i] = quick_pow(type1[i] , i * i % (mod - 1));
        fac_1[i] = fac_1[i - 1] * type1[i] % mod;
        // if(i > 46340)cout << "i = " << i << " " << "fac_0[i] = " << fac_0[i] << ' ' << "fac_0_inv[i] = " << fac_0_inv[i] << ' ' << "fac_1[i] = " << fac_1[i] << ' ' << "fac_1_inv[i] = " << fac_1_inv[i] << '\n';
    }
    fac_0_inv[kato - 1] = quick_pow(fac_0[kato - 1] , mod - 2);
    fac_1_inv[kato - 1] = quick_pow(fac_1[kato - 1] , mod - 2);
    // cout << fac_0_inv[kato - 1] << ' ' << fac_1_inv[kato - 1];
    for(int i = kato - 2 ; i ; i --){
        fac_0_inv[i] = fac_0_inv[i + 1] * type0[i + 1] % mod;
    }
    for(int i = kato - 2 ; i ; i --){
        fac_1_inv[i] = fac_1_inv[i + 1] * type1[i + 1] % mod;
    }
    // cout << "QAQ" << '\n';
}

inline int get_type2_(int x , int y){
    int ans = 1;
    for(int l = 1 , r = 0;l <= min(x , y);l = r + 1){
        r = min(x / (x / l) , y / (y / l));
        ans = ans * quick_pow(1LL * fac_0[r] * fac_0_inv[l - 1] % mod , 1LL * (x / l) * (y / l) % (mod - 1)) % mod; 
    }
    return ans % mod;
}

inline int get_sum(int a){
    return ((a * (a + 1))>> 1) % (mod - 1);
}

inline int get_type0_f1(int x , int y , int z){
    return quick_pow(fac[x] , y * z % (mod - 1)) % mod;
}

inline int get_type0_f2(int x , int y , int z){
    // cout << x << ' ' << y << ' ' << z << '\n';
    int ans = 1;
    for(int l = 1 , r = 0;l <= min(x , y);l = r + 1){
        r = min(x / (x / l) , y / (y / l));
        // cout << fac_0[r] << ' ' << fac_0_inv[l - 1] << '\n' ;
        ans = ans * quick_pow(fac_0[r] * fac_0_inv[l - 1] % mod , (x / l) * (y / l) % (mod - 1)) % mod; 
    }
    // cout << ans << '\n';
    return quick_pow(ans , z);
}

inline int get_type1_f1(int x , int y , int z){
    return quick_pow(Fac[x] , get_sum(y) * get_sum(z) % (mod - 1)) % mod;
}

inline int get_type1_f2(int x , int y, int z){
    int ans = 1;
    for(int l = 1 , r = 0;l <= min(x , y);l = r + 1){
        r = min(x / (x / l) , y / (y / l));
        ans = ans * quick_pow(fac_1[r] * fac_1_inv[l - 1] % mod , get_sum(x / l) * get_sum(y / l) % (mod - 1)) % mod;
    }
    return quick_pow(ans , get_sum(z));
}

inline int get_type2_f1(int x , int y , int z){
    int ans = 1;
    for(int l = 1 , r = 0;l <= min(x , min(y , z));l = r + 1){
        r = min(x / (x / l) , min(y / (y / l) , z / (z / l)));
        ans = ans * quick_pow(fac[x / l] % mod , (phi_sum[r] - phi_sum[l - 1] + mod - 1) % (mod - 1) * (y / l) % (mod - 1) * (z / l) % (mod - 1)) % mod;
    }
    return ans % mod;
}

inline int get_type2_f2(int x , int y , int z){
    int ans = 1;
    for(int l = 1 , r = 0;l <= min(x , min(y , z));l = r + 1){
        r = min(x / (x / l) , min(y / (y / l) , z / (z / l)));
        ans = ans * quick_pow(get_type2_(x / l , y / l) , (phi_sum[r] - phi_sum[l - 1] + mod - 1) * (z / l) % (mod - 1)) % mod;
    }
    return ans % mod;
}

inline int get_type0(){
    int res1 = get_type0_f1(a , b , c) * get_type0_f1(b , a , c) % mod;
    int res2 = get_type0_f2(a , b , c) * get_type0_f2(a , c , b) % mod;
    // cout << res1 << ' ' << res2 << '\n';
    return (res1 * quick_pow(res2 , mod - 2)) % mod;
}

inline int get_type1(){
    int res1 = get_type1_f1(a , b , c) * get_type1_f1(b , a , c) % mod;
    int res2 = get_type1_f2(a , b , c) * get_type1_f2(a , c , b) % mod;
    return (res1 * quick_pow(res2 , mod - 2)) % mod;
}

inline int get_type2(){
    int res1 = get_type2_f1(a , b , c) * get_type2_f1(b , a , c) % mod;
    int res2 = get_type2_f2(a , b , c) * get_type2_f2(a , c , b) % mod;
    return (res1 * quick_pow(res2 , mod - 2)) % mod;
}

inline int Ame_(){
    read(t) , read(mod);
    inv[1] = 1;
	for(int i = 2;i < kato;i ++){
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    }
    mu[1] = phi[1] = phi_sum[0] = fac[0] = fac[1] = Fac[0] = Fac[1] = fac_0[0] = fac_0[1] = fac_1[0] = fac_1[1] = fac_0_inv[0] = fac_1_inv[0] = 1;
    pri();
    // cout << "QAQ" << '\n';
    // for(int i = 1;i <= 10;i ++){
    //     cerr << i << ' ' << mu[i] << ' ' << phi[i] << '\n';
    // }
    // cout << type0[1] << ' ' << type0[2] << ' ' << type0[3] << '\n';
    // for(int i = 1;i <= 10;i ++){
    //     cerr << fac_0_inv[i] << ' ' << fac_1_inv[i] << '\n';
    // }
    for(; t --> 0 ;){
        read(a) , read(b) , read(c);
        printf("%lld %lld %lld\n" , get_type0() , get_type1() , get_type2());
        // put(get_type0());cout << ' ';put(get_type1());cout << ' ';put(get_type2());cout << '\n';
    }
    return ~~(0^_^0);
}
    
int Ame__ = Ame_();
    
signed main(){;}

/*
3 998244853
1 1 1
2 2 2
3 3 3
*/

/*
1 1 1
16 4096 16
180292630 873575259 180292630
*/
```

---

## 作者：whiteqwq (赞：2)

# [MtOI2019]幽灵乐团解题报告

标签： 解题报告

---

发现自己的一篇远古题解，拿出来发一下：

[[MtOI2019]幽灵乐团](https://www.luogu.com.cn/problem/P5518)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1689732)

题意：共$T$组数据，给定$A,B,C,p$求对于每个$type$的$(\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C(\frac{lcm(i,j)}{\gcd(i,k)})^{f(type)})\bmod p$，其中：$f(0)=1,f(1)=i\cdot j\cdot k,f(2)=\gcd(i,j,k)$。

数据范围：$A,B,C\leqslant 10^5,10^7\leqslant p\leqslant 1.05\cdot 10^9,p\in\mathbb{P},T\leqslant 70$

这道题的公式真的是精神污染。。。

首先我们可以将原式化为$(\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C(\frac{i\cdot j}{\gcd(i,k)^2})^{f(type)})\bmod p$，因此我们可以分为两部分来做这道题，即求$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(type)}$与$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(type)}$

- $type=0$时：
第一个式子：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(0)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i=\prod_{i=1}^A i^{B\cdot C}=(\prod_{i=1}^A i)^{B\cdot C}$$
然后用一些基本的套路（枚举$\gcd$，将求积转换为指数的求和，莫比乌斯函数替换$\gcd$，等差数列求和等）化简第二个式子：

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(0)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)=\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^C=(\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j))^C=(\prod_{d=1}^A\prod_{i=1}^A\prod_{j=1}^B d^{[\gcd(i,j)==d]})^C=(\prod_{d=1}^A d^{\sum_{i=1}^A\sum_{j=1}^B[\gcd(i,j)==d]})^C=(\prod_{d=1}^A d^{\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}[\gcd(i,j)==1]})^C=(\prod_{d=1}^A d^{\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k\mid\gcd(i,j)}\mu(k)})^C=(\prod_{d=1}^A d^{\sum_{k=1}^{\lfloor\frac{A}{d}\rfloor}\mu(k)\cdot (\sum_{i=1}^{\lfloor\frac{A}{k\cdot d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{k\cdot d}\rfloor}1)})^C=(\prod_{d=1}^A d^{\sum_{k=1}^{\lfloor\frac{A}{d}\rfloor}\mu(k)\cdot\lfloor\frac{A}{k\cdot d}\rfloor\cdot \lfloor\frac{B}{k\cdot d}\rfloor})^C$$

设$t=k\cdot d$，则有：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(0)}=(\prod_{t=1}^A\prod_{d\mid t}d^{\mu(\frac{t}{d})\cdot\lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor})^C=(\prod_{t=1}^A(\prod_{d\mid t}d^{\mu(\frac{t}{d})})^{\lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor})^C$$

设$f(x)=\prod_{d\mid x}x^{\mu(\frac{x}{d})}$，则其可以在$O(n\log n)$的时间用整除分块预处理

此时原式为$(\prod_{t=1}^A f(x)^{\lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor})^C$

可以整除分块解决这一式子。

得分：$20pts$

- $type=1$时：
第一个式子：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(1)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{i\cdot j\cdot k}=\prod_{i=1}^A i^{i\cdot j\cdot\sum_{k=1}^C k}=\prod_{i=1}^A i^{i\cdot(\sum_{j=1}^B j)\cdot(\sum_{k=1}^C k)}=\prod_{i=1}^A i^{i\cdot\frac{B\cdot(B+1)}{2}\cdot\frac{C\cdot(C+1)}{2}}=(\prod_{i=1}^A i^i)^{\frac{B\cdot(B+1)}{2}\cdot\frac{C\cdot(C+1)}{2}}$$
第二个式子：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(1)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{i\cdot j\cdot k}=\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{i\cdot j\cdot(\sum_{k=1}^C k)}=\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{i\cdot j\cdot\frac{C\cdot(C+1)}{2}}=\prod_{d=1}^n\prod_{i=1}^A\prod_{j=1}^B[\gcd(i,j)==d]d^{i\cdot j\cdot\frac{C\cdot(C+1)}{2}}=\prod_{d=1}^A\prod_{i=1}^{\lfloor\frac{A}{d}\rfloor}\prod_{j=1}^{\lfloor\frac{B}{d}\rfloor}[\gcd(i,j)==1]d^{i\cdot j\cdot\frac{C\cdot(C+1)}{2}}=(\prod_{d=1}^A\prod_{i=1}^{\lfloor\frac{A}{d}\rfloor}\prod_{j=1}^{\lfloor\frac{B}{d}\rfloor}(\sum_{k\mid\gcd(i,j)}\mu(k))\cdot d^{i\cdot j\cdot d^2})^\frac{C\cdot(C+1)}{2}=(\prod_{d=1}^A d^{d^2\cdot \sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}(i\cdot j\cdot \sum_{k\mid\gcd(i,j)}\mu(k))})^{\frac{C\cdot(C+1)}{2}}=(\prod_{d=1}^A d^{d^2\cdot \sum_{k=1}^{\lfloor\frac{A}{d}\rfloor}\mu(k)\sum_{i=1}^{\lfloor\frac{A}{k\cdot d}\rfloor}i\cdot k\sum_{j=1}^{\lfloor\frac{B}{k\cdot d}\rfloor}j\cdot k})^{\frac{C\cdot(C+1)}{2}}=(\prod_{d=1}^A d^{\sum_{k=1}^{\lfloor\frac{A}{d}\rfloor}d^2\cdot \mu(k)\cdot k^2\cdot\frac{\lfloor\frac{A}{k\cdot d}\rfloor\cdot (\lfloor\frac{A}{k\cdot d}\rfloor+1)}{2}\cdot\frac{\lfloor\frac{B}{k\cdot d}\rfloor\cdot (\lfloor\frac{B}{k\cdot d}\rfloor+1)}{2}})^{\frac{C\cdot(C+1)}{2}}=(\prod_{t=1}^A\prod_{d\mid t} d^{(d^2\cdot (\frac{t}{d})^2)\cdot\mu(\frac{t}{d})\cdot\frac{\lfloor\frac{A}{t}\rfloor\cdot (\lfloor\frac{A}{t}\rfloor+1)}{2}\cdot\frac{\lfloor\frac{B}{t}\rfloor\cdot (\lfloor\frac{B}{t}\rfloor+1)}{2}})^{\frac{C\cdot(C+1)}{2}}=(\prod_{t=1}^A(\prod_{d\mid t} d^{\mu(\frac{t}{d})\cdot t^2})^{\frac{\lfloor\frac{A}{t}\rfloor\cdot (\lfloor\frac{A}{t}\rfloor+1)}{2}\cdot\frac{\lfloor\frac{B}{t}\rfloor\cdot (\lfloor\frac{B}{t}\rfloor+1)}{2}})^{\frac{C\cdot(C+1)}{2}}$$

设$f(x)=(\prod_{d\mid x}x^{\cdot\mu(\frac{x}{d})})^{x^2}$，则$f(x)$可以预处理

原式可化为：

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(1)}=(\prod_{t=1}^A f(t)^{\frac{\lfloor\frac{A}{t}\rfloor\cdot (\lfloor\frac{A}{t}\rfloor+1)}{2}\cdot\frac{\lfloor\frac{B}{t}\rfloor\cdot (\lfloor\frac{B}{t}\rfloor+1)}{2}})^{\frac{C\cdot(C+1)}{2}}$$
直接整除分块即可
得分$60pts$

- $type=2$时
第一个式子：

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(2)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{\gcd(i,j,k)}=\prod_{i=1}^A i^{\sum_{j=1}^B\sum_{k=1}^C\gcd(i,j,k)}=\prod_{i=1}^A i^{\sum_{d=1}^B\sum_{j=1}^B\sum_{k=1}^C[\gcd(i,j,k)==d]\cdot d}=\prod_{i=1}^A i^{\sum_{d=1}^B\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k=1}^{\lfloor\frac{C}{d}\rfloor}[d\mid i][\gcd(\frac{i}{d},j,k)==1]\cdot d}=\prod_{i=1}^A i^{\sum_{d\mid i}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k=1}^{\lfloor\frac{C}{d}\rfloor}d\cdot (\sum_{r\mid\gcd(\frac{i}{d},j,k)}\mu(r))}=\prod_{i=1}^A i^{\sum_{d\mid i}\sum_{r\mid\frac{i}{d}}\sum_{j=1}^{\lfloor\frac{B}{r\cdot d}\rfloor}\sum_{k=1}^{\lfloor\frac{C}{r\cdot d}\rfloor}d\cdot \mu(r))}=\prod_{i=1}^A i^{\sum_{d\mid i}d\sum_{r\mid\frac{i}{d}}\mu(r)\sum_{j=1}^{\lfloor\frac{B}{r\cdot d}\rfloor}\sum_{k=1}^{\lfloor\frac{C}{r\cdot d}\rfloor}1}=\prod_{i=1}^A i^{\sum_{d\mid i}d\sum_{r\mid\frac{i}{d}}\mu(r)\cdot\lfloor\frac{B}{r\cdot d}\rfloor\cdot\lfloor\frac{C}{r\cdot d}\rfloor}$$

设$t=r\cdot d$，则有：

$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(2)}=\prod_{i=1}^A i^{\sum_{t\mid n}\lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor\sum_{d\mid t}(d\cdot\mu(\frac{t}{d}))}$$

由$\mu\cdot I=\epsilon$与$\varphi\cdot I=id$，可以简单推一下：
$$\varphi\cdot I=id \varphi\cdot I\cdot\mu=id\cdot\mu \varphi\cdot\epsilon=id\cdot\mu \varphi=id\cdot\mu \varphi(x)=\sum_{d\mid x} d\cdot\mu(\frac{x}{d})$$
因此带入原式得：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(2)}=\prod_{i=1}^A i^{\sum_{t\mid n}\lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor\varphi(t)}=\prod_{i=1}^A\prod_{t\mid i} i^{\varphi(t)\cdot \lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor}=\prod_{t=1}^A\prod_{i=1}^{\lfloor\frac{A}{t}\rfloor} (i\cdot t)^{\varphi(t)\cdot \lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor}$$
注意一下，这里$i$扩大$t$倍的原因是$i$的范围缩小了$t$
继续推：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(2)}=\prod_{t=1}^A(t^{\lfloor\frac{A}{t}\rfloor}\cdot\prod_{i=1}^{\lfloor\frac{A}{t}\rfloor}i)^{\varphi(t)\cdot \lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor}=\prod_{t=1}^A ((t^{\varphi(t)})^{\lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor}\cdot(\prod_{i=1}^{\lfloor\frac{A}{t}\rfloor}i)^{\varphi(t)\cdot\lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor})$$
设$fac(i)$为$i$的阶乘，则原式可化为：
$$\prod_{t=1}^A ((t^{\varphi(t)})^{\lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor}\cdot fac(\lfloor\frac{A}{t}\rfloor)^{\varphi(t)\cdot\lfloor\frac{B}{t}\rfloor\cdot\lfloor\frac{C}{t}\rfloor})$$
然后预处理+整除分块就可以解决了
第二个式子：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(2)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{\gcd(i,j,k)}$$
枚举$\gcd(i,j)$：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(2)}=\prod_{d=1}^A\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C[\gcd(i,j)==d]\cdot d^{\gcd(i,j,k)}=\prod_{d=1}^A d^{\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C[\gcd(i,j)==d]\cdot\gcd(i,j,k)}=\prod_{d=1}^A d^{\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k=1}^C[\gcd(i,j)==1]\cdot\gcd(d,k)}=\prod_{d=1}^A d^{\sum_{i=1}^{\lfloor\frac{A}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{d}\rfloor}\sum_{k=1}^C(\sum_{r\mid\gcd(i,j)}\mu(r))\cdot\gcd(d,k)}=\prod_{d=1}^A d^{\sum_{r=1}^{\lfloor\frac{A}{d}\rfloor}\mu(r)\sum_{i=1}^{\lfloor\frac{A}{r\cdot d}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{r\cdot d}\rfloor}\sum_{k=1}^C\gcd(d,k)}=\prod_{d=1}^A d^{\sum_{r=1}^{\lfloor\frac{A}{d}\rfloor}\mu(r)\cdot\lfloor\frac{A}{r\cdot d}\rfloor\cdot\lfloor\frac{B}{r\cdot d}\rfloor(\sum_{k=1}^C\gcd(d,k))}$$

设$t=r\cdot d$，则有：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(2)}=\prod_{t=1}^A\prod_{d\mid t}d^{\mu(\frac{t}{d})\cdot\lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor(\sum_{k=1}^C\gcd(d,k))}$$
我们将$\sum_{k=1}^C\gcd(d,k)$单独拿出推一下：
$$\sum_{k=1}^C\gcd(d,k)=\sum_{w\mid d}\sum_{k=1}^C[\gcd(d,k)==w]\cdot w=\sum_{w\mid d} w\sum_{k=1}^{\lfloor\frac{C}{w}\rfloor}[\gcd(\frac{d}{w},k)==1]=\sum_{w\mid d}w\sum_{k=1}^{\lfloor\frac{C}{w}\rfloor}\sum_{g\mid\gcd(\frac{d}{w},k)}\mu(g)=\sum_{w\mid d}w\sum_{g\mid\frac{d}{w}}\mu(g)\cdot\lfloor\frac{C}{w\cdot g}\rfloor$$
设$h=w\cdot g$，则有：
$$\sum_{k=1}^C\gcd(d,k)=\sum_{h\mid d}\sum_{w\mid h}w\cdot\mu(\frac{h}{w})\cdot\lfloor\frac{C}{h}\rfloor$$
由上面推出的$\varphi(x)=\sum_{d\mid x} d\cdot\mu(\frac{x}{d})$带入上式得
$$\sum_{k=1}^C\gcd(d,k)=\sum_{h\mid d}\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor$$
将其代入原式得：
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C i^{f(2)}=\prod_{t=1}^A\prod_{d\mid t}d^{\mu(\frac{t}{d})(\sum_{h\mid d}\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor)\cdot \lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor}=\prod_{t=1}^A\prod_{d\mid t}\prod_{h\mid d}d^{\mu(\frac{t}{d})\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor}$$
这里需要比较毒瘤将$d$拆成$\frac{d}{h}\cdot h$，我们先计算$\frac{d}{h}$的情况：
改变求和顺序并先后将$t$与$d$扩大$h$倍得原式可以化为：
$$\prod_{h=1}^A\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}\prod_{h\mid d,d\mid h\cdot t}\frac{d}{h}^{\mu(\frac{h\cdot t}{d})\cdot\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor}=\prod_{h=1}^A\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}\prod_{d\mid t}d^{\mu(\frac{h\cdot t}{d\cdot h})\cdot\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor}=\prod_{h=1}^A(\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}(\prod_{d\mid t}d^{\mu(\frac{t}{d})})^{\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor})^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor}$$
设$f(x)=\sum_{d\mid x}d^{\mu(\frac{x}{d})}$，则$f(x)$可在$O(n\log n)$的时间内预处理
则原式可化为
$$\prod_{h=1}^A(\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}f(t)^{\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor})^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor}$$
然后我们计算$h$的情况：
同样我们可以改变求和顺序，先后将$t$和$d$扩大$h$倍
$$\prod_{t=1}^A\prod_{d\mid t}\prod_{h\mid d}h^{\mu(\frac{t}{d})\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor}=\prod_{h=1}^A\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}\prod_{h\mid d,d\mid h\cdot t}
h^{\mu(\frac{h\cdot t}{d})\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor}=\prod_{h=1}^A\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}\prod_{d\mid t} h^{\mu(\frac{h\cdot t}{d\cdot h}\cdot\varphi(h))\cdot \lfloor\frac{C}{h}\rfloor\cdot\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor}=\prod_{h=1}^A\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}\prod_{d\mid t} h^{\mu(\frac{t}{d}\cdot\varphi(h))\cdot \lfloor\frac{C}{h}\rfloor\cdot\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor}$$
将求积改成指数求和得：
$$\prod_{t=1}^A\prod_{d\mid t}\prod_{h\mid d}h^{\mu(\frac{t}{d})\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor}=\prod_{h=1}^A h^{\sum_{t=1}^{\lfloor\frac{A}{h}\rfloor}\sum_{d\mid t}\mu(\frac{t}{d})\cdot\varphi(h)\cdot \lfloor\frac{C}{h}\rfloor\cdot\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor}=\prod_{h=1}^A h^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \sum_{t=1}^{\lfloor\frac{A}{h}\rfloor} \lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor\sum_{d\mid t}\mu(\frac{t}{d})}$$
由莫比乌斯反演$\mu\cdot I=\epsilon$得：
$$\prod_{t=1}^A\prod_{d\mid t}\prod_{h\mid d}h^{\mu(\frac{t}{d})\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \lfloor\frac{A}{t}\rfloor\cdot\lfloor\frac{B}{t}\rfloor}=\prod_{h=1}^A h^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \sum_{t=1}^{\lfloor\frac{A}{h}\rfloor} \lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor\epsilon(t)}=\prod_{h=1}^A h^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \sum_{t=1}^{\lfloor\frac{A}{h}\rfloor} [t==1]\cdot \lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor}=\prod_{h=1}^A h^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor\cdot \lfloor\frac{A}{h\cdot 1}\rfloor\cdot\lfloor\frac{B}{h\cdot 1}\rfloor}=\prod_{h=1}^A h^{\varphi(h)\cdot\lfloor\lfloor\frac{A}{h}\rfloor\cdot\lfloor\frac{B}{h}\rfloor\cdot\frac{C}{h}\rfloor}$$
故
$$\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(2)}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{\gcd(i,j,k)}=(\prod_{h=1}^A(\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}f(t)^{\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor})^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor})\cdot (\prod_{h=1}^A h^{\varphi(h)\cdot\lfloor\frac{A}{h}\rfloor\cdot\lfloor\frac{B}{h}\rfloor\cdot\lfloor\frac{C}{h}\rfloor})=\prod_{h=1}^A((\prod_{t=1}^{\lfloor\frac{A}{h}\rfloor}f(t)^{\lfloor\frac{A}{h\cdot t}\rfloor\cdot\lfloor\frac{B}{h\cdot t}\rfloor})^{\varphi(h)\cdot\lfloor\frac{C}{h}\rfloor}\cdot h^{\varphi(h)\cdot\lfloor\frac{A}{h}\rfloor\cdot\lfloor\frac{B}{h}\rfloor\cdot\lfloor\frac{C}{h}\rfloor})$$
（$f(x)=\sum_{d\mid x}d^{\mu(\frac{x}{d})}$）
```
#include<stdio.h>
const int maxn=100005;
long long i,j,k,m,n,T,p,A,B,C,l,r,cnt;
long long a[maxn],c[maxn],mu[maxn],varphi[maxn],fac1[maxn],fac2[maxn],w1[maxn],f1[maxn],g1[maxn],w2[maxn],f2[maxn],g2[maxn],w3[maxn],f3[maxn],g3[maxn],sum[maxn];
//a[i]={Prime},c[i]=[i\in{Prime}?]
//mu[i]=(i==1?)1:((i=\prod_{j=1}^s p_i,(p_x!=p_y(x!=y)))? 0:(-1)^s)
//fac1[i]=i!,fac2[i]=\prod_{j=1}^i i^i
//w1[i]=\prod_{d|i}i^{\mu(d/i)},f1[i]=\prod_{j=1}^i w1[i],g1[i]=f1[i]^{-1}
//w2[i]=w1[i]*(i^2),f2[i]=\prod_{j=1}^i w2[i],g2[i]=f2[i]^{-1}
//w3[i]=i^{\varphi(i)},f3[i]=\prod_{j=1]^i w3[i],g3[i]=f3[i]^{-1}
//sum[i]=\sum_{j=1}^i varphi[i]
inline long long min(long long a,long long b){
	return a<b? a:b;
}
long long ksm(long long a,long long b,long long p){
	long long res=1;
	while(b>0){
		if(b&1)
			res=(res*a)%p;
		a=(a*a)%p,b>>=1;
	}
	return res;
}
long long inv(long long a,long long b){
	return ksm(a,b-2,b);
}
void init(){
	c[1]=mu[1]=varphi[1]=1;
	for(long long i=2;i<maxn;i++){
		if(c[i]==0)
			a[++cnt]=i,mu[i]=-1,varphi[i]=i-1;
		for(long long j=1;j<=cnt;j++){
			if(i*a[j]>=maxn)
				break;
			c[i*a[j]]=1;
			if(i%a[j]==0){
				mu[i*a[j]]=0;
				varphi[i*a[j]]=varphi[i]*a[j];
				break;
			}
			mu[i*a[j]]=-mu[i];
			varphi[i*a[j]]=varphi[i]*(a[j]-1);
		}
	}
	fac1[0]=1;
	for(long long i=1;i<maxn;i++)
		fac1[i]=fac1[i-1]*i%p; 
	fac2[0]=1;
	for(long long i=1;i<maxn;i++)
		fac2[i]=fac2[i-1]*ksm(i,i%(p-1),p)%p; 
	for(long long i=0;i<maxn;i++)
		w1[i]=w2[i]=1;
	for(long long i=1;i<maxn;i++){
		if(mu[i]==0)
			continue;
		for(long long j=i;j<maxn;j+=i){
			if(mu[i]==1)
				w1[j]=(w1[j]*(j/i))%p;
			if(mu[i]==-1)
				w1[j]=(w1[j]*inv(j/i,p))%p;
		}
	}
	f1[0]=g1[0]=1;
	for(long long i=1;i<maxn;i++)
		f1[i]=f1[i-1]*w1[i]%p,g1[i]=inv(f1[i],p);
	for(long long i=1;i<maxn;i++)
		w2[i]=ksm(w1[i],i*i%(p-1),p);
	f2[0]=g2[0]=1;
	for(long long i=1;i<maxn;i++)
		f2[i]=f2[i-1]*w2[i]%p,g2[i]=inv(f2[i],p);
	for(long long i=1;i<maxn;i++)
		w3[i]=ksm(i,varphi[i],p);
	f3[0]=g3[0]=1;
	for(long long i=1;i<maxn;i++)
		f3[i]=f3[i-1]*w3[i]%p,g3[i]=inv(f3[i],p);
	for(long long i=1;i<maxn;i++)
		sum[i]=sum[i-1]+varphi[i];
}
inline long long getsum(long long x,long long p){
	return x*(x+1)/2%p;
}
long long getnmt(long long A,long long B,long long C,long long t){
	if(t==0){
		long long res=ksm(fac1[A],B*C%(p-1),p);
		return res;
	} 
	if(t==1){
		long long res=ksm(fac2[A],getsum(B,p-1)*getsum(C,p-1)%(p-1),p);
		return res;
	}
	if(t==2){
		long long l=1,r,res=1;
		while(l<=min(min(A,B),C)){
			r=min(min(A/(A/l),B/(B/l)),C/(C/l));
			res=res*ksm(f3[r]*g3[l-1]%p,(A/l)*(B/l)%(p-1)*(C/l)%(p-1),p)%p*ksm(fac1[A/l],(sum[r]-sum[l-1]+(p-1))%(p-1)*(B/l)%(p-1)*(C/l)%(p-1),p)%p;
			l=r+1;
		}
		return res;
	}
}
long long getres(long long A,long long B){
	long long l=1,r,res=1;
	while(l<=min(A,B)){
		r=min(A/(A/l),B/(B/l));
		res=res*ksm(f1[r]*g1[l-1]%p,(A/l)*(B/l)%(p-1),p)%p;
		l=r+1;
	}
	return res;
}
long long getdmt(long long A,long long B,long long C,long long t){
	if(t==0){ 
		long long l=1,r,res=1;
		while(l<=min(A,B)){
			r=min(A/(A/l),B/(B/l));
			res=(res*ksm(f1[r]*g1[l-1]%p,(A/l)*(B/l)%(p-1),p))%p;
			l=r+1;
		}
		return ksm(res,C,p);
	}
	if(t==1){
		long long l=1,r,res=1;
		while(l<=min(A,B)){
			r=min(A/(A/l),B/(B/l));
			res=(res*ksm(f2[r]*g2[l-1]%p,getsum(A/l,p-1)*getsum(B/l,p-1)%(p-1),p))%p;
			l=r+1;
		}
		return ksm(res,getsum(C,p-1),p);
	}
	if(t==2){
		long long l=1,r,res=1;
		while(l<=min(min(A,B),C)){
			r=min(min(A/(A/l),B/(B/l)),C/(C/l));
			res=res*ksm(getres(A/l,B/l),(sum[r]-sum[l-1]+(p-1))%(p-1)*(C/l)%(p-1),p)%p*ksm(f3[r]*g3[l-1]%p,(A/l)*(B/l)%(p-1)*(C/l)%(p-1),p)%p;
			l=r+1;
		}
		return res;
	}
}
long long getans(long long A,long long B,long long C,long long t){
	long long nmt=getnmt(A,B,C,t)*getnmt(B,A,C,t)%p,dmt=getdmt(A,B,C,t)*getdmt(A,C,B,t)%p;
	return nmt*inv(dmt,p)%p;
}
int main(){
	scanf("%lld%lld",&T,&p);
	init();
	while(T--){
		scanf("%lld%lld%lld",&A,&B,&C);
		printf("%lld %lld %lld\n",getans(A,B,C,0),getans(A,B,C,1),getans(A,B,C,2)); 
	}
	return 0;
}
```

---

## 作者：Mobius127 (赞：1)

5 月开的，现在写完。。。~~足以显示我有多咕~~

[题目传送门](https://www.luogu.com.cn/problem/P5518)

提前开坑？

约定: 

1. 如无特殊说明，本文的 $n$ 为 $ABC$ 的值域范围。

1. 假定 $sum(x)=\sum_{y=1}^{x} y$ 。

1. 由于不想炸掉 $\LaTeX$ ，把一部分整除的直接写成了除法。

1. 函数 $\varepsilon(x)=[x=1]$ 直接简写成 $[x]$ 。 

$\operatorname{lcm}$ 不好搞，先把柿子拆开。

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} (\frac{i \times j}{\gcd(i, j) \times \gcd(i, k)})^{f(type)}$$

再把 幂 给套开。

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \frac{(i \times j)^{f(type)}}{[\gcd(i, j) \times \gcd(i, k)]^{f(type)}} $$

再把连乘积放进分数里面（连乘积有个好处就是分子分母可以拆开来计算贡献）。

$$\frac{\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}(i \times j)^{f(type)}}{\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}[\gcd(i, j) \times \gcd(i, k)]^{f(type)}}$$

显然可以把分母看成两个类似于这样的东西相乘：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i, j)^{f(type)}$$

同时，分子也可以类似同化：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i ^{f(type)}$$

那么，我们只要计算出分子和分母的值，再用分子乘上分母的逆元即可。

~~但是并没有到很重要的环节~~

直接分 $type$ 去推柿子！！1

### Segment 1: $type=0$

考虑分子：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{1}$$

显然每个 $i$ 都被乘了 $B \times C$ 次。

那么就是 $\prod_{i=1}^{A} i^{B \times C} = (A!)^{B \times C}$ 。

预处理阶乘后快速幂可做到 $\log n$ 。

再看分母：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i, j)^{1}=\prod_{i=1}^{A}\prod_{j=1}^{B} \gcd(i, j)^{C}$$

带着幂并不好推，把 $C$ 提出。

$$(\prod_{i=1}^{A}\prod_{j=1}^{B} \gcd(i, j))^{C}$$

然后就变成了莫反基本套路。


$$\Large  \left ({\normalsize \prod_{d=1} d }^{\sum_{d'=1} \mu(d') \left \lfloor \frac{A}{dd'} \right \rfloor \left \lfloor \frac{B}{dd'} \right \rfloor }   \right ) ^{C}$$

来一发 $T=dd'$ 。

$${\Large \left ( \prod_{T=1}{\large \left ( {\normalsize \prod_{d|T} d^{\mu(T/d)}}  \right ) }^{\left \lfloor \frac{A}{T} \right \rfloor \left \lfloor \frac{B}{T} \right \rfloor }   \right ) }^C $$


注意到第二对括号里的东西对于每一个 $T$ 是一定的，可以 $O(n \ln n)$ 筛出来。

即令 $f(T)=\prod_{d|T} d^{\mu(T/d)}$

预处理完后就可以愉快地跑整除分块$O(\sqrt{n} \log n)$啦~


### Segment 2: $type=1$

考虑分子：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{i \times j \times k}$$

显然这个 $j,k$ 可以提出。

$$\prod_{i=1}^{A} i^{i \times sum(B) \times sum(C) }=(\prod_{i=1}^{A} i^{i})^{sum(B) \times sum(C)}$$

预处理出括号内的东西后套个快速幂，时间复杂度 $O(\log n)$。

再看分母：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i, j)^{i \times j \times k}={\Large \left ({\normalsize \prod_{i=1}^{A}\prod_{j=1}^{B} \gcd(i, j)^{i \times j}}   \right ) } ^{sum(C)}$$

扔掉外面的幂，继续推里面的，都是莫反的基本套路了。

$$\prod_{d=1}^{A}\prod_{i=1}^{A/d}\prod_{j=1}^{B/d} d^{ij \times d^2 [gcd(i,j)]}$$

第三个 $\prod$ 可以拆掉。

$$\prod_{d=1}^{A}\prod_{i=1}^{A/d}d^{\mu(i) \times d^2 \times i^2 \times sum(A/di) \times sum(B/di)}$$

熟悉的连乘项 $T=di$ 。

$$\prod_{T=1}^{A} {\Large \left ({\large \left ({\normalsize \prod_{d|T} d^{\mu(T/d)}}   \right )^{T^2} }  \right ) ^{sum(A/T) \times sum(B/T)}} $$

看到了吗！我们之前出的 $f(T)$ 出现了！！1

$$\prod_{T=1}^{A} { \left (f(T)^{T^2}  \right ) ^{sum(A/T) \times sum(B/T)}} $$


同样多预处理一个平方就可以做到单次 $O(\sqrt{n} \log n)$ 了。

**不要忘记我们之前丢掉的幂！！1**


### Segment 3: $type=2$

**提前 FBI WARNING。**

考虑分子：

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i^{\gcd(i,j,k)}$$

$$\prod_{i=1}^{A}i^{\sum_{j=1}^{B}\sum_{k=1}^{C}\gcd(i,j,k)}$$

滚过去看指数。

$$\sum_{i=1}^{B}\sum_{j=1}^{C}\gcd(n,i,j)$$

大力枚举 $\gcd(i, j, n)$

$$\sum_{d=1}d\sum_{i=1}^{B/d}\sum_{j=1}^{C/d}[\gcd(i, j, n/d][d|n]$$

$[d|n]$ 很烦，扔到外面。

$$\sum_{d|n}d\sum_{i=1}^{B/d}\sum_{j=1}^{C/d}[\gcd(i, j, n/d)]=\sum_{d|n}d\sum_{dd'|n}^{B} \mu(d') \left \lfloor \frac{B}{dd'} \right \rfloor \left \lfloor \frac{C}{dd'} \right \rfloor $$

梅开 n 度 ...

$$\sum_{T|n}\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \sum_{d|T} \mu(d) (T/d)$$

第二个 $\sum$ 其实就是欧拉反演 $\varphi = \mu * id$ 。

$$\sum_{T|n}\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \varphi(T)$$ 

把这东西代回去。

$$\prod_{i=1}^{A}i^{\sum_{T|i}\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \varphi(T)}$$

把 $\sum$ 放下来变成 $\prod$ 。

$$\prod_{i=1}^{A}\prod_{T|i}i^{\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \varphi(T)}$$

$T$ 在里面计算很难，不妨改变枚举顺序，枚举 $T$ 后枚举其倍数：

$$\prod_{T=1}^{A}(T^{\left \lfloor \frac{A}{T} \right \rfloor } \times \prod_{i=1}^{\left \lfloor \frac{A}{T} \right \rfloor } i) ^{\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \varphi(T)}$$

里面的 $\prod$ 可以化为阶乘。

$$\prod_{T=1}^{A}(T^{\varphi(T)} ) ^{\left \lfloor \frac{A}{T} \right \rfloor \left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor }\times (\left \lfloor \frac{A}{T} \right \rfloor !)^{\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \varphi(T)}$$

预处理一波 $\varphi$ 的前缀和以及 $\varphi$ 的指数幂即可 $O(\sqrt{n}\log n)$ 啦。

接下来是最恐怖的柿子。。。

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i, j)^{\gcd(i,j,k)}$$

考虑枚举 $\gcd(i,j,k)$ 。

由于 $\gcd(i, j, k)=\gcd(\gcd(i, j), k)$，所以我们枚举 $\gcd(i, j)$。

$$=\prod_{d=1}^{A} d^{\sum_{i=1}^{A} \sum_{j=1}^{B}[\gcd(i, j)=d]\times (\sum_{k=1}^{C}\gcd(d, k))}$$

显然幂的指数珂以分开计，套路变换不多说。。。

$$=\prod_{d=1}^{A} d^{(\sum_{i=1}^{A/d} \sum_{j=1}^{B/d}[\gcd(i, j)]) \times (\sum_{k=1}^{C}\gcd(d, k))}$$

$$=\prod_{d=1}^{A} d^{(\sum_{d'|\min(A/d, B/d)} \mu(d') \left \lfloor \frac{A}{dd'} \right \rfloor  \left \lfloor \frac{B}{dd'} \right \rfloor ) \times (\sum_{k=1}^{C}\gcd(d, k))}$$

这里有个很妙的一个点：将 $\sum$ 下放，仍然是 $T=dd'$。

$$=\prod_{T=1}^{A} (\prod_{d|T} d^{\mu(T/d) \times \sum_{k=1}^{C}\gcd(d, k)})^{\left \lfloor \frac{A}{T} \right \rfloor  \left \lfloor \frac{B}{T} \right \rfloor }$$

对于右上角的 $\sum_{k=1}^{C}\gcd(d, k)$，右转去 [这里](https://www.luogu.com.cn/problem/P2303) $=\sum_{d'|d} \left \lfloor \frac{C}{d'} \right \rfloor \varphi(d')$，套回去并同样将 $\sum$ 下放。

$$=\prod_{T=1}^{A} (\prod_{d|T} \prod_{d'|d}d^{\mu(T/d) \times \left \lfloor \frac{C}{d'} \right \rfloor \varphi(d')})^{\left \lfloor \frac{A}{T} \right \rfloor  \left \lfloor \frac{B}{T} \right \rfloor }$$

这里有个阴间的做法：把 $d$ 变成 $d' \times \frac{d}{d'}$。

对于 $d'$：

$$\prod_{T=1}^{A} (\prod_{d|T} \prod_{d'|d} d'^{\mu(T/d) \times \left \lfloor \frac{C}{d'} \right \rfloor \varphi(d')})^{\left \lfloor \frac{A}{T} \right \rfloor  \left \lfloor \frac{B}{T} \right \rfloor }$$

枚举 $T=d'$

$$=\prod_{T=1}^{A} T^{\varphi(T)\left \lfloor \frac{C}{T} \right \rfloor\sum_{d=1}^{A/T} \left \lfloor \frac{A}{Td} \right \rfloor \left \lfloor \frac{B}{Td} \right \rfloor \sum_{d'|d} \mu(d')}$$

注意到最后一个东西实际上是莫反经典柿子，当 $d=1$ 时候才有效。

于是柿子就变成了：

$$=\prod_{T=1}^{A} T^{\varphi(T)\left \lfloor \frac{C}{T} \right \rfloor \left \lfloor \frac{A}{T} \right \rfloor \left \lfloor \frac{B}{T} \right \rfloor }$$

这玩意跟分子的第一块约掉了（忘记了就回去康康）。

对于 $\frac{d}{d'}$：

$$\prod_{T=1}^{A} (\prod_{d|T} \prod_{d'|d} (\frac{d}{d'})^{\mu(T/d) \times \left \lfloor \frac{C}{d'} \right \rfloor \varphi(d')})^{\left \lfloor \frac{A}{T} \right \rfloor  \left \lfloor \frac{B}{T} \right \rfloor }$$

这里有个更阴间的操作：将 $T$ 和 $d$ 同时乘上 $d'$。

$$=\prod_{d'=1}^{A}\prod_{T=1}^{A/d'}\prod_{d|T} d^{\mu(T/d)\varphi(d')\left \lfloor \frac{A}{T} \right \rfloor \left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{d'} \right \rfloor }$$

你发现其中有个东西是我们之前得到的 $f$。

$$=\prod_{T=1}^{A}(\prod_{d=1}^{A/T} f(d)^{\left \lfloor \frac{A}{Td} \right \rfloor \left \lfloor \frac{B}{Td} \right \rfloor })^{\varphi(T)\left \lfloor \frac{C}{T} \right \rfloor }$$

套两个整除分块，$\left \lfloor \frac{A}{T} \right \rfloor$ 最大到 $\sqrt{n}$，那么里面的数论分块就是 $n^{0.25}$

这样就是 $O(n^{0.75} \log n)$。

整理一下之前的东西。

需要预处理的：

$f(T)=\prod_{d|T} d^{\mu(T/d)}$

$f_2(T)=f(T)^{T^2}$

$F(T)=\prod_{i=1}^{T}i^i$

$F_2(T)=(\prod_{i=1}^{T}i)^{\varphi(T)}$

$sum(T)=\sum_{i=1}^{T} i$

$fac(T)=T!$

---
接下来与题解无关，单纯是小技巧。

首先回到开头，我们用以下东西来表示：

$$G(A, B, C)=\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} \gcd(i, j)^{f(type)}$$

$$H(A,B,C)=\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C} i ^{f(type)}$$

那么答案就是：

$$\frac{H(A,B,C) \times H(B,A,C)}{G(A,B,C) \times G(A,C,B)}$$

写个函数就可以大大减少码量（虽然我知道是个人都会）。

---

我们再来梳理一下要求的东西。

$H_0(A,B,C)=fac(A)^{B \times C}$

$G_0(A,B,C)={\large \left ( \prod_{T=1}{\large \left ( {\normalsize f(T}  \right ) }^{\left \lfloor \frac{A}{T} \right \rfloor \left \lfloor \frac{B}{T} \right \rfloor }   \right ) }^C$

$H_1(A,B,C)=F(A)^{sum(B) \times sum(C)}$

$G_1(A,B,C)=(\prod_{T=1}^{A} f_2(T)^{sum(A/T) \times sum(B/T)})^{sum(C)} $

$H_2(A,B,C)=(\left \lfloor \frac{A}{T} \right \rfloor !)^{\left \lfloor \frac{B}{T} \right \rfloor \left \lfloor \frac{C}{T} \right \rfloor \varphi(T)}$

$G_2(A,B,C)=\prod_{T=1}^{A}(\prod_{d=1}^{A/T} f(d)^{\left \lfloor \frac{A}{Td} \right \rfloor \left \lfloor \frac{B}{Td} \right \rfloor })^{\varphi(T)\left \lfloor \frac{C}{T} \right \rfloor }$

放一下窝的屎山代码。。。。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
signed P;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int mod(int x, int mos){
	x=(x%mos+mos)%mos;
	return x;
}
inline int ksm(int a, int b, int mos){
	int ret=1;b=mod(b, mos-1);
	for(; b; b>>=1, a=1ll*a*a%mos)
		if(b&1) ret=1ll*ret*a%mos;
	return ret;
}
namespace Solution{
	const int N=1e5+1e3;
	int mu[N], phi[N], u[N], st[N], top;
	int fac[N], f[N], f_inv[N], F[N], f2[N], f2_inv[N];
	void pre(int n){
		fac[0]=1, mu[1]=1, phi[1]=1;
		for(int i=1; i<=n; i++)
			fac[i]=1ll*fac[i-1]*i%P;
		for(int i=2; i<=n; i++){
			if(!u[i]){st[++top]=i, mu[i]=-1, phi[i]=i-1;}
			for(int j=1; j<=top&&1ll*i*st[j]<=n; j++){
				u[i*st[j]]=1;
				if(i%st[j]==0){mu[i*st[j]]=0, phi[i*st[j]]=phi[i]*st[j];break;} 
				mu[i*st[j]]=-mu[i], phi[i*st[j]]=phi[i]*phi[st[j]];
			}
		}
		for(int i=0; i<=n; i++)
			f[i]=f2[i]=1;
		f_inv[0]=f2_inv[0]=1;
		for(int j=1; j<=n; j++)
			if(mu[j]) //小剪枝 
				for(int i=j; i<=n; i+=j)
					f[i]=1ll*f[i]*ksm(i/j, mu[j], P)%P;
		for(int i=0; i<=n; i++)
			F[i]=ksm(i, i, P),
			f2[i]=ksm(f[i], 1ll*i*i%(P-1), P);
		for(int i=1; i<=n; i++)
			f[i]=1ll*f[i]*f[i-1]%P, f_inv[i]=ksm(f[i], P-2, P),
			f2[i]=1ll*f2[i]*f2[i-1]%P, f2_inv[i]=ksm(f2[i], P-2, P),
			F[i]=1ll*F[i]*F[i-1]%P, phi[i]=mod(phi[i]+phi[i-1], P-1);
//		for(int i=99998; i<=100000; i++)
//			printf(">>>>>>f2[%lld]=%lld\n", i, f2[i]);
		return ;
	}
	int sum(int S, int mos){
		if(S&1) return 1ll*(S+1)/2*S%mos;
		return 1ll*S/2*(S+1)%mos;
	}
	inline int H0(int A, int B, int C){
//	printf("fac[%lld]=%lld\n", A, fac[A]); 
		return ksm(fac[A], B*C%(P-1), P);
	}
	inline int G0(int A, int B, int C){
		int ret=1, t=min(A, B);
		for(int l=1, r; l<=t; l=r+1){
			r=min(A/(A/l), B/(B/l));
			int tmp=1ll*f[r]*f_inv[l-1]%P;
			tmp=ksm(tmp, (A/l)*(B/l)%(P-1), P);
//			if(ret==0) printf("find 0 at %lld\n", l);
			ret=1ll*ret*tmp%P;
		}
		return ksm(ret, C, P);
	}
	inline int H1(int A, int B, int C){
		return ksm(F[A], 1ll*sum(B, P-1)*sum(C, P-1)%(P-1), P);
	}
	inline int G1(int A, int B, int C){
		int ret=1, t=min(A, B);
		for(int l=1, r; l<=t; l=r+1){
			r=min(A/(A/l), B/(B/l));
			int tmp=1ll*f2[r]*f2_inv[l-1]%P;
			tmp=ksm(tmp, 1ll*sum(A/l, P-1)*sum(B/l, P-1)%(P-1), P);
//			if(ret==0) printf("find 0 at %lld\n", l);
			ret=1ll*ret*tmp%P;
		}
		return ksm(ret, sum(C, P-1), P);
	}
	inline int H2(int A, int B, int C){
		int ret=1, t=min(A, min(B, C));
		for(int l=1, r; l<=t; l=r+1){
			r=min(A/(A/l), min(B/(B/l), C/(C/l)));
			int tmp=1ll*(B/l)*(C/l)%(P-1)*mod(phi[r]-phi[l-1], P-1)%(P-1);
			tmp=ksm(fac[A/l], tmp, P);
			ret=1ll*ret*tmp%P;
		}
		return ret;
	}
	int zcfk(int A, int B){
		int ret=1, t=min(A, B);
    	for(int l=1, r=0; l<=t; l=r+1){
        	r=min(A/(A/l), B/(B/l));
        	int tmp=ksm(1ll*f[r]*f_inv[l-1]%P, 1ll*(A/l)*(B/l)%(P-1), P);
        	ret=1ll*ret*tmp%P;
    	}
//		printf("--%lld\n", ret);
		return ret;
	}
	inline int G2(int A, int B, int C){
		int ret=1, t=min(A, min(B, C));
    	for(int l=1, r=0; l<=t; l=r+1){
        	r=min(A/(A/l), min(B/(B/l), C/(C/l)));
        	int tmp=ksm(zcfk(A/l, B/l), 1ll*mod(phi[r]-phi[l-1], P-1)*(C/l)%(P-1), P);
			ret=1ll*ret*tmp%P;
    	}
		return ret;
	}
	int type1(int A, int B, int C){
		int ret=1ll*H0(A, B, C)*H0(B, A, C)%P;
		int rem=1ll*G0(A, B, C)*G0(A, C, B)%P;
		return mod(1ll*ret*ksm(rem, P-2, P)%P, P);
	}
	int type2(int A, int B, int C){
		int ret=1ll*H1(A, B, C)*H1(B, A, C)%P;
		int rem=1ll*G1(A, B, C)*G1(A, C, B)%P;//printf("rem:%lld\n", rem);
		return mod(1ll*ret*ksm(rem, P-2, P)%P, P);
	}
	int type3(int A, int B, int C){
		int ret=1ll*H2(A, B, C)*H2(B, A, C)%P;
		int rem=1ll*G2(A, B, C)*G2(A, C, B)%P;//printf("rem:%lld\n", rem);
		return mod(1ll*ret*ksm(rem, P-2, P)%P, P);
		return 0;
	}
	signed work(){
		int T=read();P=read();
		pre(100000);
//		printf("--%lld %lld\n", fac[99999], fac[99998]);
		for(int i=1; i<=T; i++){
			int A=read(), B=read(), C=read();
			printf("%lld %lld %lld\n", type1(A, B, C), type2(A, B, C), type3(A, B, C));
		}
		return 0;
	}
}

signed main(){
	Solution :: work();
	return 0;
}
/*
1 998244353
99998 99999 100000
99998 100000 99999
99999 99998 100000
99999 100000 99998
100000 99998 99999 
100000 99999 99998  
*/

```
















---

## 作者：FjswYuzu (赞：1)

推式子题就应该直接来。

推荐到博客去看，因为我不知道会不会有渲染 bug（ [Link](https://www.luogu.com.cn/blog/blog10086001/solution-p5518)

### $type=0$

$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\\

\begin{aligned}
&= \prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \dfrac{ij}{\gcd(i,j)\gcd(i,k)} \\
&= \prod_{i=1}^A i \prod_{j=1}^B j \prod_{k=1}^C \dfrac{1}{\gcd(i,j)\gcd(i,k)} \\
&= (A!)^{BC} (B!)^{AC} \left( \prod_{i=1}^A \prod_{j=1}^B \dfrac{1}{\gcd(i,j)} \right)^C\cdot \left(\prod_{i=1}^{A} \prod_{k=1}^C \dfrac{1}{\gcd(i,k)}\right)^B \\
&= (A!)^{BC} (B!)^{AC} \left(\dfrac{1}{G(A,B)}\right)^C\cdot \left(\dfrac{1}{G(A,C)}\right)^B
\end{aligned}
$$

其中：
$$
G(n,m)\\
\begin{aligned}
&= \prod_{i=1}^n \prod_{j=1}^m \gcd(i,j) \\
&= \prod_{d=1}^{n}d^{\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \sum_{D|\gcd(i,j)} \mu(D)} \\
&= \prod_{d=1}^n d^{\sum_{D=1}^{\lfloor \frac{n}{d} \rfloor} \mu(D) \lfloor \frac{n}{dD} \rfloor \lfloor \frac{m}{dD} \rfloor} \\
&= \prod_{T=1}^n \left(\prod_{d|T} d^{\mu\left( \frac{T}{d} \right)}\right)^{{ \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}}
\end{aligned}
$$
令 $f(T) = \prod_{d|T} d^{\mu\left(\frac{T}{d}\right)}$，这个东西可以直接枚举倍数预处理，滚个前缀积就可以整除分块做了。

### $type=1$

$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \left( \dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)} \right)^{ijk} \\
\begin{aligned}
&= \prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \left( \dfrac{ij}{\gcd(i,j)\gcd(i,k)} \right)^{ijk} \\
&= \prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C ij^{ijk} \cdot \left( \dfrac{1}{\gcd(i,j)} \right)^{ijk} \left( \dfrac{1}{\gcd(i,k)} \right)^{ijk} \\
\end{aligned}
$$

显然这个式子里三个东西独立。又因为后面两个东西本质相同，考虑分成两类计算。定义 $S(x) = \dfrac{x(x+1)}{2}$。

#### Sub 1

$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C ij^{ijk} \\
\begin{aligned}
&=\left(\prod_{i=1}^A i^i\right)^{S(B)S(C)} \cdot \left(\prod_{j=1}^B j^j\right)^{S(A)S(C)}
\end{aligned}
$$

对于这个东西，处理 $i^i$，用快速幂预处理滚个前缀积即可。注意 $i,j$ 都有贡献。

#### Sub 2

分析一个即可。根据上面的推导可以直接得到简单结论。显然 $\dfrac{1}{\gcd(i,j)} = \gcd(i,j)^{-1}$，到时候求个逆也简单。
$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \gcd(i,j)^{ijk} \\
\begin{aligned}
&= \left(\prod_{i=1}^A \prod_{j=1}^B \gcd(i,j)^{ij}\right)^{S(C)} \\
&= \left( \prod_{d=1}^{A} d^{d^2 \sum_{i=1}^{\lfloor \frac{A}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{B}{d}\rfloor} \sum_{D|\gcd(i,j)} \mu(D)}\right)^{S(C)} \\
&= \left( \prod_{d=1}^A d^{d^2\sum_{D=1}^{\lfloor\frac{A}{d}\rfloor}\mu(D) D^2 \lfloor \frac{A}{dD} \rfloor\lfloor \frac{B}{dD} \rfloor} \right)^{S(C)} \\
&= \left( \prod_{T=1}^A \left(\left(\prod_{d|T} d^{\mu(\frac{T}{d})}\right)^{T^2}\right)^{S(\lfloor \frac{A}{T} \rfloor)S(\lfloor \frac{B}{T} \rfloor)} \right)^{S(C)} \\
&= \left( \prod_{T=1}^A\left( f(T)^{T^2}\right)^{S(\lfloor \frac{A}{T} \rfloor)S(\lfloor \frac{B}{T} \rfloor)} \right)^{S(C)}
\end{aligned}
$$
发现 $f(T)$ 早在二十年之前就已经预处理过了，定义 $g(T) = f(T)^{T^2}$，显然这个东西也可以预处理。一样的套路滚个前缀积可以完成这个问题。

于是对于这个东西完成一个函数，到时候只需要改变一下传参即可。一定要注意取逆元。

### $type=2$

$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \left( \dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)} \right)^{\gcd(i,j,k)} \\
\begin{aligned}
&= \prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \left( \dfrac{ij}{\gcd(i,j)\gcd(i,k)} \right)^{\gcd(i,j,k)} \\
&= \prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C ij^{\gcd(i,j,k)} \cdot \left( \dfrac{1}{\gcd(i,j)}\right)^{\gcd(i,j,k)} \cdot\left( \dfrac{1}{\gcd(i,k)}\right)^{\gcd(i,j,k)}
\end{aligned}
$$

一样的套路，三者互不干扰，拆开看。

#### Sub 1

$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C i^{\gcd(i,j,k)} \\
\begin{aligned}
&=\prod_{d=1}^{A} \prod_{i=1}^{\lfloor \frac{A}{d} \rfloor} (id)^{d\sum_{j=1}^B \sum_{k=1}^C [\gcd(i,j,k)=1]} \\
&=\prod_{d=1}^A\prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} \prod_{i=1}^{\lfloor \frac{A}{dD} \rfloor} (Did)^{\mu(D) d \lfloor \frac{B}{dD} \rfloor \lfloor \frac{C}{dD} \rfloor} \\
&=\prod_{T=1}^A \left(\prod_{i=1}^{\lfloor \frac{A}{T} \rfloor}(Ti)^{\sum_{d|T} \mu(d) \frac{T}{d}}\right)^{ \lfloor \frac{B}{T} \rfloor\lfloor \frac{C}{T} \rfloor} \\
&=\prod_{T=1}^A \left(\left( \left\lfloor\dfrac{A}{T}\right\rfloor!T^{\lfloor \frac{A}{T} \rfloor} \right)^{\sum_{d|T} \mu(d) \frac{T}{d}}\right)^{\lfloor \frac{B}{T} \rfloor \lfloor \frac{C}{T} \rfloor}
\end{aligned}
$$

注意到 $\sum_{d|T} \mu(d) \frac{T}{d}$ 实质上是 $\mu * id$，又知道 $\varphi = \mu * id$，所以有：
$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C i^{\gcd(i,j,k)} \\
\begin{aligned}
&=\prod_{T=1}^A \left(\left( \left\lfloor\dfrac{A}{T}\right\rfloor! T^{\lfloor \frac{A}{T} \rfloor} \right)^{\varphi(T)}\right)^{\lfloor \frac{B}{T} \rfloor \lfloor \frac{C}{T} \rfloor} \\
&= \prod_{T=1}^A \left( \left(\left\lfloor\dfrac{A}{T} \right\rfloor!\right)^{\varphi(T)} \cdot \left(T^{\varphi(T)}\right)^{\lfloor \frac{A}{T} \rfloor} \right)^{\lfloor \frac{B}{T} \rfloor \lfloor \frac{C}{T} \rfloor} \\
&= \prod_{T=1}^A \left( \left(\left\lfloor\dfrac{A}{T} \right\rfloor!\right)^{\lfloor \frac{B}{T} \rfloor \lfloor \frac{C}{T} \rfloor} \right)^{\varphi(T)}\cdot \left(T^{\varphi(T)}\right)^{\lfloor \frac{A}{T} \rfloor\lfloor \frac{B}{T} \rfloor\lfloor \frac{C}{T} \rfloor} 
\end{aligned}
$$
现在可以分成两段进行整除分块了。具体做法是，预处理 $\varphi(i)$ 的前缀和向 $p-1$ 取模的值（因为是指数），以及 $h(x) = x^{\varphi(x)}$ 的前缀积即可。

#### Sub 2

一样到时候取个逆元就行了。考虑枚举 $\gcd(i,j)$。
$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \gcd(i,j)^{\gcd(i,j,k)} \\
\begin{aligned}
&=\prod_{d=1}^A \left( d^{\sum_{i=1}^{\lfloor \frac{A}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{B}{d} \rfloor} [\gcd(i,j)=1]}\right)^{\sum_{k=1}^C \gcd(d,k)} \\
&=\prod_{d=1}^A \left( d^{\sum_{i=1}^{\lfloor \frac{A}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{B}{d} \rfloor} \sum_{D|\gcd(i,j)} \mu(D)}\right)^{\sum_{k=1}^C \gcd(d,k)} \\
&=\prod_{d=1}^A \left( d^{\sum_{D=1}^{\lfloor \frac{A}{d} \rfloor}\mu(D) \left\lfloor \frac{A}{dD} \right\rfloor \left\lfloor \frac{B}{dD} \right\rfloor} \right)^{\sum_{k=1}^C \gcd(d,k)} \\
&=\prod_{T=1}^A \left(\prod_{d|T}  d^{ \mu\left(\frac{T}{d}\right) \sum_{k=1}^C \gcd(d,k)}\right)^{\left\lfloor \frac{A}{T} \right\rfloor\left\lfloor \frac{B}{T} \right\rfloor}
\end{aligned}
$$
显然这个指数是不优美的。提出来慢慢搞：
$$
\sum_{k=1}^C \gcd(d,k) \\
\begin{aligned}
&= \sum_{D|d}D \sum_{k=1}^{\lfloor \frac{C}{D} \rfloor} [\gcd(\tfrac{d}{D},k)=1] \\
&= \sum_{D|d}D \sum_{k=1}^{\lfloor \frac{C}{D} \rfloor} \sum_{e|\gcd(\tfrac{d}{D},k)} \mu(e) \\
&= \sum_{D|d}D \sum_{e| \frac{d}{D}} \mu(e) \left\lfloor \dfrac{C}{eD} \right\rfloor \\
&= \sum_{t|d} \left\lfloor \dfrac{C}{t} \right\rfloor \sum_{D|t} \mu\left(\frac{t}{D}\right) D
\end{aligned}
$$
发现 $\sum_{D|t} \mu\left(\dfrac{t}{D}\right)D$ 又是 $\mu*id=\varphi$，可以写成：
$$
\sum_{t|d} \left\lfloor \dfrac{C}{t} \right\rfloor \sum_{D|t} \mu\left(\frac{t}{D}\right) D \\
\begin{aligned}
&=\sum_{t|d} \left\lfloor \dfrac{C}{t} \right\rfloor \varphi(t)
\end{aligned}
$$
 

将其带回：
$$
\prod_{T=1}^A \prod_{d|T}\left(  d^{ \mu\left(\frac{T}{d}\right)\left\lfloor \frac{A}{T} \right\rfloor\left\lfloor \frac{B}{T} \right\rfloor }\right)^{\sum_{k=1}^C \gcd(d,k)} \\
\begin{aligned}
&=\prod_{T=1}^A \left(\prod_{d|T}  d^{ \mu\left(\frac{T}{d}\right) \sum_{t|d} \left\lfloor \frac{C}{t} \right\rfloor \varphi(t)}\right)^{\left\lfloor \frac{A}{T} \right\rfloor\left\lfloor \frac{B}{T} \right\rfloor}
\end{aligned}
$$
其实这样已经可以做到 $O(Tn \log n)/O(T n \ln n)$ 了。但是因为常数原因抽不了烟。有人去尝试了……

正解是枚举 $\gcd(i,j,k)$，式子可以写成：
$$
\prod_{i=1}^A \prod_{j=1}^B \prod_{k=1}^C \gcd(i,j)^{\gcd(i,j,k)} \\
\begin{aligned}
&=\prod_{d=1}^A \prod_{i=1}^{\lfloor \frac{A}{d} \rfloor} \prod_{j=1}^{\lfloor \frac{B}{d} \rfloor} \left(d \cdot \gcd(i,j)\right)^{d \sum_{k=1}^{\lfloor \frac{C}{d} \rfloor} [\gcd(i,j,k)=1]} \\
&=\prod_{d=1}^A \prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} \prod_{i=1}^{\lfloor \frac{A}{dD} \rfloor}\prod_{j=1}^{\lfloor \frac{B}{dD} \rfloor} \left( dD\cdot\gcd(i,j) \right)^{d \mu(D) \lfloor \frac{C}{dD} \rfloor} \\
&=\left(\prod_{d=1}^{A} \prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} d D\right)^{d \mu(D) \lfloor \frac{A}{dD} \rfloor\lfloor \frac{B}{dD} \rfloor\lfloor \frac{C}{dD} \rfloor} \cdot \left( \prod_{d=1}^A \prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} \prod_{i=1}^{\lfloor \frac{A}{dD} \rfloor}\prod_{j=1}^{\lfloor \frac{B}{dD} \rfloor}\gcd(i,j) \right)^{d \mu(D) \lfloor \frac{C}{dD} \rfloor} \\
&=\left( \prod_{T=1}^A T^{\lfloor \frac{A}{T} \rfloor\lfloor \frac{B}{T} \rfloor\lfloor \frac{C}{T} \rfloor} \right)^{\sum_{d|T} \mu(d) \frac{T}{d}} \cdot \left( \prod_{d=1}^A \prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} \prod_{i=1}^{\lfloor \frac{A}{dD} \rfloor}\prod_{j=1}^{\lfloor \frac{B}{dD} \rfloor}\gcd(i,j) \right)^{d \mu(D) \lfloor \frac{C}{dD} \rfloor} \\
&=\left( \prod_{T=1}^A T^{\varphi(T)} \right)^{\lfloor \frac{A}{T} \rfloor\lfloor \frac{B}{T} \rfloor\lfloor \frac{C}{T} \rfloor} \cdot \left( \prod_{d=1}^A \prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} \prod_{i=1}^{\lfloor \frac{A}{dD} \rfloor}\prod_{j=1}^{\lfloor \frac{B}{dD} \rfloor}\gcd(i,j) \right)^{d \mu(D) \lfloor \frac{C}{dD} \rfloor}
\end{aligned}
$$
显然拆开更好算。所以又要分开去计算……

#### Sub 2.1

这个不是已经算过了？
$$
\left( \prod_{T=1}^A T^{\varphi(T)} \right)^{\lfloor \frac{A}{T} \rfloor\lfloor \frac{B}{T} \rfloor\lfloor \frac{C}{T} \rfloor}
$$
我们筛过 $h(x) = x^{\varphi(x)}$。这个东西我们甚至在 Sub 1 做过。

当然有一个更妙的做法是因为 Sub 2.1 的求的这个东西，在最终我们会将去取逆元。所以乘起来就等于 $1$。你直接算也不会 T。

#### Sub 2.2

主要还是看这个东西。关注到现在只与 $\gcd(i,j)$ 与 $\gcd(i,j,k)$ 有关，不难联想到整除分块套整除分块做法。
$$
\prod_{d=1}^A \prod_{D=1}^{\lfloor \frac{A}{d} \rfloor} \left( \prod_{i=1}^{\lfloor \frac{A}{dD} \rfloor}\prod_{j=1}^{\lfloor \frac{B}{dD} \rfloor}\gcd(i,j) \right)^{d \mu(D) \lfloor \frac{C}{dD} \rfloor}\\
\begin{aligned}
&=\prod_{T=1}^A \left(\prod_{i=1}^{\lfloor \frac{A}{T} \rfloor}\prod_{j=1}^{\lfloor \frac{B}{T} \rfloor} \gcd(i,j)\right)^{\sum_{d|T} d\mu(\frac{T}{d}) \lfloor \frac{C}{T} \rfloor}  \\
&=\prod_{T=1}^A\left( \prod_{D=1}^{\lfloor \frac{A}{T} \rfloor}D^{\lfloor \frac{A}{T} \rfloor\lfloor \frac{B}{T} \rfloor}\right)^{\sum_{d|T} d \mu(\frac{T}{d}) \lfloor \frac{C}{T} \rfloor} \\
&=\prod_{T=1}^A \left( \prod_{t=1}^{\lfloor \frac{A}{T} \rfloor} \left( \prod_{d|t}	d^{\mu(\frac{t}{d})} \right)^{\lfloor \frac{A}{Tt} \rfloor \lfloor \frac{B}{Tt} \rfloor} \right)^{\varphi(T) \lfloor \frac{C}{T} \rfloor} \\
&=\prod_{T=1}^A \left(\left( \prod_{t=1}^{\lfloor \frac{A}{T} \rfloor} f(t)^{\lfloor \frac{A}{Tt} \rfloor \lfloor \frac{B}{Tt} \rfloor} \right)^{ \lfloor \frac{C}{T} \rfloor} \right)^{\varphi(T)}
\end{aligned}
$$


内层整除分块与外层整除分块。时间复杂度 $O(n\log p -T n^{\frac{3}{4}} \log p)$。答案式子自己理吧……实在难顶。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL MOD;
LL cnt,phi[100005],prime[50005],mu[100005],smmu[100005],smphi[100005],fac[100005],h[100005],invh[100005],invfac[100005],f[100005],inv[100005],invf[100005],g[100005],invg[100005],se[100005];
bool vis[100005];
LL QuickPow(LL x,LL p)
{
	LL ans=1,base=x;
	while(p)
	{
		if(p&1)	ans=(ans*base)%MOD;
		base=base*base%MOD;
		p>>=1;
	}
	return ans;
}
void shai(LL upper)
{
	vis[1]=true;
	f[1]=mu[1]=1;
	phi[1]=1;
	se[1]=1;
	se[0]=1;
	for(LL i=2;i<=upper;++i)
	{
		se[i]=QuickPow(i,i);
		f[i]=1;
		if(!vis[i])	prime[++cnt]=i,mu[i]=-1,phi[i]=i-1;
		for(LL j=1;j<=cnt && prime[j]*i<=upper;++j)
		{
			vis[prime[j]*i]=true;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				mu[i*prime[j]]=0;
				break;
			}
			phi[i*prime[j]]=phi[i]*phi[prime[j]];
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(LL i=1;i<=upper;++i)	smmu[i]=(smmu[i-1]+mu[i]+MOD)%MOD,se[i]=se[i-1]*se[i]%MOD;
	f[0]=1;
	g[0]=1;
	h[0]=1;
	for(LL i=1;i<=upper;++i)
		for(LL j=i;j<=upper;j+=i)
			if(mu[j/i]==1)	f[j]=f[j]*i%MOD;
			else if(mu[j/i]==-1)	f[j]=f[j]*inv[i]%MOD;
	for(LL i=1;i<=upper;++i)	g[i]=QuickPow(f[i],i*i%(MOD-1));
	for(LL i=1;i<=upper;++i)	f[i]=f[i-1]*f[i]%MOD;
	for(LL i=1;i<=upper;++i)	g[i]=g[i]*g[i-1]%MOD;
	for(LL i=1;i<=upper;++i)	h[i]=QuickPow(i,phi[i]);
	for(LL i=1;i<=upper;++i)	h[i]=(h[i-1]*h[i])%MOD;
	for(LL i=1;i<=upper;++i)	smphi[i]=(smphi[i-1]+phi[i])%(MOD-1);
	for(LL i=0;i<=upper;++i)	invf[i]=QuickPow(f[i],MOD-2);
	for(LL i=0;i<=upper;++i)	invg[i]=QuickPow(g[i],MOD-2);
	for(LL i=0;i<=upper;++i)	invh[i]=QuickPow(h[i],MOD-2);
}
LL G(LL n,LL m)
{
	if(n>m)	n^=m^=n^=m;
	LL ans=1;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		ans=ans*QuickPow((f[r]*invf[l-1])%MOD,(n/l)*(m/l)%(MOD-1))%MOD;
	}
	return ans;
}
LL S(LL x){return x*(x+1)/2;}
LL Calc1(LL n,LL m,LL t)
{
	if(n>m)	n^=m^=n^=m;
	LL ans=1;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		ans=ans*QuickPow(invg[r]*g[l-1]%MOD,S(n/l)%(MOD-1)*S(m/l)%(MOD-1))%MOD;
	}
	return QuickPow(ans,S(t)%(MOD-1));
}
LL Sub1_1(LL a,LL b,LL c)
{
	LL ans=1;
	for(LL l=1,r;l<=min({a,b,c});l=r+1)
	{
		r=min({a/(a/l),b/(b/l),c/(c/l)});
		ans=ans*(QuickPow(QuickPow(fac[a/l],(b/l)*(c/l)%(MOD-1)),(smphi[r]-smphi[l-1]+MOD-1)%(MOD-1)))%MOD;
	}
	return ans;
}
LL Sub1_2(LL a,LL b,LL c)
{
	LL ans=1;
	for(LL l=1,r;l<=min({a,b,c});l=r+1)
	{
		r=min({a/(a/l),b/(b/l),c/(c/l)});
		ans=(ans*QuickPow(h[r]*invh[l-1]%MOD,(a/l)*(b/l)%(MOD-1)*(c/l)%(MOD-1)))%MOD;
	}
	return ans;
}
LL Sub2_1(LL a,LL b,LL c){return QuickPow(Sub1_2(a,b,c),MOD-2);}
LL Sub2_2In(LL a,LL b)
{
	LL ans=1;
	for(LL l=1,r;l<=min(a,b);l=r+1)
	{
		r=min(a/(a/l),b/(b/l));
		ans=ans*QuickPow(f[r]*invf[l-1]%MOD,(a/l)*(b/l)%(MOD-1))%MOD;
	}
	return ans;
}
LL Sub2_2(LL a,LL b,LL c)
{
	LL ans=1;
	for(LL l=1,r;l<=min({a,b,c});l=r+1)
	{
		r=min({a/(a/l),b/(b/l),c/(c/l)});
		LL st=Sub2_2In(a/l,b/l);
		ans=ans*QuickPow(QuickPow(st,c/l),(smphi[r]-smphi[l-1]+MOD-1)%(MOD-1))%MOD;
	}
	return QuickPow(ans,MOD-2);
}
LL Sub1(LL a,LL b,LL c){return Sub1_1(a,b,c)*Sub1_1(b,a,c)%MOD*Sub1_2(a,b,c)%MOD*Sub1_2(b,a,c)%MOD;}
LL Sub2(LL a,LL b,LL c){return Sub2_1(a,b,c)*Sub2_1(a,c,b)%MOD*Sub2_2(a,b,c)%MOD*Sub2_2(a,c,b)%MOD;}
int main(){
	LL T;
	scanf("%lld %lld",&T,&MOD);
	inv[1]=1;
	for(LL i=2;i<=100000;++i)	inv[i]=MOD-(MOD/i)*inv[MOD%i]%MOD;
	shai(100000);
	fac[0]=fac[1]=1;
	for(LL i=2;i<=100000;++i)	fac[i]=(fac[i-1]*i)%MOD;
	invfac[100000]=QuickPow(fac[100000],MOD-2);
	for(LL i=99999;~i;--i)	invfac[i]=invfac[i+1]*(i+1)%MOD;
	while(T-->0)
	{
		LL A,B,C;
		scanf("%lld %lld %lld",&A,&B,&C);
		printf("%lld ",QuickPow(fac[A],B*C%(MOD-1))*QuickPow(fac[B],A*C%(MOD-1))%MOD*QuickPow(QuickPow(G(A,B),MOD-2),C)%MOD*QuickPow(QuickPow(G(A,C),MOD-2),B)%MOD);
		printf("%lld ",QuickPow(se[A],S(B)%(MOD-1)*S(C)%(MOD-1))*QuickPow(se[B],S(A)%(MOD-1)*S(C)%(MOD-1))%MOD*Calc1(A,B,C)%MOD*Calc1(A,C,B)%MOD);
		printf("%lld\n",Sub1(A,B,C)*Sub2(A,B,C)%MOD);
	}
	return 0;
}
```



---

## 作者：木xx木大 (赞：1)

[P5518 [MtOI2019]幽灵乐团 / 莫比乌斯反演基础练习题](https://www.luogu.com.cn/problem/P5518)

基础练习题都是毒瘤阴间题！
写这题之前我从来没想过莫反题码量能有 4k 。。。

### type=0：

$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^C{\left(\frac{ij}{\gcd(i,j)\gcd(i,k)}\right)}\\=(A!)^{BC}(B!)^{AC}\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{-C}\times\prod_{i=1}^A\prod_{j=1}^C\gcd(i,k)^{-B}
$$

前两部分（分子）直接预处理阶乘+快速幂，后半部分为：
$$
\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^C\\(枚举\gcd)=\prod_{d=1}^{\min(A,B)}\prod_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}d^{C[\gcd(i,j)=1]}\\(把i,j放到指数上)=\prod_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}C[\gcd(i,j)=1]}\\(按套路反演)=\prod_{d=1}^{\min(A,B)}d^{{C\sum\limits_{p=1}^{\min(\left\lfloor\frac{A}{d}\right\rfloor,\left\lfloor\frac{B}{d}\right\rfloor)}}\left\lfloor\frac{A}{pd}\right\rfloor\left\lfloor\frac{B}{pd}\right\rfloor\mu(p)}
$$

预处理 $\mu$ 的前缀和，然后整除分块套整除分块即可。




### type=1：

$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^C{\left(\frac{ij}{\gcd(i,j)\gcd(i,k)}\right)}^{ijk}\\
=\prod_{i=1}^Ai^{i\sum\limits_{j=1}^Bj\sum\limits_{k=1}^Ck}\prod_{j=1}^Bj^{j\sum\limits_{i=1}^Ai\sum\limits_{k=1}^Ck}\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^{C}\gcd(i,j)^{-ijk}\times\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^{C}\gcd(i,k)^{-ijk}
$$

前半部分（分子）为 
$$
\prod_{i=1}^A (i^i)^{B(B+1)C(C+1)/4}
$$
预处理 $i^i$ 的前缀积就可以直接算了。

设 $D=C(C+1)/2$ ，后半部分（分母）为


$$
\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{ijD}\\(枚举\gcd)=\prod_{d=1}^{\min(A,B)}\prod_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}d^{d^2ijD[\gcd(i,j)=1]} \\(把i,j放到指数上)=\prod_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}Dijd^2[\gcd(i,j)=1]} \\(向上面那样按套路反演)=\prod_{d=1}^{\min(A,B)}d^{{D\sum\limits_{p=1}^{\min(\left\lfloor\frac{A}{d}\right\rfloor,\left\lfloor\frac{B}{d}\right\rfloor)}}\sum\limits_{i=1}^{\left\lfloor\frac{A}{pd}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{B}{pd}\right\rfloor}d^2p^2ij \mu(p)}\\=(\prod_{d=1}^{\min(A,B)}d^{d^2})^{D\sum\limits_{p=1}^{\min(\left\lfloor\frac{A}{d}\right\rfloor,\left\lfloor\frac{B}{d}\right\rfloor)}p^2\mu(p)\frac{\left\lfloor\frac{A}{dp}\right\rfloor(\left\lfloor\frac{A}{dp}\right\rfloor+1)}{2}\frac{\left\lfloor\frac{B}{dp}\right\rfloor(\left\lfloor\frac{B}{dp}\right\rfloor+1)}{2}}
$$

预处理 $d^{d^2}$ 的前缀积，预处理 $p^2 \mu(p)$ 的前缀和然后整除分块套整除分块即可。



### type=2（重头戏来了！）

$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^C{\left(\frac{ij}{\gcd(i,j)\gcd(i,k)}\right)}^{\gcd(i,j,k)}
\\=\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^Ci^{\gcd(i,j,k)}\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^Cj^{\gcd(i,j,k)}\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^{C}\gcd(i,j)^{-\gcd(i,j,k)}\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^{C}\gcd(i,k)^{-\gcd(i,j,k)}
$$

前半部分（分子）为
$$				\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^Ci^{\gcd(i,j,k)}\\(枚举\gcd)=\prod_{d=1}^{A}\prod_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}(id)^{d\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}\sum\limits_{k=1}^{\left\lfloor\frac{C}{d}\right\rfloor}[\gcd(i,j,k)=1]}\\(按套路反演)=\prod_{d=1}^{A}\prod\limits_{t=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\prod_{i=1}^{\left\lfloor\frac{A}{td}\right\rfloor}(itd)^{d{\left\lfloor\frac{B}{td}\right\rfloor}{\left\lfloor\frac{C}{td}\right\rfloor}\mu(t)}\\(设T=td)=\prod_{T=1}^{A}\prod\limits_{d|T}\prod_{i=1}^{\left\lfloor\frac{A}{T}\right\rfloor}(iT)^{d\ \mu(\frac{T}{d}){\left\lfloor\frac{B}{T}\right\rfloor}{\left\lfloor\frac{C}{T}\right\rfloor}}\\(\mu*id=\phi)=\prod_{T=1}^{A}\prod_{i=1}^{\left\lfloor\frac{A}{T}\right\rfloor}(iT)^{\phi(T){\left\lfloor\frac{B}{T}\right\rfloor}{\left\lfloor\frac{C}{T}\right\rfloor}}\\(化简)=\prod_{T=1}^{A}\left(T^{\left\lfloor\frac{A}{T}\right\rfloor}(\left\lfloor\frac{A}{T}\right\rfloor!)\right)^{\phi(T){\left\lfloor\frac{B}{T}\right\rfloor}{\left\lfloor\frac{C}{T}\right\rfloor}}\\(拆开算)=\prod_{T=1}^{A}\left(T^{\phi(T)}\right)^{\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}(\left\lfloor\frac{A}{T}\right\rfloor!)^{\phi(T){\left\lfloor\frac{B}{T}\right\rfloor}{\left\lfloor\frac{C}{T}\right\rfloor}}
$$

后半部分：
$$
\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^{C}\gcd(i,j)^{\gcd(i,j,k)}\\(把i,j放指数上并枚举\gcd)=\prod_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}[\gcd(i,j)=1]\sum\limits_{k=1}^C\gcd(d,k)}\\(按套路反演)=\prod_{d=1}^{\min(A,B)}d^{\sum\limits_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}\sum\limits_{t|i,t|j}\mu(t)\sum\limits_{k=1}^C\gcd(d,k)}\\(化简)=\prod_{d=1}^{\min(A,B)}d^{\sum\limits_{t=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\mu(t){\left\lfloor\frac{A}{td}\right\rfloor}{\left\lfloor\frac{B}{td}\right\rfloor}\sum\limits_{k=1}^C\gcd(d,k)}\\(设T=dt)=\prod_{T=1}^{\min(A,B)}\prod_{d|T}d^{\mu(\frac{T}{d}){\left\lfloor\frac{A}{T}\right\rfloor}{\left\lfloor\frac{B}{T}\right\rfloor}\sum\limits_{k=1}^C\gcd(d,k)}\\(把式子写好看一点)=\prod_{T=1}^{\min(A,B)}{\left(\prod_{d|T}d^{\mu(\frac{T}{d})\sum\limits_{k=1}^C\gcd(d,k)}\right)^{{\left\lfloor\frac{A}{T}\right\rfloor}{\left\lfloor\frac{B}{T}\right\rfloor}}}
$$
把中间的指数部分提出来
$$
\sum\limits_{k=1}^C\gcd(d,k)\\
=\sum\limits_{p|d}p\sum\limits_{k=1}^{\left\lfloor\frac{C}{p}\right\rfloor}[\gcd(\frac{C}{d},k)=1]
\\=\sum\limits_{p|d}p\sum\limits_{t|\frac{d}{p}}\mu(t){\left\lfloor\frac{C}{pt}\right\rfloor}\\
=\sum\limits_{s|d}{\left\lfloor\frac{C}{s}\right\rfloor\phi(s)}
$$
再扔回去
$$
\prod_{T=1}^{\min(A,B)}{\left(\prod_{d|T}d^{\mu(\frac{T}{d})\sum\limits_{s|d}{\left\lfloor\frac{C}{s}\right\rfloor\phi(s)}}\right)^{{\left\lfloor\frac{A}{T}\right\rfloor}{\left\lfloor\frac{B}{T}\right\rfloor}}}\\(把枚举s放下面)=\prod_{T=1}^{\min(A,B)}{\left(\prod_{d|T}\prod\limits_{s|d}d^{\mu(\frac{T}{d}){\left\lfloor\frac{C}{s}\right\rfloor\phi(s)}}\right)^{{\left\lfloor\frac{A}{T}\right\rfloor}{\left\lfloor\frac{B}{T}\right\rfloor}}}
$$
发现仍然不好算，orz题解后发现可以把 $s$ 和 $\frac{d}{s}$ 分开算。
$$
\prod_{T=1}^{\min(A,B)}{{\prod_{d|T}\prod\limits_{s|d}\frac{d}{s}^{\mu(\frac{T}{d})\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor}}}\\(交换枚举顺序，T\div s,d\div s)=\prod_{s=1}^{\min(A,B)}\prod_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}{{\prod_{d|T}d^{\mu(\frac{T}{d})\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\left\lfloor\frac{A}{Ts}\right\rfloor\left\lfloor\frac{B}{Ts}\right\rfloor}}}\\(最后整理一下)=\prod_{s=1}^{\min(A,B)}\left(\prod_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}{\left({\prod_{d|T}d^{\mu(\frac{T}{d})}}\right)}^{\left\lfloor\frac{\left\lfloor\frac{A}{T}\right\rfloor}{s}\right\rfloor\left\lfloor\frac{\left\lfloor\frac{B}{T}\right\rfloor}{s}\right\rfloor}\right)^{\phi(s)\left\lfloor\frac{C}{s}\right\rfloor}
$$

最里面一层 $O(n\log n)$ 预处理，外面两层整除分块即可。（和上面反演的方法基本一样，就不写注释了）




$$
\prod_{T=1}^{\min(A,B)}{{\prod_{d|T}\prod\limits_{s|d}s^{\mu(\frac{T}{d})\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor}}}
\\=\prod_{s=1}^{\min(A,B)}\prod_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}\prod\limits_{d|T}s^{\mu(\frac{T}{d})\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\left\lfloor\frac{A}{Ts}\right\rfloor\left\lfloor\frac{B}{Ts}\right\rfloor}
\\=\prod_{s=1}^{\min(A,B)}s^{\sum\limits_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}\sum\limits_{d|T}\mu(\frac{T}{d})\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\left\lfloor\frac{A}{Ts}\right\rfloor\left\lfloor\frac{B}{Ts}\right\rfloor}
\\=\prod_{s=1}^{\min(A,B)}s^{\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\sum\limits_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}\left\lfloor\frac{A}{Ts}\right\rfloor\left\lfloor\frac{B}{Ts}\right\rfloor\sum\limits_{d|T}\mu(\frac{T}{d})}
\\=\prod_{s=1}^{\min(A,B)}s^{\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\sum\limits_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}\left\lfloor\frac{A}{Ts}\right\rfloor\left\lfloor\frac{B}{Ts}\right\rfloor\epsilon(T)}
$$

因为 $\epsilon(T)=[T=1]$ ，所以可以直接把 $T$ 看作 $1$，那么
$$
\prod_{s=1}^{\min(A,B)}s^{\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\sum\limits_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}\left\lfloor\frac{A}{Ts}\right\rfloor\left\lfloor\frac{B}{Ts}\right\rfloor\epsilon(T)}
\\=\prod_{s=1}^{\min(A,B)}s^{\phi(s)\left\lfloor\frac{C}{s}\right\rfloor\left\lfloor\frac{A}{s}\right\rfloor\left\lfloor\frac{B}{s}\right\rfloor}
$$
终于出现了一个漂亮的式子啊！然后我震惊地发现，这个部分和分子的 $\prod_{T=1}^{A}\left(T^{\phi(T)}\right)^{\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor\left\lfloor\frac{C}{T}\right\rfloor}$ 部分可以约掉！所以我们实际要算的分子是 
$$
\prod_{T=1}^{A}(\left\lfloor\frac{A}{T}\right\rfloor!)^{\phi(T){\left\lfloor\frac{B}{T}\right\rfloor}{\left\lfloor\frac{C}{T}\right\rfloor}}
$$
分母是
$$
\prod_{s=1}^{\min(A,B)}\left(\prod_{T=1}^{\left\lfloor\frac{\min(A,B)}{s}\right\rfloor}
{\left({\prod_{d|T}d^{\mu(\frac{T}{d})}}\right)}^
{\left\lfloor\frac{\left\lfloor\frac{A}{T}\right\rfloor}{s}\right\rfloor
\left\lfloor\frac{\left\lfloor\frac{B}{T}\right\rfloor}{s}\right\rfloor}
\right)^{\phi(s)\left\lfloor\frac{C}{s}\right\rfloor}
$$

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
namespace FGF
{
	int n,mo,phi;
	const int N=1e5+5;
	ll A,B,C,fac[N],mu[N],inv[N],dd2[N],p2[N],dd[N],sumphi[N],ph[N],h[N],ifac[N];
	ll ih[N];
	int p[N],vis[N],cnt;
	ll qpow(ll x,ll y)
	{
		ll s=1;
		while(y)
		{
			if(y&1)s=s*x%mo;
			x=x*x%mo,y>>=1;
		}
		return s;
	}
	void init()
	{
		ih[0]=ifac[0]=h[0]=dd[0]=dd2[0]=fac[0]=inv[0]=inv[1]=1;
		for(int i=1;i<=1e5;i++)
			fac[i]=fac[i-1]*i%mo,h[i]=1;
		for(int i=2;i<=1e5;i++)
			inv[i]=inv[mo%i]*(mo-mo/i)%mo;
		for(int i=1;i<=1e5;i++)
			ifac[i]=ifac[i-1]*inv[i]%mo;
		for(int i=1;i<=1e5;i++)
			dd2[i]=dd2[i-1]*qpow(i,1LL*i*i%phi)%mo;
		for(int i=1;i<=1e5;i++)
			dd[i]=dd[i-1]*qpow(i,i)%mo;
		mu[1]=1,ph[1]=1;	
		for(int i=2;i<=1e5;i++)
		{
			if(!vis[i])p[++cnt]=i,mu[i]=phi-1,ph[i]=i-1;
			for(int j=1;j<=cnt&&p[j]*i<=1e5;j++)
			{
				vis[i*p[j]]=1;
				if(i%p[j]==0){mu[i*p[j]]=0;ph[i*p[j]]=ph[i]*p[j];break;}
				mu[i*p[j]]=phi-mu[i],ph[i*p[j]]=ph[i]*(p[j]-1);
			}
		}	
		for(int i=1;i<=1e5;i++)
			sumphi[i]=(sumphi[i-1]+ph[i])%phi;
		for(int i=1;i<=1e5;i++)
			p2[i]=(p2[i-1]+1LL*i*i%phi*mu[i]%phi)%(mo-1);
		for(int i=1;i<=1e5;i++)
			for(int j=i;j<=1e5;j+=i)
				if(mu[j/i]==1)h[j]=h[j]*i%mo;
					else if(mu[j/i]==phi-1)h[j]=h[j]*inv[i]%mo;
		for(int i=1;i<=1e5;i++)
			h[i]=h[i-1]*h[i]%mo,ih[i]=qpow(h[i],mo-2);
		for(int i=2;i<=1e5;i++)mu[i]=(mu[i]+mu[i-1])%phi;
	}
	ll getans1(ll a,ll b,ll c)
	{
		ll ans=1;
		for(int l=1,r;l<=min(a,b);l=r+1)
		{
			ll d=a/l,e=b/l;
			r=min(a/d,b/e);
			ll p=fac[r]*ifac[l-1]%mo,sum=0;
			for(int ql=1,qr;ql<=min(d,e);ql=qr+1)
			{
				qr=min(d/(d/ql),e/(e/ql));
				ll k=(mu[qr]-mu[ql-1]+phi)%phi;
				sum=(sum+k*(d/ql)%phi*(e/ql)%phi)%phi;
			}
			ans=ans*qpow(qpow(p,sum*c%phi),mo-2)%mo;
		}
		return ans;
	}
	ll solve1(ll a,ll b,ll c)
	{
		ll ans=qpow(fac[a],b*c%(mo-1))*qpow(fac[b],a*c%(mo-1))%mo;
		return ans*getans1(a,b,c)%mo*getans1(a,c,b)%mo;
	}
	ll getans2(ll a,ll b,ll c)
	{
		ll D=c*(c+1)/2%phi,ans=1;
		for(int l=1,r;l<=min(a,b);l=r+1)
		{
			ll d=a/l,e=b/l;
			r=min(a/d,b/e);
			ll p=dd2[r]*qpow(dd2[l-1],mo-2)%mo,sum=0;
			for(int ql=1,qr;ql<=min(d,e);ql=qr+1)
			{
				ll g=d/ql,f=e/ql;
				qr=min(d/g,e/f);
				ll k=(p2[qr]-p2[ql-1]+phi)%phi;
				sum=(sum+(g*(g+1)/2%phi)%phi*(f*(f+1)/2%phi)%phi*k%phi)%phi;
			}
			ans=ans*qpow(qpow(p,sum*D%phi),mo-2)%mo;
		}
		return ans;
	}
	ll solve2(ll a,ll b,ll c)
	{
		ll ans=qpow(dd[a],(b*(b+1)/2%phi)%phi*(c*(c+1)/2%phi)%phi)*qpow(dd[b],(a*(a+1)/2%phi)%phi*(c*(c+1)/2%phi)%phi)%mo;
		return ans*getans2(a,b,c)%mo*getans2(a,c,b)%mo;
	}
	ll getans31(ll a,ll b,ll c)
	{
		ll s=1;
		for(int l=1,r;l<=min(a,min(b,c));l=r+1)
		{
			r=min(a/(a/l),min(b/(b/l),c/(c/l)));
			s=s*qpow(fac[a/l],(sumphi[r]-sumphi[l-1]+phi)%phi*(b/l)%phi*(c/l)%phi)%mo;
		}
		return s;
	}
	ll getans32(ll a,ll b,ll c)
	{
		ll ans=1;
		for(int l=1,r;l<=min(a,min(b,c));l=r+1)
		{
			ll d=a/l,e=b/l,sum=1;
			r=min(a/d,min(b/e,c/(c/l)));
			for(int ql=1,qr;ql<=min(d,e);ql=qr+1)
			{
				qr=min(d/(d/ql),e/(e/ql));
				sum=sum*qpow(h[qr]*ih[ql-1]%mo,(d/ql)*(e/ql)%phi)%mo;
			}
			ans=ans*qpow(sum,(sumphi[r]-sumphi[l-1]+phi)%phi*(c/l)%phi)%mo;
		}
		return ans;
	}
	ll solve3(ll a,ll b,ll c)
	{
		return getans31(a,b,c)*getans31(b,a,c)%mo*qpow(getans32(a,b,c),mo-2)%mo*qpow(getans32(a,c,b),mo-2)%mo;
	}
	void work()
	{
		scanf("%d%d",&n,&mo),phi=mo-1;
		init();
		while(n--)
		{
			scanf("%lld%lld%lld",&A,&B,&C);
			printf("%lld %lld %lld \n",solve1(A,B,C),solve2(A,B,C),solve3(A,B,C));
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```



顺便放一下，机房巨佬用另一种做法推出来的式子是，我也不知道这玩意能不能算。
$$

\large\prod_{t=1}^{\min(A,B,C)}\prod\limits_{s=1}^{\min(\left\lfloor\frac{\min(A,B)}{t}\right\rfloor,\left\lfloor\frac{C}{t}\right\rfloor)}\prod_{d=1}^{\left\lfloor\frac{\min(A,B)}{ts}\right\rfloor}(dts)^{\left\lfloor\frac{C}{ts}\right\rfloor t\mu(s)\sum\limits_{p=1}^{\min(\left\lfloor\frac{A}{dts}\right\rfloor,\left\lfloor\frac{B}{dts}\right\rfloor)}\left\lfloor\frac{A}{dpts}\right\rfloor \left\lfloor\frac{B}{dpts}\right\rfloor \mu(p)}
$$



---

## 作者：monstersqwq (赞：0)

提供一种还算新的最后一个子问题的做法

$$\prod\limits_{i=1}^{A}\prod\limits_{j=1}^B\prod\limits_{k=1}^C \gcd(i,j)^{\gcd(i,j,k)}$$

$$\prod\limits_{i=1}^{A}\prod\limits_{j=1}^B \gcd(i,j)^{\sum_{k=1}^C\gcd(i,j,k)}$$

单扔出来这样的东西 $\sum\limits_{i=1}^m\gcd(n,i)$，这个东西在 $\prod\limits_{i=1}^{A}\prod\limits_{j=1}^B\prod\limits_{k=1}^C i^{\gcd(i,j,k)}$ 里实际上是做过加强版的，不多赘述，直接写出结果为 $\sum\limits_{d|n}\varphi(d)\left\lfloor\dfrac{m}{d}\right\rfloor$。

重新扔回去：

$$\prod\limits_{d=1}^Ad^{(\sum_{t|d}\varphi(t)\left\lfloor\frac{C}{t}\right\rfloor)(\sum_{i=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{B}{d}\right\rfloor}[\gcd(i,j)=1])}$$

$$\prod\limits_{d=1}^Ad^{(\sum_{t|d}\varphi(t)\left\lfloor\frac{C}{t}\right\rfloor)(\sum_{p=1}^{\left\lfloor\frac{A}{d}\right\rfloor}\mu(p)\left\lfloor\frac{A}{dp}\right\rfloor\left\lfloor\frac{B}{dp}\right\rfloor})$$

令 $T=dp$。

$$\prod\limits_{T=1}^A\left(\prod\limits_{d|T}d^{\mu(\frac{T}{d})\sum_{t|d}\varphi(t)\left\lfloor\frac{C}{t}\right\rfloor}\right)^{\left\lfloor\frac{A}{T}\right\rfloor\left\lfloor\frac{B}{T}\right\rfloor}$$

发现本来应该预处理中间的东西，但是 $C$ 每次在变，无法提前预处理，只能现做，但是普通的 $O(Tn\log n)$ 做法大概会超时（$n$ 为 $A,B,C$ 的值域），首先这个 $\sum_{t|d}\varphi(t)\left\lfloor\frac{C}{t}\right\rfloor$ 可以通过 Dirichlet 前缀和单次 $O(n\log\log n)$ 做，然后外面的枚举因数求积可以魔改 Dirichlet 前缀和为前缀积来做（注意这里的前缀积实际上是做一个 Dirichlet 卷积，实现细节可以借鉴 Prean 在 P7580 写的卷一个积性函数和一个非积性函数的[这一份代码](https://www.luogu.com.cn/paste/amov5eto)），还需要一个线性逆元（求 $\mu$ 次幂），主要难点是这个 $d$ 的幂次。

首先考虑光速幂，发现这东西空间时间都是 $O(n\sqrt{V})$，$V$ 是指数的值域，约为 $10^9$，显然的爆炸，考虑传统光速幂是一个分块，可以多分几层，如果分 $k$ 层的话这个求幂方式的复杂度是 $O(knV^{\frac{1}{k}})-O(k)$ 的，由于后面的查询要做 $Tn$ 次，多试几次可以得到大约在 $k=6$ 的时候比较优秀（实际上画图可知最优的大约在 $6.12$），最后的复杂度在这里约为 $O(knV^{\frac{1}{k}}+Tnk)$，空间复杂度 $O(knV^{\frac{1}{k}})$。

实测加上取模优化之后就能过了，跑的并不慢。

分块的大致写法见下。
```cpp
void pre(int x)
{
	for(int i=0;i<=5;i++)
	{
		blk[x][0][i]=1;
		if(i!=0) blk[x][1][i]=F.reduce(1ll*blk[x][1][i-1]*blk[x][31][i-1]);
		else blk[x][1][i]=x;
        for(int j=2;j<=31;j++) blk[x][j][i]=F.reduce(1ll*blk[x][j-1][i]*blk[x][1][i]);
	}
}
```


---

## 作者：Sya_Resory (赞：0)

## Prologue

建议点击 [在 Ta 的博客查看](https://www.luogu.com.cn/blog/114514resory/solution-p5518)，以免题解区的 $\LaTeX$ 爆掉。

终于过掉了这题，写篇题解（

建议在做这题之前先做一遍 P3704，对这题的推导过程会有帮助（

## Description

> 令：
> $$f(\textit{type})=\begin{cases}1&\textit{type}=0\\ijk&\textit{type}=1\\\gcd(i,j,k)&\textit{type}=2\end{cases}$$
> 给定 $A,B,C$，求：
> $$\textit{ans}_{\textit{type}}=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\left(\frac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right)^{f(\textit{type})}$$
> 多测，对给定质数 $p$ 取模。
>
> $1\le A,B,C\le 10^5$，$10^7\le p\le 1.05\times10^9,p\in\mathbb{P}$，$T=70$。

## Solution

[纯享版](https://www.luogu.com.cn/paste/9k4dmq4d)

首先对原式化简一下：

$$
\begin{aligned}
\textit{ans}_{\textit{type}}=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\left(\frac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right)^{f(\textit{type})}\\
=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\left(\frac{ij}{\gcd(i,j)\cdot\gcd(i,k)}\right)^{f(\textit{type})}
\end{aligned}
$$

于是原式可以分为两个部分：

$$
\begin{aligned}
& \mathcal F(A,B,C) = \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci^{f(\textit{type})}\\
& \mathcal G(A,B,C)=\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{f(\textit{type})}
\end{aligned}
$$

显然有：

$$
\text{ans}=\frac{\mathcal F(A,B,C)\cdot\mathcal F(B,A,C)}{\mathcal G(A,B,C)\cdot\mathcal G(A,C,B)}
$$

接下来就开始推柿子吧！

----

### $\textit{type}=0$

$$
\begin{aligned}
\mathcal F(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci\\
=&\ \prod_{i=1}^A\prod_{j=1}^Bi^C\\
=&\ \prod_{i=1}^Ai^{B\cdot C}\\
=&\ (A!)^{B\cdot C}
\end{aligned}
$$

预处理阶乘，每次计算快速幂即可。

$$
\begin{aligned}
\mathcal G(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)\\
=&\ \left(\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)\right)^C\\
\end{aligned}
$$

然后开始莫反：

$$
\begin{aligned}
\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)=&\ \prod_{d=1}\prod_{i=1}^A\prod_{j=1}^Bd^{[\gcd(i,j)=d]}\\
=&\ \prod_{d=1}\prod_{i=1}^{\lfloor \frac Ad\rfloor}\prod_{j=1}^{\lfloor\frac Bd\rfloor}d^{[gcd(i,j)=1]}\\
=&\ \prod_{d=1}d^{\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}[gcd(i,j)=1]}
\end{aligned}
$$

把指数提出来推一下：

$$
\begin{aligned}
\sum_{i=1}^{\lfloor\frac Ad\rfloor}\sum_{j=1}^{\lfloor\frac Bd\rfloor}[gcd(i,j)=1]=&\ \sum_{e=1}\sum_{i=1}^{\lfloor\frac Ad\rfloor}\sum_{j=1}^{\lfloor\frac Bd\rfloor}[e\mid i][e \mid j]\mu(e)\\
=&\ \sum_{e=1}\sum_{i=1}^{\lfloor \frac A{de}\rfloor}\sum_{j=1}^{\lfloor\frac B{de}\rfloor}\mu(e)\\
=&\ \sum_{e=1}\lfloor \frac A{de}\rfloor\lfloor\frac B{de}\rfloor\mu(e)
\end{aligned}
$$

带回去就有：

$$
\begin{aligned}
\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)=&\ \prod_{d=1}d^{\sum_{e=1}\lfloor \frac A{de}\rfloor\lfloor\frac B{de}\rfloor\mu(e)}\\
=&\ \prod_{t=1}\prod_{d\mid t}d^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor\mu(\frac td)}\\
=&\ \prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
\mathcal G(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)\\
=&\ \left(\prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\right)^C\\
\end{aligned}
$$

最里面括号内的东西可以用类似埃氏筛的方法预处理一下，即对于每个 $d$，将它的贡献累乘到它的每个倍数上。预处理完成后就可以快乐的整除分块了。

----

### $\textit{type}=1$

定义：$S(n)=\sum_{i=1}^ni=\frac{n(n+1)}2$。

然后开始推柿子：

$$
\begin{aligned}
\mathcal F(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci^{ijk}\\
=&\ \left(\prod_{i=1}^A\prod_{j=1}^Bi^{ij}\right)^{S(C)}\\
=&\ \left(\prod_{i=1}^Ai^i\right)^{S(B)\cdot S(C)}
\end{aligned}
$$

预处理 $\prod_{i=1}^Ai^i$ 即可。

$$
\begin{aligned}
\mathcal G(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{ijk}\\
=&\ \left(\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{ij}\right)^{S(C)}\\
\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{ij}=&\ \prod_{d=1}\prod_{i=1}^A\prod_{j=1}^Bd^{[\gcd(i,j)=d]ij}\\
=&\ \prod_{d=1}\prod_{i=1}^{\lfloor\frac Ad\rfloor}\prod_{j=1}^{\lfloor\frac Bd\rfloor}d^{[\gcd(i,j)=1]ijd^2}\\
=&\ \prod_{d=1}d^{d^2\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}[\gcd(i,j)=1]ij}
\end{aligned}
$$

把指数拎出来：

$$
\begin{aligned}
\sum_{i=1}^{\lfloor\frac Ad\rfloor}\sum_{j=1}^{\lfloor\frac Bd\rfloor}[\gcd(i,j)=1]ij=&\ \sum_{e=1}\sum_{i=1}^{\lfloor\frac Ad\rfloor}\sum_{j=1}^{\lfloor\frac Bd\rfloor}[e\mid i][e\mid j]\mu(e)ij\\
=&\ \sum_{e=1}\sum_{i=1}^{\lfloor\frac A{de}\rfloor}\sum_{j=1}^{\lfloor\frac B{de}\rfloor}e^2\mu(e)ij\\
=&\ \sum_{e=1}e^2\mu(e)\left(\sum_{i=1}^{\lfloor\frac A{de}\rfloor}\sum_{j=1}^{\lfloor\frac B{de}\rfloor}ij\right)\\
=&\ \sum_{e=1}e^2\mu(e)S(\lfloor\frac A{de}\rfloor)S(\lfloor\frac B{de}\rfloor)
\end{aligned}
$$

带回去：

$$
\begin{aligned}
\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{ij}=&\ \prod_{d=1}d^{d^2\sum_{e=1}e^2\mu(e)S(\lfloor\frac A{de}\rfloor)S(\lfloor\frac B{de}\rfloor)}\\
=&\ \prod_{e=1}\prod_{d=1}d^{(de)^2\mu(e)S(\lfloor\frac A{de}\rfloor)S(\lfloor\frac B{de}\rfloor)}\\
=&\ \prod_{t=1}\prod_{d\mid t}d^{t^2\mu(\frac td)S(\lfloor\frac A{t}\rfloor)S(\lfloor\frac B{t}\rfloor)}\\
=&\ \prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)}\right)^{t^2S(\lfloor\frac At\rfloor)S(\lfloor\frac Bt\rfloor)}\\
\mathcal G(A,B,C)=&\ \left(\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{ij}\right)^{S(C)}\\
=&\ \left(\left(\prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)}\right)^{t^2}\right)^{S(\lfloor\frac At\rfloor)S(\lfloor\frac Bt\rfloor)}\right)^{S(C)}
\end{aligned}
$$

括号里的东西其实就是第一问预处理的那个东西的 $t^2$ 次方，预处理一下即可整除分块。

----

### $\textit{type}=2$

毒瘤。

$$
\begin{aligned}
\mathcal F(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Ci^{\gcd(i,j,k)}\\
=&\ \prod_{i=1}^Ai^{\sum_{j=1}^B\sum_{k=1}^C\gcd(i,j,k)}\\
=&\ \prod_{d=1}\prod_{i=1}^Ai^{\sum_{j=1}^B\sum_{k=1}^C[\gcd(i,j,k)=d]d}\\
=&\ \prod_{d=1}\prod_{i=1}^{\lfloor\frac Ad\rfloor}(id)^{\sum_{j=1}^{B/d}\sum_{k=1}^{C/d}[\gcd(i,j,k)=1]d}\\
=&\ \prod_{d=1}\prod_{e=1}\prod_{i=1}^{\lfloor\frac A{de}\rfloor}(ide)^{\lfloor{\frac B{de}}\rfloor\lfloor{\frac C{de}}\rfloor\mu(e)d}\\
=&\ \prod_{t=1}\prod_{d\mid t}\prod_{i=1}^{\lfloor\frac At\rfloor}(it)^{\lfloor\frac Bt\rfloor\lfloor\frac Ct\rfloor\mu(\frac td)d}\\
=&\ \prod_{t=1}\left(\prod_{d\mid t}\left(\lfloor\frac At\rfloor!\cdot t^{\lfloor\frac At\rfloor}\right)^{\mu(\frac td)d}\right)^{\lfloor\frac Bt\rfloor\lfloor\frac Ct\rfloor}\\
=&\ \prod_{t=1}\left(\left(\lfloor\frac At\rfloor!\cdot t^{\lfloor\frac At\rfloor}\right)^{\sum_{d\mid t}\mu(\frac td)d}\right)^{\lfloor\frac Bt\rfloor\lfloor\frac Ct\rfloor}\\
=&\ \prod_{t=1}\left(\left(\lfloor\frac At\rfloor!\cdot t^{\lfloor\frac At\rfloor}\right)^{\varphi(t)}\right)^{\lfloor\frac Bt\rfloor\lfloor\frac Ct\rfloor}\\
\end{aligned}
$$

这玩意有点复杂，把它拆成两个部分：

$$
\begin{aligned}
& f_0(A,B,C)=\prod_{t=1}\left(\left(\lfloor\frac At\rfloor!\right)^{\lfloor\frac Bt\rfloor\lfloor\frac Ct\rfloor}\right)^{\varphi(t)}\\
& f_1(A,B,C)=\prod_{t=1}\left(t^{\varphi(t)}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor\lfloor\frac Ct\rfloor}
\end{aligned}
$$

于是有：

$$
\begin{aligned}
\mathcal F(A,B,C)=f_0(A,B,C)\cdot f_1(A,B,C)
\end{aligned}
$$

$f_1$ 可以整除分块了，把 $f_2$ 先放着，看 $\mathcal G$：

$$
\begin{aligned}
\mathcal G(A,B,C)=&\ \prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C\gcd(i,j)^{\gcd(i,j,k)}\\
=&\ \prod_{d=1}\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^Cd^{[\gcd(i,j)=d]\gcd(d,k)}\\
=&\ \prod_{d=1}d^{\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}[\gcd(i,j)=1]\sum_{k=1}^C\gcd(d,k)}\\
=&\ \prod_{d=1}d^{\sum_{e=1}\lfloor{\frac A{de}\rfloor}\lfloor\frac B{de}\rfloor\mu(e)\cdot\sum_{k=1}^C\gcd(d,k)}\\
=&\ \prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)\cdot\sum_{k=1}^C\gcd(d,k)}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}
\end{aligned}
$$

指数上的东西：

$$
\begin{aligned}
\sum_{k=1}^C\gcd(d,k)=&\ \sum_{f\mid d}\sum_{k=1}^{\lfloor\frac Cf\rfloor}[\gcd(\frac df,k)=1]f\\
=&\ \sum_{f\mid d}\sum_{g\mid\frac df}\lfloor\frac C{fg}\rfloor\mu(g)f\\
=&\ \sum_{u\mid d}\varphi(u)\lfloor\frac Cu\rfloor
\end{aligned}
$$

然后带回去：

$$
\begin{aligned}
\mathcal G(A,B,C)=&\ \prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)\sum_{u\mid d}\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
\end{aligned}
$$

这玩意不怎么好预处理。考虑把底数的 $d$ 拆成 $u$ 和 $\frac du$：

$$
\begin{aligned}
& g_0(A,B,C)=\prod_{t=1}\left(\prod_{d\mid t}\prod_{u\mid d}\left(\frac du\right)^{\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
& g_1(A,B,C)=\prod_{t=1}\left(\prod_{d\mid t}\prod_{u\mid d}u^{\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}
\end{aligned}
$$

就有：

$$
\mathcal G(A,B,C)=g_0(A,B,C)\cdot g_1(A,B,C)
$$

分别推一下：

$$
\begin{aligned}
g_0(A,B,C)=&\ \prod_{t=1}\left(\prod_{d\mid t}\prod_{u\mid d}\left(\frac du\right)^{\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
=&\ \prod_{t=1}\left(\prod_{u\mid t}\prod_{u\mid d\mid t}\left(\frac du\right)^{\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
=&\ \prod_{t=1}\left(\prod_{u\mid t}\left(\prod_{d\mid \frac tu}d^{\mu(\frac td)}\right)^{\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
=&\ \prod_{u=1}\left(\prod_{t=1}\left(\prod_{d\mid t}d^{\mu(\frac td)}\right)^{\lfloor\frac A{tu}\rfloor\lfloor\frac B{tu}\rfloor}\right)^{\varphi(u)\lfloor\frac Cu\rfloor}
\end{aligned}
$$

括号里的东西预处理过了，两次整除分块可以搞定。

$$
\begin{aligned}
g_1(A,B,C)=&\ \prod_{t=1}\left(\prod_{d\mid t}\prod_{u\mid d}u^{\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac At\rfloor\lfloor\frac Bt\rfloor}\\
=&\ \prod_{u=1}\prod_{t=1}\left(\prod_{d\mid t}u^{\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor}\right)^{\lfloor\frac A{tu}\rfloor\lfloor\frac B{tu}\rfloor}\\
=&\ \prod_{u=1}u^{\sum_{t=1}\sum_{d\mid t}\mu(\frac td)\varphi(u)\lfloor\frac Cu\rfloor\lfloor\frac A{tu}\rfloor\lfloor\frac B{tu}\rfloor}\\
=&\ \prod_{u=1}u^{\varphi(u)\lfloor\frac Cu\rfloor\sum_{t=1}\lfloor\frac A{tu}\rfloor\lfloor\frac B{tu}\rfloor\sum_{d\mid t}\mu(\frac td)}\\
=&\ \prod_{u=1}u^{\varphi(u)\lfloor\frac Cu\rfloor\sum_{t=1}\lfloor\frac A{tu}\rfloor\lfloor\frac B{tu}\rfloor[t=1]}\\
=&\ \prod_{u=1}u^{\varphi(u)\lfloor\frac Au\rfloor\lfloor\frac Bu\rfloor\lfloor\frac Cu\rfloor}\\
\end{aligned}
$$

注意到，$g_1$ 和之前的 $f_1$ 其实是一样的，而且它们的值不受 $A,B,C$ 顺序的影响，因此可以把它们约掉。

-----

卡常小技巧（不过应该众所周知）：把预处理的东西的逆元同时预处理出来可以大幅减小常数

[code](https://www.luogu.com.cn/paste/n5q3vgbs) （预处理丑陋无比）



---


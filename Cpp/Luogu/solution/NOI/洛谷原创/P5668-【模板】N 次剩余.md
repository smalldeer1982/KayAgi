# 【模板】N 次剩余

## 题目描述

你需要解方程 $x^n\equiv k\pmod m$，其中 $x\in [0,m-1]$。

## 说明/提示

对于 $100 \%$ 的数据，$1\le T\le 100$，$1\le n\le 10^9$，$0\le k \lt m\le 10^9$。

设 $m$ 的唯一分解形式为 $m=\prod_{i=1}^s p_i^{q_i}$，保证方程 $x^n\equiv k\pmod{p_i^{q_i}}$ 在 $[0,p_i^{q_i})$ 中的解数 $\le 10^6$。

## 样例 #1

### 输入

```
2
3 531441 330750
5 304128 1```

### 输出

```
27
264 19947 39630 59313 78996 98679 118362 138045 157728 177411 197094 216777 236460 256143 275826 295509 315192 334875 354558 374241 393924 413607 433290 452973 472656 492339 512022
5
1 82945 138241 165889 193537```

# 题解

## 作者：Eznibuil (赞：16)

Upd：用递推解模 $2^q$ 的情况居然被叉飞了，惊恐地发现本题解幸存。

此题解将使用复杂度正确的方法解决模 $2^q$ 的情况。记 $\{0,1,\dots,m-1\}$ 为 $\Z_m$。

解关于整数 $x$ 的方程，$x^n\equiv k\pmod m$，其中 $x\in\Z_m$。

首先按照惯例，分解 $m=\prod p_i^{q_i}$，接下来只需要考虑素数的幂。$2$ 的幂比较特殊，没有原根，分开考虑。

回想 $m$ 是素数时如何求解，特判掉 $0$ 的情况，首先找到 $m$ 的一个原根 $g$，接着求解方程 $g^a\equiv k\pmod m$。显然 $x$ 一定可以表示为 $g^t$，得到方程 $g^{tn}\equiv g^a\pmod m$，两侧同时取离散对数，有 $tn\equiv a\pmod{(m-1)}$，扩欧求得 $t$，快速幂得 $x$ 即可。同时知道此方程若有解，则有 $\gcd(n,m-1)$ 个解。

同样的方法可以应用到此题。于是分情况：

1. $k=0$；
1. $p_i=2$；
1. $p_i$ 为奇素数。

首先是 $k=0$。则有 $x^n\bmod p^q=0$，满足时当且仅当 $x\bmod p^{\lceil\frac qn\rceil}=0$。

然后当 $k$ 和 $p$ 不互质就不太行，所以将 $k$ 分解为 $u\cdot p^t(u\bmod p\ne0)$，重新解 $x^n\equiv u\pmod{p^{q-t}}$ 即可。

接下来是 $p_i=2$。有 $x^n\equiv k\pmod{2^q}$。
可以发现每个数可以唯一地表示为 $(-1)^a5^b\bmod 2^q$，其中 $a\in\Z_2,b\in\Z_{2^{q-2}}$。两个维度是独立的，于是套用 $m$ 是素数的解法。

最后是 $p_i$ 为奇素数。套用 $m$ 是素数的写法即可。

下面是详细证明。

引理 1（中国剩余定理）$\quad$ 设 $m=\prod p_i^{q_i}$，$p_i$ 为素数且 $q_i>0$，则 $\Z_m$ 和 $\Z_{p_1^{q_1}}\times\Z_{p_2^{q_2}}\times\cdots$ 可以建立一个唯一的双射，满足这个双射的一侧的映射 $f:\Z_m\to\Z_{p_1^{q_1}}\times\Z_{p_2^{q_2}}\times\cdots$，表示为 $f(x)=(x\bmod p_1^{q_1},x\bmod p_2^{q_2},\dots)$。
>证明：显然映射 $f$ 成立，考虑证明 $f$ 映射到的两两不同。使用反证法，假设 $x_1\ne x_2$，同时 $x_1\bmod p_1^{q_1}=x_2\bmod p_1^{q_1},x_1\bmod p_2^{q_2}=x_2\bmod p_2^{q_2},\dots$。可以发现 $x_1-x_2$ 必然是所有 $p_i^{q_i}$ 的倍数，又因为 $p_i^{q_i}$ 都是两两互素，所以得到 $x_1-x_2$ 是 $m$ 的倍数，矛盾。证毕。

于是可以分解原方程为若干互相独立的方程，并逐个求解，最后合并。

引理 2 $\quad$ 若关于整数 $x$ 的方程 $x^n\equiv k\pmod m$ 有解，当且仅当 $k^{\frac{\varphi(m)}{\gcd(n,\varphi(m))}}\equiv1\pmod m$。其中 $m$ 有原根且 $\gcd(k,m)=1$。（注意，此处 $\gcd(0,x)=x$。）
>证明：
>
>充分性：则须证明对于所有 $x$，$(x^n)^{\frac{\varphi(m)}{\gcd(n,\varphi(m))}}\equiv1\pmod m$。显然可化为 $x^{\operatorname{lcm}(n,\varphi(m))}\equiv1\pmod m$，由欧拉定理可证。
>
>必要性：设 $m$ 的一个原根为 $g$，显然存在唯一 $k'\in\Z_{\varphi(m)}$ 满足 $g^{k'}\equiv k\pmod m$，亦存在唯一 $x'\in\Z_{\varphi(m)}$ 满足 $g^{x'}\equiv x\pmod m$。则条件变为 $k'\cdot\frac{\varphi(m)}{\gcd(n,\varphi(m))}\equiv0\pmod{\varphi(m)}$，可得 $k'$ 必然是 $\gcd(n,\varphi(m))$ 的倍数。另一方面，要证明原方程有解，则要证明 $x'n\equiv k'\pmod{\varphi(m)}$ 有解，而此方程有解的条件即为 $k'$ 是 $\gcd(n,\varphi(m))$ 的倍数（根据 Bézout's Lemma）。得证。

然后就可以判别对于一个 $p^q$ 有没有解了。不幸的是，当 $q>2$ 时，$2^q$ 并没有原根，所以另外处理。先证明几个基础的。

引理 3 $\quad$ $5^{2^{q-3}}\equiv2^{q-1}+1\pmod{2^q}$，其中 $q>2$。
>证明：使用归纳法。显然 $q=3$ 时成立。假设 $q=i$ 成立，有 $5^{2^{i-3}}\equiv2^{i-1}+1\pmod{2^i}$，则 $5^{2^{i-3}}\equiv2^{i-1}+1\pmod{2^{i+1}}$ 或者 $5^{2^{i-3}}\equiv2^i+2^{i-1}+1\pmod{2^{i+1}}$。两侧同时平方，前一个得到 $5^{2^{i-2}}\equiv2^{2i-2}+2^i+1\equiv2^i+1\pmod{2^{i+1}}$，后一个得到 $5^{2^{i-2}}\equiv2^{2i+1}+2^{2i-2}+2^{i+1}+2^i+1\equiv2^i+1\pmod{2^{i+1}}$。于是 $q=i+1$ 成立。根据归纳，证毕。

引理 4 $\quad$ $5$ 在模 $2^q$ 意义下的阶为 $2^{q-2}$，其中 $q>2$。
>证明：易知 $5$ 的阶必定是 $\varphi(2^q)=2^{q-1}$ 的因数，也就是 $2^i(i\in\Z_q)$。而如果 $5^{2^i}\equiv1\pmod{2^q}$，则 $5^{2^j}\equiv1\pmod{2^q}(j\ge i)$，于是根据引理 3，$5$ 的阶必然 $>2^{q-3}$。另一方面，引理 3 两侧同时平方，有 $5^{2^{q-2}}\equiv2^{2q-2}+2^q+1\equiv1\pmod{2^q}$，所以 $5$ 的阶必然 $\le2^{q-2}$。综上有 $5$ 的阶为 $2^{q-2}$，证毕。

引理 5 $\quad$ 关于 $a,b$ 的方程 $(-1)^a5^b\equiv x\pmod{2^q}$，其中 $q>2,a\in\Z_2,b\in\Z_{2^{q-2}},\gcd(x,2)=1$，有唯一解。
>证明：首先，根据引理 4，$5$ 的阶是 $2^{q-2}$，所以 $\{5^0\bmod2^q,5^1\bmod2^q,\dots,5^{2^{q-2}-1}\bmod2^q\}$ 中的元素互不相同。证明没有二解，使用反证法，假设 $(-1)^{a_1}5^{b_1}\equiv(-1)^{a_2}5^{b_2}\pmod{2^q}$，由上得 $a_1\ne a_2$。于是有 $5^{b_1}+5^{b_2}\equiv0\pmod{2^q}$，但是左侧模 $4$ 为 $2$，右侧模 $4$ 为 $0$，矛盾。从而得证。证明不可能无解，则由上有所有 $(-1)^a5^b$ 互不相同，而一共有 $2^{q-1}$ 个 $(-1)^a5^b$，于是一定可以和所有 $x$ 对应，证毕。

发现 $x=(-1)^a5^b\pmod{2^q}$ 有唯一解，所以考虑改写方程为 $(-1)^{a_xn}5^{b_xn}\equiv(-1)^{a_k}5^{b_k}\pmod{2^q}$。$a_k$ 和 $b_k$ 可由两次离散对数得到。然后因为相互独立，拆解为两个方程 $a_xn\equiv a_k\pmod2$ 和 $b_xn\equiv b_k\pmod{2^{p-2}}$。扩欧求解即可。

至此完整地给出了 $x^n\equiv k\pmod{p^q}$（$p$ 是素数且 $\gcd(k,p)=1$）的情况的证明。接下来的问题是：如果 $k=0$ 或是 $\gcd(k,p^q)>1$ 怎么办？

先解决 $k=0$。

引理 6 $\quad$ 关于整数 $x$ 的方程 $x^n\equiv0\pmod{p^q}$ 的解为 $x\equiv0\pmod{p^{\lceil\frac qn\rceil}}$。
>证明：反证。若 $x$ 含 $p$ 少于 $\lceil\frac qn\rceil$，则 $x^n$ 含 $p$ 少于 $\lceil\frac qn\rceil\cdot n$，也就少于 $q$，矛盾。证毕。

然后是不互素。

引理 7 $\quad$ 关于整数 $x$ 的方程 $x^n\equiv u\cdot p^t\pmod{p^q}$，其中 $\gcd(u,p)=1$，有解当且仅当 $t\bmod n=0$。
>证明：直接构造。设 $x^n\equiv u\pmod{p^{q-t}}$ 的解为 $x_0$，则原方程解为 $(x_0+z\cdot p^{q-t})\cdot p^{\frac tn}$。证毕。

至此全部情况梳理完毕。时间复杂度为 $O(\sqrt m+\tau\log m+s)$，$s$ 为解数，$\tau$ 为离散对数时间复杂度。

代码用了下 `pb_ds` 的哈希表（用来加速 BSGS）。处理 $p=2$ 时马蜂较为阴间，且含有压行，建议不阅读。
```cpp
#include<stdio.h>
#include<vector>
#include<ext/pb_ds/assoc_container.hpp>
typedef long long ll;
bool f;
int lp,le,e[2000001];
ll n,m,k,p[21],pw[21],c[21];
std::vector<ll>r[21];
__gnu_pbds::gp_hash_table<ll,ll>h;
ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}
ll Pow(ll a,ll b,ll m)
{
	ll s=1;
	for(a%=m;b;a=a*a%m,b>>=1)
		if(b&1)
			s=s*a%m;
	return s;
}
ll BSGS(ll a,ll b,ll m)
{
	a%=m,b%=m,h.clear();
	if(b==1)
		return 0;
	if(!a&&b)
		return -1;
	ll s=sqrt(m)+1,aa=1;
	for(ll i=0;i<s;i++)
		h[b*aa%m]=i,aa=aa*a%m;
	for(ll i=1,j=aa;i<=s;i++,j=j*aa%m)
	{
		int x=h[j];
		if(x||j==b)
			return i*s-x;
	}
	return -1;
}
ll exgcd(ll a,ll b,ll&x,ll&y)
{
	if(!b)
		return x=1,y=0,a;
	int g=exgcd(b,a%b,y,x);
	return y-=a/b*x,g;
}
bool DiscreteRoots(ll z)
{
	if(k%pw[z])
	{
		ll kp=k%pw[z],pk=1,mk=0;
		while(kp%p[z]==0)
			kp/=p[z],pk*=p[z],mk++;
		if(mk%n)
			return 1;
		ll pwk=pw[z]/pk,h=pwk/p[z]*(p[z]-1),g,le=0,e[21];
		if(Pow(kp,h/gcd(n,h),pwk)!=1)
			return 1;
		for(ll i=2;i*i<=h;i++)
			if(h%i==0)
			{
				while(h%i==0)
					h/=i;
				e[le++]=i;
			}
		if(h>1)
			e[le++]=h;
		for(g=1;;g++)
		{
			bool f=1;
			for(int i=0;i<le&&f;i++)
				if(Pow(g,pwk/p[z]*(p[z]-1)/e[i],pwk)==1) 
					f=0;
			if(f)
				break;
		}
		ll x=BSGS(g,kp,pwk),ka,kb,y=exgcd(n,pwk/p[z]*(p[z]-1),ka,kb);
		if(x%y)
			return 1;
		h=pwk/p[z]*(p[z]-1)/y,kb=Pow(p[z],mk/n,pw[z]),r[z].resize(y*(pk/kb)),r[z][0]=Pow(g,(ka*(x/y)%h+h)%h,pwk),ka=kb,kb=Pow(g,h,pwk);
		for(ll i=1;i<y;i++)
			r[z][i]=r[z][i-1]*kb%pwk;
		for(ll i=y;i<y*(pk/ka);i++)
			r[z][i]=(r[z][i-y]+pwk)%(pw[z]/ka);
		for(ll i=0;i<y*(pk/ka);i++)
			r[z][i]=r[z][i]*ka;
	}
	else
	{
		ll x=0,y=1,o=Pow(p[z],n,pw[z]);
		while(y)
			x++,y=y*o%pw[z];
		r[z].resize(o=pw[z]/(y=Pow(p[z],x,pw[z]+1)));
		for(ll i=0;i<o;i++)
			r[z][i]=i*y;
	}
	return 0;
}
void dfs(ll st,ll x)
{
	if(st==lp)
	{
		e[le++]=x;
		return;
	}
	for(ll i:r[st])
		dfs(st+1,(x+i*c[st])%m);
	return;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld%lld%lld",&n,&m,&k),f=1,lp=le=0;
		if(n==1)
		{
			printf("1\n%lld\n",k);
			continue;
		}
		if(!(m&7))
		{
			ll mp=3;
			p[0]=2,pw[0]=8,m>>=3;
			while(!(m&1))
				m>>=1,pw[0]<<=1,mp++;
			if(k&pw[0]-1)
			{
				ll k2=k&pw[0]-1,r2=0;
				while(!(k2&1))
					k2>>=1,r2++;
				if(r2%n)
				{
					puts("0");
					continue;
				}
				if(pw[0]>>r2>4)
				{
					ll w_1=0,w5=BSGS(5,k2,pw[0]>>r2);
					if(!~w5)
						w_1=1,w5=BSGS(5,(pw[0]>>r2)-k2,pw[0]>>r2);
					if(n&1)
					{
						ll x,y,g=exgcd(n,pw[0]>>r2+2,x,y);
						if(w5%g)
						{
							puts("0");
							continue;
						}
						w5/=g,x=x*w5&(pw[0]>>r2+2)/g-1,y=Pow(5,(pw[0]>>r2+2)/g,pw[0]>>r2),r[0].resize(g),r[0][0]=w_1?(pw[0]>>r2)-Pow(5,x,pw[0]>>r2):Pow(5,x,pw[0]>>r2);
						for(ll i=1;i<g;i++)
							r[0][i]=r[0][i-1]*y&(pw[0]>>r2)-1;
					}
					else if(w_1)
					{
						puts("0");
						continue;
					}
					else
					{
						ll x,y,g=exgcd(n,pw[0]>>r2+2,x,y);
						if(w5%g)
						{
							puts("0");
							continue;
						}
						w5/=g,x=x*w5&(pw[0]>>r2+2)/g-1,y=Pow(5,(pw[0]>>r2+2)/g,pw[0]>>r2),r[0].resize(g<<1),r[0][g]=(pw[0]>>r2)-(r[0][0]=Pow(5,x,pw[0]>>r2));
						for(ll i=1;i<g;i++)
							r[0][i]=r[0][i-1]*y&(pw[0]>>r2)-1,r[0][i+g]=r[0][i+g-1]*y&(pw[0]>>r2)-1;
					}
				}
				else
					for(ll i=0;i<pw[0]>>r2;i++)
						if(Pow(i,n,pw[0]>>r2)==k&(pw[0]>>r2)-1)
							r[0].emplace_back(i);
				ll s=r[0].size();
				r[0].resize(s<<r2-r2/n);
				for(ll i=s;i<s<<r2-r2/n;i++)
					r[0][i]=r[0][i-s]+(pw[0]>>r2)&(pw[0]>>r2/n)-1;
				for(ll i=0;i<s<<r2-r2/n;i++)
					r[0][i]=r[0][i]<<r2/n;
			}
			else
			{
				ll l=1ll<<mp-(mp-1)/n-1;
				r[0].resize(l);
				for(ll i=0;i<l;i++)
					r[0][i]=i<<(mp-1)/n+1;
			}
			lp++;
		}
		else if(!(m&3))
		{
			p[0]=2,pw[0]=4,m>>=2;
			for(ll i=0;i<4;i++)
				if(Pow(i,n,4)==(k&3))
					r[0].emplace_back(i);
			if(r[0].empty())
			{
				puts("0");
				continue;
			}
			lp++;
		}
		else if(!(m&1))
			p[0]=2,pw[0]=2,m>>=1,r[0].emplace_back(k&1),lp++;
		for(ll i=3;i*i<=m;i+=2)
			if(m%i==0)
			{
				p[lp]=i,pw[lp]=1;
				while(m%i==0)
					m/=i,pw[lp]*=i;
				if(DiscreteRoots(lp))
				{
					f=0;
					break;
				}
				lp++;
			}
		if(!f)
		{
			puts("0");
			while(lp--)
				r[lp].clear();
			continue;
		}
		if(m>1)
		{
			p[lp]=pw[lp]=m,m=1;
			if(DiscreteRoots(lp))
			{
				puts("0");
				while(lp--)
					r[lp].clear();
				continue;
			}
			lp++;
		}
		for(ll i=0;i<lp;i++)
			m*=pw[i];
		for(ll i=0;i<lp;i++)
			c[i]=m/pw[i]*Pow(m/pw[i],pw[i]/p[i]*(p[i]-1)-1,pw[i])%m;
		dfs(0,0),std::sort(e,e+le),printf("%lld\n",le);
		for(ll i=0;i<le;++i,i<le?putchar(' '):putchar('\n'))
			printf("%lld",e[i]);
		while(lp--)
			r[lp].clear();
	}
	return 0;
}
```

---

## 作者：Determinant (赞：11)

本文将介绍一种不求离散对数求任意模数 $n$ 次剩余的方法。具体地，设质因数分解 $m$ 的复杂度为 $\operatorname{factorize}(m)$，答案个数为 $s$，且假设值域范围内整数四则运算复杂度为 $O(1)$，则可以在 $O(\operatorname{factorize}(m)+s\log^2m)$ 的时间内得到答案。

## 初步转化

根据维基百科，求任意模数二次剩余等价于对模数进行质因数分解。因此本题不弱于质因数分解，不妨先做个质因数分解，转化为求 $k^{1/n}\bmod p^c$ 这样的问题，然后用中国剩余定理合并。显然合并可以在 $O(s\log m)$ 时间内完成。

这里为了避免一些问题，我们先将 $n$ 对 $\varphi(p^c)$ 取模，$k$ 对 $p^c$ 取模，然后讨论一些 corner case（若符合某一条，则执行该条并忽略后面的所有内容）：

(1)若 $k=0$，答案为 $\{0\}$。

现在 $k\neq0$。

(2)若 $n=0$，$k=1$，答案为 $[1,p-1]\cap\Z$。

现在 $n\neq0,k\neq0$。

(3)记 $v_p(n)=\max\{k|n\bmod p^k=0\}$，令 $h=v_p(k)$。当 $h\bmod n\neq0$ 时无解；否则先求 $(k/p^h)^{1/n}\bmod p^{c-h}$ 的答案，然后在 $p$ 进制意义下在每个值的右边补上 $h/n$ 位，全部填 $0$，然后在左边补上 $h(1-1/n)$ 位，随便填数，将所有值的集合并起来即可。

注记：不难注意到 $v_p(k^{1/n})=v_p(k)/n$，因此判定无解和在右边补 $0$ 是合理的；展开 $(a_0+a_1p+a_2p^2+...)^n$，发现最高的 $h(1-1/n)$ 位对结果完全没有贡献，于是可以随便填。至于中间的 $c-h$ 位，可以证明两个问题的解是一一对应的。

现在 $n\neq0,k\bmod p\neq0$。

(4)令 $q=\varphi(p^c)/(1+[p=2][c\geq3])$，则有解的充要条件为 $k^{q/\gcd(n,q)}\bmod p^c=1$。

注记：现在 $k$ 一定是模 $p^c$ 乘法群中的元素。当 $p\neq2$ 或 $c\leq2$，模 $p^c$ 乘法群同构于循环群 $\mathbf{C_{\varphi(p^c)}}$，于是 $k$ 可以表示为 $g^a$ 的形式，$g$ 是原根；由于 $(n/\gcd(n,q))^{-1}\bmod q$ 一定存在，这部分不用考虑了；为使 $a/\gcd(n,q)\bmod q$ 存在，$a\bmod\gcd(n,q)$ 必须等于 $0$，于是 $k^{q/\gcd(n,q)}\bmod p^c=1$。反过来，满足这个条件，也可以推出一个根是 $g^a$，于是一定有解。当 $p=2$ 且 $c\geq3$，乘法群同构于 $\mathbf{C_2}\times\mathbf{C_{2^{n-2}}}$，可以设 $k=g_1^{a_1}g_2^{a_2}$，进行类似的分析。

现在 $n\neq0,k\bmod p\neq0$，且一定有解。

## 模质数的情形

模 $p^c$ 的情形还是太过复杂，我们先考虑模 $p$ 意义下的根。

不妨将 $n$ 对 $p-1$ 取余，$k$ 对 $p$ 取余。现在有 $k\neq0$，但可能出现 $n=0$ 的情况。为了方便，我们仍然先讨论一些 corner case。

(5)当 $n=0$，答案为 $[1,p-1]\cap\Z$。

(6)当 $n=1$，答案为 $\{k\}$。

现在 $n\geq2,k\neq0$。继续规约：看起来，令 $g=\gcd(n,p-1)$，我们可以先求出 $q=(n/g)^{-1}\bmod(p-1)$，然后转化为求 $k^q$ 的 $g$ 次方根，这样就规约到了 $n|(p-1)$ 的情况。但还有一个问题：$n/g$ 的逆元一定存在吗？取 $n=16,p-1=18$，我们发现实际上并不一定。

这里的解决方法是把 $n$ 加上 $p-1$ 的随机倍数。令 $p-1$ 任一质因数为 $q$，则要使 $\gcd(n+c(p-1),p-1)=1$，若 $v_q(n)\neq v_q(p-1)$，则只需 $c\bmod q\neq0$；否则，若 $v_q(n)=v_q(p-1)$，也只要 $(n/q^v)+c((p-1)/q^v)\bmod q\neq0$，即存在一个 $d$ 使得 $c\bmod q\neq d$ 即可。于是这样的 $c$ 是大量存在的，直接随机就可以快速找到。~~实际上，本题数据中直接取 1 就能过。~~

现在 $n|(p-1)$。求出最大的 $t$ 使得 $n^t|(p-1)$，令 $d=(p-1)/n^t$。对 $n$ 做质因数分解，随机一个数求 $d$ 次方，期望随机 $o(\log m)$ 次就能找到一个 $n^t$ 次单位根 $g$。现在求出 $g^0,g^{n^{t-1}},g^{2n^{t-1}},...,g^{(n-1)n^{t-1}}$ 放入哈希表。

令 $D=d^{-1}\bmod n$，$N=(Dd-1)/n$，$K=k^D$。由于一定有解，必然有 $K^{(p-1)/n}\bmod p=1$。两边同时开 $n$ 次方，得到一个 $n$ 次单位根，查表，设其为 $g^{a_0n^{t-1}}$，得 $K^{(p-1)/n^2}g^{-a_0n^{t-1}}\bmod p=1$。

继续这样两边同时开根然后除过去的操作，最终 $K^dg^{-(a_0n+a_1n^2+...+a_{t-2}n^{t-1})}\bmod p=1$，也即 $k^{Nn}g^{-(a_0n+a_1n^2+...+a_{t-2}n^{t-1})}\bmod p=k^{-1}$。

两边开根，$k^{1/n}=k^Ng^{a_0+a_1n+...+a_{t-2}n^{t-2}}$，于是右边就是一个合法的根；而 $n$ 次单位根已经全部在上面的表中了，可以直接得到所有的根。分析复杂度，每次开根需要计算 $O(\log m)$ 次快速幂，因此需要 $O(\log^2 m)$ 的时间。还有一个小问题：$d^{-1}\bmod n$ 不存在怎么办？当 $n$ 为质数时一定不会出现这种情况，因此把 $n$ 分解质因数之后多次开质数次方根即可，这不影响复杂度为 $O(s\log^2m)$。

## 牛顿迭代

现在我们已经求出了模 $p$ 意义下的根，我们要做的就是求出模 $p^c$ 意义下的根。

正如经典的求模 $2^k$ 逆元一样，在这里可以使用牛顿迭代。

定义 $\mathbb Q$ 上的 p-adic 赋值：$|\frac ab|=p^{v_p(b)-v_p(a)},a,b\in\Z-\{0\}$，特别地，$|0|=0$。

可以验证 p-adic 赋值满足如下三条性质：

（1）正定性：$|x|\geq0,|x|=0\iff x=0$

（2）积性：$|xy|=|x||y|$

（3）强三角不等式：$|x+y|\leq\max\{|x|,|y|\}$

对于解析函数 $f(z)$，设 $f(\zeta)=0,f'(\zeta)\neq0$，定义 $\gamma=\sup\limits_{k=2}^\infty\left |\dfrac{f^{(k)}(\zeta)}{k!f'(\zeta)}\right |^{\frac1{k-1}}$.

**引理** 若 $\gamma|z-\zeta|<1$，则 $|f'(z)/f'(\zeta)|=1$.

**证明** 在 $\zeta$ 处展开 $f$：
$$
\dfrac{f'(z)}{f'(\zeta)}=1+\sum\limits_{k=1}^\infty\dfrac{f^{(k+1)}(\zeta)(z-\zeta)^k}{k!f'(\zeta)}
$$
而
$$
\left |\dfrac{f^{(k+1)}(\zeta)(z-\zeta)^k}{k!f'(\zeta)}\right |=\left|\dfrac{f^{(k+1)}(\zeta)}{(k+1)!f'(\zeta)}\right||(z-\zeta)^k||k|\leq(\gamma|z-\zeta|)^k|k|<1
$$
于是 $|\sum\limits_{k=1}^\infty\dfrac{f^{(k+1)}(\zeta)(z-\zeta)^k}{k!f'(\zeta)}|<1$，$|f'(z)/f'(\zeta)|=1$.

**定理** 若 $\gamma|z-\zeta|<1$，则 $|z-f(z)/f'(z)-\zeta|\leq\gamma|z-\zeta|^2$.

**证明** 在 $\zeta$ 处展开 $f$：
$$
z-\dfrac{f(z)}{f'(z)}-\zeta=\dfrac1{f'(z)}(f'(z)(z-\zeta)-f(z))=\dfrac{f'(\zeta)}{f'(z)}\sum\limits_{k=2}^\infty\dfrac{(k-1)f^{(k)}(\zeta)(z-\zeta)^k}{k!f'(\zeta)}
$$
由引理知 $|f'(\zeta)/f'(z)|=1$，而 $\left|\dfrac{(k-1)f^{(k)}(\zeta)(z-\zeta)^k}{k!f'(\zeta)}\right|\leq|k-1|\gamma^{k-1}|z-\zeta|^k\leq\gamma|z-\zeta|^2$.

于是 $|z-f(z)/f'(z)-\zeta|\leq\gamma|z-\zeta|^2$.

本题中对 $f(z)=z^n-k$，有 $\gamma\geq|1/f'(\zeta)|\geq|1/n|$。也就是说，只要求出了模 $p^{v_p(n)+1}$ 意义下的根，就能通过 $O(\log\log m)$ 次牛顿迭代提升到模 $p$ 的任意幂次。那么模 $p^{v_p(n)+1}$ 意义下的根怎么求呢？不妨直接枚举。

由二项式定理可知，$k$ 在 $p$ 进制下最高的 $v_p(n)$ 位对 $k^n\bmod p^c$ 无任何贡献；而另一方面，由前面对乘法群结构的分析，根的个数恰有 $p^{v_p(n)}\gcd(n,p-1)$ 个。于是对每个模 $p$ 意义下的根，我们枚举其 $p$ 进制下第 $2$ 至 $v_p(n)+1$ 位怎么填，做牛顿迭代。应当恰好有一种填法能成功迭代得到一个特解，我们在它 $p$ 进制下最高的 $v_p(n)$ 位随意填数，便得到了所有解。

另外，对于 $p=2$ 且 $c\geq3$ 且 $2|n$ 的情况，需要特殊处理。由于乘法群结构不同，此时根的个数为 $2^{\min\{v_2(n)+1,c-1\}}$，意味着如果按照刚才的方法，会漏掉一半的根。这里我们注意到，若 $x$ 是方程的根，则 $-x$ 也一定是方程的根，于是在解集中加入所有已知根的相反数即可。

最终，我们得到了 $O(\operatorname{factorize}(m)+s\log^2m)$ 求解任意模数 $n$ 次剩余的方法。实际效率上，对于我的实现，在洛谷模板题比前最优解快了三分之一；理论上，在限制答案个数不太多的前提下，依据 LOJ 上离散对数和分解质因数模板题的最快记录，原先大概能做 $10^{20}$；通过这个做法规避离散对数之后，大概可以做到 $10^{30}$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
mt19937 rnd(114514);
struct FactorList{
	map<int,int>mp;
	FactorList(){}
	FactorList(int x){mp[x]=1;}
	void operator +(const int &h){mp[h]++;}
	void operator +=(const FactorList &h){
		for(auto it:h.mp)mp[it.first]+=it.second;
	};
	void print(){int fl=0;for(auto it:mp){if(fl)putchar('*');fl=1;printf("%d^%d",it.first,it.second);}puts("");}
};
namespace Factorize{
	const int N=1000;
	int m,c[31],pr[3]={2,7,61};FactorList f[N];
	void init(){
		for(int i=2;i<N;++i){
			int fl=1;
			for(int j=2;j*j<=i;++j)if(i%j==0){fl=0;f[i]=f[i/j];f[i]+=j;break;}
			if(fl)f[i]=i;
		}
	}
	bool chk(int n,int x){
		int v=pr[x],p=n;n--;m=1;while(!(n&1))n>>=1,++m;c[m]=1;
		while(n){if(n&1)c[m]=1ll*c[m]*v%p;v=1ll*v*v%p;n>>=1;}
		for(int i=m-1;i;--i)c[i]=1ll*c[i+1]*c[i+1]%p;
		for(int i=1;i<=m;++i){
			if(c[i]!=1&&c[i]!=p-1)return 0;
			if(i==1&&c[i]==p-1)return 0;
			if(i==m||c[i]==p-1)return 1;
		}
	}
	bool chk(int n){
		for(int i=0;i<3;++i)if(!chk(n,i))return 0;return 1;
	}
	int getd(int n){
		int s=0,t=0,c=rnd()&((1<<30)-1);
		while(1){
			int val=1;for(int i=1;;i<<=1){
				for(int j=1;j<=i;++j){
					t=(1ll*t*t+c)%n;val=1ll*val*abs(t-s)%n;
					if(!(i%31)){ll q=__gcd(n,val);if(q>1)return q;}
				}
				int q=__gcd(n,val);if(q==n)return getd(n);if(q>1)return q;s=t;
			}
		}
	}
	FactorList sol(int n){
		if(n<N)return f[n];
		if(chk(n))return n;
		int d=getd(n);FactorList h=sol(d);h+=sol(n/d);return h;
	}
};
void exgcd(int a,int b,int &x,int &y){
	if(!b){x=1;y=0;return;}
	exgcd(b,a%b,y,x);y-=a/b*x;
}
int inv(int x,int p){int a,b;if(x<0)x+=p;exgcd(x,p,a,b);if(a<0)a+=p;return a;}
ll fpowll(ll x,int y,ll p){
	ll s=1;while(y){if(y&1)s=(__int128)s*x%p;x=(__int128)x*x%p;y>>=1;}return s;
}
int fpow(int x,int y,int p){
	int s=1;while(y){if(y&1)s=1ll*s*x%p;x=1ll*x*x%p;y>>=1;}return s;
}
int fpow(int x,int y){
	int s=1;while(y){if(y&1)s=s*x;x=x*x;y>>=1;}return s;
}
vector<int> enumerate(int l,int r,int d){
	vector<int>v;for(int i=l;i<r;i+=d)v.push_back(i);
	return v;
}
vector<int> getroot0(int n,int k,int p){
	int t=0,d=p-1,w,u,npow[32]={1};while(d%n==0)d/=n,t++;for(int i=1;i<t;++i)npow[i]=npow[i-1]*n;
	FactorList N=Factorize::sol(n);unordered_map<int,int>mp;
	if(__gcd(n,d)>1){
		vector<int>w0,w1={k},w2;
		for(auto i:N.mp){
			for(int j=1;j<=i.second;++j){
				w2.clear();
				for(int k:w1){
					w0=getroot0(i.first,k,p);
					for(int l:w0)w2.push_back(l);
				}
				swap(w1,w2);
			}
		}
		return w1;
	}
	while(1){
		w=fpow(u=rnd(),npow[t-1]*d,p);if(w<0)w+=p;if(w==0||w==1)continue;
		int fl=1;for(auto it:N.mp)if(fpow(w,n/it.first,p)==1){fl=0;break;}if(fl)break;
	}
	for(int i=0,c=1;i<n;++i)mp[c]=i,c=1ll*c*w%p;u=fpow(u,d,p);
	int ans=0,d_=max(inv(n,d),1),k_=fpow(k,d_*n-1,p);
	for(int i=t-2;i>=0;--i){
		int h=1ll*fpow(k_,npow[i],p)*fpow(u,ans,p)%p;
		ans+=npow[t-1]*(n-mp[h]);ans/=n;
	}
	k=1ll*fpow(k,d_,p)*fpow(u,ans,p)%p;
	vector<int>v;for(int i=0;i<n;++i)v.push_back(k),k=1ll*k*w%p;return v;
}
vector<int> getroot(int n,int k,int p){
	if(!k)return {0};
	if(!n){if(k==1)return enumerate(1,p,1);return {};}
	if(n==1)return {k};
	if(!k)return {0};n+=p-1;
	int g=__gcd(n,p-1);
	k=fpow(k,inv(n,p-1),p);n=g;if(n==1)return {k};
	if(fpow(k,(p-1)/n,p)!=1)return {};
	return getroot0(n,k,p);
}
vector<int> getroot(int n,int k,int p,int pn){
	int q=fpow(p,pn),fac=1,fac1=1,fac2=q;k%=q;
	if(!k)return enumerate(0,q,fpow(p,(pn+n-1)/n));
	int h=0,u=p;while(k%p==0)k/=p,q/=p,h++;
	if(h%n)return {};
	fac=fpow(p,h/n);fac1=fpow(p,pn-h+h/n);pn-=h;
	vector<int>v=getroot(n%(p-1),k%p,p);vector<int>V;
	int n0=n;while(n%p==0)u*=p,n/=p,fac1/=p;u=min(u,q);fac1=max(fac1,fac*p);
	ll q0=1ll*u/p;
	for(int i:v)for(int j=i;j<u;j+=p){
		int x=j,x1,fl=0;
		for(int z=1;z<7;++z){
			ll t0=fpowll(x,n0-1,q0*q),t=(lll)t0*x%(q0*q);
			if((t-k)%q==0){fl=1;break;}
			x1=((k-t)/q0*inv(t0%q*n%q,q)+x)%q;if((x1-x)%u)break;x=x1;
		}
		if(!fl)continue;
		if(x<q)x+=q;x*=fac;x%=fac1;fl=0;for(int j=x;j<fac2;j+=fac1){V.push_back(j);if(j+x==fac2)fl=1;}
		if(p==2&&!fl&&q0>1)for(int j=x;j<fac2;j+=fac1)V.push_back(fac2-j);
		break;
	}
	return V;
}
bool chkroot(int n,int k,int p,int pn){
	int h=0,u=p,q=fpow(p,pn),ord;k%=q;if(!k)return 1;while(k%p==0)k/=p,q/=p,h++;if(h%n)return 0;if(q==1)return 1;
	ord=1ll*(p-1)*q/p;n%=ord;if(!n)return (k==1);
	if(p==2&&q<=4){for(int i=0;i<q;++i)if(fpow(i,n,q)==k)return 1;return 0;}
	if(p==2)ord>>=1;n=__gcd(n,ord);return (fpow(k,ord,p)==1);
}
void sol(){
	int n,m,k;FactorList M;vector<int>w0,w1,w2;w1.push_back(0);
	scanf("%d%d%d",&n,&m,&k);M=Factorize::sol(m);
	for(auto it:M.mp)if(!chkroot(n,k,it.first,it.second)){puts("0");return;}
	for(auto it:M.mp){
		int h=fpow(it.first,it.second);h=(1ll*inv(m/h,h)*m/h)%m;
		w0=getroot(n,k,it.first,it.second);
		if(w0.empty()){w1={};break;}
		w2.resize(w1.size()*w0.size());
		int k=0;for(int i:w1)for(int j:w0)w2[k++]=((1ll*j*h+i)%m);
		swap(w1,w2);
	}
	printf("%d\n",(int)w1.size());sort(w1.begin(),w1.end());for(int i=0;i<w1.size();++i){printf("%d",w1[i]);if(i<w1.size()-1)putchar(' ');else puts("");}
}
int main(){
	Factorize::init();
	int t;scanf("%d",&t);while(t--)sol();
	return 0;
}
```

## 闲话

写这篇文章，可以说是为了一瓶醋包了一碗饺子。当时在搜 p-adic 牛顿迭代有没有什么理论依据，找到了 [On a p-adic newton method](https://pbrdng.github.io/ma_breiding.pdf)，看了看分析还蛮有意思的，然后就想着能不能有什么应用，就搞出来了这个东西。

在这篇题解中，我们只用了原论文中结论的一个特例。我们只用到 p-adic 赋值的正定性、积性和强三角不等式，实际上这正是非阿基米德赋值的三条性质。于是它可以推广到一般非阿基米德赋值域上。例如，在有理分式域上，类似地，定义 $|f(x)/g(x)|=2^{-c}$，$c$ 为 $f(x)/g(x)$ 的最低非零项幂次数，便立即可以得到 oi 范围内所有多项式牛顿迭代的合理性。对于阿基米德赋值域(如赋予通常绝对值的实数域)也可以有类似的分析，但由于没有强三角不等式，需要类似等比数列求和的计算(具体过程可参见 [Complexity and Real Computation](https://zh.zb-lib.gs/book/2609421/f61f38/complexity-and-real-computation.html) Ch.8)，最终可知当 $\gamma|z-\zeta|<\frac{5-\sqrt{17}}4$ 时二阶收敛。

---

## 作者：Shunpower (赞：7)

## 前言

计算机好用的原因是，人类已经为它做了太多事情。—— @[StayAlone](https://www.luogu.com.cn/user/409236)

下文中可能存在变量名与题目冲突或不同（因为本文最初是学习笔记），请以本文定义为准。

## 正文

求解方程 $x^n\equiv k\pmod m$，其中 $x\in [0,m-1]$。

首先这个东西并不好做。注意到 $m$ 有唯一分解 $m=\prod p_i^{c_i}$，考虑针对每一个 $p_i^{c_i}$ 构造子方程 $x^n
\equiv k\pmod {p_i^{c_i}}$ 解一堆答案出来。然后对于每一个子方程的解集挑一个解，假设挑出的解分别为 $x_1,x_2,
\cdots$，注意到最终答案 $ans$ 一定满足对于每一个子方程的解都有 $ans\equiv k\equiv x_i\pmod{p_i^{c_i}}$，因此采用 DFS 挑解并且 CRT 合并即可。

下面我们考虑如何解 $x^n
\equiv k\pmod {p^{c}}$。

### $p\neq 2$

#### $k=0$

注意到只要 $x=p^aq$ 且 $an\geqslant c$ 即可。因此解集为所有 $p^{\left\lceil \frac{c}{n}\right\rceil}|x$。

#### $k\neq 0\land k\perp p^c$

注意到此时 $p^c$ 必然存在原根。根据原根和阶的性质，$g^a,a\in[0,\varphi
(n))$ 可以取到模 $n$ 意义下（也就是 $[0,n)$ 中）的所有与 $n$ 互质的数。而且这样的一个周期为 $\varphi(n)$，也就是从 $0$ 起每隔 $\varphi(n)$ 长度为一块，每一块里面都有这个性质。

那么下面不妨假设 $f=\varphi(p^c)$。

算出 $p^c$ 的最小原根 $g$，注意到 $k$ 可以表示为 $g^a$，而此时又显然有 $x\perp p^c$，因此不妨把 $x$ 表示为 $g^b$。那么原来的方程可以变为 $(g^b)^n\equiv g^a\pmod {p^c}(a,b\in[0,f))$。

> 算出最小原根的方法：
>
> 存在原根判定定理：$g$ 是 $m$ 的原根当且仅当对于所有 $\varphi(m)$ 的质因数 $p$ 都有 $g^{\frac{\varphi(m)}{p}}\not\equiv 1\pmod m$。
> 
> 然后这里有一个误区。实际上王元并没有证明对于任意 $m$，它的原根的级别都是 $\mathcal O(m^{0.25})$，[这里](https://www.luogu.com.cn/discuss/608103)已经有人给出了原论文，可以看到他只证明了对于奇质数而言存在这样的性质。但根据最新一条评论说明，把若干论文拼在一起可以得到最小原根级别的广泛性质。
>
> 无论怎么样，我们还是直接暴力找最小原根就可以了。

接下来很容易可以用反证推出 $k\perp p^c\Rightarrow g\perp p^c$，于是 $a$ 可以直接采用 BSGS 求出来。考虑指数，由于原根的周期为 $f$，因此我们容易得到 $bn\equiv a\pmod f$。注意到 $n,a,f$ 都是已知的，线性同余方程，采用 exgcd 解然后枚举 $b\in[0,f)$ 的通解，再根据 $x=g^b$ 搞定答案。

#### $k\neq 0\land k\not\perp p^c$

很遗憾，此时 $k$ 由于和模数不互质并不能表示为 $g$ 的幂。

因为 $p$ 是质数，注意到此时 $k$ 一定是 $p^aq$ 的形式，此处要求 $q\perp p^c$ 否则显然可以继续分解。同理，$x$ 当中也必须有 $p$ 因子否则不可能和 $k$ 同余，因此不妨表示 $x$ 为 $p^br$。

那么原式变为 $(p^br)^n\equiv p^aq\pmod {p^c}$。

注意到 $k\neq 0\to a<c$，意味着右侧有完整的 $a$ 个 $p$。而左侧的 $p^{bn}$ 项也就必须拥有完整的 $a$ 个 $p$。于是有 $bn=a$ 这一重大结论。

注意到 $n\nmid a$ 时找不到这样一个 $b$，判断一下。

接下来 $b$ 变成常数了，我们基本啥都知道了。

考虑改写式子为 $p^{bn}r^n-p^aq=i\times p^c$，注意到可以提取公因数，因此有 $p^a(r^n-q)=i\times p^{c-a}$，考虑改写回去为同余方程，那么有 $r^n\equiv q\pmod {p^{c-a}}$。

注意到显然有 $p^{c-a}\perp q$，于是规约到之前的情况解决，把 $r$ 全部解出来即可。

不妨考虑枚举所有 $r$，注意到此时我们得到 $r$ 的值因为是在之前的方法求解，因此有 $r\in[0,p^{c-a})$，但这里没有类似 $x$ 的限制，可以往 $r$ 上随便加 $p^{c-a}$ 得到更多满足条件的 $r$。对于每个 $r$ 我都尝试往上加 $0,1,2\cdots$ 个 $p^{c-a}$，只要乘上 $p^b<p^c$ 就好了。对于每个 $r$（包括靠增加衍生出来的），都可以计算出一个 $x$。

注意到尝试往上加的数量一定是有限个。具体来说，$r\in [0,p^{c-b})$，而每次会增加 $p^{c-a}$，因此最多增加 $p^{c-b-(c-a)}-1=p^{a-b}-1$ 个就够了（开区间，所以要减掉 $1$，此外注意可以增加 $0$ 个）。

### $p=2$

$p=2$ 的时候很遗憾并不是所有 $2^c$ 都存在原根，于是我们有一种表现优秀的暴力可以考虑。

注意到 $x^n\equiv b\pmod {2^c}$ 时，考虑求出 $y^n\equiv b\pmod{2^{c-1}}$，那么存在 $x=y$ 或者 $x=y+2^{c-1}$（非常好感性理解），递归求解 $c-1$ 的答案并且暴力检验 $c$ 的答案即可。

$c=0$ 时设置解为 $0$ 即可。

复杂度不清楚，但是一般数据下表现其实很不错。令人遗憾的是最终还是被叉了，下面有一个厉害的正确方法。

------------------

先干掉 $p=2,c\leqslant 2$，这两种情况下是有原根的，由于奇质数的部分没有用到“存在原根”以外的任何奇质数性质，我们把它规约到奇质数去也没什么问题。

首先容易归纳证明 $5^{2^{c-3}}\equiv 2^{c-1}+1\pmod {2^c}$，具体来说，$c=3$ 时结论显然，然后考虑假设 $c=i$ 时有 $5^{2^{c-3}}\equiv 2^{c-1}+1\pmod{2^c}$ 去证明 $c=i+1$ 时也有这个结论。对该同余方程在模 $2^{c+1}$ 时的形态进行讨论，再将两边同时平方、化简即可证明。

然后由于 $5\perp 2^c(c>0)$，根据阶的性质可以知道 $5^{\varphi(2^c)}\equiv 1\pmod {2^c}$ 且 $5$ 在模 $2^c$ 意义下的阶（下面简称 $5$ 的阶）一定整除 $\varphi(2^c)=2^{c-1}$ 即所有质因子均是 $2$。

然后考虑 $5^{2^i}\equiv 1\pmod {2^c}$，对它左右两边不断平方可以证明 $5^{2^j}\equiv 5^{2^i}\equiv1\pmod {2^c}(j\geqslant i)$，于是我们得知 $5$ 的阶一定 $>2^{c-3}$ 否则 $5^{2^{c-3}}\equiv 1\pmod {2^c}$。与此同时我们考虑对 $5^{2^{c-3}}\equiv 2^{c-1}+1\pmod {2^c}$ 进行平方，展开后得到 $5^{2^{c-2}}\equiv 1\pmod {2^c}$ 于是有 $5$ 的阶 $\leqslant 2^{c-2}$。由于 $5$ 的阶中只有 $2$ 这一个质因子，那么 $5$ 的阶只能是 $2^{c-2}$。

根据阶的性质，我们有 $5^i,\forall i\in[0,2^{c-2})$ 构成的集合没有重复元素，且从 $2^{c-2}+1$ 开始进入下一个周期。然后考虑构造 $(-1)^a5^b\equiv x\pmod {2^c},x\perp 2,a\in[0,1],b\in[0,2^{c-2})$，由于周期性更大的 $b$ 和此情况是等价的。考虑证明该方程有唯一解。

不存在两个解可以考虑进行反证 $(-1)^{a_1}5^{b_1}\equiv (-1)^{a_2}5^{b_2}\pmod {2^c}$，由无重复元素的性质可知不可能存在 $a_1=a_2$，于是一般地有 $5^{b_1}+5^{b_2}\equiv 0\pmod {2^c}$。由于 $c>2$，左侧模 $4$ 为 $2$，右侧是 $0$，于是原命题矛盾。

一定有解比较显然，$(a,b)$ 的所有可能组合共 $2^{c-1}$ 种，$x$ 的所有可能也有 $2^{c-1}$ 种。由于前面证明不可能存在两个不同的 $(a,b)$ 解相同，所以这两者必然一一对应因此一定有解。

经过一通精妙构造之后我们把这坨东西带回到原命题并对 $k$ 做同样操作。在 $k\perp 2$ 的情况下显然也有 $x\perp 2$，于是得到 $(-1)^{a_1n}5^{b_1n}\equiv (-1)^{a_2}5^{b_2}\pmod {2^c}$。由于在模 $2^c$ 意义下 $-1$ 的周期为 $2$，$5$ 的周期为它的阶 $2^{c-2}$，这两者独立，于是我们容易得到两个同余方程 $a_1n\equiv a_2\pmod 2,b_1n\equiv b_2\pmod {2^{c-2}}$，由于 $5\perp 2^c$，枚举 $a_2$，尝试用 BSGS 搞出 $b_2$ 得到解，再两遍 exgcd 即可，注意 BSGS 和 exgcd 都需要判无解。

最后的问题在于 $k\not\perp 2$ 怎么搞。先干掉 $k=0$，这个时候显然我们拿出奇质数时 $k=0$ 的做法就行了。而普通的不互质，我们发现奇质数搞不互质的时候用不到一点奇质数的性质，所以也拿出奇质数时 $k\not\perp p^c$ 的做法就行了。

把上面所有东西拼在一起就可以了。

------------------

最终 DFS 挑方程答案并且 CRT 合并的时候需要注意某个方程无解的时候特判一下。

注意到整个算法过程中每次枚举都至少为方程贡献了一个解，所以总的复杂度是解的数量加上每个方程中进行 BSGS exgcd 等贡献的一些不太大的项，足够通过本题。

代码一通狂写写了 8.48K，[写得相当丑](https://www.luogu.com.cn/paste/6yg8ofh2)，随便看看就行了，思路理顺了拼一下各种板子还是好写的。

[AC 记录](https://www.luogu.com.cn/record/134298818)

---

## 作者：Leasier (赞：4)

Update on 2023.9.8：已通过 [Hack 数据](https://www.luogu.com.cn/discuss/646392)。

这里的 $m$ 没有特殊性质，考虑将其分解为 $m = \displaystyle\prod_{i = 1}^{\omega(m)} p_i^{q_i}$，并在依次求出每个 $x^n \equiv k \pmod{p_i^{q_i}}$ 的所有解后暴力合并。

问题转化为求出形如 $x^n \equiv k \pmod{p^q}$ 的方程的所有解。

1. $k \bmod p^q = 0$

此时设 $x = ap^b, k = p^c$（$a \bmod p \neq 0 \operatorname{and} b, c \in Z$），则 $bn \geq c$ 即 $b \geq \lceil \frac{c}{n} \rceil$，于是此时 $x$ 可以取遍 $p^q$ 以内所有**包含 $0$ 在内的** $p^{\lceil \frac{c}{n} \rceil}$ 的倍数。直接暴力枚举即可。

2. $k \bmod p^q \neq 0 , k \bmod p = 0$

此时设 $x = ap^b, k = cp^d$（$a, c \bmod p \neq 0 \operatorname{and} b, d \in Z$），则 $bn = d$ 且 $a^n \equiv c \pmod{p^{q - d}}$。此时我们可以直接解出 $b = \frac{d}{n}$，求余下那个方程交给接下来要讲的两种情况。

考虑解出所有 $a$ 后的操作。对于每个符合条件的 $a$ 和 $t \in Z$，令 $a' = a + tp^{q - d}$，则所有 $x = a'p^b < p^q$ 都是可行的解。

3. $k \bmod p \neq 0, p \neq 2 \operatorname{or} q \leq 2$

此时求出 $p^q$ 的一个原根 $g$，设 $x = g^a, k = g^b$，则 $na \equiv b \pmod{\varphi(p^q)}$。在求出原根后，$b$ 可以用 BSGS 解出，$a$ 可以用 exgcd 解线性同余方程得出。

4. $k \bmod p \neq 0, p = 2, q > 2$

这里给出一个结论：

- $\forall x \in [0, 2^q)$，$x \bmod 2 \neq 0$，$x$ 可以唯一地表示为 $x \equiv (-1)^a 5^b \pmod{2^q}$。

证明：首先不难归纳得出 $5^{2^{q - 3}} \equiv 2^{q - 1} + 1 \pmod{2^q}$，于是 $\operatorname{ord}_{2^q}(5) > 2^{q - 3}$；又因为 $(2^{q - 1} + 1)^2 \equiv 1 \pmod{2^q}$，则 $\operatorname{ord}_{2^q}(5) \mid 2^{q - 2}$；可得 $\operatorname{ord}_{2^q}(5) = 2^{q - 2}$，又因为一定 $\nexists b_1 \neq b_2, 5^{b_1} + 5^{b_2} \equiv 0 \pmod{2^q}$，则表示方式唯一。

于是我们 BSGS 解出 $k$ 的表示方式，exgcd 求出 $x$ 的所有可能表示方式即可。

时间复杂度看起来很高，但由于这道题保证每个质因数幂次对应的解数和所有询问的总解数 $\leq 10^6$，实际上可以通过。

需要注意的是，有可能某一个质因数幂次对应的方程无解但其他质因数幂次对应的方程解数都很大，此时需要提前判断是否存在一个质因数幂次对应的方程无解。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <vector>
#include <cstdio>
#include <cmath>

using namespace std;

typedef long long ll;

typedef struct {
	int mod;
	vector<ll> v;
	
	inline void clear(){
		mod = 1;
		v.clear();
	}
} Equation;

map<int, int> mp1;
map<ll, int> mp2;
vector<Equation> v;

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

inline int lcm(int a, int b){
	return a * b / gcd(a, b);
}

void exgcd(ll a, ll b, ll &x, ll &y){
	if (b == 0){
		x = 1;
		y = 0;
		return;
	}
	ll t;
	exgcd(b, a % b, x, y);
	t = x;
	x = y;
	y = t - a / b * y;
}

Equation operator +(Equation &a, Equation &b){
	int sizea = a.v.size(), sizeb = b.v.size();
	ll d = gcd(a.mod, b.mod), x, y, t1 = a.mod / d;
	Equation ans;
	ans.mod = lcm(a.mod, b.mod);
	exgcd(a.mod, b.mod, x, y);
	for (register int i = 0; i < sizea; i++){
		for (register int j = 0; j < sizeb; j++){
			ll t2 = ((a.v[i] - b.v[j]) % a.mod + a.mod) % a.mod;
			if (t2 % d == 0) ans.v.push_back(((b.v[j] + b.mod * (y * (t2 / d) % t1) % ans.mod) % ans.mod + ans.mod) % ans.mod);
		}
	}
	sort(ans.v.begin(), ans.v.end());
	ans.v.erase(unique(ans.v.begin(), ans.v.end()), ans.v.end());
	return ans;
}

Equation operator +=(Equation &a, Equation &b){
	return a = a + b;
}

inline int quick_pow(int x, int p){
	int ans = 1;
	while (p){
		if (p & 1) ans *= x;
		x *= x;
		p >>= 1;
	}
	return ans;
}

inline int euler(int n){
	int ans = n;
	for (register int i = 2; (ll)i * i <= n; i++){
		if (n % i == 0){
			ans = ans / i * (i - 1);
			while (n % i == 0){
				n /= i;
			}
		}
	}
	if (n > 1) ans = ans / n * (n - 1);
	return ans;
}

inline void decompound(int n){
	mp1.clear();
	for (register int i = 2; i * i <= n; i++){
		while (n % i == 0){
			n /= i;
			mp1[i]++;
		}
	}
	if (n > 1) mp1[n] = 1;
}

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline int get_least_primitive_root(int n){
	int phi_n = euler(n);
	decompound(phi_n);
	for (register int i = 0; i < n; i++){
		if (gcd(i, n) > 1) continue;
		bool flag = true;
		for (register map<int, int>::iterator j = mp1.begin(); j != mp1.end(); j++){
			if (quick_pow(i, phi_n / j->first, n) == 1){
				flag = false;
				break;
			}
		}
		if (flag) return i;
	}
	return -1;
}

inline ll inv(ll a, ll b){
	ll x, y;
	exgcd(a, b, x, y);
	return (x % b + b) % b;
}

inline int bsgs(int a, int b, int p){
	if (p == 1) return 0;
	a %= p;
	b %= p;
	if (b == 1) return 0;
	if (a == 0) return b == 0 ? 1 : -1;
	int n = ceil(sqrt(euler(p))), i = 0;
	ll t = quick_pow(a, n, p);
	mp2.clear();
	for (register ll j = b; i < n; i++, j = j * a % p){
		mp2[j] = i;
	}
	i = 1;
	for (register ll j = t; i <= n; i++, j = j * t % p){
		if (mp2.count(j)) return i * n - mp2[j];
	}
	return -1;
}

inline Equation solve1(int a, int b, int p){
	int g = get_least_primitive_root(p), c = bsgs(g, b, p), phi_p = euler(p), d = gcd(a, phi_p);
	Equation ans;
	ans.mod = p;
	if (c % d != 0) return ans;
	int t = phi_p / d;
	ll e = quick_pow(g, t, p), x, y, z;
	exgcd(a, phi_p, x, y);
	x = (x * (c / d) % t + t) % t;
	z = quick_pow(g, x, p);
	while (x < phi_p){
		ans.v.push_back(z);
		x += t;
		z = z * e % p;
	}
	sort(ans.v.begin(), ans.v.end());
	return ans;
}

inline vector<ll> solve2(int a, int b, int p){
	int d = gcd(a, p);
	if (b % d != 0) return vector<ll>();
	int t = p / d;
	ll x, y;
	vector<ll> ans;
	exgcd(a, p, x, y);
	x = (x * (b / d) % t + t) % t;
	while (x < p){
		ans.push_back(x);
		x += t;
	}
	return ans;
}

inline Equation solve3(int a, int b, int p, int p_pow_k){
	if (p > 2 || p_pow_k <= 4) return solve1(a, b, p_pow_k);
	int x = bsgs(5, b, p_pow_k), y, size1, size2;
	vector<ll> v1, v2;
	Equation ans;
	ans.mod = p_pow_k;
	if (x != -1){
		y = 0;
	} else {
		y = 1;
		x = bsgs(5, p_pow_k - b % p_pow_k, p_pow_k);
	}
	v1 = solve2(a, y, 2);
	v2 = solve2(a, x, p_pow_k / 4);
	size1 = v1.size();
	size2 = v2.size();
	for (register int i = 0; i < size1; i++){
		if (v1[i] == 0){
			v1[i] = 1;
		} else {
			v1[i] = p_pow_k - 1;
		}
	}
	for (register int i = 0; i < size2; i++){
		v2[i] = quick_pow(5, v2[i], p_pow_k);
	}
	for (register int i = 0; i < size1; i++){
		for (register int j = 0; j < size2; j++){
			ans.v.push_back(v1[i] * v2[j] % p_pow_k);
		}
	}
	sort(ans.v.begin(), ans.v.end());
	return ans;
}

void write(int n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

void write(ll n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

int main(){
	int t;
	cin >> t;
	for (register int i = 1; i <= t; i++){
		int n, m, k, ansa;
		bool flag = false;
		Equation ansb;
		cin >> n >> m >> k;
		v.clear();
		for (register int j = 2; j <= m; j++){
			if (j * j > m){
				if (m == 1) break;
				j = m;
			}
			if (m % j == 0){
				int power = 0;
				Equation equation;
				equation.clear();
				while (m % j == 0){
					m /= j;
					equation.mod *= j;
					power++;
				}
				if (k % equation.mod == 0){
					int x = quick_pow(j, (power - 1) / n + 1);
					for (register int y = 0; y < equation.mod; y += x){
						equation.v.push_back(y);
					}
				} else if (k % j == 0){
					int u = k, v = 1, w = 0;
					while (u % j == 0){
						u /= j;
						v *= j;
						w++;
					}
					if (w % n != 0){
						flag = true;
						break;
					}
					int size;
					ll mul = quick_pow(j, w / n, equation.mod);
					Equation t = solve3(n, k / v, j, equation.mod / v);
					size = t.v.size();
					for (register int x = 0; x < size; x++){
						for (register int y = 0; ; y++){
							ll val = mul * (t.v[x] + y * t.mod);
							if (val >= equation.mod) break;
							equation.v.push_back(val);
						}
					}
				} else {
					equation = solve3(n, k, j, equation.mod);
				}
				if (equation.v.empty()){
					flag = true;
					break;
				}
				v.push_back(equation);
			}
		}
		if (flag){
			write(0);
			putchar('\n');
		} else {
			int size = v.size();
			ansb.clear();
			ansb.v.push_back(0);
			for (register int j = 0; j < size; j++){
				ansb += v[j];
			}
			ansa = ansb.v.size();
			write(ansa);
			putchar('\n');
			if (ansa != 0){
				for (register int j = 0; j < ansa; j++){
					write(ansb.v[j]);
					putchar(' ');
				}
				putchar('\n');
			}
		}
	}
	return 0;
}
```

---

## 作者：Union_Find (赞：1)

首先我们注意到的就是模数不是质数，这比较麻烦，我们考虑质因数分解，然后用**中国剩余定理**求解。接下来我们就只要求模数是 $p^c$ 的情况即可。我们先令 $k \bmod p^c$。

# $k = 0$

这种情况就是 $p^c | x^n$。我们考虑把 $x$ 中 $p$ 的因子提出来。不妨设 $x=p^tq$。那么我们就有 $p^c | p^{tn}q^n$，我们可以直接得出 $tn \ge c$，那么 $t \ge \left \lceil \frac{c}{n} \right \rceil$。$x$ 就是 $p^{\left \lceil \frac{c}{n} \right \rceil}$ 的所有倍数。

```cpp
if (!k){
	int tmp = pw(p, (c - 1) / n + 1);
	for (int i = 0; i < lim; i += tmp) X.push_back(i);
	return ;
}
```

# $p$ 为奇素数

我们容易想到的是 $x^n \equiv k \pmod {p^c}$ 不好直接求解，而求解比较常见的是 exgcd。我们考虑转化成 $ax \equiv b \pmod P$ 的形式。

用离散对数，因为 $p^c$ 存在原根，不妨设是 $g$。那么令 $k = g^r,x=g^a$。当然，这个前提是 $p\not |  k$。

## $\gcd(p,k) \not= 1$

我们考虑先转化称等价形式，简单来讲就是一直除 $p$。同样我们不妨设 $k = p^{t_1}q_1,x=p^{t_2}q_2$。那么可以得出 $p^{t_2n}q_2^n \equiv p^{t_1}q_1 \pmod {p^c}$。因为 $k < p^c$，所以 $t_1 < p^c$，我们就可以容易得到 $t_2n = t_1$，所以如果 $t_1$ 不是 $n$ 的倍数，就无解。所以我们直接全都除 $p^{t_1}$，那么得到 $q_2^n \equiv q_1 \pmod {p^{c-t_1}}$。这样子 $q_1$ 就和模数互质了，变成了子问题。

我们先不考虑如何求 $q_2$，考虑求出 $q_2$ 之后，我们如何确定所有的 $x$。因为 $x = p^{t_2}q_2$，所以我们直接枚举 $p^{t_2}$ 即可。

```cpp
int cnt = 0, mod, phi;
while (k % p == 0) k /= p, cnt++;
c -= cnt, mod = pw(p, c), phi = mod / p * (p - 1);
if (cnt % n) return ;

// 求解子问题

vector <int> XX = X;
X.clear();
int top = pw(p, cnt - (cnt / n)), D = pw(p, c), M = pw(p, (cnt / n));
for (int u : XX) for (int i = u, j = 1; j <= top; j++, i = (i + D) % P) X.push_back(i * M % P); 
```

## $\gcd(p,k)=1$

我们现在求的就是 $x^n\equiv k\pmod {p^c}$。按照之前的思路，我们可以用离散对数表示，令 $k = g^r,x=g^a$。

$$x^n \equiv k \pmod {p^c}$$
$$g^{an} \equiv g^r \pmod {p^c}$$

根据欧拉定理，我们有如下结论。

$$an \equiv r \pmod{\phi(p^c)}$$

这个 $\phi(p^c)$ 其实就是 $p^{c-1} \times (p-1)$。

这个式子可以直接用 exgcd 先求特解，然后求所有解。

```cpp
int g = find_G(mod, phi), r = BSGS(g, k, mod), a, Tmp, d = exgcd(n, phi, a, Tmp); 
if (r % d) return ;
int D = phi / d, tmp = ksm(g, D, mod);
a = (a * (r / d) % D + D) % D;
for (int x = ksm(g, a, mod); a < phi; a += D, x = 1ll * x * tmp % mod) X.push_back(x);
```

这里的 $r$ 用 BSGS 求，直接用 `map` 即可通过。

# $p=2$

如果没有这一部分，这题就只是紫题了。这一部分是最难的，包括了很多**逆天注意力**。

首先这一部分需要分出来是因为 $2^c$ 在 $c>2$ 时没有原根，先处理掉 $c=1,2$ 的情况，这个和上面 $p$ 为奇素数的情况一样处理。

引理1：$5^{2^{c-3}} \equiv 2^{c-1}+1 \pmod {2^c}$。
> 证明：$c=3$ 显然，证明 $c>3$，归纳证明。假设 $5^{2^{c-4}} \equiv 2^{c-2}+1 \pmod{2^{c-1}}$，那么 $5^{2^{c-4}} \equiv 2^{c-2}+1 \mod{2^c}$ 或 $5^{2^{c-4}} \equiv 2^{c-2}+2^{c-1}+1 \mod{2^c}$。不管是哪个式子，平方后都可以得到 $5^{2^{c-3}} \equiv 2^{c-1}+1 \pmod {2^c}$。证毕。

根据这个引理，我们可以求出 $5$ 在 $2^c$ 意义下的阶。

引理2：$5$ 在模 $2^c$ 意义下阶为 $2^{c-2}$。

> 证明：首先根据阶的性质我们得知，$5$ 的阶一定整除 $\phi(2^c)$，所以 $5$ 的阶一定是 $2^i$。所以 $5^{2^i} \equiv 1 \pmod{2^c}$。两边不断平方得 $5^{2^j} \equiv 5^{2^i} \equiv 1 \pmod {2^c}$，即对于所有比 $i$ 大的 $j$，$2^j$ 都是阶。
> 那么我们得知，如果阶小于等于 $2^{c-3}$，那么 $5^{2^{c-3}} \equiv 1 \pmod{2^c}$。但是 $5^{2^{c-3}} \equiv 2^{c-1}+1 \pmod{2^c}$，产生矛盾，所以 $5$ 的阶一定大于 $2^{c-3}$。
> 同时我们对 $5^{2^{c-3}} \equiv 2^{c-1}+1 \pmod{2^c}$ 左右同时平方，可以得到 $5^{2^{c-2}} \equiv 1 \pmod{2^c}$。所以阶一定是 $2^{c-2}$。

根据阶的性质，我们知道在 $i \in [0,2^{c-2})$ 中，$5^i$ 没有重复元素，考虑可以用 $5$ 代替原根进行计算。

首先考虑 $k$ 为偶数，我们可以用前面 $p$ 为奇素数时 $k|p$ 的处理方法处理掉，让 $k$ 变成奇数，然后计算。此时 $x$ 一定时奇数，那么 $x$ 就有 $2^{c-1}$ 种选择。直接用 $5$ 代替原根是做不到的，因为 $5$ 的阶只有 $2^{c-2}$，考虑加一个系数。容易想到的就是加上一个正负号，即变成 $(-1)^a5^b \equiv x \pmod {2^c}$。考虑证明 $x$ 唯一对应一个 $(a,b)$ 二元组。

> 证明一个 $x$ 不存在两个 $(a,b)$ 二元组：假设存在 $x\equiv (-1)^{a_1}5^{b_1} \equiv (-1)^{a_1}5^{b_2} \pmod{2^c}$，那么因为在 $i \in [0,2^{c-2})$ 中，$5^i$ 没有重复元素，所以 $a_1 \not= a_2$。所以 $5^{b_1} + 5^{b_2} \equiv 0 \pmod {2^c}$。但是因为 $c>2$，所以左侧模 $4$ 是 $2$，右边是 $0$。矛盾。
> 证明每个 $x$ 都有解：因为 $(a,b)$ 二元组有 $2^{c-1}$ 个，$x$ 也有 $2^{c-1}$，一个 $x$ 至多对应一个 $(a,b)$，所以一定有解，即 $(a,b)$ 和 $x$ 一一对应。

于是我们就可以先用 $(a,b)$ 表示出 $k$，记为 $(a_1,b_1)$，假设 $(-1)^{a_2}5^{b_2} \equiv x \pmod {2^c}$，那么我们发现 $a$ 和 $b$ 两个是可以分开计算的，即我们有如下式子。

$$a_2n \equiv a_1 \pmod 2$$
$$b_2n \equiv b_1 \pmod{2^{c-2}}$$

直接枚举 $a_2$，用 BSGS 求出 $b_2$，然后两边 exgcd 即可。

# 整合

我们用上面的方法即可求出所有模 $p^c$ 的 $x$，然后我们可以 $\text{dfs}$ 暴力枚举每个方程以哪个为解，用 $\text{CRT}$ 求出最终解。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 15
#define VAL 100005
#define int ll
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
int n, k, P, cnt, g, p_t[N], c_t[N], isp[VAL], pr[VAL], tot, PR[N], x[N]; 
vector <int> ans, X[N];

int gcd(int a, int b){return (!b ? a : gcd(b, a % b));}
int exgcd(int a, int b, int& x, int& y){
	if (!b) return x = 1, y = 0, a;
	int d = exgcd(b, a % b, y, x);
	return y -= a / b * x, d;
}
il int inv(int a, int P){
	int x, y, d = exgcd(a, P, x, y);
	return (x % P + P) % P;
}
int pw(int x, int r){
    int ans = 1;
    for (; r; x *= x, r >>= 1) if (r & 1) ans *= x;
    return ans;
}
int ksm(int x, int r, int P){
    int ans = 1;
    for (; r; x = 1ll * x * x % P, r >>= 1) if (r & 1) ans = 1ll * ans * x % P;
    return ans;
}
map <int, int> tp;
il int BSGS(int a, int b, int p){
    int V = ceil(sqrt(p));
    tp.clear(), b %= p;
    int base = 1;
    for (int B = 0; B < V; B++, base = 1ll * base * a % p) tp[1ll * b * base % p] = B;
    for (int A = 0, prod = 1; A <= V; A++, prod = 1ll * prod * base % p){
        int tmp = prod;
        if (tp.find(tmp) != tp.end() && 1ll * A * V - tp[tmp] >= 0) return 1ll * A * V - tp[tmp];
    }
    return -1;
}
il int find_G(int n, int phi){
    int cnt = 0, x = phi;
    for (int i = 1; i <= tot && pr[i] <= x; i++) if (x % pr[i] == 0){
    	while (x % pr[i] == 0) x /= pr[i];
    	PR[++cnt] = pr[i];
	}
	if (x > 1) PR[++cnt] = x;
    for (int i = 1;; i++){
        if (ksm(i, phi, n) != 1) continue;
        int flag = 1;
        for (int j = 1; j <= cnt; j++) if (ksm(i, phi / PR[j], n) == 1){flag = 0;break;}
        if (flag) return i;
    }
}
void dfs(int x, int val){
	if (x > cnt) return ans.push_back(val % P), void(0);
	int pt = pw(p_t[x], c_t[x]), m = P / pt, iv = inv(m, pt);
	for (int u : X[x]) dfs(x + 1, val + m * iv * u);
}

il void solve(int p, int c, int k, vector <int> &X){
	int lim = pw(p, c);
	if (!k){// k = 0
		int tmp = pw(p, (c - 1) / n + 1);
		for (int i = 0; i < lim; i += tmp) X.push_back(i);
		return ;
	}
	int cnt = 0, mod, phi;// 处理 gcd(p,k)=1 的情况 
	while (k % p == 0) k /= p, cnt++;
	c -= cnt, mod = pw(p, c), phi = mod / p * (p - 1);
	if (cnt % n) return ;
	if (p == 2 && c > 2){
		for (int a2 = 0; a2 <= 1; a2++){
			int trn = pw(2, c - 2), a1, b1, Tmp, d1 = exgcd(n, 2, a1, Tmp), x2, y2, d2 = exgcd(n, trn, b1, Tmp);
			int b2 = BSGS(5, (a2 ? mod - k : k), mod);
			if (b2 == -1) continue;
			if (a2 % d1 || b2 % d2) return ;
			int D1 = 2 / d1, D2 = trn / d2, Dp5 = ksm(5, D2, mod);
			a1 = (a1 * (a2 / d1) % D1 + D1) % D1, b1 = (b1 * (b2 / d2) % D2 + D2) % D2;
			for (; a1 < 2; a1 += D1){
				for (int i = b1, p5 = ksm(5, b1, mod); i < trn; i += D2, p5 = 1ll * p5 * Dp5 % mod)
					X.push_back((a1 ? (mod - p5) : p5) % mod);
			}
		}
	}
	else{// p 为奇素数或 2,4 
		int g = find_G(mod, phi), r = BSGS(g, k, mod), a, Tmp, d = exgcd(n, phi, a, Tmp); 
		if (r % d) return ;
		int D = phi / d, tmp = ksm(g, D, mod);
		a = (a * (r / d) % D + D) % D;
		for (int x = ksm(g, a, mod); a < phi; a += D, x = 1ll * x * tmp % mod) X.push_back(x);
	}
	vector <int> XX = X;// 转化成子问题之后还原出所有解 
	X.clear();
	int top = pw(p, cnt - (cnt / n)), D = pw(p, c), M = pw(p, (cnt / n));
	for (int u : XX) for (int i = u, j = 1; j <= top; j++, i = (i + D) % P) X.push_back(i * M % P);
}
int Main(){
	for (int i = 1; i <= cnt; i++) X[i].clear();
	ans.clear();
	n = rd(), P = rd(), k = rd(), cnt = 0;
	int x = P;
	for (int i = 2; i * i <= x; i++) if (x % i == 0){
		int c = 0;
		while (x % i == 0) x /= i, c++; 
		p_t[++cnt] = i, c_t[cnt] = c, solve(i, c, k % pw(i, c), X[cnt]); 
	}
	if (x > 1) p_t[++cnt] = x, c_t[cnt] = 1, solve(x, 1, k % x, X[cnt]);
	for (int i = 1; i <= cnt; i++) if (X[i].empty()) return puts("0"), 0;
	dfs(1, 0);
	printf ("%d\n", ans.size());
	sort (ans.begin(), ans.end());
	for (int u : ans) printf ("%d ", u);
	puts("");
	return 0;
}
signed main(){
	isp[1] = 1, n = 100000;
	for (int i = 2; i <= n; i++) if (!isp[i]){
		pr[++tot] = i;
		for (int j = i + i; j <= n; j += i) isp[j] = 1;
	}
	
	for (int T = rd(); T--;) Main(); 
	return 0;
}

```

---

## 作者：gxy001 (赞：1)

看了不求离散对数求任意模数 $n$ 次剩余的那篇题解，但是没看懂牛顿迭代，仔细思考发现根本不用牛顿迭代，故做此题解。

记 $\Z_m=[0,m-1]\cap \Z$。

解方程 $x^n\equiv k\pmod m$，其中 $x\in \Z_m$。

首先对 $m$ 分解质因数，对每个素数幂单独考虑，最后在 CRT，设模数为 $p^c$，将 $k$ 对 $p^c$ 取模后，分类讨论。

若 $k=0$，答案为 $0$。

若 $p\mid k$，设 $h$ 满足 $p^h\mid k$ 且 $p^{h+1}\nmid k$，则若 $n\nmid h$ 无解，否则我们求解 $y^n\equiv \frac{k}{p^h}\pmod{p^{c-h}}$，我们有，$x\equiv yp^{\frac hn}\pmod{p^{c-\frac {(n-1)h}{n}}}$，即$c$ 位 $p$ 进制数 $x$，低 $\frac hn$ 位为 $0$，高 $\frac{(n-1)h}{n}$ 位为 $1$，中间 $c-h$ 位为任意 $y$。

现在问题转化为 $p\nmid k$，此时我们可以将 $n$ 对 $\phi=\varphi(p^c)/(1+[p=2\land c>2])$ 取模（这里的 $/(1+[p=2\land c>2])$ 是因为 $2^c$ 的乘法群结构不同，为 $2^{c-2}$ 阶循环群 $\times$ $2$ 阶循环群，其余时候乘法群都是 $\varphi(p^c)=p^{c-1}(p-1)$ 阶循环群）。

若 $n=0$，显然此时 $k$ 必须为 $1$，$k=1$ 时，答案为 $\{x|\gcd(x,p)=1,x\in\Z_{p^c}\}$。

现在 $n\ne 0$，那么此时有解的充要条件为 $k^{\frac{\phi}{\gcd(\phi,n)}}=1$，解的个数为 $\gcd(\phi,n)$，证明的话设 $k=g^a$（$g$ 是原根）就好，这里不展开了。

$n=1$ 时，答案为 $k$。

令 $g=\gcd(\phi,n),q=(\frac ng)^{-1}\bmod \phi$，如果 $q$ 存在，我们就可以转化为求 $k^q$ 的 $g$ 次剩余了，但是 $q$ 可能不存在，此时我们注意到 $n$ 可以多次加 $\phi$ 不改变结果，我们随机 $c\in \Z_g$，求 $q=(\frac {n+c\phi}g)^{-1}\bmod \phi$，直到其存在。

关于这一行为的成功率，我们对 $\phi$ 的每个质因数 $p_0$ 分类讨论（CRT），会发现当 $n$ 中 $p_0$ 的次数小于 $\phi$ 中次数的时候，无论 $c$ 取什么，都是存在的；而 $n$ 次数大于等于 $\phi$ 次数的时候，只有 $c\bmod p_0$ 等于某个特定值的时候才不存在。因此随机 $c$ 使得 $q$ 不存在，当前仅当 $c\bmod$（前述的后一种情况的 $p_0$ 乘积）为一个特定值时。所以成功率 $\ge \frac 12$，期望常数次即可求得。

现在问题转化为 $n\mid \phi$ 的情况，我们对 $n$ 做质因数分解，转化为求质数次剩余的情况，每次对当前的所有答案求质数次剩余，做若干轮，这并不会影响复杂度。

下面这部分看的时候先假装 $p=2\land c>2$ 的情况不存在，我们一会再说明这部分。

现在问题转化为 $n$ 是质数且整除 $\phi$ 的情况，我们设 $t$ 满足 $n^t\mid \phi$ 且 $n^{t+1}\nmid \phi$。

现在先求出一个 $n^t$ 次单位根 $g$，我们使用如下的做法，随机 $u\in \Z_{p^c}$，若 $\gcd(c,p)=1\land u^{\frac \phi n}\ne 1$，则 $u^{\frac \phi{n^t}}$ 是一个 $n^t$ 次单位根。

做法的正确性显然，但成功率是个问题，这里给出一个粗略的估计，显然 $u$ 是原根时可以成功，我们知道设循环群大小为 $k$，则原根有 $\varphi(k)$ 个，这里即是 $\varphi(\varphi(p^c))$ 个。我们又知道 $\frac{n}{\varphi(n)}=O(\log\log n)$，所以我们可以给出一个期望 $O((\log\log m)^2)$ 次的粗略估计。总之，此处的期望次数为 $o(\log m)$ 次。

求出 $g$ 后，我们将所有 $n$ 次单位根 $g^0,g^{n^{t-1}},g^{2n^{t-1}}...g^{(n-1)n^{t-1}}$ 放入哈希表记录对应的指数。

令 $d=\frac \phi{n^t}$，$D=d^{-1}\bmod n$，$K=k^{-D}\bmod p^c$，$N=\frac{dD-1}{n}$。

维护下面这样一个流程，初始时，$a=\frac \phi n$，$b=0$，此时 $K^ag^b\bmod p^c=1$，然后令 $a\larr\frac an$，$b\larr\frac bn$，此时 $K^ag^b\bmod p^c$ 应当等于某个 $n$ 次单位根，查哈希表，查出值对应为 $g^w$，令 $b\larr b-w$，此时又有 $K^ag^b\bmod p^c=1$。重复这一流程，总共进行 $t-1$ 次。

流程完毕后，式子应当形如 $K^dg^{w_1n+w_2n^2+\dots+w_{t-1}n^{t-1}}\bmod p^c=1$，即 $k^{-Dd}g^b\bmod p^c=1$，也即 $k^{-nN}g^b\bmod p^c=k$，两边取 $n$ 次剩余，$x\equiv k^{-N}g^{\frac bn}\pmod {p^c}$。

这样我们就求出了一个解，而解一共有 $n$ 个，是这个解乘上所有的 $n$ 次单位根。

单次的时间复杂度为 $O(\log^2 m+n)$（$t$ 是 $O(\log m)$，每次又需要快速幂）

设总解数为 $s$，那么总时间复杂度大致可以认为是 $O(s\log^2 m)$（没有计算分解质因数的时间复杂度）。

那么这题就做完了。

诶等会没完，$p=2\land c>2$ 的情况需要说明。

由于此时是一个 $2^{c-2}$ 阶循环群 $\times$ $2$ 阶循环群，而且 $\phi=2^{c-2}$，那么 $n$ 只能为 $2$，此时我们得到的 $g$ 是 $2^{c-2}$ 阶循环群中的一个原根 $\times$ $2$ 阶循环群中的任意一个数，按照这个做法做下去，结果不会错误，但是会少一半的答案，因为我们可以发现求出的答案中每个 $2^{c-2}$ 阶循环群中的答案只与一个 $2$ 阶循环群中的值组合，实际上两个值的组合都是可行的，因此，我们把求出的答案的相反数也加入答案即可。

```cpp
#include<iostream>
#include<vector>
#include<numeric>
#include<ranges>
#include<algorithm>
#include<unordered_map>
#include<chrono>
#include<random>
std::mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());	
using std::cin,std::cout;
int pow(int x,int y,int mod){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return res;
}
int exgcd(int a,int b,int &x,int &y){
	if(!b) return y=0,x=1,a;
	long long res(exgcd(b,a%b,y,x));
	return y-=a/b*x,res;
}
int inv(int x,int y){
	int a=0,b=0;
	if(exgcd(x,y,a,b)!=1) return 0;
	return a<0?a+y:a;
}
int pow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res*=x;
		if(y>>=1) x*=x;
	}
	return res;
}
std::vector<std::pair<int,int>> factor(int t){
	std::vector<std::pair<int,int>> fac;
	for(int i=2;i*i<=t;i++)if(t%i==0){
		int ct=0;
		while(t%i==0) ++ct,t/=i;
		fac.emplace_back(i,ct);
	}
	if(t>1) fac.emplace_back(t,1);
	return fac;
}
bool check(int n,int k,int p,int c){
	int q=pow(p,c);
	k%=q;
	if(k==0) return true;
	int ct=0;
	while(k%p==0) k/=p,++ct;
	if(ct%n) return false;
	c-=ct;
	int phi=q/p*(p-1);
	n%=phi;
	if(n==0) return k==1;
	if(p==2&&c>2) phi/=2;
	return pow(k,phi/std::gcd(n,phi),q)==1;
}
std::vector<int> nrt(int n,int k,int p,int c){
	int q=pow(p,c),d=q/p*(p-1),phi=d;
	if(p==2&&c>2) phi/=2,d/=2;
	p=q;
	int ct=0,w=1;
	while(d%n==0) d/=n,++ct,w*=n;
	w/=n;
	std::uniform_int_distribution<int> rng(1,p-1);
	int g=0;
	while(true){
		int t=rng(rnd);
		if(std::gcd(t,p)==1){
			int u=pow(t,w*d,p);
			if(u!=1){
				g=pow(t,d,p);
				break;
			}
		}
	}
	std::unordered_map<int,int> mp;
	mp.reserve(n);
	for(int i=0,c=1,q=pow(g,w,p);i<n;i++,c=1ll*c*q%p) mp[c]=i;
	k=inv(k,p);
	int D=inv(d,n),K=pow(k,D,p);
	int pw1=phi/n,pw2=0;
	for(int i=1;i<ct;i++){
		pw1/=n,pw2/=n;
		int h=1ll*pow(K,pw1,p)*pow(g,pw2,p)%p;
		pw2+=(n-mp[h])%n*w;
	}
	int t=1ll*pow(k,1ll*(D*d-1)/n%phi,p)*pow(g,pw2/n,p)%p;
	auto it=mp|std::views::transform([t,p](auto x){return 1ll*x.first*t%p;});
	return std::vector<int>(it.begin(),it.end());
}
std::vector<int> sv(int n,int k,int p,int c){
	int q=pow(p,c),phi=q/p*(p-1);
	if(p==2&&c>2) phi/=2;
	n%=phi;
	if(n==0){
		std::vector<int> v;
		v.reserve(phi);
		if(p==2&&c>2) q/=2;
		for(int i=1;i<q;i++)if(i%p)v.push_back(i);
		return v;
	}
	int g=std::gcd(n,phi),w=n/g,t=phi/g,o=inv(w,phi);
	std::uniform_int_distribution<int> rng(0,g-1);
	while(!o) o=inv((w+1ll*rng(rnd)*t)%phi,phi);
	n=g,k=pow(k,o,q);
	if(n==1) return {k};
	std::vector<int> ans{k},tmp;
	ans.reserve(n),tmp.reserve(n);
	for(auto [a,b]:factor(n)){
		for(int i=1;i<=b;i++){
			std::swap(ans,tmp);
			ans.clear();
			for(auto v:tmp){
				auto res=nrt(a,v,p,c);
				for(auto t:res) ans.push_back(t);
			}
		}
	}
	return ans;
}
std::vector<int> solve(int n,int k,int p,int c){
	int q=pow(p,c);
	k%=q;
	if(k==0){
		int t=pow(p,(c+n-1)/n);
		auto it=std::views::iota(0,q/t)|std::views::transform([t](int x){return x*t;});
		return std::vector<int>(it.begin(),it.end());
	}
	int h=0;
	int w3=q;
	while(k%p==0) k/=p,q/=p,++h;
	c-=h;
	int w1=pow(p,h/n),w2=pow(p,h/n+c);
	auto res=sv(n,k,p,c);
	std::vector<int> ans;
	ans.reserve(res.size()*w3/w2);
	for(auto z:res){
		for(int i=1ll*z*w1%w2;i<w3;i+=w2) ans.push_back(i);
		if(p==2&&c>2&&n%2==0)for(int i=1ll*(q-z)*w1%w2;i<w3;i+=w2) ans.push_back(i);
	}
	return ans;
}
void solve(){
	int n,m,k;
	cin>>n>>m>>k;
	std::vector<std::pair<int,int>> fac=factor(m);
	for(auto [p,c]:fac) if(!check(n,k,p,c)){
		cout<<"0\n";
		return;
	}
	std::vector<int> ans={0};
	for(auto [p,c]:fac){
		auto res=solve(n,k,p,c);
		int q=1;
		for(int i=1;i<=c;i++) q*=p;
		int w=1ll*(m/q)*inv(m/q,q)%m;
		std::vector<int> a;
		a.reserve(ans.size()*res.size());
		for(auto u:ans)
			for(auto v:res)
				a.push_back((u+1ll*w*v)%m);
		ans=std::move(a);
	}
	std::ranges::sort(ans);
	cout<<ans.size()<<'\n';
	for(auto u:ans) cout<<u<<' ';
	cout<<'\n';
}
int main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	int T=1;
	cin>>T;
	while(T--) solve();
	return 0;
}
```

---


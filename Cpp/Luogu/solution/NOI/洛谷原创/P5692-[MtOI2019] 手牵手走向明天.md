# [MtOI2019] 手牵手走向明天

## 题目背景

2019 年 5 月 17 日，Ynoi2018 Day 2 的题目上传至洛谷公共题库。

2019 年 5 月 19 日，mrsrz 想出了[[Ynoi2018]天降之物](https://www.luogu.com.cn/problem/P5397)的序列分块做法，并尝试 AC 该题。

2019 年 5 月 21 日，在 lxl 略微放宽时限，加上各种玄学优化下，mrsrz 通过了此题（现在时限改回来了所以没希望了）。

过了若干日，mrsrz 发现该序列分块做法可以支持区间查询，和 lxl 讨论后，发现也可以做到区间修改。

2019 年 10 月，mrsrz 找到 disangan233 并告诉了他这个题。disangan233 收下了这个题并打算作为 MtOI2019 Extra Round 的 F 题。

2019 年 11 月 1 日，mrsrz 发现某个地方的某个比赛的某个题和该题有类似的地方。观察题解后发现了几乎一样的做法。然后这个原来的 F 题没了。

2019 年 11 月 2 日，MtOI2019 Extra Round 顺利进行。

2019 年 11 月 30 日，mrsrz 想起了这道题，决定将这道饱经风霜的题贡献至公共题库中。希望这道题，能对大家有所帮助。

by mrsrz

2019 年 11 月 30 日

### Update：

2019 年 12 月 2 日，经 disangan233 同意，本题仍使用原来的题面。

2021 年 8 月 13 日，更新了 std，现在 std 的空间复杂度为 $O(n+m)$。

---

「俺、セツナは、お前を永遠に愛することちか！」  
「我，Setsuna，发誓将会永远爱着你！」

「私の、あなたを永遠に愛することちかう！」  
「我也是，发誓会永远爱着你！」

「歴史がかでもまた得た、ウェディングドレスてあみあをそ！」   
「要是我们在其他的历史中再次相遇，那就披上婚纱再来一次吧！」

![rinne.png](https://i.loli.net/2019/10/03/oR4tNIQ6rBMe8GU.png)

## 题目描述

Rinne 给了你一个数列 $a_1,a_2,\dots,a_n$，你需要依次执行 $m$ 个操作。

操作共有两种：

1. 给定 $l,r,x,y$，将 $a_l,a_{l+1},a_{l+2},\dots,a_r$ 中等于 $x$ 的数全部改成 $y$。

2. 给定 $l,r,x,y$，找到 $i,j$ 满足 $i,j\in[l,r]$ 且 $a_i=x,a_j=y$，并要求 $|i-j|$ 最小。求这个最小值。无解输出 $-1$。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n,m,a_i,x,y\leq 10^5$，$1\leq l\leq r\leq n$。

本题共有 $6$ 个子任务，每个子任务的限制如下：

子任务 $1$（$1$ 分）：保证对于任意操作，$l=1,r=n$。

子任务 $2$（$5$ 分）：$n,m\leq 50$。

子任务 $3$（$18$ 分）：$n,m\leq 2000$。

子任务 $4$（$7$ 分）：保证 $a_i,x,y\in\{1,2\}$。

子任务 $5$（$29$ 分）：保证当 $op=2$ 时，$x=y$。

子任务 $6$（$40$ 分）：没有特殊限制。

**时间限制**：$1.5\rm s$

**空间限制**：$512\rm MB$

Idea：nzhtl1477，mrsrz

Solution：mrsrz，nzhtl1477

Code：mrsrz

Data：mrsrz

Background：disangan233，mrsrz

## 样例 #1

### 输入

```
6 5
1 1 4 5 1 4
1 1 3 1 7
2 1 4 7 7
1 1 5 7 3
2 2 6 1 3
2 3 3 3 3
```

### 输出

```
0
3
-1
```

# 题解

## 作者：mrsrz (赞：17)

大家看了题目背景，也许会对这悲伤的故事有所了解吧。

这里给出原来作为赛题题解的 pdf 版本，里面有各个部分分的讲解。你也会看到这题原来的名字。

[题解](https://mrsrz.github.io/files/lg5692/island.pdf)

这里不贴代码了，可以直接去我的[提交记录](https://www.luogu.com.cn/record/27973035)看。

UPD：现在可以看到原来的题面辣

---

## 作者：mlvx (赞：13)

前置任务：[[Ynoi2018] 天降之物](https://www.luogu.com.cn/problem/P5397)（第四分块）的序列分块做法。

我们先回顾一下第四分块的做法：先预处理出块内答案，直接存是存不下的，所以要对块内先离散化，$mnl_{i,j,k}$ 表示第 $i$ 块内离散化值为 $j,k$ 的最近距离，$lsh_{i,j}$ 表示第 $j$ 块内 $i$ 的离散化值。

至此我们解决了块内的答案，块间的答案我们需要预处理出 $fir_{i,j}$ 表示第 $j$ 块离散化值为 $i$ 的数第一次出现的位置，$lst_{i,j}$ 则为最后一次。查询时扫一遍即可。

修改分三类情况：

- 块内无 $x$：跳过。

- 块内有 $x$，无 $y$：直接让 $y$ 继承 $x$ 的标号。

- 块内有 $x$，有 $y$：暴力即可，由于这类中每次颜色种类至少会少一种，则此部分复杂度可均摊为共 $O(n^{1.5})$。

---

变成了区间查询，散块查询是容易的，整块就直接延续上面的做法，散块对整块同理。

变成了区间修改，散块修改有一个标号的问题，所以要写内存池；整块前两类修改同上，第三类考虑一个散块修改每次最多多出一种颜色，故此处复杂度可均摊为共 $O((n+q)n^{0.5})$。

---
令 $n,q,V$ 同阶。

时空复杂度 $O(n^{1.5})$。

由于不存储块间信息，则可离线逐块处理，空间复杂度变为 $O(n)$，常数也大大减小。

---

由于篇幅问题，此处不给出代码，有需要请私信领取。

---

## 作者：FZzzz (赞：11)

被卡常卡飞了/kk

不过还是先来发篇题解吧。

根据传统写题解之前先要写一堆废话对吧。

事情是这样的，我翻 Ynoi 题解的时候发现 lxl 说第四分块有分块做法，然后就想了一下。

想到某个地方卡住了，然后发现了这题，看了眼题解。

结果被那题卡常卡飞了（~~可以获得 $4$ 分的好成绩~~），所以就滚过来写这题。

------------
复述（雾）一下官方题解吧。

考虑分块。

对于答案在一个块内的情况显然可以预处理，如果不在一个块内的话，就维护每个块内每个数第一次和最后一次出现的位置，然后扫一遍，维护 $x$ 和 $y$ 各自最后一次出现的位置。然后对于散块也可以用类似的方法扫过去。

问题是你要是开一个 `f[i][j][k]` 表示第 $i$ 块内 $j$ 和 $k$ 最近的距离的话空间就是 $n^2\sqrt n$ 的。注意到每个块内只有 $\sqrt n$ 个数，所以可以使用类似于离散化的技巧，对于每个数，把它映射到一个标号，这样空间就是 $n\sqrt n$ 开得下了。

然后修改的话我们考虑类似于最初分块那个做法，对于整块的修改，如果同时含有 $x$ 和 $y$ 就重构，如果只含有 $x$ 不含有 $y$ 就打标记。这样的话对于每个块每次重构会使得块内颜色数减少一，而每次修改操作的边角暴力最多会使得 $O(1)$ 的块的颜色数增加 $O(1)$，所以说所有块的重构最多进行 $O(n)$ 次，所以是对的。

问题是如果我们直接像最初分块那样维护每个数变成了哪个数是哪个数变的的话对于 `f` 数组的处理就会很难受。想了想发现我是 sb，因为你都对于所有的数重新标号了所以实际上可以直接把 $y$ 的标号改成 $x$ 的。

但是对于 `f` 数组我们肯定不能直接重构。我在这里卡了挺久之后发现了这题然后看了下题解。其实对于每个 `j` 我们把 `f[i][j][id[i][y]]` 与 `f[i][j][id[i][x]]` 取 `min` 就可以了。

然后散块的 `f` 又不会处理了。注意到改变的 `f` 值只跟 $x$ 和 $y$ 有关，所以可以像查询那样扫一遍维护。

然后实现上的一些问题的话，首先 `f` 数组说过了，这里有个卡常技巧就是规定 $j<k$；`first` 和 `last` 数组就是第一次和最后一次出现的位置；`id` 数组代表每个数“离散化”之后变成哪个标号，然后我的写法还开了个队列或者栈类似于内存池一样地去维护没有用过的标号，标号减少时要记得 `push` 进去，不然要是一直加标号的话复杂度显然就错了。

然后有一些细节要注意一下，我调了两天。再就是比真 Ynoi 还要毒瘤的卡常。代码就不放了，一是因为太丑二是因为还没卡过去（捂脸）。要是有需要的话私信找我吧。

~~顺便吐槽一下 srz，他的题解说是去提交记录看代码，其实他根本没开代码公开。~~

然后应该就没有什么问题了。

---

## 作者：Fa_Nanf1204 (赞：7)

此题是[ [Ynoi2018] 天降之物](https://www.luogu.com.cn/problem/P5397)的加强版本，建议先解决该题。

此题不咋卡常，码量适中，适合食用。

考虑序列分块。对于每个块，因为最多只有 $ \sqrt n  $ 个元素，所以将其块内的元素离散化，之后维护每个块内每个元素第一次和最后一次出现的位置和每个块内一对元素之间最小的距离。

那么每次将区间内 $x$ 修改为 $y$ 的时候，对于散块的部分，直接暴力重构即可。对于整块的部分此时分三类情况讨论：

- 块内没有 $x$：直接跳过。
- 块内有 $x$，没有 $y$：直接将块内离散化后对应的值改为 $y$ 即可。
- 块内有 $x$，也有 $y$：此时考虑暴力重构，对于块内被修改并不再存在于块内的元素，可以考虑写一个内存池存储其离散化后的编号，后面有新加进来的元素就可以直接取出使用，这样元素编号始终不超过 $\sqrt n$。因为每次重构是 $O(\sqrt n)$ 的，每次重构后元素种类数减一，一个块内最多只有 $\sqrt n$ 种元素，每次修改后散块的部分最多只会增加 $2$ 种元素，所以均摊下来时间复杂度是 $O(m \sqrt n+n \sqrt n)$。

那么查询的时候，考虑整块内部的贡献已经维护，块间的贡献只需要扫描整块，不断更新答案即可，然后散块内部的贡献也是如此即可。

总时间复杂度：$O(m \sqrt n+n \sqrt n)$。

如果离线逐块处理的话，可以做到线性空间，这里不过多赘述。

代码私信领取。

---

## 作者：cyffff (赞：6)

$\text{Upd2024.2.13}$：修改笔误。

[$\text{Link}$](https://www.luogu.com.cn/problem/P5692)
## 题意
给你一个长为 $n$ 序列的 $a$，支持操作共 $q$ 次：
1. 将区间 $[l,r]$ 中所有等于 $x$ 的数修改为 $y$，即 $\forall i\in[l,r]\land a_i=x$，执行 $a_i\gets y$。
2. 查询序列的区间 $[l,r]$ 中 $x$ 与 $y$ 出现位置两两之差的最小值，即求 $\displaystyle\min_{a_i=x,l\le i\le r}\min_{a_j=y,l\le j\le r}|i-j|$。

时间 1.5s，$1\le n,q,a_i\le 10^5$.
## 思路
前置知识：[P5397 [Ynoi2018] 天降之物 - 第四分块](https://www.luogu.com.cn/problem/P5397)。

第四分块的加强版。

一些记号需在[我的第四分块题解](https://www.luogu.com.cn/blog/cyffff/solution-p5397)中了解。

本篇题解中记号采用原题解中卡常部分之前的记号。
****
记 $b_i=inp_{bel_i,a_i}$。

首先考虑比原题多了什么，多的是散块修改与散块询问。

先看较为简单的散块询问，显然，恢复两个散块的序列，扫的时候记录 $lasx,lasy$ 即可，与整块基本无异。

然后就是非常恶心的散块修改。其中散块修改可能会使块中颜色数 $+1$，但块中颜色数始终是 $O(\sqrt n)$ 的，于是我们动态分配空间，具体地，记录未被使用的离散化值，在删除时加入，出现当前没有的数时分配一个离散化值给它。

对修改分类讨论。设散块为 $[L,R]$，修改区间为 $[l,r]$。
1. 区间 $[l,r]$ 中无 $x$，直接跳过；
2. 区间 $[l,r]$ 中有 $x$，且 $[L,R]$ 中无 $y$：
	1. 区间 $[L,l)\cup(r,R]$ 中无 $x$：相当于整块修改，令 $ind_{i,inp_{i,x}}=y,inp_{i,y}=inp_{i,x},inp_{i,x}=0$；
   2. 区间 $[L,l)\cup(r,R]$ 中有 $x$：见下文。
3. 区间 $[l,r]$ 中有 $x$，且 $[L,R]$ 中有 $y$：
	1. 区间 $[L,l)\cup(r,R]$ 中无 $x$：见下文。
   2. 区间 $[L,l)\cup(r,R]$ 中有 $x$：见下文。

对于这三类情况，我们作以下处理：
1. 若是 2.2 类，先取出一个未被使用的离散化值赋给 $inp_{i,y}$；
2. 若是 3.1 类，将 $inp_{i,x}$ 丢入未被使用的离散化值中并赋 $0$；
3. 恢复整块序列 $[L,R]$，将 $[l,r]$ 中的 $x$ 修改为 $y$，对应的 $b_k$ 修改为 $inp_{i,y}$，并把这些被修改的位置取出，记作 $st_{1,\dots,top}$。
4. 若是 2.2 类，将所有 $ins_{i,k,inp_{i,y}}$ 初始为极大值。
5. 双指针记录 $i$ 与最大的 $j$ 满足 $st_j\le i$，令 $ins_{i,b_i,inp_{i,y}}=\min(ins_{i,b_i,inp_{i,y}},st_{j+1}-i,i-st_{j})$，注意边界；
6. 若是 2.2 或 3.2 类，按照与 4 和 5 同样的方式双指针更新 $x$ 的答案；
7. 更新 $fir_{i,x},fir_{i,y},sec_{i,x},sec_{i,y}$。

最棘手的散块修改就做完了，整块修改按照第四分块的方式即可，注意在重构时要将消失的 $x$ 的离散化值丢进未被使用的离散化值中，并还原这块的 $a_i,b_i$ 并修改。

由于每次只有 $O(1)$ 个散块修改，总共给 $O(n)$ 个块分别添加了 $O(1)$ 的势能，所以该算法复杂度正确，时空均为 $O(n\sqrt n)$。

这题的修改、询问仍是平凡的，仍可离线逐块处理，做到空间 $O(n)$，时间常数也相应地减少了。~~但已经够难写了再写个这个就要吐了。~~
****
从第四分块改到这题，我的代码长度翻了一倍。

由于在第四分块的卡常，即使散块修改常数极大，我的代码运行速度仍不慢，跑到了最优解。最慢点甚至仍在 500ms 内。

以下代码仅供参考：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=1e5+300,sq=255,nq=N/sq+10;
int n,q,blk,last,a[N],b[N],bl[nq],br[nq],bel[N],tp[nq],op[nq];
int fir[N],sec[N],ind[N];
short inp[N][nq],ins[N][sq+10],stk[nq][sq+10];
inline int site(int x,int y){
	if(x>y) swap(x,y);
	return x*sq+y;
}
inline void init(int l,int r){
	int d=bel[l],p=l-1;
	vector<int>vec;
	for(int i=l;i<=r;i++)
		vec.push_back(a[i]);
	sort(vec.begin(),vec.end());
	vec.resize(unique(vec.begin(),vec.end())-vec.begin());
	tp[d]=vec.size();
	for(int i=sq;i>tp[d];i--)
		stk[d][++op[d]]=i;
	for(int i=l;i<=r;i++)
		b[i]=lower_bound(vec.begin(),vec.end(),a[i])-vec.begin()+1,
		ind[p+b[i]]=a[i],inp[a[i]][d]=b[i];
	for(int i=l;i<=r;i++)
		sec[p+b[i]]=i;
	for(int i=r;i>=l;i--)
		fir[p+b[i]]=i;
	for(int i=1;i<=r-l+1;i++)
		for(int j=i+1;j<=r-l+1;j++)
			ins[p+i][j]=32767;
	for(int i=l;i<=r;i++)
		for(int j=i+1;j<=r;j++){
			int A=min(b[i],b[j]),B=max(b[i],b[j]);
			ins[p+A][B]=min(ins[p+A][B],(short)(j-i));
		}
}
inline void rebuild(int l,int r,int x,int y){
	int d=bel[l],p=l-1;
	int inpx=inp[x][d],inpy=inp[y][d];
	fir[p+inpy]=min(fir[p+inpy],fir[p+inpx]),sec[p+inpy]=max(sec[p+inpy],sec[p+inpx]);
	fir[p+inpx]=sec[p+inpx]=0,inp[x][d]=0;
	for(int i=l;i<=r;i++)
		a[i]=ind[p+b[i]];
	for(int i=l;i<=r;i++)
		if(a[i]==x) a[i]=y,b[i]=inpy;
	stk[d][++op[d]]=inpx;
	if(inpx>inpy){
		for(int i=1;i<=inpy;i++)
			ins[p+i][inpy]=min(ins[p+i][inpy],ins[p+i][inpx]),ins[p+i][inpx]=32767;
		for(int i=inpy+1;i<=inpx;i++)
			ins[p+inpy][i]=min(ins[p+inpy][i],ins[p+i][inpx]),ins[p+i][inpx]=32767;
		for(int i=inpx+1;i<=sq;i++)
			ins[p+inpy][i]=min(ins[p+inpy][i],ins[p+inpx][i]),ins[p+inpx][i]=32767;
	}else{
		for(int i=1;i<=inpx;i++)
			ins[p+i][inpy]=min(ins[p+i][inpy],ins[p+i][inpx]),ins[p+i][inpx]=32767;
		for(int i=inpx+1;i<=inpy;i++)
			ins[p+i][inpy]=min(ins[p+i][inpy],ins[p+inpx][i]),ins[p+inpx][i]=32767;
		for(int i=inpy;i<=sq;i++)
			ins[p+inpy][i]=min(ins[p+inpy][i],ins[p+inpx][i]),ins[p+inpx][i]=32767;
	}
}
int st[sq+10],top;
inline void solve1(int L,int R,int l,int r,int x,int y,int fl){
	int d=bel[L],p=L-1;
	int inpx=inp[x][d],inpy;
	if(!fl){
		inpy=stk[d][op[d]--],inp[y][d]=inpy,ind[p+inpy]=y;
	}
	else inpy=inp[y][d];
	if(fl==2){
		inp[x][d]=0,ind[p+inpx]=0;
		fir[p+inpx]=sec[p+inpx]=0;
		stk[d][++op[d]]=inpx;
	}
	top=0;
	for(int i=l;i<=r;i++)
		if(a[i]==x) a[i]=y,b[i]=inpy,st[++top]=i;
	st[++top]=1e9;
	if(!fl){
		for(int i=L;i<=R;i++){
			int A=b[i],B=inpy;
			if(A>B) swap(A,B);
			ins[p+A][B]=32767;
		}
	}
	for(int i=L,j=1;i<=R;i++){
		while(st[j]<=i) j++;
		j--;
		int A=b[i],B=inpy;
		if(A>B) swap(A,B);
		if(j!=top-1){
			if(j==0) ins[p+A][B]=min(ins[p+A][B],(short)(st[j+1]-i));
			else ins[p+A][B]=min({ins[p+A][B],(short)(i-st[j]),(short)(st[j+1]-i)});
		}else{
			ins[p+A][B]=min(ins[p+A][B],(short)(i-st[j]));
		}
	}
	if(fl!=2){
		top=0;
		for(int i=L;i<=R;i++)
			if(a[i]==x) st[++top]=i;
		st[++top]=1e9;
		for(int i=L;i<=R;i++){
			int A=b[i],B=inpx;
			if(A>B) swap(A,B);
			ins[p+A][B]=32767;
		}
		for(int i=L,j=1;i<=R;i++){
			while(st[j]<=i) j++;
			j--;
			int A=b[i],B=inpx;
			if(A>B) swap(A,B);
			if(j!=top-1){
				if(j==0) ins[p+A][B]=min(ins[p+A][B],(short)(st[j+1]-i));
				else ins[p+A][B]=min({ins[p+A][B],(short)(i-st[j]),(short)(st[j+1]-i)});
			}else{
				ins[p+A][B]=min(ins[p+A][B],(short)(i-st[j]));
			}
		}
	}
	for(int i=L;i<=R;i++)
		if(a[i]==x) sec[p+inpx]=i;
	for(int i=R;i>=L;i--)
		if(a[i]==x) fir[p+inpx]=i;
	for(int i=L;i<=R;i++)
		if(a[i]==y) sec[p+inpy]=i;
	for(int i=R;i>=L;i--)
		if(a[i]==y) fir[p+inpy]=i;
}
inline void solve2(int l,int r,int x,int y){
	int bL=bel[l];
	int p=bl[bL]-1,L=bl[bL],R=br[bL],inpx=inp[x][bL],inpy=inp[y][bL];
	if(!inpx) return ;
	for(int i=L;i<=R;i++)
		a[i]=ind[p+b[i]];
	bool fl=0;
	for(int i=l;i<=r;i++)
		if(a[i]==x) fl=1;
	if(!fl) return ;
	fl=0;
	for(int i=L;i<l;i++)
		if(a[i]==x) fl=1;
	for(int i=r+1;i<=R;i++)
		if(a[i]==x) fl=1;
	if(!inpy){
		if(fl) solve1(L,R,l,r,x,y,0);
		else ind[p+inpx]=y,inp[x][bL]=0,inp[y][bL]=inpx;
	}else{
		if(fl) solve1(L,R,l,r,x,y,1);
		else solve1(L,R,l,r,x,y,2);
	}
}
int main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i+=sq){
		blk++;
		bl[blk]=i,br[blk]=min(i+sq-1,n);
		for(int j=bl[blk];j<=br[blk];j++)
			bel[j]=blk;
		init(bl[blk],br[blk]);
	}
	while(q--){
		int opt=read(),l=read(),r=read(),x=read(),y=read();
		if(opt==2){
			int ans=n+1,bL=bel[l],bR=bel[r],lasx=-1e9,lasy=-1e9;
			if(x==y){
				if(bL==bR){
					int p=bl[bL]-1;
					for(int i=l;i<=r;i++)
					if((a[i]=ind[p+b[i]])==x) ans=0;
				}else{
					int p=bl[bL]-1;
					for(int i=l;i<=br[bL];i++)
					if((a[i]=ind[p+b[i]])==x) ans=0;
					p=bl[bR]-1;
					for(int i=bl[bR];i<=r;i++)
					if((a[i]=ind[p+b[i]])==x) ans=0;
				}
				for(int i=bL+1;i<=bR-1;i++)
					if(inp[x][i]) ans=0;
				if(ans==n+1) puts("-1");
				else printf("%d\n",ans);
				continue;
			}
			if(bL==bR){
				int p=bl[bL]-1;
				for(int i=l;i<=r;i++)
					a[i]=ind[p+b[i]];
				for(int i=l;i<=r;i++){
					if(a[i]==x) ans=min(ans,i-lasy),lasx=i;
					if(a[i]==y) ans=min(ans,i-lasx),lasy=i;
				}
			}else{
				int p=bl[bL]-1;
				for(int i=l;i<=br[bL];i++)
					a[i]=ind[p+b[i]];
				for(int i=l;i<=br[bL];i++){
					if(a[i]==x) ans=min(ans,i-lasy),lasx=i;
					if(a[i]==y) ans=min(ans,i-lasx),lasy=i;
				}
				for(int i=bL+1;i<=bR-1;i++){
					int inpx=0,inpy=0,p=bl[i]-1;
					if(inpx=inp[x][i]) ans=min(ans,fir[p+inpx]-lasy);
					if(inpy=inp[y][i]) ans=min(ans,fir[p+inpy]-lasx);
					if(inpx&&inpy){
						int q=ins[p+min(inpx,inpy)][max(inpx,inpy)];
						if(q!=32767) ans=min(ans,q);
					}
					if(inpx) lasx=sec[p+inpx];
					if(inpy) lasy=sec[p+inpy];
				}
				p=bl[bR]-1;
				for(int i=bl[bR];i<=r;i++)
					a[i]=ind[p+b[i]];
				for(int i=bl[bR];i<=r;i++){
					if(a[i]==x) ans=min(ans,i-lasy),lasx=i;
					if(a[i]==y) ans=min(ans,i-lasx),lasy=i;
				}
			}
			if(ans==n+1) puts("-1");
			else printf("%d\n",ans);
		}else{
			if(x==y) continue;
			int bL=bel[l],bR=bel[r];
			if(bL==bR){
				solve2(l,r,x,y);
			}else{
				solve2(l,br[bL],x,y);
				solve2(bl[bR],r,x,y);
				for(int i=bL+1;i<=bR-1;i++){
					int t=inp[x][i],p=bl[i]-1;
					if(!t) continue;
					if(!inp[y][i])
						ind[p+t]=y,inp[x][i]=0,inp[y][i]=t;
					else
						rebuild(bl[i],br[i],x,y);
				}
			}
		}
	}
	flush();
}
```
再见 qwq~

---

## 作者：MrcFrst (赞：4)

[cnblogs](https://www.cnblogs.com/MrcFrst-LRY/p/17893788.html)

[P5692 [MtOI2019] 手牵手走向明天](https://www.luogu.com.cn/problem/P5692)

---------------------

### 题意

将区间内所有 $x$ 变为 $y$，查询区间内值 $x$ 和值 $y$ 的下标距离的最小值。

$n,m,V\le 10^5$（分别为序列长度，操作数和值域）。

-------------------

### 题解

是[第四分块：P5397 [Ynoi2018] 天降之物](https://www.luogu.com.cn/problem/P5397)的改版。去掉了强制在线，操作和询问从全局加强到了区间，所以不能用根号分治做法了。

考虑对序列分块，记块长为 $B$，将答案的统计拆为块内和块间，显然块间的答案只会产生于前面某个块里的最后一个 $x$ 和后面某个块里的第一个 $y$，或者是把这里的表述中的 $x,y$ 交换。

那么考虑维护块内的所有答案，首先我们在每个块内离散化，将值域映射到 $id$ 上，然后记录每个 $id$ 的 $fst$ 和 $lst$，分别为它在块内第一次和最后一次出现的位置。

那么显然答案的计算就是记录当前的 $lstx$ 和 $lsty$ 表示 $x$ 和 $y$ 最后出现的位置，散块暴力扫答案并更新这两个值，整块就先用块内答案更新 $ans$，然后用 $fst_x-lsty$ 和 $fst_y-lstx$ 更新 $ans$（先要判断块内是否存在 $x,y$），然后用 $lst_x$ 和 $lst_y$ 更新 $lstx$ 和 $lsty$。

再来考虑修改，讨论一下：

1. 散块：暴力扫，修改，然后 $O(B)$ 暴力重构此块中 $x,y$ 的信息。此部分总复杂度为 $O(mB)$。

2. 整块：

	1. 块内不存在 $x$：直接忽略，不进行操作；
   
   2. 块内存在 $x$ 但不存在 $y$：直接修改离散化值，把 $id_x$ 赋给 $id_y$，然后将 $id_x$ 置为 $0$。此部分总复杂度为 $O(\frac{nm}{B})$。
   
   3. 块内 $x,y$ 都存在：同散块处理，暴力扫，修改，然后 $O(B)$ 暴力重构此块中 $x,y$ 的信息。因为在一个块内每进行一次此操作都会使块内不同数值的个数恰好减少一个，所以一个块内最多进行 $O(B)$ 次此操作，总共最多进行 $O(n)$ 次。所以此部分总复杂度为 $O(nB)$。
   
总时间复杂度为 $O((n+m)B+\frac{nm}{B})$，空间复杂度为 $O(nB)$（瓶颈在于维护整块内两两值的答案），$B$ 取 $\sqrt n$ 时即为 $O((n+m)\sqrt n)$。

用逐块处理的 trick 可以做到线性空间复杂度。

实现上有一个容易被忽略的细节：

我们在进行散块修改的时候因为可能只修改了块内的一部分 $x$，所以需要在保留 $id_x$ 的同时给 $id_y$ 赋值，这个时候如果一直无脑 `++idx` 的话，$idx$ 最大会达到 $O(m+B)$ 级别，然后我们维护每个 $id$ 在块内的信息的时候就有可能造成数组访问越界 `RE`，如果直接开大数组，空间复杂度会达到 $O((m+B)^2)$，~~就会爆炸~~。

正确的解决方法是，我们用一个 `vector` 存下当前“空闲”的 $id$ 值。我们在块内重构维护某个值的信息的时候，如果这个值在块内没有出现了，那么就把它原先的 $id$ 值存入 `vector`，之后我们就可以用 `vector` 里面存的“空闲”值，如果 `vector` 为空我们才 `++idx`。这样可以保证 $idx$ 始终不会超过块内的不同数值个数，即为 $O(B)$ 级别。

---------------

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define re register
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
char buf[1<<22],*p1=buf,*p2=buf;
const int N=1e5+10,sq=360,len=350,star=1e8,V=1e5;
int n,m,a[N],L,R,cntB,idx,l,r,x,y;
int fst[sq],lst[sq],ans[sq][sq],id[N];
vector<int>v;
#define pb emplace_back
il int read(){
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
struct query{
    int op,l,r,x,y,ans;
    int lstx,lsty;
}q[N];
il void Calc(int &i){
    for(re int j=1;j<=idx;j++)ans[i][j]=star;
    ans[i][i]=0,lst[i]=0;
    for(re int j=L,now=star;j<=R;j++)
        if(a[j]==i)now=0,lst[i]=j;
        else ans[i][a[j]]=ans[a[j]][i]=min(ans[i][a[j]],++now);
    for(re int j=R,now=star;j>=L;j--)
        if(a[j]==i)now=0,fst[i]=j;
        else ans[i][a[j]]=ans[a[j]][i]=min(ans[i][a[j]],++now);
    if(!lst[i])v.pb(i),i=0;
}
il void Build(){
    vector<int>().swap(v);
    for(re int i=1;i<=V;i++)id[i]=0;
    idx=0;
    for(re int i=L;i<=R;i++){
        if(!id[a[i]])id[a[i]]=++idx;
        a[i]=id[a[i]];
    }
    for(re int i=1;i<=idx;i++)Calc(i);
}
il void Modify(int &x,int &y){
    if(!x||x==y)return;
    if(l>L||r<R){
        if(!y){
            if(v.empty())y=++idx;
            else y=v.back(),v.pop_back();
        }
        for(re int i=max(l,L);i<=min(r,R);i++)if(a[i]==x)a[i]=y;
        return Calc(x),Calc(y);
    }
    if(!y)return y=x,x=0,void();
    for(re int i=L;i<=R;i++)if(a[i]==x)a[i]=y;
    return Calc(x),Calc(y),void();
}
il void Solve(int &res,int &lstx,int &lsty){
    x=id[x],y=id[y];
    if(!x&&!y)return;
    if(l>L||r<R){
        for(re int i=max(l,L);i<=min(r,R);i++){
            if(a[i]==x&&a[i]==y)return res=0,void();
            else if(a[i]==x)res=min(res,i-lsty),lstx=i;
            else if(a[i]==y)res=min(res,i-lstx),lsty=i;
        }
        return;
    }
    if(x==y)return res=0,void();
    if(x)res=min(res,fst[x]-lsty);
    if(y)res=min(res,fst[y]-lstx);
    if(x)lstx=lst[x];
    if(y)lsty=lst[y];
    if(x&&y)res=min(res,ans[x][y]);
}
int main(){
    n=read(),m=read(),cntB=(n-1)/len+1;
    for(re int i=1;i<=n;i++)a[i]=read();
    for(re int i=1;i<=m;i++)
        q[i].op=read(),q[i].l=read(),q[i].r=read(),
        q[i].x=read(),q[i].y=read(),q[i].ans=star,
        q[i].lstx=q[i].lsty=-star;
    for(re int _=1;_<=cntB;_++){
        L=R+1,R=min(_*len,n);
        Build();
        for(re int i=1;i<=m;i++){
            l=q[i].l,r=q[i].r,x=q[i].x,y=q[i].y;
            if(l>R||r<L)continue;
            if(q[i].op==1)Modify(id[x],id[y]);
            else Solve(q[i].ans,q[i].lstx,q[i].lsty);
        }
    }
    for(re int i=1;i<=m;i++)
        if(q[i].op==2)cout<<((q[i].ans==star)?-1:q[i].ans)<<'\n';
    return 0;
}
```

---

## 作者：forest114514 (赞：3)

「拭尽破净的第四分块」加强版

首先经典的序列分块，对每个点维护前后面最近的颜色的位置和最近距离，询问时就维护当前颜色最右出现位置就能合并块间贡献。

块内全局修改做法？如果没有 $x$ 就跳过，没有 $y$ 就把 $x$ 变成 $y$，否则暴力重构，这样每次颜色数 $-1$，单块只会有 $O(\sqrt n)$ 次，单块时间就是 $O(n)$ 的，空间也是 $O(n)$ 的，此时时空都是 $O(n\sqrt n)$ 的。

接着散块就暴力修改，暴力查询即可，只不过注意到不能每次直接新开颜色，要先继承之前改没的颜色编号。不难发现此时可以逐块处理，空间变 $O(n)$，时间常数小很多！但是写了第四分块的强制在线后就不想重构代码，所以没写……

注意一些细节：

1. 整块
   1. 没有出现 $x$：直接跳过；
   2. 没有出现 $y$：如果是新颜色，直接 $col_{pos_x}\leftarrow y$。
   3. 否则 $c[pos_{x}]\leftarrow y$，计算 $y$ 的新距离，把 $x$ 的编号加入桶，**把所有 $x$ 改成 $y$**（这个东西第四分块没必要，但这题要加，不然就会和我一样调大半天）。
2. 散块
   1. 没有出现过 $x$ 或没有修改 $x$：直接跳过；
   2. 所有 $x$ 被覆盖：变成整块修改。
   3. 修改部分 $x$：
      1. $y$ 是原有颜色，直接更新距离和左右端点即可。
      2. $y$ 没有出现，新开颜色，桶没有就增加 $ct_{p}$，桶中有颜色就继承一个编号。
3. 如果修改颜色 $x=y$ 直接跳过，不要修改。（让我调大半天的原因之二）

卡常的话如果你卡过了第四分块，这题也能轻松在 500ms 内过，还是提一句吧，虽然是在第四分块那卡的常就是了：

1. 经典调块长，我第四分块开 375 最快，这题开 300 最快；
2. 把记录每块每个颜色离散化的数组 $id$ 的关于颜色的一维放前面，这样内存连续速度会块很多，这很重要，反正加了这个我就从最慢点 700ms 以上变成了最慢点 460 ms；
3. 记录两个颜色的最短距离的 $dis$ 只用关心 $x\le y$ 的部分，而且 $dis$ 可以优化成二维数组，这样更快。

可能是常数还行，反正我只改了上面三点就卡过了。

[恶臭代码](https://www.luogu.com.cn/paste/cdk0jqi4)

---

## 作者：_Yonder_ (赞：2)

要注意边界情况啊...调了一天...

考虑分块。

我们先对每个数维护其在其所属块的离散化值。

对于修改操作我们可以注意到，如果一个块内同时含有 $x,y$，则这个块内数的种类数会减少一。而一个块最多有 $\sqrt n$ 个不同的值，所以暴力是可行的，时间复杂度 $O(n\sqrt n)$。若只含有 $x$，把 $x$ 的离散化值赋给 $y$ 即可，若只含有 $y$，跳过即可。

查询的话，我们需要维护一个块内 $x,y$ 的答案，和块内 $x,y$ 第一次和最后一次出现的位置。这是容易的。

对于修改操作的散块，需要注意种类数不一定会减少一，所以不可以直接赋离散化值。

---

## 作者：Others (赞：2)

我看还没人补线性空间做法的介绍（其实也没太大差别，只是**更好写**，**不用卡常**而已）。本文假设 $n,m$ 同阶。

**Solution：**

先考虑第四分块的做法，发现有一个可取之处：

对于一些数，可以维护 $dis_{x,y}$ 表示其最短距离。但是这题是区间修改，考虑分块，对每个块分别维护 $dis_{x,y}$，然后空间就成了 $O(n^2\sqrt n)$，这里可以对每个块块内元素“离散化（重新标号）”，把值域缩成 $O(\sqrt n)$，然后空间就是 $O(n\sqrt n)$。

但是以上方法存的只是块内的距离，$x,y$ 的最短距离当然有可能跨块产生，所以对每个块存下每个元素最左边的位置和最右边的位置，然后（~~枚举那两个块~~）从左到右扫一遍，记录 $lstx,lsty$ 表示 $x,y$ 上一次出现的位置。~~当然，你可以 $O(n\sqrt n)$ 的空间复杂度~~。

然后就是修改，这里的复杂度分析很珂学，~~我差点就以为我假了~~。

对于整块，先排除几种可能爆掉的情况：$x==y,x$ 不存在。然后发现每个块一共 $O(\sqrt n)$ 个元素，所以共合并 $O(\sqrt n)$ 次后就会被上面的优化排除掉，所以每次操作就 $O(\sqrt n)$ 合并 $dis_{x,i},dis_{y,i}$ 就行了。但是~~有些人~~我觉得散块会加元素数量，然后爆掉，注意散块的总数量是 $O(n)$，每个元素的时间复杂度是 $O(\sqrt n)$，所以总量还是不变（用势能分析可能会更严谨）。

对于散块，就暴力重构 $dis_{x,y}$，就行了。在更新时就扫一遍块，**记得前后都要扫一遍！！！**

放一份珂爱的代码。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define wr(x,ch) write(x),putchar(ch)
using namespace std;
namespace IO{
    
}
using IO::read;
using IO::write;
const int N=100005,SN=1005,s=1000;
struct query {int op,l,r,x,y,lst1,lst2;}p[N];
int n,m,bls,NN,L,R,top,sta[N],LL[N],RR[N],flag[N],a[N],ans[N],pos[N],dis[SN][SN];
int main() {
	n=read(),m=read(),bls=(n+s-1)/s;
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++) p[i].op=read(),p[i].l=read(),p[i].r=read(),p[i].x=read(),p[i].y=read();
	memset(ans,0x7f,sizeof(ans));
	for(int i=1;i<=bls;i++) {
		L=R+1,R=min(n,s*i);
		memset(pos,0,sizeof(pos)),memset(dis,0x7f,sizeof(dis)),memset(flag,0,sizeof(flag));
		memset(LL,0,sizeof(LL)),memset(RR,0,sizeof(RR)),NN=top=0;
		for(int j=L;j<=R;j++) flag[++NN]=a[j];
		sort(flag+1,flag+NN+1),NN=unique(flag+1,flag+NN+1)-flag-1;
		for(int j=L;j<=R;j++) a[j]=lower_bound(flag+1,flag+NN+1,a[j])-flag;
		for(int j=1;j<=NN;j++) pos[flag[j]]=j;
		for(int j=L;j<=R;j++) {
			(LL[a[j]]==0)&&(LL[a[j]]=j),RR[a[j]]=j;
			for(int k=j;k<=R;k++) 
				dis[a[j]][a[k]]=dis[a[k]][a[j]]=min(dis[a[j]][a[k]],k-j);
		}
		for(int j=1;j<=m;j++) {
			if(p[j].l>R||p[j].r<L) continue;
			if(p[j].op^2) {
				if(p[j].x==p[j].y) continue;
				if(!pos[p[j].x]) continue;
				if(p[j].l<=L&&p[j].r>=R) {
					if(!pos[p[j].y]) pos[p[j].y]=pos[p[j].x],pos[p[j].x]=0;
					else {
						for(int k=1;k<=NN;k++) 
							dis[k][pos[p[j].y]]=dis[pos[p[j].y]][k]=min(dis[k][pos[p[j].y]],dis[k][pos[p[j].x]]),
							dis[k][pos[p[j].x]]=dis[pos[p[j].x]][k]=0;
						for(int k=L;k<=R;k++) (a[k]==pos[p[j].x])&&(a[k]=pos[p[j].y]);
						LL[pos[p[j].y]]=min(LL[pos[p[j].y]],LL[pos[p[j].x]]),LL[pos[p[j].x]]=0;
						RR[pos[p[j].y]]=max(RR[pos[p[j].y]],RR[pos[p[j].x]]),RR[pos[p[j].x]]=0;
						flag[sta[++top]=pos[p[j].x]]=0,pos[p[j].x]=0;
					}
				} else {
					if(!pos[p[j].y]) (top?flag[pos[p[j].y]=sta[top--]]=p[j].y:flag[pos[p[j].y]=++NN]=p[j].y);
					for(int k=max(L,p[j].l),tmp=min(R,p[j].r);k<=tmp;k++) (a[k]==pos[p[j].x])&&(a[k]=pos[p[j].y]);
					LL[pos[p[j].x]]=RR[pos[p[j].x]]=0;
					LL[pos[p[j].y]]=RR[pos[p[j].y]]=0;
					for(int k=1;k<=NN;k++) dis[pos[p[j].x]][k]=dis[k][pos[p[j].x]]=dis[pos[p[j].y]][k]=dis[k][pos[p[j].y]]=0x7f7f7f7f;
					int pos1=0,pos2=0;
					for(int k=L;k<=R;k++) {
						(LL[a[k]]==0)&&(LL[a[k]]=k);
						RR[a[k]]=k;
						if(a[k]==pos[p[j].x]) pos1=k;
						if(a[k]==pos[p[j].y]) pos2=k;
						if(pos1) dis[a[k]][pos[p[j].x]]=dis[pos[p[j].x]][a[k]]=min(dis[a[k]][pos[p[j].x]],k-pos1);
						if(pos2) dis[a[k]][pos[p[j].y]]=dis[pos[p[j].y]][a[k]]=min(dis[a[k]][pos[p[j].y]],k-pos2);
					}
					pos1=pos2=0;
					for(int k=R;k>=L;k--) {
						if(a[k]==pos[p[j].x]) pos1=k;
						if(a[k]==pos[p[j].y]) pos2=k;
						if(pos1) dis[a[k]][pos[p[j].x]]=dis[pos[p[j].x]][a[k]]=min(dis[a[k]][pos[p[j].x]],pos1-k);
						if(pos2) dis[a[k]][pos[p[j].y]]=dis[pos[p[j].y]][a[k]]=min(dis[a[k]][pos[p[j].y]],pos2-k);
					}
					if(!LL[pos[p[j].x]]) flag[sta[++top]=pos[p[j].x]]=0,pos[p[j].x]=0;
					if(!LL[pos[p[j].y]]) flag[sta[++top]=pos[p[j].y]]=0,pos[p[j].y]=0;
				}
			} else {
				if(p[j].l<=L&&p[j].r>=R) {
					if(dis[pos[p[j].x]][pos[p[j].y]]!=0x7f7f7f7f) ans[j]=min(ans[j],dis[pos[p[j].x]][pos[p[j].y]]);
					if(p[j].lst1&&LL[pos[p[j].y]]) ans[j]=min(ans[j],LL[pos[p[j].y]]-p[j].lst1);
					if(p[j].lst2&&LL[pos[p[j].x]]) ans[j]=min(ans[j],LL[pos[p[j].x]]-p[j].lst2);
					if(RR[pos[p[j].x]]) p[j].lst1=RR[pos[p[j].x]];
					if(RR[pos[p[j].y]]) p[j].lst2=RR[pos[p[j].y]];
				} else {
					for(int k=max(p[j].l,L),tmp=min(R,p[j].r);k<=tmp;k++) {
						if(a[k]==pos[p[j].x]&&p[j].x==p[j].y) {ans[j]=0;break;}
						if(a[k]==pos[p[j].x]&&p[j].lst2) ans[j]=min(ans[j],k-p[j].lst2);
						if(a[k]==pos[p[j].y]&&p[j].lst1) ans[j]=min(ans[j],k-p[j].lst1);
						if(a[k]==pos[p[j].x]) p[j].lst1=k;
						if(a[k]==pos[p[j].y]) p[j].lst2=k;
					}
				}
			}
		}
	}
	for(int i=1;i<=m;i++) if(p[i].op^1) wr((ans[i]==0x7f7f7f7f?-1:ans[i]),'\n');
	return 0;
}

```

---

## 作者：xfrvq (赞：2)

[$\tt Link$](/problem/P5692) 与 [弱化版—第四分块](/problem/P5397)。

---

我们先来回顾一下第四分块的序列分块做法。

这个修改和 [最初分块](/problem/P4119) 一样，所以我们还是考虑从值入手维护一个**类似**于并查集的东西（并查集会让复杂度变高，所以我们和最初分块一样通过改良写法规避掉并查集）。

你想过直接维护一个块任意两个元素的最近距离，但是这时的空间是 $O(\sqrt n\times n^2)$ 的，所以要**块内离散化**，最后会维护以下几个数组。

以下的数组都是对于一个块而言的（即对于每种数组我们都要开 $\sqrt n$ 个来存每个块）

+ $id$ 数组代表 **实际值 $\to$ 离散化值**.
+ $val_i$ 代表 **离散化值 $\to$ 实际值**。
+ $pl,pr$ 代表 **一个离散化值在块内第一次/最后一次出现位置**。
+ $dis$ 代表 **两个离散化值的距离**。

修改对每个块分类讨论：

+ 有 $x$ 无 $y$：改 $val_{id_x}$ 为 $y$。
+ 有 $x$ 有 $y$：这时块内的颜色会 $-1$，而块内颜色最多减根号次就会到达 $1$，所以对于每个块这种修改的总次数是根号的，因此用 $O(\sqrt n)$ 的时间重构这个块。
+ 没有 $x$ 就跳过

查询也很好办：

+ 对于在一个块的答案，直接查表。
+ 不在一个块的答案，使用 $pl,pr$ 辅助统计。

这个写法是非常简单的，大概 $\texttt{1.9k}$（就是跑得慢）。

---

考虑这个题有哪些变化：**散块查询和散块修改**。

散块查询是很简单的，直接暴力遍历计算答案即可。散块修改就有点恶心人。

大体我们要干的事是更新 $dis$ 以及更新 $pl,pr$，更新 $pl,pr$ 的过程是平凡的取 $\min$ 或 $\max$，不说了。

更新 $dis$ 的过程可以理解为有 $\sqrt n$ 个位置 $[l,r]$，又有 $k$ 个位置 $b_{1\cdots k}$（$k\le\sqrt n$），然后你要计算出对于每个 $i\in[l,r]$，距离 $i$ 最近的 $b_j$ 的值。

这个很寻常，你直接从左到右再从右到左扫两次，计算最近的 $b_j$ 值就好了。

散块修改需要分类讨论，这里先记 $[l,r]$ 为散块，$[L,R]$ 为 **完全包含散块的那个整块**：

1. $[l,r]$ 无 $x$：跳过。
1. $[L,R]$ 无 $y$，$[L,R]$ 中除 $[l,r]$ 外无 $x$：改离散化值。
1. $[L,R]$ 有 $y$，$[L,R]$ 中除 $[l,r]$ 外无 $x$。
1. $[L,R]$ 无 $y$，$[L,R]$ 中除 $[l,r]$ 外有 $x$。
1. $[L,R]$ 有 $y$，$[L,R]$ 中除 $[l,r]$ 外有 $x$。

+ 对于 3 情况，你需要删除掉 $x$ 的离散化值。
+ 对于 4 情况，你需要给 $y$ 添加新离散化值。
+ 对于 4 情况，你需要初始化 $y$ 的 $dis$ 答案（全部设为 $\infty$）
+ 对于 3,4,5 情况，你需要更新 $y$ 的 $dis$ 答案（上述方法）
+ 对于 4,5 情况，你需要更新 $x$ 的 $dis$ 答案（上述方法）

---

关于实现，提几个注意事项。

+ 可以把 $dis$ 数组设为位置从小到大，即对于 $dis_{x,y}$ 只有当 $x\le y$ 才有用（优化常数）。
+ 可以把一些功能函数化（比如更新 $dis$，散块修改之类的）（写方便使用）。
+ $\tt WA$ 可以考虑调大/小块长，然后看看对的点有没有增多/变少，判断出是块内部分还是块间部分出问题。
+ **这题不卡常**（对非并查集写法而言），只要你没写错基本不会 $\tt TLE$。
+ **调块长没多大用**（对我而言），$\sqrt n$ 是跑的最快的，目前跑到 [$\tt\color{black}c\color{red}yffff$](/user/365127) 后的第二优解。

---

[$\tt Code$](https://www.luogu.com.cn/paste/z63atsw1)

$\texttt{3.7k}$（去快读等一些东西），可能是写过最长的分块。

---

## 作者：whiteqwq (赞：1)

[P5692 [MtOI2019]手牵手走向明天](https://www.luogu.com.cn/problem/P5692)解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15933184.html)

## 题意

维护一个长度为 $n$ 的序列，$q$ 次操作，支持区间将颜色 $x$ 变成颜色 $y$，或者查询区间内 $x$ 与 $y$ 的最近距离。

$1\leqslant n,q\leqslant 10^5$。

## 分析

[一年前](https://www.luogu.com.cn/blog/xiaoziyaoxzy/solution-p5397)我在路上做第四分块，折戟沉沙。一年后，我在加强版继续折戟沉沙。

我失败了。我还是以前的那个我。

套路的序列分块。

先考虑怎么查询，每个整块开个二维数组 $dis$ 维护 $a$ 和 $b$ 的最近距离，暴力找散块内部的答案，块间的答案数字一定在第一个/最后一个出现位置，从前往后扫一遍，最后再拼上整块内部的答案。

修改的时候，不难发现除了维护 $dis$ 数组之外的内容都是平凡的。实际上，维护 $dis$ 可以枚举每个既包含 $x$ 又包含 $y$ 的块，对这些块中关于 $x,y$ 的 $dis$ 暴力重构。势能分析一下，若我们将不同块的相同颜色看成不同颜色，那么初始颜色数量为 $n$，每次修改至多增加两个颜色，重构一个块则会减少一个颜色，于是重构次数是线性的。

这样可以做到 $O(n\sqrt n)$ 的时空复杂度。

我们发现 $dis$ 数组的维护比较独立，于是可以离线逐块处理，空间就变成线性了。

## 代码

咕了。

---

## 作者：orz_z (赞：1)

### P5692 手牵手走向明天

有一个长度为 $n$ 的序列 $a$，有 $m$ 次操作。

* 给定 $l,r,x,y$，将 $a_l,a_{l+1},a_{l+2},\cdots,a_r$ 中等于 $x$ 的数全部改成 $y$。
* 给定 $l,r,x,y$，找到 $i,j$ 满足 $i,j\in[l,r]$ 且 $a_i=x,a_j=y$，并要求 $|i-j|$ 最小，求这个最小值，无解输出 `-1`。

$1 \leq n,m,a_i\leq 10^5$，时限 $1.50\text{s}$，空限 $512\text{MB}$。

#### sol

「弑尽破净第四分块」加强版。

无难度评分。

相较于 [P5397 天降之物](https://www.luogu.com.cn/problem/P5692)，这题是对区间修改和查询，所以我们不能再用原先的根号分治。

考虑序列分块。

对于答案在一个块内的情况显然可以预处理。

但这里如果是开一个 $dis[i][j][k]$ 的三维数组的话空间是 $n^2\sqrt n$ 级别的。

注意到每个块内只有 $\sqrt n$ 个数，所以可以使用类似于离散化的技巧，对于每个数，把它映射到一个标号，这样空间就是 $n\sqrt n$ 开得下了，可 $\mathcal O(1)$ 获取⼀个数在某个块中的标号，$dis[i][j][k]$ 的定义为第 $i$ 个块内，数 $j$ 与离散化后的 $k$ 的最短距离。

如果不在一个块内的话，由于我们要求距离最小，那么每个块中可能成为答案的，只有这个数第一次出现的位置和最后一次出现的位置，维护每个块内每个数第一次和最后一次出现的位置，然后扫一遍，维护 $x$ 和 $y$ 各自最后一次出现的位置即可，单次时间复杂度 $\mathcal O(\sqrt n)$。

对于散块的查询直接扫过去，单次时间复杂度为 $\mathcal O(\sqrt n)$。

再看修改，枚举每一个块，假设一个块中最开始有 $m$ 个颜色，那么修改 $x$ 为 $y$：

* 无 $x$：跳过。
* 有 $x$ 无 $y$：改标号即可。
* 有 $x$ 有 $y$：对于 $x,y$ 以外的 $m-2$ 个颜色，每一个颜色都需要进行 $\mathcal O(1)$ 次修改，然后合并 $x,y$ 的颜色信息也是 $\mathcal O(m)$ 的，总时间复杂度是 $O(m)$，并且每次操作完 $m$ 减少一。

考虑怎么更新 $dis$ 数组的信息，容易想到，枚举每个其他颜色，取 $\min$ 即可。

那么一个块最多产生多少次操作？

因为 $m$ 最大为 $\sqrt{n}$ ，所以一个块中的操作次数其实是 $\mathcal O(n)$ 级别的，所以总操作次数就是 $O(n\sqrt{n})$。

最后看散块修改，最大的问题在于关于 $y$ 的距离怎么修改，因为做的是 $\min$，直接修改似乎不好办。

考虑到，先用 $O(\sqrt{n})$ 的代价将这一块的 $a_i$ 的实际值求出来，然后对于 $y$ 的相关信息直接求一遍，$x$ 的相关信息也直接求一遍，这一部分的复杂度是 $O(\sqrt{n})$ 的。

需要注意的是，散块的修改可能增加一个颜色，但是散块最多只会增加 $\sqrt n$ 个颜色，所以时间复杂度还是对的。

所以，总时间复杂度为 $\mathcal O((n+m)\sqrt n)$，总空间复杂度为 $\mathcal O(n \sqrt n)$。

$\text{2.76s / 398.59MB / 6.84KB C++98 O2}$。

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>

namespace Fread
{
	const int SIZE = 1 << 21;
	char buf[SIZE], *S, *T;
	inline char getchar()
	{
		if (S == T)
		{
			T = (S = buf) + fread(buf, 1, SIZE, stdin);
			if (S == T)
				return '\n';
		}
		return *S++;
	}
}
namespace Fwrite
{
	const int SIZE = 1 << 21;
	char buf[SIZE], *S = buf, *T = buf + SIZE;
	inline void flush()
	{
		fwrite(buf, 1, S - buf, stdout);
		S = buf;
	}
	inline void putchar(char c)
	{
		*S++ = c;
		if (S == T)
			flush();
	}
	struct NTR
	{
		~NTR()
		{
			flush();
		}
	} ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int N = 1e5 + 3, S = 3e2 + 3, T = 6e2 + 3, inf = 0x3f3f3f3f;

int n, m, q, a[N];

int sqrtn, bl[N], L[T], R[T];

int dis[T][S][S], disl[T][S], disr[T][S], pot[T][N], rpot[T][S], lim[T];

int rt[T][S], col[N], fa[N];

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

inline int min(int x, int y)
{
	return x < y ? x : y;
}

inline int max(int x, int y)
{
	return x > y ? x : y;
}

inline void chkmin(int &x, int y)
{
	x = min(x, y);
}

inline void chkmax(int &x, int y)
{
	x = max(x, y);
}

inline void swap(int &x, int &y)
{
	x ^= y ^= x ^= y;
}

inline void upd_dis(int t, int _L, int _R, int y)
{
	int tl = -inf;
	const int &py = pot[t][y];
	for (int j = _L; j <= _R; ++j)
	{
		if (col[find(j)] == y)
			tl = j;
		chkmin(dis[t][py][pot[t][col[find(j)]]], j - tl);
		chkmin(dis[t][pot[t][col[find(j)]]][py], j - tl);
	}
	tl = inf;
	for (int j = _R; j >= _L; --j)
	{
		if (col[find(j)] == y)
			tl = j;
		chkmin(dis[t][py][pot[t][col[find(j)]]], tl - j);
		chkmin(dis[t][pot[t][col[find(j)]]][py], tl - j);
	}
}

inline void init()
{
	sqrtn = sqrt(n * 2.2 / 5);
	for (int i = 1, c = 1, j; i <= n; i = j + 1, ++c)
	{
		L[c] = i, R[c] = j = min(n, i + sqrtn);
		for (int t = L[c]; t <= R[c]; ++t)
			bl[t] = c;
	}
	m = bl[n];
	memset(disl, 60, sizeof disl);
	memset(disr, -61, sizeof disr);
	memset(dis, 60, sizeof dis);
	for (int t = 1; t <= m; ++t)
	{
		for (int i = L[t]; i <= R[t]; ++i)
		{
			if (!pot[t][a[i]])
			{
				rpot[t][pot[t][a[i]] = ++lim[t]] = a[i];
				col[rt[t][lim[t]] = i] = a[i];
			}
			fa[i] = rt[t][pot[t][a[i]]];
		}
		for (int i = L[t]; i <= R[t]; ++i)
			if (fa[i] == i)
				upd_dis(t, L[t], R[t], a[i]);
		for (int i = R[t]; i >= L[t]; --i)
			disl[t][pot[t][a[i]]] = i;
		for (int i = L[t]; i <= R[t]; ++i)
			disr[t][pot[t][a[i]]] = i;
	}
}

inline int calc(int l, int r, int x, int y)
{
	int ans = inf, lx = -inf, ly = -inf;
	for (int i = l; i <= r; ++i)
	{
		if (col[find(i)] == x)
			lx = i, chkmin(ans, i - ly);
		if (col[find(i)] == y)
			ly = i, chkmin(ans, i - lx);
	}
	return ans;
}

inline int query(int l, int r, int x, int y)
{
	if (x == y)
	{
		bool flag = 0;
		if (bl[l] == bl[r])
			for (int i = l; i <= r; ++i)
				flag |= col[find(i)] == x;
		else
		{
			for (int i = l; i <= R[bl[l]]; ++i)
				flag |= col[find(i)] == x;
			for (int i = L[bl[r]]; i <= r; ++i)
				flag |= col[find(i)] == x;
			for (int i = bl[l] + 1; i <= bl[r] - 1; ++i)
				flag |= pot[i][x] > 0;
		}
		return -1 + flag;
	}
	if (bl[l] == bl[r])
		return calc(l, r, x, y);
	int ans = min(calc(l, R[bl[l]], x, y), calc(L[bl[r]], r, x, y));
	int lx = disr[bl[l]][pot[bl[l]][x]];
	if (lx < l)
		lx = -inf;
	int ly = disr[bl[l]][pot[bl[l]][y]];
	if (ly < l)
		ly = -inf;
	for (int i = bl[l] + 1; i <= bl[r] - 1; ++i)
	{
		if (pot[i][x])
			chkmin(ans, disl[i][pot[i][x]] - ly);
		if (pot[i][y])
			chkmin(ans, disl[i][pot[i][y]] - lx);
		if (pot[i][x])
			lx = disr[i][pot[i][x]];
		if (pot[i][y])
			ly = disr[i][pot[i][y]];
		chkmin(ans, dis[i][pot[i][x]][pot[i][y]]);
	}
	int rx = disl[bl[r]][pot[bl[r]][x]];
	if (rx > r)
		rx = inf;
	int ry = disl[bl[r]][pot[bl[r]][y]];
	if (ry > r)
		ry = inf;
	return min(ans, min(rx - ly, ry - lx));
}

inline void deleted(int t, int px)
{
	const int &lt = lim[t];
	swap(rt[t][px], rt[t][lt]);
	for (int i = 1; i <= lt; ++i)
		swap(dis[t][px][i], dis[t][lt][i]), swap(dis[t][i][px], dis[t][i][lt]);
	swap(disl[t][px], disl[t][lt]), swap(disr[t][px], disr[t][lt]);
	swap(rpot[t][px], rpot[t][lt]), swap(pot[t][rpot[t][px]], px), --lim[t];
}

inline void cg(int t, int l, int r, int x, int y)
{
	int ret = 0, &px = pot[t][x], &py = pot[t][y];
	const int &_L = L[t], &_R = R[t];
	for (int i = l; i <= r; ++i)
		ret += col[find(i)] == x;
	if (!ret)
		return;
	if (!py)
	{
		rpot[t][py = ++lim[t]] = y, disl[t][py] = inf, disr[t][py] = -inf;
		for (int i = 1; i <= lim[t]; ++i)
			dis[t][py][i] = dis[t][i][py] = inf;
	}
	for (int i = 1; i <= lim[t]; ++i)
		dis[t][px][i] = dis[t][i][px] = inf;
	for (int i = _L; i <= _R; ++i)
	{
		a[i] = col[find(i)];
		rt[t][pot[t][a[i]]] = 0;
	}
	for (int i = l; i <= r; ++i)
		if (a[i] == x)
		{
			a[i] = y;
			--ret;
		}
	for (int i = _L; i <= _R; ++i)
		ret += a[i] == x;
	if (!ret)
		deleted(t, px);
	for (int i = _L; i <= _R; ++i)
	{
		if (!rt[t][pot[t][a[i]]])
			col[rt[t][pot[t][a[i]]] = i] = a[i];
		fa[i] = rt[t][pot[t][a[i]]];
	}
	upd_dis(t, _L, _R, y);
	if (ret)
		upd_dis(t, _L, _R, x);
	for (int i = _R; i >= _L; --i)
		disl[t][pot[t][a[i]]] = i;
	for (int i = _L; i <= _R; ++i)
		disr[t][pot[t][a[i]]] = i;
	if (!ret)
		px = 0;
}

inline void modify(int l, int r, int x, int y)
{
	if (x == y)
		return;
	if (bl[l] == bl[r])
		return cg(bl[l], l, r, x, y), void();
	cg(bl[l], l, R[bl[l]], x, y);
	cg(bl[r], L[bl[r]], r, x, y);
	for (int t = bl[l] + 1; t <= bl[r] - 1; ++t)
	{
		int &px = pot[t][x], &py = pot[t][y];
		if (!px)
			continue;
		if (!py)
		{
			rpot[t][py = px] = y, px = 0, col[rt[t][py]] = y;
			continue;
		}
		fa[rt[t][px]] = rt[t][py], rt[t][px] = 0;
		for (int i = lim[t]; i >= 1; --i)
		{
			chkmin(dis[t][py][i], dis[t][px][i]);
			chkmin(dis[t][i][py], dis[t][i][px]);
		}
		chkmin(disl[t][py], disl[t][px]);
		chkmax(disr[t][py], disr[t][px]);
		for (int i = lim[t]; i >= 1; --i)
			dis[t][px][i] = dis[t][i][px] = inf;
		deleted(t, px), px = 0;
	}
}

int op, l, r, x, y;

int main()
{
	n = read(), q = read();
	for (int i = 1; i <= n; ++i)
		a[i] = read();
	init();
	for (int i = 1; i <= q; ++i)
	{
		op = read(), l = read(), r = read(), x = read(), y = read();
		if (op == 1)
			modify(l, r, x, y);
		else
		{
			int ans = query(l, r, x, y);
			write(ans > n ? -1 : ans);
			putchar('\n');
		}
	}
}
```





---


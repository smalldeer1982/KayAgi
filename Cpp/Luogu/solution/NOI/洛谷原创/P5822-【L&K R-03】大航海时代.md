# 【L&K R-03】大航海时代

## 题目描述

【如果不想看题面请阅读分割线以下部分】

$$\text{Onde\space a\space terra\space acaba\space e\space o\space mar\space começa}$$

>_15 世纪末，是一个伟大时代的开始。自此之后，人们开始逐渐认识到大千世界的险恶与奇丽，开始前仆后继地展开一个又一个不可思议的冒险，开始缓缓地驾驭那波涛汹涌、变幻莫测的大海。_

>_15 世纪末，是一个伟大时代的开始。为了征服海洋，人们集人类之智慧，制造出方舟巨轮；汇天地之灵怪，制造出罗盘、六分仪。海上的康庄大道从此建立，人们航行于各地，商贸随之诞生。_

>_15 世纪末，是一个伟大时代的开始。商品与金钱象征着欲望，在海上流动了起来。原先分隔的黄金汇聚成大金库，让人们尝到了商业的甜头。贸易的花朵开遍整个欧洲，航线上船只往来不绝，财富源源不断地从海上涌出。_

>_[更多](https://www.luogu.org/paste/k9bqwpps)_

>……

>_大航海时代，是人类文明崭新的起点。_

海上经商，商人们必须对航路有充分的了解。欧洲的城市不计其数，航路更是数不胜数。当然，人们无需知晓所有城市的位置，更无需清楚所有航路的情况。人们只需要知道，有几个主要城市，并且有几条海上航路连接着它们即可，其他的城市与航路都是次要的，不会带来过多收益。

商船沿着航路往来于城市之间。它们每到一个城市，卸下一些货品，城市里的商人便会根据货品的数目给出相应的报酬。这些报酬由船主收取，并将部分报酬分发给水手们。不过大家并不关心这件事，他们只会关心一艘船获得的总收益。

商船的航行总会伴随着危险与损失。海上的天气难以预测，船只随时都可能会被大浪吞没，或者被飓风刮得千疮百孔。不过这些情况比较特殊，我们并不考虑。我们考虑的是，商船在航行过程中的必要支出。一趟航行往往需要几星期甚至几个月的时间。在这段时间里，船员需要淡水与食物，船也需要适当的维护。人们总结经验发现，一段航行的必要支出与航行距离和载货量有直接关系。

大航海时代的人们就是在这些规律下生活的，考量着商船的支出与收益，缓行于茫茫大海之上，每日如此，单调而无趣。大航海时代，对于大部分人来说，或许并没有那么伟大。

当然，生于现代的我们不必在意这些东西。这也是当然的，现代人怎么会为古代人考虑什么东西呢？

然而，小 L 和小 K 发现他们必须开始考虑这些事物了，因为他们不小心掉进了虫洞，回到了大航海时代。回到过去的他们用唯一的财产：手机，换来了一艘船和一船货物。为了生存，他们要驾驶着这艘船航行于海上，用货物与商人们换取钱财。

----------------------------------

小 L 和小 K 通过调查了解了海上贸易的一些基本规律。共有 $n$ 个主要城市和 $m$ 条连接着它们的航道，船只能沿着这些航道航行。注意航道是单向的，因为如果是双向，航线就容易交叉，发生事故。第 $i$ 条航道的距离为 $dis_i$，若商船在经过此航道时载货量（下称货物量）为 $p$，则航行完此航道需花费 $p\times dis_i$  的金币。商船到达一个城市，会卸下部分货物与商人交易。每座城市都有一个大商人，会根据 **船上卸下** 的货物量付给商船一定的金币。每座城市的大商人不同，标准也不一样。第 $i$ 座城市的大商人标准为 $mea_i$，若商船在 $i$ 号城市卸下量为 $p$ 的商品，大商人会付给商船 $p\times mea_i$ 的金币。商船每到达一座城市，只会与大商人进行一次交易。当然，一座城市可以重复到达，每次到达都会与大商人进行交易。

小 L 和小 K 需要遵循这些规律，沿着航道进行海上贸易。小 L 和小 K 在一开始总共有量为 $q$ 的货品。小 L 和小 K 本该精打细算，详细计算出他们在每座城市应该卸下的货物量。但是小 L 和小 K 是懒癌晚期患者，并不想这样做。他们随便想了两个正整数 $s,t$，于是如果需要卸下货物，他们便会卸下总货物量 $\frac{s}{s+t}$ 的货物。

在他们的商贸之旅开始之前，小 L 和小 K 就已经研究出了回到现代的方法。但是他们并不着急回去。因为回溯时间导致的时空错位，小 L 和小 K 身上的时间是静止的。也就是说他们拥有无限的时间。他们决定利用此原理在这个时代大赚一笔。小 L 和小 K 可以选择从任意一座城市出发。他们希望知道从每座城市出发，可以赚到的最大金币数量是多少。当然因为他们比较懒，这个问题由你来解决。

需要注意的是，尽管在大航海时代分数的运算并没有普及，但小 L 和小 K 为了自己方便而将他们得到的信息部分用分数（有理数）来表示。也就是说，虽然 $dis_i,mea_i,q$ 是由当时的人们给出的，所以是整数，但是货物量和金币量可以是分数，即小 L 和小 K 用有理数的计算法则计算自己的收益。小 L 和小 K 在出发的城市也会进行交易。

## 说明/提示

【样例说明】

$\frac{s}{s+t}=\frac{1}{2}$，小 L 和小 K 每次会卸下一半的货物进行交易。

从 $1$ 号城市出发：先在 $1$ 号城市进行交易，用 $2\times\frac{1}{2}=1$ 的货物量交易，获得金币 $1\times 100=100$，剩余货物量 $2-1=1$。之后如果走 $1\rightarrow1$ 的航道，会再花费 $1\times 50=50$ 的金币回到城市 $1$，很不划算。如果走 $1\rightarrow2$ 的航道，只需要再花费 $1\times 2=2$ 的金币就可以到达城市 $2$。到达城市 $2$ 进行交易，用 $1\times\frac{1}{2}=\frac{1}{2}$ 的货物量交易，获得金币 $\frac{1}{2}\times 200=100$，剩余货物量 $1-\frac{1}{2}=\frac{1}{2}$。接下来走 $2\rightarrow3$，花费 $\frac{1}{2}\times1=\frac{1}{2}$ 的金币。到达城市 $3$，用 $\frac{1}{2}\times\frac{1}{2}=\frac{1}{4}$的货物量交易，交易获得金币 $\frac{1}{4}\times300=75$，剩余货物量 $\frac{1}{2}-\frac{1}{4}=\frac{1}{4}$。总获利 $100-2+100-\frac{1}{2}+75=\frac{545}{2}$。

从 $2$ 号城市出发：走 $2\rightarrow3$，在 $2,3$ 号城市交易，获利 $200-1+150=349$。

从 $3$ 号城市出发：在 $3$ 号城市交易，获利 $300$。

【数据范围】

对于 $10\%$ 的数据，$n\le 3,m\le 9$，$s,t,q,mea_i,dis_i\le10$。

对于 $50\%$ 的数据，$n\le 10,m\le 100$，$s,t,q,mea_i,dis_i\le10$。

对于另外 $10\%$ 数据，$m=n$，且对于任意正整数 $i\in[1,n]$，编号为 $i$ 的城市有一条到编号为 $(i\mod n)+1$ 的城市的航道。

对于另外 $10\%$ 数据，对于任意正整数 $i\in[1,n]$，若存在航道 
 $i\rightarrow j$，则 $j>i$。

对于 $100\%$ 的数据，$n\le 50,m\le 500$，$s,t,q,mea_i,dis_i\le10^4$。

【补充说明】

城市从 $1$ 到 $n$ 编号。

请注意本题特殊的时空限制。

为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。保证标程在加上八聚氧后通过每个数据点的最大用时小于时限的一半。请大胆尝试解法。

## 样例 #1

### 输入

```
3 3 1 1 2
100 200 300
1 1 50
1 2 2
2 3 1```

### 输出

```
545/2
349
300```

# 题解

## 作者：KesdiaelKen (赞：19)

~~题面写的好累~~

本题是一道图论+高精题目，这两部分都在本题中占有很重要的地位。

点权和边权都是正的。因为到达的城市都要进行交易，经过的边也都要花费金币，所以我们可以让每条边表示其边权和其指向城市的点权这两个信息。这样，题意就变成了：**从图中每个点出发，走任意长度路径，每走过一条边货物会按比例减少一定数值，求走过的所有边边权与货物量的乘积之和。**

可以发现本题与[幸福路径](https://www.luogu.com.cn/problem/P4308)这题很像（事实上只要会做这道题，原题就是双倍经验）。只不过原题是要输出一个小数，而本题要输出的是分数。原题倍增floyd的做法在本题显然行不通。我们需要一个不利用精度的解法。

考虑从其中一个点出发的情形。显然，路径长度要么有限，要么无限。我们先考虑路径长度无限的情况。

因为路径长度无限，显然至少有一个点被经过无限次。假设这个点是$i$，则路径的情况一定是这样的：从起点走到$i$，然后走过几个经过$i$的环，并一直走下去。然而，只是知道这些，我们并不能很好地做出这题。这个模型需要更多的约束条件。

我们先考虑环的条件。凭感觉似乎能够想出，在所有经过$i$的环中，有一个是最优的。但是该如何证明呢？

因为经过环的数量是无限的，可以考虑类似数学归纳法的方法证明。

我们把经过的环排成一个序列。例如，如果先后经过环$C_1,C_2,C_3,C_2$，则形成的序列就是$C_1C_2C_3C_2$。

考虑这样一个事情：如果有长度为无限的序列$C_1C_2C_3C_4...$，我们希望得到序列$C_xC_1C_2C_3C_4...$。这时候，我们可以考虑在$C_1C_2C_3C_4...$前加上一个$C_x$。

这听起来很简单，但如果我们希望由$C_1C_2C_3C_4...$得到的序列式$C_aC_bC_cC_d...$呢？可以考虑扩展上述思路：先在$C_1C_2C_3C_4...$前加上$C_aC_bC_cC_d...$的尾项（这么说可能不是很严谨，因为一个长度为无穷的序列没有尾项，先大致理解一下意思即可），然后再加上尾项的前一项，一直加到$C_aC_bC_cC_d...$的第一项。此时，$C_aC_bC_cC_d...$为新的序列开头的部分。又因为$C_aC_bC_cC_d...$长度为无限，导致原来的$C_1C_2C_3C_4...$对整体的贡献变成了无穷小，不用考虑。这样，我们就把$C_1C_2C_3C_4...$转化为了$C_aC_bC_cC_d...$。

通过上面的思路我们发现，任何一个无穷长的序列都可以由另一个无穷长的序列转化过来。

就着这样的思路，我们来探究一下：对于一个长度为无穷的序列$\{C_i\}$，若在其队首加上环$B$，得到的新序列的值（按照题目从$i$开始走边得到的值）与原序列比较会如何变化。

设$\{C_i\}$的值为$v_C$，单个环$B$的值为$v_B$，其长度（经过的边数）为$l_B$。设$q=\frac{t}{s+t}$（每走过一条边货物量的下降程度），则加上$B$形成的新环值为$v_B+q^{l_B}v_C$。将其与$v_C$比较。我们让$v_C$都移到同一边，即$v_B$与$(1-q^{l_B})v_C$比较。因为$0<q<1$，可以变为$v_B\frac{1}{1-q^{l_B}}$与$v_C$比较。对数列比较敏感的同学应该已经看出来了，左式其实就是环序列$BBBB...$的值了。所以，如果$BBBB...$比$\{C_i\}$优，则在$\{C_i\}$前加上$B$形成的序列比$\{C_i\}$优。反之亦然。注意这是个充要条件，即若在$\{C_i\}$前加上$B$形成的序列比$\{C_i\}$优，则$BBBB...$比$\{C_i\}$优。

显然，我们可以构造一个初始序列，让所有序列都由在其队首添加项的方式得来。

所有单环中必有一个是最优的。我们设其为$A$，构造初始序列$AAAA...$。那么，根据上面的原理，可以推得$AAAA...$是所有环序列中最优的。

接下来我们考虑$A$的性质。如果$A$中有重复经过节点，则显然$A$中包含至少两个环。我们把其中值较大的环用上述方式列成初始序列，则$AAAA...$比其小。因此，$A$中不会重复经过节点，即$A$的长度不大于$n$。

这样，路径模型的后半部分就解决了。只需解决从起点走到$i$这部分路径的情况。

有了上面解决环问题的经验，我们可以大致得出这部分路径应该具有什么性质：不重复经过任何节点，即不经过环。我们可以这样想，先证明路径上如果仅有一个单环时，其非最优性。接下来，路径上有若干个单环的情况都可以由这部分推得。

若路径上只有一个单环，那么加上之后的环部分，整条航线只会经过两个环（$i\rightarrow j\rightarrow B\rightarrow k\rightarrow AAAA...$）。（如图）![](https://cdn.luogu.com.cn/upload/image_hosting/5sqoc7zc.png))

这种情况下，有两种符合“路径不重复经过节点”条件的航线：$i\rightarrow j \rightarrow BBBB...$和$i\rightarrow j\rightarrow k \rightarrow AAAA...$。我们只需要证明，这两种情况的值至少有一个比$i\rightarrow j\rightarrow B\rightarrow k\rightarrow AAAA...$这种航线大即可。

由于三种路径都经过$i\rightarrow j$，我们大可将这段省去。于是，我们需要比较$j\rightarrow B\rightarrow k\rightarrow AAAA...$，$j \rightarrow BBBB...$与$j\rightarrow k \rightarrow AAAA...$。

用$K$表示$j\rightarrow k$这段路程，则$j\rightarrow B\rightarrow k\rightarrow AAAA...$对应的序列为$BKAAAA...$，$j \rightarrow BBBB...$对应$BBBB...$，$j\rightarrow k \rightarrow AAAA...$对应$KAAAA...$。

考虑先比较$BKAAAA...$与$KAAAA...$。若$BKAAAA...$值小于$KAAAA...$则已经得证；否则，根据上面的结论，$BBBB...$值大于$KAAAA...$，而$BBBB...$恰好为$j \rightarrow BBBB...$对应的序列。因此得证。

所以，我们已经得出模型的限制条件了：从$i$出发，经过一个无环路径，然后一直走一个单环。无环路径与单环的长度都不大于$n$。

这就是路径长度为无限的做法。路径长度有限的做法其实只需要参考环之前的部分即可。

于是，我们可以先用$O(n^2m)$递推出从$i$到$j$路径长度为$k$的最大值，然后得到经过每个点的最大环。之后枚举起点与环之前路径的终点，路径长度，得到起点的答案即可。

这样这道题的思路就得出了。接下来就是高精的事情了。

如果用普通的分数高精，则在计算过程中会因为通分而炸掉。考虑先把$\frac{s}{s+t}$的$s+t$乘到分母，在最后再除回来，这样就可以避免以上问题。

然后，还需要注意一下各种优化，包括常数优化和非常数优化，比如递推时如果直接用三维数组空间会炸，要用滚动数组等。

------------

其实这道题的解法很容易想到，但是要证明还是比较困难的。代码难度主要在于高精度，~~上网找板子就可以了~~。

## $\%10$

不写高精直接做。

## $\%50$

写的很菜的高精。

## 成环部分

由于只存在一个环，判断一下是否使用即可。

## $DAG$部分

$DAG$上DP。

## $\%100$

写的不是那么菜的高精。

下面是参考程序（写的很长且很难看，请见谅）：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<string>
#include<iostream>
using namespace std;
const long long mod=1e9;const int wss=9;
const long long che[9]={1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8};
struct GJD
{
    long long num[100];int len;
    GJD(){len=0;}
    inline bool operator<=(GJD&a)
    {
        if(len!=a.len)return len<a.len;
        for(register int i=len-1;i>=0;i--)if(num[i]!=a.num[i])return num[i]<a.num[i];
        return true;
    }
    inline bool operator==(GJD&a)
    {
    	if(len!=a.len)return false;
    	for(register int i=len-1;i>=0;i--)if(num[i]!=a.num[i])return false;
    	return true;
	}
    inline void jia(GJD&a,GJD&b)
    {
        long long x=0;len=0;
        for(;len<a.len||len<b.len||x;len++)
        {
            if(len>=a.len)a.num[len]=0;
            if(len>=b.len)b.num[len]=0;
            num[len]=a.num[len]+b.num[len]+x;
            if(num[len]<mod)x=0;
            else{x=1;num[len]-=mod;}
        }
        while(len>1&&num[len-1]==0)len--;
    }
    inline void jian(GJD&a,GJD&b)
    {
        long long x=0;len=0;
        for(;len<a.len||len<b.len||x;len++)
        {
            if(len>=a.len)a.num[len]=0;
            if(len>=b.len)b.num[len]=0;
            num[len]=a.num[len]-b.num[len]-x;
            if(num[len]>=0)x=0;
            else{x=1;num[len]+=mod;}
        }
        while(len>1&&num[len-1]==0)len--;
    }
    inline void cheng(GJD&a,GJD&b)
    {
        for(register int i=0;i<=a.len+b.len;i++)num[i]=0;
        for(register int i=0;i<a.len;i++)
        {
            if(a.num[i]==0)continue;
            for(register int j=0;j<b.len;j++)
            {
                num[i+j]+=a.num[i]*b.num[j];
                num[i+j+1]+=num[i+j]/mod;
                num[i+j]-=num[i+j]/mod*mod;
            }
        }
        len=a.len+b.len;
        while(len>1&&num[len-1]==0)len--;
    }
    inline GJD operator/(GJD&b)
    {
        GJD a,c,d,e;a.len=len;for(int i=0;i<len;i++)a.num[i]=num[i];
        int ks=d.len=len-b.len+1;
        if(ks<=0)
        {
            d.len=1;d.num[0]=0;
            return d;
        }
        long long zuo,you,mid;
        for(int i=ks;i>=1;i--)
        {
            memset(c.num,0,sizeof(c.num));
            c.len=i;
            zuo=0,you=mod-1;
            while(zuo!=you)
            {
                mid=(zuo+you+1)>>1;
                c.num[i-1]=mid;
                e.cheng(c,b);
                if(e<=a)zuo=mid;
                else you=mid-1;
            }
            c.num[i-1]=d.num[i-1]=zuo;
            e.cheng(c,b);c.jian(a,e);a=c;
        }
        while(d.len>1&&d.num[d.len-1]==0)d.len--;
        return d;
    }
};
inline void output(GJD&a)
{
    printf("%lld",a.num[a.len-1]);
    for(int i=a.len-2;i>=0;i--)
    {
        for(int j=wss-1;j>=0;j--)
        {
            if(a.num[i]>=che[j])
            {
                printf("%lld",a.num[i]);
                break;
            }
            printf("0");
        }
    }
}
GJD gjd,gjdgjd;
GJD gcd(GJD x,GJD y)
{
    if(y.num[0]==0&&y.len==1)return x;
    gjd=x/y;gjdgjd.cheng(gjd,y);gjd.jian(x,gjdgjd);
    return gcd(y,gjd);
}
struct BIGNUM
{
	GJD shu;bool zf;
	BIGNUM(){zf=true;}
	inline bool operator<(BIGNUM&a)
	{
		if(!zf&&a.zf)return true;
        if(zf&&(!a.zf))return false;
        if(shu==a.shu)return false;
        return (shu<=a.shu)^(!zf);
	}
	inline void jia(BIGNUM&a,BIGNUM&b)
	{
		if(a.zf==b.zf)
		{
			zf=a.zf,shu.jia(a.shu,b.shu);
			return;
		}
		if(a.zf)
		{
			if(b.shu<=a.shu)zf=true,shu.jian(a.shu,b.shu);
			else zf=false,shu.jian(b.shu,a.shu);
		}
		else
		{
			if(a.shu<=b.shu)zf=true,shu.jian(b.shu,a.shu);
			else zf=false,shu.jian(a.shu,b.shu);
		}
	}
	inline void jian(BIGNUM&a,BIGNUM&b)
	{
		if(a.zf==!b.zf)
		{
			zf=a.zf,shu.jia(a.shu,b.shu);
			return;
		}
		if(a.zf)
		{
			if(b.shu<=a.shu)zf=true,shu.jian(a.shu,b.shu);
			else zf=false,shu.jian(b.shu,a.shu);
		}
		else
		{
			if(a.shu<=b.shu)zf=true,shu.jian(b.shu,a.shu);
			else zf=false,shu.jian(a.shu,b.shu);
		}
	}
	inline void cheng(BIGNUM&a,BIGNUM&b)
	{
		shu.cheng(a.shu,b.shu);
		zf=!(a.zf^b.zf);
	}
};
GJD aa,bb;
struct FRAC
{
    GJD fz,fm;bool zf;
    FRAC(){zf=true;}
    inline void operator=(BIGNUM&a)
	{
		zf=a.zf;
		fz=a.shu;
		fm.len=1;fm.num[0]=1;
	}
    inline bool operator<(FRAC&a)
    {
        if(!zf&&a.zf)return true;
        if(zf&&(!a.zf))return false;
        GJD aa,bb;aa.cheng(fz,a.fm),bb.cheng(fm,a.fz);
        if(aa==bb)return false;
        return (aa<=bb)^(!zf);
    }
    inline bool operator<(BIGNUM&a)
    {
    	if(!zf&&a.zf)return true;
        if(zf&&(!a.zf))return false;
        GJD aa=fz,bb;bb.cheng(fm,a.shu);
        if(aa==bb)return false;
        return (aa<=bb)^(!zf);
	}
    inline void jia(FRAC&a,FRAC&b)
    {
        aa.cheng(a.fz,b.fm);bb.cheng(a.fm,b.fz);
        fm.cheng(a.fm,b.fm);
        if(a.zf==b.zf)
		{
			zf=a.zf,fz.jia(aa,bb);
			return;
		}
		if(a.zf)
		{
			if(bb<=aa)zf=true,fz.jian(aa,bb);
			else zf=false,fz.jian(bb,aa);
		}
		else
		{
			if(aa<=bb)zf=true,fz.jian(bb,aa);
			else zf=false,fz.jian(aa,bb);
		}
    }
    inline void jiajia(BIGNUM&a,FRAC&b)
    {
    	aa.cheng(a.shu,b.fm);bb=b.fz;
        fm=b.fm;
        if(a.zf==b.zf)
		{
			zf=a.zf,fz.jia(aa,bb);
			return;
		}
		if(a.zf)
		{
			if(bb<=aa)zf=true,fz.jian(aa,bb);
			else zf=false,fz.jian(bb,aa);
		}
		else
		{
			if(aa<=bb)zf=true,fz.jian(bb,aa);
			else zf=false,fz.jian(aa,bb);
		}
	}
    inline void jian(FRAC&a,FRAC&b)
    {
        aa.cheng(a.fz,b.fm);bb.cheng(a.fm,b.fz);
        fm.cheng(a.fm,b.fm);
        if(a.zf==!b.zf)
		{
			zf=a.zf,fz.jia(aa,bb);
			return;
		}
		if(a.zf)
		{
			if(bb<=aa)zf=true,fz.jian(aa,bb);
			else zf=false,fz.jian(bb,aa);
		}
		else
		{
			if(aa<=bb)zf=true,fz.jian(bb,aa);
			else zf=false,fz.jian(aa,bb);
		}
    }
    inline void cheng(FRAC&a,FRAC&b)
    {
        zf=!(a.zf^b.zf);
		fz.cheng(a.fz,b.fz),fm.cheng(a.fm,b.fm);
    }
}q,std1,std0;
int n,m,fa,fb;
inline void dy(int&a)
{
	int ch=0;a=0;
	while(ch<'0'||ch>'9'){ch=getchar();}
	while(ch>='0'&&ch<='9'){a=a*10+ch-'0';ch=getchar();}
}
inline void dr(BIGNUM&aa)
{
    int a;dy(a);
    aa.zf=true;
    aa.shu.len=1;aa.shu.num[0]=a;
}
inline void fracdr(FRAC&aa)
{
    int a;dy(a);
    aa.zf=true;
    aa.fz.len=aa.fm.len=1;
    aa.fz.num[0]=a,aa.fm.num[0]=1;
}
inline void sc(FRAC aa)
{
    GJD lr=gcd(aa.fz,aa.fm);
    aa.fz=aa.fz/lr,aa.fm=aa.fm/lr;
    output(aa.fz);
    if(aa.fm.len==1&&aa.fm.num[0]==1)return;
    printf("/");output(aa.fm);
}
const int SZ=51;
BIGNUM pn1[100],pn2[100],pn[100],dis[SZ][SZ][2],lsc[SZ][SZ],jl[SZ][SZ],mea[100];
FRAC maxcir[100],pnn[100],ans[100],lc[SZ][SZ];
bool exdis[SZ][SZ][SZ]={0},excir[100]={0},con[SZ][SZ];
int gd;
int main()
{
//  freopen("9.in","r",stdin);
//  freopen("9.out","w",stdout);
    std1.zf=true;std1.fz.len=std1.fm.len=1;std1.fz.num[0]=std1.fm.num[0]=1;
    std0.zf=true;std0.fz.len=std0.fm.len=1;std0.fz.num[0]=0;std0.fm.num[0]=1;
    scanf("%d%d%d%d",&n,&m,&fa,&fb);fracdr(q);
    for(int i=1;i<=n;i++)dr(mea[i]);
    BIGNUM syfm,sy1,sy2;
    syfm.zf=sy1.zf=sy2.zf=true;
    syfm.shu.len=sy1.shu.len=sy2.shu.len=1;
    syfm.shu.num[0]=fa+fb;sy1.shu.num[0]=fa;sy2.shu.num[0]=fb;
    int a,b;BIGNUM c,d,e;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);dr(c);
        d.cheng(mea[b],sy1);e.cheng(c,syfm);
        c.jian(d,e);
        if(!con[a][b])jl[a][b]=c;
        else if(jl[a][b]<c)jl[a][b]=c;
        con[a][b]=true;
    }
    pn1[0].shu=std1.fz;pn1[0].zf=true;for(int i=1;i<=n;i++)pn1[i].cheng(pn1[i-1],sy2);
    pn2[n].shu=std1.fz;pn2[n].zf=true;for(int i=n-1;i>=0;i--)pn2[i].cheng(pn2[i+1],syfm);
    for(int i=1;i<=n;i++)pn[i].cheng(pn1[i],pn2[i+1]);
	for(int i=0;i<=n;i++)pnn[i].zf=true,pnn[i].fz=pn1[i].shu,pnn[i].fm=pn2[n-i].shu;
    memset(exdis,0,sizeof(exdis));
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
        if(con[i][j])dis[i][j][1].cheng(jl[i][j],pn2[1]),exdis[i][j][1]=true;
    gd=0;
    FRAC f,g;
    for(int i=1;i<=n;i++)
    {
    	if(!exdis[i][i][1])continue;
    	f.jian(std1,pnn[1]);
    	g.zf=!(dis[i][i][1].zf^f.zf);
    	g.fz.cheng(dis[i][i][1].shu,f.fm);
    	g.fm=f.fz;
        if(!excir[i])maxcir[i]=g;
    	else if(maxcir[i]<g)maxcir[i]=g;
        excir[i]=true;
	}
    for(register int i=2;i<=n;i++)
    {
        for(register int k=1;k<=n;k++)
        {
            for(register int s=1;s<=n;s++)
            {
                if(!con[k][s])continue;
                lsc[k][s].cheng(jl[k][s],pn[i-1]);
                for(register int j=1;j<=n;j++)
                {
                    if(!exdis[j][k][i-1])continue;
                    c.jia(dis[j][k][gd^1],lsc[k][s]);
                    if(!exdis[j][s][i])dis[j][s][gd]=c;
                    else if(dis[j][s][gd]<c)dis[j][s][gd]=c;
                    exdis[j][s][i]=true;
                }
            }
        }
        for(int j=1;j<=n;j++)
        {
        	if(!exdis[j][j][i])continue;
    		f.jian(std1,pnn[i]);
    		g.zf=!(dis[j][j][gd].zf^f.zf);
    		g.fz.cheng(dis[j][j][gd].shu,f.fm);
    		g.fm=f.fz;
            if(!excir[j])maxcir[j]=g;
            else if(maxcir[j]<g)maxcir[j]=g;
            excir[j]=true;
		}
        gd^=1;
    }
    for(int j=1;j<=n;j++)
    {
    	if(!excir[j])continue;
    	for(int k=1;k<=n;k++)
    		lc[j][k].cheng(maxcir[j],pnn[k]);
	}
	for(int i=1;i<=n;i++)ans[i]=std0;
	memset(exdis,0,sizeof(exdis));
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
        if(con[i][j])dis[i][j][1].cheng(jl[i][j],pn2[1]),exdis[i][j][1]=true;
    gd=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(!exdis[i][j][1])continue;
            if(ans[i]<dis[i][j][1])ans[i]=dis[i][j][1];
            if(!excir[j])continue;
            f.jiajia(dis[i][j][1],lc[j][1]);
            if(ans[i]<f)ans[i]=f;
        }
    }
    for(register int i=2;i<=n;i++)
    {
        for(register int k=1;k<=n;k++)
        {
            for(register int s=1;s<=n;s++)
            {
                if(!con[k][s])continue;
                lsc[k][s].cheng(jl[k][s],pn[i-1]);
                for(register int j=1;j<=n;j++)
                {
                    if(!exdis[j][k][i-1])continue;
                    c.jia(dis[j][k][gd^1],lsc[k][s]);
                    if(!exdis[j][s][i])dis[j][s][gd]=c;
                    else if(dis[j][s][gd]<c)dis[j][s][gd]=c;
                    exdis[j][s][i]=true;
                }
            }
        }
        for(register int j=1;j<=n;j++)
    	{
    	    for(register int k=1;k<=n;k++)
    	    {
    	        if(!exdis[j][k][i])continue;
    	        if(ans[j]<dis[j][k][gd])ans[j]=dis[j][k][gd];
    	        if(!excir[k])continue;
    	        f.jiajia(dis[j][k][gd],lc[k][i]);
    	        if(ans[j]<f)ans[j]=f;
    	    }
    	}
        gd^=1;
    }
    FRAC s1,s2;s1=sy1;s2=sy2;
    s1.fm=s2.fm=syfm.shu;
    for(int i=1;i<=n;i++)
    {
    	d.shu.cheng(ans[i].fm,pn2[0].shu);
        ans[i].fm=d.shu;
        g=mea[i];f.cheng(s1,g);
        g.cheng(s2,ans[i]);
        ans[i].jia(f,g);
        f.cheng(q,ans[i]);
        sc(f);
        printf("\n");
    }
    return 0;
}
```


---

## 作者：Alex_Wei (赞：3)

### [P5822 【L&K R-03】大航海时代](https://www.luogu.com.cn/problem/P5822)

吐槽：

- 这题涉及无穷长路径但提问方式不严谨，因为无穷集不一定有最大值。”最大“ 应该指上确界，尽管可以证明最大值确实存在。
- 没有在题面中说明 ”可以证明答案为有理数“。
- 官方题解的证明完全不知道在说些什么。
- 需要有符号压位高精，还卡常。

设 $p = \frac {t} {s + t}$。

题目同时有点权和边权，考虑将点权转化到边权上。设边 $(u, v)$ 的新权值 $w'(u, v) = (1 - p)w(v) - w(u, v)$，则路径权值改写为
$$
w(P) = q\cdot \left((1 - p)w(v_0) + \sum_{i = 1} ^ k p ^ i w'(e_i) \right)
$$
其中 $(1 - p)w(v_0)$ 只和起点有关，可以放在最后统计，这样就只剩边权了。

考虑最优路径的形态，本题中 “最优” 即 “最大”。自然的想法是路径会在经过 $O(\mathrm{poly}(n))$ 条边之后不断在某个环上绕圈。

定义环的比率为由它不断重复得到的无限长路径的权值，即
$$
r(C) = w(C ^ {\infty}) = w(C) + p ^ {|C|} w(C) + p ^ {2|C|} w(C) + \cdots = \frac {w(C)} {1 - p ^ {|C|}}
$$
定义经过 $v$ 的最大比率环 $C_{\max}(v)$ 为经过 $v$ 的比率最大的**简单环**。

添加权值为 $0$ 的自环不影响答案，但使得最优路径总可以经过无限条边。在此基础上，设 $F(s)$ 表示从 $s$ 出发的路径权值的最大值（实际应定义为上确界）。

因为所有路径的权值有限，根据实数的确界原理，所有路径的权值在实数范围内存在上确界，即 $F(s)$ 存在。

> **性质 $1$**
>
> $F(s)$ 一定会由某条从 $s$ 出发的 $\rho$ 形路径取到，即先走一段不经过重复点的路径，然后在某个简单环上不断绕圈。这同时说明从 $s$ 出发的路径权值存在最大值。
>
> **证明**
>
> 考虑 $s$ 的所有出边 $(s, u)$，因路径长度无限，故
> $$
> F(s) \geq (1 - p) w(s) + p(w(u, s) + F(u))
> $$
> 且存在 $u$ 使得
> $$
> F(s) = (1 - p) w(s) + p(w(u, s) + F(u))
> $$
> 根据上确界的定义使用 $\epsilon-\delta$ 语言容易证明该结论。
>
> 设 $out_s$ 为任意一个这样的 $u$，则 $out_s$ 存在。从 $s\to out_s$ 连边得到内向基环树，则从每个点出发下一步最优的点是 $out_s$。由此可知从每个点出发的最优路径是沿基环树不断移动，即 $F(s)$ 可由某条从 $s$ 出发的 $\rho$ 形路径取到，否则在第一个不同的位置调整，会导出与 $F$ 值最优性的矛盾。$\square$

> **性质 $2$**
>
> 从 $s$ 出发最优路径的环部分总可以是经过某个点的最大比率环。
>
> **证明**
>
> 考虑从 $s$ 出发沿内向基环树边移动得到的无限长路径 $P_s$。由性质 $1$，$P_s$ 是从 $s$ 出发权值最大的路径，且 $P_s$ 可表示为简单路径 $P'_s$ 接上无穷多个简单环 $Q_s$。
>
> 设 $Q_s$ 的起止点为 $v$，设经过 $v$ 的最大比率环为 $C_v = C_{\max}(v)$。
>
> 根据路径权值的定义可知若 $A$ 长度有限，$B$ 长度任意，则 $w(B) \geq w(B')$ 当且仅当 $w(AB) \geq w(AB')$，所以比较两条路径的权值时，如果它们有一段公共前缀，则将这段前缀去掉不影响大小关系。
>
> 由 $P_s$ 的最优性可知 $w(P'_s Q_s ^ {\infty}) \geq w(P'_s C_v ^ {\infty})$，于是 $w(Q_s ^ {\infty}) \geq w(C_v ^ {\infty})$，即 $r(Q_s) \geq r(C_v)$。但 $C_v$ 是 $v$ 的最大比率环且 $Q_s$ 经过 $v$，所以 $r(C_v) \geq r(Q_s)$。
>
> 因此 $r(C_v) = r(Q_s)$，即 $Q_s$ 是 $v$ 的最大比率环。$\square$

根据性质 $2$ 设计如下算法：

首先预处理 $f(k, u, v)$ 表示从 $u$ 出发恰好走 $k$ 条边的最长路权值，其中 $0\leq k\leq n$。由 $f$ 可以算出经过每个点 $v$ 的最大比率环以及对应比率 $r_v = r_{\max}(v)$。

对每个起点 $s$，枚举 $v$，本质上是在枚举 $n$ 个可能最大比率环之一，再枚举 $s\to v$ 的简单路径长度 $k$，则对应权值为 $q\cdot (f(k, s, v) + p ^ k \cdot r_v)$。因此
$$
ans(s) = q\cdot \max_{v = 1} ^ n \max_{k = 0} ^ {n - 1}  (f(k, s, v) + p ^ k \cdot r_v)
$$
时间复杂度 $O(n ^ 2m)$。

关于维护精确值的问题：本题需要使用高精度分数类维护所有值，导致复杂度多带一个 $n ^ 2$ 因子。由于高精度 $\gcd$ 耗时极其严重，所以无法保证在高精度分数运算过程中及时化简。为减小常数，在预处理 $f$ 时，注意到 $f(k, u, v)$ 的分母一定是 $(s + t) ^ {k + 1}$ 的因数，所以可设 $f'(k, u, v) = f(k, u, v) \cdot (s + t) ^ {k + 1}$，此时计算和维护 $f$ 就只涉及高精度整数类了。仍需一定常数优化才能通过本题，如使用压位高精度，尽可能减少高精度运算等。

代码的前六百行都是高精度板子，且和题解略有出入，如并没有将点权转化为边权，$f$ 是建反图逆推求的。总之就是题目卡常使得代码不太可读。

[高精度板子](https://www.luogu.com.cn/paste/daslqo66)。

```cpp
#include <bits/stdc++.h>
using namespace std;

// 此处省略高精度板子

using BI = bigint;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;
using LL = __int128_t;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;

// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937_64 rnd(1064);
int rd(int l, int r) {
  return rnd() % (r - l + 1) + l;
}


constexpr int mod = 998244353;
void addt(int &x, int y) {
  x += y, x >= mod && (x -= mod);
}
int add(int x, int y) {
  return x += y, x >= mod && (x -= mod), x;
}
int ksm(int a, ll b) {
  int s = 1;
  while(b) {
    if(b & 1) s = 1ll * s * a % mod;
    a = 1ll * a * a % mod, b >>= 1;
  }
  return s;
}

constexpr int Z = 1e5 + 5;
int fc[Z], ifc[Z], inv[Z];
int bin(int n, int m) {
  if(n < m) return 0;
  return 1ll * fc[n] * ifc[m] % mod * ifc[n - m] % mod;
}
void init_fac(int Z) {
  for(int i = fc[0] = 1; i < Z; i++) fc[i] = 1ll * fc[i - 1] * i % mod;
  ifc[Z - 1] = ksm(fc[Z - 1], mod - 2);
  for(int i = Z - 2; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % mod;
  for(int i = 1; i < Z; i++) inv[i] = 1ll * fc[i - 1] * ifc[i] % mod;
}

char buf[1 << 20], *p1 = buf, *p2 = buf;
#define getc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
#define putc(x) putchar(x)
inline int read() {
  int x = 0, sgn = 0; char s = getc();
  while(!isdigit(s)) sgn |= s == '-', s = getc();
  while(isdigit(s)) x = x * 10 + s - '0', s = getc();
  return sgn ? -x : x;
}
inline void print(int x) {if(x >= 10) print(x / 10); putc(x % 10 + '0');}

// ---------- templates above ----------

constexpr int N = 50 + 5;

BI f[N][N], d[N][N][N];
BI gcd(BI a, BI b) {
  if(a == 0) return b;
  if(b == 0) return a;
  // cerr << "gcd " << a << " " << b << endl;
  BI res = 1;
  while(a != b) {
    while(a > 0 && !a.mod2() && b > 0 && !b.mod2()) {
      a = a / 2, b = b / 2, res = res * 2;
    }
    while(a > 0 && !a.mod2()) a = a / 2;
    while(b > 0 && !b.mod2()) b = b / 2;
    if(a == b) break;
    if(a < b) swap(a, b);
    a -= b;
  }
  // cerr << res * a << endl;
  return res * a;
}

struct frac {
  BI a, b;
  void init() {a = BI(0), b = BI(1);}
  frac operator + (const frac &z) const {
    BI y = b * z.b, x = a * z.b + b * z.a;
    return (frac) {x, y};
  }
  frac operator - (const frac &z) const {
    BI y = b * z.b, x = a * z.b - b * z.a;
    return (frac) {x, y};
  }
  frac operator * (const frac &z) const {
    BI y = b * z.b, x = a * z.a;
    return (frac) {x, y};
  }
  frac operator / (const frac &z) const {
    BI y = b * z.a, x = a * z.b;
    return (frac) {x, y};
  }
  bool operator < (const frac &z) const {
    long double lft = a.eval() * z.b.eval(), rt = z.a.eval() * b.eval();
    if(rt) {
      lft = (lft - rt) / abs(rt);
      if(lft < -1e-20) return 1;
      if(lft > 1e-20) return 0;
    }
    return a * z.b < z.a * b;
  }
  bool operator <= (const frac &z) const {
    return a * z.b <= z.a * b;
  }
  bool operator > (const frac &z) const {
    return a * z.b > z.a * b;
  }
  bool operator >= (const frac &z) const {
    return a * z.b > z.a * b;
  }
  void reduce() {
    BI d = gcd(a, b);
    a = a / d, b = b / d;
  }
  void print(string info = "") {
    // cout << "info " << info;
    // cout << a << " " << b << " " << gcd(a, b) << endl;
    reduce();
    if(b == 1) cout << a << endl;
    else cout << a << "/" << b << endl;
  }
} zero, one, cyc[N], pw[N];
frac max(const frac &a, const frac &b) {
  return a < b ? b : a;
}

int n, m, s, t, g, w[N];
vector<pii> e[N];
void calc(int i) {
  cerr << "stt " << i << endl; 
  cyc[i].init();
  for(int j = 0; j < N; j++) {
    for(int k = 0; k < N; k++) {
      f[j][k] = -int(1e6);
    }
  }
  d[i][i][0] = f[0][i] = 0;
  for(int j = 1; j <= n; j++) {
    for(int k = 1; k <= n; k++) {
      if(f[j - 1][k] <= int(-1e6)) continue;
      BI res = f[j - 1][k] + w[k] * s * pw[j - 1].b;
      for(pii _ : e[k]) {
        int it = _.first;
        BI mid = res - _.second * pw[j].b;
        if(f[j - 1][k] <= int(-1e6)) f[j][it] = mid;
        else f[j][it] = max(f[j][it], mid);
      }
    }
    for(int k = 1; k <= n; k++) {
      if(f[j][k] <= int(-1e6)) continue;
      f[j][k] *= t;
      d[k][i][j] = f[j][k];
    }
    if(f[j][i] >= 0) {
      frac tmp;
      tmp.a = f[j][i];
      tmp.b = pw[j + 1].b;
      frac res = tmp / (one - pw[j]);
      cyc[i] = max(cyc[i], res);
    }
  }
}

void solve() {
  cin >> n >> m >> s >> t >> g;
  zero = (frac) {0, 1}, one = (frac) {1, 1};
  pw[0] = (frac) {1, 1}, pw[1] = {t, s + t};
  for(int i = 0; i < N; i++) {
    for(int j = 0; j < N; j++) {
      for(int k = 0; k < N; k++) {
        d[i][j][k] = -int(1e6);
      }
    }
  }
  for(int i = 1; i <= n; i++) cin >> w[i];
  for(int i = 2; i <= n + 2; i++) pw[i] = pw[i - 1] * pw[1];
  for(int i = 1; i <= m; i++) {
    int x, y, z;
    cin >> x >> y >> z;
    e[y].push_back({x, z});
  }
  for(int i = 1; i <= n; i++) calc(i);
  for(int i = 1; i <= n; i++) {
    cerr << i << endl;
    frac ans = {0, 1};
    for(int j = n - 1; ~j; j--) {
      for(int k = 1; k <= n; k++) {
        if(d[i][k][j] <= int(-1e6)) continue; // <= zero -> .a < -1e6
        frac tmp;
        tmp.a = d[i][k][j];
        tmp.b = 1;
        frac tmpc = cyc[k];
        tmpc.a *= pw[j].a * (s + t);
        tmp = tmp + tmpc;
        tmp.b *= pw[j + 1].b;
        ans = max(ans, tmp);
      }
    }
    ans = ans + (frac) {w[i] * s, s + t};
    ans.a *= g;
    ans.print("final ans = ");
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) solve();
  fprintf(stderr, "%d ms\n", int(1e3 * clock() / CLOCKS_PER_SEC));
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---


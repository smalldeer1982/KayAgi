# 「EZEC-11」雪的魔法

## 题目背景

Muxii 是一个雪魔法师。只要他挥起魔法棒，念出神秘的咒语，雪花就会从天而降，在地面上一点一点地积累起厚厚的雪层。正因 Muxii 魔力高超，上帝任命 Muxii 掌管整个世界的雪。

某天，上帝给 Muxii 下达了一个任务：他需要让一个长为 $n$ 的地面上下雪。其中，第 $i$ 个位置的积雪厚度需要达到 $a_i$（$a_i\ge0$，“达到 $a_i$” 指不能低于也不能超过 $a_i$）。然而，上帝不知道的是，Muxii 的能力有限，他每次施法只能让长度 $\le m$ 的区间内下雪 1s，使得这个区间内的积雪厚度增加 $1$。由于任务急迫，Muxii 想要知道，若要完成某些区间的任务，他至少要施法多少次。

## 题目描述

定义初始数列为每个数字都为 $0$ 的数列。

定义一次操作为将数列的一个区间中每一个数的值增加 $1$，规定该区间的长度不能超过 $m$。

给定一个长度为 $n$ 的数列 $a$，第 $i$ 个数为 $a_i$。

你需要回答 $q$ 次询问。每次询问给定 $l,r$，你需要回答将一个长度为 $r-l+1$ 的初始数列变为 $a$ 中的 $[l,r]$（即数列 $a_l$, $a_{l+1}$, $\cdots$, $a_r$）至少需要多少次操作。

## 说明/提示

**「样例 1 说明」**

一个长度为 $5$ 的初始数列为 $0$ $0$ $0$ $0$ $0$。

第一次操作为，将区间 $[1,3]$ 中每一个数，即第 $1$、$2$、$3$ 个数的值分别增加 $1$。经过该操作后，数列变为  $1$ $1$ $1$ $0$ $0$。

第二次操作为，将区间 $[3,5]$ 中每一个数，即第 $3$、$4$、$5$ 个数的值分别增加 $1$。经过该操作后，数列变为  $1$ $1$ $2$ $1$ $1$。

**「数据范围与约定」**

- Subtask 1（1 point）：$m=1$。
- Subtask 2（4 points）：$m=n$。
- Subtask 3（10 points）：$n,q\le300$。
- Subtask 4（10 points）：$n,q\le5\times10^3$。
- Subtask 5（15 points）：$m\le5$。
- Subtask 6（15 points）：$m\le100$。
- Subtask 7（20 points）：$n,q\le5\times10^4$。
- Subtask 8（25 points）：无特殊限制。

对于 $100\%$ 的数据，保证 $1\le m\le n\le10^5$，$1\le q\le10^5$，$0\le a_i\le10^9$，$1\le l\le r\le n$。

## 样例 #1

### 输入

```
5 4 1
1 1 2 1 1
1 5```

### 输出

```
2```

## 样例 #2

### 输入

```
10 3 3
4 8 1 2 9 7 4 1 3 5
1 10
3 8
5 5```

### 输出

```
22
10
9```

# 题解

## 作者：Jelefy (赞：15)

这是一道非常棒的思维题，可以说没有用到任何高深的知识点，却极大地考验了做题人的思维能力和创造性。

在此感谢 @zhoukangyang 神仙提出了本题的主干做法，以及 @Forever_Pursuit 为本题制作数据和转述 zky 的做法。

## 第一步：题意转化

### **做法一：线性规划对偶**

详见 [[ZJOI2020] 序列](https://www.luogu.com.cn/problem/P6631)

这是本题唯一一个可能用到的所谓 “高深知识点”，“可能” 也就意味着本题存在的做法二。

### **做法二：贪心**

为了方便叙述，我们先将题目表述为：

- 我们每次让一个 $≤m$ 长的区间中所有的 $a_i$ 消去 $1$，使得最终所有的 $a_i$ 减为 $0$，求最少的消去次数。

 _容易发现消去的顺序与答案无关，换句话说，不管我们是从左往右消还是从中间开始消，我们只不过是把消的顺序调换了，因此我们从左往右，每次将消去区间的左端点放在左边第一个 $a_i$ 不为 $0$ 的位置，一定有一种方案是最优解。_
 
如此以来，每次消去时左端点的选择已经固定，就是从左往右第一个 $a_i$ 不为 $0$ 的位置。那么，右端点应该如何选择？

 - **先考虑前 $j$ $(j≤m)$ 个位置构成不减序列的情况。**
 
 这种情况下我们只需要直接将前 $m$ 个位置全部消去 $1$ 即可，因为由于这是不减序列，我们贪心地希望每次能够消去的东西尽量多，而在序列一直为不减序列的情况下，消去区间的长度始终为 $m$。相信这一部分读者很好理解。
 
 - **按照这种规律一直消到前 $j'$ $(j'<m)$ 个位置构成不减序列的情况。**
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/8vv6nxme.png)
 
我们发现，在 $a_{j'}$ 和 $a_{j'+1}$ 之间存在一个 gap，这个 gap 必须要 $(a_{j'}-a_{j'+1})$ 次右端点在 $j'$ 的操作才能消去。那么，先消去这个 gap 显然是不劣的。

除此之外，我们需要充分利用这 $(a_{j'}-a_{j'+1})$ 次操作，即使得这几次操作尽量多地消去。否则，如果我们先进行右端点超过 $j'$ 的操作，将会使得 $j'$ 前可消去的部分变少，就可能使得消 gap 操作消去的东西变少了，最终将会导致答案偏大。

因此结论就是：

**我们仍然只需要让前 $j'$ 个位置全部消去 $1$，直到 gap 消失。**



------------


从上述做法，我们知道仅有当 $a_i>a_{i+1}$ 时消去的区间长度小于 $m$。我们又知道，这个 gap 是必然要被消去的，问题只不过是消去的左端点在哪。

**不妨直接将 $(i-m+1)\sim i$ 消去至 gap 消失**。即，令 $k=a_i-a_{i+1}$，我们使 $a[(i-m+1)\sim i]-=k$。

这样操作之后，我们相当于把问题转换为：

 - **至少要多少次操作可以将每一个数字都减到 $≤0$（不必正好等于 $0$）。**

这是为什么呢？

------------

首先，对于一个不减数列，在贪心地消去时，我们不用保证每个位置都被刚好减为 $0$，而是可以减为负数，这样做和原题的答案是相同的，这很显然。

那么，我们从左往右依次考虑每个 gap，第一个 gap 之前是个不减数列。

如果我们提前消去这个 gap，那么这对于右端点在 gap 之前的消去所产生的答案不变。

那么，由于消去的区间长度为 $m$，如果我们提前消去这个 gap，则当右端点移动到（或经过）原 gap 所在位置时，一定满足一个条件：

**该位置前（$m$ 个位置以内）一定是一个不减序列。**

那么，我们就把问题转移到了第二个 gap，此时第二个 gap 之前已经是不减序列，依此类推。

------------

另外，这种做法实际上还有一个问题：

既然我们提前消去，那么最终答案显然也要加上区间内提前消去的次数，并且我们的询问是在提前消去过后的数列上进行。

但是，对于我们询问的区间，在这个区间之后的 gap 提前消去的区间可能覆盖到询问区间内。对于这一部分 gap，如果我们也提前消去，那么将会导致答案不正确，因为这些 gap 根本不在区间内。如何解决这一问题？

事实上，有一个非常聪明和简洁的办法：当我们消到区间内最后 $m$ 个位置时，此时的序列一定是不减的，因此最后 $m$ 个位置的答案就是区间最后一个数的原值。而，不在 gap 内的提前消去最多影响到区间的后 $m$ 个位置。于是，非常凑巧地，我们只需要对提前消去后的数列，求出 $[l,r-m]$ 的答案，再加上 $a[r]$ 的原值以及 $[l,r-1]$ 内所有 gap 的提前消去次数即可。

------------

现在考虑如何求出提前消去之后的数列上某个区间的答案。

假定对于这个数列，我们消去的策略类似，依然是从左到右每次把左端点放在第一个 $a[i]>0$ 的位置上，并且不需要让 $a[i]$ 刚好减为 $0$。那么，可以视为区间长度始终为 $m$。

那么，当左端点移动到 $i$ 时，设 $b[i]$ 为此时的 $a[i]$。那么，$b[i]$ 就是左端点在 $i$ 的消去次数。

使得 $a[i]$ 减为 $b[i]$ 的则是所有距离 $m$ 以内的消去次数，即 $b[(i-m+1)\sim (i-1)]$ 之和。于是我们写出柿子

$$b[i]=\max(0,a[i]-\sum_{j=i-m+1}^{i-1}b[j])$$
 
令

$$S[i]=\sum_{i=1}^ib[i]$$

可得

$$S[i]-S[i-1]=\max(0,a[i]-S[i-1]+S[i-m])$$

即

$$S[i]=\max(a[i]+S[i-m],S[i-1])$$

而所求答案即为 $S[n]$。

**我们发现，这个式子与以下问题等价：**

- **在长为 $n$ 的数列上，每个长度为 $m$ 的区间内最多有一个数字被选中，求最终选中的数字之和的最大值。**

下面考虑如何解决这一等价问题。

## 主干解法 - 分类分治

我们对于原序列分段，每段长度为 $m$，共 $\lceil\frac nm\rceil$ 段。然后，将分段后的序列排成一个矩阵，矩阵的每行为一个整块，即每行 $m$ 个元素，共 $\lceil \frac nm \rceil$ 行。更具体地，记矩阵的第 $i$ 行第 $j$ 列为 $(i,j)$，$(i,j)$ 对应原序列的第 $((i-1)×m+j)$ 个位置。下面进行分类讨论。

- ### Case 1：$m<\sqrt n$

对整个序列进行二分。具体地，在整个序列中间画一条竖线，也就是在整个矩阵的中间位置画一条横线，将整个矩阵从中间截断。对于跨越了这一分界线的询问区间，其必然存在一个跨越该分界线的长度为 $(m−1)$ 的子区间，使得该子区间内没有数被选中。枚举这 $m$ 个子区间，并且对于每个子区间的左端点，利用递推式预处理出其向左到任意点的答案；对于右端点，预处理出其到右边任意点的答案。于是对于跨越该分界线的询问 $[L,R]$，设某个子区间为 $[l,r]$，将左右答案 $[L,l-1]$ 和 $[r+1,R]$ 求和，再对每个子区间对应的答案取 $\max$，就是该询问的答案。从而我们能够 $O(m)$ 算出所有跨越区间中点的询问的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/z1pyn3ov.png)

这样的话我们需要预处理的时间复杂度为 $T(n)=2×T(\frac n2)+O(nm)$，初始状态为 $T(m^2)=O(m^3)$。又因为 $T(n)=2×T(\frac n2)+O(nm)<2×T(\frac n2)+O(n\sqrt n)$，故 $T(n)≈O(n\sqrt n)$。这样的话我们就把问题化归为 $m≥\sqrt n$ 的情况了（因为最后不能求解的区间的长度 $≤m^2$）。

- ### Case 2：$m≥\sqrt n$

下面进行二次分类讨论。

1. **矩阵中存在一整行被询问区间包含，且这一行内没有任何数被选择。**

枚举这一行是哪行，设这一行对应原序列的 $[L,R]$。容易发现这个整段的左右互不影响，答案为 $f_{l,L-1}+f_{R+1,r}$。因此，我们对每两行之间的分界点，向左向右预处理出到任意点的答案。预处理时间复杂度为 $O(n \frac nm)≤O(n\sqrt n)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/je1erlzi.png)

2. **矩阵中任意一个被询问区间包含的行都存在一个数被选择。**

容易发现对于相邻两个被选择的数，它们在矩阵上的位置一定是后一个数在前一个数的右下方向。然后，将所有被选择的数依次连成一条折线。

我们在矩阵中间划一条竖线，它将每行分为长度为 $\lfloor\frac m2\rfloor$, $\lceil\frac m2\rceil$ 的两段，将第 $i$ 行的后一段与第 $(i+1)$ 行的前一段拼接，又能得到若干个长度为 $m$ 的段，我们再次套用 1. 中的解法，相当于解决了折线越过我们所划的竖线的情况。

接下来需要解决折线不越过竖线的情况，那么如果在折线一边选了数，另一边就不能选数，在解决竖线一侧的问题时，另一侧的数完全无用。

若将一侧的元素顺次拼接，得到一个长度为原来的一半的序列，并认为 $m$ 也随着矩阵宽度变化为原来的一半，解决一侧的问题相当于解决规模更小的原问题。

于是我们得到了两个规模更小的与原问题题意一致的子问题，$n,m$ 均为原来的一半。**若一个询问的最优解选择的第一个数与 $l$ 或选择的最后一个数与 $r$ 不在竖线的一侧，这种情况在之前套用 1. 中算法的时候已经计算过了，不需要递归，因此每个询问至多只会被递归到一个子问题中。**

![](https://cdn.luogu.com.cn/upload/image_hosting/xwt9bdec.png)

## 时间复杂度分析

预处理时间复杂度为 $T(n)=O(n\sqrt n)+2T(\frac n2)$，$T(n)=O(n\sqrt n)$。

每次询问时间复杂度为 $T(n)=O(\sqrt n)+T(n/2)$，$T(n)=O(\sqrt n)$。

总时间复杂度为 $O((n+q)\sqrt n)$。

至此，我们在 $O((n+q) \sqrt n)$ 的时间复杂度内解决了本题，**采用离线整体二分的做法做到 $O(n)$ 空间复杂度，即可通过本题。**


---

## 作者：Falashiro (赞：13)

通过线性规划对偶，我们将原问题转化为：

给 $[l,r]$ 中每一个位置一个权值 $w_i$，使得所有长度不超过 $m$ 的区间的 $w_i$ 之和不超过 $1$，最大化 $\sum\limits_{i=l}^ra_iw_i$。

容易发现最优解中 $w_i$ 的值不会小于 $-1$。

题目进一步转化为：在 $[l,r]$ 中选若干个数求和，若两个相邻的被选择的数 $a_x,a_y(x<y)$ 满足 $y-x<m$，则需要在区间 $(x,y)$ 中选择一个数减去，最大化最终得到的值。

容易得到一个时间复杂度为 $O(nq)$ 的做法：

```
int n,m,q,a[N];
ll f[N],dp[N];
signed main(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	while(q--){
		int l=read(),r=read();
		ll w=0;
		f[l-1]=0;
		for(int i=l;i<=r;i++){
			if(i>=l+m)w=max(w,dp[i-m]);
			w=max(w,f[i-1]-a[i]),dp[i]=w+a[i],f[i]=max(f[i-1],dp[i]);
		}
		printf("%lld\n",f[r]);
	}
	return 0;
}
```

代码中 $dp_i$ 表示选择的最后一个数是 $a_i$ 的最优答案，$f_i$ 表示 $[l,i]$ 这段区间的最优答案。

我们对于原序列分段，每段长度为 $m$，共 $\lceil\frac{n}{m}\rceil$ 段，若 $m>\sqrt n$，段数为 $O(\sqrt n)$，对于每一段的左/右端点，我们向右/左跑一遍上面的 dp，预处理出每个端点开始的 $f$，这里的时间复杂度为 $O(n\sqrt n)$。

以下 Case 均在初始 $m>\sqrt n$ 的情况下讨论。

Case1：在最优解中，存在相邻两个被选择的数之间的距离小于 $m$ 且不在同一个段中或存在相邻两个被选择的数不在相邻的两个段中。

与预处理 $f$ 类似的，预处理 $g$，$g_i$ 表示从端点开始到 $i$，开头先减去一个数或不选前 $m-1$ 个数的最优答案。枚举每个整段，设当前段为 $[L_1,R_1]$，下一段为 $[L_2,R_2]$，若在 $[L_1,R_1]$ 中没有数被选择，则答案被包含在 $g_{R_1,l}+f_{L_2,r}$ 中，即答案不大于 $g_{R_1,l}+f_{L_2,r}$，若存在相邻的两个被选择的数分别在 $[L_1,R_1]$ 和 $[L_2,R_2]$ 中，则答案为 $\max\{f_{R_1,l}+g_{L_2,r},g_{R_1,l}+f_{L_2,r}\}$，这一部分的时间复杂度为 $O((n+q)\sqrt n)$。

Case2：

我们将分段后的序列排成一个矩阵，矩阵的每行为一个整块，即每行 $m$ 个元素，共 $\lceil\frac{n}{m}\rceil$ 行，记矩阵的第 $i$ 行第 $j$ 列为 $(i,j)$，$(i,j)$ 对应原序列的第 $(i-1)\times m+j$ 个位置，我们认为 $(1,1)$ 处于矩阵的左上角。

若最优答案不在 Case1 中，那么对于相邻两个被选择的数，它们在矩阵上的位置一定是后一个数在前一个数的右下方向，每行至少有一个数被选择，将所有被选择的数依次连成一条折线。

Case2.1：$\lceil\frac{n}{m}\rceil<m$。

我们在矩阵中间划一条竖线，它将每行分为长度为 $\lfloor\frac{m}{2}\rfloor,\lceil\frac{m}{2}\rceil$ 的两段，将第 $i$ 行的后一段与第 $i+1$ 行的前一段拼接，又能得到若干个长度为 $m$ 的段，我们再次套用 Case1 的解法，相当于解决了折线越过我们所划的竖线的情况。

接下来需要解决折线不越过竖线的情况，那么如果在折线一边选了数，另一边就不能选数，在解决竖线一侧的问题时，另一侧的数完全无用，可以认为是 $n$ 变为了原来的一半，此时 $m$ 是否变为原来的一半没有影响。

若将一侧的元素顺次拼接，得到一个长度为原来的一半的序列，并认为 $m$ 也随着矩阵宽度变化为原来的一半，解决一侧的问题相当于解决规模更小的原问题。

于是我们得到了两个规模更小的与原问题题意一致的子问题，$n,m$ 均为原来的一半。若一个询问的最优解选择的第一个数与 $l$ 或选择的最后一个数与 $r$ 不在竖线的一侧，这种情况在之前套用 Case1 算法的时候已经计算过了，不需要递归，因此每个询问至多只会被递归到一个子问题中。

这一部分的时间复杂度为 Case1 的时间复杂度，即为 $O((n+q)\sqrt n)$。

Case2.2：$m\le\lceil\frac{n}{m}\rceil$。

我们取出矩阵中间的一行，这一行中至少有一个数被选择，枚举这一行的每个位置，钦定一个位置被选择，若一个询问的区间与这一行有交，那么就能计算出这个询问的答案。

与 Case2.1 类似，我们得到了两个规模更小的与原问题题意一致的子问题，$n$ 为原来的一半，而 $m$ 不变。显然每个询问至多只会被递归到一个子问题中。

这一部分的时间复杂度为 $O((n+q)m)$，由于 $m\le\lceil\frac{n}{m}\rceil$，时间复杂度为 $O((n+q)\sqrt n)$。

注意：只有 Case2.1 的算法与 Case2.2 的算法交替使用才能得到正确的时间复杂度。

对于整个算法：

预处理部分复杂度为 $T(n)=O(n\sqrt n)+2T(\frac{n}{2})$，$T(n)=O(n\sqrt n)$。

此外对于每次询问产生的复杂度为 $T(n)=O(\sqrt n)+T(\frac{n}{2})$，$T(n)=O(\sqrt n)$。

总时间复杂度为 $O((n+q)\sqrt n)$。

若在一开始 $m\le\sqrt n$，我们略微修改 Case2.2 的算法，在序列中间设置一个断点，枚举与断点距离小于 $m$ 的 $2m-1$ 个位置，钦定一个位置被选择，显然这些数不可能都不被选择，否则一定可以找到更优解。这样就可以通过多次递归使得 $m$ 变为 $\sqrt n$ 级别。注意这里并不需要保证相邻两个被选择的数在矩阵上的位置一定是后一个数在前一个数的右下方向，仅仅是通过这个算法缩小 $n$ 的规模。

这一部分的时间复杂度为 $T(n)=O(nm)+2T(\frac{n}{2})$，当 $m>\sqrt n$ 时，递归停止，所以其中 $O(nm)$ 不超过 $O(n\sqrt n)$，$T(n)=O(n\sqrt n)$。询问部分的复杂度分析与之前询问部分的复杂度分析同理。

至此，我们在 $O((n+q)\sqrt n)$ 的时间复杂度内解决了本题，实现精细即可做到 $O(n+q)$ 空间复杂度。

另：通过一些操作可以把问题转化为每个长度为 $m$ 的区间最多选择一个数，求选择的数的和的最大值。这个问题也可以使用上面的算法解决，常数较小。

---

## 作者：251Sec (赞：3)

线性规划对偶，变成给每个位置赋 $-1,0,1$ 权，使得任意长度 $\le m$ 区间和 $\le 1$，然后最大化带权和。这个限制换句话说，就是任意距离 $< m$ 的相邻 $1$ 之间要有恰好一个 $-1$。

把序列在相邻且距离 $\ge m$ 的 $1$ 处劈开，则劈出来每一段里去掉 $0$ 之后都是 $1,-1$ 交替的形式。通过手玩，或者直接注意到这就是 $n=m$ 的情况，我们发现这样的一段的最大权值是 $a_1+\sum_{i \ge 2}\max(0,a_i-a_{i-1})$。

考虑这样劈出来的段长啥样：最优解里，第一段一定以序列开头为开头，最后一段一定以序列结尾为结尾，剩下的每相邻两段距离一定恰好是 $m$。把所有除了第一段以外的的左端点取出来，则一个左端点的贡献可以推出来是 $b_i=a_i-\sum_{j=0}^{m-1}\max(0,a_{i-j}-a_{i-j-1})$。

问题变为：在 $[l+m,r]$ 选取若干个点，每个点有点权 $b$，选的任意两个点距离至少为 $m$，最大化点权和。容易写出 DP，$f(i)$ 从 $f(i-m)$ 和 $f(i-1)$ 转移过来，复杂度 $O(nq)$。

考虑建一张图，$i$ 向 $(i+1)$ 和 $(i+m)$ 连边，则它应该几乎是一张网格图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rhge7hre.png)

（图片来自 P9040 洛谷题解）我们要在这样的图上多次询问两点最长路。这是可以分治做的。

具体地，我们每次选择网格较长的一边劈开，然后对于分界线上每个点，处理经过它的最短路。因为较短的边长是根号的，主定理一下可以发现总复杂度 $O((n+q) \sqrt n)$。注意这里除了网格边以外还有 $(2,3)$ 这样的斜着的边，这只会在我们第一次对行分治时有贡献，特殊处理一下即可。

---


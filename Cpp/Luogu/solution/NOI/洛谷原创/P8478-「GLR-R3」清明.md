# 「GLR-R3」清明

## 题目背景

&emsp;&emsp;「&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;」

---

&emsp;&emsp;“你非说这不是我的实力，那凭什么一个偶然错音就不能毁了我的命运？！”

&emsp;&emsp;天依没有注意到，心中所哭嚎向的那个人，同她一样撑着伞，身后十来步而已。

---

&emsp;&emsp;**清明**　「你在名为弱小的深渊　究竟看见过什么」

## 题目描述

雨打在窗沿，下坠，一级一级。

这里一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。假设在某一瞬间，第 $i$ 级窗沿上有 $a_i$ 单位体积的雨水。由于奇妙的物理原因，第 $i$ 级的雨水将在「下一个瞬间」滴向第 $i+1,i+2,\dots,\min\{i+k,n\}$ 级，也可能留在第 $i$ 级，但是每一种去向的雨水的单位体积都应是非负整数，且总和为 $a_i$。

设在「下一个瞬间」，第 $i$ 级窗沿上有 $a_i'$ 单位的雨水，那么称此时雨水的**奇妙度**为 $\prod_{i=1}^n a_i'$。现在，悲伤的人儿想知道，对于所有**本质不同的**「下一个瞬间」，雨水的奇妙度之和对素数 $P=998244353$ 取模的结果。

两个「下一个瞬间」本质不同，当且仅当存在编号 $i<j$ 的两级窗沿，从窗沿 $i$ 滴向窗沿 $j$ 的雨水的单位体积不同。

## 说明/提示

#### 样例 #1 解释

容易发现总共只有一种本质不同的「下一个瞬间」，也就是每级窗沿都没有雨水向其他窗沿滴落。

所以最终 $a'=\{2,2,2\}$，权值为 $8$。

#### 样例 #2 解释

设 $c_k$ 表示从第 $k$ 级窗沿滴向第 $k+1$ 级窗沿的雨点体积，显然有 $c_3=0$。

枚举所有合法的滴落情况：

- $c=\{0,0,0\},b=\{2,2,2\}$，权值为 $8$；
- $c=\{0,1,0\},b=\{2,1,3\}$，权值为 $6$；
- $c=\{0,2,0\},b=\{2,0,4\}$，权值为 $0$；
- $c=\{1,0,0\},b=\{1,3,2\}$，权值为 $6$；
- $c=\{1,1,0\},b=\{1,2,3\}$，权值为 $6$；
- $c=\{1,2,0\},b=\{1,1,4\}$，权值为 $4$；
- $c_1=2$，此时必然有 $b_1=0$，此情况下的三种方案权值均为 $0$；

所以所有本质不同的「下一个瞬间」的权值和为 $8+6+0+6+6+4+0+0+0=30$。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

对于 $100\%$ 的数据，$0\le k<n\le 32$，$0\le a_i<P$。

对于不同的子任务，作如下约定：

| 子任务编号 |   $n$   |   $k$   | $\max a_i$ | 子任务分值 |
| :--------: | :-----: | :-----: | :--------: | :--: |
|    $1$     | $\le32$ |  $<n$   |    $=0$    | $2$  |
|    $2$     | $\le32$ |  $=0$   |    $<P$    | $2$  |
|    $3$     | $\le32$ |  $<n$   |    $=1$    | $3$  |
|    $4$     | $\le5$  |  $<n$   |   $\le4$   | $20$ |
|    $5$     | $\le32$ |  $=1$   |    $<P$    | $13$ |
|    $6$     | $\le32$ | $=n-1$  |    $<P$    | $10$ |
|    $7$     | $\le32$ | $\le16$ |    $<P$    | $20$ |
|    $8$     | $\le25$ |  $<n$   |    $<P$    | $10$ |
|    $9$     | $\le32$ |  $<n$   |    $<P$    | $20$ |


## 样例 #1

### 输入

```
3 0
2 2 2```

### 输出

```
8```

## 样例 #2

### 输入

```
3 1
2 2 2```

### 输出

```
30```

## 样例 #3

### 输入

```
5 3
2 3 4 4 3```

### 输出

```
275200```

# 题解

## 作者：Vsinger_洛天依 (赞：24)

## P8478 「GLR-R3」清明

参考了[出题人题解](https://www.luogu.com.cn/article/4agpym8e)和 [xcyyyyyy 大神的题解](https://www.luogu.com.cn/article/yxt2uyzc)，强推前两篇。

拿到题完全没思路怎么办？？？

人类智慧的巅峰，思维量的登峰造极。

换句话说就是非人题目，不过不得不说 GLR 的题是真的好，难度也是真的高。

首先我们需要看懂题面，这是第一个难点。

题面大意如下：

>对于一个雨滴，它可以向任意编号小于等于 $\min\{i+k,n\}$ 的台阶上移动，而其对应的一部分容量也会在移动后修改至其移动后的台阶。
>
>同时雨滴体积不会莫名其妙减少或者增多。
>
>而在「下一个瞬间」其对应的奇妙度为 $\prod\limits_{i=1}^{n}a_i'$。
>
>求所有本质不同的「下一个瞬间」的奇妙度总和。

考虑从数据范围入手。

- Subtask 5

    对于 $k=1$，在此情况下每个台阶上的雨滴最多只会向下移动一个台阶。

    我们定义 $c_i$ 为第 $i$ 个台阶向下一阶流动的雨水容量。

    那么我们就可以知道 $a_i'=a_i+c_{i-1}-c_i$。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/jvq4vrxt.png)

    可以发现 $ans=\sum\limits_{c}\prod\limits_{i=1}^{n}(a_i+c_{i-1}-c_i)$。

    考虑多项式展开，对于内部的 $a_i+c_{i-1}-c_i$ 我们直接划分为两部分：$a-c_i$ 和 $c_{i-1}$。

    此时我们推广到积就会得到很多项 $a-c_i$ 和 $c_{i-1}$ 的和，我们再引入一个子集 $S\subseteq\{1,2,3,\cdots,n\}$。

    每个 $i\in S$ 代表在 $a_i-c_i$ 中选取，否则代表在 $c_{i-1}$ 中选取。

    那么我们也就发现 $\prod\limits_{i=1}^{n}(a_i+c_{i-1}-c_i)=\sum\limits_{S\subseteq \{1,2,\cdots,n\}}\prod\limits_{i\in S} (a_i-c_{i})\prod\limits_{i\not\in S}c_{i-1}$。

    整体式子也就得到了 $ans=\sum\limits_{c}\sum\limits_{S\subseteq \{1,2,\cdots,n\}}\prod\limits_{i\in S} (a_i-c_{i})\prod\limits_{i\not\in S}c_{i-1}$。

    我们考虑去掉外层的 $\sum\limits_{c}$，策略就是把下标 $c_i$ 相同的一批都合成到一起。
    
    当 $i<n$ 时，考虑 $i$ 和 $i-1$ ，定义 $f_{i,1}$ 为包含 $i$ 的所有 $S$ 的乘积之和，$f_{i,1}$ 为不包含 $i$ 的所有 $S$ 的乘积之和，我们就可以分成 $4$ 个情况来转移。

    - $i - 1 \in S, i \in S$ 

        贡献是 $\sum\limits_{0\le c_i \le a_i}(a_i-c_i)=\frac{a_i(a_i+1)}{2}$。

    - $i - 1 \not \in S, i \in S$

        贡献是 $\sum\limits_{0\le c_i \le a_i} 1 = a_i+1$。

    - $i - 1 \in S, i \not \in S$

        贡献是 $\sum\limits_{0\le c_i \le a_i}(a_i-c_i)c_i = \frac{a_i^2(a_i+1)}{2}-\frac{a_i(a_i+1)(2a_i+1)}{6} = \frac{(a_i-1)a_i(a_i+1)}{6}$。

    - $i - 1 \not \in S, i \not \in S$

        贡献是 $\sum\limits_{0\le c_i \le a_i}c_i=\frac{a_i(a_i+1)}{2}$。

    那么我们就可以直接递推的从 $f_{i-1,0/1}$ 向 $f_{i,0/1}$ 转移。

    这样我们就终于完成了拿到了 13 pts，复杂度 $O(n)$。

- Subtask 6

    考虑从 Sub5 进行推广， $c_i \to c_{i,j}$ 代表第 $i$ 个台阶到第 $i+j$ 个台阶流动的量，然后就能拿到一个能拆的式子。

    $$
    \sum_{c}\prod_{i=1}^{n}\left(\sum_{j=0}^{\min(i-1,k)}c_{i-j,j}\right)
    $$

    然后再推好像就好点，我们继续展开。

    依然是先把 $\sum\limits_c$ 置之不理。

    我们设对于所有 $c_{i,j}$ 的出现下标构成的集合为 $S_i$，那么可以得到这样一个式子。
    
    $$
    \prod_{i=1}^n\prod_{j\in S_i}c_{i,j}
    $$

    考虑外层 $\sum_{c}$ 的影响，显然第一维不同的 $c$ 之间互不影响。

    先将外层乘积 $\prod_{i=1}^{n}$ 展开为若干 $n$ 次单项式的和，针对每个单项式，我们考虑 $c_{i,j}$ 的约束即 $\sum_j c_{i,j} = a_i$。

    利用乘法分配律，分别对每个 $i$ 维度的 $c_{i,j}$ 进行求和，最终我们可以收拢成一个和式。

    $$
    \prod_{i=1}^n\sum_{c_i}\left[\sum_{j}c_{i,j}=a_i\right]\prod_{j\in S_i}c_{i,j}
    $$

    这好像不是很好做啊，那我们可以构建一个组合意义来简化题面。

    我们用 $r_i$ 表示对于任意合法的 $j$，$c_{i,j}$ 中有 $r_i$ 个变量可以取到非 $0$ 值，也就是说 $r_i=\min(n-i,k)+1$。

    那么我们就可以建立这样的模型：

    >有编号为 $0,1,2,\dots,r_i-1$ 的 $r_i$ 个盒子。
    >
    >其中编号落在属于 $S_i$ 的盒子，放了 $x$ 个球会贡献 $x$。
    >
    >而其它盒子无论放多少个球，贡献都是 $1$。
    >
    >一种方案的贡献为各个盒子的贡献的积。
    >
    >求往 $r_i$ 个盒子中任意放 $a_i$ 个没有任何区别的球的贡献之和。

    虽然还是不好做，但是起码可以构建生成函数了不是吗？

    我们可以发现我们并不关心 $S_i$ 具体是多少，我们只关心 $|S_i|$。

    我们构造生成函数来实现，对于编号在 $S_i$ 中的盒子，这些盒子的特点是放 $x$ 个球的贡献是 $x$，生成函数为 $\frac{x}{(1-x)^2}$，将球放进盒子时，贡献会随着球的数目成比例增加。
    
    剩下的盒子，这些盒子的特点是不论放多少球，贡献始终为 $1$，因此其生成函数为 $\frac{1}{1-x}$，球的数目对贡献无影响，但我们仍然允许球被放进去。
    
    将这些生成函数组合在一起，让 $|S_i| = s_i$，那么总生成函数为：

    $$
    G(x) = \left( \frac{x}{(1 - x)^2} \right)^{s_i} \cdot \left( \frac{1}{1 - x} \right)^{r_i - s_i}
    $$

    简化得到：

    $$
    G(x) = \frac{x^{s_i}}{(1 - x)^{s_i + r_i}}
    $$

    为了求往 $r_i$ 个盒子中放入 $a_i$ 个球的贡献，我们需要找到生成函数 $G(x)$ 中 $x^{a_i}$ 的系数：

    $$
     [x^{a_i}] G(x) = [x^{a_i}] \frac{x^{s_i}}{(1 - x)^{s_i + r_i}}
    $$

    这等价于：

    $$
     [x^{a_i - s_i}] \frac{1}{(1 - x)^{s_i + r_i}}
    $$

    对 $\frac{1}{(1-x)^{s_i + r_i}}$ 展开，得到：

    $$
    \frac{1}{(1-x)^{s_i + r_i}} = \sum_{n=0} \binom{n + s_i + r_i - 1}{s_i + r_i - 1} x^n
    $$

    将这一展开式代入 $G(x)$ 中：

    $$
    \begin{aligned}
    G(x) &= x^{s_i} \sum_{n=0} \binom{n + s_i + r_i - 1}{s_i + r_i - 1} x^n\\
    &= \sum_{n=0} \binom{n + s_i + r_i - 1}{s_i + r_i - 1} x^{n + s_i}
    \end{aligned}
    $$

    为了找到 $x^{a_i}$ 项，需要满足 $n + s_i = a_i$，可以得知 $n = a_i - s_i$。

    代入可以得到 $x^{a_i}$ 项的系数为：

    $$
    \binom{(a_i - s_i) + s_i + r_i - 1}{s_i + r_i - 1} = \binom{a_i + r_i - 1}{s_i + r_i - 1}
    $$

    可以发现结果只受到 $S_i$ 的影响，上面已经提到了，我们考虑 $s_i$ 是怎么来的。

    可以发现每个 $i$ 会向集合 $\max\{i-k,1\} \le j \le i$ 的某个盒子 $j$ 恰好贡献 $S_j$。
    
    因此每个 $i$ 在对应区间内，只会贡献一次。

    每个 $i$ 的贡献可以由多个位置 $j \in (i,i+k)$ 贡献，可以反过来理解：
    
    实际上每个 $s_i$ 可以从 $\{i, i+1, \dots, i+r_i-1\}$ 这些位置中任选一个贡献。

    进行 $dp$ 即可，设 $f_{i,j}$ 表示在后缀 $i$ 中有 $j$ 个位置没有贡献过 $s$ 的权值和。
    
    转移就枚举一下 $s$ 然后组合数计算，复杂度 $O(n^3)$

- Subtask 7

    拓展 Subtask 6 中的处理方法，考虑状压。
    
    设 $f_{i,S}$，用 $i$ 表示当前后缀，用 $S$ 表示 $i,i+1,i+2,\dots,\min(i+k,n)$ 是否已经都贡献过 $s$，复杂度 $O(n\cdot 3^k)$ 是过不去的。

    那咋办？注意到 $i$ 的贡献只和 $S$ 中新增的已经贡献过的位置个数有关，并且能贡献到 $S$ 的前驱状态 $T$ 得满足 $T\subseteq S$，因此我们可以直接做高维前缀和，同时记录一下新增个数即可。

    复杂度 $O(n\cdot k^2\cdot 2^k)$，可以通过 Subtask 7。

- Subtask 8

    直接莽 $O(n\cdot k^2\cdot 2^k)$！欸过不去，考虑优化。

    发扬人类智慧，我们发现在 $k$ 较大的时候只有较少的台阶会超出限制，大多数问题集中在一部分位置

    我们如果在 $k$ 和 $k+1$ 处对前后分成两部分的话，枚举后半段位置是否被前半段占用，从而使得前后的贡献分开计算。这样每一段的内部贡献就独立了

    因为前半段的贡献不会超出限制，因此每个内部后缀都可以贡献，问题转化为类似 Subtask 6 的形式

    考虑动态规划， $f_{i,j,S}$ 表示一下含义：

    - $i$: 从后缀 $i$ 开始。
    - $j$: 在区间 $[i, k]$ 中，尚未被占用的位置数。
    - $S$: 表示区间 $(k, n]$ 中的位置占用情况。

    然后根据前半段和后半段的不同情况分别处理。

    我们对前半段的 $j$ 做类似 Sub6 的转移，对 $S$ 做类似 Sub7 的转移。

    对于后半段，我们枚举 $S$ 来做类似 Sub6 的转移。

    复杂度为 $O(n\cdot k^2\cdot \sqrt k\cdot 2^k)$。

- Subtask 9

    Sub8 的做法又过不去了？

    我们引入**容斥思想**来优化 Sub8 的做法，为了优化算法，我们枚举后半段 $(k+1,n]$ 中的位置是否被超出限制占用。

    我们用状态 $f_{i,j}$ 来表示后缀 $i$ 中有 $j$ 个位置是可选的但未被占用

    在状态转移时，从 $f_{i+1}$ 转移到 $f_i$ 时，不仅要考虑位置 $i$ 是否被加入，还需要考虑位置 $i+k+1$ 是否被加入，和 Sub6 类似，但需要结合对后段的枚举。

    这样我们就解决了 Sub9，复杂度 $O(n^2\cdot k\cdot 2^{n-k})$。

现在我们解决了所有的 Subtask，我们将 Sub6，Sub7 和 Sub9 进行结合即可通过本题。

---

## 作者：crashed (赞：12)

# 题目

## 题目描述

雨打在窗沿，下坠，一级一级。

这里一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。假设在某一瞬间，第 $i$ 级窗沿上有 $a_i$ 单位体积的雨水。由于奇妙的物理原因，第 $i$ 级的雨水将在下一个瞬间滴向第 $i+1,i+2,\dots,\min\{i+k,n\}$ 级，也可能留在第 $i$ 级，但是每一种去向的雨水的单位体积都应是非负整数，且总和为 $a_i$。

设在「下一个瞬间」，第 $i$ 级窗沿上有 $a_i'$ 单位的雨水，那么称此时雨水的**奇妙度**为 $\prod_{i=1}^n a_i'$。现在，悲伤的人儿想知道，对于所有**本质不同的**「下一个瞬间」，雨水的奇妙度之和对素数 $P=998244353$ 取模的结果。

两个「下一个瞬间」本质不同，当且仅当存在编号 $i<j$ 的两级窗沿，从窗沿 $i$ 滴向窗沿 $j$ 的雨水的单位体积不同。

## 数据范围

对于 $100\%$ 的数据，满足 $0\le k<n\le 32,0\le a_i<P$。

# 分析

## Subtask 1,2,3

想必就不用我多说了吧

## Subtask 4

可以直接搜索每个窗沿到其它窗沿的雨滴数量。

复杂度看实现，不过肯定是能过的。

## Subtask 5

这个部分分还是蛮重要的。

我们考虑将题目提到的方法扩展一下。设 $c_k$ 为窗沿 $k$ 滴到窗沿 $k+1$ 的雨滴数，为了方便我们也同样定义 $c_0=c_n=0$。不难发现答案的式子如下：

$$
\sum_{\{c\}}\prod_{k=1}^n(a_k-c_k+c_{k-1})
$$

考虑**直接拆开和式**。我们形式地写为：

$$
\sum_{\{c\}}\sum_{S}[S\subseteq\{1,2,3,\dots,n\}] \prod_{k\in S}(a_k-c_k)\prod_{k\not\in S} c_{k-1}
$$

我们可以尝试将同一下标的 $c$ 合在一起写，这样我们就可以**收起外层 $\sum_{\{c\}}$**，使得贡献独立。举个例子，当 $k<n$ 时，我们考虑 $k,k+1$ 的存在情况：

- $k\not\in S,k+1\in S$，此时贡献为 $\sum_{0\le c\le a_k}1=a_k+1$；
- $k\in S,k+1\in S$，此时贡献为 $\sum_{0\le c\le a_k}a_k-c=\frac 1 2a_k(a_k+1)$；
- $k\not\in S,k+1\not \in S$，此时贡献为 $\sum_{0\le c\le a_k}c=\frac 1 2 a_k(a_k+1)$；
- $k\in S,k+1\not \in S$，此时贡献为 $\sum_{0\le c\le a_k}(a_k-c)c=\frac 1 6(a_k+1)a_k(a_k-1)$；

不难发现此时某一个 $k$ 的贡献仅仅和 $k-1$ 是否在 $S$ 中相关，因此设计一个 $f_{i,0/1}$ 进行转移即可。

时间复杂度为 $O(n)$。

## Subtask 6

类似于 Subtask 5 的处理，设 $c_{i,j}$ 为窗沿 $i$ 滴到窗沿 $i+j$ 的雨滴数；特别地，认为 $c_{i,0}$ 表示窗沿 $i$ 留下未滴落的雨滴数量。同样为了方便，我们认为 $i+j>n$ 的时候 $c_{i,j}=0$。因此有如下和式：

$$
\sum_{\{c\}}\prod_{i=1}^{n}\left(\sum_{j=0}^{\min\{i-1,k\}}c_{i-j,j}\right)
$$

同样的处理方法，**我们把外层 $\prod$ 展开，得到若干个 $n$ 次单项式的和；再处理单个的 $n$ 次单项式，从而将 $\sum_{\{c\}}$ 利用乘法分配律收拢，加速运算**。

不妨考虑这样一个 $n$ 次单项式：设 $S_i$ 为式子中 $c_{i,*}$ 的出现下标，也即，这个乘积式为：
$$
\prod_{i=1}^n\prod_{j\in S_i}c_{i,j}
$$
那么，考虑外层 $\sum_{\{c\}}$ 的影响。由于 $c$ 的限制为 $\forall 1\le i\le n,\sum_jc_{i,j}=a_i$，所以**第一维不同的 $c$ 之间互不影响**。利用乘法分配律，我们可以将和式写成：
$$
\prod_{i=1}^n\sum_{\{c_i\}}\left[\sum_{j}c_{i,j}=a_i\right]\prod_{j\in S_i}c_{i,j}
$$
接下来，尝试收拢内层的和式套乘积式。不妨设 $r_i$ 表示 $c_{i,*}$ 中有 $r_i$ 个变量可以取到非 $0$ 的值，也即 $r_i=\min\{n-i,k\}+1$。则，我们可以构造组合意义：

> 有 $r_i$ 个盒子，编号为 $0,1,2,\dots,r_i-1$。其中编号落在 $S_i$ 中的盒子，放了 $x$ 个球会贡献 $x$；而其它盒子无论放多少个球，贡献都是 $1$。一种方案的贡献为各个盒子的贡献的积。求往 $r_i$ 个盒子中任意放 $a_i$ 个没有区别的球的贡献之和。

事实上，我们发现答案和 $S_i$ 没有关系，而只和 $|S_i|$ 有关。另一方面，我们容易构造出生成函数来描述这个问题：编号在 $S_i$ 中的盒子，生成函数为 $\frac{x}{(1-x)^2}$；剩下的盒子，生成函数为 $\frac{1}{1-x}$。如果令 $|S_i|=s_i$，则可以得到后面的和式结果为：
$$
[x^{a_i}]\left(\frac{x}{(1-x)^2}\right)^{s_i}\frac{1}{(1-x)^{r_i-s_i}}=\binom{a_i+r_i-1}{s_i+r_i-1}
$$

再来看如何将巨大的乘积式拆分成若干个单项式。由于答案计算的过程中，只有 $s_i$ 会受到拆分方式的影响，因此我们考虑 $s_i$ 是怎么来的：乘积中，每个 $i$ **向 $\max\{i-k,1\}\le j\le i$ 中的恰好一个 $j$ 贡献 $s_j$**。反过来，每个 $i$ 的 $s_i$ 可以从 $i,i+1,i+2,\dots,i+r_i-1$ 这些位置中取，且一个位置不能贡献两次 $s$。以下，如果一个位置已经贡献过一次 $s$，我们就称它为**被占用**。

所以，现在可以解决 Subtask 6。此时每个 $i$ 的指数可以由 $i,i+1,i+2,\dots,n$ 贡献到，因此只需要设计 $f_{i,j}$ 表示后缀 $i$ 中还剩 $j$ 个位置未被占用的权值和。转移只需要枚举一下 $s$，用组合数计算即可。

时间复杂度可以做到 $O(n^3)$。

## Subtask 7

进一步拓展 Subtask 6 中的处理方法，我们压一个状态 $f_{i,S}$，用 $i$ 表示当前后缀，用 $S$ 表示 $i,i+1,i+2,\dots,\min\{i+k,n\}$ 各自是否被占用。

如果实现不恰当，复杂度会到 $O(n3^k)$，无法通过这个子任务。但是注意到 $i$ 的贡献只和 $S$ 中新增的被占用位置个数有关，并且能贡献到 $S$ 的前驱状态 $T$ 得满足 $T\subseteq S$，因此我们可以直接做**高维前缀和**，同时记录一下新增个数即可。

时间复杂度可以做到 $O(nk^22^k)$。

------

这个部分分还可以进行容斥。我们要求所有的位置最终必须被占用，对**被占用时是否在有效的 $[i,i+k]$ 范围内**进行容斥。则设状态 $f_{i,S,j}$，用 $S$ 表示钦定了 $[i,i+k]$ 中哪些位置**必须超出限制**，用 $j$ 表示可选（包括没有被限制和钦定超出限制占用且已经超出限制的位置）但尚未被占用的位置个数。转移可以做到 $O(n^32^k)$。

## Subtask 8

此时直接莽 $O(nk^22^k)$ 肯定不行。注意当 $k$ 比较大的时候，**只有较少的位置有可能会超出限制**，因此我们可以在 $k$ 和 $k+1$ 中间切一刀，分成前后两段。我们可以尝试枚举后半段位置是否被前半段占用，**前后贡献就分开了**。并且，前后内部贡献不存在超出限制的情况，我们可以直接看作是“内部的一个后缀都可以贡献”，因而直接转化到了 Subtask 6 的情况。

实现时，可以设状态 $f_{i,j,S}$，用 $i$ 标识后缀，用 $j$ 表示 $[i,k]$ 中有多少位置尚未被占用，用 $S$ 表示 $(k,n]$ 中位置的占用情况。转移相当于同时对 $j$ 做 Subtask 6、对 $S$ 做 Subtask 7 的转移，可以做到 $O(nk^32^{n-k})$。而后半部分的内部贡献可以枚举 $S$，并做一个类似于 Subtask 6 的转移（只需注意不要将钦定被前半段占用的位置加入）即可做到 $O(nk^22^{n-k})$。

两侧平衡一下复杂度，理论上总的时间复杂度最小可以为 $O(nk^{2.5}2^{\frac n 2})$。~~但是，考虑到 $k$ 是整数，因此很难取到这个最优结果~~。

## Subtask 9

~~其实想到了容斥方法基本就解决本题了。~~

同样考虑的是，$k$ 较大的时候较少的位置才有可能超出限制。因此，我们对于 $(k+1,n]$ 中的位置，枚举它们是否被超出限制占用。剩下的，可以用 $f_{i,j}$ 表示后缀 $i$ 中有 $j$ 个可选但未被占用的位置。从 $f_{i+1}$ 过来时，需要同时考虑 $i$ 是否被加入和 $i+k+1$ 是否被加入；话虽如此，转移本身仍然类似于 Subtask 6，复杂度可以做到 $O(n^2k2^{n-k})$。

结合 Subtask 7 的算法和 Subtask 9 的算法即可得到 $O(nk^22^{\frac n 2})$ 的算法。

# 代码

```cpp
#include <cstdio>

#define rep( i, a, b ) for( int i = (a) ; i <= (b) ; i ++ )
#define per( i, a, b ) for( int i = (a) ; i >= (b) ; i -- )

const int mod = 998244353;
const int MAXN = 100;

template<typename _T>
void read( _T &x ) {
    x = 0; char s = getchar(); bool f = false;
    while( s < '0' || '9' < s ) { f = s == '-', s = getchar(); }
    while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
    if( f ) x = -x;
}

template<typename _T>
void write( _T x ) {
    if( x < 0 ) putchar( '-' ), x = -x;
    if( 9 < x ) write( x / 10 );
    putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b ) {
    return a < b ? a : b;
}

int C[MAXN][MAXN];

int A[MAXN], coe[MAXN][MAXN];
int inv[MAXN];

int N, K;

inline int Qkpow( int, int );
inline int Mul( int x, int v ) { return 1ll * x * v % mod; }
inline int Inv( const int a ) { return Qkpow( a, mod - 2 ); }
inline int Sub( int x, int v ) { return ( x -= v ) < 0 ? x + mod : x; }
inline int Add( int x, int v ) { return ( x += v ) >= mod ? x - mod : x; }

inline int Qkpow( int base, int indx ) {
    int ret = 1;
    while( indx ) {
        if( indx & 1 ) ret = Mul( ret, base );
        base = Mul( base, base ), indx >>= 1;
    }
    return ret;
}

void Init( const int k ) {
    inv[1] = 1; rep( i, 2, k << 1 ) inv[i] = Mul( inv[mod % i], mod - mod / i );
    rep( i, 0, k ) {
        C[i][0] = C[i][i] = 1;
        rep( j, 1, i - 1 ) C[i][j] = Add( C[i - 1][j], C[i - 1][j - 1] );
    }
}

int Binom( const int x, const int r ) {
    if( x < r ) { return 0; } int ret = 1;
    rep( i, 1, r ) ret = Mul( ret, Mul( ( x - i + 1 ) % mod, inv[i] ) );
    return ret;
}

int Query( const int j, const int k, const int n ) {
    if( n < k ) return 0;
    return Binom( n + j - 1, j + k - 1 );
}

namespace SmallK {
    const int MAXS = ( 1 << 16 ) + 5;

    int f[MAXS], g[MAXS][MAXN];

    void Solve() {
        if( K == 0 ) {
            int ans = 1;
            rep( i, 1, N ) ans = Mul( ans, A[i] );
            write( ans ), putchar( '\n' );
            return ;
        }

        f[0] = coe[N][0], f[1] = coe[N][1];
        per( i, N - 1, 1 ) {
            int lim = MIN( N - i + 1, K + 1 );
            rep( j, 0, ( 1 << lim ) - 1 ) rep( k, 0, lim ) g[j][k] = 0;
            rep( j, 0, ( 1 << ( lim - 1 ) ) - 1 ) g[j][0] = f[j], f[j] = 0;
            rep( j, 0, lim - 1 ) 
                per( k, ( 1 << lim ) - 1, 0 )
                    if( ! ( k >> j & 1 ) ) per( t, lim - 1, 0 )
                        g[k | ( 1 << j )][t + 1] = Add( g[k | ( 1 << j )][t + 1], g[k][t] );
            if( i <= N - K ) {
                rep( k, 0, ( 1 << lim ) - 1 )
                    if( k & 1 ) rep( t, 0, lim )
                        f[k >> 1] = Add( f[k >> 1], Mul( g[k][t], coe[i][t] ) );
            } else {
                rep( k, 0, ( 1 << lim ) - 1 )
                    rep( t, 0, lim ) f[k] = Add( f[k], Mul( g[k][t], coe[i][t] ) );
            }
        }
        write( f[( 1 << K ) - 1] ), putchar( '\n' );
    }
}

namespace LargeK {
    int f[MAXN];
    
    void Solve() {
        int rest = N - K - 1, ans = 0, lim, tmp, shft = 0;
        for( unsigned S = 0 ; S < ( 1u << rest ) ; S ++ ) {
            f[0] = 1, lim = 0;
            per( i, N, 1 ) {
                shft = 0;
                if( i > K + 1 ) shft += ! ( S >> ( i - K - 2 ) & 1 );
                else shft ++;
                if( i + K < N ) shft += S >> ( i - 1 ) & 1;

                if( shft ) {
                    per( j, lim, 0 ) f[j + shft] = f[j];
                    rep( j, 0, shft - 1 ) f[j] = 0;
                    lim += shft;
                }

                rep( j, 0, lim ) {
                    tmp = 0;
                    for( int t = 0 ; t <= K + 1 && t + j <= lim ; t ++ )
                        tmp = Add( tmp, Mul( f[j + t], Mul( C[j + t][t], coe[i][t] ) ) );
                    f[j] = tmp;
                }
            }
            ans = __builtin_popcount( S ) & 1 ? Sub( ans, f[0] ) : Add( ans, f[0] );
        }
        write( ans ), putchar( '\n' );
    }
}

int main() {
    read( N ), read( K );
    Init( K + 1 );
    rep( i, 1, N ) {
        read( A[i] );
        int lim = MIN( N - i + 1, K + 1 );
        rep( j, 0, lim ) coe[i][j] = Query( lim, j, A[i] );
    }
    if( K < N / 2 )
        SmallK :: Solve();
    else
        LargeK :: Solve();
    return 0;
}
```

---

## 作者：ningago (赞：11)

一个 $m+1\geq \dfrac{n}{2}$ 时的 poly 复杂度做法。

首先拆贡献：

$$\sum_v\prod_{i}a'_i=\sum_v\prod_{i}\sum_{j=i-m}^i v_{j\to i}=\sum_v\sum_{fa_i\in[i-m,i]}\prod_i v_{fa_i\to i}$$

也就是先给每个点钦定一个父亲然后求乘积，这个值显然只和每个点的儿子个数有关：

令点 $i$ 的权值为 $v$，假设有 $deg$ 个儿子，$[i,\min(n,i+m)]$ 一共有 $lim$ 个点。需要计算的就是 $deg$ 个儿子算入乘积，剩下 $lim-deg$ 不算入乘积的权值之和：

$$[x^v](\dfrac{x}{(1-x)^2})^{deg}\cdot (\dfrac{1}{1-x})^{lim-deg}=[x^{v-deg}]\dfrac{1}{(1-x)^{lim+deg}}=\dbinom{v+lim-1}{lim+deg-1}$$

由于 $a_i$ 比较大但 $n$ 比较小，可以 $O(n)$ 地暴力计算组合数。故可以在 $O(n^3)$ 的复杂度内预处理该权值，记其为 $val_{i,deg}$。现在计算的就是：

$$\sum_{fa_i\in[i-m,i]}\prod_i {val_{i,deg_i}}$$

那么在 $m$ 比较小的时候，显然可以状压 DP，直接枚举子集的复杂度为 $O(n3^m)$，用子集卷积可以做到 $O(nm^22^m)$，在本题的数据范围下没有必要。

当 $m+1\geq \dfrac{n}{2}$ 时，考虑把 $0\sim m$ 放在第一行，$m+1\sim n$ 放在第二行。每个点的 $fa$ 的取值就是它同行前面的点，或者上一行后面的点。

考虑从后往前按列进行一个 DP：$dp_{i,x,y,z}$ 表示考虑了 $[i,m]$ 这些列；第一个有 $x$ 个选择同行匹配，且还未匹配的；第二个有 $y$ 个选择同行匹配，且还未匹配的；钦定 $[0,i)$ 中有 $z$ 个异行匹配的；其权值之和。按第一行和第二行分开转移：

第一行即枚举同行的儿子个数 $p$，异行的儿子个数 $q$，系数为 $val_{i,p+q}\cdot \dbinom{x}{p}\cdot \dbinom{z+q}{q}$。

第二行枚举同行的儿子个数 $p$，系数为 $val_{i,p}\cdot\dbinom{y}{p}$。

分讨一下 $i$ 这个点的匹配情况，这是简单的。

复杂度看着是 $O(m^6)$ 的，但实际转移数是非常少的，在本题的数据范围下最多只跑了 $16ms$。

```cpp
#define N 40
int n, m;
int a[N], inv[200];
int val[N][N];
int C(int n, int m)
{
	int res = 1;
	for(int i = n; i >= n - m + 1; i--) mul_(res, i % mod);
	for(int i = 1; i <= m; i++) mul_(res, inv[i]);
	return res;
}

namespace Sub1
{
int dp[2][1 << 16], pp[1 << 16], op;
int tmp[N];
void solve()
{
	// debug("Sub1\n");
	dp[op = 0][0] = 1;
	for(int i = 0; i < (1 << m); i++) pp[i] = pp[i >> 1] + (i & 1);
	for(int i = n - 1; ~i; i--)
	{
		op ^= 1;
		for(int S = 0; S < (1 << m); S++) if(dp[op ^ 1][S])
		{
			int v = dp[op ^ 1][S]; dp[op ^ 1][S] = 0;
			for(int j = 0; j <= std::min(m + 1, n - i); j++) tmp[j] = 1ll * v * val[i][j] % mod;
			int U = S, X = 0;
			if(S >> (m - 1) & 1)
				U ^= 1 << (m - 1), X ^= 1 << (m - 1);
			for(int _T = U, T; ; _T = (_T - 1) & U)
			{
				T = _T | X;
				plus_(dp[op][(S ^ T) << 1 | 1], tmp[pp[T]]);
				plus_(dp[op][(S ^ T) << 1], tmp[pp[T] + 1]);
				if(!_T) break;
			}
		}
	}
	print(dp[op][0], '\n');
}
}

namespace Sub2
{
int dp[2][N][N][N], op;
int C[N][N];
void solve()
{
	// debug("Sub2\n");
	for(int i = 0; i < N; i++) for(int j = C[i][0] = C[i][i] = 1; j < i; j++)
		C[i][j] = sm(C[i - 1][j - 1] + C[i - 1][j]);
	dp[op][0][0][0] = 1;
	for(int i = m; i >= 0; i--)
	{
		if(i + m + 1 < n)
		{
			op ^= 1;
			for(int x = 0; x <= m - i; x++) for(int y = 0; y <= m - i; y++) for(int z = 0; z <= i + 1; z++) if(dp[op ^ 1][x][y][z])
			{
				int v = dp[op ^ 1][x][y][z]; dp[op ^ 1][x][y][z] = 0;	
				for(int p = 0; p <= y; p++)
				{
					// 连自环
					plus_(dp[op][x][y - p][z], 1ll * v * val[i + m + 1][p + 1] % mod * C[y][p] % mod);
					// 向前连
					plus_(dp[op][x][y - p + 1][z], 1ll * v * val[i + m + 1][p] % mod * C[y][p] % mod);
					// 向上连
					if(z) plus_(dp[op][x][y - p][z - 1], 1ll * v * val[i + m + 1][p] % mod * C[y][p] % mod);
				}
			}	
		}
		if(i < n)
		{
			op ^= 1;
			for(int x = 0; x <= m - i; x++) for(int y = 0; y <= m - i + 1; y++) for(int z = 0; z <= i + 1; z++) if(dp[op ^ 1][x][y][z])
			{
				int v = dp[op ^ 1][x][y][z]; dp[op ^ 1][x][y][z] = 0;	
				for(int p = 0; p <= x; p++) for(int q = 0; z + q <= m; q++)
				{
					// 连自环
					plus_(dp[op][x - p][y][z + q], 1ll * v * val[i][p + q + 1] % mod * C[x][p] % mod * C[z + q][q] % mod);
					// 向前连
					plus_(dp[op][x - p + 1][y][z + q], 1ll * v * val[i][p + q] % mod * C[x][p] % mod * C[z + q][q] % mod);
				}
			}
		}
	}
	print(dp[op][0][0][0], '\n');
}
} // namespace Sub2


void solve()
{
	// memset(h, idx = -1, sizeof(h));
	n = read(), m = read();
	for(int i = 0; i < n; i++) a[i] = read();
	for(int i = 0; i < n; i++) 
	{
		int lim = std::min(m + 1, n - i);
		for(int j = 0; j <= lim; j++) val[i][j] = C(a[i] + lim - 1, lim + j - 1);
	}
	if(m + m + 2 < n) Sub1::solve();
	else Sub2::solve();
}
```

---

## 作者：Vsinger_洛天依 (赞：4)

这篇题解主要讲一下 Sub5。

注意特殊性质，可以发现 $k =1$，也就是说雨滴现在只能像他自己和其下一格台阶转移。

因此有一个很自然的想法：定义一个 $c_i$ 表示第 $i$ 格被转移来的雨滴量。

那么就可以很轻易的得出转移后的 $a_i'=a_i+c_i-c_{i+1}$，我们需要计算的是 $\sum\limits_{\text{所有可能的} c_i}\prod\limits_{i=1}^na_i'$。

我们现在把这个 $a_i'$ 拆成 $(a_i-c_{i+1})$ 和 $c_i$ 两部分，那么我们求的就转化成了 $\sum\limits_{\text{所有可能的} c_i}\prod\limits_{i=1}^n(a_i-c_{i+1})+c_i$。

考虑使用乘法分配律进行和式展开，对于 $n$ 个台阶，共有 $2^n$ 种展开方式，对应于所有 $\{1,2,\dots,n\}$ 的子集 $S$。

对于 $i\in S$，选择 $(a_i- c_i) $；对于 $i \notin S$，选择 $c_{i-1}$。

原表达式可以展开为：

$$
\text{ans} = \sum_{\{c_i\}} \sum_{S \subseteq \{1,2,\dots,n\}} \left( \prod_{i \in S} (a_i - c_i) \prod_{i \notin S} c_{i-1} \right)
$$

为了方便计算，我们先固定 $ S $，然后对 $ c_i $ 求和

$$
\text{ans} = \sum_{S \subseteq \{1,2,\dots,n\}} \sum_{\{c_i\}} \left( \prod_{i \in S} (a_i - c_i) \prod_{i \notin S} c_{i-1} \right)
$$

考虑相邻台阶 $ i-1 $ 和 $ i $ 的状态和如何影响当前台阶的贡献。

每个台阶有两种状态，分别定义为 $1$ 和 $0$：

- **状态 $1$**：台阶 $ i $ 在子集 $ S $ 中（即 $ i \in S $）
- **状态 $0$**：台阶 $ i $ 不在子集 $ S $ 中（即 $ i \notin S $）

这样，对于相邻的台阶 $ i-1 $ 和 $ i $ 有四种状态组合：

- **状态 $(1,1)$**：$ i-1 \in S $，$ i \in S $
- **状态 $(0,1)$**：$ i-1 \notin S $，$ i \in S $
- **状态 $(1,0)$**：$ i-1 \in S $，$ i \notin S $
- **状态 $(0,0)$**：$ i-1 \notin S $，$ i \notin S $

定义 $f_{i,1}$ 为包含 $i$ 的所有 $S$ 的乘积之和，$f_{i,1}$ 为不包含 $i$ 的所有 $S$ 的乘积之和，此时去找前面的状态。

- **状态 $(1,1)$**

	在这种情况下，第 $ i-1 $ 个台阶对应 $ (a_{i-1} - c_{i-1})$，第 $i$ 个台阶对应 $(a_i-c_i)$。
    
   由于 $ c_{i-1} $ 和 $ c_i $ 是独立的变量，我们可以分别对它们求和。

	- 对于 $ c_{i-1} $：
		$\sum_{c_{i-1}=0}^{a_{i-1}} (a_{i-1} - c_{i-1}) = \frac{a_{i-1}(a_{i-1} + 1)}{2}$
	- 对于 $ c_i $：
  	$\sum_{c_i=0}^{a_i} (a_i - c_i) = \frac{a_i(a_i + 1)}{2}$
	
    总体贡献就是 $\frac{a_i(a_i + 1)}{2}$。
 
- 状态$(1,0)$：

  在这种情况下，第 $ i-1 $ 个台阶对应 $ (a_{i-1} - c_{i-1})$，第 $i$ 个台阶对应 $c_{i-1}$。

  - 对于 $ c_{i-1} $：

    我们需要计算：

    $$
    \sum_{c_{i-1}=0}^{a_{i-1}} (a_{i-1} - c_{i-1}) c_{i-1}
    $$

    化简一下得到。

    $$
    a_{i-1} \sum_{c_{i-1}=0}^{a_{i-1}} c_{i-1} - \sum_{c_{i-1}=0}^{a_{i-1}} c_{i-1}^2
    $$

    把这两个 $\sum$ 拆开，总和为：

    $$
    a_{i-1} \cdot \frac{a_{i-1}(a_{i-1} + 1)}{2} - \frac{a_{i-1}(a_{i-1} + 1)(2a_{i-1} + 1)}{6}
    $$

    化简得到：$\frac{(a_{i-1} - 1)a_{i-1}(a_{i-1} + 1)}{6}$。

- 状态 $(0,1)$

  在这种情况下，第 $ i-1 $ 个台阶对于了 $c_{i-2}$，第 $ i $ 个台阶对应 $(a_i - c_i)$。

  注意到 $ c_{i-2} $ 与 $ c_i $ 独立，我们需要对 $ c_{i-1} $ 和 $ c_i $ 求和。

  - $ c_{i-1} $ 来自于前一状态 $ f_{i-1,0} $，其值为：$f_{i-1,0} \times \sum_{c_{i-1}=0}^{a_{i-1}} c_{i-1}$。

  - 对于 $ c_i $：$\sum_{c_i=0}^{a_i} (a_i - c_i) = \frac{a_i(a_i + 1)}{2}$。

  - 总贡献：$\left( \sum_{c_{i-1}=0}^{a_{i-1}} c_{i-1} \right) \times \frac{a_i(a_i + 1)}{2}$。

  为了简化计算，我们可以考虑 $ c_{i-1} $ 的期望值：$\sum_{c_{i-1}=0}^{a_{i-1}}c_{i-1}=\frac{a_{i-1}(a_{i-1}+1)}{2}$。

- 状态 $(0,0)$

  在这种情况下，第 $ i-1 $ 个台阶对于了 $c_{i-2}$，第 $ i $ 个台阶对应 $c_1$。

  - 对于 $ c_{i-1} $：$\sum_{c_{i-1}=0}^{a_{i-1}} c_{i-1} = \frac{a_{i-1}(a_{i-1} + 1)}{2}$。

最后答案是 $f_{n,1} + f_{n,0}$。

---

## 作者：xcyyyyyy (赞：3)

有史以来做的思维量结合量最大的题。

给出的代码中实现了 `Subtask6,7,9`。

参考了出题人题解，这里强推：`https://www.luogu.com.cn/article/4agpym8e`。

### Subtask5(k=1)

考虑设 $c_i$ 表示第 $i$ 个窗沿给下一个窗沿的雨水量，同时定 $c_n=0$，那么答案就是：

$$
\sum \limits_{c}\prod_{i=1}^n (a_i-c_i+c_{i+1})
$$

**展开和式：**

$$
\sum \limits_{c} \sum \limits_{S \subseteq \{1,2,...,n\}} \prod \limits_{i\in S}(a_i-c_i)\prod_{i \not\in S}c_{i+1}
$$

**此时我们从左往右定  $c_i$ 的值，$f_{i,1}$ 表示包含了 $i$ 的所有 $S$ 的乘积的和，$f_{i,0}$ 表示不包含 $i$ 的所有 $S$ 的乘积的和，来看一看所有情况的转移式：**

* $ i-1 \in S,i \not\in S$，贡献是 $\sum \limits_{0 \leq c_i \leq a_i}1=a_i+1$
* $i-1 \not\in S,i \not\in S$，贡献是 $\sum \limits_{0\leq c_i \leq a_i}c_{i}=\frac{a_i(a_i+1)}{2}$
* $i-1 \not\in S,i \in S$，贡献是 $ \sum \limits_{0\leq c_i \leq a_i}(a_i-c_i)c_i=\frac{a_i^2(a_{i}+1)}{2}-\frac{a_i (a_i+1)(2a_i+1)}{6}=\frac{(a_i-1)a_i(a_i+1)}{6}$
* $i-1 \in S,i \in S$，贡献是 $\sum\limits_{0 \leq c_i \leq a_i}(a_i -c_i)=\frac{a_i(a_i+1)}{2}$

有了以上推导的贡献，我们就可以对应的从 $f_{i-1,0/1}\rightarrow f_{i,0/1}$ 了，时间复杂度 $O(n)$。

到这里我已经觉得非常妙了，甚至可以单独出一道题。不过别急，还有更高级的在后面。

### Subtask6(k=n-1)

为了方便，我们不妨设 $c_{i,j}$ 表示从第 $i$ 个窗沿到第 $i+j$ 个窗沿的雨水量。特别的，$c_{i,0}$ 表示留下来的雨水数量。那么答案就是：

$$
\sum\limits_c \prod \limits_{i=1}^n(\sum\limits_{j=0}^{\min (i-1,k)}c_{i-j,j})
$$

这一步更妙，**在 `Subtask5` 中的展开中，我们将 $c_i$ 所造成的贡献集中在一起**。我们此时也可以这样做，但是一步不好想通顺。**不妨设 $S_k$ 表示在上面的 $\sum \limits_j$ 中选择了 $i-j=k$ 的 $j$ 的集合**，同时将 $c$ 合法的条件加上，那么原式就可以表示为($S_i$ 合法条件未标出)：

$$
\sum \limits_c \prod \limits _{i=1}^n[c_{i,j}=a_i]\sum \limits_{j \in S_i}c_{i,j}
$$

接下来我们来看如何抽丝剥茧地解决这个问题：

同样利用 `dp` 转移，但是这里 $c,S$ 都有条件，$c_{i,j}$ 的条件是和为定值，$S_i$ 我们可以看作是 $j$ 可以给 $i=j,j-1,...,\max(1,j-k)$ 中的一个 $S_i$ 贡献 $1	$，不妨将这个分配的过程看作 $i$ 从 $i,i+1,...,\min(n,i+k)$ 中取贡献，同时每个数只能被取一次，由于 $k=n-1$，我们从 $n$ 到 $1$ `dp`，记录该后缀中有多少个没有被选。

同时我们发现式子中 $S_i$ 的贡献只和他的大小有关系，转移的时候不妨枚举 $|S_i|$，然后算方案数。

设当前有 $r_i=\min(n-i,k)+1$ 个 $c_{i,j} $ 可以取非 $0$，我们首先定好 $S_i$ 具体为哪些下标，这是一个组合数的形式，然后我们不妨用这样一个模型来描述这个问题：

> 有 $r_i$ 个盒子，其中有 $|S_i| $ 个已经确定的盒子，放了 $x$ 个球会贡献 $x$(我们称作第一种盒子)，其他盒子无论放了几个球贡献都是 $1$(我们称作第二种盒子)，一个方案的贡献各个盒子的贡献的积，求往这 $r_i$ 个盒子中放 $a_i$ 个没有区别的球的贡献之和。

不妨用生成函数表示每一个盒子，第一种盒子的生成函数是 $\sum \limits_{i=0} ix^i=\frac{x}{(1-x)^2}$，第二种是 $\sum \limits _ix_i=\frac{1}{1-x}$，那么结果为 $[x^{a_i}](\frac{x}{(1-x)^2})^{|S_i|}\frac{1}{(1-x)^{r_i-|S_i|}}=[x^{a_i}]\frac{x^{|S_i|}}{(1-x)^{r_i+|S_i|}}$，不妨用组合意义：将 $a_i-|S_i|$ 个无差别球分到 $r_i+|S_i|$ 个可空盒子里的方案数，那么方案就是 $\binom{a_i+r_i-1}{|S_i|+r_i-1}$，注意到这个组合数可以预处理。

那么我们就可以做到 $O(n^3)$ 的时间复杂度了。

### Subtask7(k $\leq$ 16)

此时一定是要状态压缩了，设 $f_{i,s}$ 表示 $i,i+1,i+2,...,\min(i+k,n)$ 是否被使用，直接实现是 $O(n3^k)$，无法通过。

我们考虑到转移时能转移到 $S$ 的 $T$ 必须满足 $T \subseteq S$，而贡献只和集合大小有关，我们不妨设 $g_{i,j,S}$ 表示 $\sum \limits_{T\subseteq S,|T|=j}f_{i,T}$，即做高维前缀和。用 $g$ 辅助转移即可。

时间复杂度 $O(nk^22^k)$ 了。

### Subtask9

$k$ 较大的时候，可能会超出贡献区间限制的很少，所以我们考虑容斥 $[k+1,n]$ 里面的下标贡献 $1$ 的时候是否贡献到了 $[1,i-k)$ 的位置，剩下的我们不管他们贡献到哪里。

我们用 `Subtask6 ` 的做法，但是如何保证一个下标一定贡献到了 $[1,i-k)$ 之外的区间呢？只需要在 $i-k-1$ 的时候把他放到 `dp` 的第二维即可。此时时间复杂度是 $O(n^32^{n-k})$。

与 `Subtask7` 做法结合可以做到 $O(n^32^{\frac{n}{2}})$ 的优秀时间复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 998244353
#define ll long long
#define pc(x) __builtin_popcount(x)
ll inv[100],C[100][100],coe[100][100];
inline ll Binom(int n,int m){
    ll ans=1;
    for(int i=n-m+1;i<=n;i++)ans=ans*i%p;
    for(int i=1;i<=m;i++)ans=ans*inv[i]%p;
    return ans;
}
void init(){
    inv[0]=inv[1]=1;for(int i=2;i<=90;i++)inv[i]=inv[p%i]*(p-p/i)%p;
    for(int i=0;i<=90;i++){C[i][0]=1;for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;}
}

int n,k;
int a[40];
namespace Subtask6{
    ll f[40][40];
    void solve(){
        f[n+1][0]=1;
        for(int i=n;i;i--)
            for(int j=0;j<=n-i+1;j++)
                for(int k=max(j-1,0);k<=n-i;k++)
                    (f[i][j]+=f[i+1][k]*C[k+1][j]%p*coe[i][k+1-j]%p)%=p;
        printf("%lld\n",f[1][0]);
    }
}
namespace Subtask7{
    ll f[40][1<<18],g[20][1<<18];
    void solve(){
        f[n+1][(1<<k+1)-1]=1;
        for(int i=n;i;i--){
            for(int ss=0;ss<1<<k;ss++)for(int K=0;K<=k;K++){int s=(ss|1<<k);g[K][s]=0;}
            for(int ss=0;ss<1<<k;ss++){int s=(ss|1<<k);g[pc(s)][s]=f[i+1][s];}
            for(int K=0;K<=k;K++)for(int j=0;j<k;j++)for(int s=0;s<1<<k;s++)if(s>>j&1)(g[K][s|(1<<k)]+=g[K][s^(1<<j)|(1<<k)])%=p;
            for(int ss=0;ss<1<<k;ss++){
                int s=(ss|(1<<k));
                for(int j=0;j<=pc(s);j++)//枚举 t 的位数
                    (f[i][s]+=g[j+1][(s>>1)|(1<<k)]*coe[i][pc(s)-j]%p)%=p;
            }
        }
        printf("%lld",f[1][(1<<k+1)-1]);
    }
}
namespace Subtask9{
    int f[40][40];
    void solve(){
        ll ans=0;
        for(int s=0;s<1<<(n-k-1);s++){//1 必须超出
            memset(f,0,sizeof(f));
            f[n+1][0]=1;int lim=0;
            for(int i=n;i;i--){
                int t=0;
                if(i>k+1)t+=!(s>>(i-k-2)&1);
                else ++t;
                if(i+k<n)t+=(s>>(i-1)&1);
                for(int j=0;j<=lim+t;j++)
                    for(int k=max(0,j-t);k<=lim;k++)
                        (f[i][j]+=f[i+1][k]*C[k+t][j]%p*coe[i][k+t-j]%p)%=p;
                lim+=t;
            }
            if(pc(s)&1)(ans+=p-f[1][0])%=p;
            else (ans+=f[1][0])%=p;
        }
        printf("%lld\n",ans);
    }
}
int main(){
    init();
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        int r=min(n-i,k)+1;
        for(int j=0;j<=min(r,a[i]);j++)coe[i][j]=Binom(a[i]+r-1,j+r-1);
    }
    if(k==0){
        ll ans=1;
        for(int i=1;i<=n;i++)ans=ans*a[i]%p;
        return printf("%lld",ans),0;
    }
    else if(k==n-1)Subtask6::solve();
    else if(k<=n/2)Subtask7::solve();
    else Subtask9::solve();
}
```

---

## 作者：Felix72 (赞：2)

貌似前几篇题解在复读出题人题解，我尝试写一个不那么复读的版本。

设 $c_{i, j}$ 表示 $i$ 给到 $j$ 的水量（$i > j$ 或者 $i, j \notin [1, n]$ 等边界情况统一视作 $0$），则所求的东西写作：

$$
\sum_{\{c\}} \prod_{j = 1}^{n} \sum_{i = \min(1, j - m)}^j c_{i, j}
$$

把后面的 $\prod\sum$ 用乘法分配律拆了，变成

$$
\sum_{\{c\}} \sum_{\{s\}} \prod_{j = 1}^{n} c_{s_j, j}
$$

这是对于每个 $j$ 枚举其“水源”，不能很好的契合 $\forall i,\sum c_{i, j} = a_i$ 的限制。于是转而考虑对于 $i$，其向哪些位置贡献了水量。即对于上述式子，不用 $j$ 的视角求，而是用 $s_j$ 的视角求。所求变为：

$$
\sum_{\{c\}} \sum_{\{S\}} \prod_{i = 1}^{n} \prod_{j \in S_i} c_{i, j}
$$

其中 $S_i$ 是一个集合，对 $\{S\}$ 的限制为对于 $i \neq j$，$S_i \cap S_j$ 为空集，且所有 $S_i$ 的并为全集，以及 $\sum_{x \in S_i} c_{i, x} = a_i$。

那么既然已经枚举 $i$ 了，那么在最外层枚举 $c$ 就很没有必要，完全可以先枚举 $i$，再想办法计算所有满足和为 $a_i$ 的 $\{c_i\}$ 的贡献。

设 $f_{i, mask}$ 表示考虑到 $i$ 位置，$S_1$ 到 $S_i$ 的并为 $mask$，对于所有可能的 $c_1, c_2, \dots, c_i$，式子的贡献和。转移形如这样：

$f_{i, mask} \times Function(i + 1, ex) \to f_{i + 1, mask \cup ex}$

这个 $Function$ 的值只和 $i + 1$ 和 $|ex|$ 有关系。设 $i + 1$ 能给 $M$ 个位置贡献水量，则我们要做的就是挑选 $|ex|$ 个位置，计算 $c_{i, x}$ 的乘积。先不考虑 ${M} \choose {ex}$ 这个系数，即钦定挑选的是前 $|ex|$ 个位置。则这个问题有组合意义如下：

> 有 $a_i$ 个小球，用 $M - 1$ 个挡板隔开，再在前 $|ex|$ 组里各选一个代表球，求方案数。

我们可以先用 $M - 1 + |ex|$ 个挡板隔开，再把第 $1, 3, 5, \dots$ 个小球变成代表球。式子写作 ${a_i + M - 1} \choose {|ex| + M - 1}$。

预处理出 $Function$，则可以 $O(n3^n)$ 求解。还可以更进一步，因为一个 $i$ 的可贡献范围是有限的，所以只记录这个范围内的 $mask$ 就行了，复杂度 $O(n3^m)$。

$3$ 为底比较慢，思考更快的转移。因为转移核心是 $mask \to mask \cup ex$，所以思考高维前缀和。但是直接前缀和是不行的，因为系数和 $|ex|$ 有关系。但是我们知道，$|ex| = |mask \cup ex| - |mask|$，因此对于每个 $|mask|$，把对应的 $mask$ 拿出来跑高维前缀和，就能确定系数了。复杂度 $O(n^32^m)$。

但这样还有问题，$m > \frac{n}{2}$ 复杂度就比较大了。然而复杂度确实很难再降低了，因此考虑设计一个复杂度与 $n - m$ 相关性更强的算法，然后对数据分治。

我们知道，对于前 $m + 1$ 个元素，所有元素都能贡献到它们（除非本身在他们后面）。于是把整个序列视为两部分，一部分是前 $m + 1$ 个元素（称第一部分），另一部分是 $n - m - 1$ 个元素（称第二部分）。

把 $f$ 的定义略作修改，其所记录值的意义不变，但把状态改为 $f_{i, j, mask'}$，表示考虑到第 $i$ 个元素，设 $mask$ 为 $S_1$ 到 $S_i$ 的并，$mask$ 在第一部分有 $j$ 个元素，在第二部分为 $mask'$ 时的式子值。我们之所以能把第一部分直接记作 $\operatorname{popcount}$ 值，正是因为所有元素 $x$ 都能在 $S_x$ 里选择他们。

那么依旧对 $mask'$ 这一维做高维前缀和，并枚举 $k$，使得 $mask'' = mask' \cup ex$，$j' = j + k$。这 $f_{i + 1, j', mask''}$ 就是我们的转移目标。

系数当然有 $Function(i + 1, |ex| + k)$，但是还没完，我们不知道 $k$ 个元素到底选在哪里了，也就是说这里还缺一个组合数。我们可以先乘上 ${j + k} \choose k$，表示所选元素的相对位置。然后 $i \to i + 1$ 的时候，$i$ 必须已经包含在某个 $S_x$ 里，所以让所有的 $j \to j - 1$ 即可。

对所有不同的 $|mask'|$ 做高位前缀和：$O((n - m)^22^{n - m})$；

枚举 $k$：$O(m)$；

枚举 $i$：$O(n)$。

全乘起来，好像是四次方？其实不然，因为 $mask'$ 的量级与 $i$ 有关，$i$ 变大 $1$ 时 $mask$ 乘 $2$，而且很多地方跑不满，所以复杂度上界约为 $O(n^32^{n - m})$，实际上更快。结合上面的 $O(n^32^m)$ 就可以了。

---

## 作者：TallBanana (赞：2)

题面：[「GLR-R3」清明](https://www.luogu.com.cn/problem/P8478)

首先，我们发现，假如已经确定了每个窗沿流向其他位置的雨滴数量，那么我们就可以求出贡献。不妨设 $c_{i,j}$ 表示 $i$ 号窗沿流向 $i+j$ 号窗沿的雨滴量。若 $j=0$ 则表示是留在 $i$ 号窗沿的雨滴数量。那么我们答案可以写成

$$\sum_c\prod_{i=1}^n\sum_{j=0}^{j\le k,1\le i-j}c_{i-j,j}$$

即对于所有的 $c$ 数组，把 $a'_i$ 拆成 $c$ 的和。

考虑把上述式子利用乘法分配律展开，那么我们每次会相当于在每个和式里面选出一个项乘出去。于是我们记每次 $c_i$ 选到的 $c_{i,j}$ 的 $j$ 的集合为 $S_i$。

那么我们将这个式子展开：

$$\sum_c\sum_S\prod_{i=1}^n\prod_{j\in S_i}c_{i,j}$$

由于 $c_i$ 的合法条件为 $\sum_{j=0}^kc_{i,j}=a_i$，是每个 $i$ 独立的，所以我们可以将 $\sum_c$ 提后。

$$\sum_S\prod_{i=1}^n\sum_{c_i}\prod_{j\in S_i}c_{i,j}$$

我们可以先考虑 $\sum_{c_i}\prod_{j\in S_i}c_{i,j}$ 这一部分的贡献和 $c_i$ 的方案数。考虑将 $i$ 能够给雨水的窗沿分成两类，一类是属于 $S_i$ 的，另一类不属于 $S_i$。那么我们不妨设属于 $S_i$ 的有 $j$ 个，那么可以列出生成函数为 $F(x)=\sum_{i=0}^\infty ix^i$。那么不属于 $S_i$ 的生成函数就是 $G(x)=\sum_{i=0}^\infty x^i$。

对于一个 $j$，结果为 $[x^{a_i}]F(x)^jG(x)^{lim-j}$，其中 $lim$ 为 $i$ 能给雨水的窗沿数量。化一下式子：

$$
\begin{aligned}
[x^{a_i}]F(x)^jG(x)^{lim-j}&=[x^{a_i}](\frac{x}{(1-x)^2})^j(\frac{1}{1-x})^{lim-j}
\\
&=[x^{a_i}]\frac{x^j}{(1-x)^{lim+j}}
\\
&=[x^{a_i-j}]\frac{1}{(1-x)^{lim+j}}
\\
&=[x^{a_i-j}]\sum_{o=0}C_{o+lim+j-1}^{lim+j-1}x^o
\\
&=C_{a_i+lim-1}^{lim+j-1}
\end{aligned}
$$

记 $h_{i,j}$ 为 $C_{a_i+lim-1}^{lim+j-1}$。接下来我们要考虑怎么体现 $\sum_S\prod_{i=1}^n$。考虑dp。

* 当 $k\le 16$ 时。

  考虑状压 $i+1\sim i+k$ 是否在 $S$ 中，那么就可以dp了。不妨设 $f_{i,s}$ ，那么转移方程即为 $f_{i,s>>1|t}\leftarrow f_{i-1,s}\times h_{i,\operatorname{popcount}(t)+!(s\&1)}$。直接转移是 $O(n3^k)$，考虑使用高维前缀和优化转移，时间复杂度 $O(nk^22^k)$。

* 当 $k>16$ 时。

  考虑容斥 $(k+1,n]$ 中对其他 $S_i$ 有非法贡献的位置的个数。容斥系数就是经典的 $1,-1$。那么考虑已经枚举出 $(k+1,n]$ 中有哪些的贡献是非法的，如何 dp？考虑按 $n\rightarrow 1$ 枚举顺序，对于 $i$ 有非法贡献，则其一定要在 $i-k-1$ 及以后被加入。那么我们可以设计 dp $g_{i,j}$ 表示第 $i$ 个位置有 $j$ 个可选位置。转移有 $g_{i,j+ad_i-x}=g_{i+1,j}\times C_{j+ad_i}^{x}\times h_{i,x}$，其中 $ad_i$ 表示在第 $i$ 个位置能够新产生贡献的位置个数。
  时间复杂度 $O(n^2k2^{n-k})$

结合两种情况，可以通过本题。

注意卡常，对于 $k\le 16$，只用状压有用的位置，不要把数组开太大。对于 $k>16$，在 dp 时只有值非 0 的状态需要产生去转移。

**code（丑死了）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N=40,M=1<<17,P=998244353;
LL n,m,a[N],h[N][N];
LL ksm(LL a,LL b) { LL res=1; for(;b;b>>=1,a=a*a%P) if(b&1) res=res*a%P; return res; }
void upd(LL &x,LL y) { x=(x+y)%P; }
namespace A
{
	LL f[M],sum[M][N];
	void solve()
	{
		f[0]=1;
		for(int i=1;i<=n;i++)
		{
			LL lim=min(m,n-i);
			for(int s=0;s<(1<<lim);s++)
			{
				sum[s][0]=f[s<<1|1],sum[s][1]=f[s<<1];
				for(int j=2;j<=lim+2;j++) sum[s][j]=0;
			}
			for(int j=0;j<lim;j++)
				for(int s=1;s<(1<<lim);s++)
					if(s>>j&1)
						for(int k=1;k<=j+2;k++)
							upd(sum[s][k],sum[s^(1<<j)][k-1]);
			memset(f,0,sizeof(f));
			for(int s=0;s<(1<<lim);s++)
				for(int j=0;j<=lim+1;j++)
					upd(f[s],sum[s][j]*h[i][j]%P);
		}
		printf("%lld",f[0]);
	}
}
namespace B
{
	LL f[N][N],ad[N],C[N][N];
	LL GG()
	{
		memset(f,0,sizeof(f));
		f[n+1][0]=1;
		for(int i=n;i>=1;i--)
			for(int j=0;j<=n;j++)
				if(f[i+1][j])
					for(int k=0;k<=j+ad[i];k++)
						upd(f[i][j+ad[i]-k],f[i+1][j]*C[j+ad[i]][k]%P*h[i][k]%P);
		return f[1][0];
	}
	void solve()
	{
		for(int i=0;i<=n;i++)
			for(int j=0;j<=i;j++)
				if(j==0||j==i) C[i][j]=1;
				else C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;
		LL ans=0;
		for(int s=0;s<(1<<n-m-1);s++)
		{
			LL pop=0;
			for(int i=0;i<n-m-1;i++) if(s>>i&1) pop++;
			for(int i=1;i<=n;i++) ad[i]=1;
			for(int i=1;i<=n-m-1;i++)
				if(s>>i-1&1) ad[i+m+1]--,ad[i]++;
			ans=(ans+(pop&1?P-1:1)*GG()%P)%P;
		}
		printf("%lld",ans);
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",a+i);
	for(LL i=1;i<=n;i++)
		for(int j=0;j<=n;j++)
		{
			LL x=a[i]+min(i+m,n)-i,y=min(i+m,n)-i+j,res=1;
			for(LL j=x-y+1;j<=x;j++) res=res*j%P;
			for(LL j=1;j<=y;j++) res=res*ksm(j,P-2)%P;
			h[i][j]=res;
		}
	if(m<=16) A::solve();
	else B::solve();
	return 0;
}
```

---

## 作者：Union_of_Britain (赞：0)

考试数据分治写挂了，，还发现 $O(n3^{n/2})$ 比 $O(n^32^{n/2})$ 快。

写出生成函数：

$$ans=\left[\prod x_i^{a_i}\right]\prod_i \sum_j j[y^j]\prod_{i-m\le k\le i}\frac{1}{1-x_ky}\\

=\left[\prod x_i^{a_i}\right]\left.\prod _i\frac{\partial}{\partial y}\prod_{i-m\le k\le i}\frac{1}{1-x_ky}\right|_{y=1}\\

=\left[\prod x_i^{a_i}\right]\prod_i\prod_{i-m\le j\le i}\frac{1}{1-x_j}\sum_{i-m\le k\le i}\frac{x_k}{1-x_k}\\
$$

设 

$$F_i=\prod_{j\le i} \frac{1}{1-x_j}$$

则

$$ans=\left[\prod x_i^{a_i}\right]\left(\prod_{n-m\le i\le n}F_i\right)\left(\prod _i \sum_{i-m\le k\le i}\frac{x_k}{1-x_k}\right)$$

后半部分相当于每个 $i$ 选择一个 $k$，然后贡献只跟每个 $k$ 被选择的次数相关，且事实上等于乘积，即设被选择次数为 $c_{1:n}$，造成贡献是

$$\prod_i f_{i,c_i}$$

$f$ 容易通过组合数快速计算。

当 $m\le \frac n2$ 时，直接状压 dp 并使用子集卷积获得 $O(n^32^{n/2})$ 的复杂度。当 $m>\frac n2$ 时，对后 $n-m-1$ 个位置状压，前面的 $m+1$ 位置 $i$ 可以钦定任意 $j\le i$ ，因此前面部分可以背包记录。这部分的复杂度也是 $O(n^32^{n/2})$。

最终复杂度 $O(n^32^{n/2})$，实际上子集卷积不如暴力转移快。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
namespace FWT{
	// #define Poly vector<int>
	int n,A[(1<<17)+5],B[(1<<17)+5],C[(1<<17)+5];
	void work(){
		int sz=0,len=1<<n;
		for(int S=0;S<len;++S) sz+=(A[S]>0);
		for(int S=0;S<len;++S) sz-=(B[S]>0);
		if(sz>0) for(int i=0;i<len;++i) swap(A[i],B[i]);
			for(int S=0;S<len;++S)
				if(A[S]){
					int v=A[S],TT=len-S-1;
					for(int T=TT;~T;T=(T-1)&TT){
						if(B[T]) C[S+T]=(C[S+T]+v*B[T])%mod;
						if(!T) break;
					}
				}
	}
	void clear(){
		for(int j=0;j<(1<<FWT::n);j++)FWT::A[j]=FWT::B[j]=FWT::C[j]=0;
	}
}
int f[40][40],F[40][(1<<17)+5],n,m,a[40],g[2][40][(1<<16)+5];
int qp(int a,int b){
	if(b==0)return 1;
	int T=qp(a,b>>1);T=T*T%mod;
	if(b&1)T=T*a%mod;
	return T;
}
int C(int a,int b){
	int z=1;
	for(int i=a;i>=a-b+1;i--)z=z*i%mod;
	for(int i=1;i<=b;i++)z=z*qp(i,mod-2)%mod;
	z=(z%mod+mod)%mod;
	return z;
}
inline int pop(int x){return __builtin_popcount(x);}
int high[(1<<17)+5],Ci[40][40];
int CL(int i){return min(n-i+1,m+1);}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int N=35;
	for(int i=0;i<=N;i++){
		Ci[i][0]=1;
		for(int j=1;j<=i;j++)Ci[i][j]=(Ci[i-1][j]+Ci[i-1][j-1])%mod;
	}
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		int b;
		if(i<n-m)b=m;
		else b=n-i;
		for(int j=0;j<=min(m+1,a[i]);j++)f[i][j]=C(a[i]+b,b+j);
	}
	if(m==0){
		int ans=1;
		for(int i=1;i<=n;i++)ans=ans*f[i][1]%mod;
		cout<<ans<<endl;
	}else if(m<=14){
		for(int j=0;j<(1<<m+1);j++){
			high[j]=-1;
			for(int k=0;k<m+1;k++)if(j&(1<<k))high[j]=k;
		}
		F[0][0]=1;
		for(int i=1;i<=n;i++){
			FWT::n=m+1;
			for(int j=0;j<(1<<m+1);j++)FWT::A[j]=FWT::B[j]=FWT::C[j]=0;
			for(int j=0;j<(1<<m+1);j++){
				(FWT::A[j>>1]+=F[i-1][j])%=mod;
				if(high[j]+i<=n)FWT::B[j]=f[i][pop(j)];
			}
			FWT::work();
			for(int j=0;j<(1<<m+1);j++)F[i][j]=FWT::C[j];
			for(int j=0;j<(1<<m+1);j++)if(!(j&1))F[i][j]=0;
		}
		int ans=0;
		for(int i=0;i<(1<<m);i++)(ans+=F[n][i])%=mod;
		cout<<ans<<endl;
	}else{
		F[n+1][0]=1;
		for(int i=n;i>=m+2;i--){
			int cl=min(n-i+1,m+1);
			FWT::n=cl;
			for(int j=0;j<(1<<cl);j++){
				FWT::B[j]=f[i][pop(j)];
				if(!(j&1))FWT::A[j]=F[i+1][j>>1];
			}
			FWT::work();
			for(int j=0;j<(1<<cl);j++)F[i][j]=FWT::C[j]; 
			FWT::clear();
		}
		int cur=0,lst=CL(m+2);
		for(int j=0;j<(1<<CL(m+2));j++)g[0][0][j]=F[m+2][j];
		for(int i=m+1;i>=1;i--){
			int cl=min(n-m-1,i-1),c2=m+1-i;
			for(int j=0;j<=c2;j++)for(int k=0;k<(1<<cl);k++){
				if(lst>cl)g[cur][j][k]=0;
			}
			for(int j=0;j<=c2;j++)for(int k=0;k<(1<<lst);k++){
				if(k>=(1<<cl)){
				if((k|((1<<cl)-1))!=(1<<lst)-1)continue;
					(g[cur][j][k&((1<<cl)-1)]+=g[cur][j][k])%=mod;
					}
			}
			for(int j=0;j<(1<<cl);j++)for(int k=0;k<=m+2-i;k++)g[cur^1][k][j]=0;
			for(int j=0;j<=c2;j++){
				for(int k=0;k<=m+2-i-j;k++){
					FWT::n=cl;
					for(int t=0;t<(1<<cl);t++){
						FWT::B[t]=f[i][pop(t)+k];
						FWT::A[t]=g[cur][j][t];
					}
					FWT::work();
					for(int t=0;t<(1<<cl);t++){
						(g[cur^1][j+k][t]+=FWT::C[t]*Ci[m+2-i-j][k])%=mod;
					}
					FWT::clear();
				}
			}
			lst=cl;
			cur^=1;
		}
		int ans=g[cur][m+1][0];
		cout<<ans<<endl;
	}
	return 0;
}
```

代码的 $m>14$ 部分可能在搬过来处理 $m\le 14$ 的时候会出现问题。

---


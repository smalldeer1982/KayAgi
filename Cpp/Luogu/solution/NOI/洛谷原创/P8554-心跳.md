# 心跳

## 题目背景

“清晰的跳动声传达来的，重叠的声响和流动的思念。

约定再也不要分开吧，希望无论何时都不要让你寂寞。”

恋爱之时，人的心情不会一成不变，可喜悦和悲伤会随着时间流逝而归于平淡。最令人难忘的是那些“心动”的感觉，那些因未曾经历而喜出望外的感觉。因此，有些时候，失去某些特别美好的回忆，反而能让心动的感觉增多。可为此失去那些回忆，真的值得吗？

## 题目描述

赫尔德想对上面的问题进行探究，她想先做一些统计，于是她抽象了这个问题。

我们对于一个长为 $l$ 的数列 $p$，定义函数：

-   $f(p)$ 表示有多少 $1\le i\le l$ 满足 $p_i=\max_{j=1}^i p_j$（即前缀最大值的个数）。

现在，给定 $n,m$，请求出有多少满足以下条件的长为 $n$ 的，值域在 $[m,n]$ 数列 $a$：

-   存在一个排列 $p$ 使得：令 $P_i$ 代表 $p$ 去掉 $p_i$ 后的数列（即 $[p_1,p_2,\dots,p_{i-1},p_{i+1},\dots,p_n]$），$f(P_i)=a_i$。

答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释 \#2】**

有以下 $8$ 种不同的 $a$：

1. $\{4,4,4,4,4\}$，对应的一种 $p$ 为：$\{1,2,3,4,5\}$；
2. $\{3,3,3,4,4\}$，对应的一种 $p$ 为：$\{1,2,3,5,4\}$；
3. $\{3,3,4,4,3\}$，对应的一种 $p$ 为：$\{1,2,4,3,5\}$；
4. $\{3,3,3,3,4\}$，对应的一种 $p$ 为：$\{1,2,4,5,3\}$；
5. $\{3,4,4,3,3\}$，对应的一种 $p$ 为：$\{1,3,2,4,5\}$；
6. $\{3,3,3,4,3\}$，对应的一种 $p$ 为：$\{1,3,4,2,5\}$；
7. $\{4,4,3,3,3\}$，对应的一种 $p$ 为：$\{2,1,3,4,5\}$；
8. $\{3,3,4,3,3\}$，对应的一种 $p$ 为：$\{2,3,1,4,5\}$。

---

**【数据范围】**

对于所有数据，保证 $3\le n\le 2000,1\le m\le n $。

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c|c}\hline 
\textbf{子任务编号}&~~\bm{n\le} ~~&~~\bm{m\le}~~ &\textbf{分数}\cr\hline 
\textsf1 & 9 &1&8\cr\hline 
\textsf2 & 18&1&12 \cr\hline 
\textsf3 & 70&1&15\cr\hline 
\textsf4 & 70 &&24\cr\hline 
\textsf5 & 300&&18 \cr\hline
\textsf6 & &&23\cr\hline\end{array}
$$

没写就是没特殊限制。

---

赫尔德成功算出了不同的恋爱的数量。但她只会经历其中一个。

## 样例 #1

### 输入

```
3 1
```

### 输出

```
6
```

## 样例 #2

### 输入

```
5 3
```

### 输出

```
8
```

## 样例 #3

### 输入

```
50 10```

### 输出

```
664411387```

# 题解

## 作者：小粉兔 (赞：63)

考虑找出合法的 $a$ 的结构，并基于结构性质，进行去重和 $\ge m$ 的统计。

我们考虑原排列中的每个前缀最大值都“控制”它后面的一段：也即，那一段内的元素都小于这个前缀最大值，这个控制的区间向右延伸到下一个前缀最大值前（或排列末尾）。

记原排列的前缀最大值个数为 $k$，也即段数为 $k$。删去非前缀最大值时，序列的前缀最大值个数不会改变，这也就是说，如果 $p_i$ 不为前缀最大值，则 $a_i = k$。

当删去前缀最大值时，这个前缀最大值所控制的段内其他元素都将暴露在外，如果这些元素中出现了新的 $x$ 个前缀最大值，则新序列的前缀最大值个数应为 $k - 1 + x$，即原排列的前缀最大值个数，去掉这个被删去的前缀最大值，再加上新出现的 $x$ 个前缀最大值。  
记这一段（包含它自己）的长度为 $h$，由于 $x$ 至多为 $h - 1$，这说明新的前缀最大值个数将在 $[k - 1, k + h - 2]$ 中选取。我们进一步要探讨的是，如果仅知道每一段的长度，这 $[k - 1, k + h - 2]$ 中的 $h$ 个数是否都能取到；换言之，给定每一段的长度 $h_{1 \sim k}$，对于每个前缀最大值的每个 $a_i \in [k - 1, k + h - 2]$ 的方案，是否都能构造一个排列 $p$ 使其恰好得到序列 $a$？

- 答案**几乎**是肯定的：除了在第一段中如果 $h \ge 2$ 就无法取到 $a_1 = k - 1$ 外，总能构造一个排列 $p$ 使其恰好得到序列 $a$。
- 我们可以感性证明一下这个结论。注意，在原排列中，“**当删去前缀最大值时，这个前缀最大值所控制的段内其他元素都将暴露在外**”。只要我们可以自由控制这 $h - 1$ 个元素暴露在外后，恰好出现的前缀最大值的数量（即在 $[0, h - 1]$ 中任取），就能达到根据每段长度和每个 $a_i$ 反向构造原排列的目的。
- 对于所有段，可以发现，总是可以排列段内其他元素的相对顺序（段内所有元素都大于上一段的最大值），达到恰好新出现 $[1, h - 1]$ 个前缀最大值。
- 要达到恰好新出现 $0$ 个前缀最大值，即其他元素全部被前一段的最大值隐藏，前提是“存在前一段”或 $h = 1$，即当第一段的 $h \ge 2$ 时，不可能取到 $a_1 = k - 1$。

我们恰恰是要对序列 $a$ 进行计数，所以前述结论（对 $a$ 的合法性判定）将提供莫大的帮助。但是我们仍需要对序列 $a$ 进行去重，因为可能存在不同的段分布情况对应到相同的序列 $a$ 的情况：

- $p = [\underline{5, 3, 4, 1, 2}, \underline{7, 6}]$ 对应 $a = [\underline{3, 2, 2, 2, 2}, \underline{2, 2}]$。
- $p = [\underline{3, 1, 2}, \underline{7, 6, 4, 5}]$ 对应 $a = [\underline{3, 2, 2}, \underline{2, 2, 2, 2}]$。
- 注意它们的段分布情况不同，但是对应的序列 $a$ 相同，所以不能通过段分布情况对所有可能的序列 $a$ 直接进行分类。

为了进一步考虑对不同的段分布情况的序列 $a$ 去重，我们基于序列 $a$ 引入一个新序列称作序列 $b$ ：  
已知序列 $a$ 对应的原排列的段数为 $k$，此时令 $b$ 为 $a$ 中每个元素减去 $k$ 构成的序列，则原排列中**不为前缀最大值的位置**在序列 $b$ 中对应的值为 $0$。

考察序列 $b$ 中的那些前缀最大值位置，我们知道它们的取值为 $[-1, h - 2]$，其中 $h$ 为这一段的长度。为了给序列 $a$ 去重，我们不先确定段分布情况，而是从序列 $b$ 的每个元素的具体数值入手。如果确定了序列 $b$ 中的某个段首位置的值，即确定了 $b_i = v$，则根据前文可知这一段的长度 $h$ 满足 $h \ge v + 2$。所以，如果按段首的具体数值分类，每一段在序列 $b$ 中必然呈现如下形式：

- $[-1]$ 后跟零个或更多个 $0$。
- $[0, 0]$ 后跟零个或更多个 $0$。
- $[1, 0, 0]$ 后跟零个或更多个 $0$。
- $[2, 0, 0, 0]$ 后跟零个或更多个 $0$。
- $[3, 0, 0, 0, 0]$ 后跟零个或更多个 $0$。
- 以此类推……

回顾序列 $b$ 的定义，可知只要确定了 $(b, k)$ 就可以反向构造出唯一的 $a$。当然，这里的 $(b, k)$ 必须是**合法**的。使用上文列举的段结构，我们可以清晰地认识**附加了段分布信息**的序列 $b$ 的结构，对其进行计数也是很容易的：

- 我们可以把每一段看作 $[-1], [0, 0], [1, 0, 0], [2, 0, 0, 0], \ldots$ 之一与若干个 $0$ 拼接而成。
- 记段的组合类为 $\mathcal{S}$，则 $\displaystyle \operatorname{OGF}(\mathcal{S}) = \frac{x}{1 - x} \cdot \frac{1}{1 - x}$。
- 注意第一段不能以 $[-1, 0]$ 为前缀，只能是 $[-1]$ 或以其他数开头，所以记第一段的组合类为 $\mathcal{S}_1$ 时有 $\displaystyle \operatorname{OGF}(\mathcal{S}_1) = x + \frac{x^2}{1 - x} \cdot \frac{1}{1 - x}$。
- 那么附加了段分布信息的序列 $b$ 的组合类就是 $\mathcal{S}_1 \times \operatorname{SEQ}(\mathcal{S})$，有 OGF $\displaystyle \frac{x + \dfrac{x^2}{1 - x} \cdot \dfrac{1}{1 - x}}{1 - \dfrac{x}{1 - x} \cdot \dfrac{1}{1 - x}}$。

**但是**，我们需要计数的并不是附加上段结构信息的序列 $b$ ，而是序列 $a$。注意：

- 相同的序列 $b$，如果有不同的 $k$（即段数），当然会对应到不同的序列 $a$ 上。
- 相同的序列 $b$，如果有不同的段结构信息，但段数 $k$ 相同，也会对应到相同的序列 $a$ 上。

即，从序列 $b$ 的角度来看，我们要计数的是**带段数信息的**不同的序列 $b$ 个数。即，不同的序列 $b$ 依然算作不同，但相同的序列 $b$，如果段数不同也算作不同，段数相同则算作相同。举个例子：

- $p = [\underline{5, 3, 4, 1, 2}, \underline{7, 6}]$ 对应 $a = [\underline{3, 2, 2, 2, 2}, \underline{2, 2}]$ 和 $b = [\underline{1, 0, 0, 0, 0}, \underline{0, 0}]$ 与 $k = 2$。
- $p = [\underline{3, 1, 2}, \underline{7, 6, 4, 5}]$ 对应 $a = [\underline{3, 2, 2}, \underline{2, 2, 2, 2}]$ 和 $b = [\underline{1, 0, 0}, \underline{0, 0, 0, 0}]$ 与 $k = 2$。
- $p = [\underline{3, 1, 2}, \underline{5, 4}, \underline{7, 6}]$ 对应 $a = [\underline{4, 3, 3}, \underline{3, 3}, \underline{3, 3}]$ 和 $b = [\underline{1, 0, 0}, \underline{0, 0}, \underline{0, 0}]$ 与 $k = 3$。
- 前两个 $\langle b, k \rangle$ 需要被视为同一类，但第三个 $\langle b, k \rangle$ 有着不同的 $k$，需要分开计数。

注意，这里默认了不同的序列 $b$ 必然对应不同的序列 $a$，这个结论是正确的，然而并不显然（初看时，无法否认两个相差为常数的序列 $b$ 由于段数 $k$ 不同而对应到相同的序列 $a$ 上的可能性）。

通过上述例子，容易观察到出现重复的 $\langle b, k \rangle$ 的原因：在序列 $b$ 中有 $[0, 0]$ 段的存在，更一般地，有形如 $[0, 0]$ 后跟若干个 $0$ 的段的存在。它们的分布方式不同，但数量相同时，就会导致重复统计。如果禁止这样的段的出现呢？

- 如果强制不能出现“形如 $[0, 0]$ 后跟若干个 $0$ 的段”，即是每一段的首位都非零，可以直接根据序列 $b$ 本身的值唯一确定段分布信息，故也确定了段数。这就是说，直接将 $[-1], [1, 0, 0], [2, 0, 0, 0], \ldots$ 之一与若干个 $0$ 拼接而成的段进行不限数量的有序拼接（$\operatorname{SEQ}$）即可不重不漏地枚举到所有序列 $b$。
- 翻译成符号化方法的语言即是，$\displaystyle \operatorname{OGF}(\mathcal{S}) = \left( \frac{x}{1 - x} - x^2 \right) \cdot \frac{1}{1 - x}$ 和 $\displaystyle \operatorname{OGF}(\mathcal{S}_1) = x + \frac{x^3}{1 - x} \cdot \frac{1}{1 - x}$。
- 而不允许出现 $0$ 开头的段的序列 $b$ 的组合类即是 $\mathcal{S}_1 \times \operatorname{SEQ}(\mathcal{S})$，有 OGF $\displaystyle \frac{x + \dfrac{x^3}{1 - x} \cdot \dfrac{1}{1 - x}}{1 - \left( \dfrac{x}{1 - x} - x^2 \right) \cdot \dfrac{1}{1 - x}}$。

但是如果考虑上首位为 $0$ 的段，我们应该如何把首位为 $0$ 的段按出现次数进行去重呢？有关键性质：

- 不带段分布信息地给定一个合法序列 $b$，它能对应的合法 $k$ 必须是一个区间。感性理解：

- 区间必须有端点 $k \in [l, r]$，我们可以构造性地指出端点和中间所有数都能被 $k$ 取到。

- 显然每个非零数都必须在不同的段中，不妨先粗暴地把每个非零数与其后面的 $0$ 连续段划分为同一段。序列 $b$ 以 $0$ 或 $-1$ 开头时进行一些特别处理。举一些例子：

  - 将 $b = [2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]$ 划分为 $[\underline{2, 0, 0, 0, 0, 0, 0, 0}\ ,\ \underline{1, 0, 0, 0}\ ,\ \underline{-1, 0, 0, 0}\ ,\ \underline{1, 0, 0}]$。
  - 将 $b = [0, 0, 0, 0, 0, 2, 0, 0, 0, -1, 0, 1, 0, 0, 0, -1]$ 划分为 $[\underline{0, 0, 0, 0, 0}\ ,\ \underline{2, 0, 0, 0}\ ,\ \underline{-1, 0}\ ,\ \underline{1, 0, 0, 0}\ ,\ \underline{-1}]$。
  - 将 $b = [-1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 0]$ 划分为 $[\underline{-1}\ ,\ \underline{0, 0, 0, 0, 0}\ ,\ \underline{1, 0, 0, 0, 0, 0}\ ,\ \underline{-1, 0, 0, 0}]$。

  总的来说，即是保证每一段在合法的前提下尽量长。可以看出，这种划分唯一且一定是合法的，否则就不存在任何合法划分了。这样导出的段分布一定是段数最少的，此时即为 $k = l$，取到区间的左端点。

- 对于右端点，考虑划分段数最多的方式。如果这一段的首元素为 $v$，则段必须至少长度为 $v + 2$，但是如果在前一种划分方式中段长为 $h$，即是说在段的末尾超出了 $h - (v + 2)$ 个 $0$。这写多余的 $0$，为了使段数尽量多，可以两个两个结合成段，即产生 $\left\lfloor \dfrac{h - (v + 2)}{2} \right\rfloor$ 个新的段，按相同例子：

  - 将 $b = [2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]$ 划分为 $[\underline{2, 0, 0, 0}\ ,\ \underline{0, 0}\ ,\ \underline{0, 0}\ ,\ \underline{1, 0, 0, 0}\ ,\ \underline{-1, 0}\ ,\ \underline{0, 0}\ ,\ \underline{1, 0, 0}]$，$k$ 增加了 $3$。
  - 将 $b = [0, 0, 0, 0, 0, 2, 0, 0, 0, -1, 0, 1, 0, 0, 0, -1]$ 划分为 $[\underline{0, 0, 0}\ ,\ \underline{0, 0}\ ,\ \underline{2, 0, 0, 0}\ ,\ \underline{-1, 0}\ ,\ \underline{1, 0, 0, 0}\ ,\ \underline{-1}]$，$k$ 增加了 $1$。
  - 将 $b = [-1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 0]$ 划分为 $[\underline{-1}\ ,\ \underline{0, 0, 0}\ ,\ \underline{0, 0}\ ,\ \underline{1, 0, 0, 0}\ ,\ \underline{0, 0}\ ,\ \underline{-1, 0}\ ,\ \underline{0, 0}]$，$k$ 增加了 $3$。

  这种满足段数尽量多的划分不一定唯一，如果存在 $h - (v + 2)$ 为奇数且 $\ge 3$，则可以有多种具体的段分布方式。相比 $k$ 尽量少的划分，$k$ 一般会增加，但也可能无法增加，即可能存在每一段都出现了 $h - (v + 2) \le 1$ 的情况。

- 由于划分段数最多是基于划分段数最少的方法进一步划分而成，显然中间的每个数都能被 $k$ 取到，只需进行不完全的划分即可。

既然已知不带附加信息的合法序列 $b$ 可以对应一个区间中的 $k$，再考虑到 $m$ 的需求——由于 $b$ 的最小值为 $0$ 或 $-1$，要求 $a$ 的值域在 $[m, n]$ 中，即是要求 $k$ 需要大于某个值（这里根据最小值是否取到 $-1$ 会有一些偏差，后文中会展开细节），结合这两点我们考虑直接附带记录 $k$ 的信息。

即，我们试图求出，$k$ 恰好为某个值的数值不同的序列 $b$（不带附加信息）的个数。通过区间的性质，我们考虑从左右端点切入。如果可以求出：

- 对应到的 $k$ 区间的左端点恰好为 $l$ 的序列 $b$ 的个数，记作 $f(n, l)$。
- 对应到的 $k$ 区间的右端点恰好为 $r$ 的序列 $b$ 的个数，记作 $g(n, r)$。

如果记 $h(n, k)$ 表示能够取到 $k$ 的序列 $b$ 的个数，则有 $\displaystyle h(n, k) = \sum_{l = 1}^{k} f(n, l) - \sum_{r = 1}^{k - 1} g(n, r)$。

现在只考虑求 $f$ 和 $g$。使用二元生成函数，将 $l$ 和 $r$ 作为 $y$ 的次数引入信息。下面继续沿用前文中符号化方法的记号。

对于 $f$，即 $y$ 的次数为左端点，由于每一段不再分裂：

- 有 $\displaystyle \operatorname{OGF}(\mathcal{S}) = y \cdot \left[ \left( \frac{x}{1 - x} - x^2 \right) \cdot \frac{1}{1 - x} \right]$。

- 对于首（两）段的特殊处理，有 $\displaystyle \operatorname{OGF}(\mathcal{S}_1) = y \cdot \left( x + x \cdot y \cdot \frac{x^2}{1 - x} + \frac{x^2}{1 - x} \cdot \frac{1}{1 - x} \right)$。这是因为首段可以以 $0, 1, 2, \ldots$ 开头，而 $-1$ 开头时，要么不能往后接 $0$ 了，要么后面的 $0$ 至少接两个，并独立成段。

- 最后，有 $\mathcal F = \mathcal{S}_1 \times \operatorname{SEQ}(\mathcal{S})$。对于 OGF 有

- $$
  \begin{aligned}
  F(x, y) = \operatorname{OGF}(\mathcal{F}) &= \frac{\operatorname{OGF}(\mathcal{S}_1)}{1 - \operatorname{OGF}(\mathcal{S})} \\
  &= \frac{y \cdot \left( x + x \cdot y \cdot \dfrac{x^2}{1 - x} + \dfrac{x^2}{1 - x} \cdot \dfrac{1}{1 - x} \right)}{1 - y \cdot \left[ \left( \dfrac{x}{1 - x} - x^2 \right) \cdot \dfrac{1}{1 - x} \right]} \\
  \text{(WolframAlpha or Mathematica)\qquad} &= \frac{x y - x^2 y + x^3 y + x^3 y^2 - x^4 y^2}{1 - (2 x - x^2 + y \cdot (x - x^2 + x^3))} \text{.}
  \end{aligned}
  $$

对于 $g$，即 $y$ 的次数为右端点，考虑每一段额外多出的 $0$ 的个数为 $w$ 时会产生 $\lfloor w / 2 \rfloor$ 个新段：

- 有 $\displaystyle \operatorname{OGF}(\mathcal{S}) = \left[ y \cdot (1 + x) \cdot \left( \frac{x}{1 - x} - x^2 \right) \right] \cdot \frac{1}{1 - y \cdot x^2}$。此处相当于以基本的 $\displaystyle \frac{x}{1 - x} - x^2$ 为基础，先乘上 $(1 + x)$ 表示多出奇数个 $0$ 与偶数无异，然后乘上 $y$ 表示这一段本身的贡献，后面乘上 $\operatorname{SEQ}(y \cdot x^2)$ 表示每两个 $0$ 单独成段。

- 对于首（若干）段的特殊处理，有 $\displaystyle \operatorname{OGF}(\mathcal{S}_1) = y \cdot x + \left[ y \cdot (1 + x) \cdot \left( x \cdot y \cdot x^2 + \frac{x^2}{1 - x} \right) \right] \cdot \frac{1}{1 - y \cdot x^2}$。其中在外的 $y \cdot x$ 对应首段为 $-1$ 并不接任何 $0$ 的情况，内部的 $x \cdot y \cdot x^2$ 对应首（两）段为 $[-1]$、$[0, 0]$ 的情况，它们也需要乘 $(1 + x)$ 和 $\displaystyle \frac{1}{1 - y \cdot x^2}$。

- 最后，有 $\mathcal G = \mathcal{S}_1 \times \operatorname{SEQ}(\mathcal{S})$。对于 OGF 有

- $$
  \begin{aligned}
  G(x, y) = \operatorname{OGF}(\mathcal{G}) &= \frac{\operatorname{OGF}(\mathcal{S}_1)}{1 - \operatorname{OGF}(\mathcal{S})} \\
  &= \frac{y \cdot x + \left[ y \cdot (1 + x) \cdot \left( x \cdot y \cdot x^2 + \dfrac{x^2}{1 - x} \right) \right] \cdot \dfrac{1}{1 - y \cdot x^2}}{1 - \left[ y \cdot (1 + x) \cdot \left( \dfrac{x}{1 - x} - x^2 \right) \right] \cdot \dfrac{1}{1 - y \cdot x^2}} \\
  \text{(WolframAlpha or Mathematica)\qquad} &= \frac{x y + x^3 y + x^4 y^2 - x^5 y^2}{1 - (x + y \cdot (x + x^2 - x^3 + x^4))} \text{.}
  \end{aligned}
  $$

接下来，根据 $\displaystyle h(n, k) = \sum_{l = 1}^{k} f(n, l) - \sum_{r = 1}^{k - 1} g(n, r)$，我们有 $\displaystyle H(x, y) = \operatorname{OGF}(\mathcal{H}) = \frac{1}{1 - y} \cdot F(x, y) - \frac{y}{1 - y} \cdot G(x, y)$。

根据 $F(x, y)$ 和 $G(x, y)$ 的二元有理分式，容易在 $\mathcal{O}(n^2)$ 计算它们在 $\langle n, n \rangle$ 次项处的截断，并进一步得到 $h(n, k)$ 的每个值。

仍要注意，直接计算 $\displaystyle \sum_{k = m}^{n} h(n, k)$ 并不能得到答案，这是因为多统计了当 $k = m$ 时，序列 $b$ 中有 $-1$ 的存在导致序列 $a$ 的对应位置 $= m - 1 < m$。改为直接计算 $\displaystyle \sum_{k = m + 1}^{n} h(n, k)$ 也不能得到答案，这是因为当 $k = m$ 时，可能仍有一些不存在 $-1$ 的序列 $b$ 是满足条件的但未被统计到。所以我们只需针对 $k = m$ 且序列 $b$ 中不存在 $-1$ 的情况处理。再推一遍生成函数式子，此时强制不能有 $-1$ 的段出现：

- 在记号上，将禁止 $-1$ 的相关对象加个星号。类似地，我们要求 $F^{{\ast}}(x, y)$ 对应左端点、以及 $G^{{\ast}}(x, y)$ 对应右端点。

- 对于 $F^{{\ast}}(x, y)$，有 $\displaystyle \operatorname{OGF}(\mathcal{S}) = y \cdot \frac{x^3}{1 - x} \cdot \frac{1}{1 - x}$ 和 $\displaystyle \operatorname{OGF}(\mathcal{S}_1) = y \cdot \frac{x^2}{1 - x} \cdot \frac{1}{1 - x}$。计算可得
  $$
  F^{{\ast}}(x, y) = \frac{\operatorname{OGF}(\mathcal{S}_1)}{1 - \operatorname{OGF}(\mathcal{S})} = \cdots = \frac{x^2 y}{1 - (2 x - x^2 + y \cdot (x^3))} \text{.}
  $$

- 对于 $G^{{\ast}}(x, y)$，有 $\displaystyle \operatorname{OGF}(\mathcal{S}) = \left[ y \cdot (1 + x) \cdot \frac{x^3}{1 - x} \right] \cdot \frac{1}{1 - y \cdot x^2}$ 和 $\displaystyle \operatorname{OGF}(\mathcal{S}_1) = \left[ y \cdot (1 + x) \cdot \frac{x^2}{1 - x} \right] \cdot \frac{1}{1 - y \cdot x^2}$。计算可得
  $$
  G^{{\ast}}(x, y) = \frac{\operatorname{OGF}(\mathcal{S}_1)}{1 - \operatorname{OGF}(\mathcal{S})} = \cdots = \frac{x^2 y + x^3 y}{1 - (x + y \cdot (x^2 + x^4))} \text{.}
  $$

那么，类似地，我们有 $\displaystyle H^{{\ast}}(x, y) = \operatorname{OGF}(\mathcal{H}^{{\ast}}) = \frac{1}{1 - y} \cdot F^{{\ast}}(x, y) - \frac{y}{1 - y} \cdot G^{{\ast}}(x, y)$。

答案即为 $\displaystyle \sum_{k = m + 1}^{n} h(n, k) + h^{{\ast}}(n, m)$。至此，本题在 $\mathcal{O}(n^2)$ 复杂度内得到解决。

为了追求更好的时间复杂度，注意到答案为
$$
\Big( \big[ x^n y^n \big] - \big[ x^n y^m \big] \Big) \frac{1}{1 - y} \left( \frac{1}{1 - y} \cdot F(x, y) - \frac{y}{1 - y} \cdot G(x, y) \right) + \big[ x^n y^m \big] \left( \frac{1}{1 - y} \cdot F^{{\ast}}(x, y) - \frac{y}{1 - y} \cdot G^{{\ast}}(x, y) \right) \text{,}
$$
再结合这一事实——对关于 $x$ 的一元多项式 $P(x), Q(x)$ 满足 $Q(0) \ne 1$，有
$$
\big[ y^m \big] \frac{1}{1 - (Q(x) + y \cdot P(x))} = {\left( \frac{P(x)}{1 - Q(x)} \right)}^m \frac{1}{1 - Q(x)} \text{.} \tag{3}
$$
这启发我们对答案中的二元有理分式进行部分分式分解，得到分母中 $y$ 最高次数为 $1$ 的部分分式。

对 $\displaystyle \frac{1}{{(1 - y)}^2} \cdot F(x, y)$、$\displaystyle \frac{y}{{(1 - y)}^2} \cdot G(x, y)$、$\displaystyle \frac{1}{1 - y} \cdot F^{{\ast}}(x, y)$、以及 $\displaystyle \frac{y}{1 - y} \cdot G^{{\ast}}(x, y)$ 分别进行以 $y$ 为主元的部分分式分解（借助 Mathematica）：
$$
\begin{aligned}
\frac{1}{{(1 - y)}^2} \cdot F(x, y) &= x y \cdot \bigg[ \frac{1}{{(1 - y)}^2} \cdot \frac{1 - x + 2 x^2 - x^3}{1 - (3 x - 2 x^2 + x^3)} \\
  & \qquad {} - \frac{1}{1 - y} \cdot \frac{x - x^2 + x^4}{1 - (6 x - 13 x^2 + 14 x^3 - 10 x^4 + 4 x^5 - x^6)} \\
  & \qquad {} + \frac{1}{1 - (2 x - x^2 + y \cdot (x - x^2 + x^3))} \cdot \frac{x^2 - 2 x^3 + 2 x^4 - x^6 + x^7}{1 - (6 x - 13 x^2 + 14 x^3 - 10 x^4 + 4 x^5 - x^6)} \bigg] \text{.} \\
\frac{y}{{(1 - y)}^2} \cdot G(x, y) &= x y^2 \cdot \bigg[ \frac{1}{{(1 - y)}^2} \cdot \frac{1 - x + 2 x^2 - x^3}{1 - (3 x - 2 x^2 + x^3)} \\
  & \qquad {} - \frac{1}{1 - y} \cdot \frac{x + x^3 - x^4 + x^5}{1 - (5 x - 7 x^2 + x^3 + 4 x^4 - 6 x^5 + 3 x^6 - x^7)} \\
  & \qquad {} + \frac{1}{1 - (x + y \cdot (x + x^2 - x^3 + x^4))} \cdot \frac{x^2 + x^3 + x^5 - x^6 + 3 x^7 - 2 x^8 + x^9}{1 - (5 x - 7 x^2 + x^3 + 4 x^4 - 6 x^5 + 3 x^6 - x^7)} \bigg] \text{.} \\
\frac{1}{1 - y} \cdot F^{{\ast}}(x, y) &= x^2 y \cdot \bigg[ \frac{1}{1 - y} \cdot \frac{1}{1 - (2 x - x^2 + x^3)} \\
  & \qquad {} - \frac{1}{1 - (2 x - x^2 + y \cdot (x^3))} \cdot \frac{x^3}{1 - (2 x - x^2 + x^3)} \bigg] \text{.} \\
\frac{y}{1 - y} \cdot G^{{\ast}}(x, y) &= x^2 y^2 \cdot \bigg[ \frac{1}{1 - y} \cdot \frac{1}{1 - (2 x - x^2 + x^3)} \\
  & \qquad {} - \frac{1}{1 - (x + y \cdot (x^2 + x^4))} \cdot \frac{x^2 + x^4}{1 - (2 x - x^2 + x^3)} \bigg] \text{.}
\end{aligned}
$$
基于这些结果，通过先提取 $\big[ y^m \big]$，转化为求常数个关于 $x$ 的常数次多项式的常有理数次幂的乘积的 $\big[ x^n \big]$，此时可以使用相关多项式运算达到 $\mathcal O(n \log n)$。

或者结合 $(3)$ 的形式，使用 ODE 相关技术，转化为整式递推，达到 $\mathcal O(n)$ 的复杂度。

---

## 作者：dottle (赞：29)

### $m=1$

首先，对于一个固定的数组，我们来分析它去掉每一个数后，前缀最大值个数的变化。

设 $k$ 为该数组原先的前缀最大值个数。那么去掉一个数后，

1.  若其原先不是前缀最大值，则前缀最大值个数不变，仍为 $k$。
2.  若其原先是前缀最大值，则前缀最大值个数先减 1，然后其后有一些本不是前缀最大值上的数将变为前缀最大值，因此还会加上一些数，因此前缀最大值个数变为 $[k-1,n]$ 的某个数。



接下来，为了解决计数问题，我们先解决构造问题——对于数组 $a$，若是否存在 $p$ 与其对应，则称这些 $a$ 为合法的。我们对于合法的 $a$，我们先构造一个 $p$。

首先，我们需要确定 $k$，但这并不方便直接求出，所以我们就假设我们已经知道 $k$ 了。可以证明一个合法数组 $a$ 唯一对应了一个 $k$，因此我们加的这一个条件不影响我们计数。

接下来，我们开始尝试构造一个 $p$ 与 $a$ 对应。我们将整个过程分为三步：

1.  考虑那些不等于 $k$ 的位置 $i$。若其小于 $k-1$ 是无解的，否则设其为 $x$，且 $x-(k-1)=y$。这就要求去掉此位置之后， 有至少 $y$ 个位置会成为新的前缀最大值。为了方便唯一对应，我们就钦定 $i$ 后面的 $y$ 个位置是备用最大值 $(\star )$。
2.  设在第一步中，我们确定了 $w$ 个位置是前缀最大值，那么还需要钦定 $k-w$ 个等于 $k$ 的位置为前缀最大值。对于这些位置，去掉他们会有 $1$ 个位置成为新的前缀最大值。也就是说，这些位置后面必须跟着一个非前缀最大值的 $k$。为了方便唯一对应，我们就从前往后扫，每次遇到两个连续的未在第一步中被钦定的数，我们就钦定前一个是前缀最大值，后一个是备用最大值。
3.  对于那些既不是前缀最大值，又不是备用最大值的数，就称为垃圾。

我们将前缀最大值染成红色，备用最大值染上绿色，垃圾染上黄色。这样，我们就将一个 $a$ 序列唯一对应到了一个颜色序列。颜色序列拥有好的性质：

1.  一个颜色序列唯一对应了一个 $a$ 序列。
2.  对于任意一个颜色序列，都存在排列 $p$ 与之对应。

前者的正确性比较自然，直接根据颜色序列算 $a$ 序列就好。对于后者，我们采取以下的插入构造法得到一个 $p$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kahg2dg3.png)


稍微解释一下，绿色位置的值大于上上个红色，小于上个红色，升序排列；黄色位置的值小于上上个红色位置，或者小于上个绿色位置。这样一定是可以构造出来的。



那么现在，我们只需要对颜色序列计数就可以了。我们再来回忆一下先前的构造中隐含的要求，并非所有红黄绿组成的序列都是我们说的颜色序列。颜色序列的要求有哪些呢？

1.  绿色（备用最大值）仅应该紧跟着红色（前缀最大值），这是为了满足 $(\star )$。
2.  “红绿X”段应该尽可能靠前，其中  X 是任意一个非绿的颜色，即“红绿X”不能出现在“黄黄”之后（否则可以把后面的红绿与前面的黄黄交换位置，不满足红绿考前的要求）。“黄红绿X”也不应该出现（因为它可以换成“红绿黄X”）。
3.  第一个数一定是红色，第二个数一定不是黄色。后者是因为，去掉第一个数后，第二个数一定成为前缀最大值。

据此，我们就可以根据这三个条件，开始设计关于颜色序列计数的 dp 了。



接下来，我们开始设计状态。考察我们需要记录哪些信息：

1.  前一个是什么颜色。
2.  前面是否有“黄黄”。
3.  这一段绿色段是 0、1 还是大于等于 2。
4.  这一段绿色前面的红色是否在黄色后面。

你可以就根据这四个写，也可以参考这个压缩后的状态：

![img](https://cdn.luogu.com.cn/upload/image_hosting/rshc1xwz.png)

转移略，建议待会直接看我代码。

### $m>1$ 

只需要额外记录两个信息：

1.  当前红色的个数。
2.  是否有不接绿色的红色。

对于条件 2，我是直接跑了两遍，第二遍跑的时候强制不在红色后面跟红色和黄色。这样方便，合在一起写起来比较逆天。最后所有数大于等于 $m$ 就是要求此值大于等于 $m$：$红色的个数-[存在不接绿色的红色]$。

```cpp
#include<bits/stdc++.h>
#define int long long
const int N=3050;
using namespace std;

int n,m;
const int mod=1e9+7;
int f[N][11],G[N][11];
int res[N];

void solve(){
	int i;cin>>i;
	cout<<res[i]<<endl;
}

main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	f[2][0]=1,f[1][1]=1;
	int res=0;
	for(int i=2;i<=n;i++){
		memcpy(G,f,sizeof(G));
		memset(f,0,sizeof(f));
		for(int j=0;j<=n;j++){
			auto g=G[j];
			f[j+1][0]=(g[0]+g[1]+g[2]+g[8]+g[10])%mod;
			f[j][1]=g[0];
			f[j][2]=(g[1]+g[2])%mod;
			f[j][3]=(g[0]+g[1]+g[2]+g[8]+g[10])%mod;
			f[j][4]=(g[3]+g[4]+g[5]+g[7])%mod;
			f[j+1][5]=(g[4]+g[5]+g[7])%mod;
			f[j][6]=g[5];
			f[j][7]=(g[6]+g[7])%mod;
			f[j+1][8]=g[3];
			f[j][9]=g[8];
			f[j][10]=(g[9]+g[10])%mod;
		}
	}
	for(int i=m+2;i<=n+1;i++)
		res+=(f[i][0]+f[i][5]+f[i][8]);
	memset(f,0,sizeof(f));
	f[1][1]=1;
	for(int i=2;i<n;i++){
		memcpy(G,f,sizeof(G));
		memset(f,0,sizeof(f));
		for(int j=0;j<=n;j++){
			auto g=G[j];
			f[j+1][0]=(g[1]+g[2]+g[10])%mod;
			f[j][1]=g[0];
			f[j][2]=(g[1]+g[2])%mod;
			f[j][3]=(g[1]+g[2]+g[10])%mod;
			f[j][4]=(g[3]+g[4]+g[7])%mod;
			f[j+1][5]=(g[4]+g[7])%mod;
			f[j][6]=g[5];
			f[j][7]=(g[6]+g[7])%mod;
			f[j+1][8]=g[3];
			f[j][9]=g[8];
			f[j][10]=(g[9]+g[10])%mod;
		}
	}
	res+=(f[m][1]+f[m][2]+f[m][3]+f[m][4]+f[m][7]+f[m][10]);
	cout<<res%mod<<endl;
}
```





---

## 作者：Elegia (赞：14)

很多内容和兔子想的一样, 不过自认为对"每个序列只对应了唯一的单调栈大小"这一点的证明比较趣味, 所以还是把写的东西挂出来了.

-----

我们首先考虑 $m=1$ 的子任务如何解决. 这个时候, 我们其实就是希望知道有多少可构造的序列 $a$. 

序列 $a$ 首先看起来和 $f(p)$ 本身的值 (也即不去掉任何一个数时候的单调栈大小) 有着莫大的关系. 我们假设 $f(p)=l$, 首先, 计数所有的二元组 $\langle \{a\}, l \rangle$ 看起来是更简单的. 这里的意思是, 我们先对于每个 $l$ 把能构造出的 $\{a\}$ 的数量数出来, 这样显然是不漏的.

一个让人安心的事实是, 这样的数法实际上也是不重的, 通过打表可以发现每个可构造的序列 $\{a\}$ 只会对应于一个 $l$. 当然, 通过接下来对结构的讨论, 我们也会严谨地确认这一点.

对于所有不在单调栈上的位置 $i$, 我们发现删去它不会影响单调栈, 也就是必然有 $f(P_i) = l$. 对于那些在单调栈上的位置 $i$ 呢? 最坏情况, 就是到单调栈下一个元素之前没有任何数被加了进去, 这样的话就是 $f(P_i)=l-1$ 了. 而最好的情况则是到下一个元素之前刚好是全都可以加入的, 也就是说, 如果之间有 $d$ 个数, 那么最好情况就有 $f(P_i)=l-1+d$. 为什么这些之间的数都能达到呢? 一个比较直接的看法是注意到, 我们只关心排列的大小关系, 这实际上和 $n$ 个实数的大小关系是一样的, 所以我们可以随便插在我们需要的大小.

这个说法准确吗? 不完全. 特例是 $i=1$ 的情况. 如果 $d\geq 1$, 我们发现删去 $p_1$ 之后, 是一定会多出来至少一个单调栈里的元素的, 对于单调栈后面的则没有这个问题, 因为可以让暴露出来的值全都小于之前单调栈里的数. 接下来, 我们就得到了和 $l$ 有关的可构造序列的一个"精确"的刻画:

> 对于下标 $1=q_1 < q_2 <\dots < q_l < q_{l+1}=n+1$, 如果限制排列 $p$ 的单调栈的下标恰为 $q_1,\dots,q_l$, 那么这些排列给出的可构造的 $\{a\}$ 由如下笛卡尔积规则生成, 我们设 $d_i = q_{i+1} - q_i - 1$:
> - 对于 $j\neq q_i$ (不在单调栈上的数), 一定有 $a_j = l$.
> - 对于 $j = q_1 =1$, 如果 $d_1=0$, 那么 $a_1 = l-1$, 否则 $l\leq a_1\leq l - 1 + d_1$.
> - 对于 $i > 1$ 的 $j=q_i$, 有 $l-1\leq a_{j} \leq l-1+d_i$.

接下来我们看看为什么同一个 $a$ 不会对应于两个 $l$. 

考虑 $\sum (a_i-l)$ 的值域范围, 这就是 $-\sum 1 = -l$ 到 $\sum (d-1) = n - 2l$. 也就是说, $\sum a_i$ 的值域区间是 $[L_l, R_l] = [nl-l, nl+n-2l]$. 那么, 我们发现, $L_{l+1} - R_l = l-1$, 所以 $l>1$ 的区间是互不相交的, 而 $l=1$ 和 $l=2$ 之间唯一的交点是 $\sum a_i = 2n-2$, 这个情况在 $l=1$ 时候只能形如 $\{a\} = n-1,1,1,\dots,1$, 在 $n\geq3$ 的时候是不可能有 $l=2$ 的对应构造的. 这就说明了前文提到的, 可以通过打表验证的事实.

我们现在已经成功地给出了一个初步的刻画, 但是它距离我们想要进行计数, 还有些要注意的事项.

刚刚这个刻画所不足的地方在于, 不同的一组单调栈下标是有可能给出相同的序列的, 因为我们可以以一定的自由度重排那些明明满足 $a_i=l$ 却还在单调栈上的数. 为此, 我们可以考虑把 $l$ 的地位看淡. 转而考虑序列 $b_i = a_i - l$. 我们此时关心的是, 这样一个序列 $\{b\}$ 可以对应于多少个 $l$. 

这样一来, 首先 $b_i\neq 0$ 的必须在单调栈上, 但还有一个要考虑的就是 $b_1$ 的问题. 根据前面的刻画, 如果 $b_1 =-1$, 那此时就算 $b_2 =0$, 也必须让 $2$ 在单调栈中. 接下来对于一个大小为 $D$ 的间隔, 如果对应单调栈位置的 $b_i=d-1$, 那么我们可以利用这段区间插入尽量多的 $b_i=0$ 的单调栈, 其需要长度至少是 $2$, 因此这一段可以插至多 $\lfloor (D-d)/2\rfloor$ 个.

对于 $m=1$ 的情况, 我们不需要考虑 $a_i$ 的下界, 此时只需对每个可构造的 $\{b\}$ 序列, 设其能最多按照上面的方法插 $r$ 个 $b_i=0$ 的单调栈, 那么对答案的贡献是 $r+1$. 

我们先来尝试写出 $m=1$ 情况的生成函数. 除去单调栈里的第一个元素, 剩下每段的转移是一样的, 我们需要避免 $d=1$ 的情况 (因为这对应 $b_i=0$), 设 $x$ 计量段的长度, $y$ 计量可以额外插的数量, 那么一段的贡献是
$$ P(x, y) = \sum_{d\neq 1, D} x^{D+1}y^{\lfloor(D-d)/2\rfloor} = \frac{x(1+x)}{(1-x^2y)(1-x)} - \frac{x^2(1+x)}{1-x^2y}. $$

对于第一段, 我们按照 $b_1 = -1$ 与否分成两类讨论, 不过它们贡献都是一样的, 总贡献是
$$ Q(x, y) = \frac{2x^2(1+x)}{(1-x^2y)(1-x)}. $$

因此生成函数是
$$ F(x, y) = \frac{Q}{1-P} = -\frac{2 x^2 (x+1)}{x^4-x^3 y+x^2 y+2 x-1}. $$

我们关心的是
$$ F(x, 1) + \frac{\partial F}{\partial y}(x,1) = -\frac{2 x^2 (x+1) \left(x^4+2 x-1\right)}{\left(x^4-x^3+x^2+2 x-1\right)^2}. $$

所以, $m=1$ 的情况可以直接通过计算这个线性递推得到.

对于一般的 $m$, 我们需要考虑扩充我们记录的东西. 首先要记录我们总共用的段数, 此外, 还需要考虑是否存在 $b_i=-1$. 

我们先假设存在 $-1$, 之后再容斥掉从来没出现过 $-1$ 的情况. 
用 $t$ 计量段数. 我们只需令新的 $P$ 是原先的 $tP(x,y)$. 而 $Q$ 则是
$$ Q(x, y, t) = \frac{t(1+t)x^2(1+x)}{(1-x^2y)(1-x)}. $$
得到
$$ F(x, y, t) = \frac{Q}{1-P} = -\frac{t (t+1) x^2 (x+1)}{t x^4+t x-x^3 y+x^2 y+x-1}. $$
然后我们要把 $y^r$ 转换成 $1 + t + \cdots + t^r$, 也就是
$$ A = \frac{tF(x,t,t) - F(x,1,t)}{t-1} = -\frac{t (t+1) x^2 \left(t x^4+t x+x-1\right)}{\left(t x^3-(t+1) x^2+(t+2) x-1\right)
   \left(t x^4-t x^3+t x^2+t x+x-1\right)}. $$

然后考虑不存在 $-1$ 的, 我们有
$$P(x, y, t) = t\sum_{d\geq 2, D} x^{D+1}y^{\lfloor(D-d)/2\rfloor} = \frac{tx^3(1+x)}{(1-x^2y)(1-x)}, $$
以及
$$ Q(x, y, t) = \frac{tx^2(1+x)}{(1-x^2y)(1-x)}. $$
进而
$$ F = \frac{Q}{1-P} = -\frac{t x^2 (x+1)}{t x^4+x^3 (t-y)+x^2 y+x-1}, $$
进而
$$ B = \frac{tF(x,t,t) - F(x,1,t)}{t-1} =-\frac{t x^2 \left(t x^4+t x^3+x-1\right)}{\left(t x^3-x^2+2 x-1\right) \left(t x^4+t
   x^2+x-1\right)}. $$

我们最后的答案则是
$$ \frac{A-B}{t} +B, $$
它的 $x^nt^m$ 次项表示的是序列中出现的最小的数为 $m$ 的序列数量.

我们用上述的有理分式直接递推, 就可以在 $O(n^2)$ 时间内计算出答案了.

把上面提到的有理分式做分式分解, 就可以在 $O(n)$ 甚至 $O(\sqrt n\log n)$ 时间内计算出答案了.


---

## 作者：zhiyangfan (赞：9)

## P8554 心跳 题解
~~因为不会压缩状态只有 77pts 所以就不发题解了。~~

强大出题人多哥把时限改成了 $\tt 2s$，然后我过了，所以就发个题解吧。
### 题意
对于长为 $n$ 的数列 $p$，定义 $f(p)$：
$$f(p)=\sum_{i=1}^n\left[\max_{j=1}^i \{p_j\}=p_i\right]$$
即前缀最大值个数。对于数列 $p$，定义它的 $a$ 数组为：
$$a_i=f(\left<p_1,p_2,\cdots,p_{i-1},p_{i+1},\cdots,p_n\right>)$$
求有多少数组满足是至少一个数列的 $a$。答案对 $10^9+7$ 取模。
### 题解
这题巨大无敌神奇神秘逆天的一点就是建立双射。发现直接对 $a$ 计数巨大难，所以我们想找到一个比较简单的，便于计数的序列与 $a$ 建立双射关系。

一个神奇的思路是染色，或者说给 $a$ 中元素分类。我们先来观察一个数列：
$$[{\color{red}4},2,3,{\color{red}7},{\color{red}9},8,6,5]$$
其中标红的是前缀最大值位置，我们记它的个数为 $k$。如果去掉非红色点，显然个数不变，还是 $k$ 个。这样有：
$$a:[/,3,3,/,/,3,3,3]$$
去掉 $4$ 后，$2,3$ 会成为新的红色数，从而 $a_1=4$。类似地，有：
$$a:[{\color{red}4},3,3,{\color{red}2},{\color{red}3},3,3,3]$$ 
求的过程中，我们发现新的前缀最大值个数为 $k-1+x$，其中 $x$ 是后面新增加的红色数个数。从而可以得到红色位置 $a$ 的值域为 $[k-1,n]$。

从上面的讨论，我们可以把数分为三类，分别是：
- 红色：原来就是前缀最大值的位置。
- 绿色：删去红色点后可以成为前缀最大值的位置。
- 黄色：非红色绿色数。

注意到这个颜色序列只有 $3$ 种元素，如果颜色序列和 $a$ 之间真的有双射，那么对颜色序列计数显然要更简单。定义有 $a$ 对应的颜色序列为合法的。

双射是怎么构建起来的？$a$ 唯一对应合法颜色序列，和合法颜色序列唯一对应 $a$。最后还要证明所有合法的颜色序列对应到的 $a$ 为对应至少一个 $p$。

由合法颜色序列唯一对应 $a$ 比较好证，我们给出由合法颜色序列构造出 $a$ 的方法。首先确定 $k$，它就是红色数的个数。将所有不为红色的数的值设置为 $k$。红色点的数设置为 $k-1+x$，其中 $x$ 表示它后面连续的绿色点个数。

而 $a$ 唯一对应合法颜色序列就牵扯到我们对合法颜色序列的定义了。刚刚我们是已知 $p$ 构造的颜色序列，在未知 $p$ 的时候，我们想要定义一个规则，使得唯一对应条件满足。因为合法颜色序列唯一对应 $a$，所以我们可以假装我们知道 $k$ 是多少了（反正这个 $k$ 是唯一的，假设知道并不影响证明）。对于所有 $\ne k$ 的位置 $a_i$，我们标上红色，并把后面的 $a_i-k+1$ 个位置标为绿色。假设这样确定了 $w$ 个红色点，还差 $k-w$ 个，显然要放进去 $k-w$ 个红绿连续点对，尽量往前放即可。最后还没有颜色的位置标为黄色。

接下来是 $a$ 对应一个 $p$ 的问题。我们尝试用颜色序列构造一个 $p$。对于绿色点，它应该满足小于上一个红和大于上上一个红，对于黄色点，它应该满足小于上一个绿或上上一个红。这样一定可以根据这些条件构造出满足条件的 $p$。

接下来，就是根据上面产生合法颜色序列的方法，讨论合法颜色序列应该满足什么条件了。

- 因为红绿要尽可能往前放，所以红绿前面不能存在黄黄，否则可以交换。
- 类似地，如果存在黄红绿[非绿/结尾]，也不合法，可以换为红绿黄[非绿/结尾]。
- 绿色前面不可能是黄色，因为新产生的前缀最大值一定是紧跟红色的一段区间。
- 第一个数一定是红色，第二个数不可能是黄色。原因显然。

然后我们再看看前面的构造，似乎也没别的限制了。那就做 $\rm dp$ 吧。在做之前，我们还要考虑 $a$ 值域的限制，显然 $k-1\le \min a\le k$。当某个红色后不存在绿色时，$\min a=k-1$，否则 $\min a=k$。。

想想为了这些条件需要知道当前状态的什么信息。显然知道前三个颜色是什么和是否出现黄黄就够了。而为了统计答案我们还要记录是否存在某个红色后不存在绿色和红色的个数。这一共是 $3^3\times 2\times 2\times n=108n$ 种状态。可以再压缩，但我不太会了。转移也比较简单，只需考虑当前填这个颜色会不会破坏条件就行了，具体见代码。这里有点细节就是最后统计答案的时候也要判断一下前两个条件。

时间复杂度 $\mathcal{O}(n^2)$。~~但因为高达 108 的常数寄了。~~ 又活过来了。
```cpp
#include <cstdio>
#include <cstring>
// 填到第几个了 | 有没有黄黄 | 有没有不接绿色的红色 | 前三个的颜色 | 有多少红色 
const int N = 2e3 + 10, mod = 1e9 + 7; int f[2][2][2][27][N]; 
// x,y,z 分别为 i,i-1,i-2 的颜色，0,1,2 分别为红绿黄
inline int S(const int& x, const int& y, const int& z) { return x + y * 3 + z * 9; }
inline int S1(const int& S) { return S % 3; }
inline int S2(const int& S) { return S / 3 % 3; }
inline int S3(const int& S) { return S / 9 % 3; }
inline int add(const int& S, const int& x) { return S % 9 * 3 + x; }
int main()
{
	int n, m; scanf("%d%d", &n, &m);
	int now = 0;
	// 绿色前面不能是黄色，黄黄后不存在红绿x，也不存在黄红绿x，第一个是红，第二个不是黄
	f[0][0][1][S(0, 0, 0)][3] = f[0][0][1][S(1, 0, 0)][2] = f[0][0][1][S(2, 0, 0)][2] = 1;
	f[0][0][0][S(0, 1, 0)][2] = f[0][0][0][S(1, 1, 0)][1] = f[0][0][0][S(2, 1, 0)][1] = 1;
	for (int j = 4; j <= n; ++j)
	{
		now ^= 1; memset(f[now], 0, sizeof (f[now]));
		for (int o = 1; o < j; ++o)
			for (int p = 0; p < 2; ++p)
				for (int q = 0; q < 2; ++q)
					for (int i = 0; i < 27; ++i)
					{
						if (!f[now ^ 1][p][q][i][o]) continue;
						int t = f[now ^ 1][p][q][i][o];
						for (int l = 0; l < 3; ++l)
						{
							if (S1(i) == 2 && l == 1) continue;
							if (p && S1(i) == 1 && S2(i) == 0 && l != 1) continue;
							if (S1(i) == 1 && S2(i) == 0 && S3(i) == 2 && l != 1) continue;
							(f[now][p || (S1(i) == 2 && l == 2)][q || (S1(i) == 0 && l != 1)][add(i, l)][o + !l] += t) %= mod;
						}
					}
	}
	int ans = 0;
	for (int p = 0; p < 2; ++p)
		for (int q = 0; q < 2; ++q)
			for (int i = 0; i < 27; ++i)
				for (int j = 1; j <= n; ++j)
				{
					if (i == S(1, 0, 2) || (p && S1(i) == 1 && S2(i) == 0)) continue;
					if (j - (q || (S1(i) == 0)) < m) continue;
					(ans += f[now][p][q][i][j]) %= mod;
				}
	printf("%d\n", ans); return 0;
	return 0;
}
```

---

## 作者：QuantAsk (赞：8)

好像说没有重复的做法，那我就来水一下题解。感觉这个做法相对来说思维难度没那么大，比较清明。

先不考虑 $m$ 的限制。

我们考虑前缀最大值的个数，假设其为 $k$ 。当我们修改一个非前缀最大值时 $f(p)=k$ ，当我们修改一个前缀最大值时，假设这个前缀最大值与下一个前缀最大值之间有 $len$ 个数，那么 $f(p)\in[k-1,k-1+len]$ 。

然后限制是要求至少有 $n-k$ 个数值为 $k$ ，我们考虑使用 $dp$ 来计数，一个朴素的想法是设 $f_{i,j}$ 表示现在计数到第 $i$ 个，目前已经钦定了 $j$ 个位置作为前缀最大值。

那么就有转移方程
$$
f_{i,j}=\sum_{k=1}^i f_{k,j-1}\times (j-k)
$$
这个可以转移方程用前缀和优化，但是这样显然会重复计数，因为值为 $k$ 的位置既可以作为前缀最大值也可以不作为前缀最大值。

那假设对于一个序列 $a$ 我们要选够 $k$ 个位置作为前缀最大值，要让选择的方式唯一那么我们一个不错的想法是能尽量往前选就尽量往前选。

换而言之我们倒过来 $dp$ ，然后把过程 $dp$ 过程分为两个部分，前一个部分中所有的 $a_i=k$ 的值的位置都不作为前缀最大值，后一个部分中尽量选取最多的 $a_i=k$ 的部分作为前缀最大值。

然后后一个部分可以从前一个部分中转移过来就好了。

实现起来细节比较多。

然后考虑 $m$ 的限制也很简单，最后我们要求选择的前缀最大值的数量不小于 $m$ 即可。需要注意的是统计 $k=m$ 的情况时，前面 $f(p)\in[k-1,k-1+len]$ 这个条件就不适用了，我们应该改成 $f(p)\in[k,k-1+len]$ 作为条件再进行一次类似的 $dp$ 。

时间复杂度：$O(n^2)$

最后贴个code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const ll N=2100,P=1e9+7;
ll n,m,f[N][N],sf[N][N],s[N][N],g[N][N],ans[N];
signed main()
{
	scanf("%lld%lld",&n,&m);f[0][n+1]=1;
	for(ll i=0;i<=n+1;i++)sf[0][i]=1;
	for(ll i=1;i<=n;i++){
		ll sum=0;
		for(ll j=n;j>=1;j--){
			if(j!=1)(sum+=sf[i-1][j+2])%=P;
			f[i][j]=(f[i-1][j+1]+sum)%P;
			sf[i][j]=(sf[i][j+1]+f[i][j])%P; 
		}
	}
	for(ll i=1;i<=n;i++){
		ll sum=0,buf=0;
		for(ll j=n;j>=1;j--){
			buf=(buf+f[i-1][j+2])%P;
			s[i][j]=(s[i-1][j+2]+buf)%P;
			g[i][j]=(g[i-1][j+2]+g[i-1][j+1]+s[i-1][j+1])%P;
			if(j!=1)(g[i][j]+=g[i-1][j+2])%=P;
			(sum+=s[i-1][j+3]+g[i-1][j+3]+g[i-1][j+4])%=P;
			(g[i][j]+=sum)%=P;
		}
	}
	ll sum=0;
	for(ll i=m+1;i<=n;i++){
		ans[i]=(f[i][1]+g[i][1]+s[i][1])%P;
		(ans[i]+=g[i-1][4]+g[i-2][5])%=P;
		(sum+=ans[i])%=P;
	//	printf("%d\n",ans[i]);
	}
		
	if(m!=0){
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		memset(s,0,sizeof(s));
		memset(sf,0,sizeof(sf));
		memset(ans,0,sizeof(ans));
		f[0][n+1]=1;
		for(ll i=0;i<=n+1;i++)sf[0][i]=1;
		for(ll i=1;i<=n;i++){
			ll sum=0;
			for(ll j=n;j>=1;j--){
				(sum+=sf[i-1][j+3])%=P;f[i][j]=sum;
				sf[i][j]=(sf[i][j+1]+f[i][j])%P; 
			}
		}
		for(ll i=1;i<=n;i++){
			ll sum=0,buf=0;
			for(ll j=n;j>=1;j--){
				buf=(buf+f[i-1][j+2])%P;
				s[i][j]=(s[i-1][j+2]+buf)%P;
				(sum+=s[i-1][j+3]+g[i-1][j+3]+g[i-1][j+4])%=P;
				g[i][j]=(g[i-1][j+2]+sum)%P;
			}
		}
		sum=(sum+f[m][1]+g[m][1]+s[m][1]+g[m-1][4])%P;
	}
	printf("%lld\n",sum);
	return 0;
}

```

---

## 作者：whiteqwq (赞：6)

[P8554 心跳](https://www.luogu.com.cn/problem/P8554) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16728162.html)

## 题意

定义一个排列上的函数 $f(p,i)$ 表示序列 $p$ 去除 $i$ 位置后前缀最大值个数。对于所有长度为 $n$ 的排列 $p$，生成序列 $a_i=f(p,i)$。试计数值域 $[m,n]$，且能被生成的 $a$ 序列数量。

$1\leqslant m\leqslant n\leqslant 2000$。

## 分析

hzr 场切了，有点恐怖的。

下面记 $g(p)$ 为不去除任何位置的前缀最大值个数。

首先有一个结论，对于两个 $g$ 不相等的排列，其生成的 $a$ 序列不可能有交。

经过初步地观察，我们能得知：

- 若去除的位置不是前缀最大值，$f(p,i)=g(p)$；
- 否则，$f(p,i)$ 为 $i$ 后面大于 $[1,i-1]$ 所有数的单调栈大小加 $g(p)-1$。

于是我们可以将序列里的数分成三个部分：前缀最大值，可能成为前缀最大值的数（下文称其为有用的数），其他。

将排列按照前缀最大值划分成若干段，那么前缀最大值的 $f(p,i)$ 就是其对应段有用的数数量加上 $g(p)-1$。

我们并不关心有用的数的位置，只关心其数量，于是可以将一段内所有有用的数保留顺序提前，然后生成一个仅包含 $\{0,1,2\}$ 的序列，$0$ 对应前缀最大值，$1$ 对应有用的数，$2$ 对应没用的数。（称这种序列为颜色序列）

我们想直接 dp 来计数颜色序列，但必须先知道任意颜色序列是否都存在一个对应的排列 $p$。

考虑一种排列的生成方式：从前往后加入数字，维护目前前缀 $[1,i]$ 离散化后的结果，每次插入一个 $[1,i+1]$ 内的数字并将大于等于其的数字加一（其实就是在值域上插入数字）。那么插入 $i+1$ 就对应插入一个 $0$，插入 $i$ 就对应插入一个 $1$，否则就是插入一个 $2$。

只需保证第一个位置是 $0$，第二个位置是 $0/1$ 即可。

但是不同的颜色序列可能对应相同的 $a$ 序列，算重的原因实际上就是 $201\text{x}$ 与 $012\text{x}$ 等价，以及 $01\text{x}$ 与 $22$ 等价（$\text{x}=\{0,2\}$），于是我们只需保证序列中不存在 $201\text{x}$ 子段与 $22$ 后的 $01\text{x}$ 子段即可。

令 $f_{i,j,0/1/2/3,0/1/2}$ 表示 dp 了 $i$ 个位置，前缀最大值个数为 $j$，上一个为 $0$、$1$（长度 $=1$）、$1$（长度 $>1$）、$2$，无限制、当前段不能只有 $1$ 个 $1$，后面所有段不能只有 $1$ 个 $1$，直接转移即可。

$m$ 的限制很好处理，要么前缀最大值数量大于 $m$，要么前缀最大值数量等于 $m$ 且没有一个前缀最大值段没有有意义的数，随便改改转移方程就好了。

复杂度 $O(n^2)$。

## 代码

写不动，借鉴了官方题解的波特状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/rshc1xwz.png)

```cpp
#include<stdio.h>
#include<string.h>
const int maxn=2005,mod=1000000007;
int n,m,ans,now;
int f[2][maxn][11],g[11],h[11];
void solve(int typ){
	now=0,f[0][1][1]=1;
	if(typ==0)
		f[0][2][0]=1;
	for(int i=3;i<=n;i++){
		now^=1,memset(f[now],0,sizeof(f[now]));
		for(int j=1;j<=i;j++){
			for(int c=0;c<=10;c++){
				g[c]=f[now^1][j][c];
				if(typ&&(c==0||c==5||c==8))
					g[c]=0;
			}
			h[0]=h[3]=(0ll+g[0]+g[1]+g[2]+g[8]+g[10])%mod;
			h[1]=f[now^1][j][0],h[2]=(g[1]+g[2])%mod;
			h[4]=(0ll+g[3]+g[4]+g[5]+g[7])%mod;
			h[5]=(0ll+g[4]+g[5]+g[7])%mod;
			h[6]=f[now^1][j][5],h[7]=(g[6]+g[7])%mod;
			h[8]=g[3];
			h[9]=f[now^1][j][8],h[10]=(g[9]+g[10])%mod;
			for(int c=0;c<=10;c++){
				int nxt=j+(c==0||c==5||c==8);
				f[now][nxt][c]=(f[now][nxt][c]+h[c])%mod,h[c]=0;
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	solve(0);
	for(int i=m+1;i<=n;i++)
		for(int c=0;c<=10;c++)
			if(c!=6&&c!=9)
				ans=(ans+f[now][i][c])%mod;
	memset(f,0,sizeof(f));
	solve(1);
	for(int c=0;c<=10;c++)
		if(c!=0&&c!=5&&c!=6&&c!=8&&c!=9)
			ans=(ans+f[now][m][c])%mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Dovish (赞：4)

## 前言
省流：多头出的题被 forest 组成模拟赛喂给联考被出来外培的我给吃了。

鉴定为师出同门导致脑电波对上了。

## 思路

容易发现和原本的前缀最大值关系密切。

具体而言，一个位置 $i$ 是前缀最大值，那么其会对所有不等于 $i$ 的位置上的 $a$ 做贡献。否则，这个位置是之前某个位置删除之后新增的前缀最大值。容易发现对于一个点 $j$，其作为新增的前缀最大值，只可能贡献到其之前的第一个前缀最大值 $i$ 的 $a$ 数组上。

~~然后通过打表猜测~~在 $n>2$ 时，一个合法的序列 $a$ 的所有可能的来源的 $p$ 的前缀最大值数量是相同的。实际上也的确如此，证明不会。（注意 $n>2$ 时成立。）

继续观察，假设当前 $a$ 数组对应的 $p$ 的前缀最大值个数是 $k$，且我们知道了 $p$ 的前缀最大值的位置集合 $S$。而这些位置在 $a$ 上的值能取到多少能？假设当前位置到下一个前缀最大值之间的空位个数为 $x$，则当前位置合法的取值范围是 $[k-1,k-1+x]$。（corner：当前位置是 $1$ 且 $x\not=0$，则取值范围是 $[k,k-1+x]$。）

> 证明：只考虑值的相对大小地插入排列的元素，首先将前缀最大值插入到序列的对应位置上，两个前缀最大值之间的位置只对前者做贡献，且可以通过在当前前缀最大值和上一个前缀最大值的值域之间插入元素 （注意这里也解释了 corner 的原因）所以可以任意调整每一个位置是否做贡献。

我们选取当前位置之后连续的一段非前缀最大值作为删去当前节点之后新增贡献的位置，并将当前位置和其之后这些被选取的位置称为一段。则 $a$ 数组可以表示为若干个互不相交的段。但是注意当段长为 $2$ 时，这一段的起始元素在 $a$ 上是 $k$，无法和其他平凡的位置区分开，一个 $a$ 可能对应多种划分方式，故无法直接构成双射。

不过解决方式很简单，我们在考虑完所有长度不是 $2$ 的线段之后，让这些长度为 $2$ 的线段尽可能地靠前即可。

于是我们现在就可以用一个不交线段的覆盖方式来表示 $a$ 了！

那么对前者计数就容易计数出合法的 $a$ 的数量。

至于对于值域的限制，显然，当我们选取的段数 $>m$ 时，$a$ 的值域一定 $\ge m$。否则恰好选择 $m$ 段且不存在单独的一段时值域 $\ge m$。

~~讲到这里其实读者随便列个 dp 就能做出来了。下文是我的考场做法。~~

考虑设 $dp_{i,j,0/1,0/1}$ 表示考虑了前 $i$ 位，此时已经填了 $j$ 个线段了，决定当前位置之后还能否继续填长度为 $2$ 的段，上一段是否是长度为 $2$ 的段。

如果还可以填长度为 $2$ 的段则转移是平凡的。

否则只能新增一段 $len\not=2$ 的段，（前缀和优化）或者填一个空位。

如果当前结尾不是填的 $2$ 的段，则转移是平凡的。

否则，可以直接填或者空一位填长度 $\not=2$ 的段。如果还可以继续填长度为 $2$ 的段，则可以填长度为 $2$ 的段。

然后再写一个 $dp$ 处理不能有长度为 $1$ 的段的情况。

还要注意如果 $1$ 开头的段长度为 $1$，则下一位不能是空位。（对应前文提到的corner。）

还要注意代码中是在填完一个长度为 $2$ 的段之后决定是否还能继续填，所以初始化为 $dp_{0,0,0,0}=dp_{0,0,1,0}=1$。

## code

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define per(i,a,b) for(register int i=(a);i>=(b);--i)
#define pii pair<int,int>
#define mp make_pair
#define pb push_back
#define fst first
#define sed second
#define Max(a,b) (a=max(a,b))
#define Min(a,b) (a=min(a,b))
using namespace std;
const int N=7000+10,M=1e6+10,inf=1e9,mod=1e9+7;
bool MS;int used;
struct modint{
...//取模类
};
int n,m;
modint f[5][N][2][2];//驻波的第三维的状态好像和上文描述的是反的。>_<
modint sum[5][N][2][2];
modint sum_[N][2][2];
modint sol(int m)
{
	memset(f,0,sizeof f);
	memset(sum,0,sizeof sum); 
	sum[0][0][0][0]=f[0][0][0][0]=1;
	sum[0][0][1][0]=f[0][0][1][0]=1;
	rep(i,1,n)
	{
		int c=i%5;
		rep(j,0,i)
		rep(k,0,1)
		rep(l,0,1)
		f[c][j][k][l]=
		sum[c][j][k][l]=0;
		
		rep(j,1,i)
		{
			if(i-3>=0)
			{
				f[c][j][0][0]+=sum[(i-3)%5][j-1][0][0];
				f[c][j][0][0]+=sum[(i-3)%5][j-1][0][1];
					
				f[c][j][1][0]+=sum[(i-3)%5][j-1][1][0];
				f[c][j][1][0]+=sum[(i-3)%5][j-1][1][1];
			}
			if(i>=6)
			{
				f[c][j][0][0]+=sum[(i-4)%5][j-1][0][0]-sum_[j-1][0][0];
				f[c][j][0][0]+=sum[(i-4)%5][j-1][0][1]-sum_[j-1][0][1];
				
				f[c][j][1][0]+=sum[(i-4)%5][j-1][1][0]-sum_[j-1][1][0];
				f[c][j][1][0]+=sum[(i-4)%5][j-1][1][1]-sum_[j-1][1][1];
			}
			if(i>=2)
			{
				f[c][j][0][1]+=f[(i-2)%5][j-1][0][0];
				f[c][j][0][1]+=f[(i-2)%5][j-1][0][1];
				
				f[c][j][1][1]+=f[(i-2)%5][j-1][0][0];
				f[c][j][1][1]+=f[(i-2)%5][j-1][0][1];
				
				if(i!=3)
				f[c][j][1][1]+=f[(i-2)%5][j][1][0];
				f[c][j][1][1]+=f[(i-2)%5][j][1][1];
			}
		}
		rep(j,0,i)
		rep(k,0,1)
		rep(l,0,1)
		sum[c][j][k][l]=sum[(i-1)%5][j][k][l]+f[c][j][k][l];
		if(i==1)
		rep(j,0,i)
		rep(k,0,1)
		rep(l,0,1)
		sum_[j][k][l]=sum[i][j][k][l];
	}
	modint ans=0;
	ans+=f[n%5][m][1][0]+f[n%5][m][1][1];
	ans+=f[(n-1)%5][m][1][0]+f[(n-1)%5][m][1][1];
	return ans; 
}
bool MT;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	sum[0][0][0][0]=f[0][0][0][0]=1;
	sum[0][0][1][0]=f[0][0][1][0]=1;
	rep(i,1,n)
	{
		int c=i%5;
		rep(j,0,i)
		rep(k,0,1)
		rep(l,0,1)
		f[c][j][k][l]=
		sum[c][j][k][l]=0;
		
		rep(j,1,i)
		{
			if(i-3>=0)
			{
				f[c][j][0][0]+=sum[(i-3)%5][j-1][0][0];
				f[c][j][0][0]+=sum[(i-3)%5][j-1][0][1];
					
				f[c][j][1][0]+=sum[(i-3)%5][j-1][1][0];
				f[c][j][1][0]+=sum[(i-3)%5][j-1][1][1];
			}
			if(i>=6)
			{
				f[c][j][0][0]+=sum[(i-4)%5][j-1][0][0]-sum_[j-1][0][0];
				f[c][j][0][0]+=sum[(i-4)%5][j-1][0][1]-sum_[j-1][0][1];
				
				f[c][j][1][0]+=sum[(i-4)%5][j-1][1][0]-sum_[j-1][1][0];
				f[c][j][1][0]+=sum[(i-4)%5][j-1][1][1]-sum_[j-1][1][1];
			}
			f[c][j][0][0]+=f[(i-1)%5][j-1][0][0];
			f[c][j][0][0]+=f[(i-1)%5][j-1][0][1];
			f[c][j][1][0]+=f[(i-1)%5][j-1][1][0];
			f[c][j][1][0]+=f[(i-1)%5][j-1][1][1];
			if(i>=2&&i!=3)
			f[c][j][0][0]+=f[(i-2)%5][j-1][0][1],
			f[c][j][1][0]+=f[(i-2)%5][j-1][1][1];
			if(i>3)
			f[c][j][0][0]+=f[(i-2)%5][j-1][0][0],
			f[c][j][1][0]+=f[(i-2)%5][j-1][1][0];
			
			if(i>=2)
			{
				f[c][j][0][1]+=f[(i-2)%5][j-1][0][0];
				f[c][j][0][1]+=f[(i-2)%5][j-1][0][1];
				
				f[c][j][1][1]+=f[(i-2)%5][j-1][0][0];
				f[c][j][1][1]+=f[(i-2)%5][j-1][0][1];
				
				if(i-2!=1)
				f[c][j][1][1]+=f[(i-2)%5][j][1][0];
				f[c][j][1][1]+=f[(i-2)%5][j][1][1];
			}
		}
		
		rep(j,0,i)
		rep(k,0,1)
		rep(l,0,1)
		sum[c][j][k][l]=sum[(i-1)%5][j][k][l]+f[c][j][k][l];
		if(i==1)
		rep(j,0,i)
		rep(k,0,1)
		rep(l,0,1)
		sum_[j][k][l]=sum[i][j][k][l];
	}
	modint ans=0;
	rep(i,m+1,n)ans+=f[n%5][i][1][0]+f[n%5][i][1][1];
	rep(i,m+1,n)ans+=f[(n-1)%5][i][1][0]+f[(n-1)%5][i][1][1];//考虑空位 
	ans+=sol(m);
	cout<<ans<<'\n'; 
	cerr<<"Memory:"<<(&MS-&MT)/1048576.0<<"MB Time:"<<clock()/1000.0<<"s\n";
}//因为模拟赛的题要卡空间开滚动所以看起来有点丑
```

[这里是一份带注释的没有前缀和优化的代码，方便理解。](https://www.luogu.com.cn/paste/uocwu78g)

第一次写这么牛的题的题解，如果有没讲清楚的地方欢迎指出。

---

## 作者：Qiuly (赞：3)

考虑对于一个 $a_{[1,n]}$ 怎么构造：首先，$a$ 一定唯一对应一个 $k$（前缀最大值个数）。对于 $a_i=k-1$，单独成段；对于 $a_i>k$，后面要接上 $a_i-k+1$ 个 $k$，成一段（类似 `51234` 这种）；对于 $a_i=k$，可以和后一个 $a_i=k$ 成段，也可以废弃。再做完所有 $a_i\not=k$ 后，贪心地划 $a_i=k$ 的段，如果能到 $k$ 个，就合法。否则非法。

于是 DP 记 $f_{i,j,0/1,0/1/2}$ 表示 $[1,i]$ 有 $j$ 段，是否有过 $k-1$（为了考虑下界），$a_{i}\not= k$ 且从未 ban / $a_{i}=k$ 且未 ban / $k$ 已 ban（这里说的 ban 是指，如果存在连续两个单独的 $a_i=k$，后面就不能划 $a_i,a_{i+1}=k$ 的段了，否则会算重）。转移时讨论一下即可，如果第四维非 $0$ 就不能接 $a_i,a_{i+1}=k$ 的段。前缀和优化。

复杂度还是 $O(n^2)$，不过常数好像小很多。

```cpp
//
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define debug(...) fprintf (stderr, __VA_ARGS__)

#define fi first
#define se second
#define lep(i, l, r) for (int i = (l), i##_end = (r); i <= i##_end; ++ i)
#define rep(i, r, l) for (int i = (r), i##_end = (l); i >= i##_end; -- i)

char __c; bool _f; template <class T> inline void IN (T & x) {
    _f = 0, x = 0; while (__c = getchar (), ! isdigit (__c)) if (__c == '-') _f = 1;
    while (isdigit (__c)) x = x * 10 + __c - '0', __c = getchar (); if (_f) x = -x;
}

template <class T> inline void chkmin (T & x, T y) { if (x > y) x = y; }
template <class T> inline void chkmax (T & x, T y) { if (x < y) x = y; }

const int mod = 1e9 + 7;

inline int mul (int x, int y) { return 1ll * x * y % mod; }
inline int qpow (int x, int y, int r = 1) { for ( ; y; y >>= 1, x = mul (x, x)) if (y & 1) r = mul (r, x); return r; }

inline void sub (int &x, int y) { x -= y; if (x < 0) x += mod; }
inline void pls (int &x, int y) { x += y; if (x >= mod) x -= mod; }
inline int dec (int x, int y) { x -= y; if (x < 0) x += mod; return x; }
inline int add (int x, int y) { x += y; if (x >= mod) x -= mod; return x; }

const int N = 2e3 + 5;

int n, m;
int f[4][N][6], nxt[6];

signed main () {
	IN (n), IN (m);

	lep (o, 0, 5) {
		int a = o & 1, b = o >> 1;
		nxt[o] = a | ((b - (b == 1)) << 1);
	}

	int cur = 2, ls1 = 1, ls2 = 0, rec = 3;
	lep (i, 1, n) {
		(cur += 1) %= 3, (ls1 += 1) %= 3, (ls2 += 1) %= 3;
		memset (f[cur], 0, sizeof f[cur]), f[cur][1][i == 1] = 1;

		lep (k, 1, i - 1) lep (o, 0, 5) {
			int a = o & 1, b = o >> 1;

			pls (f[cur][k + 1][nxt[o] | 1], f[ls1][k][o]);
			if (i == 2) continue ;
			pls (f[cur][k][a | (min (2, b + 1) << 1)], f[ls1][k][o]);
		}
		lep (k, 1, i - 2) lep (o, 0, 1) pls (f[cur][k + 1][o], f[ls2][k][o]);
		lep (k, 1, i - 3) lep (o, 0, 5) pls (f[cur][k + 1][nxt[o]], f[rec][k][o]);
		lep (k, 1, i - 2) lep (o, 0, 5) pls (f[rec][k][o], f[ls2][k][o]);
	}

	int ret = 0;
	lep (j, m, n) lep (o, 0, 5) {
		if (j - (o & 1) >= m) pls (ret, f[cur][j][o]);
	}
	printf ("%d\n", ret);
    return 0;
}
```

---


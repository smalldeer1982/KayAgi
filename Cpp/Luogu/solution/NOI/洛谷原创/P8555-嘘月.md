# 嘘月

## 题目背景

“我早已认不出你的眼睛，也没有在想念你的面容；

你还是没有说出再见，就化作黑夜离开了。”

[赫尔德看着潮水](https://baike.baidu.com/item/%E4%B8%A5%E7%95%AF/23345630?fr=aladdin)，忽觉这不断上涨的潮水就像是持续上升的热情，它维持着热恋的时间，而激动的情绪又带给我们更多的热情。但是初识的热情终会逐渐平淡，又有多少人能在冷却的心跳中找到其中不变的节奏，走完这一生呢？

## 题目描述

赫尔德想对上面的问题进行探究，她想先做一些统计，于是她抽象了这个问题。

对于一个长为 $n$ 的排列，我们维护一个下标 $t$，初始 $t=m$。

重复以下过程：

- 从下标在 $1\sim t$ 的元素中选一个没标记过的，并将其标记。若标记的数比上一次标记的数大且 $t<n$，则 $t$ 自增 $1$；否则结束此过程。在你进行第一次标记前，上一次标记的数视为 $0$。

我们称这样的排列是好的：

- 存在某种方法，使得在经过若干次操作后，$t=n$。

现在，给定 $m$，求长为 $n$ 的好的排列在所有长为 $n$ 的排列中所占比例，对 $998244353$ 取模。换言之，若长为 $n$ 的好的排列一共有 $x$ 个，你需要输出 $\frac x{n!}$ 取模 $998244353$ 的结果。如果你不理解有理数的取模，可以看[这道题目](/problem/P2613)。

有 $q$ 次询问，每次给出一个 $m$。

## 说明/提示

**【样例解释 \#1】**

可以使得 $t=n$ 的排列的数量分别为 $5,90,120$，排列总共有 $5!=120$ 种，所以分别需要输出 $\frac{5}{120},\frac{90}{120},\frac{120}{120}$。取模后即为样例输出中的答案。

$m=1$ 时，以下是所有可以使得 $t=n$ 的排列：

$$ \{1,2,3,4,5\},\{2,3,4,5,1\},\{1,3,4,5,2\},\{1,2,4,5,3\},\{1,2,3,5,4\} $$

$m=2$ 时，列出了一些可以使得 $t=n$ 的排列：

$$ \{1,4,2,3,5\},\{1,5,4,3,2\} $$

和一些不能使得 $t=n$ 的排列：

$$ \{5,4,3,2,1\},\{3,5,2,1,4\} $$

---

**【数据范围】**

保证 $1\le q\le n\le 10^5$，$1\leq m_i \leq n$，询问的 $m_i$ 互不相同且升序排列。

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c|c}\hline 
\textbf{子任务编号}&\bm{~~~~~~~n\le~~~~~~~}&\textbf{~~~特殊限制~~~}&\textbf{~~分数~~}\cr\hline 
\textsf1 & 5 &&7\cr\hline 
\textsf2 & 200&&23\cr\hline 
\textsf3 & 2\times 10^4 &m_i=1& 9\cr \hline 
\textsf4 & 2\times 10^4 &2m_i\ge n& 3\cr \hline 
\textsf5 & 2\times 10^4 &&12\cr\hline 
\textsf6 &  &q=1&36\cr\hline 
\textsf7 &  &&10\cr\hline 
\end{array}
$$

提示：$O(n^2)$ 能跑挺多点的。


## 样例 #1

### 输入

```
5 3
1 2 3
```

### 输出

```
291154603
249561089
1
```

## 样例 #2

### 输入

```
50 5
4 7 9 14 17
```

### 输出

```
344293672
864377042
192544332
688054502
97923957
```

# 题解

## 作者：dottle (赞：14)

### ⚠警告：题解非常摧毁本题的思考体验，作者强烈建议您先思考完题再来看题解

### 题目简述

对于一个排列，我们维护一个指针 $t$，初始为 $m$，每次从 $1\sim t$ 的元素中选一个没删过的删掉，若删掉的比上一个大且 $t<n$，则 $t$ 自增 $1$，否则结束此过程。你希望使得 $t=n$，且会使用最优的策略。

对于所有排列，求可以使得 $t=n$ 的概率，对 $998244353$ 取模。多次询问，每次给出一个 $m$。

### 构建映射

首先，明确一点。我们总是会标记比上一次标记的大的最小的那个数，如果没有比就寄了。

为了方便直观理解，我们把 $i$ 当作大小为 $i$ 的积木，删掉一个数就把他搭在地上，当我们寄掉的时候，将那些 $1\sim t$ 的还没标记的数按照原排列中的顺序搭起来。最后我们会搭出一个积木塔。

**我们考虑 $\bm{t\ne n}$ 的概率**，这一点非常重要。如果你认为后文的积木塔还可能有其他的形态，请再思考一下这句话。后文 $(\star)$ 性质用到了这一性质。

先来考虑 $m=1$ 时我们搭出来的积木塔长啥样：不断增大，在最后一个位置减小 $(\star)$。我们称这个形态为“**基本积木塔**”。这里如果不保证没取完的话，有可能整个数列都是递增的，就不好办了。

![img](https://cdn.luogu.com.cn/upload/image_hosting/vuyl0w4a.png)

再来考虑 $a_i=2$ 时候长什么样子。我们对于一个例子来分析：对于 $\{1,4,2,8,5,7,3,6,9,10\}$，我们搭出来应该是 $\{1,2,4,5,7,8,3,6\}$。我们还是把塔画出来，然后给塔染色：

1.  对于原序列的前 $m$ 个积木，染上不同的颜色。
2.  若我们搭了一个颜色的积木 $c$ 后，指针新移动到的位置对应的积木也染成 $c$。
3.  为每个颜色确定标号，倒数第 $m$ 个积木的颜色编号为 $1$，倒数第 $m-1$ 个染成 $2$，以此类推，最后一个积木染色成 $m$。

![img](https://cdn.luogu.com.cn/upload/image_hosting/3pzm1dcf.png)

右边是染色后的结果。蓝色为 $1$，粉色为 $2$。值得注意的是，因为我们新移动到的数的颜色与我们标记的颜色相同，因此在每个时刻，我们手上每个颜色的数都有恰好一个。

我们染色的目的是展示这样一个事实：

-   一个数列对应的 $m=2$ 的塔可以唯一划分为两个 $m=1$ 的塔，并为他们确定标号。
-   两个确定好标号的 $m=1$ 的塔也能唯一归并出一个已染色的 $m=2$ 的塔。归并的方式是，每个塔除去最后一块的部分，按照大小排序；每个塔的最后一块，按照标号排序。

然后，我们再来讨论原数列与已染色的 $m=2$ 的塔的对应关系，我们已经介绍了通过数列唯一构造已染色的塔的方法了，我们再来考虑用塔构造数列前 $l$ 项的方法（$l$ 是塔的高度）。

1.  根据各个颜色第一个的数，可以求出数列的前 $m$ 项的集合，对应了 $m!$ 种排列。这个 $m!$ 的系数我们不急着考虑，最后再来乘。
2.  取出比上一个放的积木更大的积木中最小的那个，把下一个此颜色的积木放在序列尾，然后更新你手上积木的集合。

其他 $n-t$ 个数可以任意排，所以已染色的塔可以对应 $(n-t)!$ 个数列。

我们发现这些步骤对于 $m>2$ 也成立，那么就很好了。在此，我们再来检视一下我们构建的映射：$m$ 个基本积木塔的任何归并都对应一个已染色的积木塔，从而对应 $(n-t)!$ 个数列。

### 开始计数

考虑 $i$ 个数，将他们搭成基本积木塔的方案数为 $i-1$，即选择一个放到最后面。因此基本积木塔的 EGF 为：
$$
f(x)=\sum_{i\ge1}\frac {(i-1)x^i}{i!}
$$
则固定 $m$，积木塔的 EGF 为 $f^m$。那么我们要求的变为：
$$
\sum_{i=m}^{n-1}i![x^i]f^m(x)(n-i)!\binom ni =n!\sum_{i=m}^{n-1}[x^i]f^m(x)=n![x^{n-1}]\frac {f^m(x)}{1-x}
$$
乘 $i!$ 是因为 EGF，乘 $(n-i)!$ 是因为高为 $i$ 的积木塔对应了 $(n-i)!$ 个数列，称组合数是因为我们要从 $n$ 个数里面选出 $i$ 个搭塔。

至此，可以一次多项式 exp 解决 $q=1$ 的部分分。

上面是搭不成功的概率，那么成功的概率就是：
$$
\begin{aligned}
&\phantom{={}}1-[x^{n-1}]\frac{f^m}{1-x}\\
&=1-[x^{n-1}]\frac{(e^xx-e^x+1)^m}{1-x}\\
&=1-[x^{n-1}]\sum_i{m\choose i}\frac{(e^x(x-1))^i}{1-x}\\
&=[x^{n-1}]\sum_{i\geq 1}{m\choose i}e^{ix}(x-1)^{i-1}\\
&=[x^{n-1}]\sum_{i\geq 1}{m\choose i}e^{ix}\sum_j{i-1\choose j}x^j(-1)^{i-1-j}\\
&=\sum_{i\geq 1}{m\choose i}\sum_j{i-1\choose j}[x^{n-1-j}]e^{ix}(-1)^{i-1-j}\\
&=\sum_{i\geq 1}{m\choose i}\sum_j{i-1\choose j}\frac{i^{n-1-j}}{(n-1-j)!}(-1)^{i-1-j}\\
\end{aligned}
$$

至此，可以 $O(n^2)$ 预处理后面半截，单次 $O(n)$ 的询问。结合上文 $q=1$ 的部分分可以获得 $90$ 的高分。

```
#include<bits/stdc++.h>
#define ll long long
const int N=20005,mod=998244353;
using namespace std;

ll gsc(ll x,ll y){
    ll ans=1;
    for(int i=1;i<=y;i<<=1,x=x*x%mod)
        if(y&i)
            ans=ans*x%mod;
    return ans;
}int inv(int k){return gsc(k,mod-2);}
ll jc[N],ij[N],iv[N]; 
void init(){
    iv[0]=jc[0]=ij[0]=iv[1]=1;
    for(int i=2;i<N;i++)
        iv[i]=mod-(mod/i)*iv[mod%i]%mod;
    for(int i=1;i<N;i++)
        jc[i]=jc[i-1]*i%mod,ij[i]=ij[i-1]*iv[i]%mod;
}

int n,q,vis[N],m;
ll f[N];int C[N];

int chk(int k){
	return k>=mod?k-mod:k;
}

void solve(){
	cin>>n>>q,m=n/2;
	while(q--){
		int x;cin>>x;
		vis[x]=1;
	}
	init(); 
	C[0]=1;
	for(int i=1;i<=m;i++){
		ll pwi=gsc(i,n-1),p=iv[i];
		for(int j=0;j<i;j++){
			f[i]+=((i+j+1)&1?-1:1)*pwi*C[j]%mod*ij[n-1-j];
			f[i]%=mod;
			pwi=pwi*p%mod;
		}
		f[i]=(f[i]%mod+mod)%mod;
		for(int j=i;j;j--)
			C[j]=chk(C[j]+C[j-1]);
	}
	memset(C,0,sizeof(C));
	C[0]=1;
	for(int i=1;i<=m;i++){
		unsigned ll res=0;
		for(int j=i;j;j--){
			C[j]=chk(C[j]+C[j-1]);
			res+=C[j]*f[j];
			res%=mod;
		}
		res=res%mod+mod;
		if(vis[i])cout<<res%mod<<'\n';
	}
	for(int i=m+1;i<=n;i++)
		if(vis[i])cout<<1<<'\n';
}
main(){solve();}
```

设 $g_i=\sum_j{i-1\choose j}\frac{i^{n-1-j}}{(n-1-j)!}(-1)^{i-1-j}$，那么上式便是关于 $m$ 的卷积。

设 $a_i=\frac{(-1)^{i+1}}{(i-1)!(n-i)!}$ ，则 $g_i=(-1)^{i-1}\sum_j a_{j+1}(i-1)^{\underline j}i^{n-1-j}=\frac{(-1)^{i-1}}{i}\sum_j a_{j}i^{\underline {j}}i^{n-j}$

设 $f(x)=\sum_j a_{j}x^{\underline {j}}x^{n-j}$ ，则 $g_i=\frac{(-1)^{i-1}}{i}f(i)$

那么如果我们求出了 $f$ ，只需要一个 多 点 求 值 就可以得到 $g$ 。

考虑分治，设 $A_{l,r}=\prod_{l\leq i<r} (x-i)$ ，$B_{l,r}=\sum_{l\leq i<r} a_iA_{l,i}x^{r-1-i}$ 那么答案就为 $B_{0,n+1}$ 

考虑合并，有 $A_{l,r}=A_{l,mid}*A_{mid,r}$ ，$B_{l,r}=x^{r-mid}B_{l,mid}+A_{l,mid}*B_{mid,r}$ 

边界为 $A_{i,i+1}=x-i$ ，$B_{i,i+1}=a_i$

最后用一次卷积得到每一个 $m$ 的答案，总时间复杂度 $O(n\log^2 n)$。

---

## 作者：Elegia (赞：12)

## 组合转换

首先根据题意, 我们可以将问题表述成如下形式:

> 有多少 $n$ 阶排列 $q$, 满足: 存在互不相同位置 $p_m, p_{m+1}, \dots, p_{n-1}$, 使得
> - $p_t \leq t$
> - $q_{p_t}$ 递增?

正难则反, 问题本身的描述是从小到大选取的, 我们考虑从大到小选取.

以 $f(n, 0) = 1$ 为动态规划的起点, 其中 $f(i, j)$ 两个状态表示规划前 $i$ 个位置, 目前知道前 $i$ 个位置中有 $j$ 个数已经在 $t\geq i$ 的 $p_t$ 里被使用了.

那么在 $(i, j)$ 个位置, 我们要规划 $t=i-1$ 时候的选取, 我们只需贪心选取能选的最大值, 所以我们关心的其实是 $i$ 这个位置的数是否已经被选了.
1. 如果 $i$ 这个位置的数已经被选了, 我们有 $j$ 中可能之一. $(i, j)$ 以 $j$ 的权值转移到 $(i-1, j)$.
2. 否则 $i$ 这个位置的数没被选, 那么它是尚未被选的 $i-j$ 个数之一, 删掉它之后我们还需要再选一个数. $(i, j)$ 以 $i-j$ 的权值转移到 $(i-1, j+1)$.

值得注意的是, 这个 DP 的边界不是自然的! 最后我们询问 $m$ 的答案时, 要求和
$$ m!\cdot \sum_{i\leq m} f(m, i), $$
但按照这个转移的话, $i > m$ 的地方也有值.

这就得到了一个 $O(n^2)$ 复杂度求所有答案的 DP.

## 代数变换

我们记 $f_i(x)$ 是第 $i$ 行的生成函数. 容易将 DP 的转移过程写成

$$ f_{i-1} = (x-x^2) f_i' + i x f_i. $$

注意到,

$$ \frac{f_{i-1}}{(1-x)^{i+1}} = x \left( \frac{f_i}{(1-x)^i} \right)', $$

所以令 $g_i(x) = f_i(x) / (1-x)^i$, 就有

$$ g_{i-1} = x(1-x)^2 g_i'. $$

再做换元 $h_n(u) = g_i(x)$, 其中 $u = te^t, t = x/(1-x)$, 可以验证

$$ h_{i-1} = u h_i'. $$

所以 $h_i$ 的变换就是直接把第 $k$ 次项系数乘以 $k$, 这是容易做的.

现在我们考虑如何提取答案. 记内积为 $\langle A(x), B(x) \rangle = \sum_n [x^n]A\cdot [x^n]B$, 我们希望求的是

$$
\begin{aligned}
&\quad \langle f_i(x), 1 + x + \cdots + x^i \rangle\\
&= \left\langle g_i(x)(1-x)^i, 1 + x + \cdots + x^i  \right\rangle,
\end{aligned}
$$

注意到
$$ \begin{aligned}
&\quad \langle x^k (1-x)^i, 1 + x + \cdots + x^i \rangle\\
& = [x^i] x^k(1-x)^i \cdot \frac 1{1-x}\\
& = [x^{i-k}] (1-x)^{i-1} \\
& = [x^{k}] x(x-1)^{i-1},
\end{aligned} $$

可知前面的内积有

$$
\begin{aligned}
&\quad \left\langle g_i(x)(1-x)^i, 1 + x + \cdots + x^i  \right\rangle\\
&= \left\langle g_i(x), x(x-1)^{i-1} \right\rangle\\
&= \left\langle h_i(u), x(x-1)^{i-1} \right\rangle\\
&= \left\langle h_i(te^t), x(x-1)^{i-1} \right\rangle,
\end{aligned}
$$

由于 $t = x/(1-x)$, 考虑
$$ \begin{aligned}
&\quad \langle t^k, x(x-1)^{i-1} \rangle\\
& = \left\langle \left(\frac{x}{1-x}\right)^k, x(x-1)^{i-1} \right\rangle\\
&= [x^i] \left(\frac{x}{1-x}\right)^k \cdot (1-x)^{i-1}\\
&= [x^i] x^k \cdot (1-x)^{i-1-k}\\
&= [i = k],
\end{aligned} $$

所以
$$
\begin{aligned}
&\quad \left\langle h_i(te^t), x(x-1)^{i-1}\right\rangle\\
&= \sum_{j\leq i} [u^j] h_i \cdot [t^i] (te^t)^j\\
&= \sum_{j} [u^j] h_i \cdot \frac{j^{i-j}}{(i-j)!}\\
&= \sum_{j} [u^j] h_n j^{n-i} \cdot \frac{j^{i-j}}{(i-j)!}\\
&= \sum_{j} [u^j] h_n \cdot \frac{j^{n-j}}{(i-j)!}\\
&= [T^i] \left( \sum_j ([u^j]h_n) \cdot j^{n-j} T^j \right) e^T.
\end{aligned}
$$

我们只要求出 $h_n(u)$ 的系数就做完了. 有
$$
\begin{aligned}
g_n(x) &= \left(\frac 1{1-x}\right)^n\\
&= (1 + t)^n\\
&= \left( 1 + \sum_{k \geq 1} \frac{(-k)^{k-1}}{k!} u^k \right)^n,
\end{aligned}
$$

因此有多项式快速幂就可以了.


---

## 作者：Aleph1022 (赞：8)

双射就不讲了，因为我也不会！

我们要做的是对
$$
f(x) = \sum_{i\ge 1} \frac{(i-1)x^i}{i!} = x\mathrm e^x - \mathrm e^x + 1
$$

和 $1 \le m \le n$ 计算
$$
[x^{n-1}] \frac{f^m}{1-x}
$$

令 $\frac{g^2}2 = f$，则 $g$ 的最低次项是 $x$。  
从而所求即为
$$
[x^{n-1}] \frac{g^{2m}2^{-m}}{1-x}
$$

施（另类）拉格朗日反演，得
$$
[x^{n-1}] \frac{x^{2m}2^{-m}}{1-g^{\langle -1\rangle}} \cdot \left(g^{\langle -1\rangle}\right)' \cdot \left(\frac x{g^{\langle -1\rangle}}\right)^n
$$

则关键在于求出 $g^{\langle -1\rangle}$。可以牛顿迭代或半在线卷积。

时间复杂度为 $\Theta(n\log n)$ 或 $\Theta\left(\frac{n\log^2 n}{\log \log n}\right)$。

---

## 作者：Qiuly (赞：3)

先考虑 $m=1$，肯定是要求前 $n-1$ 个递增，最后一个无所谓。就是因为无所谓，导致我们判断很麻烦。不妨考虑计算非法，即前面若干个递增，最后一个非增。

拓展到 $m=2$，首先最优策略肯定是每次放弃比上一次放弃的数大的数中，最小的那个。举个例子，对于 $\{1,4,2,8,5,7,3,6,9,10\}$ 我们会依次拿出 $\{1,2,4,5,7,8\}$，然后指针指到 $\{3,6\}$ 也加进去。变成 $\{1,2,4,5,7,8,3,6\}$ 。现在我们考虑设计一个 split 方案，使得 $m=2$ 可以分裂成两个 $m=1$ 的问题，这样就可以分开算了。

考虑如下染色：我们维护指针 $t=m+1$，每次对于原序列 $a_t$ 令其颜色，等同于 $b_{t-m}$ 的颜色（$b$ 是拿出序列，前 $m$ 项各染一个颜色）。显然若 $a_t=i$ 那么 $i$ 应该在 $b$ 中出现在 $t-m$ 更靠前的位置，所以染色必然合法。于是，按照上面的例子，染色为 $\{4,5,7,3\},\{1,2,8,6\}$（标号由最后的终结位置，按顺序确定）。

可以发现，$m=2$ 的结构可以 split 成唯一两个 $m=1$ 的结构。而两个 $m=1$ 的结构可以 merge 成一个唯一的 $m=2$ 的结构（前面归并，后面按标号排序）。

一个原序列显然对应一个唯一的已经染色的拿出序列。而一个已经染色拿出序列，也可以对应恰好 $(n-t)!$ 个原序列：原序列后 $n-t$ 随意（反正非法）。因为拿出序列最后 $m$ 个已定，又因为 $a_{m+t}$ 的颜色与 $b_t$ 相同，只要倒着进行，取与 $b_t$ 相同颜色的上一个位置即可。

于是我们要算的就是 $m$ 个 $m=1$ 的子问题，有标号选择的方案数。$i-1$ 即一个大小为 $i$ 的 $m=1$ 的子问题的方案数。要算的应当是：令 $F=\sum\limits_{i\geq 1}\frac{i-1}{i!}x^i$，求 $\sum\limits_{i=m}^{n-1}i![x^i]F^i{n\choose i}(n-i)!$ 。即求 $n![x^{n-1}]\frac{F^m}{1-x}$ 。

令 $F=G^2$，于是 $G$ 的最低次项为 $x$ 。令 $H\circ G=\frac{G^{2m}}{1-x}$，于是 $H=\frac{x^{2m}}{1-G^{-1}}$ 。应用拉格朗日反演有：$[x^{n-1}](H\circ G)=\frac{1}{n-1}[x^{n-2}]H'\left(\frac{x}{G^{-1}}\right)^n$。把 $H'$ 展开就好了（用另类拉反展开简单不少）。

---

## 作者：水军带你飞 (赞：3)

双射太难了，那就别双射了！

把题目中的排列 $p$ 转换一下变成 $q$，$q_i$ 表示 $i$ 在 $p$ 中的位置。则 $p, q$ 一一对应，题目中判断是否是好的也就有另外一种做法：

> 维护一个值 $x$ 初始为 $t$，顺序枚举 $q_1 \sim q_n$，若 $q_i \le x$，则 $x$ 加上一。如果 $x$ 达到了 $n$，那么这个排列就是好的。

那么不妨钦定 $q$ 中哪些位置给 $x$ 加了 $1$，即 $1 \le a_t < a_{t + 1} < \cdots < a_{n - 1} \le n$，其中 $a_i$ 表示 $x = i$ 的时候在 $q_{a_i}$ 给 $x$ 加上了 $1$。那么就要求 $q_{a_i} \le i$。

而对于别的位置 $j$，若 $a_i < j < a_{i + 1}$，则就说明 $x = i$ 的时候，$q_j$ 没有让 $x$ 加 $1$，即 $q_j > i$。

现在这个序列既有小于等于，也有大于不是很好做。不妨先不考虑大于的那一部分，只考虑小于部分的计数，那么就是 $t^{n - t}$（第一个位置在 $1 \sim t$ 中选，第二个数在 $1 \sim t + 1$ 中选且前面已经选过的数不能选，以此类推）。

再考虑容斥，将一些大于的位置钦定为小于等于。那么现在我们钦定的位置就变成了：

一些位置 $\le t$，后面一些位置 $\le t + 1$……最后面一些位置 $\le n - 1$。假设总共选了 $m$ 个数，那么就容斥了 $m - (n - t)$ 个位置。容斥系数 $(-1)^{m - (n - t)}$。再考虑这些位置的方案数形如：$t \times (t - 1) \times (t - 2) \times \cdots \times (t - z) \times (t - z) \times \cdots \times (t - (m - (n - t)))$ 即 $(n - m)$。这里乘两个 $t - z$，后面的一个是因为 $\le t + 1$，而前面一个是因为 $\le t$。

写成生成函数就是：

$$ \sum\limits_{i = 1}^t [x^{n - t - 1}] \prod\limits_{j = i}^t \frac{i}{1 - ix} (-1)^{t - i} $$

再考虑把这些位置插入到整个序列中，方案数 $\binom{n}{m}$，而剩下 $n - m$ 个数没有限制，所以在 $m$ 个数填完之后有方案数 $(n - m)!$，所以要乘上 $\frac{n!}{m!}$，而在上式中，$i = n - m$，故 $t$ 的方案数是：

$$ \sum\limits_{i = 1}^t [x^{n - t - 1}] \prod\limits_{j = i}^t \frac{i}{1 - ix} (-1)^{t - i} \frac{n!}{(n - i)!} $$

化简一下就是：

$$ n!(-1)^t \sum\limits_{i = 1}^t [x^{n - t - 1}] \prod\limits_{j = i}^t \frac{i}{1 - ix} \frac{(-1)^i}{(n - i)!} $$

丢掉前面的 $n!(-1)^t$，然后这就已经可以直接分治 FFT 维护分式来求解单组询问的答案了。对于多组询问，可以考虑类似多点求值的做法：在外面全部乘上 $\frac{1}{\prod\limits_{i = 1}^{n - 1} 1 - ix}$，然后分治内部就变成了乘上若干 $1 - ix$ 的单项式。复杂度 $O(n \log^2 n)$。

可以看到双射题解最终推出来的复杂度是 $O(n \log n)$，这两种最终形式之间有关联吗？

好问题，可以见 [EI 的博客](https://blog.csdn.net/EI_Captain/article/details/106243485)。

下面是 $O(n \log^2 n)$ 的代码。~~题解是写了很久之后口胡的，如果有 typo 请联系下~~

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 1 << 17, mod = 998244353, o = 19, len = 1 << o;
int n, q, t;
int iv[N], ifac[N], fac[N];
int a[N], b[N];
int ans[N];
vector<int> f[N << 1], g[N << 1];

int add(int x, int y) { return x + y < mod ? x + y : x + y - mod; }
int sub(int x, int y) { return x < y ? x + mod - y : x - y; }

int power(int a, int n) {
  int tp = 1;
  while (n) {
    if (n & 1)
      tp = 1ll * tp * a % mod;
    a = 1ll * a * a % mod, n >>= 1;
  }
  return tp;
}

void prep(int n) {
  iv[1] = 1;
  for (int i = 2; i <= n; i++) {
    int j = mod / i + 1;
    iv[i] = 1ll * j * iv[i * j - mod] % mod;
  }
  ifac[0] = 1;
  for (int i = 1; i <= n; i++)
    ifac[i] = 1ll * ifac[i - 1] * iv[i] % mod;
  fac[0] = 1;
  for (int i = 1; i <= n; i++)
    fac[i] = 1ll * fac[i - 1] * i % mod;
}

namespace poly {
typedef unsigned long long u64;
int w[len], r[len], up, l;

void init() {
  const int w0 = power(3, (mod - 1) >> o);
  w[len >> 1] = 1;
  for (int i = (len >> 1) + 1; i != len; i++)
    w[i] = 1ll * w[i - 1] * w0 % mod;
  for (int i = (len >> 1) - 1; i; i--)
    w[i] = w[i << 1];
  for (int i = 0; i != len; i++)
    r[i] = (r[i >> 1] >> 1) | ((i & 1) << (o - 1));
}

void ntt(int *a, int n, bool op) {
  static u64 t[len], x, y;
  for (int i = 0; i != n; i += 2) {
    x = a[r[i] >> (o - l)], y = a[r[i + 1] >> (o - l)];
    t[i] = x + y, t[i + 1] = x + mod - y;
  }
  for (int l = 2; l != n; l <<= 1) {
    if (l == (1 << 18))
      for (u64 *f = t; f != t + n; f++)
        *f %= mod;
    int *k = w + l;
    for (u64 *f = t; f != t + n; f += l)
      for (int *j = k; j != k + l; j++, f++) {
        u64 x = *f, y = f[l] * *j % mod;
        f[l] = x + mod - y, *f += y;
      }
  }
  if (op) {
    if (n == (1 << 18))
      for (u64 *f = t; f != t + n; f++)
        *f %= mod;
    for (int i = 0, x = mod - (mod >> l); i != n; i++)
      a[i] = t[i] * x % mod;
    reverse(a + 1, a + n);
  } else
    for (int i = 0; i != n; i++)
      a[i] = t[i] % mod;
}

int pre(int n) {
  l = 32 - __builtin_clz(n);
  return up = 1 << l;
}

void mul(int *f, int n, int *g, int m, int *h, int q = -1) {
  static int x[len], y[len];
  if (n == 0 && m == 0) {
    h[0] = 1ll * f[0] * g[0] % mod;
    return;
  }
  memcpy(x, f, (n + 1) << 2), memcpy(y, g, (m + 1) << 2);
  pre(n + m), ntt(x, up, 0), ntt(y, up, 0);
  for (int i = 0; i != up; i++)
    h[i] = 1ll * x[i] * y[i] % mod;
  ntt(h, up, 1);
  memset(x, 0, up << 2), memset(y, 0, up << 2);
  if (q != -1)
    fill(h + q + 1, h + up, 0);
}

void inv(int *a, int n, int *f) {
  static int x[len], y[len];
  if (n <= 16) {
    int x = f[0] = power(a[0], mod - 2);
    for (int i = 1; i <= n; i++) {
      u64 s = 0;
      for (int j = 0; j != i; j++)
        s += 1ll * f[j] * a[i - j];
      f[i] = (mod - s % mod) * x % mod;
    }
    return;
  }

  int lt = n >> 1;
  inv(a, lt, f);
  memcpy(x, f, (lt + 1) << 2), memcpy(y, a, (n + 1) << 2);
  pre(n);
  ntt(x, up, 0), ntt(y, up, 0);
  for (int i = 0; i != up; i++)
    y[i] = 1ll * y[i] * x[i] % mod;
  ntt(y, up, 1);
  memset(y, 0, (lt + 1) << 2);
  ntt(y, up, 0);
  for (int i = 0; i != up; i++)
    y[i] = 1ll * y[i] * x[i] % mod;
  ntt(y, up, 1);
  for (int i = lt + 1; i <= n; i++)
    f[i] = sub(0, y[i]);
  memset(x, 0, up << 2), memset(y, 0, up << 2);
}
}

void solve1(int i, int l, int r) {
  static int x[len], y[len];
  static int a[len];
  using namespace poly;
  if (l == r) {
    f[i] = {1, mod - l};
    int x = 1;
    if (l & 1)
      x = mod - 1;
    g[i] = {(int)(1ll * x * ifac[l - 1] % mod * ifac[n - l] % mod), 0};
    return;
  }

  int mid = (l + r) >> 1;
  solve1(i << 1, l, mid), solve1(i << 1 | 1, mid + 1, r);
  memcpy(x, f[i << 1].data(), (mid - l + 2) << 2);
  memcpy(y, f[i << 1 | 1].data(), (r - mid + 1) << 2);
  memcpy(a, g[i << 1 | 1].data(), (r - mid + 1) << 2);
  int up = pre(r - l + 1);
  ntt(x, up, 0), ntt(y, up, 0), ntt(a, up, 0);
  for (int i = 0; i != up; i++) {
    a[i] = 1ll * a[i] * x[i] % mod;
    x[i] = 1ll * x[i] * y[i] % mod;
  }
  ntt(a, up, 1), ntt(x, up, 1);
  f[i] = vector<int>(x, x + r - l + 2);
  g[i] = vector<int>(a, a + r - l + 2);
  for (int j = 0; j <= mid - l; j++)
    g[i][j] = add(g[i][j], g[i << 1][j]);
  memset(x, 0, up << 2), memset(y, 0, up << 2), memset(a, 0, up << 2);
}

void solve(int i, int l, int r, vector<int> h, vector<int> gu) {
  static int x[len], y[len], z[len];
  static int w[len], v[len];
  using namespace poly;
  if (l == r) {
    int x = 1;
    if (l & 1)
      x = mod - 1;
    ans[l] = (gu[0] + 1ll * x * h[0] % mod * ifac[l - 1] % mod * ifac[n - l]) % mod * fac[l] % mod;
    if (l & 1)
      ans[l] = sub(0, ans[l]);
    return;
  }

  int mid = (l + r) >> 1;
  memcpy(x, h.data(), h.size() << 2);
  int up = pre(h.size() - 1 + mid - l + 1);
  memcpy(y, f[i << 1].data(), (mid - l + 2) << 2);
  memcpy(z, f[i << 1 | 1].data(), (r - mid + 1) << 2);
  memcpy(w, g[i << 1].data(), (mid - l + 2) << 2);
  memcpy(v, gu.data(), gu.size() << 2);
  ntt(x, up, 0), ntt(y, up, 0), ntt(z, up, 0);
  ntt(w, up, 0), ntt(v, up, 0);
  for (int i = 0; i != up; i++) {
    v[i] = 1ll * v[i] * z[i] % mod;
    y[i] = 1ll * y[i] * x[i] % mod;
    z[i] = 1ll * z[i] * x[i] % mod;
    w[i] = 1ll * w[i] * x[i] % mod;
  }
  ntt(y, up, 1), ntt(z, up, 1), ntt(w, up, 1), ntt(v, up, 1);

  vector<int> hl, hr, gl, gr;
  for (int j = 0; j != up; j++) {
    int p = n - r - 1 - (r - l) + j;
    if (p <= n - l - 1 && p + (mid - l) >= n - mid - 1)
      hl.push_back(z[j]), gl.push_back(v[j]);
    if (p <= n - (mid + 1) - 1 && p + (r - mid - 1) >= n - r - 1)
      hr.push_back(y[j]), gr.push_back(add(gu[j], w[j]));
  }

  memset(x, 0, up << 2), memset(y, 0, up << 2), memset(z, 0, up << 2);
  memset(v, 0, up << 2), memset(w, 0, up << 2);
  solve(i << 1, l, mid, hl, gl), solve(i << 1 | 1, mid + 1, r, hr, gr);
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);

  cin >> n;
  prep(n);
  poly::init();

  solve1(1, 1, n);
  memcpy(a, f[1].data(), (n + 1) << 2);
  poly::inv(a, n, b);
  vector<int> g(b, b + n - 1);
  auto tp = vector<int>(n, 0);
  g.insert(g.begin(), tp.begin(), tp.end());

  solve(1, 1, n, g, vector<int>(2 * n - 1, 0));
  ans[n] = 1;

  cin >> q;
  while (q--) {
    int t;
    cin >> t;
    cout << ans[t] << '\n';
  }
}
```

---


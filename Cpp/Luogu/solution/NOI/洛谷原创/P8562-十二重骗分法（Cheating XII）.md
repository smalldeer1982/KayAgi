# 十二重骗分法（Cheating XII）

## 题目描述

一阵恍惚过后，你发现自己坐在机房里。一看时间，现在竟然是 2202 年！你又环视了一下周围的情况，原来自己在 CSP-J 2202 的考场上。

你还没搞清楚情况时，似乎听见有人对你低语：「想知道怎么回事吗？那就展现你以往的能力，把这次的 CSP-J 也 AK 掉吧。」

于是你看到四个题分别是：  

1. 输入一个正整数 $n$，求 $\lfloor \sqrt n \rfloor$。  

2. 给定一个左右各有 $n$ 个点的二分图，与其中的边，求它完美匹配的方案数，答案对 $998244353$ 取模。

3. 生命游戏（Conway's Game of Life）进行于一个无限大的二维网格上，每个格子要么是空地，要么有一个细胞。每个时刻都会进行一轮**迭代**，规则如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/do0c6ras.png)  
现在，给定你初始状态，求迭代 $k$ 次后的细胞数。  
ps：你可以在 [这里](https://playgameoflife.com/) 试玩。

4. 给你一个 $n$ 个点、 $m$ 条边的无向图，每个点都可以涂上 $k$ 种颜色中的一种，且相邻的点（即有边直接相连的点）不能有相同的颜色。求有多少种染色方案，答案对 $998244353$ 取模。

「这怎么可能啊！」你差点惊叫出来。不过你发现，唯独你的电脑上有题目的输入数据！你想暴力跑出答案，却发现 2202 年的评测机性能和一百多年前没差别。

那该怎么办呢？总之只能靠自己了吧。


**输入数据可以在题目下方的附件中下载。**

## 说明/提示

【样例 $1$ 解释】  
输入中 $T=3$，要求的问题是二分图完美匹配计数。  
可以发现，只有两种匹配方案：$1 \leftrightarrow 1,2 \leftrightarrow 2,3 \leftrightarrow 3$
 或 $1 \leftrightarrow 2,2 \leftrightarrow 3,3 \leftrightarrow 1$。
 
 【样例 $2$ 解释】  
 输入中 $T=7$，要求的问题是预测生命游戏细胞数。给出的输入是：  
 ![](https://cdn.luogu.com.cn/upload/image_hosting/0ukc526n.png)   
 经过 $133$ 轮迭代后为：  
 ![](https://cdn.luogu.com.cn/upload/image_hosting/g6yz6nf3.png)  
 可以数出其中细胞数为 $129$。  
 
样例中虽然有 $T\in[1,12]$，但并不代表实际输入。  

【测试点分数信息】   

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| **分数** | $7$ | $8$ | $6$ | $7$ | $9$ | $11$ | $8$ | $9$ | $10$ | $7$ | $8$ | $10$ |



## 样例 #1

### 输入

```
3
3
2 1 2
2 2 3
2 1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
7
5 5 133
10001
00000
11111
00000
01010```

### 输出

```
129```

# 题解

## 作者：NaCly_Fish (赞：67)

整个题目分为四部分内容讲解。

### 第一部分 求平方根

**测试点 1：**  
可以发现输入的规律是 $5444 \cdots 42888 \cdots$，但是最后有一段乱掉的内容。发现前半部分 4 的位数，比在中间的 2 后面的位数少一位。  
尝试小数据可以发现如 $2333333^2=5444442888889$ 这样的规律（可以用线性递推数列来证明）。而这里的输入后面虽然稍大，但其平方根下取整后依然是 $2333 \cdots$。

**测试点 2:**   
大家一定知道如 $111111^2=12345654321$ 这样的结论吧！观察输入数据，发现整体是比较对称的，只是最后一位看起来应该是 4，但实际是 1。同样是按照规律，答案就是若干个 $200000$ 的拼接，最后再接个 1。证明和上一个点时类似的。
****
### 第二部分 二分图完美匹配计数

**测试点 3：**  

左边的 1 号点只能匹配右边的 1 号；由此左边的 2 号也只能连接右边的 2 号，以此类推，只有一种方案。

**测试点 4：**  

看不出什么明显的规律，~~但如果你的屏幕够长，很容易发现输入数据像条形图一样。~~ 若尝试打出邻接矩阵，就很明显了：整个图分成了许多连通块，每个连通块中左边的点都连接了所有右侧的点（即完全二分图）。那么一边有 $n$ 个点的这种连通块，答案显然为 $n!$，把每个连通块的答案乘起来即可。

**测试点 5：**  

左侧的 $i$ 号点（从 0 开始计）会连接编号为 $(i+k) \bmod 60000 \ \ k \in [0,4]$ 的右侧点。可以按照这个规律，设有 $n$ 个点，打一些小数据的表。可以猜测答案满足一个常系数线性递推，用 BM 算法找出递推式，暴力计算即可。

如果对 dp 加一些优化，大概也是能在可接受的时间内跑出答案的。当然你也可以在 [OEIS](https://oeis.org/A000804) 上找到这个数列。

**测试点 6：**  

首先每个点的度数都不超过 4。再稍作分析，就能发现这是一个 $n \times m$ 的网格图，再交错地黑白染色，使每个格子周围的四个都与其颜色不同。最后在相邻的格子之间连边，就是题目中的情况。

手玩一下小数据的方案，发现实际上所求就是用 $1\times 2$ 的骨牌铺满 $n \times m$ 的网格的方案数。如果你对《具体数学》的内容记得比较清楚，你一定能找到这样一个公式（证明比较难，我也不会）：

$$2^{nm/2}\prod_{j=1}^m \prod_{k=1}^n\left(x^2\cos^2 \frac{j \pi}{m+1}+y^2 \cos^2\frac{k \pi}{n+1} \right)^{1/4}$$
它的 $x^py^q$ 项系数就表示用 $p$ 个竖骨牌和 $q$ 个横骨牌铺满的方案数。只需要令 $x=y=1$ 就是我们想要的答案了。

将 $\cos$ 函数用单位根来表示，就得到答案为：
$$\prod_{j=1}^m \prod_{k=1}^n (\omega_{m+1}^j + \omega_{m+1}^{-j}+\omega_{n+1}^k +\omega_{n+1}^{-k}+4)^{1/4}$$
在此题中 $m=511$，$n=118$，满足 $(m+1)|p$ 且 $(n+1)|p$，可以直接用原根来计算单位根。那么主要问题就是怎么开四次根。考虑到 $n+1$ 是奇数，$k$ 和 $n+1-k$ 的乘积项必然相同；但 $m$ 是奇数，$j= \lceil m/2 \rceil$ 时这一项多了出来，我们将答案写成：

$$\left(\prod_{j=1}^{\lfloor m/2 \rfloor}\prod_{k=1}^{n/2}(\omega_{m+1}^j + \omega_{m+1}^{-j}+\omega_{n+1}^k +\omega_{n+1}^{-k}+4)\right) \prod_{k=1}^{n/2}(\omega_{n+1}^k+\omega_{n+1}^{-k}+2)^{1/2}$$
而后面那段乘积项是 $\omega_{n+1}^{k/2}+\omega_{n+1}^{-k/2}$，可以直接计算；当然也容易证明整体就是 $1$，直接忽略掉就行。然后就能以 $\Theta(nm)$ 的时间复杂度计算。对于更一般的情况，也有高效的做法，这里就不说了（
****
### 第三部分 生命游戏迭代预测  

首先，这玩意手动模拟很难，建议写个小程序来模拟；或者直接找现成的可视化工具，把输入丢进去就好。

**测试点 7：**. 

输入量不小，但运行一下就能发现，其细胞数是周期变化的。这就是典型的「飞船」模型，整体向着固定方向移动，而内部的形态呈周期变化。  

**测试点 8：**  

这次的输入很少，却能快速地增长，并铺满整个平面。下图为迭代 50 次后的图案：  

![](https://cdn.luogu.com.cn/upload/image_hosting/b2oix78g.png)  

四角向外移动的部分的形状，是以 $4$ 为周期变化；再结合其增长速度显然为平方级，可以猜测：在第 $4t$ 次迭代后的细胞数，关于 $t$ 是个二次多项式。那就很简单了，简单插值可以得到 $4t \ \ (t \ge 1)$ 代后的细胞数为 $195+38t+4t^2$，注意需要高精度运算。

**测试点 9：**  

现在需要对图案进行深入分析。首先可以看到有一个「飞船」，以很小的匀速度向左上移动；还有一个「滑翔机」，沿左上和右下方向往返移动。当「滑翔机」触及右下角的部分时，就会有一个「滑翔机」向右上飞去。

注：所谓滑翔机，就是这样的结构：  
![](https://cdn.luogu.com.cn/upload/image_hosting/53dkvvhx.png)


显然，这也是一个可以无限增长的形态，但是增长得很慢，有多慢呢？假设向左上的大飞船速度为 $u$，滑翔机速度为 $v$，飞船初始到右下的距离为 $S_0$，则第 $n$ 次往返所需时间 $T_n$，与返回后飞船到右下的距离 $S_n$ 为：

$$T_n = \frac{S_{n-1}}{v}+\frac{S_{n-1}}{v-u}\left( 1+ \frac{u}{v}\right) = \frac{2S_{n-1}}{v-u}$$
$$ S_n=S_{n-1}+T_n u$$

简单代换可以得到：
$$S_n = \frac{v+u}{v-u}S_{n-1}$$
这就证明了细胞数是呈对数增长的。进一步分析，大飞船的速度为每 $96$ 代 $8$ 格，而滑翔机为每 $4$ 代 $1$ 格（横向和纵向移动相同距离），即 $u=1/12$，$v=1/4$，$S_n=2S_{n-1}$，每次往返所需时间翻倍。

由此合理推断：取合适的 $a$，在 $a\times 2^n$ 代时，细胞数为 $5n+b$。对于任意情况求解比较困难，这里给出：在 $a=960$ 时有 $b=376$。这个结果可以根据其它部分的周期来发现。而输入的迭代次数是 $960$ 的倍数，除掉之后刚好又是 $2$ 的整数幂。

最后推荐一个整合了许多相关资料的网站：[Life Wiki](https://conwaylife.com/wiki)。
****
### 第四部分 图染色计数


**测试点 10：**  

一眼发现这个图有 $n$ 个点和 $n-1$ 条边，再验证一下这就是一棵树。我们随便选一个点开始染色，有 $k$ 种选择方式；与其相邻的点都有 $k-1$ 种方案，于是答案就是 $k(k-1)^{n-1}$。

**测试点 11：**  

直接看不出什么性质，尝试打出邻接矩阵来，就可以发现有 $C=233$ 个点与之间的边形成了团，即它们的颜色必须两两不同。而剩下的点之间没有连边，都连向了那个团中的点。考虑先给团染色，方案数为 $k^{\underline C}$；剩下的点若度数为 $d$，只有 $k-d$ 种颜色可选，全部乘起来即可。

**测试点 12：**

也是个比较稠密的图，可以参考上一个测试点的方法，观察邻接矩阵发现：两个点之间有边相连，当且仅当它们模 $17$ 的结果不同。于是整个图可以分为 $17$ 个部分，每部分节点数相同；从中选出一个点，都要和其它部分中所有点不同色。

那么可以预见到这样一种计数方法：给每个部分一个可用、且必须都用到的颜色集合，集合之间没有交集。枚举将要出现的总颜色数 $c$，可以得到答案计算式：

$$\sum_{c=0}^k \binom kc \sum_{i_1+\cdots+i_{17}=c}\binom{c}{i_1,\cdots,i_{17}} \prod_{j=1}^{17}f(i_j)$$

其中的 $n$ 表示**每一部分的节点数**；$f(i)$ 表示给 $n$ 个点都涂色，有 $i$ 种颜色可用，且每种颜色都要用到的方案数。这个和第二类 Stirling 数很像，显然有
$$f(i)=\begin{Bmatrix}n \\ i \end{Bmatrix}i!$$
于是答案可以写为
$$\sum_{c=0}^k \binom kc c! [x^c]\left(  \sum_{i=1}^n \begin{Bmatrix}n \\ i \end{Bmatrix} x^i\right)^{17}$$
可以直接 $\Theta(n^2)$ 计算，注意 $c$ 只需取到 $17n$ 即可。

****
至于最终的答案，都很容易计算，这里就不给出了。（而且也有人通过 WA 信息套取数据 AC 了）

---

## 作者：Frielen (赞：4)

# 前言

本题虽然已经有 $2$ 份大佬的题解了，但讲的没有那么容易理解，因此本蒟蒻就来写一篇题解，尽量写的详细些，还是偏向于补充性质的。

叠甲：题解中可能会有非正解的想法，但大多是我自己想出来的。还有一些未详细证明，因为本题解以实现为主。

**为防止有人抄题解通过此题，将不会放出 #6 和 #12 的代码**

# 正文

## T1 求$\lfloor \sqrt n \rfloor$

### T1-1

观察一下，我们大体可以这么描述这个数字：$5 \underbrace{44444\dots}_{一些4} 2 \underbrace{88888\dots}_{一些8} \underbrace{917134\dots}_{乱码}$。

观察不难发现，乱码部分与前面的部分相比较小，因此我们完全可以考虑将乱码部分统一成一段有规律的数而不影响答案，我们又发现 $4$ 大约占了一半，**于是，我们可以猜测将乱码统一为 8**。这时，问题转换为：**找到 $\lfloor \sqrt {5 \underbrace{44444\dots}_{k个4} 2 \underbrace{88888\dots}_{k个8}} \rfloor$ 的规律**。

打表发现，$t=1$ 时答案为 $232$ ，$t=2$ 时答案为 $2332$，以此类推。所以，我们打表 $2\underbrace{33333\dots}_{t个3}2$，但这和答案却没有很大的直接联系。于是我们尝试对 $2\underbrace{33333\dots}_{t+1个3}$ 打表，能够发现明显规律：${2\underbrace{33333\dots}_{t个3}}^{2}=5\underbrace{44444\dots}_{t-1个4}2\underbrace{88888\dots}_{t-1个8}9$，使用 数学归纳法 容易证明其正确性。

我们又发现，乱码的开头是 $9$，答案是不会小于 $2\underbrace{333\dots3333}_{数量比题目中4的数量多1}$ 的，那么我们可以说: **题中有 $2200000$ 个 $4$ ，因此答案为 $2\underbrace{33333\dots}_{2200001个3}$**

### T1-2

我们发现除了结尾的 $1$ 都很有规律，所以我们大胆猜测答案满足前面的部分很有规律，最后接上一个 $1$。对于剩下的部分，我们在小学奥数中容易找到类似的规律：

$$11^2=121$$
$$111^2=12321$$
$$1111^2=1234321$$

回到此题，我们注意到此题的循环节是这样的：$$一个循环节 = \begin{cases}
  一个4的倍数\ \\
  一堆0 \\
\end{cases}$$

既然是 $4$ 的倍数，那么不难想到它是由 $2$ 的倍数平方得到。结合上面的“规律”，可以猜测答案的形式如下：$\underbrace{2\underbrace{000\dots}_{一堆0}2000\dots}_{一堆2000\dots}1$

这样子完全可以打表找规律，第 $1$ 次打表知道 $0$ 的数量是 $5$，第 $2$ 次打表知道答案若有 $k$ 个 $200000$，则原数有 $14\times k+1$ 位，而原数共有 $10170609$ 位，那么答案就有 $726472$ 位，即答案为：$\underbrace{200000}_{726472个200000}1$。

**总结：该部分对数学要求能力不强，更考验找规律~~乱搞~~的能力**

## T2 二分图完美匹配

**说明：接下来称左侧的第 $i$ 个点为 $L_i$，右侧的 $i$ 个点为 $R_i$**

### T2-1

手玩不难发现，$L_i $ 似乎连接着 $R_1,R_2,R_3,......R_i$。如何验证？对$L_k$ 连接的右侧 $k$ 个点排序即可，排序代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int op,n,m,cnt[1145];
bool flag=1;
bool check(){
	for(int i=1;i<=m;i++){
		if(cnt[i]!=i)
			flag=0;
			return flag;
	}
	return flag;
}
int main(){
	freopen("3.in","r",stdin);
	freopen("3.out","w",stdout);
	cin>>op;
	cin>>n;
	for(int i=1;i<=n;i++){
		cout<<"左侧的第"<<i<<"个点连接了右侧的： ";
		cin>>m;
		for(int j=1;j<=m;j++) cin>>cnt[j];
		sort(cnt+1,cnt+m+1);
		for(int j=1;j<=m;j++) cout<<cnt[j]<<" "; 
		check();
		cout<<"\n";
	}
	if(flag) cout<<"\n规律是：左侧的第 i 个点连接右侧的点 1,2,3,......,i";
	return 0;
}
```

于是，我们能够确定这个规律了。

推一下规律：$L_1$ 只能连接 $R_1$。$R_1$ 被连过了，因此 $L_2$ 不能连它，只能连 $R_2$，以此类推。那么，对于 $1 \le i \le n$，必然有 $L_i$ 只能连接 $R_i$，即答案为 $1$。

### T2-2

将输入数据在记事本中缩小，可以发现输入数据是 $14$ 个~~豆腐块~~矩形。根据上一问的套路，我们将输入数据的右端点们排序。

容易发现，$14$ 个矩形似乎对应着 $14$ 个全连通块。我们再次考虑使用代码检验，判断代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int op,n,m,cnt[888][888],old=1;
bool check(int a,int b){
	for(int i=a;i<=b;i++){
		for(int j=a;j<=b;j++){
			if(!cnt[i][j]) return 0;
		}
	}
	return 1;
}
int main(){
	freopen("4.in","r",stdin);
	freopen("check.out","w",stdout);
	cin>>op;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>m;
		for(int j=1,k;j<=m;j++){
			cin>>k;
			cnt[i][k]=1;
		}
		if(check(old,i-1)&&!check(old,i)&&i!=old){
			cout<<"["<<old<<","<<i-1<<"]是一个全连通块\n";
			old=i;
		}
	}
	if(check(old,n)) cout<<"["<<old<<","<<n<<"]是一个全连通块\n";  // 写法差异，本人代码要特判 
	return 0;
}
```

那接下来就好办了，对于一个全连通块 $[l,r]$，可以任意连接，只要不重复即可。我们知道，$L_l$ 有 $r-l+1$ 种选择，$L_{l+1}$ 有 $r-l$ 种选择，因为有一种被 $L_l$ 选了，以此类推。所以该全连通块有 $(r-l+1) !$ 种选择，得到 $14$ 个答案后相乘即可。但是 C++ 每次乘后要进行一次取模操作防止爆精度，因此我选择用 Python 偷懒，代码如下：
```
def jc(a):
    res=1
    for i in range(1,a+1):
        res*=i
    return res
print((jc(70)*jc(58)*jc(45)*jc(55)*jc(78)*jc(61)*jc(51)*jc(63)*jc(70)*jc(67)*jc(76)*jc(54)*jc(70)*jc(68))%998244353)
```

输出答案即可。

### T2-3

题目开始上强度了。这里使用了 oeis，需要 dp 或正解没必要看了。

**特别的，此题解中 $k=j$ 时认为 $ k\bmod j=j$**

数据等价于 $L_i$ 连接 $R_{i\bmod60000}，R_{(i+1)\bmod 60000}，R_{(i+2)\bmod 60000}，R_{(i+3)\bmod 60000}，R_{(i+4)\bmod 60000}$

这是一个看起来就很 dp 的东西。所以我们假设 $Ans[j]$ 为 $L_i$ 连接 $R_{(i+1)\bmod j}，R_{(i+2)\bmod j}，R_{(i+3)\bmod j}，R_{(i+4)\bmod j}$ （$1 \le i \le n$），那问题变为求 $Ans[60000]$。

不会写 dp 怎么办？既然是 dp，那就可以爆搜前几个数的结果，那就可以丢进 oeis 找规律。其实这里有赌它是常系数而且是 dp 的成分，在其他题目中不可取。

爆搜程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool check[50][50],vis[50];
int n,ans;
void dfs(int now){
	if(now==n+1){
		ans=(ans+1)%998244353;
		return;
	}
	for(int i=1;i<=n;i++){
		if(check[now][i]&&!vis[i]){
			vis[i]=1;
			dfs(now+1);
			vis[i]=0;
		}
	}
}
int main(){
	for(n=5;n<=40;n++){
		ans=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				check[i][j]=0;
		for(int i=1;i<=n;i++){
			for(int j=0;j<=4;j++){
				if(i+j==n) check[i][i+j]=1;
				else check[i][(i+j)%n]=1;
			}
		}
		dfs(1);
		cout<<"n="<<n<<"    "<<"ans="<<ans<<"\n";
	}
    return 0;
}
```

搜索效率可观，很快就能搜到 $n=20$。就可以放到 oeis 上面搜。由于作者本人原因暂时上不了 oeis，所以就不放式子了。

### T2-4

发现有 $4$ 个 左侧点只连接 $2$ 个右侧点，少量的左侧点连接 $3$ 个右侧点，其余左侧点连接 $4$ 个右侧点。容易想到网格图。什么是网格图？怎么想到的？看看下面的图就知道了。

![](https://cdn.luogu.com.cn/upload/image_hosting/g6idefkz.png)

这就是一张 $4\times 5$ 的网格图，所有想法就都不言而喻了。

我们发现，网格图等于说：可以将任意两个相邻的点放到一个小集合里，然而一个点只能在一个集合中，一个集合内有且仅有两个点，所有点都在集合中的方案数，也就是用 $1\times 2$ 的骨牌铺满 $n\times m$ 的地面的方案数。

观察四个度为 $2$ 的点，发现 $n=511,m=118$，轮廓线dp 废掉了，考虑数学方法。

直接给出结论：

$$4^{\frac{m}{2}\lfloor\frac{n}{2}\rfloor}\prod_{k=1}^{\lfloor\frac{n}{2}\rfloor }\prod_{j=1}^{\frac{m}{2}}(\cos^2 \frac{k\pi}{n+1}+\cos^2 \frac{j\pi}{m+1})$$

证明见下图，非常感谢 Union_of_Britain 提供的解析。

![](https://cdn.luogu.com.cn/upload/image_hosting/iz5ru8i6.png)

注：如果没搞错，开根后应当是没有 $\cos$  的和平方的，平方应删去。

我们知道 $cos \pi x=\dfrac{\omega_t^{\frac{tx}{2}}+\omega_t^{\frac{-tx}{2}}}{2}$，即 $cos^2 \pi x=\dfrac{\omega_t^{tx}+\omega_t^{-tx}}{4}+\dfrac{1}{2}$

说明：复数 $\omega$ 满足 $\omega^n=1$，称 $\omega$ 是 $n$ 次单位根，记作 $\omega_n$。把单位圆 $n$ 等分，取这 $n$ 个点所表示的复数，即为 $n$ 次单位根。

答案就是:

$$\prod_{j=1}^{\lfloor \frac{n}{2}\rfloor} \prod _{k=1}^{\lfloor \frac{m}{2}\rfloor}(\omega_{119}^{k}+\omega_{119}^{-k}+\omega_{512}^{j}+\omega_{512}^{-j}+4)$$

不难发现，$\omega_{119}$ 和 $\omega_{512}$ 这个东西按照定义，就是让你求 $119$ 和 $512$ 在模 $998244353$ 意义下的原根，暴力计算即可。

请注意：不要乘反！不要乘反！不要乘反！

**总结：此部分极难，后两个点需要较高的数学素养~~或 oeis~~**

## T3 生命游戏

**这个部分不要取模！！！**

显然，我们可以写一个暴力来模拟它，这里给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
bool f[4000][4000],f2[4000][4000];
const int N=3000;
int n,m,op;
string k;
char c;
int check(int q,int w){
	return f[q-1][w]+f[q+1][w]+f[q][w-1]+f[q][w+1]+f[q+1][w+1]+f[q+1][w-1]+f[q-1][w-1]+f[q-1][w+1];
}
int change(){
	int res=0;
	for(int i=1;i<N;i++){
		for(int j=1;j<N;j++){
			int qwp=check(i,j);
			if(qwp==3) f2[i][j]=1;
			else if(qwp==2) f2[i][j]=f[i][j];
			else f2[i][j]=0;
		}
	}
	for(int i=1;i<N;i++){
		for(int j=1;j<N;j++){
			f[i][j]=f2[i][j];
			res+=f[i][j];
		}
	}
	return res;
}
signed main(){
//	freopen
	cin>>op>>n>>m;
	cin>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='1') f[i+(N-n)/2][j+(N-m)/2]=1;
		}
	}
	for(int now=1;now<=2000;now++){
		cout<<change()<<"\n";
	}
	return 0;
}
```

### T3-1

跑模拟即可，规律是 $4022,4018,4018,4016$，又有 $1145141919810 \bmod 4=2$，答案为 $4018$。

### T3-2

找不到规律，考虑输出地图找规律。

打印地图的代码如下：

```cpp
void printmap(int a,int c,int b,int d){
	printf("from(%lld,%lld)to(%lld,%lld)\n",a,b,c,d);
	for(int i=a;i<=c;i++){
		for(int j=b;j<=d;j++){
			cout<<f[i][j];
		}
		cout<<"\n";
	}
	return;
}
int change(){
	int res=0;
	int countx_min=114514,county_min=114514,countx_max,county_max;
	for(int i=1;i<N;i++){
		for(int j=1;j<N;j++){
			int qwp=check(i,j);
			if(qwp==3) f2[i][j]=1;
			else if(qwp==2) f2[i][j]=f[i][j];
			else f2[i][j]=0;
		}
	}
	for(int i=1;i<N;i++){
		for(int j=1;j<N;j++){
			f[i][j]=f2[i][j];
			if(f[i][j]){
				countx_min=min(countx_min,i);
				countx_max=max(countx_max,i);
				county_min=min(county_min,j);
				county_max=max(county_max,j);
			}
			res+=f[i][j];
		}
	}
	printmap(countx_min,countx_max,county_min,county_max);
	return res;
}
```

不难发现，这个东西以 $4$ 为周期，每次斜着增大一圈。而 $k \bmod 4=0$，考虑对 $4$ 的倍数输出迭代结果，最后跑 拉格朗日插值，得到答案为： $4 \times (\frac{k}{4})^2+38\times (\frac{k}{4})+195$

用 python 跑高精度即可。

```
k=19246583716923021756376987231098475262985292403618248198921569148//4
print(4*k*k+38*k+195)
```

### T3-3

看到 $k$ 这么大，就知道要找规律了。要知道，这道题目是在一场公开赛中出现的，时长 $5.5$ 个小时，所以必然存在 $O(1)$ 或 $O(\log k)$ 的解。

首先考虑 $O(1)$，我们打表迭代，即使是打印地图也找不到规律。对答案进行 拉格朗日插值，到 $300$ 代都没有确定的多项式（如果你算了更多代发现有规律就当我没说），因此 $O(1)$ 的想法是不可能的。

因此，答案只能是 $O(\log k)$ 级别的，很容易想到倍增。第一反应就是质因数分解。试着丢进 python，发现 $k=2^{1339}\times 3 \times5$。这说明我们的想法大概率是正确的！直接观察 $2^j \times 15$ 的迭代结果。

注意，这里要对暴力进行优化：找到上一轮扩张的边界，这次扩张的边界影响不会超过它的周围一圈，可以少搜很多点，搜到 $t=7$ 时只要 $37$ 秒。注意 $N$ 和数组大小要改，防越界。然后其实还要用 bitset 优化，不然空间跑不过去。
 
然后发现，从 $t=6$ 开始形成了等差数列（从 $6$ 到 $9$ 四个数字够有说服力了吧！），算一下发现答案是 $5 \times t+346$，就很显然了。

**总结：这个部分不需要很多的数学知识，你要敢写敢猜，还需要一点码力，不过个人感觉总体对我这种数学菜鸡还算简单**

## T4 无向图染色

### T4-1

发现有 $n$ 个点 $n-1$ 条边，考虑到这可能是一棵树，用并查集试一下发现确实如此。

取一个点，令它能够取满 $k$ 种颜色，那与其连通的点只有 $k-1$ 种颜色选，再拓展的点只有一种与已经染色的点连线的方案，所以答案就是 $k\times(k-1)^{n-1}$，连快速幂都用不着，直接暴力即可。

```
#define mod 998244353
long long normal_pow(long long k,long long n){
	long long res=k%mod;
	for(int i=1;i<n;i++){
		res=(res*(k-1))%mod;
	}
	return res%mod;
}
```

输出答案即可。

### T4-2

看似毫无头绪，但是我们可以从一开始的点想到一个问题：**为什么要将 $123$ 至 $355$ 拎到前面呢？** 观察发现，$123$ 至 $355$ 的点形成了一个团！至于团内的方案数则好想：就是 $k$ 种颜色里选出 $355-123+1$ 种的排列方案数，即$ A^{355-123+1}_k=A^{233}_k$。

剩下的点都是连接团的散点，也很好求：设一个点有 $p$ 条边连接团，则有 $k-p$ 种颜色可选，最后将所有结果相乘即可，给出实现。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int op,n,m,k,a,B,mod=998244353;
int deg[1145];
int b[114514+1919],c[114514+1919];
int ans=1;
int Fastpow(int base,int k){
	int res=1;
	while(k){
		if(k&1) res=(res*base)%mod;
		k>>=1;
		base=(base*base)%mod;
	}
	return res%mod;
}
int A(int n,int m){
    return (c[n]*b[n-m])%mod;
}
signed main(){
	freopen("11.in","r",stdin);
	cin>>op>>n>>m>>k;
	b[0]=c[0]=1;
    for(int i=1;i<=114514+1910;++i){
        c[i]=(c[i-1]*i)%mod;
        b[i]=Fastpow(c[i],mod-2);
    }
	for(int i=1;i<=m;i++){
		cin>>a>>B;
		if(a>=123&&a<=355) continue;
		deg[a]++;
	}
	for(int i=1;i<=1000;i++){
		if(i>=123&&i<=355) continue;
		ans=(ans*(k-deg[i]))%998244353;
	}
	cout<<(ans*A(k,233))%mod;
	return 0;
}
```

### T4-3

手玩不难发现规律：对于任意点 $l$ ，当且仅当 $l \bmod 17 \neq k \bmod 17$ 时连接点 $k$ 与点 $l$。

如果让人来操作，会怎样实现它呢？

注：以下称同余于 $p$ 的缩系（$1 \le p \le 17$）为第 $p+1$ 个集合

首先，从 $k$ 种颜色选出 $i$ 种，再把 $i$ 种颜色分为 $17$ 份给到每个集合。若用 $f(i_j)$ 代表第 $j$ 个集合内部分配颜色的方案，$g(i)$ 表示将 $i$ 种颜色分配给 $17$ 个集合的方案数，则答案为：

$$\sum_{i=0}^{k}\left( \begin{array}{c} k \\ i \end{array} \right)\sum_{i_1+i_2......=i}^{} g(i)\prod_{j=1}^{17} f(i_j)$$

先考虑分拆 $f(i,j)$，函数内部可以分为两个部分：$i_j$ 个颜色分配给集合内元素和颜色的排列。第二个简单，就是 $i_j$，至于第一个，相信熟悉组合数学的大家已经看出来了，就是 第二类斯特林数！所以原式被拆为：

$$\sum_{i=0}^{k}\left( \begin{array}{c} k \\ i \end{array} \right) \sum_{i_1+i_2+......=i}g(i) \prod_{j=1}^{17} \begin{Bmatrix} n\\i_j \end{Bmatrix} i_j!$$

根据意义，有 $g(i) \prod_{j=1}^{17}i_j!=i!$，即式子又可以化为：

$$\sum_{i=0}^{k}\left(\begin{array}{c}k\\i\end{array}\right)i!\sum_{i_1+i_2......=i}\prod_{j=1}^{17} \begin{Bmatrix} n\\i_j \end{Bmatrix}$$

拆贡献，变成多项式后计算即可。

**那么不会拆式子，就做不了这题了吗？**

当然不是，还有伟大的 dp。

设 $dp(i,j)$ 表示考虑了前 $i$ 个集合染 $j$ 种颜色的情况，就显然会有以下的转移：

$$dp(i,j)=\sum_{p=1}^{100}dp(i-1,j-p) \times A_{k-j+p}^{p} \times \begin{Bmatrix} p\\100 \end{Bmatrix}$$

简单说一下，就是相当于说，已经知道了前 $i-1$ 个集合染几个颜色的答案已知。那么，我希望得到 $dp(i,j)$。第 $i$ 个集合有可能染 $1$
  到 $100$ 个颜色。对应的，我的 $dp(i,j)$ 就与 $dp(i-1,j-1)$ 到 $dp(i-1,j-100)$ 有关。特别的，对于 $dp(i-1,j-p)$ 到 $dp(i,j)$ 的转换，给一个集合染 $p$ 个颜色，显然有 $\begin{Bmatrix} p\\100 \end{Bmatrix} \times A_{k-j+p}^{p}$ 种方案，全部加起来即可。不懂斯特林数的可以去看定义。

答案就显然了，就是：

$$\sum_{i=1}^{k} dp(17,i)$$

虽然说和第一个方法本质相同吧，但比第一个方法好想几百倍了，然而目前两篇题解都不是用 dp。所以说看到一道题不会写，题解也看不懂，不意味着你不可能写出来。可能还有更适合你的方法。

**总结：考的非常均衡的一个部分，需要一些代码能力。**

---

## 作者：littlez_meow (赞：4)

[题目指路](https://www.luogu.com.cn/problem/P8562)。

### 思路

#### Case $1$

输入为一个 $5$，一堆 $4$，一堆 $8$，$4,8$ 之间夹了一个 $2$，和最后混乱的一段，且 $4$ 的位数约为 $8$ 的位数的两倍。

先缩小规模，研究 $54280$ 的平方根，后面补一个 $0$ 是因为奇数位比较容易猜平方根。其值约为 $232.98$，很接近 $233$。这是因为 $54289=233^2$。

进一步地，$2333^2=5442889,23333^2=544428889$。归纳可以得到 ${2\underbrace{3\cdots3}_{t\ 个\ 3}}^2=5\underbrace{4\cdots4}_{t-1\ 个\ 4}2\underbrace{8\cdots8}_{t-1\ 个\ 8}9$，其位数为 $2t+1$。

虽然最后有很多乱七八糟的位，但既然向下取整，我们猜它的答案就是 $2\underbrace{3\cdots3}_{t\ 个\ 3}$。输入共 $4400003$ 位，故 $t=2200001$。

#### Case $2$

如果把最后一位改成 $0$，输入从某种意义上来说比较对称。

考虑顺着构造答案，使其平方和输入越来越相近。

先从开头的 $40000008000000$ 开始。由于其中间隔了 $6$ 个 $0$，这说明应该是个 $10^6$ 量级且很多个 $0$ 的数。又由于要形成回文，我们需要把一个数重复写若干遍。

先试试 $20000002000000$，发现平方为 $400000080000004000000000000$，比较对称，但是没那么对称。最后一段 $0$ 太多了。结合输入的结尾是 $1$，尝试在最后接上一个 $1$，得到 $200000020000001$。其平方为 $40000008000000800000040000001$，非常符合输入。

再往前接上一个 $2000000$，中间出现了 $1200000$，正好是输入中有的。

归纳得到，答案为 $\underbrace{2000000\cdots2000000}_{t 个 2000000}1$。其平方有 $14t+1$ 位。输入共 $10170609$ 位，故 $t=726472$。

#### Case $3$

输入的二分图左部第 $i$ 个点会跟右部 $1\sim i$ 所有点连边。因此第 $1$ 个点只能和 $1$ 匹配，第 $2$ 个点只能和 $2$ 匹配……答案为 $1$。

#### Case $4$

输入是杂乱无章的。根据上一个数据点的经验，每一个点连的边可能被重排过。考虑把每个左部点连接的右部点按编号排序，发现图可以被划分成若干区间，每个区间 $[l,r]$ 表示左部编号在 $[l,r]$ 中的所有点和右部 $[l,r]$ 中所有点两两连边，即其生成子图为 $K_{r-l+1,r-l+1}$。

因此，答案可以变成每个区间的答案之积。对于一个区间 $[l,r]$ 的答案，我们可以构造双射。对于任何一种匹配，若 $i$ 匹配 $j$，则令 $p_{i-l+1}=j-l+1$。则匹配可以和长为 $r-l+1$ 的排列构成双射，答案为 $(r-l+1)!$

直接相乘即可。这几个区间分别为 $[1,70]$、$[71,128]$、$[129,173]$、$[174,228]$、$[229,306]$、$[307,367]$、$[368,418]$、$[419,481]$、$[482,551]$、$[552,618]$、$[619,694]$、$[695,748]$、$[749,818]$、$[819,886]$。

#### Case $5$

输入中的左部点 $i$ 会和右部点 $i\sim i+4$ 连边，如果编号大于 $n$ 就从 $1$ 重新开始。

设 $dp(i,S,T)$ 表示考虑到点 $i$，右部点 $[i,min\{i+4,n\}]$ 选出的集合为 $S$，右部点 $[1,4]$ 选出集合为 $T$ 的方案数。转移显然，直接 dp 即可，注意边界情况。可以得到 $n=5,6,7\cdots$ 时的答案为 $120,265,579,1265,2783,6208,13909\cdots$。丢进 [oeis](https://oeis.org/search?q=1%2C2%2C6%2C24%2C+120%2C265%2C579%2C1265%2C2783%2C6208%2C13909&go=Search)，得到其可以线性递推，系数为 $\{3,0,-2,-2,-6,2,4,2,2,-1,-1\}$。

如果没有 oeis，可以拉插和 BM 都试一下，发现不是多项式，但可以得到线性递推式。

注意到该递推式是从 $n=5$ 开始的，而非 $n=0$。

#### Case $6$

发现每个点的度数都不超过 $4$，猜测是网格图黑白染色后输出。

左部第一个点连上了右部第 $60$ 个点，说明第一行有 $59$ 个右部点，进一步说明第一行有 $118$ 或 $119$ 个点。又因为 $119\nmid30149\times2$，故第一行共 $118$ 个点。也就是说这是一个 $118\times511$ 的网格图。下记 $n=118,m=511$。

网格图完美匹配相当于 $1\times2$ 骨牌覆盖方案计数。问题转化为求骨牌覆盖计数。

通过一些[复杂的组合数学与线性代数知识](https://www.bilibili.com/video/BV1G8411x7GU)，我们有方案数为：

$$\prod_{j=1}^{\left\lceil\frac{m}{2}\right\rceil} \prod_{k=1}^{\left\lceil\frac{n}{2}\right\rceil}\left(4 \cos ^{2} \frac{\pi j}{m+1}+4 \cos ^{2} \frac{\pi k}{n+1}\right)$$

实数计算是困难的，我们需要更好的方法在模意义下计算三角函数，比如单位根。

根据欧拉公式，我们有 $\cos x=\dfrac{e^{ix}+e^{-ix}}2$。又由 $\omega_t=e^{\frac{2\pi}ti}$，得 $cos(\pi x)=\dfrac{\omega_t^{tx/2}+\omega_t^{-tx/2}}{2}$。因此 $cos^2(\pi x)=\dfrac{\omega_t^{tx}+\omega_t^{-tx}+2}{4}$。

原式中，$x=\dfrac{j}{m+1}$ 或 $\dfrac{k}{n+1}$。第一个就取 $t=m+1$ 消掉分母，第二个取 $t=n+1$，得到原式为：

$$\prod_{j=1}^{\left\lceil\frac{m}{2}\right\rceil} \prod_{k=1}^{\left\lceil\frac{n}{2}\right\rceil}\left(\omega_{m+1}^j+\omega_{m+1}^{-j}+\omega_{n+1}^k+\omega_{n+1}^{-k}+4\right)$$

由于 $n+1|p-1,m+1|p-1$，直接用原根计算即可。具体地，若原根为 $g$，则单位根 $w_t$ 在模意义下等于 $g^{\frac{p-1}t}$。

#### Case $7$

在开始这一部分前，可以先看一下[这个视频](https://www.bilibili.com/video/BV1HK4y1Q7kj)。

既然是这一部分第一个点，肯定不会太难，猜测输入为振荡器或飞船。其细胞数肯定成周期性变化。

模拟发现变化周期为 $4016,4022,4018,4018$，从 $0$ 时刻开始。

#### Case $8$

模拟发现这个输入的变化类似于上面提到视频中“快速铺满平面”，显然细胞数为 $O(t^2)$。四个角向外延申时，以 $4$ 为周期变化。输入给的 $k$ 显然能被 $4$ 整除。设当前时刻为 $4t$，插值得到细胞数为 $4t^2+38t+195$。高精度即可。

#### Case $9$

我觉得这个点是整道题最难的点。

输入要求 $10^{400}$ 多代后的结果。但是打表发现其答案又没有周期。如果再是线性递推式增长哪怕是平方增长答案都会巨大无比。~~出于对出题人的信任~~我们猜测是对数增长的。

当然，我们的猜测还是要有依据的。但是看着那个非常抽象的输入数据我根本不想分析。怎么办呢？既然是对数，答案又要好算，迭代代数肯定可以写成次幂乘一些数，好像可以质因数分解。但是 $10^{400}$ 就算 `Pollard-Rho` 也没法跑过去。不过，如果真的是对数增长，肯定有一个质因数的指数极大，这样分解的时间复杂度就会变成 $O(\log n)$，是可以分解出来的。丢进高精度分解器，很快就分解出来了，等于 $2^{1339}\times3\times5$。$2$ 上的指数非常大，我们的猜测似乎进一步正确了。

既然是对数增长，我们接下来研究 $2^t\times15$ 代的值，此时的值应该是关于 $t$ 的低次多项式。

$t=0\sim5$ 的值很乱，但是从 $t=6$ 开始，值变成了首项 $376$，公差为 $5$ 的等差数列。这说明当迭代代数 $k=2^t\times15$ 足够大时，答案为 $5(t-6)+376$。

#### Case $10$

输入 $n$ 个点，$n-1$ 条边。稍微检验一下连通性，发现是树。

任选一个点为根开始，根有 $k$ 中染法，剩下所有点都有 $k-1$ 种，因为只要和自己父亲不同就行。答案为 $k(k-1)^{n-1}$。

#### Case $11$

发现输入是 $123\sim355$ 组成的完全图和旁边挂着的点，非完全图的点之间不互相连边。先给完全图部分染色，方案数为 $A^{355-123+1}_k$；再给剩下的点染色，连了多少个完全图内的点就有多少种颜色不能涂。全部乘起来就行。

#### Case $12$

输入数据中 $1$ 似乎跟其他所有点连了边。但仔细观察，发现 $1$ 没有和 $18,35,52$ 等连边。它们的共同点是模 $17$ 余 $1$。再看看 $2$，发现其不和模 $17$ 余 $2$ 的点连边。猜测 $x,y$ 连边当且仅当模 $17$ 不同余。

图中一共 $1700$ 个点，按模 $17$ 的余数分类，共 $17$ 类，每类 $100$ 个点。同类颜色可以相同，不同类颜色不能相同。

枚举每一类的颜色集合，钦定它们不相交。再枚举颜色总数，得到答案为：

$$\sum\limits_{i=0}^k\binom{k}{i}\sum\limits_{i_1+\cdots+i_{17}=i}\binom{i}{i_1,\cdots,i_{17}}\prod_{j=1}^{17}S(100,i_j)i_j!$$

分别解释一下每一部分是什么意思。$\dbinom{k}{i}$ 表示从 $k$ 种颜色里面选 $i$ 种。$\dbinom{i}{i_1,\cdots,i_{17}}$ 表示把 $i$ 种颜色分配给每个集合，第 $j$ 个集合分配 $i_j$ 种颜色。$S(100,i_j)i_j!$ 表示将一类分成 $i_j$ 个集合，每种划分方式有 $i_j!$ 种染色方式。

对上式多重组合数拆贡献，得：

$$\sum\limits_{i=0}^k\binom{k}{i}i!\sum\limits_{i_1+\cdots+i_{17}=i}\prod_{j=1}^{17}S(100,i_j)$$

这个式子看着就很多项式。用多项式表示：

$$\sum\limits_{i=0}^k\binom{k}{i}i![x^i]\left(\sum\limits_{j=1}^{100}S(100,j)x^j\right)^{17}$$

暴力多项式乘法就好了。

---


# You are the Miserable

## 题目描述

小 A 和小 B 玩游戏。小 A 有一个凸 $n$ 边形以及 $n-3$ 条不交的对角线构成一个三角剖分。每一次，小 B 可以问小 A 某一条对角线 $x-y$ ，小 A 会回答他该对角线是否在他的三角剖分中。小 B 想要对于每一条 **三角剖分中** 的对角线得到至少一次肯定的答复。他希望询问的次数尽量少，而小 A 希望询问次数尽量多，并且有可能会根据小 B 的询问来改变他的三角剖分。但在这个过程中，小 A 的三角剖分不能与他曾做出的回答矛盾。

现在，给出小 A 和小 B 玩的若干步，判断它们的游戏过程是否保持最优。如果是，输出 $0$；如果不是，输出第一次不是最优的操作，形如 `A x` 或者 `B x`，表示小 A 或者小 B 的第 $x$ 次操作不是最优的。

具体地，保持最优的定义如下：假设最优情况下小 B 要询问 $k$ 次，那么每一步过后，双方最优的策略仍然使得总的询问次数为 $k$，第一次使得询问次数不为 $k$ 的步骤就是需要输出的步骤。

他们玩了 $T$ 次独立的游戏，你需要对每一次询问作出回答。

**注意：**

-   数据保证，直到第一次不优的操作被做出，小 A 的回答都是合法的，即总存在一个三角剖分符合小 A 做出的所有回答。
-   数据不保证，在第一次不优的操作被做出以后，小 A 的回答仍然保持合法，即可能不存在一个三角剖分符合小 A 做出的所有回答。

**【提示】**

1. 多边形的对角线指连接不相邻两个顶点的线段。
2. 多边形的三角剖分指 $n-3$ 条仅可以在顶点处相交的对角线构成的集合。

## 说明/提示

【样例解释】

对于 $n=5$，最优的 $k=4$。对于 $n=4$，最优的 $k=2$。对于最后一组数据，B 重复询问同一条边已经不是最优，此时 A 的回答可以不合法。

【数据范围】

$1 \le T\le 10^3$，$4\le n \le 10^5$，$1 \le \sum n \le 2\times 10^5$，$1 \le m \le k$，$1 \le x,y \le n$，$0 \le z \le 1$。保证所有的 $x-y$ 都是合法的对角线，以及直到第一次不是最优的一步所有询问的回答都至少对应一种三角剖分。

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c|c|c}\hline 
\textbf{~~测试点编号~~}&\bm{~~T\le~~}&\bm{~~n \le ~~}&\bm{~~~~m~~~~}& ~\bm{z}~\cr\hline 
\textsf1\sim \sf2 &100 &5  &  \cr\hline 
\sf3\sim 4 & 100& 7& &\cr\hline 
\sf5 \sim 6 &100 &8 & & \cr\hline 
\sf7 \sim \sf9 & & &=1 & \cr\hline 
\sf10\sim 12 & & & & =0\cr\hline
\sf13\sim 16 &20 &200\cr\hline
\sf 17 \sim 20
\end{array}
$$

## 样例 #1

### 输入

```
5
4 2
1 3 0
2 4 1
5 4
2 5 0
1 4 0
3 1 1
2 4 0
5 4
1 3 0
2 4 1
2 5 0
1 4 1
5 4
1 3 0
5 3 0
1 4 1
2 5 0
4 2
1 3 0
1 3 1```

### 输出

```
0
B 4
0
B 2
B 2```

# 题解

## 作者：JohnVictor (赞：4)

#### Solution 1

手玩 $n\le 5$，期望通过数据点 $1,2$。如果有惊人的毅力可以手玩 $n \le 7$，通过数据点 $3,4$。

写一个爆搜或者状压 dp，期望通过数据点 $1 \sim 6$。如果写的不好可能过不了 $n=8$ 的点。期望代码量 $4\text{kb}$，非常不好写。

#### Solution 2

本题的主要部分就是猜测和验证以下的一系列结论。诱导出结论的过程大致是从两头开始优化最终达到的平衡。

一种观点是每一次 Yes 会将整个游戏分治成两个游戏。在之后的题解中也会多次用到这个观点，我们会运用【当前的多边形】来表示被分治出来的某个游戏。之后我们会发现被在最优情况下分治出来的游戏只有一个还有再提问的空间。

**结论 0** B 不会询问和已经确定存在的边相交的边，因为这些边肯定不存在。

**结论 1** 最优的 $k=2n-6$。

**证明** 注意到 $2n-6=2(n-3)$，之后我们的策略也会往“一次 Yes 回答对应一次 No 回答"这个方向去靠拢。

此外注意到一次 Yes 询问相当于是将整个游戏分治成了两个游戏，当然和这次 Yes 相交的 No 也就不带来任何额外信息了。从这一点我们很容易看出 A 有如下策略：回答 Yes 当且仅当这次询问和之前的询问相交，这样一次 Yes 至少对应一次 No，也就是 $k \ge 2n-6$。

而从同样的角度思考，我们也能给出一种 B 的策略。B 不断询问长度为 2 的边，并且保证被询问到的边是连续的一段。如果得到 Yes 的答案，有一个 No 白费了，并且 $n$ 减少了 $1$，因此这个方案最多询问了 $2n-6$ 次。

当然上述证明可能会带来疑问，例如会不会围成一圈了还没有得到答案。这当然是不会的，因为统计边数就能得知整个三角剖分至少有两条长为 $2$ 的弦。

**结论 2** 所有一直最优的策略如下：对于 B，每一次询问之后得到的所有 No 必须是当前的多边形中一些连续的长为 $2$ 的弦（指弦的中点连续）；并且除非已经得到了 $n-3$ 次 No，也就是确定了剩余部分是一个点连出若干条边以外可以任意顺序问这个已知的三角剖分以外，必须继续询问长度为 $2$ 的弦。对于 A，由于 B 必须采用上述策略，只用所有 Yes 的时候都有相交就行。

**证明** 上面的叙述中已经证明了 A 的策略（在假设 B 的策略的前提下），这里主要证明 B 的策略。

我们引入 **坏弦** 的定义，一条弦为坏的当且仅当它没有被问过，并且存在一种使得这条弦答案为 Yes 的问题，并且和两条以上问过的 No 相交。如果任意时刻出现坏弦，那么 A 告诉 B 这条弦答案为 Yes，B 必须询问这条弦，那么就亏了一次以上的操作。到这里可以用归纳法证明结论，然而这种证明要对前几条弦进行繁琐的讨论（可能要四步以上才会出现坏弦），感兴趣的读者可以自行补全。

这里叙述一个较为简短但是不那么自然的证明，同时可以引入一个比较好玩的结论。

**引理** 对于任意 $n-3$ 条弦，存在一个不包含其中任意一条弦的三角剖分。更进一步地，除非这 $n-3$ 条弦是相邻的长为 $2$ 的弦，这个三角剖分都不唯一。

如果有了引理，A 可以无脑回答 $n-3$ 次 No；这样如果 B 某一次操作不按照要求，$n-3$ 次后还无法唯一确定，那么肯定不能在 $2n-6$ 次中得到答案。并且即使最后是 $n-3$ 条相邻的长度为 $2$ 的弦，任意时刻也必须连续，否则会出现坏弦。

**引理证明** 我们对 $n$ 归纳，$n\le 5$ 的情况容易验证。下面假设 $n\ge 6$ 并且 $n-1$ 时结论成立。

首先证明这样的三角剖分存在。考虑所有长度为 $2$ 的弦，一定有一条没有被选上。如果没有任意一条选上，任选一条和某条禁止的弦相交的弦；否则选择最边上一条长度为 $2$ 的弦再旁边一条。这样如果去掉和被选上的弦相交的弦就规约到了 $n-1$ 时的归纳假设。

当然唯一性也很好顺着上面的思路归纳得到。假设变成 $n-1$ 后不唯一，并且形成了多边形 $x_1x_2\cdots x_{n-1}$，其中 $x_ix_{i+2}(1 \le i \le n-4)$ 连边。

考虑是从什么角度扩展来的。如果被缩掉的点 $X$ 在某个 $x_ix_{i+1}$ 之间，其中 $1 \le i \le n-3$，那么考虑改连 $Xx_{n-1}$，分出的两个部分不包括缩点时去掉的弦分别含有 $u-4,v-4$ 条弦（$u,v$ 为这两部分的大小），那么加上一条弦最多 $u-3,v-3$，并且有一部分取不到等，肯定至少两种情况。另外两种对称的情况只用考虑一种，也就是在 $x_{n-1}x_1$ 之间，这时如果那条弦是 $Xx_2$ 那么就是所说的唯一的情况；否则是 $xx_{n-2}$，改连 $x_{n-1}x_{n-3}$ 就只剩下 $n-1$ 个点和 $n-5$ 条边，肯定有至少两种情况。证毕。

#### 实现

直接拿链表甚至 `set` 来维护都行，主要不要漏情况，尤其是重复询问。用中点表示弦可以节省代码量。时间复杂度视实现为 $O(n)$ 或者 $O(n\log n)$。

#### 后记

$m=1$ 的部分分说不定可以直接猜出第一次必须问长度为 $2$ 的弦。给的特殊性质 $z=0$ 也就是一直回答 No 是用来引导想到正解的。当然仔细观察给出的大样例也能猜到一些结论。

---

## 作者：olegekei (赞：2)

### update
- 2023.2.27 修了一下题解中的表达问题，以及管理漏掉的一处不规范的 Markdown。

本题解的思路主要参考了 JohnVictor 的[官方题解](https://www.luogu.com.cn/blog/JohnVictor/ti-xie-p8566-post)，请先在阅读本篇题解之前阅读官方题解。

实现代码的时候遇到了很多问题：[本人的艰难历程](https://www.luogu.com.cn/record/list?pid=P8566&user=593613)。

(~~第一篇黑题题解~~)

这里说一下我的做题思路：
## $15pts$
首先对于测试点编号 $7 \sim 9$，$m=1$ 的情况及其容易处理，只需要判断询问两个点是否仅差一个点，以及 A 给出的回复是否为 `0` 即可。$15$ 分轻松到手。
## $30pts$
接下来处理测试点编号 $10 \sim 12$，因为每次询问，A 给出的答复都一定是 `0`，而且题目已经保证在 B 的询问出现非最优之前 A 的答复一定合法，所以我们只需要判断 B 的询问是否最优即可（判断方法参考官方题解）：

>对于 B，每一次询问之后得到的所有 No 必须是当前的多边形中一些连续的长为 2 的弦（指弦的中点连续）；并且除非已经得到了 n-3 次 No，也就是确定了剩余部分是一个点连出若干条边以外可以任意顺序问这个已知的三角剖分以外，必须继续询问长度为 2 的弦。

$30$ 分也就拿到了。
## 代码实现问题
在开始写正解之前，有一部分实现比较难的地方：

对于这个 $n$ 边形，A 每次回答的 `1` 都会将这 $n$ 边形削掉一部分，这就意味着如果我们想要在 $n$ 边形上对每次操作进行处理会很困难。

所以我们需要维护一个链来表示这个 $n$ 边形。我本人是用了 $to$ 数组和 $back$ 数组来表示在当前 $n$ 边形中该点的下一个点和上一个点，而每次回答 $1$ 的时候操作一下这两个数组，把这次回答该削掉的点排除出去即可。

注意在代码实际操作中需要合理运用这个链，容易发现一个性质：

对于 A 给出的每个回答 `0`，不能对链进行任何操作。只有回答 `1` 才可以削掉 $x \sim y$ 中间的那个点。
## $100pts$
~~主要是一点爆搜和状压 dp 的思路都没有~~

下面我们规定 $cnt_0$ 代表 A 回复 `0` 的次数，$cnt_1$ 代表 A 回复 `1` 的次数。

对于输入给的每个 $n$，先构造出该 $n$ 边形的链，读入一组操作，将该操作定位基准操作点，之后对于 B 的每次询问都需要从该基准点向两侧扩展，否则操作非最优。

此处向两边扩展结合图片描述一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/eikpdbir.png)

读入该红色边，并以该红边对应的点为基准点：

![](https://cdn.luogu.com.cn/upload/image_hosting/7eocztkp.png)

此处黄色星星为基准点，下一个询问一定要从黄色星星往其中一个绿色星星连接。

经过第二次询问之后，就可以得到两个黄星星和两个绿星星：

![](https://cdn.luogu.com.cn/upload/image_hosting/02p1ko1l.png)

（相应的，下一次询问仍必须是紫色虚线两者其一）

切掉的紫线对应的黄星星和绿星星要往外扩散一个点。

-------------------------------------------------------

现在已经可以判断 B 的询问是否最优，再根据 A 的回答调整 $n$ 边形的边数：

如果 A 的回答是 `0`（即该边不存在）则不需要调整边数。

如果 A 的回答是 `1`，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/anekdd08.png)

此时切割出了一个三角形 $(1,2,3)$，不难发现切割之后 $2$ 号点就已经不可能再被切割了，所以可以处理为形如：

![](https://cdn.luogu.com.cn/upload/image_hosting/on83a7mg.png)

的一个五边形，之后可以当作 $n=5$ 进行处理。

------------------------------------------------------

对于 A,B 操作的处理已经搞完了，下面讲讲判断 B 的询问是否合法：

首先对于 B 询问的每条边都存一下，用来判重边（因为我本人代码实现上对于 $cnt_0<n-3$ 和 $cnt_0\ge n-3$ 是分开处理的，所以这里不判重连样例都过不去），当出现重边时 B 的询问即不合法。

另外，当 B 的询问与之前询问过的回答为 `1` 的边相交也为不合法。那么问题来了：如何判断当前询问与历史询问是否相交呢？

甚至暴力枚举都很难判断这一问题，我们手玩几组多边形，发现当 $cnt_0\ge n-3$ 时 B 剩下的所有询问都必须连一个从未被访问过的点，具体情况如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ng61f5bx.png)

此时一定是 $5$ 向其他五个点连接（因为不能连接相邻点 $4$ 和点 $6$，所以是五个点）后得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5nspglal.png)

对于这个结论是举不出反例的，如果 B 不按照结论进行连边，不打算连接 $5$ 号点而是选择连接 $(4,6)$ 的话：

![](https://cdn.luogu.com.cn/upload/image_hosting/qc47d1sy.png)

接下来分别考虑 $8,1,2$ 号点的连接，不难发现 $8$ 号点只能连接 $3,4$ 号点，$1$ 号点只能连接 $4,6$ 号点，$2$ 号点只能连接 $6,7$ 号点，这三者是无法同时满足的。

--------------------------------------------------------

其实到这里如果细节处理没问题的话交上去已经是满分代码了，但是本人交上去只得到 $65pts$，接下来说一下我挂分的位置：

首先对于 A 的每次 `1` 和 `0` 都统计了次数，当 $cnt_1=cnt_0$ 时当前 $n$ 边形已经重新成为了一个 $n-cnt_1$ 边形，也就是说我们需要重新把它当成一个 $n-cnt_1$ 边形来处理而不是继续承接 $n$ 边形来处理。

另外对于 $n=4$ 时，是需要让两个未被访问的点连接而不是一个被访问过的点向另一个未被访问过的点连接（$n=4$ 算是特殊情况）。

还需注意每次从 $n$ 边形转为 $n-cnt_1$ 边形时需要判断以下 B 询问的点必须在当前 $m$ 边形上存在。

最后即可拿到 $100pts$。

代码：
```cpp
#include<map>
#include<iostream>
using namespace std;
int n,m,cnt0,cnt1;
int to[200015],back[200015];
map<int,int>p[200015];//p记录重边
int d[200015];// d 表示是否被访问过
int x,y,z;//读入的x,y,z
bool vis[200015],f;//vis表示当前点是否在当前 n-cnt0 边形上，f记录A，B询问是否均最优
int midl,midr,exl,exr;
void getstart(int i){
	for(int i=1;i<=n;i++)d[i]=0;//因为重新当成 n-cnt1 边形来处理，所以 d 数组清零
	if(vis[x]||vis[y]){cout<<"B "<<i<<"\n";f=1;return;}//询问不合法，x或y点不在当前 n-cnt1 边形上 
	if(to[to[x]]==y){midl=midr=to[x];if(z){cout<<"A "<<i<<"\n";f=1;}} 
	else if(to[to[y]]==x){midl=midr=to[y];if(z){cout<<"A "<<i<<"\n";f=1;}}
	else{cout<<"B "<<i<<"\n";f=1;}
	p[x][y]=p[y][x]=1;
	d[x]++;d[y]++;
	exl=back[back[midl]];exr=to[to[midr]];
	cnt0++;
} 
int main(){
ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
int t;
cin>>t;
while(t--){
	f=0;
	cin>>n>>m;
	cnt0=cnt1=0;
	for(int i=1;i<=n;i++)p[i].clear(),vis[i]=d[i]=0;//初始化数组 
	for(int i=1;i<n;i++)to[i]=i+1;to[n]=1;//每个点的下一个点 
	for(int i=n;i>1;i--)back[i]=i-1;back[1]=n;//每个点的上一个点 
	cin>>x>>y>>z;
	getstart(1);//先找到基准点 
	for(int i=2;i<=m;i++){
		cin>>x>>y>>z;
		if(f)continue;
		if(cnt1==cnt0){getstart(i);continue;}
		if(vis[x]||vis[y]){cout<<"B "<<i<<'\n';f=1;continue;}//此点不在当前 n-cnt1 边形上，不可能再与其他点相连 
		if(cnt0<n-3){//此时必须连续询问长度为 2 的弦 
			 if((x==exl&&y==midl)||(y==exl&&x==midl)){//从midl向左边的点连边 
				if(p[x].count(y)){cout<<"B "<<i<<'\n';f=1;continue;}//重边！ 实测满足exl与midl时应该不会出现重边，所以注释掉了   实测连样例都过不去，所以注释回来了 
				p[x][y]=p[y][x]=1;
				if(!z){cnt0++;d[x]++;d[y]++;}//入度加一，cnt0加一 
				else{
					cnt1++;
					if(cnt1>cnt0){cout<<"A "<<i<<'\n';f=1;continue;}
					vis[to[exl]]=1;//否则排除midl~exl之间的点 
					if(d[to[exl]]==0){cout<<"A "<<i<<'\n';f=1;continue;}
					back[midl]=exl;to[exl]=midl;//之后便不会访问midl~exl之间的点  
					midl=to[midl];//把midl向基准点推一格（因为需要保证询问的必须是连续，长度为 2 的弦） 
					continue;
				}
				midl=back[midl]；//从基准点向左扩展
				exl=back[exl];
				continue;
			}
			else if((x==exr&&y==midr)||(y==exr&&x==midr)){//从midr向右边的点连边 
				if(p[x].count(y)){cout<<"B "<<i<<'\n';f=1;continue;}//重边！
				p[x][y]=p[y][x]=1;
				if(!z){cnt0++;d[x]++;d[y]++;}//入度加一，cnt0加一 
				else{
					cnt1++;
					if(cnt1>cnt0){cout<<"A "<<i<<'\n';f=1;continue;}
					vis[back[exr]]=1;//否则排除掉midr~exr之间的点 
					if(d[back[exr]]==0){cout<<"A "<<i<<'\n';f=1;continue;}
					to[midr]=exr;back[exr]=midr;//之后便不会访问midl~exl之间的点 
					midr=back[midr];//把midr向基准点推一格（因为需要保证询问的必须是连续，长度为 2 的弦） 
					continue;
				}
				midr=to[midr];//从基准点向右扩展
				exr=to[exr];
				continue;
			}
			else{cout<<"B "<<i<<'\n';f=1;continue;}//上述条件均不满足，只能说明B的询问是错的 
		}
		else{//已经可以随便问了，但是必须保证不能重边 
			if(p[x].count(y)){cout<<"B "<<i<<'\n';f=1;continue;}//重边！
			p[x][y]=p[y][x]=1;
			if(d[x]==-1||d[y]==-1){cout<<"B "<<i<<'\n';f=1;continue;}
			if(d[x]){
				if(d[y]){cout<<"B "<<i<<'\n';f=1;continue;}
				else d[x]=-1;
			}
			if(d[y]){
				if(d[x]){cout<<"B "<<i<<'\n';f=1;continue;}
				else d[y]=-1;
			}
			continue;
		}
	}
	if(f)continue;
	cout<<"0\n";
}
return 0;
}
```


---


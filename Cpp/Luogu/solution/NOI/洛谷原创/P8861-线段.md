# 线段

## 题目描述

有一个初始为空的线段集，你需要处理 $q$ 组询问，每组询问的格式为如下三种之一：

1. 加入一条新线段 $[l_i,r_i]$。
2. 将线段集里所有与 $[l_i,r_i]$ 相交的线段修改为其与 $[l_i,r_i]$ 的交。
3. 求出线段集里所有与 $[l_i,r_i]$ 相交的线段与 $[l_i,r_i]$ 的交的长度和。

两条线段 $[a,b],[c,d]$ 相交，当且仅当 $\max\{a,c\} \leq \min\{b,d\}$，它们的交为 $[\max\{a,c\},\min\{b,d\}]$。

一条线段 $[a,b]$ 的长度为 $b-a$。

在部分测试点中，你需要**在线地**进行这些操作。

**注意：在本题中，线段可能退化为单点。**

## 说明/提示

#### 【样例解释】

每次操作后的线段集：

- 第一次后：$\{ [1,5] \}$
- 第二次后：$\{ [1,5],[6,8] \}$
- 第三次后：$\{ [1,5],[6,8],[2,3] \}$
- 第五次后：$\{ [4,5],[6,6],[2,3] \}$
- 第六次后：$\{ [4,5],[6,6],[2,3],[5,9] \}$
- 第七次后：$\{ [4,5],[6,6],[2,3],[5,7] \}$

#### 【数据范围】

记 $k_1,k_2,k_3$ 分别为 $opt=1,2,3$ 的询问个数。

|    测试点编号    |    $k_1 \leq$    |    $k_2 \leq$    |    $k_3 \leq$    | $type=$ |             特殊性质             |
|:----------------:|:---------------:|:---------------:|:---------------:|:-------:|:--------------------------------:|
|      $1 \sim 2$  |      $100$      |      $100$      |      $100$      |   $=0$  |                无                |
|      $3 \sim 5$  |      $10^5$     |       $5$       | $3 \times 10^5$ |   $=0$  |                无                |
|      $6 \sim 8$  |      $10^5$     |      $10^5$     |        $1$        |   $=0$  | 所有 $2$ 操作在所有 $1$ 操作之后 |
|      $9 \sim 12$ |      $10^5$     |      $10^5$     | $3 \times 10^5$ |   $=0$  | 所有 $2$ 操作在所有 $1$ 操作之后 |
|     $13 \sim 17$ |      $10^5$     |      $10^5$     | $3 \times 10^5$ |   $=0$  |     $l_i \leq 10^5 \leq r_i$     |
|     $18 \sim 20$ | $5 \times 10^4$ | $5 \times 10^4$ | $3 \times 10^5$ |   $=0$  |                无                |
|     $21 \sim 25$ |      $10^5$     |      $10^5$     | $3 \times 10^5$ |   $=1$  |                无                |

对于所有数据，$1 \leq q \leq 5 \times 10^5$, $k_3 \geq 1$, $0 \leq l_i',r_i' \leq 2 \times 10^5$, $1 \leq l_i \leq r_i \leq 2 \times 10^5$，$0 \leq type \leq1$，$1 \leq opt \leq 3$。

## 样例 #1

### 输入

```
9 0
1 1 5
1 6 8
1 2 3
3 3 8
2 4 6
1 5 9
2 2 7
3 2 7
3 3 6
```

### 输出

```
4
4
2
```

# 题解

## 作者：_rqy (赞：23)

应某同学邀请, 做了一下月赛题. 感觉这题挺有意思, 来写一篇题解.

闲言少叙, 书归正传.

# 思路

看到这题, 我首先想到分块. 如果把整个值域分成大约 $\sqrt{n}$ 块.
考虑一次修改之后, 有一些区间会大幅度减小, 他们跨过的块的个数会变少.
对于这样的区间, 我们试图快速找到他们, 找到之后暴力修改.
因为每个区间最多被这样修改不超过 $\sqrt{n}$ 次, 所以这个复杂度是对的
(如果我们可以快速找到这样的区间).

接下来考虑哪些区间发生了变化, 但是跨过的块的个数不会变少.
可以发现, 设修改的左右端点是 $L, R$, 那么只有左端点和 $L$ 同块的区间,
或者右端点和 $R$ 同块的区间, 才有可能出现这种情况.

我们先考虑一种简单情况, 那就是 $L, R$ 不处于同一个块,
并且我们只考虑整个区间都在 $L$ 所在块内的区间.
设这个区间是 $[l, r]$, 那么如果 $L \in [l, r]$, 则 $[l, r]$ 会变成 $[L, r]$.
否则 $[l, r]$ 会保持不变.

这似乎并没有什么好办法去维护.
那么暴力修改可不可行呢?
好消息是暴力是可行的!

我们把修改区间看成删除后重新插入.
那么在这一次修改中, 我们只插入了 $O(\sqrt{n})$ 种区间.
如果我们可以把相同的区间合并并计算一个重数, 那么一共只会插入 $O(n\sqrt{n})$ 种区间. (以下假设修改次数与 $n$ 同阶.)

因此如果我们可以快速找到要修改的区间, 那么这一部分修改的总复杂度也在 $O(n\sqrt{n})$.

那么如果考虑任意的左端点在这个块中的区间 $[l, r]$, 我们可以把它暂且当成 $[l, T]$ 来处理, 其中 $T$ 表示这个块的右端点.

这样, 我们还有三个问题:

1. 块间修改的时候, 我们怎么找到修改后跨过的块会减少的区间呢?
   可以对每一块维护左端点在这一块内, 右端点不在这一块内的所有区间,
   按右端点从大到小维护.
   这样我们修改的时候, 只需要找 $L$ 所在块的左边所有块延伸出的区间中,
   右端点比 $L$ 更大的即可.
   对右端点, 也可以同样处理.
2. 块内修改的时候, 我们怎么找到需要修改的区间呢?
   可以对每个 $l$, 把左端点为 $l$ 的块内区间按右端点从小到大挂成链表.
   只需要枚举 $l$, 然后在链表里按右端点从大到小遍历所有受到影响的区间即可.
3. 如何维护询问的答案? 这个询问还是比较好处理的.
   它相当于说对每个区间, 把整个区间 $+1$. 然后查询区间和.
   由于我们所有修改都是暴力修改, 只需要每次暴力修改的时候区间加, 询问的时候区间和即可. 由于这个区间加次数过多, 可以用根号平衡技巧把复杂度优化到 $O(n\sqrt{n})$, 不带 $\log$.
   
**等一下!** 如果你试图实现这个算法, 就会发现一个问题.
由于我们在块内修改的时候, 跨过块的区间也会被合并起来一起修改,
在某个端点被修改过后, 我们发现这个区间跨过的块会减少的时候, 就不知道它当前的端点在哪里了!

而且如果一个区间的右端点受块内影响减小了, 那么我们再寻找"右端点比 $L$ 更大的区间"来确定哪些区间会被缩小的时候, 就难以处理了.

好在这也不难解决. 我们可以给修改时新增的区间建立一个结点, 然后让删掉的区间对应的结点指向它, 然后使用并查集就可以了. 上面的两个问题都可以迎刃而解 (第二个问题可以和块内修改一起处理: 只需要把左端点在 $T$, 右端点比 $L$ 更大的那些区间对应的并查集拆出来就得到了).

另一种办法是对每个块, 把处于块内的所有修改的左(右)端点按时间建立单调栈, 然后二分即可 (因为如果某个区间过了很长时间之后, 发现他跨过的块减少了, 那么这个时候考虑它现在的左端点, 一定是上一次跨过的块减少的时候到现在为止, 它的左端点所在的块里所有修改的左端点的最大值. 单调栈可以维护时间后缀的最大值).

而如果使用单调栈, 对于第二个问题, 相当于找到"上一次修改的右端点落在 $L$ 所在块内并且比 $L$ 更靠左"这件事情发生之后所有右端点被放到 $L$ 块内在 $L$ 后面的区间. 这件事情的发生时间仍然可以二分出来, 然后我们需要一个动态的三维数点 (动态三维数点!), 可以搞个主席树...这个做法我并没有想到足够好的优化方法, 所以没有写出代码. 如果有人可以提供优化方法可以[联系我](https://rqy.moe/contact.html).

**那么, 这个思路能不能优化到 $O(n \times \mathrm{poly}(\log n))$ 呢?**
答案是可以的. 我们发现上面的分块完全可以嵌套: 我们把跨过块的单独处理, 块内的递归处理, 那么这完全可以改到线段树上! 最后的复杂度即为 $O(n \log^2 n)$, 因为每次变更区间时需要 $O(\log n)$ 的树状数组修改, 还需要用堆维护区间.

呜呜.

# 代码

```cpp
#include <algorithm>
#include <queue>
#include <vector>
#include <functional>
#include <utility>
#include <cctype>
#include <cstdio>
#include <cstring>

typedef long long LL;
const int N = 200050;
const int M = 100050;

int read() {
  int ans = 0, c;
  while (!isdigit(c = getchar()));
  do ans = ans * 10 + c - '0';
  while (isdigit(c = getchar()));
  return ans;
}

namespace UFS {
  const int MM = M * 200;
  int Fa[MM], cnt = 0; // 正: 父亲; 负: 子树大小
  int Ls[MM], Rb[MM], id[MM];
  int sz[MM];
  int pos[MM];

  int Find(int x) { return Fa[x] < 0 ? x : Fa[x] = Find(Fa[x]); }
  int Union(int x, int y) {
    x = Find(x); y = Find(y);
    if (Fa[x] < Fa[y]) // y 子树更大
      std::swap(x, y);
    sz[x] += sz[y];
    Fa[x] += Fa[y]; Fa[y] = x;
    Rb[y] = Ls[x]; Ls[x] = y;
    return x;
  }

  int corNode[M * 2];

  inline int addNode(int i, int p) {
    int o = cnt++;
    if (cnt % 10000 == 0) fprintf(stderr, "qwq %d\n", cnt);
    if (i >= 0) {
      id[o] = i;
      corNode[i] = o;
      sz[o] = 1;
    } else {
      id[o] = -1;
      sz[o] = 0;
    }
    pos[o] = p;
    Fa[o] = -1;
    Ls[o] = Rb[o] = -1;
    return o;
  }

  inline void rmNode(int i) {
    int x = corNode[i];
    --sz[Find(x)];
    id[x] = -1;
  }
}

typedef std::pair<int, int> E;
#define mp std::make_pair

const int NN = N * 3; // TODO

std::priority_queue<E, std::vector<E>, std::greater<E>> LE[NN];
std::priority_queue<E> RE[NN];

inline void addA(int l, int r, LL v);

// 线段树是"左闭右开"区间
void addE(int o, int l, int r, int k, int L, int R) {
  int m = (l + r) / 2;
  if (R < m) addE(o << 1, l, m, k, L, R);
  else if (L > m) addE(o << 1 | 1, m, r, k, L, R);
  else {
    LE[o].push(mp(L, UFS::addNode(k << 1, L)));
    RE[o].push(mp(R, UFS::addNode(k << 1 | 1, R)));
  }
}

void reAddE(int x, int l1, int o, int l, int r, int Lq, int Rq) {
  using namespace UFS;
  int t = id[x];
  if (t >= 0) {
    int k = t >> 1, y = corNode[t ^ 1];
    int Lp = l1, Rp = pos[Find(y)];
    if (t & 1) std::swap(Lp, Rp);
    rmNode(t); rmNode(t ^ 1);

    int Ls = std::max(Lp, Lq), Rs = std::min(Rp, Rq);
    if (Ls == Rs) {
      addA(Lp, Rp, -1);
#ifdef DEBUG
      fprintf(stderr, "Remove the range [%d, %d]\n", Lp, Rp);
#endif
    } else {
#ifdef DEBUG
      fprintf(stderr, "Change the range [%d, %d] to [%d, %d]\n", Lp, Rp, Ls, Rs);
#endif
      if (Ls > Lp) addA(Lp, Ls, -1);
      if (Rs < Rp) addA(Rs, Rp, -1);
      addE(o, l, r, k, Ls, Rs);
    }
  }
  for (int y = Ls[x]; y >= 0; y = Rb[y])
    reAddE(y, l1, o, l, r, Lq, Rq);
}

void modify(int o, int l, int r, int Lq, int Rq) {
  if (r - l == 1 || r < Lq || l > Rq || (l >= Lq && r <= Rq)) return;
#ifdef DEBUG
      fprintf(stderr, "> %d %d %d\n", o, l, r);
#endif
  int m = (l + r) / 2;
  if (Rq < m) {
    while (!LE[o].empty()) {
      E x = LE[o].top();
      if (x.first > Rq) break;
      LE[o].pop();
      reAddE(x.second, x.first, o << 1, l, m, Lq, Rq);
    }
    modify(o << 1, l, m, Lq, Rq);
  } else if (Lq > m) {
    while (!RE[o].empty()) {
      E x = RE[o].top();
      if (x.first < Lq) break;
      RE[o].pop();
      reAddE(x.second, x.first, o << 1 | 1, m, r, Lq, Rq);
    }
    modify(o << 1 | 1, m, r, Lq, Rq);
  } else {
    using namespace UFS;
    int nd = addNode(-1, Lq);
    while (!LE[o].empty()) {
      E x = LE[o].top();
      if (x.first > Lq) break;
      LE[o].pop();
#ifdef DEBUG
      fprintf(stderr, "Modify the left endpoint of %d ranges from %d to %d\n",
              UFS::sz[x.second], x.first, Lq);
#endif
      addA(x.first, Lq, -UFS::sz[x.second]);
      nd = Union(nd, x.second);
    }
    pos[nd] = Lq;
    LE[o].push(mp(Lq, nd));
    nd = addNode(-1, Rq);
    while (!RE[o].empty()) {
      E x = RE[o].top();
      if (x.first < Rq) break;
      RE[o].pop();
#ifdef DEBUG
      fprintf(stderr, "Modify the right endpoint of %d ranges from %d to %d\n",
              UFS::sz[x.second], x.first, Rq);
#endif
      addA(Rq, x.first, -UFS::sz[x.second]);
      nd = Union(nd, x.second);
    }
    pos[nd] = Rq;
    RE[o].push(mp(Rq, nd));
    modify(o << 1, l, m, Lq, Rq);
    modify(o << 1 | 1, m, r, Lq, Rq);
  }
}

LL A[N], B[N];

void adda(LL *A, int x, LL v) {
  for (; x < N; x += x & -x)
    A[x] += v;
}

inline void addA(int l, int r, LL v) {
  // 区间加 v
  adda(B, r, -v); adda(B, l, v);
  adda(A, r, v * r); adda(A, l, -v * l);
}

LL querya(LL *A, int x) {
  LL ans = 0;
  for (; x; x -= x & -x)
    ans += A[x];
  return ans;
}

inline LL queryA(int l, int r) {
  return r * querya(B, r) + querya(A, r) - l * querya(B, l) - querya(A, l);
}

int main() {
  int q = read(), type = read();
  LL last = 0;
  int t = 0;
  while (q--) {
    int k = read(), l = read(), r = read();
    l = (l + type * last) % 200001;
    r = (r + type * last) % 200001;
    if (k == 1) {
      if (l < r) {
        addA(l, r, 1);
        addE(1, 1, 200000, t++, l, r);
      }
    } else if (k == 2) {
      modify(1, 1, 200000, l, r);
    } else {
      printf("%lld\n", last = queryA(l, r));
    }
  }
}
```

---

## 作者：mydcwfy (赞：17)

题意：给定一些区间的集合，最开始为空。给出 $q$ 次操作，会给出 $op, l, r$：

1. $op = 1$：向集合插入一个新的元素 $[l, r]$。
2. $op = 2$：对于集合的每一个元素，如果其与 $[l, r]$ 有交，就改为其与 $[l, r]$ 的交。
3. $op = 3$：查询集合中每一个元素与 $[l, r]$ 交的长度的和。


$[l, r]$ 的长度定义为 $r - l$。部分测试点强制在线。假设 $op = 1, 2, 3$ 的操作次数分别为 $k_1, k_2, k_3$，则有 $k_1, k_2\leq 10 ^ 5, k_3\leq 3\times 10 ^ 5$，$1\leq l\leq r\leq 2\times 10 ^ 5$。

记权值范围为 $m = 2\times 10 ^ 5$。

### Tests 13 - 17

首先注意到中间的一些测试点（$13\sim 17$）是 $1\leq l\leq 10 ^ 5\leq r\leq 2\times 10 ^ 5$，这个启示我们在 $10 ^ 5$ 处给出一个分界线，然后左右分别 `chkmin/chkmax`，维护信息。

具体来说，我们维护两个数据结构，插入平凡，修改相当于是对于全局左端点 `chkmax`，右端点 `chkmin`。

直接使用 jls 线段树即可（当然全局 `chkmin/chkmax` 有其他做法）。现在问题是我们怎么维护区间交的长度和。

首先考虑我们直接使用 $\min(r_1, r_2) - \max(l_1, l_2)$ 计算所有答案，这个是好计算的，我们使用权值线段树 / 树状数组维护值域区间内个数以及值域区间内和就可以 $O(\log n)$ 查询。

然后考虑如果 $l_1 > r_2$，本身应该是 0，但是我们会得到 $r_2 - l_1$，所以我们加回来的话需要计算 $> r_2$ 的所有 $l$ 的个数和和。另一边同理。

据上我们可以得到一个 $O(\log m)$ 修改查询的做法。注意到这个做法只和 $l$ 集合，$r$ 集合相关，和他们如何配对的无关。这个对我们下面的推导是有一定作用的。

### AC 做法

上面的启示性很强，我们马上可以得到一个做法：使用类似猫树的二区间分治结构，对每个区间都使用这个做法。但是和上面不同的是我们还需要考虑另外一些情况。

假设插入的是 $[l', r']$，我们在一个满足 $l\leq l'\leq mid < r'\leq r$ 的分治区间 $[l, r]$ 插入这个区间。容易发现这个分治区间是确定并且唯一的。插入由于需要动态维护权值树状数组，是 $O(\log m)$ 的。

考虑如何修改。直接在分治区间上修改，如果 $r' > mid$，我们需要向右区间递归，当前分治区间所有满足 $r\geq l'$ 的都会被修改成 $[l', \min(r, r')]$。得到这个区间我们直接向右区间插入这个区间，注意到这个暴力的均摊复杂度是正确的（每个区间最多向下 $O(\log m)$ 次），所以我们直接在线段树上找出所有右端点 $\geq l'$ 的区间，一个一个修改即可。

如果当前分治区间满足 $l \leq l'\leq mid < r'\leq r$，那么可以发现和上面的情况类似，我们直接 jls 线段树即可。注意到此时我们不能直接返回，因为他对 $[l, mid]$ 和 $[mid + 1, r]$ 等分治区间还有贡献。由于完全覆盖是不存在贡献的，所以类似线段树的复杂度分析，最多只会访问 $O(\log m)$ 个节点。单次修改均摊是 $O(\log m)$ 的，因为我们需要更新树状数组。

分析以上复杂度：我们一共有 $O(k_1\log m)$ 次修改，单次修改是 $O(\log m)$ 的，jls 线段树上共有 $O(k_2 \log m)$ 次操作，均摊单次是 $O(\log n + \log m)$ 的。单次查询是 $O(\log m)$ 的。

于是总复杂度是 $O(k_1 \log ^ 2 m + k_2 \log m(\log n + \log m) + k_3\log m)$ 的，可以通过。

注意几个细节：

1. 其实没人写 jls 线段树的罢，因为这个是好用 dsu / 堆 维护的，只是我 vp 的时候只想到了这里 /kk。但是由于线段树的强大，这个题有没有可能扩展到编号过后区间修改呢？
2. 线段树大小是不固定的，这里我是用的类似 `std::vector` 的扩容办法，满了就增加一倍的空间。
3. 注意插入时 $l' = r'$ 需要特判一下，不然可能 RE/WA。

```cpp
struct SegTree1 {
    struct Node {
        int l, r;
        int mn, sec, cnt, lt;
    };
    std::vector<Node> tr;
    int mid, L;

    void pushup(int x) {
        auto &nl = tr[x << 1], &nr = tr[x << 1 | 1], &rt = tr[x];
        if (nl.mn < nr.mn)
            rt.mn = nl.mn, rt.cnt = nl.cnt, rt.sec = std::min(nl.sec, nr.mn);
        else if (nl.mn > nr.mn)
            rt.mn = nr.mn, rt.cnt = nr.cnt, rt.sec = std::min(nr.sec, nl.mn);
        else
            rt.mn = nl.mn, rt.cnt = nl.cnt + nr.cnt, rt.sec = std::min(nl.sec, nr.sec);
    }

    void build(int x, int l, int r, int *a)
    {
        tr[x] = {l, r};
        if (l == r) {
            tr[x].mn = a[l], tr[x].sec = INF, tr[x].cnt = 1;
            return;
        }
        int mid = (l + r) >> 1;
        build(x << 1, l, mid, a), build(x << 1 | 1, mid + 1, r, a);
        pushup(x);
    }

    void update(int x, int c) { tr[x].mn += c, tr[x].lt += c; }

    void pushdown(int x) {
        if (!tr[x].lt) return;
        int mnl = tr[x << 1].mn, mnr = tr[x << 1 | 1].mn;
        if (mnl <= mnr) update(x << 1, tr[x].lt);
        if (mnl >= mnr) update(x << 1 | 1, tr[x].lt);
        tr[x].lt = 0;
    }

    void change(int x, int pos, int c)
    {
        if (tr[x].l == tr[x].r) {
            if (c <= mid) T1[0].add(c, 1), T1[1].add(c, c);
            return tr[x].mn = c, void();
        }
        pushdown(x);
        change(x << 1 | (pos * 2 > tr[x].l + tr[x].r), pos, c);
        pushup(x);
    }

    void modify(int x, int l, int r, int c) {
        if (tr[x].l > r || tr[x].r < l || tr[x].mn >= c) return;
        if (tr[x].l >= l && tr[x].r <= r && tr[x].sec > c) {
            T1[0].add(tr[x].mn, -tr[x].cnt), T1[1].add(tr[x].mn, (LL) -tr[x].cnt * tr[x].mn);
            T1[0].add(c, tr[x].cnt), T1[1].add(c, (LL) tr[x].cnt * c);
            return update(x, c - tr[x].mn);
        }
        pushdown(x);
        modify(x << 1, l, r, c), modify(x << 1 | 1, l, r, c);
        pushup(x);
    }

    void dfs(int x, std::vector<int> &vec, int lim)
    {
        if (tr[x].mn > lim) return;
        if (tr[x].l == tr[x].r) return vec.push_back(tr[x].l);
        pushdown(x);
        dfs(x << 1, vec, lim), dfs(x << 1 | 1, vec, lim);
    }

    int ask(int x, int pos) {
        if (tr[x].l == tr[x].r) return tr[x].mn;
        pushdown(x);
        return ask(x << 1 | (pos * 2 > tr[x].l + tr[x].r), pos);
    }

    void rebuild(std::vector<int> a, int _l, int _m)
    {
        mid = _m, L = _l;
        tr.resize(a.size() * 4);
        build(1, 0, a.size() - 1, a.data());
    }
    SegTree1() : tr(2, {0, 0, INF}), mid(0), L(0) {}
};

struct SegTree2 {
    struct Node {
        int l, r;
        int mx, sec, cnt, lt;
    };
    std::vector<Node> tr;
    int mid, R;

    void pushup(int x) {
        auto &nl = tr[x << 1], &nr = tr[x << 1 | 1], &rt = tr[x];
        if (nl.mx > nr.mx)
            rt.mx = nl.mx, rt.cnt = nl.cnt, rt.sec = std::max(nl.sec, nr.mx);
        else if (nl.mx < nr.mx)
            rt.mx = nr.mx, rt.cnt = nr.cnt, rt.sec = std::max(nr.sec, nl.mx);
        else
            rt.mx = nl.mx, rt.cnt = nl.cnt + nr.cnt, rt.sec = std::max(nl.sec, nr.sec);
    }

    void build(int x, int l, int r, int *a)
    {
        tr[x] = {l, r};
        if (l == r) {
            tr[x].mx = a[l], tr[x].sec = -INF, tr[x].cnt = 1;
            return;
        }
        int mid = (l + r) >> 1;
        build(x << 1, l, mid, a), build(x << 1 | 1, mid + 1, r, a);
        pushup(x);
    }

    void update(int x, int c) { tr[x].mx += c, tr[x].lt += c; }

    void pushdown(int x) {
        if (!tr[x].lt) return;
        int mxl = tr[x << 1].mx, mxr = tr[x << 1 | 1].mx;
        if (mxl >= mxr) update(x << 1, tr[x].lt);
        if (mxl <= mxr) update(x << 1 | 1, tr[x].lt);
        tr[x].lt = 0;
    }

    void change(int x, int pos, int c)
    {
        if (tr[x].l == tr[x].r) {
            if (c > mid) T2[0].add(c, 1), T2[1].add(c, c);
            return tr[x].mx = c, void();
        }
        pushdown(x);
        change(x << 1 | (pos * 2 > tr[x].l + tr[x].r), pos, c);
        pushup(x);
    }

    void modify(int x, int l, int r, int c) {
        if (tr[x].l > r || tr[x].r < l || tr[x].mx <= c) return;
        if (tr[x].l >= l && tr[x].r <= r && tr[x].sec < c) {
            T2[0].add(tr[x].mx, -tr[x].cnt), T2[1].add(tr[x].mx, (LL) -tr[x].cnt * tr[x].mx);
            T2[0].add(c, tr[x].cnt), T2[1].add(c, (LL) tr[x].cnt * c);
            return update(x, c - tr[x].mx);
        }
        pushdown(x);
        modify(x << 1, l, r, c), modify(x << 1 | 1, l, r, c);
        pushup(x);
    }

    void dfs(int x, std::vector<int> &vec, int lim)
    {
        if (tr[x].mx < lim) return;
        if (tr[x].l == tr[x].r) return vec.push_back(tr[x].l);
        pushdown(x);
        dfs(x << 1, vec, lim), dfs(x << 1 | 1, vec, lim);
    }

    int ask(int x, int pos) {
        if (tr[x].l == tr[x].r) return tr[x].mx;
        pushdown(x);
        return ask(x << 1 | (pos * 2 > tr[x].l + tr[x].r), pos);
    }

    void rebuild(std::vector<int> a, int _m, int _r)
    {
        mid = _m, R = _r;
        tr.resize(a.size() * 4);
        build(1, 0, a.size() - 1, a.data());
    }
    SegTree2() : tr(2, {0, 0, -INF}), mid(0), R(0) {}
};

struct Node {
    int l, r, sz;
    SegTree1 T1;
    SegTree2 T2;
} tr[N << 2];

void build(int x, int l, int r)
{
    tr[x] = {l, r, 0, SegTree1(), SegTree2()};
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);
}

void insert(int x, int l, int r)
{
    if (tr[x].l == tr[x].r) {
        T1[0].add(l, 1), T1[1].add(l, l), T2[0].add(l, 1), T2[1].add(l, l);
        return;
    }
    // if (l == r) std::cout << "Insert " << l << ' ' << r << '\n', exit(0);
    int mid = (tr[x].l + tr[x].r) >> 1;
    // std::cout << "Insert " << x << ' ' << l << ' ' << r << ' ' << tr[x].l << ' ' << tr[x].r << std::endl;
    if (r <= mid) return insert(x << 1, l, r);
    if (l > mid) return insert(x << 1 | 1, l, r);
    if (tr[x].sz & (tr[x].sz - 1)) {
        tr[x].T1.change(1, tr[x].sz, l), tr[x].T2.change(1, tr[x].sz, r);
        tr[x].sz ++;
        return;
    }
    std::vector<int> vl(tr[x].sz), vr(tr[x].sz);
    for (int i = 0; i < tr[x].sz; ++ i)
        vl[i] = tr[x].T1.ask(1, i), vr[i] = tr[x].T2.ask(1, i);
    vl.push_back(l), vr.push_back(r);
    int bit = 0;
    while ((1 << bit) <= tr[x].sz) bit ++;
    vl.resize(1 << bit, INF), vr.resize(1 << bit, -INF);
    tr[x].T1.rebuild(vl, tr[x].l, mid), tr[x].T2.rebuild(vr, mid, tr[x].r);
    tr[x].sz ++, T1[0].add(l, 1), T1[1].add(l, l), T2[0].add(r, 1), T2[1].add(r, r);
}

void modify(int x, int l, int r)
{
    if (tr[x].l >= l && tr[x].r <= r) return;
    // std::cout << "Modify " << x << ' ' << l << ' ' << r << ' ' << tr[x].l << ' ' << tr[x].r << std::endl;
    int mid = (tr[x].l + tr[x].r) >> 1;
    if (r <= mid) {
        std::vector<int> vec;
        tr[x].T1.dfs(1, vec, r);
        for (int id : vec) {
            int cl = tr[x].T1.ask(1, id), cr = tr[x].T2.ask(1, id);
            tr[x].T1.change(1, id, INF), tr[x].T2.change(1, id, -INF);
            insert(x << 1, std::max(l, cl), r);
            T1[0].add(cl, -1), T1[1].add(cl, -cl), T2[0].add(cr, -1), T2[1].add(cr, -cr);
        }
        return modify(x << 1, l, r);
    }
    if (l > mid) {
        std::vector<int> vec;
        tr[x].T2.dfs(1, vec, l);
        for (int id : vec) {
            // std::cout << "Check " << id << std::endl;
            int cl = tr[x].T1.ask(1, id), cr = tr[x].T2.ask(1, id);
            // std::cout << cl << ' ' << cr << std::endl;
            tr[x].T1.change(1, id, INF), tr[x].T2.change(1, id, -INF);
            insert(x << 1 | 1, l, std::min(r, cr));
            T1[0].add(cl, -1), T1[1].add(cl, -cl), T2[0].add(cr, -1), T2[1].add(cr, -cr);
        }
        return modify(x << 1 | 1, l, r);
    }
    tr[x].T1.modify(1, 0, tr[x].sz - 1, l), tr[x].T2.modify(1, 0, tr[x].sz - 1, r);
    modify(x << 1, l, r), modify(x << 1 | 1, l, r);
}

LL query(int l, int r)
{
    LL res = T1[0].ask(l) * l + T1[1].ask(M) - T1[1].ask(l);
    res = res * -1 + (T2[0].ask(M) - T2[0].ask(r)) * r + T2[1].ask(r);
    res += l * T2[0].ask(l) - T2[1].ask(l);
    res += T1[1].ask(M) - T1[1].ask(r) - r * (T1[0].ask(M) - T1[0].ask(r));
    return res;
}

int main()
{
    int m, op, l, r, typ;
    LL ls = 0;
    read(m, typ);
    build(1, 0, M);
    while (m --)
    {
        read(op, l, r);
        l = (l + ls * typ) % (M + 1), r = (r + ls * typ) % (M + 1);
        if (op == 1) insert(1, l, r);
        else if (op == 2) modify(1, l, r);
        else printf("%lld\n", ls = query(l, r));
        // printf("%lld\n", query(1, M));
    }
    return 0;
}
```

---

## 作者：tzc_wk (赞：10)

牛逼题。

先考虑 $l\le 10^5,10^5+1\le r$ 的部分分：一种方法是线段树，即因为左右端点是独立的，因此对左右端点各维护一个权值线段树表示有多少个区间以这个值为左 / 右端点，这样对于修改，左端点的部分相当于先查询 $\le l$ 的数的个数，然后将它们都挂到 $l$ 上，最后把 $<l$ 的部分清空了，右端点也同理。对于查询就线段树上每个节点维护 $\sum cnt_i$ 和 $\sum cnt_i·i$ 即可。

但是这种做法不容易推广到正解的部分，因此再说一个与正解有点关系的使用堆维护这部分的做法。因为你相当于将所有区间左端点对 $L$ 取 $\max$，以及将所有区间右端点对 $R$ 取 $\min$。考虑对左右端点各维护一个堆，同时维护两个并查集，将左右端点相同的线段缩到并查集同一等价类内，然后堆内存储若干个 pair 表示所有出现过的左 / 右端点和其在并查集中的根节点，这样就可以在均摊 $O(1)$ 的时间内处理修改。查询是类似的，维护 $\sum cnt_i$ 和 $\sum cnt_i·i$，这里可以树状数组。

接下来考虑正解的部分。建一棵权值线段树，线段树每个节点 $[L,R]$ 上使用上述所说的基于堆和并查集的数据结构维护当前区间集中所有跨 $mid$ 的区间，然后一次操作的影响：

- 插入操作：找到满足 $L\le l\le mid<r\le R$ 的区间 $[L,R]$，然后往这个节点的数据结构里插入区间 $[l,r]$。
- 修改操作：类比在线段树上进行区间查询，考虑当前线段树上区间 $[L,R]$ 与查询区间 $[l,r]$ 的关系：
  - 无交，返回。
  - $[L,R]\in[l,r]$，返回。
  - $l\le mid<r$，将这个节点上所有区间左端点对 $l$ 取 $\max$，右端点对 $r$ 取 $\min$，使用上面的方法处理即可。
  - $r\le mid$ 或者 $l>mid$，二者是等价的，这里考虑前者。操作这个区间对这个节点上的区间的影响是，如果这个区间上的节点与 $[l,r]$ 有交，那么操作完以后它就完全属于左半边了，它就不能待在这个节点上，得往左儿子走。而容易证明当前节点上的区间 $[l',r']$ 与 $[l,r]$ 有交当且仅当 $l'\le r$，因此这里我们采取一种简单粗暴的方法：**不断 pop 掉左端点对应的堆里的最小元素知道它 $>r$，对于被 pop 掉的元素，考察其对应并查集中所有区间，将其插入左子树内。**类比李超线段树，每个区间最多移动 $\log$ 次，所以这里复杂度是对的。
- 查询操作：情况类似。由于这个修改操作是全局的，因此树状数组只用开一个（即，不用对每个节点都开一个）。

时间复杂度 $(n+q)\log^2n$。代码实现比较复杂。

```cpp
const int MAXN=2e5;
const int MAXP=MAXN<<6;
int qu,typ;ll lstans;
struct fenwick{
	ll t[MAXN+5];
	void add(int x,ll v){for(int i=x;i<=MAXN;i+=(i&(-i)))t[i]+=v;}
	ll query(int x){ll ret=0;for(int i=x;i;i&=(i-1))ret+=t[i];return ret;}
}T1,T2,T3,T4;
void addl(int x,int v){T1.add(x,v),T2.add(x,1ll*v*x);}
void addr(int x,int v){T3.add(x,v),T4.add(x,1ll*v*x);}
ll query(int l,int r){
	ll res=0;
	res+=T4.query(r)+1ll*r*(T3.query(MAXN)-T3.query(r));
	res-=T2.query(MAXN)-T2.query(l)+1ll*l*T1.query(l);
	res-=T4.query(l-1)-1ll*l*T3.query(l-1);
	res-=1ll*r*(T1.query(MAXN)-T1.query(r))-(T2.query(MAXN)-T2.query(r));
	return res;
}
struct node{
	int l,r;priority_queue<pii>qr;
	priority_queue<pii,vector<pii>,greater<pii> >ql;
}s[MAXN*4+5];
bool vis[MAXP+5];
int mch[MAXP+5],f[MAXP+5],val[MAXP+5],ncnt,alive[MAXP+5],siz[MAXP+5];
vector<int>g[MAXP+5];
int find(int x){return (!f[x])?x:f[x]=find(f[x]);}
void build(int k,int l,int r){
	s[k].l=l;s[k].r=r;if(l==r)return;int mid=l+r>>1;
	build(k<<1,l,mid);build(k<<1|1,mid+1,r);
}
void insert(int k,int l,int r){
	int mid=s[k].l+s[k].r>>1;
	if(r<=mid)insert(k<<1,l,r);
	else if(l>mid)insert(k<<1|1,l,r);
	else{
		int P=++ncnt,Q=++ncnt;val[P]=l;val[Q]=r;mch[P]=Q;mch[Q]=P;
		alive[P]=alive[Q]=siz[P]=siz[Q]=1;s[k].ql.push(mp(l,P));s[k].qr.push(mp(r,Q));
	}
}
int merge(int x,int y){
	if(!x||!y)return x+y;x=find(x);y=find(y);if(x==y)return x;
	if(siz[x]<siz[y])swap(x,y);f[y]=x;siz[x]+=siz[y];g[x].pb(y);
	return x;
}
void insl(int k,int l,int r,int p,int L){
	if(alive[p]){
		int q=mch[p],R=val[find(q)];alive[p]=alive[q]=0;
		siz[find(p)]--;siz[find(q)]--;
		int nwl=max(L,l),nwr=min(R,r);
		addl(L,-1);addr(R,-1);
		if(nwl!=nwr)addl(nwl,1),addr(nwr,1),insert(k,nwl,nwr);
	}
	for(int pp:g[p])insl(k,l,r,pp,L);
}
void insr(int k,int l,int r,int p,int R){
	if(alive[p]){
		int q=mch[p],L=val[find(q)];alive[p]=alive[q]=0;
		siz[find(p)]--;siz[find(q)]--;
		int nwl=max(L,l),nwr=min(R,r);
		addl(L,-1);addr(R,-1);
		if(nwl!=nwr)addl(nwl,1),addr(nwr,1),insert(k,nwl,nwr);
	}
	for(int pp:g[p])insr(k,l,r,pp,R);
}
void modify(int k,int l,int r){
	if(l<=s[k].l&&s[k].r<=r)return;
	int mid=s[k].l+s[k].r>>1;
	if(r<=mid){
		while(!s[k].ql.empty()){
			pii p=s[k].ql.top();if(p.fi>r)break;
			insl(k<<1,l,r,p.se,p.fi);s[k].ql.pop();
		}
		modify(k<<1,l,r);
	}else if(l>mid){
		while(!s[k].qr.empty()){
			pii p=s[k].qr.top();if(p.fi<l)break;
			insr(k<<1|1,l,r,p.se,p.fi);s[k].qr.pop();
		}
		modify(k<<1|1,l,r);
	}else{
		int nd=0;
		while(!s[k].ql.empty()){
			pii p=s[k].ql.top();if(p.fi>=l)break;
			addl(p.fi,-siz[p.se]);nd=merge(nd,p.se);
			s[k].ql.pop();
		}
		if(nd)val[nd]=l,addl(l,siz[nd]),s[k].ql.push(mp(l,nd));
		nd=0;
		while(!s[k].qr.empty()){
			pii p=s[k].qr.top();if(p.fi<=r)break;
			addr(p.fi,-siz[p.se]);nd=merge(nd,p.se);
			s[k].qr.pop();
		}
		if(nd)val[nd]=r,addr(r,siz[nd]),s[k].qr.push(mp(r,nd));
		modify(k<<1,l,mid);modify(k<<1|1,mid+1,r);
	}
}
int main(){
//	freopen("yy.in","r",stdin);freopen("yy.out","w",stdout);
	scanf("%d%d",&qu,&typ);build(1,1,MAXN);
	for(int i=1;i<=qu;i++){
		int opt,x,y;scanf("%d%d%d",&opt,&x,&y);
		x=(x+typ*lstans)%(MAXN+1);y=(y+typ*lstans)%(MAXN+1);
		if(x>y)swap(x,y);
		if(opt==1){
			if(x==y)continue;addl(x,1);addr(y,1);
			insert(1,x,y);
		}else if(opt==2)modify(1,x,y);
		else printf("%lld\n",lstans=query(x,y));
	}
	return 0;
}
```


---

## 作者：Vidoliga (赞：4)

设 $M=2\times 10^5$。

哈哈，没有 $2$ 操作会做吧。

$2$ 操作如果可以均摊成为若干次覆盖修改 $l,r$ 做完了吧。

怎么搞，线段拍到猫树节点上，当且仅当线段被节点区间完全包含且跨过节点区间中点。

$2$ 操作 $L,R$，包含猫树节点区间或者和其无交都没用吧。

如果这个 $2$ 操作跨过中点直接对这个节点 $l,r$ 分别取 $\min/\max$，直接用个堆+并查集均摊维护。

否则，有 $R\leq mid$，或 $L>mid$，不失一般性，设 $R\leq mid$，发现所有 $l\geq R$ 的区间都会被修改，且会跑到猫树节点子树内，均摊一个区间进行这种操作至多 $O(\log M)$ 次，直接均摊暴力修改。

复杂度 $O(q\log^2M)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define pii pair<int,int>
#define MP make_pair
#define fi first
#define se second
using namespace std;
const int N=2e5+10,M=N*30,mod=998244353;
const int L=2e5;
struct Bit{
	ll s[N];
	inline int lb(int x){return x&(-x);}
	inline void upd(int x,ll v){for(;x<=L;x+=lb(x)) s[x]+=v;}
	inline ll q(int x){ll t=0;for(;x;x-=lb(x)) t+=s[x];return t;}
	inline ll q(int l,int r){return l>r?0:q(r)-q(l-1);}
}tll,tl,trr,tr;
inline ll qry(int l,int r){return (trr.q(l,r)+(tr.q(r+1,L)-tl.q(r+1,L))*r)-(tll.q(l,r)+(tl.q(1,l-1)-tr.q(1,l-1))*l);}
inline void updl(int x,int v){tl.upd(x,v),tll.upd(x,1ll*x*v);}
inline void updr(int x,int v){tr.upd(x,v),trr.upd(x,1ll*x*v);}
struct Size_Balance_Tree{
	int L[N<<2],R[N<<2];
	priority_queue<pii,vector<pii>,greater<pii> > q1[N<<2];
	priority_queue<pii> q2[N<<2];
	int v[M],d[M],fa[M],sz[M],cnt=1;
	vector<int> e[M];
	inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
	inline int mrg(int x,int y){
		if(!x||!y) return x|y;
		x=find(x),y=find(y);if(x==y) return x;
		if(sz[x]<sz[y]) swap(x,y);
		fa[y]=x,sz[x]+=sz[y],e[x].pb(y);
		return x;
	}
	inline void build(int rt,int l,int r){
		L[rt]=l,R[rt]=r;
		if(l==r) return ;
		int mid=(l+r)>>1;build(rt<<1,l,mid),build(rt<<1|1,mid+1,r);
	}
	inline void add(int rt,int l,int r){
		int x=++cnt,y=++cnt;
		d[x]=d[y]=0,fa[x]=x,fa[y]=y,sz[x]=sz[y]=1;
		v[x]=l,v[y]=r;
		updl(l,1),updr(r,1);
		q1[rt].push(MP(l,x)),q2[rt].push(MP(r,y));
	}
	inline void eral(int rt,int x){
		int y=x^1,a=find(x),b=find(y);
		d[x]=d[y]=1,sz[a]--,sz[b]--;
		updl(v[a],-1),updr(v[b],-1);
	}
	inline void erar(int rt,int x){
		int y=x^1,a=find(x),b=find(y);
		d[x]=d[y]=1,sz[a]--,sz[b]--;
		updr(v[a],-1),updl(v[b],-1);
	}
	inline void dell(int rt,int u){
		if(!d[u]) eral(rt,u);
		for(int x:e[u]) dell(rt,x);
	}
	inline void delr(int rt,int u){
		if(!d[u]) erar(rt,u);
		for(int x:e[u]) delr(rt,x);
	}
	inline void ins(int rt,int l,int r){
		if(l==r) return ;
		int mid=(L[rt]+R[rt])>>1;
		if(l<L[rt]||r>R[rt]) return ;
		if(l<=mid&&mid<r) return add(rt,l,r);
		ins(rt<<1,l,r),ins(rt<<1|1,l,r);
	}
	void upd(int rt,int l,int r){
		if(l>R[rt]||r<L[rt]) return ;
		if(l<=L[rt]&&R[rt]<=r) return ;
		int u,mid=(L[rt]+R[rt])>>1;
		if(l<=mid&&mid<r){
			u=0;
			while(!q1[rt].empty()){
				pii o=q1[rt].top();if(o.fi>l) break;
				q1[rt].pop(); 
				updl(v[o.se],-sz[o.se]);u=mrg(u,o.se);
			}
			if(u) v[u]=l,updl(v[u],sz[u]),q1[rt].push(MP(v[u],u));
			u=0;
			while(!q2[rt].empty()){
				pii o=q2[rt].top();if(o.fi<r) break;
				q2[rt].pop();
				updr(v[o.se],-sz[o.se]);u=mrg(u,o.se);
			}
			if(u) v[u]=r,updr(v[u],sz[u]),q2[rt].push(MP(v[u],u));
		}
		else if(r<=mid){
			u=0;
			while(!q1[rt].empty()){
				pii o=q1[rt].top();if(o.fi>l) break;
				q1[rt].pop(); 
				updl(v[o.se],-sz[o.se]);u=mrg(u,o.se);
			}
			if(u) v[u]=l,updl(v[u],sz[u]),q1[rt].push(MP(v[u],u));
			while(!q1[rt].empty()){
				pii o=q1[rt].top();if(o.fi>r) break;
				q1[rt].pop(); 
				for(int j=1;j<=sz[o.se];j++) ins(rt<<1,v[o.se],r);
				dell(rt,o.se);
			}
		}
		else if(l>mid){
			u=0;
			while(!q2[rt].empty()){
				pii o=q2[rt].top();if(o.fi<r) break;
				q2[rt].pop();
				updr(v[o.se],-sz[o.se]);u=mrg(u,o.se);
			}
			if(u) v[u]=r,updr(v[u],sz[u]),q2[rt].push(MP(v[u],u));
			while(!q2[rt].empty()){
				pii o=q2[rt].top();if(o.fi<l) break;
				q2[rt].pop();
				for(int j=1;j<=sz[o.se];j++) ins(rt<<1|1,l,v[o.se]);
				delr(rt,o.se);
			}
		}
		upd(rt<<1,l,r),upd(rt<<1|1,l,r);
	}
}t;
int q,tp;
signed main(){
	freopen("ex_segment2.in","r",stdin);
	freopen("a.out","w",stdout);
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>q>>tp;
	t.build(1,1,L);
	ll lst=0;
	for(int i=1,op,l,r;i<=q;i++){
		cin>>op>>l>>r;
		l=(l+tp*lst)%(L+1),r=(r+tp*lst)%(L+1);
		if(op==1) t.ins(1,l,r);
		else if(op==2) t.upd(1,l,r);
		else cout<<(lst=qry(l,r))<<'\n';
	}
	return 0;
}
```

---

## 作者：XZhuRen (赞：2)

不是很好调……吗？

设 $m=2\times 10^{5}$，加入线段数与操作数同级为 $n$。

首先答案的统计就是树状数组区间加区间求和，把右端点视作空的就好。

猫树，每个非空线段插入的时候插在遍历过程中第一个可以碰到中点的节点上。

考虑维护。

我们记当前取交线段为 $[lt,rt]$，线段树节点的中点为 $mid$。

对于一个取交操作，有两种操作方式：

1. $lt\le mid\le rt$。

>操作方式为，对插在本节点的线段的两个端点，分别 $\text{chk}$。

2. 不跨过中点。

>操作方式为，手动对每一条相交线段取交重新插入。

分析这两种操作的复杂度：

1. 假设维护端点，每次相同的端点合并起来，这个操作有单调性，所以最多 $\mathcal{O}(m\log_{2}{m})$ 次。

2. 暴力操作，每次操作后线段被“降级”，即进入子结点，不超过 $\mathcal{O}(n\log_{2}{m})$ 次。

考虑怎么维护：

要实现：

从并查集里拆除一个点，访问并查集内所有点，查找根，合并。

这个不是很友善的样子，但是我们发现时间复杂度充裕，直接启发式合并就好，拆点就新建点，把旧的点标记为删除，把根的 $sz_{rt}-1 \to sz_{rt}$。

然后用优先队列维护两个端点值就好。

时间复杂度 $\mathcal{O}(n\log_{2}^{2}n)$，为启发式合并复杂度乘上修改次数，与修改次数乘上树状数组复杂度相同。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll1;
const int N=5e5+5;
const int NN=N<<5;
const int M=200005;
namespace BIT{
	#define lowbit(x) (x&-x)
	ll1 sm1[N],sm2[N];
	void ad(int x,ll1 y){int tx=x;for(;x<=M&&x>0;x+=lowbit(x))sm1[x]+=y,sm2[x]+=tx*y;}
	void Add(int l,int r,ll1 x){ad(l,x),ad(r,-x);}
	ll1 qy(int x){ll1 res=0;int tx=x+1;for(;x>0;x-=lowbit(x))res+=(tx)*sm1[x]-sm2[x];return res;}
	ll1 Qry(int l,int r){return qy(r)-qy(l-1);}
}
int n,Tp;
int totp=0;
int tots=0;
int ID[NN];//对应线段
int L[NN],R[NN];//左右端点的编号
int fa[NN],sz[NN];//所属点，根大小
int val[NN];
vector<int>sons[NN];//从属点
int newnode(){
	int x=++totp;
	fa[x]=x,sz[x]=1;sons[x].push_back(x);
	return x;//虚点
}
int merge(int x,int y){
	x=fa[x],y=fa[y];
	if(x==y)return x;
	if(sz[x]<sz[y])swap(x,y);
	sz[x]+=sz[y];
	for(auto em:sons[y]){
		if(!ID[em])continue;//不是真点
		fa[em]=x,sons[x].push_back(em);
	}
	sons[y].clear();//删除y的从属
	return x;//启发式合并两点
}
int split(int x){//把 x 从当前集合里分离并新建点
	int y=fa[x],tid=ID[x];
	ID[x]=0;sz[y]--;
	ID[x=newnode()]=tid;
	return newnode();
}
struct Node{
	int l,r;
}t[N*4];
struct nd{
	int x,val;
	bool operator >(const nd&o)const{
		return val!=o.val?val<o.val:x<o.x;
	}
	bool operator <(const nd&o)const{
		return val!=o.val?val>o.val:x>o.x;
	}
};
priority_queue<nd,vector<nd>,less<nd> >ql[N*4];//两个队列
priority_queue<nd,vector<nd>,greater<nd> >qr[N*4];//两个队列
#define mid ((l+r)>>1)
#define ls (o<<1)
#define rs (ls|1)
void build(int o,int l,int r){
	//这个不好-1维护，所以考虑非网格区间了。。。
	t[o]=(Node){l,r};
	if(l+1==r)return;
	build(ls,l,mid),build(rs,mid,r);
}
void ins(int o,int lt,int rt,int id){
	if(lt==rt)return;//没有必要加入单点
	int l=t[o].l,r=t[o].r;
	if((lt<=mid&&rt>=mid)){
		L[id]=newnode(),R[id]=newnode();
		ql[o].push((nd){L[id],lt});
		qr[o].push((nd){R[id],rt});
		val[L[id]]=lt,val[R[id]]=rt;
		BIT::Add(lt,rt,1);
		ID[L[id]]=id,ID[R[id]]=id;
		return;
	}
	ins(rt<=mid?ls:rs,lt,rt,id);
}
void mdf(int o,int lt,int rt){
	int l=t[o].l,r=t[o].r;
	if(lt>r||rt<l)return;
	if(l>=lt&&r<=rt)return;
	nd tmp;
	if((lt<=mid&&rt>=mid)){
		int lst=0;
		while(!ql[o].empty()){
			if(ql[o].top().val>=lt)break;
			else{
				tmp=ql[o].top();
				ql[o].pop();
				BIT::Add(tmp.val,mid,-sz[tmp.x]);
				if(lst)lst=merge(lst,tmp.x);
				else lst=fa[tmp.x];
			}
		}
		if(lst){
			val[lst]=lt;
			ql[o].push((nd){lst,lt});//都合并到这里来
			BIT::Add(lt,mid,sz[lst]);
		}
		lst=0;
		while(!qr[o].empty()){
			if(qr[o].top().val<=rt)break;
			else{
				tmp=qr[o].top();
				qr[o].pop();
				BIT::Add(mid,tmp.val,-sz[tmp.x]);
				if(lst)lst=merge(lst,tmp.x);
				else lst=fa[tmp.x];
			}
		}
		if(lst){
			val[lst]=rt;
			qr[o].push((nd){lst,rt});//都合并到这里来
			BIT::Add(mid,rt,sz[lst]);
		}
	}//非平凡修改
	else{
		int id=0;
		if(rt<=mid){
			while(!ql[o].empty()){
				if(ql[o].top().val>rt)break;
				else{
					tmp=ql[o].top();ql[o].pop();
					for(auto em:sons[tmp.x]){
						id=ID[em];if(!id)continue;
						BIT::Add(tmp.val,val[fa[R[id]]],-1);
						R[id]=split(R[id]);//分裂出来
						ins(ls,max(lt,tmp.val),rt,id);
					}
				}
			}
		}
		if(lt>=mid){
			while(!qr[o].empty()){
				if(qr[o].top().val<lt)break;
				else{
					tmp=qr[o].top();qr[o].pop();
					for(auto em:sons[tmp.x]){
						id=ID[em];if(!id)continue;
						BIT::Add(val[fa[L[id]]],tmp.val,-1);
						L[id]=split(L[id]);//分裂出来
						ins(rs,lt,min(tmp.val,rt),id);
					}
				}
			}
		}
	}
	if(l!=r-1)mdf(ls,lt,rt),mdf(rs,lt,rt);
}
#undef ls
#undef rs
#undef mid


void init(){
	scanf("%d%d",&n,&Tp);
	build(1,0,M);
}
void work(){
	int op,l,r;
	ll1 Ans=0;
	for(int nw=1;nw<=n;nw++){
		scanf("%d%d%d",&op,&l,&r);
		l=(l+Tp*Ans)%200001;
		r=(r+Tp*Ans)%200001;
		if(op==1)ins(1,l,r,++tots);
		if(op==2)mdf(1,l,r);
		if(op==3){
			Ans=BIT::Qry(l,r-1);//注：视为左闭右开
			printf("%lld\n",Ans);
		}
	}
}
int main(){
	init();
	work();
	return 0;
}
/*
你知道吗

对于猫来说

不喜欢的人摸(踩)它的后背

它就会跳起来哈气
*/
```

---

## 作者：piantouqu (赞：0)

神仙 DS 题。

很巧妙的转化。

13 \~ 17 的部分分做法容易想到：对一边 $l$ 取 $\max$，一边 $r$ 取 $\min$，处理不难。

考虑把这种方式扩展成全局情况：

1. $mid$ 为当前的划分点，每次对跨过 $mid$ 的线段进行处理，并且它可能与左右两边的线段也有交，应继续往下处理。
2. 如果修改没有跨过分阶点，暴力去修改它的范围。
3. 如果 $l$ \~ $r$ 被完全覆盖，显然操作是无效的，直接退出。

拿堆维护 $l，r$ 大小不难（当然你用吉司机线段树也可以，就是码量要大些）。

计算贡献就都会了吧，就不多写了。

这个复杂度应该是可以用势能算，复杂度是 $n\log^2 n$ 的。

代码实现有点困难，贴一下代码，注释应该很清楚。

```cpp
const int MX=2e5;
int q,type,last,cnt;
int val[N<<3],oth[N<<3],sz[N<<3],hv[N<<3];
int f[N<<3];
vector<int> g[N<<3];
struct BIT{
#define lowbit(x) (x&(-x))
    int t[MX+5];
    void clear(){memset(t,0,sizeof t);}
    void update(int x,int y){for(;x<=MX;x+=lowbit(x)) t[x]+=y;}
    int query(int x){int res=0;for(;x;x-=lowbit(x)) res+=t[x];return res;}
    int query(int l,int r){return query(r)-query(l-1);}
}t1,t2,t3,t4;
struct Tree{
    int l,r;
    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> >  > q1;
    priority_queue<pair<int,int> > q2;
}t[N<<2];

void addl(int x,int y){t1.update(x,y),t2.update(x,1ll*y*x);}

void addr(int x,int y){t3.update(x,y),t4.update(x,1ll*y*x);}

int query(int l,int r){
    int res=0;
    res=t4.query(l,r)+1ll*r*t3.query(r+1,MX)+1ll*l*t3.query(l-1);
    res-=1ll*l*t1.query(l)+1ll*r*(t1.query(r+1,MX))+t2.query(l+1,MX)-t2.query(r+1,MX);
    return res;
}//跟我的计算贡献说去吧

int find(int x){
    if(!f[x]||f[x]==x) return x;
    return f[x]=find(f[x]);
}

int mergy(int x,int y){
    if(!x||!y) return x|y;
    x=find(x),y=find(y);
    if(x==y) return x;
    if(sz[x]<sz[y]) swap(x,y);
    f[y]=x,sz[x]+=sz[y];
    g[x].emplace_back(y);
    return x;
}//这东西显然要启发式合并。

void build(int u,int l,int r){
    t[u].l=l,t[u].r=r;
    if(l==r) return ;
    int mid=(l+r)>>1;
    build(ls,l,mid),build(rs,mid+1,r);
}

void ins(int u,int l,int r){
    // printf("%d %d %d %d %d\n",u,l,r,t[u].l,t[u].r);
    int mid=(t[u].l+t[u].r)>>1;
    if(l<=mid&&mid<r){
        int L=++cnt,R=++cnt;
        val[L]=l,val[R]=r;//记录真实值
        oth[L]=R,oth[R]=L;//方便找另一个
        hv[L]=hv[R]=sz[L]=sz[R]=1;//标记一下，存大小
        t[u].q1.push({l,L}),t[u].q2.push({r,R});
        return ;
    }
    if(r<=mid) ins(ls,l,r);
    if(l>mid) ins(rs,l,r);
}

void insl(int u,int l,int r,int L,int NL){
    if(hv[L]){
        int R=oth[L],NR=val[find(R)];hv[L]=hv[R]=0;
        sz[find(L)]--,sz[find(R)]--;
        addl(NL,-1),addr(NR,-1);//删除原有贡献
        int nl=max(NL,l),nr=min(NR,r);//取交
        // printf("1::%d %d\n",nl,nr);
        if(nl<nr) addl(nl,1),addr(nr,1),ins(u,nl,nr);//塞回去
    }
    for(int v:g[L]) insl(u,l,r,v,NL);//处理合并时遗留的
}

void insr(int u,int l,int r,int R,int NR){
    if(hv[R]){
        int L=oth[R],NL=val[find(L)];hv[L]=hv[R]=0;
        sz[find(L)]--,sz[find(R)]--;
        addl(NL,-1),addr(NR,-1);
        int nl=max(NL,l),nr=min(NR,r);
        // printf("2::%d %d %d %d %d %d\n",nl,nr,NL,NR,l,r);
        if(nl<nr) addl(nl,1),addr(nr,1),ins(u,nl,nr);
    }
    for(int v:g[R]) insr(u,l,r,v,NR);
}//同上

void update(int u,int l,int r){
    // if(t[u].r<=10) printf("%d %d %d %d\n",l,r,t[u].l,t[u].r);
    if(l<=t[u].l&&t[u].r<=r) return ;
    int mid=(t[u].l+t[u].r)>>1;
    if(l<=mid&&mid<r){
        int all=0;
        while(!t[u].q1.empty()){
            auto p=t[u].q1.top();if(p.fi>=l) break;
            addl(p.fi,-sz[p.se]);//删除贡献
            all=mergy(all,p.se);//把所有的并在一起。
            t[u].q1.pop();
        }
        if(all) val[all]=l,addl(l,sz[all]),t[u].q1.push({l,all});
        all=0;
        while(!t[u].q2.empty()){
            auto p=t[u].q2.top();if(p.fi<=r) break;
            addr(p.fi,-sz[p.se]);//删除贡献
            all=mergy(all,p.se);//把所有的并在一起。
            t[u].q2.pop();
        }
        if(all) val[all]=r,addr(r,sz[all]),t[u].q2.push({r,all});
        update(ls,l,r),update(rs,l,r);//继续搜下去
        return ;
    }
    if(r<=mid){
        while(!t[u].q1.empty()){
            auto v=t[u].q1.top();if(v.fi>r) break;
            insl(ls,l,r,v.se,v.fi);t[u].q1.pop();
        }//显然不能塞回来了，只能存在于 ls 内
        update(ls,l,r);
        return ;
    }
    if(l>mid){
        while(!t[u].q2.empty()){
            auto v=t[u].q2.top();if(v.fi<l) break;
            insr(rs,l,r,v.se,v.fi);t[u].q2.pop();
        }//类似于上面
        update(rs,l,r);
        return ;
    }
}

signed main(){
    cin>>q>>type;
    build(1,1,MX);
    while(q--){
        int opt,l,r;cin>>opt>>l>>r;
        l=(l+type*last)%mod,r=(r+type*last)%mod;
        if(opt==1){
            if(l==r) continue;
            addl(l,1),addr(r,1),ins(1,l,r);
        }else if(opt==2){
            update(1,l,r);
        }else{
            last=query(l,r);
            cout<<last<<'\n';
        }
    }
    return 0;
}
```

---


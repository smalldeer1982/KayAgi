# 「CGOI-3」灵气

## 题目背景

>「地牢中回荡着尖叫声...」

打完世花的 ac 进入地牢刷灵气……

花后地牢十分险恶，ac 想在地牢里搭满单向门。

[![](https://cdn.luogu.com.cn/upload/image_hosting/a1ewte9n.png)](https://www.bilibili.com/video/BV1jf4y1Z7RB)

## 题目描述

ac 世界里的地牢有 $n$ 个小房间，恰好存在 $n-1$ 条过道，并且每个小房间连通。第 $i$ 个小房间生成的怪在一个时刻**最多只会存在一个**，且**伤害为 $a_i$**。

为了方便刷灵气，ac 在每个过道上建了一个单向门。

每一秒会发生以下几个事件之一：

1. 第 $x$ 个房间生成了一个怪。怪**不会穿墙**，只会顺着单向门方向移动。

2. 第 $x$ 个房间生成的怪被 ac 的仆从干掉了。

3. ac 想要挂机刷怪，于是他希望知道，如果从时刻 1 开始站在房间 $x$ 一直到当前时刻，受到伤害最多的一个时刻所受伤害是多少。

这里定义一个时刻受到伤害为可以走到 ac 所在房间的怪的伤害值总和，“可以走到”定义为可以穿过若干条单向门到达 ac 的房间（若干可以为 $0$）。ac 非常强大，不会中途被怪打死。

当然，ac 所在的位置**不会改变怪的刷新**和**仆从的行为**。

#### 简化版题面

一棵树，每个点有个点权，每条边有个方向。

有个集合，一开始为空，三个操作：

1. 在集合中加入一个点。
2. 删除集合中的一个点。
3. 给出一个点 $x$，询问集合中满足可以走到 $x$ 的点的点权之和的历史最大值。

## 说明/提示

#### 样例一说明
第一个询问中，时刻 $1$ 存在怪的房间为 $\{4\}$，$4$ 号房间的怪可以走到 $1$ 号房间，因此答案为 $a_4=4$。

第二个询问中，受到伤害最大的时刻为时刻 $1$，答案为 $a_4=4$。其中时刻 $5$ 存在怪的房间为 $\{3,5\}$，而 $5$ 号房间的怪走不到 $1$ 号房间，因此此时刻受到伤害为 $a_3=3<4$，不是最大值。

第三个询问中，受到伤害最大的时刻为时刻 $5$，$3,5$ 号房间的怪均可走到 $5$，因此答案为 $a_3+a_5=8$。

---

#### 数据范围
**「本题采用捆绑测试」**

对于 $10\%$ 的数据，$n,m \leq 2000$。

对于另 $10\%$ 的数据，过道 $(x,y)$ 单向门满足 $x<y$。

对于另 $30\%$ 的数据，不存在 2 事件。

对于 $100\%$ 的数据，$1\leq n,m \leq 2\times 10^5$，$1\leq a_i\leq10^4$。

~~但是地牢幽魂就是穿墙怪（）（）（）~~

~~不会真的有人会在地牢里搭满单向门吧。~~


## 样例 #1

### 输入

```
5 7
1 2 3 4 5
1 2
3 1
4 3
3 5
1 4
3 1
2 4
1 3
1 5
3 1
3 5```

### 输出

```
4
4
8```

## 样例 #2

### 输入

```
8 7
4 1 3 5 8 6 2 9
1 2
3 1
4 2
5 1
5 6
7 5
6 8
1 1
1 5
3 7
3 1
1 2
2 5
3 5
```

### 输出

```
0
12
8
```

# 题解

## 作者：jrxxx (赞：19)

[题面](https://www.luogu.com.cn/problem/P8959)

模拟赛时当暴力写的，结果 AC 了。

向大佬请教后发现复杂度竟是 $O(n\log n)$！

该做法离线。好想也好写，不需要分类讨论。

---

## 思路

将题目中加/删点操作的集合记作 $S$。

记 $f_x(i)$ 表示 $i$ 时刻 $S$ 中可以到达 $x$ 的所有点的点权和。

对每一个点 $x$ 维护长为 $q$ 的序列 $f_x$，初始全为 $0$。 

将所有加/删点操作离线下来。若一个点 $x$ 在 $l$ 时刻加入，$r+1$ 时刻删除，则将 $f_x$ 的 $[l,r]$ 区间加 $a_x$。另外，第 $q$ 次操作后还在 $S$ 中的点认为在 $q+1$ 时刻删除。

拓扑排序。删掉一条边 $u\rightarrow v$ 时，因为能到达 $u$ 的点一定能到达 $v$，所以将 $f_u$ 向 $f_v$ 对应位置相加。一个点被加入队列时，所有能到达它的点都直接或间接向它贡献完成了。整个拓扑排序结束后，所有 $f$ 都正确了。

在 $t$ 时刻查询 $x$，即为查询 $\max_{i\in [1,t]}f_x(i)$。

考虑采用数据结构维护 $f$，需要支持的操作有：区间加，合并，前缀 $\max$。线段树即可。

---

## 复杂度

常见的线段树合并因为将 $x$ 向 $y$ 合并后，$x$ 不再参与合并，相当于删掉一个点，所以合并复杂度不超过总结点数，为 $O(n\log n)$。典例是在内向树上按拓扑序合并。

本题没有这样的性质。

假如存在 $x\rightarrow y,\ x\rightarrow z$ 这两条边，$x$ 向 $y$ 合并后，还会再向 $z$ 合并。乍一看好像很寄，但可以发现这样合并的复杂度不劣于 $x\rightarrow y,\ y\rightarrow z$。 

重复对出度大于 $1$ 的点执行这个操作，最终所有点出度 $\le 1$，得到一棵内向树。而内向树上合并的复杂度为 $O(n\log n)$。于是该做法的复杂度也是 $O(n\log n)$。

---

## 实现细节

- 因为存在复用，所以线段树合并时一定要新建版本再修改。我写的是标记永久化，如果 $\rm{pushdown}$ 的话也要注意这个问题。

- $\max(a_i+b_i)\not = \max a_i+\max b_i$，所以处理两个线段树上都有的节点时，$\rm{tag}$ 相加，但是 $\rm{ans}$ 不能直接相加，要等儿子处理完再 $\rm{pushup}$。

---

完结。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+7;
int n,q,rt[N],que[N],indeg[N],a[N],t[N],ans[N];
vector<int> G[N];
vector<pair<int,int>> Q[N];
namespace SGT
{
    int tot;
    struct node{int ls,rs,ans,tag;}tr[N*80];
    #define ls(p) tr[p].ls
    #define rs(p) tr[p].rs
    inline void pushup(int p){tr[p].ans=tr[p].tag+max(tr[ls(p)].ans,tr[rs(p)].ans);}
    void add(int &p,int L,int R,int x,int l=1,int r=q)
    {
        if(!p) p=++tot;
        if(L<=l&&r<=R) return tr[p].ans+=x,tr[p].tag+=x,void();
        int mid=(l+r)>>1;
        if(L<=mid) add(ls(p),L,R,x,l,mid);
        if(R>mid)  add(rs(p),L,R,x,mid+1,r);
        pushup(p);
    }
    void merge(int &p,int q)
    {
        if(!p||!q) return p|=q,void();
        int o=++tot;tr[o]=tr[p],p=o;
        merge(ls(p),ls(q));
        merge(rs(p),rs(q));
        tr[p].tag+=tr[q].tag;
        pushup(p);
    }
    int query(int p,int L,int R,int l=1,int r=q)
    {
        if(!p) return 0;
        if(L<=l&&r<=R) return tr[p].ans;
        int mid=(l+r)>>1,res=0;
        if(L<=mid) res=query(ls(p),L,R,l,mid);
        if(R>mid)  res=max(res,query(rs(p),L,R,mid+1,r));
        return res+tr[p].tag;
    }
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0);
    int i,x,y,op,qcnt=0,hd,tl,u;
    cin>>n>>q;
    for(i=1;i<=n;++i) cin>>a[i];
    for(i=1;i<n;++i)
    {
        cin>>x>>y;
        G[x].push_back(y),++indeg[y];
    }
    for(i=1;i<=q;++i)
    {
        cin>>op>>x;
        if(op==1) t[x]=i;
        else if(op==2) SGT::add(rt[x],t[x],i-1,a[x]),t[x]=0;
        else Q[x].emplace_back(i,++qcnt);
    }
    for(i=1;i<=n;++i)if(t[i]!=0) SGT::add(rt[i],t[i],q,a[i]);
    //topo
    hd=1,tl=0;
    for(i=1;i<=n;++i)if(indeg[i]==0) que[++tl]=i;
    while(hd<=tl)
    {
        u=que[hd++];
        for(int v:G[u])
        {
            SGT::merge(rt[v],rt[u]);
            if(!--indeg[v]) que[++tl]=v;
        }
        for(auto p:Q[u]) ans[p.second]=SGT::query(rt[u],1,p.first);
    }
    for(i=1;i<=qcnt;++i) cout<<ans[i]<<'\n';
    return 0;
}
```


---

## 作者：Lynkcat (赞：10)

先考虑只查询当前值怎么做。

修改相当于把从当前点开始一条不断向上跳的链上的每个点点权加，查询相当于从当前点开始一条不断向上跳反向边的链上的每个点点权和。

考虑等价于修改相当于把从当前点开始一条不断向上跳的链上的每个点所往下能到的点点权加，查询单点查询。

那么只要把这些点贴在一起形成一个区间我们就能够把区间加区间减查询历史最大值套上去了。

考虑每个由向上的边形成的连通块，对连通块进行树剖，然后将每个重链按顺序把每个点往下能够跳到的点加入序列即可。

直接做 $O(n\log^2n)$，利用全局平衡二叉树可以做到 $O(n\log n)$。 

---

## 作者：DengDuck (赞：7)

由于节点是有加入有删除的，所以我一开始的想法是线段树分治，但是要求历史最大值，所以否掉了。

然后看了题解知道要把维护放在时间轴上，变成 $n$ 个数组。

那么对于每一个节点，我们先算其自身的贡献，对于其存在的时间，全部加上自身的权值 $a_x$。

由于这是一棵有向树，只有“指向我”的点会给我做贡献，我们把离我距离大于 $1$ 的点的贡献通过与我相连的点简介传过来。

所以我们的想法很明显，不断更新点的贡献，一个点的数组已经求好之后就去更新其他邻接的节点的数组。

每次贡献别的数组其实就是合并，相同位置权值相加，可以线段树合并解决。

发现拓扑排序是符合我们要求的，所以拓扑过程中线段树合并即可。

学到了什么？

- 线段树合并可以处理时间轴上的贡献计算。
- 线段树求最值可以不下传懒标记。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pLL pair<LL,LL>
#define fir first
#define sec second
#define pb push_back
using namespace std;
const LL N=2e5+5;
const LL inf=2e5;
LL n,m,rt[N],tot,du[N],a[N],ans[N],st[N];
vector<LL>v[N];
vector<pLL>Q[N];
struct node
{
	LL l,r,mx,lz;
}t[N*60];
void pushup(LL rt)
{
	if(rt)t[rt].mx=t[rt].lz+max(t[t[rt].l].mx,t[t[rt].r].mx);
}
void upd(LL &rt,LL l,LL r,LL x,LL L,LL R)
{
	
	if(r<L||R<l)return;
//	cout<<l<<' '<<r<<' '<<L<<' '<<R<<' '<<x<<endl;
	if(!rt)rt=++tot;
	if(L<=l&&r<=R)
	{
		t[rt].mx+=x,t[rt].lz+=x;
		return;
	}
	LL mid=l+r>>1;
	upd(t[rt].l,l,mid,x,L,R),upd(t[rt].r,mid+1,r,x,L,R);
	pushup(rt);
}
void merge(LL &rt1,LL rt2)
{
	if(!rt1||!rt2)
	{
		rt1+=rt2;
		return;
	}
	LL now=++tot;
	t[now]=t[rt1],rt1=now;
	merge(t[rt1].l,t[rt2].l),merge(t[rt1].r,t[rt2].r);
	t[rt1].lz+=t[rt2].lz;	
	pushup(rt1);
}
LL query(LL rt,LL l,LL r,LL L,LL R)
{
	if(r<L||R<l)return 0;
	if(!rt)return 0;
	if(L<=l&&r<=R)return t[rt].mx;
	LL mid=l+r>>1;
	return max(query(t[rt].l,l,mid,L,R),query(t[rt].r,mid+1,r,L,R))+t[rt].lz;	
}
queue<LL>q;
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<=n-1;i++)
	{
		LL x,y;
		scanf("%lld%lld",&x,&y);
		v[x].pb(y);
		du[y]++;
	}
	LL cnt=0;
	for(int i=1;i<=m;i++)
	{
		LL op,x;
		scanf("%lld%lld",&op,&x);
		if(op==1)st[x]=i;
		if(op==2)upd(rt[x],1,m,a[x],st[x],i-1),st[x]=0;
		if(op==3)Q[x].pb({i,++cnt});
	}
	for(int i=1;i<=n;i++)
	{
		if(st[i]!=0)upd(rt[i],1,m,a[i],st[i],m);
	}
	for(int i=1;i<=n;i++)
	{
		if(!du[i])q.push(i);
	}
	while(!q.empty())
	{
		LL x=q.front();
		q.pop();
		for(LL i:v[x])
		{
			merge(rt[i],rt[x]);
			du[i]--;
			if(!du[i])q.push(i);
		}
		for(pLL i:Q[x])
		{
			ans[i.sec]=query(rt[x],1,m,1,i.fir);
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		printf("%lld\n",ans[i]);
	}
}
```

---

## 作者：hlsnqdmz (赞：7)

题外话：这道题是本蒟蒻的第一道黑，也是第一道写题解的黑。所以有什么不足欢迎提出。

看到简化版题面，我们看到我们需要写三个功能：添加、删除、查询。

我们先考虑在线怎么做，对于每个添加和删除，我们都可以在线段树上维护，所以我们可以对于每个房间开一棵线段树，下标代表着时间。那么查询可以将通向查询房间的房间的线段树全部合并，然后再查询线段树上的前缀最大值，即查询区间 $1\sim x$，满足区间和最大。由于要线段树合并，所以我们要用动态开点的权值线段树。但是由于每棵线段树不止合并一次，所以线段树合并也要动态开点，那么空间就很容易爆炸，也很容易超时，所以在线是不好做的（不过好像有大佬做出来了）。

那么我们考虑离线，离线有个好处是我们不需要考虑求前缀最大值，我们可以记录下每个点加入时间和删除时间，然后就可以区间加，对于没有删除的点，就区间加到线段树的右区间。最后我们再 dfs 统一合并，然后处理查询。这样做看起来就没什么问题了。但是注意合并完后的线段树是单向门**通向**的房间的。所以换到 dfs 上就是当前节点的线段树与儿子的线段树合并，然后儿子带着这棵合并的线段树递归下去。

那么我们发现每个房间的线段树只会和有单向门直接连向它和间接连向它的线段树合并，这让我们想到什么？答曰：拓扑排序，所以我们可以通过拓扑排序优化掉 dfs。另外由于合并时也要下传懒标记，不好写也容易写错（不过好像出错的原因是动态开点线段树下传标记可能下传到没有节点的位置，可以在下传时新建节点来解决，不过会 [RE](https://www.luogu.com.cn/record/224609025)/[MLE](https://www.luogu.com.cn/record/224609137)），但是我们可以使用标记永久化。注意线段树合并时如果到叶子节点也要加上标记并且更新最大值。

首先给出求前缀最大值的代码，码量应该要少一点，不需要打标记，少了很多玄学错误：
```
//Just Sayori
//这是求最大前缀和的
#pragma GCC diagnostic ignored "-Wnarrowing"
#pragma GCC diagnostic ignored "-Wsign-compare"
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <utility>
#include <queue>
#define ll long long
#define rnt register int
#define gr getchar
#define pr putchar
#define N 200005
#define M 1000000007
using namespace std;
inline ll read()
{
	int f = 1;
	ll x = 0;
	char ch = gr();
	while (ch < '0' || ch > '9') ch == '-' ? f = -1, ch = gr() : ch = gr();
	while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = gr();
	return x * f;
}
inline void write(ll x)
{
	static int top = 0, sta[39];
	if (x < 0) pr('-'), x = -x;
	do sta[++top] = x % 10, x /= 10;
	while (x);
	while (top) pr(sta[top--] ^ 48);
}
struct edge
{
	int v,next;
}e[N<<1];
int head[N],cnt;
inline void add(int u,int v)
{
	e[++cnt]={v,head[u]},head[u]=cnt;
}
int a[N],in[N],root[N];
ll ans[N];
queue<int> q;
vector<pair<int,int>> ve[N];
#define mid ((l+r)>>1)
#define lc(x) s[x].lc
#define rc(x) s[x].rc
#define w(x) s[x].w
#define lw(x) s[x].lw
struct node
{
	int lc,rc;
	ll w,lw;
}s[N<<6];//本来以为空间要开很大的……
inline void push_up(int u)
{
	w(u)=w(lc(u))+w(rc(u));
	lw(u)=max(lw(lc(u)),w(lc(u))+lw(rc(u)));
}
void modify(int &u,int l,int r,int x,int w)
{
	if (!u) u=++cnt;
	if (l==r) return w(u)+=w,lw(u)+=w,void();
	if (x<=mid) modify(lc(u),l,mid,x,w);
	else modify(rc(u),mid+1,r,x,w);
	push_up(u);
}
pair<ll,ll> query(int u,int l,int r,int ls,int rs)
{
	if (ls<=l && r<=rs) return make_pair(lw(u),w(u));
	ll ans=0;
	pair<ll,ll> p1=make_pair(0,0),p2;
	if (ls<=mid)
		p1=query(lc(u),l,mid,ls,rs),ans=p1.first;
	if (rs>=mid+1)
		p2=query(rc(u),mid+1,r,ls,rs),ans=max(ans,p1.second+p2.first);
	return make_pair(ans,p1.second+p2.second);
}
void merge(int &u,int v,int l,int r)
{
	if (!u || !v) return u|=v,void();
	int root=++cnt;
	s[root]=s[u],u=root;
	if (l==r) return w(u)+=w(v),lw(u)+=lw(v),void();
	merge(lc(u),lc(v),l,mid);
	merge(rc(u),rc(v),mid+1,r);
	push_up(u);
}
int main()
{
	int n=read(),m=read(),k=0;
	for (rnt i=1;i<=n;i++) a[i]=read();
	for (rnt i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v),in[v]++;
	cnt=0;
	for (rnt i=1,x;i<=m;i++)
		switch(read())
	{
	case 1:
		x=read();
		modify(root[x],1,n,i,a[x]);
		break;
	case 2:
		x=read();
		modify(root[x],1,n,i,-a[x]);
		break;
	case 3:
		x=read(),k++;
		ve[x].emplace_back(make_pair(i,k));
		break;
	}
	for (rnt i=1;i<=n;i++)
		if (!in[i])
			q.emplace(i);
	while (!q.empty())
	{
		int u=q.front();
		q.pop();
		for (rnt i=head[u];i;i=e[i].next)
		{
			int v=e[i].v;
			merge(root[v],root[u],1,n);
			if (!(--in[v])) q.emplace(v);
		}
		for (rnt i=0;i<ve[u].size();i++)
			ans[ve[u][i].second]=query(root[u],1,n,1,ve[u][i].first).first;
	}
	for (rnt i=1;i<=k;i++) write(ans[i]),pr(10);
	return 0;
}
```

然后是区间加和标记永久化的：
```
//Just Sayori
//这是区间加加标记永久化的的
#pragma GCC diagnostic ignored "-Wnarrowing"
#pragma GCC diagnostic ignored "-Wsign-compare"
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <utility>
#include <queue>
#define ll long long
#define rnt register int
#define gr getchar
#define pr putchar
#define N 200005
#define M 1000000007
using namespace std;
inline ll read()
{
	int f = 1;
	ll x = 0;
	char ch = gr();
	while (ch < '0' || ch > '9') ch == '-' ? f = -1, ch = gr() : ch = gr();
	while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = gr();
	return x * f;
}
inline void write(ll x)
{
	static int top = 0, sta[39];
	if (x < 0) pr('-'), x = -x;
	do sta[++top] = x % 10, x /= 10;
	while (x);
	while (top) pr(sta[top--] ^ 48);
}
struct edge
{
	int v,next;
}e[N<<1];
int head[N],cnt;
inline void add(int u,int v)
{
	e[++cnt]={v,head[u]},head[u]=cnt;
}
int a[N],in[N],last[N],root[N];
ll ans[N];
queue<int> q;
vector<pair<int,int>> ve[N];
#define mid ((l+r)>>1)
#define lc(x) s[x].lc
#define rc(x) s[x].rc
#define w(x) s[x].w
#define t(x) s[x].tag
struct node
{
	int lc,rc;
	ll w,tag;
}s[N<<6];
inline void push_up(int u)
{
	w(u)=max(w(lc(u)),w(rc(u)))+t(u);
}
void modify(int &u,int l,int r,int ls,int rs,int w)
{
	if (!u) u=++cnt;
	if (ls<=l && r<=rs) return w(u)+=w,t(u)+=w,void();
	if (ls<=mid) modify(lc(u),l,mid,ls,rs,w);
	if (rs>=mid+1) modify(rc(u),mid+1,r,ls,rs,w);
	push_up(u);
}
ll query(int u,int l,int r,int ls,int rs)
{
	if (ls<=l && r<=rs) return w(u);
	ll ans=0;
	if (ls<=mid)
		ans=query(lc(u),l,mid,ls,rs);
	if (rs>=mid+1)
		ans=max(ans,query(rc(u),mid+1,r,ls,rs));
	return ans+t(u);
}
void merge(int &u,int v,int l,int r)
{
	if (!u || !v) return u|=v,void();
	int root=++cnt;
	s[root]=s[u],u=root;
	if (l==r) return w(u)+=w(v),t(u)+=t(v),void();
	merge(lc(u),lc(v),l,mid);
	merge(rc(u),rc(v),mid+1,r);
	t(u)+=t(v);
	push_up(u);
}
int main()
{
	int n=read(),m=read(),k=0;
	for (rnt i=1;i<=n;i++) a[i]=read();
	for (rnt i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v),in[v]++;
	cnt=0;
	for (rnt i=1,x;i<=m;i++)
		switch(read())
	{
	case 1:
		x=read();
		last[x]=i;
		break;
	case 2:
		x=read();
		modify(root[x],1,n,last[x],i-1,a[x]);
		last[x]=0;
		break;
	case 3:
		x=read(),k++;
		ve[x].emplace_back(make_pair(i,k));
		break;
	}
	for (rnt i=1;i<=n;i++)
		if (last[i])
			modify(root[i],1,n,last[i],n,a[i]);
	for (rnt i=1;i<=n;i++)
		if (!in[i])
			q.emplace(i);
	while (!q.empty())
	{
		int u=q.front();
		q.pop();
		for (rnt i=head[u];i;i=e[i].next)
		{
			int v=e[i].v;
			merge(root[v],root[u],1,n);
			if (!(--in[v])) q.emplace(v);
		}
		for (rnt i=0;i<ve[u].size();i++)
			ans[ve[u][i].second]=query(root[u],1,n,1,ve[u][i].first);
	}
	for (rnt i=1;i<=k;i++) write(ans[i]),pr(10);
	return 0;
}
```

### 感谢您的观看！

upd by 2025-7-15：没想到之前写的题解有大量问题，基本是重写了一遍，删去一些毫无意义的内容，还把代码也重写了。三个月的时间结果洛谷上也只做出这一道黑题。

---

## 作者：Union_Find (赞：5)

首先，注意到这道题有删除操作，考虑可以离线下来在时间轴上维护数据结构，最经典的就是线段树分治。

对于这道题，比较友好的是我们容易发现每个点存在于一段区间，当我们不考虑移动时，可以直接线段树区间加 $a_u$，查询前缀最大值。但是这题还有一个移动操作，所以考虑拓扑排序，可以使用线段树合并维护。

于是我们就敲完了代码，过了样例，结果发现只有 Sub $2$ 过了。观察 Sub $2$ 限制了统一方向，于是我们就发现，在拓扑排序里，一个点会用于转移多次，所以线段树合并要新建节点再合并。

但是会 T 吗？写完结果真的没 T，但是为什么呢？

直观感受，因为打乱了顺序，不想正常的树上线段树合并可以证明 $O(n\log n)$，这题我们直觉会有 $x \to y$，并且 $x \to z$，并且节点数很多导致重复。但实际上我们想多了。在 $x \to y$ 之后，$y$ 的线段树节点数一定比 $x$ 多，所以接下来 $y \to z$ 肯定比 $x \to z$ 更劣，但是在内向树的时候证明了时间复杂度是 $O(n\log n)$ 的，所以树上的拓扑排序时间复杂度也是 $O(n\log n)$ 的。

然后就极短的码量过了这题，甚至一大半是线段树合并板子。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 200005
#define rep(u, v) for (int ii = hd[u], v = ev[ii]; ii; ii = nxt[ii], v = ev[ii])
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
int n, m, u, v, a[N], lst[N], ans[N], op, du[N];
int hd[N], nxt[N], ev[N], en;
il void addedge(int u, int v){nxt[++en] = hd[u], hd[u] = en, ev[en] = v;}
int tr[N << 6], tag[N << 6], ls[N << 6], rs[N << 6], rt[N], ep;
vector <int> qury[N];
queue <int> q;
void add(int &p, int l, int r, int nl, int nr, int k){
	if (!p) p = ++ep;
	if (nl <= l && r <= nr) return tr[p] += k, tag[p] += k, void(0);
	int mid = (l + r) >> 1;
	if (nl <= mid) add(ls[p], l, mid, nl, nr, k);
	if (nr > mid) add(rs[p], mid + 1, r, nl, nr, k);
	tr[p] = max(tr[ls[p]], tr[rs[p]]) + tag[p];
}int ask(int p, int l, int r, int nl, int nr){
	if (!p) return 0;
	if (nl <= l && r <= nr) return tr[p];
	int mid = (l + r) >> 1, ans = 0;
	if (nl <= mid) ans = max(ans, ask(ls[p], l, mid, nl, nr));
	if (nr > mid) ans = max(ans, ask(rs[p], mid + 1, r, nl, nr));
	return ans + tag[p];
}int merge(int u, int v, int l, int r){
	if (!u || !v) return u | v;
	int p = ++ep;
	if (l == r) return tr[p] = tr[u] + tr[v], p;
	tag[p] = tag[u] + tag[v];
	int mid = (l + r) >> 1;
	ls[p] = merge(ls[u], ls[v], l, mid), rs[p] = merge(rs[u], rs[v], mid + 1, r);
	tr[p] = max(tr[ls[p]], tr[rs[p]]) + tag[p];
	return p;
}

int main(){
	n = rd(), m = rd();
	for (int i = 1; i <= n; i++) a[i] = rd(), lst[i] = -1;
	for (int i = 1; i < n; i++) u = rd(), v = rd(), addedge(u, v), du[v]++;
	for (int i = 1; i <= m; i++){
		op = rd(), u = rd(), ans[i] = -1;
		if (op == 1) lst[u] = i;
		else if (op == 2) add(rt[u], 1, m, lst[u], i - 1, a[u]), lst[u] = -1;
		else qury[u].push_back(i);
	}for (int i = 1; i <= n; i++) if (~lst[i]) add(rt[i], 1, n, lst[i], m, a[i]);
	for (int i = 1; i <= n; i++) if (!du[i]) q.push(i);
	while (!q.empty()){
		int u = q.front();q.pop();
		for (int id : qury[u]) ans[id] = ask(rt[u], 1, n, 1, id);
		rep(u, v){
			rt[v] = merge(rt[v], rt[u], 1, m), du[v]--;
			if (!du[v]) q.push(v);
		}
	}for (int i = 1; i <= m; i++) if (~ans[i]) printf ("%d\n", ans[i]);
	return 0;
}

```

---

## 作者：鱼跃于渊 (赞：5)

一道不错的 ds 题，但难度似乎虚高？  

## 做法  

发现题目既有插入删除操作，又要求查询历史点集最值。  
在线维护想不到什么突破口，转而思考离线解法。  
发现题目给出了一个有向树，也就是说这实际上是一个 DAG。  
可以联想到拓扑排序，这样正好可以统计到所有可以走到 $x$ 的点。  
显然怪物出现的时间是一段一段的，即在出现时间到消失时间这段区间产生了贡献。  
而询问涉及的时间也是一段一段的，即询问初始时间到询问时间这段区间内的最值。  
如何把这些区间都叠到一起呢？可以想到线段树合并。  

我们离线所有询问操作，出现插入删除操作就把这段时间都加上 $a_{x}$。  
然后一边拓扑排序一边线段树合并更新最值，最终再解决询问即可。  
时间复杂度为 $O(n\log n)$，可以通过此题。  

注意在线段树合并时要新开结点代替原来结点，原因很简单：  
一颗线段树会合并到多个线段树上去，在合并时可能会在别的线段树内留下自己的结点。  
当另一颗线段树来合并时，如果你不选择新开结点就会出事。  
因为更新到的结点可能在多个线段树上存在，从而导致其他线段树的信息也被更改了。  


## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace basic{
#define int long long
#define uint unsigned int
#define per(i,a,b) for(int i=(a);i<=(b);i++)
#define perr(i,a,b,c) for(int i=(a);i<=(b);i+=(c))
#define rep(i,b,a) for(int i=(b);i>=(a);i--)
#define epb emplace_back
#define bit(x) (1ll<<(x))
#define all(x,l,r) &(x)[l],&(x)[r]+1
#define vall(x) (x).begin(),(x).end()
#define lowbit(x) ((x)&(-(x)))
#define pc(x) putchar(x)
#define turn(x) (x-'a'+1)
#define cto const auto
#define exc exchange
template <class T> bool chkmn(T &x,T y){return x>y?(x=y,1):0;}
template <class T> bool chkmn(T &x,T y,T z){return y<z?(x=y,1):(x=z,0);}
template <class T> bool chkmx(T &x,T y){return x<y?(x=y,1):0;}
template <class T> bool chkmx(T &x,T y,T z){return y>z?(x=y,1):(x=z,0);}
char *p1,*p2,buf[100000];
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read(){
    int x=0,f=1;char ch=nc();
    while(ch<48||ch>57){if(ch=='-') f=-1;ch=nc();}
    while(ch>=48&&ch<=57) x=x*10+ch-48,ch=nc();
    return x*f;
}
void write(int x){
    if(x<0) pc('-'),x=-x;
    if(x>9) write(x/10);
    pc(x%10+'0');
}
void print(string s,char op=0){for(auto x:s) pc(x);op&&pc(op);}
void print(int x,char op=0){write(x);op&&pc(op);}
}
using namespace basic;
namespace fisher{
bool mbe;void cntime();
const int N=2e5+5;
struct segtree{
    #define ls(x) t[x].ls
    #define rs(x) t[x].rs
    #define mx(x) t[x].mx
    #define tg(x) t[x].tg
    #define mid (((l)+(r))>>1)
    struct node{
        int mx,tg,ls,rs;
    }t[N<<6];
    int tot;
    segtree(){tot=0;}
    int new_node(node cp={0,0,0,0}){
        t[++tot]=cp;
        return tot;
    }
    void push_up(int i){
        mx(i)=tg(i)+max(mx(ls(i)),mx(rs(i)));
    }
    void update(int nl,int nr,int l,int r,int &i,int k){
        if(!i) i=new_node();
        if(nl<=l&&r<=nr){
            mx(i)+=k;tg(i)+=k;
            return;
        }
        if(nl<=mid) update(nl,nr,l,mid,ls(i),k);
        if(mid<nr) update(nl,nr,mid+1,r,rs(i),k);
        push_up(i);
    }
    int merge(int p,int q){
        if(!p||!q) return p|q;
        p=new_node(t[p]);
        ls(p)=merge(ls(p),ls(q));
        rs(p)=merge(rs(p),rs(q));
        tg(p)+=tg(q);push_up(p);
        return p;
    }
    int query(int nl,int nr,int l,int r,int i){
        if(!i) return 0;
        if(nl<=l&&r<=nr) return mx(i);
        int res=0;
        if(nl<=mid) chkmx(res,query(nl,nr,l,mid,ls(i)));
        if(mid<nr) chkmx(res,query(nl,nr,mid+1,r,rs(i)));
        return res+tg(i);
    }
}t;
int rt[N];
int n,m,k,a[N],ans[N];
int in[N],tub[N];
vector <int> e[N];
vector <tuple<int,int>> qu[N];
queue <int> q;
void main(){
    n=read();m=read();
    per(i,1,n) a[i]=read();
    per(i,2,n){
        int u=read(),v=read();
        e[u].epb(v);in[v]++;
    }
    per(i,1,m){
        int op=read(),x=read();
        if(op==1) tub[x]=i;
        if(op==2)
            t.update(exc(tub[x],0),i-1,1,m,rt[x],a[x]);
        if(op==3) qu[x].epb(i,++k);
    }
    per(i,1,n) if(tub[i])
        t.update(exc(tub[i],0),m,1,m,rt[i],a[i]);
    per(i,1,n) if(!in[i]) q.push(i);
    for(int u;!q.empty();){
        u=q.front();q.pop();
        for(auto v:e[u]){
            rt[v]=t.merge(rt[v],rt[u]);
            if(!(--in[v])) q.push(v);
        }
    }
    per(i,1,n) for(auto [r,id]:qu[i])
        ans[id]=t.query(1,r,1,m,rt[i]);
    per(i,1,k) print(ans[i],'\n');
    return cntime();
}
bool mbd;void cntime(){
    cerr<<"Memory: "<<abs(&mbd-&mbe)/1048476.0<<" MB\n";
    cerr<<"Time: "<<1e3*clock()/CLOCKS_PER_SEC<<" ms\n";
}}
signed main(){
    fisher::main();
    return 0;
}
```

---

## 作者：iamzq (赞：5)

## CGOI Round 3 T4 灵气 题解

### subtask 1
每次加入删除点的时候直接更新每个点的答案，并取 $\max$。

### subtask 2
树剖什么的各显神通整就完了。

### subtask 3

没有删除操作，等价于最大值在当前时刻取，即去掉了“历史最大值”。

开一个数组 $sum$。

加入一个点 $x$ 时，先改 $x$ 的答案。如果 $x$ 的父边方向为 $x\rightarrow fa_x$，就令 $sum_{fa_x}$ 加上 $a_x$ 并继续往上跳，否则停止。

询问一个点时，先累加 $sum_x$。如果该点 $x$ 的父边方向为 $fa_x\rightarrow x$，就累加 $sum_{fa_x}$ 并继续往上跳，否则停止并输出答案。

这可以树剖解决。

~~但是这和正解没什么关系（）~~

### subtask 4
#### 前置知识：线段树合并

考虑离线，求出每个节点在集合中的时间段。

定义父边方向为 $x\rightarrow fa_x$ 的点为上节点，反之，为下节点。

以节点 $1$ 为根 dfs，每到一个上节点 $x$，按顺序做下列事情：

1. dfs 所有为上节点的儿子节点的子树。因为这些子树里的点的答案不会被外界干扰，所以可以直接当做独立的一棵树求。

2. 给 $x$ 开一棵 维护每个时刻集合内能到 $x$ 节点的点的权值和 的线段树，将所有为上节点的儿子节点的线段树与之合并，并将 $x$ 的区间加入其中。

3. 求出这个节点上所有询问的答案（区间最大值线段树）。

4. dfs 所有为下节点的儿子节点的子树。


到一个下节点 $x$，按顺序做下列事情：

1. 将父亲节点的线段树复制给当前节点，“复制”的意思为：
```root[x]=root[fa]```，```root[x]``` 表示 $x$ 点线段树的根节点。
2. dfs 所有为上节点的儿子节点的子树，合并。合并时需新开节点，防止污染到父亲节点的线段树。

3. 求答案，并且 dfs 所有为下节点的儿子节点的子树。

具体实现可以见 [std](/paste/d22s4is7)。
___

### 复杂度分析
瓶颈在于线段树合并。分两类考虑线段树合并操作：

对于合并至下节点的操作，可以考虑每个询问所贡献的节点被合并的次数，显然次数为 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cpvjl6u5.png?x-oss-process=image/resize,m_lfit,h_200,w_450)

（红色节点上的询问贡献的节点几经周折后只会经历一次合并到下节点的操作）

这一部分复杂度为节点数：$\mathcal O(n\log q)$。

对于合并至上节点的操作，为一般的线段树合并，复杂度为线段树的总结点数 $\mathcal O(n\log q)$。

证明可以用势能分析（by @ljc1301）：

可以考虑线段树总节点数的变化。

区间修改可以视为加入一个区间，一次操作最多会增加 $\log q$ 个节点。

合并两个节点时可以视为其中一个节点没了，那么每合并两个节点，总结点数会 $-1$。

再考虑每一个节点，会在一次区间修改中加入，某一次合并中被删除，所以对每个节点的时间复杂度是 $\mathcal O(1)$。
___
### 写在后面的废话
这道题真的出了很久很久~~~

这题源自于一年前的 idea，是把这道题去掉历史最大值，把树变成有向图的版本（可以缩点变成 dag），但是发现根本不可做，就放弃了。

然后某天学了淀粉质，以为把这道题放到树上就可淀粉质做。

把没有历史最大值的版本给 ac 做，被 ac 用树剖秒了，于是加上了历史最大值，以为用淀粉质还是能做。

后来发现淀粉质假飞了。但又发现把这题转成离线的方法很新，于是继续思考。

于是想了个 dsu 的做法。

后来发现 dsu 假了，于是想了个线段树合并。

我甚至打完了 std，调试的时候才发现还要撤销，以为暴力撤销复杂度是对的，并且随机数据跑很快，极限数据也很快。

和 ac 交流发现复杂度假了，而且极限数据造错了，刚准备自闭，ac 告诉我其实线段树合并可以可持久化。

（上面说的是我之前以为的做法）

之后一直以为这题是个只能停留在口胡上的题，码量爆炸且不可调。

不过打完 std 发现也不长（）

之后提交 rated 被认为假了，但我 AFO 了之后成了废物（虽然之前也是），就找了众多金钩爷（金牌爷）交流，发现是题解想错了，std 没错（就离谱），其实只是正常的线段树合并。之后修改了题解。

rated 了！

赛时被大佬用在线做法切了，神/bx/bx/bx/bx/bx。之前本来想加强成一段时间区间内的最大值，但怕容易被看出是离线，就没改。结果真的有在线做法。

附上 @ljc1301 对在线做法的理解。

![一张图](https://cdn.luogu.com.cn/upload/image_hosting/4r6lj76a.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

随机数据很水，不会出数据，不会构造/kk

不过，Terraria 真是一个很好玩的游戏，快来入坑！！！/kx

---

## 作者：一只绝帆 (赞：4)

考虑离线，对每个点求出一个时间轴，询问就是查询 $[1,i]$ 的时间轴上的最大值，考虑我们不能真的开出那么多空间，所以使用可持久化线段树合并。

具体来说，本题采用以下流程：

- 首先对每个点建立线段树，类似于线段树分治将这个点的出现区间全部加上 $a_x$（在这个点自己的动态开点线段树上）。

- 然后随便一个根开始 $\text{dfs}$，先递归指向 $x$ 的儿子（因为这些儿子会影响到其他的儿子），递归完成后将儿子的线段树合并到自己身上。

- 再递归 $x$ 指向的儿子，递归前将 $x$ 的线段树合并到儿子身上。

- 所有递归结束后在 $x$ 处统计所有询问的答案。

关于线段树合并为什么要可持久化，一个点的线段树要多次给儿子们复用，而普通的线段树合并会将原树变成新树的一部分，破坏了原结构。

关于复杂度的证明，可以理解为当且仅当两个点的路径上有 $\le 1$ 个交汇点，$=0$ 个分叉点，这两个点的线段树才会发生 $1$ 次合并，所以并不会有两棵原始树发生了多次合并，而我们知道一直合并的复杂度是跟节点个数成正比的，所以复杂度 $\Theta(n\log n)$。

关于区间修改的线段树合并，并不是所有区间修改的线段树都能合并，需要看叶子节点的合并和标记的合并是否吻合，本题就是相当于把两棵“区间加区间 $\max$”的线段树给“加”起来，所以直接使用标记永久化合并即可，叶子处和非叶子处都要将标记相加。

Code：

```cpp
// Problem: P8959 「CGOI-3」灵气
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8959
// Memory Limit: 512 MB
// Time Limit: 1000 ms

#include<bits/stdc++.h>
#define l(d) ls[d]
#define r(d) rs[d]
#define mid (L+R>>1)
#define vec basic_string
#define F(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
using namespace std;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char *p1,*p2,buf[1<<21];
int read() {
	int s=0,w=0;char ch=gc();
	while(ch<'0'||ch>'9') w|=(ch=='-'),ch=gc();
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=gc();
	return w?-s:s;
} const int N=2e5+5,C=3e7+5;
vec<int> G[N],Q[N],uG[N];
int mx[C],tg[C],snt,l(C),r(C),rt[N],a[N],n,m,vis[N],st[N],ans[N];
#define up(d) (mx[d]=tg[d]+max(mx[l(d)],mx[r(d)]))
void mo(int l,int r,int x,int L,int R,int &d) {
	!d&&(d=++snt);if(R<l||r<L) return;if(l<=L&&R<=r) return tg[d]+=x,mx[d]+=x,void();
	mo(l,r,x,L,mid,l(d));mo(l,r,x,mid+1,R,r(d));up(d);
}
int q(int l,int r,int L,int R,int d,int t=0) {
	if(R<l||r<L) return 0;if(l<=L&&R<=r) return mx[d]+t;
	return max(q(l,r,L,mid,l(d),t+tg[d]),q(l,r,mid+1,R,r(d),t+tg[d]));
}
int cpy(int d) {int x=++snt;l(x)=l(d);r(x)=r(d);mx[x]=mx[d];tg[x]=tg[d];return x;}
void mer(int L,int R,int &x,int y) {
	if(!x||!y) return x=cpy(x|y),void();
	x=cpy(x);if(L^R) mer(L,mid,l(x),l(y)),mer(mid+1,R,r(x),r(y));
	tg[x]+=tg[y];up(x);
}
void d(int x,int fa=0) {
	for(int v:uG[x]) if(v^fa) d(v,x),mer(1,m,rt[x],rt[v]);
	for(int v:G[x]) if(v^fa) mer(1,m,rt[v],rt[x]),d(v,x);
	for(int i:Q[x]) ans[i]=q(1,i,1,m,rt[x]);
}
int main() {
	n=read();m=read();
	F(i,1,n) a[i]=read();
	F(i,2,n) {
		int x=read(),y=read();
		G[x]+=y;uG[y]+=x;
	}
	F(i,1,m) {
		int op=read(),x=read();
		if(op==1) {
			st[x]=i;
		} else if(op==2) {
			mo(st[x],i-1,a[x],1,m,rt[x]);st[x]=0;
		} else Q[x]+=i,Q[0]+=i;
	} F(x,1,n) if(st[x]) mo(st[x],m,a[x],1,m,rt[x]);
	d(1);for(int i:Q[0]) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：lzqy_ (赞：4)

赛时所有做法都是在线的，但题解做法实际上是离线的/qd/qd

以下是验题的思路。

---------

首先先把操作离线。

考虑对于一个节点 $x$ 与能到达 $x$ 的点集 $S$（**不包含 $x$ 子树内能到达 $x$ 的点**），上儿子的子树 $T$ 会对 $S$ 产生贡献，而 $S$ 不会对 $T$ 产生贡献；$S$ 会对下儿子的子树 $T'$ 产生贡献，而 $T'$ 不会对 $S$ 产生贡献。

也就是说，两种儿子，一个没有后效性，一个没有前效性。

所以考虑采用类似于二叉树中序遍历的方式去处理整棵树：

- 遍历到 $x$ 时，$x$ 的线段树中含有能到达它的节点（**在子树外的**）的信息。

- 先遍历上儿子，将上儿子的信息合并至 $x$（遍历上儿子的时候不需要传 $x$ 线段树的信息，因为上儿子没有前效性）。

- 然后用此时 $x$ 线段树的信息更新 $x$ 处询问的答案。

- 接着再遍历下儿子。遍历下儿子时，直接将 $x$ 的信息全盘下传即可（`rt[v]=rt[x]`）。

## 时间复杂度分析

由于所有元素都是向上合并的，所以依然可以用线段树合并的方式分析复杂度。

发现该算法与普通线段树合并的唯一区别在于该题有区间修改。通过标记永久化的技巧，可以将关键元素个数控制在 $\log$ 级别。因此时间复杂度是 $O(n\log^2n)$ 的。

----------

upd：不过金牌爷说整个过程可以通过势能分析降到单 $\log$。

--------

## 代码

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define il inline
using namespace std;
const int maxn=200010;
const int N=maxn*500;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x; 
}
struct edge{
	int v,w,to;
}e[maxn<<1];
int head[maxn],ecnt;
void addedge(int u,int v,int w){
	e[++ecnt].v=v,e[ecnt].w=w;
	e[ecnt].to=head[u],head[u]=ecnt;
}
vector<pair<int,int> >v[maxn];
vector<int>q[maxn];
int a[maxn],ans[maxn],n,m,cnt;
int lz[N],d[N],ls[N],rs[N],rt[maxn],L[maxn];
il void Copy(int i,int j){d[j]=d[i],lz[j]=lz[i],ls[j]=ls[i],rs[j]=rs[i];}
int merge(int a,int b,int l,int r){
	if(!a||!b) return a|b;
	int k=++cnt;
	lz[k]=lz[a]+lz[b];
	if(l==r) return k;
	int mid=l+r>>1;
	if(mid>=l) ls[k]=merge(ls[a],ls[b],l,mid);
	if(mid<r) rs[k]=merge(rs[a],rs[b],mid+1,r);
	d[k]=max(d[ls[k]]+lz[k],d[rs[k]]+lz[k]);
	return k;
}
void Add(int &i,int l,int r,int L,int R,int x){
	Copy(i,++cnt),i=cnt;
	if(l>=L&&r<=R){
		lz[i]+=x,d[i]+=x;
		return ;
	}int mid=l+r>>1;
	if(mid>=L) Add(ls[i],l,mid,L,R,x);
	if(mid<R) Add(rs[i],mid+1,r,L,R,x);
	d[i]=max(d[ls[i]]+lz[i],d[rs[i]]+lz[i]);
}
int Query(int i,int l,int r,int L,int R,int s=0){
	if(l>R||r<L) return 0;
	if(!i||(l>=L&&r<=R)) return s+d[i];
	int mid=l+r>>1;
	return max(Query(ls[i],l,mid,L,R,s+lz[i]),Query(rs[i],mid+1,r,L,R,s+lz[i]));
}
void dfs(int fa,int x){
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa&&!e[i].w)
			dfs(x,e[i].v),rt[x]=merge(rt[x],rt[e[i].v],1,m);
	for(int i=0;i<v[x].size();i++)
		Add(rt[x],1,m,v[x][i].first,v[x][i].second,a[x]);
	for(int i=0;i<q[x].size();i++)
		ans[q[x][i]]=Query(rt[x],1,m,1,q[x][i]);
	for(int i=head[x];i;i=e[i].to)
		if(e[i].v!=fa&&e[i].w)
			rt[e[i].v]=rt[x],dfs(x,e[i].v);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		addedge(x,y,1),addedge(y,x,0);
	}
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		if(x==2) v[y].push_back(mp(L[y],i)),L[y]=0;
		else if(x==1) L[y]=i;
		else q[y].push_back(i);
	}
	for(int i=1;i<=n;i++)
		if(L[i]) v[i].push_back(mp(L[i],m));
	memset(ans,-1,sizeof(ans));
	dfs(0,1);
	for(int i=1;i<=m;i++)
		if(~ans[i]) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：lateworker (赞：2)

// 虽然看了题解，但并不妨碍我写一篇题解。主要谈谈我对线段树合并，及数据结构题的理解。

## 思路

首先，我们要明确，这是一道数据结构题。

本题给了一棵有根有向树，以及两个修改操作，查询历史最值。显然，一个点的修改会沿着树，贡献给树上其它点。这个贡献不是双向的，所以树链剖分并不好做。

重新审视本题，不难发现，所有操作都有两个关键的约束条件：时间、树上位置。既然在线不好做，我们不妨考虑离线，先维护时间，再维护树上位置。从时间的角度看：

- 两个修改操作，实际上就是将一段时间内的代价（伤害值）提高了 $a_x$，即区间加；
- 查询操作，实际上是询问一段时间内的伤害最值，即区间最大值。

由此不难想到用线段树维护，树上每个结点，开一棵**以时间为下标**的线段树。至于树上位置，套路地，用线段树合并维护即可，本题可以按照树上有向边的拓扑序合并。

实际上，数据结构题一般会有很多约束条件，例如时间、位置、数值等等。所谓在线算法，是一种特殊的、**优先考虑时间条件**的离线算法。

## 实现

本题的关键，在于实现一棵，标记永久化+区间加+区间最大值+线段树合并 的动态开点线段树。区间加区间最大值的标记永久化写法，可参见zkw线段树的维护。其实就是： `u.max = u.tag + max(lc.max + rc.max)`

根据线段树的 Leafy 特性，合并时，叶结点可以直接把最大值相加，但是非叶结点不行。因为，两棵树的对应叶结点，一定是同一个点；但是，非叶结点的最值，可能是从两棵树的**不同位置**的叶结点贡献上来的，位置不同代表时间不同，不能直接合并。最后，记得把每个结点的懒标记相加合并。

另外，每次合并时，要把并向的那棵树可持久化出来，新建一个版本再合并。原因是：如果你把 $root[v]$ 并向 $root[u]$，相当于让两棵树共用了一些结点。（这是线段树合并的代码实现所导致的）这个时候，如果更改了 $root[u]$，就有可能反向影响到 $root[v]$。考虑一拓扑排序，$a,b,c,d$ 四个点之间存在 $a\rightarrow c, b\rightarrow c,a\rightarrow d$ 三条有向边，不难构造出一组拓扑序 $a, b, d, c$，在合并不使用可持久化的情况下，使得 $d$ 在出队时已经受到 $b\rightarrow c$ 合并的影响。（此时 $a,b,d$ 共用一部分线段树结点）这就是所谓的“存在复用”。

合并时，遇到空树是不需要新建版本的，我们只关心存在的结点复用问题。这一点可以自行画图理解。

附上自己理解用的一张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/2mozyyd6.png)

## 代码

本人喜欢用指针线段树实现动态开点，这样免去了数组的嵌套。存在轻微压行。

```cpp
#include <bits/stdc++.h>
#define C__ const
#define int long long
using namespace std;
C__ int N_ = 2e5 + 10;
struct SegT {
	int ma, tag;
	SegT *le, *ri;
	SegT(); SegT(int ma, int tag, SegT* le, SegT* ri): ma(ma), tag(tag), le(le), ri(ri) {}
} _null(0, 0, &_null, &_null), *null = &_null; // 建立一个空结点null，相当于普通线段树的st[0]，其左右子结点也都是null
SegT::SegT() { ma = tag = 0, le = ri = null; } // 所有结点的左右儿子都指向null，防止遇到nullptr炸掉
SegT pool[N_ * 40]; int psz;
SegT* node(int ma = 0, int tag = 0, SegT* le = null, SegT* ri = null) {
	pool[++psz] = SegT(ma, tag, le, ri);
	return pool + psz;
}
SegT* copy(SegT* u) {
	pool[++psz] = *u;
	return pool + psz;
}
void pushup(SegT* u, int l, int r) {
	if (l == r) return;
	u->ma = u->tag + max(u->le->ma, u->ri->ma);
}
void update(SegT*& u, int l, int r, int L, int R, int V) {
	if (u == null) u = node();
	if (L <= l && r <= R) return u->ma += V, u->tag += V, void();
	int mid = (l + r) >> 1;
	if (L <= mid) update(u->le, l, mid, L, R, V);
	if (mid < R) update(u->ri, mid + 1, r, L, R, V);
	pushup(u, l, r);
}
int query(SegT* u, int l, int r, int L, int R) {
	if (u == null) return 0;
	if (L <= l && r <= R) return u->ma;
	int mid = (l + r) >> 1;
	if (R <= mid) return u->tag + query(u->le, l, mid, L, R);
	if (mid < L) return u->tag + query(u->ri, mid + 1, r, L, R);
	return u->tag + max(query(u->le, l, mid, L, R), query(u->ri, mid + 1, r, L, R));
}
SegT* merge(SegT* u, SegT* v, int l, int r) {
	if (u == null) return v;
	if (v == null) return u;
	u = copy(u); // 先复制一份，在新的结点上做修改
	if (l == r) return u->ma += v->ma, u->tag += v->tag, u;
	int mid = (l + r) >> 1;
	u->le = merge(u->le, v->le, l, mid);
	u->ri = merge(u->ri, v->ri, mid + 1, r);
	u->tag += v->tag;
	return pushup(u, l, r), u;
}
SegT *root[N_];
int n, m, a[N_], b[N_], deg[N_], qpsz, ans[N_];
vector<int> g[N_];
vector<pair<int, int> > qset[N_];
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) root[i] = null;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v), ++deg[v];
	}
	for (int i = 1; i <= m; i++) {
		int op, u;
		cin >> op >> u;
		if (op == 1) b[u] = i;
		if (op == 2) update(root[u], 1, m, b[u], i - 1, a[u]), b[u] = 0;
		if (op == 3) qset[u].push_back(make_pair(i, ++qpsz));
	}
	for (int u = 1; u <= n; u++)
		if (b[u]) update(root[u], 1, m, b[u], m, a[u]), b[u] = 0;
	queue<int> que;
	for (int u = 1; u <= n; u++)
		if (deg[u] == 0) que.push(u);
	while (!que.empty()) {
		int u = que.front(); que.pop();
		for (auto [tim, idx] : qset[u])
			ans[idx] = query(root[u], 1, m, 1, tim);
		for (int v : g[u]) {
			root[v] = merge(root[v], root[u], 1, m);
			--deg[v]; if (deg[v] == 0) que.push(v);
		}
	}
	for (int i = 1; i <= qpsz; i++) cout << ans[i] << "\n";
	return 0;
}
```

后记：这是本人写的第一道黑题，也是第一篇黑题题解。感觉并不难想，也不难写。~~说不定哪天就降紫了~~

---


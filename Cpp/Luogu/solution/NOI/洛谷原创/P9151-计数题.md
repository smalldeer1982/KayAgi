# 计数题

## 题目背景

[Easy Counting Problem](https://atcoder.jp/contests/agc022/tasks/agc022_e)

> 身のうさを思ひしらでややみなまし そむくならひのなき世なりせば

## 题目描述

给定长度为 $N$ 的 $01$ 串 $S$，你可以做若干个操作，形如将长度为 $3$ 的子串变成它们的中位数（注意是变成一个数字），问可以得到多少个不同的串。

答案对 $998244353$ 取模。

## 说明/提示

**【样例解释】**

可以证明，$1001$ 仅能通过操作获得串 $10,01,1001$ ，因此样例第一组数据的答案为 $3$。

---

**【数据范围】**

对于 $100 \%$ 的数据，满足 $1\le N \le 5\times {10}^6$，$S_i\in\{0,1\}$，$1 \le T \le 5$。

| 子任务 | $N \le$ | 特殊性质 | 分数 |
| - | - | - | - |
| 1 | $10$ | | $5$ |
| 2 | $50$ | | $10$ |
| 3 | $300$ | | $10$ |
| 4 | $2000$ | | $15$ |
| 5 | | A | $5$ |
| 6 | | B | $5$ |
| 7 | ${10}^5$ | | $20$ |
| 8 | | | $30$ |

特殊性质 A：保证 $S_i=0$。

特殊性质 B：保证 $S_{2k}=0$、$S_{2k+1}=1$。

**字符串下标的编号从 $1$ 开始。**

## 样例 #1

### 输入

```
4
1001
111000
101010
111000101010
```

### 输出

```
3
7
3
25
```

# 题解

## 作者：C1942huangjiaxu (赞：12)

题目中的操作可以看做：

+ 选择 2 个相邻的不同的数并删除。
+ 选择 3 个相邻且相同的数，删掉其中 2 个。

那么最终对答案有贡献的 $T$ 一定是 $S$ 的子序列。

考虑构建这样一个自动机，每个点 $i$ 有 $0,1$ 两条出边，出边 $c$ 连向**最小的** $j\gt i,S_j=c$ 满足 $S[i+1,j-1]$ 可以被删除的位置 $j$。   

假如 $S[j+1,n]$ 可以被删除，那么所有起点为 $0$ 终点为 $j$ 的路径都是一个答案。

但这样不够，我们还要证明，每一个答案串 $T$ 都可以被自动机匹配上。

考虑构建自动机的过程其实是一个贪心的过程，我们只要证明， **$\forall i\lt j$ 满足 $S_i=S_j$ 且 $i,j$ 奇偶性相同，那么对于所有 $k$ 满足 $S[j+1,k]$ 可以被删除，则 $S[i+1,k]$ 可以被删除。**

证明也很简单，**只要证明 $S[i+1,j]$ 可以删除**，先把 $S[i+1,j-1]$ 删到只剩下一个数 $c$，然后删除 $c$ 和 $S_j$ 即可。

自动机的边数是 $O(n)$ 的，我们只要建出这个自动机就行了。

以 $S_i=0$ 为例，出边 $j$ 一定满足 $i,j$ 奇偶性不同，下面只考虑奇偶性与 $i$ 不同的位置是否满足条件。

对于 $c=1$ 的出边，找到第一个 $S_j=1$ 即可，中间显然能删完。

对于 $c=0$ 的出边，上面已经说明了，若 $S_{j-1}=0$ 则 $S[i+1,j-1]$ 可以被删除，所以找到第一个 $j$ 满足 $S_j=S_{j-1}=0$ 的 $j$。

我们要证明所有 $k\lt j,S_k=0$，$S[i+1,k-1]$ 都不可以删完。

首先 $S[i+1,k-1]$ 中不存在连续的 $3$ 个 $0$，我们把连续的 $1$ 也都删除到不超过 $2$ 个，那么相当于是一个 $1$,$0$,$11$,$00$ 交替序列，并且序列的开头和末尾都是 $1$ 段。

注意到**不存在奇偶不同的 $p,q$ 满足 $S_p=S_{p+1}=S_q=S_{q+1}=0$**，否则 $j$ 不是第一个，那么，**删除过程中始终会是一个满足不存在 $p,q$ 的 $1$,$0$,$11$,$00$ 交替序列**。

证明考虑归纳：

删除过程中产生 $1$ 段的合并，直接贪心把个数减小到不超过 $2$。

删除过程中产生 $0$ 段的合并，**因为不存在 $p,q$ ，即不存在 $00100$ 串**，所以一定是 $2$ 个 $0$ 的合并，设原先的串为 $10xx01$，我们删除了 $xx$，$xx$ 是 $01$ 或 $10$ 。    
可以发现，不论 $xx$ 是什么，删除后的 $00$ 串奇偶性与原先的 $00$ 串奇偶性相同，仍然不存在 $p,q$。

因为 $1$ 段个数比 $0$ 段多 $1$，所以最后剩下的一定是 $11$，即 $S[i+1,k-1]$ 不能被删除。

时间复杂度 $O(n)$。

代码很好写：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5,P=998244353;
int T,n,f[N],nx[N][2],to[N][2],ans;
char s[N];
inline void Add(int &x,int y){
	if((x+=y)>=P)x-=P;
}
void solve(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;++i)f[i]=0,s[i]-=48;
	f[1]=1;
	for(int i=3;i<=n;i+=2)if(s[i]!=s[1]&&s[i]==s[i-1]){
		f[i]=1;
		break;
	}
	for(int i=1;i<3;++i)for(int j=0;j<2;++j)nx[n+i][j]=to[n+i][j]=n+1;
	for(int i=n;i;--i){
		nx[i][0]=nx[i+2][0],nx[i][1]=nx[i+2][1];
		to[i][0]=to[i+2][0],to[i][1]=to[i+2][1];
		nx[i][s[i]]=i;
		if(i<n&&s[i]==s[i+1])to[i][s[i]]=i+1;
	}
	ans=0;
	for(int i=1;i<=n;++i)if(f[i]){
		Add(f[nx[i+1][s[i]^1]],f[i]);
		Add(f[to[i][s[i]]],f[i]);
		if(!(n-i&1)&&(s[i]==s[n]||to[i][s[i]]<=n))Add(ans,f[i]);
	}
	printf("%d\n",ans);
}
int main(){
	scanf("%d",&T);
	while(T--)solve();
	return 0;
}
```

---

## 作者：Rosaya (赞：7)

### 题意

[P9151 计数题](https://www.luogu.com.cn/problem/P9151)

个人很喜欢这种题，不失思考的乐趣。

思路构建 $\text{with}$ [$\text{Solystic}$](https://www.luogu.com.cn/user/61088)。

### 思路

考虑操作的性质，每次是相邻三个变为中位数。

也就是说最后得到的字符串中的每一个字符都是由一段区间操作得来的。

为了答案不计算重复，我们让最后得到的字符串每一个字符对应的区间尽量靠前匹配，这样每一个字符串都能被一个状态唯一对应。

具体的，记 $f_i$ 表示贪心匹配 $1 \sim i$ 中字符得到的字符串数量。

比如样例 $111000$ 中的 $f_4$ 包含字符串 $10$，因为 $111$ 可以操作得到 $1$，$0$ 可以操作得到 $0$，而且这组匹配是尽量靠前的。

现在我们考虑如何转移，记 $c$ 表示下一位要转移的字符，为了仍满足贪心策略，我们需要找到最小的 $j>i$ 使得 $[i+1,j]$ 能操作得到字符 $c$，并有 $f_j \leftarrow f_i$。

而计算答案时，我们需要知道 $[i+1,n]$ 中的字符能不能操作没（实际上不能操作没，至少留一个，这么写只是方便大家理解），也就是 $[i,n]$ 能不能操作变成 $s_i$，随后 $ans \leftarrow f_i$。在上面的例子中，因为 $000$ 可以操作变成 $0$，所以 $f_4$ 的所有答案都能取得，并且 $f_4=2(10,1110)$。

现在我们只需要知道如何判定 $[l,r]$ 能否操作变成 $c$，因为 $c=0,1$ 是对称的情况，我们只考虑 $c=0$，另一种情况可以通过所有值取反来处理。

因为操作是取中位数，所以我们要尽可能的让序列中的 $0$ 多，$1$ 少，多余连续 $2$ 个 $1$ 可以操作一次减少 $2$ 个 $1$。

我们考虑 $l \sim r$ 顺次加入，维护一个栈，这个栈仅有栈顶最多两个值为 $1$。

若新加入的字符是 $1$，则加入后判断栈顶是否为 $111$，若是则弹出 $11$。

若新加入的字符是 $0$，则加入后判断栈顶是否为 $10$，若是则弹出 $10$。

最后进需要判断栈的大小是否是奇数并且 $1$ 的个数是否严格少于 $0$ 的个数即可，复杂度 $O(n)$。

这个做法的正确性比较容易感性理解，具体正确性说明如下。

首先，在栈底的 $0$ 可以随时与在栈顶的 $1$ 匹配消去，所以留到最后再匹配最优，因为后续操作中栈顶可能会 $111$ 弹出 $11$，这种方式是最符合 $0$ 多 $1$ 少的策略的，最后匹配的方式是在 $0,1$ 分界线弹出 $01$，所以就是谁多剩谁。

其次，在出现 $111$ 时直接弹出是最符合策略的，而在出现 $10$ 时直接弹出是考虑到无论下一位字符是 $0$ 还是 $1$，对它们操作一次都等效于直接弹出 $10$，而且弹出栈顶堆积的 $0$ 有利于底部被压住的 $1$ 与后面的 $1$ 相遇，从而以 $111$ 的方式弹出，也是符合策略的。

举个例子，$01100$ 如何操作变成 $0$，首先前三个字符直接加入变成 $011$，在加入下一个 $0$ 时看到 $10$ 弹出，变为 $01$，最后一位同理，变为 $0$。构造方案就是考虑消去 $10$ 时若栈不为空考虑跟上一项一起操作，否则等下一项进栈时再操作。

这个部分代码如下：

```cpp
inline bool check2(int pos,int val)
{
    hd=0;
    
    for(int i=pos;i<=n;i++)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=2&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;
    }

    return ((pos&1)==(n&1))&&(hd-(hd&&q[hd]==1)-(hd>1&&q[hd-1]==1)>(hd&&q[hd]==1)+(hd>1&&q[hd-1]==1));
}
```


这个策略在判定后缀时是正确的，但是其实在前面贪心时是错误的。

还是原来的例子，$111000$，我们发现 $f_4$ 其实不会计入 $10$，因为 $1$ 在 $f_1$ 中计入，而 $[2,4]$ 是 $110$，确实不能操作成为 $0$，所以我们需要改良一下。

我们发现改良的思路其实是前一位的字符可以充当 $111$ 最开头的 $1$，而且不会被消去，所以我们直接在开头加入到栈中即可。需要注意的一点是，这个字符不应该被消去，也就是说我们不应该弹出最开头的 $10$ 将栈弹空。

这样我们可以把判定和贪心找最靠前的位置结合到一起，具体的，第一位是 $s_{i-1}$，也就是说若栈大小为 $2$ 且 $q_2=0$ 则说明当前位置 $j$ 满足 $[i+1,j]$ 可以操作为 $0$，直接返回位置即可。

这个部分代码如下：

```cpp
inline int check1(int pos,int val)
{
    hd=0;
    
    for(int i=pos;i<=n;i++)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=3&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;
        if(hd==2&&q[hd]==0)
            return i;
    }

    return n+1;
}
```

我们需要注意 $s_1$ 的前一位也就是 $s_0$ 不应该操作，也就是说我们需要将它赋值为一个毫不相干的数（或者 $s_1$ 取反，比较推荐这个，因为好优化）。

从这个函数中我们可以看出若 $[i,j],[i,k]$ 都能操作成 $0$，并且 $j$ 是最靠前的那个，则操作 $[i,k]$ 贪心到 $j$ 时栈里仍是仅有 $s_{i-1}$ 和 $0$，所以 $[i,k]$ 可行说明 $[j,k]$ 可行，这样也就说明了贪心匹配可以不重不漏的计数。

具体代码如下：

```cpp
inline void work()
{
    cin>>(s+1);
    n=strlen(s+1);

    ans=0;
    for(int i=0;i<=n;i++)
        f[i]=0;

    f[0]=1,s[0]='0'+((s[1]-'0')^1);
    for(int i=1;i<=n;i++)
    {
        int p=check1(i-1,0);
        f[p]=(f[p]+f[i-1])%mod;
        p=check1(i-1,1);
        f[p]=(f[p]+f[i-1])%mod;
        if(check2(i,s[i]-'0'))
            ans=(ans+f[i])%mod;
    }

    cout<<ans<<'\n';
}
```

复杂度 $O(n^2)$，```check2``` 函数是卡满的，所以只能拿 $40$ 分。

考虑优化这个算法，首先对于后缀的判断可以倒序加数优化，$vis_{i,0/1}$ 表示 $[i,n]$ 是否能操作成 $0/1$，代码如下：

```cpp
inline void sol(int val)
{
    hd=0;

    for(int i=n;i;i--)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=2&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;

        vis[i][val]=(hd&1)&&(hd-(hd&&q[hd]==1)-(hd>1&&q[hd-1]==1)>(hd&&q[hd]==1)+(hd>1&&q[hd-1]==1));
    }
}
```

仅加上这个优化，会多过几个点，也就是说 ```check1``` 函数跑的不是很满，但是仍需要优化。

我们发现贪心时的这个栈不会很大。第 $1$ 位是 $s_{i-1}$，第 $2$ 位若是 $0$ 则找到了最靠前的位置，结束算法，所以第 $2$ 位只能为 $1$，同理，第 $3$ 位若为 $0$，则 $10$ 会匹配消去，所以第 $3$ 位也只能为 $1$，第 $4$ 位不管为 $0$ 还是 $1$ 都会消去，所以集合大小最多为 $3$。

具体的，集合内的数其实只有 $5$ 种情况（算上找到位置结束是 $6$ 种），我们按如下方式编号，$\Delta$ 表示找到最靠前的位置。

```
delta: 00 & 10
+0 = none
+1 = none
0: 0
+0 = delta
+1 = 2
1: 1
+0 = delta
+1 = 3
2: 01
+0 = 0
+1 = 4
3: 11
+0 = 1
+1 = 1
4: 011
+0 = 2
+1 = 2

```

这样的话，我们记 $g_{i,X}$ 表示加入 $s_i$ 之前栈的情况为 $X$ 的最靠前的位置的编号，则加入 $s_i$ 之后栈的情况会变为 $X'$，若 $X'=\Delta$ 则 $g_{i,X} \leftarrow i$，否则 $g_{i,X} \leftarrow g_{i+1,X'}$，倒序转移即可做到 $O(n)$。

加一些取模优化可以增加效率，具体实现细节看代码。

有不理解的地方可以在博客或者讨论区问我本人。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int mod=998244353;

int _,n,hd,ans;
int f[5000005],g[5000005][5],h[5000005][2],q[5000005];
bool vis[5000005][2];
char s[5000005];

inline void update(int &x,int y)
{
    x+=y;
    if(x>=mod)
        x-=mod;
}

inline int check(int pos,int val)
{
    hd=0;
    
    for(int i=pos;i<=n;i++)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=3&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;
        if(hd==2&&q[hd]==0)
            return i;
    }

    return n+1;
}

inline void sol(int val)
{
    hd=0;

    for(int i=n;i;i--)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=2&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;

        vis[i][val]=(hd&1)&&(hd-(hd&&q[hd]==1)-(hd>1&&q[hd-1]==1)>(hd&&q[hd]==1)+(hd>1&&q[hd-1]==1));
    }

    g[n+1][0]=g[n+1][1]=g[n+1][2]=g[n+1][3]=g[n+1][4]=n+1;

    for(int i=n;i;i--)
    {
        if((s[i]-'0')^val)
        {
            g[i][0]=g[i][4]=g[i+1][2];
            g[i][1]=g[i+1][3];
            g[i][2]=g[i+1][4];
            g[i][3]=g[i+1][1];
        }
        else
        {
            g[i][0]=g[i][1]=i;
            g[i][2]=g[i+1][0];
            g[i][3]=g[i+1][1];
            g[i][4]=g[i+1][2];
        }

        h[i][val]=g[i][(s[i-1]-'0')^val];
    }
}

inline void work()
{
    cin>>(s+1);
    n=strlen(s+1);

    for(int i=0;i<=n;i++)
        f[i]=0;
    ans=0,f[0]=1,s[0]='0'+((s[1]-'0')^1);
    sol(0),sol(1);

    for(int i=1;i<=n;i++)
    {
        update(f[h[i][0]],f[i-1]);
        update(f[h[i][1]],f[i-1]);
        if(vis[i][s[i]-'0'])
            update(ans,f[i]);
    }

    cout<<ans<<'\n';
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>_;

    while(_--)
        work();

    return 0;
}
```

---

## 作者：Crescent_Rose_ (赞：5)

这里是对一种已有做法（就是洛谷题解区第一篇题解的做法）的一些详细解释。

珂怕人类智慧结论题。

需要先仔细读题理解。中位数是说排序后的中间；不是三个一起赋值而是变成一个数；（如果两边都还有）两边拼起来。

建议在纸上写写画画辅助理解。

## 明确自动机结构

首先注意到要算本质不同的串的个数，尝试建立自动机，在自动机上统计路径数。注意到生成的串是原串的子序列，这启发我们建立类似子序列自动机的结构。

$3$ 个数的中位数但只有 $0$ 和 $1$，于是相当于取更多的那个。发现多的那个至少 $2$ 个，且由鸽巢原理至少有一个在边上。这启发我们去删除另两个。构造两种删除操作：

- 对于 $3$ 个相邻相同的数，删除其中 $2$ 个。对应 $000,111$。
- 对于（相邻 $3$ 个数中）$2$ 个相邻不同的数，删除它们。对应 $110,001,100,011,101,010$。

发现它们对应且仅对应 $3$ 个数形成的这 $8$ 种情况，这说明这样的构造是可行的。

这也给我们的自动机提供了思路：$1$ 到 $n$ 每个位置作为一个结点，走到这个结点的边的边权（字符）为这个点上的数；每个点 $i$ 连向点 $j>i$，要求 $[i+1,j-1]$ 可以用上述两种操作删空（或本来就是空的）。

要在这个自动机上统计路径数，就要求每条路径和每个串一一对应，那么一个点连出同样字符的边最多一条。直接的想法是对每个点的每个“多边”字符新建一个点，让原先的点以该字符连向它，再将它连向 原先的点以此字符连向的所有点 连向的所有点；从后往前构建。（这样的正确性存疑）

然而可以不这样。我们尝试证明这个自动机有子序列自动机的某种性质（贪心）：不需要新建那个点，把原先的点连向的最近的点作为那个“新建的点”即可（对每个字符仅保留到最近的点的边）。也就是说最近的点要一步连向其他被忽略的点一步连向的点。

这里写一个显然的性质：一段能被删除的区间一定由偶数个点构成，那么自动机上相连的两点奇偶性一定不同。

于是写出命题：$\forall i,j,k$，满足 $i<j<k$ 且 $[j+1,k-1]$ 可被删除 且 $S_i=S_j$ 且 $(j-i)\bmod2=0$，那么 $[i+1,k-1]$ 也可被删除。

证明：先删除 $[j+1,k-1]$。接下来要删除 $[i+1,j]$，将 $[i+1,j-1]$（奇数个点）删除到只剩一个点，由于 $S_i=S_j$，不论这个点是 $0$ 还是 $1$ 都可以将它和 $j$ 一起删掉。

其中用了一个结论：一个奇数长度的区间一定可以被删为一个点。

证明：一旦有连续 $\leq 3$ 个相同的数就删到连续 $\leq 2$ 个，没有这样的就删除相邻的不同数；一开始有奇数个，每次删两个，一直保持奇数个；只要有不同的就可以继续删，只要有连续 $\leq 3$ 个相同的也可以继续删，于是直到只有 $\leq 2$ 个才会停止，而始终保持个数为奇数，所以最终只剩下 $1$ 个。

于是我们现在证明了自动机结构的正确性。

## 构建自动机

现在的问题是如何构建自动机。

显然 $0,1$ 等价（对称），于是这里仅考虑 $S_i=0$，看 $i$ 如何向后连边，记 $c$ 为边 $i\to j$ 上的字符。又因为 $i\to j$ 中 $i,j$ 奇偶性不同，这里仅考虑和 $i$ 奇偶性不同的 $j$（默认满足此条件）。

- 对于 $c=1$ 的出边，从左往右考虑每个 $S_j=1$。
	- 因为 $[i+1,j-1]$ 长度为偶数且 $S_i=0$，第一个 $S_j=1$ 的 $j$ 就是合法的（此时 $[i+1,j-1]$ 中不会有连续的 $1$，一个 $1$ 前面必定是 $0$，那就把它们删掉。剩下的是偶数个连续的 $0$，又有 $S_i=0$，于是可以把这偶数个 $0$ 都删掉）。
- 对于 $c=0$ 的出边，从左往右考虑每个 $S_j=0$。
	- 发现一个结论：若 $[l,r]$ 长度为偶数且 [ $S_l=0$ 或 $S_r=0$ ] 且 [ $S_{l-1}=0$ 或 $S_{r+1}=0$ ]，则 $[l,r]$ 可以被删除。
	- 证明（对于 $S_l=S_{l-1}=0$ 的情况，另 $3$ 种同理）：先删 $[l+1,r]$（长度为奇数）直到只剩下一个数，然后不论它是 $0$ 还是 $1$ 都能删掉它和 $l$。
	- 于是最靠左的 $j$ 满足 $S_j=S_{j-1}=0$ 是可行的（充分）。但还没说明它是最靠左的可行点。
	- 那么就要说明它左边的都不行，即 $\forall k<j$ 且 $S_k=0$，$[i+1,k-1]$ 不能被删空。
	- 证明：
		- 首先有 $S_{k-1}=S_{i+1}=1$（形如“$0[1\ldots1]0$”），那么 $1$ 的段数一定比 $2$ 的段数多 $1$。
		- 考虑各种删除方式，发现除了删除当前区间边界的情况，无论怎么删都要么两个段数都不变，要么两个段数都减 $1$；那这样是不能删空的。
		- 再考虑区间边界被删除的情况。要让 $0$ 的段数相对 $1$ 的段数增加，就要让区间两端 $1$ 的段被删而被删的 $0$ 所在的段没被删。
		- 为了拼尽全力（可能算贪心）实现这个目的，我们一旦遇到 $\geq3$ 个连续的 $1$ 就删到 $\leq2$ 个。然而 $0$ 的段长度不超过 $2$，且 $00$ 段的结尾不能和 $i$ 奇偶性不同（否则违背 $j$ 是最靠左的满足那个限制的点）。当前你要让 $1$ 的段减少且 $0$ 的段不变只能在区间开头将 $100$ 的 $10$ 删除，或在结尾将 $001$ 的 $01$ 删除。但这两种情况都违背了这条对奇偶性的限制。也就是说这样的两种 $00$ 都不会在初始情况中存在。
		- 那会不会里面删除后的拼接致使左边的 $10$ 接上一个 $0$ 呢？那就是左侧为 $101001\ldots$ 这种样子（$1011001\ldots$ 和 $10101\ldots$ 都没法把更靠右的那两个或一个 $0$ 接过来）。但同样由于奇偶性的限制，更靠右的那两个 $0$ 不能共存。于是你只能继续写成 $10101\ldots$，递归下去继续处理。但一直都有奇偶性的限制，于是无法在左边完成任务。右边同理。这里是左右分开分析的，合起来也不可能在左 或/和 右完成任务。
		- 于是我们证明了这个 $j$ 就是 $i$ 的 $c=0$ 边要连向的点。

总结一下，对于 $i$：

- $c=S_i$ 的边连向 $\min j$ 满足 $j>i,(j-i)\bmod2=1,S_j=S_{j-1}=c$。
- $c\neq S_i$ 的边（另一条边）连向 $\min j$ 满足 $j>i,(j-i)\bmod2=1,S_j=c$。

于是你可以直接写一个 DP，$f_{i,0/1}$ 表示 $\min j, j\geq i,j\equiv i{\pmod2},S_j=S_{j-1}='0'/'1'$，$g_{i,0/1}$ 表示 $\min j, j\geq i,j\equiv i{\pmod2},S_j='0'/'1'$。没有满足条件的 $j$ 时统一赋值为 $n+1$，$f$ 在 $i=1$ 时 $j$ 不考虑 $i$。从 $i+2$ 转移而来。

那么 $i$ 的出边就分别连向 $f_{i+1,S_i-'0'},f_{i+1,(S_i-'0')\oplus1}$，为 $n+1$ 就表示没有这条出边。

## 在自动机上 DP

构建完自动机，我们考虑如何 DP。转移是显然的（计算路径数），关键是初值和答案。

设 $dp_i$ 表示以结点（位置）$i$ 结尾的路径条数。转移就是传统的 DAG 上路径数统计。

我们并没有给自动机建立空的出发结点，也并未建立终止结点。这是因为上面自动机连边的结论建立在被删除区间两边都有数的前提下，而位置 $0$ 和 $n+1$ 上并没有数。也正因为此，我们需要仔细考虑 DP 的初值和答案。

初值：
- 考虑将位置 $0$ 作为起点，为两个字符分别寻找起点。我们回到关于连边最初的想法，要找夹着的那段能被删（或为空）的点。$0$ 上面没有数并不会对那个子序列的性质造成任何影响，即我们仍可以搬用上面的结论，只取最近的点。
- 首先 $1$ 一定作为一个字符的起点（它和 $0$ 夹着的段为空），那么另一个字符的起点就要从 $3$ 开始继续向后寻找。$0$ 上面没有数同样不会造成影响，与上面的结论同理，我们取最靠左的 $j$ 满足 $j\geq3,j \bmod 2 = 1,S_j=S_{j-1},S_j\neq S_1$ 即可。

答案：
- $i$ 能更新答案当且仅当 $[i+1,n]$ 可被删除。
- 那首先要求 $i,n$ 奇偶性相同（就保证了 $[i+1,n]$ 长度为偶数）。
- 若 $S_i=S_n$，则由“构建自动机”中的结论，$[i+1,n]$ 可以删空。
- 若 $S_i\neq S_n$，则可以将 $[i+1,n]$ 删空当且仅当 $i$ 存在自动机上字符为 $S_i$ 的出边。证明（记这条出边连向 $j$）：
	- 充分性：先将 $[i+1,j-1]$ 删空。接下来要删 $[j,n]$（长度为偶数），且 $S_j\neq S_n$。一定可以先将 $[j+1,n-1]$（长度为偶数）删到只剩 $2$ 个数（证明类似长度为奇数的区间一定可以删到只剩一个数），然后分类讨论这 $2$ 个数（$0001,0011,0101,0111$），发现每种情况都可以删空。当然也可以在删除 $[i+1,j-1]$ 后把 $[j,n]$ 接到 $i$ 后面，然后利用 $S_i=S_j$ 来套用“构建自动机”中的结论。
	- 必要性：证明逆否命题：若没有这条出边则无法将 $[i+1,n]$ 删空。我们在 $n+1$ 处强行填一个 $S_i$，$n+1$ 与 $i$ 奇偶性不同。由于 $S_{n+1}\neq S_{n}$，前面又不能有满足条件的出边，那就可以搬用“构建自动机”中的结论，说明在 $n+1$ 上填 $0$ 的情况下 $[i+1,n]$ 无法删空。填了 $0$ 不会变得更难删空，于是在 $n+1$ 上没有数时更是无法删空。

## 总结

理解题目想干什么，难点在哪里，从而摸清思考的方向。

多画多写。

神秘操作可以先转换一下。

对于满足某种限制的本质不同子序列的计数，不妨建立类似子序列自动机的自动机。

扩展一下，对于满足某种限制的本质不同字符串的计数，也不妨建立对应的自动机。

## 代码

```cpp
#include <bits/stdc++.h>
#define gc getchar
using namespace std;
int rd() {
	int x = 0, f = 1; char c = gc();
	while(c < '0' || c > '9') { if(c == '-') f = (- 1); c = gc(); }
	while(c >= '0' && c <= '9') { x = x * 10 + (c - '0'); c = gc(); }
	return (x * f);
}
const int N = 5000000, P = 998244353;
int n;
int a[N + 1], nx1[N + 1][2], nx2[N + 1][2], f[N + 1];
string s;
inline void add(int & x, int y) { x = x + y >= P ? x + y - P : x + y; }
void Solve() {
	cin >> s; n = ((int)s.size()); s = "0" + s;
	for(int i = 1; i <= n; ++ i) f[i] = 0; // 多测清空
	for(int i = 1; i <= n; ++ i) a[i] = s[i] - '0';
	f[1] = 1;
	for(int i = 3; i <= n; i += 2) { if(a[i] != a[1] && a[i] == a[i - 1]) { f[i] = 1; break; } }
	nx1[n + 1][0] = nx1[n + 1][1] = nx2[n + 1][0] = nx2[n + 1][1] = nx1[n + 2][0] = nx1[n + 2][1] = nx2[n + 2][0] = nx2[n + 2][1] = n + 1;
	for(int i = n; i >= 1; -- i) {
		nx1[i][0] = nx1[i + 2][0]; nx1[i][1] = nx1[i + 2][1];
		nx2[i][0] = nx2[i + 2][0]; nx2[i][1] = nx2[i + 2][1];
		nx1[i][a[i]] = i;
		if(i > 1 && a[i] == a[i - 1]) nx2[i][a[i]] = i;
	}
	int ans = 0;
	for(int i = 1; i <= n; ++ i) {
		if(nx1[i + 1][a[i] ^ 1] <= n) add(f[nx1[i + 1][a[i] ^ 1]], f[i]);
		if(nx2[i + 1][a[i]] <= n) add(f[nx2[i + 1][a[i]]], f[i]);
		if(((n - i) & 1) == 0 && (a[i] == a[n] || nx2[i + 1][a[i]] <= n)) add(ans, f[i]);
	}
	printf("%d\n", ans);
}
int main() {
	int T = rd();
	while(T --) Solve();
	return 0;
}
// 参考：
// https://www.luogu.com.cn/article/n4ytnmoj
// https://shijiuwan.github.io/P9151/
// https://www.cnblogs.com/zltzlt-blog/p/18047850
```

## 参考

- https://www.luogu.com.cn/article/n4ytnmoj
- https://shijiuwan.github.io/P9151/
- https://www.cnblogs.com/zltzlt-blog/p/18047850

2025.5.6 & 2025.5.7

---

## 作者：Kubic (赞：5)

先考虑如何判断 $0$ 是否为好的。

显然 $|S|$ 必须是奇数。

我们将 $0$ 看作分隔符，构建一个新的序列 $a$，依次表示相邻两个 $0$ 之间 $1$ 的数量。

将操作放在 $a$ 上考虑，可以得到以下三种操作：

- 选择 $i\in [1,|a|]$，满足 $a_i\ge 3$，并 $a_i\leftarrow a_i-2$。

- 选择 $i\in [1,|a|-1]$，满足 $a_i+a_{i+1}\ge 1$，并将 $a_i$ 和 $a_{i+1}$ 合并为 $a_i+a_{i+1}-1$。

- 选择 $i\in [2,|a|-2]$，满足 $a_i=a_{i+1}=0$，并将 $a_i$ 和 $a_{i+1}$ 删除。

我们的目标是使得 $|a|=2$ 且 $a_1=a_2=0$。

如果 $a_i\ge 3$，我们一定会不断进行操作直到 $a_i\le 2$。此时 $a$ 中只剩下 $0,1,2$。

如果 $a_i=1$，那么它和相邻元素合并时相当于是将它 $a_i$ 删除。因此我们可以先把 $a$ 中所有 $1$ 删除。此时 $a$ 中只剩下 $0,2$。

接下来我们一定是要尽量多地合并相邻的 $2$。

如果存在相邻两个 $2$，那么把它们合并起来之后会得到一个 $3$，进行第一种操作之后变为 $1$。而 $1$ 又可以直接删除。因此这种操作相当于将相邻两个 $2$ 直接删除。

最后我们要使用 $0$ 和 $2$ 进行合并。通过类似的分析可以得到这种操作相当于将相邻的 $0,2$ 直接删除。因此我们要求 $0$ 至少比 $2$ 多两个，这样才能在操作完成之后保留下来两个 $0$。

综上，我们得到了一种快速判断 $S$ 是否能变为 $0$ 的方法。

考虑如何判断一个 $01$ 序列 $T$ 是否为好的。

为了方便计数，我们需要设计一个只维护少量信息，并且支持每次往 $T$ 后面加入一个数，并判断当前的 $T$ 是否为好的。

设 $f_{i,0/1}$ 左端点为 $i$ 的区间中，能够变为 $0/1$ 的最小的右端点。

维护一个 $t$ 表示 $S_{1\dots t}$ 能够变为当前的 $T$。

一个比较基本的想法是：如果加入了一个 $x$，那么 $t\leftarrow f_{t+1,x}$。

但这显然是有问题的，例如 $S=0001,T=01$ 时就无法正确判断。

我们可以分析什么时候可能会出问题。

不妨设当前加入的是 $0$，下一个加入的是 $x$。设变为当前这个 $0$ 的区间为 $[t+1,t_1]$，变为 $x$ 的区间为 $[t_1+1,t_2]$。

- 如果 $x=0$，那么根据之前的计算方法可以得到，一定可以将 $t_1$ 调整为 $f_{t,0}$，并且不影响方案合法性。

- 如果 $x=1$，那么此时 $t_1$ 就不一定能调整为 $f_{t,0}$ 了。因为此时让 $t_1$ 增大一些可能是对 $[t_1+1,t_2]$ 更优的决策。

那么我们考虑 $t_1$ 要增大到什么程度。考虑以 $t_1+1$ 为起点的一段连续的 $0$，设为 $[t_1+1,p]$。

- 如果 $p-t_1$ 为奇数，那么这一段 $0$ 在 $[t_1+1,t_2]$ 的计算过程中会变为一个 $a$ 中的 $1$。因此只扩展到 $p$ 是没有收益的。我们可以 $t_1\leftarrow p+1$ 递归处理。

- 如果 $p-t_1$ 为偶数，那么这一段 $0$ 在 $[t_1+1,t_2]$ 的计算过程中会变为一个 $a$ 中的 $0$ 或 $2$。可以证明，直接 $t_1\leftarrow p$ 一定是一种最优策略。

根据上面这个过程，我们可以得到一个很好的结构来判断 $T$ 是否为好的。

具体来说，先依次加入 $T$ 中前 $|T|-1$ 个数，然后判断 $S_{t+1\dots n}$ 是否能够变为 $T_{|T|}$ 即可。

只需要利用这个结构 dp 即可。直接实现是 $O(n^2)$ 的，容易优化到 $O(n)$。

参考代码（$O(n^2)$）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000005
#define MOD 998244353
int n,ans,z[N][2],z1[N][2],dp[N][2];bool o[N][2];char a[N];
void W(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;}
int main()
{
	scanf("%s",a+1);n=strlen(a+1);dp[0][0]=dp[0][1]=1;
	for(int i=1,t,t1,t2,t3;i<=n;++i) for(int j=0;j<2;++j)
	{
		t1=t2=t3=0;
		for(int k=i;k<=n;++k)
		{
			if(a[k]-48==j) {if(!t1) t3+=1-t2,t2=0;else if(t1==2) t2^=1;t1=0;}
			else {++t1;if(t1>2) t1=1;}if(k-i&1) continue;
			t=t3;if(!t1) t+=1-t2;else if(t1==1) t-=t2;else t-=t2^1;
			if(t>1) {if(!z[i][j]) z[i][j]=k;if(k==n) o[i][j]=1;}
		}t1=0;
		for(int k=i;k<=n;++k) if(a[k]-48==j) t1^=1;
			else if(!t1) {z1[i][j]=k-1;break;}else t1=0;
	}
	for(int i=0,t;i<n;++i)
	{
		t=z[i+1][0];if(t) {W(dp[t][0],dp[i][0]);t=z1[t+1][0];if(t) W(dp[t][1],dp[i][0]);}
		t=z[i+1][1];if(t) {W(dp[t][1],dp[i][1]);t=z1[t+1][1];if(t) W(dp[t][0],dp[i][1]);}
		if(o[i+1][0]) W(ans,dp[i][0]);if(o[i+1][1]) W(ans,dp[i][1]);
	}printf("%d\n",ans);return 0;
}
```

---

## 作者：hgckythgcfhk (赞：3)

考虑一段长为 $3$ 的区间，操作后换成一个数，一个显然的性质是这个数一定在区间中出现过，所以可以得出，所有可能的答案一定是一个子序列，同时，长度为 $3$ 的区间有两个数相等，这两个相等的数必有一个是区间端点，所以可以钦定留下某个端点，于是发现多次对几个相邻的位置操作相当于把一个区间合并成一个数。

以 $0$ 为例，一个区间能合并成 $0$，的充分条件是区间内有连续两个 $0$，或者两个端点都是 $0$，这个条件同时也是必要的，因为如果不满足，那拼尽全力也只能合并到 $10101\dots$ 这种形式，由于保证了端点不都是 $0$，所以端点必有一个 $1$，由于只有奇数长的区间能合并，每次合并删两个数不影响奇偶性，所以不可能一个 $0$ 一个 $1$，所以这种形式一定合不出 $0$。

根据操作的性质不难得出 $01$ 是本质相同的，所以一个区间能合并成 $1$ 的充要条件和 $0$ 的差不多，类比一下就好了。

同时我们根据上面的证明注意到一个事情，奇偶性是很重要的，所以我们下面的过程都需要考虑爆不爆奇偶性是否等价。

我们钦定相等的子序列只要最左的，同一个子序列也只要最左的划分方案，这样保证不重，这个说法不太严谨，但后面 dp 的过程会自动帮我们处理掉。

考虑合法的子序列的性质，首先必须把起点前和重点后的扔掉，那当且仅当奇偶性爆掉起点的值与 $s_1$ 相等，终点也一样，这里不能管有两个相等的数相邻的情况，因为这样相当于换了起点，会算重。

设 $dp_i$ 表示把当前位置作为终点，并且假装后面没有数，也就是假装 $n=i$ 的方案数，为了满足上面的两个最左，我们只能往最小可以转移的位置转移，以 $0$ 为例，想让这个位置合成 $0$ 去接下一段，要找到一个位置 $j$ 满足 $s_j=0,s_{j-1}=0$ 或者 $s_j=0$，这是直接根据上面的条件翻译出来的，但实际上显然只需要 $s_j=0$，也就是找下一个和当前位置相等且奇偶性不爆的位置，如果想合出来一个 $1$，那就必须找下一个连续两个 $1$ 且后面那个不爆的位置。

为了防止算重，只对第一个合法的起点初始化，前面说过起点和终点的合法条件了，不做赘述，最后统计所有合法终点处的答案即可。

至于那两个条件，随便拿桶维护一下就行，或者可以用数据结构硬做，反正是能做的

这个题其实不难，但是我感觉已有的题解说的都太高级了，虽然这说明写题解的人很强，但我看不懂，我觉得也还会有很多人看不懂，所以写一篇题解。

说句闲话，@sjkmvdtjvc 场上没看到括号里的字，浪费了一个小时才发现自己做过这个题，所以认真读题是很重要的，大家不要像它一样糖糖的，由于我并不在 LCA 那里，所以直接贺它场上过了的程序，~主要是在 WHK，手机扣题解太折磨了~。

```cpp
#include <bits/stdc++.h>
#define il inline
#define rg register
#define cit const rg unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),freopen("B.in","r",stdin),freopen("B.out","w",stdout)
#define int rg unsigned
#define void il void
#define ll long long
#define lll __int128
#define ull unsigned ll
#define db double
#define vector basic_string
#define pq priority_queue
#define vint vector<unsigned>
#define vll vector<ll>
#define vull vector<ull>
#define ump unordered_map
#define ust unordered_set
#define deq deque
#define mkp make_pair
#define pii pair<unsigned,unsigned>
#define pll pair<ull,ull>
#define fi first
#define se second
#define Bool(a,n) bitset<n>a
#define sca(a) for(int $=0;$<n;cin>>a[++$])
#define cle(a) memset(a,0,sizeof a)
#define tmx(a) memset(a,0x3f,sizeof a)
#define tmn(a) memset(a,0xbf,sizeof a)
#define tif(a) memset(a,0xff,sizeof a)
#define ge getchar_unlocked()
#define pu putchar_unlocked
//#define max(a,b) ((a)>(b)?(a):(b))
//#define min(a,b) ((a)<(b)?(a):(b))
//#define abs(a,b) ((a)>(b)?(a)-(b):(b)-(a))
#define fls cout<<endl;
#define PP pop_back()
#define PS push
#define BK back()
#define SZ size()
inline ll max(const rg ll a,const rg ll b){return a>b?a:b;}
inline ll min(const rg ll a,const rg ll b){return a<b?a:b;}
inline ll abs(const rg ll a,const rg ll b){return a>b?a-b:b-a;}
//il ull rd(){int ll s=0;int char c=ge;while(c<48||c>58)c=ge;while(c<59&&c>47)s=s*10+(c&0b1111),c=ge;return s;}
//void wt(int ll x){if(!x){pu(48);return;}static unsigned char c[10];int char s=0;while(x)c[++s]=x%10,x/=10;while(s)pu(c[s--]|48);}
//il ll rd(){rg ll s=0,f=1;int char c=ge;while(c<48||c>58)c=='-'?f=-1:0,c=ge;while(c<59&&c>47)s=s*10+(c&0b1111),c=ge;return s*f;}
//void wt(rg ll x){if(!x){pu(48);return;}if(x<0)pu('-'),x=-x;static unsigned char c[10];int char s=0;while(x)c[++s]=x%10,x/=10;while(s)pu(c[s--]|48);}
using namespace std;constexpr unsigned N=5e6+10,M=1e3+1;constexpr ll inf=1e9;
//unsigned p;
constexpr unsigned p=998244353;
//constexpr unsigned p=1e9+7;
/**/
namespace mod{
	void add(int&a,cit b){a+=b,a>=p?a-=p:0;}
	void sub(int&a,cit b){add(a,p-b);}
	il unsigned mul(cit ll a,cit ll b){return a*b%p;}
	il unsigned pw(int ll a,int b){int ll s=1;for(;b;b>>=1,a=a*a%p)b&1?s=s*a%p:0;return s;}
	il unsigned inv(cit a){return pw(a,p-2);}
	void div(int&a,cit b){a=mul(a,inv(b));}}
using mod::add;
using mod::sub;
using mod::mul;
using mod::inv;
using mod::pw;
/**/
unsigned a[N][2],b[N][2],dp[N],n;
char s[N];
void init(){cle(a),cle(b),cle(dp),cle(s);
	cin>>s+1,n=strlen(s+1);
	for(int i=1;i<=n;++i)s[i]&=0b11;dp[1]=1;
}
void solve(){init();
	for(int i=3;i<=n;i+=2)if((s[i]^s[1])&&s[i]==s[i-1]){dp[i]=1;break;}
	for(int i=1;i<3;++i)for(int j=0;j<2;++j)a[n+i][j]=b[n+i][j]=n+1;
	for(int i=n;i;--i){for(int j=0;j<2;++j)
		a[i][j]=a[i+2][j],b[i][j]=b[i+2][j];
		a[i][s[i]]=i;if(i<n&&s[i]==s[i+1])b[i][s[i]]=i+1;
	}int ans=0;for(int i=1;i<=n;++i)if(dp[i]){
		add(dp[a[i+1][s[i]^1]],dp[i]),add(dp[b[i][s[i]]],dp[i]);
		if(!(n-i&1)&&(s[i]==s[n]||b[i][s[i]]<=n))add(ans,dp[i]);
	}cout<<ans<<'\n';
}signed main(){open;int t=1;cin>>t;
	while(t--)solve();}

```

---

## 作者：syzf2222 (赞：3)

# Median Replace

给定长度为 $n$ 的 01 序列 $a$，你可以做若干次操作形如把长度为三的子串变成中位数，问可以变成多少个不同的序列。答案对 `998244353` 取模。

$n \le 10^6$

---

### 题解

我们令原串为 $S$，生成的串为 $T$，让我们来考虑对给定的 $S$，是否能生成 $T$。

把 $T$ 分为几个极长的连续相同子串，那么每个 $T$ 的串就对应 $S$ 的一个区间。

如果我们可以选出 $S$ 的若干个不交子串，两个串中间可以空偶数个位置不选，分别把它们交错变成 $0$ 段和 $1$ 段，拼接成 $T$，那么 $S$ 串也可以变成 $T$。

于是我们有这样的 dp：令 $dp_{i,0/1}$ 表示已经使用了 $S$ 的前 $i$ 个位置，上一段是 $0/1$，可以构造多少不同的序列。

转移考虑枚举接下来接长度为多少的串，并选择一个长度最短的前缀接上。

令 $f_{i,j,0}$ 表示为了制造一个长度为 $j$ 的 $0$ 串，需要选取多长的以 $i$ 开头的串。即：
$$
dp_{i,0}\to dp_{f_{i+2k,j,0},1}
$$
（其中 $k$ 为满足 $f_{i+2k,j,0}$ 最小的 $k$，且是偶数。）

暴力的求解每个 $f_{i,j}$，至少可以做到 $O(n^3)$。

让我们来关注如何快速求解这个问题。

如果 $f_{l,a} =x (a \ge 1)$，我们考虑快速计算 $f_{l,a+1}$ 的值。

可以证明 —— 只需找到一个最小的整数 $k$ 满足 $S_{x+2k}=S_{x+2k+1}=0$，我们就有 $f_{l,a+1}=x+2k+1$。

这样就能进行快速的转移了。在此不赘述具体的转移，总复杂度 $O(n)$，可以通过。

---


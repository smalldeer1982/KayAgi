# 橙垒球

## 题目描述

垒球很喜欢一个叫迷你某·萨菲克斯的题，并且很崇拜这题的出题人，所以出了个差不多的题。

给定一个长度为 $n$ 的序列 $a_1,\ldots,a_n$，请构造一个**字典序最大**的长度为 $n$ 的字符串 $w$，使得：

- $w$ 的每个字符是 $1$ 到 $n$ 的整数，字符的大小顺序为 $1$ 最小 $n$ 最大；

- $w$ 的长度为 $i$ 的前缀的**字典序最大的后缀**长度恰为 $a_i$。

请输出这样的 $w$，或报告无解。

本题单个测试点包含多组数据。

## 说明/提示

**【样例解释】**

字符串 $1,2,3$ 的每个前缀的最大后缀长度恰好为 $1,1,1$，且是满足这个条件的字典序最大的字符串。

字符串 $2,3,3$ 的每个前缀的最大后缀长度恰好为 $1,1,2$，且是满足这个条件的字典序最大的字符串。

不存在一个字符串，每个前缀的最大后缀长度恰好为 $1,1,3$。

字符串 $2,2,3$ 的每个前缀的最大后缀长度恰好为 $1,2,1$，且是满足这个条件的字典序最大的字符串。

不存在一个字符串，每个前缀的最大后缀长度恰好为 $1,2,2$。

字符串 $3,3,3$ 的每个前缀的最大后缀长度恰好为 $1,2,3$，且是满足这个条件的字典序最大的字符串。

---

**【评分方式】**

每个测试点的分数等于其中所有测试数据分数的最小值。一个测试数据的分数由以下方式确定：

如果你的输出格式错误（即不符合输出格式的要求），则不能得分。

否则，如果你正确判定了是否有解（即在无解的数据输出 $-1$，有解的数据输出了 $n$ 个 $[1,n]$ 中的数），则可以获得 $20\%$ 的分数。

在此基础上，如果该测试点无解，或者有解且你输出的是一组合法解（未必是字典序最大的），则可以再获得 $30\%$ 的分数。

在此基础上，如果该测试点无解，或者有解且你输出的是字典序最大的解，则可以再获得 $50\%$ 的分数。

---

**【数据范围】**

对于全部数据：$1\leq T\leq 10000$，$1 \le n \le 4 \times 10 ^ 6$，$\sum n\leq 4\times 10^6$，$1\leq a_i\leq i$。

|     子任务编号     |  $\sum n\leq$  | 特殊性质 | 分值 |
| :----------------: | :------------: | :------: | :--: |
| $\text{Subtask 1}$ | $4\times 10^6$ | 保证无解 | $1$  |
| $\text{Subtask 2}$ | $4\times 10^5$ | 保证有解 | $29$ |
| $\text{Subtask 3}$ | $4\times 10^6$ |    无    | $70$ |

---

**【提示】**

请使用较快速的输入输出方式。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/5ofelxu1.png)

## 样例 #1

### 输入

```
6
3
1 1 1
3
1 1 2
3
1 1 3
3
1 2 1
3
1 2 2
3
1 2 3
```

### 输出

```
1 2 3
2 3 3
-1
2 2 3
-1
3 3 3
```

# 题解

## 作者：ix35 (赞：12)

## 橙垒球

定义 $Suf(i)$ 表示（$w$ 的）以 $i$ 开头的后缀。

我们首先将字典序反转，那么最大后缀就变成了最小的不是其他后缀的前缀的后缀。

**定义 1**：若 $w$ 小于它的所有真后缀，则称 $w$ 是 Lyndon 串；若 $v$ 是 Lyndon 串且 $w=v^kv'$，其中 $v'$ 为 $v$ 的前缀，则称 $w$ 是近似 Lyndon 串；若 $v$ 是 Lyndon 串且 $w=v^k$，则称 $w$ 是 Necklace。

**定义 2**：定义一个后缀 $Suf(k)$ 是 Significant Suffix，当且仅当存在一个 $v$ 使得 $Suf(k)+v=\min_i(Suf(i)+v)$。

---

考虑 Duval 算法求最大后缀，不难发现 $w$ 的最大后缀就是 Duval 算法第一次运行完 $w$ 的末尾时对应的近似 Lyndon 串，同时它是 $w$ 的最长的 Significant Suffix。

设 $a_i=1,\ a_{i+1}=p>1$，于是：$w[1\ldots i]$ 是近似 Lyndon 串，$w[p\ldots i+1]$ 也是近似 Lyndon 串。

模拟 Duval 算法可知，$w[p\ldots i]$ 是 $w[1\ldots i]$ 的前缀（也可以根据 Significant Suffix 的结构发现），同时下一个字符 $w_{i-p+2}$ 必须大于 $w_{i+1}$（否则 $a_{i+1}$ 也等于 $1$ 了））。

由于我们现在希望字典序最小，所以最佳的选择就是让 $w_{i-p+2}$ 比 $w_{i+1}$ 恰好大 $1$，而后面的部分 $w[i-p+3\ldots i]$ 可以重复前面的模式 $w[1\ldots i-p+2]$ 进行循环。由于 $w[p\ldots i+1]$ 是近似 Lyndon 串，所以把它的最后一个字符增大 $1$ 得到一定就是 Lyndon 串，于是 $w[1\ldots i]$ 确实是一个 Lyndon 串的若干次方加上一个前缀，符合近似 Lyndon 串的要求。

大致结构如下（每种颜色是一个字符，$+1$ 表示比对应颜色字符恰好大 $1$ 的字符）：

![](https://cdn.luogu.com.cn/upload/image_hosting/kt6r70bk.png)

但是上面的只是一种情况，如果 $w[1\ldots p-1]$ 不能表示成若干个完整的循环，那么就会出问题：Duval 算法加入 $w_{i+1}$ 后会把前面的完整循环截断，但是并不会恰好截到 $p$ 这个位置。为了让它恰好截到 $p$ 这个位置，我们可以让 $w_{p-1}$ 增大 $1$，这样一来前缀 $w[1\ldots p-1]$ 自成一个 Lyndon 串，截断时自然会把它截去。

大致结构如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ge7d9him.png)

考虑何时会无解：如果 $w[1\ldots p-1]$ 比 $w[p\ldots i+1]$ 还要短，那么第一个循环都没办法完全填完，这时就会无解（这个结论有另外两种理解：一种是 Duval，由于截断后保留的是前一段 Lyndon 因子的前缀，所以截掉的长度一定大于一半；另一种是 Significant Suffix，$w[1,i]$ 和 $w[p,i]$ 都是 Significant Suffix，因此前者的长度大于后者的两倍）。

如果我们构造完了后缀 $Suf(p)$，就可以利用上面的方法得到 $w[1\ldots p-1]$，同时由于 $w[1\ldots p-1]$ 的前缀是 $w[p\ldots i+1]$，所以最小化 $w$ 就等价于最小化 $w[p\ldots |w|]$，优化目标一样，所以可以直接递归后缀 $Suf(p)$。当然，这和从后往前贪心是等价的。

时间复杂度为 $O(n)$。

---

## 作者：unputdownable (赞：10)

记 $l_i=i-a_i+1$，即 $i$ 处最大后缀的起始下标。

记 $|s|$ 为字符串 $s$ 的长度。

记 $s_{l,r}$ 为字符串 $s$ 从 $l$ 到 $r$ 的子串。

称字符串 $x$ 严格大于 $y$ 当且仅当 $x>y$ 且 $y$ 不是 $x$ 的前缀，这意味着 $\forall z,x+z>y+z$，严格小于同理。 

--------

首先可以推出 $l_i\leq l_{i+1}$。

考虑任何一个前缀 $s_{1,i}$，$s_{l_i,i}$ 是其最大后缀。

因为较长串永远不可能是较短串的前缀，所以 $\forall p<l_i$ 都有 $s_{p,i}$ 严格小于 $s_{l_i,i}$。

那么在 $i$ 往后推的时候，$s_{p,i}+s_{i+1,j}$ 永远小于 $s_{l_i,i}+s_{i+1,j}$，$l_i$ 也就不可能递减了。

--------

若 $l_i<l_{i+1}$，记  $p=l_i$，$q=l_{i+1}$。

如果 $i<q$（$p=l_{i+1}=i+1$），那么有 $s_q>s_p$，这个情况是简单的，中间的空白地带后面再说。

有 $s_{p,i}>s_{q,i}$，$s_{p,i+1}<s_{q,i+1}$，两个字符串的大小关系在加一个字符后发生改变，

这意味着 $s_{q,i}$ 是 $s_{p,i}$ 的前缀（即 $s_{p,i}>s_{q,i}$ 并不是严格大于关系）；

![](https://cdn.luogu.com.cn/upload/image_hosting/59v0mgb7.png)



上图两段蓝色字符串相等，且 $s_{p+(i+1-q)}<s_{i+1}$。

至于 $p+(i+1-1)$ 和 $q$ 中间的空白地带，暂且先不讨论，不过如果只要构造一个合法解的话，全部填 $1$（最小值）显然是合法的。

--------

你发现刚刚画的两段相等的字符串是没有交集的，然而还有有交集的情况。

1. 如果 $q=p+(i+1-q)$，那么有 $s_{i+1}>s_{p+(i+1-q)}=s_q$，此时你发现 $s_{i+1,i+1}>s_{q,i+1}$，与 $l_{i+1}$ 的定义矛盾了。
2. 如果 $q<p+(i+1-q)$， 此时 $s_{p,q}$ 拥有一个长度大于一半的 $\text{border}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/ktiruakl.png)  

![](https://cdn.luogu.com.cn/upload/image_hosting/3duk7ind.png)

你发现 $s_{2q-p,i+1}>s_{q,i+1}$，所以也是不合法的。

--------

最后来讨论 $q=l_{i+1}=i+1$ 时 $s_{p,i}$ 或者 $p+(i+1-1)$ 和 $q$ 中间的空白地带的填法（令 $l_{n+1}=n+1$，则最后一段也是情况一）。

![](https://cdn.luogu.com.cn/upload/image_hosting/59v0mgb7.png)

记 $t$ 为被唯一限制偏序关系的那个位置，情况一时 $t=p$（此时有 $s_p<s_q$），情况二时 $t=p+(i+1-1)$。

因为要字典序最大，所以在情况二那个相等的前缀确定以后，那个红色的字符要贪心取最大，即 $s_{t}=s_{i+1}-1$。

考虑字符串 $s_{p,i}$，此时问题变成给定一个字符串的一段前缀和一段后缀，要求填充字符串满足题意。

字典序最大等价于从前往后贪心取最大。

所以 $s_{t+1}$ 取到其最大值 $s_p$（如果大于 $s_p$ 这个后缀就比原串更大了）;

然后 $s_{t+2}$ 必须要小于等于 $s_{p+1}$（考虑后缀 $s_{t+1,i}$，并且有 $s_p \geq s_{p+1}$）$\dots$

类似与 $\text{runs}$ 一样的结构，一直推到 $s_{q-1}$。

$q$ 及以后就是被给定的后缀了。

但是如果 $s_{q-1}$ 取到它的最大值， $s_q$ 及以后还有一堆偏序关系需要满足。  

如果 $s_{q-1}$ 取最大值减一，那么 $s_q$ 及以后就不需要满足由后缀 $s_{t+1,i}$ 带来的偏序关系。

直接暴力检查 $s_q$ 及以后的偏序关系是否满足，决定 $s_{q-1}$ 是否需要减一即可。

事实上 $s_{q-1}$ 不需要减一当且仅当 $s_{p,q-1}$ 是若干个整周期。

--------

**Code：**

```c++
inline void work() {
    n=read();
    for(int i=1; i<=n; ++i) st[i]=i-read()+1;
    for(int i=1; i< n; ++i) if(st[i]>st[i+1]) return puts("-1"),void();
    int LL=n+1; s[n+1]=n+1;
    for(int i=n; i>=1; ) {
        int L=st[i],l=i; 
        while(st[l-1]==st[i]) --l;
        if(i<LL) for(int u=L; u<=i; ++u) s[u]=s[LL]-1;
        else {
            int len=i-LL+1;
            if(L+len>=LL) return puts("-1"),void();
            for(int u=0; u<len; ++u) s[L+u]=s[LL+u];
            s[L+len]=s[LL+len]-1;
            for(int u=L+len+1; u<LL; ++u) s[u]=s[u-len-1];
            for(int u=LL; u<=i; ++u) if(s[u]>s[u-len-1]) {
                --s[LL-1];
                break;
            }
        }
        LL=L,i=l-1;
    }
    for(int i=1; i<=n; ++i) write(s[i]),putchar(" \n"[i==n]);
}
```



---


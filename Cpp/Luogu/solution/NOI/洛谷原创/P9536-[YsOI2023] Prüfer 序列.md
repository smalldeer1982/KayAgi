# [YsOI2023] Prüfer 序列

## 题目背景

Ysuperman 模板测试的计数题。

众所周知，Prüfer 序列几乎没有在正赛中出现过，所以它需要出现在洛谷月赛中。

## 题目描述

众所周知，一棵 $n$ 个点的有标号无根树与他的 Prüfer 序列一一对应。如果你不知道 Prüfer 序列指的是什么，可以参考下面提示说明中对 Prüfer 序列的解释。

现在给你一个长度为 $m$ 的正整数序列 $a$，其中 $a_i\in[1,n]$。等概率随机选择这个序列的一个长度为 $n-2$ 的子序列（只要选择下标不同就认为两个子序列不同）作为 Prüfer 序列构造得到一棵树 $T$，对于所有 $1\le i<n$，你需要求出 $\mathrm{dist}(i,n)$ 的期望（$\mathrm{dist}(u,v)$ 定义为 $u,v$ 两点简单路径的边数）。

答案对 $10^9+7$ 取模。

## 说明/提示

#### 对 Prüfer 序列的解释

对于一棵给定的无根有标号树，Prüfer 序列的构建过程如下：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n-2$ 次后就只剩下两个结点，此时记录下来的那个序列就是这棵无根有标号树的 Prüfer 序列。

我们可以证明，一棵结点数量大于 $1$ 的无根有标号树和一个 Prüfer 序列是一一对应的，并且任意一个长度为 $n-2$ 每个数取 $[1,n]$ 范围内的整数的 Prüfer 序列都有唯一对应它的树，所以同样的，我们也可以根据一个 Prüfer 序列还原出一棵树。

有关 Prüfer 序列更加详细的内容，你可以参考 [OI wiki 上关于 Prüfer 序列的描述](https://oi-wiki.org/graph/prufer/)。

#### 样例 1 解释

共有三种等可能选择的子序列：$2,4$，$2,3$，$4,3$。

1. $2,4$ 对应的树为一条链 $1-2-4-3$，其中 $1,2,3$ 与 $4$ 的距离分别为 $2,1,1$。
2. $2,3$ 对应的树为一条链 $1-2-3-4$，其中 $1,2,3$ 与 $4$ 的距离分别为 $3,2,1$。
3. $4,3$ 对应的树为一条链 $1-4-3-2$，其中 $1,2,3$ 与 $4$ 的距离分别为 $1,2,1$。

所以 $\mathrm{dist}(1,4)$ 期望为 $(2+3+1)/3=2$，$\mathrm{dist}(2,4)$ 期望为 $(1+2+2)/3=5/3\equiv 666666673\pmod{10^9+7}$，$\mathrm{dist}(3,4)$ 期望为 $(1+1+1)/3=1$。

#### 样例 2 解释

仅有一种可能的子序列 $4,6,5,2$，对应的树为一条链 $1-4-5-2-6-3$，$1,2,3,4,5$ 与 $6$ 的距离依次为 $4,1,1,3,2$，即为答案。

#### 数据范围

本题共 $20$ 个测试点：

|测试点编号|$n$|$m$|
|:-:|:-:|:-:|
|$1$|$=4$|$=6$|
|$2$|$=8$|$=15$|
|$3$|$=10$|$=20$|
|$4$|$=10$|$=50$|
|$5$|$=10$|$=200$|
|$6$|$=10$|$=1000$|
|$7$|$=10$|$=1750$|
|$8$|$=10$|$=2500$|
|$9$|$=11$|$=500$|
|$10$|$=11$|$=1000$|
|$11$|$=12$|$=250$|
|$12$|$=12$|$=375$|
|$13$|$=12$|$=400$|
|$14$|$=13$|$=80$|
|$15$|$=13$|$=120$|
|$16$|$=13$|$=160$|
|$17$|$=13$|$=200$|
|$18$|$=14$|$=60$|
|$19$|$=14$|$=90$|
|$20$|$=15$|$=40$|

另外，对于所有数据，保证 $1\le a_i\le n$。

**请注意，前 $19$ 个测试点空间限制为 $512\rm{MB}$，最后一个点空间限制为 $150\rm{MB}$。**

## 样例 #1

### 输入

```
4 3
2 4 3
```

### 输出

```
2 666666673 1```

## 样例 #2

### 输入

```
6 4
4 6 5 2```

### 输出

```
4 1 1 3 2```

## 样例 #3

### 输入

```
10 12
6 9 2 10 1 5 5 9 10 7 8 3
```

### 输出

```
585858594 60606064 8080810 834343444 638383846 785858595 913131322 595959602 286868692```

# 题解

## 作者：xiaolilsq (赞：15)

考虑 Prüfer 序列构造树的过程，从前往后扫过整个序列，记录当前度数为 $1$ 的点集 $S$，以及已经被删除的点集 $T$，每次如果遇到数 $x\not\in (S\cup T)$，那么就将 $S$ 中最小值连上 $x$，然后删除 $S$ 中的最小值将其加入 $T$，而 $x$ 则可能可以加入 $S$ 也可能不加入 $S$，序列扫完后必然 $|S|=1,|T|=n-2$，这时 $S$ 中唯一的数就会连上 $n$。

于是可以如此 dp，设 $f(i,j,S,T)$ 表示考虑 $i\sim m$ 这个序列中的子序列为最后一段，$S,T$ 为上面描述的两个点集，其中 $j$ 与 $n$ 距离的总和以及方案数。按照上面转移 $O(1)$，且 $S\cap T=\varnothing$，所以复杂度为 $O(3^nnm)$。

考虑 Prüfer 序列具体构造过程是如何从 $O(n\log n)$ 优化到 $O(n)$ 的，类似的，优化掉 $3^n$，用一个集合 $L=S\cup T$，那么实际上 $S$ 就是 $L$ 的一个后缀加上最多前面一个新加的点，所以可以将 $3^n$ 优化到 $2^nn^2$，时间复杂度复杂度优化为 $O(2^nn^3m)$。

但是我们发现如果当且 dp 要求的是 $j$ 与 $n$ 的距离，那么我们唯一关心的就是 $j$ 连出去的父亲，所以如果新加的点如果不是 $j$ 那么我们其实完全不关心它具体是谁，于是一个 $n$ 可以被优化为一个 $01$ 储存的状态，即 $S$ 中当前最小的点是否恰好为 $j$，于是时间复杂度优化为 $O(2^nn^2m)$，可以通过所有数据。

---

## 作者：Purslane (赞：1)

# Solution

省流就是，这题 $90$ 分有手就行，$100$ 分需要一点技术。

显然这题是以 $n$ 为根的 Prufer 序列。

考虑用 Prufer 序列建树过程，实际上维护了两个集合 $S$ 和 $T$，表示可以用的零度点集合与已经用过的零度点集合。

每次从 $S$ 中取出最小的数扔到 $T$ 里，如果当前的数已经是零度点了就扔进 $S$ 中。（零度点指的是儿子的个数。）

在 $n-1$ 次流程之后，有 $S = \varnothing$ 以及 $T=\{1,2,\cdots,n-1\}$（注意 $S$ 应该是 $\{n\}$，不过 $n$ 只有最后一刻才会进去，所以直接不管他）。

将 $(S,T)$ 当做状态处理一下。由于 $S \cap T = \varnothing$ 所以一共只有 $O(3^n)$ 种。

那你的 DP 应该怎么设计呢。如果正着 DP，你维护 $S$ 和 $T$，还要维护初始的点以及这个点当前的最浅祖先。而倒着 DP，我们可以知道当前点最终的祖先一定是 $n$。

所以你设 $dp_{i,S,T,j}$ 表示考虑了 $i$ 以后的序列，进行操作之前两个集合分别是 $S$ 和 $T$，最终所有合法的子序列中 $j$ 到 $n$ 的距离之和，以及方案数（方案数和 $j$ 无关，单独拉出来可以降低常数。）。采取 $i \to i+1$ 的填表法，就可以在 $O(3^nnm)$ 的复杂度内完成本题。

注意到构建 Prufer 序列的时候，$S$ 必定是 $S \cup T$ 的一段后缀加上至多一个散点，所以实际上 $(S,T)$ 只有 $2^nn^2$ 种，只保留有用的就可以做到 $O(2^nn^3m)$。

这是代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2500+10,MOD=1e9+7;
int n,m,a[MAXN],ans[MAXN],p3[MAXN],C[MAXN][MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=1ll*ans*base%MOD;
		base=1ll*base*base%MOD,p>>=1;
	}
	return ans;
}
vector<int> ot[(1<<15)+10];
int dy[(1<<15)-1];
int dp1[2][3000000+10],dp2[2][3000000+10][15];
pair<int,int> DY[3000000+10];
int main() {
	freopen("du.in","r",stdin);
	freopen("du.out","w",stdout); 
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,0,m) {C[i][0]=1;ffor(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;}
	ffor(i,1,m) cin>>a[i];
	p3[0]=1;ffor(i,1,n) p3[i]=p3[i-1]*3;
	ffor(i,0,(1<<n-1)-1) {
		int S=0;
		ffor(j,1,n-1) if(i&(1<<j-1)) dy[i]+=p3[j-1];
		else S|=(1<<j-1);
		for(int s=S;s;s=(s-1)&S) ot[i].push_back(s);
		ot[i].push_back(0);
	}
	vector<int> ok;
	ffor(i,0,(1<<n-1)-1) for(auto j:ot[i]) {
		DY[dy[i]*2+dy[j]]={i,j}; 
		if(!i&&j==(1<<n-1)-1) ok.push_back(dy[i]*2+dy[j]);
		else if(j<=(i&-i)||__builtin_popcount(i)==1) ok.push_back(dy[i]*2+dy[j]);
		else if(j<=((i-(i&-i))&-((i-(i&-i))))) ok.push_back(dy[i]*2+dy[j]);
	}
	++m,a[m]=n;
	dp1[(m+1)&1][dy[(1<<n-1)-1]]=1;
	dp2[(m+1)&1][dy[(1<<n-1)-1]][n]=0;
	roff(i,m,1) {
		int st=i&1,lst=st^1;
		if(m!=i) for(auto j:ok) ffor(y,1,n) dp1[st][j]=dp1[lst][j],dp2[st][j][y]=dp2[lst][j][y];
		for(auto j:ok) {
			int x=DY[j].first,y=DY[j].second;
			if(!x||((x|y)&(1<<a[i]-1))) continue ;
			int v=__lg(x&-x)+1;
			int nx=x-(1<<v-1),ny=y+(1<<v-1),s=2*dy[nx]+dy[ny];
				dp1[st][j]=(dp1[st][j]+dp1[lst][s])%MOD;
				if(a[i]!=n) dp1[st][j]=(dp1[st][j]+dp1[lst][s+2*p3[a[i]-1]])%MOD;
				ffor(u,1,n) if(u!=v) {
					dp2[st][j][u]=(dp2[st][j][u]+dp2[lst][s][u])%MOD;
					if(a[i]!=n) dp2[st][j][u]=(dp2[st][j][u]+dp2[lst][s+2*p3[a[i]-1]][u])%MOD;
				}
				else {
					dp2[st][j][u]=(dp2[st][j][u]+dp2[lst][s][a[i]])%MOD;
					if(a[i]!=n) dp2[st][j][u]=(dp2[st][j][u]+dp2[lst][s+2*p3[a[i]-1]][a[i]])%MOD;
					dp2[st][j][u]=(dp2[st][j][u]+dp1[lst][s])%MOD;
					if(a[i]!=n) dp2[st][j][u]=(dp2[st][j][u]+dp1[lst][s+2*p3[a[i]-1]])%MOD;
				}
		}
	}
	ffor(i,0,p3[n-1]-1) {
		int x=DY[i].first,y=DY[i].second;
		if(y) continue ;
		ffor(j,1,n) ans[j]=(ans[j]+dp2[1][i][j])%MOD;
	}
	ffor(i,1,n-1) cout<<1ll*ans[i]*qpow(C[m-1][n-2],MOD-2)%MOD<<' ';
	return 0;
}
```

这样实际上还是过不去的。

观察上面代码的 DP 转移，发现我们删掉的数是 $v$。而如果 $j$ 不是 $v$ 我们实际上不太关心它的死活。也就是说，$S$ 中的最小值和 $j$ 不相等的时候是不重要的。

所以我们不用记录 $S$ 的那个散点，只记录是否是 $j$ 即可。这样把一个 $n$ 变成了 $0/1$，复杂度 $O(2^nn^2m)$，足以通过本题。

代码没写。

---


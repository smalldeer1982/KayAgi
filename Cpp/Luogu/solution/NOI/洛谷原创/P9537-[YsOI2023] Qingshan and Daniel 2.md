# [YsOI2023] Qingshan and Daniel 2

## 题目背景

Ysuperman 模板测试的博弈论题。

都什么年代了，还在玩传统对称博弈，快来玩玩非传统非对称博弈。

猜猜题目名称啥意思，没错就是要你快去做 CF1764B！！！另外这题融合了 CF1495、CF1707、CF1764 的梗（）

## 题目描述

今天 Ysuperman 发现了一款非对称博弈游戏，名字叫做 Bugaboo，具体规则如下：

> 在游戏的一开始，Qingshan 手中有一个正整数集 $S$，Daniel 手中有一个正整数集 $T$。
>
> Qingshan 和 Daniel 依次如下操作（Qingshan 先手）：选择在自己数集中的任意两个**不同的**数字 $x,y$，并且还需要满足 $|x-y|$ 不属于**对方的数集**，然后将 $|x-y|$ 加入**对方的数集**。最终无法操作的人失败。
>
> 可以注意到在游戏的进行过程中一个人手中的数集是会不断变化的，他在选择数字 $x,y$ 时既可以选择初始自己拥有的数字，也可以选择后面新增的数字。

现在 Ysuperman 给了你一个正整数集 $R$，Ysuperman 想要知道如果 Qingshan 一开始拥有的集合 $S$ 是 $R$ 的 $2^{|R|}$ 个子集中的任意一个，而 Daniel 一开始拥有的集合 $T$ 也是 $R$ 的 $2^{|R|}$ 个子集中的任意一个，那么在多少种情况下 Qingshan 会赢。

由于答案可能很大， Ysuperman 不想为难你，于是只要你求出答案对 $998,244,353$ 取模后的结果。

## 说明/提示

#### 样例 1 解释

对于第一组样例，显然 Qingshan 要赢的一个必要条件是她一开始的集合有至少两个数：

1. 当 $S=\{1,2\}$ 时，Qingshan 赢当 $T=\{\},\{2\},\{3\},\{2,3\}$。
1. 当 $S=\{1,3\}$ 时，Qingshan 赢当 $T=\{\},\{1\},\{3\}$。
1. 当 $S=\{2,3\}$ 时，Qingshan 赢当 $T=\{\},\{3\}$。
1. 当 $S=\{1,2,3\}$ 时，Qingshan 赢当 $T=\{\},\{1\},\{2\},\{3\},\{1,3\},\{2,3\}$。

所以答案为 $4+3+2+6=15$。

#### 数据范围

对于 $15\%$ 的数据，有 $a_i\le 10$。

对于 $30\%$ 的数据，有 $n\le 10$。

对于 $50\%$ 的数据，有 $a_i\le 1000$。

对于 $70\%$ 的数据，有 $n\le 1000$。

对于 $100\%$ 的数据，有 $1\le n\le 20000$，$1\le a_1<a_2<\cdots<a_n\le 20000$。

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
15```

## 样例 #2

### 输入

```
5
6 8 10 17 19
```

### 输出

```
378```

## 样例 #3

### 输入

```
9
2 3 4 6 7 8 12 16 18
```

### 输出

```
106533```

# 题解

## 作者：xiaolilsq (赞：10)

考虑啥时候游戏停止，如果轮到某人他无法操作了，那么除非他手中的数为等差数列，否则对方的集合大小必然大于等于他的集合大小。更进一步的，大小为 $n$ 的正整数集合只有等差数列中两两数的差值才只有 $n-1$ 种不同可能，归纳法很好证明。

所以我们可以发现几乎所有情况下都是拥有数字多的一方获胜。或者说在**大部分情况**下，如果先手有 $n$ 个数字时：当后手拥有大于等于 $n$ 个数字的时候，后手必胜；当后手拥有小于等于 $n-1$ 个数字的时候，先手必胜。

接下来考虑少数情况，也即输家数字比赢家多，此时不妨假设输家最终 $\{a,a+d,\dots,a+(n-1)d\}$ 共 $n$ 个数，赢家最终 $\{d,2d,\dots,(n-1)d\}$ 共 $n-1$ 个数，此时输家操作。

当先手 $n$ 个数字时，后手 $n-1$ 个数字若满足上述情况则后手必胜。否则说明至少经过了一次操作才达成了上述关系，这也就说明存在 $t$ 满足 $a=td$（或者说 $a$ 必然是 $d$ 的倍数）。那么最终关系形如：输家为 $\{td,(t+1)d,\dots,(t+n-1)d\}$；赢家为 $\{d,2d,\dots,(n-1)d\}$。

注意到赢家在游戏结束时都只能构造出来 $d,2d,\dots,(n-2)d$ 这些数字，所以我们可以得出 $(n-1)d,nd,\dots,(t+n-1)d$ 必然不是后来加入输家集合的，而是一开始就在输家集合中的。

考虑 $t=1$ 的特殊情况，也即最终关系形如：输家为 $d,2d,\dots,nd$，而赢家为 $d,2d,\dots,(n-1)d$。在这种情况下，输家初始必然拥有 $(n-1)d,nd$。由此我们知道这种局面出现的必要条件之一便是输家一开始拥有 $(n-1)d,nd$ 且赢家一开始最大值小于等于 $(n-1)d$，并且所有人一开始拥有的数字都是 $d$ 的倍数。

事实上非常巧合的一点就是这个必要条件就是充要的，因为在这种条件下赢家总是可以操作，某次轮到赢家操作的时候不妨设赢家集合大小为 $m$，输家除了 $(n-1)d,nd$ 两个数以外小于 $(n-1)d$ 的数字只有 $m-2$ 个，而赢家总是可以构造出至少 $m-1$ 个小于 $(n-1)d$ 的数字。

于是我们知道少数情况也就两种，一种是先手本来拥有的就是等差数列而被后手卡死直接赢，另一种又分先后手，一种就是先手有 $n$ 个数，后手 $n$ 个数，存在一组 $N,d$，满足后手最大两个数为 $Nd$ 和 $(N-1)d$，且先手最大数小于等于 $(N-1)d$，且所有数均为 $d$ 的倍数，则先手必胜，一种就是先手有 $n$ 个数，后手 $n-1$ 个数，存在一组 $N,d$，满足先手最大的两个数为 $Nd$ 和 $(N-1)d$，且后手最大数小于等于 $(N-1)d$，且所有数均为 $d$ 的倍数，则后手必胜。

至于具体去计数也很简单，唯一比较困难的一个地方就是如何统计一开始先手就无法操作的等差数列，这个可以枚举公差 $d$，然后用 bitset 存所有数，每次与上自身右移 $d$ 位，$k$ 次操作得到的 $1$ 的数量就是长度为 $k+1$ 且公差为 $d$ 的等差数列数量，复杂度为 $O(a^2\log a/w)$。

综上，复杂度为 $O(a^2\log a/w+a\log a)$。

---

## 作者：yyyyxh (赞：8)

好好一道题，学到很多。

这篇题解主要补充一些出题人题解没有提到的计数问题。

需要我们特殊计数的三个情况分别是：

+ 先手 $n+1$ 数，后手 $n$ 数，先手是首项任意公差为 $d$ 的等差数列，后手是首项为 $d$ 公差为 $d$ 的等差数列。后手胜。

+ 先手 $n+1$ 数，后手 $n$ 数，先手最大两数为 $(t+1)d,td$，后手所有数不超过 $td$，且所有数都是 $d$ 倍数。后手胜。

+ 先手 $n$ 数，后手 $n$ 数，后手最大两数为 $(t+1)d,td$，先手所有数不超过 $td$，且所有数都是 $d$ 倍数。先手胜。

为什么这样出题人已经讲得很清楚了，这里不赘述。

对于第一种可以直接 `bitset` 统计。枚举公差 $d$，然后每次 `bs&=bs<<d`。一共 $O(a\ln a)$ 次 `bitset` 操作，复杂度 $O(\frac{a^2\ln a}{\omega})$ 正好卡在 $10^8$ 左右，实际上非常快。

对于第二、三种情况出题人题解没有讲，自己推了一下。依旧枚举公差 $d$，这时候需要考虑的数的总量是 $O(a\ln a)$ 级别的。我们可以枚举合法的 $td,(t+1)d$，然后设在给定集合中 $\leq td$ 的个数为 $c$。这里以第二种情况为例，我们枚举后手选的数的个数 $p$。方案数就是：

$$
\sum_{p=1}^c {c \choose p} {c-1\choose p-1}
$$

这个式子看起来很像经典问题“组合数平方和”，我们可以用范德蒙德卷积化：

$$
\begin{aligned}
&\sum_{p=1}^c {c \choose p} {c-1\choose p-1}\\
=&\sum_{p=1}^c {c \choose c-p} {c-1\choose p-1}\\
=&{2c-1\choose c-1}

\end{aligned}
$$

第三种情况同理。

还有一个小问题，第一种和第二种情况会算重一点点。但这样先手和后手分别只会拿一段连续等差数列的前缀和后缀，可以放在一起简单统计。

```cpp
int main(){
	n=read();
	for(int i=1;i<=n;++i) msk.set(a[i]=read());
	int mx=a[n];
	fac[0]=1;
	for(int i=1;i<=mx+mx;++i) fac[i]=(ll)fac[i-1]*i%P;
	fiv[mx+mx]=qp(fac[mx+mx]);
	for(int i=mx+mx;i;--i) fiv[i-1]=(ll)fiv[i]*i%P;
	int tmp=0,res=0;
	for(int i=0;i<=n;++i){
		int cur=C(n,i);
		if(i>1) res=(res+(ll)cur*tmp)%P;
		inc(tmp,cur);
	}
	for(int t=1;t<=mx;++t){
		bs=msk;
		for(int i=t;i<=mx;i+=t)
			if(msk[i]){
				bs&=(bs<<t);
				int cc=bs.count();
				if(!cc) break;
				res-=cc;
			}
			else break;
		while(res<0) res+=P;
	}
	for(int t=1;t<=mx;++t){
		int cnt=0,cont=0,las=0;
		bool fl=1;
		for(int i=t;i<=mx;i+=t){
			if(msk[i]) ++cnt,++las;
			else fl=0,las=0;
			if(fl) ++cont;
			if(i+t<=mx&&msk[i]&&msk[i+t]){
				res=(res-C(cnt+cnt-1,cnt-1))%P;
				if(cnt>1) res=(res+C(cnt+cnt-1,cnt-2))%P;
				res=(res+min(cont,las))%P;
			}
		}
	}
	while(res<0) res+=P;
	printf("%d\n",res);
	return 0;
}
```

~~点开提交记录发现出题人是用 NTT 统计第二、三种情况的，于是有了这篇题解 QwQ。~~

---

## 作者：Kreado (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9537)。

## 思路

考虑什么时候先手会赢。

假设先手集合为 $|S|$，后手集合为 $|T|$，我们分以下几种情况讨论：

若 $|S|>|T|+1$，这种情况下 $S$ 都能构造出超过 $|T|$ 种不同的数，因此先手必胜。

若 $|S|<|T|$，我们先进行先手的操作，此时 $|T|>|S|+1$，根据上面的结论，后手必胜。

若 $|S|=|T|+1$，若 $S$ 的最终局面不是 $\{a,a+d,a+2d,\cdots,a+(n-1)d\}$，或者 $|T|$ 的最终局面不是 $\{d,2d,\cdots,(n-1)d\}$，那么 $S$ 能产生的数一定大于 $|T|$，此时先手必胜。

若 $|S|=|T|+1$，若 $S$ 的最终局面是 $\{a,a+d,a+2d,\cdots,a+(n-1)d\}$，且 $|T|$ 的最终局面是 $\{d,2d,\cdots,(n-1)d\}$，考虑以下两种情况：

- $S,T$ 的初始集合就是最终状态，容易发现此时后手必胜。

- $S,T$ 的初始集合不是最终得到的集合，那么在此过程中一定经过了至少一轮操作，由于 $T$ 只能产生 $\{d,2d,\cdots,(n-1)d\}$ 这些数的一个，首先我们能得出 $d\mid a$，即 $a=td$，其次 $S$ 集合中的 $a+(n-2)d$ 和 $a+(n-1)d$ 是无论如何都不能被 $T$ 集合里的数组合出来，也就是说 $a+(n-2)d,a+(n-1)d$ 这两个数是一开始就存在于集合 $S$ 中的，这种情况后手必胜。

若 $|S|=|T|$，我们可以让先手先操作一步达成上面 $|S|+1=|T|$ 的情况（注意此时变为后手操作），按照上面得到的结论，若 $T$ 集合存在 $a+(n-2)d,a+(n-1)d$，$S$ 集合中的最大值小于等于 $a+(n-2)d$，且 $\forall x\in S\cup T,d\mid x$，那么此时先手必胜。

总结下来，我们可以得到这几种情况：

- $|S|=|T|+1$，$S$ 的初始集合为 $\{td,td+d,td+2d,\cdots,td+(n-1)d\}$，$T$ 的初始集合为 $\{d,2d,\cdots,(n-1)d\}$，此时后手必胜。

- $|S|=|T|+1$，存在 $t,d$ 满足集合 $S$ 存在 $td,(t+1)d$，$T$ 中最大的数不超过 $td$，且 $\forall x\in S\cup T,d\mid x$，此时后手必胜。

- $|S|>|T|$，除去上面两种情况，先手必胜。

- $|S|=|T|$，存在 $t,d$ 满足集合 $T$ 存在 $td,(t+1)d$，$S$ 中最大的数不超过 $td$，且 $\forall x\in S\cup T,d\mid x$，此时先手必胜

- 其余情况均为后手必胜。

接下来考虑对合法的 $S,T$ 集合计数。

首先计算出 $|S|>|T|$ 的方案数，然后在减去这其中不合法的方案，容易得到总方案数为 $\displaystyle \sum_{i=1}^n \dbinom{n}{i}\sum_{j=0}^{i-1} \dbinom{n}{j}$，（其中 $i$ 枚举的是 $|S|$ 的大小，$j$ 枚举的是 $|T|$ 的大小）。

对于上述的第一种情况，首先枚举公差 $d$ 和其长度 $l$，用一个 bitset 记录哪些数出现过，这部分可以做到 $\mathcal O(\frac{a^2\ln a}{w})$。

对于第二，三种情况，依旧枚举公差 $d$，然后得到 $td,(t+1)d$，接下来枚举后手集合大小 $p$（这时先手集合大小我们也知道了），假设当前有 $c$ 个数，对于其中每个数 $x$，都满足 $d\mid x,x\le td$，那么方案数为

$$
\begin{aligned}
\sum_{p=1}^c \dbinom{c}{p}\dbinom{c-1}{p-1}&=\sum_{p=0}^{c-1} \dbinom{c}{p}\dbinom{c-1}{c-p}
\\&=\dbinom{2c-1}{c-1}

\end{aligned}
$$

第四种情况也是类似，贡献为 $\dbinom{2c-1}{c-2}$。

还有一个小问题，第一种和第二种情况会算重一点点。但这样先手和后手分别只会拿一段连续等差数列的前缀和后缀，可以放在一起简单统计。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=4e4+7,N=4e4;
const ll Mod=998244353;
int n;
int a[Maxn];

ll fac[Maxn],Inv[Maxn],ans;
inline ll ksm(ll a,ll b,ll mod){
    ll z=1;
    while(b){
        if(b&1) z=z*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return z;
}
bitset<Maxn>b,tmp;
int mx;
inline ll upd(ll x){
    return (x%Mod+Mod)%Mod;
}
inline ll Binom(int x,int y){
    if(y>x) return 0;
    return fac[x]*Inv[y]%Mod*Inv[x-y]%Mod;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),b.set(a[i]),mx=max(mx,a[i]);

    fac[0]=1;
    for(int i=1;i<=N;i++) fac[i]=fac[i-1]*i%Mod;
    Inv[N]=ksm(fac[N],Mod-2,Mod);
    for(int i=N-1;~i;i--) Inv[i]=Inv[i+1]*(i+1)%Mod;

    ll sm=1;
    for(int i=1;i<=n;i++){
        ans=(ans+Binom(n,i)*sm)%Mod;
        sm=(sm+Binom(n,i))%Mod;
    }

    for(int i=1;i<=mx;i++){
        tmp=b;
        for(int j=i;j<=mx;j+=i){
            tmp&=(tmp<<i);
            if(b.test(j)) ans=upd(ans-tmp.count());
            else break;
        }
    }
    for(int i=1;i<=mx;i++){
        bool flg=1;
        int pre=0,suf=0,cnt=0;
        for(int j=i;j+i<=mx;j+=i){
            if(b.test(j)) suf++,cnt++; 
            else flg=0,suf=0;
            if(flg) pre++;
            if(b.test(j)&&b.test(j+i)){
                ans=upd(ans-Binom(2*cnt-1,cnt-1));
                if(cnt>=2) ans=(ans+Binom(2*cnt-1,cnt-2))%Mod;
                ans=(ans+min(suf,pre))%Mod;
            }
        }
    }
    printf("%lld",upd(ans-n));
    return 0;
}
/*
3
1 2 3

5
6 8 10 17 19

9
2 3 4 6 7 8 12 16 18
*/
```

---

## 作者：qiuzx (赞：0)

这个博弈是一个非传统非对称博弈，所以没有什么现成的工具可以帮助解决这个问题。因此必然是有一些很简洁的性质能够被应用。考虑什么时候某个人无法操作了，设对手的集合大小为 $m$，则发现有一个必要条件是通过他当前所有数能凑出来的不同的差值不超过 $m$ 个，否则根据抽屉原理必然可以继续操作。然而发现若当前他有 $n$ 个数，那么至少能凑出 $n-1$ 个不同的差（直接用最大的数减去其它所有的），所以若 $m<n-1$，那么当前玩家一定不会输。由于每一个回合中两人的元素个数都增加了 $1$，所以若初始状态中先手有 $n$ 个数，后手有 $m$ 个数，那么当 $n>m+1$ 时先手必胜（因为每到先手操作时都一定满足 $n>m+1$），当 $n<m$ 时后手必胜（因为每到后手操作时都一定满足 $n+1<m$）。从而我们只需要考虑 $n=m$ 与 $n=m+1$ 的情形即可。

刚刚的分析中这个 $n-1$ 的下界是十分宽泛的，大部分情况中 $n$ 个数不可能只能凑出 $n-1$ 个差。具体地，只有当这 $n$ 个数形成等差数列时才只会有 $n-1$ 个差。因此若某个时刻 $n>m$，当前玩家的数不形成等差数列，那么一定可以继续操作。但我们希望这个结论能够拓展到初始状态，因为我们无法判断一个初始状态是否会通过一系列操作变成等差数列。

注意到当 $n>m$ 时若想让当前玩家输掉游戏，则另一方的集合是唯一确定的。假设当前玩家的数为 $x,x+d,\cdots,x+(n-1)d$，那么另一方的数必然为 $d,2d,\cdots,(n-1)d$。假定这不是初始状态，那么另一方必然往当前玩家的集合中添加过至少一个数。由于另一方所有数都是 $d$ 的倍数，所以添加进当前集合的也一定是 $d$ 的倍数，从而可以设 $x=kd$。进一步地，另一方至多能凑出 $(n-2)d$ 这么大的数，所以当前集合中 $(n-1)d$ 往后的所有这些数都是一开始就有的。另一方面，无论 $k$ 取值如何，设当前玩家初始最大的数为 $td$，那么他必然拥有 $(t-1)d$，这是因为即使 $k=1$，也有最后两项 $>(n-2)d$。

这样我们得到了 $n=m+1$ 时先手必败的一个必要条件，即存在 $d$ 和 $t$，使得先手最大的两个数为 $(t-1)d$ 和 $td$，后手所有的数都不大于 $(t-1)d$，且两人所有的数都是 $d$ 的倍数。接下来似乎没有什么其它的必要条件了，所以不妨猜测这个条件是充分的，事实上确实如此。我们只需要说明每次后手操作时都存在一种合法方案即可。设 $m'$ 表示某次后手操作时他的集合大小，则此时先手也有 $m'$ 个数。因为后手的集合中所有数都不大于 $(t-1)d$，所以它们的不同差值至少有 $m'-1$ 种，且均不大于 $(t-2)d$。另一方面，先手的 $m'$ 个数中至少有两个 $>(t-2)d$，所以只有至多 $m'-2$ 种不大于 $(t-2)d$，因此后手的差值一定存在一个不在先手的集合中。注意还有一种情况是第一步就无法操作，这种情况需要特别处理。

由于当 $n=m$ 时就是操作一步变成上面的情况，所以此时若存在 $d$ 和 $t$，使得后手最大的两个数为 $(t-1)d$ 和 $td$，先手所有的数都不大于 $(t-1)d$，且两人所有的数都是 $d$ 的倍数，那么先手必胜，否则必败。

考虑现在如何计数。首先容易计算 $n>m$ 的方案数，接下来只需要计算 $n=m+1$ 时先手必败的方案，以及 $n=m$ 时先手必胜的方案。

如果是第一步就无法操作，那么枚举 $d$ 和 $n$，则只需要考察有多少个 $x$ 满足 $x,x+d,\cdots,x+(n-1)d$ 都出现在输入中，容易使用 bitset 维护，复杂度 $O(\frac{a^2\ln a}{\omega})$。否则若 $n=m+1$，枚举 $d,t$，那么剩下的就是一个组合数，$n=m$ 也是类似的。注意这里确定了 $d,t$ 之后末两项都唯一确定了，且反过来任意一个序列的末两项都唯一对应一组 $d,t$，因此不会算重。然而可能出现 $n=m+1$ 时既满足我们的充要条件，也满足第一步无法操作，此时这种情况不应被重复统计。不过会发生这种情况一定是后手取了 $d$ 开始的一段前缀，先手取了 $td$ 往前的一段后缀，动态维护合法的前后缀长度即可。

这样就做完了，复杂度 $O(\frac{a^2\ln a}{\omega}+a\ln a)$。

[代码](https://www.luogu.com.cn/paste/9wgfh8x5)

---


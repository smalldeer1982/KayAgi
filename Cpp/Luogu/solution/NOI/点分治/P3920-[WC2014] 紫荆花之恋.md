# [WC2014] 紫荆花之恋

## 题目描述

强强和萌萌是一对好朋友。有一天他们在外面闲逛，突然看到前方有一棵紫荆树。这已经是紫荆花飞舞的季节了，无数的花瓣以肉眼可见的速度从紫荆树上长了出来。

仔细看看的话，这个大树实际上是一个带权树。每个时刻它会长出一个新的叶子节点，每个节点上有一个可爱的小精灵，新长出的节点上也会同时出现一个新的小精灵。小精灵是很萌但是也很脆弱的生物，每个小精灵 $i$ 都有一个感受能力值 $r_i$，小精灵 $i,j$ 成为朋友当且仅当在树上 $i$ 和 $j$ 的距离 $dist(i,j) \leq r_i+r_j$，其中 $dist(i,j)$ 表示在这个树上从 $i$ 到 $j$ 的唯一路径上所有边的边权和。

强强和萌萌很好奇每次新长出一个叶子节点之后，这个树上总共有几对朋友。


我们假定这个树一开始为空，节点按照加入的顺序从 1 开始编号。由于强强非常好奇，你必须在他每次出现新结点后马上给出总共的朋友对数，不能拖延哦。

## 说明/提示

所有数据均满足 $1 \leq c_i \leq 10^4$，$a_i \leq 2\times 10^9$，$r_i \leq 10^9$。

| 测试点编号       | 约定                                                         |
| :----------------: | :------------------------------------------------------------: |
| $1,2$            | $n \leq 100$                                                 |
| $3,4$            | $n \leq 1000$                                                |
| $5,6,7,8$        | $n \leq 10^5$，节点 1 最多有两个子节点，其他节点最多有一个子节点 |
| $9,10$           | $n \leq 10^5$，$r_i \leq 10$                                 |
| $11,12$          | $n \leq 10^5$，树是随机生成的                                |
| $13,14,15$       | $n \leq 7\times 10^4$                                        |
| $16,17,18,19,20$ | $n \leq 10^5$                                                |

## 样例 #1

### 输入

```
0
5
0 0 6
1 2 4
0 9 4
0 5 5
0 2 4
```

### 输出

```
0
1
2
4
7
```

# 题解

## 作者：shadowice1984 (赞：176)

~~丸了丸了毒瘤实锤了，110行的紫荆花之恋了解一下？~~

只能说这道题的细节不是一般的多，我会尽量详细的在这篇题解里列举一下
___________

### 前置芝士:动态点分治(点分树)

如果不知道什么是动态点分治(或者点分树)的话还是暂且不要淦这题了，拿这题去练动态点分治的手会让你留下心里阴影

关于动态点分治这个技术可以去自行百度一下，做几道例题来学习一下

### 前置芝士:高速平衡树

这里的高速平衡树指的是除了splay和fhqtreap以外的所有平衡树(这两个平衡树真的很慢)，如果不会这些平衡树的话请出门左转模板区
_______________

# 本题题解

一句话题意，维护一颗树支持动态的插入叶子，每个边上有边权，每个点上有点权，每次插入一个节点之后询问树上有多少点对满足两个点的点权之和大于边权

**强制在线**~~(对，这才是万恶之源)~~

那么让我们来简单的分析一下题目的思路

首先可以想到的是我们求出答案的方式应该是插入一个节点之后p询问一下树上有多少个点v和p的距离小于v,p的点权之和，然后把这些点的数目加到答案中去就可以得到插入了p之后的答案了

所以说现在的问题就是询问树上一个点到其他所有点的信息的问题

如果你对动态点分治(点分树)这个技术足够熟练的话应该可以想到我们是可以用点分树去解决这个问题的(这是动态点分治的两个常见用法,一个是询问树上的某一个点到其他所有点的信息，另一个是树上二分寻找关键点)

我们就对这个树建立起一颗点分树(让我们暂时忽略复杂度问题)

现在让我们来看一看这颗点分树都需要维护什么信息呢？

### part1:处理询问

我们现在希望询问对于树上一个点u，有多少个点v的点权加起来大于他们之间的距离

那么我们可以考虑遍历u在点分树上的所有祖先g(显然这些祖先不会太多)，然后考虑一条形如$u-v-g$的路径是否合法

那么我们设$u-g$的路径为$d_{u}$,$v-g$的路径长度为$d_{v}$,显然$dis(u,v)=d_{u}+d_{v}$，根据题意，一个点对$u,v$合法当且仅当$dis(u,v) \leq r_{u}+r_{v}$，换句话说就是$d_{u}+d_{v} \leq r_{u}+r_{v}$，我们对这个不等式做些小小的变换，那么我们就可以得到这个式子


$$d_{v}-r_{v} \leq r_{u}-d_{u}$$

换句话说我们在每一层的祖先$g$处需要查询的东西就是有多少个$v$他的$d_{v}-r_{v}$比$r_{u}-d_{u}$小，那么我们可以使用平衡树来维护这些$d_{v}-r_{v}$的值，(这里之所以不使用权值线段树和权值树状数组是因为根本无法离散化所以只能上平衡树),这样的话我们就可以求出有多少个形如$u-g-v$的路径了，只是这样有一个问题，就是我们可能考虑了的路径并不是简单的路径，换句话说即使切掉$g$，$u,v$还是在同一个联通块里

那其实也很简单，对于切掉$g$之后形成的若干个联通块，我们每个块开一个平衡树还是存同样的值，查询的时候用总的减去和自己在同一个联通块里的就行了

那么我们总结一下就是我们点分树上每一个节点都需要开一个vector

vector里面存一个三元组$(g,dis,tree)$表示这个节点的一个祖先编号，到这个祖先的距离，以及在切掉这个祖先之后，这个点所在的联通块所在的平衡树编号(也就是说，同一个平衡树会被不同的节点存很多次)

然后每一个点开一个平衡树，存的是点分治到这个点g的时候，和g在同一个联通中的点$v$的$d_{v}-r_{v}$值

查询树上的一个点u到树上的其他点v中，有多少个合法$(u,v)$对的算法流程如下

枚举$u$的vector中的所有元素，对于一个祖先$g$，在这个点平衡树上查一下有几个元素小于等于$r_{u}-d_{u}$，加到答案里，然后在这个vector里存的平衡树中查一下有几个元素小于$r_{u}-d_{u}$答案减去这个值。如此这般迭代我们就能获得答案了,对了，我们还需要查一下这个点自己的平衡树里面有多少点的值小于$-r_{u}$(因为自己到自己的距离是0)
_______________________________

### part2:定期重构点分树

然后问题来了，我们总不能每次都点分治啊，这样的话我们只会得到一个$O(n^2logn)$的垃圾做法

那么我们可以想一个类似于替罪羊树的思想，就是我们每次插入一个节点的时候检查一下是否存在一对父子使得父亲的$size×a$小于孩子的$size$，如果存在这样的不平衡关系我们就找到最高的点，然后重构这个点所在的点分树子树

好了现在的问题就是我们的点分树维护的信息已经相当的复杂了，重构整颗点分树就算了，问题是重构一个点分树的子树的时候我们进行的操作将会相当的难受了

~~但是就算难受我们还是得写~~

所以我们慢慢的推我们需要在点分树上维护什么附加的信息才能让我们可以重构这个点分树的一个子树

首先我们需要的信息是这个点的子树里都有谁，所以我们每个节点暴力的开一个vector存他的所有孩子都是谁，同时我们在重构点分树的时候还需要清空一些平衡树(因为要重新插入)所以我们每个节点开一个vector存的是切掉这个点之后，存储剩下的各个联通块信息的平衡树，也就是你查询的时候减掉的那颗平衡树

好了那么现在我们要重构一个点$p$在点分树中的子树了

怎么办呢?

其实也很简单我们清空该清空的东西留下该留下的东西然后点分治就行了

我们需要清空的东西有

1.这个子树中所有点的平衡树

2.这个子树中所有用来减的平衡树

3.这个子树中所有点用来存自己孩子的vector

4.这个子树中所有点的存自己周围一圈平衡树的vector

但是最重要的还是每个点用来存自己祖先的vector

如果我们在每一层点分治的时候都在这个存祖先的vector里面push我们该push的元素的话，你会发现vector中元素的顺序刚好是所有祖先按照深度排序的顺序，所以我们清空的时候不停的pop_back直到我们把$p$给pop出来为止

然后清空了这些之后我们访问一遍$p$的存孩子标记然后把对应的节点都打上标记跑一遍点分治就可以了
_____________________

### part3点分治

当然点分治的过程相对来讲还是比较亲切的(其实这题哪个部分都不难写，就是叠起来就十分的要命另外细节超级多)

我们十分套路对目标联通块进行找重心操作,找到重心之后我们考虑构造这一层的点分树

首先先把这个联通块里的所有点push到g的孩子vector里没有任何问题

然后接下来dfsg的每一个子树，对于每一个子树里的元素v我们把$(g,dis(g,v),tree)$这个三元组插到v的vector里去

然后在上述dfs的过程中我们顺手把平衡树新建出来顺便把每个节点的$d_{v}-r_{v}$插到平衡树中去就可以了

___________________

### part4插入一个节点

嗯，最要命的东西来了

我们需要插入一个节点，把他挂在$u$上

我们具体的算法流程如下

首先把u的祖先vector复制一份给p

然后for一遍这个vetor，里面所有的dis+=u和p之间的距离，同时在这个vector记录的平衡树以及祖先g的平衡树中插入$dis-r_{p}$这个值

接下来在p的vector中插入$(u,dis(u,p),tree)$这个三元组，(当然你需要把p的平衡树开出来)同时你还需要把u的存平衡树的vector中插入一个关于p的平衡树，并且在这个平衡树中插入$dis(u,p)-r_{p}$这个值，同时你还需要把p的平衡树也给开出来同时插入$-r_{p}$这个值

接下来事情还没有结束我们for一遍p的vector，并在这些祖先的孩子vector当中插入$p$

最后我们扫描一遍p的vector检测有无违反$a$平衡条件的父子对，如果有，就重构那个最高的节点所在的子树

对了，插入1号节点记得特判

_____________________

### 关于高速平衡树

~~splay实在是太慢了~~

可我是个splay党啊，只会splay怎么办啊，不想写treap啊

~~写bst啊~~，只要数据随机就是最快的二叉搜索树

可是9,10两个点卡bst啊

~~替罪羊树啊~~,简单粗暴的平衡树$a$取0.8就可以通过本题了
____________________

110行紫荆花之恋你值得拥有

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;const int N=1e5+10;const int M=6*1e6+10;typedef long long ll;const ll mod=1e9;
int t;int n;ll lastans;
namespace SC//简易替罪羊树模板 
{
    int s[M][2];int fa[M];int siz[M];int val[M];int tr[N];int hd;int st[M];int tp;int ct;
    inline int chk(){return tp?st[tp]:ct+1;}
    inline int rus(){return tp?st[tp--]:++ct;}inline void rls(const int& x){st[++tp]=x;}
    inline void del(const int& x)
        {if(s[x][0])del(s[x][0]);if(s[x][1])del(s[x][1]);s[x][0]=s[x][1]=0;rls(x);}
    inline int gc(const int& x){return s[fa[x]][1]==x;}
    struct spt
    {
        int rt;
        inline void itw(const int& p){if(s[p][0])itw(s[p][0]);tr[++hd]=p;if(s[p][1])itw(s[p][1]);}
        inline int build(int l,int r)
        {
            if(l>r)return 0;int mid=(l+r)/2;int p=tr[mid];s[p][0]=build(l,mid-1);
            s[p][1]=build(mid+1,r);fa[s[p][0]]=p;fa[s[p][1]]=p;siz[p]=siz[s[p][0]]+1+siz[s[p][1]];
            return p;
        }
        inline void ins(const int& va)
        {
            int hi=-1;int p=0;
            for(int tw=rt;tw;tw=s[p][val[p]<=va])//a取0.8 
                {p=tw;siz[p]++;if(fa[p]!=0&&fa[p]!=rt&&hi==-1&&siz[p]*5>=siz[fa[p]]*4)hi=fa[p];}
            int np=rus();fa[np]=p;s[p][val[p]<=va]=np;val[np]=va;siz[np]=1;
            if(hi!=-1){int d=fa[hi];int t=gc(hi);hd=0;itw(hi);s[d][t]=build(1,hd);fa[s[d][t]]=d;}
        }
        inline int qry(const int& va)
        {int ret=0;for(int p=rt;p;)if(val[p]<=va)ret+=siz[s[p][0]]+1,p=s[p][1];else p=s[p][0];return ret;}
        inline int rebuild(int* a,int l,int r)
        {
            if(l>r)return 0;int mid=(l+r)/2;int p=rus();val[p]=a[mid];
            s[p][0]=rebuild(a,l,mid-1);s[p][1]=rebuild(a,mid+1,r);
            fa[s[p][0]]=p;fa[s[p][1]]=p;siz[p]=siz[s[p][0]]+1+siz[s[p][1]];return p;
        }
        inline void clear(){del(rt);}inline void ih(int* a,int S){rt=rebuild(a,0,S);fa[rt]=0;}
    };
}
namespace VDC_tree//点分树 
{
    int v[2*N];int x[2*N];int ct;int al[N];int val[2*N];bool cut[N];int siz[N];int w[N];
    struct data{int f;int dis;SC::spt sp;};vector <data> ve[N];
    vector <int> so[N];vector <SC::spt> nw[N];SC::spt sct[N];int ndep[N];int tp;int* mdep;int tot;
    inline void add(int u,int V,int va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
    inline int dfs1(int u,int f)//找重心 
    {siz[u]=1;for(int i=al[u];i;i=x[i])if(v[i]!=f&&cut[v[i]])siz[u]+=dfs1(v[i],u);return siz[u];}
    inline int find(int u,int f,const int& tot)
    {
        for(int i=al[u];i;i=x[i])
            if(v[i]!=f&&cut[v[i]]&&2*siz[v[i]]>=tot)return find(v[i],u,tot);return u;
    }
    inline void dfs3(int u,int f,int dis,const int& g,const int& p)//处理点分树 
    {
        so[g].push_back(u);ve[u].push_back((data){g,dis,(SC::spt){p}});mdep[++tp]=dis-w[u];
        for(int i=al[u];i;i=x[i])if(v[i]!=f&&cut[v[i]])dfs3(v[i],u,dis+val[i],g,p);
    }
    inline void solve(int u)//点分治 
    {
        dfs1(u,0);int g=find(u,0,siz[u]);cut[g]=false;so[g].clear();so[g].push_back(g);
        if(siz[u]==1){ndep[0]=-w[u];sct[g].ih(ndep,0);return;}mdep=ndep;tp=-1;tot=0;
        for(int i=al[g];i;i=x[i])
        {
            if(!cut[v[i]])continue;mdep=mdep+tp+1;tot+=tp+1;tp=-1;dfs3(v[i],g,val[i],g,SC::chk());
            SC::spt tre;sort(mdep,mdep+tp+1);
            tre.ih(mdep,tp);nw[g].push_back(tre);
        }tot+=tp+1;ndep[tot]=-w[g];sort(ndep,ndep+tot+1);sct[g].ih(ndep,tot);
        for(int i=al[g];i;i=x[i])if(cut[v[i]])solve(v[i]);
    }
    inline void rebuild(int p)//重构前的清空函数 
    {
        vector <int>:: iterator it;vector <SC::spt>:: iterator it1;
        for(it=so[p].begin();it!=so[p].end();++it)cut[*it]=true;
        for(it=so[p].begin();it!=so[p].end();++it)sct[*it].clear();
        for(it=so[p].begin();it!=so[p].end();++it)
            {for(it1=nw[*it].begin();it1!=nw[*it].end();++it1)it1->clear();nw[*it].clear();}
        for(it=so[p].begin();it!=so[p].end();++it)
            if(*it!=p)while(1)if(ve[*it].rbegin()->f==p){ve[*it].pop_back();break;}else ve[*it].pop_back();
        solve(p);
    }
    inline int ins(int p,int u,int va,int we)//插入一个点 
    {
        add(u,p,va);add(p,u,va);w[p]=we;vector <data>:: iterator it,it1,it2;int res=0;
        for(ve[p]=ve[u],it=ve[p].begin();it!=ve[p].end();++it)
            it->dis+=va,it->sp.ins(it->dis-we),sct[it->f].ins(it->dis-we);   
        SC::spt tre;ndep[0]=va-we;tre.ih(ndep,0);ve[p].push_back((data){u,va,tre});
        nw[u].push_back(tre);sct[u].ins(va-we);ndep[0]=-we;sct[p].ih(ndep,0);so[p].push_back(p);
        for(it=ve[p].begin();it!=ve[p].end();++it)so[it->f].push_back(p);
        for(it1=ve[p].begin(),it2=it1,++it2;it2!=ve[p].end();++it2,++it1)
            if(so[it1->f].size()*4<=so[it2->f].size()*5){rebuild(it1->f);break;}
        res+=sct[p].qry(we)-1;
        for(it=ve[p].begin();it!=ve[p].end();++it)
            res+=sct[it->f].qry(we-it->dis)-it->sp.qry(we-it->dis);return res;						
    }
    inline void ih(int we){w[1]=we;ndep[0]=-we;sct[1].ih(ndep,0);so[1].push_back(1);}
}
int main()
{
    scanf("%d",&t);scanf("%d",&n);
    int f;int va;int we;scanf("%d%d%d",&f,&va,&we);VDC_tree::ih(we);printf("0\n");
    for(int i=2;i<=n;i++)
    {
        scanf("%d%d%d",&f,&va,&we);f^=(lastans)%mod;
        lastans+=VDC_tree::ins(i,f,va,we);printf("%lld\n",lastans);
    }return 0;//拜拜程序~ 
}

```












---

## 作者：panyf (赞：53)

45 行 1.7KB 紫荆花之恋了解一下~

总时间不到 20s，暂时是洛谷最优解。

树上路径询问，带修，和距离有关，果断想到点分树。

把题目中的式子移项，就是 $dis(i,l)-r_i\leq r_j-dis(j,l)$，其中 $l$ 是 $i,j$ 在点分树上的 lca。

用平衡树维护，每新增一个点 $i$ 时，先对 $i$ 的所有点分树上的祖先 $l$，查询 $r_i-dis(i,l)$ 的排名，然后向平衡树插入 $dis(i,l)-r_i$。

因为在 $fa_l$ 的平衡树中查询时 $l$ 的子树会算重，所以要再开一个平衡树用来容斥，向其中插入 $dis(i,fa_l)-r_i$。

因为平衡树码量和常数都较大，所以这里用 basic_string/vector 和根号重构。具体做法是维护两个 basic_string 分别为 $big$ 和 $small$，插入时直接向 $small$ push_back。如果 $small$ 的大小大于根号，就对 $big$ 和 $small$ 归并排序，然后放入 $big$ 中。查询时在 $big$ 中二分，然后在 $small$ 中暴力枚举。这样的复杂度是 $O(n\sqrt n)$。

因为此题有加点操作，还要强制在线，所以要动态点分树。

具体做法是，加入一个点 $i$ 和边 $(i,j)$ 时先将 $fa_i$ 设为 $j$。然后从根节点开始枚举 $i$ 在点分树上的祖先，如果 $sz_x>\alpha\times sz_{fa_x}$，就对 $fa_x$ 的子树重新建树，这里 $fa$ 表示点分树上的父亲。$\alpha$ 取 $0.8$ 左右即可。这样可以保证点分树高为 $\log n$。

重新建树只需要对整棵树点分治一遍即可。

一些实现细节：

对每个点 $i$ 开两个 basic_string $f$ 和 $d$，分别表示祖先 $j$ 和 $dis(i,j)$。

再开一个 basic_string $g$，表示 $i$ 的点分树子树中的结点。

重构子树 $i$ 时，对于 $g_i$ 中的每一个点 $k$，清空 $k$ 的平衡树和 $g_k$，然后不断同时弹出 $f_k$ 和 $d_k$ 的末尾，直到 $f_k$ 弹出点 $i$。这样 $f_k$ 中就只剩下 $i$ 子树以外的点了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3;
struct T{//根号重构 basic_string
	basic_string<int>b,s,t;
	void st(){sort(b.begin(),b.end());}
	int get(int x){
		if(s.size()>300)t.resize(s.size()+b.size()),sort(s.begin(),s.end()),merge(b.begin(),b.end(),s.begin(),s.end(),t.begin()),swap(b,t),s={};
		int w=upper_bound(b.begin(),b.end(),x)-b.begin();
		for(int i:s)w+=i<=x;
		return s+=-x,w;
	}
}u[N],v[N];
basic_string<int>f[N],d[N],g[N],h;
long long ans;
int m,o,r,he[N],len[N*2],to[N*2],ne[N*2],w[N],sz[N];
bool b[N];
void gr(int x,int y){//求重心
	int i=he[x],j,w=0;
	for(sz[x]=1;i;i=ne[i])if(b[j=to[i]]&&j!=y)gr(j,x),sz[x]+=sz[j],w=max(w,sz[j]);
	if((w=max(w,m-sz[x]))<=o)o=w,r=x;
}
void gd(int x,int y,int z){//求距离
	if(d[x].size())v[r].b+=d[x].back()-w[x];
	f[x]+=r,d[x]+=z,g[r]+=x,u[r].b+=z-w[x];
	for(int i=he[x],j;i;i=ne[i])if(b[j=to[i]]&&j!=y)gd(j,x,z+len[i]);
}
void wk(int x){//点分治
	int i=he[x],l=m,j;
	for(b[x]=0,gd(x,0,0),u[x].st(),v[x].st();i;i=ne[i])if(b[j=to[i]])o=m=sz[j]<sz[x]?sz[j]:l-sz[x],gr(j,0),wk(r);
}
int main(){
	int n,i,j,k,l,z,y,x,t=0;
	for(scanf("%*d%d%*d%*d%d",&n,w+1),f[1]+=1,g[1]+=1,d[1]+=0,u[1].s+=-w[1],i=2;printf("%lld\n",ans),i<=n;++i){
		scanf("%d%d%d",&j,&x,w+i),j^=ans%int(1e9),ne[++t]=he[i],to[t]=j,len[t]=x,he[i]=t,ne[++t]=he[j],to[t]=i,len[t]=x,he[j]=t,f[i]=f[j],d[i]=d[j];
		for(int&k:d[i])k+=x;
		for(f[i]+=i,d[i]+=0,l=f[i].size(),k=l-1;~k;--k)if(g[z=f[i][k]]+=i,ans+=u[z].get(w[i]-d[i][k]),k)ans-=v[z].get(w[i]-d[i][k-1]);//更新答案
		for(k=0;k<l-1;++k)if(g[z=f[i][k]].size()*.8<g[f[i][k+1]].size()){
			for(int o:h=g[z])for(u[o].b=u[o].s=v[o].b=v[o].s=g[o]={},b[o]=1;y=f[o].back(),f[o].pop_back(),d[o].pop_back(),y!=z;);//清空
			m=o=h.size(),gr(z,0),wk(r);
			break;
		}
	}
	return 0;
}
```


---

## 作者：Kelin (赞：47)

题意:每次插入一个点,询问$dis_{(i,j)}\le r_i+r_j$的数量

①:假装这棵树是一开始给你的

树上路径问题$->$点分治

考虑重心$u$,答案就是$dis_{(i,u)}+dis_{(u,j)}\le r_i+r_j$的数量
移一个项$\Rightarrow dis_{(i,u)}-r_i\le r_j-dis_{(u,j)}$

把所有的$dis_{(i,u)}-r_i$插入$u$的平衡树,询问$u$的平衡树中$r_j-dis_{(u,j)}$的排名就好了

~~计算贡献什么的基本都是点分治的基本套路(其实主要是这部分大家都讲得很清楚了)~~

②:这棵树会动怎么做?

考虑用按照替罪羊树的思想,从这个点不断跳上一层重心,当满足$Sz_{i}\gt Sz_{fa_i}*\alpha$时就重构$fa_i$这棵树,当然$fa_i$要是最浅的

③:细节&卡常

听起来似乎好简单(想完题解后我也是这么想的),但是写起来写到怀疑人生

我们讲一讲这道题最要命的地方——细节&卡常

$1.$你需要一颗高效的平衡树,可能你$80-90$分,这时候换一颗平衡树说不定就卡过了;如果你用$Treap$的话不如手写随机会快一些

$2.$你需要一个平衡树的垃圾桶,因为这题重构是要清空这棵树以及这棵树上每个节点的平衡树的,这里会造成巨大的空间浪费(其实你不写垃圾桶你可能会被卡到$MLE$)

$3.$我稍微感受了一下平衡树写法的速度大概是这样的:结构体$\gt$指针$\gt$数组

其实想想也比较好理解吧

$4.$对于像我一样的手残党,一开始写代码的时候最好还是写到$namespace$里面吧,之前因为平衡树节点的$size$用$sz$当名字,然后点分治按照习惯也写的$sz$,后来发现重名了,然后就稍微改了一下,然后有一个地方没有改,但是他小数据跑出来了$exm?!?!$,然后调到绝望才找出来.什么你说那样不好看$?$你不知道先写完保证不错然后$ctrl+F$替换吗?

$5.$什么你问我为什么第一名那么快$?$其实主要是处理链的部分非常快

因为我们可以发现链完全不要像上面那么做

假设$1$是链的顶端,左右分别拉一条链,令$d_i=dis(1,i)$

考虑新加进来的点一定在链的底端,考虑两种情况

$d_u-d_i\le r_u+r_i\Rightarrow-d_i-r_i\le r_u-d_u,u$和$i$在同一边

$d_u+d_i\le r_u+r_i\Rightarrow d_i-r_i\le r_u-d_u,u$和$i$在不同边

所以你维护$4$棵平衡树就可以在$O(n\log n)$的时间内处理出答案了

注意要特判当$d_u\le r_1+r_u$时答案要减$1$

$6.$卡常有风险,$code$需谨慎

$7.$什么你说还不够快$?$那你可以用$bfs$来求重心,不要用$STL$,能放在一块的用结构体存起$\ldots$

---

## 作者：ywy_c_asm (赞：35)

### **题外话**

AC这题之后闲来无事翻了下提交记录发现仅仅两页之内就有至少10个人粘了同机房大神 @shadowice1984 的代码……可见这题乱象之严重。

### **这题的主要思路**

显然我们要在加入这个点$i$之后仅考虑有多少点能够跟他配成对就行了，毕竟我们的答案是不断累加的。

然后统计路径就是点分治，并且我们需要把点分树建出来，然后我们考虑其中一个连通块的重心$M$，按照点分治的套路我们需要统计经过$M$的所有路径吧，我们要找的点$P$是在$M$的其他子连通块里的，那么显然有：

$dis(P,M)-r_P<=r_i-dis(i,M)$

那么我们就在每个重心处开一棵平衡树维护**每个点到重心的距离-点权**即可，注意在动态点分治的查询中我们是**不能**扫一遍每个点在点分树上的子树的，那样会被菊花图卡，我们为了不让$P$出现在$i$所在的子树中，就接着在重心上开一棵平衡树维护**每个点到重心在点分树上的父亲的距离-点权**，统计答案的时候就在$M$的平衡树上与$i$所在的$M$的点分树儿子的平衡树上找一下有多少个比$r_i-dis(i,M)$小的，然后容斥一下让后者减去前者即可。

另外这题的另一个关键就是我们的点分树是相当于不那么正常的构建的（意思就是没用正常的点分治构建），显然这样不平衡的树高复杂度会被卡成暴力，其实点分树这玩意有点像K-D Tree，都是整个构造出来是非常理想的结构，然而单点插入就wei了，对于这种数据结构的套路就是替罪羊式暴力重构，我们设一个因子$\alpha$，当这个点的点分树儿子里的最大的$size$超过了自己的$size*\alpha$就暴力重构，怎么暴力重构呢？做一遍$O(nlog^2n)$的普通点分治……反正复杂度$O(\text{能过})$……

好，思路还是不难的。

### **实现细节**

**1.** 关于那个玄学的$\alpha$，我在正常的替罪羊树上设的都是$0.7$，然而那个暴力重构是$O(n)$的，这里是$O(nlog^2n)$的，代价比较大，所以$\alpha$必须调高一点（这样重构次数就会减少一些），实测$\alpha=0.7$时T成55分，开到$0.8$就能AC了。

**2.** 还是关于暴力重构的事情，我在正常的替罪羊树上的写法是这样的：

①.递归插入该点

②.回溯，发现该子树不平衡，暴力重构

③重构完接着回溯，重复②

其实这种写法是有缺陷的，在这种重构代价比较大的更能够体现出来，如果你重构完了一个点的子树，再重构一遍他的祖先，我们发现实际上重构不重构这个点并不会影响他的祖先的平衡效果，所以还不如直接重构他的祖先，所以我们可以遍历一遍插入的这个点到根的点分树上的链，找一个最靠上的不平衡点暴力重构就行了。

**3.** 这种错误是动态点分治上经常犯的，就是我们在点分治的时候一定要时刻想着当前扫的东西实际上是一个**连通块**而非一棵**真实的子树**，他的边界可不止一个点这么简单，所以在暴力重构之前我们要先对该点进行一遍bfs把这个连通块找出来，如果我们bfs到了一个点发现它在点分树上的深度还没有当前的点大那就说明这个点不属于这个连通块就把这个点标记为边界。

**4.** 因为我们在还没有重构的情况下仅有加点操作，$size$会只增不减，所以对$maxsize$的维护直接取$max$即可。并不用额外的开数据结构维护。

**5.** 我们在点分治的时候要维护**每个点到重心在点分树上父亲的距离**对吧，这个东西显然可以bfs，但是从哪里开始bfs呢？显然是父亲在原树上连的这个连通块里的点，显然不一定是重心。可是我们是在点分树上暴力重构啊，那么就对每个重心记一下这个连通块的哪个点被父亲所连着，就行了。（因为这毕竟不是正常的点分治）

**6.** 记得在平衡树上开垃圾回收。

~~此外我的平衡树用的也是替罪羊树……替罪羊套替罪羊还行~~

上代码~（自带超大常数……我开Ofast卡时过的……）

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	void print(ll num){
		if(num>=10)print(num/10);putchar(num%10+'0');
	}
	namespace bst{//替罪羊平衡树 
		ll data[5000001];
		int ch[5000001][2],size[5000001],cnt[5000001],gc[5000001],tmp[100001]； 
		int gptr=1,gcptr=0,gn=1;
		inline int getnew(){
			if(!gcptr){
				gn++;return(gn-1);
			}gcptr--;return(gc[gcptr]);
		}
		void dfs(int tree){
			if(!tree)return;dfs(ch[tree][0]);
			tmp[gptr]=tree,gptr++;dfs(ch[tree][1]);
		}
		int build(int l,int r){//平衡树暴力重构 
			if(l>r)return(0);
			int mid=(l+r)>>1;
			int tree=tmp[mid];
			ch[tree][0]=build(l,mid-1);
			ch[tree][1]=build(mid+1,r);
			size[tree]=cnt[tree]+size[ch[tree][1]]+size[ch[tree][0]];
			return(tree);
		}
		void insert(int &tree,ll num){
			if(!tree){
				tree=getnew();
				ch[tree][0]=ch[tree][1]=0;
				size[tree]=cnt[tree]=1;
				data[tree]=num;return;
			}
			if(data[tree]==num){
				size[tree]++;
				cnt[tree]++;return;
			}
			size[tree]++;
			insert(ch[tree][num>data[tree]],num);
			if(max(size[ch[tree][0]],size[ch[tree][1]])>=size[tree]*0.7)gptr=1,dfs(tree),tree=build(1,gptr-1);
		}
		void baodfs(int tree){
			if(!tree)return;
			gc[gcptr]=tree;gcptr++;
			baodfs(ch[tree][0]);
			baodfs(ch[tree][1]);
		}
		typedef struct _scg{//封装平衡树 
			int root;
			_scg(){root=0;}
			inline void insert(ll num){bst::insert(root,num);}
			inline int getrank(ll num){//找有多少小于等于num的 
				int ans=0,cur=root;
				while(cur&&data[cur]!=num){
					if(num>data[cur])ans+=cnt[cur]+size[ch[cur][0]],cur=ch[cur][1];
					else cur=ch[cur][0];
				}
				if(cur)ans+=cnt[cur]+size[ch[cur][0]];
				return(ans);
			}
			inline void clear(){//清空 
				baodfs(root);root=0;
			}
		}scg;
	}
	int cannot,gdeep;
	unsigned char bv[100001];//是否为标记过的边界 
	int yuan[100001];//当前连通块的跟父亲连着的点 
	typedef struct _b{
		int dest;int nxt;int len； 
	}bian;
	bian memchi[200001];
	int gn=1;int heads[100001];
	inline void add(int s,int t,int l){
		memchi[gn].dest=t;
		memchi[gn].nxt=heads[s];
		memchi[gn].len=l;
		heads[s]=gn;gn++;
	}
	bst::scg chs[100001],fas[100001];//两颗平衡树 
	int fa[100001],rdeep[100001];
	ll dis[100001][41],disfa[100001][41];
	int rsize[100001],mxsize[100001],size[100001],que[100001],que1[100001],head,tail,zx;
	void afs(int pt,int baba){//找重心 
		size[pt]=1;
		int mx=0;
		for(register int i=heads[pt];i;i=memchi[i].nxt){
			if(memchi[i].dest==baba||bv[memchi[i].dest])continue;
			afs(memchi[i].dest,pt);
			size[pt]+=size[memchi[i].dest];
			mx=max(mx,size[memchi[i].dest]);
		}
		if(max(tail-size[pt],mx)<=tail/2)zx=pt;
	}
	int fab[100001],cme[100001];
	int ints[100001];
	void digui(int pt,int baba,int babab,int deep,int link){//暴力点分治 
		head=0,tail=0;
		que1[tail]=pt;
		cme[pt]=0;tail++;
		do{//第一遍bfs初始化一波 
			int me=que1[head];head++;
			dis[me][deep]=disfa[me][deep]=0x7fffffffffffffff;
			for(register int i=heads[me];i;i=memchi[i].nxt){
				if(memchi[i].dest==baba||memchi[i].dest==cme[me]||bv[memchi[i].dest])continue;
				cme[memchi[i].dest]=me;
				que1[tail]=memchi[i].dest;tail++;
			}
		}while(head<tail);
		cannot=baba;
		zx=0;afs(pt,0);
		fa[zx]=baba;fab[zx]=babab;
		rdeep[zx]=deep;rsize[zx]=tail;
		yuan[zx]=link;
		mxsize[baba]=max(mxsize[baba],rsize[zx]);
		head=0,tail=1;
		que[0]=zx;
		dis[zx][deep]=0;
		chs[zx].clear();
		do{//第二遍bfs找到重心的距离 
			int me=que[head];cme[me]=0;head++;chs[zx].insert(dis[me][deep]-ints[me]);
			for(register int i=heads[me];i;i=memchi[i].nxt){
				if(dis[me][deep]+memchi[i].len<dis[memchi[i].dest][deep]&&!bv[memchi[i].dest]){
					dis[memchi[i].dest][deep]=dis[me][deep]+memchi[i].len;que[tail]=memchi[i].dest;tail++;
				}
			}
		}while(head<tail);
		fas[zx].clear();
		head=0;tail=1;
		que[0]=link;
		disfa[link][deep]=babab;
		do{//第三遍bfs找到重心父亲的距离 
			int me=que[head];head++;fas[zx].insert(disfa[me][deep]-ints[me]);
			for(register int i=heads[me];i;i=memchi[i].nxt){
				if(disfa[me][deep]+memchi[i].len<disfa[memchi[i].dest][deep]&&!bv[memchi[i].dest]){
					disfa[memchi[i].dest][deep]=disfa[me][deep]+memchi[i].len;
					que[tail]=memchi[i].dest;tail++;
				}
			}
		}while(head<tail);
		int me=zx;bv[zx]=1;
		for(register int i=heads[zx];i;i=memchi[i].nxt){
			if(memchi[i].dest==baba||bv[memchi[i].dest])continue;
			digui(memchi[i].dest,me,memchi[i].len,deep+1,memchi[i].dest);
		}
	}
	void ywymain(){
		get();
		int n=get();
		ll ans=0;
		for(register int i=1;i<=n;i++){
			int baba=get()^(ans%1000000000),len=get();
			ints[i]=get();
			if(baba)add(baba,i,len),add(i,baba,len);//先在原树上连边 
			chs[i].insert(-ints[i]);
			fas[i].insert(len-ints[i]);
			rdeep[i]=rdeep[baba]+1;rsize[i]=1;
			fa[i]=baba;fab[i]=len;
			disfa[i][rdeep[i]]=len;yuan[i]=i;//初始化该点，先让他直接在点分树上指向父亲 
			int cur=baba,pre=i;
			int cjr=0;
			while(cur){//统计答案 
				int dp=rdeep[cur];
				dis[i][dp]=dis[baba][dp]+len;
				disfa[i][dp]=disfa[baba][dp]+len;
				chs[cur].insert(dis[i][dp]-ints[i]);
				fas[cur].insert(disfa[i][dp]-ints[i]);
				ll ywy=chs[cur].getrank(ints[i]-dis[i][dp])-fas[pre].getrank(ints[i]-dis[i][dp]);
				ans+=ywy;
				rsize[cur]++;
				mxsize[fa[cur]]=max(mxsize[fa[cur]],rsize[cur]);
				if(mxsize[cur]>=rsize[cur]*0.8)cjr=cur;
				pre=cur;cur=fa[cur];
			}
			print(ans);putchar('\n');
			if(!cjr)continue;
			cur=cjr;cme[cur]=0;//重构cur 
			head=0;tail=1;que[0]=cur;
			do{//bfs把连通块标记一发 
				int me=que[head];head++;
				for(register int j=heads[me];j;j=memchi[j].nxt){
					if(rdeep[memchi[j].dest]>=rdeep[cur]&&memchi[j].dest!=cme[me]){
						cme[memchi[j].dest]=me;
						que[tail]=memchi[j].dest;tail++;
					}
					if(rdeep[memchi[j].dest]<rdeep[cur])bv[memchi[j].dest]=1;
				}
			}while(head<tail);
			for(register int j=0;j<tail;j++)bv[que[j]]=0,cme[que[j]]=0;
			bv[fa[cur]]=1;
			digui(cur,fa[cur],fab[cur],rdeep[cur],yuan[cur]);
		}
	}
}
int main(){
	ywy::ywymain();
	return(0);//再见程序 
}
```

---

## 作者：花淇淋 (赞：19)

**分析**


**动态点分治 $+$ treap $+$ 替罪羊树的思想**


容易看出，这题是一个动态的点分治。


静态的点分治是将重心作为分治中心，动态的分治，每次重心都会变，所以就不能以重心作为分治中心。


用重心作为分治中心，是因为这样最能省时间，那么是否可以不用重心呢，显然是可以的。


接下来说一说分治中心的问题。

![](https://cdn.luogu.com.cn/upload/pic/24550.png)

如图，1是一个分治中心，2,3,4是分出来的子树的分治中心。介绍一个概念：点分树，即所有分治中心形成的树结构。在这张图中，2,3,4在点分树中的父亲为1。


每个分治中心都会计算出一个答案进行累加。如果2的答案作了修改，说明以2为分治中心的子树出现变动，那么3,4的答案不用修改，而1的答案必定修改。


如果1是2,3,4在原树的父亲，同理，2,3,4互不关联，它们都和1有关联。


新插入一个叶结点，它在点分树中也可以作为叶子结点，而它在原树的父亲，也可以作为它在点分树上的父亲。


**因此，可以考虑把原树作为点分树。即：把根结点当作整棵树的分治中心，将根结点的子结点当作子树的分治中心。这样每次插入结点时，只要在点分树中找到它原树父亲的位置，插入这个结点作为叶子结点即可。**


但是，这样会导致点分树过度不平衡，比如说原树是一条链的情况，每次修改祖先结点的答案都会遍历整棵树。


可以利用替罪羊树的思想，当以某个结点为根的子树过度不平衡时将它重建。


**因为按重心分治是最省时间的，所以将这棵点分子树中的所有点进行一次静态的点分治，就相当于将这棵点分子树建成了近似的完全二叉树。**


分治中心的问题已经解决了，下面说一说怎么计算答案。


**设此时分治中心为u，则：**

$dist(i,j)<=ri+rj$ **变为** $dist(j,u)-rj<=ri-dist(i,u)$


**因此，可以对每个 $u$ 维护一个treap，存储所有 $dist(j,u)-rj$ 的值，查找 $ri-dist(i,u)$ 的排名，就是所有的情况。查找之后，要将 $dist(i,u)-ri$ 加入 $u$ 的treap，作为以后的 $j$.**


显然有非法的情况，如下图

![](https://cdn.luogu.com.cn/upload/pic/29621.png)

$i$到$j$ 的最短路径是不会经过 $u$ 的，但是可能满足 $dist(j,u)-rj<=ri-dist(i,u)$ ，这种情况非法，应该减掉。


所以对每个点再维护一个treap，存储这种非法的情况。


**如图所示，$u$ 是一个分治中心，$v$ 是子树的分治中心，结点 $i$和$j$ 在以 $v$ 为分治中心的子树中， $v$ 的第二个treap存储所有的 $dist(j,u)-rj$，可以查 $ri-dist(i,u)$ 的排名，即非法情况的数量。查完之后，要把 $dist(i,u)-ri$ 加入 $v$ 的第二个treap。**


**总的来说就是，每个点要存储它所有点分树上的祖先(包括它自己)的编号，以及它到祖先的距离。每次添加一个叶子，先连接它的父亲，可以根据它的父亲的信息，得到它的祖先们的信息。先根据上面的分析，在所有祖先结点中查排名，累计答案，再往所有祖先结点和它的treap加入结点。然后，再从深度浅到深遍历所有祖先结点，找到第一个不满足平衡条件的点，将它的子树中的所有点进行一次静态的点分治，相当于重建点分树。**


**代码如下**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

inline int read() //读入优化
{
    char ch; int res=0;
    while (ch = getchar(), ch < '0' || ch > '9');
    res = ch - 48;
    while (ch = getchar(), ch >= '0' && ch <= '9')
    res = res * 10 + ch - 48;
    return res;
}

const double alpha = 0.777666;
const int e = 1e5+5, mod = 1e9, inf = 0x3f3f3f3f, o = 4000006;
int test, n, r[e], fa[e], sze[e], son[e], num, next[e << 1];
int dist[e], head[e], go[e << 1], cost[e << 1];
long long ans = 0;
bool vis[e];
vector<int>anc[e], id[e], sons[e];

inline void add(int x, int y, int v) //建边 
{
    next[++num] = head[x]; 
    head[x] = num;
    go[num] = y;
    cost[num] = v;
    next[++num] = head[y];
    head[y] = num;
    go[num] = x;
    cost[num] = v;
}

int unused[o], top, pool, rt_self[e], rt_fa[e];

//当 grav 为分治中心时
//rt_self[grav]表示存储 dist(i, grav) - ri 的 treap 的根结点 
//设 grav 在点分树上的父亲为 f
//rt_fa[grav] 表示存储 dist(i, f) - ri 的根结点(非法情况)
 
struct node
{
    int lc, rc, val, s, pos;
}a[o];

inline void reset(int &x, int v)
{
    a[x].lc = a[x].rc = 0;
    a[x].val = v;
    a[x].s = 1;
    a[x].pos = rand();
}

inline void update(int &x)
{
    a[x].s = a[a[x].lc].s + a[a[x].rc].s + 1;
}

inline int new_node()
{
    int res;
    if (top > 0)
    {
        res = unused[top]; //将用过的并且删过的点的编号放入 unused
        top--;     //新建节点的时候可以再使用这些编号，可以省空间
    }
    else res = ++pool;
    return res;
}

inline void del_node(int &u)
{
    if (!u) return;
    unused[++top]=u;
    a[u].val = a[u].s = a[u].pos = 0;
    if (a[u].lc) del_node(a[u].lc);
    if (a[u].rc) del_node(a[u].rc);
    u = 0;
}

inline void zig(int &u)
{
    int v = a[u].lc;
    a[u].lc = a[v].rc;
    a[v].rc = u;
    a[v].s = a[u].s;
    update(u);
    u = v;
}

inline void zag(int &u)
{
    int v = a[u].rc;
    a[u].rc = a[v].lc;
    a[v].lc = u;
    a[v].s = a[u].s;
    update(u);
    u = v;
}

inline void insert(int &u,int v)
{
    if (!u)
    {
        u = new_node();
        reset(u, v);
        return;
    }
    a[u].s++;
    if (v <= a[u].val)
    {
        insert(a[u].lc, v);
        if (a[a[u].lc].pos < a[u].pos) zig(u);
    }
    else
    {
        insert(a[u].rc, v);
        if (a[a[u].rc].pos < a[u].pos) zag(u);
    }
}

inline int qrank(int u, int v)
{
    if (!u) return 0;
    if (v < a[u].val) return qrank(a[u].lc, v);
    else return a[a[u].lc].s + 1 + qrank(a[u].rc, v);
}

inline int calc_grav(int &st) //求树的重心
{
    static int qn, que[e];
    que[qn = 1] = st;
    fa[st] = 0;
    for (int i = 1; i <= qn; i++)
    {
        int u = que[i];
        sze[u] = 1;
        son[u] = 0;
        for (int j = head[u]; j; j = next[j])
        {
            int v = go[j];
            if(!vis[v] || v == fa[u])continue;
            fa[v] = u;
            que[++qn] = v;
        }
    }
    for (int i = qn; i >= 2; i--)
    {
        int u = que[i], v = fa[u];
        sze[v] += sze[u];
        if (sze[u] > son[v])
        son[v] = sze[u];
    }
    int all = sze[st], grav = 0, min = inf;
    for (int i = 1; i <= qn; i++)
    {
        int u = que[i];
        if (all - sze[u] > son[u])
        son[u] = all - sze[u];
        if (son[u] < min)
        {
            min = son[u];
            grav = u;
        }
    }
    return grav;
}

inline void dac(int &st, int &par) //静态点分治，用于重建 
{
    static int qn, que[e];
    int grav = calc_grav(st);
    vis[grav] = false; // vis[] = false 表示当前这个点已经当过分治中心
    que[qn = 1] = grav;
    fa[grav] = 0;
    dist[grav] = 0;
    for (int i = 1; i <= qn; i++)
    {
        int u = que[i];
        for (int j = head[u]; j; j = next[j])
        {
            int v = go[j];
            if (!vis[v] || v == fa[u]) continue;
            fa[v] = u;
            dist[v] = dist[u] + cost[j];
            que[++qn] = v;
        }
    }
    for (int i = 1; i <= qn; i++)
    {
        int u = que[i];
        id[u].push_back(grav);
        //id[u][i] 表示 u 在点分树的所有祖先中(包括它自己)第 i 老的编号 
        anc[u].push_back(dist[u]); //anc[u][i] 就是 dist(u, id[u][i]) 
        //id[u][i] 是 id[u][i+1] 点分树中的父亲，anc 同理 
        sons[grav].push_back(u); //sons[u] 存储在点分树中u的子树的所有节点
        insert(rt_self[grav], dist[u] - r[u]); //所有情况
        if (par != 0)
        insert(rt_fa[grav], anc[u][anc[u].size() - 2] - r[u]); //非法情况 
    }
    for (int i = head[grav]; i; i = next[i])
    {
        int v = go[i];
        if (vis[v]) dac(v, grav);
    }
}

inline void rebuild(int &u, int par) //重建点分树的某一子树 
{
    vector<int>tmpson = sons[u];
    //要先把原来的 sons[u] 存了，因为下面 sons[v].clear
    int notres = anc[par].size(), len = tmpson.size();
    for (int i = 0; i < len; i++) //先把这棵子树部分的信息删了
    {
        int v = tmpson[i];
        vis[v] = true;
        sons[v].clear();
        anc[v].resize(notres); //仅与子树的根结点的祖先们有关的信息还要留着
        id[v].resize(notres);
        del_node(rt_self[v]);
        del_node(rt_fa[v]);
    }
    dac(u, par); //再将这棵子树中的所有点进行一次静态的点分治
}

inline void check(int &u)
{
	int len = anc[u].size();
    for (int i = 0; i < len; i++)
    {
        insert(rt_self[id[u][i]], anc[u][i] - r[u]);
        //所有祖先的 treap (包括它自己的)都要插入新结点
        if (i != 0)
        insert(rt_fa[id[u][i]], anc[u][i - 1] - r[u]);
    }
    for (int i = 0; i < len - 1; i++)
    {
        int sze_fa = a[rt_self[id[u][i]]].s;
        int sze_son = a[rt_self[id[u][i + 1]]].s;
        if (sze_fa <= 30)break;
        if (sze_son > alpha * sze_fa) //过度不平衡，重建
        {
            rebuild(id[u][i], i == 0 ? 0 : id[u][i - 1]);
            break;
        }
    }
}

inline int calc_ans(int &u, int &v, int &w)
{
    int res = 0;
    anc[u] = anc[v]; //当前结点的父亲的祖先也是它的祖先 
    id[u] = id[v]; //存储的信息先由它父亲得来 
    anc[u].push_back(-w); //和 += w 抵消
    id[u].push_back(u);
    int len = anc[u].size();
    for (int i = 0; i < len; i++)
    {
        anc[u][i] += w;
        sons[id[u][i]].push_back(u);
        res += qrank(rt_self[id[u][i]], r[u] - anc[u][i]);
        //查询 r[u] - dist(u, id[u][i]) 的排名，即所有的情况
        if (i != 0)
        res -= qrank(rt_fa[id[u][i]], r[u] - anc[u][i - 1]);
        //查询 r[u] - dist(u, id[u][i] 的父亲) 的排名，即非法情况
    }
    return res;
}

int main()
{
    test = read();
    n = read();
    for (int i = 1; i <= n; i++)
    {
        int fa_i = read(), c = read();
        r[i] = read();
        fa_i ^= (ans % mod);
        if(i == 1)
        {
            anc[i].push_back(0);
            id[i].push_back(i);
            sons[i].push_back(i);
            insert(rt_self[i], -r[i]); //第一个结点 dist 为 0  
            puts("0");
            continue;
        }
        add(fa_i, i, c);
        ans += calc_ans(i, fa_i, c); //累加包含当前结点且满足条件的点对的个数
        check(i); //往所有祖先结点和它的 treap 加入结点
        //并检查是否存在过度不平衡现象
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：lhm_ (赞：11)

对于本题这样带修的树上路径问题，考虑用动态点分治来解决。

将题目中给的式子变形得：

$$
\begin{aligned} 
	val_x + val_y \geqslant dis_{x,y} \\
    
    val_y \geqslant dis_{x,y} - val_x
\end{aligned}
$$

对于点分树上的每个节点 $x$ 维护 $dis_{x,y} - val_x$，$y$ 为在点分树上其子树内的节点。查询时只需考虑对于当前子树，维护的权值小于等于插入的节点权值的个数。

考虑到时空限制，点分树上每个节点用平衡树来维护信息，并且还需使用快速的 $Treap$ 或者替罪羊树。在点分树上向上跳时，查询其在点分树上的祖先时，为了避免算重，还需减去其子节点对应连通块的贡献，这里对每个节点再维护一个平衡树即可。

在不断插入节点后，点分树会越来越不平衡，可以应用替罪羊树的思想，当一个节点子树大小和其父亲节点子树大小满足不平衡的判定关系后，就对该子树进行重构，对节点上维护的平衡树进行垃圾回收，只对这个连通块进行点分治，维护好信息后再连接回去即可。为了方便处理，对点分树上每个点的子节点进行记录。

实现时，我对于原树，平衡树，点分树使用了三个结构体来维护，便于操作和调试，平衡树用的 $Treap$，用结构体封装后会显著变快。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 200010
#define maxm 4000010
#define mod 1000000000
#define alpha 0.76
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n;
ll ans;
struct Graph
{
    int d[maxn],de[maxn],f[maxn][20],val[maxn];
    struct edge
    {
        int to,nxt,v;
    }e[maxn];
    int head[maxn],edge_cnt;
    void add(int from,int to,int val)
    {
        e[++edge_cnt]=(edge){to,head[from],val};
        head[from]=edge_cnt;
    }
    void insert(int x,int fa,int v)
    {
        if(fa) add(fa,x,v),add(x,fa,v);
        f[x][0]=fa,de[x]=de[fa]+1,d[x]=d[fa]+v;
        for(int i=1;i<=17;++i) f[x][i]=f[f[x][i-1]][i-1];
    }
    int lca(int x,int y)
    {
        if(de[x]<de[y]) swap(x,y);
        for(int i=17;i>=0;--i)
            if(de[f[x][i]]>=de[y])
                x=f[x][i];
        if(x==y) return x;
        for(int i=17;i>=0;--i)
            if(f[x][i]!=f[y][i])
                x=f[x][i],y=f[y][i];
        return f[x][0];
    }
    int dis(int x,int y)
    {
        return d[x]+d[y]-d[lca(x,y)]*2;
    }
}G;
struct Treap
{
    int tot,top;
    int st[maxm];
    struct node
    {
        int val,key,cnt,siz;
        int ch[2];
    }t[maxm];
    int add(int v)
    {
        int x;
        if(top) x=st[top--];
        else x=++tot;
        t[x].ch[0]=t[x].ch[1]=0,t[x].val=v,t[x].key=rand(),t[x].siz=t[x].cnt=1;
        return x;
    }
    void del(int x)
    {
        if(!x) return;
        st[++top]=x,del(t[x].ch[0]),del(t[x].ch[1]);
    }
    void pushup(int x)
    {
        t[x].siz=t[t[x].ch[0]].siz+t[t[x].ch[1]].siz+t[x].cnt;
    }
    void rotate(int &x,int k)
    {
        int y=t[x].ch[k^1];
        t[x].ch[k^1]=t[y].ch[k],t[y].ch[k]=x;
        pushup(x),pushup(y),x=y;
    }
    void insert(int &x,int v)
    {
        if(!x)
        {
            x=add(v);
            return;
        }
        if(v==t[x].val)
        {
            t[x].cnt++,pushup(x);
            return;
        }
        int k=(v>t[x].val);
        insert(t[x].ch[k],v);
        if(t[x].key<t[t[x].ch[k]].key) rotate(x,k^1);
        pushup(x);
    }
    int query(int x,int v)
    {
        if(!x) return 0;
        if(v<t[x].val) return query(t[x].ch[0],v);
        return t[t[x].ch[0]].siz+t[x].cnt+query(t[x].ch[1],v);
    }
}Tr;
struct Tree
{
    int tot,root;
    int siz[maxn],ma[maxn],fa[maxn],rt1[maxn],rt2[maxn];
    bool vis[maxn];
    vector<int> ve[maxn];
    void dfs_root(int x,int fath)
    {
        siz[x]=1,ma[x]=0;
        for(int i=G.head[x];i;i=G.e[i].nxt)
        {
            int y=G.e[i].to;
            if(vis[y]||y==fath) continue;
            dfs_root(y,x),siz[x]+=siz[y];
            ma[x]=max(ma[x],siz[y]);
        }
        ma[x]=max(ma[x],tot-siz[x]);
        if(ma[x]<ma[root]) root=x;
    }
    void dfs_dis(int x,int fath,int dis,int id)
    {
        Tr.insert(rt1[id],dis-G.val[x]);
        if(fa[id]) Tr.insert(rt2[id],G.dis(x,fa[id])-G.val[x]);
        for(int i=G.head[x];i;i=G.e[i].nxt)
        {
            int y=G.e[i].to;
            if(vis[y]||y==fath) continue;
            dfs_dis(y,x,dis+G.e[i].v,id);
        }
    }
    void solve(int x)
    {
        int now=tot;
        vis[x]=true,dfs_dis(x,0,0,x);
        for(int i=G.head[x];i;i=G.e[i].nxt)
        {
            int y=G.e[i].to;
            if(vis[y]) continue;
            root=0,tot=siz[y];
            if(siz[y]>siz[x]) tot=now-siz[x];
            dfs_root(y,x),fa[root]=x,ve[x].push_back(root),solve(root);
        }
    }
    void del(int x)
    {
        vis[x]=false;
        for(int i=0;i<ve[x].size();++i) del(ve[x][i]);
        Tr.del(rt1[x]),Tr.del(rt2[x]),rt1[x]=rt2[x]=0,ve[x].clear();
    }
    void rebuild(int x)
    {
        root=0,tot=Tr.t[rt1[x]].siz,del(x),dfs_root(x,0);
        for(int i=0;i<ve[fa[x]].size();++i)
            if(ve[fa[x]][i]==x)
                ve[fa[x]][i]=root;
        fa[root]=fa[x],solve(root);
    }
    void insert(int x,int fath)
    {
        fa[x]=fath,ve[fath].push_back(x),vis[x]=true;
        for(int i=x;i;i=fa[i])
        {
            if(fa[i])
            {
                int d=G.dis(fa[i],x);
                ans+=Tr.query(rt1[fa[i]],G.val[x]-d)-Tr.query(rt2[i],G.val[x]-d);
                Tr.insert(rt2[i],d-G.val[x]);
            }
            Tr.insert(rt1[i],G.dis(i,x)-G.val[x]);
        }
        int p=0;
        for(int i=x;fa[i];i=fa[i])
            if(Tr.t[rt1[i]].siz>Tr.t[rt1[fa[i]]].siz*alpha)
                p=fa[i];
        if(p) rebuild(p);
    }
}T;
int main()
{
    read(n),read(n),T.ma[0]=n;
    for(int i=1;i<=n;++i)
    {
        int fa,v;
        read(fa),read(v),read(G.val[i]),fa^=ans%mod;
        G.insert(i,fa,v),T.insert(i,fa),printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：cyffff (赞：9)

[$\text{Link}$](https://www.luogu.com.cn/problem/P3920)
## 题意
给 $n$ 次操作，每次操作加入一个节点 $k$，给出 $k$ 的父亲、$k$ 与父亲之间的边权、$k$ 的点权 $r_k$，操作后求出 $|\{(i,j)|1\le i<j\le k\text{ and }r_i+r_j\ge\text{dis}(i,j)\}|$。强制在线。

$n\le 10^5$。
## 思路
首先思考一个弱化问题：给一棵树，求出答案。

我们可以思考点分治，设当前分治中心为 $u$。对于在不同子树中的 $i$ 和 $j$，$\text{dis}(i,j)=\text{dis}(i,u)+\text{dis}(j,u)$，则答案转为统计 $r_i+r_j\ge \text{dis}(i,u)+\text{dis}(u,j)$ 的对数。

我们将式子移项得到 $r_i-\text{dis}(i,u)\ge\text{dis}(u,j)-r_j$。我们可以使用一个数据结构，支持插入和求排名操作，可以直接使用平衡树，也可以离散化使用权值线段树、权值树状数组维护 $u$ 所有的 $\text{dis}(u,j)-r_j$，查询 $r_i-\text{dis}(i,u)$ 的排名即可。

考虑强制在线后怎么做，显然我们有点分树，可以动态维护点分治。

但是问题来了：我们动态加点，怎么维护点分树的形态呢？

考虑点分树的复杂度是怎么来的：点分树每个节点的父节点是上层分治取的重心，保证了点分树树高为 $O(\log n)$，使得操作复杂度为 $O(\log n)\times O(ds)$。我们可以首先向直接使用原树作为点分树的方向思考，树高 $O(n)$，显然不行，只能得到 $30\text{pts}$。考虑维护点分树上的子树大小，使用替罪羊树的思想，设定平衡因子 $\alpha$，当 $siz_i>siz_{f_i}\times \alpha$ 时暴力重构这颗点分树子树，此处重构指对这部分子树进行点分治建出点分树。

对于这个算法数据结构的选用提一句：由于强制在线的缘故，无法离散化使用树状数组、线段树，如果使用平衡树的话：重构中重新插入 $O(\log n)$，树高 $O(\log n)$，会重构 $O(\log n)$ 次，时间复杂度 $O(n\log^3n)$，再加上平衡树的大常数可能需要卡常。

我们可以使用一种定期重构的数据结构：由于只需要清空、插入、求排名，可以使用两个 `vector` $a$ 和 $b$，每次暴力在 $b$ 中插入，当 $b$ 的大小超过预订的阀值 $S$ 时，$O(n)$ 将 $b$ 合并进 $a$ 中，查询排名直接在两个 `vector` 中 `upper_bound` 即可。

算一下时间复杂度，询问 $O(n\log n)\times O(\log n)=O(n\log^2n)$，插入 $O(n\log^2nS+\dfrac{n^2\log^2n}{S})$，$S$ 取 $O(\sqrt n)$ 得复杂度 $O(n\sqrt n\log^2 n)$。看似复杂度变差了，但由于 `vector` 自带的超小常数，反而跑得挺快，完全不需要卡常。

不知道为什么 $\alpha$ 取 $0.95$ 跑得最快。

最后贴一下代码吧：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff

}
const int N=1e5+10,S=350,INF=1e7+10;
const double alpha=0.95; 
//like the Scapegoat_Tree to rebuild
int head[N],sz[N],cnt,n,r[N];
bool vis[N];
struct Edge{
	int to,nxt,val;
}a[N<<1];
inline void add(int u,int v){
	cnt++;
	a[cnt].to=v;
	a[cnt].nxt=head[u];
	head[u]=cnt;
}
inline pair<int,int> findroot(int rt,int f,int pre){
	sz[rt]=1;
	int mx=0;
	pair<int,int> ans=make_pair(INF,0);
	for(int i=head[rt];i;i=a[i].nxt){
		int t=a[i].to;
		if(vis[t]||t==f) continue;
		ans=min(ans,findroot(t,rt,pre));
		sz[rt]+=sz[t];
		mx=max(mx,sz[t]);
	}
	ans=min(ans,make_pair(max(mx,pre-sz[rt]),rt));
	return ans;
}
struct Dis{
	int f[17][N],dep[N],des[N];
	inline void insert(int x,int fa,int c){
		f[0][x]=fa;
		dep[x]=dep[fa]+1;
		des[x]=des[fa]+c;
		for(int i=1;i<=16;i++){
			f[i][x]=f[i-1][f[i-1][x]];
		}
	}
	inline int LCA(int x,int y){
		if(dep[x]<dep[y]) swap(x,y);
		for(int i=16;~i;i--){
			if(dep[f[i][x]]>=dep[y]){
				x=f[i][x];
			}
		}
		if(x==y) return x;
		for(int i=16;~i;i--){
			if(f[i][x]!=f[i][y]){
				x=f[i][x],y=f[i][y];
			}
		}
		return f[0][x];
	}
	inline int dis(int x,int y){
		return des[x]+des[y]-2*des[LCA(x,y)];
	}
}bz;
struct Data_Structer{
	vector<int>a,b;
	inline void insert(int x){
		b.insert(lower_bound(b.begin(),b.end(),x),x);
		if(b.size()>=S){
			vector<int>c,d;
			//use 3 not 1 or UB in O2
			int i=0,j=0;
			for(;i<a.size()&&j<b.size();){
				if(a[i]<b[j]){
					c.push_back(a[i++]);
				}else{
					c.push_back(b[j++]);
				}
			}
			while(i<a.size()){
				c.push_back(a[i++]);
			}
			while(j<b.size()){
				c.push_back(b[j++]);
			}
			swap(a,c);
			swap(b,d);
		}
	}
	inline int rank(int x){
		return (upper_bound(a.begin(),a.end(),x)-a.begin())+(upper_bound(b.begin(),b.end(),x)-b.begin())-2;
	}
	inline void clear(){
		a.clear(),b.clear();
	}
}pa[N<<1],pb[N<<1];
//smile
//pa:when i is root pb:subtree f_i->i
struct Point_Divide_Tree{
	int f[N],dep[N],siz[N];
	//point x value v in subtree Rt
	//insert -r into DS count dis(j,u)-r_j≤r_i-dis(i,u)
	inline int query(int x,int r){
		int ans=0;
		for(int i=x,j;f[i];i=j){
			j=f[i];
			int dis=r-bz.dis(x,j);
			ans+=pa[j].rank(dis)-pb[i].rank(dis);
		}
		return ans;
	}
	inline void insert(int x,int v,int Rt){
		pa[x].insert(-v);
		for(int i=x,j;i!=Rt;i=j){
			j=f[i];
			int dis=bz.dis(x,j)-v;
			if(j!=Rt) pa[j].insert(dis);
			pb[i].insert(dis);
		}
	}
	//clear "vis" thats dep[i]>deps(rebuild Rt)
	inline void clear(int x,int fa,int deps){
		vis[x]=0;
		for(int i=head[x];i;i=a[i].nxt){
			int t=a[i].to;
			if(t!=fa&&dep[t]>deps){
				clear(t,x,deps);
			}
		}
	}
	//build subtree Rt
	inline int build(int x,int pre,int fa,int Rt){
		int rt=findroot(x,0,pre).second,bas=sz[x];
		pa[rt].clear();
		pb[rt].clear();
		f[rt]=fa;
		siz[rt]=1;
		vis[rt]=1;
		dep[rt]=dep[fa]+1;
		insert(rt,r[rt],Rt);
		for(int i=head[rt];i;i=a[i].nxt){
			int t=a[i].to;
			if(!vis[t]){
				siz[rt]+=build(t,bas,rt,Rt);
			}
		}
		return siz[rt];
	}
	//rebuild subtree x
	inline void rebuild(int x){
		if(!x) return ;
		clear(x,0,dep[x]);
		build(x,siz[x],f[x],f[x]);
	}
	inline void insert(int x,int v){
		pa[x].insert(-v);
		siz[x]++;
		int Rt=0;
		for(int i=x,j;f[i];i=j){
			j=f[i];
			int dis=bz.dis(x,j)-v;
			siz[j]++;
			pa[j].insert(dis);
			pb[i].insert(dis);
			if(siz[i]>siz[j]*alpha){
				Rt=j;
			}
		}
		rebuild(Rt);
	}
}t;
int main(){
	ll last=0;
	read();
	n=read();
	for(int i=1;i<=n;i++){
		vis[i]=1;
		int fa=read()^last%1000000000,c=read();
		r[i]=read();
		bz.insert(i,fa,c);
		if(i>1){
			add(fa,i);
			add(i,fa);
		}
		t.f[i]=fa;
		t.dep[i]=t.dep[fa]+1;
		write(last+=t.query(i,r[i]));
		t.insert(i,r[i]);
		putc('\n');
	}
	flush();
}
/*
Time:52.31s
Memory:162.77MB
*/
```
再见 qwq~

---

## 作者：letitdown (赞：8)

发现题解区的大佬们讲解重构点分树部分蒟蒻不是很能理解，当时就是卡在了如何重构部分，于是来写一篇题解。

题意大概就是给出一棵支持插入点的树，每个点有和自己父亲的距离 $w_i$ 和自己的探索半径 $r_i$，问每次插入一个新的点之后有多少对点满足 $r_i+r_j\geq dis(i,j)$。

首先我们可以记录一个答案变量，每次加入新点时统计这个新点的贡献就可以了。由于答案和树的形态无关，所以可以考虑建造点分树。

那么我们一步一步来：

### 统计贡献
我们设 $d_i$ 表示 i 点到点分树上某个父亲节点的距离，那么上面的式子就变成了 $r_i+r_j\geq d_i+d_j$ ，移个项就变成了 $r_i-d_i\geq d_j-r_j$，所以可以在点分树每个点上用平衡树维护子树内的 $d_i-r_i$,如果要累加答案就在点分树上暴力跳父亲，统计满足 $d_j-r_j\leq r_i-d_i$ 的 j 的个数即可。然后更新父亲信息，暴力跳父亲把自己的 $d_i-r_i$ 插到父亲的平衡树里面。

为了避免一个子树内在父亲处的互相配对，我们对每个点再另外开一棵平衡树维护自己子树对父亲的贡献，统计答案时再减去即可。于是我们维护了两颗替罪羊树，把上面那个叫做 1 号，这个叫做 2 号树。

另外考虑如何计算 $d_i$，我们发现倍增可以很好的实现这个操作，于是加入一个点的时候处理一下它的倍增数组就行了。

### 重构点分树
我们在插入一个点的时候在点分树上也是直接把它插到原树父亲上面，所以这样会导致点分树在插入一些点之后可能会出现不平衡的情况，评判标准是某个子树的大小超过了自己的总的子树的大小乘上一个值 $\alpha$。

这样的话就需要我们去重构点分树。重构点分树在原树上的表现是重构一个连通块，但是在点分树上的表现就是重构一个子树，所以我们发现一个点在点分树上面的子树不平衡时，直接遍历一遍它在点分树上面的子树，然后重新找这个点分树上的重心，重新连边建树即可。

再具体一点就是，我们把子树内的所有点遍历一边(bfs,dfs 都可以)，然后把当前点的平衡树所有节点清空回收，重新计算一遍它的子树大小，然后重建的时候再次暴力跳父亲，把自己的所有信息重新插到父亲节点的平衡树里，但是注意这里就不是一直跳父亲跳到头了，而是只跳到被重构的最浅的那个父亲为止，因为再上面的父亲肯定已经包含过自己的信息，而且子树重构不会改变对这些父亲的影响（因为反正都是从被重构的这个子树跳过来的，怎么跳过来无所谓）。

这样的话，我们就可以一边重建子树，一边把信息传递给父亲，让点分树重新平衡下来。

然后这里的平衡树我用的是替罪羊树，由于重构点分树代价比较大，可以把替罪羊树和点分树的 $\alpha$ 都设成 0.8。

有道重构点分树的题可以练练手： [link](https://www.luogu.com.cn/problem/P6541)

### 一些小细节
1. 我们发现重构点分树和替罪羊树时如果自己子树不平衡，自己的父亲子树也不平衡时直接重构自己父亲的子树就可以了，因为如果重构自己子树，自己的父亲还是会不平衡，所以还不如直接重构父亲，这样也可以让自己平衡。这样的话我们每次如果要重构就找到最上面的不平衡的父亲重构即可。
2. 重构点分树时，清空替罪羊树的节点后可以回收到内存池中，重复利用，这样可以避免内存爆炸。
3. 由于 1 号节点处理答案时有一些奇奇怪怪的问题所以可以拿出来单独判断处理。
4. 边权很大所以要开 long long。
5. 在清空子树时一定要判一下当前节点不是 0 再扔到内存池里面，否则会把 0 扔进去，然后一个节点 pushup 的时候就会把0的信息统计进去，然后就会炸裂，~~别问我怎么知道的~~

然后就没了。放一下代码：


```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
namespace EMT{
	typedef long long ll;typedef double db;
	#define pf printf
	#define F(i,a,b) for(int i=a;i<=b;i++)
	#define D(i,a,b) for(int i=a;i>=b;i--)
	inline ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void file(){freopen("in.in","r",stdin);freopen("my.out","w",stdout);}
	inline int max(int a,int b){return a>b?a:b;}inline int min(int a,int b){return a<b?a:b;}
	inline void pi(ll x){pf("%lld ",x);}inline void pn(){pf("\n");}
	const int N=1e5+10,mod=1e9;const db alp=0.8;
	int head[N],co,n,r[N];struct node{int next,to,w;}e[N<<1];
	ll ans;
	namespace times{
		int f[N][20],log[N],deep[N];ll pre[N];
		inline void init(){
			log[0]=-1;
			F(i,1,n)log[i]=log[i>>1]+1;
		}
		inline void add(int next,int to,int w){
			e[++co]={head[next],to,w},head[next]=co;
			e[++co]={head[to],next,w},head[to]=co;
			int x=next,y=to;f[y][0]=x,deep[y]=deep[x]+1;pre[y]=pre[x]+w;
			F(i,1,log[deep[y]])f[y][i]=f[f[y][i-1]][i-1];
		}
		inline int getlca(int a,int b){
			if(deep[a]<deep[b])a^=b^=a^=b;
			D(i,log[deep[a]-deep[b]],0)if((1<<i)<=deep[a]-deep[b])a=f[a][i];
			if(a==b)return a;
			D(i,log[deep[a]],0)if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i];
			return f[a][0];
		}
		inline ll getdis(int x,int y){return pre[x]+pre[y]-pre[getlca(x,y)]*2;}
	}
	namespace sgt{
		int rt[N],tot,ls[N*60],rs[N*60],s[N*60],top,rec[N];
		struct dp{ll val;int psiz,rsiz,cnt;}t[N*60];
		inline int New(){if(top)return s[top--];return ++tot;}
		inline void pia(int p){
			if(!p)return;
			if(ls[p])pia(ls[p]);
			rec[++rec[0]]=p;
			if(rs[p])pia(rs[p]);
		}
		inline void clear(int &p){
			if(!p)return;
			if(ls[p])clear(ls[p]);
			if(rs[p])clear(rs[p]);
			s[++top]=p;t[p].cnt=t[p].rsiz=t[p].psiz=0;
			p=0;
		}
		inline void up(int p){
			if(!p)return;
			t[p].psiz=t[ls[p]].psiz+t[rs[p]].psiz+1;
			t[p].rsiz=t[ls[p]].rsiz+t[rs[p]].rsiz+t[p].cnt;
		}
		inline int rebuild(int l,int r){
			if(l>r)return 0;
			int mid=(l+r)>>1,p=rec[mid];
			ls[p]=rebuild(l,mid-1),rs[p]=rebuild(mid+1,r);
			up(p);return p;
		}
		inline bool check(int &p){
			if(t[p].psiz*alp<max(t[ls[p]].psiz,t[rs[p]].psiz)){
				rec[0]=0,pia(p),p=rebuild(1,rec[0]);return 1;
			}return 0;
		}
		inline void ins(int &p,ll v){
			if(!p){p=New(),t[p].psiz=t[p].rsiz=t[p].cnt=1,t[p].val=v,ls[p]=rs[p]=0;up(p);return;}
			if(t[p].val==v){t[p].cnt++;up(p);return;}
			if(t[p].val<v)ins(rs[p],v);else ins(ls[p],v);up(p);
			return;
		}
		inline void dfs(int &p,ll v){
			if(!p)return;
			if(check(p))return;
			if(t[p].val==v)return;
			if(t[p].val<v)dfs(rs[p],v);
			else dfs(ls[p],v);
		}
		inline int ask(int p,ll v){
			if(!p)return 0;
			if(t[p].val==v)return t[p].cnt+t[ls[p]].rsiz;
			if(t[p].val>v)return ask(ls[p],v);
			return ask(rs[p],v)+t[p].cnt+t[ls[p]].rsiz;
		}
		inline void insert(int &p,ll v){ins(p,v),dfs(p,v);}
	}
	namespace sgt2{
		int rt[N],tot,ls[N*60],rs[N*60],s[N*60],top,rec[N];
		struct dp{ll val;int psiz,rsiz,cnt;}t[N*60];
		inline int New(){if(top)return s[top--];return ++tot;}
		inline void pia(int p){
			if(!p)return;
			if(ls[p])pia(ls[p]);
			rec[++rec[0]]=p;
			if(rs[p])pia(rs[p]);
		}
		inline void clear(int &p){
			if(!p)return;
			if(ls[p])clear(ls[p]);
			if(rs[p])clear(rs[p]);
			s[++top]=p;t[p].cnt=t[p].rsiz=t[p].psiz=0;
			p=0;
		}
		inline void up(int p){
			if(!p)return;
			t[p].psiz=t[ls[p]].psiz+t[rs[p]].psiz+1;
			t[p].rsiz=t[ls[p]].rsiz+t[rs[p]].rsiz+t[p].cnt;
		}
		inline int rebuild(int l,int r){
			if(l>r)return 0;
			int mid=(l+r)>>1,p=rec[mid];
			ls[p]=rebuild(l,mid-1),rs[p]=rebuild(mid+1,r);
			up(p);return p;
		}
		inline bool check(int &p){
			if(t[p].psiz*alp<max(t[ls[p]].psiz,t[rs[p]].psiz)){
				rec[0]=0,pia(p),p=rebuild(1,rec[0]);return 1;
			}return 0;
		}
		inline void ins(int &p,ll v){
			if(!p){p=New(),t[p].psiz=t[p].rsiz=t[p].cnt=1,t[p].val=v,ls[p]=rs[p]=0;up(p);return;}
			if(t[p].val==v){t[p].cnt++;up(p);return;}
			if(t[p].val<v)ins(rs[p],v);else ins(ls[p],v);up(p);
		}
		inline void dfs(int &p,ll v){
			if(!p)return;
			if(check(p))return;
			if(t[p].val==v)return;
			if(t[p].val<v)dfs(rs[p],v);
			else dfs(ls[p],v);
		}
		inline int ask(int p,ll v){
			if(!p)return 0;
			if(t[p].val==v)return t[p].cnt+t[ls[p]].rsiz;
			if(t[p].val>v)return ask(ls[p],v);
			return ask(rs[p],v)+t[p].cnt+t[ls[p]].rsiz;
		}
		inline void insert(int &p,ll v){ins(p,v),dfs(p,v);}
	}
	namespace tree{
		int fa[N],siz[N],maxn,mx[N],rt,deep[N];bool vis[N];
		inline void getans(int x){
			if(times::pre[x]<=r[x]+r[1])ans++;
			for(int i=fa[x];i;i=fa[i])ans+=sgt::ask(sgt::rt[i],r[x]-times::getdis(x,i));
			for(int i=fa[x];fa[i];i=fa[i])ans-=sgt2::ask(sgt2::rt[i],r[x]-times::getdis(x,fa[i]));
		}
		inline void add(int x){
			for(int i=x;i;i=fa[i])sgt::insert(sgt::rt[i],times::getdis(x,i)-r[x]),siz[i]++;
			for(int i=x;fa[i];i=fa[i])sgt2::insert(sgt2::rt[i],times::getdis(x,fa[i])-r[x]);
		}
		inline void clear(int k,int f,int lim){
			siz[k]=mx[k]=fa[k]=deep[k]=vis[k]=0;
			sgt::clear(sgt::rt[k]),sgt2::clear(sgt2::rt[k]);
			for(int i=head[k],j;i;i=e[i].next)if((j=e[i].to)!=f){
				if(deep[j]<lim)continue;
				clear(j,k,lim);
			}
		}
		inline void findrt(int x,int fa){
			siz[x]=1,mx[x]=0;
			for(int i=head[x],j;i;i=e[i].next)if(!vis[j=e[i].to]&&j!=fa){
				findrt(j,x),siz[x]+=siz[j],mx[x]=max(mx[x],siz[j]);
			}mx[x]=max(mx[x],maxn-siz[x]);
			if(mx[x]<mx[rt])rt=x;
		}
		inline void dfs(int x,int lim){
			vis[x]=1;
			if(x!=1){
				for(int i=x;i;i=fa[i])if(deep[i]>=lim)
				sgt::insert(sgt::rt[i],times::getdis(i,x)-r[x]);else break;
				for(int i=x;fa[i];i=fa[i])if(deep[i]>=lim)
				sgt2::insert(sgt2::rt[i],times::getdis(fa[i],x)-r[x]);else break;
			}
			int st=maxn;
			for(int i=head[x],j;i;i=e[i].next)if(!vis[j=e[i].to]){
				maxn=siz[j]<siz[x]?siz[j]:st-siz[x];
				mx[rt=0]=n+1,findrt(j,x);
				fa[rt]=x,deep[rt]=deep[x]+1,siz[rt]=siz[j];
				dfs(rt,lim);
			}
		}
		inline void rebuild(int x){
			maxn=siz[x],mx[rt=0]=n+1;
			int dep=deep[x],f=fa[x];
			clear(x,0,dep);
			findrt(x,0);
			fa[rt]=f,deep[rt]=dep,siz[rt]=maxn;
			dfs(rt,dep);
		}
		inline void judge(int x){
			int goal=0;
			while(fa[x]){
				if(siz[fa[x]]*alp<=siz[x])goal=fa[x];
				x=fa[x];
			}if(goal)rebuild(goal);
		}
		inline void upd(int x){
			add(x),judge(x);
		}
	}
	inline short main(){
		read();n=read();times::init();
		read(),read();r[1]=read();
		tree::vis[1]=1,tree::siz[1]=1;pi(0);pn();
		F(i,2,n){
			int f=read()^(ans%mod),w=read();r[i]=read();
			times::add(f,i,w),tree::fa[i]=f;
			tree::deep[i]=tree::deep[f]+1;
			tree::vis[i]=1;
			tree::getans(i),tree::upd(i);
			pi(ans);pn();
		}
		return 0;
	}
}
signed main(){return EMT::main();}
```


---

## 作者：GK0328 (赞：7)

### [我的博客链接](https://www.cnblogs.com/GK0328/p/13857804.html)

### 动态点分治

题目给出的条件是：

$$
dist(i,j) \le r_i+r_j
$$

转换可得：

$$
dist(i,j)-r_j \le r_i
$$

因此可以考虑用**动态点分治**来解决这道题。

添加新节点$x$，更新答案时还是**动态点分治**的套路，由于我们只需要统计新加入节点的答案，因此我们一路跳点分树，利用容斥，设当前跳到点为$t$，路径长度为$d$，这里利用了平衡树（**替罪羊树**，本题只有插入操作，**替罪羊树**巨好写，常数还小）。

那么满足题意的点$y$需满足的条件是：

$$
d+dist(t,y) \le r_x+r_y
$$

$$
\therefore r_x-d \ge dist(t,y)-r_y
$$

查找其替罪羊树上$\le r_x-d$的数的个数，容斥计算答案。

计算路径长度$d$，我想不出$O(1)$求解的方法，直接暴力写$LCT$（好像倍增就行了，~~某指导：倍增已经被时代遗弃~~）。

新添加节点可以直接连上去当成一个大小为$1$的连通块，不会改变点分树的性质。

$But,$点分树深度会出问题。

我们利用**替罪羊树**的思想，对不平衡节点暴力重构，直接把我们插入节点的那条链从高到低扫到第一个需要重构的节点（不用就不重构）。

假设要重构$x$子树，这是点分树上的子树，我们如何在原树上找到这棵子树呢？

我想了一个很逊的方法，记录每个节点在点分树上的深度$dep$，每次访问到$dep_y \le dep_x$的节点（下面称为无效节点）就跳过，其余满足条件的节点（下面称为有效节点）就一定在子树内。

那么会不会有一个节点的连接节点很多，导致遍历复杂度爆炸呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/754kxglk.png)

答案是不会。

设点分树上$x$节点记录的原树连通块为$T_x$

我们考虑点分树的性质，假如$x$与$T_{y}$中一点有边，必有$x \in T_{y}$和$T_{y}  \subset T_{x}$其中一个成立。

因此，如果一条边$(u,v)$，$v$是无效节点，$u$是有效节点，那么$v$必然为$x$在点分树上的祖先。

同时，一个无效节点顶多与$T_x$中一个节点相连，否则必然出现了环。

由于点分树树高为$\log$级别，我们最多访问到$\log$级别的无效节点，而我们每次插入点最多重构一次，那么访问无效节点在整道题中消耗的时间复杂度上限为$O(n \log n)$。

注意，这里计算时不要使用$LCT$求距离，要建$ST$表，因为$LCT$上访问的时间复杂度为$O(\log n)$，举个例子，假如有大小为$4$的树需要重构，$LCT$一次查询的时间复杂度为$O(\log n)$，显然用$ST$表就可以$O(4 \log 4)$预处理，$O(1)$查询。

同时，重构时，对于$x$的父节点$f_x$，$x$对它的容斥贡献可以直接继承。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 100005
#define M 8000005
#define S 1000000000
#define INF 1000000007
#define il inline
#define rint register int
#define D double
#define ll long long
#define lc(x) lct[x].ch[0]
#define rc(x) lct[x].ch[1]
#define sr(x) lct[x].sz
#define fa(x) lct[x].ft
#define rev(x) lct[x].tag
#define ls(x) a[x].ch[0]
#define rs(x) a[x].ch[1]
#define val(x) a[x].value
#define cnt(x) a[x].cct
#define s(x) a[x].siz
using namespace std;
const D alpha=0.7;
int ty,n,ai,ci,ri;
int w[N],q[N],lcq[N << 1],cq[N];
int tot,f[N],dep[N],fr[N],nxt[N << 1],d1[N << 1],d2[N << 1];
int lsz,rrf,rtsz,rt,tsz[N],sz[N];
int dfnt,cdp[N],bg[N],lg2[N << 1],st[N << 1][22];
int pool[M+25],ct;
bool vis[N];
ll ans=0;
struct Link_Cut_Tree
{
    int ch[2],sz,ft;
    bool tag;
}lct[N << 1];
int lctct,vd[N << 1];
il void connect(int x,int y,int son)
{
    fa(x)=y;
    lct[y].ch[son]=x;
}
il int id(int x)
{
    return lc(fa(x))==x?0:1;
}
il bool isrt(int x)
{
    return lc(fa(x))!=x && rc(fa(x))!=x;
}
il void update(int x)
{
    sr(x)=sr(lc(x))+sr(rc(x))+vd[x];
}
il void rot(int x)
{
    int y=fa(x),r=fa(y);
    int yson=id(x),rson=id(y);
    if (isrt(y))
        fa(x)=r; else
        connect(x,r,rson);
    connect(lct[x].ch[yson^1],y,yson);
    connect(y,x,yson^1);
    update(y),update(x);
}
il void push_rev(int x)
{
    if (!x)
        return;
    swap(lc(x),rc(x));
    rev(x)^=1;
}
il void push_down(int x)
{
    if (rev(x))
    {
        push_rev(lc(x));
        push_rev(rc(x));
        rev(x)=false;
    }
}
il void splay(int x)
{
    int g=x,k=0;
    lcq[++k]=g;
    while (!isrt(g))
        g=fa(g),lcq[++k]=g;
    while (k)
        push_down(lcq[k--]);
    while (!isrt(x))
    {
        int y=fa(x);
        if (isrt(y))
            rot(x); else
        if (id(x)==id(y))
            rot(y),rot(x); else
            rot(x),rot(x);
    }
}
il void access(int x)
{
    for (rint y=0;x;y=x,x=fa(x))
    {
        splay(x);
        rc(x)=y;
        update(x);
    }
}
il void makeroot(int x)
{
    access(x);
    splay(x);
    push_rev(x);
}
il void split(int x,int y)
{
    makeroot(x);
    access(y);
    splay(y);
}
il void link(int x,int y)
{
    makeroot(x);
    fa(x)=y;
}
il void link_v(int x,int y,int z)
{
    ++lctct;
    vd[lctct]=z;
    link(x,lctct),link(y,lctct);
}
il int dis(int x,int y)
{
    split(x,y);
    return sr(y);
}
struct node
{
    int ch[2],value,cct,siz;
}a[M+25];
int rp,rq,rg,tr1[N],tr2[N];
il void add_pool()
{
    for (rint i=1;i<=M;++i)
        pool[i]=M-i+1;
    ct=M;
}
il int newnode(int x)
{
    int z=pool[ct--];
    ls(z)=rs(z)=0,val(z)=x,s(z)=cnt(z)=1;
    return z;
}
il int build(int l,int r)
{
    if (l>r)
        return 0;
    if (l==r)
    {
        s(cq[l])=cnt(cq[l]),ls(cq[l])=rs(cq[l])=0;
        return cq[l];
    }
    int mid=(l+r) >> 1;
    ls(cq[mid])=build(l,mid-1);
    rs(cq[mid])=build(mid+1,r);
    s(cq[mid])=s(ls(cq[mid]))+s(rs(cq[mid]))+cnt(cq[mid]);
    return cq[mid];
}
il void dfs(int x)
{
    if (!x)
        return;
    dfs(ls(x));
    cq[++cq[0]]=x;
    dfs(rs(x));
}
il int reb(int x)
{
    cq[0]=0;
    dfs(x);
    int tt=build(1,cq[0]);
    return tt;
}
il bool bad(int x,int y)
{
    return alpha*s(x)<=s(y);
}
il void insr(int &x,int y)
{
    if (!x)
    {
        x=newnode(y);
        return;
    }
    s(x)++;
    if (val(x)==y)
    {
        cnt(x)++;
        return;
    }
    int nxt=(val(x)>y)?0:1;
    insr(a[x].ch[nxt],y);
    if (bad(x,a[x].ch[nxt]))
        rp=x,rq=rg=0; else
    if (rp && !rq)
        rq=x,rg=nxt;
}
il void ins(int &x,int y)
{
    rp=rq=rg=0;
    insr(x,y);
    if (rp)
    {
        if (rq)
            a[rq].ch[rg]=reb(rp); else
            x=reb(rp);
    }
}
il int calc(int x,int y)
{
    int ans=0;
    while (x)
    {
        if (val(x)==y)
        {
            ans+=s(ls(x))+cnt(x);
            break;
        }
        if (val(x)<y)
            ans+=s(ls(x))+cnt(x),x=rs(x); else
            x=ls(x);
    }
    return ans;
}
il int read()
{
    int s=0;
    char c=getchar();
    while (c<'0' || c>'9')
        c=getchar();
    while ('0'<=c && c<='9')
        s=(s << 3)+(s << 1)+(c^48),c=getchar();
    return s;
}
il void write(ll x)
{
    if (x>9)
        write(x/10);
    putchar(x%10+48);
}
il void add(int x,int y,int z)
{
    ++tot;
    d1[tot]=y,d2[tot]=z;
    nxt[tot]=fr[x];
    fr[x]=tot;
}
il void clear_sgt(int u)
{
    if (!u)
        return;
    pool[++ct]=u;
    clear_sgt(ls(u)),clear_sgt(rs(u));
}
il void clear_vis_sgt_getst(int u,int F,int mxd)
{
    clear_sgt(tr1[u]),tr1[u]=0;
    if (f[u]!=rrf)
        clear_sgt(tr2[u]),tr2[u]=0;
    vis[u]=false;
    st[++dfnt][0]=u;
    bg[u]=dfnt;
    for (rint i=fr[u];i;i=nxt[i])
    {
        int v=d1[i];
        if (dep[v]<=mxd || v==F)
            continue;
        cdp[v]=cdp[u]+d2[i];
        clear_vis_sgt_getst(v,u,mxd);
        st[++dfnt][0]=u;
    }
}
il int lca(int x,int y)
{
    x=bg[x],y=bg[y];
    if (x>y)
        swap(x,y);
    int k=lg2[y-x+1];
    return (cdp[st[x][k]]<cdp[st[y-(1 << k)+1][k]])?st[x][k]:st[y-(1 << k)+1][k];
}
il int st_dis(int x,int y)
{
    return cdp[x]+cdp[y]-(cdp[lca(x,y)] << 1);
}
il void findrt(int u,int F,int rn)
{
    int mx=-1;
    sz[u]=1;
    for (rint i=fr[u];i;i=nxt[i])
    {
        int v=d1[i];
        if (v==F || vis[v])
            continue;
        findrt(v,u,rn);
        sz[u]+=sz[v];
        if (sz[v]>mx)
            mx=sz[v];
    }
    mx=max(mx,rn-sz[u]);
    if (mx<rtsz)
        rtsz=mx,rt=u;
}
il void getrt(int u,int rn)
{
    rtsz=INF;
    findrt(u,0,rn);
}
il void update_dis(int u,int F,int rt)
{
    ins(tr1[rt],st_dis(rt,u)-w[u]);
    if (f[rt] && f[rt]!=rrf)
        ins(tr2[rt],st_dis(f[rt],u)-w[u]);
    for (int i=fr[u];i;i=nxt[i])
    {
        int v=d1[i];
        if (v==F || vis[v])
            continue;
        update_dis(v,u,rt);
    }
}
il void solve(int u)
{
    int csz=lsz;
    vis[u]=true,tsz[u]=1;
    update_dis(u,0,u);
    for (rint i=fr[u];i;i=nxt[i])
    {
        int v=d1[i];
        if (vis[v])
            continue;
        lsz=(sz[v]<sz[u])?sz[v]:csz-sz[u];
        getrt(v,lsz);
        f[rt]=u,dep[rt]=dep[u]+1;
        int qt=rt;
        solve(rt);
        tsz[u]+=tsz[qt];
    }
}
il void rebuild(int x)
{
    rrf=f[x];
    lsz=tsz[x];
    dfnt=0,cdp[x]=0;
    clear_vis_sgt_getst(x,0,dep[x]);
    for (rint j=1;j<=lg2[dfnt];++j)
        for (rint i=1;i<=dfnt-(1 << j)+1;++i)
            st[i][j]=(cdp[st[i][j-1]]<cdp[st[i+(1 << j-1)][j-1]])?st[i][j-1]:st[i+(1 << j-1)][j-1];
    getrt(x,lsz);
    f[rt]=rrf,dep[rt]=dep[x],tr2[rt]=tr2[x],tr2[x]=0;
    solve(rt);
}
il void isr(int x,int y)
{
    vis[x]=true;
    f[x]=y,dep[x]=dep[y]+1;
    int t=y;
    q[0]=0;
    while (t)
        q[++q[0]]=t,tsz[t]++,t=f[t];
    for (rint i=1;i<=q[0];++i)
    {
        int o=dis(q[i],x);
        ans+=calc(tr1[q[i]],w[x]-o),ins(tr1[q[i]],o-w[x]);
        if (i!=1)
            ans-=calc(tr2[q[i-1]],w[x]-o),ins(tr2[q[i-1]],o-w[x]); else
            ins(tr2[x],o-w[x]);
    }
    for (rint i=q[0];i>1;--i)
        if (alpha*tsz[q[i]]<=tsz[q[i-1]])
        {
            rebuild(q[i]);
            break;
        }
}
int main()
{
    ty=read(),n=read();
    add_pool();
    lg2[0]=-1;
    for (rint i=1;i<=(n << 1);++i)
        lg2[i]=lg2[i >> 1]+1;
    lctct=n;
    for (rint i=1;i<=n;++i)
    {
        ai=read(),ci=read(),w[i]=read();
        ai=(ans%S)^ai;
        ins(tr1[i],-w[i]);
        tsz[i]=1;
        if (!ai && !ci)
        {
            vis[1]=true;
            write(ans),putchar('\n');
            continue;
        }
        link_v(i,ai,ci);
        add(ai,i,ci),add(i,ai,ci);
        isr(i,ai);
        write(ans),putchar('\n');
    }
    return 0;
}
```

---

## 作者：斯蒂芬·库里30 (赞：7)

首先，我们发现实际上每次只需要统计新加进的结点有多少合法解。那么，我们将dist(i,j)dist(i,j)写成dist(i,p)+dist(j,p)dist(i,p)+dist(j,p)，其中p是i和j的LCA。


那么，


dist(i,j)⇔dist(i,p)+dist(j,p)⇔ri−dist(i,p)≤ri+rj≤ri+rj≥dist(j,p)−rj

dist(i,j)≤ri+rj⇔dist(i,p)+dist(j,p)≤ri+rj⇔ri−dist(i,p)≥dist(j,p)−rj


所以，我们枚举新加的结点的所有祖先p，计算以p为LCA的满足条件的点对(i,j)(i,j)有多少个即可。


计算时，先查询pp子树在添加i之前有多少j满足ri−dist(i,p)≥dist(j,p)−rj，再减去其中LCA不是p的（即，i和j在p的同一棵子树里，这样我们就要查询在这棵子树里有多少j满足此条件）。


然而，要高效地维护这个信息，就需要在每个结点上维护一个Treap（记录所有的dist(j,p)−rj），但这样当树退化为链，单次加入时间复杂度增加为O(nlogn)，空间复杂度增加为O(n2)。


于是，借鉴替罪羊树的思想，我们在某个结点子树内的点个数大于其父亲子树内点的个数的α∈(0,1)α∈(0,1)倍的时候暴力重构其父亲的子树。既然要求重构之后尽量平衡，理所当然地选用点分治。


这样，上面的分析中所有的“父亲”和“祖先”都应理解为点分治树上的祖先（LCA当然也是），但是答案仍是正确的，因为我们仍然不重不漏地枚举了所有可能的点。


代码实现上，还要写一个倍增LCA以查询dist，因为点分治之后的祖先不一定是原树上的祖先，不能直接用dep相减。


哦，还有，要写垃圾回收，因为有重构treap，之前的内存必须要重复利用。


代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <stack>
#include <set>
typedef long long LL;
const int N = 100050;
int pre[N], to[N * 2], nxt[N * 2], c[N * 2], cnt = 0;
int r[N];
inline void add_edge(int x, int y, int v) {
  nxt[cnt] = pre[x];
  c[cnt] = v;
  to[pre[x] = cnt++] = y;
  nxt[cnt] = pre[y];
  c[cnt] = v;
  to[pre[y] = cnt++] = x;
}
namespace Tree{
  int dep[N], dep2[N], fa[N][17];
  void insert(int x, int c, int f) {
    add_edge(x, f, c);
    dep[x] = dep[fa[x][0] = f] + 1;
    dep2[x] = dep2[f] + c;
    for (int i = 1; i < 17; ++i)
      fa[x][i] = fa[fa[x][i - 1]][i - 1];
  }
  int LCA(int x, int y) {
    if (dep[x] > dep[y]) std::swap(x, y);
    for (int i = 16; ~i; --i)
      if (dep[fa[y][i]] >= dep[x])
        y = fa[y][i];
    for (int i = 16; ~i; --i)
      if (fa[x][i] != fa[y][i]) {
        x = fa[x][i];
        y = fa[y][i];
      }
    return x == y ? x : fa[x][0];
  }
  int dis(int x, int y) {
    int l = LCA(x, y);
    return dep2[x] + dep2[y] - 2 * dep2[l];
  }
};
struct Treap;
typedef Treap* PTreap;
struct Treap{
  static std::stack<PTreap> bin;
  PTreap lch, rch;
  int val, key, cnt, siz;
  void* operator new(size_t, int v) {
    Treap *res;
    res = bin.top();
    bin.pop();
    res->val = v; res->key = rand();
    res->cnt = 1; res->siz = 1;
    res->lch = res->rch = NULL;
    return res;
  }
  void operator delete(void *t) {
    bin.push((PTreap)t);
  }
  void update() {
    siz = cnt;
    if (lch != NULL) siz += lch->siz;
    if (rch != NULL) siz += rch->siz;
  }
  friend void Zig(PTreap &t) { //右旋
    PTreap l = t->lch;
    t->lch = l->rch;
    l->rch = t;
    t->update();
    l->update();
    t = l;
  }
  friend void Zag(PTreap &t) { //左旋
    Treap *r = t->rch;
    t->rch = r->lch;
    r->lch = t;
    t->update();
    r->update();
    t = r;
  }
  friend int query(PTreap o, int x) {
    if (o == NULL) return 0;
    if (o->val > x) return query(o->lch, x);
    else return query(o->rch, x) + (o->lch == NULL ? 0 : o->lch->siz) + o->cnt;
  }
  friend void insert(PTreap &o, int x) {
    if (o == NULL)
      o = new (x)Treap;
    else if (o->val == x)
      ++o->cnt;
    else if (o->val > x) {
      insert(o->lch, x);
      if (o->lch->key > o->key)
        Zig(o);
    } else {
      insert(o->rch, x);
      if (o->rch->key > o->key)
        Zag(o);
    }
    o->update();
  }
  friend void remove(PTreap &x) {
    if (x == NULL) return;
    remove(x->lch);
    remove(x->rch);
    delete x; x = NULL;
  }
};
std::stack<PTreap> Treap::bin;
namespace Dynamic_TreeDivision{
  PTreap tree[N], sonTree[N];
  int time, vise[N * 2];
  int fa[N], vis[N];
  std::set<int> son[N];
  void remove(int x) {
    vis[x] = time;
    for (std::set<int>::iterator i = son[x].begin(); i != son[x].end(); ++i) {
      remove(*i);
      remove(sonTree[*i]);
    }
    son[x].clear();
    remove(tree[x]);
  }
  int getCentre(int x, int f, int siz, int &ct) {
    int res = 1;
    bool ok = true;
    for (int i = pre[x]; ~i; i = nxt[i]) {
      if (vise[i] == time) continue;
      if (to[i] == f) continue;
      if (vis[to[i]] != time) continue;
      int ss = getCentre(to[i], x, siz, ct);
      if (ss > siz / 2) ok = false;
      res += ss;
    }
    if (siz - res > siz / 2) ok = false;
    if (ok) ct = x;
    return res;
  }
  void insertAll(int x, int f, int dep, PTreap &p) {
    insert(p, dep - r[x]);
    for (int i = pre[x]; ~i; i = nxt[i]) {
      if (vise[i] == time) continue;
      if (to[i] == f) continue;
      if (vis[to[i]] != time) continue;
      insertAll(to[i], x, dep + c[i], p);
    }
  }
  int divide(int x) {
    getCentre(x, 0, getCentre(x, 0, 1000000000, x), x);
    insertAll(x, 0, 0, tree[x]);
    for (int i = pre[x]; ~i; i = nxt[i]) {
      if (vise[i] == time) continue;
      if (vis[to[i]] != time) continue;
      vise[i] = vise[i ^ 1] = time;
      PTreap p = NULL;
      insertAll(to[i], 0, c[i], p);
      int s = divide(to[i]);
      fa[s] = x;
      son[x].insert(s);
      sonTree[s] = p;
    }
    return x;
  }
  void rebuild(int x) {
    ++time;
    remove(x);
    int ff = fa[x];
    PTreap p = sonTree[x];
    sonTree[x] = NULL;
    if (ff != 0) son[ff].erase(x);
    x = divide(x);
    fa[x] = ff;
    sonTree[x] = p;
    if (ff != 0) son[ff].insert(x);
  }
  LL insert(int x, int f) {
    LL ans = 0;
    son[f].insert(x);
    fa[x] = f;
    for (int i = x; i; i = fa[i]) {
      if (fa[i] != 0) {
        int d = Tree::dis(fa[i], x);
        ans += query(tree[fa[i]], r[x] - d);
        ans -= query(sonTree[i], r[x] - d);
        insert(sonTree[i], d - r[x]);
      }
      int d = Tree::dis(i, x);
      insert(tree[i], d - r[x]);
    }
    int rebuildx = 0;
    for (int i = x; fa[i]; i = fa[i])
      if (tree[i]->siz > tree[fa[i]]->siz * 0.88)
        rebuildx = fa[i];
    if (rebuildx) rebuild(rebuildx);
    return ans;
  }
};
Treap node[N * 100];
int main() {
  for (int i = 0; i < N * 100; ++i)
    Treap::bin.push(node + i);
  int n, a, cc, v;
  scanf("%*d%d", &n);
  LL lastans = 0;
  pre[0] = -1;
  for (int i = 1; i <= n; ++i) {
    scanf("%d%d%d", &a, &cc, &v);
    r[i] = v;
    a ^= lastans % 1000000000;
    pre[i] = -1;
    Tree::insert(i, cc, a);
    lastans += Dynamic_TreeDivision::insert(i, a);
    printf("%lld\n", lastans);
  }
  return 0;
}

```

---

## 作者：huangjinxiu (赞：5)

### 前言：

本篇题解不同于所有其他题解，不需要用类似替罪羊树的思想来重构点分树，也不需要使用平衡树维护点分树上的信息。

## 正文：

发现如果不强制在线，离线下来可以用点分树随便做。

但是本题烦就烦在强制在线，于是考虑 **根号重构**。

考虑设置阈值 $S$，每加入 $S$ 个点重构一次点分树。

考虑 $dist(u,v)\le r_u+r_v$ 等价于 $dist(rt,u)+dist(rt,v)\le r_u+r_v$ ($rt$ 表示对应的分治中心（即点分树上 $u,v$ 的 $lca$）)。

转化为 $dist(rt,v)-r_v \le dist(rt,u)-r_u$ 。
我们把所有的 $dist(rt,v)-r_v$ 塞进一个 $vector$ 里然后排序，查询时直接将 $dist(rt,u)-r_u$ 带进去 $upper$ 即可。注意要额外开一些 $vector$ 来去除子树贡献（点分树常规操作）。



![](https://cdn.luogu.com.cn/upload/image_hosting/6ra7t5gk.png)

考虑贡献分为两部分，来自已经加入点分树的点的贡献（图中的加粗点，以下简称粗点）以及还没有加入点分树中的点的贡献（图中的未加粗点（总数不超过 $S$），以下简称细点）。

- 考虑一个新加入的细点 $u$ 与所有粗点的贡献。定义 $F_u$ 表示 $u$ 的深度最大的祖先满足 $F_u$ 为粗点。容易发现点 $u$ 与任意粗点间的路径一定会经过 $F_u$ 。所以直接在点分树上 $F_u$ 所在点一路往上查询然后跳其在点分树上的父亲即可。
- 考虑暴力统计点 $u$ 与所有细点的贡献。如何快速求出两个细点 $u,v$ 之间的距离？因为$dist(u,v)=dep_u+dep_v-2\times lca(u,v)$ 所以这等价于快速求出 $lca(u,v)$。容易想到倍增，这样可以做到总复杂度 $O(n\log n\sqrt{n\log n})$，可以斩获 65 分。
- 考虑优化，注意到若点 $v$ 不在点 $u$ 所在的**极大细点联通块**中，则 $lca(u,v)=lca(F_u,F_v)$。可以考虑每次重构的时候使用 $dfn$ 序求 $lca$ 的方法做到 $O(n\log n)$ 预处理 $O(1)$ 求粗点间的 $lca$。
- 至于点 $v$ 在点 $u$ 所在的**极大细点联通块**中的情况可以直接从 $u$ 开始深搜获取这部分点的贡献（这个时候求的就不是 $lca$ 了而是直接求 $dist$）。

### 复杂度分析：

细点贡献部分 $O(nS)$，粗点贡献部分 $O(n\log^2 n)$ ,重构部分 $O(\frac{n}{
S}\times n\log^2 n)$。

总复杂度 $O(nS+\frac{n}{
S}\times n\log^2 n+n\log^2 n)$。当 $S$ 取 $\sqrt n\log n$ 时总复杂度为 $O(n\sqrt n\log n)$。

### 代码：

3.3k 不算太长，最慢点4.38s 不算太慢
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb emplace_back
#define cmax(a,b) ((a)=max((a),(b)))
#define LL long long
using namespace std;
const int N=1e5+10,inf=0x3f3f3f3f;
vector<pii> E[N];vector<int> G[N];bitset<N> vis;
int S=1000,m,res,cur,n,x,y,z,top,F[N],fa[N],st[N],dep[N],r[N];
LL las;
namespace Tree{
	int cur,dfn[N],st[18][N];
	inline int get(int x,int y){return dep[x]<dep[y]?x:y;}
	void dfs(int u){
		st[0][dfn[u]=++cur]=fa[u];
		for(int v:G[u])if(v^fa[u])dfs(v);
	}
	void init(){
		cur=0;dfs(1);
		for(int i=1;i<=m;++i)F[i]=i;
		for(int i=1;i<=__lg(m);++i)
			for(int j=1;j+(1<<i)-1<=m;++j)
				st[i][j]=get(st[i-1][j],st[i-1][j+(1<<(i-1))]);	
	}
	inline int lca(int u,int v){
		if(u==v)return u;
		if((u=dfn[u])>(v=dfn[v]))swap(u,v);
		int d=__lg(v-u++);
		return get(st[d][u],st[d][v-(1<<d)+1]);
	}
	inline int dist(int u,int v){
		return dep[u]+dep[v]-2*dep[lca(u,v)];
	}
}
namespace Divide{
	int top,root,mxs,all,cur,dep[N],siz[N],st[N],fa[N],id[N];bitset<N> del;
	struct SUM{
		vector<int> P; 
		void init(){
			P.resize(top);sort(st+1,st+1+top);
			for(int i=1;i<=top;++i)P[i-1]=st[i];top=0;
		}
		inline int qry(int x){return upper_bound(P.begin(),P.end(),x)-P.begin();}
	}sum[N],dsum[N];
	inline void get_root(int u,int fa){
		int res=0;siz[u]=1;
		for(int v:G[u]){
			if(v==fa||del[v])continue;
			get_root(v,u);
			siz[u]+=siz[v];
			cmax(res,siz[v]);
		}
		cmax(res,all-siz[u]);
		if(res<mxs)mxs=res,root=u;
	}
	inline void dfs(int u,int fa){
		st[++top]=dep[u]-r[u];siz[u]=1;
		for(pii g:E[u]){
			int v=g.fi;
			if(v==fa||del[v])continue;
			dep[v]=dep[u]+g.se;
			dfs(v,u);siz[u]+=siz[v];
		}
	}
	inline void dfs2(int u,int fa){
		st[++top]=dep[u]-r[u];
		for(int v:G[u])if(v!=fa&&!del[v])dfs2(v,u);
	}
	inline void divide(int u,int allsiz,int lasid,int lstcen){
		mxs=(all=allsiz)+1;get_root(u,0);
		u=root;fa[u]=lstcen;id[u]=lasid;
		dep[u]=0;
		dfs(u,0);
		sum[u].init();
		del[u]=1;
		for(int v:G[u]){
			if(del[v])continue;
			dfs2(v,u);dsum[++cur].init();
			divide(v,siz[v],cur,u);
		}
	}
	inline void rebuild(){
		cur=0;
		memset(id,0,sizeof id);
		memset(fa,0,sizeof fa);
		for(int i=1;i<=m;++i)vector<int>().swap(sum[i].P);
		while(cur)vector<int>().swap(dsum[cur--].P);
		del.reset();divide(1,m,0,0);
	}
	inline int qry(int u,int y){
		int res=0;
		for(int x=u;x;x=fa[x]){
			res+=sum[x].qry(y-Tree::dist(u,x));
			if(id[x])res-=dsum[id[x]].qry(y-Tree::dist(u,fa[x]));
		}
		return res;
	}
}
void dfs(int u,int dep,int fa){
	if(F[u]==u)return ;
	if(dep<=r[u]+r[cur])++res,vis[u]=1;
	for(pii g:E[u])if(g.fi^fa)dfs(g.fi,dep+g.se,u);
}
int qry(int u){
	res=0;dfs(fa[u],dep[u]-dep[fa[u]],u);
	if(F[u])res+=Divide::qry(F[u],r[u]-dep[u]+dep[F[u]]);
	for(int i=1;i<=top;++i)
		if(!vis[st[i]])res+=(dep[u]+dep[st[i]]-2*dep[Tree::lca(F[u],F[st[i]])]<=r[u]+r[st[i]]);
		else vis[st[i]]=0;
	return res;
}
void rebuild(int all){
	m=all;Tree::init();Divide::rebuild();top=0;
	S=ceil(1.2*sqrt(cur)*__lg(cur));
	//动态设定S的值，因为当前的点数越少重构得越快。乘1.2是因为常数不平衡。
	//这样写会快一些，将S直接设为定值也可以稳过。 
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);
	cin>>n>>n; 
	for(int i=1;i<=n;++i){
		++cur;cin>>x>>y>>r[i];
		x^=las%1000000000;
		if(i^1){
			E[fa[i]=x].pb(i,y);
			E[i].pb(x,y);
			G[x].pb(i);
			G[i].pb(x);
			dep[i]=dep[x]+y;
			F[i]=F[fa[i]];
		}
		las+=qry(i);
		cout<<las<<'\n';
		st[++top]=i;
		if(top==S)rebuild(i);
	}
	return 0;
}
```
### 感谢：

由衷感谢 [@wjwweiwei](https://www.luogu.com.cn/user/547295) 提供的优化思路！

---

## 作者：Seauy (赞：5)

好家伙点开题解区一看全没有复杂度分析，一篇定期重构 $O(n^{1.5}\log^2 n)$，一篇说替罪羊树式的点分树复杂度为 $O(n^{1.5} \log^2 n)$。

~~那我来一篇 $O(n^{1.5} \log n)$ 的吧~~

## 题目大意

- 修改操作：在树上挂个新叶子。

- 查询操作：$dist(i,j)\leq r_i + r_j$ 的点对个数。

- 强制在线，$n \leq 10^5$，12s。

# 一、题目分析

看见点对统计，并且限制跟距离有关，甚至还带修，果断点分树。

在点分治的时候确定一个根，计算分治范围内所有结点的深度 $dep_i$，对于两个在根的不同子树中的结点，要求改写为

$$ dep_i+dep_j\leq r_i +r_j $$

如果想知道 $i$ 能跟几个结点满足要求，相当于求满足

$$ r_i-dep_i \geq dep_j-r_j $$

的 $j$ 的个数，平衡树维护即可。

但是点分树的结构是静态的，但是加叶子操作却是动态的，如果直接在点分树上插入新结点会导致结构不平衡。

我们知道一次建点分树的复杂度是 $O(n\log^2 n)$ 的，那么我们借鉴朝鲜树的思想，每 $S$ 次操作重构一次。

对于下次重构未到来前加入的结点，称为剩余点，不作为点分树的某个分治范围的根结点，但插入平衡树中，并且剩余点间连边构成剩余树。每次插入一个新的剩余点，沿着点分树一路从根开始向父亲走，并查询平衡树，最后走到点分树上的结点 $r$，还有一部分剩余点，与新结点在同一 $r$ 的子树中。直接在剩余树上暴力计算新结点与他们的贡献即可。

这样重构复杂度 $O(\frac{n}{S}n\log^2 n)$，查询复杂度 $O(n(\log^2n +S))$，取 $S=\sqrt n \log n$ 得时间复杂度 $O(n^{1.5} \log n)$，空间 $O(n \log n)$。

~~所以替罪羊式重构的复杂度要怎么分析啊~~

# 二、代码

手贱写了 fhq，导致最优解倒一！！！！

```cpp
#include<bits/stdc++.h>
#define Lson(x) node[x].Son[0]
#define Rson(x) node[x].Son[1]
using namespace std;

typedef long long ll;

const int MAXN=1e5,LOGN=17;
const ll MOD=1e9;

inline int Read()
{
	int ret;char c;
	while(1) {c=getchar();if('0'<=c && c<='9') {ret=c-'0';break;}}
	while(1) {c=getchar();if('0'<=c && c<='9') ret=ret*10+c-'0';else break;}
	return ret;
}

//---------------------- fhqTreap --------------------------
struct fhqTreap
{
	int Son[2],SIZE,data,KEY;
	//KEY in [0,RAND_MAX]
}node[2*MAXN*LOGN+5];int Tail;

int New(int x)
{
	node[++Tail].data=x;
	node[Tail].SIZE=1;
	node[Tail].KEY=rand();
	node[Tail].Son[0]=node[Tail].Son[1]=0;
	return Tail;
}

void PushUp(int now) {node[now].SIZE=node[Lson(now)].SIZE+1+node[Rson(now)].SIZE;}

void Split(int now,int x,int &a,int &b)//值域分裂
{
	if(!now) {a=b=0;return;}
	if(node[now].data<=x) a=now,Split(Rson(now),x,Rson(now),b);
	else b=now,Split(Lson(now),x,a,Lson(now));
	PushUp(now);
}

int Merge(int a,int b)
{
	if(!a || !b) return a^b;
	if(node[a].KEY>node[b].KEY) {Rson(a)=Merge(Rson(a),b),PushUp(a);return a;}
	Lson(b)=Merge(a,Lson(b)),PushUp(b);return b;
}

int Ask(int now,int x)
{
	if(!now) return 0;
	if(x<node[now].data) return Ask(Lson(now),x);
	return node[Lson(now)].SIZE+1+Ask(Rson(now),x);
}

void Add(int &x,int v)
{
	int a,b;Split(x,v,a,b);
	x=Merge(Merge(a,New(v)),b);
}

//---------------------- daq Tree --------------------------
struct DE {int nxt,val;};

int n,S,q,R[MAXN+5];
vector<DE> Tree[MAXN+5];
ll ans;
vector<int> ance[MAXN+5],depth[MAXN+5],subt[MAXN+5];
//点分树上祖先，每层的深度，每层所在子树编号
vector<int> subfhq[MAXN+5];//成为根时每个子树的 fhq 根
int beRoot,root[MAXN+5];//编号最大的成为点分树根的结点，成为根时 fhq 的根
vector<DE> Left[MAXN+5];//剩余结点构成的树 

bool V[MAXN+5];int Size[MAXN+5];
void CalSize(int now,int lst)
{
	Size[now]=1;
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(rear==lst || V[rear]) continue;
		CalSize(rear,now),Size[now]+=Size[rear];
	}
}
int FindCG(int now,int lst,int ALL)
{
	bool OK=1;
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(rear==lst || V[rear]) continue;
		if(2*Size[rear]>ALL) {OK=0;break;}
	}
	OK&=(2*Size[now]>=ALL);
	if(OK) return now;
	for(int i=0,rear,res;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(rear==lst || V[rear]) continue;
		res=FindCG(rear,now,ALL);
		if(res) return res;
	}
	return 0;
}
void BuildMainfhq(int now,int lst,int x,int dep)
{
	ance[now].push_back(x);
	depth[now].push_back(dep);
	Add(root[x],dep-R[now]);
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(rear==lst || V[rear]) continue;
		BuildMainfhq(rear,now,x,dep+Tree[now][i].val);
	}
}
void BuildSubfhq(int now,int lst,int x,int y,int dep)//根与第几个子树
{
	subt[now].push_back(y);
	Add(subfhq[x][y],dep-R[now]);
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(rear==lst || V[rear]) continue;
		BuildSubfhq(rear,now,x,y,dep+Tree[now][i].val);
	}
}
void daq(int now)//分治建树
{
	CalSize(now,0),now=FindCG(now,0,Size[now]);
	BuildMainfhq(now,0,now,0);
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(V[rear]) continue;
		subfhq[now].push_back(0);
		BuildSubfhq(rear,now,now,subfhq[now].size()-1,Tree[now][i].val);
	}
	V[now]=1;
	for(int i=0,rear;i<Tree[now].size();i++)
	{
		rear=Tree[now][i].nxt;
		if(V[rear]) continue;
		daq(rear);
	}
}

void Build()
{
	for(int i=1;i<=n;i++)
	{
		ance[i].clear();
		depth[i].clear();
		subt[i].clear();
		subfhq[i].clear();
		V[i]=root[i]=0;
	}
	for(int i=beRoot+1;i<=n;i++) Left[i].clear();
	Tail=0,daq(1),beRoot=n;
}

void Link(int a,int c)
{
	if(a>beRoot)
	{
		Left[a].push_back(DE{n,c});
		Left[n].push_back(DE{a,c});
		for(int i=0,now,dep;i<ance[a].size();i++)
		{
			now=ance[a][i];
			dep=depth[a][i]+c;
			
			ance[n].push_back(now);
			depth[n].push_back(dep);
			subt[n].push_back(subt[a][i]);
			
			Add(root[now],dep-R[n]);
			Add(subfhq[now][subt[n][i]],dep-R[n]);
		}
	}
	else
		for(int i=0,now,dep;i<ance[a].size();i++)
		{
			now=ance[a][i];
			dep=depth[a][i]+c;
			
			ance[n].push_back(now);
			depth[n].push_back(dep);
			if(i==ance[a].size()-1)
			{
				subfhq[a].push_back(0);
				subt[n].push_back(subfhq[a].size()-1);
			}
			else subt[n].push_back(subt[a][i]);
			
			Add(root[now],dep-R[n]);
			Add(subfhq[now][subt[n][i]],dep-R[n]);
		}
}

int LeftQuery(int now,int lst,int x,int dist)
{
	int res=(dist<=R[x]+R[now] && now!=x);
	for(int i=0,rear;i<Left[now].size();i++)
	{
		rear=Left[now][i].nxt;
		if(rear==lst) continue;
		res+=LeftQuery(rear,now,x,dist+Left[now][i].val);
	}
	return res;
}

int Query(int x)
{
	int res=0;
	for(int i=0,now;i<ance[x].size();i++)
	{
		now=ance[x][i];
		res+=Ask(root[now],R[x]-depth[x][i]);
		if(x==ance[x][i]) --res;
		else
		{
			res-=Ask(subfhq[now][subt[x][i]],R[x]-depth[x][i]);
			if(i==ance[x].size()-1) res+=LeftQuery(x,0,x,0);
		}
	}
	return res;
}

void Insert(int a,int c)//插入结点 n 
{
	if(!a) 
	{
		beRoot=1;
		ance[n].push_back(n),depth[n].push_back(0);
		root[n]=0,Add(root[n],-R[n]);
		return;
	}
	Tree[a].push_back(DE{n,c});
	Tree[n].push_back(DE{a,c});
	if(n%S==0) Build();//n-S+1 ~ n 没有成为过点分树的根
	else Link(a,c);
	ans+=Query(n);
}

int main()
{
	int T=Read();
	q=Read();
	S=ceil(sqrt(q)*log(q)/log(2));
	int a,c;
	for(n=1;n<=q;n++)
	{
		a=Read(),c=Read(),R[n]=Read();
		a^=ans%MOD;
		Insert(a,c);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：orz_z (赞：2)

要求维护一颗带边权和点权 $r$ 的树，支持动态插入叶子 以及 询问树上有多少点对满足两个点的点权之和大于两点间的边权之和，即 $\forall i < j,r_i+r_j \geq \operatorname{dis}(i,j)$。

强制在线。

$1\leq$ 点数 $\leq 10^5$，$1 \leq$ 边权 $\leq 10^4$，$1 \leq $ 点权 $\leq 10^9$。

#### std

先不考虑动态插入叶子，即给你一棵树，求出答案。

按照套路，对于这种大规模树上路径问题，考虑点分治。

考虑询问，由于点分治只统计经过根节点的方案数，那么设当前分治中心为 $g$，一条经过 $g$ 的路径 $(u,v)$ 可分为 $(u,g)$ 和 $(g,v)$ 两段，那么 $\operatorname{dis}(u,v)=\operatorname{dis}(u,g)+\operatorname{dis(g,v)}$。

考虑到原式可移项为 $r_u-\operatorname{dis}(u,g)\leq \operatorname{dis}(g,v)-r_v$，我们可以用一个数据结构，支持插入和求排名操作维护节点 $g$ 的所有 $\operatorname{dis}(g,v)-r_v$，查询 $r_u-\operatorname{dis}(u,g)$ 的排名即可。

对于多次点分治，可用点分树优化。

再考虑动态插入叶子怎么做。

显然，定期重构部分点分树即可。

总时间复杂度为 $\mathcal O(n \sqrt n \log^2n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}

namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

#define ll long long

inline ll read()
{
    ll x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = x * 10 + c - '0', c = getchar();
    return x * f;
}

inline void write(ll x)
{
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

const int _ = 1e5 + 10, S = 350, inf = 1e7 + 10;

const double alpha = 0.95;

int n, r[_];

int sz[_];

bool vis[_];

int tot, head[_], to[_ << 1], nxt[_ << 1];

ll lst;

inline void add(int u, int v)
{
    to[++tot] = v;
    nxt[tot] = head[u];
    head[u] = tot;
}

inline pair<int, int> get_rt(int rt, int f, int pre)
{
    sz[rt] = 1;
    int mx = 0;
    pair<int, int> ans = {inf, 0};
    for (int i = head[rt]; i; i = nxt[i])
    {
        int v = to[i];
        if (vis[v] || v == f)
            continue;
        ans = min(ans, get_rt(v, rt, pre));
        sz[rt] += sz[v];
        mx = max(mx, sz[v]);
    }
    ans = min(ans, {max(mx, pre - sz[rt]), rt});
    return ans;
}

struct DIS
{
    int f[_][17], dep[_], dis[_];
    inline void insert(int x, int fa, int c)
    {
        f[x][0] = fa;
        dep[x] = dep[fa] + 1;
        dis[x] = dis[fa] + c;
        for (int i = 1; i <= 16; ++i)
            f[x][i] = f[f[x][i - 1]][i - 1];
    }
    inline int LCA(int x, int y)
    {
        if (dep[x] < dep[y])
            swap(x, y);
        for (int i = 16; ~i; --i)
            if (dep[f[x][i]] >= dep[y])
                x = f[x][i];
        if (x == y)
            return x;
        for (int i = 16; ~i; --i)
            if (f[x][i] != f[y][i])
                x = f[x][i], y = f[y][i];
        return f[x][0];
    }
    inline int Dis(int x, int y)
    {
        return dis[x] + dis[y] - 2 * dis[LCA(x, y)];
    }
} bz;

struct ABC
{
    vector<int> a, b;
    inline void insert(int x)
    {
        b.insert(lower_bound(b.begin(), b.end(), x), x);
        if (b.size() >= S)
        {
            vector<int> c, d;
            int i = 0, j = 0;
            for (; i < a.size() && j < b.size();)
                if (a[i] < b[j])
                    c.push_back(a[i++]);
                else
                    c.push_back(b[j++]);
            while (i < a.size())
                c.push_back(a[i++]);
            while (j < b.size())
                c.push_back(b[j++]);
            swap(a, c);
            swap(b, d);
        }
    }
    inline int rank(int x)
    {
        return (upper_bound(a.begin(), a.end(), x) - a.begin()) + (upper_bound(b.begin(), b.end(), x) - b.begin()) - 2;
    }
    inline void clear()
    {
        a.clear();
        b.clear();
    }
} pa[_ << 1], pb[_ << 1];

struct D_F_Z
{
    int f[_], dep[_], siz[_];
    inline int query(int x, int r)
    {
        int ans = 0;
        for (int i = x, j; f[i]; i = j)
        {
            j = f[i];
            int dis = r - bz.Dis(x, j);
            ans += pa[j].rank(dis) - pb[i].rank(dis);
        }
        return ans;
    }
    inline void insert(int x, int v, int Rt)
    {
        pa[x].insert(-v);
        for (int i = x, j; i != Rt; i = j)
        {
            j = f[i];
            int dis = bz.Dis(x, j) - v;
            if (j != Rt)
                pa[j].insert(dis);
            pb[i].insert(dis);
        }
    }
    inline void clear(int x, int fa, int deps)
    {
        vis[x] = 0;
        for (int i = head[x]; i; i = nxt[i])
        {
            int v = to[i];
            if (v == fa || dep[v] <= deps)
                continue;
            clear(v, x, deps);
        }
    }
    inline int build(int x, int pre, int fa, int Rt)
    {
        int rt = get_rt(x, 0, pre).second, bas = sz[x];
        pa[rt].clear();
        pb[rt].clear();
        f[rt] = fa;
        siz[rt] = vis[rt] = 1;
        dep[rt] = dep[fa] + 1;
        insert(rt, r[rt], Rt);
        for (int i = head[rt]; i; i = nxt[i])
        {
            int v = to[i];
            if (vis[v])
                continue;
            siz[rt] += build(v, bas, rt, Rt);
        }
        return siz[rt];
    }
    inline void rebuild(int x)
    {
        if (!x)
            return;
        clear(x, 0, dep[x]);
        build(x, siz[x], f[x], f[x]);
    }
    inline void insert(int x, int v)
    {
        pa[x].insert(-v);
        siz[x]++;
        int Rt = 0;
        for (int i = x, j; f[i]; i = j)
        {
            j = f[i];
            int dis = bz.Dis(x, j) - v;
            siz[j]++;
            pa[j].insert(dis);
            pb[i].insert(dis);
            if (siz[i] > siz[j] * alpha)
                Rt = j;
        }
        rebuild(Rt);
    }
} t;

signed main()
{
    read(), n = read();
    for (int i = 1; i <= n; i++)
    {
        vis[i] = 1;
        int fa = read() ^ lst % 1000000000, c = read();
        r[i] = read();
        bz.insert(i, fa, c);
        if (i > 1)
        {
            add(fa, i);
            add(i, fa);
        }
        t.f[i] = fa;
        t.dep[i] = t.dep[fa] + 1;
        write(lst += t.query(i, r[i]));
        t.insert(i, r[i]);
        putchar('\n');
    }
    return 0;
}
```







---

## 作者：Alear (赞：2)

[题面传送门](https://www.luogu.com.cn/problem/P3920)

## 闲话

断断续续写了差不多一个月了。。。昨天又花了一整天，找出了两只手都数不过来的错误，大概我写的时候睡着了吧。。毕竟是自己没怎么整理好思路就开始想了，但是这题整理好思路对我来说太难了一点。调出来的时候瞬间感觉人间值得。

## 题面

一棵带点权边权的树，每次加一个点，求所有点权和大于等于路径边权和的点对数。  
强制在线。  
$n \leqslant 10^5, r_i\leqslant 10, e\leqslant 10^4$  
时限：12s ~~（大概是常数太大但是还是要卡暴力的）~~

## 题解

前置技能：点分树，高速平衡树~~，一行代码调一天的耐性~~

如果去掉强制在线的话这题其实还是很简单的，普通的点分树板子题。

考虑动态加点，显然把这个点连在其父节点上在正确性是完全没有问题的。

问题在于，点分树复杂度依赖于树的结构，一个极度不平衡的树结构是会导致复杂度爆炸，就像某BST一样。  

可惜的是由于复杂的树结构和复杂的信息维护，我们无法通过旋转调整树高，那怎么办？拍扁重来，让它没脾气，暴力重构可以解决一切不平衡的问题。

大体思路有了，考虑具体需要维护什么。$r_i + r_j \geqslant dis_i + dis_j$，$r_i - dis_i \geqslant dis_j - r_j$在分治中心上保存所有的$dis_j - r_j$即可，每次查询$\leqslant r_i - dis_i$的数量，当然按照传统，我们还需要保存对于其父节点的部分用于容斥。  
据评论区记题解区，出于常数的要求，这里需要使用高速平衡树（除fhq,splay的平衡树）。

查询的时候需要知道$dis_i$的值，但是对于一颗动态的树，虽然因为都是加点可以通过倍增来维护，不免码量太大，偷懒的做法当然是直接用$vector$将所有的祖先和距离都保存下来，加点的时候直接继承，然后在$vector$上爬点分树。

在爬树查询的同时维护每棵点分树的$size$以及$son\_max$，后者具有单调性，直接取$max$即可，无需再加数据结构。

当某个节点$u$，满足$son\_max_u \geqslant size_u \cdot alpha$，说明这颗树已经过度不平衡，需要重构，每次选择最浅的一个进行重构。

考虑如何重构。基本上就是跑一遍静态的点分树了，首先要做的是标记范围和数据清零，可以是跑bfs，我选择直接将所有子节点直接存下来，将所有子节点标记$vis=1,fs,s,son$清零,$dis$弹出到$to\_build$弹出。（变量含义见代码）

这里采用在父节点出计算子节点的$fs$的做法，所以$to\_build$的$fs$将会被保留。

剩下的就是码力与信仰了。

## 再闲话，一些我写的nc错误以及一些要注意的点

首先是写了万年的平衡树，一开始写替罪羊实在写不出来，就换成treap，还是犯了搞错0,1，大小不分的nc错误。

倒腾不等式时我一开始居然还搞反了。

清零时候要清干净，也不要提前加进去一些奇怪的东西。

重构时不要把根设置为全局变量，对于这种写法是会被修改的。

点分树和原树不一样，原树的根不是点分树的根，所以计算$fs$是要用临时变量，而不能直接加到相邻节点上。

构思的时候使用$dis$计算$fs$也许会简单一点，毕竟不用反复考虑递归顺序

保持清醒，要时刻记得自己的标记含义。

注意取模。

善用对拍，调整参数强制程序做出某些行为以检测，比如把$alpha$调小，可以让程序立刻开始重构。

## code
$ Talk \  is \ cheap ,show\ you\ the\ code. $  
这个版本才两百行出头~~（也就两道题的码量）~~，但是调试版本的整整有四百行，有够呛的。

```cpp
#include<bits/stdc++.h>
#define next nxt
using namespace std;
int read(){
	int c=0,nx,sign=1;
	while(!isdigit(nx = getchar()))
		if(nx=='-')
			sign=-1;
	while(isdigit(nx))
		c=c*10+nx-'0',nx=getchar();
	return sign*c;
}
const int N=2e5+20,M=2*N,K=17,mod=1e9;
int head[N],next[M],ver[M],edge[M];
inline void addEdge(int u,int v,int e){
	static int now = 0;
	next[++now]=head[u],head[u]=now,ver[now]=v,edge[now]=e;
	next[++now]=head[v],head[v]=now,ver[now]=u,edge[now]=e;
}
namespace treap{
	int now = 0;
	struct node{
		int rnd;
		int size;
		int val, ch[2], cnt;
	}treap[N*K];
	int rub[N*K], top;
	inline int New(int u=0){
		int s = top ? rub[top--] : ++now;
		node &ss = treap[s];
		ss.ch[0] = ss.ch[1] = 0;
		ss.cnt = ss.size = 1;
		ss.val = u;
		ss.rnd = rand();
		return s;
	}
	void del(int &s){
		if(!s)
			return ;
		if(treap[s].ch[0])
			del(treap[s].ch[0]);
		if(treap[s].ch[1])
			del(treap[s].ch[1]);
		rub[++top] = s;
		s=0;
	}
	inline void upd(int &p){
		treap[p].size = treap[p].cnt + treap[treap[p].ch[0]].size + treap[treap[p].ch[1]].size;
	}
	inline void rot(int &x, int t){
		int y = treap[x].ch[!t];
		treap[x].ch[!t] = treap[y].ch[t];
		treap[y].ch[t] = x;
		upd(x);
		x = y;
		upd(x);
	}
	void insert(int &p, int x){
		if(!p){
			p = New(x);
			return ;
		}
		node &s = treap[p];
		s.size++;
		if(x == s.val){
			s.cnt++;
			return ;
		}
		int t = x > s.val;
		insert(s.ch[t], x);
		if(treap[s.ch[t]].rnd > s.rnd)
			rot(p, !t);
	}
	int query(int p,int val){
		if(!p)
			return 0;
		int ans = 0;
		while(p){
			node &s = treap[p];
			int tmp = s.val;
			if(val < tmp)
				p = s.ch[0];
			else if(val == tmp)
				return ans + s.cnt + treap[s.ch[0]].size;
			else
				p = s.ch[1], ans += s.size - treap[p].size;
		}
		return ans;
	}
}
using treap::del;
using treap::insert;
using treap::query;
typedef vector<int> vi;
typedef pair<int,int> pii;
const double alpha = 0.75;
int n;
int r[N];
int vis[N], fa[N], size[N];
vector<pii> dis[N];//每个点的所有点分树上祖先(包括自身)，距离 
vi son[N];//点分树上的子树内节点，不包括根 
int sm[N];//重儿子的size 
int s[N], fs[N];//子树内点，到祖先的
int to_build;//需要重构的节点 
int get_root(int u,int fa,int n){
	size[u] = 1;
	int flag = 0, &son_max = sm[u];
	son_max = 0;
	for(int i=head[u];i;i=next[i]){
		int v = ver[i];
		if(v == fa or !vis[v])
			continue;
		if(flag = get_root(v, u, n))
			return flag;
		son_max = max(son_max, size[v]);
		size[u] += size[v];
	}
	son_max = max(son_max, n - size[u]);
	if(son_max * 2 <= n)
		return u;
	else
		return 0;
}
int root = 0;//临时记录dfs遍历时的根 
void dfs(int u, int fa,int d,int &s,int &fs){
	size[u] = 1;
	dis[u].push_back(make_pair(root, d));
	son[root].push_back(u);
	
	insert(s, d - r[u]);
	insert(fs, d - r[u]);
	for(int i=head[u];i;i=next[i]){
		int v = ver[i];
		if(v == fa or !vis[v])
			continue;
		dfs(v, u, d + edge[i], s, fs);
		size[u] += size[v];
	}
}
int solve(int u,int f,int n, int _fs){
	int rt = get_root(u, 0, n);
	vis[rt] = 0, fa[rt] = f, fs[rt] = _fs, size[rt] = n;
	
	insert(s[rt], 0 - r[rt]);
	dis[rt].push_back(make_pair(rt, 0));
	for(int i=head[rt];i;i=next[i]){
		int v = ver[i];
		if(!vis[v])
			continue;
		root = rt;
		int _fs = 0;
		dfs(v, rt, edge[i], s[rt], _fs);
		solve(v, rt, size[v], _fs);
	}
	return rt;
}
int main(){
	int cnt = read();
	long long ans = 0;
	n = read();
	read(), read(), r[1] = read();
	insert(s[1], 0 - r[1]);
	size[1] = 1;
	printf("0\n");
	dis[1].push_back(make_pair(1, 0));
	for(int i=2;i<=n;i++){
		int f = read() ^ (ans % mod), e = read();
		r[i] = read();
		addEdge(i, f, e);
		fa[i] = f, size[i] = 1;
		dis[i] = dis[f];
		for(auto &it:dis[i])
			it.second += e, size[it.first]++;
		dis[i].push_back(make_pair(i, 0));
		for(int j=dis[i].size()-2;j>=0;j--){
			pii &it = dis[i][j];
			int f = it.first, d = it.second, p = dis[i][j+1].first;
			
			ans += query(s[f], r[i] - d);
			ans -= query(fs[p], r[i] - d);
			
			insert(s[f], d - r[i]);
			insert(fs[p], d - r[i]);
			son[f].push_back(i);
			
			if(size[p] > sm[f])
				sm[f] = size[p];
			if(sm[f] > size[f] * alpha)
				to_build = f;
		}
		insert(s[i], 0 - r[i]);
		
		if(to_build and i < n){
			for(auto u:son[to_build]){
				vis[u] = 1;
				son[u].clear();
				size[u] = sm[u] = 0;
				while(dis[u].back().first != to_build)
					dis[u].pop_back();
				dis[u].pop_back();
				del(s[u]);
				del(fs[u]);
			}
			son[to_build].clear();
			vis[to_build] = 1;
			dis[to_build].pop_back();
			del(s[to_build]);
			
			int tmp = fs[to_build];
			fs[to_build] = 0;
			solve(to_build, fa[to_build], size[to_build], tmp);
			to_build = 0;
		}
		printf("%lld\n",ans);
	}
}
```



---

## 作者：ecnerwaIa (赞：2)

## P3920 [WC2014]紫荆花之恋
### [题目传送门](https://www.luogu.org/problemnew/show/P3920)
考虑如果题目只查询一次该怎么做，那就是裸的点分树+平衡树了。  
然而此题是动态的，不可能对每个询问都求一次点分树，那么就要动态维护点分树了？  
类似替罪羊树，也是$siz[son[x]]>alpha*siz[x]$时就重构，维护点分树树高，当然重构复杂度其实也是很大的，是$O(log^3n)$，所以aplha不能取太小，取0.8-0.85都是合适的  
哎，你说这谁能不明白呢？关键是这题细节真的多！（其实我是把这题当做点分树入门做的，结果....）首先是算贡献，题目要求$dis(x,i)<=r_x+r_i$  
转化一下，变成求$dis(x,u)+dis(u,i)<=r_x+r_i$,也就是求$dis(u,i)-r_i<=r_x-dis(x,u)$的$i$有多少个，那么就是对于每个重心维护一个$(dis-r)$就好了。  
等等，这不一定是最短路径，那要怎么办？其实可以发现对于当前重心$x$,上一层重心$y$（从底而上）,只要$x$求出的合法路径不经过$y$管辖的那颗子树就好了

![](https://cdn.luogu.com.cn/upload/pic/57180.png)

那么去掉$z$的影响即可，再记一个平衡树维护到$z$（不知道如何表述，看图...）的距离-r,那么就可以算出所有合法的贡献。还有就是这里求$dis$不要用倍增！慢整整一倍！所以改用一个数组$s[x][k]$代表着$x$节点到点分树$dep=k$的点的距离。那么为什么不是记到第$k$祖先的距离呢？因为后面重构如果这样记会发现并不好操作，就算能写复杂度也较大。  
这样记的好处在于重构时因为失配的祖先都没变，那么就只用管这颗子树，否则复杂度就没有保证了  
重构时先清vis数组方便之后判断边界，清除记录的平衡树信息，记的回收节点。  
然后就是重构，假设当前的子树和上一个重心连接的点是$x$(就是图示的$z$啦)，找到的重心为$y$，那么分别以$x,y \ bfs$一次，就是重构$y$节点的平衡树，注意两颗维护的信息不同所以bfs两次（至少我这个方法是两次。。。）以$y$为起点的还要维护下$s$数组，然后好像就没了吧
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <vector>
using namespace std;
#define ri register int
typedef long long LL;
const int N=100010,M=N*45;
const double alpha=0.7;
const double Alpha=0.8;
int rt[N],rt1[N],r[N];
struct SC{
    int ch[M][2],siz[M],v[M],st[M],tail;
    inline void Init(int x){for(ri i=1;i<=x;++i)st[++tail]=i;}
    //初始化 
    inline int get_id(){return st[tail--];}
    //得到一个未被用的数 
    inline void push(int x){st[++tail]=x;}
    //回收 
    #define lc ch[x][0]
    #define rc ch[x][1]
    inline int New(ri val){ri x=get_id();lc=rc=0;siz[x]=1;v[x]=val;return x;}//新建节点 
    inline void pushup(ri x){siz[x]=siz[lc]+siz[rc]+1;}
    inline void rotate(ri&x,register bool c){
        ri y=ch[x][c];ch[x][c]=ch[y][!c];
        ch[y][!c]=x;siz[y]=siz[x];pushup(x);
        x=y;//这样比暴力重构快多了。。。 
    }inline int rk(ri x,ri r){
        ri ans=0;
        while(x){
            if(v[x]<=r)ans+=siz[lc]+1,x=rc;
            else x=lc;
        }return ans;
    }inline void Insert(ri&x,ri val){
        if(!x){x=New(val);return;}
        ++siz[x];
        ri d=val>=v[x];
        Insert(ch[x][d],val);
        if(siz[ch[x][d]]>siz[x]*alpha)rotate(x,d);//判断是否要rotate 
    }inline void recover(int x){if(!x)return;recover(lc);recover(rc);push(x);} 
    inline void clear(ri&x){recover(x);x=0;}//清空平衡树 
}T;
int n;
LL ans;
struct VCD_tree{
    int siz[N],dp[N],dep[N],failpos,center,sum;
    bool vis[N];
    int d[N],nxt[N<<1],to[N<<1],cost[N<<1],tot;
    int p[N],c[N],s[N][50],top[N];
    //p[x]:点分树上x的父亲,dep:点分树上的深度,siz:点分树的大小,dp:求重心用 
    //top[x]:是p[x]相邻的一个点,该点属于x这个重心所管辖的区域,只是为了降低常数,非必要
    //c[x]:top[x]和p[x]这条边的权值,同上非必要
	//s[x][k]:x和点分树上是x父亲并且dep=k的点的距离 
    #define max(a,b) (a>b?a:b)
    inline void add(ri a,ri b,ri v){to[++tot]=b;nxt[tot]=d[a];d[a]=tot;cost[tot]=v;}//加边 
    inline void ins(ri a,ri b,ri v){
        add(a,b,v);add(b,a,v);
        c[b]=s[b][0]=v;p[top[b]=b]=a;
        //初始p[b]=a,top[b]=a 
    }int st[N],f[N],dis[N],L,R;
    inline void bfs(ri x){//找重心 
        st[L=R=1]=x;f[x]=0;
        ri i,u;
        while(L<=R){
            x=st[L++];
            siz[x]=1;dp[x]=0;
            for(i=d[x];i;i=nxt[i]){u=to[i];if(!vis[u]&&u!=f[x])st[++R]=u,f[u]=x;}
        }for(i=R;i>=1;--i){
            u=st[i];siz[f[u]]+=siz[u];dp[f[u]]=max(dp[f[u]],siz[u]);
            dp[u]=max(dp[u],sum-dp[u]);
            if(dp[u]<dp[center])center=u;
        }
    }inline int get_center(ri x){sum=siz[x];center=0;bfs(x);return center;}//这个没啥好说的 
    int maxx;
    inline void clear(ri x){
        st[L=R=1]=x;ri i,u;
        while(L<=R){
            x=st[L++];vis[x]=0;//清除vis 
            T.clear(rt[x]);T.clear(rt1[x]);//清除平衡树 
            for(i=d[x];i;i=nxt[i]){u=to[i];if(dep[u]>=maxx&&vis[u])st[++R]=u;}
        }
    }inline int work(ri x){
        siz[x]=vis[x]=1;dep[x]=dep[p[x]]+1;
        for(ri i=1;i<=dep[p[x]];++i)s[x][i]=s[p[x]][i]+c[x];
		//因为除非是p[y]和p[p[y]]跨过了x这样不能简单的+c[x]
		//而因为如果跨过了x,说明不连通？所以肯定可以这样,而下面重构就只有bfs 
        //初始化 
        ri ans=0,v=0;T.Insert(rt[x],-r[x]);
        failpos=0;
        for(ri y=x,k=dep[x];p[y];--k,y=p[y]){
            v=s[x][k-1];//其实就是x和p[y]的距离 
            T.Insert(rt[p[y]],v-r[x]);T.Insert(rt1[y],v-r[x]-c[y]);//肯定是相差一个c[y]啦 
            ans+=T.rk(rt[p[y]],r[x]-v)-T.rk(rt1[y],r[x]-v-c[y]);
            ++siz[p[y]];
            if(siz[y]>=siz[p[y]]*Alpha)failpos=p[y];
        }if(failpos){//重构
            maxx=dep[failpos]; 
            clear(failpos);
            x=p[failpos];
            siz[top[failpos]]=siz[failpos];
			//注意这个一定要,因为top[failpos]不一定等于failpos
			//但是siz确实siz[failpos],是点分树和原树的区别 
            rebuild(top[failpos],x,c[failpos]);
        }return ans;
    }inline void build(ri x,ri now){//这个是以top[重心]为起点建的平衡树 
        st[L=R=1]=x;f[x]=dis[x]=0;ri i,u;
        while(L<=R){
            x=st[L++];
            T.Insert(rt1[now],dis[x]-r[x]);
            for(i=d[x];i;i=nxt[i]){u=to[i];if(!vis[u]&&u!=f[x])st[++R]=u,f[u]=x,dis[u]=dis[x]+cost[i];}
        }
    }inline void build_2(ri x,ri now){//这个是以重心为起点建的平衡树 
        st[L=R=1]=x;f[x]=dis[x]=0;ri i,u;
        while(L<=R){
            x=st[L++];
            T.Insert(rt[now],dis[x]-r[x]);
            s[x][dep[now]]=dis[x];//顺便重构s数组 
            for(i=d[x];i;i=nxt[i]){u=to[i];if(!vis[u]&&u!=f[x])st[++R]=u,f[u]=x,dis[u]=dis[x]+cost[i];}
        }
    }inline void rebuild(ri x,ri f,ri v){
        ri y=get_center(x);p[y]=f;dep[y]=dep[f]+1;
        //得到重心,重构下p:父亲,dep 
        build(x,y);
        build_2(y,y);
        vis[y]=1;siz[y]=siz[top[y]=x];c[y]=v;
        //siz需要赋值,还是因为是原树和点分树的区别
		//top[y]=x,c[y] =v 这个毋庸置疑吧 
        ri i,u;
        for(i=d[y];i;i=nxt[i]){
            u=to[i];
            if(!vis[u])rebuild(u,y,cost[i]);
        }
    }
}wjr;
const int maxn=1<<20;
char IN[maxn+10],*A,*B;
#define nc() (A==B&&(B=(A=IN)+fread(IN,1,maxn,stdin),A==B)?EOF:*A++)
inline void read(ri&x){
    x=0;ri f=1;register char c=nc();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=nc();
    x*=f;
}int kkk_is_our_red_sun[50],cnt;//逃 
inline void print(register LL x){cnt=0;
    if(!x)kkk_is_our_red_sun[++cnt]=0;
    while(x)kkk_is_our_red_sun[++cnt]=x%10,x/=10;
    for(ri i=cnt;i>=1;--i)putchar('0'+kkk_is_our_red_sun[i]);
    putchar('\n');
}const int mod=1e9;
int main(){
    T.Init(M-10);wjr.top[1]=1;
    scanf("%*d");read(n);wjr.dp[0]=n<<1;//初始化省的后面判断 
    int a,b;
    read(a);read(b);read(r[1]);wjr.work(1);
    putchar('0');putchar('\n');
    for(ri i=2;i<=n;++i){
        read(a);read(b);read(r[i]);
        a^=(ans%mod);wjr.ins(a,i,b);
        ans+=wjr.work(i);print(ans);
    }
    return 0;
}

```


---

## 作者：ZillionX (赞：1)

# Description

给出一棵树，每个点有点权 $r_i$，求 $r_x+r_y \ge d(x,y)$ 的点对数目。同时，你需要支持插入叶子结点。

$n \le 10^5, r \le 10^9$，时限 12s。

# Solution

我们先不考虑修改，直接在原树上进行点分治。

设当前的分治中心为 $u$，不妨将原式化成 $d(u,x)-r_x \le r_y-d(u,y)$，这个显然可以用平衡树维护。

但是，由于平衡树的大常数，卡过这个题对于我们来说比较困难。所以我选择用动态数组和根号分治做到小常数 $\mathcal O(n \sqrt n)$ 代替大常数 $\mathcal O(n \log n)$ 的平衡树。

具体地，我们维护两个动态数组 $x,y$，这里约定 ${\rm siz}_x \ge {\rm siz}_y$。插入时，暴力在 $y$ 中二分加入元素，若 ${\rm siz}_y$ 超过阀值 $B$，则归并 $x,y$；查询时，在 $x,y$ 中二分查找即可。

回到原题，由于需要支持插入叶子结点，我们只能用动态点分治处理。每次插入时，直接在点分树上和原树一样地暴力建边。但是，这样显然无法保证点分树的高度是 $\mathcal O(\log n)$ 级别的，因此复杂度会退化。

这个时候，我们就需要借鉴替罪羊树的思想，重构局部不平衡的点分树。具体地，在点分树上插入叶子结点，枚举其祖先时，若 ${\rm siz}_x \ge \alpha \times {\rm siz}_{{\rm fa}_x}$，则对 ${\rm fa}_x$ 的子树重新跑一遍点分治，重建点分树。

众所周知，普通替罪羊树的重构比查询少一个 $\log$，一般 $\alpha=0.75$，而本题重构复杂度较大，所以实际应用中 $\alpha=0.9$ 比较合适。

对于查询，我们按照老套路在点分树上跳父亲就好了。但是显然需要维护 LCA，然而本题需要插入叶子结点，所以使用倍增 LCA 比较合适。

复杂度不会算，大概带个 $\sqrt n$ 和几个 $\log n$，实际跑起来很快。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+5,B=300;
const int mod=1e9;
const double alp=0.95;
int typ,n,NumE,Sum,rt,lst,Fir[N],dep[N],dis[N],fa[N][25],r[N],ff[N],dd[N],ss[N],lg2[N],sl[N],sz[N];
bool vis[N];
vector<int> g[N];
struct Edge {
	int v,nxt;
}E[N*2];
void AddE(int u,int v) {
	E[++NumE]=(Edge){v,Fir[u]};
	Fir[u]=NumE;
}
int LCA(int x,int y) {
	if (dep[x]<dep[y]) swap(x,y);
	for (int i=lg2[dep[x]];i>=0;i--)
		if (dep[fa[x][i]]>=dep[y])
			x=fa[x][i];
	if (x==y) return x;
	for (int i=lg2[dep[x]];i>=0;i--)
		if (fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int Dis(int x,int y) {
	return dis[x]+dis[y]-dis[LCA(x,y)]*2;
}
struct BST {
	vector<int> b,s;
	void Ins(int x) {
		s.insert(lower_bound(s.begin(),s.end(),x),x);
		if (s.size()>=B) {
			vector<int> t;t.clear();
			t.resize(b.size()+s.size());
			merge(b.begin(),b.end(),s.begin(),s.end(),t.begin());
			swap(b,t);s.clear();
		}
	}
	int rk(int x) {
		return (upper_bound(b.begin(),b.end(),x)-b.begin())+(upper_bound(s.begin(),s.end(),x)-s.begin())-2;
	}
	void clr() {
		b.clear(),s.clear();
	}
}v[N],fv[N];
void GetR(int x,int fa) {
	sl[x]=0,sz[x]=1;
	for (int i=Fir[x];i;i=E[i].nxt) {
		if (!vis[E[i].v] && E[i].v!=fa) {
			GetR(E[i].v,x);
			sl[x]=max(sl[x],sz[E[i].v]);
			sz[x]+=sz[E[i].v];
		}
	}
	sl[x]=max(sl[x],Sum-sz[x]);
	if (sl[x]<sl[rt]) rt=x;
}
void rins(int x,int r,int gua) {
	v[x].Ins(-r);
	int p=x;
	while (p!=gua) {
		if (ff[p]!=gua) v[ff[p]].Ins(Dis(x,ff[p])-r);
		fv[p].Ins(Dis(x,ff[p])-r);
		p=ff[p];
	}
}
void Dfs(int u,int fa,int gua) {
	vis[u]=true;
	v[u].clr(),fv[u].clr();
	ff[u]=fa,dd[u]=dd[fa]+1;
	ss[u]=1,rins(u,r[u],gua);
	GetR(u,0);
	g[u].clear(); 
	for (int i=Fir[u];i;i=E[i].nxt)
		if (!vis[E[i].v]) {
			rt=0,sl[0]=n,Sum=sz[E[i].v];
			GetR(E[i].v,u);
			g[u].push_back(rt);
			int now=rt;
			Dfs(rt,u,gua);
			ss[u]+=ss[now];
		}
}
void clr(int u) {
	vis[u]=0;
	for (int i=0;i<g[u].size();i++)
		clr(g[u][i]);
}
void rebd(int u) {
	if (!u) return;
	clr(u);
	rt=0,sl[0]=n,Sum=ss[u];
	GetR(u,0);
	for (int i=0;i<g[ff[u]].size();i++)
		if (g[ff[u]][i]==u) g[ff[u]][i]=rt;
	Dfs(rt,ff[u],ff[u]);
}
void Udfz(int x,int r) {
	v[x].Ins(-r);
	ss[x]++;
	int rb=0,p=x;
	while (ff[p]) {
		ss[ff[p]]++;
		v[ff[p]].Ins(Dis(x,ff[p])-r);
		fv[p].Ins(Dis(x,ff[p])-r);
		if (1.0*ss[p]>1.0*ss[ff[p]]*alp) rb=ff[p];
		p=ff[p];
	}
 	rebd(rb);
}
int Qdfz(int x,int r) {
	int Ans=0,p=x;
	while (ff[p])
		Ans+=v[ff[p]].rk(r-Dis(x,ff[p]))-fv[p].rk(r-Dis(x,ff[p])),
//		printf("%d\n",p),
		p=ff[p];
	return Ans;
}
signed main() {
	scanf("%lld%lld",&typ,&n);
	for (int i=2;i<=n;i++) lg2[i]=lg2[i>>1]+1;
	for (int i=1;i<=n;i++) {
		vis[i]=1;
		int x,y;
		scanf("%lld%lld%lld",&x,&y,&r[i]);
		x=x^(lst%mod);
		fa[i][0]=x,dep[i]=dep[x]+1,dis[i]=dis[x]+y;
		for (int j=1;j<=lg2[dep[i]];j++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
		if (i>1) AddE(i,x),AddE(x,i);
		ff[i]=x,dd[i]=dd[x]+1;
		g[x].push_back(i);
//		printf("D");
		lst+=Qdfz(i,r[i]);
//		printf("D");
		printf("%lld\n",lst);
		Udfz(i,r[i]);
	}
//	printf("%d\n",Dis(2,5));
	return 0;
}
```


---

## 作者：pldzy (赞：1)

# Solution

在此提供一种可能相对其他解法~~较为好写~~的做法。

## 一

首先考虑一棵如下图的树，其中 $rtlr_0=6,\ rtlr_1=5$。

![1](https://img-blog.csdnimg.cn/d5e23f207b014b5789c81d4101795cdb.png#pic_center)

发现此时这棵树不考虑根节点只有两条链，而左右链的末尾分别是 $rtlr_0$ 和 $rtlr_1$。

同时，~~按照套路~~，我们将 $dist(i,j) \leq r_i+r_j$ 化为 $dist(i, l)-r_i\leq r_j-dist(j,l)$，其中 $l$ 为 $i$ 和 $j$ 的最近公共祖先。

对于上图，我们只用维护 4 棵平衡树（使用平衡树因为我们是在维护在某一集合内比某数要大的值的个数）就可以把答案求出，具体实现如下：

```cpp

inline void add(int u, int v, int w){
	e[++cnt] = (edge){v, hd[u], w}, hd[u] = cnt;
	e[++cnt] = (edge){u, hd[v], w}, hd[v] = cnt;
}

inline void rotate(int &x, int k){
	int y = t[x].ch[k];
	t[x].ch[k] = t[y].ch[!k], t[y].ch[!k] = x;
	t[y].s = t[x].s, 
	t[x].s = t[t[x].ch[1]].s + t[t[x].ch[0]].s + 1;
	x = y;
}

inline void insrt(int &x, int v){
	if(!x){
		x = ++tot;
		t[x].s = 1, t[x].a = v;
		return;
	}
	bool k = (v >= t[x].a);
	insrt(t[x].ch[k], v), t[x].s += 1;
	if(t[x].s * 0.8 < t[t[x].ch[k]].s) 
		rotate(x, k);
}

inline int query(int x, int v){
	if(!x) return 0;
	if(v <= t[x].a) 
		return query(t[x].ch[0], v) + t[t[x].ch[1]].s + 1;
	else return query(t[x].ch[1], v);
}


int main(){
	rd(), n = rd(), rd(), rd(), val[1] = rd();
	rtlr[0] = rtlr[1] = 1;
	printf("0\n");
	insrt(rt1[0], val[1]), insrt(rt1[1], val[1]);//rt1/2[0]维护左边的分支 
	insrt(rt2[0], val[1]), insrt(rt2[1], val[1]);//rt1/2[1]维护右边的分支 
	for(i = 2; i <= n; ++i){
		f[i] = rd() ^ ans % mod, j = rd(), val[i] = rd();
		if(f[i] != rtlr[1] and f[i] != rtlr[0]) break;//如果此时不满足只有两条链的形态，就 break 掉 
		add(i, f[i], j);
		dis[i] = dis[f[i]] + j;//dis[i] 为 i 到根节点的距离 
		fx = (f[i] == rtlr[1])/*看 i 在左右哪条链上*/, rtlr[fx] = i;
		ans += query(rt1[fx], dis[i] - val[i]) + query(rt2[!fx], dis[i] - val[i]); 
		if(dis[i] <= val[1] + val[i]) ans -= 1;//减去重复计算的 
		insrt(rt1[fx], dis[i] + val[i]), insrt(rt2[fx], val[i] - dis[i]);//rt1和rt2分别插入不同的值，辅助求解答案 
		printf("%lld\n", ans); 
	} 
}
```

## 二

然后我们再来考虑当树的形态不满足上面的要求时，如下图：

![2](https://img-blog.csdnimg.cn/d43aa4ebda234b70975d85ad1e39fa62.png#pic_center)

### 1. 求解答案

面对这种情况，我们对于每个点要维护两棵平衡树：

一棵用于记录以当前节点 $i$ 为根的树内每个子节点 $j$ 的 $r_j-dist(j, fa_i)$ 的值，这棵平衡树的根的编号记为 $ms_i$；

一棵用于记录当前节点 $i$，它其中一个儿子 $j$，$j$ 子树内的所有子节点 $k$ 的 $r_k-dist(k,i)$ 的值，记为 $gs_i$（注意 $gs_i$ 中并没有记录 $i$ 的直接儿子 $j$ 的信息）。

对于每个节点，我们再去维护它分别到每一个深度的祖先的距离，对于第 $k$ 层的祖先，节点 $i$ 到它的距离记为 $adis_{k,i}$。

然后我们试着去求一下对于新增的一个节点 $i$，最终答案是多少。

过程如下：

```cpp
	for(k = dep[f[i]], l = f[i], o = i; l; k--, o = l, l = f[l])
		u = adis[k][i] - val[i],
		ans += query(gs[l], u) - query(ms[o], u);
```

我们从下往上去遍历每一个祖先，对于每一个祖先，我们利用刚刚对每个节点维护的两棵平衡树进行求解答案。

### 2. 添加新节点

然后我们就考虑如何把这个节点加入这棵树内。

首先，肯定是按照刚刚求答案那样，从下往上去遍历祖先，对于每一个祖先，我们分别在它的两棵平衡树内插入新节点的信息即可。

但是如果单单只是这样，树的深度就可能会无止境地增加，这绝不是我们想要的。

~~所以这时候就要请出替罪羊树了！~~ 我们用替罪羊树的思路，在从下往上遍历祖先的同时，去检查每棵子树的大小有没有超过其父亲子树大小的 0.88 倍。

如果有，就把它记录下来，然后就对它进行重构。

重构一棵树的步骤：

1. “拍扁”这棵树，然后选出一个大小刚刚好超过或等于总节点数一半的节点，把它当做新根。

2. 对于这个新根，我们去建立它的新平衡树，然后对它的每一个儿子，重复第 1 和 2 步。

然后这道题就结束了，复杂度可过。

虽然~~口胡~~起来并不复杂，但是代码实现的时候还是需要注意很多细节的。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
const int maxn = 1e5 + 5;
const int mod = 1000000000;

inline int rd(){
	int x = 1, s = 0;
	char ch = getchar();
	while(ch < '0' or ch > '9'){
		if(ch == '-') x = -1;
		ch = getchar();
	}
	while(ch >= '0' and ch <= '9')
		s = s * 10 + ch - '0', ch = getchar();
	return s * x;
}

struct tree{
	int s, a;
	int ch[2];
}t[maxn * 200];
bool fx;
int rt1[2], rt2[2], rtlr[2];
int n, m, i, j, k, l, o, u, v;
int val[maxn], f[maxn];
int cnt, hd[maxn];
struct edge{
	int to, nxt, w;
}e[maxn << 1];
int tsiz[maxn], siz[maxn], in[maxn], id[maxn];
int gs[maxn], ms[maxn];
int dep[maxn], dis[maxn], adis[100][maxn];
int pre[maxn], he, ta, que[maxn];
int tot;
ll ans;

inline void add(int u, int v, int w){
	e[++cnt] = (edge){v, hd[u], w}, hd[u] = cnt;
	e[++cnt] = (edge){u, hd[v], w}, hd[v] = cnt;
}

inline void rotate(int &x, int k){
	int y = t[x].ch[k];
	t[x].ch[k] = t[y].ch[!k], t[y].ch[!k] = x;
	t[y].s = t[x].s, 
	t[x].s = t[t[x].ch[1]].s + t[t[x].ch[0]].s + 1;
	x = y;
}

inline void insrt(int &x, int v){
	if(!x){
		x = ++tot;
		t[x].s = 1, t[x].a = v;
		return;
	}
	bool k = (v >= t[x].a);
	insrt(t[x].ch[k], v), t[x].s += 1;
	if(t[x].s * 0.8 < t[t[x].ch[k]].s) 
		rotate(x, k);
}

inline int query(int x, int v){
	if(!x) return 0;
	if(v <= t[x].a) 
		return query(t[x].ch[0], v) + t[t[x].ch[1]].s + 1;
	else return query(t[x].ch[1], v);
}

inline int fndrt(int x, int tdep, int tdis, int fa){
	int i, j, k;
	he = ta = 0;
	que[ta++] = x, dis[x] = tdis;
	pre[x] = 0;
	while(he != ta){
		i = que[he++];
		dep[i] = tdep + 1, tsiz[i] = 1;
		for(j = hd[i]; j; j = e[j].nxt){
			k = e[j].to;
			if(k != pre[i] and dep[k] >= tdep)
				que[ta++] = k, pre[k] = i, 
				dis[k] = dis[i] + e[j].w;
		}
		if(tdep) adis[tdep - 1][i] = dis[i];
	}
	for(i = ta - 1; i >= 0; --i){
		k = pre[que[i]];
		tsiz[k] += tsiz[que[i]];
		if(tsiz[que[i]] * 2 >= ta) break;
	}
	j = que[i], f[j] = fa, siz[j] = ta, dep[j] = tdep;
	if(tdep) in[j] = x, id[j] = tdis;
	else in[j] = id[j] = 0;
	return j;
}

inline void build(int x){
	int i, j, k, l, o;
	adis[dep[x]][x] = gs[x] = 0;
	insrt(gs[x], val[x]);
	for(i = hd[x], j = e[i].to; i; i = e[i].nxt, j = e[i].to){
		if(dep[j] < dep[x]) continue;
		k = fndrt(j, dep[x] + 1, e[i].w, x);
		ms[k] = 0;
		for(l = 0; l < siz[k]; ++l){
			o = que[l];
			insrt(gs[x], val[o] - dis[o]);
			insrt(ms[k], val[o] - dis[o]);
		}
		build(k);
	}
}

inline void calc(int i){
	add(i, f[i], j);
	dep[i] = dep[f[i]] + 1, siz[i] = 1, 
	in[i] = i, id[i] = j;
	insrt(gs[i], val[i]);
	for(k = 0; k < dep[i]; ++k) 
		adis[k][i] = adis[k][f[i]] + j;
	for(k = dep[f[i]], l = f[i], o = i; l; k--, o = l, l = f[l])
		u = adis[k][i] - val[i],
		ans += query(gs[l], u) - query(ms[o], u);
	printf("%lld\n", ans);
	for(k = dep[f[i]], v = 0, l = f[i], o = i; l; k--, o = l, l = f[l]){
		u = val[i] - adis[k][i];
		insrt(gs[l], u), insrt(ms[o], u);
		siz[l] += 1;
		if(siz[l] * 0.88 < siz[o]) v = l;
	}
	if(v){
		if(dep[v]) u = fndrt(in[v], dep[v], id[v], f[v]);
		else u = fndrt(1, 0, 0, 0);
		ms[u] = ms[v], ms[v] = 0;
		build(u); 
	}
}

int main(){
	rd(), n = rd(), rd(), rd(), val[1] = rd();
	rtlr[0] = rtlr[1] = 1;
	printf("0\n");
	insrt(rt1[0], val[1]), insrt(rt1[1], val[1]);
	insrt(rt2[0], val[1]), insrt(rt2[1], val[1]);
	for(i = 2; i <= n; ++i){
		f[i] = rd() ^ ans % mod, j = rd(), val[i] = rd();
		if(f[i] != rtlr[1] and f[i] != rtlr[0]) break;
		add(i, f[i], j);
		dis[i] = dis[f[i]] + j;
		fx = (f[i] == rtlr[1]), rtlr[fx] = i;
		ans += query(rt1[fx], dis[i] - val[i]) + query(rt2[!fx], dis[i] - val[i]); 
		if(dis[i] <= val[1] + val[i]) ans -= 1;
		insrt(rt1[fx], dis[i] + val[i]), insrt(rt2[fx], val[i] - dis[i]);
		printf("%lld\n", ans); 
	} 
	if(i > n) return 0;
	for(k = 1; k <= tot; ++k) 	
		t[k].ch[0] = t[k].ch[1] = 0;
	tot = 0, memset(dis, 0, sizeof dis);
	k = fndrt(1, 0, 0, 0), build(k);
	for(calc(i), i += 1; i <= n; ++i)
		f[i] = rd() ^ ans % mod, j = rd(), val[i] = rd(), calc(i);
	return 0;
}
```


------------
感谢阅读。

辛苦管理员审核，若有问题烦请指出。

---

## 作者：Rui_R (赞：1)

久仰大名。

[原题](https://www.luogu.com.cn/problem/P3920)

首先，强制在线，那么就需要每次加入一个点并判断有几个点跟它满足条件。

注意到条件是 $dis$ ，于是想到点分树。

假如当前加入点为 $\alpha$，它跟 $\beta$ 满足条件，它们在点分树上的 $\text{lca}$ 为 $x$，那么有 

$$dis(\alpha,x)+dis(x,\beta)\le r_{\alpha}+r_{\beta}$$

$$dis(x,\beta)-r_{\beta}\le r_{\alpha}-dis(\alpha,x)$$

加入 $\alpha$ 的时候，对于它的每一个点分树上祖先 $x$，右边那部分都是确定的。

所以只要对于每个点分树上的点，维护一个支持插入，求权值小于等于一个数的点的数量的数据结构就好了。加入点的时候把 $dis(x,\alpha)-r_{\alpha}$ 作为权值加入到它的祖先里去就好了。

因为值域很大并且不能离散化，放弃权值线段树，改成平衡树。（不然空间大概会死的很惨吧）

当然，需要一个套路的容斥，对于每个点分树上的点 $x$ ，再维护一下它在点分树上的所有子树上点 $\alpha$ 和到其点分树上的父亲 $\beta$ ，还有一棵容斥所需要的，以 $dis(\alpha,\beta)-r_{\alpha}$ 为权值的平衡树，从而在跳祖先的时候减去当前子树的贡献。

然后，由于近期洛谷评测姬性能显著提高，**FHQ活了！**

求 $dis$ 的时候需要 $\text{lca}$ ，这个如果你吃得特别撑的话可以写 $\text{LCT}$ ，但是估计也会死的很惨。实际上新加入一个叶子，它的倍增数组是很好维护的。所以倍增就好了。 

接下来，我们发现一个令人悲痛的问题：点分树可以为所欲为的跳祖先是因为它树高是 $\log$ 的，我们这个带插入的话，树高要怎么保证啊？

**像替罪羊那样，如果出现一个特别不平衡的子树，将其重构。**

于是梳理一下算法流程：

对于一个新加入的点，找到它的父亲在点分树上的位置，一路上跳更新其祖先的平衡树。

同时，更新它的祖先们在点分树上的 $size$ ，并记录下最高的，需要被重构的位置。

如果需要重构的话，先把它的 $\alpha$ 枚举一下，清掉这些点的平衡树。当然，这里需要垃圾回收。同时，记录这些点“需要被重构”。

然后就像一棵正常的点分树那样，把这些点建起来就好，重新计算它们的 $\alpha,\beta$，以及它们的平衡树。最后将这些点所成的树的根的 $\beta$ 标为原来的，这些点所成的树的根的 $\beta$。

其余不需要被重构的点，它们所维护好的东西不需要改变。

至于求每个点重儿子的大小，由于只有加点没有删点，不需要数据结构，每次改 $size$ 的时候尝试更新它父亲的重儿子大小就好了。

由于重构点分树的代价比较大，所以需要把平衡因子调大一点，大概在 $0.8$ 到 $0.9$ 左右。亲测 $0.7$ 左右效果欠佳。

**写的时候一定要保持头脑清醒。或者说，等到状态好的时候再来写这个。**

剩下的，见代码。

```
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <vector>

typedef long long ll;
const int maxn = 1e5 + 5,mod = 1e9;

template<typename T>
inline void swap(T &a,T &b){
	T temp=a;a=b;b=temp;
}

template<typename T>
inline T max(const T &a,const T &b){
	return a>b?a:b;
}

int n;ll RM[maxn],answer;

struct IO{
	IO(){};char c;
	inline char gc(){
		static char buf[maxn],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;
	}
	template<typename T>
	inline IO&operator>>(T &_){
		_=0;bool f=1;c=gc();while(c<'0'||c>'9'){if(c=='-') f=0; c=gc();}
		while(c>='0'&&c<='9'){_=_*10+c-48;c=gc();}if(!f) _=-_;return *this;
	}
	template<typename T>
	inline IO&operator<<(T x){
		if(!x){putchar(48);putchar('\n');return *this;}
		static int wt[40],len;len=0;if(x<0){putchar('-');x=-x;}
		for(;x;x/=10){wt[++len]=x%10;}
		while(len){putchar(wt[len--]+48);}
		putchar('\n');return *this;
	}
}io;

namespace Tree{
	struct edge{
		int v,nxt;ll w;
	}e[maxn<<1];
	int S,fir[maxn],edge_cnt;
	inline void add_edge(int u,int v,ll w){
		e[++edge_cnt].nxt=fir[u];e[edge_cnt].v=v,e[edge_cnt].w=w;fir[u]=edge_cnt;
	}
	int anc[maxn][21];ll dis[maxn];int dep[maxn];
	const int lim = 20;
	void insert(int fa,ll w){
		anc[++S][0]=fa;dis[S]=dis[fa]+w,dep[S]=dep[fa]+1;
		add_edge(fa,S,w),add_edge(S,fa,w);
		for(int i=1;i<=lim;i++) anc[S][i]=anc[anc[S][i-1]][i-1];//维护倍增
	}
	int lca(int Alpha,int Beta){
		if(dep[Alpha]<dep[Beta]) swap(Alpha,Beta);
		for(int i=lim;i>=0;i--) if(dep[anc[Alpha][i]]>=dep[Beta]) Alpha=anc[Alpha][i];
		if(Alpha==Beta) return Alpha;
		for(int i=lim;i>=0;i--) if(anc[Alpha][i]!=anc[Beta][i]) Alpha=anc[Alpha][i],Beta=anc[Beta][i];
		return anc[Alpha][0];
	}
}

using namespace Tree;

inline ll El_Psy_Congroo(int Alpha,int Beta){
	int Tina=lca(Alpha,Beta);
	return dis[Alpha]+dis[Beta]-2*dis[Tina];
}

//求两个点在原树上的距离

namespace Steins{
	struct gate{
		struct node{
			#define null 0
			node *l,*r;ll val;int size,luck;
			node()
			{l=r=null;size = 1;luck=rand();}
			void push_up(){
				size=(l?l->size:0)+(r?r->size:0)+1;
			}
		}*rt[maxn],*Alpha,*Beta,*biz[maxn*30],*pt;int top;
		gate(){pt=(node*)malloc(sizeof(node)*maxn*30);}
		inline node* Ot(){
			node *p;if(top) p=biz[top--];else p=pt++;
			p->l=p->r=null,p->size=1,p->luck=rand();return p;
		}
		node* &operator[](const int &id){
			return rt[id];
		}
		void split(node *now,ll key,node* &Alpha,node* &Beta){
			if(now==null){Alpha=Beta=null;return ;}
			if(now->val<=key){Alpha=now;split(now->r,key,now->r,Beta);}
			else{Beta=now;split(now->l,key,Alpha,now->l);}
			return now->push_up();
		}
		node* merge(node *Alpha,node *Beta){
			if(Alpha==null) return Beta;if(Beta==null) return Alpha;
			if(Alpha->luck>=Beta->luck){Alpha->r=merge(Alpha->r,Beta);return Alpha->push_up(),Alpha;}
			else{Beta->l=merge(Alpha,Beta->l);return Beta->push_up(),Beta;}
		}
		void insert(int id,ll val){
			split(rt[id],val,Alpha,Beta);
			node *W=Ot();W->val=val;
			rt[id]=merge(merge(Alpha,W),Beta);
		}
		int wonder(int id,ll key){
			split(rt[id],key,Alpha,Beta);
			int answer = Alpha?Alpha->size:0;
			return rt[id]=merge(Alpha,Beta),answer;
		}
		void Amadues(node* &now){
			if(now==null) return ;
			Amadues(now->l),Amadues(now->r);
			biz[++top] = now;now = null;
		}
	}Sg,Sg0;
	const double zeta = 0.818;
	std::vector<int> Alpha[maxn];
	int cnt=0,Beta[maxn];	int barrey[maxn];bool Dance[maxn];
	int rt,Ms,S;	int King,Queen;
	int dfs_S(int now,int fa){
		int answer = 1;
		for(int i=fir[now];i;i=e[i].nxt){
			int v=e[i].v;if(v==fa||!Dance[v]) continue;
			answer += dfs_S(v,now);
		}
		return answer ;
	}
	int dfs_rt(int now,int fa){
		int answer = 1,result = 0;
		for(int i=fir[now];i;i=e[i].nxt){
			int v=e[i].v;if(v==fa||!Dance[v]) continue;
			int tp = dfs_rt(v,now);
			answer += tp , result = max(result , tp);
		}
		if((result=max(result,S-answer))<Ms) Ms=result,rt = now;
		return answer ;
	}
	void divide(int now){//重构
		Alpha[now].clear();
		Dance[now]=false;barrey[now]=0;Alpha[now].push_back(now);
		for(int i=fir[now];i;i=e[i].nxt){
			int v=e[i].v;if(!Dance[v]) continue;
			S=Ms=dfs_S(v,0);dfs_rt(v,0);int Cris = rt;Beta[Cris] = now;
			divide(rt);barrey[now]=max(barrey[now],(int)Alpha[Cris].size());
			for(unsigned p=0;p<Alpha[Cris].size();p++) Alpha[now].push_back(Alpha[Cris][p]);
		}
		int x = now;
		while(x!=Queen){//跳到Queen，也就是被重构的子树的原来的根的父亲就不用跳了
			Sg.insert(x,El_Psy_Congroo(x,now)-RM[now]);
			if(Beta[x]) Sg0.insert(x,El_Psy_Congroo(Beta[x],now)-RM[now]);
			x = Beta[x];
		}
	}
	void rebuild(){
		for(unsigned p=0;p<Alpha[King].size();p++){
			int now = Alpha[King][p];
			Dance[now]=true;//Dance表示这个点是否需要被重构
			Sg.Amadues(Sg[now]),Sg0.Amadues(Sg0[now]);
		}
		Ms=S=Alpha[King].size();dfs_rt(King,0);Beta[rt]=Queen;divide(rt);//divide会自己把Dance复原
	}
	void insert(int fa,ll w){
		if(fa>cnt){printf("now:%d fa:%d\n",cnt+1,fa);throw;}//调试用，如果Wa掉了，立刻会在这里结束。
		Tree::insert(fa,w);int now=++cnt;int x = now;Beta[now] = fa;
		King = 0 , Queen = 0;
		while(now){
			Alpha[now].push_back(x);
			if(Beta[now]&&barrey[Beta[now]]<Alpha[now].size()) barrey[Beta[now]]=Alpha[now].size();
			//barrey存重儿子大小
			if((double)barrey[now]>zeta*Alpha[now].size()) King = now,Queen = Beta[now];
			Sg.insert(now,El_Psy_Congroo(now,x)-RM[x]);
			if(Beta[now]) Sg0.insert(now,El_Psy_Congroo(Beta[now],x)-RM[x]);
			now=Beta[now];
		}
		if(King) rebuild();
	}
	void Pepper(){
		int now = cnt;
		answer+=Sg.wonder(now,RM[now])-1;//减掉自己
		while(Beta[now]){
			int Tina = Beta[now];ll tp=RM[cnt]-El_Psy_Congroo(cnt,Tina);
			answer+=Sg.wonder(Tina,tp)-Sg0.wonder(now,tp);
			now=Beta[now];
		}
	}
}

int main(){
	// freopen("1.in","r",stdin);freopen("Steins;gate","w",stdout);
	srand(time(null));io>>n>>n;
	for(int i=1;i<=n;i++){
		ll a,c;io>>a>>c>>RM[i];
		a^=(answer%mod);
		Steins::insert(a,c);Steins::Pepper();
		io<<answer;
	}
	return 0;
}

```

在 darkbzoj 上怒砍次劣解。

---


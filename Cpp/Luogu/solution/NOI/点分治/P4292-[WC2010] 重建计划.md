# [WC2010] 重建计划

## 题目描述

X 国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X 国由 $N$ 个城市组成, 重建小组提出，仅需建立 $N-1$ 条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含 $N-1$ 条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路 $e$ 建设之后可以带来的价值 $v(e)$。  

由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为 $k$ 条，但需满足 $L \leq k \leq U$，即不应少于$L$ 条，但不超过 $U$ 条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的 $k$ 条路径可以构成一个排列 $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \cdots , e_k = (p_k, q_k)$， 对于 $1 \leq i < k$， 有$(q_i = p_{i+1})$。 

重建小组打算修改他们的原有方案以满足要求，即在原有的 $N-1$ 条道路中寻找一条路径 $S$ 作为新的方案，使得新方案中的道路平均价值

$$AvgValue = \frac{\sum _{e \in S} v(e)}{|S|}$$

最大。这里 $v(e)$ 表示道路 $e$ 的价值，$|S|$ 表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。  注: 在本题中 $L$ 和 $U$ 的设置将保证有解。


## 说明/提示

新方案中选择路径 $(3, 1), (1, 4)$ 可以得到的平均价值为 $2.5$，为最大平均价值。

对于20%的数据，$N \leq 5 000$;  

另有30%的数据，$N \leq 100 000$， 原有方案恰好为一条路径(链); 

对于100%的数据，$N \leq 100 000, 1 \leq L \leq U \leq N-1, v_i \leq 10^6$。

## 样例 #1

### 输入

```
4 
2 3 
1 2 1 
1 3 2 
1 4 3```

### 输出

```
2.500```

# 题解

## 作者：dspr (赞：37)

**update:突然发现里面有一个公式鬼畜了，修改一下**

没看到有人写长链剖分的题解，于是来发一波。

分数规划就不讲了，其他人讲的很清楚了

然后我们要做的就是在二分答案之后，通过求树上满足要求的最长链来检测答案

首先可以想到一个很暴力的$DP$

设$f_{i,j}$表示以$i$为根的子树，往下走$j$条边的最大权值和

对于一颗子树，可以一边更新数组，一边更新答案。

时间复杂度O($n^2$)

然而这是一个以深度为下标的$DP$

可以考虑用长链剖分优化，做到均摊O(1)的复杂度(后面会讲，有兴趣的可以看看)

然而因为统计答案时要把每个长度的答案都找一遍，如果这样的话时间复杂度还是O($n^2$)，并没有优化的效果，所以我们可以开一颗线段树，像线段树维护重链剖分一样维护长链剖分，这样我们就可以把时间复杂度做到O($n*log\ n$)，与点分治一致，但代码量要小很多，而且也不怕被扫把图卡掉(虽然点分治优化后也不会被卡，但要考虑的越多越易错)

算上二分答案，最终复杂度为O($n*log^2\ n$)

理论上线段树常数应该优于点分治，然而我的常数被点分治吊打了(~~我是真的弱~~)。

至于长链剖分

处理一颗树的链上操作时，我们常常我们常常按照子树大小划分重链(也就是重链剖分)，这样每跳一次重链，树的$size$至少乘2，于是可以在$log\ n$的时间内完成一些链上操作，然而有一种划分就是按照最深的子树划分重链，这样虽然不能像重链剖分一样在短时间内完成许多操作(长链剖分的复杂度为O($\sqrt{n}$))，但是这种按深度划分能给我们带来许多优秀的性质。

性质1：所有长链的长度和为$n$，因为长链与重链一样也是互不相交的。

性质2：任意一个节点$x$的$k$级祖先所在长链的长度一定大于或等于$k$(自己想想为什么)

长链剖分有两个经典应用

应用1：在$O(n*log\ n)$的预处理后，$O(1)$求任意一点的$k$级祖先

应用2：优化以深度为下标的树形$DP$

这题就是应用2对吧。那么我就不讲应用1了。

这类以深度为下标的$DP$,我们往往只能暴力for链长更新，然而，对于第一颗子树的信息，我们可以直接继承，为什么，假设对于以$i$为根的子树，要合并第一颗子树$j$时我们要做的仅仅只是将$j$子树的每一个信息复制一遍往后移一位再加上某个权值然后赋给子树$i$,暴力做的话就非常的浪费，会将我们已经得到的信息全部舍弃，那么怎样把这些已经得到的信息利用起来呢。

首先先按深度划分重儿子(至于为什么后面会讲到)，然后对树进行$dfs$，优先遍历重儿子(就跟重链剖分一样，只是划分方式不同),将$dfs$序记录下来，这样我们得到的每一条长链的$dfs$都是连续一段的，然后我们将状态以dfs序记录在数组$f$中，这样我们就会发现，后移一位的操作已经完成了，至于加上一个权值，我们只需要打上一个标记记在另一个数组$g$中，并将重儿子的标记继承，实际上的$f_i$就是$f_i+g_i$,这样同一条长链上的信息可以直接继承，而在轻儿子上的信息我们直接暴力修改，暴力统计答案即可，这样做因为轻儿子一定是某条长链的链头，重儿子的信息直接继承，所以我们只是在每条长链的链头将整条长链遍历一遍，而根据又由于长链互不相交，所以总复杂度为$O(n)$,均摊$O(1)$。

然后看上面加粗字，怎么做呢，以这个节点的$dfs$序为开头,将形如$f_{i,j}$的信息以$f_{dfn_i+j}$的形式保存，便于直接继承，由于继承之后重儿子信息就没用了，所以可以将轻儿子的信息合并。这个时候你应该就能明白为什么要按深度划分链了，因为这样可以使所有轻儿子的信息都能够直接合并上来。

下面是代码，真的比点分治好写。
```
#include<bits/stdc++.h>
#define lc no<<1
#define rc no<<1|1
#define ls lc,l,mid
#define rs rc,mid+1,r
#define mid ((l+r)>>1)
using namespace std;
const int _=1e6+20;
int a[_],to[_],nex[_],w[_],ww[_],dep[_],son[_],pos[_],n,LL,RR,cnt;
double p,f[_],t[_],ans,g[_];
void clear(int no,int l,int r){
    t[no]=-1e18;
    if(l==r)return;
    clear(ls);clear(rs);
}
void update(int no,int l,int r,int k,double x){
    t[no]=max(t[no],x);
    if(l==r){return;}
    if(k<=mid)update(ls,k,x);
    else update(rs,k,x);
}
double query(int no,int l,int r,int L,int R){
    if(l>R||r<L)return -1e18;
    if(l>=L&&r<=R)return t[no];
    return max(query(ls,L,R),query(rs,L,R));
}
void Dfs(int fa,int u,int W){
    dep[u]=-1;
    for(int i=a[u];i;i=nex[i]){
        int v=to[i];
        if(v==fa)continue;
        Dfs(u,v,w[i]);
        if(dep[u]<dep[v])dep[u]=dep[v],son[u]=v,ww[u]=w[i];
    }
    dep[u]++;
}
void dfs(int fa,int u){
    if(!pos[u])pos[u]=++cnt;
    int pu=pos[u];
    g[pu]=f[pu]=0;
    if(son[u]){
        dfs(u,son[u]);
        g[pu]+=g[pu+1]+ww[u]-p;
        f[pu]=-g[pu];
    }
    update(1,1,n,pu,f[pu]);
    for(int i=a[u];i;i=nex[i]){
        int v=to[i];
        if(v==fa||v==son[u])continue;
        dfs(u,v);int pv=pos[v];
        for(int j=1;j<=dep[v]+1;++j)
            if(LL-j<=dep[u]){
                double xx=query(1,1,n,pu+max(1,LL-j),pu+min(RR-j,dep[u]));
                ans=max(ans,w[i]-p+f[pv+j-1]+g[pv]+g[pu]+xx);
            }
        for(int j=1;j<=dep[v]+1;++j){
            if(w[i]-p+f[pv+j-1]+g[pv]>g[pu]+f[pu+j]){
                f[pu+j]=w[i]-p+f[pv+j-1]+g[pv]-g[pu];
                update(1,1,n,pu+j,f[pu+j]);
            }
        }
    }
    if(dep[u]>=LL)ans=max(ans,g[pu]+query(1,1,n,pu+LL,pu+min(RR,dep[u])));
}
int check(double x){
    clear(1,1,n);p=x;
    ans=-1e18;dfs(0,1);
    return ans>=0;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>LL>>RR;
    for(int i=1,t=0;i<n;++i){
        int u,v,W;cin>>u>>v>>W;
        nex[++t]=a[u];to[t]=v;w[t]=W;a[u]=t;
        nex[++t]=a[v];to[t]=u;w[t]=W;a[v]=t;
    }
    Dfs(0,1,0);
    double l=0,r=1e6;
    while(r-l>1e-5){
        double Mid=(l+r)/2;
        if(check(Mid))l=Mid;
        else r=Mid;
    }
    printf("%.3lf\n",l);
    return 0;
}

```


---

## 作者：shadowice1984 (赞：27)

这题其实有坑……

有一个做法可以hack掉网上大部分的题解

并且luogu上有这样的数据，所以不要认为你T了是常数大

______________________

题意简单明了，求树上长度在L到R内的路径，使得路径的平均值最大

那么也就是最大化这个式子

## $\frac{\sum_{}val_{u,v}}{\sum len_{u,v}}$

然后这里是01分数规划问题，有一个非常经典的套路叫二分答案

我们假设答案是mid，然后判断最优解比mid大还是比mid小

换言之我们要验证不等式

## $\frac{\sum val_{u,v}}{\sum len_{u,v}}\leq mid$

是否成立

所以说我们可以将这个不等式变一下形……

## $\sum val_{u,v}-len_{u,v}mid \leq 0$

所以说这就非常方便我们验证了，我们只需要将每一个边都减去mid然后判定一下有没有负的路径即可

找负路径的话我们可以将这个问题转化为长度在[L,R]中寻找最小的路径

一看有长度限制……当然是点分治啦……

所以我们还是老套路，对这颗树进行点分治，此时我们考虑过分治重心g的所有路径

暴力的从分治重心dfs一遍然后求出每一个路径的距离和深度

现在我们要做的是“拼合”两条路径

那么，怎么拼合呢？

当然是对于每一个路径求出和它匹配的最优的一个路径了……

但是我们还有深度的限制，换句话说我们能和这个路径匹配的路径的深度必须在一个区间里

如果对深度建权值线段树的话我们会发现情况十分辣手，因为复杂度此时猛增至
$O(nlog^3n)$根本过不去

此时你可能会说，如果把割掉g之后每一个子联通块中的路径按照深度排序，那么随着深度的递增，可以和当前路径匹配的路径的深度区间左右端点是单调递增的

此时我们就可以愉快的使用单调队列，复杂度成功优化至$O(nlog^2n)$皆大欢喜？

此时你会发现你复杂度分析存在一个漏洞，每次初始化的复杂度是$min(R-L,max(dep))$的其中$max(dep)$为这个联通块之前的联通块的最深深度

所以我们可以构造一个长度为2/3n的长链，在中点处构造一个3/n的菊花，此时我们就可以愉快的把你卡成$O(n^2logn)$

为了避免这个情况需要把联通块们按照最大深度进行排序，然后按照这个顺序插入路径，关于同一个深度的路径，我们使用以深度为下标的数组存储路径的带权长度

此时我们就可以愉快的使用单调队列进行求解最小值的操作了

然后就是大力二分套在外面啦~

对了，为了优化常数，请将点分树提前建好，不然可能因为常数巨大而T飞

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;const int N=1e5+10;typedef double db;const db eps=1e-9;
int v[2*N];int x[2*N];int al[N];int ct;db val[2*N];int siz[N];bool book[N];
bool cut[N];db mxv[N];int q[N];int hd;int tl;int L;int R;int n;
struct data{int dep;db v;friend bool operator <(data a,data b){return a.dep>b.dep;}};
struct chi//对每个联通块排序
{
    int mxdep;vector <data> ve;
    inline void push(const data& da){mxdep=max(mxdep,da.dep);ve.push_back(da);}
    inline void srt(){sort(ve.begin(),ve.end());}
};vector <chi> s[N];
inline bool cmp(const chi& a,const chi& b){return a.mxdep<b.mxdep;}
inline void add(int u,int V,db va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
inline int dfs1(int u)//siz
{
    book[u]=true;siz[u]=1;
    for(int i=al[u];i;i=x[i])if(!book[v[i]]&&!cut[v[i]])siz[u]+=dfs1(v[i]);
    book[u]=false;return siz[u];
}
inline int find(int u,const int& tot)//重心
{
    book[u]=true;int ret=u;
    for(int i=al[u];i;i=x[i])
    if(!book[v[i]]&&!cut[v[i]]&&2*siz[v[i]]>=tot){ret=find(v[i],tot);break;}
    book[u]=false;return ret;
}
inline void dfs2(int u,vector <chi>::iterator ve,int dep,db dis)
{
    book[u]=true;ve->push((data){dep,dis});
    for(int i=al[u];i;i=x[i])if(!book[v[i]]&&!cut[v[i]])dfs2(v[i],ve,dep+1,dis+val[i]);
    book[u]=false;
}
inline void solve(int u)//构建点分树
{
    dfs1(u);int g=find(u,siz[u]);cut[g]=true;
    for(int i=al[g];i;i=x[i])
    {
        if(cut[v[i]])continue;s[g].push_back(chi());
        dfs2(v[i],--s[g].end(),1,val[i]);(--s[g].end())->srt();
    }sort(s[g].begin(),s[g].end(),cmp);
    for(int i=al[g];i;i=x[i]){if(!cut[v[i]])solve(v[i]);}
}
inline bool jud(db ans)//每次在点分树上拼合路径
{
    vector <chi>::iterator it1;vector <data>::iterator it2;
    for(int i=1;i<=n;i++)mxv[i]=-0x7f7f7f7f;bool ret=false;
    for(int i=1,nwdep;i<=n;i++)
    {
        for(it1=s[i].begin(),nwdep=0;it1!=s[i].end();nwdep=it1->mxdep,++it1)
        {
            int dr=0;
            for(it2=it1->ve.begin(),hd=1,tl=0;it2!=it1->ve.end();++it2)//单调队列
            {
                int nl=max(0,(int)(L-it2->dep));int nr=min(nwdep,(int)(R-it2->dep));if(nl>nr){continue;}
                for(int np=dr+1;np<=nr;np++){while(hd<=tl&&mxv[q[tl]]<mxv[np])--tl;q[++tl]=np;}
                while(hd<=tl&&q[hd]<nl){++hd;}dr=nr;
                if(mxv[q[hd]]+it2->v-ans*it2->dep>eps){ret=true;goto skip;}				
            }
            for(it2=it1->ve.begin();it2!=it1->ve.end();++it2)//特判到根的路径同时将路径插入到权值数组中
            {
                mxv[it2->dep]=max(mxv[it2->dep],it2->v-ans*it2->dep);
                if(L<=it2->dep&&it2->dep<=R&&mxv[it2->dep]>eps){ret=true;goto skip;}
            }
        }skip:;
        for(it1=s[i].begin();it1!=s[i].end();++it1)
            for(it2=it1->ve.begin();it2!=it1->ve.end();++it2)
            {mxv[it2->dep]=-0x7f7f7f7f;}
        if(ret)return true;
    }return false;
}
int main()
{
    scanf("%d%d%d",&n,&L,&R);
    for(int i=1,u,v,va;i<n;i++)
    {scanf("%d%d%d",&u,&v,&va);add(u,v,va);add(v,u,va);}
    solve(1);db l=0;db r=1e6;//无脑二分
    while(r-l>1e-4){db mid=(l+r)/2;(jud(mid)?l:r)=mid;}
    printf("%.3lf",l);return 0;
}

```






---

## 作者：ez_lcw (赞：16)

# 长链剖分

因为有很多巨佬只是讲了一下大致的做法，并没有详细地解释如何维护，所以就有了这篇题解。~~巨佬们都不屑于详细写，我太弱了/kk~~

首先先对原树进行长链剖分。

先讲一些定义：

- 一条路径的权值和指的是这条路径上的所有边权之和

- 一条路径的长度指的是这条路径包含多少条边

- $dep_i$ 表示 $i$ 的深度。

- $maxdep_i$ 表示在 $i$ 子树内的最深的节点的深度。

- $dis_i$ 表示从根节点到节点 $i$ 的路径权值和是什么。

- $id_i$ 表示点 $i$ 在线段树中所代表的位置

- $val_i$ 表示的是线段树的点的权值

然后容易想到先套一个二分套在最外层来二分 $AugValue$ ~~（AV）~~。

不放假设现在的二分值为 $mid$，然后根据分数规划，我们可以把所有边的边权减去 $mid$，那么只要找到一条长度符合要求的路径，并且它的边权和大于 $0$ 即可，同时也更新一下 $dis_i$。

那我们就不妨找到树中长度符合要求的最大路径，然后再判断是否大于 $0$。

让我们先用朴素的树形 dp 的做法想一下，设 $dp_{i,j}$ 为以 $i$ 为根的子树，往下走 $j$ 步的最大权值和。

那么我们每次枚举一个 $u$ 的儿子 $a$、$b$，有：

$$dp_{i,j}=\max_{k=0}^{j}(dp_{a,k}+dp_{b,j-k})$$

然而这个时间复杂度我们是承受不起的。

所以考虑用长链剖分进行优化。

每一次 $\operatorname{check}$，我们都先按着重儿子的方向进行递归，然后再递归其他的儿子。

先说一下每一次递归到 $u$，并递归完其重儿子后，我们先循环枚举 $u$ 的每一个非重儿子 $son$，每一次循环中，我们先递归这个非重儿子 $son$。

~~可能看代码好解释：~~（伪代码）

```cpp
void solve(int u)
{
   solve(重儿子);
   for(son=非重儿子)
   {
   	solve(son);
    	......
   }
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/x92ut7kl.png)

如图，我们现在已经遍历完了重儿子（红色节点）、$son$ 以及 $son$ 左边的儿子，现在要更新经过 $u$ 和 $son$ 的且在 $u$ 的子树内的路径的最大权值和，就好像这样的路径：（蓝色路径）

![](https://cdn.luogu.com.cn/upload/image_hosting/u1kaiblx.png)

这时，我们循环枚举这条路径中 $u\rightarrow b$ 的**长度**（不是权值和） $j$。那么 $a\rightarrow u$ （不含 $u$）长度的取值范围是 $A=[\max(1,L-j),\min(R-j,maxdep_u-dep_u)]$，那么 $dep_a$ 的取值范围是 $B=dep_u+A$。

那么我们就要求出 $u$ 的子树中，所有深度在 $B$ 的点中，$dis_i$ 最大的那个点 $i$ 当做 $a$，那么这条路径就是 $u\rightarrow b$ 的长度为 $j$ 的路径中权值和最大的那一条。

考虑如何维护这些点中 $dis$ 最大的那一个。

由于他们需要满足的条件只是在一个深度范围内，所以想到了线段树。

关键是如何用较低的时间复杂度查询这么多子树中所有符合条件的点的 $dis$ 的最大值。

所以在递归 $son$ 左边的儿子以及 $u$ 的重儿子时，要预先维护好这个东西。

那么我们现在进入到递归到 $u$ 的重儿子或 $son$ 左边的某个儿子 $a$ 的情景：

![](https://cdn.luogu.com.cn/upload/image_hosting/lpch244m.png)

如图，蓝色为长链，当我们递归完 $a$ 准备回溯的时候，我们需要维护好这棵树内每一层的节点的 $dis$ 的最大值。

对于某一层（比如 $dep=k$ 这一层）的所有节点的 $dis$，我们可以把它们全部合并入 $a$ 所在的重链的满足 $dep=k$ 的这个点 $v$ 里面。

也就是说，不妨设在 $a$ 子树内的 $dep=k$ 的这一层的所有节点的集合为 $\{a_1,a_2,\dots,a_m\}$，那么我们只用把点 $v$ 在线段树中所代表的位置 $id_v$ 的权值 $val_{id_v}$ 设为 $\max_{i=1}^m a_i$。所以我们要查询这一层只用查询这一个点的权值就好了。

至于如何合并，我们只需在遍历 $a$ 的儿子的时候更新就好了。

回到一开始的问题，我们现在就可以维护一个深度区间内最大的 $dis_i$ 了。

同样，对于 $u$ 来说，也要做上述的处理。

事到如此，整道题就已经做完了。

接下来有一些需要注意的事情：

- INF 要开够，至少 $N\times \dfrac{\max v_i}{2}=50000000000$。

- 有很多东西需要开 double。

代码：

```cpp
#include<bits/stdc++.h>
 
#define N 100010
#define INF 50000000010
 
using namespace std;
 
int n,L,R;
int cnt,head[N],nxt[N<<1],to[N<<1],w[N<<1];
int tot,fa[N],num[N],dep[N],maxd[N],son[N],sonw[N],id[N];
double ans,last[N],dis[N],ww[N<<1],sonww[N],maxn[N<<2];
 
void dfs1(int u)
{
    for(int i=head[u];i;i=nxt[i])
    {
        int v=to[i];
        if(to[i]==fa[u]) continue;
        maxd[v]=dep[v]=dep[u]+1;
        fa[v]=u;
        dfs1(v);
        if(maxd[v]>maxd[son[u]])
        {
            maxd[u]=maxd[v];
            son[u]=v;
            sonw[u]=w[i];
        }
    }
}
 
void dfs2(int u)
{
    id[u]=++tot;
    if(son[u])
        dfs2(son[u]);
    for(int i=head[u];i;i=nxt[i])
        if(to[i]!=fa[u]&&to[i]!=son[u])
            dfs2(to[i]);
}
 
void adde(int u,int v,int wi)
{
    to[++cnt]=v;
    w[cnt]=wi;
    nxt[cnt]=head[u];
    head[u]=cnt;
}
 
void getnum(int k,int l,int r)
{
    if(l==r)
    {
        num[l]=k;
        return;
    }
    int mid=(l+r)>>1;
    getnum(k<<1,l,mid);
    getnum(k<<1|1,mid+1,r);
}
 
void clear(int k,int l,int r)
{
    maxn[k]=-INF;
    if(l==r) return;
    int mid=(l+r)>>1;
    clear(k<<1,l,mid);
    clear(k<<1|1,mid+1,r);
}
 
void update(int k,int l,int r,int x,double y)
{
    maxn[k]=max(maxn[k],y);
    if(l==r) return;
    int mid=(l+r)>>1;
    if(x<=mid) update(k<<1,l,mid,x,y);
    else update(k<<1|1,mid+1,r,x,y);
}
 
double query(int k,int l,int r,int ql,int qr)
{
    if(ql<=l&&r<=qr) return maxn[k];
    int mid=(l+r)>>1;
    double ans=-INF;
    if(ql<=mid) ans=max(ans,query(k<<1,l,mid,ql,qr));
    if(qr>mid) ans=max(ans,query(k<<1|1,mid+1,r,ql,qr));
    return ans;
}
 
void solve(int u)
{
    update(1,1,n,id[u],dis[u]);
    if(son[u])
    {
        int v=son[u];
        dis[v]=dis[u]+sonww[u];
        solve(v);
    }
    for(int i=head[u];i;i=nxt[i])
    {
        int v=to[i];
        if(v==fa[u]||v==son[u]) continue;
        dis[v]=dis[u]+ww[i];
        solve(v);
        for(int j=1;j<=maxd[v]-dep[u];j++)
        {
            last[j]=maxn[num[id[v]+j-1]];
            if(j<=R)
            {
            	int ql=max(1,id[u]+L-j),qr=min(id[u]+R-j,id[u]+maxd[u]-dep[u]);
                double tmp=query(1,1,n,ql,qr);
                ans=max(ans,tmp+last[j]-dis[u]*2);
            }
        }
        for(int j=1;j<=maxd[v]-dep[u];j++)
            update(1,1,n,id[u]+j,last[j]);
    }
    ans=max(ans,query(1,1,n,id[u]+L,min(id[u]+R,id[u]+maxd[u]-dep[u]))-dis[u]);
}
 
bool check(double mid)
{
    for(int i=1;i<=cnt;i++) 
        ww[i]=1.0*w[i]-mid;
    for(int i=1;i<=n;i++)
        sonww[i]=1.0*sonw[i]-mid;
    ans=-INF;
    clear(1,1,n);
    solve(1);
    return ans>0;
}
 
int main()
{
    scanf("%d%d%d",&n,&L,&R);
    for(int i=1;i<n;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        adde(u,v,w),adde(v,u,w);
    }
    dfs1(1);
    dfs2(1);
    getnum(1,1,n);
    double l=0,r=1000000;
    while(r-l>1e-5)
    {
        double mid=0.5*(l+r);
        if(check(mid)) l=mid;
        else r=mid;
    }
    printf("%.3lf\n",l);
    return 0;
}
```

---

## 作者：Log_x (赞：16)

## Solution 二分答案 + 点分治 + BFS + 单调队列
- 容易想到二分答案 $mid$，将树上每条边减去 $mid$，原问题被转化为求树上是否存在一条价值和大于等于 $0$ 的路径，可以用点分治来做。 
- 因为题目对路径长度有限制，记录之前处理的子树中某一长度的路径价值和的最大值。
- 对重心的每一棵子树 $BFS$，则按照 $BFS$ 序枚举点，路径的长度递增。 
- 枚举之前处理的子树中的路径长度，则对于当前子树可以用单调队列（滑动窗口）来维护对应的最大值，每次判断路径总价值和是否大于等于 $0$ 即可。
- 时间复杂度 $O(n \log n \times$二分次数$)$。
- ~~尽管洛谷跑得很慢，BZOJ那么卡常竟然过了……~~
- 如果有什么好的提高运行速度的方法欢迎指出。

## Code

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;

const double eps = 1e-6;
const int Maxn = 0x3f3f3f3f;
const int N = 1e5 + 5, M = N << 1;
int n, L, U, Gs, Gt, tis, last, top, num;
int sze[N], len[N], G[N], h[N], ph[N]; 
bool flag, vis[N], stp[N];
double l = 1e9, r = -1e9, Ans, dis[N], f[N];

struct Edge
{
	int to; double cst; Edge *nxt;
}p[M], *lst[N], *P = p;

inline void Link(int x, int y, int z)
{
	(++P)->nxt = lst[x]; lst[x] = P; P->to = y; P->cst = z;
	(++P)->nxt = lst[y]; lst[y] = P; P->to = x; P->cst = z; 
	if (z < l) l = z; if (z > r) r = z; 
}

inline int get()
{
	char ch; int res = 0; bool flag = false;
	while (ch = getchar(), !isdigit(ch) && ch != '-');
	(ch == '-' ? flag = true : res = ch ^ 48);
	while (ch = getchar(), isdigit(ch))
		res = res * 10 + ch - 48;
	return flag ? -res : res;
}

template <class T> inline void CkMax(T &x, T y) {if (x < y) x = y;}
inline int Min(int x, int y) {return x < y ? x : y;}

inline void Dfs1(int x, int fa)
{
	int cnt = 0; sze[x] = 1; 
	for (Edge *e = lst[x]; e; e = e->nxt)
	{
		int y = e->to;
		if (y == fa || vis[y]) continue;
		Dfs1(y, x);
		sze[x] += sze[y];
		CkMax(cnt, sze[y]); 
	}
	CkMax(cnt, tis - sze[x]);
	if (cnt < Gs)
		Gs = cnt, Gt = x;
}

inline int findG(int x)
{
	Gs = Maxn;
	Dfs1(x, 0);
	return Gt;
}

inline void Init(int x)
{
	int y; G[++num] = findG(x); vis[G[num]] = true;
	for (Edge *e = lst[G[num]]; e; e = e->nxt)
		if (!vis[y = e->to]) tis = sze[y], Init(y);
}

inline void Bfs(int src)
{
	stp[h[++top] = src] = true; int x, y;
	for (int i = last + 1; i <= top; ++i)
	{
		x = h[i];
		for (Edge *e = lst[x]; e; e = e->nxt)
			if (!vis[y = e->to] && !stp[y]) 
			{
				dis[y] = dis[x] + e->cst;
				len[y] = len[x] + 1;
				stp[h[++top] = y] = true;
			}
	}
	for (int i = last + 1; i <= top; ++i) 
		stp[h[i]] = false;
}

inline void Check()
{
	int t = 1, w = 0, tip = last + 1;
	for (int i = Min(U, len[h[top]]); i >= 0; --i)
	{
		int tl = i >= L ? 0 : L - i, tr = U - i;
		while (t <= w && len[ph[t]] < tl) ++t;
		while (tip <= top && len[h[tip]] < tl) ++tip;
		while (tip <= top && len[h[tip]] <= tr)
		{
			while (t <= w && dis[ph[w]] + eps <= dis[h[tip]]) --w;
			ph[++w] = h[tip++];
		}
		if (t <= w && f[i] + dis[ph[t]] >= -eps) 
			return (void)(flag = true);
	}
}

inline void solve(int x)
{
	int Gz = G[++num], y;
	vis[Gz] = true; h[0] = Gz; 
	f[0] = dis[Gz] = len[Gz] = 0; top = 0;
	for (Edge *e = lst[Gz]; e; e = e->nxt)
		if (!vis[y = e->to])
		{
			dis[y] = e->cst; len[y] = 1; 
			last = top; Bfs(y); Check();
			for (int i = last + 1; i <= top; ++i)	
				CkMax(f[len[h[i]]], dis[h[i]]);
		}
	for (int i = 0; i <= top; ++i) 
		f[len[h[i]]] = -1e9; 
	for (Edge *e = lst[Gz]; e; e = e->nxt)
		if (!vis[y = e->to]) solve(y); 
}

inline bool Judge(double mid)
{
	memset(vis, false, sizeof(vis));
	for (int i = 1; i <= n; ++i)
		for (Edge *e = lst[i]; e; e = e->nxt)
			e->cst -= mid;
	flag = false; num = 0; solve(1); 
	for (int i = 1; i <= n; ++i)
		for (Edge *e = lst[i]; e; e = e->nxt)
			e->cst += mid;
	return flag; 
}

int main()
{
	tis = n = get(); L = get(); U = get(); int x, y;
	for (int i = 1; i < n; ++i)
	{
		x = get(); y = get();
		Link(x, y, get()); f[i] = -1e9; 
	}
	Init(1);
	for (int i = 1; i <= 32; ++i)
	{
		double mid = (l + r) / 2.0;
		if (Judge(mid)) Ans = mid, l = mid;
			else r = mid;
	}
	printf("%.3lf", Ans);
} 
```

---

## 作者：javalyc (赞：12)

[博客传送门qwq](https://www.cnblogs.com/LLTYYC/p/11392247.html)

纪念第一个自己写出的黑题...

看一眼就是分数规划，二分答案先套上，二分一个 $mid$ ，把所有边权减 $mid$

然后就变成求树上边数在 $[L,R]$ 范围内的最长链

看到树，看到求链，再看看时间限制，点分治是没得跑了...

关键是考虑具体怎么点分治

每到一个分治节点 $x$ 就考虑所有以它为最浅点的所有链，发现对于两条以它为起点的深度相同的链，我们只要保留最长的长度

所以维护一个桶 $T[i]$ 表示当前深度为 $i$ 的所有以 $x$ 为起点的链的长度最大值，考虑新加入的一个儿子子树 $v$ 如何合并

设 $tmp[i]$ 表示 $v$ 中深度为 $i$（起点是 $x$）的链的最长长度，考虑 $T$ 和 $tmp$ 的合并（luogu的图有点大...）：

![](https://cdn.luogu.com.cn/upload/pic/73902.png)

动态维护两个指针 $ld,rd$ ，分别表示之前的儿子贡献的边数和新加入的儿子贡献的边数

那么有 $ld+rd>=L$ 且 $ld+rd<=R$，考虑枚举 $rd$，使得 $ld$ 跟着变化，并统计合法 $ld$ 的区间内的贡献

通过上面两个式子得到 $ld>=L-rd,ld<=R-rd$ ，即 $ld \in [L-rd,R-rd]$

发现 $rd$ 增加 $1$ 那么整个合法区间就整体移一位，并且区间大小不变（不考虑边界），发现这就是个滑动窗口，直接单调队列就完事了

点分树先预处理会快很多

以上就是本题关键思路，具体实现请看代码（代码里有一些细节）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
typedef long long ll;
typedef double db;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
	return x*f;
}
const int N=2e5+7,inf=1e9+7;
const db INF=1e18+7;
const double eps=1e-5;
int fir[N],from[N<<1],to[N<<1],val[N<<1],cntt;
inline void add(int a,int b,int c) { from[++cntt]=fir[a]; fir[a]=cntt; to[cntt]=b; val[cntt]=c; }
int n,L,R;
int RT,rt,sz[N],mx[N],tot;
bool vis[N];
void find_rt(int x,int fa)//找重心
{
	sz[x]=mx[x]=1;
	for(int i=fir[x];i;i=from[i])
	{
		int &v=to[i]; if(v==fa||vis[v]) continue;
		find_rt(v,x); sz[x]+=sz[v]; mx[x]=max(mx[x],sz[v]);
	}
	mx[x]=max(mx[x],tot-sz[x]);
	if(mx[x]<mx[rt]) rt=x;
}
vector <int> V[N];//存点分树
void build(int x)//预处理点分树
{
	vis[x]=1;
	for(int i=fir[x];i;i=from[i])
	{
		int &v=to[i]; if(vis[v]) continue;
		rt=0; tot=sz[v]; find_rt(v,x);
		V[x].push_back(rt); build(rt);
	}
	vis[x]=0;
}
db tmp[N],mid,T[N];
int tp,Tp,Q[N];
bool flag;
void dfs(int x,int fa,int dep,db dis)//枚举子树路径
{
	tp=max(tp,dep); tmp[dep]=max(tmp[dep],dis);//取max
	for(int i=fir[x];i;i=from[i])
	{
		int &v=to[i]; if(v==fa||vis[v]) continue;
		dfs(v,x,dep+1,dis+val[i]-mid);//边权减mid
	}
}
void work(int x)//求以x为最浅点的最长链
{
	for(int i=fir[x];i;i=from[i])
	{
		int &v=to[i]; if(vis[v]) continue;//枚举儿子
		dfs(v,x,1,val[i]-mid); int l=1,r=0;
		for(int ld=Tp,rd=1;rd<=tp;rd++)//滑动窗口
		{
			while(l<=r && Q[l]>R-rd ) l++;
			while(ld>=L-rd&&ld>=0)
			{
				while(l<=r && T[Q[r]]<=T[ld]) r--;
				Q[++r]=ld; ld--;
			}
			if(l<=r && T[Q[l]]+tmp[rd]>0) { flag=1; break; }//不要直接返回，先把数组清空
		}
		for(int j=1;j<=tp;j++) T[j]=max(T[j],tmp[j]); Tp=max(Tp,tp);
		for(int j=1;j<=tp;j++) tmp[j]=-INF; tp=0;//注意初始为-INF
		if(flag) break;//记得先清空再break
	}
	for(int i=1;i<=Tp;i++) T[i]=-INF; Tp=0;
}
void solve(int x)//遍历点分树求最长链
{
	vis[x]=1; work(x); if(flag) { vis[x]=0; return; } int len=V[x].size();
	for(int i=0;i<len;i++) { solve(V[x][i]); if(flag) break; }
	vis[x]=0;
}
bool check()
{
	flag=0; solve(RT);
	return flag;
}
int main()
{
	mx[0]=inf; n=read(),L=read(),R=read();
	for(int i=1;i<=n;i++) T[i]=tmp[i]=-INF;//记得初始化
	int a,b,c; db l=INF,r=0,ans=2333;
	for(int i=1;i<n;i++)
	{
		a=read(),b=read(),c=read();
		l=min(l,1.0*c),r=max(r,1.0*c);
		add(a,b,c); add(b,a,c);
	}
	tot=n; find_rt(1,0); RT=rt; build(rt);
	while(l<=r-eps)
	{
		mid=(l+r)/2;
		if(check()) l=mid,ans=mid;
		else r=mid;
	}
	printf("%.3lf\n",ans);
	return 0;
}

```


---

## 作者：xtx1092515503 (赞：10)

这里是某可能假掉的$n\log n$算法。**证明不太严谨，如果你把它叉掉了或者可以提供更美妙的证明欢迎私信或者发帖联系**。

照着[[BJOI2017]树的难题](https://www.luogu.com.cn/problem/P3714)的思路，我们可以很自然地想到这题仍然可以使用**单调队列按秩合并**，即将分治树中所有点按照**深度递增**排序，则可选深度区间一定是**递减**的。因为这一区间是递减的，所以就可以使用**单调队列**维护。更详细的解释可以在本人的[点分治学习笔记](https://www.luogu.com.cn/blog/Troverld/dian-fen-zhi-xue-xi-bi-ji)找到或者参阅其它神仙的题解。

这里主要是探讨$n\log n$的做法，即不在外面套上$\log n$的二分的算法。

我们设当前探讨的点是$x$，它的深度是$dep_x$，到根的路径权值为$sum_x$。再设所有其它路径中，深度为$k$的路径最大的权值为$buc_k$。单调队列中存储的是**深度**，按照从队首到队尾递减。

因为$x$已经按照深度排序了，所以必有$dep_x\nearrow$。其它值都没有任何性质。

------------


我们考虑这样一种贪心策略：

当从队尾加入新元素时，只要当前队尾的那条路径与$x$拼合起来的结果小于新元素与$x$拼合的结果，就弹出队尾。

------------

设队尾元素为$a$，新元素为$b$，必有$a>b$。则只要$\dfrac{buc_a+sum_x}{a+dep_x}\leq\dfrac{buc_b+sum_x}{b+dep_x}$成立，$a$就应该被弹出。

现在我们要来证明，被弹出的$a$再往后都不会成为解。

显然，当$dep_x\nearrow$时，两边的值都是**下降**的。故因为此时有$\dfrac{buc_a+sum_x}{a+dep_x}\leq\dfrac{buc_b+sum_x}{b+dep_x}$，再往后的值一定更劣，故不如此时就选择$b$。

但是我们没有考虑到，万一$sum_x$也跟着$\nearrow$怎么办？

则显然，此时$a$增加的更少。

如果$sum_x$增加的速度小于对应的$dep_x$增加的速度，则答案肯定会变得更劣，故就算$a$可能到那时会更优，那更优的答案也会小于此时$b$的答案；如果$sum_x$增加速度大于$dep_x$增加的速度，则就是$b$更优了。故$a$无论如何都可以弹出。

------------

那么队首呢？设其为$c$。

首先，只要队首已经不合法了（即$c+dep_x>R$），就必须被弹掉，这点毫无疑问。

然后，我们考虑队首的下一位为$d$。则只要$\dfrac{buc_c+sum_x}{c+dep_x}\leq\dfrac{buc_d+sum_x}{d+dep_x}$，$c$就应该被弹掉。

这个格式同队尾的基本一致，故也可以类似地证明。

则我们只要采取bfs解法，就可以在$O(n\log n)$时间内解出本题。

**当然这个证明不很严谨，欢迎来叉**。

代码：

```cpp
#pragma GCC optimize(3)
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
typedef long long ll;
const ll fni=-1e11;
int n,L,R;
double mx;
int ROOT,SZ,sz[200100],msz[200100];
int dep[200100],mdp[200100],lim;
ll sum[200100],buc[200100];
vector<pair<int,int> >v[200100];
bool vis[200100];
void getsz(int x,int fa){
	sz[x]=1;
	for(auto i:v[x])if(!vis[i.first]&&i.first!=fa)getsz(i.first,x),sz[x]+=sz[i.first];
}
void getroot(int x,int fa){
	sz[x]=1,msz[x]=0;
	for(auto i:v[x])if(!vis[i.first]&&i.first!=fa)getroot(i.first,x),sz[x]+=sz[i.first],msz[x]=max(msz[x],sz[i.first]);
	msz[x]=max(msz[x],SZ-sz[x]);
	if(msz[x]<msz[ROOT])ROOT=x;
}
void getdep(int x,int fa,int fr){
	mdp[fr]=max(mdp[fr],dep[x]);
	for(auto i:v[x])if(!vis[i.first]&&i.first!=fa)dep[i.first]=dep[x]+1,sum[i.first]=sum[x]+i.second,getdep(i.first,x,fr);
}
bool cmp(pair<int,int>x,pair<int,int>y){
	return mdp[x.first]<mdp[y.first];
}
queue<int>q;
deque<int>dq;
void bfsread(int x){
	dq.clear();
	q.push(x);
	int tmp=lim;
	while(!q.empty()){
		x=q.front(),q.pop();
		while(tmp>=0&&tmp+dep[x]>=L){
			while(!dq.empty()&&(buc[tmp]+sum[x])*(dq.back()+dep[x])>=(buc[dq.back()]+sum[x])*(tmp+dep[x]))dq.pop_back();
			dq.push_back(tmp--);
		}
		while(!dq.empty()&&dq.front()+dep[x]>R)dq.pop_front();
		while(dq.size()>=2&&(buc[dq[0]]+sum[x])*(dq[1]+dep[x])<=(buc[dq[1]]+sum[x])*(dq[0]+dep[x]))dq.pop_front();
		if(!dq.empty())mx=max(mx,1.0*(buc[dq.front()]+sum[x])/(dq.front()+dep[x]));
		for(auto i:v[x])if(!vis[i.first]&&dep[i.first]>dep[x])q.push(i.first);
	}
}
void bfswrite(int x){
	q.push(x);
	while(!q.empty()){
		x=q.front(),q.pop();
		buc[dep[x]]=max(buc[dep[x]],sum[x]),lim=max(lim,dep[x]);
		for(auto i:v[x])if(!vis[i.first]&&dep[i.first]>dep[x])q.push(i.first);
	}
}
void calc(int x){
	sum[x]=dep[x]=0;
	for(auto i:v[x])if(!vis[i.first])sum[i.first]=i.second,dep[i.first]=1,getdep(i.first,x,i.first);
	sort(v[x].begin(),v[x].end(),cmp);
	for(auto i:v[x])if(!vis[i.first])mdp[i.first]=0,bfsread(i.first),bfswrite(i.first);
	for(int i=1;i<=lim;i++)buc[i]=fni;lim=0;
}
void solve(int x){
	calc(x);
	getsz(x,0); 
	vis[x]=true;
	for(auto i:v[x])if(!vis[i.first])ROOT=0,SZ=sz[i.first],getroot(i.first,0),solve(ROOT);
}
void read(int &x){
	x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
int main(){
	read(n),read(L),read(R);
	for(int i=1;i<=n;i++)buc[i]=fni;
	for(int i=1,x,y,z;i<n;i++)read(x),read(y),read(z),v[x].push_back(make_pair(y,z)),v[y].push_back(make_pair(x,z));
	msz[0]=n+1,SZ=n,getroot(1,0),solve(ROOT);
	printf("%.3lf\n",mx);
	return 0;
}
```


---

## 作者：lhm_ (赞：7)

先二分答案 $mid$，使得 $\frac{val}{tot} \geqslant mid $，移项得:
$$
\large val - tot \times mid \geqslant 0
$$
判定对每条边的边权都减去 $mid$ 后，是否存在一条边权和大于零的路径即可。

考虑树形 $DP$，设 $f_{x,i}$ 为以 $x$ 为根的子树内，从 $x$ 向下延伸 $i$ 条边所形成的路径边权和的最大值，直接 $DP$ 复杂度是 $O(n^2)$ 的，无法接受。

发现状态是和深度有关，所以考虑用长链剖分来优化，每次转移时，先从重儿子继承过来，然后再将轻儿子合并，合并轻儿子时扫一遍轻儿子所在的链即可。因为每个轻儿子都是其所在链的顶端，所以每个点都只会被扫一次，复杂度就有保证了。

因为有边数的限制，所以合并时用线段树来维护。长链剖分后进行 $dfs$，优先遍历重儿子，求出 $dfs$ 序。对于 $DP$ 状态 $f_{x,i}$，将其用 $dfn_x + i$ 在线段树上表示，这样每个状态都有一个对应的表示，转移时也便于合并，链上的信息为一个连续的区间，重儿子能直接转移到当前节点。

```cpp
#include<bits/stdc++.h>
#define maxn 200010
#define maxm 800010
#define inf 2000000000000000
#define ls (cur<<1)
#define rs (cur<<1|1)
#define mid ((l+r)>>1)
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,L,R,cnt,root=1;
double now,ans,l,r;
int d[maxn],dep[maxn],len[maxn],son[maxn],dfn[maxn];
double val[maxn],dis[maxn],t[maxn],mx[maxm];
struct edge
{
    int to,nxt;
    double v;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to,double val)
{
    e[++edge_cnt]=(edge){to,head[from],val};
    head[from]=edge_cnt,r=max(r,val);
}
void modify(int l,int r,int pos,double v,int cur)
{
    if(l==r)
    {
        mx[cur]=max(mx[cur],v);
        return;
    }
    if(pos<=mid) modify(l,mid,pos,v,ls);
    else modify(mid+1,r,pos,v,rs);
    mx[cur]=max(mx[ls],mx[rs]);
}
double query(int L,int R,int l,int r,int cur)
{
    if(L>R) return -inf;
    if(L<=l&&R>=r) return mx[cur];
    double v=-inf;
    if(L<=mid) v=max(v,query(L,R,l,mid,ls));
    if(R>mid) v=max(v,query(L,R,mid+1,r,rs));
    return v;
}
void clear(int l,int r,int cur)
{
    mx[cur]=-inf;
    if(l==r) return;
    clear(l,mid,ls),clear(mid+1,r,rs);
}
void dfs_son(int x,int fa)
{
    d[x]=dep[x]=d[fa]+1;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(y==fa) continue;
        dfs_son(y,x),dep[x]=max(dep[x],dep[y]);
        if(dep[y]>dep[son[x]]) son[x]=y,val[son[x]]=e[i].v;
    }
    len[x]=dep[x]-d[x];
}
void dfs_dfn(int x)
{
    dfn[x]=++cnt;
    if(son[x]) dfs_dfn(son[x]);
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(dfn[y]) continue;
        dfs_dfn(y);
    }
}
void dp(int x,int fa)
{
    modify(1,n,dfn[x],dis[x],root);
    if(son[x]) dis[son[x]]=dis[x]+val[son[x]]-now,dp(son[x],x);
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(y==fa||y==son[x]) continue;
        dis[y]=dis[x]+e[i].v-now,dp(y,x);
        for(int j=1;j<=len[y]+1;++j) t[j]=query(dfn[y]+j-1,dfn[y]+j-1,1,n,root);
        for(int j=1;j<=min(len[y]+1,R);++j)
            ans=max(ans,t[j]+query(dfn[x]+L-j,min(dfn[x]+R-j,dfn[x]+len[x]),1,n,root)-2*dis[x]);
        for(int j=1;j<=len[y]+1;++j) modify(1,n,dfn[x]+j,t[j],root);
    }
    ans=max(ans,query(dfn[x]+L,min(dfn[x]+R,dfn[x]+len[x]),1,n,root)-dis[x]);
}
bool check(double m)
{
    now=m,ans=-inf,clear(1,n,root),dp(1,0);
    return ans>=0;
}
int main()
{
    read(n),read(L),read(R);
    for(int i=1;i<n;++i)
    {
        int x,y,v;
        read(x),read(y),read(v);
        add(x,y,v),add(y,x,v);
    }
    dfs_son(1,0),dfs_dfn(1);
    for(int i=1;i<=35;++i)
    {
        double m=(l+r)/2;
        if(check(m)) l=m;
        else r=m;
    }
    printf("%.3lf",l);
    return 0;
}
```

---

## 作者：不存在之人 (赞：5)

### Solution

------------
敲个二分就变成了求一条长度在$[L,R]$内路径的权值和最大，然后我就不会做了

首先这是一棵树，显然点分治是可写的

然鹅我并不是很想写点分治因此这里有另一种方法

先对树长链剖分，我们像做$dsu$ $on$ $tree$一样先做长链，用线段树继承长链的全部信息，然后做其他儿子

查询的时候枚举一下路径的长度$len$，左半边直接找长度为$len$的最大权值，右半边线段树查询长度为$[L-len,R-len]$的区间即可

一个非常巧妙的地方在于同一个长度我们只需要记录最大权值，这也是长链剖分在这类问题中优于重链剖分的原因

### Code

--------------------- 
```cpp
#include<cstdio>
#include<algorithm>
#define rep(i,st,ed) for (int i=st;i<=ed;++i)
using std::max;
using std::min;
typedef double db;
const db INF=1e15;
const int N=400005;
const int E=600005;
struct edge
{
	int y,w,next;db v;
}e[E];
int dep[N],mx[N],son[N],pos[N],num[N];
int ls[N],edCnt,tot,L,R,n;
db rec[N<<2],dis[N],tmp[N],ans;
int read()
{
    int x=0,v=1;
	char ch=getchar();
    for (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());
    for (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());
    return x*v;
}
void add_edge(int x,int y,int w)
{
    e[++edCnt]=(edge)
	{
		y,w,ls[x],0
	};
	ls[x]=edCnt;
    e[++edCnt]=(edge)
	{
		x,w,ls[y],0
	};
	ls[y]=edCnt;
}
void dfs1(int now,int fa)
{
    mx[now]=dep[now]=dep[fa]+1;
    for (int i=ls[now];i;i=e[i].next)
	{
        if (e[i].y==fa) continue;
        dfs1(e[i].y,now);
        mx[now]=max(mx[now],mx[e[i].y]);
        if (mx[son[now]]<mx[e[i].y]) son[now]=e[i].y;
    }
}
void dfs2(int now,int fa)
{
    pos[now]=++pos[0];
    if (son[now]) dfs2(son[now],now);
    for (int i=ls[now];i;i=e[i].next)
	{
        if (e[i].y==fa||e[i].y==son[now]) continue;
        dfs2(e[i].y,now);
    }
}
void modify(int now,int tl,int tr,int x,db v)
{
    rec[now]=std::max(rec[now],v);
    if (tl==tr) return ;
    int mid=(tl+tr)>>1;
    if (x<=mid) modify(now<<1,tl,mid,x,v);
    else modify(now<<1|1,mid+1,tr,x,v);
}
db query(int now,int tl,int tr,int l,int r)
{
    if (r<l) return -INF;
    if (tl==l&&tr==r) return rec[now];
    int mid=(tl+tr)>>1;
    if (r<=mid) return query(now<<1,tl,mid,l,r);
    if (l>mid) return query(now<<1|1,mid+1,tr,l,r);
    db qx=query(now<<1,tl,mid,l,mid);
    db qy=query(now<<1|1,mid+1,tr,mid+1,r);
    return max(qx,qy);
}
void build_tree(int now,int tl,int tr)
{
    rec[now]=-INF;
    if (tl==tr)
	{
        num[tl]=now;
        return ;
    }
    int mid=(tl+tr)>>1;
    build_tree(now<<1,tl,mid);
    build_tree(now<<1|1,mid+1,tr);
}
void solve(int now,int fa)
{
    modify(1,1,n,pos[now],dis[now]);
    for (int i=ls[now];i;i=e[i].next)
	{
        if (e[i].y==son[now])
		{
            dis[e[i].y]=dis[now]+e[i].v;
            solve(e[i].y,now);
        }
    }
    for (int i=ls[now];i;i=e[i].next)
	{
        if (e[i].y==fa||e[i].y==son[now]) continue;
        dis[e[i].y]=dis[now]+e[i].v;
        solve(e[i].y,now);
        rep(j,1,mx[e[i].y]-dep[now])
		{
            tmp[j]=rec[num[pos[e[i].y]+j-1]];
            if (j<=R)
			{
                db tttt=query(1,1,n,max(pos[now]+L-j,1),min(pos[now]+R-j,pos[now]+mx[now]-dep[now]));
                ans=max(ans,tttt+tmp[j]-dis[now]*2);
            }
        }
        rep(j,1,mx[e[i].y]-dep[now]) modify(1,1,n,pos[now]+j,tmp[j]);
    }
    ans=max(ans,query(1,1,n,pos[now]+L,min(pos[now]+R,pos[now]+mx[now]-dep[now]))-dis[now]);
}
int main(void)
{
    n=read(),L=read(),R=read();
    rep(i,2,n)
	{
        int x=read(),y=read(),w=read();
        add_edge(x,y,w);
    }
    dfs1(1,0);dfs2(1,0);
    db prt,l,r;rec[0]=-INF;
    for (l=0,r=1000000;r-l>1e-5;)
	{
        db mid=(l+r)*0.5;
        rep(i,1,edCnt) e[i].v=-mid+e[i].w;
        ans=-INF; build_tree(1,1,n);
        solve(1,0);
        if (ans<=0) r=mid;
        else l=mid;
    }
    printf("%.3lf\n",(l+r)*0.5);
    return 0;
}
```

---

## 作者：缙云山车神 (赞：4)

## 长链剖分
分数规划和长链剖分大体思路大佬们已经讲得很清楚了  
奈何我太蒟了被有个问题卡了我很久  
就是怎么分配每个子树对应的线段树的空间  
  
当我们正在处理 **x** 点时  
先递归处理完它的重儿子也就是 **y**   
然后直接让 **x** 继承 **y** 的数据
![](https://i.loli.net/2020/10/21/uVt8KivsoMgTjL6.png)
若 **y** 对应的数组长这样子
![](https://i.loli.net/2020/10/21/4f1OxXLypNkMJzV.png)
我们发现在 **y** 这棵树中  
 **x** 为距离 **1** 的点就是 **y** 距离 **0** 的点  
 **x** 为距离 **2** 的点就是 **y** 距离 **1** 的点...  
![](https://i.loli.net/2020/10/21/27oTJvdp8SiFR5B.png)
所以这个显然就是  
我们先遍历重儿子所形成的 **dfs** 序  
其中每一条长链都对应的一段区间  

所以这道题就是对 **dfs** 序建一颗线段树  
x子树中 距离为n的点的最大权值  
对应的是线段树中第 **dfn[x]+n** 个元素

我也搞不懂为什么我在这种显*zhi*然*zhang*的地方卡这么久 
最外层的二分一个*log* 线段树一个*log*  
$O(nlog^2n)$  
最后代码 
```cpp
#include <bits/stdc++.h>
#define N 100100
#define M 200100
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
#define mid ((l+r)>>1)
using namespace std;
typedef long long ll;
const double inf=-5e11*1.0;
int n,minn,maxx;
int f[N],nxt[M],data[M],num;
int dfn[N],mdep[N],dep[N],son[N],fa[N],len[N],root,ti;
double rr,mm,lst[N],far[M],dis[N];
int posi[N];
bool ans;
struct _tr{
	double t[N<<3];
	inline void push_up(int rt){
		t[rt]=max(t[rt<<1],t[rt<<1|1]);
	}
	inline void updata(int pos,double c,int rt=1,int l=1,int r=n){
		if(l==r){ t[rt]=max(c,t[rt]); return; }
		if(pos<=mid){ updata(pos,c,lson); }
		else{ updata(pos,c,rson); }
		push_up(rt);
	}
	inline double query(int L,int R,int rt=1,int l=1,int r=n){
		if(L<=l&&r<=R)return t[rt];
		double res=inf;
		if(L<=mid)res=max(res,query(L,R,lson));
		if(R>mid)res=max(res,query(L,R,rson));
		return res;
	}
	inline void build(int rt=1,int l=1,int r=n){
		t[rt]=inf;
		if(l==r){ posi[l]=rt; return; }
		build(lson); build(rson);
	}
}q;
void inline add(int x,int y,int z){
	nxt[++num]=f[x]; f[x]=num; data[num]=y; far[num]=z;
}
inline void dfs(int x){
	int y;
	for(int i=f[x];i;i=nxt[i]){
		y=data[i]; if(y==fa[x])continue;
		lst[y]=far[i];
		fa[y]=x; dep[y]=mdep[y]=dep[x]+1; dfs(y);
		if(mdep[x]<mdep[y]){
			son[x]=y; mdep[x]=mdep[y];
		}
	} 
	len[x]=mdep[x]-dep[x];
}
inline void dfs2(int x){
	dfn[x]=++ti;
	if(son[x]){ dfs2(son[x]); }
	int y;
	for(int i=f[x];i;i=nxt[i]){
		y=data[i]; if(y==fa[x]||y==son[x])continue;
		dfs2(y);
	}
}
inline void solve(int x){
	int y=son[x],o=dfn[x],ql,qr,oo;
	double z;
	q.updata(o,dis[x]);
	if(y){
		dis[y]=dis[x]+lst[y]-mm;
		solve(y); if(ans==1)return;
	}
	for(int i=f[x];i;i=nxt[i]){
		y=data[i]; if(y==fa[x]||y==son[x])continue;
		dis[y]=dis[x]+lst[y]-mm; solve(y); if(ans==1)return;
		oo=dfn[y];
		for(int j=0;j<=min(maxx,len[y]);j++){
			ql=max(minn-1-j,0),qr=min(maxx-1-j,len[x]);
			if(ql>qr)continue;
			z=q.t[posi[oo+j]]-dis[x];
			if(q.query(o+ql,o+qr)-dis[x]+z>=0){
				ans=1; return; 
			}
		}
		for(int j=0;j<=min(len[y],maxx);j++){
			ql=1+j;
			if(q.t[posi[oo+j]]>q.t[posi[o+ql]]){ q.updata(o+ql,q.t[posi[oo+j]]); }
		}
	}
	if(len[x]>=minn){
		if(q.query(o+minn,o+min(len[x],maxx))>=dis[x]){
			ans=1; return;
		}
	}
}

void get_ans(){
	double l=0,r=rr;
	while(r-l>0.0002){
		mm=(l+r)/2.0000;
		ans=0; dis[root]=0; q.build();
		solve(root);
		if(ans){ l=mm; }
		else{ r=mm; }
	} 
	printf("%.3lf",l);
}
int main(){
//	freopen("test.in","r",stdin);
	scanf("%d %d %d",&n,&minn,&maxx);
	int u,v,z;
	for(int i=1;i<n;i++){
		scanf("%d %d %d",&u,&v,&z);
		add(u,v,z); add(v,u,z); 
		rr=max((double)z,rr);
	}
	root=rand()%n+1;
	dfs(root); 
	dfs2(root); 
	get_ans();
	return 0;
} 
```









---

## 作者：1saunoya (赞：3)

~~只有我发现这题和150E几乎是一样的然后抄了个板子改改改就过了吗。~~

首先考虑一个判定问题。

平均值 $\ge mid$。

那么就是存在 $\sum_{l \leq |path| \leq r} x \in path \geq mid \times |path|$。

所以我们把每条路径的权值减掉 $mid$，然后问题等价于找一条大于 0 的路径，这个显然可以长链剖分+线段树。

于是就和 150E 一模一样了，就是把 中位数 改成 平均值，int 改成 double（（

---

## 作者：gorokokoro (赞：1)

## 这个题可以使用 $\log^3$ 算法通过

显然是一个分数规划的模型，因此直接二分答案 $m$，现在欲求所有长度在 $l$ 到 $r$ 之间的路径的权值的最大值。

点对问题考虑点分治，考虑把子树用线段树维护，暴力区间查询即为 $n\log^3n$ 。

因为常数过大，不预先建出点分树可能会 $\text T$ 到爆炸……

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <utility>
#define N 100020
#define EPS 1e-4
using namespace std;

extern vector<pair<int, double> > e[N];
extern bool u[N];

namespace G
{
    int f[N], g[N];
    vector<int> v;

    void DFS(int x, int p)
    {
        int i;

        v.push_back(x);
        for(i = g[x] = 0, f[x] = 1; i < (signed)e[x].size(); i ++)
            if(!u[e[x].at(i).first] && e[x].at(i).first != p)
            {
                DFS(e[x].at(i).first, x);
                f[x] += f[e[x].at(i).first];
                g[x] = max(g[x], f[e[x].at(i).first]);
            }

        return;
    }

    int G(int x)
    {
        int i, o;

        v.clear();
        DFS(x, x);
        for(i = o = 0; i < (signed)v.size(); i ++)
            if(max(g[v.at(i)], (signed)v.size() - f[v.at(i)]) < max(g[v.at(o)], (signed)v.size() - f[v.at(o)]))
                o = i;

        return v.at(o);
    }
}

vector<pair<int, double> > e[N];
bool u[N];
double f[N << 1];
vector<vector<pair<double, int> > > g[N];
int d[N];

void CheckSegwin(int p, double v, int n, bool k)
{
    if(k || f[p + n] < v)
        for(f[p += n] = v; p >>= 1; )
            f[p] = max(f[p << 1], f[p << 1 | 1]);

    return;
}

double MaxSegwin(int l, int r, int n)
{
    double o;

    l = max(l,     0);
    r = min(r, n - 1);
    if(l > r)
        return -1e12;
    for(o = -1e12, l += n, r += n + 1; l < r; l >>= 1, r >>= 1)
    {
        if(l & 1)
            o = max(o, f[l ++]);
        if(r & 1)
            o = max(o, f[-- r]);
    }

    return o;
}

void DFS(vector<pair<double, int> > &g, int x, int p, int d, double w)
{
    int i;

    g.push_back(make_pair(w, d));
    for(i = 0; i < (signed)e[x].size(); i ++)
        if(!u[e[x].at(i).first] && e[x].at(i).first != p)
            DFS(g, e[x].at(i).first, x, d + 1, w + e[x].at(i).second);

    return;
}

void CDQ(int x)
{
    int i, j;

    x = G::G(x);
    u[x] = true;
    for(i = 0; i < (signed)e[x].size(); i ++)
        if(!u[e[x].at(i).first])
        {
            g[x].push_back(vector<pair<double, int> >());
            DFS(g[x].back(), e[x].at(i).first, x, 1, e[x].at(i).second);
            for(j = 0; j < (signed)g[x].back().size(); j ++)
                d[x] = max(d[x], g[x].back().at(j).second);
        }
    d[x] ++;

    for(i = 0; i < (signed)e[x].size(); i ++)
        if(!u[e[x].at(i).first])
            CDQ(e[x].at(i).first);

    return;
}

bool Check(int n, int p, int q, double m)
{
    int x, i, j;

    for(x = 0; x < n; x ++)
    {
        for(i = 0; i < (signed)g[x].size(); i ++)
        {
            for(j = 0; j < (signed)g[x].at(i).size(); j ++)
                if(g[x].at(i).at(j).first - m * g[x].at(i).at(j).second + MaxSegwin(p - g[x].at(i).at(j).second, q - g[x].at(i).at(j).second, d[x]) > 0)
                    return true;
            for(j = 0; j < (signed)g[x].at(i).size(); j ++)
                CheckSegwin(g[x].at(i).at(j).second, g[x].at(i).at(j).first - m * g[x].at(i).at(j).second, d[x], false);
        }
        if(MaxSegwin(p, q, d[x]) > 0)
            return true;

        for(i = 0; i < d[x]; i ++)
            CheckSegwin(i, -1e12, d[x], true);
    }

    return false;
}

int main(void)
{
    int n, p, q, u, v, w;
    int i;
    double l, m, r;

    scanf("%d %d %d", &n, &p, &q);
    for(i = 1, r = 0; i < n; i ++)
    {
        scanf("%d %d %d", &u, &v, &w);
        e[-- u].push_back(make_pair(-- v, w));
        e[   v].push_back(make_pair(   u, w));
        r += w;
    }
    CDQ(0);

    for(l = 0; r - l > EPS; )
    {
        for(i = 0; i < (n << 1); i ++)
            f[i] = -1e12;
        if(Check(n, p, q, m = (l + r) / 2))
            l = m;
        else
            r = m;
    }
    printf("%.3f\n", r);

    return 0;
}

```

---

## 作者：Ark_ (赞：1)

# 题意
[自己看.](https://www.luogu.org/problemnew/show/P4292)
# 分析
求这个平均值的最大值就是分数规划,二分一下就变成了求一条长度在[L,R]内路径的权值和最大.有淀粉质的做法但是我没写,感觉常数会很大.这道题可以用长链剖分做.

先对树长链剖分. 我们像做dsu on tree(树上启发式合并)一样先做重儿子，用线段树继承重儿子的全部信息，然后做其他轻儿子

查询的时候枚举一下路径的长度len，一边单点$O(1)$查询长度为len的最大权值，一边线段树$O(logn)$查询长度为[L-len,R-len]的区间即可

时间复杂度我不会证(后面有)...反正枚举**轻儿子的深度**是总共$O(n)$的.所以加上外面的二分,总时间复杂度为$O(nlog^2n)$.

$Upd:$ 枚举轻儿子的深度的时间复杂度证明如下
> 时间复杂度$O(n)$。
分析如下：
每个点x只会暴力统计其所有轻儿子的信息，而每个轻儿子的信息大小为该轻儿子所在长链长度。
而当递归到x的父节点fa(x)时，若x不是fa(x)的重儿子，则fa(x)会暴力统计大小为x长链长度的信息。
故，每个长链只会对转移的复杂度做一次大小为其长度的贡献。

超强的长链剖分a!!! 证明摘自下面的博客.

学习长链剖分的看这里...[博客传送门](https://blog.bill.moe/long-chain-subdivision-notes/)

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
char cb[1<<15],*cs=cb,*ct=cb;
#define getc() (cs==ct&&(ct=(cs=cb)+fread(cb,1,1<<15,stdin),cs==ct)?0:*cs++)
template<class T>inline void read(T &res) {
    char ch; int flg = 1; for(;!isdigit(ch=getc());)if(ch=='-')flg=-flg;
    for(res=ch-'0';isdigit(ch=getc());res=res*10+ch-'0'); res*=flg;
}
template<class T>inline void chkmax(T &x, T y) { if(x < y) x = y; }
const int MAXN = 100005;
const double INF = 1e16;
int n, L, R, cnt, fir[MAXN], init_len[MAXN<<1];
struct edge { int to, nxt; double w; }e[MAXN<<1];
inline void add(int u, int v, int wt) {
    e[cnt] = (edge) { v, fir[u], 0 }, init_len[cnt] = wt, fir[u] = cnt++;
    e[cnt] = (edge) { u, fir[v], 0 }, init_len[cnt] = wt, fir[v] = cnt++;
}
int mxd[MAXN], dep[MAXN], son[MAXN], Eson[MAXN], dfn[MAXN], tmr;
void dfs1(int u, int ff) {
    mxd[u] = dep[u] = dep[ff] + 1;
    for(int i = fir[u], v; ~i; i = e[i].nxt)
        if((v=e[i].to) != ff) {
            dfs1(v, u); chkmax(mxd[u], mxd[v]);
            if(mxd[v] > mxd[son[u]]) son[u] = v, Eson[u] = i;
        }
}
void dfs2(int u, int ff) {
    dfn[u] = ++tmr;
    if(son[u]) dfs2(son[u], u);
    for(int i = fir[u], v; ~i; i = e[i].nxt)
        if((v=e[i].to) != ff && v != son[u])
            dfs2(v, u);
}
int num[MAXN];
double dis[MAXN], mx[MAXN<<2];
void build(int i, int l, int r) {
    mx[i] = -INF;
    if(l == r) { num[l] = i; return; }
    int mid = (l + r) >> 1;
    build(i<<1, l, mid);
    build(i<<1|1, mid+1, r);
}
void modify(int i, int l, int r, int x, double val) {
    chkmax(mx[i], val);
    if(l == r) return;
    int mid = (l + r) >> 1;
    if(x <= mid) modify(i<<1, l, mid, x, val);
    else modify(i<<1|1, mid+1, r, x, val);
}
double query(int i, int l, int r, int x, int y) {
    if(x > y) return -INF;
    if(l == x && r == y) return mx[i];
    int mid = (l + r) >> 1;
    if(y <= mid) return query(i<<1, l, mid, x, y);
    else if(x > mid) return query(i<<1|1, mid+1, r, x, y);
    else return max(query(i<<1, l, mid, x, mid), query(i<<1|1, mid+1, r, mid+1, y));
}
double tmp[MAXN];
bool solve(int u, int ff) {
    modify(1, 1, n, dfn[u], dis[u]);
    if(son[u]) {
		dis[son[u]] = dis[u] + e[Eson[u]].w;
		if(solve(son[u], u)) return 1;
	}
    for(int i = fir[u], v; ~i; i = e[i].nxt)
        if((v=e[i].to) != ff && v != son[u]) {
            dis[v] = dis[u] + e[i].w;
			if(solve(v, u)) return 1;
            for(int j = 1; j <= mxd[v]-dep[u]; ++j) {
                tmp[j] = mx[num[dfn[v]+j-1]];
                if(j <= R) {
                    double temp = query(1, 1, n, dfn[u] + max(L-j, 0), dfn[u] + min(R-j, mxd[u]-dep[u]));
					if(tmp[j] + temp - 2 * dis[u] >= 0) return 1;
                }
            }
            for(int j = 1; j <= mxd[v]-dep[u]; ++j)
                modify(1, 1, n, dfn[u]+j, tmp[j]);
        }
    return query(1, 1, n, dfn[u]+L, dfn[u]+min(R, mxd[u]-dep[u]))-dis[u] >= 0;
}
inline bool judge(double mid) {
    for(int i = 0; i < cnt; ++i)
        e[i].w = init_len[i] - mid;
    build(1, 1, n);
    return solve(1, 0);
}
int main() {
    memset(fir, -1, sizeof fir);
    read(n), read(L), read(R);
    for(int i = 1, x, y, z; i < n; ++i)
        read(x), read(y), read(z), add(x, y, z);
    dfs1(1, 0), dfs2(1, 0);
    double l = 0, r = 1e6, mid;
    while(r - l > (1e-4)) {
        mid = (l + r) / 2;
        if(judge(mid)) l = mid;
        else r = mid;
    }
    printf("%.3f\n", l);
}
```
# CODE2
把二分转成迭代后直接洛谷rank 1了...

迭代就是随便取一个值作为mid,带进去算后得到更优的答案,然后把更优的答案作为mid继续迭代下去...直白点就是向答案逼近.

然后初值取一个适中的数就跑的超快了...感觉相当于没有了二分的那一个log

~~那分数规划都可以用迭代咯...~~ 
```cpp
#include<bits/stdc++.h>
using namespace std;
char cb[1<<15],*cs=cb,*ct=cb;
#define getc() (cs==ct&&(ct=(cs=cb)+fread(cb,1,1<<15,stdin),cs==ct)?0:*cs++)
template<class T>inline void read(T &res) {
    char ch; int flg = 1; for(;!isdigit(ch=getchar());)if(ch=='-')flg=-flg;
    for(res=ch-'0';isdigit(ch=getchar());res=res*10+ch-'0'); res*=flg;
}
template<class T>inline void chkmax(T &x, T y) { if(x < y) x = y; }
const int MAXN = 100005;
const double INF = 1e16;
int n, L, R, cnt, fir[MAXN], init_len[MAXN<<1];
struct edge { int to, nxt; double w; }e[MAXN<<1];
inline void add(int u, int v, int wt) {
    e[cnt] = (edge) { v, fir[u], 0 }, init_len[cnt] = wt, fir[u] = cnt++;
    e[cnt] = (edge) { u, fir[v], 0 }, init_len[cnt] = wt, fir[v] = cnt++;
}
int mxd[MAXN], dep[MAXN], son[MAXN], Eson[MAXN], dfn[MAXN], tmr;
void dfs1(int u, int ff) {
    mxd[u] = dep[u] = dep[ff] + 1;
    for(int i = fir[u], v; ~i; i = e[i].nxt)
        if((v=e[i].to) != ff) {
            dfs1(v, u); chkmax(mxd[u], mxd[v]);
            if(mxd[v] > mxd[son[u]]) son[u] = v, Eson[u] = i;
        }
}
void dfs2(int u, int ff) {
    dfn[u] = ++tmr;
    if(son[u]) dfs2(son[u], u);
    for(int i = fir[u], v; ~i; i = e[i].nxt)
        if((v=e[i].to) != ff && v != son[u])
            dfs2(v, u);
}
int num[MAXN];
double dis[MAXN];
struct node {
    double x; int y; //x:最大路径和   y:边数
    node(){}
    node(double xx, int yy):x(xx), y(yy){}
    inline bool operator <(const node &o)const { return x < o.x; }
}Ans, tmp[MAXN], mx[MAXN<<2];
void build(int i, int l, int r) {
    mx[i] = node(-INF, 0);
    if(l == r) { num[l] = i; return; }
    int mid = (l + r) >> 1;
    build(i<<1, l, mid);
    build(i<<1|1, mid+1, r);
}
void modify(int i, int l, int r, int x, node val) {
    chkmax(mx[i], val);
    if(l == r) return;
    int mid = (l + r) >> 1;
    if(x <= mid) modify(i<<1, l, mid, x, val);
    else modify(i<<1|1, mid+1, r, x, val);
}
node query(int i, int l, int r, int x, int y) {
    if(x > y) return node(-INF, 0);
    if(l == x && r == y) return mx[i];
    int mid = (l + r) >> 1;
    if(y <= mid) return query(i<<1, l, mid, x, y);
    else if(x > mid) return query(i<<1|1, mid+1, r, x, y);
    else return max(query(i<<1, l, mid, x, mid), query(i<<1|1, mid+1, r, mid+1, y));
}

void solve(int u, int ff) {
    modify(1, 1, n, dfn[u], node(dis[u], dep[u]));
    if(son[u]) dis[son[u]] = dis[u] + e[Eson[u]].w, solve(son[u], u);
    for(int i = fir[u], v; ~i; i = e[i].nxt)
        if((v=e[i].to) != ff && v != son[u]) {
            dis[v] = dis[u] + e[i].w, solve(v, u);
            for(int j = 1; j <= mxd[v]-dep[u]; ++j) {
                tmp[j] = mx[num[dfn[v]+j-1]];
                if(j <= R) {
                    node temp = query(1, 1, n, dfn[u] + max(L-j, 0), dfn[u] + min(R-j, mxd[u]-dep[u]));
                    chkmax(Ans, node(tmp[j].x + temp.x - 2 * dis[u], tmp[j].y + temp.y - 2*dep[u]));
                }
            }
            for(int j = 1; j <= mxd[v]-dep[u]; ++j)
                modify(1, 1, n, dfn[u]+j, tmp[j]);
        }
    node temp = query(1, 1, n, dfn[u]+L, dfn[u]+min(R, mxd[u]-dep[u]));
    temp.x -= dis[u]; temp.y -= dep[u];
    chkmax(Ans, temp);
}
inline node judge(double mid) {
    for(int i = 0; i < cnt; ++i)
        e[i].w = init_len[i] - mid;
    build(1, 1, n);
    Ans = node(-INF, 0);
    solve(1, 0);
    return Ans;
}
int main() {
    memset(fir, -1, sizeof fir);
    read(n), read(L), read(R);
    for(int i = 1, x, y, z; i < n; ++i)
        read(x), read(y), read(z), add(x, y, z);
    dep[0] = -1; dfs1(1, 0), dfs2(1, 0);
    double mid = 600000;
    while(1) { //高级操作
        node now = judge(mid);
        double ans = (now.x + mid*now.y) / now.y; //把y条边减去的mid加回来,再算一次平均值
        if(fabs(ans-mid) < 1e-3) break;
        mid = ans;
    }
    printf("%.3f\n", mid);
}
```


---


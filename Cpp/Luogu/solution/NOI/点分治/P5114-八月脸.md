# 八月脸

## 题目背景

Cdm1020 十分喜欢 August-soft 出品的游戏，在游玩 august 社历届作品的时候他突然发现了一些神奇的事实。

**那就是所有的人物立绘的脸都是一样的!**


![](https://i.loli.net/2018/09/17/5b9fb47a8b3e0.gif)

不过尽管如此，作为一名资深的八月厨，他依然可以敏锐的分辨出各张立绘之间的细微差异 ~~（并不，就是同一张脸有什么好分辨的）~~，为了进一步研究八月社的立绘水平，Cdm1020 将八月社的所有立绘都放到了一颗树上 ~~（什么鬼啊）~~

（如果你不知道什么是树的话，你可以将树理解为一个无环的无向连通图）

具体来讲树上的每个节点仅保存了一张八月社的立绘，Cdm1020 通过和他的八月厨朋友们交流发现，狂热程度不同的八月厨对于同一张立绘的喜爱程度是不一样的，具体来讲每张立绘有两个属性 $a$ 和 $b$，对于一个狂热指数为 $k$ 的八月厨来讲，他对一张属性为 $(a,b)$ 的立绘的喜爱程度为 $ka+b$。

现在 Cdm1020 想要带领他的 $m$ 个狂热指数不同的朋友参观八月社的立绘（们），他希望你对于他的每一个朋友，帮他规划出一条喜爱程度之和最大的游览路线。

当然这个问题很简单，他是不会拿来烦你的。现在他真正头疼的事情是八月社新来了一个画师夏野。他的朋友们现在闹腾着想要看八月社的新立绘 ~~（反正还是一张脸有什么好看的）~~，所以他规定你的路线必须从一张属于 b 叔的立绘开始，到一张属于夏野的立绘结束，你能帮帮他吗？

## 题目描述

**请忽略上面的鬼话，就当什么也没看见**

一句话题意，给定一颗 $n$ 个点的树，树上每个点不是黑色就是白色，每个点有两个属性 $a$ 和 $b$。

现在多组询问，每次询问仅给出一个参数 $k$，要求你从树上找出一条路径 $(u,v)$ 使得 $u$ 和 $v$ 的颜色不同并且

$$k\times \sum_{p \in path (u-v)}p.a+\sum_{p\in path(u-v)}p.b$$

最大，对于每个询问你仅需要输出这个最大值即可（式子里面的两个和式的意思分别是路径上的点 $a$ 属性之和和路径上点的 $b$ 属性之和）。

**tips: $a,b,k$ 均可正可负，并且我们不允许你不选路径，也就是说我们求出的的最大值可以是一个负数，这会发生在所有合法路径的权值都是负数的时候**。

## 说明/提示

$2 \leq n\leq 10^5$，$1 \leq m \leq 10^5$，$-10^8 \leq k \leq 10^8 $

保证不会存在所有点都是黑色或者都是白色的数据，保证对于树上的任意路径，路径上点的 $a$ 属性之和的绝对值不超过$1.5×10^9$，路径上点的 $b$ 属性之和的绝对值不超过 $1.5×10^9$。

## 样例 #1

### 输入

```
15 15
29 -23 -14 -50 -13 -23 5 33 50 32 27 27 -9 -42 -11
-37 39 21 50 10 -42 -2 25 1 28 40 -45 -24 -29 47
0 0 1 0 0 1 1 0 0 1 0 1 0 0 0
2 1
3 1
4 3
5 2
6 2
7 2
8 4
9 1
10 2
11 5
12 3
13 5
14 3
15 9
-8
36
44
29
-5
-4
-3
-2
-1
0
1
2
3
4
5
```

### 输出

```
679
3252
3988
2608
436
355
274
199
135
126
155
232
309
386
471
```

# 题解

## 作者：qwaszx (赞：12)

我们发现需要求一个类似 $\max(kx+y)$ 的东西，那么只需要求出所有 $(x,y)$ 的上凸壳然后二分即可.

官方题解用的边分治，由于我不会边分治所以我写的点分治.

点分治的常用计算答案方法有三种: 先不考虑两个点在同一棵子树的情况计算最后再容斥掉；逐子树加入，即考虑每棵子树对之前加入的子树的贡献；合并果子，即每次拿出两个size最小的子树计算答案，然后把这两个子树的信息合并后放回去. 

这里需要第三种算法，如果合并两棵大小为 $size_x$ 和 $size_y$ 的子树需要的复杂度是 $O(size_x+size_y)$，那么总复杂度仍然是一个log~~然而我不会证~~

求出所有子树的末端为黑/白点的凸包，那么合并两棵子树 $x,y$ 的时候，只需要对 $x$ 的黑点凸包和 $y$ 的白点凸包、$x$ 的白点凸包和 $y$ 的黑点凸包分别做一个闵可夫斯基和，得到的凸包上的点扔到答案凸包里去(先不构建，只存储点). 不会闵可夫斯基和的可以去看一下[这道题](https://www.luogu.com.cn/problem/P5073). 然后归并 $x$ 的凸包和 $y$ 的凸包放回去即可.

求出答案凸包之后询问在上面二分即可，当然也可以像上面那道题一样暴力移动指针.

算一下复杂度，发现合并凸包的部分是没问题的，但是构建答案凸包和构建子树凸包的时候可能会有问题，使用sort会使复杂度变成两个log，那么只需要离线基数排序即可. 不过两个log也能过，所以就懒得写基排了(

跑得好像比边分治慢不少.

需要注意的细节是由于值域为 $1.5\times 10^9$，所以加加减减的时候可能会爆int(

然后排序的时候先按 $x$ 排序，$x$ 一样的时候按 $y$ 排序，不然求的凸包可能会有问题.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<algorithm>
#define IT vector<int>::iterator
using namespace std;
const int N=2e5+5000,INF=2e9;
struct Point
{
    long long x,y;
    Point operator +(const Point &a)const{return (Point){x+a.x,y+a.y};}
    Point operator -(const Point &a)const{return (Point){x-a.x,y-a.y};}
    bool operator >=(const Point &a)const{return 1ll*x*a.y<=1ll*y*a.x;}
    long long f(int k){return 1ll*k*x+y;}
}tmpans[N*200],tmp[2][N],w[N];
struct Hull
{
    int len;
    vector<Point>a;
    Hull(){len=0;}
    Point operator [](const int &x)const{return a[x];}
    void clear(){len=0;a.clear();}
    void push(const Point &x)
    {
        while(len>1&&(x-a[len-1])>=(a[len-1]-a[len-2]))--len,a.pop_back();
        ++len,a.push_back(x);
    }
}a[N<<1][2];
vector<int>e[N];
int ansn=0,len[2],col[N],n,m,nn,mxson,root,size[N],vis[N];
long long ans[N];
struct Q{int w,id;}q[N];
void ade(int u,int v){e[u].push_back(v);}
Hull merge(const Hull &a,const Hull &b)
{
    Hull tmp;
    for(int i=0,j=0;i<a.len||j<b.len;)
        if(i==a.len||(j<b.len&&b[j].x<a[i].x))
            tmp.push(b[j]),j++;
        else if(j==b.len||a[i].x<b[j].x)
            tmp.push(a[i]),i++;
        else tmp.push(a[i].y>b[j].y?a[i]:b[j]),i++,j++;
	return tmp;
}
Hull Minkow(const Hull &a,const Hull &b)
{
    Hull tmp;if(!a.len||!b.len)return tmp;
	tmp.push(a[0]+b[0]);int i=0,j=0;
    for(;i<a.len-1||j<b.len-1;)
        if(i==a.len-1)tmp.push(a[i]+b[++j]);
        else if(j==b.len-1)tmp.push(a[++i]+b[j]);
        else tmp.push((a[i+1]-a[i])>=(b[j+1]-b[j])?a[++i]+b[j]:a[i]+b[++j]);
    return tmp;
}
void findroot(int u,int fa)
{
    size[u]=1;int mx=0;
    for(IT i=e[u].begin();i!=e[u].end();i++)
    {
        int v=*i;if(vis[v]||v==fa)continue;
        findroot(v,u),mx=max(mx,size[v]),size[u]+=size[v];
    }
    mx=max(mx,nn-size[u]);
    if(mx<mxson)mxson=mx,root=u;
}
void dfs(int u,int fa,Point s)
{
    tmp[col[u]][++len[col[u]]]=s;
    for(IT i=e[u].begin();i!=e[u].end();i++)
    {
        int v=*i;if(v==fa||vis[v])continue;
        dfs(v,u,s+w[v]);
    }
}
int cmp(const Point &a,const Point &b){return a.x==b.x?a.y<b.y:a.x<b.x;}
void build(int u)
{
    a[u][0].clear();a[u][1].clear();
    sort(tmp[0]+1,tmp[0]+len[0]+1,cmp),sort(tmp[1]+1,tmp[1]+len[1]+1,cmp);
    
    for(int i=1;i<=len[0];i++)a[u][0].push(tmp[0][i]);
    for(int i=1;i<=len[1];i++)a[u][1].push(tmp[1][i]);
}
void calc(int x,int y,int u)
{
    Hull tmp=Minkow(a[x][0],a[y][1]);
    for(int i=0;i<tmp.len;i++)tmpans[++ansn]=tmp[i]+w[u];
    tmp=Minkow(a[x][1],a[y][0]);
    for(int i=0;i<tmp.len;i++)tmpans[++ansn]=tmp[i]+w[u];
}
struct HeapNode{int u,size;bool operator <(const HeapNode &a)const{return size>a.size;}};
void solve(int u)
{
    vis[u]=1;priority_queue<HeapNode>q;
    for(IT i=e[u].begin();i!=e[u].end();i++)
    {
        int v=*i;if(vis[v])continue;
	    len[0]=len[1]=0;dfs(v,u,w[v]);
        build(v);q.push((HeapNode){v,a[v][0].len+a[v][1].len});
    }
    int tn=n;
    while(q.size()>1)
    {
        HeapNode x=q.top(),y;
        q.pop();y=q.top();q.pop();
        calc(x.u,y.u,u);
//		cout<<x.u<<" "<<y.u<<endl;
        ++tn;a[tn][0]=merge(a[x.u][0],a[y.u][0]),a[tn][1]=merge(a[x.u][1],a[y.u][1]);
        q.push((HeapNode){tn,a[tn][0].len+a[tn][1].len});
    }
    if(q.empty())return;
    int t=q.top().u;q.pop();
    if(col[u])
    {
        for(int i=0;i<a[t][0].len;i++)tmpans[++ansn]=a[t][0][i]+w[u];
    }
    else
    {
        for(int i=0;i<a[t][1].len;i++)tmpans[++ansn]=a[t][1][i]+w[u];
    }
    for(IT i=e[u].begin();i!=e[u].end();i++)
    {
        int v=*i;if(vis[v])continue;
        nn=size[v],mxson=INF,findroot(v,u),solve(root);
    }
}
int getin()
{
    int x=0,f=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x*f;
}
int cmp2(const Q &a,const Q &b){return a.w<b.w;}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)w[i].x=getin();
    for(int i=1;i<=n;i++)w[i].y=getin();
    for(int i=1;i<=n;i++)col[i]=getin();
    for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),ade(u,v),ade(v,u);
    nn=n,mxson=INF,findroot(1,0),solve(root);
    sort(tmpans+1,tmpans+ansn+1,cmp);
//    for(int i=1;i<=ansn;i++)cout<<tmpans[i].x<<" "<<tmpans[i].y<<endl;
    Hull tmp;
    for(int i=1;i<=ansn;i++)tmp.push(tmpans[i]);
//    for(int i=0;i<tmp.len;i++)cout<<tmp[i].x<<" "<<tmp[i].y<<endl;
    for(int i=1;i<=m;i++)scanf("%d",&q[i].w),q[i].id=i;
    if(!tmp.len){for(int i=1;i<=m;i++)puts("0");return 0;}
    sort(q+1,q+m+1,cmp2);
    for(int i=1,j=0;i<=m;i++)
    {
        while(j+1<tmp.len&&tmp[j+1].f(q[i].w)>=tmp[j].f(q[i].w))++j;
        ans[q[i].id]=tmp[j].f(q[i].w);
    }
    for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
}
```

---

## 作者：final_trump (赞：5)

## P5114 八月脸
本题相当于求出所有异色点对路径上的点权和所构成的上凸壳，而构成凸壳的直线并不会很多，这启示我们寻找一种更快捷的方式求出答案凸壳。

我们可以沿用[这道题](https://www.luogu.com.cn/problem/CF1019E)的套路，边分治后合并两边的凸壳，即对两边做闵可夫斯基和，这样直线的数量级是 $O(n \log n)$ 的，且留下的都是有效的信息。最后离线扫一遍凸壳求答案即可。

但这道题让我体会到了用边分治解决结点问题深深的恶意。首先在三度化的过程中，新建结点的信息应该来自分裂结点，而不是没有储存信息。其次，在分治进行 dfs 时，应注意当前结点和下一个结点是否储存着同一点的信息，如果是则不应该把新的结点的信息累加到答案中。

代码中求凸壳用到了类似于求点凸壳的方法，其实该问题可以对偶转化为点凸壳问题，具体可参见[这篇博客](https://trinkle.blog.uoj.ac/blog/235)。

复杂度 $O(n \log^2 n)$ 。需要注意边分治时两边子树大小的计算，如果大小不当会导致复杂度错误。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long lxl;
const int MAXN=2e5+5;

int n,m;
int color[MAXN],rev[MAXN<<1];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch))(ch=='-')&&(f=-f),ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}
struct Vector{
	lxl x,y;
	Vector(lxl x=0,lxl y=0):x(x),y(y){};
	inline void print(){printf("(%lld,%lld)\n",x,y);}
	inline Vector operator +(const Vector &tmp)const{return Vector(x+tmp.x,y+tmp.y);}
	inline Vector operator -(const Vector &tmp)const{return Vector(x-tmp.x,y-tmp.y);}
	inline Vector operator *(const lxl &tmp)const{return Vector(x*tmp,y*tmp);}
	inline Vector operator /(const lxl &tmp)const{return Vector(x/tmp,y/tmp);}
	inline lxl operator *(const Vector &tmp)const{return x*tmp.x+y*tmp.y;}
	inline lxl operator %(const Vector &tmp)const{return x*tmp.y-y*tmp.x;}
}val[MAXN<<1];

Vector Ans[MAXN*40];int cnta;
namespace Tree2{
	const int MAXN=2e5+5;
	int head[MAXN],trump=1;
	struct Edge{
		int to,next;
		Edge(int u=0,int v=0):to(v),next(head[u]){};
	}e[MAXN<<1];
	inline void addedge(int u,int v){
		e[++trump]=Edge(u,v);head[u]=trump;
		e[++trump]=Edge(v,u);head[v]=trump;
	}
	void debug(int u,int fa){
		for(register int i=head[u];i;i=e[i].next){
			int v=e[i].to;if(v==fa) continue;
			printf("%d(%lld,%lld) %d(%lld,%lld)\n",u,val[u].x,val[u].y,v,val[v].x,val[v].y);
			debug(v,u);
		}
	}
	int size[MAXN],mx[MAXN];
	bool vis[MAXN];int tot,edge;
	void findedge(int u,int fa){
		size[u]=1;
		for(register int i=head[u];i;i=e[i].next){
			int v=e[i].to;if(v==fa||vis[i>>1]) continue;
			findedge(v,u);size[u]+=size[v];
			mx[i>>1]=max(size[v],tot-size[v]);
			if(mx[i>>1]<mx[edge>>1]) edge=i;
		}
	}
	Vector Lb[MAXN],Lw[MAXN],Rb[MAXN],Rw[MAXN];
	Vector C[MAXN];
	int cntlb,cntlw,cntrb,cntrw,cntc;
	
	inline bool cmp(const Vector &a,const Vector &b){
		return a.x!=b.x?a.x<b.x:a.y>b.y;
	}
	Vector stk[MAXN*20];int top;
	inline void tuke(Vector *a,int &n){
		register int i;
		if(!n) return;
		sort(a+1,a+n+1,cmp);
		stk[top=1]=a[1];
		for(i=2;i<=n;++i){
			if(a[i].x==a[i-1].x) continue;
			while(top>1&&(stk[top]-stk[top-1])%(a[i]-stk[top-1])>=0) --top;
			stk[++top]=a[i];
		}
		for(i=1;i<=top;++i) a[i]=stk[i];
		for(i=top+1;i<=n;++i) a[i]=0;n=top;
	}
	Vector s1[MAXN],s2[MAXN];
	inline void minkowski(Vector *a,int &n,Vector *b,int &m,Vector *c,int &s){
		int i,j;
		if(!n||!m) return void(s=n=m=0); 
		for(i=1;i<n;++i) s1[i]=a[i+1]-a[i];s1[n]=0;
		for(i=1;i<m;++i) s2[i]=b[i+1]-b[i];s2[m]=0;
		c[s=1]=a[1]+b[1];i=j=1;
		while(i<n&&j<m) ++s,c[s]=c[s-1]+(s1[i]%s2[j]<0?s1[i++]:s2[j++]);
		while(i<n) ++s,c[s]=c[s-1]+s1[i++];
		while(j<m) ++s,c[s]=c[s-1]+s2[j++];
		for(i=1;i<=n;++i) a[i]=0;
		for(i=1;i<=m;++i) b[i]=0;
		n=m=0;
//		tuke(c,s);
	}
	void work(int u,int fa,Vector len,bool c){
		if(u<=n){
			if(color[u]==0) c?Lw[++cntlw]=len:Rw[++cntrw]=len;
			else c?Lb[++cntlb]=len:Rb[++cntrb]=len;
		}
		for(register int i=head[u];i;i=e[i].next){
			int v=e[i].to;if(v==fa||vis[i>>1]) continue;
			work(v,u,len+(rev[u]!=rev[v]?val[v]:0),c);
		}
	}
	void solve(int b){
		register int i;
		if(!b) return;vis[b>>1]=1;
		int u=e[b^1].to,v=e[b].to;
		if(u>v) swap(u,v);
		work(u,v,rev[u]!=v?val[u]:0,1);work(v,u,rev[v]!=rev[u]?val[v]:0,0);
		tuke(Lb,cntlb);tuke(Rw,cntrw);
		minkowski(Lb,cntlb,Rw,cntrw,C,cntc);
		for(i=1;i<=cntc;++i) Ans[++cnta]=C[i];
		tuke(Lw,cntlw);tuke(Rb,cntrb);
		minkowski(Lw,cntlw,Rb,cntrb,C,cntc);
		for(i=1;i<=cntc;++i) Ans[++cnta]=C[i];
//		tuke(Ans,cnta);
		int szeA=size[u]>size[v]?tot-size[v]:size[u],szeB=size[v]>size[u]?tot-size[u]:size[v];
//		assert(abs(szeA-szeB)<=1000);
		tot=szeA;edge=0;findedge(u,v);solve(edge);
		tot=szeB;edge=0;findedge(v,u);solve(edge);
	}
	int main(){
		mx[0]=MAXN<<1;edge=0;
		findedge(1,0);solve(edge);
		tuke(Ans,cnta);
//		for(register int i=1;i<=cnta;++i) Ans[i].print();
		return 0;
	} 
}
namespace Tree1{
	int head[MAXN],trump;
	struct Edge{
		int to,next;
		Edge(int u=0,int v=0):to(v),next(head[u]){};
	}e[MAXN<<1];
	inline void addedge(int u,int v){
		e[++trump]=Edge(u,v);head[u]=trump;
		e[++trump]=Edge(v,u);head[v]=trump;
	}
	void debug(int u,int fa){
		for(register int i=head[u];i;i=e[i].next){
			int v=e[i].to;if(v==fa) continue;
			printf("%d(%lld,%lld) %d(%lld,%lld)\n",u,val[u].x,val[u].y,v,val[v].x,val[v].y);
			debug(v,u);
		}
	}
	int son[MAXN<<1],top,tot;
	void rebuild(int u,int fa){
		register int i,last=u;top=0;
		for(i=head[u];i;i=e[i].next){
			int v=e[i].to;if(v==fa) continue;
			son[++top]=e[i].to; 
		}
		for(i=1;i<=top-2;++i){
			Tree2::addedge(last,son[i]);
			Tree2::addedge(last,++tot);
			rev[last=tot]=u;val[last]=val[u];
		}
		if(top>1) Tree2::addedge(last,son[top-1]);
		if(top>0) Tree2::addedge(last,son[top]);
		for(i=head[u];i;i=e[i].next){
			int v=e[i].to;if(v==fa) continue;
			rebuild(v,u);
		}
	}
}

struct Query{
	int x,ord;
	Query(int x=0,int ord=0):x(x),ord(ord){};
	bool operator <(const Query &tmp)const{
		return x<tmp.x;
	}
}Q[MAXN];
lxl prt[MAXN];

int main(){
//	freopen("test.in","r",stdin);
	register int i,j;
	n=read();m=read();
	for(i=1;i<=n;++i) val[i].x=read(),rev[i]=i;
	for(i=1;i<=n;++i) val[i].y=read();
	for(i=1;i<=n;++i) color[i]=read();
	for(i=1;i<n;++i) Tree1::addedge(read(),read());
//	puts("");Tree1::debug(1,0);puts("");
	Tree1::tot=n;Tree1::rebuild(1,0);Tree2::tot=Tree1::tot;
//	puts("");Tree2::debug(1,0);puts("");
	Tree2::main();
	for(i=1;i<=m;++i) Q[i]=Query(read(),i);
	sort(Q+1,Q+m+1);j=1;
	for(i=1;i<=m;++i){
		while(j+1<=cnta&&1ll*Ans[j].x*Q[i].x+Ans[j].y<=1ll*Ans[j+1].x*Q[i].x+Ans[j+1].y) ++j;
		prt[Q[i].ord]=1ll*Ans[j].x*Q[i].x+Ans[j].y;
	}
	for(i=1;i<=m;++i) printf("%lld\n",prt[i]);
	return 0;
}
```

---

## 作者：xlpg0713 (赞：2)

简单题，但是我太菜了。树上路径问题考虑树分治，这里是点分治。

观察答案的形式为 $ka+b$ 的最大值，这个很简单就可以用凸包维护。

在点分治过程中，记每个点 $x$ 到根上路径的点权和为 $a_x,b_x$。对于一个根的每一颗子树，维护只有黑点和白点的凸包，答案（凸包）的形式是一个黑色凸包和一个白色凸包的闵可夫斯基和。

为了复杂度，这个东西可以合并果子，就是每次掏出最小的两颗子树做和，然后把凸包里的点扔进一个点集里，最后分别合并两个子树的黑白凸包。

最后对得到的点集求一个凸包，查询直接在上面二分或者扫一遍就行。

分析复杂度，闵可夫斯基和是线性的，瓶颈在于点分治过程中产生的点数，即刚才那个点分治上合并果子的复杂度。

不难发现（真的不难嘛）这个过程等价于在点分树上做启发式合并，故只有一只 $\log$。算上求凸包的排序需要两只 $\log$（不过双关键字排序可以线性做，理论更优是只带一只）。

以下的代码实现是 $O(n\log n\log(n\log n))$ 的。

diss 下造数据的，合并果子写成大根堆甚至能得 $88$ 分，调了若干个小时，结果是复杂度错了。

```cpp
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>
using pii = std::pair<int, int>;
using ll = long long; using ld = double;
const int N = 1e5 + 10; std::vector<int> g[N];
long long ans[N]; std::pair<int, int> q[N];
int n, m, nn, mx, rt, rc, ct[2], c[N], sz[N], vs[N];
struct nd{
    ll x, y; ll f(int k){return k * x + y;}
    nd operator+(const nd&a)const{return {x+a.x,y+a.y};}
    nd operator-(const nd&a)const{return {x-a.x,y-a.y};}
    bool operator>=(const nd&a)const{return x*a.y<=y*a.x;}
}rs[N<<5], t[2][N], w[N];
struct lrc{
    int n; std::vector<nd> a;
    lrc(){n=0;} void clear(){n=0,a.clear();}
    nd operator[](const int&x)const{return a[x];}
    void ins(const nd&x){
        while(n>1&&(x-a[n-1])>=(a[n-1]-a[n-2]))
            --n, a.pop_back(); ++n, a.push_back(x);
    }
}a[N<<1][2], tm;
lrc mg(const lrc&a, const lrc&b){
    tm.clear();
    for(int i = 0, j = 0; i < a.n || j < b.n;)
        if(i==a.n||(j<b.n&&b[j].x<a[i].x)) tm.ins(b[j++]);
        else if(j==b.n||a[i].x<b[j].x) tm.ins(a[i++]);
        else tm.ins(a[i].y>b[j].y?a[i]:b[j]),i++,j++;
	return tm;
}
lrc minkow(const lrc &a,const lrc &b){
    tm.clear(); if(!a.n || !b.n) return tm;
    tm.ins(a[0] + b[0]);
    for(int i = 0, j = 0; i < a.n - 1 || j < b.n - 1;)
        if(i==a.n-1) tm.ins(a[i] + b[++j]);
        else if(j==b.n-1) tm.ins(a[++i] + b[j]);
        else tm.ins((a[i+1]-a[i])>=(b[j+1]-b[j])?a[++i]+b[j]:a[i]+b[++j]);
    return tm;
}
void fd(int x, int fa){
    sz[x] = 1; int s = 0;
    for(auto v:g[x]) if(v != fa && !vs[v])
        fd(v, x), sz[x] += sz[v], s = std::max(s, sz[v]);
    s = std::max(s, nn - sz[x]); if(s < mx) mx = s, rt = x;
}
void dfs(int x, int fa, nd p){
    t[c[x]][++ct[c[x]]] = p;
    for(auto v:g[x]) if(v != fa && !vs[v]) dfs(v, x, p + w[v]);
}
inline bool cmp(const nd&a,const nd&b){return a.x==b.x?a.y<b.y:a.x<b.x;}
void bd(int u){
    a[u][0].clear(); a[u][1].clear();
    std::sort(t[0] + 1, t[0] + ct[0] + 1, cmp);
    std::sort(t[1] + 1, t[1] + ct[1] + 1, cmp);
    for(int i = 1; i <= ct[0]; i++) a[u][0].ins(t[0][i]);
    for(int i = 1; i <= ct[1]; i++) a[u][1].ins(t[1][i]);
}
void calc(int x, int y, int u){
    tm = minkow(a[x][0], a[y][1]);
    for(int i=0;i<tm.n;i++) rs[++rc]=tm[i]+w[u];
    tm = minkow(a[x][1], a[y][0]);
    for(int i=0;i<tm.n;i++) rs[++rc]=tm[i]+w[u];
}
void div(int x){
    vs[x] = 1; std::priority_queue<pii, std::vector<pii>, std::greater<pii>> q;
    for(auto v:g[x]) if(!vs[v]){
        ct[0] = ct[1] = 0, dfs(v, x, w[v]);
        bd(v), q.push({a[v][0].n+a[v][1].n, v});
    } int o = n; while(q.size() > 1){
        std::pair<int, int> xx, yy;
        xx = q.top(); q.pop(); yy = q.top(); q.pop();
        calc(xx.second, yy.second, x); ++o;
        a[o][0] = mg(a[xx.second][0], a[yy.second][0]);
        a[o][1] = mg(a[xx.second][1], a[yy.second][1]);
        q.push({a[o][0].n + a[o][1].n, o});
    } if(!q.size()) return; int t = q.top().second; q.pop();
    if(c[x]) for(int i=0;i<a[t][0].n;i++) rs[++rc]=a[t][0][i]+w[x];
    if(!c[x])for(int i=0;i<a[t][1].n;i++) rs[++rc]=a[t][1][i]+w[x];
    for(auto v:g[x]) if(!vs[v]) nn=mx=sz[v], fd(v,x), div(rt);
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(0),std::cout.tie(0);
    std::cin >> n >> m;
    for(int i = 1; i <= n; i++) std::cin >> w[i].x;
    for(int i = 1; i <= n; i++) std::cin >> w[i].y;
    for(int i = 1; i <= n; i++) std::cin >> c[i];
    for(int i = 1, x, y; i < n; i++)
        std::cin >> x >> y,
        g[x].push_back(y), g[y].push_back(x);
    nn = mx = n, fd(1, 0), div(rt);
    std::sort(rs + 1, rs + rc + 1, cmp); tm.clear();
    for(int i = 1; i <= rc; i++) tm.ins(rs[i]);
    for(int i = 1, x; i <= m; i++)
        std::cin >> x, q[i] = {x, i};
    if(!tm.n){for(int i=1;i<=m;i++) puts("0"); exit(0);}
    std::sort(q + 1, q + m + 1);
    for(int i = 1, j = 0; i <= m; i++){
        auto [k, p] = q[i];
        while(j+1<tm.n && tm[j+1].f(k)>=tm[j].f(k))
            j++; ans[p] = tm[j].f(k);
    } for(int i = 1; i <= m; i++) std::cout << ans[i] << '\n';
}
```

---

## 作者：sqrtqwq (赞：1)

~~截图选老婆~~

我们发现答案的形式是 $ka + b$，这个东西可以使用凸包维护。然后我们发现询问的答案和树上的路径有关，可以想到用点分治维护。

然后再点分治的过程中记录每一个点到根节点的点权和为 $a_x,b_x$。对于每一个根的每一个子树，我们都维护黑点和白点的凸包，那么答案就是这两个凸包的闵可夫斯基和。然后我们有三种维护方法。

1. 先不考虑两个点在同一棵子树的情况计算最后再容斥掉。
2. 逐子树加入，即考虑每棵子树对之前加入的子树的贡献。
3. 利用合并果子，每次取出 size 最小的两个凸包，然后把两个合并起来。那么复杂度是 $\log$ 的。

明显的，前两种的维护都十分复杂，我们在此选择第三种。然后求出最终的凸包后直接二分求出最大值即可。

---


# 【MX-X1-T5】「KDOI-05」简单的树上问题

## 题目背景

原题链接：<https://oier.team/problems/X1E>。

## 题目描述

小 S 有一棵 $n$ 个点的树。每个点上有一个灯泡。

小 S 决定进行 $k$ 次闪灯操作。执行闪灯操作时，他会用电脑主机给每个灯泡发送一次闪灯操作。

然而，小 S 的灯泡是劣质品，只有一部分的灯泡可以收到小 S 的闪灯操作。具体地，第 $j$ 个点上的灯泡有 $p_{i,j}$ 的概率收到小 S 的第 $i$ 次闪灯操作。

好在，小 S 的不同灯泡之间有信息传递功能。具体地，如果一个灯泡在两个收到信息的灯泡的树上最短路径上，这个灯泡也能执行闪灯操作（当然，收到信息的灯泡会执行闪灯操作）。

定义一个灯泡 $i$ 的美丽度为 $a_{i,S}$，其中 $S$ 为这个灯泡执行闪灯操作的操作集合。

定义整棵树的美丽度为每个灯泡美丽度的乘积。求整棵树美丽度的期望，对 $998244353$ 取模。

## 说明/提示

**【样例解释 \#1】**

| 收到信息灯泡集合 | 灯泡美丽度 | 树美丽度 |
|:--:|:--:|:--:|
| $\emptyset$ | $1,1,1$ | $1$ |
| $\{1\}$ | $2,1,1$ | $2$ |
| $\{2\}$ | $1,3,1$ | $3$ |
| $\{3\}$ | $1,1,4$ | $4$ |
| $\{1,2\}$ | $2,3,1$ | $6$ |
| $\{1,3\}$ | $2,3,4$ | $24$ |
| $\{2,3\}$ | $1,3,4$ | $12$ |
| $\{1,2,3\}$ | $2,3,4$ | $24$ |

故美丽度的期望是 $\frac{1+2+3+4+6+24+12+24}{8}=\frac{19}{2}$，对 $998244353$ 取模后为 $499122186$。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $k\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $5$ | $20$ | $1$ | 无 |
| $2$ | $10$ | $100$ | $2$ | 第 $i$ 条边连接 $i$ 与 $i+1$ 号节点 |
| $3$ | $5$ | $100$ | $8$ | $p_{i,j}=0$ 或 $p_{i,j}=1$ |
| $4$ | $5$ | $100$ | $8$ | $a_{i,S}=[S=\{1,2,\dots,k\}]$ |
| $5$ | $20$ | $100$ | $8$ | 第 $i$ 条边连接 $i$ 与 $i+1$ 号节点 |
| $6$ | $15$ | $100$ | $6$ | 无 |
| $7$ | $15$ | $100$ | $7$ | 无 |
| $8$ | $10$ | $50$ | $8$ | 无 |
| $9$ | $15$ | $100$ | $8$ | 无 |

对于 $100\%$ 的数据：$1\leq n\leq100$，$1\leq k\leq8$，$1\leq u,v\leq n$，保证给出数据为一棵树，保证其他输入数据均为 $[0,998244353)$ 中的整数。

## 样例 #1

### 输入

```
3 1
1 2
2 3
499122177 499122177 499122177
1 2
1 3
1 4```

### 输出

```
499122186```

## 样例 #2

### 输入

```
10 2
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
1 1 4 5
1 4 1 9
1 9 8 1
0 1 1 4
5 1 4 1
9 1 9 8
1 0 9 9
8 2 4 4
3 5 3 1
2 3 4 5```

### 输出

```
497209006```

# 题解

## 作者：cyffff (赞：7)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10717)
## 题意
给你一颗 $n$ 个结点的树，有 $k$ 次操作，第 $i$ 次操作：
- 每个点初始都处于未激活状态；
- 以 $p_{i,j}$ 的概率激活点 $j$；
- 对于每个未激活的点 $i$，如果存在激活的结点 $j,k$ 且 $i$ 在 $j$ 到 $k$ 的路径上，则 $i$ 也会被激活。

给出 $v_{i,s}$ 表示当 $i$ 在 $s$ 这些操作被激活时的权值。对于某种可能的情况，记 $S_i$ 为结点 $i$ 在哪些操作中被激活了，整棵树的权值为 $\prod_{i=1}^nv_{i,S_i}$。请求出这棵树的权值的期望。

$n\le 100$，$k\le 8$。
## 思路

考虑 $k=1$，这和[上一场梦熊周赛的 C](https://www.luogu.com.cn/problem/P10674) 完全一致，令 $f_{u,0/1/2}$ 分别表示「$u$ 子树内没有结点被激活」/「$u$ 子树内有结点被激活且钦定子树外没有结点被激活」/「$u$ 子树内有结点被激活且钦定子树外有结点被激活」时 $u$ 子树内的期望权值。

和该题一样，我们在合并子树的过程中需要将仅有一个子树内有结点被激活与有大于等于两个子树内有结点被激活分开讨论。不妨为后者新建一个状态 $3$，注意到状态 $3$ 由若干 $0/2$ 状态合并而来，此时子树外是否有结点被激活均可。令 $t_{0/1/2/3}$ 分别表示已经合并的子树的信息，转移如下，其中 $(a,b)\to c$ 表示 $t_a\times f_{v,b}\to t_c'$：

- $(0,0)\to 0$；
- $(0,1),(1,0)\to1$；
- $(0,2),(2,0)\to2$；
- $(2,2),(3,0/2)\to3$；

我们再考虑 $u$ 是否在初始时被激活，其中 $(a,b)\to c$ 表示 $a$ 状态在结点 $u$ 的初始激活状态为 $b$ 时转移到 $c$ 状态，将概率乘进去即可：
- $(0/1/2/3,0)\to 0/1/2/3$；
- $(0/2/3,1)\to 3$；

将 $0/1$ 状态乘上 $v_{u,0}$，$2/3$ 状态乘上 $v_{u,1}$，再将 $3$ 状态分别加给 $1/2$ 状态，$u$ 结点就计算完毕了。
****
考虑 $k$ 更大的情况。注意到直接给定了 $2^k$ 种情况的权值，提示我们将 $k$ 次操作一同考虑。

将 $k$ 次操作中 $u$ 的状态压缩，状态改写为 $f_{u,S}$，表示 $u$ 子树 $k$ 次操作下状态分别为 $S$ 时的期望权值，其中 $S\in \{0,1,2\}^k$，$t_{T},T\in\{0,1,2,3\}^k$ 同理。

于是我们可以得到一个非常暴力的做法：

- 加入一个子树，枚举 $k$ 次操作的转移，转移共有 $8$ 种，复杂度为 $O(8^k)$；
- 决定 $u$ 的初始激活状态，直接枚举 $u$ 初始激活的操作集合，复杂度为 $O(8^k)$；
- 将 $3$ 状态传至 $1/2$ 状态，直接枚举每个 $3$ 传给 $1$ 还是 $2$，复杂度为 $O(8^k)$。

总复杂度 $O(n8^k)$，无法通过。

不妨从看起来比较好下手的第三部分开始优化，我们注意到**这是一个类似高维后缀和的操作，我们可以类似地逐位下传**，复杂度降至 $O(k4^k)$。第二部分也可通过类似的思路逐位加入 $u$ 的初始激活信息做到 $O(k4^k)$。

接下来就是最为困难的第一部分了，我们依旧尝试用类似的思路解决。注意到 $0/2/3$ 状态的和是好求的，因为这些状态不会向外转移。由此我们考虑 **$3$ 状态的信息可由 $0/2/3$ 减去 $0/2$ 得到**。我们转移前使用高维前缀和将每一维为 $0/2$ 的状态加给 $3$ 状态，只考虑 $0/1/2$ 的 $5$ 种转移和 $(3,3)\to 3$ 共 $6$ 种转移，转移完我们便得到了 $0,1,2$ 状态的真实值和 $0/2/3$ 状态的和，将后者减去 $0,2$ 状态的值便可得到 $3$ 状态的真实值。单次高维前缀和/差分为 $O(k4^k)$，单次转移为 $O(6^k)$。

至此，我们将总复杂度优化至 $O(n6^k+nk4^k)$，可以通过。

可配合代码理解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=100+10,K=10,S=256+10,U=65536+10,T=1679616+10,mod=998244353;
inline int add(int x,int y){ return x+y>=mod?x+y-mod:x+y; }
inline void inc(int &x,int y){ x=add(x,y); }
inline void dec(int &x,int y){ x=add(x,mod-y); }
int n,k,u1,u2,u3,p[N][K],v[N][S],dp[N][U],tmp[U],tmq[U];
vector<int>a[N];
struct node{
	int a,b,c;
}stk[T];
inline void dfs(int d,int a,int b,int c){//预处理 6^k 种转移
	if(d==k){
		stk[u3++]={a,b,c};
		return ;
	}
	dfs(d+1,a|(0<<d*2),b|(0<<d*2),c|(0<<d*2));
	dfs(d+1,a|(0<<d*2),b|(1<<d*2),c|(1<<d*2));
	dfs(d+1,a|(1<<d*2),b|(0<<d*2),c|(1<<d*2));
	dfs(d+1,a|(0<<d*2),b|(2<<d*2),c|(2<<d*2));
	dfs(d+1,a|(2<<d*2),b|(0<<d*2),c|(2<<d*2));
	dfs(d+1,a|(3<<d*2),b|(3<<d*2),c|(3<<d*2));
}
inline void PFS(int *a){//将 0/2 加给 3 状态的高维前缀和
	for(int i=0;i<k;i++)
		for(int j=0;j<u2;j++){
			int c=j>>i*2&3;
			if(c==0||c==2) inc(a[j|(3<<i*2)],a[j]);
		}
}
inline void PFD(int *a){//将 0/2 从 3 状态中删去的高维前缀差分
	for(int i=0;i<k;i++)
		for(int j=0;j<u2;j++){
			int c=j>>i*2&3;
			if(c==0||c==2) dec(a[j|(3<<i*2)],a[j]);
		}
}
inline void dfs(int x,int fa){
	for(auto t:a[x]){
		if(t==fa) continue;
		dfs(t,x);
	}
	tmp[0]=1;
	PFS(tmp);
	for(auto t:a[x]){
		if(t==fa) continue;
		PFS(dp[t]);
		for(int i=0;i<u3;i++)
			inc(tmq[stk[i].c],1ll*tmp[stk[i].a]*1ll*dp[t][stk[i].b]%mod);
		for(int i=0;i<u2;i++)
			tmp[i]=tmq[i],tmq[i]=0;
	}
	PFD(tmp);
	for(int i=0;i<k;i++)//第二部分
		for(int j=u2-1;j>=0;j--){
			int c=j>>(i*2)&3;
			if(c==0||c==2) inc(tmp[j|(3<<i*2)],1ll*tmp[j]*p[x][i]%mod);
			if(c==0||c==1||c==2) tmp[j]=1ll*tmp[j]*(1-p[x][i]+mod)%mod;
		}
	for(int i=0;i<u2;i++){
		int t=0;
		for(int j=0;j<k;j++){
			int c=i>>(j*2)&3;
			if(c==2||c==3) t|=1<<j;
		}
		tmp[i]=1ll*tmp[i]*v[x][t]%mod;
	}
	for(int i=0;i<k;i++)//第三部分
		for(int j=0;j<u2;j++){
			int c=j>>(i*2)&3;
			if(c==1||c==2) inc(tmp[j],tmp[j|(3<<i*2)]);
			if(c==3) tmp[j]=0;
		}
	for(int i=0;i<u2;i++)
		dp[x][i]=tmp[i],tmp[i]=0;
}
int main(){
	n=read(),k=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		a[u].push_back(v),a[v].push_back(u);
	}
	for(int i=0;i<k;i++)
		for(int j=1;j<=n;j++)
			p[j][i]=read();
	u1=1<<k,u2=1<<k*2;
	for(int i=1;i<=n;i++)
		for(int j=0;j<u1;j++)
			v[i][j]=read();
	dfs(0,0,0,0);
	dfs(1,1);
	int s=0;
	for(int i=0;i<u2;i++){
		bool fl=0;
		for(int j=0;j<k;j++){
			int c=i>>(j*2)&3;
			if(c==2||c==3) fl=1;
		}
		if(!fl) inc(s,dp[1][i]);
	}
	write(s);
	flush();
}
```

---

## 作者：Purslane (赞：4)

# Solution

非常好的题目！和正解差一个神秘的 $\rm FWT$！

-----

考虑树形 DP。如果你做了上一场[梦熊周赛的 T3](https://www.luogu.com.cn/problem/P10674)，你会发现他们惊人的相似：每次闪灯，对每个点记录状态 $0/1/2$ 分别表示子树内没有闪灯的点、子树内有闪灯的点且当前节点闪灯、子树内有闪灯的点且子树外节点不能有闪灯。

由于有多次闪灯，可以考虑将不同的闪灯情况状态压缩。

如何转移？首先注意到，对于一次闪灯，如果 $u$ 存在两棵子树都是状态 $1$，那么 $u$ 节点一定闪灯；如果 $u$ 只有一棵子树状态为 $1$，那么 $u$ 必须以 $p_u$ 的概率选中才能闪灯。因此你还要新增状态 $3$（只在转移的过程中使用）表示子树内是否有 $2$ 棵以上是状态 $1$。

因此我们维护 $Dp_{u,\{0,1,2,3\}^k}$。初始有 $Dp_{u,0}=1$。新加入节点 $v$ 时和 $dp_{v,\{0,1,2\}^k}$ 作如下卷积：

对于每一位独立考虑，有（下面的都是“$u$ 的状态，$v$ 的状态，结果状态”的顺序）：

- $(0,0) \to 0$；
- $(1,0) \to 1$；
- $(2,0) \to 2$；
- $(3,0) \to 3$；
- $(0,1) \to 1$；
- $(1,1) \to 3$；
- $(3,1) \to 3$；
- $(0,2) \to 2$。

处理 $Dp_{u,\{0,1,2,3\}^k}$ 后，考虑 $u$ 节点的闪灯情况。每一维，如果闪灯，$0 \to 3$、$1 \to 3$、$3 \to 3$、$2 \to -1$（不合法）；如果不闪灯，$0 \to 0$、$1 \to 1$、$2 \to 2$、$3 \to 3$。这些转移加到 $dp_{u,\{0,1,2,3\}^k}$ 上。

然后将 $a_{u,\{0,1\}^k}$ 的优美值乘到 $dp_{u,\{0,1,2,3\}^k}$ 中。

这一步结束之后，可以将 $3$ 状态转化为 $1$ 或 $2$，得到 $dp_{u,\{0,1,2\}^k}$。

这样得到了 $O(n (8^k+k 4^k))$ 的做法，实现的好可以获得 $75$ 分。

------

着手优化卷积。

如果我们只考虑结果是 $0/1/2$ 的转移，那么只需要 $O(5^k)$ 就可以完成单次卷积。

那么结果是 $3$ 的部分，就可以用结果是 $0/1/3$ 的部分减去结果是 $0/1$ 的来计算。

因此考虑做一种类似 $\rm FWT$ 的操作：先将 $0/1$ 状态钦定一部分变成 $3$，然后只处理 $0/1/2$ 之间的转移和 $(3,3) \to 3$ 的转移，再做 $\rm DFWT$ 将 $3$ 减去 $0/1$ 状态。

这样得到了 $O(n (6^k+k 4^k))$ 的做法，足以通过本题。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100+10,MAX4=65536+10,MOD=998244353,MAXK=2e7+10;
int n,k,ans,dp[MAXN][MAX4],gain[MAX4],tot;
ll p[MAXN][10],a[MAXN][300];
pair<pair<int,int>,int> trans[MAXK];
void dfss(int dep,int x,int y,int z) {
	if(dep==k) return trans[++tot]={{x,y},z},void();	
	dfss(dep+1,(x<<2)|0,(y<<2)|0,(z<<2)|0);
	dfss(dep+1,(x<<2)|1,(y<<2)|0,(z<<2)|1);
	dfss(dep+1,(x<<2)|2,(y<<2)|0,(z<<2)|2);
	dfss(dep+1,(x<<2)|0,(y<<2)|1,(z<<2)|1);
	dfss(dep+1,(x<<2)|0,(y<<2)|2,(z<<2)|2);
	dfss(dep+1,(x<<2)|3,(y<<2)|3,(z<<2)|3);
	return ;
}
int tmp[MAX4];
vector<int> G[MAXN];
void fwt(int *f,int op) {
	if(op==1) {
		ffor(i,1,k) {
			ffor(j,0,(1<<k+k)-1) {
				int v=(j>>(i+i-2))&3;
				if(v==0) f[j+(1<<i+i-2)+(1<<i+i-1)]=(f[j+(1<<i+i-2)+(1<<i+i-1)]+f[j])%MOD;
				else if(v==1) f[j+(1<<i+i-1)]=(f[j+(1<<i+i-1)]+f[j])%MOD;
			}
		}
	}
	else {
		ffor(i,1,k) {
			roff(j,(1<<k+k)-1,0) {
				int v=(j>>(i+i-2))&3;
				if(v==3) f[j]=((f[j]-f[j-(1<<i+i-2)-(1<<i+i-1)])%MOD-f[j-(1<<i+i-1)])%MOD;
			}
		}
	}
	return ;
}
void dfs(int u,int f) {
	dp[u][0]=1;
	for(auto v:G[u]) if(v!=f) {
		dfs(v,u);
		fwt(dp[u],1),fwt(dp[v],1);
		memset(tmp,0,sizeof(tmp));
		ffor(i,1,tot) {
			auto pr=trans[i];
			int x=pr.first.first,y=pr.first.second,to=pr.second;
			if(dp[u][x]) tmp[to]=(tmp[to]+1ll*dp[u][x]*dp[v][y])%MOD;	
		}
		fwt(tmp,-1);
		memcpy(dp[u],tmp,sizeof(tmp));
	}
	ffor(i,1,k) {
		memset(tmp,0,sizeof(tmp));
		ffor(j,0,(1<<k+k)-1) {
			int v=(j>>(i+i-2))&3;
			if(v==0) {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j]*(1-p[u][i]))%MOD;
				nw=j+(1<<(i+i-1))+(1<<(i+i-2));
				tmp[nw]=(tmp[nw]+dp[u][j]*p[u][i])%MOD;
			}
			else if(v==1) {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j]*(1-p[u][i]))%MOD;
				nw=j+(1<<(i+i-1));
				tmp[nw]=(tmp[nw]+dp[u][j]*p[u][i])%MOD;
			}
			else if(v==2) {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j]*(1-p[u][i]))%MOD;
			}
			else {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j])%MOD;
			}
		}
		memcpy(dp[u],tmp,sizeof(tmp));
	}
	ffor(i,0,(1<<k+k)-1) dp[u][i]=dp[u][i]*a[u][gain[i]]%MOD;
	ffor(i,1,k) {
		memset(tmp,0,sizeof(tmp));
		ffor(j,0,(1<<k+k)-1) {
			int v=(j>>(i+i-2))&3;
			if(v==0) {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j])%MOD;
			}
			else if(v==1) {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j])%MOD;
			}
			else if(v==2) {
				int nw=j;
				tmp[nw]=(tmp[nw]+dp[u][j])%MOD;
			}
			else {
				int nw=j-(1<<(i+i-1));
				tmp[nw]=(tmp[nw]+dp[u][j])%MOD;
				nw=j-(1<<(i+i-2));
				tmp[nw]=(tmp[nw]+dp[u][j])%MOD;
			}
		}
		memcpy(dp[u],tmp,sizeof(tmp));
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	dfss(0,0,0,0);
	ffor(i,1,n-1) {
		int u,v;
		cin>>u>>v;
		G[u].push_back(v),G[v].push_back(u);	
	}
	ffor(i,1,k) ffor(j,1,n) cin>>p[j][i];
	ffor(i,1,n) ffor(s,0,(1<<k)-1) cin>>a[i][s];
	ffor(i,0,(1<<(k+k))-1) {
		ffor(j,0,k-1) {
			int psl=(i>>(j+j))&3;
			if(psl==1||psl==3) gain[i]|=(1<<j);
		}
	}
	dfs(1,0);
	ffor(i,0,(1<<(k+k))-1) {
		int flg=0;
		ffor(j,1,k) {
			int v=(i>>(j+j-2))&3;
			if(v!=0&&v!=2) flg=1;
		}
		if(flg==1) continue ;
		ans=(ans+dp[1][i])%MOD;
	}
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：Harry27182 (赞：2)

好神仙的题目。赛时胡了一个状态和转移都和官解不同的做法，得到了 $O(n10^m)$ 的优秀复杂度。卡了一场常卡进了 $75$ 分。这个做法和官解关系不大，并且很难进行最后的优化部分，所以在此不再赘述。

首先考虑 $k=1$ 的情况。考虑记录一些状态能够描述子树内的选择方案，$0$ 表示整个子树没有被覆盖过，$1$ 表示子树内部有点被覆盖过并且子树外的点还能被覆盖，$2$ 表示子树内部有点被覆盖过并且子树外的点不能被覆盖了。考虑转移，需要把转移描述为只和 $u,v$ 有关的形式才能较为简单的扩展到 $k\neq 1$ 的情况。发现对于 $1\rightarrow 2$ 的转移，很难描述为 $u,v$ 的形式，因为需要出现两个子树为 $1$ 或者根节点被选择才能转移到 $2$。所以考虑记录辅助状态 $3$ 表示出现过至少 $2$ 次 $1$ 的方案。那么转移有以下 $8$ 种：

$$(0,0)\rightarrow 0$$
$$(0,1)\rightarrow 1 \ \ (1,0)\rightarrow 1$$
$$(0,2)\rightarrow 2 \ \ (2,0)\rightarrow 2 $$
$$(3,0)\rightarrow 3 \ \ (3,1)\rightarrow 3 $$
$$(1,1)\rightarrow 3$$

上面没有出现过的转移为不合法或者不存在对应状态。这么转移之后再考虑和根节点是否选择合并的转移，那么有：

$$(0,0)\rightarrow 0 \ \ (1,0)\rightarrow 1 \ \ (2,0)\rightarrow 2 \ \ (3,0)\rightarrow 3 \ \ $$

$$(0,1)\rightarrow 3 \ \ (1,1)\rightarrow3 \ \ (3,1)\rightarrow 3 \ \ $$

转移的同时计入 $p,a$ 两个数组的贡献。最后将 $3$ 状态放到 $1,2$ 两种状态即可。因为 $3$ 状态对应的状态可以封口也可以不封口。复杂度 $O(n)$。

考虑对于 $k\neq 1$ 的情况，每一位暴力枚举上面的 $8$ 种转移，第一部分的转移复杂度是 $O(8^k)$ 的。对于复合根节点情况的部分，暴力枚举根节点状态显然不优，可以类似 FMT 的对每一位依次进行变换，也就是逐位枚举根节点状态并处理这一位变换后的位置。复杂度为 $O(k4^k)$。对于 $3$ 状态的下放可以用类似的做法也做到 $O(k4^k)$。复杂度 $O(n(8^k+k4^k))$，视常数可以获得 $45\sim 85$ 分。

考虑优化，目前的瓶颈在于 $O(8^k)$ 的部分。一个很神秘的做法是考虑到如果没有辅助状态 $3$，那么转移只有 $O(5^k)$。所以考虑枚举儿子的一些位置的状态钦定为 $3$，由于对于 $3$ 的转移是和 $0/1$ 复合之后仍然为 $3$，所以为 $3$ 的位可以让它的值为对应位为 $0/1$ 的和。类似 OR 卷积的 FWT，经过一次正变换之后为 $3$ 的位置真实值可以为 $0$ 或 $1$。然后对变换之后的部分进行 $O(5^k)$ 的转移，但是多了 $3$ 的状态，由于经过了变换，只需要加入 $(3,3)\rightarrow 3$ 的转移。这部分转移的复杂度是 $O(6^k)$ 的。对于转移之后 $3$ 的位置，他们是从 $(0/1,0/1)$ 转移过来的，所以真实值可能是 $0/1/3$，所以要进行一次类似 OR 卷积的 IFWT 让他变成真实值为 $3$ 的值。FWT 和 IFWT 的复杂度是 $O(k4^k)$，所以总的复杂度就是 $O(n(6^k+k4^k))$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{int v,nxt;}e[205];
int n,m,u,v,cnt,h[105],w[105][256],p[105][8],dp[105][1<<16],num,tmp[1<<16];
void add(int u,int v){e[++cnt]={v,h[u]};h[u]=cnt;}
const int mod=998244353;
void Add(int &x,int y){x=(x+y>=mod?x+y-mod:x+y);}
struct node{int x,y,z;}go[2000005];
void init(int k,int x,int y,int z)
{
	if(k==m){go[++num]={x,y,z};return;}
	init(k+1,x,y,z);
	init(k+1,x,y|(1<<(k<<1)),z|(1<<(k<<1)));
	init(k+1,x|(1<<(k<<1)),y,z|(1<<(k<<1)));
	init(k+1,x|(2<<(k<<1)),y,z|(2<<(k<<1)));
	init(k+1,x,y|(2<<(k<<1)),z|(2<<(k<<1)));
	init(k+1,x|(3<<(k<<1)),y|(3<<(k<<1)),z|(3<<(k<<1)));
}
void fwt(int *a)
{
	for(int i=0;i<m;i++)
	{
		for(int s=0;s<(1<<(m<<1));s++)
		{
			int c=(s>>(i<<1))&3;
			if(c==0)Add(a[s+(3<<(i<<1))],a[s]);
			else if(c==1)Add(a[s+(2<<(i<<1))],a[s]); 
		}
	}
}
void ifwt(int *a)
{
	for(int i=0;i<m;i++)
	{
		for(int s=0;s<(1<<(m<<1));s++)
		{
			int c=(s>>(i<<1))&3;
			if(c==3)Add(a[s],mod-a[s-(3<<(i<<1))]),Add(a[s],mod-a[s-(2<<(i<<1))]);
		}
	}
}
void dfs(int u,int fa)
{
	dp[u][0]=1;
	for(int i=h[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa)continue;
		dfs(v,u);
		for(int s=0;s<(1<<(m<<1));s++)tmp[s]=dp[u][s],dp[u][s]=0;
		fwt(tmp);fwt(dp[v]);
		for(int s=1;s<=num;s++)Add(dp[u][go[s].z],1ll*tmp[go[s].x]*dp[v][go[s].y]%mod);
		ifwt(dp[u]);
	}
	for(int i=0;i<m;i++)
	{
		for(int s=0;s<(1<<(m<<1));s++)tmp[s]=dp[u][s],dp[u][s]=0;
		for(int s=0;s<(1<<(m<<1));s++)
		{
			int c=(s>>(i<<1))&3;
			if(c==0)
			{
				Add(dp[u][s],1ll*tmp[s]*(mod+1-p[u][i])%mod);
				Add(dp[u][s|(3<<(i<<1))],1ll*tmp[s]*p[u][i]%mod);
			}
			else if(c==1)
			{
				Add(dp[u][s],1ll*tmp[s]*(mod+1-p[u][i])%mod);
				Add(dp[u][s|(2<<(i<<1))],1ll*tmp[s]*p[u][i]%mod);
			}
			else if(c==2)
			{
				Add(dp[u][s],1ll*tmp[s]*(mod+1-p[u][i])%mod);
			}
			else 
			{
				Add(dp[u][s],tmp[s]);
			}
		}
	}
	for(int s=0;s<(1<<(m<<1));s++)
	{
		int ns=0;
		for(int i=0;i<m;i++)if((s>>(i<<1))&1)ns|=(1<<i);
		dp[u][s]=1ll*dp[u][s]*w[u][ns]%mod;
	}
	for(int i=0;i<m;i++)
	{
		for(int s=0;s<(1<<(m<<1));s++)tmp[s]=dp[u][s],dp[u][s]=0;
		for(int s=0;s<(1<<(m<<1));s++)
		{
			if(((s>>(i<<1))&3)==3)
			{
				Add(dp[u][s-(1<<(i<<1))],tmp[s]);
				Add(dp[u][s-(2<<(i<<1))],tmp[s]); 
			}
			else Add(dp[u][s],tmp[s]);
		}
	}
}
int main()
{
	//freopen("e.in","r",stdin);
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<n;i++)
	{
		cin>>u>>v;
		add(u,v);add(v,u);
	}
	for(int i=0;i<m;i++)for(int j=1;j<=n;j++)cin>>p[j][i];
	for(int i=1;i<=n;i++)
	{
		for(int s=0;s<(1<<m);s++)cin>>w[i][s];
	}
	init(0,0,0,0);dfs(1,0);
	int ans=0;
	for(int s=0;s<(1<<(m<<1));s++)
	{
		int flag=1;
		for(int i=0;i<m;i++)flag&=(((s>>(i<<1))&3)!=1);
		if(flag)Add(ans,dp[1][s]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lzytag (赞：1)

讲一个神秘的（如）爆标做法。复杂度为 $O(n4^kk^2)$

首先定 $1$ 为根，考虑 dp，$f_{u,S1,S2}$ 代表在 $u$ 的子树里，$S1$ 集合中的虚树经过 $u\rightarrow fa_u$ 的边，$S2$ 集合中的虚树完全在 $u$ 的子树内，此时的概率与 $u$ 子树中点的贡献的乘积。因为 $S1$ 与 $S2$ 无交集，所以 $(S1,S2)$ 可以被状压成一个 $k$ 位三进制数。

接下来考虑怎么合并一个点的所有子树，先不考虑 $u$ 这个节点是否被选择，发现我们对于第 $i$ 选点只有四种情况：$i$ 不在任何一个子树的 $(S1,S2)$ 中，$i$ 在恰好一个子树的 $S1$ 中，$i$ 在多于一个子树的 $S1$ 中，$i$ 恰好在一个子树的 $S2$ 中。我们把四种状态分别记为 $0/1/2/3$，用 $k$ 位四进制数状压，然后每次新加入一个子树进行合并，对每一位枚举转移情况，去掉不可能的转移可以做到 $O(n8^k)$。

考虑到**不存在**，**恰好一个**的条件总是比**多于一个**更好的，于是考虑把情况 $2$ 改写为存在一个子树的 $S1$ 中有 $i$，把这四个值求出来之后再用类似 iFMT 的方式逐位容斥回原本的形式，容斥中要对这一位为 $2$ 的值减去这一位为 $1$ 的值。

考虑这四个值怎么求，**恰好一个**的限制容易联想到子集卷积，而**存在**的限制有容易联想到或卷积。但这两者都提示我们去使用类似 FMT 的做法，同时使用子集卷积中占位多项式的思想。我们对于每一个四进制数的位置映射到一个占位多项式为 $h_Sx^{i}$，其中 $h_S$ 为 $S$ 位置当前的值，$i$ 为 $S$ 中 $1,3$ 的个数。卷积时先做一遍变体的 FMT，也就是枚举每一位，这一位为 $1/2/3$ 的分别加上这一位为 $0$ 的多项式，然后对位相乘，最后 iFMT 回去。

接下来考虑如何把 $f_u$ 数组改成卷积上 $g$ 的形式。显然对于 $g_S$，考虑 $S$ 每一位，若第 $i$ 位为 $0$ 则不在 $S1,S2$ 中，若为 $3$ 则在 $S2$ 中，否则在 $S1$ 中。

最后考虑如何把卷积出来的结果转化为到 $f$ 的值。也就是如何确定 $u$ 出现的集合，以及如何给一棵虚数“封顶”，前者还是可以逐位确定，注意这时 $u$ 上的 $1$ 可以直接将情况 $0$ 转化为情况 $2$，后者能封顶当且仅当处于情况 $2$，然后就做完了。

为什么说（如）爆标呢？因为 $k \le 8$，$O(4^kk^2)$ 的子集卷积好像还真跑不过只 FMT 状态 $2$，剩下部分暴力 $O(6^k)$ 子集卷积，甚至要精细实现才能通过本题。该出加强版 $k \le 10$ 同时开大时限了（误）。

细节没懂的可以看代码。

[提交记录 $O(n4^kk^2)$](https://www.luogu.com.cn/record/218676206)

[提交记录 $O(n6^k)$](https://www.luogu.com.cn/record/218669821)

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10717)

**题目大意**

> 给定 $n$ 个点的树，以及 $k$ 个集合，第 $i$ 个集合包含第 $j$ 个点包含的概率是 $p_{i,j}$。
>
> 定义 $T_i$ 表示第 $i$ 个集合对应的斯坦纳树，第 $u$ 个点的权值为 $f_{u,S}$，其中 $S=\{i\mid u\in T_i\}$。
>
> 求所有点权值乘积的期望。
>
> 数据范围：$n\le 100,k\le 8$。

**思路分析**

考虑 $k=1$ 如何做，对于该集合，考虑 $u$ 与其的关系：

- 状态 $0$：$u$ 子树中没有集合中的点。
- 状态 $1$：$u$ 子树中有集合中的点，且钦定 $u$ 子树外还有集合中的点（即 $u\in T_1$）。
- 状态 $2$：$u$ 子树中有集合中的点，且钦定 $u$ 子树外没有集合中的点（即 $u\not\in T_1$）。
- 状态 $3$：合并子树状态时的中间状态，表示仅考虑 $u$ 子树内节点，已经有 $u\in T_1$，即 $u$ 被选或 $u$ 至少有两个儿子是状态 $1$，没有儿子是状态 $2$。

根据如上的定理，我们可以列出所有转移 $x\to^yz$ 表示 $u$ 当前状态为 $x$，加上某个状态为 $y$ 的子树后状态为 $z$。

那么所有转移共 $8$ 种：$0\to^0 0,0\to^1 1,0\to ^22,0\to^33,1\to^01,1\to^13,2\to^02,3\to ^03$。

求出当前节点状态后，考虑 $u$ 是否直接被该集合包含，如果是的话，那么 $0,1,3$ 状态都转移成 $3$，否则不变。

然后如果状态为 $1/3$，那么说明 $u\in T_1$ 否则 $u\not\in T_1$，乘上对应情况的权值。

最后我们可以考虑 $T_1$ 是否在 $u$ 处结束，即状态 $3$ 转移到 $1/2$。

那么原问题可以直接 dp，设 $f_{u,\{0,1,2\}^k}$ 表示 $k$ 个集合对 $u$ 的状态，如果我们暴力枚举每一位的转移，一共能得到 $8^k$ 种，直接暴力处理，复杂度 $\mathcal O(n8^k)$ 无法通过。

但我们注意到 $\{0,1,3\}$ 中的所有状态加上状态 $0/1$ 依然在 $\{0,1,3\}$ 中。

因此如果我们定义状态 $3$ 为实际的 $\{0,1,3\}$ 三种状态之和，那么转移就只剩下了 $0\to^0 0,0\to^1 1,0\to ^22,1\to^012\to^02,3\to ^33$ 共 $6$ 种。

预处理出所有转移即可 $\mathcal O(6^k)$ 单次合并。

我们只要在每次将 $v$ 子树合并时提前把状态为 $0/1$ 的位转移到状态 $3$ 上即可，可以类似 FWT 逐位处理。

而还原求出原数组就用状态为 $3$ 的位减去状态为 $0/1$ 的方案数，做一个逆 FWT 的过程即可。

后面的几步转移都可以逐位处理做到 $\mathcal O(k4^k)$。

最终答案就是 $\sum f_{rt,\{0,2\}^k}$。

时间复杂度 $\mathcal O(n(6^k+k4^k))$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105,MOD=998244353;
vector <int> G[MAXN];
int n,k,val[MAXN][1<<8],pr[MAXN][8],F[MAXN][1<<16],g[1<<16],e[1<<16];
inline void add(int &x,int y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
inline void sub(int &x,int y) { x=(x>=y)?x-y:x+MOD-y; }
void fwt(int *z,bool ifwt) {
	for(int i=0;i<k;++i) for(int s=0;s<(1<<k*2);++s) if((s>>i*2&3)<2) {
		(ifwt?sub:add)(z[s|(3<<2*i)],z[s]);
	}
}
vector <array<int,3>> Q; //(0,0,0) (0,1,1) (1,0,1) (0,2,2) (2,0,2) (3,3,3)
void dfs(int u,int fz) {
	int *f=F[u]; f[0]=1,fwt(f,0);
	for(int v:G[u]) if(v^fz) {
		dfs(v,u),fwt(F[v],0);
		memset(g,0,sizeof(g));
		for(auto z:Q) g[z[2]]=(g[z[2]]+1ll*f[z[0]]*F[v][z[1]])%MOD;
		memcpy(f,g,sizeof(g));
	}
	fwt(f,1);
	for(int i=0;i<k;++i) {
		memset(g,0,sizeof(g));
		for(int s=0;s<(1<<k*2);++s) {
			g[s]=(g[s]+1ll*f[s]*(1+MOD-pr[u][i]))%MOD;
			if((s>>i*2&3)^2) g[s|(3<<i*2)]=(g[s|(3<<i*2)]+1ll*f[s]*pr[u][i])%MOD;
		}
		memcpy(f,g,sizeof(g));
	}
	for(int s=0;s<(1<<k*2);++s) f[s]=1ll*f[s]*val[u][e[s]]%MOD;
	for(int i=0;i<k;++i) for(int s=0;s<(1<<k*2);++s) if((s>>i*2&3)>2) {
		add(f[s^(1<<i*2)],f[s]),add(f[s^(2<<i*2)],f[s]),f[s]=0;
	}
}
signed main() {
	scanf("%d%d",&n,&k);
	for(int i=1,u,v;i<n;++i) scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	for(int j=0;j<k;++j) for(int i=1;i<=n;++i) scanf("%d",&pr[i][j]);
	for(int i=1;i<=n;++i) for(int s=0;s<(1<<k);++s) scanf("%d",&val[i][s]);
	vector <array<int,3>> I{{0,0,0},{0,1,1},{1,0,1},{0,2,2},{2,0,2},{3,3,3}};
	Q.push_back({0,0,0});
	for(int i=0;i<k;++i) {
		vector <array<int,3>> P;
		for(auto s:Q) for(auto z:I) {
			P.push_back({s[0]<<2|z[0],s[1]<<2|z[1],s[2]<<2|z[2]});
		}
		Q.swap(P);
	}
	for(int s=0;s<(1<<k*2);++s) for(int i=0;i<k;++i) e[s]|=(s>>i*2&1)<<i;
	dfs(1,0);
	int ans=0;
	for(int s=0;s<(1<<k*2);++s) if(!e[s]) add(ans,F[1][s]);
	printf("%d\n",ans);
	return 0;
}
```

---


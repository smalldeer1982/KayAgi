# 【MX-X5-T7】「GFOI Round 1」Der Richter

## 题目背景

原题链接：<https://oier.team/problems/X5H>。

---

> [Der Richter - Ωμεγα](https://www.bilibili.com/video/BV11SpberEjC/)

## 题目描述

我们首先给出关于本题的一些定义。

定义一个 $1 \sim n$ 的排列 $p_1, p_2, \ldots, p_n$ 是**好的**，当且仅当 $\exists k \in [1, n - 1], \max\limits_{i = 1}^k p_i = k$。

定义一个序列 $x_1, x_2, \ldots, x_k$ 是一个排列 $p_1, p_2, \ldots, p_n$ 的**交换方案**，当且仅当：

- $\forall 1 \le i \le k$，$1 \le x_i \le n - 1$ 且 $x_i$ 是整数；
- 对所有 $i = 1 \sim k$ **依次**执行交换 $p$ 中 $x_i$ 和 $x_i + 1$ 位置上的数的操作之后，$p$ 是**好的**。

特别地，序列 $x$ 可以为空，代表不进行任何交换操作。

定义一个序列 $x_1, x_2, \ldots, x_k$ 是一个排列 $p_1, p_2, \ldots, p_n$ 的**关键交换方案**，当且仅当：

- $x$ 是 $p$ 的一个**交换方案**；
- $x$ 是 $p$ 的所有**交换方案**中长度最小的。

定义 $f(p)$ 为排列 $p$ 的不同的**关键交换方案**的个数。

定义一个排列 $q$ 是另一个排列 $p$ 的一个**终态**，当且仅当：

- $p$ 的长度与 $q$ 相等；
- $q$ 是**好的**；
- 存在一个 $p$ 的**关键交换方案** $x_1, x_2, \ldots, x_k$，使得对所有 $i = 1 \sim k$ **依次**执行交换 $p$ 中 $x_i$ 和 $x_i + 1$ 位置上的数的操作之后，$p$ 与 $q$ 相同（即 $\forall 1 \le i \le |p|, p_i = q_i$）。

定义一个排列 $p$ 是**极好的**，当且仅当只存在**一个**排列 $q$，使得 $q$ 是 $p$ 的**终态**。

给定一个**质数** $P$ 和 $q$ 次询问，每次询问给定两个整数 $n, m$，你需要构造任意一个**极好的**长度为 $n$ 且 $f(p) \equiv m \pmod P$ 的 $1 \sim n$ 的排列 $p$，或报告无解。

本题将使用**自定义校验器**检查你构造的排列是否正确，即若有解输出任意一个满足要求的排列都会被认为通过。

## 说明/提示

**【样例解释】**

对于第一次询问，排列 $p = [4, 1, 5, 3, 2]$ 的**关键交换方案**只有 $x = [1]$，且因为 $p$ 的**终态**只有 $q = [1, 4, 5, 3, 2]$ 所以 $p$ 是**极好的**。

对于第二次询问，排列 $p = [5, 4, 3, 2, 1, 6]$ 的**关键交换方案**只有 $x = []$，且因为 $p$ 的**终态**只有 $q = [5, 4, 3, 2, 1, 6]$ 所以 $p$ 是**极好的**。

对于第三次询问，排列 $p = [3, 6, 2, 5, 1, 4]$ 的**关键交换方案**有 $x = [2, 4, 3]$ 和 $x = [4, 2, 3]$，且因为 $p$ 的**终态**只有 $q = [3, 2, 1, 6, 5, 4]$ 所以 $p$ 是**极好的**。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | $n \le$ | 特殊性质 | 分值 |
| :-: | :-: | :-: | :-: |
| $1$ | $8$ | 无 | $17$ |
| $2$ | $50$ | A | $3$ |
| $3$ | $50$ | B | $3$ |
| $4$ | $18$ | 无 | $19$ |
| $5$ | $40$ | 无 | $16$ |
| $6$ | $50$ | 无 | $9$ |
| $7$ | $60$ | 无 | $10$ |
| $8$ | $70$ | 无 | $11$ |
| $9$ | $80$ | 无 | $12$ |

- 特殊性质 A：$m = 0$。
- 特殊性质 B：$m = 1$。

对于所有数据，满足 $1 \le q \le 10^4$，$9 \times 10^8 < P < 10^9$，$2 \le n \le 80$，$0 \le m < P$，$P$ 是**质数**。

## 样例 #1

### 输入

```
5 998244353
5 1
6 1
6 2
6 3
10 20
```

### 输出

```
4 1 5 3 2
5 4 3 2 1 6
3 6 2 5 1 4
-1
5 10 4 3 2 9 8 7 1 6
```

# 题解

## 作者：EuphoricStar (赞：5)

首先考虑怎么对一个极好的排列 $p$ 求 $f(p)$。

枚举一个正整数 $x$，把排列中 $\le x$ 的数设成 $0$，$> x$ 的数设成 $1$。

那么交换这个排列使得 $\max\limits_{i = 1}^x p_i = x$ 的最小操作次数就是这个 $01$ 串的逆序对数。

交换这个排列使其变成好的的最小操作次数就是对于所有可能的 $x$ 对应的 $01$ 串的逆序对数的最小值。

因为 $p$ 是极好的，所以最小值对应的那个 $01$ 串一定是唯一的。称这个 $01$ 串是排列 $p$ 的**关键串**。

把这个 $01$ 串拿出来，那么 $f(p)$ 就是这个 $01$ 串，一次可以交换相邻的一对 $10$，交换使得其有序的交换方案个数。

考虑把 $0$ 看成向右走，$1$ 看成向上走，这样可以画出来一个杨表的轮廓。然后交换相邻的一对 $10$ 等价于删掉杨表中处于其所在行第一个和其所在列第一个的格子。可以发现方案数就是这个杨表的勾长公式。

因为 $n \le 80$ 所以杨表格子数 $\le 79$。可以先考虑直接搜正整数拆分得到杨表，然后再把它的轮廓转成一个 $1$ 开头 $0$ 结尾的 $01$ 串。

现在我们的问题是要在其开头添加最少个数的 $0$，结尾添加最少个数的 $1$，使得存在一种将这个 $01$ 串转成排列的方案，且这个 $01$ 串是这个排列的**关键串**。要求最少个数的原因是，回答询问时要枚举一个 $n' \le n$，使得存在长度为 $n'$ 的 $01$ 串且交换方案数为 $m$，找到这个 $01$ 串之后可以在前面补 $n - n'$ 个 $0$ 或在后面补 $n - n'$ 个 $1$，再将其转成排列。

结论：设这个 $01$ 串逆序对数（即搜出来的杨表格子数）为 $k$，$01$ 串长度为 $l$，那么要在开头添加 $k - l + 2$ 个 $0$，在结尾添加 $k - l + 2$ 个 $1$。将一个 $01$ 串转化成排列的方法是，设 $1$ 的个数为 $t$，从左往右将 $1$ 填成 $n, n - 1, \ldots, n - t + 1$，再从左往右将 $0$ 填成 $n - t, n - t - 1, \ldots, 1$。

注意到只有 $2k - l + 4 \le 80$ 的杨表才有用（称其为有效状态），所以边搜边剪枝，可以保证不会搜到无效状态。

可以使用哈希表存储所有形如 $(\text{长度}, \text{交换方案数}, \text{01 串})$ 的三元组。

时间复杂度 $O((a(n) + q)n)$，其中 $a(n)$ 为有效状态数，当 $n = 80$ 时 $a(n) \approx 2 \times 10^6$。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef __int128 lll;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 85;
const int P = 5000011;

ll n, m, mod, a[maxn], fac[maxn], inv[maxn], b[maxn];
__gnu_pbds::gp_hash_table<ll, lll> mp[maxn];

void dfs(int s, int lst, ll res, lll x) {
	if (s) {
		ll re = res * fac[s] % mod;
		int t = s - (m + lst) + 2;
		mp[m + lst + t * 2][re] = (x << t) | ((((lll)1) << t) - 1);
	}
	for (int i = lst; s + i <= 79; ++i) {
		if (2 * (s + i) - (m + 1 + i) + 4 > 80) {
			continue;
		}
		a[++m] = i;
		ll r = res;
		for (int j = 1; j <= i; ++j) {
			r = r * inv[i - j + (++b[j])] % mod;
		}
		dfs(s + i, i, r, ((x << (a[m] - a[m - 1])) | ((((lll)1) << (a[m] - a[m - 1])) - 1)) << 1);
		for (int j = 1; j <= i; ++j) {
			--b[j];
		}
		--m;
	}
}

inline void init() {
	fac[0] = 1;
	for (int i = 1; i <= 80; ++i) {
		fac[i] = fac[i - 1] * i % mod;
	}
	inv[1] = 1;
	for (int i = 2; i <= 80; ++i) {
		inv[i] = (mod - mod / i) * inv[mod % i] % mod;
	}
	dfs(0, 1, 1, 0);
}

void solve() {
	scanf("%lld%lld", &n, &m);
	if (m == 1) {
		for (int i = 1; i <= n; ++i) {
			printf("%d%c", i, " \n"[i == n]);
		}
		return;
	}
	for (int i = n; i >= 2; --i) {
		if (mp[i].find(m) != mp[i].end()) {
			lll x = mp[i][m];
			ll t = n;
			for (int j = 1; j <= n; ++j) {
				if ((x >> (n - j)) & 1) {
					a[j] = (t--);
				}
			}
			for (int j = 1; j <= n; ++j) {
				if (((~x) >> (n - j)) & 1) {
					a[j] = (t--);
				}
			}
			for (int j = 1; j <= n; ++j) {
				printf("%lld%c", a[j], " \n"[j == n]);
			}
			return;
		}
	}
	puts("-1");
}

int main() {
	int T = 1;
	scanf("%d%lld", &T, &mod);
	init();
	while (T--) {
		solve();
	}
	return 0;
}
```

---


# [ZJOI2015] 地震后的幻想乡

## 题目描述

傲娇少女幽香是一个很萌很萌的妹子，而且她非常非常地有爱心，很喜欢为幻想乡的人们做一些自己力所能及的事情来帮助他们。 

这不，幻想乡突然发生了地震，所有的道路都崩塌了。现在的首要任务是尽快让幻想乡的交通体系重新建立起来。幻想乡一共有 $n$ 个地方，那么最快的方法当然是修复 $n-1$ 条道路将这 $n$ 个地方都连接起来。 幻想乡这 $n$ 个地方本来是连通的，一共有 $m$ 条边。现在这 $m$ 条边由于地震的关系，全部都毁坏掉了。每条边都有一个修复它需要花费的时间，第 $i$ 条边所需要的时间为 $e_i$。地震发生以后，由于幽香是一位人生经验丰富，见得多了的长者，她根据以前的经验，知道每次地震以后，每个 $e_i$ 会是一个 $0$ 到 $1$ 之间均匀分布的随机实数。并且所有 $e_i$ 都是完全独立的。

现在幽香要出发去帮忙修复道路了，她可以使用一个神奇的大魔法，能够选择需要的那 $n-1$ 条边，同时开始修复，那么修复完成的时间就是这 $n-1$ 条边的 $e_i$ 的最大值。当然幽香会先使用一个更加神奇的大魔法来观察出每条边 $e_i$ 的值，然后再选择完成时间最小的方案。 幽香在走之前，她想知道修复完成的时间的期望是多少呢？

## 说明/提示

### 样例解释

对于第一个样例，由于只有四条边，幽香显然只能选择这四条，那么答案就是四条边的 $e_i$ 中最大的数的期望，由提示中的内容，可知答案为 $0.8$。

### 提示 

（以下内容与题意无关，对于解题也不是必要的。） 

对于 $n$ 个 $[0,1]$ 之间的随机变量 $x_1,x_2,...,x_n$，第 $k$ 小的那个的期望值是 $k/(n+1)$。  

数据范围： 

对于所有数据：$n \leq 10, \ m \leq n(n-1)/2, \ n,m \geq 1$。 

对于 $15 \%$ 的数据：$n \leq 3$。 

另有 $15 \%$ 的数据：$n \leq 10, m=n$。 

另有 $10 \%$ 的数据：$n \leq 10, m=n(n-1)/2$。 

另有 $20 \%$ 的数据：$n \leq 5$。 

另有 $20 \%$ 的数据：$n \leq 8$。

## 样例 #1

### 输入

```
5 4
1 2
1 5
4 3
5 3```

### 输出

```
0.800000```

# 题解

## 作者：_rqy (赞：145)

嗯...既然这题没有题解那我就来写一个吧！

显然，题目等价于同时修建这$m$条道路时，首次连通的时间期望值。

我们令$p(x)$为首次连通的时间（设它为随机变量$X$）的概率分布函数，也就是$p(x)=\frac{dP(x)}{dx}$，其中$P(t)=Pr(X\geq t)$，那么根据期望的定义有

$$\begin{aligned}E(X)&=\int_0^1p(x)x\mathrm{d}x\\&=\int_0^1p(x)\int_0^x\mathrm{d}t\,\mathrm{d}x\\&=\int_0^1\int_t^1p(x)\mathrm{d}x\,\mathrm{d}t\\&=\int_0^1P(t)\mathrm{d}t\end{aligned}$$

所以我们只需计算$\int_0^1P(t)dt$即可。

考虑如果$X\geq t$，也就是说图在$t$时刻不连通，那么我们可以枚举结点$1$在$t$时刻的连通块里有哪些点。如果有$S(1 \in S)$这些点，那么首先$S$要连通（概率我们定义为$1-P_S(t)$），其次，$S$里的点和其它点之间的边的$e$都大于$t$（概率为$(1-t)^{T(S, \overline S)}$，其中$\overline S$为$S$的补集，$T(A, B)$表示点集$A,B$之间的边数）；由于这两个事件是独立的，所以总的概率是$(1-t)^{T(S, \overline S)}P_S(t)$。$P_S(t)$也可以类似计算，递推式为：

$$P_S(t)=\sum_{1\in S_0 \subsetneq S}(1-t)^{T(S_0, S - S_0)}\left[1-P_{S_0}(t)\right]\qquad(1\in S)$$

边界条件是$P_{\{1\}}(t)=0$，因为单一的点永远是连通的。

那么有

$$\begin{aligned}\int_0^1P_S(t)\mathrm{d}t&=\sum_{1\in S_0 \subsetneq S}\int_0^1(1-t)^{T(S_0, S - S_0)}\left[1-P_{S_0}(t)\right]\mathrm{d}t\\&=\sum_{1\in S_0 \subsetneq S}\left[\int_0^1(1-t)^{T(S_0, S - S_0)}-(1-t)^{T(S_0, S - S_0)}P_{S_0}(t)\mathrm{d}t\right]\\&=\sum_{1\in S_0 \subsetneq S}\left[\frac{1}{1+T(S_0, S - S_0)}-\int_0^1(1-t)^{T(S_0, S - S_0)}P_{S_0}(t)\mathrm{d}t\right]\end{aligned}$$

同理，

$$\int_0^1(1-t)^kP_S(t)\mathrm{d}t=\sum_{1\in S_0 \subsetneq S}\left[\frac{1}{1+k+T(S_0, S - S_0)}-\int_0^1(1-t)^{k+T(S_0, S - S_0)}P_{S_0}(t)\mathrm{d}x\right]$$

边界条件：$\int_0^1P_{\{1\}}(t)(1-t)^k{\rm d}t=\int_0^10{\rm d}t=0$

而我们要求的就是

$$EX = \int_0^1P(t){\rm d}t =\int_0^1(1-t)^0P_{\{1,2,\dots,n\}}(t){\rm d}t$$

于是关于$S, k$递推即可。按$S$从小到大计算，每次枚举子集之后利用位运算$O(n)$求出$T$，总时间复杂度$O(3^nm)$。

PS：搞了一晚上终于抢下rk1了。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>

const int N = 10;
const int M = 45 + 1;
bool vis[1 << N][M];
int siz[1 << N], link[N];
double f[1 << N][M];
int main() {
  int n, m;
  scanf("%d%d", &n, &m);
  int lim = 1 << n;
  for (int i = 0, x, y; i < m; ++i) {
    scanf("%d%d", &x, &y);
    --x; --y;
    link[x] |= (1 << y);
    link[y] |= (1 << x);
  }
  for (int S = 1; S < lim; ++S) siz[S] = siz[S & (S - 1)] + 1;
  for (int S1 = 3; S1 < lim; ++S1) if (S1 & 1) {
    for (int S2 = (S1 - 1) & S1; S2 != 0; S2 = (S2 - 1) & S1) if (S2 & 1) {
      int T = 0;
      for (int i = 0; i < n; ++i) if ((S1 >> i) & (~S2 >> i) & 1)
        T += siz[link[i] & S2];
      for (int i = 0; i + T <= m; ++i)
        f[S1][i] += 1.0 / (i + T + 1) - f[S2][i + T];
    }
  }
  printf("%.6lf\n", f[lim - 1][0]);
  return 0;
}


```

---

## 作者：ButterflyDew (赞：78)

想了半天，打开洛谷题解一看，最高票是_rqy的，一堆密密麻麻的积分差点把我吓跑。

据说有三种解法，然而我只学会了一种最辣鸡的凡人解法。

upt:更正了一些错误..

------

题意：给一个无向图$G$，边权为$[0,1]$间的实数，求这个图的最小生成树的最大边权期望。

提示：对于 $n$ 个 $[0,1]$ 之间的随机变量 $x_1,x_2,\dots,x_n$，第 $k$ 小的那个的期望值是 $\frac{k}{n+1}$。

------

考虑使用这个提示来帮助解题。

首先有一个暴力做法，枚举边权的相对大小，然后做最小生成树，kruskal得到一棵树时拿提示算一下

这个想法启发我们钦定一个边集$S$作为前$|S|$小，如果这个边集加入第$|S|$小这条边时恰好使图联通，我们就可以算它的贡献是$\frac{|S|}{m+1}$，如果我们还能算出它的方案并除上总方案，我们就可以得到它的概率，所以考虑去统计这个方案。

恰好联通这个条件并不好统计，我们转换一下，可以变成

`恰好联通方案=加之前不连通方案-加之后不连通方案`

然后比较自然的可以考虑压一个子集去做$dp$

令$f_{S,i},g_{S,i}$分别表示点集为$S$，用了$i$条边，且点集不联通/连通的方案数，设$d_S$为点集$s$在图$G$中的边数

显然有

$$g_{S,i}+f_{S,i}=\binom{d_S}{i}$$

考虑$f$的递推，我们枚举$s$的子集，并且**钦定**某个点$k$一定在子集里，有转移

$$f_{S,i}=\sum_{k\in T\subset S}\sum_{j=0}^{d_T}g_{T,j}\binom{d_{S-T}}{i-j}$$

然后最后考虑如何统计答案，设$U$为全集，按照之前说的，答案为

$$\sum_{k=1}^{m+1}\frac{k}{m+1}\times (\frac{f_{U,k-1}}{\binom{d_u}{k-1}}-\frac{f_{U,k}}{\binom{d_u}{k}})$$

化简一下

$$\frac{1}{m+1}\sum_{k=1}^m\frac{f_{U,k}}{\binom{d_U}{k}}$$

------

**Code:**

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
using std::min;
template <class T>
void read(T &x)
{
	x=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
}
double C[51][51],f[1<<10][51],g[1<<10][51];
int yuu[1<<10],dew[1<<10],n,m;
int main()
{
	read(n),read(m);
	for(int u,v,i=1;i<=m;i++)
	{
		read(u),read(v);
		++dew[(1<<u-1)|(1<<v-1)];
	}
	for(int s=1;s<1<<n;s++)
		for(int t=s;t;t=t-1&s)
			yuu[s]+=dew[t];
	C[0][0]=1;
	for(int i=1;i<=m;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=i;j++)
			C[i][j]=C[i-1][j]+C[i-1][j-1];
	}
	for(int s=1;s<1<<n;s++)
	{
	    for(int i=0;i<=yuu[s];i++)
		{
			for(int t=s-1&s;t;t=t-1&s)
                if(t&(s&-s))
                    for(int j=0;j<=min(i,yuu[t]);j++)
                        f[s][i]+=g[t][j]*C[yuu[s^t]][i-j];
			g[s][i]=C[yuu[s]][i]-f[s][i];
		}
	}
	double ans=0;
	for(int i=0;i<=m;i++) ans+=f[(1<<n)-1][i]/C[m][i];
	ans/=m+1.0;
	printf("%.6f\n",ans);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：33)

期望神题……
这道题和今年NOIPD2T2极度神似，不知道NOIP2018要毒瘤到哪里去了

我们首先见到这道题，第一反应是——不会

所以我们要写暴力。

其实，如果知道边的排名的话，跑kruskal就好了对吧

但是我们不知道排名

所以暴力枚举边的全排列，跑kruskal，用题目中给的结论更新答案即可

复杂度n\*m!

显然太暴力了，但是如果你记得NOIP2017D2T2的话，会发现它也有一个类似的全排列枚举+贪心的做法

然后优化呢？

子集DP，是子集DP，全排列之所以复杂度高，是因为它给了我们许多不需要的信息，对于这道题，我们只需两个信息，一是状态，二是联通性
从而把期望问题转化为计数问题

那么这个是可以状压的，当然，你会发现设f\[s]\[i]表示点集s全部联通,最大边排名为i是不可转移的

所以这里有个操作叫正难则反

我们设dp\[k]\[i]\[s](k为0/1变量)(s为二进制串)为加入前i条边时
点集s联通/不连通的概率。

先解释一下为什么变成了前i条边，因为这里要求的代价是**最大边最小**，而不是总和最小，所以平常做kruskal中被“跳过”的边，此时是无需付出代价的，所以也可以记为一种方案

转移的话，我们可以枚举其中的一个顶点，哪一个无所谓，只是在求dp[0][s][i]的时候这个点p要不变，枚举s的子集，该子集必须包含p

那么dp[0][s][i]=sigma(dp[1][s'][j]\*c[i-j][size[s^s']])
其中size为一个点集中边的数目

那么，这是什么意思呢？，相当于我们依照点p将这个集合剖为两半了
而我们是在枚举这个不联通集合联通块的大小

由于s^s'只能在本身内部连边，所以，s^s'一定和s'不联通，所以s一定不连通，而且因为枚举所有的“分割线”所以不重不漏的枚举了所有方案

另一个性质dp[0][i][j]+dp[1][i][j]=c[i][size[j]]

这个东西应该是显然？好吧还是解释下：因为已经把问题转化为了一个边可以全取问题，也就是说已经不是树了，因此边可以想怎么取就怎么取，除了联通不联通就没有了别的限制，因此dp[0]与dp[1]覆盖了所有的组合数

那么我们就可以愉快的递推了，这里有一个操作是枚举子集的，如果要枚举s的子集，那么可以用这样的语句：
```C
for(int k=(s-1)&s;k>0;k=(k-1)&s);
```

就可以愉快的枚举子集了

最后，是如何生成答案，很遗憾，答案并不能由dp[1]得到，为什么？
因为把原问题反了一下，我们求出来的是成功联通的方案，而不是什么
最小生成树，想必联通图和树之间的差别还是极大的

那么为了得出答案，我们可能也要反一下原问题，想一下，现在尽管是无条件加边，但是如果在加第X条边的时候刚好联通了，这时的联通图，对应的最小生成树最大边也是x.

也是说，连到第X条边时刚好联通的**联通图**，与最大边为X的最小**生成树**，**一一对应**

那么我们现在要求最大边的期望：

1.设最大边一种可能的排名取值为xi

2.设某一取值xi出现的概率为P(xi)

3.设x的取值不比x0小的概率为p(x>=x0)

4.设点集的全集为U

那么最大边的排名的期望就是：

sigma(xi\*p(xi)) \[i∈(1~m)]

对上述式子求一个前缀和，上式等价于(不能理解就记成结论好咯)

sigma(p(x\>=i))\[i∈(1~m)]

反一下，等价于

sigma(dp\[0]\[i]\[U]/c\[i]\[m]) \[i∈(0~m)]

ok，毕竟取到**i不连通**的概率是等价于**最大边大于i**概率的

这样就求出了边排名的期望，除个m+1就行了

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;
ll dp[2][60][2200];ll size[2200];bool book[2200];
int n;int m;ll c[60][60];int up;
int map[20][20];double res;
int main()
{
    scanf("%d%d",&n,&m);up=pow(2,n)-1;
    for(int i=1;i<=m;i++)
    {
        int u;int v;
        scanf("%d%d",&u,&v);
        map[u-1][v-1]=1;map[v-1][u-1]=1;//用邻接矩阵存 
    }
    for(int i=1;i<=up;i++)
    {
        for(int p1=1;p1<n;p1++)
        {
            for(int p2=0;p2<p1;p2++)
            {
                size[i]+=((i>>p1)&1)&&((i>>p2)&1)&&map[p1][p2];//暴力计算size 
            }
        }
    }
    c[0][0]=1;
    for(int j=1;j<=m+1;j++)//递推杨辉三角 
    {
        c[0][j]=1;
        for(int i=1;i<j;i++)
        {
            c[i][j]=c[i][j-1]+c[i-1][j-1];
        }
        c[j][j]=1;
    }
    for(int i=0;i<=up;i++){dp[0][0][i]=1;}
    for(int i=0;i<n;i++){dp[1][0][1<<i]=1;dp[0][0][1<<i]=0;}
	//边界条件,显然一个点是联通的 
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=up;j++)
        {
            int p1=0;for(;((j>>p1)&1)==0;p1++);//随便选一个剖分点 
            for(int k=(j-1)&j;k>0;k=(k-1)&j)//枚举子集 
            {
                if(((k>>p1)&1)==0)continue;//不包含就算了 
                for(int rk=0;rk<=i;rk++)//枚举补集可用的边数 
                {
                    dp[0][i][j]+=dp[1][rk][k]*c[i-rk][size[j^k]];
                }
            }
            dp[1][i][j]=c[i][size[j]]-dp[0][i][j];//同时求出dp[1] 
        }
    }
    for(int i=0;i<=m;i++){res+=(double)dp[0][i][up]/(double)(c[i][m]);}//处理出概率 
    printf("%lf",(double)res/(double)(m+1));return 0;//拜拜程序~ 
}
```





---

## 作者：command_block (赞：32)

先膜拜积分大佬！

------------

就着这道题谈一下我做概率期望题的感想吧。

这之中离不开的就是**方案数**+**概率**+**期望**

大家都知道 

$$\text{概率}=\text{方案数}/\text{总方案数}$$

$$\text{期望}=\text{概率}*\text{对应权}$$

如果一道题加模数的话，三个量可以不掉精度地转化，以方便我们的分析。

(比如[这道题](https://www.luogu.org/problemnew/show/P3600))

回到本题的平民做法，我们知道要求的是最小生成树上边的最大值的期望。

这东西一看就很不好求，而且边的权都不是离散的，而是$[0,1]$以内的随机实数，这就很不方便处理。


题目很良心，有一个提示：

```cpp
对于n个[0,1]之间的随机变量x1,x2,...,xn，第k小的那个的期望值是k/(n+1)
````

这让我们想到**把期望转化成排名的期望**，这样子就能化连续为离散（一般来讲，这可以使问题变简单，在P3600里面也有这样的细节）。

现在主要的复杂点就在于**最小生成树**,这是个很复杂的东西，我们想方设法挖掘本质，将它变简单。

**假设你知道了边的排名**，然后在跑克鲁斯卡尔。

你会一条一条地加边，然后判断是否生成了树。

答案就是最后加入的那一条边的排名。

那么我们就有了第一个算法：

```cpp
枚举边的排名，然后跑克鲁斯卡尔。

得到排名的期望，再除以(m+1)得到答案。

复杂度O(m*m!)据说分数可观。
```

我们考虑“生成了树”的本质是什么，在克鲁斯卡尔中，就是把n个点都联通了起来。

**一个最小生成树内最大的边排名为x的概率=用k条边恰好联通整个图的概率**（这个很好理解吧）

根据期望的定义，排名的期望=$\sum P(x)*x$

其中$P(x)$是用k条边**恰好**联通整个图的概率。

**恰好**的意思是，没有第k条边的时候，不连通，加一条边就联通了。

这个限制令人头疼，我们把它**前缀和**一下（P3600里面也有类似套路）

得到$P'(x)=\sum\limits_{i=0}^nP(x)$

根据人类智慧$P(x)'$=一条边联通全图的概率+二条边联通全图的概率+...=**用排名前k的边联通整个图的概率**。

（仔细体味$P(x)$和$P'(x)$的不同）。

然后因为前缀和,$P(x)'-P'(x-1)=P(x)$

我们只要想办法弄出$P'(x)$就好了。

**至此，问题已经变成了图的联通性问题（边的选取问题）。**

那么问题来了，这玩意怎么求？

如果一道题加模数的话，三个量可以不掉精度地转化，以方便我们的分析。

这道题没加模数，不代表我们不能转化，我们考虑**转化成方案数**。

方案数会不会爆long long，因为最多只有$45$条边，最多就是$C_{45}^{23}=4116715363800$,稳得一批。

这里我们采用dp求方案数。

设$f[i][s]$表示使用$i$条边联通了s这个集合的方案数。

想了想发现不可做。

于是采用正难则反，这$g[i][s]$表示使用$i$条边没有联通s这个集合的方案数。

我们设$c[x][y]$表示$C_x^y$(注意谁在下面),设$siz[s]$表示点集$s$内部有多少边。

一个很好理解的东西$c[siz[s]][i]=g[i][s]+f[i][s]$，因为$g$和$f$组成了所有选取的方法。

我们考虑如何转移出$g[i][s]$：

我自然地想到了**枚举子集**，把$s$区分成了两个真子集s1,s2(即不能枚举空集)。

（如果没听说过**枚举子集**的话建议上网查一下，或者去做P3959）

那么，必须令这s不连通，那好办，直接**令这s1,s2之间没有边**。

那么s1,s2内部就可以随便连。

这样肯定是不会算漏，但会重复。

```cpp
第一次分割
1 #  2
  # 
###  3
根据任意连边，所有点之间都不连边的方案适合这个分割线

第二次分割
1 #  2
  ####
    3
根据任意连边，所有点之间都不连边的方案也适合这个分割线

很明显存在重复计算
```

之所以会存在重复计算，是因为分割线可能会**重复穿过**“随便连”的部分。

我们dp出了$f$数组，现在可以拿来用，我们规定s1内必须联通，s2内可以随便。

这样子，分割线就不会再次穿过s1（因为其内部联通）

现在还有一个问题，如果s1与s2调换，还是会存在重复算的情况(必须联通∈随便连)

所以当我们枚举过某个s1时，**就不能再次枚举它的补集**作为s1。

这里有个非常脑洞的操作,随便钦点一个s内的点p，令s1必须包含p，这样子，枚举过的s1的补集必然不包含p，也就被排除在外了。

理解了这些(建议结合其他题解理解这个，**真的不好懂**)就好办了，下面是dp的代码与详细注释：

```cpp
long long f[50][1200],g[50][1200],c[50][50];
//f:联通; g:不连通; c:组合数; 
int siz[1200];
//siz:某点集内边的数量;
bool e[12][12];
//e:邻接矩阵;

  for (int s=0;s<=limit;s++)g[0][s]=1;
  for (int i=0;i<n;i++)
   {f[0][1<<i]=1;g[0][1<<i]=0;}
  //根据“一个点自身是联通的”来初始化
  for (int s=0;s<=limit;s++)
   for (int i=0;i<n;i++)
  	for (int j=i+1;j<n;j++)
  	 if (e[i][j]&&((1<<i)&s)&&((1<<j)&s))
  	  siz[s]++;
  //求解siz
  for (int i=0;i<=m;i++){
    c[i][0]=1;
    for (int j=1;j<=i;j++)
     c[i][j]=c[i-1][j]+c[i-1][j-1];
  }//预处理组合数
  for (int i=1;i<=m;i++)
   for (int s=1;s<=limit;s++){
   	 int p=0;
   	 for (;((1<<p)&s)==0;p++);
    //寻找一个s内的点(s必然不为空集)
   	 for (int k=(s-1)&s;k;k=(k-1)&s)
   	  if ((1<<p)&k){
      //这里还要枚举分给两个子集各多少条边
   	   for (int j=0;j<=i;j++)
   	    g[i][s]+=f[j][k]*c[siz[s^k]][i-j];
        //如上文，一部分随便选，一部分必须联通
   	  }
   	 f[i][s]=c[siz[s]][i]-g[i][s];
     //根据c[siz[s]][i]=g[i][s]+f[i][s]求出f[i][s]
   }
```

至此，dp的部分就讲完了，我们回到概率$P'(x)$上来。

$P(x)'$=一条边联通全图的概率+二条边联通全图的概率+...=**用排名前k的边联通整个图的概率**。

就是$P(x)'=\dfrac{f[x][\text{全集}]}{c[m]][x]}$

代码

```cpp
double p[50],p2[50];

  double ans=0;
  for (int i=0;i<=m;i++)
  	p2[i]=(double)f[i][limit]/(double)c[m][i];
  //计算p'
  for (int i=0;i<=m;i++)p[i]=p2[i]-p2[i-1];
  //计算p
  for (int i=0;i<=m;i++)ans+=p[i]*i;
  //计算排名的期望
  printf("%.6lf",ans/(m+1));
  //得到最大边的期望
```

[$AC$记录](https://www.luogu.org/record/show?rid=17237986)

---

## 作者：殇雪 (赞：23)

并不会打数学公式的我瑟瑟发抖

题解的链接


http://www.cnblogs.com/rrsb/p/8149523.html

数学推导的链接：

https://s1.ax1x.com/2017/12/30/zqSzV.jpg

https://s1.ax1x.com/2017/12/30/zbzR0.jpg

看在我足足写了两页纸的份上让我过吧。


---

## 作者：xudaxia (赞：10)

题目看完之后就知道不会做。

然后题目的提示十分重要：**对于 n 个 [0,1] 之间的随机变量 x1,x2,...,xn，第k小的那个的期望值是 k/(n+1)。**

假设我们知道 $m$ 条边的权值，我们做一遍**克鲁斯卡尔**最小生成树。答案就是最小生成树中的边权最大值。也就是加入后**恰好**使图联通的边权。

根据题目的提示：本题的答案就是最小生成树的最大边权在 $m$ 条边中的期望排名$/ (m+1)$。

所以现在就是要求**最小生成树的最大边权在 m 条边中的期望排名**。

然后因为期望的线性性，我们可以枚举生成树中最大边在 $m$ 条边中的排名 $i$ 再乘上最大边在 $m$ 条边中的排名为i的概率 $P(i)$ 。也可以说是加入第 $i$ 条边这个图刚好联通的概率。
就是：
$$ans=\frac{1}{m+1}\sum_{i=1}^{m}i*P(i)$$

这个式子和下面的式子等价。

$$ans=\frac{1}{m+1}\sum_{i=1}^{m}\sum_{j=i}^{m}P(j)$$

考虑$\sum_{j=i}^{n}P(j)$是什么？其实就是加入 $i-1$ 条边图不连通的概率。

所以问题转化为求加入 $x$ 条边图不连通的概率。

然后这个概率显然等于加入x条边图不连通的方案数$/$总方案数。

因为总方案数好求就是$C_m^x$

所以问题又转化为加入 $x$ 条边图不连通的方案数。

考虑用状压DP解决。

$dp[i][j][0/1]$ 分别代表选了在点集 $i$ 的生成子图中选了 $j$ 条边不连通$/$连通的方案数。

$dp[i][j][0]$ 套路求法，设定一个关键点，枚举关键点所在的连通子集 $k$，和子集 $k$ 的生成子图中的边数 $s$，设 $size[i]$为点集 $i$ 中的边的数量，转移方程为$dp[i][j][0]=dp[k][s][1]*C_{size[i\ xor \ k]}^{j-s}$。

利用$dp[i][j][0]+dp[i][j][1]=C_{size[i]}^{j}$就可以求出 $dp[i][j][1]$ 。

最后
$$ans=\frac{1}{m+1}\sum_{i=0}^{m}\frac{dp[(1<<n)-1][m][0]}{C_m^i}$$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define int long long
int dp[1111][111][2],n,m,u[111],v[111],C[111][111],size[1111];
double ans;
int read(){
	int sum=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
	return sum*f;
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=m;i++)u[i]=read(),v[i]=read();
	for(int i=0;i<(1<<n);i++)
		for(int j=1;j<=m;j++)
			if((i&(1<<(u[j]-1)))&&(i&(1<<(v[j]-1))))size[i]++;
	for(int i=0;i<=m;i++)C[i][0]=1;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			C[i][j]=C[i-1][j-1]+C[i-1][j];
	for(int i=0;i<(1<<n);i++){
		int p=i&(-i);
		for(int j=(i-1)&i;j;j=(j-1)&i){
			if((j&p)==0)continue;
			for(int a=0;a<=size[j];a++)
				for(int b=0;b<=size[j^i];b++)
					dp[i][a+b][0]+=dp[j][a][1]*C[size[i^j]][b];
		}
		for(int a=0;a<=size[i];a++)dp[i][a][1]=C[size[i]][a]-dp[i][a][0];
	}
	for(int i=0;i<m;i++)ans+=1.0*dp[(1<<n)-1][i][0]/C[m][i];
	printf("%.6lf",1.0*ans/(m+1.0));
	return 0;
}
```

```

---

## 作者：Parsnip (赞：9)

我是来补充**斯特林反演**的详细做法的。

@Ymiracle 的题解已经给出了该做法的思路，写的很详细，但是在没什么斯特林反演的题目的情况下，似乎还是有那么一点难以理解，这篇题解主要是补充，尽量让一个没做过斯特林反演题目的人也可以看懂。

该讲的题意转化还是得讲：首先，题目的意思是图的每一条边的权值都在$[0,1]$间随机分布，求原图最小生成树瓶颈边的权值期望大小。 题目里已经提示我们$n$个$[0,1]$间的随机变量第$k$小的期望值是$\frac{k}{m+1}$，**这其实就是想让我们考虑把权值的期望问题转化成排名的概率问题。**

为什么这样说？我们可以从期望的定义入手：

$$E(X)=\sum_{x}P(X=x)\times x$$

虽然随机变量$X$的取值有无穷多个，但是瓶颈边的大小在$m$条边里必然有一个排名（排名是离散的！！），不妨枚举这个排名，就可以得到权值：

$$E(X)=\sum_{k=1}^mP(\mathrm{the\ rank\ of\ the\ edge=}\ k)\times \frac{k}{m+1}$$

所以，我们就要求$p_k=P(\mathrm{the\ rank\ of\ the\ edge=}\ k)$. 那么，瓶颈边的排名为$k$是啥意思？就是说我们用了$k-1$条边，图不连通，现在我加入第$k$条边，图就联通了，**这就代表我们加的这条边成为了瓶颈边**。 也就是说，$p_k$表示**有顺序地**选$k$条边**恰好**联通原图的概率.

我本来想：这不就相当于让你求原图选$k$条边，问有多少种情况得到连通图吗。**但显然不是的**。有一个很简单的反例：

![](https://cdn.luogu.com.cn/upload/image_hosting/nc45lhhj.png)

假设这就是原图，显然边**全部都选**是$k=5$条边联通原图的一个方案，但是这可千万不能算到$p_5$里面，因为$5$条边**恰好**联通原图的概率为$0$，随便你最后加的是哪一条边，原图都已经联通了，就没有恰好这一说。

这时候一个很巧妙的处理方法就是前缀和，令

$$p'_n=\sum_{i=0}^n p_i$$

那么$p'_k$就代表 有顺序选$1$条边**恰好**联通原图的概率 $+$ 有顺序选$2$条边**恰好**联通原图的概率 $+\cdots+$ 有顺序选$k$条边**恰好**联通原图的概率 $=$ **有顺序选$k$条边原图联通的概率。**

上述等式显然可以通过**全概率公式**来验证：

![](https://cdn.luogu.com.cn/upload/image_hosting/hg2d3r7l.png)

而**有顺序**选$k$条边原图联通的概率 $=$ **无顺序**选$k$条边原图联通概率！！！

这样，如果能求$p'$数组，那么$p$数组就可以求。

**上面这段可能有点难理解，不过下面就和概率期望没关系了**。

现在我们得到另一个问题：给定一个图，求保留图中$k$条边，原图联通的概率$p'_k$。

考虑到$m\leq 45$，其保留若干条边的最大方案数$\binom{45}{23}$在$\mathrm{long\ long}$类型范围内，那么问题转到求解保留$k$条边，使原图联通方案数$F_{k}$，显然有$p'_k=\frac{F_k}{\binom{m}{k}}$.

这样的话问题就变得很经典了，对于**和图连通性有关的计数问题**，我们要考虑斯特林反演。 不妨设$f_{S,i,j}$表示现在我们选了原图中$i$条边，**把点集$S$划分成$j$个连通块的方案数**，$g_{S,i,j}$表示我们选了原图中$i$条边，**点集$S$被钦定划分成$j$个连通块**（事实上可能更多）的方案数。那么有如下关系：

$$g_{S,i,j}=\sum_{k=j}^n\begin{Bmatrix}k\\ j\end{Bmatrix}f_{S,i,k}$$

这个式子对理解斯特林反演来说至关重要，一个很好的想法是：对比二项式反演。

在二项式反演里面，我们要算**恰好**$k$的方案，当然是令 $($**钦定**$k$的方案$)=\sum_{l\geq k}\binom{l}{k}($**恰好**$l$的方案$)$，然后设法反演$/$递推求出答案。 为什么要这样做，那是因为钦定$k$的方案很好算。

**钦定**$k$啥意思？不就是我强选$k$个性质固定下来，然后剩下的随便来，使得真正的性质数量**至少为**$k$吗。

斯特林反演同样如此，既然$i$条边把点集$S$划分成$j$个连通块的方案数不好算，那么我们就钦定点集$S$被划分为$j$个连通块，然后再计算 **在不影响钦定假设的前提下** **随意地**$i$条边的方案（即不在钦定划分开来的两个连通块之间加边），这样，实际上的连通块数量，就至少为$j$。

此时，我们的求和系数就是第二类斯特林数，因为任何一个**真实的划分**$k$，都会对**钦定的划分**$j$产生$\begin{Bmatrix}k \\ j\end{Bmatrix}$次贡献，即：选子集方案数。

现在我们可以对原式进行斯特林反演：

$$f_{S,i,j}=\sum_{k=j}^n(-1)^{k-j}\begin{bmatrix}k\\ j\end{bmatrix}g_{S,i,k}$$

斯特林反演的证明，可以在我的[这篇博客](https://www.cnblogs.com/Parsnip/p/13398578.html)里找到，这道题的斯特林反演的式子还稍有不同，要用到[反演原理](https://www.cnblogs.com/Parsnip/p/12518336.html)（博客里面$3.2$节）来转化。

要求$f_{\mathrm{U},1\sim m,1}$，就是要求$g_{\mathrm{U},1\sim m,1\sim n}$。 现在考虑$g$，显然，没有任何限制的集合划分方案数就是$\mathrm{Bell}$数，但是现在我们要在不连接已经划分集合的前提下加入$i$条边，不妨考虑子集$\mathrm{dp}$。

如果要直接算$g$，那么至少要枚举$S,i,j$，要枚举$S$的子集$T$表示新加入的一个集合，枚举$k$表示新集合里面选的边数，那么复杂度就至少要$\mathcal{O}(3^nnm^2)$，显然爆炸。

但是其实我们可以先算一个$h_{S,i,j}$，表示点集$S$被钦定划分成$j$个连通块，这$j$个连通块里面一共有$i$条边**可选**的方案数. 可选的意思就是我加入一个连通块就把连通块里面的所有边都加到$\mathrm{dp}$数组的下标里面，表示我总共有这么多边可以用.

那么就会有

$$g_{S,i,j}=\sum_{k=i}^m \binom{k}{i}h_{S,k,j}$$

现在以同样的方式$\mathrm{dp}$，既不用枚举子集$T$当中的边数了，于是复杂度就降到了$\mathcal O(3^n nm)$已经可以通过。

具体地，令$e(T)$表示原图里边点集$T$有多少条边，我们可以枚举一个包含$S$**最小标号点**的子集$T$，那么：

$$h_{S,i,j}=\sum_{T \subseteq S,\min_{x\in S}\{x\}\in T}h_{\complement _S T,i-e(T),j-1}$$

如果要求集合之间是没有标号的（或者说无序的），那么强制使转移时加入的最后一个子集包括最小标号点是一个很好的避免算重的方式，代码可以这样写：

```cpp
for (int S = 1; S < 1<<n; S++)
    for (int i = 0; i <= e[S]; i++)
        for (int j = 1; j <= sz[S]; j++) {
            for (int T = S&(S-1), P; P = T|Lowbit(S), T; T = (T-1) & S & (S-1))
                if ( i >= e[P] ) h[S][i][j] += h[S-P][i-e[P]][j-1];
            h[S][i][j] += h[ S - Lowbit(S) ][ i - e[Lowbit(S)] ][j-1];
        }
```

根据上面推的式子，应该容易写出下面的代码（略去预处理）：

```cpp
for (int i = 0; i <= m; i++)
    for (int j = 1; j <= n; j++)
        for (int k = i; k <= m; k++)
            g[i][j] += h[(1<<n)-1][k][j] * c[k][i];
for (int i = 1; i <= m; i++)
    for (int j = 1; j <= n; j++)
        f[i] += ( (j&1) ? 1 : -1 ) * fac[j-1] * g[i][j];
for (int i = 0; i <= m; i++) p[i] = 1.0 * f[i] / c[m][i];
for (int i = m; i >= 1; i--) p[i] = p[i] - p[i-1];
for (int i = 1; i <= m; i++) Ans += p[i] * i / (m+1);
```

这样已经完全可以通过本题了。

然而@Ymiracle 大佬还提到了一种把系数$(-1)^{k-1}(k-1)!$放到$\mathrm{dp}$里面的做法，暂时还没有搞懂怎么转移来处理系数$(k-1)!$，可能可以参考[这篇博客](https://www.cnblogs.com/bestwyj/p/13052448.html)。 如果您可以提供帮助，望告知。

总结：这道题不知道花了我多少时间，总的来说，从题面的提示出发，我们应该容易把期望问题转化到概率问题，进一步的，我们发现可以用前缀和把恰好性概率转化到结果型概率（可以用全概率公式验证！！），再通过概率的定义转化到计数问题，使用斯特林反演求解连通图计数，最后得到答案。无论是期望，概率，还是计数方面，这道题都十分有难度。


---

## 作者：Ymiracle (赞：9)

事实上，问题就是求出$i$条边连通图的个数。
做法很多,

考虑斯特林反演：
我们记$f_{s,j,k}$表示$s$加入了$j$条边有$k$个联通块的方案数。
$g_{s,j,k}$表示至少有$k$个联通块。

显然满足$g_{s,j,k}=\sum_{l}f_{s,j,l} \begin {Bmatrix} l \\k \end {Bmatrix}$
所以得到$f_{s,j,k}=\sum_{l}g_{s,j,l}(-1)^{l-k} \begin {bmatrix} l \\k \end {bmatrix}$


考虑$g$是可以先算出$h_{s,k,m}$表示我们将$s$划分成$m$块，每个块内部一共有$k$条边，显然$g_{s,j,m}=\sum_{k}h_{s,k,m}\binom{k}{j}$

这样转移就很方便了。
考虑此时$h_{s,j,k}$可以直接枚举当前和最小标号点的集合来转移。
但这个终究还是要枚举联通块个数，不太优秀。

注意到本题需要求出$f_{s,m,1}=\sum_{l}g_{s,m,l}(-1)^{l-1}(l-1)!$

容斥系数我们是可以弄到$dp$里面的：$f_{s,m,1}=\sum_{l}\sum_{k} h_{s,k,l} \binom{k}{m}(-1)^{l-1}(l-1)!$
此时我们可以$dp_{s,k}=\sum_{l}h_{s,k,l}(-1)^{l-1}(l-1)!$
这个转移除了最后一次特殊处理，其他的暴力枚举第$l$次加入的是哪个子集就行了。

复杂度是$3^n m$

---

## 作者：Leasier (赞：6)

来点不需要脑子的~~需要吸氧才能过且成功夺得 Luogu 第二劣解~~集合划分 dp 做法。

不难发现题目想让我们求出**边以任意方式排列时，依次加边使得图联通的第一个时刻除以 $m + 1$ 的期望**。

注意到 $n$ 非常小，考虑对连通性状压。设 $dp_{i, S}$ 表示 $i$ 时刻时连通性为 $S$ 的概率。不难发现这个 dp 的状态数是 $O(m B_n)$ 的，其中 $B_n$ 表示第 $n$ 个贝尔数。

我们希望知道的是：$\dfrac{\displaystyle\sum_{i = 0}^m \frac{i dp_{i, \{\{1, 2, \cdots, n\}\}}}{(m - i)!}}{m! (m + 1)}$（注意：一个 $dp_{i, \{\{1, 2, \cdots, n\}\}}$ 不能再向 $i + 1$ 转移）。

初值：$dp_{0, \{\{1\}, \{2\}, \cdots, \{n\}\}} = 1$。

转移分为两种。

1. 不改变连通性

我们可以对于每个连通块，预处理出当前连通块内的边数（记为 $f(S)$）。

于是我们直接 $dp_{i + 1, S} \leftarrow dp_{i + 1, S} + dp_{i, S} \displaystyle\sum_{x \in S} f(x)$ 即可。

2. 改变连通性

我们可以直接枚举一条连接当前两个连通块的边，当然要预处理连通块间的边数（记为 $g(S, T)$）。

于是我们直接 $dp_{i + 1, S - \{x\} - \{y\} + \{x \cup y\}} \leftarrow dp_{i + 1, S - \{x\} - \{y\} + \{x \cup y\}} + dp_{i, S} g(x, y)$ 即可，其中 $x, y \in S$ 且 $x \neq y$。这里我们需要预处理出所有转移以保证时间复杂度。

时间复杂度为 $O(n^3 B_n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <vector>
#include <cstdio>

using namespace std;

int cnt = 0;
int a[47], b[47], inside[1027], connect[1027][1027], sum[115977];
double fac[47], dp[47][115977];
map<vector<int>, int> mp;
vector<int> v1, v2, v3[115977];
vector<pair<int, int> > v4[115977];

inline void init(int n){
	fac[0] = 1.0;
	for (register int i = 1; i <= n; i++){
		fac[i] = fac[i - 1] * i;
	}
}

void dfs(int cur, int n, vector<int> v){
	if (cur > n){
		sort(v.begin(), v.end());
		if (!mp.count(v)){
			int size = v.size();
			cnt++;
			v3[cnt] = v;
			mp[v] = cnt;
			for (register int i = 0; i < size; i++){
				sum[cnt] += inside[v[i]];
			}
		}
		return;
	}
	int mask = 1 << (cur - 1), cur_i = cur + 1, size = v.size();
	v.push_back(mask);
	dfs(cur_i, n, v);
	v.pop_back();
	for (register int i = 0; i < size; i++){
		int t = v[i];
		v[i] |= mask;
		dfs(cur_i, n, v);
		v[i] = t;
	}
}

int main(){
	int n, m;
	double ans = 0.0;
	cin >> n >> m;
	v1.push_back((1 << n) - 1);
	init(m);
	for (register int i = 0; i < n; i++){
		v2.push_back(1 << i);
	}
	for (register int i = 1; i <= m; i++){
		cin >> a[i] >> b[i];
	}
	for (register int i = 0; i < (1 << n); i++){
		for (register int j = 1; j <= m; j++){
			if ((i & (1 << (a[j] - 1))) && (i & (1 << (b[j] - 1)))) inside[i]++;
		}
		for (register int j = 0; j < (1 << n); j++){
			if (!(i & j)){
				for (register int k = 1; k <= m; k++){
					if (((i & (1 << (a[k] - 1))) && (j & (1 << (b[k] - 1)))) || ((i & (1 << (b[k] - 1))) && (j & (1 << (a[k] - 1))))) connect[i][j]++;
				}
			}
		}
	}
	dfs(1, n, vector<int>());
	for (register int i = 1; i <= cnt; i++){
		int size = v3[i].size();
		for (register int j = 0; j + 1 < size; j++){
			for (register int k = j + 1; k < size; k++){
				if (connect[v3[i][j]][v3[i][k]] != 0){
					int t = v3[i][j] | v3[i][k];
					vector<int> v = v3[i];
					v.erase(v.begin() + k);
					v.erase(v.begin() + j);
					v.insert(lower_bound(v.begin(), v.end(), t), t);
					v4[i].push_back(make_pair(mp[v], connect[v3[i][j]][v3[i][k]]));
				}
			}
		}
	}
	dp[0][mp[v2]] = 1.0;
	for (register int i = 0; i <= m; i++){
		ans += i * fac[m - i] * dp[i][mp[v1]];
		dp[i][mp[v1]] = 0.0;
		if (i == m) break;
		int ii = i + 1;
		for (register int j = 1; j <= cnt; j++){
			if (dp[i][j] == 0.0) continue;
			int size = v4[j].size();
			if (sum[j] != i) dp[ii][j] += dp[i][j] * (sum[j] - i);
			for (register int k = 0; k < size; k++){
				dp[ii][v4[j][k].first] += dp[i][j] * v4[j][k].second;
			}
		}
	}
	printf("%.6lf", ans / (m + 1) / fac[m]);
	return 0;
}
```

---

## 作者：Soulist (赞：5)


## [ZJOI2015]地震后的幻想乡

给定一张图，每条边的边权在 $[0,1]$ 中随机，求最小生成树的最大边权的期望。

$n\le 10,m\le \frac{n(n-1)}{2}$

### Solution

[$\textrm{更好的阅读体验}$](https://www.cnblogs.com/Soulist/p/13848734.html)

大概是比较 math 的做法...相对别人的做法而言可能不是很需要脑子？

这个题大概代表了 $7$ 月的一点学习记录...今天整理就顺手发出来了。

对于**连续型随机变量**，我们一般使用概率密度函数 $f(x)$ 来描述它取值的概率，其一定区域的积分可以表示取值为连续的一段区间的概率。

例如，论证 $\mathbb{E}(\max\{x_1,x_2...x_n\})=\frac{n}{n+1}$ 时，我们先定义 $F(x)=\max\{x_1...x_n\}\le x$，那么容易得到 $F(x)=x^n$

我们不难观察到，$F(x)$ 的导数就是其对应的密度函数 $f(x)$

所以我们得到 $f(x)=x^{n-1}n$

容易观察得到，我们计算的期望为：

$$\begin{aligned}
    &\int_0^1 xf(x)\cdot dx
    \\&=\int_0^1 x^nn\cdot dx
    \\&=\frac{n}{n+1}
\end{aligned}$$

接下来我们考虑证明题面给出的性质，注意到我们计算的是集合的 $\min_k$，所以我们可以考虑通过拓展 $\min-\max$ 容斥来计算答案：

$$\begin{aligned}
    &E(\min_k(x))=\sum_{i=k}^n \binom{n}{i}\binom{i-1}{k-1}(-1)^{i-k}\frac{i}{i+1}
    \\&=k\sum_{i=k}^n \binom{n}{i}\binom{i}{k}(-1)^{i-k}\frac{1}{i+1}
    \\&={k}\binom{n}{k}\sum_{i=k}^n \binom{n-k}{i-k}(-1)^{i-k}\frac{1}{i+1}
    \\&={k} \binom{n}{k}\sum_{j=0}^{n-k} \binom{n-k}{j} (-1)^j \frac{1}{j+k+1}
\end{aligned}$$

设 $m=n-k$

$$\begin{aligned}
    &{k} \binom{n}{k}\sum_{j=0}^{m} \binom{m}{j} (-1)^j \frac{1}{j+k+1}
    \\&={k} \binom{n}{k} \sum_{j=0}^m \binom{m}{j} (-1)^j \int_0^1 x^{j+k}
    \\&={k}\binom{n}{k}\sum_{j=0}^m \binom{m}{j}\int_0^1 x^k(-x)^j
    \\&={k}\binom{n}{k}\int_0^1 x^k\sum_j^m(-x)^j \binom{m}{j}
    \\&={k}\binom{n}{k}\int_0^1 x^k(1-x)^m
    \\&={k} \times \frac{n!}{k!(n-k)!}\times \frac{k!m!}{(m+k+1)!}
    \\&=\frac{k}{n+1}
\end{aligned}$$

于是得证。

最后一步是**分部积分**的结论，下面也给出证明：

考虑： 

$$\begin{aligned}
    &f(x)g(x)=\int f'(x)g(x)+\int f(x)g'(x)
    \\&\int f'(x)g(x)=f(x)g(x)-\int f(x)g'(x)
\end{aligned}$$

设 $B(a+b,b)=\int_0^1 x^a(1-x)^b$，那么不难发现：

- $f(x)=\frac{x^a}{a+1},g(x)=(1-x)^b$

$$\begin{aligned}
    &B(a+b,b)=\int_0^1 f'(x)g(x)
    \\&=f(1)g(1)-\int_0^1 f(x)g'(x)
    \\&=-\int_0^1 \frac{x^{a+1}}{a+1}\times (-b(1-x)^{b-1})
    \\&=\frac{b}{a+1}\int_0^1 x^{a+1}(1-x)^{b-1}
    \\&=\frac{b}{a+1}B(a+b,b-1)
\end{aligned}$$

观察到 $B(a+b,0)=\int_0^1 x^{a+b}=\frac{1}{a+b+1}$，不难得到 $B(a+b,b)=\frac{b!}{(a+b+1)^{\underline{b+1}}}=\frac{a!b!}{(a+b+1)!}$

至此，命题得证。




----

注意到答案是：

$$\int_0^1 dx\times P(X=x)x$$

构造 $g(x)=P(X\le x)$，那么 $P(X=x)$ 为 $g(x)$ 的导数。

于是答案即为：

$$\int_0^1 dx\cdot g'(x)x=g(x)x-\int_0^1 dx\cdot g(x)$$

不难发现答案即为：

$$1-\int_0^1 dx\cdot P(X\le x)$$

后者等价于仅保留小于 $x$ 的边有此图联通。

可以基于这样的考量，我们给每条边赋予 $0/1$ 的权值表示他是否小于等于 $x$，如果为 $1$ 那么小于等于 $x$，不妨假设有 $a$ 条 $1$ 边和 $(m-a)$ 条 $0$ 边，此时概率角度的贡献为：

$$x^a(1-x)^{m-a}$$

对于某个具体的 $a$，我们相当于计算：

$$\int_0^1 x^a(1-x)^{m-a}=\frac{a!(m-a)!}{(m+1)!}$$

于是我们成功的再次通过分部积分将此问题转换为给边染色，恰好染 $a$ 条黑色边使得这张图联通的方案数。

等价于求这张图的恰好 $a$ 条边的联通子图的数量。

经典的容斥手段是对于子集 $S$ 先任意保留边，在枚举 $1$ 号点所在的连通块，这里我们还需要枚举 $1$ 所在的连通块所保留的边数，此时外部的边数是固定的，然后转移，复杂度为 $\mathcal O(3^n\cdot m^2)$。

不难发现转移的时候的卷积为子集卷积，可以通过 FWT 处理做到 $\mathcal O(2^nn^2\cdot m^2)$，不过意义不大。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 10 + 5 ; 
const int M = 60 ; 
int n, m, lim, g[1 << 11] ; 
long double f[1 << 11][M], C[M][M], fac[M] ; 
signed main()
{
	n = gi(), m = gi() ; int x, y ; 
	rep( i, 1, m ) 
		x = gi() - 1, y = gi() - 1, 
		++ g[(1 << x) | (1 << y)] ;
	lim = (1 << n) ;
	for(re int k = 1; k < lim; k <<= 1 ) 
	rep( i, 0, lim ) if(i & k) g[i] += g[i ^ k] ; 
	C[0][0] = 1, f[0][0] = 1, fac[0] = 1 ; 
	rep( i, 1, m ) rep( j, 0, i ) C[i][j] = (!j) ? 1 : C[i - 1][j - 1] + C[i - 1][j] ; 
	rep( i, 1, m + 1 ) fac[i] = fac[i - 1] * i ; 
	for(re int S = 1; S < lim; ++ S) {
		int p = n ;
		rep( j, 0, n - 1 ) if((1 << j) & S) { p = j ; break ; } 
		rep( j, 0, m ) f[S][j] = C[g[S]][j] ; 
		for(re int i = S; i; i = (i - 1) & S) {
			if((!(i & (1 << p))) || (i == S)) continue ; 
			int u = S ^ i, l = g[i], r = g[u] ; 
			rep( j, 0, l ) rep( k, 0, r ) 
			f[S][j + k] -= f[i][j] * C[r][k] ;
		}
	}
	long double Ans = 1 ; -- lim ; 
	rep( j, 0, m ) Ans -= f[lim][j] / fac[m + 1] * fac[j] * fac[m - j] ;
	printf("%.6Lf\n", Ans ) ; 
	return 0 ;
}
```


---

## 作者：Kitahara_Haruki (赞：4)

### *积分大佬太强了*   
>>>>不会积分的我瑟瑟发抖

>对于期望 $E=\sum {P_1(i)*W(i)}$ 
>>其中 i 即用前i短的边构造最小生成树路( i ≤ M )

>而题目后方良心的出题人告诉我们 $ W(i)=i/(M+1) $

>那么$(M+1)*E=\sum  P_1(i)*i $ 

>而对于 $P(i)*i $这个式子，我们可以理解为$P(i)$被加上了 i 次，即在每一个≤i 的i 处都被加上了一次

>那么$(M+1)*E=\sum P_1(x≥i)$ ,而这个式子任然是难以处理的

>从最小生成树的性质可以得到 最大边大于等于i的最小生成树的概率 等于 最大边（严格）小于i无法构成最小生成树的概率

>那么最终$(M+1)*E=\sum P_2(i-1)$

>对于$P_2$我们就有办法求了

>$P_2=F(j)/(_j^m)$ 

>>其中$F(j)$表示选出j条边无法构成最小生成树的方案数

>>>对于$F(j)$的求解我们可以状压DP

>>>令$F[i][j]$表示 点集为 i 选这i个点之间 j 条边无法连通的方案数

>>>而若要求解此数组，我们还需要设出$G[i][j]$表示 可以连通的方案数

>>>这样我们可以构造出递推式

>>>$F[i][j]=G[i_2][j_2]*(_{j-j_2}^{Cnt[i-i_2]})$

>>>其中$Cnt[i]$是来计算点集 i 所含边数（两端点都在点集中）

>>>而简单的

>>>>$G[i][j]=(_i^{Cnt[i]})-F[i][j]$

### 然后就可以A了，虽然我还是被long long坑了。。。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int Nn=15;
const int Mm=50;
typedef long long ll;
int N,M;
ll Edg[Nn],S[1<<Nn],Cnt[1<<Nn],C[Mm][Mm],G[1<<Nn][Mm],F[1<<Nn][Mm];
int main(){
	scanf("%d%d",&N,&M);
	for(int i=1,x,y;i<=M;i++){
		scanf("%d%d",&x,&y);
		Edg[x]|=(1<<y-1);
		Edg[y]|=(1<<x-1);
	}
	for(int i=1;i<1<<N;i++)
	 S[i]=S[i>>1]+(i&1);
	for(int i=1;i<1<<N;i++){
		for(int k=1;k<=N;k++)
		if((1<<k-1)&i) Cnt[i]+=S[Edg[k]&i];
		Cnt[i]>>=1;
	}
	for(int i=0;i<=Mm;i++){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;j++)
		 C[i][j]=C[i-1][j]+C[i-1][j-1];
	}
	
	for(int i=0;i<1<<N;i++){
		if(S[i]==1){
			G[i][0]=1;
			continue ;
		}
		int t=i&(-i);
		for(int j=(i-1)&i;j;j=(j-1)&i)
		if(j&t)
		for(int a=0;a<=Cnt[j];a++)
		for(int b=0;b<=Cnt[i-j];b++)
		 F[i][a+b]+=G[j][a]*C[Cnt[i-j]][b];
		for(int j=0;j<=Cnt[i];j++)
		 G[i][j]=C[Cnt[i]][j]-F[i][j];
	}
	
	double Ans=0.0;
	for(int i=0;i<=M;i++)
	 Ans+=double(F[(1<<N)-1][i])/(double)C[M][i];
	printf("%.6f\n",Ans/(double)(M+1));
	return 0;
}
```

---

## 作者：木xx木大 (赞：1)

[P3343 [ZJOI2015]地震后的幻想乡](https://www.luogu.com.cn/problem/P3343) 

参考了给我推这道题的学长的[博客](https://www.cnblogs.com/zyt1253679098/p/10913026.html)，在这里orz!

根据期望的线性性我们得到 $ans=\sum_{k=1}^{m} 任选 k 条边恰好联通 n 个点的概率 \times  第 k大的边权的期望（即提示中的 \frac{k}{m+1}）$。

恰好连通的概率就是恰好连通的方案数除以总方案数（$C_{m+1}^{k}$ ）。

**恰好连通**的方案数很难求，那么我们**正难则反**，尝试求出图不连通的方案数。设 $g_{S,i}$ 表示选 $i$ 条边后 $S$ 点集中的点**还没有连通**的方案数， 则恰好连通的方案数$=g_{S,i-1}-g_{S,i}$ 。现在，这个期望题已经被转化为了一个计数问题。

为了保证 $g_{S,i}$ 的转移不重不漏，我们参考[P5933 [清华集训2012]串珠子](https://www.luogu.com.cn/problem/solution/P5933)的做法，枚举某个特定点所在的连通块的情况，这个连通块以外的部分随便选，即 $g_{S,i}=\sum_{T  \subseteq  S,lowbit(T)=lowbit(S)}\sum_{j=1}^{m}(C_{num_T}^{j}-g_{T,j})\times C_{num_{S-T}}^{i-j}$ 。解释一下，$T$ 为 $S$ 的真子集且 $lowbit(T)=lowbit(S)$（即把 $S$ 中编号最小的点作为上面说的特定点），$num_T$ 表示两端均在 $T$ 点集中的边数，$S-T$ 为 $T$ 在 $S$ 中的补集 ， $C_{num_T}^{j}-g_{T,j}$ 表示在 $T$ 中选 $j$ 条边使其连通（不一定恰好）的方案数。暴力转移即可，复杂度应该是 $O(3^nm)$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace FGF
{
	int n,m;
	const int N=15;
	struct edg{
		int u,v;
	}e[N*N];
	ll g[1<<N][N*N],C[N*N][N*N],num[1<<N];
	double ans;
	void work()
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++)
			scanf("%d%d",&e[i].u,&e[i].v),e[i].u--,e[i].v--; 
		for(int i=1;i<(1<<n);i++)
			for(int j=1;j<=m;j++)
				if((i&(1<<e[j].u))&&(i&(1<<e[j].v)))num[i]++;
		for(int i=0;i<=m;i++)
		{
			C[i][0]=1;
			for(int j=1;j<=i;j++)
				C[i][j]=C[i-1][j]+C[i-1][j-1];
		}
		for(int S=1;S<(1<<n);S++)
		{
			for(int T=S&(S-1);T;T=(T-1)&S)
				if((S&(-S))==(T&(-T)))
					for(int i=0;i<=num[S];i++)
						for(int j=0;j<=i;j++)
							g[S][i]+=(C[num[T]][j]-g[T][j])*C[num[S^T]][i-j];
		}
		for(int i=1;i<=m;i++)
			ans+=(double)i/(m+1)*((double)g[(1<<n)-1][i-1]/C[m][i-1]-(double)g[(1<<n)-1][i]/C[m][i]);
		printf("%.6f",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```



---


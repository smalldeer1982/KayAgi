# [THUWC 2017] 随机二分图

## 题目背景

# 滥用本题评测将被封号

## 题目描述

某人在玩一个非常神奇的游戏。这个游戏中有一个左右各 $n$ 个点的二分图，图中的边会按照一定的规律随机出现。

为了描述这些规律，某人将这些边分到若干个组中。每条边或者不属于任何组 （这样的边一定不会出现），或者只属于一个组。

有且仅有以下三类边的分组：

0.  这类组每组只有一条边，该条边恰好有 $50\%$ 的概率出现。

1. 这类组每组恰好有两条边，这两条边有 $50\%$ 的概率同时出现，有 $50\%$ 的概率同时不出现。
2. 这类组每组恰好有两条边，这两条边恰好出现一条，各有 $50\%$ 的概率出现。

组和组之间边的出现都是完全独立的。

某人现在知道了边的分组和组的种类，想要知道完美匹配数量的期望是多少。你能帮助她解决这个问题吗？

## 说明/提示

## 【定义解释】

如果你对完美匹配和期望的定义很熟悉，那么你可以跳过本段。

对于一个左右各 $n$ 个点的二分图，它的一个完美匹配是指 $n$ 条没有公共点的边构成的匹配。

两个完美匹配不同，当且仅当它们至少含有一条不同的边。一个二分图完美匹配的数量定义为这张图能找到的两两不同的完美匹配的数量。

在题目的图中，边都是随机出现的，因此这个图中完美匹配的数量是一个随机变量。一个（离散型）随机变量 $X$ 的期望定义为以概率为权，$X$ 所有可能取值的加权平均数，即
$$
\sum_{x \in V(X)}P[X=x]\cdot x
$$
其中 $V(X)$ 表示 $X$ 所有可能的取值集合，$P[X=x]$ 表示 $X$ 取值为 $x$ 的概率。

## 【数据规模和约定】

对于 $5\%$ 的数据 $n \le 5$ 。  
对于另 $5\%$ 的数据 $n \le 8$ 。  
对于另 $10\%$ 的数据 $n \le 10$ 。  
对于另 $15\%$ 的数据，只有$t = 0$ 的情况。  
对于另 $5\%$ 的数据，只有$t = 0$ 的情况，且$m = n^2$，也就是该图为一个完全图。  
对于另 $20\%$ 的数据，只有 $t =0$ 或者 $t=1$ 的情况。
对于另 $20\%$ 的数据，只有 $t =0$ 或者 $t=2$ 的情况。
对于 $100\%$ 的数据，$n \le 15$。

## 样例 #1

### 输入

```
2 2
1 2 1 2 2
2 1 2 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5
1 1 2 3 3
1 3 2 2 2
1 1 1 1 3
1 2 1 3 1
0 2 3```

### 输出

```
7```

## 样例 #3

### 输入

```
4 9
2 4 1 4 2
1 3 2 1 4
2 2 1 4 4
2 3 4 1 1
2 4 3 2 4
2 2 2 3 1
0 1 3
0 3 3
1 2 3 1 2```

### 输出

```
20```

# 题解

## 作者：duyi (赞：14)

**洛谷的latex有严重的问题，请务必在我的cnblogs查看本文！**

[链接](https://www.cnblogs.com/dysyn1314/p/14464815.html)


# LOJ2290 「THUWC 2017」随机二分图

[题目链接](https://loj.ac/p/2290)

## 本题题解

设完美匹配数量的期望是 $E$。根据期望的定义：
$$
E = \sum_{一张图} (\text{这张图出现的概率})\times (\text{这张图的完美匹配数量})
$$
根据期望的线性性，可以转化为：
$$
E = \sum_{一组完美匹配}(这组完美匹配出现的概率)
$$
暴力做法，可以 $\mathcal{O}(n!)$ 枚举一组完美匹配，计算它出现的概率。

计算一组完美匹配出现的概率，只需要考虑这组完美匹配里的边。举个例子，你要求抛 $3$ 次硬币，前两次都是正面朝上的概率，这个概率就是 $\frac{1}{2} \cdot \frac{1}{2}$，而不需要考虑第三次的结果。同理，本题里，在计算时，只需要保证当前这组完美匹配里的边都在图上出现了，而其它边是否出现则不用管。

优化上述暴力。考虑使用状压 DP。当只有 $t = 0$ 时，可以设 $\mathrm{dp}_0(i, s)$，其中 $s$ 是一个二进制状态，表示考虑了左边的前 $i$ 个点，匹配掉了右边 $s$ 里这些点，发生的概率。转移时枚举左边第 $i + 1$ 个点匹配了右边的哪个点，乘上概率 $\frac{1}{2}$，进行转移。最后 $E = \mathrm{dp}_0(n, 2^n - 1)$。

当有 $t = 1$ 和 $t = 2$ 时，要注意到：题目限制了一组里两条边在图上的出现情况，但并未直接限制它们在完美匹配里的出现情况。例如：对于 $t = 1$ 的两条边 $(a_1, b_1),(a_2, b_2)$，它们在图上要么同时出现，要么同时不出现（这是题目要求的），但在完美匹配里，可能只有 $(a_1, b_1)$，或只有 $(a_2, b_2)$，或两个都有，或两个都没有（当然，根据前面的讨论，两个都没有时不用管，我们只计算出现了的边出现的概率）。也就是说，一条边出现在图里和出现在完美匹配里，是两回事，在接下来读题解时，不要把它们搞混了。

因为涉及到要同时加入两条边，我们把 DP 状态改一改。设 $\mathrm{dp}_1(s_1, s_2)$ 表示左边 $s_1$ 里这些点匹配了右边 $s_2$ 里这些点（$s_1, s_2$ 二进制下 $1$ 的个数相同）。但是转移时遇到麻烦了。例如我要考虑，【只有 $(a_1,b_1)$ 出现在完美匹配里】的情况，那这个状态相当于要带一个附件要求：在此后的转移里，不能单独选 $(a_2, b_2)$（否则就和【$(a_1, b_1)$，$(a_2, b_2)$ 同时出现在完美匹配里】这种情况重复了）。但是你又不好把这个附加要求写进 DP 状态里，于是就会算进去一些不该算的东西，导致答案错误。

怎么办？本题的精髓就在这里了。将一组 $t = 1$ 的两条边拆开！假装它们就是 $t = 0$ 的两组边。观察此时在计算答案时，会是什么效果：

- 如果在最终的完美匹配里只出现了 $(a_1, b_1)$，那在我们统计时它对概率的贡献是 $\frac{1}{2}$。它代表的实际情况是：$(a_1, b_1)$ 和 $(a_2, b_2)$ 都在图里，我们知道这种情况实际出现的概率也是 $\frac{1}{2}$。所以算的就是对的！
- 如果在最终的完美匹配里只出现了 $(a_2, b_2)$，和上一种情况同理。
- 如果在最终的完美匹配里，同时出现了 $(a_1, b_1)$ 和 $(a_2, b_2)$，则统计时对概率的贡献是 $\frac{1}{4}$。但是它代表的实际情况是 $(a_1, b_1)$ 和 $(a_2, b_2)$ 都在图里，我们知道这种情况出现的概率其实是 $\frac{1}{2}$。所以这里就少算了 $\frac{1}{4}$。怎么办？根据期望的线性性，我们单独把这少算的 $\frac{1}{4}$ 加回来就行了！所以我们新建一种转移，同时取 $(a_1,b_1)$ 和 $(a_2,b_2)$，且这种转移的系数是 $\frac{1}{4}$。
- 如果都没出现，不用管。

$t = 2$ 是类似的。【在最终的完美匹配里，同时出现了 $(a_1, b_1)$ 和 $(a_2, b_2)$】，这种情况在统计时对概率的贡献是 $\frac{1}{4}$，但实际上它发生的概率是 $0$。所以我们要想办法减掉这 $\frac{1}{4}$。新建一种系数是 $-\frac{1}{4}$ 的转移即可。

此外，一定不要把【相同的匹配、不同的加入顺序】当成不同的方案。解决的方法是转移时，强制选当前左边（$s_1$ 里）编号最小（或最大）的一个空点进行转移。

上述状压 DP，看起来时间复杂度是 $\mathcal{O}(2^{2n}\cdot n^2)$。但其实有了【$s_1, s_2$ 二进制下 $1$ 的个数相同】这个要求后，状态数从 $2^{2n}$ 减小至 $\sum_{i = 0}^{n}{n\choose i}^2 = {2n\choose n}\approx 1.5\cdot 10^8$。仍然有些大。但我们可以用 $\texttt{std::map}$ 存状态，使用记忆化搜索进行 DP，即可通过本题。

## 参考代码

放一个网上的，很好看的代码。

```cpp
/*program by mangoyang*/
#pragma GCC optimize("Ofast", "inline")
#include<bits/stdc++.h>
#define inf ((int)(1e9))
#define Max(a, b) ((a) > (b) ? (a) : (b))
#define Min(a, b) ((a) < (b) ? (a) : (b))
typedef long long ll;
using namespace std;
template <class T>
inline void read(T &x){
    int f = 0, ch = 0; x = 0;
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') f = 1;
    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;
    if(f) x = -x;
}
const int INV2 = 500000004, INV4 = 250000002, mod = 1e9 + 7;
map<int, int> f;
int a[300], b[300], n, m, cnt;

inline int Pow(int a, int b){
	int ans = 1;
	for(; b; b >>= 1, a = 1ll * a * a % mod)
		if(b & 1) ans = 1ll * ans * a % mod;
	return ans;
}

inline int dfs(int mask){
	if(mask == (1 << (n << 1)) - 1) return 1;
	if(f.count(mask)) return f[mask];
	int now = 0, tmp = 0;
	for(int i = n - 1; ~i; i--)
		if(!((1 << i) & mask)) now = (1 << i);
	for(int i = 1; i <= cnt; i++)
		if((now & a[i]) && !(mask & a[i]))
			(tmp += 1ll * dfs(mask | a[i]) * b[i] % mod) %= mod;
	return f[mask] = tmp;
}

int main(){
	read(n), read(m);
	for(int i = 1, op, x, y; i <= m; i++){
		read(op), read(x), read(y), x--, y--;
		int tmp = (1 << x) | (1 << y + n);
		a[++cnt] = tmp, b[cnt] = INV2;
		if(op){
			read(x), read(y), x--, y--;
			a[++cnt] = (1 << x) | (1 << y + n), b[cnt] = INV2;
			if(tmp & ((1 << x) | (1 << y + n))) continue;
			tmp |= (1 << x) | (1 << y + n);
			a[++cnt] = tmp, b[cnt] = op == 1 ? INV4 : -INV4 + mod;
		}
	}
	cout << 1ll * dfs(0) * Pow(2, n) % mod << endl;
	return 0;
}
```





---

## 作者：lhm_ (赞：11)

根据题意，题目中所求的即为所有$n!$种完美匹配的各自的出现概率之和再乘上$2^n$的值。

发现$n$很小，考虑状压$DP$。设$f_{S,T}$为左部图匹配情况为$S$，右部图匹配情况为$T$的期望，可以得到转移为：
 $$
 
 f_{S,T}=\sum_{x \subseteqq S \land y \subseteqq T }f_{S \oplus x,T \oplus y} \times p_e
 
 $$

其中$x,y$为边$e$的在两个部图的两个端点，$p_e$为这条边的出现概率，转移的含义为加上$e$这条边后$x$和$y$实现了匹配。

发现直接这样转移会算重，所以要事先固定一种转移顺序，可以是每次在$S$中去除最高位来转移，也就是从低位向高位转移，这样就保证不会算重了。

然后考虑如何解决每条边的出现概率，第一组边不用特殊考虑，概率为$\frac{1}{2}$。考虑是否可以把第二组和第三组边也转化为第一种的形式。可以先将第二组和第三组边的两条边都以概率为$\frac{1}{2}$加入，对于第二组边，这时两条边同时出现的概率为$\frac{1}{4}$，不符合题目$\frac{1}{2}$的要求，因此再加入同时选这两条边的情况，概率为$\frac{1}{4}$，对于第三组边，再加入同时选这两条边的情况，概率为$-\frac{1}{4}$。根据期望的线性性，发现这样处理是正确的，并且恰好符合了题目的要求。

第二组和第三组边中，若两条边有交集，即两条边为一个点连向另外两个点，此时是不用加上同时选这两条边的情况的，因为题目所求为完美匹配，一个点匹配两个点的情况是不存在的。

处理完边后，记忆化搜索来实现状压$DP$即可。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxs 70010
#define p 1000000007
#define inv2 500000004
#define inv4 250000002
#define sta(x) (1<<(x-1))
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,cnt;
map<int,ll> f[maxs];
struct node
{
    ll s,t,v;
}e[maxs];
ll dp(int S,int T)
{
    if(!S) return 1;
    if(f[S].count(T)) return f[S][T];
    for(int i=1;i<=cnt;++i)
    {
        ll s=e[i].s,t=e[i].t,v=e[i].v;
        if((S|s)!=S||(T|t)!=T||S>=(s<<1)) continue;
        f[S][T]=(f[S][T]+dp(S^s,T^t)*v%p)%p;
    }
    return f[S][T];
}
int main()
{
    read(n),read(m);
    for(int i=1;i<=m;++i)
    {
        int opt,x,y;
        read(opt),read(x),read(y),e[++cnt]=(node){sta(x),sta(y),inv2};
        if(opt)
        {
            read(x),read(y);
            if(!((sta(x)&e[cnt].s)||(sta(y)&e[cnt].t)))
            {
                cnt++;
                if(opt==1) e[cnt]=(node){sta(x)|e[cnt-1].s,sta(y)|e[cnt-1].t,inv4};
                else e[cnt]=(node){sta(x)|e[cnt-1].s,sta(y)|e[cnt-1].t,p-inv4};
            }
            e[++cnt]=(node){sta(x),sta(y),inv2};
        }
    }
    printf("%lld",dp((1<<n)-1,(1<<n)-1)*(1<<n)%p);
    return 0;
}
```

---

## 作者：s_r_f (赞：11)

注意数据范围是n ≤ 15.

可以状压,把 2n 个点的匹配情况压到一个int里去。

然后dp.

接下来我们要处理每个边组。

对于类型为0的边组，直接建边。

对于类型为1的边组(a,b)(c,d)，我们可以先建两条概率为50%的边，再建一个概率为25%的边组。

对于类型为2的边组(a,b)(c,d)，我们可以先建两条概率为50%的边，再建一个概率为-25%的边组。

具体怎么实现？**把边和边组也压成int,转移时直接异或(^)即可。**

我们发现这样的代码会TLE.

怎么办呢?

对于一个状态S,转移的时候**强制**要转移走它的**最低位**(lowbit).

然后**我们存不下2^2N的f数组**,所以我们用map,再加上记忆化搜索即可。

代码：
```
#include <bits/stdc++.h>
#define LL long long
#define N 16
#define M 270

using namespace std;

inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c <='9' && c >='0') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}

inline void write(int x){
    int k = 0;char put[40];
    if (!x) putchar('0');
    if (x < 0) putchar('-'),x = -x;
    while (x)  put[++k] = (x % 10) + '0',x /= 10;
    while (k)  putchar(put[k]),--k;
    putchar('\n');
}

const int P = 1000000007;

int n,m,inv2,inv4,rp;
int tp,u1,v1,u2,v2;
LL ALL,Pow[N<<1],Ans;

struct Node{
    LL S,w;
}tmp;

Node a[64][M]; int cnt[64];
map<LL,LL>f[1<<N];

inline void add(){
    for (int i = 1; i <= n; ++i)
        if (Pow[i] & tmp.S){//直接在加边的时候枚举最低位
            ++cnt[i];
            a[i][ cnt[i] ] = tmp;
            return;
        }
}

LL dp(LL S){
	int p,s = S & ((1<<n) - 1),t = S >> n;
	
    if (!S) return 1;
    if (f[s].count(t)) return f[s][t];
    LL ans = 0;
    
    for (int i = 1; i <= n; ++i) if (S & Pow[i]) {p = i;break;}
    for (int i = 1; i <= cnt[p]; ++i)//只用最低位为第p位的边转移
        if ((S & a[p][i].S) == a[p][i].S)
            ans = (ans + dp(S^a[p][i].S) * a[p][i].w % P) % P;
    
    f[s][t] = ans;//记忆化
    return ans;
}

LL s1,s2;

int main(){
    inv2 = (P + 1) / 2;
    inv4 = (P + 1) / 4;
    rp = P - inv4;
    Pow[1] = 1;
    for (int i = 2; i <= 30; ++i) Pow[i] = Pow[i-1] << 1;
    
    n = read(),m = read();
    while (m--){//建边
        tp = read();
        if (!tp){
            u1 = read(),v1 = read();
            tmp.S = Pow[u1]|Pow[v1 + n];
            tmp.w = inv2;
            add();
        }
        else if (tp == 1){
            u1 = read(),v1 = read(),u2 = read(),v2 = read(); 
            s1 = Pow[u1] | Pow[v1 + n];//用位运算,卡常
            s2 = Pow[u2] | Pow[v2 + n];
            tmp.S = s1;
            tmp.w = inv2;
            add();
            
            tmp.S = s2;
            tmp.w = inv2;
            add();
            
            if (s1&s2) continue;
            tmp.S = s1|s2;
            tmp.w = inv4;
            add();
        }
        else{
            u1 = read(),v1 = read(),u2 = read(),v2 = read(); 
            s1 = Pow[u1] | Pow[v1 + n];
            s2 = Pow[u2] | Pow[v2 + n];
            tmp.S = s1;
            tmp.w = inv2;
            add();
            
            tmp.S = s2;
            tmp.w = inv2;
            add();
            
            if (s1&s2) continue;
            
            tmp.S = s1|s2;
            tmp.w = rp;
            add();
        }
    }
    
    ALL = 0;
    for (int i = 1; i <= n*2; ++i) ALL += Pow[i];
    Ans = dp(ALL) % P * Pow[n+1] % P;//直接对ALL进行记忆化搜索
    write(Ans);
    return 0;
}
```

没开O2,所以只卡进了5秒qwq...

---

## 作者：asuldb (赞：6)

[题目](https://www.luogu.com.cn/problem/P4547)

orz神仙题

考虑只有$t=0$的时候怎么做

其实等价于求完美匹配的个数，但是我们有一个更为一般的$dp$可以写，设$dp_{S,T}$表示在一左部点里匹配的点集是$S$，右部点里匹配的点集是$T$的期望完美匹配个数

我们可以枚举一条边$(i,j)$，表示当前匹配的边是$(i,j)$，于是就有

$$dp_{S,T}=\sum_{i\notin S,j\notin T,(i,j)\in E}dp_{S/i,T/j}\times p_{i,j}$$

$S/i$表示集合$S$去掉$i$后的到的集合

但是这样求出来的东西好像不是很对，因为对于某一种完全匹配，我们按照不同的加边顺序算了多次，于是我们钦定一个加边顺序，比如先加入编号小的点，这样就不会算重

由于$|S|=|T|$，所以这样的复杂度是$\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}$，还是比较科学的

再来考虑$t>0$的情况

对于$t=1$的边组$(u,v,a,b)$，我们还是先把$(a,b),(u,v)$都加入边集出现的概率视为$\frac{1}{2}$；对于一组完美匹配，如果$(a,b),(u,v)$其中之一出现在了里面，那么我们算进去的概率是$\frac{1}{2}$，这符合题意：但是当$(a,b),(u,v)$都出现了，我们算的概率是$\frac{1}{2}\times \frac{1}{2}=\frac{1}{4}$，但真实的出现概率却是$\frac{1}{2}$

所以只有在这两条边都出现的情况下我们才会错误计算，于是我们加一条四元边$(u,v,a,b)$，出现概率为$\frac{1}{4}$，这样对于一组$(a,b),(u,v)$都出现的完美匹配，我们计算的概率就是$\frac{1}{4}+ \frac{1}{4}=\frac{1}{2}$，这样算就正确了。

同理，对于$t=2$的情况，我们加一条四元边$(u,v,a,b)$出现的概率为$-\frac{1}{4}$即可

代码
```cpp
#include <tr1/unordered_map>
#include <bits/stdc++.h>
#define re register
using namespace std::tr1;
const int mod = 1e9 + 7, inv2 = 500000004, inv4 = 250000002, _inv4 = 750000005;
unordered_map<int, int> dp, f;
inline int qm(int x) { return x >= mod ? x - mod : x; }
int se[5005], sp[5005], n, m, M;
int dfs(int s) {
    if (!s)
        return 1;
    if (f[s])
        return dp[s];
    int res = 0;
    f[s] = 1;
    for (re int i = 1; i <= M; i++)
        if ((se[i] & s) == se[i] && se[i] > s / 2)
            res = qm(res + 1ll * sp[i] * dfs(se[i] ^ s) % mod);
    // printf("%d %d\n",s,res);
    return dp[s] = res;
}
int main() {
    scanf("%d%d", &n, &m);
    for (re int t, u, v, a, b, i = 1; i <= m; i++) {
        scanf("%d%d%d", &t, &u, &v);
        se[++M] = (1 << (u - 1)) | (1 << (v + n - 1));
        sp[M] = inv2;
        if (!t)
            continue;
        scanf("%d%d", &a, &b);
        se[++M] = (1 << (a - 1)) | (1 << (b + n - 1));
        sp[M] = inv2;
        if (se[M] & se[M - 1])
            continue;//当(a,b),(u,v)有交点的时候，由于不可能同时存在于完美匹配里，所以没有必要加入四元边
        se[M + 1] = se[M] | se[M - 1];
        sp[++M] = (t == 1 ? inv4 : _inv4);
    }
    // for(re int i=1;i<=M;i++) printf("%d %d\n",se[i],sp[i]);
    printf("%d\n", 1ll * (1 << n) * dfs((1 << (n + n)) - 1) % mod);
    return 0;
}

```




---

## 作者：shadowice1984 (赞：4)

这里会证明为什么这个诡异的算法是对的

_______________

题意比较清楚了这里就不在赘述

我也不知道那个乘$2^n$的条件有什么用，所以我是直接算出期望来然后乘的

我们发现一个非常重要的事实是，假设我们求出了这张图的一个完美匹配的边集，那么我们随便向这个边集里怼一些边也是不会改变这张图依然有完美匹配的性质的。

因此我们需要做的就是枚举所有可能的匹配方案然后把这些方案的概率加到一起就是我们需要的答案

那么我们怎么枚举呢？我们先来考虑所有的边都是第0类边组的情况

我们令$dp(S)$表示S这个集合实现完美匹配的期望数量，那么容易发现S的siz一定是个偶数，所以总的状态量是${30 \choose 15}$级别的

那么我们现在转移的时候为了不重不漏的枚举每一种方案，我们有必要给这个方案中的边排一个序，否则同一种边集将会以不同的顺序被计数好几次

那么我们就简单粗暴的按照左部点编号排序就行了

因此dp(S)转移的时候应该是枚举S的lowbit的所有出边，然后删掉这条出边进行转移，这样可以保证dp出来的所有方案中的边都是按照左部点编号排好序的，当然无论如何我们选择的边都只有0.5概率出现，所以答案要乘一个0.5

如此这般dp我们就可以解决所有边都是第0类边的情况了

那么问题来了我们还有边组的问题

先来考虑第一类边组，如果我们强行认为这两个边都是独立的话，第一条边单独出现在**匹配方案**中的概率是50%,第二条边单独出现在**匹配方案**中的概率是50%，两条边同时出现在**匹配方案**中的概率是25%

而真实情况是第一条边,第一条边单独出现在匹配方案中的概率是50%,同时出现在匹配方案的概率也是50%，出现这种情况是因为我们只关心出现在匹配方案中的边是否出现而不关心这张图里到底出现什么边

那么看起来情况比我们想像的简单，如果这两个边的左部点相同那么我们直接认为两条边相互之间独立，否则我们把左部点较大的边挂在左部点较小的边上，如果选择了那个左部点较小的边我们有25%的概率立即选择另一条边(前提是你能同时删掉这4个点)，这样的话我们概率就对上了

同时我们的方案现在也是排好序的，你可以认为一个边组的关键字是最小的左部点编号

同样的第2类边组其实就是两条边不可能同时出现，所以我们在选择第一条边的时候有-25%的概率选择第二条边即可

然后剩下的大力状压记忆化就行了

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<tr1/unordered_map>
using namespace std::tr1;
using namespace std;typedef unsigned long long ll;const int N=20;
const ll mod=1e9+7;const ll qu=250000002;const ll mqu=750000005;const ll ha=500000004;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
unordered_map <int,ll> dp;int mp[N];int tw[N][N];ll val[N][N];int n;int m;
inline ll dfs(int s)//记忆化
{
    if(s==0)return 1;if(dp.count(s))return dp[s];int mi=0;ll dv=0;
    for(int i=0;i<n;i++){if((s>>i)&1){mi=i;break;}}int p=(s>>15)&mp[mi];int del=s^(1<<mi);
    for(int i=0,k;i<n;i++)
        if((p>>i)&1)
        {
            k=del^(1<<(15+i));(dv+=ha*dfs(k))%=mod;int ne=tw[mi][i];
            if(ne&&((ne&k)==ne))(dv+=val[mi][i]*dfs(k^ne))%=mod;
        }
    return dp[s]=dv;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,t,u1,v1,u2,v2;i<=m;i++)
    {
        scanf("%d%d%d",&t,&u1,&v1);u1--;v1--;
        switch(t)
        {
            case 0:{mp[u1]|=(1<<v1);break;}
            case 1:
            {
                scanf("%d%d",&u2,&v2);u2--;v2--;
                if(u1>u2)swap(u1,u2),swap(v1,v2);mp[u1]|=(1<<v1);mp[u2]|=(1<<v2);
                tw[u1][v1]=(1<<u2)|(1<<(v2+15));val[u1][v1]=qu;break;
            }
            case 2:
            {
                scanf("%d%d",&u2,&v2);u2--;v2--;
                if(u1>u2)swap(u1,u2),swap(v1,v2);mp[u1]|=(1<<v1);mp[u2]|=(1<<v2);
                tw[u1][v1]=(1<<u2)|(1<<(v2+15));val[u1][v1]=mqu;break;
            }
        }
    }int s=(1<<n)-1;printf("%llu",dfs((s<<15)|s)*po(2,n)%mod);return 0;
}
```






---

## 作者：Erine (赞：1)

Tags: 状态压缩，记忆化搜索 dp，思维，trick。7.5。

十分深刻的题目。比较显然的一步是拆掉贡献，即求每种匹配出现概率之和。

如果只有 $t=0$ 显然可以状压 dp：$f_{S,T}$ 表示左边匹配了 $S$，右边匹配了 $T$ 的所有完美匹配概率之和。转移枚举一条边，为了防止同匹配异顺序算重，钦定选中的边左端点必须是 $S$ 的最低位。

$$f_{S,T}=\sum_{e\in E_0}[u_e=\operatorname{lowbit}(S)]\dfrac12 f_{S/\{u_e\},T/\{v_e\}}$$

考虑加上 $t=1$，此时等价于，**原图** 中两条边必须同时出现或者同时不出现；注意，这不等价于 **匹配** 中也是同时不出现的。

考虑某条限制 $(u_1,v_1,u_2,v_2)$，若某个匹配钦定了 $(u_1,v_1)$ 出现，概率是 $\dfrac 12$，恰好等于这条边出现概率本身；$(u_2,v_2)$ 同理；若钦定两者一起出现，概率是 $\dfrac 12$，但是如果算两条边相乘会算成 $\dfrac 14$，那么我们再加一种边“捆绑边”，出现概率是 $\dfrac 14$，就把这部分缺的营养给它补上了。

对于 $t=2$ 的边同理，做一个出现概率是 $-\dfrac 14$ 的“捆绑边”一起 dp 即可。看上去概率是 $-\dfrac{1}4$ 很扯淡，但是我们抛弃感性思考，拥抱理性愉悦，发现这是完全正确的。

同时对于边有交的 $t\neq 0$ 类限制就不用增加“捆绑边”了，因为 $t=1$ 不可能同时出现在匹配里，$t=2$ 同理。

跑一个记忆化搜索即可。复杂度是 $\Theta\left(\dbinom{2n}n n^2\right)$，实际上跑不到 6s。

```cpp
int dfs(int s, int t) {
	if (!s || !t) return 1;
	if (f[s].count(t)) return f[s][t];
	int low = s & -s, ans = 0;
	rep(i, 1, cnt) {
		int u = e[i].u, v = e[i].v, p = e[i].p;
		if ((u & s) == u && (v & t) == v && (u & low)) (ans += dfs(s ^ u, t ^ v) * p % mod) %= mod;
	}
	return f[s][t] = ans;
}

signed main() {
	n = read(), m = read();
	rep(i, 1, m) {
		int op = read();
		if (op == 0) {
			int u = read() - 1, v = read() - 1;
			e[++cnt] = {1 << u, 1 << v, inv2};
		} else if (op == 1) {
			int u1 = read() - 1, v1 = read() - 1;
			int u2 = read() - 1, v2 = read() - 1;
			e[++cnt] = {1 << u1, 1 << v1, inv2};
			e[++cnt] = {1 << u2, 1 << v2, inv2};
			if (u1 != u2 && v1 != v2) e[++cnt] = {(1 << u1) | (1 << u2), (1 << v1) | (1 << v2), inv4};
		} else {
			int u1 = read() - 1, v1 = read() - 1;
			int u2 = read() - 1, v2 = read() - 1;
			e[++cnt] = {1 << u1, 1 << v1, inv2};
			e[++cnt] = {1 << u2, 1 << v2, inv2};
			if (u1 != u2 && v1 != v2) e[++cnt] = {(1 << u1) | (1 << u2), (1 << v1) | (1 << v2), mod - inv4};
		}
	}
	write(dfs((1 << n) - 1, (1 << n) - 1) * (1 << n) % mod), pc('\n');
    return 0;
}
```

---

## 作者：Acoipp (赞：1)

做这道题就要敢设状态。

首先，把期望转化为每一种完美匹配出现的概率的和，然后再考虑解决此问题。

全 $0$ 的数据可以直接 $f_{i,S}$ 表示左边匹配了 $1 \sim i$ 号点，右边匹配了 $S$ 中的点的所有方案概率之和，这样做是 $O(2^nn^2)$ 左右的时间复杂度。

但是有 $1,2$ 的数据使得上面的方法不可取，大胆一点，直接设状态 $f_{S,T}$ 表示左边匹配了 $S$ 集合，右边匹配了 $T$ 集合的所有方案概率之和。

- 对于 $0$ 集合，可以直接加入，并且乘上 $\frac 12$。
- 对于 $1$ 集合，可以分开加入两条边，分开的概率是 $\frac 12$；或者同时加入这两条边，概率是 $\frac 14$。

计算一下，如果最终包含了 $1$ 集合的一条边，那么答案就会乘上 $\frac 12$；如果最终包含了 $1$ 集合的两条边，那么根据上述的计算方法，可以两条边分开加，一共的概率是 $\frac 12 \times \frac 12$；或者两条边一起加，概率为 $\frac 14$，总的概率为 $\frac 12$，符合题目要求。

- 对于 $2$ 集合，同 $1$ 集合的计算方式，但是同时加入这两条边的概率应该是 $-\frac 14$。

我们计算一下状态总数 $\sum_{i=0}^n (C_n^i)^2$，约等于 $1.5 \times 10^8$，但是因为我们钦定了加边的顺序，即每次添加边的时候一定要添加二分图左边编号最大的节点所在的边，状态数量就会大大减少。

最终我们用记忆化搜索实现即可。

代码如下，仅供参考：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define N 305
using namespace std;
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t = a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}
struct node{ll a,b;}p[N];
ll n,m,i,temp,inv2,inv4,ans;
struct hsh_table{
	ll val[2000005],val2[2000005],ne[2000005],head[2000005],tot=0;
	void clear(){
		for(ll i=1;i<=tot;i++) head[val[i]%1999997]=0,ne[i]=0;
		tot=0;
	}
	void insert(ll x,ll y){
		ll p = x%1999997;
		tot++;
		ne[tot] = head[p],head[p] = tot,val[tot] = x,val2[tot] = y;
	}	
	ll found(ll x){
		ll p = x%1999997;
		for(ll i=head[p];i;i=ne[i]) if(val[i]==x) return val2[i];
		return -1;
	}
}op;
inline ll dfs(ll S){
	if(S==((1<<(2*n))-1)) return 1;
	ll temp = op.found(S);
	if(temp!=-1) return temp;
	ll maxn = -1,ans = 0;
	for(ll i=n-1;i>=0;i--) if(!((S>>i)&1)){maxn=i;break;}
	for(ll i=1;i<=m;i++) if(((p[i].a>>maxn)&1)&&(!(S&p[i].a))) ans = (ans+dfs(S|p[i].a)*p[i].b)%mod;
	return op.insert(S,ans),ans;
}
int main(){
	ios::sync_with_stdio(false);
	inv2 = qmi(2,mod-2,mod),inv4 = qmi(4,mod-2,mod);
	cin>>n>>m;
	for(i=1;i<=m;i++){
		ll opt,a,b,c,d;
		cin>>opt>>a>>b,p[++temp]=(node){(1<<a-1)|(1<<b-1+n),inv2};
		if(opt>=1){
			cin>>c>>d,p[++temp]=(node){(1<<c-1)|(1<<d-1+n),inv2};
			if(a!=c&&b!=d) p[++temp]=(node){(1<<a-1)|(1<<b-1+n)|(1<<c-1)|(1<<d-1+n),opt==1?inv4:(mod-inv4)%mod};
		}
	}
	m = temp,ans = dfs(0);
	cout<<ans*qmi(2,n,mod)%mod<<endl;
	return 0;
}
```

---

## 作者：C20203030 (赞：1)

## 一、题目

[点此看题](https://www.luogu.org/problem/P4547)

## 二、解法

这道题一定不要考虑匈牙利算法，要不然暴搜都很难打。

**0x01 暴力**

还是讲一讲吧，考试的时候没打出来，枚举每个点匹配另外的一个点，时间复杂度$O(n!)$。

你可能要问，怎么建边？

对于情况一，我们直接建边并把边的概率设为$50\%$。

对于情况二，我们建出两条单独的边，并把边的概率设为$50\%$，等于这两条边可以以$50\%$单独用，也可以以$50\%$的概率一起用，所以我们在建一条概率为$25\%$的边，**强制连接两对点**。

对于情况三，仿照上面的做法，多建一条概率为$-25\%$的边，因为他们不能一起用。

然后就搜索，可以得$20pts$。

**0x02 状压**

既然$n$这么小，就考虑状压吧，设$dp[s1][s2]$为左边连接情况为$s1$，右边连接情况为$s2$，由于每个点都一定要被覆盖，然后转移的时候直接转移**最小的未被覆盖的点**（因为它总是要被覆盖），然后我们把边给搞成状压的形式，把全集传进去记忆化搜索，然后直接异或就可以了。

由于数组是开不下的，而只有两边覆盖点数相等的状态才是有用的，所以我们实际状态会小很多。

注意写的时候$map$判记忆化要用自带的$count$函数。

最后为什么这个算法能跑过去呢？我们考虑一下状态数，设操作次数为$x$，有$t$次会乱选（双边），所以状态数应该是$C_{n-x}^t\times C_n^{x}$（$t\leq x$），可以爆搜算一下，感性理解呢，就是状态数会此消彼长的状况中，在考虑我们的转移花费，由于没有重边，所以转移复杂度应该是$O(n)$的。

最后附上有注释的代码。


```cpp
#include <cstdio>
#include <map>
using namespace std;
#define int long long
//其实要开long long
#define P(x) (1<<x-1)
const int MOD = 1e9+7;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,all,tot,inv2,inv4,f[20];
map<int,int> dp[1<<15];
struct edge
{
    int S,p,next;
} e[1005];
int dfs(int S)
{
    int s1=S&((1<<n)-1),s2=S>>n,loc=0;//分离出两个部分
    if(!S) return 1;//出口
    if(dp[s1].count(s2)) return dp[s1][s2];//注意要用count判断，不然TLE
    for(int i=1; i<=n; i++)
        if(s1&(1<<i-1))
        {
            loc=i;    //找到第一个未被覆盖的
            break;
        }
    int t=0;
    for(int i=f[loc]; i; i=e[i].next)
        if((S&e[i].S)==e[i].S)
            t=(t+dfs(S^e[i].S)*e[i].p)%MOD;//从哪条边转移，求和期望
    return dp[s1][s2]=t;
}
signed main()
{
    n=read();
    m=read();
    all=(1<<(2*n))-1;//全集（把上下压在一起）
    inv2=(MOD+1)/2;
    inv4=(MOD+1)/4;//快速逆元，有点危险，不要乱用，还是要老老实实打快速幂
    for(int i=1; i<=m; i++)
    {
        int t=read();
        int a1=read(),b1=read();
        if(t==0)
        {
            //P是位运算的一个define
            e[++tot]=edge{P(a1)|P(b1+n),inv2,f[a1]},f[a1]=tot;//前向星，加给a1
            continue ;
        }
        int a2=read(),b2=read();
        if(a1>a2) swap(a1,a2),swap(b1,b2);//保证双边加在最小的编号上，因为dfs是取得是编号最小的
        e[++tot]=edge{P(a1)|P(b1+n),inv2,f[a1]},f[a1]=tot;
        e[++tot]=edge{P(a2)|P(b2+n),inv2,f[a2]},f[a2]=tot;
        if((P(a1)|P(b1+n))&(P(a2)|P(b2+n))) continue;
        if(t==1)
            e[++tot]=edge{P(a1)|P(b1+n)|P(a2)|P(b2+n),inv4,f[a1]},f[a1]=tot;//25%
        else
            e[++tot]=edge{P(a1)|P(b1+n)|P(a2)|P(b2+n),MOD-inv4,f[a1]},f[a1]=tot;//-25%
    }
    printf("%lld\n",(1<<n)*dfs(all)%MOD);
}
```



---

## 作者：Gmt丶FFF (赞：0)

非常有趣的思想。

首先假设没有 $1,2$ 组，就是一个非常简单的状压 dp，设 $f_{x,y}$ 为左边已匹配的集合为 $x$，右边已匹配的集合为 $y$ 的期望。

转移枚举每一条边即可，实现使用记忆化搜索，但因为 $2^{2n}$ 的空间开不下，且状态填不满，所以可以开一维，另一维使用 map。

现在出现了 $1,2$ 组，需要特殊的方式解决。

对于第一组，我们可以拆成两个 $0$ 组，但这样会导致两个同时选为 $\frac{1}{4}$，那么我们再多加一个 $\frac{1}{4}$ 的两个同时选的情况。

但有人可能会有这种疑问，这样不就会有几率只选一条边吗？

其实出现了这种情况不会有问题，因为我们选了两条边，实际上我们也可以只选一条，这样概率也为 $\frac{1}{2}$，所以不会有问题。

同理，对于第二组，我们拆成两个 $0$ 组，但这样就可能有 $\frac{1}{4}$ 的概率两个同时选，所以我们再多加一个 $-\frac{1}{4}$ 两个同时选的情况。

这样就都处理完了，时间复杂度为 $O(2^{2n}\times n^2)$，实际上跑不满，再加上时限充足，可以轻松通过。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<unordered_map>
#define int long long
using namespace std;
const int N=20;
const int M=1<<15;
const int mod=1e9+7;
int n,m;
unordered_map<int,int>f[M];
int quick_pow(int x,int y)
{
	int num=x,sum=1;
	while(y)
	{
		if(y&1)sum*=num,sum%=mod;
		num*=num,num%=mod;
		y>>=1;
	}
	return sum;
}
struct node
{
	int x,y,k;
};
vector<node>a;
int dfs(int x,int y)
{
//	cout<<x<<" "<<y<<endl;
	if(x==(1<<n)-1)return 1;
	if(f[x].count(y))return f[x][y];
	int num=0;
	for(int i=n-1;i>=0;i--)if(!((1<<i)&x))num=(1<<i);
	int len=a.size(),sum=0;
	for(int i=0;i<len;i++)
	{
		if(!(a[i].x&num))continue;
		if((x&(a[i].x))||(y&a[i].y))continue;
		sum+=dfs(x|a[i].x,y|a[i].y)*a[i].k%mod;
		sum%=mod;
	}
	return f[x][y]=sum;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	int num=quick_pow(2,mod-2),num2=quick_pow(4,mod-2);
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;
		scanf("%lld%lld%lld",&opt,&x,&y);
		a.push_back({(1<<(x-1)),(1<<(y-1)),num});
		if(opt==1||opt==2)
		{
			int t,p;
			scanf("%lld%lld",&t,&p);
			a.push_back({(1<<(t-1)),(1<<(p-1)),num});
			if(t!=x&&p!=y)
			{
				if(opt==1)a.push_back({(1<<(x-1))|(1<<(t-1)),(1<<(y-1))|(1<<(p-1)),num2});
				else a.push_back({(1<<(x-1))|(1<<(t-1)),(1<<(y-1))|(1<<(p-1)),mod-num2});
			}
		}
	}
	int res=dfs(0,0)*quick_pow(2,n)%mod;
	printf("%lld",res);
	return 0;
}
```


---

## 作者：lcyxds (赞：0)

状压当前二分图的状态，一共 $30$ 个点，`int` 正好可以存下

对于每条边无论在什么组里新建一条权值为 $0.5$ 的边；

对于第一种对两条边建权值为 $0.25$ 的边，第二种 $-0.25$。

建边的时候存下起点的位置（如果两条边就存在较小的那个起点下面，如果两条边有共同的起点或者终点就不加），这样可以在 DP 的时候不重不漏，而且提高效率。

DP 使用记忆化，开一个 `map`，于是跑的[这么慢](https://www.luogu.com.cn/record/48680601)，卡脖子5秒才能过。

这时候怎么办呢？我们需要比 `map` 更高效的数据结构~~然而我懒得手写一个~~

我们可以用 `unordered_map`！

把 `map` 换成 `unordered_map` ，跑的飞快，甚至时限开 1 秒都绰绰有余。

[链接](https://www.luogu.com.cn/record/48680905)


```cpp
#include <iostream>
#include <cstdio>
#include <tr1/unordered_map>
#define ll long long

using namespace std;

const ll _MOD = 1e9+7;
const ll _1_2 = 500000004;
const ll _1_4 = 250000002;
const ll __1_4 = 750000005;

struct Dual{
  int state;
  ll prob;
};

inline ll Pow(ll a, ll b) {
  ll res = 1;
  while (b) {
    if (b&1) res = res*a%_MOD;
    a = a*a%_MOD;
    b>>=1;
  }
  return res;
}

int _n, _m;
Dual _stateList[16][300];
tr1::unordered_map<int, ll> _dp;

ll Dp(int cur) {
  if (!cur) return 1;
  if (_dp.count(cur)) return _dp[cur];
  ll res = 0;
  int low = 1;
  int state;
  ll prob;
  while (!(cur&(1<<low))) low++;
  for (int i = 1; i <= _stateList[low][0].state; i++) {
    state = _stateList[low][i].state;
    prob = _stateList[low][i].prob;
    //cout << hex << state << ',' << dec << prob << endl;
    if ((state&cur)==state) {
      res = (res+prob*Dp(state^cur))%_MOD;
    }
  }
  //cout << "Dp(" << hex << cur << ")=" << dec << res << endl;
  _dp[cur] = res;
  return res;
}

void Add(int a, int b) {
  int pos = ++_stateList[a][0].state;
  _stateList[a][pos].state = (1<<a)|(1<<(b+16));
  _stateList[a][pos].prob = _1_2;
}

void AddTwo(int a1, int b1, int a2, int b2, ll prob) {
  if (a1==a2 || b1==b2) return;
  if (a1 > a2) {
    swap(a1, a2);
    swap(b1, b2);
  }
  int pos = ++_stateList[a1][0].state;
  _stateList[a1][pos].state = (1<<a1)|(1<<a2)|(1<<(b1+16))|(1<<(b2+16));
  _stateList[a1][pos].prob = prob;
}

int main() {
  int typ, a1, b1, a2, b2;
//   freopen("P4547.in", "r", stdin);
  scanf("%d%d", &_n, &_m);
  for (int i = 0; i < _m; i++) {
    scanf("%d", &typ);
    switch(typ) {
    case 0:
      scanf("%d%d", &a1, &b1);
      Add(a1, b1);
      break;
    case 1:
      scanf("%d%d%d%d", &a1, &b1, &a2, &b2);
      Add(a1, b1);
      Add(a2, b2);
      AddTwo(a1, b1, a2, b2, _1_4);
      break;
    default:
      scanf("%d%d%d%d", &a1, &b1, &a2, &b2);
      Add(a1, b1);
      Add(a2, b2);
      AddTwo(a1, b1, a2, b2, __1_4);
      break;
    }
  }
//   fclose(stdin);
  //cout << hex << (((1<<_n)-1<<1)|((1<<_n)-1<<17)) << endl;
  printf("%lld\n", (1<<_n)*Dp(((1<<_n)-1<<1)|((1<<_n)-1<<17))%_MOD);
  return 0;
}
```

注：不要滥用 unordered_map

1. 可能某些比赛不让用然后你就抱玲了
2. 目前为止，我做过的题目除了这道题，其他题都是 `map` 更快一些，不知道为什么
3. 这玩意可以卡（

---


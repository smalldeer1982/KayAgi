# [集训队互测 2023] 童话

## 题目背景

~~童话只美在真实却从不续写。~~

童话只美在温柔却从不续写。

## 题目描述

泠珞最近学习了前缀和算法，她写出了以下程序：

```cpp
read(n),read(a);
for(int i=0;i<=n;i++)read(f[i]);
for(int t=1;t<=n;t++){
    for(int i=1;i<=n;i++)f[i]=f[i]+a*f[i-1];
    ans[t]=f[t];
}
```

她发现这个程序在 $n$ 比较大的时候会运行超时，请你帮忙写一个程序帮她计算出 $\text{ans}_1,\text{ans}_2,\cdots,\text{ans}_n$，由于答案数值过大，你只需告诉她每个数除以 $998244353$ 的余数。

## 说明/提示

数据范围：

对于 $100\%$ 的数据，保证 $2\leqslant n\leqslant 10^6,0\leqslant f_i<998244353,1\leqslant a<998244353$。

| 子任务编号 |  $n\leqslant$  | 特殊性质 | 分值 |
| :--------: | :------------: | :------: | :--: |
|    $1$     |     $2000$     |          | $5$  |
|    $2$     |     $10^5$     |    A     | $5$  |
|    $3$     |     $10^5$     |    BC    | $5$  |
|    $4$     |     $10^5$     |    BD    | $10$ |
|    $5$     |     $10^5$     |    C     | $10$ |
|    $6$     | $5\times10^4$  |          | $10$ |
|    $7$     |     $10^5$     |          | $10$ |
|    $8$     | $2\times 10^5$ |          | $15$ |
|    $9$     | $5\times 10^5$ |          | $15$ |
|    $10$    |     $10^6$     |          | $15$ |

特殊性质 A：保证 $f_i\ne 0$ 的 $i$ 数量不超过 $100$。

特殊性质 B：保证 $a=1$。

特殊性质 C：保证对于所有 $i\in[0,n]$，都满足 $f_i=1$。

特殊性质 D：保证对于所有 $i\in[0,n]$，都满足 $f_i={i+2\choose 2}=\frac{(i+2)(i+1)}{2}$。

## 样例 #1

### 输入

```
2 1
1 2 0```

### 输出

```
3 7```

## 样例 #2

### 输入

```
10 10
5 9 7 8 0 6 3 2 4 10 1```

### 输出

```
59 1687 55618 1937320 69557006 549579657 621247830 250099579 483510144 968467040```

# 题解

## 作者：NaCly_Fish (赞：11)

一看这题，我啪的一下[就点进来](https://www.luogu.com.cn/problem/P10007)了，很快啊！

设 $F(x)$ 是题面代码中序列 $f$ 的生成函数，那么发现每次操作其实就是
$$F(x) \leftarrow \frac{F(x)}{1-ax}$$
也就是说答案（设 $s_t=\text{ans}_t$）

$$s_t=[x^t]\frac{F(x)}{(1-ax)^t}$$

这是[经典问题](https://www.luogu.com.cn/blog/NaCly-Fish-blog/a-classical-problem)，可以做到 $\Theta(n \log n)$ 的时间复杂度。

啊好像还需要一些常数优化，那就展开解释一下吧。首先套用模板，设 $h(x)$ 为 $x-ax^2$ 的复合逆，即

$$h(x)=\frac{1-\sqrt{1-4ax}}{2a}$$
答案就是

$$s_t=[x^0] \frac{F(x)}{(x-ax^2)^t}=[x^t]F(h(x)) \frac{xh'(x)}{h(x)}$$
虽然 $xh'(x)/h(x)$ 微分有限，但是在最后还需要一次卷积。反正 $F(x)$ 是给定的，没什么特殊性质，不如考虑把这部分揉进 $F(h(x))$ 里面去。根据代数方程的性质可知

$$h'(x)=\frac{1-2a h(x)}{1-4ax} \ , \ \frac{x}{h(x)}=1-ah(x)$$
然后设 $\hat F(x)=F(x)(1-2ax)(1-ax)$，这样处理起来就比较方便了：
$$s_t=[x^t]\frac{\hat F(h(x))}{1-4ax}$$


实际上，[接下来的处理](https://www.luogu.com.cn/blog/EntropyIncreaser/ying-ye-ri-zhi-202074-xin-ping-jiu-jiu)也很经典：
$$\hat F(h(x))=\hat F\left(\frac{1-x}{2a}\right) \circ \sqrt{1-4ax}$$
设 $G(x)=\hat F((1-x)/2a)$，然后将其分解为 $G(x)=P(x^2)+xQ(x^2)$，就有 $G(\sqrt{1-4ax})=P(1-4ax)+\sqrt{1-4ax}Q(1-4ax)$。

最后的做法似乎比出题人的常数稍大一点，但似乎容易处理一些。

update：好像实现效果比出题人还快了近一倍，很神秘。我的 DFT 部分也没有做精细的优化，补一下代码吧。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define N 2097158
#define ll long long
#define p 998244353
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int rt[N],rev[N],fac[N],ifac[N];
int siz;

void init(int n){
    int w,lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    w = power(3,(p-1)>>siz);
    fac[0] = fac[1] = ifac[0] = ifac[1] = rt[lim>>1] = 1;
    for(int i=lim>>1|1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(int i=2;i<=n;++i) fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(int i=n-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
}

inline void dft(int *f,int lim){
    static unsigned long long a[N];
    int x,shift = siz-__builtin_ctz(lim);
    for(int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(int mid=1;mid!=lim;mid<<=1)
    for(int j=0;j!=lim;j+=(mid<<1))
    for(int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(int i=0;i!=lim;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int lim){
    reverse(f+1,f+lim);
    dft(f,lim);
    int x = p-((p-1)>>__builtin_ctz(lim));
    for(int i=0;i!=lim;++i) f[i] = (ll)f[i]*x%p;
}

inline int getlen(int n){ return 1<<(32-__builtin_clz(n)); }

inline void composite(const int *f,int n,int c,int *R){
    static int g[N],h[N];
    g[0] = 1,h[0] = f[0];
    for(int i=1;i<=n;++i){
        g[i] = (ll)g[i-1]*c%p;
        h[i] = (ll)f[i]*fac[i]%p;
    }
    for(int i=2;i<=n;++i) g[i] = (ll)g[i]*ifac[i]%p;
    reverse(g,g+n+1);
    int lim = getlen(n<<1);
    memset(g+n+1,0,(lim-n)<<2);
    memset(h+n+1,0,(lim-n)<<2);
    dft(g,lim),dft(h,lim);
    for(int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
    idft(g,lim);
    for(int i=0;i<=n;++i) R[i] = (ll)g[i+n]*ifac[i]%p;
}

inline int binom(int n,int m){
    if(n<m) return 0;
    return (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;
}

int n,a,dp,dq;
int f[N],P[N],Q[N],h[N];
const int inv2 = (p+1)/2;

int main(){
    read(n),read(a);
    init(n<<1);
    for(int i=0;i<=n;++i) read(f[i]);
    for(int i=n+1;i;--i) f[i] = (f[i]-(ll)a*f[i-1])%p;
    for(int i=n+2;i;--i) f[i] = (f[i]-2ll*a*f[i-1])%p;
    int pw = 1,c = power(p-2*a%p,p-2);
    n += 2;
    for(int i=0;i<=n;++i){
        f[i] = ((ll)(f[i]+p)*pw)%p;
        pw = (ll)pw*c%p;
    }
    composite(f,n,p-1,f);
    for(int i=0;i<=n;++i){
        if(i&1) Q[dq++] = f[i];
        else P[dp++] = f[i];
    }
    composite(P,dp-1,1,P),composite(Q,dq-1,1,Q);
    pw = 1,c = p-4ll*a%p;
    for(int i=0;(i<<1)<=n+1;++i){
        P[i] = (ll)P[i]*pw%p,Q[i] = (ll)Q[i]*pw%p;
        pw = (ll)pw*c%p;
    }
    h[0] = pw = 1,c = 4ll*(p-a)%p;
    for(int i=1;i<=n;++i){
        pw = (ll)pw*c%p*(inv2-i+1)%p;
        h[i] = (ll)pw*ifac[i]%p;
    }
    int lim = getlen(n<<1);
    dft(h,lim),dft(Q,lim);
    for(int i=0;i!=lim;++i) Q[i] = (ll)Q[i]*h[i]%p;
    idft(Q,lim);
    memset(Q+n+1,0,(lim-n)<<2);
    n -= 2;
    for(int i=0;i<=n;++i) f[i] = P[i]+Q[i]>=p?P[i]+Q[i]-p:P[i]+Q[i];
    for(int i=1;i<=n;++i){
        f[i] = (f[i]+4ll*a*f[i-1])%p;
        printf("%d ",f[i]);
    }
    return 0;   
}
```


---

## 作者：whiteqwq (赞：6)

#### 子任务 1

把题面里的代码加个头文件交上去，$5$ 分到手！

#### 子任务 2

对于 $i\leqslant t$，考虑位置 $i$ 对 $ans_t$ 的贡献：我们可以将向后移动的 $t-i$ 步分给 $t$ 个时刻，而贡献乘上的系数显然为 $a^{t-i}$，于是：
$$
ans_t=\sum_{i=0}^t f_ia^{t-i}{t-i+t-1\choose t-1}
$$
对有值的位置求和即可。

#### 子任务 3

即求 $\sum_{i=0}^t{i+t-1\choose t-1}$，这是经典的上指标求和，可以在预处理阶乘及其逆元后 $O(1)$ 计算。

#### 子任务 4

即求 $\sum_{i=0}^t{i+t-1\choose t-1}{t-i+2\choose 2}$，其显然可以被 $\sum_{i=0}^t{i+t-1\choose t-1}{i\choose 2},\sum_{i=0}^t{i+t-1\choose t-1}i,\sum_{i=0}^t{i+t-1\choose t-1}$ 线性组合得到（视 $t$ 为常数），而上面三式均可使用吸收公式后上指标求和计算（也能使用组合意义直接得到结果）。

#### 子任务 5

即求 $\sum_{i=0}^t{i+t-1\choose t-1}a^i$，我们可以使用递推：
$$
ans_t=\sum_{i=0}^t{i+t-1\choose t-1}a^i=\sum_{i=0}^t{i+t-1-1\choose t-1}a^i+\sum_{i=0}^t{i+t-1-1\choose t-2}a^i$$
$$=a(ans_t-{t+t-1\choose t-1}a^t)+(ans_{t-1}+{t+t-2\choose t-2}a^t)
$$
递推时需要特殊处理 $a=1$ 的情况，复杂度 $O(n)$。

#### 子任务 6,7

容易将 $a$ 的影响消除，将 $f_i$ 除以 $a^i$ 并令第 $i$ 项答案乘上 $a^i$ 即可。

记 $v_{i,j}$ 为第 $i$ 次操作后第 $j$ 个位置的值，那么问题可以被刻画为二维平面的格路计数——$v_{i,j}$ 表示任选一个第 $0$ 排的起点 $(0,i)$，进行任意下步和右步（第 $0$ 排不能进行右步），到达 $(i,j)$ 的方案数乘上 $f_i$ 之和，我们即求 $v_{1,1},v_{2,2},\cdots,v_{n,n}$。

记 $r_i(l,r)$ 表示第 $i$ 行的 $[l,r]$ 列上面的值，$c_i(l,r)$ 表示第 $i$ 列的第 $[l,r]$ 行上面的值。

考虑使用分治求解，我们设计函数 `solve(l,r,F,G)`，表示已知 $F=r_{l-1}(l,r),G=c_{l-1}(l,r)$，需通过 $F,G$ 计算出 $v_{l,l},v_{l+1,l+1},\cdots,v_{r,r}$。

取 $[l,r]$ 中点 $mid$，尝试计算第 $mid$ 行，第 $mid$ 列的所有值。具体地，我们先使用 $r_{l-1}(l,mid),c_{l-1}(l,mid)$ 计算出 $r_{mid}(l,mid),c_{mid}(l,mid)$，再用 $r_{l-1}(mid+1,r),c_{mid}(l,mid)$ 计算出 $r_{mid}(mid+1,r)$，类似地使用 $c_{l-1}(mid+1,r),r_{mid}(l,mid)$ 计算出 $c_{mid}(mid+1,r)$。于是我们不仅计算出了 $v_{mid,mid}$，还得到了递归 `solve(mid+1,r,U,V)` 所需的 $U=r_{mid}(mid+1,r),V=c_{mid}(mid+1,r)$，可以直接递归求解剩余部分。

由于转移系数均为组合数，可以表示为卷积形式，使用 NTT 优化卷积即可做到 $O(n\log^2 n)$ 的时间复杂度。

精细实现可以通过子任务 8。

#### 子任务 8,9,10

定理（扩展拉格朗日反演）：
$$
[x^n]H(F(x))=[x^{n-1}]H'(x)(\frac{x}{G(x)})^n
$$
证明可见参考资料《信息学竞赛中的生成函数计算理论框架》3.2.3 Lagrange 反演部分。

回到原问题，我们所求的即 $[x^t](\frac{1}{1-ax})^tF$，注意到它与扩展拉格朗日反演右式形式类似，我们尝试式子化成类似的形式：
$$
[x^t](\frac{1}{1-ax})^tF
=[x^t](\frac{x}{G})^{t+1}\frac{FG}{x}
=[x^{t+1}](t+1)H(P)
$$
其中 $G(x)=-ax^2+x,H(x)=\int(\frac{F(x)G(x)}x)$，且 $P$ 与 $G$ 互为复合逆，满足 $x=-aP^2+P$。

解得 $P=\frac{1-\sqrt{1-4ax}}{2a}$（仅保留常数项为 $0$ 的解），于是我们只需处理任意多项式右复合 $\frac{1-\sqrt{1-4ax}}{2a}$ 这一问题。

子任务 4 是为了做到这一步后不会的选手设计的，此时的 $H$ 每一项系数均为 $1$，可以暴力计算出 $P$ 后做多项式快速幂（不过后来得到了更简单的做法）。

我们将复合拆解成右复合 $-\frac{1}{2a}$，右复合 $x-1$，右复合 $\sqrt{1-4ax}$ 三步。第一步容易线性处理，第二步需要进行一次多项式平移（可以使用 NTT 加速卷积做到 $O(n\log n)$），重点在复合 $\sqrt{1-4ax}$，我们对于奇数次数与偶数次数系数分开处理：

对于偶数项，我们可以先右复合 $\sqrt x$（将 $2k$ 上的系数平移到 $k$），再右复合 $1-4ax$（同样是多项式平移，卷积即可）。

对于奇数项，使用牛顿二项式定理：
$$
(1-4ax)^{k+\frac 12}=\sum_{i\geqslant 0}{k+\frac 12\choose i}(-4ax)^i=\sum_{i\geqslant 0}\frac{(-4a)^i(2k+1)(2k-1)\cdot\cdots\cdot(2k-2i+3)}{2^ii!}x^i
$$
仍然可以卷积处理。

于是本题仅需三次多项式卷积，复杂度 $O(n\log n)$，常数较小。

### 参考资料

李白天：《信息学竞赛中的生成函数计算理论框架》（2021 年集训队论文）

---

## 作者：Imitators (赞：5)

摇奖的互测题。

$$
[x^k]\frac{F}{(1-x)^k}
$$

转化一下：

$$
\begin{aligned}
&[x^k]\frac{F}{(1-x)^n}(1-x)^{n-k}\\
=&[x^n]\frac{F}{(1-x)^n}(x-x^2)^{n-k}\\
=&[x^n] H(x)(x-x^2)^k
\end{aligned}
$$

------

我们考虑这是在干啥（？）

记 $z(x)=x-x^2$，$\hat f$ 表示将 $f$ 系数翻转得到的**多项式**。

欲求：

$$
\hat H\times \begin{bmatrix}{z^0},z^1,\cdots ,{z^n}\end{bmatrix}
$$

其中每一个 $z$ 都是列向量，翻转 $H$ 系数是为了从 **内积** 变成 **卷积**。

右乘后面那个矩阵的转置的效果是：

$$
H\times \begin{bmatrix}{(z^0)^T}\\(z^1)^T\\\vdots\\({z^n})^T\end{bmatrix}=H(z)
$$

是复合。

我们将复合 $x-x^2$ 写成线性变换:

$$
F\circ(x-x^2)=F\circ(-x)\circ(x-\frac{1}{4})\circ x^2\circ (x-\frac{1}{2})
$$

复合运算是有“结合律”的，所以我们从左往右，计算 $F\gets F_0\circ c$。

复合 $-x$ 的转置是自己，复合 $x^2$ 的转置是：

$$
\begin{bmatrix}
\color{red}{1}\color{black},0,0,0,0,0,0\\
0,0,0,0,0,0,0\\
0,\color{red}{1}\color{black},0,0,0,0,0\\
0,0,0,0,0,0,0\\
0,0,\color{red}{1}\color{black},0,0,0,0\\
0,0,0,0,0,0,0\\
0,0,0,\color{red}{1}\color{black},0,0,0\\
\end{bmatrix}^T=
\begin{bmatrix}
\color{red}{1}\color{black},0,0,0,0,0,0\\
0,0,\color{red}{1}\color{black},0,0,0,0\\
0,0,0,0,\color{red}{1}\color{black},0,0\\
0,0,0,0,0,0,\color{red}{1}\color{black}\\
0,0,0,0,0,0,0\\
0,0,0,0,0,0,0\\
0,0,0,0,0,0,0\\
\end{bmatrix}
$$

虽然说看起来是在**复合** $\sqrt x$ 但实际上我们要**丢掉**所有奇数位的信息，而信息肯定不能**白丢**的，所以考虑我们复合 $x^2$ 时需要一个 $2n\times 2n$ 的矩阵。

---

but why？为啥不能截断呢？明明我们以往会很“心安理得”地去丢弃高次项呀。

因为一般来说我们只会做**多项式**的复合，而不是级数的复合，一个 $x^k$ 高次项变成常数项不为0的 $c(x)^k$ 后仍会对 $x^t,t<k$ 的项贡献。

所以我们在进行 $F\circ (x-x^2)$ 时需要一直维护一个长 $2n$ 的多项式，所以所有矩阵的大小都应为 $2n\times 2n$。

---

这样看起来就没有丢失信息了。

剩下一个复合 $x+c$ 的转置：

$$
\begin{aligned}
g_k&=\sum_{i=0}^nf_i[x^i](x+c)^k \\
g_k&=\sum_{i=0}^nf_i c^{k-i}\binom{k}{i}\\
\frac{g_k}{k!}&=\sum_{i=0}^n\frac{f_i}{i!}\frac{c^{k-i}}{(k-i)!}\\
\end{aligned}
$$

这也是符合预期的，因为多项式平移我们干的是类似的差卷积。

最后就转转转，倒着做就完了。

~~srds为啥我跑的这么慢呀，不写dif-dit导致的（~~

---

## 作者：Vidoliga (赞：2)

和每个人的做法都略有不同。

最后复合逆的处理参考了神鱼的做法（/bx 神鱼）

说实话，这题感觉要是熟悉生成函数的一些套路，每一步都挺自然的（？）

首先递推式改写：

$$f_{i,j}=f_{i-1,j}+af_{i,j-1}$$

设 $F_{i}(x)=\sum\limits_{j=0}^{+\infty} f_{i,j} x^{j}$，有：

$$F_{i}(x)=F_{i-1}(x)+axF_{i}(x)$$

$$(1-ax)F_{i}(x)=F_{i-1}(x)$$

$$F_{i}(x)=\dfrac{1}{1-ax}F_{i-1}(x)$$

不难得出 $ans_t=[x^t]F(x)\left(\dfrac{1}{1-ax}\right)^t$

这一坨东西看上去就不好搞，原因是多项式在变，求的系数位置也在变。

而拉格朗日反演可以优美的解决大部分该类情况，大体上思路是变成求定多项式的不同位置系数。

拉格朗日反演不会的，可以看[这个](https://www.luogu.com.cn/blog/Vidoliga/kuo-zhan-la-ge-lang-ri-fan-yan)。

我们知道，若 $F(G(x))=x$，即 $F,G$ 互为复合逆：

$$[x^n]H(F(x))=\dfrac{1}{n} [x^{n-1}]\dfrac{x^nH^\prime(x)}{G^n(x)}$$

考虑逆用扩展拉格朗日反演：

$$[x^t]F(x)\left(\dfrac{1}{1-ax}\right)^t=[x^{t-1}]\dfrac{F(x)}{x}\left(\dfrac{x}{x-ax^2}\right)^t$$

考虑到 $\dfrac{F(x)}{x}$ 不能整除，考虑分出 $[x^0]F(x)$ 单独计算：

$$[x^0]F(x)[x^t]\left(\dfrac{1}{1-ax}\right)^t$$

众所周知：

$$\left(\dfrac{1}{1-ax}\right)^t=\left(\sum\limits_{i \geq 0} (ax)^i\right)^t$$

考虑组合意义，相当于 $n$ 不区分个球，划分到 $t$ 组区分盒子（可为空）。

$$\left(\sum\limits_{i \geq 0} (ax)^i\right)^t=\sum\limits_{i \geq 0} \binom{i+t-1}{t-1} a^ix^i$$

所以 $[x^0]F(x)$ 的贡献为：

$$[x^0]F(x)\binom{2t-1}{t-1}a^t$$

设 $Q(x)=\dfrac{F(x)-[x^0]F(x)}{x}$，现在只需要计算：

$$[x^{t-1}]Q(x)\left(\dfrac{x}{x-ax^2}\right)^t$$

考虑还需要计算 $x-ax^2$ 的复合逆 $T(x)$：

$$T(x)-aT^2(x)=x$$

解得：

$$T(x)=\dfrac{1-\sqrt{1-4ax}}{2a}$$

扩展拉格朗日反演：

$$[x^t]t\left(\int Q \right)\left(T(x)\right)$$

接下来考虑怎么处理这个复合逆，设 $H(x)=\int Q$：

$$\left(\int Q \right)\left(T(x)\right)=H(x) \circ T(x)=H(x) \circ \left(\dfrac{x}{2a}\right) \circ (1-x) \circ \sqrt{1-4ax}$$

前面两项都可以通过多项式平移简单处理，考虑得出 $R(x)=H(x) \circ \left(\dfrac{x}{2a}\right) \circ (1-x)$，接下来计算：

$$G(x)=R(x)\circ \sqrt{1-4ax}$$

设 $R(x)=A(x^2)+xB(x^2)$：

$$G(x)=A(x)\circ (1-4ax)+B(x^2)\circ \sqrt{1-4ax}$$

前半部分通过多项式平移即可求解，考虑后半部分的式子：

$$\sum\limits_{i\geq 0}b_i(1-4ax)^{i+\frac{1}{2}}$$

根据牛顿二项式定理：

$$\sum\limits_{i\geq 0}b_i(1-4ax)^{i+\frac{1}{2}}=\sum\limits_{i\geq 0}b_i\sum\limits_{j \geq 0} \binom{i+\frac{1}{2}}{j}(-4ax)^{j}$$

$$=\sum\limits_{i\geq 0}(-4a)^{i}x^{i}\sum\limits_{j \geq 0} \binom{j+\frac{1}{2}}{i}b_j=\sum\limits_{i\geq 0}(-4a)^{i}x^{i}\sum\limits_{j \geq 0} \dfrac{(2j+1)!!}{2^ii!(2j-2i+1)!!}b_j$$

$$=\sum\limits_{i\geq 0}\dfrac{(-4a)^{i}}{2^ii!}x^{i}\sum\limits_{j \geq 0} \dfrac{(2j+1)!!}{(2j-2i+1)!!}b_j$$

卷积即可，复杂度 $O(n \log n)$。

这题细节挺多的。。

```cpp
#include<bits/stdc++.h>
#define ll long long
//#define int ll
using namespace std;
const int N=2e6+20,M=1e6+20;
const int gen=3,invg=332748118,mod=998244353;
const int inv2=(mod+1)/2,bk=64;
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=1ll*res*a%mod;
		a=1ll*a*a%mod;b>>=1;
	}return res;
}
struct Faction{
	int len;vector<int> v;
	inline void init(int l){len=l;v.resize(l+1);}
	inline int val(int x){
		int ans=0;
		for(int i=0,res=1;i<=len;i++,res=1ll*res*x%mod){
			ans=(ans+1ll*res*v[i]%mod)%mod;
		}return ans;
	}
};
int fac[N],ffac[N],iffac[N],ifac[N],inv[N];
namespace Poly{
	int tr[N],W[N];
	inline int init(int n){
		int lim=1,len=0;
		while(lim<=n) lim<<=1,len++;
		for(int i=1;i<lim;i++) tr[i]=(tr[i>>1]>>1)|((i&1)<<(len-1));
		return lim;
	}
	void NTT(Faction &f,bool opt){
		int len=f.len+1;
		for(int i=1;i<len;i++) if(i<tr[i]) swap(f.v[i],f.v[tr[i]]);
		for(int mid=1;mid<len;mid<<=1){
			int wn=qpow(opt?gen:invg,(mod-1)/(mid<<1));
			W[0]=1;for(int i=1;i<mid;i++) W[i]=1ll*W[i-1]*wn%mod;
			for(int j=0;j<len;j+=(mid<<1)) for(int k=0;k<mid;k++){
				int x=f.v[j+k],y=1ll*W[k]*f.v[j+k+mid]%mod;
				f.v[j+k]=(x+y)%mod;f.v[j+k+mid]=(x-y+mod)%mod; 
			}
		}
		if(!opt){
			int in=qpow(len,mod-2);
			for(int i=0;i<len;i++) f.v[i]=1ll*f.v[i]*in%mod;
		}
	}
	void print(Faction x){
		for(int i=0;i<=x.len;i++) cout<<x.v[i]<<' ';cout<<'\n';
	}
	inline Faction operator +(Faction a,Faction b){
		Faction c;int len=max(a.len,b.len);c.init(len);a.init(len);b.init(len);
		for(int i=0;i<=len;i++) c.v[i]=(a.v[i]+b.v[i])%mod;
		return c;
	}
	inline Faction operator -(Faction a,Faction b){
		Faction c;int len=max(a.len,b.len);c.init(len);a.init(len);b.init(len);
		for(int i=0;i<=len;i++) c.v[i]=(a.v[i]-b.v[i]+mod)%mod;
		return c;
	}
	inline Faction operator *(Faction a,Faction b){
		Faction c;
		int len=a.len+b.len,lim=init(len);
		if(len<=bk){
			c.init(len);
			for(int i=0;i<=a.len;i++) for(int j=0;j<=b.len;j++){
				c.v[i+j]=(c.v[i+j]+1ll*a.v[i]*b.v[j]%mod)%mod;
			}
			return c;
		}
		a.init(lim-1);b.init(lim-1);c.init(lim-1);
		NTT(a,1);NTT(b,1);
		for(int i=0;i<lim;i++) c.v[i]=1ll*a.v[i]*b.v[i]%mod;
		NTT(c,0);c.init(len);
		return c;
	}
	void getinv(Faction &f,Faction &g,int len){
		if(len==1) return f.init(0),f.v[0]=qpow(g.v[0],mod-2),void();
		getinv(f,g,(len+1)>>1);
		int lim=init((len-1)<<1);Faction h;h.init(lim-1);f.init(lim-1);
		for(int i=0;i<len;i++) h.v[i]=g.v[i];
		for(int i=len;i<lim;i++) h.v[i]=0;
		NTT(h,1);NTT(f,1);
		for(int i=0;i<lim;i++) f.v[i]=((2ll-1ll*f.v[i]*h.v[i]%mod)+mod)%mod*f.v[i]%mod;
		NTT(f,0);
		for(int i=len;i<lim;i++) f.v[i]=0;
	}
	Faction Inv(Faction &g){
		Faction f;
		getinv(f,g,g.len+1);
		f.init(g.len);return f;
	}
	inline void operator >>=(Faction &f,int k){
		int len=f.len;f.init(len-k);
		for(int i=k;i<=len;i++) f.v[i-k]=f.v[i];
		for(int i=len-k+1;i<=len;i++) f.v[i]=0;
	}
	inline void operator <<=(Faction &f,int k){
		int len=f.len;f.init(len+k);
		for(int i=len;~i;i--) f.v[i+k]=f.v[i];
		for(int i=0;i<k;i++) f.v[i]=0;
	}
	Faction Dev(Faction f){
		Faction g=f;int len=g.len;
		for(int i=1;i<=len;i++) g.v[i-1]=1ll*g.v[i]*i%mod;
		g.init(len-1);return g;
	}
	void getdev(Faction &f){
		int len=f.len;
		for(int i=1;i<=len;i++) f.v[i-1]=1ll*f.v[i]*i%mod;
		f.init(len-1);
	}
	void getidev(Faction &f){
		int len=f.len;f.init(len+1);
		for(int i=len+1;i;i--) f.v[i]=1ll*f.v[i-1]*inv[i]%mod;
		f.v[0]=0;
	}
	void getsqrt(Faction &f,Faction &g,int len){
		if(len==1) return g.init(0),g.v[0]=1,void();
		getsqrt(f,g,(len+1)>>1);Faction h,q;
		g.init(len-1);h=Inv(g);int lim=init(len<<1);q.init(lim-1);g.init(lim-1);h.init(lim-1);
		for(int i=0;i<len;i++) q.v[i]=f.v[i];
		NTT(q,1);NTT(g,1);NTT(h,1);
		for(int i=0;i<lim;i++) g.v[i]=(1ll*g.v[i]+1ll*q.v[i]*h.v[i]%mod)*inv2%mod;
		NTT(g,0);g.init(len-1);
	}
	Faction Sqrt(Faction f){
		int len=f.len;Faction g;
		return getsqrt(f,g,len+1),g;
	}
	inline void rev(Faction &f){reverse(f.v.begin(),f.v.end());}
}
inline int C(int n,int m){
	if(n<0||m<0||n<m) return 0;
	return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
inline int iep(int x){return x&1?mod-1:1;}
using namespace Poly;
int n,a;
inline Faction get(Faction f,int p){
	Faction g=f,h;h.init(n);
	for(int i=0;i<=n;i++) h.v[i]=ifac[i],g.v[i]=1ll*fac[i]*g.v[i]%mod;
	rev(g);
	h=h*g;h.init(n);rev(h);
	for(int i=0,x=1;i<=n;i++,x=1ll*x*p%mod) h.v[i]=1ll*ifac[i]*x%mod*h.v[i]%mod;
	return h;
}
inline Faction get2(Faction f,int p){
	Faction g=f,h;h.init(n);
	for(int i=0;i<=n;i++) h.v[i]=iffac[i],g.v[i]=1ll*ffac[i]*g.v[i]%mod;
	rev(g);
	h=h*g;h.init(n);rev(h);
	Faction t=f,s;s.init(n);
	for(int i=0;i<=n;i++) t.v[i]=1ll*ffac[i]*t.v[i]%mod;
	s.v[0]=0,s.v[1]=1;
	for(int i=2;i<=n;i++) s.v[i]=1ll*ffac[i-2]*iep(i-1)%mod;
	t=t*s;
	for(int i=0;i<=n;i++) h.v[i]=(h.v[i]+t.v[i])%mod;
	for(int i=0,x=1;i<=n;i++,x=1ll*x*p%mod*inv2%mod) h.v[i]=1ll*ifac[i]*x%mod*h.v[i]%mod;
	return h;
}
signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	ffac[0]=iffac[0]=1;for(int i=1;i<N;i++) ffac[i]=1ll*(2*i+1)*ffac[i-1]%mod;
	iffac[N-1]=qpow(ffac[N-1],mod-2);for(int i=N-1;i;i--) iffac[i-1]=1ll*iffac[i]*(2*i+1)%mod;
	fac[0]=ifac[0]=ifac[1]=1;for(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;
	ifac[N-1]=qpow(fac[N-1],mod-2);for(int i=N-1;i;i--) ifac[i-1]=1ll*ifac[i]*i%mod;
	inv[0]=1;for(int i=1;i<N;i++) inv[i]=1ll*ifac[i]*fac[i-1]%mod;
	cin>>n>>a;Faction F,G,Q,H;F.init(n);Q.init(n);G.init(n);H.init(n);
	for(int i=0;i<=n;i++) cin>>F.v[i],Q.v[i]=1ll*inv[i]*F.v[i]%mod;
	Q.v[0]=0;
	int iv=qpow(2*a%mod,mod-2);
	for(int i=1,p=iv;i<=n;i++,p=1ll*p*iv%mod) Q.v[i]=1ll*p*Q.v[i]%mod;
	Q=get(Q,mod-1);
	Faction A,B;A.init(n);B.init(n);
	for(int i=0;2*i<=n;i++) A.v[i]=Q.v[2*i];
	for(int i=0;2*i+1<=n;i++) B.v[i]=Q.v[2*i+1];
	A=get(A,(mod-4ll*a%mod)%mod);B=get2(B,(mod-4ll*a%mod)%mod);
	G=A+B;
	for(int t=1,p=a;t<=n;t++,p=1ll*p*a%mod){
		int res=1ll*G.v[t]*t%mod;
		res=(res+1ll*C(2*t-1,t-1)*p%mod*F.v[0]%mod)%mod;
		cout<<res<<' ';
	}
	return 0;
}
```

---


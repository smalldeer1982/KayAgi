# 仓鼠的数学题

## 题目背景

请注意本题时限 1s，开启 O2 优化，你可能需要输入输出优化。


## 题目描述

仓鼠在某 oj 上看到了一个问题，设 $S_k(x)=\sum_{i=0}^x i^k$，这个题输入 $a_0,a_1...a_n$，假设 $0^0=1$，要求计算 $\sum_{k=0}^{n}S_k(x)a_k$。

仓鼠想了两秒就秒了这个题，他发现数据范围居然只有 $1000$，就顺手加了两个 $0$。

但是仓鼠懒得造数据了，就把这道题丢给了你。


## 说明/提示

对于 $10\%$ 的数据，$n \leq 500$。

对于 $30\%$ 的数据，$n \leq 3000$。

对于 $70\%$ 的数据，$n \leq 100000$。

对于 $100\%$ 的数据，$1 \leq n \leq 250000$。

输入和输出多项式系数均为模 $998244353$ 意义下，为 $[0,998244352]$ 的非负整数。


## 样例 #1

### 输入

```
2
3 3 3```

### 输出

```
3 5 3 1```

# 题解

## 作者：Karry5307 (赞：77)

### 题意

设 $S_k(x)=\sum\limits_{i=0}^{x}i^k$，给定正整数 $n$ 和序列 $a$，求：

$$\sum\limits_{k=0}^{n}S_k(x)a_k$$

$\texttt{Data Range:}1\leq n\leq 2\times 10^5$

### 题解

伯努利数板子题。

假设 $S_k(x)=\sum\limits_{i=0}^{x-1}i^k$，之后只要把所有的 $x$ 换成 $x+1$ 即可，这么做是方便用伯努利数表示，那么有

$$S_k(x)=\frac{1}{k+1}\sum\limits_{i=0}^{k}\binom{k+1}{i}B_{i}x^{k+1-i}$$

这个并不是很好看，所以考虑枚举 $k-i$：

$$S_k(x)=\frac{1}{k+1}\sum\limits_{i=0}^{k}\binom{k+1}{k-i}B_{k-i}x^{i+1}$$

利用二项式的对称性：

$$S_k(x)=\frac{1}{k+1}\sum\limits_{i=0}^{k}\binom{k+1}{i+1}B_{k-i}x^{i+1}$$

于是答案为

$$\sum\limits_{k=0}^{n}\frac{a_k}{k+1}\sum\limits_{i=0}^{k}\binom{k+1}{i+1}B_{k-i}x^{i+1}$$

显然交换求和顺序

$$\sum\limits_{i=0}^{n}x^{i+1}\sum\limits_{k=i}^{n}\frac{a_k}{k+1}\binom{k+1}{i+1}B_{k-i}$$

拆掉二项式

$$\sum\limits_{i=0}^{n}\frac{x^{i+1}}{(i+1)!}\sum\limits_{k=i}^{n}a_kk!\frac{B_{k-i}}{(k-i)!}$$

直接减法卷积即可，但是这里的 $x$ 实际上是 $x+1$，于是我们考虑下面的问题，求

$$\sum\limits_{i=0}^{n}f_i(x+1)^i$$

直接利用二项式定理：

$$\sum\limits_{i=0}^{n}f_i\sum\limits_{j=0}^{i}\binom{i}{j}x^j$$

交换求和顺序之后减法卷积即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=524291,MOD=998244353;
ll n;
ll omgs[MAXN],fact[MAXN],finv[MAXN],f[MAXN],g[MAXN],h[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setupOmg(ll cnt)
{
    ll limit=__lg(cnt)-1;
    omgs[0]=1,omgs[1<<limit]=qpow(31,1<<(21-limit));
    for(register int i=limit;i;i--)
    {
        omgs[1<<(i-1)]=(li)omgs[1<<i]*omgs[1<<i]%MOD;
    }
    for(register int i=1;i<cnt;i++)
    {
        omgs[i]=(li)omgs[i&(i-1)]*omgs[i&-i]%MOD;
    }
}
inline void setup(ll cnt)
{
    fact[0]=fact[1]=finv[0]=1;
    for(register int i=1;i<=cnt;i++)
    {
        fact[i]=(li)fact[i-1]*i%MOD;
    }
    finv[cnt]=qpow(fact[cnt],MOD-2);
    for(register int i=cnt-1;i;i--)
    {
        finv[i]=(li)finv[i+1]*(i+1)%MOD;
    }
}
inline ll& reduce(ll &x)
{
	return x+=x>>31&MOD;
}
inline void DIF(ll *cp,ll cnt)
{
	ll lim=__lg(cnt),len=cnt>>1,x;
	for(register int i=0;i<lim;i++,len>>=1)
	{
		for(register int *j=cp,*omg=omgs;j!=cp+cnt;j+=len<<1,omg++)
		{
			for(register int *k=j;k!=j+len;k++)
			{
				x=(li)*omg*k[len]%MOD,reduce(k[len]=*k-x),reduce(*k+=x-MOD);
			}
		}
	}
}
inline void DIT(ll *cp,ll cnt)
{
	ll lim=__lg(cnt),len=1,x,invl;
	for(register int i=0;i<lim;i++,len<<=1)
	{
		for(register int *j=cp,*omg=omgs;j!=cp+cnt;j+=len<<1,omg++)
		{
			for(register int *k=j;k!=j+len;k++)
			{
				reduce(x=*k+k[len]-MOD);
				k[len]=(li)(*k-k[len]+MOD)**omg%MOD,*k=x;
			}
		}
	}
	reverse(cp+1,cp+cnt),invl=MOD-(MOD-1)/cnt;
	for(register int i=0;i<cnt;i++)
	{
		cp[i]=(li)cp[i]*invl%MOD;
	}
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    inv==1?DIF(cp,cnt):DIT(cp,cnt);
}
inline void conv(ll fd,ll *f,ll *g,ll *res)
{
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=fd;i<cnt;i++)
    {
    	f[i]=g[i]=0;
	}
    NTT(f,cnt,1),NTT(g,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
		res[i]=(li)f[i]*g[i]%MOD;
    }
    NTT(res,cnt,-1);
}
inline void inv(ll fd,ll *f,ll *res)
{
	static ll tmp[MAXN],tmpr[MAXN];
	ll cnt=2,limit=0;
	tmpr[0]=res[0]=qpow(f[0],MOD-2);
	while(cnt<(fd<<1))
	{
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=f[i],tmpr[i]=i<(cnt>>1)?res[i]:0;
		}
		NTT(tmp,cnt,1),NTT(tmpr,cnt,1);
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=(li)tmp[i]*tmpr[i]%MOD;
		}
		NTT(tmp,cnt,-1),memset(tmp,0,cnt<<1),NTT(tmp,cnt,1);
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=(li)tmp[i]*tmpr[i]%MOD;
		}
		NTT(tmp,cnt,-1);
		for(register int i=(cnt>>1);i<cnt;i++)
		{
			res[i]=!tmp[i]?0:MOD-tmp[i];
		}
		cnt<<=1,limit++;
	}
	for(register int i=fd;i<cnt;i++)
	{
		res[i]=0;
	}
}
int main()
{
 	setup((n=read())+5),setupOmg(524288);
	for(register int i=0;i<=n;i++)
	{
		f[i]=(li)read()*fact[i]%MOD,h[i]=finv[i+1];
	}
	inv(n+1,h,g),reverse(f,f+n+1),conv(n+1,f,g,f),reverse(f,f+n+1),g[0]=0;
	for(register int i=0;i<=n+1;i++)
	{
		g[i+1]=f[i],h[i]=finv[i];
	}
	reverse(g,g+n+2),conv(n+2,g,h,f),reverse(f,f+n+2);
	for(register int i=0;i<=n+1;i++)
	{
		printf("%d ",(li)f[i]*finv[i]%MOD);
	}
}
```

---

## 作者：fjzzq2002 (赞：23)

这一部分节选自杜瑜皓《多项式及求和》。如果你有伯努利数基础，可以直接跳过这一部分。


我们定义一个数列$\{B_i\}​$为伯努利数，当且仅当它的指数生成函数为$\frac{x}{e^x-1}​$，即$\sum_{n=0}^\infty \frac{B_n}{n!}x^n=\frac{x}{e^x-1}​$。


定义伯努利多项式$\beta_n(t)=\sum_{k=0}^n C_n^k B_{n-k}t^k$，那么它就是$t^k$和$B_k$的指数生成函数的积，即$\sum_{n=0}^\infty \frac{\beta_n(t)}{n!}x^n=(\sum_{n=0}^\infty \frac{B_n}{n!}x^n)(\sum_{n=0}^\infty \frac{t^n}{n!}x^n)$。


那么由于$\sum_{n=0}^\infty \frac{B_n}{n!}x^n=\frac{x}{e^x-1}$，$\sum_{n=0}^\infty \frac{t^n}{n!}x^n=e^{tx}$（泰勒展开），所以$\sum_{n=0}^\infty \frac{\beta_n(t)}{n!}x^n=\frac{x}{e^x-1}e^{tx}$。


$\sum_{n=0}^\infty \frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n=\frac{xe^{(t+1)x}}{e^x-1}-\frac{xe^{tx}}{e^x-1}=xe^{tx}=x\sum_{n=0}^\infty \frac{t^n}{n!}{x^n}$


所以$\sum_{n=0}^\infty \frac{t^n}{n!}{x^n}=\sum_{n=0}^\infty \frac{\beta_n(t+1)-\beta_n(t)}{n!}x^{n-1}=\sum_{n=0}^\infty \frac{\beta_{n+1}(t+1)-\beta_{n+1}(t)}{(n+1)!}x^n$。


那么对比一下系数可以发现$\frac{t^n}{n!}=\frac{\beta_{n+1}(t+1)-\beta_{n+1}(t)}{(n+1)!}$，$\beta_{n+1}(t+1)-\beta_{n+1}(t)=(n+1)t^n$。


考虑计算$S_k(x)=\sum_{i=1}^x i^k$，把右边的t从1到x求和，那么左边我们发现类似裂项相消消掉了，最后剩下$\beta_{k+1}(x+1)-\beta_{k+1}(0)$，那么$S_k(x)=\frac{\beta_{k+1}(x+1)-\beta_{k+1}(0)}{k+1}$，带入一波$\beta$的定义可以发现$S_k(x)=\frac{1}{k+1}\sum_{g=0}^k C_{k+1}^g B_g x^{k+1-g}$。


跳过部分到此结束。考虑如何求出伯努利数，$\sum_{i=0}^\infty \frac{B_i}{i!}x^i=\frac{x}{e^x-1}=\frac{x}{\sum_{i=1}^\infty \frac{x^i}{i!}}=\frac{1}{\sum_{i=0}^\infty \frac{x^i}{(i+1)!}}$，那么我们把分母这个多项式求逆元即可。$O(nlogn)$。


回到原问题，$\sum_{k=0}^{n}S_k(x)a_k=\sum_{k=0}^n\frac{a_k}{k+1}\sum_{g=0}^k C_{k+1}^g B_g x^{k+1-g}=\sum_{k=0}^n a_kk!\sum_{g=0}^n\frac{B_g}{g!}\frac{x^{k+1-g}}{(k+1-g)!}$。


那么考虑令$X_k=a_kk!$，$Y_k=\frac{B_k}{k!}$，那么$x^a$的系数为$\frac{1}{a!}\sum_k \sum_g X_k Y_g [k+1-g==a]$。


按照常用技巧，令$Y'_{k}=Y_{n+1-k}$，那么$x^a$的系数为$\frac{1}{a!}\sum_k \sum_g X_k Y'_g [k+g==a+n]$。直接将X与Y'卷积即可。$O(nlogn)$。


---

## 作者：w33z8kqrqk8zzzx33 (赞：11)

首先，根据 Faulhaber 公式，有

$$S_p(n)=[p=0]+\frac{1}{p+1}\sum _{j=0}^{p}\binom{p+1}{j}B^+_jn^{p+1-j}$$

可以先不考虑 $[p=0]$ 这个部分，最后哦铺加上去，退化为

$$S_p(x)=\frac{1}{p+1}\sum _{j=0}^{p}\binom{p+1}{j}B^+_jx^{p+1-j}$$

$$S_p(x)[x^j]=\frac{1}{p+1}\binom{p+1}{p+1-j}B^+_{p+1-j}$$

于是直接暴力推式子了。

$$c_j=\sum_{p=j-1}^n a_pS_p(x)[x^j]$$
$$c_j=\sum_{p=j-1}^n a_p\frac{1}{p+1}\binom{p+1}{p+1-j}B^+_{p+1-j}$$
$$c_j=\sum_{p=j-1}^n a_p\frac{1}{p+1}\frac{(p+1)!}{j!(p+1-j)!}B^+_{p+1-j}$$
$$c_j=\frac{1}{j!}\sum_{p=j-1}^n a_p\frac{p!}{(p+1-j)!}B^+_{p+1-j}$$
$$c_j=\frac{1}{j!}\sum_{p=j-1}^n (a_pp!)(\frac{B^+_{p+1-j}}{(p+1-j)!})$$
$$c_j=\frac{1}{j!}\sum_{p=j-1}^n (a_{n-(n-p)}(n-(n-p))!)(\frac{B^+_{p+1-j}}{(p+1-j)!})$$

现在，我们定义两个新序列：

$$x_i=a_{n-i}(n-i)!$$

$$y_i=\frac{B^+_i}{i!}$$

那么就有

$$c_j=\frac{1}{j!}\sum_{p=j-1}^n x_{n-p}y_{p+1-j}$$
$$c_j=\frac{1}{j!}\sum_{a+b=n+1-j}^n x_ay_b$$

这个是一个卷积的形式，因为出题人良心可以直接 NTT 来做。

最后只需要处理 $B^+_i$ 了，然后这个可以用它的 egf $\frac{x}{1-e^{-x}}$。

代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) { *s = __c; } *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) { x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; } return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) { qu[++ qr] = x % 10 + '0',  x /= 10; } while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define fi first
#define se second
#define pb push_back
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;
namespace poly {
	const int MOD = 998244353;
	const int IMAG = 86583718;
	const int NTTG = 3;
	
	int rev[524300];
	int minv[524300];
	int w[20][2][524300];
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
	void constructrev(int n) {
		for(int i=1, j=0; i < n; i++) {
			int bit=n>>1;
			for(;j&bit;bit>>=1)j^=bit;
			j^=bit; rev[i] = j;
		}
	}

	void constructroot(int n) {
		minv[1] = 1;
		iter(i, 2, n+1)
			minv[i]=1ll*(MOD-MOD/i)*minv[MOD%i]%MOD;
		for(int l=1; (1<<l)<=n; l++)
			rep(inv, 2) {
				int re = inv?qpow(minv[NTTG],(MOD-1)>>l):qpow(NTTG,(MOD-1)>>l);
				w[l][inv][0] = 1;
				rep1(i,(1<<(l-1))-1) w[l][inv][i] = 1ll*w[l][inv][i-1]*re%MOD;
			}
	}
	
	void ntt(int *v, int n, bool inv) {
		rep(i, n) if(i < rev[i]) swap(v[i], v[rev[i]]);
		for(int l=1;(1<<l)<=n;l++)
			for(int i=0;i<n;i+=(1<<l)) {
				int p=i+(1<<(l-1));
				iter(j, i, p) {
					int a=v[j],b=1ll*v[j+(1<<(l-1))]*w[l][inv][j-i]%MOD;
					v[j]=(a+b>=MOD?a+b-MOD:a+b);
					v[j+(1<<(l-1))]=(a<b?a+MOD-b:a-b);
				}
			}
		if(inv) rep(i, n) v[i] = 1ll*v[i]*minv[n]%MOD;
	}
	
	void mult(int *a, int as, int *b, int bs, int *o, bool construct, bool clean = 0, int th = 100000000) {
		int n = as+bs-1;
		while(n - (n & (-n))) n += (n & (-n));
		if(construct) constructroot(n);
		constructrev(n);
		ntt(a, n, 0); ntt(b, n, 0);
		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
		ntt(o, n, 1);
		iter(i, th, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(int* a, int as, int *o) {
		static int tmp[524300];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); int le = 0;
		while((1 << le) < (as << 1)) le++;
		constructrev(1 << le);
		rep(i, as) tmp[i] = a[i];
		iter(i, as, 1<<le) tmp[i] = o[i] = 0;
		ntt(tmp, 1<<le, 0); ntt(o, 1<<le, 0);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		ntt(o, 1<<le, 1);
		iter(i, as, 1<<le) o[i] = 0;
	}

	void init(int n) { constructroot(n); }
}

int fac[524300], ifac[524300], inv[524300];
int ini[524300], bern[524300];

int d[524300];
int f[524300];
int answer[524300];

int ncr(int n, int k) {
	return 1ll * fac[n] * ifac[k] % MOD * ifac[n-k] % MOD;
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    fac[0] = ifac[0] = fac[1] = ifac[1] = inv[0] = inv[1] = 1;
    int n; gi(n);
    iter(i, 2, n+2) {
    	inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;
    	fac[i] = 1ll * fac[i-1] * i % MOD;
    	ifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;
    }
    int th = 1; while(th < ((n+2)*2)) th <<= 1;
    poly::init(th);
    rep1(i, n+1) ini[i-1] = (MOD - (1ll * (i % 2 ? (MOD-1) : 1) * ifac[i]) % MOD) % MOD;
    poly::cfn(ini, n+1, bern);
    rep(i, n+1) {
    	gi(f[n-i]);
    	f[n-i] = 1ll * f[n-i] * fac[i] % MOD;
    }
    rep(i, n+1) d[i] = bern[i];
    print(f[n]);
    poly::mult(d, n+1, f, n+1, answer, 0);
    //poly::mult(d, n+2, f, n+2, answer, 0);
    rep1(j, n+1) {
    	int tot = answer[n+1-j];
    	tot = 1ll * tot * ifac[j] % MOD;
    	pc(' '); print(tot);
    }
}

```

---

## 作者：shadowice1984 (赞：8)

不知道为什么这题把自然数幂和函数的求和上限额外加了一个1，这样的话我们可能需要用二项式定理重新把原来的式子展开一遍……

### 前置芝士：伯努利数

如果不会伯努利数的话可以看一下[这篇博客](https://www.luogu.org/blog/ShadowassIIXVIIIIV/guan-yu-bo-nu-li-shuo-zhuai-hua-zi-ran-shuo-mi-hu-gong-shi-di-zheng-mi)学习一下

### 前置芝士：多项式求逆

蛤？不会多项式求逆，可以出门左转你站模板区去学习一下

### 前置芝士：快速处理伯努利数

我们使用伯努利数的指数型生成函数来快速的预处理它

具体来讲我们有这样一个和式

$$\sum_{i}\frac{B(i)}{i!}z^{i}=\frac{z}{e^{z}-1}$$

等会显然左边是一个无限和式，这东西显然没有办法计算啊

没关系啊，我们把$e^{z}$大力泰勒展开一下

$$e^{z}=\sum_{i}\frac{z^{i}}{i!}$$

那么我们要计算的式子就是

$$\frac{z}{\sum_{i}\frac{z^{i}}{i!}-1}$$

然后我们发现一个很尴尬的事实，这东西分母常数项是0求不了逆……

还好分子是$z$所以我们上下同时除一个$z$

$$\frac{1}{\sum_{i}\frac{z^{i}}{(i+1)!}}$$

那这样的话我们就可以愉快的多项式求逆然后把伯努利数的前$n$项刷出来了~

## 本题题解

众所周知，标准的自然数幂和函数$S(n,k)$是等于$\sum_{i=0}^{n-1}i^{k}$的但是这题我们的循环上限变成了$n$这就十分的难受了

所以设答案函数是$f(n)$，我们先计算比较好算的$f(n-1)$然后再用一些科技把答案的系数展开就好了

那么在以下的讨论当中我们认为$S(n,k)$代表$\sum_{i=0}^{n-1}i^{k}$而不是$\sum_{i=0}^{n}i^{k}$

题目中让我们求

$$\sum_{k=0}^{n}S(n,k)a(k)$$

强行用伯努利数展开一波可以得到

$$\sum_{k=0}^{n}a(k)\frac{1}{k+1}\sum_{i=0}^{k}{k+1 \choose i}B(i)n^{k+1-i}$$

接下来我们翻转后半部分的求和顺序

$$\sum_{k=0}^{n}a(k)\frac{1}{k+1}\sum_{i=1}^{k+1}{k+1 \choose k+1-i}B(k+1-i)n^{i}$$

让我们把组合数拆了搞成阶乘的形式

$$\sum_{k=0}^{n}a(k)k!\sum_{i=1}^{k+1}\frac{B(k+1-i)}{(k+1-i)!}\frac{n^{i}}{i!}$$

接下来又是喜闻乐见的交换求和号环节了

$$\sum_{i=1}^{n+1}\frac{n^{i}}{i!}\sum_{k=i-1}^{n}a(k)k!\frac{B(k+1-i)}{(k+1-i)!}$$

如果我们令$f,g$分别表示这两个式子的话

$$f(i)=\frac{B(i)}{i!}$$

$$g(i)=a(i)i!$$

式子会被写的好看一点

$$\sum_{i=1}^{n+1}\frac{n^i}{i!}\sum_{p-q=i-1}f(p)g(q)$$

似乎是个差卷积，众所周知我们的ntt只能处理和的卷积，所以让我们把g函数翻转一下

$$g_{r}(x)=g(n-x)$$


那么原来的式子就会变成

$$\sum_{i=1}^{n+1}\frac{n^i}{i!}\sum_{p+q=n+(i-1)}f(p)g_{r}(q)$$

这样的话我们一波ntt然后除上一个阶乘就可以求出$f(n-1)$第i项系数了，让我们设这个东西为$c_{i}$接下来我们要做的是求出这个多项式的系数

$$\sum_{i=1}^{n+1}c_{i}(x+1)^{i}$$

做法简单粗暴，直接二项式定理展开一下

$$\sum_{i=1}^{n+1}c_{i}\sum_{j=0}^{i}{i\choose j}x^{j}$$

让我们继续交换求和号，由于$c_{0}=0$所以我们无需担心求和下界的问题

$$\sum_{j=0}^{n+1}x^{j}\sum_{i=j}^{n+1}{i\choose j}c_{i}$$

把组合数用阶乘拆了可以得到

$$\sum_{j=0}^{n+1}x^{j}\frac{1}{j!}\sum_{i=j}^{n+1}c_{i}i!×\frac{1}{(i-j)!}$$

设$f,g$分别为

$$f(i)=c_{i}i!$$

$$g(i)=\frac{1}{i!}$$

那么我们会得到这样一个式子

$$\sum_{j=0}^{n+1}x^{j}\frac{1}{j!}\sum_{p-q=j}f(p)g(q)$$

看起来又是烦人的差卷积，没关系接着翻转数列,令

$$g_{r}(x)=g(n+1-x)$$

则原式为

$$\sum_{j=0}^{n+1}x^{j}\frac{1}{j!}\sum_{p+q=n+1+j}f(p)g(q)$$

然后我们大力ntt一波除个阶乘就行了

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=524288+10;typedef unsigned long long ll;const ll mod=998244353;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
# define md(x) (x=(x>mod)?x-mod:x)
int rv[22][N];ll rt[2][22];ll tr[N];ll ifac[N];ll bu[N];ll fac[N];ll a[N];int n;
ll f1[N];ll ans[N];
inline void pre()//预处理 
{
    for(int i=1;i<=19;i++)
        for(int j=1;j<(1<<i);j++)rv[i][j]=(rv[i][j>>1]>>1)|((j&1)<<(i-1));
    for(int i=1,t=(mod-1)/2;i<=20;i++,t>>=1)rt[0][i]=po(3,t);
    for(int i=1,t=(mod-1)/2;i<=20;i++,t>>=1)rt[1][i]=po(332748118,t);
}
inline void ntt(ll* a,int len,int d,int o)//简易ntt板子 
{
    for(int i=0;i<len;i++)if(i<rv[d][i])swap(a[i],a[rv[d][i]]);
    for(int k=1,j=1;k<len;k<<=1,j++)
        for(int s=0;s<len;s+=(k<<1))
            for(int i=s,w=1;i<s+k;i++,w=w*rt[o][j]%mod)
            {ll a1=a[i+k]*w%mod;a[i+k]=a[i]+mod-a1;md(a[i+k]);a[i]+=a1;md(a[i]);}
    if(o){ll iv=po(len,mod-2);for(int i=0;i<len;i++)(a[i]*=iv)%=mod;}
}
inline void poly_inv(ll* a,ll* b,int len)//简易多项式求逆 
{
    b[0]=po(a[0],mod-2);
    for(int k=2,d=1;k<=len;k<<=1,d++)
    {
        for(int i=0;i<k;i++)tr[i]=a[i];ntt(tr,(k<<1),d+1,0);ntt(b,(k<<1),d+1,0);
        for(int i=0;i<(k<<1);i++)b[i]=b[i]*(2+mod-tr[i]*b[i]%mod)%mod;
        ntt(b,(k<<1),d+1,1);for(int i=k;i<(k<<1);i++)b[i]=0;
    }
}
int main()
{
    pre();ifac[0]=1;
    ifac[1]=1;for(int i=2;i<=250005;i++)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;
    for(int i=2;i<=250005;i++)(ifac[i]*=ifac[i-1])%=mod;
    poly_inv(ifac+1,bu,262144);//这里懒了直接处理的所有的伯努利数 
    fac[0]=1;for(int i=1;i<=250005;i++)fac[i]=fac[i-1]*i%mod;
    scanf("%d",&n);
    for(int i=0;i<=n;i++)scanf("%lld",&a[i]);int len=524288;int d=19;
    for(int i=0;i<=n;i++)(a[i]*=fac[i])%=mod;ntt(a,len,d,0);
    for(int i=0;i<=n;i++)f1[i]=bu[n-i];ntt(f1,len,d,0);
    for(int i=0;i<len;i++)(f1[i]*=a[i])%=mod;ntt(f1,len,d,1);
    for(int i=1;i<=n+1;i++)f1[i]=f1[n+(i-1)]%mod;f1[0]=0;//预处理f(n-1)的系数 
    for(int i=n+2;i<len;i++)f1[i]=0;ntt(f1,len,d,0);
    for(int i=0;i<=n+1;i++)ans[i]=ifac[n+1-i];ntt(ans,len,d,0);
    for(int i=0;i<len;i++)(ans[i]*=f1[i])%=mod;ntt(ans,len,d,1);//二项式定理展开 
    for(int i=0;i<=n+1;i++)printf("%lld ",ans[n+1+i]*ifac[i]%mod);return 0;//拜拜程序~ 
}

```

---

## 作者：Jμdge (赞：6)

这题黑的丫！怎么会掉紫呢！

# noteskey

伯努利数... [这里](https://www.cnblogs.com/Judge/p/10722777.html) 有介绍哟~ 写的非常详细呢~

反正这题就是推柿子...

另外就是黈力算法的运用 QWQ 

我们令 $ANS(x)$ 为答案多项式，那么这个多项式可以这么求：

（下面我们定义 $S(n,k)$ 为自然幂和函数（不是第二类斯特林数！），即 $\sum_{i=0}^{ n} i^k$）

$$\begin{aligned}ANS(x)=& \sum_{k=0}^{n} S_k (x) a_k \\  =& \sum_{k=0}^{n} (S(x,k)+x^k) a_k \\  =&  \sum_{k=0}^n a_k \Big( x^k +{1\over k+1} \sum_{i=0}^k  \begin{pmatrix} k+1\\i \end{pmatrix} B_i x^{k+1-i}\Big)  \\  =&  \sum_{k=0}^n a_k \Big( x^k + k! \sum_{i=0}^k  {B_i\over i!} {x^{k+1-i} \over (k+1-i)! }\Big)                            \\  =&  \sum_{k=0}^n a_k x^k  + \sum_{k=0}^n a_k k! \sum_{i=0}^k  {B_i\over i!} {x^{k+1-i} \over (k+1-i)! }        \\  =&  \sum_{i=0}^n a_i  x^i + \sum_{i=1}^{n+1} {x^i\over  i!} \sum_{k=i-1}^{n}  a_k k!{B_{k+1-i}\over (k+1-i)!}          \end{aligned}$$


然后感觉做不下去了呢...后面虽说像是卷积的形式然鹅根本就不是卷积呢QWQ

首先，我们看着表达式太长了，于是乎把表达式换成一个函数：


$$\begin{aligned}f(i)=&~a_ii! \\g(i) =&~{B_i \over i!} \end{aligned}$$

那么原来的式子就是：

$$ANS=\sum_{i=0}^n a_i x^i  + \sum_{i=1}^{n+1} {x^i\over  i!} \sum_{k=i-1}^{n}  f(k)g(k+1-i)  $$

这样的话，我们就更加清晰的发现后面的式子不是卷积的形式了 XD

那么我们令 $gr(i)=g(n-i)$ （也就是翻转多项式）

然后原来的式子就是：

$$ANS=\sum_{i=0}^n a_i x^i+ \sum_{i=1}^{n+1} {x^i\over i!} \sum_{k=i-1}^{n}  f(k)gr(n+i-k-1)  $$

发现这里就是最高项改成 $n+i$ 项的卷积了，于是我们发现 要计算后面的 $\sum_{k=i-1}^n$ 什么的算出来的是 $f* gr$  的第 $(n+i-1)$ 项

于是我们把 $f* gr$ 的多项式求出来，拿第 $(n-i+1)$ 项乘上 $i!$ ，再加上 $a_i$ 就是最后多项式的第 i 项答案了


好像没有黑题难度？ 前提你得知道伯努利数这玩意儿丫！ 【雾 

而且这个推导过程...好像比 shadowice 巨巨的短很多丫...【小声



# code

不知道为什么不开 Ofast 跑得比开了快... 600ms + 

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=1<<19|3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x<y?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr=' '){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,limit; arr fac,ifac,a,B,C,r;
inline int qpow(int x,int p=mod-2,int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void init(int n){ int len=-1;
	for(limit=1;limit<=n;limit<<=1) ++len;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<len); 
}
inline void NTT(int* a,int tp){ fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(Rg int mid=1;mid<limit;mid<<=1){ Rg int I=mid<<1,Gn=qpow(tp?3:iG,(mod-1)/I);
		for(Rg int j=0,x;j<limit;j+=I) for(Rg int k=0,g=1;k<mid;++k,g=mul(g,Gn))
			x=mul(a[j+k+mid],g),a[j+k+mid]=dec(a[j+k],x),a[j+k]=inc(a[j+k],x);
	} if(tp) return ; int inv=qpow(limit); fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
void get_inv(int* a,int* b,int n){
	if(n==1) return b[0]=qpow(a[0]),void(); static int c[M],d[M];
	get_inv(a,b,n>>1),init(n); for(int i=0;i<n;++i) c[i]=a[i],d[i]=b[i];
	for(int i=n;i<limit;++i) c[i]=d[i]=0; NTT(c,1),NTT(d,1);
	fp(i,0,limit-1) c[i]=mul(c[i],mul(d[i],d[i])); NTT(c,0);
	fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),c[i]);
}
inline void prep(int len){ B[0]=ifac[0]=ifac[1]=fac[0]=fac[1]=1;
	fp(i,2,len) ifac[i]=mul(mod-mod/i,ifac[mod%i]);
	fp(i,2,len) ifac[i]=mul(ifac[i-1],ifac[i]),fac[i]=mul(fac[i-1],i);
	get_inv(ifac+1,B,len);
}
int main(){ n=read();
	for(limit=1;limit<=n;limit<<=1); prep(limit);
	fp(i,0,n) a[i]=read(),C[i]=mul(a[i],fac[i]);
	reverse(B,B+1+n),init(n<<1|1);
	fp(i,n+1,limit-1) B[i]=C[i]=0; NTT(B,1),NTT(C,1);
	fp(i,0,limit-1) B[i]=mul(B[i],C[i]); NTT(B,0);
	fp(i,0,n+1) B[n+i-1]=mul(B[n+i-1],ifac[i]);
	fp(i,0,n) B[n+i-1]=inc(B[n+i-1],a[i]);
	print(a[0]); fp(i,1,n+1) print(B[n+i-1]);
	return sr[CCF]='\n',Ot(),0;
}
```

# more...

其实我们只需要用另外一种伯努利数，就可以让推导更加简洁（没简洁多少，代码复杂度也基本没变的说）

这个伯努利数就是之前提到的那篇[博客](https://www.cnblogs.com/Judge/p/10722777.html)里面讲的 $B^+$，这个伯努利数列满足的性质更加适合做这道题...

于是我们令 $B=B^+$， 然后重推一遍：

（其实没必要，给个代码就 OJBK 了？ 【滑稽）



$$\begin{aligned}ANS(x)=& \sum_{k=0}^{n} S_k (x) a_k \\  =& \sum_{k=0}^{n} S^+(x,k) a_k \\  =&  \sum_{k=0}^n a_k \Big( {1\over k+1} \sum_{i=0}^k  \begin{pmatrix} k+1\\i \end{pmatrix} B_i x^{k+1-i} \Big) \\  =&  \sum_{k=0}^n a_k  k! \sum_{i=0}^k  {B_i\over i!} {x^{k+1-i} \over (k+1-i)! }                           \\  =& \sum_{i=1}^{n+1} {x^i\over i!} \sum_{k=i-1}^{n}  a_k k!{B_{k+1-i}\over (k+1-i)!}          \end{aligned}$$

依然令：

$$\begin{aligned}f(i)=&~a_ii! \\g(i) =&~{B_i \over i!} \\g_r(i)=&~g(n-i)\end{aligned}$$

（注意这里的 $B_i$ 就是 $B_i^+$ ）

$$ANS=\sum_{i=1}^{n+1} {x^i \over i!} \sum_{k=i-1}^{n}  f(k)gr(n+i-k-1)  $$


同样的，把 $f* g_r$ 的第 $(n-i+1)$ 项乘上 $i!$ 就是最后的答案了 ，不同的就是这里不需要再加上 $a_i$  XD


# code*2

代码...可谓没有什么区别

```cpp
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=1<<19|3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x<y?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr=' '){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,limit; arr fac,ifac,a,B,C,r;
inline int qpow(int x,int p=mod-2,int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void init(int n){ int len=-1;
	for(limit=1;limit<=n;limit<<=1) ++len;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<len); 
}
inline void NTT(int* a,int tp){ fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(Rg int mid=1;mid<limit;mid<<=1){ Rg int I=mid<<1,Gn=qpow(tp?3:iG,(mod-1)/I);
		for(Rg int j=0,x;j<limit;j+=I) for(Rg int k=0,g=1;k<mid;++k,g=mul(g,Gn))
			x=mul(a[j+k+mid],g),a[j+k+mid]=dec(a[j+k],x),a[j+k]=inc(a[j+k],x);
	} if(tp) return ; int inv=qpow(limit); fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
void get_inv(int* a,int* b,int n){
	if(n==1) return b[0]=qpow(a[0]),void(); static int c[M],d[M];
	get_inv(a,b,n>>1),init(n); for(int i=0;i<n;++i) c[i]=a[i],d[i]=b[i];
	for(int i=n;i<limit;++i) c[i]=d[i]=0; NTT(c,1),NTT(d,1);
	fp(i,0,limit-1) c[i]=mul(c[i],mul(d[i],d[i])); NTT(c,0);
	fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),c[i]);
}
inline void prep(int len){
	B[0]=ifac[0]=ifac[1]=fac[0]=fac[1]=1;
	fp(i,2,len) ifac[i]=mul(mod-mod/i,ifac[mod%i]);
	fp(i,2,len) ifac[i]=mul(ifac[i-1],ifac[i]);
	fp(i,2,len) fac[i]=mul(fac[i-1],i);
	get_inv(ifac+1,B,len); B[1]=mod-B[1];
}
int main(){ n=read();
	for(limit=1;limit<=n;limit<<=1); prep(limit);
	fp(i,0,n) a[i]=read(),C[i]=mul(a[i],fac[i]);
	reverse(B,B+1+n),init(n<<1|1);
	fp(i,n+1,limit-1) B[i]=C[i]=0; NTT(B,1),NTT(C,1);
	fp(i,0,limit-1) B[i]=mul(B[i],C[i]); NTT(B,0);
	fp(i,0,n+1) B[n+i-1]=mul(B[n+i-1],ifac[i]);
	print(a[0]); fp(i,1,n+1) print(B[n+i-1]);
	return sr[CCF]='\n',Ot(),0;
}
```




# update

虽说是文化课选手辣，但还是改了一下错误的柿子...讲道理大家能 get 到想法就行了








---

## 作者：jun头吉吉 (赞：4)

## 题意
定义 $\displaystyle sum(x,k)=\sum_{i=0}^xi^k$ ，求  $\displaystyle F(x)=\sum_{k=0}^na_k\times sum(x,k)$ 的系数。可以证明次数不超过 $n+1$
## 题解
考虑 $S(n,m)=\sum_{k=0}^{n-1}k^m$ 的 $\mathbb{EGF}$ $\hat{S}(x)$ ,还有一个神秘的 $\mathbb{EGF}$ $\hat{B}$以及 $B(i)=i![x^i]\hat{B}(x)$

$$\begin{aligned}
\hat{S}(x)&=\sum_{i=0}^\infty S(n,i)\frac{x^i}{i!}
=\sum_{i=0}^\infty\left(\sum_{k=0}^{n-1}k^i\right)\frac{x^i}{i!}\\
&=\sum_{k=0}^{n-1}\left(\sum_{i=0}^\infty\frac{(xk)^i}{i!}\right)=\sum_{k=0}^{n-1}\left(e^x\right)^k\\
&=\frac{e^{nx}-1}{e^x-1}=\frac{e^{nx}-1}{x}\times\frac{x}{e^x-1}\\
&=\sum_{i=1}^\infty\frac{n^i x^{i-1}}{i!}\sum_{i=0}^\infty\frac{B(i)x^i}{i!}
\end{aligned}$$

然后就可以提取系数 $[x^m]\hat{S}=\sum_{i=1}^m\frac{n^i}{i!}\times\frac{B(m-i+1)}{(m-i+1)!}$，也就是
$$S(n,m)=m!\sum_{i=1}^{m+1}\frac{n^iB(m-i+1)}{i!(m-i+1)}$$
以及一种可能更优美的写法
$$S(n,m)=\frac{1}{m+1}\sum_{i=0}^m\binom{m+1}{i}n^{m-i+1}B(i)$$
不过此题我们只使用第一个柿子。

考虑 $B(i)$ 怎么求，根据定义式 $\dfrac{x}{e^x-1}$，不过常数项是 $0$。还好上面的常数项也是 $0$，于是上下同除 $x+\rm Taylor\text{公式}$ 得到 $\displaystyle\frac{1}{\sum_{i=1}^\infty\frac{x^{i-1}}{i!}}$

不难有 $sum(x,k)=S(x,k)+x^k$ ,于是再来推柿子
$$
\begin{aligned}
F(x)&=\sum_{k=0}^na_i\times sum(x,k)\\
&=\sum_{k=0}^na_kx^k+\sum_{k=0}^na_kS(x,k)\\
&=F_0(x)+\sum_{k=0}^na_kk!\sum_{i=1}^{k+1}\frac{x^i}{i!}\times\frac{B(k-i+1)}{(k-i+1)!}\\
&=F_0(x)+\sum_{i=1}^{n+1}\frac{x^i}{i!}\sum_{k=0}
^na_kk!\times \frac{B(k-i+1)}{(k-i+1)!}	\\
&\text{记} c_k=a_kk!,d_{n-k}=\frac{B(k)}{k!}\\
&=F_0(x)+\sum_{i=1}^{n+1}\frac{x^i}{i!}\sum_{k=0}^nc_kd_{n-k+i-1}
\end{aligned}
$$
$\rm NTT$ 卷一下就做完了。
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
		while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
	char getC(){char c=getc();while(!isdigit(c)&&!isalpha(c))c=getc();return c;}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
	template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
	modint<mod> &operator++(int){return *this+=1;}
};
const int N=6e5+5;
const int mod=998244353;
typedef modint<mod> mint;
const mint GG=3,Ginv=mint(1)/3,I=86583718;
struct poly{
	vector<mint>a;
	mint&operator[](int i){return a[i];}
	int size(){return a.size();}
	void resize(int n){a.resize(n);}
	void reverse(){std::reverse(a.begin(),a.end());}
	void print(char op=' '){for(auto x:a)out::write(x.x),out::putc(op);}
};
int rev[N];
inline poly one(){poly a;a.a.push_back(1);return a;}
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){int n=1<<k;for(int i=0;i<n;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));}
inline void ntt(poly&a,int k,int typ){
	int n=1<<k;
	for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int mid=1;mid<n;mid<<=1){
		mint wn=(typ>0?GG:Ginv)^((mod-1)/(mid<<1));
		for(int r=mid<<1,j=0;j<n;j+=r){
			mint w=1;
			for(int k=0;k<mid;k++,w=w*wn){
				mint x=a[j+k],y=w*a[j+k+mid];
				a[j+k]=x+y,a[j+k+mid]=x-y;
			}
		}
	}
	if(typ<0){
		mint inv=mint(1)/n;
		for(int i=0;i<n;i++)a[i]*=inv;
	}
}
inline poly operator*(poly a,poly b){
	int n=a.size()+b.size()-1,k=ext(n);
	a.resize(1<<k),b.resize(1<<k),init(k);
	ntt(a,k,1);ntt(b,k,1);for(int i=0;i<(1<<k);i++)a[i]*=b[i];
	ntt(a,k,-1),a.resize(n);return a;
}
poly inv(poly F,int k){
	int n=1<<k;F.resize(n);
	if(n==1){F[0]=modint<mod>(1)/F[0];return F;}
	poly G,H=inv(F,k-1);
	G.resize(n),H.resize(n<<1),F.resize(n<<1);
	for(int i=0;i<n/2;i++)G[i]=H[i]*2;
	init(k+1),ntt(H,k+1,1),ntt(F,k+1,1);
	for(int i=0;i<(n<<1);i++)H[i]=H[i]*H[i]*F[i];
	ntt(H,k+1,-1),H.resize(n);
	for(int i=0;i<n;i++)G[i]-=H[i];return G;
}
inline poly inv(poly a){
	int n=a.size();
	a=inv(a,ext(n)),a.resize(n);return a;;
}
int n;mint a[N],fac[N],ifac[N];
signed main(){
	in::read(n);for(int i=0;i<=n;i++)in::read(a[i]);
	fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i;
	ifac[N-1]=1/fac[N-1];for(int i=N-1;i;i--)ifac[i-1]=ifac[i]*i;
	poly f,B,c,d;
	//求出 1-n 的伯努利数
	B.resize(n+2);for(int i=0;i<=n+1;i++)B[i]=ifac[i+1];B=inv(B);
	//B.print();out::putc('\n');
	c.resize(n+2);d.resize(n+2);
	for(int k=0;k<=n;k++)c[k]=a[k]*fac[k];
	for(int k=0;k<=n;k++)d[n-k]=B[k];
	c=c*d;
	f.resize(n+2);
	for(int i=1;i<=n+1;i++)f[i]=ifac[i]*c[n+i-1]+a[i];f[0]=a[0];
	f.print();out::flush();
}
```

---

## 作者：Mivik (赞：3)

[欢迎到我的博客查看](https://mivik.gitee.io/2020/solution/hamsters-math-problem/)


> 给定 $n$ 和 长度为 $n+1$ 的数组 $a_0\cdots a_n$，求
>
> $$
> \sum_{k=0}^n a_k\sum_{i=0}^x i^k
> $$
>
> $1\le n\le 250000$，答案对 $998244353$ 取模。

---

我们令 $S_{n,k}=\sum_{i=0}^{n-1}i^k$，然后我们考虑求出 $S_{n,k}$ **关于 $k$ 的** 指数生成函数 $S_n(x)$：

$$
\begin{aligned}
S_n(x)&=\sum_{k=0}^\infty \frac{x^k}{k!}\sum_{i=0}^{n-1} i^k\\
&=\sum_{i=0}^{n-1}\sum_{k=0}^\infty \frac{(xi)^k}{k!}\\
&=\sum_{i=0}^{n-1}(e^x)^i\\
&=\frac{e^{nx}-1}{e^x-1}
\end{aligned}
$$

考虑怎么拿到这个东西的第 $k$ 项系数。先设 $B(x)=\frac{x}{e^x-1}$，于是有：
$$
\begin{aligned}
S_n(x)&=\frac{e^{nx}-1}{x}\cdot B(x)\\
S_n(x)&=\left(\sum_{i=0}^\infty \frac{n^{i+1}}{(i+1)!}x^i\right)\cdot B(x)\\
\frac{S_{n,k}}{k!}&=\sum_{i=0}^k \frac{n^{i+1}}{(i+1)!}\cdot\frac{B_{k-i}}{(k-i)!}
\end{aligned}
$$

然后我们转换原式（由于我们只求到了 $n-1$ 所以要加上 $n^k$）：
$$
\begin{aligned}
&\sum_{k=0}^n a_k\sum_{i=0}^x i^k\\
=&\sum_{k=0}^n a_k\left(x^k+S_{x,k}\right)\\
=&\sum_{k=0}^n a_k\left(x^k+k!\sum_{i=0}^k \frac{x^{i+1}}{(i+1)!}\cdot\frac{B_{k-i}}{(k-i)!}\right)\\
=&\left(\sum_{k=0}^n a_k x^k\right)+\sum_{i=0}^n\frac{x^{i+1}}{(i+1)!}\sum_{k=i}^n a_k k!\frac{B_{k-i}}{(k-i)!}
\end{aligned}
$$

然后记 $B'_i=B_{n-i}$，然后上面右边那个式子就可以卷积了。

~~为看到的题解区里面一位把 $(n+1)$ 带入上面式子然后二项式定理展开的可怜老哥默哀~~

要注意的一个细节是怎么求 $B$。上文提到 $B=\frac{x}{e^x-1}$， 但是直接多项式求逆会发现由于 $(e^x-1)$ 常数项为 0，没法求逆，考虑把上面的 $x$ 弄下来，然后得到：
$$
B=\frac{1}{\sum_{i=0}^\infty \frac{x^i}{(i+1)!}}
$$
然后就可做了。顺带一提，这里的 $B$ 就是多数题解里面提到的伯努利数。

[mivik.h](https://mivik.gitee.io/mivik.h)

[代码](https://paste.ubuntu.com/p/MnQwcccB8B/)

---

## 作者：littlez_meow (赞：1)

组合推式子。

[题目指路](https://www.luogu.com.cn/problem/P3711)。

## 题意

设 $S_k(x)=\sum\limits_{i=0}^x i^k$，给定 $a_0\sim a_n$，求多项式 $\sum\limits_{i=0}^n a_iS_i(x)$。

## 思路

时限 $1$ 秒，转成下降幂多项式用斯特林数推再转回来常数肯定太大了。我们必须绕开下降幂这个连接斯特林数的纽带。

怎么办呢？我们有自然数幂和多项式：

$$S_k(x)=\dfrac1{k+1}\sum\limits_{i=0}^k\dbinom{k+1}{i}B_i(x+1)^{k+1-i}$$

其中 $B_i$ 为伯努利数，其 EGF 为 $\dfrac x{e^x-1}$，约分一个 $x$ 后多项式求逆即可。

开始今日份 Dirty Works。答案为：

$$\sum\limits_{k=0}^na_k\dfrac1{k+1}\sum\limits_{i=0}^k\dbinom{k+1}{i}B_i(x+1)^{k+1-i}$$

$x+1$ 上的指数太难看了，改变枚举方向：

$$\sum\limits_{k=0}^na_k\dfrac1{k+1}\sum\limits_{i=0}^k\dbinom{k+1}{k-i}B_{k-i}(x+1)^{i+1}$$


根据组合意义，改变枚举范围：

$$\sum\limits_{k=0}^na_k\dfrac1{k+1}\sum\limits_{i=0}^n\dbinom{k+1}{k-i}B_{k-i}(x+1)^{i+1}$$

这下可以交换枚举顺序了：

$$\sum\limits_{i=0}^n(x+1)^{i+1}\sum\limits_{k=i}^na_k\dfrac1{k+1}\dbinom{k+1}{k-i}B_{k-i}$$

展开组合数，$k+1$ 消掉：

$$\sum\limits_{i=0}^n(x+1)^{i+1}\sum\limits_{k=i}^na_k\dfrac{k!}{(i+1)!(k-i)!}B_{k-i}$$

整理一下：

$$\sum\limits_{i=0}^n\dfrac{(x+1)^{i+1}}{(i+1)!}\sum\limits_{k=i}^na_kk!\dfrac{B_{k-i}}{(k-i)!}$$

设得到的关于 $x+1$ 的多项式为 $\sum\limits_{i=0}^{n+1}g_i(x+1)^i$。一次差卷积得到 $g$。再展开：

$$\sum\limits_{i=0}^{n+1}g_i\sum\limits_{j=0}^i\binom{i}{j}x^j$$

改变循环上界，交换枚举顺序，展开组合数：

$$\sum\limits_{j=0}^{n+1}\dfrac{x^j}{j!}\sum\limits_{i=j}^{n+1}g_ii!\dfrac1{(i-j)!}$$

再来一次差卷积。

时间复杂度 $O(n\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i) 
#define ll long long
using namespace std;
const int MAXN=(1<<20)+1;
const int MOD=998244353,G=3;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
const int INVG=qpow(G,MOD-2),I=qpow(G,(MOD-1)/4);
int gpow[21],invgpow[21];
inline void calc(){
	F(i,1,20) gpow[i]=qpow(G,(MOD-1)>>i),invgpow[i]=qpow(INVG,(MOD-1)>>i);
	return;
}
inline void meow(int&t){
	t<0&&(t+=MOD);
	t>=MOD&&(t-=MOD);
	return;
}
int rev[MAXN];
inline void NTT(int*poly,int len,bool inv){
	F(i,0,len-1) (i<rev[i])&&(swap(poly[i],poly[rev[i]]),1);
	static ll g[MAXN];
	g[0]=1;
	for(int i(1),expo(1);i<len;i<<=1,++expo){
		ll omega=inv?invgpow[expo]:gpow[expo];
		F(j,1,i-1) g[j]=g[j-1]*omega%MOD;
		for(int j(0);j<len;j+=(i<<1)) F(k,0,i-1){
			int&x(poly[j|k]),&y(poly[i|j|k]);
			ll qwq(g[k]*y%MOD);
			y=x-qwq;
			y<0&&(y+=MOD);
			x+=qwq;
			x>=MOD&&(x-=MOD);
		}
	}
	if(inv){
		ll invl=qpow(len,MOD-2);
		F(i,0,len-1) poly[i]=poly[i]*invl%MOD;
	}
	return;
}
struct poly{
	int num[MAXN]={};
	int len=0;
	
	inline void resize(const int a){
		for(;len>a;--len) num[len]=0;
		len=a;
		if(len<0) len=0;
		return;
	}
	inline poly operator+(const poly a)const{
		poly res;
		res.len=max(a.len,len);
		F(i,0,res.len) res.num[i]=((num[i]+a.num[i])%MOD+MOD)%MOD;
		return res;
	}
	inline poly operator+(const int a)const{
		poly res=*this;
		int&qwq(res.num[0]);
		qwq+=a;
		meow(qwq);
		return res;
	}
	inline poly operator-(const poly a)const{
		return a*(-1)+*this;
	}
	inline poly operator-(const int a)const{
		return *this+(-a);
	}
	inline poly operator*(const poly a)const{
		poly x,y=*this;
		if(a.len*1ll*len<=1e5){
			x.len=a.len+len;
			F(i,0,len) F(j,0,a.len){
				int&qwq(x.num[i+j]);
				qwq+=a.num[j]*1ll*num[i]%MOD;
				qwq>=MOD&&(qwq-=MOD);
			}
			return x;
		}
		x=a;
		int expo=max(__lg(((len+a.len+1)<<1)+1)+1,1),l=1<<expo;
		F(i,0,l-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<(expo-1));
		NTT(x.num,l,0);
		NTT(y.num,l,0);
		F(i,0,l-1) x.num[i]=1ll*x.num[i]*y.num[i]%MOD;
		NTT(x.num,l,1);
		x.resize(len+a.len);
		return x;
	}
	inline poly operator*(const int a)const{
		poly res=*this;
		F(i,0,len){
			int&qwq(res.num[i]);
			qwq=a*1ll*qwq%MOD;
			meow(qwq);
		}
		return res;
	}
	inline poly inv(){
		poly res;
		res.num[0]=qpow(num[0],MOD-2);
		for(int l(2),expo(1);l<(len<<1);l<<=1,++expo){
			int tmp[MAXN]={};
			F(i,0,(l<<1)-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<expo);
			memcpy(tmp,num,sizeof(int)*l);
			NTT(tmp,l<<1,0);
			NTT(res.num,l<<1,0);
			F(i,0,(l<<1)-1){
				int&qwq(res.num[i]),t(2-1ll*qwq*tmp[i]%MOD);
				meow(t);
				qwq=1ll*qwq*t%MOD;
			}
			NTT(res.num,l<<1,1);
			F(i,l,(l<<1)-1) res.num[i]=0;
		}
		res.resize(len);
		return res;
	}
};
poly B,g,factor;
int fact[MAXN],inv[MAXN];
int n,a[MAXN];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	calc();
	cin>>n;
	fact[0]=1;
	F(i,1,n+2) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[n+2]=qpow(fact[n+2],MOD-2);
	R(i,n+2,1) inv[i-1]=inv[i]*1ll*i%MOD;
	F(i,0,n) cin>>g.num[i],g.num[i]=g.num[i]*1ll*fact[i]%MOD;
	g.len=n;
	B.len=n+1;
	F(i,0,n+1) B.num[i]=inv[i+1];
	B=B.inv();
	B.resize(n);
	reverse(g.num,g.num+n+1);
	g=g*B;
	reverse(g.num,g.num+n+1);
	F(i,0,n) factor.num[i+1]=g.num[i];
	F(i,0,n+1) B.num[i]=inv[i];
	factor.len=B.len=n+1;
	reverse(factor.num,factor.num+n+2);
	factor=factor*B;
	reverse(factor.num,factor.num+n+2);
	F(i,0,n+1) cout<<factor.num[i]*1ll*inv[i]%MOD<<" ";
	return 0;
}
```

---

## 作者：peterwuyihong (赞：1)

题意：$S_k(x)=\sum_{i=0}^xi^k$，默认 $0^0=1$，求

$$\sum_{i=0}^nS_i(x)a_i$$

这个多项式，$n\le250000$，对 $998244353$ 取模。

我们知道[一个东西](https://www.luogu.com.cn/blog/Peterprpr/hxznohorse)，然后我们让 $B_n=B_n+[n=1]$。

后面那个 $B_n$ 为原来的伯努利数，前面那个 $B_n$ 表示我们的伯努利数。

$$\frac 1{m+1}\sum_{k=0}^m\binom{m+1}k(B_k+[k=1])n^{m+1-k}$$

$$\sum_{i=0}^n\frac{a_i}{i+1}\sum_{j=0}^{i}B_{j}\binom{i+1}{j}x^{i+1-j}$$

$$\sum_{i=0}^n\frac{a_i}{i+1}\sum_{j=0}^{i}B_{i-j}\binom{i+1}{j+1}x^{j+1}$$

$$\sum_{j=0}^{n}\frac{x^{j+1}}{(j+1)!}\sum_{i=j}^n\frac{a_i}{i+1}B_{i-j}\frac{(i+1)!}{(i-j)!}$$

$$\sum_{j=0}^{n}\frac{x^{j+1}}{(j+1)!}\sum_{i=j}^nB_{i-j}\frac{a_ii!}{(i-j)!}$$

$$\sum_{j=0}^{n}\frac{x^{j+1}}{(j+1)!}\sum_{i=0}^{n-j}B_{i}\frac{a_{i+j}(i+j)!}{i!}$$

记 $c_i=a_{n-i}(n-i)!$

$$\sum_{j=0}^{n}\frac{x^{j+1}}{(j+1)!}\sum_{i=0}^{n-j}\frac{B_{i}}{i!}c_{n-j-i}$$

卷就是了。

因为上面放的链接的做法有局限性，就是 $k=0$ 时不行，所以 $[x^0]$ 还要特判。

```cpp
int r;
signed main(){
  int n;
  cin>>n;
  poly a(n+1),c(n+1);
  init(extend(n+1));
  rep(i,0,n)a[i]=jcinv[i+1];
  a=Inv(a);
  a[1]++;
  rep(i,0,n){
    cin>>r;
    if(i==0)cout<<r<<' ';
    c[n-i]=Mul(jc[i],r);
  }
  c=c*a;
  rep(i,0,n)cout<<Mul(c[n-i],jcinv[i+1])<<" ";
}
```
附赠[多项式板子](https://www.luogu.com.cn/blog/Peterprpr/mu-ban)。

---

## 作者：tzc_wk (赞：1)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P3711)

提供一种不太一样的做法。

假设要求的多项式为 $f(x)$。我们考察 $f(x)-f(x-1)$，不难发现其等于 $\sum\limits_{i=0}^na_ix^i$

考虑设 $f(x)=\sum\limits_{i=0}^{n+1}b_ix^i$，那么直接代入 $x-1$ 并化简可以得到：
$$
\begin{aligned}
f(x-1)&=\sum\limits_{i=0}^{n+1}b_i(x-1)^i\\
&=\sum\limits_{i=0}^{n+1}b_i\sum\limits_{j=0}^i\dbinom{i}{j}(-1)^{i-j}x^j\\
&=\sum\limits_{i=0}^{n+1}(\sum\limits_{j=i}^{n+1}\dbinom{j}{i}(-1)^{j-i}b_j)x^i
\end{aligned}
$$
故
$$
\begin{aligned}
f(x)-f(x-1)&=\sum\limits_{i=0}^{n+1}(\sum\limits_{j=i+1}^{n+1}\dbinom{j}{i}(-1)^{j-i}b_j)x^i
\end{aligned}
$$
根据 $f(x)-f(x-1)=\sum\limits_{i=0}^na_ix^i$ 可得
$$
\sum\limits_{j=i+1}^{n+1}\dbinom{j}{i}(-1)^{j-i}b_j=a_i
$$
按照套路拆组合数：
$$
\dfrac{1}{i!}\sum\limits_{j=i+1}^{n+1}(j!·b_j)·(\dfrac{1}{(j-i)!}(-1)^{j-i})=a_i
$$
设
$$
f_i=i!·b_i
$$

$$
g_i=\dfrac{1}{i!}(-1)^i,g_0=0
$$

$$
h_i=a_i·i!
$$

那么上式可以写作：
$$
h_i=\sum\limits_{x-y=i}f_xg_y
$$
喜闻乐见的减法卷积，按照套路设
$$
f'_i=f_{n+1-i},h'_i=h_{n+1-i}
$$
那么有 $h'$ 为 $f'$ 与 $g$，按照常理是一遍求逆就可以解决的事，但是非常悲催的是 $g_0=0$，因此无法直接求逆，不过注意到对于 $f'$ 和 $h'$ 同样有它们的第 $0$ 项为 $0$，因此可以将数组全部向前平移一位然后求逆。还有就是原数组是 $n+1$ 次多项式，平移以后变成了 $n$ 次多项式，因此我们可以大致确定的 $f_i$ 只有 $n+1$ 位，怎么办呢？首先注意到 $f'_{n+1}=b_0$，也就是待求多项式的常数项，因此我们可以代入 $x=0$ 求得 $f'_{n+1}=a_{0}$。还有就是由于你对 $f',g$ 卷积是在 $\bmod x^{n+1}$ 意义下进行，并且 $g_0=0$，因此理论上来说 $f'_n$ 是不能通过 $f'$ 与 $g$ 卷积为 $h'$ 这一条件确定的，不过注意到多项式求逆的过程中如果我们固定住 $f'_0$，那么所有数都可表示为 $f'_i=v_i·\dfrac{1}{f'_0}$ 的形式，其中 $v_i$ 为常数，也就是说我们求出来的 $f'$ 与真正的 $f'$ 是存在比例关系的，因此我们考虑代入 $x=1$ 求出待求多项式的系数和，这样即可求出真正的 $f'$ 相较于我们求出的 $f'$ 缩放了多少倍，也就可以求出真正的 $f'$。

时间复杂度 $n\log n$。

```cpp
const int pr=3;
const int ipr=332748118;
const int MAXN=255555;
const int MAXP=524288;
int n,fac[MAXN+5],ifac[MAXN+5];
void init_fac(int n){
	for(int i=(fac[0]=ifac[0]=ifac[1]=1)+1;i<=n;i++) ifac[i]=1ll*ifac[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%MOD,ifac[i]=1ll*ifac[i-1]*ifac[i]%MOD;
}
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int rev[MAXP+5];
void NTT(vector<int> &a,int len,int type){
	int lg=31-__builtin_clz(len);
	for(int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<lg-1);
	for(int i=0;i<len;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		int W=qpow((type<0)?ipr:pr,(MOD-1)/i);
		for(int j=0;j<len;j+=i){
			for(int k=0,w=1;k<(i>>1);k++,w=1ll*w*W%MOD){
				int X=a[j+k],Y=1ll*w*a[(i>>1)+j+k]%MOD;
				a[j+k]=(X+Y)%MOD;a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
			}
		}
	} if(!~type){
		int ivn=qpow(len,MOD-2);
		for(int i=0;i<len;i++) a[i]=1ll*a[i]*ivn%MOD;
	}
}
vector<int> conv(vector<int> a,vector<int> b){
	int LEN=1;while(LEN<a.size()+b.size()) LEN<<=1;
	a.resize(LEN,0);b.resize(LEN,0);NTT(a,LEN,1);NTT(b,LEN,1);
	for(int i=0;i<LEN;i++) a[i]=1ll*a[i]*b[i]%MOD;
	NTT(a,LEN,-1);return a;
}
vector<int> getinv(vector<int> a,int len){
	vector<int> b(len,0);b[0]=qpow(a[0],MOD-2);
	for(int i=2;i<=len;i<<=1){
		vector<int> c(b.begin(),b.begin()+(i>>1));
		vector<int> d(a.begin(),a.begin()+i);
		c=conv(conv(c,c),d);
		for(int j=0;j<i;j++) b[j]=(2ll*b[j]-c[j]+MOD)%MOD;
	} return b;
}
vector<int> A,B;
int res[MAXN+5];
int main(){
	scanf("%d",&n);init_fac(MAXN);A.resize(n+2);int sum=0;
	for(int i=n;~i;i--) scanf("%d",&A[i]),sum=(sum+A[i])%MOD,A[i]=1ll*A[i]*fac[n-i]%MOD;
	B.resize(n+2);for(int i=1;i<=n+1;i++) B[i-1]=(i&1)?(MOD-ifac[i]):ifac[i];
	int LEN=1;while(LEN<=n+2) LEN<<=1;
	A.resize(LEN,0);B.resize(LEN,0);
	vector<int> C=conv(A,getinv(B,LEN));
//	printf("A: ");for(int i=0;i<n+1;i++) printf("%d%c",A[i]," \n"[i==n]);
//	printf("B: ");for(int i=0;i<n+1;i++) printf("%d%c",B[i]," \n"[i==n]);
	for(int i=1;i<=n+1;i++) res[i]=1ll*C[n+1-i]*ifac[i]%MOD;
	res[0]=A[n];int iv=qpow(res[n+1],MOD-2);
	for(int i=1;i<=n+1;i++) res[i]=1ll*res[i]*iv%MOD;
	int ssum=0;for(int i=1;i<=n+1;i++) ssum=(ssum+res[i])%MOD;
	int mul=1ll*sum*qpow(ssum,MOD-2)%MOD;
	for(int i=1;i<=n+1;i++) res[i]=1ll*res[i]*mul%MOD;
	for(int i=0;i<=n+1;i++) printf("%d%c",res[i]," \n"[i==n+1]);
	return 0;
}
```



---

## 作者：木xx木大 (赞：0)

[P3711 仓鼠的数学题](https://www.luogu.com.cn/problem/P3711) 

**前置知识：伯努利数**

定义伯努利数 $\sum_{i=0}^nB_i{n+1\choose i}=[n=0]$。设其指数型生成函数为 $B(x)$
$$
\begin{aligned}
\sum_{i=0}^{n+1}B_i{n+1\choose i}=[n=0]+B_{n+1}\\
				\sum_{i=0}^{n}B_i{n\choose i}=[n=1]+B_{n}\\
				\sum_{i=0}^{n}\frac{B_i}{i!}\frac{1}{(n-i)!}=[n=1]+\frac{B_n}{n!}\\
					B(x)e^x=x+B(x)\Rightarrow B(x)=\frac{x}{e^x-1}
			\end{aligned}
$$
伯努利数可以用来算自然数幂和。设 $S_m(n)=\sum\limits_{i=0}^{n-1}i^m,G(x)=\sum\limits_{i=0}\frac{S_i(n)x^i}{i!}$，$B$ 表示伯努利数，则有
$$
G(x)=\sum_{i=0}\sum_{j=0}^{n-1}j^i\frac{x^i}{i!}=\sum_{j=0}^{n-1}e^{jx}=\frac{e^{nx}-1}{e^x-1}=B(x)\frac{e^{nx}-1}{x}=B(x)\sum_{i=0}\frac{n^{i+1}x^i}{(i+1)!}\\
S_m(n)=\frac{1}{m+1}\sum_{i=0}^m{m+1\choose i}{B_i}n^{m+1-i}
$$

**本题solution**

~~如果会了上面的部分，这题其实挺板的。~~

假设 $S_k(x)=\sum_{i=0}^{x-1}i^k$，之后把 $x$ 全换为 $x+1$ 即可。根据自然数幂和的公式
$$
\begin{aligned}
&\sum_{k=0}^{n}\frac{a_k}{k+1}\sum_{i=0}^k{k+1\choose i}{B_i}x^{k+1-i}\\
=&\sum_{k=0}^{n}\frac{a_k}{k+1}\sum_{i=0}^k{k+1\choose k-i}{B_{k-i}}x^{i+1}\\
=&\sum_{k=0}^{n}k!a_k\sum_{i=0}^k\frac{B_{k-i}}{(k-i)!}\frac{x^{i+1}}{(i+1)!}\\
=&\sum_{i=1}^{n+1}\frac{x^{i}}{i!}\sum_{k=i-1}^{n}k!a_k\frac{B_{k-i+1}}{(k-i+1)!}\\
\end{aligned}
$$

后半部分是个差卷积的形式，可以直接算。设后半部分为 $f_i$ ，将 $x+1$ 代入得
$$
\begin{aligned}&\sum_{i=1}^{n+1}\frac{(x+1)^{i}}{i!}f_i\\=&\sum_{i=1}^{n+1}\frac{f_i}{i!}\sum_{j=0}^i{i\choose j}x^j\\=&\sum_{i=0}^{n+1}\frac{x^i}{i!}\sum_{j=i}^{n+1}\frac{f_j}{(j-i)!}\end{aligned}
$$

仍然是差卷积，直接算即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace FGF
{
	const int N=1e6+5,mo=998244353,g=3,gi=(mo+1)/3;
	int n,lim,r[N],a[N],inv[N],b[N],fac[N],c[N];
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void NTT(int *y,int op)
	{	
		for(int i=0;i<lim;i++)
			if(r[i]<i)swap(y[r[i]],y[i]);
		for(int l=1;l<lim;l<<=1)
			for(int i=0,wn=qpow(op==1?g:gi,(mo-1)/(l<<1));i<lim;i+=(l<<1))
				for(int j=0,w=1;j<l;j++,w=1ll*w*wn%mo)
				{
					int tmp=(y[i+j]-1ll*w*y[i+j+l]%mo+mo)%mo;
					y[i+j]=(y[i+j]+1ll*w*y[i+j+l]%mo)%mo,y[i+j+l]=tmp;
				}
		if(op==-1)
			for(int i=0,inv=qpow(lim,mo-2);i<lim;i++)
				y[i]=1ll*y[i]*inv%mo;	
	}
	void getinv(int *ans,int *a,int n)
	{
		if(n==1){ans[0]=qpow(a[0],mo-2);return ;}
		getinv(ans,a,n>>1);
		static int tmp[N];
		lim=n<<1;
		for(int i=0;i<lim;i++)tmp[i]=0,r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		for(int i=0;i<n;i++)tmp[i]=a[i];
		NTT(tmp,1),NTT(ans,1);
		for(int i=0;i<lim;i++)ans[i]=1ll*ans[i]*(2ll-1ll*ans[i]*tmp[i]%mo+mo)%mo;
		NTT(ans,-1);
		for(int i=n;i<lim;i++)ans[i]=0;
	}
	void work()
	{
		scanf("%d",&n);
		fac[0]=inv[0]=inv[1]=1;
		for(int i=2;i<=n+10;i++)
			inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;
		for(int i=1;i<=n+10;i++)
			fac[i]=1ll*i*fac[i-1]%mo,inv[i]=1ll*inv[i-1]*inv[i]%mo;
		for(int i=0;i<=n;i++)
			scanf("%d",&a[i]),a[i]=1ll*a[i]*fac[i]%mo;
		for(lim=1;lim<(n+1);lim<<=1);
		getinv(b,inv+1,lim);
		reverse(a,a+n+1);
		for(lim=1;lim<(n+n+2);lim<<=1);
		for(int i=0;i<lim;i++)r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		NTT(b,1),NTT(a,1);
		for(int i=0;i<lim;i++)a[i]=1ll*a[i]*b[i]%mo;
		NTT(a,-1);
		reverse(a,a+n+1);
		memset(b,0,sizeof(b));
		for(int i=1;i<=n+1;i++)
			b[i]=a[i-1];
		memset(a,0,sizeof(a));
		for(int i=0;i<=n+1;i++)
			a[i]=inv[i];
		reverse(b,b+n+2);
		for(lim=1;lim<(n+n+4);lim<<=1);
		for(int i=0;i<lim;i++)r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		NTT(b,1),NTT(a,1);
		for(int i=0;i<lim;i++)a[i]=1ll*a[i]*b[i]%mo;
		NTT(a,-1);
		reverse(a,a+n+2);
		for(int i=0;i<=n+1;i++)
			printf("%lld ",1ll*a[i]*inv[i]%mo);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

代码也不算长，不知道为什么写了俩小时\kk

---


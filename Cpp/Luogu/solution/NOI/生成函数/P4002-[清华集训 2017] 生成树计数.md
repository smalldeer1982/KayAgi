# [清华集训 2017] 生成树计数

## 题目描述

在一个 $s$ 个点的图中，存在 $s-n$ 条边，使图中形成了 $n$ 个连通块，第 $i$ 个连通块中有 $a_i$ 个点。

现在我们需要再连接 $n-1$ 条边，使该图变成一棵树。对一种连边方案，设原图中第 $i$ 个连通块连出了 $d_i$ 条边，那么这棵树 $T$ 的价值为：

$$ \mathrm{val}(T) = \left(\prod_{i=1}^{n} {d_i}^m\right)\left(\sum_{i=1}^{n} {d_i}^m\right) $$

你的任务是求出所有可能的生成树的价值之和，对 $998244353$ 取模。


## 说明/提示

令 $i$ 表示大小为 $i$ 的原连通块，我们在连通块之间的连边有以下三种可能:
- $2-3-4$
- $3-2-4$
- $2-4-3$

价值和为:
$$(2×3^2 ×4×2+3×2^2 ×4×2+2×4^2 ×3×2)×(1+2+1)=1728$$


---

本题共有 $20$ 个测试点，每个测试点 $5$ 分。 

- $20\%$ 的数据中，$n\le500$。

- 另外 $20\%$ 的数据中，$n \le 3000$。

- 另外 $10\%$ 的数据中，$n \le 10010, m = 1$。 

- 另外 $10\%$的数据中，$n \le 10015,m = 2$。 

- 另外 $20\%$ 的数据中，所有 $a_i$ 相等。

- $100\%$ 的数据中，$n \le 3\times 10^4,m \le 30$。  

其中，每一个部分分的测试点均有一定梯度。

## 样例 #1

### 输入

```
3 1
2 3 4```

### 输出

```
1728```

## 样例 #2

### 输入

```
233 10
604230822 258609018 347836125 103063600 545593375 983656639 636383432 149579311 37952830 782185282 792399760 556879020 19276539 821164472 992758005 635410231 174811932 967712405 76287574 877354238 403371989 131233662 90928781 909518950 816498283 460305280 688669184 272529638 706529895 931734844 376928193 161521421 41104566 573769373 264585020 586697940 408186715 749973507 585282307 446139544 533914437 228442770 4774211 553190975 51362889 997532216 39361909 75179876 816005324 115649482 801539169 70138016 95888199 892467950 979656965 761391537 354528877 519086852 35676822 910063828 301582400 261610070 73340896 342686965 835379442 186930971 778389960 245321804 936904477 365427914 691461347 321579617 593870684 545240614 874770591 494238628 393533533 914132499 418423560 211294504 878787036 221718376 281432519 823680290 115941973 111850187 435832530 319475906 630937038 471509352 80300437 932519437 733119421 153641332 125967105 419259567 340572302 904357065 664581370 128237482 120545682 206803421 449817099 563421421 752044034 175348393 59415697 147333214 91236540 326844312 207632773 819028631 548562687 338070347 493469625 513509716 449920533 929302154 681990677 929862626 251572209 762291113 713142767 833696686 915932444 839109871 254711900 107265449 594227639 768298325 235502930 563778377 975101745 685320028 128955445 577906482 860668421 37376197 574244751 800910016 364220508 630882579 470699350 761788251 968952925 813174030 126058670 269634161 593236888 808049346 201252435 844809096 572096106 914395201 529266485 338789253 604265775 783978384 295059757 49254118 403037413 530562686 613032494 228899861 66643418 590992994 806806343 776316894 628369191 231811797 427987613 841594754 862694376 898686962 605138652 682408004 562621696 731197321 952042165 157614231 390007370 4055303 851428382 962103475 918450503 382450515 151653431 373476981 17189602 446713187 271736154 420227014 826280929 884768647 649126875 892924346 326522345 306693921 520001943 954891535 387510773 947989555 647246992 100965852 697437220 103146348 783373856 261814563 834343668 737171668 268433849 75111742 741226970 121617879 38970864 510438176 353073449 39629351 732920212 370263050 335347593 6412014 639495120 163384169 740185716 139382698 905313570 68463708 446076618 427071160 872360298 833587390 225821418
```

### 输出

```
521800668
```

# 题解

## 作者：OwenOwl (赞：21)

我来胡一个 $O(n\log^2n)$ 做法。

考虑用 Prufer 序列去对应树，设 $d_i$ 表示 $i$ 在 Prufer 序列中出现的次数，则有 $\sum d_i = n - 2$。

考虑度数序列 $d$ 造成的贡献是：

$$\frac{(n-2)!}{\prod d_i!}\prod(d_i+1)^ma_i^{d_i+1}\sum (d_i+1)^m$$

$$=(n-2)!\prod a_i \sum_j \frac{1}{\prod d_i!} \prod a_i^{d_i}\prod_{i\ne j}(d_i+1)^m (d_j+1)^{2m}$$

这前面的 $(n-2)!\prod a_i$ 是常数，只考虑后面的这个 $\sum$。

设后面这个 $\sum$ 关于 $\sum d_i$ 的生成函数是 $F(x)$。

我们看到每一个 $d_i$ 造成的贡献是 $\frac{1}{d_i!} a_i^{d_i}(d_i+1)^m$ 或者最后一个幂次是$2m$。

自然而然想到 $F(x)$ 会是很多关于 $a_ix$ 的多项式的积，即设：

$$A(x)=\sum_{k} \frac{1}{k!} (k+1)^m x^k$$

$$B(x)=\sum_{k} \frac{1}{k!} (k+1)^{2m} x^k$$

那么有：

$$F(x)=\sum_i B(a_ix) \prod_{j\ne i} A(a_j x)$$

$$=\sum_i \frac{B(a_i x)}{A(a_i x)} \prod_i A(a_ix)$$

$$=\sum_i \frac{B(a_i x)}{A(a_i x)} \cdot \exp {\sum_i \ln A(a_ix)}$$

求出 $\frac{B(x)}{A(x)}$ 和 $\ln A(x)$ 后，需要代入 $a_ix$ 并求和，即第 $t$ 项系数需要乘 $\sum a_i^t$

于是还要对 $0\le k < n-1$ 预处理一个 $\sum_i a_i^k$。


注意到$\sum_{k\ge 0}a^kx^k=\frac{1}{1-ax}$

则答案的生成函数为

$$\sum_{i=1}^n\frac{1}{1-a_ix}=\frac{\sum\limits_{i=1}^n\prod\limits_{j\neq i}(1-a_jx)}{\prod\limits_{i=1}^n(1-a_ix)}$$

其中，

$$Q(x)=\prod_{i=1}^n(1-a_ix)$$

可以用分治 FFT 求出。

对比分子和分母的系数（或是把分母反转，求导，再反转）得到：

$$P(x)=\sum_{i=1}^n\prod_{j\neq i}(1-a_jx)=\sum_{k=0}^{n-1}x^k(n-k)[x^k]Q(x)$$

---

## 作者：bztMinamoto (赞：10)

[传送门](http://uoj.ac/problem/335?locale=zh-cn)

好神仙的题目……又一次有了做一题学一堆的美好体验

据说本题有第二类斯特林数+分治$FFT$的做法，然而咱实在看不懂写的是啥，[题解](https://blog.csdn.net/qq_39972971/article/details/80786441)贴这里，有兴趣的可以自己去瞅瞅~~，看懂了记得回来跟咱讲讲~~

# 前置芝士

## $prufer$序列

$prufer$序列是个啥？

对于一棵无根树，我们找到它的标号最小的叶子，删去它，并记下与它相邻的节点的标号。重复这个过程直到树上的节点数为$2$为止。这个时候我们得到了一个长度为$n-2$的序列就是这棵无根树的$prufer$序列

很明显，每一棵无根树唯一对应一个$prufer$序列，我们只要能证明每一个$prufer$序列都唯一对应一棵无根树，这两者之间就能有一个一一对应的关系了

考虑一个$prufer$序列，对于图中某个节点$u$，如果它在原图中不是叶子，那么与它相邻的边至少有两条。可操作完之后整个图中的边只剩下了一条，所以每一个不是叶子的节点都会在$prufer$序列中出现

我们把没有出现在序列中的数字排序，那么最小的数字肯定是和序列中的第一个数字配对，那么原图中它们之间肯定连边

然后我们递归考虑序列的后面几位，不难发现每一次的连边情况都唯一。于是我们知道每一个$prufer$序列唯一的对应一棵无根树

综上，无根树和$prufer$序列有着一一对应的关系

从中我们也可以看出，对于一个无向完全图的生成树，它的$prufer$序列有$n-2$个值，每个值的取值范围是$[1,n]$，所以一个无向完全图的生成树个数是$n^{n-2}$

## 快速求数列前$k$次方和

~~咱会差值~~

~~咱会第二类斯特林数~~

然而我们现在需要的是对于任意$0\leq j\leq k$，求出$\sum_{i=1}^n {a_i}^j$

~~咱刚刚啥都没说您继续~~

考虑答案的生成函数$$F(x)=\sum_{j=0}^k\sum_{i=1}^n{a_i}^jx^j=\sum_{i=1}^n\sum_{j=0}^k(a_ix)^j=\sum_{i=1}^n\frac{1}{1-a_ix}$$

因为有$$\ln'(\frac{1}{1-a_ix})=\frac{-a_i}{1-a_ix}=\sum_{j=0}^\infty (a_ix)^j\times (-a_i)$$

那么我们可以先计算出$G(x)=\sum_{i=1}^n\sum_{j=0}^k (a_ix)^j\times (-a_i)$，则$F(x)=-x\times G(x)+n$

而$G(x)$就吼算啦

$$G(x)=\sum_{i=1}^n \ln'(\frac{1}{1-a_ix})=(\sum_{i=1}^n \ln\frac{1}{1-a_ix})'=\ln'(\prod_{i=1}^n \frac{1}{1-a_ix})$$

括号里的可以用分治$FFT$计算了

# 本题题解

首先对于每一棵生成树$T$，它的贡献为$\prod_{i=1}^n{a_i}^{d_i}{d_i}^m\sum_{i=1}^n{d_i}^m$

那么考虑枚举每一个$prufer$序列来统计总贡献

$$Ans=(n-2)!\sum_{\sum d_i=n-2}\prod_{i=1}^n \frac{{a_i}^{d_i+1}}{d_i!}(d_i+1)^m\sum_{i=1}^m(d_i+1)^m$$
$$Ans=(n-2)!\prod_{i=1}^na_i\sum_{\sum d_i=n-2}\prod_{i=1}^n \frac{{a_i}^{d_i}}{d_i!}(d_i+1)^m\sum_{i=1}^m(d_i+1)^m$$
前面的$(n-2)!\prod_{i=1}^na_i$是常量，不用去管，考虑后面的$\prod_{i=1}^n \frac{{a_i}^{d_i}}{d_i!}(d_i+1)^m\sum_{i=1}^m(d_i+1)^m$，它等价于
$$\sum_{i=1}^n \frac{{a_i}^{d_i}}{d_i!}(d_i+1)^{2m}\prod_{j=1,j\neq i}^m\frac{{a_j}^{d_j}}{d_j!}(d_j+1)^{m}$$

因为需要$\sum d_i=n-2$，我们构造关于$d$的生成函数
$$A(x)=\sum_{i}\frac{x^i(i+1)^{2m}}{i!}$$
$$B(x)=\sum_{i}\frac{x^i(i+1)^{m}}{i!}$$
那么原式就等于$$F(x)=\sum_{i=1}^n A(a_ix)\prod_{j=1,j\neq i}^nB(a_jx)$$
$$F(x)=\sum_{i=1}^n \frac{A(a_ix)}{B(a_ix)}\prod_{j=1}^nB(a_jx)$$
$$F(x)=\sum\frac{A(a_ix)}{B(a_ix)}\exp(\sum\ln B(a_jx))$$
我们求出$\frac{A(x)}{B(x)}$和$\ln B(x)$之后，要把$a_ix$代入并求和，那么第$k$项的系数要乘上$\sum_{i=1}^n{a_i}^k$，这个就是前面说的可以快速求的东西

于是复杂度就为$O(n\log^2 n)$
```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
const int N=1e5+5,P=998244353,Gi=332748118;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
	R int res=1;
	for(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);
	return res;
}
int E[N],B[N],F[N],C[N],D[N],O[N],r[N],G[N];
void NTT(int *A,int ty,int len){
	int lim=1,l=0;while(lim<len)lim<<=1,++l;
	fp(i,0,lim-1)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	fp(i,0,lim-1)if(i<r[i])swap(A[i],A[r[i]]);
	for(R int mid=1;mid<lim;mid<<=1){
		int I=(mid<<1),Wn=ksm(ty==1?3:Gi,(P-1)/I);O[0]=1;
		fp(i,1,mid-1)O[i]=mul(O[i-1],Wn);
		for(R int j=0;j<lim;j+=I)fp(k,0,mid-1){
			int x=A[j+k],y=mul(O[k],A[j+k+mid]);
			A[j+k]=add(x,y),A[j+k+mid]=dec(x,y);
		}
	}
	if(ty==-1)for(R int i=0,inv=ksm(lim,P-2);i<lim;++i)A[i]=mul(A[i],inv);
}
void Inv(int *a,int *b,int len){
	if(len==1)return b[0]=ksm(a[0],P-2),void();
	Inv(a,b,len>>1);fp(i,0,len-1)C[i]=a[i],D[i]=b[i];
	NTT(C,1,len<<1),NTT(D,1,len<<1);
	fp(i,0,(len<<1)-1)C[i]=mul(mul(C[i],D[i]),D[i]);
	NTT(C,-1,len<<1);
	fp(i,0,len-1)b[i]=dec(add(b[i],b[i]),C[i]);
	fp(i,0,(len<<1)-1)C[i]=D[i]=0;
}
void Direv(int *A,int *B,int len){
	fp(i,1,len-1)B[i-1]=mul(A[i],i);B[len-1]=0;
}
void Inter(int *A,int *B,int len){
	fp(i,1,len-1)B[i]=mul(A[i-1],ksm(i,P-2));B[0]=0;
}
void Ln(int *a,int *b,int len){
	Inv(a,E,len),Direv(a,F,len);
	NTT(E,1,len<<1),NTT(F,1,len<<1);
	fp(i,0,(len<<1)-1)E[i]=mul(E[i],F[i]);
	NTT(E,-1,len<<1),Inter(E,b,len);
	fp(i,0,(len<<1)-1)E[i]=F[i]=0;
}
void Exp(int *a,int *b,int len){
    if(len==1)return b[0]=1,void();
    Exp(a,b,len>>1),Ln(b,B,len);
    B[0]=dec(a[0]+1,B[0]);fp(i,1,len-1)B[i]=dec(a[i],B[i]);
    NTT(B,1,len<<1),NTT(b,1,len<<1);
    fp(i,0,(len<<1)-1)b[i]=mul(b[i],B[i]);
    NTT(b,-1,len<<1);fp(i,len,(len<<1)-1)b[i]=B[i]=0;
}
int sz[N],A[19][N],TA[N],TB[N],TC[N],sum[N],ta[N],tb[N],tc[N];
void solve(int ql,int qr,int d){
	if(ql==qr)return A[d][0]=1,A[d][1]=P-sz[ql],void();
	int mid=(ql+qr)>>1;
	solve(ql,mid,d),solve(mid+1,qr,d+1);
	int lim=1;while(lim<=qr-ql+1)lim<<=1;
	fp(i,mid-ql+2,lim-1)A[d][i]=0;
	fp(i,qr-mid+1,lim-1)A[d+1][i]=0;
	NTT(A[d],1,lim),NTT(A[d+1],1,lim);
	fp(i,0,lim-1)A[d][i]=mul(A[d][i],A[d+1][i]);
	NTT(A[d],-1,lim);
}
int n,m,res,fac[N],inv[N];
int main(){
//	freopen("testdata.in","r",stdin);
	n=read(),m=read();if(n==1)return puts("1"),0;
	fac[0]=inv[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);
	inv[n]=ksm(fac[n],P-2);fd(i,n-1,1)inv[i]=mul(inv[i+1],i+1);
	fp(i,1,n)sz[i]=read();
	solve(1,n,0);
	fp(i,0,n)tc[i]=A[0][i];
	int len=1;while(len<=n)len<<=1;
	Ln(tc,sum,len);
	fp(i,1,n)sum[i]=P-mul(sum[i],i);
	sum[0]=n;
	fp(i,0,n-1)TA[i]=mul(ksm(i+1,m),inv[i]),TB[i]=mul(ksm(i+1,m<<1),inv[i]);
	Ln(TA,tc,len),Inv(TA,TC,len);
	NTT(TC,1,len<<1),NTT(TB,1,len<<1);
	fp(i,0,(len<<1)-1)TB[i]=mul(TB[i],TC[i]);
	NTT(TB,-1,len<<1);
	memset(TA,0,sizeof(TA));
	memset(TC,0,sizeof(TC));
	fp(i,0,n-1)TB[i]=mul(TB[i],sum[i]),TA[i]=mul(tc[i],sum[i]);
	Exp(TA,TC,len);
//	fp(i,0,(len<<1)-1)printf("%d %d\n",i,TC[i]);
	fp(i,n,(len<<1)-1)TB[i]=0;
	NTT(TB,1,len<<1),NTT(TC,1,len<<1);
	fp(i,0,(len<<1)-1)TB[i]=mul(TB[i],TC[i]);
	NTT(TB,-1,len<<1);
	res=mul(TB[n-2],fac[n-2]);
	fp(i,1,n)res=mul(res,sz[i]);
	printf("%d\n",res);
	return 0;
}
```

---

## 作者：Aly_ (赞：9)

​	关于本题的各种做法...

##### 第一步

​	首先，如果一个大小为 $a_i$ 的连通块连出了 $d_i$ 条边，那么这 $d_i$ 条边在连通块内部的出发点就总共有 $a_i^{d_i}$ 种组合，即，这会对答案产生 $a_i^{d_i}$ 的贡献。于是，对于一种所有点的度数分别为 $d_1,\cdots,d_n$ 的情况，它们对答案的贡献就是 $\prod_i a_i^{d_i}d_i^m(\sum_id_i^m)$。

​	考虑使图的生成树和 **Prufer 序列**一一对应。对于一个度数为 $d_i$ 的连通块（以下简称 “ 点 ”）$i$，其在 Prufer 序列中会出现 $d_i-1$ 次。我们现在尝试把一个个点填入 Prufer 序列。

​	设 $f_{i,j}$ 表示当前已经把前 $i$ 个点填入了 Prufer 序列，占了 $j$ 个位置的 $\prod_i a_i^{d_i}d_i^m$ 总和，$g_{i,j}$ 表示对应情况下的 $\prod_i a_i^{d_i}d_i^m(\sum_id_i^m)$ 总和。枚举第 $i$ 个点占了多少个位置，容易得出：
$$
f_{i,j}=\sum_{k\leq j}f_{i-1,k}\dbinom{j}{k}a_i^{j-k+1}(j-k+1)^m
$$

$$
g_{i,j}=\sum_{k\leq j}g_{i-1,k}\dbinom{j}{k}a_i^{j-k+1}(j-k+1)^m+\sum_{k\leq j}f_{i-1,k}\dbinom{j}{k}a_i^{j-k+1}(j-k+1)^{2m}
$$

​	得到一个 $O(n^3)$ 的暴力。

​	以后的讨论都以此为基础。

##### 第二步

​	发现 $f_{i,j}$ 可以卷积地转移。

​	使用**指数生成函数**，记 $F_i(x)=\sum_j\dfrac{f_{i,j}}{j!}x^j$，$G_i(x)$ 类似，我们把上述转移改写成如下形式：
$$
F_i(x)=F_{i-1}(x)*P_i(x)
$$

$$
G_i(x)=G_{i-1}(x)*P_i(x)+F_{i-1}(x)*Q_i(x)
$$

​	（虽然相当不严谨，若无特殊需要这里不再区分多项式 $F(x)$ 和 $F$。）

​	其中
$$
P_i(x)=\sum_j\frac{a_i^{j+1}(j+1)^m}{j!}x_j
$$

$$
Q_i(x)=\sum_j\frac{a_i^{j+1}(j+1)^{2m}}{j!}x_j
$$

​	（$P_i$ 和 $Q_i$ 长得这么像？）

​	进一步地，可以用**矩阵**改写成如下形式
$$
\begin{pmatrix}
P_i & 0\\
Q_i & P_i
\end{pmatrix}*
\begin{pmatrix}
F_{i-1}\\
G_{i-1}
\end{pmatrix}=
\begin{pmatrix}
F_i\\
G_i
\end{pmatrix}
$$
​	于是只要求 $\prod_i\begin{pmatrix}P_i & 0\\Q_i & P_i\end{pmatrix}$ 即可。

​	再化 $P_i$，有
$$
P_i(x)=\sum_j\frac{a_i^{j+1}(j+1)^m}{j!}x_j\\
=\sum_j\frac{a_i^{j+1}}{j!}x^j\sum_{k\leq m}\begin{Bmatrix}m\\k\end{Bmatrix}\dbinom{j+1}{k}k!\\
=\sum_{k\leq m}\begin{Bmatrix}m\\k\end{Bmatrix}k!\sum_j\frac{a_i^{j+1}(j+1)}{(j+1-k)!}x^j\\
$$
​	前面的先不管，看到后面的和式有点像 **exp** 的形式。具体地，若它真的有一个类似形式的话，$(j+1)$ 意味着可能需要求导，下面的阶乘平移了 $k$ 意味着需要多项式平移，而上面的 $a_i^{j+1}$ 意味着有类似 $e^{a_ix}$ 的式子出现。

​	综合上面几点不难得出后面和式就是
$$
(a_i^kx^ke^{a_ix})'
=a_i^kx^{k-1}(k+a_ix)e^{a_ix}
$$
​	继续化
$$
P_i(x)=\sum_{k\leq m}\begin{Bmatrix}m\\k\end{Bmatrix}k!a_i^kx^{k-1}(k+a_ix)e^{a_ix}\\
=e^{a_ix}\sum_{k\leq m}\begin{Bmatrix}m+1\\k+1\end{Bmatrix}a_i^{k+1}x^k
$$
​	最后一步用到了 $\begin{Bmatrix}m\\k\end{Bmatrix}=k\begin{Bmatrix}m-1\\k\end{Bmatrix}+\begin{Bmatrix}m-1\\k-1\end{Bmatrix}$。对 $Q_i$ 的推导同理。

​	再记 $A_i(x)=\sum_{k\leq m}\begin{Bmatrix}m+1\\k+1\end{Bmatrix}a_i^{k+1}x^k,B_i(x)=\sum_{k\leq 2m}\begin{Bmatrix}2m+1\\k+1\end{Bmatrix}a_i^{k+1}x^k$。

​	注意到 $A_i,B_i$ 都是次数小于等于 $2m$ 的多项式。

​	回头看原来的矩阵乘积，把所有 exp 提出来，得到所求的式子为
$$
e^{Sx}\prod_i\begin{pmatrix}A_i & 0\\B_i & A_i\end{pmatrix}
$$
​	**FFT 分治**。复杂度 $O(nm\log^2 n)$（精细的实现可以有 $O(nm\log n\log m)$？）。

​	注意的是，直接做矩阵乘法的常数显然巨大，但这个矩阵的特殊形式有
$$
\begin{pmatrix}A_i & 0\\B_i & A_i\end{pmatrix}\begin{pmatrix}A_j & 0\\B_j & A_j\end{pmatrix}=\begin{pmatrix}A_iA_j & 0\\B_iA_j+A_iB_j & A_iA_j\end{pmatrix}
$$
​	前后形式相同，可以很方便地转移。**可以通过本题。**

​	继续优化？

##### 第三步

​	上面的小优化可以推广。可以归纳地证明所有这些矩阵乘起来后左下角多项式为
$$
\sum_iB_i\prod_{j\ne i}A_j=\prod_iA_i(\sum_jB_j*A_j^{-1})
$$
​	设 $\{a_j\}$ **幂和**的生成函数 $T(x)=\sum_i(\sum_ja_j^i)x^i$。

​	注意到 $A_i(x)$ 的形式都很接近。设 $A(x)=\sum_{k\leq m}\begin{Bmatrix}m+1\\k+1\end{Bmatrix}x^k$，那么 $A_i(x)=a_iA(a_ix)$。 $B_i(x)$ 同理。

​	然后
$$
\sum_j{B_j}*{A_j}^{-1}=\sum_j{B(a_jx)}*{A(a_jx)}^{-1}=\sum_j(B*A^{-1})(a_jx)=T\cdot(B*A^{-1})
$$
​	这里 $\cdot$ 是**点乘**，即对应位置相乘。

​	继续
$$
\prod_i A_i=\exp \sum_i \ln A_i=\exp \sum_i \ln a_iA(a_ix)=\exp(T\cdot\ln A)
$$
​	如果求出 $T$ 的话，这两个式子都可以快速求解。求 $T$ 是一个经典问题，有
$$
T(x)=\sum_i(\sum_ja_j^i)x^i=\sum_j\sum_i (a_jx)^i=\sum_j\frac{1}{1-a_jx}=\frac{\sum_i\prod_{j\ne i}(1-a_jx)}{\prod_i(1-a_ix)}
$$
​	FFT 分治解决，复杂度 $O(n\log^2 n)$，这里不再赘述。

​	最后放出原问题完整的求解式（似乎两个 exp​ 可以合并？）：
$$
Ans=(n-2)![x^{n-2}]\exp(Sx)*(T\cdot(B*A^{-1}))*\exp(T\cdot\ln A)
$$
​	于是最终我们在 $O(n\log^2 n)$ 的时间内解决了问题。

​	因为是多项式题，本蒟蒻代码较长而且码风奇丑，就不放代码了。

---

## 作者：asuldb (赞：8)

[题目](https://www.luogu.com.cn/problemnew/solution/P4002)

一个用斯特林数的$O(nm\log^2n)$做法

考虑我们要求的答案即

$$\sum_{T}(\prod_{i=1}^n d_i^{m})(\sum_{i=1}^nd_{i}^m)(\prod_{i=1}^na_i^{d_i})$$

至于为什么有这个$\prod_{i=1}^na_i^{d_i}$，是因为在第$i$个联通块里连的这$d_i$条边的端点可以是$a_i$个点中随便选，于是就是$a_i^{d_i}$

考虑暴力化柿子

$$Ans=\sum_T\sum_{i=1}^nd_i^{m}\prod_{j=1}^nd_j^ma_j^{d_j}=\sum_T\sum_{i=1}^nd_i^{2m}\times a_i^{d_i}\prod_{i\neq j}d_j^ma_j^{d_j}$$

其实就是从后面那个$\prod$里拆了个$d_i^ma_i^{d_i}$出来

这老写$\sum_T$多难看，把生成树转化成$\rm prufer$序列，设$c_i$表示第$i$个点在$\rm prufer$序列中出现的次数，显然有$d_i=c_i+1$，有

$$Ans=\sum_{\sum c=n-2}\sum_{i=1}^n(c_i+1)^{2m}a_i^{c_i+1}\prod_{i\neq j}(c_j+1)^ma_j^{c_j+1}$$

$\{c_i\}$对应的$\rm prufer$序列共有$\frac{(n-2)!}{\prod c_i!}$，于是我们能进一步写成

$$\frac{(n-2)!}{\prod c_i!}\sum_{i=1}^n(c_i+1)^{2m}a_i^{c_i+1}\prod_{i\neq j}(c_j+1)^ma_j^{c_j+1}$$

不妨将$\frac{1}{\prod c_i!}$分配进去，则有

$$(n-2)!\sum_{i=1}^n\frac{(c_i+1)^{2m}a_i^{c_i+1}}{c_i!}\prod_{i\neq j}\frac{(c_j+1)^ma_j^{c_j+1}}{c_j!}$$

不难设两个$\rm EGF$，${\rm A}_i(x)=\sum_{j=0}^{\infty}\frac{(j+1)^{2m}a_i^{j+1}}{j!}x^j,{\rm B}_i(x)=\sum_{j=0}^{\infty}\frac{(j+1)^{m}a_i^{j+1}}{j!}x^j$

这样我们的答案就能写成

$$(n-2)![n-2](\sum_{i=1}^n{\rm A}_i(x)\times \prod_{i\neq j}{\rm B}_j(x))$$

即那些个$\rm EGF$卷起来的第$n-2$次项系数

现在就是神奇的魔法了，以${\rm B}_i(x)$为例，我们先积分一下，得到的是

$$\sum_{j=0}^{\infty}\frac{(j+1)^ma_i^{j+1}}{(j+1)!}x^{j+1}=\sum_{j=1}^{\infty}\frac{j^ma_i^{j}}{j!}x^{j}$$

用第二类斯特林数将$j^m$展开

$$\sum_{j=1}^{\infty}\frac{a_i^{j}}{j!}x^{j}\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}j^{\underline k}=\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}\sum_{j=1}^{\infty}\frac{a_i^{j}j^{\underline k}}{j!}x^{j}$$

注意到$\frac{j^{\underline k}}{j!}$其实就是$\frac{!}{(j-k)!}$，于是我们从后面提一个$a_i^{k}x_k$出来，并将后面的柿子泰勒展开一下

$$\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}a_i^{k}x^k\sum_{j=1}^{\infty}\frac{a_i^{j-k}}{(j-k)!}x^{j-k}=\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}a_i^{k}x^ke^{a_ix}$$

我们对于$\int {\rm B}_i(x)\rm dx$得到了一个优美的形式，那么我们再求导回去，我们可以看成是$\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}a_i^{k}x^k$乘$e^{a_ix}$这两个函数相乘求导，那么根据求导的法则$[f(x)g(x)]'=f(x)g'(x)+f'(x)g(x)$，就有

$$\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}a_i^{k}kx^{k-1}e^{a_ix}+\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}a_i^{k}x^ka_ie^{a_ix}$$

整理一下就有

$$e^{a_ix}(\sum_{k=1}^m(k+1)\begin{Bmatrix}m\\k+1\end{Bmatrix}a_i^{k+1}x^k+\sum_{k=0}^m\begin{Bmatrix}m\\k\end{Bmatrix}a_i^{k+1}x^k)$$

根据第二类斯特林数的递推式，我们惊奇的发现$(k+1)\begin{Bmatrix}m\\k+1\end{Bmatrix}+\begin{Bmatrix}m\\k\end{Bmatrix}=\begin{Bmatrix}m+1\\k+1\end{Bmatrix}$

于是我们得到一个极其优美的形式

$${\rm B}_i(x)=e^{a_ix}\sum_{k=0}^m\begin{Bmatrix}m+1\\k+1\end{Bmatrix}a_i^{k+1}x^k$$

类似的

$${\rm A}_i(x)=e^{a_ix}\sum_{k=0}^{2m}\begin{Bmatrix}2m+1\\k+1\end{Bmatrix}a_i^{k+1}x^k$$

再设${\alpha_i(x)}=\frac{{\rm A}_i(x)}{e^{a_ix}},{\beta _i(x)}=\frac{{\rm B}_i(x)}{e^{a_ix}}$

回到最开始的式子，不妨将$\sum_{i=1}^n{\rm A}_i(x)\times \prod_{i\neq j}{\rm B}_j(x)$写成$e^{x\sum a}\sum_{i=1}^n{\alpha}_i(x)\times \prod_{i\neq j}{\beta}_j(x)$，之后我们就可以进一步写成


$$\prod_{i=1}^n{\beta}_i(x)\times \sum_{i=1}^n\frac{{\alpha}_i(x)}{{\beta}_i(x)}$$

$\sum_{i=1}^n\frac{{\alpha}_i(x)}{{\beta}_i(x)}$并没有想到什么好做法，那就一边分治一边通分吧，之后分治通分到最后发现分母就是$\prod_{i=1}^n{\beta}_i(x)$，于是我们只需要分子就好了

代码鸽了，有空来补

UPD on 2019.12.28 原来的式子最后一步钦定错了，好像导致一位老鸽调了一天，手动谢罪

来补上代码了

```cpp
#include<bits/stdc++.h>
#define re register
const int mod=998244353;
const int G[2]={3,(mod+1)/3};
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
const int Maxlen=65539;
const int maxn=3e4+5;
std::vector<int> p[maxn*3],q[maxn*3];
int n,m,a[maxn],S[105][105],sum,len,inv[maxn],__og[2][50];
int rev[Maxlen],A[Maxlen],C[Maxlen],B[Maxlen],D[Maxlen];
inline int dqm(int x) {return x<0?x+mod:x;}
inline int qm(int x) {return x>=mod?x-mod:x;}
inline int ksm(int a,int b) {
	int S=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)S=1ll*S*a%mod;return S;
}
inline void NTT(int *f,int o) {
	for(re int i=0;i<len;i++)if(i<rev[i])std::swap(f[i],f[rev[i]]);
	for(re int w=0,i=2;i<=len;i<<=1,++w) {
		int ln=i>>1,og1;
		if(!__og[o][w])og1=__og[o][w]=ksm(G[o],(mod-1)/i);else og1=__og[o][w];
		for(re int t,og=1,l=0;l<len;l+=i,og=1)
			for(re int x=l;x<l+ln;++x) {
				t=1ll*f[x+ln]*og%mod,og=1ll*og1*og%mod;
				f[x+ln]=dqm(f[x]-t);f[x]=qm(f[x]+t);
			}
	}
	if(!o)return;int Inv=ksm(len,mod-2);for(re int i=0;i<len;i++)f[i]=1ll*f[i]*Inv%mod;
}
void cdq(int l,int r,int k) {
	if(l==r) {
		int nw=a[l];
		for(re int i=0;i<=m+m;i++)p[k].push_back(1ll*nw*S[m+m+1][i+1]%mod),nw=1ll*nw*a[l]%mod;
		nw=a[l];for(re int i=0;i<=m;i++)q[k].push_back(1ll*nw*S[m+1][i+1]%mod),nw=1ll*nw*a[l]%mod;
		return;
	}
	int mid=l+r>>1;
	cdq(l,mid,k<<1),cdq(mid+1,r,k<<1|1);
	int lenl=p[k<<1].size(),lenr=p[k<<1|1].size();
	len=1;while(len<=lenl+lenr+1) len<<=1;
	for(re int i=0;i<len;i++)rev[i]=rev[i>>1]>>1|((i&1)?len>>1:0);
	for(re int i=0;i<p[k<<1].size();++i) A[i]=p[k<<1][i];
	for(re int i=0;i<p[k<<1|1].size();++i) B[i]=p[k<<1|1][i];
	for(re int i=0;i<q[k<<1].size();++i) C[i]=q[k<<1][i];
	for(re int i=0;i<q[k<<1|1].size();++i) D[i]=q[k<<1|1][i];
	NTT(A,0),NTT(B,0),NTT(C,0),NTT(D,0);
	for(re int i=0;i<len;i++) A[i]=qm(1ll*A[i]*D[i]%mod+1ll*B[i]*C[i]%mod),C[i]=1ll*C[i]*D[i]%mod;
	NTT(A,1),NTT(C,1);
	for(re int i=0;i<len;i++) {
		if(i>n-2) break;
		p[k].push_back(A[i]);
		q[k].push_back(C[i]);
	}
	for(re int i=0;i<len;i++) A[i]=B[i]=C[i]=D[i]=0;
	int lp=p[k].size(),lq=q[k].size();lp--;lq--;
	for(re int i=lp;i>=0;--i) 
		if(!p[k][i]) p[k].pop_back();else break;
	for(re int i=lq;i>=0;--i)
		if(!q[k][i]) q[k].pop_back();else break;
}
signed main() {
	n=read(),m=read();S[0][0]=1;inv[0]=1;
	for(re int i=1;i<=m+m+1;i++)
		for(re int j=1;j<=i;++j) S[i][j]=qm(S[i-1][j-1]+1ll*S[i-1][j]*j%mod);
	for(re int i=1;i<=n;i++) a[i]=read(),sum=qm(sum+a[i]);
	if(n==1) return puts("1"),0;
	inv[1]=1;for(re int i=2;i<=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	cdq(1,n,1);for(re int i=0;i<p[1].size();++i) A[i]=p[1][i];int ans=0;
	for(re int i=1;i<=n-2;i++) inv[i]=1ll*inv[i]*inv[i-1]%mod;
	for(re int nw=1,i=0;i<=n-2;i++,nw=1ll*nw*sum%mod)B[i]=1ll*inv[i]*nw%mod;
	for(re int i=0;i<=n-2;i++)ans=qm(ans+1ll*A[i]*B[n-2-i]%mod);
	for(re int i=1;i<=n-2;i++)ans=1ll*ans*i%mod;
	std::cout<<ans<<std::endl;return 0;
}
//g++ lg4002.cpp -o lg4002
```

---

## 作者：tommymio (赞：7)

$\mathrm{GF}$ 菜鸡来胡一发。~~感谢这段时间 $\color{red}\rm{GuidingStar}$ 的大力py~~

喵喵喵~

容易想到直接枚举树

$$
\sum_T\left(\prod_{i=1}^na_i^{d_i}d_i^m\right)\left(\sum_{i=1}^nd_i^m\right)
$$

$$
\sum_T\sum_{i=1}^n a_i^{d_i}d_i^{2m}\prod_{j\neq i}a_j^{d_j}d_j^m
$$

运用 $\mathrm{Prufer}$ 序列这一工具

$$
\sum_{i=1}^n\sum_{\sum k_j=n-2}\frac{(n-2)!}{\prod k_j!}a_i^{k_i+1}(k_i+1)^{2m}\prod_{j\neq i}(a_j^{k_j+1}(k_j+1)^m)
$$

$$
(n-2)!\left(\prod_{j=1}^n a_j\right)\sum_{i=1}^n\sum_{\sum k_j=n-2}\frac{a_i^{k_i}(k_i+1)^{2m}}{k_i!}\prod_{j\neq i}\frac{a_j^{k_j}(k_j+1)^m}{k_j!}
$$

设 

$$
\begin{aligned}
\left[{z^n}\right]F_i(z)&=\frac{a_i^n(n+1)^{2m}}{n!}
\\
\left[{z^n}\right]G_i(z)&=\frac{a_i^n(n+1)^m}{n!}
\end{aligned}
$$

将非常数项写成卷积形式

$$
\left[{z^{n-2}}\right]\sum_{i=1}^n\frac{F_i(z)}{G_i(z)}\left(\prod_{i=1}^nG_i(z)\right)
$$

问题变为快速求解这个卷积。设 

$$
F(z)=\sum_{n=0} \frac{(n+1)^{2m}}{n!}z^n,G(z)=\sum_{n=0}\frac{(n+1)^m}{n!}z^n
$$

则有

$$
F_i(z)=F(a_iz),G_i(z)=G(a_iz)
$$


现在需要考虑对于任意 

$$
H_i(z)=\sum_{n=0}a_i^nh_nz^n=\frac{1}{1-a_iz}
$$

求解

$$
\begin{aligned}
\sum_{i=1}^n H_i(z)=\sum_{i=1}^n\frac{1}{1-a_iz}
\end{aligned}
$$

因为连乘项是 $H_i(z)=\ln G(a_iz)$ 并且 $\exp$ 回原式，而连加项其实是 $H_i(z)=\frac{F(a_iz)}{G(a_iz)}$。对于这两部分都只需要求一遍 $\ln G(z)$ 和 $\frac{F(z)}{G(z)}$。

设 

$$
u=\prod_{i=1}^n (1-a_iz)
$$

则所求变为 

$$
\frac{u'}{u}
$$

使用分治 $\mathrm{NTT}$ 求出 $u$ 的值即可，时间复杂度为 $O(n \log^2 n)$








---

## 作者：81179332_ (赞：4)

从一个连通块连出去一条边有 $a_i$ 种方案，那么连出去 $n$ 条互不相同的边的方案数就是 $a_i^n$

由此，我们可以将每个连通块看成一个点

我们发现最终要求的东西只与每个点的度数有关系，用 prufer 序列来考虑

prufer 序列为一个长度为 $n-2$ 的序列，如果 $i$ 在里面出现了 $d_i$ 次，那么 $i$ 的度数为 $d_i+1$

容易写出答案的式子：

$$\begin{aligned}

ans&=\sum\limits_{\sum d=n-2}\dbinom{n-2}{d_1,d_2,\dots,d_n}\left(\prod\limits_{i=1}^{n}(d_i+1)^m\right)\left(\sum\limits_{i=1}^{n}(d_i+1)^m\right)\left(\prod\limits_{i=1}^{n}a_i^{d_i+1}\right)\\

&=\sum\limits_{\sum d=n-2}\dfrac{(n-2)!}{\prod_{i=1}^n d_i!}\left(\prod\limits_{i=1}^{n}(d_i+1)^m\right)\left(\sum\limits_{i=1}^{n}(d_i+1)^m\right)\left(\prod\limits_{i=1}^{n}a_i^{d_i+1}\right)\\

&=(n-2)!\prod\limits_{i=1}^na_i\sum\limits_{\sum d=n-2}\left(\sum\limits_{i=1}^{n}(d_i+1)^m\right)\left(\prod\limits_{i=1}^{n}\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^m\right)

\end{aligned}$$

前面的一点点是定值，我们只需要考虑后面的部分：

$$ans'=\sum\limits_{\sum d=n-2}\left(\sum\limits_{i=1}^{n}(d_i+1)^m\right)\left(\prod\limits_{i=1}^{n}\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^m\right)$$

$\sum d=n-2$ 提示我们使用多项式，即设若干个生成函数 $F_i(x)=\sum\limits_{j=0}^{\inf}f(i,j)x^j$，其中 $f(i,j)$ 表示 $d_i=j$ 时式子中的值

然而我们如果根据上面的多项式是设不出合理的多项式的，因为右侧 $\prod\limits_{i=1}^{n}\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^m$ 的次数就已经是 $\sum d$ 了，且左侧 $\sum\limits_{i=1}^{n}(d_i+1)$ 的次数是不确定的

所以我们需要对式子进行变形：

$$\begin{aligned}
ans'&=\sum\limits_{\sum d=n-2}\left(\sum\limits_{i=1}^{n}(d_i+1)^m\right)\left(\prod\limits_{i=1}^{n}\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^m\right)\\

&=\sum\limits_{\sum d=n-2}\sum\limits_{i=1}^n\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^{2m}\prod\limits_{j\neq i}\dfrac{a_j^{d_j}}{d_j!}(d_j+1)^m
\end{aligned}$$

即我们将 $\prod\limits_{i=1}^{n}\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^m$ 中的一项提到了前面

现在我们观察式子，可以发现左侧的次数为 $d_i$，而右侧的次数为 $\sum\limits_{j\neq i}$，则我们左右侧相乘的次数就为 $\sum d$ 了

至此，我们可以设 $F_i(x)=\sum\limits_{j=0}^{\inf}\dfrac{a_i^j}{j!}(j+1)^{2m}x^j$，$G_i(x)=\sum\limits_{j=0}^{\inf}\dfrac{a_i^j}{j!}(j+1)^{m}x^j$

$$\begin{aligned}
ans'&=[x^{n-2}]\sum\limits_{i=1}^nF_i(x)\prod_{j\neq i}G_j(x)\\

&=[x^{n-2}]\left(\sum\limits_{i=1}^n\dfrac{F_i(x)}{G_i(x)}\right)\left(\prod\limits_{i=1}^nG_i(x)\right)
\end{aligned}$$

看上去还是不太行的样子，我们发现 $F_i(x)$ 和 $G_i(x)$ 中与 $i$ 相关的只有 $a_i$，尝试消除 $a_i$ 在多项式中的影响，举函数 $F(x)=\sum\limits_{i=1}^{\inf}f(i)x^i$ 为例：

$$\begin{aligned}

&\sum\limits_{i=1}^n\sum\limits_{j=1}^{\inf}f(j)a_i^jx^j\\

=&\sum\limits_{j=1}^{\inf}f(j)\left(\sum\limits_{i=1}^na_i^j\right)x^j

\end{aligned}$$

设 $S(k)=\sum\limits_{i=1}^na_i^k$

则 $\sum\limits_{i=1}^nF_i(x)=\sum\limits_{i=1}^{\inf}f(j)S(j)x^j$

如果我们能快速求出 $S(k)(k\in[0,n])$ 的话，我们就可以快速求出 $\sum\limits_{i=1}^nF_i(x)$，即不考虑 $i$ 的影响，最后第 $i$ 项乘 $S(i)$

右侧的 $\prod$ 也有套路的方法化成 $\sum$：

$$\begin{aligned}
ans'=[x^{n-2}]\left(\sum\limits_{i=1}^n\dfrac{F_i(x)}{G_i(x)}\right)\exp\left(\sum\limits_{i=1}^n\ln\left(G_i(x)\right)\right)
\end{aligned}$$

---

现在我们考虑对于所有的 $k\in[0,n]$ 求出 $\sum\limits_{i=1}^na_i^k$

这是一个经典问题


$$\begin{aligned}
F(x)&=\sum\limits_{j=0}^{\inf} S(j+1) x^j\\

&=\sum\limits_{i=1}^na_i\sum\limits_{j=0}^{\inf}(a_ix)^j\\

&=\sum\limits_{i=1}^n\dfrac{a_i}{1-a_ix}\\

&=-\sum\limits_{i=1}^n\ln'(1-a_ix)\\

&=-\left(\ln\left(\prod\limits_{i=1}^n(1-a_ix)\right)\right)'
\end{aligned}$$


然后这个东西可以多项式分治求，就没了

---

代码挺短的

```cpp
int qpow(int a,int b)
{
    int ans = 1;
    for(;b;b >>= 1,a = (ll)a * a % mod) if(b & 1) ans = (ll)ans * a % mod;
    return ans;
}
const int N = 800010;
void Mul(C int *a,C int *b,int *c,C int m1,C int m2);//多项式乘法
void Inv(C int *a,int *b,C int len);//多项式求逆
void Der(C int *a,int *b,C int len);//多项式求导
void Ln(C int *a,int *b,C int len);//多项式对数
void Exp(C int *a,int *b,C int len);//多项式指数
int n,m,a[N];
int L[N],R[N],M[N];
vector<int> solve(int l,int r)
{
	if(l == r) { return {1,mod - a[l]}; }
	int mid = l + r >> 1;vector<int> x = solve(l,mid),y = solve(mid + 1,r);
	for(int i = 0;i < x.size();i++) L[i] = x[i];
	for(int i = 0;i < y.size();i++) R[i] = y[i];
	Mul(L,R,M,x.size(),y.size());
	vector<int> z;z.clear();for(int i = 0;i < x.size() + y.size() - 1;i++) z.push_back(M[i]);
	return z;
}
int fac[N],ifac[N],sum[N],tmp[N];
int A[N],B[N],f[N],g[N];
int main()
{
	n = read(),m = read();for(int i = 1;i <= n;i++) a[i] = read();
	fac[0] = 1;for(int i = 1;i <= n;i++) fac[i] = (ll)fac[i - 1] * i % mod;
	ifac[n] = qpow(fac[n],mod - 2);for(int i = n;i;i--) ifac[i - 1] = (ll)ifac[i] * i % mod;

	vector<int> v = solve(1,n);for(int i = 0;i <= n;i++) tmp[i] = v[i];
	Ln(tmp,sum,n + 1);Der(sum,sum,n + 1);memset(tmp,0,sizeof(tmp));
	for(int i = n - 1;~i;i--) sum[i + 1] = mod - sum[i];sum[0] = n;

	for(int i = 0;i < n;i++)
	{
		A[i] = (ll)qpow(i + 1,2 * m) * ifac[i] % mod;
		B[i] = (ll)qpow(i + 1,m) * ifac[i] % mod;
	}
	Inv(B,tmp,n);Mul(A,tmp,f,n,n);Ln(B,g,n);memset(tmp,0,sizeof(tmp));
	for(int i = 0;i < n;i++) f[i] = (ll)f[i] * sum[i] % mod,g[i] = (ll)g[i] * sum[i] % mod;
	Exp(g,tmp,n);Mul(f,tmp,f,n,n);
	int ans = (ll)f[n - 2] * fac[n - 2] % mod;
	for(int i = 1;i <= n;i++) ans = (ll)ans * a[i] % mod;
	fprint(ans);
}
```

---

## 作者：AzusaCat (赞：4)

#### 前置知识：求数列幂和

给定数列 $\{a_n\}$，对 $0\leqslant t \leqslant k$，求 $\sum\limits_{i=1}^na_i^t$，$n,t\leqslant 10^5$。

我们写出幂次和对应的生成函数 $F(x)$
$$
\begin{aligned}
F(x)=&\sum\limits_{t=0}\left(\sum\limits_{i=1}^na_i^t\right)x^t\\
=&\sum\limits_{i=1}^n\sum\limits_{t=0}a_i^tx^t\\
=&\sum\limits_{i=1}^n\frac{1}{1-a_ix}
\end{aligned}
$$
然后我们考虑 $G(x)=\sum\limits_{i=1}^n\left(\ln(1-a_ix)\right)'$，化简则有
$$
\begin{aligned}
G(x)=&\sum\limits_{i=1}^n\left(\ln(1-a_ix)\right)'\\
=&-\sum\limits_{i=1}^n\frac{a_i}{1-a_ix}\\
=&-\sum\limits_{t=0}\sum\limits_{i=1}^na_i^{t+1}x^t
\end{aligned}
$$
如果我们能求得 $G(x)$，则很好就能求出 $F(x)$。同时发现
$$
\begin{aligned}
G(x)=&\sum\limits_{i=1}^n\left(\ln(1-a_ix)\right)'\\
=&\left(\sum\limits_{i=1}^n\ln(1-a_ix)\right)'\\
=&\left(\ln(\prod\limits_{i=1}^n(1-a_ix))\right)'
\end{aligned}
$$
$\prod\limits_{i=1}^n(1-a_ix)$ 可以通过分治 FFT 计算，然后求个 $\ln$ 再求导就好了。复杂度 $O(n\log^2n)$。



然后我们考虑这道题。

显然，我们可以把每一个连通块看成一个点，然后只需要考虑连通块的连接方式，每连接一条边额外乘上连通块大小即可。

我们考虑枚举 prufer 序列，如果一个数在 prufer 序列中出现了 $d$ 次，则其的度数为 $d+1$。

那么我们考虑枚举每个点在 prufer 序列中出现的次数 $d_i$，则我们有
$$
\begin{aligned}
ans=&\sum\limits_{\sum d=n-2}(n-2)!\left(\prod_{i=1}^n(d_i+1)^m\right)\left(\sum_{i=1}^n(d_i+1)^m\right)\left(\prod_{i=1}^n\frac{a_i^{d_i+1}}{d_i!}\right)\\
=&(n-2)!\prod_{i=1}^na_i\sum\limits_{\sum d=n-2}\left(\prod_{i=1}^n\frac{a_i^{d_i}}{d_i!}(d_i+1)^m\right)\left(\sum_{i=1}^n(d_i+1)^m\right)
\end{aligned}
$$
前面两项是定值，我们先不管。我们考虑后面那个东西，它等价于
$$
\sum\limits_{\sum d=n-2}\sum\limits_{i=1}^n\frac{a_i^{d_i}}{d_i!}(d_i+1)^{2m}\prod\limits_{j\not=i}\frac{a_j^{d_j}}{d_j!}(d_j+1)^m
$$
我们考虑构造两个多项式 $A(x)=\sum\limits_{i}\dfrac{(i+1)^{2m}x^i}{i!},B(x)=\sum\limits_{i}\dfrac{(i+1)^mx^i}{i!}$，设答案关于 $\sum d$ 的生成函数为 $F(x)$，则有
$$
\begin{aligned}
F(x)&=\sum\limits_{i=1}^nA(a_ix)\prod\limits_{j\not=i}B(a_jx)\\
&=\sum\limits_{i=1}^n\frac{A(a_ix)}{B(a_ix)}\prod_{j=1}^n
B(a_jx)\\
&=\sum\limits_{i=1}^n\frac{A(a_ix)}{B(a_ix)}\exp\left(\sum\limits_{j=1}^n\ln(B(a_jx))\right)
\end{aligned}
$$
如果我们求出了 $\dfrac{A(x)}{B(x)}$ 与 $\ln(B(x))$，我们只需要每一项的系数乘上 $\sum\limits_{i=1}^na_i^t$ 即可。

代码：

```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
namespace polynomials
{
    int const p=998244353,g=3;
    int const N=(1<<18)+1;
    int w[N],iv[N],r[N],last;
    typedef vector<int> vec;
    int mod(int x){return x>=p?x-p:x;}
    int pw(int x,int y)
    {
        int res=1;
        while(y)
        {
            if(y&1)res=1ll*res*x%p;
            x=1ll*x*x%p;
            y>>=1;
        }
        return res;
    }
    void init(int n)
    {
        int lim=1;
        while(lim<n)lim<<=1;
        iv[1]=1;
        for(int i=2;i<=lim;i++)iv[i]=mod(p-1ll*(p/i)*iv[p%i]%p);
        for(int i=1;i<lim;i<<=1)
        {
            int wn=pw(g,(p-1)/(i<<1));
            for(int j=0,ww=1;j<i;j++,ww=1ll*ww*wn%p)w[i+j]=ww;
        }
    }
    void ntt(vec &f,int n,int op)
    {
        f.resize(n);
        for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)|((i&1)?(n>>1):0);
        for(int i=1;i<n;i++)if(i<r[i])swap(f[i],f[r[i]]);
        for(int i=1;i<n;i<<=1)
        for(int j=0;j<n;j+=i<<1)
            for(int k=0;k<i;k++)
            {
                int x=f[j+k],y=1ll*f[i+j+k]*w[i+k]%p;
                f[j+k]=mod(x+y);f[i+j+k]=mod(x-y+p);
            }
        if(op==-1)
        {
            reverse(&f[1],&f[n]);
            for(int i=0;i<n;i++)f[i]=1ll*f[i]*iv[n]%p;
        }
    }
    void getinv(vec f,vec &g,int n)
    {
        static vec x;
        g.resize(n);
        if(n==1){g[0]=pw(f[0],p-2);return;}
        getinv(f,g,(n+1)>>1);
        int lim=1;
        while(lim<(n<<1))lim<<=1;
        x.resize(lim);
        for(int i=0;i<n;i++)x[i]=f[i];
        for(int i=n;i<lim;i++)x[i]=0;
        g.resize(lim);
        ntt(x,lim,1),ntt(g,lim,1);
        for(int i=0;i<lim;i++)g[i]=1ll*g[i]*(2-1ll*g[i]*x[i]%p+p)%p;
        ntt(g,lim,-1);
        g.resize(n);
    }
    void getln(vec f,vec &g,int n)
    {
        static vec x;
        getinv(f,x,n);
        for(int i=0;i<n-1;i++)f[i]=1ll*f[i+1]*(i+1)%p;
        f[n-1]=0;
        int lim=1;
        while(lim<((n<<1)-1))lim<<=1;
        ntt(f,lim,1),ntt(x,lim,1);
        for(int i=0;i<lim;i++)x[i]=1ll*x[i]*f[i]%p;
        ntt(x,lim,-1);
        g.resize(n);
        g[0]=0;
        for(int i=1;i<n;i++)g[i]=1ll*x[i-1]*iv[i]%p;
    }
    void getln(vec f,vec &g,vec &h,int n)
    {
        static vec x;
        getinv(f,x,n);h=x;
        for(int i=0;i<n-1;i++)f[i]=1ll*f[i+1]*(i+1)%p;
        f[n-1]=0;
        int lim=1;
        while(lim<((n<<1)-1))lim<<=1;
        ntt(f,lim,1),ntt(x,lim,1);
        for(int i=0;i<lim;i++)x[i]=1ll*x[i]*f[i]%p;
        ntt(x,lim,-1);
        g.resize(n);
        g[0]=0;
        for(int i=1;i<n;i++)g[i]=1ll*x[i-1]*iv[i]%p;
    }
    void getexp(vec f,vec &g,int n)
    {
        static vec x;
        g.resize(n);
        if(n==1){g[0]=1;return;}
        int m,lim=1;
        getexp(f,g,m=((n+1)>>1));
        while(lim<(n<<1))lim<<=1;
        g.resize(lim);
        getln(g,x,n);
        x.resize(lim);
        for(int i=0;i<n;i++)x[i]=mod(f[i]-x[i]+p);
        for(int i=n;i<lim;i++)x[i]=0;
        x[0]=mod(x[0]+1);
        ntt(g,lim,1),ntt(x,lim,1);
        for(int i=0;i<lim;i++)g[i]=1ll*g[i]*x[i]%p;
        ntt(g,lim,-1);
        g.resize(n);
    }
}
using namespace polynomials;
int n,m,a[30005];
vec solve(int l,int r)
{
    if(l==r){vec res;res.pb(1);res.pb(p-a[l]);return res;}
    int mid=(l+r)>>1,lim=1;
    vec x=solve(l,mid),y=solve(mid+1,r);
    while(lim<(r-l+2))lim<<=1;
    ntt(x,lim,1),ntt(y,lim,1);
    for(int i=0;i<lim;i++)x[i]=1ll*x[i]*y[i]%p;
    ntt(x,lim,-1);x.resize(r-l+2);
    return x;
}
int fac[30005],inv[30005];
int main()
{
    int prod=1;
    init(131071);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),prod=1ll*prod*a[i]%p;
    vec t=solve(1,n+1),res;
    getln(t,res,n+1);
    for(int i=0;i<n;i++)res[i]=1ll*res[i+1]*(i+1)%p;
    for(int i=0;i<n;i++)
        if(res[i])res[i]=p-res[i];
    for(int i=n-1;i>=1;i--)res[i]=res[i-1];
    res[0]=n;
    vec a,b,c,d;
    a.resize(n),b.resize(n);
    fac[0]=inv[0]=1;
    for(int i=1;i<n;i++)fac[i]=1ll*fac[i-1]*i%p;
    inv[n-1]=pw(fac[n-1],p-2);
    for(int i=n-2;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%p;
    for(int i=0;i<n;i++)
    {
        int t=pw(i+1,m);
        b[i]=1ll*t*inv[i]%p;
        a[i]=1ll*b[i]*t%p;
    }
    getln(b,d,c,n);
    int lim=1;
    while(lim<(n<<1))lim<<=1;
    ntt(a,lim,1),ntt(c,lim,1);
    for(int i=0;i<lim;i++)a[i]=1ll*a[i]*c[i]%p;
    ntt(a,lim,-1),a.resize(n);
    for(int i=0;i<n;i++)a[i]=1ll*a[i]*res[i]%p,d[i]=1ll*d[i]*res[i]%p;
    c.clear();
    getexp(d,c,n);
    ntt(a,lim,1),ntt(c,lim,1);
    for(int i=0;i<lim;i++)a[i]=1ll*a[i]*c[i]%p;
    ntt(a,lim,-1);
    printf("%lld",1ll*a[n-2]*fac[n-2]%p*prod%p);
    return 0;
}
```

---

## 作者：Wen_kr (赞：4)

考虑将一开始就连通的点缩起来，然后枚举缩点后的生成树 $T$。

那么最终的答案就是：

$\sum_{T}\sum_{i=1}^n d_i^m \prod_{j=1}^n d_j^m a_j^{d_j}$

之所以要乘上 $\prod_{j=1}^n a_j^{d_j}$，是因为每个连通块连出的每一条边都可以选择该连通块中的任意一个点连出去，因此方案数为 $a_j^{d_j}$。

将 $\prod$ 中 $i=j$ 的项提前，我们有

$\sum_T\sum_{i=1}^{n} d_i^{2m} a_i^{d_i} \prod_{j\neq i} d_j^ma_j^{d_j}$

考虑用一种固定的方法枚举树。

不妨枚举生成树的 Prufer 序，考虑枚举每个点在 Prufer 序中出现的次数为 $c_i$，那么有 $d_i=c_i+1$。

对于一个长度为 $n-2$ 的 Prufer 序，我们已经枚举了每个点的出现次数，那么对应的 Prufer 序列总共有 $\frac{(n-2)!}{\prod c_i!}$ 种。

现在式子变成了：

$\sum_{\sum c_i=n-2}\frac{(n-2)!}{\prod c_i!}\sum_{i=1}^n (c_i+1)^{2m}a_i^{c_i+1}\prod_{j \neq i} (c_j+1)^m a_j^{c_j+1}$

这个式子看起来很棘手。

考虑由于我们要求 $\sum c_i = n-2$，不妨用 $c_i$ 作为指数。

由于你需要计算可重排列，需要除以 $\prod c_i!$，考虑构造 EGF。

令 $\hat A_i(x)=\sum_k (k+1)^{2m}a_i^{k+1}\frac{x^k}{k!}$

$\hat B_i(x)=\sum_k (k+1)^m a_i^{k+1} \frac{x^k}{k!}$

现在的答案式子为

$(n-2)![x^{n-2}]\sum_{i=1}^n \hat A_i(x)\prod_{j\neq i}\hat B_j(x)$

观察到 $a_i$ 的次数是 $k+1$，$x$ 的次数是 $k$，这非常令人讨厌。

考虑给 $A$ 和 $B$ 同时提出一个 $a_i$ 出去。

我们有 $\hat A_i'(x)=\sum_k (k+1)^{2m}a_i^k\frac{x^k}{k!}$，$\hat B_i'(x)=\sum_k(k+1)^ma_i^k\frac{x^k}{k!}$


带回答案式子里可以得到

$(n-2)![x^{n-2}]\sum_{i=1}^n a_i\hat A_i'(x)\prod_{j\neq i} a_j\hat B_j'(x)$

$(n-2)![x^{n-2}]\sum_{i=1}^n (\prod_{k=1}^n a_k)\hat A_i'(x)\prod_{j\neq i}\hat B_j'(x)$

$(n-2)!(\prod_{i=1}^n a_i)[x^{n-2}]\sum_{i=1}^n a_i\hat A_i'(x)\prod_{j\neq i} a_j\hat B_j'(x)$

观察到此时 $\hat A_i'(x)$ 与 $\hat B_i'(x)$ 内 $x$ 和 $a_i$ 的次幂都是 $k$，不妨将它们合并，设：

$\hat A(x)=\frac{x^k(k+1)^{2m}}{k!}$

$\hat B(x)=\frac{x^k(k+1)^m}{k!}$

那么原式变成了

$(n-2)!(\prod_{i=1}^n a_i) [x^{n-2}] \sum_{i=1}^n \hat A(a_ix) \prod_{j \neq i} \hat B(a_jx)$

前面那一坨东西反正是个定值，我们盯着后面那一半看。

后面那一半可以化为

$\prod_{j=1}^n \hat B(a_jx) \sum_{i=1}^n \frac{\hat A(a_ix)}{\hat B(a_ix)}$

前面的 $\prod$ 很恶心，但是观察到如果我们算出了 $\hat B(x)$，我们能较为方便地求出每个 $\hat B(a_ix)$。

所以可以考虑化 $\prod$ 为 $\sum$，先 ln 再 exp 有：

$exp(\sum_{j=1}^n ln (\hat B(a_jx))) \sum_{i=1}^{n} \frac{\hat A(a_ix)}{\hat B(a_ix)}$

当求出了 $ln \hat B(x)$ 以及 $\frac{\hat A(x)}{\hat B(x)}$ 以后，我们只要为第 $k$ 项乘上 $\sum a_i^k$ 就能得出 $\sum ln \hat B(a_jx)$ 和 $\sum\frac{\hat A(a_ix)}{\hat B(a_ix)}$。

最后的问题，对于任意的 $k$，求 $\sum a_i^k$。

记这个东西的 OGF 为 $G(x)$。

我们有 $G(x)=\sum_{k\geq 0}\sum_{i=1}^n a_i^kx^k$

交换前后两个 $\sum$，不难发现后面那一坨不会变化，因此我们有

$G(x)=\sum_{i=1}^n\sum_{k\geq 0}(a_ix)^k$。

后面那个东西就是 $\frac{1}{1-a_ix}$。

于是 $G(x)=\sum_{i=1}^n \frac{1}{1-a_ix}$。

但是现在这个 $G(x)$ 很不方便算。

如果我们能通过某种特别的方式将相加变为相乘，那看起来就很漂亮，因为下面的每个多项式次数都是 $1$，这是一个特别简单的分治 $NTT$。

这个时候我们想起了对数函数，对数函数有一点就是 $lnA + lnB = ln AB$。

可惜如果直接换成 $ln$，外层会套上一个 $exp$，而 $\sum exp(ln(x))$ 是没有什么好方法快速计算的。

那么，有没有什么方法，能够跳过这个 $exp$，直接换成 $ln$ 呢？

这令我们想到了求导，因为求导满足我们想要的重要的两个条件：

第一是 $f'(x)+g'(x)=(f(x)+g(x))'$，也就是求导符号可以任意换到里外，这让我们可以使得若干个 $ln$ 的导数相加变为若干个 $ln$ 相加再求导。

第二是对 $ln F$ 求导结果是 $\frac{F'}{F}$，这个分数形式看起来已经很接近我们需要的了。

对 $ln(1-a_ix)$ 求导，结果是 $-\frac{a_i}{1-a_ix}$。

我们原来的式子上面是没有那个 $a_i$ 的，我们得想个办法凑出一个 $\frac{a_i}{1-a_ix}$ 出来。

观察到 $\frac{1}{1-a_ix}=1+\frac{a_ix}{1-a_ix}$，原式子就能变成：

$\sum_{i=1}^n(1+\frac{a_ix}{1-a_ix})$。

提出 $n$ 个 $1$ 以后，我们惊喜地发现原式可以化为 $n-x\sum_{i=1}^{n}(-\frac{a_i}{1-a_ix})$，这和对 $ln$ 求导出来的形式相同。

于是原式子变成了

$n-x\sum_{i=1}^n(ln(1-a_ix))'$

由求导法则，$f'(x)+g'(x)=(f(x)+g(x))'$，于是后半段可以变成 $n-x(ln(\prod_{i=1}^n(1-a_ix)))'$。

这显然可以使用分治 NTT 解决。于是做完了，时间复杂度为 $O(n \log^2 n)$

实际上，本题还存在一种 $O(nm\log n)$ 的斯特林数做法，但是笔者不太会。

---

## 作者：yijan (赞：3)

为了更好的阅读体验，同时由于不知道公式会不会挂，建议到 luogu 博客或者 [这里](https://www.yijan.co/qing-hua-ji-xun-2017-sheng-cheng-shu-ji-shu/) 阅读。

给定一张 $s$ 个点的图，存在 $s-n$ 个边，使得图中形成了 $n$ 个联通块，第 $i$ 个联通块内部有 $a_i$ 个点。

我们现在要再连 $n-1$ 个边，使得该图成为一个树。对于某一种连边方式，我们设原题第 $i$ 个联通块连出了 $d_i$ 条边，那么当前树的权值为
$$
val(T) = \left(\prod_{i=1}^n d_i^m\right) \left(\sum_{i=1}^n d_i^m\right)
$$
求所有生成树的权值和。
$$
n \le 3\times 10^4 , m\le 30
$$

---

我们可以考虑把开始就连通的点缩起来，枚举一个联通块的生成树 $T$ ，那么
$$
ans = \sum_{T} \sum_{i=1}^n d_i^m \prod_{j=1}^n d_j^m a_j^{d_j}
$$
我们考虑一个联通块向外连，可能是这个联通块的任何一个点往外连，并且一个点可以连多个边出去。

我们把 $d_i^ma_i^{d_i}$ 提出到前面去，那么
$$
ans = \sum_{T} \sum_{i=1}^n d_i^{2m}a_i^{d_i} \prod_{j\neq i} d_j^m a_j^{d_j}
$$
但是生成树 $T$ 无疑是不容易枚举的，可以转而枚举 prufer 序。复习一下

> prufer 序列的构造是，每次删除最小的叶子，把它的父亲加入序列。重复这个过程直到只剩下两个点，则构造出了一个长度为 $n-2$ 的序列。一个 prufer 序对应唯一一个无根树。

prufer 序有个很好的性质，一个数在 prufer 序列的出现次数就是它的度数减一。

如果我们钦定了每个点的出现次数 $c_i$ ，那么这样的 prufer 序列有正好 $\frac{(n-2)!}{\prod c_i!}$ 种。

我们考虑用枚举这样的出现次数 $c_i$ 序列替代枚举 $T$ ，那么
$$
ans = \sum_{\sum c_i = n-2} \frac{(n-2)!}{\prod c_i!} \sum_{i=1}^n(c_i+1)^{2m}a_i^{c_i+1} \prod_{j\neq i} (c_j+1)^m a_j^{c_j+1}
$$
考虑这个 $\sum c_i = n - 2$ 的限制，我们可以用 $c_i$ 作为指数来构造 EGF。写出来就是
$$
\hat A_i(x) = \sum_{k} (k+1)^{2m} a_i^{k+1} \frac {x^k}{k!}
$$
$$
\hat B_i(x) = \sum_{k} (k+1)^{m} a_i^{k+1} \frac{x^k}{k!}
$$

$$
ans = (n-2)![x^{n-2}]\sum_{i=1}^n A_i(x)\prod_{j\neq i} B_j(x)
$$

这个东西看起来完全不可优化？

我们的目标是，让 $A,B$ 能否从 $n$ 项化简到只需要 $m$ 项，乘上一个可以提出去的系数。

发现对于 $A,B$， $x$ 的指数都是 $k$ ，而前面竟然是 $k+1$ ，所以考虑先积分一下，提升 $x$ 的指数，化简后再求导
$$
\begin{aligned}\int A(x) &= \sum_{k} (k+1)^{2m} a_i^{k+1} \frac{x^{k+1}}{(k+1)!}\\&= \sum_k k^{2m} a_i^k \frac{x^k}{k!}\end{aligned}
$$
这个式子看起来又化简不动了，考虑后面那块 $a_i^k \frac{x^k}{k!}$ 看起来就非常 $\exp$ 。但是如果直接把 $\exp$ 提出去会发现又一次化不动了，所以考虑先把 $k^{2m}$ 用斯特林数展开，交换循环次序后看看能否化简去掉后面的 $\sum$
$$
\begin{aligned}\int A(x) &= \sum_k a_i^k\frac{1}{k!} \sum_{j=0}^{2m} \begin{Bmatrix}2m \\ j\end{Bmatrix} \frac{k!}{(k-j)!} x^k\\&=\sum_{j=0}^{2m} \begin{Bmatrix}2m \\ j\end{Bmatrix}  \sum_{k} \frac{a_i^kx^k}{(k-j)!}\end{aligned}
$$
我们考虑提出一个 $a_i^jx^j$  就可以把后面转化成 $\exp$ 了！
$$
\begin{aligned}\int A(x) &= \sum_{j=0}^{2m} \begin{Bmatrix}2m \\ j\end{Bmatrix} a_i^jx^j \sum_{k} \frac{a_i^{k-j}x^{k-j}}{(k-j)!}\\&= \sum_{j=0}^{2m} \begin{Bmatrix}2m \\ j\end{Bmatrix} a_i^jx^j \exp(a_ix)\\\end{aligned}
$$
别忘了，我们还得给它求导回去。提出 $\exp(a_ix)$ 后利用 $(uv)' = u'v + uv'$，有
$$
A(x) = a_ie^{a_ix}\sum_{j=0}^{2m} \begin{Bmatrix}2m \\ j\end{Bmatrix} a_i^jx^j + \sum_{j=0}^{2m} \begin{Bmatrix}2m \\ j+1\end{Bmatrix} a_i^{j+1} (j+1) x^{j} e^{a_ix}
$$
提出 $e^{a_ix}$ 合并一下求和，那么有
$$
A(x) = e^{a_ix}\left(\sum_{j=0}^{2m}a_i^{j+1} x^j \left(\begin{Bmatrix}2m \\ j\end{Bmatrix} + (j+1)\begin{Bmatrix}2m \\ j+1\end{Bmatrix}\right)\right)
$$
后面竟然正好是斯特林数的递推公式。。。
$$
A(x) = e^{a_ix}\left(\sum_{j=0}^{2m}a_i^{j+1} x^j \begin{Bmatrix}2m+1 \\ j+1\end{Bmatrix} \right)
$$
对于 $B$ ，不难发现它和 $A$ 形式几乎是一摸一样，只是把 $2m$ 变成了 $m$ ，所以
$$
B(x) = e^{a_ix}\left(\sum_{j=0}^{m}a_i^{j+1} x^j \begin{Bmatrix}m+1 \\ j+1\end{Bmatrix} \right)
$$
然后记 $A_i(x) = e^{a_ix} A_i^1 (x) , B_i(x) = e^{a_ix}B_i^1(x)$
$$
\begin{aligned}ans &= (n-2)![x^{n-2}]\sum_{i=1}^n A_i(x)\prod_{j\neq i} B_j(x)\\&= (n-2)![x^{n-2}]e^{\sum a_ix}\sum_{i=1}^nA_i^1(x) \prod_{j\neq i} B_j^1(x) \end{aligned}
$$
我们让后面的两个式子都变成了 $O(m)$ 项了！

于是后面乘积部分可以分治 NTT 乘出来除开某一项的 $B$ 的积再乘上 $A$ 加进去，总共也才 $O(nm)$ 项，于是复杂度是 $O(nm\log^2 (nm))$。前面的 $\exp$ 直接算一下就好了。

结 束 了 吗 ？

如果直接交上去，或许在 LOJ 5s 可以跑过去，但是在 luogu 会得到一个 TLE。

---

有没有更加优秀的优化呢？

回到最初的式子，令
$$
\hat A'_i(x) = \sum_{k} (k+1)^{2m} \frac {x^k}{k!}
$$
$$
\hat B'_i(x) = \sum_{k} (k+1)^{m} \frac{x^k}{k!}
$$
注意此处非求导。

对比之前的式子，
$$
ans = (n-2)![x^{n-2}]\sum_{i=1}^n A_i(x)\prod_{j\neq i} B_j(x)
$$
我们只要提出去一个 $\prod a_i$ 就可以把 $A_i,B_j$ 换成 $A',B'$ ，也就是
$$
ans = (n-2)![x^{n-2}]\left(\prod a_i\right)\sum_{i=1}^n A'(a_ix)\prod_{j\neq i} B'(a_jx)
$$
我们考虑交换 $\prod$ 和 $\sum$ 的顺序，
$$
ans = (n-2)![x^{n-2}]\left(\prod a_i\right)\prod_{j=1}^n B'(a_jx)\sum_{i=1}^n \frac{A'(a_ix)}{B'(a_ix)}
$$
然后把乘积通过 $\ln,\exp$ 拆成求和的形式
$$
ans = (n-2)![x^{n-2}]\left(\prod a_i\right)\exp\left(\sum_{j=1}^n \ln(B'(a_jx))\right)\sum_{i=1}^n \frac{A'(a_ix)}{B'(a_ix)}
$$
我们现在可以预处理出 
$$
F(x) = \frac{A'(x)}{B'(x)}
$$
$$
G(x) = \ln(B'(x))
$$
考虑 $[x^t]f(a_ix) = a_i^t[x^t]f(x)$ ，所以
$$
[x^t]\sum_{i=1}^n F(a_ix)
$$
$$
= \sum_{i=1}^n a_i^t[x^t]F(x)
$$
$$
=[x^t]F(x) \sum_{i=1}^n a_i^t
$$
所以现在我们需要对于 $k\in [1,n]$ 快速求出 $\sum a_i^k$。

我们构造它的 OGF 
$$
\begin{aligned}T(x) &= \sum_{k\ge 0} \sum_{i=1}^n a_i^kx^k\\&= \sum_{i=1}^n \sum_{k\ge 0} (a_ix)^k \\&= \sum_{i=1}^n \frac 1 {1-a_ix}\\&= \sum_{i=1}^n 1+\frac {a_i x} {1-a_ix}\\&= n + x\sum_{i=1}^n \frac {a_i} {1-a_ix}\\&= n - x\sum_{i=1}^n \left(\ln(1-a_ix)\right)'\\&= n - x\left(\ln\prod_{i=1}^n (1-a_ix)\right)'\\\end{aligned}
$$
所以做一次 分治 FFT 就求出了 $T$ ，从而可以求出答案了。

总复杂度是分治 FFT 的 $O(n\log^2 n)$ 。

写这题顺便可以顺便复习 $\ln,\exp$ 求逆以及分治2333

无卡常情况下 LOJ Rank 7。。复杂度很优秀

```cpp
#include "iostream"
#include "algorithm"
#include "cstring"
#include "cstdio"
#include "cmath"
#include "vector"
#include "map"
#include "set"
#include "queue"
using namespace std;
#define MAXN 100006
//#define int long long
#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)
#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector<int>
#define all(x) (x).begin() , (x).end()
#define mem( a ) memset( a , 0 , sizeof a )
typedef long long ll;
int n , m;
int A[MAXN];
#define P 998244353
int Pow( int x , int a ) {
    int ret = 1;
    while( a ) {
        if( a & 1 ) ret = 1ll * ret * x % P;
        x = 1ll * x * x % P , a >>= 1;
    }
    return ret;
}
int wn[2][MAXN];
void getwn( int len ) {
    int w0 , w1;
    for( int mid = 1 ; mid < len ; mid <<= 1 ) {
        w0 = Pow( 3 , ( P - 1 ) / ( mid << 1 ) ) , w1 = Pow( 3 , P - 1 - ( P - 1 ) / ( mid << 1 ) );
        wn[0][mid] = wn[1][mid] = 1;
        for( int i = 1 ; i < mid ; ++ i )
            wn[0][mid + i] = wn[0][mid + i - 1] * 1ll * w0 % P,
            wn[1][mid + i] = wn[1][mid + i - 1] * 1ll * w1 % P;
    }
}
int rev[MAXN];
void getr( int len ) {
    int t = __builtin_ctz( len ) - 1;
    for( int i = 1 ; i < len ; ++ i ) rev[i] = ( rev[i >> 1] >> 1 ) | ( ( i & 1 ) << t );
}
void NTT( int A[] , int len , int f ) {
    for( int i = 0 ; i < len ; ++ i ) if( i < rev[i] ) A[i] ^= A[rev[i]] , A[rev[i]] ^= A[i] , A[i] ^= A[rev[i]];
    int t0 , t1;
    for( int mid = 1 ; mid < len ; mid <<= 1 )
        for( int i = 0 ; i < len ; i += ( mid << 1 ) )
            for( int j = 0 ; j < mid ; ++ j ) {
                t0 = A[i + j] , t1 = A[i + mid + j] * 1ll * wn[f][mid + j] % P;
                A[i + j] = ( t0 + t1 ) % P , A[i + mid + j] = ( t0 + P - t1 ) % P;
            }
    if( f ) for( int inv = Pow( len , P - 2 ) , i = 0 ; i < len ; ++ i ) A[i] = 1ll * A[i] * inv % P;
}
void NTT( vi& A , int len , int f ) {
    for( int i = 0 ; i < len ; ++ i ) if( i < rev[i] ) A[i] ^= A[rev[i]] , A[rev[i]] ^= A[i] , A[i] ^= A[rev[i]];
    int t0 , t1;
    for( int mid = 1 ; mid < len ; mid <<= 1 )
        for( int i = 0 ; i < len ; i += ( mid << 1 ) )
            for( int j = 0 ; j < mid ; ++ j ) {
                t0 = A[i + j] , t1 = A[i + mid + j] * 1ll * wn[f][mid + j] % P;
                A[i + j] = ( t0 + t1 ) % P , A[i + mid + j] = ( t0 + P - t1 ) % P;
            }
    if( f ) for( int inv = Pow( len , P - 2 ) , i = 0 ; i < len ; ++ i ) A[i] = 1ll * A[i] * inv % P;
}
int tmpa[MAXN];
void Inv( const int A[] , int B[] , int n ) { // B = Inv A (mod x^n)
    if( n == 1 ) { B[0] = Pow( A[0] , P - 2 ); return; }
    Inv( A , B , ( n + 1 ) >> 1 );
    rep( i , 0 , n - 1 ) tmpa[i] = A[i];
    int len = 1;
    while( len <= n + n ) len <<= 1;
    rep( i , n , len - 1 ) tmpa[i] = 0;
    getwn( len ) , getr( len );
    NTT( B , len , 0 ) , NTT( tmpa , len , 0 );
    rep( i , 0 , len - 1 ) B[i] = 1ll * B[i] * ( 2 - 1ll * tmpa[i] * B[i] % P + P ) % P;
    NTT( B , len , 1 );
    rep( i , n , len - 1 ) B[i] = 0;
}
int ta[MAXN];
void Ln( const int A[] , int B[] , int n ) { // B = Ln A (mod x^n)
    rep( i , 0 , n - 1 ) ta[i] = 1ll * ( i + 1 ) * A[i + 1] % P;
    int len = 1;
    Inv( A , B , n );
    while( len <= n + n ) len <<= 1;
    rep( i , n , len - 1 ) ta[i] = 0;
    getr( len ) , getwn( len );
    NTT( ta , len , 0 ) , NTT( B , len , 0 );
    rep( i , 0 , len - 1 ) B[i] = 1ll * B[i] * ta[i] % P;
    NTT( B , len , 1 );
    per( i , n - 1 , 1 ) B[i] = 1ll * B[i - 1] * Pow( i , P - 2 ) % P;
    rep( i , n , len ) B[i] = 0;
    B[0] = 0;
}
int tln[MAXN];
void Exp( const int A[] , int B[] , int n ) { // B = Exp A (mod x^n)
    if( n == 1 ) { B[0] = 1; return; }
    Exp( A , B , ( n + 1 ) >> 1 );
    int len = 1;
    while( len <= n + n ) len <<= 1;
    rep( i , 0 , len - 1 ) tln[i] = 0;
    Ln( B , tln , n );
    rep( i , 0 , n - 1 ) tln[i] = ( A[i] + P - tln[i] ) % P;
    ++ tln[0];
    getwn( len ) , getr( len );
    NTT( B , len , 0 ) , NTT( tln , len , 0 );
    rep( i , 0 , len - 1 ) B[i] = 1ll * B[i] * tln[i] % P;
    NTT( B , len , 1 );
    rep( i , n , len - 1 ) B[i] = 0;
}

vi& mul( vi& a , vi& b , int f ) { // a = a * b
    int sa = a.size() , sb = b.size() , len = 1;
    while( len <= sa + sb - 2 ) len <<= 1;
    a.resize( len ) , b.resize( len );
    getwn( len ) , getr( len );
    NTT( a , len , 0 ) , NTT( b , len , 0 );
    for( int i = 0 ; i < len ; ++ i ) a[i] = 1ll * a[i] * b[i] % P;
    NTT( a , len , 1 );
    if( f ) NTT( b , len , 1 );
    return a;
}
vi S[MAXN];
vi& solve( int l , int r ) {
    if( l == r ) return S[l];
    int m = l + r >> 1;
    return mul( solve( l , m ) , solve( m + 1 , r ) , 0 );
}
int R[MAXN] , T[MAXN];

int J[MAXN] , iJ[MAXN];
int A1[MAXN] , B1[MAXN] , a[MAXN] , b[MAXN] , rb[MAXN];
void solve() {
    cin >> n >> m;
    J[0] = iJ[0] = 1;
    for( int i = 1 ; i <= n ; ++ i ) J[i] = 1ll * J[i - 1] * i % P , iJ[i] = Pow( J[i] , P - 2 );
    int pro = 1;
    rep( i , 0 , n - 1 ) {
        scanf("%d",A + i) , pro = 1ll * pro * A[i] % P;
        S[i].pb( 1 ) , S[i].pb( P - A[i] );
    }
    vi& re = solve( 0 , n - 1 );
    rep( i , 0 , re.size() - 1 ) R[i] = re[i];
    Ln( R , T , n + 1 );
    for( int i = 0 ; i <= n ; ++ i ) T[i] = 1ll * i * T[i] % P;
    T[0] = P - n;
    for( int i = 0 ; i <= n ; ++ i )
        A1[i] = 1ll * Pow( i + 1 , 2 * m ) * iJ[i] % P , B1[i] = 1ll * Pow( i + 1 , m ) * iJ[i] % P , T[i] = P - T[i];
    Ln( B1 , b , n + 1 );
    Inv( B1 , a , n + 1 );
    int len = 1;
    while( len <= n + n ) len <<= 1;
    getwn( len ) , getr( len );
    NTT( a , len , 0 ) , NTT( A1 , len , 0 );
    rep( i , 0 , len - 1 ) a[i] = 1ll * a[i] * A1[i] % P;
    NTT( a , len , 1 );
    for( int i = 0 ; i <= n ; ++ i ) a[i] = 1ll * a[i] * T[i] % P , b[i] = 1ll * b[i] * T[i] % P;
    for( int i = n + 1 ; i < len ; ++ i ) a[i] = 0;
//    printf("Before Exp : "); for( int i = 0 ; i <= n ; ++ i ) printf("%d ",b[i]); puts("");
    Exp( b , rb , n + 1 );
//    printf("After Exp : "); for( int i = 0 ; i <= n ; ++ i ) printf("%d ",rb[i]); puts("");
    while( len <= n + n ) len <<= 1;
    getwn( len ) , getr( len );
    NTT( rb , len , 0 ) , NTT( a , len , 0 );
    for( int i = 0 ; i < len ; ++ i ) rb[i] = 1ll * rb[i] * a[i] % P;
    NTT( rb , len , 1 );
    cout << J[n - 2] * 1ll * pro % P * rb[n - 2] % P << endl;
}

signed main() {
//    freopen("6.in","r",stdin);
//    freopen("fuckout","w",stdout);
//    int T;cin >> T;while( T-- ) solve();
    solve();
}

```



---

## 作者：Jμdge (赞：3)

为什么这些大佬讲用 prufer 算贡献的时候都不带解释的说...是太显然了么？

结果小蒟蒻我两篇题解上翻下翻盯了一个中午才看出来是个什么鬼...我太菜了emmm

总而言之就是列出答案的式子然后各种推（多项式题的套路？）

### 但在此之前得先会 Prufer 序列丫！

# Prufer 序列

长话短说、简而言之、说到底就是：

一棵无根树的 Prufer 序列构成方法就是每次取出**编号最小**的**叶子**，然后把与其相邻的唯一那个点的编号记录进**序列尾部**，直到只剩两个节点，这样生成的序列长度为 n-2 

对于一棵无根树，它唯一对应了一个 Prufer 序列，一个 Prufer 序列也唯一对应了一棵树，也就是说树与 Prufer 序列之间呈双射（就是一一对应）的关系

我们可以用 Prufer 证出一个完全图的生成树个数为 $n^{n-2}$ 

因为我们考虑每个生成树都敌营一个 Prufer 序列，而 n-2 长度的 Prufer 序列每个位置都可以放置 1~n 的数，于是 Prufer 序列的个数为 $n^{n-2}$ ，于是对应的生成树个数就是 $n^{n-2} $ 了

（为什么我突然想到了一个 $n^n$ 的算法 【滑稽）

![](https://www.cnblogs.com/images/cnblogs_com/Judge/1264714/o_03C080BF92B6752210DE61CE9B0A22AA.png)




------------------

# 推导过程


有了前置芝士这道题就好做一点了...吧？

我们考虑计算每棵树对应的 Prufer 序列的贡献...我们令 $d_i$ 表示当前这棵树的 Prufer 序列中编号 i 出现的次数，那么每个节点的度数就是 $d_i+1$ （被某状态下的叶子结点连接到的次数和自己连出去的一次）

$$ANS=\sum_{\sum d_i=n-2}{(n-2)!\over \prod d_i!} \prod_{i=1}^n {a_i}^{d_i+1}(d_i+1)^m \sum_{j=1}^n (d_j+1)^m$$


这个式子前面的一坨阶乘就是说：对于一个 Prufer 序列： d ，我们考虑 $(n-2)!$ 排列，然后一个编号 $i$ 出现了 $d_i$ 次，他们的相对顺序对 Prufer 序列是没影响的，要除去贡献

然后对于后面 $d_i+1$  其实已经解释过了，就是考虑一个点的度数为其在 Prufer 序列中的出现次数加上 1 

然后我们就好开始推导了：


$$\begin{aligned}ANS=&\sum_{\sum d_i=n-2}{(n-2)!\over \prod d_i!} \prod_{i=1}^n {a_i}^{d_i+1}(d_i+1)^m \sum_{j=1}^n (d_j+1)^m \\ =& (n-2)! \prod_{i=1}^n a_i \sum_{\sum d_i=n-2}  \prod_{i=1}^{n} {a_i^{d_i}\over d_i! } (d_i+1)^m \sum_{j=1}^n (d_j+1)^m\\ =& (n-2)! \prod_{i=1}^n a_i \sum_{\sum d_i=n-2}  (d_i+1)^m \sum_{i=1}^n {a_i^{d_i} \over d_i!}(d_i+1)^{2m}  \prod_{j=1,j \not= i}^{n} {a_j^{d_j}\over d_j! }(d_i+1)^m                                                                       \end{aligned}$$

然后我们发现前面的两个表达式可以 $O(n)$ 求，所以主要任务就是求出后面这个东西：

$$\sum_{\sum d_i=n-2}  (d_i+1)^m \sum_{i=1}^n {a_i^{d_i} \over d_i!}(d_i+1)^{2m}  \prod_{j=1,j \not= i}^{n} {a_j^{d_j}\over d_j! }(d_i+1)^m $$


这个时候我们肯定没办法再直接推了，那么我们引入重头戏：生成函数

我们首先构造两个生成函数：

$$\begin{aligned} A(x)&=\sum_{i=0}^\infty{x^i (i+1)^{m}\over i!}  		                 \\B(x)&=\sum_{i=1}^\infty{x^i(i+1)^{2m}\over i!}\end{aligned}$$

然后我们令：

$$F(x)=\sum_{i=1}^nA(a_ix) \prod_{j=1,j\not=i}^n B(a_jx)$$

那么这个生成函数的第 n-2 项就是我们要求的式子的答案辣！

$$\begin{aligned}F(x)=&\sum_{i=1}^nB(a_ix) \prod_{j=1,j\not=i}^n A(a_jx)  \\=& \sum_{i=1}^n{B(a_ix)\over A(a_ix)} \prod_{j=1}^n A(a_jx) \\=&\sum_{i=1}^n {B(a_ix)\over A(a_ix)} Exp(\sum_{j=1}^n Ln( A(a_jx)) )                                                     \end{aligned}$$

上面这个 $\prod$ 取 Ln 转 $\sum$ 再 Exp 回来简直是套路？

那么新的问题来了，我们求出 $Ln~ A$ 和 ${B\over A}$ 的系数后，还要将第 k （k=1~n）项乘上 $\sum_{i=1}^{n} a_i^k$ 

那么我们考虑如何快速求出这个东西...

-----

# 数列的幂和函数

讲道理，如果说只是幂和函数的话，我们可以花样求：


>拉格朗日插值

>第二类斯特林数

>伯努利数

但是这里有个数列...

其实数列的话拉格朗日插值照样可以用，只不过这个复杂度嘛... 

$$k^2,k=n$$

！！！玩个鸡儿...

那么我们只能考虑奇技淫巧了0.0 （和[这道题](https://www.luogu.org/blog/yestoday/solution-p4705)做法蛮像的）

首先我们构造一下生成函数：

$$f_j(x)= \sum_{i=1}^k a_j^ix^i $$

那么我们要求的数列幂和函数就是：

$$G(x)=\sum_{j=1}^{n} f_j(x)$$

其中 $G(x)$ 的第 k 项系数就对应了 $\sum_{i=1}^n a_i^k$ 

那么我们把 $f_j(x)$ 的上界 k 变为 $\infty$ ，那么原来的东西可以变成：


$$f_j(x)={1\over 1-a_ix}$$

$$G(x)=\sum_{i=1}^n{1\over 1-a_ix}$$

然后我们考虑 $ln(x)'={x'\over x}$ ，那么我们令：

$$g_i(x)=ln(1-a_ix)'={-a_i\over 1-a_ix}$$

那么我们就发现 ：

$$g_i(x)=-\sum_{i=1}^k a_j^{i+1}x^i=-a_if_i(x)$$

于是：

$$G(x)=\sum_{i=1}^ng_i(x)x+n$$

然后我们考虑：


$$\begin{aligned}\sum_{i=1}^{n}G_i(x)=&\sum_{i=1}^nln(1-a_ix)' \\ =&  ln(\prod_{i=1}^n1-a_ix)'                             \end{aligned}$$

那么我们现在的任务就轻松很多了，只需要对于后面的多项式求个积...

然鹅暴力合并是 n^2 的说... 于是考虑一种与多点求值类似的做法（分治）？

（复杂度大概是 $n~log~n$ ？ 复杂度白痴傻傻算不清楚）

那么我们这样求出的 $G(x)$ 的每一项就是我们需要的东西辣~


-------

然后愉快的敲代码？（板子抄过来QWQ）

# code

100 plus 的代码（然鹅这里并没有到 $100^+$ ）

```cpp
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=1e5+3;
typedef int arr[M];
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int inc(int x,int y){return (x+y)%mod;}
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return (x-y+mod)%mod;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,res,limit,fac[M],finv[M];
arr siz,D[19],A,B,C,G,sum,r;
inline int qpow(Rg int x,Rg int p=mod-2,int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void init(int n){ int l=-1;
	for(limit=1;limit<n;limit<<=1)++l;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<l);
}
inline void NTT(int* a,int tp){
	fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(Rg int mid=1;mid<limit;mid<<=1){
		int Gn=qpow(tp?3:iG,(mod-1)/(mid<<1));
		for(Rg int j=0,I=mid<<1,x,y;j<limit;j+=I)
			for(Rg int k=0,g=1;k<mid;++k,g=mul(g,Gn))
				x=a[j+k],y=mul(a[j+k+mid],g),
				a[j+k]=(x+y)%mod,a[j+k+mid]=(x-y+mod)%mod;
	} if(tp) return; int inv=qpow(limit);
	fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
void Inv(int* a,int* b,int n){ static arr C,D;
	if(n==1) return b[0]=qpow(a[0]),void();
	Inv(a,b,n>>1),init(n<<1);
	fp(i,0,n-1) C[i]=a[i],D[i]=b[i];
	fp(i,n,limit-1) C[i]=D[i]=0; NTT(C,1),NTT(D,1);
	fp(i,0,limit-1) C[i]=mul(C[i],mul(D[i],D[i]));
	NTT(C,0); fp(i,n,limit-1) b[i]=0;
	fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),C[i]);
}
inline void Direv(int* a,int* b,int n){
	fp(i,1,n-1) b[i-1]=mul(a[i],i); b[n-1]=0;
}
inline void Inter(int* a,int* b,int n){
	fp(i,1,n-1) b[i]=mul(a[i-1],qpow(i)); b[0]=0;
}
inline void Ln(int* a,int* b,int n){
	static arr C,D; Inv(a,C,n),Direv(a,D,n),init(n<<1);
	fp(i,n,limit-1) C[i]=D[i]=0; NTT(C,1),NTT(D,1);
	fp(i,0,limit-1) C[i]=mul(C[i],D[i]); NTT(C,0),Inter(C,b,n);
}
inline void Exp(int* a,int* b,int n){
	if(n==1) return b[0]=1,void(); static arr B;
	Exp(a,b,n>>1),Ln(b,B,n),B[0]=dec(a[0]+1,B[0]);
	fp(i,1,n-1) B[i]=dec(a[i],B[i]); init(n<<1);
	NTT(B,1),NTT(b,1); fp(i,0,limit-1) b[i]=mul(b[i],B[i]);
	NTT(b,0); fp(i,n,limit-1) b[i]=B[i]=0;
}
void solv(int l,int r,int d){
	if(l==r) return D[d][0]=1,D[d][1]=mod-siz[l],void();
	int mid=(l+r)>>1; solv(l,mid,d),solv(mid+1,r,d+1);
	init(r-l+2); fp(i,mid-l+2,limit-1) D[d][i]=0;
	fp(i,r-mid+1,limit-1) D[d+1][i]=0; NTT(D[d],1),NTT(D[d+1],1);
	fp(i,0,limit-1) D[d][i]=mul(D[d][i],D[d+1][i]); NTT(D[d],0);
}
int main(){ n=read(),m=read(); if(n==1) return !puts("1");
	//////////////////// prep fac and ifac 
	fac[0]=finv[0]=finv[1]=1; fp(i,1,n) fac[i]=mul(fac[i-1],i);
	fp(i,2,n) finv[i]=mul(mod-mod/i,finv[mod%i]);
	fp(i,2,n) finv[i]=mul(finv[i-1],finv[i]);
	/////////////////// prep k=1~n, ∑ai^k 
	fp(i,1,n) siz[i]=read(); solv(1,n,0);
	fp(i,0,n) G[i]=D[0][i]; int len;
	for(len=1;len<=n;len<<=1); Ln(G,sum,len);
	fp(i,1,n) sum[i]=mod-mul(sum[i],i); sum[0]=n;
	/////////////////// calc  ANS 
	fp(i,0,n-1) A[i]=mul(qpow(i+1,m),finv[i]),
		B[i]=mul(qpow(i+1,m<<1),finv[i]);
	Ln(A,G,len),Inv(A,C,len),init(len<<1),NTT(C,1),NTT(B,1);
	fp(i,0,(len<<1)-1) B[i]=mul(B[i],C[i]); NTT(B,0);
	memset(A,0,sizeof A),memset(C,0,sizeof C);
	fp(i,0,n-1) B[i]=mul(B[i],sum[i]),A[i]=mul(G[i],sum[i]); //带入求值 
	Exp(A,C,len),init(len<<1); fp(i,n,(len<<1)-1) B[i]=0; // A 要 Exp 回来 
	NTT(B,1),NTT(C,1); fp(i,0,limit-1) B[i]=mul(B[i],C[i]); NTT(B,0);
	res=mul(B[n-2],fac[n-2]); fp(i,1,n) res=mul(res,siz[i]); //乘完之后每一项乘入 res 
	return !printf("%d\n",res);
}
```

# UPD AT: 2019.5.9




---

## 作者：tzc_wk (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P4002)

神题。

考虑将所有连通块缩成一个点，那么所有连好边的生成树在缩点之后一定是一个 $n$ 个点的生成树。我们记 $d_i$ 为第 $i$ 个连通块缩完点之后的度数 $-1$，那么共有 $\prod\limits_{i=1}^na_i^{d_i+1}\times\dfrac{(n-2)!}{\prod\limits_{i=1}^nd_i!}$ 个这样的生成树，稍微解释一下这个柿子，因为每个连通块的每条边都有可能是由其中 $a_i$ 个点中任意一点连出的，因此每个连通块连边的方案为 $a_i^{d_i+1}$，而由 Prufer 序列那套理论可知 $d_i$ 即为 $i$ 在 Prufer 序列中的出现次数，且 $\sum\limits_{i=1}^nd_i=n-2$，又因为一个 Prufer 序列与一棵生成树形成双射，故这样的 $n$ 个点的生成树个数为满足 $i$ 在序列中出现 $d_i$ 次的长度为 $n-2$ 的序列个数，即多重组合数 $\dbinom{n-2}{d_1,d_2,\cdots,d_n}=\dfrac{(n-2)!}{\prod\limits_{i=1}^nd_i!}$，用乘法原理将它们乘起来即可。

因此我们要求的答案即为 $\sum\limits_{d_1+d_2+\cdots+d_n=n-2}\prod\limits_{i=1}^na_i^{d_i+1}\times\dfrac{(n-2)!}{\prod\limits_{i=1}^nd_i!}\times(\prod\limits_{i=1}^n(d_i+1)^m)(\sum\limits_{i=1}^n(d_i+1)^m)$。考虑将柿子稍微变个形，将 $a_i^{d_i+1}$ 拆成 $a_i^{d_i}$ 与 $a_i$ 并将 $a_i$ 提到外面来，再将 $(n-2)!$ 提到外面来，即可得到 $(n-2)!\prod\limits_{i=1}^na_i\sum\limits_{d_1+d_2+\cdots+d_n=n-2}\prod\limits_{i=1}^n\dfrac{a_i^{d_i}}{d_i!}\times(\prod\limits_{i=1}^n(d_i+1)^m)(\sum\limits_{i=1}^n(d_i+1)^m)$，将里面的两个 $\prod$ 合并，又有 $(n-2)!\prod\limits_{i=1}^na_i\sum\limits_{d_1+d_2+\cdots+d_n=n-2}(\prod\limits_{i=1}^n\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^m)(\sum\limits_{i=1}^n(d_i+1)^m)$，前面的 $(n-2)!\prod\limits_{i=1}^na_i$ 是常数，因此我们只需算出后面的答案后乘上去即可。将里面 $\sum$ 的括号拆开，移到外面去，可得 $\sum\limits_{d_1+d_2+\cdots+d_n=n-2}\sum\limits_{i=1}^n(d_i+1)^m(\prod\limits_{j=1}^n\dfrac{a_j^{d_j}}{d_j!}(d_j+1)^m)$，再稍微整理一下即可得到 $\sum\limits_{d_1+d_2+\cdots+d_n=n-2}\sum\limits_{i=1}^n\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^{2m}\prod\limits_{j\ne i}^n\dfrac{a_j^{d_j}}{d_j!}(d_j+1)^m$。前面的我们 $\sum\limits_{d_1+d_2+\cdots+d_n=n-2}$ 非常讨厌，不过长得一脸幂级数的样子，因此考虑记 $A(x)=\sum\limits_{k\ge 0}\dfrac{x^k}{k!}(k+1)^m$，$B(x)=\sum\limits_{k\ge 0}\dfrac{x^k}{k!}(k+1)^{2m}$，那么显然 $\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^{2m}=[x^{d_i}]B(a_ix)$，$\dfrac{a_j^{d_j}}{d_j!}(d_j+1)^m=[x^{d_j}]A(a_jx)$，故 $\sum\limits_{d_1+d_2+\cdots+d_n=n-2}\sum\limits_{i=1}^n\dfrac{a_i^{d_i}}{d_i!}(d_i+1)^{2m}\prod\limits_{j\ne i}^n\dfrac{a_j^{d_j}}{d_j!}(d_j+1)^m=\sum\limits_{d_1+d_2+\cdots+d_n=n-2}\sum\limits_{i=1}^n[x^{d_i}]B(a_ix)\prod\limits_{j\ne i}^n[x^{d_j}]A(a_jx)$，而显然它又等于 $[x^{n-2}]\sum\limits_{i=1}^nB(a_ix)\prod\limits_{j\ne i}^nA(a_jx)$，哦吼，$\sum\limits_{d_1+d_2+\cdots+d_n=n-2}$，这下我们就可以直接从这两个幂级数入手了。

然鹅直接计算 $\sum\limits_{i=1}^nB(a_ix)\prod\limits_{j\ne i}^nA(a_jx)$ 还是不太容易，考虑按照 P4389 付公主的背包 的套路取 $\ln$ 再 $\exp$ 回去，即 $\sum\limits_{i=1}^nB(a_ix)\exp\sum\limits_{j\ne i}\ln A(a_jx)$，这里 $j\ne i$ 不太美观，因此考虑直接把 $j=i$ 的答案先统计进去，前面再除个 $A(a_ix)$，即 $\sum\limits_{i=1}^n\dfrac{B(a_ix)}{A(a_ix)}\exp\sum\limits_{j=1}^n\ln A(a_jx)$，这样两个 $\sum$ 就可以独立计算了，故我们只需算出 $\sum\limits_{i=1}^n\dfrac{B(a_ix)}{A(a_ix)}$ 和 $\exp\sum\limits_{j=1}^n\ln A(a_jx)$，然后把它们卷起来即可，不过这里又有一个问题，就是对于所有 $i$ 都要计算一遍 $\dfrac{B(a_ix)}{A(a_ix)}$ 及 $\ln A(a_jx)$，这样复杂度还是平方对数的，显然过不去。不过注意到 $[x^n]\dfrac{B(a_ix)}{A(a_ix)}=a_i^n[x^n]\dfrac{B(x)}{A(x)}$，$[x^n]\ln A(a_jx)=a_j^n[x^n]\ln A(x)$，因此我们只需预处理出 $\dfrac{B(x)}{A(x)}$ 和 $\ln A(x)$，那么 $\sum\limits_{i=1}^n\dfrac{B(a_ix)}{A(a_ix)}$ 的第 $k$ 项系数就是 $\dfrac{B(x)}{A(x)}$ 第 $k$ 项系数的 $\sum\limits_{i=1}^na_i^k$ 倍，$\sum\limits_{j=1}^n\ln A(a_jx)$ 也同理。

最后就是怎样对 $k\in[0,n]$ 求 $\sum\limits_{i=1}^na_i^k$，其实这个套路在 P4705 玩游戏 里就出现过了，不过这里再讲解一遍。由于 $a^k=[x^k]\dfrac{1}{1-ax}$，因此这东西的生成函数 $F(x)=\sum\limits_{i=1}^n\dfrac{1}{1-a_ix}$，注意到 $\ln'(\dfrac{1}{1-a_ix})=-\dfrac{a_i}{1-a_ix}$，而 $F(x)=\sum\limits_{i=1}^n\dfrac{1}{1-a_ix}=n-\sum\limits_{i=1}^n-\dfrac{a_i}{1-a_ix}$，故 $F(x)=n-\sum\limits_{i=1}^n\ln'(\dfrac{1}{1-a_ix})=n+\sum\limits_{i=1}^n\ln'(1-a_ix)$，根据导数的和等于和的倒数可知，$F(x)$ 又等于 $n+(\sum\limits_{i=1}^n\ln(1-a_ix))'=n+(\ln\prod\limits_{i=1}^n(1-a_ix))'$，里面的 $\prod$ 可以分治求出，复杂度 $n\log^2n$，求出来之后再 $\ln$ 一遍，$\text{direv}$ 一遍即可。

时间复杂度 $n\log^2n$。

注意特判 $n=1$，否则 UOJ 上过不去。

```cpp
const int pr=3;
const int MAXN=3e4;
const int MAXP=1<<16;
const int MOD=998244353;
const int ipr=(MOD+1)/3;
int qpow(int x,int e=MOD-2){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,m,a[MAXN+5],fac[MAXN+5],ifac[MAXN+5];
void init_fac(int n){
	fac[0]=ifac[0]=ifac[1]=1;
	for(int i=2;i<=n;i++) ifac[i]=1ll*ifac[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%MOD,ifac[i]=1ll*ifac[i]*ifac[i-1]%MOD;
}
int rev[MAXP+5],inv[MAXP+5];
void NTT(vector<int> &a,int len,int type){
	int lg=31-__builtin_clz(len);
	for(int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(lg-1));
	for(int i=0;i<len;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		int W=qpow((type<0)?ipr:pr,(MOD-1)/i);
		for(int j=0;j<len;j+=i){
			int w=1;
			for(int k=0;k<(i>>1);k++,w=1ll*w*W%MOD){
				int X=a[j+k],Y=1ll*w*a[(i>>1)+j+k]%MOD;
				a[j+k]=(X+Y)%MOD;a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
			}
		}
	}
	if(type==-1) for(int i=0;i<len;i++) a[i]=1ll*a[i]*inv[len]%MOD;
}
vector<int> conv(vector<int> a,vector<int> b){
	int len=1;while(len<a.size()+b.size()) len<<=1;
	a.resize(len,0);b.resize(len,0);NTT(a,len,1);NTT(b,len,1);
	for(int i=0;i<len;i++) a[i]=1ll*a[i]*b[i]%MOD;
	NTT(a,len,-1);return a;
}
vector<int> conv(vector<int> a,vector<int> b,int lenc){
	int len=1;while(len<a.size()+b.size()) len<<=1;
	a.resize(len,0);b.resize(len,0);NTT(a,len,1);NTT(b,len,1);
	for(int i=0;i<len;i++) a[i]=1ll*a[i]*b[i]%MOD;
	NTT(a,len,-1);if(a.size()>lenc) a.resize(lenc);
	return a;
}
vector<int> getinv(vector<int> a,int n){
	vector<int> b(n,0);assert(a[0]!=0);b[0]=qpow(a[0]);
	for(int i=2;i<=n;i<<=1){
		vector<int> c(a.begin(),a.begin()+i);
		vector<int> d(b.begin(),b.begin()+(i>>1));
		d=conv(d,d);c=conv(c,d);
		for(int j=0;j<i;j++) b[j]=(2*b[j]%MOD-c[j]+MOD)%MOD;
	} return b;
}
vector<int> direv(vector<int> a,int n){
	vector<int> b(n,0);
	for(int i=1;i<n;i++) b[i-1]=1ll*a[i]*i%MOD;
	return b;
}
vector<int> inter(vector<int> a,int n){
	vector<int> b(n,0);
	for(int i=1;i<n;i++) b[i]=1ll*a[i-1]*inv[i]%MOD;
	return b;
}
vector<int> getln(vector<int> a,int n){
	vector<int> a_=direv(a,n),b=getinv(a,n);
	b=conv(a_,b);b=inter(b,n);return b;
}
vector<int> getexp(vector<int> a,int n){
	vector<int> b(n,0);b[0]=1;
	for(int i=2;i<=n;i<<=1){
		vector<int> c(b.begin(),b.begin()+i);
		vector<int> d(b.begin(),b.begin()+(i>>1));
		c=getln(c,i);for(int j=0;j<i;j++) c[j]=(a[j]-c[j]+MOD)%MOD;
		(c[0]+=1)%=MOD;d=conv(d,c);
		for(int j=0;j<i;j++) b[j]=d[j];
	} return b;
}
int LEN=1;
vector<int> solve(int l,int r){
	if(l==r){return vector<int>{1,MOD-a[l]};}
	int mid=l+r>>1;return conv(solve(l,mid),solve(mid+1,r),LEN);
}
int main(){
	scanf("%d%d",&n,&m);init_fac(n);
	if(n==1) return printf("%d\n",m==0),0;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	while(LEN<=n) LEN<<=1;
	for(int i=1;i<=LEN<<1;i++) inv[i]=qpow(i);
	vector<int> A(LEN),B(LEN);
	for(int i=0;i<=n;i++) A[i]=1ll*ifac[i]*qpow(i+1,m)%MOD;
	for(int i=0;i<=n;i++) B[i]=1ll*ifac[i]*qpow(i+1,2*m)%MOD;
	vector<int> iA=getinv(A,LEN),lnA=getln(A,LEN);
	vector<int> mA=conv(B,iA,LEN);
	vector<int> C=solve(1,n);C.resize(LEN,0);
	C=getln(C,LEN);C=direv(C,LEN);for(int j=LEN-1;j;j--) C[j]=(MOD-C[j-1])%MOD;
	C[0]=n;//for(int i=1;i<=n;i++) printf("%d\n",C[i]);
	for(int i=0;i<LEN;i++) lnA[i]=1ll*lnA[i]*C[i]%MOD;
	for(int i=0;i<LEN;i++) mA[i]=1ll*mA[i]*C[i]%MOD;
	lnA=getexp(lnA,LEN);vector<int> ret=conv(lnA,mA);
	int ans=ret[n-2];//printf("%d\n",ans);
	for(int i=1;i<=n;i++) ans=1ll*ans*a[i]%MOD;
	ans=1ll*ans*fac[n-2]%MOD;
	printf("%d\n",ans);
	return 0;
}
```



---


# [MtOI2018] 情侣？给我烧了！（加强版）

## 题目背景

FFF

本题原版：[P4921](https://www.luogu.com.cn/problem/P4921)

## 题目描述

有 $n$ 对情侣来到电影院观看电影。在电影院，恰好留有 $n$ 排座位，每排包含 $2$ 个座位，共 $2n$ 个座位。

现在，每个人将会随机坐在某一个位置上，且恰好将这 $2n$ 个座位坐满。

如果一对情侣坐在了同一排的座位上，那么我们称这对情侣是和睦的。

你的任务是求出共有多少种不同的就坐方案满足**恰好**有 *k* 对情侣是和睦的。

两种就坐方案不同当且仅当存在一个人在两种方案中坐在了不同的位置。不难发现，一共会有 $(2n)!$ 种不同的就坐方案。

由于结果可能较大，因此输出对 $998244353$ 取模的结果。

## 说明/提示

### 子任务

对于 $10 \%$ 的数据，满足 $1 \leq T \leq 10, 1 \leq n \leq 5$。

对于 $40 \%$ 的数据，满足 $1 \leq n \leq 3 \times 10^3$。

对于 $100 \%$ 的数据，满足 $1 \leq T \leq 2 \times 10^5, 1 \leq n \leq 5 \times 10^6, 0 \leq k \leq n$。

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T2 加强版

出题人：Imagine

50167

## 样例 #1

### 输入

```
5
1 1
2 0
2 2
2333 666
2333333 1000000
```

### 输出

```
2
16
8
798775522
300377435
```

# 题解

## 作者：Elegia (赞：145)

给出一个生成函数爆算递推式的方式：

不妨设 $D_n$ 是这个问题的“错排”：每对情侣都不在一排的方案数。那么对于答案 $f(n, k)$ 来说就可以用 $D_n$ 进行表示，即考虑坐在一排的情侣是哪几对且他们在哪几排，即

$$ f(n,k) = \binom nk^2 D_{n-k} k!2^k $$

这自然而然地导出了恒等式

$$ \sum_{k=0}^n \binom nk^2 D_{n-k}k!2^k = (2n)! $$

其中 $\binom nk^2$ 引导我们将生成函数写成 

$$ f(z) = \sum_{n=0}^\infty \frac{a_n}{n!^2} z^n $$

那么因为

$$ \sum_{n=0}^\infty \frac{n!2^n}{n!^2} z^n = \mathrm{e}^{2z} $$

$$ \sum_{n=0}^\infty \frac{(2n)!}{n!^2}z^n = \frac1{\sqrt{1-4z}} $$

带入原始，我们得到了 $D(z)$ 的生成函数方程

$$ D(z) \cdot \mathrm e^{2z} = \frac1{\sqrt{1-4z}} $$

因此

$$ D(z) = \frac{\mathrm e^{-2z}}{(1-4z)^{1/2}} $$

这帮助我们得到一个式子用于计算 $D_n$（其实就是容斥）

$$D_n = \sum_{k=0}^n \binom nk^2 (-2)^kk! (2n - 2k)!$$

或者也可以直接卷积，但是这都不够快速。我们考虑对 $D(z)$ 进行求导。

$$ D'(z) = \frac{8z\cdot \mathrm e^{-2z}}{(1-4z)^{3/2}} = \frac{8z}{1-4z} D(z) $$

这个微分方程可以帮助我们写出 $D(z)$ 的递推形式了，即

$$ D'(z) = 4zD'(z) + 8zD(z)$$

提取系数有

$$D_{n+1} = 4n(n+1)D_n + 8n^2(n+1)D_{n - 1}$$

---

## 作者：TimeTraveller (赞：45)

先$\rm Orz$并感谢$\rm Imagine$的讲解。

之前的弱化版的我们直接用一个$n^2$的$DP$求取错排的方案数即可，但是这里不行。

我们先算出刚好$K$个配对的方案数量，然后乘以剩下的错排方案数，但是这个显然不是简单的错排了，因此不能直接套用公式。

前面的刚好$K$个配对的就是：

- 选$k$排座位$C_n^k$
- 选$k$对情侣$C_n^k$
- 这$k$对每排可以交换坐$2^k$
- 这$k$排可以任意排列$k!$

所以前半部分的答案就为$(C_n^k)^2\times k!\times 2^k$

那么对于错排部分，我们模仿错排递推的推导过程分类考虑，我们令$g[n]$为$n$对不匹配的方案数：

首先我们看第一排坐两个不是情侣的人，不难发现，那么可以有$2n\times(2n-2)$种选法，剩下只有$n-1$个座位，对于剩下的，我们考虑另外的两个（就是与开始那两个坐在一起的另一半情侣），他们有两种方案：

- 坐在一起：就是在剩下的$n-1$排中任选一排，且这个两个人可以交换，然后就转化为子问题$g[n-2]$，所以贡献为$2\times (n-1)\times g[n-2]$
- 不坐在一起，我们就把他们又看作一个不能在一起的错排问题，于是贡献为$g[n-1]$

和错排公式结合起来，所以这部分的方案数贡献为$2n(2n-2)\left(g[n-1]+2(n-1)g[n-2]\right)$

那么答案就是$(C_n^k)^2\times k!\times 2^k\times 4n(n-1)\left(g[n-1]+2(n-1)g[n-2]\right)$

预处理阶乘和阶乘逆元还有$g$函数和$2$的幂，然后每次$O(1)$的回答即可。

复杂度为$O(logMod+n+T)$

其中的$logMod$为处理一个阶乘的逆元。

~~代码太丑就不放上来了~~


---

## 作者：qwaszx (赞：27)

这个做法和其他题解比起来更加暴力.

考虑二项式反演，在有$n$对情侣的前提下，设$f_k$表示至少有$k$对情侣匹配的方案数(这个至少的意思其实是对于所有$|S|=k$的集合$S$，匹配情侣集合包含$S$的方案数之和.简单地说就是子集反演的一个特殊情况)，$g_k$表示恰好有$k$对情侣匹配的方案数，那么显然有
$$f_k=\sum_{i=k}^n\binom{i}{k}g_i$$
根据二项式反演有
$$g_k=\sum_{i=k}^n\binom{i}{k}(-1)^{i-k}f_i$$
而$f_i$是容易计算的，先钦定$i$对匹配的情侣，把他们安排到座位里，每排左右可以互换，剩下的$(2n-2i)$个人随便排，方案数是
$$\binom{n}{i}\binom{n}{i}i!2^i(2n-2i)!$$
总的式子就是
$$\begin{aligned}&\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}\binom{n}{i}^2i!2^i(2n-2i)!\\=&\sum_{i=k}^n(-1)^{i-k}2^i\frac{i!}{k!(i-k)!}\frac{(n!)^2}{(i!)^2((n-i)!)^2}i!(2n-2i)!\\=&\frac{(n!)^2}{k!}\sum_{i=k}^n(-1)^{i-k}2^i\binom{2n-2i}{n-i}\frac{1}{(i-k)!}\\=&\frac{2^k(n!)^2}{k!}\sum_{i=0}^{n-k}(-1)^i2^i\frac{1}{i!}\binom{2(n-i+k)}{n-i+k}\\=&\frac{2^k(n!)^2}{k!}\sum_{i=0}^{n-k}\frac{(-2)^{n-k-i}}{(n-k-i)!}\binom{2i}{i}\end{aligned}$$
可以发现后面这一坨只和$n-k$有关，把它拿出来并设为$f_{n-k}$(前面定义的$f$已经对我们不重要了，我们可以丢弃掉它)
$$ans=\frac{2^k(n!)^2}{k!}f_{n-k}$$
其中
$$f_n=\sum_{i=0}^n\frac{(-2)^{n-i}}{(n-i)!}\binom{2i}{i}$$

考虑快速地把$f$递推出来，对$f$建立生成函数$F(x)$，容易发现$F(x)$其实是两个函数的卷积，也就是
$$F(x)=\left(\sum_{i\geq 0}\frac{(-2)^i}{i!}x^i\right)\left(\sum_{i\geq 0}\binom{2i}{i}x^i\right)$$
前面这个是$e^{-2x}$，后面有点困难，我们需要利用一些恒等式:
$$\binom{n-\frac{1}{2}}{n}=\frac{(n-\frac{1}{2})(n-1-\frac{1}{2})\cdots(\frac{1}{2})}{n!}=\frac{(2n-1)(2n-3)\cdots1}{2^nn!}=\frac{(2n)!}{2^{2n}n!n!}=\frac{\binom{2n}{n}}{4^n}$$
从而右边的一个就是
$$\sum_{i\geq 0}\binom{i-\frac{1}{2}}{i}4^ix^i=\sum_{i\geq 0}(-1)^i\binom{-1/2}{i}4^ix^i=(1-4x)^{-1/2}$$
于是
$$F(x)=\frac{e^{-2x}}{\sqrt{1-4x}}$$
微分一下
$$\frac{dF(x)}{dx}=\frac{8xe^{-2x}}{(1-4x)^{3/2}}=\frac{8xF(x)}{1-4x}$$
用$(1-4x)$乘两边并展开就得到
$$(i+1)f_{i+1}=4if_i+8f_{i-1}$$
预处理一下就好了.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int Nq=3e5;const int N=5e6+100,mod=998244353;
struct Q{int n,k;}q[Nq];
int fac[N],ifac[N],inv[N],f[N];
int getin()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}
int qpower(int a,int b)
{
    int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
    return ans;
}
int main()
{
    int T=getin();
    fac[0]=fac[1]=f[0]=ifac[0]=ifac[1]=1;
    int n=0;
    for(int i=1;i<=T;i++)
    {
        q[i].n=getin(),q[i].k=getin(),n=max(n,q[i].n);
    }
    for(int i=2;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;
    ifac[n]=qpower(fac[n],mod-2);
    for(int i=n-1;i>=2;i--)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;        
    for(int i=2;i<=n;i++)f[i]=1ll*ifac[i]*fac[i-1]%mod*(4ll*(i-1)*f[i-1]%mod+8ll*f[i-2])%mod;
    for(int i=1,w=2;i<=n;i++,w=(w<<1)%mod)
        ifac[i]=1ll*ifac[i]*w%mod,fac[i]=1ll*fac[i]*fac[i]%mod;
    for(int i=1;i<=T;i++)printf("%lld\n",1ll*fac[q[i].n]*ifac[q[i].k]%mod*f[q[i].n-q[i].k]%mod);
}
```



---

## 作者：NaCly_Fish (赞：25)

十三个月前看到这题时，根本不会啊...  
最近在看《组合数学》，回看此题，恍然大悟。  
于是写一篇题解来纪念一下。  
顺便补充一下 EI 神仙写的简略的地方...
****
还是考虑记 $D_n$ 为 $n$ 对情侣全都不配对的方案数。  
要计算有 $k$ 对配对的方案数，那么选男女分别 $\binom{n}{k}$ 种方案。  
这 $k$ 对情侣随便排列，两排之间还可以互换，剩下的错排，所以答案为：  

$$\binom{n}{k}^2D_{n-k}2^kk!$$

把 $k \in [0,n]$ 的答案全加起来，自然是全部排列的方案数：  

$$\sum\limits_{k=0}^n\binom{n}{k}^2D_{n-k}2^kk!=(2n)!$$  
把这个式子稍微变形  

$$\sum\limits_{k=0}^n\frac{2^k}{k!}\times\frac{D_{n-k}}{(n-k)!^2}=\frac{(2n)!}{n!^2}$$  
左边这显然是个卷积式，设 $\{\frac {D_n}{n!^2}\}$ 的生成函数为 $D(x)$，那么有：  

$$\text e^{2x}D(x)= \sum\limits_{k=0}^\infty\binom{2k}{k}x^k$$
根据广义二项式可以知道右面的式子其实是  
$$\frac{1}{\sqrt{1-4x}}$$  
于是就能得到 $D(x)$ 了：  
$$D(x)=\frac{\text e^{-2x}}{\sqrt{1-4x}}$$
根据书中的套路，要求其递推式，可以把它先求个导  
$$D'(x)=8x(1-4x)^{-3/2}\text e^{-2x}$$
把 $D'(x)$ 用 $D(x)$ 表示，就能得到
$$D'(x)=\frac{8xD(x)}{1-4x}$$
$$(1-4x)D'(x)=8xD(x)$$
$$D'(x)=4xD'(x)+8xD(x)$$  
有两个显然的事实
$$[x^n]D'(x)=(n+1)[x^{n+1}]D(x)$$
$$[x^n]xD(x)=[x^{n-1}]D(x)$$
然后提取上式的系数
$$\frac{D_{n+1}}{n!(n+1)!}=\frac{4D_n}{n!(n-1)!}+\frac{8D_{n-1}}{(n-1)!^2}$$  
移项得到
$$D_{n+1}=4n(n+1)D_n+8n^2(n+1)D_{n-1}$$
$$D_n=4n(n-1)D_{n-1}+8n(n-1)^2D_{n-2}$$
对于临界条件，显然有 $D_0=1,D_1=0$。

---

## 作者：Linne (赞：24)

一道披着黑皮的蓝...
------------
sb组合数学，但我不会qwq

------------

设f[i,j]为i对情侣，恰有j对在一起的方案数。

------------
显然，对于这j对在一起的，我们要先从i排里找出j排，有C(i,j)种方法；再把这些人排个顺序坐,有P(i,j)种方法，考虑左右交换：有2^j种方案。

------------
那么问题来了，对于这i-j对不坐在一起的怎么办？我们可以递推求解，设g[k]为k对情侣都不坐在一起的方案数。那么我们分类讨论：

------------
1、先选择一对~~基佬~~
------------
显然，方案数为C(k,2)*2,乘2还是因为可以交换。化简可得k*(k-1)

------------
2、先选择一对妹子
------------
显然同上。

3、选择一男一女，但不是情侣
------------
男的k个里总得选一个，女的就有一个不能选，左右交换也是可以的，所以是2*k*(k-1)


选完后，考虑他们的配偶（~~总不能晾着不管~~
------------
1、坐在一起，那么可以在k-1排里选一排，左右顺序可变，问题规模减少2；
2、不坐在一起，问题规模减少一。
乘上前面的，即可得：
g[k]=4k(k-1)(g[k-1]+2(k-1)g[k-2])

------------

总方案数f[n,k]=C(n,k)*P(n,k)*2^k*g[k]。预处理阶乘逆元2的幂以及g数组，就可以O(1)回答啦~

------------
附AC代码（压行什么的，才没有呢
```
#include<bits/stdc++.h>
const int M=998244353,N=5000005;
long long n,k,t,fac[N]={1},rev[N],g[N]={1,0},p[N]={1};
long long power(long long a,long long b){
    long long res=1;
    while(b){
        if(b&1)res=res*a%M;
        b>>=1;
        a=a*a%M;}
    return res;}
int main(){
    for(int i=1;i<=N;++i)fac[i]=fac[i-1]*i%M;
    rev[N]=power(fac[N],M-2);
    for(int i=N;i;--i )rev[i-1]=rev[i]*i%M;
    for(int i=2;i<=N;++i)g[i]=(g[i-1]+g[i-2]*2*(i-1))%M*4*i%M*(i-1)%M;
    for(int i=1;i<=N;++i)p[i]=p[i-1]*2%M;
    scanf("%lld",&t);
    while(t--){
        scanf("%lld%lld",&n,&k);
        printf("%lld\n",fac[n]*rev[n-k]%M*fac[n]%M*rev[k]%M*rev[n-k]%M*p[k]%M*g[n-k]%M);}
    return 0;}

```

---

## 作者：Spasmodic (赞：16)

组合意义 t x d y！

设 $f_n$ 表示在 $k=0$ 时的答案，即情侣全部错开的情况。

那么 $n,k$ 时的答案就是
$$
\binom{n}{k}\times \binom{n}{k}\times k!\times 2^k\times f_{n-k}
$$
解释一下这个式子的含义：
+ 第一个 $\dbinom{n}{k}$ 是在这 $n$ 对情侣中选出 $k$ 对情侣，这些情侣是和睦的
+ 第二个 $\dbinom{n}{k}$ 是在 $n$ 排中选出 $k$ 排让情侣坐
+ 第三个 $k!$ 是确定这 $k$ 对情侣分别坐哪几排
+ 第四个 $2^k$是确定这 $k$ 对情侣的顺序，即是男女还是女男
+ 第五个 $f_{n-k}$ 是确定剩下 $n-k$ 对情侣的位置

然后考虑如何递推 $f_n$。

考虑第一排坐的是什么人，可能是男男，女女或男女不同组，共 $(2\dbinom{n}{2}+n(n-1))\times 2=4n(n-1)$，以下不妨设为男男。

考虑这两个人对应的两女坐的位置，有两种情况：
+ 如果两女相邻，那么 $(n-1)$ 选出这两个人坐的排，$2$ 决定顺序，$f_{n-2}$ 决定剩下人的位置，共 $2(n-1)f_{n-2}$。
+ 如果两女不相邻，那么把这两女视为一对情侣~~绿了两男~~，共 $f_{n-1}$。

综上，可得转移
$$
f_n=4n(n-1)(f_{n-1}+2(n-1)f_{n-2})
$$
那么按照转移直接 dp 即可，复杂度 $O(n+T)$。

---

## 作者：hzoi_liuchang (赞：7)

## 分析
我们设 $f[x]$ 为恰好有 $x$ 对情侣都错开的方案数

我们考虑如何把其分解为子问题

首先我们可以从这 $2x$ 个人中随意选取一个人

接下来我们再选取一个不能与他配对的人

总的方案数为 $2x(2x-2)$

对于我们选出的这两个人的配偶，如果我们把他们也强制配对的话那么这相当于一个规模为 $x-2$ 的子问题，同时我们还要乘上 $x-1$ 代表在剩下的 $x-1$ 行中选出一行给他们坐，他们还可以交换位置，所以还要乘 $2$

如果我们不给他们强制配对的话，那么这就是一个规模为 $x-1$ 的子问题

初始化 $f[0]=1, f[1]=0$

转移方程 $f[x]=2x(2x-2)(f[x-1]+2(x-1)f[x-2])$

我们考虑了恰好有 $k$ 对情侣错开的的情况，下面要考虑本题的求解，即恰好有 $k$对情侣和睦的就坐方案数

首先我们要在 $n$ 对情侣中选出 $k$ 对情侣和睦，还要在 $n$ 排座位中选出 $k$ 排让他们坐，每对情侣在这 $k$ 排可以随便坐，情侣两人也可以互换位置

因此最终的结果为

$$C_n^k\times C_n^k \times  k! \times 2^k \times f[n-k]%mod$$

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
const int maxn=5e6+5;
int ny[maxn],jc[maxn],jcc[maxn],f[maxn];
long long ksm(int ds,int zs){
	long long ans=1;
	while(zs){
		if(zs&1) ans=ans*ds%mod;
		ds=(long long)ds*ds%mod;
		zs>>=1;
	}
	return ans%mod;
}
signed main(){
	ny[1]=1;
	for(int i=2;i<maxn;i++){
		ny[i]=((long long)mod-mod/i)*ny[mod%i]%mod;
	}
	jc[0]=1,jcc[0]=1;
	for(int i=1;i<maxn;i++){
		jc[i]=(long long)jc[i-1]*i%mod;
		jcc[i]=(long long)jcc[i-1]*ny[i]%mod;
	}
	f[0]=1,f[1]=0;
	for(int i=2;i<maxn;i++){
		f[i]=(long long)2*i*(2*i-2)%mod*((long long)f[i-1]%mod+(long long)(2*i-2)*f[i-2]%mod)%mod;
	}
	int t;
	scanf("%d",&t);
	while(t--){
		int n,k;
		scanf("%d%d",&n,&k);
		long long ans=(long long)jc[n]*jcc[k]%mod*jcc[n-k]%mod*jc[n]%mod*jcc[n-k]%mod*ksm(2,k)%mod*f[n-k]%mod;
		printf("%lld\n",ans%mod);
	}
	return 0;
}
```

---

## 作者：Illusory_dimes (赞：6)

### 题目描述
有一个有 $n$ 排但只有两列的电影院，同样有 $n$ 对情侣，如果两个人坐在了一起，他们就是和睦的，问恰有 $k$ 对情侣是和睦的方案数（注：男女交换后算另一种）

多组数据，对 $998244353$ 取模。

$1\leq T\leq 2\cdot 10^5\ ,\ 1\leq n\leq 5\cdot 10^6\ ,\ 0\leq k\leq n$

### solution
设一个函数 $g(x)$ 表示 $k=0$ 时的答案，于是答案就能表示成：

从 $n$ 对情侣中选 $k$ 对，从 $n$ 排座位中选 $k$ 排，一排上男女的两种坐法，$k$ 对情侣怎么坐 $k$ 排座位以及剩下的 $n-k$ 对情侣的坐法，写出来，就是：

$$g_{n-k}\cdot {\left( \begin{array}{c} n \\ k\end{array} \right)}^2\cdot 2^k\cdot k!$$

所以现在就要推 $g_n$ 。

如果先固定一排，那么两个人对应的伴侣就会有两种情况：

1.这俩伴侣看那两个人不爽，结果这俩又组一对，组了 $n-1$ 次，然后两人交换一下位置，又有 $n-1$ 种，最终剩下了 $n-2$ 排。

2.随缘，直接就跟其他人跑了，就等于还剩 $n-1$ 排。

所以就能表示成：

$$\big( 2\cdot (n-1)\cdot g_{n-2}+g_{n-1}\big)$$

最后就剩下这对我们强行配对的情侣了，他们的话，要么♂♂，要么♀♀，要么♂♀，~~总之都非常刺激的说~~，

易知♂♂或♀♀均为 $\Large\frac{1}{2}$ $\cdot n\cdot (n-1)$ ，♂♀为 $n\cdot (n-1)$ ，并且交换一下位置又是一种，综上，就可以写成：

$$\big(\frac{1}{2}\cdot n\cdot (n-1)+\frac{1}{2}\cdot n\cdot(n-1)+n\cdot(n-1)\big)\cdot 2$$

$$\Rightarrow n\cdot (n-1)\cdot 4$$

带上去，就是

$$g_n=n\cdot (n-1)\cdot 4\cdot \big( 2\cdot (n-1)\cdot g_{n-2}+g_{n-1}\big)$$

预处理一下 $g_n$ ，就能计算啦。

这题应该相对来说比较友好吧，就不放代码了。

---

## 作者：传奇666666 (赞：4)

虚假的黑题…………

其实就是个略微加了一些难度的错排板子（真的略微）。

首先考虑将问题分成$k$对正确的排列，和剩下$n-k$对完全错排。答案显然就是把这两部分给乘起来。

先看$k$对正确的部分。这部分对于给定的$n$，$k$来说是可以分成这么几步来算的：1，选出$k$排座位->$C_n^k$；2，选出$k$对狗男女，考虑相对顺序->$A_n^k$；考虑每排座位的两个人之间互换位置->$2^k$。把这几部分乘起来就得到了结果：$C_n^k*A_n^k*2^k$

之后考虑计算这道题里的错排部分。设$f_i$表示$i$对人的方案数。

假设现在在考虑$n$对人的错排。首先先选出来一对错误的人（考虑顺序，并且坐在第一排），显然有$2n*(2n-2)$种选法。之后考虑这两个人的另一半会是什么情况：1，这俩人坐在一起了->问题变为$n-2$对人错排;2，这俩人没在一起->问题变为$n-1$对人的错排。

因为第一种情况另外的那两人可以在后面$n-1$排里随便选，所以有$2*(n-1)*f_{n-2}$种方案；第二种就只有一种，所以是$f_{n-1}$种方案。

所以转移就是$f_n=2n*(2n-2)*(f_{n-1}+2*(n-1)*f_{n-2})$。

对于一个询问$n$，$k$，输出$C_n^k*A_n^k*2^k*f_{n-k}$即可。预处理一下阶乘，阶乘逆元，$2$的次幂和$f$数组之后就是$O(1)$输出了。

---

## 作者：81179332_ (赞：3)

生成函数算不明白，组合数想不到，还是太菜了

设 $g(n)$ 表示 $n$ 对情侣全部错开的方案数

答案很好表示：

$$ans_k=\dbinom n k\times A_n^k\times 2^k\times g(n-k)$$

表示从 $n$ 对座位中选出 $k$ 对给和谐的情侣，从 $n$ 对情侣中有序地选出 $k$ 对和谐的情侣放入，每对情侣可以男生坐左面或男生坐右面

那么我们求出 $g(i)$ 即可

我们在第一排放不和谐的两个人，容易发现，由于他们坐一块了，则他们的情侣都无法配对了，所以他们以及他们的情侣是男是女无所谓

分情况

若他们的两个情侣坐在了一起，则我们需要再选出一排安排给他们，方案数为 $2(i-2)\times g(i-2)$，乘二是考虑两人可以交换位置

若他们的两个情侣没坐在一起，那我们不妨将他们看成一对配对失败的情侣，则方案数为 $g(i-1)$

从 $2i$ 个人中选出不为情侣的两个人的方案数为：$2i(2i-2)=4i(i-1)$

则 $g(i)=4i(i-1)\times(g(i-1)+2(i-1)\times g(i-2))$

复杂度：$O(N+T)$

```cpp
//timeuse:20min
const int N = 5000010;
ll fac[N],ifac[N],g[N],t[N];
ll C(int n,int m) { return fac[n] * ifac[n - m] % mod * ifac[m] % mod; }
int main()
{
	int n = 5000000;
	fac[0] = 1;for(int i = 1;i <= n;i++) fac[i] = fac[i - 1] * i % mod;
	ifac[n] = qpow(fac[n],mod - 2);for(int i = n;i;i--) ifac[i - 1] = ifac[i] * i % mod;
	t[0] = 1;for(int i = 1;i <= n;i++) t[i] = Mod(t[i - 1] * 2);
	g[0] = 1,g[1] = 0;
	for(ll i = 2;i <= n;i++)
		g[i] = 4 * i * (i - 1) % mod * (g[i - 1] + 2 * (i - 1) * g[i - 2] % mod) % mod;
	int T = read();
	while(T--)
	{
		n = read();int k = read();
		fprint(C(n,k) * C(n,k) % mod * fac[k] % mod * t[k] % mod * g[n - k] % mod);
	}
	return 0;
}
```

---

## 作者：CXY07 (赞：2)

> 题目链接：[\[MtOI2018\]情侣？给我烧了！](https://www.luogu.com.cn/problem/P4931)

> **本题解同步发布于 [My Blog](http://www.cxy07.blog/index.php/archives/135/)**

题意：

> 有 $n$ 对情侣，电影院有 $n$ 排共 $2n$ 个座位，每排 $2$ 个座位，求恰好 $k$ 对情侣坐在同一排的方案数。

> $1\le T\le 2\times 10^5,1\le n\le 5\times 10^6,0\le k\le n$。

~~情侣？给我烧了！~~

考虑暴力反演。设 $f_k$ 为恰好 $k$ 对在同一排的方案数，$g_k$ 为钦定 $k$ 对在同一排的方案数，有：

$$
g_k=\sum_{i=k}^n \binom{i}{k}f_i=\binom{n}{k}^2 k!2^k(2n-2k)!
$$

后面的式子相当于先选出 $k$ 个位置，$k$ 对情侣，对他们进行排列，情侣内部座位可以交换，剩下的人随意排。

二项式反演可得：

$$
f_k=\sum_{i=k}^n (-1)^{i-k}\binom{i}{k}g_i
$$

暴力带入可得：

$$
f_k=\sum_{i=k}^n (-1)^{i-k}\binom{i}{k}\binom{n}{i}^2 i!2^i(2n-2i)!
$$

$$
=\sum_{i=k}^n (-1)^{i-k} \dfrac{i!}{k!(i-k)!}\dfrac{(n!)^2}{(i!)^2((n-i)!)^2} i!2^i(2n-2i)!
$$

$$
=\dfrac{(n!)^2}{k!}\sum_{i=k}^n (-1)^{i-k}\dfrac{2^i}{(i-k)!}\dfrac{(2n-2i)!}{((n-i)!)^2}
$$

$$
=\dfrac{(n!)^2}{k!}\sum_{i=k}^n (-1)^{i-k}\dfrac{2^i}{(i-k)!}\binom{2n-2i}{n-i}
$$

设 $m=n-k$，则原式

$$
=\dfrac{(n!)^22^k}{k!}\sum_{i=0}^m\dfrac{(-2)^i}{i!}\binom{2m-2i}{m-i}
$$

设：

$$
A(x)=\sum_{i=0}^\infty \dfrac{(-2)^i}{i!} x^i,B(x)=\sum_{i=0}^\infty \binom{2i}{i} x^i
$$

则答案是：

$$
\dfrac{(n!)^22^k}{k!}[x^{m}]A(x)\times B(x)
$$

注意到 $A(x)=e^{-2x}$，但 $B(x)$ 好像不是那么显然。考虑到卡特兰数生成函数：

$$
C(x)=\dfrac{\sqrt{1-4x}}{2x}=\sum_{i=0}^{\infty} \dfrac{\binom{2i}{i}}{i+1}x^i
$$

平移一下，再求导，即：

$$
(C(x)\times x)'= \sum_{i=0}^{\infty} \binom{2i}{i}x^i=\dfrac{1}{\sqrt{1-4x}}=B(x)
$$

所以答案是：

$$
\dfrac{(n!)^22^k}{k!}[x^{m}]\dfrac{e^{-2x}}{\sqrt{1-4x}}
$$

设 $F(x)=\dfrac{e^{-2x}}{\sqrt{1-4x}}$，考虑求他的系数。两边平方，将分母去掉可得：

$$
(1-4x)F^2=e^{-4x}
$$

两边求导：

$$
(1-4x)\times 2F\times F'-4F^2=-4e^{-4x}
$$

这时候左边仍然有卷积，还是不好做，所以考虑把右边的 $e^{-4x}$ 再带入原来的等式：

$$
(1-4x)\times 2F\times F'-4F^2=-4(1-4x)F^2
$$

消掉一个 $F$：

$$
(1-4x)\times 2F'-4F=-4(1-4x)F
$$

移项之后对比系数可以得到：

$$
f_0=1,f_1=0,f_i\times i=4(i-1)\times f_{i-1}+8f_{i-2}(i\ge 2)
$$

最后答案就是：

$$
\dfrac{(n!)^22^k}{k!}f_{n-k}
$$

```cpp
//Code By CXY07
#include<bits/stdc++.h>
using namespace std;

//#define FILE
#define int long long
#define file(FILENAME) freopen(FILENAME".in", "r", stdin), freopen(FILENAME".out", "w", stdout)
#define randint(l, r) (rand() % ((r) - (l) + 1) + (l))
#define LINE() cout << "LINE = " << __LINE__ << endl
#define debug(x) cout << #x << " = " << x << endl
#define abs(x) ((x) < 0 ? (-(x)) : (x))
#define popc(x) __builtin_popcount(x)
#define inv(x) qpow((x), mod - 2)
#define lowbit(x) ((x) & (-(x)))
#define ull unsigned long long
#define pii pair<int, int>
#define LL long long
#define mp make_pair
#define pb push_back
#define scd second
#define vec vector
#define fst first
#define endl '\n'

const int MAXN = 5e6 + 10;
const int INF = 2e9;
const double eps = 1e-6;
const double PI = acos(-1);
//const int mod = 1e9 + 7;
const int mod = 998244353;
//const int G = 3;
//const int base = 131;

int T, n, k, Ans;
int fac[MAXN], ifac[MAXN], Inv[MAXN], p2[MAXN], f[MAXN];

template<typename T> inline bool read(T &a) {
	a = 0; char c = getchar(); int f = 1;
	while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { a = a * 10 + (c ^ 48); c = getchar(); }
	return a *= f, true;
}

template<typename A, typename ...B>
inline bool read(A &x, B &...y) { return read(x) && read(y...); }

signed main () {
#ifdef FILE
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
#endif
	read(T);
	fac[0] = ifac[0] = Inv[1] = p2[0] = f[0] = 1, f[1] = 0;
	for(int i = 2; i < MAXN; ++i) {
		Inv[i] = Inv[mod % i] * (mod - mod / i) % mod;
		f[i] = (f[i - 1] * 4 * (i - 1) + f[i - 2] * 8) % mod * Inv[i] % mod;
	}
	for(int i = 1; i < MAXN; ++i) {
		fac[i] = fac[i - 1] * i % mod, ifac[i] = ifac[i - 1] * Inv[i] % mod;
		p2[i] = p2[i - 1] * 2 % mod;
	}
	while(T--) {
		read(n), read(k);
		Ans = fac[n] * fac[n] % mod * p2[k] % mod * ifac[k] % mod * f[n - k] % mod;
		printf("%lld\n", Ans);
	}
	return 0;
}
```


---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P4921)

~~七夕打卡圣地~~

## 题意

- 对于每个给定 $n$ $k$ 求恰好 $k$ 对情侣坐一排的情况数。

## Sol

> 组合意义天地灭，代数推导保平安。

~~尛神虎~~

考虑直接表示答案。

$ans_{n,k}=\dbinom{n}{k}\times P^k_n \times 2^k \times g_{n-k}$

其中 $\dbinom{n}{k}$ 表示选取 $k$ 对座位的组合，$P^k_n$ 表示选取 $k$ 对情侣的排列，$2^k$ 表示情侣的左右位置。

那么显然，这里 $g_{n-k}$ 可以看出表示共 $n-k$ 对情侣**都错开**的情况数。

我们考虑递推这个柿子。

首先 $g_0=1$，$g_1=0$。

考虑现在推 $g_i$。

分两种情况讨论。

考虑分别设两对情侣 $(a,b)$ $(c,d)$。

不妨让 $a$ 和 $c$ 坐一排。

#### $b$ 和 $d$ 坐一排

即为 $g_{i-2}$ 递推过来。

有贡献为 $8n(n-1)^2g_{i-2}$。

#### $b$ 和 $d$ 不坐一排

那么因为考虑 $g$ 为错排，不妨**假设 $b$ 和 $d$ 为情侣**，

即可以由 $g_{i-1}$ 转移过来。

有贡献为 $4n(n-1)g_{i-1}$。

那么可得 $g_i=4n(n-1)g_{i-1}+8n(n-1)^2g_{i-2}$。

预处理 $g$ 阶乘 逆元 即可。

预处理复杂度 $O(N)$。

询问复杂度 $O(T)$。

---

## 作者：BADFIVE (赞：1)

 **数据范围**: $1 \leq T \leq 2 \times10^5$ ， $1 \leq n \leq 5 \times 10^6$ ， $0 \leq k \leq n$   
**思路**:给定 $n,k$ ，求恰好有 $k$ 对情侣做一起的方案数据。   
**解决**:弱数据版用的是**二项式反演** ，本来以为是原版加个多项式就完了，而这道题的数据范围显示是不能这样做。   
那我们先考虑选出并坐在一起的 $k$ 对情侣 ，方案数为 $ \binom{n}{k}^2\times k!\times 2^k$   
$ \binom{n}{k}^2$ 表示为  $k$ 对情侣并选出 $k$ 行椅子的方案数。    
$k!$ 为 $k$ 对情侣排列顺序的方案数。   
$2^k$ 为每行情侣排列的方案数。   
设 $a_i$ 为 $i$ 对情侣都不坐在一排里的方案数。    
所以最后的答案就是: $a_i×2^{n-k}×(n-k)!×\binom{n}{k}^2×k!×2^k$   
当然，我们还要考虑一下 $a_i$ 的情况(分为两种):   
选择不是情侣的两个人，这样就会有 $2k×(2k-2)$ 种方案数。   
$1.$ 让他们成为情侣，那就剩 $k-1$ 个位置留个给他们，他们还可以任意相互交换位置，为 $2(k−1)a(k−2)$ 。  
$2.$ 不让他们成为情侣，那就会少 $2$ 个人，剩下的就是一个错排，为 $a(k-1)$ 。  
我们可以预处理 $g$ ，逆元就行了。   

**时间复杂度**:预处理为 $O(N)$ 。   
询问为 $O(T)$ 。   

---

## 作者：木xx木大 (赞：1)

[P4931 [MtOI2018]情侣？给我烧了！](https://www.luogu.com.cn/problem/P4931)

和 EI 巨佬的做法一样，但是写得更详细一些了。EI 的推导真是让我这样的数学菜鸡一脸懵\kk

设 $g_k$ 表示恰好有 $k$ 对情侣和睦的方案数， $f_k$ 表示 $k$ 对情侣全都不和睦的方案数。则有$g_i={n\choose i}^2i!2^if_{n-i}$

解释一下，$n$ 对情侣中选 $i$ 对，$n$ 排座位里选 $i$ 排安排这些情侣，每排男女可以互换位置。

把 $k\in[0,n]$ 的答案加起来就是全部的方案数，即
$$
\sum\limits_{i=0}^n{n\choose i}^2i!2^if_{n-i}=(2n)!\\
\sum\limits_{i=0}^n\frac{2^i}{i!}\frac{f_{n-i}}{(n-i)!^2}=\frac{(2n)!}{n!^2}
$$
设 $\frac{f_i}{i!^2}$ 的生成函数为 $F(x)$，则
$$
e^{2x}F(x)=\sum\limits_{i=0}^\infin {2i\choose i}x^i
$$
根据广义二项式定理有一个结论
$$
{n-\frac{1}{2}\choose n}=\frac{(n-\frac{1}{2})(n-1-\frac{1}{2})\dots\frac{1}{2}}{n!}=\frac{(2n-1)(2n-3)\dots1}{2^nn!}=\frac{2n!}{2^n2^nn!n!}=\frac{2n\choose n}{4^n}\\
$$
又因为
$$
{n\choose m}=\frac{n(n-1)\dots(n-m+1)}{m!}=(-1)^m\frac{-n(-n+1)\dots(-n+m-1)}{m!}=(-1)^m{-n+m-1\choose m}
$$
所以
$$
\sum\limits_{i=0}^\infin{2i\choose i}x^i=\sum\limits_{i=0}^\infin{i-\frac{1}{2}\choose i}4^ix^i=\sum\limits_{i=0}^\infin(-1)^i{-\frac{1}{2}\choose i}4^ix^i=(1-4x)^{-\frac{1}{2}}\\F(x)=\frac{e^{-2x}}{\sqrt{1-4x}}\\F(x)'=\frac{8xe^{-2x}}{(1-4x)^{\frac{3}{2}}}=\frac{8x}{1-4x}F(x)\\F(x)'=4xF(x)'+8xF(x)
$$

因为
$$
[x^n]F(x)'=(n+1)[x^{n+1}]F(x)\\ [x^n]xF(x)=[x^{n-1}]F(x)
$$
所以
$$
\frac{F_{n+1}}{n!(n+1)!}=\frac{4F_n}{n!(n-1)!}+\frac{8F_{n-1}}{(n-1)!^2}\\F_{n}=4n(n-1)F_{n-1}+8n(n-1)^2F_{n-2}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m,K;
	const int N=5e6+5,mo=998244353;
	int fac[N],inv[N],pw[N],f[N];
	ll C(int x,int y)
	{
		return 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;
	}
	void work()
	{
		f[0]=1,f[1]=0,pw[0]=fac[0]=inv[0]=inv[1]=1;
		for(int i=2;i<=5e6;i++)
			f[i]=(4ll*i%mo*(i-1)%mo*f[i-1]%mo+8ll*i%mo*(i-1)%mo*(i-1)%mo*f[i-2]%mo)%mo;
		for(int i=1;i<=5e6;i++)
			fac[i]=1ll*fac[i-1]*i%mo,pw[i]=1ll*pw[i-1]*2%mo;
		for(int i=2;i<=5e6;i++)
			inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;
		for(int i=2;i<=5e6;i++)
			inv[i]=1ll*inv[i-1]*inv[i]%mo;
		scanf("%d",&m);
		while(m--)
		{
			scanf("%d%d",&n,&K);
			printf("%lld\n",1ll*C(n,K)*C(n,K)%mo*fac[K]%mo*pw[K]%mo*f[n-K]%mo);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```



---

## 作者：FjswYuzu (赞：1)

考虑定义 $ans_i$ 为 $k=i$ 时的答案，$f_i$ 为强制 $i$ 对情侣全部错开的情况种数。答案表示：

$$
ans_i = f_{n-i} \times \dbinom{n}{i} \times 2^i \times n^{\underline{i}}
$$

解释：$f_{n-i}$ 一项定义如上，$\dbinom{n}{i}$ 是要在 $n$ 对情侣中选 $i$ 对匹配的方案数，$2^i$ 是因为每一对情侣都有两种坐法，$n^{\underline{i}}=A_{n}^i$ 是因为要在 $n$ 对位置里面选择 $i$ 个让情侣坐下。

考虑计算 $f_i$。可以近似看成「[错排问题](https://www.luogu.com.cn/blog/P6174/post-cuo-pai)」，尝试用递推的方式去求出，分类讨论新加入的不匹配的一堆情侣。

因为加入不合法，一定是两对情侣分别拆出来一个人进行匹配。假设现在在求 $f_i$，于是有：

- 若剩下的两个人匹配到一起了，我们还需要安排一对作为给他们，贡献即为 $(i-1) \times f_{i-2}$，注意可以交换位置，所以贡献还要乘上 $2$；   
- 否则，相当于一对匹配失败的情侣，我们在之后的匹配中保证他们不配对，方案数 $f_{i-1}$。

然后再考虑一下在 $2i$ 个人里面选不是一对情侣的方案数，即 $2i(2i-2)=4i(i-1)$。

至此推出递推式：

$$
f_i = 4i(i-1)(2(i-1) \times f_{i-2} + f_{i-1})
$$

预处理可以写成 $O(n)$ 或者 $O(n \log \bmod)$，但是因为开了 `__int128` $O(n \log \bmod)$ 会 T 爆，同时注意下面的代码需要开 O2 才能过。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<14,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=998244353;
LL QuickPow(LL n,LL p)
{
	LL base=n,ans=1;
	while(p)
	{
		if(p&1)	ans=ans*base%MOD;
		p>>=1;
		base=base*base%MOD;
	}
	return ans%MOD;
}
LL f[5000005],pw[5000005],fac[5000005],inv[5000005];
int main(){
	fac[0]=pw[0]=1;
	for(LL i=1;i<=5000000;++i)	pw[i]=pw[i-1]*2%MOD,fac[i]=fac[i-1]*i%MOD;
	inv[5000000]=QuickPow(fac[5000000],MOD-2);
	for(int i=4999999;~i;--i)	inv[i]=inv[i+1]*(i+1)%MOD;
	f[0]=1;
	for(LL i=2;i<=5000000;++i)	f[i]=4*i*(i-1)%MOD*(2*(i-1)*f[i-2]+f[i-1])%MOD;
	LL T;
	T=read();
	while(T-->0)
	{
		LL n=read(),k=read();
		write(fac[n]*inv[k]%MOD*inv[n-k]%MOD*fac[n]%MOD*inv[n-k]%MOD*f[n-k]%MOD*pw[k]%MOD);
		puts("");
	}
	return 0;
}
```

---

## 作者：逃离地球 (赞：1)

### 题意
把 $n$ 对情侣安排在 $n$ 行 $2$ 列的座位中，要求恰好有 $k$ 对情侣坐在一排中，问有多少种排法。询问数 $T\le2\times 10^5$，$k\le n\le5\times10^6$。

### 题解
先考虑选出并排列坐在一起的 $k$ 对情侣，方案数为 $\binom{n}{k}^2\times k!\times 2^k$，其中 $\binom{n}{k}^2$ 为选出 $k$ 对情侣并选出 $k$ 行椅子的方案数，$k!$ 为 $k$ 对情侣排列顺序的方案数，$2^k$ 为每行情侣排列的方案数。设 $f_i$ 为 $i$ 对情侣都不坐在一排里的方案数（不考虑顺序），则最终答案为 $f_i\times 2^{n-k}\times(n-k)!\times\binom{n}{k}^2\times k!\times 2^k$。

再考虑计算 $f_i$，在这 $i$ 对情侣中任选一对，设为 $(a,b)$。设 $a$ 与 $c$ 坐在一起，且 $c$ 的情侣为 $d$，则可分类讨论为两种情况：

- 第一种是 $b$ 和 $d$ 坐在一起，则方案数为剩余 $i-2$ 对情侣不坐一起的情况数，即 $f_{i-2}$；
- 第二种情况是 $b$ 和 $d$ 不坐一起，那么就可以把 $b$ 和 $d$ 也看作一对不能坐一起的情侣，情况数就是剩余 $i-2$ 对情侣和 $b$ 和 $d$ 这对“情侣“排列的方案数，即 $f_{i-1}$。

则 $f_i=2(n-1)\times(f_{i-1}+f_{i-2})$，其中 $2(n-1)$ 为选出 $c$ 的方案数。则可以用递推预处理出 $f$ 数组和组合数、2 的幂等，然后 $O(1)$ 处理询问即可。

### 注意

$f(0)=1,f(1)=0$

---

## 作者：TianTian2008 (赞：0)

选出 $k$ 对情侣，强制钦定他们和睦，方案数 $\binom nk$。选出 $k$ 排座位，让和睦的情侣坐在这，方案数 $\binom nk$。$k$ 对和睦情侣，男女之间可以互换座位，方案数 $2^k$。$k$ 对和睦情侣，不同对之间可以随意排列座位，方案数 $k!$。剩下的 $n-k$ 对情侣要求没有任何一对和睦，不妨记方案数为 $f_{n-k}$。则答案即为 $\binom nk^22^kk!f_{n-k}$。

接下来我们只需要求出 $f$ 就行了。考虑容斥，强制钦定有 $i$ 对情侣和睦，方案数与上述同理，有 $f_n=(2n)!-\sum\limits_{i=1}^n\binom ni^22^ii!f_{n-i}$。可以直接分治 FFT 做到 $O(n\log^2n)$，但 $n\le5\times10^6$，这肯定是过不了的。

所以我们考虑求出与其相关的生成函数的封闭形式。把刚才的式子移项再合并一下有 $\sum\limits_{i=0}^n\binom ni^22^ii!f_{n-i}=(2n)!$，展开组合数再变换一下得 $\sum\limits_{i=0}^n\frac{2^i}{i!}\frac{f_{n-i}}{(n-i)!^2}=\frac{(2n)!}{n!^2}=\binom{2n}n$，显然是卷积形式，可以得出 $e^{2x}F(x)=(1-4x)^{-\frac12}$，其中 $F(x)=\sum\limits_{i=0}^\infty\frac{f_i}{i!^2}$。然后多项式求逆容易做到 $O(n\log n)$，但是由于 FFT 的大常数，这很可能也是过不了的。

那么有没有办法再优化呢？一般来说我们都是把数列写成生成函数，求出封闭形式后用多项式算法快速计算，但这里我们可以从封闭形式反推出数列的性质。具体来说，因为有 $F(x)=(1-4x)^{-\frac12}e^{-2x}$，所以 $F'(x)=\frac{8x}{1-4x}(1-4x)^{-\frac12}e^{-2x}=\frac{8x}{1-4x}F(x)$，移项得 $(1-4x)F'(x)=8xF(x)$，展开得 $(n+1)F_{n+1}-4nF_n=8F_{n-1}$，也即 $F_n=\frac{4(n-1)}{n}F_{n-1}+\frac8{n}F_{n-2}$，可以直接 $O(n)$ 递推了。

```cpp
#include <iostream>
#include <cstdio>
#define N 5000000
#define mod 998244353
using namespace std;
typedef long long ll;
ll t,n,k,pw[5000001],fac[5000001],inv[5000001],d[5000001];
ll ksm(ll x,ll y) {
	ll res=1;
	while(y) {
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
inline ll binom(ll n,ll m) {
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
int main() {
	pw[0]=1;
	for(int i=1;i<=N;++i) pw[i]=(pw[i-1]<<1)%mod;
	fac[0]=1;
	for(int i=1;i<=N;++i) fac[i]=fac[i-1]*i%mod;
	inv[N]=ksm(fac[N],mod-2);
	for(int i=N;i>=1;--i) inv[i-1]=inv[i]*i%mod;
	d[0]=1;
	for(int i=2;i<=N;++i) d[i]=(d[i-1]*(i-1<<2)+(d[i-2]<<3))%mod*ksm(i,mod-2)%mod;
	for(int i=0;i<=N;++i) d[i]=d[i]*fac[i]%mod*fac[i]%mod; 
	scanf("%lld",&t);
	while(t--) {
		scanf("%lld%lld",&n,&k);
		printf("%lld\n",(d[n-k]*binom(n,k)%mod*binom(n,k)%mod*fac[k]%mod*pw[k]%mod+mod)%mod);
	}
	return 0;
}
```

---

## 作者：juju527 (赞：0)

考虑组合数~~乱来~~

从$n$排座位中选$k$排，从$n$对情侣中选$k$对，方案数$\tbinom{n}{k}\tbinom{n}{k}\times k!\times2^k$

我们已经钦定好了$k$对坐一起的情侣，剩下的问题变为计算剩下$n-k$对情侣全都没坐在同一排的方案数

我们容易发现这和错排的定义很像，但它们有些许不同

我们从问题中抽出一个小模型来考虑

![](https://cdn.luogu.com.cn/upload/image_hosting/swrbrgwo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

上图中一列的两点表示一对情侣，一条边表示边上两点坐在一排上，蓝边不能连，红边能连

容易发现，这与错排数及其类似，把错排中的编号和值变成$2n$个点，那么与这个模型只有同行之间不能连一个区别

若我们称上述模型为一个"非和睦图"

设$f_n$表示$2n$个点组成非和睦图的方案数，**这里的方案数未考虑编号顺序**

考虑类似错排数推出$f_n$的递推式

随意挑一个点$u$，它有$2(n-1)$个点可以连接，若其连点$v$

讨论$v$所在列另一节点$v'$归属

第一种情况，$v'$与$u'$相连，那么剩下的问题是$n-2$对点的“非和睦图”方案数

第二种情况，$v'$不与$u'$相连，我们考虑在剩下的问题中将$v'$与$u'$置与一列上，即为$n-1$对点的"非和睦图"方案数

综上$f_n=2(n-1)(f_{n-1}+f_{n-2})$

这一部分答案为$f_{n-k}(n-k)!2^{n-k}$

故总答案为$2^n\tbinom{n}{k}\tbinom{n}{k}\times k!f_{n-k}(n-k)!$

代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=5e6+5,mod=998244353;
namespace io{
    #define DEBUG 1
    #define isdigit(x) (x >= '0' && x <= '9')
    const int MAXSIZE = 1 << 20;
    inline char gc() {
        #if DEBUG
        return getchar();
        #endif
        static char buf[MAXSIZE], *p1 = buf + MAXSIZE, *p2 = buf + MAXSIZE;
        if(p1 == p2) {
            p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
        }
        return p1 == p2 ? -1 : *p1++;
    }
    inline bool blank(char ch) {
        return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
    }
    template<class T> inline void read(T &x) {
        register double tmp = 1;
        register bool sign = 0;
        x = 0;
        register char ch = gc();
        for(; !isdigit(ch); ch = gc()) {
            if(ch == '-') {
                sign = 1;
            }
        }
        for(; isdigit(ch); ch = gc()) {
            x = (x << 1) + (x << 3) + (ch ^ 48);
        }
        if(ch == '.') {
            for(ch = gc(); isdigit(ch); ch = gc()) {
                tmp /= 10.0, x += tmp * (ch - 48);
            }
        }
        if(sign){
            x = -x;
        }
    }
    inline void read(char *s) {
        register char ch = gc();
        for(; blank(ch); ch = gc());
        for(; !blank(ch); ch = gc()) {
            *s++ = ch;
        }
        *s = 0;
    }
    inline void read(char &c) {
        for(c = gc(); blank(c); c = gc());
    }
    inline void push(const char &c) {
        char pbuf[MAXSIZE], *pp = pbuf;
        if (pp - pbuf == MAXSIZE) {
            fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
        }
        *pp++ = c;
    }
    template<class T> inline void write(T x) {
        static T sta[35];
        T top = 0;
        do {
            sta[top++] = x % 10;
            x /= 10;
        }while(x);
        #if DEBUG
        while(top) {
            putchar(sta[--top] + '0');
        }
        return;
        #endif
        while(top) {
            push(sta[--top] + '0');
        }
    }
    template<class T> inline void write(T x,char lastChar) {
        write(x);
        putchar(lastChar);
    }
}
using namespace io;
int f[maxn];
int pw[maxn],iv[maxn],p2[maxn];
inline int power(int x,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*x%mod;
		x=1ll*x*x%mod;
		b>>=1;
	}
	return ans;
}
int C(int n,int m){
	return 1ll*pw[n]*iv[m]%mod*1ll*iv[n-m]%mod;
}
int main(){
//    freopen("friends.in","r",stdin);
//    freopen("friends.out","w",stdout);
	int T;
	read(T);
	f[0]=1;f[1]=0;f[2]=2;
	pw[0]=1;iv[0]=1;
	p2[0]=1;
	for(register int i=1;i<=5e6;i++){
		f[i]=2ll*(i-1)%mod*(f[i-1]+f[i-2])%mod;
		pw[i]=1ll*pw[i-1]*i%mod;
		iv[i]=1ll*iv[i-1]*power(i,mod-2)%mod;
		p2[i]=2ll*p2[i-1]%mod;
	}
	while(T--){
	   	int n,k;
		read(n);read(k);
		long long pw2=p2[n],ans;
		ans=1ll*C(n,k)*C(n,k)%mod*1ll*pw[k]%mod*pw2%mod*f[n-k]%mod*1ll*pw[n-k]%mod;
		write(ans,'\n');
//		cerr<<clock()*1.0/CLOCKS_PER_SEC<<endl;
	}
	return 0;
}

```

---


# 有标号荒漠计数

## 题目背景

众所周知 仙人掌计数 是一种很简单的计数，所以我们要加强它.jpg

## 题目描述

仙人掌是一张无向连通图，在一个仙人掌上，任意一条边至多只会出现在一个环上。同时，在本题定义的仙人掌中，仙人掌应当**无重边**、**无自环**。  
荒漠是一张无向图，一个荒漠的每个极大连通分量都是一个仙人掌

---
给出一个整数 $n$ ，请求出有多少种不同的含有 $n$ 个点的荒漠。（点有标号）

由于答案可能太大，您只需要将您的结果对 $998244353$ 取模后输出即可。

## 说明/提示

对于样例，所有可能的情况如下：  
![Picture](https://s2.ax1x.com/2019/06/13/Vf6SGF.png)  
可以发现，不存在更多的荒漠

---
对于 $30\%$ 的数据： $n\leqslant5000$  
对于 $100\%$ 的数据： $3\leqslant n\leqslant100000$

## 样例 #1

### 输入

```
3```

### 输出

```
8```

# 题解

## 作者：NaCly_Fish (赞：26)

update on 2022.7.7：本题解全面更新，改为更优的做法，并给出一个比较清晰的推导。
****
题目要求「荒漠」的数量，而这个只是由若干个「**无根**仙人掌」连通块组成的。可以先求出有标号**有根**仙人掌的数量，并设其指数型生成函数（EGF）为 $F(x)$。

考虑有 $i$ 个仙人掌的根连成一条链，方案的 EGF 自然是 $F(x)^i$。然后将这条链首尾分别与新根相连，对于 $i=1$ 方案数仍然是 $F(x)$；但对于 $i\geq 2$，与根连接后就形成了环，但链有正反而环没有，故方案数为 $F(x)^i/2$。

新根可以按上述方式接若干互相无序的环（或点），由此可以得到方程：
$$F(x)=x\exp \left( F(x)+\frac 12\sum_{i\ge 2} F(x)^i\right)$$
化简即得
$$F(x)=x \exp \frac{2F(x)-F(x)^2}{2-2F(x)}$$
设有标号**无根**仙人掌数量的 EGF 为 $G(x)$。从无根变为有根就是从所有节点中随便钦定一个作根，故 $F(x)=xG'(x)$。  
直接牛顿迭代提取 $\exp G(x)$ 的系数可以做到 $\Theta(n \log n)$ 的时间复杂度，但写起来比较复杂且不够优秀。

但这个形式还不便于我们进一步优化，有没有办法避开 $G'(x)$，直接建立 $G(x)$ 和 $F(x)$ 的关系呢？用一些组合意义的技巧可以求解，不过这里有一种（不知是否通用）的代数方法。
****
最理想的情况当然是 $G(x)=H(F(x))$，而且 $H(x)$ 的形式最好比较简单。对两边求导后同乘 $x$ 得

$$F(x)=xF'(x)H'(F(x))$$
设
$$B'(x)= \frac{2x-x^2}{2-2x}$$
（这里设出 $B'$ 是因为后面还要用 $B$，写起来方便）则 $F(x)$ 的方程就是
$$F(x)=x\exp B'(F(x))$$
求导得
$$F'(x)=\exp B'(F(x))+xB''(F(x))F'(x)\exp B'(F(x))$$
$$xF'(x)=F(x)+xB''(F(x))F'(x)F(x)$$
$$xF'(x)(1-B''(F(x))F(x))=F(x)$$
此时可以直接把 $xF'(x)$ 替换为不含 $F(x)$ 的项，即
$$\frac{F(x)}{H'(F(x))}(1-B''(F(x))F(x))=F(x)$$
发现了什么？把 $F(x)$ 全都换元为 $z$ 就可以求解了：
$$H'(z)=1-zB''(z)$$
确定一下常数项就可以得到
$$H(z)=z+B(z)-zB'(z)$$
****
障碍完美清除，现在就可以使用 Lagrange 反演：
$$[x^n]\text e^{H(F(x))}=\frac 1n [x^{n-1}]H'(x) \text e^{H(x)}\left(\frac{x}{F^{\langle -1 \rangle}(x)} \right)^n$$

这个式子有点长，我们分三部分来看。由 $F(x)$ 的原方程可得
$$F^{\langle -1 \rangle}(x)= x \exp \frac{x^2-2x}{2-2x}$$
这个东西并不是代数的，但其特殊性质使得下式是微分有限的：
$$\left(\frac{x}{F^{\langle -1 \rangle}(x)}\right)^n =  \exp n\frac{2x-x^2}{2-2x}$$
再分析 $\text e^{H(x)}$，用一点简单的高数知识可以求出
$$B(x)=\frac 14(-2x+x^2-2\ln(1-x))$$
再代入计算 $\text e^{H(x)}$：  
$$\text e^{H(x)}=\text e^{x-xB'(x)}\exp\left({\frac{-2x+x^2}{4}}\right)\frac{1}{\sqrt{1-x}}$$
其中 $B'(x)$ 是代数的，$\text e^{x-xB'(x)}$ 是微分有限的，其余部分也微分有限，故 $\text e^{H(x)}$ 微分有限。

最后 $H'(x)$ 这一项就很简单了，它是代数的，显然也是微分有限的。
****
综上，提取 $\text e^{H(F(x))}$ 的一项系数可以做到 $\Theta(n)$ 或 $\Theta(\sqrt n \log n)$ 的时间复杂度。具体如下：

设
$$f(x)=\exp\left((n-x)\frac{2x-x^2}{2-2x}+\frac{2x+x^2}{4} \right)$$
对两遍求导，可以化简出
$$2(1-x)^2f'(x)=((2n+1)-(2n+5)x+(n+4)x^2-x^3)f(x)$$
类似地设
$$g(x)= (1-x)^{-5/2}f(x)$$
可以得到
$$2(1-x)^2g'(x)=((2n+6)-(2n+10)x+(n+4)x^2-x^3)g(x)$$
这是一个四阶一次的整式递推，最后的答案就是：
$$n![x^n](1-3x+2x^2-x^3/2)g(x)$$
[看代码点这里](https://www.luogu.com.cn/paste/mqv5nfei)
****
ps：本文有参考 [Daniel13265](https://www.luogu.com.cn/user/55251) 早期提供的题解，但推导方法上有许多不同。

---

## 作者：Daniel13265 (赞：16)

都 2022 了都还没有看到有人给 $O(n)$ 时空复杂度的做法，所以来补一个。

---

> 求 $n$ 个点的有标号荒漠个数。$n\le10^5$。

为避免混淆，本文形式幂级数中未定元用 $z$ 表示。

设

- 荒漠的 EGF 为 $A$；
- 无根仙人掌的 EGF 为 $C$；
- 有根仙人掌的 EGF 为 $C^\bullet$；
- 将唯一的 $2$ 个点的点双连通分量看作二元环，环的 EGF 为 $B$。

另外两个辅助形式幂级数

- 可重集
  $$
  E(z)=\sum_{i=0}^{\infty}\frac{z^i}{i!}.
  $$
- 单元
  $$
  X(z)=z.
  $$

依序考察

1. $A$ 与 $C$ 的关系。荒漠是无根仙人掌的可重集，因此
   $$
   A=E\circ C.
   $$
   
2. $C$ 与 $C^\bullet$ 的关系。对仙人掌建立圆方树：仙人掌上的每一个点对应一个圆点，每个点双连通分量（环）对应一个方点，方点连接其对应的点双连通分量中所有点对应的圆点，得到一棵树。这棵树的每一条边都连接一个圆点与一个方点，且叶结点均为圆点。从而，其直径中点必定是一个点，因为其长度一定是偶数。现给圆方树任意定根，从两个角度思考：

   - 根为圆点还是方点。若根为圆点，则此方案对应一个有根仙人掌；若根为方点，则此方案对应排列形成环的若干有根仙人掌。
   - 根是否为圆方树直径的中点。若根为圆方树直径的中点，则此方案对应一个无根仙人掌；若根不圆方树直径的中点，则此方案对应排列形成有一个特定点的环的若干有根仙人掌（找到往直径方向的边，则有根仙人掌按照围绕方点对应的环排列，且圆点为特定点）。

   容易发现以上两种对应方式均为一一对应，故有恒等式
   $$
   C^\bullet+B\circ C^\bullet=C+\left(XB'\right)\circ C^\bullet.
   $$
   
   整理得
   $$
   C=\left(X+B-XB'\right)\circ C^\bullet.
   $$
   
3. $C^\bullet$ 的递归关系。去掉以圆点为根的圆方树的根，得到以方点为根的圆方树的可重集，这些圆方树的根连接若干按照去掉特定点的环排列以圆点为根的圆方树，于是
   $$
   C^\bullet=X\left(E\circ B'\circ C^\bullet\right).
   $$
   
   即
   $$
   C^\bullet\circ\frac{X}{E\circ B'}=X.
   $$

综合以上式子
$$
\boxed{A\circ\frac{X}{E\circ B'}=E\circ\left(X+B-XB'\right).}
$$


剩下的就是计算。使用扩展拉格朗日反演
$$
\begin{aligned}
n!\left[z^n\right]A&=(n-1)!\left[z^{n-1}\right]\left(1+B'-B'-XB''\right)\left[E\circ(X+B-XB')\right]\left(E\circ B'\right)^n\\
&=(n-1)!\left[z^{n-1}\right]\left(1-zB''(z)\right)\exp\left(z+B(z)-zB'(z)+nB'(z)\right).
\end{aligned}
$$
令
$$
T(z)=\exp\left(z+B(z)-zB'(z)+nB'(z)\right).
$$
求导知
$$
T'(z)=\left(1-zB''(z)+nB''(z)\right)T(z).
$$
计算有

$$
\begin{gathered}
B(z)=\frac{z^2}2+\sum_{i=3}^{\infty}\frac{(i-1)!}{2i!}z^i=\frac{-2z+z^2-2\ln(1-z)}4.\\
B'(z)=\frac{2z-z^2}{2-2z}.\\
B''(z)=\frac{2-2z+z^2}{2(1-z)^2}.
\end{gathered}
$$

带入化简
$$
T'(z)=\frac{(2n+2)-(2n+6)z+(n+4)z^2-z^3}{2(1-z)^2}T(z).
$$

容易在 $O(n)$ 时空复杂度内递推求得 $T$ 的最低 $n$ 项系数，所以原问题可以在 $O(n)$ 的时空复杂度内解决。


---

## 作者：lhm_ (赞：11)

因为是有标号计数，考虑用指数型生成函数来解决。

设有标号荒漠的生成函数为 $F(x)$，有标号仙人掌的生成函数为 $f(x)$，因为荒漠是仙人掌所组成的集合，得：
$$
F(x) = \exp (f(x))
$$
解决有标号仙人掌的计数问题后，就能解决有标号荒漠的计数问题。

先在仙人掌上确定一点来考虑，和该点相邻的边有在环上和不在环上两种情况，即与该点相邻的元素为独立边和环。独立边可看作单独的一个仙人掌，得独立边的生成函数为 $f(x)$。环的大小至少为 $3$，环上每个点也都对应单独的一个仙人掌，正方向反方向都会计算一遍，所以要除 $2$，得环的生成函数为 $\sum\limits_{i \geqslant 2 } \frac{f^i(x)}{2}$。

该点相邻的所有元素可以看作一个集合，同时还要考虑确定的那个点，得：
$$
f(x) = x \exp(f(x) + \sum_{i \geqslant 2 } \frac{f^i(x)}{2}) = x \exp(\frac{f^2(x) - 2f(x)}{2f(x)-2})
$$
通过牛顿迭代来求解。设已经求得 $f_0(x)$，满足 $f_0(x) \equiv f(x) \pmod{x^n}$，设 $g(f(x))= x \exp(\frac{f^2(x) - 2f(x)}{2f(x)-2}) - f(x),h(x) = x \exp(\frac{f_0^2(x) - 2f_0(x)}{2f_0(x)-2})$，得：
$$
\begin{aligned}	f(x) & \equiv f_0(x) - \frac{g(f_0(x))}{{g}'(f_0(x))} \pmod{x^{2n}} \\	& \equiv f_0(x) - \frac{h(x)-f_0(x)}{h(x){(\frac{f_0^2(x) - 2f_0(x)}{2f_0(x)-2})}'-1} \pmod{x^{2n}} \\	& \equiv f_0(x) - \frac{2h(x)-2f_0(x)}{h(x)(\frac{1}{(f_0(x)-1)^2}+1)-2} \pmod{x^{2n}}\end{aligned}
$$
因为之前的推导是确定了仙人掌上的一个点，所以对于 $n$ 个点的仙人掌，一个方案会计算 $n$ 次，要除以 $n$。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 800010
#define P 998244353
#define G 3
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n;
ll rev[maxn],f[maxn],g[maxn],fac[maxn],iv[maxn],w[22][maxn];
ll qp(ll x,ll y)
{
    ll v=1;
    while(y)
    {
        if(y&1) v=v*x%P;
        x=x*x%P,y>>=1;
    }
    return v;
}
int calc(int n)
{
    int lim=1;
    while(lim<=n) lim<<=1;
    for(int i=0;i<lim;++i)
        rev[i]=(rev[i>>1]>>1)|((i&1)?lim>>1:0);
    return lim;
}
void NTT(ll *a,int lim,int type)
{
    for(int i=0;i<lim;++i)
        if(i<rev[i])
            swap(a[i],a[rev[i]]);
    for(int len=1,t=1;len<lim;len<<=1,++t)
    {
        for(int i=0;i<lim;i+=len<<1)
        {
            for(int j=0;j<len;++j)
            {
                ll x=a[i+j],y=w[t][j]*a[i+j+len]%P;
                a[i+j]=(x+y)%P,a[i+j+len]=(x-y+P)%P;
            }
        }
    }
    if(type==1) return;
    ll inv=qp(lim,P-2);
    for(int i=0;i<lim;++i) a[i]=a[i]*inv%P;
    reverse(a+1,a+lim);
}
void Inv(int deg,ll *a,ll *b)
{
    static ll t[maxn];
    if(deg==1)
    {
        b[0]=qp(a[0],P-2);
        return;
    }
    Inv((deg+1)>>1,a,b);
    int lim=calc(deg<<1);
    for(int i=0;i<deg;++i) t[i]=a[i];
    for(int i=deg;i<lim;++i) t[i]=b[i]=0;
    NTT(t,lim,1),NTT(b,lim,1);
    for(int i=0;i<lim;++i) b[i]=b[i]*(2-t[i]*b[i]%P+P)%P;
    NTT(b,lim,-1);
    for(int i=deg;i<lim;++i) b[i]=0;
}
void Ln(int deg,ll *a,ll *b)
{
    static ll inva[maxn],dera[maxn];
    Inv(deg,a,inva);
    for(int i=0;i<deg-1;++i) dera[i]=a[i+1]*(i+1)%P;
    dera[deg-1]=0;
    int lim=calc(deg<<1);
    for(int i=deg;i<lim;++i) dera[i]=inva[i]=0;
    NTT(dera,lim,1),NTT(inva,lim,1);
    for(int i=0;i<lim;++i) b[i]=dera[i]*inva[i]%P;
    NTT(b,lim,-1);
    for(int i=deg-1;i>=1;--i) b[i]=b[i-1]*qp(i,P-2)%P;
    b[0]=0;
    for(int i=deg;i<lim;++i) b[i]=0;
}
void Exp(int deg,ll *a,ll *b)
{
    static ll t[maxn],lnb[maxn];
    if(deg==1)
    {
        b[0]=1;
        return;
    }
    Exp((deg+1)>>1,a,b),Ln(deg,b,lnb);
    int lim=calc(deg<<1);
    for(int i=0;i<deg;++i) t[i]=(a[i]-lnb[i]+P)%P;
    for(int i=deg;i<lim;++i) t[i]=b[i]=0;
    NTT(t,lim,1),NTT(b,lim,1);
    for(int i=0;i<lim;++i) b[i]=b[i]*(1+t[i])%P;
    NTT(b,lim,-1);
    for(int i=deg;i<lim;++i) b[i]=0;
}
void work(int deg,ll *f)
{
    static ll h[maxn],t1[maxn],t2[maxn],t3[maxn];
    if(deg==1)
    {
        f[0]=0;
        return;
    }
    work((deg+1)>>1,f);
    int lim=calc(deg<<1);
    for(int i=0;i<deg;++i) t1[i]=f[i],t2[i]=f[i]*2;
    NTT(t1,lim,1);
    for(int i=0;i<lim;++i) t1[i]=(t1[i]*t1[i]-2*t1[i]+P)%P;
    t2[0]-=2,Inv(deg,t2,t3),NTT(t3,lim,1);
    for(int i=0;i<lim;++i) t3[i]=t1[i]*t3[i]%P,t1[i]=t1[i]+1;
    NTT(t3,lim,-1),Exp(deg,t3,h),NTT(t1,lim,-1),Inv(deg,t1,t2);
    for(int i=deg-1;i>=1;--i) h[i]=h[i-1];
    h[0]=0;
    for(int i=0;i<deg;++i) t1[i]=(2*h[i]-2*f[i]+P)%P;
    t2[0]++,NTT(t2,lim,1),NTT(h,lim,1);
    for(int i=0;i<lim;++i) t2[i]=t2[i]*h[i]%P;
    NTT(t2,lim,-1),t2[0]-=2,Inv(deg,t2,t3),NTT(t1,lim,1),NTT(t3,lim,1);
    for(int i=0;i<lim;++i) t1[i]=t1[i]*t3[i]%P;
    NTT(t1,lim,-1);
    for(int i=0;i<deg;++i) f[i]=(f[i]-t1[i]+P)%P;
    for(int i=deg;i<lim;++i) f[i]=0;
}
void init()
{
    fac[0]=fac[1]=iv[1]=1;
    for(int i=2;i<=n;++i)
        fac[i]=fac[i-1]*i%P,iv[i]=(P-P/i)*iv[P%i]%P;
    for(int i=1;i<=19;++i) w[i][0]=1,w[i][1]=qp(G,(P-1)/(1<<i));
    for(int i=1;i<=19;++i)
        for(int j=2;j<1<<i;++j)
            w[i][j]=w[i][j-1]*w[i][1]%P;
}
int main()
{
    read(n),init(),work(n+1,f);
    for(int i=0;i<=n;++i) f[i]=f[i]*iv[i]%P;
    Exp(n+1,f,g),printf("%lld",g[n]*fac[n]%P);
	return 0;
}
```

---

## 作者：Great_Influence (赞：8)

仙人掌计数后再套一个 $exp$ 就完事了。

仙人掌计数可以参考[这篇](https://www.luogu.org/blog/user7035/loj-161-xian-ren-zhang-ji-shuo)。

代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

void file()
{
	FILE*DSD=freopen("a.in","r",stdin);
	FILE*CSC=freopen("a.out","w",stdout);
}

const int MAXN=1<<21;

namespace poly
{
	const int mod=998244353,gen=3;
	
	static int g[23][MAXN],iv[MAXN];

	inline int power(int u,int v)
	{
		register int sm=1;
		for(;v;v>>=1,u=(uint64)u*u%mod)if(v&1)
			sm=(uint64)sm*u%mod;
		return sm;
	}

	inline void predone()
	{
		Rep(i,1,21)
		{
			g[i][0]=1,g[i][1]=power(gen,(mod-1)>>i);
			Rep(j,2,4e5)g[i][j]=(ll)g[i][j-1]*g[i][1]%mod;
		}
		iv[1]=1;
		Rep(i,2,4e5)iv[i]=mod-(uint64)mod/i*iv[mod%i]%mod;
	}

	static int Len,rev[MAXN];

	inline void calrev()
	{
		int II=log(Len)/log(2)-1;
		Rep(i,1,Len-1)rev[i]=rev[i>>1]>>1|(i&1)<<II;
	}

	inline int ad(int u,int v){return(u+=v)>=mod?u-mod:u;}

	inline void NTT(int*F,int typ)
	{
		Rep(i,1,Len-1)if(i<rev[i])swap(*(F+i),*(F+*(rev+i)));
		for(register int i=2,ii=1,t=1;i<=Len;i<<=1,ii<<=1,++t)
		{
			for(register int j=0;j<Len;j+=i)
			{
				rep(k,0,ii)
				{
					register int tt=(uint64)*(F+j+k+ii)*g[t][k]%mod;
					*(F+j+k+ii)=ad(*(F+j+k),mod-tt);
					*(F+j+k)=ad(*(F+j+k),tt);
				}
			}
		}
		if(typ==-1)
		{
			reverse(F+1,F+Len);
			register uint64 invn=power(Len,mod-2);
			rep(i,0,Len)*(F+i)=invn**(F+i)%mod;
		}
	}

	static int X[MAXN],Y[MAXN],Iv[MAXN];

	inline void mul(int *a,int *b,int *c,int lenl,int lenr)
	{
		if((ll)lenl*lenr<=300)
		{
			memset(X,0,sizeof(int)*(lenl+lenr+1));
			Rep(i,0,lenl)Rep(j,0,lenr)
				X[i+j]=(X[i+j]+(ll)a[i]*b[j])%mod;
			Rep(i,0,lenl+lenr)c[i]=X[i];
			return;
		}
		for(Len=2;Len<=lenl+lenr;Len<<=1);
		calrev();
		memcpy(X,a,sizeof(int)*(lenl+1));
		memcpy(Y,b,sizeof(int)*(lenr+1));
		rep(i,lenl+1,Len)X[i]=0;
		rep(i,lenr+1,Len)Y[i]=0;
		NTT(X,1),NTT(Y,1);
		rep(i,0,Len)X[i]=(ll)X[i]*Y[i]%mod;
		NTT(X,-1);
		memcpy(c,X,sizeof(int)*(lenl+lenr+1));
		rep(i,lenl+lenr+1,Len)c[i]=0;
	}

	inline void Inv(int*F,int*G,int ln)
	{
		Iv[0]=power(F[0],mod-2);
		for(register int Ln=2;Ln>>1<=ln;Ln<<=1)
		{
			rep(i,0,min(Ln,ln+1))X[i]=F[i];
			rep(i,0,Ln)Y[i]=0;
			rep(i,0,(Ln>>1))Y[i]=Iv[i];
			Len=Ln,calrev();
			NTT(X,1),NTT(Y,1);
			rep(i,0,Ln)X[i]=(uint64)X[i]*Y[i]%mod;
			NTT(X,-1);
			rep(i,0,(Ln>>1))X[i]=0;
			NTT(X,1);
			rep(i,0,Ln)X[i]=(uint64)X[i]*Y[i]%mod;
			NTT(X,-1);
			rep(i,(Ln>>1),Ln)Iv[i]=mod-X[i];
		}
		memcpy(G,Iv,sizeof(int)*(ln+1));
	}

	static int ExX[MAXN],ExY[MAXN],Op[MAXN];

	inline void Deriv(int*F,int*G,int ln)
	{Rep(i,1,ln)G[i-1]=(uint64)F[i]*i%mod;G[ln]=0;}

	inline void Inter(int*F,int*G,int ln)
	{Repe(i,ln,1)G[i]=(uint64)F[i-1]*iv[i]%mod;G[0]=0;}

	static int LnX[MAXN];

	inline void Ln(int*F,int*G,int ln)
	{
		Deriv(F,LnX,ln),Inv(F,G,ln);
		for(Len=2;Len<=ln<<1;Len<<=1);
		rep(i,ln+1,Len)LnX[i]=G[i]=0;
		calrev();
		NTT(LnX,1),NTT(G,1);
		rep(i,0,Len)G[i]=(uint64)G[i]*LnX[i]%mod;
		NTT(G,-1);
		Inter(G,G,ln);
	}

	inline void Exp(int *F,int *H,int *G,int ln)
	{
		int Lx=ln+1,Hf=(Lx>>1)-1;
		Op[Hf]=0;
		memcpy(Op,H,sizeof(int)*Hf);
		rep(i,0,Hf)Op[Hf]=(Op[Hf]+(ll)F[i+1]
			*(i+1)%mod*H[Hf-1-i]%mod)%mod;
		Op[Hf]=(ll)Op[Hf]*iv[Hf]%mod;
		memset(Op+(Lx>>1),0,sizeof(int)*Lx/2);
		Ln(Op,ExX,Lx);
		rep(i,0,Lx>>1)ExX[i]=ad(F[i+(Lx>>1)],mod-ExX[i+(Lx>>1)]);
		memcpy(ExY,Op,sizeof(int)*Lx/2);
		memset(ExX+(Lx>>1),0,sizeof(int)*Lx/2);
		memset(ExY+(Lx>>1),0,sizeof(int)*Lx/2);
		Len=Lx;
		calrev();
		NTT(ExY,1),NTT(ExX,1);
		rep(i,0,Len)ExX[i]=(ll)ExX[i]*ExY[i]%mod;
		NTT(ExX,-1);
		memcpy(Op+Len/2,ExX,sizeof(int)*Lx/2);
		memcpy(G,Op,sizeof(int)*ln);
	}

	void cdq_Exp(int*a,int*F,int l,int r)
	{
		if(l==r)
		{
			if(!l)F[l]=1;
			else F[l]=(ll)F[l]*iv[l]%mod;
			return;
		}
		int md=(l+r)>>1;cdq_Exp(a,F,l,md);
		for(Len=2;Len<=r-l;Len<<=1);
		calrev();
		memset(X,0,sizeof(int)*Len);
		memset(Y,0,sizeof(int)*Len);
		memcpy(X,F+l,sizeof(int)*(md-l+1));
		memcpy(Y,a,sizeof(int)*(r-l));
		NTT(X,1),NTT(Y,1);
		rep(i,0,Len)X[i]=(ll)X[i]*Y[i]%mod;
		NTT(X,-1);
		Rep(i,md+1,r)F[i]=ad(F[i],X[i-l-1]);
		cdq_Exp(a,F,md+1,r);
	}

	inline void EXP(int *F,int *G,int ln)
	{
		Rep(i,1,ln)Op[i-1]=(ll)F[i]*i%mod,Op[i]=0;
		memset(G,0,sizeof(int)*(ln+1));
		cdq_Exp(Op,G,0,ln);
	}
}
using poly::mul;
using poly::power;
using poly::Len;
using poly::calrev;
using poly::NTT;
using poly::mod;
using poly::predone;
using poly::Inv;
using poly::Inter;
using poly::Deriv;
using poly::Ln;
using poly::Exp;
using poly::ad;
using poly::EXP;

static int F[MAXN],X[MAXN];

static int G[MAXN],H[MAXN];

void getans(int*F,int lim)
{
	F[1]=1;
	static int hf;
	for(register int len=4;len>>1<lim;len<<=1)
	{
		hf=len>>1;
		rep(i,hf,len)H[i]=G[i]=0;
		G[0]=0;
		rep(i,1,hf)H[i]=mod-F[i],G[i]=ad(H[i],H[i]);
		G[0]=H[0]=2;
		Inv(G,G,len-1);
		Len=len,calrev();
		rep(i,0,len)X[i]=F[i];
		NTT(H,1),NTT(X,1);
		rep(i,0,len)H[i]=(ll)H[i]*X[i]%mod;
		NTT(H,-1);
		mul(H,G,H,len-2,len-1);
		rep(i,len,len<<1)H[i]=0;
		Exp(H,F+1,H,len-1);
		Repe(i,len-1,1)H[i]=H[i-1];H[0]=0;
		rep(i,0,hf)G[i]=F[i];
		rep(i,hf,len)G[i]=0;
		G[0]=mod-1;
		Len=len,calrev();
		NTT(G,1);
		rep(i,0,len)G[i]=(ll)G[i]*G[i]%mod;
		NTT(G,-1);
		Inv(G,G,hf-1);
		++G[0];
		rep(i,hf,len)G[i]=0;
		mul(G,H,G,hf-1,hf);
		G[0]=ad(G[0],mod-2);
		rep(i,hf,len)G[i]=0;
		Inv(G,G,hf-1);
		rep(i,0,len)H[i]=2ll*(H[i]+mod-F[i])%mod;
		Len=len,calrev();
		NTT(H,1),NTT(G,1);
		rep(i,0,len)H[i]=(ll)H[i]*G[i]%mod;
		NTT(H,-1);
		rep(i,hf,len)F[i]=mod-H[i];
	}
}

static int fac[MAXN],inv[MAXN];

static int a[MAXN];

inline void Chkmax(int&u,int v){u<v?u=v:0;}

int main()
{
	file();
	predone();
	static int _,n=0;
	read(n);
	getans(F,n);
	fac[0]=1,inv[1]=1;
	Rep(i,2,n)inv[i]=mod-(ll)mod/i*inv[mod%i]%mod;
	Rep(i,1,n)fac[i]=(ll)fac[i-1]*i%mod;
	Rep(i,1,n)F[i]=(ll)F[i]*inv[i]%mod;
	EXP(F,F,n);
	write((ll)F[n]*fac[n]%mod);
	flush();
	return 0;
}
```

---

## 作者：Karry5307 (赞：7)

### 题意

求 $n$ 个点的有标号荒漠数量。

$\texttt{Data Range:}1\leq n\leq 10^5$。

### 题解

不知道之前为啥脑抽了交了个神笔题解上去，重写了一发。

首先先考虑如何数有标号无根仙人掌，荒漠计数的话直接 $\exp$ 一发就 OK 了。

设有标号有根仙人掌的 EGF 为 $F(x)$，则考虑将圆方树建出来并且钦定一个根，分类讨论一下与根相邻的点的类型：

- 如果是圆点则可以直接断掉这条边，对应的 GF 为 $F(x)$。

- 如果是方点，设在仙人掌上对应 $i+1$ 个点的环，则需要将这个环全部断掉，对应的 GF 为 $\dfrac{F^i(x)}{2}$。

至于这里为啥要除以 $2$ 的话，其实是因为如果直接断环的话让连通块再拼起来正反都会算一遍，所以得除掉。

同时，由于圆点和方点可以自由组合，所以得到：

$$\exp\left(F(x)+\frac{1}{2}\sum_{i\geq 2}F^i(x)\right)$$

简单化简一下

$$\exp\left(F(x)+\frac{F^2(x)}{2-2F(x)}\right)$$

由于需要考虑根而上面的过程并没有，所以加上这个根的贡献得到

$$F(x)=x\exp\left(F(x)+\frac{F^2(x)}{2-2F(x)}\right)$$

牛迭即可，其中可以记录中间结果方便计算，计算结果就不给出了。（因为实在太难算）

由于这里考虑的是有根仙人掌，对于无根仙人掌的话，$k$ 次项需要乘上 $\dfrac{1}{k}$ 才能得到 EGF，最后 exp 一下即可。

---

## 作者：zhylj (赞：5)

考虑对圆方树计数，记 $\mathcal F$ 表示根为圆点的仙人掌类（即有根仙人掌类），$\mathcal F_{\square}$ 表示根为方点的仙人掌类，那么可以得到：
$$
\left\{\begin{aligned}
\mathcal F_{\square} & = \mathsf {SEQ}_{\ge 2}(\mathcal F)/\mathbf F\\
\mathcal F & = \mathcal Z\star \mathsf {SET}(\mathcal F+\mathcal F_{\square})
\end{aligned}\right.
$$
其中 $\mathbf F$ 表示翻折的置换群。

那么就有：
$$
\begin{aligned}
& F(z) = z\exp\left(F(z) + \frac 12\cdot \frac{F^2(z)}{1-F(z)}\right)\\
\implies & [z^n]F(z) = \frac 1n[z^{n-1}]\exp\left(nz + \frac{nz^2}{2(1-z)}\right)
\end{aligned}
$$
我们希望求出所有的仙人掌，然后再除以 $n$ 消去根，然后再 $\exp$，但上面的式子似乎无法让我们做到。

拉格朗日反演似乎失败了，我们可以转而对第一个式子进行牛顿迭代以做到 $\mathcal O(n\log n)$ 的时间复杂度。

---

拉格朗日反演只能允许我们在 $\mathcal O(n\log n)$ 时间内求得一项，这意味着这一条路...走不通？

无法直接进行拉格朗日反演的原因是有根仙人掌到荒漠中间隔着一个除以 $z$ 再积分（然后还有一个 $\exp$）的操作，在有根树与无根树之间，我们可以通过对重心进行容斥，得到 $U(z) = T(z) - \dfrac 12T^2(z)$，这启示我们将积分的操作转化为函数复合的操作，那么如何将其应用到仙人掌上呢？

记无根仙人掌的组合类为 $\mathcal C$，即有 $\mathcal C = \Theta\mathcal F$，再记荒漠的组合类为 $\mathcal D$，即有 $\mathcal D=\mathsf {SET}(\mathcal C)$，即 $D(z) = \exp(C(z))$，我们可以得到：
$$
C(z) = \int_{0}^z F(w)\frac{\mathrm {d}w}{w}
$$
让我们从式子 $F = w\exp\left(F + \dfrac 12\cdot \dfrac{F^2}{1-F}\right)$ 开始，尝试去构造上面的式子（同时对 $F$ 取导数，然后把所有 $\exp$ 换掉）：
$$
\begin{aligned}
F & = w\exp\left(F + \dfrac 12\cdot \dfrac{F^2}{1-F}\right)\\

1 &= \left(1+\frac 12\cdot \frac{F(2-F)}{(1-F)^2}\right)F + \frac {\mathrm dw}{\mathrm dF}\cdot  \frac{F}w\\
\int \left(1 - F-\frac{F^2(2-F)}{2(1-F)^2}\right)\mathrm {d}F &= \int \mathrm dw\cdot  \frac{F}w = C\\
\end{aligned}
$$
我们发现，我们可以只用和 $F$ 有关的式子去构造 $C$ 的表达式，这意味着，考虑左边积分的结果 $H(F)$，即：
$$
H(z) = \int \left(1-z-\frac {z^2(2-z)}{2(1-z)^2}\right)\mathrm dz
$$
则 $H(F(z))=C(z)$，更有 $\exp(H(F(z)))=\exp C(z) = D(z)$，于是可以拉格朗日反演：
$$
[z^n]D(z) = [z^n]\exp(H(F(z))) =\frac 1n[z^{n-1}](\exp H(z))'\exp\left(nz + \frac{nz^2}{2(1-z)}\right)
$$
然后就可以在 $\mathcal O(n\log n)$ 的时间内解决。

事实上，该做法可以直接推广，推导是类似的，这边略去推导，直接给出式子：
$$
F = w \phi(F)\implies
\int \left(1 - \frac F{\phi(F)}\cdot  \frac{\mathrm d\phi(F)}{\mathrm dF} \right)\mathrm dF = \int \frac{F}w\mathrm dw = C 
$$
例如若 $\phi (F) = \exp(F)$（树的生成函数），则：
$$
C = \int \left(1 - \frac F{\exp(F)}\exp (F)\right)\mathrm dF = F-\frac 12F^2
$$

这正是我们想要的！

这个式子的优点在于，在 $\phi(F)$ 的形式较为复杂的时候，牛顿迭代就不太好做了，而这个式子可以直接给出单项的值，时间复杂度仍为 $\mathcal O(n\log n)$。







---


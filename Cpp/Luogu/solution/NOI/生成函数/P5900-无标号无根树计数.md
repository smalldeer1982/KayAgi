# 无标号无根树计数

## 题目背景

考虑到你谷还没有这类题，于是就放了这么个水题   


## 题目描述

求 $n$ 个点的无标号无根树数量，答案对 $998244353$ 取模。

## 说明/提示

【数据范围】   
对于 $30\%$ 的数据，$1\le n \le 1000$；   
对于 $100\%$ 的数据，$1\le n \le 2\times 10^5$。  

虽然 $\Theta(n \log^2 n)$ 也能过，但是没什么意义，建议写一下 $\Theta(n \log n)$ 的做法。

## 样例 #1

### 输入

```
7```

### 输出

```
11```

## 样例 #2

### 输入

```
27```

### 输出

```
751065460```

# 题解

## 作者：Weng_Weijie (赞：45)

## 前言

虽然 $\Theta(n\log^2n)$ 也能过，但是没什么意义，只是**跑的就是比 $\Theta(n\log n)$ 快**。

在我的博客里看可能公式会更好看。

## Euler 变换简介

为了方便，这里介绍一下幂级数的 $\text{Euler}$ 变换。

$\text{Euler}$ 变换的其中一个定义式如下：

$$\mathcal E(F(x))=\prod_i{\dfrac{1}{(1-x^i)^{f_i}}}$$

这个变换类似于 $\text{EGF}$ 中的 $\exp$。

$$\exp F(x)=\sum_i\dfrac{F^i(x)}{i!}$$

$\text{EGF}$ 的 $\exp$ 具有的组合意义是：将 $1\sim n$ 分成若干**非空**组，大小为 $i$ 的组内部具有 $f_i$ 中方案，问最后的总方案数。

而 $\text{Euler}$ 变换就是**去除了这个标号**的方案数，去掉标号会导致「如果两个组**大小和内部方案均相同**，则它们不可区分」。

因此 $\text{Euler}$ 的第一个定义式就易懂了。（即大小为 $i$ 的每种内部方案都可以选若干个，每种内部方案的生成函数都是 $(1-x^i)^{-1}$。）

现在有两种方法可以得到 $\text{Euler}$ 变换的第二个定义式。

### 方法一：使用指数、对数方法

$$\mathcal E(F(x))=\exp\left(\sum_i\ln\dfrac{1}{(1-x^i)^{f_i}}\right)
$$
$$=\exp\left(\sum_i-f_i\ln(1-x^i)\right)$$
$$=\exp\left(\sum_if_i\sum_{j}\dfrac{x^{ij}}j\right)$$
$$=\exp\left(\sum_j\dfrac 1j\sum_if_ix^{ij}\right)$$
$$=\exp\left(\sum_j\dfrac{F(x^j)}j\right)$$

因此我们得到了 $\text{Euler}$ 变换的第二个定义式。

### 方法二：使用 $\text{Burnside}$ 引理 / $\text{Pólya}$ 定理

首先枚举分成几个组，设有 $n$ 个。

这样的话，容易发现定理中的置换群即为 **$n$ 元对称群 $S_n$**。

**定理内容即：对所有的 $n$ 元置换，求在该置换作用下不动点个数的平均值。**

这时候考虑 $k$ 个位置构成 $k$ 阶循环的**指数生成函数**：

此时这 $k$ 个位置必须选择同样的方案，因此可以看做一个某个方案大小扩大了 $k$ 倍。同时 $k$ 个位置构成循环方案数即圆排列为 $(k-1)!$。

因此这个 $\text{EGF}$ 为

$$C_k(x)=\dfrac{1}{k!}(k-1)!\cdot F(x^k)=\dfrac{F(x^k)}{k}$$

根据 $\exp$ 的组合意义，可以想到将所有 $C_k(x)$ 相加，再做 $\exp$ 得到所有置换的贡献。

事实上这是正确的，原因是定理中的除以置换群大小（即 $n!$）与 $\text{EGF}$ 得到方案数时乘的 $n!$ 抵消了。（难理解的话可以**多设一个变元表示置换的大小**以更好地理解）

同样得到了那个定义式：

$$\mathcal E(F(x))=\exp\left(\sum_k\dfrac{F(x^k)}k\right)$$

## 回到原问题

### 解决无标号有根树计数问题

首先解决**无标号有根树**的问题。

容易发现，给定根以后，所有的子树可以理解成构成大小为 $n-1$ 的若干个组。

因此我们需要解的方程即：

$$F(x)=x\cdot\mathcal E(F(x))$$

#### 方法一：先求导再使用分治 $\text{FFT}$ 解决

将上式两边求导再同时乘上 $x$（即使用 $\vartheta$ 算子，$x^n$ 项的系数乘以 $n$）。

这里略去了一些中间步骤。

$$\vartheta F(x)=F(x)+F(x)\left(\sum_{k\geq 1}F'(x^k)x^k\right)$$

设 $G(x)=\sum\limits_kF'(x^k)x^k$。

可以观察到 $g_n=\sum\limits_{d|n}f_d\cdot d$。

因此 $f_n=\dfrac{1}{n-1}\left(\displaystyle\sum_{k}f_kg_{n-k}\right)$，$f_1=1$。

此时便可以使用分治 $\text{FFT}$ 解决这个问题。

#### 方法二：$\text{Newton}$ 迭代法

我们需要解的方程是：

$$G(F(x))=F(x)-x\cdot\mathcal E(F(x))$$

假设当前已经求出了 $F(x)\bmod{x^n}$，需要求 $F(x)\bmod{x^{2n}}$。

容易发现的是对 $k\geq 2$，我们已经知道了 $F(x^k)\mod {x^{2n}}$ 的值。

这时我们可以用一个常数来代替它。（强调一下**这不代表它原来是一个常数**，也就是说 $F(x^2)$ 对 $F(x)$ 求导并不是 $0$）。

设

$$P(x)=\left(x\exp\left(\sum_{k\geq 2}\dfrac{F(x^k)}k\right)\right)\bmod{x^{2n}}$$

由于 $P(x)$ 是我们规定的一个常数，则 

$$F(x)\equiv P(x)\exp F(x)\pmod{x^{2n}}$$

这个形式就易于 $\text{Newton}$ 迭代了，具体过程不详细介绍了。

事实上这个方法需要做 $\exp$，导致常数比较大，实现不优秀很有可能比前一个方法慢。

### 解决无标号无根树计数问题

这个问题思路大概是：用有根树的方案减去根不是重心的方案。

**当 $n$ 是奇数时**：

如果根不是重心，必然存在恰好一个子树，它的大小超过 $\left\lfloor\dfrac n2\right\rfloor$（设它的大小为 $k$），那么这个子树和这棵子树以外的其他点的方案数恰好为 $f_k\cdot f_{n-k}$（可以看成两棵有根树）。

因此答案为
$$f_n-\sum_{k=\lfloor\frac n2\rfloor+1}^{n-1}f_k\cdot f_{n-k}$$

**当 $n$ 是偶数时**：

出现的问题是，有可能存在两个重心，且其中一个是根（即存在一棵子树大小恰为 $\dfrac n2$）。

那么如果这个子树和剥离该子树后的树完全相同，这样的方案在 $f_n$ 只会计算一次，即不需要减去。

如果这个子树和另一棵树不相同，会被统计两次，需要减掉一次。

因此偶数时额外减掉的方案数为

$$\binom{f_{\frac n2}}2$$

**至此，这个问题在 $O(n\log n)$ 或 $O(n\log^2n)$ 的时间复杂度内解决**。

### 参考代码：

```cpp
#include <bits/stdc++.h>

typedef long long LL;
typedef unsigned long long ULL;
const int mod = 998244353, N = 262144;

int wn[N], lim, s, rev[N], w[N];
void reduce(int &x) { x += x >> 31 & mod; }
int pow(int x, int y, int ans = 1) {
	for (; y; y >>= 1, x = (LL) x * x % mod)
		if (y & 1) ans = (LL) ans * x % mod;
	return ans;
}
void fftinit(int len) {
	wn[0] = lim = 1, s = -1; while (lim < len) lim <<= 1, ++s;
	for (int i = 0; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
	const int g = pow(3, (mod - 1) / lim);
	for (int i = 1; i < lim; ++i) wn[i] = (LL) wn[i - 1] * g % mod;
}
void fft(int *A, int typ) {
	static ULL tmp[N];
	for (int i = 0; i < lim; ++i) tmp[rev[i]] = A[i];
	for (int i = 1; i < lim; i <<= 1) {
		for (int j = 0, t = lim / i / 2; j < i; ++j) w[j] = wn[j * t];
		for (int j = 0; j < lim; j += i << 1)
			for (int k = 0; k < i; ++k) {
				const ULL x = tmp[k + j + i] * w[k] % mod;
				tmp[k + j + i] = tmp[k + j] + mod - x, tmp[k + j] += x;;
			}
	}
	for (int i = 0; i < lim; ++i) A[i] = tmp[i] % mod;
	if (!typ) {
		const int il = pow(lim, mod - 2); std::reverse(A + 1, A + lim);
		for (int i = 0; i < lim; ++i) A[i] = (LL) A[i] * il % mod;
	}
}

int inv[N];
int f[N], g[N], n;
int a[N], b[N];

void init(int n) {
	inv[0] = 1, inv[1] = 1;
	for (int i = 2; i < n; ++i)
		inv[i] = (LL) (mod - mod / i) * inv[mod % i] % mod;
}

void solve(int l, int r) {
	if (r - l <= 32) {
		for (int i = l; i < r; ++i) {
			for (int j = l; j < i; ++j) {
				f[i] = (f[i] + (LL) f[j] * g[i - j]) % mod;
				if (l > 1) f[i] = (f[i] + (LL) g[j] * f[i - j]) % mod;
			}
			f[i] = (LL) f[i] * inv[i - 1] % mod;
			int v = (LL) f[i] * i % mod;
			for (int p = i; p <= n; p += i) reduce(g[p] += v - mod);
		}
		return;
	}
	int mid = l + r + 1 >> 1;
	solve(l, mid), fftinit(r - l);
	auto update = [&] (int *f, int la, int *g, int lb) {
		std::memcpy(a, f, la << 2), std::memset(a + la, 0, lim - la << 2);
		std::memcpy(b, g, lb << 2), std::memset(b + lb, 0, lim - lb << 2);
		fft(a, 1), fft(b, 1);
		for (int i = 0; i < lim; ++i) a[i] = (LL) a[i] * b[i] % mod;
		fft(a, 0);
		for (int i = mid; i < r; ++i) reduce(::f[i] += a[i - l] - mod);
	};
	if (l > 1) update(f + l, mid - l, g, r - l);
	update(g + l, mid - l, f, l == 1 ? mid : r - l);
	solve(mid, r);
}

int main() {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> n, f[1] = 1, init(n), solve(1, n + 1);
	int ans = f[n];
	for (int i = n / 2 + 1; i < n; ++i)
		ans = (ans + (LL) (mod - f[i]) * f[n - i]) % mod;
	if (n % 2 == 0) ans = (ans + mod - (LL) f[n / 2] * (f[n / 2] - 1) / 2 % mod) % mod;
	std::cout << ans << '\n';
	return 0;
}
```


---

## 作者：Karry5307 (赞：25)

### 题意

求 $n$ 个点的无标号无根树数量。

$\texttt{Data Range:}1\leq n\leq 2\times 10^5$

### 题解

可能是你谷最详细阐明 $\texttt{Euler}$ 变换的题解了。

首先考虑有根树计数，设 $f_n$ 是 $n$ 个点的无标号有根树数量，那么我们可以钦定某一个点为根，剩下的子树的大小加起来必须为 $n-1$，会发现是个背包。于是考虑使用生成函数优化一下：

$$f_n=[x^{n-1}]\prod\limits_{i=1}^{\infty}\left(\frac{1}{1-x^i}\right)^{f_i}$$

现在我们来定义 $F(x)$ 的 $\texttt{Euler}$ 变换为

$$\mathcal{E}(F(x))=\prod\limits_{i=1}^{\infty}\left(\frac{1}{1-x^i}\right)^{f_i}$$

这里给出另外一种组合解释，如果 $F(x)$ 为 $n$ 个点满足某种性质的无标号连通图数量，那么 $\mathcal{E}(F(x))$ 为 $n$ 个点满足这种性质的无标号图的数量，这个可以像上面那样，枚举连通块的个数做背包得到，类似于有标号图计数中的 $\exp$。

但是这个定义式是可以优化的，如果你做过付公主的背包这个题目的话应该对这种优化比较熟悉。我们设 $G(x)=\mathcal{E}(F(x))$，那么对定义式等式两端取对数，有

$$\ln G(x)=-\sum\limits_{i=1}^{\infty}f_i\ln(1-x^i)$$

两边求导，得到

$$\frac{G^\prime(x)}{G(x)}=\sum\limits_{i=1}^{\infty}f_i\frac{ix^{i-1}}{1-x^i}$$

做个级数展开

$$\frac{G^\prime(x)}{G(x)}=\sum\limits_{i=1}^{\infty}f_i\sum\limits_{j=0}^{\infty}ix^{(j+1)i-1}$$

积分回来

$$\ln G(x)=\sum\limits_{i=1}^{\infty}f_i\sum\limits_{j=1}^{\infty}\frac{x^{ij}}{j}$$

交换求和顺序，可以写成这个样子

$$\ln G(x)=\sum\limits_{j=1}^{\infty}\frac{1}{j}\sum\limits_{i=1}^{\infty}f_i(x^{j})^i$$

注意到右边是个点值，所以

$$\ln G(x)=\sum\limits_{j=1}\frac{F(x^j)}{j}$$

于是有

$$\mathcal{E}(F(x))=\exp\left(\sum\limits_{j=1}\frac{F(x^j)}{j}\right)$$

回到无标号有根数的计数上面来，所以我们用生成函数表示可以得到以下式子


$$F(x)=x\cdot\mathcal{E}(F(x))$$

这个可以牛迭求出，尽管是 $O(n\log n)$ 的，但是常数非常大，实际上可能比不过 $O(n\log^2n)$ 的分治 $\texttt{FFT}$。

考虑同时求导并且乘上 $x$，也就是使用 $\vartheta$ 算子，可以得到（~~计算过程给读者留做练习~~）

$$\vartheta F(x)=F(x)+F(x)\left(\sum\limits_{i=1}^{\infty}x^iF^\prime(x^i)\right)$$

设 $G(x)=\sum\limits_{i=1}^{\infty}x^iF^\prime(x^i)$，他的系数可以通过~~找规律~~和~~目瞪口呆法~~发现，有

$$g_n=\sum\limits_{d\mid n}df_d$$

于是有

$$nf_n=f_n+\sum\limits_{i}f_{i}g_{n-i}$$

解出来得到

$$f_n=\frac{1}{n-1}\sum\limits_{i}f_{i}g_{n-i}$$

这个可以分治 $\texttt{FFT}$ 解决，虽说是 $O(n\log^2n)$ 的，但是常数很小。

接下来考虑把根的影响去掉，这个的话可以考虑枚举重心，用有根树的答案减去根不是重心的答案。

由于当树的大小是偶数的时候可能存在两个重心，所以要分类讨论一下。

当 $n$ 为奇数的时候我们可以不用想那么多，由于已经钦定了根不是重心，那么必然有一棵子树使得它的大小大于 $\lfloor\frac{n}{2}\rfloor$，设为 $k$，枚举一下这个 $k$，答案为

$$f_n-\sum\limits_{k=\lfloor\frac{n}{2}\rfloor+1}f_kf_{n-k}$$

右边的东西可以随手卷一下。

当 $n$ 为偶数的时候有可能存在两个重心，且其中一个是根，枚举并判掉。

额外减掉的方案为

$$\binom{f_{\frac{n}{2}}}{2}$$

至此，这个题目就可以用 $O(n\log n)$ 或者 $O(n\log^2n)$ 的时间复杂度内解决。

### 代码

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast,unroll-loops")
using namespace std;
typedef int ll;
typedef long long int li;
typedef unsigned long long int ull;
const ll MAXN=524291,MOD=998244353,G=3,INVG=332748118;
ll n,cnt,limit; 
ll f[MAXN],g[MAXN],tmp[MAXN],tmp2[MAXN],tmp3[MAXN],rev[MAXN<<1],omgs[MAXN<<1];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
} 
inline ll qpow(ll base,ll exponent)
{
    li res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=1ll*res*base%MOD;
        }
        base=1ll*base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setupOmg(ll cnt)
{
	ll limit=log2(cnt)-1,omg;
	omg=qpow(G,(MOD-1)>>(limit+1)),omgs[cnt>>1]=1;
	for(register int i=(cnt>>1|1);i!=cnt;i++)
	{
		omgs[i]=(li)omgs[i-1]*omg%MOD;
	}
	for(register int i=(cnt>>1)-1;i;i--)
	{
		omgs[i]=omgs[i<<1]; 
	}
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
	static ull tcp[MAXN];
    register ll cur=0,x,shift=log2(cnt)-__builtin_ctz(cnt);
    if(inv==-1)
    {
    	reverse(cp+1,cp+cnt);
	}
    for(register int i=0;i<cnt;i++)
	{
		tcp[rev[i]>>shift]=cp[i];
	}
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1;
        for(register int j=0;j<cnt;j+=i)
        {
            for(register int k=0;k<cur;k++)
            {
                x=tcp[j|k|cur]*omgs[k|cur]%MOD;
                tcp[j|k|cur]=tcp[j|k]+MOD-x,tcp[j|k]+=x;
            }
        }
    }
    for(register int i=0;i<cnt;i++)
    {
    	cp[i]=tcp[i]%MOD;
	}
	if(inv==1)
	{
		return;
	}
    x=MOD-(MOD-1)/cnt;
    for(register int i=0;i<cnt;i++)
    {
    	cp[i]=(li)cp[i]*x%MOD;
	}
}
inline void conv(ll cnt,ll *f,ll *g,ll *res)
{
    static ll tmpf[MAXN],tmpg[MAXN];
    for(register int i=0;i<cnt;i++)
    {
        tmpf[i]=f[i],tmpg[i]=g[i],res[i]=0;
    }
    ll limit=log2(cnt)-1;
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(tmpf,cnt,1),NTT(tmpg,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        res[i]=(li)tmpf[i]*tmpg[i]%MOD;
        tmpf[i]=tmpg[i]=0;
    }
    NTT(res,cnt,-1);
}
inline void calc(ll l,ll r)
{
	ll mid=(l+r)>>1;
	if(l==1)
	{
		for(register int i=l;i<=mid;i++)
		{
			tmp[i-l]=f[i],tmp2[i-l]=g[i];
		}
		ll cnt=1;
		while(cnt<=((r-l)<<1))
		{
			cnt<<=1;
		}
		conv(cnt,tmp,tmp2,tmp3);
		for(register int i=mid+1;i<=r;i++)
		{
			f[i]=(f[i]+tmp3[i-l-1])%MOD;
		}
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=tmp2[i]=tmp3[i]=0;
		}
		return;
	}
	for(register int i=l;i<=mid;i++)
	{
		tmp[i-l]=f[i];
	}
	for(register int i=1;i<=r-l;i++)
	{
		tmp2[i-1]=g[i];
	}
	ll cnt=1;
	while(cnt<=((r+mid-l-l+1)<<1))
	{
		cnt<<=1;
	}
	conv(cnt,tmp,tmp2,tmp3);
	for(register int i=mid+1;i<=r;i++)
	{
		f[i]=(f[i]+tmp3[i-l-1])%MOD;
	}
	for(register int i=0;i<cnt;i++)
	{
		tmp[i]=tmp2[i]=tmp3[i]=0;
	}
	for(register int i=l;i<=mid;i++)
	{
		tmp[i-l]=g[i];
	}
	for(register int i=1;i<=r-l;i++)
	{
		tmp2[i-1]=f[i];
	}
	conv(cnt,tmp,tmp2,tmp3);
	for(register int i=mid+1;i<=r;i++)
	{
		f[i]=(f[i]+tmp3[i-l-1])%MOD;
	}
	for(register int i=0;i<cnt;i++)
	{
		tmp[i]=tmp2[i]=tmp3[i]=0;
	}
}
inline void cdqFFT(ll l,ll r)
{
	if(l==r)
	{
		f[l]=l!=1?((li)f[l]*qpow(l-1,MOD-2)%MOD):1;
		for(register int i=l;i<=n;i+=l)
		{
			g[i]=(g[i]+(li)f[l]*l%MOD)%MOD;
		}
		return;
	}
	ll mid=(l+r)>>1;
	cdqFFT(l,mid),calc(l,r),cdqFFT(mid+1,r);
}
int main()
{
	n=read()+1,cnt=1;
	while(cnt<=n)
	{
		cnt<<=1;
	}
	setupOmg(cnt<<1),cdqFFT(1,cnt),cnt=1,limit=-1;
	while(cnt<=(n<<1))
	{
		cnt<<=1,limit++;
	}
	for(register int i=0;i<cnt;i++)
	{
		rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
		tmp[i]=i<=n?f[i]:0;
	}
	NTT(tmp,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		tmp[i]=(li)tmp[i]*tmp[i]%MOD;
	}
	NTT(tmp,cnt,-1);
	for(register int i=1;i<=n;i+=2)
	{
		g[i]=(f[i]-(li)tmp[i]*499122177%MOD+MOD)%MOD; 
	}
	for(register int i=2;i<=n;i+=2)
	{
		tmp[i]=(tmp[i]-(li)f[i>>1]*f[i>>1]%MOD+MOD)%MOD;
		g[i]=(f[i]-(li)tmp[i]*499122177%MOD+MOD)%MOD;
		g[i]=(g[i]-(li)f[i>>1]*(f[i>>1]-1)%MOD*499122177%MOD+MOD)%MOD;
	}
	printf("%d\n",g[n-1]);
}
```

---

## 作者：Fuyuki (赞：18)

设n个点的无标号有根树有$f_n$个，对应的生成函数为$F(x)$。

对于一棵树而言，去掉根节点之后的各个部分互不关联，又因为没有标号，所以可以看作是一个背包的关系。那么枚举与根相连的子树大小，将背包的生成函数套进去：

$$f_n=[x^n]x\prod_{k=1}^{\infty}(\sum_{i=0}^{\infty}x^{ik})^{f_k}$$

这个式子就相当于枚举大小为$k$的子树，因为大小为$k$的子树有$f_k$种选法，每一种有都有无限多个，所以总贡献是右边那一堆东西。而这个总贡献有没有计算根的大小，那么就再在左边乘上一个$x$。

熟悉生成函数的话，就可以化简下右边的部分：

$$F(x)=[x^n]x\prod_{k=1}^{\infty}(1-x^k)^{-f_k}$$

这个时候$[x^n]$就可以拿掉了：

$$F(x)=x\prod_{k=1}^{\infty}(1-x^k)^{-f_k}$$

连乘转连加的话就是$\ln$了吧，那么就对数：

$$\ln{F(x)}=\ln{x}-\sum_{k=1}^{\infty}\ln(1-x^k)$$

对数不好处理，求导：

$$\frac{F(x)'}{F(x)}=\frac{1}{x}+\sum_{k=1}^{\infty}kf_k\frac{x^{k-1}}{1-x^k}$$

两边同时乘上$xF(x)$，去掉分母：

$$xF(x)'=F(x)+F(x)\sum_{k=1}^{\infty}kf_k\frac{x^k}{1-x^k}$$

放$[x^n]$上去：

$$nf_n=f_n+\sum_{i=1}^{n-1}f_i\sum_{k=1}^{n-1}kf_k([x^{n-i}]\frac{x^k}{1-x^k})$$

因为有：

$$\frac{x^k}{1-x^k}=\sum_{i=1}^{\infty}x^{ik}=\sum_{i=1}^{\infty}[k|i]x^i$$

所以可以带入原式：

$$nf_n=f_n+\sum_{i=1}^{n-1}f_i\sum_{k=1}^{n-1}kf_k[k|n-i]$$

转化一下：

$$f_n=\frac{\sum_{i=1}^{n-1}f_i\sum_{k=1}^{n-1}kf_k[k|n-i]}{n-1}$$

将右边的部分当做另一个多项式的$n-i$项，那么这就是一个类似卷积的形式，考虑用分治$FFT$优化。

基于调和级数，已知$F(x)$的话暴力计算右边的辅助多项式(设为$G(x)$)的复杂度只有$O(nlogn)$，那么就只用考虑如何计算分治时左边对右边的贡献。

因为$G(x)$的位数不够，当分治的左端点为$1$时左区间对右边的贡献不能完全计算。所以就先不计算这部分的贡献，改为在计算出一段$G(x)$后卷积两次来完整计算左区间的贡献（一遍$F(x)$一遍$G(x)$）。

我实现的时候出了点问题，所以长度需要补到$2^k$（这一点欢迎补充）。

现在已经求出了$n$个点的无标号有根树的数量，考虑使用容斥转化出为标号无根树的数量。

因为一棵树的重心非常少并且可以用子树大小来描述，那么就使用容斥去掉所有根不为重心的子树，具体来说就是枚举有哪些树的根包含一个子树的大小大于整棵树大小的一半就可以解决了。

实际实现的时候考虑枚举断掉原来树的一条中心边来处理，下面假设$h_n$为$n$的无标号无根树的数量。

$$h_n=\begin{cases}f_n-\sum_{k=(n+1)/2}^{n-1}f_kf_{n-k},[2\nmid n]\\f_n-\sum_{k=n/2+1}^{n-1}f_kf_{n-k}-\binom{f_{n/2}}{2},[2\mid n]\end{cases}$$

因为偶数个节点的树可能有两个重心，枚举判掉即可。

那么这个东西的中间的部分很明显是一个卷积，$O(nlogn)$求出来然后$O(n)$加加减减就可以求出$\{h_n\}$。

总复杂度$O(nlog^2n)$，但是因为分治FFT的小常数跑起来相当快。

下面是代码环节：


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define rnt re int
#define re register
#define I inline int
#define V inline void
#define ll long long int
#define FOR(i,A,B) for(rnt i=A;i<=B;++i)
#define ROF(i,A,B) for(rnt i=A;i>=B;--i)
const int N=1<<19|1,mod=998244353,G=3,inv3=332748118,inv2=mod+1>>1;
ll Pow(ll t,int x){
    ll s=1;
    for(;x;x>>=1,t=t*t%mod)
        if(x&1)s=s*t%mod;
    return s;
}
namespace poly{
    int lmt(1),r[N],w[N];
    V init(int n){
        int l=0;
        while(lmt<=n)lmt<<=1,++l;
        FOR(i,1,lmt-1)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
        int wn=Pow(3,(mod-1)>>l);w[lmt>>1]=1;
        FOR(i,(lmt>>1)+1,lmt-1)w[i]=(ll)w[i-1]*wn%mod;
        ROF(i,(lmt>>1)-1,1)w[i]=w[i<<1];
        lmt=__builtin_ctz(lmt);
    }
    I getLen(int n){return 1<<(32-__builtin_clz(n));}
    V DFT(int*a,int l){
        static unsigned long long int tmp[N];
        re int u(lmt-__builtin_ctz(l)),t;
        FOR(i,0,l-1)tmp[i]=a[r[i]>>u];
        for(re int i=1;i<l;i<<=1)
            for(re int j=0,step=i<<1;j<l;j+=step)
                FOR(k,0,i-1)
                    t=tmp[i+j+k]*w[i+k]%mod,tmp[i+j+k]=tmp[j+k]+mod-t,tmp[j+k]+=t;
        FOR(i,0,l-1)a[i]=tmp[i]%mod;
    }
    V IDFT(int*a,int l){
        reverse(a+1,a+l),DFT(a,l);
        re int bk(mod-(mod-1)/l);
        FOR(i,0,l-1)a[i]=(ll)a[i]*bk%mod;
    }
}
using poly::DFT;
using poly::IDFT;
using poly::getLen;
int f[N],g[N],n,m,k,h[N];
V init(const int&x){
	if(x^1)f[x]=1ll*f[x]*Pow(x-1,mod-2)%mod;
	else f[x]=1;
	for(rnt j=x,t=1ll*f[x]*x%mod;j<=n;j+=x)g[j]=(g[j]+t)%mod;
}
#define mul() DFT(X,l),DFT(Y,l);FOR(i,0,l-1)X[i]=1ll*X[i]*Y[i]%mod;IDFT(X,l);
V cdq(rnt L,rnt R){
	if(L==R)return init(L);
	static int X[N],Y[N];
	re int mid=L+R>>1,l;
	cdq(L,mid);
	if(L==1){
		FOR(i,L,mid)X[i-L]=f[i],Y[i-L]=g[i];
		l=getLen(R-L),mul();
		FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;
		FOR(i,0,l-1)X[i]=Y[i]=0;
	}
	else{
		l=getLen(R+mid-L-L+1);
		FOR(i,L,mid)X[i-L]=f[i];
		FOR(i,1,R-L)Y[i-1]=g[i];mul()
		FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;
		FOR(i,0,l-1)X[i]=Y[i]=0;
		FOR(i,L,mid)X[i-L]=g[i];
		FOR(i,1,R-L)Y[i-1]=f[i];mul()
		FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;
		FOR(i,0,l-1)X[i]=Y[i]=0;
	}
	cdq(mid+1,R);
}
int main(){
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
    cin>>n,n++,m=n,n=getLen(n),poly::init(n),cdq(1,n),n=m;
	re int l=getLen(n+n);
	static int X[N];
	FOR(i,0,l-1)X[i]=f[i]*(i<=n);DFT(X,l);
	FOR(i,0,l-1)X[i]=1ll*X[i]*X[i]%mod;IDFT(X,l);
	FOR(i,1,n)
		if(i&1)h[i]=(f[i]+mod-1ll*X[i]*inv2%mod)%mod;
		else
			X[i]=(X[i]-1ll*f[i>>1]*f[i>>1]%mod+mod)%mod,
			h[i]=((ll)f[i]+mod*2-1ll*X[i]*inv2%mod-(1ll*f[i>>1]*(f[i>>1]-1)>>1)%mod)%mod;
    cout<<h[n];
    return 0;
}
```



---

## 作者：Rui_R (赞：14)

题意：题如其名。

[原题](https://www.luogu.com.cn/problem/P5900)

这里提供一份被分治 $\text{NTT}$ 两只 $\log$ 吊着锤的单 $\log$ 牛顿迭代题解。

首先是 $\text{Euler}$ 变换：

让我们把一些无标号物品分成若干组（非空），大小为 $k$ 的组内部有 $f_k$ 种方案，求方案数。

对于无标号问题，如果出现大小与方案皆相同的两组，则它们没有区别。也就是说，对于大小、方案皆相同的几组，形成它们的方案数为 $1$ 。

那么，枚举大小 $k$ ，固定一种方案，则得到一个生成函数 $\sum_{i=0}\limits x^{ki} = \dfrac{1}{1-x^k}$

对于每个大小 $k$，方案数为 $f_k$ ，那么最后总方案数的生成函数就是

$$\prod_{k=1} (\frac{1}{1-x^k})^{f_k}$$

即 

$$\text{Euler}(f(x)) = \prod_{k=1} (\frac{1}{1-x^k})^{[x^k]f(x)}$$

我们可以把它化成另一个更实用的形式：

$$\text{Euler}(f(x)) = \exp (\sum_{k=1} \ln( (\frac{1}{1-x^k})^{[x^k]f(x)}))=\exp (\sum_{k=1}[x^k]f(x) \cdot \ln(\frac{1}{1-x^k}))$$

做过付公主的背包的同志应该知道：

$$\ln(\frac{1}{1-x^k})=\sum_{t=1} \frac{x^{kt}}{t}$$

如果没做过，可以先将其求导，一顿操作，然后积回来得到上式。

那么，

$$\text{Euler}(f(x))=\exp(\sum_{k=1}[x^k]f(x)\cdot (\sum_{t=1}\frac{x^{kt}}{t}))$$

改变求和顺序，先枚举 $t$ ，可以得到：

$$\text{Euler}(f(x))=\exp(\sum_{t=1} \frac{f(x^t)}{t})$$

先来看看无标号有根树的计数：

$$g(x) = x \cdot \text{Euler}(g(x))$$

$$\frac{g(x)}{x} = \exp(\sum_{t=1}\frac{g(x^{t})}{t})$$

两边一起取 $\ln$，得到

$$\ln(\frac{g(x)}{x})=\sum_{t=1}\frac{g(x^t)}{t}$$

设函数 $f$ ，且令

$$f(g(x))=\ln(\frac{g(x)}{x})-\sum_{t=1}\frac{g(x^t)}{t}$$

对这个东西上牛顿迭代：求 $g(x)$ 使 $f(g(x))\equiv 0 \pmod{x^n}$

假设我们递归的求出了 $g_0(x)$ ，使 $f(g_0(x))\equiv 0 \pmod{x^{\lceil \frac{n}{2} \rceil}}$

注意到 $g(x)$ 和 $g_0(x)$ 的前 $\lceil \frac{n}{2} \rceil$ 项是一致的，而且 $\dfrac{g(x^t)}{t}$ 只会跟 $g(x)$ 的前 $\lfloor \dfrac{n}{t} \rfloor$ 项有关。

也就是说，对于 $t>=2$ ，$\dfrac{g(x^t)}{t}$ 已经被决定了。因为此处的 $g$ 完全可以用 $g_0$ 换掉。那么，令

$$\alpha = \sum_{t=2}{\frac{g_0(x^t)}{t}}$$

这个东西可以调和级数得到。那么：

$$f(g(x))=\ln(\frac{{g(x)}}{{x}})-g(x)-\alpha$$

其中 $\alpha$ 与 $g(x)$ 无关。$\dfrac{1}{x}$ 与 $g(x)$ 也无关。

$$f'(g(x))=\frac{1}{x} \cdot \frac{1}{\frac{g(x)}{x}}-1$$

上牛迭公式：

$$g(x)\equiv g_0(x)-\frac{f(g_0(x))}{f'(g_0(x))} \pmod {x^n}$$

令 $g_1(x)=\dfrac{g_0(x)}{x}$，$g_2(x)=\dfrac{g(x)}{x}$

$$g(x)\equiv g_0(x)-\frac{\ln(g_1(x))-g_0(x)-\alpha}{\frac{1}{x}\cdot \frac{1}{g_1(x)}-1} \pmod{x^n}$$

两边一起除掉 $x$，得到：

$$g_2(x) \equiv g_1(x)-\frac{\ln(g_1(x))-g_0(x)-\alpha}{\frac{1}{g_1(x)}-x} \pmod{x^n}$$

于是，可以对 $\dfrac{g(x)}{x}$ 进行牛顿迭代求解。从而得到 $g(x)$。

这里复杂度是 $n \log n$ 的，但是常数巨大。

最后，考虑怎么由无标号有根树得到无标号无根树：让每种情况只在根为重心时被统计一次。

也就是说，用总方案数减去根不是重心的方案数。

既然根不是重心，那么根一定会有且只有一个子树的大小大于等于 $\lfloor \dfrac{n}{2} \rfloor+1$。

枚举这个大小 $k$ ，减掉 $[x^k]g(x)\cdot [x^{n-k}]g(x)$ 就好。

同时，如果 $n$ 是个偶数，那它有可能会有两个子树大小为 $\dfrac{n}{2}$ 的重心。

如果这两个重心的子树内形状一致，则会被正确统计一次。

否则，会统计两次。于是要减掉多出来的那一半，也就是

$$\frac{[x^{\frac{n}{2}}]g(x)\cdot ([x^{\frac{n}{2}}]g(x)-1)}{2}=\binom{[x^{\frac{n}{2}}]g(x)}{2}$$

至此结束。这个做法避免了 $\exp$ 这个常数要人命的东西，然而常数依然很大，大得被两只 $\log$ 吊起来锤。

（可能是我自带大常数……板子的实现太不优秀了）

剩下的，见代码：

```
#include <cstdio>
#include <cstring>

const int maxn = 6e5+5 , mod = 998244353;

template<typename T>
inline T max(const T &a,const T &b){
	return a>b?a:b;
}

template<typename T>
inline void swap(T &a,T &b){
	T temp=a;a=b;b=temp;
}

inline int mul(int a,int b){return 1ll*a*b%mod;}

int fastpow(int x,int y){
	if(y==0) return 1;
	int tmp=fastpow(x,y>>1);
	return y&1?mul(mul(tmp,tmp),x):mul(tmp,tmp);
}

namespace Poly{
	const int gate = 3,invg = fastpow(gate,mod-2);
	int lim,lg,sing[maxn];
	void init(int len){
		lim = 1,lg = 0;while(lim<len) lim<<=1,lg++;
		for(int i=1;i<lim;i++) sing[i]=(sing[i>>1]>>1)|((i&1)<<(lg-1));
	}
	void NTT(int *Steins,int type){
		for(int i=0;i<lim;i++) if(i<sing[i]) swap(Steins[i],Steins[sing[i]]);
		for(int len=1;len<lim;len<<=1){
			int unit=fastpow(type==1?gate:invg,(mod-1)/(len<<1));
			for(int i=0;i<lim;i+=(len<<1)){
				int w = 1;
				for(int k=0;k<len;k++,w=mul(w,unit)){
					int x=Steins[i+k],y=mul(w,Steins[i+k+len]);
					Steins[i+k]=(x+y)%mod,Steins[i+k+len]=(x-y)%mod;
				}
			}
		}
		if(type!=1){int Okabe=fastpow(lim,mod-2);for(int i=0;i<lim;i++) Steins[i]=mul(Steins[i],Okabe);}
	}
	int g[maxn];
	void get_inv(int *Alpha,int len,int *Beta){
		//使用前清空Beta数组
		if(len==1){Beta[0]=fastpow(Alpha[0],mod-2);return ;}
		get_inv(Alpha,(len+1)>>1,Beta);init(len+len-1);
		for(int i=0;i<len;i++) g[i]=Alpha[i];for(int i=len;i<lim;i++) g[i]=0;
		NTT(Beta,1),NTT(g,1);
		for(int i=0;i<lim;i++) Beta[i]=mul(Beta[i],2-mul(Beta[i],g[i]));
		NTT(Beta,-1);
		for(int i=len;i<lim;i++) Beta[i]=0;
	}
	void convolution(int *Alpha,int la,int *Beta,int lb,int *Zeta){
		init(la+lb-1);for(int i=lb;i<lim;i++) Beta[i]=0;
		for(int i=la;i<lim;i++) Alpha[i]=0;
		NTT(Alpha,1),NTT(Beta,1);
		for(int i=0;i<lim;i++) Zeta[i]=mul(Alpha[i],Beta[i]);
		NTT(Zeta,-1);
		for(int i=la+lb-1;i<lim;i++) Zeta[i]=0;
	}
	const int inv2=fastpow(2,mod-2);
	int t[maxn];
	void get_sqrt(int *Alpha,int len,int *Beta){
		//使用前清空Beta数组
		if(len==1){Beta[0]=1;return ;}
		get_sqrt(Alpha,(len+1)>>1,Beta);get_inv(Beta,len,t);
		init(len+len-1);
		for(int i=0;i<len;i++) g[i]=Alpha[i];for(int i=len;i<lim;i++) g[i]=0;
		NTT(g,1),NTT(t,1),NTT(Beta,1);
		for(int i=0;i<lim;i++) Beta[i]=mul(inv2,(Beta[i]+mul(g[i],t[i]))%mod);
		NTT(Beta,-1);
		for(int i=len;i<lim;i++) Beta[i]=0;for(int i=0;i<lim;i++) t[i]=0;
	}
	void derivative(int *Alpha,int len,int *Beta){
		for(int i=1;i<len;i++) Beta[i-1]=mul(i,Alpha[i]);
		Beta[len-1] = 0;
	}
	void integral(int *Alpha,int len,int *Beta){
		for(int i=1;i<len;i++) Beta[i]=mul(Alpha[i-1],fastpow(i,mod-2));
		Beta[0] = 0;
	}
	int f1[maxn],f2[maxn],f3[maxn];
	void get_ln(int *Alpha,int len,int *Beta){
		memset(f2,0,sizeof(f2));
		derivative(Alpha,len,f1),get_inv(Alpha,len,f2);
		convolution(f1,len,f2,len,f3);
		integral(f3,len,Beta);
	}
	int e1[maxn],e2[maxn];
	void get_exp(int *Alpha,int len,int *Beta){
		//使用前清空Beta数组
		if(len==1) return void(Beta[0]=1);
		get_exp(Alpha,(len+1)>>1,Beta);get_ln(Beta,len,e1);
		init(len+len-1);
		for(int i=0;i<len;i++) e2[i]=Alpha[i];for(int i=len;i<lim;i++) e2[i]=0;
		NTT(e2,1),NTT(Beta,1),NTT(e1,1);
		for(int i=0;i<lim;i++) Beta[i]=mul(Beta[i],(1-e1[i]+e2[i]));
		NTT(Beta,-1);
		for(int i=len;i<lim;i++) Beta[i]=0;for(int i=0;i<lim;i++) e1[i]=0;
	}
	int g1[maxn],g2[maxn],g3[maxn];
	void division(int *Alpha,int la,int *Beta,int lb,int *Zeta,int *Gamma){
		if(la<lb){
			for(int i=0;i<la;i++) Gamma[i] = Alpha[i];
			return ;
		}
		for(int i=0;i<la;i++) g1[i]=Alpha[la-i-1];for(int i=0;i<lb;i++) g2[i]=Beta[lb-i-1];
		for(int i=lb;i<=la-lb;i++) g2[i]=0;
		Poly::init((la-lb+1)<<1|1);for(int i=0;i<lim;i++) g3[i]=0;
		get_inv(g2,la-lb+1,g3);
		convolution(g1,la,g3,la-lb+1,Zeta);
		for(int i=0;i<=la-lb;i++) if(i<la-lb-i) swap(Zeta[i],Zeta[la-lb-i]);else break;
		for(int i=la-lb+1;i<lim;i++) Zeta[i]=0;
		for(int i=0;i<lb;i++) g2[i]=Beta[i];for(int i=0;i<=la-lb;i++) g3[i]=Zeta[i];
		convolution(g2,lb,g3,la-lb+1,g1);
		for(int i=0;i<lb;i++) Gamma[i]=(Alpha[i]-g1[i])%mod;
	}
}

int n,Alpha[maxn],Beta[maxn],Gamma[maxn];
int g1[maxn],g2[maxn];

void Newton(int len,int *Alpha){
	if(len==1) return void(Alpha[0]=1);
	Newton((len+1)>>1,Alpha);
	for(int i=0;i<len;i++) Gamma[i]=0;
	for(int i=1;i<len;i++){
		int Okabe = fastpow(i,mod-2);
		for(int j=1;j*i<len;j++) Gamma[j*i]=(Gamma[j*i]+mul(Okabe,Alpha[j-1]))%mod;
	}
	//注意i从1开始，这里将g_0也顺手合并了进去
	memset(g1,0,sizeof(g1));
	Poly::get_ln(Alpha,len,g1);for(int i=0;i<len;i++) g1[i]=(g1[i]-Gamma[i])%mod;
	memset(g2,0,sizeof(g2));Poly::get_inv(Alpha,len,g2);
	g2[1]=(g2[1]-1)%mod;
	memset(Beta,0,sizeof(Beta));Poly::get_inv(g2,len,Beta);
	Poly::convolution(g1,len,Beta,len,g1);
	for(int i=0;i<len;i++) Alpha[i]=(Alpha[i]-g1[i])%mod;
}

int main(){
	scanf("%d",&n);Newton(n,Alpha);//这里得到的是除以x之后的结果
	int answer = Alpha[n-1];
	for(int i=(n>>1)+1;i<=n-1;i++) answer = (answer-mul(Alpha[i-1],Alpha[n-i-1]))%mod;
	if(!(n&1)) answer = answer-mul(fastpow(2,mod-2),mul(Alpha[n/2-1],Alpha[n/2-1]-1));
	answer%=mod;
	printf("%d\n",(answer+mod)%mod);
	return 0;
}

```

最后的最后，关于另一篇牛顿迭代题解的未解之谜2，我相信那是它写法上出了什么意外，因为我这里数组开到 $6e5$ 就过了。


---

## 作者：zhiyangfan (赞：12)

## 无标号无根树计数
这道题题解区有很多神仙题解，讲解得很全面，本篇题解仅做一些细节补充和代码实现方面的讲解。
### 题意
求 $n$ 个点的无标号无根树数量，答案对 $998,244,353$ 取模。($1\le n\le 2\times10^5$)
### 题解
注意到无根树这个限制比较恶心，因为对于一棵树我们总要找个根才好处理各种东西。所以考虑先计算无标号有根树的数量，然后减去根不是重心的方案。

而对于有根树，钦定完一个根之后剩下 $n-1$ 个点会分成若干个非空集合（且非空集合之间顺序无所谓，这也是为什么后文用的 OGF 而不是 EGF），每个集合对应一棵子树，而每棵子树又是类似的结构，即具有递归的形式。这样如果我们设答案的 OGF 为：
$$F(x)=\sum_{n\ge 0}f_nx^n$$
则它应该满足等式：
$$[x^n]F(x)=[x^{n-1}]\prod_{k\ge 1}\left(\sum_{i\ge 0}x^{ik}\right)^{f_k}$$
其实就是把选择集合的过程当做背包，每种集合的大小当成一种物品，会贡献 $f_i$ 的方案数，结合上面说的无标号有根树的性质很容易得出这个等式。根据：
$$\left(\dfrac{1}{1-x^k}\right)^{f_k}=\left(\sum_{i\ge 0}x^{ik}\right)^{f_k}$$
能把原式的 $\sum$ 干掉：
$$[x^n]F(x)=[x^{n-1}]\prod_{k\ge 1}\left(\dfrac{1}{1-x^k}\right)^{f_k}$$
这里再简单乘上一个 $x$ 就能把 $[x^n],[x^{n-1}]$ 干掉了：
$$F(x)=x\prod_{k\ge 1}\left(\dfrac{1}{1-x^k}\right)^{f_k}$$
看来我们问题的关键就落在了 $\prod_{k\ge 1}\left(\frac{1}{1-x^k}\right)^{f_k}$ 这个东西上面。注意 $\prod$ 是很难处理的，所以考虑取对数转化为 $\sum$：
$$\begin{aligned}\prod_{k\ge 1}\left(\dfrac{1}{1-x^k}\right)^{f_k}&=\exp\left(\sum_{k\ge 1}\ln\left(\dfrac{1}{1-x^k}\right)^{f_k}\right)\\&=\exp\left(\sum_{k\ge1}-f_k\ln(1-x^k)\right)\end{aligned}$$
现在压力来到了 $\ln(1-x^k)$ 这边。因为 $\ln$ 很难处理，但它的导数很好处理，所以考虑求导：
$$\ln(1-x^k)=\int\dfrac{\mathrm{d}}{\mathrm{d}x}\ln(1-x^k)=\int\dfrac{-kx^{k-1}}{1-x^k}$$
我们能看到现在积分号里面的就是一个我们知道对应幂级数的封闭形式了：
$$\int\dfrac{-kx^{k-1}}{1-x^k}=-\int\sum_{n\ge 0}kx^{(n+1)k-1}=-\int\sum_{n\ge 1}kx^{nk-1}$$
现在这个式子就很好看了，只需要把积分号算进去：
$$-\int\sum_{n\ge 1}kx^{nk-1}=-\sum_{n\ge 1}\dfrac{kx^{nk-1+1}}{nk-1+1}=-\sum_{n\ge 1}\dfrac{x^{nk}}{n}$$
好，这东西的另一种形式显然更便于式子的化简，我们代回去：
$$\begin{aligned}\exp\left(\sum_{k\ge1}-f_k\ln(1-x^k)\right)&=\left(\exp\sum_{k\ge1}f_k\sum_{n\ge 1}\dfrac{x^{nk}}{n}\right)\\&=\exp\left(\sum_{n\ge 1}\dfrac{1}{n}\sum_{k\ge 1}f_kx^{nk}\right)\\&=\exp\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)\end{aligned}$$
啊这就好多了，注意到我们有等式：
$$F(x)=x\exp\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)$$
还是类似 $\ln$，遇到 $\exp$ 考虑求导：
$$\begin{aligned}F'(x)&=\left(x\exp\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)\right)'\\&=x'\exp\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)+x\left(\exp\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)\right)'\\&=\dfrac{F(x)}{x}+x\exp\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)\left(\sum_{n\ge 1}\dfrac{F(x^n)}{n}\right)'\\&=\dfrac{F(x)}{x}+F(x)\sum_{n\ge 1}\dfrac{F'(x^n)nx^{n-1}}{n}\\&=\dfrac{F(x)}{x}+F(x)\sum_{n\ge 1}F'(x^n)x^{n-1}\end{aligned}$$
两边同时乘上 $x$，会让式子更好看：
$$xF'(x)=F(x)+F(x)\sum_{n\ge 1}F'(x^n)x^n$$
注意到这个等式哪哪都好，就是最后一个求和式很恶心。考虑定义 $G(x)=\sum_{n\ge 1}F'(x^n)x^n$，并研究一下 $[x^i]G(x)$ 的取值。让我们把 $G(x)$ 展开：
$$\begin{aligned}G(x)&=\sum_{n\ge 1}x^n\sum_{j\ge 1}jf_jx^{n(j-1)}\\&=\sum_{n\ge 1}\sum_{j\ge 1}jf_jx^{nj}\end{aligned}$$
这样的话，对于 $x^i$ 做贡献的所有 $jf_j$ 应该满足 $j|i$，即：
$$[x^i]G(x)=\sum_{j|i}f_jj$$
把 $G(x)$ 带回原式：
$$xF'(x)-F(x)=F(x)G(x)$$
而我们发现 $xF'(x)$ 其实就是：
$$\sum_{n\ge 1}nf_nx^n$$
所以：
$$[x^n]F(x)=\dfrac{[x^n]F(x)G(x)}{n-1}$$
即：
$$f_n=\dfrac{\sum_{k=1}^{n-1}(f_kg_{n-k})}{n-1},f_1=1$$
半在线卷积求解即可。不过这里的半在线卷积与谷谷 [分治 FFT 板子](https://www.luogu.com.cn/problem/P4721) 的半在线卷积并不是一种。注意那道题 $g$ 是给出的，而这里 $g$ 是依赖于前面求出的 $f$ 的。在那道题中，我们用到的半在线卷积依赖于这个式子：
$$f_{l\sim mid}\times g_{0\sim r-l}\rightarrow f_{mid\sim r}$$
来算左边对右边的贡献。但这里因为只求出了 $l\sim mid$ 的 $f$，$g_{mid,\sim r-l}$ 的值还没有计算，这题这样做显然是错误的。而正确的策略是，当 $l=0$ 时：
$$f_{l\sim mid}\times g_{0\sim mid}\rightarrow f_{mid\sim r}$$
这时候显然有贡献漏掉了。考虑当 $l>0$ 时补回来：
$$\begin{cases}g_{l\sim mid}\times f_{0,r-l}\\f_{l\sim mid}\times g_{0,r-l}\end{cases}\rightarrow f_{mid\sim r}$$
这样就能补回来漏掉的贡献了。

现在求出来 $F(x)$ 了，不要忘了我们要计数的是无根树不是有根树。所以要减掉根不是重心的方案。当 $n$ 是奇数时，显然原树只能有一个重心。而重心的定义是所有子树大小均小于等于 $\lfloor\frac{n}{2}\rfloor$，所以我们只需要钦定一棵子树大小大于 $\lfloor\frac{n}{2}\rfloor$ 即可，要减去的方案数为：
$$\sum_{k=\lfloor\frac{n}{2}\rfloor+1}^{n-1}f_kf_{n-k}$$
即看成两棵有根树分别处理，然后把大小为 $k$ 的那个接到另一个的根上。而当 $n$ 为偶数时，麻烦了，因为可能出现两个重心的情况，且其中一个还是根，即存在一棵子树大小恰等于 $\frac{n}{2}$。而现在还是有两种情况，第一种是这棵子树和去掉这棵子树后的原树（类比奇数情况下 $f_k$ 和 $f_{n-k}$）恰好同构，那这个就不会重复计数了，因为这俩根本质上是一样的。而其他情况就会重复计数一次，减掉的方案数即在所有可能的形态中选俩接起来：
$$\dbinom{f_{\frac{n}{2}}}{2}$$
这样这道题就解决了，时间复杂度 $\mathcal{O}(n\log^2n)$。在刚刚的推导中我把 $f_0$ 这一项都忽略了，但在实现里面我是算上了的，但显然影响不大。
```cpp
#include <cstdio>
#include <algorithm>
const int N = 1e6 + 10, mod = 998244353; typedef long long ll;
int f[N], g[N], A[N], B[N], rev[N], lim, n, m;
inline int ksm(int a, int b)
{
    int ret = 1;
    while (b)
    {
        if (b & 1) ret = (ll)ret * a % mod;
        a = (ll)a * a % mod; b >>= 1;
    }
    return ret;
}
inline void init(int n)
{
    lim = 1; m = 0; while (lim <= n) lim <<= 1, ++m;
    for (int i = 0; i < lim; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (m - 1));
}
inline void NTT(int* f, int len, int on)
{
    for (int i = 0; i < len; ++i) if (i < rev[i]) std::swap(f[i], f[rev[i]]);
    for (int h = 2; h <= len; h <<= 1)
    {
        int gn = ksm(3, (ll)on * ((mod - 1) / h) % (mod - 1));
        for (int j = 0; j < len; j += h)
            for (int k = j, g = 1; k < j + h / 2; ++k, g = (ll)g * gn % mod)
            {
                int u = f[k], t = (ll)g * f[k + h / 2] % mod;
                f[k] = (u + t) % mod; f[k + h / 2] = ((u - t) % mod + mod) % mod;
            }
    }
    if (on == mod - 2) for (int i = 0, inv = ksm(len, on); i < len; ++i) f[i] = (ll)f[i] * inv % mod;
}
inline void mul(int* f, int lF, int* g, int lG)
{   
    for (int i = 0; i < lF; ++i) A[i] = f[i];
    for (int i = lF; i < lim; ++i) A[i] = 0;
    for (int i = 0; i < lG; ++i) B[i] = g[i];
    for (int i = lG; i < lim; ++i) B[i] = 0;
    NTT(A, lim, 1); NTT(B, lim, 1); 
    for (int i = 0; i < lim; ++i) A[i] = (ll)A[i] * B[i] % mod;
    NTT(A, lim, mod - 2);
}
inline void cdq(int l, int r)
{
    if (r == 1) return ;
    if (l + 1 == r) 
    {
        if (l != 1) f[l] = (ll)f[l] * ksm(l - 1, mod - 2) % mod;
        for (int i = l; i < n; i += l) (g[i] += (ll)f[l] * l % mod) %= mod;
        return ;
    }
    int mid = (l + r) >> 1; cdq(l, mid); init(r - l);
    if (l > 0) 
    {
        mul(f, r - l, g + l, mid - l);
        for (int i = mid; i < r; ++i) (f[i] += A[i - l]) %= mod;
    }
    mul(f + l, mid - l, g, !l ? mid : r - l);
    for (int i = mid; i < r; ++i) (f[i] += A[i - l]) %= mod;
    cdq(mid, r);
}
signed main()
{
    int m; scanf("%d", &m); n = 1; while (n <= m) n <<= 1;
    f[1] = 1; cdq(0, n); int ans = f[m];
    for (int i = m / 2 + 1; i < m; ++i) (ans += (ll)(mod - f[i]) * f[m - i] % mod) %= mod;
    if (!(m & 1)) (ans += (mod - (ll)f[m / 2] * (f[m / 2] - 1) / 2 % mod)) %= mod;
    printf("%d\n", ans); return 0;
}
```
题做完了，我们来看看从这道题我们能得到什么。注意到刚刚我们处理的式子：
$$\prod_{k\ge 1}\left(\frac{1}{1-x^k}\right)^{f_k}$$
的组合意义是把原集合分成若干个非空子集，且顺序无所谓，大小为 $i$ 的组方案数为 $f_i$，对应的总方案数。这个东西跟 EGF 中的 $\exp$ 似乎很相似，所以我们考虑给它单独起一个名字：Euler 变换，$F(x)$ 的 Euler 变换通常记为 $\mathcal{E}F(x)$。刚刚已经得出了它的两种形式：
$$\mathcal{E}F(x)=\prod_{k}\left(\frac{1}{1-x^k}\right)^{f_k}=\exp\left(\sum_{n}\dfrac{F(x^n)}{n}\right)$$
个人认为算是 OGF 版的 “$\exp$”，不考虑分成子集的前后顺序。

ps. 半在线卷积的部分参考 $\tt command\_ block$ 的 [博客](https://www.luogu.com.cn/blog/command-block/ban-zai-xian-juan-ji-xiao-ji)。

pps. 本题还可以用牛顿迭代在 $\mathcal{O}(n\log n)$ 的时间内求解，但那个方法涉及到 $\exp$，所以常数会比较爆炸，具体可以看其他神仙的题解。

ppps. 关于最后扔出的 Euler 变换第二个形式的证明，题解区还给出了用群论方法证明的思路。

pppps. 我的代码常数大得要命，看看理解咋实现可以，借鉴具体实现方式就算了。

---

## 作者：teylnol_evteyl (赞：9)

引入欧拉变换。

对于一个普通生成函数 $F(x)$，$f_i=[x^i]F(x)$ 表示体积为 $i$ 的物品权值，求生成函数 $G(x)=\varepsilon(F(x))$，$g_i$ 表示选择若干个物品，体积总和为 $i$，并且物品之间无序的权值乘积和。

设生成函数 $P_k(x)$ 表示物品体积都为 $1$ 且权值为 $k$ 的生成函数，则 $P_k{x}=\sum\limits_{i\ge 1}x^ik^i=\dfrac 1 {1-kx}$。

所以 $G$ 应该为所有物品权值的生成函数之积，即：

$$
\begin{aligned}
G(x)&=\prod_{i\ge1}P_{f_i}(x^i)\\
&=\prod_{i\ge1}\dfrac 1 {1-f_ix^i}\\
\end{aligned}
$$

先取 $\ln$ 再取 $\exp$，然后考虑 $\ln(x+1)=\sum\limits_{i\ge1}\dfrac{(-1)^{i-1}}{i}x_i$

$$
\begin{aligned}
G(x)&=\prod_{i\ge1}P_{f_i}(x^i)\\
&=\exp\left(\sum_{i\ge1}-\ln(1-f_ix^i)\right)\\
&=\exp\left(\sum_{i\ge1}-\sum_{j\ge1}\dfrac{(-1)^{j-1}(-f_i)^j}{j}x^{ij}\right)\\
&=\exp\left(\sum_{i\ge1}\sum_{j\ge1}\dfrac{f_i^j}{j}x^{ij}\right)\\
&=\exp\left(\sum_{i\ge1}\dfrac{F(x^i)}{i}\right)\\
\end{aligned}
$$

如果只需要求前 $n$ 项，求和的枚举是调和级数的，所以时间复杂度是 $O(n\log n)$。

回到无标号有根树这个问题，设生成函数为 $A(x)$，有：

$$A(x)=x\varepsilon(A(x))$$

所以

$$\ln\left(\dfrac{A(x)}x\right)=\sum_{i\ge1}\dfrac{A(x^i)}{i}$$

首先边界 $a_0=1$ 是确定的。对于其它部分，如果求道 $a_k$，则可以总时间复杂度 $O(n\log n)$ 求 $[x^k]\sum_{i\ge1}\dfrac{A(x^i)}{i}=[x^k]\ln\left(\dfrac{A(x)}x\right)$，根据 $\exp$ 的递推式，就可以求出 $A(x)$。现在就可以打 $O(n^2)$ 的暴力了。

$\exp$ 递推式

$$
g_n=
\begin{cases}
1 & n=1 \\
\dfrac 1 n\sum\limits_{i=1}^n if_ig_{n-i} & n>1
\end{cases}
$$

是一个卷积形式，但是卷积的两部分，都需要在求出 $g_k$ 之后才知道 $g_k$ 和 $f_{k+1}$，也就是说两部分都是在线的。

修改一下分治 FFT 的过程。对于当前分治区间 $[l,r]$。（$\gets$ 表示更新答案。）

- 若 $l=0$，进行 $f[mid+1,r]\gets g[l,mid]\times f[l,mid]$。
- 若 $l>0$，进行 $f[mid+1,r]\gets g[l,mid]\times f[0,r-l+1]+f[l,mid]\times g[0,r-l+1]$。

于是就可以 $O(n\log^2n)$ 的求 $f$ 了。（可以尝试画图理解？）

还有时间复杂度更优秀的做法吗？

考虑牛顿迭代。设当前的前 $n$ 位结果的生成函数为 $A_1(x)=\dfrac{A(x)}{x}=\sum\limits_{i=1}^{n}a_ix^{i-1}$。

对于 $\sum\limits_{i\ge1}\dfrac{A(x^i)}{i}$ 的 $i\ge 2$ 的部分，都是已经知道的，设为 $P(x)$，则剩余部分为 $A(x)$。

所以方程为

$$F(A(x))=\ln\left(\dfrac{A(x)}x\right)-A(x)-P(x)=0$$

对于牛顿迭代，求导应该把 $A(x)$ 当作变量，其它当作常量，所以

$$
\begin{aligned}
F'(A(x))&=\dfrac 1 x\dfrac x{A(x)}-1\\
&=\dfrac 1 {A(x)}-1
\end{aligned}
$$

根据牛顿迭代公式

$$x'=x-\dfrac{F(x)}{F'(x)}$$

可以得到 $A_1$ 迭代一次的结果为：

$$A_1-\dfrac{\ln(A_1)-A-P}{\dfrac 1{A_1}-1}$$

时间复杂度 $O(n\log n)$，常数不小。~~时间复杂度越小，效率越低。~~

当然，如果你推出的式子还带 $\exp$，那常数直接升天了。

现在把有根树转化成无根树，可以考虑先随意规定一个根，然后再减去根不是重心的情况。设无标号有根树的生成函数为 $F(x)$。

对于 $n$ 为奇数，不是重心则一定有一棵子树大于等于 $\lceil \frac n 2\rceil$，同时由于 $\varepsilon(F(x))=xF(x)$，则数量为：

$$g_n=f_n-\sum_{i=\lceil \frac n 2\rceil}^nf_if_{n-i}$$

对于 $n$ 为偶数，如果按照前面的式子计算，先减去有子树大小大于等于 $\frac n 2$ 的情况。有两个重心，且将这两个重心连边断开之后，两棵树不同构的树，会被少减去一次，更准确地说，大小为 $2m$ 的树有 $\binom {f_m-1} 2$ 个，被计算了 $n\binom {f_m-1} 2$ 次，减去了 $(n-2)\binom {f_m-1} 2$ 所以需要格外减 $\binom {f_m-1} 2$ 次。

归纳一下，写成生成函数形式，就有

$$G(x)=F(x)-\frac 1 2 F^2(x)+\frac 1 2 F(x^2)$$

[代码](https://www.luogu.com.cn/paste/a2w19cv2)。

---

## 作者：9AC8E2 (赞：7)

# 无标号有根树计数

对于一个给定的根,这棵树的方案数相当于将除根外的所有点划分进若干棵不能为空的子树的方案数,那么构造方案数关于点数的 $OGF$ ,设为 $F$ ,那么有方程 $F(x)=x\times euler(F(x))$

那么问题就是如何求解方程 $F(x)-x\times euler(F(x))=0$

考虑倍增
## 直接倍增的做法

现在已经求出 $f$ 满足 $f(x)-x\times euler(f(x))\equiv 0\mod x^n$

考虑如何求出 $F$ 满足 $F(x)-x\times euler(F(x))\equiv 0\mod x^{2n}$

容易发现, $\forall k\geq 2$,$f(x^k)\mod x^{2n}$ 都可以很方便的求出,且 $f(x^k)\equiv F(x^k)\mod x^{2n}$

所以当 $f$ 为常数时,$P(x)=x\exp\sum_{k=2}\frac{f(x^k)}{k}\mod x^{2n}$ 也为常数

再带入 $Euler$ 变换的柿子,显然 $F(x)-P(x)\exp F(x)\equiv 0\mod x^{2n}$

$$\frac{F(x)}{\exp F(x)}\equiv P(x)\mod x^{2n}$$

再做牛顿迭代

现在已经求出 $g$ 满足 $\frac{g(x)}{\exp g(x)}\equiv P(x)\mod x^n$

考虑如何求出 $G$ 满足 $\frac{G(x)}{\exp G(x)}\equiv P(x)\mod x^{2n}$

求的是 $H(x)=\frac{x}{\exp x}-P$,$H(F(x))\equiv 0\mod x^{2n}$ 的 $F$

在 $g(x)$ 处将$H$泰勒展开

$$H(G(x))\equiv H(g(x))+\sum_{i=1}\frac{H^{i'}(g(x))(G(x)-g(x))^i}{i!}\mod x^{2n}$$

$$\equiv H(g(x))+H'(g(x))\times (G(x)-g(x))$$

$$\equiv 0$$

$$G(x)=g(x)-\frac{H(g(x))}{H'(g(x))}$$

考虑如何求 $H'(g(x))$

$$H'(x)=\frac{\exp x-x\exp x}{(\exp x)^2}=\frac{1-x}{\exp x}$$

$$H'(g(x))=\frac{1-g(x)}{\exp g(x)}$$

(这里是对 $g$ 求导而不是 $x$ )

$$G(x)=g(x)-\frac{\frac{g(x)}{\exp g(x)}-P(x)}{\frac{1-g(x)}{\exp g(x)}}$$

$$=g(x)+\frac{g(x)-P(x)\times \exp g(x)}{g(x)-1}$$

该做法是正确的,复杂度也是正确的,但是常数巨大,只能过 $50\%$ 的点, $O(n\log n)$ 的复杂度 $2\times 10^5$ 跑了 $25s$

[代码](https://www.luogu.com.cn/paste/2lhx82p5)
## 基于直接倍增做法的大优化
参考题解,可以发现以上做法常数巨大的原因并不是因为需要做 $\exp$ ,而是倍增套倍增的层数太多了.
事实上,第一层倍增与第二层牛顿迭代完全可以合并.

回到一开始的问题.我们要求解的是方程 $F(x)-x\times euler(F(x))\equiv 0\mod x^n$

现在已经求得方程 $f(x)-x\times euler(f(x))\equiv 0\mod x^{n/2}$ 的解

显然, $F(x)$与$f(x)$ 的前 $n/2$ 项是相同的

将方程转化为 $F(x)-P(F(x))\exp F(x)\equiv 0\mod x^n$

其中 $P(F(x))\equiv x\times \exp\sum_{k=2}\frac{F(x^k)}{k}\mod x^n$

显然, $P(F(x))=P(f(x))$

牛顿迭代求解方程 $F(x)-P(F(x))\exp F(x)\equiv 0\mod x^n$

现在已经求得方程 $g(x)-P(F(x))\exp g(x)\equiv 0\mod x^{n/2}$

显然, $g(x)-P(f(x))\exp g(x)\equiv 0\mod x^{n/2}$ ,同时$f(x)-P(f(x))\exp f(x)\equiv 0\mod x^{n/2}$

不难发现, $g(x)\equiv f(x)\mod x^{n/2}$

直接套用之前牛顿迭代的柿子
$$F(x)=f(x)+\frac{f(x)-P(f(x))\times \exp f(x)}{f(x)-1}$$

该做法是正确的,复杂度也是正确的,但是常数也巨大,也只能过 $50\%$ 的点,不过 $O(n\log n)$ 的复杂度 $2\times 10^5$ 跑了 $14s$,比之前快了不少
[代码](https://www.luogu.com.cn/paste/g4yh0sh7)
## 基于两边取$\ln$的做法

以上做法因为做了很多次 $\exp$ ,常数十分吓人.如果我们可以把 $\exp$ 换成 $\ln$ ,常数会优很多

回到一开始的问题.我们要求解的是方程 $F(x)-x\times euler(F(x))\equiv 0\mod x^n$

现在已经求得方程 $f(x)-x\times euler(f(x))\equiv 0\mod x^{n/2}$ 的解

显然, $F(x)$ 与 $f(x)$ 的前 $n/2$ 项是相同的

将方程转化为 $F(x)\equiv P(F(x))\exp F(x)\mod x^n$

其中 $P(F(x))\equiv x\times \exp\sum_{k=2}\frac{F(x^k)}{k}\mod x^n$

对这个柿子两边取 $\ln$ 
,$\ln F(x)\equiv \sum_{k=2}\frac{F(x^k)}{k}+\ln x+F(x)\mod x^{n}$

显然, $\ln f(x)\equiv \sum_{k=2}\frac{F(x^k)}{k}+\ln x+f(x)\mod x^{n/2}$

设 $P(x)=\sum_{k=2}\frac{F(x^k)}{k}+\ln x$

设 $G(x)=\ln x-x-P$

$$G'(x)=\frac{1}{x}-1$$
$$G'(f(x))=\frac{1}{f(x)}-1$$

$$F(x)=f(x)-\frac{\ln f(x)-f(x)-P(x)}{\frac{1}{f(x)}-1}$$

容易发现,$f(x)$ 的常数项为 $0$ 且一次方项不为 $0$,并不能求 $\ln$ ,同时 $P(x)$ 中的 $\ln x$ 也不能求出

那么,设 $a(x)=\frac{f(x)}{x},A(x)=\frac{F(x)}{x}$

$$F(x)=f(x)-\frac{\ln a(x)+\ln x-f(x)-\sum_{k=2}\frac{f(x^k)}{k}-\ln x}{\frac{1}{f(x)}-1}$$
$$=f(x)-\frac{\ln a(x)-\sum_{k=1}\frac{f(x^k)}{k}}{\frac{1}{f(x)}-1}$$

$$F(x)=f(x)+\frac{\ln a(x)-\sum_{k=1}\frac{f(x^k)}{k}}{f(x)-1}\times f(x)$$

$$A(x)=a(x)-\frac{\ln a(x)-\sum_{k=1}\frac{f(x^k)}{k}}{\frac{1}{a(x)}-x}$$

这样就不用求 $\exp$ 了

[代码](https://www.luogu.com.cn/paste/73ad4agb)

### 未解之谜
1. 按照柿子 $F(x)=f(x)+\frac{\ln \frac{f(x)}{x}-\sum_{k=1}\frac{f(x^k)}{k}}{f(x)-1}\times f(x)$ 牛顿迭代没法过,但是按照柿子 $A(x)=a(x)-\frac{\ln a(x)-\sum_{k=1}\frac{f(x^k)}{k}}{\frac{1}{a(x)}-x}$ 牛顿迭代可以过,非常奇怪
2. $n$最大会等于 $2^{18}$,但是把数组开到 $8\times 10^5$ 没法过,开到 $16\times 10^5$ 能过
# 无标号无根树计数
考虑用总的无标号有根树方案数减去根不是重心的方案数,这样每个方案只会在根为重心时被统计一遍

设点数为 $n$ ,已经求出 $i$ 个点的无标号有根树方案数为 $f_i$

## $n$为奇数时

根据重心的性质,根节点不是重心,那么必然有一个子树大小 $\ge \lceil \frac{n}{2} \rceil$

枚举这棵子树大小,答案等于 $f_n-\sum_{k=\lceil \frac{n}{2} \rceil}^{n-1}f_k\times f_{n-k}$

## $n$为偶数时

可能同时存在两个重心,其中一个重心为根

断开两个重心之间的边,产生两棵以重心为根的树

若这两棵树完全相同,那么在 $f$ 中只会被统计一遍,不用减去

否则,这个方案在 $f$ 中会被统计两遍,需要减去一遍,总的方案数是 $C_{f_{\frac{n}{2}}}^2$ 种

两棵子树大小不相等的情况,按照原来的方式计算即可

答案等于 $f_n-\sum_{k=\frac{n}{2}+1}^{n-1}f_k\times f_{n-k}-C_{f_{\frac{n}{2}}}^{2}$

---
[参考博客](https://blog.csdn.net/qq_35950004/article/details/106483384)


---

## 作者：xiezheyuan (赞：5)

题目足够简要，无需简要题意，直接讲思路。

感觉符号化方法还没有普及，所以在这里介绍一下，大部分文段来自我自己在校内的《组合数学信息方法》讲稿，因此不构成侵权。

## 符号化方法

### 概述

在组合数学中，我们最常遇到的问题是，计算大小为 $n$ 的某种东西的数量，这种东西同时也要满足一些限制。我们称这种可以计数的对象称为组合对象。全体组合对象称为组合类。一个组合类的 OGF，通常为其计数序列（大小对应数量）的 OGF。

在实际应用中，这些对象往往具有一些特征，如：

- 可以分割为若干个部分，每个部分对大小的贡献为 $1$。
- 不同的部分通过经典的方法组合在一起，比如序列 $\textsf{SEQ}$、可重集合 $\textsf{MSET}$、环 $\textsf{CYC}$ 等等。

符号化方法用来将组合对象建模，使得其容易用生成函数来表示，进而用多项式相关算法来求解。

### 基础无标号类

我们称 $\epsilon$ 为中性对象，并认为 $|\epsilon|=0$，表示其不会对大小产生贡献。中性对象的组合类 $\{\epsilon\}$ 记作 $\mathcal{E}$，其生成函数为 $\mathbf{E}(z)=1$。

我们称 $\bullet$ 为原子对象，并认为 $|\bullet|=1$，表示其对大小产生贡献为 $1$。原子对象的组合类 $\{\bullet\}$，记作 $\mathcal{Z}$，其生成函数为 $\mathbf{Z}(z)=z$。

对于两个组合对象的直积 $\mathcal{C}=\mathcal{A}\times \mathcal{B}$，有 $\mathbf{C}(z)=\mathbf{A}(z)\mathbf{B}(z)$，对于两个不交的组合对象的并 $\mathcal{C}=\mathcal{A}\cup \mathcal{B}$，有 $\mathbf{C}(z)=\mathbf{A}(z)+\mathbf{B}(z)$。

这两个结论是显然的，本质上是加法原理和乘法原理。

### 无标号序列构造

定义 $\textsf{SEQ}(\mathcal{A})$ 表示 $\mathcal{A}$ 中所有元素组成的序列的组合类，其生成函数为：

$$
\mathbf{Q}(\mathcal{A})=\sum_{i=0}^{+\infty} \mathbf{A}^i(z)=\frac{1}{1-\mathbf{A}(z)}
$$

例子：$01$ 组合类 $\mathcal{B}$ 的生成函数 $\mathbf{B}=2z$，则其序列的生成函数为 $\mathbf{Q}(\mathcal{B})=\frac{1}{1-2z}$。根据无穷级数的知识，可以得到 $[z^n]\frac{1}{1-2z}=2^n$。

### 无标号可重集合构造

定义 $\textsf{MSET}(\mathcal{A})$ 表示 $\mathcal{A}$ 中所有元素组成的可重集合的组合类。

概念说清楚了，现在的问题是 $\textsf{MSET}$ 的生成函数是什么？

考虑一个显然正确，但是不够通用的生成函数：

$$
\mathbf{M}(\mathcal{A})=\prod_{a\in \mathcal{A}} \mathbf{Q}(\{a\})=\prod_{a\in \mathcal{A}}\frac{1}{1-z^{|a|}}=\prod_{i=1}^{+\infty} (1-z^i)^{-[z^i]\mathbf{A}(z)}
$$

看到 $\prod$ 不好处理，对其取 $\ln$ 得：

$$
\ln \mathbf{M}(\mathcal{A}) = \sum_{i=1}^{+\infty} (-[z^i]\mathbf{A}(z))\ln(1-z^i)
$$

根据 Taylor 展开的知识，我们有：

$$
\ln(1-z) = -\sum_{k=1}^{+\infty} \frac{z^k}{k}
$$

代入，得：
    
$$
\ln \mathbf{MSET}(\mathcal{A}) = \sum_{i=1}^{+\infty} ([z^i]\mathbf{A}(z))\sum_{k=1}^{+\infty} \frac{z^{ik}}{k}
$$

变形得：

$$
\ln \mathbf{MSET}(\mathcal{A}) = \sum_{k=1}^{+\infty}\frac{1}{k}\sum_{i=1}^{+\infty}([z^i]\mathbf{A}(z)) z^{ik} = \sum_{k=1}^{+\infty}\frac{\mathbf{A}(z^k)}{k}
$$

取 $\exp$ 得：

$$
\boxed{\mathbf{MSET}(\mathcal{A})=\exp\left(\sum_{k=1}^{+\infty}\frac{\mathbf{A}(z^k)}{k}\right)}
$$

我们用 $\mathbf{Exp}$ 代替 $\mathbf{MSET}$ 表示无标号可重集合组合类的生成函数，并称 $\mathbf{Exp}$ 为 Euler 变换，如果你对 Pólya 定理熟悉，也许可以看出这是 Pólya 定理的扩展。

## 无标号有根树计数

### 第一部分

考虑定义 $\mathcal{T}$ 表示无标号有根树的组合类，则有：

$$
\mathcal{T}=\mathcal{Z}\times \textsf{MSET}(\mathcal{T})
$$

其中原子对象组合类 $\mathcal{Z}$ 表示树根，可重集合 $\textsf{MSET}(\mathcal{T})$ 表示子树。

构建 $\mathcal{T}$ 的生成函数 $\mathbf{T}$，可以利用刚刚提到的 Euler 变换：

$$
\mathbf{T}(z)=z\cdot \mathbf{Exp}(\mathcal{T})=z\cdot \exp\left(\sum_{k=1}^{+\infty}\frac{\mathbf{T}(z^k)}{k}\right)
$$

### 第二部分

两边取 $\ln$：

$$
\ln \mathbf{T}(z)=\ln(z)+\sum_{k=1}^{+\infty}\frac{\mathbf{T}(z^k)}{k}
$$

两边求导：

$$
\frac{\mathbf{T}'(z)}{\mathbf{T}(z)}=\frac{1}{z}+\sum_{k=1}^{+\infty} {\mathbf{T}'(z^k)}z^{k-1}
$$

变形，得：

$$
z\mathbf{T}'(z)=\mathbf{T}(z)+\mathbf{T}(z)\sum_{k=1}^{+\infty}{\mathbf{T}'(z^k)}z^{k}
$$

令：

$$
\mathbf{F}(z)=\sum_{k=1}^{+\infty}{\mathbf{T}'(z^k)}z^{k}
$$

得到：

$$
[z^n](z\mathbf{T'}(z))=[z^n]\mathbf{T}(z)+[z^n](\mathbf{T}\ast \mathbf{F})
$$

由于 $[z^{n-1}]\mathbf{T}'(z)=n\cdot [z^n]\mathbf{T}(z)$，得到：

$$
n\cdot [z^n]\mathbf{T}(z)=[z^n]\mathbf{T}(z)+[z^n](\mathbf{T}\ast \mathbf{F})
$$

变形得：

$$
\boxed{[z^n]\mathbf{T}(z)=\frac{1}{n-1}[z^n](\mathbf{T}\ast \mathbf{F})}
$$

接下来考虑 $\mathbf{F}$，大力求导与化简，得：

$$
\begin{aligned}
\mathbf{F}(z)&=\sum_{k=1}^{+\infty}{\mathbf{T}'(z^k)}z^k\\
&=\sum_{k=1}^{+\infty}z^k\sum_{i=1}^{+\infty} ([x^i]\mathbf{T}(z))i{(z^k)}^{i-1}\\
&=\sum_{k=1}^{+\infty}\sum_{i=1}^{+\infty}([x^i]\mathbf{T}(z))iz^{ki}\\
&=\sum_{p=1}^{+\infty}z^p\sum_{i\mid p} i([x^i]\mathbf{T}(z))
\end{aligned}
$$

得到：

$$
\boxed{\mathbf{F}(z)=\sum_{p=1}^{+\infty}z^p\sum_{i\mid p} i([x^i]\mathbf{T}(z))}
$$

### 第三部分

你发现这玩意是一个半在线卷积的形式，我们可以考虑分治 FFT。

时间复杂度 $O(n\log^2 n)$。

但是我悲伤地发现，我根本就不会半在线卷积！于是我滚去学了一下。

[推荐 command_block 巨佬的博客](https://www.luogu.com/article/ufuicw30)。

## 无标号无根树计数

考虑钦定重心为根，则我们要去掉不以重心为根的情况。

先来考虑 $n\equiv 1\pmod{2}$，此时重心是唯一的，由于有根树的重心，一定位于大小至少为 $\lfloor\frac{n}{2}\rfloor+1$ 的子树内，于是可以将这个重子树看成一组，其余子树与根一起看成一组，则根不为重心的方案数为：

$$
\sum_{k=\lfloor\frac{n}{2}\rfloor+1}^{n-1} ([z^k]\mathbf{T}(z))\cdot ([z^{n-k}]\mathbf{T}(z))
$$

最后是 $2\mid n$ 的情况，此时重心可能为两个点，而根据重心的性质，这两个点必定相邻，且断掉中间的那条边后，形成的两个连通块大小一定是 $\frac{n}{2}$，每个连通块一共有 $([z^{\frac{n}{2}}])\mathbf{T}(z)$ 种，所以要减去 $\binom{([z^{\frac{n}{2}}])\mathbf{T}(z)}{2}$。

最后写一下完整的式子：

$$
([z^n]\mathbf{T}(z)) - \sum_{k=\lfloor\frac{n}{2}\rfloor+1}^{n-1} ([z^k]\mathbf{T}(z))\cdot ([z^{n-k}]\mathbf{T}(z)) - [2\mid n]\binom{([z^{\frac{n}{2}}])\mathbf{T}(z)}{2}
$$

总时间复杂度 $O(n\log^2 n)$ 可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 998244353, g = 3, ginv = 332748118, inv2 = (mod + 1) >> 1;

const int N = 1e6 + 5;

int Add(int x, int y){ return (x + y) >= mod ? (x + y - mod) : (x + y); }
int Sub(int x, int y){ return (x - y) < 0 ? (x - y + mod) : (x - y); }
int Mul(int x, int y){ return 1ll * x * y % mod; }

int fastpow(int x, int y){
    int ret = 1;
    for(;y;y>>=1,x=Mul(x,x)){
        if(y & 1) ret = Mul(ret, x);
    }
    return ret;
}

int Inv(int x){ return fastpow(x, mod-2); }

struct Poly{
    vector<int> a;
    Poly(){}
    Poly(vector<int> _a):a(_a){}
    Poly(int siz){ a.resize(siz); }
    int& operator[](int x){ return a[x]; }
    int size(){ return a.size(); }
    Poly resize(int siz){ a.resize(siz, 0); return *this; }
    void ntt(bool flag = 1);
    static int init_ntt(int n, int m);
    static Poly conv(Poly a, Poly b, function<int(int, int)> f);
};

int r[N], wt[N];

void Poly::ntt(bool flag){
    int n = size();
    for(int i=0;i<n;i++){
        if(i < r[i]) swap(a[i], a[r[i]]);
    }
    for(int i=2;i<(n<<1);i<<=1){
        int w1 = fastpow(flag ? g : ginv, (mod - 1) / i);
        for(int j=0;j<n;j+=i){
            int w = 1;
            for(int k=0;k<(i>>1);k++,w=Mul(w,w1)){
                int x = a[j + k], y = Mul(w, a[(i >> 1) + j + k]);
                a[j + k] = Add(x, y), a[(i >> 1) + j + k] = Sub(x, y);
            }
        }
    }
    if(!flag){
        int inv = Inv(n);
        for(int i=0;i<n;i++) a[i] = Mul(a[i], inv);
    }
}

int Poly::init_ntt(int n, int m){
    int c = 1, l = 0;
    while(c < (n + m)) c <<= 1, l++;
    for(int i=0;i<=c;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    return c;
}

Poly Poly::conv(Poly a, Poly b, function<int(int, int)> f){
    int n = a.size(), m = b.size();
    int c = Poly::init_ntt(n, m);
    a.resize(c), b.resize(c);
    a.ntt(), b.ntt();
    for(int i=0;i<c;i++) a[i] = f(a[i], b[i]);
    a.ntt(0), a.resize(n + m + 1);
    return a;
}

Poly operator*(Poly a, Poly b){ return Poly::conv(a, b, Mul); }

int F[N], G[N], n;

void solve(int l, int r){
    if(l == r){
        F[l] = (l == 1) ? 1 : Mul(F[l], Inv(l - 1));
        for(int i=l;i<=n;i+=l) G[i] = Add(G[i], Mul(l, F[l]));
        return;
    }
    int mid = (l + r) >> 1;
    solve(l, mid);
    Poly a(mid - l + 1), b(r - l + 1);
    for(int i=l;i<=mid;i++) a[i - l] = F[i];
    for(int i=1;i<=(l==1?mid:r-l);i++) b[i] = G[i];
    a = a * b;
    for(int i=mid+1;i<=r;i++) F[i] = Add(F[i], a[i - l]);
    if(l != 1){
        a.resize(mid - l + 1), b.resize(r - l + 1);
        for(int i=1;i<=r-l;i++) b[i] = F[i];
        for(int i=l;i<=mid;i++) a[i - l] = G[i];
        a = a * b;
        for(int i=mid+1;i<=r;i++) F[i] = Add(F[i], a[i - l]);
    }
    solve(mid + 1, r);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n;
    solve(1, n);
    int ans = F[n];
    for(int k=((n>>1)+1);k<n;k++) ans = Sub(ans, Mul(F[k], F[n - k]));
    if(!(n & 1)) ans = Sub(ans, Mul(Sub(F[n >> 1], 1), Mul(inv2, F[n >> 1])));
    cout << ans << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Otomachi_Una_ (赞：2)

## 题目简述

无标号无根树计数。$n\leq2\times10^5$。

## 解题思路

### charp1. 约定与预备知识

- 没有特殊说明，对于多项式 $F$，记 $F$ 中 $x^i$ 的系数为 $f_i$，$g,h$ 同理。下文中可能单独出现 $F^t$ 等类似情况，均试做 $F^t(x)$。

- 如果下文当中有明确指出「指数生成函数（EGF）」，那么 $F=\sum \dfrac{f_i}{i!} x^i$，$G,H$ 同理。

- 预备知识：**指数生成函数** $F$ 的 $\exp$ 形式的组合意义为「$n$ 元**有标号**元素分组，大小为 $i$ 的组内部有 $f_i$ 的情况的方案数」。感性证明：

- $$
  \exp F=\sum \dfrac{F^i}{i!}
  $$

- 展开上面的式子，观察每一项不难证明。

### charp 2. Euler 变换

上面我们的式子是**有标号**计数，对于无标号计数可以考虑先欧拉变换。我们只关注每一个大小相同的组内部的总体分配情况，而不是单个组。我们可以尝试枚举每种方案选择的次数，不难得到这样的生成函数：
$$
\xi(F)=\prod_{i=1}^{+\infty} (\dfrac{1}{1-x^i})^{f_i}
$$
发现这时候原来在系数的 $f$ 变换到了指数上去，感觉不太好用的样子。我们可以考虑化简一下，对 $\xi(F)$ 使用 $\ln$ 把 $f_i$ 变回系数：
$$
\begin{aligned} \ln \xi(F)&=\sum_{i=1}^{+\infty}(-f_i\times \ln(1-x^i))\\&=\sum_{i=1}^{+\infty}-f_i\times∫\dfrac{-ix^{i-1}}{1-x^i}\\&=\sum_{i=1}^{+\infty}-f_i\times∫-ix^{i-1}(1+x^i+x^{2i}+\dots)\\&=\sum_{i=1}^{+\infty} f_i\times \sum_{j=1}^{+\infty}\dfrac1jx^{ij}\\&=\sum_{j=1}^{+\infty}\dfrac{F(x^j)}{j} \end{aligned}
$$
好看了不少。

### charp 3. 无标号有根树计数

假设无标号有根树的生成函数为 $F$。则 $F=x·\xi(F)$。这里的含义是当我们确定一个点作为根的时候

，那么相当于给其他元素分组，大小为 $i$ 的组内部有 $f_i$ 的情况。我们考虑解这个方程，首先对两边求导：
$$
\begin{aligned}F'&=x\xi'(F)+\xi(F)\\&=x·\exp'(\sum_{j=1}^{+\infty} \dfrac{F(x^j)}{j})+\dfrac{F}{x}\\&=x·(\sum_{j=1}^{+\infty}\dfrac{F(x^j)}{j})'·\exp(\ln \xi(F))+\dfrac{F}{x}\\&=F\times(\sum_{j=1}^{+\infty}F'(x^j)x^{j-1})+\dfrac Fx\end{aligned}
$$
两边同时乘上 $x$ 会好看一些，变成：
$$
ϑF=F\times(\sum_{j=1}^{+\infty}F'(x^j)x^j)+F
$$
假设 $G=\sum_{j=1}^{+\infty}F'(x^k)·x^k$，不难得到 $g_n=\sum_{d|n} d\times f_n$，由上式
$$
n\times f_n=\sum_{i=1}^{n-1} f_ig_{n-i}+f_n
$$
即：
$$
f_n=\dfrac{1}{n-1}\sum_{i=1}^{n-1} f_ig_{n-i}
$$
使用半在线卷积求解即可。

### charp 4. 实现细节

有些同学可能不会半在线卷积，这里简要提一嘴。首先根据 [P4721 【模板】分治 FFT](https://www.luogu.com.cn/problem/P4721) 的基本思路，我们可以 cdq 分治，这里 $g$ 是固定的，所以对于区间 $f[l,mid]$ 到 $f[mid+1,r]$ 的贡献只要卷上 $g[0,r-l]$ 即可。但是本题当中有个问题，就是可能 $f[mid+1,r]$ 会影响到 $g[0,r-l]$，这时候我们只要考虑 $mid+1\leq r-l$ 当且仅当 $l=1$，所以我们可以把 $l=1$ 我们只能卷 $f[l,mid],g[l,mid]$ 其他我们后面补回来，即当 $l\not=1$ 时，卷上 $f[l,mid],g[0,r-l]$ 和 $g[l,mid],f[0,r-l]$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
#define vll vector<long long>
const int MAXN=4e5+5;
const int MOD=998244353;
namespace polynomial{// yjl poly plank 2.0 ver?
int bfly[MAXN];ll inver[MAXN];
int clogg(int x){return (int)ceil(log2(x));} 
ll ksm(ll a,int b){ll res=1;while(b){if(b&1)res=res*a%MOD;a=a*a%MOD,b>>=1;}return res;}
void butterfly(int l){
	static int las;
	if(las!=l){
		las=l; 
		for(int i=1;i<(1<<l);i++)
			bfly[i]=(bfly[i>>1]>>1)|((i&1)<<l-1);
	} 
}
void NTT(vll &f,int l,int typ){
	butterfly(l);f.resize(1<<l);
	for(int i=0;i<(1<<l);i++)
		if(bfly[i]<i) swap(f[i],f[bfly[i]]);
	for(int i=0;i<l;i++){
		ll step=ksm(3,MOD-1+(MOD-1>>i+1)*typ);
		for(int j=0;j<(1<<l);j+=(1<<i+1)){
			ll cur=1;
			for(int k=j;k<j+(1<<i);k++){
				ll u=f[k],v=f[k+(1<<i)]*cur%MOD;
				f[k]=(u+v)%MOD;f[k+(1<<i)]=(u-v+MOD)%MOD;
				cur=cur*step%MOD;
			}
		}
	}
	if(typ==-1){
		ll val=ksm(1<<l,MOD-2);
		for(int i=0;i<(1<<l);i++)
			f[i]=val*f[i]%MOD;
	}
	return;
}
}using namespace polynomial;
int n;
vll f,g;
void solve(int l,int r){
	if(l==r){
		if(l!=1) f[l]=f[l]*ksm(l-1,MOD-2)%MOD;
		for(int i=l;i<=n;i+=l)
			g[i]+=f[l]*l%MOD,g[i]%=MOD;
		return;
	}
	int mid=l+r>>1;
	solve(l,mid);
	if(l==1){
		vll _f=vll(begin(f)+l,begin(f)+mid+1),_g=vll(begin(g),begin(g)+mid+1);
        int k=clogg(_f.size()+_g.size());
		NTT(_f,k,1);NTT(_g,k,1);
		for(int i=0;i<(1<<k);i++) _f[i]=_f[i]*_g[i]%MOD;
		NTT(_f,k,-1);
		for(int i=mid+1;i<=r;i++)
			f[i]+=_f[i-l],f[i]%=MOD;
		solve(mid+1,r);
		return;
	}
	vll _f=vll(begin(f)+l,begin(f)+mid+1),_g=vll(begin(g),begin(g)+r-l+1);
	int k=clogg(_f.size()+_g.size());
	NTT(_f,k,1);NTT(_g,k,1);
	for(int i=0;i<(1<<k);i++) _f[i]=_f[i]*_g[i]%MOD;
	NTT(_f,k,-1);
	for(int i=mid+1;i<=r;i++)
		f[i]+=_f[i-l],f[i]%=MOD;
	_f=vll(begin(f),begin(f)+r-l+1),_g=vll(begin(g)+l,begin(g)+mid+1);
	k=clogg(_f.size()+_g.size());
	NTT(_f,k,1);NTT(_g,k,1);
	for(int i=0;i<(1<<k);i++) _f[i]=_f[i]*_g[i]%MOD;
	NTT(_f,k,-1);
	for(int i=mid+1;i<=r;i++)
		f[i]+=_f[i-l],f[i]%=MOD;
	solve(mid+1,r);
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n;f.resize(n+1),g.resize(n+1);
	f[1]=1;
	solve(1,n);
	ll ans=f[n];
	for(int i=1;i<=(n-1)/2;i++) ans-=f[i]*f[n-i]%MOD;
	if(n%2==0) ans-=f[n/2]*(f[n/2]-1)/2%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```



---

## 作者：C　C　A (赞：2)

## 欧拉变换

考虑求解形如下式的 $\rm OGF$ ：

$$F_i(x) = \left(\sum _ j x ^ {ji}\right) ^ {f _ i} =  \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i}$$

$$\varepsilon\circ F(x) = \prod _ i F_i(x) = \prod _ i \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i}$$

这个 $\rm OGF$ 的组合意义是将 $n$ 个互不区分的小球分进若干个非空集合，大小为 $i$ 的集合有 $f_i$ 种方案的总方案数。  

注意到上式右边是连乘，于是对其取 $\ln :$

$$\begin{aligned}
    \ln \varepsilon \circ F(x) &= \sum _ i \ln \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i}\\
    &= \sum _ i f_i \times \ln\left(\frac{1}{1 - x ^ i}\right)\\
    &= -\sum _ i f_i \times \ln (1 - x ^ i)\\
    &= \sum _ i \sum _ j \frac{f_i}{j + 1} x ^ {i(j + 1)}
\end{aligned}$$

由于我们一般只需求生成函数的前 $n$ 项，观察到 $i$ 和 $j$ 的枚举构成了调和级数的关系，可以直接暴力计算。

最后将求出的幂级数 $\rm exp$ 回去即可得到 $\varepsilon \circ F(x).$

时间复杂度 $\Theta(n \log n).$

## 无标号无根树计数

考虑设 $f_n$ 表示大小为 $n$ 的无标号有根树的方案数，$F(x)$ 为数列 $f$ 的生成函数。

可以发现，如果将一颗大小为 $n$ 的无标号有根树的根去除，那么剩下的子树是一个个相同的子问题，只要子树大小的和为 $n - 1$，再加上根结点就可以唯一确定地拼出一颗无标号有根树。于是有生成函数方程 ：

$$F(x) = x \cdot \varepsilon \circ F(x)$$

求解这个生成函数方程有两种方法，第一种是直接化简，分治多项式乘法求解 ：

$$F(x) = x \prod _ i (1 - x ^ i) ^ {-f_i}$$

考虑对两边取 $\ln$，将连乘转连加 ：

$$\ln F(x) = \ln x - \sum _ i f_i \ln (1 - x ^ i)$$

对数不好处理，考虑求导 ：

$$\frac{F'(x)}{F(x)} = \frac{1}{x} + \sum _ i if_i \times \frac{x ^ {i - 1}}{1 - x ^ i}$$

将两边同时乘以 $xF(x)$ ：

$$xF'(x) = F(x) + F(x) \sum _ i if_i \frac{x ^ i}{1 - x ^ i}$$

考虑将右半部分还原成 $F(x)$ 表示 ：

$$xF'(x) = F(x) + F(x)\left(\sum _ {i \geqslant 1} x ^ i F'(x ^ i)\right)$$

设 $G(x) = \sum _ k x ^ k F'(x ^ k)$，简单推一推 ：

$$G(x) = \sum _ k x ^ k \sum _ {i\geqslant 1} if _ i \left(x ^ {k}\right) ^ {i - 1} = \sum _ k \sum _ i i f _ i x ^ {ik} = \sum _ n x ^ n \sum _ {d | n} d f _ d$$

故 $g_n = \sum _ {d | n} df_d,g_1 = f_1 = 1.$

因此 ：

$$f_n = \frac{1}{n - 1} \sum _ {k = 1} ^ {n - 1} f _ k g _ {n - k}$$

$f$ 使用分治多项式乘法求解，$g$ 暴力求解即可做到 $\Theta(n \log ^ 2 n).$

另一种方法是使用牛顿迭代 ：

显然我们要求解方程 $G \circ F(x) = F(x) - x \cdot \varepsilon \circ F(x) = 0$.

假设当前已经求出了方程在模 $x ^ n$ 意义下的解 $F_0(x)$，设方程在模 $x ^ {2n}$ 意义下的解为 $F(x)$，众所周知有 ：

$$F(x) = F_0(x) - \frac{G \circ F_0(x)}{G' \circ F_0(x)}$$

首先考虑化简 $G'(F)$ ：

$$\begin{aligned}
    G'(F) &= [F - x \cdot \varepsilon (F)]'\\
    &= F' - \varepsilon (F) - x \varepsilon'(F)\\
    &= F' - \varepsilon (F) - x \varepsilon (F) \ln ' \varepsilon (F)\\
\end{aligned}$$

我们知道，$\varepsilon \circ F(x)$ 和 $\ln \varepsilon \circ F(x)$ 都可以在 $\Theta(n \log n)$ 的时间复杂度内求出，$F'(x)$ 可以 $\Theta(n)$ 求，所以可以在 $\Theta(n \log n)$ 的时间复杂度内求下式 ：

$$F(x) = F_0(x) - \frac{F_0(x)  - x \cdot \varepsilon \circ F_0(x)}{F_0'(x) - \varepsilon \circ F_0(x) - x\cdot \varepsilon \circ F_0(x) \cdot \ln' \varepsilon \circ F_0(x)}$$

用上式迭代即可算出 $F(x)$，时间复杂度 $\Theta(n \log n).$

现在我们已经求出了无标号有根树的方案数，考虑将无标号无根树的方案数容斥出来。

考虑钦点无标号无根树的根是它的重心，于是只需要去掉根不是重心的无标号有根树的方案数可以了，分类讨论 ：

如果重心唯一，那么一定存在一颗子树的大小大于 $\left\lfloor\frac{n}{2}\right\rfloor$，考虑枚举它的大小 $i$，容易发现这颗子树的方案数和将它切除后树的方案数都是无标号有根树计数问题，其答案我们已经算出，于是总方案数需要减去 $\sum _ {i = \left\lfloor\frac{n}{2}\right\rfloor + 1} ^{n - 1} f_i \times f_{n - i}.$

如果重心不唯一，那么一棵树还会在两个重心上分别被计算，这种方案只会在 $n$ 为偶数的情况下出现。考虑到这两个重心一定相连，于是将它们之间的连边断开后形成的两个子树的方案数是独立的。但是我们发现，当两颗子树完全相同时，分别以它的两个重心为根时形成的有根树是同构的，所以我们还是只会将它计算一次，故算重的方案中不包括两颗子树相同的情况，于是总方案数还需要减去 $\binom{f_{\frac{n}{2}}}{2}.$

综上，问题得到解决，时间复杂度为 $\Theta(n \log ^ 2 n)$ 或 $\Theta(n \log n).$

---

## 作者：5k_sync_closer (赞：0)

不懂为啥都要对原式神秘转化之后再牛顿迭代，直接对原式牛顿迭代即可！完全不用转化！

设无标号有根树的组合类是 $\mathcal T$，则有  $\mathcal T=\mathcal Z\times\mathrm{MSET}(\mathcal T)$，即 $T(x)=x\exp\sum\limits_{j\ge1}\dfrac{T(x^j)}j$，

设 $G(F(x))=F(x)-x\exp\sum\limits_{j\ge1}\dfrac{F(x^j)}j=0$，要求 $F(x)\bmod x^n$，问题变为牛顿迭代的形式。

首先钦定 $F(x)\bmod x^1=[x^0]F(x)=0$（否则 $\exp\sum\limits_{j\ge1}\dfrac{F(x^j)}j$ 的常数项不收敛），

然后假设已经求出模 $x^{\frac n2}$ 意义下的解 $F_0(x)$，则模 $x^n$ 意义下的解 $F(x)\equiv F_0(x)-\dfrac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}$，

考虑如何求 $G'(F_0(x))$。

观察到 $G(F_0(x))=F_0(x)-x\exp F_0(x)\exp\sum\limits_{j\ge2}\dfrac{F_0(x^j)}j$，

设最终答案是 $H(x)$（这里 $H(x)$ 是与 $F_0(x)$ 无关的常量），

则 $\forall j\ge2$，有 $F_0(x^j)\equiv H(x^j)\pmod{x^n}$，则 $\exp\sum\limits_{j\ge2}\dfrac{F_0(x^j)}j\equiv\exp\sum\limits_{j\ge2}\dfrac{H(x^j)}j\pmod{x^n}$，

于是 $\exp\sum\limits_{j\ge2}\dfrac{F_0(x^j)}j$ 是与 $F_0(x)$ 无关的常量，

则 $G'(F_0(x))=1-x\exp F_0(x)\exp\sum\limits_{j\ge2}\dfrac{F_0(x^j)}j=1-x\exp\sum\limits_{j\ge1}\dfrac{F_0(x^j)}j$，

于是 $F(x)\equiv F_0(x)-\dfrac{G(F_0(x))}{G'(F_0(x))}\equiv F_0(x)-\dfrac{F_0(x)-x\exp\sum\limits_{j\ge1}\dfrac{F_0(x^j)}j}{1-x\exp\sum\limits_{j\ge1}\dfrac{F_0(x^j)}j}\pmod{x^n}$。

现在我们会算无标号有根树了，设 $f_i$ 表示 $i$ 个点的无标号有根树个数，考虑怎么算无标号无根树。

$n$ 为奇数时，每个无标号无根树都有唯一的重心，所以只需统计根为重心的无标号有根树个数，

考虑用 $f_n$ 减去根不为重心的无标号有根树个数，这些树一定有一棵大小超过 $\left\lfloor\dfrac n2\right\rfloor$ 的子树，

枚举这棵子树的大小，则答案为 $f_n-\sum\limits_{i=\left\lfloor\frac n2\right\rfloor+1}^{n-1}f_i\times f_{n-i}$。

$n$ 为偶数时，考虑用同样的计数方法，

发现有两个重心的树，即有一棵大小为 $\dfrac n2$ 的子树的树，可能会被重复统计，

设这棵大小为 $\dfrac n2$ 的子树为 $T$，若原树去掉 $T$ 后剩下的树与 $T$ 完全一致，

则原树分别以两个重心为根形成的有根树完全一致，这样的树不会被重复统计，

反之若原树去掉 $T$ 后剩下的树与 $T$ 不同，这样的树就会被重复统计，

所以从大小为 $\dfrac n2$ 的有根树中任选出两棵，就可以组合出一种被重复统计的树，

所以有 $f_{\frac n2}\choose2$ 种被重复统计的树，答案减去 $f_{\frac n2}\choose2$ 即可。

没有封装多项式类，所以代码比较混乱邪恶，建议谨慎阅读。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
#define G 3
#define _G 332748118
#define M 998244353
using namespace std;
int n, l, r[6000050], f[6000050], g[6000050], h[6000050], x[6000050], y[6000050], z[6000050], k[6000050], v[6000050];
int P(int x, int y)
{
    int q = 1;
    for (; y; y >>= 1, x = x * x % M)
        if (y & 1)
            q = q * x % M;
    return q;
}
void F(int *f, int n, int v)
{
    for (int i = 0; i < n; ++i)
        if (i < r[i])
            swap(f[i], f[r[i]]);
    for (int L = 2, m; L <= n; L <<= 1)
    {
        m = L >> 1;
        int W = P(v == 1 ? G : _G, (M - 1) / L);
        for (int l = 0, r = L - 1; r <= n; l += L, r += L)
        {
            int o = 1;
            for (int p = l; p < l + m; ++p)
            {
                int x = f[p], y = f[p + m];
                f[p] = (x + o * y) % M, f[p + m] = (x + M - o * y % M) % M;
                o = o * W % M;
            }
        }
    }
}
void I(int *f, int *g, int n)
{
    memset(g, 0, n << 4);
    memset(x, 0, n << 4);
    g[0] = P(f[0], M - 2);
    int L;
    for (L = 4;; L <<= 1)
    {
        memcpy(x, f, L << 2);
        memcpy(y, g, L << 3);
        l = __lg(L);
        for (int i = 0; i < L; ++i)
            r[i] = r[i >> 1] >> 1 | (i & 1) << l - 1;
        F(x, L, 1);
        F(y, L, 1);
        for (int i = 0; i < L; ++i)
            x[i] = x[i] * y[i] % M;
        F(x, L, -1);
        int _ = P(L, M - 2);
        for (int i = 0; i < L; ++i)
            x[i] = (M - x[i] * _ % M) % M;
        x[0] = (x[0] + 2) % M;
        memset(x + (L >> 1), 0, L << 2);
        F(g, L, 1);
        F(x, L, 1);
        for (int i = 0; i < L; ++i)
            g[i] = g[i] * x[i] % M;
        F(g, L, -1);
        for (int i = 0; i < L; ++i)
            g[i] = g[i] * _ % M;
        if (L >> 1 >= n)
            break;
    }
    memset(g + n, 0, L - n << 3);
}
void LN(int *f, int *g, int n)
{
    memset(h, 0, n << 4);
    for (int i = 0; i < n - 1; ++i)
        h[i] = (i + 1) * f[i + 1] % M;
    I(f, g, n);
    int L = 1;
    while (L >> 1 < n)
        L <<= 1;
    l = __lg(L);
    for (int i = 0; i < L; ++i)
        r[i] = r[i >> 1] >> 1 | (i & 1) << l - 1;
    F(g, L, 1);
    F(h, L, 1);
    for (int i = 0; i < L; ++i)
        h[i] = g[i] * h[i] % M;
    F(h, L, -1);
    int _ = P(L, M - 2);
    for (int i = 0; i < L; ++i)
        h[i] = h[i] * _ % M;
    g[0] = 0;
    for (int i = 1; i < n; ++i)
        g[i] = h[i - 1] * P(i, M - 2) % M;
    memset(g + n, 0, L - n << 3);
}
void EXP(int *f, int *g, int n)
{
    memset(g, 0, n << 4);
    g[0] = 1;
    int L;
    for (L = 4;; L <<= 1)
    {
        LN(g, z, L >> 1);
        for (int i = 0; i < L >> 1; ++i)
            z[i] = (f[i] + M - z[i]) % M;
        z[0] = (z[0] + 1) % M;
        l = __lg(L);
        for (int i = 0; i < L; ++i)
            r[i] = r[i >> 1] >> 1 | (i & 1) << l - 1;
        F(g, L, 1);
        F(z, L, 1);
        for (int i = 0; i < L; ++i)
            g[i] = g[i] * z[i] % M;
        F(g, L, -1);
        int _ = P(L, M - 2);
        for (int i = 0; i < L; ++i)
            g[i] = g[i] * _ % M;
        memset(g + (L >> 1), 0, L << 2);
        if (L >> 1 >= n)
            break;
    }
    memset(g + n, 0, L - n << 3);
}
signed main()
{
    v[1] = 1;
    for (int i = 2; i <= 6e6; ++i)
        v[i] = (M - M / i) * v[M % i] % M;
    scanf("%lld", &n), ++n;
    for (int L = 4;; L <<= 1)
    {
        memset(g, 0, L << 2);
        for (int i = 1; i < L >> 2; ++i)
            for (int j = i; j < L >> 1; j += i)
                g[j] = (g[j] + f[i] * i % M * v[j]) % M;
        EXP(g, k, L >> 1);
        for (int i = (L >> 1) - 1; i >= 1; --i)
            k[i] = (M - k[i - 1]) % M;
        k[0] = 1;
        I(k, g, L >> 1);
        k[0] = 0;
        for (int i = 1; i < L >> 2; ++i)
            k[i] = (k[i] + f[i]) % M;
        F(g, L, 1);
        F(k, L, 1);
        for (int i = 0; i < L; ++i)
            g[i] = g[i] * k[i] % M;
        F(g, L, -1);
        int _ = P(L, M - 2);
        for (int i = 0; i < L; ++i)
            g[i] = g[i] * _ % M;
        for (int i = 0; i < L >> 1; ++i)
            f[i] = (f[i] + M - g[i]) % M;
        if (L >> 1 >= n)
            break;
    }
    --n;
    int q = f[n];
    for (int i = (n >> 1) + 1; i < n; ++i)
        q = (q + M - f[i] * f[n - i] % M) % M;
    if (!(n & 1))
    {
        int u = f[n >> 1];
        q = (q + M - u * (u - 1) % M * (M + 1 >> 1) % M) % M;
    }
    printf("%lld", q);
    return 0;
}
```

---


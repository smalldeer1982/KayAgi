# 「EZEC-7」线段树

## 题目背景

Bob 喜欢线段树。


## 题目描述

如果你不知道线段树，可以看 提示说明 中的定义。

Bob 得到了一个长度为 $n$ 的序列 $a_{1,2,\cdots,n}$，初始全为 $0$。

接着 Bob 进行了 $m$ 次区间加操作，每次操作会等概率地从 $[1,n]$ 的所有 $\dfrac{n(n+1)}{2}$ 个子区间中随机选择一个进行操作，每次加的数是 $[-1,V]$ 之间等概率随机的整数。

$m$ 次操作完之后要求出每一个位置的值。

由于 Bob 喜欢线段树，他熟练地打出一颗 $[1,n]$ 上的线段树来解决这个问题，使用懒惰标记来解决区间加的问题。

打代码的过程中 Bob 忽然想到了两个减小 $\mathrm{Pushdown}$（下传懒惰标记）次数的方法：

+ 修改的时候不 $\mathrm{Pushdown}$，最后一次性 $\mathrm{Pushdown}$（即 $\mathrm{Pushall}$ 函数）。

+ $\mathrm{Pushall}$ 到一个节点的时候，如果这个节点的懒惰标记为 $0$ 那么不 $\mathrm{Pushdown}$。

现在 Bob 想知道期望 $\mathrm{Pushdown}$ 次数，可是他不会算，于是来问你。

下面是 Bob 写的线段树伪代码（其中 `tag` 数组为懒惰标记）：

$
\displaystyle
\begin{array}{l}
\mathrm{pushdown\_counter}\leftarrow 0\\
\\
\textbf{function }\mathrm{Update(Node},l,r,ql,qr,Delta)\\
\qquad \textbf{if } [l,r]\cap [ql,qr] = \varnothing \textbf{ then}\\
\qquad \qquad \textbf{return}\\
\qquad \textbf{end if}\\
\qquad \textbf{if }[l,r] \subseteq [ql,qr] \textbf{ then}\\
\qquad \qquad \mathrm{tag[Node]\leftarrow tag[Node]}+Delta\\
\qquad \qquad \textbf{return}\\
\qquad \textbf{end if}\\
\qquad mid\leftarrow \lfloor\dfrac{l+r}{2}\rfloor\\
\qquad \mathrm{Update(LeftChild},l,mid,ql,qr,Delta)\\
\qquad \mathrm{Update(RightChild},mid+1,r,ql,qr,Delta)\\
\textbf{end function}\\
\\
\textbf{function }\mathrm{Pushdown(Node)} \\
\qquad \mathrm{tag[LeftChild]\leftarrow tag[LeftChild]+tag[Node]}\\
\qquad \mathrm{tag[RightChild]\leftarrow tag[RightChild]+tag[Node]}\\
\qquad \mathrm{pushdown\_counter}\leftarrow \mathrm{pushdown\_counter}+1\\
\textbf{end function}\\
\\
\textbf{function }\mathrm{Pushall(Node},l,r)\\
\qquad \textbf{if } \mathrm{Node\ is\ Leaf} \textbf{ then}\\
\qquad \qquad \textbf{return}\\
\qquad \textbf{end if}\\
\qquad \textbf{if } \mathrm{tag[Node] \not= 0} \textbf{ then}\\
\qquad \qquad \mathrm{Pushdown(Node)}\\
\qquad \textbf{end if}\\
\qquad mid\leftarrow \lfloor\dfrac{l+r}{2}\rfloor\\
\qquad \mathrm{Pushall(LeftChild},l,mid)\\
\qquad \mathrm{Pushall(RightChild},mid+1,r)\\
\textbf{end function}
\end{array}
$


换句话说，你要帮 Bob 求出 `pushdown_counter` 的期望值。

答案对 $998244353$ 取模。


## 说明/提示

**【样例解释 #1】**

整颗线段树只有 $3$ 个节点：$[1,2],[1,1],[2,2]$。

只有节点 $[1,2]$ 可能 $\mathrm{Pushdown}$。

当操作为 $\mathrm{Update(1,2,-1)}$ 的时候，根节点的懒惰标记为 $-1$， $\mathrm{Pushall}$ 在根号节点会 $\mathrm{Pushdown}$；而 $\mathrm{Update(1,2,0)}$ 之后，由于根节点懒惰标记为 $0$ 不 $\mathrm{Pushdown}$。

其余 $4$ 种操作均把懒惰标记打在叶子节点，即 $\mathrm{Update(1,1,-1)},\mathrm{Update(1,1,0)},\mathrm{Update(2,2,-1)},\mathrm{Update(2,2,0)}$，不会 $\mathrm{Pushdown}$。

所以，总共 $6$ 种情况，能 $\mathrm{Pushdown}$ 的只有 $1$ 种，期望次数为 $\dfrac{1}{6}$。

**【样例解释 #2】**

由于情况过多，不一一解释，只解释一种情况。

如果执行的 $2$ 次操作分别为 $\mathrm{Update(1,2,-1)},\mathrm{Update(1,2,1)}$，由于这时候根节点的懒惰标记为 $0$，在 $\mathrm{Pushall}$ 的时候仍然不会 $\mathrm{Pushdown}$。

---------

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | $n\le$       | $m\le$       | $V$               | 分值 | 时间限制$\text{ / ms}$ |
| :----: | :------------: | :------------: | :-----------------: | :----: | :--------: |
| $1$        | $4$  | $4$   | $\le 2$         | $3$  | $500$    |
| $2$        | $300$ | $300$ | $\le 300$       | $7$  | $500$    |
| $3$        | $1000$ | $1000$ | $\le 1000$      | $10$ | $500$    |
| $4$       | $300$  | $10^5$ | $=1000$          | $15$ | $2000$   |
| $5$        | $10^5$ | $10^5$ | $\le 0$         | $10$ | $3000$   |
| $6$        | $10^5$ | $10^5$ | $=1000$          | $15$ | $3000$   |
| $7$        | $10^5$ | $10^5$ | $\le 998244350$ | $40$ | $3000$   |


对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le m \le 10^5$，$-1 \le V \le 998244350$。

----------

**【线段树定义】**

线段树是一棵每个节点上都记录了一个线段的二叉树。根节点记录的线段是 $[1, n]$。对于每个节点，若它记录的线段是 $[l, r]$ 且 $l\not= r$，取 $m = \lfloor \dfrac{l+r}{2} \rfloor$，则它的左右儿子节点记录的线段分别是 $[l, m]$ 和 $[m+1,r]$；若 $l=r$，则它是叶子节点。


## 样例 #1

### 输入

```
2 1 0
```

### 输出

```
166374059
```

## 样例 #2

### 输入

```
2 2 1
```

### 输出

```
813384288
```

## 样例 #3

### 输入

```
3 2 1
```

### 输出

```
462150164
```

## 样例 #4

### 输入

```
100 114 514
```

### 输出

```
718571152
```

# 题解

## 作者：tommy0221 (赞：9)

出题人题解。

为了方便把 $V$ 加 $2$。

一个节点 $[l,r]$ 能 $\mathrm{Pushdown}$ 当且仅当所有覆盖它的修改加起来不等于 $0$ 。

一次操作它被覆盖的期望为 $p=\dfrac{l\times(n-r+1)}{\frac{n(n+1)}{2}}$ 。

设覆盖 $k$ 次，加起来为 $0$ 的方案数为 $f(k)$ 。
$$
f(k)=[x^0](x^{-1}+1+x+x^2+\cdots+x^{V-2})^k
$$

一个节点对于答案的贡献就是

$$
S=\sum_{i=0}^{m}p^i(1-p)^{m-i}\binom{m}{i}\dfrac{V^i-f(i)}{V^i}
$$

把 $\dfrac{p}{1-p}$ 看做参数，可以得到一个多项式。

发现总共只有 $n-1$ 个点（线段树非叶节点个数），多点求值就好了，非常简便。

当然也可以不用这个科技，验题人给了个常数较小的分治FFT做法，稍微推推式子就好了。

现在唯一剩下的问题是计算 $k\in [0,m]$ 的 $f(k)$ 。

### 方法一

$$
f(k)=[x^k](1+x+x^2+x^3+\cdots+x^{V-1})^k
$$
$$
=[x^k](\frac{1-x^{V}}{1-x})^k
$$
$$
(1-x^V)^k=\sum_{i=0}\binom{k}{i}x^{iV}(-1)^i
$$
$$
(1-x)^{-k}=\sum_{i=0}\binom{k+i-1}{i}x^{i}
$$
$$
f(k)=\sum_{i=0}^{\frac{k}{V}}\binom{k}{i}(-1)^i\binom{2k-Vi-1}{k-1}
$$

复杂度 $O(\dfrac{m^2}{V})$ 。

### 方法二

设 

$$
F(x)=1+x+x^2+\cdots+x^{V-1}
$$
$$
G(x)=\dfrac{x}{F(x)}
$$

我们要求的是 $[x^0]\left(\dfrac{F(x)}{x}\right)^k$，即 $[x^0]G^{-k}(x)$。

可以发现 $G(x)$ 没有常数项且一次项系数不为 $0$ 。令 $G(x)$ 的复合逆为 $H(x)$ 。

根据EI鸽鸽在员交课件里的《另类拉格朗日反演》一节里的一个式子（感谢 EI 的指导。证明可以看验题人题解，大概是普通拉反证明第一步两边 $k$ 次幂）：

若 $G,H$ 互为复合逆，那么
$$
[x^n]G^k=[x^{-k-1}]H'H^{-n-1}
$$

带进去就得到

$$
[x^0]G^{-k}(x)=[x^k]\dfrac{H'(x)}{\frac{H(x)}{x}}
$$

只要算出 $H(x)$ 就好了。

注意到
$$
G(x)=\dfrac{x}{F(x)}=\dfrac{x-x^2}{1-x^V}
$$

相当于要求一个 $H(x)$ 满足

$$
\dfrac{H(x)-H^2(x)}{1-H^{V}(x)}\equiv x
$$

化简一下：

$$
H(x)-H^2(x)-x+xH^V(x)\equiv 0
$$

牛顿迭代即可，复杂度 $O(n\log n)$  （$n,m$ 视为同阶）。

综上，使用方法二，复杂度为 $O(n\log^2 n)$ 。

思维难度应该不是很大，有点板子，放 E 应该差不多吧。

upd：上面那句话是赛前写的，不想删掉/wq。但是原本确实是为了放一个简单一点的 E 才选了这题的，没想到场上最高 $30$。。。

所有点的时限至少为验题人代码 3 倍，std 2 倍多，并且我的板子不算很快，还有极大的优化空间，我用我写过最慢的板子都能过，所以应该不会有人被卡常了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define mkp(x,y) make_pair(x,y)
#define pb(x) push_back(x)
#define sz(v) (int)v.size()
typedef long long LL;
typedef double db;
template<class T>bool ckmax(T&x,T y){return x<y?x=y,1:0;}
template<class T>bool ckmin(T&x,T y){return x>y?x=y,1:0;}
#define rep(i,x,y) for(int i=x,i##end=y;i<=i##end;++i)
#define per(i,x,y) for(int i=x,i##end=y;i>=i##end;--i)
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return f?x:-x;
}
const int N=200005;
const int M=N<<2;
int n,m,V,f[M],a[N<<1],tot,IV,c[N],b[N<<1],ans,P[N];
#define mod 998244353
namespace math{
int inv[N],fac[N],ifc[N];
inline int qpow(int n,int k){int res=1;for(;k;k>>=1,n=1ll*n*n%mod)if(k&1)res=1ll*n*res%mod;return res;}
inline void fmod(int&x){x-=mod,x+=x>>31&mod;}
inline int comb(int n,int m){return n<m?0:1ll*fac[n]*ifc[m]%mod*ifc[n-m]%mod;}
void initmath(const int&n=N-1){
	inv[1]=1;for(int i=2;i<=n;++i)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
	fac[0]=1;for(int i=1;i<=n;++i)fac[i]=1ll*i*fac[i-1]%mod;
	ifc[n]=qpow(fac[n],mod-2);for(int i=n-1;i>=0;--i)ifc[i]=1ll*(i+1)*ifc[i+1]%mod;
}
}
using namespace math;

namespace poly{

int rev[M],lg,lim,rt[M];
void initpoly(const int&n){
	for(lg=0,lim=1;lim<=n;++lg,lim<<=1);
	for(int i=0;i<lim;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<(lg-1));
	for(int i=1;i<lim;i<<=1){
		const int w=qpow(3,(mod-1)/(i<<1));
		rt[i]=1;
		for(int j=1;j<i;++j)rt[i+j]=1ll*rt[i+j-1]*w%mod;
	}
}
void NTT(int*a,int op){
	if(!op)reverse(a+1,a+lim);
	for(int i=0;i<lim;++i)
		if(i>rev[i])swap(a[i],a[rev[i]]);
	for(int i=1;i<lim;i<<=1){
		for(int j=0;j<lim;j+=i<<1){
			for(int k=0;k<i;++k){
				const int X=a[j+k],Y=1ll*rt[i+k]*a[i+j+k]%mod;
				fmod(a[j+k]=X+Y),fmod(a[i+j+k]=X-Y+mod);
			}
		}
	}
	if(op)return;const int ilim=qpow(lim,mod-2);
	for(int i=0;i<lim;++i)a[i]=1ll*a[i]*ilim%mod;
}
#define clr(a,n) memset(a,0,sizeof(int)*(n))
#define cpy(a,b,n) memcpy(a,b,sizeof(int)*(n))
void poly_mul(int*f,int*g,int*ans,int n,int m){
	static int A[M],B[M];initpoly(n+m);
	cpy(A,f,n),clr(A+n,lim-n),NTT(A,1);
	cpy(B,g,m),clr(B+m,lim-m),NTT(B,1);
	for(int i=0;i<lim;++i)A[i]=1ll*A[i]*B[i]%mod;
	NTT(A,0),cpy(ans,A,n+m-1);
}
void dao(int*g,int*f,int n){
	for(int i=0;i<n-1;++i)g[i]=1ll*(i+1)*f[i+1]%mod;g[n-1]=0;
}
void poly_inv(int*g,int*f,int n){
	static int A[M],B[M];
	if(n==1)return g[0]=qpow(f[0],mod-2),void();
	int m=(n+1)>>1;
	poly_inv(g,f,m),initpoly(n<<1);
	cpy(A,f,n),clr(A+n,lim-n),cpy(B,g,m),clr(B+m,lim-m);
	NTT(A,1),NTT(B,1);
	for(int i=0;i<lim;++i)A[i]=1ll*B[i]*(2-1ll*A[i]*B[i]%mod+mod)%mod;
	NTT(A,0),cpy(g,A,n);
}

#define lc (p<<1)
#define rc (p<<1|1)
int pool[N<<6],*mem=pool,*ev[M];
void eva_mul(int*f,int*g,int*ans,int n,int m){
	static int A[M],B[M];initpoly(n);
	cpy(A,f,n),clr(A+n,lim-n),NTT(A,1);
	cpy(B,g,m),clr(B+m,lim-m),NTT(B,1);
	for(int i=0;i<lim;++i)A[i]=1ll*A[i]*B[i]%mod;
	NTT(A,0),cpy(ans,A+m-1,n-m+1);
}
void eva_solve1(int l,int r,int p,int*a){
	ev[p]=mem,mem+=r-l+1;
	if(r-l==1)return ev[p][0]=mod-a[l],ev[p][1]=1,void();
	int mid=(l+r)>>1;
	eva_solve1(l,mid,lc,a);
	eva_solve1(mid,r,rc,a);
	poly_mul(ev[lc],ev[rc],ev[p],mid-l+1,r-mid+1);
}
void eva_solve2(int l,int r,int p,int*h,int*f){
	if(r-l==1)return h[l]=f[0],void();
	int mid=(l+r)>>1,*al,*ar;
	al=mem,mem+=mid-l,ar=mem,mem+=r-mid;
	eva_mul(f,ev[rc],al,r-l,r-mid+1);
	eva_mul(f,ev[lc],ar,r-l,mid-l+1);
	eva_solve2(l,mid,lc,h,al);
	eva_solve2(mid,r,rc,h,ar);
}
void poly_eva(int*g,int*f,int*a,int n,int m){
	static int A[M];
	n=max(n,m);
	eva_solve1(0,n,1,a);
	reverse(ev[1],ev[1]+n+1);
	poly_inv(A,ev[1],n),reverse(A,A+n);
	poly_mul(A,f,A,n,n),cpy(A,A+n,n);
	eva_solve2(0,n,1,g,A);
	for(int i=0;i<m;++i)fmod(g[i]=1ll*g[i]*a[i]%mod+f[0]);
	for(int i=m;i<n;++i)g[i]=0;
}
void poly_sqa(int*g,int*f,int n){
	initpoly(n<<1);
	NTT(f,1);
	for(int i=0;i<lim;++i)g[i]=1ll*f[i]*f[i]%mod;
	NTT(g,0);
}
void poly_qpow(int*g,int *f,int k,int n){
	static int A[M];
	cpy(A,f,n),g[0]=1;
	for(;k;k>>=1,poly_sqa(A,A,n),clr(A+n,n))
		if(k&1)poly_mul(g,A,g,n,n),clr(g+n,n);
}
void newton(int*g,int n){
	static int A[M],B[M],C[M];
	if(n==1)return g[0]=0,void();
	newton(g,(n+1)>>1);
	clr(A,n),A[0]=1;
	for(int i=0;i<n;++i)A[i]=(A[i]-2ll*g[i]%mod+mod)%mod;
	clr(B,n),poly_qpow(B,g,V-1,n);
	for(int i=1;i<n;++i)A[i]=(A[i]+1ll*V*B[i-1]%mod)%mod;
	clr(C,n),poly_inv(C,A,n);
	
	poly_mul(B,g,B,n,n),clr(B+n,n);
	for(int i=0;i<n;++i)A[i]=g[i];
	poly_sqa(A,A,n);
	for(int i=0;i<n;++i)fmod(A[i]=g[i]-A[i]+mod);
	fmod(A[1]+=mod-1);
	for(int i=1;i<n;++i)fmod(A[i]+=B[i-1]);
	poly_mul(A,C,A,n,n);
	
	for(int i=0;i<n;++i)fmod(g[i]+=mod-A[i]);
}
void calcf(int*f,int n){
	static int A[M],B[M];
	if(V>=127){
		f[0]=1;
		for(int k=1;k<=m;++k){
			for(int i=0;i<=k/V;++i){
				int tmp=1ll*comb(k,i)*comb(2*k-V*i-1,k-i*V)%mod;
				fmod(f[k]+=i&1?mod-tmp:tmp);
			}
		}
		return;
	}
	newton(A,n+1),dao(f,A,n+1);
	for(int i=0;i<n;++i) A[i]=A[i+1];
	clr(B,n),poly_inv(B,A,n);
	poly_mul(f,B,f,n,n),clr(f+n,n);
}

}

void solve(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1;
	int p=1ll*l*(n-r+1)%mod*IV%mod,q=mod+1-p;
	P[tot]=p,a[tot++]=1ll*p*qpow(q,mod-2)%mod;
	solve(l,mid),solve(mid+1,r);
}

signed main(){
	math::initmath();
	n=read(),m=read(),V=read()+2;
	poly::calcf(f,m+1);
	IV=qpow(1ll*n*(n+1)/2%mod,mod-2);
	solve(1,n);
	for(int i=0,j=1;i<=m;++i,j=1ll*j*V%mod)
		c[i]=1ll*comb(m,i)*(j+mod-f[i])%mod*qpow(j,mod-2)%mod;
	poly::poly_eva(b,c,a,m+1,tot);
	for(int i=0;i<tot;++i)fmod(ans+=1ll*b[i]*qpow(mod+1-P[i],m)%mod);
	cout<<ans<<'\n';
}
```


---

## 作者：Aleph1022 (赞：4)

本文同步发表于我的博客：<https://www.alpha1022.me/articles/lg-7445.htm>

首先令 $v=V+2$。

考虑一个结点 $[l,r]$。  
则实际上一次操作对它产生影响的概率即这次操作的区间包含它的概率，即 $p=\frac{l(n-r+1)}{\binom{n+1}2}$。  
设随机加 $k$ 次 $[-1,V]$ 中的整数，结果为 $0$ 的方案数为 $f_k$，那么枚举被操作次数，一个结点的贡献即为
$$
\sum\limits_{i=0}^m \binom mi p^i (1-p)^{m-i} \left(1-\frac{f_i}{v^i}\right)
$$

观察到这其实是一个关于 $\frac p{1-p}$ 的多项式乘一个 $(1-p)^m$，设其等于
$$
(1-p)^m \sum\limits_{i=0}^m c_i \left(\frac p{1-p}\right)^i
$$

一个简单的做法是直接多点求值，只要常数不爆炸应该都可以过。  
不过存在不多点求值的做法。

将有贡献的结点（非叶结点）任意标号为 $1,2,\dots,n-1$，令 $p_i$ 表示第 $i$ 个结点的以上提到的 $p$ 值，令 $a_i = \frac{p_i}{1-p_i},b_i = (1-p_i)^m$，则总答案为
$$
\begin{aligned}
\sum\limits_{i=1}^{n-1} b_i \sum\limits_{j=0}^m c_j a_i^j
&= \sum\limits_{j=0}^m c_j \sum\limits_{i=1}^{n-1} b_i a_i^j
\end{aligned}
$$

于是问题变为对 $j=0,1,\dots,m$ 求出 $\sum b_i a_i^j$。  
发现
$$
\sum\limits_{i=1}^{n-1} b_i a_i^j = [x^j] \sum\limits_{i=1}^{n-1} \frac{b_i}{1-a_ix}
$$

可以考虑分治 NTT 实现通分并相加的过程，时间复杂度 $O(n \log^2 n)$。

接下来，问题只剩下求出 $f_k$。  
通过组合数最后可以推得一个 $O\left(\frac {m^2}V\right)$ 的做法，可以参见出题人的题解，这里略去不谈。  
通过大力生成函数处理，显然
$$
f_k = [x^0](x^{-1}+1+x+x^2+\dots+x^{V})^k
$$

令
$$
F(x) = x^{-1}+1+x+x^2+\dots+x^{V} = \frac{1-x^v}{x(1-x)}
$$

然后问题变成
$$
[x^0] F^k(x)
$$

事实上这个问题的形式与一个经典问题极其相似，于是这启发我们考虑拉格朗日反演。  
但是由于要提取常数项，所以并不能直接运用经典的拉格朗日反演；并且，$F$ 显然不存在复合逆。

考虑令 $G = \frac1F$，令 $H$ 为 $G$ 的复合逆，然后考虑另类拉格朗日反演：
$$
[x^0] F^k(x) = [x^0] G^{-k}(x) = [x^k] \frac{xH'(x)}{H(x)}
$$

至此，如果能求出 $H(x)$，问题即迎刃而解。  
注意到
$$
G = \frac{x(1-x)}{1-x^v}
$$

代入 $x = H$ 得
$$
xH^v - H^2 + H - x = 0
$$

使用多项式牛顿迭代求解即可。

时间复杂度 $O(n \log^2 n)$（视 $n,m$ 同阶）。

代码：
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <utility>
#include <algorithm>
#define add(a,b) (a + b >= mod ? a + b - mod : a + b)
#define dec(a,b) (a < b ? a - b + mod : a - b)
using namespace std;
const int N = 1e5;
const int mod = 998244353;
const int LIM = 128;
int n,m,v,inv,lim;
int a[N + 5],b[N + 5],tot;
int c[N + 5];
int ans;
inline int fpow(int a,int b)
{
    int ret = 1;
    for(;b;b >>= 1)
        (b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;
    return ret;
}
namespace Poly
{
    const int LG = 19;
    const int N = 1 << LG + 1;
    const int G = 3;
    int lg2[N + 5];
    int rev[N + 5],fac[N + 5],ifac[N + 5],inv[N + 5];
    int rt[N + 5],irt[N + 5];
    inline void init()
    {
        for(register int i = 2;i <= N;++i)
            lg2[i] = lg2[i >> 1] + 1;
        int w = fpow(G,(mod - 1) / N / 2),wi = fpow(w,mod - 2);
        rt[0] = irt[0] = 1;
        for(register int i = 1;i <= N;++i)
        	rt[i] = (long long)rt[i - 1] * w % mod,
        	irt[i] = (long long)irt[i - 1] * wi % mod;
        for(register int i = 0;i < N;++i)
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << LG),
            i < rev[i] && (swap(rt[i],rt[rev[i]]),swap(irt[i],irt[rev[i]]),1);
        fac[0] = 1;
        for(register int i = 1;i <= N;++i)
            fac[i] = (long long)fac[i - 1] * i % mod;
        ifac[N] = fpow(fac[N],mod - 2);
        for(register int i = N;i;--i)
            ifac[i - 1] = (long long)ifac[i] * i % mod;
        for(register int i = 1;i <= N;++i)
            inv[i] = (long long)ifac[i] * fac[i - 1] % mod;
    }
    struct poly
    {
        vector<int> a;
        inline poly(int x = 0)
        {
            x && (a.push_back(x),1);
        }
        inline poly(const vector<int> &o)
        {
            a = o,shrink();
        }
        inline poly(const poly &o)
        {
            a = o.a,shrink();
        }
        inline void shrink()
        {
            for(;!a.empty() && !a.back();a.pop_back());
        }
        inline int size() const
        {
            return a.size();
        }
        inline void resize(int x)
        {
            a.resize(x);
        }
        inline int operator[](int x) const
        {
            if(x < 0 || x >= size())
                return 0;
            return a[x];
        }
        inline void clear()
        {
            vector<int>().swap(a);
        }
        inline poly rever() const
        {
            return poly(vector<int>(a.rbegin(),a.rend()));
        }
        inline void dit()
        {
        	int n = size();
		    for(register int i = 1,l = n >> 1;i < n;i <<= 1,l >>= 1)
		        for(register int j = 0,w,o = 0;j < i;++j,o += l << 1)
				{
		            w = rt[i | j];
		            for(register int k = o,t;k < o + l;++k)
		                t = (long long)a[k + l] * w % mod,
		                a[k + l] = dec(a[k],t),
		                a[k] = add(a[k],t);
		        }
		}
		inline void dif()
		{
			int n = size();
		    for(register int i = n >> 1,l = 1;i;i >>= 1,l <<= 1)
		        for(register int j = 0,w,o = 0;j < i;++j,o += l << 1)
				{
		            w = irt[i | j];
		            for(int k = o,t;k < o + l;++k)
		                t = a[k + l],
		                a[k + l] = dec(a[k],t),a[k + l] = (long long)a[k + l] * w % mod,
		                a[k] = add(a[k],t);
		        }
		    for(register int i = 0;i < n;++i)
				a[i] = (long long)a[i] * inv[n] % mod;
		}
        inline void ntt(int type = 1)
        {
            type == 1 ? dit() : dif();
        }
        friend inline poly operator+(const poly &a,const poly &b)
        {
            vector<int> ret(max(a.size(),b.size()));
            for(register int i = 0;i < ret.size();++i)
                ret[i] = add(a[i],b[i]);
            return poly(ret);
        }
        friend inline poly operator-(const poly &a,const poly &b)
        {
            vector<int> ret(max(a.size(),b.size()));
            for(register int i = 0;i < ret.size();++i)
                ret[i] = dec(a[i],b[i]);
            return poly(ret);
        }
        friend inline poly operator*(poly a,poly b)
        {
            if(a.a.empty() || b.a.empty())
                return poly();
            int n = a.size(),m = b.size();
            int lim = 1,tot = n + m - 1;
            for(;lim < tot;lim <<= 1);
            a.resize(lim),b.resize(lim);
            for(register int i = n;i < lim;++i)
                a.a[i] = 0;
            for(register int i = m;i < lim;++i)
                b.a[i] = 0;
            a.ntt(),b.ntt();
            for(register int i = 0;i < lim;++i)
                a.a[i] = (long long)a[i] * b[i] % mod;
            a.ntt(-1),a.shrink();
            return a;
        }
        poly &operator+=(const poly &o)
        {
            resize(max(size(),o.size()));
            for(register int i = 0;i < o.size();++i)
                a[i] = add(a[i],o[i]);
            return *this;
        }
        poly &operator-=(const poly &o)
        {
            resize(max(size(),o.size()));
            for(register int i = 0;i < o.size();++i)
                a[i] = dec(a[i],o[i]);
            return *this;
        }
        poly &operator*=(poly o)
        {
            return (*this) = (*this) * o;
        }
        poly deriv() const
        {
            if(a.empty())
                return poly();
            vector<int> ret(size() - 1);
            for(register int i = 0;i < size() - 1;++i)
                ret[i] = (long long)(i + 1) * a[i + 1] % mod;
            return poly(ret);
        }
        poly integ() const
        {
            if(a.empty())
                return poly();
            vector<int> ret(size() + 1);
            for(register int i = 0;i < size();++i)
                ret[i + 1] = (long long)a[i] * inv[i + 1] % mod;
            return poly(ret);
        }
        inline poly modxn(int n) const
        {
            if(a.empty())
                return poly();
            n = min(n,size());
            return poly(vector<int>(a.begin(),a.begin() + n));
        }
        inline poly inver(int m) const
        {
            poly ret(fpow(a[0],mod - 2)),f,g;
            for(register int k = 1;k < m;)
            {
                k <<= 1,f.resize(k),g.resize(k);
                for(register int i = 0;i < k;++i)
                    f.a[i] = (*this)[i],g.a[i] = ret[i];
                f.ntt(),g.ntt();
                for(register int i = 0;i < k;++i)
                    f.a[i] = (long long)f[i] * g[i] % mod;
                f.ntt(-1);
                for(register int i = 0;i < (k >> 1);++i)
                    f.a[i] = 0;
                f.ntt();
                for(register int i = 0;i < k;++i)
                    f.a[i] = (long long)f[i] * g[i] % mod;
                f.ntt(-1);
                ret.resize(k);
                for(register int i = (k >> 1);i < k;++i)
                    ret.a[i] = dec(0,f[i]);
            }
            return ret.modxn(m);
        }
        inline pair<poly,poly> div(poly o) const
        {
            if(size() < o.size())
                return make_pair(poly(),*this);
            poly f,g;
            f = (rever().modxn(size() - o.size() + 1) * o.rever().inver(size() - o.size() + 1)).modxn(size() - o.size() + 1).rever();
            g = (modxn(o.size() - 1) - o.modxn(o.size() - 1) * f.modxn(o.size() - 1)).modxn(o.size() - 1);
            return make_pair(f,g);
        }
        inline poly log(int m) const
        {
            return (deriv() * inver(m)).integ().modxn(m);
        }
        inline poly exp(int m) const
        {
            poly ret(1);
            for(register int k = 1;k < m;)
                k <<= 1,ret = (ret * (1 - ret.log(k) + modxn(k))).modxn(k);
            return ret.modxn(m);
        }
        inline poly pow(int m,int k1,int k2 = -1) const
        {
            if(a.empty())
                return poly();
            if(k2 == -1)
                k2 = k1;
            int t = 0;
            for(;t < size() && !a[t];++t);
            if((long long)t * k1 >= m)
                return poly();
            poly ret;
            ret.resize(m);
            int u = fpow(a[t],mod - 2),v = fpow(a[t],k2);
            for(register int i = 0;i < m - t * k1;++i)
                ret.a[i] = (long long)operator[](i + t) * u % mod;
            ret = ret.log(m - t * k1);
            for(register int i = 0;i < ret.size();++i)
                ret.a[i] = (long long)ret[i] * k1 % mod;
            ret = ret.exp(m - t * k1),t *= k1,ret.resize(m);
            for(register int i = m - 1;i >= t;--i)
                ret.a[i] = (long long)ret[i - t] * v % mod;
            for(register int i = 0;i < t;++i)
                ret.a[i] = 0;
            return ret;
        }
    };
}
using Poly::init;
using Poly::poly;
inline int C(int n,int m)
{
    return n < m ? 0 : (long long)Poly::fac[n] * Poly::ifac[m] % mod * Poly::ifac[n - m] % mod;
}
poly f,g;
pair<poly,poly> res;
inline poly solve(int m)
{
    poly ret,f2,fv1,fv,t,t1;
    for(register int k = 1;k < m;)
    {
        k <<= 1,f2.resize(k << 1);
        for(register int i = 0;i < (k << 1);++i)
            f2.a[i] = ret[i];
        f2.ntt();
        fv1 = ret.pow(k,v - 1),fv = fv1,fv.resize(k << 1),fv.ntt();
        for(register int i = 0;i < (k << 1);++i)
            fv.a[i] = (long long)fv[i] * f2[i] % mod,
            f2.a[i] = (long long)f2[i] * f2[i] % mod;
        f2.ntt(-1),f2.resize(k),fv.ntt(-1),fv.resize(k);
        t.resize(k),t1.resize(k);
        for(register int i = 0;i < k;++i)
            t.a[i] = add(fv[i - 1],ret[i]),
            t.a[i] = dec(t[i],f2[i]);
        t.a[1] = dec(t[1],1);
        for(register int i = 0;i < k;++i)
            t1.a[i] = ((long long)v * fv1[i - 1] % mod - 2 * ret[i] + 2 * mod) % mod;
        t1.a[0] = add(t1[0],1);
        ret -= (t * t1.inver(k)).modxn(k);
    }
    return ret.modxn(m);
}
inline pair<poly,poly> operator+(pair<poly,poly> a,pair<poly,poly> b)
{
    int alen = a.first.size(),blen = b.first.size();
    int n = a.second.size(),m = b.second.size();
    int lim = 1,tot = n + m - 1;
    for(;lim < tot;lim <<= 1);
    a.first.resize(lim),a.second.resize(lim),b.first.resize(lim),b.second.resize(lim);
    a.first.ntt(),a.second.ntt(),b.first.ntt(),b.second.ntt();
    for(register int i = 0;i < lim;++i)
        a.first.a[i] = ((long long)a.first[i] * b.second[i] + (long long)a.second[i] * b.first[i]) % mod,
        a.second.a[i] = (long long)a.second[i] * b.second[i] % mod;
    a.first.ntt(-1),a.second.ntt(-1),
    a.first.shrink(),a.second.shrink();
    return a;
}
inline pair<poly,poly> solve(int l,int r)
{
    if(l == r)
    {
        poly t;
        t.resize(2),t.a[0] = 1,t.a[1] = dec(0,a[l]);
        return make_pair(poly(b[l]),t);
    }
    int mid = l + r >> 1;
    return solve(l,mid) + solve(mid + 1,r);
}
void build(int l,int r)
{
    if(l == r)
        return ;
    ++tot;
    int p = (long long)l * (n - r + 1) % mod * inv % mod;
    a[tot] = (long long)p * fpow((1 - p + mod) % mod,mod - 2) % mod,
    b[tot] = fpow((1 - p + mod) % mod,m);
    int mid = l + r >> 1;
    build(l,mid),build(mid + 1,r);
}
int main()
{
    init();
    scanf("%d%d%d",&n,&m,&v),v += 2,lim = LIM,inv = fpow(C(n + 1,2),mod - 2);
    if(n == 1)
	{
    	puts("0");
    	return 0;
	}
    if(v <= lim)
    {
        f = solve(m + 2),f.resize(m + 2),g = f.deriv();
        for(register int i = 0;i <= m;++i)
            f.a[i] = f[i + 1];
        f.resize(m + 1),f = (g * f.inver(m + 1)).modxn(m + 1);
    }
    else
    {
        f.resize(m + 1),f.a[0] = 1;
        for(register int i = 1;i <= m;++i)
            for(register int j = 0;j * v <= i;++j)
                f.a[i] = (f[i] + (long long)C(i,j) * (j & 1 ? mod - 1 : 1) % mod * C(2 * i - j * v - 1,i - 1)) % mod;
    }
    for(register int i = 0;i <= m;++i)
        c[i] = (long long)C(m,i) * (fpow(v,i) - f[i] + mod) % mod * fpow(v,(mod - i - 1) % (mod - 1)) % mod;
    build(1,n),res = solve(1,tot),res.first = (res.first.modxn(m + 1) * res.second.inver(m + 1)).modxn(m + 1);
    for(register int i = 0;i <= m;++i)
        ans = (ans + (long long)c[i] * res.first[i]) % mod;
    printf("%d\n",ans);
}
```

---

## 作者：Saliеri (赞：3)

技不如人甘拜下风。化式子的感觉还是太菜了。

___

贡献拆开至每一个节点，从而不难将问题转化为两个部分：

- 对所有 $k\in [0,m]$，求 $P_k$ 表示 「长为 $k$ 的数列，每一项在 $[-1,V]$ 内，和为 $0$ 的数量」。

- 对所有线段树上区间 $[l,r]$，记随机一个区间包含它的概率为 $P_{[l,r]} = \dfrac{l(n-r+1)}{\frac{n(n+1)}{2}}$，求和 $\sum_{[l,r]\in \text{SGT}}\sum_{k=0}^m\binom{m}{k}(1-\dfrac{P_k}{(V+2)^k})P_{[l,r]}^k(1-P_{[l,r]})^{m-k}$。

___

先做第一个。显然 $P^k = [x^0](\dfrac{1+x+\cdots x^{V+1}}{x})^k$。求系数，考虑拉格朗日反演。
- 注意到求的是 $[x^0]$，因此只能上另类拉格朗日反演。

若设 $F = \sum_{i=0}^{V+1} x^i = \dfrac{1-x^{V+2}}{1-x},G = \dfrac{F}{x}$，直接上拉反，导出的是我们不想看到的负指数系数。

考虑如何规避。只需**取倒**将 $G$ 的定义更改为 $G = \dfrac{x}{F}$，此时 $P_k = [x^0]G^{-k}$，从而拉反导出的成为正指数 $[x^k](G^{(-1)})'\dfrac{x}{G^{(-1)}}$。

于是问题转化成求 $G^{(-1)}$。套路地，在 $G$ 的定义式中替换 $x$ 为 $G^{(-1)}$ ，即可导出一个函数方程 $\dfrac{G^{(-1)}(1-G^{(-1)})}{1-(G^{(-1)})^{V+2}} = x$。

牛迭解它即可。$O(n\log n)$。注意多项式快速幂需要 P5273 那个 general 的版本。

___

考虑第二个。将式子整理，**合并同次的项**，$\sum_{[l,r]\in \text{SGT}}(1-P_{[l,r]})^{m}\left(\sum_{k=0}^m\binom{m}{k}(1-\dfrac{P_k}{(V+2)^k})(\dfrac{P_{[l,r]}}{1-P_{[l,r]}})^k\right)$。

不难想到将后面的看做一个 $m$ 次多项式，多点求值即可。$O(n\log^2n)$。
___

值得注意的点：

- 牛迭解 $G^{(-1)}$ 时，需要解到 $m+1$ 次项而非 $m$，因为后面的 $(G^{(-1)})'$  需要往后用一项。（感谢 yjt 的指出）

- $n=1$ 时会导致空多项式的出现，记得判掉。

Code：放剪贴板。因为自己的多项式板子太难看了。[Link](https://www.luogu.com.cn/paste/yla4rpda)。

---


# [集训队互测 2018] 完美的旅行

## 题目描述

小 A 有一张 $n$ 个点的图，点的标号为 $0$ 到 $n-1$。点 $i$ 到点 $j$ 有 $A_{i,j}$ 条有向边。可能有自环。

现在小 A 要在图上进行若干次旅行。每次旅行都是选任意一个起点，走至少一步，走到任意一个终点。定义一次旅行的愉悦值为起点与终点编号按位与的值。

好奇的小 B 想要知道：对于所有 $x \in [1,m]$ 和 $y \in [0,n)$，小 A 进行了若干次旅行，总共走了 $x$ 步，且所有旅行的愉悦值的按位与为 $y$ 的方案数。

两种方案不同当且仅当旅行次数不同或某一次旅行不完全相同。

为了防止输出过多，你只需要输出这 $n\times m$ 个数对 $998244353$ 取模后的结果的按位异或值。

为方便起见，保证 $n$ 是 $2$ 的幂次。

## 说明/提示

### 样例解释

走 $1$ 步，愉悦值的按位与 $=0,1$ 的方案数分别为 $6,4$。

走 $2$ 步的方案数分别为 $116,38$。

走 $3$ 步的方案数分别为 $2012,358$。

异或值为 $1770$。

### 数据范围

对于所有数据，$2 \leq n \leq 64$，$1 \leq m \leq 20000$，$0 \leq A_{i,j} < 998244353$，保证 $n$ 是 $2$ 的幂。

|子任务编号	|	分值		|	$n \leq$	|	$m \leq$	|		特殊限制									|
|:----------------:|:----------------:|:----------------:|:----------------:|:-------------------------------------------------------------------------:|
|	$1$		|	$15$	|	$16$	|	$2000$	|												|
|	$2$		|	$15 $	|	$32$	|	$10000$	|												|
|	$3$		|	$35$	|	$64$	|	$20000$	|$A_{i,j}=i\otimes j$，其中 $\otimes$ 表示按位异或运算	|
|	$4$		|	$35 $	|	$64$	|	$20000$	|												|

## 样例 #1

### 输入

```
2 3
1 2
3 4```

### 输出

```
1770```

# 题解

## 作者：Larunatrecy (赞：6)

一个暴力。

对于 $S\in [0,n)$，求出旅行的预约值的按位与为 $S$ 的超集的方案数，然后做高维差分就能得到答案。

这样做的好处是，如果我们枚举 $y$，那么所有所有旅行的起点和终点都只需要满足是 $S$ 的超集即可。

设 $f_{i,x}$ 为当前走了 $i$ 步，位于 $x$ 的方案数，转移分为两种：

- 继续当前旅行

$f_{i,x}\times A_{x,y}\to f_{i+1,y}$

- 新开一个旅行

因为旅行至少走一步，所以我们不妨钦定走一步，枚举新旅行的第二个节点。

$[x\& S=S]f_{i,x}\times s_y\to f_{i+1,y}$，其中 $s_y=\sum\limits_{z\&S=S}A_{z,y}$。

同样的理由，初始化也应当钦定走一步。

最后的答案就是 $\sum\limits_{x\&S=x}f_{m,x}$。

把转移写成矩阵 $F$，同时设行向量 $P$ 为 $f$ 的初值，列向量 $Q$ 为求答案的系数数组。

那么恰好经过 $i$ 条边的方案数即为 $PF^{i-1}Q$ ，$i-1$ 是因为初始化先走了一步。

取 $B=\sqrt m$，预处理出 $PF^{k},k\in [0,B)$ 以及 $F^{kB}Q$，因为都是矩阵乘向量，单次复杂度 $O(n^2) $。

总复杂度 $O(n(n^2\sqrt m+n^3\log m+nm))$，能过。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int N = 64;
const int M = 20005;
int n,m;
inline int myplus(int a,int b){return (a+b>=mod?a+b-mod:a+b);}
struct vec
{
	int mt[N];
	vec(){memset(mt,0,sizeof(mt));}
	int &operator [](int x){return mt[x];}
}Ma[150],Mb[150];
int operator *(vec A,vec B)
{
	int res=0;
	for(int k=0;k<n;k++)
	res=myplus(res,1ll*A[k]*B[k]%mod);
	return res;
}
struct mat
{
	int mt[N][N];
	mat(){memset(mt,0,sizeof(mt));}
	inline int* operator [](int x){return mt[x];}
}G;
mat operator *(mat A,mat B)
{
	mat C;
	for(int k=0;k<n;k++)
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	C[i][j]=myplus(C[i][j],1ll*A[i][k]*B[k][j]%mod);
	return C;
}
vec operator *(vec A,mat B)
{
	vec C;
	for(int i=0;i<n;i++)
	for(int k=0;k<n;k++)
	C[i]=myplus(C[i],1ll*A[k]*B[k][i]%mod);
	return C;
}
vec operator *(mat A,vec B)
{
	vec C;
	for(int i=0;i<n;i++)
	for(int k=0;k<n;k++)
	C[i]=myplus(C[i],1ll*A[i][k]*B[k]%mod);
	return C;
}
mat Pow(mat a,int b)
{
	mat res;
	for(int i=0;i<n;i++)res[i][i]=1;
	while(b)
	{
		if(b&1)res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}
int A[N][N];
int f[M][N];
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	scanf("%d",&A[i][j]);
	int B=sqrt(m)+1;
	int K=log2(n);
	for(int S=0;S<n;S++)
	{
		for(int i=0;i<n;i++)
		{
			int sum=0;
			for(int j=0;j<n;j++)
			{
				G[j][i]=A[j][i];
				if((j|S)==j)sum=myplus(sum,A[j][i]);
			}
			Ma[0][i]=sum;
			Mb[0][i]=((i|S)==i);
			for(int j=0;j<n;j++)
			if((j|S)==j)G[j][i]=myplus(G[j][i],sum);
		}	
		for(int i=1;i<=B;i++)Ma[i]=Ma[i-1]*G;
		G=Pow(G,B);
		for(int i=1;i<=B;i++)Mb[i]=G*Mb[i-1];
		for(int i=0;i<m;i++)f[i+1][S]=Ma[i%B]*Mb[i/B];
	}
	int ans=0;
	for(int E=1;E<=m;E++)
	{
		for(int i=0;i<K;i++)
		for(int j=0;j<n;j++)
		if((j>>i)%2==0)f[E][j]=myplus(f[E][j],mod-f[E][j^(1<<i)]);
		for(int i=0;i<n;i++)ans^=f[E][i];
	}
	cout<<ans;
	return 0;
}
```

---


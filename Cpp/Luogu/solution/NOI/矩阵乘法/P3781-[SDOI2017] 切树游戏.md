# [SDOI2017] 切树游戏

## 题目背景

hack数据 by boshi & Remmina

## 题目描述

小Q是一个热爱学习的人，他经常去维基百科学习计算机科学。

就在刚才，小Q认真地学习了一系列位运算符，其中按位异或的运算符$\oplus$对他影响很大。按位异或的运算符是双目运算符。按位异或具有交换律，即$i \oplus j = j \oplus i$。

他发现，按位异或可以理解成被运算的数字的二进制位对应位如果相同，则结果的该位置为$0$，否则为$1$，例如：$1(01) \oplus 2(10) = 3(11)$。

他还发现，按位异或可以理解成参与运算的数字的每个二进制位都进行了不进位的加法，例如：$3(11) \oplus 3(11) = 0(00)$。

现在小Q有一棵$n$个结点的无根树$T$，结点依次编号为$1$到$n$，其中结点$i$的权值为$v_i$。

定义一棵树的价值为它所有点的权值的异或和，一棵树$T$的连通子树就是它的一个连通子图，并且这个图也是一棵树。

小Q想要在这棵树上玩切树游戏，他会不断做以下两种操作：

- `Change x y` 将编号为$x$的结点的权值修改为$y$。

- `Query k` 询问有多少棵$T$的非空连通子树，满足其价值恰好为$k$。

小Q非常喜(bu)欢(hui)数学，他希望你能快速回答他的问题，你能写个程序帮帮他吗？


## 说明/提示

对于$100\%$的数据，$1 \leq a_i,b_i,x \leq n$ , $0 \leq v_i,y,k < m$，修改操作不超过$10000$个。

![](https://cdn.luogu.com.cn/upload/pic/5534.png)


## 样例 #1

### 输入

```
4 4
2 0 1 3
1 2
1 3
1 4
12
Query 0
Query 1
Query 2
Query 3
Change 1 0
Change 2 1
Change 3 3
Change 4 1
Query 0
Query 1
Query 2
Query 3```

### 输出

```
3
3
2
3
2
4
2
3```

# 题解

## 作者：shadowice1984 (赞：19)

从九省联考前咕到现在的一道题……

精神污染，做好码5~6个k的心理准备……

____________________

## 前置知识：快速沃尔什变换(FWT)

如果不会fwt的话可以去这个模板区学习一下

[P4717](https://www.luogu.org/problemnew/show/P4717)

## 本题题解

首先呢题意是简单易懂的，求树上异或和为k的联通块个数

到此为止它还是$trival$的，最多是个紫牌题

但是如果我们需要支持动态修改点权呢?

然后这道题就变成了黑牌题了

当然猫老师也用这道题作为了他[博客](http://immortalco.blog.uoj.ac/blog/2625)上的一道例题……

那么让我们讲解一下这道题的原理吧……

___________________

## 朴素的dp

我们可以设$Dp_{i,j}$表示最高点为i的异或和为j的联通块个数

那么,如果询问为k的话我们最后就是求

## $\sum_{i=1}^{n}Dp_{i,k}$

让我先来愉快的推一下转移方程

还是考虑我们有了$Dp_{u,k}$现在要加入一个子树$Dp_{v}$

那么我们可以得到这个转移方程

## $Dp_{u,k}=\sum_{i \oplus j==k}Dp_{u,i}Dp_{v,j}+Dp_{u,k}$

我们发现那个和式其实是所谓的异或卷积的形式

当然可以使用fwt进行优化

所以假如我们设$\hat{Dp}_{i}$为数组$Dp_{i}$经过fwt之后的数组的话

我们会得到这样的转移式子

## $\hat{Dp}_{u,k}=\hat{Dp}_{u,k}\hat{Dp}_{v,k}+\hat{Dp}_{u,k}$

即

## $\hat{Dp}_{u,k}*=(\hat{Dp}_{v,k}+1)$

然后我们假如设

## $g_{u,k}=\sum_{i \in u.subtree}Dp_{u,k}$

的话(u.subtree)就是u的子树的意思

等式两边取沃尔什变换

## $\hat{g}_{u,k}=\sum_{i \in u.subtree}\hat{Dp}_{u,k}$

所以说我们只需要每次计算出$\hat{g}_{1}$这个数组就可以了，当然如果我们每次暴力重新计算的话算法复杂度应该是

## $O(nqmlogm)$

的，显然无法通过本题，所以我们可能需要一些优化

_____________________

## 动态dp

看到这里的话你已经注意到dp的转移方程十分简单这个事实了

这一般预示着一种叫做动态dp的技术，允许我们每次仅仅做$O(logn)$次矩阵乘法就可以快速完成dp的单点修改

那么具体来讲是什么操作呢……？

为了加深理解可以先去做一做这两道题

[P4751](https://www.luogu.org/problemnew/show/P4751)

[P4719](https://www.luogu.org/problemnew/show/P4719)

然后如果你还是不非常理解这种写法的话可以看这里的介绍

______________________

## 链分治

说白了就是轻重链剖分……

我们对这个树进行一波轻重链剖分，处理出每个点的$siz$和重儿子

然后我们采取一种不寻常的dp方式进行dp

我们一条重链一条重链的dp

这是什么意思呢……

假如我们正在计算一条重链上节点的dp值，那么我们首先for一遍这个重链，递归的求出和这个重链相连，且**最高点深度大于这个重链最高点的重链**的dp值，现在呢对于这个重链上的每一个节点，它的轻儿子的dp值已经被算出来了，还差重儿子的dp值没有算

此时我们可以做一个序列上的dp，从底向上依次递推出重链上每一个的dp值

好了到这里你可能会说，这不是没什么卵用吗……

你的算法复杂度仍然是$O(n)$的啊……

但是，请你再好好想一想，我们通过轻重链剖分这个技术将辣手的树上问题转化为了(略微好做一点的)序列问题

那么不如让我们来看一下用这种方式做的dp的转移方程会产生什么效果

那么首先我们需要知道轻儿子的dp值以及轻儿子子树当中dp的和

这样的话我们在重链上dp的时候就可以套用树形dp时的表达式(因为都是加一条边)

所以我们设

## $ldp_{u,k}=dp_{u,k}\prod_{v \in u.lightson}(dp_{v,k}+1)$

假设这里的数组都是fwt之后的形式，所以这里的乘法是普通的按位相乘而不是异或卷积

我们认为$Dp_{u}$的初值是一堆0，只有自己的值那一位是一个1的数组，上面公式里的$dp_{u}$指的是这个初值数组fwt之后的形式

然后接着设

## $lg_{u,k}=\sum_{v \in u.lightson}lg_{v,k}$

当然这里的数组依然也fwt之后的形式给出了

那么我们在重链上的dp式子就是这样

## $dp_{i}=ldp_{i+1}dp_{i}+ldp_{i+1}$

## $g_{i}=dp_{i}+lg_{i+1}+g_{i}$

然后将$g_{i}$表达式当中的$dp_{i}$代入一下就是

## $g_{i}=ldp_{i+1}dp_{i}+ldp_{i+1}+lg_{i+1}+g_{i}$

然后是最为关键的一步了……

在immortalco神仙将dp的转移写成矩阵之前这道题有一个老式的做法……

就是使用线段树维护每一条重链。

然后线段树上每一个节点维护4个值，分别是取了一段连续的重链区间，且左端点取到/右端点取到/左，右端点都没取/左，右端点都取了这个四种状态的方案数

然后你发现这个东西是可以大力转移的，于是大力转移就是了

当然你会发现你的代码十分的恶心……而且难写(这道题额外赠送一个更加难受的轻边处理问题)

当然自从猫老师把dp的转移写成矩阵的形式就不会这么麻烦了……

来，让我们尝试着把dp的转移写成矩阵乘法的形式

我们发现似乎这样做是可行的

手玩一下会发现

### $$\begin{bmatrix} dp_{i} \\ g_{i} \\ 1 \end{bmatrix} × \begin{bmatrix} ldp_{i+1} & ldp_{i+1} & 0 \\ 0 & 1  & 0\\ ldp_{i+1} & ldp_{i+1}+lg_{i+1} & 1\end{bmatrix} = \begin{bmatrix} dp_{i+1} \\ g_{i+1} \\ 1\end{bmatrix}$$

当然随之而来的事情就是，你发现每做一次矩乘似乎要做27次乘法和加法运算，并且，这些东西好像还都是对于一个长度为128的数组来讲的我们的常数可能有点爆炸

没关系我们接着手玩一下矩阵乘法，发现一个有趣的事实

### $$\begin{bmatrix} a_{0,0} & a_{0,1} & 0 \\ 0 & 1 & 0 \\ a_{1,0} & a_{1,1} & 1 \end{bmatrix} × \begin{bmatrix} b_{0,0} & b_{0,1} & 0 \\ 0 & 1 & 0 \\ b_{1,0} & b_{1,1} & 1 \end{bmatrix}=\begin{bmatrix} c_{0,0} & c_{0,1} & 0 \\ 0 & 1 & 0 \\ c_{1,0} & c_{1,1} & 1 \end{bmatrix}$$

而且

### $c_{0,0}=a_{0,0}b_{0,0}$

### $c_{0,1}=a_{0,0}b_{0,1}+a_{0,1}$

### $c_{1,0}=a_{1,0}b_{0,0}+b_{1,0}$

### $c_{1,1}=a_{1,0}b_{0,1}+a_{1,1}+b_{1,1}$

所以事实上我们只需要保存 $a_{0,0},a_{0,1},a_{1,0},a_{1,1}$就行了

而且做一次矩乘只需要4次乘法和加法了，常数降低到了一个可以令人接受的范围

对了，矩阵当中的元素可是多项式，因此这里的0和1指的是系数全部是0或者1的多项式

那么我们想要知道一个轻儿子的dp值，其实只需要提取出整条重链的转移矩阵连乘积，然后乘上一个初始向量(0,0,1)就行了，其实实际写代码的时候甚至没有必要写初值向量乘上转移矩阵这一步，因为事实上你会发现$dp_{u}=a_{1,0},g_{u}=a_{1,1}$

所以在经历了好一顿折腾之后我们终于把dp的转移写成了矩阵乘法的形式，并且把得出dp值转化为了询问一条重链的矩阵连乘积的形式

好了那这么折腾有啥用呢？


**矩阵的乘法具有结合律，因此可以方便的使用线段树维护矩阵连乘积**

想像一下修改时的情景吧，首先我们修改了一个点的点权，这对应着线段树上的单点修改，于是我们使用线段树一路修改上去，于是这个重链顶端节点的dp值改变了，于是顶端节点父亲的$ldp,lg$值都会改变，这对应着另一个重链的单点修改，于是我们再次使用线段树进行修改，重复这个过程，当我们修改到1号节点的时候，我们的算法就结束了

说的好像很轻松，但是刚才的算法流程是有硬伤的

我们修改了一个重链顶的dp值之后，如何快速计算它的父亲的$ldp,lg$值呢？

你可能会说，这有何nan，把老的值除掉/减去，然后乘上/加上新的轻儿子的dp值和g值不就好了……

但是啊，我们很有可能除一个0……此时情况瞬间变得辣手起来，其实，这里我们维护的信息似乎并不可减……此时情况开始变得辣手

当然，你可以向猫老师一样每个节点单开一个线段树来强行维护一波ldp值，但是由于在每个节点处单开一个线段树会妨碍我们使用动态dp的改进算法使得本题的复杂度降至

$O((n+qm)logn+(n+q)mlogm)$

所以说这里我们必须忍痛舍弃掉线段树，转而采取另一种方式使得我们可以除0

具体来讲，我们对于$ldp$数组，额外开一个数组$cntzero$来强行维护它，由于$ldp$是一堆多项式按位相乘得到的，所以$ldp$的第i位的值是所有非零项的乘积，而$cntzero$第i位是这一位0项的个数，当然我们提取这个数组的第i位的时候需要判断一下$cntzero$是否为0

这样我们就有办法乘和除0了，每次我们乘或者除一个0，不对$ldp$数组进行操作而是对$cntzero$数组进行操作，此时操作就变得完全可逆了

好了到此为止恶心的轻边问题就解决了，考虑到这道题的n比较小，我推荐使用常数比较小的树剖(自带一个0.25的常数)进行维护，但是……树剖难写

所以我写的是“全局平衡二叉树”

具体来讲我们使用bst来维护每一个重链，在建bst的时候不是采取平凡的取中点左右两边递归建树的方式，而是给每一个点加上一个附加权值，表示这个点所有轻儿子的siz和+1，然后找这条链的带权重心递归两边左右建树，这样我们可以保证无论是经过一条bst边还是虚边,所在子树的size至少翻一倍，这样的算上虚边的树高就是logn的，尽管某一个bst的形态可能就是一条链

~~但是有一个2的常数，而且在链上的常数会翻一倍……这道题n小体现不出来，常数被树剖吊打~~

~~可以去写一下P4751~~

但是好处就是比起树剖来说好写

然后关于这道题的实现部分，就是封装封装再封装，做好写上5~6个k的心理准备

最难受的是端点调试基本没有，都得人肉调100多行的代码……

上代码

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=3*1e4+10;const int M=130;typedef unsigned int uit;
const uit mod=10007;int n;int m;int q;uit iv[mod+10];uit ans[M];char opt[20];int rot;
inline void fwt(uit* a,const uit& o)//fwt
{
    for(int k=1;k<m;k<<=1)
        for(int s=0;s<m;s+=(k<<1))
            for(int i=s;i<s+k;i++)
            {uit a0=a[i];uit a1=a[i+k];a[i]=(a0+a1)*o%mod;a[i+k]=(a0+mod-a1)*o%mod;}
}
struct poly//多项式类
{
    uit f[M];
    inline uit& operator [](const int& x){return f[x];}
    friend poly operator *(poly a,poly b){poly c;for(int i=0;i<m;i++)c[i]=a[i]*b[i]%mod;return c;}
    friend poly operator /(poly a,poly b){poly c;for(int i=0;i<m;i++)c[i]=a[i]*iv[b[i]]%mod;return c;}
    friend poly operator +(poly a,poly b){poly c;for(int i=0;i<m;i++)c[i]=(a[i]+b[i])%mod;return c;}
    friend poly operator -(poly a,poly b){poly c;for(int i=0;i<m;i++)c[i]=(a[i]+mod-b[i])%mod;return c;}
    void operator +=(const poly& b){for(int i=0;i<m;i++)f[i]=(f[i]+b.f[i])%mod;}
    void operator -=(const poly& b){for(int i=0;i<m;i++)f[i]=(f[i]+mod-b.f[i])%mod;}
    inline void setone(){for(int i=0;i<m;i++)f[i]=1;}
}we[N],one;
struct mar//矩阵类
{
    poly mp[2][2];
    inline poly* operator [](const int& x){return mp[x];}
    friend mar operator* (mar a,mar b)
    {
        mar c;c[0][0]=a[0][0]*b[0][0];
        c[0][1]=a[0][0]*b[0][1]+a[0][1];
        c[1][0]=a[1][0]*b[0][0]+b[1][0];
        c[1][1]=a[1][0]*b[0][1]+a[1][1]+b[1][1];return c;
    }
};
int v[2*N];int x[2*N];int ct;int al[N];int siz[N];int h[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline int dfs(int u)//轻重链剖分
{
    siz[u]=1;
    for(int i=al[u];i;i=x[i])if(siz[v[i]]==0){siz[u]+=dfs(v[i]);if(siz[h[u]]<siz[v[i]])h[u]=v[i];}
    return siz[u];
}
struct data//用来维护轻边的结构体
{
    int fz[M];uit fv[M];
    inline void wt(const int& i,const int& x){if(x==0)fz[i]=fv[i]=1;else fz[i]=0,fv[i]=x;}
    void operator *=(const poly& b)
    {for(int i=0;i<m;i++)fz[i]+=(b.f[i]==0);for(int i=0;i<m;i++)fv[i]=fv[i]*(b.f[i]?b.f[i]:1)%mod;}
    void operator /=(const poly& b)
    {for(int i=0;i<m;i++)fz[i]-=(b.f[i]==0);for(int i=0;i<m;i++)fv[i]=fv[i]*iv[b.f[i]]%mod;}
};
inline void cpy(poly& a,const data& b){for(int i=0;i<m;i++)a[i]=b.fz[i]?0:b.fv[i];}
struct global_balanced_tree//全局平衡二叉树
{
    int s[N][2];int fa[N];int lsiz[N];int st[N];int tp;mar w[N];mar mul[N];data lt[N];poly lh[N];
    inline void udw(const int& p)
    {cpy(w[p][0][0],lt[p]);w[p][1][1]=w[p][1][0]=w[p][0][1]=w[p][0][0];w[p][1][1]+=lh[p];}
    inline void ud(const int& p){mul[p]=mul[s[p][0]]*w[p]*mul[s[p][1]];}
    inline void ins(const int& u,const int& v){lt[u]*=(mul[v][1][0]+one);lh[u]+=mul[v][1][1];}
    inline void del(const int& u,const int& v){lt[u]/=(mul[v][1][0]+one);lh[u]-=mul[v][1][1];}
    inline bool isr(const int& u){return (s[fa[u]][0]!=u)&&(s[fa[u]][1]!=u);}
    inline int subbuild(int l,int r)//一条重链递归建树
    {
        if(l==r){ud(st[l]);return st[l];}if(l>r){return 0;}
        int tot=0;for(int i=l;i<=r;i++)tot+=lsiz[st[i]];
        for(int i=l,nsiz=lsiz[st[i]];i<=r;i++,nsiz+=lsiz[st[i]])
            if(2*nsiz>=tot)
            {
                s[st[i]][0]=subbuild(l,i-1);s[st[i]][1]=subbuild(i+1,r);
                fa[s[st[i]][0]]=st[i];fa[s[st[i]][1]]=st[i];ud(st[i]);return st[i];
            }
    }
    inline int build(int p)//链分治
    {
        for(int i=p;i;i=h[i])lsiz[i]=siz[i]-siz[h[i]];
        for(int i=p;i;i=h[i])
            for(int j=al[i];j;j=x[j])
                if(lsiz[v[j]]==0){int ls=build(v[j]);fa[ls]=i;ins(i,ls);}
        for(int i=p;i;i=h[i])udw(i);
        tp=0;for(int i=p;i;i=h[i])st[++tp]=i;reverse(st+1,st+tp+1);
        return subbuild(1,tp);
    }
    inline void modify(int u,const int& w1)//修改，每次跳一条轻边
    {
        lt[u]/=we[u];
        for(int i=0;i<m;i++)we[u][i]=0;we[u][w1]=1;fwt(we[u].f,1);lt[u]*=we[u];udw(u);
        for(int p=u;p;p=fa[p])
            if(isr(p)&&fa[p]){del(fa[p],p);ud(p);ins(fa[p],p);udw(fa[p]);}else ud(p);
        for(int i=0;i<m;i++)ans[i]=mul[rot][1][1][i];fwt(ans,5004);
    }
    inline void ih()//初始化
    {
        for(int i=1;i<=n;i++)for(int j=0;j<m;j++)lt[i].wt(j,we[i][j]);
        w[0][0][0].setone();mul[0][0][0].setone();
    }
}gbt;
int main()
{
    iv[0]=1;iv[1]=1;for(int i=2;i<mod;i++)iv[i]=(mod-mod/i)*iv[mod%i]%mod;
    scanf("%d%d",&n,&m);one.setone();
    for(int i=1,w;i<=n;i++){scanf("%d",&w),we[i][w]=1,fwt(we[i].f,1);}
    for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),add(u,v),add(v,u);
    dfs(1);gbt.ih();rot=gbt.build(1);
    for(int i=0;i<m;i++)ans[i]=gbt.mul[rot][1][1][i];fwt(ans,5004);scanf("%d",&q);
    for(int i=1;i<=q;i++)
    {
        scanf("%s",opt);
        if(opt[0]=='Q'){int t;scanf("%d",&t);printf("%d\n",ans[t]);}
        else {int w;int u;scanf("%d%d",&u,&w);gbt.modify(u,w);}
    }return 0;//拜拜程序~
}
```






---

## 作者：2022tysc0776 (赞：15)

最近有时间来深入学习一下动态 DP，写一下题解。（进入[博客](https://www.luogu.com.cn/article/pp8lvbny)观感更佳）

## 正文内容

直接开推 DP 式子：设 $dp_{u,i}$ 表示以 $u$ 为连通块最高点，异或值为 $i$ 的方案数。

这里的 $dp'_{u,i}$ 表示在加入 $v$ 子树前的 $dp$ 数组。

$$
dp_{u,i}=dp'_{u,i}+\sum_{j \oplus k=i} dp'_{u,j} \times dp_{v,k}
\\dp_{u,a_u}=1
$$

然后我们发现右边是一个 [FWT](http://oiwiki.com/math/poly/fwt/) 的形式。

**注：以下解读只是本人作为一个初学 FWT 的一个认识，可能会有不对的地方，如果有误，请在评论区提出，谢谢。**

我们知道把 $dp'_u$ 和 $dp_v$ **FWT** 后按位相乘后进行一次 **IFWT**，可以对于每一位得到上述式子右边的部分，但是其实 FWT/IFWT 有一个非常良好的性质，**其为线性变换**，具体就是：

定义一般大写字母表示数组，小写字母表示一个数，数组 $+/\times$ 另一个数组表示两个数组按位相加/相称，数 $\times$ 数组表示数组中的每个数乘以这个数。 

$$
FWT[A+C]=FWT[A]+FWT[C]
\\FWT[c\times A]=c \times FWT[A]
$$

所以我们对等式两边做 FWT 实际上是等价的，原因如下：

我们把原式变化一下（下面为了方便，把 $'$ 给去掉了）:

$$
dp_{u,i}=dp_{u,i}+\sum_{j \oplus k=i} dp_{u,j} \times dp_{v,k}
\\=
\\dp_{u,i}=dp_{u,i}+IFWT[FWT[dp_u]\times FWT[dp_v]]_i
$$

这个就是 FWT 的基本方法了，看不懂这一步变形的可以回去在看一下 FWT 的操作。

$$
\because FWT[A+C]=FWT[A]+FWT[C]
\\\therefore FWT[dp_u]_i=FWT[dp_u]_i+FWT[IFWT[FWT[dp_u]\times FWT[dp_v]]]_i
\\\therefore FWT[dp_u]_i=FWT[dp_u]_i+FWT[dp_u]_i\times FWT[dp_v]_i
\\\therefore FWT[dp_u]_i=FWT[dp_u]_i\times(FWT[dp_v]_i+1)
$$

倒数第二步变形是因为 FWT 和 IFWT 是互逆的运算，所以可以抵消。

这实际是告诉我们，我们在做 DP 的时候可以直接对 DP 数组 FWT 然后按上面的式子算，最后 IFWT 回来就行。

所以初始化为 $FWT[a_u]$ 表示在只有 $a_u$ 这位是 1，其他都是 0 的 FWT 结果。（实际上就是对正常 DP 的初始化进行 FWT）

那问题就来了，其他的计算也可以 FWT 后直接计算吗，那我们来看一下下面要进行的操作。（为了方便，下面的 DP 数组默认进行 FWT）

然后我们发现暴力计算和修改是 $O(qnm\log m)$ 的。

然后修改很容易想到[动态 DP](http://oiwiki.com/dp/dynamic/)，所以继续推式子：

最后询问 $k$ 的答案是 $\sum IFWT[dp_{u}]_i$，所以我们要对其求和，设 $g_{u,i}$ 表示在 $u$ 子树中的所有点 $x$ 的 $dp_{x,i}$（这里不是 FWT 后的）的和。

$$
g_{u,i}=\sum g_{v,i} + dp_{u,i}
$$

然后这个式子只是加法运算，所以两边同时 FWT 也是不变的，那这个 $g$ 数组也可以先 FWT 在计算最后变回来。（所以下面的 $g$ 也是默认 FWT 后的结果）

结合动态 DP 的思想，设 $son_u$ 表示 $u$ 的重儿子，$dpl_{u,i}=\prod_{v \ne son_u} (dp_{v,i}+1)$，$gl_{u,i}=\sum_{v \ne son_u} g_{v,i}$

$$
dp_{u,i}=FWT[a_u]_i\times dpl_{u,i} \times (dp_{son_u,i}+1)
\\g_{u,i}=gl_{u,i}+g_{son_u,i}+dp_{u,i}
$$

然后就是喜闻乐见的矩阵转移：

$$
\begin{bmatrix}
 dpl_{u,i}\times FWT[a_u]_i & 0 & dpl_{u,i}\times FWT[a_u]_i \\
 dpl_{u,i}\times FWT[a_u]_i & 1 & dpl_{u,i}\times FWT[a_u]_i+gl_{u,i} \\
 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
 dp_{son_u,i} \\
 g_{son_u,i} \\
 1
\end{bmatrix}=
\begin{bmatrix}
  dp_{u,i} \\
  g_{u,i} \\
  1
\end{bmatrix}
$$

然后[全局平衡二叉树](https://www.luogu.com.cn/article/fcyeynxv)修改 $gl$ 和 $dpl$ 数组即可。（不用会超时！

~然后就结束了。~

开玩笑的，我们知道了动态 DP 的修改只涉及 $+/\times$（$-/\div$ 可以用 $+/\times$ 代替），所以我们就可以放心的把所有数组 FWT 后，最后 IFWT 即可。

但是这个题有一些坑和一些有趣的 trick：

1. 本题目的时间复杂度是 $O(qm\log n)$ 的，所以其实卡的比较死，那你矩阵乘法自带的 $3\times 3$ 的常数就太大，但是还有一种方法，手玩一下：

$$
\begin{bmatrix}
 a1 & 0 & b1\\
 c1 & 1 & d1\\
 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
 a2 & 0 & b2\\
 c2 & 1 & d2\\
 0 & 0 & 1
\end{bmatrix}=
\begin{bmatrix}
 a1a2 & 0 & a1b2+b1\\
 c1a2+c2 & 1 & c1b2+d2+d1\\
 0 & 0 & 1
\end{bmatrix}
$$

所以实际上只用做 4 次加乘即可。（但是我发现循环展开好像比这个做法快？算了，还是建议学一下）

2. 本题中的 $dpl$ 数组会是要修改的，有可能会除以 0，所以可以开一个结构体，把一个数表示成 $x\times 0^y$ 的形式，除 0 的时候把 $y$ 减少即可。

然后应该就没有然后了。

不喜勿喷。

[code](https://www.luogu.com.cn/paste/a2coaqw9)

---

## 作者：Rorschachindark (赞：10)

# 切树游戏
[题目传送门](https://www.luogu.com.cn/problem/P3781)
## 题目大意
给出一个$n$个点的树，有$m$次操作，每次要么查询有多少棵子树异或之和为$k$,$k$为每次给出的常数，要么修改一个点的权值。
## 前置定义
下面我们统称$son_u$为$u$的儿子，$wson_u$为$u$的重儿子。$FWT[a_u]$表示只有$A[a_u]=1$的$FWT[A]$，树以$1$为根。
## 思路
本来想看题解的，但是发现题解看不懂，于是只好自己想，但是发现还是很好想的，只是代码有那么**亿点**难调。。。

首先，看到异或之和我们显然得想到$\texttt{FWT}$（不会的可以[戳这里学习一下](https://www.cnblogs.com/Dark-Romance/p/13266355.html)）。我们如果设:

$$nf[u]=FWT[a_u]$$

再设$f[u]$表示以$u$为根的答案（$\texttt{IFWT}$之前的），那么可以得到:

$$f[u]=nf[u]\prod_{v\in son_u}(f[v]+1)$$

这个非常显然。

最后的答案（$\texttt{IFWT}$之前）就是:

$$\sum_{i=1}^{n} f[u]$$

如果我们设:

$$s[u]=f[u]+\sum_{v\in son_u} s[v]$$

那么，答案就是$s[1]$。

我们发现这个式子非常简洁，于是我们可以联想到动态dp，我们于是可以设:

$$lf[u]=nf[u]\prod_{v\in son_u\wedge v\not= wson_u} (f[v]+1)$$

$$ls[u]=\sum_{v\in son_u\wedge v\not= wson_u} s[v]$$

就可以得到:

$$f[u]=lf[u](f[wson_u]+1)$$

$$s[u]=ls[u]+s[wson_u]+f[u]$$

$$=ls[u]+s[won_u]+lf[u]f[wson_u]+lf[u]$$

我们将上面的式子用矩阵表示出来，就是:

$$\begin{bmatrix}lf[u]&0&lf[u]\\lf[u]&1&lf[u]+ls[u]\\0&0&1\end{bmatrix}\begin{bmatrix}f_{wson_u}\\s_{wson_u}\\1\end{bmatrix}=\begin{bmatrix}f_u\\s_u\\1\end{bmatrix}$$

于是，我们就可以用树链剖分维护这个东西。但是这个矩阵巨大的常数$27$会让我们$\texttt{GG}$得很惨。

我们可以看到这样一个神奇的事情:

$$\begin{bmatrix}a_1&0&b_1\\c_1&1&d_1\\0&0&1\end{bmatrix}\begin{bmatrix}a_2&0&b_2\\c_2&1&d_2\\0&0&1\end{bmatrix}=\begin{bmatrix}a_1a_2&0&a_1b_2+b1\\a_2c_1+c2&1&c_1b_2+d_2+d_1\\0&0&1\end{bmatrix}$$

于是，我们就只需要维护$a_1,b_1,c_1,d_1$，常数就降到了$4$。

不过这个题还有一个问题，就是我们的$f[u]$里面有乘积式，也就意味着，我们在更改重链头的时候它的父亲需要除以重链头的$f+1$。虽然$\texttt{FWT}$是可以除的，但是如果里面有$0$的话就无法让信息复原。一个解决办法是再开一个线段树维护每个节点所有虚儿子的$f+1$之积，另外一种方法就是记录$0$的个数。我用的前者，因为比较好封装。

于是，我们就在$\Theta(nm+q\log^2nm)$的时间复杂度内解决了这个问题。

不过话说，luogu上有人出了可以卡掉树剖的数据，所以会$\texttt{T}$掉两个点，以下代码只能在$\texttt{LOJ}$通过。

这里提一个小醒，$\texttt{FWT}$数组每次初始化的时候不能$\texttt{memset}$，否则会$\texttt{MLE}$。
## $\texttt{Code}$
[代码戳这里打开](https://www.luogu.com.cn/paste/qyrja9vm)

---

## 作者：木xx木大 (赞：9)

[P3781 [SDOI2017]切树游戏](https://www.luogu.com.cn/problem/P3781) 

首先考虑不带修时的暴力 dp：设 $f_{u,i}$ 表示以 $u$ 为根、价值为 $i$ 的联通子树的个数，$h_{u,i}$ 表示 $u$ 子树内 $f_{v,i}$ 的和，转移为 
$$
f_{u,k}+=\sum_{i \oplus j=k}f_{u,i}\times f_{v,j},h_{u,i}=f_{u,i}+\sum h_{v,i}
$$
复杂度为 $O(nm^2)$ 。发现转移式是一个异或卷积的形式，于是可以先 FWT 一次，转移时直接用点值相乘，复杂度为 $O(nm)$

带修怎么办？动态 dp！设 $lf_{u,i}=\prod_{v\in lightson_{u}}(1+f_{v,i}),lh_{u,i}=\sum_{v\in lightson_{u}}h_{v,i}$ 。设 $F,H,LF,LH$ 分别表示 $f,h,lf,lh$ 的生成函数，设 $v$ 为 $u$ 的重儿子，则转移为
$$
f_{u,i}=(1+f_{v,i})\times lf_{u,i}\\
h_{u,i}=h_{v,i}+lh_{u,i}+(1+f_{v,i})\times lf_{u,i}\\
\begin{pmatrix} F_v,H_v,1\\\end{pmatrix}\times\begin{pmatrix}\ &LF_u,&LF_u,&0\\&0,&1,&0\\&LF_u,&LH_u+LF_u,&1\end{pmatrix}=\begin{pmatrix} F_u,H_u,1\\\end{pmatrix}
$$
优化常数：如下式，其实我们只需要维护 $a,b,c,d$ 处的四个值即可。
$$
\begin{pmatrix}&a_1,&b_1,&0\\&0,&1,&0\\&c_1,&d_1,&1\end{pmatrix}\times\begin{pmatrix}\ &a_2,&b_2&0\\&0,&1,&0\\&c_2,&d_2,&1\end{pmatrix}=\begin{pmatrix}\ &a_1a_2,&a_1b_2+b_1,&0\\&0,&1,&0\\&a_2c_1+c_2,&c_1b_2+d_1+d_2,&1\end{pmatrix}
$$
还有一个细节：跳重链修改父亲 $lf$ 的值的时候可能会出现除以 0 的情况，所以必须再开一个变量记 $lf$ 中 0 的个数，除以 0 就直接减一，通过这个变量推出 $lf$ 的真实值。

这里放一个loj能过，洛谷被卡到 T 飞的垃圾树剖代码，复杂度 $O(qm\log^2n)$，洛谷上 80 pts。

```cpp
#include<bits/stdc++.h>
#define inl inline
#define mid ((l+r)>>1)
using namespace std;
typedef pair<int,int> pii;
namespace FGF
{
	int n,m,Q;
	const int N=30005,M=135,mo=1e4+7;
	int a[N],siz[N],son[N],fa[N],dep[N],top[N],dfn[N],id[N],c[M][M],f[N][M],h[N][M],lh[N][M],tmp1[M],tmp2[M],ed[N],inv[N],num;
	vector<int> g[N];
	struct matrx{
		int a[M],b[M],c[M],d[M];
		void clear()
		{
			memset(a,0,sizeof(int[m])),memset(b,0,sizeof(int[m])),memset(c,0,sizeof(int[m])),memset(d,0,sizeof(int[m]));
		}
	}t[N<<2];
	struct Node{
		int x,y;
		inline void operator =(int a){a?(x=a,y=0):(x=1,y=1);}
		friend Node operator *(Node a,int b){!b?a.y++:a.x=1ll*a.x*b%mo;return a;}
		friend Node operator /(Node a,int b){!b?a.y--:a.x=1ll*a.x*inv[b]%mo;return a;}
		int val(){return y?0:x;}
	}lf[N][M];
	inl matrx operator *(const matrx &x,const matrx &y)
	{
		matrx s;s.clear();
		for(int i=0;i<m;i++)
		{
			s.a[i]=x.a[i]*y.a[i]%mo;
			s.b[i]=(x.a[i]*y.b[i]%mo+x.b[i])%mo;
			s.c[i]=(x.c[i]*y.a[i]%mo+y.c[i])%mo;
			s.d[i]=(x.c[i]*y.b[i]%mo+x.d[i]+y.d[i])%mo;
		}
		return s;
	}
	void dfs1(int u,int f)
	{
		fa[u]=f,dep[u]=dep[f]+1,siz[u]=1;
		for(auto v:g[u])
			if(v!=f)
			{
				dfs1(v,u);
				siz[u]+=siz[v];
				if(siz[v]>siz[son[u]])son[u]=v;
			}
	}
	void dfs2(int u,int tp)
	{
		top[u]=tp,dfn[u]=++num,id[num]=u,ed[tp]=u;
		if(son[u])dfs2(son[u],tp);
		for(auto v:g[u])
			if(v!=son[u]&&v!=fa[u])dfs2(v,v);
	}
	inl void FWTxor(int *y,int op)
	{
		for(int i=1;1<<i<=m;i++)
			for(int j=0;j<m;j+=(1<<i))
				for(int k=0,c,d;k<(1<<(i-1));k++)
					c=(y[j|k]+y[j|k|(1<<(i-1))])%mo,d=(y[j|k]-y[j|k|(1<<(i-1))]+mo)%mo,
					y[j|k]=1ll*op*c%mo,y[j|k|(1<<(i-1))]=1ll*op*d%mo;
	}
	void dfs3(int u)
	{
		for(int i=0;i<m;i++)
			f[u][i]=c[a[u]][i];
		for(auto v:g[u])
			if(v!=fa[u])
			{
				dfs3(v);
				for(int i=0;i<m;i++)
					f[u][i]=(f[u][i]+f[u][i]*f[v][i]%mo)%mo,h[u][i]=(h[u][i]+h[v][i])%mo;
			}  
		for(int i=0;i<m;i++)
			h[u][i]=(h[u][i]+f[u][i])%mo;
	}
	void build(int ro,int l,int r)
	{
		if(l==r)
		{
			int u=id[l];
			for(int i=0;i<m;i++)
				lf[u][i]=c[0][i];
			for(auto v:g[u])
				if(v!=son[u]&&v!=fa[u])
					for(int i=0;i<m;i++)
						lf[u][i]=lf[u][i]*((f[v][i]+1)%mo),lh[u][i]=(lh[u][i]+h[v][i])%mo;
			for(int i=0;i<m;i++)
				t[ro].a[i]=t[ro].b[i]=t[ro].c[i]=t[ro].d[i]=lf[u][i].val()*c[a[u]][i]%mo,(t[ro].d[i]+=lh[u][i])%=mo;
			return;	
		}
		build(ro<<1,l,mid),build(ro<<1|1,mid+1,r);
		t[ro]=t[ro<<1|1]*t[ro<<1];
	}
	matrx query(int ro,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R)return t[ro];
		if(R<=mid)return query(ro<<1,l,mid,L,R);
		if(L>mid)return query(ro<<1|1,mid+1,r,L,R);
		return query(ro<<1|1,mid+1,r,L,R)*query(ro<<1,l,mid,L,R);
	}
	void modif(int ro,int l,int r,int x)
	{
		if(l==r)
		{
			int u=id[l];
			for(int i=0;i<m;i++)
				t[ro].a[i]=t[ro].b[i]=t[ro].c[i]=t[ro].d[i]=lf[u][i].val()*c[a[u]][i]%mo,(t[ro].d[i]+=lh[u][i])%=mo;
			return;	
		}
		x<=mid?modif(ro<<1,l,mid,x):modif(ro<<1|1,mid+1,r,x);
		t[ro]=t[ro<<1|1]*t[ro<<1];
	}
	void askk(int x)
	{
		matrx ans=query(1,1,n,dfn[top[x]],dfn[ed[top[x]]]);
		for(int i=0;i<m;i++)
			tmp1[i]=ans.c[i],tmp2[i]=ans.d[i];
	}
	void updat(int x,int y)
	{
		a[x]=y;
		while(x)
		{
			askk(x);
			if(fa[top[x]])
				for(int i=0;i<m;i++)
					lf[fa[top[x]]][i]=lf[fa[top[x]]][i]/((tmp1[i]+1)%mo),lh[fa[top[x]]][i]=(lh[fa[top[x]]][i]-tmp2[i]+mo)%mo;
			modif(1,1,n,dfn[x]),askk(x);	
			if(fa[top[x]])
				for(int i=0;i<m;i++)
					lf[fa[top[x]]][i]=lf[fa[top[x]]][i]*((tmp1[i]+1)%mo),lh[fa[top[x]]][i]=(lh[fa[top[x]]][i]+tmp2[i])%mo;
			x=fa[top[x]];
		}
	}
	void work()
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)	
			scanf("%d",&a[i]);
		for(int i=1,u,v;i<n;i++)
			scanf("%d%d",&u,&v),g[u].push_back(v),g[v].push_back(u);
		for(int i=0;i<m;i++)
			c[i][i]=1,FWTxor(c[i],1);
		inv[1]=1;
		for(int i=2;i<mo;i++)
			inv[i]=inv[mo%i]*(mo-mo/i)%mo;
		dfs1(1,0),dfs2(1,1),dfs3(1);
		build(1,1,n);
		scanf("%d",&Q);
		while(Q--)
		{
			char ch[20];int x,y;
			scanf("%s%d",ch,&x);
			if(ch[0]=='C')scanf("%d",&y),updat(x,y);
			else askk(1),FWTxor(tmp2,(mo+1)/2),printf("%d\n",tmp2[x]);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

全局平衡二叉树：
```cpp
#include<bits/stdc++.h>
#define inl inline
using namespace std;
typedef pair<int,int> pii;
namespace FGF
{
	int n,m,Q;
	const int N=30005,M=135,mo=1e4+7;
	int a[N],siz[N],son[N],c[M][M],f[N][M],h[N][M],lh[N][M],tmp[M],ff[N],inv[N];
	int fa[N],rt,ls[N],rs[N],st[N],sum[N];
	vector<int> g[N];
	struct matrx{
		int a[M],b[M],c[M],d[M];
		void clear()
		{
			memset(a,0,sizeof(int[m])),memset(b,0,sizeof(int[m])),memset(c,0,sizeof(int[m])),memset(d,0,sizeof(int[m]));
		}
	}hw[N];
	struct Node{
		int x,y;
		inline void operator =(int a){a?(x=a,y=0):(x=1,y=1);}
		friend Node operator *(Node a,int b){!b?a.y++:a.x=1ll*a.x*b%mo;return a;}
		friend Node operator /(Node a,int b){!b?a.y--:a.x=1ll*a.x*inv[b]%mo;return a;}
		int val(){return y?0:x;}
	}lf[N][M];
	inl matrx operator *(const matrx &x,const matrx &y)
	{
		matrx s;s.clear();
		for(int i=0;i<m;i++)
		{
			s.a[i]=x.a[i]*y.a[i]%mo;
			s.b[i]=(x.a[i]*y.b[i]%mo+x.b[i])%mo;
			s.c[i]=(x.c[i]*y.a[i]%mo+y.c[i])%mo;
			s.d[i]=(x.c[i]*y.b[i]%mo+x.d[i]+y.d[i])%mo;
		}
		return s;
	}
	void dfs(int u,int fa)
	{
		ff[u]=fa,siz[u]=1;
		for(int i=0;i<m;i++)
			f[u][i]=c[a[u]][i],lf[u][i]=c[0][i];
		for(auto v:g[u])
			if(v!=fa)
			{
				dfs(v,u);
				siz[u]+=siz[v];
				if(siz[v]>siz[son[u]])son[u]=v;
				for(int i=0;i<m;i++)
					f[u][i]=(f[u][i]+f[u][i]*f[v][i]%mo)%mo,h[u][i]=(h[u][i]+h[v][i])%mo;
			}
		for(int i=0;i<m;i++)
			h[u][i]=(h[u][i]+f[u][i])%mo;
		for(auto v:g[u])
			if(v!=son[u]&&v!=ff[u])
				for(int i=0;i<m;i++)
					lf[u][i]=lf[u][i]*((f[v][i]+1)%mo),lh[u][i]=(lh[u][i]+h[v][i])%mo;
	}
	inl void FWTxor(int *y,int op)
	{
		for(int i=1;1<<i<=m;i++)
			for(int j=0;j<m;j+=(1<<i))
				for(int k=0,c,d;k<(1<<(i-1));k++)
					c=(y[j|k]+y[j|k|(1<<(i-1))])%mo,d=(y[j|k]-y[j|k|(1<<(i-1))]+mo)%mo,
					y[j|k]=1ll*op*c%mo,y[j|k|(1<<(i-1))]=1ll*op*d%mo;
	}
	void pushup(int x)
	{
		for(int i=0;i<m;i++)
			hw[x].a[i]=hw[x].b[i]=hw[x].c[i]=hw[x].d[i]=lf[x][i].val()*c[a[x]][i]%mo,(hw[x].d[i]+=lh[x][i])%=mo;
    	if(ls[x])hw[x]=hw[x]*hw[ls[x]];
		if(rs[x])hw[x]=hw[rs[x]]*hw[x];
	}
	int construc(int L,int R)
	{
		int l=L,r=R,mid,ans,x;
		while(l<=r)
		{
			mid=(l+r)>>1;
			sum[mid-1]-sum[L-1]<=sum[R]-sum[mid-1]?(l=mid+1,ans=mid):r=mid-1;
		}
		x=st[ans];
		if(ans!=L)ls[x]=construc(L,ans-1),fa[ls[x]]=x;
		if(ans!=R)rs[x]=construc(ans+1,R),fa[rs[x]]=x;
		pushup(x);
		return x;
	}
	int build(int x)
	{
		int y=x;
		do{
			for(auto v:g[y])
				if(v!=son[y]&&v!=ff[y])fa[build(v)]=y;
		}while(y=son[y]);
		while(x)st[++y]=x,sum[y]=sum[y-1]+siz[x]-siz[son[x]],x=son[x];
		return construc(1,y);
	}
	void updat(int x,int y)
	{
		a[x]=y;
		while(x)
		{
			if(fa[x]&&ls[fa[x]]!=x&&rs[fa[x]]!=x)
			{
				for(int i=0;i<m;i++)
					lf[fa[x]][i]=lf[fa[x]][i]/((hw[x].c[i]+1)%mo),lh[fa[x]][i]=(lh[fa[x]][i]-hw[x].d[i]+mo)%mo;
				pushup(x);	
				for(int i=0;i<m;i++)
					lf[fa[x]][i]=lf[fa[x]][i]*((hw[x].c[i]+1)%mo),lh[fa[x]][i]=(lh[fa[x]][i]+hw[x].d[i])%mo;
			}
			else pushup(x);
			x=fa[x];
		}
	}
	void work()
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)	
			scanf("%d",&a[i]);
		for(int i=1,u,v;i<n;i++)
			scanf("%d%d",&u,&v),g[u].push_back(v),g[v].push_back(u);
		for(int i=0;i<m;i++)
			c[i][i]=1,FWTxor(c[i],1);
		inv[1]=1;
		for(int i=2;i<mo;i++)
			inv[i]=inv[mo%i]*(mo-mo/i)%mo;
		dfs(1,0),rt=build(1);;
		scanf("%d",&Q);
		while(Q--)
		{
			char ch[20];int x,y;
			scanf("%s%d",ch,&x);
			if(ch[0]=='C')scanf("%d",&y),updat(x,y);
			else 
			{
				for(int i=0;i<m;i++)
					tmp[i]=hw[rt].d[i];
				FWTxor(tmp,(mo+1)/2),printf("%d\n",tmp[x]);
			}
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：litble (赞：7)

# 题目分析
[dalao tql](http://immortalco.blog.uoj.ac/blog/2625)

## 暴力DP
设$f(x,k)$表示深度最浅点为$x$的连通块，价值为$k$的有多少个。

那么对于$x$，在遍历儿子前$f(x,v_x)=1$。对于每个儿子$y$，都有转移：

$$f'(x,k)=f(x,k)+\sum_{i=0}^{m-1}f(x,i)f(y,k-i)$$

对于一个询问，统计所有$x$的$f(x,k)$。

复杂度$O(Qnm^2)$

## 加个FWT
发现上面那个式子是个卷积的形式，那么弄个FWT来搞搞。

一开始将所有数组都先FWT一次，那么中间过程的所有卷积操作都变成直接乘法了，最后再FWT回来，复杂度$O(Qnm)$

## 动态DP
首先按照动态DP的关键先树剖一下，然后就是轻重儿子分开考虑了。

不能对于每次询问，把每个节点的$f(x,k)$都加起来了，所以设一个$h(x,k)$，表示子树$x$内每一个节点的$f(y,k)$的和。

设$lf(x,k)=\prod_{y \in lightson_x} (1+f(y,k)),lh(x,k)=\sum_{y \in lightson_x} h(y,k)$

写出生成函数$F(x)=\sum_{i=0}^{m-1} f(x,i)z^i$，$H(x),lF(x),lH(x)$以此类推。

设$x$的重儿子为$y$，那么向量$(F(y),H(y),z^0)$转移到$(F(x),H(x),z^0)$是乘了这样一个矩阵：

$$\begin{pmatrix} lF(x) {z^{v_{x}}} & lF(x) {z^{v_{x}}} & 0\\ 0 & 1 & 0 \\ lF(x) {z^{v_{x}}} & lH(x) + lF(x {z^{v_{x}}} & 1\end{pmatrix}$$

那么接下来的事情就是，用一棵线段树维护一段区间内的转移矩阵的乘积。

询问比较好处理，直接将根节点所在重链的所有转移矩阵乘起来就行了。

修改的话，一路条重链上去，这条重链链顶的$F$和$H$改变了，会导致链顶父亲的$lF$和$lH$改变，维护一下即可……呃，等等。

“维护一下即可”？说的轻巧。因为$lF(x)=\prod_{y \in lightson_x} (F(y)+1)$，所以我们先要除以$y$在$F$改变前的$F(y)+1$，再乘以改变后的。可是这个要除的值，可能是个负数。

于是我们需要用结构体写个特殊的变量来维护$lF(x)$，这个变量将一个值写成$x \times 0^y$的形式。除以0的时候，就直接将$y$减1即可。

## 常数优化
正解算法已经出炉了，但是还可以进行常数优化。我们的矩阵是$3 \times 3$的，相当于常数为$27$。

但是（式子直接抄的immortalCO大神的）：

$$\begin{pmatrix} a_1 & b_1 & 0 \\ 0 & 1 & 0 \\ c_1 & d_1 & 1 \end{pmatrix} \times \begin{pmatrix} a_2 & b_2 & 0 \\ 0 & 1 & 0 \\ c_2 & d_2 & 1 \end{pmatrix} = \begin{pmatrix} a_1 a_2 & b_1 + a_1 b_2 & 0 \\ 0 & 1 & 0 \\ a_2 c_1 + c_2 & b_2 c_1 + d_1 + d_2 & 1 \end{pmatrix}$$

所以我们只要维护$a,b,c,d$四个值即可，常数减小到$4$。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
const int M=130,inv2=5004,mod=10007,N=30005;
int n,m,Q,tot,tim;
int e[M][M],inv[mod+5],v[N],tmp1[M],tmp2[M];
int h[N],ne[N<<1],to[N<<1];
struct orz{
	int x,y;
	void put_val(int k) {if(k) x=k,y=0; else x=1,y=1;}
	friend orz operator * (orz A,int B) {
		if(!B) ++A.y; else A.x=A.x*B%mod;
		return A;
	}
	friend orz operator / (orz A,int B) {
		if(!B) --A.y; else A.x=A.x*inv[B]%mod;
		return A;
	}
	int val() {return y?0:x;}
};
int qm(int x) {return x>=mod?x-mod:x;}
void add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot;}
void FWT(int *a,int n,int x) {
    for(RI i=1;i<n;i<<=1)
        for(RI j=0;j<n;j+=(i<<1))
            for(RI k=0;k<i;++k) {
                int t1=a[j+k],t2=a[j+i+k];
                a[j+k]=qm(t1+t2),a[j+i+k]=qm(t1-t2+mod);
                if(x==-1) a[j+k]=a[j+k]*inv2%mod,a[j+i+k]=a[j+i+k]*inv2%mod;
            }
}

int fa[N],dep[N],top[N],sz[N],pos[N],repos[N],son[N],bot[N];
orz lF[N][M];int F[N][M],H[N][M],lH[N][M];
void dfs1(int x,int las) {
    fa[x]=las,dep[x]=dep[las]+1,sz[x]=1;
    for(RI i=h[x];i;i=ne[i])
        if(to[i]!=las) dfs1(to[i],x),sz[x]+=sz[to[i]];
}
void dfs2(int x,int las) {
    int bj=0,mx=0; pos[x]=++tim,repos[tim]=x;
    for(RI i=h[x];i;i=ne[i])
        if(to[i]!=las&&sz[to[i]]>mx) mx=sz[to[i]],bj=to[i];
    if(!bj) {bot[top[x]]=pos[x];return;}
    son[x]=bj,top[bj]=top[x],dfs2(bj,x);
    for(RI i=h[x];i;i=ne[i])
        if(to[i]!=las&&to[i]!=bj) top[to[i]]=to[i],dfs2(to[i],x);
}
void pre_dfs(int x,int las) {
    for(RI i=0;i<m;++i) F[x][i]=e[v[x]][i];
    for(RI i=h[x];i;i=ne[i]) {
        if(to[i]==las) continue;
        pre_dfs(to[i],x);
        for(RI j=0;j<m;++j) {
            F[x][j]=qm(F[x][j]+F[x][j]*F[to[i]][j]%mod);
            H[x][j]=qm(H[x][j]+H[to[i]][j]);
        }
    }
    for(RI i=0;i<m;++i) H[x][i]=qm(H[x][i]+F[x][i]);
}
void pre_getl() {
	for(RI x=1;x<=n;++x) {
		for(RI i=0;i<m;++i) lF[x][i].put_val(e[0][i]),lH[x][i]=0;
		for(RI i=h[x];i;i=ne[i]) {
			if(to[i]==fa[x]||to[i]==son[x]) continue;
			for(RI j=0;j<m;++j) {
				lF[x][j]=lF[x][j]*qm(1+F[to[i]][j]);
				lH[x][j]=qm(lH[x][j]+H[to[i]][j]);
			}
		}
	}
}

struct tree_node{int a[M],b[M],c[M],d[M];}tr[N<<2];
tree_node operator * (tree_node A,tree_node B) {
	tree_node C;
	for(RI i=0;i<m;++i) C.a[i]=C.b[i]=C.c[i]=C.d[i]=0;
	for(RI i=0;i<m;++i) {
		C.a[i]=A.a[i]*B.a[i]%mod;
		C.b[i]=qm(A.b[i]+A.a[i]*B.b[i]%mod);
		C.c[i]=qm(B.a[i]*A.c[i]%mod+B.c[i]);
		C.d[i]=qm(B.b[i]*A.c[i]%mod+qm(A.d[i]+B.d[i]));
	}
	return C;
}
void update_node(int i,int x) {
	for(RI j=0;j<m;++j) {
		tr[i].a[j]=tr[i].b[j]=tr[i].c[j]=tr[i].d[j]=lF[x][j].val()*e[v[x]][j]%mod;
		tr[i].d[j]=qm(tr[i].d[j]+lH[x][j]);
	}
}
void build(int s,int t,int i) {
	if(s==t) {update_node(i,repos[s]);return;}
	int mid=(s+t)>>1;
	build(s,mid,i<<1),build(mid+1,t,(i<<1)|1);
	tr[i]=tr[(i<<1)|1]*tr[i<<1];//注意合并的顺序QAQ
}
tree_node query(int l,int r,int s,int t,int i) {
	if(l<=s&&t<=r) return tr[i];
	int mid=(s+t)>>1;
	if(r<=mid) return query(l,r,s,mid,i<<1);
	if(mid+1<=l) return query(l,r,mid+1,t,(i<<1)|1);
	return query(l,r,mid+1,t,(i<<1)|1)*query(l,r,s,mid,i<<1);
}
void chan(int x,int s,int t,int i) {
	if(s==t) {update_node(i,repos[s]);return;}
	int mid=(s+t)>>1;
	if(x<=mid) chan(x,s,mid,i<<1);
	else chan(x,mid+1,t,(i<<1)|1);
	tr[i]=tr[(i<<1)|1]*tr[i<<1];
}

void getans(int x) {
	tree_node re=query(pos[x],bot[x],1,n,1);
	for(RI i=0;i<m;++i) tmp1[i]=re.c[i],tmp2[i]=re.d[i];//F,H
}
void walk(int x,int new_v) {
	v[x]=new_v;
	while(x) {
		int y=fa[top[x]];getans(top[x]);
		if(y) {
			for(RI i=0;i<m;++i)
				lF[y][i]=lF[y][i]/qm(tmp1[i]+1),
				lH[y][i]=qm(lH[y][i]-tmp2[i]+mod);
		}
		chan(pos[x],1,n,1),getans(top[x]);
		if(y) {
			for(RI i=0;i<m;++i)
				lF[y][i]=lF[y][i]*qm(tmp1[i]+1),
				lH[y][i]=qm(lH[y][i]+tmp2[i]);
		}
		x=y;
	}
}

int main()
{
	char op[10];int x,y;
	scanf("%d%d",&n,&m);
	for(RI i=1;i<=n;++i) scanf("%d",&v[i]);
	for(RI i=1;i<n;++i) scanf("%d%d",&x,&y),add(x,y),add(y,x);
	for(RI i=0;i<m;++i) e[i][i]=1,FWT(e[i],m,1);
	inv[1]=1;for(RI i=2;i<mod;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	dfs1(1,0),top[1]=1,dfs2(1,0),pre_dfs(1,0),pre_getl(),build(1,n,1);
	scanf("%d",&Q);
	while(Q--) {
		scanf("%s",op);
		if(op[0]=='C') scanf("%d%d",&x,&y),walk(x,y);
		else {
			scanf("%d",&x),getans(1);
			FWT(tmp2,m,-1),printf("%d\n",tmp2[x]);
		}
	}
	return 0;
}
```

---

## 作者：big_news (赞：5)

提供一个不使用矩阵乘法的解法，理论复杂度 $O(nm)-O(m\log n)$，常数在 2~3 左右，实际运行效率与矩阵乘法相当，参考了 [_rqy](https://rqy.moe/Solutions/bzoj4911/) 神仙的博客。

rqy 贴在上面的代码复杂度好像有点小问题，应该是过不了 LG 的数据的，这里我重新用全局平衡二叉树实现了一下，去掉了一个 $\log$。

先考虑一个 DP：设 $f[u,k]$ 表示考虑以 $u$ 为根的**连通子树**，点权异或和为 $k$ 的有多少个，那么转移是 $f'[u,k]\gets f[v,i]f[u,j][i\oplus j=k]$，可以理解做一个类似树上背包的东西。

我们要求的答案就是 $\sum\limits_{i=1}^n f[i,x]$。

注意到转移中求和是充分的，也就是说这是一类下标运算为异或的序列卷积。

我们用多项式的理论去分析，就相当于树上每个节点上有一个生成函数 $F(u,z)=\sum\limits_{i=0}^{m-1}f[u,i]z^i$，DP 的转移就变成了 $F(u,z)=z^{w_u}\prod\limits_{fa[v]=u}(1+F(v,z))$，其中 $w_u$ 是点权，乘法定义为异或卷积。

考虑维护动态 DP。我们先用熟悉的重链剖分来分析。

设 $G(u,z)=z^{w_u}\prod\limits_{fa[v]=u,v\neq p[u]}(1+F(u,z))$，其中 $p[u]$ 是 $u$ 的重儿子，那么有 $F(u,z)=(1+F(p[u],z))G(u,z)$。

我们考虑在重链剖分的 dfs 序上，用线段树维护 $G()$。对于一条重链，有：

$$F(u,z)=(1+F(p[u],z))G(u,z)=G(u,z)+G(u,z)G(p[u],z)(1+F(p[p[u]],z))=...$$

我们把这个柿子一直展开下去，直到叶子节点（重链的结束一定是叶子），就可以推得一个点对应的目标生成函数 $F(u,z)$ 即是其重链上这一段后缀所有前缀卷积的和。

形式化地，设 $u$ 在 dfs 序上的位置是 $l$，$u$ 所在重链的叶节点在 dfs 序上的位置是 $r$，有 $F(l,z)=\sum\limits_{i=l}^r\prod\limits_{j=l}^i G(i,z)$。为了表示方便，柿子中的下标做了一些变化。

最终答案即是所有重链的答案和，而容易发现，一条重链的答案就是**这一段区间的所有子区间的乘积和**。

考虑如何快速地维护生成函数的卷积。朴素的做法是 $O(m^2)$ 的，这显然不行。我们考虑对其进行快速沃尔什变换（FWT），即设 $f$ 是 $F$ 的系数序列，有：

$$\mathcal{F}(f)_i=\sum\limits_{j=0}^{m-1}(-1)^{|i\cap j|}f_j$$

可以证明该变换满足卷积定理 $\mathcal{F}(a)_i\mathcal F(b)_i=\mathcal F(ab)_i$ 以及 $\mathcal F(a)_i+\mathcal F(b)_i=\mathcal F(a+b)_i$，那么我们只需要维护点值进行运算即可。

考虑现在如果修改 $w_u$ 为 $w'_u$，那么相当于需要把 $G(u)$ 除掉一个 $x^{w_u}$ 再乘 $x^{w'_u}$；把 $G(fa[top[u]])$（$top[u]$ 是重链顶端）除掉一个 $F(top[u])$ 再乘 $F'(top[u])$；然后一直传递影响到根。这些都可以通过点值的乘 / 除在 $O(m)$ 的时间内实现。

我们要维护答案，就只需要维护线段树上某个区间所有子区间乘积的和。这个可以维护每个区间的子区间乘积和，前缀区间乘积和，后缀区间乘积和，还有区间乘积，
来实现。实际上就是广义乘法分配率 $\sum\limits_{i=1}^k\sum\limits_{j=k+1}^n s_ip_j=\left( \sum\limits_{i=1}^k s_i\right)\left(\sum\limits_{i=k+1}^np_i \right)$。

我们发现这样做只影响到了 $O(\log n)$ 个点的点权，也就是说如果我们直接维护树链剖分然后大力修改，就可以得到 $O(nm)-O(m\log^2 n)$ 的做法。

~~听说加个 O 松优化就过了，事实上对于 loj 的确如此~~  但是过不了 LG 的数据。

我们考虑用全局平衡二叉树来维护。简单来讲，就是对每条重链单独处理，将其看作序列，设 $ep[x]=sz[x]-sz[imp[x]]$ 为某个点的权，然后找到这段序列的带权重心作为根，然后递归左右子序列建立二叉结构。容易证明树高是 $O(\log n)$ 的。

我们可以在每个根处维护它这一段序列的信息，那么改一个点的值，就可以暴力 $O(\log)$ 地跳到树根，沿途把所有重链的权都修改一下好了。

然后考虑全局的答案，就是每个重链的答案之和。我们在修改一条重链时即可维护，上述两步维护都是 $O(m)$ 的，因此修改复杂度 $O(m\log n)$。

也就是说，我们最后维护出来了 $Ans(z)=\sum\limits_{i=1}^n F(i,z)$，$Ans$ 这个生成函数的点值。

再看上面 FWT 的柿子，通过代入法易证 $\mathcal F(\mathcal F(f))_i=mf_i$，那么我们再做一次变换就能求出答案。

这样复杂度就是 $O(nm+qm\log n)$。

有一个坑点：点值计算的时候可能会出现逆元不存在，即除数是模数的倍数。那么手动实现一个取模整数类，将数字拆分成 $a\times P^b$ 的形式维护即可，其中 $P$ 代指模数。

其他题解看起来在计算转移的时候用到了矩阵，但实际上完全可以转化成点值计算。

代码（5.2k）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int CN = 3e4 + 10;
const int P = 1e4 + 7; int inv[P];
int read(){
    int s = 0, ne = 1; char c = getchar();
    for(;c < '0' || c > '9';c = getchar()) if(c == '-') ne = -1;
    for(;c >= '0' && c <= '9';c = getchar()) s = (s << 1) + (s << 3) + c - '0';
    return s * ne;
}
int add(int x, int y) {return x + y >= P ? x + y - P : x + y;}
class Z {
  public: int a, b; // a * P ^ b
    void init(int x) {b = 0, a = (x % P + P) % P;}
    Z operator + (int o){
        Z r = *this; o = (o % P + P) % P;
        if(o){
            if(r.b) r.b = 0, r.a = o;
            else r.a = add(r.a, o);
        }
        return r;
    }
    Z operator * (int o){
        Z r = *this; o = (o % P + P) % P;
        if(!o) r.b++;
        else r.a = r.a * o % P;
        return r;
    }
    Z operator / (int o){
        Z r = *this; o = (o % P + P) % P;
        if(!o) r.b--;
        else r.a = r.a * inv[o] % P;
        return r;
    }
} g[CN][128]; int f[CN][128], pop[128], ans[128];
int n, q, w[CN]; vector<int> G[CN];
int sz[CN], imp[CN];
void dfs(int u, int p){
    sz[u] = 1;
    for(int j = 0; j < 128; j++) g[u][j].init(pop[j & w[u]] & 1 ? -1 : 1);
    for(int l = G[u].size(), i = 0; i < l; i++){
        int v = G[u][i]; if(v == p) continue;
        dfs(v, u), sz[u] += sz[v];
        if(sz[imp[u]] < sz[v]) imp[u] = v;
    }
    for(int l = G[u].size(), i = 0; i < l; i++){
        int v = G[u][i]; if(v == p || v == imp[u]) continue;
        for(int j = 0; j < 128; j++) g[u][j] = g[u][j] * (f[v][j] + 1);
    }
    for(int j = 0; j < 128; j++) if(!g[u][j].b) f[u][j] = g[u][j].a;
    if(imp[u]){
        for(int j = 0; j < 128; j++) f[u][j] = f[u][j] * (f[imp[u]][j] + 1) % P;
    }
    for(int j = 0; j < 128; j++) ans[j] = add(ans[j], f[u][j]);
}
class node{
  public: int sum[128], pre[128], suf[128], prd[128];
    node(){
        for(int i = 0; i < 128; i++){
            sum[i] = pre[i] = suf[i] = 0;
            prd[i] = 1;
        }
    }
    void init(Z g[]){
        for(int j = 0; j < 128; j++){
            sum[j] = pre[j] = suf[j] = prd[j] = g[j].b ? 0 : g[j].a;
        }
    }
    node operator * (const node &o) const{
        node r;
        for(int i = 0; i < 128; i++){
            r.sum[i] = (sum[i] + o.sum[i] + suf[i] * o.pre[i]) % P;
            r.pre[i] = (pre[i] + prd[i] * o.pre[i]) % P;
            r.suf[i] = (o.suf[i] + o.prd[i] * suf[i]) % P;
            r.prd[i] = prd[i] * o.prd[i] % P;
        }
        return r;
    }
} ;
namespace BST{
    node d[CN]; int rt, ch[CN][2], fa[CN], ep[CN], s[CN];
    #define lc ch[u][0]
    #define rc ch[u][1]
    void pu(int u){
        d[u].init(g[u]);
        if(lc && rc) d[u] = (d[lc] * d[u]) * d[rc];
        else if(lc) d[u] = d[lc] * d[u];
        else if(rc) d[u] = d[u] * d[rc];
    }
    int bdseq(int l, int r){
        if(l > r) return 0; int tot = 0, cur = 0;
        for(int i = l; i <= r; i++) tot += ep[i]; tot >>= 1;
        for(int i = l; i <= r; i++){
            int u = s[i]; cur += ep[i];
            if(cur >= tot){
                lc = bdseq(l, i - 1), rc = bdseq(i + 1, r);
                if(lc) fa[lc] = u; if(rc) fa[rc] = u;
                return pu(u), u;
            }
        }
        return -1;
    }
    int bd(int top, int p){
        for(int u = top; u; p = u, u = imp[u])
            for(int l = G[u].size(), i = 0; i < l; i++){
                int v = G[u][i]; if(v == imp[u] || v == p) continue;
                fa[bd(v, u)] = u;
            }
        s[0] = 0;
        for(int u = top; u; u = imp[u]) s[++s[0]] = u, ep[s[0]] = sz[u] - sz[imp[u]];
        return bdseq(1, s[0]);
    }
    bool is(int u) {return u ^ ch[fa[u]][0] && u ^ ch[fa[u]][1];}
    node prv, cur;
    void md(int u, int x){
        for(int j = 0; j < 128; j++){
            if(pop[j & w[u]] & 1) g[u][j] = g[u][j] / -1;
        }
        w[u] = x;
        for(int j = 0; j < 128; j++){
            if(pop[j & w[u]] & 1) g[u][j] = g[u][j] * -1;
        }  
        while(u){
            prv = d[u], pu(u), cur = d[u];
            if(is(u)){
                for(int j = 0; j < 128; j++){
                    ans[j] = add(ans[j], P - prv.sum[j]);
                    ans[j] = add(ans[j], cur.sum[j]);
                }
                if(fa[u]){
                    for(int j = 0; j < 128; j++){
                        g[fa[u]][j] = g[fa[u]][j] / (1 + prv.pre[j]);
                        g[fa[u]][j] = g[fa[u]][j] * (1 + cur.pre[j]);
                    }
                }
            }
            u = fa[u];
        }
    }
}
int qu(int x){
    int res = 0;
    for(int j = 0; j < 128; j++){
        if(pop[j & x] & 1) res = add(res, P - ans[j]);
        else res = add(res, ans[j]);
    }
    return res * inv[128] % P;
}
int main()
{
//    freopen("_in.in", "r", stdin);
    n = read(), read();
    inv[1] = 1; for(int i = 2; i < P; i++) inv[i] = inv[P % i] * (P - P / i) % P;
    for(int i = 1; i < 128; i++) pop[i] = pop[i & (i - 1)] + 1;
    for(int i = 1; i <= n; i++) w[i] = read();
    for(int i = 1; i < n; i++){
        int u = read(), v = read();
        G[u].pb(v), G[v].pb(u);
    }
    dfs(1, 0);
    BST :: rt = BST :: bd(1, 0);
    q = read();
    while(q--){
        char ch[10]; scanf("%s", ch); int x = read();
        if(ch[0] == 'Q') printf("%d\n", qu(x));
        else BST :: md(x, read());
    }
    return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：3)

这里给出 Top tree 做法作为 Top tree 解决动态 dp 的问题的第二个示范。

Top tree 解决动态 dp 方式一般而言有两种：1. 维护上界点答案关于下界点的线性变换。2. 维护是否考虑上下界点的答案。前者一般用于加速简单 dp 的转移，后者用于最优化与计数等复杂度形式的 dp 问题。这道题目显然是后者。

按照 Top tree 维护点集的套路，我们不将上下界点的异或值计入状态贡献，但是还是要开 dp 数组记录上下界点选或不选的 dp 值。

定义 $F_i,G_i,D_i,Z_i$ 分别表示簇内选出一些点（不能选一个界点，可以选一个其他节点或者两个界点）且只包含上界点，只包含下界点，同时包含上下界点，上下界点均不包含的答案。有如下转移式（我们均认为将簇 $x,y$ 合并为簇 $w$）：

对于一个 compress 节点：

$F_{w,i} = \sum_{j \oplus k = i \oplus a_{v}} D_{x,j} \times F_{y,k} + F_{x,i} + D_{x,{i \oplus a_v}}$

$G_{w,i} = \sum_{j \oplus k = i \oplus a_v} G_{x,j} \times D_{y,k} + G_{y,i} + D_{y,{i \oplus a_v}}$

$D_{w,i} = \sum_{j \oplus k = i \oplus a_v} D_{x,j} \times D_{y,k}$

$Z_{w,i} = \sum_{j \oplus k = i \oplus a_v} G_{x,j} \times F_{y,k} + G_{x,i \oplus a_v} + F_{y,i \oplus a_v} + \left[i = a_v \right]$

对于一个 rake 节点：

$F_{w,i} = \sum_{j \oplus k = i} F_{x,j} \times F_{y,k} + \sum_{j \oplus k = i \oplus a_v} D_{x,j} \times F_{y,k} + F_{x,i} + F_{y,i} + D_{x,i \oplus a_v}$

$G_{w,i} = G_{y,i}$

$D_{w,i} = \sum_{j \oplus k = i} F_{x,j} \times D_{y,k} + \sum_{j \oplus k = i \oplus a_v} D_{x,j} \times D_{y,k} + D_{y,i}$

$Z_{u,i} = Z_{x,i} + G_{x,i \oplus a_v} + Z_{y,i}$

然后你发现转移的瓶颈是异或卷积以及异或平移下标，第一个可以将原 dp 数组转变为 fwt 处理后的形式，第二个则可以这么解决：

$a_{i \oplus C} = \sum_{j \oplus k = i} a_i \times \left[k = C \right] = a \otimes \left[i = C \right]$

从而转变为异或卷积形式用 fwt 处理后的数组解决。

最后你就在 $O(m^2 \log m + n \log m + q \times m \log n)$ 的时间复杂度内解决了这个问题。

```cpp
#include<bits/stdc++.h>
#define int long long
const int mod = 10007;
using namespace std;
const int maxn = 6e4+114;
const int maxv = 128;
struct node{
	int u,v,id;
    int f[maxv],g[maxv],d[maxv],z[maxv];
	char type;
}cluster[maxn];
int tran[maxv][maxv];
int n,m;
int a[maxn];
int pos[maxn],fa[maxn],ls[maxn],rs[maxn];
int root=1;
void compress(node x,node y,node &w){
	w.u=x.u;
	w.v=y.v;
    for(int i=0;i<maxv;i++){
        w.f[i]=((x.d[i]*y.f[i]*tran[a[x.v]][i] + x.f[i] + x.d[i]*tran[a[x.v]][i])%mod);
        w.g[i]=((x.g[i]*y.d[i]*tran[a[x.v]][i] + y.g[i] + y.d[i]*tran[a[x.v]][i]%mod)%mod);
        w.d[i]=((x.d[i]*y.d[i]*tran[a[x.v]][i])%mod);
        w.z[i]=((x.g[i]*y.f[i]*tran[a[x.v]][i] + x.g[i]*tran[a[x.v]][i] + y.f[i]*tran[a[x.v]][i] + tran[a[x.v]][i]+x.z[i]+y.z[i])%mod);
    }
	pos[x.v]=w.id;
	fa[x.id]=fa[y.id]=w.id;
	ls[w.id]=x.id;
	rs[w.id]=y.id;
	w.type='C';
	root=w.id;
}
void rake(node x,node y,node &w){
	//把 x rake 到 y 上
	w.u=x.u;
	w.v=y.v;
	for(int i=0;i<maxv;i++){
        w.f[i]=((x.f[i]*y.f[i] + x.d[i]*y.f[i]*tran[a[x.v]][i] + x.f[i] + y.f[i] + x.d[i]*tran[a[x.v]][i])%mod);
        w.g[i]=((y.g[i])%mod);
        w.d[i]=((x.f[i]*y.d[i] + x.d[i]*y.d[i]*tran[a[x.v]][i] + y.d[i])%mod);
        w.z[i]=((x.z[i] + x.g[i]*tran[a[x.v]][i] + y.z[i] + tran[a[x.v]][i])%mod);
	}
	pos[x.v]=w.id;
	fa[x.id]=fa[y.id]=w.id;
	ls[w.id]=x.id;
	rs[w.id]=y.id;
	w.type='R';
	root=w.id;
}
void update(int u){
    if(u==0) return ;
    if(cluster[u].type=='C'){
        compress(cluster[ls[u]],cluster[rs[u]],cluster[u]);
        update(fa[u]);
    }else{
        rake(cluster[ls[u]],cluster[rs[u]],cluster[u]);
        update(fa[u]);
    }
}
vector<int> E[maxn];
int father_pos[maxn];
int father[maxn];
int son[maxn],sz[maxn],tot;
vector<int> st[maxn];
int F[maxv],G[maxv],D[maxv],Z[maxv];
void dfs1(int u){
	sz[u]=1;
	for(int v:E[u]){
		if(v==father[u]) continue;
		father[v]=u;
		father_pos[v]=++tot;
		cluster[tot].u=u,cluster[tot].v=v,cluster[tot].id=tot;
		for(int i=0;i<maxv;i++) cluster[tot].f[i]=F[i],cluster[tot].g[i]=(G[i]),cluster[tot].d[i]=(D[i]),cluster[tot].z[i]=(Z[i]);
		dfs1(v);
		if(sz[v]>sz[son[u]]) son[u]=v;
		sz[u]+=sz[v];
	}
}
void dfs2(int u,int tp){
	st[tp].push_back(u);
	if(son[u]!=0) dfs2(son[u],tp);
	for(int v:E[u]){
		if(v==father[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
vector<int> vec[maxn];
vector<int> pre[maxn];
int solve(int l,int r,int u,char type){
    if(l>r) return 0;
	if(l==r) return father_pos[vec[u][l]];
	int L=l,R=r;
	while(L+1<R){
		int mid=(L+R)>>1;
		if((pre[u][mid]-pre[u][l-1])*2<=(pre[u][r]-pre[u][l-1])) L=mid;
		else R=mid;
	}
	int mid=L;
	int lson=solve(l,mid,u,type);
	int rson=solve(mid+1,r,u,type);
	int res=++tot;
	cluster[tot].id=tot;
	if(type=='R') rake(cluster[lson],cluster[rson],cluster[res]);
	else compress(cluster[lson],cluster[rson],cluster[res]);
	return res;
}
void dfs3(int u){
	for(int x:st[u]){
        if(son[x]==0) continue;
		pre[x].push_back(0);
		vec[x].push_back(0);
		for(int v:E[x]){
			if(v!=son[x]&&v!=father[x]){
				dfs3(v);
				vec[x].push_back(v);
			}
		}
		for(int i=1;i<=vec[x].size()-1;i++){
			pre[x].push_back(pre[x][i-1]+sz[vec[x][i]]);
		}
		int rt=solve(1,vec[x].size()-1,x,'R');
		if(rt!=0){
		    tot++;
		    cluster[tot].id=tot;
            rake(cluster[rt],cluster[father_pos[son[x]]],cluster[tot]);
            father_pos[son[x]]=tot;
		}
	}
	vec[u].clear();
	pre[u].clear();
	pre[u].push_back(0);
	vec[u].push_back(0);
	for(int x:st[u]){
		vec[u].push_back(x);
	}
	for(int i=1;i<=vec[u].size()-1;i++){
		pre[u].push_back(pre[u][i-1]+sz[father[vec[u][i]]]-sz[vec[u][i]]);
	}
	if(u!=1) father_pos[u]=solve(1,vec[u].size()-1,u,'C');
	else father_pos[u]=solve(2,vec[u].size()-1,u,'C');
	E[u].clear();
	E[u].push_back(father[u]);
	return ;
}
void fwt_xor(int *Q,int x=1){
    for(int o=2,k=1;o<=maxv;o<<=1,k<<=1){
        for(int i=0;i<maxv;i+=o)
            for(int j=0;j<k;j++) Q[i+j]=(Q[i+j]+Q[i+j+k])%mod,Q[i+j+k]=(Q[i+j]+mod+mod-Q[i+j+k]-Q[i+j+k])%mod,Q[i+j]=Q[i+j]*x%mod,Q[i+j+k]=Q[i+j+k]*x%mod;
    }
}
int mx;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    D[0]=1;
    fwt_xor(F);
    fwt_xor(G);
    fwt_xor(D);
    fwt_xor(Z);
    for(int i=0;i<maxv;i++){
        tran[i][i]=1;
        fwt_xor(tran[i]);
    }
    cin>>n>>mx;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=2;i<=n;i++){
        int u,v;
        cin>>u>>v;
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs1(1);
    dfs2(1,1);
    dfs3(1);
    cin>>m;
    while(m--){
        string opt;
        cin>>opt;
        if(opt=="Change"){
            int x,y;
            cin>>x>>y;
            a[x]=y;
            update(pos[x]);
        }else{
            int k;
            cin>>k;
            for(int i=0;i<maxv;i++) F[i]=cluster[root].f[i],G[i]=cluster[root].g[i],D[i]=cluster[root].d[i],Z[i]=cluster[root].z[i];
            fwt_xor(F,(mod+1)/2);
            fwt_xor(G,(mod+1)/2);
            fwt_xor(D,(mod+1)/2);
            fwt_xor(Z,(mod+1)/2);
            cout<<(F[k^a[cluster[root].u]]+G[k^a[cluster[root].v]]+D[k^a[cluster[root].u]^a[cluster[root].v]]+Z[k]+(k==a[cluster[root].u])+(k==a[cluster[root].v]))%mod<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：3)

不会全局平衡二叉树 但其实那玩意实质上是个静态lct的玩意

提供一个用lct写的 没想到卡树剖没卡掉lct

用$f(i,j)$表示以点i为顶端有多少个连通块异或和为j，不难写出u加入一个子树v的状态转移(对于每种k):
$f(u,k)=f(u,k)+\sum_{i \bigoplus j=k}f(u,i)f(v,j)$

然后发现这玩意是个异或卷积，用$f'()$表示经fwt转换过的$f$:$f'(u)=f'(u)+f'(u)f'(v)$(因为是fwt后的 所以是直接对应相乘 不用异或卷积)

为了之后方便 直接把$f'()$当成$f()$，即:$f(u)=[w_u]\prod (f(v)+1)$([w_u]表示$w_u$那一项为1的数组 因为只有u这个点自己的时候只有$w_u$的答案为1)

然后这个f只是对于单个点为顶端的，题目询问的是整棵树中，所以不妨对f做个子树和，用$F()$表示:$F(u)=f(u)+\sum_{v\in son_u}F(v)$

根据动态dp的经典套路 用$g$，$G$表示轻子树的$f$,$F$:

$G(u)=\sum_{v\in light_u}F(v) \ \  \ \ g(u)=\prod_{v\in light_u} (f(v)+1)$

然后回去表示f,F:

$f(u)=[w_u](f(heavy_u)+1)g(u)\ \ \ F(u)=f(u)+F(heavy_u)+G(u)$

经典地可以写成一个三维的矩阵乘法

$\begin{vmatrix} F(heavy_u) & f(heavy_u) & 1\end{vmatrix}\quad \times \begin{vmatrix}1 & 0 & 0\\ [w_u]*g(u) & [w_u]*g(u) & 0\\ G(u)+[w_u]*g(u) & [w_u]*g(u) &1\end{vmatrix}\quad=\begin{vmatrix}F(u)&f(u)& 1\end{vmatrix}\quad$

然而还并没有做完 因为切换轻重链更新$g$的时候会遇到/0的情况 所以即每一位上零的个数 最后获取真正的$g$时根据零的个数存不存在还原即可

然后发现这个矩阵有一堆1,0，拿去耍耍

$\begin{vmatrix} 1 & 0 & 0 \\ a & b & 0 \\ c & d &1\end{vmatrix}\times \begin{vmatrix} 1 & 0 & 0 \\ e & f & 0\\ g & h &1\end {vmatrix} \quad \quad=\begin {vmatrix} 1 & 0 & 0 \\ a+be & bf & 0 \\ c+de+g & df+h & 1\end {vmatrix} \quad	 $

发现两个这样形式的矩阵乘完，该01的地方还是01

然后只维护左下角四个，就可以把$3^3=27$的常数降为4
```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
const int N(3e4+5),mod(1e4+7),inv2(1+mod>>1);
inline const int add(const int &a,const int &b){return (a+b)%mod;}
inline const int dec(const int &a,const int &b){return (a-b+mod)%mod;}
inline const int mul(const int &a,const int &b){return a*b%mod;}
int n,w[N],m,q,inv[mod],head[N],edc,to[N<<1],next[N<<1];
inline const void addedge(const int &u,const int &v)
{
	next[++edc]=head[u];to[head[u]=edc]=v;
	next[++edc]=head[v];to[head[v]=edc]=u;
}
struct poly
{
	int val[130];
	inline poly(){for (int i(0);i<128;i++)val[i]=0;}
	inline int &operator[](const int &x){return val[x];}
	inline const void fullset(){for (int i(0);i<m;i++)val[i]=1;}
	inline friend poly operator+(poly a,const poly &b){for (int i(0);i<m;i++)a[i]=add(a[i],b.val[i]);return a;}
	inline friend poly &operator+=(poly &a,const poly &b){for (int i(0);i<m;i++)a[i]=add(a[i],b.val[i]);return a;}
	inline friend poly operator-(poly a,const poly &b){for (int i(0);i<m;i++)a[i]=dec(a[i],b.val[i]);return a;}
	inline friend poly &operator-=(poly &a,const poly &b){for (int i(0);i<m;i++)a[i]=dec(a[i],b.val[i]);return a;}
	inline friend poly operator*(poly a,const poly &b){for (int i(0);i<m;i++)a[i]=mul(a[i],b.val[i]);return a;}
	inline friend poly operator*=(poly &a,const poly &b){for (int i(0);i<m;i++)a[i]=mul(a[i],b.val[i]);return a;}
	inline const void fwt(const int k=1)
	{
		for (int mid(1);mid<m;mid<<=1)
			for (int i(0);i<m;i+=mid<<1)
				for (int j(0);j<mid;j++)
				{
					const int x(val[i+j]),y(val[i+j+mid]);
					val[i+j]=mul(k,add(x,y));
					val[i+j+mid]=mul(k,dec(x,y));
				}
	}
}one;
struct matrix
{
	poly a,b,c,d;
	inline matrix(){}
	inline matrix(const poly &a,const poly &b):a(a),b(a),c(b),d(a){}
	inline matrix(const poly &a,const poly &b,const poly &c,const poly &d):a(a),b(b),c(c),d(d){}
	inline friend matrix operator*(const matrix &A,const matrix &B)
	{
		return matrix(A.a+A.b*B.a,A.b*B.b,A.c+A.d*B.a+B.c,A.d*B.b+B.d);
	}
};
struct sp_poly
{
	poly val,zero;
	inline const void set(const int &x,const int &y)
	{
		if (y)zero[x]=0,val[x]=y;else zero[x]=val[x]=y;
	}
	inline sp_poly operator*=(poly p)
	{
		for (int i(0);i<m;i++)
			if (p[i])val[i]=mul(val[i],p[i]);
			else zero[i]++;
		return *this;
	}
	inline sp_poly operator/=(poly p)
	{
		for (int i(0);i<m;i++)
			if (p[i])val[i]=mul(val[i],inv[p[i]]);
			else zero[i]--;
		return *this;
	}
	inline poly restore()
	{
		static poly t;
		for (int i(0);i<m;i++)t[i]=zero[i]?0:val[i];
		return t;
	}
};
struct tree
{
	matrix f;
	sp_poly g;
	poly G,val;
	tree *son[2],*fa;
	static tree *null;
	void *operator new(size_t size);
	void *operator new[](size_t size);
	inline tree()
	{
		static bool init(0);
		if (!init)
			init=1,
			null=new tree,
			null->son[0]=null->son[1]=null->fa=null;
		g.val=one;
		son[0]=son[1]=fa=null;
	}
	inline const void pushup()
	{
		const poly w(val*g.restore());
		f=matrix(w,w+G);
		if (son[0]!=null)f=son[0]->f*f;
		if (son[1]!=null)f=f*son[1]->f;
	}
	inline const bool isroot()
	{
		return fa->son[0]!=this&&fa->son[1]!=this;
	}
	inline const bool id()
	{
		return fa->son[1]==this;
	}
	inline const void rotate()
	{
		const bool f(id());
		tree *fa(this->fa),*gfa(fa->fa),*q(son[!f]);
		if (!fa->isroot())gfa->son[fa->id()]=this;
		((((son[!f]=fa)->son[f]=q)->fa=fa)->fa=this)->fa=gfa;
		fa->pushup();pushup();
	}
	inline const void splay()
	{
		for (;!isroot();rotate())
			if (!fa->isroot())
				(fa->id()^id()?this:fa)->rotate();
	}
}*tree::null,*node0;
#define node(x) (node0+x)
#define null tree::null
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof(memory_pool));
inline void *tree::operator new(size_t size){return tail-=size;}
inline void *tree::operator new[](size_t size){return tail-=size;}
inline const void access(tree *p)
{
	p->splay();
	if (p->son[1]!=null)
		p->g*=one+p->son[1]->f.a,
		p->G+=p->son[1]->f.c;
	p->son[1]=null;
	p->pushup();
	for (tree *q(p->fa);q!=null;q=p->fa)
	{
		q->splay();
		if (q->son[1]!=null)
			q->g*=one+q->son[1]->f.a,
			q->G+=q->son[1]->f.c;
		q->g/=one+(q->son[1]=p)->f.a,
		q->G-=p->f.c,
		q->pushup(),
		p->rotate();
	}
}
inline const void link(tree *p,tree *q)
{
	q->fa=p;
	p->g*=q->f.a+one;
	p->G+=q->f.c;
	p->pushup();
}
inline const void modify(tree *p,const int &v)
{
	access(p);
	poly f;f[v]=1;f.fwt();p->val=f;
	p->pushup();
}
inline const int query(const int &k)
{
	node(1)->splay();
	poly f(node(1)->f.c);
	f.fwt(inv2);
	return f[k];
}
poly f[N],F[N];
inline const void build(int p,int fa)
{
	f[p][w[p]]=1;f[p].fwt();node(p)->val=f[p];
	for (int son,i(head[p]);i;i=next[i])
		if ((son=to[i])^fa)
			build(son,p),
			f[p]*=one+f[son],
			F[p]+=F[son],
			link(node(p),node(son));
	F[p]+=f[p];
	node(p)->pushup();
}
int main()
{
	inv[1]=1;for (int i(2);i<mod;i++)inv[i]=mul((mod-mod/i),inv[mod%i]);
	read(n);read(m);
	one.fullset();node0=new tree[n+1];
	for (int i(1);i<=n;i++)read(w[i]);
	for (int u,v,i(n);--i;)read(u),read(v),addedge(u,v);
	build(1,0);
	char opt[7];read(q);
	for (int k,v;q--;)
		if (scanf("%s",opt),read(k),opt[0]=='C')read(v),modify(node(k),v);
		else printf("%d\n",query(k));
	return 0;
}
```

---

## 作者：251Sec (赞：3)

做一下 FWT 就变成长度为 $m$ 数组对位相乘，也就是我们要维护 $m$ 个数据结构，每个支持单点修改，求所有连通块点权乘积的和。上静态 Top Tree 即可。维护上下界点是否被选的答案，注意为了合并方便，这里的点权乘积不算上界点的点权。

代码非常好写。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e4 + 7, I2 = (P + 1) / 2;
int n, m, q;
void FWT(ll *a, int tp) {
	ll t = tp == 1 ? 1 : I2;
	for (int w = 1; w < m; w <<= 1) {
		for (int i = 0; i < m; i += (w << 1)) {
			for (int j = 0; j < w; j++) {
				ll x = a[i + j], y = a[i + j + w];
				a[i + j] = (x + y) * t % P;
				a[i + j + w] = (x - y + P) * t % P;
			}
		}
	}
}
ll fwt[135][135], a[30005];
int sn[30005], siz[30005];
vector<int> e[30005];
struct Dat {
	ll w[135];
	Dat() {}
	Dat(ll x) {
		memcpy(w, fwt[x], sizeof(w));
	}
	Dat operator+(const Dat &b) const {
		Dat res;
		for (int i = 0; i < m; i++) res.w[i] = (w[i] + b.w[i]) % P;
		return res;
	}
	Dat operator*(const Dat &b) const {
		Dat res;
		for (int i = 0; i < m; i++) res.w[i] = w[i] * b.w[i] % P;
		return res;
	}
} I, O;
enum Type {
	NIL, COMPRESS, RAKE
};
struct Cluster {
	int x, y;
	Type tp;
	Dat w[2][2];
} f[60005];
int ls[60005], rs[60005], prt[60005];
void Pushup(int p) {
	int ls = ::ls[p], rs = ::rs[p];
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			f[p].w[i][j] = O;
		}
	}
	if (f[p].tp == COMPRESS) {
		f[p].x = f[ls].x, f[p].y = f[rs].y;
		for (int i = 0; i < 2; i++) {
			f[p].w[i][0] = f[p].w[i][0] + f[ls].w[i][0];
			f[p].w[0][i] = f[p].w[0][i] + f[rs].w[0][i];
		}
		for (int i = 0; i < 2; i++) {
			for (int j = 0; j < 2; j++) {
				f[p].w[i][j] = f[p].w[i][j] + f[ls].w[i][1] * f[rs].w[1][j];
			}
		}
	}
	else {
		f[p].x = f[ls].x, f[p].y = f[ls].y;
		for (int i = 0; i < 2; i++) {
			f[p].w[0][i] = f[p].w[0][i] + f[ls].w[0][i];
			f[p].w[0][0] = f[p].w[0][0] + f[rs].w[0][i];
		}
		for (int j = 0; j < 2; j++) {
			f[p].w[1][j] = f[ls].w[1][j] * (f[rs].w[1][0] + f[rs].w[1][1]);
		}
	}
}
void DFS1(int u, int fa) {
	f[u].x = fa, f[u].y = u;
	f[u].w[0][1] = f[u].w[1][1] = Dat(a[u]);
	f[u].w[1][0] = I;
	siz[u] = 1;
	for (int v : e[u]) {
		if (v == fa) continue;
		DFS1(v, u);
		siz[u] += siz[v];
		if (siz[v] > siz[sn[u]]) sn[u] = v;
	}
}
typedef vector<pair<int, int>> V;
int cnt;
int Div(V::iterator L, V::iterator R, Type tp) {
	if (L + 1 == R) return L->second;
	auto M = lower_bound(L, R, make_pair((L->first + prev(R)->first + 1) / 2, 0));
	if (M == L) M++;
	int x = Div(L, M, tp), y = Div(M, R, tp), p = ++cnt;
	f[p].tp = tp;
	ls[p] = x, rs[p] = y;
	prt[x] = prt[y] = p;
	Pushup(p);
	return p;
}
int rt, las;
int DFS2(int u, int fa) {
	V li;
	li.push_back({ 1, u });
	for (int v = u, w = fa; sn[v]; w = v, v = sn[v]) {
		V t; t.push_back({ 1, sn[v] });
		for (int x : e[v]) {
			if (x == w || x == sn[v]) continue;
			t.push_back({ t.back().first + siz[x], DFS2(x, v) });
		}
		li.push_back({ li.back().first + siz[v] - siz[sn[v]], Div(t.begin(), t.end(), RAKE) });
	}
	return Div(li.begin(), li.end(), COMPRESS);
}
int main() {
	scanf("%d%d", &n, &m), cnt = n;
	for (int i = 0; i < m; i++) {
		fwt[i][i] = 1;
		FWT(fwt[i], 1);
	}
	I = Dat(0);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i);
	for (int i = 1, u, v; i < n; i++) {
		scanf("%d%d", &u, &v);
		e[u].push_back(v), e[v].push_back(u);
	}
	DFS1(1, 0);
	rt = DFS2(1, 0);
	scanf("%d", &q);
	while (q--) {
		char s[10]; scanf("%s", s);
		if (!strcmp(s, "Query")) {
			int k; scanf("%d", &k);
			Dat res = O;
			for (int j = 0; j < 2; j++) res = res + f[rt].w[0][j];
			FWT(res.w, -1);
			printf("%lld\n", res.w[k]);
		}
		else {
			int x; ll y; scanf("%d%lld", &x, &y);
			f[x].w[0][1] = f[x].w[1][1] = Dat(a[x] = y);
			for (int u = prt[x]; u; u = prt[u]) Pushup(u);
		}
	}
	return 0;
}
```

---

## 作者：Eliauk_FP (赞：2)

亲测 $3\times3$ 矩阵树剖 $O(nm\log ^2 n)$ 可过！！！

为了不引起歧义，下文中将点权记为 $a_i$，记 $\text{son}_u$ 表示 $u$ 的子节点组成的集合。

首先，有一个朴素的 DP。设 $f_{u, 0/1, i}$ 表示考虑以 $u$ 为根的子树，是否选 $u$（$0$ 表示强制不选，$1$ 表示强制选），联通子图异或和为 $i$ 时的方案数。对于 $f_{u, 0, i}$，转移如下：

$$
f_{u, 0, i} = \sum_{v \in \text{son}_u} f_{v, 0, i} + f_{v, 1, i}
$$

而对于 $f_{u, 1, i}$，它实际上是一个树上背包，所以先有 $f_{u, 1, a_u} = 1$。而对于每个子节点 $v \in \text{son}_u$，有一个合并子树的过程，转移如下：

$$
f_{u, 1, i} = f_{u, 1, i} + \sum_{j \oplus k = i} f_{u, 1, j} f_{v, 1, k}
$$

如果将 $f_{u, 1}$ 视为一个序列，那么上面的转移的后半部分实际上是一个 $f_{u, 1}$ 与 $f_{v, 1}$ 的异或卷积。处理异或卷积的常用手段为 FWT，所以我们可以重新定义 $f$ 数组，$f_{u, 0 / 1, i}$ 表示序列 $f_{u, 0 / 1}$ 进行 FWT 后的第 $i$ 位。由于 FWT 为线性变换，所以 $f_{u, 0, i}$ 的转移式不变，而 $f_{u, 1, i}$ 的转移式变为：

$$
f_{u, 1, i} = f_{u, 1, i} + f_{u, 1, i} f_{v, 1, i} = f_{u, 1, i} (f_{v, 1, i} + 1)
$$

但注意，合并子树前，$f_{u, 1, i}$ 是有初始值的，所以定义序列 $w_u$ 表示 $f_{u, 1}$ 的初始序列，即 $w_{u, a_u} = 1$，其他的 $w_{u, i}$ 都为 $0$。相应地，我们也要对序列 $w_u$ 进行 FWT。这样，我们 $f_{u, 1, i}$ 的转移式再次变化为：

$$
f_{u, 1, i} = w_{u, i} \prod_{v \in \text{son}_u}(f_{v, 1, i} + 1)
$$

接下来就是 DDP 的讨论操作了。考虑重链剖分，记 $\text{ch}_u$ 表示节点 $u$ 的重儿子。考虑将 $f_{u, 0 / 1, i}$ 的转移拆成重儿子的值和轻儿子的值，有：

$$
\begin{cases}
f_{u, 0, i} = f_{\text{ch}_u, 0, i} + f_{\text{ch}_u, 1, i} + \sum_{v \in \text{son}_u \land v \neq \text{ch}_u} f_{v, 0, i} + f_{v, 1, i} \\
f_{u, 1, i} = w_{u, i} (f_{\text{ch}_u, 1, i} + 1) \prod_{v \in \text{son}_u  \land v \neq \text{ch}_u}(f_{v, 1, i} + 1)
\end{cases}
$$

我们定义 $g_{u, i}$ 和 $h_{u, i}$，如下：

$$
\begin{cases}
g_{u, i} = \sum_{v \in \text{son}_u \land v \neq \text{ch}_u} f_{v, 0, i} + f_{v, 1, i} \\
h_{u, i} = \prod_{v \in \text{son}_u  \land v \neq \text{ch}_u}(f_{v, 1, i} + 1)
\end{cases}
$$

那么转移式变形为：

$$
\begin{cases}
f_{u, 0, i} = f_{\text{ch}_u, 0, i} + f_{\text{ch}_u, 1, i} + g_{u, i} \\
f_{u, 1, i} = w_{u, i}  h_{u, i} (f_{\text{ch}_u, 1, i} + 1)
\end{cases}
$$

写成矩阵乘法的形式，有：

$$
\begin{bmatrix}
f_{u, 0, i} \\ f_{u, 1, i} \\ 1
\end{bmatrix} =
\begin{bmatrix}
1 & 1 & g_{u, i} \\ 
0 & w_{u, i} h_{u, i} & w_{u, i} h_{u, i} \\
0 & 0 & 1 
\end{bmatrix} 
\begin{bmatrix}
f_{\text{ch}_u, 0, i} \\ f_{\text{ch}_u, 1, i} \\ 1
\end{bmatrix}
$$

用线段树维护即可。

这道题需要维护的信息比较多，矩阵比较复杂，有一些小细节需要注意：

- 查询时需要对序列进行 IFWT。 
- 重链剖分预处理不要写错。
- DDP 修改时，可能会有除 $0$ 操作。解决办法是让 $h_{u, i}$ 只记录非 $0$ 数的乘积，再开一个数组记录 $0$ 的数量。
- 叶子节点的矩阵是不同于非叶子节点的，需要特判一下。

这样写的空间复杂度为 $O(nm)$，但常数很大，需要一些优化。注意到模数是 $10007$，所以开 int 是完全没必要的，直接开 short 就行，亲测这样不会 MLE。

问题来了，我们的时间复杂度为 $O(nm \log^2 n)$，但矩阵是 $3 \times 3$ 的，再加上线段树，常数不小，实测会 TLE 最后五个点。但是，我们注意到矩阵乘法时有很多值是不变的，所以我们可以先将矩阵乘法循环展开，再进行一些剪枝，这样就可以过了。

[代码](https://loj.ac/s/2327853)。

---

## 作者：tzc_wk (赞：2)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P3781)

SDOI 2017 R2 D1 T3，nb tea %%%

~~讲个笑话，最近我在学动态 dp，wjz 在学 FWT，而我们刚好在同一天做到了这道题，而这道题刚好又是 FWT+动态 dp~~

首先考虑怎样暴力计算答案，我们记 $dp_{u,j}$ 表示以 $u$ 为根的子树中有多少个连通块包含 $u$ 且权值的异或和为 $j$，初始 $dp_{u,val_u}=1$，每次遍历 $u$ 的一个子树 $v$ 就对这个子树就对这两个子树的 $dp$ 做一个合并，即 $dp_{u,x}\leftarrow dp_{u,x}+\sum\limits_{y=0}^{m-1}dp_{u,y}\times dp_{v,x\oplus y}$，最终答案即为 $\sum\limits_{u}dp_{u,k}$。正确性显然，时间复杂度 $\mathcal O(qnm^2)$，可以通过前四个测试点。

考虑优化，首先一个非常明显的优化是，DP 转移方程式长得一脸 xor 卷积的样子，如果我们记 $f*g$ 表示 $f,g$ 两个集合幂级数的 FWTxor，那么上述式子可以改写为 $dp_u=dp_u+dp_u*dp_v=dp_u*(dp_v+1)$，因此考虑将所有 $dp_u$ 都变为 $\text{FWT}(dp_u)$，那么 $dp_u$ 的初始值就变为 $dp_{u,i}=\text{FWT}(E_{val_u})_i$，其中 $E_i$ 为满足 $f_i=1,f_j=0(j\ne i)$ 的集合幂级数 $f$，这个可以通过预处理所有 $\text{FWT}(E_i)$ 实现 $\mathcal O(m)$ 初始化。转移操作可以根据 FWT 那一套理论变成 $dp_{u,i}\leftarrow dp_{u,i}\times(dp_{v,i}+1)$，这样即可实现 $\mathcal O(m)$ 转移。然后每次操作完了之后再 IFWT 回来即可，时间复杂度降到了 $\mathcal O(qnm+qm\log m)$，还是只能通过前四个测试点（

注意到上述 $dp$ 对于不带修改的情况是 efficient enough 的，但是带上修改就直接萎掉了，因此考虑擅长处理修改操作的动态 $dp$ 来解决这个问题，按照动态 $dp$ 的套路我们将树剖成一条条重链，$dp$ 分为轻儿子和重儿子处理，我们记 $dpl_{u,i}=\sum\limits_{v\in\text{lightson}(u)}(dp_{v,i}+1)$，那么记 $w=wson_u$，则有 $dp_{u,i}=dpl_{u,i}\times\text{FWT}(E_{val_u})_i\times (dp_{w,i}+1)$。

但是光记录一个 $dp$ 值是远远不够的，因为最终我们要求的是整棵子树中 $dp_{u,k}$ 的值之和，所有我们不得不再额外记录 $sum_{u,i}$ 表示子树中所有点的 $dp_{u,i}$ 之和，那么有 $sum_{u,i}=\sum\limits_{v\in \text{son}(u)}sum_{v,i}+dp_{u,i}$，按照套路我们还是记 $suml_{u,i}=\sum\limits_{v\in\text{lightson}(u)}sum_{v,i}$，那么有 $sum_{u,i}=sum_{w,i}+dp_{u,i}+suml_{u,i}=sum_{w,i}+dpl_{u,i}\times\text{FWT}(E_{val_u})_i\times(dp_{w,i}+1)+suml_{u,i}$

考虑将这东西写成矩阵的形式，那么有：
$$
\begin{bmatrix}dp_{u}&sum_{u}&1\end{bmatrix}=\begin{bmatrix}dp_{w}&sum_{w}&1\end{bmatrix}\times
\begin{bmatrix}
dpl_u\times\text{FWT}(E_{val_u})&dpl_u\times\text{FWT}(E_{val_u})&0\\
0&1&0\\
dpl_u\times\text{FWT}(E_{val_u})&dpl_u\times\text{FWT}(E_{val_u})+suml_u&1
\end{bmatrix}
$$
其中 $f\times g$ 就对应项相乘好了，$f+g$ 也同理。

记 $A_u=\begin{bmatrix}
dpl_u\times\text{FWT}(E_{val_u})&dpl_u\times\text{FWT}(E_{val_u})&0\\
0&1&0\\
dpl_u\times\text{FWT}(E_{val_u})&dpl_u\times\text{FWT}(E_{val_u})+suml_u&1
\end{bmatrix}$，那么对于一个点 $u$ 而言，记它到重链底经过的节点依次是 $u=v_1,v_2,\cdots,v_k$，那么有
$$
\begin{bmatrix}dp_{u}&sum_{u}&1\end{bmatrix}=\begin{bmatrix}0&0&1\end{bmatrix}\times\prod\limits_{i=k}^1A_{v_i}
$$
这个可以树链剖分+线段树维护。

修改操作就按照动态 $dp$ 的套路不断跳重链并撤销原来的 $dp_{top_u}$ 对 $dpl_{fa[top_u]}$ 和 $suml_{fa[top_u]}$ 的影响并加入新的贡献即可，时间复杂度 $q\log^2nm+qm\log m$，LOJ 上可以通过，而洛谷上由于某两位毒瘤提供的毒瘤卡树剖的数据，只能获得 $80$ 分的好成绩。

说起来轻巧，实现起来一堆细节需要注意：

1. 直接矩阵乘法会多 $27$ 的常数，导致 TLE，因此需要按照套路进行优化，注意到这个 $3\times 3$ 的矩阵中只有四个位置是有用的，因此可以只维护这四个位置的值，即 $\begin{bmatrix}a&b&0\\0&1&0\\c&d&1\end{bmatrix}$，那么有 $\begin{bmatrix}a_1&b_1&0\\0&1&0\\c_1&d_1&1\end{bmatrix}\times \begin{bmatrix}a_2&b_2&0\\0&1&0\\c_2&d_2&1\end{bmatrix}=\begin{bmatrix}a_1a_2&a_1b_2+b_1&0\\0&1&0\\a_2c_1+c_2&b_2c_1+d_1+d_2&1\end{bmatrix}$，这样常数可以降到 $4$。
2. 注意线段树 `pushup` 的顺序。
3. 在撤销原来的贡献时会出现除以 $0$ 的情况，因此可以将 $dpl_{u,i}$ 存成一个个结构体，每个结构体用 $x\times 0^y$ 表示一个数，每次乘以 $0$ 时令 $y$ 加一，除以 $0$ 则令 $y$ 减一，这样可以避免这个问题~~（u1s1 蒟蒻是第一次遇到这个套路呢，大佬不喜勿喷）~~
4. 注意计算新加入的贡献时是计算线段树上 $[dfn[top[x]]],dfn[bot[top[x]]]$ 内矩阵的乘积，而不是 $[dfn[x]],dfn[bot[top[x]]]$，蒟蒻因为这个错误调了 1h，心态炸裂。

码了 212 行……

```cpp
const int MAXN=3e4;
const int MAXV=1<<7;
const int MOD=1e4+7;
const int INV2=5004;
int n,m,val[MAXN+5],inv[MOD+4];
void getinv(){
	for(int i=(inv[0]=inv[1]=1)+1;i<MOD;i++) inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;
}
void FWTxor(int *a,int len,int type){
	for(int i=2;i<=len;i<<=1)
		for(int j=0;j<len;j+=i)
			for(int k=0;k<(i>>1);k++){
				int X=a[j+k],Y=a[(i>>1)+j+k];
				if(~type) a[j+k]=(X+Y)%MOD,a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
				else a[j+k]=(X+Y)*INV2%MOD,a[(i>>1)+j+k]=(X-Y+MOD)*INV2%MOD;
			}
}
struct num0{//number expressed as x*0^y
	int x,y;
	num0(int v=1){(!v)?(y=x=1):(x=v,y=0);}
	num0 operator *(const int &rhs){
		(!rhs)?(++y):(x=x*rhs%MOD);
		return *this;
	}
	num0 operator /(const int &rhs){
		(!rhs)?(--y):(x=x*inv[rhs]%MOD);
		return *this;
	}
	int num(){return y?0:x;}
};
struct poly{
	int a[MAXV+5];
	poly(){memset(a,0,sizeof(a));}
	poly(int x){for(int i=0;i<m;i++) a[i]=x;}
	poly operator +(poly rhs) const{
		poly res;
		for(int i=0;i<m;i++) res.a[i]=(a[i]+rhs.a[i])%MOD;
		return res;
	}
	poly operator *(poly rhs) const{
		poly res(1);
		for(int i=0;i<m;i++) res.a[i]=a[i]*rhs.a[i]%MOD;
		return res;
	}
	void FWT(){FWTxor(a,m,1);}
	void IFWT(){FWTxor(a,m,-1);}
} e[MAXV+5];
int hd[MAXN+5],to[MAXN*2+5],nxt[MAXN*2+5],ec=0;
void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
int siz[MAXN+5],fa[MAXN+5],dep[MAXN+5],wson[MAXN+5];
int top[MAXN+5],dfn[MAXN+5],tim=0,rid[MAXN+5];
int bot[MAXN+5];
void dfs1(int x=1,int f=0){
	siz[x]=1;fa[x]=f;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f) continue;
		dep[y]=dep[x]+1;dfs1(y,x);siz[x]+=siz[y];
		if(siz[y]>siz[wson[x]]) wson[x]=y;
	}
}
void dfs2(int x=1,int tp=1){
	top[x]=tp;rid[dfn[x]=++tim]=x;if(wson[x]) dfs2(wson[x],tp);
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==wson[x]||y==fa[x]) continue;
		dfs2(y,y);
	}
}
int f[MAXN+5][MAXV+5],sum[MAXN+5][MAXV+5],suml[MAXN+5][MAXV+5];
num0 fl[MAXN+5][MAXV+5];
void dfs3(int x=1){
	for(int i=0;i<m;i++) f[x][i]=e[val[x]].a[i],fl[x][i]=1;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==fa[x]) continue;dfs3(y);
		for(int i=0;i<m;i++) f[x][i]=f[x][i]*(f[y][i]+1)%MOD;
		for(int i=0;i<m;i++) sum[x][i]=(sum[x][i]+sum[y][i])%MOD;
	} for(int i=0;i<m;i++) sum[x][i]=(sum[x][i]+f[x][i])%MOD;
}
void dfs4(int x=1){
	if(wson[x]) dfs4(wson[x]);
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==fa[x]||y==wson[x]) continue;dfs4(y);
		for(int i=0;i<m;i++) fl[x][i]=fl[x][i]*((f[y][i]+1)%MOD);
		for(int i=0;i<m;i++) suml[x][i]=(suml[x][i]+sum[y][i])%MOD;
	}
}
struct mat{
	poly a,b,c,d;
	mat(){}
	mat operator *(const mat &rhs){
		mat res;res.a=a*rhs.a;res.b=b+a*rhs.b;
		res.c=rhs.a*c+rhs.c;res.d=rhs.b*c+d+rhs.d;
		return res;
	}
};
void print(mat x){
	for(int i=0;i<m;i++) printf("%d%c",x.a.a[i]," \n"[i==m-1]);
	for(int i=0;i<m;i++) printf("%d%c",x.b.a[i]," \n"[i==m-1]);
	for(int i=0;i<m;i++) printf("%d%c",x.c.a[i]," \n"[i==m-1]);
	for(int i=0;i<m;i++) printf("%d%c",x.d.a[i]," \n"[i==m-1]);
}
mat get(int x){
	mat res;
	for(int i=0;i<m;i++) res.a.a[i]=res.b.a[i]=res.c.a[i]=fl[x][i].num()*e[val[x]].a[i]%MOD;
	for(int i=0;i<m;i++) res.d.a[i]=(res.a.a[i]+suml[x][i])%MOD;
	return res;
}
struct node{int l,r;mat v;} s[MAXN*4+5];
void pushup(int k){s[k].v=s[k<<1|1].v*s[k<<1].v;}
void build(int k,int l,int r){
	s[k].l=l;s[k].r=r;if(l==r) return s[k].v=get(rid[l]),void();
	int mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);pushup(k);
}
mat query(int k,int l,int r){
	if(l<=s[k].l&&s[k].r<=r) return s[k].v;
	int mid=s[k].l+s[k].r>>1;
	if(r<=mid) return query(k<<1,l,r);
	else if(l>mid) return query(k<<1|1,l,r);
	else return query(k<<1|1,mid+1,r)*query(k<<1,l,mid);
}
void modify(int k,int p){
	if(s[k].l==s[k].r) return s[k].v=get(rid[p]),void();
	int mid=s[k].l+s[k].r>>1;
	if(p<=mid) modify(k<<1,p);else modify(k<<1|1,p);
	pushup(k);
}
void change(int x){
	while(x){
		if(fa[top[x]]){
			mat res=query(1,dfn[top[x]],dfn[bot[top[x]]]);
//			printf("%d\n",fa[top[x]]);
//			for(int i=0;i<m;i++) printf("{%d,%d}%c",fl[fa[top[x]]][i].x,fl[fa[top[x]]][i].y," \n"[i==m-1]);
//			for(int i=0;i<m;i++) printf("%d%c",(res.c.a[i]+1)%MOD," \n"[i==m-1]);
//			print(get(fa[top[x]]));
			for(int i=0;i<m;i++) fl[fa[top[x]]][i]=fl[fa[top[x]]][i]/((res.c.a[i]+1)%MOD);
			for(int i=0;i<m;i++) suml[fa[top[x]]][i]=(suml[fa[top[x]]][i]-res.d.a[i]+MOD)%MOD;
		} modify(1,dfn[x]);
		if(fa[top[x]]){
			mat res=query(1,dfn[top[x]],dfn[bot[top[x]]]);
//			print(res);
			for(int i=0;i<m;i++) fl[fa[top[x]]][i]=fl[fa[top[x]]][i]*((res.c.a[i]+1)%MOD);
			for(int i=0;i<m;i++) suml[fa[top[x]]][i]=(suml[fa[top[x]]][i]+res.d.a[i])%MOD;
//			for(int i=0;i<m;i++) printf("{%d,%d}%c",fl[fa[top[x]]][i].x,fl[fa[top[x]]][i].y," \n"[i==m-1]);
//			for(int i=0;i<m;i++) printf("%d%c",(res.c.a[i]+1)%MOD," \n"[i==m-1]);
//			print(get(fa[top[x]]));
		} x=fa[top[x]];
	}
}
int main(){
	scanf("%d%d",&n,&m);getinv();
	for(int i=0;i<m;i++) e[i].a[i]=1,e[i].FWT();
//	for(int i=0;i<m;i++) for(int j=0;j<m;j++) printf("%d%c",e[i].a[j]," \n"[j==m-1]);
	for(int i=1;i<=n;i++) scanf("%d",&val[i]);
	for(int i=1,u,v;i<n;i++) scanf("%d%d",&u,&v),adde(u,v),adde(v,u);
	dfs1();dfs2();dfs3();dfs4();build(1,1,n);
//	for(int i=1;i<=n;i++) for(int j=0;j<m;j++) printf("%d%c",f[i][j]," \n"[j==m-1]);
//	for(int i=1;i<=n;i++) for(int j=0;j<m;j++) printf("%d%c",sum[i][j]," \n"[j==m-1]);
//	for(int i=1;i<=n;i++) for(int j=0;j<m;j++) printf("%d%c",fl[i][j].num()," \n"[j==m-1]);
//	for(int i=1;i<=n;i++) for(int j=0;j<m;j++) printf("%d%c",suml[i][j]," \n"[j==m-1]);
//	for(int i=0;i<m;i++) printf("%d%c",t.d.a[i]," \n"[i==m-1]);
	for(int i=1;i<=n;i++) if(top[i]==i){
		int cur=i;while(wson[cur]) cur=wson[cur];
		bot[i]=cur;
	} int qu;scanf("%d",&qu);
	while(qu--){
		char opt[9];scanf("%s",opt+1);
		if(opt[1]=='C'){
			int x,v;scanf("%d%d",&x,&v);
			val[x]=v;change(x);
		} else {
			int k;scanf("%d",&k);
			mat res=query(1,dfn[1],dfn[bot[1]]);
//			for(int i=0;i<m;i++) printf("%d%c",res.d.a[i]," \n"[i==m-1]);
			res.d.IFWT();
			printf("%d\n",res.d.a[k]);
		}
	}
	return 0;
}
```



---

## 作者：littlez_meow (赞：1)

### 思路

计数问题，不是组合就是 dp，又或者二者皆有。

又是动态的，考虑 ddp。

由于最近在学静态 top tree，我们考虑用静态 top tree 维护 ddp。

静态 top tree 根据其每个节点的定义（簇内的边的端点不一定被簇包含），维护边的信息显然比维护点的信息容易。但是，这道题有的是点权。如果直接暴力维护包括簇的界点的所有簇内点信息，加入给一个菊花图然后修改根，就需要修改整个 top tree 的信息。这样单次修改的复杂度是 $O(n)$ 的，显然不可接受。而且，这样会导致两个簇合并时需要复杂的分类讨论来去掉上界点的重复贡献。

由此可以导出一个非常自然的想法，就是我们维护的信息去掉上界点的贡献，合并再把上界点的贡献算上。这样单次修改的复杂度就是 $O(\log n)$。

然后就是静态 top tree 维护信息的套路了。对于每个簇，我们维护只包含上界点、只包含下界点、两个界点都包含、整个簇内四种情况下的信息，每个信息形如一个集合幂级数 $f(x)$，$[x^i]f(x)$ 表示满足上述条件的权值为 $i$ 的连通块个数。注意我们不包含上界点的贡献，因此对于只包含上界点和两个界点都包含，我们不异或上界点的值，同时钦定整个簇内、只包含下界点不经过上界点。

对于 Rake 节点，合并后上界点不变，因此仍然不用加入贡献，直接转移即可。

对于 Compress 节点，合并后有一个上界点变成了簇内点。但是这不影响，因为这个上界点是另一个簇的下界点，正好补上了贡献。

转移形式类似于线段树维护最大子段和，即分左子树、右子树、横跨三部分求贡献，加在一起。注意，对于某些不能经过上界点的信息，我们不能算第三部分的贡献。

转移方程形如异或卷积，暴力实现单次合并复杂度 $O(m^2)$，直接维护 FWT 后的结果复杂度 $O(m)$。

总的时间复杂度 $O(n\log n+nm+qm\log n)$，分别是建树、FWT、修改的复杂度。查询直接把根簇的上界点贡献算上，复杂度 $O(m)$。

注意求的是非空连通块，因此初始时集合幂级数的常数项为 $0$。

可以预处理出每个 $x^{i}$ FWT 之后的结果，方便代码。

感觉静态 top tree 解决 ddp 问题不需要像一般 ddp 那样分轻重儿子讨论、设计广义矩阵乘法的矩阵、写全局平衡二叉树还蛮方便的。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
using namespace std;
const int MAXN=3e4+1,MOD=1e4+7,INV2=5e3+4;
int n,m,v[MAXN];
vector<int>g[MAXN];
struct Poly{
	int val[128];
	Poly(){
		memset(val,0,sizeof(int)*m);
		return;
	}
	inline void FWT(bool inv){
		for(int i(1);(i<<1)<=m;i<<=1) for(int j(0);j<m;j+=(i<<1)) F(k,0,i-1){
			int&x(val[j+k]),&y(val[i+j+k]),qwq=y;
			(y=x-qwq)<0&&(y+=MOD);
			(x+=qwq)>=MOD&&(x-=MOD);
			inv&&(x=x*INV2%MOD,y=y*INV2%MOD);
		}
		return;
	}
	Poly operator*(const Poly&qwq)const{
		Poly res;
		F(i,0,m-1) res.val[i]=val[i]*qwq.val[i]%MOD;
		return res;
	}
	Poly operator+(const Poly&qwq)const{
		Poly res;
		F(i,0,m-1) (res.val[i]=val[i]+qwq.val[i])>=MOD&&(res.val[i]-=MOD);
		return res;
	}
};
Poly fwt[128];
int cnt;
struct Node{
	short type;//-1=Unit,0=Rake,1=Compress
	int up,dn,siz,lc,rc,fa; 
	Poly ul,dl,len,ans;
	Node(int t=-1,int a=0,int b=0,int c=1,int x=0,int y=0):type(t),up(a),dn(b),siz(c),lc(x),rc(y),fa(0){}
}node[MAXN<<2];
inline void upd(int now){
	Node&qwq(node[now]),&l(node[qwq.lc]),&r(node[qwq.rc]);
	if(qwq.type==-1) return;
	if(qwq.type){//Compress
		qwq.ul=l.ul+l.len*r.ul;
		qwq.dl=r.dl+r.len*l.dl;
		qwq.len=l.len*r.len;
		qwq.ans=l.ans+r.ans+l.dl*r.ul;
	}else{//Rake
		qwq.ul=l.ul+r.ul+l.ul*r.ul;
		qwq.dl=l.dl;
		qwq.len=l.len+r.ul*l.len;
		qwq.ans=l.ans+r.ans;
	}
	return;
}
inline int merge(int x,int y,bool type){
	node[x].fa=node[y].fa=++cnt;
	node[cnt]=Node(type,node[x].up,node[type?y:x].dn,node[x].siz+node[y].siz,x,y);
	return upd(cnt),cnt;
}
int fa[MAXN],siz[MAXN],son[MAXN];
void dfs1(int root,int f){
	fa[root]=f,siz[root]=1;
	for(int i:g[root]){
		if(i==f) continue;
		dfs1(i,root);
		siz[root]+=siz[i];
		node[i]=Node(-1,root,i);
		node[i].ul=node[i].dl=node[i].len=node[i].ans=fwt[v[i]];
		siz[i]>siz[son[root]]&&(son[root]=i);
	}
	return;
}
#define Poi vector<int>::iterator
int build(Poi l,Poi r,bool type){
	if(r==l) return 0;
	if(r==l+1) return *l;
	int all(0),sum(0);
	for(auto it(l);it!=r;++it) all+=node[*it].siz;
	auto mid=l+1;
	for(auto it(l);it!=r;++it){
		sum+=node[*it].siz;
		if(sum*2<=all) mid=it+1;
		else break;
	}
	return merge(build(l,mid,type),build(mid,r,type),type);
}
int rt[MAXN];
void dfs2(int root,bool heavy){
	if(son[root]) dfs2(son[root],1);
	for(int i:g[root]) if(i!=fa[root]&&i!=son[root]) dfs2(i,0);
	if(!heavy){
		vector<int>chain;
		if(root!=1) chain.push_back(root);
		for(int i(son[root]);i;i=son[i]){
			vector<int>sub({i});
			for(int j:g[fa[i]]) if(j!=i&&j!=fa[fa[i]]) sub.push_back(rt[j]);
			chain.push_back(build(sub.begin(),sub.end(),0));
		}
		rt[root]=build(chain.begin(),chain.end(),1);
	}
	return;
}
inline void modify(int x,int v){
	node[x].ul=node[x].dl=node[x].len=node[x].ans=fwt[v];
	while(node[x].fa) upd(node[x].fa),x=node[x].fa;
	return;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	F(i,0,m-1) fwt[i].val[i]=1,fwt[i].FWT(0);
	F(i,1,n) cin>>v[i];
	F(i,1,n-1){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v),g[v].push_back(u);
	}
	dfs1(1,0);
	cnt=n;
	dfs2(1,0);
	int Q;
	for(cin>>Q;Q;--Q){
		char type[10];
		cin>>type;
		if(type[0]=='C'){
			int x,k;
			cin>>x>>k;
			v[x]=k;
			modify(x,k);
		}else{
			int k;
			cin>>k;
			Node&t(node[rt[1]]);
			Poly qwq=t.ul*fwt[v[t.up]]+t.ans;
			qwq.FWT(1);
			(++qwq.val[v[t.up]])>=MOD&&(qwq.val[v[t.up]]-=MOD);
			cout<<qwq.val[k]<<"\n";
		}
	}
	return 0;
} 
```

---

## 作者：Arghariza (赞：1)

唉，一千个选手就有一千种 Top Tree……

仅有的两篇静态 Top Tree 题解要不是转移太复杂，要不就是我根本看不懂。而且大家的转移方式或多或少都有些不同，我在此陈述一下我的做法吧。

由于 Top Tree 是关于边的划分，而我们需要维护点的信息，同时一个簇的两个子簇之间只有一个交点（中心点），于是我们可以这样定义属于一个簇的所有点：一个簇中包含其连通块中的所有除了上界点之外的点。这样每个点在每一层中最多属于一个簇，而对于根节点我们在上面新增一条边 $(0,rt)$ 即可。

而对于一些动态 dp 之类的东西，我们对于每一个簇同样不考虑上界点对状态的影响。然而由于 compress 或 rake 操作时要求中心点在两个子簇中的状态相同，所以我们通常还会将上界点和下界点的状态列进 dp 状态中。

以这题为例：设 $f_{u,0/1,0/1}$ 表示编号为 $u$ 的簇内，上界点选/不选，下界点选/不选，至少要选一个点的方案的集合幂级数（如果选了上界点，其异或值不计算，但方案存在）。转移时，如果我们要取中心点，那么我们要求 compress 和 rake 操作的中心点状态相同：

- Compress：
$$f_{u,0,0}=f_{lc,0,0}+f_{rc,0,0}+f_{lc,0,1}\times f_{rc,1,0}$$
$$f_{u,1,0}=f_{lc,1,0}+f_{lc,1,1}\times f_{rc,1,0}$$
$$f_{u,0,1}=f_{rc,0,1}+f_{lc,0,1}\times f_{rc,1,1}$$
$$f_{u,1,1}=f_{lc,1,1}\times f_{rc,1,1}$$

- rake：
$$f_{u,0,0}=f_{lc,0,0}+f_{rc,0,0}+f_{rc,0,1}$$
$$f_{u,1,0}=f_{lc,1,0}\times (f_{rc,1,0}+f_{rc,1,1})$$
$$f_{u,0,1}=f_{lc,0,1}$$
$$f_{u,1,1}=f_{lc,1,1}\times(f_{rc,1,0}+f_{rc,1,1})$$

乘法表示集合幂级数的异或卷积，加法就是方案数简单相加。

重要的是对于基簇（Top Tree 叶子节点，也就是原树中的每条边）初始 dp 值的考虑。设该基簇编号为 $u$，则对应原树中 $(fa_u,u)$ 的边：

- 若 $u=rt$，则没有选 $fa_{u}$ 的方案，即 $f_{u,1,0/1}=f_{u,0,0}=0$，$f_{u,0,1}=x^{a_u}$，因为不能不选点。
- 若 $u\neq rt$，则可以选或不选 $fa_u$，即 $f_{u,0,0}=0$，$f_{u,1,0}=1$，$f_{u,0,1}=f_{u,1,1}=x^{a_u}$。

剩下的都是静态 Top Tree 的基本操作了。修改点权就是修改基簇的 dp 值，然后向上更新即可。异或卷积的话，一开始先 FWT 一遍，然后就把卷积变成 $O(m)$ 的点积了，查询时再 IFWT 回来即可。

复杂度 $O(m(n+q\log n))$。

~~好像确实比其他做法好写不少。~~

```cpp
// Problem: P3781 [SDOI2017] 切树游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3781
// Memory Limit: 500 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define eb emplace_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pi;
typedef vector<int> vi;
bool Mbe;

const int P = 1e4 + 7;
const int N = 3e4 + 5;
const int M = 6e4 + 5;
const int K = (1 << 7) + 5;

int n, m, q, rt, tot, lim, ilim, a[N];
int fa[N], sz[N], son[N];
vector<int> G[N];

int qpow(int p, int q) {
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

void Add(int &x, int y) { x += y, (x >= P) && (x -= P); }
void Sub(int &x, int y) { x -= y, (x < 0) && (x += P); }
int add(int x, int y) { return Add(x, y), x; }
int sub(int x, int y) { return Sub(x, y), x; }

struct F {
	int s[K];
	F () { memset(s, 0, sizeof(s)); }
	F (int v) { for (int i = 0; i < lim; i++) s[i] = (__builtin_popcount(i & v) & 1) ? (P - 1) : 1; }
	F operator + (const F &rh) const {
		F res;
		for (int i = 0; i < lim; i++)
			res.s[i] = add(s[i], rh.s[i]);
		return res;
	}
	F operator * (const F &rh) const {
		F res;
		for (int i = 0; i < lim; i++)
			res.s[i] = s[i] * rh.s[i] % P;
		return res;
	}
};

struct T {
	F s[2][2];
	T () { }
	T (int v, int op) { 
		if (op) s[1][0] = F(0), s[0][1] = s[1][1] = F(v);
		else s[0][1] = F(v);
	}
};

struct B {
	int x, y, op; T s;
	B () { }
	B (int _x, int _y, int _op, T _s) :
		x(_x), y(_y), op(_op), s(_s) { }
};

struct S {
	int lc, rc, fa, sz; B s;
	S () { }
	S (int _lc, int _rc, int _fa, int _sz, B _s) :
		lc(_lc), rc(_rc), fa(_fa), sz(_sz), s(_s) { }
} t[M];

#define ls(x) t[x].lc
#define rs(x) t[x].rc

B cp(const B &L, const B &R) {
	B res; res.x = L.x, res.y = R.y, res.op = 0;
	res.s.s[0][0] = L.s.s[0][0] + R.s.s[0][0] + L.s.s[0][1] * R.s.s[1][0];
	res.s.s[1][0] = L.s.s[1][0] + L.s.s[1][1] * R.s.s[1][0];
	res.s.s[0][1] = R.s.s[0][1] + R.s.s[1][1] * L.s.s[0][1];
	res.s.s[1][1] = L.s.s[1][1] * R.s.s[1][1];
	return res;
}

B rk(const B &L, const B &R) {
	B res; res.x = L.x, res.y = L.y, res.op = 1;
	res.s.s[0][0] = L.s.s[0][0] + R.s.s[0][0] + R.s.s[0][1];
	res.s.s[1][0] = L.s.s[1][0] * (R.s.s[1][0] + R.s.s[1][1]);
	res.s.s[0][1] = L.s.s[0][1];
	res.s.s[1][1] = L.s.s[1][1] * (R.s.s[1][0] + R.s.s[1][1]);
	return res;
}

int bld(vi::iterator l, vi::iterator r, auto op) {
	if (l == r - 1) return *l;
	int cur = 0, sum = 0; auto mid = l + 1;
	for (auto i = l; i != r; i++) sum += t[*i].sz;
	for (auto i = l; i != r; i++) {
		cur += t[*i].sz;
		if (2 * cur <= sum) mid = i + 1;
	}
	int L = bld(l, mid, op), R = bld(mid, r, op);
	t[++tot] = S(L, R, 0, t[L].sz + t[R].sz, op(t[L].s, t[R].s)), t[L].fa = t[R].fa = tot;
	return tot;
}

void dfs1(int u, int f) {
	fa[u] = f, sz[u] = 1;
	t[u] = S(0, 0, 0, 1, B(f, u, -1, T(a[u], (u != 1))));
	for (int v : G[u]) {
		if (v == f) continue;
		dfs1(v, u), sz[u] += sz[v];
		if (sz[v] > sz[son[u]]) son[u] = v;
	}
}

int dfs2(int u) {
	vi p = { u };
	while (son[u]) {
		vi q = { son[u] };
		for (int v : G[u]) 
			if (v != fa[u] && v != son[u]) q.eb(dfs2(v));
		p.eb(bld(q.begin(), q.end(), rk)), u = son[u];
	}
	return bld(p.begin(), p.end(), cp);
}

void solve() {
	cin >> n >> m, tot = n, lim = (1 << (__lg(m - 1) + 1)), ilim = qpow(lim, P - 2);
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1, u, v; i < n; i++)
		cin >> u >> v, G[u].eb(v), G[v].eb(u);
	dfs1(1, 0), rt = dfs2(1), cin >> q;
	while (q--) {
		string s; int x; cin >> s >> x;
		if (s[0] == 'Q') {
			int res = 0;
			F tp = t[rt].s.s.s[0][0] + t[rt].s.s.s[0][1];
			for (int i = 0; i < lim; i++) Add(res, (__builtin_popcount(i & x) & 1) ? (P - tp.s[i]) : tp.s[i]);
			cout << res * ilim % P << '\n';
		} else {
			int y; cin >> y;
			t[x].s = B(fa[x], x, -1, T(a[x] = y, x != 1));
			while (x = t[x].fa) t[x].s = (!t[x].s.op ? cp : rk)(t[ls(x)].s, t[rs(x)].s);
		}
	}
}

bool Med;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen(".in", "r", stdin);
		freopen(".out", "w", stdout);
	#endif
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：Vidoliga (赞：1)

省流：静态Top Tree 神/se

这东西好写跑得还快，为啥不写？

好的，由于这不是道模板题，我不会详细介绍 Top tree，想学的自行查阅资料。

主要是讲讲静态Top tree 怎么处理点的信息。想必这个但凡有学过 Top tree 的同学都多多少少对这部分有些疑问。

有个较为通用的解决方案，在维护簇内信息的时候，对于各个信息，都不考虑增加深度最浅的端点的贡献（原因是因为如果不这样修改会影响儿子个叶子，从而导致复杂度退化）。

那么怎么上传信息呢？上传信息的时候也是不能**使用**最浅的端点的贡献，否则会导致有多条路径需要上传。

这个还是需要具体到题目，抽象概念难以理解，我也讲不清楚。

我们尝试用上述大致思路解决本题：

首先是这个异或卷积要搞点，做一个 FWT 线性变换即可，卷积变成对位积，对位加仍然是对位加，复杂度从 $O(m^2)$ 变成 $O(m)$。

考虑对于每个簇，维护 $l,r,m,len$，都是一个 FWT 变换数组，分别表示包含浅端点到簇内的联通块贡献 FWT 数组（不含该端点贡献），包含深端点到簇内**不跨过浅端点**的联通块贡献 FWT 数组，簇内**不跨过浅端点**的联通块贡献 FWT 数组，包含两个端点的贡献 FWT 数组（不含浅端点贡献）。

Compress 和 Rake 分别的转移过程：

1. Compress

$$l \leftarrow l_1+l_2\times len_1$$

$$r \leftarrow r_2+r_1\times len_2$$

$$m \leftarrow m_1+m_2+r_1\times l_2$$

$$len \leftarrow len_1 \times len_2$$

这里需要注意的是这里的 $m\leftarrow l_2 \times r_1$ 将这部分之前跨过消去的那个浅端点的贡献加入了，所以不重不漏。

2. Rake

$$l \leftarrow l_1+l_2+l_1 \times l_2$$

$$r \leftarrow r_1$$

$$m \leftarrow m_1+m_2$$

$$len \leftarrow len_1+len_1 \times l_2$$

这部分相对前面就好理解了，感觉转移写出来大部分读者都能搞懂了，我觉得也没有必要细讲，这些都是对于边贡献的一些变形，稍加思考反而可以加深对 Top tree 的理解程度。

复杂度 $O(nm +qm\log n)$。

Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
//#define int ll
#define pb push_back
using namespace std;
const int N=7e4+20,M=130,mod=1e4+7;
const int inv2=(mod+1)/2; 
inline int mul(const int &a,const int &b){return a*b%mod;}
inline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}
inline int del(int a,int b){a-=b;return a<0?a+mod:a;}
//init siz[x]=1
//tp=0:compress,tp=1:rake
int n,m,Rt,sz[N],siz[N],tp[N],son[N],st[N],lc[N],rc[N],fa[N],F[N],L[N],cnt,top,d[N];
struct P{int a[M];}G[M];
inline P operator +(P x,P y){
	P z;
	for(int i=0;i<m;i++) z.a[i]=add(x.a[i],y.a[i]);
	return z;
}
inline P operator *(P x,P y){
	P z;
	for(int i=0;i<m;i++) z.a[i]=x.a[i]*y.a[i]%mod;
	return z;
}
void FWT(P &f,int opt){
	for(int i=1;i<m;i<<=1){
		for(int p=i<<1,j=0;j<m;j+=p) for(int k=0;k<i;k++){
			int x=f.a[j+k],y=f.a[j+k+i];
			f.a[j+k]=(opt==1)?del(x,y):mul(add(x,y),inv2);
			f.a[j+k+i]=(opt==1)?add(x,y):mul(del(y,x),inv2);
		}
	}
}
struct Node{int v,w,id;};
vector<int> e[N];
struct Data{P l,r,m,len;}s[N];
void dfs1(int x){
	sz[x]=1;
	for(auto y:e[x]) if(y!=F[x]){
		F[y]=x,dfs1(y),sz[x]+=sz[y];
		if(sz[y]>sz[son[x]]) son[x]=y;
	}
}
inline Data Compress(Data x,Data y){
	return (Data){x.l+y.l*x.len,y.r+x.r*y.len,x.m+y.m+x.r*y.l,x.len*y.len};
}
inline Data Rake(Data x,Data y){
	return (Data){x.l+y.l+x.l*y.l,x.r,x.m+y.m,x.len+x.len*y.l};
}
inline void ph(int x){
	if(!lc[x]&&!rc[x]) return ;
	siz[x]=siz[lc[x]]+siz[rc[x]];
	if(!tp[x]) L[x]=L[lc[x]],s[x]=Compress(s[lc[x]],s[rc[x]]);
	else L[x]=L[lc[x]],s[x]=Rake(s[lc[x]],s[rc[x]]);
}
int build(int l,int r,int k){
	if(l>r) return 0;
	if(l==r) return st[l];
	int mid=l,sum=0,p=0,x=++cnt;
	for(int i=l;i<=r;i++) sum+=siz[st[i]];
	while(mid<r-1&&p<sum-p) p+=siz[st[mid++]];
	tp[x]=k,lc[x]=build(l,mid,k),rc[x]=build(mid+1,r,k);
	return fa[lc[x]]=fa[rc[x]]=x,ph(x),x;
}
void dfs2(int u){
	int lst=top+1,rt,z;
	if(u!=1) st[++top]=u;
	for(int x=u;son[x];x=son[x]){
		st[rt=++top]=son[x];
		for(auto v:e[x]) if(v!=son[x]&&v!=F[x]) dfs2(v);
		z=build(rt,top,1),st[top=rt]=z;
	}
	z=build(lst,top,0),st[top=lst]=z;
}
int q;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=0;i<m;i++) G[i].a[i]=1,FWT(G[i],1);
	for(int i=1;i<=n;i++) cin>>d[i];
	for(int i=1,x,y;i<n;i++){
		cin>>x>>y;e[x].pb(y);e[y].pb(x);
	}
	dfs1(1);cnt=n;
	for(int i=2;i<=n;i++) siz[i]=1,s[i]=(Data){G[d[i]],G[d[i]],G[d[i]],G[d[i]]},L[i]=F[i];
	dfs2(1);Rt=st[1];
	cin>>q;
	while(q--){
		char ch[10];cin>>ch;
		if(ch[0]=='C'){
			int x,y;
			cin>>x>>y;d[x]=y,s[x]=(Data){G[d[x]],G[d[x]],G[d[x]],G[d[x]]};
			for(x=fa[x];x;x=fa[x]) ph(x);
		}else{
			int k;cin>>k;
			P u=(s[Rt].l*G[d[L[Rt]]])+s[Rt].m;
			FWT(u,0);
			u.a[d[L[Rt]]]++;u.a[d[L[Rt]]]%=mod;
			cout<<u.a[k]<<'\n';
		}
	}
	return 0;
}
```

---


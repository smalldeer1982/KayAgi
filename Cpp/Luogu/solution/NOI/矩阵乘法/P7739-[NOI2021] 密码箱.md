# [NOI2021] 密码箱

## 题目描述

Yelekastee 是 U 国著名的考古学家。在最近的一次考古行动中，他发掘出了一个远古时期的密码箱。经过周密而严谨的考证，Yelekastee 得知密码箱的密码和某一个数列 $\{ a_n \}$ 相关。数列 $\{ a_n \}$ 可以用如下方式构造出来：

1. 初始时数列长度为 $2$ 且有 $a_0 = 0, a_1 = 1$；
2. 对数列依次进行若干次操作，其中每次操作是以下两种类型之一：
  - `W` 类型：给数列的**最后一项**加 $1$。
  - `E` 类型：若数列的**最后一项**为 $1$，则给倒数第二项加 $1$；否则先给数列的**最后一项**减 $1$，接着在数列尾再加两项，两项的值都是 $1$。

受到技术限制，密码箱并没有办法完整检查整个数列，因此密码箱的密码设定为数列 $\{ a_n \}$ 经过函数 $f$ 作用后的值，其中 $f$ 的定义如下：

$$ f(a_0, \ldots , a_{k - 1}, a_k) = \begin{cases} a_0, & k = 0 \\ f \! \left( a_0, a_1, \ldots , a_{k - 2}, a_{k - 1} + \frac{1}{a_k} \right) \! , & k \ge 1 \end{cases} $$

Yelekastee 并不擅长运算，因此他找到了你，希望你能根据他提供的操作序列计算出密码箱的密码。不幸的是，他的记性并不是很好，因此他会随时对提供的操作序列做出一些修改，这些修改包括以下三种：

- `APPEND c`，在现有操作序列后追加一次 `c` 类型操作，其中 `c` 为字符 `W` 或 `E`。
- `FLIP l r`，反转现有操作序列中第 $l$ 个至第 $r$ 个（下标从 $1$ 开始，修改包含端点 $l$ 和 $r$，下同）操作，即所有 `W` 变为 `E`，所有 `E` 变为 `W`。
- `REVERSE l r`，翻转现有操作序列中第 $l$ 个至第 $r$ 个操作，也就是将这个区间中的操作逆序。

## 说明/提示

**【样例解释 #1】**

| | 操作序列 | 数列 $\{ a_n \}$ | 密码 |
|:-:|:-:|:-:|:-:|
| 初始 | `WE` | $(0, 1, 1, 1)$ | $\frac{2}{3}$ |
| 第一次修改后 | `WEE` | $(0, 1, 2, 1)$ | $\frac{3}{4}$ |
| 第二次修改后 | `EWE` | $(1, 1, 1, 1)$ | $\frac{5}{3}$ |
| 第三次修改后 | `EEW` | $(2, 2)$ | $\frac{5}{2}$ |

**【样例 #2】**

见附件 `code/code2.in` 与 `code/code2.ans`。

该样例与测试数据 $1 \sim 4$ 满足同样的约束条件。

**【样例 #3】**

见附件 `code/code3.in` 与 `code/code3.ans`。

该样例与测试数据 $5 \sim 7$ 满足同样的约束条件。

**【样例 #4】**

见附件 `code/code4.in` 与 `code/code4.ans`。

该样例与测试数据 $8 \sim 10$ 满足同样的约束条件。

**【样例 #5】**

见附件 `code/code5.in` 与 `code/code5.ans`。

该样例与测试数据 $15 \sim 20$ 满足同样的约束条件。

**【数据范围】**

对于所有测试点：$1 \le n \le {10}^5$，$1 \le q \le {10}^5$。

对于 `APPEND` 修改，保证给出的 `c` 为大写英文字母 `W` 或 `E`。

对于 `FLIP` 和 `REVERSE` 修改，保证 $1 \le l \le r \le L$，其中 $L$ 是当前操作序列的长度。

请注意由于有 `APPEND` 操作，操作序列的长度最大可能有 $2 \times {10}^5$。

| 测试点编号 | $n, q \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $2000$ | 无 |
| $5 \sim 7$ | ${10}^5$ | A |
| $8 \sim 10$ | ${10}^5$ | B，C |
| $11 \sim 14$ | ${10}^5$ | C |
| $15 \sim 20$ | ${10}^5$ | 无 |

特殊限制 A：保证在任意时刻操作序列中不会出现连续相同的两个字符。

特殊限制 B：保证没有 `FLIP` 修改。

特殊限制 C：保证没有 `REVERSE` 修改。

## 样例 #1

### 输入

```
2 3
WE
APPEND E
FLIP 1 2
REVERSE 2 3
```

### 输出

```
2 3
3 4
5 3
5 2
```

# 题解

## 作者：wishapig (赞：42)

文章中的做法是我在现场想出来的，然而被卡成 70。

首先分子分母显然一定互质，不用考虑除一个 $\gcd$ 的事情（点名排水系统）。

## Part1

考虑这么一个连分数：

$$ \cfrac{1}{a_0+\cfrac{1}{a_1+\cfrac{1}{a_2+\cdots}}} $$

（它是 $f(a_0,a_1,\cdots,a_k)$ 的倒数）

如果从 $a_k$ 到 $a_0$，从下往上进行合并时，我们会发现实际上是一个 $\dfrac{a'}{b'}=\dfrac{1}{a_i+\dfrac{a}{b}}$ 的形式

那么考虑一个 $a_i$ 合并上之后会对 $a,b$ 造成什么变化：

$$\dfrac{a'}{b'}=\dfrac{1}{a_i+\dfrac{a}{b}}=\dfrac{b}{a_i\times b+a}$$

也就是：$a'=b,b'=a_i\times b+a$

这可以用矩阵来描述：

$$ \begin{bmatrix} a' \\ b' \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ 1 & a_i \end{bmatrix} \begin{bmatrix} a \\ b \end{bmatrix} $$

好耶我们可以使用式子

$$ \begin{bmatrix} 0 & 1 \\ 1 & a_0 \end{bmatrix} \begin{bmatrix} 0 & 1 \\ 1 & a_1 \end{bmatrix} \begin{bmatrix} 0 & 1 \\ 1 & a_2 \end{bmatrix} \cdots \begin{bmatrix} 0 & 1 \\ 1 & a_k \end{bmatrix} \begin{bmatrix} 0\\ 1 \end{bmatrix} $$

来求出最后的分数了，~~然而这也是一个暴力~~。

## Part2

好了我们有了一个矩阵描述连分数的想法，由于矩阵乘法有结合律，可以任意变换乘法的先后顺序，那么我们能否使用常矩阵来描述 ```W``` 和 ```E``` 操作呢？

首先看一下 ```W``` 操作，它让 $a_k\rightarrow a_k+1$

考虑矩阵从 $\begin{bmatrix} 0 & 1 \\ 1 & a_k \end{bmatrix}$ 变成了 $\begin{bmatrix} 0 & 1 \\ 1 & a_k+1 \end{bmatrix}$。

一定是有一个矩阵 $\begin{bmatrix} x & y \\ z & w \end{bmatrix}$，使得 $\begin{bmatrix} 0 & 1 \\ 1 & a_k \end{bmatrix}\begin{bmatrix} x & y \\ z & w \end{bmatrix}=\begin{bmatrix} 0 & 1 \\ 1 & a_k+1 \end{bmatrix}$。

通过构造可以得到 $\begin{bmatrix} x & y \\ z & w \end{bmatrix}=\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}$，也就是如果出现了一个 ```W``` 操作，那可以在矩阵连乘积的最后再乘上一个 $\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}$，从而一个 ```W``` 操作可以用一个常矩阵来描述。

之后是 ```E``` 操作，要分 $a_k=1$ 和 $a_k>1$ 两种情况，首先来看一下 $a_k>1$ 时的情况。

- $a_k\rightarrow a_k-1$；
- 添加两个 $1$ 到数列末尾。

第一个 $a_k\rightarrow a_k-1$，可以依照上面的思想，构造 $\begin{bmatrix} 0 & 1 \\ 1 & a_k \end{bmatrix}\begin{bmatrix} 1 & -1 \\ 0 & 1 \end{bmatrix}=\begin{bmatrix} 0 & 1 \\ 1 & a_k-1 \end{bmatrix}$。

之后是两个添加操作，那么就直接在矩阵连乘积的末尾再乘上 $\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}$。

（注意所有的这些矩阵乘法都可以通过使用结合律改变乘法顺序得到实际意义）

于是第一种 $a_k>1$ 的情况可以在连乘积之后乘上 $\begin{bmatrix} 1 & -1 \\ 0 & 1 \end{bmatrix}\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}=\begin{bmatrix} 0 & -1 \\ 1 & 2 \end{bmatrix}$ 来描述。

还有第二种 $a_k=1$ 的情况，此时有 $a_{k-1}\rightarrow a_{k-1}+1$，这似乎比较难直接构造一个矩阵。

然后我们灵机一动，这个 $a_k>1$ 时数列的变化这么阴间，一定是有意弄成这样来达到某个目的的，于是我们大胆猜想 $a_k=1$ 时的矩阵也是 $\begin{bmatrix} 0 & -1 \\ 1 & 2 \end{bmatrix}$，可以验证这是对的：

当 $a_k=1$ 时，$a_k$ 对应的矩阵就是 $\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}$，按正常的顺序，应当是（最后两项为）$\begin{bmatrix} 0 & 1 \\ 1 & a_{k-1} \end{bmatrix}\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}$（中间一项是使 $a_{k-1}+1$ 的矩阵，最后一项是 $a_k$ 对应的矩阵，注意由于结合律我没有写上括号，在实际计算中可以按顺序进行乘法），这个东西化简出来是 $\begin{bmatrix} 0 & 1 \\ 1 & a_{k-1} \end{bmatrix}\begin{bmatrix} 1 & 2 \\ 1 & 1 \end{bmatrix}$。

而如果我们直接在最后乘上一个 $\begin{bmatrix} 0 & -1 \\ 1 & 2 \end{bmatrix}$，会得到 $\begin{bmatrix} 0 & 1 \\ 1 & a_{k-1} \end{bmatrix}\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}\begin{bmatrix} 0 & -1 \\ 1 & 2 \end{bmatrix}$，这个化简出来是 $\begin{bmatrix} 0 & 1 \\ 1 & a_{k-1} \end{bmatrix}\begin{bmatrix} 1 & 2 \\ 1 & 1 \end{bmatrix}$，与前面那个刚好相同！所以直接在连乘积之后乘上一个 $\begin{bmatrix} 0 & -1 \\ 1 & 2 \end{bmatrix}$ 的大胆想法是正确的。

所以我们用一个 $\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}$ 来描述 ```W``` 操作，一个 $\begin{bmatrix} 0 & -1 \\ 1 & 2 \end{bmatrix}$ 来描述 ```E``` 操作。

## Part3

ds 带师可以略过这一部分

之后 ```W``` 和 ```E``` 操作就分别对应一种矩阵，要用某种数据结构维护矩阵连乘积，支持区间取反和区间翻转。

要维护的信息是区间连乘积，区间取反连乘积，区间翻转连乘积，区间取反翻转连乘积，和两个 $\rm tag$：是否取反，是否翻转。

有了区间翻转操作，那就要用平衡树而非线段树来维护区间了，选用任何一种可以支持区间翻转的平衡树都可以实现，我在考场上使用的是 $\rm fhq\ treap$（人傻常数大结果被卡成 70 分）

## Part4

小小细节：

- 在最开始数列中有 $a_0=0,a_1=1$，因此初始的矩阵连乘积是 $\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}=\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}$。

- 拆了结构体 $70 \rightarrow 100$（恼）。

- ~~fhq treap 真的打不过 splay~~。

code：

```c++
const int mod=998244353;
const int N=2e5+500;
struct mat{ int a00,a01,a10,a11; } I,a,b,cur;
int pri[N],siz[N],ls[N],rs[N],tagf[N],tagi[N];
mat val[N],fil[N],inv[N],fnv[N],It[N],Itv[N];
int n,q,l,r,rt,rt1,rt2,rt3,rt4,treesize;
char s[N],c[100];
mat operator * (const mat& a, const mat& b){
	mat c;
	c.a00=(1ll*a.a00*b.a00+1ll*a.a01*b.a10)%mod;
	c.a01=(1ll*a.a00*b.a01+1ll*a.a01*b.a11)%mod;
	c.a10=(1ll*a.a10*b.a00+1ll*a.a11*b.a10)%mod;
	c.a11=(1ll*a.a10*b.a01+1ll*a.a11*b.a11)%mod;
	return c;
}
inline int Newnode(int k){
	int now=++treesize;
	if (k==0){
		val[now]=a; inv[now]=b;
		fil[now]=a; fnv[now]=b;
		It[now]=a; Itv[now]=b;
	} else {
		val[now]=b; inv[now]=a;
		fil[now]=b; fnv[now]=a;
		It[now]=b; Itv[now]=a;
	}
	siz[now]=1;
	return now;
}
inline void pushup(int now){
	if (!now) return;
	siz[now]=siz[ls[now]]+siz[rs[now]]+1;
	
	val[now]=(val[ls[now]]*It[now])*val[rs[now]];
	inv[now]=(inv[ls[now]]*Itv[now])*inv[rs[now]];
	
	fil[now]=(fil[rs[now]]*It[now])*fil[ls[now]];
	fnv[now]=(fnv[rs[now]]*Itv[now])*fnv[ls[now]];
}
inline void pushtagf(int now){
	if (!now) return;
	swap(val[now],fil[now]);
	swap(inv[now],fnv[now]);
	swap(ls[now],rs[now]);
	tagf[now]^=1;
}
inline void pushtagi(int now){
	if (!now) return;
	swap(val[now],inv[now]);
	swap(fil[now],fnv[now]);
	swap(It[now],Itv[now]);
	tagi[now]^=1;
}
inline void pushdown(int now){
	if (!now) return;
	if (tagf[now]) pushtagf(ls[now]),pushtagf(rs[now]),tagf[now]=0;
	if (tagi[now]) pushtagi(ls[now]),pushtagi(rs[now]),tagi[now]=0;
}
int Merge(int now, int las){
	if (!now || !las) return now|las;
	pushdown(now); pushdown(las);
	if (pri[now]<pri[las]){
		rs[now]=Merge(rs[now],las);
		pushup(now); return now;
	} else {
		ls[las]=Merge(now,ls[las]);
		pushup(las); return las;
	}
}
void Split(int now, int& r1, int& r2, int pos){
	if (!now){ r1=r2=0; return; }
	pushdown(now);
	if (siz[ls[now]]+1<=pos) r1=now,Split(rs[now],rs[r1],r2,pos-siz[ls[now]]-1);
	else r2=now,Split(ls[now],r1,ls[r2],pos);
	pushup(r1); pushup(r2);
}
int main(){
	freopen("code.in","r",stdin);
	freopen("code.out","w",stdout);
	scanf("%d%d",&n,&q);
	scanf("%s",s+1);
	
	srand(19260817);
	for (int i=1; i<=n+q; i++) pri[i]=i;
	random_shuffle(pri+1,pri+1+n+q);
	I.a00=I.a11=1; I.a10=I.a01=0;
	a.a00=a.a01=a.a11=1; a.a10=0;
	b.a00=0,b.a01=mod-1,b.a10=1,b.a11=2;
	
	val[0]=fil[0]=inv[0]=fnv[0]=It[0]=Itv[0]=I;
	
	for (int i=1; i<=n; i++) rt=Merge(rt,Newnode(s[i]=='W'?0:1));
	
	cur=a*val[rt];
	printf("%d %d\n",cur.a11,cur.a01);
	
	for (; q; q--){
		scanf("%s",c+1);
		if (c[1]=='A'){
			scanf("%s",c+1);
			rt=Merge(rt,Newnode(c[1]=='W'?0:1));
		} else
		if (c[1]=='F'){
			scanf("%d%d",&l,&r);
			Split(rt,rt1,rt2,r);      // rt1:[1..r],rt2:[r+1..n]
			Split(rt1,rt3,rt4,l-1);   // rt3:[1..l-1],rt4:[l..r]
			pushtagi(rt4);
			rt=Merge(Merge(rt3,rt4),rt2);
		} else {
			scanf("%d%d",&l,&r);
			Split(rt,rt1,rt2,r);      // rt1:[1..r],rt2:[r+1..n]
			Split(rt1,rt3,rt4,l-1);   // rt3:[1..l-1],rt4:[l..r]
			pushtagf(rt4);
			rt=Merge(Merge(rt3,rt4),rt2);
		}
		cur=a*val[rt];
		printf("%d %d\n",cur.a11,cur.a01);
	}
	return 0;
}
/*
2 3
WE
APPEND E
FLIP 1 2
REVERSE 2 3
*/
```

代码仅供参考，不喜勿喷。

## Bonus

提供一个只用维护连乘积的做法，不需要维护 $4$ 个乘积：

对一个矩阵 $\begin{bmatrix} a & b \\ c & d \end{bmatrix}$，考虑直接通过 $a,b,c,d$ 的线性组合凑出 ```Flip``` 和 ```Reverse``` 操作序列之后的矩阵。

通过这题的特殊性（只有两种常矩阵的乘积）~~和人类智慧（指高斯消元解方程组）~~，凑出了以下矩阵变换：

$$ \operatorname{Flip}\left(\begin{bmatrix} a & b \\ c & d \end{bmatrix}\right)=\begin{bmatrix} a-b & -b \\ -a+b-c+d & b+d \end{bmatrix} $$

$$ \operatorname{Reverse}\left(\begin{bmatrix} a & b \\ c & d \end{bmatrix}\right)=\begin{bmatrix} d-2c & -2a+b-4c+2d \\ c & a+2c \end{bmatrix} $$

这两个都可以用数学归纳法证明对任意操作序列都是对的。

那么在 ```pushup``` 的时候矩阵乘法的次数就会减少至原来的 $\dfrac{1}{4}$，常数显著优化 ~~（还是打不过 splay）~~。

```c++
inline void pushtagf(int now){
	if (!now) return;
	
	int A=val[now].a00,B=val[now].a01,C=val[now].a10,D=val[now].a11;
	val[now]=(mat){(D-2*C%mod+mod)%mod,((-2ll*A+B-4ll*C+2ll*D)%mod+mod)%mod,C,(A+2*C%mod)%mod};
	
	swap(ls[now],rs[now]);
	tagf[now]^=1;
}
inline void pushtagi(int now){
	if (!now) return;
	int A=val[now].a00,B=val[now].a01,C=val[now].a10,D=val[now].a11;
	val[now]=(mat){(A-B+mod)%mod,(mod-B)%mod,((D-A+B-C)%mod+mod)%mod,(B+D)%mod};
	
	A=It[now].a00,B=It[now].a01,C=It[now].a10,D=It[now].a11;
	It[now]=(mat){(A-B+mod)%mod,(mod-B)%mod,((D-A+B-C)%mod+mod)%mod,(B+D)%mod};
	tagi[now]^=1;
}
```

最后感谢管理对格式问题的指出和粉兔的修改

求赞 qwq

---

## 作者：SSerxhs (赞：30)

按照公式进行计算，则 $x+\frac zy=\frac{xy+z}y$，有 $\gcd (xy+z,y)=\gcd(z,y)$，必定不会被约分，所以只要正常计算是不用管分子分母互质的条件的．

本题要求输出分子和分母，意味着这两部分是分开的，考虑设向量 $\begin{pmatrix}x&y\end{pmatrix}$ 表示分数 $\dfrac xy$，那么 $f(a_i,\dfrac xy)=\dfrac {a_iy+x}x$，因此与 $a_i$ 运算对应一个线性变换，该线性变换对应**右**乘 $\begin{pmatrix}a_0&1\\1 \end{pmatrix}$，而所求的便是从右往左依次变换之后的结果．如果给定 $\{a\}$ 并单点修改，可以轻易完成查询．初始向量为 $\begin{pmatrix}1&0\end{pmatrix}$．

注意：对应到操作序列上，乘法顺序从**右**往**左**（即从右往左迭代），且均为**右**乘．

考虑 `W` 操作，其对应最后一个数字 $a_n\gets a_n+1$，考虑到 $\begin{pmatrix}1&k\\&1 \end{pmatrix}\begin{pmatrix}a_n&1\\1 \end{pmatrix}=\begin{pmatrix}a_n+k&1\\1 \end{pmatrix}$，那只需要在最右加一个 $\begin{pmatrix}1&1\\&1 \end{pmatrix}$ 就可以了．

考虑 `E` 操作．注意到若倒数两项为 $a,1$，按照题意操作将变为 $a+1,1$，按另一种方式操作变为 $a,0,1,1$．对 $\dfrac xy$ 执行此变换，则第一种情况 $\dfrac{x}{y}\to\dfrac{x+y}{x}\to \dfrac{(a+2)x+(a+1)y}{x+y}$，第二种情况 $\dfrac{x}{y}\to \dfrac{x+y}{x}\to \dfrac{2x+y}{x+y}\to \dfrac{x+y}{2x+y}\to \dfrac{(a+2)x+(a+1)y}{x+y}$，

是完全一致的．所以直接考虑第二种情况．第二种情况即添加矩阵

$\begin{pmatrix}1&1\\1 \end{pmatrix}\begin{pmatrix}1&1\\1 \end{pmatrix}\begin{pmatrix}1&-1\\&1 \end{pmatrix}=\begin{pmatrix}2&-1\\1 \end{pmatrix}$．

因此，两种操作分别对应一个矩阵．再考虑题目要求的三个操作，分别是加入、flip 和 reverse．设 $\mathrm{A_n}$ flip 后为 $\mathrm {B_n}$，考虑维护 $\mathrm {A_n}\mathrm {A_{n-1}\cdots\mathrm {A_1}}$、$\mathrm {A_1}\mathrm {A_{2}\cdots\mathrm {A_n}}$、$\mathrm {B_n}\mathrm {B_{n-1}\cdots\mathrm {B_1}}$、$\mathrm {B_1}\mathrm {B_{2}\cdots\mathrm {B_n}}$，即可维护所有运算．注意 reverse 时不仅要交换连乘结果，也要交换子节点．

------------

题外话：考完水群全程跨服聊天，有维护 $6\times 6$ 矩阵的，有说 `E` 要分开做的，有说维护连续段的，很奇妙。


```cpp
template<int N> struct _splay
{
	int c[N][2],f[N],siz[N];
	Q s[N][4],v[N][2];
	bool trsf[N],swp[N];
	int cnt,rt;
	void out(int x)
	{
		printf("%d: c %d & %d f %d siz %d\n",x,c[x][0],c[x][1],f[x],siz[x]);
		outt(s[x][0]);//outt(s[x][1]);
		outt(v[x][0]);//outt(v[x][1]);
		if (c[x][0]) out(c[x][0]);
		if (c[x][1]) out(c[x][1]);
		if (x==rt) puts("-------------------");
	}
	void init()
	{
		cnt=2;
		c[1][0]=c[1][1]=trsf[1]=swp[1]=f[1]=0;
		c[2][0]=c[2][1]=trsf[2]=swp[2]=f[2]=0;
		c[1][1]=2;f[2]=1;rt=1;siz[2]=1;siz[1]=2;
		for (int j=0;j<3;j++) for (int i=0;i<4;i++) s[j][i]=dwz;
		for (int j=0;j<3;j++) for (int i=0;i<2;i++) v[j][i]=dwz;
	}
	inline void pushup(register int x)
	{
		int lc=c[x][0],rc=c[x][1];
		s[x][0]=s[rc][0]*v[x][0]*s[lc][0];
		s[x][2]=s[rc][2]*v[x][1]*s[lc][2];
		s[x][1]=s[lc][1]*v[x][0]*s[rc][1];
		s[x][3]=s[lc][3]*v[x][1]*s[rc][3];
		siz[x]=siz[lc]+siz[rc]+1;
	}
	inline void pushdown(register int x)
	{
		register int lc=c[x][0],rc=c[x][1];
		if (trsf[x])
		{
			swap(s[lc][0],s[lc][2]);swap(s[lc][1],s[lc][3]);swap(v[lc][0],v[lc][1]);
			trsf[lc]^=1;//c^=1;
			swap(s[rc][0],s[rc][2]);swap(s[rc][1],s[rc][3]);swap(v[rc][0],v[rc][1]);
			trsf[rc]^=1;//c^=1;
			trsf[x]=0;
		}
		if (swp[x])
		{
			swap(s[lc][0],s[lc][1]);swap(s[lc][2],s[lc][3]);
			swap(c[lc][0],c[lc][1]);
			swp[lc]^=1;//c^=1;
			swap(s[rc][0],s[rc][1]);swap(s[rc][2],s[rc][3]);
			swap(c[rc][0],c[rc][1]);
			swp[rc]^=1;//c^=1;
			swp[x]=0;
		}
	}
	inline void zigzag(register int x)
	{
		register int y=f[x],z=f[y],typ=(c[y][0]==x);
		if (z) c[z][c[z][1]==y]=x;
		f[x]=z;f[y]=x;c[y][typ^1]=c[x][typ];
		if (c[x][typ]) f[c[x][typ]]=y;
		c[x][typ]=y;
		pushup(y);
	}
	inline void splay(register int x,register int tar)
	{
		if (!tar) rt=x;
		register int y;
		while ((y=f[x])!=tar)
		{
			if (f[y]!=tar) zigzag(c[f[y]][0]==y^c[y][0]==x?x:y);
			zigzag(x);
		}
		pushup(x);
	}
	inline void find(register int kth,register int tar)
	{
		register int x=rt;
		while (siz[c[x][0]]+1!=kth)
		{
			pushdown(x);
			if (siz[c[x][0]]>=kth) x=c[x][0]; else
			{
				kth-=siz[c[x][0]]+1;
				x=c[x][1];
			}
		}
		pushdown(x);
		splay(x,tar);
	}
	inline void split(int x,int y)
	{
		find(x,0);find(y+2,rt);
	}
	int npt()
	{
		int x=++cnt;
		c[x][0]=c[x][1]=siz[x]=f[x]=0;
		trsf[x]=swp[x]=0;
		return x;
	}
	int build(int l,int r)
	{
		//printf("bd [%d,%d]\n",l,r);
		if (l>r) return 0;
		int m=l+r>>1,x;
		x=npt();
		if (m<=n) {if (ss[m]=='W') v[x][0]=wbas,v[x][1]=ebas; else v[x][0]=ebas,v[x][1]=wbas;} else v[x][0]=v[x][1]=dwz;
		//printf("build %d %d %d\n",l,r,x);
		if (l==r)
		{
			siz[x]=1;
			s[x][0]=s[x][1]=v[x][0];
			s[x][2]=s[x][3]=v[x][1];
			return x;
		}
		c[x][0]=build(l,m-1);
		c[x][1]=build(m+1,r);
		if (c[x][0]) f[c[x][0]]=x;
		if (c[x][1]) f[c[x][1]]=x;
		pushup(x);
		return x;
	}
	void mdf(int x,int typ)
	{
		find(x+1,0);//puts("PP");
		x=rt;//puts("PP");
		if (typ) v[x][0]=ebas,v[x][1]=wbas; else v[x][0]=wbas,v[x][1]=ebas;//puts("PP");
		pushup(x);
	}
	void mdf_flp(int x,int l,int r)
	{
		split(l,r);
		x=c[c[rt][1]][0];
		trsf[x]^=1;
		swap(s[x][0],s[x][2]);swap(s[x][1],s[x][3]);
		swap(v[x][0],v[x][1]);
		pushup(f[x]);pushup(rt);
	}
	void mdf_rev(int x,int l,int r)
	{
		split(l,r);
		x=c[c[rt][1]][0];
		swp[x]^=1;
		swap(s[x][0],s[x][1]);swap(s[x][2],s[x][3]);swap(c[x][0],c[x][1]);
		pushup(f[x]);pushup(rt);
	}
};
_splay<N> s;
int main()
{
	//freopen("code.in","r",stdin);
	//freopen("code.out","w",stdout);
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>ss+1;
	dwz.a[0][0]=1;dwz.a[1][1]=1;
	wbas.a[0][0]=1;wbas.a[0][1]=1;wbas.a[1][1]=1;
	ebas.a[0][0]=2;ebas.a[0][1]=p-1;ebas.a[1][0]=1;
	bas=dwz;bas.a[0][1]=1;s.init();
	s.c[2][0]=s.build(1,n+m);s.f[s.c[2][0]]=2;
	s.pushup(2);s.pushup(1);//outt(1);
	//s.out(s.rt);
	ls=s.s[s.rt][0]*bas;//outt(ls);
	ans=ls.a[0][0];//inc(ans,ls.a[1][0]);
	la=ls.a[0][1];//inc(la,ls.a[1][1]);
	//cout<<"ans=";
	cout<<ans<<" "<<la;//m=0;
	if (m) cout<<"\n";
	while (m--)
	{
		//s.out(s.rt);
		cin>>ss;
		if (ss[0]=='A')
		{
			cin>>ss[0];
			s.mdf(++n,ss[0]=='E');
		}
		else if (ss[0]=='F')
		{
			cin>>z>>y;
			s.mdf_flp(1,z,y);
		}
		else
		{
			cin>>z>>y;
			s.mdf_rev(1,z,y);
		}
		//if (m==0) outt(1);
		ls=s.s[s.rt][0]*bas;//outt(1);
		ans=ls.a[0][0];//inc(ans,ls.a[1][0]);
		la=ls.a[0][1];
		//cout<<"ans=";
		cout<<ans<<" "<<la;
		if (m) cout<<"\n";
	}
	cout<<endl;
}
```

---

## 作者：「　」 (赞：12)

首先比较显然的，我们可以将数列中的数两两变成一组，对于同一组，我们思考对他进行的操作序列的形式必然是$EE...EWW...WE$ ，我们考虑其最后的数值与操作序列是什么样的。

我们不妨设 $E$ 的个数（除去最后一个 $E$ ，他将作为下一组的 $E$ ）是 $cnt_e$ ， $W$ 的个数是 $cnt_w$ ，那么一组中的两个数就分别是 $cnt_e$ 和 $cnt_w$ 。当然，最后一组的 $cnt_w$ 需要 $+1$ 。这个可以自己手模验证正确性。

我们探讨一下最终式子与 $cnt_e$ 和 $cnt_w$ 的关系。

我们试着可以将一个长度为 $4$ 的序列的答案表示出来。

$$
ans=\frac{a_0a_1a_2a_3+a_0a_1+a_0a_3+a_2a_3+1}{a_1a_2a_3+a_1+a_3}
$$

其中 $a_{2k+1}$ 对应的是 $cnt_w$ ，$a_{2k}$ 对应的是 $cnt_e$ 。

首先易证明得答案中的 $a$ 和 $b$ 一定互质。

我们不妨分别求出 $a$ 和 $b$ ，两者的组合意义我们可以根据式子得出。

$a$ 的意义就是选择以 $E$ 为开头以 $W$ 为结尾的 $EW$ 间隔出现的子序列的方案个数 $+1$ 。

$b$ 的意义就是选择以 $W$ 为开头以 $W$ 为结尾的 $EW$ 间隔出现的子序列的方案个数。

然后维护这个东西配合上后面的两种操作，可以用平衡树来维护。

---

## 作者：tzl_Dedicatus545 (赞：8)

人生首黑诶，纪念下~

首先我们考虑下这个复杂的函数到底是个什么东西，我们考虑递推，设原来的分数为 $(x,y)$，表示 $\dfrac{y}{x}$。

容易发现，一次操作等价于：

$$\dfrac{y}{x}\to\dfrac{x}{y}+a_k=\dfrac{ya_k+x}{y}$$

$$(x,y)\to(y,ya_k+x)$$

考虑用矩阵形式转移，构造转移矩阵得：

$$(x,y)\begin{pmatrix}0&1\\1&a_k\end{pmatrix}=(y,ya_k+x)$$

至此，我们用矩阵表示出了 $f$ 函数，然鹅，这还是暴力，**但是，这启示我们，可以用矩阵来做这道题！**

考虑用矩阵搞出这个 `W` 和 `E` 操作。

**`W` 操作**

`W` 操作等价于（矩阵形式）：

$$\begin{pmatrix}0&1\\1&a_k\end{pmatrix}\begin{pmatrix}?&?\\?&?\end{pmatrix}=\begin{pmatrix}0&1\\1&a_k+1\end{pmatrix}$$

易得转移矩阵为：

$$\begin{pmatrix}1&1\\0&1\end{pmatrix}$$

**`E` 操作**

这个有点麻烦，我们先来看末尾不为 $1$ 时的情况：

等价于

$$\begin{pmatrix}0&1\\1&a_k\end{pmatrix}\begin{pmatrix}?&?\\?&?\end{pmatrix}=\begin{pmatrix}0&1\\1&a_k-1\end{pmatrix}$$

发现这个问号矩阵就是

$$\begin{pmatrix}1&-1\\0&1\end{pmatrix}$$

我们把后面的两次加 $1$ 操作也弄上去，就是：

$$\begin{pmatrix}1&-1\\0&1\end{pmatrix}\begin{pmatrix}0&1\\1&1\end{pmatrix}\begin{pmatrix}0&1\\1&1\end{pmatrix}=\begin{pmatrix}0&-1\\1&2\end{pmatrix}$$

这东西一看就很难看，大胆猜一下在末尾为 $1$ 时转移矩阵也是一样的，易得这是对的。

**DS**

有了前面的推导，显然发现可以用平衡树维护，维护四个东西：

- 矩阵积 
- 矩阵翻转积
- 矩阵 `Flip` 积
- 矩阵 `Flip` 翻转积

这样就可以了。

## 重要：实现细节部分

- 如果你写的是 `FHQ-Treap`，由于它先天的大常数，再加上矩阵乘法带来的 $4$ 倍常数，会很卡，这时，请尝试循环展开矩阵乘法，如下：

```cpp
Mar operator*(const Mar &x)const{
	Mar ans(n,x.m);
	memset(ans.a,0,sizeof(ans.a));

	int res1,res2,res3,res4;
	res1=a[1][1]*x.a[1][1]+a[1][2]*x.a[2][1];
	res2=a[1][1]*x.a[1][2]+a[1][2]*x.a[2][2];
	res3=a[2][1]*x.a[1][1]+a[2][2]*x.a[2][1];
	res4=a[2][1]*x.a[1][2]+a[2][2]*x.a[2][2];

	ans.a[1][1]=res1;ans.a[1][2]=res2;ans.a[2][1]=res3;ans.a[2][2]=res4;

	return ans;
}
```

其他没啥好说的了~

---

## 作者：EnofTaiPeople (赞：6)

### Part1 前言
据说这道题比 T1 还要简单？可能只是因为它是套路题。

但是套路题不会做就完了！

讲的是普通矩阵乘法维护连分数，本题可以通过简单归纳得出总是不用约分的结论。

### Part2 将序列转化为矩乘

考虑序列当前权值为 $\dfrac b a$，将其抽象为一个向量 $\begin{bmatrix}a\\b\end{bmatrix}$，我们想要在序列**前**加入一个数 $x$，将权值变成 $\dfrac{ax+b}a$，即向量 $\begin{bmatrix}ax+b\\a\end{bmatrix}$，构造矩阵乘法：$\begin{bmatrix}a\\b\end{bmatrix}\begin{bmatrix}x&1\\1&0\end{bmatrix}=\begin{bmatrix}ax+b\\a\end{bmatrix}$，于是这道题可以看作向量 $\begin{bmatrix}1\\0\end{bmatrix}$ 从右往左依次**右乘**矩阵 $\begin{bmatrix}a_i&1\\1&0\end{bmatrix}$，于是如果只是序列上的单点修改，我们已经得到了答案，然而，这道题的操作似乎不允许我们将实际上的序列维护出来？

### Part3 将操作转化为矩乘

首先是操作 `W`，我们需要将最后一个矩阵 $\begin{bmatrix}x&1\\1&0\end{bmatrix}$ 变为 $\begin{bmatrix}x+1&1\\1&0\end{bmatrix}$，构造矩阵乘法：$\begin{bmatrix}1&1\\0&1\end{bmatrix}\begin{bmatrix}x&1\\1&0\end{bmatrix}=\begin{bmatrix}x+1&1\\1&0\end{bmatrix}$ 注意到这里我们必须构造左乘，因为查询时是从右到左依次右乘的。

对于操作 `E`，我们可以先考虑第二种情况，这时我们会在最右侧新增一个矩阵 $\begin{bmatrix}1&-1\\0&1\end{bmatrix}$，再增加两个 $1$ 即 $\begin{bmatrix}1&1\\1&0\end{bmatrix}$，整体增加了 $\begin{bmatrix}1&1\\1&0\end{bmatrix}\begin{bmatrix}1&1\\1&0\end{bmatrix}\begin{bmatrix}1&-1\\0&1\end{bmatrix}=\begin{bmatrix}2&-1\\1&0\end{bmatrix}$，这时，我们猜测另一种情况也会得到一样的矩阵。

事实上，这时对的，我们实际上会将矩阵 $\begin{bmatrix}1&1\\1&0\end{bmatrix}$ 变为 $\begin{bmatrix}1&1\\1&0\end{bmatrix}\begin{bmatrix}1&1\\0&1\end{bmatrix}=\begin{bmatrix}1&2\\1&1\end{bmatrix}$，当然这是以左乘的形式，我们发现，$\begin{bmatrix}2&-1\\1&0\end{bmatrix}\begin{bmatrix}1&1\\1&0\end{bmatrix}$ 恰好等于 $\begin{bmatrix}1&2\\1&1\end{bmatrix}$ 于是就可以用矩阵 $\begin{bmatrix}2&-1\\1&0\end{bmatrix}$ 来表示操作 `E`，接下来我们就只要考虑如何维护了。

### Part4 平衡树维护方式

之所以要使用平衡树，是因为这道题需要翻转区间。

FHQ 但然也好，但我习惯用 Splay 写 LCT，于是写 Splay 会更快且更容易调错。

考虑在每一个节点维护是否翻转、反转的矩阵乘积，这样在翻转、反转的时候交换就可以了，时间复杂度 $(n+q)\log n$。

### Part5 后记

有一个神奇的地方，为什么时间复杂度中有 $n\log n$？

因为 Splay 需要初始势能啦！

给个代码就走啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=4e5+5,M=998244353;
struct mtx{
    int a[2][2];
    mtx operator*(const mtx &z)const{
        return{
            (int)(((ll)a[0][0]*z.a[0][0]+(ll)a[0][1]*z.a[1][0])%M),
            (int)(((ll)a[0][0]*z.a[0][1]+(ll)a[0][1]*z.a[1][1])%M),
            (int)(((ll)a[1][0]*z.a[0][0]+(ll)a[1][1]*z.a[1][0])%M),
            (int)(((ll)a[1][0]*z.a[0][1]+(ll)a[1][1]*z.a[1][1])%M)
        };
    }
    void put()const{
        printf("%d %d\n%d %d\n",a[0][0],a[0][1],a[1][0],a[1][1]);
    }
}sm[N][2][2];//flip,reverse
struct vec{
    int a[2];
    vec operator*(const mtx &z)const{
        return{
            (int)(((ll)a[0]*z.a[0][0]+(ll)a[1]*z.a[1][0])%M),
            (int)(((ll)a[0]*z.a[0][1]+(ll)a[1]*z.a[1][1])%M)
        };
    }
    void put()const{
        printf("%d %d\n",a[0],a[1]);
    }
};
const mtx WE[]={{1,1,0,1},{2,M-1,1,0}},A={1,1,0,1};
const vec B={1,0};
int fp[N],rv[N],nw[N],rt,cnt;
int n,q,t[N][2],f[N],sz[N];
#define ls t[x][0]
#define rs t[x][1]
#define tp(x) (t[f[x]][1]==x)
#define in(x) (t[f[x]][0]==x||tp(x))
void pp(int x){
    for(int i=0;i<2;++i)
        for(int k=0;k<2;++k)
            sm[x][i][k]=sm[t[x][k]][i][k]*WE[nw[x]^i]*sm[t[x][!k]][i][k];
    sz[x]=sz[ls]+sz[rs]+1;
}void Flip(int x){
    nw[x]^=1,fp[x]^=1;
    swap(sm[x][0][0],sm[x][1][0]);
    swap(sm[x][0][1],sm[x][1][1]);
}void Rev(int x){
    rv[x]^=1,swap(ls,rs);
    swap(sm[x][0][0],sm[x][0][1]);
    swap(sm[x][1][0],sm[x][1][1]);
}
void rot(int x){
    int y=f[x],k=tp(x),w=t[x][!k];
    t[t[x][!k]=y][k]=w,f[w]=y;
    if(in(y))t[f[y]][tp(y)]=x;
    f[x]=f[y],f[y]=x,pp(y);
}
void pd(int x){
    if(rv[x]){
        if(ls)Rev(ls);
        if(rs)Rev(rs);rv[x]=0;
    }if(fp[x]){
        if(ls)Flip(ls);
        if(rs)Flip(rs);fp[x]=0;
    }
}
void ppd(int x){
    if(in(x))ppd(f[x]);pd(x);
}
void splay(int x){
    ppd(x);
    for(int y=f[x];in(x);rot(x),y=f[x])
        if(in(y))rot(tp(x)^tp(y)?x:y);
    pp(rt=x);
}
int fkth(int x,int k){
    while(1){
        pd(x);
        if(k<=sz[ls])x=ls;
        else if(k==sz[ls]+1)break;
        else k-=sz[ls]+1,x=rs;
    }splay(x);return x;
}
string op;
int main(){
    sm[0][0][0]=sm[0][0][1]=sm[0][1][0]=sm[0][1][1]={1,0,0,1};
    ios::sync_with_stdio(false);
    cin>>n>>q>>op;
    int i,j,k,l,r,x,y;
    for(x=1;x<=n;++x){
        nw[x]=(op[x-1]=='E');
        if(x>1)ls=x-1;if(x<n)f[x]=x+1;
        pp(x);
    }rt=cnt=n;
    (B*sm[rt][0][1]*A).put();
    while(q--){
        cin>>op;
        if(op[0]=='A'){
            cin>>op;
            nw[x=++cnt]=(op[0]=='E');
            f[ls=rt]=x,rt=x,pp(x);
        }else{
            cin>>l>>r;
            x=fkth(rt,r),f[r=rs]=0,rs=0,pp(x);
            x=fkth(x,l),f[l=ls]=0,ls=0,pp(x);
            if(op[0]=='R'){
                Rev(x),pd(x),f[rs=r]=x,pp(x);
                x=fkth(x,1),f[ls=l]=x,pp(x);
            }else{
                Flip(x),pd(x),f[ls=l]=x,pp(x);
                x=fkth(x,sz[x]);
                f[rs=r]=x,pp(x);
            }
        }(B*sm[rt][0][1]*A).put();
    }return 0;
}
```

---

## 作者：jerry3128 (赞：6)

不要分类讨论！（

- 我们从后往前考虑操作，发现一段连续的 E 的本质就是对序列倒数第二个数的加操作，W 的本质就是当前最后一个数的加操作。
- 也就是说我们能够很快的通过连续的 W 和 E 算出每个位置上的数。
- 考虑知道了这些数如何合并，我们需要一个有交换律的东西才能进行树形分治结构的优化。我们考虑当前的分数 $\frac{a}{b}$ 当前后字母相同时，每次加一其实是分子加上分母。而每次字母出现变换时，分子分母会进行一次互换，同时分子加上分母。
- 这样的运算，在它们之间互相贡献，又需要结合率，我们不由得想到矩阵乘法。并且我们还可以分析出 W,E 单独来看是等价的，我们只需要在不同的相邻点操作即可。
- 每个节点有一个从分母到分子的贡献的矩阵。每一对不同的相邻节点之间有一个交换分母分子的矩阵，这样设初始条件 $a=b=1$，矩阵后缀积就是答案，注意最开始还有个零，即要交换分母分子。
- 考虑题目给我们的修改操作。
	- 区间反转：我们可以发现这个操作只会改变最多两个相邻点对的异同关系，直接维护即可。
	- 区间翻转：区间翻转肯定涉及树形分治结构的改变，考虑平衡树进行维护，我们发现在翻转时不好直接通过当前信息计算出翻转后的信息，用提前维护的思想，在维护后缀积时直接维护前缀积，区间翻转的时候直接交换即可。

```
//ayame保佑，夸哥保佑，狗妈保佑，MDR保佑，锉刀怪保佑，M99保佑，克爹保佑
#include<bits/stdc++.h>
using namespace std;
int p1=1000000,p2=0;
char buf[1000005],wb[1000005];
int gc() {
	if(p1>=1000000)fread(buf,1,1000000,stdin),p1=0;
	return buf[p1++];
}
#define gc getchar
#define Loli true
#define Kon xor true
long long getint() {
	long long ret=0,flag=1;
	char c=gc();
	while(c<'0'||c>'9') {
		if(c=='-')flag=-1;
		c=gc();
	}
	while(c<='9'&&c>='0') {
		ret=(ret<<3)+(ret<<1)+c-'0';
		c=gc();
	}
	return ret*flag;
}
void pc(char x) {
	if(p2>=1000000)fwrite(wb,1,1000000,stdout),p2=0;
	wb[p2++]=x;
}
void wrt(long long x) {
	if(x<0)pc('-'),x=-x;
	int c[24]= {0};
	if(!x)return pc('0'),void();
	while(x)c[++c[0]]=x%10,x/=10;
	while(c[0])pc(c[c[0]--]+'0');
}
const int mod = 998244353;
const int MOD(int x){return x>=mod?x-mod:x;}
int n,Q,rt;
char c[100005];
long long ksm(long long a,long long b){
	long long ret=1;
	while(b){
		if(b&1)ret=ret*a%mod;
		a=a*a%mod,b>>=1;
	}
	return ret;
}
void calc(){
	long long a=1,b=1;
	int numW=0,numE=0;
	for(int i=n;i>=1;i--){
		if(c[i]!=c[i+1]){
			if(c[i]=='E')swap(a,b),b=MOD(numW*a%mod+b);
			if(c[i]=='W')swap(a,b),b=MOD(numE*a%mod+b);
			numW=numE=0;
		}
		if(c[i]=='W')++numW;
		if(c[i]=='E')++numE;
	}
	if(c[1]=='E')swap(a,b),b=MOD(numE*a%mod+b);
	if(c[1]=='W')swap(a,b),b=MOD(numW*a%mod+b);
	cout<<a<<" "<<b<<"\n";
}
struct matrix {
	int f[2][2];//0A 1B
	matrix(){f[0][0]=f[0][1]=f[1][0]=f[1][1]=0;}
	int* operator [](int x){return f[x];}
	matrix friend operator *(matrix &A,matrix &B){
		matrix ret=matrix();
		ret[0][0]=MOD(1ll*A[0][0]*B[0][0]%mod+1ll*A[0][1]*B[1][0]%mod);
		ret[0][1]=MOD(1ll*A[0][0]*B[0][1]%mod+1ll*A[0][1]*B[1][1]%mod);
		ret[1][0]=MOD(1ll*A[1][0]*B[0][0]%mod+1ll*A[1][1]*B[1][0]%mod);
		ret[1][1]=MOD(1ll*A[1][0]*B[0][1]%mod+1ll*A[1][1]*B[1][1]%mod);
		return ret;
	}
}C,E,R,S;
namespace T{
	int tot;
	struct node{
		int ch[2],fa,sz,pre,suf,prec,sufc,c;
		bool rev,flp;
		
		matrix sum,rsum;
	}v[200010];
	bool isroot(int x){
		return v[v[x].fa].ch[0]!=x&&v[v[x].fa].ch[1]!=x;
	}
	void push_rev(int x){
		if(!x)return;
		v[x].rev^=1;
		swap(v[x].pre,v[x].suf);
		swap(v[x].sum,v[x].rsum);
		swap(v[x].prec,v[x].sufc);
		swap(v[x].ch[0],v[x].ch[1]);
	}
	void push_flp(int x){
		if(!x)return;
		v[x].flp^=1,v[x].c^=1,v[x].prec^=1,v[x].sufc^=1;
	}
	void push_down(int x){
		if(v[x].rev){
			push_rev(v[x].ch[0]);
			push_rev(v[x].ch[1]);
			v[x].rev=0;
		}
		if(v[x].flp){
			push_flp(v[x].ch[0]);
			push_flp(v[x].ch[1]);
			v[x].flp=0;
		}
	}
	void push_up(int rt){
		v[rt].sz=v[v[rt].ch[0]].sz+1+v[v[rt].ch[1]].sz-(rt>200005);
		v[rt].pre=v[rt].ch[0]?(v[rt].prec=v[v[rt].ch[0]].prec,v[v[rt].ch[0]].pre):(v[rt].prec=v[rt].c,rt);
		v[rt].suf=v[rt].ch[1]?(v[rt].sufc=v[v[rt].ch[1]].sufc,v[v[rt].ch[1]].suf):(v[rt].sufc=v[rt].c,rt);
		
		v[rt].sum=C;
		if(v[rt].ch[1])v[rt].sum=v[rt].sum*v[v[rt].ch[1]].sum;
		if(v[rt].ch[1]&&v[v[rt].ch[1]].prec^v[rt].c)v[rt].sum=v[rt].sum*R;
		v[rt].sum=v[rt].sum*(rt>200005?C:E);
		if(v[rt].ch[0]&&v[v[rt].ch[0]].sufc^v[rt].c)v[rt].sum=v[rt].sum*R;
		if(v[rt].ch[0])v[rt].sum=v[rt].sum*v[v[rt].ch[0]].sum;
		
		v[rt].rsum=C;
		if(v[rt].ch[0])v[rt].rsum=v[rt].rsum*v[v[rt].ch[0]].rsum;
		if(v[rt].ch[0]&&v[v[rt].ch[0]].sufc^v[rt].c)v[rt].rsum=v[rt].rsum*R;
		v[rt].rsum=v[rt].rsum*(rt>200005?C:E);
		if(v[rt].ch[1]&&v[v[rt].ch[1]].prec^v[rt].c)v[rt].rsum=v[rt].rsum*R;
		if(v[rt].ch[1])v[rt].rsum=v[rt].rsum*v[v[rt].ch[1]].rsum;
	}
	int build(int l,int r){
		int mid=(l+r)>>1,now=++tot;
		if(l<mid)v[v[now].ch[0]=build(l,mid-1)].fa=now;
		if(mid<r)v[v[now].ch[1]=build(mid+1,r)].fa=now;
		v[now].c=c[mid]=='E';
		if(l==mid&&l==1)v[now].ch[0]=200006,v[200006].fa=now,push_up(200006);
		if(mid==r&&r==n)v[now].ch[1]=200007,v[200007].fa=now,push_up(200007);
		push_up(now);
		return now;
	}
	void rot(int x){
		int p=v[x].fa,g=v[p].fa;
		bool d=v[p].ch[1]==x;
		if(!isroot(p))v[g].ch[v[g].ch[1]==p]=x;
		v[p].ch[d]=v[x].ch[d^1];
		v[v[x].ch[d^1]].fa=p;
		v[x].ch[d^1]=p;
		v[x].fa=g,v[p].fa=x;
		push_up(p),push_up(x);
	}
	void pre_push_down(int x){
		if(!isroot(x))pre_push_down(v[x].fa);
		push_down(x);
	}
	void splay(int x,int f=0){
		pre_push_down(x);
		while(v[x].fa!=f){
			int p=v[x].fa,g=v[p].fa;
			if(v[p].fa!=f)rot(v[g].ch[0]==p^v[p].ch[0]==x?x:p);
			rot(x);
		}
		if(!f)rt=x;
	}
	int fdrk(int x,int sz){
		push_down(x);
		if(sz<=v[v[x].ch[0]].sz)return fdrk(v[x].ch[0],sz);
		if(x<=200005&&(sz-=v[v[x].ch[0]].sz)==1)return x;
		return fdrk(v[x].ch[1],sz-(x<=200005));
	}
	void ADD(int val){
		splay(v[rt].suf),splay(v[v[rt].ch[0]].suf);
		v[v[rt].ch[1]].ch[0]=++tot,v[tot].c=val,v[tot].fa=v[rt].ch[1],push_up(tot),push_up(v[rt].ch[1]),push_up(rt);
	}
	void FLIP(int l,int r){
		if(l==r)return l=fdrk(rt,l),splay(l),v[l].c^=1,push_up(l),void();
		l=fdrk(rt,l),splay(l),r=fdrk(rt,r),splay(r);
		splay(l),splay(r,l),l=v[v[l].ch[0]].suf,r=v[v[r].ch[1]].pre;
		splay(l),splay(r,l),push_flp(v[r].ch[0]),push_up(r),push_up(l);
	}
	void REVERSE(int l,int r){
		if(l==r)return;
		l=fdrk(rt,l),splay(l),r=fdrk(rt,r),splay(r);
		splay(l),splay(r,l),l=v[v[l].ch[0]].suf,r=v[v[r].ch[1]].pre;
		splay(l),splay(r,l),push_rev(v[r].ch[0]),push_up(r),push_up(l);
	}
}
int main() {
//	system("fc code.out code5.ans");
//	freopen("code.in","r",stdin);
//	freopen("code.out","w",stdout);
	C[0][0]=C[1][1]=1;
	E[0][0]=E[1][1]=E[1][0]=1;
	S[0][0]=S[0][1]=1;
	R[0][1]=R[1][0]=1;
	n=getint(),Q=getint();
	scanf("%s",c+1);
	rt=T::build(1,n);
	cout<<(S*T::v[rt].sum)[0][1]<<" "<<(S*T::v[rt].sum)[0][0]<<'\n';
	for(int i=1;i<=Q;i++){
		scanf("%s",c+1);
		if(c[1]=='A')scanf("%s",c+1),T::ADD(c[1]=='E');
		if(c[1]=='F'){int l=getint(),r=getint();T::FLIP(l,r);}
		if(c[1]=='R'){int l=getint(),r=getint();T::REVERSE(l,r);}
		cout<<(S*T::v[rt].sum)[0][1]<<" "<<(S*T::v[rt].sum)[0][0]<<'\n';
	}
	fwrite(wb,1,p2,stdout);
	return Loli Kon;
}
```

哨兵有点烦（恼

~~说实话，我觉得比T1简单~~

---

## 作者：约瑟夫用脑玩 (赞：3)

这里是考场上想出来的凡人做法，但好像和其他人的做法有些出入？这里是直接维护的 `a` 数组的贡献。

首先观察如何用一串 `W` 和 `E` 来得到 `a` 数列，发现如果是在中间的连续一段的 `EEE...EWWW...W` 的话，`E` 的个数和 `W` 的个数刚好确定连续的两个 `a` 的值。

再考虑边界，如果第一个字符是 `W`，那么最前面会多出来个 $a_0=0$，如果第一个字符是 `E` 则无影响。

如果最后一个字符是 `W`，那么最后面的 $a_k+1\to a_k$，因为没有 `E` 把它减 1，如果最后一个字符是 `E`，那么最后面会多出来个 $a_k=1$。

这些在回答询问时都可以处理。

考虑 `a` 数列对答案的贡献：我们考虑 $a_i+\dfrac{1}{a_{i+1}+\dfrac{1}{...+\frac{1}{x}}}$，我们希望预处理后对于一个有理数 $x$ 快速求出这个式子的值。

设 $x=\frac{q}{p}$，当前层为的 `a` 的值为 $a_k$，那么每从 $x$ 往上走一层，有 $p+q\cdot a_k\to q'$，$q\to p'$。

那么设贡献为 $\dfrac{c\cdot p+d\cdot q}{a\cdot p+b\cdot q}$ ，转移 $a,b,c,d$ 即可，此部分通过暴力验证是正确的。

接下来的事情就简单了，考虑操作对 `a` 数列带来变化。

1. `APPEND`：改变最后一个 `a`，可能在最后加入 `a`，并可能改变尾字符。

1. `FLIP`：可能把某两个 `a` 拆开，并可能改变首尾的字符。

1. `REVERSE`：可能把某两个 `a` 拆开，并可能改变首尾的字符，同时中间贡献的转移翻转。

改变某个或某两个 `a` 的操作是平凡的，只要你能找到拆开后左右的大小，改变首尾字符也是平凡的，不再赘述。

考虑中间的转移被翻转怎么办，显然我们可以把正着转移的贡献和倒着转移的贡献都算出来，翻转直接 swap 两个的贡献即可。

如果使用块链来维护上述过程是十分契合的，每次拆开两个 `a` 或改变一个 `a` 时可以直接拆块然后暴力重构整个块，复杂度是 $O(\sqrt{n})$ 的。

翻转贡献的办法也已经说过，而 `a` 数组本身被翻转用块链也很好实现，这样的话找任意一个位置都是 $O(\sqrt{n})$ 的。

为什么没写出来？你觉得我考场上能写块链？

下来后发现平衡树也能轻易维护上述操作，裂开。

---

## 作者：小超手123 (赞：2)

### 分析：

发现 $f$ 的倒数形如： 
$$
\frac{1}{a_{0}+\frac{1}{a_{1}+\frac{1}{a_{2}+\dots}}}
$$
考虑**从右往左**加入 $a_{i}$，将 $\frac{a}{b} \rightarrow \frac{A}{B}$：
$$
\frac{A}{B}=\frac{1}{a_{i}+\frac{a}{b}}
$$
可以发现 $A=b,\ B=a_{i} \times b+a$。

似乎可以使用矩阵乘法。
$$
\begin{bmatrix}
  A \\
  B
\end{bmatrix}
=
\begin{bmatrix}
  0 & 1 \\
  1 & a_{i}
\end{bmatrix}
\times
\begin{bmatrix}
  a \\
  b
\end{bmatrix}
$$
最后答案即为：
$$
\begin{bmatrix}
  0 & 1 \\
  1 & a_{0}
\end{bmatrix}
\times
\begin{bmatrix}
  0 & 1 \\
  1 & a_{1}
\end{bmatrix}
\times
\begin{bmatrix}
  0 & 1 \\
  1 & a_{2}
\end{bmatrix}
\times
\dots
\times
\begin{bmatrix}
  0 & 1 \\
  1 & a_{3}
\end{bmatrix}
\times
\begin{bmatrix}
  0 \\
  1
\end{bmatrix}
$$
不难构造出，$W$ 操作就是在后面乘上 $\begin{bmatrix}
  1 & 1 \\
  0 & 1
\end{bmatrix}$，$E$ 操作就是在后面乘上 $\begin{bmatrix}
  0 & -1 \\
  1 & 2
\end{bmatrix}$。

由于有翻转操作和取反操作，因此可以使用 FHQ-Treap 来维护。

具体地，平衡树每个节点维护以下信息：

- 该节点的类型（是 $W$ 还是 $E$）。

- 子树内的矩阵连乘积。
- 子树内的翻转矩阵连乘积。
- 子树内的取反矩阵连乘积。
- 子树内的翻转取反矩阵连乘积。
- 子树内的翻转标记。
- 子树内的取反标记。

标记的合并只需要异或 $1$ 即可。时间复杂度 $O(n \log n)$。常数巨大，轻度卡常。

### 代码：

```cpp
#include<bits/stdc++.h>
#define N 200005
#define mod 998244353
#define ll long long
using namespace std;

struct node {
	int n, m;
	int a[5][5];
	friend node operator * (node x, node y) {
		node z;
		if(x.n == 2 && x.m == 2 && y.n == 2 && y.m == 2) {
			z.n = z.m = 2;
			z.a[1][1] = 1ll * ((long long)1ll * x.a[1][1] * y.a[1][1] % mod + (long long)1ll * x.a[1][2] * y.a[2][1] % mod + mod) % mod;
			z.a[1][2] = 1ll * ((long long)1ll * x.a[1][1] * y.a[1][2] % mod + (long long)1ll * x.a[1][2] * y.a[2][2] % mod + mod) % mod;
			z.a[2][1] = 1ll * ((long long)1ll * x.a[2][1] * y.a[1][1] % mod + (long long)1ll * x.a[2][2] * y.a[2][1] % mod + mod) % mod;
			z.a[2][2] = 1ll * ((long long)1ll * x.a[2][1] * y.a[1][2] % mod + (long long)1ll * x.a[2][2] * y.a[2][2] % mod + mod) % mod;
			return z;
		}
		else {
			z.n = 2; z.m = 1;
			z.a[1][1] = 1ll * ((long long)1ll * x.a[1][1] * y.a[1][1] % mod + (long long)1ll * x.a[1][2] * y.a[2][1] % mod + mod) % mod;
			z.a[2][1] = 1ll * ((long long)1ll * x.a[2][1] * y.a[1][1] % mod + (long long)1ll * x.a[2][2] * y.a[2][1] % mod + mod) % mod;
			return z;
		}
	}
};

void Out(node X) {
	cout << endl;
	for(int i = 1; i <= X.n; i++) {
		for(int j = 1; j <= X.m; j++) cout << X.a[i][j] << " ";
		cout << endl;
	}
	cout << endl;
}

node Empty() {
	node now;
	now.n = now.m = 2;
	now.a[1][1] = now.a[2][2] = 1;
	now.a[1][2] = now.a[2][1] = 0;
	return now;
}
int n, Q, root, cnt;
int ls[N], rs[N], siz[N], pri[N];
node My[N];
char r[N];
node val[N], val_f[N], val_r[N], val_fr[N];
bool tagf[N], tagr[N]; //f:是否取反 r:是否翻转 

node W, E, P, X;

int newnode(char opt) {
	cnt++;
	siz[cnt] = 1;
	pri[cnt] = rand() * rand(); 
	
	if(opt == 'E') {
		val[cnt] = val_r[cnt] = E;
		val_f[cnt] = val_fr[cnt] = W;
	}
	else {
		val[cnt] = val_r[cnt] = W;
		val_f[cnt] = val_fr[cnt] = E;
	}
	
	My[cnt] = val[cnt];
	r[cnt] = opt;
	return cnt;
}


void pushup(int u) {
	siz[u] = siz[ls[u]] + siz[rs[u]] + 1;
	val[u] = val[ls[u]] * My[u] * val[rs[u]];
	node now;
	if(r[u] == 'E') now = W;
	else now = E;
	val_f[u] = val_f[ls[u]] * now * val_f[rs[u]];
	val_r[u] = val_r[rs[u]] * My[u] * val_r[ls[u]];
	val_fr[u] = val_fr[rs[u]] * now * val_fr[ls[u]];
}

void maketag(int u, bool F, bool R) { //Flip, Revserse, 
	node A = val[u], B = val_r[u], C = val_f[u], D = val_fr[u];
	if(!F && R) { //只翻转
		swap(ls[u], rs[u]);
		val[u] = B;
		val_r[u] = A;
		val_f[u] = D;
		val_fr[u] = C;
		tagr[u] ^= 1;
	}
	else if(F && !R) { //只取反 
		val[u] = C;
		val_r[u] = D;
		val_f[u] = A;
		val_fr[u] = B;
		tagf[u] ^= 1;
		if(r[u] == 'E') {
			r[u] = 'W';
			My[u] = W;
		}
		else {
			r[u] = 'E';
			My[u] = E;
		}
	}
	else if(F && R) { //取反+翻转
		swap(ls[u], rs[u]);
		val[u] = D;
		val_r[u] = C;
		val_f[u] = B;
		val_fr[u] = A; 
		tagf[u] ^= 1;
		tagr[u] ^= 1;
		if(r[u] == 'E') {
			r[u] = 'W';
			My[u] = W;
		}
		else {
			r[u] = 'E';
			My[u] = E;
		}
	}
}

void pushdown(int u) {
	maketag(ls[u], tagf[u], tagr[u]);
	maketag(rs[u], tagf[u], tagr[u]);
	tagf[u] = tagr[u] = 0;
}

int merge(int x, int y) {
	if(x == 0 || y == 0) return x + y;
	pushdown(x); pushdown(y);
	if(pri[x] < pri[y]) {
		rs[x] = merge(rs[x], y);
		pushup(x);
		return x;
	} 
	else {
		ls[y] = merge(x, ls[y]);
		pushup(y);
		return y;
	}
}

void split(int u, int &x, int &y, int k) {
	if(u == 0) {
		x = y = 0;
		return;
	}
	pushdown(u);
	if(k <= siz[ls[u]]) {
		y = u;
		split(ls[u], x, ls[u], k);
	}
	else {
		x = u;
		split(rs[u], rs[u], y, k - siz[ls[u]] - 1);
	}
	pushup(u);
}

void Insert(char opt) {
	root = merge(root, newnode(opt));
}

string S, opt;

void Flip(int l, int r) {
	int x, y, z;
	split(root, x, y, l - 1);
	split(y, y, z, r - l + 1);
	maketag(y, 1, 0);
	root = merge(merge(x, y), z);
}

void Reverse(int l, int r) {
	int x, y, z;
	split(root, x, y, l - 1);
	split(y, y, z, r - l + 1);
	maketag(y, 0, 1);
	root = merge(merge(x, y), z);
}

void Print() {
	node Ans = P * val[root] * X;
	cout << Ans.a[2][1] << " " << Ans.a[1][1] << endl;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	val[0] = val_f[0] = val_r[0] = val_fr[0] = Empty();
	W.n = W.m = E.n = E.m = P.n = P.m = 2;
	W.a[1][1] = 1; W.a[1][2] = 1; W.a[2][1] = 0; W.a[2][2] = 1;
	E.a[1][1] = 0; E.a[1][2] = -1; E.a[2][1] = 1; E.a[2][2] = 2;
	P.a[1][1] = 1; P.a[1][2] = 1; P.a[2][1] = 0; P.a[2][2] = 1;
	X.n = 2; X.m = 1;
	X.a[1][1] = 0; X.a[2][1] = 1;
	cin >> n >> Q >> S;
	for(int i = 0; i < n; i++) Insert(S[i]);
	Print();
	while(Q--) {
		cin >> opt;
		if(opt[0] == 'A') { //append
			char c;
			cin >> c;
			Insert(c);
		}
		else if(opt[0] == 'F') {
			int l, r;
			cin >> l >> r;
			Flip(l, r); 
		}
		else {
			int l, r;
			cin >> l >> r;
			Reverse(l, r);
		}
		Print();
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：2)

感觉难度和今年 D2T2 差不多。

 首先一个很显然的事情是，每一步得到的分数的分子分母都是互质的，证明参考 SBT。而最后答案要求我们将分子分母都求出来而不是求分数值，所以可以很明显的想到将分数当成一个二元组然后维护变换。

考虑从右往左扫，假设当前分数为 $\dfrac{x}{y}$，那么扫过 $a_k$ 这个元素之后就会变成，$\begin{bmatrix}x&y\end{bmatrix}\times\begin{bmatrix}a_{k}&1\\1&0\end{bmatrix}$，而初始情况为了满足 $\begin{bmatrix}x&y\end{bmatrix}\times\begin{bmatrix}a_{k}&1\\1&0\end{bmatrix}=\begin{bmatrix}a_k&1\end{bmatrix}$，所以初始情况应有 $x=1,y=0$，所以如果给的是序列 A 而不是 WE 序列，那么所求即为 $\begin{bmatrix}a_{k}&1\\1&0\end{bmatrix}\begin{bmatrix}a_{k-1}&1\\1&0\end{bmatrix}\cdots\begin{bmatrix}a_{1}&1\\1&0\end{bmatrix}$，使用线段树维护矩阵乘法即可。

接下来考虑怎么维护这个 `WE` 序列。先考虑 `W`，由于 $\begin{bmatrix}1&1\\0&1\end{bmatrix}\begin{bmatrix}a_{k}&1\\1&0\end{bmatrix}=\begin{bmatrix}a_{k}+1&1\\1&0\end{bmatrix}$，所以如果序列末尾有个 W，那么相当于在整个矩乘的式子左边添加一个 $\begin{bmatrix}1&1\\0&1\end{bmatrix}$。

其次考虑 `E`。考虑 `E` 的两种情况：

- 序列的最后一个元素为 $1$，由于 $\begin{bmatrix}x&y\end{bmatrix}\times\begin{bmatrix}1&1\\1&0\end{bmatrix}\times \begin{bmatrix}1&1\\0&1\end{bmatrix}=\begin{bmatrix}x+y&2x+y\end{bmatrix}$，且 $\begin{bmatrix}x&y\end{bmatrix}\times\begin{bmatrix}2&-1\\1&0\end{bmatrix}\times\begin{bmatrix}1&1\\1&0\end{bmatrix}=\begin{bmatrix}x+y&2x+y\end{bmatrix}$，所以这种情况相当于在序列左边添加一个 $\begin{bmatrix}2&-1\\1&0\end{bmatrix}$。
- 序列的最后一个元素不是 $1$，那么相当于在序列左边添加 $\begin{bmatrix}1&1\\1&0\end{bmatrix}\times \begin{bmatrix}1&1\\1&0\end{bmatrix}\times \begin{bmatrix}-1&1\\1&0\end{bmatrix}$，而我们刚好发现这个式子的结果也是 $\begin{bmatrix}2&-1\\1&0\end{bmatrix}$。

换句话说，如果序列末尾有个 `E`，那么相当于在整个矩乘的式子左边添加一个 $\begin{bmatrix}2&-1\\1&0\end{bmatrix}$。

这样问题就容易了：相当于把序列 `reverse` 过来，把 `w` 替换为 $\begin{bmatrix}1&1\\0&1\end{bmatrix}$，`E` 替换为 $\begin{bmatrix}2&-1\\1&0\end{bmatrix}$，求矩阵连乘后的结果。由于涉及 `reverse` 和 `flip`，使用平衡树维护即可。

```cpp
const int MAXN=2e5;
const int MOD=998244353;
mt19937 rng(time(0));
int n,qu;char str[MAXN+5];
struct mat{
	int a[2][2];
	mat(){memset(a,0,sizeof(a));}
	friend mat operator *(const mat &X,const mat &Y){
		mat res;
		for(int i=0;i<2;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)
			res.a[i][j]=(res.a[i][j]+1ll*X.a[i][k]*Y.a[k][j])%MOD;
		return res;
	}
}W,E,I;
struct node{int ch[2],key,typ,siz,rev_lz,flip_lz;mat v[2][2];}s[MAXN+5];
int rt,ncnt;
int nwnd(int x){
	++ncnt;s[ncnt].key=rng();s[ncnt].typ=x;s[ncnt].siz=1;
	s[ncnt].v[0][0]=s[ncnt].v[0][1]=(x)?E:W;
	s[ncnt].v[1][0]=s[ncnt].v[1][1]=(x)?W:E;
	return ncnt;
}
void pushup(int k){
	s[k].v[0][0]=s[s[k].ch[0]].v[0][0]*((s[k].typ)?E:W)*s[s[k].ch[1]].v[0][0];
	s[k].v[1][0]=s[s[k].ch[0]].v[1][0]*((s[k].typ)?W:E)*s[s[k].ch[1]].v[1][0];
	s[k].v[0][1]=s[s[k].ch[1]].v[0][1]*((s[k].typ)?E:W)*s[s[k].ch[0]].v[0][1];
	s[k].v[1][1]=s[s[k].ch[1]].v[1][1]*((s[k].typ)?W:E)*s[s[k].ch[0]].v[1][1];
	s[k].siz=s[s[k].ch[0]].siz+s[s[k].ch[1]].siz+1;
}
void tag_rev(int k){
	swap(s[k].ch[0],s[k].ch[1]);s[k].rev_lz^=1;
	swap(s[k].v[0][0],s[k].v[0][1]);swap(s[k].v[1][0],s[k].v[1][1]);
}
void tag_flip(int k){
	s[k].typ^=1;s[k].flip_lz^=1;
	swap(s[k].v[0][0],s[k].v[1][0]);swap(s[k].v[0][1],s[k].v[1][1]);
}
void pushdown(int k){
	if(s[k].rev_lz){
		if(s[k].ch[0])tag_rev(s[k].ch[0]);
		if(s[k].ch[1])tag_rev(s[k].ch[1]);
		s[k].rev_lz=0;
	}
	if(s[k].flip_lz){
		if(s[k].ch[0])tag_flip(s[k].ch[0]);
		if(s[k].ch[1])tag_flip(s[k].ch[1]);
		s[k].flip_lz=0;
	}
}
int merge(int a,int b){
	if(!a||!b)return a+b;pushdown(a);pushdown(b);
	if(s[a].key<s[b].key)return s[a].ch[1]=merge(s[a].ch[1],b),pushup(a),a;
	else return s[b].ch[0]=merge(a,s[b].ch[0]),pushup(b),b;
}
void split(int k,int sz,int &a,int &b){
	if(!k)return a=b=0,void();pushdown(k);
	if(sz<=s[s[k].ch[0]].siz)return b=k,split(s[k].ch[0],sz,a,s[k].ch[0]),pushup(k),void();
	else return a=k,split(s[k].ch[1],sz-s[s[k].ch[0]].siz-1,s[k].ch[1],b),pushup(k),void();
}
void calc(){
	int x=s[rt].v[0][0].a[0][0],y=s[rt].v[0][0].a[0][1];
	printf("%d %d\n",x,(x+y)%MOD);
}
int main(){
	scanf("%d%d%s",&n,&qu,str+1);
	W.a[0][0]=1;W.a[0][1]=1;W.a[1][0]=0;W.a[1][1]=1;
	E.a[0][0]=2;E.a[0][1]=MOD-1;E.a[1][0]=1;E.a[1][1]=0;
	I.a[0][0]=I.a[1][1]=1;
	for(int i=0;i<2;i++)for(int j=0;j<2;j++)s[0].v[i][j]=I;
	for(int i=1;i<=n;i++)rt=merge(nwnd(str[i]=='E'),rt);
	calc();
	while(qu--){
		static char opt[10];scanf("%s",opt+1);
		if(opt[1]=='A'){
			static char chr[10];scanf("%s",chr+1);
			++n;rt=merge(nwnd(chr[1]=='E'),rt);
		}else if(opt[1]=='F'){
			int l,r,k1,k2,k3;scanf("%d%d",&l,&r);
			swap(l,r);l=n-l+1;r=n-r+1;
			split(rt,r,k1,k3);split(k1,l-1,k1,k2);tag_flip(k2);
			rt=merge(merge(k1,k2),k3);
		}else{
			int l,r,k1,k2,k3;scanf("%d%d",&l,&r);
			swap(l,r);l=n-l+1;r=n-r+1;
			split(rt,r,k1,k3);split(k1,l-1,k1,k2);tag_rev(k2);
			rt=merge(merge(k1,k2),k3);
		}calc();
	}
	return 0;
}
/*
10 1
EEWEEWWWEE
FLIP 1 9
*/
```



---

## 作者：Wuyanru (赞：2)

老师留的几道题里第一个做了的，写篇题解纪念一下。

这道题主要想要写一下我做题的思路。

[更好的阅读体验](https://www.cnblogs.com/Wuyanru/p/NOI2021-password_box.html)

题目链接：[luoguP7739](https://www.luogu.com.cn/problem/P7739) 。

首先我们可以注意到这道题不同寻常的地方：别的题目都是让我们维护序列，但是这道题却让我们维护操作序列。

似乎非常麻烦啊。

但是什么东西可以维护呢？矩阵！

再看一下题目中的操作：翻转、反转。

一眼就可以看出正解是平衡树维护矩阵。

这些思路大概是我读完题之后就知道的，比较明显。

知道了算法，其实我们只需要推出这些矩阵就可以了，这才是这道题的重点。

我们现在再来想一个问题：假如我们现在通过矩阵，维护了某一个序列的答案。

我们现在给这个序列后面添加一个数字，我们可以算出答案吗？

似乎不行，或者说起码没有特别简单的方法。

但是如果这个数字添加在了整个序列的前面，我们却很好维护。

假如说 $ f(a_0,a_1,\dots,a_k) $ 的答案为 $ \dfrac{x}{y} $ ，这个时候序列变成 $ (c,a_0,a_1,\dots,a_k) $ ，答案显然会变成 $ c+\dfrac{y}{x}=\dfrac{cx+y}{x} $ 。

那也就是：
$$
\begin{bmatrix}
 x&y 
\end{bmatrix}
\times 
\begin{bmatrix}
 c&1 \\
 1&0
\end{bmatrix}
=
\begin{bmatrix}
 cx+y&x
\end{bmatrix}
$$
所以我们得到了一些启发：序列倒着会比较好维护。

其实正着可能也差不多，但是我还是觉得倒着比较方便。

然后我们再来看题目中给的操作。

首先我们来看 W 操作。

将序列中最后一个值加一，因为我们倒着维护序列，所以就是整个序列第一个位置加一。

假设说这个地方原来的值是 $ c $ ，那么这个地方对应的矩阵就是 $ \begin{bmatrix} c&1 \\ 1&0\end{bmatrix} $ 。

我们现在要将这个地方的矩阵要变成 $ \begin{bmatrix} c+1&1 \\ 1&0\end{bmatrix} $ 。

因为对于任何 $ c $ ，这个变换都要成立，所以稍微手推一下，就可以发现：
$$
\begin{bmatrix} 1&1 \\ 0&1\end{bmatrix}
\times 
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
=
\begin{bmatrix} c+1&1 \\ 1&0\end{bmatrix}
$$
接下来我们来推 E，你会发现似乎有点麻烦。不慌，我们直接推。

对于第一个数字不是 $ 1 $ 的情况，就是先把这个数字减一，然后在序列前面添上两个 $ 1 $ 。

所以我们先推一下如何给一个数字减一，感觉和上面差不多。
$$
\begin{bmatrix} 1&-1 \\ 0&1\end{bmatrix}
\times 
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
=
\begin{bmatrix} c-1&1 \\ 1&0\end{bmatrix}
$$
那么这个矩阵推出来就是：
$$
\begin{aligned}
&\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&-1 \\ 0&1\end{bmatrix}\\
=&\begin{bmatrix} 2&1 \\ 1&1\end{bmatrix}
\times
\begin{bmatrix} 1&-1 \\ 0&1\end{bmatrix}\\
=&\begin{bmatrix} 2&-1 \\ 1&0\end{bmatrix}
\end{aligned}
$$
 然后再来推一下第一个数字是 $ 1 $ 的情况。不妨写一下原来的矩阵和变化后的矩阵。

假设原来第二个数是 $ c $ （第一个数是 $ 1 $ ）。

那么开头的两个矩阵长这个样子：
$$
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
$$
我们将第二个数字加上一：
$$
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 0&1\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
$$
前两项都是常数项，我们把它们乘起来。
$$
\begin{bmatrix} 1&2 \\ 1&1\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
$$
我们肯定尽量想将他表示成对第一个数字的操作，所以我们把第一项拆开：
$$
\begin{bmatrix} ?&? \\ ?&?\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
$$
可以带进去的数字有点多，不好算。

就这么卡住了嘛？

看看上面？
$$
\begin{bmatrix} 2&-1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} 1&1 \\ 1&0\end{bmatrix}
\times
\begin{bmatrix} c&1 \\ 1&0\end{bmatrix}
$$
没错，E 操作直接用这一个矩阵就可以解决。

矩阵就这样推完了。

我们再来看题目中的这些操作。

操作一，直接在所有矩阵前添加一个数字。

操作三，直接整个区间翻转。

操作二，看起来不好搞，实际上和操作三一样，直接暴力维护没有转和转了之后这个区间长什么样子就行。

$ 4 $ 倍常数，建议实现的时候尽量常数写小一点。

代码：

```c++
#include<algorithm>
#include<cstring>
#include<random>
#include<cstdio>
#include<ctime>
using namespace std;
const int mod=998244353;
mt19937 _rand(time(0)^clock());
using ll=long long;
inline int read()
{
	int s=0,w=1;char ch;
	while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
template<const int n,const int m>
struct mat
{
	ll a[n][m];
	template<const int q>
	mat<n,q> operator * (mat<m,q>b)
	{
		mat<n,q>ans;
		memset(ans.a,0,sizeof(ans.a));
		for(int i=0;i<n;i++)
			for(int k=0;k<m;k++)
				for(int j=0;j<q;j++)
					(ans.a[i][j]+=a[i][k]*b.a[k][j])%=mod;
		return ans;
	}
	inline void debug()
	{
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++) printf("%lld ",a[i][j]);
			printf("\n");
		}
		printf("\n");
	}
};
mat<2,2>num0[200001];
mat<2,2>num1[200001];
mat<2,2>num2[200001];
mat<2,2>num3[200001];
mat<2,2>val0[200001];
mat<2,2>val2[200001];
bool rev[200001];
bool fli[200001];
int pri[200001];
int siz[200001];
int ls[200001];
int rs[200001];
char in[100002];
int root;
int tot;
int n,m;
int Neww()
{
	tot++;
	pri[tot]=_rand(),siz[tot]=1;
	num0[tot].a[0][0]=num0[tot].a[0][1]=num0[tot].a[1][1]=1;
	num2[tot].a[0][0]=2,num2[tot].a[0][1]=-1,num2[tot].a[1][0]=1;
	val0[tot]=num1[tot]=num0[tot],val2[tot]=num3[tot]=num2[tot];
	return tot;
}
int Newe()
{
	tot++;
	pri[tot]=_rand(),siz[tot]=1;
	num0[tot].a[0][0]=2,num0[tot].a[0][1]=-1,num0[tot].a[1][0]=1;
	num2[tot].a[0][0]=num2[tot].a[0][1]=num2[tot].a[1][1]=1;
	val0[tot]=num1[tot]=num0[tot],val2[tot]=num3[tot]=num2[tot];
	return tot;
}
inline void push_down(int p)
{
	if(rev[p])
	{
		rev[p]^=1;
		rev[ls[p]]^=1,rev[rs[p]]^=1;
		swap(ls[p],rs[p]);
		swap(num0[p],num1[p]),swap(num2[p],num3[p]);
	}
	if(fli[p])
	{
		fli[p]^=1;
		fli[ls[p]]^=1,fli[rs[p]]^=1;
		swap(num0[p],num2[p]),swap(num1[p],num3[p]),swap(val0[p],val2[p]);
	}
}
inline void push_up(int p)
{
	if(ls[p]) push_down(ls[p]);
	if(rs[p]) push_down(rs[p]);
	num0[p]=num0[ls[p]]*val0[p]*num0[rs[p]];
	num2[p]=num2[ls[p]]*val2[p]*num2[rs[p]];
	num1[p]=num1[rs[p]]*val0[p]*num1[ls[p]];
	num3[p]=num3[rs[p]]*val2[p]*num3[ls[p]];
	siz[p]=siz[ls[p]]+siz[rs[p]]+1;
}
int merge(int u,int v)
{
	// printf("merge %d %d\n",u,v);
	if(!u||!v) return u|v;
	if(pri[u]>=pri[v])
	{
		push_down(u);
		rs[u]=merge(rs[u],v);
		push_up(u);
		return u;
	}
	else
	{
		push_down(v);
		ls[v]=merge(u,ls[v]);
		push_up(v);
		return v;
	}
}
void split(int p,int s,int &x,int &y)
{
	if(!p){ x=y=0;return ;}
	push_down(p);
	if(siz[ls[p]]>=s)
	{
		y=p;
		split(ls[p],s,x,ls[y]);
		push_up(y);
	}
	else
	{
		x=p;
		split(rs[p],s-siz[ls[p]]-1,rs[x],y);
		push_up(x);
	}
}
void print()
{
	push_down(root);
	printf("%lld %lld\n",(num0[root].a[0][0]+mod)%mod,(num0[root].a[0][0]+num0[root].a[0][1]+2*mod)%mod);
}
void debug()
{
	// printf("root=%d\n",root);
	// for(int i=1;i<=tot;i++)
	// {
	// 	printf("%d : ls=%d rs=%d rev=%d fli=%d siz=%d ",i,ls[i],rs[i],rev[i],fli[i],siz[i]);
	// 	printf("%2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld\n",val0[i].a[0][0],val0[i].a[0][1],val2[i].a[0][0],val2[i].a[0][1],num0[i].a[0][0],num0[i].a[0][1],num1[i].a[0][0],num1[i].a[0][1],num2[i].a[0][0],num2[i].a[0][1],num3[i].a[0][0],num3[i].a[0][1]);
	// 	printf("                                ");
	// 	printf("%2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld  %2lld %2lld\n",val0[i].a[1][0],val0[i].a[1][1],val2[i].a[1][0],val2[i].a[1][1],num0[i].a[1][0],num0[i].a[1][1],num1[i].a[1][0],num1[i].a[1][1],num2[i].a[1][0],num2[i].a[1][1],num3[i].a[1][0],num3[i].a[1][1]);
	// }
	// printf("\n");
}
int main()
{
	n=read(),m=read();scanf("%s",in+1);
	num0[0].a[0][0]=num0[0].a[1][1]=1;
	num1[0]=num2[0]=num3[0]=num0[0];
	for(int i=1;i<=n;i++)
	{
		if(in[i]=='W') root=merge(Neww(),root);
		else root=merge(Newe(),root);
	}
	print();
	debug();
	for(int i=1;i<=m;i++)
	{
		scanf("%s",in+1);
		if(in[1]=='A')
		{
			scanf("%s",in+1);
			if(in[1]=='E') root=merge(Newe(),root);
			else root=merge(Neww(),root);
			n++;
		}
		else if(in[1]=='R')
		{
			int r=n-read()+1,l=n-read()+1;
			int x,y,z;
			split(root,r,y,z);
			split(y,l-1,x,y);
			rev[y]^=1;
			root=merge(merge(x,y),z);
		}
		else
		{
			int r=n-read()+1,l=n-read()+1;
			int x,y,z;
			split(root,r,y,z);
			split(y,l-1,x,y);
			// printf("l=%d r=%d x=%d y=%d z=%d\n",l,r,x,y,z);
			debug();
			fli[y]^=1;
			root=merge(merge(x,y),z);
		}
		print();
		debug();
	}
	return 0;
}
/*
2 2
WE
APPEND E
FLIP 1 2
*/
```

感谢观看！

---

## 作者：Zwaire (赞：2)

# P7739 [NOI2021] 密码箱

题目链接： [Link](https://www.luogu.com.cn/problem/P7739)

本题解主要思路来源 @Rikka__(疯狂 % )。

考虑题里面的贡献的计算其实是一个连分数的倒数，即：
$$
a_1+\frac {1}{a_2+\frac{1}{a_3 + ...}}
$$
若从 $a_k$ 到 $a_1$ 从下向上合并的话能够发现其实是一个 $ \Large \frac{a'}{b'} = \frac {1}{a_i+\frac{a}{b}}$ 的形式。（首先根据辗转相除法的那一套理论明显是不用考虑约分）

那么考虑将 $a_i$ 合并上后对答案的影响：
$$
\frac {a'}{b'} = \frac{1}{a_i+\frac{a}{b}} =  \frac {b}{a_i \times b + a}
$$
那么也就是 $a' = b ,b' = a_i \times b + a$

转移是固定的故可以考虑使用矩阵进行转移：
$$
\left[
\begin {array}{l}
a'\\
b'
\end{array}
\right] 
=
\left[
\begin {array}{l}
0 &1\\
1&a_i
\end{array}
\right]
\left[
\begin {array}{l}
a\\
b
\end{array}
\right]
$$
故答案即为：
$$
\left[
\begin {array}{l}
0&1\\
1&a_1
\end{array}
\right]
\left[
\begin {array}{l}
0&1\\
1&a_2
\end{array}
\right]
...
\left[
\begin {array}{l}
0&1\\
1&a_k
\end{array}
\right]
\left[
\begin {array}{l}
0\\
1
\end{array}
\right]
$$
继续考虑使用矩阵表述操作 `W` 和 `E`：

`W`：

$a_k \rightarrow a_{k}+1$ 

发现矩阵从 $\left[\begin {array}{l}0&1\\1&a_k\end{array}\right]$ 变成 $\left[\begin{array}{l} 0&1\\1&a_{k}+1 \end{array} \right ]$ 可以发现转移矩阵即为：$\left[\begin{array}{l} 1&1\\0&1\end{array}\right]$ （右乘）

`E`：

$a_k>1$ 

$a_k \rightarrow  a_k - 1$ 并添加两个 $1$ 到末尾。

按照上面的思路，发现 $a_k \rightarrow  a_k - 1$ 转移矩阵即为 $\left[\begin{array}{l} 1&-1\\0&1\end{array}\right]$  

末尾添加两个 $1$ 转移矩阵为 $\left[\begin{array}{l}0&1\\1&1\end{array}\right]\left[\begin{array}{l}0&1\\1&1\end{array}\right]$ 

按顺序整合一下即为 $\left[\begin{array}{l}0&-1\\1&2\end{array}\right]$

$a_k = 1$ 

这时 $a_k$ 对应的矩阵为 $\left[\begin{array}{l}0&1\\1&1\end{array}\right]$。

按照正常的运算应该为 $\left[\begin{array}{l}0&1\\1&a_{k-1}\end{array}\right]\left[\begin{array}{l}1&1\\0&1\end{array}\right]\left[\begin{array}{l}0&1\\1&1\end{array}\right]$ 。

按照结合律可变为 $\left[\begin{array}{l}0&1\\1&a_{k-1}\end{array}\right]\left[\begin{array}{l}1&2\\1&1\end{array}\right]$ 

我们同样设一个矩阵 $\left[\begin{array}{l}x&y\\z&k\end{array}\right]$

满足：
$$
\left[\begin{array}{l}0&1\\1&a_{k-1}\end{array}\right]\left[\begin{array}{l}0&1\\1&1\end{array}\right]\left[\begin{array}{l}x&y\\z&k\end{array}\right]
=
\left[\begin{array}{l}0&1\\1&a_{k-1}\end{array}\right]\left[\begin{array}{l}1&2\\1&1\end{array}\right]
$$
解得矩阵 $\left[\begin{array}{l}0&-1\\1&2\end{array}\right]$

故对于 `E` 操作只需要乘上 $\left[\begin{array}{l}0&-1\\1&2\end{array}\right]$

剩余部分比较简单，只需要用一颗支持序列翻转、取反操作的平衡树实现即可。具体维护 **区间连乘积**，**区间取反连乘积**，**区间翻转连乘积**，**区间取反翻转连乘积**。同时维护**取反标记**和**翻转标记**即可

时间复杂度：$O(n\log n)$

优化：

其实有时空复杂度都更优的写法，考虑对于 `REVERSE` 和 `FLIP` 操作也像 `W` `E` 那样去通过矩阵进行转移，具体的通过矩阵中 $4$ 个元素的线性组合去构造转移矩阵。

设矩阵 $A = \left[\begin{array}{l} a&b \\ c&d \end{array}\right]  $。

有:
$$
Flip(A) = \left[\begin{array}{l} a-b&-b \\ -a+b-c+d&b+d \end{array}\right]
$$
$$
Reverse(A) = \left[\begin{array}{l} d-2c&-2a+b-4c+2d \\ c&a+2c \end{array}\right]
$$
这样就可以不去维护 $4$ 种乘积，空间和时间得到巨大优化。可以通过解方程来证明。

```
//editor : DRYAYST
//Wo shi ge da SHA BI
#include<bits/stdc++.h>
#define g() getchar()
#define il inline
#define ull unsigned long long
#define eps 1e-10
#define ll long long
#define pa pair<int, int>
#define for_1(i, n) for(int i = 1; i <= (n); ++i)
#define for_0(i, n) for(int i = 0; i < (n); ++i)
#define for_xy(i, x, y) for(int i = (x); i <= (y); ++i)
#define for_yx(i, y, x) for(int i = (y); i >= (x); --i)
#define for_edge(i, x) for(int i = head[x]; i; i = nxt[i])
#define int long long
#define DB double
#define ls tr[x].l
#define rs tr[x].r
#define m_p make_pair
#define fi first
#define se second
using namespace std;
const int N = 1e6 + 10, INF = 0x7f7f7f7f, mod = 998244353;
il int qpow(int x, int k) {int ans = 1; while(k) {if(k & 1) ans = ans * x % mod; x = x * x % mod; k >>= 1; } return ans; }
il int Add(int x, int y) {return (x += y) %= mod;}
il int Del(int x, int y) {return (x = x - y + mod) % mod;}
il int Mul(int x, int y) {return x * y % mod;}
il int inv(int x) {return qpow(x, mod - 2); }
inline int re() {
    int x = 0, p = 1;
    char ch = getchar();
    while(ch > '9' || ch < '0') {if(ch == '-') p = -1; ch = getchar();}
    while(ch <= '9' and ch >= '0') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * p;
}
mt19937 rd(20050426);
int n, Q, rt, cnt ; 
char s[N], op[100]; 
struct Matrix {
    int a[2][2];  Matrix() {memset(a, 0, sizeof(a)); }
    il Matrix operator * (const Matrix &b) const {Matrix c;  for_0(k, 2) for_0(i, 2) for_0(j, 2) c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j] % mod) % mod;  return c;}
    il Matrix Rev(Matrix A) {Matrix c;
        c.a[0][0] = (A.a[1][1] - 2 * A.a[1][0] % mod + mod) % mod;  c.a[0][1] = ((-2 * A.a[0][0] + A.a[0][1] - 4 * A.a[1][0] + 2 * A.a[1][1]) % mod + mod) % mod; 
        c.a[1][0] = A.a[1][0];  c.a[1][1] = (A.a[0][0] + 2 * A.a[1][0] % mod) % mod;  return c; 
    }
    il Matrix Flip(Matrix A) { Matrix c; 
        c.a[0][0] = (A.a[0][0] - A.a[0][1] + mod) % mod;  c.a[0][1] = (-A.a[0][1] + mod) % mod; 
        c.a[1][0] = ((-A.a[0][0] + A.a[0][1] - A.a[1][0] + A.a[1][1]) % mod + mod) % mod;   c.a[1][1] = (A.a[0][1] + A.a[1][1]) % mod; return c; 
    }
}A, B, ans, use; //A，B分别为两个转移矩阵
struct Tree {int l, r; int val, siz, rtag, ftag; Matrix V, S; }tr[N]; 
il int Newed(int x) { int id = ++cnt; tr[id].V = (x==0?A:B); tr[id].S = tr[id].V;  tr[id].l = tr[id].r = 0; tr[id].siz = 1; tr[id].rtag = tr[id].ftag = 0; tr[id].val = rd(); return id; }
il void push_up(int x) {if(!x) return; tr[x].siz = tr[ls].siz + tr[rs].siz + 1; tr[x].S = tr[ls].S * tr[x].V * tr[rs].S; return; }
il void push_rdown(int x) { if(!x) return ;  tr[x].S = use.Rev(tr[x].S);  swap(tr[x].l, tr[x].r); tr[x].rtag ^= 1; }
il void push_fdown(int x) { if(!x) return ; tr[x].S = use.Flip(tr[x].S), tr[x].V = use.Flip(tr[x].V); tr[x].ftag ^= 1;  }
il void push_down(int x) { if(!x) return;  if(tr[x].rtag) push_rdown(tr[x].l), push_rdown(tr[x].r), tr[x].rtag = 0;  if(tr[x].ftag) push_fdown(tr[x].l), push_fdown(tr[x].r), tr[x].ftag = 0;  }
il int Merge(int k1, int k2) {
    if(!k1 || !k2) return k1 + k2; 
    if(tr[k1].val < tr[k2].val) {  push_down(k1); tr[k1].r = Merge(tr[k1].r, k2); push_up(k1); return k1; }
    else {push_down(k2); tr[k2].l = Merge(k1, tr[k2].l); push_up(k2); return k2; }
}
int Build(int l, int r) { 
    if(l == r) {int now = Newed(s[l] != 'W'); return now;} int mid = (l + r) >> 1; 
    int k1 = Build(l, mid), k2 = Build(mid + 1, r); return Merge(k1, k2);
}
il int Insert(int rt, int fl) {return Merge(rt, Newed(fl)); }
void Split(int rt, int x, int &k1, int &k2) { 
    if(!rt) {k1 = 0; k2 = 0; return ; } push_down(rt); 
    if(tr[tr[rt].l].siz < x) {k1 = rt; Split(tr[rt].r, x - tr[tr[rt].l].siz -1 , tr[k1].r, k2); push_up(k1); }
    else {k2 = rt; Split(tr[rt].l, x, k1, tr[k2].l); push_up(k2);}
}
il int Flip(int rt, int l, int r) {  int k1, k2, k3; Split(rt, r, k1, k3); Split(k1, l - 1, k1, k2); push_fdown(k2); return Merge(k1, Merge(k2, k3));  }
il int Reverse(int rt, int l, int r) { int k1, k2, k3; Split(rt, r, k1, k3); Split(k1, l-1, k1, k2); push_rdown(k2); return Merge(k1, Merge(k2, k3)); }
signed main() {
    n = re(), Q = re(); scanf("%s", s + 1); A.a[0][0] = 1; A.a[0][1] = 1; A.a[1][1] = 1; B.a[0][1] = mod - 1; B.a[1][0] = 1; B.a[1][1] = 2; 
    tr[0].V.a[0][0] = 1; tr[0].V.a[1][1] = 1; tr[0].S = tr[0].V; rt = Build(1, n);  ans = A * tr[rt].S; 
    printf("%lld %lld\n", ans.a[1][1], ans.a[0][1]); 
    while(Q--) {
        scanf("%s", op + 1); 
        if(op[1] == 'A') { scanf("%s", op + 1); rt = Insert(rt, op[1] != 'W'); }
        else if(op[1] == 'F') {int l = re(), r = re(); rt = Flip(rt, l, r); }
        else {int l = re(), r = re(); rt = Reverse(rt, l, r); }
        ans = A * tr[rt].S; printf("%lld %lld\n", ans.a[1][1], ans.a[0][1]); 
    }
}
```

可能代码有点不能看,建议 loj 格式化后观看更清晰。

---

## 作者：P2441M (赞：1)

## 题意

有数列 $a$，初始时 $a_0=0,a_1=1$。有一个初始操作序列，表示你会依次对 $a$ 进行若干次操作：

- `W` 操作：给 $a$ 的最后一项加 $1$。
- `E` 操作：若 $a$ 的最后一项为 $1$，则给其倒数第二项加 $1$；否则给 $a$ 的最后一项减 $1$，再在末尾添加两个 $1$。

有函数 $f$：

$$
f(a_0,a_1,\cdots,a_k)=
\begin{cases}
a_0,&k=0\\
f\left(a_0,a_1,\cdots,a_{k-1}+\frac{1}{a_k}\right),&k\geq 1
\end{cases}
$$

有 $q$ 次对操作序列的修改：

- 在操作序列末尾添加一个某种类型的操作。
- 区间反转操作类型。
- 区间翻转操作。

初始时和每次修改后，求对数列进行操作后 $f$ 的值，用最简分数表示，答案对 $998244353$ 取模。$1\leq n,q\leq 10^5$。

## 题解

不是很难的题。

不妨将初始时的 $f$ 值视作 $\dfrac{1}{0}$，这样我们可以把 $a_k$ 也加入递归的定义。

我们首先指出，$f$ 的值在递归过程中始终是最简分数。

**证明**：考虑数学归纳法。显然初始时命题成立。设第 $n$ 次递归时 $f=\dfrac{x}{y}$，满足 $\gcd(x,y)=1$，那么第 $n+1$ 次递归后 $f$ 变为 $a_i+\dfrac{y}{x}=\dfrac{a_ix+y}{x}$。由辗转相除法，$\gcd(a_ix+y,x)=\gcd(x,y)=1$。$\Box$

输出格式明示我们将分子与分母分开维护。而我们发现一次递归就是对分子、分母二元组的线性变换，具体地：

$$
\begin{align*}
\frac{x}{y}&\rightarrow\frac{a_ix+y}{x}\\
\begin{bmatrix}
x & y
\end{bmatrix}
&\rightarrow
\begin{bmatrix}
a_ix+y & x
\end{bmatrix}\\
\begin{bmatrix}
x & y
\end{bmatrix}\times
\begin{bmatrix}
a_i &1\\
1 & 0
\end{bmatrix}&=
\begin{bmatrix}
a_ix+y & x
\end{bmatrix}
\end{align*}
$$

于是如果 $a$ 被确定，我们给 $\begin{bmatrix}1 & 0\end{bmatrix}$ 依次**右乘**上 $\begin{bmatrix}a_k &1\\
1 & 0
\end{bmatrix},\begin{bmatrix}
a_{k-1} &1\\
1 & 0
\end{bmatrix},\cdots
\begin{bmatrix}
a_1 &1\\
1 & 0
\end{bmatrix}$ 即可得到最终 $f$ 值。

考虑同样用矩阵乘法来表示两种操作。

对于操作 `W`，最左侧的矩阵从 $\begin{bmatrix}a_k &1\\
1 & 0
\end{bmatrix}$ 变为 $\begin{bmatrix}a_k+1 &1\\
1 & 0
\end{bmatrix}$，我们构造出转移矩阵为

$$
T_W=\begin{bmatrix}
1 & 1\\
0 & 1
\end{bmatrix}
$$

注意我们是在矩阵序列的**左侧**插入该转移矩阵，下文中的 $T_E$ 同理。

对于操作 `E`，我们发现给倒数第二项加 $1$ 不太好搞。直接考虑此时执行两种情况对应操作所带来的结果。设 $a$ 的后两项为 $x,1$。对于第一种情况，后两项变为 $x+1,1$，递归了这两项后 $f$ 为 $x+1+\dfrac{1}{1}=x+2$；对于第二种情况，后四项为 $x,0,1,1$，递归了这四项后 $f\rightarrow 1+\dfrac{1}{1}=2\rightarrow 0+\dfrac{1}{2}=\dfrac{1}{2}\rightarrow x+\dfrac{1}{\frac{1}{2}}=x+2$。因此这两种操作是等价的！

于是我们直接考虑第二种情况。最左侧的矩阵从 $\begin{bmatrix}a_k &1\\
1 & 0
\end{bmatrix}$ 变为 $\begin{bmatrix}a_k-1 &1\\
1 & 0
\end{bmatrix}$，可以构造出转移矩阵为 $\begin{bmatrix}
1 & -1\\
0 & 1
\end{bmatrix}$，再乘上末尾添加的两个 $1$，可以计算出

$$
T_E=\begin{bmatrix}
1 & 1\\
1 & 0
\end{bmatrix}\times
\begin{bmatrix}
1 & 1\\
1 & 0
\end{bmatrix}\times
\begin{bmatrix}
1 & -1\\
0 & 1
\end{bmatrix}=
\begin{bmatrix}
2 & -1\\
1 & 0
\end{bmatrix}
$$

这样我们就可以完全地用矩阵乘法来表示题目中的操作了。于是对操作序列的修改就转化成了 DS 问题：插入矩阵，区间反转，区间翻转，注意反转指 $T_W\leftarrow T_E$，$T_E\leftarrow T_W$。我们当然考虑用平衡树维护（作者使用了 FHQ Treap），但矩阵乘法不满足交换律。怎么解决？这里有一个很典的 trick：维护不满足交换律的信息时，把交换后的结果也存起来。更具体地，对于本题，我们在节点上维护区间矩阵连乘积、区间反转矩阵连乘积、区间翻转矩阵连乘积、区间反转且翻转矩阵连乘积，在给节点打标记更改状态时，对应 swap 这些值即可。可以参考代码实现。

## 代码

这里给出 FHQ Treap 部分的代码，未经卡常即可通过本题。

```cpp
struct Treap {
#define ls(p) (nodes[p].ls)
#define rs(p) (nodes[p].rs)
	int rt, tot;
	struct Node {
		int ls, rs, sz, rd;
		Mat val[2][2], mat[2];
		bool tg_rev, tg_flip;
	} nodes[N];
	inline void init() {
		rt = tot = 0;
		nodes[0].mat[0] = nodes[0].mat[1] = id;
		nodes[0].val[0][0] = nodes[0].val[0][1] = nodes[0].val[1][0] = nodes[0].val[1][1] = id;
	}
	inline void push_up(int p) {
		nodes[p].sz = nodes[ls(p)].sz + nodes[rs(p)].sz + 1;
		nodes[p].val[0][0] = nodes[ls(p)].val[0][0] * nodes[p].mat[0] * nodes[rs(p)].val[0][0];
		nodes[p].val[0][1] = nodes[ls(p)].val[0][1] * nodes[p].mat[1] * nodes[rs(p)].val[0][1];
		nodes[p].val[1][0] = nodes[rs(p)].val[1][0] * nodes[p].mat[0] * nodes[ls(p)].val[1][0];
		nodes[p].val[1][1] = nodes[rs(p)].val[1][1] * nodes[p].mat[1] * nodes[ls(p)].val[1][1];
	}
	inline void make_rev(int p) {
		swap(ls(p), rs(p));
		swap(nodes[p].val[0][0], nodes[p].val[1][0]), swap(nodes[p].val[0][1], nodes[p].val[1][1]);
		nodes[p].tg_rev ^= 1;
	}
	inline void make_flip(int p) {
		swap(nodes[p].mat[0], nodes[p].mat[1]);
		swap(nodes[p].val[0][0], nodes[p].val[0][1]), swap(nodes[p].val[1][0], nodes[p].val[1][1]);
		nodes[p].tg_flip ^= 1;
	}
	inline void push_down(int p) {
		if (nodes[p].tg_rev) make_rev(ls(p)), make_rev(rs(p)), nodes[p].tg_rev = 0;
		if (nodes[p].tg_flip) make_flip(ls(p)), make_flip(rs(p)), nodes[p].tg_flip = 0;
	}
	inline int create(Mat v1, Mat v2) {
		int x = ++tot;
		nodes[x].mat[0] = nodes[x].val[0][0] = nodes[x].val[1][0] = v1;
		nodes[x].mat[1] = nodes[x].val[0][1] = nodes[x].val[1][1] = v2;
		return nodes[x].sz = 1, nodes[x].rd = gen(), x;
	}
	inline void split(int p, int v, int &x, int &y) {
		if (!p) return x = y = 0, void();
		push_down(p);
		if (nodes[ls(p)].sz >= v) split(ls(p), v, x, ls(y = p));
		else split(rs(p), v - nodes[ls(p)].sz - 1, rs(x = p), y);
		push_up(p);
	}
	inline int merge(int x, int y) {
		if (!x || !y) return x | y;
		push_down(x), push_down(y);
		if (nodes[x].rd > nodes[y].rd) return rs(x) = merge(rs(x), y), push_up(x), x;
		return ls(y) = merge(x, ls(y)), push_up(y), y;
	}
	inline void ins(Mat v1, Mat v2) { rt = merge(rt, create(v1, v2)); }
	inline void rev(int l, int r) {
		int x, y, z; split(rt, r, x, z), split(x, l - 1, x, y);
		make_rev(y), rt = merge(merge(x, y), z);
	}
	inline void flip(int l, int r) {
		int x, y, z; split(rt, r, x, z), split(x, l - 1, x, y);
		make_flip(y), rt = merge(merge(x, y), z);
	}
#undef ls
#undef rs
} t;
```

---

## 作者：Purslane (赞：1)

# Solution

这种题可以放 NOIP T3 的，不知为啥是黑题。

考虑每个 `E` 和 `W` 的连续段，假设长度为 $len$，显然会对应一个 $len$ 的 $a_i$。

不过开头如果没有 `E`，强制增加一个 $a=0$；末尾的 `W` 会对应 $len+1$ 的 $a_i$，如果不存在强制增加一个 $a=1$。

考虑使用矩阵维护后缀连分数的变化（对，就是这个题和数论没有任何关系）。使用平衡树维护即可。细节略，过于简单，复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,MOD=998244353;
//col=0 表示 E,col=1 表示 W 
int n,q,tot,rt;
struct MAT {int v[2][2];}uni;
inline MAT gain(const int v) {MAT ans;return ans.v[1][0]=ans.v[0][1]=1,ans.v[0][0]=v,ans.v[1][1]=0,ans;}
inline MAT operator *(const MAT A,const MAT B) {
	MAT res;
	res.v[0][0]=(A.v[0][0]*B.v[0][0]+A.v[0][1]*B.v[1][0])%MOD,
	res.v[0][1]=(A.v[0][0]*B.v[0][1]+A.v[0][1]*B.v[1][1])%MOD,
	res.v[1][0]=(A.v[1][0]*B.v[0][0]+A.v[1][1]*B.v[1][0])%MOD,
	res.v[1][1]=(A.v[1][0]*B.v[0][1]+A.v[1][1]*B.v[1][1])%MOD;
	return res;
}
struct INFO {int lcol,rcol,llen,rlen,sze;MAT ot1,ot2;};
inline INFO operator +(const INFO A,const INFO B) {
	if(A.sze==A.rlen&&B.sze==B.llen) {
		if(A.rcol==B.lcol) return {A.lcol,A.lcol,A.sze+B.sze,A.sze+B.sze,A.sze+B.sze,uni,uni};
		return {A.lcol,B.rcol,A.llen,B.rlen,A.sze+B.sze,uni,uni};
	}
	INFO res;
	res.lcol=A.lcol,res.llen=A.llen,res.rcol=B.rcol,res.rlen=B.rlen,res.sze=A.sze+B.sze;
	if(A.rcol==B.lcol) {
		if(A.rlen==A.sze) res.llen=A.sze+B.llen,res.ot1=B.ot1,res.ot2=B.ot2;
		else if(B.llen==B.sze) res.rlen=A.rlen+B.sze,res.ot1=A.ot1,res.ot2=A.ot2;
		else {
			int len=A.rlen+B.llen;
			res.ot1=A.ot1*gain(len)*B.ot1;
			res.ot2=B.ot2*gain(len)*A.ot2;
		}
		return res;
	}
	res.ot1=A.ot1;
	if(A.sze!=A.rlen) res.ot1=res.ot1*gain(A.rlen);
	if(B.sze!=B.llen) res.ot1=res.ot1*gain(B.llen);
	res.ot1=res.ot1*B.ot1;
	
	res.ot2=B.ot2;
	if(B.sze!=B.llen) res.ot2=res.ot2*gain(B.llen);
	if(A.sze!=A.rlen) res.ot2=res.ot2*gain(A.rlen);
	res.ot2=res.ot2*A.ot2;
	return res;
}
struct TAG {int flp,rev;};
inline TAG operator +(TAG A,const TAG B) {return A.flp^=B.flp,A.rev^=B.rev,A;}
inline INFO operator +(INFO A,const TAG B) {
	if(B.rev) swap(A.lcol,A.rcol),swap(A.llen,A.rlen),swap(A.ot1,A.ot2);
	if(B.flp) A.lcol^=1,A.rcol^=1;
	return A;
}
struct Node {int ls,rs,sze,col,key;TAG tag;INFO t;}t[MAXN];
void assign(int k,TAG tag) {
	t[k].tag=t[k].tag+tag,t[k].t=t[k].t+tag;
	if(tag.rev) swap(t[k].ls,t[k].rs);
	if(tag.flp) t[k].col^=1;
	return ;
}
void push_down(int k) {
	if(t[k].ls) assign(t[k].ls,t[k].tag);
	if(t[k].rs) assign(t[k].rs,t[k].tag);
	return t[k].tag={0,0},void();
}
INFO Gain(int col) {
	INFO res;
	res.lcol=res.rcol=col,res.llen=res.rlen=res.sze=1,res.ot1=res.ot2=uni;
	return res;
}
void push_up(int u) {
	t[u].sze=t[t[u].ls].sze+t[t[u].rs].sze+1;
	if(t[u].ls&&t[u].rs) t[u].t=t[t[u].ls].t+Gain(t[u].col)+t[t[u].rs].t;
	else if(t[u].ls) t[u].t=t[t[u].ls].t+Gain(t[u].col);
	else if(t[u].rs) t[u].t=Gain(t[u].col)+t[t[u].rs].t;
	else t[u].t=Gain(t[u].col);
	return ;
}
void split(int u,int s,int& p,int& q) {
	if(!u) return p=q=0,void();
	push_down(u);
	if(s<=t[t[u].ls].sze) return q=u,split(t[u].ls,s,p,t[u].ls),push_up(u),void();
	return p=u,split(t[u].rs,s-t[t[u].ls].sze-1,t[u].rs,q),push_up(u),void();
}
int merge(int u,int v) {
	if(!u||!v) return u|v;
	push_down(u),push_down(v);
	if(t[u].key<=t[v].key) return t[u].rs=merge(t[u].rs,v),push_up(u),u;
	return t[v].ls=merge(u,t[v].ls),push_up(v),v;
}
mt19937 myrand(time(NULL));
pair<int,int> calc(void) {
	if(!rt) return {1,1};
	MAT fin=uni;
	if(t[rt].t.llen==t[rt].t.sze) {
		int fval=0,sval=1;
		if(t[rt].t.lcol==0) fval+=t[rt].t.sze;
		else sval+=t[rt].t.sze;
		return {(fval*sval+1)%MOD,sval};
	}
	if(t[rt].t.lcol==0) fin=fin*gain(t[rt].t.llen);
	else fin=fin*gain(0)*gain(t[rt].t.llen);
	fin=fin*t[rt].t.ot1;
	if(t[rt].t.rcol==0) fin=fin*gain(t[rt].t.rlen)*gain(1);
	else fin=fin*gain(t[rt].t.rlen+1);
	MAT mul;
	mul.v[0][0]=1,mul.v[1][0]=0,mul=fin*mul;
	return {mul.v[0][0],mul.v[1][0]};
}
void insert(char ch) {
	int col;
	if(ch=='E') col=0;
	else col=1;
	++tot,t[tot].sze=1,t[tot].col=col,t[tot].t=Gain(col),t[tot].key=myrand();
	rt=merge(rt,tot);
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	uni.v[0][0]=uni.v[1][1]=1;
	string S;
	cin>>S;
	for(auto ch:S) insert(ch);
	auto pr=calc();
	cout<<(pr.first%MOD+MOD)%MOD<<' '<<(pr.second%MOD+MOD)%MOD<<'\n';
	ffor(i,1,q) {
		string op;
		cin>>op;
		if(op=="APPEND") {
			char ch;
			cin>>ch,insert(ch);
		}
		else if(op=="FLIP") {
			int l,r,A,B,C;
			cin>>l>>r;
			split(rt,r,A,C),split(A,l-1,A,B);
			assign(B,{1,0});	
			rt=merge(merge(A,B),C); 
		}
		else {
			int l,r,A,B,C;
			cin>>l>>r;
			split(rt,r,A,C),split(A,l-1,A,B);
			assign(B,{0,1});	
			rt=merge(merge(A,B),C); 
		}
		auto pr=calc();
		cout<<(pr.first%MOD+MOD)%MOD<<' '<<(pr.second%MOD+MOD)%MOD<<'\n';
	}
	return 0;
}
```

---

## 作者：Iniaugoty (赞：1)

纪念一下第一道全程独立切掉的黑题 & 第一篇黑题题解。

注意到 $f (a _ {0}, \dots, a _ {k - 1}, a _ {k}) = a _ 0 + \dfrac {1} {a _ 1 + \dfrac {1} {a _ 2 + \dfrac {1} {\dots}}}$。

这是不好搞的，如果你知道了 $f (a _ {0}, \dots, a _ {i})$ 和 $f (a _ {i + 1}, \dots, a _ {k})$ 却求不出 $f (a _ {0}, \dots, a _ {k})$。

继续观察这个东西，它貌似是形如一堆 $a + \dfrac {1} {\left( \dfrac {b} {c} \right)} = \dfrac {ab + c} {b}$ 组成的。不难发现若 $\gcd (b, c) = 1$ 则 $\gcd (ab + c, b) = 1$，也就是说分子分母始终互质，那么这两个东西其实是分开的。

这长得有点像什么奇怪的线性变换啊，而且如果它也能像线性变换那样，~~那真的是泰裤辣~~，可以结合，就好搞了。考虑一个表示 $\dfrac {x} {y}$ 的向量 $\begin {bmatrix} x & y \end {bmatrix}$ 从 $a _ 0$ 扫到 $a _ k$，每次都做一个线性变换。$\dfrac {x} {y} \to a _ {i} + \dfrac {y} {x} = \dfrac {a _ {i} x + y} {x}$，不难构造一个矩阵 $\begin {bmatrix} x & y \end {bmatrix} \begin {bmatrix} a _ i &1 \\ 1 & 0 \end {bmatrix} = \begin {bmatrix} a _ i x + y & x \end {bmatrix}$。

那么 $f (a _ {0}, \dots, a _ {k - 1}, a _ {k})$ 的分子和分母，就是 $\begin {bmatrix} a _ {0} & 1 \end {bmatrix} \displaystyle \prod _ {i = 1} ^ {k} \begin {bmatrix} a _ {i} & 1 \\ 1 & 0 \end {bmatrix}$ 的两个数字。这还不够优美。不难发现这个即 $\displaystyle \prod _ {i = 0} ^ {k} \begin {bmatrix} a _ {i} & 1 \\ 1 & 0 \end {bmatrix}$ 左列两个数字。

显然初始系列里有两个矩阵 $\begin {bmatrix} 0 & 1 \\ 1 & 0 \end {bmatrix}$ 和 $\begin {bmatrix} 1 & 1 \\ 1 & 0 \end {bmatrix}$。接下来，试着以在序列末尾添加矩阵的方式来实现 `W` 和 `E` 两种操作。

- `W` 操作：构造 $S$ 使得 $\begin {bmatrix} a _ {k} & 1 \\ 1 & 0 \end {bmatrix} \times S = \begin {bmatrix} a _ {k} + 1 & 1 \\ 1 & 0 \end {bmatrix}$。不难得到 $S = \begin {bmatrix} 1 & 0 \\ 1 & 1 \end {bmatrix}$。

- `E` 操作：首先猜测两种情况下得到的矩阵是相同的。当 $a _ {k} = 1$ 时，构造 $S$ 使得 $\begin {bmatrix} a _ {k - 1} & 1 \\ 1 & 0 \end {bmatrix} \begin {bmatrix} a _ {k} (= 1) & 1 \\ 1 & 0 \end {bmatrix} \times S = \begin {bmatrix} a _ {k - 1} + 1 & 1 \\ 1 & 0 \end {bmatrix} \begin {bmatrix} a _ {k} (= 1) & 1 \\ 1 & 0 \end {bmatrix}$；否则，构造 $T$ 使得 $\begin {bmatrix} a _ {k} & 1 \\ 1 & 0 \end {bmatrix} \times T = \begin {bmatrix} a _ {k} - 1 & 1 \\ 1 & 0 \end {bmatrix} \begin {bmatrix} 1 & 1 \\ 1 & 0 \end {bmatrix} \begin {bmatrix} 1 & 1 \\ 1 & 0 \end {bmatrix}$。不难得到 $S = T = \begin {bmatrix} 2 & 1 \\ -1 & 0 \end {bmatrix}$。

那么做法很显而易见了。

`W` 和 `E` 的操作序列相当于一个矩阵序列，答案是这些矩阵的积，再**左**乘$\begin {bmatrix} 0 & 1 \\ 1 & 0 \end {bmatrix} \begin {bmatrix} 1 & 1 \\ 1 & 0 \end {bmatrix}$。由于有区间翻转考虑用文艺平衡树维护：

- `APPEND`：直接在平衡树最后插一个对应的矩阵。

- `FLIP`：考虑对于每一个结点，多维护一个与自身矩阵相反的矩阵，除了子树积外多维护一个子树取反积。进行这个修改时，打上懒标记并将它们交换即可。

- `REVERSE`：矩阵乘法不具有交换律，考虑对于每一个结点，除子树积外多维护翻转后的子树积，除子树取反积外多维护翻转后的子树取反积，修改时同样打上懒标记并交换。

需要注意的是，一般文艺平衡树操作中需要最左和最右两个表示极值的结点，为了避免对答案的影响，将他们的矩阵设为单位矩阵 $\begin {bmatrix} 1 & 0 \\ 0 & 1 \end {bmatrix}$。同理，$0$ 号结点也要设成是单位矩阵。

PS：最初我还乘了一个 $\begin {bmatrix} 1 & 0 \\ 0 & 0 \end {bmatrix}$，这可以清空右列两个数字，但实际上毫无必要。

实现不难，但是注意[一时不好好取模一时爽](/record/140995358)，[一直不好好取模一直爽](/record/140995481)。除此以外我几乎是一遍就过了。

双手奉上代码。虽然刚学会 FHQ-Treap 但我还是觉得 Splay 写起来更舒服一些/kk。

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = a; i <= (b); ++i)
#define dF(i, a, b) for(int i = a; i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 2e5 + 5;
const int mod = 998244353;

struct matrix { int s[2][2]; } I, W, E, st;
bool operator == (matrix a, matrix b) {
	F(i, 0, 1) F(j, 0, 1)
		if (a.s[i][j] != b.s[i][j])
			return 0;
	return 1;
}
matrix _(matrix k) { return k == I ? I : (k == W ? E : W); }
matrix operator * (matrix a, matrix b) {
	matrix res = {0, 0, 0, 0};
	F(i, 0, 1) F(j, 0, 1) F(k, 0, 1) {
		res.s[i][k] += (LL) a.s[i][j] * b.s[j][k] % mod;
		res.s[i][k] %= mod;
		if (res.s[i][k] < 0) res.s[i][k] += mod;
	}
	return res;
}

int tot, rt;
struct node {
	int s[2], fa, siz;
	bool tag, rev;
	matrix val, val_;
	matrix sum, sum_;
	matrix dsum, dsum_;
} t[N];
void Newnode(int &u, matrix k) {
	t[u = ++tot].siz = 1,
	t[u].val = t[u].sum = t[u].dsum = k,
	t[u].val_ = t[u].sum_ = t[u].dsum_ = _(k);
	return ;
}
void Connect(int u, int f, int w) { t[u].fa = f, t[f].s[w] = u; }
int Ident(int u, int f) { return t[f].s[1] == u; }
void Pushup(int u) {
	t[u].siz = t[t[u].s[0]].siz + 1 + t[t[u].s[1]].siz,
	t[u].sum = t[t[u].s[0]].sum * t[u].val * t[t[u].s[1]].sum,
	t[u].sum_ = t[t[u].s[0]].sum_ * t[u].val_ * t[t[u].s[1]].sum_,
	t[u].dsum = t[t[u].s[1]].dsum * t[u].val * t[t[u].s[0]].dsum,
	t[u].dsum_ = t[t[u].s[1]].dsum_ * t[u].val_ * t[t[u].s[0]].dsum_;
	return ;
}
void Maketag(int u, bool tp) {
	if (!u) return ;
	if (!tp)
		swap(t[u].val, t[u].val_),
		swap(t[u].sum, t[u].sum_),
		swap(t[u].dsum, t[u].dsum_),
		t[u].tag ^= 1;
	else
		swap(t[u].s[0], t[u].s[1]),
		swap(t[u].sum, t[u].dsum),
		swap(t[u].sum_, t[u].dsum_),
		t[u].rev ^= 1;
	return ;
}
void Pushdown(int u) {
	if (t[u].tag)
		Maketag(t[u].s[0], 0),
		Maketag(t[u].s[1], 0),
		t[u].tag = 0;
	if (t[u].rev)
		Maketag(t[u].s[0], 1),
		Maketag(t[u].s[1], 1),
		t[u].rev = 0;
	return ;
}
void Rotate(int u) {
	int v = t[u].fa, f = t[v].fa;
	int w = Ident(u, v);
	Connect(t[u].s[w ^ 1], v, w);
	Connect(u, f, Ident(v, f));
	Connect(v, u, w ^ 1);
	Pushup(v), Pushup(u);
	return ;
}
void Splay(int u, int tp) {
	if (!tp) rt = u;
	while (t[u].fa != tp) {
		int v = t[u].fa, f = t[v].fa;
		if (f != tp) Rotate(Ident(u, v) ^ Ident(v, f) ? u : v);
		Rotate(u);
	}
	return ;
}
int Query(int k) {
	int u = rt;
	while (u) {
		Pushdown(u);
		if (k == t[t[u].s[0]].siz + 1) { Splay(u, 0); break; }
		else if (k <= t[t[u].s[0]].siz) u = t[u].s[0];
		else k -= t[t[u].s[0]].siz + 1, u = t[u].s[1];
	}
	return u;
}
void Split(int l, int r) {
	int u = Query(l), v = Query(r + 2);
	Splay(u, 0), Splay(v, u);
	return ;
}
void Insert(int x, matrix k) {
	Split(x + 1, x);
	int u; Newnode(u, k);
	Connect(u, t[rt].s[1], 0);
	Pushup(t[rt].s[1]), Pushup(rt);
	return ;
}
void Update(int l, int r, bool tp) {
	Split(l, r);
	Maketag(t[t[rt].s[1]].s[0], tp);
	Pushup(t[rt].s[1]), Pushup(rt);
	return ;
}

int n, q; char c[N];
void Build(int l, int r, int &u, int f, int s) {
	int mid = l + r >> 1;
	matrix w = (c[mid] == 'I' ? I : (c[mid] == 'W' ? W : E));
	Newnode(u, w), Connect(u, f, s);
	if (l < mid) Build(l, mid - 1, t[u].s[0], u, 0);
	if (mid < r) Build(mid + 1, r, t[u].s[1], u, 1);
	Pushup(u);
	return ;
}

int main() {
 	freopen("wmyr.in", "r", stdin);
 	freopen("wmyr.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
	I = {1, 0, 0, 1}, W = {1, 0, 1, 1}, E = {2, 1, -1, 0};
	st = (matrix) {0, 1, 1, 0} * (matrix) {1, 1, 1, 0};
	t[0].val = t[0].sum = t[0].dsum = I;
	t[0].val_ = t[0].sum_ = t[0].dsum_ = I;
	cin >> n >> q;
	c[0] = c[n + 1] = 'I';
	F(i, 1, n) cin >> c[i];
	Build(0, n + 1, rt, 0, 0);
	matrix ans = st * t[rt].sum;
	cout << ans.s[0][0] << " " << ans.s[1][0] << "\n";
	while (q--) {
		string op;
		int l, r; char ch;
		cin >> op;
		if (op == "APPEND") cin >> ch, Insert(n++, ch == 'W' ? W : E);
		else if (op == "FLIP") cin >> l >> r, Update(l, r, 0);
		else if (op == "REVERSE") cin >> l >> r, Update(l, r, 1);
		ans = st * t[rt].sum;
		cout << ans.s[0][0] << " " << ans.s[1][0] << "\n";
	}
	return 0;
}
```

另外的话，文中一些“不难得到”的推导建议读者自行推一遍，而非直接使用本文给出的结论，~~笔者利用数学课时间推式子被数学老师罚站了。~~

---

## 作者：RainWetPeopleStart (赞：0)

首先，尝试分析原问题的性质，发现 $f(a_0,a_1,\dots,a_k)=f(a_0,f(a_1,a_2,a_3,\dots,a_k))$。

对于这一类问题，一个思路是扫描线，维护整体 $f$ 的变化，不过这个没有前途。

我们不妨考虑最外面的 $f$ 对里面的 $f$ 值的影响，记 $f(a_1,a_2,\dots,a_k)=\frac{a}{b}$，则最终的 $f$ 值为 $\frac{b+a_0a}{a}$，可以看作先交换 $a,b$ 然后加 $a_0$。

发现刚刚的操作是关于 $a,b$ 的线性变换，考虑用矩阵的形式表示。

用向量 $\begin{bmatrix}a & b\end{bmatrix}$ 表示 $a,b$，交换 $a,b$ 可以用矩阵 $\begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}$ 表示，给 $\dfrac{a}{b}$ 加一可以用矩阵 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}$ 表示。

对于加 $a_0$ 而言，可以拆成若干加一。

这样就可以算答案了，用矩阵表示出 $a$ 序列，然后从后往前乘到 $\begin{bmatrix}0 & 1\end{bmatrix}$（$a,b$ 的初始值）上即可。

考虑单个 `W` 的影响，相当于加入一个“加一”，即左乘矩阵 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}$。

考虑单个 `E` 的影响，分两种情况考虑。

- 如果 $a$ 的最后一项为 $1$，则可以认为是先删掉最后一个元素，最后加进去，即先左乘 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\times \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}$ 的逆，再左乘 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}$ 最后左乘上 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\times \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}$ 即可，最后算出是左乘 $\begin{bmatrix}0 & 1\\-1 & 2\end{bmatrix}$。

- 否则，可以认为是先左乘“加一”矩阵的逆 $\begin{bmatrix}1 & 0\\-1 & 1\end{bmatrix}$，然后左乘两个 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\times \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}$，最后算出来也是 $\begin{bmatrix}0 & 1\\-1 & 2\end{bmatrix}$。

由上文，我们成功的用矩阵表示出了 `W` 和 `E` 的影响，修改只需使用平衡树维护即可。

一些细节：

- 你可能需要维护两个 $0/1$ 表示翻转和反转之后的矩阵。

- 可以把初始矩阵 $\begin{bmatrix}1 & 0\\1 & 1\end{bmatrix}\times \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}$ 和最后用矩阵形式维护的向量 $\begin{bmatrix}0 & 1\\0 & 0\end{bmatrix}$ 当哨兵元素。

---

## 作者：baka24 (赞：0)

有一个范浩强完全不用卡常的小常数做法。

考虑转化题目中给定的两个东西。

先考虑 `E` 和 `W` 相当于什么。

考虑一个 `E` 的连续段，第一个 `E` 会在序列后面接上两个 $1$。之后每个 `E` 都会让第一个数加一，直到出现了一个 `W` 操作，此时第二个数不是 $1$ 了，那么第一个数就肯定不会变化了。

就是说，操作后产生的第一个数的值相当于 `E` 连续段的大小。

考虑一个 `W` 的连续段，第一个 `W` 会把序列最后一项加一，但是随后出现的 `W` 操作还会将这个数减一，而这个数初始是 $1$，那么最终它会变成 `W` 连续段的大小。

但是注意这里的讨论只对序列中间部分有效。对于第一个字符，如果它是 `E`，就没有影响，如果它是 `W`，生成的序列最前方会有一个 $0$。

而在序列最后，如果最后一个字符是 `E`，那么序列最后还会有一个 $1$，如果是 `W`，这个 `W` 对应的数没有被 `E` 减一，所以这个数的值为 `W` 连续段长度加一。

那么现在最终生成的序列被转化成了 `E` 和 `W` 的连续段长度，之后考虑这个权值怎么处理。

考虑一个分数 $\frac{x}{y}$，在遇到一个 $p$ 后它会变成 $\frac{x+yp}{y}$。用矩阵维护这个操作，即：

$$
\begin{bmatrix} x & y \end{bmatrix}  \begin{bmatrix} p & 1 \\ 1 & 0 \end{bmatrix} = \begin{bmatrix} x+yp & x \end{bmatrix}
$$

现在就有了快速计算答案的方法。

那么用平衡树维护区间矩阵乘积。

需要维护颜色连续段大小所代表的矩阵，用一个节点代表一个连续段，在 `FLIP` 和 `REVERSE` 时维护一下分裂节点和合并节点即可，节点对应的颜色是很好通过计算维护的。

这个做法优点在于平衡树节点数量是颜色连续段数量，在颜色段较大时节点数很少，在颜色段较小时，占用常数最大的颜色段合并基本不会触发。

同时关于矩阵操作部分也可以剩下一部分常数，因为矩阵只与颜色段长度有关，所以 `FLIP` 操作不会影响中间部分矩阵的形态。只需维护原矩阵和 `REVERSE` 之后的矩阵即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lson t[now].ls
#define rson t[now].rs
#define ll long long 
#define pii pair<int,int>
#define fr first
#define sc second
#define mk make_pair
#define inx(u) int I=h[(u)],v=edge[I].v,w=edge[I].w;I;I=edge[I].nx,v=edge[I].v,w=edge[I].w
int read(){int x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();return x*f;}
const int MAXN=500010,inf=1e18,Mod=998244353;
inline void add(int &x,int y){x+=y;if(x>=Mod)x-=Mod;}int Add(int x,int y){return x+y>=Mod?x+y-Mod:x+y;}
int n,q;
char c[MAXN];
struct matrix{
    ll p[2][2];
    int x,y;
    matrix operator*(const matrix&G)const{
        matrix res;
        res.x=x,res.y=G.y;
        if(x==2){
            res.p[0][0]=Add(p[0][0]*G.p[0][0]%Mod,p[0][1]*G.p[1][0]%Mod);
            res.p[0][1]=Add(p[0][0]*G.p[0][1]%Mod,p[0][1]*G.p[1][1]%Mod);
            res.p[1][0]=Add(p[1][0]*G.p[0][0]%Mod,p[1][1]*G.p[1][0]%Mod);
            res.p[1][1]=Add(p[1][0]*G.p[0][1]%Mod,p[1][1]*G.p[1][1]%Mod);
        }
        else{
            res.p[0][0]=Add(p[0][0]*G.p[0][0]%Mod,p[0][1]*G.p[1][0]%Mod);
            res.p[0][1]=Add(p[0][0]*G.p[0][1]%Mod,p[0][1]*G.p[1][1]%Mod);
        }
        return res;
    }
}M[MAXN],A,Z;
struct node{
    int pri,val,sz,siz,lz,ls,rs;
    matrix x,y;
}t[MAXN];
int cnt;
mt19937 rng(4);
int nnd(int x){
    t[++cnt]={(int)rng(),x,x,1,0,0,0,M[x],M[x]};
    return cnt;
}
void pushup(int now){
    if(!now)return;
    t[now].sz=t[rson].sz+t[lson].sz+t[now].val;
    t[now].siz=t[rson].siz+t[lson].siz+1;
    t[now].x=t[rson].x*M[t[now].val]*t[lson].x;
    t[now].y=t[lson].y*M[t[now].val]*t[rson].y;
}
void upd(int now){
    if(!now)return;
    swap(t[now].ls,t[now].rs);
    swap(t[now].x,t[now].y);
    t[now].lz^=1;
}
void pushdown(int now){if(t[now].lz)upd(lson),upd(rson),t[now].lz=0;}
int mrge(int x,int y){
    if(!x||!y)return x|y;
    pushdown(x),pushdown(y);
    if(t[x].pri<t[y].pri){
        int tmp=mrge(t[x].rs,y);
        t[x].rs=tmp;
        pushup(x);
        return x;
    }
    else{
        int tmp=mrge(x,t[y].ls);
        t[y].ls=tmp;
        pushup(y);
        return y;
    }
}
pii splt(int now,int key){
    int nd=nnd(t[now].val-key);
    t[nd].rs=rson;
    rson=0; 
    t[now].val=key;
    pushup(now),pushup(nd);
    return mk(now,nd);
}
pii getfr(int now){
    pushdown(now);
    if(lson){
        pii tmp=getfr(lson);
        lson=tmp.sc;
        pushup(now);
        return mk(tmp.fr,now);
    }
    else{
        int tmp=rson;
        rson=0;
        pushup(now);
        pushdown(tmp);
        return mk(now,tmp);
    }
}
pii geted(int now){
    pushdown(now);
    if(rson){
        pii tmp=geted(rson);
        rson=tmp.fr;
        pushup(now);
        return mk(now,tmp.sc);
    }
    else{
        int tmp=lson;
        lson=0;
        pushup(now);
        pushdown(tmp);
        return mk(tmp,now);
    }
}
pii split(int now,int key){
    if(!now)return mk(0,0);
    pushdown(now);
    if(t[lson].sz>=key){
        pii tmp=split(lson,key);
        lson=tmp.sc;
        pushup(now);
        return mk(tmp.fr,now);
    }
    if(t[lson].sz+t[now].val<=key){
        pii tmp=split(rson,key-t[lson].sz-t[now].val);
        rson=tmp.fr;
        pushup(now);
        return mk(now,tmp.sc);
    }
    key-=t[lson].sz;
    pii tmp=splt(now,key);
    return tmp;
}
bool col;
int rt;
void insert(int x){
    if(!cnt){
        col=x;
        rt=nnd(1);
        return;
    }
    if((t[rt].siz&1^1^col)==x){
        pii tmp=geted(rt);
        t[tmp.sc].val++;
        pushup(tmp.sc);
        rt=mrge(tmp.fr,tmp.sc);
    }
    else rt=mrge(rt,nnd(1));
}
void flip(int l,int r){
    int ed=t[rt].siz&1^col^1;
    pii x=split(rt,r);
    int rc=col^t[x.fr].siz&1^1,pr=ed^t[x.sc].siz&1^1;
    pii y=split(x.fr,l-1);
    int lc=rc^t[y.sc].siz&1^1,pl=col^t[y.fr].siz&1^1;
    lc^=1,rc^=1;
    if(y.fr&&pl==lc){
        pii L=geted(y.fr);
        pii tmp=getfr(y.sc);
        t[tmp.fr].val+=t[L.sc].val;
        pushup(tmp.fr);
        y.sc=mrge(tmp.fr,tmp.sc);
        y.fr=L.fr;
    }
    if(!y.fr)col=lc;
    if(x.sc&&pr==rc){
        pii R=getfr(x.sc);
        pii tmp=geted(y.sc);
        t[tmp.sc].val+=t[R.fr].val;
        pushup(tmp.sc);
        y.sc=mrge(tmp.fr,tmp.sc);
        x.sc=R.sc;
    }
    rt=mrge(y.fr,mrge(y.sc,x.sc));
}
void reverse(int l,int r){
    int ed=t[rt].siz&1^col^1;
    pii x=split(rt,r);
    int rc=col^t[x.fr].siz&1^1,pr=ed^t[x.sc].siz&1^1;
    pii y=split(x.fr,l-1);
    int lc=rc^t[y.sc].siz&1^1,pl=col^t[y.fr].siz&1^1;
    upd(y.sc);
    if(y.fr&&pl==rc){
        pii L=geted(y.fr);
        pii tmp=getfr(y.sc);
        t[tmp.fr].val+=t[L.sc].val;
        pushup(tmp.fr);
        y.sc=mrge(tmp.fr,tmp.sc);
        y.fr=L.fr;
    }
    if(!y.fr)col=rc;
    if(x.sc&&pr==lc){
        pii R=getfr(x.sc);
        pii tmp=geted(y.sc);
        t[tmp.sc].val+=t[R.fr].val;
        pushup(tmp.sc);
        y.sc=mrge(tmp.fr,tmp.sc);
        x.sc=R.sc;
    }
    rt=mrge(y.fr,mrge(y.sc,x.sc));
}
matrix qry(){
    matrix res=A;
    if((t[rt].siz&1^1^col))res=res*M[1]*t[rt].x;
    else{
        pii tmp=geted(rt);
        res=res*M[t[tmp.sc].val+1]*t[tmp.fr].x;
        rt=mrge(tmp.fr,tmp.sc);
    }
    if(!col)res=res*M[0];
    return res;
}
void slv(){
    n=read(),q=read();
    A.p[0][0]=1,A.p[0][1]=0;A.x=1,A.y=2;
    M[0].p[1][0]=M[0].p[0][1]=1,M[0].x=M[0].y=2;
    Z.p[0][0]=Z.p[1][1]=1;Z.x=Z.y=2;
    t[0].x=t[0].y=Z;
    for(int i=1;i<=n+q;i++)M[i].p[0][1]=M[i].p[1][0]=1,M[i].p[0][0]=i,M[i].x=M[i].y=2;
    scanf("%s",c+1);
    for(int i=1;i<=n;i++)insert(c[i]=='E');
    matrix ans=qry();
    printf("%lld %lld\n",ans.p[0][0],ans.p[0][1]);
    while(q--){
        char op=getchar();
        while(op!='A'&&op!='F'&&op!='R')op=getchar();
        if(op=='A'){
            while(op!=' ')op=getchar();
            char c=getchar();
            while(c!='W'&&c!='E')c=getchar();
            insert(c=='E');
        }
        if(op=='F'){
            int l=read(),r=read();
            flip(l,r);
        }
        if(op=='R'){
            int l=read(),r=read();
            reverse(l,r);
        }
        matrix ans=qry();
        printf("%lld %lld\n",ans.p[0][0],ans.p[0][1]);
    }
}
signed main(){
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    slv();
    return 0;
}
```

---

## 作者：ZillionX (赞：0)

# Description

给定操作序列 $S$，$S$ 的每个字符为 ```W``` 或 ```E```。

若当前字符为 ```W```，则在数列 $\{a_n\}$ 末尾插入 $1$。

否则，若数列 $\{a_n\}$ 最后一项为 $1$，则给倒数第二项加 $1$；否则先给数列最后一项减 $1$，接着在数列末尾插入两个 $1$。

定义函数 $f(\{a_n\})$ 为：

$$f(a_0,\dots,a_{n-1},a_n)=\begin{cases}a_0, &n=0\\f(a_0,\dots,a_{n-2},a_{n-1}+\frac{1}{a_n}), & n \ge 1\end{cases}$$

你需要支持对操作序列的元素插入、区间取反（将 ```W``` 变为 ```E```）、区间翻转，每次修改后回答 $f(\{a_n\})$ 的值，对 $998244353$ 取模。

$n,q \le 10^5$，时限 2s。

# Solution

观察函数 $f$ 的性质，可以发现答案（的倒数）是这样的形式

$$\dfrac{1}{a_0 + \dfrac{1}{a_1 + \dfrac{1}{a_2+ \cdots}}}$$

考虑将答案从下到上合并成正常分数的形式，则有

$$\dfrac{1}{a_i +\dfrac{x}{y}} = \dfrac{y}{a_iy+x}$$

这里可以发现 $\gcd(y,a_iy+x)=\gcd(y,x)$，由于 $\dfrac{x}{y}$ 已经是合并过的最简分数，因此分数不会被约分，我们计算时可以放心取模。

不妨将分数 $\dfrac{x}{y}$ 写成矩阵 $\begin{bmatrix}x\\y\end{bmatrix}$ 的形式，不难发现上述计算可以看作


$$\begin{bmatrix} 0 &1\\1 &a_i\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}y\\a_i y +x\end{bmatrix}$$

于是我们只需要维护一车矩阵的连乘积就可以得出答案。

接下来观察 ```W``` 和 ```E``` 操作对答案的影响。

```W``` 操作其实就是将 $\begin{bmatrix} 0 &1\\1 &a_n\end{bmatrix}$ 变为 $\begin{bmatrix} 0 &1\\1 &a_n+1\end{bmatrix}$，很容易构造出矩阵 $\begin{bmatrix} 1 &1\\0 &1\end{bmatrix}$ 满足前者乘上它变为后者。

对于 ```E``` 操作，由于要分 $a_n=1$ 和 $a_n>1$ 两种情况，则会复杂很多。

先看 $a_n=1$ 的情况，此时有

$$\begin{bmatrix} 0 &1\\1 &a_{n-1}\end{bmatrix} \begin{bmatrix} 0 &1\\1 &a_n\end{bmatrix}= \begin{bmatrix} 0 &1\\1 &a_{n-1}\end{bmatrix} \begin{bmatrix} 0 &1\\1 &1\end{bmatrix} \rightarrow \begin{bmatrix} 0 &1\\1 &a_{n-1}+1\end{bmatrix} \begin{bmatrix} 0 &1\\1 &1\end{bmatrix}= \begin{bmatrix} 0 &1\\1 &a_{n-1}\end{bmatrix}\begin{bmatrix} 1 &1\\0 &1\end{bmatrix}\begin{bmatrix} 0 &1\\1 &1\end{bmatrix} = \begin{bmatrix} 0 &1\\1 &a_{n-1}\end{bmatrix} \begin{bmatrix} 0 &1\\1 &1\end{bmatrix} \begin{bmatrix} 0 &-1\\1 &2\end{bmatrix}$$

所以此时的操作等价于乘上一个 $\begin{bmatrix} 0 &-1\\1 &2\end{bmatrix}$。

接着我们考察 $a_n>1$ 的情况，可以推导出此时的操作仍然等价于乘上 $\begin{bmatrix} 0 &-1\\1 &2\end{bmatrix}$，具体推导过程留作读者练习。

这个时候题目做法已经变得非常显然，我们用一个支持区间取反、翻转和插入新元素的数据结构维护矩阵连乘积。可以想到用 Splay / 非旋 Treap 来维护。

每个结点记录区间连乘积、取反区间连乘积、翻转区间连乘积、取反翻转区间连乘积即可和对应的 lazy tag 即可。

时间复杂度 $\mathcal O(2^3 n \log n)$。

# Code

题外话：据我校参加 NOI2021 的学长回忆，考场上使用非旋 Treap 的选手无一不被卡成了 70 分，但是我在调试后提交这题就得到了满分，这到底是我的常数太小，还是 CCF 的机子太慢？

```cpp
#define int long long
#define rd() rand()
const int N=2e5+5,mod=998244353;
int n,q;
char s[N];
struct mat {
	int a[3][3];
	mat() {
		memset(a,0,sizeof(a));
	}
	mat(int a1,int b1,int c1,int d1) {
		a[1][1]=a1,a[1][2]=b1,a[2][1]=c1,a[2][2]=d1;
	}
	void clr() {
		for (int i=1;i<=2;i++) a[i][i]=1;
	}
	mat operator*(const mat &r) {
		mat o;
		for (int i=1;i<=2;i++)
			for (int j=1;j<=2;j++)
				for (int k=1;k<=2;k++)
					o.a[i][j]=(o.a[i][j]+a[i][k]*r.a[k][j]%mod)%mod;
		return o;
	}
}w(1,1,0,1),e(0,mod-1,1,2),sr(1,1,0,1),I(1,0,0,1);
int tn;
struct node {
	int s,f,l,r,t1,t2;
	mat v1,v2,s1,s2,s3,s4;
}h[N];
int nd(int fl) {
	tn++;
	if (!fl) h[tn]=(node){1,rd(),0,0,0,0,w,e,w,e,w,e};
	else h[tn]=(node){1,rd(),0,0,0,0,e,w,e,w,e,w};
	return tn;
}
void up(int x) {
	h[x].s=h[h[x].l].s+h[h[x].r].s+1;
	h[x].s1=h[h[x].l].s1*h[x].v1*h[h[x].r].s1;
	h[x].s2=h[h[x].l].s2*h[x].v2*h[h[x].r].s2;
	h[x].s3=h[h[x].r].s3*h[x].v1*h[h[x].l].s3;
	h[x].s4=h[h[x].r].s4*h[x].v2*h[h[x].l].s4;
}
void chg1(int x) {
	swap(h[x].v1,h[x].v2);
	swap(h[x].s1,h[x].s2);
	swap(h[x].s3,h[x].s4);
	h[x].t1^=1;
}
void chg2(int x) {
	swap(h[x].s1,h[x].s3);
	swap(h[x].s2,h[x].s4);
	swap(h[x].l,h[x].r);
	h[x].t2^=1;
}
void dn(int x) {
	if (h[x].t1) chg1(h[x].l),chg1(h[x].r),h[x].t1=0;
	if (h[x].t2) chg2(h[x].l),chg2(h[x].r),h[x].t2=0;
}
void spt(int u,int k,int &x,int &y) {
	if (!u) {
		x=y=0;
		return;
	}
	dn(u);
	if (h[h[u].l].s<k) x=u,spt(h[u].r,k-h[h[u].l].s-1,h[u].r,y);
	else y=u,spt(h[u].l,k,x,h[u].l);
	up(u);
}
int mrg(int x,int y) {
	if (!x || !y) return x|y;
	if (h[x].f<h[y].f) {
		dn(x),h[x].r=mrg(h[x].r,y),up(x);
		return x;
	}
	else {
		dn(y),h[y].l=mrg(x,h[y].l),up(y);
		return y;
	}
}
int rt,a,b,c,d;
void rv(int l,int r,bool fl) {
	spt(rt,l-1,a,b);
	spt(b,r-l+1,b,c);
	if (!fl) chg1(b);
	else chg2(b);
	rt=mrg(a,mrg(b,c));
}
signed main() {
	scanf("%lld%lld%s",&n,&q,s+1);
	h[0]=(node){0,0,0,0,0,0,I,I,I,I,I,I};
	for (int i=1;i<=n;i++) rt=mrg(rt,nd(s[i]=='W'?0:1));
	mat ans=sr*h[rt].s1;
	printf("%lld %lld\n",ans.a[2][2],ans.a[1][2]);
	while (q--) {
		char op[10],dx[5];
		scanf("%s",op);
		if (op[0]=='A') {
			scanf("%s",dx);
			rt=mrg(rt,nd(dx[0]=='W'?0:1));
		}
		else {
			int l,r;
			scanf("%lld%lld",&l,&r);
			if (op[0]=='F') rv(l,r,0);
			else rv(l,r,1);
		}
		mat ans=sr*h[rt].s1;
		printf("%lld %lld\n",ans.a[2][2],ans.a[1][2]);
	}
	return 0;
}
```


---

## 作者：littleKtian (赞：0)

首先我们可以通过类似辗转相除的做法发现整个过程中 $f$ 的最后一个数分子分母必然互质，不需要约分，所以我们完全可以直接计算和取模。

有区间翻转，大概率平衡树。

考虑将 $a$ 序列的最后一个元素单独拿出来，记作 $x$，然后把 $f(a_0,a_1,…,a_k)$ 看做一个和 $x$ 有关的函数，容易归纳证明出 $f(x)$ 一定是 $\dfrac{ax+b}{cx+d}$ 的形式。

显然 `W` 操作就是令代入函数的 $x$ 加上 $1$，但 `E` 操作分两种情况不好搞，所以我们猜测这两种情况可以被归为一种。

先考虑最后一项不为 $1$ 的情况，手动模拟一下可以发现此时 $f(x)=\dfrac{(ax_0+b)x+(ax_0-a+b)}{(cx_0+d)x+(cx_0-c+d)}$（$x_0$ 为原本代入的 $x$ 的值，$a,b,c,d$ 为原来 $f(x)$ 中的对应的系数），同时令代入的 $x=1$。

然后转回来看最后一项为 $1$ 的情况，我们考虑也使用第二种方式，手动模拟一下也可以发现此时结果和代入第一种方式得到的结果是一样的。也就是说我们可以直接使用上面得出的结论。

考虑矩阵维护 $a,ax,b$（另一部分形式类似，这里不再重复），对于 splay 的每个节点维护子树内操作的变换矩阵，由于翻转和反转后的变换矩阵的结果并不好直接从中看出，所以把 翻转/反转/两者都进行 后的变换矩阵也一起维护出即可。

代码太丑就不贴了。

---

## 作者：strcmp (赞：0)

矩阵好题。

这个 $f$ 我们肯定是不能直接暴力计算的，考虑转化一下。

假设到 $a_{k - 1}$ 位置，$k$ 位置之后所得到的结果分数是 $\frac ab$，则新的分数是 $\frac{1}{a_{k - 1} + \frac ab} = \frac{b}{a + a_{k - 1}b}$。即将 $a$ 变成 $b$，$b$ 变成 $a + a_{k - 1}b$，上述两种操作同时进行。最后的答案是结果分数的倒数。注意到 $\gcd(a,\,b) = \gcd(b,\,a + kb)$，所以我们从头到尾分数一直是互质的，不用管分数互质这个条件。

这样很可矩阵描述的样子，不妨设计一个矩阵：

$$
\begin{bmatrix}
x & y\\
z & w\\
\end{bmatrix}
\begin{bmatrix}
a\\
b\\
\end{bmatrix}
=
\begin{bmatrix}
b
\\
a+a_{k-1}b
\end{bmatrix}
$$

联立方程得 $b = xa + yb,\,a + a_{k - 1}b = za + wb$。

有解得：$\begin{cases}x = 0\\y = 1\\z= 1\\w=a_{k-1}\end{cases}$。即矩阵为：
$$
\begin{bmatrix}
0 & 1\\
1 & a_{k - 1}\\
\end{bmatrix}
$$

有了这个矩阵，我们就可以将函数描述为一些矩阵的乘法，对于 $f$，我们有：

$$
f(a_0, \ldots , a_{k - 1}, a_k) = \begin{bmatrix}
0 & 1\\
1 & a_{0}\\
\end{bmatrix}
\begin{bmatrix}
0 & 1\\
1 & a_{1}\\
\end{bmatrix}
\dots
\begin{bmatrix}
0 & 1\\
1 & a_{k}\\
\end{bmatrix}
\begin{bmatrix}
0\\
1\\
\end{bmatrix}
$$

显然我们不可能将 $a$ 序列直接搞出来，那么有什么用呢？

考虑第一类操作，在操作序列之后追加操作 `W`。（初始操作序列可以通过追加操作实现）

在操作序列末尾追加一个 `W`，显然会影响 $a_k$ 使得 $a_k \leftarrow a_k + 1$。

即：

$$
\begin{bmatrix}
0 & 1\\
1 & a_k\\
\end{bmatrix}
\leftarrow
\begin{bmatrix}
0 & 1\\
1 & a_k + 1\\
\end{bmatrix}
$$

依旧是联立方程。

$$
\begin{bmatrix}
0 & 1\\
1 & a_k\\
\end{bmatrix}
\begin{bmatrix}
x & y\\
z & w\\
\end{bmatrix}
=
\begin{bmatrix}
0 & 1\\
1 & a_k + 1\\
\end{bmatrix}
$$

有一个解 $\begin{cases}x = 1\\y = 1\\z= 0\\w=1\end{cases}$。

因此这个操作等价于：

$$
\begin{bmatrix}
0 & 1\\
1 & a_k\\
\end{bmatrix}
\leftarrow
\begin{bmatrix}
0 & 1\\
1 & a_k\\
\end{bmatrix}
\begin{bmatrix}
1 & 1\\
0 & 1\\
\end{bmatrix}
$$

那么在矩阵序列末尾追加一个 $\begin{bmatrix}
1 & 1\\
0 & 1\\
\end{bmatrix}$ 就行了。

对于加入 `E` 操作的情况，不妨考虑 $a_k > 1$ 的情况，先在末尾加入矩阵 $\begin{bmatrix}
1 & -1\\
0 & 1\\
\end{bmatrix}$，代表 $a_k$ 的值减 $1$。接着矩阵序列末尾加上两个 $\begin{bmatrix}
0 & 1\\
1 & 1\\
\end{bmatrix}$ 就行了。

因此在 $a_k > 1$ 的时候，`E` 操作的影响就是在矩阵序列末尾加上 $\begin{bmatrix}
1 & -1\\
0 & 1\\
\end{bmatrix}\begin{bmatrix}
0 & 1\\
1 & 1\\
\end{bmatrix}^2 = \begin{bmatrix}
0 & -1\\
1 & 2\\
\end{bmatrix}$。

大胆猜测 $a_k = 1$ 的时候影响也是等价于矩阵序列末尾加上 $\begin{bmatrix}
0 & -1\\
1 & 2\\
\end{bmatrix}$，可以发现是对的。

于是现在支持的操作都可以使用一棵平衡树来做，维护翻转和反转四种情况下，四个矩阵的乘积，大概是 $32$ 倍的常数，配合 FHQ-Treap 的大常数，理论上需要进行一系列的卡常。~~然而实际上不开 O2 最大点 485ms。~~

时间复杂度 $\Theta(k^3n \log n)$，本题中 $k = 2$，为矩阵的大小。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 4e5 + 10;
constexpr int mod = 998244353;
#define F(i, a, b) for(int i = a; i <= b; i++)
mt19937 rd(1004535809);
struct mat {
    int c11, c12, c21, c22;
    inline mat operator*(const mat& b) {
        mat d;
        d.c11 = ((ll)c11 * b.c11 + (ll)c12 * b.c21) % mod;
        d.c12 = ((ll)c11 * b.c12 + (ll)c12 * b.c22) % mod;
        d.c21 = ((ll)c21 * b.c11 + (ll)c22 * b.c21) % mod;
        d.c22 = ((ll)c21 * b.c12 + (ll)c22 * b.c22) % mod;
        return d;
    }
} A, B, I, ans; char s[maxn];
struct Node {
    mat s[2], w[4];
    int l, r;
    int rev, rtt, siz;
    unsigned int key;
} t[maxn]; int cnt = 0, rt = 0;
#define ls(x) (t[x].l)
#define rs(x) (t[x].r)
#define siz(x) (t[x].siz)
#define key(x) (t[x].key)
#define rev(x) (t[x].rev)
#define rtt(x) (t[x].rtt)
#define w(x, a) (t[x].w[a])
#define s(x, a) (t[x].s[a])
//w(0) 原，w(1) 翻转，w(2) 反转，w(3) 翻转且反转
//s(0) 原，s(1) 反转
//rev 翻转，rtt 反转
inline void pushup(int x) {
    if (x) {
        w(x, 0) = w(ls(x), 0) * s(x, 0) * w(rs(x), 0);
        w(x, 1) = w(rs(x), 1) * s(x, 0) * w(ls(x), 1);
        w(x, 2) = w(ls(x), 2) * s(x, 1) * w(rs(x), 2);
        w(x, 3) = w(rs(x), 3) * s(x, 1) * w(ls(x), 3);
        siz(x) = siz(ls(x)) + siz(rs(x)) + 1;
    }
}
inline int nwnd(int d) {
    int x = ++cnt;
    if (d == 0) w(x, 0) = w(x, 1) = s(x, 0) = A, w(x, 2) = w(x, 3) = s(x, 1) = B;
    else w(x, 0) = w(x, 1) = s(x, 0) = B, w(x, 2) = w(x, 3) = s(x, 1) = A;
    siz(x) = 1; key(x) = rd(); return x;
}
inline void pushrev(int x) {
    if (x) {
        swap(w(x, 0), w(x, 1));
        swap(w(x, 2), w(x, 3));
        swap(ls(x), rs(x)); rev(x) ^= 1;
    }
}
inline void pushrtt(int x) {
    if (x) {
        swap(w(x, 0), w(x, 2));
        swap(w(x, 1), w(x, 3));
        swap(s(x, 0), s(x, 1)); rtt(x) ^= 1;
    }
}
inline void pushdw(int x) {
    if (x) {
        if (rev(x)) pushrev(ls(x)), pushrev(rs(x)), rev(x) = 0;
        if (rtt(x)) pushrtt(ls(x)), pushrtt(rs(x)), rtt(x) = 0;
    }
}
int merge(int x, int y) {
    if (!x || !y) return x | y;
    else {
        pushdw(x); pushdw(y);
        if (key(x) <= key(y)) return rs(x) = merge(rs(x), y), pushup(x), x;
        else return ls(y) = merge(x, ls(y)), pushup(y), y;
    }
}
void split(int u, int s, int& x, int& y) {
    if (!u) return x = y = 0, void(); pushdw(u);
    if (siz(ls(u)) < s) x = u, split(rs(u), s - siz(ls(x)) - 1, rs(u), y);
    else y = u, split(ls(u), s, x, ls(u));
    pushup(u);
}
int main() {
    //freopen("code3.in", "r", stdin);
    int n, q, x = 0, y = 0, z = 0, d = 0; 
    scanf("%d%d%s", &n, &q, s + 1);
    I.c11 = I.c22 = 1; s(0, 0) = s(0, 1) = I; 
    for (int i = 0; i < 4; i++) w(0, i) = I;
    A = { 1, 1, 0, 1 }; B = { 0, mod - 1, 1, 2 };
    for (int i = 1; i <= n; i++) rt = merge(rt, nwnd(s[i] == 'E'));
    ans = A * w(rt, 0); printf("%d %d\n", ans.c22, ans.c12);
    while (q--) {
        scanf("%s", s + 1);
        if (!strcmp(s + 1, "APPEND")) { // ! strcmp
            char c; scanf(" %c", &c);
            rt = merge(rt, nwnd(c == 'E'));
        }
        else {
            int l, r; x = y = z = d = 0;
            scanf("%d%d", &l, &r);
            split(rt, r, x, y);
            split(x, l - 1, z, d);
            !strcmp(s + 1, "FLIP") ?  pushrtt(d) : pushrev(d);
            rt = merge(merge(z, d), y);
        }
        ans = A * w(rt, 0);
        printf("%d %d\n", ans.c22, ans.c12);
    }
    return 0;
}
```

---


# 冬至

## 题目背景

>春生秋死，不知冬至。

## 题目描述

给你 $1 \sim k$ 的整数，你可以选其中的数，组成长度为 $n$ 的串（可重复使用），且不能有子串是 $1\sim k$ 的排列。
  
问方案总数模 $998244353$。

## 说明/提示

【样例 1 解释】  
可以组成的合法排列有：$1,1,1$ 和 $2,2,2$  
其余均不合法，都含有 $1 \sim 2$ 的排列，因此答案为 $2$。

【样例 2 解释】  
总共有 $7^7$ 种情况，其中有 $7!$ 个不合法（即 $1 \sim 7$ 的排列情况数），答案为 $7^7-7!$，即 $818503$。

【数据范围】   
对于 $100\%$ 的数据，$1\le k \le 10^4$，$1\le n \le 10^9$。
  
By：毕克

## 样例 #1

### 输入

```
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7 7```

### 输出

```
818503```

## 样例 #3

### 输入

```
114514 233```

### 输出

```
782307368```

# 题解

## 作者：Weng_Weijie (赞：6)

### 第一部分：动态规划

首先考虑一个简单的 $\text{DP}$：

* $f(i,j)$ 表示前 $i$ 个字符中最后 $j$ 个字符**互不相同**，但最后 $j + 1$ 个字符中出现了相同的字符。
* 容易发现当 $i\geq 1$ 时只有满足 $1\leq j< k$ 才是合法的状态。
* 有两种转移：
	* $f(i+1,j+1)\leftarrow_+(k-j)\cdot f(i,j)$ 表示添加一个与后 $j$ 个字符均不相同的字符；
    * $f(i+1,k)\leftarrow_+f(i,j)$ 其中 $1\leq k \leq j$，表示添加这 $j$ 个字符中的某一个。
* 边界是 $f(0,0)=1$。
    
然而这个做法是 $O(nk)$ 的，远远高于我们的预期，我们需要想办法优化它。

### 第二部分：矩阵优化

发现题面中的 $n$ 特别大，我们要尽力在这一维上优化。

容易发现这个转移**关于第一维**来说是常系数、线性的，于是我们可以用**矩阵**来描述这个转移。具体地：

$$
\left[
\begin{matrix}
	 1 & 1 & 1 & \cdots & 1 \\
    k-1& 1 & 1 & \cdots & 1 \\
     0 &k-2& 1 & \cdots & 1 \\
     \vdots&\vdots &\vdots&\ddots& \vdots\\
     0 & 0 & 0 & \cdots & 1
\end {matrix}
\right]
\times
\left[
\begin {matrix}
	f(i,1)\\
    f(i,2)\\
    \vdots\\
    f(i,k-1)
\end {matrix}
\right]
=
\left[
\begin {matrix}
	f(i + 1, 1)\\
    f(i + 1, 2)\\
    \vdots\\
    f(i + 1, k - 1)
\end {matrix}
\right]
$$

其中矩阵、向量的维数都是 $k-1$。

我们可以写成这个形式：

$$A\times F_i=F_{i+1}$$

因此 $A^{n-1}\times F_1=F_n$。

使用矩阵快速幂就可以得到 $O(k^3\log n)$ 的做法，仍然无法通过。

### 使用特征多项式进一步优化

现在看起来没有什么优化的途径了？

发现我们在线性递推问题中也遇到了这个瓶颈，当时我们的解决办法是使用**矩阵的特征多项式**。

这里复述一下这个科技：

* 矩阵 $A$ 的特征多项式定义为 $F(\lambda)=\det(\lambda I-A)$；
* 由 $\text{Hamilton-Cayley theorem}$，矩阵的特征多项式是它的化零多项式，即 $f(A)=\mathbf 0$；
* 因此若 $x^n=F(x)Q(x)+R(x)$（即 $R(x)=x^n\bmod F(x)$），则 $A^n=F(A)Q(A)+R(A)=R(A)$；
* 左右同时乘上初始向量得 $f_n=\sum\limits_{i=0}^{k-1}f_ir_i$。

在这个问题中同样可以使用这个方法。

### 求特殊矩阵的特征多项式

接着问题来了：如何求这个矩阵 $A$ 的特征多项式呢？

注：**接下来的 $k$ 都指题目中的 $k-1$**。

设 $F_k(\lambda)=\det(\lambda I-A)=\det\left[
\begin {matrix}
\lambda-1&-1&\cdots&-1\\
-k&\lambda-1&\cdots&-1\\
0&1-k&\cdots&-1\\
\vdots&\vdots&\ddots&\vdots\\
0&0&\cdots&\lambda-1
\end{matrix}
\right]$

将这个行列式**按第一列展开**：

* 去掉第一行第一列得到了和原矩阵类似的矩阵，故贡献为 $(\lambda-1)F_{k-1}(\lambda)$；

* 去掉第二行第一列得到了和原矩阵类似的矩阵，但是左上角是 $-1$ 而不是 $\lambda$，设这种矩阵的行列式值为 $G_k(\lambda)$。

* 因此 $F_k(\lambda)=(\lambda-1)F_{k-1}(\lambda)+kG_{k-1}(\lambda)$；$G_k(\lambda)=-F_{k-1}(\lambda)+kG_{k-1}(\lambda)$；

* 两式相减得 $G_k(\lambda)=F_k(\lambda)-\lambda F_{k-1}(\lambda)$；

* 代回得 $F_k(\lambda)=(\lambda+k-1)F_{k-1}(\lambda)-k\lambda F_{k-2}(\lambda)$。

* 注意边界情况：$F_1(\lambda)=\lambda-1$；$F_2(\lambda)=\lambda^2-2\lambda-1$

我们得到了这种矩阵的特征多项式的递推式，打个表就能得到精确的结果了。

事实上：

$$F_k(\lambda)=\lambda^k-k\lambda^{k-1}-(k-1)\lambda^{k-2}-2(k-2)\lambda^{k-3}-\dots-(k-1)!$$

$$=\lambda^k-\sum_{i=1}^k(k-i+1)\cdot(i-1)!\cdot \lambda^{k-i}$$

得到特征多项式后，沿用线性递推的做法即可。需要注意初始状态。

求 $x^n\bmod f(x)$ 时使用快速幂，且需要多项式取模。

### 参考代码：

这个多项式取模是我很早以前的版本，可能码风不太一样。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

const int N = 131072;
const int mod = 998244353;
typedef long long LL;
typedef unsigned long long ULL;

int rev[N], wn[N], lim, s, w[N];

int pow(int x, int y) {
	int ans = 1;
	for (; y; y >>= 1, x = static_cast<LL> (x) * x % mod)
		if (y & 1) ans = static_cast<LL> (ans) * x % mod;
	return ans;
}
void reduce(int &x) {
	x += x >> 31 & mod;
}
void fftinit(int len) {
	wn[0] = lim = 1, s = -1; while (lim < len) lim <<= 1, ++s;
	for (int i = 0; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
	const int g = pow(3, (mod - 1) / lim);
	for (int i = 1; i < lim; ++i) wn[i] = (LL) wn[i - 1] * g % mod;
}
void fft(int *A, int typ) {
	static ULL tmp[N];
	for (int i = 0; i < lim; ++i) tmp[rev[i]] = A[i];
	for (int i = 1; i < lim; i <<= 1) {
		for (int j = 0, t = lim / i / 2; j < i; ++j) w[j] = wn[j * t];
		for (int j = 0; j < lim; j += i << 1)
			for (int k = 0; k < i; ++k) {
				const ULL x = tmp[k + j + i] * w[k] % mod;
				tmp[k + j + i] = tmp[k + j] + mod - x, tmp[k + j] += x;;
			}
	}
	for (int i = 0; i < lim; ++i) A[i] = tmp[i] % mod;
	if (!typ) {
		const int il = pow(lim, mod - 2); std::reverse(A + 1, A + lim);
		for (int i = 0; i < lim; ++i) A[i] = (LL) A[i] * il % mod;
	}
}
void inv(int *A, int *B, int n) {
	if (n == 1) { B[0] = pow(A[0], mod - 2); return; }
	int n_ = n + 1 >> 1; inv(A, B, n_), fftinit(n_ * 3);
	static int C[N], D[N];
	std::memcpy(D, B, n_ << 2), std::memset(D + n_, 0, lim - n_ << 2);
	std::memcpy(C, A, n << 2), std::memset(C + n, 0, lim - n << 2);
	fft(C, 1), fft(D, 1);
	for (int i = 0; i < lim; ++i) C[i] = mod - (LL) C[i] * D[i] % mod * D[i] % mod;
	fft(C, 0), std::memcpy(B + n_, C + n_, n - n_ << 2);
}

int g[N], rg[N], irg[N], k, n, ans, factor[N];

int rA[N];
void Divmod(int *A) {
	int n = 2 * k;
	std::reverse_copy(A, A + n, rA);
	std::memset(rA + k, 0, lim - k << 2);
	fft(rA, 1);
	for (int i = 0; i < lim; ++i)
		rA[i] = static_cast<LL> (rA[i]) * irg[i] % mod;
	fft(rA, 0);
	std::memset(rA + k, 0, lim - k << 2);
	std::reverse(rA, rA + k);
	fft(rA, 1);
	for (int i = 0; i < lim; ++i)
		rA[i] = static_cast<LL> (rA[i]) * g[i] % mod;
	fft(rA, 0);
	for (int i = 0; i < n; ++i)
		reduce(A[i] -= rA[i]);
}
int f[N];
void Powmod(int n) {
	if (n < k) {
		f[n] = 1;
		return;
	}
	Powmod(n >> 1);
	fft(f, 1);
	for (int i = 0; i < lim; ++i)
		f[i] = static_cast<LL> (f[i]) * f[i] % mod;
	fft(f, 0);
	if (n & 1) {
		for (int i = 2 * k - 1; i; --i)
			f[i] = f[i - 1];
		f[0] = 0;
	}
	Divmod(f);
}

int main() {
	std::cin >> n >> k, --k;
	g[k] = 1;
	factor[0] = 1;
	for (int i = 1; i < k; ++i)
		factor[i] = static_cast<LL> (factor[i - 1]) * i % mod;
	for (int i = 0; i < k; ++i)
		g[i] = mod - static_cast<LL> (i + 1) * factor[k - 1 - i] % mod;
	std::reverse_copy(g, g + k + 1, rg);
	inv(rg, irg, k);
	fftinit(k << 1 | 1);
	fft(irg, 1), fft(g, 1);
	Powmod(n - 1);
	for (int i = 0; i < k; ++i)
		reduce(ans += static_cast<LL> (pow(k + 1, i + 1)) * f[i] % mod - mod);
	std::cout << ans << '\n';
	return 0;
}
```




---

## 作者：zhouyuhang (赞：3)

不知道题解区为什么都在对着矩阵做。

直接考虑容斥，设共有 $c$ 个被钦定为排列，不妨设它们的结束位置分别为 $k \le p_1 < p_2 < \cdots < p_c \le n$。记 $x_i = p_i - p_{i - 1}$，特别的 $x_1 = p_1$，则对应的方案数即为 

$$
k ^ n \prod _ {i = 1} ^ {c} \frac {\min(x_i, k)!} {k ^ {\min(x_i, k)}}
$$

这是因为可以从前向后对每个 $p_i$ 依次确定其长为 $\min(x_i, k)$ 的后缀所填入数的集合。

于是我们记 $F(z) = \sum _ {i = 1} \frac {\min(i, k)!} {k ^ {\min(i, k)}} z ^ k$，$G(z) = \sum _ {i = k} \frac {k!} {k ^ k} z ^ k = \frac {k!} {k ^ k} \frac {z ^ k} {1 - z}$，则有答案为 

$$
k ^ n \left(1 - [z ^ n] \left( \frac {G(z)} {1 + F(z)} \right) \times  \left( \frac 1 {1 - z} \right) \right)
$$

（分子上的 $G(z)$ 刻画的是第一段，也就是 $x_1$ 所带来的贡献；卷上的 $\left( \frac 1 {1 - z} \right)$ 则用于刻画 $(p_c, n]$；$\left( \frac {1} {1 + F(z)} \right)$ 代表了对 $x_2, x_3, \cdots, x_c$ 的容斥）

由于我们有 $F(z) = G(z) + \sum _ {i = 1} ^ {k - 1} \frac {i!} {k ^ i} z ^ i$，所以在分子分母上同时乘上 $(1 - z)$ 就可以使得分子分母上都是最高次不超过 $k + 1$ 的多项式。于是我们的问题形式变成对短多项式 $P(z), Q(z)$，求出 $[z ^ n] \frac {P(z)} {Q(z)}$。直接应用 Bostin-Mori 算法，复杂度即为 $\mathcal O(k \log k \log n)$。

---

## 作者：望月Asta (赞：1)

## 前言

~~退役选手不好好学 whk 跑来颓废~~

本文含有大眼观察/OEIS。

**update：递推式的表有点问题，修了一下**

## 题意

用 $1 \sim k$ 的整数，组成长度为 $n$ 的串，且不能有子串是 $1\sim k$ 的排列。
  
求方案数。

## 解法

首先是暴力 DP，和另一篇题解一样。

$f_{i,j}$ 表示填 $i$ 位的串，最后 $j$ 个数各不相同且最后 $j + 1$ 位有相同的方案数。

对于 $n$ 的答案就是 $\sum_{i = 1}^{k - 1} f_{n,i}$。

然后转移就是 $f_{i + 1,j + 1} \stackrel{+}{\leftarrow} f_{i,j},f_{i + 1,w} \stackrel{+}{\leftarrow} f_{i,j} (w \in [1,j])$

```cpp
#define rep(a,b,c) for(int a = (b);a <= (c);++a)
#define repb(a,b,c) for(int a = (b);a >= (c);--a)
#define repl(a,b,c) for(int a = (b);a < (c);++a)
#define add(x,y) ( (((x) += (y)) >= MOD) && ((x) -= MOD) )

g[0][0] = 1;
int p = 1;
repl(i,1,n) {
	repl(j,0,m)
		add(g[p][j + 1],(i64)g[p ^ 1][j] * (m - j) % MOD);
	repb(j,m - 1,0) {
		ad[j] = ad[j + 1];
		add(ad[j],g[p ^ 1][j]);
	}
	repl(j,1,m) add(g[p][j],ad[j]);
	repl(j,0,m) add(f[i],g[p][j]);
	p ^= 1;
	memset(g[p],0,(m + 1) << 2);
}
```

然后这个 $\mathcal{O} (nk)$ 显然过不去，考虑优化。

首先有一个 naive 的做法是矩阵快速幂，这个是 $\mathcal{O} (k^3 \log n)$ 的，显然还不行。

但是这个方法成功让复杂度倾斜了，考虑继续优化。

形式化定义一个数列 $\{a\}$ 的递归式/递推式为如下形式：

$$\large
\sum_{i = 0}^{k - 1} a_{n - i}r_i = 0
$$

也就是常见的 $a_n = \sum_{i = 1}^{k - 1} a_{n - i}r_i$ 移项后的形式。

考虑一个 $n$ 阶方阵 $M$ 的数列 $\{I,M,M^2,M^3,\cdots\}$，我们首先求 $M$ 的特征多项式 $P$，由 Cayley-Hamilton 定理可知，特征多项式是 $M$ 的一个零化多项式，即 $P(M) = 0$ 且满足 $[x^n]P(x) = 1$，次数为 $n$ 次。

$$\large\begin{aligned}

P(M) &= 0\\

\sum_{i = 0}^{n}  p_{n - i} M^i &= 0\\

\sum_{i = 0}^{n}  p_{n - i} M^{i + j} &= 0\\

\sum_{i = 0}^{n}  p_{i} M^{n + j - i} &= 0\\

\end{aligned}$$

符合上面线性递推的
定义式，于是其最短线性递推式不长于 $n$。

由线性递推的封闭性可知，原数列每个元素乘一个相同的 $n$ 行的列向量仍满足线性递推关系，于是 $f_{n,1} \sim f_{n,k - 1}$ 都满足线性递推，长度为 $n$ 的合法方案数 $g_n = \sum_{i = 1}^{k - 1} f_{n,i}$ 也满足线性递推关系，此时可以暴力求前 $2k$ 项然后 [BM 算法](https://www.luogu.com.cn/problem/P5487) 求出其递推式，线性递推计算即可。

时间复杂度 $\mathcal{O} (k^2 + k \log k \log n)$，但是这个方法只能获得较低的分数，预处理递推式部分复杂度太高，考虑继续优化。

观察对每个 $k$ 得到的递推式：

### $k = 1$ 时

答案恒为 $0$，无解。

### $k = 2$ 时

答案恒为 $2$，全填 $1$ 或 $2$。

### $k \ge 3$ 时

打表如下：

$k = 3$ 时，有 $2$ 阶递推式 $\{2,1\}$

$k = 4$ 时，有 $3$ 阶递推式 $\{3,2,2\}$

$k = 5$ 时，有 $4$ 阶递推式 $\{4,3,4,6\}$

$k = 6$ 时，有 $5$ 阶递推式 $\{5,4,6,12,24\}$

$k = 7$ 时，有 $6$ 阶递推式 $\{6,5, 8,18, 48,120\}$

发现对于  $k \ge 3$ 有 $k - 1$ 阶递推式，满足 $r_{k,i} = (k - i - 1)i!$。

可以~~大眼观察或者~~[查看 OEIS](http://oeis.org/A137948) 得到。

现在只需要知道 $g_{i}$ 前 $k$ 项即可，考虑组合意义，前 $k - 1$ 个数都可以任意填，那么有 $g_i = k^i (i < k)$。

综上，预处理时间复杂度降至 $\mathcal{O} (k)$，总复杂度为 $\mathcal{O} (k \log k \log n)$，可以获得 100 分。

代码是线性递推板子，就只放云剪贴板里了。

[完整代码](https://www.luogu.com.cn/paste/nwh4lwlh)


---


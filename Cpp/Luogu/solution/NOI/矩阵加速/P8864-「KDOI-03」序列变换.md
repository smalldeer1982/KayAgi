# 「KDOI-03」序列变换

## 题目描述

给定一个长度为 $n$ 的 $\tt01$ 序列 $a$ 和 $q$ 次询问，询问参数 $k$。

每次询问给定 $L,R$，其中 $1\leq L\leq R\leq n$，你可以进行如下操作：

+ 选择一个下标 $L<i\le R$；
+ 将 $a_{i-1}$ 赋值为 $a_{i-1}\oplus a_i$，$a_{i+1}$  赋值为 $a_{i+1}\oplus a_i$。如果 $i=n$，则不对 $a_{i+1}$ 作出改变。其中 $\oplus$ 表示按位异或运算。

求使得 $[L,R]$ 区间内**至多**有 $k$ 个 $\tt1$ 的最小操作次数。询问之间相互独立，也就是说，每次询问后重置为初始序列。

## 说明/提示

**【样例 1 解释】**

如图，用绿色代表 $\tt0$，红色代表 $\tt1$，初始序列如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/hxw9knxu.png)

对于第 $1$ 次询问，选择 $i=3$，则序列变为下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zvb2lfi8.png)

对于第 $2$ 次询问，选择 $i=2$，则序列变为下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wubvxvaa.png)

**【样例 2 解释】**

对于第 $1$ 次询问，由于 $a_{12},a_{13},a_{14},a_{15}$ 中只有 $2$ 个 $\tt1$，所以不需要进行任何操作。

对于第 $6$ 次询问，可以依次选择 $i=\{7,8,9,10,11,12\}$。

**【样例 3】**

见选手文件中的 `control/control3.in` 与 `control/control3.ans`。

此样例满足测试点 $7\sim10$ 的限制。

**【样例 4】**

见选手文件中的 `control/control4.in` 与 `control/control4.ans`。

此样例满足测试点 $15\sim17$ 的限制。

**【样例 5】**

见选手文件中的 `control/control5.in` 与 `control/control5.ans`。

此样例满足测试点 $18\sim21$ 的限制。

***

**【数据范围】**

对于 $100\%$ 的数据， $2\le n\le 3~000$，$1\le k\le 
\min(n,1~000)$，$1\le q\le 5\times10^5$，$0\le a_i\le 1$。


|测试点编号|$n\le$|$k\le$|$q\le$|特殊性质|
|:--:|:--:|:--:|:--:|:--:|
|$1\sim3$|$80$|$50$|$2~000$|无|
|$4\sim6$|$400$|$300$|$1$|$k$ 是偶数|
|$7\sim10$|$400$|$2$|$10~000$|无|
|$11\sim14$|$400$|$300$|$10~000$|无|
|$15\sim17$|$3~000$|$10$|$5\times10^5$|无|
|$18\sim21$|$3~000$|$1~000$|$5\times10^5$|$k$ 是偶数|
|$22\sim25$|$3~000$|$1~000$|$5\times10^5$|无|




## 样例 #1

### 输入

```
5 1 2
1 1 1 0 1
2 3
1 3```

### 输出

```
1
1```

## 样例 #2

### 输入

```
20 3 22
0 0 1 1 1 1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 
12 15
1 6
5 10
2 5
9 18
6 17
2 13
4 16
2 8
9 19
10 15
7 15
1 3
14 18
6 17
12 14
7 16
14 18
11 12
3 5
3 6
3 15
```

### 输出

```
0
1
0
0
0
6
3
5
1
0
0
0
0
0
6
0
0
0
0
0
1
3
```

# 题解

## 作者：Error_Yuan (赞：15)

T4 题解：

观察题意得，我们对序列 $a$ 做前缀异或和得到 $s$ 后，每次操作相当于交换 $s_i$ 和 $s_{i-1}$。

（不失一般性，以下全部假设 $s_{L-1}=0$，$s_{L-1}=1$ 时是相反的）

至多 $k$ 个 $1$ 在 $k$ 为偶数时相当于把 $s_{[L,R]}$ 中的 $1$ 分成 $\dfrac{k}{2}$ 段，每段的 $1$ 都是连续的（$s_{L-1}=1$ 时是把 $0$ 分成 $\dfrac{k}{2}$ 段）。则我们可以写出如下 dp 转移：

+ 设 $dp_{l,r,i}$ 表示 $s_{[l,r]}$ 中的 $1$ 分成 $i$ 段的最小操作次数；
+ $dp_{l,r,i}=\min_{l\le j<r}(dp_{l,j,i-1}+cost_{j+1,r})$，其中 $cost_{i,j}$ 表示将 $s_{i,j}$ 中的 $1$ 移动到同一段的最小操作次数。
+ $cost_{i,j}$ 可以通过平凡的贪心计算。

### 算法一

暴力转移，时间复杂度 $O(n^3k)$，预期通过测试点 $1\sim10$，然而由于常数极小，实际上可以通过测试点 $1\sim14$。

+ 鲜花：这个 $O(n^3k)$ 到底是怎么做到 $400$ 只需要 $3s$ 的？？$400^3\times300=1.92\times10^{11}$，就算乘上 $\frac{1}{16}$ 的常数也有 $10^{10}$，怎么在 $4s$ 内跑过去的？？？


### 算法二

进行优化：感性理解一下，$cost$ 满足四边形不等式，因此可以用四边形不等式优化，复杂度降至 $O(n^2k)$。


**注意：此处的四边形不等式优化和 [IOI 2000] 邮局 所用并不相同。**

可以通过前 $17$ 个测试点。


### 算法三


+ 继续优化：我们记矩阵 ${\bf{A}}_{ij}=\begin{cases}
 cost_{i,j} & \text{ if } i\le j\\
 0 & \text{ otherwise }
\end{cases}$，则每次 $i$ 上的转移相当于对 $\bf{A}$ 做一次 $(\min,+)$ 的矩阵乘法，$\dfrac{k}{2}$ 次后 dp 矩阵即为 ${\bf{A}}^{\frac{k}{2}}$，所以用矩阵快速幂即可 $O(n^2\log k)$。**请注意，经过算法二中的优化后这里的矩阵乘法是 $\bm{O(n^2)}$ 的。** 实现需要注意细节，很容易挂。

一个细节：这里矩阵乘法的形式是：  
$$
C_{i,j}=\min(A_{i,k}+B_{k+1,j})
$$
这里中间的 $k$ 断开了，不一定能够满足乘法结合律，直接做快速幂会挂。我们可以这样重新定义矩阵乘法：
$$
C_{i,j}=\min(A_{i,k}+B_{k,j})
$$
这样的话，设 ${\bf A'}_{ij}=\begin{cases}
 {\bf A}_{i-1,j} & \text{ if } i\le n\\
 0 & \text{ otherwise }
\end{cases}$

这样 $\bf A'$ 也满足四边形不等式，而原来的 ${\bf A}^{\frac{k}{2}}$ 等于现在的 ${\bf A}\times{\bf (A')}^{\frac{k}{2}-1}$，这样就可以直接快速幂了。

对于询问，分类讨论一下即可做到单次 $O(1)$，具体如下：

+ 若 $k$ 是偶数，答案显然为 $dp_{l,r,\frac{k}{2}}$。
+ 若 $k$ 是奇数，则答案为 $\min_{l\le j\le r} (dp_{l,j,\frac{k-1}{2}}+cost2_{j+1,r}))$，其中 $cost2_{i,j}$ 表示 $s_{[i,j]}$ 中的 $1$ 在均移动到末尾（即 $j$）处的最小操作数，这个也可以通过四边形不等式优化在 $O(n^2)$ 内预处理。

附一些细节：

+ 不要将 `matrix` 类型传入函数，很慢。
+ 如果用了矩阵赋值，记得重载 `=`。


***

鲜花：本题赛时最高得分为 $36$，似乎大家都没有想到题解的第一句话。。。

得分为 $28/32/36$ 应该是写了错误的贪心。

---

## 作者：Hanghang (赞：5)

## P8864

给定一个长度为 $n$ 的 $\tt01$ 序列 $a$ 和 $m$ 次询问，询问参数 $d$。

每次询问给定 $L,R$，其中 $1\leq L\leq R\leq n$，你可以进行如下操作：

+ 选择一个下标 $L<i\le R$；
+ 将 $a_{i-1}$ 赋值为 $a_{i-1}\oplus a_i$，$a_{i+1}$  赋值为 $a_{i+1}\oplus a_i$。如果 $i=n$，则不对 $a_{i+1}$ 作出改变。其中 $\oplus$ 表示按位异或运算。

求使得 $[L,R]$ 区间内**至多**有 $d$ 个 $\tt1$ 的最小操作次数。询问之间相互独立，也就是说，每次询问后重置为初始序列。

$n\le 3000$，$d \le 1000$，$m \le 5\times 10^5$


将数组 $a$ 做一遍前缀异或和，那么每次使用操作相当于就是交换 $a_{i-1}$ 和 $a_i$。

不失一般性，设 $a_{l-1}=0$，$a_{l-1}=1$ 时同理。 

那么每次相当于询问区间内 $a$ 数组相邻且不同的个数小于等于 $d$。也就相当于询问将区间内的 $a$ 数组分为至多 $\lfloor \frac{d}{2}\rfloor$ 段连续 $1$ 的最少操作数。（$d$ 为奇数时末尾可能还有一段，单独计算）

考虑使用动态规划。

设 $s_{l,r}$ 表示区间的答案，$f_{l,r,k}$ 表示将 $a_{[l,r]}$ 划分为至多 $k$ 段 $1$ 的最小操作数，$g_{l,r}$ 表示将 $a_{(l,r]}$ 中的所有 $1$ 移动到一段的最小操作数，$h_i$ 表示 $a_{[1,i]}$ 中 $0$ 的个数。

$d$ 为奇数的时候有可能是 $\lfloor \frac{d}{2}\rfloor$ 段连续一加上最后一段中的所有 $1$ 全部移到末尾。再设 $t_{l,r}$ 表示将 $a_{(l,r]}$ 内所有的 $1$ 移动到末尾 $r$ 处的最小操作数。

那么有

>$g_{l,r}=min \sum_{i=l+1}^{r} [a_i=1]\times |h_i-x|$，$x\in [h_l,h_r]$

通过小学奥数可知 $x$ 等于区间内所有 $a_i=1$ 的 $h_i$ 的中位数时，$g$ 取得最小值。

>$t_{l,r}=\sum_{i=l+1}^{r}[a_i=1]\times (h_r-h_i)$

前缀和优化即可。

>$f_{l,r,k}= min_{l \le w <r}(f_{l,w,k-1}+g_{w,r})$

>$s_{l,r}=
\left\{
\begin{aligned}
f_{l,r,\frac{d}{2}}(d\bmod 2=0) \\
min_{l\le i <r}(f_{l,i,\frac{d-1}{2}}+t_{i,r})(d \bmod 2=1)\\
\end{aligned}
\right.$

好！基本暴力 dp 就结束了。

复杂度 $O(n^3 \times d+m)$。


能不能给力点？

发现 $f$ 数组每层转移只跟上一层有关且转移为 $(min,+)$ 矩阵形式，这就可以矩阵乘法优化！

复杂度 $O(n^3 \log d+m)$。


能不能再给力点？

发现每层的 $f$ 为 2D1D 转移方程。常见优化方向为决策单调性。那么只需证明 $g$ 满足区间包含单调性和四边形不等式即可。

简易证明：

区间包含单调性是简单的，大区间相比小区间不会减少 $1$ 的个数，那么将所有 $1$ 移动到一起的操作数也不会减少，所以一个小区间的最小操作数小于等于一个大区间的最小操作数。

四边形不等式是困难的，需证明 $g_{l,r}+g_{l+1,r+1} \le g_{l+1,r}+g_{l,r+1}$。

从定义出发，如果 $a_l=0$，那么对答案是无贡献的，那么就转化为证明 $g_{l+1,r}+g_{l+1,r+1} \le g_{l+1,r}+g_{l+1,r+1}$，左右两边相等，成立。那么 $a_{r+1}=0$ 时同理。

那么只需证明 $a_l=1$ 且 $a_{r+1}=1$ 的时候式子成立。

设数组 $c$ 为求 $g$ 数组的时候取的 $x$。因为 $a_l=1$ 且 $a_{r+1}=1$，那么 

> $c_{l,r+1}=c_{l+1,r}$，$c_{l+1,r} \ge c_{l,r}$，$c_{l+1,r} \le c_{l+1,r+1}$。

那么就有

> $g_{l+1,r}+g_{l,r+1}=2 \times g_{l+1,r}+c_{l+1,r}-h_l+h_{r+1}-c_{l+1,r}$

> $g_{l,r}\le g_{l+1,r}+c_{l+1,r}-h_l$，$g_{l+1,r+1}\le g_{l+1,r}+h_{r+1}-c_{l+1,r}$

所以

> $g_{l,r}+g_{l+1,r+1} \le g_{l+1,r}+g_{l,r+1}$

证毕。

所以 $f$ 数组可以四边形不等式优化。

再考虑 $s$ 数组，可以通过类似的方法证明 $t$ 满足区间包含单调性和四边形不等式，那么也就可以推出 $s$ 数组可以四边形不等式优化。

复杂度 $O(n^2 \log d+m)$。

一些可能可以帮到你的细节：

矩阵乘法传数组的时候加上引用。

一开始的 $a$ 的数组做一遍，再全部异或上 $1$ 做一次。

$d=1$ 单独处理。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=3003,INF=1e9;
int n,m,d,p[N],a[N],h[N],pos[N],num[N],sh[N];
struct Mat
{
	int mat[N][N];
	void Clear(){memset(mat,0,sizeof(mat));}
	friend Mat operator *(const Mat &a,const Mat &b)
	{
		Mat c,s;c.Clear();s.Clear();
		for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)c.mat[i][j]=i==j?i:0,s.mat[i][j]=i==j?0:INF;
		for(int len=2;len<=n;len++)for(int l=1,r=len;r<=n;l++,r++)
		    for(int k=c.mat[l][r-1],x;k<=c.mat[l+1][r];k++)
		        if((x=a.mat[l][k]+b.mat[k][r])<s.mat[l][r])s.mat[l][r]=x,c.mat[l][r]=k;
		return s;
	}
}E,f,ans[2];
int G(int l,int r)
{
	int pl=a[l]==1?pos[l]:pos[l]+1,pr=pos[r],mi=(pl+pr)/2,x=num[mi];
	return l>r?0:h[x]*(mi-pl+1)-(sh[x]-sh[l-1])+(sh[r]-sh[x])-h[x]*(pr-mi);
}
int T(int l,int r)
{
	int pl=a[l]==1?pos[l]:pos[l]+1,pr=pos[r];
	return l>r?0:h[r]*(pr-pl+1)-(sh[r]-sh[l-1]);
}
Mat Work()
{
	int tot=0,k=d/2-1;
	for(int i=1;i<=n;i++)h[i]=h[i-1]+(a[i]==0),sh[i]=sh[i-1]+h[i]*a[i];
	for(int i=1;i<=n;i++)a[i]==1?pos[i]=++tot,num[tot]=i:pos[i]=pos[i-1];
	if(d==1)
	{
		for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)E.mat[i][j]=T(i,j);
		return E;
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)f.mat[i][j]=G(i+1,j),E.mat[i][j]=G(i,j);
	for(int i=1;i<=k;i<<=1,f=f*f)if(k&i)E=E*f;
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)f.mat[i][j]=T(i+1,j);
	return d%2==0?E:E*f;
}
int main()
{
	cin>>n>>d>>m;
	for(int i=1;i<=n;i++)cin>>p[i],a[i]=a[i-1]^p[i];
	for(int i=1;i<=n;i++)a[i]^=1;
	ans[1]=Work();
	for(int i=1;i<=n;i++)a[i]^=1;
	ans[0]=Work();
	for(int i=1,l,r;i<=m;i++)cin>>l>>r,cout<<ans[a[l-1]].mat[l][r]<<endl;
}
```

---

## 作者：Implicit (赞：3)

注意到操作相当于交换前缀异或和，那么原来的限制相当于限制 1 的连续段个数。

令 $a$ 是原来的 $a$ 的前缀异或和，$dp_{l,r,k}$ 表示将 $l\dots r$ 中的 1 分为 $k$ 段的最小操作次数，则：
$$dp_{l,r,k}=\min_{l\le i<r}\{dp_{l,i,k-1}+w_{i,r}\}$$
其中 $w_{l,r}$ 表示将 $(l,r]$ 中的 1 移动到同一段的最小操作次数。

显然 $w$ 满足区间包含单调性。另一方面，移动一个端点区间所有 1 的位置组成中位数位置最多移动一位，讨论一下可以得到 $w_{l,r}+w_{l+1,r+1}\le w_{l+1,r}+w_{l,r+1}$，那么 $w$ 也满足四边形不等式。从而可以得出 $dp_{\dots,k}$ 和 $w$ 都是蒙日矩阵。

一次转移相当于做一个 $(\min,+)$ 矩阵乘法，矩阵快速幂即可批量进行转移，考虑到矩阵是蒙日矩阵所以这里的矩阵乘法可以 $O(n^2)$ 计算。那么就 $O(n^2\log k)$ 解决了这个问题。

---

## 作者：Astatinear (赞：2)

### [P8864 「KDOI-03」序列变换](https://www.luogu.com.cn/problem/P8864)

做不起，根本做不起，我就是官解中连第一个结论都没有想到的男人。

首先拿到这种，如果在原序列上的操作不好描述，那么考虑去求前缀或者后缀的值。

假设原数组的前缀异或数组为 $s_i=\oplus_{j=1}^i a_j$。发现一次对于 $i$ 的操作本质上就是交换 $s_i,s_{i-1}$。

考虑如何用 $s$ 去刻画至多 $k$ 个 $1$。先考虑 $k$ 是偶数的情况：我们钦定 $s_l=0$，其实就是 $s_l,..,s_r$ 中 $1$ 的连续段最多只有 $\frac{k}{2}$ 段。（反过来 $s_l=1$ 时，就是 $0$ 最多 $\frac{k}{2}$ 段）

有了操作和条件的刻画，考虑 DP。（一下我们都钦定 $s_l=0$，如果是 $1$ 反过来就好了。）

定义 $dp_{i,l,r}$ 表示将 $s_l,...s_r$ 分成 $i$ 个 $1$ 的连续段的最小操作次数是多少。

显然有：$dp_{i,l,r}=\min_{j=l}^{r-1} \{ dp_{i-1,l,j}+\text{val} _{j+1,r} \}$，其中 $\text{val}_{j+1,r}$ 表示将这里面的 $1$ 放到一段的最小代价。

$\text{val}_{l,r}$ 的求解方法就是找到其中 $1$ 的位置的中位数，然后全部移过去即可，一个简单的贪心。

此时时间复杂度 $\mathcal{O}(n^3 \times k)$。

先考虑第一步优化，观察到我们可以把 $\text{val},dp_i$ 当作两个矩阵，注意到转移一定只能从 $dp_{i-1}\to dp_i$。

本质上是一个 $\min+$ 矩阵的卷积，可能下标并不是很对齐，可以将 $\text{val}_{j+1,r}$ 稍微移动到 $\text{val}_{j,r}$ 来对齐卷积的下标，那么显然满足结合律，可以使用矩阵快速幂优化做到 $\mathcal{O}(n^3\times \log k)$。

继续观察，发现这个转移式看起来非常符合正常的四边形不等式优化区间 DP 的形式。考虑感性证明，简单打个表发现确实满足四边形不等式的条件。

故考虑在卷积中，使用决策单调性优化卷积过程，将单次卷积从 $\mathcal{O}(n^3)\to \mathcal{O}(n^2)$。

那么总复杂度就来到了 $\mathcal{O}(n^2\times \log k)$。

当 $k$ 为奇数时，答案就是 $\text{ans}_{l,r}=\min_{i=l}^{r-1} dp_{l,i,\frac{k-1}{2}}+\text{val'}_{i+1,r}$，其中 $\text{val'}_{l,r}$ 表示将 $[l,r]$ 中的 $1$ 全部移到最右边的最小操作次数。显然，这一步也可以使用四边形不等式优化做到 $\mathcal{O}(n^2)$。

总时间复杂度 $\mathcal{O}(n^2\log k)$，代码一点也不好写。

---


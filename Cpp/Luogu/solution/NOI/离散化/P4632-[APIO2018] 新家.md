# [APIO2018] 新家

## 题目背景

**警告！滥用本题者封号！请勿多次重复提交！**

## 题目描述

五福街是一条笔直的道路，这条道路可以看成一个数轴，街上每个建筑物的坐标都可以用一个整数来表示。小明是一位时光旅行者，他知道在这条街上，在过去现在和未来共有 $n$个商店出现。第 $i$个商店可以使用四个整数 $x_i, t_i, a_i, b_i$描述，它们分别表示：商店的坐标、商店的类型、商店开业的年份、商店关闭的年份。

小明希望通过时光旅行，选择一个合适的时间，住在五福街上的某个地方。他给出了一份他可能选择的列表，上面包括了 $q$个询问，每个询问用二元组 （坐标，时间）表示。第 $i$对二元组用两个整数 $l_i, y_i$描述，分别表示选择的地点 $l_i$和年份 $y_i$。

现在，他想计算出在这些时间和地点居住的生活质量。他定义居住的不方便指数为：在居住的年份，离居住点最远的商店类型到居住点的距离。类型 $t$的商店到居住点的距离定义为：在指定的年份，类型 $t$的所有营业的商店中，到居住点距离最近的一家到居住点的距离。我们说编号为 $i$的商店在第 $y$年在营业当且仅当 $a_i ≤ y ≤ b_i$ 。注意，在某些年份中，可能在五福街上并非所有 $k$种类型的商店都有至少一家在营业。在这种情况下，不方便指数定义为 $-1$。

你的任务是帮助小明求出每对（坐标，时间）二元组居住的不方便指数。

## 说明/提示

**提示**

在第一个样例中，有 4 家商店，共 2 种类型，还有 4 个询问。

- 对于第一个询问：小明在第 3 年住在坐标为 5 的地方。这一年中，编号为 1 和 2 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 2 的商店距离为 4 ，所以最大距离为$4$。
- 对于第二个询问：小明在第 6 年住在坐标为 5 的地方。这一年中，编号为 1 和 3 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 3 的商店距离为 2 ，所以最大距离为$2$。
- 对于第三个询问：小明在第 9 年住在坐标为 5 的地方。这一年中，编号为 1 和 4 的商店在营业，它们的类型都为 1，没有类型为 2 的商店在营业，所以答案为 $-1$。
- 同样的情况出现在第四个询问中。

在第二个样例中，有 2 家商店，共 1 种类型，还有三个询问。 两家商店的类型都是 1 。在所有的询问中，小明均住在坐标为 1 的地方。 在前两个询问中，至少有一个商店在营业，所以答案为 $0$ ，在第三个询问中，两个商店都不在营业，所以答案为 $-1$ 。

在第三个样例中，有 1 家商店和 1 个询问，两者之间的距离是 $99999999$ 。


**子任务（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

- Subtask 1(points: $5$): $n, q \leq 400$
- Subtask 2(points: $7$): $n, q \leq 6 × 10^4, k \leq 400$
- Subtask 3(points: $10$): $n, q \leq 3 × 10^5$，对于所有的商店 $a_i = 1, b_i = 10^8$
- Subtask 4(points: $23$): $n, q \leq 3 × 10^5$，对于所有的商店 $a_i = 1$
- Subtask 5(points: $35$): $n, q \leq 6 × 10^4$
- Subtask 6(points: $20$): $n, q \leq 3 × 10^5$


## 样例 #1

### 输入

```
4 2 4
3 1 1 10
9 2 2 4
7 2 5 7
4 1 8 10
5 3
5 6
5 9
1 10
```

### 输出

```
4
2
-1
-1
```

## 样例 #2

### 输入

```
2 1 3
1 1 1 4
1 1 2 6
1 3
1 5
1 7```

### 输出

```
0
0
-1
```

## 样例 #3

### 输入

```
1 1 1
100000000 1 1 1
1 1
```

### 输出

```
99999999
```

# 题解

## 作者：shadowice1984 (赞：28)

数据结构神题……

两个log跑了2000ms我也是醉了(人傻常数大)

________________________

# 本题题解

题意还是比较清楚的，数轴上有一堆不同颜色的点，每个点会在一定时间出现在另一些时间消失，每次询问在某一个时间从某一个点出发需要经过多长距离才能经过所有颜色至少一次

然后我们对于这道题的思路基本上就是模拟这个过程，只是使用一些数据结构来加速我们的模拟

### 扫描线

首先我们先对时间轴进行类似于扫描线的处理，把一个商店拆成一个a时间插入操作和一个b时间删除操作

所以现在问题变成了，动态维护一个颜色序列，支持在某个位置插入一个颜色和删除一个颜色

问题来了我们要支持什么询问呢？

### 二分答案

然后我们来看询问是询问在某一个时间，一个人从某一位置出发同时向两边走，至少走多远才能经过所有的颜色各一次

当然可以迅速的想到二分答案了……

我们二分一个答案mid，于是问题转化成了，我走mid步可不可以经过所有的颜色

换句话说我们需要强制在线的支持区间查是否有所有的颜色

那么区间数颜色这个问题就是一个套路，套路的名字叫只数左边第一个点

#### 区间数颜色

我们对于每一个颜色记$pre_{i}$为这个颜色左侧第一个和它同色点的位置，那么我们会发现一个点是区间$[l,r]$中本颜色的左侧第一个点当且仅当$pre_{i}<l$(可以画一个图加深理解)那么我们如果要数区间里有多少颜色只需查询$[l,r]$中的点有多少个点的$pre$值小于l即可……

然后你当然可以把二分的判定问题转化为区间中的颜色个数是否等于k这个问题

于是你用线段树套线段树去数区间的颜色了……

另外你需要注意的是同一个位置可能出现多个pre值不同的点，此时你的离散化会变的极其恶心同时边界问题基本讨论不清楚

并且此时的你的复杂度是$O(nlog^3n)$在$n=3×10^5$的时候这个数字甚至比$O(n\sqrt{n})$还要大……显然是要T飞的……

______________

#### 查找是否存在所有的颜色

$O(nlog^3n)$的优秀复杂度让我们不禁怀疑我们的算法复杂度出了偏差……

所以让我们回到问题的原点——查找区间中是否存在所有的颜色

有谁告诉你我们非要知道区间里有**多少种**颜色吗？

我们只是需要知道区间里**是否**有所有的颜色而已

仔细观察pre的含义——左边第一个和这个点同色点的位置，那么我们会发现$pre$值还告诉我们另一个非常重要的信息

**$i$到$pre_{i}$之间不存在i这种颜色**

换句话说，我们可以查找$[r+1,n]$的$pre$的区间最小值$k$

这样的话根据pre值的性质,除非区间的左端点小于k，否则我们从r出发一定碰不到所有的颜色，直接说可能不是很好理解，建议这里自己画图

换句话说我们只需要查找$[r+1,n]$的区间pre最小值，然后和$l$进行比较即可确认区间中是否有所有的颜色了

这个东西当然可以使用线段树进行维护

当然我们会发现我们落下了一种情况，就是每个颜色的最右点不会被算上

单开一个set存下所有颜色的最右点坐标，然后每次取set里的最小值和区间最小值比较取二者更小的即可

那么插入和删除某一个颜色的时候它的后继的pre值将会变化为他的前驱或者它自己，查找同色前驱后继的操作可以通过开k个set暴力实现

### 重复值

这才是这道题最恶心的地方，我们将要处理一大堆重复值

注意一件事情是线段树上一个叶子节点里可能存着一堆pre值不同的点，当然甚至可能pre值都相同

这意味着我们不能通过简单的赋值操作来完成替换，我们需要在每一个叶子节点上单开一个multiset来处理最小值，每次修改某一位置的pre值的时候把multiset拉出来做插入删除然后重新更改一下这个叶子节点的最小值

另外就是你的离散化会非常恶心……

因为你二分的是实际距离但是线段树上的值域就是$(0,n)$

这导致了你需要把实际距离转成线段树上的值域

另外你查出set的前驱后继查出来的都是实际距离但是你还要转成线段树的值域

一种做法就是我\*\*不写离散化了，把线段树换成splay

另一种就是不要拘泥于平常的离散化写法直接使用哈希表来暴力存下离散化数组

对于二分出的距离转线段树的值域可以直接暴力lower_bound然后查哈希表中的值

另外一个坑就是multiset的erase会erase全部的值，只erase一个值的正确做法是先find出一个迭代器然后erase这个迭代器

然后就是愉快的调试环节了，祝各位调试愉快~

代码仅供参考,小压了一下行，121行

上代码~

```C
#pragma GCC optimize(2)
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;const int N=3*1e5+10;const int Md=(1<<25)-1;int ans[N];int n;int m;int q;
struct hsh_map//用来离散化的哈希表 
{
	int f[N];int x[N];int v[N];int ct;int al[Md];int lsh[N];int hd;int rk[N];
	inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
	inline int& operator[](int va)//重载寻址运算符 
	{for(int i=al[va&Md];i;i=x[i])if(v[i]==va){return f[i];}add(va&Md,va);return f[ct];} 
	inline int find(int x)//二分 
	{int* p=lower_bound(lsh+1,lsh+hd+1,x);if(p!=lsh+hd+1)return this->operator [](*p);return n+1;}
	inline void ins(int x){lsh[++hd]=x;}
	inline void build()//暴力离散化 
	{
		sort(lsh+1,lsh+hd+1);
		rk[1]=1;for(int i=1;i<=hd;i++)rk[i]=lsh[i]==lsh[i-1]?rk[i-1]:i;
		for(int i=1;i<=hd;i++)this->operator [](lsh[i])=rk[i];
	}
}mp;
inline void ers(multiset <int>& s,const int& val)//multiset的erase 
{multiset <int>::iterator it=s.find(val);if(it!=s.end())s.erase(it);}
struct opt//扫描线 
{
	int ti;int tp;int k;int pos;
	friend bool operator <(opt a,opt b){return (a.ti==b.ti)?(a.tp<b.tp):(a.ti<b.ti);}
}op[3*N];int hd;
struct linetree
{
	multiset <int> s[4*N];int v[4*N];multiset <int> til;
	inline void build(int p,int l,int r)
	{
		int mid=(l+r)/2;v[p]=0x3f3f3f3f;if(r-l==1)return;
		build(p<<1,l,mid);build(p<<1|1,mid,r);
	}
	inline void ins(int p,int l,int r,const int& pos,const int& val)//插入 
	{
		if(r-l==1){s[p].insert(val);v[p]=*(s[p].begin());return;}int mid=(l+r)/2;
		if(pos<=mid)ins(p<<1,l,mid,pos,val);else ins(p<<1|1,mid,r,pos,val);
		v[p]=min(v[p<<1],v[p<<1|1]);
	}
	inline void del(int p,int l,int r,const int& pos,const int& val)//删除 
	{
		if(r-l==1){ers(s[p],val);v[p]=s[p].empty()?0x3f3f3f3f:*(s[p].begin());return;}int mid=(l+r)/2;
		if(pos<=mid)del(p<<1,l,mid,pos,val);else del(p<<1|1,mid,r,pos,val);
		v[p]=min(v[p<<1],v[p<<1|1]);
	}
	inline void modify(int p,int l,int r,const int& pos,const int& val1,const int& val2)//修改 
	{
		if(r-l==1){ers(s[p],val1);s[p].insert(val2);v[p]=*(s[p].begin());return;}int mid=(l+r)/2;
		if(pos<=mid)modify(p<<1,l,mid,pos,val1,val2);
		else modify(p<<1|1,mid,r,pos,val1,val2);v[p]=min(v[p<<1],v[p<<1|1]);
	}
	inline int query(int p,int l,int r,int dl,int dr)//区间最小值 
	{
		if(dl==l&&dr==r){return v[p];}int ret=0x3f3f3f3f;int mid=(l+r)/2;
		if(dl<mid)ret=min(ret,query(p<<1,l,mid,dl,min(dr,mid)));
		if(mid<dr)ret=min(ret,query(p<<1|1,mid,r,max(dl,mid),dr));
		return ret;
	}
	inline void imd(const int& v){til.insert(v);}//单开的set的操作 
	inline void pmd(const int& v){ers(til,v);}
	inline int cquery(int r){if(r==n+1)return *(til.begin());//判一下是否越界 
	return min(*(til.begin()),query(1,0,n,r-1,n));}
}lt;multiset <int> col[N];int cnt;
inline void ins(int pos,int k)//更改pre值的插入，分4种情况讨论有无前驱后继 
{
	multiset <int>::iterator it,it1,it2;if(col[k].empty())cnt++;it=col[k].insert(pos);
	if(it!=--col[k].end()) 
	{
		int pre=-0x3f3f3f3f;it2=it;++it2;if(it!=col[k].begin()){it1=it;--it1;pre=*it1;}
		lt.modify(1,0,n,mp[*it2],pre,*it);lt.ins(1,0,n,mp[*it],pre);
	}else 
	{
		int pre=-0x3f3f3f3f;if(it!=col[k].begin()){it1=it;--it1;pre=*it1;}
		lt.ins(1,0,n,mp[*it],pre);lt.pmd(pre);lt.imd(*it);
	}
}
inline void del(int pos,int k)//同理删除的时候，分4种情况讨论有无前驱后继 
{
	multiset <int>::iterator it,it1,it2;it=col[k].find(pos);
	if(it!=--col[k].end())
	{
		int pre=-0x3f3f3f3f;it2=it;++it2;if(it!=col[k].begin()){it1=it;--it1;pre=*it1;}
		lt.modify(1,0,n,mp[*it2],*it,pre);lt.del(1,0,n,mp[*it],pre);
	}else 
	{
		int pre=-0x3f3f3f3f;if(it!=col[k].begin()){it1=it;--it1;pre=*it1;}
		lt.del(1,0,n,mp[*it],pre);lt.pmd(*it);lt.imd(pre);
	}ers(col[k],pos);if(col[k].empty())cnt--;
}
inline int query(int pos)//二分答案 
{
	if(cnt!=m)return -1;int l=0;int r=1e8+10;
	while(l!=r)
	{
		int mid=(l+r)/2;int mi=lt.cquery(mp.find(pos+mid+1));
		if(mi<pos-mid)l=mid+1;else r=mid;
	}return l;
}
int main()
{ 
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1,ti1,ti3,pos,col;i<=n;i++)
	{
		scanf("%d%d%d%d",&pos,&col,&ti1,&ti3);mp.ins(pos);
		op[++hd]=(opt){ti1,1,col,pos};op[++hd]=(opt){ti3,3,col,pos};
	}mp.build();
	for(int i=1,ti,pos;i<=q;i++){scanf("%d%d",&pos,&ti);op[++hd]=(opt){ti,2,i,pos};}
	sort(op+1,op+hd+1);lt.build(1,0,n);
	for(int i=1;i<=hd;i++)
	{
		switch(op[i].tp)
		{
			case 1:{ins(op[i].pos,op[i].k);break;}
			case 2:{ans[op[i].k]=query(op[i].pos);break;}
			case 3:{del(op[i].pos,op[i].k);break;}
		}
	}for(int i=1;i<=q;i++)printf("%d\n",ans[i]);return 0;//拜拜程序~ 
}
```









---

## 作者：lhm_ (赞：24)

首先考虑可以用二分答案来解决询问，可以二分一个长度$len$，若在区间$[x-len,x+len]$内包含了所有$k$种的商店，那么这个$len$就是合法的，可以通过二分来求其最小值。

对每个商店的存在时间转化为在$a$时刻出现，在$b+1$时刻消失，然后和询问一起离线按时间排序，就可以解决时间这一维的限制了。

然后考虑如何快速查询区间内是否包含所有的商店，和支持维护商店的出现消失。

对于这种区间数颜色的问题，可以对每个位置记录与其商店类型相同的上一个位置$pre$，发现一个位置上可能会有多个商店，那么这里的$pre$改为记录这些商店的到其各自商店类型相同的上一个位置的最小值。

$pre$是记录该位置商店类型相同的上一个位置，所以对于区间$[l,r]$，如果从$r+1$往后的所有位置的$pre$的最小值小于$l$，那么说明至少有一种商店没在该区间出现。但是$r+1$往后可能并不会包含所有$k$种商店，因此加入哨兵商店来避免讨论，分别在最前面和最后面加入每种商店各一个。

然后就是如何支持维护$pre$，对于每个位置开一个$multiset$维护该位置所有商店的对应其商店类型的前驱，$multiset$中的最小值即为该位置的$pre$，然后用线段树动态开点来维护区间$pre$的最小值，这里其实就是在线段树的每个叶子节点开了一个$multiset$来维护信息。

对于商店的出现消失维护，对每种商店类型开一个$multiset$，维护该类型所有商店的出现位置，然后出现和消失只用解决对于该位置同类型的前驱和后继的影响就行，线段树单点修改即可实现。

若用线段树查询最小值来判定二分，复杂度是$O(n\ log^2\ n)$的，可以直接在线段树上二分位置，复杂度就是$O(n\ log\ n)$的了。

细节挺多，具体实现就看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 900010
#define all 200000000
#define mid ((l+r)>>1)
using namespace std;
typedef multiset<int>::iterator muli;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,k,q,tot,root,tree_cnt,num;
int mi[maxn*20],ls[maxn*20],rs[maxn*20],ans[maxn];
multiset<int> p[maxn],s[maxn*20];
struct node
{
    int pos,tim,id,opt;
}t[maxn];
bool cmp(const node &a,const node &b)
{
    if(a.tim==b.tim) return a.opt<b.opt;
    return a.tim<b.tim;
}
void modify(int l,int r,int pos,int v,int type,int &cur)
{
    if(!cur) cur=++tree_cnt;
    if(l==r)
    {
        if(type) s[cur].insert(v);
        else s[cur].erase(s[cur].find(v));
        if(!s[cur].empty()) mi[cur]=*s[cur].begin();
        else mi[cur]=all;
        return;
    }
    if(pos<=mid) modify(l,mid,pos,v,type,ls[cur]);
    else modify(mid+1,r,pos,v,type,rs[cur]);
    mi[cur]=min(mi[ls[cur]],mi[rs[cur]]);
}
int query(int pos)
{
    if(num<k) return -1;
    int l=1,r=all,cur=root,midmi,rmi=all;
    while(l<r)
    {
        midmi=min(rmi,mi[rs[cur]]);
        if(pos>mid||midmi<2*pos-mid) cur=rs[cur],l=mid+1;
        else rmi=midmi,cur=ls[cur],r=mid;
    }
    return l-pos;
}
int main()
{
    read(n),read(k),read(q),mi[0]=all;
    for(int i=1;i<=k;++i)
    {
        p[i].insert(-all),p[i].insert(all);
        modify(1,all,all,-all,1,root);
    }
    for(int i=1;i<=n;++i)
    {
        int x,id,a,b;
        read(x),read(id),read(a),read(b);
        t[++tot]=(node){x,a,id,1};
        t[++tot]=(node){x,b+1,id,0};
    }
    for(int i=1;i<=q;++i)
    {
        int pos,tim;
        read(pos),read(tim);
        t[++tot]=(node){pos,tim,i,2};
    }
    sort(t+1,t+tot+1,cmp);
    for(int i=1;i<=tot;++i)
    {
        int opt=t[i].opt,id=t[i].id,pos=t[i].pos;
        muli a,b;
        if(opt==0)
        {
            a=b=p[id].lower_bound(pos),a--,b++;
            modify(1,all,*b,pos,0,root);
            modify(1,all,*b,*a,1,root);
            modify(1,all,pos,*a,0,root);
            if(p[id].size()==3) num--;
            p[id].erase(p[id].find(pos));
        }
        if(opt==1)
        {
            a=b=p[id].lower_bound(pos),a--;
            modify(1,all,*b,pos,1,root);
            modify(1,all,*b,*a,0,root);
            modify(1,all,pos,*a,1,root);
            if(p[id].size()==2) num++;
            p[id].insert(pos);
        }
        if(opt==2) ans[id]=query(pos);
    }
    for(int i=1;i<=q;++i) printf("%d\n",ans[i]);
    return 0;
}
```


---

## 作者：Aly_ (赞：10)

**题意简述**

-  数轴上有 $n$ 个点，每个点有其位置 $x_i$ 和颜色 $t_i$，且在时间段 $[a_i,b_i]$ 中出现。总共有 $K$ 种颜色。
- 有 $q$ 个询问，每次询问在 $y_i$ 时刻所有颜色中距离位置 $l_i$ 最远的颜色。某个时刻下位置 $l_i$ 和颜色 $c_j$ 的距离定义为当时存在的所有颜色为 $ c_j$ 的点与 $l_i$ 距离的最小值。
- $n,q,K\le3\times10^5;x_i,t_i,a_i,b_i,l_i,y_i\le10^8$。

**分析**

​	离散化+线段树二分。

​	首先，询问和操作是离线的。容易想到把所有事件（点的出现，点的消失，询问）按时间排序后从小往大处理。

​	先不考虑 $x_i$ 的范围，就假设所有的位置组成一个排列好了。

​	“最小值”的“最大值”，想到二分答案。

​	顺着这个思路想下去，容易想到：每次询问时二分答案，假设当前二分的答案为 $X$，如果所有颜色都有至少一个点出现在了区间 $[l_i-X,l_i+X]$ 中，则说明所有颜色与 $l_i$ 距离都小于等于 $X$，进而意味着该答案可行。

​	如何查询所有颜色都出现在了当前区间中？

​	区间数颜色：对于每个点，记录和它同颜色的点中在它前面离它最近的点（不妨称为它的前驱）的位置，如果该点是该颜色的第一个点，把前驱设为 $-1$ 。特别地，我们在最后面新加一排 $K$ 个点，每个点顺次对应一种颜色，且把它的前驱设为该颜色出现的最后位置。（参照下图理解：我们用箭头表示前驱，最后三个格子是新加的三个点）

​	我们把所有点的前驱位置放到线段树上。

​	现设当前我们想知道区间 $[l,r]$ 中是否出现了所有颜色。我们查询区间 $[r+1,n+K]$的最小值，如果该最小值大于等于 $l$ ，则该区间出现了所有颜色。这样做的正确性是显然（？）的：最小值大于 $l$ 意味着所有后面的点的前驱都在 $l$ 之后，而刚刚新加的一排点保证了所有颜色都在 $r$ 后面出现了，于是在 $[l,r]$ 中间必定出现了所有颜色；反之，若最小值小于 $l$，则必定会出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/r88xv75v.png)

​	发现，蓝色的前驱“跨过了”该区间，于是蓝色未出现在其中。

​	线段树区间查询最小值即可。

​	回到原问题，发现套上二分答案后，我们可以 $O(log^2n)$ 一次询问。考虑加入/删除点的过程，我们可以轻松地使用 set 维护（每种颜色开一个 set，查询前驱后继）然后线段树两次单点修改。于是我们得到一个 $O(Q\log^2n+n \log n)$ 的做法。

​	考虑优化。刚刚是二分答案+线段树，我们变成线段树上二分：每次二分的答案的右端点为线段树上区间的中点。这样可以把询问降一个 log ，于是用 $O(Q\log n+n \log n)$ 的复杂度通过了本题......吗？

​	原问题 $x_i$ 的范围很大。我们使用离散化，注意离散化后不要去重。保存离散化后两相邻点的距离。注意**一点点**细节：新加的一排点位置为 $+inf$ ，每种颜色的第一个点前驱 $-inf$ ，线段树二分的时候算真实距离而不是离散化后的位置之差，把 set 换成 multiset 并且每次只删一个。

​	**据说我码风奇异**：

```
#include<bits/stdc++.h>
#include<algorithm>
#include<set>
#define mid (l+r)/2
#define inf 999999999
using namespace std;
int n,K,Q,m,pb;
int dic[1000001],pdic,stdans[1000001],nu[1000001],ncl;
int seg[4000001],aans[1000001];
multiset<int> se[300001];
struct eve{
	int x,k,l,r;
}a[300001];
struct que{
	int x,t,bh;
}q0[300001];
struct thi{
	int ty,nx,t;
	const bool operator <(thi y)const{if(this->t==y.t)return this->ty<y.ty;return this->t<y.t;}
}b[1000001];
int qread(){int nans=0;char c=getchar();while(c<'0'||c>'9')c=getchar();while(c>='0'&&c<='9')nans=nans*10+c-'0',c=getchar();return nans;}
void putin(){
	n=qread(),K=qread(),Q=qread();
	for(int i=1;i<=n;i++)a[i].x=qread(),a[i].k=qread(),a[i].l=qread(),a[i].r=qread();
	for(int i=1;i<=Q;i++)q0[i].x=qread(),q0[i].t=qread(),q0[i].bh=i;
}
void caldic(){
	for(int i=1;i<=n;i++)dic[++pdic]=a[i].x,b[++pb]=(thi){1,i,a[i].l},b[++pb]=(thi){1,i,a[i].r+1};
	for(int i=1;i<=Q;i++)dic[++pdic]=q0[i].x,b[++pb]=(thi){2,i,q0[i].t};
	sort(dic+1,dic+pdic+1);
	m=pdic+K;sort(b+1,b+pb+1);
	for(int i=1;i<=n;i++){
		int np=lower_bound(dic+1,dic+pdic+1,a[i].x)-dic;
		a[i].x=np+(nu[np]++);
	}
	for(int i=1;i<=Q;i++){
		int np=lower_bound(dic+1,dic+pdic+1,q0[i].x)-dic;
		q0[i].x=np+(nu[np]++);
	}
}
void segbuild(int u,int l,int r){
	if(l==r){
		if(l>pdic)seg[u]=-1;
		else seg[u]=inf;
	}else{
		segbuild(u<<1,l,mid);
		segbuild(u<<1|1,mid+1,r);
		seg[u]=min(seg[u<<1],seg[u<<1|1]);
	}
}
void segadd(int u,int l,int r,int np,int nx){
	if(l==r)seg[u]=nx;
	else{
		if(np<=mid)segadd(u<<1,l,mid,np,nx);
		else segadd(u<<1|1,mid+1,r,np,nx);
		seg[u]=min(seg[u<<1],seg[u<<1|1]);
	}
}
int segreq(int u,int l,int r,int nl,int nr){
	if(l>nr||r<nl)return inf;
	else if(l>=nl&&r<=nr)return seg[u];
	else return min(segreq(u<<1,l,mid,nl,nr),segreq(u<<1|1,mid+1,r,nl,nr));
}
int segef(int u,int l,int r,int nx,int nm){
	if(l==r)return max(dic[l]-nx,nx-dic[nm]);int ng=min(nm,seg[u<<1|1]);
	if(ng!=-1&&(ng==inf||dic[ng]>=max(0,nx-(dic[mid+1]-1-nx))))return segef(u<<1,l,mid,nx,ng);
	else return segef(u<<1|1,mid+1,r,nx,nm);
}
signed main(){
	putin();
	caldic();
	segbuild(1,1,m);
	for(int i=1;i<=K;i++)se[i].insert(pdic+i),dic[pdic+i]=inf;
	for(int i=1;i<=pb;i++){
		if(b[i].ty==1){
			int ni=b[i].nx;
			if(b[i].t>a[ni].r)se[a[ni].k].erase(se[a[ni].k].find(a[ni].x));
			multiset<int>::iterator ii=se[a[ni].k].lower_bound(a[ni].x);
			int np,nq;
			np=*ii;
			if(ii!=se[a[ni].k].begin())nq=*(--ii);else nq=-1;
			if(b[i].t>a[ni].r)segadd(1,1,m,np,nq),segadd(1,1,m,a[ni].x,inf);
			else segadd(1,1,m,np,a[ni].x),segadd(1,1,m,a[ni].x,nq),se[a[ni].k].insert(a[ni].x);
		}else{
			if(segreq(1,1,m,pdic+1,m)==-1)aans[q0[b[i].nx].bh]=-1;
			else{
				aans[q0[b[i].nx].bh]=segef(1,1,m,dic[q0[b[i].nx].x],inf);
			}
		}
	}
	for(int i=1;i<=Q;i++)printf("%d\n",aans[i]);
	return 0;
}
```

​	

---

## 作者：WaterSun (赞：7)

[更好的阅读体验](https://watersun.top/%5B%E9%A2%98%E8%A7%A3%5DP4632%20%5BAPIO2018%5D%20%E6%96%B0%E5%AE%B6/)

# 思路

首先有一个比较典的转化，因为本题中，有坐标和时间两种限制，于是考虑离线下来，按照时间依次进行操作。

我们可以考虑二分答案 $len$ 则 `check` 函数就是判断 $[x - len,x + len]$ 区间中是否所有 $k$ 中店铺都出现过。

有一个比较巧妙的方法，记录每一种店铺上次出现的位置 $pre_i$。

这个如果在 $i > x + len$ 且满足 $pre_i < x - len$，则这种情况一定不合法。原因比较简单，如果这种店铺上一次出现的位置小于 $x - len$，说明在 $[x - len,x + len]$ 中没有出现。

但是单单是这个条件是不够的，因为有可能有一些类型的店铺并没有在大于 $x + len$ 的区间中出现。那么考虑对于每一种店铺初始状态时添加两个哨兵 $\pm\infty$。

这样下来，如果有种类型的店铺没有出现过将会由 $+\infty$ 的哨兵，返回其前驱，减少了大量的分讨。

那么我们只需要快速查询大于 $x + len$ 的前驱最小值，这显然是可以通过线段树 $\Theta(\log n)$ 查询的。那么总时间复杂度是 $\Theta(n \log^2 n)$ 的，比较紧张，但是将二分直接转到线段树上二分是 $\Theta(n \log n)$ 的了。

# Code

```cpp
#include <bits/stdc++.h>
#define re register

using namespace std;

const int N = 1e6 + 10,M = 3e5 + 10,inf = 1e9 + 10;
int n,m,q,rt,num;
int ans[N];
multiset<int> pre[N];

struct Query{
    int op,x,tim,ty;

    bool friend operator <(const Query &a,const Query &b){
        if (a.tim != b.tim) return a.tim < b.tim;
        return a.op < b.op;
    }
};
vector<Query> Q;

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

struct seg{
    #define ls(u) (tr[u].l)
    #define rs(u) (tr[u].r)
    #define st(u) (tr[u].st)

    int idx;

    struct node{
        int l,r,Min;
        multiset<int> st;
    }tr[M * 30];

    inline void pushup(int u){
        tr[u].Min = min(tr[ls(u)].Min,tr[rs(u)].Min);
    }

    inline void insert(int &u,int l,int r,int x,int k,int falg){
        if (!u) u = ++idx;
        if (l == r){
            if (falg == 1) st(u).insert(k);
            else st(u).erase(st(u).find(k));
            if (st(u).empty()) tr[u].Min = inf;
            else tr[u].Min = (*st(u).begin());
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid) insert(ls(u),l,mid,x,k,falg);
        else insert(rs(u),mid + 1,r,x,k,falg);
        pushup(u);
    }

    inline int query(int x){
        if (num < m) return -1;
        int u = rt,l = 1,r = inf,lst = inf;
        // 由于当 u 向左递归时右端点会向左移动，原本能取到的最小值可能取不到了，因此用 lst 记录一下
        while (l < r){
            int mid = l + r >> 1;
            int Min = min(lst,tr[rs(u)].Min);
            if (mid < x || Min < 2 * x - mid) u = rs(u),l = mid + 1;
            else lst = Min,u = ls(u),r = mid;
        }
        return l - x;
    }

    #undef ls
    #undef rs
    #undef st
}T;

int main(){
    T.tr[0].Min = inf;
    n = read(),m = read(),q = read();
    for (re int i = 1;i <= m;i++){
        pre[i].insert(-inf); pre[i].insert(inf);
        T.insert(rt,1,inf,inf,-inf,1);
    }
    for (re int i = 1;i <= n;i++){
        int x,ty,l,r;
        x = read(),ty = read(),l = read(),r = read();
        Q.push_back({1,x,l,ty}); Q.push_back({2,x,r + 1,ty});
    }
    for (re int i = 1;i <= q;i++){
        int x,tim;
        x = read(),tim = read();
        Q.push_back({3,x,tim,i});
    }
    sort(Q.begin(),Q.end());
    for (auto p:Q){
        if (p.op == 1){
            auto jt = pre[p.ty].lower_bound(p.x); auto it = prev(jt);
            T.insert(rt,1,inf,p.x,*it,1); T.insert(rt,1,inf,*jt,*it,2); T.insert(rt,1,inf,*jt,p.x,1);
            if (pre[p.ty].size() == 2) num++;
            pre[p.ty].insert(p.x);
        }
        else if (p.op == 2){
            auto jt = pre[p.ty].lower_bound(p.x); auto it = prev(jt); jt = next(jt);
            T.insert(rt,1,inf,*jt,p.x,2); T.insert(rt,1,inf,p.x,*it,2); T.insert(rt,1,inf,*jt,*it,1);
            pre[p.ty].erase(pre[p.ty].find(p.x));
            if (pre[p.ty].size() == 2) num--;
        }
        else ans[p.ty] = T.query(p.x);
    }
    for (re int i = 1;i <= q;i++) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：Acee (赞：5)

一个 $\log$ 的做法：

首先对时间扫描线，然后将最优性问题转化为二分 $+$ 判定性问题（也就是二分答案）。

再来看同一时刻的询问，这时已经去掉时间的限制，所以再按坐标进行扫描线。

然后看如何快速查询区间内是否包含所有的店，和支持维护店的出现消失。

 $[x,y]$ 是否包含所有店：
 
也就是有一种店在 $[x,y]$ 内没开，等价于在 $y$ 之后，有商店的前驱 $\le x$。

使用之前的答案来进行更新，可以使用堆维护最远答案，可以将堆换成线段树。

对每种店开个 set 以及全局开个线段树维护区间最小前驱即可。

因为线段树和二分都是维护距离的，所以可以变成线段树上二分，这样就只有一个 $\log$ 了。

这里使用了常数较小的 zkw 线段树，可以换成递归版线段树。

代码：

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_pbds;
using ll = long long;
namespace Main {
	const int N = 3e5 + 5, T = (1 << 19) + N, inf = 1e8 + 5;
	int n, k, Q;
	int tot;
	int a[N];
	void init(int sz) {
		sort(a + 1, a + 1 + sz);
		tot = unique(a + 1, a + 1 + sz) - a - 1;
	}
	int get(int x) {
		return lower_bound(a + 1, a + 1 + tot, x) - a;
	}
	struct Heap {
		__gnu_pbds :: priority_queue<int, greater<int> > a, b;
		void push(int x) {
			a.push(x);
		}
		void del(int x) {
			b.push(x);
		}
		int top() {
			while (!b.empty() && a.top() == b.top()) {
				a.pop();
				b.pop();
			}
			return a.top();
		}
	};
	namespace segmenttree {
		int n, M;
		Heap q[N];
		struct tree {
			int maxx, minn;
		} t[T];
		void init(int sz, int k) {
			n = sz;
			for (M = 1; M < n; M <<= 1);
			--M;
			for (int i = n + M + 1; i >= 1; --i) t[i].minn = inf;
			for (int i = 1; i <= n; ++i) q[i].push(inf);
			for (int i = 1; i <= k; ++i) q[n].push(-inf);
			for (int i = n + M; i; i >>= 1) {
				t[i].minn = -inf;
			}
			for (int i = 1; i < n; ++i) {
				t[i + M].maxx = a[i];
			}
			t[M + n].maxx = inf * 2;
			for (int i = M; i >= 1; --i) {
				t[i].maxx = max(t[i << 1].maxx, t[i << 1 | 1].maxx);
			}
		}
		int query(int x) {
			if (t[n + M].minn == -inf) {
				return -1;
			}
			int i = 1, now = inf;
			while (i <= M) {
				if (x > t[i << 1].maxx) {
					i = i << 1 | 1;
					continue;
				}
				if (t[i << 1].maxx + 1 + min(t[i << 1 | 1].minn, now) <= 2 * x) {
					i = i << 1 | 1;
				} else {
					now = min(t[i << 1 | 1].minn, now);
					i = i << 1;
				}
			}
			return min(2 * x - min(now, t[i].minn), t[i].maxx) - x;
		}
		void update(int i) {
			t[i + M].minn = q[i].top();
			i += M;
			while (i >>= 1) {
				if (t[i].minn == min(t[i << 1].minn, t[i << 1 | 1].minn)) {
					break;
				}
				t[i].minn = min(t[i << 1].minn, t[i << 1 | 1].minn);
			}
		}
		void add(int i, int x) {
			q[i].push(x);
			update(i);
		}
		void del(int i, int x) {
			q[i].del(x);
			update(i);
		}
		void add_del(int i, int x0, int x) {
			q[i].del(x0);
			q[i].push(x);
			update(i);
		}
	}
	multiset<int> S[N];
	void add(multiset<int> &s, int x) {
		multiset<int> :: iterator it1 = s.insert(x), it2 = it1;
		--it1;
		++it2;
		segmenttree :: add(get(x), *it1);
		segmenttree :: add_del(get(*it2), *it1, x);
	}
	void del(multiset<int> &s, int x) {
		multiset<int> :: iterator it = s.lower_bound(x), it1 = it, it2 = it1;
		--it1;
		++it2;
		segmenttree :: del(get(x), *it1);
		segmenttree :: add_del(get(*it2), x, *it1);
		s.erase(it);
	}
	struct node {
		int x, t, a;
		void add() {
			Main :: add(S[t], x);
		}
		void del() {
			Main :: del(S[t], x);
		}
		bool operator < (const node &it) const {
			return a < it.a;
		}
	} qa[N], qb[N], query[N];
	int Ans[N];
	int main() {
		ios::sync_with_stdio(false);
		cin.tie(0), cout.tie(0);
		cin >> n >> k >> Q;
		for (int i = 1, x, t, a, b; i <= n; ++i) {
			cin >> x >> t >> a >> b;
			qa[i] = {x, t, a};
			qb[i] = {x, t, b};
			Main :: a[i] = x;
		}
		init(n);
		segmenttree::init(tot + 1, k);
		for (int i = 1, x, a; i <= Q; ++i) {
			cin >> x >> a;
			query[i] = {x, i, a};
		}
		sort(qa+1, qa+1+n);
		sort(qb+1, qb+1+n);
		sort(query + 1, query+Q+1);
		for (int i=1; i<=k; ++i) {
			S[i].insert(-inf);
			S[i].insert(inf);
		}
		for (int i=1, cura=1, curb=1; i<=Q; ++i) {
			while (cura <=n && qa[cura].a<= query[i].a) {
				qa[cura++].add();
			}
			while (curb <= n &&qb[curb].a < query[i].a) {
				qb[curb++].del();
			}
			Ans[query[i].t] = segmenttree :: query(query[i].x);
		}
		for (int i = 1; i <= Q; ++i) {
			cout<< Ans[i] <<'\n';
		}
		return 0;
	}
}
int main() {
	Main :: main();
	return 0;
}
```

---

## 作者：凄魉 (赞：5)

我的做法是按时间离线后，用一颗线段树维护每种现在存在的同种类型的商店的前驱，对于一次询问在位置$x$，然后在线段树上二分找出某个位置$\text [i,+\infty)$。使得这个区间内的前驱的最小值$mn<2x-i$


思路就是同kcz大佬：https://loj.ac/article/523。

在这里我就不阐述算法思路，而是重点阐述我的实现与我写代码时的细节问题。

先把每一个商店看成在$a$时间点添加进来，在$b+1$时间点删除。然后只对商店的位置离散化，用一个$pos[i]$数组表示离散化后的$i$原先对应在数轴上的哪个位置，之后线段树、multiset的元素都是以离散化后的这个值来运算的。

然后将离散化后的商店与询问一起按照时间排序，这里我用结构体$store$存储这些信息，其中如果是商店，那么$idx$是$-1$和$-2$,分别代表插入与删除，如果是询问则$idx>0$，代表对应着原来是第几个询问,并且询问的$x$没有离散化，是原来的值。

用$N$个$multiset$维护每种元素的前驱。为了防止在某次查询$[i,+\infty)$中没有出现某一种颜色的这种情况，我们在$multiset$里预先插入一个$+\infty$。其实更好地办法是插入$+\infty$，$-\infty$两个元素，这样就不用特判没有前驱/后继的情况，并且这种写法对后面二分时的细节也有把控作用，稍后再说。因为我只插了$+\infty$，并且如果前面没有元素，我还要求这时的前驱应该是0。所以我特判了前面没有元素的情况。

用一个$all$变量维护当前出现了多少种商店，配合$multiset$的$size$来修改这个变量。利用all先把不合法的情况判出来。

线段树维护离散化后的至多$2n+1$个位置（多一个$+\infty$）的前驱的信息。叶子上是一个可删堆，因为可能会在同一个位置出现不同类型的商店。线段树区间节点上维护前驱的min。

然后是在线段树上二分，二分找出坐标$>x$的第一个线段树上的位置p（即离散化后的点），使得查询位置$x$满足区间$[x-p,x+p]$出现了所有的颜色。具体的实现是首先保证位置大于$x$，所以如果$x$大于$mid$代表的位置(即$pos[mid]$)，那么就往右走。第二步就判断当前$mid$能不能使$x$合法，如果$mid$合法，那么大于$mid$的点也一定合法，那么我们要判断$[2x-pos[mid],pos[mid]]$这个区间是否出现过所有元素。查这个我就要查$mid+1$到$+\infty$的所有点的前驱的$min$是否小于$2x-pos[mid]$，小于则不合法。用一个$now$变量维护每次向左走，右儿子区间的前驱的$min$。

在我的写法中这样二分要判断一个情况，是如果出现一个点的前驱是$0$（即这个元素前面再也没出现过这种元素），我会访问$pos[0]$。但我们希望如果出现我查到的前驱的$min$是$0$，那么这个$mid$就不合法，所以我设置$pos[0]=-\infty$，这也是我前面说为什么在$multiset$中添加一个$-\infty$会好一些。

再说一下找到了线段树上的位置，那么究竟答案是什么？我们知道一个点的最优解中，一定有一个端点上会是一个商店，但是我们的二分只保证了右端点是商店，所以可能不是最优解，所以答案还可能是$x-$前驱。所以我们对这两种情况取min就行。然后又因为可能二分到线段树上的位置是$+\infty$，所以我们还要设置$pos[+\infty]=+\infty$，以免对取min产生影响。

该说的都说了……

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<set>
#include<queue>
#include<vector>
#include<cstring>
using namespace std;
#define N 300100
#define INF 0x3f3f3f3f
#define ls i<<1
#define rs i<<1|1
struct store{
	int x,y,t,idx;
	bool operator < (const store &B) const {return t==B.t?idx<B.idx:t<B.t;}
}sr[N<<2];
bool cmp(const store &A,const store &B) {return A.x<B.x;}
int ans[N],pos[N<<2],minm[N<<3],n,tot;
struct Heap{
	priority_queue<int,vector<int>,greater<int> > I,D;int sz;
	void pop(int x) {D.push(x);--sz;}
	void push(int x) {I.push(x);++sz;}
	void update() {while(D.size()&&I.top()==D.top()) D.pop(),I.pop();}
	int top() {update();return sz?I.top():INF;}
}H[N<<2];
multiset<int> S[N];
multiset<int>::iterator it;
void insert(int i,int l,int r,int p,int pre,int d)
{
	if (l==r)
	{
		if (d==1) H[l].push(pre);else H[l].pop(pre);
		minm[i]=H[l].top();
		return;
	}
	int mid=(l+r)>>1;
	if (p<=mid) insert(ls,l,mid,p,pre,d);
	else insert(rs,mid+1,r,p,pre,d);
	minm[i]=min(minm[ls],minm[rs]);
}
int query(int x)
{
	int l=1,r=tot,i=1,mid,now=INF;
	while(l<r)
	{
		mid=(l+r)>>1;
		if (x>pos[mid]) {i=rs;l=mid+1;continue;}
		if (2*x<=pos[mid]+pos[min(now,minm[rs])])//前驱不能为0，设置pos[0]=-INF解决这个问题 
		{
			now=min(now,minm[rs]);
			i=ls;r=mid;
		}else i=rs,l=mid+1;
	}
	return min(pos[l]-x,x-pos[min(now,minm[i])]);
}
inline int read(){
	int n=0;char a;bool z=false;
	while(a=getchar())
	{
		if (a>'9'||a<'0')
			if (z) break;
			else continue;
		if (!z) z=true;
		n=(n<<1)+(n<<3)+(a^48);
	}
	return n;
}
int main()
{
	memset(minm,0x3f,sizeof(minm));
	n=read();int k=read(),Q=read(),x,y,all=0,t=0;bool Z;
	for (int i=1;i<=n;++i)
	{
		x=read();y=read();
		sr[i]=(store){x,y,read(),-1};
		sr[i+n]=(store){x,y,read()+1,-2};
	}
	for (int i=1;i<=Q;++i) sr[n+n+i]=(store){read(),0,read(),i};
	sort(sr+1,sr+1+n+n,cmp);
	for (int i=1;i<=n<<1;++i)
	{
		if (i==1||sr[i].x^pos[sr[i-1].x]) pos[++tot]=sr[i].x;
		sr[i].x=tot;
	}++tot;
	sort(sr+1,sr+1+n+n+Q);pos[0]=-INF;pos[tot]=2*INF;
	for (int i=1;i<=k;++i) S[i].insert(tot),insert(1,1,tot,tot,0,1);
	for (int i=1;i<=n+n+Q;++i)
	{
		store u=sr[i];
		switch(u.idx)
		{
			case -1:
				if (S[u.y].find(u.x)==S[u.y].end())
				{
					all+=S[u.y].size()==1;
					it=S[u.y].insert(u.x);y=0;
					if (it!=S[u.y].begin())
					{
						--it;
						insert(1,1,tot,u.x,y=*it,1);
						++it;
					}else insert(1,1,tot,u.x,0,1);
					++it;
					insert(1,1,tot,*it,y,-1);
					insert(1,1,tot,*it,u.x,1);
				}else S[u.y].insert(u.x);break;
			case -2:
				it=S[u.y].find(u.x);
				Z=it==S[u.y].begin();
				S[u.y].erase(it--);
				if (S[u.y].find(u.x)==S[u.y].end())
				{
					y=0;
					insert(1,1,tot,u.x,y=(Z?0:*it++),-1);
					if (Z) it=S[u.y].begin();
					insert(1,1,tot,*it,u.x,-1);
					insert(1,1,tot,*it,y,1);
					all-=S[u.y].size()==1;
				}break;
			default:
				if (all^k) {ans[u.idx]=-1;break;}
				ans[u.idx]=query(u.x);break;
		}
	}
	for (int i=1;i<=Q;++i) printf("%d\n",ans[i]);
	return 0;
}

//by qlwpc
```

---

## 作者：lzyqwq (赞：4)

这种题还要看题解，我菜完了。

---



**[P4632 [APIO2018] 新家](https://www.luogu.com.cn/problem/P4632)**

> - 海岸线可以看作是一条数轴。有 $n$ 朵烟花，第 $i$ 朵烟花位于 $x_i$ 的位置，颜色为 $t_i$，绽放时间为 $[a_i,b_i]$。一共有 $k$ 种颜色。
> - 典道和菜津奈决定去看 $q$ 次烟花。第 $i$ 次她们会在 $y_i$ 时刻到达 $l_i$ 位置。
> - 称某一时刻 $v$ 时一种颜色 $c$ 到某个位置 $p$ 的距离 $D(v,c,p)$ 为当前存在的颜色为 $c$ 的所有烟花中与 $p$ 距离的最小值，形式化地，$D(v,c,p)=\min\limits_{t_i=c\,\land \,a_i\le v\le b_i}|x_i-p|$。
> - 她们想知道 $y_i$ 时刻所有颜色到 $l_i$ 距离的最大值 $D_{\max}$。形式化地，您需要告诉她们 $D_{\max}=\max\limits_{j=1}^kD(y_i,j,l_i)$。
> - $n,k,q\le 3\times 10^5$，值域 $V=[1,10^8]\cap\mathbb{Z}$。

默认 $\mathcal{O}(n)=\mathcal{O}(k)=\mathcal{O}(q)$。

按照时间扫描线，维护当前时刻的烟花。则第 $i$ 朵烟花在 $a_i$ 时刻被插入，在 $b_i+1$ 时刻被删除。

记当前时刻为 $T$。

对于询问，考虑二分答案。若某个询问 $i$ 的答案 $\le X$，则要求 $T$ 时刻 $[l_i-X,l_i+X]\cap V$ 的位置内出现了所有颜色。

考虑对于每种颜色，强行加入位于 $0$ 位置和 $2|V|+1$ 位置的烟花，**钦定她们永远绽放**。考虑维护 $T$ 时刻每个 **烟花** $i$ 的 **严格前驱位置** $\text{pre}_i$。即在当前时刻颜色与 $i$ 相同的烟花中，位置 **严格小于** $i$ 的烟花的 **最大位置**。形式化地，$\text{pre}_i=\max\limits_{t_j=t_i\,\land\,x_j<x_i\,\land \,a_j\le T\le b_j}x_j$。

考虑如何判断 $T$ 时刻某个区间 $[l,r]\sube V$ 出现所有颜色。其等价于 $\min\limits_{a_i\le T\le b_i\,\land\,r<x_i\le 2|V|+1}\text{pre}_i\ge l$。

- **充分性**

  由于我们对于每种颜色强行加入位置为 $2|V|+1$ 的烟花，所以 $(r,2|V|+1]$ 内，每种颜色均存在烟花。考虑找到颜色 $c$ 这个区间内最左边的烟花 $L_c$，此时 $\text{pre}_{L_c}\le r$。由条件得 $\text{pre}_{L_c}\ge l$。由 $\text{pre}$ 的定义可知存在一颗颜色为 $c$ 的烟花位于 $\text{pre}_{L_c}$ 这个位置，因此对于任意一种颜色，$[l,r]$ 都出现了这种颜色的烟花。

- **必要性**

  若存在 $a_i\le T\le b_i$ 且 $r<x_i\le 2|V|+1$ 的 $i$ 使得 $\text{pre}_i<l$，则 $[l,r]$ 内一定不存在颜色为 $t_i$ 的烟花。

那么可以使用动态开点线段树，维护 $T$ 时刻该节点区间内存在的烟花的前驱的最小值。若不存在烟花则最小值无穷大。

对于插入 / 删除点的操作，考虑对每种颜色 $i$ 开一个 `set` $s_i$，这样可以快速计算前驱。$\text{pre}$ 受到影响的位置只有新插入的位置和其后面的一个位置。

但这题最恶心的地方在于 **有重复的点**。这样插入一个点 $p$ 时，会修改她的前驱，以及 **她后继位置所有同色点** 的前驱。

此时我们需要支持如下操作：

> 给出一个可重集 $S$，每次插入 / 删除 $w$ 个 $v$，求某个值 $m$ 的 **严格** 前驱 / 后继。

考虑同时维护一个 `map` $\text{mp}_i$，表示当前每个位置的烟花个数。每次插入 / 删除时先在 $\text{mp}_i$ 上修改，若当前位置 $p$ 的个数变为 $0$ 或由 $0$ 变得不为 $0$，则说明她不再 / 新出现。此时再在 $s_i$ 中插入 / 删除她即可。

对于线段树的叶子结点，我们需要维护这个位置的烟花的前驱集合 $M$ 中的最小值。由于前驱的修改，我们需要支持：

> 给出一个可重集 $M$，每次插入 / 删除 $w$ 个 $v$，求 $\min\limits_{u\in M}u$。

对于线段树的每个叶子，类似地开 `set` 和 `map` 维护，最小值就是当前 `set` 的头指针对应的元素。

对于一次修改，要递归 $\mathcal{O}(\log |V|)$ 个结点，而仅有叶子结点需要进行 $\mathcal{O}(\log n)$ 的 STL 操作，因此修改的时间复杂度仍是 $\mathcal{O}(\log |V|)$。

由于动态开点线段树结点数为 $\mathcal{O}(n\log |V|)$，而叶子个数为 $\mathcal{O}(n)$，因此考虑对叶子再使用一个编号，节省开 `set` 和 `map` 的空间。

这样我们已经有时间复杂度为 $\mathcal{O}\left(n\log^2|V|\right)$，空间复杂度为 $\mathcal{O}(n\log |V|)$ 的做法了。

考虑单 $\log$ 做法。发现二分和线段树契合得不是很好，考虑再线段树上二分。考虑 $l_i+X$ 这个位置，她是 **最大** 的使得 $\min\limits_{a_j\le T\le b_j\,\land\,p<x_j\le 2|V|+1}\text{pre}_j<\max\{2l_i-p+1,1\}$ 的 $p$。这个就是考虑二分答案 $X-1$ 时判定不合法的条件。随着 $p$ 递减，左式不降，右式不升。先求出 $2|V|+1$ 位置的最小值，然后把线段树上 $[l_i,2|V|]$ 对应的 $\mathcal{O}(\log |V|)$ 个区间拉出来。从右至左判断，扫到第一个左端点不合法的区间，则 $l_i+X$ 一定在这个区间内。再在这 **整棵子树** 内二分，判断区间中点是否合法，然后往对应的子树跳，直至叶子。

那么我们就可以通过得到的这个位置减去 $l_i$ 得到答案。

有个小细节，我们上述讨论满足 $[l,r]\sube V$，但事实上可能会出现 $l_i+X>|V|$ 的情况。前者好解决仅需要取 $\max$，但是后者在与 $V$ 取交时，右端点均是 $|V|$，此时不知道这个位置原本是谁，影响我们判断应该小于哪个左端点。一个比较好的处理方式是，在 $|V|$ 右侧再补 $|V|$ 个空位置，此时显然不影响区间颜色数，而且使得 $l_i+X\le 2|V|$ 恒成立，此时右端点不需要对任何东西取 $\min$ 就是她本身，可以直接得到判断区间的左端点。

时空复杂度均为 $\mathcal{O}(n\log |V|)$，但是常数巨大跑不过 $2\log$。

[$\mathcal{O}(n\log |V|)$ AC Code (LOJ)](https://loj.ac/s/2139604)

---

**典** 道和 **菜** 津奈，是在暗示我又典又菜吗？数据结构萌新爬了。

典道在虚拟世界中获得了在现实中追求菜津奈的勇气，而弱小的我能在梦中无数次与【】重逢换来现实世界中在【】面前的勇气吗？能在梦中无数次 NOI Au 中换来现实中脱产 OI 的勇敢吗？

---

## 作者：foreverlasting (赞：4)

[题面](https://www.luogu.org/problemnew/show/P4632)

线段树分治或者线段树+堆

先说线段树分治的做法。

基本套路了吧。每个结点开两个vector，修改和询问，然后统计答案就行了。不做预处理的复杂度是带两个log的，事实上也可以过这道题，但跑的比较慢。然后我们可以在外面先排序，这样子扔进线段树vector的顺序就是满足单调性的，于是就可以扫描一遍，这样可以少掉一个log。

但，这样写常数大，而且不好玩，所以有一个线段树+堆的写法。

这里直接贴kcz奆佬的做法了：[做法](https://loj.ac/article/523)

这样也是一个log的，而且好写。（事实上我就是这样写的）

其实还有一种在线且一个log的做法。（锟爷讲的做法）

首先要把原问题转换。如果我们把所有点到每一种类型的商店的最近点距离画出来，其实是一条斜率为1或-1的分段一次函数。这个函数还有一个特征，就是只会在x轴上拐点。那我们就可以把-1和1分开来讨论。对于这个函数，我们可以用set和堆维护一下。对于每个询问，我们用线段树维护右端点大于这个询问点的一次函数的左端点的最小值，那么答案就出来了。（事实上，我懒得写，感觉好强）

code:
```
//2018.8.9 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline LL read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline LL _abs(const res &x){
    return x>0?x:-x;
}
inline LL _max(const res &x,const res &y){
    return x>y?x:y;
}
inline LL _min(const res &x,const res &y){
    return x<y?x:y;
}
const LL N=3e5+10,Q=3e5+10,K=3e5+10; 
LL n,k,q,sz;
LL a[N]; 
inline LL lisan_get(res x){
	return lower_bound(a+1,a+1+sz,x)-a;
}
struct HEAP{
	priority_queue<LL,vector<LL>,greater<LL> >Q1,Q2;
    inline void push(res x){
	    Q1.push(x); 
	}
    inline void erase(res x){
	    Q2.push(x); 
	}
    inline LL top(){
	    while(!Q2.empty()&&Q1.top()==Q2.top())Q1.pop(),Q2.pop();
		return Q1.top();
	}
}QQ[N];
LL siz,d;
struct zkw{
	LL mn,mx;
}tr[N<<4];
inline void build(){
	siz=sz+1;
	for(d=1;d<siz;d<<=1);
	d--;
	for(res i=siz+d+1;i>=1;i--)tr[i].mn=inf;
	for(res i=1;i<=siz;i++)QQ[i].push(inf);
	for(res i=1;i<=k;i++)QQ[siz].push(-inf);
	for(res i=siz+d;i;i>>=1)tr[i].mn=-inf;
	for(res i=1;i<=sz;i++)tr[d+i].mx=a[i];
	tr[d+siz].mx=(inf<<1);
	for(res i=d;i>=1;i--)tr[i].mx=_max(tr[i<<1].mx,tr[i<<1|1].mx);
}
inline LL solve(res x){
	if(tr[siz+d].mn==-inf)return -1;
	res i=1,now=inf;
	while(i<=d){
		if(x>tr[i<<1].mx){i=(i<<1|1);continue;}
		if(tr[i<<1].mx+1+_min(tr[i<<1|1].mn,now)<=(x<<1))i=(i<<1|1);
		else now=_min(tr[i<<1|1].mn,now),i<<=1;
	}
	return _min((x<<1)-_min(now,tr[i].mn),tr[i].mx)-x;
}
inline void update(res i){
	tr[i+d].mn=QQ[i].top();
	i+=d;
	while(i>>=1){
		if(tr[i].mn==_min(tr[i<<1].mn,tr[i<<1|1].mn))break;
		tr[i].mn=_min(tr[i<<1].mn,tr[i<<1|1].mn);
	}
}
inline void ADD(res i,res x){
	QQ[i].push(x);
	update(i);
}
inline void DEL(res i,res x){
	QQ[i].erase(x);
	update(i);
}
inline void MOD(res i,res x,res y){
	QQ[i].erase(x);
	QQ[i].push(y);
	update(i);
}
inline void insert(multiset<LL>&S,res x){
	multiset<LL>::iterator it1,it2;
	it2=it1=S.insert(x);
	it1--,it2++;
	ADD(lisan_get(x),*it1);
	MOD(lisan_get(*it2),*it1,x);
}
inline void remove(multiset<LL>&S,res x){
	multiset<LL>::iterator it,it1,it2;
	it=it1=it2=S.find(x);
	it1--,it2++;
	DEL(lisan_get(x),*it1);
	MOD(lisan_get(*it2),x,*it1);
	S.erase(it);
}
multiset<LL> S[K];
struct MAR{
	LL x,t,p;
	MAR() {}
	MAR(res x,res t,res p):x(x),t(t),p(p) {}
	inline bool operator < (const MAR &b) const {
		return p<b.p;
	}
	inline void add(){
		insert(S[t],x);
	}
	inline void del(){
		remove(S[t],x);
	}
}pa[N],pb[N];
struct QUE{
	LL id,l,y;
	QUE() {}
	QUE(res id,res l,res y):id(id),l(l),y(y) {}
	inline bool operator < (const QUE &b) const {
		return y<b.y;
	}
}que[Q];
LL ans[Q];
int main(){
	n=read(),k=read(),q=read();
	for(res i=1;i<=n;i++){
		res x=read(),t=read(),A=read(),B=read();
		pa[i]=MAR(x,t,A);
		pb[i]=MAR(x,t,B);
		a[i]=x;
	}
	sort(a+1,a+n+1);
	sz=unique(a+1,a+n+1)-a-1;
	build();
//	for(res i=1;i<=d+siz;i++)printf("%d %d\n",tr[i].mn,tr[i].mx);
	for(res i=1;i<=q;i++){
		res l=read(),y=read();
	    que[i]=QUE(i,l,y);
	}
	sort(pa+1,pa+n+1);
	sort(pb+1,pb+n+1);
	sort(que+1,que+q+1);
//	for(res i=1;i<=n;i++)printf("%d %d %d\n",pa[i].x,pa[i].t,pa[i].p);
//	for(res i=1;i<=n;i++)printf("%d %d %d\n",pb[i].x,pb[i].t,pb[i].p);
//  for(res i=1;i<=q;i++)printf("%d %d %d\n",que[i].id,que[i].l,que[i].y);
	for(res i=1;i<=k;i++)S[i].insert(-inf),S[i].insert(inf);
	for(res i=1,A=1,B=1;i<=q;i++){
		while(A<=n&&pa[A].p<=que[i].y)pa[A++].add();
		while(B<=n&&pb[B].p<que[i].y)pb[B++].del();
		ans[que[i].id]=solve(que[i].l);
	}
	for(res i=1;i<=q;i++)printf("%Ld\n",ans[i]);
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：3)

安利可爱的平衡树解法。

------------

首先先说正解。

应该很容易想到可以把询问离线下来跑扫描线，这样我们就对每个询问维护了此时所有尚在开业的商店的类型及位置。

然后，我们是否有方法求出所有颜色离当前位置最近的商店中最远的一个呢？

“最近的最远”，很容易想到二分。于是我们二分区间长度。则问题转换为能否判断一个区间 $[l,r]$ 中是否存在所有颜色。

这是经典主席树问题，思想是对于每个商店 $i$，维护其左方第一个尚在开业的同色商店 $pre_i$（不存在则置为 $0$），随后我们只需要考虑 $pre_i<l$ 的所有商店，即区间中每种颜色第一个出现的位置。

但是如果使用主席树复杂度是非常不可爱的 $O(n\log^3n)$。当然，如果把外层的二分换成直接在主席树上二分也能把复杂度优化到 $O(n\log^2n)$，还是有跑过去的希望的。但是我们还有更好的解法。

因为我们要求的不是**区间中不同颜色的数目**，而是**区间中有无出现所有的颜色**，是一个存在性问题而非计数问题。这使得我们可以忽略一些信息。

我们仍然考虑上述解法。只不过，我们这时找出所有 $i\in(r,+\infty)$ 的商店中，$pre_i$ 的最小值。明显，如果此时有 $\min<l$，则 $\min$ 所属的此种颜色并没有在区间中出现，也就无法达成所有颜色全数出现的要求了。

但是，我们会发现，上述解法中每种颜色最右端的商店都不会被考虑到。于是我们另外用点什么东西维护每种颜色最右端的商店，然后将上述的 $\min$ 与这里最右端的商店中最左端的哪一个再取 $\min$，即可找到上述位置，然后直接与 $l$ 比较即可。

------------

明显这一切都可以使用线段树维护。但是我们发现它有两个缺陷：

1. 线段树必须离散化，但离散化后就不好二分了。

2. 线段树中每个位置上都可能有不止一家商店，所以必须在里面再套一个```multiset```加以维护。

虽然这两个问题都是可以被处理掉的，但是我不想烦那么多了，就简单写了棵平衡树维护。明显此时就可以不在每个位置上开```multiset```（平衡树支持键值相同的数存在），也不必离散化了。

然后，无论是线段树还是平衡树，都可以通过在上面直接二分来规避掉外层的那个二分，从而将复杂度优化到 $O(n\log n)$。

但是反正我外层套了二分也过去了（并且甚至跑进了1s以内），也就懒得再改成平衡树上二分了。所以此处代码是 $O(n\log^2n)$ 的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
int SHO;
struct Shops{
	int tim,pos,tp;
	Shops(int u=0,int v=0,int w=0){tim=u,pos=v,tp=w;}
	friend bool operator<(const Shops &x,const Shops &y){return x.tim<y.tim;}
}sho[600100];
struct Queries{
	int tim,pos,id;
	friend bool operator<(const Queries &x,const Queries &y){return x.tim<y.tim;}
}que[300100];
int res[300100];
#define lson t[x].ch[0]
#define rson t[x].ch[1]
int cnt,rt;
struct Treap{
	int ch[2],rd,pos,pre,mn,sz;
}t[1000100];
void pushup(int x){
	t[x].mn=t[x].pre,t[x].sz=1;
	if(lson)t[x].mn=min(t[lson].mn,t[x].mn),t[x].sz+=t[lson].sz;
	if(rson)t[x].mn=min(t[rson].mn,t[x].mn),t[x].sz+=t[rson].sz;
}
int newnode(int pos,int pre){
	int x=++cnt;
	t[x].rd=rand()*rand();
	t[x].pos=pos;
	t[x].pre=pre;
	pushup(x);
	return x;
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(t[x].rd>t[y].rd){t[x].ch[1]=merge(t[x].ch[1],y),pushup(x);return x;}
	else{t[y].ch[0]=merge(x,t[y].ch[0]),pushup(y);return y;}
}
void splitbyval(int x,int pos,int pre,int &u,int &v){
	if(!x){u=v=0;return;}
	if(t[x].pos<pos||t[x].pos==pos&&t[x].pre<pre)u=x,splitbyval(rson,pos,pre,rson,v);
	else v=x,splitbyval(lson,pos,pre,u,lson);
	pushup(x);
}
void splitbysize(int x,int k,int &u,int &v){
	if(!x){u=v=0;return;}
	if(t[lson].sz>=k)v=x,splitbysize(lson,k,u,lson);
	else u=x,splitbysize(rson,k-t[lson].sz-1,rson,v);
	pushup(x);
}
void Insert(int pos,int pre){
	int a,b;
	splitbyval(rt,pos,pre,a,b);
	rt=merge(merge(a,newnode(pos,pre)),b);
}
void Delete(int pos,int pre){
	int a,b,c;
	splitbyval(rt,pos,pre,a,b);
	splitbysize(b,1,b,c);
	rt=merge(a,c);
}
multiset<int>typ[300100],all;
#define ERASE(x,y) x.erase(x.find(y))
void Ins(int col,int pos){
	auto it=typ[col].lower_bound(pos),ti=it;
	int pre=*--it;
	Insert(pos,pre);
	if(ti!=typ[col].end()){
		int nex=*ti;
		Delete(nex,pre);
		Insert(nex,pos);
	}
	ERASE(all,*typ[col].rbegin());
	typ[col].insert(pos);
	all.insert(*typ[col].rbegin());
}
void Del(int col,int pos){
	ERASE(all,*typ[col].rbegin());
	ERASE(typ[col],pos);
	all.insert(*typ[col].rbegin());
	auto it=typ[col].lower_bound(pos),ti=it;
	int pre=*--it;
	Delete(pos,pre);
	if(ti!=typ[col].end()){
		int nex=*ti;
		Delete(nex,pos);
		Insert(nex,pre);
	}
}
bool che(int l,int r){
	l=max(l,1);
	int a,b;
	splitbyval(rt,r,0x3f3f3f3f,a,b);
	bool ret=t[b].mn>=l;
	rt=merge(a,b);
	return ret;
}
int Query(int pos){
	if(*all.begin()==0)return -1;
	int l=max(pos-*all.begin(),0),r=max(l,*all.rbegin()-pos);
	while(l<r){
		int mid=(l+r)>>1;
		if(che(pos-mid,pos+mid))r=mid;
		else l=mid+1;
	}
	return r;
}
void Iterate(int x){if(x)Iterate(lson),printf("(%d,%d)",t[x].pos,t[x].pre),Iterate(rson);}
int main(){
	scanf("%d%d%d",&n,&m,&q),t[0].mn=0x3f3f3f3f;
	for(int i=1;i<=m;i++)typ[i].insert(0),all.insert(0);
	for(int i=1,a,b,c,d;i<=n;i++)scanf("%d%d%d%d",&a,&b,&c,&d),sho[++SHO]=Shops(c,a,b),sho[++SHO]=Shops(d+1,a,-b);
	sort(sho+1,sho+SHO+1);
	for(int i=1;i<=q;i++)scanf("%d%d",&que[i].pos,&que[i].tim),que[i].id=i;
	sort(que+1,que+q+1);
	for(int i=1,j=1;i<=q;i++){
		while(j<=SHO&&sho[j].tim<=que[i].tim){
			if(sho[j].tp>0)Ins(sho[j].tp,sho[j].pos);
			else Del(-sho[j].tp,sho[j].pos);
			j++;
		}
//		for(int k=1;k<=m;k++,puts(""))for(auto it:typ[k])printf("%d ",it);Iterate(rt),puts("");
		res[que[i].id]=Query(que[i].pos);
	}
	for(int i=1;i<=q;i++)printf("%d\n",res[i]);
	return 0;
}
```

---

## 作者：Seauy (赞：3)

题目要求的其实是最小的 $r$ 满足 $[l-r+1,l+r-1]$ 拥有所有类型的商店。但是仔细分析一下可以发现不用二分。

关于区间颜色有关的查询，一种经典的套路是对于每个颜色开个 set 然后二维数点，因为一个区间 $[L,R]$ 可以看作是平面上的点 $(L,R)$。

$[L,R]$ 不包含某个颜色等价于 $[L,R]$ 被夹在了这个颜色的某两个位置之间。具体地说，如果这个颜色的位置序列为 $\{x_i\}$ 满足 $x_i<x_{i+1}$，那么如果存在 $i$ 使得 $x_i<L\leq R<x_{i+1}$，$[L,R]$ 没有这个颜色。

那么我们可以考虑把所有这样的点 $(x_i,x_{i+1})$ 放到平面上，查询一个区间 $[L,R]$ 合不合法就相当于判断平面直角坐标系中 $(L,R)$ 左上方有没有点。

注意到，对于一个查询 $l$，如果采用二分，$L,R$ 其实不是没有规律的，而是满足 $\frac{L+R}{2}=l$，也就是说 $(L,R)$ 永远在直线 $y=-x+2l$ 上。如果我们想要 $r$ 最小，就得找出 $y=-x+2l$ 上最右的、左上方没有 $(x_i,x_{i+1})$ 的点。答案取到的点要么被直线下的 $y$ 坐标最大的点卡住，要么被直线上 $x$ 坐标最小的点卡住。判断是否在直线上、下需要判断 $x+y$ 与 $2l$ 的大小，也就是说把点 $(x,y)$ 插入线段树中的位置 $x+y$，然后维护个 $y$ 的前缀最大值和 $x$ 的后缀最小值即可。

复杂度 $O((n+q)\log (n+q)+k)$，代码偷懒直接动态开点了。

```cpp
#include<bits/stdc++.h>
#define Lson(x) node[x].Son[0]
#define Rson(x) node[x].Son[1] 
using namespace std;

typedef pair<int,int> pr;
typedef multiset<int>::iterator mit;
typedef multiset<pr>::iterator qit;

const int MAXN=3e5,MAXV=1e8,LOGV=30;

inline int Read()
{
	int res;char c;
	while(1) {c=getchar();if('0'<=c && c<='9') {res=c-'0';break;}}
	while(1) {c=getchar();if('0'<=c && c<='9') res=res*10+c-'0';else break;}
	return res;
}

inline int ABS(int x) {return x>0 ? x : -x;}

struct msg
{
	int l,y,t;//位置，时间，t>0 插入商店，t<0 删除商店
	int ID;
	inline void Print()
	{
		if(t>0) printf("Insert %d %d\n",l,t);
		else if(t<0) printf("Delete %d %d\n",l,-t);
		else printf("Ask %d\n",l); 
	} 
}qry[3*MAXN+5];int tot;
bool cmp(msg a,msg b) {return (a.y==b.y ? a.t>b.t : a.y<b.y);}

int n,K,q;
multiset<int> mapn[MAXN+5];int cnt;//不空的个数 
int ans[MAXN+5];

struct SegTree//<=2l max y >=2l min x
{
	struct SegNode {int Son[2],maxn,minn;}node[MAXN*LOGV+5];int Tail;
	inline void Build()
	{
		Tail=1;
		node[Tail].minn=node[0].minn=MAXV+2;
	}
	inline void New(int now,bool t)
	{
		if(node[now].Son[t]) return;
		node[now].Son[t]=++Tail;
		node[Tail].minn=MAXV+2;
	}
	void Changey(int now,int L,int R,int x,int v)
	{
		if(L==R) {node[now].maxn=v;return;}
		int mid=L+((R-L)>>1);
		if(x<=mid) New(now,0),Changey(Lson(now),L,mid,x,v);
		else New(now,1),Changey(Rson(now),mid+1,R,x,v);
		node[now].maxn=max(node[Lson(now)].maxn,node[Rson(now)].maxn);
	}
	void Changex(int now,int L,int R,int x,int v)
	{
		if(L==R) {node[now].minn=v;return;}
		int mid=L+((R-L)>>1);
		if(x<=mid) New(now,0),Changex(Lson(now),L,mid,x,v);
		else New(now,1),Changex(Rson(now),mid+1,R,x,v);
		node[now].minn=min(node[Lson(now)].minn,node[Rson(now)].minn);
	}
	int AskMax(int now,int L,int R,int x)
	{
		if(x<L || !now) return 0;
		if(R<=x) return node[now].maxn;
		int mid=L+((R-L)>>1);
		return max(AskMax(Lson(now),L,mid,x),AskMax(Rson(now),mid+1,R,x));
	}
	int AskMin(int now,int L,int R,int x)
	{
		if(R<x || !now) return MAXV+2;
		if(x<=L) return node[now].minn;
		int mid=L+((R-L)>>1);
		return min(AskMin(Lson(now),L,mid,x),AskMin(Rson(now),mid+1,R,x));
	}
	inline void Modifyy(int x,int v) {Changey(1,-MAXV,3*MAXV,x,v);}
	inline void Modifyx(int x,int v) {Changex(1,-MAXV,3*MAXV,x,v);}
	inline int GetMax(int x) {return AskMax(1,-MAXV,3*MAXV,x);}
	inline int GetMin(int x) {return AskMin(1,-MAXV,3*MAXV,x);}
}po;

multiset<pr> Qx,Qy;
inline void Insert(int x,int y)//平面上插入一个点
{
	Qy.insert(make_pair(x+y,y));
	Qx.insert(make_pair(x+y,x));
	qit now=--Qy.lower_bound(make_pair(x+y+1,0));
	po.Modifyy(x+y,(*now).second);
	now=Qx.lower_bound(make_pair(x+y,0));
	po.Modifyx(x+y,(*now).second);
}
inline void Delete(int x,int y)//平面上删除一个点
{
	Qy.erase(Qy.lower_bound(make_pair(x+y,y)));
	Qx.erase(Qx.lower_bound(make_pair(x+y,x)));
	qit now=Qy.lower_bound(make_pair(x+y+1,0));
	if(now==Qy.begin()) po.Modifyy(x+y,0);
	else
	{
		--now;
		if((*now).first!=x+y) po.Modifyy(x+y,0);
		else po.Modifyy(x+y,(*now).second);
	}
	now=Qx.lower_bound(make_pair(x+y,0));
	if(now==Qx.end()) po.Modifyx(x+y,MAXV+2);
	else if((*now).first!=x+y) po.Modifyx(x+y,MAXV+2);
	else po.Modifyx(x+y,(*now).second);
}

int main()
{
	n=Read(),K=Read(),q=Read();
	for(int i=1,x,t,a,b;i<=n;i++)
	{
		x=Read(),t=Read(),a=Read(),b=Read();
		qry[++tot]=msg{x,a,t,0};
		qry[++tot]=msg{x,b,-t,0};
	}
	for(int i=1,l,y;i<=q;i++)
	{
		l=Read(),y=Read();
		qry[++tot]=msg{l,y,0,i};
	}
	sort(qry+1,qry+tot+1,cmp);
	po.Build();
	for(int i=1;i<=K;i++)
	{
		mapn[i].insert(-MAXV),mapn[i].insert(2*MAXV);
		Insert(-MAXV,2*MAXV);
	}
	for(int i=1,t,l;i<=tot;i++)
	{
		t=qry[i].t,l=qry[i].l;
		if(t>0)
		{
			if(mapn[t].size()==2) ++cnt;
			mit now=mapn[t].lower_bound(l);
			if((*now)!=l)
			{
				int R=(*now),L=(*--now);
				Delete(L,R);
				Insert(L,l),Insert(l,R);
			}
			mapn[t].insert(l);
		}
		else if(t<0)
		{
			t*=-1;
			mapn[t].erase(mapn[t].lower_bound(l));
			mit now=mapn[t].lower_bound(l);
			if((*now)!=l)
			{
				int R=(*now),L=(*--now);
				Delete(L,l),Delete(l,R);
				Insert(L,R);
			}
			if(mapn[t].size()==2) --cnt;
		}
		else
		{
			if(cnt<K) {ans[qry[i].ID]=-1;continue;}
			int L=po.GetMin(2*l),R=po.GetMax(2*l);
			ans[qry[i].ID]=max(max(l-L,R-l),0);
		}
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：咯咯咯 (赞：2)

像这种有2个限制条件的一般都要用排序解决其中一个限制

1、按位置排？或许可以吧。。可能要可持久化

2、按时间排？发现每个商店可以拆除插入和删除

那么问题来了，怎么快速查询答案呢？

乍一看不会。。不如想想二分

假设答案为x,那么就说明pos+x位置之后没有人的前继在pos-x前面

那么只要查询pos+x后面所有人前继的最小值就好了

发现复杂度O(nlog^2n）

然而像我这种用FHQ-Treap代替离散化+线段树的zz常数巨大难以接受

~~预定100 UOJ47 洛谷60~~

那么怎么优化算法呢？

其实你会发现你只要在Treap上找就好了就好了，相当于找最小的x-k使得 min>=k-(x-k)

（x为位置，k是询问的位置，now_min为此时x右边最小的前继，~~可以自己yy一下~~）

~~然而因为原本的FHQ-Treap不保证左子树严格小于x，右子树严格大于x，害的我又加了个multiset,早知道就乖乖写线段树了~~


现在算法复杂度成功优化到O(nlogn)了，然而一交发现还是T了~~洛谷96-98 , UOJ 57……mmp~~

再想一想还有什么可以优化。。

Treap！！

我把原本的srand((int)time(0))换成srand(233)在UOJ就过了？？？

~~然而在洛谷上还是96~~

下面是代码……丑陋请见谅



```cpp
#include<iostream>
#include<cstdlib>
#include<ctime>
#include<cstdio>
#include<set>
#include<queue>
#include<algorithm>
#define RE  register
#define For(i,a,b) for( int i=a;i<=b;i++)
#define Lc(x) (s[x].lc)
#define Rc(x) (s[x].rc)
const int N=3e5+1000,INF=0x3f3f3f3f;
void read(int &x)
{
	int t=0,opt=1;
	char c=getchar();
	while (c<'0'||c>'9') (c=='-'?opt=-1:0),c=getchar();
	while ('0'<=c&&c<='9')
	{
		t=t*10+c-'0';
		c=getchar();
	}
	x=t*opt;return ;
}
int n,type,q,Pre[N],Next[N],ans[N];
struct Query
{
	int pos,t,num;
	bool operator <(const Query &other) const{return t<other.t;}
} Q[N];
struct DATA
{
	int a,b,pos,type;
	bool operator <(const DATA &other) const{return a<other.a;}
} data[N];int now=1;
std::priority_queue<std::pair<int,int> > H;
std::set<std::pair<int,int> > S[N];
std::set<std::pair<int,int> > ::iterator it1,it2;
namespace Treap
{
	std::multiset<int>  S[N*10];
	struct DATA
	{
		int x,min,lc,rc,weigh;
	}s[N*10];int cnt=0,root=0;
	int New( int x, int y)
	{
		s[++cnt]=(DATA){x,y,0,0,rand()};
		S[cnt].insert(y);
		return cnt;
	}
	void Push_up( int x)
	{
		s[x].min=*S[x].begin();
		if (Lc(x)) s[x].min=std::min(s[x].min,s[Lc(x)].min);
		if (Rc(x)) s[x].min=std::min(s[x].min,s[Rc(x)].min);	
	}
	int Merge( int x, int y)
	{
		if (!x||!y) return x+y;
		if (s[x].weigh<s[y].weigh) {Rc(x)=Merge(Rc(x),y);Push_up(x);return x;}
		else{Lc(y)=Merge(x,Lc(y));Push_up(y);return y;}
	}
	void Split(int &x,int &y, int now, int k)
	{
		if (!now) x=y=0;
		else
		{
			if (k<=s[now].x) y=now,Split(x,Lc(y),Lc(now),k);
			else x=now,Split(Rc(x),y,Rc(now),k);
			Push_up(now);
		}
	}
	void Insert( int x, int y)
	{
		 int A,B,C;
		Split(A,B,root,x);Split(B,C,B,x+1);
		if (B) S[B].insert(y),Push_up(B);else  B=New(x,y);
		root=Merge(A,Merge(B,C));
	}
	void Erase(int x,int y)
	{
		 int A,B,C;
		Split(A,B,root,x);Split(B,C,B,x+1);
		S[B].erase(S[B].find(y));
		if (!S[B].size()) B=0; else Push_up(B);
		root=Merge(A,Merge(B,C));
	}
	int Query(int x)
	{
		 int A,B,ans;
		Split(A,B,root,x);
		ans=s[B].min;root=Merge(A,B);
		return ans;
	}
	int Find(int now,int l,int r,int k,int min) //寻找最小的x-k   now_min>=k-(x-k)
	{
//		printf("!!! %d %d %d %d %d %d %d %d %d\n",now,Lc(now),Rc(now),s[now].x,*S[now].begin(),l,r,k,min);
		if (!now) return std::max(l-k,k-min);
		if (s[now].x<k) return Find(Rc(now),l,r,k,min);
		else
		{
			int now_min=std::min(min,s[Rc(now)].min);
			if (now_min>=k-(s[now].x-k)) return std::min(s[now].x-k,Find(Lc(now),l,s[now].x-1,k,  std::min(now_min,*S[now].begin())  ));
			else return Find(Rc(now),s[now].x+1,r,k,min);
		}
	}
}
int main()
{
//	freopen("xx.in","r",stdin);
	//srand((int)time(0));
	srand(233);
	Treap::s[0].min=INF;
	read(n);read(type);read(q);
	For(i,1,n) read(data[i].pos),read(data[i].type),read(data[i].a),read(data[i].b);
	For(i,1,q) read(Q[i].pos),read(Q[i].t),Q[i].num=i;
	std::sort(data+1,data+1+n);std::sort(Q+1,Q+1+q);
	For(i,1,type) S[i].insert(std::make_pair(-INF,0)),S[i].insert(std::make_pair(INF,n+1));
	For(i,1,type) Treap::Insert(INF,-INF);data[0].pos=-INF;data[n+1].pos=INF;
	For(i,1,q)
	{
		while (now<=n&&data[now].a<=Q[i].t) 
		{
			it1=it2=S[data[now].type].lower_bound(std::make_pair(data[now].pos,now));it1--;
			Next[now]=it2->second;Pre[now]=it1->second;
			Treap::Erase(data[Next[now]].pos,it1->first);
			if (Next[now]!=n+1) Pre[Next[now]]=now;
			if (Pre[now]!=0) Next[Pre[now]]=now;
			Treap::Insert(data[Next[now]].pos,data[now].pos);
			Treap::Insert(data[now].pos,data[Pre[now]].pos);
			S[data[now]
			.type].insert(std::make_pair(data[now].pos,now));
			H.push(std::make_pair(-data[now].b,now));
			now++;
		}
		while (!H.empty()&&-H.top().first<Q[i].t)
		{
			int now=H.top().second;H.pop();
			Treap::Erase(data[now].pos,data[Pre[now]].pos);
			Treap::Erase(data[Next[now]].pos,data[now].pos);
			if (Next[now]!=n+1) Pre[Next[now]]=Pre[now];
			if (Pre[now]!=0) Next[Pre[now]]=Next[now];
			Treap::Insert(data[Next[now]].pos,data[Pre[now]].pos);
			S[data[now].type].erase(std::make_pair(data[now].pos,now));
		}
		int Ans=Treap::Find(Treap::root,Q[i].pos,INF,Q[i].pos,INF);
		if (Ans>(int)1e8) Ans=-1;
		ans[Q[i].num]=Ans;
	}
	For(i,1,q) printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：Reisael (赞：1)

讲一个没有任何思维含量的做法。

对于同一种颜色挨在一起的两个点 $x,y$，令 $mid=\lfloor\frac{x+y}{2}\rfloor$，那么在 $[x,mid]$ 区间内的位置 $i$ 的不方便指数都要对 $i-x$ 取 $\max$，在 $[mid,y]$ 区间内的都要对 $y-i$ 取 $\max$。

于是用线段树分治处理掉时间维，变成只能删除点的问题，再开两颗线段树分别维护 $i-x$ 和 $y-i$ 中 $x$ 的 $\min$ 与 $y$ 的 $\max$，就可以做到 $O(n\log^2n)$ 了，常数极大。

---

## 作者：FReQuenter (赞：1)

对于每个位置上的颜色有时间区间不好处理，可以看作在 $a$ 时刻加入，$b+1$ 时刻删除。所以考虑按时间离线。

那么问题转化为快速求某个点距离所有颜色的最短距离。考虑二分出的 $mid$，我们需要快速统计 $[l_i-mid,l_i+mid]$ 内是否含有所有的颜色。

区间越短，则每个颜色出现的次数就越少，但是仍然至少需要出现一次。我们记录 $p_i$ 表示当前位于位置 $i$ 的颜色上一次出现在 $p_i$（注意一个位置可能有多个颜色，所以需要合理地选择离散化方式）。那么区间 $[L,R]$ 含有所有颜色就等同于 $\min\{p_{R+1},p_{R+2},p_{R+3},\cdots,p_{n}\}\ge p_L$。但是 $[L,n]$ 里可能没有所有的颜色，所以可以人为地在序列后面加入 $k$ 项，依次为每个颜色。$p$ 可以使用 multiset 维护插入删除，再套一个线段树维护区间最值，这时候复杂度 $O(n\log^2n)$，能够通过。两只 log 分别来自二分和数据结构。

然后发现为什么不在线段树上二分呢？考虑记录 $[L,R]$ 表示 $L\le l_i+mid-1\le R$ 以及从父亲下来的 $mid$，决策往左还是往右的时候取出右儿子 $p_i$ 的最小值，如果不是每个颜色都有对应的前一个，那就只能走右儿子；否则如果右儿子的最小 $p_i$ 落在 $L+mid-1$ 之后就走左儿子，不然就只能走右儿子。最后 $L=R$ 的时候比较取 $\max\{l_i-p_L,L-l_i\}$ 这样就只剩一只 log 了。

注意排序的时候如果有同时间的插入删除修改，修改放在最后（题解区好像没人提这个也可能是我眼瞎了

[code](https://www.luogu.com.cn/paste/qnph2d1g)

---

## 作者：LimpidSlirm (赞：0)

## 题意

给定数轴上的 $n$ 个点，每个点用一个二元组 $(pos_i,type_i)$ 描述，$pos_i$ 表示其位置，$type_i$ 表示其种类，且会在时间段 $[a_i,b_i]$ 出现。总共有 $k$ 种 $type$。

$q$ 次询问，每次询问在 $time_i$ 时刻，令第 $j$ 种类型的点中和 $pos_i$ 间最小距离为 $dis_j$，求 $\max\limits_{j\in[1,k]}(dis_j)$，若某时刻不存在 $type_j$ 类型的点，则令答案为 $-1$。

## Solution

看起来像是一个乱七八糟的偏序问题。显然地，只需要离线就可以解决时间维度上的问题。

然后有一个二分答案，即二分一个 $mid$，然后去查询 $[pos_i-mid,pos_i+mid]$ 区间内是否包含所有 $k$ 种点。

问题似乎转化成了二位数点，即以坐标为 $x$ 轴，以类型为 $y$ 轴，只需要维护当前矩形内是否存在所有 $k$ 种 $y$ 值就可以计算出答案。

但是由于颜色不连续的性质，无法用数据结构快速维护（好像可以再离线一次？《二 次 离 线》）。于是人类智慧做法他来了！令某一个点 $i$ 前一个和它种类相同的点为 $pre_i$，当前二分到的区间为 $[l,r]$，在 $n+1$ 号点上放置所有 $k$ 种 $type$ 的点。那么只需要计算 $[r+1,n+1]$ 区间内的任意一种 $type$ 的 $pre$ 的最小值。即在保证所有 $type$ 都被检测到的前提下 ，如果 $[r+1,n+1]$ 区间内任意一个点的前驱的最小值大于等于 $l$，那么显然地 $[l,r]$ 区间内存在所有 $k$ 种点。最小值大于等于 $l$ 意味着所有点的前驱都在 $l$ 之后，若 $pre\in[l,r]$ 则说明当前种类在区间内出现过，若 $r\lt pre$ 则说明 $pre$ 的某一个祖宗前驱在区间 $[l,r]$ 内。而在 $n+1$ 号点放置所有 $k$ 种点的操作保证了所有种类的点都在 $r$ 之后出现过。

使用线段树维护区间最小值，对于每一种 $type$ 维护一个 `multiset` 记录当前 $type$ 所有出现的位置，删除点的时候只需要如链表般将当前节点的 $pre$ 变为 $nxt$ 节点的 $pre$ 即可，加点同理。

由于每个点都会被被 `insert` 进入 `multiset` $3$ 次，故对于 `multiset`，时间复杂度为 $\mathcal{O}(n)$。单次修改时间复杂度为 $\mathcal{O}(\log n)$，再乘上二分答案的一个 log，总时间复杂度为 $\mathcal{O}(n\log^2 n)$。

注意二分答案时区间左右端点应转为离散化后的编号，`multiset` 中删去元素时 `erase()` 参数为迭代器，记得加 $0$ 号点和 $n+1$ 号点作为各种类型的第一个前驱和后继。

## code

```cpp
#include<bits/stdc++.h>
inline int read()
{
	int res=0,flag=1;
	char ch=getchar();
	while(!('0'<=ch&&ch<='9')) (ch=='-')?flag=-1:1,ch=getchar();
	while(('0'<=ch&&ch<='9')) res=res*10+ch-'0',ch=getchar();
	return res*flag;
}
struct infomation
{
	int id;
	int pos;
	int type;
	int time;
	bool operator <(const struct infomation &other)const
	{
		if(this->time!=other.time)
			return this->time<other.time;
		return this->type>other.type;
	}
};
struct SegmentTree
{
	struct node
	{
		std::multiset<int> s;
		int min;
	};
	struct node nd[1200010];
	#define inf 0x3f3f3f3f 
	void build(int left,int right,int id)
	{
		nd[id].min=inf;
		if(left==right)
			return ;
		int mid=(left+right)>>1;
		build(left,mid,id<<1);
		build(mid+1,right,id<<1|1);
		return ;
	}
	void pushup(int id)
	{
		nd[id].min=std::min(nd[id<<1].min,nd[id<<1|1].min);
		return ;
	}
	void modify(int left,int right,int id,int pos,int data)
	{
		if(right<pos||pos<left)
			return ;
		if(left==pos&&right==pos)
		{
			nd[id].s.insert(data);
			nd[id].min=*nd[id].s.begin();
			return ;
		}
		int mid=(left+right)>>1;
		modify(left,mid,id<<1,pos,data);
		modify(mid+1,right,id<<1|1,pos,data);
		pushup(id);
		return ;
	}
	void del(int left,int right,int id,int pos,int data)
	{
		if(right<pos||pos<left)
			return ;
		if(left==pos&&right==pos)
		{
			nd[id].s.erase(nd[id].s.find(data));
			nd[id].min=(nd[id].s.size()==0)?inf:(*nd[id].s.begin());
			return ;
		}
		int mid=(left+right)>>1;
		del(left,mid,id<<1,pos,data);
		del(mid+1,right,id<<1|1,pos,data);
		pushup(id);
		return ;
	}
	int query(int left,int right,int id,int start,int end)
	{
		if(right<start||end<left)
			return inf;
		if(start<=left&&right<=end)
			return nd[id].min;
		int mid=(left+right)>>1;
		int ansl=query(left,mid,id<<1,start,end);
		int ansr=query(mid+1,right,id<<1|1,start,end);
		return std::min(ansl,ansr);
	}
};
struct infomation info[900010];
struct SegmentTree st;
int n,k,q,m,cnt;
int res[300010];
std::map<int,int> postion;
std::multiset<int> shop[300010];
void init()
{
	n=read(),k=read(),q=read();
	std::priority_queue<int,std::vector<int>,std::greater<int> > heap;
	for(int i=1;i<=n;i++)
	{
		int pos=read(),type=read(),fr=read(),to=read();
		info[(i<<1)-1]=(infomation){0,pos,type,fr};
		info[i<<1]=(infomation){0,pos,-type,to};
		heap.push(pos);
		m=std::max(m,pos);
	}
	for(int i=1;i<=q;i++)
	{
		int pos=read(),time=read();
		info[2*n+i]=(infomation){i,pos,0,time};
		m=std::max(m,pos);
	}
	postion.clear(); 
	postion[-1e8]=++cnt;
	while(heap.empty()==false)
	{
		if(postion[heap.top()]==0)
			postion[heap.top()]=++cnt;
		heap.pop();
	}
	std::sort(info+1,info+2*n+q+1);
	postion[2e8]=++cnt;
	st.build(1,cnt,1);
	for(int i=1;i<=k;i++)
		shop[i].insert(1),shop[i].insert(cnt);
	st.modify(1,cnt,1,cnt,1e8);
	for(int i=1;i<=k;i++)
		st.modify(1,cnt,1,cnt,1);
	return ;
}
void modify(int pos,int type)
{
	int pre=*--shop[type].lower_bound(pos);
	st.modify(1,cnt,1,pos,pre);
	int nxt=*shop[type].lower_bound(pos);
	st.del(1,cnt,1,nxt,pre);
	st.modify(1,cnt,1,nxt,pos);
	shop[type].insert(pos);
	return ;
}
void del(int pos,int type)
{
	int pre=*--shop[type].lower_bound(pos);
	st.del(1,cnt,1,pos,pre);
	shop[type].erase(shop[type].find(pos));
	int nxt=*shop[type].lower_bound(pos);
	st.del(1,cnt,1,nxt,pos);
	st.modify(1,cnt,1,nxt,pre);
	return ;
}
void solve()
{
	int now=1;
	for(int i=1;i<=2*n+q;i++)
	{
		if(info[i].type>0)
			modify(postion[info[i].pos],info[i].type);
		if(info[i].type==0)
		{
			int left=0,right=m,ans=1e8+1;
			while(left<=right)
			{
				int mid=(left+right+1)>>1;
				int l=(*postion.lower_bound(info[i].pos-mid)).second;
				int r=(*--postion.upper_bound(info[i].pos+mid)).second;
				if(st.query(1,cnt,1,r+1,cnt)>=l)
					ans=mid,right=mid-1;
				else
					left=mid+1;
			}
			res[info[i].id]=(ans==1e8+1)?-1:ans;
		}
		if(info[i].type<0)
			del(postion[info[i].pos],-info[i].type);
	}
	for(int i=1;i<=q;i++)
		printf("%d\n",res[i]);
	return ;
}
int main(int argc,const char *argv[])
{
	init();
	solve();
	return 0;
}
```

## 写在最后

讲道理 $\mathcal{O}(n\log^2 n)$ 吸完氧跑的还是挺快的。



---

## 作者：xfrvq (赞：0)

综合，套路的数据结构题。好玩。

---

题意限制很多，思考方向较为狭隘。大体思路考虑离线，对时间维做扫描线，用数据结构算答案。

注意到没有数据结构能够维护 $k$ 维度的最值，于是考虑二分答案，问题变成验证 $[p-x,p+x]$ 是否有 $k$ 种颜色。

考虑数颜色的套路做法，就维护 $nxt_i$ 下一个颜色相同的位置，此时变成查询 $[l,r]$ 中有多少个 $nxt_i>r$。

这是二维偏序问题，在线/离线都没什么好做法。我们注意询问是**是否具有所有颜色**。这是简化问题的唯一途径。

不难发现一件事情：若 $\exist i<l,nxt_i>r$，此时 $[l,r]$ 中一定不含 $i$ 的颜色，即一定不符要求。于是问题转化为判断 $\forall i\in[1,l),nxt_i\le r$ ，也就是 $\max_{i=1}^{l-1}\{nxt_i\}\le r$，此时变成简单区间最值。线段树解决。

此时注意到有的数没有在 $[1,l)$ 出现过（即对于颜色第一次出现位置，没有 $nxt$ 指向它）。对于这种情况我们考虑**在原序列前增加 $k$ 位**代表 $k$ 种颜色。它们并不是实际位置，但是它们的 $nxt$ 指向每种颜色第一次出现的位置。询问 $\max\{nxt_i\}$ 时候算上这些位置。

考虑扫描线过程中一些数的插入删除，导致 $nxt$ 发生改变。不过这也是套路，考虑**用 $\tt set$ 维护一种颜色出现的所有位置**，插入/删除只会改变当前点和前驱的 $nxt$ 值，线段树单修区查即可。

---

但注意到题目使用了 **$10^8$ 值域，一个点上多个店铺** 等恶心人。需要我们合适地设计离散化应对。

+ 对时间的离散化：考虑把所有出现过的**时间点**（店铺开关，询问的时间点）排序去重，即可解决。
+ 对位置的离散化：此时不能去重（我们的线段树不支持一个点有多个值），仅将所有位置排序，**每个位置都能对应排序数组上的一段区间**，可以使用 `lower_bound()` 和 `prev(upper_bound())` 求出区间的左右端。$[p-x,p+x]$ 实际上就对应 **$\textbf{\textit{p}}-\textbf{\textit{x}}$ 所对左端点到 $\textbf{\textit{p}}+\textbf{\textit{x}}$ 所对右端点** 的区间。

---

注意到我们事先添加了 $k$ 位置，可以省去 $\tt set$ 边界情况的讨论。

注意时间的离散化用到了 $3n$ 大小的值，要开三倍。线段树维护 $n+k$ 的位置，空间要到 $8n$。

代码较工整美观。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 9e5 + 5;

int n,m,q,T[N * 4],ans[N];
int a[N],b[N],L[N],R[N],p[N],t[N];
pair<int,int> X[N];
vector<int> V,P1[N],P2[N];
vector<pair<int,int>> Q[N];
set<int> S[N];

#define lc (i << 1)
#define rc (lc | 1)
#define mid ((L + R) / 2)

void upd(int p,int x,int i = 1,int L = 1,int R = m + n){
	if(L == R) return T[i] = x,void();
	p <= mid ? upd(p,x,lc,L,mid) : upd(p,x,rc,mid + 1,R);
	T[i] = max(T[lc],T[rc]);
}

int qry(int l,int r,int i = 1,int L = 1,int R = m + n,int s = 0){
	if(l <= L && R <= r) return T[i];
	if(l <= mid) s = qry(l,r,lc,L,mid);
	if(r > mid) s = max(s,qry(l,r,rc,mid + 1,R));
	return s; 
}

int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i <= n;++i){
		scanf("%d%d%d%d",a + i,b + i,L + i,R + i);
		X[i] = make_pair(a[i],i),V.push_back(L[i]),V.push_back(R[i]);
	}
	sort(X + 1,X + n + 1);
	for(int i = 1;i <= n;++i) a[X[i].second] = i;
	for(int i = 1;i <= q;++i) scanf("%d%d",p + i,t + i),V.push_back(t[i]);
	sort(begin(V),end(V));
	V.erase(unique(begin(V),end(V)),end(V));
	for(int i = 1;i <= n;++i){
		L[i] = lower_bound(begin(V),end(V),L[i]) - begin(V) + 1;
		R[i] = lower_bound(begin(V),end(V),R[i]) - begin(V) + 1;
		P1[L[i]].push_back(i),P2[R[i]].push_back(i);
	}
	for(int i = 1;i <= q;++i){
		t[i] = lower_bound(begin(V),end(V),t[i]) - begin(V) + 1;
		Q[t[i]].emplace_back(i,p[i]);
	}
	for(int i = 1;i <= m;++i) S[i].insert(i),S[i].insert(N * 2),upd(i,N * 2);
	for(int i = 1;i <= (int)V.size();++i){
		for(int p : P1[i]){
			int l = *prev(S[b[p]].lower_bound(a[p] + m));
			upd(a[p] + m,qry(l,l)),upd(l,a[p] + m);
			S[b[p]].insert(a[p] + m);
		}
		for(auto[j,p] : Q[i]){
			int L = 0,R = 1e8,M = 5e7;
			for(;L < R;M = (L + R) / 2){ 
				int l = lower_bound(X + 1,X + n + 1,make_pair(p - M,0)) - X;
				int r = prev(upper_bound(X + 1,X + n + 1,make_pair(p + M,N))) - X;
				if(qry(1,l + m - 1) <= r + m) R = M; else L = M + 1;
			}
			ans[j] = R == 1e8 ? -1 : R;
		}
		for(int p : P2[i]){
			int l = *prev(S[b[p]].lower_bound(a[p] + m));
			upd(l,qry(a[p] + m,a[p] + m)),upd(a[p] + m,0);
			S[b[p]].erase(a[p] + m);
		}
	}
	for(int i = 1;i <= q;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---


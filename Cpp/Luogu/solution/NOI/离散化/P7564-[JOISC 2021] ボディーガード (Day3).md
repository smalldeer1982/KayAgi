# [JOISC 2021] ボディーガード (Day3)

## 题目背景

因为数据包过大，所以请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-data.zip) 获取完整数据。

## 题目描述

在一条数轴上，有 $N$ 个人，他们都是书虫保镖公司的顾客，第 $i$ 个人会在第 $T_i$ 个时刻从第 $A_i$ 个位置移动到第 $B_i$ 个位置，他们的速度是每一个时刻一个单位长度。

如果一个保镖与一个顾客同时在一个位置上，就称保镖在保护这个顾客。设这个保镖从 $a$ 时刻开始保护一个顾客 $i$，从 $b$ 时刻停止保护，那么区间 $[a,b]$ 就称为这个顾客的保护时间，时刻 $a$ 称为保护开始时间，时刻 $b$ 称为保护停止时间。**其中 $a$ 和 $b$ 不必是整数**。特殊地，如果一个保镖与两个顾客同时在一个位置上，保镖只能保护一个顾客。

保镖可以在数轴上以最多每一个时刻一个单位长度最少静止不动的速度随意移动，当保镖停止保护一个顾客的时候，他可以到另一个位置上保护另一个顾客。如果一个保镖保护第 $i$ 个顾客一起走过的路径长度为 $L$，那么顾客 $i$ 将会以 $C_i$ 津巴布韦币每单位长度给这个保镖 $ L \times C_i$ 津巴布韦币作为他的工资。

书虫作为书虫保镖公司的老板，他手里紧握着 $Q$ 份策划保护的方案，其中，第 $j$ 个方案，一个保镖从时刻 $P_j$ 开始从第 $X_j$ 个位置出发开始进行工作。

求对于每个方案，每个保镖获得的总工资数量最多是多少津巴布韦币。

## 说明/提示

#### 样例 1 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+4=8$ 津巴布韦币：
	- 在时刻 $1$ 从 $2$ 位置开始行动。
    - 从时刻 $1$ 到时刻 $2$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 时刻 $2$ 到时刻 $3$ 停留在 $1$ 位置。
    - 从时刻 $3$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $2$，得到 $2 \times 2=4$ 津巴布韦币。
- 保护方案 $2$ 中保镖可以按照下面的方式得到 $2$ 津巴布韦币：
	- 在时刻 $3$ 从 $3$ 位置开始行动。
    - 时刻 $3$ 到时刻 $4$ 从 $3$ 位置移动到 $2$ 位置。
    - 从时刻 $4$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。

#### 样例 2 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+1+8+2=15$ 津巴布韦币：
	- 在时刻 $2$ 从 $2$ 位置开始行动。
    - 时刻 $2$ 到时刻 $2.5$ 从 $2$ 位置移动到 $2.5$ 位置。
    - 从时刻 $2.5$ 到时刻 $3.5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 从时刻 $3.5$ 到时刻 $4$ 保护顾客 $1$，一起走过的路径长度为 $0.5$，得到 $2 \times 0.5=1$ 津巴布韦币。
    - 从时刻 $4$ 到时刻 $6$ 保护顾客 $3$，一起走过的路径长度为 $2$，得到 $4 \times 2=8$ 津巴布韦币。
    - 从时刻 $6$ 到时刻 $7$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。
- 保护方案 $2$ 中保镖无论怎么走都得不到工资，只能得到 $0$ 津巴布韦币。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（6 pts）：$T_i,A_i,B_i,P_j,X_j \le 3000$。
- Subtask 2（7 pts）：$Q=1$。
- Subtask 3（15 pts）：$Q \le 3000$。
- Subtask 4（20 pts）：$Q \le 4 \times 10^4$。
- Subtask 5（52 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2800$，$1 \le Q \le 3 \times 10^6$，$1 \le T_i,A_i,B_i,C_i \le 10^9$，$A_i \ne B_i$，$C_i$ 为偶数，$1 \le P_j,X_j \le 10^9$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 B ボディーガード (Bodyguard) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-en.pdf)。

## 样例 #1

### 输入

```
2 2
1 2 1 4
3 1 3 2
1 2
3 3```

### 输出

```
8
2```

## 样例 #2

### 输入

```
3 2
3 1 5 2
1 4 1 4
4 2 4 4
2 2
6 3```

### 输出

```
15
0```

## 样例 #3

### 输入

```
5 5
8 1 4 10
8 3 7 6
1 4 6 2
3 9 5 4
6 1 9 6
7 6
6 8
1 3
9 4
2 4```

### 输出

```
30
27
48
30
48```

# 题解

## 作者：harryzhr (赞：7)

# 题意

有 $n$ 个顾客在逛街，街视为一个数轴，每个顾客在 $t_i$ 时刻从 $a_i$ 位置开始逛街，以 $1$ 单位每秒的速度走到 $b_i$ 位置之后离开。如果 $a_i<b_i$ 表示他向正方向走，否则表示他向负方向走。同时每个人有权值 $c_i$ 表示单位时间内的工资数量。

一个保镖保护一个人需要跟一个人一起逛街（即相同时刻在相同位置），跟着 $i$ 逛街 $x$ 个单位时间获得 $c_i\times x$ 的工资。保镖的移动速度不超过 $1$ 单位每秒，保护一个人逛街的起止时间均不需要是一个整数。一个保镖在同一时刻只能保护一个人。

有 $q$ 个保镖，第 $x$ 个保镖在 $P_x$ 时刻上岗，初始位置时 $X_x$，你需要求出每个保镖能够获得的小费最多是多少。

**数据范围**：$n\le 2800,q\le 3\times 10^6,1\le t_i,a_i,b_i,c_i,P_i,X_i\le 10^9,a_i\ne b_i,c_i$ 为偶数。

# solution


首先转化问题，把时间和位置作为两维，在坐标系中画出所有逛街的人的图像，即**起点为 $(t_i,a_i)$ ，终点为 $(t+|a_i-b_i|,b_i)$ 的一个线段**。那么一个保镖在坐标系上起点是 $(p_i,x_i)$，每个时刻只能向右上或者右下走，保镖的路径的图像与顾客的图像的重叠部分的长度就表示保护的时长。这样线段长度变成了原来的 $\sqrt{2}$ 倍。

现在所有的线段都是与直线 $y=x$ 平行或垂直的，不是很好处理，**把坐标系顺时针旋转 $45^\circ $**，即一个点 $(x,y)$ 变为 $(x-y,x+y)$。线段长度再 $\times \sqrt{2}$，现在的线段长度是原来的 $2$ 倍，那么如果保镖与顾客的图像重叠的长度为 $len$，那么得到的工资是 $len\times \frac{c_i}{2}$。这就是 $c_i$ 是偶数的作用。


注意到 $n$ 很小，把所有顾客的线段的端点作为关键点，离散化，这样变成了一个 $O(n)\times O(n)$ 的网格图，共 $O(n^2)$ 个格点。可以 $O(n^2)$ 地**预处理出如果一个保镖走到了一个格点，之后他的最大收益 $val_{i,j}$ 是多少**。转移枚举下一步往上走还是右走，走的时候选覆盖这个线段的 $c_i$ 最大的顾客保护。


现在剩下的问题就是走到格点之前的部分，一个保镖的策略是：要么一直往上走，找到一个合适的横着的线段，跟着走一段，到达格点；要么一直往右走，找到一个合适的竖着的线段，跟着走一段，到达格点。跟着走一段，然后获得格点的贡献是一个一次函数 $kx+b$ 的形式，$k$ 是 $\frac{c_i}{2}$，$x$ 是保护的距离，$b$ 是格点的贡献。**一个保镖能走到的横着的线段和竖着的线段是一段前缀，把询问离线下来李超树维护**即可。

具体的，枚举是往上走还是往右走，以往上走为例。找出初始位置在两个格线 $i$ 和 $i+1$ 之间的所有保镖，他们选择的格点一定是 $val_{i+1,x}$。然后按照纵坐标从大到小的顺序，把一次函数插入进去即可。每个保镖 $j$ 询问一个前缀的一次函数中，$x=X_{i+1}-P_j$ 时的最大值。

时间复杂度是 $O((n^2+q)\log q)$。空间复杂度 $O(n^2+q)$。



```cpp
#include <bits/stdc++.h>
using namespace std;
namespace iobuff{//输入输出量较大，输入输出优化
	const int LEN=1000000;
	char in[LEN+5],out[LEN+5];
	char *pin=in,*pout=out,*ed=in,*eout=out+LEN;
	inline char gc(void){
		return pin==ed&&(ed=(pin=in)+fread(in,1,LEN,stdin),ed==in)?EOF:*pin++;
	}
	inline void pc(char c){
		pout==eout&&(fwrite(out,1,LEN,stdout),pout=out);
		(*pout++)=c;
	}
	inline void flush(){fwrite(out,1,pout-out,stdout),pout=out;}
	template<typename T> inline void read(T &x){
		static int f;
		static char c;
		c=gc(),f=1,x=0;
		while(c<'0'||c>'9') f=(c=='-'?-1:1),c=gc();
		while(c>='0'&&c<='9') x=10*x+c-'0',c=gc();
		x*=f;
	}
	template<typename T> inline void putint(T x,char div='\n'){
		static char s[20];
		static int top;
		top=0;
		x<0?pc('-'),x=-x:0;
		while(x) s[top++]=x%10,x/=10;
		!top?pc('0'),0:0;
		while(top--) pc(s[top]+'0');
		pc(div);
	}
}
using namespace iobuff;
const int N=5605,Q=3e6+5;
#define ll long long
#define int ll
#define y1 Yy1
#define y2 Yy2 
template<int T> struct lsh{//离散化
	int buc[T],tot;
	inline void ins(int x){buc[++tot]=x;}
	inline void build(){
		sort(buc+1,buc+1+tot);
		tot=unique(buc+1,buc+1+tot)-buc-1;
	}
	inline int operator ()(int x){return lower_bound(buc+1,buc+1+tot,x)-buc;}
	inline int operator [](int x){return buc[x];}
};
lsh<N> bx,by;
lsh<Q> qry;
int qx[Q],qy[Q];
namespace SGT{//李超树
	#define lid (id<<1)
	#define rid (id<<1|1)
	#define mid ((l+r)>>1)
	int k[Q<<2];ll b[Q<<2];
	void build(int id,int l,int r){
		k[id]=0;b[id]=-1;
		if(l==r)return;
		build(lid,l,mid);build(rid,mid+1,r);
	}
	inline ll calc(int id,int x){return 1ll*k[id]*x+b[id];}
	inline ll calc(int _k,ll _b,int x){return 1ll*_k*x+_b;}
	void insert(int id,int l,int r,int _k,ll _b){
		if(b[id]==-1){k[id]=_k;b[id]=_b;return;}
		if(calc(id,qry[mid])<calc(_k,_b,qry[mid]))swap(k[id],_k),swap(b[id],_b);
		if(l==r)return;
		if(calc(id,qry[r])<calc(_k,_b,qry[r]))insert(rid,mid+1,r,_k,_b);
		if(calc(id,qry[l])<calc(_k,_b,qry[l]))insert(lid,l,mid,_k,_b);
	}
	ll query(int id,int l,int r,int pos){
		if(b[id]==-1)return 0;
		if(l==r)return calc(id,qry[pos]);
		return max(calc(id,qry[pos]),pos<=mid?query(lid,l,mid,pos):query(rid,mid+1,r,pos));
	}
}
ll val[N][N];
int vx[N][N],vy[N][N];
template<typename T> inline void Max(T &a,T b){if(a<b)a=b;}
struct Line{
	int x1,x2,y1,y2,c;
	Line(int _x1=0,int _y1=0,int _x2=0,int _y2=0,int _c=0){x1=_x1;y1=_y1;x2=_x2;y2=_y2;c=_c;}
	inline void build(){
		x1=bx(x1);x2=bx(x2);y1=by(y1);y2=by(y2);
	}
}line[N];
vector<int> bucx[N],bucy[N];
int n,q;
void init(){
	bx.build();by.build();
	for(int i=1;i<=n;++i){
		line[i].build();//vx,vy 表示 (i,j) 向右走到 (i+1,j)/向上走到 (i,j+1) 的最大的 c
		if(line[i].x1==line[i].x2){
			for(int j=line[i].y1;j<line[i].y2;++j)
				Max(vy[line[i].x1][j],line[i].c);
		}else{
			for(int j=line[i].x1;j<line[i].x2;++j)
				Max(vx[j][line[i].y2],line[i].c);
		}
	}
	for(int i=bx.tot;i;--i)for(int j=by.tot;j;--j)
		val[i][j]=max(i<bx.tot?val[i+1][j]+1ll*vx[i][j]*(bx[i+1]-bx[i]):0ll,j<by.tot?val[i][j+1]+1ll*vy[i][j]*(by[j+1]-by[j]):0ll);
}
inline bool cmpx(int x,int y){return qx[x]>qx[y];}
inline bool cmpy(int x,int y){return qy[x]>qy[y];}
ll ans[Q];
signed main(){
	read(n);read(q);
	for(int i=1,a,b,t,c,x1,y1,x2,y2;i<=n;++i){
		read(t);read(a);read(b);read(c);
		x1=t;y1=a;
		x2=t+abs(a-b);y2=b;
		line[i]=Line(x1-y1,x1+y1,x2-y2,x2+y2,c>>1);
		bx.ins(x1-y1);bx.ins(x2-y2);
		by.ins(x1+y1);by.ins(x2+y2);
	}
	init();
	for(int i=1,t,a;i<=q;++i){
		read(t);read(a);
		qx[i]=t-a;qy[i]=t+a;
		bucx[bx(qx[i])].push_back(i);
		bucy[by(qy[i])].push_back(i);
	}
	for(int i=1;i<=bx.tot;++i){
		if(!bucx[i].size())continue;
		qry.tot=0;
		sort(bucx[i].begin(),bucx[i].end(),cmpy);
		for(int x:bucx[i])qry.ins(bx[i]-qx[x]);
		qry.build();
		int R=qry.tot;
		SGT::build(1,1,R);
		int flag=by.tot;
		for(int id:bucx[i]){
			while(flag&&by[flag]>=qy[id]){
				SGT::insert(1,1,R,vx[i-1][flag],val[i][flag]);
				--flag;
			}
			Max(ans[id],SGT::query(1,1,R,qry(bx[i]-qx[id])));
		}
	}
	for(int i=1;i<=by.tot;++i){
		if(!bucy[i].size())continue;
		qry.tot=0;
		sort(bucy[i].begin(),bucy[i].end(),cmpx);
		for(int x:bucy[i])qry.ins(by[i]-qy[x]);
		qry.build();
		int R=qry.tot;
		SGT::build(1,1,R);
		int flag=bx.tot;
		for(int id:bucy[i]){
			while(flag&&bx[flag]>=qx[id]){
				SGT::insert(1,1,R,vy[flag][i-1],val[flag][i]);
				--flag;
			}
			Max(ans[id],SGT::query(1,1,R,qry(by[i]-qy[id])));
		}
	}
	for(int i=1;i<=q;++i)putint(ans[i]);
	flush();
	return 0;
}
```




---

## 作者：Sol1 (赞：5)

牛逼 DP，联测碰上这题直接摆烂交白卷（

首先决策和时间有关，因此问题本质上是二维的，加一条时间轴。

这样如果一个人本来是 $T$ 时刻开始从 $u$ 到 $v$，在新的时间-位置平面上就转化成从 $(T,u)$ 到 $(T+|u-v|,v)$ 的线段。当然现在什么时候走这条线段就没关系了，啥时候走都能有收益。

观察到保镖没有必要停，因为停肯定是为了等几个单位时间之后出现的一个人，如果按 $0.5$ 个时间单位分段，就可以前半段往前走后半段往后走，所以一直走就不劣。

然后保镖就只能向左上或者右上走。

观察到所有线段和保镖的走法都平行于 $y=x$ 和 $y=-x$ 中的一条，所以为了方便处理整体转 $45$ 度。

离散化之后就可以发现所有的 VIP 的对应线段叉起来会形成一个网格图，而且大小是 $O(n^2)$ 量级的，可以接受，因此对所有格点算出答案。

然后剩下的就是操作这个人让他走到一个格点。

不难发现最优情况一定是先往一个方向冲，然后遇到一个格线就往另一个方向（只有两个可以走的方向）转，沿着那个格线到达第一个格点。

容易观察到这一段的贡献是关于坐标中某一项的一次函数，而后面格点的贡献可以视作常数，所以整个算下来还是个一次函数。

现在问题就转化为给定一堆一次函数序列，多次询问某一个序列的某一个前缀的所有一次函数在某一个位置的点值的最大值。

这个可以把询问离线下来，然后尝试维护一个下凸包。

当然可以直接平衡树/李超树，而且原题 25s/4GB 可能足以通过，但是 $O(n^2\log n)$ 还是不够优秀。

挖掘一下性质，发现如果把 $x$ 变量设为这半条格线的长度，截距就只剩下 DP 值，这显然是递增的（下面的 DP 值肯定大于上面的 DP 值）。因此在将直线插入凸包的时候，斜率比自己小的全都没有必要留。

所以就可以拿单调栈+二分维护。

于是这题就做完了。复杂度 $O(n^2+q\log n)$。洛谷要开 O2。

实际实现的时候可能需要把这个凸包关于 $y$ 轴翻转过来存，不过这是小问题。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline long long qread() {
	register char c = getchar();
	register long long x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

#define yn sjdfklsneklrn

struct Line {
	long long k, b;
	Line() {}
	Line(long long k, long long b) : k(k), b(b) {}
};

const int N = 6005, Q = 3000005;
long long n, q, xl[N], yl[N], xr[N], yr[N], w[N], xp[N], yp[N], xn, yn, qx[Q], qy[Q], stktop;
Line stk[N];
long long dp[N][N], wu[N][N], wr[N][N], ans[Q];
vector <int> adj[N][N];

inline void Read() {
	n = qread(); q = qread();
	for (int i = 1;i <= n;i++) {
		long long t = qread(), a = qread(), b = qread(); w[i] = qread() / 2;
		xl[i] = t + a; yl[i] = t - a; xr[i] = t + abs(a - b) + b; yr[i] = t + abs(a - b) - b;
		xp[i] = xl[i]; xp[i + n] = xr[i]; yp[i] = yl[i]; yp[i + n] = yr[i];
	}
}

inline void Prefix() {
	sort(xp + 1, xp + 2 * n + 1);
	sort(yp + 1, yp + 2 * n + 1);
	xn = unique(xp + 1, xp + 2 * n + 1) - xp - 1;
	yn = unique(yp + 1, yp + 2 * n + 1) - yp - 1;
	for (int i = 1;i <= n;i++) {
		xl[i] = lower_bound(xp + 1, xp + xn + 1, xl[i]) - xp;
		xr[i] = lower_bound(xp + 1, xp + xn + 1, xr[i]) - xp;
		yl[i] = lower_bound(yp + 1, yp + yn + 1, yl[i]) - yp;
		yr[i] = lower_bound(yp + 1, yp + yn + 1, yr[i]) - yp;
	}
	for (int i = 1;i <= n;i++) {
		if (xl[i] == xr[i]) {
			for (int j = min(yl[i], yr[i]);j < max(yl[i], yr[i]);j++) wu[xl[i]][j] = max(wu[xl[i]][j], 1ll * w[i]);
		} else {
			for (int j = min(xl[i], xr[i]);j < max(xl[i], xr[i]);j++) wr[j][yl[i]] = max(wr[j][yl[i]], 1ll * w[i]);
		}
	}
	/*
	for (int i = 1;i <= xn;i++) {
		for (int j = 1;j <= yn;j++) cout << wu[i][j] << " ";
		cout << endl;
	}
	for (int i = 1;i <= xn;i++) {
		for (int j = 1;j <= yn;j++) cout << wr[i][j] << " ";
		cout << endl;
	}
	*/
	for (int i = xn;i >= 1;i--) {
		for (int j = yn;j >= 1;j--) dp[i][j] = max(dp[i][j + 1] + wu[i][j] * (yp[j + 1] - yp[j]), dp[i + 1][j] + wr[i][j] * (xp[i + 1] - xp[i]));
	}
	/*
	for (int i = 1;i <= xn;i++) {
		for (int j = 1;j <= yn;j++) cout << dp[i][j] << " ";
		cout << endl;
	}
	*/
}

inline void addLine(long long k, long long b) {
	k = -k;
	while (stktop && stk[stktop].k >= k) stktop--;
	while (stktop > 1 && (__int128)(stk[stktop].b - b) * (k - stk[stktop - 1].k) <= (__int128)(stk[stktop - 1].b - b) * (k - stk[stktop].k)) stktop--;
	stk[++stktop] = Line(k, b);
}

inline long long qMax(long long x) {
	x = -x;
	int l = 1, r = stktop + 1;
	while (l < r - 1) {
		int mid = l + r >> 1;
		if (stk[mid].b - stk[mid - 1].b <= (__int128)x * (stk[mid - 1].k - stk[mid].k)) r = mid;
		else l = mid;
	}
	return stk[l].k * x + stk[l].b;
}

inline void Solve() {
	for (int i = 1;i <= q;i++) {
		long long p = qread(), x = qread();
		qx[i] = p + x; qy[i] = p - x;
		adj[lower_bound(xp + 1, xp + xn + 1, qx[i]) - xp][lower_bound(yp + 1, yp + yn + 1, qy[i]) - yp].push_back(i);
	}
	for (int i = 1;i <= xn;i++) {
		stktop = 0;
		for (int j = yn;j >= 1;j--) {
			addLine(wr[i - 1][j], dp[i][j]);
			int siz = adj[i][j].size();
			//for (int k = 1;k <= stktop;k++) cout << stk[k].k << "x+" << stk[k].b << " "; cout << endl;
			for (int k = 0;k < siz;k++) {
				//cout << "(" << i << "," << j << ") " << adj[i][j][k] << endl;
				ans[adj[i][j][k]] = max(ans[adj[i][j][k]], qMax(xp[i] - qx[adj[i][j][k]]));
			}
		}
	}
	for (int j = 1;j <= yn;j++) {
		stktop = 0;
		for (int i = xn;i >= 1;i--) {
			addLine(wu[i][j - 1], dp[i][j]);
			int siz = adj[i][j].size();
			for (int k = 0;k < siz;k++) ans[adj[i][j][k]] = max(ans[adj[i][j][k]], qMax(yp[j] - qy[adj[i][j][k]]));
		}
	}
	for (int i = 1;i <= q;i++) cout << ans[i] << '\n';
}

int main() {
	Read();
	Prefix();
	Solve();
	cout.flush();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}
```

---

## 作者：Arghariza (赞：2)

放到二维平面上考虑，点 $(x,y)$ 表示 $x$ 时刻在 $y$ 位置上，那么第 $i$ 顾客的路径可以看成起点为 $(t_i,a_i)$，终点为 $(t_i+|b_i-a_i|,b_i)$ 的线段 $P_i$。

注意到一个保镖的最优策略中一定不会闲着不动，因为如果他此时正在保护一个人的话显然跟下去比不动更优；如果他此时没有保护一个人的话显然是去找下一个保护的人更优。所以保镖的路径形如若干斜率 $1$ 或者 $-1$ 形成的线段拼接起来的折线 $Q_i$。

考虑到一个保镖一旦离开了正在保护的人就再也追不上他了，那么保镖 $i$ 保护顾客 $j$ 时间为 $P_j$ 和 $Q_i$ 重合的线段在时间轴上的投影长度，也就是重合线段长度 $l$ 的 $\frac{1}{\sqrt 2}$。考虑将坐标轴顺时针旋转 $45$ 度再进行放缩，那么 $(x,y)\to (x-y,x+y)$，此时重合线段长度 $l'$ 为 $\sqrt 2l$，那么保护时间就是重合线段长度的 $\frac{1}{2}$，收益就变成了 $\frac{c_i}{2}\cdot l'$。于是令 $c_i\gets c_i\cdot \frac{1}{2}$。

于是问题转化成平面上有若干平行或垂直于坐标轴的直线 $P_1,P_2,\cdots ,P_n$，$q$ 次询问，每次询问给出一个点 $(x,y)$，每次只能向上/向右走单位距离，和 $P_i$ 重合的长度为 $L_i$，收益为 $c_i\cdot L_i$，求总收益最大是多少。

所有顾客线段延长交叉起来会变成一个大小为 $O(n\times n)$ 的网格图。考虑 $(x,y)$ 一定是先径直走到网格图的某条线上，沿着某条可能不完整的线再走到某个格点，最后再在格点之间移动。

对网格进行离散化之后容易 dp $O(n^2)$ 预处理出 $f_{i,j}$ 表示目前在网格上的 $(i,j)$ 点，对应坐标系中的 $(x_i,y_j)$ 点（$1\le i\le m,1\le j\le k$），只能向上/向右走，走下去的最大收益。然后假设 $(x,y)$ 向上走到了 $(x,y_j)$ 所在的一条边，再向右走到了第一个格点 $(x_i,y_j)$，那么取经过 $(x,y_j)$ 的 $c_i$ 最大的线段 $L_i$，收益就是 $c_i(x_i-x)+f_{i,j}$。

注意到经过 $(x,y_j)$ 的线段必定经过 $(x_i,y_j)$ 和 $(x_{i-1},y_j)$，因为一条直线起码经过两个格点。所以记 $v_{i,j}$ 为经过格点 $(x_i,y_j)$ 且 $(x_i,y_j)$ 不为其右端点的线段 $P_i$ 中 $c_i$ 的最大值，那么收益就是 $v_{i-1,j}(x_i-x)+f_{i,j}$。

注意到 $x$ 固定时 $x_i$ 为第一个大于 $x$ 的格点横坐标，所以 $i$ 是固定的，将 $v_{i-1,j}$ 看作一条直线的斜率，$f_{i,j}$ 看作截距，问题转化为求给定 $k$ 条直线在 $x_i-x$ 处的 $y$ 坐标的最大值，离线下来李超树解决即可。

复杂度 $O((n^2+q)\log n+q\log q)$。

---

## 作者：Grisses (赞：1)

[题面](https://www.luogu.com.cn/problem/P7564)

---

好题。

首先我们观察到题目保证了 $c_i$ 都是偶数，结合题目中说保镖保护一个 VIP 的时间可以是实数值，我们就能反应过来保镖可以在和某个 VIP 距离只有 1 的时候迎着走上去再掉头拿 $\dfrac{c_i}{2}$ 的工资。也就是说，保镖一直以 1 的速度走着绝对是不劣的，因为可以走到一半掉头。

那么如果我们把每个 VIP 的 x-t 图像画出来可以发现他们在平面上的路径都是斜率为正负一的线段，而保镖的路径则可以看作一条折线段，保镖的收入则是看他的路径与 VIP 的线段的重合部分。

如下图，VIP1 的路径是从 $(1,2)$ 到 $(2,1)$ 的线段，VIP2 
则是从 $(3,1)$ 到 $(5,3)$ 的线段。保镖 1 沿着红色折线走获得 8 元，保镖 2 沿着蓝色折线走获得 2 元。

![](https://cdn.luogu.com.cn/upload/image_hosting/u153j4j1.png)

我们发现，现在问题就是从一个点出发，向两个方向走，如果沿着一些特殊的线段走就可以获得收益，求最大的收益。

我们考虑将平面旋转一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/4287b8rd.png)

在将线段坐标离散化后，一共有 $O(n^2)$ 个格点，我们可以用 DP 先算出到了每一个格点后能获得的最大收益。

然后我们考虑如果一个点从格子内部出发，可以向两个方向走到某条格线在转向走到格点，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/de2zt6md.png)

从红点出发沿着蓝色虚线走到某一个绿色点再走，具体的收益就是边权乘上距离再加上格点的 DP 值，可以发现这是一个一次函数的形式，我们可以搞一棵李超线段树处理一个点向一个方向会遇到的所有格线并求最大值，具体见代码。

---

代码：

```cpp
  #include<bits/stdc++.h>
  #define int long long
  using namespace std;
  char buf[1000005],*p1,*p2;
  #define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++)
  int read(){//快读优化读入常数
      int x=0,c=gc();
      while(c>'9'||c<'0')c=gc();
      while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
      return x;
  }
  int n,q,totx,toty,a[2805],b[2805],t[2805],c[2805],X[5605],Y[5605],dp[5605][5605],val[5605][5605][2],ans[3000005];
  struct node{
      int x,y;
      void cha(){//旋转
          int _x=x-y,_y=y+x;
          x=_x;
          y=_y;
      }
  }x[2805],y[2805],p[3000005];
  vector<int>Set[5605];
  struct line{//李超树直线
      int k,b;
  }xian[1000005];
  int tog;
  int Getval(int pos,int id){
      return xian[id].k*pos+xian[id].b;
  }
  struct ST{//李超树
      int rt,cnt;
      struct Node{
          int son[2],pos;
      }c[2000005];
      int New(){
          cnt++;
          c[cnt].son[0]=c[cnt].son[1]=0;
          c[cnt].pos=0;
          return cnt;
      }
      void clear(){
          cnt=rt=0;
      }
      void down(int &q,int l,int r,int id){
          if(!q)q=New();
          int mid=l+r>>1;
          if(Getval(mid,c[q].pos)<Getval(mid,id))swap(c[q].pos,id);
          if(Getval(l,c[q].pos)<Getval(l,id))down(c[q].son[0],l,mid,id);
          if(Getval(r,c[q].pos)<Getval(r,id))down(c[q].son[1],mid+1,r,id);
      }
      void Add(int &q,int l,int r,int id){
          down(q,l,r,id);
      }
      int Get(int q,int l,int r,int x){
          if(!q)return -1e10;
          if(l==r)return Getval(x,c[q].pos);
          int mid=l+r>>1,res=Getval(x,c[q].pos);
          if(x<=mid)res=max(res,Get(c[q].son[0],l,mid,x));
          else res=max(res,Get(c[q].son[1],mid+1,r,x));
          return res;
      }
  }T;
  signed main()
  {
      xian[0]=line({0,(int)-1e10});
      n=read(),q=read();
      for(int i=1;i<=n;i++){
          t[i]=read();a[i]=read();b[i]=read();c[i]=read();
          c[i]/=2;//预先处理半收益
          x[i]=node({t[i],a[i]});
          x[i].cha();
          y[i]=node({t[i]+abs(a[i]-b[i]),b[i]});
          y[i].cha();//旋转线段
          X[++totx]=x[i].x;
          X[++totx]=y[i].x;
          Y[++toty]=x[i].y;
          Y[++toty]=y[i].y;
      }
      sort(X+1,X+totx+1);
      totx=unique(X+1,X+totx+1)-X-1;
      sort(Y+1,Y+toty+1);
      toty=unique(Y+1,Y+toty+1)-Y-1;
      for(int i=1;i<=n;i++){
          x[i].x=lower_bound(X+1,X+totx+1,x[i].x)-X;
          x[i].y=lower_bound(Y+1,Y+toty+1,x[i].y)-Y;
          y[i].x=lower_bound(X+1,X+totx+1,y[i].x)-X;
          y[i].y=lower_bound(Y+1,Y+toty+1,y[i].y)-Y;//离散化
          if(x[i].x==y[i].x){//处理每段格线的最大收益
              for(int j=x[i].y;j<y[i].y;j++){
                  val[x[i].x][j][0]=max(val[x[i].x][j][0],c[i]);
              }
          }
          else{
              for(int j=x[i].x;j<y[i].x;j++){
                  val[j][x[i].y][1]=max(val[j][x[i].y][1],c[i]);
              }
          }
      }
      for(int i=totx;i>=1;i--){
          for(int j=toty;j>=1;j--){
              dp[i-1][j]=max(dp[i-1][j],dp[i][j]+val[i-1][j][1]*(X[i]-X[i-1]));
              dp[i][j-1]=max(dp[i][j-1],dp[i][j]+val[i][j-1][0]*(Y[j]-Y[j-1]));
          }
      }//dp
      for(int i=1;i<=q;i++){
          p[i].x=read();p[i].y=read();
          p[i].cha();
          int pos=lower_bound(X+1,X+totx+1,p[i].x)-X;
          Set[pos].push_back(i);//按x坐标分段
      }
      for(int t=1;t<=totx;t++){
          if(Set[t].empty())continue;
          sort(Set[t].begin(),Set[t].end(),[&](int x,int y){return p[x].y>p[y].y;});//从后往前看
          int now=toty;
          tog=0;
          T.clear();
          for(int id:Set[t]){
              while(now>0&&Y[now]>=p[id].y){//添加格线的选择
                  tog++;
                  xian[tog]=line({val[t-1][now][1],dp[t][now]});
                  T.Add(T.rt,0,1e9,tog);
                  now--;
              }
              ans[id]=max(ans[id],T.Get(T.rt,0,1e9,X[t]-p[id].x));//求值
          }
          Set[t].clear();
      }
      for(int i=1;i<=q;i++){//同上
          int pos=lower_bound(Y+1,Y+toty+1,p[i].y)-Y;
          Set[pos].push_back(i);
      }
      for(int t=1;t<=toty;t++){
          if(Set[t].empty())continue;
          sort(Set[t].begin(),Set[t].end(),[&](int x,int y){return p[x].x>p[y].x;});
          int now=totx;
          tog=0;
          T.clear();
          for(int id:Set[t]){
              while(now>0&&X[now]>=p[id].x){
                  tog++;
                  xian[tog]=line({val[now][t-1][0],dp[now][t]});
                  T.Add(T.rt,0,1e9,tog);
                  now--;
              }
              ans[id]=max(ans[id],T.Get(T.rt,0,1e9,Y[t]-p[id].y));
          }
          Set[t].clear();
      }
      for(int i=1;i<=q;i++)printf("%lld\n",ans[i]);
      return 0;
  }
```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

数轴上有 $n$ 个顾客，第 $i$ 个顾客会在时刻 $t_i$ 于 $a_i$ 出现，以 $1$ 单位每时刻的速度移动到 $b_i$，到达 $b_i$ 后消失。注意可能 $a_i>b_i$。

有 $q$ 次询问，每次询问给出 $p_i,x_i$。表示一个保镖会在时刻 $p_i$ 于 $x_i$ 出现。保镖可以以介于 $[-1,1]$ 单位每时刻的任意速度移动。当保镖与顾客位于同一个位置时，保镖可以保护这个顾客，一个保镖同时只能保护一名顾客。保镖每保护顾客 $i$ 一个时刻，顾客会给他 $c_i$ 元。你需要输出保镖最多可以获得多少钱。

$1\leq n\leq 2800,1\leq q\leq 3\times 10^6$。

## 思路

考虑到顾客的轨迹其实带有二维属性：时刻和位置，所以考虑将顾客放到平面直角坐标系上考虑，具体地，我们钦定横轴表示时间，纵轴表示位置。

那么顾客 $i$ 的轨迹可以看成端点为 $(t_i,a_i),(t_i+|a_i-b_i|,b_i)$ 的线段。类似这样（其中虚线部分为保镖的两种轨迹，重叠部分不标虚线）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hox731as.png)

然后你可以发现几个结论：

- 顾客的轨迹一定是斜率为 $\pm1$ 的线段。
- 保镖的轨迹虽然没有很多额外限制，但是一种合法的轨迹，一定与一种仅由斜率为 $\pm1$ 的若干线段组成的折线构成。

这些结论都是不难证明的。

既然要维护的是斜率为 $\pm1$ 的线段，不妨将整个坐标系旋转 $45\degree$，一种比较好的方法是将 $(x,y)$ 映射到 $(x+y,x-y)$。得到：

![](https://cdn.luogu.com.cn/upload/image_hosting/lgd0nvil.png)

考虑将每条边延长变为一个网格，然后在原本的线段上加一个权值，表示保镖经过这条边可以获得的收益。

现在我们变成了这样一个问题：你需要从一个点出发，向右或向上走到任意一个位置，经过特定的边特定长度会获得长度乘上边权的收益，你需要最大化收益。

考虑这个问题怎么做。假如起点为网格的交点，那么可以 $O(n^2)$ dp 预处理，做一个类似格路计数的 dp 求出每一个点出发的收益。

现在考虑如果起点不在网格上呢？那么我们一定要走到网格上，要不然产生不了收益。

如何走到网格上？只有两种方法：向右走走到一条边后向上走，或者向上走走到一条边后向右走，最后到达一个端点。

无论哪种走法，第一段都是产生不了答案的，但第二段可能可以。这里我们讨论第一段向右走的情况，另一种情况是类似的。

为了方便地考虑先向右走的情况，将每个保镖的起点挂在右侧的网格线上，从左往右扫描线，对于扫到的一条网格线，从上到下扫描，如果遇到了可以贡献的线段就记录一下。

要是遇到了起点呢？我们发现答案可以表示为向上走的距离乘上边权，加上一个 dp 值。注意到向上走的距离是和起点坐标有关的一个常量，所以这实际上是动态维护一次函数极值，可以维护李超线段树完成。

## 代码

[Submission](https://loj.ac/s/2232328)

---

## 作者：lgswdn_SA (赞：0)

我们考虑把它二维化，然后再变换一下坐标系（$(t,x)$ 变换成 $(x-t,x+t)$），每个 VIP 的路径就变成了有一堆横向或纵向线段，然后我们相当于从一个起点出发，可以往下或往右走，然后走到线段上会有一个贡献。我们暴力把它离散化后扩成一个完整的网格图，然后 $O(n^2)$ 做一次 DP，$f(i,j)$ 表示从 $(i,j)$ 开始走的最大贡献和 。规定一下，这里的坐标在平面直角坐标系上考虑，即向右 $x$ 增大，向下 $y$ 减小。

然后我们考虑如何从一个不在网格图上的格点的贡献。实际上，在非网格上走一定不优，所以我们实际上一定会先竖直地往下走，然后走到一个网格图上的线，然后走到向右的那个格点。或者先水平向右，走到一个网格线，再向下。

暴力 $O(qn)$ 在原题恐怖的 25s 时限下是可能是可过的吧。不过这个显然可以优化。我们离线下来。先考虑向下走到格线。对于 $i,i+1$ 两列之间的询问点，我们要求的是其实就是对于 $j$ 所在列的真实坐标位于 $(x,y)$ 下面的 $\max_{j} f_{i+1,j}+p_{x,y}w_{i,j}$，其中 $p$ 表示 $(x,y)$ 到第 $i$ 列的距离，$w_{i,j}$ 表示从离散化的网格的 $(i,j)$ 走到 $(i+1,j)$ 的单位时间的收益。注意到相同 $i$ 情况下 $f$ 随着 $j$ 递增而单调不降，于是实际上如果存在变大的 $w$ 那原本 $w$ 小的那个一定不优。我们单调栈维护凸壳，然后每次加入的时候额外把 $w$ 更小的栈顶（栈中显然 $w$ 单调）给弹掉即可。向右走到格线，本质相同，不再具体展开。

写了 4.5k 代码 /tuu，顺便勉为其难地在洛谷上拿了最劣解。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define fi first
#define se second
#define eb emplace_back
#define popc __builtin_popcount
#define sgn(x) ((x)&1?-1:1)
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector<pii> vp;
typedef unsigned long long ull;
typedef long double ld;

int read() {
    int x=0,w=1; char c=getchar(); 
    while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
    while(isdigit(c)) {x=x*10+c-'0'; c=getchar();}
    return x*w;
}

const int N=1e5+9,M=5609,inf=0x3f3f3f3f;
int k,q,n,m,bx[N],by[N],l[N],r[N],x[N],y[N],c[N],f[M][M],qx[3000009],qy[3000009],ans[3000009],fx[N],fy[N],st[N],totx,toty;
vector<signed> p[M][M];
signed wx[M][M],wy[M][M];

bool cmpc(int a,int b,int c) {
    return __int128(fy[a]-fy[b])*(fx[b]-fx[c])>__int128(fy[b]-fy[c])*(fx[a]-fx[b]);
}
bool cmpk(int a,int b,int k) {
    return fy[a]-fy[b]>__int128(fx[a]-fx[b])*k;
}

signed main() {
    k=read(), q=read();
    rep(i,1,k) {
        int t=read(), a=read(), b=read(); c[i]=read()/2;
        if(a<b) y[i]=a-t, l[i]=a+t, r[i]=2*b-a+t, x[i]=inf;
        else x[i]=a+t, r[i]=a-t, l[i]=2*b-a-t, y[i]=inf;
    }
    rep(i,1,k) {
        if(x[i]==inf) by[++toty]=y[i], bx[++totx]=l[i], bx[++totx]=r[i];
        else if(y[i]==inf) bx[++totx]=x[i], by[++toty]=l[i], by[++toty]=r[i];
    }
    sort(by+1,by+toty+1); m=unique(by+1,by+toty+1)-by-1;
    sort(bx+1,bx+totx+1); n=unique(bx+1,bx+totx+1)-bx-1;
    rep(i,1,k) if(x[i]==inf) {
        y[i]=lower_bound(by+1,by+m+1,y[i])-by;
        l[i]=lower_bound(bx+1,bx+n+1,l[i])-bx;
        r[i]=lower_bound(bx+1,bx+n+1,r[i])-bx;
        p[y[i]][l[i]].eb(c[i]), p[y[i]][r[i]].eb(-c[i]);
    }
    rep(y,1,m) {
        multiset<int,greater<int>> s;
        rep(x,1,n) {
            for(int a:p[y][x]) {
                if(a>0) s.insert(a);
                else s.erase(s.find(-a));
            }
            if(s.size()) wx[x][y]=*s.begin();
        }
    }
    rep(i,1,m) rep(j,1,n) p[i][j].clear();
    rep(i,1,k) if(y[i]==inf) {
        x[i]=lower_bound(bx+1,bx+n+1,x[i])-bx;
        l[i]=lower_bound(by+1,by+m+1,l[i])-by;
        r[i]=lower_bound(by+1,by+m+1,r[i])-by;
        p[x[i]][r[i]].eb(c[i]), p[x[i]][l[i]].eb(-c[i]);
    }
    rep(x,1,n) {
        multiset<int,greater<int>> s;
        per(y,m,1) {
            for(int a:p[x][y]) {
                if(a>0) s.insert(a);
                else s.erase(s.find(-a));
            }
            if(s.size()) wy[x][y]=*s.begin();
        }
    }
    rep(i,1,n) rep(j,1,m) p[i][j].clear();
    per(x,n,1) rep(y,1,m) f[x][y]=max(wx[x][y]*(bx[x+1]-bx[x])+f[x+1][y],wy[x][y]*(by[y]-by[y-1])+f[x][y-1]);
    rep(i,1,q) {
        int t=read(), a=read(); qy[i]=a-t, qx[i]=a+t;
        int py=upper_bound(by+1,by+m+1,qy[i])-by-1, px=upper_bound(bx+1,bx+n+1,qx[i])-bx-1;
        p[px][py].eb(i);
    }
    per(x,n-1,0) {
        per(y,m,1) fx[y]=wx[x][y], fy[y]=f[x+1][y];
        int top=0;
        rep(y,1,m) {
            while(top&&fx[st[top]]<=fx[y]) top--;
            while(top>1&&!cmpc(y,st[top],st[top-1])) top--;
            st[++top]=y;
            for(int id:p[x][y]) {
                int k=qx[id]-bx[x+1]; ans[id]=max(ans[id],fy[st[1]]-fx[st[1]]*k);
                int l=2, r=top;
                while(l<=r) {
                    int mid=l+r>>1; ans[id]=max(ans[id],fy[st[mid]]-fx[st[mid]]*k);
                    if(cmpk(st[mid],st[mid-1],k)) l=mid+1;
                    else r=mid-1;
                }
            }
        }
    }
    rep(i,1,n) rep(j,1,m) p[i][j].clear();
    rep(i,1,q) {
        int px=lower_bound(bx+1,bx+n+1,qx[i])-bx, py=upper_bound(by+1,by+m+1,qy[i])-by-1;
        p[py][px].eb(i);
    }
    rep(y,0,m) {
        per(x,n,1) fx[x]=wy[x][y+1], fy[x]=f[x][y];
        int top=0;
        per(x,n,1) {
            while(top&&fx[st[top]]<=fx[x]) top--;
            while(top>1&&!cmpc(x,st[top],st[top-1])) top--;
            st[++top]=x;
            for(int id:p[y][x]) {
                int k=by[y]-qy[id]; ans[id]=max(ans[id],fy[st[1]]-fx[st[1]]*k);
                int l=2, r=top;
                while(l<=r) {
                    int mid=l+r>>1; ans[id]=max(ans[id],fy[st[mid]]-fx[st[mid]]*k);
                    if(cmpk(st[mid],st[mid-1],k)) l=mid+1;
                    else r=mid-1;
                }
            }
        }
    }
    rep(i,1,q) printf("%lld\n",ans[i]);
    return 0;
}
```

---


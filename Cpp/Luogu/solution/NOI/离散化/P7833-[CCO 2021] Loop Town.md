# [CCO 2021] Loop Town

## 题目描述

循环镇有 $n$ 个公民、$n$ 座房子、$n$ 个办公室。每个公民住在一座房子中，并在一个办公室工作。没有两个公民住在同一座房子，也没有两个公民在同一个办公室工作。

循环镇是一个环形城市，绕城一圈路程为 $l$。循环镇的 $2n$ 栋建筑（房子和办公室）都在环上的整点上，其位置可以用 $[0, l - 1]$ 范围内的整数来描述，且这 $2n$ 栋建筑位置是互不相同的。

每天早上，每个公民同时从自己的房子出发，沿着环路走到自己的办公室。公民到达办公室之后不会立刻进去工作，而是要等到所有公民都到达办公室之后才会同时进入办公室开始工作。

一场疫情的到来打破了常规，领导人要求每个公民保持社交距离。围绕城市的环状道路很窄，两个公民的线路存在相互交叉时会很不方便（必须一个人暂时离开道路才能使另一个人通过），而三个人或以上禁止同时走到同一个地方。

领导人可以给每个公民规定上班路线，即走城市环路的哪一边。领导人的目标是任意两个公民线路交叉的总次数最小，求这个最小值。

## 说明/提示

#### 数据范围
对于 $\frac{4}{13}$ 的数据，$1 \leq n \leq 5 \times 10^3$；

对于 $\frac{8}{13}$ 的数据，$1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq l \leq 10^9$，$0 \leq a_i, b_i < l$，**保证 $a_i, b_i$ 互不相同**。
#### 题目来源
[CCO2021](https://cemc.math.uwaterloo.ca/contests/computing/2021/index.html) D2T3

## 样例 #1

### 输入

```
3 100
10 50
30 20
60 40```

### 输出

```
0```

## 样例 #2

### 输入

```
4 100
30 70
10 12
60 75
90 50```

### 输出

```
1```

# 题解

## 作者：Y204335 (赞：5)

# \[CCO2021] Loop Town

## 题目大意

有一个长 $l$ 的环，有 $n$ 个人，他们有初始顺序 $a$ 和最终顺序 $b$，要求给每个人规定路线，使得路线交叉次数最少。

## 题目分析

两人路线的交叉其实相当于**交换这两人的相对位置**，题目也就是问每次可以交换相邻的两人，最少多少次交换可以把初始顺序变为最终顺序。

如果这是在链上，其实就是经典的逆序对问题，但很容易就能发现逆序对在环上是没有意义的，但逆序对描述的部分性质在环上仍然成立，逆序对描述的是一种包含关系，即 $a_i<a_j<b_j<b_i$，在这种情况下显然一定需要一次交换。同样在环上，这种包含关系也一定需要一次交换，但不同的是，像 $b_i<a_j<a_i<b_j$ 这样的情况，在链上一定要交换，而在环上则不一定。

考虑如何处理，在环上所有人都向同一方向走一定是不劣的（显然如果方向不同，则如 $a_i<a_j<b_i<b_j$ 的情况可能产生额外的贡献），这里钦定向右。

可以处理出每条路线被其他几条路线包含，在离散化后处理每条路线，使用树状数组可以实现 $O(n\log n)$ 的处理，但是由于在环上，终点和起点的相对位置可以改变，从而改变路线，所以要处理 $n$ 次，总复杂度为 $O(n^2\log n)$。

考虑优化，由于是整体平移，位置的相对关系是不变的，所以只有当平移后出现了 $a_i=b_i$ 的情况，**路线完全发生变化**（从一路向右一圈变为直接到达，如下图），**包含关系发生变化，答案才会改变**。![](https://cdn.luogu.com.cn/upload/image_hosting/y00bw5md.png)

考虑平移 $b$ 后贡献的变化情况，从而能从之前的答案直接转移，设 $path_i$ 为 $i$ 从 $a_i$ 向右走直到 $b_i$ 的路线上点的集合（可以从 $n$ 走到 $1$）。

1. 当 $path_i$ 完全改变时，原来满足 $path_j\subset path_i$ 的 $j$ 将不再满足条件，而 $path_i$ 在完全变化前一定是首尾相接的（如上图），此时只有当 $j$ 满足 $a_i\in path_j$ 时（由于 $a_i$ 互不相同，所以不会出现重叠的情况），$path_j\not\subset path_i$，所以减少的贡献可以由 $n-sum_{a_i\in path_j}$ 算出（注意此处的 $j$ 可以等于 $i$）。
2. 当 $path_i$ 完全改变时，原来不满足 $path_i\subset path_j$ 的 $j$ 可能满足条件，$j$ 满足条件当且仅当 $a_i\in path_j$，新增贡献也就是 $sum_{a_i\in path_j}$。![](https://cdn.luogu.com.cn/upload/image_hosting/t5b3bdry.png)

可以发现，贡献的变化只和每一时刻的 $sum_{a_i\in path_j}$ 相关，考虑快速计算 $sum_{a_i\in path_j}$，由于 $b$ 为一个 $1\dots n$ 的排列（指离散化后，不难发现中间状态是无用的），所以每一次平移 $b$ 后一定有一个新的 $j$ 使得 $b_j=a_i$，也就是一定会有一个新的 $j$ 满足 $a_i\in path_j$，此时 $sum_{a_i\in path_j}$ 一定加一，但由于当 $a_i=b_i$ 时路线会完全变化，所以要减去 $sum_{a_i=b_i}$，这样就能从上一时刻的 $sum_{a_i\in path_j}$ 转移到当前时刻。

可以先朴素处理初始的答案，用差分处理初始时刻的 $sum_{a_i\in path_j}$，并把每个人挂到对应能使得 $a_i=b_i$ 的平移次数上，之后再计算每次平移后的答案以及 $sum_{a_i\in path_j}$，答案取最小值即可。

初始处理为 $O(n\log n)$，之后每次平移均摊复杂度为 $O(1)$，总时间复杂度为 $O(n\log n)$。

注：处理初始答案时，有多种包含的情况，代码中使用了 $3$ 个树状数组，相应处理的情况以注释给出；在处理初始时刻的 $sum_{a_i\in path_j}$ 时，在对差分前缀和后，要把每一个点的值减一，去掉自身；在计算每次平移的答案时，第一种情况（贡献减少）中，由于出现 $a_i=b_i$ 的时，新的满足 $a_i\in path_j$ 的 $j$ 就是 $i$，此时就会把 $i$ 算上，如果算初始 $sum_{a_i\in path_j}$ 不减去自身，在此处就会算重；由于在代码中 $sum_{a_i\in path_j}$ 在答案之后更新，贡献变化的第二种情况（贡献增加）中的 $j$ 显然不能在这一时刻满足 $a_j=b_j$，所以要还要减去 $sum_{a_i=b_i}$，并且由于这一时刻满足 $a_i\in path_j$ 的 $j$ 就是 $i$ 而多算上的自身也会在这里被消掉。

## 代码

```cpp
#include <bits/stdc++.h>
#define fir first
#define sec second
#define ll long long
using namespace std;
const int N = 1e6 + 10;
int n, l, id[N], lsh[N], pre[N];
ll ans, res, cnt;
pair<int, int> a[N];
vector<int> x[N];
struct tree {
    int tr[N];
    tree()
    {
        memset(tr, 0, sizeof(tr));
    }
    void upd(int x, int w)
    {
        while (x <= n) {
            tr[x] += w;
            x += x & -x;
        }
    }
    int quary(int x)
    {
        int res = 0;
        while (x) {
            res += tr[x];
            x -= x & -x;
        }
        return res;
    }
} tr1, tr2, tr3; // 1 A-B-B-A  2 -B-B-A A- 3 -B-A A-B-
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cin >> n >> l;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].fir >> a[i].sec;
        lsh[i] = a[i].sec;
    }
    sort(a + 1, a + n + 1);
    sort(lsh + 1, lsh + n + 1);
    for (int i = 1; i <= n; i++) {
        id[i] = lower_bound(lsh + 1, lsh + n + 1, a[i].sec) - lsh;
    }
    for (int i = 1; i <= n; i++) {
        if (id[i] < i) {
            tr2.upd(id[i], 1);
        }
    }
    for (int i = 1; i <= n; i++) {
        if (i <= id[i]) {
            pre[i]++;
            pre[id[i] + 1]--;
            x[n - (id[i] - i)].push_back(i);
            res += tr1.quary(n) - tr1.quary(id[i] - 1);
            res += tr2.quary(n) - tr2.quary(id[i] - 1);
            tr1.upd(id[i], 1);
        } else {
            pre[1]++;
            pre[id[i] + 1]--;
            pre[i]++;
            x[i - id[i]].push_back(i);
            res += tr3.quary(n) - tr3.quary(id[i] - 1);
            tr1.upd(n, 1);
            tr3.upd(id[i], 1);
        }
    }
    for (int i = 1; i <= n; i++) {
        pre[i] += pre[i - 1];
    }
    for (int i = 1; i <= n; i++) { // self
        pre[i]--;
    }
    ans = res;
    for (int i = 1; i < n; i++) { //-->
        for (auto j : x[i]) {
            res += (pre[j] + i - cnt - x[i].size()) - (n - (pre[j] + i - cnt));
        }
        cnt += x[i].size();
        ans = min(ans, res);
    }
    cout << ans;
    return 0;
}
```

---

## 作者：jinhaoxian (赞：2)

定义 $L>2$ 时，以 $0$ 为起点，环上指向 $1$ 长度较短的路径方向为顺时针（即从 $0$ 开始顺时针依次为 $0,1,\cdots L-1$。

题意转化（原题面表述不是特别清楚）：记长度为 $N$ 的排列 $p,q$ 满足 $a_{p_i}<a_{p_{i+1}},\, b_{q_i}<b_{q_{i+1}}$，将 $p,q$ 视作圆排列（即 $p_1$ 与 $p_N$ 相邻，$q_1$ 与 $q_N$ 相邻），每次可以交换 $p$ 相邻两个位置的值，求最少的交换次数使得 $p$ 转化为 $q$（作为圆排列，即排列 $1,2,\cdots N$ 和 $2,3,\cdots N-1,N,1$ 视为相同排列）。

结论：定义 $[x,y](x\le y)$ 为集合 $\{x,x+1,\cdots y\}$，$[x,y](x>y)$ 为集合 $\{x,x+1,\cdots N-1,N,1,2,\cdots y\}$，每次对 $q$ 循环移位，答案为集合 $[p_i,q_i]$ 之间包含关系数（即满足 $[p_i,q_i]\subset [p_j,q_j]$ 的 $(i,j)$ 组数）的最小值。结论证明见[Alfalfa_w](https://www.cnblogs.com/alfalfa-w/p/17914326.html)。

初始（未对 $q$ 循环移位）答案使用树状树组可以 $O(n\log n)$ 求解。每次进行循环移位，容易发现 $(i,j)$ 状态改变（从符合条件变为不符合条件，或从不符合条件变为符合条件）时必有 $p_i=i$ 或 $p_j=j$。具体而言，答案相比循环移位前答案多或少的部分可分为以下两类：
1. 移位后 $p_j=q_j$，移位前符合条件的 $(x,j)$ 不再符合条件
2. 移位后 $p_i=q_i$，移位前不符合条件的 $(i,x)$ 此时符合条件

对于 2，移位前不存在符合条件的 $(i,x)$，因此只需计算移位后符合条件的 $x$ 的个数，即满足 $i\in [p_x,q_x]$ 的 $x$ 的个数。对于 1，移位后不存在符合条件的 $(x,j)$，且移位前 $(x,j)$ **不**符合条件当且仅当移位**前** $i \in[p_x,q_x]$ 于是两者都可以转化为某时刻某数出现在多少个 $[p_x,q_x]$ 的问题。

对于每个数，初始的出现次数可用前缀和求出。每次循环移位后，若 $p_x\neq q_x$，则 $q_x\in [p_x,q_x]$ 仅在移位后成立，由于 $q$ 任意时刻均为 $1$ 到 $N$ 的排列，因此若不存在 $p_x=q_x$ 则每个数出现次数恰好加 $1$。对于 $p_x=q_x$，则除了 $q_x$（即 $p_x$）外每个数移位后不再属于集合 $[p_x,q_x]$，则只需对每个数出现次数减 $1$ 再对 $q_x$ 出现次数加 $1$ 即可。因此每次循环移位，每个数出现次数同时加 $1-T$（其中 $T$ 为符合 $p_x=q_x$ 的 $x$ 个数）。预处理出对于每个 $x$，$p_x=q_x$ 对应的时刻，这一过程即可以均摊 $O(N)$ 维护，总时间复杂度 $O(N\log N)$。

[提交记录](https://loj.ac/s/2037659)

---


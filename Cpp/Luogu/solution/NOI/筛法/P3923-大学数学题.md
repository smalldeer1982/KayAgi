# 大学数学题

## 题目背景

琪露诺：我知道了！答案一定是1！

露米娅：什么鬼啊（汗），你还是再想想去吧。。我先把最后一道题给你，这是一道大学数学题哦

## 题目描述

露米娅：大妖精想构造一个 $ n $ 元有限域，元素用 $ 0 \sim n - 1 $ 的整数表示。


有限域需要满足以下条件：


1. 有加法单位元 $ o $ ，满足对于任意元素 $ a $ ， $ o + a = a + o = a $；


2. 对于任意元素 $ a $ ，存在加法逆元 $ a^{-1} $ ，使得 $ a + a^{-1} = a^{-1} + a = o $；


3. 有不同于加法单位元 $ o $ 的乘法单位元 $ i $ ，满足对于任意元素 $ a $ ， $ i \times a = a \times i = a $；


4. 对于任意非加法单位元元素 $ a $ ，存在乘法逆元 $ a^{-1} $ ，使得 $ a \times a^{-1} = a^{-1} \times a = i $；


5. 对于任意元素 $ x $ , $ y $ ，有加法交换律，即 $ x + y = y + x  $；


6. 对于任意元素 $ x $ , $ y $ ，有乘法交换律，即 $ x \times y = y \times x  $；


7. 对于任意元素 $ x $ , $ y $ , $ z $ ，有加法结合律，即 $ ( x + y ) + z = x + ( y + z ) $；


8. 对于任意元素 $ x $ , $ y $ , $ z $ ，有乘法结合律，即 $ ( x \times y ) \times z = x \times ( y \times z ) $；


9. 对于任意元素 $ x $ , $ y $ , $ z $ ，有乘法分配律，即 $ ( x + y ) \times z = x \times z + y \times z $。


大妖精当然会做啦，但是他想考考你。


在输出中加法单位元  $ o $ 即为 $ 0 $，乘法单位元  $ i $ 即为 $ 1 $。

## 说明/提示

| 测试点  |  $ n $ 的范围      | 特殊性质|
| :-------: | :----------: | :-----------------: |
|1  | $ n = 3 $    | $ n $ 是质数           |
|2  | $ n = 4 $     | $ n $ 是 $ 2 $ 的整数次方 |
|3  | $ n = 6 $     |                无            |
|4  | $ n = 8 $     | $ n $ 是 $ 2 $ 的整数次方 |
|5  | $ n = 9 $     |                无            |
|6  | $ n = 19 $  | $ n $ 是质数           |
|7  | $ n = 89 $   | $ n $ 是质数           |
|8  | $ n = 181 $ | $ n $ 是质数           |
|9  | $ n = 233 $ | $ n $ 是质数           |
|10| $ n = 25 $  | $ n $ 是质数的平方|
|11| $ n = 121 $ | $ n $ 是质数的平方|
|12| $ n = 169 $ | $ n $ 是质数的平方|
|13| $ n = 27 $   |                无            |
|14| $ n = 143 $ |                无            |
|15| $ n = 128 $ | $ n $ 是 $ 2 $ 的整数次方 |
|16| $ n = 81 $   |                无            |
|17| $ n = 125 $ |                无            |
|18| $ n = 243 $ |                无            |
|19| $ n = 256 $ | $ n $ 是 $ 2 $ 的整数次方 |
|20| $ n = 343 $ |                无            |

## 样例 #1

### 输入

```
2
```

### 输出

```
0
0 1
1 0
0 0
0 1
```

# 题解

## 作者：Drystynt (赞：15)

**Updated On 2021/9/19.** 笔者学了抽象代数之后，做了一些补充，同时修改了一些对专业术语的措辞。增加的地方加了P.S.。**P.S.的部分比较难懂，若无法理解可以不看它们。不看P.S.的部分对全文理解不会有过多的影响。**



------------

一个有趣的抽象代数题。

开始我也是没有思路，于是就开始碰碰运气。我们先试一下`-1`:

```cpp
case 6:case 143:cout<<"-1";break;
```
发现自己得了10分。对的是哪两个点呢？

第3和第14个，此时 $n=6$ 或 $143$ 。注意到其他的数都是素数的不小于1的整数幂，而这两个不是，于是猜想：**不存在大于1个素因子的合数之元的有限域。**

于是我们不管这些合数了，只看素数的不小于1的整数幂。先观察素数：因为素数的完全剩余系与简化剩余系是相同的，我们直接把两个数相加并模这个素数即可。\[P.S. 这里在有限域中即为：$GF(p)=\mathbb{Z}/p\mathbb{Z}.$\]

```cpp
case 3:case 19:case 89:case 181:case 233:
{
   cout<<"0"<<endl;
   for(int i=0;i<n;i++)
   {
     for(int j=0;j<n;j++)
     {
        cout<<(i+j)%n;
        if(j==n-1)continue;
        else cout<<' ';
     }
     cout<<endl;
   }
   for(int i=0;i<n;i++)
   {
     for(int j=0;j<n;j++)
     {
        cout<<(i*j)%n;
        if(j==n-1)continue;
        else cout<<' ';
     }
     cout<<endl;
   }
}break;
```
于是就$35$分到手了

后面怎么办呢？

我试了一个小时$n=4$的情况，终于试出来：

```cpp
if(n==4)
{
	cout<<0<<endl;
	cout<<"0 1 2 3\n1 0 3 2\n2 3 0 1\n3 2 1 0\n0 0 0 0\n0 1 2 3\n0 2 3 1\n0 3 1 2"<<endl;
	return 0;
}
```

然后没有思绪。

于是在网上找"有限域"，发现需要：

相加或相乘再模 $p$ ，就是 $p$ 进制中个位的运算。那么 $n=p^k$
 的情况也就能解决了。

这里，每个有限域中的数都是一个多项式的值的 $p$ 进制的一个数位。于是解决了加法。

找出一个系数在 $[0,p)$ 中的 $k$ 次既约多项式，这里 $k\leqslant 8$ .关键是想要如何找到。

再把它与原多项式相乘再模 $p$ 处理即可，正确性显然。

$p=2$ 时，加法只需要把两个数异或一下。乘法怎么办？

举 $3\times 5$ 的例子：

$3=(11)_2=p+1(p=2)$

$5=(101)_2=p^2+1(p=2)$

$3\times 5=(p+1)(p^2+1)=p^3+p^2+p+1$

但这个数已经大于 $8$ 了，于是我们模一个不可约多项式 $p^3+p+1$，得到 $p^2$，于是 $3\times 5=4$.

当然多项式也不好找，需要自己动脑筋。

下附所有$2$的幂情况标程：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 17
int p;
struct f//多项式
{
	int a[N];
	int dr()
	{
		for(int i=N-1;i>=0;i--)
			if(a[i]!=0)	return i;
		return 0;	
	}
	inline void clr()
	{
		for(int i=0;i<N;i++)	a[i]=0;
		return;
	}
	inline void mod()
	{
		for(int i=0;i<N;i++)	a[i]%=p;
		return;
	}
};
inline f mul(f x,int l)//数乘
{
	for(int i=0;i<N;i++)	x.a[i]*=l;
	return x;
}
f gt(int x)//数转换为多项式
{
	f ans;ans.clr();
	for(int i=0;;i++)
	{
		if(x==0)	return ans;
		else{ans.a[i]=x%p;x/=p;}
	}
}
int ungt(f ans)//多项式转为数
{
	int x=0;
	for(int i=ans.dr();i>=0;i--)
		x=(x*p)+ans.a[i];
	return x; 
}
f add(f x,f y)//加
{
	for(int i=0;i<=N;i++)
		x.a[i]=(x.a[i]+y.a[i])%p;
	return x;
}
f yiw(f x,int sum)//移位
{
	for(int i=x.dr();i>=0;i--)	x.a[i+sum]=x.a[i];
	for(int i=sum-1;i>=0;i--)	x.a[i]=0;
	return x;
}
f prod(f x,f y)//多项式相乘
{
	f ans;ans.clr();
	for(int i=0;i<=x.dr();i++)
	{
		if(x.a[i]!=0)	ans=add(ans,mul(yiw(y,i),x.a[i]));
	}
	ans.mod();
	return ans;
}
f Mod(f x,f y)//多项式取模
{
	int sg=y.dr()-1;
	for(int i=x.dr();i>=sg+1;i--)
	{
		if(x.a[i]==0)	continue;
		else
		{
			x=add(x,mul(yiw(y,i-sg-1),p-x.a[i]));
			x.mod();
		}
	}
	return x;
}
f Num(int x)//找多项式
{
	f ans;ans.clr();
	if (x==8)ans.a[0]=ans.a[1]=ans.a[3]=1;
	if (x==256)	ans.a[8]=ans.a[4]=ans.a[3]=ans.a[1]=ans.a[0]=1;
	if (x==16)	ans.a[2]=ans.a[4]=ans.a[3]=ans.a[1]=ans.a[0]=1;
	if (x==128)	ans.a[7]=ans.a[6]=ans.a[5]=ans.a[2]=ans.a[0]=1;
	return ans;
}
```
主函数内的：
```
	case 256:case 128:case 8:
        {
        	p=2;
            cout<<0<<endl;
            for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    cout<<(i^j);
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
            }
            for(int i=0;i<n;i++)
            {
            	for(int j=0;j<n;j++)
                {
                    f x=gt(i);
                    f y=gt(j);
                    f z=prod(x,y);
                    z=Mod(z,Num(n));
                    int ans=ungt(z);
                    cout<<ans;
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
			}
        }break;
```

最后，给出满分程序，但是多项式请自己找。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 17
int p;
struct f
{
	int a[N];
	int dr()
	{
		for(int i=N-1;i>=0;i--)
			if(a[i]!=0)	return i;
		return 0;	
	}
	inline void clr()
	{
		for(int i=0;i<N;i++)	a[i]=0;
		return;
	}
	inline void mod()
	{
		for(int i=0;i<N;i++)	a[i]%=p;
		return;
	}
};
inline f mul(f x,int l)
{
	for(int i=0;i<N;i++)	x.a[i]*=l;
	return x;
}
f gt(int x)
{
	f ans;ans.clr();
	for(int i=0;;i++)
	{
		if(x==0)	return ans;
		else{ans.a[i]=x%p;x/=p;}
	}
}
int ungt(f ans)
{
	int x=0;
	for(int i=ans.dr();i>=0;i--)
		x=(x*p)+ans.a[i];
	return x; 
}
f add(f x,f y)
{
	for(int i=0;i<=N;i++)
		x.a[i]=(x.a[i]+y.a[i])%p;
	return x;
}
f yiw(f x,int sum)
{
	for(int i=x.dr();i>=0;i--)	x.a[i+sum]=x.a[i];
	for(int i=sum-1;i>=0;i--)	x.a[i]=0;
	return x;
}
f prod(f x,f y)
{
	f ans;ans.clr();
	for(int i=0;i<=x.dr();i++)
	{
		if(x.a[i]!=0)	ans=add(ans,mul(yiw(y,i),x.a[i]));
	}
	ans.mod();
	return ans;
}
f Mod(f x,f y)
{
	int sg=y.dr()-1;
	for(int i=x.dr();i>=sg+1;i--)
	{
		if(x.a[i]==0)	continue;
		else
		{
			x=add(x,mul(yiw(y,i-sg-1),p-x.a[i]));
			x.mod();
		}
	}
	return x;
}
f Num(int x)
{
	//自己找
}
int main()
{
    ios::sync_with_stdio(0);
    int n;
    cin>>n;
    if(n==4){cout<<0<<endl;cout<<"0 1 2 3\n1 0 3 2\n2 3 0 1\n3 2 1 0\n0 0 0 0\n0 1 2 3\n0 2 3 1\n0 3 1 2"<<endl;return 0;}
    switch(n)
    {
        case 6:case 143:cout<<"-1";break;
        case 3:case 19:case 89:case 181:case 233:
        {
            cout<<"0"<<endl;
            for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    cout<<(i+j)%n;
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
            }
            for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    cout<<(i*j)%n;
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
            }
        }break;
        case 256:case 128:case 8:
        {
        	p=2;
            cout<<0<<endl;
            for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    cout<<(i^j);
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
            }
            for(int i=0;i<n;i++)
            {
            	for(int j=0;j<n;j++)
                {
                    f x=gt(i);
                    f y=gt(j);
                    f z=prod(x,y);
                    z=Mod(z,Num(n));
                    int ans=ungt(z);
                    cout<<ans;
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
			}
        }break;
        default:
        {
        	p=...//自己写if
        	cout<<0<<endl;
        	for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    f x=gt(i);
                    f y=gt(j);
                    f z=add(x,y);
                    int ans=ungt(z);
                    cout<<ans;
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
            }
            for(int i=0;i<n;i++)
            {
            	for(int j=0;j<n;j++)
                {
                    f x=gt(i);
                    f y=gt(j);
                    f z=prod(x,y);
                    z=Mod(z,Num(n));
                    int ans=ungt(z);
                    cout<<ans;
                    if(j==n-1)continue;
                    else cout<<' ';
                }
                cout<<endl;
			}
		}
    }
    return 0;
}
```

P.S.

这里简略地证明一下有限域的元素个数必为 $p^n$ 的形式，其中 $p$ 为素数，下文中字母 $p$ 未加说明均为素数。我们假定读者学过群论。

"环"的定义详见[此](https://baike.baidu.com/item/%E7%8E%AF/12795512?fr=aladdin)。

环同态基本定理与群同态基本定理很类似。学过群论的应该都知道群同态基本定理，所以笔者认为不必介绍环的像、$\text{kernel}$(核)、环同态和环同态基本定理。

设有限域为 $GF(k),k$ 为有限域元素个数。显然存在 $GF(p)$.

**定义1**.设 $F$ 是域。使得 $n·1=0$ 的最小正整数 $n$ 称为 $F$ 的**特征**。若不存在这样的正整数称其特征为 $0$。我们把特征记为 $char(F)$.

**引理1**. 设 $F$ 为一个域，若 $char(F)>0$ ，则 $char(F)$ 必为素数。

证明：反证法，设 $n=char(F)$，若 $n$ 为合数，则 $n=uv$ ，$u>1,v>1$ 为整数。故 $(u·1)(v·1)=(uv)·1=n·1=0$. 由 $n$ 的最小性知 $u·1≠0$ ，从而 $u·1$ 有逆元 $(u·1)^{-1}$。上式两端同乘 $(u·1)^{-1}$ 知 $v·1=0$，与 $n$ 的最小性矛盾！

**引理2.** 设 $F$ 为域。若 $char(F)=p>0$，则 $F$ 必有与 $GF(p)$ 同构的子域。

证明：定义映射

$$\varphi: \mathbb{Z} \rightarrow F $$

$$n \mapsto n·1$$

显然 $\varphi$ 是环同态。我们断言 $\ker \varphi=p\mathbb{Z}.$ 设 $n∈\ker \varphi,$ 即$n·1=0∈F.$ 设 $n=qp+r\ (q,r∈\mathbb{Z}, 0\leqslant r<q)$ 则有 $0=n·1=q(p·1)+r·1=r·1$，由 $char$ 的定义知 $p$ 只能为 $0$. 故 $n∈p\mathbb{Z}$，这说明 $\ker \varphi \subseteq p\mathbb{Z}.$

反之，对 $n∈p\mathbb{Z}$ 设 $n=pq$ ，则 $\varphi(n)=(qp)·1=q(p·1)=0$，从而 $n∈\ker \varphi$，即 $p\mathbb{Z}\subseteq\ker \varphi.$

故断言成立。由环同态基本定理，
 $GF(p)=\mathbb{Z}/p\mathbb{Z}\cong \text{im}\ \varphi $.

由 $\text{im}\ \varphi $ 为 $F$ 的子域，故证毕。

回到原问题，设 $K$ 为有限域，则 $K$ 包含 $GF(p)$ ，且 $K/GF(p)$ 必为有限扩张（定义见[此](https://baike.baidu.com/item/%E5%9F%9F%E6%89%A9%E5%BC%A0/1745048)），故 $|K|$ 只有一个素因子，证毕！

P.S.P.S. 题外话：可以证明所有的 $GF(p^n)$ 均同构，所以上面的构造相当于是唯一的。

---

## 作者：oscar (赞：15)

解法0：

学习⑨。。等等，去哪学习⑨

期望得分：0分

解法1：

输出-1

期望得分：10分

解法2：

暴力写一个程序搜索小数据

时间复杂度O(反正n=8跑不完)

期望得分：15分

解法3：

对于n为质数情况直接输出mod n的结果

时间复杂度O(n^2)

期望得分：25分

解法4：

找规律，发现只有两个点不能表示成p^k的形式（p为质数，k为正整数）

使用解法1后发现正好有两个点通过了

于是果断在这两个点输出-1，并综合前面做法

期望得分：40分

解法5：

设n=p^k，猜想一定存在

将有限域中的数看做一个mod p意义下的k次多项式，每项为p进制下对应位

加法很自然就能完成

乘法需要找到一个mod p意义下的k次不可约多项式，将两个多项式乘完后取除以该不可约多项式的结果

最后转化为10进制数输出

时间复杂度O(反正一秒内跑得完)

期望得分：40~100分（取决于能手玩出多少不可约多项式）（好像不可约多项式也可以爆搜出来？）

不给标程啦


---

## 作者：feecle6418 (赞：10)

从《组合数学》上看到的构造方法：（以下设 $n=p^k$）

- 找出一个不能用非平凡方法分解，系数在 $[0,p)$ 中的 $k$ 次多项式；
- 令这个多项式的一个根为 $i$；
- 这个域的元素即为 $a_0+a_1i+\dots+a_{k-1}i^{k-1}$，因为大于等于 $k$ 次的都可以恒等变形降到 $k-1$ 次。加法和乘法直接按定义运算（当然要 $\mathrm{mod}\ p$，同时乘法要降次）。

正确性显然，这里不作证明。只想无限 orz 第一个想到的人 %%%

有了构造方法，实现就很简单了。可以实现一个 `complex` 类，运算会方便一些。

当然这个多项式也很重要……这里友情提供 $4$ 次和 $8$ 次多项式：

- $x^4+x^3+x^2+x+1$
- $x^8+x^4+x^3+x+1$

出题人没有给代码。由于对 xxs 的恐惧，我也不给代码。相信看懂了的自己都写得出来。

---

## 作者：cancan123456 (赞：7)

作为手写过 AES-128 加密的蒟蒻，对于有限域当然是非常了解的（毕竟 ASE-128 加密就是以 $n=256$ 时的有限域为基础的）。在下文中，我们称题目中给出的 $n$ 元有限域为 $GF(n)$。

首先有两个结论：如果 $n$ 可以表示为 $p^k$（$p$ 为质数）次方的形式，那么一定有一个有限域满足题目中的条件。

那么我们以 $n=256=2^8$ 举例，说明这个有限域的运算规则。

### 首先是加法：计算 27 + 253。

第一步，将这两个数表示为多项式形式：

$27=0x^7+0x^6+0x^5+1x^4+1x^3+0x^2+1x^1+1x^0$

$253=1x^7+1x^6+1x^5+1x^4+1x^3+1x^2+0x^1+1x^0$

第二步，加起来（注意系数要 $\bmod\ p$）：

$27 + 253$

$ = (0x^7+0x^6+0x^5+1x^4+1x^3+0x^2+1x^1+1x^0)+(1x^7+1x^6+1x^5+1x^4+1x^3+1x^2+0x^1+1x^0)$

$ = 1x^7+1x^6+1x^5+0x^4+0x^3+1x^2+1x^1+0x^0$

$ = 230$

### 第二是乘法：计算 25 * 73。

第一步，将这两个数表示为多项式形式：

$25=0x^7+0x^6+0x^5+1x^4+1x^3+0x^2+0x^1+1x^0$

$73=0x^7+1x^6+0x^5+0x^4+1x^3+0x^2+0x^1+1x^0$

第二步，将这两个多项式乘起来！（注意系数仍然要 $\bmod\ p$）

$(0x^7+0x^6+0x^5+1x^4+1x^3+0x^2+0x^1+1x^0)(0x^7+1x^6+0x^5+0x^4+1x^3+0x^2+0x^1+1x^0)$

$ = 0x^{14}+0x^{13}+0x^{12}+0x^{11}+1x^{10}+1x^9+0x^8+1x^7+0x^6+1x^5+1x^4+1x^3+0x^2+1x^1+0x^0$

我们发现这里，可能会出现次数高达 14 的项，这时我们也需要模一个东西，这个东西叫做**不可约多项式**。

不可约多项式说白了就是有限域中的素数，除了 $x ^ 0$ 和它自身之外没有能整除它的。

比如说 $GF(256)$ 中有一个不可约多项式是 $x^8+x^4+x^3+x^1+x^0$。

接下来我们把这个乘起来的多项式模 $x^8+x^4+x^3+x^1+x^0$，得到：

$25 * 73 = (0x^{14}+0x^{13}+0x^{12}+0x^{11}+1x^{10}+1x^9+0x^8+1x^7+0x^6+1x^5+1x^4+1x^3+0x^2+1x^1+0x^0) \bmod (x^8+x^4+x^3+x^1+x^0)$

$ = 1x^7+1x^6+1x^5+1x^4+0x^3+0x^2+0x^1+0x^0$

$ = 240$

搞清楚原理以后，我们就可以写一个结构体进行多项式的操作：[这里](https://www.luogu.com.cn/paste/isichg1o)，顺便加上了枚举和输出代码。

结果在[这里](https://www.luogu.com.cn/paste/w6ijlvqe)（略去了不用求的测试点）。

再结合我手写的结构体，就可以得到答案了。

附：本人写的代码效率极其低下，需要用提交答案才能过。

---

## 作者：littlez_meow (赞：5)

混沌邪恶抽代入门题。

[题目指路](https://www.luogu.com.cn/problem/P3923)。

阅读本题解前，你需要了解域的定义和其他抽代基础知识。

既然是抽代题那就一个一个结论推吧。

## 解的存在性

【约定 1】在不易混淆的情况下，将域 $(\mathbb{F},+,\times)$ 记为 $\mathbb{F}$，其加法单位元记为 $0$，乘法单位元记为 $1$。本文中的域均为有限域。

【定义 1】（域特征）对于有限域 $\mathbb{F}$，若 $\exists p\in N^*,p\times1=0$，则称最小的 $p$ 为 $\mathbb{F}$ 的特征。

【结论 1】有限域的特征是质数。

证明：设该有限域为 $\mathbb{F}$，其特征为 $p$。考虑反证法，设 $p=r\times s,1<r,s<p$。

根据 $0=p\times1$，带入得到 $0=(r\times s)\times 1$。

根据乘法结合律得到 $r\times(s\times 1)=0$。

又 $r\neq0$，故 $s\times1=0$，与 $p$ 最小矛盾，原命题得证。

【定义 2】（子域与域扩张）若 $F$ 是 $P$ 的非空子集，$(P,+,\times)$ 是域且 $(F,+,\times)$ 是域，则称 $(F,+,\times)$ 是 $(P,+,\times)$ 的子域，$(P,+,\times)$ 是 $(F,+,\times)$ 的扩张，记为 $(F,+,\times)\subseteq(P,+,\times)$。

【定义 3】（扩域的次数）若域 $F\subseteq K$，$K$ 可视为 $F-$ 向量空间，其次数称为扩域的次数，记为 $[K:F]$。

【结论 2】若域 $F\subseteq K$ 且 $F$ 为 $q$ 元有限域，则 $K$ 为 $q^m$ 元有限域，其中 $m=[K:F]$。

证明：因为 $K$ 可视为 $F$ 上 $m$ 维向量空间，取 $K$ 一组基向量，每个系数均有 $q$ 种取值，共 $m$ 个系数，乘法原理即得。

【约定 2】我们记 $\mathbb{F}_p$ 为包含 $p$ 个元素的域。显然当 $p$ 为质数时该域存在（模 $p$ 意义下整数域 $\mathbb{Z}_p$），且其无任何真子域。

【结论 3】（有限域元素个数）一个有限域 $\mathbb{F}$ 有 $p^n$ 个元素，其中 $p$ 为其特征。

证明：显然 $\mathbb{F}_p\subseteq\mathbb{F}$，由结论 2 即得。

读者可以自己搜索 $\mathbb{F}_p\subseteq\mathbb{F}$ 的证明。

由此可以得到：

【结论 4】（有限域的存在性和唯一性）$\forall p,n$，其中 $p$ 为质数，$n$ 为正整数，有限域 $\mathbb{F}_{p^n}$ 存在且唯一。

该定理的证明与本题无关，在此略去。

综上，我们得到当 $n$ 有且仅有一个质因数时，本题有解。即我们应在 case 3 与 case 14 输出 $-1$。

## 构造

请注意，有限域 $\mathbb{F}_{p^m}$ 并不是模 $p^m$ 意义下的整环。当且仅当 $m=1$ 时二者同构。

也就是说，如果 $n$ 为质数，直接当称普通模意义下的加法乘法就行。

那么，是质数的幂怎么办？设此时 $n=p^m$

根据结论 4，任何两个元素数相同的有限域同构。我们只需要找到一个现有的有限域 $(\mathbb{F}_{p^m},+,\times)$，然后构造一个双射 $f:\mathbb{F}_{p^m}\to\{0,1,2,\cdots,p^m-1\}$ 即可。

那么有什么呢？

$\mathbb{Z}_p$ 上的 $m$ 维向量空间！

确实，但是你需要定义向量间的乘法。因为要保证逆元，这是最难的一步。

换一个思路，还有什么同构？

所有系数在 $\mathbb{Z}_p$ 上的次数不超过 $m-1$ 次的多项式！

这下有乘法了，但是乘出来次数会超过 $m-1$。考虑模一个 $m$ 次多项式取模。

我们要保证所有非 $0$ 多项式均存在乘法逆元，这要多项式取模的模数是不可约的多项式。

为什么？

我们可以把多项式视为 $m$ 位的 $p$ 进制数。

若其有乘法逆元，则模数必须是质数，转换成多项式即不可约多项式。

最后的问题就是求不可约多项式了。

首先，如果多项式不首一，我们可以每个系数乘以首项系数逆元，不影响其是否可约。因此只用研究首一多项式。

其次，在求解的时候类似于质数枚举每个 $\lceil\dfrac m 2\rceil$ 阶多项式取模看有没有余项。

最劣的时间复杂度是 $O(n\sqrt nm^2)$，$n$ 这么小显然是跑得很快的。就算枚举到 $m$ 阶的也是 $O(n^2m^2)$，仍然跑得过。

## 代码

这里给出多项式板子和输出，找不可约多项式的部分就请自己写吧。

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i) 
#define ll long long
#define MOD p
using namespace std;
const int MAXN=30;
int n,m,p;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
inline void meow(int&t){
	t<0&&(t+=MOD);
	t>=MOD&&(t-=MOD);
	return;
}
struct poly{
	int num[MAXN]={};
	int len=0;
	inline void init(){
		while(!num[len]&&len>0) --len;
		return;
	}
	inline void turn(int t){
		while(t) num[len++]=t%MOD,t/=MOD;
		init();
		return;
	}
	inline poly operator+(const poly&a)const{
		poly res;
		res.len=max(a.len,len);
		F(i,0,res.len) res.num[i]=num[i]+a.num[i],meow(res.num[i]);
		res.init();
		return res;
	}
	inline poly operator+(const int a)const{
		poly res=*this;
		int&qwq(res.num[0]);
		qwq+=a;
		meow(qwq);
		return res;
	}
	inline poly operator-(const poly&a)const{
		return a*(-1)+*this;
	}
	inline poly operator-(const int a)const{
		return *this+(-a);
	}
	inline poly operator*(const poly&a)const{
		poly x;
		F(i,0,len) F(j,0,a.len){
			int&qwq(x.num[i+j]);
			qwq+=a.num[j]*1ll*num[i]%MOD;
			qwq>=MOD&&(qwq-=MOD);
		}
		x.len=len+a.len;
		x.init();
		return x;
	}
	inline poly operator*(const int a)const{
		poly res=*this;
		F(i,0,len){
			int&qwq(res.num[i]);
			qwq=a*1ll*qwq%MOD;
			meow(qwq);
		}
		return res;
	}
	inline bool operator<=(const poly&a)const{
		if(len!=a.len) return len<=a.len;
		R(i,len,0) if(num[i]!=a.num[i]) return num[i]<=a.num[i];
		return 1;
	}
	inline poly operator<<(const int a)const{
		poly res;
		res.len=a+len;
		F(i,0,len) res.num[a+i]=num[i];
		return res;
	}
	inline poly operator%(const poly&a)const{
		poly t=*this;
		while(a<=t){
			poly tmp=a*qpow(a.num[a.len],MOD-2)*t.num[t.len];
			t=t-(tmp<<(t.len-a.len));
		}
		t.init();
		return t;
	}
	inline bool check()const{//检查是否不可约
		poly x=*this,y;
		F(i,2,n-1){
			poly t;
			t.turn(i);
			y=x%t;
			if(y.len==0&&y.num[0]==0) return 0;
		}
		return 1;
	}
	inline void output(){
		F(i,0,m) cout<<num[i]<<" ";
		cout<<"\n";
		return;
	}
	inline int decode(){
		int res(0);
		R(i,len,0) res=res*p+num[i];
		return res;
	}
}mod;
inline void findmod(){

}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
	cin>>n;
	switch(n){
		case 2:case 3:case 19:case 89:case 181:case 233:{
			cout<<"0\n";
			F(i,0,n-1){
				F(j,0,n-1){
					cout<<(i+j)%n;
					j!=n-1&&(cout<<" ");
				}
				cout<<"\n";
			}
			F(i,0,n-1){
				F(j,0,n-1){
					cout<<i*j%n;
					j!=n-1&&(cout<<" ");
				}
				cout<<"\n";
			}
			return 0;
			break;
		}
		case 6:case 143:{
			cout<<"-1";
			return 0;
			break;
		}
		case 4:{
			m=2,p=2;
			break;
		}
		case 8:{
			m=3,p=2;
			break;
		}
		case 9:{
			m=2,p=3;
			break;
		}
		case 25:{
			m=2,p=5;
			break;
		}
		case 121:{
			m=2,p=11;
			break;
		}
		case 169:{
			m=2,p=13;
			break;
		}
		case 27:{
			m=3,p=3;
			break;
		}
		case 128:{
			m=7,p=2;
			break;
		}
		case 81:{
			m=4,p=3;
			break;
		}
		case 125:{
			m=3,p=5;
			break;
		}
		case 243:{
			m=5,p=3;
			break;
		}
		case 256:{
			m=8,p=2;
			break;
		}
		case 343:{
			m=3,p=7;
			break;
		}
	}
	findmod();
	cout<<"0\n";
	F(i,0,n-1){
		F(j,0,n-1){
			poly ii,jj;
			ii.turn(i),jj.turn(j);
			cout<<(ii+jj).decode();
			j!=n-1&&(cout<<" ");
		}
		cout<<"\n";
	}
	F(i,0,n-1){
		F(j,0,n-1){
			poly ii,jj;
			ii.turn(i),jj.turn(j);
			cout<<(ii*jj%mod).decode();
			j!=n-1&&(cout<<" ");
		}
		cout<<"\n";
	}
	return 0;
}
```

完结撒花 qwq~

---

## 作者：andychen_2012 (赞：3)

学了一下有限域，感觉找既约（不可约）多项式是最难的地方啊。主要的知识可以查看 oiwiki。其他题解都没有怎么讲如何找这个既约多项式。

对于质数是简单的，使用整数加法乘法，并对 $n$ 取模即可。

对于 $GF(p^n)$，我们构造的加法和乘法都应该是多项式的形式，也即

$$
a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+\cdots+a_0
$$

无论是加法或是乘法，其运算结果的系数都应对 $p$ 取模。

在学习完多项式之后，我们发现，多项式确实满足有限域除了逆元之外的所有性质，但问题在于，多项式乘法会导致出现 $x^{2n-2}$ 这样的项，因此我们需要对一个不可约多项式取模。$n$ 次不可约首一多项式是一个形如 $x^n+a_{n-1}x^{n-1}+\cdots+a_0$ 的多项式，而且没有因子，相当于一个素数。

关键在于，如何寻找 $n$ 次不可约首一多项式。既然我们使用该多项式的目的是构造逆元，那么只要让所有非零数都有乘法逆元即可。我们可以直接随机多项式的系数，然后判断其是否能让所有非零数都有乘法逆元，如果可以，那么其就是$n$ 次不可约首一多项式，记该多项式为 $g$。我们预处理 $x,x^2,\cdots,x^{2n}$ 对 $g$ 取模后的多项式，然后计算 $1 \times 1$ 到 $p^n \times p^n$ 的值，其时间复杂度是 $O(p^{2n}n^2)$，其中单次乘法的时间复杂度为 $n^2$。如果存在数没有乘法逆元，那么就重新随机。

由于 $GF(p^n)$ 上的 $n$ 次不可约首一多项式共有 $\frac{1}{n} \sum\limits_{d \mid n} \mu(d)p^{n^2/d}$ 个，而多项式的个数共有 $p^n$ 个。因此一次随机就能找到的概率为

$$
\frac{\sum\limits_{d \mid n} \mu(d)p^{n^2/d}}{np^n}
$$

这个概率是不小的，至少不小于 $\frac{1}{np^n}$。

使用题目规定的 $n$，则时间复杂度不高于 $O(n^3\log^3n)$。

关键代码如下：


```cpp
int np,up;
struct poly{
	int a[30];
	poly(){memset(a,0,sizeof(a));}
	friend poly operator +(poly x,poly y){
		poly z;
		for(int i=0;i<up;++i) z.a[i]=(x.a[i]+y.a[i])%np;
		return z;
	}
	friend poly operator *(poly x,poly y){
		poly z;
		for(int i=0;i<up;++i){
			if(!x.a[i]) continue;
			for(int j=0;j<up;++j){
				if(!y.a[j]) continue;
				z.a[i+j]=(z.a[i+j]+x.a[i]*y.a[j])%np;
			}
		}
		return z;
	}
	friend poly operator %(poly x,poly y){
		if(x.a[up]){
			for(int i=up-1;i>=0;--i)
				x.a[i]=(x.a[i]-x.a[up]*y.a[i]%np+np)%np;
			return x;
		}
		else return x;
	}
};
poly mod;
poly afmod[30];
inline int toint(poly x,int gp=np){
	int sum=0,now=1;
	for(int i=0;i<up;++i)
		sum+=x.a[i]*now,now*=gp;
	return sum;
}
inline poly topoly(int x){
	poly y;
	for(int i=0;i<up;++i)
		y.a[i]=x%np,x/=np;
	return y;
}
inline poly times(poly x,poly y){
	poly z;
	for(int i=0;i<up;++i){
		if(!x.a[i]) continue;
		for(int j=0;j<up;++j){
			if(!y.a[j]) continue;
			z.a[i+j]=(z.a[i+j]+x.a[i]*y.a[j])%np;
		}
	}
	for(int i=up;i<2*up;++i){
		if(z.a[i]){
			for(int j=0;j<up;++j)
				z.a[j]=(z.a[j]+afmod[i].a[j]*z.a[i])%np;
		}
	}
	return z;
}
int gtsum[355][355];
int gttms[355][355];
poly integ[355];
inline bool check(){
	for(int i=1;i<n;++i){
		bool flag=0;
		for(int j=0;j<n;++j){
			gttms[i][j]=toint(times(integ[i],integ[j]));
			if(gttms[i][j]==1) flag=1;
		}
		if(!flag) return 0;
	}
	return 1;
}
inline void init2(){
	for(int i=0;i<n;++i) integ[i]=topoly(i);
	for(int i=0;i<n;++i){
		for(int j=0;j<n;++j){
			gtsum[i][j]=toint(integ[i]+integ[j]);
		}
	}
	mt19937 rnd(time(0));
	poly bs;
	bs.a[1]=1;
	while(1){
		mod.a[up]=1;
		for(int i=0;i<up;++i) mod.a[i]=rnd()%np;
		bool flag=1;
		for(int i=0;i<n;++i){
			if(toint(mod,i)==0){
				flag=0;
				break;
			}
		}
		if(!flag) continue;
		afmod[0].a[0]=1;
		for(int i=1;i<=2*up;++i)
			afmod[i]=(afmod[i-1]*bs)%mod;
		if(check()) break;
	}
}
```

---

## 作者：warzone (赞：2)

前置芝士：[域论初步](https://www.luogu.com.cn/article/1xkqf00x)

**有限域** 即大小有限的域。由之前对域的特征及域扩张的维数的讨论，    
有限域的大小一定是 $p^n\ (n\in\N_+)$，其中素数 $p$ 为有限域的特征。  
此处约定有限域的素子域就是模 $p$ 整数域 $\Z_p$。

由拉格朗日定理，对于大小为 $p^n$ 的有限域 $F$，有

$$\forall a\in F,a^{p^n}=a$$

即 $F$ 中元素均为 $F$ 上多项式 $x^{p^n}-x$ 的根。因为 $\deg(x^{p^n}-x)=p^n=|F|$，  
故 $F$ 即 $x^{p^n}-x\in\Z_p[x]$ 在 $\Z_p$ 上的分裂域。  
又因为多项式的分裂域在同构意义下唯一，故 **有限域的结构被其大小唯一确定**。  
因此，我们将大小为 $p^n$ 的有限域记为 $\mathbb{F}_{p^n}$。

## 乘法结构与构造方法

同 $\pmod{p}$ 意义下原根的存在性证明，易证明 **有限域的乘法群一定是循环群**。  
取其乘法群的任意一个生成元 $\alpha$，可知 **有限域一定是其素子域 $\Z_p$ 的单代数扩域 $\Z_p(\alpha)$**。

对于任意的素数 $p$ 和正整数 $n$，$\mathbb{F}_{p^n}$ 是否一定是存在的呢？

> 求证：对于任意素数 $p$ 和正整数 $n$，$\Z_p[x]$ 中一定存在 $n$ 次不可约多项式。  
> 证明：设 $f(n)$ 为 $\Z_p[x]$ 中的 $n$ 次首一（最高次项系数为 $1$ 的）不可约多项式个数，  
> $\qquad$ 则只需要证明 $f(n)>0$ 即可。由组合意义得
> $$\dfrac{1}{1-px}=\prod_{k=1}^{+\infty}\dfrac{1}{(1-x^k)^{f(k)}}$$
> $\qquad$ 等式两边同时取对数得
> $$-\ln(1-px)=-\sum_{k=1}^{+\infty}f(k)\ln(1-x^k)$$
> $$\sum_{n=1}^{+\infty}\dfrac{p^n}{n}x^n=\sum_{k=1}^{+\infty}f(k)\sum_{i=1}^{+\infty}\dfrac{x^{ki}}{i}$$
> $$\dfrac{p^n}{n}=\sum_{i|n}\dfrac{f\left(\dfrac{k}{i}\right)}{i}$$
> $\qquad$ 这是狄利克雷卷积的形式。设 $g(n)=\dfrac{p^n}{n}$，$h(n)=\dfrac{1}{n}$，则
> $$g=f*h$$
> $\qquad h$ 是完全积性函数，由贝尔级数易得其狄利克雷卷积逆
> $$h^{-1}(n)=\dfrac{\mu(n)}{n}$$
> $\qquad$ 其中 $\mu$ 为莫比乌斯函数。于是
> $$f(n)=(g*h^{-1})(n)=\sum_{d|n}g(d)h^{-1}\left(\dfrac{n}{d}\right)$$
> $$=\sum_{d|n}\dfrac{p^d}{d}\times\dfrac{\mu\left(\dfrac{n}{d}\right)}{\dfrac{n}{d}}=\dfrac{1}{n}\sum_{d|n}p^d\mu\left(\dfrac{n}{d}\right)$$
> $\qquad$ 因此只需要证明 $\displaystyle\sum_{d|n}p^d\mu\left(\dfrac{n}{d}\right)>0$ 即可。注意到
> $$\sum_{d|n}p^d\mu\left(\dfrac{n}{d}\right)=p^n+\sum_{d|n,d\not=n}p^d\mu\left(\dfrac{n}{d}\right)\ge p^n-\sum_{d|n,d\not=n}p^d$$
> $$\ge p^n-\sum_{d=1}^{n-1}p^d=p^n-\dfrac{p^n-p}{p-1}=\dfrac{(p-2)p^n+p}{p-1}>0$$

这样一来，我们不仅证明了 $\mathbb{F}_{p^n}$ 的存在性，还给出了其构造方法：  
线性筛出 $\Z_p[x]$ 上的任意一个 $n$ 次不可约多项式即可。这就是本题的解法。

## 可分性与自同构群

因为 $\mathbb{F}_{p^n}$ 的乘法群为循环群，其阶 $p^n-1$ 与 $p$ 互质，  
故 $\mathbb{F}_{p^n}$ 中任意元素均可开 $p$ 次根，即 **有限域 $\mathbb{F}_{p^n}$ 一定是完美域**。

此时弗罗贝尼乌斯自同态是 $\mathbb{F}_{p^n}$ 的自同构。设 $\alpha$ 为 $\mathbb{F}_{p^n}$ 乘法群的生成元，  
$\alpha$ 在 $\Z_p$ 上的极小多项式为 $q(x)=\displaystyle\sum_{k=0}^nq_kx^k\ (q_0,q_1,\cdots,q_n\in\Z_p)$，  
则 $\alpha^p$ 在 $\Z_p$ 上的极小多项式也为

$$\sum_{k=0}^nq_k^px^k=\sum_{k=0}^nq_kx^k=q(x)$$

因此

$$\alpha,\alpha^p,\alpha^{p^2},\cdots,\alpha^{p^{n-1}}$$

是 $q(x)$ 的 $n$ 个不同的根。又因为 

$$(\alpha^{p^a})^{p^b}=\alpha^{p^{a+b}}$$

故 **有限域 $\mathbb{F}_{p^n}$ 的自同构群为 $n$ 阶循环群，弗罗贝尼乌斯自同态为其生成元**。

通过伽罗瓦理论分析自同构群，易得 $\mathbb{F}_{p^n}$ 的子域的大小为 $p^d$，其中 $d$ 为 $n$ 的约数。  
并且，$\mathbb{F}_{p^n}$ 中包含 $\varphi(d)$（$\varphi$ 为欧拉函数）个大小为 $p^d$ 的子域。

---

## 作者：C1942huangjiaxu (赞：1)

**结构定理一：** 设 $F$ 是一个特征为素数 $p$ 的有限域，则 $F$ 中的元素个数为 $p^n$，$n$ 是一个正整数。

**证明：** 由于 $F$ 是一个特征为 $p$ 的有限域，所以 $F$ 的素子域与 $\mathbb{Z}/p\mathbb{Z}$ 同构。因此 $F$ 是 $\mathbb{Z}/p\mathbb{Z}$ 的有限扩张，设扩张次数为 $n$，且 $a_1,a_2,\cdots ，a_n$ 是 $F$ 在 $\mathbb{Z}/p\mathbb{Z}$ 上的一组基。则 $F=\{b_1a_1+b_2a_2+\cdots+b_na_n\vert b_i\in \mathbb{Z}/p\mathbb{Z},i=1,2,\cdots,n\}$，所以 $F$ 中的元素个数为 $p^n$。

**引理一：** 如果 $f(x)$ 在 $F$ 上不可约，则 $F[x]/\langle f(x)\rangle$ 是一个域。

**证明：** 模 $f(x)$ 同余是 $F[x]$ 上的一个等价关系。不难证明 $F[x]/\langle f(x)\rangle$ 是个含幺交换环。

只要证明任意非 $0$ 元有乘法逆元，设 $r(x)\neq 0\in F[x]/\langle f(x)\rangle$，则 $0\le \operatorname{deg}(r(x))\lt\operatorname{deg}(f(x))$，因为 $f(x)$ 在 $F$ 上不可约，所以 $\gcd(f(x),r(x))=1$，因此 $r(x)$ 在 $F[x]/\langle f(x)\rangle$ 中有乘法逆元。

**引理二：** 域 $F$ 上任意一个次数 $\ge 1$ 的多项式 $f(x)$ 在 $F$ 上都有分裂域。

**证明：** 对多项式次数 $n$ 进行数学归纳：

+ 若 $n=1$，$f(x)=a(x-\alpha)$，则 $F$ 本身即为分裂域。
+ 归纳假设：假设对任意域 $K$ 及次数 $\lt n$ 的多项式 $g(x)\in K[x]$，均存在分裂域。

任取 $f(x)$ 的一个不可约因子 $p(x)$，定义 $F_1=F[x]/\langle p(x)\rangle$，则 $F_1$ 是个域，且令 $\alpha=x+\langle p(x)\rangle \in F_1$，$p(\alpha)=p(x)+\langle p(x)\rangle=0+\langle p(x)\rangle$，所以 $\alpha$ 是 $p(x)$ 的根。

在域 $F_1$ 上，将 $f(x)$ 写为 $(x-\alpha)\cdot g(x)$，$g(x)\in F_1$。

此时 $\operatorname{deg}(g(x))=n-1$，根据归纳假设，$g(x)$ 在 $F_1$ 上存在分裂域 $E$。可以验证 $E$ 是 $f(x)$ 在 $F$ 上的分裂域。

**结构定理二（存在性）：** 对于任何素数 $p$ 和任意正整数 $n$，
总存在一个有限域恰好含有 $p^n$ 个元素。

**证明：** 考虑 $\mathbb{Z}/p\mathbb{Z}$ 上的多项式 $f(x)=x^{p^n}-x$。则 $f'(x)=p^n x^{p^n-1}-1=-1$，因此 $f(x)$ 无重根。

令 $E$ 为 $f(x)$ 在 $\mathbb{Z}/p\mathbb{Z}$ 上的分裂域，则 $f(x)$ 在 $E$ 中有 $p^n$ 个不同的根。

设 $S$ 为根的集合，则 $\forall \alpha \in S$，$\alpha^{p^n}=\alpha$，下面证明 $S$ 是域。

+ 加法封闭：$\forall \alpha,\beta \in S$，$(\alpha+\beta)^{p^n}=\alpha^{p^n}+\beta^{p^n}=\alpha+\beta$
+ 乘法封闭：$\forall \alpha,\beta \in S$，$(\alpha\beta)^{p^n}=\alpha^{p^n}\beta^{p^n}=\alpha\beta$。
+ 加法逆元：$\forall \alpha \in S$，若 $p=2$ 则 $\alpha =-\alpha$，否则 $(-\alpha)^{p^n}=(-1)^{p^n}\alpha^{p^n}=-\alpha$
+ 乘法逆元：$\forall \alpha \in S$，$(\alpha^{-1})^{p^n}=(\alpha^{p^n})^{-1}=\alpha^{-1}$

因此 $S$ 构成域。

因为 $S$ 是 $f(x)$ 的根集合，同时可证明 $\mathbb{Z}/p\mathbb{Z}\subseteq S$，因此 $S$ 是 $\mathbb{Z}/p\mathbb{Z}$ 的分裂域，即 $S=E$。

所以 $E$ 是阶为 $p^n$ 的域。

**有限域上元素的表示**

设 $F_p=\mathbb{Z}/p\mathbb{Z}$，$q=p^n$，只要找到 $F_p$ 上一个 $n$ 次不可约多
项式 $f(x)$, 就有 $F_q=F_p[x]/\langle f(x)\rangle$。

其中加法和乘法都是模 $f(x)$ 的多项式运算，乘法逆元可以通过扩展欧几里得算法求出。

代码实现时随机一个 $n$ 次多项式，暴力判断是否可约即可。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 rnd(0x66ccff);
typedef vector<int> poly;
int m,P,n,inv[1005];
#define deg(f) (f.size()-1)
#define F(x) (poly{x})
inline poly operator +(poly a,poly b){
	if(deg(a)<deg(b))swap(a,b);
	for(int i=0;i<=deg(b);++i)a[i]=(a[i]+b[i])%P;
	while(deg(a)&&!a.back())a.pop_back();
	return a;
}
inline poly operator -(poly a,poly b){
	for(int i=0;i<=deg(b);++i)if(b[i])b[i]=P-b[i];
	return a+b;
}
inline poly operator *(poly a,poly b){
	poly c(deg(a)+deg(b)+1,0);
	for(int i=0;i<=deg(a);++i)for(int j=0;j<=deg(b);++j)
		c[i+j]=(c[i+j]+a[i]*b[j])%P;
	while(deg(c)&&!c.back())c.pop_back();
	return c;
}
inline pair<poly,poly> operator /(poly a,poly b){
	if(deg(a)<deg(b))return {F(0),a};
	if(!deg(a))return {F(a[0]*inv[b[0]]%P),F(0)};
	int o=1ll*a.back()*inv[b.back()]%P;
	poly c(deg(a)-deg(b)+1,0);
	c.back()=o;
	a=a-c*b;
	tie(a,b)=a/b;
	return {a+c,b};
}
poly exgcd(poly a,poly b,poly &X,poly &Y){
	auto [c,d]=a/b;
	if(d==F(0)){
		X=F(0),Y=F(inv[b.back()]);
		b=b*F(inv[b.back()]);
		return b;
	}
	poly g=exgcd(b,d,Y,X);
	Y=Y-c*X;
	return g;
}
bool check(){
	int x=m;
	if(x==1)return false;
	P=2;
	while(x%P!=0)++P;
	while(x%P==0)x/=P,++n;
	return x==1;
}
int ptoi(poly a){
	int b=0;
	for(int i=deg(a);~i;--i)b=b*P+a[i];
	return b;
}
poly itop(int b){
	if(!b)return F(0);
	poly a;
	while(b)a.push_back(b%P),b/=P;
	return a;
}
bool find(){
	poly f(n+1),X,Y,g;
	f[n]=1;
	for(int i=0;i<n;++i)f[i]=rnd()%P;
	for(int i=1;i<m;++i){
		g=exgcd(f,itop(i),X,Y);
		if(g!=F(1))return false;
	}
	for(int i=0;i<m;++i)for(int j=0;j<m;++j){
		X=itop(i),Y=itop(j);
		g=X+Y;
		tie(X,Y)=g/f;
		printf("%d%c",ptoi(Y)," \n"[j==m-1]);
	}
	for(int i=0;i<m;++i)for(int j=0;j<m;++j){
		X=itop(i),Y=itop(j);
		g=X*Y;
		tie(X,Y)=g/f;
		printf("%d%c",ptoi(Y)," \n"[j==m-1]);
	}
	return true;
}
int main(){
	scanf("%d",&m);
	if(!check())return puts("-1"),0;
	puts("0");
	inv[1]=1;
	for(int i=2;i<P;++i)inv[i]=(P-P/i)*inv[P%i]%P;
	while(!find());
	return 0;
}
```

---


# 【XR-2】记忆

## 题目背景

> 过去就像攥在手中的一把干沙，自以为攥得很紧，其实早就从指缝中流光了。记忆是一条早已干涸的河流，只在毫无生气的河床中剩下零落的砾石。——刘慈欣 《三体》

## 题目描述

你的记忆被歌者拿走了。

临走前，歌者告诉你，你的记忆中有一个序列，而且这个序列是所有 $l \le x \le r$ 的整数 $x$ 形成的一个排列。

歌者想了想，决定再告诉你一点信息：

如果把一个序列的权值定义为这个序列中相邻两个数的乘积为完全平方数的数量，那么你记忆中的这个序列是所有 $l \le x \le r$ 的整数 $x$ 形成的排列中**权值最大**的排列。

歌者希望你能够把你记忆中的这个序列的权值告诉他，他才会把属于你的记忆还给你。

## 说明/提示

【样例 $1$ 说明】

一个满足权值为 $2$ 的排列为 $\{8,2,4,9,3,10,7,5,6\}$，其中 $8 \times 2 = 16, 4 \times 9=36$ 为完全平方数。这也是所有 $2 \le x \le 10$ 的整数 $x$ 形成的排列中权值最大的排列。

【数据规模与约定】

**本题采用捆绑测试。**

Subtask 1（3 points）：$r \le 10$。  
Subtask 2（7 points）：$r \le 100$。  
Subtask 3（15 points）：$r \le 100000$。  
Subtask 4（11 points）：$l = 1$。  
Subtask 5（8 points）：$l \le 10$。  
Subtask 6（19 points）：$l \le 1000000$。  
Subtask 7（37 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le l \le r \le 10^{14}$。

## 样例 #1

### 输入

```
2 10
```

### 输出

```
2
```

# 题解

## 作者：xht (赞：23)

#### 题目大意

> 求 $[l,r]$ 形成的排列中，相邻两个数的乘积是完全平方数的对数最多是多少。

#### 前置知识

- 线性筛
- 整除分块
- 莫比乌斯函数
- 容斥

#### 题解

将正整数 $x$ 写成 $x=k^{2}p$ 的形式（其中 $k,p$ 为正整数），如果 $k$ 最大，那么我们称 $k^{2}$ 为 $x$ 的**最大平方因子**。容易发现，$p$ 的最大平方因子是 $1$。

易知两个数乘起来为完全平方数，当且仅当这两个数除去各自的最大平方因子后相等。

我们首先考虑 $l=1$ 的情况。

考虑一个数 $x$，它的最大平方因子是 $1$。假设 $x,2^{2}x,3^{2}x,...,k^{2}x \in [1,r]$，那么我们只需要把这些数连续的放在一起，权值便会增加 $k-1$，因为每对相邻的数的乘积都是完全平方数。

因此，我们所求的答案等价于 $[1,r]$ 中有多少个数最大平方因子不为 $1$。

再考虑 $l≠1$ 的情况。

它与 $l=1$ 的区别在于，原来考虑的 $2^{2}x$ 到 $k^{2}x$ 这 $k-1$ 个数，每个数都能对权值有贡献，因为 $x \in [l,r]$。现在 $x$ 可能不属于 $[l,r]$ 了，那么每有一个这样的 $x$，权值就要减 $1$。

因此现在只需要计算 $[1,l)$ 中有多少个最大平方因子为 $1$ 的数 $x$ 满足：存在一个数 $c$，使得 $c^{2}x \in [l,r]$。最后把答案减掉满足条件的 $x$ 的数量就行了。

我们可以枚举 $c$，这样所有在 $(\frac{l-1}{k^{2}},\frac{r}{k^{2}}]$ 的区间里的最大平方因子为 $1$ 的数都是满足条件的 $x$。注意区间可能会重叠，实现的时候注意去重。

#### 代码

```cpp
#include<bits/stdc++.h>
#define N 10000010
#define ll long long
using namespace std;int crr;
int nop[N],p[N],mu[N],cnt,s[N],s2[N];
void mem(int n)
{
	mu[1]=1;for (int i=2;i<=n;i++)
	{
		if (!nop[i]) p[++cnt]=i,mu[i]=-1;
		for (int j=1;j<=cnt && i*p[j]<=n;j++)
		{
			nop[i*p[j]]=1;if (i%p[j]==0){mu[i*p[j]]=0;break;}mu[i*p[j]]=-mu[i];
		}
	}
	for (int i=1;i<=n;i++) s[i]=s[i-1]+mu[i],s2[i]=s2[i-1]+mu[i]*mu[i];
}
ll sol(ll x)
{
	if (x<=N-10) return x-s2[x];
	ll ans=0,p,m=sqrt(x),i;
	for (i=2;i<=m;i=p+1)
	{
		p=min((ll)(sqrt(x/(x/(i*i)))),m);
		ans-=x/(i*i)*(s[p]-s[i-1]);
	}
	return ans;
}
int main()
{
	mem(N-10);ll l,r,i,ans,lst=0;cin>>l>>r;
	ans=sol(r)-sol(l-1);lst=l-1;
	for (i=2;i*i<=r;i++)
	{
		ll p=(l-1)/(i*i),q=(r)/(i*i);q=min(q,lst);
		if (q>p) ans-=(q-p-sol(q)+sol(p));
		lst=p;
	}
	cout<<ans;
}
```

---

## 作者：Elegia (赞：21)

来自验题人的一个算法：std 的复杂度是 $\Theta(\sqrt r)$ 的，本算法复杂度为 $\Theta(r^{\frac 37})$。

#### 思路要点

考虑将两个数乘积为平方数当且仅当所含有的次数为奇数的素因子集合，因此这就构成了一个等价关系。等价类内的数显然应当挨在一起放，故得到：答案为区间长度减去出现的等价类数量。因此等价类数量可以刻画成
$$\sum_{x\le r} |\mu(x)| \left[ \left\lfloor\sqrt{\frac rx}\right\rfloor > \left\lfloor\sqrt{\frac {l-1}x}\right\rfloor\right]$$
注意后项由于形如 $\left\lfloor\sqrt{\frac rx}\right\rfloor$ 的式子取值类似于除法分块，我们可以考虑计算若干个部分的 $\sum_{x\le t} |\mu(t)|$，不难通过莫比乌斯函数筛出无平方因子的数的数量
$$F(t)=\sum_{x\le t} |\mu(x)| = \sum_{d\le \sqrt t} \mu(d) \left\lfloor \frac{t}{d^2} \right\rfloor$$

#### 复杂度分析

考察形如 $\left\lfloor \frac{t}{d^2} \right\rfloor$ 的式子在 $d$ 变化时有多少种取值。设一个参数 $B$，显然对于 $d\le B$ 最多 $B$ 种取值，对于 $d>B$，有 $\frac t{d^2} < \frac{t}{B^2}$，因此不超过 $B + \frac{t}{B^2}$ 种取值。令 $B=t^\frac13$ 可知只有 $O(t^\frac13)$ 种取值，因此计算 $F(t)$ 的复杂度理论上可以达到 $\Theta(t^\frac13)$，但需要对于 $\mu$ 的前缀和进行预处理。具体预处理的方法在最后给出复杂度分析。

考虑将答案的式子分块 $M$，对于 $x\le M$ 的部分对 $x$ 线性筛进行计算，剩余部分通过整除分块求 $F(t)$ 进行计算。

对于 $x>M$，假设取值 $v = \sqrt{\frac rx} < \sqrt{\frac r M}$，复杂度可表示为
$$\begin{aligned}\sum_{v < \sqrt{\frac rM}} \left(\frac r {v^2}\right)^{\frac13} & \sim\int_0^{\sqrt{\frac rM}} \left(\frac r {v^2}\right)^{\frac13} \mathrm{d}v\\&= r^\frac13 \int_0^{\sqrt{\frac rM}} v^{-\frac23} \mathrm{d}v\\&= \left.3 r^{\frac13} v^{\frac13} \right|_{v=0}^{\sqrt{\frac rM}}\\&= 3r^\frac12 M^{-\frac16}\end{aligned}$$
注意最终的复杂度要与 $M$ 求和，取 $M=r^{\frac37}$，于是这一部分计算的复杂度为 $\Theta(r^\frac37)$。

最后讨论 $\mu$ 前缀和的预处理，考虑使 $v=\left\lfloor\sqrt{\frac rx}\right\rfloor$ ，当 $x$ 变大时，取值改变的 $x$，注意到可以表示为 $x=\left\lfloor\frac r{v^2}\right\rfloor$，接着带回到 $F(t)$ 的式子中观察，其中 $d$ 改变值 $w=\left\lfloor\frac t{d^2}\right\rfloor$ 的位置就是 $d=\left\lfloor\sqrt \frac tw \right\rfloor$。带入 $t=\left\lfloor\frac r{v^2}\right\rfloor$ 得到
$$\begin{aligned} d&=\left\lfloor \sqrt{\frac r{v^2w}}\right\rfloor\\&=\left\lfloor \frac{\left\lfloor\sqrt{\dfrac r{w}}\right\rfloor}v \right\rfloor\end{aligned}$$
注意杜教筛的递归式中可以算出某个 $m$ 对应的所有 $\left\lfloor \frac m d\right\rfloor$ 的位置处的取值，我们将 $\le N$ 位置的值线性筛预处理，剩余部分由 $\sqrt\frac rw > N$ 的负责计算，保守估计复杂度为
$$\begin{aligned}\sum_{w\le \frac r{N^2}} \left(\sqrt \frac rw\right)^\frac23 &\sim \int_0^{\frac r{N^2}} \left(\sqrt \frac rw\right)^\frac23 \mathrm{d}w\\&= r^\frac13 \int _0^{\frac r{N^2}} w^{-\frac13} \mathrm{d}w\\&= \left.\frac32 r^\frac13 w^\frac23 \right|_{w=0}^{\frac r{N^2}}\\&= \frac32 r N^{-\frac43}\end{aligned}$$
注意要加上预处理的时间，分块大小为 $N=r^\frac37$ 时，复杂度取到最优值 $\Theta(r^\frac37)$。



综上所述，各部分时间复杂度均为 $\Theta(r^\frac37)$，故本算法的时间复杂度为 $\Theta(r^\frac37)$。



---

## 作者：KaguyaH (赞：5)

> [P5438](https://www.luogu.com.cn/problem/P5438).
> [Github blog](https://9u46-mx.github.io/post/Solution-P5438/).

---

将 $[l, r]$ 重排，求相邻两数积为完全平方数的对数最大值。

$1 \leqslant l \leqslant r \leqslant 10^{14}$。

---

题解中所有值为正整数。

设：
$$f(x) = \max_{d^2 | x}d, \;g(x) = \frac x{f^2(x)}.$$

比较显然地：两数之积为完全平方数，等价于两数的 $g$ 相等；将 $g(x)$ 相同的数排列在一起，相邻两数积为完全平方数的对数最大。

所以，问题转化为，对于给定的非完全平方数 $k$，求满足 $g(x) = k$ 的 $x$ 的数量。

---

若 $d^2k \in [l, r]$，则有
$$\lceil\sqrt\frac l k\rceil \leqslant d \leqslant \lfloor\sqrt\frac r k\rfloor.$$

设
$$h_0(x) = \lceil\sqrt\frac l k\rceil,\;h_1(x) = \lfloor\sqrt\frac r k\rfloor,\;h(x) = h_1(x) - h_0(x);$$

则答案为
$$\sum_{k = l}^r\mu^2(k)\max(h(k), 0).$$

---

考虑答案的统计。考虑数论分块。

对于给定的 $i$，易得满足 $h_0(j) = h_0(i) \land h_1(j) = h_1(i)$ 的 $j$ 的最大值为

$$\lfloor\min(\frac{l - 1}{(h_0(i) - 1)^2}, \frac r{h_1^2(i)})\rfloor.$$

对于 $i < \sqrt[3]r$，$h_0(i), h_1(i)$ 约有 $\sqrt[3]r$ 种取值；对于 $i \geqslant \sqrt[3]r$，$h_0(i), h_1(i)$ 约有 $\sqrt[3]r$ 种取值，这部分时间复杂度为 $\mathcal O(r^{\frac 1 3})$。

---

考虑快速计算

$$\begin{aligned}
&s(n)=\sum_{i = 1}^n\mu^2(i)\cr
=&n - \sum_{i = 1}^n[\mu(i) = 0]\cr
=&n + \sum_{i = 1}^n[\mu(i) = 0](\mu(i) - \mu(1))\cr
=&n + \sum_{i = 2}^{\lfloor\sqrt n\rfloor}\mu(i)\lfloor \frac n{i^2}\rfloor.
\end{aligned}$$

对其整除分块，同理易得时间复杂度为 $\mathcal O(\sqrt[3]n)$。

预处理时空复杂度 $\mathcal O(\sqrt r)$。

---

对于 $i < \sqrt r$，我们可以预处理出 $s(i)$；对于 $i \geqslant \sqrt r$，$h_0(i), h_1(i)$ 约有 $\sqrt[4]r$ 种取值，对于每种取值计算 $s(i)$ 运算次数约为 $\sqrt[3]r$。

故时间复杂度为 $\mathcal O(r^{\frac 7{12}})$，空间复杂度为 $\mathcal O(\sqrt r)$；  
$10^{14 \times \frac 7{12}} \approx 1.4 \times 10^8$。

---

```cpp
# include <cassert>
# include <cmath>
# include <cstdio>

namespace Main {
    namespace Source {
        typedef short signed int hd;
        typedef signed int dint;
        typedef unsigned int uint;
        typedef long long unsigned int llu;
        static inline const llu min(const llu a, const llu b) { return b < a ? b : a; }
        namespace Maths {
            static uint *prime, lp; static bool* isp;
            static hd* mu; static dint* smu; static uint* smu2;
            struct FILE {
                compl FILE()
                { delete[]prime, delete[](isp + 1), delete[](mu + 1), delete[]smu, delete[]smu2; }
            } _FILE;
            static inline const void init(const uint n) {
                prime = new uint [n], lp = 0, (isp = new bool [n] - 1)[1] = false, 
                (mu = new hd [n] - 1)[1] = 1,
                (smu2 = new uint [n + 1])[0] = (smu = new dint [n + 1])[0] = 0;
                for (register uint i(2); i <= n; ++i) isp[i] = true;
                for (register uint i(1); i <= n; ++i) {
                    if (isp[i]) prime[lp++] = i, mu[i] = -1;
                    for (register uint j(0); j < lp and 1ull * i * prime[j] <= n; ++j)
                        if (i % prime[j]) isp[i * prime[j]] = false, mu[i * prime[j]] = -mu[i];
                        else { isp[i * prime[j]] = false, mu[i * prime[j]] = 0; break; }
                }
                for (register uint i(1); i <= n; ++i)
                    smu[i] = smu[i - 1] + mu[i], smu2[i] = smu2[i - 1] + mu[i] * mu[i];
            }
            static inline const llu smu2f(const llu n, const uint k) {
                if (n <= k) return smu2[n];
                llu re(n);
                for (register uint l(2), r; 1ull * l * l <= n; l = r + 1)
                    r = sqrt(n / (n / (1ull * l * l))),
                    re += (smu[r] - smu[l - 1]) * (n / (1ull * l * l));
                return re;
            }
            static inline const llu smu2f(const llu l, const llu r, const uint k)
            { return smu2f(r, k) - smu2f(l - 1, k); }
        }
    }
    using namespace Source;
    enum { Sqrt = (const uint)1e7 };
    static llu l, r;
    static llu ans;
    static inline const void main() {
        Maths::init(Sqrt), scanf("%llu%llu", &l, &r);
        for (register llu i(1), j; i <= r; i = j + 1) {
            const uint x(ceil(sqrt(1.0 * l / i))), y(floor(sqrt(1.0 * r / i)));
            j = min(x == 1 ? r : (l - 1) / (1ull * (x - 1) * (x - 1)), r / (1ull * y * y));
            if (x < y) ans += Maths::smu2f(i, j, Sqrt) * (y - x);
        }
        printf("%llu\n", ans);
    }
}


signed int main() { Main::main(); return 0; }
```

---

## 作者：aleph_blanc (赞：4)

先让我自己胡诌一个定义：

对于一个正整数 $x=k^2p$，$k$ 尽量大且不为一（这里不把 1 算进去），称 $k^2$ 为 $x$ 的最大**完全平方因子**。

将数拆成 $a^2b(\mu(b)\ne0)$ 的形式，将 $b$ 相同的放到一起，这一堆数的贡献就是这些数的个数减一。

答案等价于区间长度减去出现的不同的 $b$ 的个数。

考虑 $l=1$ 时的情况：

我们发现 $l=1$ 时，如果 $a^2b(a\ne 1)$ 在区间中，则 $b$ 必在区间中，即贡献来自有完全平方因子的数，所以答案为有完全平方因子的数的个数。

这个东西不是很好求，我们改成求无完全平方因子的数的个数，用总数即区间长度减去它即可。

直观的式子长这样：
$$
\large\sum_{i=1}^n\mu^2(i)
$$


考虑转换式子：
$$
\large
\begin{aligned}
&\sum_{i=1}^n\mu^2(i)\\
&=\sum_{a^2b\le n}[a=1][\mu(b)\ne0]\\
&=\sum_{a^2b\le n}[\mu(b)\ne0]\sum_{i\mid a}\mu(i)\\
&=\sum_{i=1}^n\mu(i)\sum_{j=1}^{\left\lfloor\frac{n}{i^2}\right\rfloor}1\\
&=\sum_{i=1}^n\mu(i)\left\lfloor\frac{n}{i^2}\right\rfloor\\
&=\sum_{i^2\le n}\mu(i)\left\lfloor\frac{n}{i^2}\right\rfloor
\end{aligned}
$$


复杂度不会算的说。。。（（（$O(能过)$？？？）

那么如果 $l\ne1$ 呢？

直接差分肯定不行，比如 $\{2,8,18,32,50\},l=9$，差分结果是 $3$，正确答案是 $2$。

我们可以枚举一个数 $k$，计算区间 $\left[\frac{l-1}{k^2},\ \frac{r}{k^2}\right]$ 内出现的无完全平方因子的数的个数即可。

```cpp
#include <bits/stdc++.h>

#define int long long
#define N 10000010

using namespace std;

template <typename T>
inline void read (T &a) {
	T x = 0, f = 1;
	char ch = getchar ();
	while (! isdigit (ch)) {
		(ch == '-') and (f = 0);
		ch = getchar ();
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch xor '0');
		ch = getchar ();
	}
	a = f ? x : -x;
}
template <typename T, typename ...A>
inline void read (T &t, A &...a) {
	read (t), read (a...);
}
template <typename T>
inline void print (T x) {
	if (x < 0) putchar ('-'), x = -x;
	if (x > 9) print (x / 10);
	putchar (x % 10 + '0');
}

int mu[N], sum[N], sum_s[N], pri[N], cnt;
bitset <N> v;

inline void phigros (int n) {
    mu[1] = sum[1] = sum_s[1] = 1;
    for (int i = 2; i <= n; i++) {
        (! v[i]) and (pri[++cnt] = i, mu[i] = -1);
        for (int j = 1; j <= cnt and i * pri[j] <= n; j++) {
            v[i * pri[j]] = 1;
            if (! (i % pri[j])) break;
            mu[i * pri[j]] = -mu[i];
        }
        sum[i] = sum[i - 1] + mu[i];
        sum_s[i] = sum_s[i - 1] + mu[i] * mu[i];
    }
}

inline int Min (int a, int b) {return a < b ? a : b;}

int mid;
inline int sol (int n) {
    if (n < mid) return n - sum_s[n];
    int k = sqrt (n), res = 0;
    for (int i = 2, j = 0; i <= k; i = j + 1) {
        j = Min (k, (int) sqrt (n / (n / i / i)));
        res -= (sum[j] - sum[i - 1]) * (n / i / i);
    }
    return res;
}

int num, swa, swb, l, r, ans;

signed main () {
    read (l, r);
    mid = sqrt (r);
    phigros (mid);
    l--, num = l;
    ans = sol (r) - sol (l - 1);
    for (int i = 2; i <= mid; i++) {
        swa = l / i / i, swb = Min (num, r / i / i);
        (swa < swb) and (ans -= (swb - swa - sol (swb) + sol (swa)));
        num = swa;
    }
    print (ans);
}
```

---

## 作者：Avocadooo (赞：3)

### 1.题目类型判断

很显然是道数论题，且与完全平方有关，自然想到了 $ \mu $ 的定义。

### 2.浅析

#### 2.1 由特殊数据点引入初步贪心

考虑将 $ [l,r] $ 区间中的所有数全部写作 $ y^2 p $ 的形式，其中 $ \mu(p) \not= 0 $ 。

看到题目下方第四个数据捆绑中满足特殊条件 $ l=1 $ 。那先看下 $ l=1 $ 的情况。

我们要使得相邻的数 $ i=y_i^2 p_i,j=y_j^2p_j $ 乘积尽可能为完全平方数，而仅当 $ q_i = q_j $ 时， $ ij=y_i^2 y_j^2 p_i p_j $ 为完全平方数。（这个不用细讲，显而易见）

而当 $ l=1 $ 的时候，我们通过简单的枚举可以发现，只要有 $  y_i^2p_i (y_i>1) $ 存在，那么必定有 $ (y_i-1)^2p_i $ 存在。那我们把 $ p_i $ 相同的数全部放在连续的区间中，一定可以使答案最大化。

#### 2.2 寻找规律及简化时间复杂度

便容易发现，结果为所有数中 $  y>1 $ 的数的个数。

即：

$$ S(r)=r-\sum\limits_{i=1}^{r}[\mu(i) \not= 0] $$


考虑后面的部分，可以转化为枚举一个数的 $ y $ 值，看在 $ r $ 的范围内，可以写作 $ y^2q_j $ 的 $ j $ 的个数：

$$ \sum\limits_{i=1}^{\lfloor \sqrt r \rfloor} \lfloor \frac{r}{i^2}\rfloor $$

但这样有一个漏洞，如数字 $ 16 $ ，在 $ i=2 $ 与 $ i=4 $ 时均被计算，所以重复计算了很多，再次想到**莫比乌斯函数**，我们可以利用它进行 **容斥** 来去除被反复计算的数。即：

$$ S(r)=\sum\limits_{i=1}^{\lfloor \sqrt r \rfloor} \mu(i)\lfloor \frac{r}{i^2}\rfloor $$

再加上**整除分块**，便大大降低了时间复杂度。

核心代码：

```cpp
ll getsum(ll R)
{
	if(R<N) return R-sumu[R];//预处理一部分可以提升运行速度
	ll sq=sqrt(R),Rec=0;
	for(ll l=2,r;l<=sq;l=r+1)
	{
		ll val=R/l/l;
		r=min(sq,(ll)(sqrt(R/val)));//整除分块
		Rec-=(summu[r]-summu[l-1])*val;
	}
	return Rec;
}
```


### 3.进一步思考

接下来再考虑 $ l \not= 1 $ 的情况。先用差分 $ S(r)-S(l-1) $ ，因为 $ S(l-1) $ 的结果是区间 $ [1,l-1] $ 中 $ y \not= 0 $ 的数，仅仅去除了 $ 1 \leq y^2 q<l (y>1) $ 带来的贡献。

而当 $ 1^2q $ 在区间 $ [1,l-1] $ 中时，在区间 $ [l,r] $ 中 $ y $ 最小的 $ y^2q $ 无法再与 $ 1^2q $ 造成 $ 1 $ 点贡献，故还需要去除 $ 1 \leq y^2 q <l (y=1) $ 时带来的贡献。

枚举 $ y^2 $ ，则区间 $ [\lfloor\frac{l-1}{y^2}\rfloor,\lfloor \frac{r}{y^2}\rfloor] $ 中 $ \mu $ 值不为 $ 0 $ 的数即为多余贡献。当然，这些区间可能会重叠在一起，稍加处理即可。

### 4.代码 ~~（你们最喜欢的）~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define N 10000005
using namespace std;
typedef long long ll;
ll a,b;
int vst[N],prime[N],cnt=0,mu[N];
int sumu[N];
int summu[N];
void get_mu()//莫比乌斯函数的预处理
{
    mu[1]=1;
    for(int i=2;i<N;i++)
    {
        if(vst[i]==0)
        {
            prime[++cnt]=i;
            mu[i]=-1;
        }
        for(int j=1;j<=cnt && prime[j]*i<N;j++)
        {
            vst[prime[j]*i]=1;
            if(i%prime[j]==0) break;
            else mu[i*prime[j]]=-mu[i];
        }
    }
    for(int i=1;i<N;i++)
	{
		sumu[i]=sumu[i-1]+mu[i]*mu[i];
		summu[i]=summu[i-1]+mu[i];
	}
}
ll getsum(ll R)
{
	if(R<N) return R-sumu[R];
	ll sq=sqrt(R),Rec=0;
	for(ll l=2,r;l<=sq;l=r+1)
	{
		ll val=R/l/l;
		r=min(sq,(ll)(sqrt(R/val)));
		Rec-=(summu[r]-summu[l-1])*val;
	}
	return Rec;
}
int main()
{
	get_mu();
	scanf("%lld %lld",&a,&b);
	ll ans=getsum(b);
	if(a==1) printf("%lld",ans);//特殊情况 l=1 直接判断
	else
	{
		ans-=getsum(a-1);//先差分
		ll RealR=a-1;
		for(ll i=2;i*i<=b;i++)
		{
			ll AreL=(a-1)/(i*i),AreR=b/(i*i);//去除多余贡献
			AreR=min(AreR,RealR);
			if(AreR>AreL) ans-=(AreR-AreL)+getsum(AreL)-getsum(AreR);
			RealR=AreL;
		}
		printf("%lld",ans);
	}
}
```

---

## 作者：Leasier (赞：3)

Update on 2021.4.7：感谢 [@SiRiehn_nx](https://www.luogu.com.cn/user/232125)

本题解省略部分分做法以及代码。

前置芝士：[数论分块](https://www.cnblogs.com/henry-1202/p/10121854.html)

考虑将满足 $l \leq x \leq r$ 的 $x$ 拆分成 $a^2 b$ 的形式，令 $1 \leq k \leq \lfloor \sqrt{r} \rfloor$，计算 $(\lfloor \frac{l - 1}{k^2} \rfloor, \lfloor \frac{r}{k^2} \rfloor]$ 中无平方因子的数的个数即可。

考虑 $\mu^2(n) = [n \operatorname{has} \operatorname{no} \operatorname{square} \operatorname{factor}]$，即仅当 $n$ 无平方因子时取 $1$，则考虑计算如下式子：

$\displaystyle\sum_{i = 1}^n \mu^2(i)$

考虑枚举求有多少个数是某个完全平方数的倍数，有：

$\displaystyle\sum_{i = 1}^{\lfloor \sqrt{n} \rfloor} \lfloor \frac{n}{i^2} \rfloor$

但这样显然会出现重复，需要容斥。不难得出，容斥系数即为莫比乌斯函数。

原式 $= \displaystyle\sum_{i = 1}^{\lfloor \sqrt{n} \rfloor} \mu(i) \lfloor \frac{n}{i^2} \rfloor$

使用数论分块计算即可。时间复杂度不会算（

代码：
```cpp
#include <stdio.h>
#include <math.h>

typedef long long ll;

const int N = 1e7 + 7;
int mu[N], mu_sqr[N], mu_sum[N], mu_sqr_sum[N];
ll prime[N];
bool p[N];

inline void init(ll n){
    int cnt = 0;
    p[0] = p[1] = true;
    mu[1] = 1;
    mu_sqr[1] = 1;
    for (register ll i = 2; i <= n; i++){
        if (!p[i]){
            prime[++cnt] = i;
            mu[i] = -1;
            mu_sqr[i] = 1;
        }
        for (register int j = 1; j <= cnt && i * prime[j] <= n; j++){
            int t = i * prime[j];
            p[t] = true;
            if (i % prime[j] == 0){
                mu[t] = 0;
                mu_sqr[t] = 0;
                break;
            }
            mu[t] = -mu[i];
            mu_sqr[t] = mu_sqr[i];
        }
    }
    for (register ll i = 1; i <= n; i++){
        mu_sum[i] = mu_sum[i - 1] + mu[i];
        mu_sqr_sum[i] = mu_sqr_sum[i - 1] + mu_sqr[i];
    }
}

inline ll sqrt(ll n){
    ll ans = sqrt((double)n);
    while (ans * ans <= n) ans++;
    return ans - 1;
}

inline ll min(ll a, ll b){
    return a < b ? a : b;
}

inline ll get_mu_sqr_sum(ll n, ll m){
    if (n <= m) return mu_sqr_sum[n];
    ll t = sqrt(n), ans = 0;
    for (register ll i = 1, j; i <= t; i = j + 1){
        ll tn = n / i / i;
        j = min(sqrt(n / tn), t);
        ans += tn * (mu_sum[j] - mu_sum[i - 1]);
    }
    return ans;
}

int main(){
    ll l, r, ld, m, ans;
    scanf("%lld %lld", &l, &r);
    ld = l - 1;
    m = sqrt(r);
    init(m);
    ans = (r - ld) - (get_mu_sqr_sum(r, m) - get_mu_sqr_sum(ld, m));
    for (register ll i = 2, j = ld; i <= m; i++){
        ll x = ld / i / i, y = min(r / i / i, j);
        j = x;
        if (y > x) ans -= get_mu_sqr_sum(y, m) - get_mu_sqr_sum(x, m);
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：skydogli (赞：2)

~~我觉得之前的两篇题解对数论蒟蒻不太友好~~

首先把所有的数拆分成 $a^2b(\mu(b) \ne 0)$ 的形式，不难发现我们会把 $b$ 相同的放在一起，如果对于一种 $b$ 的长度为 $k$，则贡献为 $k-1$，因此答案等于区间长度减去出现的不同的 $b$ 的个数。

然后考虑相对简单的 $l=1$ 的情况，我们发现因为 $l=1$，所以如果 $a^2b(a\ne 1)$ 在区间中，则必有 $b$ 在区间中，也就是说贡献来自有完全平方因子的数，所以答案就是有完全平方因子的数的个数。

这个东西不是很好求，我们改成求不含完全平方因子的数的个数，用区间长度减去它即可。

我们先把它直观的式子写出来：

$$\sum_{i=1}^n [\mu(i)\ne 0]=\sum_{i=1}^n \mu^2(i)$$


然后先给出结论，这个答案是：
$$\sum_{i=1}^n\lfloor\frac{n}{i^2}\rfloor\mu(i)$$


为啥呢，我们把它转化为一个等价的式子：

$$\sum_{i^2j\leq n}$$

我们尝试把 $i^2j$ 的贡献全部放到 $a^2b(\mu(b)\ne 1)$ 上。

不难发现必有 $i|a$ 且 $a$的每个因子都会被枚举到。所以式子就是

$$
\begin{aligned}
\sum_{a^2b\le n,\mu(b)\ne0}\sum_{i|a}\mu(i)&&\\
=\sum_{a^2b\le n,\mu(b)\ne 0}[a=1]&&\\
=\sum_{b=1}^n [\mu(b)\ne0]&&\\
\end{aligned}
$$

于是发现它就等于上面的式子。

所以我们可以 $O(\sqrt{n})$ 预处理， $O(n^{\frac{1}{3}})$ 查询一次这个答案。

然后考虑 $l\ne 1$ 怎么做。我们直接差分的话会多算一些答案，于是考虑如何消除这样的数的贡献。于是我们可以直接枚举$[\frac{l-1}{c^2},\frac{r}{c^2}]$ 包含的区间，然后减去这样的区间中出现的无完全平方因子的个数即可。计算可以小数据查表，大数据$O(n^{\frac{1}{3}})$暴力算。一个毛咕咕的上界是$O(n^\frac{5}{9})$，好像可以更精确一点。

另外要注意不能重复删除贡献，所以区间要合并一下。



```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define MN 10000005
int l,r,p[MN],mu[MN],smu[MN],ssmu[MN],cnt,nn;
bool vis[MN];
void init(int N){
	nn=N;
	ssmu[1]=smu[1]=1;
	for(int i=2;i<=N;++i){
		if(!vis[i]){p[++cnt]=i;mu[i]=-1;}
		for(int j=1;p[j]*i<=N;++j){
			vis[p[j]*i]=1;
			if(i%p[j]==0)break;
			mu[p[j]*i]=-mu[i];
		}
		smu[i]=smu[i-1]+mu[i];
		ssmu[i]=ssmu[i-1]+(mu[i]!=0);
	}
}
int calc(int r){
	int ans=r;
	if(r<nn)return r-ssmu[r];
	int blk=sqrt(r);
	for(int i=2,j=0;i*i<=r;i=j+1){
		j=min(blk,(int)sqrt(r/(r/i/i)));
		ans+=(smu[j]-smu[i-1])*(r/i/i);
		assert(i<=j);
	}
	return r-ans;
}
signed main(){
	int l,r;
	scanf("%lld%lld",&l,&r);
	l--;
	init(sqrt(r));
	int ans=calc(r)-calc(l);
	int lst=l;
	for(int i=2;i*i<=r;++i){
		int p=l/i/i,q=min(lst,r/i/i);
		if(p<q){
			ans-=q-calc(q)-p+calc(p);
		}
		lst=p;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：jiangby2011 (赞：1)

从早上十点到现在一直在搞这个题，提交记录一整面都是我，终于搞出来了。

题解大多有 typo，我来写一个完整点的吧。

感谢 @[KaguyaH](https://www.luogu.com.cn/user/236807) 提供的帮助。

## 正文

### 前三组数据（25分） 
首先题目很好理解，我们把这个序列的所有数的**最大平方因子**扣掉之后，每 $k$ 个相等的数就会贡献 $k - 1$ 。


```cpp
#include <bits/stdc++.h>

#define int long long
const int N = 1e7 + 7;
int l , r , cnt , ans , a[N];
using namespace std;

signed main() {
	cin >> l >> r;
	
	for(register int i = l; i <= r; ++i) {
		a[++cnt] = i;
	}
	
	for(register int i = 1; i <= cnt; ++i) {
		int x = 1;
		for(register int d = 2; d * d <= a[i]; ++d) {
			if(a[i] % (d * d) == 0) {
				x = max(x , d);
			}	
		}
		a[i] /= (x * x);
	}
	
	sort(a + 1 , a + cnt + 1);
	for(register int i = 1; i <= cnt; ++i) {
		if(a[i] == a[i - 1]) {
			++ ans;
		}
	}
	cout << ans;
	return 0;
}
```

### 第四组数据（11分）

首先要推一个前置的式子。

$$\sum_{i = 1}^{n}\mu^2(i)$$

接下来是见证奇迹的时刻。

$$\sum_{i = 1}^n\mu^2(i) = \sum_{i = 1}^{n}\sum_{d ^ 2 \mid i} \ \mu(d)$$

以下说明理由。

这个式子当 $d = 1$ 时无论 $i$ 质因数分解后有没有幂次大于等于 $2$ 的项都会加 $1$，我们先不管他。

首先考虑质因数分解后，**这个数存在大于等于 $2$ 的幂次**。

据乘积多项式的**因式的项的数量**分类讨论，构成一个和式的形式。

比如 $2^2 \times 3^2 \times 5^2$，把它分成 $2 , 3 , 5 , 2 \times 3 , 2 \times 5, 3 \times 5 , 2 \times 3 \times 5$ ， 单个质数的莫比乌斯函数值和是 $-3$ (因为能拆成三个单个)，两个质数的乘积的莫比乌斯函数值和是 $3$，三个质数的乘积的莫比乌斯函数值的和是 $-1$ ， 因此就可以写成 $-3 + 3 - 1$ 。

再比如 $2^2 \times 3^2 \times 5^2 \times 7^2$，同理就可以写成 $-4 + 6 - 4 + 1$ 。

我们发现这个和式符合杨辉三角，因此这个和式一定等于 $-1$。结论就是当一个 $i$ 存在质因数分解后指数大于等于 $2$ 的项，$\sum_{d^2 \mid i} \mu(d) = -1$。

**然后再考虑这个数是一堆质数乘起来的**。

没有任何 $d^2 \mid i (i = \prod d (d \in prime))$ 。

所以和就是 $0$。

然后两种情况都加上整除 1 的情况所贡献的 1，其实就跟 $\mu^2$ 的值是一样的了。

再简化一下：

$$\sum_{i = 1}^{n}\sum_{d ^ 2 \mid i} \mu(d) = \sum_{d = 1}^{\sqrt n}\mu(d) \lfloor\frac{n}{d ^ 2}\rfloor$$

好的，前置部分完成！我们现在开始考虑，如果 $l = 1$ 的情况如何做？

很显然的事情就是，在一个排列里，任何一个最大平方因子不为 $1$ 的数都会存在一个等于这个数除以他最大平方因子的数。

也就是说这个排列的所有质因数分解后存在大于等于 $2$ 指数的项的元素都一定会有贡献。

那么当 $l = 1$ 时，答案就是 $r - \sum_{i = 1}^{r} \mu^2(i)$ 。

### 正解（100分）

上一部分解的形式已经相当接近正解。

然而如果 $l > 1$ ， 在 $[1 , l - 1]$ 里有元素对答案做了贡献，我们不能够直接做差求答案，**要在这个基础上把前面的贡献也删掉**。

更形式化地说，如果做贡献的数是 $d^2k (k\in[1 , l - 1] , d = \prod k(k \in prime))$ ，且 $d^2k \in [l , r]$ ，我们就要删掉这个贡献。

我们枚举 $d$，其实就是减去这个:

$$\sum_{d = 1}^{\sqrt r} \mu ^ 2 (d) (\lfloor\frac{r}{d ^ 2}\rfloor - \lfloor\frac{l - 1}{d ^ 2}\rfloor)$$

把这玩意分成两个 $\sum$，这题其实就做完了。

至于 $\lfloor\frac {n}{i ^ 2}\rfloor$ 的整除分块操作，我认为不需要赘述，读者可以自己推。

细节看代码。


```cpp
#include <bits/stdc++.h>
	
#define int long long
using namespace std;
const int N = 1e7 + 7;
	
bitset<N> notprime;
vector<int> prime;
int l , r , M , mu[N] , sum[N] , t[N];
	
void init(int n) {
	mu[1] = sum[1] = t[1] = 1;
	for(register int i = 2; i <= n ; ++i) {
		if(!notprime[i]) {
			prime.push_back(i);
			mu[i] = -1;
		}
		
		for(int j : prime) {
			if(i * j > n){break;}
			notprime[i * j] = true;
			if(i % j == 0) {break;}
			mu[i * j] = - mu[i];
		}
		sum[i] = sum[i - 1] + mu[i] , t[i] = t[i - 1] + mu[i] * mu[i];
	}
}
	
inline int S(int n) {
	if(n <= N - 7) {
		return n - t[n]; // 这个剪枝有没有无所谓
	}
	int res = 0 , m = __builtin_sqrt(n);
	for(register int i = 1 , j ; i <= m; i = j + 1) {
		j = min((int)(__builtin_sqrt(n / (n / (i * i)))) , m);//对\frac{n}{i^2}整除分块
		res -= (sum[j] - sum[i - 1]) * (n / (i * i)) ;
	}
	return n - res;//这个函数求的就是n - \sum_{i = 1}^{n} \mu^2(i)
}

signed main() {
	ios :: sync_with_stdio(0) , cin.tie(0) , cout.tie(0);
	cin >> l >> r;
	init(N);
	int lst = l - 1;
	int ans = S(r) - S(l - 1);//原基础，也就是d在[l , r]中对答案做的贡献
	for(register int i = 2; i * i <= r; ++i) {
		int p = (l - 1) / (i * i) , q = min(r / (i * i) , lst);
		if (q > p) {
			ans -= (q - S(q) + S(p) - p);	//整除分块求上文中所说要减去的式子
		}
		lst = p;
	}
	cout << ans;
	return 0;
}
```

---


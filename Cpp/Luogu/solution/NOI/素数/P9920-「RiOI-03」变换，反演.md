# 「RiOI-03」变换，反演

## 题目背景

为了题目要求，我们对积性函数进行重定义：**不保证 $f(1)=1$**。

## 题目描述

**这是一道非传统题。**

给定一个**积性函数** $f(d)$。对于每一个测试点，我们会在附件中给出 $g(n)=\sum_{d|n}f(d)$ 的其中 $k$ 项 $\bmod\ 998244353$ 的值，这部分也会在输入中出现。接着，对于每一个测试点，有 $t$ 组数据。对于每组数据，输入 $d$，请输出 $f(d)\bmod998244353$ 的值。

## 说明/提示

#### 【样例解释】

由于 $g(d)=d$，因此 $f(d)=\varphi(d)$，结果正确。

#### 【数据范围】

对于每个测试点：

如果你正确回答了 $n\le k$ 的测试数据，你将得到 $20\%$ 的分数。

如果你正确回答了所有测试数据，你将得到剩余 $80\%$ 的分数。**所以，如果你无法正确回答，也请随机输出一个数来保证格式正确。**

#### 【数据范围】

|$\text{Id}$|$\text{Name}$|$\text{Score}$| $n\leq$|$k=$|$t=$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$0$|$\text{Epsilon}$|$5$|$10^6$|$100$|$10$|
|$1$|$\text{Division}$|$5$|$10^9$|$100$|$10$|
|$2$|$\text{Unknown}$|$5$|$10^{18}$|$1$|$10$|
|$3$|$\text{Random}$|$10$|$10^5$|$10^5$|$10^5$|
|$4$|$\text{Double}$|$10$|$10^9$|$100$|$10$|
|$5$|$\text{Hack}$|$10$|$10^9$|$31623$|$1$|
|$6$|$\text{Square}$|$15$|$10^{18}$|$100$|$5$|
|$7$|$\text{Poly}$|$20$|$10^9$|$10^5$|$100$|
|$8$|$\text{Thanks}$|$20$|$10^5$|$4$|$10^5$|

## 样例 #1

### 输入

```
10
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
10 10

3 -1
1
2
3
```

### 输出

```
1
1
2
```

# 题解

## 作者：usermin (赞：10)

## 题目描述
给出一个函数 $f(d)$，给出 $g(n)=\sum\limits_{d|n}f(d)$ 其中 $k$ 项 $\bmod$ $998244353$ 的值，对于每个测试点，有 $t$ 组数据，对于每一组数据，给出 $d$，求 $f(d)\bmod998244353$ 的值。
### Sub0
基础结论，$g(n)=[n=1]$，$f(n)=\sum\limits_{d|n}μ(d)g(\tfrac{n}{d})=μ(n)$。

核心代码：
```cpp
for(long long i=2;i*i<=n;i++)
{
	if(n%i==0)
	{
		n/=i;
		if(n%i==0)
		{
			ans=0;
		}
		else 
		{
			ans*=-1;
		}
	}
}
if(n>1)
{
	ans*=-1;
}
```
### Sub1
一眼丁真，$g(n)=d(n)$，$f(n)=\sum\limits_{d|n}μ(d)d(\tfrac{n}{d})=1$。

核心代码：
```cpp
cout<<1<<endl;
```
### Sub2
$g(1)=0$，反演后因为 $g(1)=f(1)$，所以 $f(1)=0$，$f(n)=f(1) \times f(n)=0$。

核心代码：
```cpp
cout<<0<<endl;
```
### Sub3
最抽象的一集，发现 $g(p^k)$ 是一个随机数，反演可得 $f(n)=g(n)=\sum\limits_{d\neq n,d|n}f(d)$。

核心代码：
```cpp
for(long long i=1;i<=P;i++)
{
	f[i]=y[i];//y为g(d)
}	
for(long long i=1;i<=100000;i++)
{
	for(long long j=i+i;j<=100000;j+=i)
	{
		f[j]=(f[j]-f[i]+mod)%mod;	
	}	
}
```
### Sub4
有些难度，反演两次后，设这个奇怪的反演函数为 $j$，发现是一个平方数，即 $j(p)=(p-1)^2$，得 $j(n)=\prod(j(p^k))=\prod(p^{k-1}(p-1))^2=\varphi^2(n)$，所以 $f(n)=\sum\limits\limits_{d|n}j(d)=\sum\limits_{d|n}\varphi^2(d)$。

核心代码：
```cpp
for(long long i=1;i*i<=n;i++)
{
	long long res;
	if(n%i==0)
	{
		res=phi(i);//phi部分自写
		ans=(ans+1ll*res*res)%mod;
		res=phi(n/i);
		ans=(ans+1ll*res*res)%mod;
	}
	if(i*i==n)
	{
		res=phi(i);
		ans=(ans-1ll*res*res)%mod;
	}
}
```
### Sub5
简单一次反演后，得 $f(p^k)=p^{2k-1}$，套下数据发现大质数相乘，输出 $n$。

核心代码：
```cpp
cout<<n<<endl;
```
### Sub6
最困难的一集，我们已知 $g(n)=n^2$，则 $f(p^k)=\sum\limits_{d|p^k}d^2μ(\tfrac{p^k}{d})$，因为 $p^0,p^1,p^2$ 等整除 $p^k$，且根据 $μ$ 的定义，可知只有为 $k-1,k$ 时对总答案有贡献，所以 $f(p^k)=p^{2k}-p^{2k-2}=p^{2k}(1-\tfrac{1}{p^2})$，得 $f(n)=\prod p^{2k}(1-\tfrac{1}{p^2})=n^2\prod (1-\tfrac{1}{p^2})$。

核心代码：
```cpp
long long mill[20]={0,2,325,9375,28178,450775,9780504,1795365022};
bool miller(long long n)
{
	if(n<3)
	{
		return (n==2);
	}
	long long u=n-1,t=0;
	while(u%2==0)
	{
		u>>=1,t++;
	}
	for(long long i=1;i<=7;i++)
	{
		if(mill[i]>n)
		{
			continue;
		}
		long long a=mill[i],v=pow(a,u,n),j;
		if(v==1)
		{
			continue;	
		}
		j=1;
		for(;j<=t;j++)
		{
			if(v==n-1)
			{
				break;
			}
			v=(__int128)v*v%n;
		}
		if(j==t+1)
		{
			return 0;
		}
	}
	return 1;
}
long long f2(long long x,long long c,long long n)
{
	return ((__int128)x*x+c)%n;//个人习惯
}
long long pollard(long long n)
{
	if(n==4)
	{
		return 2;
	}
	while(1)
	{
		long long c=rnd()%(n-1)+1,t=0,r=0,p=1,q,d;
		do
		{
			for(long long i=0;i<128;i++)
			{
				t=f2(t,c,n);
				r=f2(f2(r,c,n),c,n);
				if(t==r)
				{
					break;	
				}
				q=(__int128)p*abs(t-r)%n;
				if(q==0)
				{
					break;
				}
				p=q;
			}
			d=__gcd(p,n);
			if(d>1)
			{
				return d;
			}
		}while(t!=r);
	}
}
long long get(long long n)
{
	if(mp[n])
	{
		return mp[n];
	}
	if(miller(n))
	{
		return mp[n]=n;
	}
	long long k=pollard(n);
	return mp[n]=((k==n)?n:mp[n]=max(get(k),get(n/k)));
}
void ans7()
{
	while(T--)
	{
		long long n;
		cin>>n;
		__int128 ans=(__int128)n*n;
		while(n>1)
		{
			long long p=get(n);
			ans=ans/((__int128)p*p)*((__int128)p*p-1);
			while(n%p==0)
			{
				n/=p;
			}	
		}
		cout<<(long long)(ans%mod)<<endl;
	}
}
```
Pollard-rho 算法求质因数请转场 [P4718](https://www.luogu.com.cn/problem/P4718)。
### Sub7
看看数据，动了亿点脑子，得 $f(p^k)=ap^{3k}+bp^{2k}+cp^k+d$，运用拉格朗日插值，脑量不足，只得 $a=114$，运用人类智慧，得 $a=114,b=514,c=1919,d=810$。

核心代码：
```cpp
for(long long i=2;i*i<=n;i++)
{
	if(n%i==0)
	{
		long long k=1;
		while(n%i==0)
		{
			n/=i,k*=i;
		}
		if(k>1)
		{
			po=114;
			po=(po*k+514)%mod;
			po=(po*k+1919)%mod;
			po=(po*k+810)%mod;
			ans=ans*po%mod;
		}
	}
}
if(n>1)
{
	po=114;
	po=(po*n+514)%mod;
	po=(po*n+1919)%mod;
	po=(po*n+810)%mod;
	ans=ans*po%mod;
}
```
### Sub8
看数据发的，猜测 $f(n)=n^2\bmod3$，正确！

核心代码：
```cpp
cout<<1ll*n*n%3<<endl;
```

总结，非常好莫比乌斯反演，下次别出了。

---

## 作者：Register_int (赞：7)

#### Sub0

字面意思，$g(n)=\epsilon(n)$，$f(n)=\mu(n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e2 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int n = 1e2;

int main() {
	freopen("Epsilon.txt", "w", stdout);
//	freopen("trans1.in", "w", stdout);
	printf("%d\n", n);
	for (int i = 1; i <= n; i++) printf("%d %d\n", i, i == 1);
/*	puts("10 0");
	for (int t = 10; t--; printf("%lld\n", randint(3e5, 1e6)));*/
}
```
```cpp
namespace Sub0 {
	
	inline 
	ll solve(ll n) {
		int res = 0;
		for (ll i = 2; i <= n; i++) {
			if (n % i) continue;
			if (n / i % i) n /= i, res ^= 1;
			else return 0;
		}
		if (n > 1) res ^= 1;
		return res ? mod - 1 : 1;
	}
	
}
```

#### Sub1

字面意思，$g(n)=d(n)$，$f(n)=1$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e2 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int n = 1e2, f[MAXN];

int main() {
	freopen("Division.txt", "w", stdout);
//	freopen("trans2.in", "w", stdout);
	printf("%d\n", n);
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j += i) f[j]++;
	}
	for (int i = 1; i <= n; i++) printf("%d %d\n", i, f[i]);
/*	puts("10 0");
	for (int t = 10; t--; printf("%lld\n", randint(7e8, 1e9)));*/
}
```
```cpp
namespace Sub1 {
	
	inline 
	ll solve(ll n) {
		return 1;
	}
	
}
```

#### Sub2

发现 $k=1$，然后下发文件给了个寂寞。猜测 $f(1)=0$，答案为 $f(n)=0$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e2 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int n = 1e2, f[MAXN];

int main() {
	freopen("Unknown.txt", "w", stdout);
//	freopen("trans3.in", "w", stdout);
	puts("1\n1 0");
/*	puts("10 2");
	for (int t = 10; t--; printf("%lld\n", randint(6e17, 1e18)));*/
}
```
```cpp
namespace Sub2 {
	
	inline 
	ll solve(ll n) {
		return 0;
	}
	
}
```

#### Sub3

$k\le n$ 了不用我说了吧……$f(p^k)=\text{rand()}$，答案自己反演。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int p[MAXN], tot; bool vis[MAXN], pk[MAXN];

ll f[MAXN];

inline 
void init(int n) {
	f[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) { p[++tot] = i; for (ll k = i; k <= n; k *= i) f[k] = rand(); }
		if (!f[i]) f[i] = 1;
		for (int j = 1; j <= tot; j++) {
			if (i * p[j] > n) break;
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) break;
		}
	}
	for (int i = 1; i <= tot; i++) {
		for (ll k = p[i]; k <= n; k *= p[i]) {
			for (int j = k << 1; j <= n; j += k) if (j / k % p[i]) f[j] = f[j] * f[k] % mod;
		}
	}
	for (int i = n; i; i--) {
		for (int j = i << 1; j <= n; j += i) f[j] = (f[j] + f[i]) % mod;
	}
}

int n = 1e5;

int main() {
	freopen("Random.txt", "w", stdout);
//	freopen("trans4.in", "w", stdout);
	srand(1); printf("%d\n", n), init(n);
	for (int i = 1; i <= n; i++) printf("%d %lld\n", i, f[i]);
/*	puts("100000 3");
	for (int t = 1e5; t--; printf("%lld\n", randint(1, 1e5)));*/
}
```
```cpp
namespace Sub3 {
	
	bool d = 1;
	
	inline 
	void init() {
		for (int i = 1; i <= k; i++) {
			for (int j = i << 1; j <= k; j += i) f[j] = (f[j] - f[i] + mod) % mod;
		}
	}
	
	inline 
	ll solve(ll n) {
		if (d) init(), d = 0;
		return f[n];
	}
	
}
```

#### Sub4

难度上来了一点。首先反演一次，还是没啥规律，就反演第二次。可以发现每个数都是平方数，开方后就能看出来了。$f(n)=\sum_{d|n}\varphi^2(d)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e2 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int p[MAXN], tot; bool vis[MAXN]; ll f[MAXN];

inline 
void init(int n) {
	f[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) p[++tot] = i, f[i] = (i - 1) * (i - 1) % mod;
		for (int j = 1; j <= tot; j++) {
			if (i * p[j] > n) break;
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) { f[i * p[j]] = f[i] * p[j] * p[j] % mod; break; }
			f[i * p[j]] = f[i] * f[p[j]] % mod;
		}
	}
	for (int i = n; i; i--) {
		for (int j = i << 1; j <= n; j += i) f[j] = (f[j] + f[i]) % mod;
	}
}

int n = 1e2;

int main() {
	freopen("Double.txt", "w", stdout);
//	freopen("trans5.in", "w", stdout);
	printf("%d\n", n), init(n);
	for (int i = 1; i <= n; i++) printf("%d %d\n", i, f[i]);
/*	puts("10 4");
	for (int t = 10; t--; printf("%lld\n", randint(7e8, 1e9)));*/
}
```
```cpp
namespace Sub4 {
	
	inline 
	ll phi(int n) {
		int res = n;
		for (int i = 2; i <= n / i; i++) {
			if (n % i == 0) for (res -= res / i; n % i == 0; n /= i);
		}
		if (n > 1) res -= res / n;
		return (ll)res * res % mod;
	}
	
	inline 
	ll solve(ll n) {
		ll ans = 0;
		for (int i = 1; i <= n / i; i++) {
			if (n % i) continue;
			ans = (ans + phi(i)) % mod;
			if (i != n / i) ans = (ans + phi(n / i)) % mod;
		}
		return ans;
	}
	
}
```

#### Sub5

$t=1$，把数据套下来可以发现是俩大质数相乘。其实看到 $k=\left\lceil\sqrt{10^9}\right\rceil$ 你也知道咋做了吧。$f(p^k)=p^{2k-1}$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;
const int mod = 998244353;

int p[MAXN], tot; bool vis[MAXN], pk[MAXN];

ll f[MAXN];

inline 
void init(int n) {
	f[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) { p[++tot] = i; for (ll k = i; k <= n; k *= i) f[k] = k * k / i % mod; }
		if (!f[i]) f[i] = 1;
		for (int j = 1; j <= tot; j++) {
			if (i * p[j] > n) break;
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) break;
		}
	}
	for (int i = 1; i <= tot; i++) {
		for (ll k = p[i]; k <= n; k *= p[i]) {
			for (int j = k << 1; j <= n; j += k) if (j / k % p[i]) f[j] = f[j] * f[k] % mod;
		}
	}
	for (int i = n; i; i--) {
		for (int j = i << 1; j <= n; j += i) f[j] = (f[j] + f[i]) % mod;
	}
}

int n = 31623;

int main() {
	freopen("Hack.txt", "w", stdout);
//	freopen("trans6.in", "w", stdout);
	printf("%d\n", n), init(n);
	for (int i = 1; i <= n; i++) printf("%d %lld\n", i, f[i]);
//	puts("1 5\n978186151");
}
```
```cpp
namespace Sub5 {
	
	inline 
	void init() {
		for (int i = 1; i <= k; i++) {
			for (int j = i << 1; j <= k; j += i) f[j] = (f[j] - f[i] + mod) % mod;
		}
	}
	
	inline 
	ll solve(ll n) {
		init();
		for (int i = 2; i <= n / i; i++) {
			if (n % i == 0) return f[i] * f[n / i] % mod;
		}
	}
}
```

#### Sub6

前面 45pts 有点愚人，后面就全是正经的点了。容易发现 $g(n)=n^2$，但是显然时间复杂度并不允许我们硬容斥。于是我们可能要推一下式子。过程简单，直接放结果：

$$f(n)=n^2\prod_{p|n}{\left(1-\dfrac1{p^2}\right)}$$

眼尖的同学也能看出来和 $\varphi$ 有些相似了。事实上，$Id_k$ 函数的狄利克雷逆函数都为这个形式。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e2 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int n = 1e2;

int main() {
//	freopen("Square.txt", "w", stdout);
	freopen("trans7.in", "w", stdout);
	printf("%d\n", n);
	for (int i = 1; i <= n; i++) printf("%d %d\n", i, i * i);
/*	puts("5 6");
	for (int t = 5; t--; printf("%lld\n", randint(7e17, 1e18)));*/
}
```
```cpp
namespace Sub6 {
	
	const int prime[] = { 2, 3, 5, 7, 11, 61, 24251 };
	
	mt19937 eng(time(0));
	
	inline 
	ll randint(ll l, ll r) {
	    uniform_int_distribution<ll> dis(l, r);
	    return dis(eng);
	}
	
	inline 
	ll qpow(ll b, ll p, ll mod) {
		ll res = 1;
		while (p) {
			if (p & 1) res = (lll)res * b % mod;
			b = (lll)b * b % mod, p >>= 1;
		}
		return res;
	}
	
	inline 
	bool check(ll a, ll p) {
		ll s = p - 1, k;
		for (; ~s & 1; s >>= 1);
		for (k = qpow(a, s, p); s != p - 1 && k != 1 && k != p - 1; k = (lll)k * k % p, s <<= 1);
		return k == p - 1 || s & 1;
	}
	
	inline 
	bool isprime(ll n) {
		if (n == 1) return 0;
		for (int i = 0; i < 7; i++) {
			if (n == prime[i]) return 1;
			if (n % prime[i] == 0) return 0;
			if (!check(prime[i], n)) return 0;
		}
		for (int i = 1; i <= 10; i++) if (!check(randint(2, n - 1), n)) return 0;
		return 1;
	}
	
	inline 
	ll pollard_rho(ll n) {
	    if (n == 4) return 2;
	    if (isprime(n)) return n;
	    for (ll c, t, r, p, q; ;) {
	        c = randint(1, n - 1), t = 0, r = 0, p = 1, q;
	        auto f = [=](ll x) { return ((lll)x * x + c) % n; };
	        do {
	            for (int i = 0; i < 128; ++i) {
	                t = f(t), r = f(f(r));
	                if (t == r || (q = (lll)p * abs(t - r) % n) == 0) break; p = q;
	            }
	            ll d = __gcd(p, n); if (d > 1) return d;
	        } while (t != r);
	    }
	}
	
	unordered_map<ll, ll> mp;
	
	ll get(ll x) {
	    if (mp[x]) return mp[x];
	    ll k = pollard_rho(x);
	    return mp[x] = k == x ? x : mp[x] = max(get(k), get(x / k));
	}
	
	inline 
	void print(lll n) {
		if (n < 10) return putchar(n ^ '0'), void();
		print(n / 10), putchar(n % 10 ^ '0');
	}
	
	inline 
	ll solve(ll n) {
		lll res = (lll)n * n;
		for (ll k = get(n); ; k = get(n)) {
			for (res -= res / k / k; n % k == 0; n /= k);
			if (n == 1) break;
		}
		mp.clear();
		return res % mod;
	}
}
```

#### Sub7

老套路先反演。对于把所有 $p^k$ 搞下来差分一下就可以知道是个三次多项式。再根据题目名称，猜测是一个关于 $p^k$ 的多项式。直接拉插即可。$f(p^k)=114(p^k)^3+514(p^k)^2+1919(p^k)+810$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int p[MAXN], tot; bool vis[MAXN], pk[MAXN];

ll f[MAXN];

inline 
ll calc(ll k) {
	ll ans = 114;
	ans = (ans * k + 514) % mod;
	ans = (ans * k + 1919) % mod;
	ans = (ans * k + 810) % mod;
	return ans;
}

inline 
void init(int n) {
	f[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) { p[++tot] = i; for (ll k = i; k <= n; k *= i) f[k] = calc(k); }
		if (!f[i]) f[i] = 1;
		for (int j = 1; j <= tot; j++) {
			if (i * p[j] > n) break;
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) break;
		}
	}
	for (int i = 1; i <= tot; i++) {
		for (ll k = p[i]; k <= n; k *= p[i]) {
			for (int j = k << 1; j <= n; j += k) if (j / k % p[i]) f[j] = f[j] * f[k] % mod;
		}
	}
	for (int i = n; i; i--) {
		for (int j = i << 1; j <= n; j += i) f[j] = (f[j] + f[i]) % mod;
	}
}

int n = 1e5;

int main() {
	freopen("Poly.txt", "w", stdout);
//	freopen("trans8.in", "w", stdout);
	printf("%d\n", n), init(n);
	for (int i = 1; i <= n; i++) printf("%d %lld\n", i, f[i]);
/*	puts("100 7");
	for (int t = 100; t--; printf("%lld\n", randint(3e8, 1e9)));*/
}
```
```cpp
namespace Sub7 {
	
	inline 
	ll calc(ll n) {
		ll ans = 114;
		ans = (ans * n + 514) % mod;
		ans = (ans * n + 1919) % mod;
		ans = (ans * n + 810) % mod;
		return ans;
	}
	
	inline 
	ll solve(ll n) {
		ll ans = 1;
		for (ll i = 2, k; i <= n / i; i++) {
			for (k = 1; n % i == 0; n /= i, k *= i);
			if (k > 1) ans = ans * calc(k) % mod;
		}
		if (n > 1) ans = ans * calc(n) % mod;
		return ans;
	}
	
}
```

#### Sub8

压轴，但是只给了前 $4$ 项。首先 $6$ 能求出来，然后 $5$ 可以当没看见。反演完打开一看 `1 1 0 1 ? 0 1`。这个时候就要发扬我们的找规律精神了，大胆猜测这玩意就是 `1 1 0` 重复。不过题目要求 $f$ 是积性函数，咋证明呢？很简单，$f(n)=n^2\bmod\ 3$，而这个显然是完全积性。撒花！

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;
const int mod = 998244353;

mt19937 eng(time(0));

inline 
ll randint(ll l, ll r) {
	uniform_int_distribution<ll> dist(l, r);
	return dist(eng);
}

int main() {
	freopen("Thanks.txt", "w", stdout);
//	freopen("trans9.in", "w", stdout);	
	puts("7\n1 1\n2 2\n3 1\n4 2\n5 2\n6 2\n7 2");
/*	puts("100000 8");
	for (int t = 1e5; t--; printf("%lld\n", randint(1, 1e5)));*/
}
```
```cpp
namespace Sub8 {
	
	inline 
	ll solve(ll n) {
		return n * n % 3;
	}
	
}
```

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef __int128 lll;

const int MAXN = 1e6 + 10;
const int mod = 998244353;

int k; ll f[MAXN];

namespace Sub0 {
	
	inline 
	ll solve(ll n) {
		int res = 0;
		for (ll i = 2; i <= n; i++) {
			if (n % i) continue;
			if (n / i % i) n /= i, res ^= 1;
			else return 0;
		}
		if (n > 1) res ^= 1;
		return res ? mod - 1 : 1;
	}
	
}

namespace Sub1 {
	
	inline 
	ll solve(ll n) {
		return 1;
	}
	
}

namespace Sub2 {
	
	inline 
	ll solve(ll n) {
		return 0;
	}
	
}

namespace Sub3 {
	
	bool d = 1;
	
	inline 
	void init() {
		for (int i = 1; i <= k; i++) {
			for (int j = i << 1; j <= k; j += i) f[j] = (f[j] - f[i] + mod) % mod;
		}
	}
	
	inline 
	ll solve(ll n) {
		if (d) init(), d = 0;
		return f[n];
	}
	
}

namespace Sub4 {
	
	inline 
	ll phi(int n) {
		int res = n;
		for (int i = 2; i <= n / i; i++) {
			if (n % i == 0) for (res -= res / i; n % i == 0; n /= i);
		}
		if (n > 1) res -= res / n;
		return (ll)res * res % mod;
	}
	
	inline 
	ll solve(ll n) {
		ll ans = 0;
		for (int i = 1; i <= n / i; i++) {
			if (n % i) continue;
			ans = (ans + phi(i)) % mod;
			if (i != n / i) ans = (ans + phi(n / i)) % mod;
		}
		return ans;
	}
	
}

namespace Sub5 {
	
	inline 
	void init() {
		for (int i = 1; i <= k; i++) {
			for (int j = i << 1; j <= k; j += i) f[j] = (f[j] - f[i] + mod) % mod;
		}
	}
	
	inline 
	ll solve(ll n) {
		init();
		for (int i = 2; i <= n / i; i++) {
			if (n % i == 0) return f[i] * f[n / i] % mod;
		}
	}
}

namespace Sub6 {
	
	const int prime[] = { 2, 3, 5, 7, 11, 61, 24251 };
	
	mt19937 eng(time(0));
	
	inline 
	ll randint(ll l, ll r) {
	    uniform_int_distribution<ll> dis(l, r);
	    return dis(eng);
	}
	
	inline 
	ll qpow(ll b, ll p, ll mod) {
		ll res = 1;
		while (p) {
			if (p & 1) res = (lll)res * b % mod;
			b = (lll)b * b % mod, p >>= 1;
		}
		return res;
	}
	
	inline 
	bool check(ll a, ll p) {
		ll s = p - 1, k;
		for (; ~s & 1; s >>= 1);
		for (k = qpow(a, s, p); s != p - 1 && k != 1 && k != p - 1; k = (lll)k * k % p, s <<= 1);
		return k == p - 1 || s & 1;
	}
	
	inline 
	bool isprime(ll n) {
		if (n == 1) return 0;
		for (int i = 0; i < 7; i++) {
			if (n == prime[i]) return 1;
			if (n % prime[i] == 0) return 0;
			if (!check(prime[i], n)) return 0;
		}
		for (int i = 1; i <= 10; i++) if (!check(randint(2, n - 1), n)) return 0;
		return 1;
	}
	
	inline 
	ll pollard_rho(ll n) {
	    if (n == 4) return 2;
	    if (isprime(n)) return n;
	    for (ll c, t, r, p, q; ;) {
	        c = randint(1, n - 1), t = 0, r = 0, p = 1, q;
	        auto f = [=](ll x) { return ((lll)x * x + c) % n; };
	        do {
	            for (int i = 0; i < 128; ++i) {
	                t = f(t), r = f(f(r));
	                if (t == r || (q = (lll)p * abs(t - r) % n) == 0) break; p = q;
	            }
	            ll d = __gcd(p, n); if (d > 1) return d;
	        } while (t != r);
	    }
	}
	
	unordered_map<ll, ll> mp;
	
	ll get(ll x) {
	    if (mp[x]) return mp[x];
	    ll k = pollard_rho(x);
	    return mp[x] = k == x ? x : mp[x] = max(get(k), get(x / k));
	}
	
	inline 
	void print(lll n) {
		if (n < 10) return putchar(n ^ '0'), void();
		print(n / 10), putchar(n % 10 ^ '0');
	}
	
	inline 
	ll solve(ll n) {
		lll res = (lll)n * n;
		for (ll k = get(n); ; k = get(n)) {
			for (res -= res / k / k; n % k == 0; n /= k);
			if (n == 1) break;
		}
		mp.clear();
		return res % mod;
	}
}

namespace Sub7 {
	
	inline 
	ll calc(ll n) {
		ll ans = 114;
		ans = (ans * n + 514) % mod;
		ans = (ans * n + 1919) % mod;
		ans = (ans * n + 810) % mod;
		return ans;
	}
	
	inline 
	ll solve(ll n) {
		ll ans = 1;
		for (ll i = 2, k; i <= n / i; i++) {
			for (k = 1; n % i == 0; n /= i, k *= i);
			if (k > 1) ans = ans * calc(k) % mod;
		}
		if (n > 1) ans = ans * calc(n) % mod;
		return ans;
	}
	
}

namespace Sub8 {
	
	inline 
	ll solve(ll n) {
		return n * n % 3;
	}
	
}

typedef ll (*funcs)(ll);

funcs solve[9] = { 
	Sub0::solve, Sub1::solve, Sub2::solve, 
	Sub3::solve, Sub4::solve, Sub5::solve, 
	Sub6::solve, Sub7::solve, Sub8::solve 
};

ll n; int t, id;

int main() {
	scanf("%d", &k);
	for (int i = 1; i <= k; i++) scanf("%*d%lld", &f[i]);
	for (scanf("%d%d", &t, &id); t--; scanf("%lld", &n), printf("%lld\n", solve[id](n)));
}
```

---

## 作者：可爱的小棉羊 (赞：6)

## 题目描述


给定一个**积性函数** $f(d)$。给出 $g(n)=\sum_{d|n}f(d)$ 的其中 $k$ 项的值，接着，输入 $d$，请输出 $f(d)$ 的值。

## 前置小知识

一些简单的数论函数。

狄利克雷卷积和常见的数论函数的狄利克雷卷积：

$$ (g \circ f)(n)=\sum_{d\mid n} f(d)g(\frac{n}{d})$$

$$ I \circ \mu=\varepsilon$$

$$I \circ I=d$$

还需要一份可以对函数反演的代码在[这里](https://www.luogu.com.cn/paste/rs5j973p)。

## $\text{Epsilon}$

这个点很明显 $g(n)=\varepsilon(n)$。

就连这个点的名字 $\text{Epsilon}$ 都表示 $\varepsilon$。

根据 $ I \circ \mu=\varepsilon$，我们知道 $f(n)= \mu(n)$。

单次 $O(\sqrt{n})$ 直接求解。

## $\text{Division}$

$\text{Division}$ 英文翻译为除法，分割。

发扬人类智慧，我们可以猜 $ g(n)=d(n)$（事实也是这样）。

$$ d(n)=\sum_{d \mid n}1$$

输出 $1$ 就行。

## $\text{Unknown}$

真的是 $\text{Unknown}$ 啊！！！

我们只知道 $g(1)=0$，

但很明显 $f(1)=0$。

所以 $f(n)=f(1) \times f(n)=0$，

输出 $0$ 就行。

## $\text{Random}$

打开一看，好抽象啊。。。。。

一言难尽，$g$ 除了是个积性函数以外毫无规律。

研究数据大小，

|$\text{Name}$| $n\leq$|$k=$|$t=$|
|:-:|:-:|:-:|:-:|
|$\text{Random}$|$10^5$|$10^5$|$10^5$|

$n \leq k$！！！

我们可以吧前面的 $g$ 反演了，直接得到所有 $f$。

实际上 $g(p^k)=rand$。（$p$ 为质数，$k$ 为正整数，下面都这样，不多做说明。）

每个点的名字好像有暗示作用啊。。。。。

## $\text{Double}$

前 $25$ pts 有点水，现在终于正常一点了。

反演一次，咦？！没有规律。

但没有关系发扬人类智慧，

这个点的名字 $\text{Double}$ 正好有两倍的意思。

于是反演第二次，咦？！都是完全平方数，

开方后就清楚了。

$$f(n)=\sum_{d\mid n}\varphi^2(d)$$

## $\text{Hack}$

反演一下，观察得 $f(p^k)=p^{2k-1}$。

直接算就行，但是出题人搞了两个大质数相乘，所以直接输出 $n$ 即可。

## $\text{Square}$

很明显 $g(n)=n^2$（对应 $\text{Square}$）。

下面求 $f$：

先考虑 $f(p^k)$ 的取值。

$$f(p^k)=\sum_{d \mid p^k} d^2\mu({\frac{p^k}{d}})$$

可以整除 $p^k$ 的只有 $p^0$，$p^1$，$p^2$ 等。

$$ f(p^k)=\sum_{i=0}^k p^{2i}\mu(p^{k-i})$$

根据 $\mu$ 定义我们知道只有 $i=k$，$k-1$ 时可以产生贡献。

$$f(p^k)=p^{2k}-p^{2k-2}$$

然后考虑 $f(n)$ 的取值，设 $n=\prod^m_{i=1}p^{k_i}_i$。

$$\begin{aligned}

f(n) &=\prod^{m}_{i=1}(p_i^{2k_i}-p_i^{2k_i-2})

\\&=\prod^{m}_{i=1}p_i^{2k_i}(1-\frac{1}{p_i^2})

\\&=n^2\prod^{m}_{i=1}(1-\frac{1}{p^2_i}) 

\end{aligned}$$

一般来讲我们可以 $O(\sqrt{n})$ 分解质因数来求解，

但我们需要用 Pollard-rho 算法来进行优化。

（出题人说第 $8$ 个点压轴，但我认为这个点最难。）

## $\text{Poly}$

想到 $\text{Polynomial}$。

我们可以猜测 $f(p^k)$ 为一个多项式。

可以拉格朗日插值法来做，你也可以解出这个多项式。

$$f(p^k)=114p^{3k}+514p^{2k}+1919p^k+810$$

好臭啊。。。。。

## $\text{Thanks}$

谢谢你。

只有几项，手动反演得 `1 1 0 1 1 ? 1`，$f(5)$ 没法求。

猜测是 `1 1 0` 循环。

如何证明这是积性呢？

可以构造一个 $f$。

~~不知出题人怎么想到 $f(n)=n^2\mod 3$。~~

反正显然积性。

## 总结

Sub $0$，$1$，$2$ 属于送分点；

Sub $3$，$4$，$5$ 属于大众点；

Sub $6$，$7$ 属于较难点；

Sub $8$ 属于整活点。

~~（另外，无聊的问一问每个点的名字都应该与这个点有关，那么 $\text{Hack}$ 指的是什么？）~~

---

## 作者：ダ月 (赞：2)

在做这个题之前，我们需要一个用来莫比乌斯反演的代码（来获取一部分 $f(x)$ 的值）：[代码](https://www.luogu.com.cn/paste/7r8m4j2i)。（事实上稍微改改这个就有 $20$ 分了。）

### Epsilon：

我们进行一次反演，我们得到了以下东西：[Link](https://www.luogu.com.cn/paste/h7o2fteb)。

其实一眼可以看出 $f(n)=\mu(n)$。

具体证明，我们可以观察出 $g(x)=[x=1]$，因此 $f(n)=\sum\limits_{d|n}\mu(d)g(\frac{n}{d})=\mu(n)$。

直接单次 $\sqrt n$ 来获取 $\mu$ 的值。时间复杂度：$O(T\sqrt n)$。

### Division：

我们进行一次反演，我们得到了以下东西：[Link](https://www.luogu.com.cn/paste/yt34i8d3)。

这很丁真，$f(n)=1$。

具体证明我们可以观察出 $g(n)=d(n)$，$f(n)=\sum\limits_{i|n}\mu(i)d(\frac{n}{i})=1$。

直接输出 $1$。时间复杂度：$O(T)$。

### Unknown：

真的什么都不知道吗。哦，我知道 $g(1)=0$，反演一下 $f(1)=0$，是不是 $f(1\times x)=f(x)=f(1)\times f(x)=0$。

直接输出 $0$，时间复杂度：$O(T)$。

### Random：

如其名，$f(p^k)=\operatorname{rand}$。好好好。但是只要我们看到数据范围，我们会发现我们可以通过 $g(n)$ 直接反演出 $f(n)$。

时间复杂度：$O(T\sqrt n)$。

### Double：

我们做一次反演，我们得到下面这些东西（前面那一排是编号）：[Link](https://www.luogu.com.cn/paste/9ovc693j)。我们没看出什么。通过标题，我们不妨对 $f(x)$ 再进行一次反演，我们得到以下东西：[Link](https://www.luogu.com.cn/paste/274o9ity)。

我们即二次反演后的函数为 $h$。注意到，$h(p)=(p-1)^2$，$h(p^k)=(p^{k-1}(p-1))^2$，$h(n)=\prod(p^{k-1}(p-1))^2=(\prod p^{k-1}(p-1))^2=(\varphi(n))^2$.

因为 $f(n)=\sum\limits_{d|n}(\varphi(d))^2$。

直接做，时间复杂度：$O(T\sqrt n)$。

### Hack：

我们进行一次反演，我们得到以下东西：[Link](https://www.luogu.com.cn/paste/z710ccf2)。

我们注意到：$f(p)=p$，$f(p^2)=p^2f(p)$，因此得到 $f(p^k)=p^{2k-1}$。

直接做，时间复杂度：$O(T\sqrt n\log n)$。

不过，好像因为 $T=1$ 的缘故，出题人搞了个 $n$ 为两个大质数相乘。那么直接输出 $n$ 即可。时间复杂度度：$O(T)$。

### Square：

好了，抽象的东西来了。我们注意到 $g(n)=n^2$，那么 $f(n)=\sum\limits_{d|n}\mu (d)(\frac{n}{d})^2=n^2\sum\limits_{d|n}\frac{\mu(d)}{d^2}$。

我们考虑 $n$ 所有的因子满足因子的所有的质因子出现次数不超过 $1$ 次（有点绕）。记 $n$ 的所有质因子的集合为 $S$，这个集合为不可重集合。那么 $\sum\limits_{d|n}\frac{\mu(d)}{d^2}=\sum\limits_{T\subset S}\dfrac{(-1)^{|T|}}{\prod\limits_{p\in T}p^2}=\prod\limits_{p\in S}(1-\dfrac{1}{p^2})$。

因此 $f(n)=n^2\prod\limits_{p\in S}(1-\dfrac{1}{p^2})$。

我们要对 $n$ 分解质因数，考虑 pollord rho。小心爆 `long long`。

时间复杂度：$O(Tn^{\frac{1}{4}})$

### Poly：

看到这个标题的时候，我第一个想到多项式（Polynomial）。结果还真是。

老规矩，先反演得到 $f$：[Link](https://www.luogu.com.cn/paste/ng7a9pah)。

我们将所有 $f(p^{k})$ 的值拎出来，然后不断差分，发现 $f(p^k)$ 是一个关于 $x$ 的三次函数。

接下来有两条路：

1. 拉格朗日插值；
2. 把多项式直接求出来。

如果你是一个臭恶的猛人，手撕 $f(p^k)$ 的多项式，你会发现 $f(p^k)=114(p^k)^3+514(p^k)^2+1919(p^k)+810$。

直接做，时间复杂度：$O(T\sqrt n)$。

### Thanks：

谢谢你。

由于项数过少，考虑直接手撕。

我们可以撕出以下 $f$ 的值：

`1 1 0 1 1 ? 1`

小学奥数之找规律，需要找到一个积性函数 $f(x)$，满足上面的值。

注意到，$f(n)=n^2\bmod 3$。这是一定是一个积性函数，但是至于怎么想到这个函数，我感觉能想到是一件很抽象的事。

时间复杂度：$O(T)$。

---

[本题代码](https://www.luogu.com.cn/paste/48f7r0vx)。

---

## 作者：diqiuyi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9920)。

#### Epsilon

显然 $g(n)=[n=1]$，所以 $f=\mu$。

#### Division

观察可以发现 $g(n)$ 实际上是约数个数函数。显然 $f=I$。

#### Unknown	

$f(1)=g(1)=0$，因此 $f(n)=f(n)f(1)=0$。

#### Random	

发现 $n$ 的范围和 $k$ 的一样。考虑通过 $g$ 把 $f$ 算出来。显然有 $f(n)=g(n)-\sum_{d\mid n\land d\neq n}f(d)$，直接枚举倍数算贡献即可。

#### Double

这个似乎不太好发现。考虑观察 $f$ 在 $p^k$ 处的取值。发现对数列 $a_i=f(2^i)$ 差分后是一个等比数列。把 $2$ 换成 $3$ 和 $5$ 这个性质依然成立。

同时发现 $f(p)=(p-1)^2+1$。所以这个等比数列的首项为 $(p-1)^2$。稍作观察可以发现这个数列的公比是 $p^2$。所以有 $f(p^k)=f(p^{k-1})+(p-1)^2(p^{2k-2})$。化简可以得到 $f(p^k)=\dfrac{(p-1)(p^{2k}-1)}{p+1}+1$。

每次询问质因数分解后计算即可。
#### Hack

观察发现 $f(2)=2$，$f(4)=8$，$f(8)=32$，所以猜测 $f(p^k)=p^{2k-1}$。带入发现成立，所以每次询问质因数分解 $n$ 算出答案即可。

所以为什么叫这个名字啊。

#### Square

$g(n)=n^2$。莫反一下得到 $f(n)=\sum_{d\mid n}\mu(\dfrac{n}{d})d^2$。然后每次询问直接算就可以了。但是 $n$ 太大了，要用 pollard rho 分解质因数。具体实现的话，考虑 dfs 枚举 $\dfrac{n}{d}$，那么显然每个质因子最多取 $1$ 个，所以时间复杂度为 $O(T(n^{\frac{1}{4}}+2^{\omega(n)}))$。至于 $\mu$ 的值，在 dfs 的时候计算就可以了。

#### Poly

结合标题，猜测在质数处取值是一个多项式。然后高斯消元即可。不过我没有模意义下高斯消元的板子，所以套了个拉插然后剩下的手算。

最后得到的结果是 $f(p^k)=114p^{3k}+514p^{2k}+1919p^k+810$。

然后每次质因数分解后直接算就可以了。

#### Thanks

相当于啥都没给啊。但是我们大胆猜测 $f(p^k)=[p\neq 3]$。然后质因数分解以后计算就对了。

这个东西相当于 $f(n)=n^2 \bmod 3$，不过质因数分解计算也无伤大雅。

**有点丑的代码**
```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
const int mod=998244353;
int k,d[100005],t,id,tim[20],prime[100005],cnt,f[1000005],tot;
bitset<1000005> vis;
ll gd[100005],n,pri[20],ret;
vector<ll> v;
const int p[5]={2,7,11,31,61};
ll getp(int p){
	if(!id) return -1;
}
ll getval(int p,int k){
	if(!id) return 0;
	if(id==4){
		ll res=1;
		for(int i=1;i<=2*k;i++) res*=p;
		res=(res-1)/(p+1)*(p-1);
		return (res+1)%mod;
	}
	if(id==7){
		ll n=1;
		for(int i=1;i<=k;i++) n*=p;
		return (114ll*n%mod*n%mod*n%mod+514ll*n%mod*n%mod+1919ll*n%mod+810)%mod;
	}
	if(id==5){
		ll res=1;
		for(int i=1;i<2*k;i++) res*=p;
		return res%mod;
	}
	if(id==8){
		if(p==3) return 0;
		return 1;
	}
}
int ans(int x){
	int res=1;
	for(int i=2;i*i<=x;i++){
		if(!(x%i)){
			int now=0;
			while(!(x%i)) x/=i,now++;
			res=1ll*res*getval(i,now)%mod;
		}
	}
	if(x>1) res=1ll*res*getval(x,1)%mod;
	return res;
}
ll gcd(ll x,ll y){
	int xx=__builtin_ctzll(x),yy=__builtin_ctzll(y),zz=min(xx,yy);
	y>>=yy;
	while(x){
		x>>=xx;
		ll d=abs(x-y);
		xx=__builtin_ctzll(d);
		y=min(x,y),x=d;
	}
	return y<<zz;
}
ll mul(ll a,ll b,ll n){
  return ((ull)a*b-(ull)((long double)a/n*b)*n+n)%n;
}
ll Pow(ll x,ll y,ll mod){
	ll res=1;
	for(;y;y>>=1,x=mul(x,x,mod))
		if(y&1)
			res=mul(res,x,mod);
	return res;
}
bool check(ll n){
	if(n<=65){
		if(n==1) return 0;
		for(int i=2;i*i<=n;i++)
			if(!(n%i))
				return 0;
		return 1;
	}
	ll d,g;
	for(int i=0;i<5;i++){
		d=n-1,g=Pow(p[i],d,n);
		if(g^1) return 0;
		while((d&1)^1){
			d>>=1,g=Pow(p[i],d,n);
			if(g==n-1) break;
			if(g^1) return 0;
		}
	}
	return 1;
}
ll getd(ll n){
	ll c=rand()*rand(),xl=c+1145141,x=xl,y=xl;
	if(n<=20)
		for(int i=2;i<=n;i++)
			if(!(n%i))
				return i;
	x=(mul(x,x,n)+c)%n,y=(mul(y,y,n)+c)%n,y=(mul(y,y,n)+c)%n;
	for(int lmt=1;x^y;lmt=min(lmt,64)){
		ll cnt=1;
		for(int i=1;i<=lmt;i++){
			ll now=mul(cnt,abs(x-y),n);
			if(!now) break;
			cnt=now; 
			x=(mul(x,x,n)+c)%n,y=(mul(y,y,n)+c)%n,y=(mul(y,y,n)+c)%n;
		}
		ll d=gcd(cnt,n);
		if(d>1) return d;
	} 
	return 1;
}
void pr(ll x){
	if(x<=1) return ;
	if(check(x)){
		v.push_back(x);
		return ;
	}
	ll d=getd(x);
	pr(d),pr(x/d);
}
void dfs(int x,ll now,int m){
	if(x>tot){
		ret=(ret+((n/now)%mod)*((n/now)%mod)%mod*m)%mod;
		return ;
	}
	dfs(x+1,now,m);
	dfs(x+1,now*pri[x],-m);
}
int main(){
//	freopen("Hack.txt","r",stdin);
//	freopen("hakc.txt","w",stdout);
	srand(time(0));
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>k;
	for(int i=1;i<=k;i++) cin>>d[i]>>gd[i];	
	cin>>t>>id; 
	f[1]=1;
	if(id==2){
		while(t--) cout<<"0\n";
		return 0;
	}
	if(id==1){
		while(t--) cout<<"1\n";
		return 0;
	}
	if(id==4){
		while(t--)
			cin>>n,cout<<ans(n)<<'\n';
		return 0;
	}
	for(int i=2;i<=1000000;i++){
		if(!vis[i]) prime[++cnt]=i,f[i]=getp(i);
		for(int j=1;j<=cnt&&prime[j]*i<=1000000;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]) f[i*prime[j]]=1ll*f[i]*f[prime[j]]%mod;
			else{
				int res=i,res2=1;
				while(!(res%prime[j])) res/=prime[j],res2++;
				f[i*prime[j]]=1ll*f[res]*getval(prime[j],res2)%mod;
				break;
 			}
		}
	}//这里其实是筛 mu，但是原本以为很多部分都要筛，所以写的很怪
	if(!id){
		while(t--) cin>>n,cout<<(f[n]+mod)%mod<<'\n';
		return 0;
	}
	if(id==3){
		for(int i=1;i<=100000;i++)
			for(int j=i+i;j<=100000;j+=i)
				gd[j]-=gd[i];
		while(t--)
			cin>>n,cout<<(gd[n]%mod+mod)%mod<<'\n';
		return 0;
	}
	if(id==7){
//		for(int i=1;i<=100000;i++)
//			for(int j=i+i;j<=100000;j+=i)
//				gd[j]-=gd[i],gd[j]%=mod;
//		for(int i=1;i<=100;i++)
//			cout<<i<<' '<<(gd[i]+mod)%mod<<'\n';
//		cout<<ans(10)<<'\n';
		while(t--)
			cin>>n,cout<<ans(n)<<'\n';
		return 0;
	}
	if(id==6){
		while(t--){
			cin>>n,v.clear(),tot=ret=0;
			pr(n);
			sort(v.begin(),v.end());
			memset(tim,0,sizeof(tim));
			for(int i=0;i<v.size();i++)
				if(v[i]==pri[tot]) tim[tot]++;
				else pri[++tot]=v[i],tim[tot]=1;
			dfs(1,1,1);
			cout<<(ret+mod)%mod<<'\n';
		}
		return 0;
	}
	if(id==5){
//		for(int i=1;i<=100000;i++)
//			for(int j=i+i;j<=100000;j+=i)
//				gd[j]-=gd[i],gd[j]%=mod;
//		for(int i=1;i<=100;i++)
//			cout<<i<<' '<<(gd[i]+mod)%mod<<'\n';
		while(t--)
			cin>>n,cout<<ans(n)<<'\n';
		return 0;
	}
	while(t--)
		cin>>n,cout<<ans(n)<<'\n';
	return 0;
}

---

## 作者：vzcx_host (赞：1)

## 题目描述
给定一个**积性函数** $f(d)$。对于每一个测试点，我们会在附件中给出 $g(n)=\sum_{d|n}f(d)$ 的其中 $k$ 项 $\bmod\ 998244353$ 的值，这部分也会在输入中出现。接着，对于每一个测试点，有 $t$ 组数据。对于每组数据，输入 $d$，请输出 $f(d)\bmod998244353$ 的值。

**本题解中，未经特殊说明 $p$ 一般指质数。**
## $\text{Epsilon}$
$g(1)=1,g(i)=0(i\ge 2)$。

莫比乌斯函数的经典结论。
## $\text{Division}$
$k=100,g=\{1,2,2,3,2,4,2,4\ \dots\}$。

简单找找规律，可以发现 $g(i)$ 为 $i$ 的因数个数，根据定义，$f(x)=1$。
## $\text{Unknown}$
$g(1)=0$。

首先 $g(1)=f(1)$，所以 $f(1)=0$。

由积性函数的定义可得 $f(1)f(x)=f(x)$，所以 $f(x)=0$。
## $\text{Random}$
$n\le 10^5=k$。

题目给了 $g(1\dots k)$ 的所有值，根据这些值容斥还原即可。

具体的，$f(n)=g(n)-\sum_{d\neq n,d|n}f(d)$，埃筛即可。
## $\text{Double}$
好了，到这里开始不会做了，使用作弊大法：OEIS。

使用 $\text{Random}$ 的做法还原出原序列，放进 OEIS 中搜一搜，就找到了。

$f$ 为 OEIS 上的 [A029939](https://oeis.org/A029939)。

描述中说 $f(n)$ 为 $1\le i,j\le n,\gcd(i,n)=\gcd(j,n)$ 的 $(i,j)$ 对数，直接做的话 $n\le 10^9$ 不好做，考虑利用积性函数的性质，$f(p^k)$ 是好做的，可以直接套公式也可以容斥，将 $n$ 质因数分解即可。
## $\text{Hack}$
还是不会，继续作弊。

再次使用 $\text{Random}$ 的做法还原出原序列，还是放进 OEIS 中搜一搜，又搜到了。

$f$ 为 OEIS 上的 [A102631](https://oeis.org/A102631)。

$f(n)=\dfrac{n^2}{\Pi_{p|n}}$，继续暴力找 $n$ 的质因数计算即可。
## $\text{Square}$
$g(i)=i^2$。

还原出来的 $f$ 函数并没有规律，OEIS 中也没有明显的通项，还是考虑积性，易发现 $f(p^k)=p^{2k-2}(p^2-1)$，还是质因数分解计算。

由于 $n\le 10^{18}$ 要用 Pollard-Rho。不知道有没有更简单的做法。

~~由于忘了 Pollard-Rho 还特意去重学了一遍。~~

$f$ 为 OEIS 上的 [A007434](https://oeis.org/A007434)。
## $\text{Poly}$
序列杂乱无章，OEIS 肯定指望不上了，还原 $f$ 之后找找规律。

发现 $f(p^k)$ 在 $p^k$ 比较小的时候值比较小，而其它的数可以通过积性解决。发现值的增加量比较均匀，猜测 $f(x)$ 在 $p^k$ 上是一个多项式函数。

由于有 $4$ 项可以直接使用，尝试解出这个方程组，解出是一个三次多项式 $A$，多代入几个值发现 $f(x)=A(x)$，直接做即可。

$A$ 留给读者自己去解。
## $\text{Thanks}$
$g(2)=2,g(3)=1,g(4)=3,g(7)=2$。

数的数量非常少，加上 Special Judge 存在，猜只要满足这 $k$ 个条件与积性的要求即可（正确性不详）。

$f(x)=[x\!\!\mod 3 \ne 0]$，满足这 $k$ 个条件，积性显然，实测可过。

[code](https://www.luogu.com.cn/paste/5xs2l4zi)。

---


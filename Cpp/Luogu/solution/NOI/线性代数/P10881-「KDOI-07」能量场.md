# 「KDOI-07」能量场

## 题目背景

4202 年，小 K 作为一名已经工作了 3143 天的 gaLaxy enGineer Master，在 XS41 星系的 OIPA115 星球上建立了据点，帮助人类探索未知。在这里，他建起了一些能量场。原本他决定使用一些卒来运输能量，然而在他操控的两个红色卒碰撞并损失所有能量后决定还是应该使用能量管道连接他们，~~并使能量管道呈 $(180+\mathrm{eps})^\circ$ 角~~。

## 题目描述

小 K 有 $n$ 个能量场，第 $i$ 个能量场存储 $a_i$ 点能量。

小 K 在能量场之间建立了 $n$ 条不同的双向能量管道，使得能量场两两连通。

对于一条能量管道，它的能量级为两端能量场能量之和。

小 K 对一组 $n$ 个不同能量管道集合的满意度是所有能量管道能量级的乘积。

现在小 K 想知道，对于所有不同的合法的搭建能量管道的方式，满意度的总和是多少。由于小 K 的满意度是一个 $[0,998244353)$ 之间的整数，所以你只需要输出满意度总和对 $998244353$ 取模后的值即可。

两种搭建管道的方式是不同的当且仅当存在至少一条管道连接能量场 $i,j$，且恰好在其中一种搭建管道的方式中出现。

---

**【形式化题意】**

有一个 $n$ 个点的完全图 $G(V,E)$。每个点有点权 $a_i$。$i,j$ 两点之间的边权 $w_{i,j}=a_i+a_j$。

定义一个连通子图 $G'(V,E')$ 使得 $E'\in E$ 的权值为 $\prod_{e\in E'}w_e$。注意，子图的点集是全集。

求 $G(V,E)$ 的连通子图中所有基环树的权值和，对 $998244353$ 取模。

基环树要求无重边无自环。

## 说明/提示

### 样例解释 1

可能的基环树形态只有包含三个点的环，环边 $(1,2),(1,3),(2,3)$ 的边权分别是 $3,4,5$，乘积为 $60$。

### 数据规模与约定

**本题采用捆绑测试。**

| $\mathrm{Subtask}$ | $n\leq$ | 特殊性质 | 分数 |
|:--:|:--:|:--:|:--:|
| $1$ | $3$ |  | $1$ |
| $2$ | $7$ |  | $4$ |
| $3$ | $24$ | $\checkmark$ | $5$ |
| $4$ | $12$ |  | $10$ |
| $5$ | $18$ |  | $10$ |
| $6$ | $20$ |  | $5$ |
| $7$ | $23$ |  | $5$ |
| $8$ | $24$ |  | $30$ |
| $9$ | $50$ |  | $15$ |
| $10$ | $200$ |  | $5$ |
| $11$ | $500$ |  | $5$ |
| $12$ | $1000$ |  | $5$ |

特殊性质：保证 $\forall i\in[1,n],a_i=499122177$。

对于所有数据，保证 $3\leq n\leq 1000$，$0\leq a_i<998244353$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
60```

## 样例 #2

### 输入

```
4
1 2 3 4```

### 输出

```
8629```

## 样例 #3

### 输入

```
7
1 9 1 9 8 1 0```

### 输出

```
311816897```

## 样例 #4

### 输入

```
16
2 0 0 9 0 2 2 8 2 0 0 9 0 8 1 5```

### 输出

```
871736512```

# 题解

## 作者：dAniel_lele (赞：7)

#### 解法 1 by Daniel_lele

注意到 $n$ 个点的连通基环树等价于 $n$ 个点 $n$ 条边的连通图。

考虑连通性容斥，设 $dp_{S,i}$ 表示 $S$ 集合内 $i$ 条边成为连通子图的方案数。答案即为 $dp_{T,n}$，其中 $T$ 为全集。

可以通过枚举 $S$ 中 $\operatorname{lowbit}$ 并钦定其所在连通子图及边数以容斥。总复杂度 $O(3^nn^2)$，期望得分 $15$。

考虑优化，将 $w_{i,j}$ 贡献拆开，问题变为对于每条边，钦定一个点为端点，乘积的和。

考虑将答案表示为对于 $p$ 满足 $p_1+p_2+\dots+p_n=n$ 的 $\prod_{i=1}^na_i^{p_i}$ 的形式。容易发现本质不同的 $p_i$ 数量是拆分数的。

考虑如何对于已经钦定的每个点出度 $p$，求出符合要求的基环树数量。将 $p$ 写为 $p$ 中包含 $q_i$ 个 $i$ 的形式。仍然使用连通性容斥，钦定 $q'_i\leq q_i$，其中 $q'_i$ 并不全等于 $q_i$ 且对于最大的 $i$ 使得 $q_i\geq1$，$q'_i\geq 1$，即钦定出出度最大的点所在连通块。剩下部分的贡献可以预处理出。

通过搜状态可以得到 $n=24$ 时状态数为 $128304$，转移数为 $44290747$，转移复杂度在 $O(\sqrt n)$ 到 $O(n)$ 不等，期望得分 $35\sim 70$。

#### 解法 2 by zhoukangyang

考虑树的情况，显然可以使用矩阵树定理解决。

考虑通过钦定环将原问题转化为树，将环上的点视为一个点，并使用矩阵树定理即可在 $O(2^nn^3)$ 复杂度内解决，期望得分 $25$。矩阵树定理时，为了方便，我们可以删掉环对应的那个点的所在行列。

注意到我们需要求出 $\det(D-A)$，其中 $D$ 为对角矩阵，$A_{i,j}=a_i+a_j$。不难发现 $A$ 的秩不超过 $2$。考虑使用低秩矩阵分解。

考虑定义：$\det(D-A)=\sum_{p}(-1)^{\operatorname{inv}(p)}\prod_{i=1}^m(D_{i,p_i}-A_{i,p_i})$。将乘积式的贡献拆开，$D_{i,p_i}$ 有值当且仅当 $p_i=i$，于是对于选出其贡献由 $A$ 矩阵的行 $i$ 的集合 $S$，满足 $S=\{p_x|x\in S\}$。如果选出 $|S|>2$，则子矩阵秩小于 $|S|$，贡献为 $0$。也就是说，$A$ 中最多选择两行 $i,j$ 给出贡献。注意到 $\{1,2,\dots n\}$ 交换两个位置后的逆序对数量为奇数，故 $A$ 给出的贡献有三种情况：

* 不贡献，则给 $\det(D-A)$ 的贡献为 $\prod_{i=1}^nD_{i,i}$；

* 贡献一行 $i$，则给 $\det(D-A)$ 的贡献为 $-A_{i,i}\prod_{j\neq i}D_{j,j}$；
* 贡献两行 $i,j$，则给 $\det(D-A)$ 的贡献为 $(A_{i,i}A_{j,j}-A_{i,j}A_{j,i})\prod_{k\neq i,k\neq j}D_{k,k}$。

于是我们可以 $O(n^2)$ 计算这个行列式，总复杂度 $O(2^nn^2)$，期望得分 $30$。

考虑优化，对于环上的点，他们对环的贡献一定是 $a_i^0,a_i^1,a_i^2$。考虑 $dp_{i,j,k_0,k_1,k_2}$，表示看到前 $i$ 个位置，$j=0$ 时表示还未钦定 $A$ 给行列式的贡献，$j=1$ 时表示钦定完了 $A$ 给行列式的贡献，$j>1$ 时表示钦定贡献的其中一行为 $j-1$，环上点 $a_i^0,a_i^1,a_i^2$ 分别选了 $k_0,k_1,k_2$ 个的总和。

转移时，分不在环上，通过 $D$ 给行列式贡献，通过 $A$ 给行列式贡献，以及在环上三种情况考虑。最后统计时计算 $k_0,k_1,k_2$ 组成环的方案数即可。总复杂度 $O(n^5)$，期望得分 $85$。

考虑优化，对于贡献两行 $i,j$ 的情况，可以将贡献拆开得到 $2a_ia_j-a_i^2-a_j^2$，于是就可以在 dp 的时候钦定前缀没选择贡献两行、通过 A 贡献完了、选择贡献了一行并产生 $2a_i$、$-a_i^2$、$1$ 的贡献，不用额外记录一维 $j$。总复杂度 $O(n^4)$，期望得分 $90$。

考虑继续优化，注意到 $D_{i,i}=na_i+sum$，其中 $sum=\sum_{i=1}^na_i$。不难发现将 $sum$ 当成常数后，答案一定是 $\prod_{i=1}^na_i^{x_i}$ 的形式，其中 $x_i\leq 2$。将问题分成两部分计算：选定 $i,j,k$ 个 $x_p=0,x_p=1,x_p=2$ 的情况下所有 $\prod_{i=1}^na_i^{x_i}$ 的值以及对应的系数。

前半部分可以通过简单的 dp 解决。后半部分考虑从一个环的情况倒推（这是 $O(n^2)$ 的），枚举是否有贡献一行/两行的情况（这是 $O(1)$ 的），并枚举 $D_{i,i}$ 中 $a_i^1$ 的贡献（这是 $O(n)$ 的），剩下的均为当作常数项的 $sum$。之后将两部分拼起来即可。总复杂度 $O(n^3)$，期望得分 $95\sim100$。

---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10881)

## 题意

给你一个长为 $n$ 的序列 $a_{1\dots n}$，定义一条边 $(u,v)$ 的权值为 $a_u+a_v$。对于一张图，定义其权值为包含的所有边的权值乘积。求所有 $n$ 个点的有标号基环树的权值之和。对 $998244353$ 取模。

$n\le 10^3$。

## 思路
非常厉害的题，zky 倾情提供 solution。只讲述对正解有意义的几个 sub。

### $n\le 18$

考虑基环树把环缩起来就是一颗树，而树的权值乘积很自然就能想到矩阵树定理，我们不妨枚举哪些点在环上，我们可以 DP 求出这些点构成的环的权值和，然后将这些点缩起来（边权、度数相加）做一次矩阵树定理，为了方便我们可以将代表这个环的点删去。

时间复杂度 $O(2^nn^3)$，期望得分 $25$。

### $n\le 20$

我们不妨研究一下我们需要求行列式的矩阵的性质。我们需要求 $\det(D-A)$，其中 $D$ 只有对角线位置有值且 $D_{i,i}=na_i+\sum_{j=1}^na_j$，$A_{i,j}=a_i+a_j$，不妨设 $d_i=D_{i,i}$。

由行列式的基本性质，我们可以将求 $\det(D-A)$ 看成选取一个行的集合 $S$，将矩阵 $D$ 在集合内的行替换为 $-A$ 对应的行，对于所有 $S$ 求替换后的矩阵的行列式之和。

观察出矩阵 $A$ 的一个重要性质：$A$ 中任意三行线性相关。于是我们只需要考虑大小不超过 $2$ 的 $S$。

根据行列式的定义式，我们可以简单地将行列式求出：
- $|S|=0$，$\prod_{i=1}^nd_i$；
- $|S|=1$，$-2\sum_{i=1}^na_i\prod_{j\ne i}d_j$；
- $|S|=2$，$\sum_{i=1}^n\sum_{j=i+1}^n(2a_ia_j-a_i^2-a_j^2)\prod_{k\ne i,k\ne j}d_k$。

需要注意 $d_i$ 在模意义下等于 $0$ 的情况。

时间复杂度 $O(2^nn^2)$，期望得分 $30$。

### $n\le 200$

我们尝试进一步对特殊的边权进行处理。

对于环上的部分，我们需要给定点集对于每一种可能的环求出边权的乘积之和，注意到边权是 $a_i+a_j$ 的形式，而环上的点度数又恰为 $2$，所以每个点对答案的贡献只可能是 $a_i^0,a_i^1,a_i^2$ 之一！

注意到点的编号对环没有影响，我们只需要考虑环上分别有有 $i,j,k$ 个点对答案的贡献次幂为 $0,1,2$ 时可以形成多少个环即可。不妨将边权为 $a_u+a_v$ 看成给 $(u,v)$ 这条边定向，将指向的那个点的权值乘入答案，每个点对答案的贡献次幂即为它的入度。对于上述问题，

- 首先有 $j+2k=i+j+k$ 即 $i=k$；
- 先将入度为 $0,2$ 的点放在环上，显然只能交替放，分配方案的编号为 $i!(i-1)!$，注意环可以翻转，方案数要除以二；
- 再将入度为 $1$ 的点依次插入环中，由于这些点入度出度都为 $1$，可以任意插入两个点之间，方案数为 $\dfrac{(2i+j-1)!}{(2i-1)!}$。

即 $i$ 个 $0,2$ 度点、$j$ 个 $1$ 度点构成环的方案数为 $\dfrac{i!(i-1)!(2i+j-1)!}{2(2i-1)!}$，特判 $i=0$ 时方案数为 $(j-1)!$。

于是我们依次将每个点划分给环内/环外，进行一个 DP，设 $f_{i,a,b,c,p,q}$ 表示考虑前 $i$ 个点，划分给环内的点分别有 $a,b,c$ 个贡献了 $0,1,2$ 次幂，环外钦定的 $S$ 内的点分别为 $p,q$ 时的答案和，转移 $i$ 时枚举 $i$ 划分给哪一部分并算入对应贡献即可。而 $p,q$ 这两维也可以在转移到时并入计算，于是我们得到了一个状态为四维，转移 $O(1)$ 的做法。

时间复杂度 $O(n^4)$，期望得分 $90$。

### $n\le 1000$

回想一下，$d_i=na_i+\sum_{j}a_j$，再回看上述式子，我们发现环外的部分对答案的贡献同样是 $a_i$ 的 $0,1,2$ 次幂之一！

再考虑求出全局中 $0,1,2$ 次幂分别有 $i,j,k$ 个时对答案的贡献系数。不妨考虑先枚举一个环，环上 $0,1,2$ 次幂分别有 $i,j,i$ 个，再枚举环外的 $|S|$ 和有几个 $d_p$ 选择了其中的 $na_p$，分配标号并乘上一些 $n$ 和 $\sum a$ 即可。

再 DP 求出 $0,1,2$ 次幂分别有 $i,j,k$ 个时的和，注意到 $i+j+k=n$，我们可以省去一维，于是状态变为三维。

时间复杂度 $O(n^3)$，可以通过。

参考代码：
```cpp
int n,sv,v[N],fac[N],ifac[N],inv[N],pw0[N],pw1[N],C[N][N],g[N][N];
int f[N][N][2];
inline void Prefix(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=1ll*i*fac[i-1]%mod;
	ifac[n]=qpow(fac[n],mod-2);
	for(int i=n;i;i--)
		ifac[i-1]=1ll*i*ifac[i]%mod;
	for(int i=1;i<=n;i++)
		inv[i]=1ll*ifac[i]*fac[i-1]%mod;
	pw0[0]=pw1[0]=1;
	for(int i=1;i<=n;i++)
		pw0[i]=1ll*pw0[i-1]*n%mod,
		pw1[i]=1ll*pw1[i-1]*sv%mod;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		v[i]=read(),inc(sv,v[i]);
	Prefix(n);
	int in=qpow(n,mod-2);
	for(int i=0;i<=n;i++){
		C[i][0]=1;
		for(int j=1;j<=n;j++)
			C[i][j]=add(C[i-1][j-1],C[i-1][j]);
	}
	for(int i=0;i<=n;i++)
		for(int j=0;i+i+j<=n;j++){
			if(i+j+i<=2) continue;
			int v;
			if(!i) v=fac[j-1];
			else v=1ll*fac[i]*fac[i-1]%mod*fac[i+i+j-1]%mod*ifac[i+i-1]%mod*ifac[2]%mod;
			for(int l=0,p=n-i-i-j-l,tv=1ll*v*pw0[p]%mod;p>=0;l++,p--,tv=1ll*tv*sv%mod*in%mod)
				inc(g[i+l][j+p],1ll*tv*C[i+l][i]%mod*C[j+p][p]%mod);
			for(int l=0,p=n-i-i-j-1-l,tv=1ll*v*pw0[p]%mod;p>=0;l++,p--,tv=1ll*tv*sv%mod*in%mod)
				dec(g[i+l][j+p+1],2ll*tv*C[i+l][i]%mod*C[j+p][p]%mod*(j+p+1)%mod);
			for(int l=0,p=n-i-i-j-2-l,tv=1ll*v*pw0[p]%mod;p>=0;l++,p--,tv=1ll*tv*sv%mod*in%mod)
				dec(g[i+l+1][j+p],1ll*tv*C[i+l][i]%mod*C[j+p][p]%mod*(i+l+1)%mod*(i+1)%mod),
				inc(g[i+l][j+p+2],1ll*tv*C[i+l][i]%mod*C[j+p][p]%mod*(j+p+2)%mod*(j+p+1)%mod);
		}
	int r=1;
	f[0][0][0]=1;
	for(int i=0;i<n;i++,r^=1)
		for(int a=0;a<=i;a++)
			for(int b=0;a+b<=i;b++){
				if(!f[a][b][r^1]) continue;
				int t=f[a][b][r^1],x=v[i+1];
				int tx=1ll*t*x%mod,tx2=1ll*tx*x%mod;
				inc(f[a+1][b][r],t);
				inc(f[a][b+1][r],tx);
				inc(f[a][b][r],tx2);
				f[a][b][r^1]=0;
			} 
	r^=1;
	int ans=0;
	for(int a=0;a<=n;a++)
		for(int b=0;a+b<=n;b++)
			inc(ans,1ll*f[a][b][r]*g[a][b]%mod);
	write(ans);
	flush();
}
```

---

## 作者：naoliaok_lovely (赞：4)

~~神仙题，%%% zhoukangyang~~  
本文参考了各位大佬的讲解 ~~（薄纱本蒟蒻）~~，比较详细，算是其他题解的补充。

# Solution1
先考虑暴力怎么打。

基环树比较陌生，但是如果求树的权值和，可以直接 matrix-tree。一开始想的是随便断掉环上的一条边，发现这样做很麻烦，还要考虑算重的问题。不妨换个思路：直接枚举环上的点。设环上点的集合为 $S$，我们可以把 $S$ 缩为一个点（设缩为 $x$ 号点），再计算剩余部分的行列式即可。

注意到 $x$ 的连边相当于 $S$ 集合中所有点向外面点的连边，也就是说除了 $x$ 对应的行列，矩阵中的其余值均不变。为了处理这个东西，我们可以直接删去 $x$ 对应的行列（在求行列式之前本来就要删去一行一列），这等价于删去 $S$ 集合中所有点对应的行列。

于是先 $O(2^n)$ 枚举环，环外的贡献可以 $O(n^3)$ 计算，环内的贡献可以预处理做到 $O(2^nn^2)$ 状压 DP 计算，总复杂度 $O(2^nn^3)$。

# Solution2
考虑优化环外的行列式计算。

由 matrix-tree 我们知道，所求矩阵为 $D-A$，其中：（记 $\sum a=sum$）
$$
D_{i,j}=\begin{cases}
sum-(n-2)a_i&(i=j)\\
0&(i\ne j)
\end{cases}\\
A_{i,j}=\begin{cases}
0&(i=j)\\
a_i+a_j&(i\ne j)
\end{cases}
$$
由于是两个矩阵作差，我们稍微进行一下变形：
$$
D_{i,j}=\begin{cases}
sum-na_i&(i=j)\\
0&(i\ne j)
\end{cases}\\
A_{i,j}=a_i+a_j
$$
这样做的好处是 $\operatorname{rank}(A)\le2$，方便后续的行列式计算。

下一步我们回归初心，考察行列式原本的式子：
$$
\begin{aligned}
\det(D-A)&=\sum\limits_p(-1)^{\pi(p)}\prod\limits_i(D_{i,p_i}-A_{i,p_i})\\
&=\sum\limits_p(-1)^{\pi(p)}\sum_{\substack{S_1\cup S_2=S\\S_1\cap S_2=\varnothing}}\prod\limits_{i\in S_1}D_{i,p_i}\prod_{i\in S_2}(-A_{i,p_i})\\
&=\sum_{\substack{S_1\cup S_2=S\\S_1\cap S_2=\varnothing}}\sum\limits_p(-1)^{\pi'(p)}\det(D')\det(-A')
\end{aligned}
$$
其中第二行使用了乘法分配律，第三行交换了求和顺序，$\pi'(p)$ 表示排列 $p$ 中的 $S_1,S_2$ 间的逆序对数，$D'$ 表示保留 $D$ 中 $S_1$ 行的矩阵，$-A'$ 表示保留 $-A$ 中 $S_2$ 行的矩阵。  
根据 $\operatorname{rank}(A)\le2$ 可知，当 $|S_2|>2$ 时，$\det(-A')=0$，因此我们只需按照 $|S_2|=0,1,2$ 分讨。

$$
\begin{aligned}
\det(D-A)&=\prod_iD_{i,i}&(|S_2|=0)\\
&+\sum_x(-A_{x,x})\prod_{i\ne x}D_{i,i}&(|S_2|=1)\\
&+\sum_{x<y}(A_{x,x}A_{y,y}-A_{x,y}A_{y,x})\prod_{i\ne x,y}D_{i,i}&(|S_2|=2)
\end{aligned}
$$
把 $A,D$ 用 $a,sum$ 表示：
$$
\begin{aligned}
\det(D-A)&=\prod_i(sum-na_i)&(|S_2|=0)\\
&-2\sum_xa_x\prod_{i\ne x}(sum-na_i)&(|S_2|=1)\\
&+\sum_{x<y}(2a_xa_y-a_x^2-a_y^2)\prod_{i\ne x,y}(sum-na_i)&(|S_2|=2)
\end{aligned}
$$

枚举 $x,y$，求行列式复杂度降至 $n^2$，总复杂度 $O(2^nn^2)$。

# Solution3
行列式的部分先告一段落，现在的瓶颈在于 $O(2^n)$ 枚举环。

状压 DP 没什么前途，考虑换做法。我们知道，环上点的贡献为 $\prod_{i=1}^n(a_i+a_{i+1})$，继续乘法分配律，贡献变为 $\sum k\times\prod_{i=1}^na_i^{0/1/2}$。设幂次为 $0,1,2$ 的数分别有 $x,y,x$ 个，满足 $2x+y=n$，大胆猜测只要 $(x,y)$ 一样，对应的系数 $k$ 也相等。接下来我们尝试计算 $k$ 的值。  
在每个括号选一个数，这个问题可以抽象为在环上定向，次数即对应着度数。这是标准的组合数学问题，度为 $1$ 的点只起到一个过渡作用。考虑先把度数为 $0,2$ 的点分别圆排列，然后并到一起，方案数为 $\frac{(x-1)!(x-1)!x}2=\frac{(x-1)!x!}2$，然后把度为 $1$ 的点插入进去，注意这里不是隔板，因为点是有标号的，方案数为 $(2x)^{\bar y}=\frac{(2x+y-1)!}{(2x-1)!}$，所以总方案为 $\frac{(x-1)!x!(2x+y-1)!}{2(2x-1)!}$。注意特判 $x=0$ 的情况。

会计算环上的贡献，就可以将 $O(2^n)$ 枚举变为 $O(n)$ 枚举了。具体的说，依次枚举每一个点，定义状态 $f_{i,x,y,z,t}$ 表示当前到第 $i$ 个点，环内度为 $0,1,2$ 点分别有 $x,y,z$ 个，$S_2$ 集合已经选了 $t$ 时的贡献。$i$ 可以滚动数组滚掉，转移是 $O(1)$ 的，总复杂度 $O(n^5)$。如果转移写得好，也可以省去 $t$ 这一维，改为 $f_{x,y,z,0/1/2}$ 表示 $S_2$ 的大小，复杂度 $O(n^4)$。

# Solution4
对行列式的那个式子也进行乘法分配律，不难发现每个数的幂次仍然为 $0/1/2$。这启发我们可以把环内和环外的状态并在一起。具体来说，设 $f_{x,y,z}$ 表示幂次有 $x$ 个 $0$，$y$ 个 $1$，$z$ 个 $2$ 时的转移系数。空间看似 $O(n^3)$，但是有 $x+y+z=n$，可以删去 $z$，实际空间为 $O(n^2)$。至于转移，我们可以先枚举环内的 $(x,y)$，再枚举多少个数选了 $sum \operatorname{or} na_i$。总复杂度 $O(n^3)$，可以通过。

## 关于卡常
虽然本题是 $O(n^3)$ 且 $n\le1000$，但由于其本身的超小常数~~和洛谷的少爷机~~，基本不会被卡，不过在本地或者其他 OJ 可能会被卡常。注意到枚举了环上的 $x,y$ 后，$x,y$ 作为组合数 $C(n,m)$ 的第二维频繁出现，而第一维不断更改，导致数组访问不连续。可以定义数组 $CC(n,m)=C(m,n)$ 避免这个问题。

## Code
```
#include<bits/stdc++.h>
using namespace std;
#define LL long long

const int N = 1010, mod = 998244353;
int n, a[N], f[N][N], g[N][N];//次数有i个0,j个1,k个2时的系数/满足次数要求的权值乘积 (i+j+k=n，删去k) 

LL ksm(LL x, LL y)
{
	LL res = 1;
	x %= mod;
	while(y)
	{
		if(y & 1) res = res * x % mod;
		y >>= 1;
		x = x * x % mod;
	}
	return res;
}

LL fac[N], inv[N], pw_n[N], pw_sum[N], C[N][N], CC[N][N];
void init()
{
	fac[0] = 1;
	for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;
	inv[n] = ksm(fac[n], mod - 2);
	for(int i = n - 1; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % mod;
	
	pw_n[0] = 1;
	for(int i = 1; i <= n; i++) pw_n[i] = pw_n[i - 1] * n % mod;
	LL t = 0;
	for(int i = 1; i <= n; i++) t += a[i];
	pw_sum[0] = 1, pw_sum[1] = (t %= mod);
	for(int i = 2; i <= n; i++) pw_sum[i] = pw_sum[i - 1] * t % mod;
	
	for(int i = 0; i <= n; i++)
	{
		C[i][0] = CC[0][i] = 1;
		for(int j = 1; j <= i; j++)
			(C[i][j] = C[i - 1][j - 1] + C[i - 1][j]) >= mod && (C[i][j] -= mod), CC[j][i] = C[i][j];
	}
}

int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	init();
	
	for(int i = 0; i <= n; i++)
		for(int j = max(3 - 2 * i, 0); j <= n - 2 * i; j++)
		{
			//构成环的方案数 
			int w = i ? fac[i] * fac[i - 1] % mod * fac[2 * i + j - 1] % mod * inv[2 * i - 1] % mod * inv[2] % mod : fac[j - 1];
			//|S|=0
			for(int a = 0, b = n - 2 * i - j; b >= 0; a++, b--)
				f[i + a][j + b] = (f[i + a][j + b] + CC[i][i + a] * CC[j][j + b] % mod * w % mod * pw_n[b] % mod * pw_sum[a]) % mod;
			//|S|=1
			for(int a = 0, b = n - 2 * i - j - 1; b >= 0; a++, b--)
				f[i + a][j + b + 1] = (f[i + a][j + b + 1] - 2 * CC[i][i + a] * CC[j][j + b] % mod * w % mod * pw_n[b] % mod * pw_sum[a] % mod * (j + b + 1) % mod + mod) % mod;
			//|S|=2
			for(int a = 0, b = n - 2 * i - j - 2; b >= 0; a++, b--)
			{
				int t = w * pw_n[b] % mod * pw_sum[a] % mod;
				f[i + a][j + b + 2] = (f[i + a][j + b + 2] + CC[i][i + a] * CC[j][j + b] % mod * t % mod * (j + b + 2) % mod * (j + b + 1)) % mod;
				f[i + a + 1][j + b] = (f[i + a + 1][j + b] - CC[i][i + a] * CC[j][j + b] % mod * t % mod * (i + a + 1) % mod * (i + 1) % mod + mod) % mod;
			}
		}
	
	g[0][0] = 1;
	for(int i = 1; i <= n; i++)
	{
		LL t1 = a[i], t2 = 1ll * a[i] * a[i] % mod;
		for(int j = i; ~j; j--)
			for(int k = i - j; ~k; k--)
				g[j][k] = (g[j][k] * t2 + (k ? g[j][k - 1] * t1 : 0) + (j ? g[j - 1][k] : 0)) % mod;
	}
	
	LL ans = 0;
	for(int i = 0; i <= n; i++)
		for(int j = 0; j <= n - i; j++)
			ans += 1ll * f[i][j] * g[i][j] % mod;
	cout << ans % mod << endl;
	return 0;
}
```

---

## 作者：JWRuixi (赞：2)

## P10881 「KDOI-07」能量场

### 题意

给定序列 $a_{1}, \dots, a_n$，建立完全图 $G(V, E)$ 满足连接 $i, j$ 两点的边的边权为 $a_i + a_j$。

定义联通子图 $G^\prime(V, E^\prime)$ 的权值为 $\prod\limits_{e \in E^\prime} w_e$，求 $G$ 的所有无重边自环的基环树的权值之和对 $998244353$ 取模的结果。

$n \le 1000$。

### 分析

这显然是生成树问题的一种，考虑用矩阵树定理解决。

#### 算法 I

我们考虑钦定一个集合 $S$ 为基环，那么将环缩为点之后就是标准的生成树问题了！具体的就是视为新建一个结点 $x$，视其 $a_x$ 为 $\sum\limits_{y \in S} a_y$。环的贡献可以考虑单独用简单 DP 求出。

这个算法的复杂度是 $\mathcal O(n^3 2^n)$。

#### 算法 II

考虑对计算矩阵行列式的部分进行优化。

首先观察矩阵形如 $(a_i + a_j)_{i, j}$，也就是说，如果用令第 $2, \dots, n$ 均减去第一行的话那么这 $n - 1$ 行每行的数均相等！所以该矩阵的秩不超过 $2$。

将行列式展开有 $|D - A| = \sum\limits_{p} (-1)^{\sigma(p)} \prod\limits_{i \le n} (D_{i, p_i} - A_{i, p_i})$。考虑到 $D_{i, p_i}$ 有值当且仅当 $i = p_i$，所以 $A$ 的贡献一定形如 $A$ 的一个子矩阵的行列式，那么对于大小超过 $2$ 的部分其贡献均为 $0$！就是说 $A$ 的贡献至多两项，有如下分类：	

- 大小为 $0$，贡献 $|D|$；
- 大小为 $1$，贡献为 $-\sum\limits_{i} A_{i, i} \prod\limits_{j \neq i} D_{j, j}$；
- 大小为 $2$，贡献为 $\sum\limits_{i, j} (A_{i, i}A_{j, j} - A_{i, j}A_{j, i}) \prod\limits_{k \neq i, k \neq j} D_{k, k}$。

计算行列式的复杂度降为 $\mathcal O(n^2)$，总复杂度将为 $\mathcal O(n^2 2^n)$。

参考代码：<https://pastebin.com/WhHkfm6i>。

#### 算法 III

我们发现目前的瓶颈在与枚举环并计算其贡献，我们不妨尝试对环拆贡献。容易发现环上每个点的贡献只能是 $a_i^0, a_i^1, a_i^2$，假设 DP 出了某一个环上有 $k_0$ 个 $a_i^0$，$k_1$ 个 $a_i^1$，$k_2$ 个 $a_i^2$ 的权值之和，那么我们就只用考虑计算这 $k_0 + k_1 + k_2$ 个点组成环的合法方案数。

首先需要满足 $k_0 = k_2$。我们可以将这个问题视为是给环上的边定向，被指向的点贡献到答案。可以这样组织：

- 将 $k_0$ 个点排成一个环，方案数 $\dfrac{(k_0 - 1)!}{2}$；
- 将 $k_1$ 个点依次插入，插入可以分为两类：这条边已经被定向和还未被定向，方案数分别为 $2$ 和 $1$；所以第 $i$ 个插入的点方案数为 $2k_0 + i - 1$，总方案数 $\dfrac{(2k_0 + k_1 - 1)!}{(2k_0 - 1)!}$；
- 将 $k_2$ 个点同时插入，不能插入到同一条边；由于 $k_0 = k_2$，所以这部分方案数 $k_2!$。

注意特判 $k_0 = 0$ 的情况。

这样我们就可以设计 $f_{i, j, k_0, k_1, k_2}$，表示考虑 $1, \dots, i$；还未钦定 $A$ 贡献/已经钦定了第一行（具体哪一行）/已经考虑完了 $A$ 的贡献；已经在环上加入了 $k_0, k_1, k_2$ 个点对应的权值的权值之和。转移考虑枚举当前是环上的点/$D_{i, i}$ 贡献/作为唯一一行贡献的 $A_{i, i}$/作为两行贡献的第一行。

复杂度 $\mathcal O(n^5)$。

参考代码：<https://pastebin.com/svk7Mgu7>。

#### 算法 IV

发现现在的瓶颈已经转移到了需要记录选的第一行是谁上，我们考虑拆开贡献：$A_{i, i}A_{j, j} - A_{i, j}A_{j, i} = 4a_ia_j - (a_i + a_j)^2 = 2a_ia_j - a_i^2 - a_j^2$。

这三种贡献，每一种单独都是好算的，所以拆开考虑，就可以只记录 $1/2/3$ 表示第一行分别选的是 $2a_i, a_i^2, 1$ 就行了，转移是 trivial 的。

复杂度 $\mathcal O(n^4)$。

参考代码：<https://pastebin.com/fqFw3H4b>。

#### 算法 V

发现现在制约我们的关键在于我们要分类是否在环上，我们尝试寻找环上下的点的共性。

考虑拆开 $D_{i, i} = na_i + \sum\limits_{j}a_j$，我们记 $S = \sum\limits_{i} a_i$，那么后面那一部分就是常数了，每一个点的贡献就一定是 $a_i^0, a_i^1, a_i^2$ 之一了，那么我们只需要给每个点钦定一个次数，然后在去考虑一组 $(k_0, k_1, k_2)$ 的组合方案就行了。

具体的我们可以枚举：

- $(k_0, k_1)$（$k_2 = k_0$），这部分 $\mathcal O(n^2)$；
- $A$ 的贡献选两行还是一行，对应的是哪种贡献，这部分 $\mathcal O(1)$；
- $D_{i, i}$ 中贡献为 $na_i$ 的数量，剩余的就是 $S$ 了，这部分 $\mathcal O(n)$。

我们将对应的系数乘起来，再乘上组合再一起的方案就是答案了，这部分需要一定量的分类讨论，建议仔细实现（~~或参考代码~~）。

注意到最开始 DP 的时候可以以 $k_0 + k_1 + k_2$ 分层，这样空间就是 $\mathcal O(n^2)$ 了！

时间复杂度 $\mathcal O(n^3)$，空间复杂度 $\mathcal O(n^2)$，常数较小不卡常。

## Code

完整代码：<https://pastebin.com/5rZTppBU>。

---

## 作者：Otomachi_Una_ (赞：0)

**【题目简述】**

完全图点有系数 $a_i$，每条边 $(i,j)$ 有边权 $a_i+a_j$。求所有生成基环树边权乘积的和。对 $998244353$ 取模。

$1\leq n\leq 1000$。

**【解题思路】**

首先考虑先把基环点缩到一起形成大点 $x$。然后剩下就是 matrix-tree。由于 matrix-tree 求生成树要去掉一行一列，我们直接去掉 $x$ 这个一行一列。不难发现剩余矩阵和原图的 $L$ 矩阵是一致的。

先考虑原图 $L=D-A$ 矩阵的性质，记 $s=\sum a_i$，不难发现：

$$
D_{i,j}=\begin{cases}(n-2)a_i+s&i=j\\0&i\neq j\end{cases}
$$

和

$$
A_{i,j}=\begin{cases}a_i+a_j&i\neq j\\0&i=j\end{cases}
$$

为了方便后续求解，我们给 $D,A$ 每个 $(i,i)$ 加上 $2a_i$。这样子的好处是 $\operatorname{rank}(A)\leq 2$ 且 $D$ 是个对角矩阵。

注意到：

$$
\begin{aligned}\det(L)&=\sum_{p}(-1)^{\pi(p)}\prod(D_{i,p_i}-A_{i,p_i})\\&=\sum_{p}(-1)^{\pi(p)}\sum_{S_1∩ S_2=[n],S_1∪S_2=\empty}\prod_{i\in S_1}D_{i,p_i}\prod_{i\in S_2}-A_{i,p_i}\end{aligned}
$$
注意到 $D$ 是一个对角矩阵，于是对 $i\in S_1$ 有 $p_i=i$。有由于 $\operatorname{rank}(A)\leq 2$ 所以 $|S_2|\leq 2$。

记 $d_i=D_{i,i}$。于是，我们来枚举 $|S_2|$：

- $|S_2|=0$，则原式为 $\prod d_i$；
- $|S_2|=\{x\}$，则原式为 $-a_x\prod_{i\neq x}d_i$；
- $|S_2|=\{x,y\}$，则原式为 $(2a_xa_y-a_x^2-a_y^2)\prod_{i\neq x,y}d_i$。

我们再来看环的情况，不妨设环上点的权值为 $b_1,b_2,\dots,b_m$。答案肯定形如若干 $k\prod b_i^{\alpha_i}$ 的求和。显然，$\alpha_i\in\{0,1,2\}$。考虑设其中有 $x$ 个 $0$，$y$ 个 $1$，$x$ 个 $2$。为了求 $k$，那么考虑来计数环的个数。

不难发现 $1$ 仅仅作为过度点，我们考虑最后插入，然后 $0,2$ 必然交替出现，方案数 $\dfrac{(x!)^2}{2x}$，下面的 $2$ 是因为环可以反转。然后填入 $y$ 个 $1$，方案数是 $(2x)(2x+1)\dots(2x+y-1)=\dfrac{(2x+y-1)!}{(2x-1)!}$。所以总的方案数是 $\dfrac{(x!)^2(2x+y-1)!}{2x(2x-1)!}$。

你发现环形如若干 $k\prod b_i^{\alpha_i}$ 的求和（$\alpha_i\in\{0,1,2\}$），你观察树也发现是形如若干 $k\prod a_i^{\alpha_i}$ 的求和（$\alpha_i\in\{0,1,2\}$）。于是我们可以搞个 $f_{i,j,k}$ 表示一共有 $i$ 个 $\alpha=0$，$j$ 个 $\alpha=1$，$k$ 个 $\alpha=2$。由于 $i+j+k=n$ 可以压掉一维。然后算这个东西的系数也可以通过简单的求和算出。

时间复杂度：$\mathcal O(n^3)$。

**【参考代码】**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0)); 
const int MAXN=1005;
const int MOD=998244353;
const int inv2=(MOD+1)/2;
int n;
ll a[MAXN],s,f[2][MAXN][MAXN],g[MAXN][MAXN];// g 系数
ll fac[MAXN],inf[MAXN],pws[MAXN],pwn[MAXN],C[MAXN][MAXN];
ll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}
void add(ll &x,ll y){x=(x+y+MOD)%MOD;}
int main(){
	ios::sync_with_stdio(false);
	// freopen("Otomachi_Una.in","r",stdin);
	// freopen("Otomachi_Una.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],add(s,a[i]);
	pws[0]=pwn[0]=1;
	for(int i=1;i<=n;i++) pws[i]=pws[i-1]*s%MOD,pwn[i]=pwn[i-1]*n%MOD;
	inf[0]=fac[0]=1;
	for(int i=0;i<=n;i++){
		C[0][i]=1;
		for(int j=1;j<=i;j++) C[j][i]=(C[j][i-1]+C[j-1][i-1])%MOD;
	}
	for(int i=1;i<MAXN;i++) inf[i]=ksm(fac[i]=fac[i-1]*i%MOD,MOD-2);
	for(int x=0;2*x<=n;x++) for(int y=0;2*x+y<=n;y++){
		if(2*x+y<=2) continue;
		ll cyc=(x==0?fac[y-1]:fac[x]*fac[x-1]%MOD*fac[2*x+y-1]%MOD
			*inv2%MOD*inf[2*x-1]%MOD);
		for(int i=0;i+2*x+y<=n;i++) 
			add(g[y+i][x],cyc*pwn[i]%MOD*pws[n-2*x-y-i]%MOD*
				C[x][n-x-y-i]%MOD*C[y][y+i]);
		for(int i=1;i+2*x+y<=n;i++)
			add(g[y+i][x],-2*cyc*pwn[i-1]%MOD*pws[n-2*x-y-i]%MOD
				*C[x][n-x-y-i]%MOD*i%MOD*C[y][y+i]);
		for(int i=2;i+2*x+y<=n;i++){
			add(g[y+i][x],2*cyc*pwn[i-2]%MOD*pws[n-2*x-y-i]%MOD*
				C[x][n-x-y-i]%MOD*C[y][y+i]%MOD*C[2][i]);
		}
		for(int i=0;i+2*x+y+2<=n;i++){
			add(g[y+i][x+1],-cyc*pwn[i]%MOD*pws[n-2*x-y-i-2]%MOD*
				C[x][n-x-y-i-1]%MOD*C[y][y+i]%MOD*(x+1)%MOD*(n-2*x-y-i-1));
		}
	}
	f[0][0][0]=1;
	int o=0;
	for(int i=1;i<=n;i++){
		o^=1;
		memset(f[o],0,sizeof(f[o]));
		for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++) if(f[!o][j][k]){
			add(f[o][j][k],f[!o][j][k]);
			add(f[o][j+1][k],f[!o][j][k]*a[i]);
			add(f[o][j][k+1],f[!o][j][k]*a[i]%MOD*a[i]);
		}
	}
	ll ans=0;
	for(int i=0;i<=n;i++) for(int j=0;j<=n;j++){
		add(ans,f[o][i][j]*g[i][j]);
	}
	cout<<(ans%MOD+MOD)%MOD<<'\n';
	cerr<<"Running time: "<<1.*clock()/CLOCKS_PER_SEC<<'\n';
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10881)

**题目大意**

> 给定 $n$ 个点的完全图，每个点有点权 $a_i$，$i,j$ 之间的边权为 $a_i+a_j$，求图上所有生成的基环树的边权乘积之和。
>
> 数据范围：$n\le 1000$。

**思路分析**

先从树上边权乘积之和开始，这显然是一个矩阵树定理，我们所求就是 $\det(D-G)$，其中 $D_{i,i}=A+na_i$，其中 $A=\sum a_i$，$G_{i,j}=a_i+a_j$。

暴力带入得到：$\det(D-G)=\sum_p(-1)^{\mathrm{inv}(p)}\prod(D_{i,p_i}-G_{i,p_i})$。

考虑暴力拆开后面的括号，即把原矩阵分成两部分分别求出 $D$ 上和 $G$ 上的行列式，又因为 $\mathrm{rank}(G)\le 2$，因此我们只要考虑选择 $\le 2$ 个 $G$ 中行的情况。

又因为 $D$ 时对角线矩阵，因此在 $D$ 上的行列式只有全取对角线时有贡献，那么原式可以化成：
$$
\det(D-G)=\prod_{i}D_{i,i}-\sum_iG_{i,i}\prod_{j\ne i}D_{j,j}+\sum_{i,j}(G_{i,i}G_{j,j}-G_{i,j}G_{j,i})\prod_{k\ne i,k\ne j} D_{k,k}
$$
记 $A_i=A+na_i$，进一步化简就是：
$$
\det(D-G)=\prod_{i}A_i-2\sum_ia_i\prod_{j\ne i}A_j+\sum_{i,j}(2a_ia_j-a_i^2-a_j^2)\prod_{k\ne i,k\ne j} A_k
$$
此时我们就有了一个较好的表达式来计算矩阵行列式。

然后考虑基环树的情况，我们可以暴力枚举一个环，然后把环缩成一个点后求矩阵树定理的行列式。

先考虑如果确定一个环上的点集 $S$ 后，如何求出每种情况下环上边权乘积之和，即 $\sum_p\prod_i (a_i+a_{p_i})$。

考虑经典做法，拆系数，即把答案表示成 $\prod a_i^{c_i}$ 的线性组合，对每组 $\{c_i\}$ 算出对应的系数，查询时只需要求出每种给 $a_i$ 分配 $c_i$ 的方案权值和即可。

容易发现这个式子中每个 $a_i$ 出现 $2$ 次，那么 $c_i\in\{0,1,2\}$ 且 $\sum c_i=|S|$，则 $c_i=0$ 的元素和 $c_i=2$ 的元素一样多。

不妨枚举有 $x$ 个 $c_i=0$ 的元素，$y$ 个 $c_i=1$ 的元素，我们要求的就是分配方案数，可以把这个问题看成给环定向，$c_i$ 表示出度。

我们可以先插入 $c_i=0$ 和 $c_i=2$ 的点，这部分方案数 $\dfrac{x!^2}{x}$，然后插入 $c_i=1$ 的点，可以插在当前环上任意两点中间，会被两侧的点自然定向，方案数 $(2x)^{\overline y}$，总方案数 $\dfrac{x!^2\times (2x+y-1)!}{(2x)!}$。

然后考虑原问题，我们现在要处理的就是 $\det(D-G)$ 这部分的贡献。

首先矩阵树定理要在原矩阵上去掉一行一列，自然的想法就是把环缩成的虚点对应的行列给删掉。

然后观察 $\det(D-G)$ 的形式，可以用类似的手法考虑拆系数，再一次发现这部分每个 $a_i$ 最终的系数 $\in\{0,1,2\}$，枚举是这几种情况中的哪一种，也不难算出系数。

那么我们可以把两部分合起来，综合算出 $f_{x,y}$ 表示 $x$ 个 $c_i=0$，$y$ 个 $c_i=1$，$n-x-y$ 个 $c_i=2$ 时对答案的贡献系数。

具体我们依然先枚举环上 $c_i=0,1$ 的点数 $x,y$，剩余不在环上的点只有 $n-2x-y$ 个，分讨属于上式的哪个部分，需要枚举的只有后面的 $\prod$ 号上取了几个 $A$ 和个 $na_i$，总的枚举量是三次方的。

时间复杂度 $\mathcal O(n^3)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1005,MOD=998244353;
inline void add(ll&x,const ll&y) { x=(x+y)%MOD; }
ll ksm(ll a,ll b=MOD-2) { ll s=1; for(;b;a=a*a%MOD,b>>=1) if(b&1) s=s*a%MOD; return s; }
int n;
ll a[N],A,pwn[N],pwA[N],fac[N],ifac[N],C[N][N],rC[N][N];
ll f[N][N],g[N][N];
//f: coef, g: dp
signed main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]),A=(A+a[i])%MOD;
	pwn[0]=pwA[0]=ifac[0]=fac[0]=1;
	for(int i=1;i<=n;++i) {
		pwn[i]=pwn[i-1]*n%MOD,pwA[i]=pwA[i-1]*A%MOD;
		ifac[i]=ksm(fac[i]=fac[i-1]*i%MOD);
	}
	for(int i=0;i<=n;++i) {
		for(int j=C[i][0]=1;j<=i;++j) {
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;
		}
		for(int j=0;j<=i;++j) rC[j][i]=C[i][j];
	}
	for(int i=0;i<=n;++i) for(int j=max(3-2*i,0);2*i+j<=n;++j) {
		//cycle with i a^0/a^2 and j a^1
		int c=n-2*i-j; ll *bi=rC[i],*bj=rC[j];
		ll w=fac[i]*fac[i]%MOD*ifac[2*i]%MOD*fac[2*i+j-1]%MOD;
		for(int x=0,y=c;y>=0;++x,--y) { //|S|=0, x a^0, y a^1
			add(f[i+x][j+y],w*bi[i+x]%MOD*bj[j+y]%MOD*pwA[x]%MOD*pwn[y]);
		}
		for(int x=0,y=c-1;y>=0;++x,--y) { //|S|=1, x a^0, y a^1 in Prod
			add(f[i+x][j+y+1],2*(MOD-w)*(j+y+1)%MOD*bi[i+x]%MOD*bj[j+y]%MOD*pwA[x]%MOD*pwn[y]%MOD);
		}
		for(int x=0,y=c-2;y>=0;++x,--y) { //|S|=2, x a^0, y a^1 in Prod
			ll z=w*bi[i+x]%MOD*bj[j+y]%MOD*pwA[x]%MOD*pwn[y]%MOD;
			add(f[i+x][j+y+2],z*(j+y+2)*(j+y+1));
			add(f[i+x+1][j+y],(MOD-z)*(i+x+1)*(i+1));
		}
	}
	g[0][0]=1;
	for(int o=1;o<=n;++o) {
		ll w1=a[o],w2=a[o]*a[o]%MOD;
		for(int i=o;i>=0;--i) for(int j=o-i;j>=0;--j) {
			g[i][j]=(g[i][j]*w2+(i?g[i-1][j]:0)+(j?g[i][j-1]*w1:0))%MOD;
		}
	}
	ll ans=0;
	for(int i=0;i<=n;++i) for(int j=0;i+j<=n;++j) ans=(ans+f[i][j]*g[i][j])%MOD;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Xseventh (赞：0)

题目要求的是生成树计数，但是是基环树。  

考虑使用矩阵树定理。  
定义矩阵 $D$ 和 $A$，其中 $D_{i,i} = \sum_{j=1}^n a_i+a_j = na_i + \sum_{j=1}^na_j$，$A_{i,j}=a_i+a_j$。显然如果我们求的是正常的生成树，则 $det(D-A)$ 即为答案。  

注意到基环树的环缩起来也是一棵树。即对于基环树上环中点集 $S$，在矩阵 $D - A$ 上删除与 $S$ 有关的行列并求出行列式，本质与将环缩为一个点，只考虑环外贡献的答案相同。  

因此我们有了基环树计数的初步方法，即枚举环上集合 $S$，将环上贡献与环外贡献分开计算，环外贡献使用矩阵树定理，环内可以直接状压打牌解决，时间复杂度 $O(2^nn^3)$。

矩阵 $D - A$ 本身的生成具有一定性质，考虑是否可以利用。对于矩阵 $A$，将其第 $2$ 到 $n$ 行都减去第 $1$ 行，即其原本的值是这样：  

$
	\begin{matrix}
   a_1+a_1 & a_1+a_2 & a_1+a_3 & \dots & a_1+a_n \\
   a_2+a_1 & a_2+a_2 & a_2+a_3 & \dots & a_2+a_n \\
   a_3+a_1 & a_3+a_2 & a_3+a_3 & \dots & a_3+a_n \\
   \vdots & \vdots & \vdots & \vdots & \vdots \\
   a_n+a_1 & a_n+a_2 & a_n+a_3 & \dots & a_n+a_n \\
\end{matrix}
$  
操作后变为：  

$
	\begin{matrix}
   a_1+a_1 & a_1+a_2 & a_1+a_3 & \dots & a_1+a_n \\
   a_2-a_1 & a_2-a_1 & a_2-a_1 & \dots & a_2-a_1 \\
   a_3-a_1 & a_3-a_1 & a_3-a_1 & \dots & a_3-a_1 \\
   \vdots & \vdots & \vdots & \vdots & \vdots \\
   a_n-a_1 & a_n-a_1 & a_n-a_1 & \dots & a_n-a_1 \\
\end{matrix}
$  

发现这几行每行值都相等，即矩阵 $A$ 的秩至多为 $2$。  

把行列式按照定义展开，则 $det(D-A) = \sum_p(-1)^{inv(p)} \prod_{i=1}^n(D-A)_{i,p_i} = \sum_p(-1)^{inv(p)} \prod_{i=1}^n(D_{i,p_i} - A_{i,p_i})$。显然 $D_{i,p_i}$ 和 $A_{i,p_i}$ 中必然有一个为 $0$，又因 $i=p_i$ 时 $D_{i,p_i}$ 才有贡献，则矩阵 $A$ 的贡献就类似于其子矩阵的行列式。之前已知 $A$ 的秩至多为 $2$，那么 $A$ 有贡献时子矩阵大小必然不超过 $2$。  

考虑直接枚举这个子矩阵大小 $k$，情况如下：  
$k=0$时，$det(D - A) = \prod_{i=1}^n D_{i,i}$。  
$k=1$时，$det(D - A) = \sum_p(-1)^{inv(p)}(-A_{u,p_u})\prod_{i=1,i \ne u}^n D_{i,p_i} = (-2a_u)\prod_{i=1,i \ne u}^n D_{i,i}$。  
$k=2$时，$det(D - A) = (-a_u^2 + 2a_ua_v - a_v^2)\prod_{i=1,i \ne u, i \ne v}^n D_{i,i}$。 

于是我们学会了 $O(n^2)$ 计算行列式，非常高级。

考虑优化指数级复杂度的部分，即对于环的集合的枚举。令当前环上点集为 $S$，环内贡献为 $\sum_p \prod_{i=1}^{|S|} (a_{p_i} + a_{p_{i+1}})$，此处 $p$ 的含义是环上点的一种排列，$p_{i+1}$ 若超出范围则首尾相接。考虑到 $a_{p_i}$ 只会和与自己相邻的点同时出现，则最多出现两次。对式子直接展开，则 $a_{p_i}$ 最多出现二次幂，即式子中只会出现 $a_{p_i}^0$，$a_{p_i}^1$，$a_{p_i}^2$。  

针对此性质进行优化。我们直接用展开的式子进行计算，即将 $\sum_p \prod_{i=1}^{|S|} (a_{p_i} + a_{p_{i+1}})$ 展开后若干个形式为 $\prod_{i=1}^{|S|}a_{p_i}^{t_i}$ 的结构拿来计算，其中 $t_i$ 的值为 $0$，$1$ 或者 $2$。换言之，我们直接把一个环拆做多份贡献。那么对于一个 $\prod_{i=1}^{|S|}a_{p_i}^{t_i}$ 形式的贡献，可能会有多种环的形态满足可以跑出这样的贡献，假设 $t_i=0$ 的 $i$ 有 $a$ 个，假设 $t_i=1$ 的 $i$ 有 $b$ 个，假设 $t_i=2$ 的 $i$ 有 $c$ 个，我们要求出能够满足以上三个条件的环的数量。  

此时编号没有意义，我们只需要使用 $a$，$b$，$c$ 进行计算。回到原本环上 $\sum_p \prod_{i=1}^{|S|} (a_{p_i} + a_{p_{i+1}})$ 的模型，可以视作对环上每条边进行定向，最后每个点 $i$ 的入度即对应转化后点 $i$ 的指数 $t_i$。  

问题转化为已知 $a$ 个点入度为 $0$，$b$ 个点入度为 $1$，$c$ 个点入度为 $2$，求可以构造出的环的数量。  

显然环上的形态是度数为 $0$ 的点和度数为 $2$ 的点交替出现，中间间隔若干个度数为 $1$ 的点，则必须满足 $a=c$，否则方案数为 $0$。  

先将度数为 $0$ 的点和度数为 $2$ 的点交替放，方案数为 $\frac{(a-1)!a!}{2}$。再将度数为 $1$ 的点随意插入，总方案数为 $\frac{(a-1)!a!(2a+b-1)!}{2(2a-1)!}$，但是特判 $a = 0$ 的情况，计算是简单的。  

考虑打牌，定义状态 $dp_{i,j,a,b,c}$ 表示当前遍历到第 $i$ 个点，度数为 $0$，$1$，$2$ 的分别有 $a$，$b$，$c$ 个，基环树上环内 $A$ 矩阵没有贡献，贡献了一个 $j$ 或者贡献完了的方案数，还要考虑优化。  

对于环内部分，状态中的 $j$ 实际的形态是 $(-a_u^2 + 2a_ua_v - a_v^2)$ 的。当枚举到 $u$ 时，实际可以将 $u$ 和 $v$ 独立开来直接计入答案而不是再开一维。即先加入 $a_u^2$ 的贡献，对于 $2a_u$ 的部分另开一倍空间记录下来同步更新，枚举到 $v$ 时再拿来计算并累加。时间复杂度变为 $O(n^4)$。  

继续优化。回到 $D_{i,i} = \sum_{j=1}^n a_i+a_j = na_i + \sum_{j=1}^na_j$ 的定义上。我们在计算中多次使用了 $D_{i,i}$，环上的这一部分限制死了我们 $a$，$b$，$c$ 的状态是去不掉一个的。考虑将 $\sum_{j=1}^na_j$ 视作常数 $r$，则 $D_{i,i}=r+na_i$，即 $\prod_{i=1}^nD_{i,i} =\prod_{i=1}^n (r+na_i)$。可以发现我们能够用前面将环的贡献拆开的方法来拆这个式子的贡献，其中 $a_i$ 的幂次最大为 $1$。干脆将 $(-a_u^2 + 2a_ua_v - a_v^2)$ 这一部分也拆出来，无非就是 $a_i$ 的最大幂次变为了 $2$，似乎也可以用同种方法算。  

尝试将环上这部分贡献直接并入 $a$，$b$，$c$ 中，这样我们又可以省下一维状态。  
重新定义状态 $dp_{i,a,b,c}$ 表示已遍历前 $i$ 个点，其中部分可能在环内，部分可能在环外，贡献形式为 $a_i^0$ 的有 $a$ 个，贡献形式为 $a_i^1$ 的有 $b$ 个，贡献形式为 $a_i^2$ 的有 $c$ 个，此时权值相乘的值之和。由于此时 $a+b+c=i$，去除一维 $c$。显然不考虑附带的常数，将环内部分拆开乘上环外部分是没有问题的，不过这要求我们对于环内和环外的多种附带权值方案进行额外的计算。即计算一个数组可以表示已知 $a$，$b$，$c$ 时，将这三种贡献的形式分配至环内或是环外，所有这样的方案附带的权值之和。  

定义 $f_{i,j,k}$ 表示 $i$ 个数贡献形式为 $a_i^0$，$j$ 个数贡献形式为 $a_i^1$，$k$ 个数贡献形式为 $a_i^2$，环内环外的所有系数。同理，$i + j + k = n$，去除一维 $k$。  
具体的计算步骤上，先花 $O(n^2)$ 的复杂度枚举**有向环上**度为 $0$ 和 $1$ 的点数 $x$ 与 $y$，显然度为 $2$ 的点数 $z=x$；再枚举矩阵 $A$ 贡献了 $0$ 个，$1$ 个，还是 $2$ 个数；于是我们可以算出剩下在环外集合 $T$ 的大小以及具体的幂次分布（显然只有 $0$ 次和 $1$ 次），最后枚举集合 $T$ 中 $1$ 次幂的数量，即 $na_i$，就可以算出具体附带的权值。

$dp_{i,a,b}$ 可以滚动，最后的空间复杂度为 $O(n^2)$，时间复杂度为 $O(n^3)$，但是究极小常。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
const int Mod = 998244353;

int n, r;
int a[N], fact[N], infact[N];
int C[N][N], PowN[N], Powr[N];
int dp[2][N][N], f[N][N]; 

int Ad(int a, int b) {
	return (a + b >= Mod ? a + b - Mod : a + b);
}

int qmi(int a, int b, int p) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % p;
		a = 1ll * a * a % p;
		b >>= 1;
	}
	return res;
}

void init() {
	C[0][0] = 1;
	for (int i = 1; i < N; i ++) {
		C[i][0] = 1;
		for (int j = 1; j <= i; j ++) C[i][j] = Ad(C[i - 1][j], C[i - 1][j - 1]);
	}
	PowN[0] = 1;
	for (int i = 1; i <= n; i ++) PowN[i] = 1ll * PowN[i - 1] * n % Mod;
	Powr[0] = 1;
	for (int i = 1; i <= n; i ++) Powr[i] = 1ll * Powr[i - 1] * r % Mod;
	fact[0] = 1;
	for (int i = 1; i <= n; i ++) fact[i] = 1ll * fact[i - 1] * i % Mod;
	infact[n] = qmi(fact[n], Mod - 2, Mod);
	for (int i = n; i >= 1; i --) infact[i - 1] = 1ll * infact[i] * i % Mod;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++) scanf("%d", &a[i]), r = Ad(r, a[i]); 
	
	init();
	
	dp[0][0][0] = 1;
	for (int i = 1; i <= n; i ++) {
		for (int A = 0; A < i; A ++) {
			for (int B = 0; A + B < i; B ++) {
				int F = dp[(i - 1) & 1][A][B], w0 = 1, w1 = a[i], w2 = 1ll * a[i] * a[i] % Mod;
				dp[i & 1][A + 1][B] = Ad(dp[i & 1][A + 1][B], F * w0);
				dp[i & 1][A][B + 1] = Ad(dp[i & 1][A][B + 1], 1ll * F * w1 % Mod);
				dp[i & 1][A][B] = Ad(dp[i & 1][A][B], 1ll * F * w2 % Mod);
				dp[(i - 1) & 1][A][B] = 0;
			}
		}
	}
	
	for (int i = 0; i <= n; i ++) {
		for (int j = 0; i + j + i <= n; j ++) {
			int Cir = i + j + i;
			if (Cir < 3) continue;
			for (int A = 0; A <= 3; A ++) {
				int I = i, J = j, K = i, Pre = 1;
				
				if (I == 0) Pre = fact[J - 1];
				else Pre = 1ll * fact[I - 1] * fact[I] % Mod * fact[I * 2 + J - 1] % Mod * infact[2] % Mod * infact[2 * I - 1] % Mod;
				
				if (A == 1) J ++, Pre = 1ll * Pre * (Mod - 2) % Mod;
				if (A == 2) I ++, K ++, Pre = 1ll * Pre * (Mod - 1) % Mod;
				if (A == 3) J += 2, Pre = 1ll * Pre * 2 % Mod;
				
				if (I + J + K > n) continue;
				
				for (int T = 0; T <= n - (I + J + K); T ++) {
					int t0 = T, t1 = n - (I + J + K) - T;
					int G = 1ll * Pre * Powr[t0] % Mod * PowN[t1] % Mod;
					int C_ = 1ll * C[i + t0][i] * C[j + t1][j] % Mod;
					
					if (A == 0) f[I + t0][J + t1] = Ad(f[I + t0][J + t1], 1ll * G * C_ % Mod);
					if (A == 1) f[I + t0][J + t1] = Ad(f[I + t0][J + t1], 1ll * G * C_ % Mod * (J + t1) % Mod);
					if (A == 2) f[I + t0][J + t1] = Ad(f[I + t0][J + t1], 1ll * G * C_ % Mod * (I + t0) % Mod * K % Mod);
					if (A == 3) f[I + t0][J + t1] = Ad(f[I + t0][J + t1], 1ll * G * C_ % Mod * C[J + t1][2] % Mod);
				}
			}
		}
	}
	
	int ans = 0;
	for (int A = 0; A <= n; A ++)
		for (int B = 0; A + B <= n; B ++)
			ans = Ad(ans, 1ll * dp[n & 1][A][B] * f[A][B] % Mod);
	
	printf("%d", ans);
	
	return 0;
}
```

---


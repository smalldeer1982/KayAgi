# [COTS 2021] 菜 Jelo

## 题目背景

译自 [Izborne Pripreme 2021 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2021/) D1T1。$\texttt{1s,0.5G}$。

由于本题特殊的 SPJ，将本题的 TL 和 ML 分别改为 $\texttt{10s,2G}$。但是对于选手程序，本题的时空限制和原题相同。

如果使用压缩包上传答案：将文件分别命名为 $\texttt{jelo-1.out}\sim \texttt{jelo-5.out}$。

## 题目描述

给定正偶数 $N$。构造一个最大的集合 $S\subseteq \{0,1,\cdots,2^{N}-1\}$，使得 $\left|\bigcup_{i,j\in S,i\lt j} \{i\oplus j\}\right|={|S|\choose 2}$ 。换言之，在 $S$ 中任意选定 $(a,b),(c,d)$（$a,b,c,d\in S$，$a\lt b$，$c\lt d$，$(a,b)\neq (c,d)$），都有 $a\oplus b\neq c\oplus d$ 成立。

其中 $\oplus$ 表示按位异或运算。

## 说明/提示


对于 $100\%$ 的数据，保证 $1\le N\le 30$。

本题共有 $5$ 个测试点，每个测试点有三个评分参数 $t_1,t_2,t_3$，记 $t=|S|$，则得分计算方式为：

$$\mathrm{score}(t)=
\begin{cases}
2.4\cdot \frac{t}{t_1} & t\in [0,t_1) \\
2.4+3.6\cdot \frac{t-t_1}{t_2-t_1} & t\in [t_1,t_2) \\
6+12\cdot \frac{t-t_2}{t_3-t_2} & t\in [t_2,t_3) \\
20 & t\in [t_3,2^N] \\
\end{cases}$$

| 测试点编号 | $N=$ | $t_1=$   | $t_2=$   | $t_3=$    | 得分 |  
| :--: | :--: | :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 18 $    | $ 267 $   | $ 283 $   | $ 512 $    | $ 20 $   |  
| $ 2 $    | $ 20 $    | $ 444 $   | $ 462 $   | $ 1024 $   | $ 20 $   |  
| $ 3 $    | $ 26 $    | $ 2019 $  | $ 2040 $  | $ 8192 $   | $ 20 $   |  
| $ 4 $    | $ 28 $    | $ 3295 $  | $ 3327 $  | $ 16384 $  | $ 20 $   |  
| $ 5 $    | $ 30 $    | $ 5377 $  | $ 5430 $  | $ 32768 $  | $ 20 $   |

【提示】请注意代码长度限制。

## 样例 #1

### 输入

```
4```

### 输出

```
6
0 1 2 4 8 15```

# 题解

## 作者：Rainbow_qwq (赞：15)

假设有 $2n$ 位，考虑把每个数分成前 $n$ 位和后 $n$ 位。

先构造一个 $2^n$ 元有乘法、加法的有限域，这个可以通过找一个不可约多项式构造，见 [P3923](https://www.luogu.com.cn/problem/P3923)。

然后对于 $x=[0,2^n-1]$，前 $n$ 位填 $x$，后 $n$ 位填 $x^3$ 在有限域运算下的值，构造出一个 $2n$ 位的数。

这样如果两个 pair  $(a,b),(c,d)$ 的 xor 相等，就需要满足 $a+b=c+d $，$a^3+b^3=c^3+d^3$。

由于在该 $2^n$ 有限域下加法等同与 xor，可以推出 $a^3+b^3=c^3+d^3  \to ab(a+b) = cd(c+d) \to ab=cd$。

由于同时有 $ab=cd$ 和 $a+b=c+d$，则 $\{a,b\}$ 和 $\{c,d\}$ 都是方程 $x^2-(a+b)x+ab$ 的解，而这个方程只有至多两个解，也就说明 $\{a,b\} = \{c,d\}$。

那么这样构造就不会有两个不同的 pair 的 xor 相同，并且构造了 $2^n$ 个数。

```cpp
// what is matter? never mind.
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(int i=(a);i>=(b);--i)
//#define int long long
using namespace std;

int mod;

#define fi first
#define se second
#define pb push_back
#define mkp make_pair
typedef pair<int,int>pii;
typedef vector<int>vi;

#define maxn 55
#define inf 0x3f3f3f3f
#define poly vector<modint>

int n,p,k;

poly operator +(poly a,poly b){
	int n=max(a.size(),b.size());a.resize(n),b.resize(n);
	For(i,0,n-1)a[i]+=b[i];return a;
}
poly operator -(poly a,poly b){
	int n=max(a.size(),b.size());a.resize(n),b.resize(n);
	For(i,0,n-1)a[i]-=b[i];return a;
}
poly operator *(poly a,modint b){
	int n=a.size();
	For(i,0,n-1)a[i]*=b;return a;
} 
poly operator *(poly a,poly b){
	if(!a.size()||!b.size())return {};
	poly c(a.size()+b.size()-1,0);
	for(int i=0;i<a.size();++i)
		for(int j=0;j<b.size();++j)
			c[i+j]+=a[i]*b[j];
	return c;
}

poly operator %(poly a,poly b){
	while(b.back().x==0)b.pop_back();
	while(1){
		while(a.size()&&a.back().x==0)a.pop_back();
		if(a.size()<b.size())return a;
		int t=a.size()-b.size();
		modint w=a.back()/b.back();
		For(i,0,(int)b.size()-1)a[i+t]-=b[i]*w;
		assert(a.back().x==0);
	}
}

void init(poly &a,int x){
	if(a.size()<k)a.resize(k);
	For(i,0,k-1)a[i]=x%p,x/=p;
}
int get(poly a){
	if(a.size()<k)a.resize(k);
	int res=0;
	Rep(i,k-1,0)res=res*p+a[i].x;
	return res;
}

bool chk(poly a){
	poly b;
	For(i,p,n-1){
		init(b,i);
		poly c=a%b;
		if(!c.size())return 0;
	}
	return 1;
}

poly qwq(){
	poly a(k+1); a[k]=1;
	For(i,1,n-1){
		init(a,i);
		if(chk(a))return a;
	}
	assert(0);
}

int pri[maxn],pc[maxn],tot;
void fj(int n){
	For(i,2,n)
		if(n%i==0){
			pri[++tot]=i;
			while(n%i==0)n/=i,++pc[tot];
		}
}

signed main()
{
	n=1<<read();
	k=0;
	while((1<<(k*2))<n)k++;
	n=(1<<k);
	mod=p=2;
	poly a;
	a=qwq();//puts("QWQWQ");
//	for(auto x:a)cout<<x.x<<' ';puts(" A");
	vi o;
	int s=(1<<k);
	For(i,0,(1<<k)-1){
		poly x; init(x,i);
		poly y=x*x%a*x%a;
		int out=get(y);
		out|=(i<<k);
		o.pb(out);
	}
	cout<<o.size()<<"\n";
	for(int x:o)cout<<x<<" \n"[x==o.back()];
	return 0;
}
// (1 0 1) % 
```

---

## 作者：littlez_meow (赞：2)

### 题意

构造一个大小为 $2^{\frac N 2}$ 的 $\{0,1,\cdots,2^N-1\}$ 的子集，满足子集中元素两两异或和均不同。

### 思路

设 $n=\dfrac N 2$。注意区分大小写。

把一个数拆成前半段和后半段，长度均为 $n$。由于要构造的集合大小是 $2^n$，我们猜测前半段任意填，后半段是关于前半段的函数。设前半段为 $x\in[0,2^n)$，后半段为 $f(x)\in[0,2^n)$。

既然已经是异或了，我们再用普通的加法乘法肯定不方便。模仿[这道题](https://www.luogu.com.cn/problem/P3923)，我们构造有限域 $\mathbb F_{2^n}$，下面的所有加法和乘法未经说明都是这个有限域里的。

假设存在两对（无序对）元素 $\{(a,f(a)),(b,f(b))\},\{(c,f(c)),(d,f(d))\}$，满足它们异或和相同。由于我们是拼起来的，前后对于异或独立，所以有方程组 $a+b=c+d,f(a)+f(b)=f(c)+f(d)$。

我们对 $f$ 的构造要满足这个方程有且仅有两个解，即说明 $\{a,b\}=\{c,d\}$。

只有两个解那就是二次方程喽。那我们直接让 $f$ 变成二次函数，比如 $f(x)=x^2$。

带回上面的方程，我们有 $a+b=c+d,a^2+b^2=c^2+d^2$。

把第一个式子平方减去第二个式子，得到 $ab=cd$。

和相等，积也相等。这是什么🤔？韦达定理呀。我们有 $\{a,b\},\{c,d\}$ 都是方程 $x^2-(a+b)x+ab=0$ 的一组解，即 $\{a,b\}=\{c,d\}$。

我们只需要求出 $2^n$ 阶的有限域就可以了。

你高高兴兴写了代码，跑出来一看，$n=4$ 都过不去。

为什么？

在实数域下，平方是不存在逆的。在有限域下用平方是很危险的。

如何解决呢？我们又不想放弃韦达定理。

是不是改成三次方就可以了？

此时 $a+b=c+d,a^3+b^3=c^3+d^3$，一式立方减二式，得到 $ab(a+b)=cd(c+d)$，即 $ab=cd$。也是可以用韦达定理的。

于是就解决了。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i) 
#define ll long long
using namespace std;
int m,p;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res&base);
		base=base&base,expo>>=1;
	}
	return res;
}
bool type;
struct poly{
	int num[100]={};
	int len=0;
	inline void init(){
		while(!num[len]&&len>0) --len;
		return;
	}
	inline void turn(int t){
		while(t) num[len++]=t&1,t>>=1;
		init();
		return;
	}
	inline poly operator+(const poly&a)const{
		poly res;
		res.len=max(a.len,len);
		F(i,0,res.len) res.num[i]=num[i]^a.num[i];
		res.init();
		return res;
	}
	inline poly operator+(const int a)const{
		poly res=*this;
		int&qwq(res.num[0]);
		qwq^=a;
		return res;
	}
	inline poly operator-(const poly&a)const{
		return a+*this;
	}
	inline poly operator-(const int a)const{
		return *this+a;
	}
	inline poly operator*(const poly&a)const{
		poly x;
		F(i,0,len) F(j,0,a.len){
			int&qwq(x.num[i+j]);
			qwq^=(a.num[j]&num[i]);
		}
		x.len=len+a.len;
		x.init();
		return x;
	}
	inline poly operator*(const int a)const{
		poly res=*this;
		F(i,0,len){
			int&qwq(res.num[i]);
			qwq=a&qwq;
		}
		return res;
	}
	inline bool operator<=(const poly&a)const{
		if(type) return len<=a.len;
		if(len!=a.len) return len<=a.len;
		R(i,len,0) if(num[i]!=a.num[i]) return num[i]<=a.num[i];
		return 1;
	}
	inline poly operator<<(const int a)const{
		poly res;
		res.len=a+len;
		F(i,0,len) res.num[a+i]=num[i];
		return res;
	}
	inline poly operator%(const poly&a)const{
		poly t=*this;
		while(a<=t){
			poly tmp=a*t.num[t.len];
			t=t-(tmp<<(t.len-a.len));
		}
		t.init();
		return t;
	}
	inline bool check()const{
		poly x=*this,y;
		F(i,2,(1<<m)-1){
			poly t;
			t.turn(i);
			y=x%t;
			if(y.len==0&&y.num[0]==0) return 0;
		}
		return 1;
	}
	inline void output(){
		F(i,0,m) cout<<num[i]<<" ";
		cout<<"\n";
		return;
	}
	inline int decode(){
		int res(0);
		R(i,len,0) res=(res<<1)|num[i];
		return res;
	}
}mod;
inline void findmod(){
	R(i,(1<<m)-1,1){
		poly a;
		a.turn(i);
		a.num[m]=1;
		a.len=m;
		if(a.check()){
			mod=a;
			return;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
	cin>>m;
	m/=2;
	findmod();
	type=1;
	cout<<(1<<m)<<"\n";
	F(i,0,(1<<m)-1){
		int qwq=i<<m;
		poly qaq;
		qaq.turn(i);
		qwq|=(qaq*qaq*qaq%mod).decode();
		cout<<qwq<<" ";
	}
	return 0;
}
```

---

## 作者：Galois_Field_1048576 (赞：1)

外星人做法。

> 题意：设线性空间 $V = \mathbb F_2^{2n}$。构造一个 $2^n$ 元子集 $S$，使得 $a, b, c, d \in S$，$a \ne b, c \ne d, \{a, b\} \ne \{c, d\} \implies a \oplus b \ne c \oplus d$。

构造方法：设有限域 $\Bbbk = \mathbb F_{2^n}$，等同 $V$ 与 $\Bbbk \oplus \Bbbk$。则尝试构造
$$
S = \{(n, n^3) : n \in \Bbbk\}.
$$
对其满足该限制条件的证明：设 $a \ne b, c \ne d, (a, a^3) \oplus (b, b^3) = (c, c^3) \oplus (d, d^3)$。这样 $x^3 \oplus y^3 = (x \oplus y) (x^2 \oplus xy \oplus y^2)$。由于 $a \oplus b = c \oplus b \ne 0$，所以 $a^2 \oplus ab \oplus b^2 = c^2 \oplus cd \oplus d^2$。两边分别等于 $(a \oplus b)^2 \oplus ab$ 和 $(c \oplus d)^2 \oplus cd$，进而 $ab = cd$。这样我们发现 $(a, b)$ 和 $(c, d)$ 都满足方程
$$
\begin{cases}
x \oplus y = A, \\
x y = B.
\end{cases}
$$
其中 $A = a \oplus b, B = ab$。这组方程至多有一对解，分别是 $(a, b)$ 和 $(b, a)$。所以 $(c, d) = (a, b)$ 或 $(c, d) = (b, a)$。得证。

## 实现方面
```mathematica
Table["0b" <> 
  StringJoin[
   Map[ToString, 
    IntegerDigits[
     Information[FiniteField[2, k], "FieldIrreducible"][2], 2]]], {k, 
  1, 15}]
```

使用这样一段 Mathematica 代码获取有限域的不可约多项式信息。剩下的便是简单的。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace FFCalc {
using Felement = unsigned int;
array<Felement, 16> ir = {0b0,
                          0b11,
                          0b111,
                          0b1011,
                          0b10011,
                          0b100101,
                          0b1011011,
                          0b10000011,
                          0b100011101,
                          0b1000010001,
                          0b10001101111,
                          0b100000000101,
                          0b1000011101011,
                          0b10000000011011,
                          0b100000010101001,
                          0b1000000000110101};

Felement add(Felement a, Felement b) { return a ^ b; }

Felement reduce(Felement a, size_t n) {
    if (a < (1 << n)) return a;
    return reduce(a ^ (ir[n] << (__lg(a) - n)), n);
}

Felement mul(Felement a, Felement b, size_t n) {
    Felement mult = 0;
    for (int i = 0; i < n; i++)
        if (b & (1 << i)) mult ^= (a << i);
    return reduce(mult, n);
}

};  // namespace FFCalc

using FFCalc::mul;

int main() {
    int n;
    cin >> n;
    int m = n / 2;
    cout << (1 << m) << endl;
    for (int i = 0; i < (1 << m); i++)
        cout << ((i << m) + mul(mul(i, i, m), i, m)) << " ";
}
```

---


# [ZJOI2022] 计算几何

## 题目描述

九条可怜是一个喜欢计算几何的女孩子，她画了一个特别的平面坐标系，其中 $x$ 轴正半轴与 $y$ 轴正半轴夹角为 $60$ 度。

从中，她取出所有横纵坐标不全为偶数，且满足 $-2 a + 1 \le x \le 2 a - 1$，$-2 b + 1 \le y \le 2 b - 1$，$-2 c + 1 \le x + y \le 2 c - 1$ 的整点。

可怜想将其中一些点染色，但相邻的点不能同时染色。具体地，对于点 $(x, y)$，它和 $(x, y + 1), (x, y - 1), (x + 1, y), (x - 1, y), (x + 1, y - 1), (x - 1, y + 1)$ 六个点相邻，可结合样例解释理解。

可怜想知道在这个规则下最多能将多少点染色，以及染最多点的染色方案数。由于后者值可能很大，对于染色方案数，你只需要输出对 $998244353$ 取模后的结果。**注意不需要将最多染色点数取模。**

## 说明/提示

**【样例解释】**

如下图所示，点 $J$ 的坐标为 $(2, 1)$，点 $F$ 的坐标为 $(-1, 0)$，点 $H$ 的坐标为 $(2, 0)$。在这三个点中，只有点 $H$ 是横纵坐标全为偶数的点。图中与点 $A$ 距离为 $1$ 的点有 $\texttt{B C D E F G}$ 六个点。

在样例的第一组数据中，满足条件的整点有 $\texttt{R N G B I J P F C K M L E D S T}$。

最多能染 $7$ 个点，方案共 $4$ 种，具体为：$\texttt{P N L B D J T}$，$\texttt{R M F B D J T}$，$\texttt{R M G E C J T}$，$\texttt{R M G E I S K}$。

在样例的第二组数据中，满足条件的整点有 $\texttt{G B I F C L E D}$。

最多能染 $4$ 个点，方案共 $1$ 种，具体为：$\texttt{L G I D}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/a3lp43vq.png)

**【数据范围】**

对于所有测试点：$1 \le T \le 10$，$1 \le a, b, c \le {10}^6$。

每个测试点的具体限制见下表：

| 测试点编号 | $a \le$ | $b, c \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $3$ | $3$ | $a = b = c$ |
| $2$ | $4$ | $4$ | $a = b = c$ |
| $3$ | $4$ | $4$ | 无 |
| $4$ | $3$ | $100$ | 无 |
| $5 \sim 6$ | $3$ | $1000$ | 无 |
| $7 \sim 8$ | $3$ | $5000$ | 无 |
| $9 \sim 10$ | $100$ | $100$ | $a = b = c$ |
| $11 \sim 14$ | $100$ | $100$ | 无 |
| $15$ | ${10}^5$ | ${10}^5$ | $a = b = c$ |
| $16$ | ${10}^5$ | ${10}^5$ | 无 |
| $17 \sim 18$ | ${10}^6$ | ${10}^6$ | $a \cdot b \cdot c \le {10}^6$ |
| $19$ | ${10}^6$ | ${10}^6$ | $a = b = c$ |
| $20$ | ${10}^6$ | ${10}^6$ | 无 |

## 样例 #1

### 输入

```
6
2 1 2
1 1 137
3 94 95
3 1998 1996
998244 353999 999999
50 120 150
```

### 输出

```
7 4
4 1
1124 31585548
23951 33873190
1289433675488 748596399
23600 480090154
```

# 题解

## 作者：JohnVictor (赞：10)

前置题目：loj6677/lg8114.

实际上，这个问题和前置题目没有区别。

我们考虑去掉的坐标都是偶数的点，它们构成一个边长为 $2$ 的等边三角形点阵，我们画出所有的三角形，建一张以这些三角形为顶点的图，两个有公共边的三角形相邻，并连一条图论意义上的边。此时注意到原图的点可以一一对应到新图的边，这正是前置题目。（具体的 $a,b,c$ 可能不一样，应该是题目中的 $a+b-c$ 和对称式）

最后注意一下 $a+b \le c$ 或者对称情形的退化情况。这种情况下很显然答案为 $4ab$，方案数为 $1$，也就是染黑所有横纵坐标为奇数的点。
（具体证明可以考虑转换后的问题，也可以直接以每一个最后被选到的点为某个位置的顶点作一个等边三角形）

---

## 作者：dyc2022 (赞：9)

[更好的阅读体验](https://www.cnblogs.com/dyc2022/p/18996395)
***
这题的难点在于把三角坐标系独立集转化为六边形的菱形覆盖。这里提供一种不同的转化方式。

接下来，以 $a = b = c = 2$ 为例。
***
如下图，我们可以画出 $a = b = c = 2$ 的情形。我们会发现，抠掉 $x,y$ 均为偶数的点，剩余部分应该是由若干个六边形拼接而成。

![](https://cdn.luogu.com.cn/upload/image_hosting/v2rr86aj.png)

其中，红色为坐标系，线段的交点为可以选择的点，空心圆为六边形的中心。图中的黑色同心圆为我们选出来的一种最大独立集方案。

接下来，我们在图形的外围再套上一圈大六边形，使大六边形顶点到内圈顶点的距离等于小六边形边长，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/8g4fvzyn.png)

现在图中的点会分成两部分：选择的点和非选择的点，包括坐标为偶数的点和可以选择但是未被选择的点。

我们可以通过连接一些未选择的点，并延长至大六边形的边，将大六边形分割成若干部分。如图示情况下可构造如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/kg74z0rq.png)

结果非常 amazing 啊！我们把大六边形分割成了若干个菱形，并且每个选择的点恰好就在每个菱形的中心。

假设大六边形边长为 $a',b',c'$，那么问题就转化成了给定一个边长确定的六边形，求其菱形分割方案数。

到这里还毫无头绪，我们不妨把这张图染个颜色。图中的菱形有三种朝向，我们对相同的朝向染相同的颜色，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cx0qq1zr.png)

把脑袋（屏幕）旋转一个角度，然后盯着这个图看，你会发现这个东西看起来就像一堆正方体堆在墙角。

那么问题就变成了在空间直角坐标系堆正方体的方案数，并且通过观察，我们会发现必须要满足一个点前面和右边的堆叠个数要小于等于这个点的堆叠个数。给每行、每列加上一个倒序等差数列，发现变成了一个杨表。
***
那么剩下就是 dirty work 了。对于杨表 $\lambda$，根据钩子公式，答案就是 

$$\prod _{(i,j)\isin \lambda}\frac{a'+c'-j-i}{\operatorname{hook}(i,j)}=\prod ^{a'}_{i=1}\prod^{b'}_{j=1}\frac{a'+c'-j-i}{a'+b'-i-j+1}$$

展开可得

$$\prod_{i=1}^{a'}\frac{(a'+b'+c'-i)!(a'-i)!}{(a'+c'-i)!(a'+b'-i)!}$$

构造 $f(i) = \prod\limits_{j=1}^{i}i!$，带回原式则有

$$\frac{f(a'-1)f(b'-1)f(c'-1)f(a'+b'+c'-1)}{f(a'+b'-1)f(b'+c'-1)f(a'+c'-1)}$$

那么这道题就做完了，预处理 $f(i)$ 和 $f^{-1}(i)$，复杂度显然线性。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 3000006
#define MOD 998244353
using namespace std;
int fac[N],ifac[N],f[N],invf[N],T,a,b,c,x,y,z;
int qpow(int x,int y)
{
    if(y==0)return 1;if(y==1)return x%MOD;
    int ret=qpow(x,y>>1);return ret*ret%MOD*qpow(x,y&1)%MOD;
}
void init()
{
    fac[0]=f[0]=invf[0]=1;
    for(int i=1;i<N;i++)
        fac[i]=fac[i-1]*i%MOD,f[i]=f[i-1]*fac[i]%MOD;
    ifac[N-1]=qpow(fac[N-1],MOD-2);
    for(int i=N-2;~i;i--)
        ifac[i]=ifac[i+1]*(i+1)%MOD;
    for(int i=1;i<N;i++)
        invf[i]=invf[i-1]*ifac[i]%MOD;
}
main()
{
    scanf("%lld",&T),init();
    while(T--)
    {
        scanf("%lld%lld%lld",&x,&y,&z),x=min(x,y+z),y=min(y,x+z),z=min(z,x+y);
        a=x+y-z,b=x+z-y,c=y+z-x;
        printf("%lld ",a*b+b*c+c*a);
        if(!a||!b||!c){printf("1\n");continue;}
        int ans=f[a-1]*f[b-1]%MOD*f[c-1]%MOD*f[a+b+c-1]%MOD*invf[a+b-1]%MOD*invf[b+c-1]%MOD*invf[a+c-1]%MOD;
        printf("%lld\n",ans);
    }
    return 0;
}
```
***
感谢信友队孔启皓老师的讲解。

感谢 Microsoft Windows Logo 提供~~粗劣~~高超的绘图支持。

---

## 作者：VinstaG173 (赞：9)

JV 写的题解好简略。虽然应该已经足够学会做这个题了，但是我还是想补篇稍微详细一点的，主要讲一下具体的问题形式转化过程。

首先我们注意到题目中的 $60\degree$ 坐标系和三个方向上的限制，因此我们会发现它本质是一个三角网。而将其中横纵坐标均为偶数的点抠掉后得到的是一个六边形网，这一点从样例解释给出的图中就能够直观地获取（图源样例解释）：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3lp43vq.png)

看到这种六边形网的形式和选点的不相邻规则，~~如果你身经百战见得多了~~就能够想到 [P8114](https://www.luogu.com.cn/problem/P8114)。我们会发现它们是本质相同的，都是 [LOJ6677](https://loj.ac/p/6677) 的一种等价表述。接下来我们来说明一下它们之间的等价关系。

两道原题之间的等价关系在 [P8114 题解区](https://www.luogu.com.cn/problem/solution/P8114)和 [P8114 出题人题解](https://bzy-nya.github.io/CNOI/2021ER_Solution.html)中已经有解释了，我们这里只讲一下此题和 P8114 之间的等价关系（因为这个等价关系更加直观显然）。

我们考虑此题中点相邻与 P8114 中边相邻的等价转化，容易发现我们可以作出一个以题目中点为顶点的小六边形的外接大六边形，如图，其中图 1 为样例，图 2 为 $a,b,c$ 分别为 $2,3,4$ 的情况（Geogebra 钛垃圾辣！！！）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hknrd5eb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ah51uvf0.png)

则由图易看出此题中点相邻和大六边形网中边相邻显然是等价的。

我们设转化到 P8114 的形式后对应的边长（具体含义见 P8114 原题）为 $a',b',c'$，考虑如何刻画 $a,b,c$ 与 $a',b',c'$ 的关系。

我们发现 $-2a+1$ 到 $2a+1$ 中奇数有 $2a$ 个，而每个坐标为奇数的行（$x=2k+1$，共 $2a$ 个）上 $y$ 坐标最大（小）的点可以对应大六边形网边界上的一条边，如下图所示，红圈对应奇数行上的点，红线为边界上的边，其中 $b'=3,c'=1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/x3wbj6hp.png)

由此对应我们能够得到 $b'+c'=2a$，由对称性得到另两条式子，联立解得 $a'=b+c-a,b'=c+a-b,c'=a+b-c$。

由于问题可以转化为 $a' \times b' \times c'$ 立方堆叠的三视图，故所求点数最大值即为 $a'b'+b'c'+c'a'$，方案数利用原题结论即可求出。

JV 也提到以上有一种情况我们无法解决，即 $a',b',c'$ 中有非正数的情况。由对称性不妨设 $a+b \le c$。这时点数最大值为 $4ab$，方案数为 $1$，证明的大致思路 JV 题解里也说明了，具体证明是简单的，不做赘述。

---

## 作者：littlez_meow (赞：2)

一眼看上去跟[六边形战士](https://www.luogu.com.cn/problem/P8114)很像。

[题目指路](https://www.luogu.com.cn/problem/P8333)。

## 思路

首先你需要知道[六边形战士](https://www.luogu.com.cn/problem/P8114)中，若六边形的三边长为 $x,y,z$，记 $f(n)=\prod\limits_{i=1}^n n!$，则答案为：

$$\dfrac{f(x+y+z-1)f(x-1)f(y-1)f(z-1)}{f(x+y-1)f(x+z-1)f(y+z-1)}$$

具体过程可看[题解](https://www.luogu.com.cn/blog/littleZ-meow-0v0/p8114-cnoi2021-liu-bian-xing-zhan-shi-ti-xie)，在此不多赘述。

考虑将此题变成上面那题。

如果将点不相邻变成边无公共端点，就可以把染色转换成匹配。

事实上，这是可行的，如下图，我们将样例解释改造一下：

![例子](https://cdn.luogu.com.cn/upload/image_hosting/dokwtj6n.png)

在原图中相邻的点，变成了在新图中有公共顶点的边。

手玩一下可以发现 $x=a+b-c$，$y,z$ 对称性同理。

第一问显然为完美匹配大小，即 $xy+xz+yz$。

第二问就是前置题目。

发现当 $x,y,z$ 其中之一小于等于 $0$ 六边形会退化为平行四边形。为了不处理负数我们让超出去的线平移到顶点上，即 $a\leftarrow \min\{a,b+c\}$，$b,c$ 对称性同理。此时仅一种匹配方式。

## 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
using namespace std;
const int MOD=998244353,MAXN=3e6;
int a,b,c,T;
int fact[MAXN+1],inv[MAXN+1];

inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
inline int calc(int x,int y,int z){
	return (a&&b&&c)?fact[x+y+z-1]*1ll*fact[x-1]%MOD*fact[y-1]%MOD*fact[z-1]%MOD*inv[x+y-1]%MOD*inv[x+z-1]%MOD*inv[y+z-1]%MOD:1; 
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	fact[0]=inv[0]=1;
	F(i,1,MAXN) fact[i]=fact[i-1]*1ll*i%MOD;
	inv[MAXN]=qpow(fact[MAXN],MOD-2);
	R(i,MAXN,2) inv[i-1]=inv[i]*1ll*i%MOD;
	F(i,1,MAXN) fact[i]=fact[i]*1ll*fact[i-1]%MOD;
	F(i,1,MAXN) inv[i]=inv[i]*1ll*inv[i-1]%MOD;
	for(cin>>T;T;--T){
		int x,y,z;
		cin>>x>>y>>z;
		x=min(x,y+z),y=min(y,x+z),z=min(z,x+y);
		a=x+y-z,b=x+z-y,c=y+z-x;
		cout<<1ll*a*b+1ll*a*c+1ll*b*c<<" "<<calc(a,b,c)<<"\n";
	}
	return 0;
} 
```

不喜勿喷，完结撒花 awa~

---

## 作者：Others (赞：2)

做完[六边形战士](https://www.luogu.com.cn/problem/P8114)后来做这题，发现读完题，画个图就成了重题（话说做过上述题目的 $\text{ZJOIer}$ 在考场上会有多激动）。这里分享一个更简单的式子：**过程更简单**，结果一样（~~不一样就出事了~~）。

**Solution：**

首先观察，九条把所有全是偶数的点删掉了，我们把这些点连接起来形成一啪啦三角形，每个三角形对应一个节点，若有边相邻则连一条边（图论意义上的）。发现这些边通过了要染色的点，这样的话使染色的点不能相邻就等同于做二分图匹配。注意这里的三角形都是的边长都是 $2$，所以 $-2a+1$ 就相当于 $-a$，$2a-1$ 就相当于 $a$，其他的同理。

现在就差理解 $a,b,c$ 究竟表示什么：

- $a+b\le c$，这样很显然是一个平行四边形，割成了 $8\cdot ab$ 个三角形，可以发现最多染 $4\cdot ab$ 个点，而且有且仅有一种方案。

- 其他的情况的三条边分别是 $a+b-c,a+c-b,b+c-a$，画画图就知道了，由于可能有一条边巨大，所以使 $a←\min\{a,b+c\},b←\min\{b,a+c\},c←\min\{c,a+b\}$。

然后就是一个被分割成几个三角形的六边形，我们要对三角形做二分图匹配，对于这类题目，我们可以用[六边形战士](https://www.luogu.com.cn/problem/P8114)的 trick 把他转化成三维的：把一堆正方体堆在墙角有多少种堆法的问题（要求凸堆叠），然后再转化为二维的矩阵，注意到这里的行和列的数字是单调的，但都非严格单调，我们将第 $i$ 行的数字加上 $i$，使得每一列严格单调，然后就成的半标准杨表，我们令三边分别为 $A,B,C$，他们三个是等价的。那值域就是 $[1,A+C]$，运用半标准杨表勾长公式：

$$ans=\prod\limits_{i=1}^{A}\prod\limits_{j=1}^{B}\frac{A+C+j-i}{A+B-i-j+1}$$

$$=\prod\limits_{i=1}^{A}\frac{(A+B+C-i)!(A-i)!}{(A+B-i)!(A+C-i)!}$$

就这样······没什么难的。$O(A+B+C)$ 预处理，$O(A+B+C)$ 询问，总复杂度 $O(T(A+B+C))$，其实可以做到总复杂度 $O(A+B+C+T)$ 的，但是没必要。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=3000005,mod=998244353;
ll a,b,c,f[N],g[N],ans,T,_a,_b,_c;
ll qpow(ll x,ll y) {
	ll ans=1;
	while(y) {
		if(y&1) ans=ans*x%mod;
		x=x*x%mod;y>>=1;
	}
	return ans;
}
int main() {
	cin >> T;
	f[0]=1;
	for(int i=1;i<=3000000;i++) f[i]=f[i-1]*i%mod;
	g[3000000]=qpow(f[3000000],mod-2);
	for(int i=3000000-1;i>=0;i--) g[i]=g[i+1]*(i+1)%mod;
	while(T--) {
		cin >> a >> b >> c;
		if(a+b<=c) {
			printf("%lld %lld\n",4*a*b,1);
			continue;
		}
		ans=1;
		a=min(a,b+c),b=min(b,a+c),c=min(c,a+b);
		_a=a+b-c,_b=a+c-b,_c=b+c-a;
		a=_a,b=_b,c=_c;
		for(int i=1;i<=a;i++) ans=ans*f[a+b+c-i]%mod*f[a-i]%mod*g[a+c-i]%mod*g[a+b-i]%mod;
		printf("%lld %lld\n",a*c+b*c+a*b,ans);
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：2)

首先这个东西不是很好算，因为有点都消失了。如果稍微有一点空间想象能力，也许可以把点看成边，这样就变成了二分图最大匹配个数……

然后这种图二分图最大匹配个数就是[这个题](https://www.luogu.com.cn/problem/P8114)，进而转化成最基本的形式，也就是[这个题](https://loj.ac/p/6677)。

下面给个样例的草图，也许就可以看出一点转化的影子。

![](https://cdn.luogu.com.cn/upload/image_hosting/yhowg29l.png)

容易看出总共有四种方案。

然后简单介绍一下这个东西。我们将其视作三维图形（这种说法并不足够准确），然后俯视这个立体图形，容易发现是一个 $n \times m$ 的矩阵，然后答案是 $n \times m$ 的凸立方体堆叠计数。记 $a_{i,j}$ 表示 $(i,j)$ 位置上面的小立方体个数，需要满足：

- $0 \leq a_{i,j} \leq h$；   
- $a_{i,j} \leq a_{i+1,j}$；   
- $a_{i,j} \leq a_{i,j+1}$。

注意到一点是，我们可以将 $a$ 看成由若干只能向右或向下的分割线分出来的，例如 $h$ 的分割线和矩形的边界围成的上面的那个封闭图形里面就全是 $h$，$h-1$ 和 $h$ 的分割线围成的封闭图形里面全是 $h-1$……以此类推（当然封闭图形可以什么位置也不包含）。显然这些路径是不交的。

既然路径不交，考虑 LGV 引理。但是路径有重合，这样我们就进行平移就好了。这样就可以用行列式进行计算，在经过一系列推导可以得到结论。[指条明路](https://bzy-nya.github.io/CNOI/2021ER_Solution.html)，请看最后一题的题解。

剩下的工作是计算这个题里面的 $n,m,h$。困难的推导观察之后可以得到 $n=a+b-c,m=a+c-b,h=b+c-a$，同时点数最大值为 $nm+nh+mh$。

但似乎过不了样例，因为上面的 $n,m,h$ 可以出现负数。观察样例发现在 $a+b \leq c$ 及形似的情况，两问答案分别是 $4ab$ 和 $1$，输出就好了。

```cpp
void Solve()
{
	LL a=read(),b=read(),c=read();
	a=min(a,b+c),b=min(b,a+c),c=min(c,a+b);
	LL A=a+b-c,B=a+c-b,C=b+c-a;
	write(A*B+B*C+A*C),putchar(' ');
	if(!A || !B || !C)
	{
		putchar('1'),puts("");
		return ;
	}
	LL ans=Mul(Mul(f[A-1],f[B-1]),f[C-1]);
	ans=Mul(ans,f[A+B+C-1]);
	ans=Mul(ans,invf[A+B-1]);
	ans=Mul(ans,invf[A+C-1]);
	ans=Mul(ans,invf[B+C-1]);
	write(ans),puts("");
}
```

---

## 作者：dead_X (赞：1)

其实这题就是 P8114。

$a+b\leq c$ 的情况比较平凡，自己手玩一下就知道了，答案是 $4ab$ 和 $1$。

$a+b>c$ 的情况可以看作六边形网格，下面的 $n,m,k$ 为六边形网格边长。

下文中默认 $n\geq m\geq k$。

首先你要知道的是，六边形的菱形镶嵌（也就是将小三角形完美匹配）可以转化为立方体堆叠，可以看[这里](https://zhuanlan.zhihu.com/p/302869200)。

这样就相当于我们要覆盖上去 $k$ 条路径代表第 $i$ 层的轮廓，然后每层的轮廓必须向外。

我们将每层的轮廓都向外一格，那么这等价于 $k$ 条网格图路径不相交，这就可以用 LGV 引理写个暴力了。

从 $(n+i,i)$ 走到 $(j,j+m)$ 需要走 $n+m$ 步，其中 $n+i-j$ 步是向上的，因此方案数也可以用组合数计算。
$$
\begin{aligned}
\det\left(\binom{n+m}{n+i-j}\right)_{i,j=1}^k&=\det\left(\frac{(n+m)!}{(n+i-j)!(m+j-i)!}\right)_{i,j=1}^k\\
&=\left(n+m\right)!^{k}\det\left(\frac{1}{(n+i-j)!}\cdot\frac{1}{(m+j-i)!}\right)_{i,j=1}^k\\
\end{aligned}
$$
然后 P8114 给了你个提示，我们大力往里套。
$$
\begin{aligned}
&\det(A)=(-1)^{\frac{k(k-1)}{2}}(n+m)!^k\prod\limits_{i=1}^k\frac{1}{(n+k-i)!}\prod\limits_{i=1}^k\frac{1}{(m+i-1)!}\prod\limits_{1\leq i<j\leq k}(i-j)\prod\limits_{2\leq i\leq j\leq k}(n+m+j-i+1)\\
&\prod\limits_{1\le i<j\le k}(i-j)=(-1)^{\frac{k(k-1)}{2}}\prod\limits_{i=1}^{k-1}i!\\
&\prod\limits_{2\le i\le j\le k}(n+m+j-i+1)=\prod\limits_{2\le i\le k}\frac{(n+m+k-i+1)!}{(n+m)!}
\end{aligned}
$$
全部乘起来，答案惊人地简洁。

记 $F(x)$ 为 $\prod\limits_{i=1}^{n-1}(i!)$，答案就是下面这个东西：
$$
\frac{F(n-1)F(m-1)F(k-1)F(n+m+k-1)}{F(n+m-1)F(m+k-1)F(n+k-1)}
$$
所以代码非常短。

---


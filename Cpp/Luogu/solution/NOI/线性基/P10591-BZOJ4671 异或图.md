# BZOJ4671 异或图

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

## 题目描述

定义两个结点数相同的图 $G_1$ 与图 $G_2$ 的异或为一个新的图 $G$，其中如果 $(u,v)$ 在 $G_1$ 与 $G_2$ 中的出现之和为 $1$，那么边 $(u,v)$ 在 $G$ 中，否则这条边不在 $G$ 中。

现在给定 $s$ 个结点数相同的图 $G_{1\sim s}$，$S=\{G_1,G_2,\dots,G_s\}$，请问 $S$ 有多少个子集的异或为一个连通图？

## 说明/提示

对于 $100\%$ 的数据，$2\leq n\leq 10$，$1\leq s\leq 60$。

## 样例 #1

### 输入

```
3 
1 
1 
0```

### 输出

```
4```

# 题解

## 作者：BreakPlus (赞：5)

> 由于“异或图”必须同时考虑所有点和边，对点进行状压显得毫无意义。发现 $n \le 10$ 提示我们可能有奇怪复杂度做法。比如，$\text{Bell}(n)$？

----

正难则反，考虑将图强行拆成不连通图。

钦定将图分为 $x$ 个连通块，两两之间没有连边。但是我们并没有保证连通块内部是否真的联通。

令 $G(x)$ 表示钦定了 $x$ 个连通块的方案数，$F(x)$ 表示恰好有 $x$ 个连通块的方案数。注意到以下两点：

+ $G(x)$ 可以在 $\mathcal{O}(\operatorname{poly}(n)\operatorname{Bell}(n))$ 的复杂度求得。

具体地，枚举所有拆分方案，然后钦定连通块之间必须边权位 $0$，令 $x_i$ 表示第 $i$ 个图选还是不选，能列出一堆关于 $x_i$ 的异或方程。

这个异或方程必然有解，根据经典线代结论，解的个数是 $s - t$，其中 $t$ 是线性基的大小（矩阵的秩）。于是就能算了。

+ $G(x)$ 可以与 $F(x)$ 建立关系。

不难得到 $G(x) = \sum \limits_{k=x}^n S(k,x)F(k)$，其中 $S$ 是第二类 Stirling 数。

$n$ 很小其实都可以爆解方程。但是这里有一个斯特林反演的结论，上式等价于：

$F(x) = \sum \limits_{k=x}^n (-1)^{k-x}s(k,x)G(k)$

其中 $s$ 是第一类 Stirling 数。


算出 $G$ 后求得 $F(1)$ 即可。

于是就做完了。

----

哎，一车典题不会，还是似一似吧。

```cpp
ll n,s; char str[205];
bool E[65][15][15];
struct Basis{
    ll p[65], cnt;
    void clear(){ memset(p,0,sizeof(p)); cnt=0;}
    void insert(ll x){
        for(ll i=60;i>=0;i--){
            if((x>>i)&1){
                if(!p[i]){
                    p[i] = x;
                    ++cnt; break;
                }else x ^= p[i];
            }
        }
    }
}B;
ll c[65], f[65], ans, pw[65];
void dfs(ll x,ll col){
    if(x == n+1){
        B.clear();
        for(ll p=1;p<=n;p++){
            for(ll q=p+1;q<=n;q++){
                if(c[p] == c[q]) continue;
                ll trv = 0;
                for(ll i=1;i<=s;i++)
                    if(E[i][p][q]) trv |= (1ll<<i-1);
                B.insert(trv);
            }
        }
        ans = (ans + f[col] * pw[s - B.cnt]);
        return;
    }
    for(ll i=1;i<=col+1;i++) {
        c[x] = i;
        dfs(x+1, max(i, col));
    }
}
void solve(){
    pw[0] = 1;
    for(ll i=1;i<=60;i++) pw[i] = pw[i-1] * 2;
    s=read();
    for(ll i=1;i<=s;i++){
        scanf("%s", str); ll now=0;
        if(i==1){
            for(ll j=2;j<=10;j++){
                if(j*(j-1)/2==strlen(str)){
                    n=j;
                    break;
                }
            }
        }
        for(ll p=1;p<=n;p++){
            for(ll q=p+1;q<=n;q++){
                E[i][p][q] = E[i][q][p] = str[now++]-'0';
            }
        }
    }
    
    for(ll i=1;i<=n;i++){
        if(i&1) f[i] = Fac(i-1);
        else f[i] = -Fac(i-1);
    }
    dfs(1, 0);
    printf("%lld\n", ans);
}
```

---

## 作者：云浅知处 (赞：5)

考虑钦定一个连通块形态（一共只有 $\text{Bell}(n)\le 21147$ 种），计算符合这个连通块形态的图的个数。也就是说，我们钦定一个点集的划分 $S_1,S_2,\cdots,S_k$，要求 $S_i$ 内部无所谓，但不同的 $S_i,S_j$（$i\neq j$）之间的点一定两两不连通。那么这相当于在不同连通块之间的边都不能选。设这样的边构成集合 $E$，我们把每张图的边集和 $E$ 求交，计算异或和为 $\varnothing$ 的方案数即可。于是我们可以在 $O(s)$ 时间内计算方案数。

现在考虑给每个连通块形态赋一个容斥系数，使得连通图的容斥系数和为 $1$，非连通图的容斥系数和为 $0$。

设 $C(E)$ 为钦定了边集 $E$ 不能连，即连边集合为 $\{(i,j)|1\le i<j\le n\}-E$ 时的连通块形态，则钦定的划分 $P$ 的容斥系数应当为 $\sum_{C(E)=P}(-1)^{|E|}$，这就是 $(-1)^{k-1}(k-1)!$，其中 $k$ 为连通块个数。详细的推导可以参考 <https://www.luogu.com.cn/article/i68r0j43>。

综上，我们在 $O(\text{Bell}(n)\times s\times n^2)$ 的时间内解决了本题。

```cpp
#include<bits/stdc++.h>

#define ll long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

ll G[65];
int n,s;

struct basis{
	ll w[45];int cnt;
	void clear(){cnt=0;memset(w,0,sizeof(w));}
	void ins(ll x){
		for(int i=44;i>=0;i--)if((x>>i)&1){
			if(!w[i])return w[i]=x,cnt++,void();
			else x^=w[i];
		}
	}
};
ll calc(ll S){
	basis A;A.clear();
	for(int i=1;i<=s;i++)A.ins(G[i]&S);
	return 1ll<<(s-A.cnt);
}

int col[11];
ll ans=0,fac[11];
void dfs(int now,int cnt){
	if(now==n+1){
		int p=0;ll E=0;
		for(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++){
			if(col[i]!=col[j])E|=(1ll<<p);
			p++;
		}
		if(cnt&1)ans+=calc(E)*fac[cnt-1];
		else ans-=calc(E)*fac[cnt-1];
		return ;
	}
	for(int i=1;i<=cnt+1;i++)col[now]=i,dfs(now+1,max(cnt,col[now]));
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif

	s=read();
	for(int i=1;i<=s;i++){
		string Gi="";cin>>Gi;
		for(n=0;n<=10;n++)if(n*(n-1)/2==Gi.size())break;
		for(int j=0;j<Gi.size();j++)if(Gi[j]=='1')G[i]|=(1ll<<j);
	}

	fac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i;
	dfs(1,0);
	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：Lyrella (赞：4)

# 简要题意
定义两个结点数相同的图 $G_1$ 与图 $G_2$ 的异或为一个新的图 $G$，其中如果 $(u, v)$ 在 $G_1$ 与 $G_2$ 中的出现之和为 $1$，那么边 $(u, v)$ 在 $G$ 中，否则这条边不在 $G$ 中。现在给定 $s$ 个结点数相同的图 $G_{1∼s},S = {G_1,G_2,\dots ,G_s}$，请问 $S$ 有多少个子集的异或为一个连通图？

**数据范围**：$2\le n\le10,1\le s\le60$。

# 题解
这道题和连通性相关，于是考虑维护连通块。若我们直接求解有 $i$ 个连通块的方案数你发现会不太可做，考虑放宽限制。我们设 $f(i)$ 表示钦定 $i$ 个点集两两之间不连通的方案数，$g(i)$ 表示恰有 $i$ 个连通块的方案数。于是有：
$$
f(m)=\sum_{m\le i\le n}{i\brace m}g(i)
$$
于是就可以斯特林反演得到：
$$
g(m)=\sum_{m\le i\le n}(-1)^{i-m}{i\brack m}f(i)
$$
考虑答案为：
$$
g(1)=\sum_{i\le n}(-1)^{i-1}(i-1)!f(i)
$$
所以我们只需要求出所有 $f$ 即可。

因为 $f$ 的求解似乎要枚举点集划分，而枚举数量是 $\sum\limits_{i\le n}{n\brace i}$ 的，这就要我们找到合适的方法计算出方案数。

注意到一条边的组成是：$\bigoplus\limits_{edge\in G_i}a_i=0$，其中 $a_i$ 代表选或不选。那么对于一个枚举到的点集划分就有一些异或方程。对于这些方程，我们并不需要知道它们的解，只用求出方程组的秩即可。这个东西用线性基做就行了。时间复杂度 $O(Bell_n\times s\times n^2)$。

---

## 作者：exCat (赞：3)

这是一个非常牛的题（至少对于我来说)拿到的时候没有任何想法，看了一些题解后终于懂了，就想好好写一篇题解来记录。

首先我们设 $f_x$ 表示至少有 $x$ 个联通块的方案数，  $g_x$ 表示恰好有 $x$ 个连通块的方案数。然后显然有一个式子
$$
f_m=\sum_{i=m}^{n}{i\brace m}g_i
$$

然后用反演的式子就有

$$
g_m=\sum_{i=m}^n(-1)^{i-m}{i\brack m} f_i
$$

我们要求的答案显然是 $g_1$ 。

所以相当于要求 $\sum_{i=1}^n(-1)^{i-1}(i-1)!f_i$ 。前面都很简单，我们只需要考虑如何求 $f$ 。

再次观察题面发现 $n\le 10$ ，所以可以考虑相对暴力的做法来求 $f$ 。~~观察题解~~我们知道枚举所有划分的数量是 $B_{10}=115975$ 显然是可以接受的。

所以先枚举划分，然后钦定不同连通块之间不能有边，联通块内任意的可选择的子集数。我们考虑按题目给出的顺序将枚举的划分表示出来(必须没边的位置设为 $1$ )，然后将这个值与给出的图按位与然后插入线性基。最后贡献是 $2^{(n-k)}$ 其中 $n$ 是图的总数 $k$ 是线性基里的个数。

为什么这是对的呢？我们看到题解中告诉我们这是很多个异或的方程组解出的自由元的个数。但我太菜了，我觉得这样的写法并没有真的在列出方程并解。我们可以换一种方式，对于插入线性基发现可以被异或出的数在最后是可以随便选，这些异或出来的图可能在不能有边的地方有边，但是用线性基里一定有唯一的方式异或掉这些冲突的边，所以答案就上面的式子。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int cnt,col[200],n,zd,p[600],s[700],ans,fra[200],pw[700];
char g[700][600]; 
void insert(int z)
{
	for(int i=50;i>=0;i--)
	{
		if((z>>i)&1)
		{
			if(!p[i])
			{
				p[i]=z,cnt++;
				break;
			}
			else z^=p[i];
		}	
	}
}
int js(int E)
{
	for(int i=0;i<=50;i++)p[i]=0;cnt=0;
	for(int i=1;i<=n;i++)insert(s[i]&E);
	return cnt; 
}
void dfs(int u,int cnt)
{
	if(u==zd+1)//处理完所有点 
	{
		int E=0;int pos=0;
		for(int i=1;i<=zd;i++)
			for(int j=i+1;j<=zd;j++)
			{
				if(col[i]!=col[j])E|=(1ll<<pos);
				pos++;
			}
		if(cnt&1)ans+=fra[cnt-1]*pw[n-js(E)];
		else ans-=fra[cnt-1]*pw[n-js(E)];
	}
	else
		for(int i=1;i<=cnt+1;i++)col[u]=i,dfs(u+1,max(i,cnt)); 
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	pw[0]=1;
	for(int i=1;i<=n;i++)pw[i]=pw[i-1]*2;
	for(int i=1;i<=n;i++)
	{
		cin>>g[i];
		if(i==1)
 		{
		 	int len=strlen(g[i]);
 			for(int j=1;j<=10;j++)
 				if(j*(j-1)==2*len){zd=j;break;}
		} 
		int pos=0;
		for(int j=1;j<=zd;j++)
			for(int k=j+1;k<=zd;k++)
			{
				if(g[i][pos]=='1')s[i]|=(1ll<<pos);
				pos++;
			}
	}
	fra[0]=1;
	for(int i=1;i<=zd;i++)fra[i]=fra[i-1]*i;
	dfs(1,0);
	cout<<ans<<'\n';
	return 0;
} 
```

---

## 作者：EuphoricStar (赞：2)

设 $f_i$ 为钦定 $i$ 个集合两两无边的方案数（即钦定有 $i$ 个连通块的方案数），设 $g_i$ 为恰好有 $i$ 个连通块的方案数，则：
$$
f_i = \sum\limits_{j = i}^n {j \brace i} g_j
$$
根据斯特林反演，得：
$$
g_i = \sum\limits_{j = i}^n (-1)^{j - i} \begin{bmatrix} j \\ i \end{bmatrix} f_j
$$
所以：
$$
ans = g_1 = \sum\limits_{i = 1}^n (-1)^{i - 1} (i - 1)! f_i
$$
问题转化为求 $f_i$。

发现 $n$ 很小，考虑直接枚举哪些点被分到了一个集合（这里的枚举量是贝尔数级别的），设有 $m$ 个集合。那么每一条两端所属集合不同的边都必须被选偶数次。

设编号为 $b_{i, 1}, b_{i, 2}, \ldots, b_{i, k}$ 的图包含第 $i$ 条两端所属集合不同的边，$a_i$ 为第 $i$ 个图是否在子集中，那么会得到一个形如 $\forall i, a_{b_{i, 1}} \oplus a_{b_{i, 2}} \oplus \cdots \oplus a_{b_{i, k}} = 0$ 的异或方程组，高斯消元求其自由元个数 $c$，那么这种划分方案对 $f_m$ 有 $2^c$ 的贡献。

总时间复杂度 $O(B_n n^2 (s + n^2))$。

[code](https://darkbzoj.cc/submission/258494)

---

## 作者：Petit_Souris (赞：1)

看到这种图计数题就先枚举点做法，尝试一些状压做法，但是发现所有边的异或是同步进行的，出现很多问题。

在若干尝试之后容易想到强制钦定一些点集 $S_1,S_2,\dots,S_k$，他们两两之间没有连边，而内部则任意。

这种情况下，我们可以将点集之间的边作为状态的一个二进制位，那么一个方案满足要求当且仅当选中的边的状态异或和为 $0$，可以用线性基解决。

比较关键的是如何考虑一种点集的系数。设 $f_i$ 为钦定 $i$ 个连通块的方案数，$g_i$ 为恰好 $i$ 个连通块的方案数，那么容易得到 $f_i=\sum\limits_{i\le j\le n}S2(j,i)g_j$，其中 $S2$ 为第二类斯特林数。可以直接做一步斯特林反演，得到 $g_{i}=\sum\limits_{i\le j\le n}(-1)^{j-i}S1(j,i)f_{j}$，其中 $S1$ 为第一类斯特林数。

现在要求 $g_1$，代入容易得到，$g_1=\sum\limits_{1\le j\le n}(-1)^{j-1}(j-1)!f_j$。

时间复杂度 $\mathcal O(\mathrm{bell}(n)\mathrm{poly}(n))$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
ll m,n,sta[69],ch[69],bin[69],tot,ans,rsta[69],id[12][12],fac[11];
struct Basis{
    ll d[69],cnt;
    void clear(){
        memset(d,0,sizeof(d));
        cnt=0;
    }
    void Ins(ll x){
        per(i,46,0){
            if(!((x>>i)&1))continue;
            if(!d[i])return d[i]=x,cnt++,void();
            x^=d[i];
        }
    }
}B;
void calc(ll ct){
    rep(i,0,ct+1)bin[i]=0;
    B.clear();
    rep(i,1,n)bin[ch[i]]++;
    memset(rsta,0,sizeof(rsta));
    rep(i,1,n){
        rep(j,i+1,n){
            if(ch[i]==ch[j])continue;
            rep(k,1,m){
                rsta[k]<<=1;
                if((sta[k]>>(id[i][j]-1))&1)rsta[k]++;
            }
        }
    }
    rep(k,1,m)B.Ins(rsta[k]);
    ll coef=(1ll<<(m-B.cnt))*fac[ct-1];
    if(ct&1)ans+=coef;
    else ans-=coef;
}
void dfs(ll x,ll ct){
    if(x==n+1){
        calc(ct);
        return;
    }
    rep(i,1,ct+1){
        ch[x]=i;
        dfs(x+1,max(ct,i));
    }
}
char s[60];
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    m=read();
    rep(i,1,m){
        scanf("%s",s+1);
        ll len=strlen(s+1);
        n=0;
        while(n*(n-1)/2<len)n++;
        rep(j,1,len){
            if(s[j]=='1')sta[i]|=(1ll<<(j-1));
        }
    }
    fac[0]=1;
    rep(i,1,n)fac[i]=fac[i-1]*i;
    rep(i,1,n){
        rep(j,i+1,n)id[i][j]=++tot;
    }
    dfs(1,0);
    write(ans);
    return 0;
}
```

---

## 作者：dAniel_lele (赞：1)

考虑分别计数最终的图可以被分为 $S_1\cup S_2\cup\dots\cup S_k=\{1,2,\dots,n\}$ 且 $S_i\cap S_j=\emptyset$ 的互不联通的子集的方案数并容斥。这样的划分方案大约有 $C\approx1.1\times10^5$。

对于每个子问题，取出每个图中属于不同集合的边，将他们视为二进制数。问题转化为有多少个图的子集满足其权值异或和为 $0$，可以使用线性基解决。

考虑容斥。可以使用 dp 算出容斥系数。预处理出 $dp_{i,j}$ 表示大小为 $i$ 的集合拆分成 $j$ 个部分的方案数。$coef_i=-\sum_{j=1}^{i-1}dp_{i,j}\times coef_j$。

总复杂度 $O(Csn^2)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
char c[65][15][15];
long long n,m;
int a[15],bel[15],val[65];
__int128 ans;
int lnb[65],lft;
int C[15][15],dp[15][15][15],coef[15];
bool add(int val,int tcnt){
	for(int i=tcnt-1;i>=0;i--){
		if(val&(1ll<<i)){
			if(!lnb[i]){
				lnb[i]=val;
				return false;
			}
			val^=lnb[i];
		}
	}
	return true;
}
void dfs(int now,int p){
	if(now==(1ll<<m)-1){
		int cnt=0;
		for(int i=1;i<=n;i++){
			cnt=0,val[i]=0;
			for(int j=1;j<=m;j++){
				for(int k=j+1;k<=m;k++){
					if(bel[j]!=bel[k]){
						val[i]|=(c[i][j][k]-'0')*(1ll<<cnt);
						cnt++;
					}
				}
			}
		}
		lft=0; for(int i=0;i<cnt;i++) lnb[i]=0;
		for(int i=1;i<=n;i++) lft+=add(val[i],cnt);//cout<<val[i]<<" ";
		ans+=(__int128)(1ll<<lft)*coef[p];
//		cout<<p<<" "<<lft<<" "<<coef[p]<<"\n";
		return ;
	}
	int s=((1<<m)-1)^now,lb=lowbit(s); s^=lb;
	for(int i=s;;i=(i-1)&s){
		a[p+1]=i|lb;
		for(int j=1;j<=m;j++) if((a[p+1]>>(j-1))&1) bel[j]=p+1;
		dfs(now|i|lb,p+1);
		if(!i) break;
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		string s; cin>>s;
		m=sqrt(s.size()*2)+1; 
		int cnt=0;
		for(int j=1;j<=m;j++){
			for(int k=j+1;k<=m;k++){
				c[i][j][k]=s[cnt++];
			}
		}
	}
	for(int i=0;i<=m;i++) C[i][0]=1;
	for(int i=1;i<=m;i++) for(int j=1;j<=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];
	for(int i=0;i<=m;i++){
		dp[i][0][0]=1;
		for(int j=0;j<=m;j++){
			for(int k=0;k<=m;k++){
				for(int l=1;j+l<=m;l++){
					dp[i][j+l][k+1]+=dp[i][j][k]*C[j+l-1][l-1];
				}
			}
		}
	}
	coef[1]=1;
	for(int i=2;i<=m;i++){
		for(int j=1;j<i;j++){
			coef[i]+=dp[i][i][j]*coef[j];
		}
		coef[i]=-coef[i];
	}
	dfs(0,0);
	cout<<(long long)ans;
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10591)

**题目大意**

> 给定 $m$ 张 $n$ 个点的无向图，求有多少个 $1\sim m$ 的子集满足将这些编号的图的边集异或起来，得到的图连通。
>
> 数据范围：$n\le10,m\le 60$。

**思路分析**

考虑容斥，钦定得到的图可以分成 $i$ 个连通块，设这样的方案数为 $g_i$，再设得到的图恰好有 $j$ 个连通块的方案数为 $f_j$。

那么我们能得到：
$$
g_i=\sum_{j\ge i}\begin{Bmatrix}j\\i\end{Bmatrix}f_j
$$
其中 $\begin{Bmatrix}j\\i\end{Bmatrix}$ 为第二类斯特林数，根据斯特林反演得到：
$$
f_j=\sum_{i\ge j}(-1)^{i-j}\begin{bmatrix}j\\i\end{bmatrix}g_i
$$
那么我们的答案就是 $f_1$，带入 $j=1$ 得到答案为 $\sum_{i}(-1)^{i-1}(i-1)!g_i$。

因此我们只要求出 $g_i$，考虑枚举最终的连通块形态，即枚举把 $1\sim n$ 划分成 $i$ 个集合的所有方案，对所有的 $i$，枚举量是贝尔数级别的。

对于每一种方案，就是要钦定集合之间的每条边都在偶数个图里出现过，如果把这些边看成 $01$ 位，我们求实要数异或和为 $0$ 的子集个数，可以线性基解决。

时间复杂度 $\mathcal O(\mathrm{Bell}(n)n^2m)$。

> 一些思考：我们注意到最终 $g_i$ 的容斥系数是 $(-1)^{i-1}(i-1)!$，这个系数在“集合不相等容斥”中似曾相识，他们之间是否有深层的关系？
>
> 事实上是有的，我们在“集合不相等容斥”里的系数实际上是：$i$ 个点的完全图，对于每一种连通边集 $E$，$(-1)^{|E|}$ 的和，我们考虑证明这个值等于 $(-1)^{i-1}(i-1)!$。
>
> 我们对 $E$ 连通边集的限制施加这个容斥，那么 $g_x$ 就是分成 $x$ 个点集后，选出的边集 $E$ 一定在每个点集内部连边，$(-1)^{|E|}$ 的和。
>
> 我们发现只要 $E$ 可选的边 $\ge 1$ 条，其贡献总是会正负抵消，因此 $g_x$ 只在 $x=i$ 时非零，且此时恰有 $g_x=1$，那么我们就得到了这个容斥系数就是 $(-1)^{i-1}(i-1)!$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,a[10],g[65][10][10];
ll X[65],fac[65],pw[65],ans=0;
struct bas {
	int cnt;
	ll b[65];
	void init() { cnt=0,memset(b,0,sizeof(b)); }
	void ins(ll x) {
		for(int i=45;~i;--i) if(x>>i&1) {
			if(!b[i]) return b[i]=x,++cnt,void();
			x^=b[i];
		}
	}
}	B;
void calc(int k) {
	B.init(),memset(X,0,sizeof(X));
	for(int i=0;i<n;++i) for(int j=i+1;j<n;++j) if(a[i]!=a[j]) {
		for(int o=0;o<m;++o) X[o]=X[o]<<1|g[o][i][j];
	}
	for(int o=0;o<m;++o) B.ins(X[o]);
	ans+=(k&1?1:-1)*fac[k-1]*pw[m-B.cnt];
}
void dfs(int i,int c) {
	if(i==n) return calc(c);
	for(a[i]=1;a[i]<=c+1;++a[i]) dfs(i+1,max(a[i],c));
}
signed main() {
	for(int i=fac[0]=pw[0]=1;i<64;++i) fac[i]=fac[i-1]*i,pw[i]=pw[i-1]*2;
	ios::sync_with_stdio(false);
	cin>>m;
	for(int o=0;o<m;++o) {
		string s; cin>>s;
		while(n*(n-1)/2!=(int)s.size()) ++n;
		for(int i=0,k=0;i<n;++i) for(int j=i+1;j<n;++j) g[o][i][j]=s[k++]-'0';
	}
	dfs(0,0);
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：Laoshan_PLUS (赞：0)

# [BZOJ4671 异或图](https://www.luogu.com.cn/problem/P10591)

我们仍然尝试去寻找能用反演来简化运算的方法。突破口就在于题目所给的 “连通图”。所谓连通图就是连通块的个数只有 $1$，也就是 “恰好”，那么考虑使用反演将 “恰好” 转化为 “钦定”。

具体而言，设 $G(n)$ 表示子集异或后恰好有 $n$ 个连通块的方案数，$F(n)$ 表示子集异或后钦定有 $n$ 个连通块的方案数。由于我们需要把点分成若干块，符合斯特林数的定义，所以有
$$
F(n)=\sum_{i=n}^N{i\brace n}G(i)
$$
所以使用斯特林反演，得到
$$
G(n)=\sum_{i=n}^N(-1)^{i-n}{i\brack n}F(i)
$$
由于我们需要的是 $G(1)$，所以代入 $n=1$ 得
$$
G(1)=\sum_{i=1}^N(-1)^{i-1}(i-1)!F(i)
$$
现在需要求 $F(i)$。发现我们只有 $10$ 个点，而爆搜将 $10$ 个点分成若干子集的方案数为 $B_{10}$ 种，其中 $B_n$ 是贝尔数，可以接受。那么每当我们搜出一种划分方案时，根据定义，不同连通块之间不能有边，连通块之间可任意选择。找到给定的 $s$ 张图中连接不同连通块的这些边，将每张图的这些边状压到一个二进制数上，那么现在就要求选择任意张图使其这些边的异或和为 $0$ 的方案数。

考虑使用线性基解决这个问题，将每张图的二进制数插入线性基。发现我们实际上要求的是一些个异或线性方程组自由元的个数，根据线性基的性质，上述的方案数就是 $2^{s-k}$，其中 $k$ 是线性基的大小。然后代入上文公式即可求解。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll=long long;
int s,n;
bool G[61][11][11];
int fac[11],a[11];
ll ans;
void init(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i;
}
struct{
	ll p[64];
	int sz;
	void ins(ll x){
		for(int i=63;~i;i--){
			if(!(x>>i)) continue;
			if(!p[i]) return p[i]=x,sz++,void();
			x^=p[i];
		}
	}
	void clear(){
		memset(p,0,sizeof p);
		sz=0;
	}
}LB;
void dfs(int now,int tp){
	if(now>n){
		LB.clear();
		for(int i=1;i<=s;i++){
			int ct=0;
			ll S=0;
			for(int j=1;j<=n;j++)
				for(int k=j+1;k<=n;k++)
					if(a[j]!=a[k])
						S|=(1ll<<ct++)*G[i][j][k];
			LB.ins(S);
		}
		ans+=fac[tp-1]*(1ll<<(s-LB.sz))*((tp-1)&1?-1:1);
		return;
	}
	for(int i=1;i<=tp+1;i++){
		a[now]=i;
		dfs(now+1,max(i,tp));
	}
}

int main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>s;
	for(int i=1;i<=s;i++){
		string g;
		cin>>g;
		while(n*(n-1)>>1!=(int)g.size()) n++;
		int p=0;
		for(int j=1;j<=n;j++)
			for(int k=j+1;k<=n;k++)
				G[i][j][k]=g[p++]-'0';
	}
	init(n);
	dfs(1,0);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

哦哦斯特林反演哦哦。

设 $g_i$ 为，最终图有 $i$ 个连通块的方案数。$f_i$ 为，钦定有 $i$ 个连通块的方案数（即，你将其强制划分为 $i$ 个连通块让他们之间没有连边）。

根据定义写出：

$$
f_i = \sum_{j = i}^n g_j {j \brace i}
$$

略加反演有：

$$
g_i = \sum_{j=i}^n f_j (-1)^{j-i} {j \brack i}
$$

你要求 $g_1$，所以就是：

$$
\sum_{j=1}^n f_j (-1)^{j-1} (j-1)!
$$

所以只用算 $f_i$。

考虑直接爆搜，贝尔数复杂度。然后得到 $O(n^2)$ 条限制，将他们进行高斯消元即可。高斯消元复杂度为 $O(s^2)$（推荐使用线性基进行动态高斯消元）。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=65;
int n,m,ans,ok[MAXN][MAXN][MAXN],bs[MAXN],st[MAXN],frac[MAXN];
inline void insert(int eq) {ffor(i,0,m-1) if(eq&(1ll<<i)) {if(bs[i]) eq^=bs[i]; else return bs[i]=eq,void();}return ;}
void dfs(int dep,int stx) {
	if(stx==0) {
		memset(bs,0,sizeof(bs));
		ffor(i,1,dep-1) ffor(j,i+1,dep-1) ffor(x,1,n) if(st[i]&(1<<x-1)) ffor(y,1,n) if(st[j]&(1<<y-1)) {
			int eq=0;
			ffor(tc,1,m) if(ok[tc][x][y]) eq|=(1ll<<tc-1);
			insert(eq);
		}
		int cnt=0;
		ffor(i,0,m-1) if(!bs[i]) cnt++;
		if(dep%2==0) ans+=(1ll<<cnt)*frac[dep-2];
		else ans-=(1ll<<cnt)*frac[dep-2];
		return ;
	}
	for(int S=stx;S;S=(S-1)&stx) if((S&-S)==(stx&-stx)) st[dep]=S,dfs(dep+1,stx-S);
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>m;
	frac[0]=1;
	ffor(i,1,15) frac[i]=frac[i-1]*i;
	ffor(tc,1,m) {
		string S;
		cin>>S;	
		ffor(N,1,10) if(N*(N-1)/2==S.size()) n=N;
		int tot=0;
		ffor(i,1,n) ffor(j,i+1,n) ok[tc][i][j]=ok[tc][j][i]=S[tot]-'0',tot++;
	}
	dfs(1,(1<<n)-1);
	cout<<ans;
	return 0;
}
```

---

## 作者：Ryan_Adam (赞：0)

## 题解：P10591 BZOJ4671 异或图
### Tag
斯特林反演，线性基。
### Solution
设 $f_i$ 为**至少**有 $i$ 个联通块的方案，联通块内连边随意，联通块与联通块之间无连边。设 $g_i$ 为**恰好**有 $i$ 个联通块的方案，联通块内连边随意，联通块与联通块之间无连边。

显然有：

$$f_x=\sum\limits_{i=x}^{n}\begin{Bmatrix}i\\x\end{Bmatrix}g_i$$

根据斯特林反演得到：

$$g_x=\sum\limits_{i=x}^{n}(-1)^{i-x}\begin{bmatrix}i\\x\end{bmatrix}f_i$$

所以：

$$\begin{aligned}
g_1&=\sum\limits_{i=1}^{n}(-1)^{i-1}\begin{bmatrix}i\\1\end{bmatrix}f_i\\
&=\sum\limits_{i=1}^{n}(-1)^{i-1}\,(i-1)!\,f_i\\
\end{aligned}$$

接下来问题就转换为了如何求 $f_i$。

状压一下每个点所在的联通块状态，而我们则要选择图集使联通块之间无边。考虑枚举不在同一联通块的两点之间的连边，加到线性基里，设 $e$ 表示线性基中元素，这些元素是不可被选择的，故答案为 $2^{n-e}$。

---


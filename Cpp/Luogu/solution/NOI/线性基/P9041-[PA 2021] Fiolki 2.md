# [PA 2021] Fiolki 2

## 题目描述

Byteasar 是一名化学家。你可能还记得，许多年前他因一项实验而闻名，该实验产生了一种特定的物质 X。由于上述物质根本没有解决人类的所有问题，这次他没有试图生产这种物质或找寻任何其他具体的解决方案——他只是在进行实验和评估其结果。

Byteasar 的实验室里有 $n$ 个样品瓶，用 $1$ 到 $n$ 的整数编号，这些样品瓶用 $m$ 根导管连接，物质可以从导管中流过。所有的样品瓶都处于两两不同的高度，液体只能通过导管往低处流。每根导管都有两端——第 $i$ 根导管的一端与编号为 $a_i$ 的样品瓶相连，另一端与编号为 $b_i$ 的样品瓶相连，我们知道编号 $a_i$ 的样品瓶比 $b_i$ 的样品瓶高。此外，每根导管都被一个导管夹夹住，以阻止物质的流动。Byteasar 可以在任何时候选择任何导管夹并打开它，让物质从样品瓶 $a_i$ 自由地流向样品瓶 $b_i$，在所有物质从一个样品瓶流向另一个样品瓶后，再夹住它。由于导管夹是机械式卡箍，保持其打开需要用力，因此在任何时候都只能打开一个导管夹。

编号为 $1$ 至 $k$ 的样品瓶含有危险化学品。这些样品瓶中的每一个都包含一种不同的物质。编号大于 $k$ 的样品瓶最初都是空的。

化学品是非常危险的，在任何情况下都不允许不同的物质混合在一起——这种混合的后果可能是灾难性的。由于流动的物质会留下微小的沉淀物，所以甚至不能让一种物质倒入以前装有任何其他物质的样品瓶中。

Byteasar 唯一能做的就是在样品瓶之间移动这些物质，确保没有两个物质混合。这并不是毫无意义的——通过以安全的方式运输物质，他可以把这些物质移到其他样品瓶中，这样更方便他研究它们的特性。

Byteasar 现在想选择一个区间 $[l, r]$，满足 $k < l \leq r \leq n$，然后他会将尽可能多的物质转移到该区间的任何编号的样品瓶中并继续测试那些方便放置的化学品。由于他不能决定哪个区间对他来说是最方便的，对于每个可能的区间 $[l, r]$，他想知道他能最多将多少种不同的物质转移到编号在区间 $[l, r]$ 的样品瓶中。我们用 $f(l, r)$ 来表示这个值。

请你帮 Byteasar 写一个程序，根据他的描述，计算对于区间 $[0, k]$ 中的每个 $x$，有多少个区间 $[l, r]$ 满足 $f(l,r) = x$。

## 说明/提示

对于 $100\%$ 的数据，$2 \leq n \leq 10^5$，$1 \leq m \leq 10^6$，$1 \leq k \leq \min(n - 1, 50)$，$1 \leq a_i \leq n$，$k < b_i \leq n$。

## 样例 #1

### 输入

```
9 10 2
1 3
1 5
2 5
5 4
5 6
2 6
2 9
2 8
1 5
1 9```

### 输出

```
1
9
18```

# 题解

## 作者：nullqtr_pwp (赞：10)

模拟赛不会 LGV 引理，喜提 $0\text{ pts}$。~~咋又是原题啊~~，被打爆了。

[前置知识 - LGV 引理](https://www.luogu.com.cn/problem/P6657)
 以及 [可能不需要知道的知识 - 行列式求值](https://www.luogu.com.cn/problem/P7112)。

注意到本题要求路径不能有点相交，需要想到 LGV 引理。

LGV 引理：对于起点集合 $s_1,s_2,\cdots,s_k$，到终点集合 $t_1,t_2,\cdots,t_k$。记录一条路径的权值是上面所有边的边权乘积乘上符号（$(-1)^{\sigma (p)}$，为排列 $p_i$ 的奇偶性），令 $e(i,j)$ 为 $s_i$ 到 $t_j$ 上所有路径的权值和。这样构成的行列式值是 $s_i\to t_j$ 所有不相交路径组的权值和。不严谨的证明是，存在相交的路径会通过逆序对被消掉（对排列 $p$ 的影响就是交换 $i,j$，那么一定会导致排列的奇偶性改变）。

你发现权值中 $(-1)^{\sigma (p)}$ 很烦，但是本题是判定【是否存在】，不需要数数。所以可以考虑选定一个大质数 $P$（本题取 $P=998244353$ 即可），然后对每条边赋一个 $[0,P-1]$ 的随机边权。直接重新称呼一条路径的权值是 $\prod w_i$。

无解时，求出来的行列式值一定 $=0$，有解极大概率 $\ne 0$。首先跑一遍 $e_{u,v}$ 表示起点为 $u$，终点为 $v$ 的所有路径的权值（即随机边权的乘积 $\bmod \text{ }p$）的和，这是 LGV 引理需要的。

这时处理询问，对于一个区间 $[l,r]$，考虑 $f(l,r)=k$ 是否成立。把前面写出来的 $e_{i,v}$ 写成，一个 $k$ 维向量为 $V(i)=\lbrace e_{1,i},e_{2,i},\cdots e_{k,i}\rbrace$，那么 $f(l,r)=k$ 就要求 $V(l)\sim V(r)$ 组成的线性空间是否满秩。再推下去，若 $f(l,r)=x$ 就相当于可以选出来 $x$ 个起点，$x$ 个终点，拉出来这些可以搞出来一个行列式 $\ne 0$ 的 $x\times x$ 矩阵，也就是说考虑 $V(l)\sim V(r)$ 组成的极大线性无关组大小为 $x$，也就是线性空间的维数 / rank。


直接插线性基复杂度还是带 $n^2$ 的，考虑使用时间戳线性基，用来维护区间线性基。在记录基底的基础上，维护加入的时间戳，每次更新的时候也需要维护每个基底对应的时间戳，越晚越好。

注意到 $f(l,r)$ 对于一组定的 $l$ 单调，对于询问，就是计数 $f(l,r)=x$，注意到答案值域仅为 $k$，求出所有分界点即可。对 $r$ 进行扫描线，更新线性基。每次拉出来所有时间戳排序然后相邻两两做差即可。


时间复杂度 $O(nk^2+mk)$。

[提交记录](https://loj.ac/s/2014715)

---

## 作者：Arghariza (赞：7)

乐乐乐，这个题目有点长，下面是简要题意：

> 给定一张 $n$ 个点的 DAG，保证点 $1\sim k$ 没有入度，对每个 $i\in [0,k]$，求出满足条件的区间 $[l,r]\subseteq (k,n]$ 的数量，使得起点在 $[1,k]$ 且终点在 $[l,r]$ 的极大不相交路径组大小为 $i$。

由于是 DAG，而且还是不相交路径，而且还是计数，想到 LGV 引理。

但是题目要求对极大不相交路径组（下面简称极大组）计数，LGV 引理只能对不相交路径组计数，寄。

若已经确定了极大组的大小 $i$ 以及起点集合 $S$，我们考虑对满足极大组大小 $\ge i$ 的 $[l,r]$ 计数：即存在一组不交路径，使得起点集合为 $S$ 且终点集合包含于 $[l,r]$。

判定转计数，施 LGV 引理，令每条边 $e$ 的边权为 $x_e$，每条路径 $p$ 的权值 $w(p)$ 为路径上所有边权之积。对于任意起点 $u$，终点 $v$，$M_{u,v}=\sum\limits_{p:u\to v}w(p)$。

注意到这个矩阵可以通过拓扑求出，矩阵内每个元素为一个 $m$ 元多项式。

那么 $[l,r]$ 满足条件的充要条件为：子矩阵 $M_{u\in S,l\sim r}$ 的列秩为 $i$，即可以从 $M$ 中选出 $i$ 个线性无关的列向量。

进一步转化条件，$[l,r]$ 极大组大小为 $i$ 的充要条件为：$M_{1\sim k,l\sim r}$ 的列秩为 $i$，即极大线性无关向量组大小为 $i$。

于是我们从左到右扫描线枚举 $r$，维护一个广义的线性基，每个基 $i$ 维护一个由 $k$ 个 $m$ 元多项式组成的向量 $l_i$ 以及插入时对应的 $p_i=r$，每次将 $M_{1\sim k,r}$ 插入。

若插入 $M_{1\sim k,r}$ 时线性相关，那么把 $p_i$ 最小的基替换掉；最后将基按照 $p_i$ 从大到小排序，左端点在 $(p_{i+1},p_i]$ 的 $[l,r]$ 的极大组的大小就为 $i+1$，依次加入答案数组即可。

最后还有一个问题，如果真的维护 $m$ 元多项式的话复杂度显然无法接受。因此我们找一个大质数 $P$，给每条边 $e$ 随机赋一个 $[1,P)$ 中的权值代表 $x_e$ 取这个值，求出乘积模 $P$ 意义下的结果即可。

根据某些[神秘的分析](https://blog.csdn.net/mutourend/article/details/104972541)，随机取值导致矩阵秩变小的概率为 $\frac{1}{P}$。

于是复杂度就变成了 $O(n^2k+mk)$。

```cpp
// Problem: P9041 [PA2021] Fiolki 2
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9041
// Memory Limit: 512 MB
// Time Limit: 10000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define eb emplace_back
#define pb pop_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> pi;
typedef tuple<int, int, int> tu;
bool Mbe;

mt19937 rnd(time(0));
const int P = 998244353;
const int N = 1e5 + 100;
const int K = 55;

ll ans[K];
int n, m, k, in[N], p[K];
vector<int> g[N];

int R() { return rnd() % (P - 1) + 1; }
void Mod(int &x) { x += x >> 31 & P; }
void Add(int &x, int y) { x += y - P, Mod(x); }
void Sub(int &x, int y) { x -= y, Mod(x); }

int qpow(int p, int q) {
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

struct L {
	int s[K];
	L () { memset(s, 0, sizeof(s)); }
	int& operator [] (int x) { return s[x]; }
	const int& operator [] (int x) const { return s[x]; }
	L& operator += (const L &y) { for (int i = 1; i <= k; i++) Add(s[i], y[i]); return *this; }
	L& operator -= (const L &y) { for (int i = 1; i <= k; i++) Sub(s[i], y[i]); return *this; }
	L& operator *= (const int &y) { for (int i = 1; i <= k; i++) s[i] = 1ll * s[i] * y % P; return *this; }
	friend L operator + (L x, const L &y) { return x += y, x; }
	friend L operator - (L x, const L &y) { return x -= y, x; }
	friend L operator * (L x, const int &y) { return x *= y, x; }
} f[N], b[K];

void ins(int id, L x) {
	for (int i = 1; i <= k; i++) {
		if (!x[i]) continue;
		if (!p[i]) return p[i] = id, b[i] = x, void();
		if (id > p[i]) swap(p[i], id), swap(b[i], x);
		x -= b[i] * (1ll * x[i] * qpow(b[i][i], P - 2) % P);
	}
}

void solve() {
	cin >> n >> m >> k;
	for (int i = 1, u, v; i <= m; i++)
		cin >> u >> v, g[u].eb(v), in[v]++;
	for (int i = 1; i <= k; i++) f[i][i] = 1;
	queue<int> q;
	for (int i = 1; i <= n; i++) 
		if (!in[i]) q.push(i);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int v : g[u]) {
			f[v] += f[u] * R(), in[v]--;
			if (!in[v]) q.push(v);
		}
	}
	for (int i = k + 1; i <= n; i++) {
		ins(i, f[i]); vector<int> pos;
		for (int j = 1; j <= k; j++) 
			if (p[j]) pos.eb(p[j]);
		sort(pos.begin(), pos.end(), greater<int> ());
		for (int j = 0, lst = i; j < pos.size(); j++) 
			ans[j] += lst - pos[j], lst = pos[j];
		if (!pos.empty()) ans[pos.size()] += pos.back() - k;
		else ans[0] += i - k;
	}
	for (int i = 0; i <= k; i++)
		cout << ans[i] << '\n';
}

bool Med;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen("1.in", "r", stdin);
		freopen("1.out", "w", stdout);
	#endif
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P9041)
## 题意

给定一个 $n$ 个点 $m$ 条边的 DAG，定义 $f(l,r)$ 表示最多选取多少条不相交路径 $(s_i,t_i)$ 满足 $s_i\in[1,k],t_i\in[l,r]$，其中不能有任意一点同时在两条选出的路径上。对 $\forall x\in[0,k)$ 求出有多少 $[l,r]\sube(k,n]$ 使得 $f(l,r)=x$。

$n\le 10^5$，$m\le 10^6$，$k\le\min(n-1,50)$。
## 思路

不相交路径，考虑 LGV 引理。

LGV 引理的内容是：指定起点 $s_{1\dots k}$ 和终点 $t_{1\dots k}$，令 $e_{i,j}$ 表示 $i\to j$ 的所有路径的边权乘积和，则 $\det(e_{s_i,t_j})$ 等于每个 $s_i\to t_{p_i}$ 的不相交路径组的权值和乘以 $(-1)^{\text{inv}(p)}$ 之和，其中 $p$ 是一个 $[1,k]$ 的排列；而我们需要解决的问题是：指定起点终点集合，从中任意匹配起点终点并要求存在匹配的起点终点之间的不相交路径，求最大匹配数。

注意到我们只需要判断存在性，我们可以指定一个大质数 $P=10^9+7$，给每条边随机赋上 $[0,P)$ 的权值，则 $f(l,r)$ 就等于矩阵 $e_{i,j}(i\in[1,k],j\in[l,r])$ 的秩，即 $e_{*,j}(j\in[l,r])$ 中最大可取出几组线性无关的向量，这个问题明显需要使用线性基解决。

我们可以使用拓扑排序求出我们需要的 $e_{i,j}$。扫描线扫右端点 $i$，对每个 $x\in[0,k)$ 求最大的 $l$ 使得 $f(l,i)=x$，扫描线加线性基有一个很经典的 trick：记录线性基内每个元素 $v_i$ 的加入时间 $t_i$，加入一个元素 $(v,t)$ 的时候，如果现在考虑到的位上 $i$ 的 $t_i<t$，则交换 $(v_i,t_i)$ 与 $(v,t)$。使用此 trick 便可解决本题。

总时间复杂度 $O(nk^2+mk)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
    
}
#define pii pair<int,int>
#define mpr make_pair
#define fir first
#define sec second
namespace rad{
    mt19937_64 R(chrono::system_clock::now().time_since_epoch().count());
    inline int Rand(int l,int r){
        uniform_int_distribution<int> distribution(l,r);
        return distribution(R);
    }
}using namespace rad;
const int N=1e5+10,K=50+2,mod=1e9+9;
namespace PolyC{
    #define Poly vector<int>
    inline int qpow(int x,int y){
        int res=1;
        while(y){
            if(y&1) res=1ll*res*x%mod;
            x=1ll*x*x%mod;
            y>>=1;
        }
        return res;
    }
    inline int add(int a,int b){
        return a+b>=mod?a+b-mod:a+b;
    }
    inline int dec(int a,int b){
        return a>=b?a-b:a+mod-b;
    }
    inline Poly operator+(const Poly &a,const Poly &b){
        Poly F=a;
        F.resize(max(a.size(),b.size()));
        for(int i=0;i<b.size();i++)
            F[i]=add(F[i],b[i]);
        return F;
    }
    inline Poly operator-(const Poly &a,const Poly &b){
        Poly F=a;
        F.resize(max(a.size(),b.size()));
        for(int i=0;i<b.size();i++)
            F[i]=dec(F[i],b[i]);
        return F;
    }
    inline Poly operator*(const Poly &a,const int &b){
        Poly F=a;
        for(int i=0;i<F.size();i++)
            F[i]=1ll*F[i]*b%mod;
        return F;
    }
}
using namespace PolyC;
int n,m,k,d[N];
Poly ct[N];
vector<pii>a[N];
inline void bfs(){
    queue<int>q;
    for(int i=1;i<=k;i++)
        ct[i][i-1]=1;
    for(int i=1;i<=n;i++)
        if(!d[i])
            q.push(i);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(auto tp:a[x]){
            int t=tp.fir,w=tp.sec;
            ct[t]=ct[t]+ct[x]*w;
            if(!--d[t]) q.push(t);
        }
    }
    for(int i=1;i<=n;i++)
        assert(!d[i]);
}
struct LnB{
    int tim[K];
    Poly v[K];
    inline void ins(Poly vt,int t){
        for(int i=0;i<k;i++){
            if(!vt[i]) continue;
            if(!tim[i]){
                tim[i]=t,v[i]=vt;
                return ;
            }else{
                if(tim[i]<t) swap(tim[i],t),swap(v[i],vt);
                int b=1ll*qpow(v[i][i],mod-2)*vt[i]%mod;
                vt=vt-v[i]*b;
            }
            assert(!vt[i]);
        }
    }
}L;
ll ans[K];
int main(){
    n=read(),m=read(),k=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        a[u].push_back(mpr(v,Rand(1,mod-1))),d[v]++;
    }
    for(int i=1;i<=n;i++)
        ct[i].resize(k);
    bfs();
    for(int i=k+1;i<=n;i++){
        L.ins(ct[i],i);
        vector<int>vec;
        for(int j=0;j<k;j++)
            if(L.tim[j])
                vec.push_back(L.tim[j]);
        vec.push_back(k),vec.push_back(i);
        sort(vec.begin(),vec.end(),greater<int>());
        for(int j=0;j+1<vec.size();j++)
            ans[j]+=vec[j]-vec[j+1];
    }
    for(int i=0;i<=k;i++)
        write(ans[i]),putc('\n');
	flush();
}
```

---

## 作者：lalaouye (赞：2)

简要题意可以去看其他题解。

前置知识：LGV 引理。

看到这道题我们先考虑该怎么判定 $f(l,r)$ 是否等于 $x$。看完题面后很难不让人想到 LGV 引理（不相交路径，起点集 $S$ 和终点集 $T$）。但是 LGV 引理是用于计数的，放在这里似乎并不好用。但是我们可以 注意到，只要没有合法情况，那么矩阵行列式的结果一定为 $0$，而如果有合法情况，我们给每个边赋一个在 $[1,P-1]$ 内的权值，其中 $P$ 表示一个大质数，那么如果有合法情况，则行列式的值有极大概率不为 $0$。

那么现在判定 $f(l,r)=k$ 是简单的。但是怎么对于 $f(l,r)=x$ 判定呢？我们考虑矩阵的条件是什么。

行列式的基本性质告诉我们，如果一个矩阵存在两行（列）成比例则 $\det(A)=0$。这告诉我们，如果这个矩阵存在线性相关，那么行列式结果一定是零。所以 $f(l,r)=x$ 当且仅当矩阵的矩阵的秩等于 $x$。

那么我们可以套路的想到扫描线，枚举每个 $r$，对于每个 $x$ 求最大的 $l$ 满足 $f(l,r)=x$，然后我们考虑使用线性基，贪心的对于每个基底选择出现时间最晚的基底，然后就可以解决本题了！

时间复杂度 $\mathcal{O}(nk^2+mk)$。

代码：

````
#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i = l; i <= r; ++ i)
#define rrp(i, l, r) for (int i = r; i >= l; -- i)
#define id(x, y) ((x - 1) * n + y)
#define eb emplace_back
#define inf 1000000050
#define linf 10000000000000000
#define pii pair <int, int>
#define ls (p << 1)
#define rs (ls | 1)
using namespace std;
constexpr int N = 2e6 + 5, M = 50 + 5, P = 1042702009;
typedef long long ll;
inline ll rd () {
  ll x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) { if (ch == '-') f = -1; ch = getchar (); }
  while (isdigit (ch)) { x = (x << 1) + (x << 3) + ch - 48; ch = getchar (); }
  return x * f;
}      
int qpow (int x, int y) {
  int ret = 1;
  for (; y; y >>= 1, x = x * x % P) if (y & 1) ret = ret * x % P;
  return ret;
}
int n, m, k;
int deg[N];
vector <pii> e[N];
class Poly {
  public:
    int c[M];
    friend Poly operator + (const Poly& a, const Poly& b) {
      Poly c;
      rep (i, 1, 50) c.c[i] = (a.c[i] + b.c[i]) % P;
      return c;
    }
    friend Poly operator - (const Poly& a, const Poly& b) {
      Poly c;
      rep (i, 1, 50) c.c[i] = (a.c[i] - b.c[i]) % P;
      return c;
    }
    friend Poly operator * (const Poly& a, const int& b) {
      Poly c;
      rep (i, 1, 50) c.c[i] = a.c[i] * b % P;
      return c;
    }
} f[N];
void topo () {
  queue <int> q;
  rep (i, 1, k) {
    f[i].c[i] = 1;
  }
  rep (i, 1, n) if (! deg[i]) q.push (i);
  while (! q.empty ()) {
    int u = q.front ();
    q.pop ();
    for (auto p : e[u]) {
      int v = p.first, w = p.second;
      f[v] = f[v] + f[u] * w;
      if (! -- deg[v]) q.push (v);
    }
  }
}
int tim[N];
Poly vt[N];
void insert (Poly x, int t) {
  rep (i, 1, k) {
    if (! x.c[i]) continue;
    if (! tim[i]) {
      tim[i] = t, vt[i] = x;
      return ;
    } else {
      if (tim[i] < t) swap (tim[i], t), swap (vt[i], x);
      int div = qpow (vt[i].c[i], P - 2) * x.c[i] % P;
      rep (j, 1, k) (x.c[j] -= vt[i].c[j] * div) %= P;
    }
  }
}
vector <int> vec;
int ans[M];
signed main () {
  mt19937 rnd (time (NULL));
  n = rd (), m = rd (), k = rd ();
  rep (i, 1, m) {
    int u = rd (), v = rd ();
    e[u].eb (pii (v, rnd () % (P - 1) + 1)); ++ deg[v];
  }
  topo ();
  rep (i, k + 1, n) {
    insert (f[i], i);
    rep (j, 1, k) if (tim[j]) vec.eb (tim[j]);
    vec.eb (k), vec.eb (i);
    sort (vec.begin (), vec.end (), greater <int> ());
    for (int j = 0; j + 1 < vec.size (); ++ j) ans[j] += vec[j] - vec[j + 1];
    vec.clear ();
  }
  rep (i, 0, k) printf ("%lld\n", ans[i]);
}
````

---

## 作者：littlez_meow (赞：2)

[题目指路](https://www.luogu.com.cn/problem/P9041)。

### 题意

给定一个有向无环图，$1\sim k$ 为源点，定义 $f(l,r),k<l\le r\le n$ 表示起点在 $1\sim k$，终点在 $l\sim r$ 间的最大的点不相交路径组大小。对于所有 $t\in[0,k]$，求出 $f(l,r)=t$ 的 $(l,r),l\le r$ 有序数对个数。

### 思路

不相交路径，考虑 LGV 引理。

但是本题是判断是否有解，而不是计数。发现有解的时候行列式肯定不为 $0$，因此考虑随机赋权，对一个大质数 $P$ 取模，若无解则为 $0$，有解则大概率（概率为 $\dfrac{P-1}P$）不为 $0$。

考虑行列式的向量意义，表示每一列（或行）组成的向量组是否线性无关。

记向量 $E(i)=[e(1,i),e(2,i),\cdots,e(k,i)]^T$，则 $f(l,r)$ 表示 $\{e(l),e(l+1),\cdots,e(r)\}$ 的极大线性无关向量组大小，也就是线性基大小。

考虑从左到右对 $r$ 扫描线。发现随 $l$ 逐渐变左答案会变大，且值域为 $[1,k]$。这代表我们可以维护值的分界点。而值会出现分界当且仅当左边那个线性无关。因此，维护线性基中每个元素的编号，并且用最新的编号取替换可替换的，这些编号就是答案分的段。

时间复杂度 $O(nk^2+mk)$，前半个是维护线性基，后半个是拓扑排序求 $e(u,v)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define fir first
#define sec second
using namespace std;
const int MAXN=1e5+1,MOD=1e9+7,MAXK=51;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
}
int n,m,k;
vector<int>g[MAXN];
int deg[MAXN];
int chro[MAXK];
struct Vec{
	int val[MAXK];
	Vec operator+(const Vec&qwq){
		Vec res=qwq;
		F(i,1,k){
			int&qaq(res.val[i]);
			qaq+=val[i],qaq>=MOD&&(qaq-=MOD);
		}
		return res;
	}
	Vec operator-(const Vec&qwq){
		Vec res=*this;
		F(i,1,k){
			int&qaq(res.val[i]);
			qaq-=qwq.val[i],qaq<0&&(qaq+=MOD);
		}
		return res;
	}
	Vec operator*(ll x){
		Vec res;
		F(i,1,k) res.val[i]=val[i]*x%MOD;
		return res;
	}
};
Vec e[MAXN],xxj[MAXK];
inline void topsort(){
	queue<int>qu;
	mt19937 gen(time(0)^*new int);
	uniform_int_distribution<>rnd(1,MOD-1);
	F(i,1,k) e[i].val[i]=1;
	F(i,1,n) !deg[i]&&(qu.push(i),1);
	while(!qu.empty()){
		int now=qu.front();
		qu.pop();
		for(auto i:g[now]){
			e[i]=e[i]+e[now]*rnd(gen);
			!(--deg[i])&&(qu.push(i),1);
		}
	}
	return;
}
inline void ins(int ti){
	Vec qwq=e[ti];
	F(i,1,k){
		if(!qwq.val[i]) continue;
		if(!chro[i]){
			xxj[i]=qwq,chro[i]=ti;
			break;
		}
		chro[i]<ti&&(swap(chro[i],ti),swap(qwq,xxj[i]),1);
		qwq=qwq-xxj[i]*(qpow(xxj[i].val[i],MOD-2)*qwq.val[i]%MOD); 
	}
	return;
}
ll ans[MAXK];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	F(i,1,m){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		++deg[v];
	}
	topsort();
	F(i,k+1,n){
		ins(i);
		int now[MAXK+1],cnt=0;
		now[0]=k;
		F(j,1,k) chro[j]&&(now[++cnt]=chro[j]);
		sort(now+1,now+cnt+1);
		now[cnt+1]=i;
		F(j,0,cnt) ans[cnt-j]+=now[j+1]-now[j];
	}
	F(i,0,k) cout<<ans[i]<<"\n";
	return 0;
} 
```

---

## 作者：tzl_Dedicatus545 (赞：2)

来点不那么意识流的 sol。。。

首先看到这个路径不相交，很难想到使用 LGV 引理处理这件事，诶但是虽然你只要判定，但是 LGV 引理如果正负抵消了就全错了对吧（注意这个题即使 $\sigma\neq \{1,2,3,\cdots,n\}$ 也是可能不相交的）

诶那你可能已经聪明的想到给每个边赋一个 $[0,P)$ 的随机权值了，$P$ 是一个很大的**不一定是质数**，然后如果最后矩阵的行列式是 $0$ 我们就认为它寄了。

诶一个矩阵行列式是 $0$ 的充要条件是：把它的所有行（列）向量拉出来，它们**非**线性相关，具体证明详见你的线性代数教材。

我们不妨记 $w(i,j)$ 是 $i\to j$ 的所有 path 的权值和。

我们不妨设你在判定 $[l,r]$，那 $[l,r]$ 合法的正确率很高的充要条件就是

$
\begin{pmatrix}
w(1,l) & w(1,l+1) & \cdots & w(1,r)\\
w(2,l) & w(2,l+1) & \cdots & w(2,r)\\
\vdots & \vdots & \ddots & \vdots\\
w(k,l) & w(k,l+1) & \cdots & w(k,r)\\
\end{pmatrix}
$

中存在 $i$ 个**列向量**线性无关，这是因为，不存在显然不合法，存在的话你总能在 $k$ 个起点中选出 $i$ 个。

最后你枚举 $l$，扫描 $r$，中途维护一个线性基状物就行了。

复杂度 $\Theta(nk^2+mk)$ 错误率（大概）是 $\dfrac{n}{P}$。

所以为什么我用记号 $P$ 呢，因为这样方便你求逆元喵。

---

## 作者：liyixin0514 (赞：1)

# [P9041 [PA2021] Fiolki 2](https://www.luogu.com.cn/problem/P9041)

[可能更好的阅读体验](https://www.cnblogs.com/liyixin0514/p/18650638)

## 题意

给一个 $n$ 个点 $m$ 条边的 DAG 和一个常数 $k$。

定义 $f(l,r)$ 表示最多选择不相交路径条数，满足起点 $s\in[1,k]$，终点
 $t\in[l,r]$。对所有的 $x\in[0,k]$，求出有多少 $[l,r] \subseteq (k,n]$ 使得 $f(l,r)=x$。
 
$n\le 10^5,m\le 10^6,k\le \min(50,n-1)$。

## 思路

即起点集合定了，问几个区间作为终点集合，使得不相交路径条数为 $x$。

------

考虑一个弱化问题，对于一个大小为 $x$ 的起点集合和同样大小的终点集合，我们需要判断出不相交路径条数是否为 $x$。

不相交路径使我们想到 LGV 引理。但是 LGV 引理求的是对于这样的起点和终点集合，每一组不相交路径的贡献乘上一个 $-1$ 的若干次方的和。我们要的是对于这样的起点和终点集合，是否存在一组不相交路径。

> 插播：由于起点只有 $50$ 个，因此方阵大小是 $50 \times 50$ 的，求方阵需要求 $e(s_i,t_j)$ 表示从 $s_i$ 到 $t_j$ 的所有路径权值之和（一条路径的权值定义为路径所有边权之积）。这个可以 $O(m)$ 做。

如果不存在，算的行列式一定为 $0$，反之不一定。

于是我们可以给每个边随机赋边权，乘法对大质数取模。根据那个 Schwartz–Zippel引理，我不会的，反正根据直觉这样大概率就是对的。

------

> 行列式是否为零，等同于方阵是否满秩。

对于终点集合比起点集合大的情况怎么办呢？

还是设起点集和大小为 $x$，要判定是否存在 $x$ 条不相交路径。

> 朴素做法是枚举终点集合中 $x$ 个点出来。
>
> 想到[比内柯西公式](https://www.cnblogs.com/liyixin0514/p/18648007)。不过好像没关系嘻嘻。

相当于问终点集合是否存在 $x$ 个点，使得方阵行列式非零。

虽然矩阵没有行列式，但是我们可以直接求矩阵是否满秩。解决了。预处理矩阵 $O(nk+mk)$。

------

回到原问题：起点集合大小为 $k$，终点集合大小任意。问最多的不相交路径数。

就是问最多选择多大的方阵使得行列式非零，相当于问矩阵的秩是多少。

求矩阵的秩，就是求矩阵所有行向量的线性基是多大。

我们枚举终点集合（复杂度 $O(n^2)$）的话，把终点集合作为矩阵的行，动态维护线性基比较方便。每次插入或者删除一个终点就是插入或者删除一个长度为 $k$ 的向量。

维护时间戳线性基，就可以支持插入和删除了。具体地，扫描终点集合的右端点，每个基维护一个时间，插入新基的时候，尽量用时间晚的基替代早的基。查询线性基大小的时候只算时间符合要求的基。

线性基一次插入是 $O(k^2)$ 的。

------

枚举终点集合太慢辣！

固定终点集合的右端点 $r$，显然 $f(l,r)$ 是关于 $l$ 单调递减的。

因此可以对线性基里面所有基的时间排序，这样一共有 $O(k)$ 个时间节点，把 $l$ 分成 $O(k)$ 段，每段的 $f(l,r)$ 都是一样的。

时间复杂度 $O(nnk^2+mk)$。瓶颈在于插入 $n$ 次线性基和预处理矩阵。

## code

```cpp
#include<bits/stdc++.h>
#define sf scanf
#define pf printf
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
namespace pragmatic {
    constexpr int N=1e5+7,K=55,M=1e6+7,mod=1e9+7;
    int add(int a,int b) { return a+b>=mod ? a+b-mod : a+b; }
    void _add(int &a,int b) { a=add(a,b); }
    int mul(int a,int b) { return 1ll*a*b%mod; }
    void _mul(int &a,int b) { a=mul(a,b); }
    int n,m,k;
    int u,v;
    vector<int> to[N];
    int e[N][K];
    mt19937 rd(random_device{}());
    int in[N];
    void init() {
        queue<int> q;
        rep(i,1,n) if(!in[i]) q.push(i);
        rep(i,1,k) e[i][i]=1;
        while(!q.empty()) {
            int u=q.front();
            q.pop();
            for(int v : to[u]) {
                int val=add(mod,rd()%mod);
                rep(i,1,k) _add(e[v][i],mul(e[u][i],val));
                if(!--in[v]) q.push(v);
            }
        }
    }
    int ksm(int a,int b=mod-2) {
        int s=1;
        while(b) {
            if(b&1) _mul(s,a);
            _mul(a,a);
            b>>=1;
        }
        return s;
    }
    ll ans[N];
    int p[K][K];
    int tim[K];
    void insert(int *x,int t) {
        rep(i,1,k) if(x[i]) {
            if(!p[i][i]) {
                memcpy(p[i]+i,x+i,sizeof(int)*(k-i+1));
                tim[i]=t;
                return;
            }
            if(t>tim[i]) {
                swap(tim[i],t);
                rep(j,i,k) swap(p[i][j],x[j]);
            }
            int tmp=mul(x[i],ksm(p[i][i]));
            rep(j,i,k) _add(x[j],mod-mul(tmp,p[i][j]));
        }
    }
    void main() {
        sf("%d%d%d",&n,&m,&k);
        rep(i,1,m) sf("%d%d",&u,&v), to[u].push_back(v), in[v]++;
        init();
        rep(r,k+1,n) {
            insert(e[r],r);
            vector<int> vec;
            rep(j,1,k) if(tim[j]) vec.push_back(tim[j]);
            int la=k;
            sort(vec.begin(),vec.end());
            int cnt=vec.size();
            for(int j : vec) ans[cnt--]+=j-la,la=j;
            ans[cnt]+=r-la;
        }
        rep(i,0,k) pf("%lld\n",ans[i]);
    }  
}
int main() {
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("my.out","w",stdout);
    #endif
    pragmatic :: main();
}
```

---

## 作者：Grisses (赞：0)

这次加句号了。

---

发现要求所有路径不相交，自然想到 lgv 引理。

如果不会去看[模板](https://www.luogu.com.cn/problem/P6657)。

考虑先 $O(k(n+m))$ 求出 $k+1$ 到 $n$ 所有位置对应的向量，记点 $i$ 对应的向量为 $v_i$，我们本质是求每一个区间 $[l,r]$ 中所有向量的线性基大小。

暴力求解显然是行不通的。

考虑对线性基内的每一个向量记录其插入的时间，如果现在插入的向量 $v_n$ 的时间晚于这个位置的向量 $v_p$，我们就将这 $v_n$ 放在此处，再将消去最高项的 $v_p$ 继续插入。这样做之后，我们考虑刚插入第 $i$ 给向量后的线性基，每一个存在与线性基中的时间 $t_i$ 都表明以当前 $i$ 作为右端点，$t_i$ 及其之前的左端点会多存在一个向量。所以每次插完一个向量就把所有 $k$ 个时间拿出来更新答案就可以了。

总复杂度 $O(k(n+m)+nk^2)$。

---

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define db long double
using namespace std;
const int mod=998244353;
mt19937_64 Rand(time(0));
int fpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
int c[4005],inc[4005];
int C(int n,int m){
	if(n<0||m<0||n<m)return 0;
	return c[n]*inc[n-m]%mod*inc[m]%mod;
}
int n,m,k,in[100005],dp[100005],ans[55];
vector<int>a[100005];
vector<pair<int,int> >g[100005];
void init(int x){
	for(int i=1;i<=n;i++){
		for(auto v:g[i])in[v.first]++;
		dp[i]=0;
	}
	dp[x]=1;
	queue<int>q;
	for(int i=1;i<=n;i++)if(!in[i])q.push(i);
	while(!q.empty()){
		int tmp=q.front();
		q.pop();
		for(auto v:g[tmp]){
			dp[v.first]=(dp[v.first]+dp[tmp]*v.second%mod)%mod;
			in[v.first]--;
			if(!in[v.first])q.push(v.first);
		}
	}
	for(int i=1;i<=n;i++)a[i].push_back(dp[i]);
}
vector<int>bas[55];
int tim[55];
void insert(vector<int>a,int t){
	for(int i=0;i<k;i++){
		if(!a[i])continue;
		if(!tim[i]){
			bas[i]=a;
			tim[i]=t;
			return;
		}
		else{
			if(t>tim[i])swap(a,bas[i]),swap(tim[i],t);
			int p=(mod-a[i]*fpow(bas[i][i],mod-2)%mod);
			for(int j=0;j<k;j++)a[j]=(a[j]+p*bas[i][j]%mod)%mod;
		}
	}
}
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1,u,v;i<=m;i++)scanf("%lld%lld",&u,&v),g[u].push_back(make_pair(v,Rand()%mod));
	for(int i=1;i<=k;i++){
		init(i);
	}
	for(int i=k+1;i<=n;i++){
		insert(a[i],i);
		vector<int>pos;
		for(int j=0;j<k;j++)if(tim[j])pos.push_back(tim[j]);
		pos.push_back(k);
		pos.push_back(i);
		sort(pos.begin(),pos.end(),[&](int x,int y){return x>y;});
		for(int j=0;j<pos.size()-1;j++)ans[j]+=pos[j]-pos[j+1];
	}
	for(int i=0;i<=k;i++)printf("%lld\n",ans[i]);
    return 0;
}
```

---


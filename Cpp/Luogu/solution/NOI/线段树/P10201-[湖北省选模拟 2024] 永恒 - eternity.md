# [湖北省选模拟 2024] 永恒 / eternity

## 题目背景

总有地上的生灵，敢于直面雷霆的威光。

## 题目描述

稻妻的地图可以被划分为 $N$ 行 $M$ 列的网格，第 $i$ 行第 $j$ 列的区域用 $(i,j)$ 表示。曾经，每一块区域中都有一位神之眼拥有者，其元素力编号为 $c_{i,j}$（$0 \le c_{i,j} \le 9$）。

雷电将军降下雷霆的威光，收缴了一部分神之眼。神之眼被收缴的区域，被称为**雷电封锁区**，其他区域称为**非雷电封锁区**。由于你反对眼狩令而遭到通缉，你不能进入**雷电封锁区**，也无法离开稻妻地图区域。

你正在积蓄力量，你可以在**相邻的非雷电封锁区**自由移动。假设你现在在 $(i,j)$，你可以移动到 $(i+1,j),(i-1,j),(i,j+1),(i,j-1)$ 四个区域中的任意一个**非雷电封锁区**。在一次移动中，你积蓄的力量为，经过的所有区域的神之眼元素力编号**依次相连**，对 $1\ 145\ 141$ 取模的结果。例如，你经过的区域神之眼元素力编号依次为 $3,1,0,3,3,3,2,1$，那么你积蓄的力量为 $31033321 \bmod 1145141 = 114514$。**请注意，你的一次移动可以经过相同的非雷电封锁区。重复经过相同的非雷电封锁区将重复积蓄力量。**

常道恢宏，鸣神永恒。永恒的愿望终为南柯一梦，变化的趋势岂可阻挡。稻妻会随时间发生变化。在 $1\sim Q$ 秒，每秒发生了一个事件，事件有如下两种：

- `1 x y c`：若 $c$ 为 `#`，表示 $(x,y)$ 的神之眼已经**被收缴**，$(x,y)$ 为雷电封锁区；若 $c$ 为数字字符，则表示 $(x,y)$ 的神之眼拥有者重获元素力编号为 $c$ 的神之眼，或其神之眼元素力编号变化为 $c$，$(x,y)$ 为非雷电封锁区。

- `2 sx sy tx ty v`：请判断是否存在由 $(sx,sy)$ 出发，到达 $(tx,ty)$ 的移动方式，使得你积蓄了恰好为 $v$ 的力量。保证 $(sx,sy)$ 与 $(tx,ty)$ 均为非雷电封锁区。

请回答全部事件 2，保证至少有一次事件 2。

## 说明/提示

### 样例解释 1

**请注意，全部样例输入中 $id$ 均为 $0$。**

对于第一组询问，$(1,1)\to (2,1)\to (2,2)\to (2,3)\to (2,4)\to (3,4)$。

对于第二组询问，$(5,1)\to (5,2)\to (4,2)\to (3,2)\to (3,1)$。

对于第三组询问，有雷电封锁区阻挡，显然无法到达。

对于第四组询问，$(5,1)\to (4,1)\to (3,1)\to (2,1)\to (1,1)\to (1,2)\to (1,3)\to (1,4)\to (1,5)$，权值为 $999119999 \bmod 1145141=557047$。

对于第五组询问，$(3,1)\to (4,1)\to (4,2)\to (4,3)\to (4,4)\to (4,3)\to (4,4)$ ，权值为 $9999999\bmod 1145141=838871$。

### 子任务

对于所有测试数据，保证 $1 \le n,m \le 500$，$1 \le Q \le 2\times10^5$，$1 \le x, sx, tx \le N$，$1 \le y,sy,ty \le M$，$0 \le v < 1145141$。输入的迷宫仅包含 `#` 和数字字符。

| 测试点编号 | $N,M \le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1\sim 2$ | $2$ | B |
| $3\sim 4$ | $500$ | A |
| $5\sim 6$ | $500$ | B,C |
| $7\sim 8$ | $500$ | C |
| $9\sim 11$ | $500$ | B,D |
| $12\sim 13$ | $500$ | D |
| $14\sim 17$ | $500$ | B |
| $18\sim 20$ | $500$ | 无 |

特殊性质 A：对于每一个询问，不存在合法方案，或存在不超过 $5$ 步的方案。

特殊性质 B：不存在操作 $1$。

特殊性质 C：任何时候所有非雷电封锁区的格子，上面的数字是 $0$。

特殊性质 D：任何时候所有非雷电封锁区的格子，上面的数字相同。

## 样例 #1

### 输入

```
5 5 5 0
19999
14519
99949
9999#
999#0
2 1 1 3 4 114514
2 5 1 3 1 99999
2 1 1 5 5 0
2 5 1 1 5 557047
2 3 1 4 4 838871```

### 输出

```
Yes
Yes
No
Yes
Yes```

## 样例 #2

### 输入

```
见选手目录下的 eternity/eternity2.in 与 eternity/eternity2.ans。```

### 输出

```
该样例符合测试点 9 ∼ 11 的限制。```

## 样例 #3

### 输入

```
见选手目录下的 eternity/eternity3.in 与 eternity/eternity3.ans。```

### 输出

```
```

# 题解

## 作者：Liuxizai (赞：6)

## Description

给一张 $n\times m$ 的网格，每个格子上有数字 $0\sim 9$ 或 $-1$，其中 $-1$ 表示该格子被封锁。可以在网格上走出一条路径，要求相邻格子四联通，可以经过相同格子，不可以经过被封锁的格子，路径的权值为将格子上的数字按顺序拼成十进制数并对 $P=1145141$ 取模的值。支持两种操作：

1. 修改一个格子上的数。
2. 查询是否存在从 $(sx,sy)$ 到 $(tx,ty)$、权值为 $v$ 的路径。

操作共 $q$ 次。

$1\le n,m\le 500,1\le q\le 2\times 10^5$

## Solution

若对网格黑白染色后，同色格上的数字相同，注意这包含了所有格子上的数都相同的情况，我们可以枚举黑白格子上的数字，然后 $O(P)$ 预处理出每个权值是否可达，询问时直接查表即可。也可以使用数学方法。

我们断言，除上述情况之外我们总能找到一组解。

考虑构造证明这一结论。

若「同色格上的数字相同」这一条件不满足，我们总是可以找到四联通的三个格子 $A,B,C$，对应数字分别为 $a,b,c$，满足 $a\ne c$。考虑从起点走到 $B$，然后走若干 $B\to A\to B$ 或 $B\to C\to B$，最后从 $B$ 走到终点。这里前后两段路径带来的权值都是常数，只要证明能在 $A,B,C$ 三个格子上走出任意权值，就证明了整条路径可以取到任何权值。

通过 $B\to A\to B$ 和 $B\to C\to B$ 构成的路径的权值形如 $\overline{b?b?b?b\dots b}$，其中 $?$ 表示 $a$ 或 $c$。令路径长度为 $2\times(P-1)\times(P-1)+1$，所有 $b$ 对权值的贡献是常数，每个 $?$ 的贡献为 $a$ 或 $c$ 乘上位权 $100^k$，其中 $k$ 取 $1\sim(P-1)\times(P-1)$。首先令 $?$ 都为 $a$，此时计算得到一个权值，接下来考虑将若干 $a$ 替换成 $c$，我们要证明这样可以将权值调整至任何数。注意我们有 $100^{P-1}\equiv 1\pmod P$，位权 $100^k$ 中满足 $(P-1)\mid k$ 的 $k$ 共有 $P-1$ 个，仅依靠这些位可以将路径的权值加上不超过 $P-1$ 个 $c-a$，由于 $a\ne c$ 且 $P=1145141$ 是质数，所以 $t(c-a)\bmod P,t\in[0,P-1]\cap\mathbb Z$ 可以取遍 $0\sim P-1$ 中的所有数，于是路径权值可以为任何数。

注意以上证明仅需 $P$ 是质数就可成立，不需要有关 $10$ 或 $10^2=100$ 的任何性质。

于是，对于每次查询，我们只需要判断起点和终点是否在同一个连通块，以及连通块内的同色格上数字是否相同即可。

由于会对格子的封锁状态进行修改，使用线段树分治 + 可撤销并查集维护，复杂度 $O(P+(nm+q)\log q\log nm)$，$P$ 来自预处理。

[Code](https://liuxizai.ac.cn/archives/solution-lg10201.html#Code)

---

## 作者：zyn_ (赞：5)

### 单次询问

#### Part 0

令 $P=1145141$。$(x,y)$ 处的神之眼的元素力编号为 $c_{x,y}$。考虑一次询问。如果 $(sx,sy),(tx,ty)$ 不连通（连通是相对于被雷电封锁区阻隔无法互通而言）则答案显然为否；如果 $(sx,sy)=(tx,ty)$ 且 $(sx,sy)$ 周围的四个相邻区域均为雷电封锁区或出了地图边界，那么积蓄的力量只能为 $c_{sx,sy}$，答案容易得出。

#### Part 1

如果 $(sx,sy),(tx,ty)$ 连通，则有以下结论成立：若地图**黑白交替染色**，**在 $(sx,sy),(tx,ty)$ 所在的连通块中**，以下性质（称作**元素性质**）满足：所有黑格中的神之眼的元素力**不全相同**，**或者**所有白格中的神之眼的元素力**不全相同**；则答案为是。事实上，此时从 $(sx,sy)$ 移动到 $(tx,ty)$ 积蓄的力量可以为任意 $0,1,\dots,P-1$ 中的值。

*下作证明：*

由连通块满足元素性质，知连通块中**存在 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，使 $(x_1,y_1)$ 与 $(x_2,y_2)$ 相邻，$(x_2,y_2)$ 与 $(x_3,y_3)$ 相邻，且 $c_{x_1,y_1}\neq c_{x_3,y_3}$**。考虑如下路径：

$$

(sx,sy),(p_1,q_1),(p_2,q_2),\dots,(p_{k_1},q_{k_1}),(x_2,y_2), \\
(x_{r_1},y_{r_1}),(x_2,y_2),(x_{r_2},y_{r_2}),\dots,(x_{r_d},y_{r_d}), \\
(x_2,y_2),(s_1,t_1),(s_2,t_2),\dots,(s_{k_2},t_{k_2}),(tx,ty)

$$

其中 $r_i=1$ 或 $3$。

现在**钦定** $k_1,k_2$，所有 $(p_i,q_i),(s_i,t_i)$，并令 $d=(P-1)^2=1311345619600$ 为定值。则路径长度已定，故以上路径的第一行部分与第三行部分，**对路径积蓄力量的贡献确定**。只需证明合理地取 $r_i$，可以使第二行对积蓄力量的贡献取到 $0,1,\dots,P-1$ 中的**任意数**。由于模数 $P=1145141$ 为质数，设 $f_i=c_{x_i,y_i}$，只需证以下数可以取 $0$ 至 $P-1$ 的所有值：

$$
S=\overline{f_{r_1}f_2f_{r_2}f_2\dots f_{r_{d-1}}f_2f_{r_d}}\bmod P
$$

首先，先令所有 $r_i=1$，得到一个 $S_0$。考虑调整一些 $r_i$ 为 $3$。当调整 $r_{(P-1)i}$ 为 $3$ 时（$i=1,\dots,P-1$），由**费马小定理**，$S$ 在模 $P$ 意义下增加了 

$$
10^{2(P-1-i)(P-1)}(f_3-f_1)\equiv f_3-f_1\pmod P
$$

由于 $f_1,f_3\in [0,6]$ 且 $f_1\neq f_3$ 知 $P\nmid f_3-f_1$。每将一个 $r_{(P-1)i}$ 调整为 $3$，$S$ 增加 $f_3-f_1$，且这样的调整有 $P-1$ 次机会。

因此 $S$ 可以取到 $S_0+z(f_3-f_1)$，其中 $z=0,1,
\dots,P-1$，而这是一个模 $P$ 的**完系**。

因此 $S$ 可以取 $0,1,\dots,P-1$ 之间的任意自然数。

*命题得证。*

#### Part 2

如果这个连通块不满足元素性质，也就是连通块中，所有黑格中的神之眼的元素力**全相同**，**并且**所有白格中的神之眼的元素力**全相同**，那么**不妨设 $(sx,sy)$ 为黑格**，设 $f=c_{sx,sy}$ 为连通块中黑格的神之眼的元素力编号，$g$ 为白格的神之眼的元素力编号。那么，从 $(sx,sy)$ 到 $(tx,ty)$ 积蓄的力量必然形如 $\overline{fg\dots fgf}\bmod P$ 或 $\overline{fg\dots fgfg}\bmod P$，**取决于 $(tx,ty)$ 为黑格或白格**。

对于给定的 $f,g$，经过奇数或偶数个格子可以积蓄出的力量集合 $L_{f,g,0/1}$ 是可以**预处理**的。以移动奇数步为例，从 $f$ 开始作为当前数，每次将当前数加入 $L_{f,g,1}$，然后将当前数乘 $100$ 加 $\overline{gf}$ 作为新的当前数。一旦发现加入了重复的数，则停止。这样的时间复杂度上限为 $O(P)$，有一个 $200$ 的超大常数，然而时限足够，不是问题。

由于模数为质数，可以证明任何在集合 $L_{f,g,0/1}$ 中的数，都有无穷种不同的步数可以走出它。因此查询时只要判断所需力量的值是否在对应集合中即可。

### 多次询问，带修

现在带上修改操作，考虑**线段树分治**。问题转化为，在合并连通块的过程中，维护：

1. 两点之间的连通性。
2. 一个连通块中是否满足元素性质。
3. 一个连通块**不**满足元素性质时，将地图黑白染色，黑格与白格的神之眼的元素力编号。

用并查集维护。连通性的维护较为简单。对于维护元素性质的部分（第 $2,3$ 条），在一个连通块中钦定**这个连通块的代表元格子为黑格**，维护类型 $tp_i$，黑格神之眼的元素力编号 $f_i$，白格神之眼的元素力编号 $g_i$。其中，当 $tp_i=1$ 时代表不满足元素性质，此时 $f_i,g_i$ 有效（若当前在并查集中代表元自成一个集合，则 $tp_i=1$，且 $g_i$ 无效）；$tp_i=2$ 时代表满足元素性质，$f_i,g_i$ 无效。

合并两连通块时：

1. 若有至少一个连通块大小为 $1$，进行分讨特判，较容易。
2. 若两个连通块大小都 $\ge 2$，且至少一个连通块的 $tp$ 为 $2$，则合并后 $tp$ 为 $2$。
3. 若两个连通块大小都 $\ge 2$，且 $tp$ 都为 $1$，此时合并后是否仍不满足元素性质，只取决于**两连通块的代表元格子 $(x_1,y_1),(x_2,y_2)$ 与 $f_1,g_1,f_2,g_2$ 的值**。若 $|x_1-x_2|+|y_1-y_2|$ 为偶数且 $(f_1,g_1)=(f_2,g_2)$，或 $|x_1-x_2|+|y_1-y_2|$ 为奇数且 $(f_1,g_1)=(g_2,f_2)$，则合并后 $tp$ 为 $1$，$f,g$ 容易得到。否则，合并后 $tp$ 为 $2$。

本题总时间复杂度 $O((nm+q)\log(nm))$。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define y1 y1_ //......
#define N 507
#define Q 200009
#define P 1145141
#define pii pair<int,int>
#define fi first
#define sc second
#define mpr make_pair
int n,m,q,a[N][N],lst[N][N],op[Q],x1[Q],y1_[Q],x2[Q],y2[Q],v[Q];
char c[N][N],d[10];
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
bool ok[P][10][10];
struct sg{int x,y,l,r,v;}k[Q<<2];int cnt;
inline int cv(char c){return c=='#'?-1:c-48;}
inline int co(int x,int y){return (x-1)*m+y;}
inline int clr(int x,int y){return (x+y)&1;}
inline int clr(int a){return ((a-1)/m+(a-1)%m)&1;}
int pa[N*N],h[N*N],f[N*N],g[N*N],t[N*N],siz[N*N];
//t==1, f!=-1 and g==-1: one grid
//t==2, f!=-1 and g!=-1: the two elements on the two color of grids
//t==3, f==-1 and g==-1: different elements on a color of grid
//f is element on its grid, g is element on other grids
int find(int p){
	while(pa[p]!=p)p=pa[p];
	return p;
}
struct mdf{char c;int p,n;};
struct data{
	int x,y,v;
	vector<mdf> s;
}ds[Q<<3];int num;
#define nwd ds[num]
#define ins ds[num].s.push_back
void merge(int a,int b,int i){//i is true means a and b have different color
	if(h[a]<h[b])a^=b^=a^=b;
	ins({'p',pa[b],b});pa[b]=a;
	if(h[a]==h[b])ins({'h',h[a],a}),++h[a];
	if(t[b]==1){
		if(t[a]==1){
			if(f[a]!=f[b]){
				if(siz[a]==1&&siz[b]==1)ins({'g',g[a],a}),g[a]=f[b],ins({'t',t[a],a}),t[a]=2;
				else ins({'t',t[a],a}),t[a]=3;
			}
			//else do nothing;
		}
		else if(siz[b]!=1||(i==0&&f[a]!=f[b])||(i==1&&g[a]!=f[b]))ins({'t',t[a],a}),t[a]=3;
		ins({'s',siz[a],a});siz[a]+=siz[b];	
		return;
	}
	if(i==1){if(t[b]==3||f[a]!=g[b]||g[a]!=f[b])ins({'t',t[a],a}),t[a]=3;}
	else{if(t[b]==3||f[a]!=f[b]||g[a]!=g[b])ins({'t',t[a],a}),t[a]=3;}
	ins({'s',siz[a],a});siz[a]+=siz[b];
}
void add(int x,int y,int v){
	++num;
	ds[num].x=x,ds[num].y=y,ds[num].v=v;
	ds[num].s.clear();
	static int z;z=co(x,y);
	pa[z]=z,h[z]=1,f[z]=v,g[z]=-1,t[z]=1,siz[z]=1;
	static int nx,ny;
	static int p1,p2;
	for(int i=0;i<4;++i){
		nx=x+dx[i],ny=y+dy[i];
		if(1<=nx&&nx<=n&&1<=ny&&ny<=m&&a[nx][ny]!=-1){
			p1=find(z),p2=find(co(nx,ny));
			if(p1!=p2)merge(p1,p2,clr(p1)^clr(p2));			
		}
	}
	a[x][y]=v;
}
void undo(){
	a[nwd.x][nwd.y]=-1;
	static mdf i;
	while(nwd.s.size()){
		i=nwd.s.back();
		if(i.c=='p')pa[i.n]=i.p;
		if(i.c=='h')h[i.n]=i.p;
		if(i.c=='g')g[i.n]=i.p;
		if(i.c=='t')t[i.n]=i.p;
		if(i.c=='f')f[i.n]=i.p;
		if(i.c=='s')siz[i.n]=i.p;
		nwd.s.pop_back();
	}
	--num;
}
int state(int d,int b,int v){
	//a and b disconnect: 0
	//a and b connect, same element on same color grid: 1 if has solution else -1
	//otherwise: 2 
	static int cd,cb;cd=find(d),cb=find(b);
	if(cd!=cb)return 0;
	if(t[cd]==3)return 2;
	static int x,y;x=(cd-1)/m+1,y=(cd-1)%m+1;
	if((a[x][y-1]==-1||y==1)&&(a[x][y+1]==-1||y==m)&&(a[x+1][y]==-1||x==n)&&(a[x-1][y]==-1||x==1)){
		//Special! A grid alone.
		if(a[x][y]==v)return 1;
		return -1;
	}
	if(t[cd]==2){
		if(clr(d)^clr(b)){
			if(clr(d)^clr(cd))return ok[v][g[cd]][f[cd]]?1:-1;
			else return ok[v][f[cd]][g[cd]]?1:-1;
		}
		else{
			if(clr(d)^clr(cd))return ok[(v-g[cd]+P)*1030627ll%P][g[cd]][f[cd]]?1:-1;
			else return ok[(v-f[cd]+P)*1030627ll%P][f[cd]][g[cd]]?1:-1;
		}
	}
	else{//t[cd]==1
		if(clr(d)^clr(b))return ok[v][f[cd]][f[cd]]?1:-1;
		else return ok[(v-f[cd]+P)*1030627ll%P][f[cd]][f[cd]]?1:-1;
	}
}
vector<sg> vc[Q<<2];
void upd(int pl,int pr,int p,sg s){
	if(s.l<=pl&&pr<=s.r){vc[p].push_back({s.x,s.y,pl,pr,s.v});return;}
	int mid=(pl+pr)>>1;
	if(s.l<=mid)upd(pl,mid,p<<1,s);
	if(s.r>mid)upd(mid+1,pr,p<<1|1,s);
}
void solve(int l,int r,int p){
	//1. update all changes in v[p]
	//2. if on segtree's leaf, calc answer
	//3. otherwise get into deeper level
	//4. undo the updates
	for(sg st:vc[p])add(st.x,st.y,st.v);
	if(l==r){
		if(op[l]==2)puts(state(co(x1[l],y1[l]),co(x2[l],y2[l]),v[l])>=1?"Yes":"No");
	}
	else{
		int mid=(l+r)>>1;
		solve(l,mid,p<<1);solve(mid+1,r,p<<1|1);
	}
	for(sg st:vc[p])undo();
}
int main(){
	//Inazuma is the country of Eternity.
	{
		int i,p;
		for(int j=0;j<=9;++j)for(int k=0;k<=9;++k){
			p=j*10+k;
			i=p;
			while(!ok[i][j][k])ok[i][j][k]=1,i=(i*100+p)%P;
		}
	}//prework
	scanf("%d%d%d%*d",&n,&m,&q);
	for(int i=1;i<=n;++i){
		scanf("%s",c[i]+1);
		for(int j=1;j<=m;++j){
			a[i][j]=cv(c[i][j]);
			lst[i][j]=(a[i][j]==-1?-1:0);
		}
	}
	for(int i=1;i<=q;++i){
		scanf("%d%d%d",&op[i],&x1[i],&y1[i]);
		if(op[i]==1)scanf("%s",d),v[i]=cv(d[0]);
		else scanf("%d%d%d",&x2[i],&y2[i],&v[i]);
	}
	for(int i=1;i<=q;++i)if(op[i]==1){
		if(lst[x1[i]][y1[i]]!=-1)k[++cnt]={x1[i],y1[i],lst[x1[i]][y1[i]],i-1,a[x1[i]][y1[i]]};
		if(v[i]!=-1)lst[x1[i]][y1[i]]=i;
		else lst[x1[i]][y1[i]]=-1;
		a[x1[i]][y1[i]]=v[i];
	}
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)if(lst[i][j]!=-1)k[++cnt]={i,j,lst[i][j],q,a[i][j]};
	for(int i=1;i<=cnt;++i)upd(0,q,1,k[i]);
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)a[i][j]=-1;
	solve(0,q,1);
	return 0;
}
```

---

## 作者：览遍千秋 (赞：5)

本题解为官方题解。

---

首先考虑一个降级问题：
		
假设有特殊性质 D，单组询问怎么做？
		
不难发现，知道了起点与终点坐标后，路径长度的奇偶性就固定了。
		
在这种情况下，我们很容易在 $O(\bmod)$ 时间内判断是否有解。
		
那稍微改一下条件，假如说所有格子上的数字是 $ab$ 相间的（即奇偶性相同的格子数字相同），我们该怎么做。
		
不难发现，还是暴力试即可，因为若固定了路径长度，权值就固定了。
		
可以发现，对于剩下的情况，全部有解。

证明：	
对于格子数字相间的情况，我们枚举 $ a,b $ ，表示一个连通块中的数字是 $ a,b $ 相间的。对于每一个数字 $ x $ ，我们连一条边 $  x\to (100x+10a+b)\bmod 1145141 $ ，那么若从 $ x $ 出发，走若干条便可以走到数字 $ y $ ，就说明在 $ x $ 后接若干个 $ ab $ 可以接成 $ y $ 。
		
对于所以两个数字 $ a,b $ 打表可以发现，连出的所有图均构成一个自环和两个大小相等的环。
		
考虑剩余的两种情况，一定可以归结为：一个 $ a,b $ 相间的连通块，并将一部分 $ a $ 变成 $ c $ 。

也就是说，我们在原来的图的基础上，每一个点 $ x $ 多了一条 $ x\to (100x+10c+b)\bmod 1145141 $ 的边，我们想要证明这张图是强连通的。
		
因为 $ a,b,c,\bmod$ 都很小，直接打表，发现所有图均为强连通。
		
知道结论之后，使用线段树分治维护即可。
		
时间复杂度 $ O((nm+q)\log q) $ 。

---

## 作者：Otomachi_Una_ (赞：4)

## 永恒

考虑一条路径上面的数依次是 $P_1,P_2,\dots,P_n$（$n\geq 2$），从 $1$ 走到 $n$，你可以在 $\bmod P=1145141$ 下得到多少余数？

考虑一种更加简单的情况 $P_i\equiv 1$，那么走出的路径形如 $11\dots1$（$2k$ 个 $1$），即 $\dfrac{10^{2k}-1}{9}$。注意到 $10$ 是 $\bmod P$ 意义下的原根，也就是能走出所有形如 $\dfrac{x^2-1}{9}$ 的数。这个是好判断的。

进一步，这个方法可以扩展到 $P_1=P_3=\dots,P_2=P_4=\dots$ 的情况，也就是判断二次剩余。

考虑如果出现某个 $P_{i-1}\not=P_{i+1}$，我们断言所有数都能被表示。

具体构造大概是从 $1$ 走到 $i$ 之后不断从 $i$ 走到 $i±1$ 再走到 $i$。这样子我们就得到类似 $10^{2k}$ 的线性组合的玩意。这东西显然能组成 $\bmod P$ 意义下的完全剩余类。

路径的问题可以扩展到连通块，只需要对连通块黑白染色，要求黑格的数完全相同，白格的数完全相同就可以判断二次剩余，否则就能表示出所有数。

对于原问题，还有更改操作。直接线段树分治即可。

时间复杂度：$\mathcal O((nm+q)\log q\log nm)$。

---

## 作者：phigy (赞：4)

一种证明一条路径不是 $ab$ 相间就一定有解的方法。

设 $k=10a+b,p=1145141$。

同样的我们连边 $x\rightarrow 100x+k\bmod p$。

注意到我们知道每个 $x$ 走至少多少次即可回到 $x$ 就可以知道他能到多少个数。

$$x\equiv 100^tx+\dfrac{100^t-1}{99}k\pmod p$$

$$(100^t-1)x+\dfrac{100^t-1}{99}k\equiv0\pmod p$$

$$(100^t-1)(x+\dfrac{1}{99}k)\equiv0\pmod p$$

若 $x\equiv -\dfrac{k}{99}\pmod p$，那么 $x$ 连出去的是一个自环。

否则 $100^t\equiv 1\pmod p$。

我们设 $len$ 是最小的正整数满足 $100^{len}\equiv 1\pmod p$。

那么除了自环外的 $p-1$ 个点都分别在一个长度为 $len$ 的环上。

也就是说这张图由一个自环和 $\dfrac{p-1}{len}$ 个长度为 $len$ 的环组成。

我们考虑证明有 $k_1=10a+b,k_2=10c+b$ 的图是强联通分量。

此时相当于把两个形如上述的图合并起来。

注意到不可能有两个环恰好重合。

因为

$$\sum_{i=1}^{len}(100^ix+\dfrac{100^i-1}{99}k_1)\equiv\sum_{i=1}^{len}(100^ix+\dfrac{100^i-1}{99}k_2)\pmod p$$

成立，当且仅当 $k_1\equiv k_2\pmod p$。

同理，不可能选出一个不包含所有点的点集 $S$ 在 $k_1,k_2$ 的图上均由同等数量个整环构成。 

如果这个图不是强连通的，那么一定存在一个不包含所有点的点集在 $k_1,k_2$ 的图上均由同等数量个整环构成。

这是矛盾的。

所以这个图是强连通的。

---


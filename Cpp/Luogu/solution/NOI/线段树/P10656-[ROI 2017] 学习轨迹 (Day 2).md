# [ROI 2017] 学习轨迹 (Day 2)

## 题目描述

THU 和 PKU 同时开设了一批课程，THU 有 $n$ 节课，PKU 有 $m$ 节课。

其中 THU 第 $i$ 节课类别是 $a_i$，乐趣度是 $x_i$；PKU 第 $i$ 节课类别是 $b_i$，乐趣度是 $y_i$。保证 $a$ 中元素互不相同，$b$ 中元素互不相同，但是 $a$ 和 $b$ 之间可能有相同元素。

你可以选择听 THU 的 $l_1 \sim r_1$ 节课，收获到的乐趣度为所有你听的课的乐趣度的和；同时可以在 PKU 听 $l_2 \sim r_2$ 节课，收获到的乐趣度也是所有你听的课的乐趣度的和。（当然你也可以选择只听一所大学的课甚至不听）

同一类别的课你不能听两次，也就是如果 $a_{l_1 \sim r_1}$ 中有元素与 $b_{l_2 \sim r_2}$ 相同，那么这个听课方案就不能满足你的胃口。

你需要求出可能的听课方案中乐趣度最大的是多少以及具体的安排。

## 说明/提示

#### 【样例解释】

对于样例组 #1：

最优解如样例所示，课程质量之和为 $(7 + 4 + 10 + 1 + 5) + (5 + 3 + 4) = 27 + 12 = 39$。

对于样例组 #2：

由于 PKU 的 $1$ 号、$2$ 号课程相比 THU 的相同课程的质量要高得多，因此最优解是不去 THU 听课，转而在 PKU 读 $1\sim 3$ 号课程。

#### 【数据范围】

注：本题只放部分数据，完整数据请左转 [LOJ P2773](https://loj.ac/p/2773) 评测。

对于所有数据满足：$1 \le a_i,b_i \le n+m$，$1 \le x_i,y_i \le 10^9$，$a_i \ne a_j(i \ne j)$，$b_i \ne b_j(i \ne j)$。

| 子任务编号 | 分值 | $1 \le n,m \le $ |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $50$ |
| $2$ | $10$ | $100$ |
| $3$ | $10$ | $300$ |
| $4$ | $10$ | $500$ |
| $5$ | $10$ | $2000$ |
| $6$ | $5$ | $5000$ |
| $7$ | $5$ | $10^4$ |
| $8$ | $10$ | $3 \times 10^4$ |
| $9$ | $10$ | $10^5$ |
| $10$ | $10$ | $2.5 \times 10^5$ |
| $11$ | $10$ | $5 \times 10^5$ |


## 样例 #1

### 输入

```
7 5
3 1 4 8 6 9 2
2 7 4 10 1 5 3
9 2 11 3 8
3 5 3 4 12```

### 输出

```
39
2 6
2 4```

## 样例 #2

### 输入

```
2 3
1 2
1 4
2 3 1
17 2 15```

### 输出

```
34
0 0
1 3```

## 样例 #3

### 输入

```
3 3
4 2 1
10 1 2
5 4 2
1 2 9```

### 输出

```
19
1 1
3 3```

# 题解

## 作者：苏联小渣 (赞：10)

考虑暴力怎么写，枚举 $a$ 中的一个区间，然后把 $b$ 中出现了相同数的位置标记，求出未被标记的最大子段和，反过来做可以用链表维护和取 max，可以做到 $O(n^2)$，理论上有 $60$ 分的高分。

然后到这里似乎就做不下去了，这个时候需要观察到一个性质：如果 $a,b$ 都有被选，那么至少有一个序列选的价值总和要大于该序列所有价值总和的一半，原因是如果都小于一半那调整成全选某个序列一定不劣。

于是假设 $a$ 选的价值总和大于总价值的一半，$b$ 反过来同理，那么第一个满足前缀和大于总和一半的位置 $p$ 一定会被中，原因显然。

那我们现在可以确定 $a$ 序列中有一个位置必选，考虑对 $b$ 序列扫描线，扫描到某个右端点 $r$ 时，维护所有左端点的答案。对于所有左端点，设 $fl_i$ 表示选择区间 $[i,r]$ 后，在 $a$ 序列中 $p$ 所在的极长连续段的左端点；$fr_i$ 同理。我们在右端点增大时，需要支持对所有 $fl_i$ 取 $\max$，对所有 $fr_i$ 取 $\min$，并更新区间和。观察到 $fl_i$ 从右往左单调不减，$fr_i$ 从右往左单调不增，于是可以用直接维护连续段/单调栈，最后需要支持区间加、区间查询，用线段树维护，时间复杂度 $O(n \log n)$。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define lc(x) x<<1
#define rc(x) x<<1|1
#define ll long long
int n, m, tp1, tp2, al, ar, bl, br, mxl[1000010], mnr[1000010], tagl[2000010], tagr[2000010], st1[500010], st2[500010];
ll ans, pre[500010], pre2[500010], tag[2000010];
struct node{
    int x, val;
}a[500010], b[500010], c[500010];
struct segment{
    ll mx;
    int pos, ls, rs;
}d[2000010];
segment operator + (segment x, segment y){
    segment ret;
    ret.mx = max(x.mx, y.mx);
    if (ret.mx == x.mx) ret.pos = x.pos, ret.ls = x.ls, ret.rs = x.rs;
    else ret.pos = y.pos, ret.ls = y.ls, ret.rs = y.rs;
    return ret;
}
void pushdown(int k){
    if (tag[k]){
        tag[lc(k)] += tag[k], tag[rc(k)] += tag[k];
        d[lc(k)].mx += tag[k], d[rc(k)].mx += tag[k];
        tag[k] = 0;
    }
    if (tagl[k]){
        tagl[lc(k)] = tagl[rc(k)] = d[lc(k)].ls = d[rc(k)].ls = tagl[k], tagl[k] = 0;
    }
    if (tagr[k]){
        tagr[lc(k)] = tagr[rc(k)] = d[lc(k)].rs = d[rc(k)].rs = tagr[k], tagr[k] = 0;
    }
}
void build(int k, int l, int r){
    tag[k] = tagl[k] = tagr[k] = 0;
    if (l == r){
        d[k].mx = -pre2[l-1] + pre[n];
        d[k].pos = l, d[k].ls = 1, d[k].rs = n;
        return ;
    }
    int mid = l + r >> 1;
    build(lc(k), l, mid);
    build(rc(k), mid+1, r);
    d[k] = d[lc(k)] + d[rc(k)];
}
void modify(int k, int l, int r, int x, int y, int ls, int rs){
    if (x <= l && r <= y){
        if (ls){
            d[k].mx -= (pre[ls-1] - pre[d[k].ls-1]), tag[k] -= (pre[ls-1] - pre[d[k].ls-1]);
            d[k].ls = tagl[k] = ls;
        }
        if (rs){
            d[k].mx -= (pre[d[k].rs] - pre[rs]), tag[k] -= (pre[d[k].rs] - pre[rs]);
            d[k].rs = tagr[k] = rs;
        }
        return ;
    }
    int mid = l + r >> 1;
    pushdown(k);
    if (x <= mid) modify(lc(k), l, mid, x, y, ls, rs);
    if (y > mid) modify(rc(k), mid+1, r, x, y, ls, rs);
    d[k] = d[lc(k)] + d[rc(k)];
}
segment query(int k, int l, int r, int x, int y){
    if (x <= l && r <= y) return d[k];
    int mid = l + r >> 1;
    pushdown(k);
    if (y <= mid) return query(lc(k), l, mid, x, y);
    if (x > mid) return query(rc(k), mid+1, r, x, y);
    return query(lc(k), l, mid, x, y) + query(rc(k), mid+1, r, x, y);
}
void work(int op){
    int pos = 0;
    for (int i=1; i<=n; i++) pre[i] = pre[i-1] + a[i].val;
    for (int i=1; i<=n; i++){
        if (pre[i] > pre[n] / 2){
            pos = i;
            break;
        }
    }
    for (int i=1; i<=n+m; i++) mxl[i] = 1, mnr[i] = n;
    for (int i=1; i<=pos; i++) mxl[a[i].x] = i + 1;
    for (int i=n; i>=pos; i--) mnr[a[i].x] = i - 1;
    for (int i=1; i<=m; i++) pre2[i] = pre2[i-1] + b[i].val;
    build(1, 1, m);
    tp1 = tp2 = 0;
    for (int i=1; i<=m; i++){
        while (tp1 && mxl[b[st1[tp1]].x] < mxl[b[i].x]){
            modify(1, 1, m, st1[tp1-1]+1, st1[tp1], mxl[b[i].x], 0);
            tp1 --;
        }
        while (tp2 && mnr[b[st2[tp2]].x] > mnr[b[i].x]){
            modify(1, 1, m, st2[tp2-1]+1, st2[tp2], 0, mnr[b[i].x]);
            tp2 --;
        }
        modify(1, 1, m, i, i, mxl[b[i].x], mnr[b[i].x]);
        segment ret = query(1, 1, m, 1, i);
        if (ret.mx + pre2[i] > ans){
            ans = ret.mx + pre2[i], al = ret.ls, ar = ret.rs, bl = ret.pos, br = i;
            if (op == 2) swap(al, bl), swap(ar, br);
        }
        st1[++tp1] = i, st2[++tp2] = i;
    }
}
int main(){
    scanf ("%d%d", &n, &m);
    for (int i=1; i<=n; i++){
        scanf ("%d", &a[i].x);
    }
    for (int i=1; i<=n; i++){
        scanf ("%d", &a[i].val);
    }
    for (int i=1; i<=m; i++){
        scanf ("%d", &b[i].x);
    }
    for (int i=1; i<=m; i++){
        scanf ("%d", &b[i].val);
    }
    work(1);
    if (pre[n] >= ans) ans = pre[n], al = 1, ar = n, bl = br = 0;
    if (pre2[m] >= ans) ans = pre2[m], al = ar = 0, bl = 1, br = m;
    memcpy(c, a, sizeof(a));
    memcpy(a, b, sizeof(b));
    memcpy(b, c, sizeof(c));
    swap(n, m);
    work(2);
    printf ("%lld\n%d %d\n%d %d\n", ans, al, ar, bl, br);
    return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：6)

首先考虑怎么暴力啊，枚举一个 $l_1$ 让 $r_1$ 扫描，在这个过程中维护一下序列 $b$ 的最大子段和即可。

考虑这个暴力优化难点在哪，你发现序列 $b$ 被我们分成了很多段，贡献来源于最大的一段，这个非常难以维护。

但是假若钦定了序列 $b$ 中某个位置必选，那就可以非常简单的维护了，只需要处理小于这个位置的最大禁用位置和大于这个位置的最小禁用位置即可。那有没有这个必须选的点呢？

我们断言，两个序列的带权中点必有一个会被选择。

这是因为假若两个都不选，则无论怎么选，选出来的段权值之和小于总权值之和的一半，而你直接选一整个 $a$ 序列或者 $b$ 序列的较大值就可以取到总权值之和的一半，因此必有一个带权中点会被选择，不妨设会选择序列 $a$ 的带权中点 $M$。另一种情况交换 $a,b$ 再做一遍即可。

对于 $b$ 中的一个位置 $x$，假若其与 $a$ 中位置 $i$ 颜色相同，假若 $i \leq M$，则记 $L_x = i$，否则记 $R_x = i$。

注意到对于 $b$ 中的一段 $[l,r]$，选择其后能选的 $a$ 序列中的段为 $(\max_{i=l}^r L_i,\min_{i=l}^r R_i)$。

看到区间最值，不难想到从左往右扫描线，用两个单调栈分别维护区间内 $L,R$ 的极值，你发现对于单调栈上的一段，$L,R$ 的贡献一定，因此在维护单调栈的过程中顺便拿一个线段树维护每个左端点的贡献以及全局最大贡献左端点即可。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 5e5+114;
int n,m;
int a[maxn],x[maxn],b[maxn],y[maxn];
int prex[maxn],prey[maxn];
int L[maxn],R[maxn];
int stkL[maxn],tpL,stkR[maxn],tpR;
pair<int,int> col[maxn];
int M;
int ans,al,ar,bl,br;
int ty;
int tag[maxn<<2];
pair<int,int> tr[maxn<<2];
void pushdown(int cur){
    if(tag[cur]==0) return ;
    tr[cur<<1].first+=tag[cur];
    tr[cur<<1|1].first+=tag[cur];
    tag[cur<<1]+=tag[cur];
    tag[cur<<1|1]+=tag[cur];
    tag[cur]=0;
}
void pushup(int cur){
    tr[cur]=max(tr[cur<<1],tr[cur<<1|1]);
}
void add(int cur,int lt,int rt,int l,int r,int v){
    if(rt<l||r<lt) return ;
    if(l<=lt&&rt<=r){
        tr[cur].first+=v;
        tag[cur]+=v;
        return ;
    }
    pushdown(cur);
    int mid=(lt+rt)>>1;
    add(cur<<1,lt,mid,l,r,v);
    add(cur<<1|1,mid+1,rt,l,r,v);
    pushup(cur);
}
void build(int cur,int lt,int rt){
    if(lt==rt){
        tr[cur]=make_pair(-prey[lt-1],lt);
        return ;
    }
    int mid=(lt+rt)>>1;
    build(cur<<1,lt,mid);
    build(cur<<1|1,mid+1,rt);
    pushup(cur);
}
void work(bool flag){
    for(int i=1;i<=n;i++){
        if(prex[i]*2>=prex[n]){
            M=i;
            break;
        }
    }
    for(int i=1;i<=n;i++){
        col[i]=make_pair(a[i],i);
    }
    sort(col+1,col+n+1);
    for(int i=1;i<=m;i++){
        int l=1,r=n+1;
        while(l+1<r){
            int mid=(l+r)>>1;
            if(b[i]>=col[mid].first) l=mid;
            else r=mid;
        }
        if(b[i]==col[l].first){
            if(col[l].second<=M) L[i]=col[l].second;
            else R[i]=col[l].second;
        }   
    }
    build(1,1,m);
    for(int r=1;r<=m;r++){
        add(1,1,m,r,r,prex[n]);
        if(L[r]!=0){
            while(tpL>0&&L[r]>L[stkL[tpL]]){
                add(1,1,m,stkL[tpL-1]+1,stkL[tpL],+prex[L[stkL[tpL]]]);
                tpL--;
            }
            stkL[++tpL]=r;
            add(1,1,m,stkL[tpL-1]+1,stkL[tpL],-prex[L[r]]);
        }
        if(R[r]!=0){
            while(tpR>0&&R[r]<R[stkR[tpR]]){
                add(1,1,m,stkR[tpR-1]+1,stkR[tpR],+(prex[n]-prex[R[stkR[tpR]]-1]));
                tpR--;
            }
            stkR[++tpR]=r;
            add(1,1,m,stkR[tpR-1]+1,stkR[tpR],-(prex[n]-prex[R[r]-1]));
        }
        if(tr[1].first+prey[r]>ans){
            ans=tr[1].first+prey[r];
            if(flag==false) bl=tr[1].second,br=r,ty=0;
            else al=tr[1].second,ar=r,ty=1;
        }
    }   
}
signed main(){
    //freopen("food.in","r",stdin);
    //freopen("food.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>x[i],prex[i]=prex[i-1]+x[i];
    for(int i=1;i<=m;i++) cin>>b[i];
    for(int i=1;i<=m;i++) cin>>y[i],prey[i]=prey[i-1]+y[i];
    work(0);
    for(int i=1;i<=max(n,m);i++){
        swap(a[i],b[i]);
        swap(x[i],y[i]);
        swap(prex[i],prey[i]);
    }
    swap(n,m);
    tpL=tpR=0;
    memset(stkL,0,sizeof(stkL));
    memset(stkR,0,sizeof(stkR));
    memset(tag,0,sizeof(tag));
    memset(L,0,sizeof(L));
    memset(R,0,sizeof(R));
    for(int i=0;i<maxn;i++) col[i]=make_pair(0,0);
    for(int i=0;i<(maxn<<2);i++) tr[i]=make_pair(0,0);
    work(1);
    for(int i=1;i<=max(n,m);i++){
        swap(a[i],b[i]);
        swap(x[i],y[i]);
        swap(prex[i],prey[i]);
    }
    swap(n,m);
    if(ty==0){
        map<int,int> mp;
        for(int i=bl;i<=br;i++) mp[b[i]]=1;
        int L=0,R=0;
        long long v=0;
        int lst=0;
        for(int i=1;i<=n;i++){
            if(mp[a[i]]==1){
                if(prex[i-1]-prex[lst]>v){
                    v=prex[i-1]-prex[lst];
                    R=i-1,L=lst+1;
                }
                lst=i;
            }
        }
        if(prex[n]-prex[lst]>v){
            v=prex[n]-prex[lst];
            R=n,L=lst+1;
        }
        if(v==0) L=R=0;    
        cout<<ans<<'\n';
        cout<<L<<' '<<R<<'\n';
        cout<<bl<<" "<<br<<'\n';
    }else{
        map<int,int> mp;
        for(int i=al;i<=ar;i++) mp[a[i]]=1;
        int L=0,R=0;
        long long v=0;
        int lst=0;
        for(int i=1;i<=m;i++){
            if(mp[b[i]]==1){
                if(prey[i-1]-prey[lst]>v){
                    v=prey[i-1]-prey[lst];
                    R=i-1,L=lst+1;
                }
                lst=i;
            }
        }
        if(prey[m]-prey[lst]>v){
            v=prey[m]-prey[lst];
            R=m,L=lst+1;
        }
        if(v==0) L=R=0;    
        cout<<ans<<'\n';
        cout<<al<<' '<<ar<<'\n';
        cout<<L<<" "<<R<<'\n';
    }
    return 0;   
}
```

---

## 作者：Reunite (赞：3)

做完之后还是感觉很简单的。

显然答案下界为 $\max(\sum x_i,\sum y_i)$，则最优方案一定会取到某一个序列和的至少一半，否则调整发现不如下界。因为答案是区间，因此必有一答案区间过对应序列带权值域中点。

考虑写一个 $n^2$ 的暴力：扫描一个序列的右端点，维护 $lf_i,rt_i$ 为左端点为 $i$ 时，另一个带权中点左右能取到的极长段，每次加入一个在另一个序列有限制的点 $pos$ 时，若在中点左边，则对所有 $lf_i\leftarrow \max(lf_i,pos)$，右边相反同理。

然后考虑加速，注意到 $lf_i,rt_i$ 具有单调性，这个是显然的，那只需要维护两个单调栈暴力推平即可，或者也可以直接上线段树上二分。最后查答案记录最大值取到对应的 $l$，若更新答案就在单调栈上二分找到对应在另一个序列上的位置。因为单调栈中每个数出入栈一次，且答案更新次数不超过 $n+m$，因此复杂度即为 $O(n\log n)$，带 $4$ 倍常数。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;

int n,m,ans,l1,l2,r1,r2;
int a[500005];
int b[500005];
int x[500005];
int y[500005];
int h[1000005];
int lf[500005];
int rt[500005];
int s1[500005];
int s2[500005];
int tg[2000005];
int mx[2000005];
int ps[2000005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline void build(int u,int l,int r){
	mx[u]=0;
	ps[u]=l;
	if(l==r) return ;
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	return ;
}

inline void down(int u,int x){tg[u]+=x,mx[u]+=x;return ;}

inline void pushdown(int u){
	if(!tg[u]) return ;
	down(u<<1,tg[u]);
	down(u<<1|1,tg[u]);
	tg[u]=0;
	return ;
}

inline void upd(int u,int l,int r,int L,int R,int x){
	if(L<=l&&r<=R){down(u,x);return ;}
	int mid=(l+r)>>1;
	pushdown(u);
	if(L<=mid) upd(u<<1,l,mid,L,R,x);
	if(R>mid) upd(u<<1|1,mid+1,r,L,R,x);
	mx[u]=max(mx[u<<1],mx[u<<1|1]);
	if(mx[u]==mx[u<<1]) ps[u]=ps[u<<1];
	else ps[u]=ps[u<<1|1];
	return ;
}

inline pair <int,int> qry(int u,int l,int r,int L,int R){
	if(L<=l&&r<=R) return {mx[u],ps[u]};
	int mid=(l+r)>>1;
	pushdown(u);
	if(L>mid) return qry(u<<1|1,mid+1,r,L,R);
	if(R<=mid) return qry(u<<1,l,mid,L,R);
	auto t1=qry(u<<1,l,mid,L,R);
	auto t2=qry(u<<1|1,mid+1,r,L,R);
	if(t1.first>t2.first) return t1;
	else return t2;
}

inline void solve(int op){
	memset(h,0,sizeof(h));
	int mid=0;
	for(int i=1;i<=n;i++) h[a[i]]=i,s1[i]=s1[i-1]+x[i];
	for(int i=1;i<=n;i++) if(s1[i]*2>s1[n]){mid=i;break;}
	for(int i=1;i<=m;i++) s2[i]=s2[i-1]+y[i];
	pair <int,int> st1[m+5],st2[m+5];
	int t1=0,t2=0;
	build(1,1,m);
	memset(tg,0,sizeof(tg));
	for(int r=1;r<=m;r++){
		int p=h[b[r]];
		upd(1,1,m,r,r,s1[n]-s2[r-1]);
		st1[++t1]={r,1};
		st2[++t2]={r,n};
		if(p){
			if(p<=mid){
				int x=s1[p],las=r;
				while(t1&&s1[st1[t1].second-1]<=x){
					upd(1,1,m,st1[t1].first,las,s1[st1[t1].second-1]);
					las=st1[t1].first-1;
					t1--;
				}
				las=min(las+1,r);
				upd(1,1,m,las,r,-x);
				st1[++t1]={las,p+1};
			}
			if(p>mid){
				int x=s1[p-1],las=r;
				while(t2&&s1[st2[t2].second]>=x){
					upd(1,1,m,st2[t2].first,las,-s1[st2[t2].second]);
					las=st2[t2].first-1;
					t2--;
				}
				las=min(las+1,r);
				upd(1,1,m,las,r,x);
				st2[++t2]={las,p-1};
			}
		}
		auto tmp=qry(1,1,m,1,r);
		if(ans<s2[r]+tmp.first){
			ans=s2[r]+tmp.first;
			int pos=tmp.second;
			l1=pos,r1=r;
			int ll,rr,mid,p1,p2;
			ll=1,rr=t1,p1=0;
			while(ll<=rr){
				mid=(ll+rr)>>1;
				if(st1[mid].first<=tmp.second) p1=st1[mid].second,ll=mid+1;
				else rr=mid-1;
			}
			ll=1,rr=t2,p2=0;
			while(ll<=rr){
				mid=(ll+rr)>>1;
				if(st2[mid].first<=tmp.second) p2=st2[mid].second,ll=mid+1;
				else rr=mid-1;
			}
			l2=tmp.second,r2=r;
			l1=p1,r1=p2;
			if(op) swap(l1,l2),swap(r1,r2);
		}
	}
	return ;
}

signed main(){
	in(n),in(m);
	for(int i=1;i<=n;i++) in(a[i]);
	for(int i=1;i<=n;i++) in(x[i]),s1[i]=s1[i-1]+x[i];
	for(int i=1;i<=m;i++) in(b[i]);
	for(int i=1;i<=m;i++) in(y[i]),s2[i]=s2[i-1]+y[i];
	if(ans<s1[n]) l1=1,r1=n,l2=r2=0,ans=s1[n];
	if(ans<s2[m]) l2=1,r2=m,l1=r1=0,ans=s2[m];
	solve(0);
	swap(n,m);
	swap(a,b);
	swap(x,y);
	solve(1);
	printf("%lld\n",ans);
	printf("%lld %lld\n",l1,r1);
	printf("%lld %lld\n",l2,r2);

	return 0;
}
```

---

## 作者：Judgelight (赞：3)

首先，设 $s_n=\sum x_i,s_m=\sum y_i$，则 $ans\ge \max(s_n,s_m)$，所以一定有一边的和大于等于 $\frac{s}{2}$，换句话说，一定有一边的区间过带权中点，不妨设 $[l_1,r_1]$ 过第一个序列（序列 $n$）的带权中点。

考虑枚举 $r_2$，维护 $f_j$ 表示 $l_2=j$ 时的最大权值和。由于区间 $[l_1,r_1]$ 一定过序列 $n$ 的带权中点，我们可以对于每个 $i$ 维护带权中点的左右两侧可以取到的最长区间的左右端点，不难发现这个东西是单调的，用栈维护即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define eb emplace_back
#define mk make_pair
#define N 500009
using namespace std;
bool fff;
int n,m,a[N],s[N],x[N],b[N],y[N],ans,pos[N*2],l1,r1,l2,r2;
struct Misaka{int l,r,d;};
Misaka stkl[N];int topl;
Misaka stkr[N];int topr;
struct Node{int l,r,mx,add,cov1,cov2;}tr[N*4];
inline void pushup(int u){tr[u].mx=max(tr[u<<1].mx,tr[u<<1|1].mx);}
inline void eval(Node &t,int add,int cov1,int cov2){t.mx+=add,t.add+=add;if(~cov1)t.cov1=cov1;if(~cov2)t.cov2=cov2;}
inline void pushdown(int u){eval(tr[u<<1],tr[u].add,tr[u].cov1,tr[u].cov2),eval(tr[u<<1|1],tr[u].add,tr[u].cov1,tr[u].cov2),tr[u].add=0,tr[u].cov1=tr[u].cov2=-1;}
void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r,tr[u].mx=tr[u].add=0,tr[u].cov1=tr[u].cov2=-1;
	if(l==r)return ;
	int mid=(l+r)>>1;build(u<<1,l,mid),build(u<<1|1,mid+1,r),pushup(u);
}
void mdf(int u,int l,int r,int x,int cov1,int cov2){
	if(tr[u].l>=l&&tr[u].r<=r){eval(tr[u],x,cov1,cov2);return ;}
	pushdown(u);int mid=(tr[u].l+tr[u].r)>>1;
	if(l<=mid)mdf(u<<1,l,r,x,cov1,cov2);if(r>mid)mdf(u<<1|1,l,r,x,cov1,cov2);
	pushup(u);
}
int qry(int u,int d){
	if(tr[u].l==tr[u].r)return u;
	pushdown(u);int mid=(tr[u].l+tr[u].r)>>1;
	if(d<=mid)return qry(u<<1,d);else return qry(u<<1|1,d);
}
void find(int u){
	if(tr[u].l==tr[u].r){
		if(!fff)l2=tr[u].l,l1=tr[u].cov1,r1=tr[u].cov2;
		else l1=tr[u].l,l2=tr[u].cov1,r2=tr[u].cov2;
		return ;
	}
	pushdown(u);
	if(tr[u<<1].mx==tr[u].mx)find(u<<1);else find(u<<1|1);
}
void solve(){
	int p=0,sum=0;
	for(int i=1;i<=n+m;i++)pos[i]=0;
	for(int i=1;i<=n;i++)sum+=x[i],pos[a[i]]=i;
	for(int i=1,nw=0;i<=n;nw+=x[i],i++)if(nw*2<=sum&&(sum-nw-x[i])*2<=sum){p=i;break;}
	s[p]=0;for(int i=p-1;i;i--)s[i]=s[i+1]+x[i];for(int i=p+1;i<=n;i++)s[i]=s[i-1]+x[i];
	topl=topr=0;stkl[0].d=stkr[0].d=0;
	build(1,1,m);mdf(1,1,m,x[p],-1,-1);
	for(int i=1;i<=m;i++){
		mdf(1,1,i,y[i],-1,-1);
		int pp=pos[b[i]];
		if(pp==p){topl=topr=0;stkl[0].d=stkr[0].d=0;build(1,1,m);mdf(1,i+1,m,x[p],-1,-1);continue;}
		if(!pp){
			mdf(1,i,i,s[1]+s[n],1,n);
			if(stkl[topl].d==1)stkl[topl].r=i;else stkl[++topl]=(Misaka){i,i,1};
			if(stkr[topr].d==n)stkr[topr].r=i;else stkr[++topr]=(Misaka){i,i,n};
		}
		else{
			if(pp<p){
				Misaka nw=(Misaka){i,i,pp+1};
				while(topl&&stkl[topl].d<=nw.d){
					Misaka x=stkl[topl];topl--;
					mdf(1,x.l,x.r,-s[x.d],-1,-1);
					nw.l=x.l;
				}
				mdf(1,nw.l,nw.r,s[nw.d],nw.d,-1),stkl[++topl]=nw;
				mdf(1,i,i,s[n],-1,n);
				if(stkr[topr].d==n)stkr[topr].r=i;else stkr[++topr]=(Misaka){i,i,n};
			}
			else{
				Misaka nw=(Misaka){i,i,pp-1};
				while(topr&&stkr[topr].d>=nw.d){
					Misaka x=stkr[topr];topr--;
					mdf(1,x.l,x.r,-s[x.d],-1,-1);
					nw.l=x.l;
				}
				mdf(1,nw.l,nw.r,s[nw.d],-1,nw.d),stkr[++topr]=nw;
				mdf(1,i,i,s[1],1,-1);
				if(stkl[topl].d==1)stkl[topl].r=i;else stkl[++topl]=(Misaka){i,i,1};
			}
		}
		/*cout<<i<<":"<<endl;
		for(int j=1;j<=m;j++)cout<<tr[qry(1,j)].mx<<" ";
		cout<<endl;
		for(int j=1;j<=m;j++)cout<<tr[qry(1,j)].cov1<<" ";
		cout<<endl;
		for(int j=1;j<=m;j++)cout<<tr[qry(1,j)].cov2<<" ";
		cout<<endl;*/
		if(tr[1].mx>ans){
			ans=tr[1].mx;
			if(!fff)r2=i;else r1=i;find(1);
		}
	}
}
signed main(){
	scanf("%lld%lld",&n,&m);int sum=0;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&x[i]),sum+=x[i];
	if(sum>ans)ans=sum,l1=1,r1=n,l2=0,r2=0,sum=0;
	for(int i=1;i<=m;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=m;i++)scanf("%lld",&y[i]),sum+=y[i];
	if(sum>ans)ans=sum,l1=0,l1=0,l2=1,r2=m;
	solve();
	swap(a,b),swap(x,y),swap(n,m);
	fff=1;
	solve();
	if(l1==0||r1==0)l1=r1=0;if(l2==0||r2==0)l2=r2=0;
	printf("%lld\n%lld %lld\n%lld %lld",ans,l1,r1,l2,r2);
	return 0;
}
```

---

## 作者：fight_for_humanity (赞：1)

暴力显然。枚举 $a$ 数组中的左右端点，将 $b$ 中有区间内的数删去，取出最大的那一段，统计答案。可用链表+并查集维护。

关键是权值中点的性质（即其他题解中提到的必定会选到一个序列的权值中点的性质）这样我们只用关注权值中点所在的段了。

假设我们枚举 $a$ 上的右端点，$b$ 的权值中点是 $p$。

$a$ 中的数 $a_i = x$，若 $b$ 中存在 $x$，其位置为 $u$。
- $u \le p$，那么 $R_i = u$ 表示选择了该数给 $b$ 中权值中点所在的区间限定的左端点。
- $p < u$，那么 $L_i = u$ 表示选择了该数给 $b$ 中权值中点所在的区间限定的右端点。

$L_i$ 的初值为 $0$，$R_i$ 的初值为 $n+1$。 

设两个数组的前缀和分别为 $px,py$。

那么我们在 $a$ 中选择了 $[l, r]$ 这段区间，价值为 $px[r] - px[l-1] + py[\max(R[l\sim r])] - py[\min(L[l\sim r])-1]$。

枚举右端点，当前为 $cur$，线段树上叶节点 $i$ 维护 $px[\min(R[l\sim cur])-1]-px[\max(L[l\sim cur])]-py[l-1]$ 的最大值。单调栈维护要更新的区间，每次右移 $cur$ 时更新即可。

感觉没有黑题难度，别被吓到了。但是这个权值中点性质还是很精妙的，剩下来的就是考验分析能力和基本的线段树+单调栈实现了。

```cpp
#include<bits/stdc++.h>
#define rep(i, l, r) for(int (i)=(l);(i)<=(r);++(i))
#define per(i, r, l) for(int (i)=(r);(i)>=(l);--(i))
#define fi first
#define se second
using namespace std;
namespace IO{ // file IO
}using namespace IO;

const int N = 5e5 + 10;
using ll = long long;
const ll inf = 0x3f3f3f3f3f3f3f3f;

struct Seg{

#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid ((l + r) >> 1)

int n; 
pair<ll, int> tr[N << 2];
ll tag[N << 2];

void init(int _n){ n = _n, build(1, 1, n); }

void build(int p,int l,int r){
	tag[p] = 0;
	if(l == r)return tr[p] = {-inf, l}, void();
	build(ls, l, mid), build(rs, mid+1, r);
	tr[p] = max(tr[ls], tr[rs]);
}

inline void pushtag(int p,ll v){ tr[p].fi += v, tag[p] += v; }

inline void pushdown(int p){
	if(!tag[p])return ;
	pushtag(ls, tag[p]);
	pushtag(rs, tag[p]);
	tag[p] = 0;
}
void modify(int p,int l,int r,int L,int R,ll v){
	if(L <= l && r <= R)return pushtag(p, v);
	pushdown(p);
	if(L <= mid)modify(ls, l, mid, L, R, v);
	if(mid < R)modify(rs, mid+1, r, L, R, v);
	tr[p] = max(tr[ls], tr[rs]);
} 

inline void modify(int l, int r, ll v){
	modify(1, 1, n, l, r, v);
}

}seg;

ll px[N],py[N];
ll ans = -inf;
int l1,r1,l2,r2;
int mark[N << 1],L[N],R[N];
int st1[N],st2[N],top1,top2;
int n,m;

void solve(int n,int m,int a[],int b[],int x[],int y[],ll px[],ll py[], bool flag){
	rep(i, 1, n+m)mark[i] = 0;
	rep(i, 1, n)mark[a[i]] = i;
	ll sum = px[n], ans = sum;
	int l1 = 1, r1 = n, l2 = 0, r2 = 0;
	int p = -1;
	rep(i, 1, n)if(px[i] * 2 >= sum){ p = i; break; }
	rep(i, 1, m){
		L[i] = 0, R[i] = n+1;
		int x = mark[b[i]];
		if(!x)continue;
		(x <= p) ? (L[i] = x) : (R[i] = x);
	}
	top1 = top2 = 0;
	seg.init(m);
	rep(i, 1, m){
		seg.modify(i, i, inf-py[i-1]);
		while(top1 && R[st1[top1]] >= R[i]){
			seg.modify(st1[top1-1]+1, st1[top1], -px[R[st1[top1]]-1]);
			--top1;
		}
		st1[++top1] = i;
		seg.modify(st1[top1-1]+1, i, px[R[i]-1]);
		while(top2 && L[st2[top2]] <= L[i]){
			seg.modify(st2[top2-1]+1, st2[top2], px[L[st2[top2]]]);
			--top2;
		}
		st2[++top2] = i;
		seg.modify(st2[top2-1]+1, i, -px[L[i]]);
		ll res = py[i] + seg.tr[1].fi;
		if(res > ans){
			ans = res;
			l1 = r1 = -1;
			l2 = seg.tr[1].se;
			r2 = i;
		}
	}
	if(l1 == -1){
		int mx = 0, mn = n+1;
		rep(i, l2, r2)mx = max(mx, L[i]), mn = min(mn, R[i]);
		l1 = mx + 1, r1 = mn - 1;
		if(l1 > r1)l1 = r1 = 0;
	}
	if(flag)swap(l1, l2), swap(r1, r2);
	if(ans > ::ans){
		::ans = ans;
		::l1 = l1, ::l2 = l2;
		::r1 = r1, ::r2 = r2;
	}
}

int a[N],b[N],x[N],y[N];
int main(){
  freopen("study.in","r",stdin);	
  freopen("study.out","w",stdout);
	read(n, m);
	rep(i, 1, n)read(a[i]);
	rep(i, 1, n)read(x[i]);
	rep(i, 1, m)read(b[i]);
	rep(i, 1, m)read(y[i]);
	rep(i, 1, n)px[i] = px[i-1] + x[i];
	rep(i, 1, m)py[i] = py[i-1] + y[i];
	solve(n, m, a, b, x, y, px, py, 0);
	solve(m, n, b, a, y, x, py, px, 1);
	printf("%lld\n%d %d\n%d %d\n",ans,l1,r1,l2,r2);
	return 0;
}
```

---

## 作者：qnqfff (赞：1)

### 思路

首先发现一个性质，至少有一个序列的价值大于这个序列总价值的一半，否则可以全选。

这里钦定 $a$ 序列为价值大于一半的，另一种情况可以交换做，把第一个前缀和大于总价值一半的点拉出来并设为 $p$ ，在确定 $b$ 选哪个区间时，答案一定是从 $p$ 开始一直往左往右能选就选。

于是对 $b$ 扫描线，设当前扫到 $r$ ，设 $v_l$ 表示左端点为 $l$ 时的答案，每次加进来一个点，对于它在 $a$ 中的位置分讨。

1. 在 $p$ 左边。

容易发现 $a$ 中对于左端点的限制是单调递增的，可以通过单调栈加线段树简单维护出答案。

2. 在 $p$ 右边。

类似的，$a$ 中对于右端点限制是单调递减的，也可以单调栈加线段树维护。

因为还要具体的区间，所以线段树多维护一下左端点右端点即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf,ubuf[1<<23],*u=ubuf;
int read(){int p=0,flg=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,m,a[500010],id[1000010],b[500010],x[500010],y[500010],s1[500010],t1,s2[500010],t2,sum[500010];struct seg{int l,r,mx,tag,tl,tr,L,R,id;}t[2000010];
#define lson now<<1
#define rson now<<1|1
void pushup(int now){
	t[now].mx=max(t[lson].mx,t[rson].mx);t[now].id=(t[now].mx==t[lson].mx?t[lson].id:t[rson].id);
	t[now].L=(t[now].mx==t[lson].mx?t[lson].L:t[rson].L);t[now].R=(t[now].mx==t[lson].mx?t[lson].R:t[rson].R);
}
void build(int now,int l,int r){
	t[now].l=l;t[now].r=r;t[now].mx=t[now].tag=t[now].L=t[now].R=0;t[now].tl=t[now].tr=-1;if(l==r){t[now].id=l;return ;}
	int mid=(l+r)>>1;build(lson,l,mid);build(rson,mid+1,r);
}
void puttag(int now,int v,int vl,int vr){if(~vl) t[now].L=t[now].tl=vl;if(~vr) t[now].R=t[now].tr=vr;t[now].mx+=v;t[now].tag+=v;}
void pushdown(int now){if(!t[now].tag) return ;puttag(lson,t[now].tag,t[now].tl,t[now].tr);puttag(rson,t[now].tag,t[now].tl,t[now].tr);t[now].tag=0;t[now].tl=t[now].tr=-1;}
void modify(int now,int l,int r,int v,int vl,int vr){
	if(l<=t[now].l&&t[now].r<=r){puttag(now,v,vl,vr);return ;}
	pushdown(now);int mid=(t[now].l+t[now].r)>>1;if(l<=mid) modify(lson,l,r,v,vl,vr);if(mid<r) modify(rson,l,r,v,vl,vr);pushup(now);
}
array<int,4>mx(array<int,4>x,array<int,4>y){return x[0]>y[0]?x:y;}
array<int,5>_mx(array<int,5>x,array<int,5>y){return x[0]>y[0]?x:y;}
array<int,4>query(int now,int l,int r){
	if(l<=t[now].l&&t[now].r<=r) return {t[now].mx,t[now].L,t[now].R,t[now].id};
	pushdown(now);int mid=(t[now].l+t[now].r)>>1;array<int,4>res={0,0,0,0};if(l<=mid) res=mx(res,query(lson,l,r));if(mid<r) res=mx(res,query(rson,l,r));return res;
}
array<int,5>solve(int opt){
	memset(id,0,sizeof(id));for(int i=1;i<=n;i++) id[a[i]]=i,sum[i]=sum[i-1]+x[i];
	int pos=0;for(int i=1,s=0;i<=n;i++){s+=x[i];if(2*s>=sum[n]){pos=i;break;}}
	array<int,5>res={0,0,0,0,0};t1=t2=0;build(1,1,m);for(int i=1;i<=m;i++){
		if(id[b[i]]){
			if(id[b[i]]<=pos){modify(1,i,i,sum[n],1,n);modify(1,1,i,y[i],-1,-1);modify(1,s1[t1]+1,i,-sum[id[b[i]]],id[b[i]]+1,-1);while(t1&&id[b[s1[t1]]]<id[b[i]]) modify(1,s1[t1-1]+1,s1[t1],sum[id[b[s1[t1]]]]-sum[id[b[i]]],id[b[i]]+1,-1),t1--;s1[++t1]=i;}
			else{modify(1,i,i,sum[n],1,n);modify(1,1,i,y[i],-1,-1);modify(1,s2[t2]+1,i,sum[id[b[i]]-1]-sum[n],-1,id[b[i]]-1);while(t2&&id[b[s2[t2]]]>id[b[i]]) modify(1,s2[t2-1]+1,s2[t2],sum[id[b[i]]-1]-sum[id[b[s2[t2]]]-1],-1,id[b[i]]-1),t2--;s2[++t2]=i;}
		}else{modify(1,i,i,sum[n],1,n);modify(1,1,i,y[i],-1,-1);}auto tmp=query(1,1,i);res=_mx(res,{tmp[0],tmp[1],tmp[2],tmp[3],i});
	}if(res[1]>res[2]) res[1]=res[2]=0;if(res[3]>res[4]) res[3]=res[4]=0;if(!opt) return {res[0],res[1],res[2],res[3],res[4]};else return {res[0],res[3],res[4],res[1],res[2]};
}
signed main(){
	n=read();m=read();for(int i=1;i<=n;i++) a[i]=read();for(int i=1;i<=n;i++) x[i]=read();for(int i=1;i<=m;i++) b[i]=read();for(int i=1;i<=m;i++) y[i]=read();
	array<int,5>ans=solve(0);swap(n,m);swap(a,b);swap(x,y);ans=_mx(ans,solve(1));cout<<ans[0]<<'\n'<<ans[1]<<' '<<ans[2]<<'\n'<<ans[3]<<' '<<ans[4];
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：0)

# P10656 [ROI 2017] 学习轨迹 (Day 2) 题解

------

## 知识点

线段树，单调栈。

## 分析

首先分析最特殊的情况——只选某一个序列的全部值，这导致后面考虑两个序列都选的时候，其中至少一个序列满足：选的区间和大于整个区间的一半。

因为如果两个序列选的区间和都小于等于其总和一半，那么我们完全可以只选总和最大的那个序列。

这个性质有什么用呢？假设现在满足「选的区间和大于整个区间的一半」的是第一个序列 $\set{a_i}$（假设两个序列分别为 $a,b$）。

那么会发现，无论如何合法地移动区间，有一个点总会被选到。于是我们可以把这个点找出来，然后维护包含这个点的最大合法区间。

## 实现

仍然是假设现在满足「选的区间和大于整个区间的一半」的是 $\set{a_i}$，设「$\set{a_i}$ 中总会被选到的点」为 $pos$。

我们考虑在 $b$ 序列上扫过去，维护 $r$ 固定时，所有 $b$ 序列上区间选定为 $[i,r](i\le r)$ 时的答案。

开一棵线段树，记 $(l_i,r_i,v_i)$ 为答案，由于 $l_i$ 随 $i$ 单调不增，$r_i$ 随 $i$ 单调不增，我们只要单调栈就可以解决更新。具体地，我们分别预处理出对于每种值在 $pos$ 左边的最大位置和在右边的最小位置，就可以单调栈处理，每次从单调栈中删除元素的时候区间更新。

如果满足「选的区间和大于整个区间的一半」的是 $\set{b_i}$，也同理再处理一遍即可。

## 代码

```cpp
#define Plus_Cat "study"
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define Pii pair<int,int>
#define Swap(a,b) ((a)^=(b)^=(a)^=(b))
#define RCL(a,b,c,d) memset(a,b,sizeof(c)*(d))
#define FOR(i,a,b) for(int i(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i(a);i>=(int)(b);--i)
#define tomax(a,...) ((a)=max({(a),__VA_ARGS__}))
#define tomin(a,...) ((a)=min({(a),__VA_ARGS__}))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~i;y=(g)[(i=(g)[i].nxt)>0?i:0].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);return Main();}signed Main
using namespace std;
constexpr int N(5e5+10);

namespace IOEcat {
	//Fast IO...
} using namespace IOEcat;

int n,m;
int a[N],b[N],c[N<<1],mxl[N<<1],mnr[N<<1];
Pii A,B;
ll ans;
ll x[N],y[N],X[N],Y[N];

struct Tag {
	int l,r;
	ll add;
	Tag(int l=0,int r=0,ll add=0):l(l),r(r),add(add) {}

	friend Tag operator +(Tag A,Tag B) { return Tag(B.l?B.l:A.l,B.r?B.r:A.r,A.add+B.add); }
};

struct Data {
	int pos,l,r;
	ll val;
	Data(int pos=0,int l=0,int r=0,ll val=0):pos(pos),l(l),r(r),val(val) {}

	friend Data operator +(Data A,Data B) { return A.val>B.val?A:B; }

	friend Data operator +(Data A,Tag B) { return Data(A.pos,B.l?B.l:A.l,B.r?B.r:A.r,A.val+B.add); }
};

struct SEG {
	struct node {
		Data data;
		Tag tag;
		node(Data data=Data(),Tag tag=Tag()):data(data),tag(tag) {}

		void down(Tag _tag) { data=data+_tag,tag=tag+_tag; }
	} tr[N<<2];
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)
	void Up(int p) { tr[p].data=tr[ls].data+tr[rs].data; }

	void Down(int p) { tr[ls].down(tr[p].tag),tr[rs].down(tr[p].tag),tr[p].tag=Tag(); }

	void Build(int p=1,int l=1,int r=m) {
		tr[p].tag=Tag();
		if(l==r)return tr[p].data=Data(l,1,n,X[n]-Y[l-1]),void();
		Build(ls,l,mid),Build(rs,mid+1,r),Up(p);
	}

	void Update(int L,int R,int dl,int dr,int p=1,int l=1,int r=m) {
		if(L<=l&&r<=R) {
			if(dl)tr[p].down(Tag(dl,0,-(X[dl-1]-X[tr[p].data.l-1])));
			if(dr)tr[p].down(Tag(0,dr,-(X[tr[p].data.r]-X[dr])));
			return;
		}
		Down(p);
		if(L<=mid)Update(L,R,dl,dr,ls,l,mid);
		if(mid<R)Update(L,R,dl,dr,rs,mid+1,r);
		Up(p);
	}

	Data Query(int L,int R,int p=1,int l=1,int r=m) {
		if(L<=l&&r<=R)return tr[p].data;
		Down(p);
		if(R<=mid)return Query(L,R,ls,l,mid);
		if(mid<L)return Query(L,R,rs,mid+1,r);
		return Query(L,R,ls,l,mid)+Query(L,R,rs,mid+1,r);
	}
#undef ls
#undef rs
#undef mid
} seg;

void Solve(const bool univ,Pii &A,Pii &B) {
	if(univ) {
		Swap(n,m);
		FOR(i,1,max(n,m))Swap(a[i],b[i]);
		FOR(i,1,max(n,m))Swap(x[i],y[i]);
	}
	/*DE("Calculate");*/
	FOR(i,1,n)X[i]=X[i-1]+x[i];
	FOR(i,1,m)Y[i]=Y[i-1]+y[i];
	seg.Build();
	/*DE("Find Position");*/
	int pos(0);
	FOR(i,1,n)if(X[i]>(X[n]>>1)&&(pos=i,true))break;
	FOR(i,1,c[0])mxl[i]=1,mnr[i]=n;
	FOR(i,1,pos)mxl[a[i]]=i+1;
	DOR(i,n,pos)mnr[a[i]]=i-1;
	/*DE("Solve");*/
	int tA(0),tB(0);
	static int stA[N],stB[N];
	FOR(i,1,m) {
		while(tA&&mxl[b[stA[tA]]]<mxl[b[i]])seg.Update(stA[tA-1]+1,stA[tA],mxl[b[i]],0),--tA;
		while(tB&&mnr[b[stB[tB]]]>mnr[b[i]])seg.Update(stB[tB-1]+1,stB[tB],0,mnr[b[i]]),--tB;
		seg.Update(stA[++tA]=i,stB[++tB]=i,mxl[b[i]],mnr[b[i]]);
		Data res(seg.Query(1,i));
		if(res.val+Y[i]>ans)ans=res.val+Y[i],A= {res.l,res.r},B= {res.pos,i};
	}
}

signed main() {
#ifdef Plus_Cat
	freopen(Plus_Cat ".in","r",stdin),freopen(Plus_Cat ".out","w",stdout);
#endif
	I(n,m);
	FOR(i,1,n)I(a[i]),c[++c[0]]=a[i];
	FOR(i,1,n)I(x[i]);
	FOR(i,1,m)I(b[i]),c[++c[0]]=b[i];
	FOR(i,1,m)I(y[i]);
	sort(c+1,c+c[0]+1),c[0]=unique(c+1,c+c[0]+1)-c-1;
	FOR(i,1,n)a[i]=lower_bound(c+1,c+c[0]+1,a[i])-c;
	FOR(i,1,m)b[i]=lower_bound(c+1,c+c[0]+1,b[i])-c;
	ll sumA(0),sumB(0);
	FOR(i,1,n)sumA+=x[i];
	FOR(i,1,m)sumB+=y[i];
	sumA>=sumB?(ans=sumA,A= {1,n},B= {0,0}):(ans=sumB,A= {0,0},B= {1,m});
	Solve(0,A,B),Solve(1,B,A),O(ans,'\n',A.first,' ',A.second,'\n',B.first,' ',B.second,'\n');
	return 0;
}
```

------

---

## 作者：lalaouye (赞：0)

超级好的题目，乍一看还以为是套路题，而且被标签误导了，以为是线段树优化 dp。。。

首先可以想到一个 $\mathcal{O}(n^2\log n)$ 的做法，具体是固定一个区间的右端点求每个左端点对应的另外一个序列的最大子段和，而我们发现如果我们反过来可以使用并查集或者链表做到 $\mathcal{O}(n^2)$，可是这个做法看起来难以优化。

而我们发现，如果我们也能固定另外一个区间的一个端点，这样子是可以使用扫描线扫描右端点，再使用单调栈配合线段树更新的，这是好做的，而端点很多，那么有没有一个固定的端点呢？有！如果我们钦定对答案贡献少的区间在第一个序列中，而第二个序列的子段和显然要满足大于总和的一半，不然直接选第二个序列是更优的。那么我们发现，合法的第二个序列的区间必然经过 $pos$，满足 $pre_{pos}>pre_m$ 且 $pre$ 最小，这是显然的。那么我们发现左右端点独立，直接线段树维护即可。

代码：


```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i, l, r) for (int i = l; i <= r; ++ i)
#define rrp(i, l, r) for (int i = r; i >= l; -- i)
#define pii pair <int, int>
#define eb emplace_back
#define inf 1000000000
#define linf 1000000000000000000
#define ls (p << 1)
#define rs (ls | 1)
using namespace std;
typedef long long ll;
constexpr int N = 5e5 + 5, P = 998244353;
inline int rd () {
	int x = 0, f = 1;
	char ch = getchar ();
	while (! isdigit (ch)) { if (ch == '-') f = -1; ch = getchar (); }
	while (isdigit (ch)) { x = (x << 1) + (x << 3) + ch - 48; ch = getchar (); }
	return x * f;
}
int qpow (int x, int y) {
  int ret = 1;
  for (; y; y >>= 1, x = x * x % P) if (y & 1) ret = ret * x % P;
  return ret;
}
int n, m;
int a[N], va[N], b[N], vb[N];
int ans, al, ar, bl, br;
int s1[N], s2[N];
bool flag = 0;
int stk1[N], stk2[N], pos1[N], pos2[N], top1, top2;
int mx[N << 2], LL[N << 2], RR[N << 2], M[N << 2];
int id[N];

int tag[N << 2][3];
void build (int p, int l, int r) {
  mx[p] = - s2[l - 1] - linf * 2; M[p] = l;
  tag[p][0] = tag[p][1] = tag[p][2] = 0;
  if (l == r) return ;
  int mid = l + r >> 1;
  build (ls, l, mid), build (rs, mid + 1, r);
}
void add (int p, int k) {
  mx[p] += k;
  tag[p][0] += k;
}
void psd (int p) {
  if (tag[p][0]) add (ls, tag[p][0]), add (rs, tag[p][0]), tag[p][0] = 0;
  if (tag[p][1]) {
    LL[ls] = tag[ls][1] = tag[p][1];
    LL[rs] = tag[rs][1] = tag[p][1];
    tag[p][1] = 0;
  }
  if (tag[p][2]) {
    RR[ls] = tag[ls][2] = tag[p][2];
    RR[rs] = tag[rs][2] = tag[p][2];
    tag[p][2] = 0;
  }
}
void upd (int p, int l, int r, int L, int R, int k) {
  if (L <= l && r <= R) return add (p, k);
  int mid = l + r >> 1; psd (p);
  if (L <= mid) upd (ls, l, mid, L, R, k);
  if (R > mid) upd (rs, mid + 1, r, L, R, k);
  if (mx[ls] > mx[rs]) M[p] = M[ls];
  else M[p] = M[rs];
  mx[p] = max (mx[ls], mx[rs]);
}
void modify (int p, int l, int r, int L, int R, int k, int o) {
  if (L <= l && r <= R) {
    if (! o) LL[p] = k, tag[p][1] = k;
    else RR[p] = k, tag[p][2] = k;
    return ;
  } int mid = l + r >> 1; psd (p);
  if (L <= mid) modify (ls, l, mid, L, R, k, o);
  if (R > mid) modify (rs, mid + 1, r, L, R, k, o);
}
pii qry (int p, int l, int r, int x) {
  if (l == r) return pii (LL[p], RR[p]);
  int mid = l + r >> 1; psd (p);
  if (x <= mid) return qry (ls, l, mid, x);
  else return qry (rs, mid + 1, r, x);
}
void solve (bool flag) {
  memset (id, 0, sizeof id);
  rep (i, 1, n) s1[i] = s1[i - 1] + va[i];
  rep (i, 1, m) s2[i] = s2[i - 1] + vb[i];
  rep (i, 1, n) id[a[i]] = i;
  build (1, 1, m);
  if (ans <= s1[n]) {
    al = 1, ar = n, bl = br = 0, ans = s1[n];
    if (flag) swap (al, bl), swap (ar, br);
  }
  int pos;
  rep (i, 1, n) if (s1[i] * 2 > s1[n]) {
    pos = i; break;
  }
  top1 = top2 = 0;
  rep (i, 1, m) {
    int p1 = 1, p2 = n;
    if (id[b[i]]) {
      if (id[b[i]] < pos) p1 = id[b[i]] + 1;
      else p2 = id[b[i]] - 1;
    }
    upd (1, 1, m, i, i, s1[pos - 1] - s1[p1 - 1] + linf);
    int now = i - 1;
    while (top1 && pos1[top1] <= p1) {
      int j = stk1[-- top1] + 1;
      upd (1, 1, m, j, now, s1[pos1[top1 + 1] - 1] - s1[p1 - 1]);
      now = j - 1;
    }
    modify (1, 1, m, stk1[top1] + 1, i, p1, 0);
    stk1[++ top1] = i, pos1[top1] = p1;
    upd (1, 1, m, i, i, s1[p2] - s1[pos - 1] + linf);
    now = i - 1;
    while (top2 && pos2[top2] >= p2) {
      int j = stk2[-- top2] + 1;
      upd (1, 1, m, j, now, s1[p2] - s1[pos2[top2 + 1]]);
      now = j - 1;
    }
    modify (1, 1, m, stk2[top2] + 1, i, p2, 1);
    stk2[++ top2] = i, pos2[top2] = p2;
    if (mx[1] + s2[i] > ans) {
      ans = mx[1] + s2[i];
      int j = M[1];
      bl = j, br = i;
      pii t = qry (1, 1, m, j);
      al = t.first, ar = t.second;
      if (flag) swap (al, bl), swap (ar, br);
    }
  }
}
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  n = rd (), m = rd ();
  rep (i, 1, n) a[i] = rd ();
  rep (i, 1, n) va[i] = rd ();
  rep (i, 1, m) b[i] = rd ();
  rep (i, 1, m) vb[i] = rd ();
  solve (0);
  swap (a, b), swap (va, vb), swap (n, m);
  solve (1);
  printf ("%lld\n", ans);
  printf ("%lld %lld\n%lld %lld\n", al, ar, bl, br);
}
```

---

## 作者：DaydreamWarrior (赞：0)

## 分析

注意到一定存在包含 $x$ 中 $\sum_{j=1}^ix_j\geq\frac{\sum x}{2}$ 的第一个 $i$ 的最优方案。因为如果不包含，也就是 $x$ 和 $y$ 选择的两段都小于各自的 $\sum$，那么把 $x$ 和 $y$ 中 $\sum$ 大的那一个全选更优。对于 $y$ 同理。

也就是已经知道常数个位置中的某个会被包含在最优方案，枚举这个位置，假设在 THU 且为 $p$，那么对于 PKU 的 $[l,r]$ 区间，由于相同不能选，就把 THU 切成了很多段，每段都是能选的区间，而 $p$ 一定被选，所以就是 $p$ 所在的那段是答案。

根据 PKU 的选择区间 $[l,r]$ 可以求出 THU 的 选择区间 $[L,R]$。具体的，$i\in[l,r]$，THU 的 $j$ 和 $i$ 相同
  - $j>p$，$R\leftarrow \min(R,j-1)$，
  - $j>p$，$L\leftarrow \max(L,j+1)$，

那么对 PKU 做一个扫描线，需要支持前缀取 $\max$ 和 $\min$ 和求前缀最值。显然 $L,R$ 分别都是单调的，修改的都是一段区间，用线段树解决，递归到能修改才修改，复杂度为 $O(\log n)$。

## 代码

```cpp
#include <iostream>
#include <array>
#include <set>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;

namespace fastio{
    struct{template<typename T>operator T(){
        T x=0;char f=0,c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=1;c=getchar();}
        while(c>='0'&&c<='9'){x=x*10+(c^48);c=getchar();}
        return f?-x:x;
    }}in;int stk[39],tp;
    template<typename T>void out(T x,char c=0){
        if(x<0)putchar('-'),x=-x;
        do stk[tp++]=x%10;while(x/=10);
        while(tp)putchar(stk[--tp]^48);
        if(c)putchar(c);
    }
}using fastio::in;using fastio::out;

const int N = 500005;
int a[N],x[N],b[N],y[N];
int p[N*2];
int n,m;

class segtree{
    private:
        struct{int l,r,tl,tr;pair<int,int> vl,vr,v;int L;} tr[N*4];

        void modify_l(int u,int v){
            tr[u].l = tr[u].tl = v;
            tr[u].v = {tr[u].vr.first-x[v-1],tr[u].vr.second};
            tr[u].vl = {-x[v-1]-y[tr[u].L-1],tr[u].L};
        }

        void modify_r(int u,int v){
            tr[u].r = tr[u].tr = v;
            tr[u].v = {tr[u].vl.first+x[v],tr[u].vl.second};
            tr[u].vr = {x[v]-y[tr[u].L-1],tr[u].L};
        }

        void pushdown(int u){
            if(tr[u].tl){
                modify_l(u<<1,tr[u].tl);
                modify_l(u<<1|1,tr[u].tl);
                tr[u].tl = 0;
            }
            if(tr[u].tr){
                modify_r(u<<1,tr[u].tr);
                modify_r(u<<1|1,tr[u].tr);
                tr[u].tr = 0;
            }
        }

        void pushup(int u){
            tr[u].l = max(tr[u<<1].l,tr[u<<1|1].l);
            tr[u].r = min(tr[u<<1].r,tr[u<<1|1].r);
            tr[u].vl = max(tr[u<<1].vl,tr[u<<1|1].vl);
            tr[u].vr = max(tr[u<<1].vr,tr[u<<1|1].vr);
            tr[u].v = max(tr[u<<1].v,tr[u<<1|1].v);
        }
    public:
        void build(int u,int l,int r){
            tr[u].L = l;
            tr[u].tl = tr[u].tr = 0;
            if(l==r){
                tr[u].l = 1;
                tr[u].r = n;
                tr[u].vl = {-y[l-1],l};
                tr[u].vr = {x[n]-y[l-1],l};
                tr[u].v = {x[n]-y[l-1],l};
                return;
            }
            int mid = (l+r)>>1;
            build(u<<1,l,mid);
            build(u<<1|1,mid+1,r);
            pushup(u);
        }

        void modify_l(int u,int l,int r,int R,int v){
            if(r>R){
                pushdown(u);
                int mid = (l+r)>>1;
                modify_l(u<<1,l,mid,R,v);
                if(mid<R)
                    modify_l(u<<1|1,mid+1,r,R,v);
                pushup(u);
                return;
            }
            if(tr[u].l<=v){
                modify_l(u,v);
                return;
            }
            if(l==r)
                return;
            pushdown(u);
            int mid = (l+r)>>1;
            if(tr[u<<1|1].l<v)
                modify_l(u<<1,l,mid,R,v);
            modify_l(u<<1|1,mid+1,r,R,v);
            pushup(u);
        }

        void modify_r(int u,int l,int r,int R,int v){
            if(r>R){
                pushdown(u);
                int mid = (l+r)>>1;
                modify_r(u<<1,l,mid,R,v);
                if(mid<R)
                    modify_r(u<<1|1,mid+1,r,R,v);
                pushup(u);
                return;
            }
            if(tr[u].r>=v){
                modify_r(u,v);
                return;
            }
            if(l==r)
                return;
            pushdown(u);
            int mid = (l+r)>>1;
            if(tr[u<<1|1].r>v)
                modify_r(u<<1,l,mid,R,v);
            modify_r(u<<1|1,mid+1,r,R,v);
            pushup(u);
        }

        pair<int,int> query(int u,int l,int r,int R){
            if(r<=R)
                return tr[u].v;
            pushdown(u);
            int mid = (l+r)>>1;
            if(tr[u<<1|1].L<=R)
                return max(tr[u<<1].v,query(u<<1|1,mid+1,r,R));
            return query(u<<1,l,mid,R);
        }
}tr;

int L[N],r[N];

array<int,5> solve(int xp){
    array<int,3> ans = {};
    tr.build(1,1,m);
    for(int k=1;k<=m;k++){
        if(p[b[k]]>xp)
            tr.modify_r(1,1,m,k,p[b[k]]-1);
        else if(p[b[k]])
            tr.modify_l(1,1,m,k,p[b[k]]+1);
        auto [w,l] = tr.query(1,1,m,k);
        if(w+y[k]>ans[0])
            ans = {w+y[k],l,k};
    }

    auto complete = [&](array<int,3> v) -> array<int,5> {
        int l = 1,r = n;
        for(int k=v[1];k<=v[2];k++){
            if(p[b[k]]>xp)
                r = min(r,p[b[k]]-1);
            else
                l = max(l,p[b[k]]+1);
        }
        return {v[0],v[1],v[2],l,r};
    };

    return complete(ans);
}

signed main(){
    n = in,m = in;
    for(int k=1;k<=n;k++)
        p[a[k] = in] = k;
    for(int k=1;k<=n;k++)
        x[k] = x[k-1]+(int)in;
    for(int k=1;k<=m;k++)
        b[k] = in;
    for(int k=1;k<=m;k++)
        y[k] = y[k-1]+(int)in;

    array<int,5> ans1 = {};
    for(int k=1;k<=n;k++){
    
        if(x[k]*2>=x[n]){
            ans1 = max(ans1,solve(k));
            break;
        }
        if(x[k]*2==x[n]){
            ans1 = max({ans1,solve(k),solve(k+1)});
            break;
        }
    }

    swap(n,m);
    swap(a,b);
    swap(x,y);
    memset(p,0,sizeof(p));
    for(int k=1;k<=n;k++)
        p[a[k]] = k;


    array<int,5> ans2 = {};

    for(int k=1;k<=n;k++){
        if(x[k]*2>=x[n]){
            ans2 = max(ans2,solve(k));
            break;
        }
        if(x[k]*2==x[n]){
            ans2 = max({ans2,solve(k),solve(k+1)});
            break;
        }
    }

    if(max(x[n],y[m])>=max(ans1[0],ans2[0])){
        if(x[n]>y[m]){
            out(x[n],'\n');
            puts("0 0");
            out(1,' '),out(n);
        }
        else{
            out(y[m],'\n');
            out(1,' '),out(m,'\n');
            puts("0 0");
        }
    }
    else if(ans1[0]>ans2[0]){
        out(ans1[0],'\n');
        out(ans1[3],' '),out(ans1[4],'\n');
        out(ans1[1],' '),out(ans1[2]);
    }
    else{
        out(ans2[0],'\n');
        out(ans2[1],' '),out(ans2[2],'\n');
        out(ans2[3],' '),out(ans2[4]);
    }
    return 0;
}
```

## 闲话

注意 PKU 和 THU 的第一个超过一半的位置都要算，刚好等于一半的话 $i+1$ 也要计算。记录方案可以只记录一半，另一半可以之后算出来。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10656)

**题目大意**

> 给定一个长度为 $n$ 的元素元素序列 $a$ 和一个长度为 $m$ 的元素序列 $b$，每个元素有颜色和权值，同一序列的元素颜色两两不同。
>
> 在两个序列中分别选出一个子区间（可以为空），要求选出所有元素颜色不同，最大化得到的元素和。
>
> 数据范围：$n,m\le 5\times 10^5$。

**思路分析**

首先我们可以全选序列 $a/b$，否则我们选出的两个子区间权值都应该大于其对应序列总权值的一半，否则换成 $a/b$ 中较大的一个。

不妨假设在 $a$ 序列中选出的子区间权值大于 $a$ 的权值总和的一半，那么选出的所有区间一定过 $a$ 的带权中点 $a_x$。

然后考虑在 $b$ 序列上维护答案，如果 $b$ 中有和 $a_x$ 同色的元素，那么在对应位置把 $b$ 分成两半，只要考虑 $a_x$ 不与 $b$ 元素同色的情况即可。

注意到一个 $b$ 中的区间实际上会限制 $a$ 中选取的区间不能经过一些点，又因为 $a$ 中选取的区间一定要过 $x$，因此 $b$ 中每个元素都等价于对 $a$ 上选取区间的左端点或右端点的限制。

从而 $b$ 中一个区间对 $a$ 上选取区间的限制就是左端点限制的最大值和右端点限制的最小值。

那么就可以对 $b$ 扫描线 $r$，单调栈配合线段树维护每个左端点 $l$ 当前的 $b[l,r]$ 限制出的 $a$ 上选取区间的左右端点，容易统计区间和和最大值。

时间复杂度 $\mathcal O(n\log n+m\log m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=5e5+5;
const ll inf=1e18;
struct SegmentTree {
	array <ll,2> tr[MAXN<<2];
	ll tg[MAXN<<2];
	void adt(int p,ll k) { tr[p][0]+=k,tg[p]+=k; }
	void psd(int p) { adt(p<<1,tg[p]),adt(p<<1|1,tg[p]),tg[p]=0; }
	void psu(int p) { tr[p]=max(tr[p<<1],tr[p<<1|1]); }
	void init(int l,int r,int p) {
		tg[p]=0;
		if(l==r) return tr[p]={-inf,l},void();
		int mid=(l+r)>>1;
		init(l,mid,p<<1),init(mid+1,r,p<<1|1);
		psu(p);
	}
	void add(int ul,int ur,ll k,int l,int r,int p) {
		if(ul<=l&&r<=ur) return adt(p,k);
		int mid=(l+r)>>1; psd(p);
		if(ul<=mid) add(ul,ur,k,l,mid,p<<1);
		if(mid<ur) add(ul,ur,k,mid+1,r,p<<1|1);
		psu(p);
	}
}	T;
array <ll,5> ANS;
int dlt=0; bool swp=0;
void gans(ll w,int la,int ra,int lb,int rb) {
	lb+=dlt,rb+=dlt;
	if(swp) swap(la,lb),swap(ra,rb);
	if(w>ANS[0]) ANS={w,la,ra,lb,rb};
}
int pos[MAXN<<1],le[MAXN],ri[MAXN];
int sl[MAXN],tl,sr[MAXN],tr;
void solve(ll *a,ll *b,int *c,int *d,int n,int m) {
	int z=0;
	for(int i=1;i<=n;++i) if(a[i]*2>a[n]) { z=i; break; }
	for(int i=1;i<=m;++i) if(c[z]==d[i]) {
		if(i>1) solve(a,b,c,d,n,i-1);
		if(i<m) dlt=i,solve(a,b+i,c,d+i,n,m-i),dlt=0;
		return ;
	}
	memset(pos,0,sizeof(pos));
	for(int i=1;i<=n;++i) pos[c[i]]=i;
	T.init(1,m,1);
	tl=tr=0,sl[0]=0,sr[0]=0;
	for(int i=1;i<=m;++i) {
		T.add(i,i,inf,1,m,1);
		T.add(1,i,b[i]-b[i-1],1,m,1);
		le[i]=0,ri[i]=n;
		int x=pos[d[i]];
		if(x&&x<z) le[i]=x;
		if(x&&x>z) ri[i]=x-1;
		for(;tl&&le[sl[tl]]<=le[i];--tl) {
			T.add(sl[tl-1]+1,sl[tl],a[le[sl[tl]]],1,m,1);
		}
		for(;tr&&ri[sr[tr]]>=ri[i];--tr) {
			T.add(sr[tr-1]+1,sr[tr],-a[ri[sr[tr]]],1,m,1);
		}
		T.add(sl[tl]+1,i,-a[le[i]],1,m,1),sl[++tl]=i;
		T.add(sr[tr]+1,i,a[ri[i]],1,m,1),sr[++tr]=i;
		auto Z=T.tr[1];
		int L=*lower_bound(sl+1,sl+tl+1,Z[1]),R=*lower_bound(sr+1,sr+tr+1,Z[1]);
		gans(Z[0],le[L]+1,ri[R],Z[1],i);
	}
}
ll a[MAXN],b[MAXN];
int c[MAXN],d[MAXN];
signed main() {
	ios::sync_with_stdio(false);
	int n,m; cin>>n>>m;
	for(int i=1;i<=n;++i) cin>>c[i];
	for(int i=1;i<=n;++i) cin>>a[i],a[i]+=a[i-1];
	for(int i=1;i<=m;++i) cin>>d[i];
	for(int i=1;i<=m;++i) cin>>b[i],b[i]+=b[i-1];
	gans(a[n],1,n,0,0),gans(b[m],0,0,1,m);
	solve(a,b,c,d,n,m),swp=1,solve(b,a,d,c,m,n);
	cout<<ANS[0]<<"\n"<<ANS[1]<<" "<<ANS[2]<<"\n"<<ANS[3]<<" "<<ANS[4]<<"\n";
	return 0;
}
```

---


# 「CZOI-R1」卡牌

## 题目背景

Alice 和 Bob 正在玩卡牌游戏。


## 题目描述

每张卡牌有四个属性：攻击、防御、速度、血量。

我们称一张卡牌能胜过另一张卡牌，当且仅当其至少有三个属性都大于另一张卡牌。

Bob 拥有 $m$ 张卡牌，而 Alice 拥有每个属性值在 $[1, n]$ 的所有 $n^4$ 张卡牌。

现在 Alice 想知道：她有多少张卡牌可以胜过所有 Bob 的卡牌？

## 说明/提示

**【数据范围】**

**本题采用捆绑测试**。

- Subtask #1（$10\text{ pts}$）：$n, m \le 50$。
- Subtask #2（$10\text{ pts}$）：$n, m \le 5 \times 10^3$。
- Subtask #3（$20\text{ pts}$）：$d_i = 1$。
- Subtask #4（$20\text{ pts}$）：$n, m \le 10^5$。
- Subtask #5（$40\text{ pts}$）：无特殊限制。

对于所有测试数据，$1 \le n, m \le 5 \times 10^5$，$1 \le a_i, b_i, c_i, d_i \le n$。

## 样例 #1

### 输入

```
5 5
2 2 1 2
3 4 2 4
4 3 2 2
1 4 2 3
1 2 4 4
```

### 输出

```
32
```

## 样例 #2

### 输入

```
10 10
7 8 5 2
5 9 9 4
3 8 4 3
5 6 5 1
5 5 2 4
9 5 5 1
3 7 2 5
4 4 5 4
9 6 1 5
3 7 3 7
```

### 输出

```
243
```

# 题解

## 作者：Argvchs (赞：32)

首先考虑降维。

注意到若一个卡牌能满足条件，则严格大于其的卡牌都能满足条件，即满足条件的卡牌是连续的，那么可以设 $f_{i, j, k}$ 表示当攻击为 $i$、防御为 $j$、速度为 $k$ 时满足要求的卡牌数量。

当添加一张属性为 $(a, b, c, d)$ 的卡牌时：

- 对于有少于 $2$ 个属性大于当前卡牌的卡牌，这种卡牌已经失败了，于是将 $f_{i, j, k}$ 置为 $0$；
- 对于有 $2$ 个属性大于当前卡牌的卡牌，这种卡牌还需要一个更强的属性，那么它的血量必须在 $(d, n]$ 之间，于是将 $f_{i, j, k}$ 对 $n - d$ 取最小值；
- 对于有 $3$ 个属性都大于当前卡牌的卡牌，这种卡牌已经赢了。

例如当 $n = 3$ 时，添加一张 $(1, 1, 2, 2)$ 的卡牌，此时 $f$ 的值是这样的：

```text
0 0 0 | 0 0 0 | 0 1 1
0 1 1 | 0 1 1 | 1 3 3
0 1 1 | 0 1 1 | 1 3 3
```

（其中每一行表示 $i$，每一列表示 $j$，每一层表示 $k$）

发现我们做的操作其实是：

- 将前 $a$ 行对 $n - d$ 取最小值；
- 将前 $b$ 列对 $n - d$ 取最小值；
- 将前 $c$ 层对 $n - d$ 取最小值；
- 将一个左上角为原点，右下角为 $(a, b, n)$ 的长方体置零；
- 将一个左上角为原点，右下角为 $(a, n, c)$ 的长方体置零；
- 将一个左上角为原点，右下角为 $(n, b, c)$ 的长方体置零。

下文中我们记 $a_i$ 为每一行取到的最小值，$b_i$ 为每一列取到的最小值，$c_i$ 为每一层取到的最小值。只需要从后往前推一遍即可 $O(n)$ 求出这些了。

然后考虑如何统计答案。

实际上，我们可以对于每一层分别求和，同时维护每一列的和。

我们用四个数据结构维护以下四个信息：

1. $t_1(l, r)$ 表示用 $b_j$ 覆盖时 $b_j$ 在列区间 $[l, r]$ 的和；
2. $t_2(l, r)$ 表示用 $b_j$ 覆盖时 $a_i$ 在列区间 $[l, r]$ 的和；
3. $t_3(l, r)$ 表示用 $c_i$ 覆盖时 $a_i$ 在列区间 $[l, r]$ 的和；
4. $t_4(l, r)$ 表示用 $c_i$ 覆盖时 $c_i$ 在列区间 $[l, r]$ 的和。

那么维护过程大概是这样的：首先枚举每一层，处理被取消置零的行和不被 $c_i$ 覆盖的行，同时用数据结构维护以上四个信息，得到每一列的和后考虑 $b_j$ 和 $c_i$ 覆盖了哪些列，然后去掉被置零的列即可。

我们用 $\log$ 数据结构维护以上四个信息，那么总复杂度是 $O(m + n \log n)$ 的。

具体维护过程见代码。

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
using u32 = unsigned;
const int N = 5e5 + 5;
int n, m, a[N], b[N], c[N], x[N], y[N], z[N], f[N], g[N], h[N];
u32 ans;
// 线段树维护区间带权加、区间求和
struct segment_tree {
    u32 s[N], t[N << 2], lzy[N << 2];
    void pushup(int rt) { t[rt] = t[rt << 1] + t[rt << 1 | 1]; }
    void push(int rt, int l, int r, u32 k) { t[rt] += (s[r] - s[l - 1]) * k, lzy[rt] += k; }
    void pushdown(int rt, int l, int r) {
        if (!lzy[rt]) return;
        int mid = (l + r) >> 1;
        push(rt << 1, l, mid, lzy[rt]);
        push(rt << 1 | 1, mid + 1, r, lzy[rt]);
        lzy[rt] = 0;
    }
    void update(int rt, int l, int r, int x, int y, u32 k) {
        if (x <= l && r <= y) return push(rt, l, r, k);
        pushdown(rt, l, r);
        int mid = (l + r) >> 1;
        if (x <= mid) update(rt << 1, l, mid, x, y, k);
        if (y >= mid + 1) update(rt << 1 | 1, mid + 1, r, x, y, k);
        pushup(rt);
    }
    u32 query(int rt, int l, int r, int x, int y) {
        if (x <= l && r <= y) return t[rt];
        pushdown(rt, l, r);
        int mid = (l + r) >> 1;
        u32 ret = 0;
        if (x <= mid) ret += query(rt << 1, l, mid, x, y);
        if (y >= mid + 1) ret += query(rt << 1 | 1, mid + 1, r, x, y);
        return ret;
    }
    void update(int l, int r, u32 k) { update(1, 1, n, l, r, k); }
    u32 query(int l, int r) { return query(1, 1, n, l, r); }
} t1;
// 树状数组维护区间加、区间求和
struct fenwick_tree {
    u32 t1[N], t2[N];
    void update(int x, u32 k) {
        for (int i = x; i <= n; i += i & -i) t1[i] += k, t2[i] += k * x;
    }
    u32 query(int x) {
        u32 ret = 0;
        for (int i = x; i >= 1; i -= i & -i) ret += (x + 1) * t1[i] - t2[i];
        return ret;
    }
    void update(int l, int r, u32 k) { update(l, k), update(r + 1, -k); }
    u32 query(int l, int r) { return query(r) - query(l - 1); }
} t2, t3, t4;
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) a[i] = b[i] = c[i] = n;
    for (int i = 1, ai, bi, ci, di; i <= m; i++) {
        cin >> ai >> bi >> ci >> di, di = n - di;
        a[ai] = min(a[ai], di); // 每一行最小值 ai
        b[bi] = min(b[bi], di); // 每一列最小值 bi
        c[ci] = min(c[ci], di); // 每一层最小值 ci
        x[ai] = max(x[ai], bi); // 每一行置零的列数 xi
        y[ci] = max(y[ci], ai); // 每一层置零的行数 yi
        z[ci] = max(z[ci], bi); // 每一层置零的列数 zi
    }
    for (int i = n - 1; i >= 1; i--) {
        a[i] = min(a[i], a[i + 1]), b[i] = min(b[i], b[i + 1]), c[i] = min(c[i], c[i + 1]);
        x[i] = max(x[i], x[i + 1]), y[i] = max(y[i], y[i + 1]), z[i] = max(z[i], z[i + 1]);
    }
    y[0] = n, g[0] = 1; // 处理一些边界
    for (int i = 1, j = 1, k = 1, l = 1; i <= n; i++) {
        while (j <= n && b[j] <= a[i]) ++j; // fi 为第一个 bj > ai 的列
        while (k <= n && a[k] <= c[i]) ++k; // gi 为第一个 aj > ci 的行
        while (l <= n && b[l] <= c[i]) ++l; // hi 为第一个 bj > ci 的列
        f[i] = j, g[i] = k, h[i] = l;
    }
    for (int i = 1; i <= n; i++) t1.s[i] = t1.s[i - 1] + b[i];
    for (int i = 1; i <= n; i++) {
        // 处理被取消置零的行
        for (int j = y[i - 1]; j > y[i]; j--) {
            // 可以被 bj 覆盖的列区间 (xj, fj)
            // 可以被 ci 覆盖的列区间 (xj, n]
            int l = x[j] + 1, r = max(l - 1, f[j] - 1);
            t1.update(l, r, 1);                      // 更新 t1，注意使用的数据结构
            t2.update(r + 1, n, a[j]);               // 更新 t2
            if (j < g[i - 1]) t3.update(l, n, a[j]); // 若没有被 ci 覆盖则更新 t3
            else t4.update(l, n, 1);                 // 否则更新 t4
        }
        // 处理不被 ci 覆盖的行
        for (int j = g[i - 1]; j < g[i]; j++) {
            int l = x[j] + 1;
            if (j > y[i]) t3.update(l, n, a[j]), t4.update(l, n, -1); // 若没有被置零则更新
        }
        // 可以被 bj 覆盖的列区间 (zi, hi)
        int l = z[i] + 1, r = max(l - 1, h[i] - 1);
        // 对于 bj < ci 的列，用 bj 覆盖肯定更优，否则用 ci 覆盖
        ans += t1.query(l, r) + t2.query(l, r) + t3.query(r + 1, n) + t4.query(r + 1, n) * c[i];
    }
    cout << ans;
}
```

---

## 作者：SwordDance (赞：14)

时间复杂度大常数 $O(N)$，好像爆标了。


记 $f_{i,j,k}$ 表示前三种属性值依次为 $i,j,k$ 时，符合条件的卡牌的数量。

将整个 $f$ 数组看成一个大正方体，每加入一张卡牌 $(x,y,z,w)$ 时：

-  对于前 $x$ 行、前 $y$ 列、前 $z$ 层的所有点与 $n-d$ 取最小值 $\min$ 。（这些点前三个属性值中，已经至少一个属性值比这种卡小，所有第四个属性值要严格大于 $w$）
-  对前 $x$ 行且前 $y$ 列，前 $x$ 行且前 $z$ 层，前 $y$ 列且前 $z$ 层的点赋值为 $0$。
（这些点已经不可能成为答案）

将第一个样例操作后的图层依次如下：

```cpp
0 0 0 0 1  |  0 0 0 0 1  |  0 1 1 1 1  |  0 1 1 1 1  |  1 1 1 3 5  
0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 1 1  |  0 0 0 1 1  |  0 0 0 1 1  
0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 1  |  0 0 0 0 1  |  0 0 0 0 1    
0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 1  
0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 0  |  0 0 0 0 1  

```
每层累加后的数字即为答案。

由于从上到下数字依次减少，我们考虑从上到下层层维护。

记 $X_{i}$ 为前 $i$ 行上的最小值，$Y_{i}$ 为前 $i$ 列上的最小值，$TX_{i}$ 为第 $i$ 行上的 $0$ 的数量，$TY_{i}$ 为第 $i$ 列上的 $0$ 的数量。

对于初始矩阵，我们枚举行 $i$，记 $now$ 为满足 $Y_{now}<X_{i}$ 的最小列， 显然：$0$ 是连续的，因此我们可以利用前缀和轻松求出答案。而 $now$ 是单调不降的，所以总复杂度 $O(N)$。 

记 $Z_{i}$ 为前 $i$ 层上的最小值，$Qx_{i}$ 为前 $i$ 层上的点的行的最大值，$Qy_{i}$ 为前 $i$ 层上的点的列的最大值。

对于每一层，我们有两种操作：

- 将整层的数与 $Z_{i}$ 取 $\min$。
- 将查询范围缩小至左下角为 $(Qx_{i},Qy_{i})$，右上角为 $(n,n)$ 的矩阵中。（也就是将除此部分外的矩阵赋值为 $0$）

注意到，修改和查询操作都具有单调性。

- 对于每次修改，预处理初始矩阵每个 $X_{i}$、$Y_{i}$ 值的贡献次数 $cntx_{i}$、$cnty_{i}$。记 $nowx$、$nowy$ 为当前修改到的行、列，左下角 $(nowx,nowy)$，右上角 $(n,n)$ 的子矩阵要么是 $0$，要么是 $Z_{i}$。

  修改第 $j$ 行时， 当前层 $i$ 答案 $ans=ans-(X_{j}-Z_{i})\times cntx_{j}$。 维护这个矩阵中的有效数字的数量 $Num$ 即可实现后续修改。由于 $nowx$、$nowy$ 单调，此部分为 $O(N)$ 的。

- 对于每次查询，由于这个矩阵行、列均只会越来越小，我们暴力统计和赋 $0$，此部分也是 $O(N)$ 的。

代码细节很多，具体细节见注释。

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned int u32;
const int N=5e5+3;
u32 n,m,x,y,z,w,now;
u32 X[N],Y[N],Z[N],TX[N],TY[N],Qx[N],Qy[N],num[N],Num;
u32 nowx,nowy;
u32 cntx[N],cnty[N],sumx[N],sumy[N],ans,answer;
int main()
{
    scanf("%u%u",&m,&n);
    for(int i=1;i<=m;i++) X[i]=Y[i]=Z[i]=m;
    for(int i=1;i<=m;i++){
    	scanf("%u%u%u%u",&x,&y,&z,&w);
    	X[x]=min(X[x],m-w);
    	Y[y]=min(Y[y],m-w);
    	Z[z]=min(Z[z],m-w);
    	TX[x]=max(TX[x],y);
    	TY[y]=max(TY[y],x);
    	Qx[z]=max(Qx[z],x);
		Qy[z]=max(Qy[z],y); 
	}
	for(int i=m-1;i>=1;i--){ //递推即可 
        X[i]=min(X[i],X[i+1]);
		Y[i]=min(Y[i],Y[i+1]);
		Z[i]=min(Z[i],Z[i+1]);
		TX[i]=max(TX[i],TX[i+1]); 
		TY[i]=max(TY[i],TY[i+1]);
		Qx[i]=max(Qx[i],Qx[i+1]);
		Qy[i]=max(Qy[i],Qy[i+1]);
    }
    for(int i=1;i<=m;i++){ //行、列前缀和 
    	sumx[i]=sumx[i-1]+X[i];
    	sumy[i]=sumy[i-1]+Y[i];
    } 
	for(int i=1;i<=m;i++){ //求出初始矩阵 
		while(now<m&&Y[now+1]<X[i]) now++;
		if(now>TX[i]){
			cntx[i]+=m-now;
			num[TX[i]+1]++,num[now+1]--;
    	}
		else cntx[i]+=m-TX[i];
		ans+=cntx[i]*X[i];
	}
	for(int i=1;i<=m;i++){
    	num[i]+=num[i-1];
	    cnty[i]+=num[i];
		ans+=cnty[i]*Y[i];
    }
	Z[m+1]=m;
	nowx=nowy=m;
	for(int i=m;i>=1;i--){ 
		ans-=Num*(Z[i+1]-Z[i]); //右上角的修改子矩阵，值需与当前值 Z[i]同步 
	    while(nowy>Qy[i]&&Y[nowy]>Z[i]){ //修改子矩阵超出查询子矩阵的部分是没有意义的 
	    	TY[nowy]=max(TY[nowy],Qx[i]);
	    	cnty[nowy]=min(cnty[nowy],m-TY[nowy]);
			ans-=cnty[nowy]*(Y[nowy]-Z[i]);
			Num+=cnty[nowy];
			cnty[nowy]=0; //修改后，行的贡献全部算入列中 
			nowy--;
    	}
		while(nowx>Qx[i]&&X[nowx]>Z[i]){ 
			TX[nowx]=max(TX[nowx],Qy[i]);
			cntx[nowx]=min(cntx[nowx],m-TX[nowx]);
			ans-=cntx[nowx]*(X[nowx]-Z[i]);
			Num+=cntx[nowx];
			cntx[nowx]=m-max(TX[nowx],nowy);
			nowx--;
		}
		for(int j=Qx[i+1]+1;j<=Qx[i];j++){ //减去将第j列的贡献 
		    TX[j]=max(TX[j],Qy[i+1]); //减去行和减去列的相交部分算入列中，避免重复计数 
			if(nowx<j) X[j]=Z[i]; 
			if(nowx<j) cntx[j]=m-max(TX[j],nowy); //更新X[j]的贡献次数 
			else cntx[j]=min(cntx[j],m-TX[j]);
			ans-=cntx[j]*X[j];
			ans-=sumy[m-cntx[j]]-sumy[TX[j]];
			if(nowx<j) Num-=cntx[j];
		}
		for(int j=Qy[i+1]+1;j<=Qy[i];j++){ //减去第j行的贡献 
		    TY[j]=max(TY[j],Qx[i]);
			if(nowy>=j){ //如果第j行没有被修改 
				cnty[j]=min(cnty[j],m-TY[j]);
	    		ans-=cnty[j]*Y[j];
	    		ans-=sumx[m-cnty[j]]-sumx[TY[j]];
	    	}
			else{
				if(nowx>=Qx[i]){
			    	if(Qx[i]>=TY[j]) ans-=sumx[nowx]-sumx[Qx[i]];
			    	else if(nowx>=TY[j]) ans-=sumx[nowx]-sumx[TY[j]];
		    	}
				if(nowx>=TY[j]) ans-=Z[i]*(m-nowx);
				else ans-=Z[i]*(m-TY[j]);
			}
			if(nowy<j) Num-=m-max(TY[j],nowx);
		}
		answer+=ans;//总答案加上每层的答案 
	}
	printf("%u",answer);
	return 0;
}
```

---

## 作者：cyffff (赞：13)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10800)

最近做的最神金的一道数据结构题。
## 题意
给出 $m$ 个值域为 $[1,n]$ 的四元组 $t_{i,0\sim 3}$，定义四元组 $A$ 胜于四元组 $B$ 当且仅当最多存在一个 $j\in[0,3]$ 使得 $A_j\le B_j$，求出有多少个值域为 $[1,n]$ 的四元组 $A$ 胜于所有的 $t_{1\sim n}$。

$n,m\le 5\times 10^5$。
## 题解
为了易读，本文中递增表示不递减，递减表示不递增。

一个直接的思路就是令 $v_{i,j,k}$ 表示有几个合法四元组前三维分别为 $i,j,k$，此时合法四元组的第四维是一个后缀。

那么我们考虑一个限制 $t$：
- 如果前三维均比 $t$ 大，则无需考虑该限制；
- 如果前三维恰有一维不比 $t$ 大，则第四维要比 $t$ 大；
- 如果前三维有至少两维不比 $t$ 大，则必然不合法。

考虑这个恰有一维是不需要的，我们可以将它转为对 $v$ 的操作：
- 对于 $i\le t_0$，将 $v_{i,j,k}$ 对 $n-t_3$ 取 $\min$；
- 对于 $j\le t_1$，将 $v_{i,j,k}$ 对 $n-t_3$ 取 $\min$；
- 对于 $k\le t_2$，将 $v_{i,j,k}$ 对 $n-t_3$ 取 $\min$；
- 对于 $i\le t_0\land j\le t_1$，将 $v_{i,j,k}$ 设为 $0$；
- 对于 $i\le t_0\land k\le t_2$，将 $v_{i,j,k}$ 设为 $0$；
- 对于 $j\le t_1\land k\le t_2$，将 $v_{i,j,k}$ 设为 $0$。

显然这些操作的顺序对答案无影响，则我们可以处理出 $a_i,b_j,c_k$ 表示考虑前三种操作后第 $i$ 行，第 $j$ 列，第 $k$ 层的取 $\min$ 标记。不考虑置零操作，则 $v_{i,j,k}=\min(a_i,b_j,c_k)$，其中 $a,b,c$ 均单调递增。

再考虑置零操作。设第 $j$ 列最大清到行 $u_j$（第一种），第 $k$ 层最大清到行 $x_k$（第二种）、列 $y_k$（第三种），其中 $u,x,y$ 均单调递减。

答案即可表示为
$$\sum_{i,j,k}^{i>u_j\land i>x_k\land j>y_k}\min(a_i,b_j,c_k)$$
但这样不优。

令 $f_j$ 为最大的 $i$ 使得 $a_i\le b_j$，$g_k$ 为最大的 $j$ 使得 $b_j\le c_k$，$h_k$ 为最大的 $i$ 使得 $a_i\le c_k$，显然 $f,g,h$ 均单调递增。

考虑对 $k$ 扫描线，则第 $k$ 层的 $v_{i,j,k}$ 如下所示：

$$\begin{pmatrix}
b_1&b_2&\dots&b_{j}&c_k&\dots&c_k\\
.&.&\dots &.&.&\dots&.\\
b_1&b_2&\dots&b_{j}&c_k&\dots&c_k\\
b_1&b_2&\dots&b_{j}&a_{h_k}&\dots&a_{h_k}\\
.&.&\dots &.&.&\dots&.\\
b_1&b_2&\dots &b_j&a_{f_j+1}&\dots&a_{f_j+1}\\
b_1&b_2&\dots &a_{f_j}&a_{f_j}&\dots&a_{f_j}\\
.&.&\dots &.&.&\dots&.\\
b_1&a_{f_2}&\dots &a_{f_2}&a_{f_2}&\dots&a_{f_2}\\
.&.&\dots &.&.&\dots&.\\
.&.&\dots &.&.&\dots&.\\
a_{1}&a_{1}&\dots &a_{1}&a_{1}&\dots&a_{1}\\
\end{pmatrix}
$$

其中 $j=g_k$。则答案分为四个部分：

- 在 $g_k$ 列及之前的取到 $a_i$ 作为最小值的部分：$\displaystyle\sum_{j=y_k+1}^{g_k}\sum_{i=\max(x_k,u_j)+1}^{f_j}a_i$；
- 取到 $b_j$ 作为最小值的部分：$\displaystyle\sum_{j=y_k+1}^{g_k}[n-\max(x_k,u_j,f_j)]b_j$；
- 在 $g_k$ 列之后的取到 $a_i$ 作为最小值的部分：$\displaystyle\sum_{j=\max(y_k,g_k)+1}^{n}\sum_{i=\max(x_k,u_j)+1}^{h_k}a_i$；
- 取到 $c_k$ 作为最小值的部分：$\displaystyle c_k\sum_{j=\max(y_k,g_k)+1}^{n}[n-\max(x_k,u_j,h_k)]$。

再求出 $p_i$ 为最大的 $j$ 使得 $u_j\ge i$，$q_i$ 为最小的 $j$ 使得 $f_j\ge i$。在移动 $k\to k+1$ 时增加 $h$、减少 $x$ 并依据式子对四个部分分别增量，分别使用线段树或树状数组维护即可。

认为 $n,m$ 同阶，时间复杂度 $O(n\log n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ui unsigned
namespace IO{//by cyffff
	
}
inline void umn(int &x,int y){ x=min(x,y); }
inline void umx(int &x,int y){ x=max(x,y); }
const int N=5e5+10;
int n,m,a[N],b[N],c[N],f[N],g[N],h[N],u[N],x[N],y[N],p[N],q[N];
struct Segment_Tree{
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	ui ans[N<<2],sum[N<<2],tag[N<<2];
	inline void pushup(int rt){
		ans[rt]=ans[ls]+ans[rs];
		sum[rt]=sum[ls]+sum[rs];
	}
	inline void pushtag(int rt,ui v){
		tag[rt]+=v,ans[rt]+=sum[rt]*v;
	}
	inline void pushdown(int rt){
		if(!tag[rt]) return ;
		pushtag(ls,tag[rt]);
		pushtag(rs,tag[rt]);
		tag[rt]=0;
	}
	inline void build(int rt,int l,int r){
		if(l==r){
			sum[rt]=b[l];
			return ;
		}
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		pushup(rt);
	}
	inline void modify(int rt,int l,int r,int L,int R,ui v){
		if(L>R) return ;
		if(L<=l&&r<=R) return pushtag(rt,v);
		pushdown(rt);
		int mid=l+r>>1;
		if(L<=mid) modify(ls,l,mid,L,R,v);
		if(R>mid) modify(rs,mid+1,r,L,R,v);
		pushup(rt);
	}
	inline ui query(int rt,int l,int r,int L,int R){
		if(L>R) return 0;
		if(L<=l&&r<=R) return ans[rt];
		pushdown(rt);
		int mid=l+r>>1;
		ui s=0;
		if(L<=mid) s+=query(ls,l,mid,L,R);
		if(R>mid) s+=query(rs,mid+1,r,L,R);
		return s;
	}
}T3;
struct BIT{
	#define lowbit(i) (i&-i)
	ui t1[N],t2[N];
	inline void add(int x,ui v){
		for(int i=x;i<=n;i+=lowbit(i))
			t1[i]+=v,t2[i]+=1u*x*v;
	}
	inline ui query(int x){
		ui s1=0,s2=0;
		for(int i=x;i;i-=lowbit(i))
			s1+=t1[i],s2+=t2[i];
		return 1u*(x+1)*s1-s2; 
	}
	inline ui query(int l,int r){
		return l<=r?query(r)-query(l-1):0;
	}
}T[3];
int main(){
	n=read(),m=read();
	for(int i=1;i<=n+1;i++)
		a[i]=b[i]=c[i]=n;
	for(int i=1;i<=m;i++){
		int A=read(),B=read(),C=read(),D=read();
		umn(a[A],n-D),umn(b[B],n-D),umn(c[C],n-D);
		umx(u[B],A),umx(x[C],A),umx(y[C],B);
	}
	for(int i=n;i;i--)
		umn(a[i],a[i+1]),umn(b[i],b[i+1]),umn(c[i],c[i+1]),
		umx(u[i],u[i+1]),umx(x[i],x[i+1]),umx(y[i],y[i+1]);
	x[0]=n;
	for(int i=0,j=1;j<=n;j++){
		while(i<n&&a[i+1]<=b[j]) i++;
		f[j]=i;
	}
	for(int j=0,k=1;k<=n;k++){
		while(j<n&&b[j+1]<=c[k]) j++;
		g[k]=j;
	}
	for(int i=0,k=1;k<=n;k++){
		while(i<n&&a[i+1]<=c[k]) i++;
		h[k]=i;
	}
	for(int j=0,k=n;k;k--){
		while(j<n&&u[j+1]>=k) j++;
		p[k]=j;
	}
	for(int j=n+1,k=n;k;k--){
		while(j&&f[j-1]>=k) j--;
		q[k]=j;
	}
	T3.build(1,1,n);
	ui ans=0;
	for(int k=1;k<=n;k++){
		for(int i=h[k-1]+1;i<=h[k];i++)
			if(i>x[k-1]){
				T[1].add(p[i]+1,a[i]);
				T[2].add(p[i]+1,-1);
			}
		for(int i=x[k-1];i>x[k];i--){
			T[0].add(max(p[i]+1,q[i]),a[i]);
			T3.modify(1,1,n,p[i]+1,q[i]-1,1);
			if(i<=h[k]) T[1].add(p[i]+1,a[i]);
			if(i>h[k]) T[2].add(p[i]+1,1);
		}
		ans+=T[0].query(y[k]+1,g[k]);
		ans+=T3.query(1,1,n,y[k]+1,g[k]);
		ans+=T[1].query(max(y[k],g[k])+1,n);
		ans+=1u*c[k]*T[2].query(max(y[k],g[k])+1,n);
	}
	write(ans);
	flush();
}
```

---

## 作者：yyyyxh (赞：10)

乍一看是巨大多数高维数点题，仔细一做发现是清新 $O(n)$ 小 DS。很有趣！

首先我们考虑如何处理“至多一维”是输的这个限制，方法是对于每对不同的两维，要求它们不能同时是输的。即 $a\le a_i,b\le b_i$ 不能同时成立。

那么类似 2-SAT 建图的想法，我们把这种关系描述成“若 $a\le a_i$，则 $b> b_i$”或者“若 $b\le b_i$，则 $a> a_i$”。发现这个限制关系是**单向的**且是可以**任意定向**的，保留上述两个式子的任意一个都与原来的条件等价，给了我们很多操作空间。

我们考虑先从大到小枚举 $d$ 这一维，此时 $d$ 的取值会对 $a,b,c$ 的取值有一个下界限制，这个限制会不断的缩紧。相当于每次删去 $a,b,c$ 数组的一段前缀。

我们记录下 $a,b,c$ 数组每个位置被删除的时间 $av,bv,cv$，那么对于一个合法的 $(a,b,c)$ 三元组，对答案的贡献就是 $\min(av_a,bv_b,cv_c)$。

现在原题变成了一个带了一点权的三维问题，而本题三维的情况是很好做到 $O(n)$ 的。具体方法是枚举一维，然后其对于第二、三维有一个下界限制，而第二维的值对于第三维也是一个下界限制。对于第二维的一个取值，第三维的取值个数可以用一个 $\max$ 表示。而一维对另一维的限制数组具有单调性，所以用双指针求下分界点前缀和一下就可以做完了。

如何处理对于答案的贡献的那个 $\min$ 呢？注意到 $a,b,c$ 地位相同，所以你钦定是哪一维取到最小值，对其它维的限制也是一个下界，把这一维当作前面方法所述的第一维做就好了。

代码很好写，复制粘贴一下就没啥细节了。总时间复杂度为 $O(n)$。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef unsigned int ui;
ui read(){/* read */}
const ui N=500003;
ui n,m;
ui a[N],b[N],c[N],d[N];
ui amx[N],bmx[N],cmx[N];
ui av[N],bv[N],cv[N];
ui ab[N],ac[N];
ui ba[N],bc[N];
ui ca[N],cb[N];
ui ps[N],w[N];
inline void chmx(ui &x,ui v){if(x<v) x=v;}
int main(){
	n=read();m=read();
	for(ui i=1;i<=m;++i) a[i]=read(),b[i]=read(),c[i]=read(),d[i]=read();
	for(ui i=1;i<=m;++i){
		chmx(amx[d[i]],a[i]);
		chmx(bmx[d[i]],b[i]);
		chmx(cmx[d[i]],c[i]);
		chmx(ab[a[i]],b[i]);
		chmx(ac[a[i]],c[i]);
		chmx(ba[b[i]],a[i]);
		chmx(bc[b[i]],c[i]);
		chmx(ca[c[i]],a[i]);
		chmx(cb[c[i]],b[i]);
	}
	for(ui i=n-1;i;--i){
		chmx(amx[i],amx[i+1]);
		chmx(bmx[i],bmx[i+1]);
		chmx(cmx[i],cmx[i+1]);
		chmx(ab[i],ab[i+1]);
		chmx(ac[i],ac[i+1]);
		chmx(ba[i],ba[i+1]);
		chmx(bc[i],bc[i+1]);
		chmx(ca[i],ca[i+1]);
		chmx(cb[i],cb[i+1]);
	}
	ui ap=1,bp=1,cp=1;
	for(ui i=n;i;--i){
		while(ap<=amx[i]) av[ap++]=n-i;
		while(bp<=bmx[i]) bv[bp++]=n-i;
		while(cp<=cmx[i]) cv[cp++]=n-i;
	}
	while(ap<=n) av[ap++]=n;
	while(bp<=n) bv[bp++]=n;
	while(cp<=n) cv[cp++]=n;
	ui res=0;
	for(ui i=1;i<=n;++i) w[i]=w[i-1]+n-bc[i];
	for(ui i=n+1,t=1;i;--i){
		while(t<=n&&bc[t]>=i) ++t;
		ps[i]=t-1;
	}
	bp=cp=1;
	for(ui a=1;a<=n;++a){
		while(bp<=n&&bv[bp]<av[a]) ++bp;
		while(cp<=n&&cv[cp]<av[a]) ++cp;
		ui bl=max(bp,ab[a]+1);
		ui cl=max(cp,ac[a]+1);
		if(ps[cl]<bl) res+=(n-bl+1)*(n-cl+1)*av[a];
		else res+=((n-ps[cl])*(n-cl+1)+w[ps[cl]]-w[bl-1])*av[a];
	}
	for(ui i=1;i<=n;++i) w[i]=w[i-1]+n-ac[i];
	for(ui i=n+1,t=1;i;--i){
		while(t<=n&&ac[t]>=i) ++t;
		ps[i]=t-1;
	}
	ap=cp=1;
	for(ui b=1;b<=n;++b){
		while(ap<=n&&av[ap]<=bv[b]) ++ap;
		while(cp<=n&&cv[cp]<bv[b]) ++cp;
		ui al=max(ap,ba[b]+1);
		ui cl=max(cp,bc[b]+1);
		if(ps[cl]<al) res+=(n-al+1)*(n-cl+1)*bv[b];
		else res+=((n-ps[cl])*(n-cl+1)+w[ps[cl]]-w[al-1])*bv[b];
	}
	for(ui i=1;i<=n;++i) w[i]=w[i-1]+n-ab[i];
	for(ui i=n+1,t=1;i;--i){
		while(t<=n&&ab[t]>=i) ++t;
		ps[i]=t-1;
	}
	ap=bp=1;
	for(ui c=1;c<=n;++c){
		while(ap<=n&&av[ap]<=cv[c]) ++ap;
		while(bp<=n&&bv[bp]<=cv[c]) ++bp;
		ui al=max(ap,ca[c]+1);
		ui bl=max(bp,cb[c]+1);
		if(ps[bl]<al) res+=(n-al+1)*(n-bl+1)*cv[c];
		else res+=((n-ps[bl])*(n-bl+1)+w[ps[bl]]-w[al-1])*cv[c];
	}
	printf("%u\n",res);
	return 0;
}
```

upd on 2024.8.8: 一开始 `ap<=n` 打成 `ap<=m`，但是据 `assert` 由于本题数据全部有 $m\ge n$ 没有测试出来……

---

## 作者：王熙文 (赞：7)

提供一种 $\mathcal O(n)$ 的做法。

## 思路

首先考虑三维的问题（即 [CF815D](https://www.luogu.com.cn/problem/CF815D)）如何做。考虑将可以打败某张卡牌的三元组放到坐标系中。

![](https://cdn.luogu.com.cn/upload/image_hosting/y66n7lei.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

问题便转化为对这些区域求交。考虑计算补集的并。考虑从上到下扫描线。最初它们的并就是若干个过原点的矩形的并，并出来的形状是台阶，即纵坐标单调递减。当高度等于某个三元组的 $c$ 时，并就加入了一条横向和一条竖向的线，它们表示横线向上、竖线向左都属于并的部分。而这些线可以先合并，只保留最大的。现在问题便转化为了多次计算下图的阴影面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/p4f9jtpn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

设每个横坐标上的台阶的高度为 $ax_i$，$ax$ 的前缀和为 $qzh$，竖线的横坐标为 $a$，横线的纵坐标为 $b$，台阶中最后一个满足 $ax_i>b$ 的 $i$ 为 $wz$，则面积为 $(a+b)n-ab+qzh_{wz}-qzh_{a}-b\cdot (wz-a)$。当 $wz \le a$ 的时候不计算后面的部分。

因为 $b$ 单调递增，所以 $wz$ 单调递减，可以使用双指针求出来。这样三维的问题就在 $\mathcal O(n)$ 的时间内解决了。

对于四维的问题，继续扫描线。从大到小枚举第四维。最初，第四维大于所有 $d$，问题便是三维的问题。当第四维等于某个 $d$ 时，并就加入了三维中除了最小的长方体外的剩下的三个长方体。考虑将三维中那 $n$ 个台阶加上两条线的图形拿出来。可以发现加入最下面的长方体时，高度 $\le c$ 的图形的并填满了，这些图形的答案便是 $n^2$。对于高度 $>c$ 的图形，就像三维时，并也加入了一条横向和一条竖向的线。现在问题转化为了对所有高度 $>c$ 的图形，将原先的两条线与现在的两条线取最大值，并计算新的面积并求和。

当高度增大时，原先的两条线逐渐减小，所以这四条线会经历三个阶段：原先的两条线都大于现在的两条线；原先的一条线大于现在，另一条小于等于现在；原先的两条线都小于等于现在的两条线。过程形如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/3moya8zq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

第一阶段的答案就是三维问题中的答案，第三阶段的答案与图形的高度无关，可以统一求出。接下来的问题便是如何求第二阶段的答案。

假设第二阶段是原先的横线大于现在的横线，原先竖线小于等于现在的竖线。反过来本质相同。

这个问题等价于有若干条横线，多次查询添加一条竖线后面积之和。设横线的纵坐标为 $b_1,b_2,\cdots,b_k$，竖线的横坐标为 $a$。将这些线再放回台阶中。横线有两种情况：包含台阶组成的面积或不包含。对于后者，答案即为 $(a+b_i)n-a\cdot b_i$，计算 $b_i$ 的前缀和，便可以快速地求出这个式子。对于前者，答案多了台阶的面积。设台阶中最后一个满足 $ax_j>b_i$ 的 $j$ 为 $wz_i$，则面积为 $qzh_{wz_i}-qzh_a-b_i \cdot (wz_i-a)$。计算 $qzh_{wz_i},b_i\cdot wz_i$ 的前缀和即可。前者和后者在数组中的分界可以通过二分第一个 $b_i<ax_{a+1}$ 的位置得到。

现在问题已经可以在 $\mathcal O(n\log n)$ 的时间内解决了。可以发现现在的两条线也具有单调性，所以所有二分都可以改为双指针，这样的复杂度就降为 $\mathcal O(n)$ 了。

## 代码

二分的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned
int n,m;
int ax[500010],qzh[500010];
int tot=0,gta[500010],gtb[500010],nxt[500010],head[500010];
int ttot=0,ggta[500010],ggtb[500010],ggtc[500010],nnxt[500010],hhead[500010];
int aa[500010],bb[500010];
int wz[500010],ans[500010];
int qa[500010],qqa[500010],qb[500010],qbw[500010],qqw[500010],qans[500010];
signed main()
{
	cin>>n>>m;
	for(int i=1; i<=m; ++i)
	{
		int a,b,c,d; cin>>a>>b>>c>>d;
		ax[a]=max(ax[a],b);
		gta[++tot]=a,gtb[tot]=b,nxt[tot]=head[c],head[c]=tot;
		ggta[++ttot]=a,ggtb[ttot]=b,ggtc[ttot]=c,nnxt[ttot]=hhead[d],hhead[d]=ttot;
	}
	for(int i=n-1; i>=1; --i) ax[i]=max(ax[i],ax[i+1]);
	for(int i=1; i<=n; ++i) qzh[i]=qzh[i-1]+ax[i];
	int axa=0,axb=0,wwz=n;
	for(int i=n; i>=1; --i)
	{
		for(int j=head[i]; j!=0; j=nxt[j]) axa=max(axa,gta[j]),axb=max(axb,gtb[j]);
		aa[i]=axa,bb[i]=axb;
		ans[i]=(axa+axb)*n-axa*axb;
		while(wwz>=1 && ax[wwz]<=axb) --wwz;
		wz[i]=wwz;
		if(axb<ax[axa+1]) ans[i]+=qzh[wwz]-qzh[axa]-axb*(wwz-axa);
	}
	for(int i=1; i<=n; ++i)
	{
		qa[i]=qa[i-1]+aa[i],qqa[i]=qqa[i-1]+qzh[aa[i]];
		qb[i]=qb[i-1]+bb[i],qbw[i]=qbw[i-1]+bb[i]*wz[i],qqw[i]=qqw[i-1]+qzh[wz[i]];
		qans[i]=qans[i-1]+ans[i];
	}
	axa=0,axb=0; int axc=0,aans=0;
	for(int i=n; i>=1; --i)
	{
		for(int j=hhead[i]; j!=0; j=nnxt[j]) axa=max(axa,ggta[j]),axb=max(axb,ggtb[j]),axc=max(axc,ggtc[j]);
		aans+=axc*n*n;
		int nowans=(axa+axb)*n-axa*axb;
		int el=axa+1,er=n,wzaxb;
		while(el<=er)
		{
			int mid=el+er>>1;
			if(ax[mid]>axb) wzaxb=mid,el=mid+1;
			else er=mid-1;
		}
		if(axb<ax[axa+1]) nowans+=qzh[wzaxb]-qzh[axa]-axb*(wzaxb-axa);
		el=axc+1,er=n; int wza=axc;
		while(el<=er)
		{
			int mid=el+er>>1;
			if(aa[mid]>axa) wza=mid,el=mid+1;
			else er=mid-1;
		}
		el=axc+1,er=n; int wzb=axc;
		while(el<=er)
		{
			int mid=el+er>>1;
			if(bb[mid]>axb) wzb=mid,el=mid+1;
			else er=mid-1;
		}
		aans+=qans[min(wza,wzb)]-qans[axc]+(n-max(wza,wzb))*nowans;
		if(wza<=wzb)
		{
			aans+=(qb[wzb]-qb[wza])*(n-axa)+axa*n*(wzb-wza);
			el=wza+1,er=wzb; int wwz=wzb+1;
			while(el<=er)
			{
				int mid=el+er>>1;
				if(bb[mid]<ax[axa+1]) wwz=mid,er=mid-1;
				else el=mid+1;
			}
			aans+=qqw[wzb]-qqw[wwz-1]-qzh[axa]*(wzb-wwz+1)
			-(qbw[wzb]-qbw[wwz-1])+(qb[wzb]-qb[wwz-1])*axa;
		}
		else
		{
			aans+=(qa[wza]-qa[wzb])*(n-axb)+axb*n*(wza-wzb);
			el=wzb+1,er=wza; int wwz=wza+1;
			while(el<=er)
			{
				int mid=el+er>>1;
				if(ax[aa[mid]+1]>axb) wwz=mid,er=mid-1;
				else el=mid+1;
			}
			aans+=qzh[wzaxb]*(wza-wwz+1)-(qqa[wza]-qqa[wwz-1])
			-axb*wzaxb*(wza-wwz+1)+axb*(qa[wza]-qa[wwz-1]);
		}
	}
	cout<<n*n*n*n-aans;
	return 0;
}
```

双指针的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned
int n,m;
int ax[500010],qzh[500010];
int tot=0,gta[500010],gtb[500010],nxt[500010],head[500010];
int ttot=0,ggta[500010],ggtb[500010],ggtc[500010],nnxt[500010],hhead[500010];
int aa[500010],bb[500010];
int wz[500010],ans[500010];
int qa[500010],qqa[500010],qb[500010],qbw[500010],qqw[500010],qans[500010];
signed main()
{
	cin>>n>>m;
	for(int i=1; i<=m; ++i)
	{
		int a,b,c,d; cin>>a>>b>>c>>d;
		ax[a]=max(ax[a],b);
		gta[++tot]=a,gtb[tot]=b,nxt[tot]=head[c],head[c]=tot;
		ggta[++ttot]=a,ggtb[ttot]=b,ggtc[ttot]=c,nnxt[ttot]=hhead[d],hhead[d]=ttot;
	}
	for(int i=n-1; i>=1; --i) ax[i]=max(ax[i],ax[i+1]);
	for(int i=1; i<=n; ++i) qzh[i]=qzh[i-1]+ax[i];
	int axa=0,axb=0,wwz=n;
	for(int i=n; i>=1; --i)
	{
		for(int j=head[i]; j!=0; j=nxt[j]) axa=max(axa,gta[j]),axb=max(axb,gtb[j]);
		aa[i]=axa,bb[i]=axb;
		ans[i]=(axa+axb)*n-axa*axb;
		while(wwz>=1 && ax[wwz]<=axb) --wwz;
		wz[i]=wwz;
		if(axb<ax[axa+1]) ans[i]+=qzh[wwz]-qzh[axa]-axb*(wwz-axa);
	}
	for(int i=1; i<=n; ++i)
	{
		qa[i]=qa[i-1]+aa[i],qqa[i]=qqa[i-1]+qzh[aa[i]];
		qb[i]=qb[i-1]+bb[i],qbw[i]=qbw[i-1]+bb[i]*wz[i],qqw[i]=qqw[i-1]+qzh[wz[i]];
		qans[i]=qans[i-1]+ans[i];
	}
	axa=0,axb=0; int axc=0,aans=0;
	int wzaxb=n,wwza=n,wwzb=n,wwz1=1,wwz2=1;
	for(int i=n; i>=1; --i)
	{
		for(int j=hhead[i]; j!=0; j=nnxt[j]) axa=max(axa,ggta[j]),axb=max(axb,ggtb[j]),axc=max(axc,ggtc[j]);
		aans+=axc*n*n;
		int nowans=(axa+axb)*n-axa*axb;
		while(wzaxb>=1 && ax[wzaxb]<=axb) --wzaxb;
		if(axb<ax[axa+1]) nowans+=qzh[wzaxb]-qzh[axa]-axb*(wzaxb-axa);
		while(wwza>=1 && aa[wwza]<=axa) --wwza;
		int wza=max(wwza,axc);
		while(wwzb>=1 && bb[wwzb]<=axb) --wwzb;
		int wzb=max(wwzb,axc);
		aans+=qans[min(wza,wzb)]-qans[axc]+(n-max(wza,wzb))*nowans;
		if(wza<=wzb)
		{
			aans+=(qb[wzb]-qb[wza])*(n-axa)+axa*n*(wzb-wza);
			while(wwz1<=n && bb[wwz1]>=ax[axa+1]) ++wwz1;
			int wwz=max(wza+1,min(wwz1,wzb+1));
			aans+=qqw[wzb]-qqw[wwz-1]-qzh[axa]*(wzb-wwz+1)
			-(qbw[wzb]-qbw[wwz-1])+(qb[wzb]-qb[wwz-1])*axa;
		}
		else
		{
			aans+=(qa[wza]-qa[wzb])*(n-axb)+axb*n*(wza-wzb);
			while(wwz2<=n && ax[aa[wwz2]+1]<=axb) ++wwz2;
			int wwz=max(wzb+1,min(wwz2,wza+1));
			aans+=qzh[wzaxb]*(wza-wwz+1)-(qqa[wza]-qqa[wwz-1])
			-axb*wzaxb*(wza-wwz+1)+axb*(qa[wza]-qa[wwz-1]);
		}
	}
	cout<<n*n*n*n-aans;
	return 0;
}
```

---

## 作者：xxxxxzy (赞：2)

还挺有意思。

原问题是一个四维的形式，不太能做，考虑降维。

我们枚举 $d$，发现随着 $d$ 的减小，限制会不断增强，具体来说，当 $d$ 取到一定的值时，$a,b,c$ 会有一个下界，这个下界我们记为 $sa_d,sb_d,sc_d$。

这样每个点 $(a,b,c)$，贡献为 $\min(sa_a,sb_b,sc_c)$。

这样问题就转化为了三维的带点权问题。

考虑继续降维。

我们继续枚举 $c$，发现随着 $c$ 的减小，$a,b$ 也会有一个越来越强的下界，接着我们发现，随着 $b$ 的减小，$a$ 还是会有一个下界。

具体来说，我们钦定 $a/b/c$ 为最小值，然后跑一遍，会发现这个最小值还是对另外两维的下界限制。

由于这种限制是不断增强的，所以枚举一维，拿指针扫一下另外两维，用个前缀和处理一下贡献就做完了。

时空复杂度 $O(n)$。

---

## 作者：L_zaa_L (赞：1)

模拟 shai 题，考场上做都不会做。

## 分析
- **Task 1**

假设一张卡牌只有两个属性，且要满足其中一个属性大于其他的所有卡牌。

我们可以直接使用双指针，我们从小到大枚举第一个属性，那么第二个属性能取到的值肯定是单调不降的。

- **Task 2**

考虑对于有三个属性且满足至少有两个大于其他卡片该怎么做。 我们可以记录 $lim_{a,b,A}$ 表示当 $a$ 属性的值为 $A$ 时，$b$ 至少为多少才使得没有一张 $Bob$ 的卡片的这两个属性同时大于这个卡片

然后我们可以枚举 $Alice$ 卡片的 $a$ 属性然后可以得到 $b$ 和 $c$ 属性至少为多少，然后我们现在的 $a,b,c$ 三个属性中 $ab,ac$ 这两对属性时不可能同时不合法的，所以我们最后只需要考虑 $bc$ 同时不合法的情况。

我们对于每个 $B$ 求可以得到一个 $C$ 范围，然后同时 $a$ 属性也对 $c$ 属性规定了一个范围（如下图）：  

![](https://picx.zhimg.com/80/v2-786adf02679f842d0ad4b247e01b3f90_720w.png)
($lim_{b,c,B}$ 不一定是一条直线，只不过肯定单调下降)

由于 $a$ 属性的值时固定为 $A$（我们枚举了的），所以 $lim_{a,c,A}$ 是固定的，然后我们两个限制都是是都要满足的，所以合法的 $C$ 是在两条直线之上的，然后我们就可以二分中间转折的那个点，然后前面一部分做前缀和可以得到，后面的是一个固定的值，然后随便做做就可以了。

- **Task 3**

回到原问题，我们现在先满足 $ad,bd,cd$ 不同时不合法的情况，对于每个 $A,B,C$ 我们都有一个对应的最小 $D$，我们发现 $D$ 的取值范围只和另外三个属性对它的限制的最大的那个，于是我们可以枚举一个位置 $x$，设剩下两个属性为 $y,z$，然后假设这个位置的值是 $X$，另外两个属性需要满足 $lim_{x,d,X}>lim_{{y,d,Y}},lim_{x,d,X}>lim_{{z,d,Z}}$，所以另外两个属性的满足条件的范围我们可以通过双指针来求，因为 $lim_{x,d,X}$ 是单调的，然后 $xy,xz$ 也有一个限制，所以最后我们得到了 $y,z$ 的两个属性的范围，然后最后只需要考虑 $yz$ 这个限制，我们发现与 Task 2 的二分部分是一样的，可以直接用。

## Code
```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast,unroll-loops")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
//#include <immintrin.h>
//#include <emmintrin.h>
#define ls(x) ((x)*2)
#define rs(x) ((x)*2+1)
#define pii pair<int,int>
#define fi first
#define se second
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=5e5+5,base=999983,Mod=998244353;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
int _base=1;
inline int mol(const int x){return x-Mod*((__int128)_base*x>>64);}
inline void Add(int &x,const int y){x=mol(x+y);}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
void print(int n){
    if(n<0){
        putchar('-');
        n*=-1;
    }
    if(n>9) print(n/10);
    putchar(n%10+'0');
}int n,m,w[N],mx[4][4][N],qzh[4][4][N];
signed main(){
	_base=((__int128)_base<<64)/Mod;
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	n=read(),m=read();
	For(i,1,m){
		For(j,0,3)w[j]=read();
		For(a,0,3)For(b,0,3)mx[a][b][w[a]]=max(mx[a][b][w[a]],w[b]);
	}Rof(i,n,0)For(a,0,3)For(b,0,3)mx[a][b][i]=max(mx[a][b][i],mx[a][b][i+1]);
	Rof(i,n,0)For(a,0,3)For(b,0,3)qzh[a][b][i]=qzh[a][b][i+1]+n-mx[a][b][i];
	unsigned int ans=0;
	For(a,0,2){
		int b=(a==0),c=3^a^b;
		int j=1,t=1;
		For(i,1,n){
			while(j<=n&&mx[b][3][j]+(b<a)>mx[a][3][i])j++;
			while(t<=n&&mx[c][3][t]+(c<a)>mx[a][3][i])t++;
			int Lb=max(j,mx[a][b][i]+1),Lc=max(t,mx[a][c][i]+1);
			int L=Lb,R=n,res=n+1;
			while(L<=R){
				int mid=(L+R)>>1;
				if(mx[b][c][mid]<Lc)res=mid,R=mid-1;
				else L=mid+1;
			}ans+=(n-mx[a][3][i])*(1ull*(n-res+1)*(n-Lc+1)-qzh[b][c][res]+qzh[b][c][Lb]);
		}
	} printf("%u",ans);
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}



```

---

## 作者：ZnPdCo (赞：0)

分享一个比较难写的做法。

::::info[三维弱化弱化版]{open}
考虑三维的部分分，虽然好像没有这个部分分呢？就是卡牌只有三个属性，只需要满足两个比较大就可以赢。先只用做到 $n\le 10^3$。

枚举 $C$ 属性的值 $c$，那么对于 $c_i\ge c$，则要求 $a_i<a,b_i<b$。那其实相当于当 $a>a_i,b>b_i$ 时，$C$ 属性可以取 $c$。

我们考虑预处理出 $sa_i$ 表示属性 $A$ 的值为 $i$ 时，$C$ 属性可以取多少种数。$sb$ 同理，容易预处理。你可能发现这两个数组具有单调性，但是在这个版本内没有什么用。

那么接下来我们规约成了二维的形式，只需要枚举 $a,b$ 了，但是对于一个合法的 $a,b$，它会产生 $\min(sa_a,sb_b)$ 的贡献。我们做到了 $O(n^2)$。
::::

::::info[三维弱化版]{open}
同样的还是只有三个属性，但是要求做到 $n\le 5\times 10^5$。这个做法和「弱化弱化版」没有关系。

「三个属性，至少有两个要大于其它的」相当于「三个属性，不能有两个小于等于其它的」。

我们可以把这个限制弄成类似于 2-SAT 那样的限制，也就是对于 $A\le a_i\Rarr B>b_i$、$A\le a_i\Rarr C>c_i$ 等等等等。

稍加思索可以发现，限制 $A\le a_i\Rarr B>b_i$ 与 $B\le b_i\Rarr A>a_i$ 是没有必要重复存在的，我们保留一条就好。

所以最后剩下三条限制：$A\le a_i\Rarr B>b_i$、$A\le a_i\Rarr C>c_i$、$B\le b_i\Rarr C>c_i$。

考虑求出 $lim_{A,B,a}$ 表示我们选择的卡牌 $A$ 属性为 $a$，那么 $B$ 属性至少要为多少？因为不能有两个小于等于其它的，那么我们的 $B$ 属性要大于「所有 $A$ 属性大于等于 $a$ 的卡牌的 $B$ 属性」，这个可以容易处理出来。

同理，计算出 $lim_{A,C,*}$、$lim_{B,C,*}$。

预处理完后考虑如何计算答案，先枚举 $A$ 的值 $a$，那么 $B$ 的值至少要为 $lim_{A,B,a}$，$C$ 的值至少要为 $lim_{A,C,a}$。

那么我们画一张图，其中横坐标为 $B$ 的值，纵坐标为 $C$ 的值：

![](https://cdn.luogu.com.cn/upload/image_hosting/88ktfrby.png)

这里你应当发现了，$lim_{B,C,*}$ 的值是递减的。

然后我们发现贡献是橙色那一块，可以分成前面 $lim_{B,C,*}\ge lim_{A,C,a}$ 和后面 $lim_{B,C,*}< lim_{A,C,a}$。

前者的贡献可以用 $lim$ 的前缀和计算，后者的贡献是一个矩阵，乘法简单计算即可。

中间的分界点可以用指针扫做到 $O(n)$，也可以二分带个 $\log$。
::::

::::info[原版]{open}
相信你已经想到把上面两个做法缝合起来了。

首先枚举 $D$ 属性的值 $d$，那么预处理出 $sa,sb,sc$，接下来就变成带权的「三维弱化版」了。

但是带权似乎不是很好处理？因为是要取 $\min$。

枚举 $a/b/c$ 为 $sa$ 最小的那个，然后我们发现，因为要求 $sb>sa$，所以 $B$ 的下限应当是还要和最小的满足 $sb_i>sa_a$ 的 $i$ 取 $\max$ 的，$C$ 同理。

然后你还需要处理有相等的情况，那太麻烦了。考虑合并同类项，我们只需要考虑：

- $sa\le sb,sa<sc$
- $sb\le sc,sb<sa$
- $sc\le sa,sc<sb$
- $sa=sb=sc$

四种情况。

前面三种是好处理的，第四种的 $B$ 和 $C$ 还有取值的上界，需要处理一下。
::::

::::success[参考代码]
```cpp
// 参考 https://www.luogu.com.cn/article/kjt9ubyn
#include <bits/stdc++.h>
using namespace std;
namespace {
constexpr int N = 5e5 + 10;
using uint = unsigned int;
struct card { int a[4]; } p[N];
int n, m, pos, mx[3], s[3][N], l[3][3][N];
uint ans, ls[3][3][N];
void solve(int i, int j, int k, int mny, int mnz, int mxy, int mxz, uint coef) {
    if (mny > mxy || mnz > mxz) return;
    // 二分一个最小的点，使得 l[j][k][x] <= mxz
    int L = mny, R = mxy, x = mxy + 1;
    while (L <= R) {
        int mid = (L + R) >> 1;
        if (l[j][k][mid] <= mxz) {
            x = mid;
            R = mid - 1;
        } else {
            L = mid + 1;
        }
    }
    // 这个点前面全部不贡献
    mny = x;

    // 二分一个最大的点，使得 l[j][k][x] >= mnz
    L = mny, R = mxy, x = mny - 1;
    while (L <= R) {
        int mid = (L + R) >> 1;
        if (l[j][k][mid] >= mnz) {
            x = mid;
            L = mid + 1;
        } else {
            R = mid - 1;
        }
    }
    // 这个点后面的全部贡献
    ans += coef * (mxy - x) * (mxz - mnz + 1);
    mxy = x;

    // 中间是一个前缀和,lbc的前缀和
    ans += coef * (((uint)(mxy - mny + 1) * (mxz + 1)) - (ls[j][k][mxy] - ls[j][k][mny - 1]));
}
void entry() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> p[i].a[0] >> p[i].a[1] >> p[i].a[2] >> p[i].a[3];

    sort(p + 1, p + 1 + m, [](const auto &x, const auto &y) { return x.a[3] > y.a[3]; });
    pos = 1;
    for (int x = n; x >= 1; x--) {
        while (pos <= m && p[pos].a[3] == x) {
            for (int j = 0; j < 3; j++) mx[j] = max(mx[j], p[pos].a[j]);
            pos++;
        }
        for (int j = 0; j < 3; j++) s[j][mx[j] + 1]++;
    }
    for (int i = 1; i <= n; i++) for (int j = 0; j < 3; j++) s[j][i] += s[j][i - 1];

    for (int i = 0; i < 3; i++) {
        sort(p + 1, p + 1 + m, [&](const auto &x, const auto &y) { return x.a[i] > y.a[i]; });
        pos = 1;
        for (int j = 0; j < 3; j++) l[i][j][n + 1] = 1;
        for (int x = n; x >= 1; x--) {
            for (int j = 0; j < 3; j++) l[i][j][x] = l[i][j][x + 1];
            while (pos <= m && p[pos].a[i] == x) {
                for (int j = 0; j < 3; j++) l[i][j][x] = max(l[i][j][x], p[pos].a[j] + 1);
                pos++;
            }
        }
    }

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            for (int x = 1; x <= n; x++) ls[i][j][x] = l[i][j][x] + ls[i][j][x - 1];
        }
    }

    for (int i = 0; i < 3; i++) {
        int j = (i + 1) % 3, k = (i + 2) % 3;
        // sa <= sb && sa < sc
        for (int x = 1; x <= n; x++) {
            int mny = max<int>(lower_bound(s[j] + 1, s[j] + 1 + n, s[i][x]) - s[j], l[i][j][x]);
            int mxy = n;
            int mnz = max<int>(upper_bound(s[k] + 1, s[k] + 1 + n, s[i][x]) - s[k], l[i][k][x]);
            int mxz = n;
            solve(i, j, k, mny, mnz, mxy, mxz, s[i][x]);
        }
    }
    
    // sa = sb = sc
    for (int x = 1; x <= n; x++) {
        int mny = max<int>(lower_bound(s[1] + 1, s[1] + 1 + n, s[0][x]) - s[1], l[0][1][x]);
        int mxy = upper_bound(s[1] + 1, s[1] + 1 + n, s[0][x]) - 1 - s[1];
        int mnz = max<int>(lower_bound(s[2] + 1, s[2] + 1 + n, s[0][x]) - s[2], l[0][2][x]);
        int mxz = upper_bound(s[2] + 1, s[2] + 1 + n, s[0][x]) - 1 - s[2];
        solve(0, 1, 2, mny, mnz, mxy, mxz, s[0][x]);
    }

    cout << ans << '\n';
}
}
int main() { entry(); }
```
::::

---


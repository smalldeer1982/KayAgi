# [NOI2012] 魔幻棋盘

## 题目描述

将要读二年级的小 Q 买了一款新型益智玩具——魔幻棋盘，它是一个 $N$ 行 $M$ 列的网格棋盘，每个格子中均有一个正整数。棋盘守护者在棋盘的第 $X$ 行第 $Y$ 列（行与列均从 $1$ 开始编号）并且始终不会移动。棋盘守护者会进行两种操作：

* （a）询问：他会以自己所在位置为基础，向四周随机扩展出一块大小不定的矩形区域，向你询问这一区域内所有数的最大公约数是多少。
* （b）修改：他会随意挑选棋盘上的一块矩形区域，将这一区域内的所有数同时加上一个给定的整数。

游戏说明书上附有这样一句话“聪明的小朋友，当你连续答对 $19930324$ 次询问后会得到一个惊喜噢！”。小 Q 十分想得到这个惊喜，于是每天都在玩这个玩具。但由于他粗心大意，经常算错数，难以达到这个目标。于是他来向你寻求帮助，希望你帮他写一个程序来回答棋盘守护者的询问，并保证 $100\%$ 的正确率。

为了简化问题，你的程序只需要完成棋盘守护者的 $T$ 次操作，并且问题保证任何时刻棋盘上的数字均为不超过 $2^{62} - 1$ 的正整数。


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2594.png) 

对于第一、第四次操作（查询操作）后，加粗部分表示查询区域。

对于第二、第三次操作（修改操作）后，加粗部分表示修改区域。

测试数据分为 A、B、C 三类：

A 类数据占 $20\%$，满足 $N \leq 100$，$M \leq 100$，$T \leq 2\times 10^4$。

B 类数据占 $40\%$，满足 $N = 1$，$M \leq 5\times 10^5$，$T \leq 10^5$。

C 类数据占 $40\%$，满足 $N \times M \leq 5\times 10^5$，$T \leq 10^5$。

在每类数据中，均有 $50\%$ 的数据满足每次修改操作仅含一个格子（即 $x_1 = x_2$，$y_1 = y_2$）。

输入数据保证满足题目描述中的所有性质。


## 样例 #1

### 输入

```
2 2
1 1
4
6 12
18 24
0 0 0 1 0
1 1 1 1 2 6
1 2 1 2 2 6
0 0 0 1 1```

### 输出

```
6
6```

# 题解

## 作者：lhm_ (赞：25)

先考虑只有一维的情况，要求支持区间加和求区间 $\gcd$，根据 $\gcd$ 的性质，发现：

$$
	\gcd(a_1,a_2,a_3,\ldots a_n)=\gcd(a_i,a_2-a_1,a_3-a_2,\ldots a_n-a_{n-1})
$$

其中 $a_i$ 为原序列 $a$ 中的任意一个元素，其与序列 $a$ 的差分序列的 $\gcd$ 即为原序列的 $\gcd$。根据该性质，对于一维的情况，就可以通过线段树单点修改维护差分序列，区间查询 $\gcd$ 来实现了。对于 $a_i$，根据修改维护其当前值即可。

然后考虑二维的情况，比如对于这样的一个 $4 \times 4$ 的矩形：

$$
\begin{aligned} 
	a_{1,1}\quad a_{1,2}\quad a_{1,3}\quad a_{1,4} \\
	a_{2,1}\quad a_{2,2}\quad a_{2,3}\quad a_{2,4} \\
	a_{3,1}\quad a_{3,2}\quad a_{3,3}\quad a_{3,4} \\
	a_{4,1}\quad a_{4,2}\quad a_{4,3}\quad a_{4,4}   
\end{aligned}
$$

设棋盘守护者的位置为 $(x,y)$，先对每一行进行差分，得：

$$
\begin{aligned} 
	a_{1,y}\quad a_{1,2}-a_{1,1}\quad a_{1,3}-a_{1,2}\quad a_{1,4}-a_{1,3} \\
	a_{2,y}\quad a_{2,2}-a_{2,1}\quad a_{2,3}-a_{2,2}\quad a_{2,4}-a_{2,3} \\
	a_{3,y}\quad a_{3,2}-a_{3,1}\quad a_{3,3}-a_{3,2}\quad a_{3,4}-a_{3,3} \\
	a_{4,y}\quad a_{4,2}-a_{4,1}\quad a_{4,3}-a_{4,2}\quad a_{4,4}-a_{4,3}   
\end{aligned}
$$

对每一行来维护差分序列，根据每一行的 $\gcd$，就能求得整个矩形的 $\gcd$。发现这样实现复杂度依然无法接受，于是对每一列也进行差分，也就是进行二维差分，得：

$$
\begin{aligned} 
	&a_{x,y}\qquad\qquad\qquad\quad a_{x,2}-a_{x,1}\qquad\qquad\qquad\quad a_{x,3}-a_{x,2}\qquad\qquad\qquad\quad a_{x,4}-a_{x,3} \\\\
	&a_{2,y}-a_{1,y}\qquad a_{2,2}-a_{2,1}-a_{1,2}+a_{1,1}\qquad a_{2,3}-a_{2,2}-a_{1,3}+a_{1,2}\qquad a_{2,4}-a_{2,3}-a_{1,4}+a_{1,3} \\\\
	&a_{3,y}-a_{2,y}\qquad a_{3,2}-a_{3,1}-a_{2,2}+a_{2,1}\qquad a_{3,3}-a_{3,2}-a_{2,3}+a_{2,2}\qquad a_{3,4}-a_{3,3}-a_{2,4}+a_{2,3} \\\\
	&a_{4,y}-a_{3,y}\qquad a_{4,2}-a_{4,1}-a_{3,2}+a_{3,1}\qquad a_{4,3}-a_{4,2}-a_{3,3}+a_{3,2}\qquad a_{4,4}-a_{4,3}-a_{3,4}+a_{3,3}  
\end{aligned}
$$

发现二维差分后的这个矩形的 $\gcd$ 即为原矩形的 $\gcd$。然后考虑维护，对于第一行和第一列，去掉位置 $(1,1)$ 的 $a_{x,y}$ 后剩下的序列，其为一维上的问题，用两个一维线段树维护即可。对于去掉第一行和第一列的剩下的矩形，用二维线段树维护即可。两者都是只用支持单点修改和区间查询。对于 $a_{x,y}$，根据修改维护其当前值即可。

二维线段树可以用树套树或者四分树来实现，因为树套树的空间不好处理，并且题目中也说明了查询是随机的，所以我这里用四分树来实现二维线段树了。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 2000010
#define maxm 32000010
#define a(i,j) a[(i-1)*m+j]
#define b(i,j) b[(i-1)*m+j]
#define ls (cur<<1)
#define rs (cur<<1|1)
#define mid ((l+r)>>1)
#define midx ((u+d)>>1)
#define midy ((l+r)>>1)
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,sx,sy,q,root,rt=1,tree_cnt;
int uls[maxm],urs[maxm],dls[maxm],drs[maxm];
ll w;
ll a[maxn],b[maxn],val[maxm];
ll gcd(ll a,ll b)
{
    return b?gcd(b,a%b):abs(a);
}
void build(int u,int d,int l,int r,int &cur)
{
    if(u>d||l>r) return;
    if(!cur) cur=++tree_cnt;
    if(u==d&&l==r)
    {
        val[cur]=b(u,l);
        return;
    }
    build(u,midx,l,midy,uls[cur]),build(u,midx,midy+1,r,urs[cur]);
    build(midx+1,d,l,midy,dls[cur]),build(midx+1,d,midy+1,r,drs[cur]);
    val[cur]=gcd(gcd(val[uls[cur]],val[urs[cur]]),gcd(val[dls[cur]],val[drs[cur]]));
}
void modify(int u,int d,int l,int r,int x,int y,ll v,int cur)
{
    if(l==r&&u==d)
    {
        val[cur]+=v;
        return;
    }
    if(x<=midx)
    {
        if(y<=midy) modify(u,midx,l,midy,x,y,v,uls[cur]);
        else modify(u,midx,mid+1,r,x,y,v,urs[cur]);
    }
    else
    {
        if(y<=midy) modify(midx+1,d,l,midy,x,y,v,dls[cur]);
        else modify(midx+1,d,midy+1,r,x,y,v,drs[cur]);
    }
    val[cur]=gcd(gcd(val[uls[cur]],val[urs[cur]]),gcd(val[dls[cur]],val[drs[cur]]));
}
ll query(int U,int D,int L,int R,int u,int d,int l,int r,int cur)
{
    if(U>D||L>R) return 0;
    if(U<=u&&D>=d&&L<=l&&R>=r) return val[cur];
    ll v=0;
    if(U<=midx)
    {
        if(L<=midy) v=gcd(v,query(U,D,L,R,u,midx,l,midy,uls[cur]));
        if(R>midy) v=gcd(v,query(U,D,L,R,u,midx,midy+1,r,urs[cur]));
    }
    if(D>midx)
    {
        if(L<=midy) v=gcd(v,query(U,D,L,R,midx+1,d,l,midy,dls[cur]));
        if(R>midy) v=gcd(v,query(U,D,L,R,midx+1,d,midy+1,r,drs[cur]));
    }
    return v;
}
struct Segment_Tree
{
    ll a[maxn],val[maxn];
    void build(int l,int r,int cur)
    {
        if(l==r)
        {
            val[cur]=a[l];
            return;
        }
        build(l,mid,ls),build(mid+1,r,rs);
        val[cur]=gcd(val[ls],val[rs]);
    }
    void modify(int l,int r,int pos,ll v,int cur)
    {
        if(l==r)
        {
            val[cur]+=v;
            return;
        }
        if(pos<=mid) modify(l,mid,pos,v,ls);
        else modify(mid+1,r,pos,v,rs);
        val[cur]=gcd(val[ls],val[rs]);
    }
    ll query(int L,int R,int l,int r,int cur)
    {
        if(L>R) return 0;
        if(L<=l&&R>=r) return val[cur];
        ll v=0;
        if(L<=mid) v=gcd(v,query(L,R,l,mid,ls));
        if(R>mid) v=gcd(v,query(L,R,mid+1,r,rs));
        return v;
    }
}T1,T2;
int main()
{
    read(n),read(m),read(sx),read(sy),read(q);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            read(a(i,j));
    for(int i=1;i<n;++i)
        for(int j=1;j<m;++j)
            b(i,j)=a(i+1,j+1)-a(i,j+1)-a(i+1,j)+a(i,j);
    for(int i=1;i<n;++i) T1.a[i]=a(i+1,sy)-a(i,sy);
    for(int i=1;i<m;++i) T2.a[i]=a(sx,i+1)-a(sx,i);
    w=a(sx,sy),build(0,n,0,m,root),T1.build(0,n,root),T2.build(0,m,root);
    while(q--)
    {
        int u,d,l,r,opt;
        ll v;
        read(opt),read(u),read(l),read(d),read(r);
        if(!opt)
        {
            u=sx-u,l=sy-l,d=sx+d,r=sy+r;
            v=gcd(w,query(u,d-1,l,r-1,0,n,0,m,root));
            v=gcd(v,gcd(T1.query(u,d-1,0,n,rt),T2.query(l,r-1,0,m,rt)));
            printf("%lld\n",v);
        }
        else
        {
            read(v);
            if(sx>=u&&sx<=d&&sy>=l&&sy<=r) w+=v;
            if(sy>=l&&sy<=r) T1.modify(0,n,u-1,v,rt),T1.modify(0,n,d,-v,rt);
            if(sx>=u&&sx<=d) T2.modify(0,m,l-1,v,rt),T2.modify(0,m,r,-v,rt);
            modify(0,n,0,m,u-1,l-1,v,root),modify(0,n,0,m,d,r,v,root);
            modify(0,n,0,m,u-1,r,-v,root),modify(0,n,0,m,d,l-1,-v,root);
        }
    }
    return 0;
}
```

---

## 作者：devout (赞：15)

首先考虑一维的情况怎么做，我们发现用线段树维护无法区间修改。

观察发现 $\gcd(x,y)=\gcd(x,y-x)$，所以我们可以用线段树维护差分，然后单点修改，区间查询。

二维呢？

二维线段树维护二阶差分就好啦！

我们发现因为他每次都是从一个点往外扩展的，所以我们可以以 $(x,y)$ 为中心向四个方向差分。

修改的时候，我们可以大力分九种情况讨论。

- 修改矩形包含 $(X,Y)$
- 修改矩形包含 $x=X,y=Y$ 中的一条（四种）
- 修改矩形全部位于 $(X,Y)$ 的一个方向（左上，右上，左下，右下）

通过二阶差分我们同样可以实现单点修改

然后就是愉快的coding时间啦！

[code](https://www.luogu.com.cn/paste/rtyanhx6)

---

## 作者：Xy_top (赞：10)

### 简化题意

二维矩形，区间加，区间求 $\gcd$。
### 分析
先来考虑弱化的一维版本，显然可以用线段树维护。可是就无法下传标记了，此时我们考虑把区间操作转换为单点，想到了差分。发现 $\gcd(a,b)=\gcd(a-b,b)$，所以维护差分数组是对的，边界再处理一下即可。
### 扩展
现在变成了二维，如果我们简简单单的维护 $n$ 行差分数组，$n$ 颗线段树，修改时一行一行修改就会发现时间复杂度会不行。

这个时候我们想一想，两个数相乘等于 $n$，必定有一个数大于等于 $\sqrt{n}$，另一个数小于等于 $\sqrt{n}$，所以我们挑短的维护就行。一次操作时间为 $O(\min(n, m)\times \log_{\max(n, m)})$，总时间复杂度再乘上一个 $T$ 就可以了，卡卡常完全过得去。

---

## 作者：luqyou (赞：6)

# 前置技能
本题是对于一个矩阵求gcd，也就是说是一个二维的问题，那处理一维的问题自然就是前置技能了！

于是我们可以发现：

$\boxed{\gcd(a1,a2,\dots,an)=\gcd(a1,a2-a1,\dots,an-an-1)}$

有了这个结论我们就可以对于一维的问题用线段树解决了。

# 做法

## 错解
有了上面这个结论，我们很容易想到把查询的矩形分成左上角一个点，左边一列，上面一行，右下一块四个部分来解决问题。

开始我也是这么做，然后就把4k+的代码删得只剩线段树了。该做法的问题就在于，如果你修改了一个矩阵那你也需要将这个矩阵拆分成四个部分进行修改。

但是你修改左边一列的时候就会发现，这一列中每个位置都对应一行的一个位置，也就是说，如果修改了一列，对应的每行都需修改，这样的复杂度显然是不对的！

看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3q1d7tvx.png)

实际上修改时你并**无法修改到蓝色**这一格，因为修改的时候蓝色这一格是作为一整个方块进行修改的，则询问以其为起始对应行列都会出问题。

出题人必然也知道上面这个看似正确的错解，那么难道这是一道错题？

显然不是。

对于询问，我们发现一个特点，所有询问都是以 $(x,y)$ 为中心的！

那么我们以 $(x,y)$ 为坐标原点，建立坐标系切割矩形，我们很容易发现，询问的每个矩形的每个都要么在原点，要么在坐标轴上，要么在四个象限

我们只需要一棵二维线段树记录一下一个矩阵做完差分后的gcd就行了。~~要不就像我一样\*\*地开了3棵线段树，四个象限用二维线段树，坐标轴用一维线段树~~

具体怎么差分呢，在坐标轴上的大家一定都会，我就举一个在第一象限的例子好了

对于第一象限一个点，有：

$\boxed{c[i][j]=a[i][j]-a[i+1][j]-a[i][j+1]+a[i+1][j+1]}$

($c$ 表示差分后的值，$a$ 表示原矩阵)

为什么这样做？实际上我们要做的事就是**减少修改次数**，我们发现上面那个差分刚好加两个值，减两个值，而且这四个数刚好相邻构成矩阵，且这个矩阵刚刚刚刚好是向着原点的啊，真的是刚刚刚刚好啊，不选它选谁啊

对于修改操作，我的程序实现还是比较麻烦的，修改也是分为修改坐标轴和修改象限.

对于每个象限做的操作大概长这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/j2p8ha1z.png)

既然差分已经做出来了，那修改也不是难事。还有一些边界问题需要处理一下。

但还有一种特殊情况：当矩形一条边恰好贴在坐标轴上时，例如贴在x轴上，矩阵向y的正半轴延伸，此时矩阵并不包括y的负半轴，但是负半轴的第一个点与原点做差分的时候，差分的结果仍然会 $-k$，当然，边贴在坐标轴上时，象限中的点也会受到一些影响，这个反正乱搞一下就好了。

# $code$

```
#include<bits/stdc++.h>  
using namespace std;      
         
const int maxn = 5E5 + 10;     
const int dx[4][4] = {{0,0,1,1},{0,0,1,1},{0,0,-1,-1},{0,0,-1,-1}};    
const int dy[4][4] = {{0,1,0,1},{0,-1,0,-1},{0,1,0,1},{0,-1,0,-1}};     
typedef long long LL;      
         
LL c[maxn*25];      
int n,m,t,x,y,X1,X2,Y1,Y2,cnt = 0,tt,lc[maxn*20],rc[maxn*20];   
int jx[10],jy[10],cur;     
         
vector <LL> v[maxn];    
vector <int> bo[maxn];
         
LL gcd(LL a,LL b) {return b?gcd(b,a%b):a;}      
     
LL ABS(LL x) {return x>0?x:x*-1;}  
     
void PRE(int l,int r,int o)      
{      
    cnt = max(cnt,o);      
    if (l == r) return;      
    int mid = (l+r) >> 1;      
    PRE(l,mid,2*o); PRE(mid+1,r,2*o+1);      
}  
         
LL que(int o,int l,int r,int ql,int qr)    
{    
    if (ql <= l && r <= qr) return ABS(c[o]);    
    LL ret = 0;    
    int mid = (l+r) >> 1;    
    if (ql <= mid) ret = gcd(ret,que(lc[o],l,mid,ql,qr));    
    if (qr > mid) ret = gcd(ret,que(rc[o],mid+1,r,ql,qr));    
    return ret;    
}  
       
LL Modi(int l,int r,int o,int pos,LL va,int typ)      
{      
    if (l == r) {if (typ) c[o] = va; else c[o] += va; return ABS(c[o]);}      
    int mid = (l+r) >> 1; LL ret;  
    if (pos <= mid) {      
        if (!lc[o]) lc[o] = ++cnt;      
        ret = Modi(l,mid,lc[o],pos,va,typ);      
    }      
    else {      
        if (!rc[o]) rc[o] = ++cnt;      
        ret = Modi(mid+1,r,rc[o],pos,va,typ);      
    }      
    c[o] = gcd(ABS(c[lc[o]]),ABS(c[rc[o]]));  
    return ret;  
}      
         
LL Modify(int l,int r,int o,int pn,int pm,LL va)      
{      
    if (!pn || !pm || pn > n || pm > m) return -1;    
    if (l == r) return Modi(1,m,o,pm,va,0);      
    int mid = (l+r) >> 1;      
    LL ret1,ret2;  
    if (pn <= mid) {  
        ret1 = Modify(l,mid,2*o,pn,pm,va);  
        ret2 = que(2*o+1,1,m,pm,pm);   
    }     
    else {  
        ret1 = Modify(mid+1,r,2*o+1,pn,pm,va);  
        ret2 = que(2*o,1,m,pm,pm);      
    }  
    return Modi(1,m,o,pm,gcd(ret1,ret2),1);  
}      
         
LL getLL()    
{    
    LL ret = 0;  LL xx = 1;  
    char ch = getchar();    
    while (ch < '0' || ch > '9') {  
        if (ch == '-') xx = -1;  
        ch = getchar();   
    }  
    while ('0' <= ch && ch <= '9') ret = ret*10 + 1LL*(ch-'0'),ch = getchar();    
    return ret*xx;    
}    
         
void Judge(int px,int py,LL c)    
{    
    if (!px || !py || px > n || py > m || px == x || py == y) return;   
	if (bo[px][py] == tt) return; 
    int po;    
    if (px < x && py < y) po = 0;    
    else if (px < x && py > y) po = 1;    
    else if (px > x && py < y) po = 2;    
    else po = 3;    
    LL tot = 0;    
    for (int l = 0; l < 4; l++) {    
        int xx = px + dx[po][l];    
        int yy = py + dy[po][l];    
        LL t;    
        if ((!dx[po][l] || !dy[po][l]) && dx[po][l] != dy[po][l]) t = -1;  else t = 1;    
        if (X1 <= xx && xx <= X2 && Y1 <= yy && yy <= Y2) tot += c*t;    
    }    
    if (tot != 0) Modify(1,n,1,px,py,tot),bo[px][py] = tt,jx[cur] = px,jy[cur++] = py;    
}     
         
LL query(int o,int l,int r,int nl,int nr,int ml,int mr)    
{    
    if (nl <= l && r <= nr) return que(o,1,m,ml,mr);    
    LL ret = 0;    
    int mid = (l+r) >> 1;    
    if (nl <= mid) ret = gcd(ret,query(2*o,l,mid,nl,nr,ml,mr));    
    if (nr > mid) ret = gcd(ret,query(2*o+1,mid+1,r,nl,nr,ml,mr));    
    return ret;    
}      
       
int main()      
{      
    #ifdef YZY      
        //freopen("chess1.in","r",stdin);      
        //freopen("test.txt","w",stdout);  
    #endif      
             
    cin >> n >> m >> x >> y >> t; PRE(1,n,1);      
    for (int i = 1; i <= n; i++) {    
        v[i].push_back(0);    bo[i].push_back(0);
        for (int j = 1; j <= m; j++) {    
            LL x; x = getLL();    
            v[i].push_back(x);    bo[i].push_back(0);
        }    
    }    
           
    for (int i = 1; i <= n; i++)    
        for (int j = 1; j <= m; j++) {    
            if (i == x && j == y) Modify(1,n,1,i,j,v[i][j]);    
            else if (i == x && j < y) Modify(1,n,1,i,j,v[i][j]-v[i][j+1]);    
            else if (i == x && j > y) Modify(1,n,1,i,j,v[i][j]-v[i][j-1]);    
            else if (j == y && i < x) Modify(1,n,1,i,j,v[i][j]-v[i+1][j]);    
            else if (j == y && i > x) Modify(1,n,1,i,j,v[i][j]-v[i-1][j]);    
            else if (i < x && j < y) Modify(1,n,1,i,j,v[i][j]-v[i+1][j]-v[i][j+1]+v[i+1][j+1]);    
            else if (i < x && j > y) Modify(1,n,1,i,j,v[i][j]-v[i+1][j]-v[i][j-1]+v[i+1][j-1]);    
            else if (i > x && j < y) Modify(1,n,1,i,j,v[i][j]-v[i-1][j]-v[i][j+1]+v[i-1][j+1]);    
            else Modify(1,n,1,i,j,v[i][j]-v[i][j-1]-v[i-1][j]+v[i-1][j-1]);    
        }  
            
    while(t--) {      
        int typ = getLL();    
        if (typ == 0) {    
            X1 = getLL(); Y1 = getLL();     
            X2 = getLL(); Y2 = getLL();    
            X1 = x - X1; X2 = x + X2;    
            Y1 = y - Y1; Y2 = y + Y2;    
            printf("%lld\n",query(1,1,n,X1,X2,Y1,Y2));    
        }    
        else {    
        	++tt;
            X1 = getLL(); Y1 = getLL();     
            X2 = getLL(); Y2 = getLL();    
            LL c; c = getLL();  cur = 0;  
            Judge(X1-1,Y1-1,c); Judge(X1,Y1-1,c); Judge(X1,Y1,c); Judge(X1-1,Y1,c);    
            Judge(X1-1,Y2,c); Judge(X1-1,Y2+1,c); Judge(X1,Y2+1,c); Judge(X1,Y2,c);    
            Judge(X2,Y1,c);  Judge(X2+1,Y1,c); Judge(X2+1,Y1-1,c); Judge(X2,Y1-1,c);   
            Judge(X2,Y2,c); Judge(X2,Y2+1,c); Judge(X2+1,Y2,c); Judge(X2+1,Y2+1,c);    
            if (X1 <= x && x <= X2 && Y1 <= y && y <= Y2) Modify(1,n,1,x,y,c);    
            if (X1 <= x && x <= X2) {    
                if (Y1 <= y && y <= Y2) Modify(1,n,1,x,Y2+1,-c),Modify(1,n,1,x,Y1-1,-c);    
                else if (y > Y2) Modify(1,n,1,x,Y2,c),Modify(1,n,1,x,Y1-1,-c);    
                else Modify(1,n,1,x,Y1,c),Modify(1,n,1,x,Y2+1,-c);    
            }    
            if (Y1 <= y && y <= Y2) {    
                if (X1 <= x && x <= X2) Modify(1,n,1,X1-1,y,-c),Modify(1,n,1,X2+1,y,-c);    
                else if (x > X2) Modify(1,n,1,X2,y,c),Modify(1,n,1,X1-1,y,-c);    
                else Modify(1,n,1,X1,y,c),Modify(1,n,1,X2+1,y,-c);    
            }    
        }    
    }      
    return 0;      
}     
```


 

---

## 作者：FFTotoro (赞：6)

考虑一种很暴力的做法。下文中令 $S=NM$，$V=2^{62}-1$（值域）。

为方便叙述，**不妨设 $N\le M$。**

考虑 $N=1$ 时怎么做：一种情况是直接维护原来的操作（区间加 & 区间查询 $\gcd$）——但是这样似乎很难维护，那么是否能把区间加转换为单点加呢？

注意到 $\gcd$ 具有良好的性质，即 $\gcd(a,b)=\gcd(a,b-a)$。所以对于一个序列 $a$ 进行区间查询 $[l,r]$ 时，有：

$$\gcd\limits_{i=l}^r a_i=\gcd\left(a_l,\gcd\limits_{i=l+1}^r a_i-a_{i-1}\right)$$

于是只需要维护 $a$ 的差分序列：区间加变成了单点加，区间查询时，求 $a_l$ 的值就是查询前缀和，求 $\gcd\limits_{i=l+1}^r a_i-a_{i-1}$ 的值就是查询区间 $\gcd$。

由于 $N\le M$ 且 $NM=S$，所以 $N\le\sqrt{S}$：这启发我们对于每一行开一棵线段树，操作时直接对于每棵线段树修改，查询时对于每棵线段树求出答案后合并即可。

设有 $T$ 次询问，时间复杂度为 $O(NM+TN\log M\log V)$，即 $O(S+T\sqrt{S}\log S\log V)$，其中 $\log V$ 是求 $\gcd$ 的时间复杂度（代码实现中使用的是 `std::gcd`，需要使用 C++17 及以上的标准编译）。

上面的做法看起来在 $S\le 5\times 10^5$ 的数据范围下过不去，但是我们可以使用非递归线段树（又称 zkw 线段树），这样就大大了减小常数；实测可以在 $3.5\mathrm{s}$ 内通过。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
class segtree{
  private:
    int k,m;
    vector<ll> s,g;
    inline void pushup(int u){
      s[u]=s[u<<1]+s[u<<1|1];
      g[u]=gcd(g[u<<1],g[u<<1|1]);
    }
  public:
    void init(vector<ll> a){
      k=__lg(a.size())+(__builtin_popcount(a.size())>1);
      s.resize((m=1<<k)<<1),g=s;
      for(int i=0;i<a.size();i++)
        s[i+m]=g[i+m]=a[i];
      for(int i=m-1;i;i--)
        pushup(i);
    }
    inline void update(int p,ll d){
      s[p+=m]+=d,g[p]+=d;
      for(int i=1;i<=k;i++)
        pushup(p>>i);
    } // 单点修改
    inline ll query_sum(int l,int r){
      ll c=0; l+=m,r+=m;
      while(l<r){
        if(l&1)c+=s[l++];
        if(r&1)c+=s[--r];
        l>>=1,r>>=1;
      }
      return c;
    } // 区间求和
    inline ll query_gcd(int l,int r){
      ll w=0; l+=m,r+=m;
      while(l<r){
        if(l&1)w=gcd(w,g[l++]);
        if(r&1)w=gcd(w,g[--r]);
        l>>=1,r>>=1;
      } // 区间求 gcd
      return w;
    }
}; // 非递归线段树
int main(){
  ios::sync_with_stdio(false);
  int n,m,x,y,q; cin>>n>>m>>x>>y>>q,x--,y--;
  bool f=n>m; if(f)swap(n,m),swap(x,y); // 处理 n>m 的情况
  vector a(n,vector<ll>(m));
  if(f){
    for(int i=0;i<m;i++)
      for(int j=0;j<n;j++)
        cin>>a[j][i];
  }
  else for(auto &i:a)for(auto &j:i)cin>>j;
  vector<segtree> t(n);
  for(int i=0;i<n;i++){
    vector<ll> d(m);
    adjacent_difference(a[i].begin(),a[i].end(),d.begin());
    t[i].init(d);
  } // 预处理差分序列
  while(q--){
    int op; cin>>op;
    if(op){
      int xa,ya,xb,yb; ll d; cin>>xa>>ya>>xb>>yb>>d,xa--,ya--,xb--,yb--;
      if(f)swap(xa,ya),swap(xb,yb);
      for(int i=xa;i<=xb;i++)
        if(t[i].update(ya,d);yb+1<m)t[i].update(yb+1,-d);
    } // 修改
    else{
      int xa,ya,xb,yb; ll c=0; cin>>xa>>ya>>xb>>yb;
      if(f)swap(xa,ya),swap(xb,yb);
      for(int i=x-xa;i<=x+xb;i++)
        c=gcd(c,gcd(t[i].query_gcd(y-ya+1,y+yb+1),t[i].query_sum(0,y-ya+1)));
      cout<<c<<'\n';
    } // 查询
  }
  return 0;
}
```

---

## 作者：WaTleZero_pt (赞：6)

~~作为一个初一蒟蒻居然敢写黑题题解，真是太勇了~~

## 题目分析

首先，我们从 $N \times M \leq 5 \times 10^{5},T \leq 10^{5}$ 不难看出，这就是一个二维线段树的题目。这里我选用的是四分树来实现二维线段树。

本题最烦的一点是，我们不可能使用线段树直接实现区间修改加和区间查询 $\gcd$。因为 $\gcd$ 的性质 $\gcd(a,b)=\gcd(a,b-a)$，所以本题我们可以借助二维差分来帮助我们实现这个操作。

## 初始化

那我们应该如何初始化这个二维线段树呢？本题查询时的一个特性为我们提供了帮助，那就是查询时一定包含坐标 $(X,Y)$ 的位置。所以我们可以以 $(X,Y)$ 为二维差分数组的中心，然后依次对左上角、右上角、左下角和右下角的区域做一遍二维差分数组即可。如图（1）所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/r79xqsd4.png) 

$$\texttt{图（1）}$$

## 修改

现在最棘手的问题就是线段树的修改了。通过差分我们已经把线段树的区间修改改为单点修改，但问题是我们的二维差分数组是以坐标 $(X,Y)$ 为中心进行差分的，所以我们在修改时要进行分类讨论。我们可以分为以下几种情况：

1. 查询时包含坐标 $(X,Y)$，需要修改 $9$ 个单点。（即查询的范围覆盖了左上，右上，左下和右下四片区域）

1. 查询时包含 $X$ 行或 $Y$ 列，需要修改 $6$ 个单点。（即查询的范围覆盖了如上描述的区域中的两个）

1. 其他情况，需要修改 $4$ 个单点。（即查询的范围仅覆盖了如上描述的区域中的一个）

## 查询

查询时我们只需要直接一个区间查询 $\gcd$ 即可，没什么好说的。

## AC CODE

代码对于一道 $NOI$ 的题目来说算是正常的吧。$120$ 行左右。

```cpp
#include<stdio.h>
#include<cstring>
using namespace std;
typedef long long ll;
ll Abs(ll a){return a>=0?a:-a;}
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):Abs(a);
}
const int MAXA=2000010,MAXB=8000010;
int n,m;
#define pt(x,y) (x-1)*m+y
class Double_Segment_Tree{
    public:
    ll a[MAXB]; int clls[MAXB],clrs[MAXB],crls[MAXB],crrs[MAXB],cnt;
    Double_Segment_Tree(){
    	memset(a,0,sizeof(a)); memset(clls,0,sizeof(clls)); cnt=1;
    	memset(clrs,0,sizeof(clrs)); memset(crls,0,sizeof(crls)); memset(crrs,0,sizeof(crrs));
	} 
    void Build(int lx,int ly,int rx,int ry,int u,ll *p){
        if(lx==rx&&ly==ry){
            a[u]=p[pt(lx,ly)];
            return;
        }
        int mid1=(lx+rx)/2,mid2=(ly+ry)/2;
        a[u]=0;
        Build(lx,ly,mid1,mid2,clls[u]=++cnt,p),a[u]=gcd(a[u],a[clls[u]]);
        if(mid1+1<=rx) Build(mid1+1,ly,rx,mid2,clrs[u]=++cnt,p),a[u]=gcd(a[u],a[clrs[u]]);
        if(mid2+1<=ry) Build(lx,mid2+1,mid1,ry,crls[u]=++cnt,p),a[u]=gcd(a[u],a[crls[u]]);
        if(mid1+1<=rx&&mid2+1<=ry) Build(mid1+1,mid2+1,rx,ry,crrs[u]=++cnt,p),a[u]=gcd(a[u],a[crrs[u]]);
    }
    void Update(int lx,int ly,int rx,int ry,int u,int chidx,int chidy,ll val){
        if(lx==rx&&ly==ry){
            a[u]+=val;
            return;
        }
        int mid1=(lx+rx)/2,mid2=(ly+ry)/2;
        if(chidx<=mid1&&chidy<=mid2) Update(lx,ly,mid1,mid2,clls[u],chidx,chidy,val);
        if(mid1+1<=rx) if(chidx>mid1&&chidy<=mid2) Update(mid1+1,ly,rx,mid2,clrs[u],chidx,chidy,val);
        if(mid2+1<=ry) if(chidx<=mid1&&chidy>mid2) Update(lx,mid2+1,mid1,ry,crls[u],chidx,chidy,val);
        if(mid1+1<=rx&&mid2+1<=ry) if(chidx>mid1&&chidy>mid2) Update(mid1+1,mid2+1,rx,ry,crrs[u],chidx,chidy,val);
        a[u]=gcd(a[clls[u]],gcd(a[clrs[u]],gcd(a[crls[u]],a[crrs[u]])));
    }
    ll Query(int lx,int ly,int rx,int ry,int u,int chlx,int chly,int chrx,int chry){
        if(lx>=chlx&&ly>=chly&&rx<=chrx&&ry<=chry){
            return a[u];
        }
        ll res=0;
        int mid1=(lx+rx)/2,mid2=(ly+ry)/2;
        if(chlx<=mid1&&chly<=mid2) res=gcd(res,Query(lx,ly,mid1,mid2,clls[u],chlx,chly,chrx,chry));
        if(mid1+1<=rx) if(chrx>mid1&&chly<=mid2) res=gcd(res,Query(mid1+1,ly,rx,mid2,clrs[u],chlx,chly,chrx,chry));
        if(mid2+1<=ry) if(chlx<=mid1&&chry>mid2) res=gcd(res,Query(lx,mid2+1,mid1,ry,crls[u],chlx,chly,chrx,chry));
        if(mid1+1<=rx&&mid2+1<=ry) if(chrx>mid1&&chry>mid2) res=gcd(res,Query(mid1+1,mid2+1,rx,ry,crrs[u],chlx,chly,chrx,chry));
        return res;
    }
}seg;
ll S[MAXA];
int pl[5][4]={{0,0,0,0},{1,2,6,7},{4,5,9,10},{16,17,21,22},{19,20,24,25}};
bool flag[26];
int stx,sty,t,op,a,b,c,d;ll f;
int xpro(int val){
	if(val==1) return a-1;
	if(val==2) return c;
	if(val==3) return stx;
	if(val==4) return a;
	if(val==5) return c+1;
}
int ypro(int val){
	if(val==1) return b-1;
	if(val==2) return d;
	if(val==3) return sty;
	if(val==4) return b;
	if(val==5) return d+1;
}
int jz[26]={0,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1};
int main(){
    scanf("%d%d%d%d",&n,&m,&stx,&sty);
    scanf("%d",&t);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%lld",&S[pt(i,j)]);
    for(int i=1;i<=n;i++)
        for(int j=m;j>sty;j--)
            S[pt(i,j)]-=S[pt(i,j-1)];
    for(int i=1;i<=n;i++)
        for(int j=1;j<sty;j++)
            S[pt(i,j)]-=S[pt(i,j+1)];
    for(int i=1;i<=m;i++)
        for(int j=n;j>stx;j--)
            S[pt(j,i)]-=S[pt(j-1,i)];
    for(int i=1;i<=m;i++)
        for(int j=1;j<stx;j++)
            S[pt(j,i)]-=S[pt(j+1,i)];
    seg.Build(1,1,n,m,1,S);
    while(t--){
        scanf("%d%d%d%d%d",&op,&a,&b,&c,&d);
        if(op){//修改部分不想写一大堆if嵌套，所以压缩了亿下
            scanf("%lld",&f);
            memset(flag,0,sizeof(flag));
            int ssum=0;
            if(a<=stx&&b<=sty) for(int i=0;i<4;i++) flag[pl[1][i]]=1,ssum++;
            if(a<=stx&&d>=sty) for(int i=0;i<4;i++) flag[pl[2][i]]=1,ssum++;
            if(c>=stx&&b<=sty) for(int i=0;i<4;i++) flag[pl[3][i]]=1,ssum++;
            if(c>=stx&&d>=sty) for(int i=0;i<4;i++) flag[pl[4][i]]=1,ssum++;
            if(flag[2]&&flag[4]) flag[2]=flag[4]=0,flag[3]=1;
            if(flag[6]&&flag[16]) flag[6]=flag[16]=0,flag[11]=1;
            if(flag[10]&&flag[20]) flag[10]=flag[20]=0,flag[15]=1;
            if(flag[22]&&flag[24]) flag[22]=flag[24]=0,flag[23]=1;
            if(flag[7]&&flag[9]) flag[7]=flag[9]=0,flag[8]=1;
            if(flag[7]&&flag[17]) flag[7]=flag[17]=0,flag[12]=1;
            if(flag[17]&&flag[19]) flag[17]=flag[19]=0,flag[18]=1;
            if(flag[9]&&flag[19]) flag[9]=flag[19]=0,flag[14]=1;
            if(flag[8]&&flag[18]) flag[8]=flag[18]=0,flag[13]=1;
            for(int i=1;i<=25;i++){
            	if(!flag[i]) continue;
            	if(xpro((i-1)/5+1)>=1&&xpro((i-1)/5+1)<=n&&ypro((i-1)%5+1)>=1&&ypro((i-1)%5+1)<=m)
            		seg.Update(1,1,n,m,1,xpro((i-1)/5+1),ypro((i-1)%5+1),jz[i]*f);
			}
        }
        else{
            printf("%lld\n",seg.Query(1,1,n,m,1,stx-a,sty-b,stx+c,sty+d));
        }
    }
}
```

### 温馨提示：抄代码一时爽，棕名封号两行泪！

---

## 作者：int233 (赞：5)

非常感谢 @LYqwq 和 @王熙文 的卡常

看到其他题解都是用二维线段树做的，我太菜了，不会二维线段树

于是，我开始想别的解法，我突发奇想：可不可以用 n 个一维线段树去维护呢？

这个复杂度是 $O(Tn\log m)$ ，明显不行。

在面对 $n$ 很大的数据时，它就不行。那如果在 $n$ 过大时，将矩阵从 $n$ 行 $m$ 列转换成 $m$ 行 $n$ 列呢？

它的复杂度就变成了$O(T\min(n,m)\log \max(n,m))$

那么如何判断 $n$ 是否过大呢？可以这样判断：如果 $\sqrt{nm}\ge m$ ，那么 $n$ 就太大了。

具体来说，如果 $n=3,m=2$ ，矩阵为：

$\begin{matrix}1&2\\3&4\\5&6\end{matrix}$

则转换为：

$\begin{matrix}2&4&6\\1&2&3\end{matrix}$

交换 n , m 有助于之后的计算。

一维线段树可以这么处理：

$\gcd(x,y)=\gcd(x,y-x)$

维护差分数组，每次区间 $+c$ 时可以 $a_l+c,a_{r+1}-c$

至于 x 嘛，可以用差分树状数组解决。

## 60 分：

用 map 存储矩阵，并用刚才的方法解题。

[Code](https://www.luogu.com.cn/paste/c2mh7nfr)

## 70 分：

将 map 改为 unordered_map 即可。

## 90 分

由于 unordered_map 常数很大，而矩阵元素数量又很小，可以将 unordered_map 改成普通一维数组，$a_{i,j}$ 变成 $a_{(i-1)*m+j}$

线段树是一个个例，因为线段树要开 4 倍空间。 $a_{i,j}$ 变成 $a_{(i-1)*4*m+j}$

[Code(经过@LYqwq 略微卡常)](https://www.luogu.com.cn/paste/yn8yd4zm)：

## 100 分

众所周知，辗转相除法的复杂度是： $O(\log \max(x,y))$

如果数据规模很大，使用辗转相除法就会 TLE

感谢 @王熙文 给出的求最大公约数的函数

```cpp
inline ll exgcd(ll a,ll b)
{
	if(a<0) a=-a;
	if(b<0) b=-b;
	if(!a) return b;
	if(!b) return a;
	ll t=__builtin_ctzll(a|b),tmp;
	a>>=__builtin_ctzll(a);
	do
	{
		b>>=__builtin_ctzll(b);
		if(a>b)
		{
			tmp=a,a=b,b=tmp;
		}
		b-=a;
	} while(b);
	return a<<t;
}
```
将原来的 exgcd 替换成现有的 exgcd 即可 AC。

---

## 作者：Dispwnl (赞：5)

> Upt:2019-03-02
>
> 嗯别看这篇题解了
> 
> 四分树查询的复杂度是假的，最劣$O(\sqrt n)$
>
> 感谢@Marser 提醒
>
> 反正能过这题这代码就放在这吧……

调了一天到早上发现是差分差错了
![](https://cdn.luogu.com.cn/upload/pic/15867.png)

------

思路楼上已经写得很清楚了，现在只是给另一种用四分树的写法

四分树就是四分一个矩阵，然后普通线段树操作就行了

码量~~非常~~比较大，跑的还挺快，大概是因为常数小？

代码：
```cpp
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cstdlib>
# define LL long long
# define midl (x1+x2>>1)
# define midr (y1+y2>>1)
# define tll s[k].ll
# define tlr s[k].lr
# define trl s[k].rl
# define trr s[k].rr
# define pu(i,j) (i-1)*m+j
using namespace std;
const int MAX=5e5+1;
struct p{
	LL x;
	int ll,lr,rl,rr;
}s[MAX<<4];
int n,m,xs,ys,T,tot,rt;
LL a[MAX],b[MAX];
LL gcd(LL x,LL y)
{
	return y?gcd(y,x%y):abs(x);
}
LL read()
{
	LL x=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x*f;
}
void pus(int k)
{
	s[k].x=gcd(s[tll].x,gcd(s[tlr].x,gcd(s[trl].x,s[trr].x)));
}
void build(int x1,int y1,int x2,int y2,int &k)
{
	if(x1>x2||y1>y2) return;
	k=++tot;
	if(x1==x2&&y1==y2)
	{
		s[k].x=a[pu(x1,y1)];
		return;
	}
	build(x1,y1,midl,midr,tll);
	build(midl+1,y1,x2,midr,tlr);
	build(x1,midr+1,midl,y2,trl);
	build(midl+1,midr+1,x2,y2,trr);
	pus(k);
}
LL ask(int x1,int y1,int x2,int y2,int k,int X1,int Y1,int X2,int Y2)
{
	if(x1>X2||x2<X1||y1>Y2||y2<Y1) return 0;
	if(x1>=X1&&x2<=X2&&y1>=Y1&&y2<=Y2) return s[k].x;
	return gcd(ask(x1,y1,midl,midr,tll,X1,Y1,X2,Y2),gcd(ask(midl+1,y1,x2,midr,tlr,X1,Y1,X2,Y2),gcd(ask(x1,midr+1,midl,y2,trl,X1,Y1,X2,Y2),ask(midl+1,midr+1,x2,y2,trr,X1,Y1,X2,Y2))));
}
void change(int x1,int y1,int x2,int y2,int k,int X,int Y,LL dis)
{
	if(x1==x2&&y1==y2)
	{
		s[k].x+=dis;
		return;
	}
	if(X<=midl)
	if(Y<=midr) change(x1,y1,midl,midr,tll,X,Y,dis);
	else change(x1,midr+1,midl,y2,trl,X,Y,dis);
	else if(Y<=midr) change(midl+1,y1,x2,midr,tlr,X,Y,dis);
	else change(midl+1,midr+1,x2,y2,trr,X,Y,dis);
	pus(k);
}

int main()
{
	n=read(),m=read(),xs=read(),ys=read(),T=read();
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	    a[pu(i,j)]=read();
	for(int i=xs-1;i>=1;--i)
	  for(int j=1;j<=m;++j)
	    {
	    	int pos=pu(i,j);
	    	b[pos]=a[pos]-a[pos+m];
		}
	for(int i=xs+1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	    {
	    	int pos=pu(i,j);
	    	b[pos]=a[pos]-a[pos-m];
		}
	for(int i=1;i<=m;++i)
	  {
	  	int pos=pu(xs,i);
	  	b[pos]=a[pos];
	  }
	for(int i=1;i<=n;++i)
	  for(int j=ys-1;j>=1;--j)
	    {
	    	int pos=pu(i,j);
	    	a[pos]=b[pos]-b[pos+1];
		}
	for(int i=1;i<=n;++i)
	  for(int j=ys+1;j<=m;++j)
	    {
	    	int pos=pu(i,j);
	    	a[pos]=b[pos]-b[pos-1];
		}
	for(int i=1;i<=n;++i)
	  {
	  	int pos=pu(i,ys);
	  	a[pos]=b[pos];
	  }
	build(1,1,n,m,rt);
	for(int i=1;i<=T;++i)
	  {
	  	int op=read(),x1=read(),y1=read(),x2=read(),y2=read();
	  	if(!op) printf("%lld\n",ask(1,1,n,m,1,xs-x1,ys-y1,xs+x2,ys+y2));
	  	else if(op==1)
	  	{
	  		LL dis=read();
	  		if(x1<=xs&&y1<=ys&&x2>=xs&&y2>=ys)
	  		{
	  			change(1,1,n,m,1,xs,ys,dis);
	  			if(x1!=1)
	  			{
	  				change(1,1,n,m,1,x1-1,ys,-dis);
	  				if(y1!=1) change(1,1,n,m,1,x1-1,y1-1,dis);
	  				if(y2!=m) change(1,1,n,m,1,x1-1,y2+1,dis);
				}
				if(x2!=n)
				{
					change(1,1,n,m,1,x2+1,ys,-dis);
					if(y1!=1) change(1,1,n,m,1,x2+1,y1-1,dis);
					if(y2!=m) change(1,1,n,m,1,x2+1,y2+1,dis);
				}
				if(y1!=1) change(1,1,n,m,1,xs,y1-1,-dis);
				if(y2!=m) change(1,1,n,m,1,xs,y2+1,-dis);
			}
			else
			{
				if(x1<xs&&y1<ys&&x2<xs&&y2<ys)
				{
					change(1,1,n,m,1,x2,y2,dis);
					if(y1!=1&&x1!=1) change(1,1,n,m,1,x1-1,y1-1,dis);
					if(y1!=1) change(1,1,n,m,1,x2,y1-1,-dis);
					if(x1!=1) change(1,1,n,m,1,x1-1,y2,-dis);
				}
				else if(x1<xs&&y1>ys&&x2<xs&&y2>ys)
				{
					change(1,1,n,m,1,x2,y1,dis);
					if(y2!=m&&x1!=1) change(1,1,n,m,1,x1-1,y2+1,dis);
					if(y2!=m) change(1,1,n,m,1,x2,y2+1,-dis);
					if(x1!=1) change(1,1,n,m,1,x1-1,y1,-dis);
				}
				else if(x1>xs&&y1<ys&&x2>xs&&y2<ys)
				{
					change(1,1,n,m,1,x1,y2,dis);
					if(y1!=1&&x2!=n) change(1,1,n,m,1,x2+1,y1-1,dis);
					if(y1!=1) change(1,1,n,m,1,x1,y1-1,-dis);
					if(x2!=n) change(1,1,n,m,1,x2+1,y2,-dis);
				}
				else if(x1>xs&&y1>ys&&x2>xs&&y2>ys)
				{
					change(1,1,n,m,1,x1,y1,dis);
					if(y2!=m&&x2!=n) change(1,1,n,m,1,x2+1,y2+1,dis);
					if(y2!=m) change(1,1,n,m,1,x1,y2+1,-dis);
					if(x2!=n) change(1,1,n,m,1,x2+1,y1,-dis);
				}
				else if(x1<=xs&&x2>=xs&&y1<ys&&y2<ys)
				{
					change(1,1,n,m,1,xs,y2,dis);
					if(y1!=1&&x1!=1) change(1,1,n,m,1,x1-1,y1-1,dis);
					if(y1!=1&&x2!=n) change(1,1,n,m,1,x2+1,y1-1,dis);
					if(y1!=1) change(1,1,n,m,1,xs,y1-1,-dis);
					if(x1!=1) change(1,1,n,m,1,x1-1,y2,-dis);
					if(x2!=n) change(1,1,n,m,1,x2+1,y2,-dis);
				}
				else if(x1<=xs&&x2>=xs&&y1>ys&&y2>ys)
				{
					change(1,1,n,m,1,xs,y1,dis);
					if(y2!=m&&x1!=1) change(1,1,n,m,1,x1-1,y2+1,dis);
					if(y2!=m&&x2!=n) change(1,1,n,m,1,x2+1,y2+1,dis);
					if(y2!=m) change(1,1,n,m,1,xs,y2+1,-dis);
					if(x1!=1) change(1,1,n,m,1,x1-1,y1,-dis);
					if(x2!=n) change(1,1,n,m,1,x2+1,y1,-dis);
				}
				else if(x1<xs&&x2<xs&&y1<=ys&&y2>=ys)
				{
					change(1,1,n,m,1,x2,ys,dis);
					if(y1!=1&&x1!=1) change(1,1,n,m,1,x1-1,y1-1,dis);
					if(y2!=m&&x1!=1) change(1,1,n,m,1,x1-1,y2+1,dis);
					if(y1!=1) change(1,1,n,m,1,x2,y1-1,-dis);
					if(x1!=1) change(1,1,n,m,1,x1-1,ys,-dis);
					if(y2!=m) change(1,1,n,m,1,x2,y2+1,-dis);
				}
				else if(x1>xs&&x2>xs&&y1<=ys&&y2>=ys)
				{
					change(1,1,n,m,1,x1,ys,dis);
					if(y1!=1&&x2!=n) change(1,1,n,m,1,x2+1,y1-1,dis);
					if(y2!=m&&x2!=n) change(1,1,n,m,1,x2+1,y2+1,dis);
					if(y1!=1) change(1,1,n,m,1,x1,y1-1,-dis);
					if(x2!=n) change(1,1,n,m,1,x2+1,ys,-dis);
					if(y2!=m) change(1,1,n,m,1,x1,y2+1,-dis);
				}
			}
		}
	  }
	return 0;
}
```

---

## 作者：MuelsyseU (赞：4)

补一个四分树做法的复杂度证明。

类似于 CH4302，题解区大佬对采取二维差分方法解决这个问题的二维版本的方法已经有详细的阐释。具体来说，需要一个维护单点修改、矩形 $\gcd$ 的数据结构，显然二维线段树可以实现。

然而，由于初学 DS 时常常听到四分树这一复杂度“极端错误”的结构，这里笔者首先想到了四分树。显然单点修改没有问题；而实际上由于数据随机，实际上还可以达到 $O(\log n)$ 的均摊单次查询复杂度和较小的时空常数。这里分析四分树的复杂度。考虑四分树每次递归的情形：

1. 询问矩形恰好完全覆盖当前节点，直接返回。
2. 否则若询问矩形与四个儿子中的某一个重叠，只递归单棵子树。
3. 否则若询问矩形与两个相邻儿子重叠，递归两棵子树。
4. 否则若询问矩形与四个儿子重叠，递归四棵子树。

考虑最坏情况，询问为 $1\times n$ 的矩形，显然导致复杂度和遍历单棵线段树相当，为 $O(n)$。

但由于 **数据随机**，这种情况发生的概率较小。容易发现，情况 4 只会出现多次，但这时实际上只有一次可能出现询问矩形不与该节点四角中任意一个重叠。而如果重叠，显然会递归在儿子上出现一次 1 情况（如左下）。另外，这个儿子对面的（如右上）儿子肯定也会出现与角落重合的情况，这个儿子会在若干次 2 情况后回到 4 情况，以此类推。因此，情况 4 总共只会带来 $O(\log n)$ 的复杂度。

实际导致复杂度不对的是在接下来出现的情况 3 以及之前 4 情况中出现的尚未被处理的两个儿子（实际上也就是若干情况 3 组合），例如跨过整个矩形中点的一次 $n\times 2$ 的询问就导致这两个儿子需要递归 $O(n)$ 次才能得到结果。此时询问矩形在递归中始终与两个儿子重叠。显然，线段树中也会存在与两个儿子始终重合的询问区间，但在这之前递归路径上已经由于被完全覆盖而剪枝了。但在四分树上，由于节点的额外一维始终不能被询问矩形完全覆盖，因此只能继续递归。

我们不妨考虑在某一子树内出现了这一情况，不失一般性，设此时该子树对应矩形在左边界与询问矩形重合并且没有跨过四个儿子，也就是说，在进入这一子树时，我们只会对其中每个节点的左边两个儿子进行递归。可以发现，如果左边重合的部分宽度为 $k$，则我们一旦在情况 2 中进入宽度小于 $k$ 的节点就会直接返回。而如果递归中出现情况 4，那么左半边肯定被完全覆盖直接返回，右边又是一个递归的情况 2 的问题（这时和线段树完全一致）。

如果假设 $k$ 是**随机**的，则期望此时递归产生复杂度为：

$$\dfrac{1}{n}\sum^{n}_{k=1}\sum^{\lceil \log n - \log k\rceil}_{j=0}2^j={O}(\log n)$$

显然两个未处理儿子的 $k$ 值应当为随机。而 $3$ 情况要么由于询问区间恰好位于对应位置导致，要么是由**第一次**情况 4 产生。所以我们认为上述分析同样可以用于整体询问。

细节诸多。注意到在 CH4302 中这个是支持任意区间修改的，实际上本题中也同样支持，只不过还需要额外维护每个点的实际值。考虑查询矩形 $(x_1,y_1)(x_2,y_2)$，求 $\gcd(a_{x_1,y_1},\operatorname{ask}(x_1,y_1+1,x_2,y_2),\operatorname{ask}(x_1+1,y_1,x_2,y_2))$ 即可。

---

## 作者：Milky_Way (赞：4)

二维线段树，按套路差分原矩阵，gcd( x1, x2, ……, xn ) = gcd( xi , x2 - x1 , ……, xn - xn-1 )，必须要有一个原数 xi，恰好每次询问都包含一个固定点 ( x , y )，差分以它为中心就可以保证它是原值。以 e 为中心的二阶差分如图。

（如果图片无法正常显示请点[这里](http://www.cnblogs.com/milky-w/p/8530723.html)。）

![](https://images2018.cnblogs.com/blog/1326357/201803/1326357-20180308155219267-394626.png)

对于一维序列，修改区间 [ l , r ] 只需修改差分后的 l 和 r + 1 两点。那么对于二维，差分后的修改如下所示：

![](https://images2018.cnblogs.com/blog/1326357/201803/1326357-20180308200045381-604844866.png)

中间的灰色格子为守卫者所在地（为方便表示多个区域把它拆成了 9 格），以它为差分中心，若修改矩阵在它的右下方，即黄色区域，设它的左上角坐标为 ( x1, y1)，右下角坐标 ( x2, y2 )，则需在 ( x1, y1 ) 处 + c，( x1, y2+1 ) 处 - c，( x2+1, y1 ) 处 - c，( x2 + 1, y2 + 1) 处 +c。

其他区域同理。再加上守卫者正上方、正下方、正左方、正右方的区域，一共 8 种情况。如果一个修改矩阵包含多个区域，就将其划分为若干个子矩阵处理。

这样就将巨慢的区间修改转换成了单点修改，每修改完一个点，pushup( ) 维护 gcd 即可。

另外读入的时候，500000 * 500000 的二维数组是开不了的，需要动态分配内存；或者开一个 500000 的一维数组读入，判断每一行的末端在哪里。

讨论的时候有些麻烦，下面列一下大致的情况：（黄色表示修改的区域，绿色加， 红色减）

（如果图片无法正常显示请点[这里](http://www.cnblogs.com/milky-w/p/8530723.html)。）

![](https://images2018.cnblogs.com/blog/1326357/201803/1326357-20180309134736310-607758096.png)

仔细观察后，发现可分为三种情况：① 包含守卫者 ( X , Y )；② 包含 X 行或 Y 列；③ 只包含左上或左下、右上或右下区域。

细节诸多。

```cpp
#include <cstdio>
#include <string>

const int N = 500005;
typedef long long ll;

int n, m; ll a[N], b[N];

ll read() {
	ll x = 0, f = 1;
	char c = getchar();
	while (!isdigit(c)) {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x * f;
}

ll abs(ll x) {
	if (x >= 0) return x; return -x;
}

ll gcd(ll x, ll y) {
	if (y) return gcd(y, x % y); return abs(x);
}

struct inNode {
	ll val;
	inNode *ls, *rs;
	inNode() : val(0), ls(NULL), rs(NULL) {}
} inPool[N << 2];

inNode *newInNode () {
	static int cnt = 0;
	return &inPool[++cnt];
}

void buildY(inNode *&cur, int l, int r, int x) {
	if (!cur) cur = newInNode();
	if (l == r) cur->val = a[(x - 1) * m + l];
	else {
		int mid = l + ((r - l) >> 1);
		buildY(cur->ls, l, mid, x);
		buildY(cur->rs, mid + 1, r, x);
		cur->val = gcd(cur->ls->val, cur->rs->val);
	}
}

void updateY(inNode *&cur, int l, int r, int y, ll val) {
	if (l == r) cur->val += val;
	else {
		int mid = l + ((r - l) >> 1);
		if (y <= mid) updateY(cur->ls, l, mid, y, val);
		else updateY(cur->rs, mid + 1, r, y, val);
		cur->val = gcd(cur->ls ? cur->ls->val : 0, cur->rs ? cur->rs->val : 0);
	}
}

void maintainY(inNode *&cur, int l, int r, int y, ll val) {
	if (l == r) cur->val = val;
	else {
		int mid = l + ((r - l) >> 1);
		if (y <= mid) maintainY(cur->ls, l, mid, y, val);
		else maintainY(cur->rs, mid + 1, r, y, val);
		cur->val = gcd(cur->ls ? cur->ls->val : 0, cur->rs ? cur->rs->val : 0);
	} 
}

ll queryY(inNode *&cur, int l, int r, int y1, int y2) {
	if (y1 <= l && r <= y2) return cur->val;
	int mid = l + ((r - l) >> 1); ll res = 0;
	if (y1 <= mid) res = gcd(res, queryY(cur->ls, l, mid, y1, y2));
	if (mid < y2) res = gcd(res, queryY(cur->rs, mid + 1, r, y1, y2));
	return res;
}

struct outNode {
	inNode *root;
	outNode *ls, *rs;
	outNode() : root(NULL), ls(NULL), rs(NULL) {}
} outPool[N << 2], *root;

outNode *newOutNode() {
	static int cnt = 0;
	return &outPool[++cnt];
}

void maintainX(inNode *&cur, inNode *&lc, inNode *&rc, int l, int r) {
	if (!cur) cur = newInNode();
	if (l == r) cur->val = gcd(lc->val, rc->val);
	else {
		int mid = l + ((r - l) >> 1);
		maintainX(cur->ls, lc->ls, rc->ls, l, mid);
		maintainX(cur->rs, lc->rs, rc->rs, mid + 1, r);
		cur->val = gcd(cur->ls->val ,cur->rs->val);
	}
}

void buildX(outNode *&cur, int l, int r) {
	if (!cur) cur = newOutNode();
	if (l == r) buildY(cur->root, 1, m, l);
	else {
		int mid = l + ((r - l) >> 1);
		buildX(cur->ls, l, mid);
		buildX(cur->rs, mid + 1, r);
		maintainX(cur->root, cur->ls->root, cur->rs->root, 1, m);
	}
}

void updateX(outNode *&cur, int l, int r, int x, int y, ll val) {
	if (x <= 0 || y <= 0 || x > n || y > m) return;
	if (l == r) updateY(cur->root, 1, m, y, val);
	else {
		int mid = l + ((r - l) >> 1); ll lv = 0, rv = 0;
		if (x <= mid) updateX(cur->ls, l, mid, x, y, val);
		else updateX(cur->rs, mid + 1, r, x, y, val);
		if (cur->ls) lv = queryY(cur->ls->root, 1, m, y, y);
		if (cur->rs) rv = queryY(cur->rs->root, 1, m, y, y);
		maintainY(cur->root, 1, m, y, gcd(lv, rv));
	}
}

ll queryX(outNode *&cur, int l, int r, int x1, int x2, int y1, int y2) {
	if (x1 <= l && r <= x2) return queryY(cur->root, 1, m, y1, y2);
	int mid = l + ((r - l) >> 1); ll res = 0;
	if (x1 <= mid) res = gcd(res, queryX(cur->ls, l, mid, x1, x2, y1, y2));
	if (mid < x2) res = gcd(res, queryX(cur->rs, mid + 1, r, x1, x2, y1, y2));
	return res;
}

int main() {
	n = read(), m = read();	int X = read(), Y = read(), T = read();
	for (int i = 1; i <= n * m; ++ i) a[i] = read();
	for (int i = 1; i <= n * m; ++ i) {
		if ((i - 1) % m + 1 < Y) b[i] = a[i] - a[i + 1];
		else if ((i - 1) % m + 1 > Y) b[i] = a[i] - a[i - 1];
		else b[i] = a[i];
	}
	for (int i = 1; i <= n * m; ++ i) {
		if ((i - 1) / m + 1 < X) a[i] = b[i] - b[i + m];
		else if ((i - 1) / m + 1 > X) a[i] = b[i] - b[i - m];
		else a[i] = b[i];
	}
	buildX(root, 1, n);
	while (T--) {
		int opt = read(), x1 = read(), y1 = read(), x2 = read(), y2 = read();
		if (opt == 0) {
			x1 = X - x1, x2 = X + x2, y1 = Y - y1, y2 = Y + y2;
			printf("%lld\n", queryX(root, 1, n, x1, x2, y1, y2));
		} else {
			ll val = read();
			if (x1 <= X && x2 >= X && y1 <= Y && y2 >= Y) {	//包含(X,Y) 
				updateX(root, 1, n, X, Y, val);
				updateX(root, 1, n, x1 - 1, y1 - 1, val);
				updateX(root, 1, n, x1 - 1, y2 + 1, val);
				updateX(root, 1, n, x2 + 1, y1 - 1, val);
				updateX(root, 1, n, x2 + 1, y2 + 1, val);
				updateX(root, 1, n, x1 - 1, Y, -val);
				updateX(root, 1, n, x2 + 1, Y, -val);
				updateX(root, 1, n, X, y1 - 1, -val);
				updateX(root, 1, n, X, y2 + 1, -val);
			} else if (y1 <= Y && y2 >= Y) {				//包含Y列 
				if (x1 < X) {								//在(X,Y)上方 
					updateX(root, 1, n, x2, Y, val);
					updateX(root, 1, n, x1 - 1, y1 - 1, val);
					updateX(root, 1, n, x1 - 1, y2 + 1, val);
					updateX(root, 1, n, x1 - 1, Y, -val);
					updateX(root, 1, n, x2, y1 - 1, -val);
					updateX(root, 1, n, x2, y2 + 1, -val);
				} else {									//在(X,Y)下方 
					updateX(root, 1, n, x1, Y, val);
					updateX(root, 1, n, x2 + 1, y1 - 1, val);
					updateX(root, 1, n, x2 + 1, y2 + 1, val);
					updateX(root, 1, n, x2 + 1, Y, -val);
					updateX(root, 1, n, x1, y1 - 1, -val);
					updateX(root, 1, n, x1, y2 + 1, -val);
				}
			} else if (x1 <= X && x2 >= X) {				//包含X行 
				if (y1 < Y) {								//在(X,Y)左边 
					updateX(root, 1, n, X, y2, val);
					updateX(root, 1, n, x1 - 1, y1 - 1, val);
					updateX(root, 1, n, x2 + 1, y1 - 1, val);
					updateX(root, 1, n, X, y1 - 1, -val);
					updateX(root, 1, n, x1 - 1, y2, -val);
					updateX(root, 1, n, x2 + 1, y2, -val);
				} else {									//在(X,Y)右边 
					updateX(root, 1, n, X, y1, val);
					updateX(root, 1, n, x1 - 1, y2 + 1, val);
					updateX(root, 1, n, x2 + 1, y2 + 1, val);
					updateX(root, 1, n, X, y2 + 1, -val);
					updateX(root, 1, n, x1 - 1, y1, -val);
					updateX(root, 1, n, x2 + 1, y1, -val);
				}
			} else if (x1 < X && y1 < Y) {					//左上区域 
				updateX(root, 1, n, x2, y2, val);
				updateX(root, 1, n, x1 - 1, y1 - 1, val);
				updateX(root, 1, n, x1 - 1, y2, -val);
				updateX(root, 1, n, x2, y1 - 1, -val);
			} else if (x1 < X && y1 > Y) {					//右上区域 
				updateX(root, 1, n, x2, y1, val);
				updateX(root, 1, n, x1 - 1, y2 + 1, val);
				updateX(root, 1, n, x1 - 1, y1, -val);
				updateX(root, 1, n, x2, y2 + 1, -val);
			} else if (x1 > X && y1 < Y) {					//左下区域 
				updateX(root, 1, n, x1, y2, val);
				updateX(root, 1, n, x2 + 1, y1 - 1, val);
				updateX(root, 1, n, x1, y1 - 1, -val);
				updateX(root, 1, n, x2 + 1, y2, -val);
			} else {										//右下区域 
				updateX(root, 1, n, x1, y1, val);
				updateX(root, 1, n, x2 + 1, y2 + 1, val);
				updateX(root, 1, n, x1, y2 + 1, -val);
				updateX(root, 1, n, x2 + 1, y1, -val);
			}
		}
	}
	return 0;
}
```

---

## 作者：Bad_Luck_No_Fun (赞：1)

这道题是一个二维线段树板子。我们读题可以发现这道题要求我们用线段树维护一个矩阵，需要支持矩阵加，矩阵求 gcd 的功能。

我们可以先联系一下一维时的这道题。

我们可以发现，对于 $a_1,a_2,a_3,...,a_n$ 这个数组来说：

$\gcd 
(a_l,a_{l+1},a_{l+2},...,a_r)=\gcd(a_{l+1}-a_l,a_{l+2}-a_{l+1},...,a_r-a_{r-1},a_i)$ 

其中 $i \in [l,r]$ 。

这件事可以让我们拓展到二维，我们可以对矩阵进行二维差分处理，除此之外，我们还需要用两个普通的线段树维护一行和一列的情况，原因和一维情况中需要维护一个 $a_i$ 一样。

然后我们就可以选择维护第 $X$ 行，第 $Y$ 列（因为不管怎么样查询都会经过这两列）以及 $a_{X,Y}$ 的值。

至于二维差分矩阵的动态维护，也可以使用树套树或四分树实现，笔者是用四分树实现的。

接下来就是愉快的 coding time 了。

下面放一下 code。

```cpp
# include <bits/stdc++.h>
# define int long long
# define maxm 1000005
# define maxn 1005
using namespace std;
int n, m, X, Y, q, w;
vector <int> a[maxm];

inline int gcd(int a, int b, int c, int d) {
	return __gcd(a, __gcd(b, __gcd(c, d)));
}

struct segment_tree1 {
	int cnt;
	int g[maxm * 8];
	int lls[maxm * 8];
	int lrs[maxm * 8];
	int rls[maxm * 8];
	int rrs[maxm * 8];
	void init() { cnt = 1; } 
	int id(int &x) { return x ? x : x = ++cnt; }
	void pushup(int i) {
		g[i] = gcd(g[lls[i]], g[lrs[i]], g[rls[i]], g[rrs[i]]);
	}
	void ch(int i, int xl, int xr, int yl, int yr, int x, int y, int c) {
		if (xl == xr && yl == yr) {
			g[i] += c;
			return;
		}
		int midx = xl + xr >> 1;
		int midy = yl + yr >> 1;
		if (x <= midx && y <= midy)
			ch(id(lls[i]), xl, midx, yl, midy, x, y, c);
		if (midx <  x && y <= midy)
			ch(id(lrs[i]), midx + 1, xr, yl, midy, x, y, c);
		if (x <= midx && midy <  y)
			ch(id(rls[i]), xl, midx, midy + 1, yr, x, y, c);
		if (midx <  x && midy <  y)
			ch(id(rrs[i]), midx + 1, xr, midy + 1, yr, x, y, c);
		pushup(i);
	}
	int ask_gcd(int i, int xl, int xr, int yl, int yr, int qxl, int qxr, int qyl, int qyr) {
		if (qxl > xr || qxr < xl)
			return 0;
		if (qyl > yr || qyr < yl)
			return 0;
		if (qxl <= xl && xr <= qxr && qyl <= yl && yr <= qyr)
			return g[i];
		int midx = xl + xr >> 1;
		int midy = yl + yr >> 1;
		int ret = 0;
		ret = __gcd(ret, ask_gcd(id(lls[i]), xl, midx, yl, midy, qxl, qxr, qyl, qyr));
		ret = __gcd(ret, ask_gcd(id(lrs[i]), midx + 1, xr, yl, midy, qxl, qxr, qyl, qyr));
		ret = __gcd(ret, ask_gcd(id(rls[i]), xl, midx, midy + 1, yr, qxl, qxr, qyl, qyr));
		ret = __gcd(ret, ask_gcd(id(rrs[i]), midx + 1, xr, midy + 1, yr, qxl, qxr, qyl, qyr));
		return abs(ret);
	}
} tr;
struct segment_tree2 {
	int g[maxm * 10];
	void pushup(int i)
	{
		g[i] = __gcd(g[2 * i + 1], g[2 * i + 2]);
	}
	void ch(int i, int l, int r, int x, int c)
	{
		if(l == r) {
			g[i] += c;
			return; 
		} 
		int mid = l + r >> 1;
		if(x <= mid) ch(2 * i + 1, l, mid, x, c);
		if(mid <  x) ch(2 * i + 2, mid + 1, r, x, c);
 		pushup(i);
	}
	int ask_gcd(int i, int l, int r, int ql, int qr)
	{
		if(r < ql || l > qr) return 0;
		if(ql <= l && r <= qr) return g[i];
		int ret = 0; int mid = l + r >> 1;
		ret = __gcd(ret, ask_gcd(2 * i + 1, l, mid, ql, qr));
		ret = __gcd(ret, ask_gcd(2 * i + 2, mid + 1, r, ql, qr));
		return abs(ret);
	}
} T1, T2;
signed main() {
	//freopen("P2086.in", "r", stdin);
	//freopen("P2086.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin >> n >> m >> X >> Y >> q;
	for (int i = 0; i <= n + 4; i++)
		for (int j = 0; j <= m + 4; j++)
			a[i].push_back(0);
	
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
	}
	tr.init();
	n++, m++;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			tr.ch(1, 1, n, 1, m, i, j, a[i][j] + a[i - 1][j - 1] - a[i - 1][j] - a[i][j - 1]);
	w = a[X][Y];
	for(int i = 1; i <= n; i++) T1.ch(0, 1, n, i, a[i][Y] - a[i - 1][Y]);
	for(int i = 1; i <= m; i++) T2.ch(0, 1, m, i, a[X][i] - a[X][i - 1]);
	while (q--) {
		int opt, xl, xr, yl, yr, c;
		cin >> opt;
		if (!opt) {
			cin >> xl >> yl >> xr >> yr;
			int ans = __gcd(w, tr.ask_gcd(1, 1, n, 1, m, X - xl + 1, X + xr, Y - yl + 1, Y + yr));
			ans = __gcd(ans, __gcd(T1.ask_gcd(0, 1, n, X - xl + 1, X + xr), T2.ask_gcd(0, 1, m, Y - yl + 1, Y + yr)));
			cout << ans << endl;
		} else {
			cin >> xl >> yl >> xr >> yr >> c;
			tr.ch(1, 1, n, 1, m, xl, yl, c);
			tr.ch(1, 1, n, 1, m, xl, yr + 1, -c);
			tr.ch(1, 1, n, 1, m, xr + 1, yl, -c);
			tr.ch(1, 1, n, 1, m, xr + 1, yr + 1, c);
			if(xl <= X && X <= xr && yl <= Y && Y <= yr) w += c;
			if(xl <= X && X <= xr) T2.ch(0, 1, m, yl, c), T2.ch(0, 1, m, yr + 1, -c);
			if(yl <= Y && Y <= yr) T1.ch(0, 1, n, xl, c), T1.ch(0, 1, n, xr + 1, -c);
		}
	}
	return 0;
}
```

---

## 作者：NebuDrift_Psc (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2086)

显然可以用线段树维护，但是如果是区间修改的话就不好办了。这个时候我们需要将原矩阵以棋盘守护者的位置为中心进行差分，那么区间修改就变为单点修改了，自然好维护多了。

但是当我们整体加的时候，因为我们对原矩阵进行了拆分，所以对于每个点是加是减还是不动的话需要分类讨论一番。

经过观察我们会发现，有三种情况（棋盘守护者的位置变化）。

### Nov.1:询问矩阵不包括

询问矩阵包含棋盘守护者所在的轴。
 
询问矩阵不包含棋盘守护者所在的轴。
 
### Nov.2:询问矩阵包括

这个时候我们可以自己更改原矩阵，然后输出其差分矩阵寻找规律了。需要注意的是判断的时候的边界情况以及自己修改的点的位置是否正确。细节很多，需要注意。

# Code:
```
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
#define F(i,x,y) for((i)=(x);(i)<=(y);++(i))
#define R(i,x,y) for((i)=(x);(i)>=(y);--(i))

const int N=5e5+7;
const int inf=1e9+9;

int n,m;LL a[N],b[N];
int id(int x,int y) {return (x-1)*m+y;}

namespace OI {
    LL abs(LL x) {return x>=0?x:-x;}
    LL gcd(LL x,LL y) {return y?gcd(y,x%y):abs(x);}
    template <typename _Tp> inline void IN(_Tp&x) {
        char ch;bool flag=0;x=0;
        while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;
        while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
        if(flag) x=-x;
    }
}using namespace OI;

namespace _2D_Segment_tree {/*四分线段树*/
    #define midl ((x1+x2)>>1)
    #define midr ((y1+y2)>>1)
    int tot,root;
    struct Node {LL v;int ll,lr,rl,rr;}t[N<<4];
    void pushup(int x) {
        LL vl=gcd(t[t[x].ll].v,t[t[x].lr].v);
        LL vr=gcd(t[t[x].rl].v,t[t[x].rr].v);
        t[x].v=gcd(vl,vr);return;
    }
    void build(int&x,int x1,int y1,int x2,int y2) {
        if(x1>x2||y1>y2) return;x=++tot;
        if(x1==x2&&y1==y2) {t[x].v=a[id(x1,y1)];return;}
        build(t[x].ll,x1,y1,midl,midr);
        build(t[x].lr,midl+1,y1,x2,midr);
        build(t[x].rl,x1,midr+1,midl,y2);
        build(t[x].rr,midl+1,midr+1,x2,y2);
        pushup(x);return;
    }
    void change(int x,int x1,int y1,int x2,int y2,int X,int Y,LL val) {
        if(x1>X||X>x2||y1>Y||Y>y2) return;
        if(x1==x2&&y1==y2) {t[x].v+=val;return;}
        change(t[x].ll,x1,y1,midl,midr,X,Y,val);
        change(t[x].lr,midl+1,y1,x2,midr,X,Y,val);
        change(t[x].rl,x1,midr+1,midl,y2,X,Y,val);
        change(t[x].rr,midl+1,midr+1,x2,y2,X,Y,val);
        pushup(x);return;
    }
    LL query(int x,int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2) {
        if(x1>X2||x2<X1||y1>Y2||y2<Y1) return 0;
        if(X1<=x1&&Y1<=y1&&x2<=X2&&y2<=Y2) return t[x].v;
        LL vll=query(t[x].ll,x1,y1,midl,midr,X1,Y1,X2,Y2);
        LL vlr=query(t[x].lr,midl+1,y1,x2,midr,X1,Y1,X2,Y2);
        LL vrl=query(t[x].rl,x1,midr+1,midl,y2,X1,Y1,X2,Y2);
        LL vrr=query(t[x].rr,midl+1,midr+1,x2,y2,X1,Y1,X2,Y2);
        return gcd(vll,gcd(vlr,gcd(vrl,vrr)));
    }
}using namespace _2D_Segment_tree;

int main() {
    IN(n),IN(m);
    int X,Y,T,i,j;IN(X),IN(Y),IN(T);
    for(int i=1;i<=n*m;++i) IN(a[i]);
    /*-------对原矩阵进行差分-------*/
    for(int i=1;i<=n*m;++i){
        if((i-1)%m+1<Y) b[i]=a[i]-a[i+1];
        else if((i-1)%m+1>Y) b[i]=a[i]-a[i-1];
        else b[i]=a[i];
    }
    for(int i=1;i<=n*m;++i) {
        if((i-1)/m+1<X) a[i]=b[i]-b[i+m];
        else if((i-1)/m+1>X) a[i]=b[i]-b[i-m];
        else a[i]=b[i];
    }
    /*----------------------------*/
    build(root,1,1,n,m);
    while(T--) {
        int op,x1,y1,x2,y2;IN(op),IN(x1),IN(y1),IN(x2),IN(y2);
        if(!op) printf("%lld\n",query(1,1,1,n,m,X-x1,Y-y1,X+x2,Y+y2));
        else {
            LL val;IN(val);
            if(x1<=X&&x2>=X&&y1<=Y&&y2>=Y) {/*包含了 (X,Y)*/
                change(1,1,1,n,m,X,Y,val);
                if(y1-1>=1) change(1,1,1,n,m,X,y1-1,-val);
                if(y2+1<=m) change(1,1,1,n,m,X,y2+1,-val);
                if(x1-1>=1) change(1,1,1,n,m,x1-1,Y,-val);
                if(x2+1<=n) change(1,1,1,n,m,x2+1,Y,-val);
                if(x1-1>=1&&y1-1>=1) change(1,1,1,n,m,x1-1,y1-1,val);
                if(x1-1>=1&&y2+1<=m) change(1,1,1,n,m,x1-1,y2+1,val);
                if(x2+1<=n&&y1-1>=1) change(1,1,1,n,m,x2+1,y1-1,val);
                if(x2+1<=n&&y2+1<=m) change(1,1,1,n,m,x2+1,y2+1,val);
            } else if(y1<=Y&&Y<=y2) {/*包含 Y 轴*/
                if(x1<X&&x2<X) {/*在上面*/
                    change(1,1,1,n,m,x2,Y,val);
                    if(y1-1>=1) change(1,1,1,n,m,x2,y1-1,-val);
                    if(y2+1<=m) change(1,1,1,n,m,x2,y2+1,-val);
                    if(x1-1>=1) change(1,1,1,n,m,x1-1,Y,-val);
                    if(x1-1>=1&&y1-1>=1) change(1,1,1,n,m,x1-1,y1-1,val);
                    if(x1-1>=1&&y2+1<=m) change(1,1,1,n,m,x1-1,y2+1,val);
                } else if(x1>X&&x2>X) {/*在下面*/
                    change(1,1,1,n,m,x1,Y,val);
                    if(y1-1>=1) change(1,1,1,n,m,x1,y1-1,-val);
                    if(y2+1<=m) change(1,1,1,n,m,x1,y2+1,-val);
                    if(x2+1<=n) change(1,1,1,n,m,x2+1,Y,-val);
                    if(x2+1<=n&&y1-1>=1) change(1,1,1,n,m,x2+1,y1-1,val);
                    if(x2+1<=n&&y2+1<=m) change(1,1,1,n,m,x2+1,y2+1,val);
                }
            } else if(x1<=X&&X<=x2) {/*包含 X 轴*/
                if(y1<Y&&y2<Y) {/*在左边*/
                    change(1,1,1,n,m,X,y2,val);
                    if(x1-1>=1) change(1,1,1,n,m,x1-1,y2,-val);
                    if(x2+1<=n) change(1,1,1,n,m,x2+1,y2,-val);
                    if(y1-1>=1) change(1,1,1,n,m,X,y1-1,-val);
                    if(y1-1>=1&&x1-1>=1) change(1,1,1,n,m,x1-1,y1-1,val);
                    if(y1-1>=1&&x2+1<=n) change(1,1,1,n,m,x2+1,y1-1,val);
                } else if(y1>Y&&y2>Y) {/*在右边*/
                    change(1,1,1,n,m,X,y1,val);
                    if(x1-1>=1) change(1,1,1,n,m,x1-1,y1,-val);
                    if(x2+1<=n) change(1,1,1,n,m,x2+1,y1,-val);
                    if(y2+1<=m) change(1,1,1,n,m,X,y2+1,-val);
                    if(y2+1<=m&&x1-1>=1) change(1,1,1,n,m,x1-1,y2+1,val);
                    if(y2+1<=m&&x2+1<=n) change(1,1,1,n,m,x2+1,y2+1,val);
                }
            } else {//剩下的判断四个角
                if(x2<X&&y2<Y) {//左上角
                    change(1,1,1,n,m,x2,y2,val);
                    if(y1-1>=1) change(1,1,1,n,m,x2,y1-1,-val);
                    if(x1-1>=1) change(1,1,1,n,m,x1-1,y2,-val);
                    if(x1-1>=1&&y1-1>=1) change(1,1,1,n,m,x1-1,y1-1,val);
                } else if(x2<X&&y1>Y) {/*右上角*/
                    change(1,1,1,n,m,x2,y1,val);
                    if(y2+1<=m) change(1,1,1,n,m,x2,y2+1,-val);
                    if(x1-1>=1) change(1,1,1,n,m,x1-1,y1,-val);
                    if(x1-1>=1&&y2+1<=m) change(1,1,1,n,m,x1-1,y2+1,val);
                } else if(x1>X&&y2<Y) {/*左下角*/
                    change(1,1,1,n,m,x1,y2,val);
                    if(y1-1>=1) change(1,1,1,n,m,x1,y1-1,-val);
                    if(x2+1<=n) change(1,1,1,n,m,x2+1,y2,-val);
                    if(x2+1<=n&&y1-1>=1) change(1,1,1,n,m,x2+1,y1-1,val);
                } else if(x1>X&&y1>Y) {/*右下角*/
                    change(1,1,1,n,m,x1,y1,val);
                    if(y2+1<=m) change(1,1,1,n,m,x1,y2+1,-val);
                    if(x2+1<=n) change(1,1,1,n,m,x2+1,y1,-val);
                    if(x2+1<=n&&y2+1<=m) change(1,1,1,n,m,x2+1,y2+1,val);
                }
            }
        }
    }
    return 0;
}
```
完结散花QWQ

---

## 作者：huangjizuo (赞：0)

一种没有充分利用差分性质的瞎搞做法。

题意：查询二维区间最大公约数，支持整个区间加上某个常数的修改。

由于 $\mathrm{gcd}$ 本身满足结合律交换律，最自然的想法就是做区间加的时候把 $\mathrm{gcd}$ 顺便维护出来，就跟做区间加顺便维护 $\mathrm{sum}$ 一样。

那么我们考虑如果整个集合 $\{a_1, a_2, a_3, ..., a_n\}$ 整体加上一个数，它的 $\mathrm{gcd}$ 会怎么变化。首先看两个数的情形：假设 $a_1<a_2$，那么整体加上一个数，它的 $\mathrm{gap}=a_2-a_1$ 是不会受区间加影响的，并且它给出了 $\mathrm{gcd}$ 的上界，如果 $a_1$ 平移到 $\mathrm{gap}$ 的整数倍，就能取到上界，更一般的，$\mathrm{gcd} = \mathrm{gcd}(\mathrm{gap}, a_1)$。接着我们回到 $n$ 个数，并定义：
$$\mathrm{gap} = \mathrm{gcd}(\{a_i-a_j | 1 \leq i, j \leq n\}),$$
则整体 $\mathrm{gcd}$ 仍然是 $\mathrm{gcd}(\mathrm{gap}, a_1)$，这里的 $a_1$ 可以换成任意一个元素，比如说集合的 $\mathrm{min}$。注意到 $\mathrm{gap}$ 仍然是不受整体平移的影响的。因此问题转化为维护区间的 $\mathrm{gap}$ 和 $\mathrm{min}$。

假设现在有两个集合 $L$ 和 $R$，已知 $\mathrm{gap}_L, \mathrm{gap}_R, \mathrm{min}_L, \mathrm{min}_R$，那么对于 $S = L \cup R$，我们有：
$$\mathrm{gap}_S=\mathrm{gcd}(\mathrm{gap}_L, \mathrm{gap}_R, |\mathrm{min}_L-\mathrm{min}_R|).$$
上式可理解为从集合 $L$ 和集合 $R$ 中各自任取一项相减，再合并上两个集合各自的 $\mathrm{gap}$，就能表示全集的 $\mathrm{gap}$。由于 $\mathrm{min}$ 是显然可以维护并支持区间加法的，所以 $\mathrm{gap}$ 也能顺带维护出来，进而求出 $\mathrm{gcd}$。

这样做比差分数组差在修改和查询都是区间运算，没法用二维线段树，只能上四叉树，不过本题貌似不卡四叉树。

---


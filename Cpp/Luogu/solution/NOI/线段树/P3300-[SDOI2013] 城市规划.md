# [SDOI2013] 城市规划

## 题目描述

A 市的市长打算在海边开发一段地带。这个地带看成是一个 $N \times M $ 的方格阵。每个格子可以是建筑、道路或者草地。这片地带是要出租给某些公司，但是这些公司的要求很奇怪。他们要求租给他们的建筑要通过道路形成一个连通块。同一个连通块只能租给一家公司。这个 $N\times M$ 的方格阵是用字符组成的：`O`，`.`，`+`，`|`，`-`，其中 `O` 表示建筑，'.' 表示草地。`|`，`-`，`+` 表示道路，分别表示把上下，左右、上下左右的格子连起来。相邻的 `O` 表示这是一个建筑物。

由于规划可能不太好，可能某些连通块里面只有道路，这里道路是不能出租的！由于最后这块地的选取可能有部分会与其他市共冋开发，所以最后会在这个 $N\times M$ 中选取一段出来，最后选取出来的是一个 $N_i\times M$（$0<N_1\le N$）的地段。A 市的市长想弄要一个规划软件，支持以下功能：

1. 改变一个格子。
2. 询问某块地带有多少个带建筑的连通块。

## 说明/提示

对于 $100\%$ 的数据，$N\le 100000, M\le 6, Q\le 10000$。


## 样例 #1

### 输入

```
4  4
.O..
O+O|
.O.. 
..OO
4
Q 1 4
C 2 4 + 
C 3 4 | 
Q 1 4```

### 输出

```
2 
1```

# 题解

## 作者：gongbangrui (赞：13)


解法：
------------
题目有个条件，就是m<=6，于是启发我们可以按照行建立数据结构，由于列很少可以快速维护行与行之间的信息。稍加思考发现线段树是可行的。维护行与行之间的关系也很简单，只要通过并查集来实现，如果不会可以去做做[wc2005]双面棋盘这道题。

这题的一个细节是，如果只有道路的连通块是不能算进答案的，所以实现时加一个布尔数组判断这个连通块内是否有‘O’。这题的思维难度一般，主要考察实现能力和代码细心。。

最后还要orz Xietutu。。一开始连通的条件理解错，连暴力都wa了。~~后来是某大佬告诉我正确的理解。我太弱了...~~

AC代码
------------

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn=100003;
struct node
{
    int sum,u[7],d[7];
    bool avld[7],avlu[7];
}tree[maxn*4];
int n,m,fa[100],lab[100],cnt[100];
bool flag[100];
char a[maxn][7];
 
inline int get()
{
    int f=0,v=0;char ch;
    while(!isdigit(ch=getchar()))if(ch=='-')break;
    if(ch=='-')f=1;else v=ch-48;
    while(isdigit(ch=getchar()))v=v*10+ch-48;
    if(f==1)return -v;else return v;
}
inline void write(int x)
{
    int _=x,len=0,p[20];
    if(_<0)putchar('-'),_=-_;
    while(_)p[++len]=_%10,_/=10;
    if(!x)p[++len]=0;
    while(len)putchar(p[len--]+'0');
}
inline void writeln(int x)
{
    write(x);puts("");
}
inline bool check(const char &a,const char &b,const char &c) 
{
    return (a=='O'||a==c||a=='+')&&(b=='O'||b==c||b=='+');
}
inline void init(int p,int x)
{
    tree[p].sum=0;
    for(int i=1;i<=m;i++)tree[p].u[i]=tree[p].d[i]=tree[p].avld[i]=tree[p].avlu[i]=0;
    int tot=0;
    for(int i=1,j;i<=m;i++)
    {
        if(a[x][i]=='.')continue;
        bool avl=0;
        for(j=i;j<m&&check(a[x][j],a[x][j+1],'-');j++);
        for(int k=i;k<=j&&!avl;k++)avl|=a[x][k]=='O';
        ++tot;
        for(int k=i;k<=j;k++)tree[p].u[k]=tree[p].d[k]=tot,tree[p].avld[k]=tree[p].avlu[k]=avl;
        tree[p].sum+=int(avl);
        i=j;
    }
}
 
inline int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
 
inline void merge(node &x,const node &ls,const node &rs,const int &l,const int &r,const int &mid)
{
    x.sum=ls.sum+rs.sum;
    for(int i=1;i<=m;i++)x.u[i]=x.d[i]=x.avld[i]=x.avlu[i]=0;
    for(int i=1;i<=4*m;i++)fa[i]=i,lab[i]=0,flag[i]=0;
    for(int i=1;i<=m;i++)
    {
        if(ls.d[i])cnt[ls.d[i]]=ls.avld[i],flag[ls.d[i]]=1;
        if(rs.u[i])cnt[rs.u[i]+2*m]=rs.avlu[i],flag[rs.u[i]+2*m]=1;;
        if(ls.u[i])cnt[ls.u[i]]=ls.avlu[i];
        if(rs.d[i])cnt[rs.d[i]+2*m]=rs.avld[i];
    }
    for(int i=1;i<=m;i++)
    {
        if(!check(a[mid][i],a[mid+1][i],'|'))continue;
        int fx=getfa(ls.d[i]),fy=getfa(rs.u[i]+2*m);
        if(fx!=fy)fa[fx]=fy,cnt[fy]+=cnt[fx];
    }
    for(int i=1;i<=m*4;i++)
        if(flag[i]&&fa[i]==i&&cnt[i]>0)x.sum-=cnt[i]-1;
    for(int i=1,tot=0;i<=m;i++)
    {
        int fx;
        if(ls.u[i])
        {
            fx=getfa(ls.u[i]);
            if(!lab[fx])lab[fx]=++tot;
            x.u[i]=lab[fx],x.avlu[i]=cnt[fx];
        }
        if(rs.d[i])
        {
            fx=getfa(rs.d[i]+2*m);
            if(!lab[fx])lab[fx]=++tot;
            x.d[i]=lab[fx],x.avld[i]=cnt[fx];
        }
    }
}
 
inline void build(int p,int l,int r)
{
    if(l==r){init(p,l);return;}
    int mid=(l+r)/2;
    build(p*2,l,mid),build(p*2+1,mid+1,r);
    merge(tree[p],tree[p*2],tree[p*2+1],l,r,mid);
}
 
inline node ask(int p,int l,int r,int a,int b)
{
    if(a<=l&&r<=b)return tree[p];
    int mid=(l+r)/2;node res;
    if(b<=mid)res=ask(p*2,l,mid,a,b);
    else if(a>mid)res=ask(p*2+1,mid+1,r,a,b);
    else merge(res,ask(p*2,l,mid,a,mid),ask(p*2+1,mid+1,r,mid+1,b),a,b,mid);
    return res;
}
 
inline void modify(int p,int l,int r,int num)
{
    if(l==r){init(p,l);return;}
    int mid=(l+r)/2;
    if(num<=mid)modify(p*2,l,mid,num);else modify(p*2+1,mid+1,r,num);
    merge(tree[p],tree[p*2],tree[p*2+1],l,r,mid);
}
 
int main()
{
    n=get(),m=get();
    for(int i=1;i<=n;i++)scanf("%s",a[i]+1);
    build(1,1,n);
    int Q=get();
    while(Q--)
    {
        char ch;while(!isalpha(ch=getchar()));
        int x=get(),y=get();node res;
        if(ch=='C')
        {
            scanf(" %c",&a[x][y]);
            modify(1,1,n,x);
        }else res=ask(1,1,n,x,y),writeln(res.sum);
    }
    return 0;
}

```

---

## 作者：fush (赞：3)

我们注意一下数据范围：$m \le 6$。  
这明显是一个很有用的性质。由于列很少，我们可以快速维护行与行之间的信息。  
题目里还有对行区间操作，且符合结合律，就差直接告诉你是**线段树**了。

而维护行与行之间的关系也很简单，判断联通块可以用**并查集**来维护。  
具体的 `merge` 操作可以看代码。

需要注意的一点：**如果只有道路的连通块是不能算进答案的**。
所以实现时加一个布尔数组判断这个连通块内是否有 `O`。
```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
#define eb emplace_back
#define ldb long double
#define ll long long
#define sgindex(l, r) ((l)+(r)|(l)!=(r))
#define rt sgindex(l,r)
#define ls sgindex(l,sgm)
#define rs sgindex(sgm+1,r)
#define sgm ((l)+(r)>>1)
constexpr int N = 1e5 + 10;
char mp[N][10], op;
struct sgs{
	int ans, ufa[10], dfa[10];
	bool uf[10], df[10];
}sg[N << 1];
int fa[N], cnt[N], vis[N], n, m;
int find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}
bool check(char&a, char&b, char c){return(a=='O'||a==c||a=='+')&&(b=='O'||b==c||b=='+');}
void init(int l, int r){
	sgs&u = sg[rt];
	u.ans = 0;
	FL(i, 1, m)u.ufa[i] = u.dfa[i] = u.uf[i] = u.df[i] = 0;
	int j, tot = 0;
	FL(i, 1, m){
		if(mp[l][i] == '.')continue;
		bool f = 0;
		for(j = i, ++tot; j < m && check(mp[l][j], mp[l][j + 1], '-'); ++j)f |= (mp[l][j] == 'O');
		f |= (mp[l][j] == 'O');
		FL(k, i, j)u.ufa[k] = u.dfa[k] = tot, u.uf[k] = u.df[k] = f;
		u.ans += f, i = j;
	}
}
sgs merge(sgs a, sgs b, int p){
	sgs u;
	u.ans = a.ans + b.ans;
	int tot = 0, x;
	FL(i, 1, m << 2)fa[i] = i, cnt[i] = vis[i] = 0;
	FL(i, 1, m)u.df[i] = u.uf[i] = u.dfa[i] = u.ufa[i] = 0;
	FL(i, 1, m){
		if(a.dfa[i])cnt[a.dfa[i]] = a.df[i], vis[a.dfa[i]] = 1;
		if(b.ufa[i])cnt[b.ufa[i] + 2 * m] = b.uf[i], vis[b.ufa[i] + 2 * m] = 1;
		if(a.ufa[i])cnt[a.ufa[i]] = a.uf[i];
		if(b.dfa[i])cnt[b.dfa[i] + 2 * m] = b.df[i];
	}
	FL(i, 1, m){
		if(!check(mp[p][i], mp[p + 1][i], '|'))continue;
		int x = find(a.dfa[i]), y = find(b.ufa[i] + 2 * m);
		if(x != y)fa[x] = y, cnt[y] += cnt[x];
	}
	FL(i, 1, m << 2)if(vis[i] && fa[i] == i && cnt[i] > 1)u.ans -= cnt[i] - 1;
	memset(vis, 0, (sizeof*vis) * (m * 4 + 4));
	FL(i, 1, m){
		if(a.ufa[i])
			x = find(a.ufa[i]), (!vis[x]) && (vis[x] = ++tot), 
			u.ufa[i] = vis[x], u.uf[i] = cnt[x];
		if(b.dfa[i])
			x = find(b.dfa[i] + 2 * m), (!vis[x]) && (vis[x] = ++tot),
			u.dfa[i] = vis[x], u.df[i] = cnt[x];
	}
	return u;
}
void build(int l, int r){
	if(l == r)return init(l, r);
 	build(l, sgm), build(sgm + 1, r);
	sg[rt] = merge(sg[ls], sg[rs], sgm);
}
void modify(int l, int r, int pos){
	if(l == r)return init(l, r);
	if(pos <= sgm)modify(l, sgm, pos);
	else modify(sgm + 1, r, pos);
	sg[rt] = merge(sg[ls], sg[rs], sgm);
}
sgs query(int l, int r, int L, int R){
	if(L <= l && r <= R)return sg[rt];
	if(R <= sgm)return query(l, sgm, L, R);
	if(sgm < L)return query(sgm + 1, r, L, R);
	return merge(query(l, sgm, L, R), query(sgm + 1, r, L, R), sgm);
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int q, l, r;
	cin >> n >> m;
	FL(i, 1, n)FL(j, 1, m)cin >> mp[i][j];
	build(1, n), cin >> q;
	while(q--){
		cin >> op >> l >> r;
		if(op == 'C')cin >> mp[l][r], modify(1, n, l);
		else cout << query(1, n, l, r).ans << endl;
	}
	return 0;
}
```

---

## 作者：xuantianhao (赞：2)

# [[SDOI2013] 城市规划](https://www.luogu.com.cn/problem/P3300)

题意：给你一个 $6 \times n$ 的网格题，单点修改，询问区间联通块数，$n \le 10^5$。

解：看起来就很显然的一道题......线段树每个点用一个 ufs 维护连通性；

我为了方便思考把图转成横着的了。

~~写起来真是毒瘤......~~

重点在于：

$\bullet$ 1、建立叶节点。

$\bullet$ 2、合并两个子节点。

$\bullet$ **3、把新的并查集的中间两列压掉。**

第一步，这个就直接枚举 $merge$ 就完事了。

第二步，把两个 2 列的子并查集复制到当前节点的 4 列的并查集上。注意右边那个并查集，$fa$ 全部要加 $2m$，因为下标加了 $2m$。

然后枚举中间两列 $merge$。这样也做完了。

第三步，我们只要保留两边的两列即可。注意到有可能有两边元素的代表元在中间，我们使用左偏树技巧，切换代表元到它自己，注意 $vis$ 也要变。

然后把两边的 $vis$ 和 $fa$ 复制一份出来，用以查询代表元。

然后把前两列 init，然后枚举每个元素，跟它的代表元 $merge$。注意这一步会对连通块总数 tot 造成改变，最后复原即可。

最后把前两列的 $vis$ 和 $lk$ 从复制的那里拿来用即可。

注意 $vis$（当前联通块是否有建筑物）要继承代表元的，$lk$（能否与两边连通）直接从对应下标继承，这两个不一样！

具体实现看代码吧......

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ck(x) ((x)=='|'||(x)=='+')
const int N=1e5+100;
const int M=24;
int n,m,q,x,y;
char c[2];
int exfa[M],exvis[M],exlk[M];
inline int read(){
	char c=getchar();int f=1,x=0;
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int exfind(int x){
	if(exfa[x]==x) return x;
	else return exfa[x]=exfind(exfa[x]);
}
inline int trans(int x){
	return x<m?x:x-(m<<1);
}
struct node{
	int fa[M],tot;
	bitset<M> lk,vis;
	int find(int x){
		if(fa[x]==x) return x;
		else return fa[x]=find(fa[x]);
	}
	inline void merge(int x,int y){
		int fx=find(x),fy=find(y);
		if(fx==fy) return ;
		fa[fy]=fx;
		tot-=(vis[fx]&&vis[fy]);
		if(vis[fy]) vis.set(fx);
		return ;
	}
	node(){}
	node(char *a){
		tot=0;
		for(int i(0);i<m;i++){
			fa[i+m]=fa[i]=i;
			if(a[i]=='O'){
				vis.set(i);
				vis.set(i+m);
				lk.set(i);
				lk.set(i+m);
				++tot;
			}else if(a[i]=='.'){
				vis.reset(i);
				vis.reset(i+m);
				lk.reset(i);
				lk.reset(i+m);
			}else if(a[i]=='-'||a[i]=='+'){
				vis.reset(i);
				vis.reset(i+m);
				lk.set(i);
				lk.set(i+m);
			}
		}
		for(int i(1);i<m;i++){
			if(ck(a[i-1])&&ck(a[i])) merge(i-1,i);
			else if((ck(a[i-1])&&a[i]=='O')||(ck(a[i])&&a[i-1]=='O')) merge(i-1,i);
			else if(a[i]=='O'&&a[i-1]=='O') merge(i-1,i);
		}
	}
	inline void update(){
		for(int i(0);i<m;i++){
			int t(find(i));
			fa[i]=fa[t]=i;
			vis[i]=vis[t];
			t=find(i+3*m);
			fa[i+3*m]=fa[t]=i+3*m;
			vis[i+3*m]=vis[t];
		}
		memcpy(exfa,fa,sizeof(fa));
		for(int i(0);i<m;i++){
			exvis[i]=vis[i];
			exvis[i+3*m]=vis[i+3*m];
			exlk[i]=lk[i];
			exlk[i+3*m]=lk[i+3*m];
		}
		int temp=tot;
		for(int i(0);i<m;i++){
			fa[i]=i;
			fa[i+m]=i+m;
		}
		for(int i(0);i<m;i++){
			merge(i,trans(exfind(i)));
			merge(i+m,trans(exfind(i+3*m)));
		}
		for(int i(0);i<m;i++){
			vis[i]=exvis[exfind(i)];
			vis[i+m]=exvis[exfind(i+m*3)];
			lk[i]=exlk[i];
			lk[i+m]=exlk[i+m*3];
		}
		tot=temp;
		return ;
	}
	inline node merge(const node &w)const{
		node ans;
		for(int i(0);i<m;i++){
			ans.fa[i]=fa[i];
			ans.lk[i]=lk[i];
			ans.vis[i]=vis[i];
			ans.fa[i+m]=fa[i+m];
			ans.lk[i+m]=lk[i+m];
			ans.vis[i+m]=vis[i+m];
			ans.fa[i+2*m]=w.fa[i]+2*m;
			ans.lk[i+2*m]=w.lk[i];
			ans.vis[i+2*m]=w.vis[i];
			ans.fa[i+3*m]=w.fa[i+m]+2*m;
			ans.lk[i+3*m]=w.lk[i+m];
			ans.vis[i+3*m]=w.vis[i+m];
		}
		ans.tot=tot+w.tot;
		for(int i(0);i<m;i++){
			if(ans.lk[i+m]&&ans.lk[i+2*m]){
				ans.merge(i+m,i+2*m);
			}
		}
		ans.update();;
		return ans;
	}
}tr[N<<2];
char str[N][6];
void build(int l,int r,int now){
	if(l==r){
		tr[now]=node(str[r]);
		return ;
	}
	int mid=(l+r)>>1;
	build(l,mid,now<<1);
	build(mid+1,r,now<<1|1);
	tr[now]=tr[now<<1].merge(tr[now<<1|1]);
	return ;
}
void change(int p,int l,int r,int now){
	if(l==r){
		tr[now]=node(str[r]);
		return ;
	}
	int mid=(l+r)>>1;
	if(p<=mid) change(p,l,mid,now<<1);
	else change(p,mid+1,r,now<<1|1);
	tr[now]=tr[now<<1].merge(tr[now<<1|1]);
	return ;
}
node get_sum(int x,int y,int l,int r,int now){
	if(x<=l&&y>=r) return tr[now];
	int mid=(l+r)>>1;
	if(y<=mid) return get_sum(x,y,l,mid,now<<1);
	if(mid<x) return get_sum(x,y,mid+1,r,now<<1|1);
	node temp(get_sum(x,y,l,mid,now<<1));
	temp=temp.merge(get_sum(x,y,mid+1,r,now<<1|1));
	return temp; 
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		scanf("%s",str[i]);
		for(int j=0;j<m;j++){
			if(str[i][j]=='-') str[i][j]='|';
			else if(str[i][j]=='|') str[i][j]='-';
		}
	}
	build(1,n,1);
	q=read();
	while(q--){
		scanf("%s",c);
		x=read();y=read();
		if(c[0]=='C'){
			scanf("%s",c);
			if(c[0]=='-') c[0]='|';
			else if(c[0]=='|') c[0]='-';
			str[x][y-1]=c[0];
			change(x,1,n,1);
		}else{
			node temp=get_sum(x,y,1,n,1);
			printf("%d\n",temp.tot);
		}
	}
	return 0;
}
```



（ PS :一开始没开 O2 的时候 TLE 了，只有 50 分，吸氧以后才过的，~~希望哪位 dalao 可以找到更好的思路~~）

---

## 作者：Union_Find (赞：1)

注意到，题目中的 $m \leq 6$ 的条件，加上这是一道单点修改，区间查询，考虑对 $n$ 这一维进行线段树。

线段树最麻烦的是合并信息，要考虑应该维护什么。这题与连通性相关，我们可以对每个结点的左右两端，建立并查集，并存储该连通块内是否有建筑。

可以先让初始答案为两个儿子答案之和，将两个儿子的左右端点都先存下来，然后用并查集合并。当合并左儿子右端点和右儿子左端点时，如果两个还未合并且都包含建筑物，答案减 $1$ 并合并。

只要会了合并，线段树的修改和查询就很简单，就不说了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define N 100005
#define M 28 
il int rd(){
	int s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
int n, m, x, y, fa_p[M], t_p_1[M], t_p_2[M], son[M];
// fa_p 和 t_p_2 是临时数组，son 是在每次合并时如果祖先编号超过了 m*2 时用比 m*2 小的编号代替 （编号含义见下） 
char s[N][M], op;
il bool check(char s1, char s2, int k){
	if (s1 == '.' || s2 == '.') return 0;
	if (k) return (s1 != '-' && s2 != '-');
	else return (s1 != '|' && s2 != '|');
}
struct ST{
	int ans, fa[M], t[M];// fa 是并查集，t 是是否建筑物 
	char s[M][2];
	ST(){
		ans = 0;
		for (int i = 1; i <= m + m; i++) fa[i] = i, t[i] = 0;
	}il int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}
	il bool merge(int u, int v){
		int fu = find(u), fv = find(v);
		if (fu != fv){
			bool flag = t[fu] && t[fv];
			fa[fu] = fv, t[fv] |= t[fu], t[fu] = 0;
			return flag;
		}return 0;
	}
}tr[N << 2];
ST operator + (const ST &x, const ST &y){
	ST ans, a = x, b = y;
	ans.ans = a.ans + b.ans;
	for (int i = 1; i <= m; i++){
		ans.fa[i] = a.fa[i] <= m ? a.fa[i] : a.fa[i] + m, ans.t[i] = a.t[i];
		ans.fa[i + m] = b.fa[i + m] > m ? b.fa[i + m] : b.fa[i + m] + m * 3, ans.t[i + m] = b.t[i + m];
		ans.fa[i + m * 2] = a.fa[i + m] > m ? a.fa[i + m] + m : a.fa[i + m], ans.t[i + m * 2] = a.t[i + m];
		ans.fa[i + m * 3] = b.fa[i] <= m ? b.fa[i] + m * 3 : b.fa[i], ans.t[i + m * 3] = b.t[i];
	}// 编号 1-m 是左儿子左端点，m-m*2 是 右儿子右端点， m*2-m*3 是左儿子右端点， m*3-m*4 是右儿子左端点 
	for (int i = 1; i <= m; i++) ans.s[i][0] = a.s[i][0], ans.s[i][1] = b.s[i][1];
	for (int i = 1; i <= m; i++) if (check(a.s[i][1], b.s[i][0], 1) && ans.merge(i + m * 2, i + m * 3)) ans.ans--;// 修改答案 
	for (int i = 1; i <= m + m + m + m; i++) t_p_1[i] = t_p_2[i] = son[i] = 0; 
	for (int i = 1; i <= m + m; i++){
		int fu = ans.find(i);
		t_p_1[fu] = ans.t[fu], son[fu] = i;// 将根节点用编号小的代替，并存储是否有建筑 
	}for (int i = 1; i <= m + m; i++) fa_p[i] = son[ans.find(i)];// 替换根节点的同时路径压缩 
	for (int i = 1; i <= m + m + m + m; i++) if (t_p_1[i]) t_p_2[son[i]] = 1;
	for (int i = 1; i <= m + m; i++) ans.fa[i] = fa_p[i], ans.t[i] = t_p_2[i];
	return ans;
}
il ST init(int x){//初始化线段树叶子节点 
	ST a;
	for (int i = 1; i <= m; i++) a.fa[a.find(i)] = a.find(m + i);
	for (int i = 1; i < m; i++) if (check(s[x][i], s[x][i + 1], 0)) a.fa[a.find(i)] = a.find(i + 1);
	for (int i = 1; i < m; i++) if (check(s[x][i], s[x][i + 1], 0)) a.fa[a.find(m + i)] = a.find(m + i + 1);
	for (int i = 1; i <= m; i++){
		a.s[i][0] = a.s[i][1] = s[x][i];
		if (s[x][i] == 'O') a.t[a.find(i)] = 1;
	}for (int i = 1; i <= m + m; i++) if (a.fa[i] == i && a.t[i]) a.ans++;
	return a;
}
void build(int p, int l, int r){
	if (l == r) return tr[p] = init(l), void(0); 
	int mid = (l + r) >> 1;
	build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
	tr[p] = tr[p << 1] + tr[p << 1 | 1];
}void add(int p, int l, int r, int x, int y, char k){
	if (l == r) return tr[p] = init(l), void(0);
	int mid = (l + r) >> 1;
	if (x <= mid) add(p << 1, l, mid, x, y, k);
	else add(p << 1 | 1, mid + 1, r, x, y, k);
	tr[p] = tr[p << 1] + tr[p << 1 | 1];
}ST ask(int p, int l, int r, int nl, int nr){
	if (nl <= l && r <= nr) return tr[p];
	int mid = (l + r) >> 1;
	ST ans;
	if (nl <= mid) ans = ask(p << 1, l, mid, nl, nr);
	if (nr > mid){
		if (nl <= mid) ans = ans + ask(p << 1 | 1, mid + 1, r, nl, nr);
		else ans = ask(p << 1 | 1, mid + 1, r, nl, nr);
	}return ans;
}
int main(){
	n = rd(), m = rd();
	for (int i = 1; i <= n; i++) scanf ("%s", s[i] + 1);
	build(1, 1, n);
	for (int T = rd(); T--;){
		scanf ("%s", &op);
		x = rd(), y = rd();
		if (op == 'C') scanf ("%s", &op), s[x][y] = op, add(1, 1, n, x, y, op);
		else printf ("%d\n", ask(1, 1, n, x, y).ans);
	}
	return 0;
}

```

---

## 作者：XiaoZi_qwq (赞：0)

# P3300 [SDOI2013] 城市规划
## 分析题意  
首先我们需要理解**连通**这个概念。有两种情况被称为“连通”：  
- 对于**同一列的**相邻的两个格子，它们都是“+”，“|”或“O”三者之一；
- 对于**同一行的**相邻的两个格子，它们都是“+”，“-”或“O”三者之一；

然后我们看到本题需要维护连通块，因此可以考虑使用**并查集**维护连通块。  
其次，让我们关注询问区间 $(l,1)(r,M)$，这等价于询问第 $l$ 行到第 $r$ 行，因此我们可以考虑到把每一行看做一个整体进行处理。  
最后，让我们看到数据范围：$N \leq 10^5$ 且 $M \leq 6$。是熟悉的 $10^5$，再结合区间查询，让我们想到**线段树**。
## 算法分析  
在思考怎么使用线段树时，我们会遇到一个问题：怎么合并子节点信息？  
结合我们之前学过的“用线段树求最大子段和”，我们可以想到我们只需要处理**两个儿子相邻的两行**就可以了。  
对于这两行（第 $i$ 行和第 $i+1$ 行），如果 $(i,j)$ 和 $(i+1,j)$ 是连通的，那么我们就要用并查集合并这两个连通块，同时**维护权值**（如果被合并的两个连通块都有建筑，那么合并后总权值应该减一，因为这两个连通块在各自节点都被统计过）。  
这里有一个问题：在合并后，由部分并查集的根节点并不在最上和最小这两行。我们可以**将并查集的根节点转移到这两行上的点**来解决问题（详见代码）。  
其余的查询和修改与正常的线段树一样，不再赘述。  
  _**“talk is cheap,show me the code”**_ 
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls (i<<1)
#define rs (i<<1|1)
#define inf 0x3f3f3f3f
using namespace std;
typedef long long ll;
inline int read(){
  register int x=0;
  char c=getchar();
  while(c<'0' || '9'<c) c=getchar();
  while('0'<=c && c<='9') x=(x<<1)+(x<<3)+c-'0',c=getchar();
  return x;
}
const int N=1e5+1000,M=8;
int n,m,q,p[N][M];
//连通性判断
bool able_x(int val){return val==0 || val==1 || val==3;}
bool able_y(int val){return val==0 || val==1 || val==2;}
struct Data{
  int l,r,f[M<<2],cnt;
  bool have[M<<2];
  int find(int x){return f[x]=(f[x]==x)?x:find(f[x]);}
  bool Union(int x,int y){//合并联通块，返回值为真当且仅当 合并成功且合并的两个联通块都有建筑
    int fx=find(x),fy=find(y);
    if(fx==fy) return false;
    bool res=(have[fx] && have[fy]);
    f[fx]=fy;
    have[fy]|=have[fx];
    return res;
  }
  Data(int x=0){
    l=r=x,cnt=0;
    for(int i=1;i<=2*m;i++) f[i]=i,have[i]=0;
    for(int i=1;i<=m;i++)
      have[i]=(!p[x][i]),Union(i+m,i);
    for(int i=1;i<m;i++)
      if(able_x(p[x][i]) && able_x(p[x][i+1]))
        Union(i,i+1);
    for(int i=1;i<=2*m;i++)
      if(f[i]==i && have[i])
        cnt++;
  }
};
int rk[M<<2],nwf[M<<2],nwhave[M<<2];
Data Merge(Data a,Data b){
  Data ans;
  ans.cnt=a.cnt+b.cnt;
  ans.l=a.l,ans.r=b.r;
  for(int i=1;i<=m;i++){//继承两个儿子的所有并查集 和 每个并查集是否有建筑
    //[1,m] 左儿子左侧 [m+1,2m] 右儿子右侧 [2m+1,3m] 左儿子右侧 [3m+1,4m] 右儿子左侧
    ans.f[i]     = a.f[i]  <=m ? a.f[i]       : a.f[i]+m;
    ans.f[i+m]   = b.f[i+m]<=m ? b.f[i+m]+3*m : b.f[i+m];
    ans.f[i+2*m] = a.f[i+m]<=m ? a.f[i+m]     : a.f[i+m]+m;
    ans.f[i+3*m] = b.f[i]  <=m ? b.f[i]+3*m   : b.f[i];
    ans.have[i]     = a.have[i];
    ans.have[i+m]   = b.have[i+m];
    ans.have[i+2*m] = a.have[i+m];
    ans.have[i+3*m] = b.have[i];
  }
  for(int i=1;i<=m;i++)
    if(able_y(p[a.r][i]) && able_y(p[b.l][i]))
      ans.cnt+= ans.Union(i+2*m,i+3*m) ? -1 : 0;
  memset(rk,0,sizeof(rk));
  for(int i=1,u;i<=2*m;i++)//找到每一个并查集的根节点，并准备将根节点转移到 在该并查集的 且位于两侧的任意一个节点(rk[u])
    u=ans.find(i),rk[u]=i;
  for(int i=1;i<=2*m;i++)//这个地方不能直接修改并查集！！！ 因为我们仍需要利用旧的并查集去查找原根节点
    nwf[i]=rk[ans.find(i)],nwhave[i]=0;
  for(int i=1;i<=4*m;i++)//这个地方就可以直接修改，因为之后的操作就和原并查集无关了
    if(rk[i])
      ans.have[rk[i]]=ans.have[i];
  for(int i=1;i<=2*m;i++)
    ans.f[i]=nwf[i];
  return ans;
}
struct Tree{int l,r;Data val;}t[N<<2];
void push_up(int i){t[i].val=Merge(t[ls].val,t[rs].val);}
void build(int i,int l,int r){
  t[i].l=l,t[i].r=r;
  if(l==r){
    t[i].val=Data(l);
    return;
  }
  int mid=l+r>>1;
  build(ls,l,mid);
  build(rs,mid+1,r);
  push_up(i);
}
Data query(int i,int l,int r){
  if(l<=t[i].l && t[i].r<=r)
    return t[i].val;
  int mid=t[i].l+t[i].r>>1;
  if(l>mid) return query(rs,l,r);
  if(mid>=r) return query(ls,l,r);
  return Merge(query(ls,l,r),query(rs,l,r));
}
void update(int i,int x){
  if(t[i].l==t[i].r){
    t[i].val=Data(x);
    return;
  }
  int mid=t[i].l+t[i].r>>1;
  if(x<=mid) update(ls,x);
  else update(rs,x);
  push_up(i);
}
char s[10],c;
int main(){
  n=read(),m=read();
  memset(p,inf,sizeof(p));
  for(int i=1;i<=n;i++){
    scanf("%s",s+1);
    for(int j=1;j<=m;j++){
      c=s[j];
      if(c=='O') p[i][j]=0;
      if(c=='+') p[i][j]=1;
      if(c=='|') p[i][j]=2;
      if(c=='-') p[i][j]=3;
      if(c=='.') p[i][j]=4;
    }
  }
  build(1,1,n);
  q=read();
  char opt[3];
  for(int i=1,l,r;i<=q;i++){
    scanf("%s",opt),l=read(),r=read();
    if(opt[0]=='Q')
      printf("%d\n",query(1,l,r).cnt);
    else{
      scanf("%s",opt);
      if(opt[0]=='O') p[l][r]=0;
      if(opt[0]=='+') p[l][r]=1;
      if(opt[0]=='|') p[l][r]=2;
      if(opt[0]=='-') p[l][r]=3;
      if(opt[0]=='.') p[l][r]=4;
      update(1,l);
	  }
  }
  return 0;
}
```

---

## 作者：qnqfff (赞：0)

### 思路

考虑线段树，每个节点维护最上面一行和最下面一行的连通块标号和有无 ```O```，合并的时候考虑把左儿子最下面一行和右儿子最上面一行拉出来，用一个并查集维护连通性，最后把合并成功的联通块的贡献减掉就行了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<23],*p1=buf,*p2=buf;
int read(){char c=getchar();int p=0,flg=1;while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,m,q,fa[30],siz[30],vis[30];char mp[100010][10];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){x=find(x);y=find(y);if(x==y) return ;fa[x]=y;siz[y]+=siz[x];}
struct Info{
	int sum,id[10],_id[10],flg[10],_flg[10],U,D;
	Info(){sum=U=D=0;for(int i=1;i<=m;i++) id[i]=_id[i]=flg[i]=_flg[i]=0;}
	Info operator+(Info x){
		Info res;res.sum=sum+x.sum;res.U=U;res.D=x.D;
		for(int i=1;i<=m<<2;i++) fa[i]=i,siz[i]=vis[i]=0;
		for(int i=1;i<=m;i++){if(id[i]) siz[id[i]]=flg[i];if(_id[i]) siz[_id[i]]=_flg[i];if(x.id[i]) siz[x.id[i]+(m<<1)]=x.flg[i];if(x._id[i]) siz[x._id[i]+(m<<1)]=x._flg[i];}
		for(int i=1;i<=m;i++) if((mp[D][i]=='O'||mp[D][i]=='|'||mp[D][i]=='+')&&(mp[x.U][i]=='O'||mp[x.U][i]=='|'||mp[x.U][i]=='+')) merge(_id[i],x.id[i]+(m<<1));
		for(int i=1;i<=m<<2;i++) if(find(i)==i&&siz[i]) res.sum-=siz[i]-1;
		for(int i=1,cnt=0;i<=m;i++){
			if(id[i]){int u=find(id[i]);if(!vis[u]) vis[u]=++cnt;res.id[i]=vis[u];res.flg[i]=siz[u]>0;}
			if(x._id[i]){int u=find(x._id[i]+(m<<1));if(!vis[u]) vis[u]=++cnt;res._id[i]=vis[u];res._flg[i]=siz[u]>0;}
		}return res;
	}
};
struct seg{int l,r;Info x;}t[400010];
#define lson now<<1
#define rson now<<1|1
void build(int now,int l,int r){
	t[now]={l,r};if(l==r){
		t[now].x.U=t[now].x.D=l;for(int i=1,cnt=0;i<=m;i++) if(mp[l][i]^'.'){
			int j=i,f=(mp[l][i]=='O');while(j+1<=m&&(mp[l][j]=='O'||mp[l][j]=='-'||mp[l][j]=='+')&&(mp[l][j+1]=='O'||mp[l][j+1]=='-'||mp[l][j+1]=='+')) j++,f|=(mp[l][j]=='O');
			cnt++;for(int k=i;k<=j;k++) t[now].x.id[k]=t[now].x._id[k]=cnt,t[now].x.flg[k]=t[now].x._flg[k]=f;t[now].x.sum+=f;i=j;
		}return ;
	}int mid=(l+r)>>1;build(lson,l,mid);build(rson,mid+1,r);t[now].x=t[lson].x+t[rson].x;
	 
}
void modify(int now,int x){
	if(t[now].l==t[now].r){
		for(int i=1;i<=m;i++) t[now].x=Info();t[now].x.U=t[now].x.D=x;for(int i=1,cnt=0;i<=m;i++) if(mp[x][i]^'.'){
			int j=i,f=(mp[x][i]=='O');while(j+1<=m&&(mp[x][j]=='O'||mp[x][j]=='-'||mp[x][j]=='+')&&(mp[x][j+1]=='O'||mp[x][j+1]=='-'||mp[x][j+1]=='+')) j++,f|=(mp[x][j]=='O');
			cnt++;for(int k=i;k<=j;k++) t[now].x.id[k]=t[now].x._id[k]=cnt,t[now].x.flg[k]=t[now].x._flg[k]=f;t[now].x.sum+=f;i=j;
		}return ;
	}int mid=(t[now].l+t[now].r)>>1;if(x<=mid) modify(lson,x);else modify(rson,x);t[now].x=t[lson].x+t[rson].x;
}
Info query(int now,int l,int r){
	if(l<=t[now].l&&t[now].r<=r) return t[now].x;
	int mid=(t[now].l+t[now].r)>>1;if(r<=mid) return query(lson,l,r);if(mid<l) return query(rson,l,r);return query(lson,l,r)+query(rson,l,r);
}
signed main(){
	n=read();m=read();for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>mp[i][j];build(1,1,n);
	q=read();while(q--){char opt;cin>>opt;int x=read(),y=read();if(opt=='C'){cin>>mp[x][y];modify(1,x);}else cout<<query(1,x,y).sum<<'\n';}
	return 0;
}
```

---


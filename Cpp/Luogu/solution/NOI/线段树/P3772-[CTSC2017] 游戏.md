# [CTSC2017] 游戏

## 题目描述

小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。

第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。

具体来说：

1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。

2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。

小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。

小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；

有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。

需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。

## 说明/提示

【评分标准】

如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。

如果你的所有答案均为正确，则得满分，否则得 $0$ 分。

请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。


【限制与约定】

对于 $100\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。

对于 $100\%$ 的数据，输入保留最多四位小数。

本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：


 ![](https://cdn.luogu.com.cn/upload/pic/5484.png) 

【小 R 教你学数学】

你可. 能. 会用到以下公式

1. 条件概率的计算方法

我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：

$p(A|B)=\frac {p(AB)}{p(B)}$

其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。

2. 贝叶斯公式 (bayes)

由条件概率的计算方法，我们容易得到贝叶斯公式

$p(A|B)=\frac {p(B|A)p(A)}{p(B)}$

3. 全概率公式

如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\ldots , x_k$ 那么

$p(A)=\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$

 ![](https://cdn.luogu.com.cn/upload/pic/5486.png) 

【温馨提示】

在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。

1. 两个大小相近的数相减可以引入非常大的相对误差。

2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。

当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。

## 样例 #1

### 输入

```
3 3 A
0.3
0.5 0.2
0.9 0.8
add 1 1
add 3 0
del 1```

### 输出

```
2.350000
1.333333
0.432749```

# 题解

## 作者：周子衡 (赞：14)

**前置知识：贝叶斯公式**

设 $A,B$ 是两个随机事件。定义 $P(A|B)$ 为在 $B$ 事件发生的情况下 $A$ 发生的概率。显然有

$P(A|B)=\dfrac{P(AB)}{P(B)}$

同样

$P(B|A)=\dfrac{P(AB)}{P(A)}$

则

$P(A|B)=\dfrac{P(B|A)\times P(A)}{P(B)}$

----------

根据期望的线性性，我们可以单独计算每个未知的局面的获胜概率。设 $x$ 是一个未知局面，显然 $x$ 获胜的概率只与 $x$ 左边的第一个已知局面 $l$ 和右边的第一个已知局面 $r$ 有关。记事件 $X$ 为小 P 在第 $x$ 局中获胜，事件 $L,R$ 为第 $l,r$ 获胜者和已知相符。则欲求为

$P(X|L,R)=\dfrac{P(L,R|X)\times P(X)}{P(L,R)}$

$=\dfrac{P(L|X)P(R|X)P(X)}{P(L,R)}$

$=\dfrac{P(L|X)P(R|X)P(X)}{P(R|L)P(L)}$

$=\dfrac{P(X|L)P(R|X)}{P(R|L)}$

此时分母是一个定值，在求和的时候可以提出维护。换句话说，

$\sum_{l < x <r}\dfrac{P(X|L)P(R|X)}{P(R|L)}=\dfrac{\sum_{l < x <r}P(X|L)P(R|X)}{P(R|L)}$

分母可以用线段树维护矩阵乘法预处理出——对于每个点维护一个 $2\times 2$ 矩阵 $F_i$，$F(0,0)=1-q_i,F(0,1)=q_i,F(1,0)=1-p_i,F(1,1)=p_i$。容易验证 这样乘起来符合组合意义。

至于分子，$P(X|L)P(R|X)$ 可以理解为从 $l$ 到 $r$ 进行矩阵乘法时，在 $x$ 处只乘 $F_x$ 中第二维为 $1$ 的元素。换言之构造另一个矩阵 $G_x$，$G(0,0)=G(1,0)=0$，要求则变成 $\sum_{x=l}^rF_l\times F_{l+1}\times \cdots\times F_{x-1}\times G_x\times \cdots\times F_r$。这个也可以在线段树上维护，每次维护一个区间的 $G$ 矩阵，对于每个节点 $k$，有

$G_k=G_{l(k)}\times F_{r(k)}+F_{l(k)}\times F_{r(k)}$

（$l(k),r(k)$ 分别代表 $k$ 的左右子节点）

这样就大致解决了这道题。关于实现细节，可以开一个 set 维护所有已知的位置。

代码：
```cpp
#include<cstdio>
#include<set>

using namespace std;

double p[300000],q[300000];

struct mat
{
	int r,c;double val[2][2];
	double* operator[](int x){return val[x];}
	const double* operator[](int x)const{return val[x];}
	mat(int rr=2,int cc=2):r(rr),c(cc){for(int i=0;i<2;i++)for(int j=0;j<2;j++)val[i][j]=0;} 
};
mat operator+(mat a,mat b){for(int i=0;i<a.r;i++)for(int j=0;j<a.c;j++)a[i][j]+=b[i][j];return a;}
mat operator*(mat a,mat b)
{
	mat c(a.r,b.c);
	for(int i=0;i<a.r;i++)
	{
		for(int j=0;j<b.c;j++)
		{
			for(int k=0;k<a.c;k++)
			{
				c[i][j]+=a[i][k]*b[k][j];
			}
		}
	}
	return c; 
}

struct dat
{
	mat sum,pri;
};
dat operator*(const dat& a,const dat& b)
{
	dat c;c.pri=a.pri*b.pri,c.sum=a.sum*b.pri+a.pri*b.sum;return c;
}
struct SegmentTree
{
	struct nd
	{
		int l,r;dat x;
	}t[800000];
	void build(int l,int r,int k=1)
	{
		t[k].l=l,t[k].r=r;
		if(l==r)
		{
			t[k].x.pri[1][1]=p[l],t[k].x.pri[1][0]=1-p[l],
			t[k].x.pri[0][1]=q[l],t[k].x.pri[0][0]=1-q[l];
			t[k].x.sum[1][1]=p[l],t[k].x.sum[0][1]=q[l];
			return;
		}
		int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
		t[k].x=t[k<<1].x*t[k<<1|1].x;
	}
	dat query(int l,int r,int k=1)
	{
		if(l<=t[k].l&&t[k].r<=r)return t[k].x;
		int mid=(t[k].l+t[k].r)>>1;
		if(r<=mid)return query(l,r,k<<1);
		if(l>mid)return query(l,r,k<<1|1);
		return query(l,r,k<<1)*query(l,r,k<<1|1);
	}
	void output(int k)
	{
		printf("%d: %d %d\n",k,t[k].l,t[k].r);
		for(int i=0;i<2;i++)for(int j=0;j<2;j++)printf("%.2lf ",t[k].x.pri[i][j]);puts("");
		if(t[k].l==t[k].r)return;output(k<<1);output(k<<1|1);
	}
}T;

int a[300000];

double calc(int l,int r)
{
	dat x=T.query(l+1,r);return x.sum[a[l]][a[r]]/x.pri[a[l]][a[r]];
}

set<int> st;char op[10];

int main()
{
	//mat A,B;A[0][0]=1,A[1][1]=2,B[1][0]=B[1][1]=1;A=A*B;for(int i=0;i<2;i++)for(int j=0;j<2;j++)printf("%lf ",A[i][j]);puts("");
	int n=0,m=0;scanf("%d%d%*s",&n,&m);
	scanf("%lf",&p[1]);for(int i=2;i<=n;i++)scanf("%lf%lf",&p[i],&q[i]);
	p[0]=1,q[0]=1;a[0]=1,a[n+1]=0;st.insert(0),st.insert(n+1);
	T.build(0,n+1);//T.output(1);
	double ans=calc(0,n+1);//printf("%lf\n",ans);
	while(m--)
	{
		scanf("%s",op);
		if(op[0]=='a')
		{
			int pos=0;scanf("%d",&pos);scanf("%d",&a[pos]);
			set<int>::iterator it=st.lower_bound(pos);int r=*it;it--;int l=*it;
			ans-=calc(l,r);ans+=calc(l,pos),ans+=calc(pos,r);
			st.insert(pos);
		}
		else
		{
			int pos=0;scanf("%d",&pos);st.erase(pos);
			set<int>::iterator it=st.lower_bound(pos);int r=*it;it--;int l=*it;
			ans+=calc(l,r);ans-=calc(l,pos),ans-=calc(pos,r);
		}
		printf("%.6lf\n",ans);
	}
	return 0;
}
```

---

## 作者：FZzzz (赞：7)

不知道大家都在推啥，而且为啥还都用了个 `set` 维护，这里是用常数换脑子的做法。

记小 R 获胜局数为 $c$，需要满足的限制为 $Q$，则我们要求的是：
$$\begin{aligned}E(c\mid Q)=&\sum_iiP(c=i\mid Q)\\=&\frac{\sum\limits_iiP(c=i\land Q)}{P(Q)}\\=&\frac{E([Q]c)}{P(Q)}\end{aligned}$$

然后发现提示里面提到了矩阵！我们直接考虑搞一个矩阵可以维护的东西。对于一个前缀，记 $R$ 为上一局是小 R 赢，$B$ 为上一局是小 B 赢，那么我们维护：
$$\begin{bmatrix}P(R\land Q)&P(B\land Q)&E([R\land Q]c)&E([B\land Q]c)\end{bmatrix}$$
如果第 $i$ 位没有限制，那么从 $i-1$ 转移到 $i$ 就是右乘上这个东西：
$$\begin{bmatrix}p_i&1-p_i&p_i&0\\q_i&1-q_i&q_i&0\\0&0&p_i&1-p_i\\0&0&q_i&1-q_i\end{bmatrix}$$
第 $i$ 位有限制的话形式也很友好，就是把这个矩阵里的某两列变成 $0$。

最后的答案就是
$$\frac{E([R\land Q]c)+E([B\land Q]c)}{P(R\land Q)+P(B\land Q)}$$
直接线段树维护就做完了。时间复杂度 $O(n\log n)$，带个可能 $4^3$ 的大常数。

~~提交后跑到了最优解最后一名。~~
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=2e5+5;
int n,m;
using ld=long double;
ld p[maxn],q[maxn];
struct matrix{
	ld a[4][4];
	matrix operator *(matrix B){
		matrix C;
		for(int i=0;i<4;i++) for(int j=0;j<4;j++){
			C.a[i][j]=0;
			for(int k=0;k<4;k++) C.a[i][j]+=a[i][k]*B.a[k][j];
		}
		return C;
	}
};
matrix get(int x){
	matrix A;
	A.a[0][0]=A.a[0][2]=A.a[2][2]=p[x];
	A.a[0][1]=A.a[2][3]=1-p[x];
	A.a[0][3]=A.a[1][3]=A.a[2][0]=A.a[2][1]=A.a[3][0]=A.a[3][1]=0;
	A.a[1][0]=A.a[1][2]=A.a[3][2]=q[x];
	A.a[1][1]=A.a[3][3]=1-q[x];
	return A;
}
struct node{
	int l,r;
	node* ch[2];
	matrix P;
	void pushup(){
		P=ch[0]->P*ch[1]->P;
	}
	node(int l,int r):l(l),r(r){
		if(l==r){
			P=get(r);
			return;
		}
		int mid=l+(r-l)/2;
		ch[0]=new node(l,mid);
		ch[1]=new node(mid+1,r);
		pushup();
	}
	void modify(int x,matrix A){
		if(l==r){
			P=A;
			return;
		}
		if(x<=ch[0]->r) ch[0]->modify(x,A);
		else ch[1]->modify(x,A);
		pushup();
	}
}*rt;
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	m=read();
	scanf("%*s%Lf",&p[1]);
	for(int i=2;i<=n;i++) scanf("%Lf%Lf",&p[i],&q[i]);
	rt=new node(1,n);
	while(m--){
		char opt[5];
		scanf("%s",opt);
		if(opt[0]=='a'){
			int x=read();
			bool c=read();
			matrix A=get(x);
			if(c) A.a[0][1]=A.a[1][1]=A.a[2][3]=A.a[3][3]=0;
			else A.a[0][0]=A.a[0][2]=A.a[1][0]=A.a[1][2]=A.a[2][2]=A.a[3][2]=0;
			rt->modify(x,A);
		}
		else{
			int x=read();
			rt->modify(x,get(x));
		}
		printf("%.6Lf\n",(rt->P.a[0][2]+rt->P.a[0][3])/(rt->P.a[0][0]+rt->P.a[0][1]));
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：Legitimity (赞：4)

这题还有一个更加朴实无华的维护方法。



------------

对于条件期望，我们有：

$$E(A|B)=\dfrac{E(AB)}{P(B)}$$

（可以这样理解：$E(A|B)P(B)=E(AB)$，即事件 $B$ 发生的概率乘在 $B$ 发生前提下事件 $A$ 的期望就是 $A$ 和 $B$ 同时发生的期望。）



------------


对于这道题，我们发现根据已确定输赢的位置将 $n$ 局游戏划成若干区间，设，区间 $[l,r]$ 内的输赢期望只和 $l$ 和 $r$ 的输赢情况有关，其它的修改影响不到区间 $[l,r]$。

那维护区间信息自然想到线段树，设 $p(l,r,a,b)$ 为位置 $l$ 的输赢情况为 $a$ 且位置 $r$ 的输赢情况为 $b$ 的概率，$e(l,r,a,b)$ 为在位置 $l$ 的输赢情况为 $a$ 且位置 $r$ 的输赢情况为 $b$ 时区间 $[l,r]$ 赢的局数的期望，$tp[x][a][b]$ 表示在前一个位置的输赢情况为 $a$ 时位置 $x$ 输赢情况为 $b$ 的概率（$tp$ 可以在一开始根据 $p_i$ 和 $q_i$ 预处理）。

下面我们尝试从 $[l,mid]$ 和 $[mid+1,r]$ 转移到 $[l,r]$。

对于 $p$ ，我们枚举 $mid$ 和 $mid+1$ 的输赢情况：

$$p(l,r,a,b)=\sum_{0\leq c,d\leq 1}p(l,mid,a,c)\times tp(mid+1,c,d)\times p(mid+1,r,d,b)$$

对于 $e$，根据上面条件期望的公式，记“赢”为事件 $A$，“位置 $l$ 的输赢情况为 $a$ 且位置 $r$ 的输赢情况为 $b$”为事件 $B$，则有：

$$e(l,r,a,b)=\dfrac{\sum_{0\leq c,d\leq 1}p(l,mid,a,c)\times tp(mid+1,c,d)\times p(mid+1,r,d,b)\times(e(l,mid,a,c)+e(mid+1,r,d,b))}{p(l,r,a,b)}$$

于是就可以在常数时间内转移。

然后每次用 `std::set` 维护已确定的位置，插入和删除时加加减减即可。（有个细节，当钦定位置 $i$ 赢的时候，我们令 $ans\gets ans+e(pre,i,c_{pre},c_i)+e(i,nex,c_i,c_{nex})-e(pre,nex,c_pre,c_nex)$ 时将位置 $i$ 的期望计算了两次，应减去 $1$；删除的时候同理）

线段树部分代码（完整代码去提交记录找）：

```cpp
double p[200005],q[200005],tp[200005][2][2];
struct node{
	double p[2][2],e[2][2];
	int l,r;
}t[200005<<2];
inline void merge(node& cx,node cl,node cr){
	cx.l=cl.l,cx.r=cr.r;
	cx.p[0][0]=cx.p[0][1]=cx.p[1][0]=cx.p[1][1]=cx.e[0][0]=cx.e[0][1]=cx.e[1][0]=cx.e[1][1]=0;
	for(rg int a=0;a<2;++a) for(rg int b=0;b<2;++b){
		for(rg int c=0;c<2;++c) for(rg int d=0;d<2;++d) cx.p[a][b]+=cl.p[a][c]*cr.p[d][b]*tp[cr.l][c][d];
		for(rg int c=0;c<2;++c) for(rg int d=0;d<2;++d) cx.e[a][b]+=cl.p[a][c]*cr.p[d][b]*tp[cr.l][c][d]*(cl.e[a][c]+cr.e[d][b]);
        if(fabs(cx.p[a][b])<1e-6) cx.e[a][b]=0;
		else cx.e[a][b]/=cx.p[a][b];
	}
}
void build(int x,int l,int r){
	t[x].l=l,t[x].r=r;
	if(l==r) return t[x].p[0][0]=1,t[x].p[1][1]=1,t[x].e[0][0]=1.0,void();
	const int mid=l+r>>1;
	build(x<<1,l,mid),build(x<<1|1,mid+1,r);
	merge(t[x],t[x<<1],t[x<<1|1]);
}
node query(int x,const int sl,const int sr){
	if(sl<=t[x].l&&sr>=t[x].r) return t[x];
	const int mid=t[x].l+t[x].r>>1;
	if(sl>mid) return query(x<<1|1,sl,sr);
	if(sr<=mid) return query(x<<1,sl,sr);
	node ret; merge(ret,query(x<<1,sl,sr),query(x<<1|1,sl,sr)); return ret;
}
```


---

## 作者：Purslane (赞：0)

# Solution

根据期望的线性性，我们要求未知的每个位置赢的概率。游戏是 $\rm Markov$ 过程，我们只需要关心每个位置左边相邻的已知状态和右边相邻的已知状态。

具体的，$P(W \mid L,R)$ 表示已知事件 $L$ 和 $R$，求事件 $W$ 发生的概率。有

$$
\begin{aligned}
P(W \mid L,R) &= \frac{P(W,L,R)}{P(L,R)} \\
&= \frac{P(L)P(W \mid L)P(R \mid W)}{P(R \mid L) P(L)}  & \small{这一步还是利用了 \text{Markov} 过程的性质} \\
&= \frac{P(W \mid L)P(R \mid W)}{P(R \mid L)}
\end{aligned}
$$

如何求 $P(R \mid L)$？维护矩阵 $\left[ \begin{matrix} w & l\end{matrix}\right]$ 表示赢和输的概率，对于每个位置都乘上 $\left[ \begin{matrix}p_i & 1-p_i \\ q_i & 1-q_i \end{matrix}\right]$。

那么一段区间里面的 $\sum P(W \mid L) P(X \mid W)$ 如何计算？这一步我们的矩阵应当修改为 $\left[ \begin{matrix}p_i & 0 \\ q_i & 0 \end{matrix}\right]$。设修改前的矩阵是 $M$，修改后的矩阵为 $G$，那么求的是 $GMM\cdots MM+MGM\cdots MM + MMG \cdots MM + \dots + MMM \cdots GM$ 这种类型。（小细节在于，最后一个矩阵必定是 $M$ 形的 $R$，所以如果你想让他好看一点，可以最后一把乘）使用线段树容易维护。

注意首尾加两个哨兵元素 $0$ 和 $n+1$，并且钦定第 $0$ 局和第 $n+1$ 局小 $R$ 必胜方便代码实现。

概率题不取模差评 /oh

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200000+10;
struct Matrix {double a,b,c,d;}M[MAXN],G[MAXN];
Matrix operator +(Matrix A,Matrix B) {return {A.a+B.a,A.b+B.b,A.c+B.c,A.d+B.d};}
Matrix operator *(Matrix A,Matrix B) {return {A.a*B.a+A.b*B.c,A.a*B.b+A.b*B.d,A.c*B.a+A.d*B.c,A.c*B.b+A.d*B.d};}
double p[MAXN],q[MAXN];
struct TMatrix {Matrix sum,prod;}t[MAXN<<2];
TMatrix operator +(TMatrix A,TMatrix B) {return {(A.sum*B.prod)+(A.prod*B.sum),A.prod*B.prod};}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void build(int k,int l,int r) {
	if(l==r) return t[k]={(G[l]={p[l],0,q[l],0}),(M[l]={p[l],1-p[l],q[l],1-q[l]})},void();
	build(lson,l,mid),build(rson,mid+1,r);
	return t[k]=t[lson]+t[rson],void();
}
TMatrix query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return t[k];
	if(y<=mid) return query(lson,l,mid,x,y);
	if(x>mid) return query(rson,mid+1,r,x,y);
	return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);
}
int n,m,st[MAXN],ans_k; set<int> kpos; char tp;
double ans_unk;
double query(int l,int r) {
	if(r-l==1) return 0;
	Matrix mul={0,0,0,0};
	if(st[l]==0) mul.b=1; else mul.a=1;
	auto qr=query(1,1,n,l+1,r-1);
	double sum=0; Matrix mt=mul*qr.sum*M[r];
	if(st[r]==1) sum=mt.a; else sum=mt.b;
	mt=mul*qr.prod*M[r];
	if(st[r]==1) return sum/mt.a; return sum/mt.b;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>tp;
	cin>>p[1]; ffor(i,2,n) cin>>p[i]>>q[i];
	p[n+1]=q[n+1]=1,st[0]=1,st[n+1]=1,kpos.insert(0),kpos.insert(n+1);
	build(1,1,n); M[n+1]={1,0,1,0};
	ans_unk=query(0,n+1);
	ffor(i,1,m) {
		string op; cin>>op;
		if(op=="add") {
			int pos,c; cin>>pos>>c;
			st[pos]=c;
			auto nxt=*kpos.upper_bound(pos),pre=*(--kpos.upper_bound(pos));
			ans_unk+=query(pre,pos)+query(pos,nxt)-query(pre,nxt);
			if(c) ans_k++;
			kpos.insert(pos);
		}
		else {
			int pos; cin>>pos;
			auto nxt=*kpos.upper_bound(pos),pre=*(--kpos.lower_bound(pos));
			ans_unk-=query(pre,pos)+query(pos,nxt)-query(pre,nxt);
			if(st[pos]) ans_k--;
			kpos.erase(pos);
		}
		cout<<fixed<<setprecision(10)<<ans_k+ans_unk<<'\n';
	}
	return 0;
}
```

---

## 作者：Leasier (赞：0)

在无修改的情况下，考虑 dp。设 $f_{i, 0/1}$ 表示第 $i$ 局游戏小 B / R 获胜的概率，$g_{i, 0/1}$ 表示第 $i$ 局游戏中小 B / R 获胜时，前 $i$ 局游戏中小 R 获胜的期望轮数。

初值：$f_{1, 0} = 1 - p_1$，$f_{1, 1} = p_1$，$g_{1, 0} = 0$，$g_{1, 1} = p_1$。

转移：$f_{i, 0} = (1 - q_i) f_{i - 1, 0} + (1 - p_i) f_{i - 1, 1}$，$f_{i, 1} = q_i f_{i - 1, 0} + p_i f_{i - 1, 1}$，$g_{i, 0} = (1 - q_i) g_{i - 1, 0} + (1 - p_i) g_{i - 1, 1}$，$g_{i, 1} = q_i (g_{i - 1, 0} + f_{i - 1, 0}) + p_i (g_{i - 1, 1} + f_{i - 1, 1})$。

答案：$g_{n, 0} + g_{n, 1}$。

现在考虑加入修改。不妨钦定 $c = 0$，则一个 naive 的想法是强令 $f_{i, 1} = g_{i, 1} = 0$，答案变为 $\dfrac{g_{n, 0} + g_{n, 1}}{f_{n, 0} + f_{n, 1}}$。

套上 ddp 即可。时间复杂度为 $O(n + m \log n)$。

------------

但如题面所说，这样会被[卡精度](https://loj.ac/s/1884969)，开 long double 后[跑得巨慢](https://loj.ac/s/1885128)，循环展开后速度也[不甚理想](https://loj.ac/s/1885179) /fad

注意到由确定局隔开的两块是独立的，于是我们用 set 维护确定局组成的连续段即可。时间复杂度不变，但因为只需要 double 而[快了很多](https://loj.ac/s/1885750)。

代码：
```cpp
#include <set>
#include <vector>
#include <cstdio>

using namespace std;

typedef struct Segment_tag {
	int l;
	int r;
	Segment_tag(){}
	Segment_tag(int l_, int r_){
		l = l_;
		r = r_;
	}
} Segment;

typedef struct {
	double a00;
	double a01;
	double a02;
	double a03;
	double a10;
	double a11;
	double a12;
	double a13;
	double a22;
	double a23;
	double a32;
	double a33;
} Matrix;

typedef struct {
	int l;
	int r;
	Matrix mat;
} Node;

typedef struct {
	double a0;
	double a1;
	double a2;
	double a3;
} Vector;

int n;
double ans;
int flag[200007];
double p[200007], q[200007];
char type[7], op[7];
Matrix mat0[200007], mat1[200007], cur_mat[200007];
Node tree[800007];
set<Segment> s;

bool operator <(const Segment a, const Segment b){
	return a.r < b.r;
}

Matrix operator *(Matrix &a, Matrix &b){
	Matrix ans;
	ans.a00 = a.a00 * b.a00 + a.a01 * b.a10;
	ans.a01 = a.a00 * b.a01 + a.a01 * b.a11;
	ans.a02 = a.a00 * b.a02 + a.a01 * b.a12 + a.a02 * b.a22 + a.a03 * b.a32;
	ans.a03 = a.a00 * b.a03 + a.a01 * b.a13 + a.a02 * b.a23 + a.a03 * b.a33;
	ans.a10 = a.a10 * b.a00 + a.a11 * b.a10;
	ans.a11 = a.a10 * b.a01 + a.a11 * b.a11;
	ans.a12 = a.a10 * b.a02 + a.a11 * b.a12 + a.a12 * b.a22 + a.a13 * b.a32;
	ans.a13 = a.a10 * b.a03 + a.a11 * b.a13 + a.a12 * b.a23 + a.a13 * b.a33;
	ans.a22 = a.a22 * b.a22 + a.a23 * b.a32;
	ans.a23 = a.a22 * b.a23 + a.a23 * b.a33;
	ans.a32 = a.a32 * b.a22 + a.a33 * b.a32;
	ans.a33 = a.a32 * b.a23 + a.a33 * b.a33;
	return ans;
}

Vector operator *(Vector &a, Matrix &b){
	Vector ans;
	ans.a0 = a.a0 * b.a00 + a.a1 * b.a10;
	ans.a1 = a.a0 * b.a01 + a.a1 * b.a11;
	ans.a2 = a.a0 * b.a02 + a.a1 * b.a12 + a.a2 * b.a22 + a.a3 * b.a32;
	ans.a3 = a.a0 * b.a03 + a.a1 * b.a13 + a.a2 * b.a23 + a.a3 * b.a33;
	return ans;
}

void operator *=(Vector &a, Matrix &b){
	a = a * b;
}

inline void update(int x){
	tree[x].mat = tree[x * 2].mat * tree[x * 2 + 1].mat;
}

void build(int x, int l, int r){
	tree[x].l = l;
	tree[x].r = r;
	if (l == r){
		tree[x].mat.a00 = tree[x].mat.a22 = 1.0 - q[l];
		tree[x].mat.a01 = tree[x].mat.a03 = tree[x].mat.a23 = q[l];
		tree[x].mat.a10 = tree[x].mat.a32 = 1.0 - p[l];
		tree[x].mat.a11 = tree[x].mat.a13 = tree[x].mat.a33 = p[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
	update(x);
}

void mul(int x, int l, int r, Vector &v){
	if (l <= tree[x].l && tree[x].r <= r){
		v *= tree[x].mat;
		return;
	}
	int mid = (tree[x].l + tree[x].r) >> 1;
	if (l <= mid) mul(x * 2, l, r, v);
	if (r > mid) mul(x * 2 + 1, l, r, v);
}

inline double query(int l, int r){
	Vector v;
	if (l == 1){
		v.a0 = 1.0 - p[l];
		v.a1 = v.a3 = p[l];
		v.a2 = 0.0;
		if (l < r) mul(1, l + 1, r, v);
		if (r < n){
			v *= cur_mat[r + 1];
			if (flag[r + 1] == 1) v.a3 -= v.a1;
		}
	} else {
		v.a0 = flag[l - 1] ^ 1;
		v.a1 = flag[l - 1];
		v.a2 = v.a3 = 0.0;
		mul(1, l, r, v);
		if (r < n){
			v *= cur_mat[r + 1];
			if (flag[r + 1] == 1) v.a3 -= v.a1;
		}
	}
	return (v.a2 + v.a3) / (v.a0 + v.a1);
}

inline void split(int x, int k){
	Segment seg;
	set<Segment>::iterator it = s.lower_bound(Segment(0, x));
	seg = *it;
	s.erase(it);
	ans -= query(seg.l, seg.r);
	flag[x] = k;
	ans += k;
	if (k == 0){
		cur_mat[x] = mat0[x];
	} else {
		cur_mat[x] = mat1[x];
	}
	if (seg.l < x){
		s.insert(Segment(seg.l, x - 1));
		ans += query(seg.l, x - 1);
	}
	if (x < seg.r){
		s.insert(Segment(x + 1, seg.r));
		ans += query(x + 1, seg.r);
	}
}

inline void merge(int x){
	Segment seg(x, x);
	vector<Segment> v;
	set<Segment>::iterator it = s.lower_bound(Segment(0, x));
	ans -= flag[x];
	if (it != s.end() && it->l == x + 1){
		seg.r = it->r;
		ans -= query(it->l, it->r);
		v.push_back(*it);
	}
	if (it != s.begin() && (--it)->r == x - 1){
		seg.l = it->l;
		ans -= query(it->l, it->r);
		v.push_back(*it);
	}
	while (!v.empty()){
		s.erase(v.back());
		v.pop_back();
	}
	s.insert(seg);
	ans += query(seg.l, seg.r);
}

int main(){
	int m;
	scanf("%d %d %s", &n, &m, type);
	for (register int i = 1; i <= n; i++){
		scanf("%lf", &p[i]);
		if (i > 1) scanf("%lf", &q[i]);
	}
	s.insert(Segment(1, n));
	build(1, 1, n);
	for (register int i = 1; i <= n; i++){
		mat0[i].a00 = mat0[i].a22 = 1.0 - q[i];
		mat0[i].a10 = mat0[i].a32 = 1.0 - p[i];
		mat1[i].a01 = mat1[i].a03 = mat1[i].a23 = q[i];
		mat1[i].a11 = mat1[i].a13 = mat1[i].a33 = p[i];
	}
	ans = query(1, n);
	for (register int I = 1; I <= m; I++){
		int i;
		scanf("%s %d", &op[1], &i);
		if (op[1] == 'a'){
			int c;
			scanf("%d", &c);
			split(i, c);
		} else {
			merge(i);
		}
		printf("%.6lf\n", ans);
	}
	return 0;
}
```

---

## 作者：luqyou (赞：0)

# 前言
本题解来自：Stargazer_cykoi

# 直接上思路
首先显然考虑每个位置赢的概率~~是人都知道吧~~，但是最重要的问题在于一个位置输赢的概率不只要考虑前面的，还要考虑造成下一个胜负确定位置的影响。

易想到贝叶斯公式。

参考给出的贝叶斯公式。

$P(x_i=1|x_r,x_l)$

$=\frac{P(x_l,x_r|x_i)P(x_i)}{P(x_l,x_r)}$

$=\frac{P(x_l,x_r,x_i)}{P(x_l)P(x_r|x_l)}$

$=\frac{P(x_l,x_r,x_i)}{P(x_l)P(x_r|x_l)}$

$=\frac{P(x_i,x_r|x_l)}{P(x_r|x_l)}$ 

可以发现下面就是 $x_l$ 导致 $x_r$ 为当前确认情况的概率，这个就是概率矩阵相乘。

可以发现这时候
上面则不需要考虑 $x_r$ 的影响了，上面所有 $i$ 加起来就是赢的场数的期望，只需要在概率矩阵相乘的时候顺便算一个期望即可。

然后就只需要在加入或者删除确定时间的时候找一下前驱后继加加减减就可以了。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define cs const
#define re register
#define pii pair<int,int>
#define fi first
#define se second
#define ll long long
#define pb push_back
cs int RLEN=1<<20|1;
inline char gc(){
	static char ibuf[RLEN],*ib,*ob;
	(ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));
	return (ib==ob)?EOF:*ib++;
}
#define gc getchar
inline int read(){
	char ch=gc();
	int res=0;bool f=1;
	while(!isdigit(ch))f^=ch=='-',ch=gc();
	while(isdigit(ch))res=(res+(res<<2)<<1)+(ch^48),ch=gc();
	return f?res:-res;
}
template<class tp>inline void chemx(tp &a,tp b){a<b?a=b:0;}
template<class tp>inline void chemn(tp &a,tp b){a>b?a=b:0;}
int n,m;
cs int N=200005;
struct mat{
	double a[2][2];
	mat(){a[0][0]=a[1][0]=a[0][1]=a[1][1]=0;}
	friend inline mat operator +(cs mat &a,cs mat &b){
		mat c;
		for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
		c.a[i][j]=a.a[i][j]+b.a[i][j];
		return c;
	}
	friend inline mat operator *(cs mat &a,cs mat &b){
		mat c;
		for(int i=0;i<2;i++)
		for(int k=0;k<2;k++)
		for(int j=0;j<2;j++)
		c.a[i][j]+=a.a[i][k]*b.a[k][j];
		return c;
	}
};
double p[N],q[N];
int sta[N];
namespace Seg{
	#define lc (u<<1)
	#define rc ((u<<1)|1)
	#define mid ((l+r)>>1)
	struct data{
		mat a,b;
		inline void init(double p,double q){
			a.a[0][0]=1-q,a.a[0][1]=q,a.a[1][0]=1-p,a.a[1][1]=p;
			b.a[0][1]=q,b.a[1][1]=p;
		}
		friend inline data operator *(cs data &a,cs data &b){
			data c;
			c.a=a.a*b.a;
			c.b=a.a*b.b+a.b*b.a;
			return c;
		}
	}s[N<<2];
	inline void pushup(int u){
		s[u]=s[lc]*s[rc];
	}
	void build(int u,int l,int r){
		if(l==r){
			s[u].init(p[l],q[l]);return;
		}
		build(lc,l,mid),build(rc,mid+1,r);
		pushup(u);
	}
	data query(int u,int l,int r,int st,int des){
		if(st<=l&&r<=des)return s[u];
		if(des<=mid)return query(lc,l,mid,st,des);
		if(mid<st)return query(rc,mid+1,r,st,des);
		return query(lc,l,mid,st,des)*query(rc,mid+1,r,st,des);
	}
	inline double getans(int l,int r){
		data now=query(1,0,n+1,l+1,r);
		return now.b.a[sta[l]][sta[r]]/now.a.a[sta[l]][sta[r]];
	}
	#undef lc
	#undef rc
	#undef mid
}
char op[5];
map<int,int> vt;
#define It map<int,int>::iterator
int main(){
	#ifdef Stargazer
	freopen("lx.in","r",stdin);
	#endif
	n=read(),m=read();scanf("%s",op);
	scanf("%lf",&p[1]);
	for(int i=2;i<=n;i++)scanf("%lf%lf",&p[i],&q[i]);
	p[0]=q[0]=1,p[n+1]=q[n+1]=0;
	Seg::build(1,0,n+1);
	vt[0]=1,vt[n+1]=0,sta[0]=1,sta[n+1]=0;
	double ans=Seg::getans(0,n+1);
	while(m--){
		scanf("%s",op);
		if(op[0]=='a'){
			int pos=read(),c=read();
			It nxt=vt.lower_bound(pos),pre=nxt;pre--;
			vt[pos]=c,sta[pos]=c;
			ans-=Seg::getans(pre->fi,nxt->fi);
			ans+=Seg::getans(pre->fi,pos);
			ans+=Seg::getans(pos,nxt->fi);
		}
		else{
			int pos=read();
			It nxt=vt.upper_bound(pos),pre=nxt;pre--,pre--;
			ans+=Seg::getans(pre->fi,nxt->fi);
			ans-=Seg::getans(pre->fi,pos);
			ans-=Seg::getans(pos,nxt->fi);
			sta[pos]=0;pre++,vt.erase(pre);
		}
		printf("%.7lf\n",ans);
	}
}

```


---


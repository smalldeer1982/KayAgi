# [九省联考 2018] IIIDX

## 题目背景

Osu 听过没？那是 Konano 最喜欢的一款音乐游戏，而他的梦想就是有一天自己也能做个独特酷炫的音乐游戏。现在，他在世界知名游戏公司 KONMAI 内工作，离他的梦想也越来越近了。

这款音乐游戏内一般都包含了许多歌曲，歌曲越多，玩家越不易玩腻。同时，为了使玩家在游戏上~~氪更多的金钱~~花更多的时间，游戏一开始一般都不会将所有曲目公开，有些曲目你需要通关某首特定歌曲才会解锁，而且越晚解锁的曲目难度越高。

## 题目描述

这一天，Konano 接到了一个任务，他需要给正在制作中的游戏《IIIDX》安排曲目的解锁顺序。游戏内共有 $n$ 首曲目，每首曲目都会有一个难度 $d$，游戏内第 $i$ 首曲目会在玩家 Pass 第 $\left\lfloor \frac i k \right\rfloor$ 首曲目后解锁（$\left\lfloor x \right\rfloor$ 为下取整符号）若 $\left\lfloor \frac i k \right\rfloor = 0$，则说明这首曲目**无需解锁**。

举个例子：当 $k = 2$ 时，第 $1$ 首曲目是无需解锁的（$\left\lfloor \frac 12 \right\rfloor = 0$），第 $7$ 首曲目需要玩家 Pass 第 $\left\lfloor \frac 72 \right\rfloor = 3$ 首曲目才会被解锁。

Konano 的工作，便是安排这些曲目的顺序，使得每次解锁出的曲子的难度**不低于**作为条件需要玩家通关的曲子的难度，即使得确定顺序后的曲目的难度对于每个 $i$ 满足 $d_i \geq d_{\left\lfloor \frac ik \right\rfloor}$。

当然这难不倒曾经在信息学竞赛摸鱼许久的 Konano。那假如是你，你会怎么解决这份任务呢？

## 说明/提示

| 测试点编号 | $n$ | $k$ | $d$ | 特殊限制 |
|-|-|-|-|-|
| $1$ | $1 \leq n \leq 10$ | $k=2$ | $1 \leq d \leq 100$ | 保证 $d_i$ 互不相同 |
| $2$ | $1 \leq n \leq 10$ | $k=3$ | $1 \leq d \leq 100$ | 保证 $d_i$ 互不相同 |
| $3$ | $1 \leq n \leq 10$ | $k=1.1$ | $1 \leq d \leq 100$ | 保证 $d_i$ 互不相同 |
| $4$ | $1 \leq n \leq 10$ | $k=n$ | $1 \leq d \leq 100$ | 保证 $d_i$ 互不相同 |
| $5$ | $1 \leq n \leq 10$ | $1 < k \leq 100$ | $1 \leq d \leq 100$ | 保证 $d_i$ 互不相同 |
| $6$ | $1 \leq n \leq 10$ | $1 < k \leq 100$ | $1 \leq d \leq 100$ | 保证 $d_i$ 互不相同 |
| $7$ | $1\leq n\leq 2000$ | $k=2$ | $1\leq d\leq 10^9$ | 保证 $d_i$ 互不相同 |
| $8$ | $1\leq n\leq 2000$ | $k=2$ | $1\leq d\leq 10^9$ | 无 |
| $9$ | $1\leq n\leq 2000$ | $k=3$ | $1\leq d\leq 10^9$ | 保证 $d_i$ 互不相同 |
| $10$ | $1\leq n\leq 2000$ | $k=3$ | $1\leq d\leq 10^9$ | 无 |
| $11$ | $1\leq n\leq 2000$ | $1 < k \leq 10^9$ | $1\leq d\leq 10^9$ | 保证 $d_i$ 互不相同 |
| $12$ | $1\leq n\leq 2000$ | $1 < k \leq 10^9$ | $1\leq d\leq 10^9$ | 无 |
| $13$ | $1\leq n\leq 500000$ | $k=2$ | $1\leq d\leq 10^9$ | 无 |
| $14$ | $1\leq n\leq 500000$ | $k=3$ | $1\leq d\leq 10^9$ | 无 |
| $15$ | $1\leq n\leq 500000$ | $1<k\leq 10^9$ | $1\leq d\leq 10^9$ | 保证 $d_i$ 互不相同 |
| $16$ | $1\leq n\leq 500000$ | $1<k\leq 10^9$ | $1\leq d\leq 10^9$ | 保证 $d_i$ 互不相同 |
| $17$ | $1\leq n\leq 500000$ | $1<k\leq 10^9$ | $1\leq d\leq 10^9$ | 无 |
| $18$ | $1\leq n\leq 500000$ | $1<k\leq 10^9$ | $1\leq d\leq 10^9$ | 无 |
| $19$ | $1\leq n\leq 500000$ | $1<k\leq 10^9$ | $1\leq d\leq 10^9$ | 无 |
| $20$ | $1\leq n\leq 500000$ | $1<k\leq 10^9$ | $1\leq d\leq 10^9$ | 无 |

## 样例 #1

### 输入

```
4 2.0
114 514 1919 810```

### 输出

```
114 810 514 1919```

# 题解

## 作者：Sakits (赞：59)

## https://sakits.com/bzoj5249/
# 题解
　　显然题意可以抽象成：一棵树，要对树上的每个点标上给定的权值，满足每个点上的权值都$\leq$子树内点的权值，并使这个棵树编号从小到大的权值字典序最大。

　　首先可以一眼得到一个做法，将权值从大到小排序，把长度为子树大小的一段按子树编号从小到大丢给它们，递归下去得到答案。

　　这种做法在$d_i$不重复的时候是正确的，那$d_i$要是有相同的数呢？

　　有可能可以将编号$x$子树里一个大的权值与编号$x+1$的子树根的权值替换，使得$x$的权值依然是能取得的最大数且子树内的数都比$x$的权值大，同时$x+1$子树内的点也还能标满$\geq$$x+1$权值的权值。

　　那怎么做呢？先把给定权值从大到小排序，线段树上维护每个权值左边（包括本身）还能取的权值的个数$C_i$。

　　当取好一个点$x$的权值时，需要给它子树内的点预留取的权值，这些权值显然在$x$取得权值的左边，但是我们并不知道取的是哪些权值，所以只把$x$取得的权值右边（包括本身）的$C_i$减去$x$子树大小$size[x]$，每次取一个点$y$的权值时，只需要在线段树上找到最大权值$val$满足$val$所在位置右边（包括本身）的所有$C_i\geq size[y]$，且$val$尽可能靠右即可，这个在线段树上二分就能做到。

　　如果一个点有父亲，求它的权值时要把它父亲为子树预留的大小去掉，需要注意的是，每个父亲预留的大小只要去掉一次，写的时候容易忽略这一点，WA了半天T_T。
# 代码

    #include<iostream> 
    #include<cstring>
    #include<cstdlib>
    #include<cstdio>
    #include<cmath> 
    #include<algorithm> 
    using namespace std;
    const int maxn=500010, inf=1e9;
    struct poi{int mn, delta;}tree[maxn<<2];
    int n, N;
    double k;
    int a[maxn], b[maxn], ans[maxn], size[maxn], fa[maxn], cnt[maxn];
    inline void read(int &k)
    {
    	int f=1; k=0; char c=getchar();
    	while(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();
    	while(c<='9' && c>='0') k=k*10+c-'0', c=getchar();
    	k*=f;
    }
    inline bool cmp(int a, int b){return a>b;}
    inline void addone(int x, int delta){tree[x].delta+=delta; tree[x].mn+=delta;}
    inline void up(int x){tree[x].mn=min(tree[x<<1].mn, tree[x<<1|1].mn);}
    inline void down(int x)
    {
    	addone(x<<1, tree[x].delta);
    	addone(x<<1|1, tree[x].delta);
    	tree[x].delta=0;
    }
    void build(int x, int l, int r)
    {
    	if(l==r){tree[x].mn=l; return;}
    	int mid=(l+r)>>1;
    	build(x<<1, l, mid); build(x<<1|1, mid+1, r);
    	up(x);
    }
    int query(int x, int l, int r, int k)
    {
    	if(l==r) return (tree[x].mn>=k?l:l+1);
    	down(x);
    	int mid=(l+r)>>1;
    	if(k<=tree[x<<1|1].mn) return query(x<<1, l, mid, k);
    	else return query(x<<1|1, mid+1, r, k);
    }
    void update(int x, int l, int r, int cl, int cr, int delta)
    {
    	if(cl<=l && r<=cr){tree[x].mn+=delta; tree[x].delta+=delta; return;}
    	down(x);
    	int mid=(l+r)>>1;
    	if(cl<=mid) update(x<<1, l, mid, cl, cr, delta);
    	if(cr>mid) update(x<<1|1, mid+1, r, cl, cr, delta);
    	up(x);
    }
    int main()
    {
    	read(n); scanf("%lf", &k);	
    	for(int i=1;i<=n;i++) read(a[i]);
    	sort(a+1, a+1+n, cmp);
    	for(int i=n-1;i;i--) 
    	if(a[i]==a[i+1]) cnt[i]=cnt[i+1]+1; else cnt[i]=0;
    	for(int i=1;i<=n;i++) fa[i]=(int)floor(i/k), size[i]=1;
    	for(int i=n;i;i--) size[fa[i]]+=size[i];
    	build(1, 1, n);
    	for(int i=1;i<=n;i++)
    	{
    		if(fa[i]&&fa[i]!=fa[i-1]) update(1, 1, n, ans[fa[i]], n, size[fa[i]]-1);
    		int x=query(1, 1, n, size[i]); 
    		x+=cnt[x]; cnt[x]++; x-=(cnt[x]-1); ans[i]=x; 
    		update(1, 1, n, x, n, -size[i]);
    	}
    	for(int i=1;i<=n;i++) printf("%d ", a[ans[i]]);
    }


---

## 作者：Lunch (赞：47)

### 这个题目花了我整整两天时间...可能是学oi以来刚的最久的一道题了..

### 果然我还是太弱了 但在我们的~~红太阳~~@ylsoi帮助下还是想通了


考试的时候我这种辣鸡打了贪心还美滋滋地以为自己打的是正解

首先是55分的贪心 对于任何一个点i它的权值一定小于floor(i/x)

这样就构成了一个树形结构 把所有的数全存进一个堆中 直接dfs回溯的
时候把最大值赋给那个点就ok了
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=a;i<=b;++i)
#define FOR(i,a,b) for(register int i=a;i>=b;--i)
#define go(x,i) for(register int i=head[x];i;i=next[i])
#define inf (0x3f3f3f3f)
#define next Next
#define mid ((l+r)>>1)
#define SZ(x) (x.size())
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
#define tt template<typename T>

using namespace std;

tt inline bool chkmax(T &_,T __){return _<__?_=__,1:0;}
tt inline bool chkmin(T &_,T __){return _>__?_=__,1:0;}

tt inline void read(T &_)
{
	T ___=1,__=getchar();_=0;
	for(;!isdigit(__);__=getchar()) if(__=='-') ___=-1;
	for(;isdigit(__);__=getchar()) _=(_<<3)+(_<<1)+(__^48);
	_*=___;
}

inline void file()
{
	freopen("iiidx.in","r",stdin);
	freopen("iiidx.out","w",stdout);
}

const int maxn=5e5+10;
vector<int> son[maxn];
priority_queue<int> a;
int fa[maxn];
int ans[maxn],root;
int n,vis[maxn];
int dis[maxn],size[maxn];
double k;

inline void dfs(int x)
{
	int len=son[x].size();
	For(i,0,len-1)
		dfs(son[x][i]);
	if(x!=root)
		ans[x]=a.top(),a.pop();
}

int main()
{
	file();
	read(n);cin>>k;
	int qaq;
	For(i,1,n)
	{
		read(qaq);
		a.push(qaq);
	}
	root=n+1;
	For(i,1,n)
	{
		int dad=i/k;
		dad=dad?dad:root;
		son[dad].push_back(i);
		fa[i]=dad;
	}
	dfs(root);
	For(i,1,n)
		printf("%d ",ans[i]);
	return 0;
}

```

在有多个数相同的时候贪心是显然错误的 例如
 
 $$ n=4;k=2;a=(1,1,1,2) $$
 正确答案应该是 $$ (1,1,2,1)$$
 而贪心求出来的答案是 $$(1,1,1,2)$$
 这样就只有55分了~
 
 那么我们来考虑一下如何维护这样一个近似于小根堆的结构
 
 对于这样一组数 9 9 9 8 7 7 6 6 6 5
 
$\quad $如果size[1]是7的话,
 那么我们会先找到一个最靠近左边的位置使得在左边有6个数要大于等于这个位置上的值，那么我们就会找到第7个位置上的 6 然后再移动到和它相等最右边的数的位置上，也就是第9个位置上的6，为什么要移动呢，因为这样子可以留出更多的数给后面的点使用，就是保证1号点选到最优的值情况下尽量让和它同一层的点最优，而不是它的子树达到最优，所以我们可以从1到n按顺序去取点，对于i号点要给它的子树预留size[i]-1个点，那么可以通过线段树来维护“预留”这个操作。 
 
### $\quad $ 定义f[i]数组表示i号点左边(包括它自己)最多可以再放多少个点， 那么f[i]数组一定是一个单调不下降的数组，我们可以用线段树来维护F[i]数组和某段区间的F最小值，那么我们就可以每次在线段树上二分出那个最左边的位置，再通过一个cnt数组来存储当前点向右位移几个距离能够到达使当前点最优并且能给同层的点提供一个可能更优的位置的位置~~（理解一下下这句话）~~ 就可以解决这个问题了~具体实现见代码


```cpp
/*============================
 * Author : Lunch_
 * Problem : iiidx
 * Algorithm : tanxin
 * Time : 2018.4.12
 * ==========================*/
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=a;i<=b;++i)
#define FOR(i,a,b) for(register int i=a;i>=b;--i)
#define mid ((l+r)>>1)
#define ls (bh<<1)
#define rs (ls|1)
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
#define inf (0x3f3f3f3f)

typedef long long ll;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::sort;

const int maxn=5e5+10;
int s[maxn<<2],lazy[maxn<<2];
int cnt[maxn],a[maxn],fa[maxn],ans[maxn]; //cnt数组为了找到某个位置最右边与它相同的数(如果那个数已经被选了就指针往后移动一个）
int vis[maxn],n,size[maxn];
vector<int> son[maxn]; 
double k;

inline bool cmp(int x,int y) //从大到小排序
{
	return x>y;  
}

inline void pushup(int bh)
{
	s[bh]=min(s[ls],s[rs]);
}

inline void pushdown(int bh)
{
	if(lazy[bh])
	{
		lazy[ls]+=lazy[bh];
		lazy[rs]+=lazy[bh];
		s[ls]+=lazy[bh];
		s[rs]+=lazy[bh];
		lazy[bh]=0;
	}
}

inline void build(int bh,int l,int r)
{
	if(l==r)
		s[bh]=l; //每个点初始左边可用的数就是他的下标
	else
	{
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(bh);
	}
}

inline void change(int bh,int l,int r,int x,int y,int z)
{
	if(x<=l&&r<=y)
	{
		lazy[bh]+=z;
		s[bh]+=z;
		return;
	}
	pushdown(bh);
	if(x<=mid) 
		change(ls,l,mid,x,y,z);
	if(y>mid)
		change(rs,mid+1,r,x,y,z);
	pushup(bh);

}

inline int query(int bh,int l,int r,int x)
{
	if(l==r)
		return s[bh]>=x?l:l+1; //在底下的if中s[rs]==x时我们也是往左边选的 可能会漏掉最小值在相邻的右区间这种情况所以在这里判一下
	pushdown(bh);
	if(x>s[rs])  //尽量往左边选
		return query(rs,mid+1,r,x);
	return query(ls,l,mid,x);
}

int main(void)
{
#ifndef ONLINE_JUDGE
	freopen("iidxes.in","r",stdin);
	freopen("iidxes.out","w",stdout);
#endif
	memset(s,inf,sizeof(s));
	scanf("%d",&n);cin>>k;
	For(i,1,n)
	{
		scanf("%d",&a[i]);
		size[i]=1;
	}
	sort(a+1,a+n+1,cmp);
	build(1,1,n);
	FOR(i,n,1)
	{
		cnt[i]=a[i]==a[i+1]?cnt[i+1]+1:0; //推cnt数组
		int ovo=i/k;
		size[ovo]+=size[i];
		fa[i]=ovo;
	}
	For(i,1,n)
	{
		if(fa[i]&&!vis[fa[i]])
		{
			change(1,1,n,ans[fa[i]],n,size[fa[i]]-1);//每次一个点的父亲节点访问过以后就把预留的空间放出来
			vis[fa[i]]=1;
		}
		int now=query(1,1,n,size[i]);
		now+=cnt[now];
		++cnt[now];//位置用过后后指针向右边偏移一个单位
		ans[i]=now;
		change(1,1,n,ans[i],n,-size[i]);//给它的子树预留空间
	}
	For(i,1,n)
		printf("%d ",a[ans[i]]);
}

```
第一篇题解写的不好多多包涵~~


然后希望自己HNOI2018能考好qwq


---

## 作者：dengyaotriangle (赞：27)

**UPD 2021/3/26 感谢 @LiM_817 发现了一些笔误，已修改**

我认为其它题解中 $f$ 数组（也就是“右边有多少空位”之类的表述）的定义多少不太明了或有问题，于是写一个我认为清楚一些的：

首先很容易想到一个（只在 $d_i$ 互不相同时正确） 的贪心，这个贪心的思路以及反例参考其它题解。

正解则是考虑**按位确定**：考虑从 $1$ 到 $n$ 依次确定该点选了哪个值，确定 $i$ 这个位置的值时，我们选取满足以下条件的值：

1. 使得这个东西确定之后，存在一种 $i+1$ 到 $n$ 的分配方案，使得总方案合法。
2. 尽可能大。

容易证明这个过程结束之后取到的就是字典序最大的合法方案。（这个方法对于其它求字典序最大值的方案也适用，是一个非常套路的东西）

那么接下来的思路将会是这样的：

- 既然是逐位确定，那我们考虑动态确定，动态维护接下来确定什么合法
- 确定了一个点不仅仅确定了这个值，其实相当于限制了它的子树内的点都 $\geq x$，或者说，这是对之后的尚未确定的值进行限定。
- 我们发现上述限定是充分必要的，于是可以直接维护它作为是否合法的判据。
- 根据限制满足的贪心性质，发现这个东西可以奇妙地使用线段树维护。



------------

考虑本题中我们如何判定一个值的选取是否合法。

若我们新确定了某个位置的值，考虑确定了它之后，会怎么影响接下来的点取值的合法性。

考虑限制：一个子树内的所有点要 $\geq$ 其根。

令一个点子树大小为 $s_u$

那我们知道，若这个位置 $u$ 确定是 $x$，那么其子树内必须也有 $s_u$ 个 $\geq x$ 的数。

而且这个条件还是充分必要的：若找得到 $s_u$ 个 $\geq x$ 的数，那么一定存在分配方案使得 $u$ 这颗子树合法。

而我们发现我们确定 $u$ 时，其子树内还肯定没有已经确定了的地方，所以它带来的限制就是，要有 $s_u$ 个，$\geq x$ 的数分配给这棵子树。注意之前说明的条件充要，所以这个限制是**完备**的，或者说，**等价于原条件的**。

所以我们引入的限制就形如：**需要拿走 $a_i$ 个 $\geq b_i$ 的数**。

但是我们发现，这个条件其实需要在确定 $u$ 的直接孩子的时候进行去除。

也就是说，每当我们发现一个节点的父亲有着上述限制，须将其删除，并且换成一个 “需要拿走一个 $d_i$”——因为父亲的值已经确定，所以我们需要把这个值去掉一个。
（刚开始就去除没有任何问题，因为孩子是一个连续区间，所以这个条件在开始被满足就一定一直被满足）


而直观上来讲，我们干的事情其实是：**把整棵子树的限制，分成根的限制和这颗子树挂在根上每棵子树的限制。**

所以我们还需要支持限制的 **删除操作**，以及形如 **需要拿走一个 $=b_i$ 的数** 的操作

限制说完了，怎么判断哪些值满足限制？若我们现在想给 $u$ 这个点分配值：

我们发现，我们只需要找到最大的值 $p$，使得存在满足条件的一种拿去方案，使得还剩下 $s_u$ 个 $\geq p$ 的数。

考虑令 $f_i$ 代表只考虑 $b_j\geq i$ 的限制，还剩下多少个 $\geq i$ 的数。考虑 $\min_{i\leq k} f_i$ ，我们发现这代表最多还剩下几个 $\geq k$ 的数。

原因是因为为了让剩下的 $\geq k$ 的更多，自然是从 $b_j$ 从大到小考虑每个限制，然后每次都拿最小的，然后其实类似一个不断对于剩下的数压栈弹栈的过程，考虑限制的时候，先压进来加入新来的数，然后每次选最小的弹掉，自然地，栈的大小的最小值就是答案。而栈的大小就是 $f_i$，若看不懂可以随便选一组限制手动模拟一下。

那么我们发现我们已经会求这个”最大的合法值了“：考虑使用线段树维护 $f$，一个限制就相当于 $[1,b_i]$ 的值 $-a_i$，然后找到最大的符合限制的值就是找到最靠右的，前缀 $\min\geq s_u$ 的位置，这个可以通过线段树二分实现。

而最后剩下的一个操作，需要拿走一个 $=b_i$ 的数 ，对应在 $f$ 数组上是 $[1,b_i]$ 的值 $-1$，也可以维护。

而 $f_i$ 的初始值就是 $d$ 中 $\geq i$ 的数的个数。

其实这个操作和另一个修改操作的形式一模一样，但一个是 $\geq b_i$，一个是 $=b_i$，其实这个的道理在于根据上面的贪心论述，我们每次都是拿尽可能小的，而 $=b_i$ 的限制存在的前提是一定能取到一个 $=b_i$ 的（因为需要合法），所以 $=b_i$ 的限制与 $\geq $ 其实一样，所以二者体现在 $f$ 上的影响是一模一样的。


参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int maxn=500005;

int n,m;double k;
int val[maxn],sval[maxn],cnt[maxn];

struct node{
    int tg,mi;
    node* c[2];
}pool[maxn<<1];int ps;

void pu(node* rt){
    rt->mi=min(rt->c[0]->mi,rt->c[1]->mi);
}
void pd(node* rt){
    rt->mi+=rt->tg;
    if(rt->c[0]){
        rt->c[0]->tg+=rt->tg;
        rt->c[1]->tg+=rt->tg;
    }
    rt->tg=0;

}
node* bt(int l,int r){
    node* nw=pool+ps++;
    if(l==r){
        nw->mi=cnt[l];
    }else{
        nw->c[0]=bt(l,(l+r)>>1);nw->c[1]=bt(((l+r)>>1)+1,r);
        pu(nw);
    }
    return nw;
}

void chg(node* rt,int cl,int cr,int l,int r,int d){
    int cm=(cl+cr)>>1;
    pd(rt);
    if(l==cl&&r==cr)rt->tg+=d,pd(rt);
    else if(r<=cm)chg(rt->c[0],cl,cm,l,r,d),pd(rt->c[1]),pu(rt);
    else if(l>cm)chg(rt->c[1],cm+1,cr,l,r,d),pd(rt->c[0]),pu(rt);
    else chg(rt->c[0],cl,cm,l,cm,d),chg(rt->c[1],cm+1,cr,cm+1,r,d),pu(rt);
}

int find(node* rt,int cl,int cr,int s){
    int cm=(cl+cr)>>1;
    pd(rt);
    if(cl==cr){return cl-1;}
    else{
        pd(rt->c[0]);int w=rt->c[0]->mi;
        if(w<s)return find(rt->c[0],cl,cm,s);
        else return find(rt->c[1],cm+1,cr,s);
    }
}

int ans[maxn];
int sz[maxn];
bool vis[maxn];


int main(){
    ios::sync_with_stdio(0);cin.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>val[i];
    sort(val+1,val+1+n);
    for(int i=1;i<=n;i++)sval[i]=val[i];
    m=unique(sval+1,sval+1+n)-sval;
    for(int i=1;i<m;i++)cnt[i]=upper_bound(val+1,val+1+n,sval[i])-lower_bound(val+1,val+1+n,sval[i]);
    for(int i=m-1;i>=1;i--)cnt[i]+=cnt[i+1];
    node* rt=bt(1,m);
    for(int i=n;i>=1;i--){
        sz[i]++;
        sz[(int)floor(i/k)]+=sz[i];
    }
    vis[0]=1;
    for(int i=1;i<=n;i++){
        int fa=(int)floor(i/k);
        if(!vis[fa]){
            vis[fa]=1;
            chg(rt,1,m,1,ans[fa],sz[fa]-1);
        }
        int v=find(rt,1,m,sz[i]);
        ans[i]=v;
        chg(rt,1,m,1,v,-sz[i]);
    }
    for(int i=1;i<=n;i++)cout<<sval[ans[i]]<<' ';
    return 0;
}
```


---

## 作者：ww3113306 (赞：26)

# [广告](https://www.cnblogs.com/ww3113306/p/9867556.html)
一开始翻网上题解看了好久都没看懂，感觉很多人都讲得不太详细，所以导致一些细节的地方看不懂，所以这里就写详细一点吧，如果有不对的or不懂的可以发评论在下面。

　　首先有一个比较明显的50分贪心：

　　先把d排好序，然后按从小到大的顺序贪心的给每个点选值，同等条件下优先编号大的，于是越小的值会越趋近于放在编号越大的上面。

　　但是这样在数字重复的情况下是不对的， 比如下面这组数据：

　　4 3.0

　　1 1 2 2

　　贪心会得到1 1 2 2 ,而正确答案是1 2 2 1.

　　因此换个角度考虑，在什么情况下一个点可以取到一个值x？

　　设这个点的子树大小为Size[i],那么这个点可以取到值x，当且仅当大于等于x的还没被取的值的个数 >= Size[i]，原因应该是很好理解的，毕竟还要有Size[i] - 1和比x大的值放在i的子树上才行。

　　因此我们先对d从小到大排序去重，统计每个值的出现次数cnt[x], 然后对于每个数统计一个f[x]表示大于等于x的还没被取的值的个数为f[x].

　　

　　假设我们给节点i匹配上了一个值x，那么这个策决策对小于等于x的值的影响是确定的，因此将所有小于等于x的值的f数组都减小SIze[i],表示这些值的右边可以取的值又减小了Size[i]个。

　　我们将和这个操作称为“预定”，因为我们现在并不知道点i的子树分别会选择哪些值，但我们知道它们要选几个值，所以我们相当于先告诉后面的人，这个节点i已经坐到了x这个值上，并且要求后面的人为它的子树留Size[i] - 1个座位。

　　因为这个决策对大于x的值的影响是不确定的，我们暂时没有修改它，但其实这个决策会对它产生影响，那么对于一个值k，在取它之前的决策到底对它产生了什么样的影响呢？

　　对于一个值k，它的真正的f[k]其实是min(f[1], f[2], f[3] ....f[k]),因为每个f值都相当于一个后缀和，一个合法的值不能使得f[k]反而比它前面的f值更大，因为前面的f值要比f[k]统计了更多的数。

　　

　　因为题目要求使得字典序最大，所以我们按照编号从小到大给节点分配值显然是最优的。

　　因此我们每次就是要在剩下的数上寻找一个最靠右的，并且使得min(f[1], f[2], f[3] ...f[k]) >= Size[i]的k。

　　因为涉及区间修改和查询，我们使用线段树来维护所有的f值，每次选好一个值，我们就把一些已经确定的影响从线段树中删除（对一个区间进行- Size[i]的操作）。

　　对于每次选值，我们都可以在线段树上进行二分来查找满足上述粗体字要求的最靠右的值。

　　值得注意的是，在每次查询前，如果一个节点的父亲的影响还没有被撤销的话，应该要撤销它父亲的影响。（即把父亲给子树占的座给加回来 ：1 ~ 父亲匹配值的f值 加上 Size[fa] - 1）

　　为什么呢？

　　想象一下，如果不撤销父亲的影响的话，岂不是相当于别人特意给你占了座，结果你自己还不能坐上去？

　　因为一个节点的儿子都是连续的，所以我们在撤销的父亲的影响后，会马上把不应该撤销的部分给补上（儿子的子树在不断的加上来），所以不用担心对之后的决策造成影响
  ```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 551000
#define ac 2500000

int n, w, go, tot, rnt;
double k;
int ans[AC], cnt[AC], father[AC], Size[AC], f[AC], s[AC];//cnt[i]表示排名第i位的d值出现的次数
bool done[AC];

inline int read()
{
    int x = 0;char c = getchar();
    while(c > '9' || c < '0') c = getchar();
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x;
}

inline int Min(int a, int b){
    return a > b ? b : a;
}

struct seg_tree{
    int tree[ac], lazy[ac], l[ac], r[ac];
    
    inline void update(int x){
        tree[x] = Min(tree[x * 2], tree[x * 2 + 1]);
    }
    
    inline void pushdown(int x)
    {
        if(lazy[x])
        {
            int ll = x * 2, rr = ll + 1;
            tree[ll] += lazy[x], tree[rr] += lazy[x];
            lazy[ll] += lazy[x], lazy[rr] += lazy[x];
            lazy[x] = 0;
        }
    }
    
    void build(int x, int ll, int rr)
    {
        l[x] = ll, r[x] = rr;
        if(ll == rr){tree[x] = f[ll]; return ;}
        int mid = (ll + rr) >> 1;
        build(x * 2, ll, mid), build(x * 2 + 1, mid + 1, rr);
        update(x);
    }
    
    void change(int x, int ll, int rr)
    {
        pushdown(x);
        if(l[x] == ll && r[x] == rr)
        {
            tree[x] += w, lazy[x] += w;
            return ;
        }
        int mid = (l[x] + r[x]) >> 1;
        if(rr <= mid) change(x * 2, ll, rr);
        else if(ll > mid) change(x * 2 + 1, ll, rr);
        else change(x * 2, ll, mid), change(x * 2 + 1, mid + 1, rr);
        update(x);
    }
    
    void find(int x)
    {
        pushdown(x);
        if(l[x] == r[x]){go = tree[x] >= w ? l[x] : l[x] - 1; return ;}
        if(tree[x * 2] >= w) find(x * 2 + 1);
        else find(x * 2); 
        update(x);
    }
}T;

void pre()
{
    n = read(), scanf("%lf", &k);
    for(R i = 1; i <= n; i ++) s[i] = read(), Size[i] = 1;
    sort(s + 1, s + n + 1);
    for(R i = 1; i <= n; i ++)
    {
        ++ cnt[tot + 1];
        if(s[i] != s[i + 1]) s[++tot] = s[i];
    }
    for(R i = tot; i; i --)
        f[i] = f[i + 1] + cnt[i];//存下每个值右边有多少个可供选择的值
    for(R i = n; i; i --) 
        father[i] = floor(i / k), Size[father[i]] += Size[i];//获取每个节点的Size
    T.build(1, 1, tot);
}

void work()
{
    for(R i = 1; i <= n; i ++)
    {
        int fa = floor(i / k);
        if(fa && !done[fa]) w = Size[fa] - 1, T.change(1, 1, ans[fa]);//如果有父亲的话，要先把给儿子预定的节点还回来以帮助正确判断
        w = Size[i], done[fa] = true;
        T.find(1), w = -Size[i];//先找到一个合法的点
        T.change(1, 1, go);//再减去已经被预定的位置
        ans[i] = go;
        printf("%d ", s[go]); 
    }
    printf("\n");
}

int main()
{
//    freopen("in.in", "r", stdin);
    pre();
    work();
//    fclose(stdin);
    return 0;
}
```

---

## 作者：AubRain (赞：21)

**题意:**

给出 $k$ 和 $n$ 个数，构造一个序列使得 $d[i]>=d[i/k]$，并且字典序最大。

本题一个贪心的思路已经被证明是错误的了，~~虽然我在考场上的时候连贪心都没想出来~~

**正确的解法：**

先**从大到小排序**，每次找一个**最靠左**的位置，使得这个位置左边**足够放下当前节点的子树**。若有多个值相同，应该放到**最右边那个值**那里

显然**满足单调性**，毕竟如果某个位置可以满足，那么该位置右边的位置也一定能够满足。

那么想到了什么？没错！就是二分+线段树！



**具体做法：**

1、先建成一棵树，其中 **$i$ 节点是 $i/k$ 节点的儿子**，表示 $i$ 号节点应该>= $i/k$ 号节点。记录下每个节点的子树大小 $size[i]$。

2、建线段树，记录下来每个区间的**最小值**，用来查询。第 $i$ 个位置左边有 $i$ 个能用的位置。

3、每次在线段树，查找一个位置使得该**位置左边能用的位置个数>=该节点的子树大小。**如果多值相同，就到最右边那里。

4、更新后方位置左边能用的位置个数，都减去 $size[i]$。

5、重复 $n$ 次，每次复杂度 $log(n)$，总复杂度 $O(nlogn)$。




------------

先说我的一个错误的想法，可以忽略：

序列中每个点如果被“预留”了或者被用了，就设为 $0$，否则设为 $1$。

每次二分查找前缀和，找一个位置，使得该位置左边的和>= $size[i]$，然后把左边的节点 $size[i]$ 个节点都赋值为 $0$ 。

为什么错了呢？因为找到一个位置后，若有多值相同，到达右边后，可能左边有 $10$ 个位置，但只用把 $5$ 个位置预留设为 $0$ 。这时候就**没法确定到底预留哪几个位置**，没法赋值，所以当有值相同的时候就 $RE$ 了，并且复杂度 $O(nlog$ $^2$ $n)$ 也不对


------------
**下面是正解：**

值得注意的是，$find$ 函数查找的时候，**要根据区间最小值来确定是向左儿子还是右儿子继续找**

$nxt$ 数组用来求同一个值的最右边在哪个位置。更新的时候向左移一个，防止取到相同的位置。

还有，线段树修改的时候，最小值直接加上修改的值就行了，不用乘上区间长度

还有，更新儿子节点的时候，**要把他的父亲给他预留的位置先去掉**

```cpp
#include<bits/stdc++.h>
#define N 500005
#define r1 (p<<1)
#define r2 (p<<1|1)
#define mid ((l+r)>>1)

using namespace std;

double k;
int n,a[N],f[N],ans[N];
int size[N],fa[N],nxt[N];
int mn[N<<2],add[N<<2];

inline void rd(int &x){
    x=0;char ch=0;
    while(!isdigit(ch)) ch=getchar();
    while( isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}

void build(int p,int l,int r){
    if(l==r){mn[p]=l;return ;}
    build(r1,l,mid); build(r2,mid+1,r);
    mn[p]=min(mn[r1],mn[r2]);
}
void push(int p){
    if(!add[p]) return ;
    mn[r1]+=add[p];mn[r2]+=add[p];
    add[r1]+=add[p];add[r2]+=add[p];add[p]=0;
}
void change(int p,int L,int R,int d,int l=1,int r=n){
    if(L<=l and r<=R) return add[p]+=d,mn[p]+=d,void(); push(p);
    if(L<=mid) change(r1,L,R,d,l,mid);
    if(R >mid) change(r2,L,R,d,mid+1,r);
    mn[p]=min(mn[r1],mn[r2]);
}
void init()
{
    sort(a+1,a+1+n);reverse(a+1,a+1+n);
    for(int i=n-1;i;i--)
        if(a[i]==a[i+1]) nxt[i]=nxt[i+1]+1;
    for(int i=1;i<=n;i++)
        fa[i]=i/k,size[i]=1;
    for(int i=n;i;i--)
        size[fa[i]]+=size[i];
}
int find(int p,int d,int l=1,int r=n){
    if(l==r) return l+(mn[p]<d); push(p);
    return d<=mn[r2] ? find(r1,d,l,mid) : find(r2,d,mid+1,r);
}
int main()
{
    scanf("%d%lf",&n,&k);
    for(int i=1;i<=n;i++) rd(a[i]);
    init(); build(1,1,n);
    for(int i=1;i<=n;i++)
    {
        if(fa[i]!=fa[i-1]) change(1,ans[fa[i]],n,size[fa[i]]-1);
        int p=find(1,size[i]);
        p+=nxt[p];nxt[p]++;p-=nxt[p]-1;ans[i]=p;
        change(1,p,n,-size[i]);
    }
    for(int i=1;i<=n;i++)
        printf("%d ",a[ans[i]]);
}
```

---

## 作者：StudyingFather (赞：11)

题意很简单，给出一个多叉堆，求一种赋值方案，使得其在满足小根堆性质的情况下，编号靠前的点值尽量大。

## Part 1 贪心

先考虑一种贪心做法。

我们先将原序列从大到小排序。容易发现一个子树内的数一定对应序列的一个连续区间。

为了达到靠前的数尽可能大的目的，我们递归到点 $u$ 时，优先将靠前的区间分配给编号较小的子树，而该子树的根节点则取得该子区间右端点的数（小根堆性质）。

**在 $d_i$ 互不相同的时候**，该做法正确性较为显然。

期望得分：$55$ pts（实际可以拿到 $60$ pts）。

## Part 2 贪心·改

上面的做法只能保证 $d_i$ 互不相同时的正确性，当存在相同的 $d_i$ 时会发生什么？

为了方便描述，我们设 $u$ 的某个兄弟节点为 $x$，$u$ 的某个儿子节点为 $v$。

之前的贪心做法，可能会出现 $d_v>d_x=d_u$ 的情况，在这种情况下，如果将 $x$ 和 $v$ 的值互换，可能会在保证堆性质的前提下，让编号较小的点取得更大值。

因此我们需要稍微改良一下原来的做法。

仍然将原序列从大到小排序。不过与之前不同的是，我们这次按层来遍历。

设 $f_i$ 表示当前数左边还能取多少个数。对于 $u$ 点，因为要满足小根堆性质，需要满足 $f_i \geq siz_u$。

因为序列已经排序，因此 $f_i$ 单调不下降，从而考虑二分查找找出满足 $f_i \geq siz_u$ 的最靠左的 $i$。

这里有一个细节，因为存在 $d_i$ 相等的情况，因此这个最靠左的数字右边，可能还存在与之相等的数字。这里我们选择这一连续段中，最靠右的数字，从而解决了旧贪心的弊端。

考虑用线段树维护这一过程。

剩下的就和 Part 1 的做法差不多了。

```cpp
// Problem: P4364 [九省联考2018]IIIDX
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4364
// Memory Limit: 500 MB
// Time Limit: 2000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
struct seg
{
 int minf,tag;
}s[2000005];
int n;
double k;
int d[500005];
int vis[500005],cnt[500005],fa[500005],siz[500005],res[500005];
vector<int> e[500005];
bool cmp(int x,int y)
{
 return x>y;
}
void dfs(int u)
{
 siz[u]=1;
 for(auto v:e[u])
  dfs(v),siz[u]+=siz[v];
}
void pushup(int root)
{
 s[root].minf=min(s[root<<1].minf,s[root<<1|1].minf);
}
void pushdown(int root)
{
 s[root<<1].minf+=s[root].tag,s[root<<1].tag+=s[root].tag;
 s[root<<1|1].minf+=s[root].tag,s[root<<1|1].tag+=s[root].tag;
 s[root].tag=0;
}
void build(int root,int l,int r)
{
 if(l==r)
 {
  s[root].minf=l;
  return;
 }
 int mid=(l+r)>>1;
 build(root<<1,l,mid);
 build(root<<1|1,mid+1,r);
 pushup(root);
}
void update(int root,int cl,int cr,int l,int r,int x)
{
 if(r<cl||cr<l)return;
 if(l<=cl&&cr<=r)
 {
  s[root].minf+=x;
  s[root].tag+=x;
  return;
 }
 pushdown(root);
 int mid=(cl+cr)>>1;
 update(root<<1,cl,mid,l,r,x);
 update(root<<1|1,mid+1,cr,l,r,x);
 pushup(root);
}
int query(int root,int l,int r,int x)
{
 if(l==r)
  return s[root].minf>=x?l:l+1;
 pushdown(root);
 int mid=(l+r)>>1;
 if(s[root<<1|1].minf<x)
  return query(root<<1|1,mid+1,r,x);
 else
  return query(root<<1,l,mid,x);
}
int main()
{
 ios::sync_with_stdio(false);
 cin>>n>>k;
 for(int i=1;i<=n;i++)
  cin>>d[i];
 sort(d+1,d+n+1,cmp);
 for(int i=n-1;i;i--)
  if(d[i]==d[i+1])cnt[i]=cnt[i+1]+1;
 for(int i=1;i<=n;i++)
 {
  fa[i]=i/k;
  e[fa[i]].push_back(i);
 }
 dfs(0);
 build(1,1,n);
 for(int i=1;i<=n;i++)
 {
  if(fa[i]&&!vis[fa[i]])
  {
   vis[fa[i]]=1;
   update(1,1,n,res[fa[i]],n,siz[fa[i]]-1);
  }
  int pos=query(1,1,n,siz[i]);
  pos+=cnt[pos];
  cnt[pos]++;
  res[i]=pos;
  update(1,1,n,res[i],n,-siz[i]);
 }
 for(int i=1;i<=n;i++)
  cout<<d[res[i]]<<' ';
 return 0;
}
```

---

## 作者：Celtic (赞：7)

首先把题目转化成给一棵树赋权值，让他成为一个小根堆，字典序最大。

考虑贪心，对于当前点 $u$ 的子树，选择当前最大的 $siz_u$ 个权值，然后递归求解。这样在 $d_i$ 互不相同的时候容易发现是正确的。

如果 $d_i$ 中存在相同的，我们发现当在决策 $u$ 的子树时，子树内可以选择和 $u$ 相等的权值，把大的权值让给和 $u$ 的同深度的其他点（显然点的编号越小深度越小）。

这个时候我们就不能递归每个子树了，正确的做法是按照点的编号来决策。

先将 $d$ 从小到大排序。

假设当前点是 $u$ ，我们找到最大的可能权值在排好序的数组中的最小位置，让 $u$ 选择这个位置，然后在 $u$ 后面预留出 $siz_u$ 个位置，这个可以通过维护 $f_i$ 表示 $i$ 后面最多有多少个剩余位置来实现，预留就是在 $[1,i]$ 区间减 $1$ ，用线段树维护。

可是这样我们发现 $i$ 的值不是真实的 $f$ ，同时因为我们无法确定预留了哪些权值，所以真实的 $f$ 没办法直接维护。

这个时候我们让之前所有预留的值都尽量靠前选（跳过 $i$ ），这是为了让当前的决策点尽量靠后，此时的 $f_i$ 就是维护的数组的前缀最小值，这个模拟一下这个过程就能得出。

我们发现 $f_i$ 具有单调性，所以决策每个点的时候在线段树上二分就可以了。

注意在决策点 $u$ 时要把父亲为他预留的位置空出来。

时间复杂度 $O(n\log n)$

$\sf{Code}$

```cpp

#include<bits/stdc++.h>
#define N 2001001
#define MAX 2001
using namespace std;
typedef long long ll;
typedef double db;
const ll inf=1e18;
inline void read(ll &ret)
{
	ret=0;char c=getchar();bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,d[N],pos[N],siz[N],a[N];
db k;
struct node
{
	ll minn,tag,ls;
}seg[N];
inline node operator +(node x,node y)
{
	return node{min(x.minn,y.minn),0ll,x.ls};
}
inline void add(ll pos,ll num)
{
	seg[pos].minn+=num;
	seg[pos].ls+=num;
	seg[pos].tag+=num;
	return;
}
inline void pushdown(ll pos)
{
	add(pos<<1,seg[pos].tag);
	add(pos<<1|1,seg[pos].tag);
	seg[pos].tag=0;
	return;
}
inline void build(ll pos,ll l,ll r)
{
	if(l==r)
		seg[pos].minn=seg[pos].ls=n-l+1;
	else
	{
		ll mid=l+r>>1;
		build(pos<<1,l,mid);
		build(pos<<1|1,mid+1,r);
		seg[pos]=seg[pos<<1]+seg[pos<<1|1];
	}
	return;
}
inline void upgrade(ll pos,ll l,ll r,ll s,ll t,ll num)
{
	if(l>=s&&r<=t)
		return add(pos,num);
	else if(l>t||r<s)
		return;
	pushdown(pos);
	ll mid=l+r>>1;
	upgrade(pos<<1,l,mid,s,t,num);
	upgrade(pos<<1|1,mid+1,r,s,t,num);
	seg[pos]=seg[pos<<1]+seg[pos<<1|1];
	return;
}
inline ll query(ll pos,ll l,ll r,ll siz,ll d)
{
	if(l==r)
		return l;
	ll mid=l+r>>1;
	pushdown(pos);
	if(siz<=min(seg[pos<<1].minn,min(d,seg[pos<<1|1].ls)))
		return query(pos<<1|1,mid+1,r,siz,min(d,seg[pos<<1].minn));
	return query(pos<<1,l,mid,siz,d);
}
bool vis[N];
map<ll,ll>mp;
signed main()
{
	read(n);
	cin>>k;
	for(int i=1;i<=n;i++)
		read(a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		if(!mp[a[i]])
			mp[a[i]]=i;
	}
	build(1,1,n);
	for(int i=1;i<=n;i++)
		siz[i]=1;
	for(int i=n;i;i--)
		siz[ll(floor(i/k))]+=siz[i];
	for(int i=1;i<=n;i++)
	{
		ll fa=ll(floor(i/k));
		if(fa)
			upgrade(1,1,n,1,pos[fa],siz[i]);
		ll tmp=a[query(1,1,n,siz[i],inf)];
		pos[i]=mp[tmp];
		mp[tmp]++;
		upgrade(1,1,n,1,pos[i],-siz[i]);
	}
	for(int i=1;i<=n;i++)
		printf("%lld ",a[pos[i]]);
	exit(0);
}
```

---

## 作者：tommymio (赞：6)

> 题目简述：一棵树，要对树上的每个点标上给定的权值，满足每个点上的权值都不大于子树内点的权值，并使这棵树，编号从小到大的点权字典序最大。 （**这棵树满足一些性质**，下文会说）
>
> ——Sakits

$60$ $\text{pts}$ 贪心的写法自然是很好想的，根据题意建出一棵树来即可，把 $d_i$ 从小到大排序，根据子树大小分配区间。**这棵树的根节点为 $0$**。因为如果不为 $0$ ，这棵树可能会变为森林。

由于分配到叶子节点时，区间其实就是一个点，所以我们每次只需要考虑这棵子树的可以被分配到的区间和这棵子树的根被分配到的数。可以证明，**当 $d_i$ 不重复时**，一个树所被分配到的区间会被它的子树分成连续的几段。因此直接 $\text{dfs}$ 贪心即可。

代码大概是这个样子。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
std::vector<int> mp[500005];
int size[500005],res[500005],a[500005];
void prework(int x) {
	size[x]=1;
	for(register int i=0;i<mp[x].size();++i) {prework(mp[x][i]);size[x]+=size[mp[x][i]];}
}
void dfs(int x,int l,int r) {
	res[x]=a[l++];
	for(register int i=0;i<mp[x].size();++i) {
		int y=mp[x][i];
		dfs(y,r-size[y]+1,r);
		r=r-size[y];
	}
}
int main() {
	int n;
	double k;
	scanf("%d%lf",&n,&k);
	for(register int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(register int i=1;i<=n;++i) mp[(int)(i*1.00/k)].push_back(i);
	std::sort(a+1,a+1+n);
	prework(0);
	dfs(0,0,n);
	for(register int i=1;i<=n;++i) printf("%d ",res[i]);
	return 0;
}
```

但是很抱歉，这个做法是假的，只有 $60 \text{ pts}$，由于**存在重复的 $d_i$**。

就有了这组 $\text{hack}$ 数据：``4 3 1 1 2 2``。

如果按照上述贪心思路，输出为 `` 1 1 2 2 ``，但正确输出为 ``1 2 2 1``。

正确输出的图画出来大概是这个样子的：

![](https://cdn.luogu.com.cn/upload/image_hosting/zaur71b2.png)

因为存在重复，所以 $4$ 号点不会选择 $2$ ，而会选择 $1$ ，把 $2$ 留给 $2$ 号节点。

通过这组数据我们发现，基于 $\text{dfs}$ 的贪心都不能够确保正确性，由于存在重复，所以儿子节点可能可以选择和父亲节点相同的数，把更大的数留给其他节点，使解更优。显然这一点不满足贪心的性质，于是我们考虑换一种方式来贪心。

题目要求编号从小到大的点权字典序最大，那我们就考虑从 $1-N$ 遍历，对于每个点，令他的点权尽可能的大。

对于从 $1-N$ 遍历的正确性的证明，这里需要几个性质：

- 儿子编号一定大于父亲编号。
- 根据构造这棵树的过程可以得出，对于深度为 $dep$ 的任意点 $i$ 的编号 $id_i$ ，都有深度为 $dep+1$ 的任意点 $j$ 的编号 $id_j$ ，令 $id_i<id_j$，即深度为 $dep$ 的点的编号永远小于深度为 $dep+1$ 的点的编号。 

于是我们就发现，从 $1-N$ 的遍历，必然从深度为 $1$ 的层次逐层遍历到深度为 $maxDepth$ 的层次，所以对于一个节点 $i$ ，之前必然遍历过其父亲 $f_i$ ，且该父亲所在的深度的所有节点已被遍历，这是一个很好的结论。

那么问题就在于，如何找出一个满足条件的点权。

我们总结一下，这个尽可能大的点权需要满足哪些条件：

- 其子树内所有点的权值不小于该点权。
- 这个点权没有被之前的点选过。

所以我们想到，一个点 $i$ 的点权在**从大到小**排序后未被选的 $a_i$ 中的排名为 $size[i]$，因为至少要有 $size[i]-1$ 个数不小于 $size[i]$，这一点和贪心的思路非常类似。

并且，由于存在重复，若我们选择的 $a_i$ 有其他的 $a_i$ 和它相同，应选择最右端的一个。证明也很简单，如果有多个数满足条件，肯定不会先分配大的数给它的子树，因为从 $1-N$ 遍历，当前层次的节点取到更大的数会更优，这一点前面已经证明过了。

那么我们就考虑实现，设 $f_i$ 为当前这个数左边还有多少数能取，可以发现 $f_i$ 一定单调不下降，于是就可以二分找出这个符合条件的位置。然后对于每次预留子树的操作，都需要做区间修改和单点查询，那么线段树维护即可。

值得注意的是，在线段树操作过程中可能会出现 $f_i$ 没有单调性的情况，这是修改的缺陷，事实上 $f_i$ 一定存在单调性，所以我们必须维护一个 $f_i$ 的**区间最小值** 而非区间最大值。

**Show the Code**
```cpp
/*============================
 * Author : tommy0103
 * Problem : IIIDX
 * Algorithm : SGT
 * Time : 2020.3.30
 * ==========================*/
#include<cstdio>
#include<vector>
#include<algorithm>
#include<unordered_map>
#define min(a,b) ((a)<(b)? (a):(b))
int n;
double k;
std::vector<int> mp[500005];
int a[500005],size[500005],res[500005],fa[500005],vis[500005],cnt[500005];
int segL[2000005],segR[2000005],minn[2000005],tag[2000005];
inline bool cmp(int x,int y) {return x>y;}
void build(int p,int l,int r) {
	segL[p]=l;segR[p]=r;minn[p]=0x3f3f3f3f;
	if(l==r) {minn[p]=l;return;}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	minn[p]=min(minn[p<<1],minn[p<<1|1]);
}
inline void spread(int p) {
	if(tag[p]!=0) {
		minn[p<<1]+=tag[p];minn[p<<1|1]+=tag[p];
		tag[p<<1]+=tag[p];tag[p<<1|1]+=tag[p];
		tag[p]=0;
	}
}
void change(int p,int l,int r,int v) {
	if(l<=segL[p]&&segR[p]<=r) {minn[p]+=v;tag[p]+=v;return;}
	spread(p);
	int mid=segL[p]+segR[p]>>1;
	if(l<=mid) change(p<<1,l,r,v);
	if(r>mid) change(p<<1|1,l,r,v);
	minn[p]=min(minn[p<<1],minn[p<<1|1]);
}
int ask(int p,int len) {
	if(segL[p]==segR[p]) return minn[p]>=len? segL[p]:segL[p]+1;
	spread(p);
	if(minn[p<<1|1]<len) return ask(p<<1|1,len);
	return ask(p<<1,len);
}
void prework(int x) {
	size[x]=1;
	for(register int i=0;i<mp[x].size();++i) {fa[mp[x][i]]=x;prework(mp[x][i]);size[x]+=size[mp[x][i]];}
}
void print(int p) {
	if(segL[p]==segR[p]) {printf("[%d,%d]%d\n",segL[p],segR[p],minn[p]);return;}
	spread(p);
	print(p<<1);print(p<<1|1);
}
int main() {
	scanf("%d%lf",&n,&k);
	for(register int i=1;i<=n;++i) scanf("%d",&a[i]);
	std::sort(a+1,a+1+n,cmp);
	for(register int i=n-1;i>=1;--i) cnt[i]=(cnt[i+1]+1)*(a[i]==a[i+1]);
	for(register int i=1;i<=n;++i) mp[(int)(i*1.00/k)].push_back(i);
	build(1,1,n);prework(0);
	for(register int i=1;i<=n;++i) {
		if(fa[i]&&!vis[fa[i]]) {
			change(1,res[fa[i]],n,size[fa[i]]-1);//fa[i]已经被选了
			vis[fa[i]]=1;
		}
		int pos=ask(1,size[i]);
		pos+=cnt[pos];++cnt[pos];res[i]=pos;
		change(1,res[i],n,-size[i]);
	} 
	for(register int i=1;i<=n;++i) printf("%d ",a[res[i]]);
	return 0;
}
```

---

## 作者：sry_ (赞：5)

#### IIIDX

##### 题意

给定一棵树，保证相同深度的点连续，你需要给每个点在 $v_i$ 中选取一个作为该点权值，且父亲的权值小于该点。

你需要最大化序列的字典序。 

$1\leq n\leq 5\times 10^5$ 。

##### 题解

本题解从二分图匹配的角度解决了该问题，并说明了贪心的正确性（

根据题目可以想到一个比较 $\text{trival}$ 的贪心，每次先将最右子树遍历以保证最左儿子的权值最大。

然后你就获得了 $60$ 分的成绩，打开一看仅过掉了 $v_i$ 互不相同的情况。

考虑这个算法的正确性，我们仅保证了最优化最左儿子的代价，但是 $=$ 的性质可以对于右儿子进行调整，但是贪心无法做到。

而对于 $v_i$ 互不相同的情况，由于不会出现 $=$ ，那么显然是正确的。 

那么我们只能枚举当前位置判断是否后面存在解，一直最优化此过程得到的一定是字典序最大的。

现在的问题变成了：如何判断是否存在一种方案给未给定点定权值满足题意？

稍微转化题意：我们当前可以得到一些限制：必须选择 $a_i$ 个 $\geq b_i$ 的，需要满足所有的限制。为了方便将其限制写成 $(a_i,b_i)$

这是一个简单的贪心，按照 $a_i$ 排序从小到大依次从左面开始选择。但是并没有显式的得到更优秀的判断条件。

考虑建二分图，左侧代表未匹配结点 $\sum a_i$ 个，右侧代表还未选择的 $v$ 。

那么对于限制 $(a_i,b_i)$ ，只需要将左侧 $a_i$ 个连向 $b_i$ 的后缀。判断条件为是否该图存在完美匹配。

考虑 $\text{Hall}$ 定理，我们将所有限制按 $b_i$ 排序，可以发现只要判断后缀，即对于 $\forall i,S=[i,i+1,...]$ ，$|S|\leq |N(S)|$ 。

即 $\forall i,\sum_{j=i} a_j \leq W_{b_i}$ ，$W_{b_i}$ 表示 $b_i$ 后面未匹配点的个数  。

移项可得 $W_{b_i}-\sum_{j=i} a_j\geq 0$ ，那么我们仅需要判断是否对于每个后缀剩余的位置都需要 $\geq 0$ 。

那么我们只需要维护每个位置的 $W-\sum_{在他位置之后的} a$ 是否均 $\geq 0$  ，由于 $\text{Hall}$ 定理，这个条件是充要的。

故每次到一个需要判断的点撤销之前父亲的操作在新加入一个操作，判断序列的最小值是否 $\geq 0$ 。

整个过程仅需要一个数据结构支持查询最小值，区间加，线段树维护即可。

判断是否加入可以线段树二分，故整体的时间复杂度为 $\mathcal O(n\log n)$ 。

---

## 作者：FZzzz (赞：4)

两年半以前死命看不懂这题题解，现在再做感觉也没那么难！

题意：给你一棵以 $0$ 为根树和一堆权值，你要把这些权值分给除 $0$ 以外的点，使得每个点的权值不小于父亲，在此基础上 bfs 序的权值的字典序最大。这个 $k$ 的作用其实就是告诉你编号是 bfs 序，没什么其他的神秘含义。

字典序最大肯定是从前往后贪心，我们需要知道一个前缀是不是合法的。

先考虑最前面的几步，从特殊到一般地思考。既然是 bfs 序，我们来看看第一层的某个前缀合法的条件。实际上我们只需要每个已经被考虑的点，它能找出若干个不小于它自己的权值塞满它的子树，并且每个权值只被分配给一个子树。

照着这个思路，我们发现所有权值不相同的部分分就已经可以解决了：只需要按照后序遍历（或者叫 exit 序？）从大到小分配权值即可。这样你可以直接拿到至少 55 分，在当年算是很可观的分数了。

但很可惜，这个方法在有相等权值时行不通。比如下面这组数据：
```plain
4 3
1 1 2 2
```
问题出在哪里呢？实际上，上面这个做法依赖于，对每个子树和一些权值，我们需要总是能在其中找到一个权值，满足这些权值中不小于它的恰好有子树大小个。也就是说，需要权值互不相同。

那么我们重新思考这个限制意味着什么，其实这是一个经典模型。我们把权值从小到大拍到一个序列上，并且在决定一个点的权值以后，我们把它放在和这个权值相同的，第一个还没有被前面的点占用的位置上。那么，我们的限制实际上是：对于每个后缀，放在它其中的点的子树大小之和不大于这个后缀的长度。

维护这个东西也很经典，我们直接对每个后缀维护它的长度减去其中的点的子树大小之和。那么，找最大的能放的位置就是第一个小于子树大小的位置的左边一个，当然我们实际上把它放到跟这个位置权值相同的第一个没有被占的位置上。然后对维护的东西的影响是前缀加。所以用线段树维护。

为什么这样不会找到一个已经被占掉的位置呢？因为这样的位置对应的后缀的这个值一定不大于他右边的位置。

现在我们已经可以决定第一层所有点的权值了，我们来看看决策其他点时的限制。发现其实我们决策到一个点时，只需要把它的子树从它父亲的子树里去掉就可以了，这也相当于区间加。至于它的权值不小于父亲的权值这个限制，由于我们已经是要选择最大的合法权值，所以这个限制自动被满足了。

至此我们在 $O(n\log n)$ 的时间内完整解决了问题。因为我比较懒所以讲得比较抽象，可以看代码帮助理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=5e5+5;
int n,a[maxn],fa[maxn],sz[maxn];
int d[maxn],p[maxn],c[maxn];
struct node{
	int l,r;
	node* ch[2];
	int mn,add=0;
	void pushup(){
		mn=min(ch[0]->mn,ch[1]->mn);
	}
	node(int l,int r):l(l),r(r),mn(n-r+1){
		if(l==r) return;
		int mid=l+(r-l)/2;
		ch[0]=new node(l,mid);
		ch[1]=new node(mid+1,r);
	}
	void pushtag(int k){
		mn+=k;
		add+=k;
	}
	void pushdown(){
		ch[0]->pushtag(add);
		ch[1]->pushtag(add);
		add=0;
	}
	void modify(int ql,int qr,int k){
		if(ql>r||qr<l) return;
		if(ql<=l&&qr>=r){
			pushtag(k);
			return;
		}
		pushdown();
		ch[0]->modify(ql,qr,k);
		ch[1]->modify(ql,qr,k);
		pushup();
	}
	int query(int x){
		if(l==r) return r;
		pushdown();
		return ch[ch[0]->mn>=x]->query(x);
	}
}*rt;
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	double k;
	scanf("%lf",&k);
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=n;i>0;i--) sz[fa[i]=i/k]+=++sz[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		p[i]=a[i]==a[i-1]?p[i-1]:c[i]=i;
	rt=new node(1,n+1);
	for(int i=1;i<=n;i++){
		if(fa[i]) rt->modify(1,d[fa[i]],sz[i]);
		d[i]=c[p[rt->query(sz[i])-1]]++;
		rt->modify(1,d[i],-sz[i]);
	}
	for(int i=1;i<=n;i++) printf("%d ",a[d[i]]);
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：Sol1 (赞：3)

首先考虑 $d_i$ 互不相同怎么做。

有一个非常简单的思路：对于一棵树，把最小的丢给根，然后把长度为第一个孩子的子树大小的一段后缀丢给它递归构造，再取一段长度为第二个孩子的子树大小的一段丢给第二个孩子递归构造，以此类推。

但是在 $d_i$ 可以相同时，这个做法不再适用。例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/c4rei4nd.png)

贪心给出的结果用红色数字标明，而正确的结果用绿色数字标明。

但是我们还可以沿用这个思路，问题在 **我们显然不能简单地取一个后缀**。

问题来了，不取后缀，怎么取？

首先将 $d$ 降序排序。

首先还是把 **最大的可以取出子树大小个大于等于它的数** 留给自己。但是我们不知道后面要取什么，所以我们不妨就在它上面丢一个标记，告诉比它靠后的数它们少了子树大小个可以取的数。

但是比它靠前的，怎么判断少了多少个呢？

**注意到这是一个递归的过程，所以我们并不需要去关心这些节点是什么，我们只需要保证它们够所有孩子去用。至于怎么用，和这一层就没关系了。**

~~问题解决不了就丢给别人解决~~

所以和它取 $\min$ 就可以了，因为我们暂时还没有确定用哪些，只需要保证够用。

这个取 $\min$ 很难受，可以转化成查询后缀 $\min$。

那么现在问题就变为维护区间减法和前缀 $\min$ 的二分查找，显然可以用线段树。

二分的时候有一个小细节：当这个最优决策点 **刚好卡在一个线段树节点的左端点上** 的时候会二分到不合法的位置，所以要特判。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

struct Segtree {
	int minv[2000005], tag[2000005];
	inline void Build(int p, int pl, int pr) {
		if (pl == pr) {
			minv[p] = pl;
			return;
		}
		int mid = pl + pr >> 1;
		Build(p << 1, pl, mid);
		Build(p << 1 | 1, mid + 1, pr);
		minv[p] = Min(minv[p << 1], minv[p << 1 | 1]);
	}
	inline void Pushdown(int p) {
		if (!tag[p]) return;
		tag[p << 1] += tag[p];
		minv[p << 1] += tag[p];
		tag[p << 1 | 1] += tag[p];
		minv[p << 1 | 1] += tag[p];
		tag[p] = 0;
	}
	inline void Modify(int p, int pl, int pr, int l, int r, int v) {
		if (pl == l && pr == r) {
			minv[p] += v;
			tag[p] += v;
			return;
		}
		Pushdown(p);
		int mid = pl + pr >> 1;
		if (mid >= r) Modify(p << 1, pl, mid, l, r, v);
		else if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);
		else {
			Modify(p << 1, pl, mid, l, mid, v);
			Modify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);
		}
		minv[p] = Min(minv[p << 1], minv[p << 1 | 1]);
	}
	inline int Query(int p, int pl, int pr, int k) {
		if (pl == pr) return pl + (minv[p] < k);
		Pushdown(p);
		int mid = pl + pr >> 1;
		if (k <= minv[p << 1 | 1]) return Query(p << 1, pl, mid, k);
		else return Query(p << 1 | 1, mid + 1, pr, k);
	}
};
int n, fa[500005], d[500005], pnt[500005], siz[500005], ans[500005];
double k;
Segtree sgt;

inline void Read() {
	scanf("%d%lf", &n, &k);
	for (int i = 1;i <= n;i++) {
		scanf("%d", &d[i]);
		fa[i] = floor(i / k);
	}
}

inline void Prefix() {
	sort(d + 1, d + n + 1, greater <int>());
	for (int i = 1;i <= n;i++) siz[i] = 1;
	for (int i = n;i >= 1;i--) siz[fa[i]] += siz[i];
	sgt.Build(1, 1, n);
	for (int i = n - 1;i >= 1;i--) pnt[i] = (d[i] == d[i + 1]) * (pnt[i + 1] + 1);
}

inline void Solve() {
	for (int i = 1;i <= n;i++) {
		if (fa[i] && fa[i] != fa[i - 1]) sgt.Modify(1, 1, n, ans[fa[i]], n, siz[fa[i]] - 1);
		int x = sgt.Query(1, 1, n, siz[i]);
		x += pnt[x]; pnt[x]++;
		ans[i] = x;
		sgt.Modify(1, 1, n, x, n, -siz[i]);
	}
	for (int i = 1;i <= n;i++) printf("%d ", d[ans[i]]);
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：1)

一道很有趣的题。        
        
我们发现每个点只会有一条出边，于是原题形成了一个树形结构。      

60pts 其实很简单，我们观察到有 ```d[i]``` 互不相等的情况。我们直接贪心一下把序列拆分成很多段，可以证明我们这么选出来的字典序是最大的。                  

然而当出现相同 ```d[i]``` 时这个贪心就很成问题，比如说我们现在贪心滴割一段但是割的那一节刚好是一堆相同的数组成的一节，我们完全可以把区间一直右移到相同的数一节的最右端来考虑给 x + 1 节点一个更优的答案。               
(如果对这个地方还是有问题的同学可以去看一些其他题解里面的 hack 数据再回来看一下这里就基本上没什么问题了)       

接着我们就想到了可不可以考虑暴力先做一遍假贪心然后再来暴力换，这个思路很好但是在本题中体现不出来，你换了过后又会影响到原来子树的情况接着就又得去考虑原来子树的情况，反正挺复杂的时间复杂度也不一定能得到保证。          

我们这么考虑，你要字典序最大我是不是就直接从 $1 \sim n$ 给你做，那么我们首先从小到大排序去个重然后记录一下每个数出现的次数以及每个数有多少个大于等于它的数，接着遍历 $1 \sim n$ ：        

- 我们令 ```f[i]``` 为当前状态一个数有多少个大于等于它并且还没有选择的数字。       

- 假若遍历到了 i ，我们首先需要找到在排好序去了重的 d 数组下最靠右边的 ```siz[i] <= f[idx]``` ，那么当前节点的答案就是 ```d[idx]``` 了，现在我们只要可以动态维护 f 数组这道题不就出来了吗？        

- 我们考虑线段树。很显然假若遍历到了 i 找到了一个位置 idx ，那么它就对 $[1 , i]$ 的所有 f 值全部减去了一个 ```siz[i]``` ，因为你当前这个点需要有 ```siz[i]``` 个往子树里面填。           

- 查询时我们首先要把父亲吞掉的位置给“吐”出来，这里其实很好理解，因为你父亲现在本来占了一些数那么现在都考虑你的儿子了，那为什么不把你占的位子给吐出来呢？至于其他点它占着那些数是板上钉钉的事实我们也无法改变。       

- 接着我们考虑我们的查询，难道直接在线段树上维护一个区间```max{f[i]}``` 然后线段树上 find 吗？这么做其实是有问题的，我们发现我们修改时其实只管了 $[1 , i]$ 里面的所有 f 值，但是实际上它对 $[i + 1 , n]$ 里面的 f 值也有影响我们却没有更新，准确来说我们更新不来，因为我们后面的点的 f 值是无法确定的，你总不能暴论滴全部减去一个 ```siz[i]```吧。         

- 所以我们此时可以很巧妙滴利用前缀，我们发现我们线段树里面维护的 f 值其实是不准确的，但是如果这个 f 取一个前缀 min 就一定是正确的。因为你当前的 f 值且只会被前面的选择给影响到，那么我们这么做其实就是抵消了前面的影响。             

- 于是我们直接看当前的前缀 f 是否大于等于查询的 ```siz[i]``` 即可。       

时间复杂度 $O(n \log n)$ 。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int Len = 5e5 + 5;
int n,m,ans[Len << 2],tag[Len << 2],a[Len],lsh[Len],tot,f[Len],cnt[Len],siz[Len],fa[Len],Print[Len];
bool flag[Len];
int ls(int x){return x << 1;}
int rs(int x){return x << 1 | 1;}
void push_up(int x){ans[x] = min(ans[ls(x)] , ans[rs(x)]);}
void build(int p,int l,int r)
{
	tag[p] = 0;
	if(l == r){ans[p] = f[l] ; return;}
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid) , build(rs(p) , mid + 1 , r);
	push_up(p); 
}
void push_down(int p,int l,int r)
{
	if(tag[p]) 
	{
		ans[ls(p)] += tag[p] , ans[rs(p)] += tag[p];
		tag[ls(p)] += tag[p] , tag[rs(p)] += tag[p];
	}
	tag[p] = 0;
}
void update(int p,int l,int r,int nl,int nr,int w)
{
	if(nl <= l && nr >= r) 
	{
		ans[p] += w , tag[p] += w;
		return; 	
	}	
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(nl <= mid) update(ls(p) , l , mid , nl , nr , w);
	if(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , w);
	push_up(p);
}
int find(int p,int l,int r,int w)
{
	if(l == r){return ans[p] >= w ? l : l - 1;}
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	//printf("%d %d %d %d\n",w,ans[ls(p)],l,mid);
	if(ans[ls(p)] >= w) return find(rs(p) , mid + 1 , r , w);
	return find(ls(p) , l , mid , w);
}
double k;
int main()
{
	scanf("%d %lf",&n,&k);
	for(int i = 1 ; i <= n ; i ++) scanf("%d",&lsh[i]);
	sort(lsh + 1 , lsh + 1 + n);
	int lst = 1;
	for(int i = 1 ; i <= n ; i ++) 
	{
		if(lsh[i] != lsh[i + 1]) 
		{
			tot ++;
			cnt[tot] = i - lst + 1;
			a[tot] = lsh[i];
			lst = i + 1;
		}
	}
	for(int i = tot ; i >= 1 ; i --) f[i] = f[i + 1] + cnt[i];
	build(1 , 1 , tot); 
	for(int i = 1 ; i <= n ; i ++) fa[i] = (int)(i / k) , siz[i] = 1;	
	for(int i = n ; i >= 1 ; i --) siz[fa[i]] += siz[i];
	for(int i = 1 ; i <= n ; i ++)
	{
		if(fa[i] && !flag[fa[i]]) update(1 , 1 , tot , 1 , Print[fa[i]] , siz[fa[i]] - 1);
 		flag[fa[i]] = 1 ; int num = find(1 , 1 , tot , siz[i]);
		update(1 , 1 , tot , 1 , num , -siz[i]);
		Print[i] = num;
		printf("%d ",a[num]);
	}
	return 0;
}
```

---

## 作者：云浅知处 (赞：0)

考虑依次给 $i=1,2,\cdots,n$ 填上数，每次尽量填最大的。考虑什么时候 $i$ 填上 $x$ 是合法的。考虑 Hall 定理，发现左部点约束最严的时候肯定是找一个已经填过的点 $u$，然后对所有 $d_v\ge d_u$ 的 $v$，选出 $v$ 的子树内的所有点，也就是说我们会选一个后缀的子树的并。形式化地，对每个已经填过的点 $u$，所有 $d_v\ge d_u$ 的 $v$ 的子树内未填的点并起来的大小不能超过 $\ge d_u$ 且尚未被填入的格子个数。

维护 $w_i$ 表示如果在判定中选择分界点为 $i$，$\ge i$ 的剩余空位数减去所有 $d_u\ge i$ 的子树并中未填点数的差，那么当前状态合法当且仅当 $w_i\ge 0$ 对所有 $i$ 成立。

考虑给 $u$ 填入 $x$ 有什么影响，发现对前一项的影响是所有 $i\le x$ 的 $w_i\leftarrow w_i-1$。考虑后一项会发生什么变化，我们发现由于树的 BFS 序就是 $1,2,\cdots,n$，因此 $u$ 的子树内一定完全是空的，祖先一定是满的。因此，设 $v$ 是 $u$ 的父亲，显然只有 $i\le x$ 的 $w_i$ 会发生改变，具体地：

- 当 $i \le d_v$ 时这个子树并中未填的点的个数会 $-1$，导致实际的 $w_i$ 不改变；
- 当 $d_v<i\le x$ 时，子树并会多出 $\text{size}_u-1$，导致实际的 $w_i$ 的变化为 $w_i\leftarrow w_i-\text{size}_u$。

因此，实际的影响就是：对所有 $d_v<i\le d_u$，令 $w_i\leftarrow w_i-\text{size}_u$。那么要想维持 $w_i\ge 0$，就只需要找到 $d_v$ 后面的最大的 $x$，使得对 $i\in (d_v,x]$，均有 $w_i\ge \text{size}_u$，然后将这个区间都减去 $\text{size}_u$。线段树维护即可，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>

#define ll long long

using namespace std;

const int N=5e5+5;
int n;double k;
int fa[N],val[N],lsh[N],cnt[N],sz[N];

struct SegTree{
	int d[N<<2],lz[N<<2];
	#define ls(p) (p<<1)
	#define rs(p) (p<<1|1)
	void pushup(int p){d[p]=min(d[ls(p)],d[rs(p)]);}
	void pushdown(int p){d[ls(p)]+=lz[p],d[rs(p)]+=lz[p],lz[ls(p)]+=lz[p],lz[rs(p)]+=lz[p],lz[p]=0;}
	void add(int l,int r,int k,int ql,int qr,int p){
		if(l<=ql&&qr<=r){lz[p]+=k,d[p]+=k;return ;}
		int mid=(ql+qr)>>1;pushdown(p);
		if(l<=mid)add(l,r,k,ql,mid,ls(p));
		if(r>mid)add(l,r,k,mid+1,qr,rs(p));
		pushup(p);
	}
	int query(int l,int r,int lim,int ql,int qr,int p){
		if(l<=ql&&qr<=r&&d[p]>=lim)return -1;
		if(ql==qr)return ql;
		int mid=(ql+qr)>>1;pushdown(p);
		if(r<=mid)return query(l,r,lim,ql,mid,ls(p));
		if(l>mid)return query(l,r,lim,mid+1,qr,rs(p));
		int res=query(l,r,lim,ql,mid,ls(p));
		if(res!=-1)return res;
		return query(l,r,lim,mid+1,qr,rs(p));
	}
	void build(int l,int r,int p){
		lz[p]=0;
		if(l==r)return d[p]=cnt[l],void();
		int mid=(l+r)>>1;build(l,mid,ls(p)),build(mid+1,r,rs(p)),pushup(p);
	}
}T;

int ans[N];

signed main(void){
	
	ios::sync_with_stdio(0);cin>>n>>k;
	for(int i=1;i<=n;i++)fa[i]=(int)((double)(i)/k);
	for(int i=1;i<=n;i++)cin>>val[i],lsh[i]=val[i];
	sort(lsh+1,lsh+n+1);int m=unique(lsh+1,lsh+n+1)-lsh-1;
	for(int i=1;i<=n;i++)val[i]=lower_bound(lsh+1,lsh+m+1,val[i])-lsh;
	m++;for(int i=1;i<=n;i++)cnt[val[i]]++;
	for(int i=m-1;i>=1;i--)cnt[i]+=cnt[i+1];
	
	for(int i=n;i>=1;i--)sz[i]++,sz[fa[i]]+=sz[i];
	
	T.build(1,m,1);
	for(int i=1;i<=n;i++){
		ans[i]=T.query(ans[fa[i]]+1,m,sz[i],1,m,1)-1;
		T.add(ans[fa[i]]+1,ans[i],-sz[i],1,m,1);
	}
	
	for(int i=1;i<=n;i++)cout<<lsh[ans[i]]<<" ";puts("");
	
	return 0;
}
```

---

## 作者：老莽莽穿一切 (赞：0)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16504804.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P4364)

先简化一下题意，把下取整之类的皮给先剥了，问题转化成给你一棵树，要求给树的每个节点分配权值，使树满足小根堆性质的情况下字典序最大（给定的 $d$ 只影响树的形态，不理解为什么专门要给一个 $k$ 为整数的部分分）。

发现有很多的部分分给到了权值互不相等，我们考虑权值互不相等怎么做，不妨再特化一点，给一个二叉堆分配一个排列，看情况会是怎么样的。

首先 $1$ 节点值固定后考虑 $2$ 节点的权值，通过堆性质我们可以知道 $2$ 节点的子树里任意一点的权值都是要比 $2$ 节点的权值大的，那么因为贪心使 $2$ 节点最大，就把最后 $\mathrm{size}_2$ 个权值分配给 $2$ 的儿子，然后发现这变成了一个递归问题，对以 $2$ 为根的子树分配权值，有限分配 $4$，等 $4$ 分配完再考虑 $5$，等到 $2$ 考虑完然后再考虑 $3$。

对于多叉树，我们发现这个问题并没有什么变化，对于每个点，按顺序依次处理它的每个子树，递归解决。

这样就可以拿到 $55$ 的分数，考虑再权值有相等情况下为什么会错。

考虑这样一组数据：

```
3 3.0
1 1 2
```

![](https://s2.loli.net/2022/07/22/EkiuQrny867OG5M.png)

（$0$ 是作的虚拟节点）

此时如果按照刚刚的方法分配权值，我们会为 $3$ 分配 $2$，为 $2$ 分配 $1$，这显然是不优的，我们思考是什么让我们的贪心失败了。

整体来看我们的贪心处理过程，我们将自己的权值分配好以后顺序遍历所有的儿子进行递归处理，整个是一个前序遍历的过程，但是考虑我们的要求是字典序最小，在树中应该进行的是类似 bfs 遍历的方法，我们的贪心过程从根本上没有满足题目要求，所以我们应当使用另一种贪心的思路。

在上面的贪心中，我们每处理完一个点，将它的子树权值分配固定，然后再去处理它的兄弟，这次我们不这样做，首先我们将这个点的权值固定，然后对于我们先不去分配它的子树，将它子树需要的权值先“代为保管”，那么我们对于这个“保管”需要满足什么要求呢，当然是之后得还得起，即对于一个分配了权值 $x$ 的点 $p$ 而言，在处理到它的儿子之前，小于等于 $x$ 的数的数量不能少于 $\mathrm{size}_p$。

具体怎么维护呢，首先定义 $c_i$ 表示当前小于等于 $i$ 的数的个数，也就是一个子树的根节点的权值为 $i$ 的情况下它的子树最多有多大，我们可以离散化完用线段树维护，当我们做到点 $p$ 时，考虑如果 $p$ 的权值为 $x$，则我们会“保管”成什么样，对于所有 $i$ 满足 $i\ge x$，对应的 $c_i\gets c_i-\mathrm{size}_p$，考虑 $c$ 数组的意思就可以理解了，我们对于子孙里每个值到底是几还没有确定，但我们知道要“保管” $\mathrm{size}_p$ 个小于等于 $x$ 的数，那么我们找到的 $x$ 肯定要满足 $\forall i\ge x,\ c_i\ge\mathrm{size}_p$，从 $c$ 数组的意思理解，这个减掉是“保管”的，如果现在有一个 $c_i$ 为负，到时候这个 $c_i$ 要还就还不上了，所以一定要满足这个要求，且对于每个 $p$，处理到它的儿子时应当把它的影响消去，因为 $p$ 是给它儿子“保管”的，现在它儿子来了肯定就要还了。

具体代码实现上难度不大。

[c++ 代码](https://www.cnblogs.com/LaoMang-no-blog/p/16504804.html)

---

## 作者：DrBit (赞：0)

[题面](https://www.luogu.com.cn/problem/P4364)

首先这个条件很好满足，甚至 sort 一下就行。

手摸几组数据可以找到一个性质，如果合法，那么前面的点越大越好。（废话）

首先我们把点之间的大小树形关系建出来，$fa[i] = \lfloor \frac{i}{k} \rfloor $。

55pts 做法：

把权值从大到小排序，每个点一开始赋值为 $1$，对于点 $i$ 找到前缀和不小于 $siz[i]$ 的最靠左的点，用这个点给 $i$ 赋值并把 $i$ 前面的点全部改为 $0$。

问题关键在于重复的权值。

假设现在的权值集合 $\{8,7,6,5,5,5 \}$，其中 $siz[1]=4$，$siz[2] = 2 $。按照刚才的策略会给 $1$ 和 $2$ 都赋上 $5$，但是发现 $1$ 赋 $5$，$2$ 赋 $7$ 是个更优的策略。

如果我们让 $1$ 赋到最右边那个 $5$，这样保证了 $1$ 的值最大，同时也保证了后面的点可以取到可能的更大值。

所以假如 $i$ 要取 $val$ 这个值，那么取 $val$ 最靠右的出现位置那个肯定最优。

但是这样的话 $1$ 的子树内的权值集合就不确定了，前面赋 $0$ 赋 $1$ 的做法不太可行。

转而维护前缀和，设 $f[i]$ 表示 $i$ 左边还有多少个能取的点（很明显 $f[i]$ 单调不降），那么假设 $i$ 取到了 $x$ 这个位置的值，那么就把$x$ 往右（包括自身）的值全部减去 $siz[i]$ 就好了（这个区间修操作可以用线段树维护）。

至于查找，在线段树上二分找到最靠左的 $f[x] \ge siz[i]$ 的点就好了。

以下是代码实现的一些细节：（建议自己手摸几组数据理解一下）

1. 线段树上维护的点实际上并不满足单调不降（实际的 $f[i]$应该是线段树里维护的值的后缀最小值），因此二分时要保证如果右子树的最大值大于等于 $siz[i]$ 时再往左子树跑，这样才能保证 $f[x] \ge siz[i] $ 的限制条件。

2. 最后我们二分到的点很可能是最靠右的小于 $siz[i]$ 的点，所以最后一步加一个特判判断是否答案是右侧相邻的点。

3. 如果位置 $x-1$ 和 $x$ 对应的值相同，而 $x$ 之前已经被一个点取过了，那么另一个点取在 $x-1$ 和 $x$ 是等价的。（答案相同，对 $f[i]$ 的影响也相同）

4. 如果一个点被迫应该取 $x$ 这个位置，而 $x$ 这个位置之前被取过了，那么这个点只能往右去找位置，即使这个位置比 $x$ 对应的值更小。

5. 当一个点的儿子节点被计算到时，那么要把它给儿子节点预留的位置对 $f$ 的影响删掉。（之后儿子节点会相继把这个点所预留的位置占满，所以不会影响答案）

代码其实和别人长得都差不多。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ls (x << 1)
#define rs ((x << 1) | 1)
using namespace std;
const int MAXN = 5e5 + 50;
int a[MAXN], cnt[MAXN], siz[MAXN], ans[MAXN];
int fa[MAXN], vis[MAXN];
int N;
double k;
struct SegT
{
    int val[MAXN * 4], tag[MAXN * 4];
    void pushdown(int x)
    {
        if (!tag[x])
            return;
        tag[ls] += tag[x];
        tag[rs] += tag[x];
        val[ls] += tag[x];
        val[rs] += tag[x];
        tag[x] = 0;
    }
    void build(int x, int l, int r)
    {
        if (l == r)
        {
            val[x] = l;
            return;
        }
        int mid = (l + r) >> 1;
        pushdown(x);
        build(ls, l, mid);
        build(rs, mid + 1, r);
        val[x] = min(val[ls], val[rs]);
    }
    void modify(int x, int l, int r, int tl, int tr, int v)
    {
        if (tl > r || tr < l)
            return;
        if (tl <= l && tr >= r) 
        {
            val[x] += v;
            tag[x] += v;
            return;
        }
        pushdown(x);
        int mid = (l + r) >> 1;
        modify(ls, l, mid, tl, tr, v);
        modify(rs, mid + 1, r, tl, tr, v);
        val[x] = min(val[ls], val[rs]);
    }
    int query(int x, int l, int r, int v)
    {
        if (l == r)
            return val[x] >= v ? l : l + 1;
        int mid = (l + r) >> 1;
        pushdown(x);
        if (val[rs] < v)
            return query(rs, mid + 1, r, v);
        else
            return query(ls, l, mid, v);
    }
} T;
bool cmp(int x, int y)
{
    return x > y;
}
int main()
{
    scanf("%d", &N);
    scanf("%lf", &k);
    for (int i = 1; i <= N; ++i)
        scanf("%d", &a[i]);
    for (int i = 1; i <= N; ++i)
        siz[i] = 1;
    sort(a + 1, a + N + 1, cmp);
    for (int i = N; i >= 1; --i)
    {
        fa[i] = floor(1.0 * i / k);
        siz[fa[i]] += siz[i];
    }
    for (int i = N; i >= 1; --i)
        cnt[i] = (a[i] == a[i + 1]) ? cnt[i + 1] + 1 : 0;
    T.build(1, 1, N);
    for (int i = 1; i <= N; ++i)
    {
        if (fa[i] && !vis[fa[i]])
        {
            T.modify(1, 1, N, ans[fa[i]], N, siz[fa[i]] - 1);
            vis[fa[i]] = 1;
        }
        int pos = T.query(1, 1, N, siz[i]);
        pos += cnt[pos];
        cnt[pos] = cnt[pos + 1] + 1;
        ans[i] = pos;
        T.modify(1, 1, N, ans[i], N, -siz[i]);
    }
    for (int i = 1; i <= N; ++i)
        printf("%d ", a[ans[i]]);
    return 0;
}
```


---

## 作者：zzw4257 (赞：0)

# 【九省联考】IIIDX

标签：数据结构调整贪心



## 简述

> 求一棵可重序列构成的多叉堆，使得编号字典序最大

## 60 pts

首先一个很有依据的贪心

考虑对于一个点，因为子树里的值都要比他大，因此我们总是在回溯完子树紧凑的放这个值

对兄弟而言还有一个排列顺序

子问题:对$x$子树与儿子集合$\{y\}$,定义$S(x)$为$x$子树的从小到达取得是第几大值编号集合

一定有$S(x)=S(y_1)\vee \cdots S(y_k)\vee s_x$紧凑拼在一起

于是跑儿子编号从小到大的后续遍历就是答案(编号)

正确性?感性理解吧

为什么重复时错误

思考一个子情况手上有$a>b>c$,我们对一个点$x$的最大儿子$y$编号大于$x$的兄弟$z$,假设编号不同让$y\Rightarrow a~x\Rightarrow b~ z\Rightarrow c$一定是最优的情况

但若$a>b=c$

则我们会选择$y\Rightarrow a~x\Rightarrow b~ z\Rightarrow c$逊于$y\Rightarrow b~x\Rightarrow c~ z\Rightarrow a$

那是因为严格大于代表编号$-1$具有传递性，你让$x$尽量大，一定得让它紧跟在$y$后选第二位

但非严格大于可以让直接有关系存在的传递编号留下编号更小的

例子:

```4 3 1 1 2 2```

(from luogu)

其实我们贪心是在说什么

对于第一次考虑到的点$x$，它的编号$\geq size_x+1$,我们错误的认为必须紧凑的放这些值

```cpp
inline void dfs(int x){
	int i,y;
	for(i=0;i<g[x].size();++i)dfs(g[x][i]);
	p[x]=++*p;
}
inline void Solve(void){
	int i;
	for(i=1;i<=n;++i)AddEdge(fa[i],i);
	*a=0,dfs(0);
	for(i=1;i<=n;++i)wer(a[p[i]],' ');out();
}
```

## 100 pts

打包思想还是沿用

设$f_i$表示$i$左侧可以放多少个数

对$x$，我们找到第一个$\geqslant size_x$的$f_{pos}$

然后一个贪心用没有用的最后一个相同的值，放入，更改$[pos',n]$的$f$为$f'=f-size_{pos'}$

考虑对于从父亲考虑到儿子，父亲为儿子们预定好了位置，但儿子们自己会当做被别人预定的位置，需要撤销掉(预定值是给另一个比较体系用的),因此在从父亲层进入儿子层是需要去掉为儿子的预定值$size_{fa}-1$,简单来说在$fa$的第一个儿子就撤销掉影响

维护一个编号为下标，记录$f$的线段树即可

```cpp
for(i=1;i<=n;++i){
        if(fa[i]!=fa[i-1])Add(1,1,n,ans[fa[i]],n,size[fa[i]]-1);//撤销父亲 
        pos=Find(1,1,n,size[i]);//第一个使得f_i>=size_i的位置
        pos+=r[pos];pos-=((++used[pos])-1);ans[i]=pos;//到最后一位还没用过的同类 
        Add(1,1,n,pos,n,-size[i]);
        wer(a[ans[i]],' ');
    }
```

---

## 作者：Rorschachindark (赞：0)

# IIIDX
## 思路
我看到这道题的时候想都没想，直接一个贪心甩上去，然后。。。就$60$分了（我也不知道那多的$5$分怎么骗到的）

代码大概长成这样

```cpp
bool cmp (int a,int b){return a > b;}

void Add_Edge (int u,int v){G[u].push_back (v);}

void dfs (int u)
{
	dfn[u] = Index ++;
	Ans[u] = d[dfn[u]];
	sort (G[u].begin(),G[u].end (),cmp);
	for (Int i = 0;i < G[u].size();++ i)
	{
		int v = G[u][i];
		dfs (v);
	}
}
```

然后发现随便有相等的值都能把我hack掉。。。

我们还是来考虑正解吧。

首先转换一下，每一个点的父节点是$\frac{i}{k}$,要求每个点的子树内的权值都不小于该点的权值。

首先肯定是要把$d$从大到小排序的。

我们考虑使用线段树，那我们维护什么呢？我们需要维护的是$d$序列每一个值左边有多少个可以使用的值，我们线段树就直接维护每段的那个的最小值即可。

考虑对于一个点如何求答案。很显然，就是序列中第一个满足左边可用的点数足够填满这棵子树即可。但是，因为贪心，所以我们尽可能选相同的数的最右边，因为这样同一层的点的权值可以尽可能的大。

但是我们具体怎么搞呢?填子树的话我们可以直接在线段树上预留下来，在子节点的时候在直接填回来就好了，具体可以见代码。

## $\text {Code}$
```cpp
#pragma GCC optimize ("O3")
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 500005
#define rs i<<1|1
#define ls i<<1

int n,Index;
int d[MAXN],fa[MAXN],cnt[MAXN],Ans[MAXN],size[MAXN];

bool vis[MAXN];

bool cmp (int a,int b){return a > b;}

int sum[MAXN << 2],lazy[MAXN << 2];

void Pushdown (int i)
{
	if (lazy[i])
	{
		sum[ls] += lazy[i],sum[rs] += lazy[i];
		lazy[ls] += lazy[i],lazy[rs] += lazy[i];
		lazy[i] = 0;
	}
}

void Pushup (int i){sum[i] = min (sum[ls],sum[rs]);}

void build (int i,int l,int r)
{
	sum[i] = l;
	if (l == r) return ;
	int mid = (l + r) >> 1;
	build (ls,l,mid);
	build (rs,mid + 1,r);
}

void update (int i,int l,int r,int tl,int tr,int val)
{
	if (l > tr || tl > r) return ;
	if (l >= tl && r <= tr) return sum[i] += val,lazy[i] += val,void ();
	Pushdown (i);
	int mid = (l + r) >> 1;
	update (ls,l,mid,tl,tr,val);
	update (rs,mid + 1,r,tl,tr,val);
	Pushup (i);
}

int query (int i,int l,int r,int val)
{
	if (l == r) return sum[i] >= val ? l : l + 1;
	Pushdown (i);
	int mid = (l + r) >> 1;
	if (val > sum[rs]) return query (rs,mid + 1,r,val);
	else return query (ls,l,mid,val);
}

int read ()
{
	int x = 0;char c = getchar();int f = 1;
	while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
	while (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
	return x * f;
}

void write (int x)
{
	if (x < 0){x = -x;putchar ('-');}
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}

signed main()
{
	memset (sum,0x7f,sizeof (sum));
	n = read ();double k;scanf ("%lf",&k);
	for (Int i = 1;i <= n;++ i) d[i] = read (),size[i] = 1;
	sort (d + 1,d + n + 1,cmp);
	build (1,1,n);
	for (Int i = n;i;-- i)
	{
		fa[i] = i / k;
		size[fa[i]] += size[i];
		cnt[i] = d[i] == d[i + 1] ? cnt[i + 1] + 1 : 0;
	}
	for (Int i = 1;i <= n;++ i)
	{
		if (fa[i] && !vis[fa[i]])
		{
			update (1,1,n,Ans[fa[i]],n,size[fa[i]] - 1);
			vis[fa[i]] = 1;
		}
		int now = query (1,1,n,size[i]);
		now += cnt[now];cnt[now] ++;
		Ans[i] = now;
		update (1,1,n,Ans[i],n,-size[i]);
	}
	for (Int i = 1;i <= n;++ i) write (d[Ans[i]]),putchar (' ');
	putchar ('\n');
	return 0;
}
```

---


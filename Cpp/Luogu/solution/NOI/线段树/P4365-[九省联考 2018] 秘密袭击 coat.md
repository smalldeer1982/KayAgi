# [九省联考 2018] 秘密袭击 coat

## 题目背景

> We could have had it all. . . . . .
>
> 我们本该，拥有一切
>
> Counting on a tree. . . . . .
>
> 何至于此，数数树上

Counting on a Tree（CoaT）即是本题的英文名称。

## 题目描述

Access Globe 最近正在玩一款战略游戏。在游戏中，他操控的角色是一名 C 国士兵。他的任务就是服从指挥官的指令参加战斗，并在战斗中取胜。

C 国即将向 D 国发动一场秘密袭击。作战计划是这样的：选择 D 国的 $s$ 个城市，派出 C 国战绩最高的 $s$ 个士兵分别秘密潜入这些城市。每个城市都有一个危险程度 $d_i$。

C 国指挥官会派遣战绩最高的士兵潜入所选择的城市中危险程度最高的城市，派遣战绩第二高的士兵潜入所选择的城市中危险程度次高的城市，以此类推（即派遣战绩第 $i$ 高的士兵潜入所选择城市中危险程度第 $i$ 高的城市）。D 国有 $n$ 个城市，$n - 1$ 条双向道路连接着这些城市，使得这些城市两两之间都可以互相到达。为了任务执行顺利，C 国选出的 $s$ 个城市中，任意两个所选的城市，都可以不经过未被选择的城市互相到达。

Access Globe 操控的士兵的战绩是第 $k$ 高，他希望能估计出最终自己潜入的城市的危险程度。Access Globe 假设 C 国是以等概率选出任意满足条件的城市集合 $S$，他希望你帮他求出所有可能的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和。如果选择的城市不足 $k$ 个，那么Access Globe 不会被派出，这种情况下危险程度为 $0$。

当然，你并不想帮他解决这个问题，你也不打算告诉他这个值除以 $998\,244\,353$ 的余数，你只打算告诉他这个值除以 $64\,123$ 的余数。

## 说明/提示

D 国地图如下，其中危险程度为 $d$ 的城市的形状是 $d + 3$ 边形。

![](https://cdn.luogu.com.cn/upload/pic/16888.png)

以下是所有符合条件且选择的城市不少于 $3$ 个的方案：

- 选择城市 $1,2,3$，Access Globe 的士兵潜入的城市危险程度为 $1$；
- 选择城市 $1,2,3,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；
- 选择城市 $1,2,3,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；
- 选择城市 $1,2,3,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；
- 选择城市 $1,2,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；
- 选择城市 $1,2,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；
- 选择城市 $1,2,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；
- 选择城市 $1,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；
- 而在选择的城市少于 $3$ 时，Access Globe 的士兵潜入的城市危险程度均为 $0$。

所以你应该输出 $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \bmod 64\,123 = 11$。

![](https://cdn.luogu.com.cn/upload/pic/16889.png)

## 样例 #1

### 输入

```
5 3 3
2 1 1 2 3
1 2
2 3
1 4
1 5```

### 输出

```
11```

## 样例 #2

### 输入

```
10 2 3
2 1 1 3 1 2 3 3 1 3
1 2
2 3
2 4
2 5
2 6
5 7
1 8
8 9
1 10```

### 输出

```
435```

# 题解

## 作者：Zhang_RQ (赞：49)

这篇题解写的是**官方正解**。

建议直接去我博客里看，因为这里插不了多行公式，[链接](https://zhang-rq.github.io/2018/05/04/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018-%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BBCoaT/)

正解需要以下知识

- 整体DP
- 多项式初步
- 拉格朗日插值法  ~~(可以在[这里](https://Zhang-RQ.github.io/2018/05/04/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)学)~~
- 生成函数
- 线段树合并

题目大意：

​	给一颗有$N$个点的树，点权在$1 \sim  W$之间，求树的每一个联通块的第$K$大点权之和。

看到这个题时，我的心里是懵逼的。

我们首先开始考虑转化题目。


$Ans = \sum\limits_{S \in T} k_{th} \ \ of \ \ S \ \ \ \ (1)$

$Ans = \sum\limits_{i=1}^{W} i \times \sum_{S \in T} [k_{th}\ of  \ S==i] \ \ \ \ (2)$

$Ans =\sum\limits_{i=1}^{W} \sum_{S \in T} {[k_{th} \ of \ S \geqslant i]} \ \ \ \ (3)$

$Ans =\sum\limits_{i=1}^{W} \sum_{S \in T} {[cnt[i] \geqslant k]} \ \ \ \ (4)$


$(1)$到$(2)$的过程是枚举每个权值的贡献。

$(2)$到$(3)$的过程比较难理解，我们直接考虑从每个$i$在公式$(2)$中会被算多少次，显然是$i$次。

那在公式$(3)$中也是会被算$i$次。

$(3)$到$(4)$的过程就比较显然了，这里不再赘述。

那么到现在，问题就变得比较显然了：

枚举权值$v$,求树上权值$v$出现次数超过$k$的联通块个数。

我们设计一个DP。

$f[i][j][k]$表示以$i$为根的子树中，权值大于等于$j$的权值出现为$k$次的方案数。

转移显然

$f[i][j][k] = \prod\limits_{v \in son[i]} f[v][j][k'] \ \ \ \ (d[i] < j,\sum k'=k) $


$f[i][j][k] = \prod\limits_{v \in son[i]} f[v][j][k'] \ \ \ \ (d[i] \geqslant j,\sum k'=k-1)$

最后答案就是$\sum\limits_{k'=1}^{k}\sum\limits_{j=1}^{W}\sum\limits_{i=1}^{N} f[i][j][k']$

复杂度$\mathcal{O}(N^2*k)$，据说有人大力过了。

我们考虑优化这个转移，不难发现，这个DP其实是背包的一种，而转移就是背包的合并。

那我们不妨直接考虑生成函数。

设$F[i][j]$表示以$i$为根的子树中，权值大于等于$j$的权值的生成函数。

则$F[i][j]=\sum\limits_{k=0}^{n} f[i][j][k] \times x^k$，这是一个$N$次多项式。

但是最后我们要求的是整棵树的所有$F[i][j]$之和，所以我们不妨再设一个$G[i][j]$。

$G[i][j]=\sum\limits_{x \in subtree(i)}F[x][j]$

$F[i][j]$在转移时是多项式卷积，还是很慢，$G[i][j]$在转移时只要维护一下就行了。

所以我们考虑将它转换为$N+1$个点值，这样的话转移时就是普通乘法了。

我们就令$x=1 \sim N+1$，然后将所有$G[i][j]$在$x$时的值都求出来，最后进行拉格朗日插值法将原始的多项式差出来就行了，可具体怎么实现呢？

我们首先在最外层枚举$x \in [1,N+1]$，然后每次进行一次$DFS$，但具体如何进行转移呢？

我们不难发现，$F[i][j] \leftarrow F[son[i]][j]$转移过程中其实就是$[j]$的对应位置相乘。

所以我们可以使用整体$DP$的思想在每个点上都维护一颗线段树，然后在转移时进行线段树合并就可以了。

正解差不多就是这个意思。

具体合并方法如下：

初始化：
$ F[i][j] = x \ \ \ \ (d[i] \geqslant j) $

$F[i][j] = 1 \ \ \ \ (d[i] < j) $

转移时： $F[i][j] \times =(F[son[i]][j]+1) , G[i][j]+=G[son[i]][j]$

最后，$G[i][j]+=F[i][j]$。

我们可以将$F[son[i]][j]+1$的操作放在$DFS$ son[i]后进行。

可是你说了这么多，线段树到底应该怎么写？

我们设变换$(a,b,c,d)$可以使$(f,g)$变换为$(a \times f+b,c \times f+d+g)$

然后每个线段树维护一个变换即可。

变换结合的话手推一下即可。

注意：变换在普遍情况下没有交换律，只有结合律。

剩下的实现方法详见代码。

注意以下坑点：

- 模数是64123，做乘法时要用unsigned int。
- unsigned int 取模时模数必须是unsigned类型。
- 初始化变换时应该是$(1,0,0,0)$



[代码](https://zhang-rq.github.io/2018/05/04/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018-%E7%A7%98%E5%AF%86%E8%A2%AD%E5%87%BBCoaT/)

---

## 作者：老K (赞：33)

之前那两篇题解的算法复杂度太优了，我这种萌新不会他们的算法，只会一个更暴力的暴力。

有一个很显然的暴力：
枚举第k大的值w，然后树上背包算出有共有多少个联通块有**至少**k个元素的值$\ge w$。

然后直接求和即可，发现值为k的情况恰好算了k次。

时间复杂度$O(n^2w^2)$


你写这个算法,显然不能AC。

但是通过一些奥妙重重的优化，我们可以A掉这题。

1. 记录每个点的子树有多少个元素值$\ge w$，也就是记录每个子树DP的最大范围，可以加速转移。
2. 枚举了w以后，如果一共也不到k个元素$\ge w$直接不要DP了。（在k小的时候就没什么用了，但是k大的时候，效果很好）
3. dp的时候，一般是$f_{i,j}$表示以i为联通块深度最浅的点，有j个元素值$\ge w$的方案数，但我们可以用$f_{i,k}$表示以i为根， 满足条件（至少k个）的方案数。（k大就没啥用了，k小就很快）

结合2,3~~快如闪电~~就能过了，以老K的大常数，洛谷上要将近11s。
然而最慢的点也不到3s.

```C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
bool chkmax(ll &a,ll b){return a<b?a=b,1:0;}
ll d[102424],beg[102424],to[233333],lst[233333],ok[102424],e;
ll f[2333][4555],v[2333];
const ll p=64123;
void add(ll u,ll v){
    to[++e]=v;
    lst[e]=beg[u];
    beg[u]=e;
}	
ll n,k;

void dfs(ll x,ll fa){
    ll bts=0,mxv=0,vpt=0;
    v[x]=ok[x];
    for(ll i=0;i<=k;++i)f[x][i]=0;

    f[x][ok[x]]=1;
    for(ll i=beg[x];i;i=lst[i])if(to[i]!=fa){
        dfs(to[i],x);
        for(ll j=v[x];~j;--j){
			int aw=f[x][j];
			for(ll ak=v[to[i]];~ak;--ak)f[x][min(j+ak,k)]=(f[x][min(j+ak,k)]+aw*f[to[i]][ak])%p;
		}
        v[x]=min(v[x]+v[to[i]],k);
    }
}
/*
void dfs(ll x,ll fa){
    ll bts=0,mxv=0,vpt=0;
    v[x]=0;
    for(ll i=0;i<=n;++i)f[x][i]=0;
    for(ll i=beg[x];i;i=lst[i])if(to[i]!=fa){
        dfs(to[i],x);
        if(chkmax(mxv,v[to[i]]))vpt=to[i];
    }
    for(ll i=beg[x];i;i=lst[i])if(to[i]==vpt){
        for(ll j=0;j<=v[to[i]];++j)f[x][j]=f[to[i]][j];
        v[x]=v[to[i]];
    }
    for(ll i=beg[x];i;i=lst[i])if(to[i]!=fa&&to[i]!=vpt){
        for(ll j=v[x];~j;--j)for(ll k=v[to[i]];k;--k)f[x][j+k]=(f[x][j+k]+f[x][j]*f[to[i]][k])%p;
        v[x]+=v[to[i]];
    }
    for(ll i=v[x];~i;--i)f[x][i+ok[x]]+=f[x][i];
    if(!v[x])f[x][0]=1,f[x][ok[x]]=1;
    v[x]+=ok[x];
}*/
int main(){
#ifdef cnyali_lk
    freopen("coat.in","r",stdin);
    freopen("coat.out","w",stdout);
#endif

    ll w,u,v,W;
    scanf("%lld%lld%lld",&n,&k,&W);
    for(ll i=1;i<=n;++i)cin>>d[i];
    for(ll i=1;i<n;++i){
        cin>>u>>v;
        add(u,v);
        add(v,u);
    }
    ll ans=0;
    for(ll w=1;w<=W;++w){
		int cnt=0;
        for(ll i=1;i<=n;++i)cnt+=(ok[i]=d[i]>=w);
		if(cnt<k)break;
        dfs(1,0);
        for(ll i=1;i<=n;++i){
            ans=(ans+f[i][k])%p;
        }
    }
    printf("%lld\n",ans);
    return 0;
}

```
upd：复杂度可能是$O(n^2w)$的？

---

## 作者：Crabby_Maskiv (赞：11)

气抖冷，Minmax容斥怎么就不能做？

我们知道，$kthmax(S)=\sum_{|T|\geq k}(-1)^{|T|-k}\binom{|T|-1}{k-1}min(T)$

因此列出 dp 方程：$dp_{u,i,j}$ 表示在 $u$ 子树中选出连通块，要求连通块必须包含点 $u$，然后再从连通块中选出大小为 $i$ 的点集 $T$，满足 $T$ 中点权最小值等于 $j$ 有多少种方案。

将子树 $v$ 合并到 $u$ 的转移方程：

$$dp_{u,i,j}=\sum_{i_1+i_2=i,\min(j_1,j_2)=j} dp_{u,i1,j1}(dp_{v,i_2,j_2}+[i=0 \land j=\infty]) $$

其中的 $[i=0 \land j=\infty]$ 表示根本没有在 $v$ 中选择连通块

初始化：$dp_{u,1,a_u}=1,dp_{u,0,\infty}=1$

最后的答案是：$\sum_{i \geq k} j\times (-1)^{i-k}\times \binom{i-1}{k-1}\times dp_{u,i,j}$

补充：在实际实现当中，不妨将 $\infty$ 设为 $W+1$

和其他做法一样，我们观察到忽略 $j$ 时，$i$ 这一维形似卷积，因此列出生成函数：

$$F_{u,j}=\sum x^idp_{u,i,j}$$

转移变为：

$$F_{u,j}=\sum_{\min(j_1,j_2)=j} F_{u,j_1}(F_{v,j_2}+[j=\infty]) $$

初始化：$F_{u,a_u}=x,F_{u,\infty}=1$

令多项式 $G(x)=\sum jF_{u,j}$ ，最后的答案是：$\sum_{i \geq k}  (-1)^{i-k}\times \binom{i-1}{k-1}\times [x^i]G(x)$

这种转移方式是经典的，可以拿线段树合并维护的类型，只不过现在我们需要维护的是一堆多项式而不是数。因此复杂度来到了常数极大的 $O(n^2\log^2 n)$，不能通过此题。

观察到，我们并不需要实时知道每个多项式是什么，只需要在最后把 $G(x)$ 求出来，因此只需要代入 $n+1$ 个点值，然后利用拉格朗日插值法即可，最终复杂度 $O(n^2\log n)$

注意在线段树合并过程中，我们不光要维护 $F_{u,j}$ 的点值，还要维护它们 $j\times F_{u,j}$ 的和（也就是线段树每个位置的下标乘以权值的和）

**以及补充一下怎么拉格朗日插值**

我们知道拉格朗日插值的公式是：

已知 $n$ 次多项式 $F(x)$ 的 $n+1$ 个点值 $(x_i,y_i)$ ，则

$$F(x)=\sum_{i=1}^{n+1} y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}$$

如何根据这个公式求出原多项式呢？

第一步：求出 $G(x)=\prod(x-x_i)$，是一个 0/1 背包的形式，复杂度是 $O(n^2)$

第二步：对于每一个 $(x_i,y_i)$，求出$\frac{G(x)}{x-x_i}$，相当于带撤销背包，一个点 $O(n)$

第三步：将 $\frac{G(x)}{x-x_i}$ 乘以常数 $y_i\prod_{j\neq i}\frac{1}{x_i-x_j}$，累加入 $F(x)$，这部分可以暴力求逆元，也可以使用均摊 $O(1)$ 预处理逆元的技巧达到总共 $O(n^2)$

综上我们可以 $O(n^2\log P)$ （$P$ 是模数）或者 $O(n^2)$ 地完成由点值求原多项式。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1670;
const int mod=64123;
int n,m,w;
struct sgt{
	int l,r,ls,rs;
	int add,mul,sum,val;
}s[120*N];
int rt[N],P;
inline int build(int l,int r){
	int p=++P;
	s[p].l=l;s[p].r=r;
	s[p].ls=s[p].rs=s[p].add=s[p].sum=s[p].val=0;
	s[p].mul=1;
	return p;
}
inline int gets(int p){
	return (1ll*s[p].sum*s[p].mul+1ll*s[p].add*(s[p].r-s[p].l+1))%mod;
}
inline int getv(int p){
	return (1ll*s[p].val*s[p].mul+1ll*s[p].add*(s[p].l+s[p].r)%mod*(s[p].r-s[p].l+1)%mod*(mod+1>>1))%mod;
}
inline void upd(int p){
	s[p].sum=(gets(s[p].ls)+gets(s[p].rs))%mod;
	s[p].val=(getv(s[p].ls)+getv(s[p].rs))%mod;
}
inline void pushd(int p){
	s[p].sum=gets(p);
	s[p].val=getv(p);
	int mid=s[p].l+s[p].r>>1;
	if(s[p].ls){
		s[s[p].ls].mul=1ll*s[s[p].ls].mul*s[p].mul%mod;
		s[s[p].ls].add=(1ll*s[s[p].ls].add*s[p].mul+s[p].add)%mod;		
	}
	if(s[p].rs){
		s[s[p].rs].mul=1ll*s[s[p].rs].mul*s[p].mul%mod;
		s[s[p].rs].add=(1ll*s[s[p].rs].add*s[p].mul+s[p].add)%mod;	
	}
	s[p].mul=1;s[p].add=0;
}
int merge(int x,int y,int sx,int sy){
	if(!x&&!y) return 0;
	if(!x){
		s[y].mul=1ll*s[y].mul*sx%mod;
		s[y].add=1ll*s[y].add*sx%mod;
		return y;
	}
	if(!y){
		s[x].mul=1ll*s[x].mul*sy%mod;
		s[x].add=1ll*s[x].add*sy%mod;
		return x;
	}
	pushd(x);pushd(y);
	if(s[x].l==s[x].r){
		s[x].sum=((1ll*s[x].sum*sy+1ll*s[y].sum*sx+1ll*s[x].sum*s[y].sum)%mod+mod)%mod;
		s[x].val=1ll*s[x].sum*s[x].l%mod;
		return x;
	}
	int sx1=(sx+gets(s[x].rs))%mod;
	int sy1=(sy+gets(s[y].rs))%mod;
	s[x].ls=merge(s[x].ls,s[y].ls,sx1,sy1);
	s[x].rs=merge(s[x].rs,s[y].rs,sx,sy);
	upd(x);
	return x;
}
void chg(int p,int pos,int x){
	if(s[p].l==s[p].r){
		s[p].add=(s[p].add+x)%mod;
		return;
	}
	pushd(p);
	int mid=s[p].l+s[p].r>>1;
	if(pos<=mid){
		if(!s[p].ls) s[p].ls=build(s[p].l,mid);
		chg(s[p].ls,pos,x);
	}
	else{
		if(!s[p].rs) s[p].rs=build(mid+1,s[p].r);
		chg(s[p].rs,pos,x);
	}
	upd(p);
}
int a[N];
vector<int> g[N];
int y[N];
int fa[N];
void dfs(int u,int k){
	rt[u]=build(1,w+1);
	chg(rt[u],a[u],k);
	chg(rt[u],w+1,1);
	for(auto v:g[u])if(v!=fa[u]){
		fa[v]=u;
		dfs(v,k);
		chg(rt[v],w+1,1);
		rt[u]=merge(rt[u],rt[v],0,0);
	}
	y[k]=(y[k]+getv(rt[u]))%mod;
}
int f[N],ans[N];
inline int po(int x,int k){
	int ret=1;
	while(k){
		if(k&1) ret=1ll*ret*x%mod;
		x=1ll*x*x%mod;
		k>>=1;
	}
	return ret;
}
int C[N][N];
int main(){
	ios::sync_with_stdio(0);
	int i,j;
	cin>>n>>m>>w;
	for(i=0;i<=n;i++){
		for(j=0;j<=i;j++){
			if(j==0||j==i) C[i][j]=1;
			else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	for(i=1;i<=n;i++) cin>>a[i];
	for(i=1;i<n;i++){
		int x,y;cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for(i=1;i<=n+1;i++){
		P=0;dfs(1,i);
	}
	f[0]=1;
	for(i=1;i<=n+1;i++){
		for(j=n+1;j;j--)
			f[j]=(ll(mod-i)*f[j]+f[j-1])%mod;
		f[0]=f[0]*ll(mod-i)%mod;
	}
	for(i=1;i<=n+1;i++){
		int ivx=po(mod-i,mod-2);
		f[0]=1ll*f[0]*ivx%mod;
		for(j=1;j<=n+1;j++)
			f[j]=ll(f[j]-f[j-1]+mod)*ivx%mod;
		int tmp=y[i];
		for(j=1;j<=n+1;j++){
			if(i==j) continue;
			tmp=1ll*tmp*po(i-j+mod,mod-2)%mod;
		}
		for(j=0;j<=n;j++)
			ans[j]=(ans[j]+1ll*f[j]*tmp)%mod;
		for(j=n+1;j;j--)
			f[j]=(ll(mod-i)*f[j]+f[j-1])%mod;
		f[0]=f[0]*ll(mod-i)%mod;
	}
	int answ=0;
	for(i=m;i<=n;i++)
		answ=(answ+1ll*ans[i]*((i-m&1)?(mod-1):1)%mod*C[i-1][m-1])%mod;
	cout<<answ;
	return 0;
}
```


---

## 作者：Fizzmy (赞：11)

## Solution：

正解貌似是线段树合并+FFT 但是我并不会写QAQ

所以说我们考虑暴力~~碾标算~~：

我们可以考虑每个点对于答案的贡献：

我们把大于它的点看成1，小于它的点看成0，最后只要求包含它的和为k-1的联通块个数即可，这个可以用一个树形DP来实现

复杂度为$O(n^2k)$

加一些剪枝就可以过了~~而且跑得比正解快~~


代码：

```
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=2010;
const int mod=64123;
int n,k,w,S;
int d[N],head[N],size;
int f[2010][2010],ans;
struct edg{
	int to,next;
}e[2*N];
void add(int x,int y)
{
	size++;e[size].to=y;e[size].next=head[x];head[x]=size; 
}
void dfs(int x,int fa)
{
	if ((d[S]<d[x])||((d[x]==d[S])&&x<S))
		for (int i=1;i<k;i++) {f[x][i+1]+=f[fa][i];if (f[x][i+1]>=mod) f[x][i+1]-=mod;}
	else for (int i=1;i<=k;i++) {f[x][i]+=f[fa][i];if (f[x][i]>=mod) f[x][i]-=mod;}
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (fa==y) continue;
		dfs(y,x);
	}
	for (int i=1;i<=k;i++) {f[fa][i]+=f[x][i];if (f[fa][i]>=mod) f[fa][i]-=mod;}
}
int main()
{
	scanf("%d%d%d",&n,&k,&w);
	for (int i=1;i<=n;i++) scanf("%d",&d[i]);
	for (int x,y,i=1;i<n;i++) scanf("%d%d",&x,&y),add(x,y),add(y,x);
	for (int i=1;i<=n;i++)
	{
		S=i;int tot=0;
		for (int j=1;j<=n;j++) if ((d[j]>d[i])||((d[i]==d[j])&&i>j)) tot++;
		if (tot<k-1) continue;
		memset(f,0,sizeof(f));
		f[i][1]=1;
		for (int j=head[i];j;j=e[j].next)
		{
			int y=e[j].to;
			dfs(y,i);
		}
		ans+=(1ll*f[i][k]*d[i])%mod;
		if (ans>=mod) ans-=mod;
	}
	printf("%d",ans);
} 
```

---

## 作者：juju527 (赞：9)

### 前置知识
线段树合并，拉格朗日插值。

大概后文重点分析了线段树合并的复杂度。

### $\texttt{Solution}$
一脸 dp 的样子，我们来推一推式子。

枚举 $S$ 为一个点数不小于 $k$ 的树上连通块。

记 $val(S,k)$ 为集合 $S$ 中的第 $k$ 大权值。

$cnt(S,v)$ 为集合 $S$ 中不小于 $v$ 的元素个数。

$$
\sum_{S}val(S,k)=\sum_S\sum_{v=1}^w[cnt(S,v)\geq k]
$$

此时我们可以丢掉 $S$ 中点数的限制，交换求和符号。

$$
ANS=\sum_{v=1}^w\sum_{S}[cnt(S,v)\geq k]
$$

即我们需要对于每个 $v$ 求出有多少个树上连通块里权值不小于 $v$ 的点个数不小于 $k$。

设计一个暴力的 dp 状态：

$f_{x,i,j}$ 表示以点 $x$ 为根的连通块中权值不小于 $i$ 的点有 $j$ 个的连通块数。

转移显然是树上背包。

最后的答案应该是 $\sum_{i}\sum_{x}\sum_{j=k}^nf_{x,i,j}$。

暴力的复杂度很高，我们考虑优化。

广为人知的是，树上背包问题是一个卷积，我们用生成函数的角度思考。

记 $F_{x,i}(z)=\sum_{j=0}^nf_{x,i,j}x^j$。

那么 $F_{x,i}=z^{[d_x\geq i]}\prod_{y}(F_{y,i}+1)$。

由于我们最后要求 $\sum_i\sum_x\sum_{j=k}^n[z^j]F_{x,i}$。

我们设 $G_{x,i}=\sum_{y\in sub(x)}F_{x,i}$。

转移显然是 $G_{x,i}=F_{x,i}+\sum_{y\in son(x)}G{y,i}$。

答案简化为 $\sum_i\sum_{j=k}^n[z^j]G_{1,i}$。

由于转移中与 $i$ 的关联极小，我们希望对于所有 $i\in[1,w]$ 做整体 dp。

由于多项式乘法复杂度较高，我们考虑带入点值计算多项式，最后再插值回来。

我们现在只需对于点值 $[0,n]$ 都算一遍整体 dp 即可。

考虑建立以 $i$ 为下标的线段树，所有的转移都能用矩阵表示，即：

$[f,g,1]\times \left[\begin{matrix}a&c&0\\0&1&0\\b&d& 1\end{matrix}\right]$

考虑矩阵能简化为四元组运算的形式，即大多数题解中提到的“变换”。

容易讨论，不展开叙述。

本题的线段树合并与一般线段树合并不同的地方在于其区间的修改。

例如线段树的初值：

$F_{x,i}=z^{[i\leq d_x]}$，其中 $z$ 是枚举的点值，为常数。

我们应该将 $[1,d_x]$ 赋值为 $z$，$[d_x+1,w]$ 赋值为 $1$。

为了让复杂度正确，我们不能让点数达到 $O(nw)$。

我们直接利用懒标记，显然初始节点个数确为 $O(n\log w)$。

对于线段树合并操作，我们知道我们得保证遍历一个点后“删除”一个点复杂度才正确。

我们考虑合并时直接在存在一棵线段树节点没有儿子时返回即可。

由于有一棵树往下已经没有儿子，那么实际上这段区间的矩阵懒标记均相同，容易处理。

对于 merge 里 pushdown ，一定是两个线段树节点此时均有儿子时才会去做，事实上此时两节点一定会有左右儿子，所以并不增加节点个数。

总复杂度为 $O(n^2\log w)$。

众所周知区间修改的 $\log$ 常数不小，线段树里还有矩阵乘法，属于是跑不过暴力（。

[code](https://www.luogu.com.cn/paste/7d7feqk9)

---

## 作者：王鲲鹏 (赞：7)

## [九省联考2018]秘密袭击coat


### 题面
给定一棵 $n$ 个点的树，每个点有点权 $d$，满足 $d\le W$，和一个排名 $k$（$k\le n$），求
$$
\sum_{S\subset T}k\text{th of }S \qquad\text{S是连通块}
$$
$n\le 1666$，$W\le1666$。

### Solution

既然有正解做法，还是想学习正解吖。重点分析了下个人理解困难的地方，跟zhang_RQ推的不是很一致的感觉/yun。可以去看 Mriacle 的[文章](https://www.cnblogs.com/Miracevin/p/10402405.html)。

转化一下，（以下省略 $S$ 为连通块）
$$
\begin{aligned}
\sum_{S\in T}k\text{th of }S &=\sum_{i=1}^Wi\sum_{S\in T}[k\text{th }S=i]\\
&=\sum_{i=1}^W\sum_{S\in T}[k\text{th }S\ge i]\\
&=\sum_{i=1}^W\sum_{S\in T}[cnt(S,i)\ge k]
\end{aligned}
$$

其中 $cnt(S,i)$ 表示 $S$ 中权值大于等于 $i$ 的点的数量。

把连通块放在最上面的点统计贡献，可以设 $f(x,i,j)$ 表示在 $x$ 的子树中选出连通块（必含自身），权值大于等于 $i$ 的点数为 $j$ 的方案数。转移不详细写了，就是树上背包的形式。设 $g[j]=\sum_{x=1}^{n}\sum_{i=1}^{W}f(x,i,j)$，答案是 $\sum_{j=k}^{W}g[j]$。这就是暴力的做法，复杂度可以做到 $O(n^2W)$。

把最后一维看成生成函数的系数，那么
$$
F[x,i]=(\prod_{y\in Son}F[y][i])\times\left\{\begin{matrix}
z & d[x]\ge i\\
1 & d[x]<i
\end{matrix}
\right.
$$
多项式还是不好直接处理。从巨佬题解学到方法是，把它看成点值。点值就方便多了，一项就对应一项。

审视以下我们的状态，一维 $x$，表示哪个点；一维权值 $i$ ；$n+1$个点值。然而单看 $F[x][i]$ 的点值还是挺杂乱的

，不妨先考虑一下一个叶子节点的 $F[x]$ 是什么样子。举例如下（$d[x]=3$）
$$
\begin{matrix}
i, z & 1 & 2 & 3 & \cdots & n+1\\
1 & 1 & 2 & 3 & \cdots & n+1\\
2 & 1 & 2 & 3 & \cdots & n+1\\
3 & 1 & 2 & 3 & \cdots & n+1\\
4 & 1 & 1 & 1 & \cdots & 1\\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots\\
W & 1 & 1 & 1 & \cdots & 1\\
\end{matrix}
$$

发现竖着看的话，整个序列分成了两半。自变量 $z$ 的值可以提到最外层枚举，然后对每个点维护一棵线段树，下标 $i$ 表示多项式 $F[x][i]$ 在自变量为 $z$ 时的点值 。因为线段树合并的时候是整块合并，每个节点最初段数很少，所以复杂度是ok的。

具体而言要完成这样几个操作：
线段树全局设为 $1$；
$[1,d[x]]$ 乘 $z$；
全局 $+1$；
合并：对应位置相乘；
维护全局答案。

这一步可以通过构造一个神奇的运算完成（并不会自己构造）

定义元素 $(a,b,c,d)$，定义运算
$$
(a2,b2,c2,d2)\cdot(a2,b2,c2,d2)=(a1\cdot a2,b2+a2\cdot b1,c1+a1\cdot c2,d1+d2+b1\cdot c2)
$$
单位元 $(0,1,0,0)$。手推一下发现是满足结合律的。

令 $b=f$，$d=g$。剩下的主要就是构造了，就不细说了（~~其实是不会~~）。

当然我们只求出了点值，最后还要再拉格朗日插值，重新求出系数。我是看[这里](https://www.cnblogs.com/Miracevin/p/10158752.html)学的。

code:
```cpp
#include <cstdio>
#include <algorithm>

typedef long long ll;
int const maxn = 1677;
ll const mod = 64123;
inline ll pls(ll a, ll b) { return a + b < mod ? a + b : a + b - mod; }
inline ll dec(ll a, ll b) { return a >= b ? a - b : a - b + mod; }

int n = 0, k = 0, W = 0;
int d[maxn];
int head[maxn], nxt[maxn << 1], to[maxn << 1], cnt = 0;
inline void insert(int u, int e) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = e; }

struct Data {
	Data() {}
	Data(int A, int B, int C, int D) : a(A), b(B), c(C), d(D) {}
	void clear() { a = 1; b = c = d = 0; }
	int a, b, c, d;
};
inline Data operator*(Data const &A, Data const &B) {
	return Data(ll(A.a) * B.a % mod, pls(ll(A.b) * B.a % mod, B.b), pls(A.c, ll(A.a) * B.c % mod), pls(pls(A.d, B.d), ll(A.b) * B.c % mod)); // there do not mod, because it will be mod in Data(..)
}
struct Node {
	Node() {}
	void init() {
		v.clear();
		ls = rs = 0;
	}
	Data v;
	int ls, rs;
};
Node tr[maxn * 50];
int bin[maxn * 50];
int cntNode = 0, binTop = 0;
inline int newNode() {
	int r = binTop ? bin[binTop--] : ++cntNode;
	tr[r].init();
	return r;
}
void delTree(int &p) {
	if (p == 0) return;
	if (tr[p].ls) delTree(tr[p].ls);
	if (tr[p].rs) delTree(tr[p].rs);
	bin[++binTop] = p;
	tr[p].init();
	p = 0;
}
void pushdown(int p) {
	if (tr[p].ls == 0) tr[p].ls = newNode();
	if (tr[p].rs == 0) tr[p].rs = newNode();
	tr[tr[p].ls].v = tr[tr[p].ls].v * tr[p].v;
	tr[tr[p].rs].v = tr[tr[p].rs].v * tr[p].v;
	tr[p].v.clear();
}
void modify(int &p, int L, int R, int l, int r, Data const x) {
	if (p == 0) p = newNode();
	if (l <= L && R <= r) { tr[p].v = tr[p].v * x; return; }
	pushdown(p);
	int mid = (L + R) >> 1;
	if (l <= mid) modify(tr[p].ls, L, mid, l, r, x);
	if (r > mid) modify(tr[p].rs, mid + 1, R, l, r, x);
}
int merge(int &x, int &y) { // 必须传引用 否则swap后del时会出错
	if (tr[x].ls == 0 && tr[x].rs == 0) std::swap(x, y);
	if (tr[y].ls == 0 && tr[y].rs == 0) {
		tr[x].v = tr[x].v * Data(tr[y].v.b, 0, 0, tr[y].v.d);
		return x;
	}
	pushdown(x);
	pushdown(y);
	merge(tr[x].ls, tr[y].ls);
	merge(tr[x].rs, tr[y].rs);
	return x;
}

ll querySumD(int p, int L, int R) {
	if (L == R) return tr[p].v.d;
	pushdown(p);
	int mid = (L + R) >> 1;
	int r = pls(querySumD(tr[p].ls, L, mid), querySumD(tr[p].rs, mid + 1, R));
	return r;
}

int root[maxn];
void dfs(int x, int const fa, int const z0) {
	modify(root[x], 1, W, 1, W, Data(0, 1, 0, 0));
	for (int i = head[x]; i; i = nxt[i]) {
		if (to[i] == fa) continue;
		dfs(to[i], x, z0);
		modify(root[to[i]], 1, W, 1, W, Data(1, 1, 0, 0));
		merge(root[x], root[to[i]]);
		delTree(root[to[i]]);
	}
	modify(root[x], 1, W, 1, d[x], Data(z0, 0, 0, 0));
	modify(root[x], 1, W, 1, W, Data(1, 0, 1, 0));
}

int inv[maxn];
ll pv[maxn], g[maxn];

void Lagrange() {
	static int f[maxn], a[maxn];
	f[0] = 1;
	for (int i = 1; i <= n + 1; ++i) {
		for (int j = n + 1; j >= 0; --j)
			f[j] = pls(f[j] * ll(mod - i) % mod, (j > 0 ? f[j - 1] : 0));
	}
	for (int i = 1; i <= n + 1; ++i) {
		for (int j = 0; j <= n + 1; ++j) a[j] = f[j];
		a[0] = a[0] * ll(mod - inv[i]) % mod;
		for (int j = 1; j <= n + 1; ++j)
			a[j] = dec(a[j], a[j - 1]) * ll(mod - inv[i]) % mod;

		ll k = pv[i];
		for (int j = 1; j <= n + 1; ++j)
			if (j < i) k = k * inv[i - j] % mod;
			else if (i < j) k = k * (mod - inv[j - i]) % mod;

		for (int j = 0; j <= n; ++j)
			g[j] = pls(g[j], k * a[j] % mod);
	}
}

int main() {
	scanf("%d%d%d", &n, &k, &W);
	int x = 0, y = 0;
	for (int i = 1; i <= n; ++i) scanf("%d", d + i);
	for (int i = 1; i < n; ++i) {
		scanf("%d%d", &x, &y);
		insert(x, y);
		insert(y, x);
	}

	inv[0] = inv[1] = 1;
	for (int i = 2; i <= n + 1; ++i) inv[i] = ll(mod - mod / i) * inv[mod % i] % mod;

	for (int z = 1; z <= n + 1; ++z) {
		cntNode = binTop = 0;
		dfs(1, 0, z);
		pv[z] = querySumD(root[1], 1, W);
		delTree(root[1]);
	}
	
	Lagrange();
	
	int ans = 0;
	for (int i = k; i <= n; ++i) ans = pls(ans, g[i]);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Great_Influence (赞：6)

这题直接$O[nk(n-k)]$暴力，利用树形$dp$来实现。这样你能够得到一个被卡掉边缘的做法(数据强一些的话就凉了)。但是实际上，这种方法的常数非常小，可以通过各种奇怪的方法来优化。

可以发现，写的程序多次使用$[]$来调用数组。然而这种方法十分缓慢，考虑换用指针来调用。这样写加上$Ofast$优化可以不加$O2$直接跑过，或者加上$O2$跑得飞快。然后就是一些基本常数优化了。

写这个题解的主要原因是因为我们机房有人被卡$TLE$，导致这道题得利用$Ofast$修改。如果大家自觉掌握一种卡常技巧，常数问题就不存在了。

代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T&x)
{
    static char c;x=0;
    for(c=getchar();!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())x=(x*10)+(c^48);
}
const int MAXN=1777;
static struct edge
{
    int v,nxt;
}p[MAXN<<1];
static int n,k,W,w[MAXN],e,head[MAXN],b[MAXN];
inline void add(int u,int v)
{p[++e]=(edge){v,*(head+u)};*(head+u)=e;}
inline void init()
{
    read(n);read(k);read(W);
    Rep(i,1,n)read(*(w+i)),*(w+i)*=10000,*(w+i)+=i,*(b+i)=*(w+i);
    sort(b+1,b+n+1);
    static int u,v;
    Rep(i,1,n-1)read(u),read(v),add(u,v),add(v,u);
}
const int mod=64123;
static int rt,dp[MAXN][MAXN];
inline int Add(int u,int v){return (u+=v)>=mod?u-mod:u;}
void dfs(int u,int fr)
{
    short low;
    for(register int v=head[u];v;v=p[v].nxt)if(p[v].v^fr)
    {
        low=w[p[v].v]>w[rt];
        Rep(i,0,k)*(dp[p[v].v]+low+i)=*(dp[u]+i);
        dfs(p[v].v,u);
        Rep(i,0,k)*(dp[u]+i)=Add(*(dp[u]+i),*(dp[p[v].v]+i));
    }
}
static int ans;
inline void solve()
{
    --k;
    Rep(i,1,n)
    {
        if(lower_bound(b+1,b+n+1,w[i])-b-1>=n-k)continue;
        Rep(l,1,k)*(dp[i]+l)=0;
        Rep(l,1,n)*dp[l]=0;
        *dp[i]=1;rt=i;
        dfs(i,0);
        ans=Add(ans,(1ll**(w+i)/10000**(dp[i]+k))%mod);
    }
    printf("%d\n",ans);
}
int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：木xx木大 (赞：3)

[P4365 [九省联考2018]秘密袭击coat](https://www.luogu.com.cn/problem/P4365)

先把问题转化为，对于每个权值 $i$，求出权值大于等于 $i$ 的点数 $= k$ 的连通块个数。求和就是答案。
设 $f_{u,i,j}$ 表示 $u$ 号点为连通块根，权值 $\ge i$ 的有 $j$ 个点的方案数，再设 $g_{u,i,j}=f_{u,i,j}+\sum g_{v,i,j}$。则有

$$
f_{u,i,j}=\begin{cases}\prod_{\sum k=j}f_{v,i,k}&d_u<i\\\prod_{\sum k=j-1}f_{v,i,k}&d_u\ge i\end{cases}
$$

这是一个卷积的形式。把 $F,G$ 看作生成函数，插 $n+1$ 个值代入，转移式即为

$$
F(u,i)=x^{[d_u\ge i]}\prod (F(v,i)+1)\\
G(u,i)=F(u,i)+\sum G(v,i)\\
$$

对应位置相乘、相加，这是一个线段树合并的形式。每次进行的操作为：全局赋值为 1 ，$[1,d_u]$ 乘 $x$ ，全局+1，$F$ 对应位置相乘，$G$ 对应位置相加，将 $F$ 数组加到 $G$ 数组上。

考虑一个变换，初始时 $b=f,d=g$

$$
(a,b,c,d)*(f,g)=(af+b,cf+g+d)
$$

手推一下发现这个变换有结合律。

* 全局赋值为 1 ：$*(0,1,0,0)$

* $[1,d_u]$ 乘 $x$ ：$*(x,0,0,0)$

* 全局+1：$*(1,1,0,0)$

* 将 $F$ 加到 $G$ 上：$*(1,0,1,0)$

用线段树维护这个变换即可。最后再用拉格朗日插值求出 $k\sim n$ 次项系数即可，方法见[这里](https://www.luogu.com.cn/blog/flyingfan/la-ge-lang-ri-cha-zhi-qiu-ji-shuo)。

```cpp
#include<bits/stdc++.h>
#define ls t[ro].l
#define rs t[ro].r
#define mid ((l+r)>>1)
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,K,w;
	const int N=2005,mo=64123;
	struct Node{
		ll a,b,c,d;
		Node(){}
		Node(int _a,int _b,int _c,int _d):a(_a),b(_b),c(_c),d(_d){};
	};
	Node operator *(Node x,Node y){return Node(x.a*y.a%mo,(y.a*x.b+y.b)%mo,(x.a*y.c+x.c)%mo,(y.c*x.b+x.d+y.d)%mo);}
	struct tree{
		int l,r;Node val;
		void init(){l=r=0;val=Node(1,0,0,0);}
	}t[N*40];
	int a[N],rt[N],num,ans[N],inv[N];
	vector<int> g[N];
	void pushdown(int ro)
	{
		if(!ls)ls=++num,t[ls].init();
		if(!rs)rs=++num,t[rs].init();
		t[ls].val=t[ls].val*t[ro].val,t[rs].val=t[rs].val*t[ro].val;
		t[ro].val=Node(1,0,0,0);
	}
	ll query(int ro,int l,int r)
	{
		if(l==r)return t[ro].val.d;
		pushdown(ro);
		return (query(ls,l,mid)+query(rs,mid+1,r))%mo;
	}
	void updat(int ro,int l,int r,int L,int R,const Node &x)
	{
		if(L<=l&&r<=R){t[ro].val=t[ro].val*x;return;}
		pushdown(ro);
		if(L<=mid)updat(ls,l,mid,L,R,x);
		if(R>mid)updat(rs,mid+1,r,L,R,x);
	}
	int merge(int &x,int &y)
	{
		if(!x||!y)return x+y;
		if(!t[x].l&&!t[x].r)swap(x,y);
		if(!t[y].l&&!t[y].r)
		{
			t[x].val=t[x].val*Node(t[y].val.b,0,0,t[y].val.d);
			return x;
		}
		pushdown(x),pushdown(y);
		t[x].l=merge(t[x].l,t[y].l),t[x].r=merge(t[x].r,t[y].r);
		return x;
	}
	void dfs(int u,int f,int k)
	{
		rt[u]=++num,t[rt[u]].init();
		updat(rt[u],1,w,1,w,Node(0,1,0,0));
		updat(rt[u],1,w,1,a[u],Node(k,0,0,0));
		for(auto v:g[u])
			if(v!=f)dfs(v,u,k),updat(rt[v],1,w,1,w,Node(1,1,0,0)),rt[u]=merge(rt[u],rt[v]);
		updat(rt[u],1,w,1,w,Node(1,0,1,0));	
	}
	int Lagrange()
	{
		static int f[N],inv[N],g[N],s;
		inv[1]=f[0]=1;
		for(int i=2;i<=n+1;i++)
			inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;
		for(int i=1;i<=n+1;i++)
			for(int j=n+1;j>=0;j--)
				f[j]=((j?f[j-1]:0)+1ll*(mo-i)*f[j]%mo)%mo;
		for(int i=1;i<=n+1;i++)
		{
			g[0]=1ll*f[0]*(mo-inv[i])%mo;
			for(int j=1;j<=n+1;j++)
				g[j]=1ll*(f[j]-g[j-1]+mo)%mo*(mo-inv[i])%mo;
			int tmp=ans[i];
			for(int j=1;j<=n+1;j++)
			{
				if(i>j)tmp=1ll*tmp*inv[i-j]%mo;
				if(i<j)tmp=1ll*tmp*(mo-inv[j-i])%mo;
			}
			for(int j=K;j<=n+1;j++)
				s=(s+1ll*tmp*g[j]%mo)%mo;
		}
		return s;
	}
	void work()
	{
		scanf("%d%d%d",&n,&K,&w);
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		for(int i=1,u,v;i<n;i++)
			scanf("%d%d",&u,&v),g[u].push_back(v),g[v].push_back(u);
		for(int i=1;i<=n+1;i++)
		{
			num=0;
			dfs(1,0,i);
			ans[i]=query(rt[1],1,w);
		}
		printf("%d\n",Lagrange());
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：sry_ (赞：2)

#### 秘密袭击

##### 题意

给定一颗含 $n$ 个结点的树，每个点有点权 $d_i$ ，求所有联通块中第 $k$ 大之和。

$1\leq n,m,k\leq 1666,1\leq d_i\leq m$ ，时间限制 $5$ 秒。

##### 题解

一道很有趣的题目。 

**做法简述：由于 $dp$ 为卷积形式，对其多项式求点值，并通过类似整体 $dp$ 的方式维护变换，再通过拉格朗日插值还原多项式。**

由于每次统计 $d_i$ 较难，一个直观的想法是转化成 $0/1$ 问题，若答案为 $d_i$ ，则在 $[1,d_i]$ 均统计一遍。

具体的，答案可以写成 $\sum_{S} kth(S)=\sum_{S} \sum_{i=1}^n [i\leq kth(S)]=\sum_{i=1}^n \sum_S [i\leq kth(S)]$ 。

那么对于每个 $i$ ，将点权 $\geq i$ 的设为 $1$ ，其余为 $0$ ，那么我们只需要知道有多少个联通块其点权和 $\geq k$ 。

这是一个简单的树形 $dp$ ，根据树形背包可得时间复杂度为 $\mathcal O(nkw)$ 。

据说就过了此题？？？喜提 $\text{LOJ}$ 最优解，比我的快 $20$ 倍（

我们将 $dp$ 式子写出，设 $f_{i,j,p}$ 表示当前根为 $i$ ，且考虑点权 $\geq j$ 的情况时选择 $p$ 个 $1$ 的联通块个数。

也很好转移
$$
f_{i,j,p}=\prod_{(u,v)} (f_{v,j,c_v}+1) (\sum c_v=[d_i\geq j])
$$
由于背包的实质为卷积，不妨将该 $dp$ 写成 $\text{OGF}$ 的形式。

设
$$
\begin{aligned}
F_{i,j}&=\sum_{p=0}^n f_{i,j,p}\cdot x^p\\G_{i,j}&=\sum_{v\in sub(i)}^n f_{v,j}
\end{aligned}
$$
可得
$$
\begin{aligned}
F_{i,j}&=x^{[d_i\geq j]}\prod_{(u,v)} (F_{v,j}+1)\\Ans&=\sum_{i=1}^{m} \sum_{j=k}^m [x^j] G_{1,i}\\&=\sum_{j=k}^m[x^j] \sum_{i=1}^m G(1,i) 
\end{aligned}
$$
显然这东西不能跑过去。

考虑进一步的优化，由于多项式乘法太慢我们不妨求出 $\sum_{i=1}^m G(1,i)$ 多项式的点值最后在通过拉格朗日插值插回去，那么我们需要求出 $n+1$ 个点值。

显然
$$
\begin{aligned}
F_{i,j}(x)&=x^{[d_i\geq j]} \prod_{(u,v)} F_{v,j} (x)\\G_{i,j} (x)&=\sum_{(u,v)} G_{v,j} (x)+F_{i,j} (x)
\end{aligned}
$$
但这还是 $O(nkw)$ 的。（悲

先考虑 $x$ 为定值且仅有一个的情况。

我们需要维护的操作是维护 $n$ 个关于 $F,G$ 的点值数组。

- 对于新点 $u$ ，$F$ 的前缀赋值为 $x$ ，后缀赋值为 $1$ 。$G$ 数组赋值为 $0$ 。
- 对于 $(u,v)$ ，我们现将 $v$ 的 $F$数组全体加一，然后将两个 $F$ 数组对应位置相乘，将 $G$ 数组对应位置相加
- 将 $u$ 的 $F$ 数组加到 $G$ 数组上。

注意到这变换是相同的，不妨设计一个变换形式来实现快速转移。

定义变换 $(a,b,c,d)$ 的作用为
$$
(a,b,c,d):(f,g)\longrightarrow (af+b,cf+g+d)
$$
容易将上方三个式子写成相对应的变换，但我们要对于变换实现乘法
$$
(a_1,b_1,c_1,d_1)\cdot (a_2,b_2,c_2,d_2)
$$
这个也很好推
$$
(a_1,b_1,c_1,d_1):(f,g)\longrightarrow (a_1f+b_1,c_1f+g+d_1)
$$
$$
(a_2,b_2,c_2,d_2):(a_1f+b1,c_1f+g+d_1)\longrightarrow (a_1a_2f+b_1a_2+b_2,(c_2a_1+c_1)f+g+c_2b_1+d_1+d_2)
$$
那么
$$
(a_1,b_1,c_1,d_1)\cdot(a_2,b_2,c_2,d_2)=(a_1a_2,b_1a_2+b_2,c_2a_1+c_1,c_2b_1+d_1+d_2)
$$
这样我们就可以知道每个点所对应的变换来快速求出答案了。

但这还是 $\mathcal O(nkw)$ 的。（悲

注意到上述操作很像区间加法，不妨用线段树支持变换。

具体来讲，我们类似打区间 $tag$ 的，标记下传的方式可以得到每个点的变化，而对于合并子树也类似线段树合并。

而这个线段树合并需要支持标记下传，并且由于变换的乘法没有交换律我们需要考虑一下非空的子结点是 $u/v$ 。

这个线段树合并的时/空复杂度也是 $\mathcal O(n\log n)$ 的，因为标记下传仅在两个线段树的 $\cap$ 下传，时间复杂度依然是 $\mathcal O(n\log n)$ 的，所以空间复杂度仅多了常数 $(2)$ 倍。

由于我们需要求 $x$ 在 $1\sim n+1$ 的点值需要将上述做法重复 $n+1$ 遍。

即总时间复杂度为 $\mathcal O(n^2\log n)$ ，但这常数肉眼可见的大，所以被暴力碾了。 

---

## 作者：lory1608 (赞：2)

这道题的数据不好造，所以**树形**$\texttt{dp}$可以踩标算。

~~由于自己dp太差，还是写写题解积累一下经验，理清思路~~。

本题中注意到时间限制是$5s$，那么对于$n=1666,k=1666$的数据范围，我们可以考虑$\Theta(nk^2)$，但是要加很多优化。

在本题中，我们枚举每个点，假定他就是第$k$大的点，那么为了不算重复，我们需要将所有大于它的权值的点，与和它权值相等且编号比他小的点的权重设为$val=1$，否则设为$val=0$。

那么，我们只用$dp$出包含它的比他大的点的个数的次数即可，显然可用**树形背包**。

即$dp[u][i]$表示在$u$点，一共选了$i$个点比它大的方案数。

在本题中要强制选子树的根，即$dp[u][val[u]]=1$。

怎么转移呢？

$dp[u][j+k]=dp[u][j]\times dp[v][k]$。

就这$\cdots\cdots$。

但是有一些细节，想请大家注意，我也要注意防止犯此类错误。

- 最好在$dp$时新建一个数组$tmp$，将$dp$的值存在$tmp$中。(这样好写，好调)。

- 循环中只用循环到$\min{k,siz[u]}$即可，这样复杂度可以少一个$k$。

- 在统计答案时，要把之前的加上去。

关于卡常：清空是只请空要用的，如果比他大的数小于$k$,那么不用统计。

跑起来飞快~~~~。

~~不知道为什么在12-14跑的这么慢~~。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#define ll long long 
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define REP(u) for(int i=p[u];i!=-1;i=e[i].nxt)
using namespace std;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
inline int getint()
{
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')ch=getchar();
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
const int maxn=1667,mod=64123;
int n,k,w;
ll dp[maxn][maxn],ans,tmp[maxn];
int d[maxn],val[maxn],sum,sz,p[maxn],siz[maxn];
struct edge
{
	int v,nxt;
	edge(int vv=0,int nn=0){v=vv,nxt=nn;}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}
inline void dfs(int u,int fa,int k)
{
	siz[u]=1;
	int cnt=1;
	REP(u)
	{
		int v=e[i].v;
		if(v==fa)continue;
		dfs(v,u,k);
		cnt+=siz[v];
	}
	FOR(j,0,cnt)dp[u][j]=0;
	dp[u][val[u]]=1;
	REP(u)
	{
		int v=e[i].v;
		if(v==fa)continue;
		FOR(j,0,siz[u]+siz[v])tmp[j]=0;
		FOR(j,0,siz[u])
		{
			if(dp[u][j]==0)continue;
			FOR(kk,0,siz[v])
			{
				if(dp[v][kk]==0)continue;
				tmp[j+kk]+=(dp[u][j]*dp[v][kk])%mod;
				tmp[j+kk]%=mod;
			}	
		}
		FOR(j,0,siz[u])tmp[j]=(tmp[j]+dp[u][j])%mod;
		FOR(j,0,siz[u]+siz[v])dp[u][j]=tmp[j];
		siz[u]+=siz[v];
	}
}
int main()
{
//	freopen("coat.in","r",stdin);
//	freopen("coat.out","w",stdout);
	memset(p,-1,sizeof(p));
	n=getint(),k=getint(),w=getint();
	FOR(i,1,n)d[i]=getint();
	FOR(i,1,n-1)
	{
		int x=getint(),y=getint();
		add(x,y);add(y,x);
	}
	FOR(i,1,n)
	{
		sum=0;
		FOR(j,1,n)
		{
			if((i>j&&d[i]==d[j])||(d[j]>d[i]))val[j]=1,sum++;
			else val[j]=0;
		}
		if(sum<k-1)continue;
		dfs(i,0,k-1);
		ans+=(d[i]*dp[i][k-1])%mod;
		ans%=mod;
	} 
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：AzusaCat (赞：0)

给定 $n$ 个点的树，每个点有权值 $a_i\in [1,w]$，对求出树上每个连通块第 $k$ 大权值（相同计算多次）的和，对 $64123$ 取模。$n,w,k\leqslant 1666$。

先考虑 /dao 掉这个第 $k$ 大。
$$
\begin{aligned}
&\sum_S\mathrm{kth}(S)\\
=&\sum_{i=1}^wi\sum_S[\mathrm{kth(S)}=i]\\
=&\sum_{i=1}^w\sum_S[\mathrm{kth(S)}\geqslant i]\\
=&\sum_S\sum_{i=1}^w[cnt_{S,i}\geqslant k]
\end{aligned}
$$
其中，$S$ 表示任意一个连通块，$cnt_{S,i}$ 表示 $S$ 中权值大于等于 $i$ 的点的个数。

我们考虑一个暴力 dp，钦定一个根，设 $f(u,i,j)$ 表示以 $u$ 为 lca 的所有连通块，权值大于等于 $i$ 的点的个数为 $j$ 的连通块个数。转移是一个背包的形式。我们只需要求出来。这样可以做到 $O(n^2w)$ 的复杂度，卡卡常能过。

现在我们考虑优化，注意到第三维是一个背包，我们考虑把第三维改写成生成函数的形式，那么第三维是一个卷积，由于次数不超过 $n$，我们考虑用拉格朗日插值去插出这个多项式。

为了方便获取答案，再设一个 $g(u,i,j)$ 表示 $u$ 及其子树内的所有 $f(v,i,j)$ 之和，那么新的转移为
$$
F_{u,i}=z^{[a_u\geqslant i]}\prod (F_{v,i}+1)\\
G_{u,i}=F_{u,i}+\sum G_{v,i}
$$
对其带入某个值 $z=t$，则有
$$
\newcommand{\F}{\hat{F}}
\newcommand{\G}{\hat{G}}
\F_{u,i}=(a_u\geqslant i?t:1)\prod (\F_{v,i}+1)\\
\G_{u,i}=\F_{u,i}+\sum \G_{v,i}
$$
这里的乘法是对应位相乘。

现在考虑固定某个位，把 $i$ 这一维看作下标，对某个 $u$ 我们的转移过程是什么样的：

1. 把 $\F$ 整体赋为 1。
2. 对于下标大于等于 $a_u$ 的地方，区间乘 $t$。
3. 枚举子树 $v$，令子树 $v$ 的 $\F$ 全局 +1，然后 $\F$ 对应相乘，$\G$ 对应相加。
4. 让 $\G$ 和 $\F$ 对应相加。

我们考虑设计一个变换 $(a,b,c,d):(f,g)\rightarrow (f',g')$，其输出为 $(af+b,cf+g+d)$，考虑变换之间的结合：
$$
(a_2,b_2,c_2,d_2):((a_1,b_1,c_1,d_1):(f,g))=\\
(a_1a_2f+b_1a_2+b_2,(c_2a_1+c_1)f+g+c_2b_1+d_1+d_2)\\
(a_1,b_1,c_1,d_1)\cdot(a_2,b_2,c_2,d_2)=(a_1a_2,b_1a_2+b_2,c_2a_1+c_1,c_2b_1+d_1+d_2)
$$
可以验证这个变换满足结合律，且存在单位元 $(1,0,0,0)$。同时注意到对于初始值 $(0,0)$，最后的值为 $(b,d)$。

现在考虑维护，我们使用线段树维护，除了过程 3 都很好直接通过打标记维护，过程 3 只需要线段树合并即可。注意由于现在是区间修改，所以在合并的时候需要注意如果合并的两个结点都没有左右儿子就不 pushdown 而是直接合并信息返回，同时虽然这个操作没有交换律，但是在线段树合并的时候交换 $x,y$ 后 $b,d$ 的值不变，而我们并不会再用到 $a,c$ 的值，所以复杂度依旧正确。最后某个 $x_i$ 对应的 $y_i$ 是所有叶节点的 $d$ 之和。

现在考虑怎么在求出点值之后还原系数，先放出来拉格朗日插值公式：
$$
F(x)=\sum_{i=1}^ny_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}
$$
我们先考虑计算出 $\prod(x-x_j)$，然后枚举 $i$，$\prod x_i-x_j$ 和 $y_i$ 都是常数，然后再把全部乘积除上 $(x-x_i)$ 即可。一次插值的复杂度 $O(n^2)$ 或 $O(n^2\log p)$。

认为 $n,k,w$ 同阶，则我们可以在 $O(n^2\log n)$ 的时间内解决问题。

草暴力比正解快 30 倍，建议把 ML 改成 4MB/mgx。


---


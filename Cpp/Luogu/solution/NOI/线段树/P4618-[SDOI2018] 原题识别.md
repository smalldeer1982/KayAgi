# [SDOI2018] 原题识别

## 题目背景

 - Input file: old.in
 - Output file: old.out
 - Time limit: 10 seconds
 - Memory limit: 512 megabytes

## 题目描述

“人肉题库” 小 $Q$ 刷题非常勤奋，题量破万。每当有人拿题目请教他时，小 $Q$ 总能在 $1$ 秒内报出这
是哪个 $OJ$ 的哪道题。因此，小 $Q$ 是被当作 “原题搜索机” 一样的存在。

有一天，小 $Q$ 来到了一棵 $n$ 个节点的有根树下，这棵树的根节点为 $1$ 号点，且每个节点都印着一道
题目。凭借超大的题量，小 $Q$ 迅速识别出了每道题的来源，并发现有些题目被搬运了好多次。他把每个
节点的题目都做了一个分类，第 $i$ 个节点的题目对应的题目种类为 $a_i$，当且仅当 $a_i=a_j$ 时，$i$ 点和 $j$ 点的题目来源是相同的。

同一道题目做多次除了增加 $AC$ 数以外，对本身的水平没有任何提高。为了调查这棵树的题目质量，
小 $Q$ 会不断提出以下两种询问共 $m$ 次：

- $1$ $x$ $y$：如果将 $x$ 点到 $y$ 点的最短路径上的所有点 (包括 $x$ 和 $y$) 对应的题目都做一遍，那么一共可
以做到多少道本质不同的题目？

- $2$ $A$ $B$：如果在 $A$ 点到根的最短路径上 (包括 $A$ 点和根) 等概率随机选择一个点 $x$，在 $B$ 点到根的最短路径上 (包括 $B$ 点和根) 等概率随机选择一个点 $y$，那么询问 $1$ $x$ $y$ 的答案期望是多少？

定义 $cnt_x$ 表示 $x$ 点到根最短路径上的节点个数，因为小 $Q$ 不喜欢分数，而且第 $2$ 类询问的答案一
定可以表示成$\frac{ans}{{cnt_A}*{cnt_B}}$的形式，你只需要告诉他 $ans$ 的值就可以了。

识别这些题目消耗了小 $Q$ 太大的精力，他没有办法自己去计算这些简单的询问的答案。请写一个程序回答小 $Q$ 的所有 $m$ 个问题。

## 说明/提示

 -$1 ≤ T ≤ 3,2 ≤ p ≤ n ≤ 100000,1 ≤ m ≤ 200000$
 -$ 10000 ≤ SA, SB, SC ≤ 1000000,1 ≤ x, y, A, B ≤ n$

子任务 $1$（$30$ 分）：只含第 $1$ 类询问。

子任务 $2$（$30$ 分）：满足 $p = n$。

子任务 $3$（$40$ 分）：没有任何附加的限制。

## 样例 #1

### 输入

```
2
5 3 10000 12345 54321
3
1 2 3
2 1 3
1 3 2
10 6 23456 77777 55555
5
1 1 10
2 3 5
2 7 5
2 5 4
1 8 6```

### 输出

```
1
5
1
4
34
61
45
3```

# 题解

## 作者：shadowice1984 (赞：27)

SDOI2018全部做完一遍祭

感觉是R2六道题中最精神污染的一道……

慢慢肝吧……

claris的树状数组题解太神啦没有看懂……

所以我们这里介绍一个简(chao)单(ji)易(nan)懂(xie)的主席树做法

___________________________

### 前置芝士:主席树(可持久化线段树,可持久化数组)

什么敢刚SD二轮题不会主席树?

出门左转luogu膜板区

# 本题题解

题目简单易懂,树上数颜色

如果只有操作1的显然可以树上莫队莽过去

但是我们有可爱的操作2此时的操作就略显辣手了

但是你仔细看一眼会发现数据是ran出来的!

这意味着一件事情,任意一个点到主链的距离均是O(logn)级别的

另外一件事情就是每种颜色的种类是O(1)级别的

因此我们的思路就是把这个树上问题变成序列问题，抽取路径的上的一条长链用序列上的数据结构进行维护

剩余的O(logn)个散点暴力插入，这样的话我们最后的复杂度是$O(nlog^2n)$的

所以让我们先来考虑一下序列上的问题~

## 序列问题

### 操作1

当然你可以直接莫队莽过去

但是这是序列，我们考虑一个优雅一点的log做法

这里有一个十分经典的套路叫只数每个颜色左侧第一个点

为此我们记$pre_{i}$表示i左侧第一个和它同色点的位置,如果这样的点不存在的话$pre_{i}=0$

那么一个点i是$[l,r]$中的左侧第一个点当且仅当$pre_{i}<l$

问题变成了查询区间中$pre_{i}<l$的点的个数

主席树经典问题,一个主席树即可解决了

### 操作2

在序列上操作2的限制变成了要求x在[1,A]之间,y在[1,B]之间了

讲一句很不要脸的话,我们考虑贡献(因为大部分时候你都是不知道怎么考虑的)!

原来是枚举每一个询问考虑有多少个点对这个询问产生了贡献

现在我们是枚举每一个点看有多少个有效询问覆盖它

然后分两种情况讨论

#### case1:i在(A,B]之间

此时我们发现i产生了贡献的询问必须满足3个条件

1.$pre_{i}<A$

2.左端点在$(pre_{i},A]$之间

3.右端点在$[i,B]$之间

所以这样的询问一共有$(A-pre_{i})(B-i+1)$种

拆一下式子就是点i的贡献是$[pre_{i}<A](A(B+1)-pre_{i}(B+1)-Ai+ipre_{i})$

#### case2:i在[1,A]之间

##### case 2.1:左端点是x

此时我们发现i产生了贡献的询问必须满足两个条件

1.左端点在$(pre_{i},i)$之间

2.右端点在$[i,B]$之间

所以这样的询问有$(i-pre_{i})(B-i+1)$种

##### case 2.2:左端点是y

此时我们发现i产生了贡献的询问必须满足两个条件

1.左端点在$(pre_{i},i)$之间

2.左端点在$[i,A]$之间

所以这样的询问一共有$(i-pre_{i})(B-i+1)$种

那么我们把两个点的贡献加起来点i的贡献就是

$(i-pre_{i})(A+B)+(i-pre_{i})(-2i+2)-1$减1是为了避免重复计算$(i,i)$这个询问

那么我们发现case2的贡献可以轻易的使用前缀和O(1)的进行维护

而case1的贡献可以使用主席树维护$(1,i,pre_{i},ipre_{i})$的和来进行维护

那么我们的操作2就解决啦~

_____________________

## 序列上树

### 操作1

我们发现一个非常神奇的性质，这棵树任意两点间的路径，他们的lca总是离一个点特别近，近到了$O(logn)$的级别

假设我们处理一个$(x,y)$的询问(假设lca离x更近)，那么我们先建一个树形主席树，然后这样就可以快速查出(lca,y)的颜色种类数，这里的pre你可以每种颜色开一个栈在dfs的时候顺手维护一下

此时我们枚举(x,lca)路径上的点，查询这种颜色是否在(lca到y)上出现过

问题来了怎么查询？

你当然可以把这问题转化为一个查询区间里某种颜色出现多少次，然后树形主席树大力维护即可

可是我们的操作2还需要一些奇奇怪怪的信息来维护，因此我们考虑另一种方法来进行查询工作

我们建一个树形的可持久化数组(其实还是主席树)，每经过一个点i，进行一个赋值操作，将下标为$a_{i}$的位置赋值为i

那么我们在某一个点x的数组历史版本对应的就是x到1路径上某个颜色最后一次出现的点的编号

那么我们查询(lca,y)路径上是否出现了某种颜色x其实就是查询y这个历史版本的数组的第x项的深度是否大于等于lca的深度，如果大于等于的话证明颜色x最后一次出现的位置在链上，因此x就在路径里出现了

这样的话我们可以$O(log^2n)$的解决操作1

### 操作2

我们先处理直路径的部分，因为这一部分可以直接套用序列问题的代码，只是需要把序列的普通主席树改成树上主席树，可能需要注意的一点是，主席树中的下标应该是深度

所以我们先计算这3部分操作2的答案

1.x在(1,lca),y在(1,B)

2.y在(1,lca),x在(1,A)

3.然后发现 (1,lca) ,(1,lca)的路径被重复计数了，因此减去这一部分的答案

上述3部分全部可以直接套用序列问题的代码，不再赘述

好了下面我们要考虑 x在(lca,A],y在(lca,B]的部分了

我们还是继续统计贡献

首先先特判掉lca的贡献，因为我们的x和y都不能取到lca但是lca一定出现在这部分路径上

显然lca一定会被数到所以lca的贡献是$(dep_{A}-dep_{lca})(dep_{B}-dep_{lca})$

然后我们考虑你在操作1的时候是如何处理这种弯的路径的

显然是先查了一个长链然后向长链里暴力插点对吧

所以两种点的贡献方式完全不同，分情况考虑一下贡献

### case 1:长链中点的贡献

那么我们在长链上跑的是普通的区间数颜色

无论如何y的个数都是$(dep_{B}-dep_{lca})$个

无论如何x的个数都是$(dep{A}-dep_{i}+1)$个

只需要考虑这个点到底是不是链上的第一个颜色点就行了

所以加上一个限制$dep_{pre_{i}}<dep_{lca}$

然后把序列上的主席树搬过来之后就可以利用主席树查贡献展开式的各种项相加就好了

### case2:短链中点的贡献

应该是最难的部分了

我们发现操作1中我们直接对短链进行暴力了，因此我们从这个暴力什么时候会让答案+1的角度考虑短链中点的贡献

首先如果这个点i的pre的深度大于等于lca的深度是不会产生贡献的，因为无论怎么取他都不是第一个点

之后我们考虑查这个点的颜色是否在(lca,A)中出现过，如果没有出现的话y可能的取值共有$(dep_{B}-dep_{i}+1)$种，而此时x是可以随便取的因此可能的取值共有$(dep_{A}-dep_{lca})$种，所以贡献就是二者相乘了

接下来如果出现过的话我们是需要找一个这样的点，从lca出发向A的方向往下走，第一个出现的和i同色的点pr，如果x在pr和lca之间的话我们就还是可以暴力插点成功的

问题来了怎么求这个玩意？

我们的可持久化数组只能告诉我们每种颜色最后一次出现的点是什么，但是我们先是要求某种颜色第一次出现的位置

还记得吗？每种颜色的个数是期望$O(1)$的

所以我们求出这个颜色最后一次出现的位置之后直接顺着他的pre开始跳，直到我们要跳出了lca位置，这样我们就找到了这个颜色第一次出现的位置，期望进行O(1)次跳跃

那么此时点y可能的取值还是有$dep_{B}-dep_{i}+1$中，而x可能出现的取值有$(dep_{pr}-dep_{lca}-1)$种，点i的贡献就是是二者相乘了

分析下复杂度会发现复杂度是期望$O(log^2n)$的

这样我们成功解决了操作2就可以写这道题了

_____________________

当然不用我多说也知道这道题有多难写了吧……(然而跑的飞起，所有点都在2s内跑完了)

如果胡写乱写基本调试不出来，请注意代码风格

当然这里的代码基本就不能看了，仅供参考

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<stack>
using namespace std;const int N=1e5+10;const int E=20*N;typedef long long ll;typedef unsigned int uit;
int n;int m;int p;int v[2*N];int x[2*N];int ct;int al[N];int pre[N];int dep[N];int a[N];bool book[N];
stack <int> s[N];int fa[N];int T;
struct data//主席树强行维护信息
{
    int v0;ll v1;ll v2;ll v3;data(int a=0,ll b=0,ll c=0,ll d=0){v0=a;v1=b;v2=c;v3=d;}
    friend data operator +(data a,data b){return data(a.v0+b.v0,a.v1+b.v1,a.v2+b.v2,a.v3+b.v3);}
    friend data operator -(data a,data b){return data(a.v0-b.v0,a.v1-b.v1,a.v2-b.v2,a.v3-b.v3);}
};
struct answ//树上前缀和
{
    ll v1;ll v2;answ(ll a=0,ll b=0){v1=a;v2=b;}
    friend answ operator +(answ a,answ b){return answ(a.v1+b.v1,a.v2+b.v2);}
    friend answ operator -(answ a,answ b){return answ(a.v1-b.v1,a.v2-b.v2);}
}val[N];
struct per_linetree//主席树的板子
{
    data v[E];int s[E][2];int root[N];int ct;
    inline void modify(int p1,int p2,int l,int r,const int& pos,const data& pl)
    {
        v[p2]=v[p1]+pl;if(r-l==1){s[p2][0]=0;s[p2][1]=0;return;}int mid=(l+r)/2;
        if(pos<=mid){s[p2][1]=s[p1][1];modify(s[p1][0],s[p2][0]=++ct,l,mid,pos,pl);}
        else {s[p2][0]=s[p1][0];modify(s[p1][1],s[p2][1]=++ct,mid,r,pos,pl);}
    }
    inline data query(int p,int l,int r,int dl,int dr)
    {
        if(p==0||dl==l&&dr==r){return v[p];}int mid=(l+r)/2;data ret;
        if(dl<mid)ret=ret+query(s[p][0],l,mid,dl,min(dr,mid));
        if(mid<dr)ret=ret+query(s[p][1],mid,r,max(dl,mid),dr);return ret;
    }
    inline void cmodify(int p1,int p2,int pos,const data& pl)
    {modify(root[p1],root[p2]=++ct,0,n+1,pos+1,pl);}
    inline data cquery(int p1,int p2,int l,int r)
    {return query(root[p2],0,n+1,l+1,r+1)-query(root[p1],0,n+1,l+1,r+1);}
    inline void clear(){ct=1;}
}plt;
struct per_array//可持久化数组，还是主席树的板子
{
    int v[E];int s[E][2];int root[N];int ct;
    inline void modify(int p1,int p2,int l,int r,const int& pos,const int & pl)
    {
        v[p2]=pl;if(r-l==1){s[p2][0]=0;s[p2][1]=0;return;}int mid=(l+r)/2;
        if(pos<=mid){s[p2][1]=s[p1][1];modify(s[p1][0],s[p2][0]=++ct,l,mid,pos,pl);}
        else {s[p2][0]=s[p1][0];modify(s[p1][1],s[p2][1]=++ct,mid,r,pos,pl);}
    }
    inline int query(int p,int l,int r,int pos)
    {
        if(p==0||r-l==1){return v[p];}int mid=(l+r)/2;
        if(pos<=mid){return query(s[p][0],l,mid,pos);}
        else {return query(s[p][1],mid,r,pos);}
    }
    inline void cmodify(int p1,int p2,const int& pos,const int& pl)
    {modify(root[p1],root[p2]=++ct,0,n+1,pos+1,pl);}
    inline int cquery(int p,int pos){return query(root[p],0,n+1,pos+1);}
    inline void clear(){ct=1;}
}pa;
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline void dfs(int u,int f)//dfs建树形主席树，顺手处理出pre和树上前缀和
{
    pre[u]=s[a[u]].empty()?0:s[a[u]].top();s[a[u]].push(u);int dp=dep[pre[u]];
    plt.cmodify(f,u,dp,data(1,dep[u],dp,(ll)dp*dep[u]));
    pa.cmodify(f,u,a[u],u);fa[u]=f;
    val[u]=val[f]+answ(dep[u]-dp,(ll)(dep[u]-dp)*(-2*dep[u]+2)-1);
    for(int i=al[u];i;i=x[i]){dep[v[i]]=dep[u]+1;dfs(v[i],u);}
    s[a[u]].pop();
}
inline int query1(int u,int v)
{
    if(dep[u]>dep[v])swap(u,v);int lc=u;int lc1=v;//暴力找lca
    for(;lc1>p;lc1=fa[lc1])book[lc1]=true;
    for(;lc>p;lc=fa[lc])if(book[lc])goto ed1;
    lc=(dep[lc]<dep[lc1])?lc:lc1;ed1:;
    for(int x=v;x>p;x=fa[x])book[x]=false;
    int ans=plt.cquery(fa[lc],v,-1,dep[lc]-1).v0;//提取长链信息
    for(int x=u;x!=lc;x=fa[x])
        if(dep[pre[x]]<dep[lc]&&dep[pa.cquery(v,a[x])]<dep[lc])ans++;//暴力插入短链
    return ans;
}
inline ll subquery(int l,int r)//操作2的序列问题
{
    ll L=dep[l];ll R=dep[r];data ret=(l!=r)?plt.cquery(l,r,-1,dep[l]):data();//无脑考虑贡献即可
    return val[l].v1*(L+R)+val[l].v2+ret.v0*L*(R+1)-L*ret.v1-(R+1)*ret.v2+ret.v3;
}
inline ll query2(int u,int v)//操作2
{
    if(dep[u]>dep[v])swap(u,v);int lc=u;int lc1=v;//还是暴力找lca
    for(;lc1>p;lc1=fa[lc1])book[lc1]=true;
    for(;lc>p;lc=fa[lc])if(book[lc])goto ed1;
    lc=(dep[lc]<dep[lc1])?lc:lc1;ed1:;
    for(int x=v;x>p;x=fa[x])book[x]=false;
    ll ret=subquery(lc,v)+subquery(lc,u)-subquery(lc,lc);//处理直路径
    if(lc==u)return ret;data tr=plt.cquery(lc,v,-1,dep[lc]-1);//弯路径的长链贡献,主席树查一发即可
    ret+=(dep[u]-dep[lc])*((ll)tr.v0*(dep[v]+1)-tr.v1)+(ll)(dep[v]-dep[lc])*(dep[u]-dep[lc]);//记得加上lca
    for(int x=u;x!=lc;x=fa[x])
    {
        if(dep[pre[x]]>=dep[lc]){continue;}//如果数不到这个点就跳过
        int pr=pa.cquery(v,a[x]);
        if(dep[pr]<dep[lc]){ret+=(ll)(dep[v]-dep[lc])*(dep[u]-dep[x]+1);continue;}//如果一定可以插入成功就直接算贡献
        for(;dep[pre[pr]]>=dep[lc];pr=pre[pr]);if(dep[pr]==dep[lc])continue;//跳pre找第一次出现的点
        ret+=(ll)(dep[pr]-dep[lc]-1)*(dep[u]-dep[x]+1);//计算贡献
    }return ret;
}
namespace Maker//生成器代码,直接粘就行了
{
    uit SA,SB,SC;
    uit rng61(){SA^=SA<<16;SA^=SA>>5;SA^=SA<<1;uit t=SA;SA=SB;SB=SC;SC^=t^SA;return SC;}
    void gen()
    {
    	scanf("%d%d%u%u%u",&n,&p,&SA,&SB,&SC);
    	for(int i=2;i<=p;i++)add(i-1,i);
    	for(int i=p+1;i<=n;i++)add(rng61()%(i-1)+1,i);
    	for(int i=1;i<=n;i++)a[i]=rng61()%n+1;
    }
}
inline void solve()
{
    Maker::gen();scanf("%d",&m);dep[1]=1;dfs(1,0);
    for(int i=1,t,l,r;i<=m;i++)
    {scanf("%d%d%d",&t,&l,&r);printf("%lld\n",(t==1)?query1(l,r):query2(l,r));}
}
inline void clear(){plt.clear();pa.clear();for(int i=1;i<=n;i++)al[i]=0;ct=0;}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++){solve();clear();}return 0;}//拜拜程序~
```

























---

## 作者：GaryH (赞：7)

## P4618 题解

一道对笔者本人来说较难的数据结构题。

给一个比较好写的阳间做法，如有错误或笔误敬请指出，笔者将不胜感激。

**题意**：

给一棵节点上有颜色的有根树，要求支持两种询问，分别是给 $u,v$，求 $u,v$ 间路径的颜色数 $f(u,v)$，

和给 $A,B$，求 $\sum\limits_{u\in S(A)}\sum\limits_{v\in S(B)}f(u,v)$，其中 $S(A)$ 是点 $A$ 到根的路径上的所有点形成的点集。

保证树的形态，是一条长链加若干个深度不超过 $\log n$ 的子树接在链上，保证颜色随机。

**做法**：

我们对树进行 `dfs`，并同时维护一个时刻 $t$，每当第一次访问某个节点，或一个节点对应子树的访问结束后，

都将时刻加一，并记录：每个节点被第一次访问时的时刻，以及每个节点对应子树的访问完全结束后的时刻。

记节点 $u$ 被第一次访问时的时刻是 $st_u$，其子树内所有节点都访问后时刻为 $en_u$。

同时，为了方便下文描述，我们称 $st_u$ 为 $u$ 的入栈时刻，称 $en_u$ 为 $u$ 的出栈时刻。

那考虑以整棵树的访问时刻为下标，写出一个 $2n\times 2n$ 的矩阵 $W$，这个矩阵的每个点的权对应一条路径的答案。

其中，对于每对点 $(u,v)$，记 $(u,v)$ 路径上的颜色数为 $f(u,v)$，则在矩阵上有 $4$ 个点的权值与之对应，分别是：

$W_{st_u,st_v}=W_{en_u,en_v}=f(u,v),W_{st_u,en_v}=W_{en_u,st_v}=-f(u,v)$，其中 $W_{x,y}$ 是矩阵 $W$ 中点 $(x,y)$ 的权值。

考虑构建矩阵 $W$ 的好处，即对于询问 $X(A,B)=\sum\limits_{u\in S(A)}\sum\limits_{v\in S(B)}f(u,v)$ 的值，其答案可以在矩阵上找到，

具体的，$X(A,B)$ 的值一定等于 $\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$，我们可以利用 $st$ 和 $en$ 的性质来证明这一点，即：

考虑对于任意一点 $u$，不难证明：点 $v\in S(u)$ 等价于 $st_v<st_u<en_v$，那么考虑询问 $X(A,B)$，

我们考虑证明，所有 $f(u,v)$ 对 $X(A,B)$ 的贡献和其对 $\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$ 的贡献是一致的，

从而证明 $X(A,B)=\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$。以下将会把 $f(u,v)$ 分成四种情况讨论。

第一种是 $u\in S(A),v\in S(B)$，显然此时 $f(u,v)$ 给 $X(A,B)$ 提供了恰 $1$ 次贡献，

而由条件可得 $st_u<st_A<en_u,st_v<st_B<en_v$，

故 $f(u,v)$ 在 $\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$ 中恰好被累加了一次。

第二种是 $u\in S(A),v\notin S(B)$，显然此时 $f(u,v)$ 不会给 $X(A,B)$ 提供贡献，

而由条件可得 $st_u<st_A<en_u$，以及：$st_B<st_v$ 或 $st_B>en_v$ 的两者之一成立，

若 $st_B<st_v$ 成立，则 $f(u,v)$ 在 $\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$ 中显然没有被累加，即贡献为 $0$；

若 $st_B>en_v$ 成立，则在 $\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$ 中，有 $W_{st_u,st_v}=f(u,v),W_{st_u,en_v}=-f(u,v)$，总贡献也为 $0$。

第三种是 $u\notin S(A),v\in S(B)$，这种情况和第二种情况类似，就不再赘述；

第四种是 $u\notin S(A),v\notin S(B)$，显然此时 $f(u,v)$ 不会给 $X(A,B)$ 提供贡献，

而由条件可得，$st_B<st_u$ 或 $st_B>en_u$ 的两者之一成立，以及 $st_B<st_v$ 或 $st_B>en_v$ 的两者之一成立，

对四种小情况分别讨论一下，也能证明 $f(u,v)$ 在 $\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$ 中的贡献是正确的，这里就也不赘述了。

经过了漫长~~而恶心~~的分类讨论，我们证明了 $X(A,B)=\sum\limits_{1\le i\le st_A}\sum\limits_{1\le j\le st_B}W_{i,j}$，

故我们可以通过快速查询矩阵 $W$ 的二维前缀和，来回答形如 $X(A,B)=\sum\limits_{u\in S(A)}\sum\limits_{v\in S(B)}f(u,v)$ 的询问。

为了查询前缀和，我们考虑维护每种颜色的点对 $W$ 的贡献，即考虑该颜色对 $W$ 中哪些位置的值造成了影响。

注意，$W_{a,b}$ 受颜色 $c$ 影响，当且仅当：存在 $x$，满足点 $x$ 的颜色为 $c$，且 $W_{a,b}$ 受点 $x$ 影响，

而 $W_{a,b}$ 受点 $x$ 影响，当且仅当：

对于满足 $W_{a,b}=\pm f(s,t)$ 的无序点对 $(s,t)$（显然这样的点对唯一），路径 $(s,t)$ 包含点 $x$。

这样定义的原因也是好理解的，即若 $W_{a,b}$ 受颜色 $c$ 影响，则 $W_{a,b}$ 的权值本身一定受到了颜色 $c$ 的贡献。

那么，对于每种颜色 $c$，我们希望能刻画出：$W$ 中所有被颜色 $c$ 影响的位置所共有的特征，

以便于维护出，颜色 $c$ 给 $W$ 的权值所带来的贡献。

因为颜色 $c$ 的影响即为所有颜色为 $c$ 的点的影响的累加，故先考虑刻画出 $W$ 中所有被点 $x$ 影响的位置的特征。

具体的，对于每个点 $x$，我们考虑一个所有包含该点的路径 $(u,v)$ 所共有的性质，即：

$u,v$ 中至少有一个点在 $x$ 子树内，且对 $x$ 的每个儿子 $y$，都满足 $u,v$ 不同时在 $y$ 子树内。

容易发现，这个性质足够充分，即满足该特点的路径都包含点 $x$。

考虑用每个点的入栈时刻和出栈时刻来书写这个性质，即：

1. $st_x<st_u<en_u<en_x$ 和 $st_x<st_v<en_v<en_x$，两者中至少满足一个；

2. 对 $x$ 的每个儿子 $y$，$st_y<st_u<en_u<en_y$ 和 $st_y<st_v<en_v<en_y$，两者最多满足一个。

显然，这两条限制同时满足，与路径 $(u,v)$ 包含点 $x$ 等价，也就与 $W_{st_u/en_u,st_v/en_v}$ 受点 $x$ 影响等价，

而这两条限制勾勒出的受影响位置集，在矩阵 $W$ 中有直观的表达方式，即：

第一个限制，形如在 $W$ 中框出两个长方形，分别是 $[1,2n]\times [st_x,en_x]$ 和 $[st_x,en_x]\times[1,2n]$，

表示受影响位置不在这两个长方形外，其中 $[a,b]\times[c,d]$，是左下角为 $(a,c)$，右上角为 $(b,d)$ 的长方形；

第二个限制，形如在 $W$ 中框出若干个正方形，其中对 $x$ 的每个儿子 $y$，都框出 $[st_y,en_y]\times[st_y,en_y]$，

表示受影响区域不在这些正方形内。那么，在排除了这些不在的区域后，剩下的所有区域就是该点的影响区域，

而一个颜色的影响区域，就等于所有该颜色的点的影响区域取并，

而我们现在需要做的，就是给这些影响区域的并区域，添加上当前颜色带来的 $1$ 的贡献。

考虑取并的麻烦之处在于，某个点的不可行区域可能是另外一个点的可行区域，这导致了判断可行的困难性，

但实际上我们发现，对于一个固定的点 $x$ 和其任意儿子 $y$，以下关系永远成立：

$([st_y,en_y]\times[st_y,en_y])\subseteq ([1,2n]\times [st_x,en_x])\cap([st_x,en_x]\times[1,2n])$；

同时，对 $x$ 的两个儿子 $y_1,y_2$，以下关系永远成立：

$[st_{y_1},en_{y_1}]\times[st_{y_1},en_{y_1}]\cap[st_{y_1},en_{y_1}]\times[st_{y_1},en_{y_1}]=\varnothing$。

这两条关系利用 $x,y_1,y_2$ 在树上的关系就不难证明，而这说明了，对于一个点影响区域的两种限制中，

第二种限制的所有禁止区域一定在第一种限制的两个允许区域的交之内，且任意两个第二种限制的禁止区域无交。

那么，记状态 $S(x)_{i,j}$ 代表 $W_{i,j}$ 是否受点 $x$ 影响，我们对下标在 $[1,2n]\times [st_x,en_x]$ 中的 $S(x)$ 值全部加一，

对下标在 $[st_x,en_x]\times[1,2n]$ 中的 $S(x)$ 值全部加一，以及 $x$ 的每个儿子 $y$，

对 $[st_y,en_y]\times[st_y,en_y]$ 中的 $S(x)$ 值全部减二，那么 $W_{i,j}$ 受 $x$ 影响，当且仅当这样操作后，$S(x)_{i,j}>0$。

上面的断言，用我们发现的两条关系就不难证明，且我们发现，这种方法在对多个点的影响取并时也同样适用，

具体的，对每种颜色 $c$ 记 $S'(c)_{i,j}=\sum\limits_{color(x)=c}S(x)_{i,j}$，则颜色 $c$ 对 $W_{i,j}$ 有影响，当且仅当 $S'(c)_{i,j}>0$。

那么，我们将找 $W$ 中所有受颜色 $c$ 影响的位置，转化为了找 $S'(c)$ 中所有值大于 $0$ 的位置，

且 $S'(c)$ 的构造方式是，从空矩阵开始，对若干个矩形做区间加 / 减操作，

且这样的区间加 / 减操作次数一定不多，因为树由一条长链加若干个随机树拼接而成，故每个点的儿子数较小，

同时每个节点的颜色也是随机的，故同颜色的节点数也较小，

故我们可以把所有区间加 / 减对应矩形的横纵坐标离散化，再对离散化后的 $S'(c)$ 暴力的维护修改操作，

最后枚举每个离散化后的位置 $S'(c)_{i,j}$，若其值大于 $0$，则其离散化前对应的矩形中的所有位置 $(i,j)$，

都满足 $W_{i,j}$ 受颜色 $c$ 影响。

那么，现在剩下的最后一个问题就是，对于颜色 $c$ 和 $W$ 中的某个全受颜色 $c$ 影响的矩形区域 $[l_1,r_1]\times[l_2,r_2]$，

我们如何快速为这个矩形区域中的所有值，添加上颜色 $c$ 带来的贡献，

且在若干次这样的操作后，我们需要能快速查询 $W$ 的二维前缀和。

注意，这里的添加贡献，不是指全部加，而是有些位置加，有些位置减，

原因是 $W$ 的定义，即某些 $W_{i,j}$ 值等于 $f(u,v)$，而另外一些 $W_{i,j}$ 值等于 $-f(u,v)$，具体在下文有提到。

这个问题的难点在于，对于受影响区域 $[l_1,r_1]\times[l_2,r_2]$ 中的所有位置中，有些位置需要加一，有些需要减一，

而不是全部加或全部减，所以直接对一个矩形添加贡献是难做的，但我们可以考虑每次添加贡献对查询的影响。

具体的，由于贡献的可减性，我们可以将对一个矩形加贡献，转化为对 $4$ 个前缀矩形加 / 减贡献，

那么问题转化为，对于每个询问，维护所有前缀添加 $v$（$v$ 可以为负）贡献的操作，对该询问的影响。

考虑对于一个前缀添加 $v$ 贡献的操作，哪些位置 $(i,j)$ 的 $W_{i,j}$ 的值实际上需要减 $v$，

我们发现，当且仅当 $i,j$ 中恰有一个数，在整棵树的访问时刻中是某个点的出栈时刻时，

$W_{i,j}$ 的值实际上需要减 $v$，其他的 $W_{i,j}$ 的值实际上都需要加 $v$。

也就是说，对于一次查询 $W$ 中前缀矩形 $[1,a]\times[1,b]$ 的前缀和的询问，

以及一次对 $W$ 中前缀 $[1,i]\times[1,j]$ 添加 $v$ 贡献的操作，

仅当 $i\le a$ 且 $j\le b$ 时，该次添加贡献的操作对该次询问有影响。

现在继续讨论影响的具体值，其中：设在时刻区间 $[i,a]$ 中有 $p$ 个时刻是某个点的入栈时刻，

有 $q$ 个时刻是某个点的出栈时刻；同时，设在时刻区间 $[j,b]$ 中有 $r$ 个时刻是某个点的入栈时刻，

有 $w$ 个时刻是某个点的出战时刻，则该次添加贡献的操作，对当前询问的贡献就是：$(pr-pw-qr+qw)v$。

上面的断言不难证明，利用我们对添贡献操作中，具体哪些位置加，具体哪些位置减的分析即可证明其正确性，

而注意到贡献的式子实际上等于 $(p-q)(r-w)v$，而 $p-q$ 仅与 $i,a$ 有关，$r-w$ 仅与 $j,b$ 有关，

且两者都具有区间可减性，故我们可以将两者分别表示成 $s(a)-s(i-1)$，$s(b)-s(j-1)$ 的形式，

其中 $s(x)$ 代表时刻 $x$ 之前的所有时刻中，入栈时刻的数量与出栈时刻数量的差。

所以，上面的贡献式也就等于 $(s(a)-s(i-1))(s(b)-s(j-1))v$，这时再将式子中的括号拆开，就是：

$s(a)s(b)v-s(a)s(i-1)v-s(j-1)s(b)v+s(i-1)s(j-1)v$。

那么，对于一个询问 $[1,a]\times[1,b]$，其答案就是所有添加贡献的操作对其的影响和，即：

$answer=\sum\limits_{([1,i]\times[1,j],v)\in Modify}(s(a)s(b)v-s(a)s(i-1)v-s(j-1)s(b)v+s(i-1)s(j-1)v)$，

其中 $([1,i]\times[1,j],v)\in Modify$ 的含义是，存在一次对前缀 $[1,i]\times[1,j]$ 添加 $v$ 贡献的操作，

由于长度限制，下文用 $01$ 变量 $M$，来代替 $([1,i]\times[1,j],v)\in Modify$ 的值，

也用二元组 $([1,i]\times [1,j],v)$，来代替一次对前缀 $[1,i]\times[1,j]$ 添加 $v$ 贡献的操作。

那么，我们将上面式子的每一项拆开，即：

$answer=\sum\limits_{M}(s(a)s(b)v)-\sum\limits_M(s(a)s(i-1)v)-\sum\limits_M(s(j-1)s(b)v)+\sum\limits_M(s(i-1)s(j-1)v)$，

有了这个式子，我们就可以将所有询问操作和添加贡献操作都离线下来，再用扫描线树状数组维护即可。

具体的，我们以 $-\sum\limits_Ms(a)s(i-1)v$ 这一项的维护方法为例，

注意到 $s(a)$ 的值不随操作 $([1,i]\times[1,j],v)$ 的变化而改变，故可以将式子写成 $-s(a)\sum\limits_Ms(i-1)v$，

而 $\sum\limits_Ms(i-1)v$ 的值就容易维护了，我们可以将其理解为，在平面上有若干个带权的点，其中：

点 $(i,j)$ 存在，当且仅当存在操作 $([1,i]\times[1,j],v)$，而若存在的话，此时该点权值就是 $s(i-1)v$，

那么 $\sum\limits_Ms(i-1)v$ 的值，就等于平面中 $[1,a]\times[1,b]$ 这片区域里，所有点点权的和，

相信看到这里的人肯定都会做了，而其他三项的维护方法，也和这个类似。

这道题就做完了，时间复杂度是 $O(n\log n)$，但我不太会证，想要了解的话可以看 `Claris` 的[题解](https://files.cnblogs.com/files/clrs97/old-solution.pdf)。

代码较其他做法来说还算好写，就不全贴在这里了，想看的话可以[点击链接](https://www.luogu.com.cn/paste/xr98dvr4)。

**参考文章**：

`Claris` 的题解，链接在上面。



---

## 作者：localhost (赞：5)

## 链上的情况

### 情况一

记录每个点$i$前一个与它一样的位置$pre_i$,

那么区间$[l,r]$内不同的个数也就是$[l,r]$中$pre_i<l$的个数

主席树统计即可

### 情况二

考虑每个点对答案的贡献,分类讨论

1. $i\in [1,A]$
   
   那么满足的$y\in (pre_i,i],x\in [i,A]$
   
   或$x\in (pre_i,i],y\in [i,B]$

   总贡献为$\sum (i-pre_i)\times(A+B-2i+2)-1$
   
   ($-1$为了避免$[i,i]$被重复计算)

   拆下式子: $(A+B+2)(\sum i-pre_i)-2(\sum i(i-pre_i))-\sum 1$

   可以发现这种情况可以直接前缀和维护

2. $i\in (A,B]$,满足$pre_i<A$
   
   那么满足的$x\in (pre_i,A],y\in [i,B]$

   总贡献为$\sum (A-pre_i)\times(B-i+1)$

   拆下式子$(A\sum 1-\sum pre_i)(B+1)-A\sum i+\sum ipre_i$

   可以发现这种情况可以用主席树维护

## 树上情况

观察数据形成方式:

- 前$p$个点形成一条主链,其他点随机向主链连边  
  所以树上任意点对的$\texttt{lca}$距离他们期望为$\mathcal O(\log n)$
- 每个点的颜色在$[1,n]$中随机,每种颜色数目期望为$1$

令$pre_i$为$i$的祖先中颜色与$i$相同的深度最大的点

### 第一问

设$x$与$y$中$x$离$\texttt{lca}(x,y)$更近

首先求出$y$到$\texttt{lca}$链上的颜色总数,

然后再暴力枚举$x$到$\texttt{lca}$链上的颜色更新答案

### 第二问

设$A$与$B$中$A$离$\texttt{lca}(A,B)$更近

分类讨论:

1. $x\in [1,\texttt{lca}],y\in [1,B]$,与链上的情况相同
2. $x\in [\texttt{lca},A],y\in [1,\texttt{lca}]$
   
   用$x\in [1,A],y\in [1,\texttt{lca}]$的答案减去
   
   $x,y\in [1,\texttt{lca})$的答案$\sum (2(i-pre_i)(\texttt{lca}-i)-1)$

   拆下式子: $2\texttt{lca}\sum (i-pre_i) - 2\sum i(i-pre_i)-\sum 1$

3. $x\in [\texttt{lca},A],y\in [\texttt{lca},B]$
   
   先求出$i\in [\texttt{lca,B}]$的贡献$\sum (B-i+1)(A-\texttt{lca}+1)$

   拆下式子: $(A-\texttt{lca}+1)(\sum B+1 - \sum i)$

   然后用$i\in (\texttt{lca},A]$更新

   $pre_i\le\texttt{lca}$,设$j$为$[\texttt{lca},B]$中第一个与它颜色相同的点

   贡献: $(A-i+1)(j-\texttt{lca})$

实现过程详见代码

```cpp
#include<bits/stdc++.h>
using std::list;
typedef long long ll;
const int N=100011;
int n,a[N];list<int>vec[N],e[N];
int RT[N];
struct node{
    ll v,pd,d,pdxd;// Σ1,Σdep[pre],Σdep[i],Σdep[pre]×dep[i]
    node operator+(const node&t){return node{v+t.v,pd+t.pd,d+t.d,pdxd+t.pdxd};}
    node operator-(const node&t){return node{v-t.v,pd-t.pd,d-t.d,pdxd-t.pdxd};}
};
struct prt{

int sz,ls[N*20],rs[N*20];
node s[N*20];
void build(int&x,int l,int r){
    s[x=++sz]=node{0,0,0,0};
    if(l==r)return;
    int m=l+r>>1;
    build(ls[x],l,m);build(rs[x],m+1,r);
}
void ins(int&x,int pre,int p,int l,int r,node v){
    s[x=++sz]=s[pre]+v;
    if(l==r)return;
    ls[x]=ls[pre],rs[x]=rs[pre];
    int m=l+r>>1;
    if(p<=m)ins(ls[x],ls[pre],p,l,m,v);
    else ins(rs[x],rs[pre],p,m+1,r,v);
}
node ask(int x,int y,int R,int l,int r){
    if(r<=R)return s[y]-s[x];
    int m=l+r>>1;
    node ans=ask(ls[x],ls[y],R,l,m);
    return R>m?ans+ask(rs[x],rs[y],R,m+1,r):ans;
}

}T;
int L[N],R[N],dfn,st[20][N*2];
int f[N],d[N],pre[N],b[N];ll sum[N][2];
void dfs(int x){
    st[0][L[x]=++dfn]=x;
    pre[x]=b[a[x]],b[a[x]]=x;
    T.ins(RT[x],RT[f[x]],pre[x],0,n,node{
        1,d[pre[x]],d[x],1ll*d[pre[x]]*d[x]
    });
    sum[x][0]=d[x]-d[pre[x]]+sum[f[x]][0];
    sum[x][1]=1ll*(d[x]-d[pre[x]])*d[x]+sum[f[x]][1];

    for(int to:e[x])d[to]=d[x]+1,dfs(to),st[0][++dfn]=x;
    R[x]=dfn;
    b[a[x]]=pre[x];
}
int gmd(int x,int y){return d[x]<d[y]?x:y;}
void ST(){
    for(int k=1;(1<<k)<=dfn;++k)
        for(int i=1;i<=dfn-(1<<k)+1;++i)
            st[k][i]=gmd(st[k-1][i],st[k-1][i+(1<<k-1)]);
}
void swap(int&x,int&y){int t=x;x=y;y=t;}
int lca(int x,int y){
    int l=L[x],r=L[y];
    if(l>r)swap(l,r);
    int k=log2(r-l+1);
    return gmd(st[k][l],st[k][r-(1<<k)+1]);
}
int v[N],ti;
bool chk(int x,int y,int p){
    return L[x]<=L[p]&&L[p]<=R[x]&&L[p]<=L[y]&&L[y]<=R[p];
}
ll ask1(int x,int y){
    if(d[x]>d[y])swap(x,y);
    int F=lca(x,y);
    ll ans=T.ask(RT[f[F]],RT[y],d[F]-1,0,n).v;
    ++ti;
    for(int i=x;i!=F;i=f[i])if(v[a[i]]!=ti){
        v[a[i]]=ti;
        bool ff=1;
        for(int j:vec[a[i]])
            if(chk(F,y,j)){ff=0;break;}
        ans+=ff;
    }
    return ans;
}
ll calc(int A,int B,node t){// i∈[1,A],i∈(A,B]
    return (d[A]+d[B]+2)*sum[A][0]-2*sum[A][1]-d[A]+
        (d[A]*t.v-t.pd)*(d[B]+1)-d[A]*t.d+t.pdxd;
}
ll ask2(int A,int B){
    if(d[A]>d[B])swap(A,B);
    int F=lca(A,B);
    node FA=T.ask(RT[f[F]],RT[A],d[F]-1,0,n),
        FB=T.ask(RT[f[F]],RT[B],d[F]-1,0,n);
    ll ans=calc(f[F],B,FB) // x∈[1,lca],y∈[1,B]
        +calc(f[F],A,FA);  // x∈[1,A],y∈[1,lca]
    ans-=2*(d[F]*sum[f[F]][0]-sum[f[F]][1])-(d[F]-1);// - x,y∈[1,lca)
    ans+=(d[A]-d[F]+1)*((d[B]+1)*FB.v-FB.d);// i∈[lca,B]
    list<int>sta;
    for(int i=A;i!=F;i=f[i])sta.push_back(i);
    ++ti;
    while(!sta.empty()){// i∈(lca,A]
        int i=sta.back();sta.pop_back();
        if(v[a[i]]!=ti){
            v[a[i]]=ti;
            int mi=d[B]+1;
            for(int j:vec[a[i]])
                if(chk(F,B,j)&&d[j]<mi)mi=d[j];
            ans+=ll(d[A]-d[i]+1)*(mi-d[F]);
        }
    }
    return ans;
}
unsigned int SA,SB,SC;
unsigned int rng61(){SA^=SA<<16;SA^=SA>>5;SA^=SA<<1;unsigned int t=SA;SA=SB;SB=SC;SC^=t^SA;return SC;}
void solve(){
    int q,p,x,y;
    scanf("%d%d%u%u%u%d",&n,&p,&SA,&SB,&SC,&q);
    for(int i=2;i<=n;++i)
        e[f[i]=i>p?rng61()%(i-1)+1:i-1].push_back(i);
    for(int i=1;i<=n;++i)vec[a[i]=rng61()%n+1].push_back(i);
    T.build(RT[0],0,n);
    d[1]=1,dfs(1);ST();
    while(q--)
        scanf("%d%d%d",&p,&x,&y),
        printf("%lld\n",p==1?ask1(x,y):ask2(x,y));
    dfn=T.sz=0;
    for(int i=1;i<=n;++i)
        vec[i].clear(),e[i].clear(),
        RT[i]=v[i]=b[i]=0;
}
int main(){
    int T;scanf("%d",&T);
    while(T--)solve();
}
```

---

## 作者：Leasier (赞：1)

~~话说 SDOI 是不是有很多阴间题啊。~~

观察一下数据随机生成的方式，可知这棵树满足：

- 有一条长为 $p$ 的链。
- 把链上点缩到一起后是一棵随机树。
### Subtask 1：只有操作 1
注意到缩点后随机树的性质，可知 $\min(dis_{x, LCA(x, y)}, dis_{y, LCA(x, y)})$ 距离是 $O(\log n)$ 的，不妨设 $x$ 离 $LCA(x, y)$ 更近，则我们考虑首先用主席树求出 $LCA(x, y) \to y$ 的答案，再枚举 $x \to LCA(x, y)$ 上的点看它是否被统计过即可。时间复杂度为 $O(T(n \log n + m \log^2 n))$。
### Subtask 2：树为一条链
现在我们只需要解决链上的操作 2。

不妨设 $A \leq B$，考虑枚举每个在某些区间中第一次出现的数统计贡献。

设 $pre_i$ 表示 $a_i$ 上一次出现的位置，则 $i$ 的答案为 $\max(A - pre_i, 0) \times (B - i + 1) + (B - pre_i) \times \max(A - i + 1, 0)$。

下面把 $\max$ 拆开：

- $1 \leq i \leq A$：$(A - pre_i)(B - i + 1) + (B - pre_i)(A - i + 1) = (i - pre_i)(A + B - 2i + 2) - 1$。
- $A < i \leq B$：$[pre_i < A] (A - pre_i)(B - i + 1)$。

对于前者，前缀和即可；对于后者，主席树即可。时间复杂度为 $O(T(n + m) \log n)$。
### Subtask 3：无特殊限制
设 $u = LCA(A, B)$。

不难发现我们可以将 Subtask 2 的做法套用到所有直链上 $A$ 为 $B$ 祖先的情况，设该答案为 $f(A, B)$。

我们尝试通过 $f$ 表示出一般情况中直链部分的答案，可得其为 $f(fa_u, A) + f(fa_u, B) - f(fa_u, fa_u)$。我们还需要解决起点位于 $u \to A$，终点位于 $u \to B$ 部分的答案。

仿照操作 1 的做法，我们将长短链切分成两种不同的处理方式。不妨设 $A$ 离 $u$ 更近。

对于长链 $u \to B$，我们将所有 $depth_{pre_i} < depth_u$ 的 $i$ 视为首次出现，由此不难用主席树维护。

对于短链 $u \to A$，我们从上到下找出短链上首次出现的 $i$，找出长链上最浅的 $j$ 满足 $a_i = a_j$（若不存在则钦定 $depth_j = depth_B + 1$），则终点在 $fa_j \to u$ 中的点都可以取到 $i$。

需要注意的是，由于 $a_i$ 随机生成，我们可以直接在一个关于 $a_i$ 的 vector 中枚举找出 $j$。

综上，时间复杂度为 $O(T(n \log n + m \log^2 n))$。

代码：
```cpp
#include <iostream>
#include <vector>
#include <cstdio>

using namespace std;

typedef unsigned int uint;
typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct {
	int ls;
	int rs;
	int cnt;
} Node1;

typedef struct {
	int id;
	Node1 tree[2200007];
	
	int build(int l, int r){
		int ans = ++id;
		tree[ans].cnt = 0;
		if (l == r){
			tree[ans].ls = tree[ans].rs = 0;
			return ans;
		}
		int mid = (l + r) >> 1;
		tree[ans].ls = build(l, mid);
		tree[ans].rs = build(mid + 1, r);
		return ans;
	}
	
	inline void update(int x){
		tree[x].cnt = tree[tree[x].ls].cnt + tree[tree[x].rs].cnt;
	}
	
	int inc(int x, int l, int r, int pos){
		int ans = ++id;
		tree[ans] = tree[x];
		if (l == r){
			tree[ans].cnt++;
			return ans;
		}
		int mid = (l + r) >> 1;
		if (pos <= mid){
			tree[ans].ls = inc(tree[x].ls, l, mid, pos);
		} else {
			tree[ans].rs = inc(tree[x].rs, mid + 1, r, pos);
		}
		update(ans);
		return ans;
	}
	
	int get_cnt(int x, int y, int l, int r, int L, int R){
		if (L <= l && r <= R) return tree[y].cnt - tree[x].cnt;
		int mid = (l + r) >> 1, ans = 0;
		if (L <= mid) ans = get_cnt(tree[x].ls, tree[y].ls, l, mid, L, R);
		if (R > mid) ans += get_cnt(tree[x].rs, tree[y].rs, mid + 1, r, L, R);
		return ans;
	}
	
	bool exist(int x, int y, int l, int r, int pos){
		if (l == r) return tree[y].cnt - tree[x].cnt > 0;
		int mid = (l + r) >> 1;
		if (pos <= mid) return exist(tree[x].ls, tree[y].ls, l, mid, pos);
		return exist(tree[x].rs, tree[y].rs, mid + 1, r, pos);
	}
} PresidentTree1;

typedef struct {
	int ls;
	int rs;
	int sum00;
	ll sum01;
	ll sum10;
	ll sum11;
} Node2;

typedef struct {
	int id;
	Node2 tree[2200007];
	
	int build(int l, int r){
		int ans = ++id;
		tree[ans].sum00 = tree[ans].sum01 = tree[ans].sum10 = tree[ans].sum11 = 0;
		if (l == r){
			tree[ans].ls = tree[ans].rs = 0;
			return ans;
		}
		int mid = (l + r) >> 1;
		tree[ans].ls = build(l, mid);
		tree[ans].rs = build(mid + 1, r);
		return ans;
	}
	
	inline void update(int x){
		int ls = tree[x].ls, rs = tree[x].rs;
		tree[x].sum00 = tree[ls].sum00 + tree[rs].sum00;
		tree[x].sum01 = tree[ls].sum01 + tree[rs].sum01;
		tree[x].sum10 = tree[ls].sum10 + tree[rs].sum10;
		tree[x].sum11 = tree[ls].sum11 + tree[rs].sum11;
	}
	
	int add(int x, int l, int r, int pos, int p, int q){
		int ans = ++id;
		tree[ans] = tree[x];
		if (l == r){
			tree[ans].sum00++;
			tree[ans].sum01 += p;
			tree[ans].sum10 += q;
			tree[ans].sum11 += (ll)p * q;
			return ans;
		}
		int mid = (l + r) >> 1;
		if (pos <= mid){
			tree[ans].ls = add(tree[x].ls, l, mid, pos, p, q);
		} else {
			tree[ans].rs = add(tree[x].rs, mid + 1, r, pos, p, q);
		}
		update(ans);
		return ans;
	}
	
	ll calc1(int x, int y, int l, int r, int L, int R, int p, int q){
		if (L <= l && r <= R) return (ll)p * q * (tree[y].sum00 - tree[x].sum00) - p * (tree[y].sum01 - tree[x].sum01) - q * (tree[y].sum10 - tree[x].sum10) + (tree[y].sum11 - tree[x].sum11);
		int mid = (l + r) >> 1;
		ll ans = 0;
		if (L <= mid) ans = calc1(tree[x].ls, tree[y].ls, l, mid, L, R, p, q);
		if (R > mid) ans += calc1(tree[x].rs, tree[y].rs, mid + 1, r, L, R, p, q);
		return ans;
	}
	
	ll calc2(int x, int y, int l, int r, int L, int R, int p){
		if (L <= l && r <= R) return (ll)p * (tree[y].sum00 - tree[x].sum00) - (tree[y].sum01 - tree[x].sum01);
		int mid = (l + r) >> 1;
		ll ans = 0;
		if (L <= mid) ans = calc2(tree[x].ls, tree[y].ls, l, mid, L, R, p);
		if (R > mid) ans += calc2(tree[x].rs, tree[y].rs, mid + 1, r, L, R, p);
		return ans;
	}
} PresidentTree2;

int cnt, tm = 0;
PresidentTree1 pt1, pt2;
PresidentTree2 pt3;
int head[100007], fa[100007], a[100007], pre[100007], in[100007], depth[100007], root1[100007], root2[100007], root3[100007], out[100007], vis[100007], path[100007];
ll sum1[100007], sum2[100007];
Edge edge[100007];
vector<int> v[100007];

inline void init(int n){
	cnt = pt1.id = pt2.id = pt3.id = 0;
	for (register int i = 1; i <= n; i++){
		head[i] = 0;
		v[i].clear();
	}
}

inline int read(){
	int sign = 1, ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') sign = -sign;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return sign * ans;
}

inline uint rng61(uint &sa, uint &sb, uint &sc){
	uint t;
	sa ^= sa << 16;
	sa ^= sa >> 5;
	sa ^= sa << 1;
	t = sa;
	sa = sb;
	sb = sc;
	sc ^= t ^ sa;
	return sc;
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs(int u, int n, int &id){
	int t = pre[a[u]];
	in[u] = ++id;
	depth[u] = depth[fa[u]] + 1;
	sum1[u] = sum1[fa[u]] + (depth[u] - t);
	sum2[u] = sum2[fa[u]] + (ll)depth[u] * (depth[u] - t);
	root1[u] = pt1.inc(root1[fa[u]], 0, n, t);
	root2[u] = pt2.inc(root2[fa[u]], 1, n, a[u]);
	root3[u] = pt3.add(root3[fa[u]], 0, n, t, depth[u], t);
	pre[a[u]] = depth[u];
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		dfs(edge[i].end, n, id);
	}
	pre[a[u]] = t;
	out[u] = id;
}

inline int jump(int u, int p){
	while (u > p) u = fa[u];
	return u;
}

inline int lca(int u, int v, int p){
	int x = jump(u, p), y = jump(v, p);
	if (x != y) return min(x, y);
	while (u != v){
		if (depth[u] > depth[v]){
			u = fa[u];
		} else {
			v = fa[v];
		}
	}
	return u;
}

inline int query1(int u, int v, int n, int p){
	int cur_lca = lca(u, v, p), ans;
	tm++;
	if (depth[u] < depth[v]) swap(u, v);
	ans = pt1.get_cnt(root1[fa[cur_lca]], root1[u], 0, n, 0, depth[cur_lca] - 1);
	for (register int i = v; i != cur_lca; i = fa[i]){
		if (vis[a[i]] != tm && !pt2.exist(root2[fa[cur_lca]], root2[u], 1, n, a[i])){
			vis[a[i]] = tm;
			ans++;
		}
	}
	return ans;
}

inline ll query2(int u, int v, int n){
	if (u == 0 || v == 0) return 0;
	return (sum1[u] * (depth[u] + depth[v] + 2) - sum2[u] * 2 - depth[u]) + pt3.calc1(root3[u], root3[v], 0, n, 0, depth[u] - 1, depth[u], depth[v] + 1);
}

inline bool check(int u, int v){
	return in[u] <= in[v] && in[v] <= out[u];
}

inline ll query3(int x, int u, int v, int n){
	int cnt = 0;
	ll ans;
	tm++;
	if (depth[u] > depth[v]) swap(u, v);
	ans = pt3.calc2(root3[fa[x]], root3[v], 0, n, 0, depth[x] - 1, depth[v] + 1) * (depth[u] - depth[x] + 1);
	for (register int i = u; i != x; i = fa[i]){
		path[++cnt] = i;
	}
	for (register int i = cnt; i >= 1; i--){
		if (vis[a[path[i]]] != tm){
			int size = ::v[a[path[i]]].size(), val = depth[v] + 1;
			vis[a[path[i]]] = tm;
			for (register int j = 0; j < size; j++){
				int p = ::v[a[path[i]]][j];
				if (check(x, p) && check(p, v)) val = min(val, depth[p]);
			}
			ans += (ll)(depth[u] - depth[path[i]] + 1) * (val - depth[x]);
		}
	}
	return ans;
}

int main(){
	int t = read();
	for (register int i = 1; i <= t; i++){
		int n = read(), p = read(), m, id = 0;
		uint sa = read(), sb = read(), sc = read();
		m = read();
		init(n);
		for (register int j = 2; j <= p; j++){
			fa[j] = j - 1;
		}
		for (register int j = p + 1; j <= n; j++){
			fa[j] = rng61(sa, sb, sc) % (j - 1) + 1;
		}
		for (register int j = 2; j <= n; j++){
			add_edge(fa[j], j);
		}
		for (register int j = 1; j <= n; j++){
			a[j] = rng61(sa, sb, sc) % n + 1;
			v[a[j]].push_back(j);
		}
		root1[0] = pt1.build(0, n);
		root2[0] = pt2.build(1, n);
		root3[0] = pt3.build(0, n);
		dfs(1, n, id);
		for (register int j = 1; j <= m; j++){
			int op = read();
			if (op == 1){
				int x = read(), y = read();
				printf("%d\n", query1(x, y, n, p));
			} else {
				int a = read(), b = read(), cur_lca = lca(a, b, p);
				printf("%lld\n", query2(fa[cur_lca], a, n) + query2(fa[cur_lca], b, n) - query2(fa[cur_lca], fa[cur_lca], n) + query3(cur_lca, a, b, n));
			}
		}
	}
	return 0;
}
```

---

## 作者：PosVII (赞：0)

**前言**

------------

思路完全不同的 $\log n$ 做法，位列最优解 rk2。

只用到了离线树状数组。

哈哈，我的树套树 $\log^2 n$ 做法是 $\log^3 n$ 做法的十倍，所以愤而写了这个单 $\log$ 做法。

8.5k(树套树)+9.5k(树状数组)=18k！！！

**思路**

------------

其它题解通过每个点颜色贡献入手，我是直接从每个询问入手。

将整棵树视为一个由一条主链串联起来的森林，那么每次询问的两个点离它们分别所在树的根距离期望为 $\log$ 级别。

我们设定同种颜色点的贡献优先级为：主链>森林的点。

暂时不考虑 $top_{x}=top_{y}$ 的情况：

考虑询问 $1$，我们找到 $top_{x}$ 为 $x$ 点的根， $top_{y}$ 为 $y$ 点的根，默认 $top_{x}< top_{y}$。

我们发现答案就是主链上 $[top_{x},top_{y}]$ 的答案再加上在 $x,y$ 分别到根的路径上没有被找到过且不存在主链上的点的数量即可，这个可以 ```vector``` 里二分做到  $O(\log^2 n)$ 或者离线下来做到 $O(\log n)$。 

然后考虑询问 $2$，我们发现答案分为四种：$x$ 在主链上与否和 $y$ 在主链上与否：

1. 都在主链上，发现是一个类似在矩阵上的区间查询 $r=[L_1,R_1],l=[L_2,R_2]$ 时的答案之和。
1. 都不在主链上，可以暴力。
1. 一个在主链上，可以利用类似询问一的方法做到 $O(\log^2 n)$，可以利用前缀和优化。

发现唯一难点就是矩阵上的区间查询，这个可以树套树做到 $O(\log^2 n)$，也可以离线树状数组做到 $O(\log n)$。

考虑 $top_{x}=top_{y}$ 的情况：

询问一可以暴力，询问二也可以暴力然后把剩下的情况转化为 $top_{x} \neq top_{y}$ 的方法。

**code**

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
unsigned SA,SB,SC;
unsigned Rand() {SA^=SA<<16;SA^=SA>>5;SA^=SA<<1;unsigned t=SA;SA=SB,SB=SC;SC^=t^SA;return SC;}
template<typename G> inline void read(G &x) {x=0;G f=1;char ch=getchar();while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();if(ch=='-') f=-1,ch=getchar();while(ch>='0'&&ch<='9') {x=x*10+(ch^48);ch=getchar();}x*=f;}
const int MAXN=2e5+5;
struct Fenwick_Tree {
	int n,d1[MAXN],d2[MAXN];
	void init(int x) {n=x;for(int i=1;i<=n;++i) d1[i]=d2[i]=0;}
	void modify(int x,int y) {for(int i=x;i<=n;i+=(i&-i)) d1[i]+=y,d2[i]+=(x-1)*y;} 
	void modify(int l,int r,int y) {modify(l,y),modify(r+1,-y);}
	int query(int x) {int res=0;for(int i=x;i;i-=(i&-i)) res+=d1[i]*x-d2[i];return res;}
	int query(int l,int r) {return query(r)-query(l-1);}
}BIT1,BIT2;
int cnt,ans[MAXN];
struct node {int idx,l,r,num;};
vector<node> M[MAXN];
vector<pair<int,int> > L[MAXN],R[MAXN];
int qry[MAXN*50],idx[MAXN],tot; 
int vis[MAXN],pl[MAXN],pr[MAXN];bool imp[MAXN];
int T,n,m,q,a[MAXN],dep[MAXN],fa[MAXN],top[MAXN];
vector<int> G[MAXN],ix,iy,iz;
void dfs(int u,int tp) {
	top[u]=tp;
	for(auto v:G[u]) dep[v]=dep[u]+1,dfs(v,tp);
}
int s[MAXN],las[MAXN],tp;
int op[MAXN],xx[MAXN],yy[MAXN];
void clear() {
	tot=cnt=0;
	for(int i=1;i<=n;++i) G[i].clear(),M[i].clear(),L[i].clear(),R[i].clear(),dep[i]=las[i]=0;
	BIT1.init(m),BIT2.init(m);
}
signed main() {
//	freopen(".in","r",stdin);
//	freopen("1.out","w",stdout);
	read(T);
	while(T--) {
	 	read(n),read(m),read(SA),read(SB),read(SC);
		clear();
	 	for(int i=m+1;i<=n;++i) {
			fa[i]=Rand()%(i-1)+1;
			G[fa[i]].emplace_back(i);
		}
		for(int i=1;i<=n;++i) {
			a[i]=Rand()%n+1;
			if(las[a[i]]) {
				M[las[a[i]]].emplace_back(node{0,las[a[i]],i-1});
				BIT2.modify(las[a[i]],i-1,1); 
			}las[a[i]]=i;
		}
		for(int i=1;i<=n;++i) {
			if(las[i]) {
				M[las[i]].emplace_back(node{0,las[i],m,0});
				BIT2.modify(las[i],m,1);
			}
		}
		for(int i=1;i<=m;++i) dfs(i,i);
		read(q);
		for(int ind=1;ind<=q;++ind) {
			read(op[ind]),read(xx[ind]),read(yy[ind]);
			int x=xx[ind],y=yy[ind];
			if(top[x]>top[y]) swap(x,y);
			if(op[ind]&1) {
				if(top[x]==top[y]) {
					while(x!=y) {
						if(dep[x]<dep[y]) swap(x,y);
						if(!vis[a[x]]) {
							++ans[ind];
							vis[a[x]]=1,s[++tp]=a[x];
						}
						x=fa[x];
					}
					ans[ind]+=(!vis[a[x]]);
					while(tp) vis[s[tp--]]=0;
				}
				else {
					M[top[x]].emplace_back(node{ind,top[y],top[y],1});
					M[top[x]-1].emplace_back(node{ind,top[y],top[y],-1}); 
					while(x!=top[x]) L[top[x]].emplace_back(make_pair(++tot,a[x])),x=fa[x];
					while(y!=top[y]) L[top[x]].emplace_back(make_pair(++tot,a[y])),y=fa[y];
				}
			}
			else {
				if(top[x]==top[y]) {
					ix.clear(),iy.clear(),iz.clear();
					while(x!=y) {
						if(dep[x]>dep[y]) {
							ix.emplace_back(x);
							x=fa[x];
						}
						else {
							iy.emplace_back(y);
							y=fa[y];
						}
					}
					while(x!=top[x]) {
						iz.emplace_back(x);
						x=fa[x];
					}
					reverse(ix.begin(),ix.end());
					reverse(iy.begin(),iy.end());
					reverse(iz.begin(),iz.end());
					int six=ix.size(),siy=iy.size(),siz=iz.size();
					for(auto i:iz) R[top[x]].emplace_back(make_pair(++tot,a[i]));
					for(auto i:ix) R[top[x]].emplace_back(make_pair(++tot,a[i]));
					for(auto i:iy) R[top[x]].emplace_back(make_pair(++tot,a[i]));
					M[top[x]].emplace_back(node{ind,1,top[x],2});
					M[top[x]].emplace_back(node{ind,top[x],top[x],siz*2+six+siy});
					ans[ind]-=top[x];
				}
				else {
					ix.clear(),iy.clear();
					while(x!=top[x]) ix.emplace_back(x),x=fa[x];
					while(y!=top[y]) iy.emplace_back(y),y=fa[y];
					reverse(ix.begin(),ix.end());
					reverse(iy.begin(),iy.end());
					for(auto i:ix) {
						L[top[x]].emplace_back(make_pair(++tot,a[i]));
						R[top[x]].emplace_back(make_pair(++tot,a[i]));
					}
					for(auto i:iy) R[top[y]].emplace_back(make_pair(++tot,a[i]));
					int six=ix.size(),siy=iy.size();
					M[top[x]].emplace_back(node{ind,1,top[x],2});
					M[top[x]].emplace_back(node{ind,top[x]+1,top[y],1+six});
					M[top[x]-1].emplace_back(node{ind,top[x]+1,top[y],-six}); 
					M[top[x]].emplace_back(node{ind,top[y],top[y],six*siy+siy});
					M[top[x]-1].emplace_back(node{ind,top[y],top[y],-six*siy});
					M[top[x]].emplace_back(node{ind,top[x],top[x],six});
					ans[ind]-=top[x];
				}
			}
		}
		for(int i=1;i<=m;++i) {
			for(auto tmp:M[i]) {
				if(tmp.idx>0) ans[tmp.idx]+=(BIT1.query(tmp.l,tmp.r)+BIT2.query(tmp.l,tmp.r)*i)*tmp.num;
				else {
					BIT1.modify(tmp.l,tmp.r,i);
					BIT2.modify(tmp.l,tmp.r,-1);
				}
			}
		}
		for(int i=1;i<=n;++i) idx[i]=0;
		for(int i=1;i<=m;++i) {
			idx[a[i]]=i;
			for(auto pii:R[i]) qry[pii.first]=idx[pii.second];
		}
		for(int i=1;i<=n;++i) idx[i]=m+1;
		for(int i=m;i>=1;--i) {
			idx[a[i]]=i;
			for(auto pii:L[i]) qry[pii.first]=idx[pii.second];
		}
		tot=0;
		for(int ind=1;ind<=q;++ind) {
			int x=xx[ind],y=yy[ind];
			if(top[x]>top[y]) swap(x,y);
			if(op[ind]&1) {
				if(top[x]!=top[y]) {
					while(x!=top[x]) {
						int k=qry[++tot];
						if(!vis[a[x]]&&k>top[y]) {
							++ans[ind];
							vis[a[x]]=1,s[++tp]=a[x];
						}
						x=fa[x];
					}
					while(y!=top[y]) {
						int k=qry[++tot];
						if(!vis[a[y]]&&k>top[y]) {
							++ans[ind];
							vis[a[y]]=1,s[++tp]=a[y];
						}
						y=fa[y];
					}
					while(tp) vis[s[tp--]]=0;
				}
			}
			else {
				if(top[x]==top[y]) {
					ix.clear(),iy.clear(),iz.clear();
					while(x!=y) {
						if(dep[x]>dep[y]) {
							ix.emplace_back(x);
							x=fa[x];
						}
						else {
							iy.emplace_back(y);
							y=fa[y];
						}
					}
					while(x!=top[x]) {
						iz.emplace_back(x);
						x=fa[x];
					}
					reverse(ix.begin(),ix.end());
					reverse(iy.begin(),iy.end());
					reverse(iz.begin(),iz.end());
					int six=ix.size(),siy=iy.size(),siz=iz.size();
					for(int i=0;i<siz;++i) {
						int j=iz[i],k=qry[++tot];
						las[a[j]]=-1,pl[a[j]]=six,pr[a[j]]=siy;
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=(six+siy+siz*2-i*2)*(top[x]-k);
						}
					}
					int rec=tp;
					for(int i=0;i<six;++i) {
						int j=ix[i],k=qry[++tot];
						pr[a[j]]=siy;
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=(six-i)*(top[x]-k);
						}
					}
					while(tp>rec) vis[s[tp--]]=0;
					for(int i=0;i<siy;++i) {
						int j=iy[i],k=qry[++tot];
						pl[a[j]]=six;
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=(siy-i)*(top[x]-k);
						}
					}
					while(tp) vis[s[tp--]]=0;
					int sum=0;
					for(int i=0;i<siz;++i) {
						int j=iz[i];
						sum+=(las[a[j]]+1)*(i-las[a[j]]);
						las[a[j]]=i;
					}
					for(int i=0;i<siz;++i) {
						int j=iz[i];
						if(las[a[j]]==i) sum+=(i+1)*(siz-i);
					}
					ans[ind]+=sum*2-siz;
					for(int i=six-1;i>=0;--i) {
						int j=ix[i];
						pl[a[j]]=i;
					}
					for(int i=siy-1;i>=0;--i) {
						int j=iy[i];
						pr[a[j]]=i;
					}
					for(int i=six-1;i>=0;--i) {
						int j=ix[i];
						if(a[j]!=a[y]&&!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=six*siy-pl[a[j]]*pr[a[j]];
						}
					}
					for(int i=siy-1;i>=0;--i) {
						int j=iy[i];
						if(a[j]!=a[y]&&!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=six*siy-pl[a[j]]*pr[a[j]];
						}
					}
					ans[ind]+=six*siy;
					while(tp) vis[s[tp--]]=0;
					for(int i=siz-1;i>=0;--i) {
						int j=iz[i];
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=siz*six-pl[a[j]]*(siz-i-1);
							ans[ind]+=siz*siy-pr[a[j]]*(siz-i-1); 
						}
					}
					rec=tp;
					for(int i=0;i<six;++i) {
						int j=ix[i];
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=siz*six-pl[a[j]]*siz;
						}
					}
					while(tp>rec) vis[s[tp--]]=0;
					for(int i=0;i<siy;++i) {
						int j=iy[i];
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=siz*siy-pr[a[j]]*siz;
						}
					}
					while(tp) vis[s[tp--]]=0;
				}
				else {
					ix.clear(),iy.clear();
					while(x!=top[x]) ix.emplace_back(x),x=fa[x];
					while(y!=top[y]) iy.emplace_back(y),y=fa[y];
					reverse(ix.begin(),ix.end());
					reverse(iy.begin(),iy.end());
					int six=ix.size(),siy=iy.size();
					for(int i=0;i<six;++i) {
						int j=ix[i],rr=qry[++tot],ll=qry[++tot];
						if(rr>top[y]) imp[a[j]]=1;
						else imp[a[j]]=0;
						pr[a[j]]=siy;
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							if(ll!=rr) ans[ind]+=(six-i)*(min(rr-1,top[y])-ll);
						}
					}
					while(tp) vis[s[tp--]]=0;
					for(int i=0;i<siy;++i) {
						int j=iy[i],ll=qry[++tot];
						if(ll<top[x]) imp[a[j]]=1;
						else imp[a[j]]=0;
						pl[a[j]]=six;
						if(!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=(siy-i)*(top[x]-min(ll,top[x]));
						}
					}
					while(tp) vis[s[tp--]]=0;
					for(int i=six-1;i>=0;--i) {
						int j=ix[i];
						pl[a[j]]=i;
					}
					for(int i=siy-1;i>=0;--i) {
						int j=iy[i];
						pr[a[j]]=i;
					}
					for(int i=six-1;i>=0;--i) {
						int j=ix[i];
						if(imp[a[j]]&&!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=six*siy-pl[a[j]]*pr[a[j]];
						}
					}
					for(int i=siy-1;i>=0;--i) {
						int j=iy[i];
						if(imp[a[j]]&&!vis[a[j]]) {
							vis[a[j]]=1,s[++tp]=a[j];
							ans[ind]+=six*siy-pl[a[j]]*pr[a[j]];
						}
					}
					while(tp) vis[s[tp--]]=0;
				}
			}
		}
		for(int i=1;i<=q;++i) printf("%lld\n",ans[i]),ans[i]=0;
	}
	return 0;
}
```

---


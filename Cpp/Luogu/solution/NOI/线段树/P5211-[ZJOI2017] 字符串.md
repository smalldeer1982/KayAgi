# [ZJOI2017] 字符串

## 题目背景

猪小侠最近学习了字符串相关理论，现在他遇到了这样一个题：

## 题目描述

维护一个动态字符串 $s_{1..n}$，字符串的字符集是所有 $|x| \leq 10 ^ 9$ 的整数。要求支持两个操作：

1. 输入 $l, r, d$，对于所有 $l \leq i \leq r$，将 $s_i$ 修改为 $s_i + d$，注意 $d$ 可能是负数。

2. 输入 $l, r$，输出子串 $s_{l..r}$ 的字典序最小的后缀的起点位置。即，如果最小后缀是 $s_{p..r}$（$l\leq p\leq r$），请输出 $p$。

## 说明/提示

| 测试点编号 | $n$ | $m$ | 其他约定 |
| ------ | ------ | ------ | ------ |
| $1$ | $\leq 300$ | $\leq 300$ | 无 |
| $2$ | $\leq 2 \times 10^4$ | $\leq 2 \times 10^4$ | 无 |
| $3$ | $\leq 2 \times 10^4$ | $\leq 2 \times 10^5$ | 无 |
| $4$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |只有第二类操作 |
| $5$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |只有第二类操作 |
| $6$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |数据随机生成 |
| $7$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |数据随机生成 |
| $8$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |无 |
| $9$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |无 |
| $10$ | $\leq 2 \times 10^5$ | $\leq 3 \times 10^4$ |无 |

对于 $100\%$ 的数据，$1\leq l\leq r\leq n$，$|d|\leq 10 ^ 3$，$|s_i|\leq 10 ^ 8$。

注意，$6$ 和 $7$ 两个测试数据在随机生成时，$s_i$ 在 $\{0, 1\}$ 中随机，$d$ 在 $\{-1, 1\}$ 中随机。操作种类和操作区间都是等概率随机的。

## 样例 #1

### 输入

```
5 5
3 2 1 4 3
2 1 5
1 2 4 2
2 1 5
1 2 5 1
2 1 5
```

### 输出

```
3
5
1```

# 题解

## 作者：zghtyarecrenj (赞：15)

**Upd 2020/06/15：优化了 `\overline` 太丑的问题，添上代码。**

# ZJOI2017 字符串

前置芝士：Lyndon 分解，Significant Suffixes，线段树，字符串哈希，分块。

如果你会 Significant Suffixes 相关知识，请阅读 **[0 Marks & Facts]** 后直接跳到后面的 **进入正题**。

## 0 Marks & Facts

1. 我们定义两个字符串 $a$ 和 $b$，如果 $a$ 的字典序 $<b$，则我们称 $a < b$。
2. 如果 $a$ 是 $b$ 的前缀且 $a \ne b$，则我们称 $a \sqsubset b$。
3. 如果 $a$ 是 $b$ 的前缀，则我们称 $a \sqsubseteq b$。
4. 如果 $a < b$ 且 $a$ 不是 $b$ 的前缀，则我们称 $a \triangleleft b$。即 $a \triangleleft b \Longleftrightarrow (a < b) \wedge (a \not\sqsubseteq b)$。
5. ${abc}$ 表示拼接 $a, b, c$ 三个字符串。
6. $a^n$ 表示 $n$ 个 $a$ 拼接在一起。e.g. ${a^2b} = {aab}$
7. $\epsilon$ 表示空串。
8. 我们定义字符集为 $\Sigma$，组成的字符串为 $\Sigma^*$，$\Sigma^+ = \Sigma^* \setminus \{\epsilon\}$
9. $\operatorname{pref}(a)$ 表示所有 $a$ 的前缀的集合，$\operatorname{suf}(a)$ 表示所有 $a$ 的后缀的集合（包含 $a$ 和 $\epsilon$）
10. $\operatorname{pref}^+(a) = \operatorname{pref}(a) \setminus \{a,\epsilon\},\ \operatorname{suf}^+(a) = \operatorname{suf}^+(a) \setminus \{a, \epsilon\}$

一些非常显然的 Fact:

1. 如果 $a \triangleleft b$，则 ${au} < {bv}$。

## 1 Lyndon Words

### 1.1 Definition

**Lyndon Word**：一个串是一个 **Lyndon Word** 当且仅当 $\forall a$ 的后缀 $b$，有 $a < b$。

$\mathcal L$ 表示 Lyndon Word 的集合。

### 1.2 Chan-Fox-Lyndon Factorization

又称 Lyndon Decomposition。

我们定义 $\operatorname{CFL}(s)$ 是一个对于 $s$ 串的划分，即划分成了 ${w_1w_2\cdots w_k} = s$，使得所有 $w_i$ 是 Lyndon Word，并且 $w_1 \ge w_2 \ge \cdots \ge w_n$。

#### Theory 1.2.1 Lyndon Concatanation

这是一个很显然的结论。

> 如果 $a, b \in \mathcal L$，且 $a < b$，则 $\overline {ab} \in \mathcal L$。

由于 $a < b$，我们有 ${ab} < b$。接下来我们分两种情况讨论。

i) $a \not \sqsubseteq b$：根据 $a < b$，我们有 $a \triangleleft b$。所以 ${ab} \triangleleft b \implies {ab} < b$。

ii) $a \sqsubseteq b$：令 $b={ac}$，则 ${ab} = {a^2c}$。因为 $b \in \mathcal L$，所以 ${ab} < b \implies {a^2c} < {ac} \implies {ac} < c$，所以 $b < c$。

所以，$\forall d \in \operatorname{suf}^+(b), \ {ab} < b < d \implies \forall c \in \operatorname{suf}^+(a),\ a \triangleleft e \implies {ab} \triangleleft {eb}$。$\blacksquare$

#### Theory 1.2.2 Existence of CFL

这个结论和 **[Theory 1.2.3] Uniqueness of CFL** 是两个很有趣的结论。

> 对于任意的串 $s$，$\operatorname{CFL}(s)$ 一定存在。

我们考虑，单个的字母一定是 Lyndon Word。

根据 **[Theory 1.2.1 Lyndon Concatanation]**，我们可以把字典序小的两个 Lyndon Word 并起来，所以我们把所有的字典序单增的序列都并起来，剩下的就是一个合法的 CFL。$\blacksquare$

#### Theory 1.2.3 Uniqueness of CFL

> 对于任意的串 $s$，$\operatorname{CFL}(s)$ 一定唯一。

反证法，假设有两种方案。我们取第一个不同的位置，可以很容易地得到矛盾，因为这个和 CFL 的定义矛盾了。$\blacksquare$

Q: 为什么不写详细点呢…… A；~~因为我懒！！！~~

然后我们就得到了 **CFL 存在且唯一**。由此有两个推论：

#### Theory 1.2.4 Lyndon Suffixes and Lyndon Prefixes

好玩且显然的 Fact。

> $w_1$ 是最长的 Lyndon 前缀且 $w_k$ 是最长的 Lyndon 后缀。

反证法，因为如果 $w_1$ 不是最长，那么还能再拼，产生了两个合法的 CFL，和 **[Theory 1.2.3 Uniqueness of CFL]** 矛盾。所以 $w_1$ 是最长的 Lyndon 前缀。

$w_k$ 同理。$\blacksquare$

#### Theory 1.2.5 Theory of Minsuf

其实这是一道题，要求 $O(n)$ 的时间复杂度完成。

> 一个字符串 $s$ 的最小后缀是 $w_k$。

反证法，假设最小后缀是 ${xw_{i+1}w_{i+2}\cdots w_{k}}$ 而不是 $w_k$ 且 $|x| < |w_i|$。

我们有 ${x w_{i + 1} \dots w_k} \geq x > w_i \ge w_k$，矛盾。$\blacksquare$

### 1.3 Duval's Algorithm

时间复杂度 $O(n)$，空间复杂度 $O(1)$ 的算法，不会可以去看你谷的【模板】Lyndon 分解。

## 2 Significant Suffixes

### 2.1 Definition

我们令 $\operatorname{minsuf}(u)$ 为 $u$ 的最小后缀，且 $\operatorname{minsuf}(u, v) = \min _{w \in \operatorname{suf}(u)} wv$。

**Significant Suffixes**：$\Lambda(u) = \arg\min_{w\in \operatorname{suf}(u)} wv$。 

$\operatorname{minsuf}(s)$ 表示 S 字典序最小的后缀，且

由 $\operatorname{minsuf}$ 的性质可知，$\operatorname{minsuf}(u, \epsilon) = \operatorname{minsuf}(u)$。$\implies \operatorname{minsuf}(u) \in \Lambda(u)$。

所以，显然 $\forall u \in \Lambda(u),\ \operatorname{minsuf}(u) \sqsubseteq u$。

我们注意到一个 CFL 分解中的 Lyndon Words 是存在一定的循环的。因此，我们可以记一个 CFL 为次方的形式。
$$
\operatorname{CFL}(u) = \overline {{w_1}^{k_1}{w_2}^{k_2}\cdots {w_n}^{k_n}}
$$
我们记 $s_i$ 为一个后缀，即 $s_i = \overline {{w_i}^{k_i}{w_{i+1}}^{k_{i+1}}\cdots{w_n}^{k_n}}$。边界：$s_{n+1} = \epsilon$。

### 2.2 Significant Theory

首先，我们需要一个引理。

#### Theory 2.2.1 Infinite Theory

一个十分显然的结论，和显然今天下大雨一样显然。

在 **[Theory 2.2.2 Significant Suffixes Theory]** 里面会用到，建议先食用下一个 Theory。

> 如果 $u^\infty < v$，则 $v > {uv} > {u^2v} > \cdots$。

$u^\infty < v \implies u^\infty < {uv}$。

令 $u = {xay}$，$v = {(xay)^k xbh}$，其中 $x,y,h\in\Sigma^*$，$a,b\in\Sigma$，$a<b$。

我们有 $v \succ uv \Longleftrightarrow (xay)^{k - 1} xbh \succ (xay)^k xbh \Longleftrightarrow xbh \succ (xay) xbh$。

$v>{uv} \implies {u^iv} > u^{i+1} \implies \blacksquare$

同理如果 $u^\infty > v$，则 $v < {uv} < {u^2v} < \cdots$。

#### Theory 2.2.2 Significant Suffixes Theory

> $$
> \Lambda(u)\subseteq \{s_i | i \in [1,n]\}
> $$

反证法：如果这个命题不成立，则我们分类讨论

**i)** 假设有一个串 $v = \overline {b{w_i}^ks_{i+1}} \in \Lambda(u)$，$|b| < |w_i|,\ 0 \le k < k_i$。

$w_i \in \mathcal L \implies w_i \triangleleft b \implies s_i = {w_is_{i+1}} < {bs_{i+1}}$，矛盾。

**ii)** 假设有一个串 $v = {{w_i}^ks_{i+1}} \in \Lambda(u)$，$1 < k < k_i$。

根据 **[Theory 2.2.1 Infinite Theory]**，如果 ${w_i}^\infty < s_{i+1}$，则 ${{w_i}^{k_i}s_{i+1}} < {{w_i}^{k_i - 1}s_{i+1}}<\cdots<s_{i+1}$，否则 ${{w_i}^{k_i}s_{i+1}} > {{w_i}^{k_i-1}s_{i+1}} > \cdots > s_{i+1}$。

我们令 $\lambda = \min \{i : s_{i+1} \sqsubset s_i\}$。$\forall i \ge \lambda, \ w_i = {s_{i+1}y_i},\ x_i = {y_is_{i+1}}$。$\implies s_i = {{w_i}^{k_i}s_{i+1}}= {(s_{i+1}y_i)^{k_i}s_{i+1}} = {s_{i+1}{x_i}^{k_i}}$。

根据 CFL 的性质，$s_{\lambda} \triangleleft w_{\lambda - 1}$。所以 $\Lambda(u)\subseteq \{s_i | i \in [1,n]\}$。$\blacksquare$

### 2.3 Other Theories

#### Theory 2.3.1 Lambda Subset Theory

> 如果有 $2$ 个串 $u$ 和 $v$，满足 $|u| \le |v|$，则我们有
> $$
> \begin{aligned}\Lambda(uv) &\subseteq \Lambda(v) \cup \{\operatorname{maxsuf}^R(u, v)\} \\&= \Lambda(u) \cup{\max _{s \in \Lambda(u)}}^R \{sv\}\end{aligned}
> $$

理由很简单，因为 $\{\operatorname{maxsuf}^R(u, v)\}$ 也是一个 Significant Suffix，随意我们就可以把它展成第二行的式子的形式。$\blacksquare$

#### Theory 2.3.2 Significant Suffixes Log Theory

> 一个字符串 $S$ 的 Significant Suffixes 至多有 $\log n$ 个。

原命题可以很容易地转化为：（感谢 yhx 的证明）

> 如果两个 Significant Suffixes $u$，$v$ 满足 $|u| < |v|$，那么 $2|u| < |v|$。

反证法。设存在 $|u| < |v| < 2|u|$。因为 $u, v \in \operatorname{suf}^+(u)$，所以 $u \in \operatorname{suf}^+(v)$。

所以我们可以非常容易地知道，$u \triangleleft v$。$\implies v$ 有一个长度为 $|v| - |u| < \frac {|v|} 2$ 的周期，记为 $T$。

所以，$u = {Tw}, v = {T^2w}$。

由于 $u$ 是一个 Significant Suffix，因此存在串 $t$，满足 $vt>ut$，即 ${T^2wt} > {Twt} \implies {Twt} > {wt}$。

而 $w \in \operatorname{suf}^+(s)$，所以与 $u$ 是 Significant Suffix 矛盾。$\blacksquare$

### 2.4 Facts

我们知道 $\Lambda(S)$ 中有很多串，其中最短的是 $\operatorname{minsuf}(S)$，而最长的是 $\operatorname{maxsuf}^R(S)$。这里的 $^R$ 代表 reverse。

- $\Lambda(u) = \{s_{\lambda}, \cdots, s_{n+1}\}$
- $\operatorname{minsuf}(u) = s_n$
- $\operatorname{maxsuf}^R(u) = s_\lambda$
- ${x_\lambda}^\infty > \cdots > {x_m}^\infty$
- 我们有一个串 $v$，${x_i}^\infty > v > {x_{i+1}}^\infty$。则 ${s_\lambda v} > \cdots > {s_{i+1}v} < \cdots < {s_kv}$。
- 对于两个串 $u$ 和 $v$，有 $|u|<|v|$，$\Lambda({uv}) \subseteq \{\operatorname{maxsuf}^R(u, v)\} \cup \Lambda(v) = \{\min_{w \in \Lambda(u)}{wv}\} \cup \Lambda(v)$。

这里的 Proof 先咕着吧。贴个 Reference：

1. Tomohiro, I., Nakashima, Y., Inenaga, S., Bannai, H., & Takeda, M. (2016). Faster Lyndon factorization algorithms for SLP and LZ78 compressed text. Theor. Comput. Sci., 656, 215-224.
2. Kociumaka, T. (2016). Minimal Suffix and Rotation of a Substring in Optimal Time. ArXiv, abs/1601.08051

## 进入正题。

我们先考虑不带修的情况。

由 **[Theory 2.3.1 Lambda Subset Theory]**，我们可以很容易地想到考虑建一棵线段树来维护 Significant Suffixes。

细节：如果线段树的 `mid = l + r >> 1`，则左边的区间比右边长一些。但是上面的这个结论对于 $|u| \le |v|$ 有效，所以我们需要调整一下，使得左儿子比右儿子要长一些（即：`mid = l + r + 1 >> 1`，使得左儿子总不比右儿子短）

可以存一下当前代表的串的所有 Significant Suffixes，然后直接考虑合并（把右边的所有的直接加进来，左边的都循环一遍，字典序最长的加进去）得到父节点的 Significant Suffixes 即可。（看不懂的看代码）

由 **[Theory 2.3.2 Lambda Log Theory]** 可知，每一个集合都是 $O(\log n)$ 大小的。这样的话，我们求出了每一个线段树上的区间的 Significant Suffixes。然后查询就在这 $O(\log n)$ 个区间内求 Significant Suffixes 的并，暴力比较即可。所以我们需要一个 $O(1)$ 比较两个串的方法（否则复杂度就挂了）。所以如果不带修的话我们可以考虑 SA。

接下来考虑带修的情况。

我们需要快速地求两个串的 LCP，又有一个线段树，所以可以很自然地想到一个线段树+字符串哈希+二分LCP的算法。复杂度 $O(q \log^4 n)$，慢了点，我这种人傻常数大的就不用想了。

我们考虑分块维护一些哈希，分 $\sqrt n$ 的块。我们维护一下每个点到块的末端的哈希值，然后维护一下每个块到串的末尾的哈希值。然后我们可以记一个块的全局的偏移量，就可以算了。每次查询的时候，我们只需要查 $2$ 次即可，$O(1)$ 查找。最终是 $O(q \log ^3 n + q\sqrt n)$ 的复杂度。

**Q: 道理我都懂，但是为什么我挂了？** A: 你是用了自然溢出哈希吧，换个双哈希试试。

### code

```cpp
const int N = 200000;
const int B = 450;

const int base1 = 233;
const int base2 = 5e8;
const int mod = 1e9 + 9;

int n, q, c[N];
std::vector<int> tree[N << 2];

namespace Block {
int bs, bdelta[B], power[N + 1], psum[B + 1], intrah[B][B], interh[B];
  
inline int getc(int i) { return c[i] + bdelta[i / bs]; }

inline int geth(int i) {
  if (i == -1)
    return 0;
  const int bid = i / bs;
  i = i % bs;
  return ((ll)interh[bid] * power[i + 1] + intrah[bid][i] + (ll)bdelta[bid] * psum[i + 1]) % mod;
}

void init() { // 初始化分块和哈希
  bs = ceil(sqrt(1.0 * n));
  power[0] = 1, psum[0] = 0;
  for (int i = 1; i <= n; ++i)
    power[i] = (ll)power[i - 1] * base1 % mod;
  for (int i = 1; i <= bs; ++i)
    psum[i] = (psum[i - 1] + power[i - 1]) % mod;
  for (int bid = 0, s = 0; s < n; ++bid, s += bs) {
    interh[bid] = geth(s - 1);
    int h = 0;
    for (int r = 0; r < bs && s + r < n; ++r) {
      h = ((ull)h * base1 + (c[s + r] + base2)) % mod;
      intrah[bid][r] = h;
    }
  }
}

void hadd(int a, int b, int d) { // 对哈希修改
  for (int bid = 0, s = 0; s < n; ++bid, s += bs) {
    interh[bid] = geth(s - 1);
    if (a <= s && s + bs <= b)
      bdelta[bid] += d;
    else if (s < b && a < s + bs) {
      int h = 0;
      for (int r = 0; r < bs && s + r < n; ++r) {
        c[s + r] += bdelta[bid] + (a <= s + r && s + r < b ? d : 0);
        h = ((ull)h * base1 + (c[s + r] + base2)) % mod;
        intrah[bid][r] = h;
      }
      bdelta[bid] = 0;
    }
  }
}

template <bool flag = 1> bool cmp(int i, int j, int r) { // 比较两个串
  int hi = geth(i - 1), hj = geth(j - 1);
  int low = 0, high = r - j + 1;
  while (low < high) {
    int middle = low + high + 1 >> 1;
    if (((ull)(hi + mod - hj) * power[middle] + geth(j + middle - 1) + mod - geth(i + middle - 1)) % mod == 0)
      low = middle;
    else
      high = middle - 1;
  }
  return j + low - 1 == r ? flag : getc(i + low) < getc(j + low);
}
} // namespace Block

namespace Sgt {
inline void pushup(int k, int l, int r) { // 合并子节点信息
  auto &sigsuf = tree[k] = tree[k * 2 + 1]; // 右子节点直接加进来
  int best = -1;
  for (int i : tree[k * 2]) // 左子节点遍历一遍
    if (best == -1 || Block::cmp(i, best, r)) best = i; // 最“重要”的一个加进来
  sigsuf.push_back(best);
}

void build(int k, int l, int r) {
  if (l == r) return (void)(tree[k] = {l});
  int mid = (l + r + 1) / 2; // 左边比右边大
  build(k * 2, l, mid - 1);
  build(k * 2 + 1, mid, r);
  pushup(k, l, r);
}

void modify(int k, int l, int r, int a, int b) {
  if (b < l || r < a || (a <= l && r <= b)) return;
  int mid = (l + r + 1) / 2;
  if (a < mid) modify(k * 2, l, mid - 1, a, b);
  if (b >= mid) modify(k * 2 + 1, mid, r, a, b);
  pushup(k, l, r);
}

void query(int k, int l, int r, int a, int b, int &best) {
  if (b < l || r < a) return;
  if (a <= l && r <= b) {
    for (int v : tree[k])
      if (best == -1 || Block::cmp<0>(v, best, b))
        best = v;
    return;
  }
  int mid = (l + r + 1) / 2;
  if (b >= mid) query(k * 2 + 1, mid, r, a, b, best);
  if (a < mid) query(k * 2, l, mid - 1, a, b, best);
}
} // namespace Sgt
```

主程序随便写，注意我的下标是从 0 开始的。

---

## 作者：shadowice1984 (赞：10)

爆肝好题啊……

我给你讲，这题炒鸡休闲的，我也就写了7.7个k……

~~怎么zjoi的题都是思维难度高代码实现难度大的duliu题啊~~

______________

## 前置芝士：线段树

蛤？不会线段树敢来淦zjoi？

## 前置芝士：字符串哈希

~~不会蛤希的可以出门左转你站模板区包教包会~~

_______________

# 本题题解

首先我们看到一个肥肠劲爆的操作，维护一个字符串，支持**区间加**

这就十分出乎我们的意料了，我们通常学的串串都是给定一个静态字符串然后询问一些奇奇怪怪的东西，但是这道题不仅询问了一个区间最小后缀这种神奇的东西还要资瓷一个非常有毒的区间加操作……

那么让我们先从一个naive的静态做法开始……(和正解的联系不是很大，可以选择性阅读)

## 静态做法

由于这是一个静态串我们可以求出字符串的后缀数组来，那么我们现在至少知道了每一个后缀在全局的排名了

那么我们现在需要求出$(l,r]$这段区间内字典序最小的以$r$结尾的后缀了

我们不妨把这个字符串分成两段来看，先求出$(l,mid]$中字典序最小的后缀，然后求出$(mid,r]$中字典序最小的后缀

然后接下来我们的算法简易的令人吃鲸，只要我们保证左侧区间的长度小于等于右侧区间的长度，那么我们只需要求出$(l,mid]$中**全局**字典序最小的后缀然后和右侧区间的结果取个min就能得到答案了

**注意：刚才的描述混用了子串和后缀的概念，以r结尾的后缀其实是整个字符串的一个子串，我们刚才的算法流程其实是将$(pos,r)$和右侧区间分治之后返回的结果取了一个min，其中$(pos,n)$是左端点在$(l,mid]$当中字典序最小的后缀**

为什么这个看起来假的捕星的算法其实是正确的呢？

我们的算法唯一假的地方就是用$(pos,r)$替换了以r结尾的，左端点在$(l,pos]$当中字典序最小的后缀

那么我们来考虑一下当$(pos,r)$是假后缀的时候会发生什么状况

换句话讲就是$(pos,r)$并不是左侧区间当中字典序最小的后缀，存在一个比他更小的串S

那么我们知道$(pos,n)$是全局最小的后缀，那么换句话讲肯定是两个子串分出大小的位置在$r$之后导致另外一个子串由于长度较短，导致在以$r$结尾时字典序较小的串不是$(pos,r)$了

这只能说明一件事，S既是$(pos,r)$的前缀还是$(pos,r)$的后缀，并且S还是一个长度过半的公共前后缀，因为我们右侧区间的长度比左侧区间长度大

那么$(pos,r)$就是一个有周期的串了，所以不好意思$(pos,r)$和S都不是$(l,r)$当中字典序最小的后缀，字典序最小的后缀在右侧区间，而我们求出来的假后缀则会被取min给取掉

所以我们就得到了一个$O(logn)$的优秀静态做法(如果使用st表可以做到$O(1)$回答每个询问)

## 动态做法

当然你也看到了这个静态做法没有任何抢救的空间了，我们首先需要求出全局最小的后缀才行，但是现在有动态修改我们不能用后缀数组了……

那么我们不妨把刚才的做法反过来，使用线段树维护整个序列，自底向下的求出答案

但是首先我们需要合并左右两个区间

采用左开右闭的建树方式，我们可以保证左孩子的长度永远小于等于右孩子的区间长度，那么我们仿照静态做法，尝试用长度过半的前后缀与周期串之间的关系来搞事情……

那么我们采用这样一个策略，在每个区间上维护将来可能成为最小字典序后缀的位置，换句话说线段树上每个节点开一个vector存储所有可能成为最小字典后缀的位置

那么假如我们知道了左儿子的vector和右儿子的vector,我们来考虑一下如何得到这个节点的vector

首先这个节点应该继承右孩子的vector，因为右孩子存储的子串后面并没有添加东西，所以这些后缀依然有潜力

接下来我们考虑处理左孩子的vector，我们把左孩子中的串都拉出来并且在这些字符串的后面怼上一个右孩子对应的字符串

接下来我们开始比较这些字符串的字典序大小，如果两个串u,v(这里认为u比v长)满足v不是u的前缀，那么证明这两个字符串已经比出字典序大小了，我们留下字典序更小的那个就可以了

接下来是一个比较有趣的情况，如果v是u的前缀，我们应该留下u而不是v，尽管看起来此时v的字典序更小

为啥呢？我们发现u有过半的公共前后缀，所以u是个周期串

那么我们发现v现在就不是字典序最小的串，至少这个字符串一个更短的周期z就比他小，那么在整个字符串后怼上一个字符之后v有没有潜力成为字典序最小的后缀呢？

答案是否定的，如果加上一个字符之后v仍然是周期串那么v还是凉的，如果加上一个字符之后整个串不再是周期串，我们比较一下这个字符是比应该填的字符大还是小，如果大的话u的字典序比v小如果小的话z的字典序比v小,无论如何v都是凉的

那么如此这般我们发现左孩子中只有一个元素可以加入到父亲节点的vector里，那么这样看来每个节点的vector的size就是log级别的

那么现在询问就非常的好处理了，反正$m$只有3w，我们3个log乱搞完全能过，我们把询问的区间在线段树上拆分成log个区间然后大力取min就做完了

修改也非常的好处理，容易看出如果一个区间被整体加上一个值之后有潜力成为字典序最小后缀的串是没有变化的，那么在一次区间加操作之后我们只需要修改$O(logn)$个节点的vector,暴力合并左右孩子就行了

好了看起来我们需要资瓷的操作就是区间加比较两个字符串的大小，也就是说区间加求两个后缀的lcp

后缀数组和sam都凉了，我们还是老老实实二分哈希求lcp吧

这里我们使用分块来维护hash值，这样我们一次修改是$O(\sqrt{N})$的而查询一次的复杂度是$O(1)$的~~其实常数很大~~

这里有一个trick就是我们需要在整个字符串加上或者减去一个数字的情况下快速得知hash值，其实非常简单，我们把bas开到3e8的级别，然后直接把原来的hash值加上或者减去aaaaaaaa这样的字符串的hash值就可以了，为了避免减出负数来我们还需要把每个数字加上一个很大的数字以避免负数

如此这般实现两个数据结构，我们就以丢人的$O(nlog^2n+m(log^3n+\sqrt{N}))$完成了这题……

啊，uoj前面那些人怎么那么块啊？

把hash换成暴力lcp即可，实现简单，由于数据水还不会被卡

当然你也可以用自然溢出hash，不要像我一样很蠢的用双hash

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=2*1e5+10;const int B=450;typedef long long ll;
const ll bas=3*1e8+19;const int shif=bas/2;int n;int mde[N];int m;int rk[N<<1];
const ll mod1=998244353;const ll mod2=1e9+7;int TP;
inline ll po(ll a,ll p,ll mod){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
namespace hsa//分块维护hash值 
{
	int bi[N];int bj[N];ll mi1[N];ll imi1[N];ll mi2[N];
	ll imi2[N];ll pre1[N];ll pre2[N];ll sf1[N];ll sf2[N];
	struct blk
	{
		int ch[B+3];ll pr1[B+3];ll pr2[B+3];ll sp1[B+3];ll sp2[B+3];int ad;int siz;
		inline int& operator [](const int& x){return ch[x];}
		inline void calh()
		{
			for(int i=1;i<=siz;i++)pr1[i]=(pr1[i-1]+mi1[i-1]*ch[i])%mod1;
			for(int i=1;i<=siz;i++)pr2[i]=(pr2[i-1]+mi2[i-1]*ch[i])%mod2;
		}inline void ih()
		{
			for(int i=1;i<=siz;i++)sp1[i]=(sp1[i-1]+mi1[i-1])%mod1;
			for(int i=1;i<=siz;i++)sp2[i]=(sp2[i-1]+mi2[i-1])%mod2;calh();
		}inline void badd(int l,int r,int del)
		{for(int i=1;i<=siz;i++)ch[i]+=ad;for(int i=l;i<=r;i++)ch[i]+=del;ad=0;calh();}
		inline ll gh1(int x){return (pr1[x]+sp1[x]*(mod1+ad))%mod1;}
		inline ll gh2(int x){return (pr2[x]+sp2[x]*(mod2+ad))%mod2;}
	}bl[N/B+3];
	inline void calp(int st)
	{
		for(int i=st;i<=bi[n];i++)pre1[i]=(pre1[i-1]+bl[i].gh1(bl[i].siz)*sf1[i-1])%mod1;
		for(int i=st;i<=bi[n];i++)pre2[i]=(pre2[i-1]+bl[i].gh2(bl[i].siz)*sf2[i-1])%mod2;
	}
	inline void ih(int* mde)
	{
		for(int i=1;i<=n;i++)bi[i]=(i-1)/B+1;for(int i=1;i<=n;i++)bj[i]=(i-1)%B+1;
		mi1[0]=1;for(int i=1;i<=n;i++)mi1[i]=mi1[i-1]*bas%mod1;
		mi2[0]=1;for(int i=1;i<=n;i++)mi2[i]=mi2[i-1]*bas%mod2;
		imi1[0]=1;ll iv=po(bas,mod1-2,mod1);for(int i=1;i<=n;i++)imi1[i]=imi1[i-1]*iv%mod1;
		imi2[0]=1;iv=po(bas,mod2-2,mod2);for(int i=1;i<=n;i++)imi2[i]=imi2[i-1]*iv%mod2;
		for(int i=1;i<=n;i++)bl[bi[i]][bj[i]]=mde[i];
		for(int i=1;i<bi[n];i++)bl[i].siz=B;bl[bi[n]].siz=(n%B)?n%B:B;
		for(int i=1;i<=bi[n];i++)bl[i].ih();
		sf1[0]=1;for(int i=1;i<=bi[n];i++)sf1[i]=sf1[i-1]*mi1[bl[i].siz]%mod1;
		sf2[0]=1;for(int i=1;i<=bi[n];i++)sf2[i]=sf2[i-1]*mi2[bl[i].siz]%mod2;calp(1);
	}
	inline ll gh1(int p){int t=bi[p]-1;return (pre1[t]+bl[t+1].gh1(bj[p])*sf1[t])%mod1;}
	inline ll gh2(int p){int t=bi[p]-1;return (pre2[t]+bl[t+1].gh2(bj[p])*sf2[t])%mod2;}
	inline void modify(int l,int r,int del)
	{
		int p1=bi[l];int p2=bi[r];if(p1==p2){bl[p1].badd(bj[l],bj[r],del);goto ed;}
		bl[p1].badd(bj[l],bl[p1].siz,del);bl[p2].badd(1,bj[r],del);
		for(int i=p1+1;i<p2;i++)bl[i].ad+=del;ed:calp(p1);
	}
	inline bool ck(int p1,int p2,int len)
	{
		ll v1=(gh1(p1+len-1)+mod1-gh1(p1-1))*imi1[p1-1]%mod1;
		ll v2=(gh1(p2+len-1)+mod1-gh1(p2-1))*imi1[p2-1]%mod1;
		if(v1!=v2)return false;
		v1=(gh2(p1+len-1)+mod2-gh2(p1-1))*imi2[p1-1]%mod2;
		v2=(gh2(p2+len-1)+mod2-gh2(p2-1))*imi2[p2-1]%mod2;return v1==v2;
	}
	inline int gt(int x){return bl[bi[x]][bj[x]]+bl[bi[x]].ad;}
}
struct str//字符串类 
{
	int st;int len;
	friend bool operator <(str a,str b)
	{
		int c1=hsa::gt(a.st);int c2=hsa::gt(b.st);if(c1!=c2)return c1<c2;
		int l=0;int r=min(a.len,b.len);
		if(hsa::ck(a.st,b.st,r))return (a.len>b.len)^TP;r--;
		while(l!=r)
		{int mid=(l+r+1)>>1;if(hsa::ck(a.st,b.st,mid))l=mid;else r=mid-1;}
		return hsa::gt(a.st+l)<hsa::gt(b.st+l);
	}friend str operator +(str a,int b){return (str){a.st,a.len+b};}
};
struct linetree//线段树 
{
	str v[N<<2][20];int cnt[N<<2];str ans;
	inline void mg(int p,int p1,int p2,int len)//合并两个节点 
	{
		cnt[p]=cnt[p2];for(int i=1;i<=cnt[p2];i++)v[p][i]=v[p2][i];
		str mi=v[p1][1]+len;for(int i=2;i<=cnt[p1];i++)mi=min(mi,v[p1][i]+len);
		v[p][++cnt[p]]=mi;
	}	
	inline void build(int p,int l,int r)
	{
		if(r-l==1){v[p][++cnt[p]]=(str){r,1};return;}int mid=(l+r)>>1;
		build(p<<1,l,mid);build(p<<1|1,mid,r);mg(p,p<<1,p<<1|1,r-mid);
	}
	inline void modify(int p,int l,int r,int dl,int dr)
	{
		if(dl==l&&r==dr){return;}int mid=(l+r)>>1;
		if(dl<mid)modify(p<<1,l,mid,dl,min(dr,mid));
		if(mid<dr)modify(p<<1|1,mid,r,max(dl,mid),dr);mg(p,p<<1,p<<1|1,r-mid);
	}
	inline void qry(int p,int l,int r,int dl,int dr,int pos)
	{
		if(dl==l&&dr==r)
		{
			int i=1;if(ans.st==-1)ans=(str){v[p][1].st,pos-v[p][1].st+1},i=2;
			for(;i<=cnt[p];i++)ans=min(ans,(str){v[p][i].st,pos-v[p][i].st+1});return;
		}int mid=(l+r)>>1;
		if(dl<mid)qry(p<<1,l,mid,dl,min(dr,mid),pos);
		if(mid<dr)qry(p<<1|1,mid,r,max(dl,mid),dr,pos);
	}
	inline int cqry(int l,int r){ans=(str){-1,0};qry(1,0,n,l-1,r,r);return ans.st;}
}lt;
int main()
{
	scanf("%d%d",&n,&m);for(int i=1;i<=n;i++)scanf("%d",&mde[i]);
	for(int i=1;i<=n;i++)mde[i]+=shif;hsa::ih(mde);lt.build(1,0,n);
	for(int i=1,tp,l,r,d;i<=m;i++)
	{
		scanf("%d%d%d",&tp,&l,&r);
		if(tp==1)
		{
			scanf("%d",&d),TP=0;for(int i=l;i<=r;i++)mde[i]+=d;
			hsa::modify(l,r,d),lt.modify(1,0,n,l-1,r);
		}
		else {TP=1;printf("%d\n",lt.cqry(l,r));}
	}return 0;//拜拜程序~ 
}
```

















---

## 作者：向日葵小班 (赞：7)

### 题目大意：

&emsp;&emsp;维护一个长度为 $n$ 的动态字符串 $s$，字符集为 $1 ∼ 10^9$。支持下列操作：

-  区间加。

-  询问某个子串的最小后缀的开头位置。
 
 &emsp;&emsp;$n\le 2\times 10^5,m\le 3\times 10^4$。
 
 

------------
###   这题要先学会一种东西: 最小后缀。
  
  定义：
  
&emsp;&emsp;记 $\operatorname{suf(S)}$ 为 $S$ 的后缀集合。
  
&emsp;&emsp;记 $\operatorname{minsuf(S)}$ 为 $S$ 的最小后缀。

&emsp;&emsp;记 $\operatorname{Ssuf(S)}$ 为 $\left\{V∈\operatorname{suf(S)}|T,VT=\operatorname{minsuf(ST)}\right\}$，意思就是说，在 $S$ 后面加一个串之后，可能成为最小后缀的后缀。即 Significant Suffixes，简称为 $\operatorname{Ssuf}$。


------------

定理： 

&emsp;&emsp;**1.** 对于任意两个 $\operatorname{Ssuf}$ $U,V$，$|U|<|V|⇒U$ 是 $V$ 的前缀。

&emsp;&emsp;若 $U$ 并非 $V$ 的前缀，无论向串后面加怎样的 $T$，$UT$ 和 $VT$ 的大小关系还是由 $U,V$ 的大小关系决定。

&emsp;&emsp;所以 $U,V$ 只有一者有可能是 $\operatorname{Ssuf}$，矛盾。

&emsp;&emsp;注意，$U$ 同时也是 $V$ 的后缀，所以 $U$ 是 $V$ 的 $\operatorname{Bd}$。


------------
&emsp;&emsp;**2.** 若串 $S$ 有两个 $\operatorname{Ssuf}U,V$ 满足 $|U|<|V|$，则 $2|U|<|V|$。

&emsp;&emsp;考虑反证。假设 $|U| < |V| < 2|U|$，由上一个定理可得 $U$ 是 $V$ 的 $\operatorname{Bd}$。


&emsp;&emsp;即对应长度为 $\left|V\right|-\left|U\right|<|U|<2|U|$ 的周期。记一个周期为 $T$，有$U=T^kC,V=T^{k+1}C$。




由最小后缀，存在$R$ (可空)使得$UR<VR⇒T^kCR<T^{k+1}CR⇒CR<TCR⇒CR<UR$，注意到 $CR$ 也是后缀，故 $UR$ 注定不可能是最小后缀，矛盾。 

推论：$|\operatorname{Ssuf(S)}|=O(\log|S|)$。


------------
### 回到这题上，我们来讲讲这个题目的解法：

&emsp;&emsp;先写个分块，支持 $O(\sqrt{n})$ 区间加，$O(1)$ 查询区间 $Hash$ 值。

&emsp;&emsp;考虑使用线段树维护 $\operatorname{Ssuf}$ 集合。查询时，答案只可能是拆出来的 $O(\log n)$ 个节点的 $\operatorname{Ssuf}$ 集合的元素，共 $O(\log^2n)$ 个，大力比较，复杂度 $O(\log^3n)$。

&emsp;&emsp;修改时，只有被修改区间部分包含的 $O(\log_n)$ 个点（即在线段树上拆区间时访问的点）的 $\operatorname{Ssuf}$ 受到影响。

&emsp;&emsp;合并两个儿子的信息时，设左侧的串为 $S_1$，右侧的串为 $S_2$。我们要通过 $\operatorname{Ssuf(S_1)},\operatorname{Ssuf(S_2)}$ 得到 $\operatorname{Ssuf(S_1,S_2)}$。

&emsp;&emsp;由于在线段树上有 $|S_2|≤|S_1|≤|S_2|+1$ （两侧长度相近），由倍长定理得至多有一个 $\operatorname{Ssuf(S_1)}$ 中的元素被保留到 $\operatorname{Ssuf(S_1,S_2)}$ 中。如何挑出那个元素？

&emsp;&emsp;对于 $U,V∈\operatorname{Ssuf(S_1)}$，不妨设 $US_2<VS_2$，若 $US_2$ 不是 $VS_2$ 的前缀，则 $VS_2$ 可以排除（显然），若 $US_2$ 是 $VS_2$ 的前缀 $\operatorname{Bd}$，则 $US_2$ 可以排除（证明同前文定理）。

&emsp;&emsp;根据这一规则可以 $\operatorname{Ssuf(S_1)}$ 排除到只剩一个元素 $X$，记 $P=XS_2$。

&emsp;&emsp;初始时令集合 $\operatorname{Ssuf(S_2)}$，然后枚举其中的串 $V$ 进行如下操作：

- 若 $V$ 是 $P$ 的前缀，不做任何操作。

- 若 $V$ 不是 $P$ 的前缀，且 $V < P$，抛弃 $P$。停止。

- 若 $V$ 不是 $P$ 的前缀，且 $V > P$ ，抛弃 $V$。

&emsp;&emsp;若最终 $P$ 未被抛弃，则将其加入 $S$。得到的 $S$ 就是 $\operatorname{Ssuf(S_1,S_2)}$。（实际上，直接令 $S=\operatorname{Ssuf(S_2)}∪{P}$ 复杂度也是对的）
总复杂度 $O(\log^2n+m\log^3n+m\sqrt{n})$。

---


# EI 的第六分块

## 题目背景

他说他解决了经典根号复杂度问题，怕引起轰动所以撤回了.jpg  

不过 [EntropyIncreaser](https://www.luogu.com.cn/user/21423) 确实得到了此题更优的做法。

## 题目描述

给定一个整数序列 $a$，支持两种操作：  

- `1 l r x` 表示给区间 $[l,r]$ 中每个数加上 $x$  
- `2 l r` 表示查询区间 $[l,r]$ 的最大子段和（可以为空）

## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$1\le n,q \le 1000$；  
对于 $60\%$ 的数据，$1\le n,q \le 10^5$；  
对于 $100\%$ 的数据，$1\le n,q \le 4\times 10^5$，$|a_i| \le 10^9$，$1 \le x \le 10^6$。

Idea：nzhtl1477   
Solution：EntropyIncreaser  
Code：EntropyIncreaser   
Data：NaCly_Fish

### 请注意常数优化。

## 样例 #1

### 输入

```
5 5
-2 -3 -3 -3 -3
2 1 5
1 2 4 4
2 1 5
1 2 3 1
2 3 3```

### 输出

```
0
3
2```

# 题解

## 作者：qwaszx (赞：35)

首先，欢迎加入EI队长粉丝裙:450567214

本题的一个 $O((n+m)\log^3 n+q\log n)$ 做法由 EI 队长在她的集训队论文《浅谈函数最值的动态维护》中给出，其中 $n,m,q$ 分别代表序列长度、修改次数、查询次数. 该数据结构被称为 Kinetic Tournament 树 (KTT).

该做法的原理在 [EI's blog](https://blog.csdn.net/EI_Captain/article/details/101040226) 或论文中有详细阐述，这里仅给出一个直接实现及可参考的代码.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=400500;
const long long INF=2e18;
int n,w[N],m;
long long tag[N<<2];
struct LINE//一次函数
{
    int k;long long b;
    LINE operator +(const LINE &a)const{return (LINE){k+a.k,b+a.b};}
};
pair<LINE,long long> max(LINE a,LINE b)//对两个一次函数取x=0时的最值，同时给出max的选取不发生变化的最大值C(即 x>C 时max变成另一个)
{
    if(a.k<b.k||(a.k==b.k&&a.b<b.b))swap(a,b);
    if(a.b>=b.b){return make_pair(a,INF);}
    return make_pair(b,(b.b-a.b)/(a.k-b.k));
}
struct Node
{
    LINE ls,rs,ans,sum;long long x;//增量>x时子树内会有max的选取发生变化
    Node operator +(const Node &a)const
    {
        Node t;t.x=min(x,a.x);
        pair<LINE,long long>tmp=max(ls,sum+a.ls);
        t.ls=tmp.first,t.x=min(t.x,tmp.second);
        tmp=max(a.rs,rs+a.sum);
        t.rs=tmp.first,t.x=min(t.x,tmp.second);
        tmp=max(ans,a.ans);t.x=min(t.x,tmp.second);
        tmp=max(tmp.first,rs+a.ls);
        t.ans=tmp.first,t.x=min(t.x,tmp.second);
        t.sum=sum+a.sum;
        return t;
    }
}a[N<<2];
void build(int rot,int lt,int rt)
{
    if(lt==rt)
    {
        LINE t={1,w[lt]};
        a[rot]=(Node){t,t,t,t,INF};
        return;
    }
    int mid=(lt+rt)>>1;
    build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);
    a[rot]=a[rot<<1]+a[rot<<1|1];
}
void upd(int rot,long long w)
{
    tag[rot]+=w;a[rot].x-=w;
    a[rot].ls.b+=a[rot].ls.k*w;
    a[rot].rs.b+=a[rot].rs.k*w;
    a[rot].ans.b+=a[rot].ans.k*w;
    a[rot].sum.b+=a[rot].sum.k*w;
}
void upd(int rot,int lt,int rt,long long w)
{
    if(w>a[rot].x)//如果增量使得子树内有max发生变化则递归下去重构
    {
        long long t=tag[rot]+w;tag[rot]=0;int mid=(lt+rt)>>1;
        upd(rot<<1,lt,mid,t),upd(rot<<1|1,mid+1,rt,t);
        a[rot]=a[rot<<1]+a[rot<<1|1];
    }
    else upd(rot,w);
}
void pushdown(int rot)
{
    if(tag[rot])
    {
        long long t=tag[rot];tag[rot]=0;
        upd(rot<<1,t),upd(rot<<1|1,t);
    }
}
void update(int rot,int lt,int rt,int lq,int rq,int x)
{
    if(lt>=lq&&rt<=rq){upd(rot,lt,rt,x);return;}
    pushdown(rot);
    int mid=(lt+rt)>>1;
    if(lq<=mid)update(rot<<1,lt,mid,lq,rq,x);
    if(rq>mid)update(rot<<1|1,mid+1,rt,lq,rq,x);
    a[rot]=a[rot<<1]+a[rot<<1|1];
}
Node query(int rot,int lt,int rt,int lq,int rq)
{
    if(lt>=lq&&rt<=rq)return a[rot];
    pushdown(rot);
    int mid=(lt+rt)>>1;
    if(rq<=mid)return query(rot<<1,lt,mid,lq,rq);
    if(lq>mid)return query(rot<<1|1,mid+1,rt,lq,rq);
    return query(rot<<1,lt,mid,lq,mid)+query(rot<<1|1,mid+1,rt,mid+1,rq);
}
int getin()
{
    int x=0,f=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x*f;
}
int main()
{
    n=getin(),m=getin();
    for(int i=1;i<=n;i++)w[i]=getin();
    build(1,1,n);
    for(int i=1,opt,l,r,x;i<=m;i++)
    {
        opt=getin(),l=getin(),r=getin();
        if(opt==1)x=getin(),update(1,1,n,l,r,x);
        else printf("%lld\n",max(0ll,query(1,1,n,l,r).ans.b));
    }
}
```

---

## 作者：cyffff (赞：30)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5693)

“$\text{KTT}$”学习笔记。

不含复杂度分析。理解上参考学习了 @[optimize_2](https://www.luogu.com.cn/user/224978) 的[这篇题解](https://www.luogu.com.cn/blog/_post/476943)。

## 题意

区间加正数，区间最大子段和。

$n,q\le4\times10^5$。

## 思路
线段树求区间最大子段和需要维护的有区间和 $sum$，最大前缀和 $lmax$，最大后缀和 $rmax$，最大子段和 $totmax$ 四个参数。

考虑修改操作对这几个值的影响。

对区间加上 $k$，如果选择的区间没有发生改变，则这个答案会变大 $lk$，其中 $l$ 为选择的区间长度。

我们考虑将上述四个值换用一次函数表示，使其表示为 $ls+b$，如果没有改变选择的区间则 $s$ 每次增加 $k$。

为了判断选择的区间是否改变，除了加法标记，我们需要额外维护一个 $x$，表示如果 $s\ge x$，则 $lmax,rmax,totmax$ 选择的区间至少有一个一定会改变。

考虑 `pushup`：$+$ 操作为一次函数相加，$\max$ 操作为一次函数在 $s=0$ 处的比较。
- $sum=l.sum+r.sum$
- $lmax=\max(l.lmax,l.sum+r.lmax)$
- $rmax=\max(r.rmax,l.rmax+r.sum)$
- $totmax=\max(l.totmax,r.totmax,l.rmax+r.lmax)$
- $x$ 在 $\min(l.x,r.x)$ 的基础上，对 $lmax,rmax$ 的两种方案、$totmax$ 的三种方案的一次函数交点位置取 $\min$（小于 $0$ 或无交点变为 `INF`）

在实现中，我们每次把 $x$ 减小 $k$，如果 $x$ 在一次减小后小于 $0$，则 `dfs` 这个子树，如果搜到的子树 $x$ 没有变为 $0$ 就返回。

通过复杂的势能分析，我们会得到复杂度为 $O((n+m)\log^3n+q\log n)$，其中 $m$ 为修改次数，$q$ 为查询次数。

代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=4e5+10;
const ll INF=1e15;
int n,Q,p[N];
#define ls (rt<<1)
#define rs (rt<<1|1)
struct Func{
	int k;
	ll b;
	inline friend Func operator+(const Func &a,const Func &b){
		return (Func){a.k+b.k,a.b+b.b};
	}
	inline void add(ll v){ b+=k*v; }
};
inline pair<Func,ll> max(Func a,Func b){
	if(a.k<b.k||a.k==b.k&&a.b<b.b) swap(a,b);
	if(a.b>=b.b) return make_pair(a,INF);
	return make_pair(b,(b.b-a.b)/(a.k-b.k));
}
struct node{
	Func lmax,rmax,totmax,sum;
	ll x;
	inline friend node operator+(const node &a,const node &b){
		node t;
		pair<Func,ll> tmp;
		t.x=min(a.x,b.x);
		tmp=max(a.lmax,b.lmax+a.sum);
		t.lmax=tmp.first,t.x=min(t.x,tmp.second);
		tmp=max(b.rmax,a.rmax+b.sum);
		t.rmax=tmp.first,t.x=min(t.x,tmp.second);
		tmp=max(a.totmax,b.totmax);
		t.x=min(t.x,tmp.second);
		tmp=max(tmp.first,a.rmax+b.lmax);
		t.totmax=tmp.first,t.x=min(t.x,tmp.second);
		t.sum=a.sum+b.sum;
		return t;
	}
};
struct KTT{
	node a[N<<2];
	ll tag[N<<2];
	inline void pushup(int rt){
		a[rt]=a[ls]+a[rs];
	}
	inline void push(int rt,ll v){
		tag[rt]+=v;
		a[rt].x-=v;
		a[rt].lmax.add(v);
		a[rt].rmax.add(v);
		a[rt].sum.add(v);
		a[rt].totmax.add(v);
	}
	inline void pushdown(int rt){
		if(tag[rt]){
			ll bas=tag[rt];
			tag[rt]=0;
			push(ls,bas);
			push(rs,bas);
		}
	}
	inline void build(int rt,int l,int r){
		if(l==r){
			Func q={1,p[l]};
			a[rt]=(node){q,q,q,q,INF};
			return ;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(rt);
	}
	inline void defeat(int rt,int l,int r,ll v){
		if(v>a[rt].x){
			int mid=l+r>>1;
			ll t=tag[rt]+v;
			tag[rt]=0;
			defeat(ls,l,mid,t);
			defeat(rs,mid+1,r,t);
			pushup(rt);
		}else{
			push(rt,v);
		}
	}
	inline void update(int rt,int l,int r,int L,int R,int k){
		if(L<=l&&r<=R){
			defeat(rt,l,r,k);
			return ;
		}
		pushdown(rt);
		int mid=l+r>>1;
		if(L<=mid) update(ls,l,mid,L,R,k);
		if(R>mid) update(rs,mid+1,r,L,R,k);
		pushup(rt);
	}
	inline node query(int rt,int l,int r,int L,int R){
		if(L<=l&&r<=R){
			return a[rt];
		}
		pushdown(rt);
		int mid=l+r>>1;
		if(R<=mid) return query(ls,l,mid,L,R);
		if(L>mid) return query(rs,mid+1,r,L,R);
		return query(ls,l,mid,L,mid)+query(rs,mid+1,r,mid+1,R);
	}
}t;
int main(){
	n=read(),Q=read();
	for(int i=1;i<=n;i++){
		p[i]=read();
	}
	t.build(1,1,n);
	while(Q--){
		int opt=read();
		switch(opt){
			case 1:{
				int l=read(),r=read(),v=read();
				t.update(1,1,n,l,r,v);
				break;
			}
			case 2:{
				int l=read(),r=read();
				write(max(0ll,t.query(1,1,n,l,r).totmax.b)),putc('\n');
				break;
			}
		}
	}
	flush();
    return 0;
} 
```
再见 qwq~

---

## 作者：optimize_2 (赞：19)

关于 EI 的这个做法的讲解不多，我看了一会才懂，这里放一下较为详细的流程讲解（不含复杂度证明）

首先考虑经典不带修区间最大子段和问题的线段树做法，每个节点维护 $tot, sum, pre, suf$ 分别表示当前节点所代表的区间 $[l, r]$ 的总和，最大子段和，前缀最大子段和（必须包含 $l$），后缀最大子段和（必须包含 $r$）。

然后递归左右子树后 `pushup` 更新一下当前节点的答案。

当前节点的最大子段和从 左最大子段和，右最大子段和，左后缀 + 右前缀中取最大值。

当前节点的前缀最大子段从 左前缀，整个左区间 + 右前缀 中取最大值。

当前节点的后缀最大子段和从 右后缀，整个右区间 + 左后缀 中取最大值。

当前节点的总和就是左总和加右总和。

现在看看修改，如果一次区间加并没有导致决策发生变化（另一个子段的和超过了原先的子段称为该区间的决策变化），该区间的答案会增大 $lx$。（$l$ 是这个区间原先的最大子段和选择的子段的长度，$x$ 是本次修改给每个节点增加的值）

所以原先的 $tot, sum, pre, suf$ 不在表示一个值，而是一个二元组 $(l, v)$，$v$ 就是原来的值，$l$ 是当前选择的区间的长度，用来在有修改的时候更新答案。

这样就可以写成一个一次函数来表示一个决策：$y = lx+v$，$x$ 就表示决策所在的区间被整体加了多少。（分散加的话会在 `pushup` 中被更新）

那这是修改不使决策改变的情况，如果修改使决策改变了，原来的决策 $(l_1, v_1)$ 变成了新的决策 $(l_2, v_2)$，相当于因为 $x$ 的增大 $y_1 = l_1x + v_1$ 变得比 $y_2 = l_2x + v_2$ 小了。`pushup` 的时候不是给这两个决策取过 $\max$ 吗？在取 $\max$ 的时候顺便记录一下决策的阈值，详细地说：

在合并两个决策 $p = (l_1, v_1)$ 和 $q = (l_2, v_2)$ 时（不妨设 $v_1 \geq v_2$），由于初始时没有修改，所以肯定选 $p$，这个时候顺便记录一个阈值 $x$，代表当修改大于等于 $x$ 的时候，决策就会改变（$x$ 即为交点横坐标），若不会改变（交点在 $y$ 轴左边）则 $x = inf$。

还有一个特殊情况，就是 $l_1 < l_2$ 而且 $v_1 = v_2$，这个时候就选 $q$，$x$ 记 $inf$。

一个节点的阈值代表当修改大于等于 $x$ 时，它维护的三个决策 $sum, pre, suf$ 中有一个会改变。（取 $\min$ 即可）

然后在修改的时候，如果发生了决策改变，就直接重构这棵子树。（暴力更新左右子树然后 `pushup`）

看起来很暴力，但是复杂度是对的，EI 说是 $O(n\log^3n + m\log^4n + q\log n)$，具体证明可以看 [EI 的博客](https://entropyincreaser.blog.uoj.ac/blog/5217)。

---

## 作者：critnos (赞：12)

原文：https://entropyincreaser.blog.uoj.ac/blog/5217

KTT 维护区间最大子段和。

除了维护区间和，区间最大子段和，区间最大前/后缀和（维护这个和还有长度），还要额外维护一个量表示“这个结点最少加上多少之后区间最大子段和/区间最大前/后缀和的决策会发生变化。”如果给子树加上 $x$ 后发生变化就暴力递归下去，否则直接在原决策上加上长度乘上 $x$。**$x$ 是正数。**

下面是阿巴阿巴的复杂度证明，我觉得大概是对的。

复杂度证明：前后缀长度显然只会增加，那么每次增加的时间复杂度是 $O(\log n)$，总时间复杂度是 $O(n\log ^2n)$。而对于最大子段和的变化使用势能分析。

一个结点的势能：最大子段和可能从左区间最大子段和、右区间最大子段和、左区间最大后缀和+右区间最大前缀和更新，这可以抽象为三条直线 $a,b,c$，设当前决策是 $p\in\{a,b,c\}$，$d$ 表示这个结点到根的距离，当前结点的势能就是 $d([k_p<k_a]+[k_p<k_b]+[k_p<k_c])$（$k$ 是直线斜率）。整棵树的势能是所有结点的势能之和。显然势能是正的。

考虑一次暴力递归发生时（原文称之为“击败事件”）对势能的影响。这意味着该结点的 $p$ 增大了，势能减小 $\ge d$；同时父亲的势能增量 $\le d-1$。综上这次时间复杂度  $O(\log n)$ 的击败事件使势能增加了一个负数。

单次修改会重置 $O(\log n)$ 个结点（非整体加）的势能即把势能增加了 $O(\log^2n)$.

但是！我们还没有考虑最大前后缀和对势能的影响。注意到前后缀的更新次数是 $O(n\log n)$，单次更新会让势能增加 $\le d-1$，所以这里的总势能是 $O(n\log^2 n)$。

综上，时间复杂度 $O((n+m)\log^3 n)$。

---

## 作者：洛苡hh (赞：8)

## 第二分块怎么就比第六分块简单了 第六分块明明~~好懂好写~~ 我为第六分块正名！
~~第六分块不用分块~~。

**本篇题解大部分内容跟我的[P6792 [SNOI2020] 区间和 题解](https://www.luogu.com.cn/blog/luoyihh/p6792-snoi2020-ou-jian-hu-ti-xie)存在重复，因为我是先写的那道题然后来板题拿的双倍经验**。

**KTT 维护区间最大子段和板题，本篇题解不含复杂度证明**。

学习过程中参考了楼上 dalao 的题解以及[EI的博客](https://entropyincreaser.blog.uoj.ac/blog/5217)。

求区间最大子段和，先考虑在线段树上的暴力做法。

朴素的线段树做法是维护四个信息：
- $totmx$：区间最大子段和。
- $lmx$：以左端点为起点的最大子段和（强制包含左端点）。
- $rmx$：以右端点为起点的最大子段和（强制包含右端点）。
- $sum$：区间和。

怎么维护呢？有以下式子：
- $totmx = \max (totmx_{ls} , totmx_{rs} ,rmx_{1s} + lmx_{rs})$。
- $lmx = \max (lmx_{ls} ,  sum_{ls} + lmx_{rs})$。
- $rmx = \max (rmx_{rs} ,  sum_{rs} + rmx_{ls})$。
- $sum = sum_{ls} + sum_{rs}$。  
（$ls,rs$ 分别为左右儿子）。

解释一下 考虑最大子段和一共有三种情况：
1. 子段全部位于左区间内 即 $totmx_{ls}$。
2. 子段全部位于右区间内 即 $totmx_{rs}$。
3. 子段横跨两个区间 这时候左右区间都要做贡献 因为要保证子段连续 所以是 $rmx_{1s} + lmx_{rs}$。

求 $totmx$ 的方式也解释了为什么要维护 $lmx$ 和 $rmx$。

对于 $lmx$ 只要强制包含左端点就行啦:
1. 要么直接继承左区间的答案 即 $lmx_{ls}$。
2. 要么考虑更新 那就是左区间和加上右区间前缀 即 $sum_{ls} + lmx_{rs}$。

$rmx$ 同理。

$sum$ 太基础没啥好说的。

分析一下该算法的复杂度，因为你每次更新都可能会改变最大子段的构成，这个决策改变之后所有维护的信息都要变，也就是在最劣情况下我们需要重构整棵线段树，即 $O(n)$，查询的话就是 $O(\log n)$ 的，所以整体还是比暴力要优，对于一些查询多的题说不定也能冲过去。

现在考虑该算法瓶颈，不难发现在于**修改会改变最大子段构成的决策**，但手推几组数据也很容易发现，不是所有修改都会对决策有影响，只有当变化量大于某个阈值时才会改变决策，否则该是哪个子段还是哪个子段，当成平凡的区间加维护就好。

我们考虑将每个值维护成一次函数的形式 $y=kx+b$，用一个二元组 $(k,b)$ 来表示，$b$ 是现在的值，$k$ 是最大子段的长度，$x$ 即为变化量，在取 $\max$ 时，以前我们只需比较 $b$ 的大小就够了（$x=0$），现在我们还要维护一下什么时候这个决策会改变，具体来说:

两条直线 $l1$，$l2$，不妨令 $b_{l1} > b_{l2}$
1. $k_{l1} > k_{l2}$ 直接把阈值设成 $\inf$。
2. 否则 阈值就是两条直线交点的横坐标。

这部分的代码： 

```cpp
pair<line,long long> max(line a,line b){
	if(a.k<b.k || (a.k==b.k && a.b<b.b)) swap(a,b);
	if(a.b>=b.b) return mkp(a,inf);
	else return mkp(b,(b.b-a.b)/(a.k-b.k));
}
```

易知 $totmx$，$lmx$ 和 $rmx$ 中任何一个改变都可能影响到最终决策，所以整个节点的阈值对它们产生的三个阈值取 $\min$ 即可。

这部分代码：

```cpp
node operator + (const node &a) const{
	node res;
	pair<line,long long> tmp;
	res.x=min(x,a.x);
	//sum=ls.sum+rs.sum
	res.sum=sum+a.sum;
	//lmax=max(ls.lmax,ls.sum+rs.lmax)
	tmp=max(lmx,sum+a.lmx);
	res.lmx=tmp.first;
	res.x=min(res.x,tmp.second);
	//rmax=max(rs.rmax,rs.sum+ls.rmax)
	tmp=max(a.rmx,a.sum+rmx);
	res.rmx=tmp.first;
	res.x=min(res.x,tmp.second);
	//totmax=max(ls.totmax,rs.totmax,ls.rmax+rs.lmax)
	tmp=max(totmx,a.totmx);
	res.x=min(res.x,tmp.second);
	tmp=max(tmp.first,rmx+a.lmx);
	res.totmx=tmp.first;
	res.x=min(res.x,tmp.second);
	return res;
}
```

具体的复杂度证明去 EI 大佬的博客看吧，蒟蒻不会分析势能 QwQ

代码直接用[P6792 [SNOI2020] 区间和](https://www.luogu.com.cn/problem/P6792)的代码改了改（） 一些细节问题放注释里啦！

```cpp
#include<bits/stdc++.h>
#define MAXN 400005
#define inf 1e18
#define ls k<<1
#define rs k<<1|1
#define mkp make_pair
using namespace std;

inline long long read(){
	long long x=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

int n,q;
long long A[MAXN];

//一次函数
struct line{
	long long k,b;//b可以认为就是正常的值 跟原来不加一次函数优化是一样的 k即最大子段和这个子段的长度
	line operator + (const line &a) const{
		return (line){k+a.k,b+a.b};
	}
	void add(long long v){
		b+=k*v;
	}
};

pair<line,long long> max(line a,line b){
	if(a.k<b.k || (a.k==b.k && a.b<b.b)) swap(a,b);
	if(a.b>=b.b) return mkp(a,inf);
	else return mkp(b,(b.b-a.b)/(a.k-b.k));
}

struct node{
	int l,r;
	line lmx,rmx,sum,totmx;
	long long x;//阈值
	long long tag;
	node operator + (const node &a) const{//维护最大子段和需要的四个变量 同时维护阈值
		node res;
		pair<line,long long> tmp;
		res.x=min(x,a.x);
		//sum=ls.sum+rs.sum
		res.sum=sum+a.sum;
		//lmax=max(ls.lmax,ls.sum+rs.lmax)
		tmp=max(lmx,sum+a.lmx);
		res.lmx=tmp.first;
		res.x=min(res.x,tmp.second);
		//rmax=max(rs.rmax,rs.sum+ls.rmax)
		tmp=max(a.rmx,a.sum+rmx);
		res.rmx=tmp.first;
		res.x=min(res.x,tmp.second);
		//totmax=max(ls.totmax,rs.totmax,ls.rmax+rs.lmax)
		tmp=max(totmx,a.totmx);
		res.x=min(res.x,tmp.second);
		tmp=max(tmp.first,rmx+a.lmx);
		res.totmx=tmp.first;
		res.x=min(res.x,tmp.second);
		return res;
	}
}t[MAXN<<2];

void pushup(int k){
	node tmp=t[ls]+t[rs];//重载的运算符只维护了KTT 别把除KTT之外的正常线段树信息搞没了
	tmp.tag=t[k].tag;
	tmp.l=t[k].l;
	tmp.r=t[k].r;
	t[k]=tmp;
}

void build(int k,int l,int r){
	t[k].l=l;t[k].r=r;
	if(l==r){
		line tmp={1,A[l]};//初始值最大子段就是本身 子段长度为1
		t[k].lmx=t[k].rmx=t[k].sum=t[k].totmx=tmp;
		t[k].x=inf;
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(k);
}

void calc(int k,long long v){
	t[k].tag+=v;
	t[k].sum.add(v);
	t[k].totmx.add(v);
	t[k].lmx.add(v);
	t[k].rmx.add(v);
	t[k].x-=v;//别忘了维护阈值
}

void pushdown(int k){
	if(t[k].tag){
		calc(ls,t[k].tag);
		calc(rs,t[k].tag);
		t[k].tag=0;
	}
}

void upd(int k,long long v){
	if(v>t[k].x){//超过阈值的递归重构子树
		v+=t[k].tag;
		t[k].tag=0;
		upd(ls,v);
		upd(rs,v);
		pushup(k);
	}else{
		calc(k,v);//没超过阈值就是平凡的区间加
	}
}

void update(int k,int l,int r,long long v){
	if(t[k].l>=l && t[k].r<=r){
		upd(k,v);
		return;
	}
	pushdown(k);
	int mid=(t[k].l+t[k].r)>>1;
	if(mid>=l){
		update(ls,l,r,v);
	}
	if(mid<r){
		update(rs,l,r,v);
	}
	pushup(k);
}

node query(int k,int l,int r){
	if(t[k].l>=l && t[k].r<=r){
		return t[k];
	}
	pushdown(k);
	int mid=(t[k].l+t[k].r)>>1;
	if(mid>=r) return query(ls,l,r);
	if(mid<l) return query(rs,l,r);
	return query(ls,l,mid)+query(rs,mid+1,r);
}

int main(){
	n=read();q=read();
	for(int i=1;i<=n;i++){
		A[i]=read();
	}
	build(1,1,n);
	int op,l,r;
	long long x;
	while(q--){
		op=read();
		l=read();r=read();
		if(op==1){
			x=read();
			update(1,l,r,x);
		}else{
			long long ans=query(1,l,r).totmx.b;
			printf("%lld\n",max(0ll,ans));
		}
	}
	return 0;
}
```

---

## 作者：CNS_5t0_0r2 (赞：8)

本题是区间加正数 + 区间最大子段和，关于单点修改 + 区间最大子段和可以参见我~~一直在咕~~的[线段树博客](https://www.luogu.com.cn/article/j1ge1oon)【2.3】例题 $1$。

先思考一个问题：单点修改为什么不能直接转成区间加？

答：区间加完后我们不能直接确定一个区间的最优决策会变成什么，而单点修改是可以的（都是一个点了，肯定只能选当前位置或不选啦）。

因此，对于区间修改我们只能暴力修改子树，但这样复杂度就直接爆炸了。

不过，我们可以维护一些额外的信息，可以快速判断一个区间的决策是否会发生变化，从而减少暴力枚举子树时的枚举量。

首先我们得明确：一个决策是如何存储的？或者说，一个决策的形式是什么？

这就跟区间加的性质有关了。如果区间加 $x$ 后决策的区间没变，那么区间最大子段和、区间前缀最大和、区间后缀最大和都会加上 $len \times x$，其中 $len$ 为原来最优决策的区间长度。

这提示我们，我们除了要把这个决策没有区间加时的值存下来，还需要把决策的区间长度 $len$ 存储下来。

对于一个决策，如果其本来的值为 $val$，区间整体加了 $x$，则这个决策的真实值为 $len \times x + val$。因此，如果要比较两个决策在区间整体加 $x$ 时孰优孰劣，只需要比较 $len_1 \times x + val_1$ 和 $len_2 \times x + val_2$。

这显然可以看作两个以 $x$ 作为自变量的一次函数。我们要探讨的问题是如何判断一个区间的决策是否会更改，假设决策 $1$ 本来更优，那么在 $x$ 达到一定的值后，决策 $2$ 会比决策 $1$ 更优。这个时刻显然是 $x$ 取到两个一次函数交点的时刻（特别的，因为 $x$ 为正，所以当交点为负时相当于决策 $2$ 永远不可能优于决策 $1$，这等价于交点处 $x$ 为 $\inf$）。

而本题中有三个量需要决策（区间和决策永远是左右区间和相加），所以，只要 $x$ 达到任意一个量的决策的交点时，就需要重构整棵子树。

对于每个节点维护一个值 $x$ 表示该区间内区间加的值超过 $x$ 时就要暴力重构，$x$ 除了可能是三个量决策的交点，还要和左右子节点的 $x$ 取 $\min$（左右区间的决策修改也会导致当前区间决策发生变化）。

这样本题就做完了。

复杂度……不会证（可以看[这篇题解](https://www.luogu.com.cn/article/ja3bqgqt)）。

以下是一些注意事项：

1. 本题不卡常。

2. 交点横坐标只需要保留整数。

其余的可以参考代码中的注释（如果有不懂的地方可以回复我，我会随时更新）。

以下是代码（应该比较好懂吧）：

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid ((l + r) >> 1)
#define lchild (root << 1)
#define rchild ((root << 1) + 1)
using namespace std;
const int N = 4e5 + 9,INF = 1e15;
int n,m;
int a[N];
struct linear_func{//一次函数，本质存储的是决策
	int k,b;//k：最优决策区间的长度；b：最优决策的值
	void add(int v){
		b += k * v;
	}
};
linear_func operator+(linear_func f1,linear_func f2){//两个一次函数相加
	return (linear_func){f1.k + f2.k,f1.b + f2.b};
}
linear_func Max(linear_func f1,linear_func f2){//返回两个一次函数在 x = 0 （没有区间加操作）处取值更优者及两函数交点坐标
	if(f1.k < f2.k || f1.k == f2.k && f1.b < f2.b)//不明白为什么不交换会WA，有知道的大佬欢迎私信告诉我！
		swap(f1,f2);
	return (f1.b >= f2.b) ? f1 : f2;
}
int intersection(linear_func f1,linear_func f2){//两个一次函数交点坐标
	if(f1.k < f2.k || f1.k == f2.k && f1.b < f2.b)
		swap(f1,f2);
	if(f1.b >= f2.b)
		return INF;
	return (f2.b - f1.b + f1.k - f2.k - 1) / (f1.k - f2.k);
}
struct node{
	linear_func sum,val;//区间和、区间最大子段和 
	linear_func lsum,rsum;//前缀最大和、后缀最大和 
	int x;//区间加超过了 x 就要重构子树
};
node operator+(node lc,node rc){//合并两个节点的信息
	node ret;
	ret.x = min(lc.x,rc.x);
	ret.x = min(ret.x,intersection(lc.val,rc.val));
	ret.x = min(ret.x,intersection(Max(lc.val,rc.val),lc.rsum + rc.lsum));
	ret.x = min(ret.x,intersection(lc.lsum,lc.sum + rc.lsum));
	ret.x = min(ret.x,intersection(rc.rsum,rc.sum + lc.rsum));

  //这部分和单点修改 + 区间最大子段和是一样的，只是额外维护了一个最优决策的长度k。
	ret.sum = lc.sum + rc.sum;
	ret.val = Max(Max(lc.val,rc.val),lc.rsum + rc.lsum);
	ret.lsum = Max(lc.lsum,lc.sum + rc.lsum);
	ret.rsum = Max(rc.rsum,rc.sum + lc.rsum);
	
	return ret;
}
struct KTT{
	struct ktt_node{
		node u;
		int tag;
	} t[N << 2];
	bool in_range(int l,int r,int L,int R){
		return L <= l && r <= R;
	}
	bool out_range(int l,int r,int L,int R){
		return r < L || l > R;
	}
	void push_up(int root){
		t[root].u = t[lchild].u + t[rchild].u;
	}
	void make_tag(int root,int v){
		t[root].tag += v;
		t[root].u.x -= v;
		t[root].u.sum.add(v);
		t[root].u.val.add(v);
		t[root].u.lsum.add(v);
		t[root].u.rsum.add(v);
	}
	void push_down(int root){
		if(t[root].tag){
			make_tag(lchild,t[root].tag);
			make_tag(rchild,t[root].tag);
			t[root].tag = 0;
		}
	}
	void defeat(int root,int l,int r,int v){//将以root为根的子树暴力重构
		if(v > t[root].u.x){//区间的决策发生了变化，暴力重构
			int tmp = t[root].tag + v;//注意要把标记一起传下去，v包括了root节点祖先的标记
			t[root].tag = 0;
			defeat(lchild,l,mid,tmp);
			defeat(rchild,mid + 1,r,tmp);
			push_up(root);
		}
		else//否则可以直接更新区间信息，打标记即可
			make_tag(root,v);
	}
	void build(int root,int l,int r){
		if(l == r){
			linear_func tmp = (linear_func){1,a[l]};//叶节点的区间长度为1，所以k就只能为1了（不用考虑叶节点不选的情况，如果出现了负数在 cout 处有取 max 操作可以忽略）
			t[root].u = (node){tmp,tmp,tmp,tmp,INF};
			return;
		}
		build(lchild,l,mid);
		build(rchild,mid + 1,r);
		push_up(root);
	}
	void update(int root,int l,int r,int L,int R,int v){
		if(out_range(l,r,L,R))
			return;
		if(in_range(l,r,L,R)){
			defeat(root,l,r,v);
			return;
		}
		push_down(root);
		update(lchild,l,mid,L,R,v);
		update(rchild,mid + 1,r,L,R,v);
		push_up(root);
	}
	node query(int root,int l,int r,int L,int R){
		if(in_range(l,r,L,R))
			return t[root].u;
		push_down(root);
		if(R <= mid)
			return query(lchild,l,mid,L,R);
		if(L > mid)
			return query(rchild,mid + 1,r,L,R);
		return query(lchild,l,mid,L,R) + query(rchild,mid + 1,r,L,R);
	}
} ktt;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i++)
		cin >> a[i];
	ktt.build(1,1,n);
	while(m--){
		int op;
		cin >> op;
		if(op == 1){
			int l,r,v;
			cin >> l >> r >> v;
			ktt.update(1,1,n,l,r,v);
		}
		else if(op == 2){
			int l,r;
			cin >> l >> r;
			cout << max(ktt.query(1,1,n,l,r).val.b,0ll) << '\n';
		}
	}
	return 0;
}
```

---

## 作者：wjl1100 (赞：7)

## [原题传送门](https://www.luogu.com.cn/problem/P5693)

## 思路

### 前置芝士：

#### KTT（附 [2020 年国家集训队论文](https://rusunoi.github.io/books/National-Team-Thesis/2020.pdf)）

KTT 是李白天在 2020 年国家集训队论文写的一篇文章中的部分内容，文章名称为《浅谈函数最值的动态维护》，以下内容为我在学习 KTT 中的一些理解，若有误请指出。

首先我们可知用线段树求最大子段和需要维护最大前缀和 $lmax$，最大后缀和 $rmax$，最大子段和 $maxn$ 和区间和 $sum$ 四个变量。

公式为（用 $l$ 表示左儿子，$r$ 表示右儿子）：

```cpp
sum=l.sum+r.sum
lmax=max(l.lmax,l.sum+r.lmax)
rmax=max(r.rmax,r.sum+l.rmax)
maxn=max(l.maxn,r.maxn,l.rmax+r.lmax)
```

首先如果最长子段和的区间不变，那么最长字段和每次更新就会增加区间长乘上 $x$，但是由于区间里会有负数，在增加到某一时刻时会变为正数，增大区间长，所以此时线段树的每个节点存的就不再是值而是一个一次函数 $y=k \times x+b$ 其中 $k$ 为斜率，$x$ 就是加的 $x$，$b$ 就是初始值，在代码中我们只需记 $k$ 和 $y$ 就行。

然后我们需要引入 KTT 中最重要的变量：$intr$ 交替阈值。

画一个图理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/64fufmbz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

其中红线与蓝线汇交与一点，也就是 $intr$。当 $x$ 大于 $intr$ 时最大值位于蓝线，否则为红线。

当然也会出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/yyexljvj.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时红线与蓝线并无交点，可将 $intr$ 设为正无穷，表示永不会交替。

现在我们来讨论如何维护 $intr$，因为我们要维护四个参数，所以 $intr$ 要取四种更新的最小值，如果 $intr$ 的值小于零后就表明有至少一个值需要进行更新，所以我们可以~~很轻松~~得出这份代码：

```cpp
        node c;
		pair<line , int> tmp;
		c.intr = min(a.intr , b.intr);
		tmp = maxx(a.lmax , a.sum + b.lmax);
		c.lmax = tmp.first;
		c.intr = min(c.intr , tmp.second);
		tmp = maxx(b.rmax , b.sum + a.rmax);
		c.rmax = tmp.first;
		c.intr = min(c.intr , tmp.second);
		tmp = maxx(a.maxn , b.maxn);
		c.intr = min(c.intr , tmp.second);
		tmp = maxx(a.rmax + b.lmax , tmp.first);
		c.maxn = tmp.first;
		c.intr = min(c.intr , tmp.second);
		c.sum = a.sum + b.sum;
		return c;
```

其中 $c$ 为父节点，$a$ 为左儿子，$b$ 为右儿子，$maxx$ 为求当前最大值所在直线和交点，这样我们就可从儿子推出父亲（注意：这段代码我们可以写在重载运算符中来简化代码）。

然后我们来考虑更新，因为横坐标加 $x$ 就相当于 $intr$ 减去 $x$，所以我们在 $add$ 函数中就直接将 $intr$ 减去即可，如果此时 $intr$ 小于零，就意味着有更优的值，我们只需向下递归，找到第一个 $intr$ 大于等于零的子节点即可，然后向上 $up$ 即可，这个操作我们可称之为 $rebuild$。

以下是 $add$ 和 $rebuild$ 的代码：

```cpp
	inline void push(int id , int val) {
		lazy[id] += val;
		tr[id].intr -= val;
		tr[id].lmax.b += tr[id].lmax.a * val;
		tr[id].rmax.b += tr[id].rmax.a * val;
		tr[id].maxn.b += tr[id].maxn.a * val;
		tr[id].sum.b += tr[id].sum.a * val;
		return ;
	}


	inline void add(int id , int l , int r , int ql , int qr , int val) {
		if(l >= ql && r <= qr) {
			push(id , val);
			rebuild(id);
			return ;
		}
		down(id);
		int mid = (l + r) >> 1;
		if(ql <= mid) add(id << 1 , l , mid , ql , qr , val);
		if(qr > mid) add(id << 1 | 1 , mid + 1 , r , ql , qr , val);
		up(id);
		return ;
	}


	inline void rebuild(int id) {
		if(tr[id].intr >= 0) return ;
		down(id);
		rebuild(id << 1);
		rebuild(id << 1 | 1);
		up(id);
		return ;
	}


```

（为了图方便，把 $push$ 函数单独拎了出来，这样可以给其他函数共同使用。）

接着是 $build$ 函数，注意子节点的 $intr$ 为正无穷，因为就一条线，没有其他的线与它竞争，故没有交替点。

$build$ 函数：

```cpp
	inline void build(int id , int l , int r) {
		lazy[id] = 0;
		if(l == r) {
			tr[id].lmax = tr[id].rmax = tr[id].maxn = tr[id].sum = {1 , aa[l]};
			tr[id].intr = inf;
			return ;
		}
		int mid = (l + r) >> 1;
		build(id << 1 , l , mid);
		build(id << 1 | 1 , mid + 1 , r);
		up(id);
		return ;
	}
```

最后还剩下一个 $query$ 查询函数了，与普通的线段树差不多，记得多 $up$ 和 $down$。

$query$ 函数：

```cpp
	inline node query(int id , int l , int r , int ql , int qr) {
		if(l >= ql && r <= qr) return tr[id];
		down(id);
		int mid = (l + r) >> 1;
		node ans;
		ans.init();
		if(ql <= mid) ans = ans + query(id << 1 , l , mid , ql , qr);
		if(qr > mid) ans = ans + query(id << 1 | 1 , mid + 1 , r , ql , qr);
		return ans;
	}
```

至于时间复杂度，极限是 $O((n+m)\log^3n)$，但一般达不到，大家当成 $O((n+m)\log^2n)$，最后就是大家喜闻乐见的全部代码了，如果还有不懂的可以翻阅一下代码。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x = 0 , f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9' ) {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar();}
	return x * f;
}
inline void write(int x) {
	if(x < 0) x = ~(x - 1) , putchar('-');
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
inline void writeh(int x) {
	write(x);
	putchar('\n');
}
inline void writek(int x) {
	write(x);
	putchar(' ');
}
int n , q , aa[maxn] , opt;
struct line {
	int a , b;//a为斜率，b为y=kx+b中的y
	friend line operator +(line a1 , line b1) {
		return {a1.a + b1.a , a1.b + b1.b};
	}
};
inline pair<line , int> maxx(line a , line b) {
	if(a.a < b.a || (a.a == b.a && a.b < b.b)) swap(a , b);
	if(a.b >= b.b) return make_pair(a , inf);
	return make_pair(b , (b.b - a.b) / (a.a - b.a));
}//取更大的直线
struct node {
	line lmax , rmax , maxn , sum;
	int intr;
	void init() {
		lmax = rmax = maxn = sum = {0 , 0};
		intr = inf;
	}
	friend node operator +(node a , node b) {
		node c;
		pair<line , int> tmp;
		c.intr = min(a.intr , b.intr);
		tmp = maxx(a.lmax , a.sum + b.lmax);
		c.lmax = tmp.first;
		c.intr = min(c.intr , tmp.second);
		tmp = maxx(b.rmax , b.sum + a.rmax);
		c.rmax = tmp.first;
		c.intr = min(c.intr , tmp.second);
		tmp = maxx(a.maxn , b.maxn);
		c.intr = min(c.intr , tmp.second);
		tmp = maxx(a.rmax + b.lmax , tmp.first);
		c.maxn = tmp.first;
		c.intr = min(c.intr , tmp.second);
		c.sum = a.sum + b.sum;
		return c;
	}
};
struct KTT {
	node tr[maxn << 2];
	int lazy[maxn << 2];
	inline void up(int id) {
		tr[id] = tr[id << 1] + tr[id << 1 | 1];
		return ;
	}
	inline void push(int id , int val) {
		lazy[id] += val;
		tr[id].intr -= val;
		tr[id].lmax.b += tr[id].lmax.a * val;
		tr[id].rmax.b += tr[id].rmax.a * val;
		tr[id].maxn.b += tr[id].maxn.a * val;
		tr[id].sum.b += tr[id].sum.a * val;
		return ;
	}
	inline void down(int id) {
		if(lazy[id]) {
			push(id << 1 , lazy[id]);
			push(id << 1 | 1 , lazy[id]);
			lazy[id] = 0;
		}
		return ;
	}
	inline void build(int id , int l , int r) {
		lazy[id] = 0;
		if(l == r) {
			tr[id].lmax = tr[id].rmax = tr[id].maxn = tr[id].sum = {1 , aa[l]};
			tr[id].intr = inf;
			return ;
		}
		int mid = (l + r) >> 1;
		build(id << 1 , l , mid);
		build(id << 1 | 1 , mid + 1 , r);
		up(id);
		return ;
	}
	inline void rebuild(int id) {
		if(tr[id].intr >= 0) return ;
		down(id);
		rebuild(id << 1);
		rebuild(id << 1 | 1);
		up(id);
		return ;
	}
	inline void add(int id , int l , int r , int ql , int qr , int val) {
		if(l >= ql && r <= qr) {
			push(id , val);
			rebuild(id);
			return ;
		}
		down(id);
		int mid = (l + r) >> 1;
		if(ql <= mid) add(id << 1 , l , mid , ql , qr , val);
		if(qr > mid) add(id << 1 | 1 , mid + 1 , r , ql , qr , val);
		up(id);
		return ;
	}
	inline node query(int id , int l , int r , int ql , int qr) {
		if(l >= ql && r <= qr) return tr[id];
		down(id);
		int mid = (l + r) >> 1;
		node ans;
		ans.init();
		if(ql <= mid) ans = ans + query(id << 1 , l , mid , ql , qr);
		if(qr > mid) ans = ans + query(id << 1 | 1 , mid + 1 , r , ql , qr);
		return ans;
	}
}tree;
signed main(){
	cin >> n >> q;
	for(int i = 1; i <= n; i++) aa[i] = read();
	tree.build(1 , 1 , n);
	int l , r , x;
	for(int i = 1; i <= q; i++) {
		cin >> opt >> l >> r;
		if(opt == 1) {
			cin >> x;
			tree.add(1 , 1 , n , l , r , x);
		}else writeh(max(0ll , tree.query(1 , 1 , n , l , r).maxn.b));
	}
	return !("wjl1100 qwq");
}
```

### 小结：

不知不觉已经写了这么多了，顺便提一句，我竟是这道题的第 1000 次通过。

---

## 作者：YZren (赞：6)

# [EI 的第六分块](https://www.luogu.com.cn/problem/P5693)

## 题目大意

给定一个长度为 $n$ 的整数序列，支持两种操作：
1. 区间加一个正数
2. 查询区间最大子段和（可以为空）

## 解题思路

本题需要使用一种称为 **KTT（Kinetic Tournament Tree）** 的数据结构来解决。KTT 是线段树的一种变体，能够高效处理区间加正数和区间查询问题。

### KTT 的核心思想

KTT 维护的每个节点包含一个一次函数 $y = k \times val + b$，其中：
- $k$ 是斜率
- $b$ 是截距
- $val$ 是当前节点的值

每次区间加操作相当于对 $b$ 进行修改：$b = b + k \times val$。

### 维护的信息

每个节点需要维护以下信息：
1. `sum`：区间和
2. `lmax`：从左端点开始的最大子段和
3. `rmax`：从右端点开始的最大子段和
4. `max`：区间最大子段和
5. `limit`：一个阈值，用于判断何时需要更新最大值

### 合并区间

合并两个子区间时，需要注意顺序，并正确计算各个值：
1. `lmax`：取左子区间的 `lmax` 或左子区间的 `sum` 加上右子区间的 `lmax` 中的较大值
2. `rmax`：取右子区间的 `rmax` 或右子区间的 `sum` 加上左子区间的 `rmax` 中的较大值
3. `max`：取左子区间的 `max`、右子区间的 `max` 或左子区间的 `rmax` 加上右子区间的 `lmax` 中的最大值
4. `sum`：左右子区间 `sum` 的和

#### Code


```cpp
node operator +(const node &a){
		node ans; ans.limit=std::min(limit,a.limit);
		std::pair<line,int> tmp=getmax(lmax,sum+a.lmax);
		ans.lmax=tmp.first;
		ans.limit=std::min(ans.limit,tmp.second);
		tmp=getmax(a.rmax,rmax+a.sum);
		ans.rmax=tmp.first;
		ans.limit=std::min(ans.limit,tmp.second);
		tmp=getmax(max,a.max);
		ans.limit=std::min(ans.limit,tmp.second);
		tmp=getmax(tmp.first,rmax+a.lmax);
		ans.max=tmp.first;
		ans.limit=std::min(ans.limit,tmp.second);
		ans.sum=sum+a.sum;
		return ans;
		
	}
```


### 维护 `limit`

`limit` 表示需要更新最大值的最小 `val` 增量。在合并区间时，需要计算所有可能的一次函数交点，并取其中的最小值作为新的 `limit`。

1. 第一种情况（交点是正数，所以 limit 可以更新）。
![](https://cdn.luogu.com.cn/upload/image_hosting/wo432k1e.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2. 第二种情况（两条直线平行没有交点（交点是负数也一样），返回正无穷让其不更新）。
![](https://cdn.luogu.com.cn/upload/image_hosting/dz5ahar2.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

取这个交点就很简单了（注意还要返回先交替的直线，也就是下面那一条）。

#### Code

```cpp
std::pair<line,int> getmax(line n1,line n2){
	if(n1<n2) std::swap(n1,n2);
	if(n1.b>=n2.b) return std::make_pair(n1,LLONG_MAX);
	return std::make_pair(n2,(n1.b-n2.b)/(n2.k-n1.k));
}
```

### 区间更新

和普通的线段树的过程差不多。

1. 先看标记下传的实现。

#### Code

```cpp
struct line{
	int k,b;
	line operator +(const line &a){return (line){k+a.k,b+a.b};}
	void operator +=(const int &a){b+=k*a;}
	bool operator <(const line &a){return (k<a.k||(k==a.k&&b<a.b));}
};

struct node{
	line sum,lmax,rmax,max;
	int limit;
	void operator +=(const int &a){sum+=a;lmax+=a;rmax+=a;max+=a;}
} tree[maxn<<2];


inline void update(int rt,int w){lazy[rt]+=w;tree[rt].limit-=w;tree[rt]+=w;}


inline void pushdown(int rt){
	update(rt<<1,lazy[rt]); update(rt<<1|1,lazy[rt]);
	lazy[rt]=0;
}
```

2. 接着是整块更新（注意当 limit 不为正时，要进行交替，将懒标记下传给子树，判断其是否需要交替）。

#### Code


```cpp
inline void update(int rt,int w){lazy[rt]+=w;tree[rt].limit-=w;tree[rt]+=w;}
inline void Update(int rt,int w){
	if(w>tree[rt].limit){
		update(rt,w);
		Update(rt<<1,lazy[rt]); Update(rt<<1|1,lazy[rt]);
		tree[rt]=tree[rt<<1]+tree[rt<<1|1];
		lazy[rt]=0;
	}
	else update(rt,w);
}
inline void revise(int rt,int l,int r,int L,int R,int w){
	if(l>R||r<L) return ;
	if(l>=L&&r<=R){Update(rt,w);return ;}
	if(lazy[rt]) pushdown(rt);
	int mid=(l+r)>>1;
	revise(rt<<1,l,mid,L,R,w); revise(rt<<1|1,mid+1,r,L,R,w);
	tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}
```

### 查询操作

类似于普通线段树的写法（要注意合并顺序先左后右）。

#### Code


```cpp
inline node query(int rt,int l,int r,int L,int R){
	if(l>=L&&r<=R) return tree[rt];
	if(lazy[rt]) pushdown(rt);
	int mid=(l+r)>>1;
	node a;	a.init();
	if(L<=mid) a=a+query(rt<<1,l,mid,L,R);
	if(R>mid) a=a+query(rt<<1|1,mid+1,r,L,R);
	return a;
}
```


### 时间复杂度

有点菜证不来，大概是 $O((n+m)\log^3n)$。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
const int maxn=1e6+10;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
inline void write(int x){
    if(x<0) {x=~(x-1); putchar('-');}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int n=read(),m=read(),val[maxn],lazy[maxn];
struct line{
    int k,b;
    line operator +(const line &a){return (line){k+a.k,b+a.b};}
    void operator +=(const int &a){b+=k*a;}
    bool operator <(const line &a){return (k<a.k||(k==a.k&&b<a.b));}
};
std::pair<line,int> getmax(line n1,line n2){
    if(n1<n2) std::swap(n1,n2);
    if(n1.b>=n2.b) return std::make_pair(n1,LLONG_MAX);
    return std::make_pair(n2,(n1.b-n2.b)/(n2.k-n1.k));
}
struct node{
    line sum,lmax,rmax,max;
    int limit;
    inline void init(){
        lmax=rmax=max=sum={0,0};
        limit=LLONG_MAX;
    }
    node operator +(const node &a){
        node ans; ans.limit=std::min(limit,a.limit);
        std::pair<line,int> tmp=getmax(lmax,sum+a.lmax);
        ans.lmax=tmp.first;
        ans.limit=std::min(ans.limit,tmp.second);
        tmp=getmax(a.rmax,rmax+a.sum);
        ans.rmax=tmp.first;
        ans.limit=std::min(ans.limit,tmp.second);
        tmp=getmax(max,a.max);
        ans.limit=std::min(ans.limit,tmp.second);
        tmp=getmax(tmp.first,rmax+a.lmax);
        ans.max=tmp.first;
        ans.limit=std::min(ans.limit,tmp.second);
        ans.sum=sum+a.sum;
        return ans;
        
    }
    void operator +=(const int &a){sum+=a;lmax+=a;rmax+=a;max+=a;}
} tree[maxn<<2];
inline void build(int rt,int l,int r){
    if(l==r){
        line w={1,val[l]};
        tree[rt]={w,w,w,w,LLONG_MAX};
        return ;
    }
    int mid=(l+r)>>1;
    build(rt<<1,l,mid); build(rt<<1|1,mid+1,r);
    tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}
inline void update(int rt,int w){lazy[rt]+=w;tree[rt].limit-=w;tree[rt]+=w;}
inline void Update(int rt,int w){
    if(w>tree[rt].limit){
        update(rt,w);
        Update(rt<<1,lazy[rt]); Update(rt<<1|1,lazy[rt]);
        tree[rt]=tree[rt<<1]+tree[rt<<1|1];
        lazy[rt]=0;
    }
    else update(rt,w);
}
inline void pushdown(int rt){
    update(rt<<1,lazy[rt]); update(rt<<1|1,lazy[rt]);
    lazy[rt]=0;
}
inline void revise(int rt,int l,int r,int L,int R,int w){
    if(l>R||r<L) return ;
    if(l>=L&&r<=R){Update(rt,w);return ;}
    if(lazy[rt]) pushdown(rt);
    int mid=(l+r)>>1;
    revise(rt<<1,l,mid,L,R,w); revise(rt<<1|1,mid+1,r,L,R,w);
    tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}
inline node query(int rt,int l,int r,int L,int R){
    if(l>=L&&r<=R) return tree[rt];
    if(lazy[rt]) pushdown(rt);
    int mid=(l+r)>>1;
    node a;    a.init();
    if(L<=mid) a=a+query(rt<<1,l,mid,L,R);
    if(R>mid) a=a+query(rt<<1|1,mid+1,r,L,R);
    return a;
}
inline void work(){
    f(i,1,n) val[i]=read();
    build(1,1,n);
    while(m--){
        int opt=read(),l=read(),r=read(),x;
        if(opt==1) x=read(),revise(1,1,n,l,r,x);
        else write(std::max(0LL,query(1,1,n,l,r).max.b)),puts("");
    }
}
signed main(){work();return !!!!!("YZren");}
```

## 中文代码

```cpp
#include<bits/stdc++.h>
#define 长整型 long long
#define 求最大值 max
#define 求最小值 min
#define 倘若 if
#define 否则 else 
#define 重载运算符 operator
#define 结构体 struct
#define 无返回值型 void
#define 布尔型 bool
#define 双返回值型 pair
#define 循环(i,j,k) for(长整型 i=j;i<=k;i++)
#define 反向循环(i,j,k) for(长整型 i=j;i>=k;i--)
#define 返回 return 
#define 常数 const
#define 声明 inline
#define 函数库 std
#define 当循环 while
#define 字符类型 char
#define 读入字符 getchar
#define 输出字符 putchar
#define 换行输出 puts
#define 主函数 main
#define 修饰整数型 signed
#define 第一个 first
#define 第二个 second
常数 长整型 最大数量=1e6+10,正无穷=1e18;
声明 长整型 读取(){
	长整型 x=0,f=1;字符类型 字符=读入字符();
	当循环(字符<'0'||字符>'9'){倘若(字符=='-')f=-1;字符=读入字符();}
	当循环(字符>='0'&&字符<='9'){x=x*10+字符-48;字符=读入字符();}
	返回 x*f;
}
声明 无返回值型 写入(长整型 x){
	倘若(x<0){x=~(x-1);输出字符('-');}
	倘若(x>9)写入(x/10);
	输出字符(x%10+'0');
}
长整型 点数=读取(),操作数=读取(),数值[最大数量],懒标记[最大数量];
结构体 线段{
	长整型 斜率,截距;
	线段 重载运算符+(常数 线段 &a){返回 {斜率+a.斜率,截距+a.截距};}
	无返回值型 重载运算符+=(常数 长整型 &a){截距+=斜率*a;}
	布尔型 重载运算符<(常数 线段 &a){返回(斜率<a.斜率||(斜率==a.斜率&&截距<a.截距));}
};
函数库::双返回值型<线段,长整型> 获取最大值(线段 线1,线段 线2){
	倘若(线1<线2)函数库::swap(线1,线2);
	倘若(线1.截距>=线2.截距)返回 函数库::make_pair(线1,正无穷);
	返回 函数库::make_pair(线2,(线1.截距-线2.截距)/(线2.斜率-线1.斜率));
}
结构体 节点{
	线段 总和,左最大,右最大,最大值;
	长整型 限制;
	声明 无返回值型 初始化(){
		左最大=右最大=最大值=总和={0,0};
		限制=正无穷;
	}
	节点 重载运算符+(常数 节点 &a){
		节点 结果;
		结果.限制=函数库::求最小值(限制,a.限制);
		函数库::双返回值型<线段,长整型> 临时=获取最大值(左最大,总和+a.左最大);
		结果.左最大=临时.第一个;
		结果.限制=函数库::求最小值(结果.限制,临时.第二个);
		临时=获取最大值(a.右最大,右最大+a.总和);
		结果.右最大=临时.第一个;
		结果.限制=函数库::求最小值(结果.限制,临时.第二个);
		临时=获取最大值(最大值,a.最大值);
		结果.限制=函数库::求最小值(结果.限制,临时.第二个);
		临时=获取最大值(临时.第一个,右最大+a.左最大);
		结果.最大值=临时.第一个;
		结果.限制=函数库::求最小值(结果.限制,临时.第二个);
		结果.总和=总和+a.总和;
		返回 结果;
	}
	无返回值型 重载运算符+=(常数 长整型 &a){
		总和+=a;
		左最大+=a;
		右最大+=a;
		最大值+=a;
	}
}线段树[最大数量<<2];
声明 无返回值型 构建(长整型 当前节点,长整型 左,长整型 右){
	倘若(左==右){
		线段 初始值={1,数值[左]};
		线段树[当前节点]={初始值,初始值,初始值,初始值,正无穷};
		返回;
	}
	长整型 中点=(左+右)>>1;
	构建(当前节点<<1,左,中点);
	构建(当前节点<<1|1,中点+1,右);
	线段树[当前节点]=线段树[当前节点<<1]+线段树[当前节点<<1|1];
}
声明 无返回值型 更新节点(长整型 当前节点,长整型 值){
	懒标记[当前节点]+=值;
	线段树[当前节点].限制-=值;
	线段树[当前节点]+=值;
}
声明 无返回值型 区间更新(长整型 当前节点,长整型 值){
	倘若(值>线段树[当前节点].限制){
		更新节点(当前节点,值);
		区间更新(当前节点<<1,懒标记[当前节点]);
		区间更新(当前节点<<1|1,懒标记[当前节点]);
		线段树[当前节点]=线段树[当前节点<<1]+线段树[当前节点<<1|1];
		懒标记[当前节点]=0;
	}
	否则 更新节点(当前节点,值);
}
声明 无返回值型 下推懒标记(长整型 当前节点){
	更新节点(当前节点<<1,懒标记[当前节点]);
	更新节点(当前节点<<1|1,懒标记[当前节点]);
	懒标记[当前节点]=0;
}
声明 无返回值型 修改区间(长整型 当前节点,长整型 左,长整型 右,长整型 目标左,长整型 目标右,长整型 值){
	倘若(左>目标右||右<目标左)返回;
	倘若(左>=目标左&&右<=目标右){
		区间更新(当前节点,值);
		返回;
	}
	倘若(懒标记[当前节点])下推懒标记(当前节点);
	长整型 中点=(左+右)>>1;
	修改区间(当前节点<<1,左,中点,目标左,目标右,值);
	修改区间(当前节点<<1|1,中点+1,右,目标左,目标右,值);
	线段树[当前节点]=线段树[当前节点<<1]+线段树[当前节点<<1|1];
}
声明 节点 查询区间(长整型 当前节点,长整型 左,长整型 右,长整型 目标左,长整型 目标右){
	倘若(左>=目标左&&右<=目标右)返回 线段树[当前节点];
	倘若(懒标记[当前节点])下推懒标记(当前节点);
	长整型 中点=(左+右)>>1;
	节点 结果;结果.初始化();
	倘若(目标左<=中点)结果=结果+查询区间(当前节点<<1,左,中点,目标左,目标右);
	倘若(目标右>中点)结果=结果+查询区间(当前节点<<1|1,中点+1,右,目标左,目标右);
	返回 结果;
}
声明 无返回值型 主程序(){
	循环(i,1,点数)数值[i]=读取();
	构建(1,1,点数);
	当循环(操作数--){
		长整型 操作类型=读取(),左=读取(),右=读取(),值;
		倘若(操作类型==1){
			值=读取();
			修改区间(1,1,点数,左,右,值);
		}
		否则{
			写入(函数库::求最大值(0LL,查询区间(1,1,点数,左,右).最大值.截距));
			换行输出("");
		}
	}
}
修饰整数型 主函数(){主程序();返回 !!!!!("YZren");}
```

---

## 作者：apple_vinegar (赞：6)

联考上用到了 KTT 这种科技，记录一下。  
12.8 update: 减少了很多无用内容，请求通过。

## 介绍

KTT 是李白天所写的[浅谈函数最值的动态维护](https://rusunoi.github.io/books/National-Team-Thesis/2020.pdf)中的部分内容，其中对复杂度，细节等进行了严谨证明。我在此处以本蒟蒻的理解叙述，若有不足麻烦联系。

## 应用

与线段树不同，若我们需解决一段形若 $ax+b$ 的式子，每次修改区间的 $a$ 值或 $b$ 值应该怎么处理呢。考虑到维护区间和是简单的，那么我们假设解决如下问题。

- 1. 将区间 $[L,R]$ 中每个数加上 $x$，保证 $x>0$。
- 2. 查询区间 $[L,R]$ 的最大值。

## 思路

比起普通的线段树，我们发现在改变了区间值时可能会使区间内最大值变化，导致懒标记难以记录。\
于是我们此时可以设立一个区间阈值 $c$ 表示两个 $ax+b$ 的图像的交点，即仅当经过此交点时需更新最大值。\
因为对于线段树上每个区间范围大于其子树，故其阈值（此处看作“受限范围” 可能更好理解）也不大于其子树，所以我们只需要在某个线段树节点达到阈值时重构其子树即可。重构代码如下：

```cpp
inline void rebuild(int p){
    if(d[p].c>=0) return;//需要更替，即超过阈值时需要重构其子树
    pushdown(p);
    rebuild(ls);
    rebuild(rs);
    up(p);
    return ;
}
```

## 转化

这道题是求的区间最大子段和，如何由上述问题转化而来呢？我们不难想到，区间最大子段和可以由合并得到，存储信息如下：

- $lmx$：最大前缀和
- $rmx$：最大后缀和
- $totmx$：最大子段和
- $len$：区间长

合并方式如下：

- $lmx= \max (ls.lmx,ls.len+rs.lmx)$
- $rmx= \max (rs.rmx,rs.len+ls.rmx)$
- $totmx= \max ({ls.totmx,rs.totmx,ls.rmx+rs.lmx})$
- $len=ls.len+rs.len$

至此，我们已经完成了由最基本的线段树到此题的思路转换，只需注意合并细节即可。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid ((l+((r-l)>>1)))
#define ls (p<<1)
#define rs (ls|1)
#define lt ls,l,mid
#define rt rs,mid+1,r
#define fi first
#define se second
using namespace std;
const int N=5e6+5,MX=1e18;

inline int read(){
    int a=1,b=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') a=-a;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        b=(b<<1)+(b<<3)+(ch^48);
        ch=getchar();
    }
    return a*b;
}

struct line{
    int a,b;//即kkt最基本的处理方式，表示成ax+b;
    friend line operator +(line a,line b){
        return {a.a+b.a,a.b+b.b};//重载+，合并两个函数
    }
};

struct node{
    line lmx,rmx,totmx,len;//lmx:最大前缀和 rmx:最大后缀和 totmx：最大区间和，即答案 len：区间长度
    int c;//阈值，决定什么时候需要重构子树
};

node d[N<<2];
int tag[N<<2],a[N];

inline pair<line,int> inter(line a,line b){
    if(a.a<b.a||(a.a==b.a&&a.b<b.b)) swap(a,b);//不同与普通的KTT,我们此处需要前缀与后缀，所以不仅需要反馈数值，还需反馈先后顺序
    if(a.b>=b.b) return (make_pair(a,MX));//无交
    return (make_pair(b,(b.b-a.b)/(a.a-b.a)));//交点的x
}

inline node add(node a,node b){
    pair<line,int> tmp;
    node res;
    res.c=min(a.c,b.c);
    tmp=inter(a.lmx,a.len+b.lmx);
    res.lmx=tmp.fi;   //res.lmx=max(a.lmx,a.len+b.lmx)
    res.c=min(res.c,tmp.se);
    tmp=inter(b.rmx,b.len+a.rmx);
    res.rmx=tmp.fi;   //res.rmx=max(b.rmx,b.len+a.rmx)
    res.c=min(res.c,tmp.se);
    tmp=inter(a.totmx,b.totmx);
    res.c=min(res.c,tmp.se);
    tmp=inter(tmp.fi,a.rmx+b.lmx);
    res.totmx=(tmp.fi);   //res.totmx=max({a.totmx,b.totmx,a.rmx+b.lmx})
    res.c=min(res.c,tmp.se);
    res.len=a.len+b.len;   //res.len=a.len+b.len
    return res;
}

inline void up(int p){
    d[p]=add(d[ls],d[rs]);
}

inline void build(int p,int l,int r){
    if(l==r){
        d[p].lmx=d[p].rmx=d[p].totmx=d[p].len={1,a[l]};//初始化最大子段和为自身，长度为1
        d[p].c=MX;//初始阈值设为极大值
        return;
    }
    build(lt),build(rt);
    up(p);
    return ;
}

inline void push(int p,int k){//不用考虑a的变化，可以化为b变化a*x
    tag[p]+=k;
    d[p].c-=k;
    d[p].lmx.b  +=d[p].lmx.a*k;
    d[p].rmx.b  +=d[p].rmx.a*k;
    d[p].totmx.b+=d[p].totmx.a*k;
    d[p].len.b  +=d[p].len.a*k;
    
    return ;
}

inline void pushdown(int p){
    push(ls,tag[p]),push(rs,tag[p]);
    tag[p]=0;
}

inline void rebuild(int p){
    if(d[p].c>=0) return;//需要更替，即超过阈值时需要重构其子树
    pushdown(p);
    rebuild(ls);
    rebuild(rs);
    up(p);
    return ;
}

inline void update(int p,int l,int r,int x,int y,int k){
    if(x<=l&&r<=y){
        push(p,k);
        rebuild(p);
        return;
    }
    pushdown(p);
    if(x<=mid) update(lt,x,y,k);
    if(y>mid) update(rt,x,y,k);
    up(p);
    return ;
}

inline node query(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y){
        return d[p];
    }
    pushdown(p);
    if(y<=mid) return query(lt,x,y);
    if(x>mid) return query(rt,x,y);
    return add(query(lt,x,y),query(rt,x,y));
}

signed main(){
    int n=read(),q=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
    }
    build(1,1,n);
    while(q--){
        int op=read();
        if(op==1){
            int l=read(),r=read(),k=read();
            update(1,1,n,l,r,k);
        }
        else{
            int l=read(),r=read();
            if(l>r) printf("0 \n");
            printf("%lld\n",max(0ll,query(1,1,n,l,r).totmx.b));
        }
    }
    return 0;
}
```

后记：没用结构体封装被机房大佬骂了。

做了[CF1178G](https://www.luogu.com.cn/problem/CF1178G)，发现 rebuild 的过程其实就是继续递归，并且若需修改，需要 pushdown 。根据我们之前发现的规律，一个子树若无需修改，其子树受限范围小于它，也无需修改，所以我们完全可以在 update 添加一个条件实现递归以减小码量。

代码如下：


```cpp
#include<bits/stdc++.h>
#define int long long
#define mid ((l+((r-l)>>1)))
#define ls (p<<1)
#define rs (ls|1)
#define lt ls,l,mid
#define rt rs,mid+1,r
#define fi first
#define se second
using namespace std;
const int N=5e6+5,MX=1e18;

inline int read(){
    int a=1,b=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') a=-a;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        b=(b<<1)+(b<<3)+(ch^48);
        ch=getchar();
    }
    return a*b;
}

struct line{
    int a,b;//即kkt最基本的处理方式，表示成ax+b;
    friend line operator +(line a,line b){
        return {a.a+b.a,a.b+b.b};//重载+，合并两个函数
    }
};

struct node{
    line lmx,rmx,totmx,len;//lmx:最大前缀和 rmx:最大后缀和 totmx：最大区间和，即答案 len：区间长度
    int c;//阈值，决定什么时候需要重构子树
};

node d[N<<2];
int tag[N<<2],a[N];

inline pair<line,int> inter(line a,line b){
    if(a.a<b.a||(a.a==b.a&&a.b<b.b)) swap(a,b);//不同与普通的KTT,我们此处需要前缀与后缀，所以不仅需要反馈数值，还需反馈先后顺序
    if(a.b>=b.b) return (make_pair(a,MX));//无交
    return (make_pair(b,(b.b-a.b)/(a.a-b.a)));//交点的x
}

inline node add(node a,node b){
    pair<line,int> tmp;
    node res;
    res.c=min(a.c,b.c);
    tmp=inter(a.lmx,a.len+b.lmx);
    res.lmx=tmp.fi;   //res.lmx=max(a.lmx,a.len+b.lmx)
    res.c=min(res.c,tmp.se);
    tmp=inter(b.rmx,b.len+a.rmx);
    res.rmx=tmp.fi;   //res.rmx=max(b.rmx,b.len+a.rmx)
    res.c=min(res.c,tmp.se);
    tmp=inter(a.totmx,b.totmx);
    res.c=min(res.c,tmp.se);
    tmp=inter(tmp.fi,a.rmx+b.lmx);
    res.totmx=(tmp.fi);   //res.totmx=max({a.totmx,b.totmx,a.rmx+b.lmx})
    res.c=min(res.c,tmp.se);
    res.len=a.len+b.len;   //res.len=a.len+b.len
    return res;
}

inline void up(int p){
    d[p]=add(d[ls],d[rs]);
}

inline void build(int p,int l,int r){
    if(l==r){
        d[p].lmx=d[p].rmx=d[p].totmx=d[p].len={1,a[l]};//初始化最大子段和为自身，长度为1
        d[p].c=MX;//初始阈值设为极大值
        return;
    }
    build(lt),build(rt);
    up(p);
    return ;
}

inline void push(int p,int k){//不用考虑a的变化，可以化为b变化a*x
    tag[p]+=k;
    d[p].c-=k;
    d[p].lmx.b  +=d[p].lmx.a*k;
    d[p].rmx.b  +=d[p].rmx.a*k;
    d[p].totmx.b+=d[p].totmx.a*k;
    d[p].len.b  +=d[p].len.a*k;
    
    return ;
}

inline void pushdown(int p){
    push(ls,tag[p]),push(rs,tag[p]);
    tag[p]=0;
}

inline void update(int p,int l,int r,int x,int y,int k){
    if(x<=l&&r<=y&&d[p].c>=k){
        push(p,k);
        return;
    }
    pushdown(p);
    if(x<=mid) update(lt,x,y,k);
    if(y>mid) update(rt,x,y,k);
    up(p);
    return ;
}

inline node query(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y){
        return d[p];
    }
    pushdown(p);
    if(y<=mid) return query(lt,x,y);
    if(x>mid) return query(rt,x,y);
    return add(query(lt,x,y),query(rt,x,y));
}

signed main(){
    int n=read(),q=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
    }
    build(1,1,n);
    while(q--){
        int op=read();
        if(op==1){
            int l=read(),r=read(),k=read();
            update(1,1,n,l,r,k);
        }
        else{
            int l=read(),r=read();
            if(l>r) printf("0 \n");
            printf("%lld\n",max(0ll,query(1,1,n,l,r).totmx.b));
        }
    }
    return 0;
}
```

---

## 作者：Tmbcan (赞：4)

## [P5693 EI 的第六分块](https://www.luogu.com.cn/problem/P5693)

## 题目描述
给定一个整数序列，支持区间加正整数以及查询区间最大子段和。

## 思路  
使用线段树记录四个信息来维护答案：
- $sum_i$：区间和；
- $lmax_i$：最大前缀和；
- $rmax_i$：最大后缀和；
- $mx_i$：最大子段和。

合并时我们分类讨论：
- $lmax = \max(lmax_{ls},sum_{ls}+lmax_{rs})$；
- $rmax = \max(rmax_{rs},sum_{rs}+rmax_{ls})$；
- $mx = \max(mx_{ls},mx_{rs},rmax_{ls}+lmax_{rs})$。

## KTT 部分
我推荐直接去看[集训队论文](https://rusunoi.github.io/books/National-Team-Thesis/2020.pdf)或者[一些大佬的讲解](https://www.luogu.com.cn/article/u0ouhel6)。复杂度我不会证，请看 [EI 队长的证明](https://entropyincreaser.blog.uoj.ac/blog/5217)。  
（KTT 我没学会严谨说明，只能全靠感性理解了。）

现在每个信息记录的都不是一个具体值，而是一条**一次函数** $f(x)=kx+b$。  
其中 $k$ 为最大子段的长度，$x$ 为变化量，$f(0)=b$ 为当前维护的具体值。  
同时，对于两条函数，记录一个**阈值 $dx$**，表示当前区间最大值是否在两个函数间进行**交替**。我们需要维护四个信息的最大值，现在问题变成了一次函数比大小。  

### Push_down/Push_up

~~前置知识：[人教版八年级下册 19.2.3一次函数与方程、不等式](http://www.shuxue9.com/pep/cz8x/ebook/103.html)。~~  
在对两条函数进行合并取**最大值**时，需要知道具体应该**何时**选取哪条函数。我们知道应该看函数的交点相对于区间的位置，来对取值情况分类讨论。  
交替阈值就干了这样一件事情，维护时记录下何时应该对函数选取进行交替，并只在需要交替时交替，以此优化时间复杂度。

具体地，当**区间加 $q$** 时，函数向上进行了移动，函数的交点相对于区间进行了左右移动。此时我们令**阈值 $dx$ 减小**，当 $dx<0$ 时表示此时选取的函数要进行交替了（即决策点向左进行了移位）。  
由于同一个区间可能有两个不同的函数进行维护，所以在合并区间时，阈值不仅要对左右区间取最小值，还需要包含当前两条函数的交点。

### Rebuild
我们在 Update 后，可能会导致**节点子树内的 $dx$** 发生变化，而当 $dx<0$ 时会导致最大值选取发生变化。  
所以我们在做更新后需要对节点子树 Rebuild，二次递推来更新 $dx$。

### Update/Query
正常进行修改和查询即可，记得 Rebuild。  
同时注意**左右区间的合并顺序**。

## 代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
template <typename T>
inline void read(T&x){//快读
	int w=0;x=0;
	char ch = getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') w=1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x=-x;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
}
template <typename T>
inline T Min(T x,T y){ return (x < y ? x : y); }
const int N = 4e5+10;
const ll INF = 1e16;
struct Func{//一次函数
	ll k,b;
	Func(){
		k = 0; b = 0;
	}
	Func(ll tk,ll tb){
		k = tk; b = tb;
	}
	inline Func operator + (const Func&G) const{//函数合并
		return Func(k+G.k,b+G.b);
	}
	inline bool operator < (const Func&G) const{//钦定函数的位置关系
		return k==G.k && b<G.b || k<G.k;
	}
	inline ll operator & (const Func&G) const{//求交点
		return (G.b-b)/(k-G.k);
	}
	inline void operator += (const ll&G){//函数向上移动
		b += k*G;
	}
};
struct Tree{
	Func lx,rx,sum,mx; ll dx;//维护区间的四个信息以及阈值
	Tree(){
		dx = INF;//初始化为无穷大值，表示永远不会对最大值产生影响
	}
	Tree(Func tlx,Func trx,Func tsum,Func tmx,ll tdx){
		lx = tlx; rx = trx; sum = tsum; mx = tmx; dx = tdx;
	}
	inline void Merge_lx(Func x,Func y,Tree &tmp) const{//求lmax
		if(x<y) swap(x,y); 
		if(x.b>=y.b) tmp.lx = x;//钦定过了函数位置，此时两条函数没有交点
		else tmp.lx = y,tmp.dx = Min(tmp.dx,x&y);
	}
	inline void Merge_rx(Func x,Func y,Tree &tmp) const{//求rmax
		if(x<y) swap(x,y);
		if(x.b>=y.b) tmp.rx = x;
		else tmp.rx = y,tmp.dx = Min(tmp.dx,x&y);
	}
	inline void Merge_mx(Func x,Func y,Tree &tmp) const{//求mx
		if(x<y) swap(x,y);
		if(x.b>=y.b) tmp.mx = x;
		else tmp.mx = y,tmp.dx = Min(tmp.dx,x&y);
	}
	inline Tree operator + (const Tree&G) const{//区间合并
		Tree tmp; tmp.dx = Min(dx,G.dx); tmp.sum = sum+G.sum;
		Merge_lx(lx,sum+G.lx,tmp);Merge_rx(G.rx,G.sum+rx,tmp);
		Merge_mx(G.mx,mx,tmp);Merge_mx(tmp.mx,rx+G.lx,tmp);
		return tmp;
	}
	inline void operator += (const ll&G){//区间加
		lx += G; rx += G; mx += G; sum += G; dx -= G;
	}
}tr[N*3];
int P=1,DEP=0,st[N*3]; ll tag[N*3];
inline void push_down(int p){//正常push_down
	if(tag[p]){
		tag[p<<1] += tag[p]; tr[p<<1] += tag[p];
		tag[p<<1|1] += tag[p]; tr[p<<1|1] += tag[p];
		tag[p] = 0;
	}
}
inline void rebuild(int p){
	if(tr[p].dx>=0) return ;
	int head = 1,tail = 0;
	st[++tail] = p; push_down(p);
	while(tail>=head){
		int ttail = tail;
		for(int j=tail,pos;j>=head;--j){
			pos = st[j]; //看子节点的子树是否需要更新
			if(tr[pos<<1].dx<0) st[++tail]=pos<<1,push_down(pos<<1);
			if(tr[pos<<1|1].dx<0) st[++tail]=pos<<1|1,push_down(pos<<1|1);
		}
		head = ttail+1;
	}//重新维护
	do{ tr[st[tail]]=tr[st[tail]<<1]+tr[st[tail]<<1|1]; } while(--tail); 
}
inline void update(int l,int r,ll k){
	l += P-1; r += P+1;//先push_down
	for(int dep=DEP;dep;--dep) push_down(l>>dep),push_down(r>>dep);
	while(l^1^r){
		if(~l&1) tag[l^1]+=k,tr[l^1]+=k,rebuild(l^1);//别忘了rebuild
		if(r&1) tag[r^1]+=k,tr[r^1]+=k,rebuild(r^1);
		l>>=1;r>>=1;
		tr[l] = tr[l<<1]+tr[l<<1|1];
		tr[r] = tr[r<<1]+tr[r<<1|1];
	}
	for(l>>=1; l ;l>>=1) tr[l] = tr[l<<1]+tr[l<<1|1];
}
inline ll query(int l,int r){
	l += P-1; r += P+1;//先push_down
	for(int dep=DEP;dep;--dep) push_down(l>>dep),push_down(r>>dep);
	Tree resl,resr;
	while(l^1^r){
        //注意左右区间的合并顺序
		if(~l&1) resl = resl+tr[l^1];
		if(r&1) resr = tr[r^1]+resr;
		l>>=1;r>>=1;
	}
	return (resl+resr).mx.b;
}
int main(){
	// freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);
	int n,m;read(n,m);
	while(P<=n+1) P<<=1,++DEP;
	for(int i=1,k;i<=n;++i){
		read(k); Func res = Func(1ll,1ll*k);
		tr[i+P] = Tree(res,res,res,res,INF);//初始时都是y=x+a[i]
	}
	for(int i=P-1;i;--i) tr[i] = tr[i<<1]+tr[i<<1|1];
	for(int i=1,opt,l,r;i<=m;++i){
		read(opt,l,r); ll k;
		if(opt==1) read(k),update(l,r,k);
		else printf("%lld\n",(k=query(l,r))<0?0ll:k);//区间可以不选
	}
// 	fclose(stdin);
// 	fclose(stdout);
	return 0;
}
```

我的第一篇黑题，感谢 [NianFeng](https://www.luogu.com.cn/user/670826) 提供的帮助。

---

## 作者：FutaRimeWoawaSete (赞：4)

时间复杂度证明 EI 写的挺好的，去他博客看就行了。这个题解主要就是讲讲正确性和怎么做的。

[link](https://blog.csdn.net/EI_Captain/article/details/101040226)

主要思路就是，套用 TB6 前体的做法，我们直接将一个方案写成一次函数，即 $\text{kx} + \text b$ 表示选择区间长度为 $\text k$ 时区间和为 $\text b$ 的一种方案，其中 $\text x$ 是区间整体增量。

对于无区间加的最大子段和，我们只需要维护区间半群信息 $(\text{lmx},\text {rmx},\text {mx},\text {sum})$ 即可。不罗列具体的转移了。

考虑直接将这四个变量写成一次函数。注意此时从儿子向上的转移**都以 $\text x = \text 0$ 为基准转移，即假设子树内的所有转移没有被区间加影响到。**

更新信息时其中有一个一次函数的转移固定，两个一次函数每次有两种转移，一个一次函数每次有三种转移。对每个节点维护阈值 $\text T$ 表示**子树内所有节点的某个一次函数要切换转移路径的最小需要增加的 $\Delta \text x$，即区间加的值。**

根据此定义可以写出维护。注意到这个 $\text T$ 的定义很巧妙，因为我们假设了**子树中所有节点都不会被区间加影响到**，故对于 $\text T$ 的转移直接从子树中转移上来并且加入所有的两边对应转移的一次函数的交点就是正确的。

贴一下转移的代码：

```cpp
struct line
{
	int k;ll b;
	line(){k = b = 0;}
	line(int K,ll B){k = K , b = B;}
	inline line operator + (const line &Ano) const
	{return line(k + Ano.k , b + Ano.b);}
	inline void ad(const ll V){b += 1ll * k * V;}
};
#define pll pair<line,ll> 
#define mk(x,y) make_pair(x , y)
#define fs first 
#define sc second 
pll rt;
inline pll merge(line x,line y)
{
	if(x.k < y.k || (x.k == y.k && x.b < y.b)) swap(x , y);
	if(x.b >= y.b) return mk(x , Inf);
	return mk(y , (y.b - x.b) / (x.k - y.k));
}
inline info operator + (const info &Ano) const
{
	info t;
	pll ret;
	t.x = min(x , Ano.x);
	t.sm = sm + Ano.sm;
	ret = merge(lm , sm + Ano.lm) , t.lm = ret.fs , t.x = min(t.x , ret.sc);
	ret = merge(Ano.rm , Ano.sm + rm) , t.rm = ret.fs , t.x = min(t.x , ret.sc);
	ret = merge(Ano.mx , mx) , t.mx = ret.fs , t.x = min(t.x , ret.sc);
	ret = merge(t.mx , rm + Ano.lm) , t.mx = ret.fs , t.x = min(t.x , ret.sc);
	return t;
}
```

考虑每次修改时如果 $\Delta \text x > \text T_{\text i}$ 就向下递归重构，否则直接打个标记就能得到当前节点正确的信息。

这个维护好了查询就直接查就行了。注意到我们只需要保证修改和查询时的信息是对的就行了，设计一个函数在这两个地方修改/查询信息的时候递归处理即可。

时间复杂度 EI 证明了是 $\text O((\text n + \text m) \log ^ 3 \text n + \text q \log \text n)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
#define ll long long
const int Len = 4e5 + 5;
const ll Inf = 1e15;
int n,m,a[Len];
struct line
{
	int k;ll b;
	line(){k = b = 0;}
	line(int K,ll B){k = K , b = B;}
	inline line operator + (const line &Ano) const
	{return line(k + Ano.k , b + Ano.b);}
	inline void ad(const ll V){b += 1ll * k * V;}
};
#define pll pair<line,ll> 
#define mk(x,y) make_pair(x , y)
#define fs first 
#define sc second 
pll rt;
inline pll merge(line x,line y)
{
	if(x.k < y.k || (x.k == y.k && x.b < y.b)) swap(x , y);
	if(x.b >= y.b) return mk(x , Inf);
	return mk(y , (y.b - x.b) / (x.k - y.k));
}
struct info
{
	line lm,rm,sm,mx;
	ll x;
	info(){x = Inf;}
	info(line LM,line RM,line SM,line MX,ll X){lm = LM , rm = RM , sm = SM , mx = MX , x = X;}
	inline info operator + (const info &Ano) const
	{
		info t;
		pll ret;
		t.x = min(x , Ano.x);
		t.sm = sm + Ano.sm;
		ret = merge(lm , sm + Ano.lm) , t.lm = ret.fs , t.x = min(t.x , ret.sc);
		ret = merge(Ano.rm , Ano.sm + rm) , t.rm = ret.fs , t.x = min(t.x , ret.sc);
		ret = merge(Ano.mx , mx) , t.mx = ret.fs , t.x = min(t.x , ret.sc);
		ret = merge(t.mx , rm + Ano.lm) , t.mx = ret.fs , t.x = min(t.x , ret.sc);
		return t;
	}
}O[Len << 2],ep;
ll tag[Len << 2];
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
inline void push_up(int p){O[p] = O[ls(p)] + O[rs(p)];}
inline void cg(int p,ll w)//更新不被影响的 
{
	tag[p] += w , O[p].x -= w;
	O[p].lm.ad(w) , O[p].rm.ad(w) , O[p].sm.ad(w) , O[p].mx.ad(w);
}
inline void push_down(int p)
{
	if(tag[p])
	{
		cg(ls(p) , tag[p]) , cg(rs(p) , tag[p]);
		tag[p] = 0;
	}
}
void get(int p,int l,int r)
{
	if(O[p].x >= 0) return;
	push_down(p);
	int mid = (l + r) >> 1;
	get(ls(p) , l , mid) , get(rs(p) , mid + 1 , r);
	push_up(p);
}
void build(int p,int l,int r)
{
	tag[p] = 0;
	if(l == r)
	{
		line d = line(1 , a[l]);
		O[p] = info(d , d , d , d , Inf);
		return;
	} 
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid) , build(rs(p) , mid + 1 , r);
	push_up(p);
}
void update(int p,int l,int r,int nl,int nr,ll w)
{
	if(nl <= l && nr >= r) 
	{
		cg(p , w);
		get(p , l , r);
		return;
	}
	push_down(p);
	int mid = (l + r) >> 1;
	if(nl <= mid) update(ls(p) , l , mid , nl , nr , w);
	if(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , w);
	push_up(p);
}
info ret;bool fg;
void Q(int p,int l,int r,int nl,int nr)
{
	if(nl <= l && nr >= r)
	{
		get(p , l , r);
		if(!fg) fg = 1 , ret = O[p];
		else ret = ret + O[p];
		return;
	}
	push_down(p);
	int mid = (l + r) >> 1;
	if(nl <= mid) Q(ls(p) , l , mid , nl , nr);
	if(nr > mid) Q(rs(p) , mid + 1 , r , nl , nr); 
	push_up(p);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= n ; i ++) scanf("%d",&a[i]);
	build(1 , 1 , n);
	for(int i = 1 ; i <= m ; i ++)
	{
		int op,l,r,x;scanf("%d %d %d",&op,&l,&r);
		if(op == 1)
		{
			scanf("%d",&x);
			update(1 , 1 , n , l , r , x);
		}
		else
		{
			ret = ep , fg = 0;
			Q(1 , 1 , n , l , r);
			printf("%lld\n",max(0ll , ret.mx.b));
		}
	}
	return 0;
}
```

---

## 作者：RainySoul (赞：3)

尖端科技 KTT，用了都说好。

### 简介

KTT 是 EntropyIncreaser 巨佬提出的用于特定问题的全新数据结构，它有啥强大功能呢？我们都知道普通线段树可以支持区间加与区间最值查询，但是当每个点增量不同的时候，普通线段树就无能为力了。此时，我们的 KTT 出现了！

具体而言，KTT 是一类特殊的很厉害的线段树，每个节点维护一个一次函数 $y=ax+b$，每次对着 $x$ 修改，这样你通过改变 $a$ 的值可以使得 $x$ 增加相同量的时候真实值变化量不同，而这个节点的真实值储存在 $b$ 中。

相较于普通线段树，KTT 有如下 $2$ 个最大的限制：

1. 只支持加正数。
2. 只支持区间查询最大值。

为什么呢？讲完 KTT 的实现你自然就知道了。

### 实现

KTT 最高妙的地方在于其需要维护一个叫做阈值的东西用于更新最大值。

请看下图，其中红色线的解析式是 $y=x+5$，绿色线的解析式是 $y=2x+1$。而我要维护的是这两条线最大值的解析式。明显在 $x \in [0,4)$ 这段最大值的解析式是 $y=x+5$，而在 $x \in [4,\infty)$ 这段最大值的解析式是 $y=2x+1$。所以在 $x=4$ 时发生了一次最大值的更替，我们的阈值就是为了处理出这个更替发生的时间，阈值明显就是左右子树解析式交点的 $x$ 坐标（注意向上取整）。

![](https://cdn.luogu.com.cn/upload/image_hosting/rno8i450.png)

好，我们现在知道了更替什么时候发生了，而在一次更替发生时我们需要做的就是递归子树，找出是哪条线成为了新的最大值，然后 `pushup` 更新。

这个递归子树的操作实际上是重构子树，我们将其命名为 `rebuild`。其他操作与普通线段树差别不大，不过注意，`pushdown` 操作可能会让子树越过阈值，`pushdown` 完后要看需不需要 `rebuild`。

好了，现在你会了一个最板的 KTT，借用一下 [Dark\_moon](https://www.luogu.com.cn/user/417018) 巨佬的出的[【模板】KTT](https://www.luogu.com.cn/problem/U435624)，大家可以用来练手。

[模板题的 AC 代码](https://www.luogu.com.cn/paste/dxhycmy1)扔这里了。

至于前面提出的两个限制，稍微思考一下也很好理解了。你维护的是最大值更替的阈值，而当 $x$ 加的是个负数，很可能会出现回退的情况，而你并不能处理。

### 本题

现在来看看本题怎么用 KTT 做。

首先不带修最大子段和这个东西可以简单地线段树维护每个节点覆盖区间的最大前缀、最大后缀、所有数的总和、最大子段和，然后合并得到。如果你不会的话可以去做 [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)。

然后考虑修改，观察到区间加的 $x$ 范围是 $1 \le x \le 10^{6}$，这很 KTT。想一下区间可以怎么用一次函数的形式表示。一个区间长度为 $len$ 的区间加上一个 $k$，贡献是 $len \times k$，所以你的一次函数 $y=ax+b$ 的 $a$ 就是区间长度，这个区间的真实值储存在 $b$ 中。

想到这里就做完了，只需要在模板的基础上更改一下合并操作就行了。

时间复杂度的话，本人太菜了，并不会分析。据说是三只 $\log$ 的，但很难卡满，可以当作两只 $\log$ 来算。有兴趣的童鞋可以去看 [EI 的证明](https://entropyincreaser.blog.uoj.ac/blog/5217)。

AC code：

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f3f
using namespace std;
const int N=400010;
struct csq{
    int a,b;
    friend csq operator +(csq x,csq y){//重载一下两个函数的合并，显然b是直接相加，而a是与区间长度相关的，合并也是直接相加
        return (csq){x.a+y.a,x.b+y.b};
    }
};
pair<csq,int> inter(csq x,csq y){//不仅需要知道阈值是多少，你还需要知道是哪个函数
    if(x.b==y.b){
        if(x.a<y.a)return make_pair(y,inf);
        else return make_pair(x,inf);
    }
    if(x.b<y.b){
        if(x.a<=y.a)return make_pair(y,inf);
        else return make_pair(y,(x.b-y.b)/(y.a-x.a));
    }
    else{
        if(x.a>=y.a)return make_pair(x,inf);
        else return make_pair(x,(y.b-x.b)/(x.a-y.a));
    }
}
struct zyx{
    csq lmax,rmax,sum,ans;
    int intr;
    friend zyx operator +(zyx x,zyx y){//实际上就是线段树的合并操作
        zyx temp;
        pair<csq,int> t1,t2,t3,t4;
        t1=inter(x.lmax,x.sum+y.lmax);
        t2=inter(y.rmax,x.rmax+y.sum);
        t3=inter(x.ans,y.ans);
        t4=inter(t3.first,x.rmax+y.lmax);
        temp.intr=min({x.intr,y.intr,t1.second,t2.second,t3.second,t4.second});
        temp.lmax=t1.first;
        temp.rmax=t2.first;
        temp.ans=t4.first;
        temp.sum=x.sum+y.sum;
        return temp;
    } 
}w[N<<2];
int n,q,a[N],lazy[N<<2];
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
void build(int u,int l,int r){
    if(l==r){
        w[u].lmax=(csq){1,a[l]};
        w[u].rmax=(csq){1,a[l]};
        w[u].sum=(csq){1,a[l]};
        w[u].ans=(csq){1,a[l]};//其他所有值的初始化：区间长度为1，值为a[l]
        w[u].intr=inf;//阈值初始化为inf
        return;
    }
    int mid=(l+r)>>1;
    build(u*2,l,mid);
    build(u*2+1,mid+1,r);
    w[u]=w[u*2]+w[u*2+1];
}
void make_tag(int u,int k){//标准的打标记操作
    w[u].sum.b+=w[u].sum.a*k;
    w[u].ans.b+=w[u].ans.a*k;
    w[u].lmax.b+=w[u].lmax.a*k;
    w[u].rmax.b+=w[u].rmax.a*k;//现在你每个节点的值就是b了，区间长度为a，区间中每个数加上k，贡献就是a*k
    w[u].intr-=k;//注意！更新阈值
    lazy[u]+=k;
}
void pushdown(int u){
    make_tag(u*2,lazy[u]);
    make_tag(u*2+1,lazy[u]);
    lazy[u]=0;
}
void rebuild(int u){
    if(w[u].intr>=0)return;
    pushdown(u);
    rebuild(u*2);
    rebuild(u*2+1);
    w[u]=w[u*2]+w[u*2+1];
}
void update(int u,int l,int r,int x,int y,int k){
    if(x<=l&&r<=y){
        make_tag(u,k);
        rebuild(u);
        return;
    }
    pushdown(u);
    int mid=(l+r)>>1;
    if(x<=mid)update(u*2,l,mid,x,y,k);
    if(y>mid)update(u*2+1,mid+1,r,x,y,k);
    w[u]=w[u*2]+w[u*2+1];
}
zyx query(int u,int l,int r,int x,int y){
    if(x<=l&&r<=y){
        return w[u];
    }
    pushdown(u);
    int mid=(l+r)>>1;
    if(x<=mid&&y>mid)return query(u*2,l,mid,x,y)+query(u*2+1,mid+1,r,x,y);
    else if(x<=mid)return query(u*2,l,mid,x,y);
    else if(y>mid)return query(u*2+1,mid+1,r,x,y);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    n=read(),q=read();
    for(int i=1;i<=n;i++)a[i]=read();
    build(1,1,n);
    while(q--){
        int op=read(),l=read(),r=read();
        if(op==1){
            int x=read();
            update(1,1,n,l,r,x);
        }
        else{
            cout<<max(0ll,query(1,1,n,l,r).ans.b)<<'\n';
            //注意可以不选
        }
    }
    return 0;
}
```

---

## 作者：Eterna (赞：2)

单点修改和区间最大子段和相信大家都会了。

但是本题是区间加正数，就比较难做了。因为区间加后，我们无法快速判断它对答案的贡献。

回忆单点修改和区间最大子段和的做法，我们分别维护了，区间和，区间前缀最大子段和，区间后缀最大子段和，与区间最大子段和。合并答案就不再说了。我们可以将这些值看做区间内的决策。

比如这样的一个数列：$\{ 5 ,-9 ,5 ,5 ,-12 ,8\}$。

显然，它的和为 $2$，前缀最大子段和为 $6$，后缀最大子段和为 $8$，最大子段和为 $10$。

则我们称其决策的区间分别为 $[1,6],[1,4],[6,6],[3,4]$。

区间和很好维护，因为其决策的区间始终为整个区间，设区间长度为 $l$，区间增量为 $v$，显然其对结果增加 $l \times v$。

最大子段和不好维护，因为其决策的区间是可变的。倘若其决策区间不可变，设决策区间长度为 $l$，区间增量为 $v$，显然其也可以对结果增加 $l \times v$。

不过决策区间也不是一定会变，当我们的增量比较小，则它可能不会使决策区间改变。容易发现它的决策区间改变存在某个值域 $[x,\infty]$，计算出这个阈值 $x$ 或许可以实现快速地修改。

考虑将每个值维护成一次函数 $ax+b$ 的形式。$a$ 代表决策区间的长度，$b$ 代表函数值，也就是我们维护的值，$x$ 是我们每次操作的增量。

考虑计算阈值，先举一个前缀最大子段和的例子：

>已知前缀最大子段和有两种取值，即左区间的前缀最大子段和，或左区间的和加上右区间的前缀最大子段和。
>
>将其理解为两种不同的决策，这两种决策我们也表示为一次函数，也就是直线。
>
>两条直线的交点就是区间前缀最大子段和决策变更的地方。注意如果不存在交点，阈值记为 $\infty$。

其余同理。

由于前缀最大子段和，后缀最大子段和，与区间最大子段和都会影响我们的答案，所以当增量大于这些值的阈值的最小值换一种方式修改，否则直接修改。注意直接修改对区间的阈值有影响，相当于做减法。

为了方便，不管我们是否改变决策，我们都先执行后者，此时阈值可能是负数。我们对当前节点为根构成的子树暴力重构，向下递归直到阈值是一个非负数。

说是暴力重构，其实 `pushdown` 一遍，再 `pushup` 一遍就好了。

这个问题就解决了。时间复杂度被证明为 $O((n+q)\log^3 n)$，但我不会证明。

阈值的极值一定要够大，否则会导致 `RE` 或 `WA`。

---

## 作者：Nygglatho (赞：1)

题意：

- 区间 $[l,r]$ 加 $v(v>0)$。
- 区间最大子段和。

---

对于不带有区间修改的情况，显然就是 [GSS1](https://www.luogu.com.cn/problem/SP1043) 的经典 Trick：维护 $\mathrm{mx,mxl,mxr,sum}$ 分别表示 $[l,r]$ 最大子段和，左端点必须在 $l$ 的最大子段和，右端点必须在 $r$ 的最大子段和，以及区间和。

现在考虑 $\mathrm{mx,mxl,mxr,sum}$ 不再只维护一个数字，而是维护一个一次函数 $y=kx+b$，$k$ 表示元素的数量，$b$ 表示当前的答案值。

- 对于相加，显然 $k$ 和 $b$ 分别相加，作为新的 $k$ 和 $b$ 即可。
- 对于取 $\max$，则直接根据 $b$ 取 $\max$ 即可，因为 $b$ 代表当前的答案值。
- 对于查询，直接取该函数的常数 $b$ 即可。

接下来考虑区间加，显然你需要分两种情况考虑：不改变决策和改变决策（击败操作）。

- 对于不改变决策的情况，直接对当前的 $\mathrm{mx,mxl,mxr,sum}$ 每一个加上对应的 $k\cdot v$，因为数量一共有 $k$ 个，决策没有改变，每一个增加了 $v$，总共即增加了 $k\cdot v$。

- 对于改变决策的情况，可以直接暴力重构其子树。

接下来的问题就是判断何时应该重构子树，可以发现，当增加到一个阈值 $w$ 之后，决策就会发生改变，如下图举例的数列 $[5,-2,-5]$，全部增加 $2$ 之后决策会发生改变，继续增加 $3$ 之后决策会再一次发生改变。

![](https://cdn.luogu.com.cn/upload/image_hosting/8jbmrfvc.png)

假设两个决策分别是 $y=k_1x+b_1,y=k_2x+b_2(k_1<k_2)$，显然在交点之后就是 $y=k_2x+b_2$ 更优了，那么 $w$ 即为当前决策和 $k$ 比当前决策大的所有一次函数交点横坐标的最小值。特别地，如果不存在 $k$ 比当前决策大的一次函数，则 $w$ 可以取 $\infty$。

考虑维护这个 $w$，合并可以 $O(1)$ 合并两个儿子信息，把两个子节点 $\mathrm{mx,mxl,mxr}$ 的所有决策交点横坐标取 $\min$，这个再和两个子节点的 $w$ 信息取 $\min$ 即为当前节点的 $w$。

然后就是区间修改对 $w$ 的影响，同样分为两种：

- 已经产生决策改变，即 $v>w$，那么直接递归重构子树，$w$ 也会随之被重新得出。
- 未产生，那么增加 $v$ 时，就相当于所有函数全体向左平移 $v$ 个单位，$w\gets w-v$。

这样就可以维护了，采用势能分析，复杂度为 $O((n+q)\log^3n)$，具体证明可以看 [EI 的博客](https://entropyincreaser.blog.uoj.ac/blog/5217)。

```cpp
struct Line {
    ll k, b;
    void operator += (ll v) {
        b += k * v;
    }
    Line operator +(const Line& p) const {
        Line res;
        res.k = k + p.k;
        res.b = b + p.b;
        return res;
    }
    bool operator <(const Line& p) const {
        return ((k < p.k) || (k == p.k && b < p.b));
    }
};

Line max (Line a, Line b) {
    if (a < b) swap (a, b);
    if (a.b >= b.b) return a;
    else return b;
}

ll Point (Line a, Line b) { // 两个一次函数交点
    if (a < b) swap (a, b);
    if (a.b >= b.b) return inf;
    return (b.b - a.b) / (a.k - b.k);
}

struct Node {
    Line lmx, rmx, mx, sum;
    ll x; // 这里的 x 是描述中的 w
    Node operator +(const Node& p) const {
        Node res;
        res.x = min (x, p.x);
        res.x = min (res.x, Point (mx, p.mx));
        res.x = min (res.x, Point (max (mx, p.mx), rmx + p.lmx));
        res.x = min (res.x, Point (lmx, sum + p.lmx));
        res.x = min (res.x, Point (p.rmx, rmx + p.sum)); // 求交点横坐标 min

        res.lmx = max (lmx, sum + p.lmx);
        res.rmx = max (rmx + p.sum, p.rmx);
        res.sum = sum + p.sum;
        res.mx = max (max (mx, p.mx), rmx + p.lmx); // 这和 GSS 没区别

        return res;
    }
};

struct KTT {
    ll b[1620000];
    Node d[1620000];

    void Upd (int p, ll v) {
        d[p].x -= v;
        d[p].lmx += v;
        d[p].rmx += v;
        d[p].mx += v;
        d[p].sum += v;
    }

    void Build (int l, int r, int p) {
        if (l == r) {
            d[p].x = inf;
            d[p].lmx = {1, a[l]};
            d[p].rmx = {1, a[l]};
            d[p].mx = {1, a[l]};
            d[p].sum = {1, a[l]};
            return;
        }
        int m = (l + r) >> 1;
        Build (l, m, p << 1);
        Build (m + 1, r, p << 1 | 1);
        d[p] = d[p << 1] + d[p << 1 | 1];
    }

    void Pushdown (int p) {
        Upd (p << 1, b[p]);
        Upd (p << 1 | 1, b[p]);
        b[p << 1] += b[p];
        b[p << 1 | 1] += b[p];
        b[p] = 0;
    }

    void Rebuild (int l, int r, int p, ll v) { // 重构
        if (v > d[p].x) { // 如果大于阈值则继续递归重构
            int m = (l + r) >> 1;
            Rebuild (l, m, p << 1, v + b[p]);
            Rebuild (m + 1, r, p << 1 | 1, v + b[p]);
            d[p] = d[p << 1] + d[p << 1 | 1];
            b[p] = 0ll;
        } else { // 否则直接打个标记即可
            Upd (p, v);
            b[p] += v;
        }
    }

    void Add (int l, int r, int s, int t, int p, ll v) {
        if (l <= s && t <= r) {
            Rebuild (l, r, p, v);
            return ;
        }
        Pushdown (p);
        int m = (s + t) >> 1;
        if (l <= m) Add (l, r, s, m, p << 1, v);
        if (m < r) Add (l, r, m + 1, t, p << 1 | 1, v);
        d[p] = d[p << 1] + d[p << 1 | 1];
    }

    Node Query (int l, int r, int s, int t, int p) {
        if (l <= s && t <= r) return d[p];
        Pushdown (p);
        int m = (s + t) >> 1;
        if (l <= m && m < r) return Query (l, r, s, m, p << 1) + Query (l, r, m + 1, t, p << 1 | 1);
        if (l <= m) return Query (l, r, s, m, p << 1);
        if (m < r) return Query (l, r, m + 1, t, p << 1 | 1);
    }
}st;
```

---

## 作者：xiao7_Mr_10_ (赞：0)

这种高级数据结构还是太抽象了，简单理一下思路，不会 KTT 的应该看不懂。

只考虑区间查的问题，我们显然维护区间和、最大前缀和、最大后缀和，以及答案。

然后考虑这样一件事情：区间如果选择了加 $x$，那么是不是我们在某种情况下可以不重构相关节点呢，而且这样对答案没有影响。

我们考虑把问题转化：把上述的四个需要维护值看做一个**一次函数**。

实际上，我们可以将区间长度看做斜率 $k$，然后加法标记看做自变量 $x$，再将原答案看做 $b$。

最基础的，每次我们考虑合并两条直线，这个贪心搞一搞就行了很简单。

我们在线段树的每个节点上维护一个阈值 $lim$ 表示如果加法标记 $x \ge lim$ 那么至少需要更新一个信息。

然后就是合并两个节点的分类讨论，可以看代码，去掉直线合并和阈值实际上和不带修差不多。

打标记的时候考虑这样一件事：不妨把这个阈值看做一个**限制值**，意思是如果这个值小于等于 $0$ 我们就需要递归子树修改，反之直接修改并返回。

然后就是线段树基础结构的套用，经过复杂度分析之后是 $O((n+m) \log ^3 n)$。细节我看不懂，可以看一下其他题解提供的论文。

注意，由于子序列可以为空所以答案需要对 $0$ 取最大值。当然我相信这种问题其实没必要提出来。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e5+5,inf=1e18;
struct line{
	int k,b;
	line operator +(const line &x)const{return (line){k+x.k,b+x.b};}
};
pair<line,int> max(line x,line y){
	if(x.k<y.k||(x.k==y.k&&x.b<y.b))swap(x,y);
	if(x.b>=y.b)return make_pair(x,inf);
	return make_pair(y,(y.b-x.b)/(x.k-y.k));
}
struct Point{
	line ans1,sum,lsum,rsum;int lim;
	Point operator +(const Point &x)const{
		Point ans;ans.lim=min(lim,x.lim);ans.sum=sum+x.sum;
		pair<line,int> lq=max(lsum,sum+x.lsum);
		ans.lsum=lq.first,ans.lim=min(ans.lim,lq.second);lq=max(x.rsum,rsum+x.sum);
		ans.rsum=lq.first,ans.lim=min(ans.lim,lq.second);lq=max(ans1,x.ans1);ans.lim=min(ans.lim,lq.second);
		lq=max(lq.first,rsum+x.lsum);ans.ans1=lq.first,ans.lim=min(ans.lim,lq.second);return ans;
	} 
}c[N<<2];
int n,a[N],q,l,r,op,x,m,k;
void updata(int x){c[x]=c[x<<1]+c[x<<1|1];}
void build(int x,int l,int r){
	if(l==r){line tmp=(line){1ll,a[l]};
		c[x]=(Point){tmp,tmp,tmp,tmp,inf};
		return;
	}int mid=(l+r)>>1;
	build(x<<1,l,mid);build(x<<1|1,mid+1,r);updata(x);
}int tag[N<<2];
void xg(int x,int y){
	tag[x]+=y;c[x].lim-=y;
	c[x].ans1.b+=c[x].ans1.k*y,c[x].lsum.b+=c[x].lsum.k*y;
	c[x].rsum.b+=c[x].rsum.k*y,c[x].sum.b+=c[x].sum.k*y;
}
void pushdown(int x,int l,int r,int k){
	if(k>c[x].lim){
		int mid=(l+r)>>1;
		pushdown(x<<1,l,mid,tag[x]+k);
		pushdown(x<<1|1,mid+1,r,tag[x]+k);
		updata(x);tag[x]=0;
	}else xg(x,k);
}
void down(int x){
	xg(x<<1,tag[x]);
	xg(x<<1|1,tag[x]);tag[x]=0;
}
void change(int x,int l,int r,int s,int t,int k){
	if(l>=s&&r<=t){
		pushdown(x,l,r,k);
		return;
	}int mid=(l+r)>>1;down(x);
	if(s<=mid)change(x<<1,l,mid,s,t,k);
	if(t>mid)change(x<<1|1,mid+1,r,s,t,k);updata(x);
}
Point query(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x];int mid=(l+r)>>1;down(x);
	if(s>mid)return query(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return query(x<<1,l,mid,s,t);
		return query(x<<1,l,mid,s,t)+query(x<<1|1,mid+1,r,s,t);
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);	
	cin >> n >> m;
	for(int i = 1;i <= n;i++)cin >> a[i];build(1,1,n);
	for(int i = 1;i <= m;i++){
		cin >> op >> l >> r;
		if(op==1){
			cin >> k;
			change(1,1,n,l,r,k);
		}else cout << max(0ll,query(1,1,n,l,r).ans1.b) << "\n";
	}
	return 0;
}

```

---


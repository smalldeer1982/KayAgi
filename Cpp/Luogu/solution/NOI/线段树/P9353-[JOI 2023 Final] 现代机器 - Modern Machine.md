# [JOI 2023 Final] 现代机器 / Modern Machine

## 题目描述

Bitaro 收到了一个 JOI 机器作为生日礼物。

JOI 机器由一个球、$N$ 个灯光瓷砖和 $M$ 个按钮组成。灯光瓷砖从 $1$ 到 $N$ 编号。当 Bitaro 打开电源时，灯光瓷砖 $i$ ($1 \leq i \leq N$) 会发出颜色为 $C_i$（蓝色（$\texttt B$）或红色（$\texttt R$））的光。按钮从 $1$ 到 $M$ 编号。

如果 Bitaro 按下按钮 $j$ ($1 \leq j \leq M$)，会发生以下情况。 

1. 球被放置在灯光瓷砖 $A_j$ 上。
2. 灯光瓷砖 $A_j$ 变为红色（无论其原始颜色如何）。
3. 在球被移除之前，执行以下操作。 设 $p$ 为球当前所在的灯光瓷砖的索引。
   - 如果灯光瓷砖 $p$ 是蓝色的，灯光瓷砖 $p$ 变为红色。之后，如果 $p = 1$，球被移除。否则，球移动到灯光瓷砖 $p - 1$。
   - 如果灯光瓷砖 $p$ 是红色的，灯光瓷砖 $p$ 变为蓝色。之后，如果 $p = N$，球被移除。否则，球移动到灯光瓷砖 $p + 1$。

Bitaro 对 JOI 机器很感兴趣。他计划进行 $Q$ 次实验。在第 $k$ 次实验中（$1 \leq k \leq Q$），在 Bitaro 打开电源后，Bitaro 按顺序按下按钮 $L_k, L_{k} + 1, \dots , R_k$。在 Bitaro 按下一个按钮后，他不会按下下一个按钮，并等待球被移除。

给定 JOI 机器的信息和实验，编写一个程序来计算每次实验结束时颜色为红色的灯光瓷砖的数量。

## 说明/提示

**【样例解释 #1】**

第一次实验如下进行。 
1. Bitaro 按下按钮 1，球被放置在灯光瓷砖 4 上。 
2. 灯光瓷砖 4 变为红色。由于灯光瓷砖 4 的原始颜色是红色，灯光瓷砖 4 的颜色没有改变。 
3. 之后，执行以下操作。  
（1）由于灯光瓷砖 4 的当前颜色是红色，灯光瓷砖 4 变为蓝色，球移动到灯光瓷砖 5。  
（2）由于灯光瓷砖 5 的当前颜色是蓝色，灯光瓷砖 5 变为红色，球移动到灯光瓷砖 4。  
（3）由于灯光瓷砖 4 的当前颜色是蓝色，灯光瓷砖 4 变为红色，球移动到灯光瓷砖 3。  
（4）由于灯光瓷砖 3 的当前颜色是红色，灯光瓷砖 3 变为蓝色，球移动到灯光瓷砖 4。  
（5）由于灯光瓷砖 4 的当前颜色是红色，灯光瓷砖 4 的颜色变为蓝色，球移动到灯光瓷砖 5。  
（6）由于灯光瓷砖 5 的当前颜色是红色，灯光瓷砖 5 的颜色变为蓝色，球被移除。

实验结束后，灯光瓷砖 1 是唯一一个当前颜色为红色的灯光瓷砖。因此，输出 1。

本样例满足子任务 1,2,3,6,7 的限制。

**【样例解释 #2】**

对于第一次实验，灯光瓷砖 1, 2, 3, 4, 5 是实验结束后当前颜色为红色的灯光瓷砖。由于有五个这样的灯光瓷砖，输出 5。

对于第二次实验，没有灯光瓷砖在实验结束后颜色为红色。因此，输出 0。

本样例满足子任务 3,6,7 的限制。

**【样例解释 #3】**

本样例满足子任务 1,2,3,6,7 的限制。

**【样例解释 #4】**

本样例满足子任务 3,4,5,6,7 的限制。

**【样例解释 #5】**

本样例满足子任务 3,5,6,7 的限制。

**【样例解释 #6】**

本样例满足子任务 6,7 的限制。

**【数据规模】**

对全部的测试点，保证： 
- $3 \leq N \leq 1.2 \times 10^5$；
- $1 \leq M \leq 1.2 \times 10^5$；
- $C_i \in \{\texttt{B},\texttt{R}\}$； 
- $1 \leq A_j \leq N$；
- $1 \leq Q \leq 1.2 \times 10^5$； 
- $1 \leq L_k \leq R_k \leq M$； 
- $N, M, A_j, Q, L_k, R_k$ 均为整数。

**【子任务】**

**本题采用捆绑测试**。

1. (3 分) $N,M \leq 300$，$Q = 1$。 
2. (12 分) $N, M \leq 7000$，$Q = 1$。 
3. (10 分) $Q \leq 5$。 
4. (11 分) $N = 10$，$C_i = \texttt R$。 
5. (26 分) 存在一个整数 $t \in [0, N]$，满足对 $1 \leq i \leq t$，$C_i = \texttt R$；且对 $t < i \leq N$，$C_i = \texttt B$。 
6. (17 分) $A_j \leq 20$ 或 $A_j > N - 20$。
7. (21 分) 无特殊约定。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
5 1
RBRRB
4
1
1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 3
RBRBR
1 3 4
2
2 3
1 3```

### 输出

```
5
0```

## 样例 #3

### 输入

```
10 3
BBRRBRBRRB
2 10 5
1
1 3```

### 输出

```
2```

## 样例 #4

### 输入

```
10 10
RRRRRRRRRR
3 1 4 1 5 9 2 6 5 3
5
1 7
2 8
3 9
4 10
1 10```

### 输出

```
4
8
10
0
9```

## 样例 #5

### 输入

```
10 10
RRRBBBBBBB
3 1 4 1 5 9 2 6 5 3
5
1 10
2 9
3 8
4 7
5 6```

### 输出

```
2
6
0
10
7```

## 样例 #6

### 输入

```
30 10
RRRBBRBBBRBBBRBRBRRRRRBBBBRBRR
3 28 2 29 1 30 6 14 7 7
10
1 10
2 3
2 5
2 8
3 3
3 6
4 5
4 7
5 9
10 10```

### 输出

```
21
15
15
4
17
16
14
20
12
23```

# 题解

## 作者：APJifengc (赞：5)

首先考虑一次操作干了什么，注意到我们只有在最后一次转弯后的覆盖是有意义的，那么实际上，将结果分为从左边出界和从右边出界，分别造成的修改是前缀染红与后缀染蓝。

那么考虑具体染了多少，大概手动模拟一下发现，如果在第 $i$ 个位置操作，会将前 $i$ 个蓝色染红或把后 $n-i+1$ 个红染蓝。证明也很简单，以前一种情况为例，考虑左边与右边转弯的次数，左边遇到红色会转弯，后边遇到蓝色会转弯，设左边有 $p$ 个蓝色，那么就有 $i-1-p$ 个红色，于是会转 $i-1-p$ 次弯，最后从左边出，说明在右边转了 $i-p$ 次弯，于是右边覆盖了 $i-p$ 个蓝色，于是总共覆盖的蓝色数就是 $i$ 个。

那么暴力模拟这个过程就可以 $O(nmq)$ 了，可以拿到 $15$ 分。改成线段树上二分即可 $O(mq \log n)$，可以通过第三个包，拿到 $25$ 分。

考虑第四、五个包怎么做，存在一个 $t \in [0, n]$，使得前 $t$ 个为红色，剩下的都是蓝色。注意到，此时每次操作之后，原来的操作不会改变这个性质，仅改变了 $t$，那么我们实际上只需要考虑维护 $t$ 即可。

由于开始会把所在的格子染红，所以起点在红与蓝上的情况会不同，简单分情况考虑一下：

- 若起点 $i$ 为红色：
  - 若 $n - t \ge i$，则 $t \gets t + i$；
  - 否则，$t \gets t - (n - i + 1)$；
- 若起点 $i$ 为蓝色：
  - 若 $n - t - 1 \ge i$，则 $t \gets t + i + 1$；
  - 否则，$t \gets t - (n - i)$；

可以发现，上述操作实际上是在模 $n + 1$ 意义下进行加 $i$ 或 $i+1$ 的操作，我们可以写出一个函数 $f_i(t)$，表示在 $i$ 操作下 $t$ 会变成什么，那么有：

$$
f_i(t) = \begin{cases}
(t + i + 1) \bmod (n + 1) & t < i\\
(t + i) \bmod (n + 1) & t \ge i
\end{cases}
$$

那么，我们要求的，实际上就是一个区间内这个函数的复合。对于 $n = 10$ 的情况，发现我们可以直接维护所有函数值，直接上线段树维护，复杂度 $O(nq \log m)$，可以通过第四个包，拿到 $36$ 分。

直接维护函数值显然是很差的，我们能不能直接维护分段函数？看起来似乎复杂度爆炸，但是注意到我们只有查询操作没有修改操作，于是我们的线段树只要能建出来就行，而查询操作也不需要真的把函数复合找出来，因为我们只要求单点的值，所以查询的时候不需要将线段树上的若干个区间合并起来，于是我们不需要太关心合并两个区间的复杂度，不过我们还是需要关心分段函数的总段数的。

而注意到复合一次这个分段函数相当于进行 $O(1)$ 次的裁剪拼接，这只会使分段函数增加 $O(1)$ 段，于是 $len$ 个函数的复合得到的是一个 $O(len)$ 段的分段函数，那么我们就可以发现线段树上所有节点上的函数的段数之和是 $O(m \log m)$ 的。由于合并的时候需要找到分割点的位置，需要二分，所以总建树的复杂度就是 $O(m \log^2 m)$ 的，单次查询也是 $O(\log^2 m)$ 的，所以总复杂度 $O((m + q) \log^2 m)$，可以通过第五个包，拿到 $62$ 分。

一般情况呢？注意到，任意局面进行若干次操作后，一定会变成上述的局面，而由于每次操作都是前缀染红与后缀染蓝，我们只需要维护前缀红的数量 $p$ 与后缀蓝的数量 $q$，如果某一时刻两者染的部分交叉了，那么说明此时已经变成了上述的情况。考虑每次操作，如果操作的点 $i \le p$，覆盖前缀则 $p$ 会多覆盖 $i$ 个蓝点，覆盖后缀则一定会变成前面所述的情况，$q$ 是同理的，于是对于操作的点在 $p,q$ 之内的情况，所进行的操作就是一直增加 $p+q$ 的总和，我们只需要找到什么时候能够交叉即可。

如果操作的点不在 $p,q$ 之内似乎就不好办了，不过我们注意到，进行一次操作后，无论增长的是 $p$ 还是 $q$，它们都会翻倍，也就是说不在 $p,q$ 内的点的操作只有 $O(\log n)$ 次，于是我们只需要每次找到下一次不在 $p, q$ 内的点，然后判断一下此时应该覆盖前缀还是后缀即可。

但是找 $p,q$ 内的点是比较麻烦的，因为 $p,q$ 一直在变。我们可以不严格找到所有 $p,q$ 之内的点，而是只考虑小于等于 $p,q$ 的最大的 $2$ 的幂 $x,y$，这样我们只要对每个可能的 $x,y$ 预处理出 $i \le x$ 或者 $i \ge n - y + 1$ 的 $i$ 或 $n-i+1$ 的前缀和与下一个 $x < i < n - y + 1$ 的位置，这样不在 $x,y$ 内的点仍然只有 $O(\log n)$ 个，这样我们就可以每次跳一整段，看跳完之后是否 $p,q$ 仍然不交，不交则找到新的 $x,y$ 然后继续跳，交了则二分找到段内什么时候开始相交，于是这部分就可以在 $O(m \log^2 n + q \log n)$ 的时间复杂度内解决了。

那么只需要把两部分拼在一起就做完这道题了。复杂度两个 $\log$。

有一些细节需要仔细考虑，大部分细节来自于操作时需要先把当前点修改为红色。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 120005, LOG = 18;
int n, m, T;
char s[MAXN];
int a[MAXN];
int px[MAXN], qx[MAXN], pc, qc, pi[MAXN], qi[MAXN];
int h(int x) { return x == 0 ? 0 : __lg(x) + 1; }
int nxt[LOG][LOG][MAXN];
long long ps[LOG][LOG][MAXN], qs[LOG][LOG][MAXN];
int preb[MAXN];
struct SegmentTree {
    vector<pair<int, int>> t[MAXN << 2];
#define lc (i << 1)
#define rc (i << 1 | 1)
    void build(int i = 1, int l = 1, int r = m) {
        if (l == r) {
            int v = a[l];
            if (v == n) t[i] = { { v - 1, v + 1 - n - 1 }, { n, v - n - 1 } };
            else if (n - v - 1 < v - 1) t[i] = { { n - v - 1, v + 1 }, { v - 1, v + 1 - n - 1 }, { n, v - n - 1 } };
            else t[i] = { { v - 1, v + 1 }, { n - v, v }, { n, v - n - 1 } };
            return;
        }
        int mid = (l + r) >> 1;
        build(lc, l, mid), build(rc, mid + 1, r);
        int L = 0;
        for (auto [R, v] : t[lc]) {
            auto it1 = lower_bound(t[rc].begin(), t[rc].end(), make_pair(L + v, INT_MIN));
            auto it2 = lower_bound(t[rc].begin(), t[rc].end(), make_pair(R + v, INT_MIN));
            for (auto it = it1; ; it++) {
                int rr = it == it2 ? R + v : it->first;
                t[i].push_back({ rr - v, v + it->second });
                if (it == it2) break;
            }
            L = R + 1;
        }
    }
    void query(int a, int b, int &v, int i = 1, int l = 1, int r = m) {
        if (a <= l && r <= b) {
            auto p = lower_bound(t[i].begin(), t[i].end(), make_pair(v, INT_MIN));
            v += p->second;
            return;
        }
        int mid = (l + r) >> 1;
        if (a <= mid) query(a, b, v, lc, l, mid);
        if (b > mid) query(a, b, v, rc, mid + 1, r);
    }
} st;
int main() {
    scanf("%d%d%s", &n, &m, s + 1);
    for (int i = 1; i <= m; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n + 1; i++) if (s[i] != 'R') px[++pc] = i - 1, pi[i - 1] = pc;
    for (int i = n; i >= 0; i--) if (s[i] != 'B') qx[++qc] = n - i, pi[n - i] = qc;
    for (int i = 1; i <= n; i++) preb[i] = preb[i - 1] + (s[i] == 'B');
    for (int x = 0; x < LOG; x++) {
        for (int y = 0; y < LOG; y++) {
            int X = x == 0 ? 0 : (1 << (x - 1));
            int Y = y == 0 ? 0 : (1 << (y - 1));
            nxt[x][y][m + 1] = m + 1;
            for (int i = m; i >= 1; i--) nxt[x][y][i] = (X < a[i] && a[i] < n + 1 - Y) ? i : nxt[x][y][i + 1];
            for (int i = 1; i <= m; i++) {
                ps[x][y][i] = (a[i] <= X ? a[i] : 0) + ps[x][y][i - 1];
                qs[x][y][i] = (a[i] > n - Y ? n - a[i] : 0) + qs[x][y][i - 1];
            }
        }
    }
    st.build();
    scanf("%d", &T);
    while (T--) {
        int l, r; scanf("%d%d", &l, &r);
        int p = 1, q = 1;
        int i = l - 1;
        int t = -1;
        auto Get = [&](int x) {
            if (x <= px[p]) return 'R';
            if (x > n - qx[q]) return 'B';
            return s[x];
        };
        while (1) {
            int x = h(px[p]), y = h(qx[q]);
            int j = min(nxt[x][y][i + 1], r + 1);
            int dp = min(ps[x][y][j - 1] - ps[x][y][i], 1ll * n);
            int dq = min(qs[x][y][j - 1] - qs[x][y][i], 1ll * n);
            if (px[min(pc, p + dp)] + qx[min(qc, q + dq)] < n) {
                p += dp, q += dq, i = j;
                if (j == r + 1) break;
                int bc = preb[n - qx[q]] - preb[px[p]] + qx[q], x = a[j] + (Get(a[j]) == 'B');
                if (x <= bc) {
                    if (x >= bc - qx[q]) { t = n - qx[q] + (x - (bc - qx[q])), l = j + 1; break; }
                    else p += x;
                } else {
                    int ac = n - bc, x = n - a[j] + (Get(a[j]) == 'R');
                    if (x >= ac - px[p]) { t = px[p] - (x - (ac - px[p])), l = j + 1; break; }
                    else q += x;
                }
            } else {
                int L = i + 1, R = j - 1;
                while (L < R) {
                    int mid = (L + R) >> 1;
                    int dp = min(ps[x][y][mid] - ps[x][y][i], 1ll * n);
                    int dq = min(qs[x][y][mid] - qs[x][y][i], 1ll * n);
                    if (px[min(pc, p + dp)] + qx[min(qc, q + dq)] < n) L = mid + 1;
                    else R = mid;
                }
                int dp = min(ps[x][y][L - 1] - ps[x][y][i], 1ll * n);
                int dq = min(qs[x][y][L - 1] - qs[x][y][i], 1ll * n);
                p += dp, q += dq, l = L + 1;
                int bc = preb[n - qx[q]] - preb[px[p]] + qx[q], x = a[L] + (Get(a[L]) == 'B');
                if (x <= bc) {
                    t = n - qx[q] + (x - (bc - qx[q]));
                } else {
                    int ac = n - bc, x = n - a[L] + (Get(a[L]) == 'R');
                    t = px[p] - (x - (ac - px[p]));
                }
                break;
            }
        }
        if (t == -1) {
            int ans = px[p] + n - qx[q] - px[p] - (preb[n - qx[q]] - preb[px[p]]);
            printf("%d\n", ans);
        } else {
            if (l <= r) st.query(l, r, t);
            printf("%d\n", t);
        }
    }
    return 0;
}
```

---

## 作者：qiuzx (赞：3)

## 题意

有一个长度为 $n$ 的字符串 $s$，每个字符为左箭头或右箭头。一次操作中将一个球放在位置 $x$，然后这个位置变成右箭头，接下来球重复向箭头所指方向移动一步，移动之后原位置的箭头反向，直到从左右两侧移出字符串为止。有 $m$ 个操作，第 $i$ 个操作的起点为 $a_i$。$q$ 次询问若从初始状态开始，依次执行 $l,l+1,\cdots,r$ 这些操作，最终的字符串中有多少个右箭头。$n,m,q\le 1.2\times 10^5$。

## 思路

先考虑 $q=1$ 怎么做。手玩一下小的情况容易发现一些基本的规律，若一次操作后球从左侧离开，那么最后一定是将一段前缀全部变成 `>`，其它不变。否则一定是将一段后缀全部变成 `<`，其它不变。下面不妨以从左侧离开为例先对这个过程做一个更加具体的分析。我们会从某个 $x$ 出发先向右走，直到某个 $r_1$，那么 $[x,r_1)$ 这些字符初始时全部为 `>`（初始指的是将 $s_x$ 变成 `>` 之后的字符串），且 $s_{r_1}$ 一定是 `<`。然后会向左走到 $l_1$，那么中间全是 `<`，但 $s_{l_1}$ 是 `>`。这样我们假设转向的位置依次为 $r_1,l_1,r_2,l_2,\cdots,l_{k-1},r_k$，那么初始时 $s_{r_i}$ 均为 `<`，$s_{l_i}$ 初始时均为 `>`，其它 $<x$ 的位置初始时均为 `<`，其它 $[x,r_k)$ 中的位置初始时均为 `>`。因此设 $k$ 为 $x$ 左侧的 `>` 个数，则可以将一次从左侧离开的操作看作将从 $x$ 开始向后的第 $k+1$ 个 `<` 之前的所有字符全部变成 `>`。

但这个表述方式不太好，因为它和左右两侧的字符个数都有关。注意到如果 $x$ 前面有 $l$ 个 `>`，那么可以看作将从字符串的最开始向后的第 $k+l+1$ 个 `<` 之前的部分都变成 `>`，而 $k+l=x-1$，所以相当于是从最左侧开始，把前 $x$ 个 `<` 变成 `>`。同理，如果是从右侧离开，那么相当于从最右侧开始，把前 $n-x+1$ 个 `>` 变成 `<`。注意这里均是先将 $s_x$ 变成 `>` 之后所做的操作。而要判定是从左侧还是右侧离开也是容易的，因为显然如果 `<` 有至少 $x$ 个那么 `>` 不会有超过 $n-x$ 个，所以这两种可能性只有一种是理论可以去做的，因此直接根据 `<` 和 `>` 的个数判定一下即可（例如 `<` 的个数至少为 $x$，则一定是从左边离开，因为若从右边离开那么至少要有 $n-x+1$ 个 `>` 才可以这么做）。

但动态地维护所有左右箭头的位置是没有什么很好的性质的，所以需要考虑一些更简便的维护方式。容易发现整个字符串在任意多次操作结束之后，总是形如左边一段 `>`，中间一段没有变的字符，右边一段 `<`。这样只需要维护左右两段的长度，就容易 $O(1)$ 进行一次操作。具体地，预处理出所有 `<` 和 `>` 出现的位置，然后用两个指针 $l,r$ 分别维护第一个 `<` 和最后一个 `>` 的位置，则 $[l,r]$ 表示的就是中间这部分的区间。不妨设当前操作将前 $k$ 个 `<` 变成 `>`，则相当于将 $l$ 在所有 `<` 的出现位置中向后跳 $k$ 步，如果跳完之后仍然 $\le r$ 则说明没有用完中间的 `<`，因此此时维护的信息仍然是准确的。但问题在于可能出现 $l>r$ 的情况，即此时中间部分全部被替换了，此时就不能用原来的 `<` 和 `>` 的位置信息来处理了。那么对于这种情况，发现只需要维护前缀 `>` 的个数即可，而讨论一下可以发现，若当前前缀有 $x$ 个 `>`，且这一次对 $y$ 位置进行操作，那么若 $x<y$，则操作过后 $x$ 变成 $(x+y+1)\bmod (n+1)$，否则 $x$ 变成 $(x+y)\bmod (n+1)$。这样这也是可以 $O(1)$ 维护的。

这样我们得到了一个 $O(mq)$ 的做法，不过这个过程看起来不是很好优化了，所以我们需要进一步来分析这个过程的性质。首先这个过程有两个阶段，第一个阶段中中间部分仍然保留，第二个阶段是中间被替换完了的情况。从第一阶段向第二阶段转化的这一步可以用上面的暴力 $O(1)$ 做一下，所以只需要快速处理两个阶段，以及找到阶段转化的时刻即可。

先考虑第二阶段，此时可以将每个操作看成一个分段的一次函数，而我们需要查询一段区间内所有函数的复合 $f(x)$ 对于某个 $x$ 的函数值。则一个想法就是直接线段树维护分段函数，但关键在于怎么合并两个分段函数。这个看起来很困难，不过发现我们只需要在建树的时候合并，不需要在查询的时候合并。因为我们不关心 $f(x)$ 到底是什么，只关心对于一个特定的 $x$ 的函数值，那么假如已经求出了所有区间内的分段函数，那么直接在这些分段函数上面依次二分即可在 $O(\log^2m)$ 的时间内做一次查询。所以下面我们只关心如何在初始状态中合并两个函数。

对于两个分别分为 $a,b$ 段的函数，容易在 $c+a\log b$ 的时间内完成合并，其中 $c$ 为合并之后的段数。所以我们希望能够对每个区间内的函数的复合的段的数量有一个合理的估计。发现这里的分段函数有很好的性质就是在一个单点处的两段只有在端点处一个位置的函数值是一样的。这意味着往一个复合的分段函数里面再加一个单点的分段函数，会在这个分段点处切成两段，然后只会增加 $O(1)$ 个其它的点，所以 $a$ 个点的分段函数的复合的大小是 $O(a)$ 的，这样在建树时处理出每个区间的函数就只需要 $O(m\log^2m)$ 的时间，因此做第二阶段的总复杂度为 $O(m\log^2m+q\log^2m)$。

下面考虑第一阶段，这个阶段需要对操作位置的具体信息进行讨论，所以不好直接像第二阶段一样写成函数的形式来维护。但发现有一种操作是好做的，就是如果我们操作的位置不在中间没有被动过的那一段中，那么除非这一次操作完了之后进入了第二阶段，这两侧是独立的（即在第一段中的操作一定从左边出去，在第二段中的操作一定从右边出去）。原因很显然，就是因为我们操作之后中间没有被覆盖，但是我们所有经过的位置都一定是最后被改变的，所以如果跨越了段那么一定需要覆盖中间一段，因此矛盾。这样如果全部都是这一类操作，只需要根据元素在哪一段进行讨论，剩下的就只是一个简单的加法了，这个容易通过前缀和来维护。

这个想法有两个问题，第一，不是所有操作都满足这个性质，第二，怎么样才能将操作正确地分给左右两侧进行处理。为了解决第二个问题，只能将上面这个想法做一个弱化，即固定一对 $L,R$，然后对于所有要么满足 $a_i\le L$，要么满足 $a_i\ge R$ 的操作，可以直接用前缀和快速处理。虽然我们找到的第一个满足 $L<a_i<R$ 的点可能实际上仍然处于左右两段中，但我们不予考虑，而是暴力来进行处理。这样找到第一个这样的点之后暴力处理，然后更新 $L,R$ 继续做，就充分利用了上述性质。

然而我们仍然有需要暴力处理的部分，那么这个部分怎么优化呢？好像这个部分没有任何的性质，因为我们既无法判定它离开的方向，也无法求出它对维护的两个指针的影响。但我们再回顾一下一次操作干的事情，对于一次在 $x$ 的从左侧离开的操作，会将前 $x$ 个 `<` 变成 `>`。这意味着如果 $x$ 很大，那么会有很多的 `<` 都加入到第一段前缀中，这样的一次暴力会使得上一个优化中的 $L$ 增大很多，所以看起来不会做很多次这样的暴力。具体来说，由于我们做暴力的时候一定有 $a_i>L$，所以此时至少会将 $L$ 个 `<` 变成 `>`，那么 $L$ 至少会变成 $2L$，即增加一倍！类似地若从右侧离开，则 $n-R$ 也至少会增加一倍。特别地，若 $L=0$ 或 $R=n$，则它们至少会变成 $1$。所以一次操作要么使得 $L$ 翻倍要么使得 $R$ 翻倍，因此暴力只会做 $O(\log n)$ 次。

这样就可以有一个低于平方的复杂度的做法了。我们从第一阶段开始，动态维护 $L,R$，然后每次需要找到当前位置后面的第一个满足 $L<a_i<R$ 的 $a_i$，处理出这段区间内 $\le L$ 和 $\ge R$ 的 $a_i$ 之和，分别加到指针 $l$ 和 $r$ 上。如果出现了 $l>r$ 的情形则说明在这一段中进入了第二阶段，那么二分这个时刻，则因为这一段全是 $\le L$ 或 $\ge R$ 的操作，可以直接用前缀和求出某个时刻的 $l,r$ 的值，由于 $l,r$ 有单调性，所以可以直接二分出进入第二阶段的时刻。如果没有进入第二阶段，则将这一段先全加到 $l,r$ 上，然后暴力做 $i$ 这个操作并更新 $L,R$。这样做需要用树套树或主席树来支持查询 $i$ 以及区间的和，复杂度 $O(\log^2m)$，但这样的操作需要做 $O(\log n)$ 次，且常数很大，所以不太能接受。

下面令 $R$ 为上面做法中的 $n-R$。发现问题在于每次的 $L,R$ 不同非常难受，这使得需要做的查询次数有 $O(q\log n)$ 次之多。那我们能不能采用类似分块的想法，预处理一些 $L,R$ 的信息然后每次取比实际的 $L,R$ 略小的预处理的 $L,R$ 来做呢？发现直接用根号分块显然是不太行的，因为这样需要处理的信息有 $O(nm)$ 个。由于我们关键的性质在于每次 $L,R$ 翻倍，所以一个自然的想法就是使用二进制分组。具体来说，我们对于所有 $L=2^x,R=2^y$，和每个 $i$，处理出 $nxt_{L,R,i}$ 表示 $i$ 的下一个满足 $L<a_j<n-R$ 的 $j$，同时令 $sr,sb_{L,R,i}$ 分别表示前 $i$ 个位置中 $\le L$ 和 $\ge R$ 的 $a_i$ 之和。这个预处理可以在 $O(m\log^2n)$ 的时间内完成。则这样在实际过程中取 $\le$ 实际的 $L,R$ 的最大的 $2^x$ 和 $2^y$，仍然具有翻倍的性质，即一次暴力后 $x$ 或 $y$ 至少会增加 $1$。而此时处理一段时需要的信息全部可以 $O(1)$ 通过预处理的信息求出，所以这部分复杂度变为 $O(q(\log n+\log m))$。这样就解决了原问题，复杂度 $O(m\log^2m+q\log^2m+m\log^2n)$。

[代码](https://www.luogu.com.cn/paste/qr9t8rnv)

---

## 作者：Henry__Chen (赞：3)

对于特定的状态与 $A_j=x$，考虑操作会对状态产生哪些影响。

先考虑向左出边界，向右出边界显然是对称的。

首先不难发现，会存在一段前缀，使得操作过后全是红色，而分界点之后的部分的状态不会改变。同时球在左右移动的过程中，必然满足向左与向右的移动步数之差为 $x$，而球仅在一段前缀上运动，结果使得前缀的所有蓝色变为红色。将蓝色变为红色显然对步数之差的贡献为 $1$，因此，每次操作会使前 $x$ 个蓝色光带变为红色。

当蓝色光带不足 $x$ 时，显然球会向右边移动，对状态的改变同理。

考虑第 $5$ 个子任务，即前缀为一段红色，剩余部分为蓝色。

在该种情况下，每一次操作只会改变红蓝分隔点的位置，因为每次操作只会把前缀的蓝色变为红色，或后缀的红色变为蓝色。因此，我们只需记录当前状态下的红色光带个数 $y$。

- $x \le y$ 时，此时球在红色光带上
  - $x < N - y$ 时，向右出边界，$y\gets y-(N + 1 -x)$
  - $x \ge N - y$ 时，向左出边界，$y\gets y+x$
- $x > y$ 时，此时球在蓝色光带上，会额外多出一条红色光带
  - $x < N - y$ 时，向右出边界，$y\gets y-(N+1-x)+1$
  - $x \ge N - y$ 时，向左出边界，$y\gets y+x+1$

综上
$$
\begin{cases}
y\gets (x + y)\bmod (N + 1) & x \le y\\
y\gets (x + y + 1)\bmod (N + 1) & x > y
\end{cases}
$$

至此，对于每个 $A_i$ 而言，我们可以处理出 $y$ 在某一个区间中会增加的值。这个东西显然是可以合并的，用线段树维护可以做到 $\mathcal O(M\log^2 M)$。

> 证明：
>
> 不失一般性，设 $M = 2^m$，此时线段树有 $m + 1$ 层，自上向下的节点数依次为 $2^0, 2^1, \cdots, 2^m$。
>
> 对于第 $m$ 层的节点，其分段函数的段数为 $2$（即每个 $A_i$ 的状态），向上归纳不难得到：对于第 $i$ 层的节点，其分段函数的段数不超过 $2^{m - i + 1}$。则整棵线段树的总段数不超过
$$
\sum_{i=0}^m 2^i\times 2^{m - i + 1}=\sum_{i = 0}^m2^{m + 1}=m2^{m  + 1}=\mathcal O(M \log M)
$$
> 在节点合并的过程中，我们需要二分查找分隔点，故此处的时间复杂度为 $\mathcal O(M \log^2 M)$。

对于一般的情况，不难发现在做一些操作之后，状态会转变为子任务 $5$ 的形态，因此只需处理红蓝没有相遇的情况，设前缀开始的红色长度为 $a$，末尾开始的蓝色长度为 $b$，同时设前缀有 $L$ 个蓝色变为了红色，后缀有 $R$ 个红色变为了蓝色。对于一次操作，会存在 $3$ 种情况

- $x \le a\implies L\gets L+x$
- $x \ge N - b + 1\implies R \gets R+(N-x)$
- $ a < x < N - b + 1$，此时必然有 $a'\ge 2a$ 或 $b'\ge 2b$，即这种情况不超过 $\log N$ 次。

对于前两种情况，我们可以令 $a'=\text{highbit}(a), b'=\text{highbit}(a)$，在此基础上求出满足条件的前缀和，查询时二分查找是否红蓝相遇；对于第三种情况，可以直接 $\mathcal O(1)$ 更新状态。

可以做到在线，时间复杂度 $\mathcal O\left(M\left(\log^2 M + \log^2 N\right)+Q \log N\left(\log N+\log M\right)\right)$。


---


# 幼儿园篮球题

## 题目背景

众所周知，全民制作幼儿园园龄两年半的蔡徐坤同学喜欢唱、跳、rap 和篮球。而作为欧文的老师，他的篮球技术自然比 ikun 们要强得多。

## 题目描述

全民制作幼儿园的蔡徐坤专属篮球场上总共有 $N$ 个蔡徐坤专属篮球，而其中有 $M$ 个是没气的。鉴于蔡徐坤的高超技术，他投**没气的球一定能进**，而投**有气的球一定不能**。

蔡徐坤举办了 $S$ 场巡回篮球表演，第 $i$ 场表演 ikun 们会指定投球个数 $k_i$ ，ikun 们会从 $N$ 个蔡徐坤专属篮球中准备 $n_i$ 个球放在场地上，其中恰好有 $m_i$ 个是没气的。蔡徐坤会在这 $n_i$ 个蔡徐坤专属篮球中**随机**选出 $k_i$ 个投篮。如果投进了 $x$ 个，则这次表演的**失败度**为 $x^L$。ikun 们想知道这 $S$ 场表演的**期望失败度**对 $998244353$ 取模的结果。篮球表演之间**相互独立**。

## 说明/提示

对于样例，我们作出如下解释：设失败度为 $X$，蔡徐坤有 $\frac{1}{3}$ 的概率投进 $2$ 个，有 $\frac{2}{3}$ 的概率投进 $1$ 个，期望失败度为 $E(x)=\frac{2^3}{3}+\frac{1^3*2}{3}=\frac{10}{3}$，$\frac{10}{3}\equiv 332748121\pmod{998244353}$。

子任务 1 ($15\%$)：$1\leq L\leq2$。

子任务 2 ($10\%$)：$1\leq N\leq10^5$。

子任务 3 ($75\%$)：无特殊限制。

对于全部数据，$1\leq S\leq200$，$1\leq L\leq2\times 10^5$，$1\leq M\leq N\leq2\times 10^7$。并且对于 $1\leq i\leq S$，有 $1\leq m_i,k_i\leq n_i\leq N$，$1\leq m_i\leq M$。

## 样例 #1

### 输入

```
3 2 1 3
3 2 2```

### 输出

```
332748121```

# 题解

## 作者：λᴉʍ (赞：73)


我喜欢唱♂跳♂rap♂篮球

要求的是：$\sum_{i=0}^kC_m^iC_{n-m}^{k-i}i^L$

这个$i^L$很烦，就把第二类斯特林数的式子套进去

$\sum_{i=0}^kC_m^iC_{n-m}^{k-i}i^L$

$\sum_{i=0}^kC_m^iC_{n-m}^{k-i}\sum_{j=0}^iC_{i}^j\begin{Bmatrix}L\\j\end{Bmatrix}j!$

$\sum_{j=0}^k\begin{Bmatrix}L\\j\end{Bmatrix}j!\sum_{i=j}^kC_m^iC_{n-m}^{k-i}C_{i}^j$

后面$\sum$三个组合数好像很不好搞，但是$C_{m}^{i}C_{i}^{j}=C_{m}^{j}C_{m-j}^{i-j}$，可以拆出一个与$i$无关的组合数

$\sum_{j=0}^k\begin{Bmatrix}L\\j\end{Bmatrix}j!C_{m}^{j}\sum_{i=j}^kC_{m-j}^{i-j}C_{n-m}^{k-i}$

把式子化的好看一点，发现可以套范德蒙德卷积（$\sum_{i=0}^kC_{n}^{i}C_{m}^{k-i}=C_{n+m}^k$）

$\sum_{j=0}^k\begin{Bmatrix}L\\j\end{Bmatrix}j!C_{m}^{j}\sum_{i=0}^kC_{m-j}^{k-i-j}C_{n-m}^{i}$ 

$\sum_{j=0}^k\begin{Bmatrix}L\\j\end{Bmatrix}j!C_{m}^{j}C_{n-j}^{k-j}$ 

注意上面循环$i$的上界实际上是$\min(k,L,m)=O(L)$

求出$n=L$的一行第二类斯特林数，每次询问就可以$O(L)$了

把组合数全拆出来约分就洛谷rk1了= =

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
#define mod 998244353
#define poly std::vector<int>
typedef long long ll;
il ll gi(){
    ll x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))f^=ch=='-',ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return f?x:-x;
}
il int pow(int x,int y){
    int ret=1;
    while(y){
        if(y&1)ret=1ll*ret*x%mod;
        x=1ll*x*x%mod;y>>=1;
    }
    return ret;
}
#define maxn 524289
poly pA,pB;
int rev[maxn],_lstN,P[maxn],iP[maxn];
il vd ntt(int*A,int N,int t){
    for(int i=0;i<N;++i)if(rev[i]>i)std::swap(A[i],A[rev[i]]);
    for(int o=1;o<N;o<<=1){
        int W=t?P[o]:iP[o];
        for(int*p=A;p!=A+N;p+=o<<1)
            for(int i=0,w=1;i<o;++i,w=1ll*w*W%mod){
                int t=1ll*w*p[i+o]%mod;
                p[i+o]=(p[i]-t+mod)%mod;p[i]=(p[i]+t)%mod;
            }
    }
    if(!t){
        int inv=pow(N,mod-2);
        for(int i=0;i<N;++i)A[i]=1ll*A[i]*inv%mod;
    }
}
int N,lg;
il vd setN(int n){
    N=1,lg=0;
    while(N<n)N<<=1,++lg;
    if(N!=_lstN)for(int i=0;i<N;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<lg-1);
}
il vd ntt(poly&a,int t){
    static int A[maxn];
    for(int i=0;i<a.size();++i)A[i]=a[i];memset(A+a.size(),0,4*(N-a.size()));
    ntt(A,N,t);
    a.resize(N);
    for(int i=0;i<N;++i)a[i]=A[i];
    int s=a.size();while(s&&!a[s-1])--s;
    a.resize(s);
}
il poly mul(poly a,poly b,int newn=-1){
    if(newn==-1)newn=a.size()+b.size()-1;
    setN(a.size()+b.size()-1);
    ntt(a,1),ntt(b,1);
    for(int i=0;i<N;++i)a[i]=1ll*a[i]*b[i]%mod;
    ntt(a,0);a.resize(newn);
    return a;
}
il poly operator+(poly a,const poly&b){
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0;i<a.size();++i)if(i<b.size())a[i]=(a[i]+b[i])%mod;
    return a;
}
il poly operator-(poly a,const poly&b){
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0;i<a.size();++i)if(i<b.size())a[i]=(a[i]-b[i]+mod)%mod;
    return a;
}
il poly operator*(poly a,int b){
    for(auto&i:a)i=1ll*i*b%mod;
    return a;
}
il poly qiudao(poly a){
    for(int i=0;i<a.size()-1;++i)a[i]=1ll*a[i+1]*(i+1)%mod;
    a.erase(a.end()-1);
    return a;
}
il poly jifen(poly a){
    a.insert(a.begin(),0);
    for(int i=1;i<a.size();++i)a[i]=1ll*a[i]*pow(i,mod-2)%mod;
    return a;
}
il poly getinv(poly a){
    if(a.size()==1)return poly(1,pow(a[0],mod-2));
    int n=a.size(),m=a.size()+1>>1;
    poly _a(m);
    for(int i=0;i<m;++i)_a[i]=a[i];
    poly b=getinv(_a);
    setN(n+m*2-2);
    ntt(a,1);ntt(b,1);
    for(int i=0;i<N;++i)a[i]=1ll*a[i]*b[i]%mod*b[i]%mod;
    ntt(a,0),ntt(b,0);
    a.resize(n);
    return b*2-a;
}
il poly getln(poly a,int n=-1){
    if(n==-1)n=a.size();
    a.resize(n);
    return jifen(mul(qiudao(a),getinv(a),n));
}
il poly getexp(poly a){
    if(a.size()==1)return a[0]=1,a;
    int n=a.size(),m=a.size()+1>>1;
    poly _a(m);
    for(int i=0;i<m;++i)_a[i]=a[i];
    poly b=getexp(_a);
    return mul(b,poly(1,1)-getln(b,a.size())+a,a.size());
}
il poly operator^(poly a,int b){
    int n=a.size();
    a=getexp(getln(a)*b);a.resize(n);
    return a;
}
il poly sqrt(poly a){
    if(a.size()==1)return a;
    int n=a.size(),m=a.size()+1>>1;
    poly _a(m);
    for(int i=0;i<m;++i)_a[i]=a[i];
    poly b=sqrt(_a);b.resize(n);
    return (b+mul(a,getinv(b),n))*(mod+1>>1);
}
il vd poly_init(){
    int G=3,iG=332748118;
    for(int i=1;i<maxn;i<<=1)P[i]=pow(G,(mod-1)/(i<<1)),iP[i]=pow(iG,(mod-1)/(i<<1));
}
il vd add(int&a,int b){a=a+b>=mod?a+b-mod:a+b;}
int fact[20000010],ifact[20000010];
int pr[4000010],Pr,PL[20000010];
bool yes[20000010];
int main(){
#ifdef XZZSB
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    poly_init();
    int N=gi(),M=gi(),S=gi(),L=gi(),o=std::max(N,L);
    fact[0]=1;for(int i=1;i<=o;++i)fact[i]=1ll*i*fact[i-1]%mod;
    ifact[o]=pow(fact[o],mod-2);for(int i=o-1;~i;--i)ifact[i]=1ll*ifact[i+1]*(i+1)%mod;
    PL[0]=0,PL[1]=1;
    for(int i=2;i<=L;++i){
        if(!yes[i])pr[++Pr]=i,PL[i]=pow(i,L);
        for(int j=1;j<=Pr&&i*pr[j]<=L;++j){
            yes[i*pr[j]]=1;
            PL[i*pr[j]]=1ll*PL[pr[j]]*PL[i]%mod;
            if(i%pr[j]==0)break;
        }
    }
    poly f(L+1),g(L+1);
    for(int i=0,mul=1;i<=L;++i,mul=mod-mul)f[i]=1ll*mul*ifact[i]%mod;
    for(int i=0;i<=L;++i)g[i]=1ll*PL[i]*ifact[i]%mod;
    f=mul(f,g,L+1);
    while(S--){
        int n=gi(),m=gi(),k=gi(),ans=0,o=std::min(k,std::min(m,L));
        for(int i=0;i<=o;++i)
            ans=(ans+1ll*f[i]*ifact[m-i]%mod*fact[n-i]%mod*ifact[k-i])%mod;
        printf("%d\n",1ll*ans*fact[m]%mod*fact[k]%mod*ifact[n]%mod);
    }
    return 0;
}
```

---

## 作者：SSerxhs (赞：41)

注意：题解所用变量名称和题目中是**不同**的

题意：给定系数 $k$，多组询问超几何分布 $x$~$H(n,M,N)$ 的 $k$ 次方期望 $E(x^k)$。

难度定位：简单紫题，文化课选手应该能秒。

前两档部分分分别是套课本期望方差公式和直接暴力枚举投进几个球，用超几何分布公式计算。

超几何分布中， $P(x=i)=\frac{\tbinom{M}{i}\tbinom{N-M}{n-i}}{\tbinom{N}{n}}$

所以
$$ans=\sum_{i=0}^ni^k*\frac{\tbinom{M}{i}\tbinom{N-M}{n-i}}{\tbinom{N}{n}}=\sum_{i=1}^ni^k*\frac{\tbinom{M}{i}\tbinom{N-M}{n-i}}{\tbinom{N}{n}}$$

考虑 $i^k$ 的组合意义是将 $k$ 个**不同**的球放入 $i$ 个**不同**的盒子中的方案数，设 $S_2(k,j)$ (第二类斯特林数)表示把 $k$ 个**不同**的球放入 $j$ 个**相同**的盒子且要求**盒子非空**的方案数，考虑枚举**非空盒子**数目 $j$ 那么显然有

$$i^k=\sum_{j=0}^iS_2(k,j)j!\tbinom{i}{j}$$

代入题中式子可以得到

$$\sum_{i=1}^ni^k\frac{\tbinom{M}{i}\tbinom{N-M}{n-i}}{\tbinom{N}{n}}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $$

$$=\frac{\sum_{i=1}^n\tbinom{M}{i}\tbinom{N-M}{n-i}\sum_{j=0}^kS_2(k,j)j!\tbinom{i}{j}}{{\tbinom{N}{n}}}$$

交换求和次序

$$=\frac{\sum_{j=0}^kS_2(k,j)j!\sum_{i=1}^n\tbinom{M}{i}\tbinom{i}{j}\tbinom{N-M}{n-i}}{{\tbinom{N}{n}}}$$

考虑 $\tbinom{M}{i}\tbinom{i}{j}$ 的组合意义是从 $M$ 个人中选出 $i$ 个参加比赛的，再从 $i$ 个人中选出 $j$ 个获奖。

那么我们可以先硬点 $j$ 个人获奖，然后选 $i-j$ 个人~~爆 $0$~~

可以得到 $\tbinom{M}{i}\tbinom{i}{j}=\tbinom{M}{j}\tbinom{M-j}{i-j}$ 

因此原式化为下式（与 $i$ 无关扔前面）

$$\ \ \ \ \ \ \ =\frac{\sum_{j=0}^kS_2(k,j)j!\tbinom{M}{j}\sum_{i=1}^n\tbinom{M-j}{i-j}\tbinom{N-M}{n-i}}{{\tbinom{N}{n}}}$$

后面这玩意是一个范德蒙德卷积，进一步化简

$$=\frac{\sum_{j=0}^kS_2(k,j)j!\tbinom{M}{j}\tbinom{N-j}{n-j}}{{\tbinom{N}{n}}}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $$

这样只要知道 $S_2(k,j)$ 就可以 $O(k)$ 计算答案了，而$O(qk)$的复杂度是可以通过这题的。

考虑第二类斯特林数 $S_2(k,j)$ 的组合意义，利用容斥原理可以得到

$$S_2(k,j)=\frac{1}{j!}\sum_{i=0}^j(-1)^i(j-i)^k\tbinom{j}{i}=\sum_{i=0}^j\frac{(-1)^i(j-i)^k}{i!(j-i)!}$$

设生成函数 $f(x)=\sum_i(-1)^ii!*x^i,g(x)=\sum_i\frac{i^k}{i!}*x^i$，显然对于一个给定的 $k$，$S_2(k,j)$ 为 $f*g$ 中 $x^j$ 的系数，可以 $O(k+N)$ 计算 $f(x),g(x)$ （可以用线性筛处理 $i^k$ )，然后 $\text{NTT}$ 就可以 $O(klog_2k+N)$ 计算所需要的第二类斯特林数，从而计算出结果。总复杂度 $O(N+k(q+log_2k))$。

代码
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=5.5e5,M=2e7+2,p=998244353;
int f[N],g[N],r[N],yg[N],ig[N],ifac[M],fac[M],ss[N],mc[N];
int c;
inline int ksm(register int x,register int y)
{
    register int r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        x=(ll)x*x%p;
        y>>=1;
    }
    return r;
}
void dft(register int *a,register int xs,register int limit)
{
    register int i,j,k,l,w,wn,b,c;
    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);
    for (i=1;i<limit;i=l)
    {
        l=i<<1;
        if (xs) wn=ig[l]; else wn=yg[l];
        for (j=0;j<limit;j+=l)
        {
            w=1;
            for (k=0;k<i;k++,w=(ll)w*wn%p)
            {
                b=a[j|k];c=(ll)w*a[j|k|i]%p;
                a[j|k]=(b+c)%p;
                a[j|k|i]=(b-c+p)%p;
            }
        }
    }
    if (xs)
    {
        limit=ksm(limit,p-2);
        for (i=0;i<xs;i++) a[i]=(ll)a[i]*limit%p;
    }
}
inline void read(int &x)
{
    c=getchar();
    while ((c<48)||(c>57)) c=getchar();
    x=c^48;c=getchar();
    while ((c>=48)&&(c<=57))
    {
        x=x*10+(c^48);
        c=getchar();
    }
}
int main()
{
    register int n,m,q,k,i,j,x,limit=1,l=0,gs=0;
    read(n);read(c);read(q);read(k);
    while (limit<=k) limit<<=1,++l;
    n=max(n,limit-1);
    limit<<=1;
    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;
    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);
    for (i=limit>>1;i;i>>=1)
    {
        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;
        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;
    }
    l=limit>>1;ifac[0]=ifac[1]=fac[0]=fac[1]=1;
    for (i=2;i<=n;i++) ifac[i]=p-(ll)p/i*ifac[p%i]%p,fac[i]=(ll)fac[i-1]*i%p;
    for (i=2;i<=n;i++) ifac[i]=(ll)ifac[i-1]*ifac[i]%p;
    mc[1]=1;
    for (i=2;i<l;i++)
    {
        if (!mc[i]) mc[ss[++gs]=i]=ksm(i,k);
        for (j=1;(j<=gs)&&(i*ss[j]<l);j++)
        {
            mc[i*ss[j]]=(ll)mc[i]*mc[ss[j]]%p;
            if (i%ss[j]==0) break;
        }
    }
    for (i=0;i<l;i++) if (i&1) f[i]=p-ifac[i]; else f[i]=ifac[i];
    for (i=1;i<l;i++) g[i]=(ll)ifac[i]*mc[i]%p;
    dft(f,0,limit);dft(g,0,limit);
    for (i=0;i<limit;i++) f[i]=(ll)f[i]*g[i]%p;
    dft(f,l,limit);
    while (q--)
    {
        read(n);read(m);read(x);
        j=0;
        for (i=min(min(x,m),k);i;i--) j=(j+(ll)f[i]*ifac[m-i]%p*fac[n-i]%p*ifac[x-i])%p;
        printf("%d\n",int((ll)j*ifac[n]%p*fac[x]%p*fac[m]%p));
    }
}
```


update：由于时限缩短，此代码已经无法通过此题。请使用高效的阶乘/阶乘逆元预处理手段。

---

## 作者：Rorschachindark (赞：17)

# 幼儿园篮球题
[题目传送门](https://www.luogu.com.cn/problem/P2791)
## 思路
不难发现，我们要求的答案实际上是这个东西:

$$\frac{\sum_{i=0}^{k} i^{L}\binom{m}{i} \binom{n-m}{k-i}}{\binom{n}{k}}$$

于是，我们只需求到分子即可。我们开始愉快的化式子了。

$$\sum_{i=0}^{k} i^L \binom{m}{i} \binom{n-m}{k-i}$$

我们发现里面难搞的其实是$i^L$，但是我们又有式子：

$$n^m=\sum_{i=0}^{n} \binom{n}{i} i!\begin{Bmatrix} m \\ i\end{Bmatrix}$$

对于这个式子的感性证明就是：假设我们现在有$m$个小球，要放进$n$个盒子里面，没有限制，显然它等于$n^m$。但是，我们还有一种求法，即，我们选出$i$个盒子放$m$个小球，显然要选出$i$个盒子，然后把$m$个小球塞进去，又因为盒子不同，所以还要乘上$i!$。

将上式代入式子中，可以得到:

$$=\sum_{i=0}^{k} \binom{m}{i} \binom{n-m}{k-i} \sum_{j=0}^{i} \binom{i}{j} j! \begin{Bmatrix} L\\ j\end{Bmatrix}$$

$$=\sum_{j=0}^{k} \begin{Bmatrix} L\\ j\end{Bmatrix} j!\sum_{i=j}^{k} \binom{i}{j} \binom{m}{i} \binom{n-m}{k-i}$$

又因为

$$\binom{m}{i} \binom{i}{j}=\binom{m}{j} \binom{m-j}{i-j}$$

这个式子展开之后易证。

所以原式等于:

$$=\sum_{j=0}^{k} \begin{Bmatrix} L\\ j\end{Bmatrix} j! \binom{m}{j} \sum_{i=j}^{k} \binom{m-j}{i-j}\binom{n-m}{k-i}$$

$$=\sum_{j=0}^{k} \begin{Bmatrix} L\\ j\end{Bmatrix} j! \binom{m}{j} \sum_{i=0}^{k-j} \binom{m-j}{i}\binom{n-m}{k-i-j}$$

然后你发现后面那个式子是范德蒙德卷积，就等于:

$$\binom{n-j}{k-j}$$

所以原式等于:

$$=\sum_{j=0}^{k} \begin{Bmatrix} L\\ j\end{Bmatrix}j!\binom{m}{j}\binom{n-j}{k-j}$$

又因为上面提到的$n^m=\sum_{i=0}^{n} \binom{n}{i} i!\begin{Bmatrix} m \\ i\end{Bmatrix}$，这个东西我们可以使用二项式反演得到：

$$\begin{Bmatrix} m \\ n\end{Bmatrix}=\sum_{i=0}^{n} \frac{i^m}{i!} \frac{(-1)^{n-i}}{(n-i)!}$$

然后你就发现这是个卷积形式，于是我们就可以$\Theta(L\log L)$预处理出$\begin{Bmatrix} L \\ j\end{Bmatrix}$。

不过因为这道题十分卡常，所以我们还需要再化一下式子。

$$\text {ans}=\frac{\sum_{j=0}^{k}\begin{Bmatrix} L \\ j\end{Bmatrix} j!\binom{m}{j} \binom{n-j}{k-j}}{\binom{n}{k}}$$

$$=(\sum_{j=0}^{k} \begin{Bmatrix} L \\ j\end{Bmatrix} j! \frac{m!}{j!(m-j)!} \frac{(n-j)!}{(k-j)!(n-k)!})\frac{k!(n-k)!}{n!}$$

$$=(\sum_{j=0}^{k} \begin{Bmatrix} L \\ j\end{Bmatrix} \frac{(n-j)!}{(m-j)!(k-j)!})\frac{k!m!}{n!}$$

我们又发现上界其实是$\min\{n,k,L\}$，所以至此，我们可以$\Theta(L\log L+SL)$解决此题目。

不得不说这道题真的卡常:

![](https://cdn.luogu.com.cn/upload/image_hosting/gfvry8si.png)

## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXX 20000005
#define mod 998244353
#define Gi 332748118
#define MAXN 800005
#define G 3 

int quick_pow (int a,int b,int c){
	int res = 1;
	while (b){
		if (b & 1) res = 1ll * res * a % c;
		a = 1ll * a * a % c;
		b >>= 1;
	}
	return res;
}

int l,limit,r[MAXN];

void NTT (int *a,int type){
	for (Int i = 0;i < limit;++ i)
		if (i < r[i]) swap (a[i],a[r[i]]);
	for (Int mid = 1;mid < limit;mid <<= 1){
		int Wn = quick_pow (type == 1 ? G : Gi,(mod - 1) / (mid << 1),mod);
		for (Int R = mid << 1,j = 0;j < limit;j += R){
			int w = 1;
			for (Int k = 0;k < mid;++ k,w = 1ll * w * Wn % mod){
				int x = a[j + k],y = 1ll * w * a[j + k + mid] % mod;
				a[j + k] = (x + y) % mod,a[j + k + mid] = (x + mod - y) % mod;
			} 
		} 
	}
	if (type == 1) return ; 
	int Inv = quick_pow (limit,mod - 2,mod);
	for (Int i = 0;i < limit;++ i) a[i] = 1ll * a[i] * Inv % mod;
}

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int N,M,S,L;
int A[MAXN],B[MAXN];

int inv[MAXX],fac[MAXX];

void SiteLin (int n){
	for (Int i = 0;i <= n;++ i){
		A[i] = (i & 1) ? mod - inv[i] : inv[i];
		B[i] = 1ll * quick_pow (i,n,mod) * inv[i] % mod;
	}
	limit = 1,l = 0;
	while (limit <= (n << 1)) limit <<= 1,l ++;
	for (Int i = 0;i < limit;++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l - 1);
	NTT (A,1),NTT (B,1);
	for (Int i = 0;i < limit;++ i) A[i] = 1ll * A[i] * B[i] % mod;
	NTT (A,-1);
}

int C (int n,int m){
	return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;
}

signed main(){
	read (N,M,S,L);
	inv[0] = inv[1] = fac[0] = 1;int uu = max (N,L);
	for (Int i = 1;i <= uu;++ i) fac[i] = 1ll * fac[i - 1] * i % mod;
	inv[uu] = quick_pow (fac[uu],mod - 2,mod);
	for (Int i = uu - 1;~i;-- i) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;
	SiteLin (L);
	while (S --){
		int n,m,k;
		read (n,m,k);int ans = 0;
		for (Int i = 0;i <= min (L,min (m,k));++ i) ans = (ans + 1ll * A[i] * inv[m - i] % mod * fac[n - i] % mod * inv[k - i]) % mod;
		write (1ll * ans * fac[m] % mod * fac[k] % mod * inv[n] % mod),putchar ('\n');
	}
	return 0;
}
```

---

## 作者：xgzc (赞：16)

上了文化课之后终于知道“超几何分布”的准确定义了，这时候再回来看这题，突然灵光一闪，想到了一个新的解法。

超几何分布：$n$ 个物品中，$m$ 个次品，不放回抽取的 $k$ 个物品中有 $x$ 个次品的概率 $P(x = i) = \dfrac {\binom mi \binom {n - m} {k - i}} {\binom nk}$。

那么其概率生成函数为 $P(x) = \dfrac {\sum_{i} \binom mi \binom{n-m}{k-i} x^i} {\binom nk}$。

加入辅助变量 $y$，可得 $P(x) = \dfrac {[y^k] (1 + xy)^m(1 + y)^{n - m}} {\binom nk}$

由定义可知，$E(x^{\underline k}) = P^{(k)}(1)$。

所以 $E(x^L) = \sum_{i=0}^L \begin{Bmatrix} L \\ i \end{Bmatrix} E(x^{\underline i}) = \sum_{i=0}^L \begin{Bmatrix} L \\ i \end{Bmatrix} P^{(i)}(1)$，那么问题就变成了求 $P^{(i)}(1)$。

$P^{(i)}(x) = \dfrac {[y^k] m^{\underline i}y^i (1 + xy)^{m - i} (1 + y)^{n - m}} {\binom nk}$，所以 $P^{(i)}(1) = \dfrac {[y^{k - i}] m^{\underline i} (1 + y)^{n - i}} {\binom nk} = \dfrac {m^{\underline i} \binom{n - i}{k - i}} {\binom nk} = \dfrac {k^{\underline i}m^{\underline i}} {n^{\underline i}}$，带到之前那个期望的式子里面去就可以了。

代码见我的 [$\textsf{blog}$](https://www.cnblogs.com/cj-xxz/p/14221622.html)

---

## 作者：Fido_Puppy (赞：11)

哎呦，你干嘛~

## 题目链接

- [P2791 幼儿园篮球题](https://www.luogu.com.cn/problem/P2791)

## 题解

首先尝试枚举有 $i$ 个球没气，不难写出每次蔡徐坤表演的期望失败度：

$$\sum_{i = 0} ^ k i ^ L \times {m \choose i} \times {n - m \choose k - i} \times {n \choose k} ^ {-1}$$

发现这个 $i ^ L$ 比较难处理，可以考虑将其用**第二类斯特林数**代入：

$$\because x ^ n = \sum_{i = 0} ^ n \begin{Bmatrix}n \\ i \end{Bmatrix} \times x ^ {\underline{i}}$$

所以可得答案为：

$${n \choose k} ^ {-1} \times \sum_{i = 0} ^ k {m \choose i} \times {n - m \choose k - i} \times \sum_{j = 0} ^ L \begin{Bmatrix} L \\ j \end{Bmatrix} \times i ^ {\underline{j}}$$

交换求和式后可得：

$${n \choose k} ^ {-1} \times \sum_{j = 0} ^ L \begin{Bmatrix} L \\ j \end{Bmatrix} \times \sum_{i = 0} ^ k {m \choose i} \times {n - m \choose k - i} \times i ^ {\underline{j}}$$

发现什么也看不出来，不如把组合数和下降幂全部拆开来：

$${n \choose k} ^ {-1} \times \sum_{j = 0} ^ L \begin{Bmatrix} L \\ j \end{Bmatrix} \times \sum_{i = 0} ^ k \dfrac{m! \times (n - m)! \times i!}{i! \times (m - i)! \times (k - i)! \times (n - m - k + i)! \times (i - j)!}$$

发现 $i!$ 可以约掉，然后发现分母中有 $(m - i)!$ 和 $(i - j)!$，但是分子中并没有 $(m - j)!$，于是分式上下再同乘 $(m - j)!$：

$${n \choose k} ^ {-1} \times \sum_{j = 0} ^ L \begin{Bmatrix} L \\ j \end{Bmatrix} \times \sum_{i = 0} ^ k \dfrac{m! \times (n - m)! \times (m - j)!}{(m - j)! \times (m - i)! \times (k - i)! \times (n - m - k + i)! \times (i - j)!}$$

然后我们再将阶乘转回组合数与下降幂：

$${n \choose k} ^ {-1} \times \sum_{j = 0} ^ L \begin{Bmatrix} L \\ j \end{Bmatrix} \times \sum_{i = 0} ^ k {m - j \choose i - j} \times {n - m \choose k - i} \times m ^ {\underline{j}}$$

可以将 $m ^ {\underline{j}}$ 提到前面，并且对后面的组合数求和用**范德蒙德卷积**：

$${n \choose k} ^ {-1} \times \sum_{j = 0} ^ L \begin{Bmatrix} L \\ j \end{Bmatrix} \times m ^ {\underline{j}} \times {n - j \choose k - j}$$

至此，只需要预处理**第二类斯特林数·行**，组合数即可做到每次询问复杂度 $\Theta(L)$。

不会 $\Theta(n \log n)$ 求第二类斯特林数·行的同学可以左转 [P5395 第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395)。

时间复杂度 $\Theta(N + SL + L \log L)$。

## 代码链接

- [https://www.luogu.com.cn/paste/h4f070i1](https://www.luogu.com.cn/paste/h4f070i1)

---

## 作者：Warriors_Cat (赞：9)

[题面传送门](https://www.luogu.com.cn/problem/P2791)。

> 题意：开始给定 $N, M, S, L$。$S$ 次询问，给定 $n, m, k$，表示有 $m$ 个 $1$ 和 $n-m$ 个 $0$，在这当中随机选 $k$ 个数，问选出数和的 $L$ 次方的期望值。答案对 $998244353$ 取模。

> $1\le S\le200$，$1\le L \le 2\times 10^5$，$1\le m, k\le n\le N \le 2\times 10^7$，$1 \le m\le M \le N$。

推式子大法好！

---

### $Solution:$

考虑每个 $x^L$ 的贡献，这等价于从中要选出 $x$ 个 $1$ 和 $k-x$ 个 $0$，于是其贡献为 $x^L\dbinom{m}{x}\dbinom{n-m}{k-x}$。

那么这个题目实际上转化为求：

$$\frac{\sum\limits_{x=0}^kx^L\dbinom{m}{x}\dbinom{n-m}{k-x}}{\dbinom{n}{k}}$$

分母是关于 $x$ 的常数，所以考虑一下分子就行。

发现 $x^L$ 这个东西很不好看，考虑斯特林数。记 $S(n, m)$ 表示第二类斯特林数：

$$x^L=\sum_{i=0}^x\binom{x}{i}i!S(L, i)$$

证明考虑组合意义就行。

代回原式：

$$\begin{aligned}
&=\sum_{x=0}^k\sum_{i=0}^x\binom{m}{x}\binom{n-m}{k-x}\binom{x}{i}i!S(L, i)
\\&=\sum_{i=0}^k\sum_{x=i}^k\binom{m}{x}\binom{n-m}{k-x}\binom{x}{i}i!S(L, i)
\\&=\sum_{i=0}^kS(L, i)i!\sum_{x=i}^k\binom{m}{i}\binom{m-i}{x-i}\binom{n-m}{k-x}
\\&=\sum_{i=0}^kS(L, i)i!\binom{m}{i}\sum_{x=0}^{k-i}\binom{m-i}{x}\binom{n-m}{k-i-x}
\\&=\sum_{i=0}^kS(L, i)i!\binom{m}{i}\binom{n-i}{k-i}
\end{aligned}$$

（[如果上述推式子过程有不了解的知识点，可以戳这](https://www.luogu.com.cn/paste/rqkwzjce)）

又有：

$$\begin{aligned}
S(L, i)&=\frac{1}{i!}\sum_{j=0}^i(-1)^j\binom{i}{j}(i-j)^L
\\&=\sum_{j=0}^i\frac{(-1)^j}{j!}\cdot\frac{(i-j)^L}{(i-j)!}
\end{aligned}$$

是个卷积的形式，于是可以在 $L\log L$ 的时间内预处理出 $S(L, 0), S(L, 1), ...S(L, L)$。

over，时间复杂度为 $O(L\log L +SL)$。

### $Code:$

实现的时候注意一下常数问题，不过我好像没卡过常？（

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 800010, M = 20000010, mod = 998244353, g_ = 3, invg = 332748118;
int n, m, s, l, nn, mm, kk, S[N], B[N], e[N], r[N], rev, fac[M], inv[M];
inline int fpow(int x, int p){ int ans = 1; for(; p; p >>= 1, x = 1ll * x * x % mod) if(p & 1) ans = 1ll * ans * x % mod; return ans; }
inline void clr(int *A, int x){ memset(A, 0, sizeof(int)*x); }
inline void cpy(int *A, int *B, int x){ memcpy(A, B, sizeof(int)*x); }
inline void NTT(int typ, int *a, int lim){
	if(rev != lim){ rev = lim; rep(i, 0, lim - 1) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0); }
	rep(i, 0, lim - 1) if(i < r[i]) swap(a[i], a[r[i]]);
	for(int mid = 1; mid < lim; mid <<= 1){
		int R = mid << 1, rt = fpow(typ == 1 ? g_ : invg, (mod - 1) / R);
		for(int j = 0; j < lim; j += R){
			int w = 1;
			for(int k = 0; k < mid; ++k, w = 1ll * w * rt % mod){
				int x = a[j | k], y = 1ll * w * a[j | k | mid] % mod;
				a[j | k] = (x + y) % mod; a[j | k | mid] = (x - y + mod) % mod;
			}
		}
	}
	if(typ < 0){ int k = fpow(lim, mod - 2); rep(i, 0, lim - 1) a[i] = 1ll * a[i] * k % mod; }
}
inline void ptm(int *A, int *B, int len){ rep(i, 0, len - 1) A[i] = 1ll * A[i] * B[i] % mod; }
inline void Polymul(int *A, int *B, int len, int m){
	int lim = 1; while(lim < len) lim <<= 1;
	cpy(e, B, lim); clr(e + m, lim - m);
	NTT(1, A, lim); NTT(1, e, lim); ptm(A, e, lim);
	NTT(-1, A, lim); clr(A + m, lim - m); 
}
inline void initfac(int n){
	fac[0] = 1;
	rep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % mod;
	inv[n] = fpow(fac[n], mod - 2);
	per(i, n - 1, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;
}
inline int C(int n, int m){ return n < m ? 0 : 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; }
inline int invC(int n, int m){ return 1ll * inv[n] * fac[m] % mod * fac[n - m] % mod; }
inline void mian(){
	n = read(); m = read(); s = read(); l = read(); initfac(max(n, l));
	rep(i, 0, l) S[i] = (i & 1) ? mod - inv[i] : inv[i];
	rep(i, 0, l) B[i] = 1ll * fpow(i, l) * inv[i] % mod;
	Polymul(S, B, l + 1 << 1, l + 1);
	while(s--){
		nn = read(); mm = read(); kk = read(); int ans = 0;
		rep(i, 0, min(min(mm, kk), l)) ans = (ans + 1ll * S[i] * fac[i] % mod * C(mm, i) % mod * C(nn - i, kk - i) % mod) % mod;
		printf("%d\n", 1ll * ans * invC(nn, kk) % mod); 
	}
}
int main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```

---

## 作者：TernaryTree (赞：8)

击你胎没。

---

题目所求即为

$$
\dfrac
{
\Large{\sum\limits_{i=0}^{\tiny{\min(k, m, L)}}}\normalsize{\dbinom{m}{i}\dbinom{n-m}{k-i}i^L}
}
{
\dbinom{n}{k}
}
$$

下面分母非常简洁可以不看，尝试化简分子。形如 $i^L$ 的东西不好处理，看起来像一个第二类斯特林数的经典结论：

$$i^n=\sum_{j=0}^i\dbinom{i}{j}\begin{Bmatrix}{n}\\{j}\end{Bmatrix}j!$$

把它套进去。得到

$$\sum\limits_{i=0}^{\min(k, m, L)}\dbinom{m}{i}\dbinom{n-m}{k-i}\sum_{j=0}^i\dbinom{i}{j}\begin{Bmatrix}{L}\\{j}\end{Bmatrix}j!$$

把 $j$ 提到 $i$ 前面，由 $j\le i$ 得到 $i\ge j$。

$$\sum\limits_{j=0}^{\min(k, m, L)}\begin{Bmatrix}{L}\\{j}\end{Bmatrix}j!\sum_{i=j}^{\min(k, m, L)}\dbinom{m}{i}\dbinom{n-m}{k-i}\dbinom{i}{j}$$

同时我们有

$$
\begin{aligned}
&\dbinom{m}{i}\dbinom{i}{j} \\
=&\dfrac{m!\ i!}{i!\ j!\ (m-i)! \ (i-j)!} \\
=&\dfrac{m!}{j!\ (m-i)! \ (i-j)!} \\
=&\dfrac{m!\ (m-j)!}{j!\ (m-i)! \ (i-j)!\ (m-j)!} \\ 
=&\dbinom{m}{j}\dbinom{m-j}{i-j}
\end{aligned}
$$

原式化为

$$
\begin{aligned}
&\sum\limits_{j=0}^{\min(k, m, L)}\begin{Bmatrix}{L}\\{j}\end{Bmatrix}\dbinom{m}{j}j!\sum_{i=j}^{\min(k, m, L)}\dbinom{n-m}{k-i}\dbinom{m-j}{i-j}\\
=&\sum\limits_{j=0}^{\min(k, m, L)}\begin{Bmatrix}{L}\\{j}\end{Bmatrix}\dbinom{m}{j}j!\sum_{i=0}^{\min(k, m, L)}\dbinom{n-m}{k-i-j}\dbinom{m-j}{i}\\
\end{aligned}
$$

后面是明显的范德蒙德卷积形式，即 $\dbinom{n-j}{k-j}$。于是关于 $i$ 的和式就被拆掉了。

$$\sum\limits_{j=0}^{\min(k, m, L)}\begin{Bmatrix}{L}\\{j}\end{Bmatrix}\dbinom{m}{j}\dbinom{n-j}{k-j}j!$$

这里的复杂度瓶颈在于第二类斯特林数的一个求，参考 [P5395 第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395) 可以使用 NTT 在 $\Theta(N\log N)$ 预处理求出 $\begin{Bmatrix}{L}\\{j}\end{Bmatrix}(0\le j\le L)$。

总复杂度 $\Theta(N\log N+SL)$。

[Code](https://www.luogu.com.cn/paste/spcf6r4i)。

---

## 作者：Spasmodic (赞：8)

一边翻具体数学一边做这题.jpg

首先枚举有气篮球个数：
$$
ans=\sum_ii^L\frac{\dbinom{m}{i}\dbinom{n-m}{k-i}}{\dbinom{n}{k}}
$$
对于 $i^L\dbinom{m}{i}\dbinom{n-m}{k-i}$ 我们没有好的办法处理，那么考虑把 $i^k$ 拆了：
$$
\sum_i\dbinom{m}{i}\dbinom{n-m}{k-i}\sum_j\begin{Bmatrix}L\\j\end{Bmatrix}i^{\underline{j}}\times \dbinom{n}{k}^{-1}
$$
下面忽略后面的 $\dbinom{n}{k}$，继续计算。

对第二类斯特林数我们没有好的处理方法，因此我们的目标是把 $i$ 相关的和式写成封闭，那么交换求和号可得：
$$
\sum_j\begin{Bmatrix}L\\j\end{Bmatrix}\sum_i\dbinom{m}{i}\dbinom{n-m}{k-i}i^{\underline{j}}
$$
求和式内部有一个成型了的范德蒙德卷积，为了把多余的下降幂去除，我们就把下降幂提取为组合数：
$$
\sum_j\begin{Bmatrix}L\\j\end{Bmatrix}j!\sum_i\dbinom{m}{i}\dbinom{n-m}{k-i}\dbinom{i}{j}
$$
根据 (5.21) 我们有 $\dbinom{m}{i}\dbinom{i}{j}=\dbinom{m}{j}\dbinom{m-j}{i-j}$，那么剩下的明显就是一个范德蒙德卷积的形式：
$$
\sum_j\begin{Bmatrix}L\\j\end{Bmatrix}\dbinom{m}{j}j!\sum_i\dbinom{m-j}{i-j}\dbinom{n-m}{k-i}=\sum_j\begin{Bmatrix}L\\j\end{Bmatrix}\dbinom{m}{j}j!\dbinom{n-j}{k-j}
$$
现在就没有必要推下去了，容易在 $O(L\log L)$ 时间内预处理一行第二类斯特林数，然后每次查询 $O(L)$ 计算即可，总复杂度是 $O(L\log L+qL)$ 的。

---

## 作者：xiezheyuan (赞：5)

> P2791 幼儿园篮球题
>
> 预先给出 $N,M,S,L$，其中 $N,M$ 为后文中的 $n,m,k$ 的上界。
>
> 有 $S$ 次询问，每次询问给出 $n,m,k$。表示有 $n$ 个球，其中 $m$ 个球是红色的，其余均是蓝色的。你需要随机选择 $k$ 个球。
>
> 如果你选择了 $i$ 个红色球，会获得 $i^L$ 的收益。你需要求出期望收益，对 $998,244,353$ 取模。
>
> $1\leq N,M\leq 2\times10^7,1\leq L\leq2\times10^5,1\leq S\leq 200,1\leq m,k\leq n\leq N,1\leq m\leq M$

首先不难想到需要计算的是下面这个玩意：

$$
\dfrac{1}{\binom{n}{k}}\sum_{i=0}^k\binom{m}{i}\binom{n-m}{k-i}i^L
$$

$i^L$ 不好处理，考虑使用第二类斯特林数拆幂（普通幂转下降幂）：

$$
\def\str#1#2{\begin{Bmatrix} #1\\#2\end{Bmatrix}}
i^L=\sum_{j=0}^i\str{L}{j}\binom{i}{j}j!
$$

代入原式：

$$
\def\str#1#2{\begin{Bmatrix} #1\\#2\end{Bmatrix}}
\begin{aligned}
&\dfrac{1}{\binom{n}{k}}\sum_{i=0}^k\binom{m}{i}\binom{n-m}{k-i}i^L\\
&=\dfrac{1}{\binom{n}{k}}\sum_{i=0}^k\binom{m}{i}\binom{n-m}{k-i}\sum_{j=0}^i\str{L}{j}\binom{i}{j}j!\\
&=\dfrac{1}{\binom{n}{k}}\sum_{j=0}^{k}\str{L}{j}j!\sum_{i=0}^{k}\binom{m}{i}\binom{i}{j}\binom{n-m}{k-i}\\
&=\dfrac{1}{\binom{n}{k}}\sum_{j=0}^{k}\str{L}{j}j!\binom{m}{j}\sum_{i=0}^k\binom{m-i}{i-j}\binom{n-m}{k-i}
\end{aligned}
$$

根据范德蒙德卷积公式：

$$
\sum_{i=0}^k\binom{a}{i}\binom{b}{k-i}=\binom{a+b}{k}
$$

代入原式：

$$
\def\str#1#2{\begin{Bmatrix} #1\\#2\end{Bmatrix}}
\begin{aligned}
&\dfrac{1}{\binom{n}{k}}\sum_{j=0}^{k}\str{L}{j}j!\binom{m}{j}\sum_{i=0}^{k-j}\binom{m-i}{i}\binom{n-m}{k-i-j}\\
&=\dfrac{1}{\binom{n}{k}}\sum_{j=0}^{k}\str{L}{j}j!\binom{m}{j}\binom{n-i}{k-j}
\end{aligned}
$$

首先由于 $\def\str#1#2{\begin{Bmatrix} #1\\#2\end{Bmatrix}}\str{n}{k}$ 在 $k>n$ 的时候为 $0$，所以真实的上界只有 $\min(m,k,L)$。

考虑如何求出第 $L$ 行第二类斯特林数，可以将第二类斯特林数的通项公式拆开，然后转化为卷积的形式。

使用 NTT，可以做到 $O({L\log L})$。

预处理阶乘来计算组合数，每次询问扫一遍即可。

时间复杂度 $O({SL+L\log L})$。注意本题卡常卡空。

---

## 作者：封禁用户 (赞：5)

先看我们要求的是什么，要求的期望就是 $\sum _ {i=0} ^ {k} 
\tbinom{m}{i} \tbinom{n - m}{k - i}$，总方案是 $\tbinom{n}{k}$

直接做显然不行(~~废话~~)，然后发现式子里有个 $i ^ {l}$，把它拆开，也就是 $\sum _ {j=0} ^ {l} 
\tbinom{i}{j} S _ {l, i}j!$，代入原式 
$$\sum _ {i=0} ^ {k} \tbinom{m}{i} \tbinom{n - m}{k - i} \sum _ {j=0} ^ {l} 
\tbinom{i}{j} S _ {l, i}j!$$
$$\sum _ {j=0} ^ {l} S _ {l, i}j! \sum _ {i=0} ^ {k} \tbinom{m}{i}  \tbinom{i}{j} \tbinom{n - m}{k - i}$$
$$\sum _ {j=0} ^ {l} S _ {l, i}j! \sum _ {i=0} ^ {k} \tbinom{m}{j} \tbinom{m - j}{i - j} \tbinom{n - m}{k - i}$$
$$\sum _ {j=0} ^ {l} S _ {l, i}j! \tbinom{m}{j} \sum _ {i=0} ^ {k} \tbinom{m - j}{i - j} \tbinom{n - m}{k - i}$$
$$\sum _ {j=0} ^ {l} S _ {l, i}j! \tbinom{m}{j} \tbinom{n - j}{k - j}$$

然后只需要快速预处理 $S _ {l, j}$ 就能做了。

考虑组合意义
$$\begin{aligned} S _ {n, m} &= \frac{1}{m!} \sum _ {i=0} ^ {m} (-1) ^ {i} \tbinom{m}{i} (m - i) ^ {n} \\ &= \sum _ {i=0} ^ {m} \frac{(-1) ^{i}}{i!} \frac{(m - i) ^ {n}}{(m - i)!} \end{aligned}$$

之后卷积即可。

这题可能有点卡常，要注意简化运算

code：
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<vector>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<set>
#define LL long long
#define db double
 
using namespace std;
const int N=2e7+10,M=550000+10,mod=998244353;
LL rd()
{
    LL x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
int fpow(int a,int b){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;} return an;}
int inv(int a){return fpow(a,mod-2);}
int fac[N],iac[N],rdr[M];
void ntt(int *a,int n,bool op)
{
    int x,y;
    for(int i=0;i<n;++i)
        if(i<rdr[i]) swap(a[i],a[rdr[i]]);
    for(int i=1;i<n;i<<=1)
    {
        int ww=fpow(op?3:332748118,(mod-1)/(i<<1));
        for(int j=0;j<n;j+=i<<1)
            for(int k=0,w=1;k<i;++k,w=1ll*w*ww%mod)
                x=a[j+k],y=1ll*a[j+k+i]*w%mod,a[j+k]=(x+y)%mod,a[j+k+i]=(x-y+mod)%mod;
    }
    if(!op) for(int i=0,w=inv(n);i<n;++i) a[i]=1ll*a[i]*w%mod;
}
int C(int n,int m){return m<0||n<m?0:1ll*fac[n]*iac[m]%mod*iac[n-m]%mod;}
int n,m,s,l,aa[M],bb[M],prm[M>>1],tt;
bool v[M];
 
int main()
{
    n=rd(),m=rd(),s=rd(),l=rd();
    fac[0]=1;
    int lm=max(n,l);
    for(int i=1;i<=lm;++i) fac[i]=1ll*fac[i-1]*i%mod;
    iac[lm]=inv(fac[lm]);
    for(int i=lm;i;--i) iac[i-1]=1ll*iac[i]*i%mod;
    bb[1]=1;
    for(int i=2;i<=l;++i)
    {
        if(!v[i]) prm[++tt]=i,bb[i]=fpow(i,l);
        for(int j=1;j<=tt&&i*prm[j]<=l;++j)
        {
            v[i*prm[j]]=1;
            bb[i*prm[j]]=1ll*bb[i]*bb[prm[j]]%mod;
            if(i%prm[j]==0) break;
        }
    }
    for(int i=0;i<=l;++i)
        aa[i]=(i&1)?mod-iac[i]:iac[i];
    for(int i=0;i<=l;++i)
        bb[i]=1ll*bb[i]*iac[i]%mod;
    int len=1,ms=0;
    while(len<=l+l) len<<=1,++ms;
    for(int i=0;i<len;++i) rdr[i]=(rdr[i>>1]>>1)|((i&1)<<(ms-1));
    ntt(aa,len,1),ntt(bb,len,1);
    for(int i=0;i<len;++i) aa[i]=1ll*aa[i]*bb[i]%mod;
    ntt(aa,len,0);
    while(s--)
    {
        int nn=rd(),mm=rd(),kk=rd(),ans=0,lim=min(min(l,kk),mm);
        for(int i=0;i<=lim;++i)
            ans=(ans+1ll*aa[i]/**fac[i]%mod*iac[i]%mod*/*iac[mm-i]%mod*fac[nn-i]%mod*iac[kk-i]%mod)%mod;
        ans=1ll*ans*inv(C(nn,kk))%mod*fac[mm]%mod*(nn>=kk?iac[nn-kk]:0)%mod;
        printf("%d\n",ans);
    }
    return 0;
}
```



---

## 作者：Arghariza (赞：4)

<https://www.cnblogs.com/Ender32k/p/17569726.html>

考虑枚举选出来 $i$ 个**没气**的篮球，那么答案可以表示成：

$$\text{ans}=\frac{1}{\dbinom{n}{k}}\sum\limits_{i=0}^{k}\dbinom{m}{i}\dbinom{n-m}{k-i}i^L$$

注意到这里的组合数 $\dbinom{n}{m}$ 在 $n<m$ 或者 $m<0$ 时无意义，直接当成 $0$ 即可。

考虑普通幂转下降幂：

$$i^L=\sum\limits_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}i^{\underline j}$$

带入原式有：

$$\begin{aligned}\text{ans}&=\frac{1}{\dbinom{m}{k}}\sum\limits_{i=0}^k\dbinom{m}{i}\dbinom{n-m}{k-i}\sum\limits_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}i^{\underline j}\\&=\frac{1}{\dbinom{m}{k}}\sum\limits_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}\sum\limits_{i=0}^k\dbinom{m}{i}\dbinom{n-m}{k-i}i^{\underline j}\end{aligned}$$

根据经典组合恒等式：

$$\begin{aligned}\dbinom{m}{i}i^{\underline j}&=\frac{m!}{i!(m-i)!}\cdot \frac{i!}{(i-j)!}\\&=\frac{m!}{(m-i)!(i-j)!}\\&=\frac{(m-j)!}{(m-i)!(i-j)!}\cdot \frac{m!}{(m-j)!}\\&=\dbinom{m-j}{i-j}m^{\underline j}\end{aligned}$$

代入原式得：

$$\begin{aligned}\text{ans}&=\frac{1}{\dbinom{m}{k}}\sum\limits_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}\sum\limits_{i=0}^k\dbinom{n-m}{k-i}\dbinom{m-j}{i-j}m^{\underline j}\\&=\frac{1}{\dbinom{m}{k}}\sum\limits_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}m^{\underline j}\sum\limits_{i=0}^k\dbinom{n-m}{k-i}\dbinom{m-j}{i-j}\\&=\frac{1}{\dbinom{m}{k}}\sum\limits_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}m^{\underline j}\dbinom{n-j}{k-j}\end{aligned}$$

第三步运用了**范德蒙德卷积**。

于是我们只需要求出第 $L$ 行的斯特林数值，就可以通过 $O(N)$ 预处理阶乘及其逆元，对于每个询问 $O(L)$ 得出答案。

这是个经典 trick，通过二项式反演以及 NTT 可以 $O(L\log L)$求出，可以看 [P5395 第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395)，这里不多赘述。

总复杂度 $O(N+L(\log L+q))$。

```cpp
// Problem: P2791 幼儿园篮球题
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2791
// Memory Limit: 222 MB
// Time Limit: 1110 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(int x) {
        if (x < 0) {
            x = ~(x - 1);
            putchar('-');
        }
        if (x > 9)
            wr(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace vbzIO;

const int N = 2e5 + 200;
const int M = 2e7 + 200;
const int P = 998244353;
const int G = 114514;
int q, n, len = 1, lim, a[N << 2], b[N << 2], tr[N << 2], fac[M], ifac[M];

int qpow(int p, int q) {
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

const int iG = qpow(G, P - 2);

void init(int lim) {
	fac[0] = 1;
	for (int i = 1; i <= lim; i++) 
		fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[lim] = qpow(fac[lim], P - 2) % P;
	for (int i = lim - 1; ~i; i--)
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
}

int C(int n, int m) {
	if (n < m || m < 0) return 0;
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

void NTT(int *f, int op) {
	for (int i = 0; i < len; i++)
		if (i < tr[i]) swap(f[i], f[tr[i]]);
	for (int o = 2, k = 1; k < len; o <<= 1, k <<= 1) {
		int tg = qpow((~op) ? G : iG, (P - 1) / o);
		for (int i = 0; i < len; i += o) {
			for (int j = 0, w = 1; j < k; j++, w = 1ll * w * tg % P) {
				int x = f[i + j], y = 1ll * f[i + j + k] * w % P;
				f[i + j] = (x + y) % P, f[i + j + k] = (x - y + P) % P;
			}
		}
	}
	if (~op) return;
	int iv = qpow(len, P - 2);
	for (int i = 0; i < len; i++)
		f[i] = 1ll * f[i] * iv % P;
}

int main() {
	int t = max(rd(), rd());
	q = rd(), n = rd(), init(t);
	for (int i = 0, g = 1; i <= n; i++, g = P - g)
		a[i] = 1ll * g * ifac[i] % P, b[i] = 1ll * qpow(i, n) * ifac[i] % P;
	while (len <= (n << 1)) len <<= 1, lim++;
	for (int i = 0; i < len; i++) 
		tr[i] = (tr[i >> 1] >> 1) | ((i & 1) << (lim - 1)); 
	NTT(a, 1), NTT(b, 1);
	for (int i = 0; i < len; i++)
		a[i] = 1ll * a[i] * b[i] % P;
	NTT(a, -1);
	while (q--) {
		int x = rd(), y = rd(), z = rd();
		int res = 0;
		for (int i = 0; i <= min(min(n, x), min(y, z)); i++) 
			(res += 1ll * a[i] * fac[y] % P * ifac[y - i] % P * C(x - i, z - i) % P) %= P;
		wr(1ll * res * qpow(C(x, z), P - 2) % P), pc('\n');
	}
	return 0;
}
```

---

## 作者：xzCyanBrad (赞：2)

## 1. 推式子与结论

考虑推分子，因为分母一定是 $\binom{n_i}{k_i}$。下面第一个式子是按照题目描述中的式子算出的总和。
$$
\begin{aligned}
&\sum_{p=0}^{k_i}\binom{m_i}p\binom{n_i-m_i}{k_i-p}p^L\\
=&\sum_{p=0}^{k_i}\binom{m_i}p\binom{n_i-m_i}{k_i-p}\sum_q\begin{Bmatrix}L\\q\end{Bmatrix}p^{\underline q}&&(\because \text{Lemma.0})\\
=&\sum_{p=0}^{k_i}\sum_q\binom{m_i}p\binom{n_i-m_i}{k_i-p}\binom pq\begin{Bmatrix}L\\q\end{Bmatrix}q!\\
=&\sum_{p=0}^{k_i}\sum_q\binom{m_i}p\binom pq\binom{n_i-m_i}{k_i-p}\begin{Bmatrix}L\\q\end{Bmatrix}q!\\
=&\sum_{p=0}^{k_i}\sum_q\binom{m_i}q\binom{m_i-q}{p-q}\binom{n_i-m_i}{k_i-p}\begin{Bmatrix}L\\q\end{Bmatrix}q!&&(\because \text{Lemma.1})\\
=&\sum_qm_i^{\underline q}\begin{Bmatrix}L\\q\end{Bmatrix}\sum_{p'=0}^{k_i-q}\binom{m_i-q}{p'}\binom{n_i-m_i}{(k_i-q)-p'}\\
=&\sum_qm_i^{\underline q}\begin{Bmatrix}L\\q\end{Bmatrix}\binom{n_i-q}{k_i-q}&&(\because\text{Lemma.2})\\
\end{aligned}
$$

直接枚举 $q$，快速求行斯特林数求出 $\begin{Bmatrix}L\\q\end{Bmatrix}$，复杂度 $\Theta(L\log L+SL)$，因为对于一组数据 $\begin{Bmatrix}L\\q\end{Bmatrix}$ 不会变，所以少了一只老哥。

## 2. 引理证明

#### 2.0 Lemma.0 $p^L=\sum_q\begin{Bmatrix}L\\q\end{Bmatrix}p^{\underline q}$

根据[第二类斯特林数](https://oi-wiki.org/math/combinatorics/stirling/#下降幂与普通幂的相互转化)的性质即得。

#### 2.1 Lemma.1 $\binom{m_i}{p}\binom{p}{q}=\binom{m_i}{q}\binom{m_i-q}{p-q}$

考虑组合意义，前者是先选 $p$ 个再在 $p$ 个里面选 $q$ 个，后者是先选 $q$ 个再另外选 $p-q$ 个，两者本质上都是划分成大小为 $q,(p-q),(m_i-p-q)$ 的三个集合，由 Double Counting 即得相等。

#### 2.2 Lemma.2 $\sum_{p'=0}^{k_i-q}\binom{m_i-q}{p'}\binom{n_i-m_i}{(k_i-q)-p'}=\binom{n_i-q}{k_i-q}$

根据[范德蒙德卷积公式](https://oi-wiki.org/math/combinatorics/vandermonde-convolution/#范德蒙德卷积公式)即得。

---

## 作者：可爱的小棉羊 (赞：2)

挺典的。

考虑枚举有 $i$ 个球投了进去，失败度为 $i^L$，从漏气的选 $i$ 个又从有气的选 $k-i$ 个方案数为 $\binom mi\binom{n-m}{k-i}$。

所以答案为：

$$\left (\sum^k_{i=0}\binom{m}{i}\binom{n-m}{k-i}i^L\right)/\binom nk$$

我们来算左边那坨玩意，发现多了个 $i^L$ 很烦，不然就可以是个蒙德范德卷积，那就拆开：

$$\sum^k_{i=0}\binom{m}{i}\binom{n-m}{k-i}\sum_{j=0}^Li^{\underline{j}}\begin{Bmatrix}L\\j\end{Bmatrix}$$

交换 $\sum$。

$$\sum_{j=0}^L\begin{Bmatrix}L\\j\end{Bmatrix}j!\sum^k_{i=0}\binom{m}{i}\binom{n-m}{k-i}\binom ij$$

然后有个 $\binom mi\binom ij=\binom mj\binom{m-j}{i-j}$：

$$\sum_{j=0}^L\binom mj\begin{Bmatrix}L\\j\end{Bmatrix}j!\sum^k_{i=0}\binom{n-m}{k-i}\binom{m-j}{i-j}$$

然后就剩蒙德范德卷积卷积啦！

$$\sum_{j=0}^L\binom mj\begin{Bmatrix}L\\j\end{Bmatrix}j!\binom {n-j}{k-j}$$

展开所有组合数：

$$\frac{m!}{(n-k)!}\sum _{j=1}^l\begin{Bmatrix}L\\j\end{Bmatrix}\frac{(n-j)!}{(k-j)!(m-j)!} $$

再除个 $\binom nk$：

$$\frac{m!k!}{n!}\sum _{j=1}^l\begin{Bmatrix}L\\j\end{Bmatrix}\frac{(n-j)!}{(k-j)!(m-j)!} $$

然后第二类斯特林数可以一次卷积求出来，就可以 $O(L\log L+SL)$ 的时间复杂度算出来啦!


```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=998244353,G=3;
long long fpow(long long a,long long b){
	long long ans=1;
	if(b<0)b=(b%(mod-1)+mod-1)%(mod-1);
	
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int inv[20000005];
int n,fac[20000006],f[600005],g[600005],res[600004],N,M,t;
void ntt(int* a,long long n,int f){
	for(int i=0;i<n;i++)if(i<res[i])swap(a[i],a[res[i]]);
	for(int h=1;h<n;h<<=1){
		long long wn=fpow(G,1ll*f*((mod-1)/(h<<1)));
		for(int i=0;i<n;i+=(h<<1)){
			long long w=1;
			for(int j=0;j<h;j++,w=(w*wn)%mod){
				long long x=1ll*a[i+j],y=w*a[i+j+h]%mod;
				a[i+j]=(x+y)%mod;
				a[i+j+h]=(x-y+mod)%mod;
			}
		}
	}
	if(f==-1){
		long long inv=fpow(n,-1);
		for(int i=0;i<n;i++)a[i]=1ll*inv*a[i]%mod;
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>N>>M>>t>>n;
	fac[0]=1;
	for(int i=1;i<=2e7;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[(int)2e7]=fpow(fac[(int)2e7],mod-2);
	inv[0]=1;
	for(int i=2e7-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	int lim=1,k=0;
	while(lim<=(n<<1)){
		lim<<=1;
		k++;
	}
	for(int i=1;i<lim;i++)res[i]=(res[i>>1]>>1)|((i&1)<<(k-1));
	for(int i=0;i<=n;i++){
		f[i]=1ll*fpow(i,n)*fpow(fac[i],mod-2)%mod;
		g[i]=fpow(fac[i],mod-2)%mod;
		if(i&1)g[i]=mod-g[i];
	}
//	cout<<"\n";
	ntt(f,lim,1);
	ntt(g,lim,1);
	for(int i=0;i<lim;i++)f[i]=1ll*f[i]*g[i]%mod;
	ntt(f,lim,-1);
	while(t--){
		int p,m,k;
		cin>>p>>m>>k;
		long long ans=0;
		for(int i=0;i<=min(k,min(m,n));i++){
//			ans=(ans+f[i]*fac[p-i]%mod*fpow(fac[k-i]*fac[m-i]%mod,mod-2)%mod)%mod;
			ans=(ans+1ll*f[i]*fac[p-i]%mod*inv[k-i]%mod*inv[m-i]%mod)%mod;
		}
		ans=ans*fac[m]%mod%mod;
		ans=ans*fpow(fac[p],mod-2)%mod*1ll*fac[k]%mod;
		cout<<ans<<"\n";
	}
	return 0;
}

```

---


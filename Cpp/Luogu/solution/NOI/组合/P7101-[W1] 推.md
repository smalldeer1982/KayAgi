# [W1] 推

## 题目背景

一个”点集“为一个二维平面上的整点组成的**多重**集合。  
可以从一个点集构造一个三角形当且仅当这个三角形的所有顶点在该点集里面。  
从一个点集 $S$ 里可以构造恰好 $|S|^3$ 个三角形。（可能一些三角形会退化为一条面积为 0 的线段）

## 题目描述

有一个点集，初始为空集。  
有 $N$ 个操作，在每一个操作，会从这个点集插入或删除一个点。每一步完成后，询问这个点集可构造的所有三角形面积 *__八次方__* 之和。

所有询问答案都可以表示为 $a/b$，其中 $a$ 和 $b$ 互质。输出 $a\cdot b^{-1}\pmod{998244353}$。

## 说明/提示

对于 $10\%$ 的数据，$N\le10$；  
对于 $30\%$ 的数据，$N\le10^3$；  
对于另外 $10\%$ 的数据，没有删除步骤；  
对于 $100\%$ 的数据，$1\le N\le10^5,0\le x,y<998244353$，任何删除的点都保证原来存在。

## 样例 #1

### 输入

```
7
1 0 0
1 0 1
1 2 0
2 2 0
1 4 0
2 4 0
1 6 0```

### 输出

```
0
0
1
0
256
0
6561```

## 样例 #2

### 输入

```
5
1 0 0
1 0 1
1 1 0
1 1 1
2 0 1```

### 输出

```
0
0
994344961
982646785
994344961```

# 题解

## 作者：zhoukangyang (赞：7)

[更好的阅读体验 /kel /kel](https://www.cnblogs.com/zkyJuruo/p/14308661.html)

验题验不动，就来写写题解吧 ``/qq``

在本文中，我们让 $k = 8$  （即三角形面积的 $k$ 次方之和） 。此题拓展到 $k = 16$ 也是没问题的

首先要求的是 三个点围成的三角形面积 的和，我们显然要快速求出这个东西。

运用计算机和知识，或在百度上搜第一篇就可以找到答案  ：

三个点 $(x_1, y_1), (x_2, y_2),  (x_3, y_3)$ 围成的三角形面积为 ： $\frac{1}{2} |x_1 y_2 + x_2 y_3 + x_3 y_1 - x_1 y_3 - x_2 y_1 - x_3 y_2|$

对于每一个三角形，可以把这个三角形算 $6$ 次。

我们要计算的就是 $\frac{1}{6} \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{n} \sum\limits_{k = 1}^{n} (\frac{1}{2} |x_i y_j + x_j y_k + x_k y_i - x_i y_k - x_j y_i - x_k y_j|)^8$ 

（把有相同的点的也算进去了，这东西算出的答案为 $0$，对答案没有贡献）

$$\frac{1}{6 \times 2^8} \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{n} \sum\limits_{k = 1}^{n} (x_i y_j + x_j y_k + x_k y_i - x_i y_k - x_j y_i - x_k y_j)^8$$

用二项式定理的拓展把后面的一堆东西展开：

$$\frac{1}{1536} \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{n} \sum\limits_{k = 1}^{n} \sum\limits_{a + b + c + d + e + f = 8} \binom{8}{a, b, c, d, e, f}  (x_i y_j)^a (x_jy_k)^b (x_k y_i)^c (-x_iy_k)^d (-x_jy_i)^e (-x_ky_j)^f$$

$$\frac{1}{1536}  \sum\limits_{a + b + c + d + e + f = 8} (-1)^{d+e+f} \binom{8}{a, b, c, d, e, f}  \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{n} \sum\limits_{k = 1}^{n}x_i^a y_j^a x_j^by_k^b x_k^cy_i^c x_i^dy_k^d x_j^ey_i^e x_k^fy_j^f$$

$$\frac{1}{1536}  \sum\limits_{a + b + c + d + e + f = 8} (-1)^{d+e+f} \binom{8}{a, b, c, d, e, f}  (\sum\limits_{i = 1}^{n} x_i^{a+d} y_i^{c+e}) (\sum\limits_{j = 1}^{n} x_j^{b+e} y_j^{a+f}) (\sum\limits_{k = 1}^{n} x_k^{c+f} y_k^{b+d})$$

这样对于每一个 $A$ 和 $B$ 维护 $sum(A, B) = \sum\limits_{i = 1}^{n} x_i^A y_i^B$，统计答案时 $dfs$ 一下就是 $\Theta(k^5 n)$ 的了。事实上那个 $k^5$ 会很小，是 $\binom{k+5}{5}$

轻微卡常可以通过。

代码：

```cpp
#include<bit/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int, int>
#define mkp make_pair
using namespace std;
const int N = (1 << 20);
const int M = 10;
const int mod = 998244353;
int qpow(int x, int y = mod - 2) {
	int res = 1;
	for(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;
	return res;
}
int n, k = 8, inv1536;
int sum[M][M], f[M], ifac[M], fac[M];
ll ans;
void dfs(int x, int w, int now) {
	if(x == 6) {
		f[x] = w, now = (ll) now * ifac[w] % mod;
		int res = (ll) now * sum[f[1] + f[4]][f[3] + f[5]] % mod * sum[f[2] + f[5]][f[1] + f[6]] % mod * sum[f[3] + f[6]][f[2] + f[4]] % mod;
		if((f[4] + f[5] + f[6]) & 1) res = mod - res;
		ans += res;
		return;
	}
	L(i, 0, w) f[x] = i, dfs(x + 1, w - i, (ll) now * ifac[i] % mod);
}
int mian() {
	inv1536 = qpow(1536);
	scanf("%d", &n);
	fac[0] = ifac[0] = 1;
	L(i, 1, k) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = qpow(fac[i]);
	L(i, 1, n) {
		int opt, x, y; 
		scanf("%d%d%d", &opt, &x, &y);
		int now = 1;
		L(a, 0, k) {
			int Now = now;
			L(b, 0, k) {
				if(opt == 1) (sum[a][b] += Now) %= mod;
				else (sum[a][b] += mod - Now) %= mod;
				Now = (ll) Now * y % mod;
			}
			now = (ll) now * x % mod;
		}
		ans = 0, dfs(1, k, 1);
		printf("%lld\n", (ll) ans % mod * fac[k] % mod * inv1536 % mod);
	}
	return;
}
```

这样的常数十分不优良，考虑预处理出来要计算的每一次要调用的 $sum$ 的下标和乘上的系数。

这样子常数原来的 $\frac{1}{2}$。

对于每一次调用的 $sum$ 数组，有很多本质相同的，于是考虑把他们压缩起来。把相同的调用系数加起来就好了。

这样子常数减小到了最初的 $\frac{1}{12}$

（细节见代码）

```cpp
#include<bits/stdc++h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int, int>
#define mkp make_pair
using namespace std;
const int M = 10;
const int P = 5000;
const int mod = 998244353;
int qpow(int x, int y = mod - 2) {
	int res = 1;
	for(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;
	return res;
}
int n, k = 8, inv1536;
int sum[M][M], f[M], ifac[M], fac[M];
struct node { int x, y; } ;
bool operator < (node aa, node bb) { 
	return aa.x == bb.x ? aa.y < bb.y : aa.x < bb.x; 
}
bool operator == (node aa, node bb) { 
	return aa.x == bb.x && aa.y == bb.y; 
}
struct Node {
	int buf;
	node f[4];
} d[P], g[P];
bool operator < (Node aa, Node bb) { 
	return aa.f[1] == bb.f[1] ? (aa.f[2] == bb.f[2] ? aa.f[3] < bb.f[3] : aa.f[2] < bb.f[2]) : aa.f[1] < bb.f[1];
}
bool operator == (Node aa, Node bb) {
	return aa.f[1] == bb.f[1] && aa.f[2] == bb.f[2] && aa.f[3] == bb.f[3];
}
int tot, all;
ll ans;
void dfs(int x, int w, int now) {
	if(x == 6) {
		f[x] = w, now = (ll) now * ifac[w] % mod, ++tot;
		d[tot].f[1].x = f[1] + f[4], d[tot].f[1].y = f[3] + f[5];
		d[tot].f[2].x = f[2] + f[5], d[tot].f[2].y = f[1] + f[6];
		d[tot].f[3].x = f[3] + f[6], d[tot].f[3].y = f[2] + f[4];
		sort(d[tot].f + 1, d[tot].f + 4);
		if((f[4] + f[5] + f[6]) & 1) now = mod - now;
		d[tot].buf = (ll) now * inv1536 % mod * fac[k] % mod;
		return;
	}
	L(i, 0, w) f[x] = i, dfs(x + 1, w - i, (ll) now * ifac[i] % mod);
}
int main( {
	inv1536 = qpow(1536);
	scanf("%d", &n);
	fac[0] = ifac[0] = 1;
	L(i, 1, k) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = qpow(fac[i]);
	dfs(1, 8, 1);
	sort(d + 1, d + tot + 1);
	L(i, 1, tot) {
		if(g[all] == d[i]) (g[all].buf += d[i].buf) %= mod;
		else ++all, g[all] = d[i];
	}
	L(i, 1, n) {
		int opt, x, y; 
		scanf("%d%d%d", &opt, &x, &y);
		int now = 1;
		L(a, 0, k) {
			int Now = now;
			L(b, 0, k) {
				if(opt == 1) (sum[a][b] += Now) %= mod;
				else (sum[a][b] += mod - Now) %= mod;
				Now = (ll) Now * y % mod;
			}
			now = (ll) now * x % mod;
		}
		ans = 0;
		L(j, 1, all) {
			(ans += (ll) sum[g[j].f[1].x][g[j].f[1].y] * sum[g[j].f[2].x][g[j].f[2].y] % mod * 
			sum[g[j].f[3].x][g[j].f[3].y] % mod * g[j].buf % mod) %= mod;
		}
		printf("%lld\n", ans);
	}
	return 0;
```

$k = 8$ 的时候本质不同的 $sum$ 数组调用次数为 $180$，在 $k = 16$ 的时候也只有 $1996$ 。

orz w33z

---

## 作者：yizcdl2357 (赞：6)

# 解法
首先看到 $8$ 次方，考虑几何意义是不可能的了。于是考虑转为一个代数式求解。

设 $S((x_0,y_0),(x_1,y_1),(x_2,y_2))$ 为三个顶点坐标为 $(x_0,y_0),(x_1,y_1),(x_2,y_2)$ 的三角形的**面积**。

那么答案化为：

$$\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^nS((x_i,y_i),(x_j,y_j),(x_k,y_k))^8$$

不对。这样每一个三角形会被计算 $6$ 次。

因为，当 $i=1,j=2,k=3$ 和 $i=2,j=1,k=3$ 计算的是同一个三角形。

所以答案要除以 $6$：

$$\dfrac{1}{6}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^nS((x_i,y_i),(x_j,y_j),(x_k,y_k))^8$$

~~根据小学奥数可知~~三个顶点坐标为 $(x_0,y_0),(x_1,y_1),(x_2,y_2)$ 的三角形的面积是：

$$S((x_0,y_0),(x_1,y_1),(x_2,y_2))=\dfrac{1}{2}|x_0y_1+x_1y_2+x_2y_0-x_0y_2-x_1y_0-x_2y_1|$$

于是原式化为：

（公式较多，但没有任何跳步，还有注解，请耐心看完）

$$\scriptsize{\begin{aligned}
&\dfrac{1}{6}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^nS((x_i,y_i),(x_j,y_j),(x_k,y_k))^8\\
=&\dfrac{1}{6}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n\left(\dfrac{1}{2}|x_iy_j+x_jy_k+x_ky_i-x_iy_k-x_ky_j-x_jy_i|\right)^8&\text{（用公式代换）}\\
=&\dfrac{1}{1536}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n|x_iy_j+x_jy_k+x_ky_i-x_iy_k-x_ky_j-x_jy_i|^8&\text{（提出 }\dfrac{1}{2^8}\text{）}\\
=&\dfrac{1}{1536}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n(x_iy_j+x_jy_k+x_ky_i-x_iy_k-x_ky_j-x_jy_i)^8&\text{（去绝对值）}\\
=&\dfrac{1}{1536}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n\sum_p\sum_q\sum_r\sum_s\sum_t\sum_u\binom{8}{p,q,r,s,t,u}(x_iy_j)^p(x_jy_k)^q(x_ky_i)^r(-x_iy_k)^s(-x_jy_i)^t(-x_ky_j)^u&\text{（二项式定理）}\\
=&\dfrac{1}{1536}\sum_p\sum_q\sum_r\sum_s\sum_t\sum_u\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n\binom{8}{p,q,r,s,t,u}(x_iy_j)^p(x_jy_k)^q(x_ky_i)^r(-x_iy_k)^s(-x_jy_i)^t(-x_ky_j)^u&\text{（交换求和顺序）}\\
=&\dfrac{1}{1536}\sum_p\sum_q\sum_r\sum_s\sum_t\sum_u\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n(-1)^{s+t+u}\binom{8}{p,q,r,s,t,u}(x_iy_j)^p(x_jy_k)^q(x_ky_i)^r(x_iy_k)^s(x_jy_i)^t(x_ky_j)^u&\text{（提出}-1\text{ 的幂）}\\
=&\dfrac{1}{1536}\sum_p\sum_q\sum_r\sum_s\sum_t\sum_u\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n(-1)^{s+t+u}\binom{8}{p,q,r,s,t,u}x_i^{p+s}y_j^{p+u}x_j^{t+q}y_i^{t+r}y_k^{q+s}x_k^{u+r}&\text{（拆开括号）}\\
=&\dfrac{1}{1536}\sum_p\sum_q\sum_r\sum_s\sum_t\sum_u(-1)^{s+t+u}\binom{8}{p,q,r,s,t,u}\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^nx_i^{p+s}y_j^{p+u}x_j^{t+q}y_i^{t+r}y_k^{q+s}x_k^{u+r}&\text{（提出与}i,j,k\text{无关的部分）}\\
=&\dfrac{1}{1536}\sum_p\sum_q\sum_r\sum_s\sum_t\sum_u(-1)^{s+t+u}\binom{8}{p,q,r,s,t,u}\left(\sum_{i=1}^nx_i^{p+s}y_i^{t+r}\right)\left(\sum_{j=1}^nx_j^{t+q}y_j^{p+u}\right)\left(\sum_{k=1}^nx_k^{u+r}y_k^{q+s}\right)&\text{（因式分解）}\\
\end{aligned}}$$

容易发现枚举 $p,q,r,s,t,u$ 的时间复杂度都非常低，但是后面的计算时间复杂度达 $O(n)$，直接计算会 TLE，所以可以考虑在每次修改时维护它们。

具体要维护一个二维数组 `a[9][9]`，其中 `a[u][v]` 表示 $\sum_{k=1}^nx_k^uy_k^v$。详见代码。

时间复杂度：$O(n\times 8^5)$，经卡常可过。
# 卡常技巧
1. 常规操作：函数 `inline`
2. 预处理 $1536$ 的逆元而不是每次都去算。
3. (important)把每一个 $\binom{8}{p,q,r,s,t,u}$ 预处理在数组里。

详见代码。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int T,a[9][9],f[9],C[9][9][9][9][9][9];
const int M=998244353,i1536=332098219;
inline int md(int x)
{
	return x>M?x-M:M;
}
inline int P(int x,int y)
{
	if(!(~x)) return (y&1)*(-2)+1;/*(y&1)?-1:1*/;
	if(!y) return 1;
	if(y&1) return x*P(x,y^1)%M;
	int tmp=P(x,y>>1);
	return tmp*tmp%M;
}
inline void add(int x,int y)
{
	for(int i=0;i<=8;i++)
		for(int j=0;j<=8;j++)
			a[i][j]=(a[i][j]+P(x,i)*P(y,j)%M)%M;
}
inline void del(int x,int y)
{
	for(int i=0;i<=8;i++)
		for(int j=0;j<=8;j++)
			a[i][j]=(a[i][j]-P(x,i)*P(y,j)%M+M)%M;
}
inline int sum()
{
	int res=0;
	for(int p=0;p<=8;p++)
	for(int q=0;p+q<=8;q++)
	for(int r=0;p+q+r<=8;r++)
	for(int s=0;p+q+r+s<=8;s++)
	for(int t=0;p+q+r+s+t<=8;t++)
	for(int u=8-p-q-r-s-t;u>=0;u=-1)
	{
		int tmp=C[p][q][r][s][t][u];
		tmp*=((s+t+u)&1)*(-2)+1;
		tmp=tmp*a[p+s][t+r]%M;
		tmp=tmp*a[t+q][p+u]%M;
		tmp=tmp*a[u+r][q+s]%M;
		res+=tmp;
	}
	return (res%M+M)%M;
}
signed main()
{
	f[0]=1;
	for(int i=1;i<=8;i++) f[i]=i*f[i-1];
	for(int p=0;p<=8;p++)
	for(int q=0;p+q<=8;q++)
	for(int r=0;p+q+r<=8;r++)
	for(int s=0;p+q+r+s<=8;s++)
	for(int t=0;p+q+r+s+t<=8;t++)
	for(int u=8-p-q-r-s-t;u>=0;u=-1)
		C[p][q][r][s][t][u]=f[8]/f[p]/f[q]/f[r]/f[s]/f[t]/f[u];
	cin>>T;
	while(T--)
	{
		int t,x,y;
		scanf("%lld%lld%lld",&t,&x,&y);
		if(t==1) add(x,y);
		else del(x,y);
		printf("%lld\n",i1536*sum()%M);
	}
	return 0;
}
```


---


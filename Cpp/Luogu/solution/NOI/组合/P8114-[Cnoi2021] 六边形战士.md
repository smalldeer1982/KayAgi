# [Cnoi2021] 六边形战士

## 题目背景

在 Cirno 的精心照料下，六边形成长为一只可爱的平行六边形。

现在，Cirno 很想知道它的战斗力是多少。

## 题目描述

可爱的平行六边形所有边的夹角均为 $\frac{2\pi}{3}$，三组对边的长度分别为 $a$，$b$，$c$ 个单位。如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/aa8i6soa.png)

在战斗力鉴定时，鉴定师会以六边形的每一条边所在的直线，间隔 $\frac{\sqrt{3}}{2}$ 个单位建立平行直线系。这样六边形战士会被划分成若干个正三角形。如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/mbkn807n.png)

鉴定师会将所有有公共边的正三角形连边。由于没有奇环，很容易知道这是一个二分图。然后鉴定师会试图构造该二分图的完美匹配。如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/in7c6cf7.png)

该六边形战士的战斗力为上述**二分图的完美匹配**可能的种类数。作为见习鉴定师，你需要帮 Cirno 求出该六边形的战斗力。

由于答案可能过大，仅需输出它对 $998244353$ 取模的结果即可。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据，保证 $1\le a,b,c\le 10^6$。

**子任务**

Subtask1（$10$ points）：$a,b,c\le 3$。

Subtask2（$10$ points）：$a,b,c\le 8$。

Subtask3（$70$ points）：$a,b,c\le 100$。

Subtask4（$10$ points）：无特殊限制。

**提示**

 - **Krattenthaler’s formula**  
 $\displaystyle\det\left(\prod\limits_{k=2}^j(x_i+a_k)\prod\limits_{k=j+1}^n(x_i+b_k)\right)_{i,j=1}^{n}=\prod\limits_{1\le i<j\le n}{(x_i-x_j)}\prod\limits_{2<i\le j\le n}(a_i-b_j)$。

## 样例 #1

### 输入

```
1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 4 3```

### 输出

```
4116```

# 题解

## 作者：whiteqwq (赞：15)

[P8114 [Cnoi2021]六边形战士](https://www.luogu.com.cn/problem/P8114) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15882721.html)

## 题意

给定一个三条边分别有 $a,b,c$ 个六边形的六边形网络，求网络上所有边组成的二分图的完美匹配数量。

$1\leqslant a,b,c\leqslant 10^6$。

## 分析

非人力可及的巨大神仙题，膜拜 bzy。

考虑将匹配按照朝向分成三类：平、朝上、朝下，将三种匹配按照类型染上不同的颜色，然后考察其对应的三角形网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/rptzphhh.png)

（图来自 [Solara570-在二维世界中解决看似立体的平面问题](https://www.bilibili.com/video/av200522733)）

可以证明染色方法可以与平面的立方体凸堆叠一一对应。

考察高度 $v$ 与高度 $v+1$ 的分界线，将这 $c$ 条分界线画出来，可以发现路径 $i$ 可以与路径 $i+1$ 重叠，但是不能越过。

![](https://bzy.moe/CNOI/%E3%80%8CCNOI2021%E3%80%8DCirno's%20Easy%20Round%20II/F%20-%20Hexagon/p6.png)

（图，以及下面的图都来自官方题解）

将第 $i$ 条路径向右上平移 $i-1$ 格，可以得到一个新的网格，可以发现此时已经转化成 LGV 能解决的问题了，直接列出矩阵，求行列式即可做到立方复杂度了。

![](https://bzy.moe/CNOI/%E3%80%8CCNOI2021%E3%80%8DCirno's%20Easy%20Round%20II/F%20-%20Hexagon/p7.png)

列出矩阵，容易发现每个出发点到每个结束点的距离都是 $a+b$，且第 $i$ 个出发点和第 $j$ 个到达点的横向距离为 $a+(x-y)$：

$$ans=\det(M)\\M=\begin{bmatrix}{a+b\choose a}&{a+b\choose a-1}&\cdots&{a+b\choose a+1-c}\\{a+b\choose a+1}&{a+b\choose a}&\cdots&{a+b\choose a+2-c}\\\vdots&\vdots&\ddots&\vdots\\{a+b\choose a+c-1}&{a+b\choose c-2}&\cdots&{a+b\choose a}\end{bmatrix}$$

下面就是一些 dirty work 了：

$$\det(M)=\det(M')\times\prod_{i=1}^c\frac{(a+b)!}{(a+c-i))!(b+i-1)!}\\=\det(M'')\times\prod_{i=1}^c\frac{(a+b)!}{(a+c-i))!(b+i-1)!}\times(-1)^{\frac{c(c-1)}{2}}\\M_{i,j}'=\prod_{k=j+1}^c(a+k-i)\prod_{k=2}^j(b+i-k+1)\\M''_{i,j}=\prod_{k=j+1}^c(a+k-i)\prod_{k=2}^j(k-b-1-i)$$

根据题面提供的公式 Krattenthaler’s formula：

$$\det(\prod_{k=2}^j(x_i+a_k)\prod_{k=j+1}^m(x_i+b_k))_{i,j=1}^n=\prod_{1\leqslant i<j\leqslant n}(x_i-x_j)\prod_{2<i\leqslant j\leqslant n}(a_i-b_j)$$

$$\det(M'')=\prod_{1\leqslant i<j<c}(j-i)\prod_{2\leqslant i\leqslant j\leqslant c}(a+b+j-i-1)$$

$$\det(M)=\prod_{1\leqslant i<j<c}(i-j)\prod_{2\leqslant i\leqslant j\leqslant c}(a+b+j-i-1)\times\prod_{i=1}^c\frac{(a+b)!}{(a+c-i))!(b+i-1)!}\times(-1)^{\frac{c(c-1)}{2}}\\=\prod_{i=1}^{c-1}(i!)\prod_{i=1}^{c-1}(a+b+i)^{\underline i}\prod_{i=1}^c\frac{(a+b)!}{(a+c-i)!(b+i-1)!}\\=\prod_{i=1}^{c-1}(i!)\prod_{i=1}^{c-1}\frac{(a+b+i)!}{(a+b)!}\prod_{i=1}^c(a+b)!\prod_{i=1}^c\frac{1}{(a+c-i)!}\prod_{i=1}^c\frac{1}{(b+i-1)!}\\=\prod_{i=1}^{c-1}(i!)((a+b)!\times\prod_{i=1}^c(a+b+i)!)\frac{\prod_{i=0}^{a-1}(i!)}{\prod_{i=0}^{a+c-1}(i!)}\frac{\prod_{i=0}^{b-1}(i!)}{\prod_{i=0}^{b+c-1}(i!)}\\=\frac{H(a)H(b)H(c)H(a+b+c)}{H(a+b)H(b+c)H(a+c)}\\H(x)=\prod_{i=0}^{x-1}(i!)$$

然后就可以线性了。

## 代码
```
#include<stdio.h>
const int maxn=3000005,mod=998244353;
int a,b,c;
int fac[maxn],ffac[maxn];
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod,b>>=1;
	}
	return res;
}
int main(){
	fac[0]=ffac[0]=1;
	for(int i=1;i<maxn;i++)
		fac[i]=1ll*fac[i-1]*i%mod,ffac[i]=1ll*ffac[i-1]*fac[i]%mod;
	scanf("%d%d%d",&a,&b,&c);
	printf("%d\n",1ll*ffac[a-1]*ffac[b-1]%mod*ffac[c-1]%mod*ffac[a+b+c-1]%mod*ksm(ffac[a+b-1],mod-2)%mod*ksm(ffac[a+c-1],mod-2)%mod*ksm(ffac[b+c-1],mod-2)%mod);
	return 0;
}
```

---

## 作者：gxy001 (赞：9)

很显然，题目等价于将三角形网格划分为若干个菱形的方案数，每个菱形由两个三角形组成，而这个方案又与 $a\times b\times c$ 的长方体中，堆叠了一些靠一墙角放置的 $1\times 1\times 1$ 的小正方体的方案数相等。

考虑每个位置的高度，问题等价于，给一个 $a\times b$ 的网格 $h$ 内填数，每个位置可以填 $[0,c]$ 中的整数，且要满足 $h_{i,j}\le h_{i+1,j}\land h_{i,j}\le h_{i,j+1}$ 的方案数。

设 $g_{i,j}=h_{i,j}+i$，则有 $g_{i,j}< g_{i+1,j}\land g_{i,j}\le g_{i,j+1}$，且所有满足 $g_{i,j}< g_{i+1,j}\land g_{i,j}\le g_{i,j+1}$ 且每个位置都在 $[1,a+c]$ 中的 $g$ 与 $h$ 一一对应。

我们发现，$g$ 是一个半标准杨表，根据钩长公式，我们知道，其填数方案数即为

$$
\prod\limits_{i=1}^a\prod\limits_{j=1}^b\frac{a+c+j-i}{a-i+b-j+1}\\
=\prod\limits_{i=1}^a\prod\limits_{j=1}^b\frac{(a+c-i)+j}{(a+b-i+1)-j}\\
=\prod\limits_{i=1}^a\frac{(a+c+b-i)!(a-i)!}{(a+c-i)!(a+b-i)!}\\
=\frac{f(a+b+c-1)f(a-1)f(c-1)f(b-1)}{f(b+c-1)f(a+c-1)f(a+b-1)}\\
f(n)=\prod\limits_{i=1}^ni!
$$

预处理 $O(a+b+c)$，单次询问 $O(1)$。

```cpp
#include<iostream>
using std::cin;
using std::cout;
int const mod=998244353;
int fac[3000010],f[3000010],iv[3000010],a,b,c;
int pow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod,y>>=1;
	}
	return res;
}
int main(){
	std::ios::sync_with_stdio(false),cin.tie(nullptr);
	cin>>a>>b>>c;
	int n=a+b+c;
	fac[0]=f[0]=1;
	for(int i=1;i<=n;i++) fac[i]=1ll*i*fac[i-1]%mod;
	for(int i=1;i<=n;i++) f[i]=1ll*f[i-1]*fac[i]%mod;
	iv[n]=pow(f[n],mod-2);
	for(int i=n;i;i--) iv[i-1]=1ll*iv[i]*fac[i]%mod;
	cout<<(1ll*f[n-1]*f[a-1]%mod*f[b-1]%mod*f[c-1]%mod*iv[a+b-1]%mod*iv[a+c-1]%mod*iv[b+c-1]%mod)<<'\n';
	return 0;
}
```



---

## 作者：littlez_meow (赞：3)

upd 2023.8.8：更换图片

提供一种不需要行列式的做法。

杨表好难……

[题目指路](https://www.luogu.com.cn/problem/solution/P8114)

## step 1：转化问题

二分图的完美匹配似乎不太好处理，用一一对应来转化它的个数！

【引理 1】求证：该二分图的完美匹配种类数等于将原六边形按三角形网格划分成若干由两个网格组成的菱形的方案数。

证明：对于一个菱形划分方案，将每个菱形包含的两个三角形网格连一条边，得到的图是该二分图的子图。由于任意两个菱形不重合，其为该二分图的一个匹配；由于菱形覆盖了所有三角形，其为该二分图的完美匹配。

反之，我们也可以用上面的方法用该二分图的完美匹配构造一个菱形划分。

因此，该二分图的完美匹配与菱形划分一一对应。

故二者数量相同。

例如题面中的这种完美匹配，它对应的菱形划分如下图：

![举例](https://cdn.luogu.com.cn/upload/image_hosting/x3z8vicx.png)

空间想象能力强的同学可能已经感觉上图有立体感了。的确，菱形划分和正方体堆叠确实一一对应。

【引理 2】求证：建立空间直角坐标系，在 $(a,0,0),(0,b,0),(0,0,c)$ 围成的长方体中堆叠边长为 $1$ 的正方体，使得每行向 $x$ 轴正方向、每列向 $y$ 轴正方向的正方体堆叠高度单调不升。这样的正方体堆叠个数等于对边长分别为 $a,b,c$ 的平行六边形的菱形划分数。

不那么严格的证明：

对任意一种正方体堆叠，令投影线平行于其中小正方体最长对角线，该堆叠正投影即为一种菱形划分。因此二者一一对应，数量相同。

最后，设第 $i$ 行、第 $j$ 列上小正方体的高度为 $h_{i,j}$，则高度构成矩阵：

$$H=\begin{bmatrix}
 h_{1,1} & h_{1,2} & \cdots & h_{1,b}\\
 h_{2,1} & h_{2,2} & \cdots & h_{2,b}\\
 \vdots  & \vdots & \ddots  & \vdots \\
 h_{a,1} & h_{a,2} & \cdots & h_{a,b}
\end{bmatrix}$$

其满足 $h_{i,j}\ge h_{i+1,j},h_{i,j}\ge h_{i,j+1},h_{i,j}\in[0,c]$。

也就是说，每行每列都单调不升。这和杨表很像！但杨表是每行每列都严格递减。就算是半标准，也要每列严格递减。有没有什么办法转化？

还记得曾经不相邻排列的推法吗？我们只要给某些数加上一些数，就可以把小于等于转化为严格小于。

考虑把第 $1$ 行每个数加上 $a$，第二行加上 $a-1$，第 $i$ 行加上 $a-i+1$，第 $a$ 行加上 $1$。这样，矩阵中 $h_{i,j}+a-i+1>h_{i+1,j}+a-i$，每列严格递减。该矩阵就变成了半标准杨表，值域为 $[1,a+c]$。

自此，原问题转化为了半标准杨表计数。

## step 2：推式子
给出值域为 $[1,n]$ 半标准杨表的钩长公式：

$$|\operatorname{SSYT}(\lambda)|=\prod\limits_{(i,j)\in\lambda}\dfrac{n-i+j}{\operatorname{hook}(i,j)}$$

其中 $\operatorname{SSYT}(\lambda)$ 为在杨图 $\lambda$ 中填入 $1-n$ 中整数可得到的半标准杨表构成的集合。

该公式证明比较复杂，大家可以自己去[维基百科](https://en.wikipedia.org/wiki/Hook_length_formula#Related_formulas)上查看。

带入数值得到答案为：

$$\prod\limits_{(i,j)\in\lambda}\dfrac{a+c-i+j}{\operatorname{hook}(i,j)}$$

拆开钩长，由于本题中 $\lambda$ 为 $a\times  b$ 的表格，有：

$$\prod\limits_{i=1}^a\prod\limits_{j=1}^b\dfrac{a+c-i+j}{(a-i)+(b-j)+1}$$

展开内层循环，得：

$$\prod\limits_{i=1}^a\dfrac{(a+c-i+b)(a+c-i+b-1)\cdots(a+c-i+1)}{(a+b+1-i-1)(a+b+1-i-2)\cdots(a+b+1-i-b)}$$

缩写成阶乘形式，整理分子分母：

$$\prod\limits_{i=1}^a\dfrac{(a+b+c-i)!(a-i)!}{(a+c-i)!(a+b-i)!}$$

预处理阶乘和阶乘逆元，枚举 $i$，时间复杂度 $O(a)$。

但是，根据题面，式子中 $a,b,c$ 应是对称的。我们的结果显然还能化简。

观察到式子中出现了很多形如 $(t-i)!$（$t$ 是常数）的东西，我们尝试设一个函数。

设 $f(n)=\prod\limits_{i=1}^n {i!}$，有 $f(n-1)=\prod\limits_{i=1}^n {(n-i)!}$。

因此对于 $m>n$，有：

$$\prod\limits_{i=1}^n (m-i)!=\dfrac{f(m-1)}{f(m-n-1)}$$

左右展开就可以证明了。

带回原式，得：

$$\dfrac{f(a+b+c-1)f(a-1)f(b-1)f(c-1)}{f(a+b-1)f(a+c-1)f(b+c-1)}$$

其中 $f(n)=\prod\limits_{i=1}^n {i!}$。

这个式子就优美多了，$a,b,c$ 三者对称。

预处理 $f$ 再计算仍然是 $O(a+b+c)=O(a)$ 时间复杂度。

## step 3：附上代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a),i##i(b);i<=i##i;++i)
#define R(i,a,b) for(int i(a),i##i(b);i>=i##i;--i)
#define _ 0
using namespace std;
const int MOD=998244353;
inline ll inv(ll base){
	ll res(1);
	int expo=MOD-2;
	while(expo){
		if(expo&1) res=res*base%MOD;
		base=base*base%MOD;
		expo>>=1;
	}
	return res;
}
int a,b,c,f[3000000];
inline int input(){
	int x;char ch;
	for(ch=getchar();!isdigit(ch);ch=getchar());
	for(x=0;isdigit(ch);ch=getchar()) x=x*10+(ch^48);
	return x;
}
int main(){
	a=input(),b=input(),c=input();
	f[0]=1;
	F(i,1,a+b+c-1) f[i]=(ll)f[i-1]*i%MOD;
	F(i,1,a+b+c-1) f[i]=(ll)f[i-1]*f[i]%MOD;
	cout<<inv(f[a+b-1])*inv(f[a+c-1])%MOD*inv(f[b+c-1])%MOD*f[a+b+c-1]%MOD*f[a-1]%MOD*f[b-1]%MOD*f[c-1]%MOD;
	return ~~(0^_^0);//每日卖萌（1/1）
}
```

图片由 [@Aaronwrq](https://www.luogu.com.cn/user/426313) 使用 Geogebra 绘制，特此感谢。

不喜勿喷owo~

---

## 作者：IdnadRev (赞：3)

正三角形匹配会形成一个菱形，也就是求将六边形划分成若干菱形的方案数。

根据经典的几何意义，其又等价于立方体的凸堆叠方案数。将每个位置的高度写成一个 $a\times b$ 的矩阵，其与杨表很类似，尝试向这方面靠。

将第 $i$ 行所有数字加 $i$，矩阵会形成值域 $[1,a+c]$ 的半标准杨表，使用半标准杨表的钩子公式：

$$\prod_{i,j}\frac{V+j-i}{h_{\lambda}(i,j)}=\prod_{i,j}\frac{a+c+j-i}{(a-i)+(b-j)+1}$$

$$=\prod_{i,j}\frac{(a+c-i)+j}{(a+b+1-i)-j}=\prod_i\frac{(a+c-i+b)!}{(a+c-i)!}\cdot\frac{(a-i)!}{(a+b-i)!}$$

这已经是可以计算的形式了，但结果有一个特别简洁的形式：（令 $H(x)=\sum_{i=0}^{x-1}i!$）

$$=\frac{H(a+b+c)}{H(b+c)}\cdot H(a)\cdot\frac{H(c)}{H(a+c)}\cdot\frac{H(b)}{H(a+b)}$$

$$=\frac{H(a+b+c)H(a)H(b)H(c)}{H(a+b)H(a+c)H(b+c)}$$

代码不贴了。

---


# [集训队互测 2019] 简单计数

## 题目背景

## 警告，滥用本题者将被封号。


$\mathsf C \color{red}\mathsf{auchySheep}$ 近期优化了他的 快速数论变换 (NTT) 模板的常数，现在他能在 $0.1\text s$ 内轻松跑过 $n=10^9$ 了，所以他准备用下面的这个简单计数题也考验一下你的常数优化水平。

## 题目描述

传说，在很久很久以前，有一张 $n​$ 个点的带标号**有向无环**图。每条边有一个颜色，为 $k$ 种不同颜色中的一种。这张图满足如下性质：

- 每个点有不超过 $1$ 条出边  
- 每个点的入边条数在集合 $S$ 中

由于某种原因，你想知道这样的图的个数。由于这样的图可能很多，你只要输出答案对 $998244353​$ 取模的值。

两个图不同当且仅当存在一条从某个点 $a$ 到某个点 $b$ 的有向边，它只在恰好一个图中出现，或在两个图中都出现但颜色不同。

## 说明/提示

【样例一解释】  
有如下 $13$ 个符合题意的图，其中 $a \to b$ 表示一条从 $a$ 连向 $b$ 的有向边：

1. 没有边
2. $1 \to 2$
3. $2 \to 1$
4. $1 \to3$
5. $3 \to 1$
6. $2 \to 3$
7. $3 \to 2$
8. $1 \to 2 \to 3$
9. $1 \to 3 \to 2$
10. $2 \to 1 \to 3$
11. $2 \to 3 \to 1$
12. $3 \to 1 \to 2$
13. $3 \to 2 \to 1$

【数据范围】  
数据共分为 $7$ 个子任务。

- 子任务 $1$（$5$ 分）：$n \leq 8$。
- 子任务 $2$（$10$ 分）：$n \leq 5000$。
- 子任务 $3$（$30$ 分）：$n \leq 10^5$。
- 子任务 $4$（$20$ 分）：$n \leq 10^7$。
- 子任务 $5$（$15$ 分）：$n \leq 10^8$。
- 子任务 $6$（$10$ 分）：$S=\{0,1\}$。
- 子任务 $7$（$10$ 分）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 9 \times 10^8​$，$1 \le k \le 10^7$，$S \neq \varnothing$，$S \subseteq \{0,1,2,3\}$。 

By：fjzzq2002  
来源：2019 年集训队互测 Day5

## 样例 #1

### 输入

```
3 1 2
0 1```

### 输出

```
13```

## 样例 #2

### 输入

```
8 2 3
0 2 3```

### 输出

```
7497953```

## 样例 #3

### 输入

```
3000 2 3
0 1 3```

### 输出

```
500207304```

## 样例 #4

### 输入

```
10000000 3 2
0 3```

### 输出

```
238588124```

## 样例 #5

### 输入

```
876543210 233 4
0 1 2 3```

### 输出

```
467638557```

# 题解

## 作者：myee (赞：9)

### 思路

可以发现就是让你求**限制度数的根向树森林**，每条边带颜色的计数之和。

易知必有 $0\in S$，否则直接输出 $0$ 即可。

考虑求出单颗树的 $\rm EGF$：

$$f=z\sum_{a\in S}{f^a\over a!}$$

故

$$z=\frac f{\sum_{a\in S}{f^a\over a!}}$$

即 $f$ 的复合逆为

$$f^{(-1)}=\frac z{\sum_{a\in S}{z^a\over a!}}$$

然后答案即为

$$
\sum_i[{z^n\over n!}]{k^{n-i}f^i\over i!}=k^n[{z^n\over n!}]\exp\frac fk
$$

众所周知，有另类 Lagrange Inversion

$$[z^n]H(F)=[z^n]HG'\left(\frac zG\right)^{n+1}$$

但是这里求导不方便，不如直接用扩展 Lagrange Inversion

$$[z^n]H(F)=\frac1n[z^{n-1}]H'\left(\frac zG\right)^n$$

即

$$k^n[{z^n\over n!}]\exp\frac fk=k^{n-1}[{z^{n-1}\over(n-1)!}]\exp\frac zk\left(\sum_{a\in S}{z^a\over a!}\right)^n$$

于是即求

$$k^{n-1}[{z^{n-1}\over(n-1)!}]\exp\frac zk\left(\sum_{a\in S}{z^a\over a!}\right)^n$$

即

$$[{z^{n-1}\over(n-1)!}]\exp z\left(\sum_{a\in S}{(kz)^a\over a!}\right)^n$$

怎么求呢？

注意到 $z^n$ 是 D-finite 的，$\sum_{a\in S}{(kz)^a\over a!}$ 是代数的，所以 $\left(\sum_{a\in S}{(kz)^a\over a!}\right)^n$ 是 D-finite 的！

具体的，设 $F=\sum_{a\in S}{(kz)^a\over a!},G=F^n$，则

$$FG'=nF'G$$

于是 $G$ 可以整式递推。

总所周知 $\exp z$ 也可以整式递推，所以 $H=e^zG$ 也可以整式递推！

求完系数后还要乘一个 $n!$，这个也可以整式递推（快速阶乘算法，或者分段打表）。

当然，你也可以直接对 $\Xi(e^zG)$ 求 ODE，然后上整式递推，也没有问题。

至此，我们得到一个 $O(\sqrt n\log n)$ 的做法，其中 $|S|$ 作为常数忽略不计。

### Code

咕了。


---

## 作者：_lbw_ (赞：2)

P6132 题解

为什么有人把代码咕了？？？我们贺题解的怎么活？？？

题目简意即为求度数 $\in S$ 的有标号森林数量。

设 $f$ 为有标号树的 EGF，有：

$$f=z\sum_{x\in S}\dfrac{(kf)^x}{x!}$$

答案即为 $[\dfrac{z^n}{n!}]\exp f$。

使用扩展 Lagrange Inversion，答案即为：

$$[\dfrac{z^{n-1}}{(n-1)!}]\exp z\left(\sum\limits_{x\in S}\dfrac{(kz)^x}{x!}\right)^n$$

而 $\exp z$ D-Finite，$\sum\limits_{x\in S}\dfrac{(kz)^x}{x!}$ 是代数的，所以原式是 D-Finite 的。

然后使用倍增矩阵法求整式递推，时间复杂度 $\mathcal{O}(\sqrt{n}\log n|S|^2+\sqrt{n}|S|^3)$。

```cpp
#define G 3
#include<map>
#include<set>
#include<ctime>
#include<cmath>
#include<queue>
#include<bitset>
#include<cstdio>
#include<vector>
#include<random>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
#define I ll
#define her1 20081214
#define IV void
#define cht 998244353
#define ld long double
#define Aestas16 392699
#define ull unsigned long long
#define cp(x,y)memcpy(x,y,sizeof y)
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=e[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register i64 i=j;i>=n;i--)
#define EL(i,now)for(register i64 i=first[now];i;i=e[i].nxt)
#define FL(i,j,n)for(register i64 i=j;i<=n;i++)
//#define D(i,j,n)for(int i=j;i>=n;i--)
//#define E(i,now)for(int i=first[now];i;i=e[i].nxt)
//#define F(i,j,n)for(int i=j;i<=n;i++)
//#define DL(i,j,n)for(register ll i=j;i>=n;i--)
//#define EL(i,now)for(register ll i=first[now];i;i=e[i].nxt)
//#define FL(i,j,n)for(register ll i=j;i<=n;i++)
ll read(){
	ll ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans*f;
}
#undef ll
#include "assert.h"
mt19937_64 rnd(her1);
#include "functional"
using i64 = long long;
const int MAX = 1e6;
const int maxn = 1e6+5;
const int maxm = (1<<20)+5;
#define in(i,V) F(i,0,(i64)V.size()-1)
#define My_assert(expr,tips) ((expr)?(void(0)):(puts(tips),exit(0)))
IV cadd(i64&x,i64 val){x=(x+val)%cht;}

i64 w[maxm];
i64 qpow(i64 n,i64 base=cht-2){
	i64 ans=1;
	while(base){
		if(base&1)ans=ans*n%cht;
		n=n*n%cht;base>>=1;
	}
	return ans;
}
IV init(i64 limit){
	for(int i=1,j,k;i<limit;i<<=1)
		for(w[j=i]=1,k=qpow(3,(cht-1)/(i<<1)),j++;j<(i<<1);j++)
			w[j]=w[j-1]*k%cht;
}
const i64 invG = qpow(G);
IV DIT(i64*a,i64 limit){
	for(i64 i,j,k=limit>>1,L,*W,*x,*y,z;k;k>>=1)
		for(L=k<<1,i=0;i<limit;i+=L)for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
			*y=(*x+cht-(z=*y))* *W%cht,*x=(*x+z)%cht;
}
IV DIF(i64*a,i64 limit){
	for(i64 i,j,k=1,L,*W,*x,*y,z;k<limit;k<<=1)
		for(L=k<<1,i=0;i<limit;i+=L)for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
			z=1ll* *W* *y%cht,*y=(*x-z)%cht,*x=(*x+z)%cht;
	reverse(a+1,a+limit);
	i64 inv=qpow(limit);
	F(i,0,limit-1)a[i]=a[i]*inv%cht;
}
#define poly vector<i64>
IV print(poly v){in(i,v)cout<<v[i]<<' ';puts("");}
poly operator*(const poly&A,const poly&B){
	static i64 f[maxm],g[maxm];
	My_assert(A.size()&&B.size(),"multiply with a empty poly.");
	i64 limit=1;
	while(limit<=A.size()+B.size())
		limit<<=1;
	F(i,0,limit-1)f[i]=g[i]=0;
	in(i,A)f[i]=A[i];in(i,B)g[i]=B[i];
	DIT(f,limit);DIT(g,limit);
	F(i,0,limit-1)f[i]=f[i]*g[i]%cht;DIF(f,limit);
	poly C;C.resize(A.size()+B.size()-1);
	in(i,C)C[i]=f[i];
	return C;
}
poly operator+(const poly&A,const poly&B){
	poly C;C.resize(max(A.size(),B.size()));
	in(i,C)C[i]=0;
	in(i,A)cadd(C[i],A[i]);
	in(i,B)cadd(C[i],B[i]);
	return C;
}

i64 fac[maxn],ifac[maxn];
i64 C(i64 n,i64 m){
	if(n<m||n<0||m<0)return 0;
	return fac[n]*ifac[m]%cht*ifac[n-m]%cht;
}
IV init(){
	fac[0]=1;F(i,1,MAX)fac[i]=fac[i-1]*i%cht;
	ifac[MAX]=qpow(fac[MAX]);D(i,MAX-1,0)ifac[i]=ifac[i+1]*(i+1)%cht;
}
IV remod(poly&A,i64 n){while(A.size()>n)A.pop_back();}

i64 n,k,L,s[10],dp[maxn],A[5],B[5];

poly mat[4][4],tmp[4][4];i64 val[4][4];
poly Shift(poly f,i64 n,i64 k){
	//known f(0)~f(n),get f(k)~f(n+k)
	k=(k%cht+cht)%cht;poly nw=f,g(2*n+1);
	F(i,0,n)nw[i]=((n-i&1)?-1:1)*ifac[i]*ifac[n-i]%cht*nw[i]%cht;
	F(i,0,2*n)g[i]=qpow(i+k-n);
	nw=nw*g;poly Ans(n+1);
	i64 mul=1;F(i,0,n)mul=mul*(k-i)%cht;
	F(i,0,n){
		Ans[i]=nw[i+n]*mul%cht;
		mul=mul*qpow(i+k-n)%cht*(i+k+1)%cht;
	}
	return Ans;
}
IV solve(i64 d,i64 B,i64 N){
	if(d==1){
		F(i,0,3)F(j,0,3)mat[i][j]={0,0};
		mat[1][0]={1,B+1};
		mat[2][1]={1,B+1};
		mat[3][2]={1,B+1};
		F(k,0,3){
			mat[3-k][3]={(::B[k]-A[k]*(1-1-k))%cht,
			-A[k]*B%cht+(::B[k]-A[k]*(1-1-k))%cht};
		}
		return;
	}
	solve(d>>1,B,N);d>>=1;
	F(i,0,3)F(j,0,3){
		tmp[i][j]=Shift(mat[i][j],d,d+1);
		F(k,0,d-1)mat[i][j].push_back(tmp[i][j][k]);
	}
	i64 k=d*qpow(B);d<<=1;
	F(i,0,3)F(j,0,3)tmp[i][j]=Shift(mat[i][j],d,k);
	F(i,0,d){
		mem(val,0);
		F(p,0,3)F(q,0,3)F(r,0,3)
			cadd(val[p][r],mat[p][q][i]*tmp[q][r][i]);
		F(x,0,3)F(y,0,3)
			mat[x][y][i]=val[x][y];
	}
}

i64 R[4][4],sv[4][4];
IV print_M(i64 M[4][4]){
	F(i,0,3){
		F(j,0,3)cout<<(M[i][j]+cht)%cht<<' ';
		puts("");
	}
	puts("");
}
IV Mul(){
	mem(sv,0);
	F(i,0,3)F(j,0,3)F(k,0,3)
		cadd(sv[i][k],val[i][j]*R[j][k]);
	F(i,0,3)F(j,0,3)val[i][j]=sv[i][j];
}
i64 Solve(i64 N){
	i64 v=ceil(log2(sqrt(N))),B=(1<<v);
	i64 k=N/B;
	solve(B,B,N);
	mem(val,0);
	F(i,0,3)val[i][i]=1;
	F(i,0,k-1){
		F(x,0,3)F(y,0,3)R[x][y]=mat[x][y][i];
		Mul();
	}
	F(i,k*B+1,N){
		F(i,0,3)F(j,0,3)R[i][j]=0;
		R[1][0]=i;R[2][1]=i;R[3][2]=i;
		F(k,0,3){
			R[3-k][3]=(::B[k]-A[k]*(i-1-k))%cht;
		}
		Mul();
	}
	return val[3][3];
}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);

	init();init(1<<18);

	n=read();k=read();L=read();
	F(i,1,L)A[s[i]=read()]=1;
	if(!L||s[1])return puts("0"),0;
	i64 mul=1;
	F(i,0,3)A[i]=mul*A[i]%cht*ifac[i]%cht,mul=mul*k%cht;
	F(i,0,2)B[i]=A[i+1]*(i+1)%cht;
	F(i,0,3)B[i]=(n*B[i]+A[i])%cht;
	i64 inv=qpow(A[0]);
	F(i,0,3)A[i]=A[i+1];
	F(i,0,3)A[i]=A[i]*inv%cht,B[i]=B[i]*inv%cht;

	return cout<<(Solve(n-1)+cht)%cht,0;
}
```

---


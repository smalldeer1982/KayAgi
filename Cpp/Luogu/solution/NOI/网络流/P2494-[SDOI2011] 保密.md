# [SDOI2011] 保密

## 题目描述

现在，保密成为一个很重要也很困难的问题。如果没有做好，后果是严重的。比如，有个人没有自己去修电脑，又没有拆硬盘，后来的事大家都知道了。

当然，对保密最需求的当然是军方，其次才是像那个人。为了应付现在天上飞来飞去的卫星，军事基地一般都会建造在地下。

某 K 国的军事基地是这样子的：地面上两排大天井共 $n_1$ 个作为出入口，内部是许多除可以共享出入口外互不连通的空腔，每个空腔有且只有两个出入口，并且这两个出入口不会在同一排。为了方便起见，两排出入口分别编号为 $1, 3, 5, \dots$ 和 $2, 4, 6, \dots$ 并且最大的编号为 $n_1$。

虽然上面扯了那么多关于保密的东西，但是其实解密也是一件很纠结的事情。但其实最简单直接暴力无脑的解密方法就是找个人去看看…

我们有很牛 X 的特种部队，只需要派出一支特种部队到 K 国基地的某个出入口，那么和这个出入口直接相连的所有空腔都可以被探索，但也只有这些空腔可以被这支部队探索。现在有足够多的特种部队可以供你调遣，你必须使用他们调查完所有的 K 国基地内的空腔。

当然，你的基地离 K 国基地不会太近，周边的地图将会给你，表示为 $n$ 个检查点和 $m$ 条连接这些点的道路，其中点 $1$ 到点 $n_1$ 就是 K 国基地的出入口，点 $n$ 是你的部队的出发点。对每条道路，有不同的通行时间 $t$ 和安全系数 $s$ 。因为情报部门只对单向的道路安全系数进行了评估，所以这些道路只允许单向通行，并且不会存在环。

一支特种部队从你的基地出发，通过某条路径，到达某个 K 国基地出入口，此时这支部队的危险性表示为总时间和这条路径经过的所有道路的安全系数和的比值。整个行动的危险性表示为你派出的所有部队的危险性之和。你需要使这个值最小的情况下探索整个 K 国基地。

快点完成这个任务，在 K 国的叫兽宣布你是 K 国人之前。

## 说明/提示

- 对 $30\%$ 的数据，$n \leq 30$；
- 对 $60\%$ 的数据，$n \leq 300$；
- 另外 $40\%$ 的数据 $n_1 \leq 20$。
- 对于 $100\%$ 的数据，$4 \leq n \leq 700$，$m \leq 100000$，$a, b \leq n$，$1 \leq t, s \leq 10$，$m_1 \leq 40000$，$n_1 < \min(n, 161)$，$u, v \leq n_1$，$u$ 是奇数，$v$ 是偶数。

## 样例 #1

### 输入

```
5 5
5 1 10 1
5 1 10 1
5 2 9 1
5 3 7 1
5 4 8 1
4 4
1 2
1 4
3 2
3 4```

### 输出

```
17.0```

# 题解

## 作者：w4p3r (赞：83)

## 前言

我觉得这是一道好题，因为它考到了许多知识，将很多知识综合了起来

## 思路

拿到这道题之后，我们应该将这个问题拆成两个问题

**第一，求n到每个出入口的时间和与安全系数和比值最小的路径**

**第二，求出探索所有空腔的最小代价**

## 做法

#### 第一个问题
假设我们去的是点$x$,那么我们就是要找到一条从$n$到$x$的路径，使得$\sum (Ti *xi)/\sum (Si*xi )$最小，

($xi$表示第i条边在不在该路径上，若在为1，不在即为0)


我们考虑**二分答案**，假设我们当前二分的值为$ans$,

那如果这个答案满足条件，就要满足 $\sum (Ti *xi)/\sum (Si *xi)<=ans$，

移项可得$\sum (Ti*xi) -\sum (Si*xi)*ans<=0$，

即为$\sum((Ti-ans*Si)*xi)<=0$

那我们只要使每条边权改为$Ti-Si*xi$,然后看$n$到$x$的路径是否$<=0$即可

**这就是一个简单的01分数规划，我相信看这道题的人应该都看得懂qwq**

但是要求多个点到$n$的最小路径，所以考虑**整体二分**

~~但貌似听说不整体二分也过得去，如果你不会的话就一个一个二分吧233~~

**最短路用什么方法呢？Spfa?Dijkstra?Floyed?**

no no no!!!

首先，这道题有负边，所以$Dijkstra$首先淘汰，$SPFA?$,但是这道题$m$又有足足$1e5$,跑$SPFA$巨慢啊，$Floyed$对于$n<=700$来说根本不可能

那咋办啊？？

等等，我们是不是漏了什么？

没有环啊！！！

那就简单了，跑个拓扑序就完事了啊（~~我也不知道我前面扯那么多干嘛~~）

#### 第二个问题

现在我们得到了$n$到所有出入口的最小路径，那如何求探索所有空腔的最小代价呢？

首先，我觉得题目都已经在~~疯狂暗示~~告诉我们这是个一个二分图了

 *-----每个空腔有且只有两个出入口，并且这两个出入口不会在同一排。为了方便起见，两排出入口分别编号为$1,3,5…$和$2,4,6…$并且最大的编号为$n1$。*
 
两排，每个出口一排一个，这不是二分图是什么？？

其实这个网络流模型也并不难建立，

从源点往每个奇数点建边，流量为从$n$到该点的最小路径

对于每个空腔的两个出入口$u,v$,假设$u$是奇数,则从u向v建一条流量为inf的边

从每个偶数点往汇点建边，流量为从$n$到改点的最小路径

**问题是为什么那么建图呢？**

其实我们在这里利用的是最小割，因为对于每一个空腔的出入口$u,v$，我们必须选择一个，让$u$往$v$建inf边的意义就是我们为了让$u$和$v$分开，我们就必须在$u$和
$v$和之间选一条边割掉，割掉的代价即为从$n$到改点的最小路径，

然后由最大流最小割定理，跑最小割即可

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#define inf 0x7fffffff/2
#define eps 1e-3
#define N 100010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
struct Edge
{
	int next,to;
	double s,t;
}E[N<<1];
int Head[N],ecnt;
int n,U[N],V[N],m,n1,m1;
int pre[N],minn[N];
double dist[N],D[N];
int depth[N],Index[N];
struct edge
{
	int next,to;
	double fl;
}e[N*10];
int head[N],cnt=1;
int q[N],ql[N],qr[N];
queue<int>qu;
int vis[N];
int pos[N],nowpos;
int ss,tt,maxflow;
int Stack[N],top;
inline void Add_edge(int from,int to,double s,double t)
{
	E[++ecnt].to=to;E[ecnt].next=Head[from];E[ecnt].s=s;E[ecnt].t=t;Head[from]=ecnt;Index[to]++;
}//对原图进行建边
inline void Topu(double x)
{
	for(register int i=1;i<n;i++)dist[i]=inf;dist[n]=0;
	for(register int i=1;i<=n;i++)
	{
		int now=pos[i];
		for(register int j=Head[now];j;j=E[j].next)
		{
			dist[E[j].to]=min(dist[E[j].to],dist[now]+E[j].t-E[j].s*x);
		}
	}
}//求最短路
void Q(double L,double R,int l,int r)
{
	if(l>r)return ;
	if(fabs(R-L)<=eps){for(register int i=l;i<=r;i++)D[q[i]]=L;return ;}
	double mid=(L+R)/2;
	Topu(mid);
	int nowl=0,nowr=0;
	for(register int i=l;i<=r;i++)if(dist[q[i]]<=0.0){ql[++nowl]=q[i];}else qr[++nowr]=q[i];
	for(register int i=l;i<=l+nowl-1;i++)q[i]=ql[i-l+1];
	for(register int i=l+nowl;i<=r;i++)q[i]=qr[i-nowl-l+1];
	Q(L,mid,l,l+nowl-1);Q(mid+eps,R,l+nowl,r);
}//整体二分
inline void add_edge(int from,int to,double fl){e[++cnt].to=to;e[cnt].next=head[from];e[cnt].fl=fl;head[from]=cnt;}
  //对网络流建边
inline int bfs()
{
	memset(depth,0,sizeof(depth));while(!qu.empty())qu.pop();
	qu.push(ss);depth[ss]=1;
	while(!qu.empty())
	{
		int x=qu.front();qu.pop();
		for(register int i=head[x];i;i=e[i].next)
		{
			if(fabs(e[i].fl-0)>=eps&&!depth[e[i].to])depth[e[i].to]=depth[x]+1,qu.push(e[i].to);
		}
	}
	return depth[tt];
}
double dfs(int now,double flow)
{
	if(now==tt)return flow;
	double ret=0;
	for(register int i=head[now];i;i=e[i].next)
	{
		if(fabs(ret-flow)<=eps)return flow;
		if(fabs(e[i].fl-0)>=eps&&depth[e[i].to]==depth[now]+1)
		{
			double fl=dfs(e[i].to,min(e[i].fl,flow-ret));
			if(fabs(fl-0)>=eps)
			{
				ret+=fl;
				e[i].fl-=fl;
				e[i^1].fl+=fl;
			}
		}
	}
	if(fabs(ret-0)<=eps)depth[now]=0;
	return ret;
}
inline double Dinic()
{
	double sum=0,x=0;
	while(bfs()){x=1;while(fabs(x-0)>=eps){x=dfs(ss,inf);sum+=x;}}
	return sum;
}//最大流，即为最小割
inline void Prepare()
{
	nowpos=0;top=0;
	for(register int i=1;i<=n;i++)if(!Index[i])Stack[++top]=i;
	while(top)
	{
		int x=Stack[top--];pos[++nowpos]=x;
		for(register int i=Head[x];i;i=E[i].next)
		{
			Index[E[i].to]--;if(!Index[E[i].to])Stack[++top]=E[i].to;
		}
	}
}//求拓扑排序
int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++)q[i]=i;
	for(register int i=1;i<=m;i++)
	{
		int from,to;double s,t;
		scanf("%d%d%lf%lf",&from,&to,&t,&s);
		Add_edge(from,to,s,t);
	}
	Prepare();
	Q(0,inf,1,n-1);D[n]=0;
	m1=read(),n1=read();
	for(register int i=1;i<=m1;i++)U[i]=read(),V[i]=read();
	tt=n1+m1+1;
	for(register int i=1;i<=n1;i++)
	{
		if(i&1)add_edge(ss,i,D[i]),add_edge(i,ss,0);
		else add_edge(i,tt,D[i]),add_edge(tt,i,0);
	}
	for(register int i=1;i<=m1;i++)
	{
		if(V[i]&1)swap(U[i],V[i]);
		add_edge(U[i],V[i],inf),add_edge(V[i],U[i],0);
	}
	double ans=Dinic();
	if(ans>1e8){printf("-1\n");}
	else printf("%.1lf\n",ans);
	return 0;
}
```

**如果认为我这篇题解对你有帮助的可以给我点一下赞qwq。如果有任何疑问，或者认为我的题解有什么问题的话，请务必私信我，感激不尽！我会努力把我的题解写得最好的!**

---

## 作者：Danno0v0 (赞：8)

~~这就是超融合的力量吗嘤嘤嘤~~

QP 提醒：本篇题解的方法都非常~~弱智~~蒟蒻而且贼~~废话连篇~~详细，意在帮助像我这样的蒟蒻，大佬请自行跳过

前置芝士：01 分数规划，最小割

一看题，~~看了半个小时后~~我们看出来它是一道融合了两道题的题目：

- 求出到达每个地道口最小代价 

- 求出探索所有空腔的最小代价

好理解吧，原问题就是求出探索所有空腔最小代价，然后为了到达空腔就必须先到地道口，所以也要求出到所有地道口的代价。

### - 第一部分：求出到达每个地道口最小代价- 01 规划

读一下题，要使走过道路的时间总和比上危险值总和最小——裸的 01 规划呢。

所以就是求到达每个地道口的 $min\dfrac{ \sum(t_n\times x_n) }{\sum(s_n\times x_n)}$

所以令最小为 $ans$ ：

$\dfrac{ \sum(t_n\times x_n) }{\sum(s_n\times x_n)}=ans$

然后移项：

$\sum(t_n\times x_n)-\sum(s_n\times x_n)\times ans=0$

提取公因式：

$\sum x_n\times(t_n-s_n\times ans)=0$

01 规划的基操应该，应该不用多说吧？不懂的再去重新做几道 01 题好了（雾）

观察式子，然后就发现这其实是要求每条边的边权为 $t_n-s_n \times ans$ 的最短路（选出一些边使它能到达地道口， $x_n$ 就表示了选不选，总代价就是路径总长度，为了使代价尽可能小所以是最短路）。

这道题因为是个有向无环图所以最短路直接用拓扑就可以求出来啦。

然后就是 01 规划的标准操作：二分 $ans$ ，当最终结果
如果小于 $0$ 就说明还有更优解，二分左区间，反之二分右区间。

然后对每个地道口进行二分，就轻松愉快的求出了到达每个地道口的最小代价啦~

（听说可以整体二分?蒟蒻不会呀 QAQ ）

### - 第二部分：求出探索所有空腔的最小代价-最小割

两排地道口，每个空腔的出入口不在同一排而是在两排一排一个，这不是二分图是什么呢？

二分图能考什么，最大匹配，最小费用最大匹配，最小割，这道题当然是最小割啦。

奇数号口连源点，流量是到这个口的代价，偶数号口连汇点，流量同上。

然后没有一个空腔在这两个点之间连一条流量无限的边，跑一个最小割/最大流就解出了这一部分了。

为什么呢，你想一下把源点和汇点当成敌方总部，特种部队过去把那个地道口给占掉了，然后就相当于所有的用这个空腔当出入口的都失去了与总部的连接然后就只有被乖乖占领啦。

然后为了占领所有空腔就是要让所有的空腔都不能和总部取得连接也就是让这个图不连通。

假若这个图连通，那么说明至少有一个空腔还是能和总部联系上的，这样的话说明这个空腔还没有被占领所以不符合题意。

然后假如有一个地道口你根本无法到达那就让割掉它的代价表示为无限大，然后假如最小割跑出来居然是个无限大那么说明必须要占一个你无法到达的地道口，这个时候输出 $-1$ 就可以了。

然后这道融合题就写出来了。

over！

~~虽然但是，上代码吧~~

```cpp
#include<bits/stdc++.h>
#define maxx 1000001
#define ahhhhhh 114514114.99  //恶臭
using namespace std;
int fi[maxx],nx[maxx],to[maxx],t[maxx],s[maxx],in[maxx][2],tot;//原图的边数组
int fi_dinic[maxx],nx_dinic[maxx],to_dinic[maxx],tot_dinic=1,depth[maxx];//网络流边数组
bool check[400][400];//网络流连边时判重
int n,m;
int S=290,T=299;
double dis[maxx],dis_goal[maxx],val[maxx];//dis：找最短路时的数组 dis_goal：到每个地道口最小代价 val：每条边流量上限
void link_mmp(int a,int b,int c,int d)//原图的边 
{
	nx[++tot]=fi[a];
	fi[a]=tot;
	to[tot]=b;
	t[tot]=c;
	s[tot]=d;
}
void link_dinic(int a,int b,double c)//最大流的边 
{
	nx_dinic[++tot_dinic]=fi_dinic[a];
	fi_dinic[a]=tot_dinic;
	to_dinic[tot_dinic]=b;
	val[tot_dinic]=c;
}
double find_shortest(double now,int goal)//拓扑找最短路 
{
	queue<int>que;
	for(int i=1;i<=n;i++)
	{
		in[i][0]=in[i][1];
		dis[i]=ahhhhhh;
		if(in[i][0]==0)
		{
			que.push(i);
		}
	}
	dis[n]=0.0;
	while(!que.empty())
	{
		int x=que.front();
		que.pop();
		for(int i=fi[x];i;i=nx[i])
		{
			int v=to[i];
			dis[v]=min(dis[v],dis[x]+(double)t[i]-(double)(s[i]*now));
			in[v][0]--;
			if(in[v][0]==0)
			{
				que.push(v);
			}
		}
	}
	return dis[goal];
}
void find_least(int goal)//01规划 
{
	double L=0.0,R=10.0;
	dis_goal[goal]=ahhhhhh;
	while(L<=R)
	{
		double M=(L+R)/2.0;
		if(find_shortest(M,goal)>1e-8)
		{
			L=M+0.00005;
		}
		else
		{
			dis_goal[goal]=M;
			R=M-0.00005;
		}
	}
}
bool bfs()//最大流dep标记 
{
	queue<int>que;
	memset(depth,0,sizeof(depth));
	depth[S]=1;
	que.push(S);
	while(!que.empty())
	{
		int x=que.front();
		que.pop();
		for(int i=fi_dinic[x];i;i=nx_dinic[i])
		{
			int v=to_dinic[i];
			if(val[i]!=0.0&&!depth[v])
			{
				depth[v]=depth[x]+1;
				que.push(v);
			}
		}
	}
	return depth[T];
}
double dinic(int x,double ins)//dinic 
{
	if(x==T)
	{
		return ins;
	}
	double out=0.0;
	for(int i=fi_dinic[x];i&&ins!=0.0;i=nx_dinic[i])
	{
		int v=to_dinic[i];
		if(val[i]!=0.0&&depth[v]==depth[x]+1)
		{
			double res=dinic(v,min(ins,val[i]));
			val[i]-=res;
			val[i^1]+=res;
			ins-=res;
			out+=res;
		}
	}
	if(out==0.0)
	{
		depth[x]=0;
	}
	return out;
}
int main()
{
	int a,b,c,d;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>c>>d;
		in[b][1]++;
		link_mmp(a,b,c,d);
	}
	int n1,m1,x,y,s=0;
	cin>>m1>>n1;
	for(int i=1;i<=n1;i++)
	{
		find_least(i);
	}
	for(int i=1;i<=m1;i++)
	{
		cin>>x>>y;
		if(!check[S][x])
		{
			link_dinic(S,x,dis_goal[x]);
			link_dinic(x,S,0.0);
			check[S][x]=1;
			check[x][S]=1;
		}
		if(!check[T][y])
		{
			link_dinic(y,T,dis_goal[y]);
			link_dinic(T,y,0.0);
			check[T][y]=1;
			check[y][T]=1;
		}
		if(!check[x][y])
		{
			link_dinic(x,y,ahhhhhh);
			link_dinic(y,x,0.0);
			check[x][y]=1;
			check[y][x]=1;
		}
	}
	double ans=0.0;
	while(bfs())
	{
		ans+=dinic(S,ahhhhhh);
	}
	if(ans>1e7)
	{
		cout<<-1;
		return 0;
	}
	printf("%.1f",ans);
}
```


---

## 作者：xiwang (赞：7)

~~讲真？没有题解？~~

所以题意就是给你两排点，一堆连接这两排点的边（二分图？）

还有另一堆除了计算基地到某个入口的最小危险值以外屁用没有的边

于是我们想，要是建个源汇点，完了奇数点（第一排入口）连源点，流量为

基地到这个入口的最小危险值；第二排入口（偶数点）连汇点，流量还是

基地到这个入口的最小危险值，完了连接x,y的空腔就是连接x,y流量为inf

的边.....我们就会发现这么建模之后跑个最小割就是答案。为啥？

因为这样建图砍掉一条连源点的边=这条边连的另一个点连的空腔不能走了=探索了

与它相连的空腔，代价为基地到这个入口的最小危险度；砍掉一条连汇点的边也同理

完了现在图建好了，最小割确定好了，dinic板子魔改好了，就差怎么求基地

到某个入口的最小危险值了

当然，你是不会直接求解的，但你是可以判断一个解是否合法啊

假设你搞了个解re,如果存在一堆边（为了方便，把他们编号为1至n）使得

(t1+t2+..+tn)/(s1+s2+...+sn)<=re

也就是

```
t1-s1*re+t2-s2*re+...+tn-sn*re<=0
```
就说明还有更小的解

这个式子拿每条边的t减s乘re当边权跑最短路，要是到终点最短路是负的就代表

这个re还可以更小，可以在跑最短路时一旦拓展到终点（一个入口）发现路径

长是负数就怒退，效率惊人。

完了你对每一个入口都二分一下求出最小危险值，带到上面的建图里，这题就

叫你水过去了，万岁！

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100000+10;
typedef double ddf;
int n,m,k,st,ed,n1,m1;
const ddf eps=1e-8;
ddf val[N];
namespace smz{
    const int N=100000+10;
const int fuck=0x3f3f3f3f;
const int inf=0x7fffffff;


struct edge{
    int to,next;ddf cap;
}g[N*10];
int head[N],tot=2;
void add(int st,int ed,ddf cp){
    g[tot].to=ed;
    g[tot].next=head[st];
    g[tot].cap=cp;
    head[st]=tot++;
}
void ins(int st,int ed,ddf cp){
    add(st,ed,cp);
    add(ed,st,0);
}

void init(){
    memset(head,0,sizeof(head));
    tot=2;
}
int lv[N];
queue<int>q;
bool bfs(int s,int t){
    memset(lv,0,sizeof(lv));
    lv[s]=1;
    while(!q.empty())q.pop();
    q.push(s);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=g[i].next){
            int v=g[i].to;
            if(g[i].cap>0&& !lv[v]){
                lv[v]=lv[x]+1;
                q.push(v);
            }
        }
    }
    return lv[t];
}

ddf dfs(int x,ddf mf){
    if(!mf||x==ed)return mf;
    ddf tmp=0;
    for(int i=head[x];i;i=g[i].next){
        int v=g[i].to;
        if(g[i].cap&&lv[v]==lv[x]+1){
            ddf f=dfs(v,min(mf,g[i].cap));
            tmp+=f;
            mf-=f;
            g[i].cap-=f;
            g[i^1].cap+=f;
        }
    }
    return tmp;
}

ddf dinic(int s,int t){
    ddf r=0;
    while(bfs(s,t))r+=dfs(s,1e50);
    return r;
}
}

struct edge{
    int to,next;ddf t,s;
}g[N<<1];
int head[N],tot=1;
void add(int st,int ed,ddf t,ddf s){
    g[tot]=(edge){ed,head[st],t,s};
    head[st]=tot++;
}
queue<int>q;
bool inq[N];
ddf dis[N];
bool sofa(int s,int t,ddf mid){
    for(int i=1;i<=n;i++)dis[i]=1e50;
    memset(inq,0,sizeof(inq));
    while(!q.empty())q.pop();
    dis[s]=0;inq[s]=1;q.push(s);
    while(!q.empty()){
        int x=q.front();q.pop();inq[x]=0;
        for(int i=head[x];i;i=g[i].next){
            int v=g[i].to;
            ddf xs=g[i].s,xt=g[i].t;
            if(dis[v]>dis[x]+xt-xs*mid){
                dis[v]=dis[x]+xt-xs*mid;
                if(v==t&&dis[v]<eps)return 1;
                if(!inq[v])inq[v]=1,q.push(v);
            }
        }
    }
    return dis[t]<-eps;
}
int main(){
    scanf("%d%d",&n,&m);
    int x,y;
    ddf s,t;
    for(int i=1;i<=m;i++){
    	scanf("%d%d%lf%lf",&x,&y,&t,&s);
    	add(x,y,t,s);
    }
    scanf("%d%d",&m1,&n1);
    for(int i=1;i<=n1;i++){
        ddf l=0,r=100,mid;
        while(r-l>1e-4){
            mid=(l+r)*0.5;
            if(sofa(n,i,mid))r=mid;
            else l=mid;
        }
        if(dis[i]==1e50)val[i]=1e50;
        else val[i]=(l+r)/2.0;
        //printf("val[%d]=%lf\n",i,val[i]);
    }
    smz::init();
    st=n1+1,ed=st+1;
    for(int i=1;i<=m1;i++){
        scanf("%d%d",&x,&y);
        if(y&1)swap(x,y);
        if(val[x]==1e50&&val[y]==1e50){
            printf("-1");return 0;
        }
        smz::ins(x,y,1e50);
    }
    for(int i=1;i<=n1;i++){
        if(i&1)smz::ins(st,i,val[i]);
        else smz::ins(i,ed,val[i]);
    }
    printf("%.1lf",smz::dinic(st,ed));
    return 0;
}
```

---

## 作者：litble (赞：4)

首先，关于这个危险性，长得就很像个分数规划。二分一下答案$k$，发现二分的答案还可以缩小的条件是存在一条路径$\frac{\sum t}{\sum s} \leq k$也就是$\sum t \leq \sum sk$，也就是把边权变成$t-sk$后跑最短路，如果我到终点的最短路小于0则二分的答案还可以缩小。

既然有负权边，怎么跑最短路呢？~~SPFA？不,SPFA已经死了！~~ 由于原图是一个DAG，所以可以用拓扑排序求最短路。

基地出入口有很多个，那就整体二分好啦！（虽然其实直接一个一个二分也没问题）

然后我们就求出了到每一个出入口的最小危险性，接下来就是一个网络流最小割的建图。选择类问题可以转化为最小割割哪条边的选择，也就是我们把奇数编号出入口与源点相连，偶数编号出入口与汇点相连，流量都是到这个出入口的最小危险性。如果一个空腔有$a$和$b$两个出入口，则在$a$与$b$之间连一条流量为$inf$的边。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
int read() {
	int q=0;char ch=' ';
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q;
}
typedef double db;
const db eps=1e-3;
const int N=705,M=100005,inf=0x3f3f3f3f;
int n,m,n1,m1;
db dis[N],ans;

namespace graph{
	int tot,top,js;
	int h[N],ne[M],to[M],tt[M],ss[M],du[N],st[N],p[N];
	int q[N],k1[N],k2[N];db f[N];
	void add(int x,int y,int s,int t)
		{to[++tot]=y,ne[tot]=h[x],h[x]=tot,ss[tot]=s,tt[tot]=t,++du[y];}
	void topsort() {//拓扑排序
		for(RI i=1;i<=n;++i) if(!du[i]) st[++top]=i;
		while(top) {
			int x=st[top];--top,p[++js]=x;
			for(RI i=h[x];i;i=ne[i]) {
				--du[to[i]];
				if(!du[to[i]]) st[++top]=to[i];
			}
		}
	}
	void shortest_way(db kans) {//求最短路
		for(RI i=1;i<=n;++i) f[i]=inf; f[n]=0;
		for(RI i=1;i<=n;++i) {
			int x=p[i];
			for(RI j=h[x];j;j=ne[j])
				f[to[j]]=min(f[to[j]],f[x]+(db)tt[j]-(db)ss[j]*kans);
		}
	}
	void slove(db l,db r,int ql,int qr) {//整体二分
		if(ql>qr) return;
		if(fabs(r-l)<eps) {for(RI i=ql;i<=qr;++i) dis[q[i]]=(l+r)/2.0;return;}
		db mid=(l+r)/2.0;int js1=0,js2=0;
		shortest_way(mid);
		for(RI i=ql;i<=qr;++i)
			if(f[q[i]]<0) k1[++js1]=q[i];
			else k2[++js2]=q[i];
		for(RI i=1;i<=js1;++i) q[ql+i-1]=k1[i];
		for(RI i=1;i<=js2;++i) q[ql+js1+i-1]=k2[i];
		slove(l,mid,ql,ql+js1-1),slove(mid,r,ql+js1,qr);
	}
	void work() {
		topsort();
		for(RI i=1;i<=n1;++i) q[i]=i;
		slove(0,11,1,n1);
		for(RI i=1;i<=n1;++i) if(dis[i]-eps>10.0) dis[i]=inf;//不可达的点
	}
}

namespace maxflow{
	int S,T,tot=1;
	int h[N],ne[M<<1],to[M<<1],lev[N],que[N];db flow[M<<1];
	void add(int x,int y,db z) {
		to[++tot]=y,ne[tot]=h[x],h[x]=tot,flow[tot]=z;
		to[++tot]=x,ne[tot]=h[y],h[y]=tot,flow[tot]=0;
	}
	int bfs() {
		for(RI i=1;i<=T;++i) lev[i]=0;
		int he=1,ta=1;lev[S]=1,que[1]=S;
		while(he<=ta) {
			int x=que[he];++he;
			if(x==T) return 1;
			for(RI i=h[x];i;i=ne[i])
				if(fabs(flow[i])>eps&&!lev[to[i]])
					lev[to[i]]=lev[x]+1,que[++ta]=to[i];
		}
		return 0;
	}
	db dfs(int x,db liu) {
		if(x==T) return liu;
		db sum=0;
		for(RI i=h[x];i;i=ne[i])
			if(fabs(flow[i])>eps&&lev[to[i]]==lev[x]+1) {
				db kl=dfs(to[i],min(flow[i],liu-sum));
				flow[i]-=kl,flow[i^1]+=kl,sum+=kl;
				if(fabs(liu-sum)<eps) return sum;
			}
		if(fabs(sum)<eps) lev[x]=-1;
		return sum;
	}
	void work() {//网络流建图
		S=n1+1,T=n1+2;int x,y;
		for(RI i=1;i<=n1;i+=2) add(S,i,dis[i]);
		for(RI i=2;i<=n1;i+=2) add(i,T,dis[i]);
		for(RI i=1;i<=m1;++i) {
			x=read(),y=read();
			if(!(x&1)) swap(x,y);
			add(x,y,inf);
		}
		while(bfs()) ans+=dfs(S,inf);
	}
}

int main()
{
    n=read(),m=read();
    for(RI i=1;i<=m;++i) {
    	int x=read(),y=read(),t=read(),s=read();
    	graph::add(x,y,s,t);
    }
    m1=read(),n1=read();
    graph::work();maxflow::work();
    if(ans>1e9) puts("-1");
    else printf("%.1lf\n",ans);
    return 0;
}
```

---

## 作者：lsw1 (赞：3)

好题。考察分数规划和网络流。

与这题类似的分数规划题有：

- [P2868 [USACO07DEC]Sightseeing Cows G](https://www.luogu.com.cn/problem/P2868)

- [P3199 [HNOI2009]最小圈](https://www.luogu.com.cn/problem/P3199)

- [P3288 [SCOI2014]方伯伯运椰子](https://www.luogu.com.cn/problem/P3288)

- [P3705 [SDOI2017]新生舞会](https://www.luogu.com.cn/problem/P3705)

与这题类似的网络流有：

- [P1361 小M的作物](https://www.luogu.com.cn/problem/P1361)

- [P1646 \[国家集训队\]happiness](https://www.luogu.com.cn/problem/P1646)

- [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774)

- - -

如果做了上面的网络流题目的话，我们不难想到这个题的一个建模方法：讲奇数点和原点之间、偶数点和汇点之间都连上流量为基地到奇数点或偶数点的最小危险值的边，对于每个空腔的两个端点之间都连上流量为正无穷大的边，然后跑最小割即可。最小割为正无穷大则无解。如果对网络流了解不深入的话，这里有一个通俗易懂的方法来理解这个做法：空腔连 $+\infty$ 是为了不割掉这条边，也就只能花费从源、汇点连出的边的边权割掉这些边，其中花费边权割掉一条边可以被看做花费危险值占领这个点。如果其他边都被割完，只能割边权为 $+\infty$ 的边，那么答案必然大于 $+\infty$ ，也即无解。

那么，如何求出边权（即起点 $n$ 到其他点的最小危险值）呢？显然应该用分数规划。二分最小危险值，假设此时二分到的值为 $mid$ ，由题意有：

$$\begin{aligned}\dfrac{\sum t}{\sum s}&\ge mid\\\sum t&\ge mid\times\sum s\\\sum t-mid\times\sum s&\ge0\end{aligned}$$

上面这些都是分数规划的基本套路。由题意有整个图是 DAG ，故将整个图的边权作为 $\sum t-mid\times\sum s$ ，拓扑排序求得 $n$ 到该点的最短路即可。

事实上，有一些点需要被注意：

- 比较大小关系、判断二分是否结束需要使用 $\operatorname{EPS}$ ，建议设为 $10^{-5}$ ;
- 如果起点与某点不可达，要将最小危险值设为 $+\infty$ 。
- 在我的代码中将网络流用的图与求最小危险值用的图共用，这是一个不非常好的习惯，如果非要这么做，请在每次使用前将图清空。
- 前文提到，判断有无解要与 $+\infty$ 比较大小。事实上，由于精度误差，代表 $+\infty$ 的双精度浮点数常量可能因会出现误差而变小。一个解决方案是与代表 $+\infty$ 的双精度浮点数常量的一半进行比较。


```cpp
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
#include <map>
using namespace std;
const double EPS = 1e-5;
const double INF = 1e18;
const int MAXN = 7e2;
const int MAXM = 1e5;
struct edge
{
	int u,v;
	double a,b;
}e[MAXM + 5];
vector<pair<int,double> >graph[MAXN + 5];
int ind[MAXN + 5];
double f[MAXN + 5];
double dis[MAXN + 5];
int n,m,m1,n1;
bool check(double x,int goal)
{
	for(int i = 1;i <= n;i++)
	{
		f[i] = INF;
		ind[i] = 0;
		graph[i].clear();
	}
	for(int i = 1;i <= m;i++)
	{
		graph[e[i].u].push_back(make_pair(e[i].v,e[i].a - e[i].b * x));
		ind[e[i].v]++;
	}
	queue<int>q;
	for(int i = 1;i <= n;i++)
	{
		if(ind[i] == 0)
		{
			q.push(i);
		}
	}
	f[n] = 0;
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i = 0;i < graph[u].size();i++)
		{
			int v = graph[u][i].first;
			double w = graph[u][i].second;
			ind[v]--;
			f[v] = min(f[v],f[u] + w);
			if(ind[v] == 0)
			{
				q.push(v);
			}
		}
	}
	return f[goal] > -EPS;
}
map<pair<int,int>,pair<int,int> >rev;
int dep[MAXN + 5];
int cur[MAXN + 5];
int s,t;
bool bfs()
{
	memset(dep,0,sizeof(dep));
	memset(cur,0,sizeof(cur));
	queue<int>q;
	q.push(s);
	dep[s] = 1;
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i = 0;i < graph[u].size();i++)
		{
			int v = graph[u][i].first;
			double w = graph[u][i].second;
			if(dep[v] == 0 && abs(w) > EPS)
			{
				dep[v] = dep[u] + 1;
				if(v == t)
				{
					return true;
				}
				q.push(v);
			}
		}
	}
	return dep[t] != 0;
}
double dfs(int u,double in)
{
	if(u == t)
	{
		return in;
	}
	double ans = 0;
	for(int i = cur[u];i < graph[u].size();i++)
	{
		cur[u] = i;
		int v = graph[u][i].first;
		double w = graph[u][i].second;
		if(dep[v] == dep[u] + 1 && abs(w) > EPS)
		{
			double tmp = dfs(v,min(in,w));
			if(abs(tmp) <= EPS)
			{
				dep[v] = 0;
				continue;
			}
			pair<int,int>x = rev[make_pair(u,i)];
			graph[u][i].second -= tmp;
			graph[x.first][x.second].second += tmp;
			in -= tmp;
			ans += tmp;
			if(abs(in) <= EPS)
			{
				break;
			}
		}
	}
	if(abs(ans) <= 0)
	{
		dep[u] = 0;
	}
	return ans;
}
void add(int u,int v,double w)
{
	graph[u].push_back(make_pair(v,w));
	graph[v].push_back(make_pair(u,0));
	rev[make_pair(u,graph[u].size() - 1)] = make_pair(v,graph[v].size() - 1);
	rev[make_pair(v,graph[v].size() - 1)] = make_pair(u,graph[u].size() - 1);
}
bool vis[MAXN + 5][MAXN + 5];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= m;i++)
	{
		scanf("%d%d%lf%lf",&e[i].u,&e[i].v,&e[i].a,&e[i].b);
	}
	scanf("%d%d",&m1,&n1);
	for(int i = 1;i <= n1;i++)
	{
		double l = 0,r = 10;
		while(r - l >= EPS)
		{
			double mid = (l + r) / 2;
			if(check(mid,i))
			{
				l = mid;
			}
			else
			{
				r = mid;
			}
		}
		if(10 - l <= EPS)
		{
			dis[i] = INF;
		}
		else
		{
			dis[i] = l;
		}
	}
	s = n + 1;
	t = n + 2;
	for(int i = 1;i <= t;i++)
	{
		graph[i].clear();
	}
	for(int i = 1;i <= m1;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		if(!vis[s][u] && !vis[u][s])
		{
			add(s,u,dis[u]);
			vis[s][u] = true;
			vis[u][s] = true;
		}
		if(!vis[u][v] && !vis[v][u])
		{
			add(u,v,INF);
			vis[u][v] = true;
			vis[v][u] = true;
		}
		if(!vis[v][t] && !vis[t][v])
		{
			add(v,t,dis[v]);
			vis[v][t] = true;
			vis[t][v] = true;
		}
	}
	double ans = 0;
	while(bfs())
	{
		ans += dfs(s,INF);
	}
	if(ans >= INF / 2)
	{
		printf("-1");
	}
	else
	{
		printf("%.1lf",ans);
	}
	return 0;
}
```

---

## 作者：小木虫 (赞：2)

### Preface  
高能预警，本题细节和实现比较繁杂，一些细节上的错误可能会浪费您大量的时间。  
### Problem  
给你一张 $n$ 个点，$m$ 条边的 DAG，其中编号前 $n_1$ 个点和 $m_1$ 条虚边组成了一张二分图。  
每条边有一个安全系数 $s_i$ 和用时 $t_i$，定义一条路径 $p$ 的危险值为：  
$$cost_p=\dfrac{\sum_{e_i\in p}t_{e_i}}{\sum_{e_i\in p}s_{e_i}}$$  
现在，对于每一条虚边，它的两个端点至少有一个要被选择，选择一个点 $u$ 的花费为 $\min cost_p,(s_p=n,t_p=u)$，$s_p$ 为 $p$ 的起始点，$t_p$ 为 $p$ 的结束点。  

现在问你，满足每一条虚边的两个端点至少有一个要被满足的情况下，最小的选择花费之和是多少？
### Solution  
首先，对于每一个 $u$，我们可以使用分数规划算出 $n$ 到 $u$ 的危险值最小的路径。  
具体来说，二分 $cost$，对于最终答案，移项得 $cost_p\times \sum_{e_i\in p}s_{e_i}=\sum_{e_i\in p}t_{e_i}$，再移项得 $\sum_{e_i\in p}t_{e_i}-cost_p\times \sum_{e_i\in p}s_{e_i}=0$。  

每一次 check 建出相应的图，即每条边权为 $t_i-cost_p\times s_i$，由于我们要求危险值尽可能小，所以在该图上跑最短路，若最短路小于 $0$ 则答案过大，否则过小，调整二分即可，因为是 DAG，所以拓扑排序最短路的复杂度是 $O(n+m)$。  

然后，我们记每个点 $u$ 的最小 $cost$ 为 $val_u$。  
现在就是在一个二分图上，每条边做决策，选左还是选右。  
多条边共用端点，无法动态规划。  
一般来说，带有无法消除的后效性的决策问题我们可以考虑最大流和最小割，这道题恰巧是经典模型。  

你先把二分图建出来，决策转最小割，发现一个边的两侧点必须有一个被割，然后你对每个点根据权值建图跑最小割即可。  
具体来说，我们建超级源汇，每个点按照其颜色向源或汇连一条流量为自身 $val$ 的边。  
对于每一条边，我们直接建，流量为 $\inf$。  
容易发现，我们选择一个点所对的边割一下能使所有与它有关的边断流，符合题目的决策要求。  

我们再跑一次网络流，这个题就做完了。  

接下来是一些注意事项：  
首先，请你注意二分 check 时每次各个数据的清空，尤其是点的度数，边等。  
请使用 C++ 自带的四舍五入的输出，防止被卡精度要多开几位再二分和网络流。  
请注意答案的上界和你精度转整数的乘积，保证网络流源点的流量用不完，最后判无解不会判错。  

code：  
```cpp
#include <bits/stdc++.h>
#define dll double
#define int long long
#define mp make_pair
#define fir first
#define sec second
using namespace std;
const int N=1e5+10,M=5e5+10;
int n,m,u,v,t,s,n1,m1;
int deg[N],val[N],dis[N];
vector <pair<int,int> > edge[N];
pair <pair<int,int>,pair<int,int> > E[M];
struct queue{
	int head,tail,que[N<<1];
	void init(){head=1;tail=0;}
	void pop(){++head;}
	void push(int x){que[++tail]=x;}
	int size(){return tail-head+1;}
	int front(){return que[head];}
}Q;
struct Shortest_path{
	void build(int C){
		for(int i=1;i<=n;i++)edge[i].clear(),deg[i]=0;
		for(int i=1;i<=m;i++){deg[E[i].fir.sec]++;
			edge[E[i].fir.fir].push_back(mp(E[i].fir.sec,10000*E[i].sec.fir-E[i].sec.sec*C));
		}for(int i=1;i<=n;i++)dis[i]=1e18;
	}
	bool run(int End){
		Q.init();dis[n]=0;
		for(int i=1;i<=n;i++)
			if(!deg[i])Q.push(i);
		while(Q.size()){
			int u=Q.front();Q.pop();
			if(u==End)return (dis[u]>0);
			for(auto to:edge[u]){
				int v=to.fir;int w=to.sec;
				deg[v]--;dis[v]=min(dis[v],dis[u]+w);
				if(!deg[v])Q.push(v);
			}
		}return true;
	}
}S1;
struct Max_Flow{
	int n,s,t,maxflow;
	int deep[N];int cnt=-1,head[N],cur[N];
	struct EDGE{
		int to,next,w;
	}edge[M];
	void add(int u,int v,int w){
		edge[++cnt].to=v;
		edge[cnt].next=head[u];
		head[u]=cnt;
		edge[cnt].w=w;
	}
	bool bfs(){
		for(int i=0;i<=n;i++)deep[i]=0;
		for(int i=0;i<=n;i++)cur[i]=head[i];
		Q.init();deep[s]=1;Q.push(s);
		while(Q.size()){
			int u=Q.front();Q.pop();
			for(int i=head[u];i!=-1;i=edge[i].next){
				int v=edge[i].to;int w=edge[i].w;
				if(w&&!deep[v]){
					deep[v]=deep[u]+1;
					Q.push(v);
				}
			}
		}
		if(deep[t]!=0)return true;
		else return false;
	}
	int dfs(int u,int limit){
		if(u==t)return limit;
		if(!limit)return 0;
		int flow=0;int f=0;
		for(int &i=cur[u];i!=-1;i=edge[i].next){
			int v=edge[i].to;int w=edge[i].w;
			if(deep[v]!=deep[u]+1)continue;
			f=dfs(v,min(limit,w));
			flow+=f;edge[i].w-=f;edge[i^1].w+=f;
			limit-=f;if(!limit)break;
		}return flow;
	}
	void DINIC(){
		maxflow=0;
		while(bfs())
			maxflow+=dfs(s,1e13);
	}
}S2;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		cin>>E[i].fir.fir>>E[i].fir.sec>>E[i].sec.fir>>E[i].sec.sec;
	cin>>m1>>n1;
	for(int i=1;i<=n1;i++){
		int l=0,r=1e13;
		while(l<r){
			int mid=(l+r)/2;
			S1.build(mid);
			if(S1.run(i))l=mid+1;
			else r=mid;
		}val[i]=l;
	}S2.s=0;S2.t=n1+1;S2.n=n1+1;
	for(int i=0;i<=n1+1;i++)S2.head[i]=-1;
	for(int i=1;i<=n1;i++){
		if(i&1)S2.add(S2.s,i,val[i]),S2.add(i,S2.s,0);
		else S2.add(i,S2.t,val[i]),S2.add(S2.t,i,0);
	}
	for(int i=1;i<=m1;i++){
		cin>>u>>v;
		if(v&1)swap(u,v);
		S2.add(u,v,1e13);
		S2.add(v,u,0);
	}S2.DINIC();
	if(S2.maxflow>=1e13)cout<<-1;
	else cout<<fixed<<setprecision(1)<<(dll)((int)(S2.maxflow/100)/100.0);
	return 0;
}
```


---

## 作者：sangshang (赞：0)

# Description

一张有向无环图。每条边可以用一个四元组表示 $(u,v,t,s)$，表示一条 $u\to v$，花费时间为 $t$，安全系数为 $s$ 的边。

对于每个特种部队想探查 $u$ 号出口，则必须从 $n$ 号点出发。经过一组边，会造成 $\frac{\sum t}{\sum s}$ 的危险系数。希望在所有基地都能被探索的前提下，危险系数总和最小。

# Solution

基本思路：（二分 + 拓扑排序 = 分数规划）+ 网络流。

## 分数规划

希望最小化 $\frac{\sum t}{\sum s}$，考虑二分。

判断 $\frac{\sum t}{\sum s}<x$，推式子：

$$
\begin{aligned}
\frac{\sum t}{\sum s}<x\\
\sum t<x\times\sum s\\
\sum t-x\times \sum s<0
\end{aligned}
$$

此时 $\operatorname{check(u)}$ 就变成求从每条边以 $t-x\times s$ 为边权，$n$ 开始，到 $u$ 的最短路。如果最短路小于零，返回真，否则返回假。因为是有向无环图，所以直接拓扑排序求最短路。

## 网络流

求出对于每个出入口，所产生的最小危险系数后，就可以网络流求解了。

>$u$ 是奇数，$v$ 是偶数。

一眼鉴定二分图。考虑最小割。

源点连奇数出入口，偶数出入口连汇点，边权就是到达那个出入口的最小危险系数；将一个出入口对应的边割掉表示派一个特种部队探查那个出入口。

对于每个空腔，其所连的两个出入口，至少有一个被探查（两个都被探查也行），所以考虑“并联电路”。

即，每个空腔，奇数出入口连它，他连偶数出入口，边权都为 $+\infty$。此时想要源汇不联通，就必须割掉两个出入口之一。

## [Code](https://www.luogu.com.cn/paste/4blb5kbj)

---

## 作者：Fzrcy (赞：0)

题目描述差评。

设 $f_i=\frac{\sum t}{\sum s}$ 表示从 $n$ 到 $i$ 的危险性，$\frac{\sum t}{\sum s}$ 显然是个 01 规划式子，于是我们可以二分答案，在 $O(n\log n)$ 的复杂度求出单个 $f_i$，然后用整体二分优化一下，在 $O(n\log^2n)$ 的复杂度求出 $f_{1,\dots,n1}$。

由于空腔连接的两个点的奇偶性不同，所以我们可以对前 $n1$ 个点建立二分图，于是问题变成点带权的最小边覆盖，可以转变为最小割问题。

再判断一下无解的情况即可。

总复杂度 $O(n\log^2n+\operatorname{dinic}(n1,m1))$。

```cpp
// Fzrcy
#include <bits/stdc++.h>
using namespace std;
constexpr int N=720,M=1e5+9;
int h[N],to[M],nt[M],w[M],e[M],cnt;
int n,m,n1,m1,ban[N]; double f[N],ans[N];
inline void Lnk(int u,int v,int z,int c)
    {nt[++cnt]=h[u],h[u]=cnt,to[cnt]=v,w[cnt]=z,e[cnt]=c;}
inline double dp(int u,double t){
    if(ban[u])return f[u];
    for(int i=h[u];i;i=nt[i])
        f[u]=min(f[u],dp(to[i],t)+(double)w[i]-t*e[i]);
    return ban[u]=1,f[u];
}
inline void DP(double mid){
    for(int i=1;i<n;i++)f[i]=1e9,ban[i]=0;ban[n]=1,f[n]=0;
    for(int i=1;i<n;i++)dp(i,mid);
}
inline void solve(vector<int>T,double l,double r){
    if(r-l<1e-5||T.empty()){for(auto i:T)ans[i]=(l+r)/2.;return;}
    vector<int>L,R;double mid=(l+r)/2.;DP(mid);
    for(auto i:T)(f[i]<=0.?L:R).push_back(i);
    solve(L,l,mid),solve(R,mid,r);
}
struct dinic{
    int h[N],to[M],nt[M],cnt=1,c[N];double cap[M];
    inline void Lnk(int u,int v,double c){
        nt[++cnt]=h[u],h[u]=cnt,to[cnt]=v,cap[cnt]=c;
        nt[++cnt]=h[v],h[v]=cnt,to[cnt]=u,cap[cnt]=0;
    }
    int dis[N],ban[N],st,ed,num; double F;
    inline bool bfs(){
        for(int i=1;i<=num;i++)dis[i]=ban[i]=0,c[i]=h[i];
        queue<int>q;q.push(st),dis[st]=0,ban[st]=1;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int i=h[u],v;i;i=nt[i])
                if(!ban[v=to[i]]&&cap[i]>1e-9)
                    dis[v]=dis[u]+1,q.push(v),ban[v]=1;
        }
        return ban[ed];
    }
    inline double dfs(int u,double a){
        if(fabs(a)<1e-9||u==ed)return a;double tot=0,f=0;
        for(int&i=c[u],v;i;i=nt[i]){
            if(dis[v=to[i]]==dis[u]+1&&(f=dfs(v,min(a,cap[i])))>1e-9){
                tot+=f,a-=f,cap[i]-=f,cap[i^1]+=f;if(a<1e-9)return tot;
            }
        }
        return tot;
    }
    inline double sol(int _s,int _t,int _n){
        st=_s,ed=_t,num=_n,F=0.;double tmp;
        while(bfs())F+=(tmp=dfs(st,1e9)),assert(tmp>=0.);
        return F;
    }
}G;
int main(){
    int st,ed;double lp=0.,rp=0.;cin>>n>>m;
    for(int i=1,x,y,z,c;i<=m;i++)cin>>y>>x>>z>>c,Lnk(x,y,z,c),rp+=z;
    cin>>m1>>n1,st=n1+1,ed=st+1;DP(0);
    for(int i=1,x,y;i<=m1;i++){
        cin>>x>>y,G.Lnk(x,y,1e10);
        if(f[x]>1e8&&f[y]>1e8){puts("-1");return 0;}
    }
    vector<int>T;for(int i=1;i<=n1;i++)T.push_back(i);solve(T,lp,rp);
    for(int i=1;i<=n1;i++)if(i&1)G.Lnk(st,i,ans[i]);else G.Lnk(i,ed,ans[i]);
    return printf("%.1lf\n",G.sol(st,ed,ed)),0;
}
```

---


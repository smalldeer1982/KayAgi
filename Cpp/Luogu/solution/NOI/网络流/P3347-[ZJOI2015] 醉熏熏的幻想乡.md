# [ZJOI2015] 醉熏熏的幻想乡

## 题目描述

傲娇少女幽香是一个很萌很萌的妹子，这些天幻想乡的大家都不知道为何还是拼命喝酒。很快酒就供不应求了，为了满足大家的需求，幽香决定在森林里酿酒。

经过调查，幽香发现森林里面有一些地方非常适合酿酒，有一些地方则非常适合存酒。幽香把这些适合酿酒的地方成为酿酒点，不妨认为有 $n$ 个酿酒点，从 $1$ 到 $n$ 标号。同时也有 $m$ 个适合存酒的地方，幽香将它们成为存酒点，从 $1$ 到 $m$ 标号。在一些酿酒点和存酒点之间存在通道，如果酿酒点 $i$ 到存酒点 $j$ 之间存在通道，那么 $i$ 生产的酒就可以被运输到 $j$。

但是在一个地方酿酒是需要消耗幽香的魔力的，由于存在管理上的因素，在酿酒点 $i$，制造 $x$ 升的酒，需要花费 $a_i\cdot x^2+b_i\cdot x$ 的魔力，注意 $x$ 不一定是一个非负整数，也可以是一个非负实数，同时在这个点最多只能制造 $c_i$ 升的酒。每个存酒点 $j$ 有一个容量 $d_j$，表示这个存酒点最多能存多少升的酒。

幽香打算存尽量多的酒，那么她需要再一些酿酒点生产一些酒并且通过通道将酒运送到存酒点。当然幽香想要节省自己的魔力，所以想让你帮忙算出在满足要求的情况下，最少花费的魔力是多少？

## 说明/提示

对于 $30\%$ 的数据：所有 $a_i=0$。

对于另 $30\%$ 的数据：最终答案的分母 $\leq 1000$。

对于 $100\%$ 的数据：$1\leq n\leq100$，$1\leq m\leq100$。

对于所有数据，$0\leq a_i,b_i,c_i,d_i\leq3$ 且都是整数。同时对于每个 $i$，$a_i+b_i>0$ 的通道的数量不超过 $1000$ 条。

非常神奇的是，对于所有数据存在一个正整数 $X\leq10^7$，使得存在一个最优解，使得所有路径上运送的酒的体积都是 $1/X$ 的倍数。

## 样例 #1

### 输入

```
10 10
0 2 3
2 3 2
3 1 3
1 2 1
1 0 1
1 1 0
3 3 0
1 2 2
3 1 1
3 1 0
3 1 2 2 3 1 1 2 2 0
0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0
1 0 0 0 1 0 0 0 0 0
1 0 1 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0 1 0```

### 输出

```
8
42/1
```

# 题解

## 作者：hehezhou (赞：19)

[可以在我的博客食用](https://hehezhou.github.io/2019/06/04/solve-P3347)  
抱歉上次链接挂错了  
[题面](https://www.luogu.org/problemnew/show/P3347)  
不得不说,浙江神队选拔赛真是年年毒瘤  
首先你需要有一点导数的知识,否则可能看不懂  
第一问很简单,建个图跑个最大流就好了(如果这都不会还敢来肝zjoi???)  
第二问

1. 有一个很$fAKe$的想法:  
因为费用不是一次函数,而是二次函数,并且我们观察到$a,b>=0$  
所以我先想到的是把每个酿酒点的费用强行离散,就是分成一个个区间,然后源点向每个酿酒点连很多条边,再跑费用流  
因为导函数单调不降,所以理论上是可以做到一定精度的  
~~然而我们观察到毒瘤出题人要求输出分数~~  

2. 让误差降为0???  
显然分的越细误差越小  
考虑分的份数无限趋于0  
此时费用即为导数  
然后就可以开个集合维护当前单位费用最小的酿酒点  
然后二分出当单位费用涨到多少时,集合内点会变化(要么是有新点加入,要么是有一个点跑满流)  
然后更新集合并进行下一轮操作  
~~然而二分还是只能做到一定精度~~(貌似乘上一个奥妙重重的系数可以二分整数,但我不知道是不是对的,而且复杂度好像是假的)

3. 正解!
观察一下解法2,就会发现当集合内点不变时,产酒量(当前流量)和费用呈线性关系,并且当集合内点变化时,费用的一次函数会发生变化，最多变化$2
n$次

所以搞一个函数$y = f(x)$表示单位费用(导数)不超过x时,最大流是多少  
那么$f(x)$可以被分成若干段,每段均为一次函数,最多$2n=O(n)$段  
然后可以用类似积分的方式搞出最小费用
![](https://hehezhou.github.io/images/P3345-1.png)
考虑怎么搞出这个函数  
如果只有二次函数的费用,那么f(x)会形成一个类似上凸壳的图像  
然后考虑分治,每次求出最左一次函数和最右一次函数的交点，如果再图像上则该点是区间内唯一断点，否则递归处理两个子区间
![](https://hehezhou.github.io/images/P3345-2.png)  
然后考虑一次函数  
发现b只会是0, 1, 2, 3(详细数据范围见[bzoj](https://www.lydsy.com/JudgeOnline/problem.php?id=4091))  
只要强行设1, 2, 3为断点即可  
记得加上左右边界的f(x)之差(见代码)
复杂度$O(n\times$网络流$)$
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const db feps = 1e-11, eps = 1e-9;
inline ll gcd(ll a, ll b) {
    return a == 0 || b == 0 ? a | b : gcd(b, a % b);
}
struct frac {
    ll a, b; //仔细看题发现要开ll
    inline frac(ll _a = 0, ll _b = 1) {
        int g = gcd(_a, _b);
        a = _a / g, b = _b / g;
    }
    friend inline frac operator + (frac a, frac b) {
        return frac(a.a * b.b + a.b * b.a, a.b * b.b);
    }
    friend inline frac operator - (frac a, frac b) {
        return frac(a.a * b.b - a.b * b.a, a.b * b.b);
    }
    friend inline frac operator * (frac a, frac b) {
        return frac(a.a * b.a, a.b * b.b);
    }
    friend inline frac operator / (frac a, frac b) {
        return frac(a.a * b.b, a.b * b.a);
    }
    inline operator db () {
        return 1.0l * a / b;
    }
};
int dis[210], s, t;
int a[110], b[110], c[110], d[110], ed[110][110];
struct edge {
    db f;
    int v, nxt;
} e[3010];
int tot, head[210], cur[210];
int n, m;
inline void addedge(int u, int v, db c) {
    e[++tot] = edge{c, v, head[u]};
    head[u] = tot;
    e[++tot] = edge{0, u, head[v]};
    head[v] = tot;
}
inline int bfs() {
    queue<int> q;
    memset(dis, -1, sizeof dis);
    dis[s] = 0;
    q.push(s);
    memcpy(cur, head, sizeof head);
    while(!q.empty()) {
        int now = q.front();
        q.pop();
        for(int i = head[now]; i; i = e[i].nxt) {
            if(~dis[e[i].v] || e[i].f < feps) continue;
            dis[e[i].v] = dis[now] + 1;
            q.push(e[i].v);
        }
    }
    return dis[t] != -1;
}
inline db dfs(int now, db limit) {
    if(now == t) return limit;
    db ans = 0;
    for(int &i = cur[now]; i; i = e[i].nxt) {
        if(e[i].f < feps || dis[e[i].v] != dis[now] + 1) continue;
        db lala = dfs(e[i].v, min(limit, e[i].f));
        limit -= lala, ans += lala;
        e[i].f -= lala, e[i ^ 1].f += lala;
        if(limit < feps) return ans;
    }
    return ans;
}
inline pair<frac, frac> dinic(db lambda) {
    tot = 1;
    memset(head, 0, sizeof head);
    for(int i = 1; i <= n; i++) {
        if(a[i] == 0) {
            if(b[i] < lambda) addedge(s, i, c[i]);
        }
        else {
            db w = (lambda - b[i]) / 2 / a[i];
            if(w > feps) addedge(s, i, min(1.0 * c[i], w));
        }
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) if(ed[i][j]) addedge(i, j + n, 1e9);
    for(int i = 1; i <= m; i++) addedge(i + n, t, d[i]);
    while(bfs()) dfs(s, 1e9);
    frac K, B;
    for(int i = 1; i <= n; i++) {
        if(dis[i] == -1) {
            if(a[i] == 0) {
                if(b[i] < lambda) B = B + frac(c[i]);
            }
            else {
                if(b[i] > lambda) B = B + frac();
                else if(a[i] * 2 * c[i] + b[i] > lambda)
                    K = K + frac(1, a[i] * 2), B = B - frac(b[i], a[i] * 2);
                else B = B + frac(c[i]);
            }
        }
    }
    for(int i = 1; i <= m; i++) if(dis[i + n] != -1) B = B + frac(d[i]);
    return make_pair(K, B);
}                                                                      //dinic板子
vector<pair<frac, frac> > v;
inline void solve(pair<frac, frac> fl, pair<frac, frac> fr) {          //分治找断点
    if(fl.first == fr.first && fl.second == fr.second) return;
    frac px = (fl.second - fr.second) / (fr.first - fl.first);
    pair<frac, frac> fml = dinic((db)px - eps), fmr = dinic((db)px + eps);
    if(fmr.first == fr.first && fmr.second == fr.second) {
        v.push_back(make_pair(px, fml.second + fml.first * px));
    } else {
        solve(fl, fml);
        solve(fmr, fr);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    s = 0, t = n + m + 1;
    for(int i = 1; i <= n; i++) scanf("%d%d%d", a + i, b + i, c + i);
    for(int i = 1; i <= m; i++) scanf("%d", d + i);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) scanf("%d", &ed[i][j]);
    frac ans, sum;
    cout << (sum = dinic(1e9).second).a;//第一问
    v.push_back(make_pair(frac(), 0));
    for(int i = 1; i <= 3; i++) {
        auto l = dinic(i - 1 + eps), r = dinic(i - eps);
        solve(l, r);
        v.push_back(make_pair(frac(i), r.second + frac(i) * r.first));
    }
    solve(dinic(3 + eps), dinic(1e9));//找断点
    for(int i = 1; i < v.size(); i++) {
        auto l = dinic((db)v[i].first - eps), r = dinic((db)v[i].first + eps), _l = dinic((db)v[i - 1].first + eps);//std=c++11(滑稽
        ans = ans + v[i].first * ((r.first - l.first) * v[i].first + r.second - l.second);
        ans = ans + (v[i].second - v[i - 1].first * _l.first - _l.second) * frac(1, 2) * (v[i].first + v[i - 1].first);//积分
    }
    if(ans.a < 0) ans.a = -ans.a, ans.b = -ans.b;
    return cout << ans.a << '/' << ans.b << endl, 0;
}
```

---

## 作者：Alex_Wei (赞：15)

> [P3347 [ZJOI2015] 醉熏熏的幻想乡](https://www.luogu.com.cn/problem/P3347)

相当不平凡的一道题，需要对费用流本质有深入理解。对 [hehezhou](https://www.luogu.com.cn/blog/hehezhou/solution-p3347) 题解的细节补充。

#### 瞬时费用

当费用计算没有平方项时，本题即最小费用最大流的裸题，但形如 $ax ^ 2 + bx + c$ 的费用计算方式让本题看起来不太可做。先类似费用流增广吧。

消去高次项的最好方法是求导，$ax ^ 2 + bx$ 求导得 $2ax + b$。考虑足够小的流量间隔 $\Delta t$，每次增广 $\Delta t$ 的流量，且每条边的 **瞬时费用** 为 $2ax + b$，其中 $x$ 为这条边的当前流量，则整个过程结束后，每条边被算入的总费用即 $ax ^ 2 + bx$。当 $\Delta t \to 0 ^ {+}$ 时，拟合效果趋于正解，但时间复杂度不允许。

上述过程是离散的，我们希望用连续的算法精确解决问题。

注意整张图是二分图，而增广费用仅在 $S$ 与左部点之间的连边产生：运输和储存无需费用，忽略掉它们，使得 **酿酒点与产生费用的边一一对应**。由此可知模拟费用流的过程中所有边的瞬时费用一定相等。将它们想象成连通器，注水时各容器内液面总保持在同一水平面上，类似地，当我们增大流量时，每条边的流量以某种方式增加，使得每条边的瞬时费用 $2ax + b$ 相等。

上述表述并不严谨，因为没有考虑到 $b_i$，更精确的比喻是底面连通但不处于同一水平面上的容器。连续地增大流量时，若整体最小费用 $< b_i$ 则该边流量不增加，否则所有瞬时费用等于整体最小费用的边的流量同时增加，保持这些边的瞬时费用相等，且整体最小费用不断增加。

也就是说，每条边的流量会在某一标准费用开始增加，并在某一标准费用停止增加。并非所有边同时从费用 $0$ 开始增加的原因为 $b_i$。停止增加的原因为酿酒点无法制造更多的酒，即 $x$ 等于 $c_i$，或所有与当前边对应酿酒点有通道的存酒点均无法存储更多的酒。

#### 折线积分

带着这样的认知，我们尝试解决原问题。因单条边的瞬时费用与流量呈 **定义域为 $\mathbb R$** 的一次函数关系，考虑求出瞬时费用关于流量的折线，其与 $x$ 轴围出的面积即为答案。但这无法求解，因为为了求出总流量一定时，每条边的流量并不确定，瞬时费用仍需使用离散的方法模拟。也许可以解方程，但相当复杂。

换种角度，当瞬时费用 $\lambda$ 确定时，每条边的流量上限 $L_i$ 也就决定了：$L_i = \min(c_i, \frac {\lambda - b_i}{2a_i})$，由 $2a_ix + b_i \leq \lambda$ 可知 $x \leq \frac {\lambda - b_i}{2a_i}$，注意特判 $a_i = 0$ 的情况。因此考虑求出流量关于瞬时费用的折线 $T$。

由每条边是否满流以及 $\lambda$ 是否小于 $b_i$ 可知每条边在 $\lambda$ 处流量 $x_i$ 关于 $\lambda$ 的变化关系。为防止 $\lambda$ 恰为顶点，需要对 $\lambda$ 进行扰动。

- 若当前边满流且 $\lambda \leq b_i$，说明 $L_i = 0$，不产生任何流量贡献，即 $x_i = 0$。
- 若当前边满流且 $\lambda  > b_i$，
    - 若 $L_i \leq c_i$，则 $L_i$ 随着 $\lambda$ 增大不断增加。因当前 $\lambda$ 当前边满流，故对于更小的 $\lambda$ 和 $L_i$ 同样满流，这一点不作证明。此时 $x_i = L_i = \frac{\lambda - b_i}{2a_i}$。
    - 若 $L_i > c_i$，则 $L_i$ 受到 $c_i$ 的限制一直等于 $c_i$，此时 $x_i = L_i = c_i$。
- 若当前边不满流，直接加入其对应流量。

这样，可以求出 $T$ 在 $\lambda$ 处 $\sum x_i$ 关于 $\lambda$ 的函数。 

#### 顶点

只要知道所有顶点的位置 $P_1, P_2, \cdots, P_k$，容易积分得到答案。进一步地，因为可以求出 $T$ 在 $\lambda$ 处的表达式，所以只要知道所有顶点的横坐标 $S = \{\lambda_1, \lambda_2, \cdots, \lambda_k\}$。

折线必然经过原点，所以 $0\in S$。此外不妨将 $R = \sum ac_i ^ 2 + bc_i$ 加入 $S$，因为当 $\lambda \geq R$ 时总流量等于原图最大流。

因 $b_i$ 为不大于 $3$ 的整数，且对于 $a_i = 0$ 的酿酒点，它的流量会在 $b_i$ 处从 $0$ 突变到某个值，所以令 $1, 2, 3 \in S$。

将 $0, 1, 2, 3, R$ 视为 $T$ 的断点，因为 $T$ 在这些位置发生了突变。其余所有顶点在两侧表达式的取值一定相同，因为没有其它会产生突变的因素。我们只需在它们形成的区间 $(l, r)$ 找出所有顶点的横坐标。

接下来介绍求解这个问题的技巧，相当人类智慧。

使用该技巧的前提为横坐标区间内折线没有断点且有凸性。因断点之间的折线 $T_{l, r}$ 由所有边的折线相加得到，且后者形如 $x_i = \min(c_i, \frac {\lambda - b_i}{2a_i})$（没有 $x_i = 0$ 的原因是已对 $b_i$ 形成的断点特殊考虑，区间内不含断点），上凸，故 $T_{l, r}$ 上凸。

令 $l + eps$ 处直线为 $A_l$，$r - eps$ 处直线为 $A_r$。

- 若 $A_l = A_r$，根据凸性可知区间内没有断点。
- 否则，令 $A_l$ 与 $A_r$ 交于 $P$，令 $\lambda_P + eps$ 处直线为 $A_m$，
    - 若 $A_m$ 等于 $A_r$，根据凸性可知区间内仅有 $P$ 一个顶点。
    - 否则，因进行随机扰动，故 $\lambda_P$ 几乎不可能为顶点横坐标，递归处理 $(l, \lambda_P)$ 和 $(\lambda_P, r)$ 即可。

整个过程的时间复杂度为 $\mathcal{O}(nD)$，$D$ 是单次 Dinic 的复杂度。

进一步地，传入直线 $A_l, A_r$ 作为 $solve$ 的参数可减小常数，递归时只需调用 $solve(A_l, A_m)$ 和 $solve(A_m, A_r)$，因 $\lambda_P$ 几乎不可能为顶点横坐标故可行。

#### 精度问题

看似已经大功告成了，但实际上还有不少细节需要讨论。

因题目要求用分数表示的精确值，这意味着与顶点相关的所有参数需要用分数而非小数表示。为此，需要手写分数类 `fraction` 及其四则运算。

然而题目只保证了最终答案的分母不超过 $10 ^ 7$，如果网络流的流量也用分数表示，很有可能因运算时表示爆炸而得到错误结果。因此，最大流全过程需要使用浮点数运算，但返回直线的所有参数必须为分数。

注意到求和过程中当前边不满流时加入的当前边流量无法表示成分数，解决办法为最大流最小割定理，所有未满流的酿酒点的流量之和等于所有与 $T$ 相连且被割掉的边的流量之和，而后者涉及到的所有边的流量等于容量，均为整数，可行。

此外，当区间内仅有 $P$ 一个顶点时，我们将 $\lambda_P$ 加上 $eps$ 求直线，但如果这个 $eps$ 无法在最大流过程中体现，则有可能求得 $A_m = A_l$，使得不断调用 $solve(A_l, A_r)$ 死循环。注意到 $\Delta \lambda$ 产生的 $\Delta L_i$ 最多衰减至  $\frac{\Delta \lambda} {2a_i}\geq \frac{eps}{6}$，因此最大流的 $feps$ 需要小于 $\frac {eps} {6}$。 

注意积分过程不是普通积分，因为答案为 $T$ 与 $y$ 轴而非 $x$ 轴围成的面积。

#### 代码

时间复杂度 $\mathcal{O}(nD)$，细节相当多。代码有部分细节注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
using ll = long long;
bool Mbe;
constexpr int N = 200 + 5;
constexpr int M = 2e3 + 5;
constexpr double eps = 1e-7;
constexpr double feps = 1e-8;
constexpr int inf = 0x1064822E;
// 为什么要给网络流再设一个 feps？
// 破案了，扰动的 eps 必须要在网络流上体现，否则会无限递归
// 除掉了一个 2a，所以理论上只要 eps / feps > 6 应该都没问题
// 确实是这样，feps = 1.6e-8 可以，但 1.7e-8 就爆炸了！
struct frac {
  ll a, b;
  frac(ll x = 0, ll y = 1) {ll d = __gcd(x, y); a = x / d, b = y / d;}
  bool operator == (const frac &z) const {return a * z.b == b * z.a;}
  frac operator + (const frac &z) const {return frac(a * z.b + b * z.a, b * z.b);}
  frac operator - (const frac &z) const {return frac(a * z.b - b * z.a, b * z.b);}
  frac operator * (const frac &z) const {return frac(a * z.a, b * z.b);}
  frac operator / (const frac &z) const {return frac(a * z.b, b * z.a);}
  double get() {return 1.0 * a / b;}
  void print() {cout << a << "/" << b;}
} ans;
struct flow {
  int cnt = 1, hd[N], nxt[M << 1], to[M << 1];
  double limit[M << 1];
  void clear() {cnt = 1, memset(hd, 0, sizeof(hd));}
  void add(int u, int v, double w) {
    nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v, limit[cnt] = w;
    nxt[++cnt] = hd[v], hd[v] = cnt, to[cnt] = u, limit[cnt] = 0;
  }
  int dis[N], cur[N], T;
  double dfs(int id, double res) {
    if(id == T) return res;
    double flow = 0;
    for(int i = cur[id]; i && res > feps; i = nxt[i]) {
      cur[id] = i;
      int it = to[i];
      double c = min(res, limit[i]);
      if(dis[id] + 1 == dis[it] && c > feps) {
        double k = dfs(it, c);
        flow += k, res -= k, limit[i] -= k, limit[i ^ 1] += k;
      }
    }
    return flow;
  }
  void maxflow(int s, int t) {
    T = t;
    while(1) {
      queue<int> q;
      memset(dis, -1, sizeof(dis));
      memcpy(cur, hd, sizeof(cur));
      q.push(s), dis[s] = 0;
      while(!q.empty()) {
        int t = q.front();
        q.pop();
        for(int i = hd[t]; i; i = nxt[i])
          if(dis[to[i]] == -1 && limit[i] > feps)
            dis[to[i]] = dis[t] + 1, q.push(to[i]);
      }
      if(dis[t] == -1) return;
      dfs(s, 1064);
    }
  }
};
int n, m, t;
int a[N], b[N], c[N], d[N], e[N][N];
// 开导！找到瞬时费用 = x 时对应最大流的直线
auto dinic(double lambda) {
  static flow g;
  g.clear();
  for(int i = 1; i <= n; i++)
    if(b[i] < lambda) {
      if(!a[i]) g.add(0, i, c[i]); // 特判 a[i] = 0
      else g.add(0, i, min(1.0 * c[i], (lambda - b[i]) / 2 / a[i]));
    }
  for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
      if(e[i][j])
        g.add(i, n + j, inf);
  for(int i = 1; i <= m; i++) g.add(n + i, t, d[i]);
  g.maxflow(0, t);
  frac K, B; // flow = K * lambda + B
  for(int i = 1; i <= n; i++)
    if(b[i] < lambda && g.dis[i] == -1) { // s -> i 之间的边被割掉
      if(!a[i]) B = B + frac(c[i]);
      else if(2 * a[i] * c[i] + b[i] < lambda) B = B + frac(c[i]); // 彻底满流，对最大流产生固定 c 贡献
      else K = K + frac(1, 2 * a[i]), B = B - frac(b[i], 2 * a[i]);
      // 没有彻底满流（在图上满流，但没有流满实际限制），产生直线 (lambda - b) / 2a 的贡献
    }
  for(int i = 1; i <= m; i++) if(g.dis[n + i] != -1) B = B + frac(d[i]); // == -> !=
  // n + i -> t 之间的边被割掉了，满流，最大流要加上这些贡献
  return make_pair(K, B);
}
vector<frac> pt;
void solve(auto l, auto r) {
  if(l == r) return; // 如果端点处两条直线重合，说明区间内没有顶点
  frac lambda = (r.se - l.se) / (l.fi - r.fi); // 求交点横坐标
  auto mid = dinic(lambda.get() + eps); // 扰动求解交点右侧的直线
  if(mid == r) return pt.push_back(lambda), void(); // 如果交点右侧直线和区间右端直线相同，说明 lambda 是唯一顶点
  solve(l, mid), solve(mid, r); // 否则向下分治处理子区间
}
bool Med;
int main() {
  fprintf(stderr, "%.4lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0);
  cin >> n >> m, t = n + m + 1;
  for(int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> c[i];
  for(int i = 1; i <= m; i++) cin >> d[i];
  for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
      cin >> e[i][j];
  pt.push_back(frac()); // 原点搞进去
  for(int d : {1, 2, 3}) {
    solve(dinic(d - 1 + eps), dinic(d - eps));
    pt.push_back(frac(d)); // 先求区间内部顶点，再强制 i 为断点
    // 断点产生因为从 lambda - eps 到 lambda + eps，所有 a[i] = 0，b[i] = lambda 的边从零流变成满流
  }
  solve(dinic(3 + eps), dinic(inf));
  for(int i = 1; i < pt.size(); i++) { // 不许导，积回去！
    auto l = dinic(pt[i].get() - eps), r = dinic(pt[i].get() + eps);
    ans = ans + pt[i] * (r.se - l.se + (r.fi - l.fi) * pt[i]);
    // 将跳跃的流量乘以费用加进去，这部分是标准矩形长乘宽，只会在断点 1, 2, 3 处产生贡献
    // 长为横坐标 pt[i]，宽为纵坐标之差，即 pt[i] 在左右两侧直线取值之差
    ans = ans + (pt[i - 1] + pt[i]) * (pt[i] - pt[i - 1]) * l.fi * frac(1, 2);
    // 梯形面积公式，pt[i] + pt[i - 1] 为上底 + 下底，(pt[i] - pt[i - 1]) * l.fi 为纵坐标之差，即高
    // 求出直线 l 左侧与 y 轴围成的梯形面积
  }
  cout << dinic(inf).se.get() << "\n";
  ans.print(), cout << "\n";
  return cerr << "Time: " << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n", 0;
}
/*
2022/7/14
start coding at 13:21
finish debugging at 14:13
*/
```

---

## 作者：Linshey (赞：3)

这里提供一个部分分做法。

假设 $a_i=0$，我们进行费用流建图，这是一个二分图，源点和左部点之间的连边带有费用，左部点和右部点的连边均为 $+\infty$ 没有费用，右部点和汇点之间的连边没有费用。直接跑费用流即可。

当 $a_i\not=0$，费用变成了一个二次函数。但是好在这还是凸的，启发我们模仿费用流算法。观察一下性质：

1. 一条增广路的费用完全由源点到左部点之间连的这条边确定。
2. 一个左部点失去作用（当源点到它的边流满或者它流向汇点的所有路都被堵死了）后，它永远都失去作用了，不可能恢复。

所以我们从所有还未失去作用的左部点中，选择一个 $\frac {d\ cost}{d\ flow}$ 最小的进行增广（也就是选择 $2a_i\cdot x_i+b_i)$ 最小的）。

但是注意到一些问题：导数随着流的增加而增加，很可能流着流着它就不是最优的了；或者有可能存在多个最优的，我们不知道选哪个去流。

分类讨论一下：

1. 当前导数最小的左部点中存在 $a_i=0$ 的：直接试图将其流满，然后删掉它。
2. 否则，让这些左部点同时流一个流量 $x$，其中 $x$ 是一个合理的步长。

但是这个第 2 类情况非常的难缠，因为它要满足流了这个流量后这些点的导数不超过其它左部点的导数的最小值，且要满足这个流量是能流的，且它们之间具体每个流多少很难知道……所以我们需要一个能够比较好的降低问题复杂性的方法。

类似 NOI 骑行川藏的做法，我们二分导数，表示最优左部点流了一个流量后它们的导数为 $mid$，`check` 时就判断这个导数是否超过了其它左部点的导数，以及是否存在一个合法的流的方案，直接在残量网络上跑 `dinic` 即可。

由于输出分数的问题，我们改在 `Stern Brocot Tree` 上二分，由于其经典性质，所以可以做到 $O(\log^2(U)$ 的二分，总的复杂度便是 $O(\log^2(U)\cdot nm\cdot n)$（因为凸壳大小是 $O(n)$ 的）。

过不去是因为中间表示膨胀的问题，开 `__int128` 都撑不住，估计写高精也没用（）

---

## 作者：DaiRuiChen007 (赞：2)

# P3347 题解

[Problem Link](https://www.luogu.com.cn/problem/P3347)

**题目大意**

> 给定一张有源汇二分图，左侧有 $n$ 个点，右侧有 $m$ 个点。
>
> 考虑图上的流，源到左侧第 $i$ 个点的流量上限为 $c_i$，且流量为 $x$（$x\in\mathbb R$）时会产生 $a_ix^2+b_ix$ 的费用，右侧点 $i$ 到汇的流量上限为 $d_i$，求最小费用最大流。
>
> 数据范围：$n,m\le 100,a_i,b_i\le 3$。

**思路分析**

以下 $\epsilon$ 均表示充分小的一个实数。

考虑将每条边拆成充分多条 $(\epsilon,(2a_ix+b_i)\times \epsilon)$ 的边，那么可以证明原图具有的最小费用最大流具有凸性。

考虑其他边没有流量限制的情况，那么原问题等价于求若干个二次函数的闵可夫斯基和。

可以考虑二分一个斜率 $\lambda$，每个二次函数只取导数 $\ge \lambda$ 的一段，记这些段在 $x$ 轴上的总长为 $f(\lambda)$，最后把 $f(\lambda)$ 关于 $y$ 轴围成的面积算出来即可。

感性理解就是考虑流量变大 $\epsilon$ 的时候会添加斜率为多少的边。

然后考虑原问题，相当于把每条边流量设成 $\min\left(c_i,\dfrac{\lambda-b_i}{2a_i}\right)$，求最大流即为 $f(\lambda)$。

注意到此时 $f(\lambda)$ 是一个有关最小割形态的函数，容易发现每条边只会加删一次，因此 $f(\lambda)$ 可以拆成 $\mathcal O(n)$ 段一次函数。

那么现在我们要求 $f(\lambda)$ 等价于：我们有一个形态未知的凸壳，每次能知道一个 $x$ 上对应的一次函数，那么我们考虑用如下的的分治算法求出凸壳：每次找出夹在两条直线 $l,r$ 中间还有没有别的直线：显然直接求 $l,r$ 交点 $+\epsilon$ 处的直线是否于 $r$ 即可，如果不等就继续分治两边。

注意可能有 $a_i=0$ 的直线，因此 $f(\lambda)$ 可能在 $1,2,3$ 处不连续，因此要特殊处理。

时间复杂度 $\mathcal O(nD)$，其中 $D$ 是一次网络流的复杂度。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct frac {
	ll x,y;
	frac(ll a=0,ll b=1) { ll d=__gcd(a,b); x=a/d,y=b/d; }
	friend bool operator==(const frac &u,const frac &v) {
		return u.x*v.y==u.y*v.x;
	}
	friend frac operator +(const frac &u,const frac &v) {
		return frac(u.x*v.y+u.y*v.x,u.y*v.y);
	}
	friend frac operator -(const frac &u,const frac &v) {
		return frac(u.x*v.y-u.y*v.x,u.y*v.y);
	}
	friend frac operator *(const frac &u,const frac &v) {
		return frac(u.x*v.x,u.y*v.y);
	}
	friend frac operator /(const frac &u,const frac &v) {
		return frac(u.x*v.y,u.y*v.x);
	}
	double eval() { return 1.*x/y; }
};

struct line {
	frac k,b;
	frac f(frac x) { return x*k+b; }
	friend bool operator ==(const line &u,const line &v) {
		return u.k==v.k&&u.b==v.b;
	}
};

namespace Flow {
const int MAXV=205,MAXE=1e5+5,inf=1e9;
const double eps=1e-8;
int S,T,ecnt,hd[MAXV],dep[MAXV],cur[MAXV];
struct Edge {
	int v,lst; double f;
}	G[MAXE];
void init() { ecnt=1,memset(hd,0,sizeof(hd)); }
void adde(int u,int v,double w) { G[++ecnt]={v,hd[u],w},hd[u]=ecnt; }
void link(int u,int v,double w) { adde(u,v,w),adde(v,u,0); }
bool BFS() {
	memset(dep,-1,sizeof(dep));
	memcpy(cur,hd,sizeof(cur));
	queue <int> Q; Q.push(S),dep[S]=0;
	while(Q.size()) {
		int u=Q.front(); Q.pop();
		for(int i=hd[u];i;i=G[i].lst) if(dep[G[i].v]==-1&&G[i].f>eps) {
			dep[G[i].v]=dep[u]+1,Q.push(G[i].v);
		}
	}
	return ~dep[T];
}
double dfs(int u,double f) {
	if(u==T||f<eps) return f;
	double r=f;
	for(int i=cur[u];i;i=G[i].lst) {
		int v=G[i].v; cur[u]=i;
		if(dep[v]==dep[u]+1) {
			double g=dfs(v,min(r,G[i].f));
			G[i].f-=g,r-=g,G[i^1].f+=g;
		}
		if(r<eps) return f;
	}
	return f-r;
}
void maxflow() { while(BFS()) dfs(S,inf); }
}
const int MAXN=105,inf=1e9;
const double eps=1e-7;
int n,m,a[MAXN],b[MAXN],c[MAXN],d[MAXN],e[MAXN][MAXN];
line flow(double k) {
	Flow::init();
	int S=Flow::S=n+m+1,T=Flow::T=n+m+2;
	for(int i=1;i<=n;++i) if(k>b[i]) {
		if(!a[i]) Flow::link(S,i,c[i]);
		else Flow::link(S,i,min((k-b[i])/2/a[i],1.*c[i]));
	}
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(e[i][j]) Flow::link(i,j+n,inf);
	for(int i=1;i<=m;++i) Flow::link(i+n,T,d[i]);
	Flow::maxflow();
	line f;
	for(int i=1;i<=n;++i) if(k>b[i]&&Flow::dep[i]==-1) {
		if(2*a[i]*c[i]+b[i]<k) f.b=f.b+c[i]; //full in real network
		else f.k=f.k+frac(1,2*a[i]),f.b=f.b-frac(b[i],2*a[i]); //not full in real network
	}
	for(int i=1;i<=m;++i) if(~Flow::dep[i+n]) f.b=f.b+d[i];
	return f;
}
vector <frac> g; //changing points
void conv(line l,line r) {
	if(l==r) return ;
	frac k=(r.b-l.b)/(l.k-r.k);
	line mid=flow(k.eval()+eps);
	if(mid==r) g.push_back(k);
	else conv(l,mid),conv(mid,r);
}
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d%d%d",&a[i],&b[i],&c[i]);
	for(int i=1;i<=m;++i) scanf("%d",&d[i]);
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) scanf("%d",&e[i][j]);
	printf("%d\n",(int)flow(inf).b.eval());
	g.push_back(0);
	for(int k:{1,2,3}) conv(flow(k-1+eps),flow(k-eps)),g.push_back(k);
	conv(flow(3+eps),flow(inf));
	frac ans=0;
	for(int i=1;i<(int)g.size();++i) {
		line l=flow(g[i].eval()-eps),r=flow(g[i].eval()+eps);
		ans=ans+g[i]*(r.f(g[i])-l.f(g[i])); //rectangle
		ans=ans+(g[i]+g[i-1])*(l.f(g[i])-l.f(g[i-1]))/2; //trapezoid
	}
	printf("%lld/%lld\n",ans.x,ans.y);
	return 0;
}
```

---


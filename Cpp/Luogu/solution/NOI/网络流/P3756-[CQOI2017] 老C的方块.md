# [CQOI2017] 老C的方块

## 题目描述

老 C 是个程序员。

作为一个懒惰的程序员，老 C 经常在电脑上玩方块游戏消磨时间。游戏被限定在一个由小方格排成的 $R$ 行 $C$ 列网格上，如果两个小方格有公共的边，就称它们是相邻的，而且有些相邻的小方格之间的公共边比较特殊。特殊的公共边排列得有很强的规律。首先规定，第 $1$ 行的前两个小方格之间的边是特殊边。然后，特殊边在水平方向上每 $4$ 个小方格为一个周期，在竖直方向上每 $2$ 个小方格为一个周期。所有的奇数列与下一列之间都有特殊边，且所在行的编号从左到右奇偶交替。

下图所示是一个 $R=C=8$ 的网格，蓝色标注的边是特殊边。首先，在第 $1$ 行，第 $1$ 列和第 $2$ 列之间有一条特殊边。因为竖直方向周期为 $2$，所以所有的奇数行，第 $1$ 列和第 $2$ 列之间都有特殊边。因为水平方向周期为 $4$，所以所有奇数行的第 $5$ 列和第 $6$ 列之间也有特殊边，如果网格足够大，所有奇数行的第 $9$ 列和第 $10$ 列、第 $13$ 列和第 $14$ 列之间都有特殊边。因为所有的奇数列和下一列之间都有特殊边，所以第 $3$ 列和第 $4$ 列、第 $7$ 列和第 $8$ 列之间也有特殊边，而所在行的编号从左到右奇偶交替，所以它们的特殊边在偶数行。如果网格的规模更大，我们可以用同样的方法找出所有的特殊边。

 ![](https://cdn.luogu.com.cn/upload/pic/5092.png) 

网格的每个小方格刚好可以放入一个小方块，在游戏的一开始，有些小方格已经放上了小方块，另外的小方格没有放。老 C 很讨厌下图所示的图形，如果他发现有一些小方块排列成了它讨厌的形状（特殊边的位置也要如图中所示），就很容易弃疗，即使是经过任意次旋转、翻转后排列成讨厌的形状，老 C 也同样容易弃疗。

 ![](https://cdn.luogu.com.cn/upload/pic/5093.png) 

为了防止弃疗，老 C 决定趁自己还没有弃疗，赶紧移除一些格子里小方块，使得剩下的小方块不能构成它讨厌的形状。但是游戏里每移除一个方块都是要花费一些金币的，每个方块需要花费的金币有多有少参差不齐。老 C 当然希望尽可能少的使用游戏里的金币，但是最少要花费多少金币呢？老 C 懒得思考，就把这个问题交给你了。


## 说明/提示

【输入输出样例 2 说明】 如图所示。容易发现，如果不移除第 $1$ 列第 $2$ 行的小方块，则至少要移除两个小方块，才能不包含老 C 讨厌的图形，花费至少 $20$ 个金币；而删除第 $1$ 列第 $2$ 行的小方块后，原有的讨厌图形全都不存在了，只需要花费 $15$ 个金币。


 ![](https://cdn.luogu.com.cn/upload/pic/5094.png) 

【数据规模与约定】

对于第 $1\sim 2$ 个测试点，$1\le C, R \le 100$，$1\leq n \leq 20$。

对于第 $3\sim 6$ 个测试点，$1 \leq C, R\leq 10^5$，$2000\le n\leq 5000$，数据有梯度。

对于第 $7\sim 10$ 个测试点，$1\leq C, R\leq 10^5$，$30000 \leq n\leq 10^5$，数据有梯度。

对于所有测试点，$1 \leq C, R, n \leq 10^5$，$ 1 \leq w \leq 10^4$。


## 样例 #1

### 输入

```
2 2 4
1 1 5 
1 2 6 
2 1 7 
2 2 8 ```

### 输出

```
5```

## 样例 #2

### 输入

```
3 3 7 
1 1 10 
1 2 15 
1 3 10 
2 1 10 
2 2 10 
2 3 10 
3 1 10 ```

### 输出

```
15```

# 题解

## 作者：Danno0v0 (赞：19)

Update 修改了错别字。

**在做这道题前，建议先做 [P2774 方格取数问题](https://www.luogu.com.cn/problem/P2774) 和 [P3355 骑士共存问题](https://www.luogu.com.cn/problem/P3355) 以保证您会染色网络流。**

一道染色题的究极形态。

首先看到方格想网络流。看到要欧拉掉点代价最小就可以想最小割了。最小割，又是在网格中，染色没跑了。

那么，我们进行黑白染色——

然后就会发现染完后什么用都没有。

难道是这道题不能用染色？

然后我们来看那四个老 C 不喜欢的图形，都是四个方块组成的。

而且——

我们发现，假如我们用四个颜色蓝绿红黄对这四个图形进行染色的话，就会发现，一定会存在这样一条路径：黄—蓝—特殊边—绿—红。

![](https://cdn.luogu.com.cn/upload/image_hosting/nce3wtu1.png)

有一点网络流的味道了。

试想一下，假设我们按 源点—黄—蓝—特殊边—绿—红—汇点 连边的话，假若图还连通就说明还有这种图形。必须把这个图变成不连通然后花费最小代价，这不就是最小割吗。

那么现在问题就是如何连层与层的边以及边权的问题了。

这就很简单了。

我们刚刚说一个不喜欢图形中的路径是黄—蓝—特边—绿—红，那就说明每一个蓝点只能由黄点溜过来，每一个特殊边只能由蓝点流过来，后面几层同理，所以就向黄点周围所有蓝点连边，所有蓝点向特殊边连，后面几层同理。

那么边权呢？

如果把一个黄点欧拉掉了，那么周围所有蓝点就都不可以通过这个黄点组成讨厌图形了。蓝点欧拉掉了特殊边也就不能组成特殊图形了。一下几层同理。

说明边权不在黄—蓝，绿—红而在黄—源点，蓝—特边，绿—特边，红—汇点上。回推一下这也是符合题意的。把黄点与源点的边割掉了就说明不选这个黄点，它连的所有蓝点都不会通过它产生不喜欢图形。那么，我们把上述 $4$ 种边的边权改成欧拉这个方块的代价，其余边全是 INF 就好了。然后我们发现，蓝—特殊边—绿 这一条路径其实和 蓝—绿 然后边权为 $\min(val[Blue],val[Green])$ 是等价的（因为每条特殊边最多只有一个蓝点和绿点和它连边），这样就顺便把特殊边这一层给优化掉了。

那么就还剩最后一个问题了。怎么染色让这个图中不管不喜欢图形怎么摆都是按以上路径的？

这个吗没什么技巧，多试试几次就出来了。总之就是这样染色的：

![](https://cdn.luogu.com.cn/upload/image_hosting/8mr3qrzt.png)

然后就会发现这个图的循环规律是每个 $2 \times 4$ 的长方形都是一样的，然后就对每一个长方形内八个不同格子进行特判就好了。

然后就是一些零零碎碎的问题：

第一个，怎么存每一个格子所建的节点。

按照以往的我们直接用列乘上 $10$ 的幂再加上行然后直接用数组存肯定是木大的，这个图很贴心的给出了长宽小于 $10^5$ ,所以不得不建一个 <long long,int> 的 map 来强行让每一个格子的坐标（按刚刚的方法把坐标处理成 long long ）与一个节点编号对应。

第二个，怎么比较快连边。

黄点和红点都是可以直接在读入时就直接向源汇连边的；蓝点和绿点在读入时记录一下然后读入完后再向周围的点连边好了。

code：（记住蓝点连边有两套不同方法，绿点连边也有两套不同方法，我为这个调了一个晚上）

```cpp
#include<bits/stdc++.h>
#define maxx 2000001
#define B 1
#define G 2
#define R 3
#define Y 4
#define S 1999999
#define T 2000000
using namespace std;
map<long long,long long>check;
map<long long,long long>cost_;
long long r,c,n;
struct node
{
	long long col,val,x,y;
}N[maxx];
long long fi[maxx],nx[maxx],to[maxx],val[maxx],depth[maxx],tot=1,num,heroes[maxx],b_g;
long long dx[4]={-1,0,0,1};
long long dy[4]={0,1,-1,0};
void link(long long a,long long b,long long c)
{
	nx[++tot]=fi[a];
	fi[a]=tot;
	to[tot]=b;
	val[tot]=c;
}
bool bfs()
{
	memset(depth,0,sizeof(depth));
	queue<long long>que;
	que.push(S);
	depth[S]=1;
	while(!que.empty())
	{
		long long x=que.front();
		que.pop();	
		for(long long i=fi[x];i;i=nx[i])
		{
			long long v=to[i];
			if(val[i]&&!depth[v])
			{
				depth[v]=depth[x]+1;
				que.push(v);
			}
		}
	}
	return depth[T];
}
long long dinic(long long x,long long in)
{
	if(x==T)
	{
		return in;
	}
	long long out=0;
	for(long long i=fi[x];i&&in;i=nx[i])
	{
		long long v=to[i];
		if(val[i]&&depth[x]+1==depth[v])
		{
			long long res=dinic(v,min(val[i],in));
			in-=res;
			out+=res;
			val[i]-=res;	
			val[i^1]+=res;
		}
	}
	if(out==0)
	{
		depth[x]=0;
	}
	return out;
}
signed main()
{
	cin>>c>>r>>n;
	for(long long i=1;i<=n;i++)
	{
		cin>>N[i].x>>N[i].y>>N[i].val;
		long long x=N[i].x;
		long long y=N[i].y;
		check[x*1000000+y]=++num;
		switch(x%4)
		{
			case 1:
				if(y%2==1)
				{
					N[i].col=B;
					heroes[++b_g]=i;	
				}
				else
				{
					N[i].col=Y;
					link(S,num,N[i].val);
					link(num,S,0);
				}
				break;
			case 2:
				if(y%2==1)
				{
					N[i].col=G;
					heroes[++b_g]=i;
					cost_[x*1000000+y]=N[i].val;
				}
				else
				{
					N[i].col=R;
					link(num,T,N[i].val);
					link(T,num,0);
				}
				break;
			case 3:
				if(y%2==1)
				{
					N[i].col=R;
					link(num,T,N[i].val);
					link(T,num,0);
				}
				else
				{
					N[i].col=G;
					heroes[++b_g]=i;
					cost_[x*1000000+y]=N[i].val;
				}
				break;
			case 0:
				if(y%2==1)
				{
					N[i].col=Y;
					link(S,num,N[i].val);
					link(num,S,0);
				}
				else
				{
					N[i].col=B;
					heroes[++b_g]=i;
				}
				break;
		}
	}
	for(long long i=1;i<=b_g;i++)
	{
		long long xx=N[heroes[i]].x;
		long long yy=N[heroes[i]].y;
		if(N[heroes[i]].col==B&&xx%4==0)
		{
			if(xx+dx[0]>=1&&xx+dx[0]<=c&&yy+dy[0]>=1&&yy+dy[0]<=r)
			{
				long long s=check[(xx+dx[0])*1000000+yy+dy[0]];
				if(s)
				{
					long long a=check[xx*1000000+yy];
					link(a,s,min(N[heroes[i]].val,cost_[(xx+dx[0])*1000000+yy+dy[0]]));
					link(s,a,0);
				}
			}
			for(long long i=1;i<4;i++)
			{
				if(xx+dx[i]>=1&&xx+dx[i]<=c&&yy+dy[i]>=1&&yy+dy[i]<=r&&check[(xx+dx[i])*1000000+yy+dy[i]])
				{
					long long a=check[(xx+dx[i])*1000000+yy+dy[i]],b=check[xx*1000000+yy];
					link(a,b,0x7ffffff);
					link(b,a,0);
				}
			}
		}
		else if(N[heroes[i]].col==B&&xx%4==1)
		{
			if(xx+dx[3]>=1&&xx+dx[3]<=c&&yy+dy[3]>=1&&yy+dy[3]<=r)
			{
				long long s=check[(xx+dx[3])*1000000+yy+dy[3]];
				if(s)
				{
					long long a=check[xx*1000000+yy];
					link(a,s,min(N[heroes[i]].val,cost_[(xx+dx[3])*1000000+yy+dy[3]]));
					link(s,a,0);
				}
			}
			for(long long i=0;i<3;i++)
			{
				if(xx+dx[i]>=1&&xx+dx[i]<=c&&yy+dy[i]>=1&&yy+dy[i]<=r&&check[(xx+dx[i])*1000000+yy+dy[i]])
				{
					long long a=check[(xx+dx[i])*1000000+yy+dy[i]],b=check[xx*1000000+yy];
					link(a,b,0x7ffffff);
					link(b,a,0);
				}
			}
		}
		else if(N[heroes[i]].col==G&&xx%4==2)
		{
			for(long long i=1;i<4;i++)
			{
				if(xx+dx[i]>=1&&xx+dx[i]<=c&&yy+dy[i]>=1&&yy+dy[i]<=r&&check[(xx+dx[i])*1000000+yy+dy[i]])
				{
					long long a=check[xx*1000000+yy],b=check[(xx+dx[i])*1000000+yy+dy[i]];
					link(a,b,0x7ffffff);
					link(b,a,0);
				}
			}
		}
		else
		{
			for(long long i=0;i<3;i++)
			{
				if(xx+dx[i]>=1&&xx+dx[i]<=c&&yy+dy[i]>=1&&yy+dy[i]<=r&&check[(xx+dx[i])*1000000+yy+dy[i]])
				{
					long long a=check[xx*1000000+yy],b=check[(xx+dx[i])*1000000+yy+dy[i]];
					link(a,b,0x7ffffff);
					link(b,a,0);
				}
			}
		}
	}
	long long ans=0;
	while(bfs())
	{
		ans+=dinic(S,0x7ffffff);
	}
	cout<<ans;
}
```


对了数据有点水你输出 $0$ 都能过掉 $5$ 个点

---

## 作者：cryozwq (赞：12)

~~这题我们教练出的。~~

Sto nodgd Orz

一般来说，看到网格题，想到网络流。看到要炸点，考虑染色，这道题的四个形状都是四个格子，考虑染成四色（图片来自[ shadowice1984
 的题解](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3756)）：

![](https://cdn.luogu.com.cn/upload/image_hosting/2vws6rgv.png)

那么我们再观察符合条件的讨厌图形，会发现**有且仅有**这四种由四个块组成图形必然存在一种顺序是黄-红-黑线-蓝-绿

那我们想一下，怎样才能破坏一个讨厌图形呢？两种方式：

- 破坏掉一个红/蓝方块
- 破坏掉所有**和红色或者蓝色相邻**的黄块或者绿块

到这里已经有一些最小割的影子了，我们按颜色可以建图建成 $7$ 层，分别是源点，黄色，红色，黑线，蓝色，绿色，汇点。

然后考虑如何去连边，显然“摧毁掉所有讨厌图形”也就是“使得源点和汇点不连通”:
- 我们从源点向黄色块连容量就是这个黄色块消除代价的边。
- 黄色块向红色块连容量为 $\inf$ 的边。
- 红色块向黑色线连容量就是这个红色块消除代价的边。
- 黑色线向蓝色点连容量就是这个蓝色块消除代价的边。

之后几层同理。

但是注意了，我在这里说黑色线只是帮助大家思考，事实上很容易发现我们从红块向蓝块连两者容量最小值是等价于红-黑-蓝的，于是黑色就去死了。

然后跑最小割，基于上面的分析，这就是答案。

代码实现有点难写，我也自认为写的比较简单，所以放一下代码：

```cpp
#include<bits/stdc++.h>
#define inf 15000000000000ll 
using namespace std;
#define int long long 
const int maxn=1e7;
struct Edge{
    int v,w,nxt;
}e[maxn];
map<int,map<int,int> >id;
map<int,map<int,int> >cst;
int h[maxn],tot=1,dis[maxn],N,cnt[maxn],u[maxn],v[maxn],b,f[300][300],sc=0,c,r;
int n=0,tt=0,m=0; 
void add(int u,int v,int w){  
	tot++;
    e[tot].v=v;
    e[tot].w=w;
    e[tot].nxt=h[u];
    h[u]=tot;
} 
void ae(int u,int v,int w){
//	cout<<u<<" "<<v<<" "<<w<<endl;
	add(u,v,w);
	add(v,u,0);
}
queue<int>q;
int wc(int x,int y){//1 R 2 B 3 Y 4 G
	swap(x,y);
	y=r-y;
	if(x==1){
		return y%2==1?3:1;
	}
	x--;
	if(((x-1)/2+1)%2){
		return x%2?(y%2?4:2):(y%2?2:4);
	}
	else{
		return x%2?(y%2?1:3):(y%2?3:1);
	}
}
void BFS(int s,int t){
	for(int i=1;i<=t;i++){
		dis[i]=0;
		cnt[i]=0;
	}
	dis[t]=1;
	cnt[1]++;
    q.push(t);
    while(!q.empty()) {
        int u=q.front();
        q.pop();
        for (int i=h[u];i;i=e[i].nxt) {
            int v=e[i].v;
			if(!dis[v]) {
                dis[v]=dis[u]+1;
                cnt[dis[v]]++;
                q.push(v);
            }
        }
    }
}

int dfs(int x,int s,int t,int flow){
    if(x==t||!flow) 
	return flow;
    int flw=0;
    for(int i=h[x];i;i=e[i].nxt) {
        int v=e[i].v;
		if(dis[x]==dis[v]+1){
            int tmp=dfs(v,s,t,min(flow,e[i].w));
            flw+=tmp;
			flow-=tmp;
			e[i].w-=tmp;
			e[i^1].w+=tmp;
            if(!flow) 
			return flw;
        }
    }
    cnt[dis[x]]--;
    if(!cnt[dis[x]]){
    	dis[s]=N; 
	}
	dis[x]++;
	cnt[dis[x]]++;
    return flw; 
}
int ISAP(int s,int t){
	BFS(s,t);
	int flw=dfs(s,s,t,inf);
	while(dis[s]<=N){
	 	flw+=dfs(s,s,t,inf);
	}
	return flw;
}
struct node{
	int x,y,cost;
}bk[maxn];
bool cmp(node a,node b){
	return a.x!=b.x?a.x<b.x:a.y<b.y;
}
const int dx[]={-1,1,0,0};
const int dy[]={0,0,-1,1}; 
signed main(){ 
	ios::sync_with_stdio(0);
	cin>>c>>r>>n;
	N=n+2;
	int s=n+1;
	for(int i=1;i<=n;i++){
		cin>>bk[i].x>>bk[i].y>>bk[i].cost;
		swap(bk[i].x,bk[i].y);
		bk[i].x=r-bk[i].x+1;
//		bk[i].y=c-bk[i].y+1;
	}
	sort(bk+1,bk+n+1,cmp);
	for(int i=1;i<=n;i++){
//		cout<<"id"<<bk[i].x<<" "<<bk[i].y<<" "<<i<<endl;
		id[bk[i].x][bk[i].y]=i;
		cst[bk[i].x][bk[i].y]=bk[i].cost;
	}
//	cout<<"_"<<endl;
	for(int i=1;i<=n;i++){
		int x=bk[i].x,y=bk[i].y;
		if(wc(x,y)==4)
		ae(s,id[x][y],cst[x][y]);
		if(wc(x,y)==3)
		ae(id[x][y],N,cst[x][y]);
		for(int t=0;t<4;t++){
			int tx=x+dx[t],ty=y+dy[t];
			if(id[tx][ty]){
				if(wc(x,y)==2&&wc(tx,ty)==1){
					ae(id[x][y],id[tx][ty],min(cst[x][y],cst[tx][ty]));
				}
				if(wc(x,y)==3){
					if(wc(tx,ty)==1){
//						cout<<tx<<" "<<ty<<" color1"<<endl;
						ae(id[tx][ty],id[x][y],cst[x][y]);
					}
				}
				if(wc(x,y)==4){
					if(wc(tx,ty)==2){
						ae(id[x][y],id[tx][ty],inf);
					}
				}
			}
		}
	}
	cout<<ISAP(s,N)<<endl;
	return 0;
}
```

---

## 作者：MiRaciss (赞：10)



这里提供一种更好想，但是点会多一些的做法

首先我们很容易就能想到染色

## 染色

![](https://cdn.luogu.com.cn/upload/image_hosting/gz9iit2r.png)



我们按照以上方法染色，然后发现从 $1$ 出发，沿着 $1$ -> $2$ -> $3$ -> $4$ 的路线，可以把我们所有需要删除情况都涵盖完。

所以我们现在就只需要建图了

## 建图

因为我们可以沿着 $1$ -> $2$ -> $3$ -> $4$ 的路线走完所有的情况，那么就可以建分层图了：


![](https://cdn.luogu.com.cn/upload/image_hosting/zidde6kq.png)

那么图与图之间怎么连边呢？我们就把一个点相邻的点，且染色颜色比它大 1 的点和它之间连一条边，边权为删去当前相邻点的代价。

但是我们直接连边会出现问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/zyvu4byb.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

就像这张图一样，当我们删去了 $1$ 和 $3$ 之间的边，就相当于删去的节点 $3$ ，但我们的 $2$ 和 $3$ 还是联通的，所以就会出现我们的点被删两次的情况。

所以我们要拆点，把点的点权转换为该点的两个点之间的边权，把两层之间的边权设为极大值就好了。

差不多图就长这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/enx4y747.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## 代码
```cpp

#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int INF=0x3f3f3f3f;

struct zz{
	int u,w,id;
};
vector<zz> v[1000005];
struct Dinic{
	int dist[1000005],be[1000005];
	int s,t;
	void Add(int x,int y,int z){
//		printf("QwQ:%d %d %d\n",x,y,z);
		int idx=v[x].size(),idy=v[y].size();
		v[x].push_back((zz){y,z,idy});
		v[y].push_back((zz){x,0,idx});
	}
	bool BFS(){
		bool f=0;memset(dist,-1,sizeof dist);
		queue<int> q;q.push(s);
		dist[s]=be[s]=0;
		while(!q.empty()){
			int x=q.front();q.pop();
			int siz=v[x].size();
			for(int i=0;i<siz;i++){
				int y=v[x][i].u,w=v[x][i].w;
				if(!w||dist[y]!=-1) continue;
				q.push(y),be[y]=0,dist[y]=dist[x]+1;
				if(y==t) f=1;
			}
		}
		return f;
	}
	int DFS(int x,int sum){
		if(x==t||!sum) return sum;
		int siz=v[x].size(),ans=0;
		for(int i=0;i<siz;i++){
			int y=v[x][i].u,w=v[x][i].w,id=v[x][i].id;be[x]=i;
			if(!w||dist[x]!=dist[y]-1) continue;
			int now=DFS(y,min(sum-ans,w));
			if(!now) dist[y]=0;
			v[x][i].w-=now,v[y][id].w+=now,ans+=now;
		}
		return ans;
	}
	int dinic(){
		int ans=0,now=0;
		while(BFS()) while(now=DFS(s,INF)) ans+=now;
		return ans;
	}
}T;

int n,m,k,tot=0;

int qq[4]={3,4,1,2};
int qqq[4]={4,3,2,1};
int fx[5]={0,1,-1,0,0};
int fy[5]={0,0,0,1,-1};

bool Check(int x,int y){
	if(x<=0||x>n) return 0;
	if(y<=0||y>m) return 0;
	return 1;
}

struct ss{
	int x,y,col,val;
}a[1000005];

#define mp make_pair
#define pii pair<int,int> 
map<pii ,int > f;

signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(NULL), std::cout.tie(NULL);
	cin>>n>>m>>k;T.s=0,T.t=k*2+1;
	for(int i=1;i<=k;i++){
		cin>>a[i].x>>a[i].y>>a[i].val;
		swap(a[i].x,a[i].y);
		if(a[i].x&1) a[i].col=qqq[a[i].y%4];
		else a[i].col=qq[a[i].y%4];	
		f[mp(a[i].x,a[i].y)]=i;
	}
	for(int i=1;i<=k;i++){
		int x=a[i].x,y=a[i].y;
		T.Add(i,i+k,a[i].val);
		for(int kk=1;kk<=4;kk++){
			int qx=x+fx[kk],qy=y+fy[kk];
			if(!Check(qx,qy)||f.find(mp(qx,qy))==f.end()) continue;
			int id=f[mp(qx,qy)];
			if(a[id].col!=a[i].col+1) continue;
			T.Add(i+k,id,INF);
		}
		if(a[i].col==1) T.Add(T.s,i,INF);
		if(a[i].col==4) T.Add(i+k,T.t,INF);
	}
	cout<<T.dinic();
	return 0;
}


```


---

## 作者：MSqwq (赞：6)

这是 [nodgd](https://www.luogu.com.cn/user/552) （~~我们教练~~）的题，必须好评  
前置芝士：网络流（染色法）  
这种题，瞎子才会看出来是网络流吧，这么毒瘤。当然这题也成为了最小割的经典例题。  
好像也快退役了，写篇题解，留个名吧。  
先介绍一下染色法哈，这个染色法不是二分图！！！就是单纯的解决网格类型题目的方法，比如黑白染色可以解决相邻块的问题比如 [ [国家集训队]圈地计划](https://www.luogu.com.cn/problem/P1935)  这是一道非常典型的最小割用黑白染色解决，其次就是本题了。  
本题注重如何染色和染色怎么处理，请听我细细道来~  
首先观察 小C 讨厌的形状，~~是不是很像俄罗斯方块，但少了一个山字形~~，好很容易发现他们都是又四个小方块决定的，所以我们染四种颜色，如下图  
![](https://cdn.luogu.com.cn/upload/image_hosting/p9urc718.png)   
可以发现强调出来的讨厌形状都有一个规律就是都由四种不同的颜色构成且都可以表示为 黄色 $\to$ 黑色 $\to$ 蓝色 $\to$ 红色 $\to$ 绿色  
这样染色就染完了。    
若一个方块被填上了方块，简称“被填”，那么讨厌的形状一定满足以下几条:   
1. 蓝线两边一定是被填的黑色和红色	  
2. 黑色周围要有被填的黄色 
3. 红色周围由被填的绿色  

把局部拆开看就下面这样  
![](https://cdn.luogu.com.cn/upload/image_hosting/zsbi0v58.png)  
然后我们就会发现要pohuai这种讨厌的图形有四种方法，分别是：  
1. 删除被填的黑色  
2. 删除被填的红色
3. 删除黑色周围的黄色  
4. 删除红色周围的绿色  

然后就可以正常构图跑网络流了，这题的构图就相对简单，我就直接放图了奥，就粗略的说了哈，相信能做到这题的人，建图还是没啥大问题的  
图是这样建的：  
![](https://cdn.luogu.com.cn/upload/image_hosting/78ve6ado.png)  
原因是消除一块黄色需要 $W_i$ 所以容量为 $W_i$ ，绿色同理，因为红色和黑色只需要消除一块就可以了，取最小就好了，其他的直接连无穷大就好啦，再跑最小割就是答案了  
代码如下：  
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<map>
#define ll long long
using namespace std;
const int N=300010,M=80000010,R=100010;
struct MS{
	int from,to,next,z;
}e[M];
int elast[N],cur[N],k=1;
void print(int x,int y,int z){cout<<x<<"->"<<y<<"="<<z<<endl;}
void add(int x,int y,int z)
{
	//print(x,y,z);
	e[++k].to=y,e[k].from=x,e[k].z=z,e[k].next=elast[x],elast[x]=k;
	e[++k].to=x,e[k].from=y,e[k].z=0,e[k].next=elast[y],elast[y]=k;
}
int c,r,n;
int ans;
int st,en;
int dis[N],cnt[N];
void bfs(int en)
{
	queue<int>q;
	q.push(en);
	for(int i=0;i<=N-10;i++)cur[i]=elast[i],dis[i]=-1,cnt[i]=0;
	dis[en]=0;
	cnt[0]=1;
	while(!q.empty())
	{
		int now=q.front();q.pop();
		for(int i=elast[now];i;i=e[i].next)
		{
			int to=e[i].to;
			if(dis[to]==-1)
			{
				dis[to]=dis[now]+1;
				cnt[dis[to]]++;
				q.push(to);
			}
		}
	}
}
int dfs(int x,int flow)
{
	if(x==en)return flow;
	int d=0;
	for(int i=cur[x];i;i=e[i].next)
	{
		cur[x]=i;
		int to=e[i].to;
		if(e[i].z>0&&dis[x]==dis[to]+1)
		{
			int tmp=dfs(to,min(e[i].z,flow-d));
			e[i].z-=tmp;
			e[i^1].z+=tmp;
			d+=tmp;
			if(d==flow||dis[st]>=en+1)return d;
		}
	}
	if(dis[st]>=en+1)return d;
	cnt[dis[x]]--;
	if(cnt[dis[x]]==0)dis[st]=en+1;
	dis[x]++;
	cur[x]=elast[x];
	cnt[dis[x]]++;
	return d;
}
struct MSQWQ{
	int x,y,z;
}a[R];
bool yellow(int x,int y)
{
	int AFO=((x+1)/2)&1;
	if(AFO)
	{
		if(y&1)return false;
	}
	else if(!(y&1))return false;
	AFO=(x/2)&1;
	if(!AFO)return true;
	return false;
}
bool green(int x,int y)
{
	int AFO=((x+1)/2)&1;
	if(AFO)
	{
		if(y&1)return false;
	}
	else if(!(y&1))return false;
	AFO=(x/2)&1;
	if(AFO)return true;
	return false;
}
bool bulu(int x,int y)
{
	int AFO=((x+1)/2)&1;
	if(AFO)
	{
		if(y&1)return true;
	}
	else if(!(y&1))return true;
	return false;
}
map<pair<int,int>,int>mp;
int dx[3][2]={{0,1},{0,-1},{-1,0}},dy[3][2]={{0,1},{0,-1},{1,0}};
void in(int x,int op)
{
	if(op==1)
	{
		for(int i=0;i<3;i++)
		{
			int xx=a[x].x+dx[i][0],yy=a[x].y+dx[i][1];
			int t=mp[make_pair(xx,yy)];
			if(t)add(t,x,1e9);
		}		
	}
	if(op==2)
	{
		for(int i=0;i<3;i++)
		{
			int xx=a[x].x+dy[i][0],yy=a[x].y+dy[i][1];
			int t=mp[make_pair(xx,yy)];
			if(t)add(t,x,1e9);
		}	
	}
}
void out(int x,int op)
{
	if(op==1)
	{
		for(int i=0;i<3;i++)
		{
			int xx=a[x].x+dx[i][0],yy=a[x].y+dx[i][1];
			int t=mp[make_pair(xx,yy)];
			if(t)add(x,t,1e9);
		}	
	}
	if(op==2)
	{
		for(int i=0;i<3;i++)
		{
			int xx=a[x].x+dy[i][0],yy=a[x].y+dy[i][1];
			int t=mp[make_pair(xx,yy)];
			if(t)add(x,t,1e9);
		}		
	}
}
int main()
{
	scanf("%d%d%d",&c,&r,&n);
	st=0,en=n+1;
	for(int i=1;i<=n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		a[i].x=x,a[i].y=y,a[i].z=z;
		
		if(yellow(x,y))add(st,i,z);
		else if(green(x,y))add(i,en,z);
		
		mp[make_pair(x,y)]=i;
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i].x&1&&bulu(a[i].x,a[i].y))
		{
			int to=mp[make_pair(a[i].x+1,a[i].y)];
			if(to)
			{
				if(a[i].y&1)
				{
					add(i,to,min(a[i].z,a[to].z));
					in(i,1),out(to,2);
				}
				else 
				{
					add(to,i,min(a[i].z,a[to].z));
					in(to,2),out(i,1);
				}
			}
		}
	}
	bfs(en);
	while(dis[st]<n+2)ans+=dfs(st,1e9);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Night_Aurora (赞：6)

### 全文所说的相连都是四联通，就是一个块与其上下左右四个块联通
首先我们看一下不合法的方式
![NUL](https://cdn.luogu.com.cn/upload/pic/5093.png)

说白了就是以蓝边为中的两个方块(下文都简称为两个方块)除彼此外，不能再分别与别的块相连

就是如果不合法的话我们至少要做到以下一条

#### #1.把与左边块相连的块都给消掉

#### #2.——右边块————————

#### #3.把这两个方块至少破坏一个

就相当于一个三选一决策问题

然后我们再观察一下蓝边的分布

![NULL](https://cdn.luogu.com.cn/upload/pic/5092.png)

我们又可以发现如下性质

#### I.  中间的两个方块不会影响其他的

这样#3就相当于破坏两个中权值最小的那一个

#### II. 两个方块所连的方块分别属于黑白染色的两色
---

这样我们就可以用最小割模型来解决这道题

三个决策我们给串联起来
其中#3放在最中间,就是两个点+中间一条流量为两个点最小值边
#1与#2我们根据黑白染色的情况放在左右边，先与S或者T连一条流量为自身花费的边，再与#3左或右端点连一条流量为无穷的边

(上面表述均忽略边方向)


对于不完整的两个方块我们就不用管


然后用Dinic来处理

因为长得很像二分图，感觉可以做到O(n^1.5)差不多的复杂度

至少提交时时限没有压力




---

## 作者：Graph (赞：5)

## 前言

这是我上一次一道黑题降难度之后第一道正经的黑题。

这个题还是挺妙的。

某老师言独立做出这道题至少 NOI 银，可惜我不是独立做出来的。

## 思路

![https://cdn.luogu.com.cn/upload/pic/5093.png](https://cdn.luogu.com.cn/upload/pic/5093.png)

找规律，我们可以观察那四个不能存在的图形，我们会发现那些图形都是由 $4$ 个连通方块组成，而且分割线恰好把两边分出了 $2$ 个方块。

我们注意到棋盘的分割线是有规律的，所以我们可以考虑如何染色，染肯定是染四种颜色，且这四种图案里恰好均有一种，而且在这四种图案里满足某种规律。（这怎么想得出来？）

于是我们可以想到染 $1,2,3,4$ 四种颜色，而且在一个图形里能通过 $1 \to 2 \to 3 \to 4$ 走出一条路径。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2nur3fb6.png)

从上图得知，分割线的两段是 $2$ 和 $3$。

接下来，就是对整张图进行染色，使得每一个图形都能通过 $1 \to 2 \to 3 \to 4$ 走出一条路径。我们可以如下染色：

![](https://cdn.luogu.com.cn/upload/image_hosting/9zlqk8kc.png)

如果这样染色，你会发现现在的不能存在的图形存在必定是图形内部有一条 $1 \to 2 \to 3 \to4$ 的路径。

回到题目所求，要求不存在这些图形的最小代价，不存在这些图形可以转化为**不存在一条 $\color{black}{1 \to 2 \to 3 \to 4}$ 的路径**，同时要求代价最小，这是最小割的模型。

于是，我们可以拆点把点权通过入点和出点之间的连边转化为边权，把源点 $s$ 和染色后为 $1$ 的方块连边，染色后的方块和 $t$ 连边，同时把染色后相邻的且加 $1$ 的互相连边，边权设极大值即可。

最后跑出来的最大流就是答案。

---

时间复杂度分析：

用 `map` 储存一个位置的箱子编号，四个方向判一下连边，时间复杂度 $O(n \log n)$。

网络流 Dinic 算法最坏是 $O(n^2m)$，但是注意到这里连边的层数很少，只有 $10$ 层，而且每个点至多向 $5$ 个其他点连边，这种情况下时间复杂度只有 $O(kn)$，其中 $k$ 是一个较小的常数，接近于 Dinic 的反悔次数，不会很大。

$1 \le n \le 10^5$，是可以接受的。

## 代码

别的题解代码太长了，我的简洁易懂。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long  

inline int read()
{
	int x(0);
	short f(1);
	char ch(getchar());
	while(!isdigit(ch))f=(ch=='-')?-1:1,ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}

const int N=5e5+5,lnf=2e18;
class P
{
public:
	int x,y;
	bool operator<(const P& tmp)const{if(x!=tmp.x)return x<tmp.x;return y<tmp.y;}
};
class Node
{
public:
	int x,y,w;
}e[N];
class eg
{
public:
	int to,w;
	int unsigned ip;
};
int R,C,n,s,t,hig[N],dep[N];
vector<eg>nbr[N];
map<P,int>mp;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};

bool bfs()
{
	queue<int>q;
	q.push(s);
	for(int i=s;i<=t;i++)
		hig[i]=0,dep[i]=-1;
	dep[s]=0;
	while(q.empty()==false)
	{
		int cur=q.front();
		q.pop();
		for(auto dat:nbr[cur])
		{
			int nxt=dat.to,w=dat.w;
			if(w>0&&dep[nxt]==-1)
			{
				dep[nxt]=dep[cur]+1;
				q.push(nxt);
			}
		}
	}
	return dep[t]>=0;
}

int dfs(int cur,int now)
{
	if(cur==t)
		return now;
	int num=0;
	for(int i=hig[cur];i<nbr[cur].size();i=hig[cur])
	{
		hig[cur]=i+1;
		int nxt=nbr[cur][i].to,w=nbr[cur][i].w,ip=nbr[cur][i].ip;
		if(w>0&&dep[cur]+1==dep[nxt])
		{
			int h=dfs(nxt,min(now,w));
			nbr[cur][i].w-=h;
			nbr[nxt][ip].w+=h;
			num+=h;
			now-=h;
			if(now==0)
				break;
		}
	}
	return num;
}

void add(int x,int y,int w=1)
{
	// cerr<<x<<" "<<y<<" "<<w<<"\n";
	nbr[x].push_back({y,w,nbr[y].size()});
	nbr[y].push_back({x,0,nbr[x].size()-1ull});
	return ;
} // 网络流 Dinic ----------------从这里开始看----------------

int getdis(int x,int y)
{
	if(y%2==1)
		return x%4+1;
	if(x%2==1)
		return x%4;
	return x%4+2;
}

signed main()
{
	R=read(),C=read(),n=read();
	for(int i=1;i<=n;i++)
	{
		e[i].x=read(),e[i].y=read(),e[i].w=read();
		mp[{e[i].x,e[i].y}]=i;
	}
	s=0,t=(n<<1)|1;
	for(int i=1;i<=n;i++)
	{
		int cur=getdis(e[i].x,e[i].y);
		add(i,i+n,e[i].w);
		if(cur==1)
			add(s,i,lnf);
		if(cur==4)
		{
			add(i+n,t,lnf);
			continue;
		}
		for(int p=0;p<4;p++)
		{
			int nx=e[i].x+dx[p];
			int ny=e[i].y+dy[p];
			if(nx<1||nx>R||ny<1||ny>C)
				continue;
			if(mp[{nx,ny}]==0)
				continue;
			int nxt=getdis(nx,ny);
			if(cur+1==nxt)
				add(i+n,mp[{nx,ny}],lnf);
		}
	}
	int ans(0);
	while(bfs()==true)
		ans+=dfs(s,1e18);
	cout<<ans;
	return 0;
}
```

---

## 作者：ker_xyxyxyx_xxs (赞：4)

[P3756 [CQOI2017]老C的方块](https://www.luogu.com.cn/problem/P3756)

题意：略

思路：建图+（标签写的）最小割

首先考虑染色，这里不是黑白染色，而是四色染色，染完色后发现所有讨厌图形都能够被表示为黄块 $ \rightarrow $ 黑块 $ \rightarrow $ 蓝线 $ \rightarrow $ 红块 $ \rightarrow $ 绿块（图如下）

![](https://cdn.luogu.com.cn/upload/image_hosting/342nsgx9.png)

小定义：如果一个方格被填上了，则称为被填方块

自己观察每一种讨厌图形，可以发现，每一种讨厌图形都有如下性质：

1、蓝线两侧一定是被填的黑块和红块

2、黑格周围要有被填的黄快

3、红格周围要有被填的绿块

以上三条需要同时满足

所以可以得出，破坏讨厌图形有如下几种情况：

1、删掉被填的红格

2、删掉被填的黑格

3、删掉被填黑格周围所有被填的黄格

4、删掉被填黑格周围所有被填的绿格

所以这四种情况容量为移除的花费，其余的边全部为 $ \infty $ 

~~根据经验~~ 构图方式如下：

1、源点 $ S $ 向所有被填黄格连边， $ S $ 连向黄格 $ i $ 的容量为 $ w_i $

2、所有被填绿格向汇点 $ T $ 连边，绿格 $ j $ 连向 $ T $ 的容量为 $ w_j $

3、被填黄格向相邻的被填黑格连边，容量为 $ \infty $

4、被填红格向相邻的被填绿格连边，容量为 $ \infty $ 

5、被填黑格 $ i $ 向相邻的被填红格 $ j $ 连边，容量为 $ min \begin{cases}w_i\\w_j\end{cases} $ 

最后跑最小割即可

建图完成后如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/3mbkxwcd.png)

最后说一下代码实现，确实很难写，~~本人写了一下午 wtcl~~

开 $ map $ 记录每一个被填方块的编号，位置以及花费，然后枚举每一个方块，进行连边，本人自己写了四个判断颜色的函数，我们很容易发现规律如下：

1、黄块和黑块：所处列，对 $ 4 $ 取模一定为 $ 0 $ 或 $ 1 $ ,对应一下在哪一行即可

2、红块和绿块：所处列，对 $ 4 $ 取模一定为 $ 2 $ 或 $ 3 $ ,对应一下在哪一行即可

接下来，为了减少码量写个广搜。记住！千万不能建空点，~~因为这个我写了一下午~~，不然会各种错误

最终 $ Code $ 如下

```cpp
# include <iostream>
# include <cstdio>
# include <queue>
# include <cstring>
# include <map>
# include <algorithm>
using namespace std;
const int N = 2e6 + 5;
const int M = 1e7 + 5;
const int inf = 0x7fffffff;
const int xyxyxyx_ = 1e5 + 5;
int S , T;
typedef struct {
	int x , y , z , next;
} Edge ;
Edge Kikyo[M];
int E = 1 , elast[N];
void add(int x , int y , int z) {
	E ++;
	Kikyo[E].x = x;
	Kikyo[E].y = y;
	Kikyo[E].z = z;
	Kikyo[E].next = elast[x];
	elast[x] = E;
}
int dis[N] , cnt[N];
void bfs(int start) {
	queue<int> q;
	q.push(start);
	dis[start] = 0;
	cnt[S] = 1;
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int i = elast[cur] ; i ; i = Kikyo[i].next) {
			int v = Kikyo[i].y;
			if (dis[v] != -1) continue;
			dis[v] = dis[cur] + 1;
			q.push(v);
			cnt[dis[v]] ++;
		}
	}
}
int cur[N];
int min(int a , int b) {
	return a < b ? a : b;
}
int dfs(int u , int flow) {
	if (u == T) return flow;
	int delta = 0;
	for (int i = cur[u] ; i ; i = Kikyo[i].next) {
		cur[u] = i;
		int v = Kikyo[i].y;
		if (Kikyo[i].z > 0 && dis[u] == dis[v] + 1) {
			int kikyo = dfs(v , min(flow - delta , Kikyo[i].z));
			Kikyo[i].z -= kikyo;
			Kikyo[i ^ 1].z += kikyo;
			delta += kikyo;
			if (delta == flow) return delta;
		}
	}
	if (dis[S] >= T + 1) return delta;
	cur[u] = elast[u];
	if (-- cnt[dis[u]] == 0) dis[S] = T + 1;
	cnt[++ dis[u]] ++;
	return delta;
}
int Isap() {
	int Kikyo = 0;
	memset(cnt , 0 , sizeof cnt);
	memset(dis , -1 , sizeof dis);
	bfs(T);
	for (int i = 0 ; i <= T ; i ++) {
		cur[i] = elast[i];
	}
	while (dis[S] < T + 1) Kikyo += dfs(S , inf);
	return Kikyo;
}
int C , R , n;
int xuexsshuan , Kikyo_ , kikyo_;
map<int , int> mp[xyxyxyx_] , mp_Kikyo[xyxyxyx_];
bool Kikyo_Yellow(int x , int  y) {
	if (x % 4 == 0) {
		if (y & 1) return true;
		else return false;
	}
	if (x % 4 == 1) {
		if (y & 1) return false;
		else return true;
	}
	return false;
}

bool Kikyo_Black(int x , int y) {
	if (x % 4 == 1) {
		if (y & 1) return true;
		else return false;
	}
	if (x % 4 == 0) {
		if (y & 1) return false;
		else return true;
	}
	return false;
}
bool Kikyo_Red(int x , int y) {
	if ((x + 2) % 4 == 0) {
		if (y & 1) return true;
		else return false;
	}
	if ((x + 1) % 4 == 0) {
		if (y & 1) return false;
		else return true;
	}
	return false;
}
bool Kikyo_Green(int x , int y) {
	if ((x + 1) % 4 == 0) {
		if (y & 1) return true;
		else return false;
	}
	if ((x + 2) % 4 == 0) {
		if (y & 1) return false;
		else return true;
	}
	return false;
}

int get_color_Kikyo(int x , int y) {
	if (Kikyo_Yellow(x , y) == true) return 1;
	if (Kikyo_Black(x , y) == true) return 2;
	if (Kikyo_Red(x , y) == true) return 3;
	if (Kikyo_Green(x , y) == true) return 4;
}

int dx[4] = {1 , 0 , -1 , 0};
int dy[4] = {0 , 1 , 0 , -1};
typedef struct {
	int x , y , cos;
} ssh;
ssh f[xyxyxyx_];
int main() {
	cin >> C >> R >> n;
	S = 0 , T = n + 1;
	for (int i = 1 ; i <= n ; i ++) {
		scanf("%d%d%d" , &xuexsshuan , &Kikyo_ , &kikyo_);
		mp[xuexsshuan][Kikyo_] = kikyo_;
		mp_Kikyo[xuexsshuan][Kikyo_] = i;
		f[i].x = xuexsshuan;
		f[i].y = Kikyo_;
		f[i].cos = kikyo_;
	}
	for (int i = 1 ; i <= n ; i ++) {
		int x = f[i].x , y = f[i].y , cos = f[i].cos , color = 0;
		color = get_color_Kikyo(x , y);
		if (color == 1) {
			add(S , mp_Kikyo[x][y] , cos);
			add(mp_Kikyo[x][y] , S , 0);
			for (int jk = 0 ; jk < 4 ; jk ++) {
				int tx = x + dx[jk];
				int ty = y + dy[jk];
				if (tx < 1 || ty < 1 || tx > C || ty > R) continue;
				if (Kikyo_Black(tx , ty) == true && mp_Kikyo[tx][ty] != 0) {
					add(mp_Kikyo[x][y] , mp_Kikyo[tx][ty] , inf);
					add(mp_Kikyo[tx][ty] , mp_Kikyo[x][y] , 0);
				}
			}
		}
		if (color == 2) {
			for (int jk = 0 ; jk < 4 ; jk ++) {
				int tx = x + dx[jk];
				int ty = y + dy[jk];
				if (tx < 1 || ty < 1 || tx > C || ty > R) continue;
				if (Kikyo_Red(tx , ty) == true && mp_Kikyo[tx][ty] != 0) {
					int cos1 = cos , cos2 = mp[tx][ty];
					add(mp_Kikyo[x][y] , mp_Kikyo[tx][ty] , min(cos1 , cos2));
					add(mp_Kikyo[tx][ty] , mp_Kikyo[x][y] , 0);
				}
			}
		}
		if (color == 3) {
			for (int jk = 0 ; jk < 4 ; jk ++) {
				int tx = x + dx[jk];
				int ty = y + dy[jk];
				if (tx < 1 || ty < 1 || tx > C || ty > R) continue;
				if (Kikyo_Green(tx , ty) == true && mp_Kikyo[tx][ty] != 0) {
					add(mp_Kikyo[x][y] , mp_Kikyo[tx][ty] , inf);
					add(mp_Kikyo[tx][ty] , mp_Kikyo[x][y] , 0);
				}
			}
		}
		if (color == 4) {
			add(mp_Kikyo[x][y] , T , cos);
			add(T , mp_Kikyo[x][y] , 0);
		}
	}
	printf("%d\n" , Isap());
	return 0;
}


```

---

## 作者：Leasier (赞：4)

~~作为 NK 神仙教练 nodgd 的小迷弟，我觉得 AC 了还是有必要写一篇题解的（~~

前置芝士：[最小割](https://oi-wiki.org/graph/flow/min-cut/)

一看到要在网格图里搞什么事情和最小花费就应该想到网络流和染色。

但是……这道题给出的老 C 不喜欢的方块由 $4$ 个方块组成，怎么染色？

那就染四种颜色嘛，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/sfvgdqxr.png)

如果你把题目中给出的四种方块按这种方式染色，你会发现**红色和黄色一定相邻，黑色和绿色一定相邻，红色和黑色也一定相邻**。

于是：如果我们切断如上三种相邻关系之一，就一定可以消除“讨厌的形状”。

然后就是最小割的事了。首先建立超级源点 $S$ 和超级汇点 $T$。

接下来，建五种类型的边：

1. $S \to$ 黄色，边权为移除这个黄色方块所需代价（如果割掉这条边，意味着移除这个黄色方块）；

2. 黄色 $\to$ 红色，边权为 $\inf$（设为移除这个黄色方块所需代价也可）；

3. 红色 $\to$ 黑色，边权为移除这个红色方块或黑色方块所需代价中的最小值（如果割掉这条边，意味着移除这个红色方块或黑色方块）；

4. 黑色 $\to$ 绿色，边权为 $\inf$（设为移除这个绿色方块所需代价也可）；

5. 绿色 $\to T$，边权为移除这个绿色方块所需代价（如果割掉这条边，意味着移除这个绿色方块）。

建好图后直接跑 ISAP / Dinic 即可。时间复杂度为 $O(c + n^3)$~~你看，网络流 $n^3$ 过十万了~~。

代码：
```cpp
#include <iostream>
#include <queue>
#include <map>

using namespace std;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

const int N = 1e5 + 7, M = 4, K = 8e5 + 7, RED = 1, BLACK = 2, GREEN = 3, YELLOW = 4;
int cnt = 1;
int head[N], dx[M + 7] = {0, -1, 0, 0, 1}, dy[M + 7] = {0, 0, -1, 1, 0}, dis[N], cur_edge[N], dis_cnt[N];
Edge edge[K];
queue<int> q;
map<int, int> mp1[N], mp2[N];

inline void init(int n){
	for (register int i = 0; i <= n; i++){
		dis[i] = 0x7fffffff;
		cur_edge[i] = head[i];
	}
}

inline int get_color(int i, int j){
	if (i % 2 == 1) return (j - 1) % 4 + 1;
	return 4 - (j - 1) % 4;
}

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

inline void bfs(int start){
	dis[start] = 0;
	q.push(start);
	while (!q.empty()){
		int cur = q.front(), next_dis = dis[cur] + 1;
		q.pop();
		dis_cnt[dis[cur]]++;
		for (register int i = head[cur]; i != 0; i = edge[i].nxt){
			int x = edge[i].end;
			if (dis[x] == 0x7fffffff){
				dis[x] = next_dis;
				q.push(x);
			}
		}
	}
}

int dfs(int u, int flow, int start, int end, int n){
	if (u == end) return flow;
	int ans = 0;
	for (register int i = cur_edge[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		cur_edge[u] = i;
		if (dis[u] == dis[x] + 1){
			int t = dfs(x, min(flow - ans, edge[i].dis), start, end, n);
			edge[i].dis -= t;
			edge[i ^ 1].dis += t;
			ans += t;
			if (ans == flow) return ans;
		}
	}
	cur_edge[u] = head[u];
	if (--dis_cnt[dis[u]] == 0) dis[start] = n;
	dis_cnt[++dis[u]]++;
	return ans;
}

inline int isap(int start, int end, int n){
	int ans = 0;
	bfs(end);
	while (dis[start] < n) ans += dfs(start, 0x7fffffff, start, end, n);
	return ans;
}

int main(){
	int c, r, n, id = 0, end;
	cin >> c >> r >> n;
	for (register int i = 1; i <= n; i++){
		int x, y, w;
		cin >> x >> y >> w;
		mp1[x][y] = w;
		mp2[x][y] = ++id;
	}
	end = id + 1;
	for (register int i = 1; i <= c; i++){
		for (register map<int, int>::iterator j = mp1[i].begin(); j != mp1[i].end(); j++){
			int y = j->first, w = j->second, cur_color = get_color(y, i), cur_id = mp2[i][y];
			if (cur_color == YELLOW){
				add_edge(0, cur_id, w);
				add_edge(cur_id, 0, 0);
			} else if (cur_color == GREEN){
				add_edge(cur_id, end, w);
				add_edge(end, cur_id, 0);
			} else {
				for (register int k = 1; k <= M; k++){
					int new_x = i + dx[k], new_y = y + dy[k];
					if (new_x >= 1 && new_x <= c && new_y >= 1 && new_y <= r && mp1[new_x].count(new_y)){
						int new_id = mp2[new_x][new_y], new_color = get_color(new_y, new_x);
						if (cur_color == RED){
							if (new_color == BLACK){
								add_edge(cur_id, new_id, min(w, mp1[new_x][new_y]));
								add_edge(new_id, cur_id, 0);
							} else if (new_color == YELLOW){
								add_edge(new_id, cur_id, 0x7fffffff);
								add_edge(cur_id, new_id, 0);
							}
						} else if (new_color == GREEN){
							add_edge(cur_id, new_id, 0x7fffffff);
							add_edge(new_id, cur_id, 0);
						}
					}
				}
			}
		}
	}
	init(end);
	cout << isap(0, end, end + 1);
	return 0;
}
```

---

## 作者：longdie (赞：4)

真是神奇的建图方式，表示真的想不到。  

首先这道题是网络流确实不难想，一看到网格图不会有人不想网络流吧，不过你可能会因为数据范围而放弃，但是我们要相信 dinic 的玄学复杂度！！！ 

u1s1，看到网格图的第一反映就是黑白染色吧，然后发现完全不可做，于是这道题就这么弃了。  

但是我们如果开拓思路的话，会发现这道题的不合法状态都是4个格子连起来的，而且特殊边的左边一定是有格子的。  

这让我们想到用4种颜色去给这个图进行染色。   

下面给出一张嫖来的图： (看不了的话可以点链接进去)  

![](https://images.cnblogs.com/cnblogs_com/zhoushuyu/1192665/o_a.png)  

然后你就会发现对任意一种不合法状态的4个格子一定是分布着不同的4种颜色的，并且一定可以找到一条路径使得有 $4 - 1 - 2 - 3$ 这种路径，然后如果你会最小割的话，你就会发现这已经很可做了吧。 

具体的来说，我们需要对于每个点进行拆点操作，然后我们直接按上面的路径进行连边就可以了。  

我是用了一堆 map 存的各种信息，反正还是比较麻烦的。  

可以看我代码上的注释： 

```cpp
// by longdie
#include <bits/stdc++.h>
using namespace std;
const int N = 4e5 + 5, inf = 0x3f3f3f3f;
inline int read(int s = 0, int f = 1, char ch = getchar()) {
    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
    while(isdigit(ch)) { s = s*10 + ch - '0', ch = getchar(); }
    return s * f;
}
unordered_map<int, unordered_map<int, int> > p[5], ru, chu, ji;
int L, R, n, head[N], cnt=1, tot, s, t, maxflow, d[N], X[N], Y[N], cur[N];
struct edge { int to, next, w; } e[N*15];
inline void add(int x, int y, int z) { e[++cnt] = (edge){y, head[x], z}, head[x] = cnt; }
bool bfs() {
    queue<int> q;
    memcpy(cur, head, tot * 4 + 4), memset(d, 0, tot * 4 + 4);
    d[s] = 1, q.push(s);
    while(q.size()) {
        int u = q.front(); q.pop();
        for(register int i = head[u], v; i; i = e[i].next) {
            v = e[i].to;
            if(d[v] || e[i].w == 0) continue;
            d[v] = d[u] + 1;
            if(v == t) return 1;
            q.push(v);
        }
    }
    return 0;
}
int dinic(int u, int flow) {
    if(u == t) return flow;
    int rest = flow;
    for(register int i = cur[u], v; i && rest; cur[u] = i, i = e[i].next) {
        v = e[i].to;
        if(d[v] != d[u] + 1 || e[i].w == 0) continue;
        int tmp = dinic(v, min(e[i].w, rest));
        if(!tmp) d[v] = 0;
        rest -= tmp, e[i].w -= tmp, e[i^1].w += tmp;        
    }
    return flow - rest;
}
signed main() {
    s = ++tot, t = ++tot;
    L = read(), R = read(), n = read();
    for(register int i = 1, x, y, w, now; i <= n; ++i) {
        y = read(), x = read(), w = read();
        ru[x][y] = ++tot, chu[x][y] = ++tot, X[i] = x, Y[i] = y;
        //找到被染成了什么颜色
        if(x & 1) {
            now = y % 4; if(!now) now = 4;
            ji[x][y] = now, p[now][x][y] = w;
        }
        else {
            now = y % 4;
            if(now == 1) now = 4;
            else if(now == 2) now = 3;
            else if(now == 3) now = 2;
            else now = 1;
            ji[x][y] = now, p[now][x][y] = w;
        }
    }
    for(register int i = 1; i <= n; ++i) {//连边的具体过程
        int x = X[i], y = Y[i], k = ji[x][y], u = ru[x][y], v = chu[x][y];
        add(u, v, p[k][x][y]), add(v, u, 0);//拆点之间的连边
        //分4种情况讨论
        if(k == 1) {
            int xx = x, yy = y + 1;
            if(p[2][xx][yy]) add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            xx = x, yy = y - 1;
            if(p[2][xx][yy]) add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
        }
        if(k == 2) {
            int xx = x, yy = y + 1;
            if(p[3][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
            xx = x + 1, yy = y;
            if(p[3][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
            xx = x - 1, yy = y;
            if(p[3][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
            xx = x, yy = y - 1;
            if(p[3][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
        }
        if(k == 3) {
            add(v, t, inf), add(t, v, 0);
        }
        if(k == 4) {
            add(s, u, inf), add(u, s, 0);
            int xx = x, yy = y + 1;
            if(p[1][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
            xx = x, yy = y - 1;
            if(p[1][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
            xx = x + 1, yy = y;
            if(p[1][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
            xx = x - 1, yy = y;
            if(p[1][xx][yy]) {
                add(v, ru[xx][yy], inf), add(ru[xx][yy], v, 0);
            }
        }
    }
    while(bfs()) maxflow += dinic(s, 0x3f3f3f3f);
    printf("%d\n", maxflow);
    return 0;
}
```

---

## 作者：xtx1092515503 (赞：3)

首先，看到“一个形状中如果拆掉任何一个方块都算合法”的限制，可以往最小割的方向去想。进一步说，如果我们将每个方块拆点，在拆开的点间连上一条相当于该方块权值的边；然后，对于一组四元组，假如我们可以按照某种顺序将四个东西用无穷大的边**串联**起来，则跑最小割即可。

现在考虑如何建图。观察到一个图形中有且仅有四个东西，于是往染四种颜色，最终的图被分成四层的方向去想。

因为每个图形中有且仅有一条特殊边，我们决定先从特殊边下手。

于是，我们初步的染色结果长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/vo1t9znd.png)

然后，再进一步染色，我们得到了这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4bhptjcu.png)

然后我们观察四种特殊图样，发现其都是一个 $0$ 加上一个 $1$ 加上 $0$ 旁边的某个数加上 $1$ 旁边的某个数；

而我们现在的图中，$0$ 旁的数不全相等，$1$ 旁的数同样；

于是我们考虑调整染色方式使得 $0$ 旁所有的数都相等。

![](https://cdn.luogu.com.cn/upload/image_hosting/bk4afvdf.png)

但是，这样染色后，我们发现不同的 $0$ 旁，有的旁边全是 $2$，有的旁边全是 $3$；

所以我们考虑再次修改，得到了最终的染色方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/c3g1jeas.png)

在此种方案中，$0$ 旁全是 $2$，$1$ 旁全是 $3$。

染色完成后，我们考虑如何建图。为了防止不同的四元组间混用了边，我们必须找到一种合适的分层顺序。

因为每个 $0$ 只会唯一地配对一个 $1$，而其它无论任何对之间都没有这种性质，所以我们考虑将 $(0,1)$ 间的边放在最中间。

于是，我们最终得到的思路是从 $S$ 连向 $2$ 层，从 $2$ 连向所有 $0$，从 $0$ 再连向 $1$，从 $1$ 连到 $3$，从 $3$ 连到 $T$。

这样，我们便建出了图。

可是，这张图有 $2\times 10^5$ 个点，网络流那奇奇怪怪的复杂度来跑这个确定大丈夫？

~~凭信仰跑就行了，反正能过~~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int lim=16384;
int n,m,k,tp[2][4]={{0,2,3,1},{2,0,1,3}},dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
namespace MaxFlow{
	const int N=210000,M=10000000;
	int head[N],cur[N],dep[N],cnt,S,T,res;
	struct node{int to,next,val;}edge[M];
	void ae(int u,int v,int w){
		edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
		edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++;
	}
	queue<int>q;
	inline bool bfs(){
		memset(dep,0,sizeof(dep)),q.push(S),dep[S]=1;
		while(!q.empty()){
			register int x=q.front();q.pop();
			for(register int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val&&!dep[edge[i].to])dep[edge[i].to]=dep[x]+1,q.push(edge[i].to);
		}
		return dep[T]>0;
	}
	bool reach;
	inline int dfs(int x,int flow){
		if(x==T){res+=flow,reach=true;return flow;}
		int used=0;
		for(register int &i=cur[x];i!=-1;i=edge[i].next){
			if(!edge[i].val||dep[edge[i].to]!=dep[x]+1)continue;
			register int ff=dfs(edge[i].to,min(edge[i].val,flow-used));
			if(ff){edge[i].val-=ff,edge[i^1].val+=ff,used+=ff;if(used==flow)break;}
		}
		return used;
	}
	inline void Dinic(){while(bfs()){reach=true;while(reach)reach=false,dfs(S,0x3f3f3f3f);}}
}
using namespace MaxFlow;
map<pair<int,int>,int>mp;
int main(){
	scanf("%d%d%d",&m,&n,&k),S=2*k+1,T=2*k+2,memset(head,-1,sizeof(head));
	for(int i=1,x,y,z;i<=k;i++){
		scanf("%d%d%d",&y,&x,&z);
		ae(i,i+k,z);
		mp[make_pair(x,y)]=i;
		if(tp[x%2][y%4]==2)ae(S,i,lim);
		if(tp[x%2][y%4]==3)ae(i+k,T,lim);
	}
	for(auto i:mp){
		int xi=i.first.first,yi=i.first.second,zi=i.second;
//		printf("%d %d %d:%d\n",xi,yi,zi,tp[xi%2][yi%4]);
		if(tp[xi%2][yi%4]>=2)continue;
		for(int I=0;I<4;I++){
			int xx=xi+dx[I],yy=yi+dy[I];
			if(mp.find(make_pair(xx,yy))==mp.end())continue;
			int zz=mp[make_pair(xx,yy)];
			if(tp[xx%2][yy%4]<=1){
				if(tp[xi%2][yi%4]==0)ae(zi+k,zz,lim);
				continue;
			}
			if(tp[xi%2][yi%4]==0)ae(zz+k,zi,lim);
			else ae(zi+k,zz,lim);
		}
	}
	Dinic();
	printf("%d\n",res);
	return 0;
}
```



---

## 作者：LEWISAK (赞：2)

[广告](https://www.cnblogs.com/lewisak)。

提供一种不到 $13$ 行的优雅建边方式。

首先这种题看着就很像**染色**，不难想到应该让所有的图形都能占所有的颜色恰好 $1$ 次以便于建图，也就是说需要有 $4$ 种颜色。

经过了 $1.5$ 个小时的简单枚举后，我找到了这样一个染色方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/mkbb4hzc.png)

读者可以把左边的图形带入右边，以此我们发现任意图形都可以按亮黄、浅绿、深绿、淡蓝的顺序走出来，那么这个时候建图就浮出水面了。

我们不难想到，对于所有存在的点，把 $s$ 向所有亮黄点连，然后亮黄向浅绿连，浅绿向深绿连，深绿向淡蓝连，最后把所有淡蓝向 $t$ 连，这就是一个显然的最小割模型了。

可这个时候我们发现题目的删点是带权的，根据知识积累，我们不难想到可以**把点权转化为边权**，具体地，把所有的点拆为入点和出点，对于上述的边流量全部设为 $inf$，边的起点改为该点的出点，边的终点改为该点的入点，最后把入点向出点连流量为删除该点费用的边即可。

具体实现上，可以将亮黄、浅绿、深绿、浅蓝分别编号为 $0,1,2,3$，然后对于一个编号为 $x $ 的点向周围的编号为 $x+1$ 的点连边（注意当 $x$ 为 $3$ 时恰好不会向任何点连边），$s$ 连接所有编号为 $0$ 的点，所有编号为 $3$ 的点向 $t$ 连边。

时间复杂度证明上，这里引用我代码中的一句话：

> 如果这个能过那就是说我们带 $8$ 倍常数的 $n^3$ 算法通过了 $n\le 10^5$，然后我**这辈子**都不会想要去证明网络流复杂度了。

我**这辈子**都不会想要去证明网络流复杂度了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace kong{bool st;}
namespace zhu{
int fx[4]={0,0,1,-1};
int fy[4]={1,-1,0,0};
int tot=1,head[1001000],lead[1001000],s,t,dep[1001000],gap[1001000],r,c,n,cnt;
map<int,int> mp1[100100],mp2[100100];
pair<int,int> in[100100];
queue<int> q;
struct{
	int nxt,to,w;
}e[2002000];
void add(int u,int v,int w){
	e[++tot]={head[u],v,w};
	head[u]=tot;
	e[++tot]={head[v],u,0};
	head[v]=tot;
}
void bfs(){
	q.push(t);
	dep[t]=1;
	gap[1]++;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to;
			if(!dep[v]){
				dep[v]=dep[x]+1;
				q.push(v);
				gap[dep[v]]++;
			}
		}
	}
}
int dfs(int x,int flow){
	if(x==t||flow==0) return flow;
	int rest=flow;
	for(int i=lead[x];i&&rest;i=e[i].nxt){
		lead[x]=i;
		int v=e[i].to,w=e[i].w;
		if(dep[x]==dep[v]+1&&w>0){
			int t=dfs(v,min(rest,w));
			rest-=t;
			e[i].w-=t;
			e[i^1].w+=t;
		}
	}
	if(rest){
		gap[dep[x]]--;
		if(!gap[dep[x]]){
			dep[s]=cnt+1;
		}
		dep[x]++;
		gap[dep[x]]++;
	}
	return flow-rest;
}
int ISAP(){
	int ans=0;
	bfs();
	while(dep[s]<=cnt){
		for(int i=1;i<=cnt;i++){
			lead[i]=head[i];
		}
		ans+=dfs(s,1e18);
	}
	return ans;
}
int col(int x,int y){
	if(y%2){
		return (3-(x%4))%4;
	}
	else{
		return (x+2)%4;
	}
}
bool check(int x,int y){
	return (x>0&&y>0&&x<=c&&y<=r);
}
string main(){
	cin>>c>>r>>n;
	s=++cnt,t=++cnt;
	for(int i=1;i<=n;i++){
		int x,y,w;
		cin>>x>>y>>w;
		in[i]={x,y};//离线输入
		mp1[x][y]=++cnt;//入点
		mp2[x][y]=++cnt;//出点
		add(mp1[x][y],mp2[x][y],w);
	}
	for(int i=1;i<=n;i++){//建边
		int x=in[i].first,y=in[i].second;
		if(col(x,y)==0) add(s,mp1[x][y],1e18);
		if(col(x,y)==3) add(mp2[x][y],t,1e18);
		for(int j=0;j<4;j++){
			int xx=x+fx[j],yy=y+fy[j];
			if(check(xx,yy)&&mp1[x][y]&&col(xx,yy)==col(x,y)+1){
				add(mp2[x][y],mp1[xx][yy],1e18);
			}
		}
	}
	cout<<ISAP()<<'\n';
	return "如果这个能过那就是说我们带 8 倍常数的 n^3 算法通过了 n<=1e5，然后我这辈子都不会想要去证明网络流复杂度了。";
}
}
namespace kong{bool ed;double MB(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<'\n'<<kong::MB();
	return 0;
} 
```

---

## 作者：Acoipp (赞：2)

做这道题的时候想了好久，最后终于做出来了，不得不说这是一道好题，考察图论建模，注重点：二分图的割。

首先我们可以观察到的是下面 $4$ 种情况：

![](https://cdn.luogu.com.cn/upload/pic/5093.png)

中间都有一条特殊边，我们把特殊边以及它左右两边格子的所有四连通格子拿出来，得到下面这种形状：

![](https://cdn.luogu.com.cn/upload/image_hosting/j467qp4y.png)

（里面的坐标是格子的自编号）

那么如果 $(2,1)$ 和 $(2,2)$ 格子里面都填了数字，对于这一块小方块才有其它的要求，我们把题目要求的四种图案放进去，就会发现：

- 沿着 $(i,1)$ 和 $(i,2)$ 格子的分界线将整个图案划分成两个对称的部分的话，这两个部分除了 $(2,1)$ 和 $(2,2)$ 的格子有方块外，最多有一个部分有方块。

举个例子：$(2,0)$ 和 $(2,3)$ 不能同时有方块，因为它们在对称轴两旁；而 $(2,0)$ 和 $(1,1)$ 可以同时有方块，因为它们在对称轴一边。

抽象一下这个问题，可以把对称轴两边看做二分图，二分图两边的格子互相之间都有边，要用最小的代价去掉一些格子，满足二分图的每条边的两端最多存在一个格子。

扩展到全局的情况也是如此，因为下图绿色的部分和红色的部分在每一个上面剖出来的图案中都不在同一个对称轴旁：

![](https://cdn.luogu.com.cn/upload/image_hosting/1g92u2jv.png)

所以如果蓝线两旁的小方块不能去掉的话，跑一遍模板的：[方格取数问题](https://www.luogu.com.cn/problem/P2774)就可以了。

现在考虑如果删掉蓝线两旁任何一个小方块的话，那对称轴不存在，与之相匹配的二分图也不存在，我们考虑继续解决这个问题。

考虑一下方格取数问题中的处理方式：

> 源点 $S$ 向二分图的左边连边，流量为删去它的代价，然后不能同时存在的两个点（一定分别在二分图两边）中间连流量为无穷大的边，然后二分图的右边向汇点 $T$ 连边，流量为删去它的代价，求最小割即可。

我们可以扩展一下这个过程，即中间的无穷大流量的边变成左边的点连向新开的一个点 $n_1$，流量为无穷大；新开的点 $n_1$ 连向新开的点 $n_2$，流量为 $\min(w_{2,1},w_{2,2})$；$n_2$ 向二分图的右端连边，流量为无穷大。跑最小割就可以了。

**注意：是对于每个上面的剖出来的图形新开两个点 $n_1$，$n_2$。**

思考一下这样做的实际意义，就是相当于我们可以断开 $n_1 \to n_2$ 的边，然后去掉当前剖出来的图形左边与右边的限制；如果不断开这条边的话，就必须删去一些小方块来满足最开始的左右两边不能同时存在小方块的条件。

特别的，而且因为这道题目的特殊性，每个小二分图两边的每对点都有边，所以这样做是对的。（如果不是每对点都有边的话这样做就是错误的）

于是这道题就做完了，代码用 ISAP 实现，时间复杂度还是一如既往的玄学，提示：数组要开够，边可能会很多。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1000005
#define K 100005
using namespace std;
struct node{ll x,y,z;}p[N];
vector<ll> op[N];
ll n,m,inf,s,t,i,j,k,ttt,px[3]={0,0,1},py[3]={1,-1,0};
ll la[N],ne[N],to[N],dis[N],cur[N],tot=1,sum[N],now1,now2,a[N],pos,p1[N],p2[N],t1,t2,vis[N],val[N],summ;
map<ll,ll> maps[K],id[K];
inline void merge(ll x,ll y,ll z){tot++,ne[tot] = la[x],la[x] = tot,to[tot] = y,val[tot] = z,tot++,ne[tot] = la[y],la[y] = tot,to[tot] = x,val[tot] = 0;}
ll dfs(ll x,ll step){
	if(x==t) return step;
	ll used = 0;
	for(ll i=cur[x];i;i=ne[i]){
		cur[x] = i;
		if(dis[to[i]]+1==dis[x]&&val[i]>0){
			ll temp = dfs(to[i],min(val[i],step-used));
			val[i] -= temp,val[i^1] += temp,used += temp;
			if(used==step||dis[s]>=inf) return used;
		}
	}
	if(--sum[dis[x]]==0) dis[s] = inf;
	sum[++dis[x]]++;
	return used;
}
inline void clear(){
	tot=1;
	summ=0;
	memset(la,0,sizeof(la));
	memset(ne,0,sizeof(ne));
	memset(to,0,sizeof(to));
	memset(val,0,sizeof(val));
	memset(sum,0,sizeof(sum));
	memset(dis,0,sizeof(dis));
}
void solve(ll x,ll y,ll calc){
	t1 = t2 = 0,now1 = ++ttt,now2 = ++ttt,merge(now1,now2,min(maps[x][y],maps[x+1][y]));
	if(calc==0){
		for(ll i=0;i<3;i++){
			ll tx1 = x-px[i],ty1 = y+py[i];
			if(tx1<1||ty1<1||!id[tx1][ty1]) continue;
			p1[++t1] = id[tx1][ty1];
		}
		for(ll i=0;i<3;i++){
			ll tx1 = x+1+px[i],ty1 = y+py[i];
			if(tx1<1||ty1<1||!id[tx1][ty1]) continue;
			p2[++t2] = id[tx1][ty1];
		}
	}
	else{
		for(ll i=0;i<3;i++){
			ll tx1 = x-px[i],ty1 = y+py[i];
			if(tx1<1||ty1<1||!id[tx1][ty1]) continue;
			p2[++t2] = id[tx1][ty1];
		}
		for(ll i=0;i<3;i++){
			ll tx1 = x+1+px[i],ty1 = y+py[i];
			if(tx1<1||ty1<1||!id[tx1][ty1]) continue;
			p1[++t1] = id[tx1][ty1];
		}
	}
	for(ll i=1;i<=t1;i++) if(!vis[p1[i]]) vis[p1[i]]=1;
	for(ll i=1;i<=t2;i++) if(!vis[p2[i]]) vis[p2[i]]=2;
	for(ll i=1;i<=t1;i++) for(ll j=1;j<=t2;j++) merge(p1[i],now1,1e18),merge(now2,p2[j],1e18);
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
	clear();
	s=0;
	for(i=1;i<=k;i++) cin>>p[i].x>>p[i].y>>p[i].z,maps[p[i].x][p[i].y] = p[i].z,id[p[i].x][p[i].y] = ++ttt;
	ttt*=2;
	for(i=1;i<=k;i++){
		if(p[i].x&1){
			if(((p[i].x-1)/2)&1){
				if(p[i].y%2==0) solve(p[i].x,p[i].y,1);
			}
			else{
				if(p[i].y%2==1) solve(p[i].x,p[i].y,0);
			}
		}
	}
	t = ++ttt,inf = t-s+1;
	for(i=1;i<=k;i++){
		if(vis[i]==1) merge(s,i,p[i].z);
		if(vis[i]==2) merge(i,t,p[i].z);
	}
	sum[0] = inf;
	while(dis[s]<inf) memcpy(cur,la,sizeof(la)),summ+=dfs(s,1e18);
	cout<<summ<<endl;
	return 0;
} 
/*
Input:
2 2 4
1 1 5 
1 2 6 
2 1 7 
2 2 8 

Output:
5
*/
```

---

## 作者：sangshang (赞：1)

## 题意

有一个 $R\times C$ 的网格，根据位置可确定特殊边，如题。有 $n$ 个方块，要求各个方块与特殊边之间不能组成老 C 讨厌的图形，如题。

炸掉每个点都有对应的花费，求将哪些点炸掉可以不再有讨厌图形，并使得花费最小，输出花费。

#  Solution

看到网格，炸点，最小花费~~和标签最小割~~，可以想到，是要求最小割。具体的，将炸点化为割边，应该要把网格染色，根据颜色分层建图，求出的将哪些边割掉，即炸掉那些点可使花费最小。

一般的染色题会将图分为黑白两种，将图转化为二分图求解，比如这道[王者之剑](https://www.luogu.com.cn/problem/P4474)，将图染色后求二分图权值和最大的独立集。~~其实就是最小割模型~~。

但这题不同，将图化为二分图没有任何作用。仔细观察会发现，讨厌图形都由四个方格组成，且特殊线都在中间。那有没有可能是染四种颜色，将讨厌图形如下拆开。

![](https://cdn.luogu.com.cn/upload/image_hosting/beqg4557.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以发现十分有规律，有点网络流的意思了。现在要沿着特殊边，将网格进行染色。具体的，看见特殊边，就想着根据临近已染色的格子组成的讨厌图形，将新格子染色。得到下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/uo3ucwfo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这图很神奇，任取一个可能的讨厌图形，都被按顺序染了色。更像最小割模型了。

于是我们将给出的方格，按颜色分类，对应连边，源点连 $1$，$1$ 连 $2$，$2$ 连特殊边，特殊边连 $3$，$3$ 连 $4$，$4$ 连汇点。此时只要填上合理的边权，图的最小割便是答案，因为找不到从源点到汇点的路，等于找不到格子组成合法的 $1\to 2\to 3\to 4$ 的路径，即，没有讨厌图形。

分析边权怎么存放。从源点到 $1$，$2$ 到特殊边，特殊边到 $3$，$4$ 到汇点的边都是唯一的，可以放心表示炸点花费；从 $1$ 到 $2$，$3$ 到 $4$ 的边不唯一，如果存放花费，会导致贡献不唯一。综上所述，$1$ 的花费存在源点到 $1$ 的边。$1$ 到 $2$ 的边权为 $+\infty$，无法被割。因为特殊边只可能与两点相连，所以 $2$ 到特殊边再到 $3$ 的边合为一条，边权为 $2,3$ 中花费较小的，同时表示两点花费。从 $3$ 到 $4$ 的边无法被割。从 $4$ 到汇点的边存放 $4$ 的花费。

因为我们要查询一格子周围的位置，所以使用 `std::map<std::pair<int,int>,int>` 根据坐标查询点的编号，或查有没有格子。还有，坐标输入先列后行，网格大小也一样。

# C++ Code
```cpp
#include <bits/stdc++.h>
using namespace std;

namespace IO {
	const int IN_LEN = 1 << 22;
	char buf[IN_LEN], *front = buf, *back = buf;
	inline char FastGetchar() {
		if (front >= back) {
			front = buf;
			back = buf + fread(buf, 1, IN_LEN, stdin);
			if (front == back) {
				return EOF;
			}
		}
		return (front++)[0];
	}
	inline int read() {
		int ret = 0;
		char ch = FastGetchar();
		bool flag = false;
		while (ch < '0' || ch > '9') {
			if (ch == '-') {
				flag = true;
			}
			ch = FastGetchar();
		}
		while (ch >= '0' && ch <= '9') {
			ret = ret * 10 + ch - '0';
			ch = FastGetchar();
		}
		return flag ? -ret : ret;
	}
}
using namespace IO;

class HLPP {
	public:
		typedef int TYPE;
		static const int maxn = 100005, maxm = 1200005, inf = 0x7f7f7f7f;
		class Node {
			public:
				int X, Y;
				TYPE val;
				Node(int X, int Y, TYPE val): X(X), Y(Y), val(val) {}
				Node() {}
				bool operator<(const Node a)const {
					return ((this->X == a.X) ? (this->Y < a.Y) : (this->X < a.X));
				}
		};
		Node Target[maxn];
		std::map<std::pair<int, int>, int>IDX;
		class edge {
			public:
				int to, rev;
				TYPE flow;
				edge(int to, TYPE flow, int rev): to(to), flow(flow), rev(rev) {}
				edge() {}
		};
		std::vector<edge>vec[maxn];
		TYPE Excess[maxn];
		int n, m, s, t, WolkCnt, maxh, maxgaph;
		int h[maxn], gap[maxn], gapnex[maxn], gappre[maxn], Excess_list[maxn], Excess_nex[maxn], Cur[maxn];
		HLPP(int n, int m, int s, int t): n(n), m(m), s(s), t(t), maxh(0), maxgaph(0), WolkCnt(0),
			Excess({0}), h({0}), gap({-1}), gapnex({-1}), gappre({-1}),
		Excess_list({-1}), Excess_nex({-1}) {}
		HLPP() {}
		inline void Add_Edge(int from, int to, TYPE flow) {
			vec[from].push_back(edge(to, flow, vec[to].size()));
			vec[to].push_back(edge(from, 0, vec[from].size() - 1));
		}
		inline void Push_flow(int u, edge &e, TYPE flow) {
			int v = (e.to);
			if (!Excess[v] && (v != t) && (h[v] != inf)) {
				Excess_nex[v] = Excess_list[h[v]];
				Excess_list[h[v]] = v;
			}
			Excess[u] -= flow, Excess[v] += flow, e.flow -= flow, vec[v][e.rev].flow += flow;
		}
		inline void Set_Height(int u, int newh) {
			if (~gappre[u]) {
				if (gappre[u] == u) {
					gap[h[u]] = gapnex[u];
					gappre[gapnex[u]] = gapnex[u];
				} else {
					gapnex[gappre[u]] = gapnex[u];
					if (~gapnex[u]) {
						gappre[gapnex[u]] = gappre[u];
					}
				}
			}
			if ((h[u] = newh) >= inf) {
				return;
			}
			maxgaph = std::max(maxgaph, newh);
			if (Excess[u]) {
				maxh = std::max(maxh, newh);
				Excess_nex[u] = Excess_list[newh];
				Excess_list[newh] = u;
			}
			if (~(gapnex[u] = gap[newh])) {
				gappre[gapnex[u]] = u;
			}
			gap[newh] = gappre[u] = u;
		}
		inline void Globals_Relabel() {
			maxgaph = maxh = WolkCnt = 0;
			std::memset(h, inf, sizeof(h));
			h[t] = 0;
			std::memset(gap, -1, sizeof(gap));
			std::memset(gapnex, -1, sizeof(gapnex));
			std::memset(gappre, -1, sizeof(gappre));
			std::memset(Excess_list, -1, sizeof(Excess_list));
			std::memset(Excess_nex, -1, sizeof(Excess_nex));
			std::memset(Cur, 0, sizeof(Cur));
			int q[maxn], front = 0, back = -1;
			std::memset(q, 0, sizeof(q));
			for (q[++back] = t; front <= back;) {
				int u = q[front++];
				for (edge &e : vec[u]) {
					int v = (e.to);
					if (vec[v][e.rev].flow && h[v] == inf && (v != s)) {
						q[++back] = v;
						Set_Height(v, h[u] + 1);
					}
				}
			}
		}
		inline void Scaling(int u) {
			int sz = vec[u].size(), nh = inf;
			for (int i = Cur[u]; i < sz; ++i) {
				edge &e = vec[u][i];
				if (e.flow) {
					int v = (e.to);
					if (h[v] + 1 == h[u]) {
						Push_flow(u, e, std::min(e.flow, Excess[u]));
						if (!Excess[u]) {
							Cur[u] = i;
							return;
						}
					} else {
						nh = std::min(nh, h[v] + 1);
					}
				}
			}
			for (int i = 0; i < Cur[u]; ++i) {
				edge &e = vec[u][i];
				if (e.flow) {
					nh = std::min(nh, h[(e.to)] + 1);
				}
			}
			++WolkCnt;
			Cur[u] = 0;
			int oldh = h[u];
			if (~gapnex[gap[oldh]]) {
				Set_Height(u, nh);
			} else {
				for (int i = oldh; i <= maxgaph; ++i) {
					for (int j = gap[i]; ~j; j = gapnex[j]) {
						h[j] = inf;
					}
					gap[i] = -1;
				}
				maxgaph = oldh - 1;
			}
		}
		inline TYPE GetMaxFlow() {
			Globals_Relabel();
			for (edge &e : vec[s]) {
				if (e.flow && h[(e.to)] != inf) {
					Push_flow(s, e, e.flow);
					maxh = std::max(maxh, h[(e.to)]);
				}
			}
			for (; maxh; --maxh) {
				while (~Excess_list[maxh]) {
					int front = Excess_list[maxh];
					Excess_list[maxh] = Excess_nex[front];
					Scaling(front);
					if (WolkCnt >= (n << 2)) {
						Globals_Relabel();
					}
				}
			}
			return Excess[t];
		}
		inline int Check(int X, int Y) {
			int tmp1 = X & 1, tmp2 = Y & 3;
			if (tmp2 == 1) {
				if (tmp1 == 0) {
					return 1;
				} else {
					return 2;
				}
			} else if (tmp2 == 2) {
				if (tmp1 == 0) {
					return 4;
				} else {
					return 3;
				}
			} else if (tmp2 == 3) {
				if (tmp1 == 0) {
					return 3;
				} else {
					return 4;
				}
			} else {
				if (tmp1 == 0) {
					return 2;
				} else {
					return 1;
				}
			}
		}
		inline void Solve() {
			int R, C, N;
			C = read(), R = read(), N = read();
			this[0] = HLPP(N + 1, inf, 0, N + 1);
			for (int i = 1; i <= N; ++i) {
				Target[i].Y = read(), Target[i].X = read(), Target[i].val = read();
			}
			for (int i = 1; i <= N; ++i) {
				Node &tmp = Target[i];
				IDX[make_pair(tmp.X, tmp.Y)] = i;
			}
			for (int i = 1; i <= N; ++i) {
				Node &now = Target[i];
				int tmp = Check(now.X, now.Y);
				if (tmp == 1) {
					Add_Edge(s, i, now.val);
					std::map<std::pair<int, int>, int>::iterator iter;
					if ((iter = IDX.find(make_pair(now.X + 1, now.Y))) != IDX.end()) {
						int id = (*iter).second;
						Add_Edge(i, id, inf);
					}
					if ((iter = IDX.find(make_pair(now.X - 1, now.Y))) != IDX.end()) {
						int id = (*iter).second;
						Add_Edge(i, id, inf);
					}
					if ((now.Y & 3) == 1) {
						if ((iter = IDX.find(make_pair(now.X, now.Y - 1))) != IDX.end()) {
							int id = (*iter).second;
							Add_Edge(i, id, inf);
						}
					} else if ((now.Y & 3) == 0) {
						if ((iter = IDX.find(make_pair(now.X, now.Y + 1))) != IDX.end()) {
							int id = (*iter).second;
							Add_Edge(i, id, inf);
						}
					}
				} else if (tmp == 2) {
					if ((now.Y & 3) == 1) {
						std::map<std::pair<int, int>, int>::iterator iter;
						if ((iter = IDX.find(make_pair(now.X, now.Y + 1))) != IDX.end()) {
							int id = (*iter).second;
							TYPE val = Target[id].val;
							Add_Edge(i, id, std::min(now.val, val));
						}
					} else if ((now.Y & 3) == 0) {
						std::map<std::pair<int, int>, int>::iterator iter;
						if ((iter = IDX.find(make_pair(now.X, now.Y - 1))) != IDX.end()) {
							int id = (*iter).second;
							TYPE val = Target[id].val;
							Add_Edge(i, id, std::min(now.val, val));
						}
					}
				} else if (tmp == 3) {
					std::map<std::pair<int, int>, int>::iterator iter;
					if ((iter = IDX.find(make_pair(now.X + 1, now.Y))) != IDX.end()) {
						int id = (*iter).second;
						Add_Edge(i, id, inf);
					}
					if ((iter = IDX.find(make_pair(now.X - 1, now.Y))) != IDX.end()) {
						int id = (*iter).second;
						Add_Edge(i, id, inf);
					}
					if ((now.Y & 3) == 2) {
						if ((iter = IDX.find(make_pair(now.X, now.Y + 1))) != IDX.end()) {
							int id = (*iter).second;
							Add_Edge(i, id, inf);
						}
					} else if ((now.Y & 3) == 3) {
						if ((iter = IDX.find(make_pair(now.X, now.Y - 1))) != IDX.end()) {
							int id = (*iter).second;
							Add_Edge(i, id, inf);
						}
					}
				} else {
					Add_Edge(i, t, now.val);
				}
			}
			printf("%d\n", GetMaxFlow());
		}
};
HLPP Main;

int main() {
	Main.Solve();
	return 0;
}
```



---

## 作者：封禁用户 (赞：1)

# 洛谷 P3756 老C的方块 —— 最小割

## 题目
### [题目传送门](https://www.luogu.com.cn/problem/P3756)

巧妙建图；

其实“俄罗斯方块”就是选择一条特殊边两边的方格，左右两边周围的六个中再各选两个；

于是可以把图“四分”，特殊边两边的格子算两种，而且奇数行和偶数行恰好相反，然后两边围着的格子也算两种；

然后不能有上面四种可选方格同时存在的情况，建出图来跑最小割即可。

# AC Code
## [AC记录](https://www.luogu.com.cn/record/168094227)
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<queue>
using namespace std;
int const xn=2e5+5,xm=2e6+5,inf=1e9;
int C,R,n,hd[xn],ct=1,to[xm],nxt[xm],c[xm],dis[xn],cur[xn],S,T;
map<int,int>mp[xn];
struct N{int x,y;}p[xn];
queue<int>q;
int rd()
{
  int ret=0,f=1; char ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-')f=0; ch=getchar();}
  while(ch>='0'&&ch<='9')ret=ret*10+ch-'0',ch=getchar();
  return f?ret:-ret;
}
void ade(int x,int y,int z){to[++ct]=y; nxt[ct]=hd[x]; hd[x]=ct; c[ct]=z;}
void add(int x,int y,int z){ade(x,y,z); ade(y,x,0);}
int tp(int x,int y)
{
  int d=y%4;
  if(x&1){if(d==1)return 1; if(d==2)return 2; if(d==3)return 4; if(!d)return 3;}
  else {if(d==1)return 3; if(d==2)return 4; if(d==3)return 2; if(!d)return 1;}
}
void addedge(int a,int b,int x,int y)
{
  if(a==3&&b==1)add(n+x,y,inf);
  else if(a==1&&b==2)add(n+x,y,inf);
  else if(a==2&&b==4)add(n+x,y,inf);
}
bool bfs()
{
  for(int i=S;i<=T;i++)dis[i]=0;
  dis[S]=1; q.push(S);
  while(q.size())
    {
      int x=q.front(); q.pop();
      for(int i=hd[x],u;i;i=nxt[i])
    if(!dis[u=to[i]]&&c[i])dis[u]=dis[x]+1,q.push(u);
    }
  return dis[T];
}
int dfs(int x,int fl)
{
  //printf("x=%d fl=%d\n",x,fl);
  if(x==T)return fl;
  int ret=0;
  for(int &i=cur[x],u;i;i=nxt[i])
    {
      if(dis[u=to[i]]!=dis[x]+1||!c[i])continue;
      int tmp=dfs(u,min(fl-ret,c[i]));
      if(!tmp)dis[u]=0;
      c[i]-=tmp; c[i^1]+=tmp;
      ret+=tmp; if(ret==fl)break;
    }
  return ret;
}
int main()
{
  C=rd(); R=rd(); n=rd(); S=0; T=2*n+1;
  for(int i=1,x,y,w;i<=n;i++)
    {
      y=p[i].y=rd(); x=p[i].x=rd(); w=rd();
      mp[x][y]=i; add(i,n+i,w);
      int t=tp(p[i].x,p[i].y);
      if(t==3)add(S,i,inf);
      if(t==4)add(n+i,T,inf);
    }
  for(int i=1;i<=n;i++)
    {
      int x=p[i].x,y=p[i].y,t=tp(x,y);
      if(x>1&&mp[x-1][y]){int tt=tp(x-1,y); addedge(t,tt,i,mp[x-1][y]);}
      if(y>1&&mp[x][y-1]){int tt=tp(x,y-1); addedge(t,tt,i,mp[x][y-1]);}
      if(x<R&&mp[x+1][y]){int tt=tp(x+1,y); addedge(t,tt,i,mp[x+1][y]);}
      if(y<C&&mp[x][y+1]){int tt=tp(x,y+1); addedge(t,tt,i,mp[x][y+1]);}
    }
  int ans=0;
  while(bfs())
    {
      memcpy(cur,hd,sizeof hd);
      ans+=dfs(S,inf);
    }
  printf("%d\n",ans);
  return 0;
}
`````

---

## 作者：int_R (赞：1)

[更好的阅读体验](https://www.cnblogs.com/int-R/p/18111432/P3756)

感觉挺有意思的。

先简化一下不合法的状况，实际上是如果特殊边两侧都有点，且那两个点的另外三个联通方向上也有至少一个点，就是坏的。相当于是四个限制只要有一个不满足就可以了。于是就可以转化成最小割。

按四种限制将点分成四类。特殊边两侧分别是 $1$ 类点和 $2$ 类点，$1$ 类点四联通的非 $2$ 类点是 $3$ 类点，$2$ 类点四联通的非 $1$ 类点是 $4$ 类点。如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/fwbawi27.png)

这样标号以后，我们就可以通过在不同编号的点中连边来做到从源点分别经过四条限制到达汇点。一个周期中的点就长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/0e1hpead.png)

至于删掉每个格子的代价，$3$ 类点可以在源点到它的边上将容量设为其权值，表示删掉 $3$ 类点，$3$ 类点到 $1$ 类点的边上设为 INF 表示不能删。$4$ 类点同理。

当然我们是可以删掉 $1$ 类点和 $2$ 类点的，只需要在 $1$ 类点到 $2$ 类点的边上将权值设为它俩权值中较小值即可。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<queue>
using namespace std;
using namespace __gnu_pbds;
const int MAXN=1e5+10,MAXM=4e5+10,INF=1e9+7;
int C,R,n,s,t,x[MAXN],y[MAXN],w[MAXN],dep[MAXN],ans;
int to[MAXM],nxt[MAXM],head[MAXN],cur[MAXN],val[MAXM],cnt=1;
gp_hash_table <int,int> p[MAXN];
inline void add(int x,int y,int v)
{
    to[++cnt]=y,nxt[cnt]=head[x];
    head[x]=cnt,val[cnt]=v;return ;
}
inline void edd(int x,int y,int v){add(x,y,v),add(y,x,0);}
inline bool bfs()
{
    for(int i=s;i<=t;++i) dep[i]=-1,cur[i]=head[i];
    dep[s]=0;queue <int> q;q.push(s);
    while(!q.empty())
    {
        int x=q.front();q.pop();
        for(int i=head[x];i;i=nxt[i])
        {
            int y=to[i];
            if(val[i]&&dep[y]==-1)  
                dep[y]=dep[x]+1,q.push(y);
        }
    }
    return dep[t]!=-1;
}
int dfs(int x,int flow)
{
    if(x==t) return flow;int rmn=flow;
    for(int i=cur[x];i&&rmn;i=nxt[i])
    {
        cur[x]=i;int y=to[i];
        if(!val[i]||dep[y]!=dep[x]+1) continue;
        int f=dfs(y,min(rmn,val[i]));
        rmn-=f,val[i]-=f,val[i^1]+=f;
    }
    return flow-rmn;
}
int main()
{
#ifdef ONLINE_JUDGE
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
#else
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    cin>>C>>R>>n;s=0,t=n+1;
    for(int i=1;i<=n;++i)
    {
        cin>>x[i]>>y[i]>>w[i];
        p[x[i]][y[i]]=i;
    }
    for(int i=1;i<=n;++i)
    {
        int k=(x[i]&3)^(y[i]&1),j;//这里是用位运算确定是哪一类点。
        if(!k)
        {
            if((y[i]&1)&&(j=p[x[i]+1][y[i]])) edd(i,j,min(w[i],w[j]));
            if(!(y[i]&1)&&(j=p[x[i]-1][y[i]])) edd(i,j,min(w[i],w[j]));
        }
        if(k==3)
        {
            if((y[i]&1)&&(j=p[x[i]+1][y[i]])) edd(i,j,INF);
            if(!(y[i]&1)&&(j=p[x[i]-1][y[i]])) edd(i,j,INF);
            if(j=p[x[i]][y[i]+1]) edd(i,j,INF);
            if(j=p[x[i]][y[i]-1]) edd(i,j,INF);
        }
        if(k==1)
        {
            edd(s,i,w[i]);
            if((y[i]&1)&&(j=p[x[i]+1][y[i]])) edd(i,j,INF);
            if(!(y[i]&1)&&(j=p[x[i]-1][y[i]])) edd(i,j,INF);
            if(j=p[x[i]][y[i]+1]) edd(i,j,INF);
            if(j=p[x[i]][y[i]-1]) edd(i,j,INF);
        }
        if(k==2) edd(i,t,w[i]);
    }
    while(bfs()) ans+=dfs(s,INF);
    cout<<ans<<'\n';return 0;
}
```

---

## 作者：Gmt丶FFF (赞：0)

其实不需要往染色方向想，用一点简单的技巧就行了。

可以很容易想到的是，我们只需要把四种关键图形上的四个点从头到尾串起来，最后跑最小割就行了。

具体来说，我们对四个点拟定一个顺序，那么我们将每个点拆点后，按顺序用上一个的出点连下一个的入点，再用源点连第一个点的入点，最后一个点的出点连汇点，流量皆为无限，每个点的入点到出点连流量为其价值的边即可。

但这样有点难以实现（主要是特判过多），所以我们可以考虑拟定一个固定的起点，这样我们可以少 $\frac{3}{4}$ 的特判。

我们在 $y$ 为奇数的那行拟定 $x \equiv 3(\bmod \space 4)$，偶数行 $x \equiv 2(\bmod \space 4)$ 为起点。

那奇数行为例。

为什么不设 $x \equiv 2(\bmod \space 4)$ 或 $x \equiv 1(\bmod \space 4)$ 为起点：因为如果以这个点为起点，无法完成长条状，闪电状和阶梯状的图形。

为什么不设 $x \equiv 0(\bmod \space 4)$ 为起点：等价的，你选这两个当中一个即可。

现在全写特判即可。

但是人总是懒的。

我们既然拟定了起点，看一下第二个点，第三个点与终点是否能拟定。

这东西看起来不好搞，实际上很好做，需要一点小 trick。

我们找正方形状，闪电形状与阶梯形状去搞实际上是不好弄的，因为涉及到两排直接的关系，所以我们以长条去拟定，这个就非常好搞了，我们找到起点，然后往左或右去延伸即可。

这样我们就可以把全图中的所有点给它标记上它是顺序上的第几个点。

然后我们找到一个靠图中间的起点，去验证它的所有形状是否被这些顺序给包含，并验证所有顺序是否为合法的图形。

发现是可以的，由于我们的起点是循环的，长条标记后是固定的，所以所有数是循环的，那么如果一个靠图中间的起点能满足，那么所有起点都能满足这个条件。

验证后发现是成立的，那么就好做了，对于一个点的出点，朝四联通顺序比它大 $1$ 的点的入点连边，源点连起点的入点，终点的出点连汇点即可。

因为矩阵过大而点数少，所以先给每个点编号，查询用 map 判断一个点是否存在即可。

时间复杂度：$O(n^2m)$（fake），实际上为：$O(\text{能过})$。

看似 $2\times 10^5$ 数量的点很大，实际上因为图的深度很小（最大为 $10$），所以实际上跑得飞快，复杂度并不高。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
#include<algorithm>
#define int long long
using namespace std;
const int N=1e5+5;
const int M=205;
int n,m,k,h[2*N],s,t,cnt,dis[2*N];
map<int,int>vis[N];
struct node2
{
	int x,y,z;
}p[N];
inline int calc(node2 x)
{
	int num=x.y&1;
	if(x.x%4==1)return 3^num;
	if(x.x%4==2)return num;
	if(x.x%4==3)return 1^num;
	return 2^num; 
}
bool cmp(node2 x,node2 y)
{
	return calc(x)>calc(y);
}
struct node
{
	int to,next,data;
}a[100*N];
void addedge(int x,int y,int k)
{
//	cout<<x<<" "<<y<<" "<<k<<endl;
	a[cnt]={y,h[x],k};
	h[x]=cnt++;
	a[cnt]={x,h[y],0};
	h[y]=cnt++;
}
bool bfs()
{
	for(int i=1;i<=t;i++)dis[i]=0;
	dis[t]=1;
	queue<int>q;
	q.push(t);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=h[x];i!=-1;i=a[i].next)
		{
			if(!a[i^1].data||dis[a[i].to])continue;
			dis[a[i].to]=dis[x]+1;
			q.push(a[i].to);
			if(a[i].to==s)return 1;
		}
	}
	return 0;
}
int dfs(int x,int minn)
{
	if(x==t)return minn;
	int sum=0;
	for(int i=h[x];i!=-1;i=a[i].next)
	{
		if(!a[i].data||dis[a[i].to]!=dis[x]-1)continue;
		int num=dfs(a[i].to,min(minn,a[i].data));
		if(num)
		{
			a[i^1].data+=num;
			a[i].data-=num;
			sum+=num;
			minn-=num;
		}
		else dis[a[i].to]=0;
		if(!minn)break;
	}
	return sum;
}
signed main()
{
	memset(h,-1,sizeof(h));
	scanf("%lld%lld%lld",&n,&m,&k);
	s=2*k+1,t=2*k+2;
	for(int i=1;i<=k;i++)scanf("%lld%lld%lld",&p[i].x,&p[i].y,&p[i].z);
	sort(p+1,p+1+k,cmp);
	for(int i=1;i<=k;i++)
	{
//		cout<<p[i].x<<" "<<p[i].y<<" "<<calc(p[i])<<" :\n";
		int num=calc(p[i]);
		if(num==0)addedge(s,i,1e18);
		if(num==3)addedge(i+k,t,1e18);
		int x=p[i].x,y=p[i].y;
		addedge(i,i+k,p[i].z);
		vis[x][y]=i;
		if(x>1&&calc({x-1,y,0})==num+1&&vis[x-1][y])addedge(i+k,vis[x-1][y],1e18);
		if(x<n&&calc({x+1,y,0})==num+1&&vis[x+1][y])addedge(i+k,vis[x+1][y],1e18);
		if(y>1&&calc({x,y-1,0})==num+1&&vis[x][y-1])addedge(i+k,vis[x][y-1],1e18);
		if(y<m&&calc({x,y+1,0})==num+1&&vis[x][y+1])addedge(i+k,vis[x][y+1],1e18);
	}
	int ans=0;
	while(bfs())
	{
		int num=dfs(s,1e18);
		while(num)
		{
			ans+=num;
			num=dfs(s,1e18);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：orz_z (赞：0)

题面自己看吧。。。

#### std

典型的网络流。

看到网格和炸点，可以想到是最小割。

按照套路，考虑染色，寻找规律。

发现，可用如下方法染色。

![](https://img-blog.csdnimg.cn/f14128842e5b45d883a449a4ac9d95a7.png)

之后四种情况都是如下：

![](https://img-blog.csdnimg.cn/6847f413ea664bf8a411cc102bf74aa1.png)

发现如图每种情况必然包含四种不一样的颜色，且顺序都是 黄 $\to$ 绿 $\to$ 黑 $\to$ 灰。

思考一下，发现破坏一个讨厌的图形有以下几种方式：

* 炸掉一个绿色块或黑色块。
* 炸掉所有和绿色块或者黑色块相邻的黄色块或者灰色块。 

那么现在模型就很显然了：

1. $s$ 向黄色块连容量为消除黄色块的代价的边。
2. 黄色块向绿色块连容量为 $+\infty$ 的边。
3. 绿色块向蓝线连容量为消除绿色块的代价的边。
4. 蓝线向黑色块连容量为消除黑色块的代价的边。
5. 黑色块向灰色块连容量为 $+\infty$ 的边。
6. 灰色块向 $t$ 连容量为消除灰色块的代价的边。

容易发现第 $3$ 种边和第 $4$ 种边可以合为：绿色块向黑色块连容量为消除绿色块的代价和消除黑色块的代价的最小值的边。

最后跑一边最小割即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

typedef int tp;

const int _ = 5e5 + 10;

int n, m, s, t, lv[_], cur[_];

int tot = 1, head[_], to[_ << 1], nxt[_ << 1];

tp w[_ << 1];

inline void add(int u, int v, tp dis)
{
	to[++tot] = v;
	nxt[tot] = head[u];
	w[tot] = dis;
	head[u] = tot;
}

inline void Add(int u, int v, tp dis)
{
	add(u, v, dis);
	add(v, u, 0);
}

inline bool bfs()
{
	memset(lv, -1, sizeof(lv));
	lv[s] = 0;
	memcpy(cur, head, sizeof(head));
	queue<int> q;
	q.push(s);
	while (!q.empty())
	{
		int p = q.front();
		q.pop();
		for (int eg = head[p]; eg; eg = nxt[eg])
		{
			int v = to[eg];
			tp vol = w[eg];
			if (vol > 0 && lv[v] == -1)
				lv[v] = lv[p] + 1, q.push(v);
		}
	}
	return lv[t] != -1;
}

tp dfs(int p = s, tp flow = 2e9)
{
	if (p == t)
		return flow;
	tp rmn = flow;
	for (int eg = cur[p]; eg && rmn; eg = nxt[eg])
	{
		cur[p] = eg;
		int v = to[eg];
		tp vol = w[eg];
		if (vol > 0 && lv[v] == lv[p] + 1)
		{
			tp c = dfs(v, min(vol, rmn));
			rmn -= c;
			w[eg] -= c;
			w[eg ^ 1] += c;
		}
	}
	return flow - rmn;
}

inline tp dinic()
{
	tp ans = 0;
	while (bfs())
		ans += dfs();
	return ans;
}

int r, c, x[_], y[_], W[_], col[_];

inline long long tr(int i, int j) { return (long long)(i - 1) * (c + 1) + j; }

map<long long, int> mp;

int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};

inline void build_A(int i, int j, int d)
{
	for (int k = 0; k < 4; k++)
	{
		int px = dx[k] + i, py = dy[k] + j;
		int num = mp[tr(px, py)];
		if (num != 0)
		{
			if (col[num] != 2)
				Add(num, d, 2e9);
			else
				Add(d, num, min(W[num], W[d]));
		}
	}
}
inline void build_B(int i, int j, int d)
{
	for (int k = 0; k < 4; k++)
	{
		int px = dx[k] + i, py = dy[k] + j;
		int num = mp[tr(px, py)];
		if (num != 0)
		{
			if (col[num] != 1)
				Add(d, num, 2e9);
		}
	}
}

signed main()
{
	c = read(), r = read(), n = read();
	for (int i = 1; i <= n; i++)
	{
		x[i] = read(), y[i] = read(), W[i] = read();
		mp[tr(x[i], y[i])] = i;
	}
	s = 0, t = _ - 1;
	for (int i = 1; i <= n; i++)
	{
		switch (x[i] % 4)
		{
		case 1:
		{
			col[i] = (y[i] % 2) ? 1 : 3;
			break;
		}
		case 2:
		{
			col[i] = (y[i] % 2) ? 2 : 4;
			break;
		}
		case 3:
		{
			col[i] = (y[i] % 2) ? 4 : 2;
			break;
		}
		case 0:
		{
			col[i] = (y[i] % 2) ? 3 : 1;
			break;
		}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		switch (col[i])
		{
		case 1:
		{
			build_A(x[i], y[i], i);
			break;
		}
		case 2:
		{
			build_B(x[i], y[i], i);
			break;
		}
		case 3:
		{
			Add(s, i, W[i]);
			break;
		}
		case 4:
		{
			Add(i, t, W[i]);
			break;
		}
		}
	}
	write(dinic());
	return 0;
}
```



---

## 作者：封禁用户 (赞：0)

# 洛谷 P3756 老C的方块 —— 最小割
## 题目
### [传送门](https://www.luogu.com.cn/problem/P3756)
巧妙建图；

其实“俄罗斯方块”就是选择一条特殊边两边的方格，左右两边周围的六个中再各选两个；

于是可以把图“四分”，特殊边两边的格子算两种，而且奇数行和偶数行恰好相反，然后两边围着的格子也算两种；

然后不能有上面四种可选方格同时存在的情况，建出图来跑最小割即可。

# AC 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int const xn=2e5+5,xm=2e6+5,inf=1e9;
int C,R,n,hd[xn],ct=1,to[xm],nxt[xm],c[xm],dis[xn],cur[xn],S,T;
map<int,int>mp[xn];
struct N{int x,y;}p[xn];
queue<int>q;
int rd()
{
  int ret=0,f=1; char ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-')f=0; ch=getchar();}
  while(ch>='0'&&ch<='9')ret=ret*10+ch-'0',ch=getchar();
  return f?ret:-ret;
}
void ade(int x,int y,int z){to[++ct]=y; nxt[ct]=hd[x]; hd[x]=ct; c[ct]=z;}
void add(int x,int y,int z){ade(x,y,z); ade(y,x,0);}
int tp(int x,int y)
{
  int d=y%4;
  if(x&1){if(d==1)return 1; if(d==2)return 2; if(d==3)return 4; if(!d)return 3;}
  else {if(d==1)return 3; if(d==2)return 4; if(d==3)return 2; if(!d)return 1;}
}
void addedge(int a,int b,int x,int y)
{
  if(a==3&&b==1)add(n+x,y,inf);
  else if(a==1&&b==2)add(n+x,y,inf);
  else if(a==2&&b==4)add(n+x,y,inf);
}
bool bfs()
{
  for(int i=S;i<=T;i++)dis[i]=0;
  dis[S]=1; q.push(S);
  while(q.size())
    {
      int x=q.front(); q.pop();
      for(int i=hd[x],u;i;i=nxt[i])
    if(!dis[u=to[i]]&&c[i])dis[u]=dis[x]+1,q.push(u);
    }
  return dis[T];
}
int dfs(int x,int fl)
{
  if(x==T) return fl;
  int ret=0;
  for(int &i=cur[x],u;i;i=nxt[i])
    {
      if(dis[u=to[i]]!=dis[x]+1||!c[i])continue;
      int tmp=dfs(u,min(fl-ret,c[i]));
      if(!tmp)dis[u]=0;
      c[i]-=tmp; c[i^1]+=tmp;
      ret+=tmp; if(ret==fl)break;
    }
  return ret;
}
int main()
{
  C=rd(); R=rd(); n=rd(); S=0; T=2*n+1;
  for(int i=1,x,y,w;i<=n;i++)
    {
      y=p[i].y=rd(); x=p[i].x=rd(); w=rd();
      mp[x][y]=i; add(i,n+i,w);
      int t=tp(p[i].x,p[i].y);
      if(t==3)add(S,i,inf);
      if(t==4)add(n+i,T,inf);
    }
  for(int i=1;i<=n;i++)
    {
      int x=p[i].x,y=p[i].y,t=tp(x,y);
      if(x>1&&mp[x-1][y]){int tt=tp(x-1,y); addedge(t,tt,i,mp[x-1][y]);}
      if(y>1&&mp[x][y-1]){int tt=tp(x,y-1); addedge(t,tt,i,mp[x][y-1]);}
      if(x<R&&mp[x+1][y]){int tt=tp(x+1,y); addedge(t,tt,i,mp[x+1][y]);}
      if(y<C&&mp[x][y+1]){int tt=tp(x,y+1); addedge(t,tt,i,mp[x][y+1]);}
    }
  int ans=0;
   while(bfs())
	{
      memcpy(cur,hd,sizeof hd);
      ans+=dfs(S,inf);
	}
  printf("%d\n",ans);
  return 0;
}
`````

---


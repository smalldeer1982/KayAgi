# [CTSC2017] 最长上升子序列

## 题目描述

猪小侠最近学习了最长上升子序列的相关知识。对于一个整数序列 $A =(a_1, a_2,\ldots , a_k)$，定义 $A$ 的子序列为：从 $A$ 中删除若干个元素后（允许不删，也允许将所有 $k$ 个元素都删除），剩下的元素按照原来的顺序所组成的序列。如果这个子序列的元素从左到右严格递增，则称它为 $A$ 的一个上升子序列。其中包含元素数量最多的上升子序列称为 $A$ 的最长上升子序列。例如，$(2, 4, 5, 6)$ 和 $(1, 4, 5, 6)$ 都是 $(2, 1, 1, 4, 7, 5, 6)$ 的最长上升子序列，长度都为 $4$。

现在猪小侠遇到了这样一个问题：给定一个序列 $B_m = (b_1, b_2, \ldots, b_m)$，设 $C$ 是 $B_m$ 的子序列，且 $C$ 的最长上升子序列的长度不超过 $k$，则 $C$ 的长度最大能是多少？

猪小侠觉得这个问题太简单了，缺乏挑战，他决定提出一个更难的问题。于是他给了你这样一个序列 $B = (b_1, b_2,\ldots , b_n)$，以及若干次询问。每次询问会给定两个整数 $m$ 和 $k$，你需要对于 $B$ 序列的前 $m$ 个元素构成的序列 $B_m = (b_1, b_2, \ldots, b_m)$ 和 $k$ 回答上述问题。


## 说明/提示

【样例解释】

询问 $1$：对于序列 $(9,6,3,1,5)$，可以选取子序列 $(9,6,3,1)$，它的最长上升子序列长度为 $1$。

询问 $2$：对于序列 $(9,6,3,1,5,12,8)$，可以选取子序列 $(9,6,3,1,12,8)$，它的最长上升子序列长度为 $2$。

询问 $3$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,5,4,2)$，它的最长上升子序列长度为 $1$。

询问 $4$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,3,1,12,8,4,2)$，它的最长上升子序列长度为 $2$。

询问 $5$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,5,4,2,2,2)$，它的最长上升子序列长度为 $1$。

询问 $6$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,3,1,5,12,8,4,2,2,2)$，它的最长上升子序列长度为 $3$。


 ![](https://cdn.luogu.com.cn/upload/pic/5487.png) 

对于 $100\%$ 的数据， $1\leq n\leq 5\times 10^4$，$1\leq b_i\leq 5\times 10^4$，$1\leq q \leq 2\times 10^5$，$1\leq k_i \leq m_i \leq n$。


## 样例 #1

### 输入

```
11 6
9 6 3 1 5 12 8 4 2 2 2
5 1
7 2
9 1
9 2
11 1
11 11```

### 输出

```
4 
6 
5 
8 
7
11```

# 题解

## 作者：foreverlasting (赞：17)

[可以看这里哦](https://foreverlasting1202.github.io/2019/09/06/CTSC2017%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/)

一道杨表的神题。
<!--more-->

前置知识：杨表。

杨表（又称为杨氏矩阵、杨图、$Young\ Diagram$），是一种特殊的图，用于整数划分类问题上。

杨表定义如下：

对于一个$n$的划分$\lambda=(\lambda_1,\lambda_2,...)\mapsto n$定义为杨表为一个左对齐的方块组，其中第$i$行有$\lambda_i$个方块。

类似于这样![](https://s2.ax1x.com/2019/09/06/nuHbOH.png)

（画的丑）

我们定义钩子长$h(u)$（$Young\ Diagram$）为一个方块它下面的块数和它右边的块数之和（包括本身）。

这里每个格子上的数字表示这个格子的钩子长![](https://s2.ax1x.com/2019/09/06/nuqVDH.png)

我们定义标准杨表（$SYT$）为将${1,2,...,n}$填入杨表且满足从上到下，从左到右数字都是满足比较方式$<$的杨表。

像这样![](https://s2.ax1x.com/2019/09/06/nuLDYt.png)

我们再定义$f^{\lambda}$为$\lambda$对应的标准杨表的个数。

于是可以定义钩子公式：对于$\lambda\mapsto n$，有$f^{\lambda}=\frac{n!}{\prod_{u\in \lambda}h(u)}$。

证明考虑组合意义即可。

下面再定义近似杨表（$NYT$）为将$n$个不同的数填入杨表且满足从上到下，从左到右数字都是满足比较方式$<$的杨表。

下面讲述如何构造近似杨表，我们考虑增量法。

每次将一个新的元素插入时，先在第一行查找是否有其后继，若有，替换其后继，让其后继在下一行进行新的查找，递归下去。若无，则插入到这一行的末尾。这样每次插入元素的复杂度可以证明为$O(rlogc)$，$r$为行数，$c$为列数。

同时根据$RSK$算法，我们可以构造一个关于杨表二元组集合与$n$个元素之间的双射，即$S_{(P,Q)}\leftrightarrow S_n$，其中$P$为近似杨表，$Q$为标准杨表。$RSK$算法不再过多赘述，感兴趣可以去$wiki$一下，这道题只利用到这个算法中的一个性质，即对于任意排列$\pi\in S_n$，其最长上升子序列的长度等于$\pi$对于的$P$的第一行长度。

对于杨表，还有一个性质，即若将其的比较方式取反（$<$变$\geq$,$>$变$\leq$)，所得杨表为原杨表的转置。（这里的转置定义为形状对称，并非元素对称，即元素可以滑动）

---

接下来回到这道题。

根据$Dilworth$定理，我们可以知道一个序列的最长上升子序列的长度等于将其分为若干个不上升子序列所需数量的最小值。

因此，题意转换成对于$B$的每一个前缀，取出不超过$k$个最长上升子序列，求最多能取走多少元素。

再根据杨表的性质，我们可以知道求的这个东西即为该序列的不上升杨表中前$k$行元素数量之和。

于是我们将询问离线，等于每次插入一些元素，然后动态地维护前$k$行的值即可。若暴力做，则是$O(nrlogc)$的，这样显然过不了。我们考虑总元素个数是$O(n)$的，于是对于每一个元素而言，它所在的行与列总有一个是$\leq \sqrt{n}$的。对于行，我们直接维护前$\sqrt{n}$行即可。对于列，我们将杨表的比较方式取反，维护转置后的前$\sqrt{n}$行即可。于是复杂度就在$O(n\sqrt{n}logn+qlogn)$或者$O(n\sqrt{n}logn+q\sqrt{n})$了。

code:
```cpp
//2019.9.6 by ljz
//email 573902690@qq.com
//if you find any bug in my code
//please tell me
#include<bits/stdc++.h>
//#include<ext/pb_ds/tree_policy.hpp>
//#include<ext/pb_ds/assoc_container.hpp>
using namespace std;
//using namespace __gnu_pbds;
//using namespace __gnu_cxx;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f
#define unl __int128
#define eps 5.6e-8
#define RG register
#define db double
#define pc(x) __builtin_popcount(x)
//#define pc(x) __builtin_popcountll(x)
typedef pair<int,int> Pair;
#define mp make_pair
#define fi first
#define se second
#define pi acos(-1.0)
#define pb push_back
#define ull unsigned LL
#define lowbit(x) (x&-x)
#define gc getchar
//template <class T>using Tree=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;
//inline char gc() {
//    static char buf[100000],*p1,*p2;
//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
//}
inline int read() {
    res s=0,ch=gc();
    while(ch<'0'||ch>'9')ch=gc();
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();
    return s;
}
//inline int read() {
//    res s=0,ch=gc(),w=1;
//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}
//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();
//    return s*w;
//}
//inline LL Read() {
//    RG LL s=0;
//    res ch=gc();
//    while(ch<'0'||ch>'9')ch=gc();
//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();
//    return s;
//}
//inline LL Read() {
//    RG LL s=0;
//    res ch=gc(),w=1;
//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}
//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();
//    return s*w;
//}
//inline void write(RG unl x){
//    if(x>10)write(x/10);
//    putchar(int(x%10)+'0');
//}
inline void swap(res &x,res &y) {
    x^=y^=x^=y;
}
//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
//clock_t start=clock();
//inline void ck(){
//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);
//}
const int kcz=998244353;
const int N=2e5+10;
const int M=300;
namespace MAIN{
    inline void add(res &x,const res &y){
        x+=y,x>=kcz?x-=kcz:1;
    }
    inline int mul(const res &x,const res &y){
        return int(1LL*x*y%kcz);
    }
    inline int Add(const res &x,const res &y){
        return x+y>=kcz?x+y-kcz:x+y;
    }
    inline int qpow(res x,res y){
        res ret=1;
        while(y){
            if(y&1)ret=mul(ret,x);
            x=mul(x,x),y>>=1;
        }
        return ret;
    }
    int n,q;
    int tr[N];
    inline void modify(const res &x,const res &y){
        for(res i=x;i<=n;i+=lowbit(i))tr[i]+=y;
    }
    inline int query(const res &x){
        res ret=0;
        for(res i=x;i;i-=lowbit(i))ret+=tr[i];
        return ret;
    }
    int a[N];
    struct Que{
        int m,k,id;
        Que() {}
        Que(res m,res k,res id):m(m),k(k),id(id) {}
        inline bool operator < (const RG Que &b) const {
            return m<b.m;
        }
    }Q[N];
    int ans[N],bl;
    vector<int> YT[M],TY[M];
    inline void add(const res &va){
        for(res i=1,x=va;i<bl;i++){
            if(YT[i].empty()||YT[i].back()>=x){YT[i].pb(x),modify(i,1);break;}
            swap(YT[i][upper_bound(YT[i].begin(),YT[i].end(),x,greater<int>())-YT[i].begin()],x);
        }
        for(res i=1,x=va;i<bl;i++){
            if(TY[i].empty()||TY[i].back()<x){
                TY[i].pb(x);
                if(TY[i].size()>=bl)modify(int(TY[i].size()),1);
                break;
            }
            swap(TY[i][lower_bound(TY[i].begin(),TY[i].end(),x)-TY[i].begin()],x);
        }
    }
    inline void MAIN(){
        n=read(),q=read(),bl=int(sqrt(n))+1;
        for(res i=1;i<=n;i++)a[i]=read();
        for(res i=1;i<=q;i++){
            res m=read(),k=read();
            Q[i]=Que(m,k,i);
        }
        sort(Q+1,Q+q+1);
        for(res i=1;i<=q;){
            res j=i;
            for(res k=Q[i-1].m+1;k<=Q[i].m;k++)add(a[k]);
            while(Q[j].m==Q[i].m&&j<=q)j++;
            j--;
            for(res k=i;k<=j;k++)ans[Q[k].id]=query(Q[k].k);
            i=j+1;
        }
        for(res i=1;i<=q;i++)printf("%d\n",ans[i]);
    }
}
int main(){
//    srand(19260817);
//    freopen("signin.in","r",stdin);
//    freopen("signin.out","w",stdout);
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：Sasiyar (赞：8)

先学一下杨氏矩阵再来做这一题会好一些（否则A不了）。
由$Dilworth$定理，好像是这个名字，可以在对询问排序后求解当前状态下的非升子序列的个数，用杨氏矩阵的每一行来维护，这样是查询前$k$行的元素个数和，所以树状数组统计。

但是空间会开不下，注意到求非升子序列的个数与求升子序列的长度相等，求非升子序列的长度和求升子序列的个数相等，就可以有两种目的的矩阵形状相反(可以想成矩阵是行的个数是子序列个数，最下列的长度是异于上一个子序列的要求的最长子序列)。

也就是两个矩阵的形状互为转置（我没学过线性代数，表述若有误还请原谅）。

那么假设$sz=\sqrt n$那么对于行数大于$sz$的就可以在转置矩阵当中求，可以证明，在横坐标$x\in [1, sz]$与纵坐标$y\in [1, sz]$当中的所有位置不可能既全部有点，又在这个范围外有点，因为假设全部有点(范围内和转置矩阵$x\in [sz + 1, n],y\in [sz + 1, n]$的区域)，数量超过$n$。

那么转置的矩阵在横坐标$x\in [sz+1,n]$的范围内，一定不存纵坐标$y\in [sz+1, n]$的点。

所以可以维护两个$sz\times n$的矩阵求解。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 50000 + 5, M = 233;
inline int lowbit (int u) {return u & (-u);}
int tree[N];
inline void add (int u, int v) {while (u <= N - 5) tree[u] += v, u += lowbit (u);}
inline int query (int u) {int res = 0; while (u) res += tree[u], u -= lowbit (u); return res;}
struct Q {int m, k, id, ans;}qq[N << 2];
int sz, n, b[N], q;
struct Matrix {
	int info[M][N], sign;
	inline void insert (int u, int v, int p) {
		if (u > sz) {return ;}
		int l = 1, r = min (v, info[u][0] + 1), mid;
		while (l < r) {
			mid = (l + r) / 2;
			if (sign ^ (info[u][mid] < p)) {r = mid;}
			else {l = mid + 1;}
		}
		swap (info[u][l], p);
		info[u][0] = max (info[u][0], l);
		if (p) {insert (u + 1, l, p);}
		else {
			if (sign) {if (l > sz)add (l, 1);}
			else {add (u, 1);}
		}
	}
}m1, m2;
int main () {
	m1.sign = 0, m2.sign = 1;
	scanf ("%d%d", &n, &q);sz = sqrt (n);
	for (int i = 1; i <= n; ++i) {scanf ("%d", &b[i]);}
	for (int i = 1; i <= q; ++i) {scanf ("%d%d", &qq[i].m, &qq[i].k);qq[i].id = i;}
	sort (qq + 1, qq + q + 1, [](Q a, Q b){return a.m < b.m;});
	int pre = 0;
	for (int i = 1; i <= q; ++i) {
		while (pre < qq[i].m) {
			++pre;
			m1.insert (1, INT_MAX, b[pre]);
			m2.insert (1, INT_MAX, b[pre]);
		}
		qq[i].ans = query (qq[i].k);
	}
	sort (qq + 1, qq + q + 1, [](Q a, Q b){return a.id < b.id;});
	for (int i = 1; i <= q; ++i) {printf ("%d\n", qq[i].ans);}
	return 0;
}
```

---

## 作者：okbj (赞：8)

```
#include<bits/stdc++.h>
#define N 50505
#define M 233
using namespace std;
struct data{int pos,K,id,ans;}d[N<<2];
bool cmp1(data a,data b){return a.pos<b.pos;}
bool cmp2(data a,data b){return a.id<b.id;}
int n,m,a[N];
namespace A{
int a[M+10][N],len[M+10];
void insert(int x,int y,int v){
 if(x>M)return ;
       y=min(y,len[x]);
       while(y&&a[x][y]<v)y--;y++;
       if(y>len[x]){
           a[x][++len[x]]=v;
            return;
         }
         else{
             insert(x+1,y,a[x][y]);
             a[x][y]=v;
         }
     }
 };
 namespace B{
    int a[M+10][N],len[M+10];
     void insert(int x,int y,int v){
	          if(x>M)return ;
        y=min(y,len[x]);
         while(y&&a[x][y]>=v)y--;y++;
         if(y>len[x]){
            a[x][++len[x]]=v;
             return;
         }
         else{
             insert(x+1,y,a[x][y]);
             a[x][y]=v;
         }
    }
};
 int query(int x){
     int ans=0;
     for(int i=1;i<=x&&i<=M;i++)
         ans+=A::len[i];
     if(x>M){
         for(int i=1;i<=M&&B::len[i]>M;i++)
             ans+=min(B::len[i],x)-M;
     }
     return ans;
 }
 int main(){
     scanf("%d%d",&n,&m);
     for(int i=1;i<=n;i++)scanf("%d",&a[i]);
     for(int i=1;i<=m;i++)
        scanf("%d%d",&d[i].pos,&d[i].K),d[i].id=i;
    sort(d+1,d+m+1,cmp1);
     for(int i=1,j=1;i<=n;i++){
        A::insert(1,N,a[i]);
         B::insert(1,N,a[i]);
         for(;j<=m&&d[j].pos==i;j++)
             d[j].ans=query(d[j].K);
     }
     sort(d+1,d+m+1,cmp2);
     for(int i=1;i<=m;i++)
         printf("%d\n",d[i].ans);
     return 0;
 }
```

---

## 作者：Others (赞：3)

**前置知识：**

杨表，$RSK$ 插入算法，转置杨表。

介绍一下后面两个：

**$RSK$ 插入算法**：对于一个杨表（值域很大，**不是标准杨表**） $\lambda$，将一个数 $x$ 插入到 $\lambda$ 中，我们首先在第一行二分出第一个大于 $x$ 的数，若没有，则把 $x$ 放在第一行末尾；如果有，那交换那个数与 $x$，将那个数在下一行执行相同的操作直至最后一行。

可以发现这个东西有点像我们用单调栈优化 $LIS$ 的求解过程，这就是它的用处，结合 $Dilworth$ 定理，可以利用这个算法。

**转置杨表**，在介绍 $RSK$ 插入算法时，我们的杨表中每一行都是单调递减，使用的运算符时 $\le$，如果我们把它“取反”为 $>$，那这个杨表就称作之前那个杨表的“转置杨表”$\lambda'$，$\lambda$ 的第一行就是 $\lambda'$ 的第一列，剩下的同理。

**Solution**

一个利用 $RSK$ 插入算法的板题，利用了一点技巧：总量是 $O(n)$，长宽分别维护 $\sqrt n$ 一定能覆盖完。由 $Dilworth$ 定理（不会的去补课），这题要维护的就是由长到短的最长升序子序列集合（每个数不能重复使用）中每个下标的元素数量的前缀和（可以结合样例理解）。

将询问离线到序列中，扫描一遍，记录杨表前 $k$ 列的格子数。但是注意每次插入的复杂度是 $O(r\log c)$，如果是降序就爆掉了。我们考虑一个东西：只维护前 $\sqrt n$ 列的杨表，后面的在其转置杨表中维护行，注意这个行只有在格子数 $>\sqrt n$ 时更新。

实现很简单，在维护时使用树状数组或分块都可以，实践中树状数组最快（$n,q$ 差不多）。

给个代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct CGY {
	int x,y;
};
const int N=200005;
vector<CGY> qu[N];
int idx[N],bls,s,n,m,L[N],R[N],a[N],x,y,ans[N];
int sum1[N],sum2[N];
vector<int> vec1[10005],vec2[10005];
void add(int x) {
	for(int i=idx[x];i<=bls;i++) ++sum1[i];
	for(int i=x;i<=R[idx[x]];i++) ++sum2[i];
}
int getsum(int x) {
	return sum1[idx[x]-1]+sum2[x];
}
void insert(int x) {
	int tmp=x;
	for(int i=1;i<s;i++) {
		if(vec2[i].empty()||vec2[i].back()>=x) {
			vec2[i].push_back(x);
			add(i);
			break;
		}
		vector<int>::iterator it=upper_bound(vec2[i].begin(),vec2[i].end(),x,greater<int>());
		swap(*it,x);
	}
	x=tmp;
	for(int i=1;i<s;i++) {
		if(vec1[i].empty()||vec1[i].back()<x) {
			vec1[i].push_back(x);
			if(vec1[i].size()>=s)add(vec1[i].size());
			break;
		}
		vector<int>::iterator it=lower_bound(vec1[i].begin(),vec1[i].end(),x);
		swap(*it,x);
	}
}
int main() {
	cin >> n >> m;
	s=sqrt(n)+1,bls=(n+s-1)/s;
	for(int i=1;i<=bls;i++) {
		L[i]=R[i-1]+1,R[i]=min(n,s*i);
		for(int j=L[i];j<=R[i];j++) idx[j]=i;
	}
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) scanf("%d%d",&x,&y),qu[x].push_back((CGY){y,i});
	for(int i=1;i<=n;i++) {
		insert(a[i]);
		for(auto &lxl:qu[i]) ans[lxl.y]=getsum(lxl.x);
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：Tenderfoot (赞：3)

**感谢@[okbj](https://www.luogu.com.cn/user/123679)提供的代码思路，但是由于其只发了代码题解，那么我来补充一下分析思路罢。**

一道杨氏矩阵（杨矩阵、杨表）的模板题。对于其讲解，可以学习[这里](https://www.luogu.com.cn/blog/qlwpc/yang-shi-ju-zhen-jian-jie)，非常简洁易懂。

下面来分析这道题。

根据狄尔沃斯定理，最小链覆盖等于最长反链。因此问题就可以转化为：求 $k$ 个最小不上升序列能覆盖的最大数的个数。

原矩阵只需维护前 $\sqrt n$ 行，进行查询操作时同样，只查询前 $\sqrt n$ 行，剩下的可以置换矩阵中的某一列。同样地，置换矩阵时只需维护前 $\sqrt n$ 行。可以二分进行维护，也可以直接插入。其中该矩阵的转置指的是改变比较方式，即从原先的从大到小维护变成从小到大维护。

代码：
```cpp
#include<bits/stdc++.h>

#define MOD 1000000007
#define int long long
#define MAXN 60100
#define MAXM 233
#define Enter puts("")
#define Space putchar(' ')
#define Test_Begin Enter , puts("Test--------------")
#define Test_End Enter , puts("--------------------")

using namespace std;

constexpr int INF = 2147483647;

static inline int Read()
{
	int Ans = 0;
	char Ch = getchar(), Las = ' ';
	while (!isdigit(Ch))
	{
		if (Ch == '-')
			Las = '-';
		Ch = getchar();
	}
	while (isdigit(Ch))
	{
		Ans = Ans * 10 + Ch - '0';
		Ch = getchar();
	}
	if (Las == '-')
		Ans = -Ans;
	return Ans;
}

static inline void Write(int x)
{
	if (x < 0)
	{
		x = -x;
		putchar('-');
	}
	if (x >= 10)
		Write(x / 10);
	putchar(x % 10 + '0');
}

struct Node
{
    int Pos , k , id , Ans;
};

static inline bool Cmp1(Node a , Node b)
{
    return a.Pos < b.Pos;
}

static inline bool Cmp2(Node a , Node b)
{
    return a.id < b.id;
}

int n , a[MAXN];

struct A
{
    int _a[MAXM + 10][MAXN] , Len[MAXM + 10];

    inline void Insert(int x , int y , int Val)
    {
        if(x > MAXM)
            return;
        y = min(y , Len[x]);
        while(y and (_a[x][y] < Val))
            y--;
        y++;
        if(y > Len[x])
        {
            _a[x][++Len[x]] = Val;
            return;
        }
        else
        {
            Insert(x + 1 , y , _a[x][y]);
            _a[x][y] = Val;
        }
    }
};

struct B
{
    int _a[MAXM + 10][MAXN] , Len[MAXM + 10];

    inline void Insert(int x , int y , int Val)
    {
        if(x > MAXM)
            return;
        y = min(y , Len[x]);
        while(y and (_a[x][y] >= Val))
            y--;
        y++;
        if(y > Len[x])
        {
            _a[x][++Len[x]] = Val;
            return;
        }
        else
        {
            Insert(x + 1 , y , _a[x][y]);
            _a[x][y] = Val;
        }
    }
};

A _A;
B _B;
Node N[MAXN << 2];

static inline int Query(int x)
{
    int Ans(0);
    for(register int i = 1; (i <= x) and (i <= MAXM); i++)
        Ans += _A.Len[i];
    if(x > MAXM)
        for(register int i = 1; (i <= MAXM) and (_B.Len[i] > MAXM); i++)
            Ans += min(_B.Len[i] , x) - MAXM;
    return Ans;
}

signed main()
{
    int n = Read() , Q = Read();
    for(register int i = 1; i <= n; i++)
        a[i] = Read();
    for(register int i = 1; i <= Q; i++)
    {
        N[i].Pos = Read() , N[i].k = Read();
        N[i].id = i;
    }
    sort(N + 1 , N + Q + 1, Cmp1);
    for(register int i = 1 , j = 1; i <= n; i++)
    {
        _A.Insert(1 , MAXN , a[i]);
        _B.Insert(1 , MAXN , a[i]);
        for(; j <= Q and N[j].Pos == i; j++)
            N[j].Ans = Query(N[j].k);
    }
    sort(N + 1 , N + Q + 1 , Cmp2);
    for(register int i = 1; i <= Q; i++)
        Write(N[i].Ans) , Enter;
    return 0;
}
```


---

## 作者：Purslane (赞：1)

# Solution

杨表！

这题就是让你求出杨表的前 $k$ 列的长度，使用 RSK 算法插入。

显然插入的复杂度可以被卡成 $O(n \log n)$ 单次。但是将偏序关系取反之后，容易得到杨表的转置。

显然不会有格子在 $(\sqrt n,\sqrt n)$ 之外。所以你对于两种杨表维护前 $\sqrt n$ 列即可。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXB=250+5,MAXN=5e4+10,MAXQ=2e5+10;
int n,q,a[MAXN],ans[MAXQ];
pair<int,int> st[MAXN];
vector<int> vc1[MAXB],vc2[MAXB];
vector<pair<int,int>> qr[MAXN];
void insert1(int x,int v) {
	if(x>250) return ;
	int id=lower_bound(vc1[x].begin(),vc1[x].end(),v)-vc1[x].begin();
	if(id<vc1[x].size()) insert1(x+1,vc1[x][id]),vc1[x][id]=v;
	else vc1[x].push_back(v);
	return ;
}
void insert2(int x,int v) {
	if(x>250) return ;
	int id=lower_bound(vc2[x].begin(),vc2[x].end(),v)-vc2[x].begin();
	if(id<vc2[x].size()) insert2(x+1,vc2[x][id]),vc2[x][id]=v;
	else vc2[x].push_back(v);
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	ffor(i,1,n) cin>>a[i],st[i]={a[i],-i};
	sort(st+1,st+n+1);
	ffor(i,1,n) a[-st[i].second]=i;
	ffor(i,1,q) {
		int m,k;
		cin>>m>>k,qr[m].push_back({k,i});	
	}
	ffor(i,1,n) {
		insert1(1,a[i]),insert2(1,-a[i]);
		for(auto pr:qr[i]) {
			int k=pr.first,id=pr.second;
			ffor(i,1,250) ans[id]+=min(k,(int)vc1[i].size());
			ffor(i,1,min(k,250)) if(vc2[i].size()>250) ans[id]+=vc2[i].size()-250;
		}
	}
	ffor(i,1,q) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：ZillionX (赞：1)

# Description

给定长度为 $n$ 的序列 $B$，有 $q$ 次询问，每次询问 $[1,m]$ 中最长的满足 LIS 长度 $\le k$ 的子序列长度。

$n,B_i \le 5 \times 10^4,q \le 2 \times 10^5$，时限 1s。

# Solution

约定下文中 $k$ − LIS 表示序列 $X$ 最长的满足 LIS 长度不超过 $k$ 的子序列。

------------


经典的 $k$ - LIS 问题，考虑使用杨氏矩阵。

介绍一个杨氏矩阵的重要性质 1：

> $\mathcal P_{X^R}$ 由 $\mathcal P_X$ 转置（即对于每一个元素交换行列）得到，其中 $X^R$ 为序列 $X$ 的翻转。

以及另一个类似的性质 2：

> 元素比较方式取反，则 $\mathcal P'_{X}$ **形状上**由 $\mathcal P_X$ 转置得到。

证明可以去看 19 年国集袁老师的论文。

众所周知，序列 $X$ 对应杨氏矩阵 $\mathcal P_X$ 的第一行长度就是 $X$ 的 LIS 长度。

那么由上面的性质很容易得到 $\mathcal P_X$ 的第一列长度就是 $X$ 的 LDS（即 $1$ - LIS） 长度。

可以猜想 $X$ 的 $k$ - LIS 长度就是 $\mathcal P_X$ 的前 $k$ 列长度之和，事实上确实如此。证明可以考虑 Dilworth 反链定理，序列 LIS 长度相当于将其分成若干 LDS 的最小数量，于是就显然了。

所以可以考虑将询问离线，动态维护整个 $\mathcal P_B$，但是单次插入的复杂度是 $\mathcal O(n \log n)$ 的，显然不可行。

正当你怀疑这题是不是神仙的新科技论文题时，你忽然想起了上文中的性质 2，我们能不能维护一个转置矩阵呢？

注意到杨氏矩阵逐行列数不增，以及逐列行数不增的性质，那么假设一个数最终插入到 $(x,y)$ 的位置，$x,y$ 中至少有一者 $\le \sqrt n$。

所以一个更为聪明的算法呼之欲出，我们改为维护运算符取反后 $\mathcal P'_B$ 的前 $\sqrt n$ 行，以及 $\mathcal P_B$ 的前 $\sqrt n$ 行。

前者由 $\mathcal P_B$ 形状上转置得到，因此对应长度就是 $\mathcal P_B$ 前 $\sqrt n$ 列的长度；而后者在求大于 $\sqrt n$ 的列长度时必然完整。

单次插入是单点修改，可以用树状数组实现。

这样我们就得到了一个 $\mathcal O(n \sqrt n \log n + q \log n)$ 的做法。

# Code
```cpp
const int N=5e4+5,M=255,Q=2e5+5;

int n,m,a[N],Ans[Q];

struct Qst {
	int x,id;
	bool operator<(const Qst &r) const {
		return x<r.x;
	}
};
vector<Qst> q[N];

#define ad emplace_back
#define sz size()

struct BIT {
	int n,T[N];
	#define lbt(x) (x&(-x))
	void Add(int x,int y) {
		for (;x<=n;x+=lbt(x)) T[x]+=y;
	}
	int Qry(int x) {
		int Sum=0;
		for (;x;x-=lbt(x)) Sum+=T[x];
		return Sum; 
	}
}T;

struct Yng {
	int n,sg,s[M],t[M][N];
	
	void Ins(int x,int y,int v) {
		if (x>n) return;
		int l=1,r=min(y,s[x]+1);
		while (l<r) {
			int mid=(l+r)>>1;
			if (sg^(t[x][mid]<v)) r=mid;
			else l=mid+1;
		}
		swap(t[x][l],v),s[x]=max(s[x],l);
		if (v) Ins(x+1,l,v);
		else {
			if (sg) {if (l>n) T.Add(l,1);}
			else T.Add(x,1);
		}
	}
}M1,M2;

int main() {
	scanf("%d%d",&n,&m);
	M2.sg=1,M1.n=M2.n=sqrt(n),T.n=n; 
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=m;i++) {
		int x,k;
		scanf("%d%d",&x,&k);
		q[x].ad(Qst{k,i});
	}
	
	for (int i=1;i<=n;i++) {
		M1.Ins(1,n+1,a[i]),M2.Ins(1,n+1,a[i]);
		if (q[i].sz)
			for (auto v:q[i]) Ans[v.id]=T.Qry(v.x);
	}
	
	for (int i=1;i<=m;i++) printf("%d\n",Ans[i]);
	
	return 0;
}
```


---

## 作者：WorldMachine (赞：1)

RSK 插入算法的板子题。

以将 $x$ 插入杨表 $Y$ 为例，RSK 插入算法流程如下：

1. 初始时在第一行；
2. 在当前行二分出第一个大于 $x$ 的数，如果没有则将 $x$ 放在该行末尾，否则交换该数和 $x$，进入下一行，重复这一步直到到达最后一行。

将大于改成小于即可得到原杨表的转置。

单次插入复杂度最坏为 $\mathcal O(r\log c)$，容易被卡，因此我们维护原杨表的前 $\mathcal O(\sqrt n)$ 行，同时在转置杨表中维护超出的行（只用在格子数超过 $\mathcal O(\sqrt n)$ 时更新）。

根据 Dilworth 定理，答案为杨表前 $k$ 列的方格个数之和。将询问离线下来，扫描线维护即可。插入时需要更新前缀和，可以用树状数组做到 $\mathcal O(n\sqrt n\log n+q\log n)$ 或用分块做到 $\mathcal O(n\sqrt n+q\sqrt n)$。由于 $q$ 较大，采取前者。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 50005, M = 200005, B = 230;
int n, m, blk, a[N], c[N], ans[M];
struct query { int id, m, k; } q[M];
bool cmp(query a, query b) { return a.m < b.m; }
void upd(int x, int d) { while (x <= n) c[x] += d, x += x & -x; }
int qry(int x) { int y = 0; while (x) y += c[x], x -= x & -x; return y; }
struct Yang {
	int f, a[B][N];
	void insert(int x, int y, int v) {
		if (x > blk) return;
		int l = 1, r = min(y, a[x][0] + 1), mid;
		while (l < r) {
			mid = l + r >> 1;
			if (f ^ (a[x][mid] < v)) r = mid;
			else l = mid + 1;
		}
		swap(a[x][l], v), a[x][0] = max(a[x][0], l);
		if (v) insert(x + 1, l, v);
		else if (f && l > blk) upd(l, 1);
		else if (!f) upd(x, 1);
	}
} mx, my;
int main() {
	my.f = 1;
	scanf("%d%d", &n, &m), blk = sqrt(n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= m; i++) scanf("%d%d", &q[i].m, &q[i].k), q[i].id = i;
	sort(q + 1, q + 1 + m, cmp);
	for (int i = 1, j = 1; i <= m; i++) {
		while (j <= q[i].m) mx.insert(1, n + 1, a[j]), my.insert(1, n + 1, a[j]), j++;
		ans[q[i].id] = qry(q[i].k);
	}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}
```

---


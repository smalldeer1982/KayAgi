# [BJWC2018] 餐巾计划问题

## 题目背景

**本题和网络流24题中的餐巾计划不为重题**

## 题目描述

一个餐厅在相继的 $n$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天 $(i=1, 2, ..., n)$ 需要 $r_i$ 块餐巾。餐厅可以在任意时刻购买新的餐巾，每块餐巾的费用为 $p$ 。使用过的旧餐巾，则需要经过清洗才能重新使用。把一块旧餐巾送到清洗店A，需要等待 $m_1$ 天后才能拿到新餐巾，其费用为 $c_1$ ；把一块旧餐巾送到清洗店B，需要等待 $m_2$ 天后才能拿到新餐巾，其费用为 $c_2$ 。例如，将一块第 $k$ 天使用过的餐巾送到清洗店A清洗，则可以在第 $k+m_1$ 天使用。

请为餐厅合理地安排好 $n$ 天中餐巾使用计划，使总的花费最小。

## 说明/提示

**【样例说明】**

第 1 天：买8块餐巾，花费24。送2块餐巾去清洗店A，6块餐巾去清洗店B。

第 2 天：取回2块清洗店A的餐巾，花费4。送1块餐巾去清洗店B。

第 3 天：取回6块清洗店B的餐巾，花费6。

第 4 天：取回1块清洗店B的餐巾，花费1。这样就用了最少的钱。


**【数据规模和约定】**

对于30%的数据，$1 \leq n \leq 5$ ，$1 \leq c_1, c_2, p \leq 5$ ， $1 \leq r_i \leq 5$ 。

对于50%的数据，$1 \leq n \leq 100$ ，$1 \leq r_i \leq 50$ 。

对于70%的数据，$1 \leq n \leq 5000$ 。

对于100%的数据，$1 \leq n \leq 200000$ ， $1 \leq m_1, m_2 \leq n$ ， $1 \leq c_1, c_2, p \leq 100$ ， $1 \leq r_i \leq 100$ 。

## 样例 #1

### 输入

```
4 1 2 2 1 3
8
2
1
6```

### 输出

```
35```

# 题解

## 作者：George1123 (赞：24)

# 题解-[BJWC2018]餐巾计划问题
好好的网络流题，变成了队列加模拟。

**参考资料**
> 暂无

**[博客中原文](https://blog.csdn.net/KonnyWen/article/details/104659156)**

---
## $\color{#000}\texttt{Introduction}$
蒟蒻在刷省选水题时发现一道 [\[HNOI2001\]软件开发](https://www.luogu.com.cn/record/31354488)，与当年的网络流题 [餐巾计划问题](https://www.luogu.com.cn/problem/P1251) 一模一样。然后蒟蒻又看了讨论，这两题又和 [\[USACO08NOV\]Toys G](https://www.luogu.com.cn/problem/P2917) 和 [\[BJWC2018\]餐巾计划问题](https://www.luogu.com.cn/problem/P4480) 除了数据范围以外一模一样。然后这题就是其中数据范围最强的了，做法竟然是队列和模拟。

---
## $\color{#000}\texttt{Description}$
> [\[BJWC2018\]餐巾计划问题](https://www.luogu.com.cn/problem/P4480)

> 有 $n$ 天，每天需要 $r_i$ 块干净餐巾给人用，用完后会脏。每天买新干净餐巾 $p$ 元每块，洗脏餐巾需要 $c_1$ 元每块耗时 $m_1$  天或 $c_2$ 元每块耗时 $m_2$ 天。求最少花费。

> 数据范围：$1\le n\le 2\times 10^5$，$1 \le m_1, m_2 \le n$，$1 \le c_1, c_2, p \le 100$，$1 \le r_i \le 100$ 。
---
## $\color{#000}\texttt{Solution}$

网络流的 $50\sim90$ 分做法就不赘述了。

首先从两种洗餐巾方式入手。把 $m$ 大的洗餐巾方式叫慢洗，反之叫快洗。如果慢洗比快洗贵，把慢洗设为和快洗一模一样。这样我们就有**快洗快而贵，慢洗慢而便宜**两种洗法了。令快洗时间为 $t_k$，价格为 $f_k$ 每块；慢洗时间为 $t_m$，价格为 $f_m$ 每块（$t_k\le t_m,f_k\ge f_m$）。

买的餐巾总数 $x$ 是不定的，如果买多了也耗钱，买少了洗得多也耗钱。所以可以直觉推断**买餐巾数量一定的情况下最少耗钱随 $x$ 而变化的图像是 $V$ 字型**，所以可以三分或斜率二分，找到这个 $x$。

但是知道了 $x$，怎么计算最优耗钱呢？首先要**早买餐巾**，因为早点买早点用早点洗对每个餐巾的利用率高。所以可以用买餐巾解决前几天的需求。

然后是**能用慢洗不用快洗**，很明显，因为快洗贵。

所以可以用**三个双向队列维护脏餐巾（每天用完的餐巾）、慢洗完的餐巾（用完后至少 $t_m$ 天）、快洗完的餐巾（用完后 $t_k\sim t_m-1$）**。每天把脏餐巾队列的末尾用完时间到 $t_k$ 天的餐巾放进快洗完的餐巾队列头，然后把快洗完的餐巾队列末尾时间到 $t_m$ 的餐巾放进慢洗完的队列头。然后按**先买再慢洗最后快洗**的顺序模拟即可。

特别的，如果某天的要求怎么都满足不了，就返回 $\infty$。

最后答案就是三分或斜率二分得到的耗钱谷点的耗钱数。

---

## $\color{#000}\texttt{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
const int inf=0x3f3f3f3f;
const lng Inf=1e17;

//&Check
const int N=2e5+10;
int n,r[N],fx,fm,fk,Tm,Tk,sm,ans=inf;
struct bag{int T,v;};
//买来的时间、数量（把多份一起买的餐巾打包）
deque<bag> qx,qm,qk;//新买、慢洗、快洗
int f(int x){//买x块餐巾计算最优耗钱
	int res=x*fx;//买餐巾的钱
	qx.clear(),qm.clear(),qk.clear();
	for(int i=1;i<=n;i++){
		while(qx.size()&&qx.front().T+Tk<=i)
			qk.push_back(qx.front()),qx.pop_front();
		//把旧餐巾快洗完的丢进快洗队列
		while(qk.size()&&qk.front().T+Tm<=i)
			qm.push_back(qk.front()),qk.pop_front();
		//把快洗完的餐巾慢洗完的丢进慢洗队列
		int nd=r[i],by=min(nd,x);//如果还可以买餐巾就先买
		x-=by,nd-=by;
		while(nd&&qm.size()){//先慢洗
			by=min(nd,qm.back().v);
			nd-=by,res+=by*fm;
			if(by==qm.back().v) qm.pop_back();//用完了
			else qm.back().v-=by;
		}
		while(nd&&qk.size()){//再快洗
			by=min(nd,qk.back().v);
			nd-=by,res+=by*fk;
			if(by==qk.back().v) qk.pop_back();//用完了
			else qk.back().v-=by;
		}
		if(nd) return inf;
		qx.push_back((bag){i,r[i]});
	}
	return res;
}

//&Main
int main(){
	scanf("%d%d%d%d%d%d",&n,&Tm,&Tk,&fm,&fk,&fx);
	if(Tm<Tk) swap(Tm,Tk),swap(fm,fk);
	if(fm>fk) Tm=Tk,fm=fk;//保证快洗快贵，慢洗慢便宜
	for(int i=1;i<=n;i++) scanf("%d",r+i),sm+=r[i];
	int l=0,r=sm+1;
	while(l<r-1){//斜率二分
		int mid=(l+r)>>1;
		if(f(mid)<f(mid+1)) r=mid;
		else l=mid;
	}
	printf("%d\n",f(r));//Go!
	return 0;
}
```

---
然后把这份代码交到另外三题，就妥妥四倍经验了。我还是太蒻了。**祝大家学习愉快！**

---

## 作者：滑大稽 (赞：12)

为什么都说这题网络流只有50~90分啊，我直接把[P1251](https://www.luogu.com.cn/problem/P1251)的代码搬过来，数据范围改大一点就直接过了。 ~~（卡常都不用是我没想到的）~~

我感觉可能是我网络流写的不算难看，那我就稍微分享一下网络流的几点优化吧。

1. zkw费用流是必须的，或者多路增广spfa也行（话说这道题多路增广spfa甚至比zkw跑得还快）

2. 推荐最短路spfa用双端队列优化的spfa（不加写好看点也能过，但最后一个点完全是卡着过了）

3. 必须要加当前弧优化，不然你就会深深感受第10个点的险恶

4. 建议写快读，快出在这道题没必要

5. 清零尽可能用memset（好像memset比for循环要快一点吧？）

6. 记得开其他大大小小的玄学优化

7. 切记要吸氧

由于我习惯打zkw，那我就把我的zkw代码放上来吧（码风有亿点点奇怪）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define ll long long
#define inf 1e17
#define inff 1e9
#define M 3000005
#define N 400005
using namespace std;
struct nood{
	int x,y,z,w;
}q[M];
int k[N],c[N];
ll d[N];
int su=1,s,t,n;
ll co;
bool v[N]; 
inline int r()
{
	char h=getchar();
	int y=0,q=1;
	while(h<'0'||h>'9'){if(h=='-')q=-1;h=getchar();}
	while(h>='0'&&h<='9'){y=y*10+h-'0';h=getchar();}
	return y*q;
}
inline void jr(int a,int b,int c,int d)
{
	q[++su]=(nood){k[a],b,c,d};
	k[a]=su;
	q[++su]=(nood){k[b],a,0,-d};
	k[b]=su;
}
inline bool spfa()
{
	memset(d,0x3f,sizeof d);
	deque<int>dl;
	dl.push_front(t);
	d[t]=0;
	while(!dl.empty())
	{
		if(dl.size()>1&&d[dl.front()]>d[dl.back()])swap(dl.front(),dl.back());
		int x=dl.front();dl.pop_front();
		v[x]=0;
		for(int i=k[x];i;i=q[i].x)
		{
			int y=q[i].y,z=q[i^1].z,w=q[i].w;
			if(!z)continue;
			if(d[y]>d[x]-w)
			{
				d[y]=d[x]-w;
				if(!v[y])
				{
					v[y]=1;
					if(dl.size()&&d[y]<d[dl.front()])dl.push_front(y);
					else dl.push_back(y);
				}
			}
		}
	}
	return d[s]!=d[0];
}
int dfs(int x,int nl)
{
	if(x==t||!nl)return nl;
	v[x]=1;
	int sl=0;
	for(int i=c[x];i;i=q[i].x)
	{
		c[x]=i;
		int y=q[i].y,z=q[i].z,w=q[i].w;
		ll l;
		if(!v[y]&&d[y]==d[x]-w&&z&&(l=dfs(y,min(nl,z))))
		{
			nl-=l;
			sl+=l;
			q[i].z-=l;
			q[i^1].z+=l;
			co+=w*l;
			if(!nl)break;
		}
	}
	if(nl)d[x]=-1;
	v[x]=0;
	return sl;
}
inline void zkw()
{
	int x;
	while(spfa())
	{
		memcpy(c,k,sizeof k);
		while((x=dfs(s,inff)));
	}
}
signed main()
{
	n=r();int a=r(),b=r(),c=r(),d=r(),e=r();
	s=(n<<1)+1,t=s+1;
	for(int x,i=1;i<=n;i++)x=r(),jr(s,i,x,0),jr(i+n,t,x,0);
	for(int i=1;i<=n;i++)
	{
		if(i+1<=n)jr(i,i+1,inff,0);
		if(i+a<=n)jr(i,i+a+n,inff,c);
		if(i+b<=n)jr(i,i+b+n,inff,d);
		jr(s,i+n,inff,e);
	}
	zkw();
	printf("%lld\n",co);
}
```

~~双倍经验到手~~

---

## 作者：onlyfiee (赞：8)


## 前置
**注意，网络流不是这道题的正解，学习正解的可以看看别人的题解。**

所需知识：费用流。

## 分析

首先考虑这个网络流如何建边，毕竟最难的地方还是建边。

网络流拆点成边的技巧有很多种，在这里推荐一道题目。

[P2045 方格取数加强版](https://www.luogu.com.cn/problem/P2045)。

根据题意，可以进行以下的操作。

1. 购买毛巾。
1. 将毛巾放到 $A$ 店去洗，并在 $m_1$ 天后获得毛巾。
1. 将毛巾放到 $B$ 店去洗，并在 $m_2$ 天后获得毛巾。
1. 以后再来洗。

注意操作四是很容易忽略掉的，但是需要考虑进去，虽然你现在不需要毛巾，但是可能以后需要。

将每一天拆成两个点然后连边，也就是说，钱就是费用，毛巾的需求量就是单价。

所以就有如下的代码。
## code-建边
```cpp
	s=0,t=2*n+1;//s是起始点,t是终点
	for(int i=1;i<=n;i++)
	{
		ll u;
		cin>>u;
		add(s,i,u,0);//表示终点给起始点脏毛巾。
		add(i+n,t,u,0);//表示起始点给终点干净毛巾。
	}
	for(int i=1;i<=n;i++)
	{
		add(s,i+n,inf,p);
		if(i+1<=n) add(i,i+1,inf,0);//这里三个之所以加判断条件，是因为如果毛巾没拿到n天就结束了，肯定是没有用的。   
		if(i+a<=n) add(i,i+n+a,inf,f); 
		if(i+b<=n) add(i,i+n+b,inf,ss); 
	}
```
剩下的就只需要跑一遍 dinic 就得到了答案。由于流量是无限大的（就是可以源源不断的获得毛巾），所以后面四个的建边流量是 $inf$。

## 关于代码效率
我用的是 SPFA 来跑，关于 SPFA ~~他死了~~，似乎有很多玄学的方法优化，但是在这里就不在赘述。

不过还是有[代码](https://www.luogu.com.cn/paste/btz0pa21)实现的。在这道题确实提高了挺多效率，如果是大常数选手可以考虑。关于 long long 和 memset 不要滥用，这样还是可以通过此题的。dinic 需要考虑当前弧优化。

[玄学优化效率](https://www.luogu.com.cn/record/123464053)，[普通 SPFA 效率](https://www.luogu.com.cn/record/123464390)。

最后给出第二种代码的实现方式。

## code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define next _
const ll inf=1e17;
using namespace std;
const int N=4e6+50;
long long n,p,b,f,a,ss,tot,ans,s;
ll d[N];
int head[N],to[N],c[N],next[N];
long long edge[N],cost[N];
queue<int>q;
bool v[N];
int cnt=1;
int t,num;
void add(int x,int y,register ll w,int f)
{
	to[++cnt]=y;next[cnt]=head[x];edge[cnt]=w;cost[cnt]=f;head[x]=cnt;
	to[++cnt]=x;next[cnt]=head[y];edge[cnt]=0;cost[cnt]=-f;head[y]=cnt;
}
bool spfa()
{
	for(int i=0;i<=t;i++) d[i]=inf,v[i]=0,c[i]=head[i];
	q.push(0);
	v[0]=1;
	d[0]=0;
	while(!q.empty())
	{
		int k=q.front();
		q.pop();v[k]=0;
		for(int i=head[k];i;i=next[i])
		{
			int u=to[i],w=cost[i];
			if(d[u]>d[k]+w&&edge[i])
			{
				d[u]=d[k]+w;
				if(!v[u]) v[u]=1,q.push(u); 
			} 
		}
	}
	return d[t]!=inf;
}
ll dfs(int p,ll now)
{
	if(p==t||!now)	return now;
	ll minn=0,used=0;
	v[p]=1;
	for (int i=c[p];i;i=next[i])
	{
		c[p]=i; int u=to[i],w=cost[i];
		if((!v[u]||u==t)&&d[u]==d[p]+w&&edge[i])
		if((minn=dfs(u,min(now-used,edge[i]))))
		{
			edge[i]-=minn; edge[i^1]+=minn; used+=minn;
			tot+=w*minn;
		}
		if(used==now)	break;
	}
	v[p]=0;
	return used;
}
long long dinic()
{
	while (spfa())
	{
        memcpy(c,head,(t+1)*sizeof(int));
		dfs(s,inf);
	}
	return tot;
}
signed main()
{
	scanf("%lld",&n);
	scanf("%lld%lld%lld%lld%lld",&a,&b,&f,&ss,&p);
	s=0,t=2*n+1;
	for(int i=1;i<=n;i++)
	{
		ll u;
		cin>>u;
		add(s,i,u,0);
		add(i+n,t,u,0);
	}
	for(int i=1;i<=n;i++)
	{
		add(s,i+n,inf,p);
		if(i+1<=n) add(i,i+1,inf,0);   
		if(i+a<=n) add(i,i+n+a,inf,f); 
		if(i+b<=n) add(i,i+n+b,inf,ss); 
	}
	cout<<dinic();
}
```


---

## 作者：木xx木大 (赞：3)

[P4480 [BJWC2018]餐巾计划问题](https://www.luogu.com.cn/problem/P4480)

双倍经验[P2917 [USACO08NOV]Toys G](https://www.luogu.com.cn/problem/P2917)

先考虑一下这题的部分分/弱化版[P1251 餐巾计划问题](https://www.luogu.com.cn/problem/P1251)，这是一个经典的**费用流问题**，做法如下：

* 首先拆点。把每一天拆成早上和晚上，早上用干净的餐巾，晚上回收脏的餐巾。

- 源点向每一天的晚上连一条流量为 $r_i$，费用为0的边，表示这一天得到的脏餐巾。每一天的早上向汇点连一条流量为 $r_i$，费用为0的边，表示这一天要提供 $r_i$ 条干净毛巾。这样连边的目的是保证有 $r_i$ 的干净毛巾的流量流过这一天。（感觉这一步不太好想，个人认为这是**本题核心**了）
- 每一天晚上向下一天晚上连一条流量为INF，费用为0的边，处理不洗的情况
- 每一天晚上向快洗结束之后的那天早上连一条流量为INF，费用为快洗费用的边，处理快洗的情况。慢洗的连边方式与快洗相同。
- 源点向每一天早上连一条流量为INF，费用为买新毛巾费用的边，代表新买毛巾。

到这里我们就可以 AC [P1251 餐巾计划问题](https://www.luogu.com.cn/problem/P1251)和它的双倍经验[P2223 [HNOI2001]软件开发](https://www.luogu.com.cn/problem/P2223)了。后者轻微卡常。这里放一下P1251的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,p,m1,m2,f1,f2;
	const int N=1e4+5;
	const int INF=0x3f3f3f3f;
	struct edg{
		int to,nxt,w,d;
	}e[N<<2];
	int a[N],cnt=1,head[N],S,T,lst[N],vis[N],flo[N],dis[N];
	ll ans=0;
	void add(int u,int v,int w,int d)
	{
		cnt++;
		e[cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
		e[cnt].w=w,e[cnt].d=d;
	}
	void Add(int u,int v,int w,int d){add(u,v,w,d),add(v,u,0,-d);}
	queue<int> q;
	bool spfa()
	{
		memset(vis,0,sizeof(vis)),memset(dis,0x3f,sizeof(dis));
		dis[S]=0,vis[S]=1,flo[S]=0x3f3f3f3f;q.push(S);
		while(q.size())
		{
			int u=q.front();q.pop();
			vis[u]=0;
			for(int i=head[u];i;i=e[i].nxt)
			{
				int v=e[i].to;
				if(dis[v]>dis[u]+e[i].d&&e[i].w)
				{
					dis[v]=dis[u]+e[i].d,flo[v]=min(flo[u],e[i].w),lst[v]=i;
					if(!vis[v])q.push(v),vis[v]=1;
				}
			}
		}
		return dis[T]!=0x3f3f3f3f;
	}
	void work()
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		T=2*n+1;
		scanf("%d%d%d%d%d",&p,&m1,&f1,&m2,&f2);
		for(int i=1;i<=n;i++)
		{
			Add(S,i+n,a[i],0),Add(i,T,a[i],0);
			Add(S,i,INF,p);
			if(i<n)Add(i+n,i+n+1,INF,0);
			if(i+m1<=n)Add(i+n,i+m1,INF,f1);
			if(i+m2<=n)Add(i+n,i+m2,INF,f2);
		}
		while(spfa())
		{
			int now=T;
			ans+=1LL*flo[T]*dis[T];
			while(now!=S)
				e[lst[now]].w-=flo[T],e[lst[now]^1].w+=flo[T],now=e[lst[now]^1].to;
		}
		printf("%lld",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

但费用流显然是不能处理 $2e5$ 的数据的（听说这题数据水可以卡过去，当然像我这样的大常数选手肯定是不行的），我们需要更优秀的解法。

首先有两个显然的性质：

* 如果买的毛巾的总量一定，越早买一定越优。
* 如果慢洗比快洗贵，那么就不用慢洗，将其直接改为快洗。

假设在这 $n$ 天内一共购买了 $x$ 块新餐巾，设 $f(x)$ 表示一共购买了 $x$ 块新餐巾的最小代价，最优解一共购买了 $x'$块新餐巾。首先买多余的餐巾放着不用肯定不优。若 $x=x'-k$，那么在费用流的图上表示买新餐巾的边就少流了 $k$ 次。由于在费用流中我们寻找的是最短路，少流一条最短路中的边就说明走了一条较长路，因此少买也不优。综上，$f(x)$为单峰函数，此题可用**三分**解决。问题就转化为了如何求 $f(x)$，我们进行贪心：

* 如果还能买新餐巾就买
* 新餐巾用完后优先用慢洗的餐巾，再用快洗的餐巾。因为经过上面的转化，慢洗的毛巾更便宜。
* 用快洗的餐巾时要优先用时间较晚的，因为时间较早的更有可能在之后变为慢洗的餐巾从而减小代价。
* 如果没有可用的餐巾了，说明当前所设的 $x$ 无法满足要求，返回 INF 。

具体实现时，开三个 deque 分别存弄脏后还没洗好的餐巾、已经快洗好了的餐巾和已经慢洗好了的餐巾，按上面说的四条原则模拟即可。

~~所以这题实际上是四倍经验~~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m1,m2,f1,f2,p;
	const int INF=2e9;
	const int N=2e5+5;
	int a[N],sum,ans=INF;
	deque<pair<int,int> >qs,qn,qf;//qn表示正在洗的，qs表示已经慢洗好了的，qf表示已经快洗好了的 
	int calc(int x)
	{
		int s=p*x;
		qs.clear(),qn.clear(),qf.clear();
		for(int i=1;i<=n;i++)
		{
			while(qn.size()&&qn.front().first<=i-m1)//先更新队列	
				qf.push_back(qn.front()),qn.pop_front();
			while(qf.size()&&qf.front().first<=i-m2)
				qs.push_back(qf.front()),qf.pop_front();
			int nd=a[i],mn=min(nd,x);nd-=mn,x-=mn;//能买新的尽量买 
			while(nd&&qs.size())//能慢洗就慢洗 
			{
				mn=min(nd,qs.back().second);
				s+=mn*f2,nd-=mn;
				if(mn==qs.back().second)qs.pop_back();//用完的及时弹出以保证复杂度 
				else qs.back().second-=mn;
			}
			while(nd&&qf.size())//不能慢洗就快洗 
			{
				mn=min(nd,qf.back().second);
				s+=mn*f1,nd-=mn;
				if(mn==qf.back().second)qf.pop_back();
				else qf.back().second-=mn;
			}
			if(nd)return INF;//满足不了需求，说明当前买的总量不合法。 
			qn.push_back(make_pair(i,a[i]));//把这一天弄脏的拿去洗 
		}
		return s;
	}	
	void work()
	{
		scanf("%d%d%d%d%d%d",&n,&m1,&m2,&f1,&f2,&p);
		if(m1>m2)swap(m1,m2),swap(f1,f2);
		if(f2>f1)f2=f1,m2=m1;//如果慢的还贵，就不用它，把它直接改成快的方式 
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]),sum+=a[i];
		int l=0,r=sum+1;
		while(r-l>2)
		{
			int k=(r-l)/3,mid1=l+k,mid2=r-k;
			calc(mid1)>=calc(mid2)?l=mid1:r=mid2;
		}
		for(int i=l;i<=r;i++)ans=min(ans,calc(i));
		printf("%d\n",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```


---

## 作者：白いバラの夜 (赞：3)

该自一个AFO的蒟蒻的博客：https://www.cnblogs.com/luyouqi233/p/8933397.html

这道题和网络流24题中的餐巾计划的确不一样,[BJWC2018]餐巾计划问题的数据范围更大。

一个餐厅在相继的n天里，每天需用的餐巾数不尽相同。假设第i天(i=1,2,...,n)需要ri块餐巾。餐厅可以在任意时刻购买新的餐巾，每块餐巾的费用为p。

使用过的旧餐巾，则需要经过清洗才能重新使用。把一块旧餐巾送到清洗店A，需要等待m1天后才能拿到新餐巾，其费用为c1；把一块旧餐巾送到清洗店B，需要等待m2天后才能拿到新餐巾，其费用为c2。

例如，将一块第k天使用过的餐巾送到清洗店A清洗，则可以在第k+m1天使用。


对于50%的数据，我们有一个很经典的网络流做法：[餐巾计划问题](http://www.cnblogs.com/luyouqi233/p/8483640.html)。

但是数据规模扩大后就显然不能用网络流求解了。

分两种情况：

1.快洗店更贵：

考虑到先买和后买餐巾所对答案和过程不会造成影响，且当买餐巾c条达到最优解时，显然c+k的花费比c+k+1的花费更少。

并且不难感性证出c-k的花费比c-k-1的花费更少（会在最优情况下多次使用快洗店的餐巾使得钱变多）。

因此我们可以三分求解。

最便宜的显然是先使用新的毛巾，等到没了的时候使用慢洗店的，最差使用快洗店的得出答案，使用队列维护一下即可（虽然这么说，也是挺恶心的，我对着别人的代码调了3h才过，可能现在让我解释代码都解释不明白。）

2.快洗点更便宜：

那就都快洗，这是显然的。

这是可爱的代码
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=200010;
const int INF=2147483647;
inline int read(){
    int X=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')X=(X<<1)+(X<<3)+ch-'0',ch=getchar();
    return X*w;
}
int t[N],num[N],q[N],cnt,d,n1,n2,c1,c2,tc;
int sn,sm,so,en,em,eo;
inline void add(int x,int p){
    q[en]=x;num[en++]=p;
}
int f(int k){
    sn=sm=so=en=em=eo=0;
    int ans=(tc-c2)*k;
    add(-2000000,k);
    for(int i=1;i<=d;i++){
        int j=t[i];
        while(sn!=en&&i-q[sn]>=n1){
            num[em]=num[sn];
            q[em++]=q[sn++];
        }
        while(sm!=em&&i-q[sm]>=n2){
            num[eo]=num[sm];
            q[eo++]=q[sm++];
        }
        while(j>0){
            if(so!=eo){
                if(num[eo-1]>j){
                    ans+=c2*j;
                    num[eo-1]-=j;
                    break;
                }
                else{
                    ans+=c2*num[eo-1];
                    j-=num[eo-1];
                    eo--;
                }
            }
            else if(sm!=em){
                if(num[em-1]>j){
                    ans+=c1*j;
                    num[em-1]-=j;
                    break;
                }
                else{
                    ans+=c1*num[em-1];
                    j-=num[em-1];
                    em--;
                }
            }
            else return INF;
        }
        add(i,t[i]);
    }
    return ans;
}
int sfen(int l,int r){
    while(233){
        if(r-l<=2){
            int m=INF;
            for(int i=l;i<r;i++)m=min(m,f(i));
            return m;
        }
        int mid1=l+(r-l)/3,mid2=l+2*(r-l)/3;
        int a=f(mid1);
        if(a!=INF&&a<=f(mid2))r=mid2;
        else l=mid1;
    }
}
int main(){
    d=read(),n1=read(),n2=read(),c1=read(),c2=read(),tc=read();
    if(n1>n2){swap(n1,n2);swap(c1,c2);}
    if(c1<=c2)n2=2000001,c2=101;
    int tsum=0;
    for(int i=1;i<=d;i++){
        t[i]=read();tsum+=t[i];
    }
    printf("%d\n",sfen(0,tsum+1));
    return 0;
}
```

---

## 作者：strcmp (赞：3)

人生第二道黑题题解。

**步入正题**

看见这道题几乎都是贪心，所以贡献一个网络流题解，重点讲如何卡常，想知道为什么这样建模的可以去看弱化版题解。

**建模方法：**

可以按照[弱化版](https://www.luogu.com.cn/problem/P4480)的做法。

1. 考虑拆点，将一个点拆成早上和晚上，早上接受干净餐巾，晚上发出脏餐巾，建立超级源 $s$ 和超级汇 $t$，从 $s$ 连向每一天早上，容量为 $r_i$，费用为 $0$；从每个结点的晚上连向 $t$，容量为 $r_i$，费用为 $0$。

2. $s$ 向每一天晚上连容量为 $+\infty$，费用为 $p$ 的边，表示买新餐巾。

3. 每个结点 $u_i$ 向 $u_{i+m_1}$ 连容量为 $+\infty$，费用为 $c_1$ 的边，表示送快洗店，慢洗店类似处理。

4. 每一天早上可以选择留下干净餐巾备用，所以从 $u_i$ 连向 $u_{i+1}$，容量为 $+\infty$，费用为 $0$。

5. 求最小费用最大流，最小费用即为所求。

**卡常**

首先，单路增广的 MCMF 肯定死的不能再死了，考虑对其优化，想到多路增广 MCMF，打了一波板子，交上去仍然 TLE。

难道只能贪心了吗？

**SLF 优化**

SPFA 很容易被网络图和菊花图卡成 $O(nm)$，但是有一种优化能使 SPFA 过掉网络图的 Hack，并且在实践中快上大约 $40\%$，这就是 **Small Label First** 优化。

如果设 $\operatorname{dis}(u)$ 为结点 $u$ 的预测距离，具体是这样的：

- 比较将要入队的结点经过松弛后的 dis 值与队首结点的 dis 值

- 如果比队首结点的 dis 值小，则进入队首

- 否则不小于队首结点的 dis 值，则进入队尾

这个优化看起来很微小，但可以让队列更接近优先队列，从而大大减少松弛次数。

经过 SLF 优化，终于有 90pts 了！

**LLL 优化**

LLL 优化即 **Large Label Last** 优化，看起来跟 SLF 优化没什么差别，但实际上配合 SLF 优化往往能使 SPFA 优化 $60\%$！

设 $ave$ 为当前队列中结点的 $dis$ 的平均值，算法步骤是这样的：

- 每次队首结点出队后，继续比较队首结点的 $dis$ 与队列内 $ave$ 的大小

- 如果队首结点 $dis$ 大于 $ave$，则取出队首结点，并将其放入队尾，并重复步骤一

- 否则，队首结点 $dis$ 不大于 $ave$，退出循环

经过两个优化，再卡一卡常，吸一吸氧，网络流就能过这道毒瘤题了！

ACcode

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 1000100
#define E 5000100
typedef long long int ll;
struct edge {
	int to, next;
	ll capa, cost;
};
int cnt = 0, head[V], n, m; edge node[E];
inline void add(register int fir,register int nxt,register ll w,register ll c) {
	node[cnt].to = nxt,
		node[cnt].capa = w,
		node[cnt].cost = c,
		node[cnt].next = head[fir],
		head[fir] = cnt++;
}
int s, t, cur[V]; deque<int>que; ll dep[V], sum = 0, cost = 0, num = 0;
bool vis[V];
inline bool spfa() {
	for (register int i = 1; i <= t; ++i)dep[i] = inf;
	dep[s] = 0; que.push_back(s); int u, v;
	while (!que.empty()) {
		v = que.front(); que.pop_front();
		while (dep[v] * que.size() > num)que.pop_front(), que.push_back(v), v = que.front();
		for (register int i = head[v]; i != -1; i = node[i].next) {
			u = node[i].to;
			if (dep[v] + node[i].cost < dep[u] && node[i].capa) {
				dep[u] = dep[v] + node[i].cost, num += dep[u];
				if (!que.empty() && dep[u] < dep[que.front()])que.push_front(u);
				else que.push_back(u);
			}
		}
	}
	num = 0;
	return (dep[t] != inf);
}
ll dfs(register int v, register ll flow) {
	if (flow == 0 || v == t)return flow; ll used = 0, wei = 0;
	vis[v] = true;
	for (register int i = cur[v]; i != -1; i = node[i].next) {
		cur[v] = i;
		if (!vis[node[i].to] && dep[node[i].to] == dep[v] + node[i].cost && node[i].capa) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei,
					node[i ^ 1].capa += wei,
					used += wei,
					cost += node[i].cost * wei;
			}
		}
		if (used == flow)break;
	}
	vis[v] = false;
	return used;
}
inline void Dinic() {
	while (spfa()) {
		memcpy(cur, head, (t + 1) * sizeof(int));
		sum += dfs(s, inf);
	}
}
inline void addE(int u, int v, ll w, ll c) {
	add(u, v, w, c);
	add(v, u, 0, -c);
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(); cout.tie();
	memset(head, -1, V * sizeof(int));
	int fast, sown; ll p, f, ss;
	cin >> n >> fast >> sown >> f >> ss >> p;
	s = 2 * n + 1, t = 2 * n + 2; ll w;
	for (register int i = 1; i <= n; ++i) {
		cin >> w;
		addE(s, i, w, 0);
		addE(i + n, t, w, 0);
	}
	
	for (register int i = 1; i <= n; ++i) {
		addE(s, i + n, inf, p);
		if(i + fast <= n)addE(i, i + fast + n, inf, f);
		if(i + sown <= n)addE(i, i + sown + n, inf, ss);
		if (i + 1 <= n)addE(i, i + 1, inf, 0);
	}
	Dinic();
	cout << cost;
	return 0;
}
```


---

## 作者：radish布団 (赞：2)

看过讨论的各位大佬应该已经发现了，这道题与[P2917](https://www.luogu.org/problemnew/show/P2917)，[P1251](https://www.luogu.org/problemnew/show/P1251)仅在数据范围及数据强度上略有不同。因此本文会先给出[P2917](https://www.luogu.org/problemnew/show/P2917)的标准解法，再对本题所增加的特殊情况进行讨论。~~三倍经验美滋滋~~
## P2917
显而易见的是，照抄[P1251](https://www.luogu.org/problemnew/show/P1251)的费用流解法会导致程序 $TLE$，因此我们必须寻找一个 $O(nlogn)$ 的优秀解法解决这道题。我们假设在这 $n$ 天内一共购买了 $m$ 块新餐巾，而最优解一共购买了 $m_{ans}$ 块新餐巾。若 $m=m_{ans}+k$，由于购买新餐巾必然比洗旧餐巾贵，因此多买必定不优。若 $m=m_{ans}-k$，那么在网络流的图上表示买新餐巾的边就少流了一次。由于在网络流中我们寻找的是最短路，那么少流一条最短路中的边也就说明走了一条较长路，因此少买必定不优。综上，总花费关于新餐巾购买数的函数 $f(x)$ 必为单峰函数，所以此题可用**三分**解决。

那么对于任意一个点 $x_i$，如何计算 $f(x)$ 呢？

通过分析网络流解法的建图方式可以发现，每天的干净餐巾来源有4个：

1. 在前几天买了但还没用完的干净餐巾；
2. 在今天买的干净餐巾；
3. 在 $t_1$ 天前送去慢洗部的脏餐巾；
4. 在 $t_2$ 天前送去快洗部的脏餐巾。

可以依据以上四条进行贪心：

1. 若还有新餐巾没用完，则先用新餐巾；
2. 新餐巾用完后，优先用慢洗部送来的餐巾，且优先用较晚送来的餐巾；
3. 慢洗部送来的餐巾用完后，用快洗部送来的餐巾，且优先用较晚送来的餐巾；
4. 若快洗部送来的餐巾用完后仍不满足今日所需，则说明此情况无解。

**Q1. 为什么要先用慢洗部送来的餐巾？**

**A1. 因为若慢洗部送来的餐巾已经满足了今日所需，就没必要用快洗部送来的餐巾了。**

**Q2. 为什么要优先用较晚送来的餐巾？**

**A2. 为了以后减少清洗费用，而较早送来的餐巾更有可能以更低廉的价格进行清洗。例如，现在有2块快洗部送来的餐巾，一块是今天刚送来的，另一块是好几天前送来，再多一天就能用慢洗部洗的，而今日还需餐巾1块。若用今天送来的那块餐巾，到明天时另一块餐巾就能用慢洗部清洗，从而减少了清洗费用。**

依照以上贪心思路，开三个双端队列分别存储剩余的新餐巾，快洗部洗的餐巾以及慢洗部洗的餐巾即可。

## P4480
关于这道题，其数据不仅在范围上有所增强，还增加了一种特殊情况。即：慢洗部的价格高于快洗部的价格。~~(喵喵喵？？？)~~ 针对这种特殊情况的特判也是显而易见的：只需把慢洗部的时间和价格都改为快洗部的即可。

然而，按照以上解法构建的代码是无法通过本题的。(后三个点 $TLE$ )原因是我们开了三个极慢的双端队列，大大拖慢了程序速度。解决方法有两个：

1. 吸氧。众所周知， $O2$ 优化对于 $STL$ 的常数优化是极其明显的。开 $O2$ 后第6个点的速度比不开 $O2$ 快了十几倍。(109ms --> 8ms)
2. 只开一个双端队列，且不用 $STL$，纯靠手写。关于这种解法，由于我实在是太过~~懒惰~~蒟蒻，因此没有研究。还请各位大佬自行分析，构建代码。

以下是蒟蒻写的不吸氧只能拿70分的辣鸡 $TLE$ 代码：
```
#include<algorithm>//STL通用算法
#include<bitset>//STL位集容器
#include<cctype>
#include<cmath>
#include<complex>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<deque>//STL双端队列容器
#include<list>//STL线性列表容器
#include<map>//STL映射容器
#include<iostream>
#include<queue>//STL队列容器
#include<set>//STL集合容器
#include<stack>//STL堆栈容器
#include<utility>//STL通用模板类
#include<vector>//STL动态数组容器
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
typedef pair<int,int> pr;//first 日期 second 个数 
int n,tot[200001],sum,pri_slw,pri_fst,pri_new,tim_slw,tim_fst;
deque<pr> ava_slw,ava_fst,ava_new;
int calc(int buy)
{
	int ans=pri_new*buy;
	ava_slw.clear(),ava_fst.clear(),ava_new.clear();
	for(int i=1;i<=n;i++)
	{
		while(!ava_new.empty()&&ava_new.front().first<=i-tim_fst)//能快洗就不新买 
			ava_fst.push_back(ava_new.front()),ava_new.pop_front();
		while(!ava_fst.empty()&&ava_fst.front().first<=i-tim_slw)//能慢洗就不快洗 
			ava_slw.push_back(ava_fst.front()),ava_fst.pop_front();
		int need=tot[i],mn=min(need,buy);need-=mn,buy-=mn;
		while(need&&!ava_slw.empty())//能用慢洗就用慢洗 
		{
			int tmp=min(need,ava_slw.back().second);//优先用时间最靠后的 
			ans+=tmp*pri_slw,need-=tmp;
			if(tmp==ava_slw.back().second) ava_slw.pop_back();
			else ava_slw.back().second-=tmp;
		}
		while(need&&!ava_fst.empty())//实在不行再用快洗 
		{
			int tmp=min(need,ava_fst.back().second);//优先用时间最靠后的 
			ans+=tmp*pri_fst,need-=tmp;
			if(tmp==ava_fst.back().second) ava_fst.pop_back();
			else ava_fst.back().second-=tmp;
		}
		if(need) return INF;
		ava_new.push_back(make_pair(i,tot[i]));
	}
	return ans;
}
int main()
{
	scanf("%d%d%d%d%d%d",&n,&tim_fst,&tim_slw,&pri_fst,&pri_slw,&pri_new);
	if(tim_slw<tim_fst) swap(tim_slw,tim_fst),swap(pri_slw,pri_fst);
	if(pri_slw>pri_fst) pri_slw=pri_fst,tim_slw=tim_fst;
	for(int i=1;i<=n;i++) scanf("%d",&tot[i]),sum+=tot[i];
	int l=0,r=sum;
	while(r-l>2)
	{
		int midl=(l*2+r)/3,midr=(l+r*2+2)/3;
		int pril=calc(midl),prir=calc(midr);
		(pril>=prir? l=midl:r=midr);
	}
	int ans=INF;
	for(int i=l;i<=r;i++) ans=min(ans,calc(i));
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：HenryHuang (赞：1)

~~刷了n次用了奇淫技巧才拿到rk1，亥~~

这道题是网络流二十四题中「餐巾计划问题」的加强版。

于是怀着试一试的心情用费用流交了一发：

哇塞，过了9个点！（~~强烈谴责出题人用*造数据~~

下面是费用流解法简述：

那么我们把每一天拆为早上和晚上两个点，设为 $day_i,night_i$ 。

首先可以人为地规定一点：对一块餐巾，我们要么在其脏了之后立即送洗，要么买一块新干净餐巾来代替它。

然后对于每一个操作，我们可以如下连边：

对于买新干净餐巾：我们可以视作从源点买餐巾，从 $s$ 向 $day_i$ 连边即可

对于送慢洗部：从 $night_i$ 向 $day_{i+n}$ 连边，流量为 $inf$ ,费用为 $f$。

对于送快洗部：从 $night_i$ 向 $day_{i+m}$ 连边，流量为 $inf$ ,费用为 $s$。 

但是我们注意到，可能存在某一天的干净餐巾冗余。

于是我们要从 $day_i$ 向 $day_{i+1}$ 连一条费用为零，流量为 $inf$ 的单向边。

如何保证每天刚好只用 $r_i$ 块餐巾？

将其拆成两个板块：

从 $day_i$ 向 $t$ 连边，流量为 $r_i$，费用为 $0$。

从 $s$ 向 $night_i$ 连边，流量为 $r_i$，费用为 $0$。

------

优化无果，于是猜想可以不用费用流。

首先无论餐巾是最开始一起买还是需要用时再买，不会影响最终的答案。

那么如果我们已经确定了要买的新餐巾的张数，那么是否可以确定一种唯一的方案使得总花费最小呢？

不难得到有这样一种贪心策略：

在能够用新餐巾的时候，尽量使用新餐巾。

设 $m$ 为慢洗的天数。

如果无新餐巾可用，则倒回到 $m$ 天前，找用过的旧餐巾进行慢洗。

如果没有 $m$  天以前的旧餐巾可用，则**由时间线从近到远**地找旧餐巾进行快洗。

这样做使得时间线较远的旧餐巾更有可能慢洗。

如果慢洗比快洗贵，那么直接将慢洗的时间和价格都改为快洗的时间和价格即可。

朴素代码无O2只能过掉70分。

于是我怀疑单次判断的时间复杂度过高。有的题解里说是 $O(n)$ 的，但我死活没看出来。

于是我们可以优化常数。

注意到在如果在第 $i$ 天需要慢洗，所有在第 $i-m$ 天前的旧餐巾对于我们来说是等效的，因为我们显然没有办法将其拿去快洗。

所以我们每次将第 $i-m$ 天前的旧餐巾全部累加至第 $i-m$ 天即可。这样可以优化一定的常数。

这样可以保证在计算慢洗的时候一定是线性的，但仍然不能保证计算快洗部分时为线性。

最后我们需要确定最优解时需购买餐巾的张数 $c$。

设最优解时最小代价为 $f(c)$,设当前枚举到了 $x$。

则当 $x \ge c $,一定有 $f(x) \ge f(c)$，因为你还需要多出钱买新餐巾。

当 $x \le c$，则要么不存在 $f(x)$ ，即购买 $x$ 张餐巾不能达到目的，要么此时多洗一张餐巾一定劣于多买一张餐巾，也有 $f(x) \ge f(c)$。

所以对于最优解 $c$ 我们可以三分求解。

个人认为代码可读性还是挺高的，可以康康代码：

```cpp
/*---Author:HenryHuang---*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn=5e5+5;
const ll inf=1ll<<50;
ll sumr=0;
ll r[maxn],res[maxn];
ll n,m1,m2,c1,c2,p;
ll f(ll num){
	ll ans=1ll*num*p;//提前算好新餐巾代价 
	ll now=0;
	for(ll i=1;i<=n;++i){
		res[i]=0;
		if(r[i]){
			ll tmp=r[i];
			if(num){
				ll k=min(tmp,num);
				tmp-=k,res[i]+=k,num-=k;
				if(!tmp) continue;
			}//直接用新的 
			for(ll j=now;j<i-m2;++j){
				res[j+1]+=res[j],res[j]=0;
			}//累加旧洗餐巾 
			now=max(now,i-m2);
			if(now<i&&res[now]){
				ll k=min(tmp,res[now]);
				res[now]-=k,res[i]+=k;
				tmp-=k,ans+=1ll*k*c2;
				if(!tmp) continue;
			}//慢洗 
			for(ll j=i-m1;j>=1&&j>i-m2;--j){
				if(res[j]){
					ll k=min(tmp,res[j]);
					res[j]-=k,res[i]+=k;
					tmp-=k,ans+=1ll*k*c1;
				}
				if(!tmp) break;
			}//快洗 
			if(tmp) return inf;
		}
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m1>>m2>>c1>>c2>>p;
	if(m1>m2) swap(m1,m2),swap(c1,c2);//1快2慢
	if(c1<c2) c2=c1,m2=m1; 
	for(ll i=1;i<=n;++i)
		cin>>r[i],sumr+=r[i];
	ll l=1,r=max(10000ll,sumr/3);//奇淫技巧 
	ll ans=inf;
	while(r-l>2){
		ll k=(r-l)/3;
		ll mid1=l+k,mid2=r-k;
		ll aa=f(mid1),bb=f(mid2);
		if(aa<bb) ans=min(ans,aa),r=mid2;
		else ans=min(ans,bb),l=mid1;
	}
	for(ll i=l;i<=r;++i) ans=min(ans,f(i));
	cout<<ans<<'\n';
	return 0;
}
```



---

## 作者：柠檬熟了 (赞：0)

## [Luogu P4480 餐巾计划问题](https://www.luogu.com.cn/problem/P4480)

本系列经验中数据范围最大的一道，可以拿这个水掉其他的三个

### [**Luogu P1251 餐巾计划问题**](https://www.luogu.com.cn/problem/P1251)

### [**Luogu P2223 软件开发**](https://www.luogu.com.cn/problem/P2223)
(注意天数需要 +1)

### [**Luogu P2917 Toys G**](https://www.luogu.com.cn/problem/P2917)

## **思路部分**

可以用费用流卡过去，但这里讲贪心的思路。

考虑 **买的餐巾** 若太多，则花费很高。

如若太少，则可能无法安排，或需要换洗的次数过多，花费也很高。

故可以感性理解到，花费随购买餐巾变化的函数 是一个 **单峰函数**，可以想到**三分**购买的餐巾数。

（其中左边界 $L$ 可直接取第一天所需餐巾数，右边界 $R$ 取所需餐巾数之和）

```cpp
while (L + 2 < R) {
	K = (R - L) / 3, LM = L + K, RM = R - K;
	(Check(LM) >= Check(RM)) ? L = LM : R = RM;
}
```

可以将两种洗餐巾的方式按时间排序，以下称所需时间长的为 **慢洗**，另一种为 **快洗**

**若钦定慢洗更便宜**，则可以想到使用餐巾的优先顺序：

1. 先用已经买好的，相当于 **没有花费**
2. 再用慢洗的部分，每张花费 $C_{slow}$ 
3. 最后用快洗的部分，每张花费 $C_{fast}$

可以用**双端队列**维护已经洗好的部分，每次从队列中取走所需并支付即可 

## **实现部分**

先用结构体存储餐巾信息。

```cpp
struct Node {
	int id; // 来源在第几天
	long long n; // 数量
};
```



以 **Check** 函数为主，

记录所需花销 $Cost$，初始将其赋值为当前购买的餐巾数 $r$ 乘以单价 $p$。

```cpp
long long Cost = r * p;
```

枚举天数，在每天开始把待洗队列中符合条件（能在今天前洗好的）的餐巾放入两种清洗队列。

```cpp
while (!buy.empty() && buy.front().id + m <= i) fast.push_back(buy.front()), buy.pop_front(); // m 即快洗时间
while (!fast.empty() && fast.front().id + n <= i) slow.push_back(fast.front()), fast.pop_front(); // n 为慢洗时间
```

能买则买

```cpp
Ret = NR[i]; // 今日所需餐巾数
int Buy = min(Ret, r); // r 为当前三分到的总购买餐巾数
Ret -= Buy, r -= Buy;
```

先慢洗，再快洗

```cpp
while (Ret && !slow.empty()) {
    SlowNum = min(Ret, slow.back().n);
    Ret -= SlowNum, Cost += SlowNum * s;
    if (slow.back().n == SlowNum) slow.pop_back();
    else slow.back().n -= SlowNum;
}
while (Ret && !fast.empty()) {
    FastNum = min(Ret, fast.back().n);
    Ret -= FastNum, Cost += FastNum * f;
    if (fast.back().n == FastNum) fast.pop_back();
    else fast.back().n -= FastNum;
}
```

有剩的说明不可行，否则全部加入**待洗队列**。

```cpp
if (Ret) return INF;
buy.push_back({i, NR[i]});
```

最后返回花销即可。

注意到本题**并未给出清洗时间长花费一定小**的条件，故而特判这种情况。

```cpp
if (cslow > cfast) cslow = cfast, tslow = tfast; // 既然快洗便宜那么全部采用快洗
```

## **完整代码**

```cpp
#include <bits/stdc++.h>

const int MAXN = 300005;
const long long INF = 8e18;

using namespace std;

struct Node {
	int id;
	long long n;
};

long long NR[MAXN], Num[MAXN];
long long N;
long long L, R, LM, RM, K, Ans = INF;
long long p, m, f, n, s;

inline long long Check (long long r) {
	memset(Num, 0, sizeof Num);
	long long Cost = r * p;
	long long Ret = 0, SlowNum, FastNum;
	deque <Node> fast, slow, buy;
	for (int i = 1; i <= N; ++ i) {
		while (!buy.empty() && buy.front().id + m <= i) fast.push_back(buy.front()), buy.pop_front();
		while (!fast.empty() && fast.front().id + n <= i) slow.push_back(fast.front()), fast.pop_front();
		Ret = NR[i];
		int Buy = min(Ret, r);
		Ret -= Buy, r -= Buy;
		while (Ret && !slow.empty()) {
			SlowNum = min(Ret, slow.back().n);
			Ret -= SlowNum, Cost += SlowNum * s;
			if (slow.back().n == SlowNum) slow.pop_back();
			else slow.back().n -= SlowNum;
		}
		while (Ret && !fast.empty()) {
			FastNum = min(Ret, fast.back().n);
			Ret -= FastNum, Cost += FastNum * f;
			if (fast.back().n == FastNum) fast.pop_back();
			else fast.back().n -= FastNum;
		}
		
		if (Ret) return INF;
		buy.push_back({i, NR[i]});
	}
	return Cost;
}
int cfast, cslow, tfast, tslow, bc;

signed main () {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> N >> tfast >> tslow >> cfast >> cslow >> bc;
	if (tfast > tslow) swap(tfast, tslow), swap(cfast, cslow);
	if (cslow > cfast) cslow = cfast, tslow = tfast;
	n = tslow, s = cslow, m = tfast, f = cfast, p = bc;
	
	for (int i = 1; i <= N; ++ i) 
		cin >> NR[i], R += NR[i];
	L = NR[1];
	
	while (L + 2 < R) {
		K = (R - L) / 3, LM = L + K, RM = R - K;
		(Check(LM) >= Check(RM)) ? L = LM : R = RM;
	}
	for (; L <= R; ++ L) Ans = min(Ans, Check(L));
	
	cout << Ans;
	return 0;
}
```



---

## 作者：沉石鱼惊旋 (赞：0)

# 多倍经验

- [P1251 餐巾计划问题](https://www.luogu.com.cn/problem/P1251)
- [P2223 [HNOI2001] 软件开发](https://www.luogu.com.cn/problem/P2223)
- [P2917 [USACO08NOV] Toys G](https://www.luogu.com.cn/problem/P2917)
- [P4480 [BJWC2018] 餐巾计划问题](https://www.luogu.com.cn/problem/P4480)

# 题目思路

约定 $p$ 为干净餐巾价格，$m_1,m_2$ 为快洗慢洗所需要的天数，$c_1,c_2$ 为快洗慢洗一个的代价，$m_1\leq m_2,c_1\geq c_2$，不满足的话自己 swap 一下即可。

一个显然的性质是我们可以把要用的餐巾一次性买好。考虑如果我们知道了具体要买多少餐巾。设要买 $x$ 条，$f(x)$ 表示买了 $x$ 条餐巾最后的总花费。如果不够用为 $+\infty$。手玩几个找找规律~~或者是靠小学数学题告诉你的经验~~可以发现这是个单谷函数，有一个极点。显然我们要找出这个极点并且求出对应的函数值。

单谷函数，显然是需要三分的。那么这个 $f(x)$ 到底应该怎么算呢？

先思考，每天可以用的餐巾从哪里来？

1. 买来的新的没用完。

2. 快洗洗完的。

3. 慢洗洗完的。

之后会发现优先使用新的餐巾会更优，这个是先用的。

然后在可以的情况下优先使用较晚慢洗好的。慢洗全用完之后用较晚快洗好的。

优先使用较晚得到的餐巾，可以尝试让更早的餐巾去慢洗，最小化代价。

优先用慢洗可以尽量减少消费，和上面一个道理，可能能让快洗的餐巾去慢洗。

这时很显然这就是贪心的过程，~~因为这题是洛谷秋令营提高组贪心课后作业。~~

注意到我们需要从头放，从尾巴取，所以我们实现的时候可以使用双端队列模拟这一贪心过程，即使用 C++ 的 STL 容器 deque。

# 丑陋代码

[Luogu record 128374675](https://www.luogu.com.cn/record/128374675)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define upd1(a, b, c)                            \
    while (!a.empty() && a.front().day <= i - c) \
    {                                            \
        b.push_back(a.front());                  \
        a.pop_front();                           \
    }
#define upd2(a, b)                   \
    while (cnt > 0 && !a.empty())    \
    {                                \
        mn = min(cnt, a.back().cnt); \
        ret += mn * b;               \
        cnt -= mn;                   \
        if (!(a.back().cnt -= mn))   \
            a.pop_back();            \
    }
struct info
{
    int day, cnt;
};
int n, m1, m2, c1, c2, p;
deque<info> buy;
deque<info> fst;
deque<info> slw;
int a[200020];
int f(int k)
{
    buy.clear();
    fst.clear();
    slw.clear();
    int ret = k * p;
    for (int i = 1; i <= n; i++)
    {
        upd1(buy, fst, m1);
        upd1(fst, slw, m2);
        int cnt = a[i];
        int mn = min(cnt, k);
        cnt -= mn;
        k -= mn;
        upd2(slw, c2);
        upd2(fst, c1);
        if (cnt > 0)
            return INT_MAX;
        buy.push_back({i, a[i]});
    }
    return ret;
}
int main()
{
    cin >> n >> m1 >> m2 >> c1 >> c2 >> p;
    if (m1 > m2)
        swap(m1, m2), swap(c1, c2);
    if (c1 < c2)
        m2 = m1, c2 = c1;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int l = 0, r = accumulate(a + 1, a + n + 1, 0);
    while (l <= r)
    {
        int ml = l + (r - l) / 3;
        int mr = r - (r - l) / 3;
        int vl = f(ml), vr = f(mr);
        if (vl >= vr)
            l = ml + 1;
        else
            r = mr - 1;
    }
    cout << min(f(l), f(r)) << endl;
    return 0;
}
```



---


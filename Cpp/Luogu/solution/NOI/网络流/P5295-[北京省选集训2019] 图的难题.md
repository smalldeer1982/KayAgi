# [北京省选集训2019] 图的难题

## 题目背景

标题是假的。

## 题目描述

小 D 在图论习题书上遇到了一个问题：

书上画出了一张无向图，要求把边染成黑白两色，要求所有白色边构成的子图没有环，且所有黑色边构成的子图没有环。

小 D 无论怎样尝试都觉得书上的问题没有解，她想请你帮她确认一下。

由于这道题有很多小问，小 D 每次会给你图的点数 $n$、边数 $m$ 与所有边集，你只需要告诉小 D 有没有解即可。

## 说明/提示

### 数据范围：  

对于 $20\%$ 的数据：$1\le m \le 10$。

对于 $40\%$ 的数据：$1\le n \le 15$。

对于 $70\%$ 的数据：$1\le n \le 50$。

对于 $100\%$ 的数据：$1\le n \le 501$，$1\le m \le 2n$，$1\le T \le 10$。

## 样例 #1

### 输入

```
3
3 3
1 2
1 3
2 3
2 3
1 2
1 2
1 2
4 6
1 2
1 3
2 4
1 3
2 3
3 4```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：_sys (赞：5)

给定一张图，你需要选出一个子集，使得这个子集没有环，子集的补集没有环。

$T \leq 10$，$n \leq 500$，$m \leq 10^3$。

***


一张图是合法的当且仅当其所有导出子图 $(V, E)$ 满足 $|E| \leq 2|V|-2$。

必要性显然。充分性考虑归纳法。我们通过点数为 $|V|-1$ 的图成立推出点数为 $|V|$ 的成立。

设 $d(u)$ 表示 $u$ 的度数，我们取 $d$ 最小的一个作为我们加入的点 $u$。

那么 $1 \leq d(u) \leq 3$。否则 $\sum d=4|V|$，$|E|=2|V|$，不满足条件。

若 $d(u) \leq 2$，我们设相邻的点为 $v_1, v_2$，把 $(v_1, u)$ 加入第一个森林，$(v_2, u)$ 加入第二个森林，仍然满足性质。

若 $d(u)=3$，设相邻的点为 $v_1, v_2, v_3$。那么去掉 $u$ 及其邻边的所有图 $G$ 满足 $|E|<2|V|-2$。

我们考虑三个导出子图 $H_1(E_1, V_1)$, $H_2(E_2, V_2)$, $H_3(E_3, V_3)$，$H_1$ 不包含 $(u, v_1)$ 但包含 $v_2, v_3$，$H_2$ 不包含 $(u, v_2)$ 但包含 $v_1, v_3$，$H_3$ 不包含 $(u, v_3)$ 但包含 $v_1, v_2$。这样的 $H_1, H_2, H_3$ 有很多种。但**至少有一个** $i$ **满足不存在** $H_i$ **使得** $|E_i|=2|V_i|-2$。

引理：若 $G_1(E_1, V_1), G_2(E_2, V_2)$ 满足 $|E_1|=2|V_1|-2, |E_2|=2|V_2|-2$，则 $G_1 \cap G_2(E'_1, V'_1), G_1 \cup G_2(E'_2, V'_2)$ 满足 $|E_1'|=2|V_1'|-2, |E_2'|=2|V_2'|-2$。因为交 + 并 = 和，假如一个没达到上界，另一个就要超过上界。

使用反证法，若三个 $H$ 都能达到上界，那他们的并也达到了上界，而他们的并，就是 $G$。矛盾。

那么假设 $H_1$ 达不到上界，那么我们在 $H_1$ 中加入一条边 $(v_2, v_3)$，这样 $H'_1$ 也是合法的。

于是我们考虑这样一张图：在 $(V, E)$ 的基础上，除去 $u$ 的出边，加入 $(v_2, v_3)$，根据归纳假设，它能够分成两个森林。

我们设第一个森林包含了 $(v_2, v_3)$，那么我们把这条边删去，加入 $(u, v_2), (u, v_3)$，它还是一个森林。第二个森林加入 $(u, v_1)$，它还是一个森林。

原命题得证。

也就是说，我们只用判断这张图是否满足对于所有的子图满足 $|E| \leq 2|V|-2$。

也就是说，$\max\{|E|-2|V|\} \leq -2$。

这是一个最大权闭合子图的模型。考虑一条边的权值为 $1$，一个点的权值为 $-2$，我们要求的是最大权闭合子图。

**但是有一个问题**！这个子图必须非空，因为空的图被判定为不合法了。

所以我们钦定一个点一定被选，把它在网络流中的点删去，最后把答案直接 $-2$ 即可。

这样的复杂度是 $O(nm \sqrt n)$ 的。

（好像这样就能过了，但是 uoj 那题就过不了）

考虑优化，发现每次是删一条边后的最大流。使用退流即可。

时间复杂度：$O(nm)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int Maxn = 12005;
int T, n, m, ct, cnt, s, t, ans, cur[Maxn], dis[Maxn], head[Maxn];
struct edg
{
	int nxt, to, w;
} edge[10 * Maxn];
void add(int x, int y, int w)
{
	edge[++cnt] = (edg){head[x], y, w};
	head[x] = cnt;
	edge[++cnt] = (edg){head[y], x, 0};
	head[y] = cnt;
}
queue <int> Qu;
bool bfs(void)
{
	Qu.push(s);
	memset(dis, 0, sizeof(int[ct + 1]));
	while (!Qu.empty())
	{
		int u = Qu.front();
		Qu.pop();
		if (u == t)
		{
			while (!Qu.empty()) Qu.pop();
			return true;
		}
		for (int i = head[u]; i; i = edge[i].nxt)
		{
			int to = edge[i].to;
			if (to != s && !dis[to] && edge[i].w) dis[to] = dis[u] + 1, Qu.push(to);
		}
	}
	return false;
}
int dfs(int u, int mini)
{
	if (u == t || !mini) return mini;
	int w, used = 0;
	for (int & i = cur[u]; i; i = edge[i].nxt)
	{
		int to = edge[i].to;
		if (dis[to] == dis[u] + 1 && edge[i].w)
		{
			w = dfs(to, min(mini - used, edge[i].w));
			edge[i].w -= w, edge[((i - 1) ^ 1) + 1].w += w, used += w;
			if (used == mini) return used;
		}
	}
	return used;
}
void dinic(int w)
{
	while (bfs())
	{
		memcpy(cur, head, sizeof(int[ct + 1]));
		ans += w * dfs(s, 0x3f3f3f3f);
	}
}
int main()
{
	scanf("%d", &T);
	while (T--)
	{
		cnt = ans = 0;
		memset(head, 0, sizeof(int[ct + 1]));
		scanf("%d%d", &n, &m);
		ct = n;
		s = ++ct, t = ++ct;
		for (int i = 1; i <= n; i++)
			add(i, t, 2);
		for (int i = 1; i <= m; i++)
		{
			int x, y;
			scanf("%d%d", &x, &y);
			++ct;
			add(s, ct, 1);
			add(ct, x, 0x3f3f3f3f), add(ct, y, 0x3f3f3f3f);
		}
		dinic(1);
		for (int i = 1; i <= 2 * n; i += 2)
		{
			s = (i + 1) / 2, t = n + 1, dinic(-1);
			edge[i].w = 0;
			s = n + 1, t = n + 2, dinic(1);
			if (m - ans >= 1)
			{
				puts("No");
				goto END;
			}
			edge[i].w = 2;
		}
		puts("Yes");
		END:;
	}
	return 0;
}
```

---

## 作者：Mine_King (赞：4)

## Problem

[P5295 [北京省选集训2019] 图的难题](https://www.luogu.com.cn/problem/P5295)

**题目大意：**

给你一张无向图，判断是否存在一种边的黑白染色方案，使得白边无环，黑边也无环。

## Solution

结论：一张图合法当且仅当其任意导出子图 $(V', E')$ 满足 $|E'| \le 2|V'| - 2$。

必要性显然，下面证明充分性：

考虑归纳，对于所有 $|V| = 1$ 的图显然成立。  
对于 $|V| > 1$ 的图，假设结论对于所有点数小于 $|V|$ 的图都成立。  
取出度数最小的点，设其为 $u$，则 $u$ 的度数 $\le 3$，否则若 $u$ 的度数 $\ge 4$，则总度数 $\ge 4|V|$，$|E| \ge 2|V|$。

设删掉 $u$ 及与其相连的边后的图为 $G' = (V', E')$。

若 $u$ 的度数为 $1$，设与之相连的点为 $v$，则构造出 $G'$ 的方案，然后将 $(u, v)$ 染成任意一种颜色即可。

若 $u$ 的度数为 $2$，设与之相连的点为 $v _ 1, v _ 2$，则构造出 $G'$ 的方案，然后将 $(u, v _ 1)$ 和 $(u, v _ 2)$ 染成不同颜色即可。

若 $u$ 的度数为 $3$，设与之相连的点为 $v _ 1, v _ 2, v _ 3$。

定义一张图 $G = (V, E)$ 是满的当且仅当其满足 $|E| = 2|V| - 2$。

> 引理 1：对于一张满足条件的图中任意两张满的子图 $G _ 1 = (V _ 1, E _ 1), G _ 2 = (V _ 2, E _ 2)$，$G _ 1 \cup G _ 2$ 也是满的。

证明考虑设 $G _ 3 = G _ 1 \cup G _ 2, G _ 4 = G _ 1 \cap G _ 2$，则

$$
|E _ 3| = |E _ 1| + |E _ 2| - |E _ 4| = 2|V _ 1| + 2|V _ 2| - |E _ 4| - 4 \\
|V _ 3| = |V _ 1| + |V _ 2| - |V _ 4|
$$

所以 $|E _ 3| - 2|V _ 3| = 2|V _ 4| - |E _ 4| - 4 \ge -2$，即 $|E _ 3| \ge 2|V _ 3| - 2$，又因为 $|E _ 3| \le 2|V _ 3| - 2$，所以 $|E _ 3| = 2|V _ 3| - 2$。

> 引理 2：$v _ 1, v _ 2, v _ 3$ 中一定存在两个点 $x, y$，满足 $G'$ 中不存在同时包含 $x, y$ 的满子图。

考虑反证，如果存在三张满子图分别包含 $(v _ 1, v _ 2), (v _ 1, v _ 3), (v _ 2, v _ 3)$，则把它们并起来还是满子图。再添加 $(u, v _ 1), (u, v _ 2), (u, v _ 3)$ 三条边，此时 $|E| = 2|V| - 1$，矛盾。

于是我们可以找到的 $x, y$，然后将边 $(x, y)$ 添加进 $G'$ 中，此时新图仍然满足条件，求出一种方案，然后将 $(u, x), (u, y)$ 染成 $(x, y)$ 的颜色，将另一条边染成另一种颜色，删去 $(x, y)$ 即可得到一种合法方案。

因此问题转化为求一张子图，使得 $|E| - 2|V|$ 最大，然后判断其是否 $\ge -2$ 即可。

我们对于没条边建一个点，连向其两个顶点，将边的权值设成 $1$，点的权值设成 $-2$，就转化成了最大权闭合子图。

问题是直接跑会寄，因为选空集的答案是 $0$。所以我们枚举每个点，钦定它必须选，也就是将其权值设成 $0$ 即可。这样复杂度为 $O(Tnm\sqrt{n})$。

已经足以通过这道题了，但是无法通过加强版 [UR #11 元旦老人与丛林](https://uoj.ac/problem/168)。

我们发现从钦定一个点到钦定另一个点只会改变两条边的流量，于是使用退流技巧即可通过。

## Code

```cpp
// 願ったんなら叶えてしまえやって
// Think twice, code once.
#include <queue>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eputchar(c) putc(c, stderr)
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define eputs(str) fputs(str, stderr), putc('\n', stderr)
using namespace std;

struct Dinic {
	int s, t, dis[1605], cur[1605];
	struct graph {
		int tot, hd[1605];
		int nxt[8005], to[8005], flw[8005];

		void clear() {tot = 1; memset(hd, 0, sizeof(hd)); return ;}
		void add(int u, int v, int f) {
			nxt[++tot] = hd[u];
			hd[u] = tot;
			to[tot] = v;
			flw[tot] = f;
			return ;
		}
	} g;

	void add_edge(int u, int v, int f) {g.add(u, v, f), g.add(v, u, 0); return ;}
	int bfs() {
		queue<int> q;
		memset(dis, -1, sizeof(dis));
		dis[s] = 0;
		q.push(s);
		while (!q.empty()) {
			int now = q.front();
			q.pop();
			cur[now] = g.hd[now];
			for (int i = g.hd[now]; i; i = g.nxt[i])
				if (g.flw[i] && dis[g.to[i]] == -1) dis[g.to[i]] = dis[now] + 1, q.push(g.to[i]);
		}
		return dis[t] != -1;
	}
	int dinic(int now, int flow) {
		if (now == t) return flow;
		int used = 0;
		for (int i = cur[now]; i && used < flow; i = g.nxt[i])
			if (g.flw[i] && dis[g.to[i]] == dis[now] + 1) {
				int f = dinic(g.to[i], min(flow - used, g.flw[i]));
				g.flw[i] -= f, g.flw[i ^ 1] += f;
				used += f;
				cur[now] = i;
			}
		if (!used) dis[now] = -1;
		return used;
	}
	int solve() {
		int ans = 0;
		while (bfs()) ans += dinic(s, 0x3f3f3f3f);
		return ans;
	}
} f;
int T, n, m, res;

int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d%d", &n, &m);
		f.g.clear();
		f.s = 0, f.t = n + m + 1;
		f.add_edge(1, f.t, 0);
		for (int i = 2; i <= n; i++) f.add_edge(i, f.t, 2);
		for (int i = 1; i <= m; i++) {
			int u, v;
			scanf("%d%d", &u, &v);
			f.add_edge(f.s, n + i, 1);
			f.add_edge(n + i, u, 0x3f3f3f3f);
			f.add_edge(n + i, v, 0x3f3f3f3f);
		}
		if ((res = f.solve()) < m) {puts("No"); continue;}
		for (int i = 2; i <= n; i++) {
			f.s = i, f.t = 0;
			f.solve();
			for (int j = f.g.hd[i]; j; j = f.g.nxt[j])
				if (f.g.to[j] == n + m + 1) res -= f.g.flw[j ^ 1], f.g.flw[j] = f.g.flw[j ^ 1] = 0;
			for (int j = f.g.hd[i - 1]; j; j = f.g.nxt[j])
				if (f.g.to[j] == n + m + 1) f.g.flw[j] = 2;
			f.s = 0, f.t = n + m + 1;
			if ((res += f.solve()) < m) {puts("No"); goto NXT;}
		}
		puts("Yes");
NXT:;
	}
	return 0;
}
```

---

## 作者：Drind (赞：2)

### 题目解析

给定一个 $n$ 点 $m$ 边无向图，要求给每条边染黑或白色，使得黑色边不形成环且白色边不形成环。你只需要判断是否存在合法染色方案。

我们猜测一个结论就是这个问题等价于这个图的任何一个导出子图均满足 $|E|\le 2|V|-2$，其中 $|E|$ 为边数，$|V|$ 为点数。不想看证明可以跳过下面一段。

### 证明

考虑证明，必要性易证，因为一张不存在环的无向图必定是一个森林，保证 $|E|\le |V|-1$，将黑白两张图叠加即可。

考虑证明充分性，即证明一张满足条件的无向图一定能构造出一个染色方案。我们找到一个度数最小的点，这个点的度数一定不为 $4$，否则 $|E|\ge2|V|$，图不合法。

若度数为 $1$，我们可以随便把这个边染一个色，显然不成环。若度数为 $2$，我们给两个边染不同颜色，显然不成环。若度数为 $3$，我们设这个点为 $u$，连出的三个点分别为 $a,b,c$。

我们记一张满图为满足条件且 $|E|=2|V|-2$ 的图。

引理 $1$：两个点相交的满图的并也是满的。
>我们设两张图分别为 $G_1=(V_1,E_1),G_2=(V_2,E_2)$，记他们的交为 $G_3=(V_3,E_3)$，因为他们的并合法，所以 $|E_1|+|E_2|-|E_3|\le 2(|V_1|+|V_2|-|V_3|)-2$，因为 $G_1,G_2$ 为满图，所以 $|E_1|+|E_2|\le 2(|V_1|+|V_2|)-4$，联立得 $|E_3|\ge 2|V_3|-2$，又因为交合法，所以 $|E_3|\le 2|V_3|-2$,即 $|E_3| = 2|V_3|-2$

引理 $2$：在 $a,b,c$ 中存在一个点对 $(x,y)$ 满足不同时包含在一个满图中。
>反证法。我们将包含 $(a,b),(a,c),(b,c)$ 的三个满图合并，根据引理 $1$，他们的并也是满图，然后我们把 $u$ 和连接 $u$ 的三条边加入图中，发现不符合条件($|E|=2|V|-1$)，和我们的假设不符。

我们开始构造方案，我们找到一个 $(x,y)$ 满足不被满图包含，然后将 $u$ 以及连接 $u$ 的三条边删除，添加一条新边 $x,y$，显然现在新的图符合条件，构造出新图方案后，将 $x,u$ 和 $y,u$ 加入包含 $x,y$ 的颜色中，剩下的一条边加入另一个颜色，显然无环。

### 求解

我们将边看做左部点，原图中的点看做右部点，边的权值为 $1$，点的权值为 $-2$。显然原图的导出子图为新图的闭合子图，且最大权闭合子图的权值大于 $-2$ 时不符合条件。

但是这样会跑出来一个权值为 $0$ 的闭合子图就是空图。所以我们每次钦定一个点，必须选中他（就是把他的权值赋成 $0$），然后再跑就行了。

但是这样是 $O(n^2\sqrt n)$ 的，过不去 uoj 的[#168. 【UR #11】元旦老人与丛林](https://uoj.ac/problem/168)，所以我们考虑优化。

因为每次换一个点钦定的时候只会改变这个点和上一个点的权值，我们考虑使用退流解决。

我们将目前钦定的点记做 $i$，我们要把这个点的流量退掉，就从 $i$ 到 $s$ 跑一次最大流，然后退掉这个点的流量，将上一个点的流量加回来，跑从 $s$ 到 $t$ 的最大流即可。

省略最大流板子代码如下
```cpp
void fake_main(){
	f.init();
	f.s=N-1,f.t=f.s-1;
	int n,m; cin>>n>>m; 
	f.adde(1,f.t,0);
	for(int i=2;i<=n;i++) f.adde(i,f.t,2);
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		f.adde(f.s,i+n,1);
		f.adde(i+n,u,inf);
		f.adde(i+n,v,inf);
	}
	int t=f.dinic();
	if(t<m){
		cout<<"No\n";
		return;
	}
	for(int i=2;i<=n;i++){
		f.s=i,f.t=N-1;
		f.dinic();
		for(int j=f.head[i];~j;j=f.edge[j].nxt){
			int v=f.edge[j].to;
			if(v==N-2){
				t-=f.edge[j^1].flow;
				f.edge[j].flow=f.edge[j^1].flow=0;
			}
		}
		for(int j=f.head[i-1];~j;j=f.edge[j].nxt){
			int v=f.edge[j].to;
			if(v==N-2){
				f.edge[j].flow=2;
			}
		}
		f.s=N-1; f.t=f.s-1; t+=f.dinic();
		if(t<m){
			cout<<"No\n";
			return;
		}
	}
	cout<<"Yes\n";
}

```

uoj 那题没有多测，注意一下。

---

## 作者：basince (赞：1)

**必要条件法**。

不难发现一个合法的图的必要条件是所有导出子图满足 $|E|\le 2|V|-2$。而他的充分性可以归纳证明。

那么现在我们相当于要求 $ans=\max(|E|-2|V|)$，看其是否 $\le -2$。

可以发现问题相当于点权为 $-2$，边权为 $1$，选了边则必选其端点，求最大权。这是一个最大权闭合子图问题。

但是如果啥都不选是非法的，且权为 $0$。我们可以枚举强制要选的一个点，然后每次都跑一遍网络流。由于图是二分图，所以时间复杂度 $O(nm\sqrt n)$。

实际上每次都重新跑一遍网络流很浪费，因为每次都只是相对于原网络删了一条边。我们可以运用**退流**的技巧，将一个点的流量退回源点，然后再断掉。实际操作起来假设我们要将点 $i$ 的流量退回，就跑一遍从 $i$ 到 $S$ 的网络流即可。

时间复杂度 $O(\sqrt nm+nm)$。

---

## 作者：happybob (赞：0)

记无向图 $G=(V,E)$，其点集 $S \subseteq V$ 的导出子图 $G_S=(V_S,E_S)$。

结论：无向图 $G$ 合法当且仅当对于任意非空集合 $S \subseteq V$，$|E_S|\leq 2|V_S|-2$。

必要性显然，这是因为森林边数最多只有 $|V_S|-1$ 条，两棵森林则至多 $2|V_S|-2$ 条。

考虑证明充分性：

我们尝试按照 $|V|$ 归纳证明。$|V|=1$ 时显然成立。

考虑 $|V| > 1$，令 $d_i$ 表示点 $i$ 在图 $G$ 中的度数，考虑取出 $i$ 为 $d_i$ 最小的任意一个 $i$。

不难发现 $d_i \leq 3$，原因是若 $d_i \geq 4$，则 $|E| \geq \dfrac{|V|d_i}{2} \geq 2|V|$，与 $|E| \leq 2|V|-2$ 矛盾。

记 $G'=(V',E')$ 为删去点 $i$ 与其相邻边得到的图，根据归纳假设，$G'$ 符合原命题且存在解。

若 $d_i = 0$，显然符合要求。

若 $d_i = 1$ 或 $d_i = 2$，由于 $G'$ 存在解，将至多两条边分给两棵森林即可。

考虑 $d_i = 3$。

称一个点集 $S$ 为坏的当且仅当 $|E_S|=2|V_S|-2$。

对于任意一个满足原命题的图 $G$，考虑其两个坏的点子集 $S,T$ 满足 $S \cap T \neq \varnothing$，则 $S \cup T$ 也是坏的。

证明：

考虑 $|E_{S\cup T}| = |E_S| + |E_T| - |E_{S \cap T}| = 2|V_S|-2+2|V_T|-2-|E_{S\cap T}| = 2(|V_{S}|+|V_T|)-|E_{S \cap T}| - 4$。

又有 $|V_{S \cup T}| = |V_S|+|V_T|-|V_{S \cap T}|$。

由于 $S \cap T \neq \varnothing$，所以 $|E_{S \cap T}| \leq 2|V_{S \cap T}| - 2$。

所以 $|E_{S\cup T}| \geq 2(|V_{S}|+|V_T|)-2|V_{S \cap T}| - 2=2|V_{S \cup T}| - 2$。

由于 $G$ 符合结论，故 $|E_{S\cup T}| \leq 2|V_{S \cup T}| - 2$。

综上，$|E_{S\cup T}| = 2|V_{S \cup T}| - 2$。

考虑用此引理证明原命题。

$d_i = 3$ 时，设其三个邻居分别为 $x,y,z$。

则不存在三个非空坏集合 $A,B,C \subseteq G'$ 满足 $x,y \in A$，$y,z \in B$，$x,z \in C$，反之，则任意两个集合交集非空，所以 $A \cup B \cup C$ 为坏集合，而 $A \cup B \cup C \subseteq G'$，与归纳假设矛盾。

不妨假设不存在坏集合 $A$ 使得 $x,y \in A$，则在 $G'$ 中加入边 $(x,y)$ 得到 $G''$，$G''$ 仍符合原命题并存在解，将 $(i,x),(i,y)$ 两条边划分给 $G''$ 中 $(x,y)$ 边所分配的颜色，将 $(i,z)$ 分配给另一种颜色即可。

证毕。

考虑原题如何进行判定，则我们要求一个集合 $S \neq \varnothing \subset V$ 使得 $|E_S|-2|V_S|$ 最大。

考虑对每条边 $(u,v)$ 新增一个点 $x$，连边 $x \rightarrow u$，$x \rightarrow v$，将 $x$ 点权设置为 $1$，将原图点的点权设置为 $-2$，即求最大权非空闭合子图。

直接跑最大权闭合子图显然不对，因为会跑出空集。枚举一个原图点 $i$ 并钦定其必选然后跑即可做到 $O(n^2\sqrt n)$。

进一步，考虑钦定 $i$ 本质就是删去一条 $i \rightarrow T$ 的边，那么直接用退流技巧，从 $i$ 向 $S$ 跑最大流即可。复杂度 $O(n^2)$。

---


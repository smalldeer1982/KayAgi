# 封锁

## 题目背景

震惊！zbw 竟从 B 城监狱逃出！

作为 B 城的警察局长，你必须在 zbw 逃出你的管辖范围之前抓住他。

## 题目描述

B 城可视为一个 $n \times n$ 的方阵，其中监狱在 $(1,1)$，B 城唯一出城的出口在 $(n,n)$。每两个相邻的点（横坐标之差的绝对值 $+$ 纵坐标之间的绝对值 $=1$）之间都有一条**无向的**道路（没有斜着的道路）。你需要在一些道路上部下防守，使得无论 zbw 怎么走，都至少会经过其中的一条道路。

在一条 $(i,j)$ 到 $(i,j+1)$ 的道路上部下防守的花费是 $r_{i,j}$，在一条 $(i,j)$ 到 $(i+1,j)$ 的道路上部下防守的花费是 $d_{i,j}$，同时，在道路上部下防守会对人民的生活造成影响，在一条 $(i,j)$ 到 $(i,j+1)$ 的道路上部下防守对人民的生活造成的影响是 $x_{i,j}$，在一条 $(i,j)$ 到 $(i+1,j)$ 的道路上部下防守对人民的生活造成的影响是 $y_{i,j}$。

定义总花费为 $w$ ，总影响为 $e$ ，作为一名优秀的警察局长，你需要最小化 $w \times e$。 

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/bjd62iba.png)

如图，左上角为 $(1,1)$，右下角为 $(n,n)$，
其中蓝色数字表示 $r$,
红色数字表示 $x$,
黄色数字表示 $d$,
绿色数字表示 $y$。

最优方案为防守三条边，分别为：

$(2,2)-(2,3),(3,1)-(3,2),(3,2)-(3,3)$

三条边的边权分别是 $2,3$---$1,1$ ---$4,3$

答案为 $(1+2+4)\times (1+3+3)=49$


可以发现没有更优的做法。

**本题采用捆绑测试。**

|  Subtasks| $n$ |特殊性质  |分数
| :----------: | :----------: | :----------: |:----------: |
|  Subtask1| $n=2$ |无  |$5$
|  Subtask2| $n\leq400$ |数据随机  |$15$
|  Subtask3| $n\leq10$ |  无|$15$
|  Subtask4| $n\leq50$ | 无 |$30$
|  Subtask5| $n\leq400$ | 无 |$35$

对于所有数据 $1 \leq n \leq 400$，$0 \leq r_{i,j}, d_{i,j},x_{i,j} ,y_{i,j}  \leq 10^3$。

数据于2020/3/4加强，卡掉部分复杂度错误的做法。

## 样例 #1

### 输入

```
3
8 3
5 2
1 1
4 2
1 2
7 5
7 2
6 1
5 4
2 3
1 4 
4 3```

### 输出

```
49```

# 题解

## 作者：feecle6418 (赞：7)

最小乘积模型。这里不再讲解基础知识，请移步“最小乘积生成树”题解区查看。

~~为什么会被拒？？？那我就讲一下基础知识吧。。。。难道不接受只说坑点的题解了吗。。~~

将每个割的 $a,b$ 值之和看成点 $(sum_a,sum_b)$，则 $sum_asum_b$ 最小的点一定在下凸壳上。

首先找到 $sum_a$ 最小的与 $sum_b$ 最小的两个点 $A,B$，显然这两个点是凸壳的端点。接着找到距离直线 $AB$ 最远并且在 $AB$ 下方的 $C$，显然这个点也在下凸壳上。当不存在这个 $C$ 时算法结束，否则以 $(A,C),(C,B)$ 分别递归调用。

可是怎么找距离最远的 $C$？使用面积法，相当于 $\triangle ABC$ 面积最大，即 $\vec{AB} \times \vec{AC}$ 最小。拆开式子相当于 

![](https://cdn.luogu.com.cn/upload/image_hosting/210fm5bo.png)

最小，即 $(x_B-x_A)y_C+(y_A-y_B)x_C$ 最小，以这个为边权跑最小割即可。

---

出题人没有写网络流，我来提供一个网络流的代码。

注意：

1. 请根据图的形状选择网络流算法。本题增广路众多，显然用 Dinic 会远快于其他算法。
2. 一定要加当前弧优化。
3. 注意每次清空。
4. 如何找出最小割的边？从 S 和 T 分别 DFS，假如存在一条边，一个端点只能被 S 遍历，另一个端点只能被 T 遍历，则这条边在割中.
6. 开 long long。
7. 在递归时会出现每条边的权值都为 $0$ 的情况，此时最大流算法不能正常工作。权值的真正意义，表示的是这条边在答案中占的比重。每条边的权值都为 $0$ 的真正意义是每条边的权重相同，只需将所有 $0$ 边的流量赋值为一个相同的较大的数即可。这里我选取的是 $10^6$。

代码如下，需要者可自取。

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
#define int long long
struct Point {
	int x,y;
};
int operator *(Point x,Point y) {
	return x.x*y.y-x.y*y.x;
}
Point operator +(Point x,Point y) {
	return {x.x+y.x,x.y+y.y};
}
Point operator -(Point x,Point y) {
	return {x.x-y.x,x.y-y.y};
}
struct Triple {
	int x,y,z;
};
struct E {
	int from,to,a,b;
} ee[320005];
int tot,w[320005];
namespace NetWorkFlow {
	int S,T,N,dis[160005],h[160005],cnt,cur[160005],vst[160005],qq[160005],L,R;
	struct Edge {
		int to,next,flow;
	} e[1000005];
	void Add_Edge(int x,int y,int z) {
		e[++cnt]= {y,h[x],z};
		h[x]=cnt;
		e[++cnt]= {x,h[y],z};
		h[y]=cnt;
		//cout<<x<<' '<<y<<' '<<z<<endl;
	}
	bool BFS() {
		memset(dis,-1,sizeof(dis));
		dis[S]=0;
		L=1,R=0;
		qq[++R]=S;
		while(L<=R) {
			int now=qq[L++];
			if(now==T)return 1;
			for(int i=h[now]; i; i=e[i].next) {
				if(dis[e[i].to]==-1&&e[i].flow) {
					dis[e[i].to]=dis[now]+1;
					qq[++R]=e[i].to;
				}
			}
		}
		return 0;
	}
	int DFS(int point,int flow,int t) {
		int ret=0,delta;
		if(point==t||!flow)return flow;
		for(int &i=cur[point]; i; i=e[i].next) {
			if(e[i].flow&&dis[e[i].to]==dis[point]+1) {
				delta=DFS(e[i].to,min(e[i].flow,flow),t);
				if(!delta)dis[e[i].to]=-1;
				e[i].flow-=delta;
				e[i^1].flow+=delta;
				ret+=delta,flow-=delta;
				if(!flow)return ret;
			}
		}
		return ret;
	}
	int Dinic(int s,int t) {
		int ans=0;
		while(BFS())memcpy(cur,h,sizeof(h)),ans+=DFS(s,inf,t)/*,cout<<ans<<'\n'*/;
		return ans;
	}
	void DFS(int x,int y) {
		vst[x]=y;
		//cout<<x<<' '<<y<<endl;
		for(int i=h[x]; i; i=e[i].next) {
			if(e[i].flow&&!vst[e[i].to])DFS(e[i].to,y);
		}
	}
	Point MaxFlow(int SS,int TT,int nn) {
		cnt=1,S=SS,T=TT,N=nn;
		memset(h,0,sizeof(h));
		for(int i=1; i<=tot; i++)Add_Edge(ee[i].from,ee[i].to,w[i]);
		Dinic(S,T);
		memset(vst,0,sizeof(vst));
		DFS(S,1);
		DFS(T,2);
		Point r= {0,0};
		for(int i=1; i<=tot; i++) {
			if(vst[ee[i].from]==1&&vst[ee[i].to]==2)r=r+(Point) {ee[i].a,ee[i].b};
		}
		return r;
	}
}
int ans=1e18,n;
int pos(int a,int b) {
	return (a-1)*n+b;
}
Point XXJ() {
	Point r=NetWorkFlow::MaxFlow(pos(1,1),pos(n,n),pos(n,n));
	ans=min(ans,r.x*r.y);
	return r;
}
void Calc(Point A,Point B) {
	for(int i=1; i<=tot; i++)w[i]=ee[i].a*(A.y-B.y)-ee[i].b*(A.x-B.x);
	for(int i=1; i<=tot; i++)if(!w[i])w[i]=1e6;
	Point C=XXJ();
	//cout<<C.x<<' '<<C.y<<endl;
	if((B-A)*(C-A)>=0)return ;
	Calc(A,C),Calc(C,B);
}
signed main() {
//	freopen("1.in","r",stdin);
	ans=1e9,cin>>n;
	for(int i=1,a,b; i<=n*(n-1); i++) {
		scanf("%lld%lld",&a,&b);
		int x=(i-1)/n+1,y=(i-1)%n+1;
		ee[++tot]= {pos(x,y),pos(x+1,y),a,b},w[tot]=a;
	}
	for(int i=1,a,b; i<=n*(n-1); i++) {
		scanf("%lld%lld",&a,&b);
		int x=(i-1)/(n-1)+1,y=(i-1)%(n-1)+1;
		//cout<<pos(x,y)<<' '<<pos(x,y+1)<<' '<<a<<' '<<b<<endl;
		ee[++tot]= {pos(x,y),pos(x,y+1),a,b},w[tot]=a;
	}
	Point A=XXJ();
	for(int i=1; i<=tot; i++)w[i]=ee[i].b;
	Point B=XXJ();
	//cout<<"PP "<<A.x<<' '<<A.y<<' '<<B.x<<' '<<B.y<<endl;
	Calc(A,B);
	cout<<ans<<endl;
}
```

---

## 作者：Lyrella (赞：5)

# 前言

这道题需要你会**最小乘积模型**，但是此篇题解不会进行非常详细的讲解，不会的话建议去看[我的博客](https://www.cnblogs.com/Lyrella/p/18909196)了解一下。

# 题解

首先这道题需要我们求一个割，这是显然的。但是这并不是一个普通的最小割，题目中有两维的限制让我们难以直接处理。面对这种需要最小化两种元素乘积的题目我们能想到最小乘积模型。这里大概讲一下。

首先我们将题目中的花费当成 $x$，影响当成 $y$。我们把每一种不同的割抽象成平面上的一个点 $(x,y)$。现在我们要求 $x\times y$ 的最小值就可以转化成我们在平面上找一个点满足**这个点所在的反比例函数的 $k$ 最小**。

考虑如何去找目标点，考虑目标点一定在这些割对应的点组成的下凸壳上，这是显然的。于是我们的思路就是将下凸壳上的点计算并更新答案。

考虑我们怎么去找下凸壳上的点？首先我们能够找到两个点，分别是只满足 $x$ 最小的点 $A$ 和只满足 $y$ 最小的点 $B$。这两个点一个的横坐标最小，另一个纵坐标最小。我们从这两个点入手。

我们有了两个点 $A,B$，考虑在直线 $AB$ 下方找一个点 $C$ 使得 $S_{\triangle ABC}$ 最大，这个点 $C$ 显然一定在下凸壳上。我们计算 $C$ 处的答案然后递归到两边更新答案即可。

现在我们的目标是找到点 $C$。考虑找一个点 $C$ 使得 $S_{\triangle ABC}$ 最大，也就是 $\overrightarrow{AB}\times\overrightarrow{AC}$ 最小（因为其值为负），所以我们现在暴力拆掉叉积，有：

$$
\begin{aligned}
\overrightarrow{AB}\times\overrightarrow{AC}&=(x_B-x_A)(y_C-y_A)-(y_B-y_A)(x_C-x_A)\\
&=(y_A-y_B)x_C+(x_B-x_A)y_C-x_By_A+y_Bx_A
\end{aligned}
$$

因为后面两项都是定值所以我们需要找前两项的最小值，于是我们在求最小割的时候把流量设为 $(y_A-y_B)w_i+(x_B-x_A)e_i$ 即可。

于是这道题就这么水灵灵地过啦，时间复杂度是网络流的复杂度乘上下凸壳上点的数量。具体复杂度笔者不是很会证，个人感觉玄学，反正是 $O(\text{能过})$ 就对了。

# 代码

写的时候就是一个网络流板子加上分治下凸壳的函数。注意每次跑网络流前清空一些数组。代码细节较少，故不放代码。

---

## 作者：gyh20 (赞：5)

$Subtask1$

直接判断即可，只有 $4$ 种删法。

$Subtask2$

因为本题有很多特殊性，所以乱搞的正确率很高，这里就给了一些类似于贪心的做法一些部分分，比如只满足 $\sum a_i$ 最小之类的做法

$Subtask3$

枚举割的地方，找最小答案即可。

$Subtask4$

前置知识:最小割 $=$ 最大流，网络流最大流。

虽然说求法是用最大流，但本质是最小割，这里就要用到一个很不常用的模型，最小乘积模型(如果没学过可以看看[这道题](https://www.luogu.com.cn/problem/P5540))

总体思想就是找一个函数的最值点，而 $x$ 坐标和 $y$ 坐标代表的是一个决策中 $\sum a$ 和 $\sum b$。

也就是说，如果存在一个比其他某两个决策更优的话，那么它一定在这两个点的连线的下方,我们需要通过给边重新赋值使得它在这两个点下方且距离最大，假如已知两个点 $A,B$，就要找到一个点 $C$ 使得 $C$ 在 $AB$ 下方且距离最大，即$S\triangle ABC$最大，使用向量叉积,$S\triangle ABC=-(AB\times AC)/2$。

推一推式子，得到
$AB\times AC=(x_B-x_A)y_C+(y_A-y_B)x_C-(x_B-x_A)y_A+(y_B-y_A)x_A$

最小化前两项即可，每次调用最大流求出比 $A,B$ 更优的点 $C$，递归求出比 $A,C $ 更优，$B,C$ 更优的点即可。

可以发现求最大流的次数是所有决策点构成的凸包上的点数，期望好像是 $n\log n$的(差不多)。复杂度$O(n^7\log n)$(网络流复杂度很玄，可过)

$Subtask5$

回归本题，这个城市的边是很特殊的，我们可以使用平面图最小割。

感性理解:

![](https://cdn.luogu.com.cn/upload/image_hosting/bjd62iba.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

每一种割法都对应一种从右或上到左或下的一条路径(将 $(1,1)$ 和 $(n,n)$ 割开)

![](https://cdn.luogu.com.cn/upload/image_hosting/vqrvp60h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这就是样例的割法。

将网格转为了路径，果断放弃网络流，改用更快的 $Dijkstra$ 最短路径算法。

建立源点，向最右和最上的网格连边，每个网格向旁边的格子连边，最左和最下的点向汇点连边，求最短路即可。

总复杂度 $O(n^3\log^3n)=O($可过$)$，复杂度很玄学，能过。

其实很模板:

```cpp

#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<iostream>
#define re 
#define int long long
#define ll long long
using namespace std;
int read(){
	re int t=0;
	re char v=getchar();
	while(v<'0'&&v<='9')v=getchar();
	while(v>='0'&&v<='9'){
		t=(t<<3)+(t<<1)+v-48;
		v=getchar(); 
	}
	return t;
}
int n,m;
struct pnt{
	int x,y;
}ans; 
struct vec{
	int sx,sy,tx,ty;
};
inline int cj(re pnt A,re pnt B){
	return A.x*B.y-A.y*B.x;
}
struct edge{
	int to,next,w,x,y;
}e[5000003];
int cnt,head[2500003],s,t;
void add(re int x,re int y,re int z,re int a,re int b){
	e[++cnt].to=y;
	e[cnt].w=z;
	e[cnt].next=head[x];
	head[x]=cnt;
	e[cnt].x=a;
	e[cnt].y=b;
}
struct aaa{
    int pos;
    int dis;
    pnt x;
    bool operator <(const aaa x)const{
        return dis>x.dis;
    }
}h[2500003];
priority_queue <aaa> q;
ll M(re ll x,re ll y){
    return (x<y)?(x):(y);
}
pnt dis(re int s){
	for(re int i=0;i<=t;++i)h[i].dis=1e9,h[i].x.x=h[i].x.y=0,h[i].pos=i;
    h[s].dis=0;
    q.push(h[s]);
    while(!q.empty()){
        aaa tmp=q.top();
        q.pop();
        for(re int i=head[tmp.pos];i;i=e[i].next){
            if((tmp.dis+e[i].w)<h[e[i].to].dis){
                h[e[i].to].dis=tmp.dis+e[i].w;
                h[e[i].to].x.x=h[tmp.pos].x.x+e[i].x;
                h[e[i].to].x.y=h[tmp.pos].x.y+e[i].y; 
                q.push(h[e[i].to]);
            }
        }
     }
    
     if(h[t].x.x*h[t].x.y<ans.x*ans.y)ans=h[t].x;
     return h[t].x;
}int f[503][503],f1[503][503],g[503][503],g1[503][503];
void div(re pnt A,re pnt B){
	cnt=0;
	memset(head,0,sizeof(head));
	for(re int i=1;i<n;++i){
		for(re int j=1;j<n;++j){
			int pos=(i-1)*(n-1)+j;
			if(j!=n-1){
				add(pos,pos+1,f[i][j+1]*(A.y-B.y)+f1[i][j+1]*(B.x-A.x),f[i][j+1],f1[i][j+1]);
				add(pos+1,pos,f[i][j+1]*(A.y-B.y)+f1[i][j+1]*(B.x-A.x),f[i][j+1],f1[i][j+1]);
			} 
			if(i!=n-1){
				add(pos,pos+n-1,g[i+1][j]*(A.y-B.y)+g1[i+1][j]*(B.x-A.x),g[i+1][j],g1[i+1][j]);
				add(pos+n-1,pos,g[i+1][j]*(A.y-B.y)+g1[i+1][j]*(B.x-A.x),g[i+1][j],g1[i+1][j]);
			}
		}
	}
	for(re int i=1;i<n;++i){
		add(s,i,g[1][i]*(A.y-B.y)+g1[1][i]*(B.x-A.x),g[1][i],g1[1][i]);
		add(i+(n-1)*(n-2),t,g[n][i]*(A.y-B.y)+g1[n][i]*(B.x-A.x),g[n][i],g1[n][i]);
		add((i-1)*(n-1)+1,t,f[i][1]*(A.y-B.y)+f1[i][1]*(B.x-A.x),f[i][1],f1[i][1]);
		add(s,(i-1)*(n-1)+n-1,f[i][n]*(A.y-B.y)+f1[i][n]*(B.x-A.x),f[i][n],f1[i][n]);
	}
	pnt C=dis(s);
	if(cj(pnt{B.x-A.x,B.y-A.y},pnt{C.x-A.x,C.y-A.y})>=0)return;
	div(A,C);div(C,B); 
	}

signed main(){
	ans.x=1e9;
	ans.y=1e9;
	n=read();
	s=0;
	t=(n-1)*(n-1)+2;
	for(re int i=1;i<n;++i){
		for(re int j=1;j<=n;++j)
		f[i][j]=read(),f1[i][j]=read();
	}
	for(re int i=1;i<=n;++i){
		for(re int j=1;j<n;++j)
		g[i][j]=read(),g1[i][j]=read();
	}
	cnt=0;
	memset(head,0,sizeof(head));
	for(re int i=1;i<n;++i){
		for(re int j=1;j<n;++j){
			int pos=(i-1)*(n-1)+j;
			if(j!=n-1){
				add(pos,pos+1,f[i][j+1],f[i][j+1],f1[i][j+1]);
				add(pos+1,pos,f[i][j+1],f[i][j+1],f1[i][j+1]);
			} 
			if(i!=n-1){
				add(pos,pos+n-1,g[i+1][j],g[i+1][j],g1[i+1][j]);
				add(pos+n-1,pos,g[i+1][j],g[i+1][j],g1[i+1][j]);
			}
		}
	}
	for(re int i=1;i<n;++i){
		add(s,i,g[1][i],g[1][i],g1[1][i]);
		add(i+(n-1)*(n-2),t,g[n][i],g[n][i],g1[n][i]);
		add((i-1)*(n-1)+1,t,f[i][1],f[i][1],f1[i][1]);
		add(s,(i-1)*(n-1)+n-1,f[i][n],f[i][n],f1[i][n]);
	}
	pnt A=dis(s);
	cnt=0;
	memset(head,0,sizeof(head));
	for(re int i=1;i<n;++i){
		for(re int j=1;j<n;++j){
			int pos=(i-1)*(n-1)+j;
			if(j!=n-1){
				add(pos,pos+1,f1[i][j+1],f[i][j+1],f1[i][j+1]);
				add(pos+1,pos,f1[i][j+1],f[i][j+1],f1[i][j+1]);
			} 
			if(i!=n-1){
				add(pos,pos+n-1,g1[i+1][j],g[i+1][j],g1[i+1][j]);
				add(pos+n-1,pos,g1[i+1][j],g[i+1][j],g1[i+1][j]);
			}
		}
	}
	for(re int i=1;i<n;++i){
		add(s,i,g1[1][i],g[1][i],g1[1][i]);
		add(i+(n-1)*(n-2),t,g1[n][i],g[n][i],g1[n][i]);
		add((i-1)*(n-1)+1,t,f1[i][1],f[i][1],f1[i][1]);
		add(s,(i-1)*(n-1)+n-1,f1[i][n],f[i][n],f1[i][n]);
	}
	pnt B=dis(s);	div(A,B);
printf("%lld",ans.x*ans.y);
}
```



---

## 作者：Hollow_knight_ (赞：4)

[博客阅读效果更佳](https://www.luogu.com.cn/blog/mimahqy/solution-p6158)

简化题意：现在有一张 $n\times n$ 的矩形图，每个点与周围四个点都连有一条拥有两个权值 $(a,b)$ 的双向边。而你需要找出一条联通 （图中最左侧，最下侧）任意一点 到 （图中最右侧，最上侧）任意一点 的路径，使得路径上所有边的 $\sum{a}\times\sum{b}$ 最小。

### subtask $1,2$ （$20$ pts）

乱搞即可。

### subtask $3$ （$35$ pts）

枚举路径找最小值即可。

### subtask $4,5$ （$35$~$100$ pts）

我们首先考虑权值只有一维时该如何解决。

其实就是最短路。

我们要找出一条从左下任意一点走到右上任意一点的最短路，则最直观的建模方法就是从起点向左下所有点连一条长度为 $0$ 的边，从右上所有点向终点连一条长度为 $0$ 的边，再把图中所有边建出来，跑最短路即可。

当然观察数据范围，我们亦可以思考出最小费用最大流的解法。但是 dijkstra 最短路算法时间复杂度较低，故我们先思考最短路做法，在此不对费用流做法做过多赘述。

接下来，我们尝试将最短路做法拓展到二维。

首先很navi的一个想法就是优先选择 $a_i\times b_i$ 的 dijkstra 最短路。可惜这种贪心策略是错误的，这一点可以参考诸如01规划的相关算法。

于是这个问题似乎有些无从下手。但是，我们知道关于答案边界的一些信息：

我们先让一条路径用 $(\sum{a},\sum{b})$ 的形式表示，表示这条路径上所有边的 $a$ 之和与路径上所有边的 $b$ 之和各是多少。这时，我们令 $\sum{a}$ 和 $\sum{b}$ 最小，各求一次最短路得到 $(A_1,B_1)$，$(A_2,B_2)$，则答案 $ans\le\min(A_1\times B_1,A_2\times B_2)$。

不过这个信息似乎也不是那么重要。不过 $(\sum{a},\sum{b})$ 的形式启发我们转到二维平面上试试能不能找到正解。

于是我们建立笛卡尔坐标系，令 $\sum{a}$ 为 $x$ 坐标，$\sum{b}$ 为 $y$ 坐标。

于是边界条件就形象化地被表示出来为两个点。

那么很明显，我们需要在经过两点 $L(A_1,B_1)$，$R(A_2,B_2)$ 的反比例函数左下角找答案。

但是这样好像无法根据边界条件推出其他答案，于是我们退而求其次，转而找点 $L$，$R$ 连线左下角的答案。

那么我们需要通过直线 $LR$ 找出一个也许更优的答案，那么我们可以通过这个答案点到直线 $LR$ 的距离来判断它的优劣。

这样说可能有点抽象。形象一点地说，我们要在直线 $LR$ 的左下角找到离直线最远的一点。我们令这个点为 $M$。这样，如果能找到点 $M$，我们就可以根据这个点来递归处理，即 由 $\operatorname{dfs}(L,R)$ 递归到 $\operatorname{dfs}(L,M)$，$\operatorname{dfs}(M,R)$。

那么，这个点 $M$ 该怎么找呢？

我们要令点到直线的距离最长，则有许多公式可以用：$d=\frac{|Ax+By+C|}{\sqrt{A^2+B^2}}$ 最长；或令 $S_{ΔLRM}$ 最大，即 $\sqrt{p(p-a)(p-b)(p-c)}$ 最大或 $\vec{LR}\times \vec{LM}$ 最小......$OI$ 经验告诉我们，比较有价值的公式应该是向量公式。于是我们进一步推式子：

$\min\{\vec{_{LR}}\times \vec{_{LM}}\}$

$=\min\{(R-L)\times (M-L)\}$

$=\min\{(X_R-X_L,Y_R-Y_L)\times(X_M-X_L,Y_M-Y_L)\}$

$=\min\{(X_R-X_L)(Y_M-Y_L)-(Y_R-Y_L)(X_M-X_L)\}$

$=\min\{(X_R-X_L)Y_M-(X_R-X_L)Y_L-(Y_R-Y_L)X_M+(Y_R-Y_L)X_L\}$

由于点 $L$，$R$ 已知，我们只需要求 $(X_R-X_L)Y_M-(Y_R-Y_L)X_M$ 的最小值就行了。

我们发现这其实就是初中所学的分解因式，即把积的形式分解为和的形式。

对于和的形式，我们就可以轻松解决了：在 $\operatorname{dfs}(L,R)$ 中，对于每一条权值为 $(a,b)$ 的边，我们为其赋予一个新的权值为 $(X_R-X_L)Y_M-(Y_R-Y_L)X_M$，用 dijkstra 算法求出点 $M$ ，接下来继续递归 $\operatorname{dfs}(L,M)$，$\operatorname{dfs}(M,R)$ 即可。

边界条件就是找不到直线 $LR$ 左下方的点，即 $\vec{LR}\times \vec{LM}\ge 0$，此时 return 即可。

于是这么一道~~恶心~~兼并思维难度与代码难度的黑题就差不多解决了。

代码如下：

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn=405,maxm=maxn*maxn<<1;
const int inf=1e9;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
	while(c>=48&&c<=57){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return f==1?x:-x;
}
ll ans;
int n,m,r[maxn][maxn],d[maxn][maxn],x[maxn][maxn],y[maxn][maxn];
int s,t,ecnt,head[maxm];
struct edge_node{
	int to,w,x,y,nxt;
}ed[maxm<<1];
inline void add(int u,int v,int w,int a,int b){
	ed[++ecnt]=edge_node{v,w,a,b,head[u]};
	head[u]=ecnt;
}
struct Node{
	ll x,y;
	friend Node operator -(Node a,Node b){
		return Node{a.x-b.x,a.y-b.y};
	}friend int operator ^(Node a,Node b){
		return a.x*b.y-a.y*b.x;
	}
}L,R;
struct dis_node{
	int to,w;
	Node x;
	friend bool operator <(dis_node a,dis_node b){
		return a.w>b.w;
	}
}now,dis[maxm];
priority_queue<dis_node>q;
inline Node dijkstra(){
	for(int i=s;i<=t;++i){
		dis[i].to=i,dis[i].w=inf;
		dis[i].x=Node{0,0};
	}
    dis[s].w=0;
    q.push(dis[s]);
    while(!q.empty()){
        now=q.top();
        q.pop();
        for(int i=head[now.to];i;i=ed[i].nxt){
            if(now.w+ed[i].w<dis[ed[i].to].w){
                dis[ed[i].to].w=now.w+ed[i].w;
                dis[ed[i].to].x.x=dis[now.to].x.x+ed[i].x;
                dis[ed[i].to].x.y=dis[now.to].x.y+ed[i].y; 
                q.push(dis[ed[i].to]);
            }
        }
    }
    ans=min(ans,dis[t].x.x*dis[t].x.y);
    return dis[t].x;
}
inline void build(Node A,Node B){
	ecnt=0;
	memset(head,0,sizeof(head));
	for(int i=1;i<n;++i){
		for(int j=1,pos;j<n;++j){
			pos=(i-1)*(n-1)+j;
			if(j!=n-1){
				add(pos,pos+1,r[i][j+1]*(A.y-B.y)+d[i][j+1]*(B.x-A.x),r[i][j+1],d[i][j+1]);
				add(pos+1,pos,r[i][j+1]*(A.y-B.y)+d[i][j+1]*(B.x-A.x),r[i][j+1],d[i][j+1]);
			}
			if(i!=n-1){
				add(pos,pos+n-1,x[i+1][j]*(A.y-B.y)+y[i+1][j]*(B.x-A.x),x[i+1][j],y[i+1][j]);
				add(pos+n-1,pos,x[i+1][j]*(A.y-B.y)+y[i+1][j]*(B.x-A.x),x[i+1][j],y[i+1][j]);
			}
		}
	}
	for(int i=1;i<n;++i){
		add(s,i,x[1][i]*(A.y-B.y)+y[1][i]*(B.x-A.x),x[1][i],y[1][i]);
		add(i+(n-1)*(n-2),t,x[n][i]*(A.y-B.y)+y[n][i]*(B.x-A.x),x[n][i],y[n][i]);
		add((i-1)*(n-1)+1,t,r[i][1]*(A.y-B.y)+d[i][1]*(B.x-A.x),r[i][1],d[i][1]);
		add(s,(i-1)*(n-1)+n-1,r[i][n]*(A.y-B.y)+d[i][n]*(B.x-A.x),r[i][n],d[i][n]);
	}
}
inline void build(int x,int y){
	build(Node{0,x},Node{y,0});
}
void dfs(Node A,Node B){
	build(A,B);
	Node C=dijkstra();
	if(((B-A)^(C-A))>=0)
		return;
	dfs(A,C);
	dfs(C,B); 
}
int main(){
	ans=2e18;
	n=read();
	s=0,t=(n-1)*(n-1)+2;
	for(int i=1;i<n;++i)
		for(int j=1;j<=n;++j)
		r[i][j]=read(),d[i][j]=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<n;++j)
		x[i][j]=read(),y[i][j]=read();
	build(1,0);
	L=dijkstra();
	build(0,1);
	R=dijkstra();
	dfs(L,R);
	printf("%lld",ans);
	return 0;
}
```
tips：

1，仔细计算代码的空间复杂度，在这种空间开销相对较大的题目切忌因不想动脑而乱赋值什么 $2\times 10^6$ 之类的~~这只会害了你~~。

2，还是仔细观察数据范围。计算可得 $(2\times 10^3)^2 < 2^{32}$，故无需换 long long 来计算。

3，时间复杂度，这个比较难算。由于本文主要核心是探索程序实现方法，故这里不多赘述~~读者自证QED~~。简单来讲，这样的递归方式其实就是一种叫做 _QuickHull_ 的求凸包算法；而选中 $n-1$ 条边在平面上组合出的点中，凸包个数期望级别是 $\sqrt{\ln n}$，算上 $dijkstra$ 的 $Θ(m\log_2 m)$ 就是 $Θ(m\log_2 m\times\sqrt{\ln (n^2)!})$。

4，程序中有大段代码段如 dijkstra，赋值连边的内容是需要重新使用的，故尽量封装函数，以便多次使用。

_Thanks for your reading_

### More Practice

其实这个优化模型叫做最小乘积模型，模板题为[最小乘积生成树](https://www.luogu.com.cn/problem/P5540)。

“三倍经验”：[生成树模板](https://www.luogu.com.cn/problem/P5540)，[套二分图](https://www.luogu.com.cn/problem/P3236)，[套最短路](https://www.luogu.com.cn/problem/P6158)。

这种计算几何综合思维题还是少做。。。。。。别好给做出毛病来了。

_Finally_,_take care of yourself and be well_

---


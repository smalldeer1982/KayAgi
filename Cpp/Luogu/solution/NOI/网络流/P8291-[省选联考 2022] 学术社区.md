# [省选联考 2022] 学术社区

## 题目背景

**小 I 的温馨提示：在题目描述中有形式化的题面，你可以选择跳过题目背景。同时请仔细将本题的除题目背景以外的所有内容进行完整阅读后再进行做题。**

小 I 是一个喜欢 OI 的选手，不过，与其说小 I 喜欢 OI，不如说小 I 喜欢的是他最经常使用的 OJ——FCCOJ——上的趣味功能：学术社区。虽说名字叫学术社区，但小 I 和网友们能够谈论的东西远不止学术。每天学术社区里总会出现不少吸引小 I 注意的帖子。今天小 I 在学术社区冲浪时发现了一个这样的帖子：

> `builtin_clz`：萌新求助，学术社区这题，本机 AC 提交 RE
> 
> `builtin_ctz`：`builtin_clz` 楼下
> 
> `jinkela`：`builtin_ctz` 楼下
> 
> `builtin_ctz`：`builtin_clz` 楼上
> 
> `builtin_clz`：能不能别魔怔了，大家正经回答问题
> 
> `OrzTourist`：`builtin_clz` 楼下
> 
> `OrzTourist`：`OrzTourist` 楼下
> 
> `builtin_clz`：怎么没有人回答问题，我生气了！
> 
> `builtin_clz`：`builtin_clz` 楼上
> 
> `builtin_clz`：`builtin_clz` 楼下
> 
> `builtin_clz`：`builtin_clz` 楼上
> 
> `builtin_clz`：`builtin_clz` 楼下
> 
> ……

虽然这个名叫 `builtin_clz` 的网友因为没有人回答他的学术问题被激怒了，但这个有趣的发言方式让小 I 乐呵了许久，这说明人类的悲欢并不相通。不过当小 I 刷新界面想要往下浏览大家的回复时，却发现学术社区的管理员因为这个帖子过于灌水把它删除了。

为了恢复这个有趣的帖子，小 I 对着网页缓存倒腾了许久，还原出了这个帖子的每条消息。然而因为神秘原因，消息的顺序被打乱了，且缓存中没有每条消息发送的时间，因而小 I 没有办法还原原始帖子中消息的顺序。

秉承 “遇到困难睡大觉” 精神的小 I 决定随便给帖子里的消息排个顺序，不过深受 “`XXX` 楼上” “`XXX` 楼下” 这种发言形式吸引的小 I 还是希望重排之后有尽可能多的这种形式的消息的表达是符合帖子的实际情况的。然而小 I 是一个只会水社区不会做题的 OI 选手，所以小 I 求助于你。

当然了，小 I 知道直接将帖子中的原始信息丢给你对你来说是不方便的，所以他对信息进行了一些规范化处理，详见题目描述中的形式化题意。**同时由于学术社区的特殊规定，帖子中的消息满足一定特殊限制，详见题目描述最后。**

## 题目描述

**以下涉及的所有字符串判等操作都对大小写敏感，例如 `1oushang`、`Loushang`、`LOUSHANG` 是互不相同的字符串。**

小 I 正在整理学术社区中的一个帖子。帖子中一共有 $N$ 个网友发过消息，他们的网名分别为 $n_1, n_2, \ldots, n_N$。帖子中总共有 $M$ 条消息，对于第 $i$ 条消息，我们用三个字符串 $s_{i,1}, s_{i,2}, s_{i,3}$ 构成的三元组描述它，其中 $s_{i,1}$ 表示这条消息发出者的网名，而 $s_{i,2}$ 和 $s_{i,3}$ 描述这条消息的内容。

对于第 $i$ 条消息，我们通过如下方式定义其属于**楼下型消息**、**楼上型消息**、**学术型消息**中的哪一种：

- 若字符串 $s_{i, 3}$ 为 `louxia`，且 $s_{i, 2}$ 恰好与给出的某个网名相同（注意 $s_{i,2} = s_{i,1}$ 是允许的），则称这条消息是**楼下型消息**，$s_{i,2}$ 对应这条消息提到的网友；
- 若字符串 $s_{i,3}$ 为 `loushang`，且 $s_{i,2}$ 恰好与给出的某个网名相同（注意 $s_{i,2} = s_{i,1}$ 是允许的），则称这条消息是**楼上型消息**，$s_{i,2}$ 对应这条消息提到的网友；
- 若以上两个条件都不满足，则称这条消息是**学术消息**。

定义一个对所有消息的重排方案为一个 $1$ 到 $M$ 的排列 $a_1, a_2, a_3, \ldots, a_M$，表示第一条消息是 $(s_{a_1,1}, s_{a_1,2}, s_{a_1,3})$，第二条消息是 $(s_{a_2,1}, s_{a_2,2}, s_{a_2,3})$，依此类推。

对于一个重排方案 $a_1, a_2, a_3, \ldots, a_M$ 中的第 $i$（$1 \le i \le M$）条消息 $(s_{a_i,1}, s_{a_i,2}, s_{a_i,3})$，如下定义其是否是**符合实际情况的**：

- 若这条消息是**楼下型消息**，则这条消息是**符合实际情况的**当且仅当 $i \ne 1$ 且 $s_{a_{i - 1}, 1} = s_{a_i, 2}$，即上一条消息存在且它的发出者与这条消息提到的网友一致。
- 若这条消息是**楼上型消息**，则这条消息是**符合实际情况的**当且仅当 $i \ne M$ 且 $s_{a_{i + 1}, 1} = s_{a_i, 2}$，即下一条消息存在且它的发出者与这条消息提到的网友一致。
- 若这条消息是**学术消息**，则无论如何这条消息一定不是符合实际情况的，这是因为小 I 只想灌水不想学术。

在以上定义下，小 I 希望找到一个重排方案，使得该重排方案中符合实际情况的消息数量最多。你需要帮他找到这个方案以及这个方案中符合实际情况的消息数量。

**为了方便你的解题，小 I 还告诉了你帖子中消息的一个特殊限制：因为学术社区会禁言在社区中只灌水不学术的人，所以在小 I 给出的帖子里，每一个在帖子中发过言的人都一定会在帖子中发出至少一条学术消息。**

## 说明/提示

**【样例解释 #1】**

第一个测试数据与题目背景中给出的例子基本一致，而不同的点在于：为了满足每个人至少发出一条学术消息的要求，在该组数据输入的最后有几条额外的学术消息。

第二个测试数据中，输入的前两条消息是楼上型消息，第三条消息是楼下型消息，其他消息是学术消息。

**【样例 #3】**

见附件中的 `community/community3.in` 与 `community/community3.ans`。

该组样例满足数据范围中的特殊性质 A、特殊性质 B、特殊性质 C。

**【样例 #4】**

见附件中的 `community/community4.in` 与 `community/community4.ans`。

该组样例满足数据范围中的特殊性质 C。

**【数据范围】**

设 $\sum M$ 为单个测试点中所有测试数据的 $M$ 的和。

对于所有测试点，$1 \le T \le 100$，$1 \le N \le M \le 77777$，$1 \le \sum M \le 2.5 \times {10}^5$。

| $T \le$ | $M \le$ | $\sum M \le$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| $5$ | $10$ | $50$ | $1$ | 无 | 无 | 无 |
| $10$ | $16$ | $160$ | $2$ | 无 | 无 | 无 |
| $30$ | $2222$ | $15000$ | $3 \sim 4$ | 有 | 有 | 有 |
| $30$ | $2222$ | $15000$ | $5 \sim 6$ | 有 | 无 | 有 |
| $30$ | $2222$ | $15000$ | $7 \sim 9$ | 无 | 有 | 有 |
| $30$ | $2222$ | $15000$ | $10 \sim 11$ | 无 | 无 | 有 |
| $30$ | $2222$ | $15000$ | $12 \sim 13$ | 无 | 无 | 无 |
| $100$ | $77777$ | $2.5 \times {10}^5$ | $14 \sim 15$ | 有 | 有 | 有 |
| $100$ | $77777$ | $2.5 \times {10}^5$ | $16$ | 有 | 无 | 有 |
| $100$ | $77777$ | $2.5 \times {10}^5$ | $17 \sim 19$ | 无 | 有 | 有 |
| $100$ | $77777$ | $2.5 \times {10}^5$ | $20 \sim 22$ | 无 | 无 | 有 |
| $100$ | $77777$ | $2.5 \times {10}^5$ | $23 \sim 25$ | 无 | 无 | 无 |

**注意：为了阅读方便，测试点编号在表格中的第四列。**

特殊性质 A：没有楼上型消息。**注意：这不意味着 $\bm{s_3}$ 不等于 `loushang`。**

特殊性质 B：对于每组测试数据，存在一个重排方案，使得每一条楼上型消息和楼下型消息都是符合实际情况的。

特殊性质 C：对于每组测试数据，若存在一条消息是 $s_1$ $s_2$ `loushang`，其中 $s_1, s_2$ 为任意字符串，则该组数据中一定不存在一条消息是 $s_2$ $s_1$ `louxia`。

**【评分方式】**

若一个测试点内所有测试数据的符合实际情况的消息数量都正确，你将获得该测试点 $50 \%$ 的分数；在此基础上，若一个测试点内所有测试数据的重排方案都正确，你将获得该测试点的所有分数。需要注意的是，**如果你只希望获得 $\bm{50 \%}$ 的分数，你也要保证在每组测试数据的第二行输出一个 $\bm{1}$ 到 $\bm{M}$ 的排列，否则实际分数与期望分数可能出现偏差**。

**【提示】**

因为这对你可能很重要，所以小 I 再一次强调：**因为学术社区会禁言在社区中只灌水不学术的人，所以在小 I 给出的帖子里，每一个在帖子中发过言的人都一定会在帖子中发出至少一条学术消息**。

本题输入规模较大，请使用较为快速的输入方式。

## 样例 #1

### 输入

```
2
4 15
builtin_clz
builtin_ctz
jinkela
OrzTourist
builtin_clz MengXin QiuZhu
builtin_ctz builtin_clz louxia
jinkela builtin_ctz louxia
builtin_ctz builtin_clz loushang
builtin_clz BieMoZheng YaoXueShu
OrzTourist builtin_clz louxia
OrzTourist OrzTourist louxia
builtin_clz Iam Angry!
builtin_clz builtin_clz loushang
builtin_clz builtin_clz louxia
builtin_clz builtin_clz loushang
builtin_clz builtin_clz louxia
builtin_ctz Xue Shu
jinkela Xue Shu
OrzTourist Xue Shu
1 9
builtin_clz
builtin_clz builtin_clz loushang
builtin_clz builtin_clz loushang
builtin_clz builtin_clz louxia
builtin_clz builtin_clz Loushang
builtin_clz builtin_clz LOUSHANG
builtin_clz Builtin_clz loushang
builtin_clz loushang louxia
builtin_clz builtin_clz builtin_clz
builtin_clz loushang builtin_clz
```

### 输出

```
9
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
3
8 1 2 7 9 3 6 4 5
```

## 样例 #2

### 输入

```
见附件中的 community/community2.in```

### 输出

```
见附件中的 community/community2.ans```

# 题解

## 作者：Itst (赞：71)

### 特殊性质 B 部分分

观察到输出的合法信息数正确就可以得到 50% 的分数，而特殊性质 B 存在某个方案每条非学术消息都合法，故直接计算输入中的楼上型消息与楼下型消息的数量和即可，获得 20 分。

### 测试点 1

爆搜，获得 4 分。

### 测试点 2

状压 DP，获得 8 分。

### 特殊性质 ABC

注意到一条消息连接两个人并且有明显的指向关系，可以想到使用图论建模描述方案。对于每个人建立一个点，对于每条消息 `A B louxia` 从 `B` 向 `A` 连一条边（这是因为它之后的消息指向的是 A 不是 B），对于一条学术消息放在其发出者对应的节点上。观察合法方案，其应该由若干条链构成，每一条链从一个点的学术消息开始，在图上走一段路径，最后可以在任意一个点结束。也就是说，我们需要把图上的所有边进行覆盖。

图论中讨论到边覆盖的算法模型是欧拉回路，当然为了让链覆盖变成欧拉回路需要一些小小的技巧：建立一个虚点 `T`，对于一个 `A` 发出的学术消息从 `T` 向 `A` 连一条边。对于每个非虚点，若其入度减出度为 `d`，则从它往 `T` 连 `d` 条边。首先这个 `d` 一定不会是负数，否则必然存在一条从它发出的边对应的消息不符合实际情况。对新图从 `T` 开始跑欧拉回路得到的方案去掉所有没用的边就得到了一个合法的方案。当然还有一个问题是为啥这个图一定联通，这是因为每个人都会发一条学术消息。

该算法可以通过 7 个测试点，加上以上所有的部分分，共可以获得 42 分。

### 特殊性质 AC

沿用 ABC 的算法，问题在于有一些点由于入度小于出度，对于额外的（出度减去入度）条消息是一定无法满足实际情况的，由此我们可以计算出答案的一个下界。同时我们可以简单地构造一个方案使得答案恰好为这个下界：对于每个出度大于入度的点，从 `T` 向它连若干条边使其入出度平衡，然后跑一遍欧拉回路。对于这样加入的每一条边，它在欧拉回路中连接的下一条边对应的消息不满足实际情况，而其他消息都满足实际情况。

该算法可以额外通过 3 个测试点，加上以前所有的部分分，共可以获得 54 分。

### 特殊性质 BC

再一次观察最终的方案。其仍然可以划分成若干条链，因为满足特殊性质 C，所以每条链一定是若干条楼上消息+中间的一条学术消息+若干条楼下消息（若干可以是零）。这引导我们建立分层图描述方案。具体地，建立二层图 $G_1,G_2$，每个人在 $G_1$,$G_2$ 中都对应一个点。对于一条楼上型消息 `A B loushang`，在 $G_1$ 中从 `A` 向 `B` 连一条边；对于一条学术消息，从 $G_1$ 对应节点向 $G_2$ 对应节点连一条边；对于一条楼下型消息 `A B louxia`，在 $G_2$ 中从 `B` 向 `A` 连一条边。那么一条方案中的链对应的就是从 $G_1$ 的任意一个点开始到 $G_2$ 的任意一个点结束的一条路径，我们需要找到一个路径对边的覆盖。

仍然沿用特殊性质 ABC 的做法：建立一个虚点 T，对于每个 $G_1$ 中的点，通过 T 向它连边使其入出度平衡，对于每个 $G_2$ 中的点，通过从它向 T 连边使其入出度平衡，然后运行欧拉回路算法得到一个方案。

该算法可以额外通过 5 个测试点，加上以前所有的部分分，共可以获得 64 分。

### 特殊性质 C

继续沿着之前的思路走，现在不一定每条边都出现在方案里了，我们要如何选择舍弃的边呢？

之前的所有算法都在平衡图上每个点的点度以保证欧拉回路的存在，那么继续沿着这个想法行进。对于 $G_1$ 中的点，入度大于出度时，会有（入度减出度）那么多条边无法匹配；而 $G_2$ 中则是入出度反过来。那么与特殊性质 AC 类似，我们首先有了一个答案的下界。但是没有优化空间了吗？

仔细想想舍弃一条边意味着什么。对于一条 `A B loushang`，如果我们舍弃它，其实意味着这条消息被我们认作了功能与学术消息等同的消息，也就是说，原本是 $G_1$ 中 $A$ 连向 $B$，现在是 $G_1$ 中的 $A$ 连向 $G_2$ 中的 $A$，此时 $G_1$ 中的 $B$ 入度减少 $1$，$G_2$ 中的 $A$ 入度增加 $1$，对于两个点来说条件都松弛了 $1$！也就是说，如果这两个点在开始的时候都需要舍弃边，那么通过舍弃 `A B loushang` 这条边，下界可以往上加 1。

这样看来，我们希望尽可能多的找到这样的边，那么下界就可以抬升得尽可能大，而这个最大值很显然对应着答案。找这样的边的过程可以使用二分图网络流模型刻画：对于每个 $G_1$ 中的点 $A_1$，如果其出度 $d_{out}(A_1)$ 小于入度 $d_{in}(A_1)$，从 $S$ 向 $A_1$ 连流量为 $-d_{out}(A_1) + d_{in}(A_1)$ 的边；对于每个 $G_2$ 中的点 $A_2$，如果其入度小于出度，从 $A_2$ 向 $T$ 连流量为 $d_{out}(A_2) - d_{in}(A_2)$ 的边；对于一条 `A B loushang` 消息，从 $B_1$ 向 $A_2$ 连一条流量为 $1$ 的边；对于一条 `A B louxia` 消息，从 $A_1$ 向 $B_2$ 连一条流量为 $1$ 的边。对建立的网络流图跑最大流，最大流量就对应着下界的最大抬升量，而对应的方案就是舍弃了之后能让下界增加 1 的边集。

将这些边舍弃（这指的是将它们变成对应的学术边）之后，再运行 BC 和 AC 思想结合的算法得到欧拉回路即可找到对应方案。

该算法可以额外通过 5 个测试点，结合之前的所有算法可获得 80 分。

### 最终算法

最后一个问题是需要解决特殊性质 C 中提到的对边。其发生的变化是：链的中间不一定由一条学术消息作为中转，而是用一对 `A B loushang` 和 `B A louxia`。我们容易对方案进行调整或者对网络流得到的最终方案进行分析，得到将这样的一对消息放在一起总是不劣的，所以将它们拼在一起之后，就变成了 $A_1 \to B_2$ 的一条边，这样的边在特殊性质 C 的网络流中不需要进行任何决策，所以将这样的边缩起来之后更新度数运行特殊性质 C 算法即可。

该算法可以通过最后 5 个测试点，获得满分。

### Bonus

如果去掉题目中的**每一个在帖子中发过言的人都一定会在帖子中发出至少一条学术消息**这题能不能做呢？

去掉这个条件的难点在于，$G_1$ 和 $G_2$ 中可能存在入出度平衡的连通块，对于它们需要额外用一条边让虚点 $T$ 与它们联通。而在网络流决策的过程中，可能会出现一个 $G_1$ 中导出子图入出度平衡的、不向子图外连边的 SCC 由于 $G_1$ 中其他点连向它们的边都被网络流舍弃光了导致这个连通块需要额外的 1 的代价。而这个代价作为 SCC 一个整体出现，又与特殊性质 C 中的单点代价有所不同，它们很难整合在同一个网络流模型中。

如果大家有什么想法可以与我讨论。

---

## 作者：WeLikeStudying (赞：27)

- 对自身的问题有了新的体会。
- 当你的笔头落在实处的时候，烦恼便消失无踪。
- 感谢[大佬](https://www.luogu.com.cn/user/58705)对时间复杂度的指导。
- 感谢与[大佬](https://www.luogu.com.cn/user/52881)讨论与争辩，让我对该做法有了更深刻的理解。
- 感谢[大佬](https://www.luogu.com.cn/user/52170)，[大佬](https://www.luogu.com.cn/user/58543)对题解的指导。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P8291)。
- 给一个讨论帖子,每个人都会发出至少一条学术信息和楼上楼下帖子，给帖子重排使得尽量多的楼上楼下帖子合情合理。

**分析**
- 您点开题目，快速地写了一个 $O(n!)$ 的暴力再水了 $20$ 分部分分，看到了学术帖（显然的重要性质）但是完全不知道它在提示什么。
- 剩下的时间您悠闲地思考着，您掠过了无数种想法，发现这样一种想法比较有前途：贪心，如果楼上和楼下相互照应，那么直接将它们配对即可，因为其他解如果破除它无法做到更优。
- 您发现您已经把正解归纳到性质 $C$ 上了，所以您有信心。
- 您认为它显然是个图论问题，所以您把每条的信息看成点，而连边的规则是：对 $(i,j)$ 连权值为 $w$ 的有向边当且仅当如果在排列中 $i$ 帖子在 $j$ 帖子楼上，对答案有 $w$ 的贡献，当然，第一步贪心过后，可以认为图中边的权值都为 $1$。
- 您发现这个问题可以归纳到最小路径覆盖问题：将每条路径以任意的顺序输出就是合法解，最小路径覆盖显然选出了最多的边，这个边数（包括您一开始的贪心）就是答案。
- 您发现这个图有环，而一般图的最小路径覆盖即 $\text{NPC}$，您愤怒了，感叹老天不公，回头转向了特殊性质。
- 您发现您完全没有用到每个人都至少发一条学术信息的特殊性质，于是您考虑使用它，比如 $a,b,\text{loushang}$ 且 $b,a,\text{loushang}$，那么可以将它们直接连到学术信息那里，这样我们可以看作学术信息并没有减少。
- 您发现这个性质可以消除我们网络流内部的环，于是您暴力建边用 $\text{Dicnic}$ 跑二分图最大匹配，复杂度是 $O(m^{2.5})$。
- 您不甘于此，再次感叹老天不公。
- 然后您突然想到一个有虚点的建边方式（如下图），使得图的规模为 $O(m)$，您考虑再三，发现由于边权都为 $1$，用网络流跑它是 $O(m^{1.5})$ 的，与[二分图](https://www.cnblogs.com/Itst/p/12556871.html)的证明类似，可以通过此题。
![](https://cdn.luogu.com.cn/upload/image_hosting/zwku5936.png)

**总结**
- 以上是我的全部思路，你或许觉得杂乱，但那就是我们思考的样子，这里是以上思路的总结，解释与补充，没有信息一其实也能做，但是优化较为困难。
- 第一个信息：楼上楼下相照应可以直接选，利用反证法可以证明。
- 第二个信息：拆环，上面只是一个粗浅的理解，环不一定是二元的，如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/bcb8sq8v.png)
- 注意：最小路径覆盖问题同时也求解了选出边条数最多的情况，而这正是本题的目的。
- 那么，我们上面做法的本质是：我们把做法归纳成一个最小路径覆盖问题，并妄想在一般图上跑最小路径覆盖。
- 传统在有向无环图上跑最小路径覆盖的做法会告诉你：这是不行的，因为传统的做法会跑出的不止有不相交路径，还有一些环，而环是不被允许的。
- 但我们有学术帖！所以可以将所有的环改成不相交路径！所以就可以求解这种特殊情况的“一般图最小路径覆盖”。
- 我们的暴力看上去很没有前途是 $O(m^{2.5})$ 的，但我们利用虚点换了一个建图让它变成是 $O(m^{1.5})$ 的，最终达到了本题的目的。

**代码实现**
- 我的经验是：一定要循序渐进，因为在这个过程中，复杂的模型会被简化，一些原本模糊不清的标准和问题也会显露出来，[准备](https://www.luogu.com.cn/paste/wmirpnd5)。
- 目标 $1$：$O(m^{2.5})$ 输出最优解，代码 $2.6\text{KB}$，[实现](https://www.luogu.com.cn/paste/8wyj48hj)。
- 解决的问题：分两个图实在是太麻烦，应该合并为一个图求解最小路径覆盖；一开始的贪心合并可以使用特殊的排序较为简单地实现；判断边是否相连的方法，只用了非常简单的代码段：
```cpp
bool ok=0;
if(q[i].tp==1&&q[j].tp!=4&&q[i].to==q[j].fm)ok=1;
if(q[j].tp==2&&q[i].tp!=3&&q[i].fm==q[j].to)ok=1;
if(ok)add(i,j+m);
```
- 目标 $2$：$O(m^{1.5})$ 输出最优解，代码 $2.6\text{KB}$：[实现](https://www.luogu.com.cn/paste/mkxnmnfi)。
- 目标 $3$：$O(m^{1.5})$ 小常数输出最优解，代码 $2.6\text{KB}$：[实现](https://www.luogu.com.cn/paste/q8fykz4f)。
- 解决的问题：如何卡常，反正我当前点优化试过了（这个一点效果也没有），不完全 $\text{bfs}$ 优化试过了，一次性退流优化也试过了……反正最后发现还是手工模拟比较正确的增广路会简单轻松一些（或许可以称它为：模拟最大流？）……话说复杂度正确为啥会被卡啊……
- 目标 $4$：$O(m^{1.5})$ 输出最优解和最优方案：代码 $3.4\text{KB}$，[实现](https://www.luogu.com.cn/paste/4ybao5so)。
- 解决的问题：首先把数改成一个双向链表会更加容易修改（虽然还是得有一堆特判），破环为链有更简单的方法，不需要一个个改，只需如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/1atmm51y.png)

**总结**
- 我不知道我的做法相比正解更加简单还是更加困难，或者本质就是一个东西，不过就这样吧，留下思考的痕迹。
- 我常常怀念很久以前的时候，那个时候我只有中午花午睡的时间才能学信息学，很菜，在校队排倒数，但那个时候我学得简单而快乐。
- 这道题让我重新找回了我以前的感觉，简简单单地思考一道题，不论对我来说是否困难：利用算法解决技术上的各种困难，这才是我想要的，这才是我的本心。
- 尽管限于能力，我无法在当时给出这个做法的代码实现，但这题对我的意义远不止一场比赛。
- 就这样吧。

---

## 作者：Miko35 (赞：24)

## 题意

有 $n$ 个人和 $m$ 个消息，一个消息有三种情况：

- `A B loushang`：发消息的人叫 $A$，它产生贡献当且仅当下一条消息是 $B$ 发的；
- `A B louxia`：发消息的人叫 $A$，它产生贡献当且仅当上一条消息是 $B$ 发的；
- `A xxx xxx`（其他情况）：$A$ 发的一条学术消息，永远不产生贡献。

每人至少有一条学术消息，你要找到一种重排消息的方案，使得所有消息贡献之和最大。

$T$ 组数据，$T \leq 100$，$n \leq m \leq 77777$，$\sum m \leq 2.5\times 10^5$。

## 题解

考场写了个 72 ~~但是手贱加了一手输出方案然后写挂爆零了~~，后来发现容易完善到满分做法。思路与官方题解不太一样，但我写了一手似乎是对的，欢迎讨论。

### 模型转换

首先不难想到，把每个消息看做一个点，$x\to y$ 的权值设为把消息 $y$ 接在消息 $x$ 后面产生的贡献（$\in \{0,1,2\}$），得到一张有向完全图。我们要构造一条哈密顿路径，使得上面的权值之和最大。

### 性质 C

考虑性质 C 的简单情况，也就是不会出现 $2$ 的边权。首先我们可以把所有权值为 $0$ 的边去掉，问题变成最小不交路径覆盖。如果这是个 DAG，我们直接跑二分图匹配就完事，但很可惜会出现环。

考虑 DAG 的建图，在一般有向图中为什么会跑错？它有可能出现 $1$ 的入点匹配了 $2$ 的出点，$2$ 的入点匹配了 $3$ 的出点，$3$ 的入点匹配了 $1$ 的出点，这一条路径被统计了 $0$ 次，就寄了。

但是此题保证每个人至少一条学术消息，如果出现了上述匹配成环的情况，我们直接随便取一个环上的点 $x$，将这个环并到 $x$ 发的学术消息上去（具体而言，在环匹配的前面/后面塞一条学术消息），这样就等效成一条大学术消息了。故我们直接使用 DAG 的建图来跑网络流，得到的答案是正确的。

边太多，需要优化建图将边数压到线性，这很容易。以上是考场想到的。

### 满分做法

一个贪心：如果出现了 `A B loushang` 和 `B A louxia`，可以直接让他俩匹配在一起。这样是必然不劣的，证明容易。

回归性质 C 的做法，这样的一组匹配等效于一条 $A$ 进 $B$ 出的学术消息，容易发现这种点永远不会成环，所以使用原来的建图跑网络流仍然是正确的。这样就解决了这道题，时间复杂度 $O(m \sqrt m)$。

无输出方案参考代码：[Code](https://www.luogu.com.cn/paste/a5n8q1l3)

完整代码（跑起来很卡，不保证任何时间提交都能通过）：[Code](https://www.luogu.com.cn/paste/0wp7xxqx)

*upd (2025.1.17)：经提醒修改了等效点的描述。*

---

## 作者：whx1003 (赞：8)

先考虑性质 C 怎么做。

一个简单的想法是把每个点拆入点和出点，然后建立二分图，左边是所有出点，右边是所有入点。$u$ 的出点和 $v$ 的入点有边当且仅当如果排列中存在相邻两个数 $u,v$ 则可以令答案加 $1$。

构造一下方案会让你冷静下来，形如下面的数据会让这个匹配不合法：

> A B louxia
>
> B C louxia
>
> C A louxia

不合法的主要原因是可能匹配出环，但是这种情况是容易解决的。具体地，观察到如下两个性质：

- 如果匹配出环，则环中不会有学术消息
- 如果匹配出环，则环中所有消息都是同一类型

下面以全部为楼下型消息的环为例叙述构造。考虑如果有环 $A\to B\to C\to A$ 且 $A$ 的学术消息为 $u$ 则我们将其变成 $u\to B\to C\to A$。

不难发现这个构造首先满足了每个环都是合法的，其次如果原本匹配出来 $u$ 后面连接了 $v$ 则不难发现 $v$ 一定是楼下型话题，于是把 $v$ 接到 $A$ 后面不会影响 $v$ 的合法性。

这个二分图匹配可以通过建虚点优化。

然后我们来叙述没有性质 C 的做法。

我们直接给出结论。如果存在两条消息 $u,v$ 如下：

> A B louxia
>
> B A loushang

则我们称 $u,v$ 「双向奔赴」。我们的结论是，直接贪心匹配所有双向奔赴的消息对不会变劣。

假设现在我们贪心匹配了 $u,v$，而某个更优的方案中的匹配是 $ux,yv$ 则首先需要满足 $ux,yv$ 中匹配了至少三个消息。这蕴含了 $ux$ 双向奔赴或者 $yv$ 双向奔赴。假设 $ux$ 双向奔赴，则 $x$ 和 $v$ 一定是完全相同的消息，那么匹配 $uv,yx$ 一定也是合法的匹配且至少匹配了三个，这与更优的方案矛盾。

总结做法：

先把所有 $A\to B$ 和 $B\gets A$ 的消息匹配在一起，然后对剩下没有出度和入度的消息做二分图匹配。构造方案的时候出现环则断环为链连到学术消息上。

关于复杂度：复杂度分析同多路增广的二分图匹配，即增广路长度 $\leq \sqrt m$ 的时候只需要增广 $\sqrt m$ 次，增广路长度 $>\sqrt m$ 的时候最多有 $\sqrt m$ 条不相交的增广路，于是复杂度 $\mathcal O(m\sqrt m)$。

```cpp
#include <bits/stdc++.h>

constexpr int maxn = 8E+4;
constexpr int INF = 0x3f3f3f3f;

int cnt;
std::vector<int> way[maxn];
namespace Flow {
	constexpr int maxN = maxn << 2;
	
	int first[maxN], cur[maxN], tot = 1, s, t;
	struct Edge { int to, nxt, cap; } e[maxn << 4];
	
	inline void clear() {
		std::fill(first, first + t + 1, 0);
		tot = 1;
	}
	
	inline void Add(int u, int v, int cap) {
		e[++tot] = { v, first[u], cap };
		first[u] = tot;
	}
	inline void Adde(int u, int v, int cap) {
		Add(u, v, cap), Add(v, u, 0);
	}
	
	int dis[maxN];
	inline bool BFS() {
		std::fill(dis, dis + t + 1, INF);
		
		std::queue<int> q;
		
		q.push(s), dis[s] = 0;
		while(!q.empty()) {
			int u = q.front(); q.pop();
			for(int i = first[u]; i; i = e[i].nxt) {
				int v = e[i].to;
				if(dis[v] > dis[u] + 1 && e[i].cap)
					dis[v] = dis[u] + 1, q.push(v);
			}
		}
		return dis[t] < INF;
	}
	
	inline int DFS(int u, int flow) {
		if(u == t) return flow;
		
		int res = 0;
		for(int &i = cur[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			if(dis[v] != dis[u] + 1 || !e[i].cap) continue;
			
			int f = DFS(v, std::min(flow, e[i].cap));
			flow -= f, res += f;
			e[i].cap -= f, e[i ^ 1].cap += f;
			
			if(!flow) break;
		}
		if(flow) dis[u] = INF;
		return res;
	}
	
	inline int Dinic() {
		int res = 0;
		while(BFS()) {
			std::copy(first, first + t + 1, cur);
			while(int x = DFS(s, INF)) res += x;
		}
		return res;
	}
	
	inline bool getw(int u) {
		if(u == t) return way[cnt].push_back(u), true;
		for(int &i = first[u]; i; i = e[i].nxt) {
			if(i % 2 == 0 && e[i ^ 1].cap) {
				int v = e[i].to;
				if(getw(v)) {
					way[cnt].push_back(u);
					++e[i].cap, --e[i ^ 1].cap;
					return true;
				}
			}
		}
		return false;
	}
}
using Flow::s;
using Flow::t;
using Flow::Adde;

int T, n, m, acd[maxn];
int to[maxn], fm[maxn];
std::unordered_map<std::string, int> id;
std::string wrd[maxn][3];

bool vis[maxn];
inline void DFS1(int u) { vis[u] = 1; if(to[u]) DFS1(to[u]); }
inline void DFS2(int u) { printf("%d ", u); if(to[u]) DFS2(to[u]); }

std::unordered_map<long long, std::vector<int>> S;
int main() {
	std::cin.tie(0)->sync_with_stdio(false);
	
	std::cin >> T;
	while(T --> 0) {
		std::cin >> n >> m, id.clear(), S.clear();
		for(int i = 1; i <= m; ++i) to[i] = fm[i] = vis[i] = 0;
		for(int i = 1; i <= n; ++i) {
			std::string s; std::cin >> s;
			id[s] = i;
		}
		
		auto check = [&](int i) {
			return (wrd[i][2] == "loushang" || wrd[i][2] == "louxia") && id.count(wrd[i][1]);
		};

		int ans0 = 0;
		
		Flow::clear(), s = 0, t = m * 2 + 1;
		for(int i = 1; i <= m; ++i) {
			std::cin >> wrd[i][0] >> wrd[i][1] >> wrd[i][2];
			if(!check(i)) acd[id[wrd[i][0]]] = i;
			else {
				int u = id[wrd[i][0]], v = id[wrd[i][1]];
				if(wrd[i][2] == "louxia") {
					std::swap(u, v);
					auto &vec = S[((long long)u << 31 | v) << 1 | 0];
					if(!vec.empty()) {
						int x = vec.back(); vec.pop_back();
						to[x] = i, fm[i] = x, ans0 += 2;
					} else S[((long long)u << 31 | v) << 1 | 1].push_back(i);
				} else {
					auto &vec = S[((long long)u << 31 | v) << 1 | 1];
					if(!vec.empty()) {
						int x = vec.back(); vec.pop_back();
						to[i] = x, fm[x] = i, ans0 += 2;
					} else S[((long long)u << 31 | v) << 1 | 0].push_back(i);
				}
			}
		}

		for(int i = 1; i <= m; ++i) {
			if(!to[i]) Adde(s, i, 1);
			if(!fm[i]) Adde(i + m, t, 1);
		}
		
		for(int i = 1; i <= m; ++i) {
			int u = id[wrd[i][0]];
			if(check(i)) {
				int v = id[wrd[i][1]];
				if(wrd[i][2] == "louxia") Adde(acd[v], i + m, 1);
				else Adde(i, acd[v] + m, 1);
			}
			if(i != acd[u]) {
				Adde(i, acd[u], 1);
				Adde(acd[u] + m, i + m, 1);
			}
		}
		
		ans0 += Flow::Dinic();
		printf("%d\n", ans0);
		
		cnt = 0;
		while(true) {
			way[++cnt].clear();
			if(!Flow::getw(s)) { --cnt; break; }
		}
		
		for(int i = 1; i <= cnt; ++i) {
			int u = way[i].end()[-2];
			int v = way[i][1] - m;
			to[u] = v, fm[v] = u;
		}
		
		for(int i = 1; i <= m; ++i) if(!fm[i]) DFS1(i);
		for(int i = 1; i <= m; ++i) if(!vis[i]) {
			std::vector<int> tmp;
			for(int j = i; !vis[j]; j = to[j])
				vis[j] = 1, tmp.push_back(j);
			
			int i = tmp.back(), j = tmp.front();
			int u = id[wrd[i][0]], v = id[wrd[j][0]];
			if(wrd[tmp.back()][2] == "louxia") {
				if(to[acd[u]]) fm[to[acd[u]]] = i;
				fm[j] = acd[u];
				to[i] = to[acd[u]];
				to[acd[u]] = j;
			} else {
				if(fm[acd[v]]) to[fm[acd[v]]] = j;
				to[i] = acd[v];
				fm[j] = fm[acd[v]];
				fm[acd[v]] = i;
			}
		}
		for(int i = 1; i <= m; ++i) if(!fm[i]) DFS2(i);
		putchar('\n');
	}
}
```

---

## 作者：1kri (赞：4)

是一道不算简单的题，但真正做起来发现并没有想象中的那么可怕。

先抽象一下题意：有若干点，每个点有颜色和贡献方式，贡献方式分为无贡献（学术型消息），后继型贡献（楼上型消息，判断下一个点的颜色），前驱型贡献（楼下型消息，判断上一个点的颜色）。你需要将这些点连成一条链，使得它们的贡献和最大。

先考虑特殊性质 C，它的本质是保证了任意一条边最多带来 $1$ 的贡献。

我们在此基础上考虑特殊性质 A，发现不存在后继型贡献。可以给每个前驱型贡献的点找前驱，就是一个二分图最大匹配的模型。

这样直接建图的边数是 $O(m^2)$ 的，但是我们可以只记录每个颜色代表的点数，把边数优化到 $O(m)$。

这里还有一个问题，就是直接找前驱可能会连出环。这时我们发现并没有用到题目中反复提及的“每种颜色都有无贡献点”的性质，便大胆猜测一定存在一组不存在环的解，测试大样例发现确实如此。

不考虑特殊性质 A，因为每条边最多只有 $1$ 的贡献，所以我们可以把贡献放在前驱点上，对于每个点找后继，跑二分图最大匹配。这个可以给每个颜色建两个虚点来优化连边，边数也容易优化到 $O(m)$。

没有特殊性质 C 时，每条边可能会带来 $2$ 的贡献，也即一条边的入点、出点可以相互“匹配”。

这里我们可以贪心地先把能够相互匹配的点对都匹配了，然后再按照特殊性质 A 来处理。

因为每个点可以匹配的点是唯一的，所以贪心匹配的结果也是唯一的。同时，我们可以通过调整法来证明这个贪心的正确性：假设在一组最优解中存在一对未匹配的点 $\text{A}$ 和 $\text{B}$，且 $\text{A}$ 和 $\text{B}$ 可以匹配。那么我们可以通过一些重组链的方式，满足最多断掉 $\text{A}$ 的一条出边和 $\text{B}$ 的一条入边，把 $\text{A}$ 和 $\text{B}$ 匹配在一起。不难发现我们断掉的每条边贡献最多为 $1$，而匹配后增加了 $2$ 的贡献，一定是不劣的。所以我们可以在一组最优解上调整，使其能够相互匹配的点对都匹配。

这样，我们通过题目条件假设不会连出环，得到了一种使用 $\text{Dinic}$ 等方式，在 $O(m \sqrt {m})$ 的时间复杂度内获得最优解答案和一组符合答案的连边方式的算法。

接下来，我们来通过无贡献点把一组有环的连边方式调整为无环。观察可以发现，一个环内不存在匹配的点或无贡献点，且一个环内的所有点同为前驱型贡献点或同为后继型贡献点。我们不难分类讨论两种情况，断环成链后通过断点颜色所对应的一个无贡献点，把环连接到这个无贡献点上。构造可以使用链表做到 $O(m)$。这个构造也证明了上面假设的正确性。

这样，我们在 $O(m \sqrt{m})$ 的时间复杂度内解决了问题。


---

## 作者：Danno0v0 (赞：3)

无内鬼，来点老鲤笑话。

出题人：保证每个人都会发一条学术消息！

Danno：我不用！

众人：我用两次！

~~好吧虽然好像这个做法第二问还是需要这个性质。~~

那么先来看第一问吧。

### 第一问

### 我会暴力！

一种十分显然的做法是把每条消息向其所有能为其产生贡献的消息连边，如果是楼上消息  ```A B loushang``` 就把这条消息向所有 B 发出的消息连一条边，假如是楼下消息 ```A B louxia``` 就把所有 B 发出的消息向这条消息连边，然后跑一个最小路径覆盖即可。

然后你就会发现连出的边是 $n^2$ 的然后还会发现里面还有环233那怎么搞呢。

### 我会优化暴力！

然后观察到上述做法边十分多的原因是因为我们直接用消息来连边，我们尝试把消息归到人上。

首先来看一看就很好做的性质 C 怎么搞。

考虑到每条消息的前面除了最前面那条一定会接一条消息，后面也除了最后面那条会接一条，考虑把每个人拆成 $A_1,A_2$ ，对 $S-A_1,A_2-T$连边，凡是有一条 $A$ 发出的消息那么就把上述两条边的容量 +1 表示 $A$ 的前面与后面又可以多接一条消息。

然后对于诸如 ```A B loushang``` 与 ```B A louxia```的消息从 $A_1$ 向 $B_2$ 连边，表示要消耗一个 $A$ 的下接口和 $B$ 的上接口来做出一个贡献。

然后你就会开心地发现消息之间可能会出现环~~cnmd~~

其实只需要再连一条 $T-T'$ 容量 $m-1$ 表示最多只能匹配 $m-1$ 个就可以了（

### 我会优化优化的暴力！

再来看一看没有 C 怎么搞。

首先我们发现有可能在匹配时贡献不为 $1$ 而是 $2$ ，因为有可能会有 ```A B loushang``` 和 ```B A louxia``` 这个东西。

那么是时候使用费用流了！对于这个东西每有一对我们就把其中一条边的费用改成 $2$ 这样跑个费用流就可以随便T飞啦。

~~对是T飞我才不会说想卡过去交了一页呢~~

很明显费用流的 $O(nmF)$ 跑不过啊！

### 我会优化优化的优化暴力！

然后我们发现为什么要为这一对消息专门建边呢。

如果我们不匹配这一对消息，那么这对消息中的两条消息产生的贡献一定是小于等于 $2$ 的，还会消耗其他消息。

那为什么不直接配上呢？？？

然后完全不需要为这东西建边，然后就只有费用为 $1$的边。

所以为什么不直接跑网络流呢？？？然后这是个二分图，可以过。

这样就解决第一问了。

[50分的纪录](https://www.luogu.com.cn/record/75583148)

### 第二问（代码先咕着）

经过第一问我们可以知道哪些消息是被选出来有贡献的。

然而我们不知道它们是怎么排的啊。

想一下，那些没有贡献的消息可以直接看成学术，然后这就把问题转成一个 B 性质的问题。

~~于是翻了一圈题解，发现并没有题解讲只有性质 B 怎么做，然后回来一看题目似乎并没有给出只有性质 B 的点~~

这里参考一下 [Itst](https://www.luogu.com.cn/blog/pengSiJin/lian-ge-xing-xuan-2022-xue-shu-she-ou-analysis) 的解法。

对于每个人拆成 $A_1,A_2$ 两个点。

对于楼上消息 ```A B loushang``` 从 $A_1$ 向 $B_1$ 连边。

对于楼下消息 ```A B louxia``` 从 $B_2$ 向 $A_2$ 连边。

对于一对消息 ```A B loushang``` 和 ```B A louxia``` 从 $A_1$ 向 $B_2$ 连边。

然后通过向虚点 $T$ 连边保证出入度平衡，跑一个欧拉回路就完了。

具体做法和证明详见 Itst 的题解。~~实际上就是把别人的 BC 做法和完整做法揉成一坨来搞~~

~~由于太懒不想写第二问先咕咕咕吧~~

总结：

本来想提供一个不同的建图方式，~~然后发现这个做法巨丑无比第一问第二问还要分开做233~~

code还没写完~~不想写了~~就不放了吧，以后有时间来补第二问。

---

## 作者：Zesty_Fox (赞：3)

更好的阅读体验：[cnblogs](https://www.cnblogs.com/acceptedzhs/p/hnoi2022-d1t3-alternative-solution.html)

考场想法，然后修改了亿点+缩了个点就过了。

首先考虑有 C 性质怎么做。

考虑每句话接下来可以接哪些话，不难发现：

- 对于形如 `A B loushang` 的话，其后只能接发出者为 B 的话
- 对于形如 `A B louxia` 的话，其前只能接发出者为 B 的话

于是可以建图，第 $i$ 句话连向所有可以接到其后面的话，被所有可以接到其前面的话连。

于是就有个网络流思路了：

- 考虑将第 $i$ 句话拆成出度与入度 2 个点，称为 $out_i,in_i$，然后对于 $n$ 个人中每个人都建 $C_j, D_j$ 两个虚点；对于第 $i$ 句话：
  - 设发出者为 $A$，连接 $(S,out_i,1),(in_i,T,1),(D_A,in_i,1),(out_i,C_A,1)$
  - 如果形如 `A B loushang`，再连接 $(out_i,D_B,1)$；
  - 如果形如 `A B louxia`，再连接 $(C_B,in_i,1)$；

不难发现，这是一个类似二分图匹配的东西（只是优化了一下连边），当 $out_i$ 有流量到 $in_j$ 时，即表示最终方案中第 $i$ 句话后接第 $j$ 句话。

直接跑网络流，可以发现第一问的答案均正确，接下来考虑如何构造方案。

首先不难通过残量网络的情况来推出每个点匹配了哪个点，进而可以知道每句话的下一句话是哪句话，于是可以把每句话向其下一句话连边。

然而，这显然可能不合法，原因是可能有环，可能出现 $out_1$ 匹配 $in_2$，$out_2$ 匹配 $in_3$，$out_3$ 匹配 $in_1$，这样的情况。

不过，这样得到的图显然由若干条链+若干个环组成，并且环上的点的类型均相同（都是楼上型或都是楼下型）。

考虑将环拆开，由于题目中保证每个人至少都有一条学术型消息，所以可以把环接到学术性消息去，以楼上型的环为例，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fyr8dc2a.png)

这样就可以把环接到学术性消息去，可以方便地用双向链表维护。楼下型的环同理。

最后没有环了，输出每条链即可。

至于没有 C 性质，不难发现把这样的两句话缩起来一定不劣，然后就变成类似学术的东西了（但不完全是学术），具体看代码吧。

不过还有一些奇技淫巧：直接跑网络流跑不过，那就把所有话的类型反过来，最后输出时再倒序。（为了可读性，格式化了代码，有点长...）

```cpp
#include <bits/stdc++.h>
using namespace std;

using pii = pair<int, int>;
using vi = vector<int>;
using ll = long long;

template <typename T> T read() {
    T x = 0, f = 0;
    char ch = getchar();

    while (!isdigit(ch))
        f |= (ch == '-'), ch = getchar();

    while (isdigit(ch))
        x = x * 10 + (ch - '0'), ch = getchar();

    return f ? -x : x;
}

#define rdi read<int>
#define rdll read<ll>
#define fi first
#define se second
#define mp make_pair
#define pb push_back

const int N = 240010;
const int INF = 0x3f3f3f3f;

map<string, int> nam;

int n, m;

struct Edge {
    int to, nxt, f;
} e[N * 10];
int head[N * 4], tot = 1;

void addedge(int x, int y, int f) {
    e[++tot] = {y, head[x], f};
    head[x] = tot;
    e[++tot] = {x, head[y], 0};
    head[y] = tot;
}

struct Mes {
    int fr, to, typ;
    ll id;
} me[N];
bool operator<(const Mes &a, const Mes &b) {
    return make_tuple(a.typ, a.fr, a.to) < make_tuple(b.typ, b.fr, b.to);
}

inline int idd(int x, int typ) {
    return 2 * m + x * 2 - 1 + typ;
}

namespace MF {
int dep[N * 4];
bool bfs(int S, int T) {
    memset(dep, 0, sizeof(int) * (T + 2));
    queue<int> q;
    q.push(S), dep[S] = 1;

    while (!q.empty()) {
        int x = q.front();
        q.pop();

        if (x == T)
            return true;

        for (int i = head[x]; i; i = e[i].nxt) {
            int y = e[i].to;

            if (e[i].f && !dep[y]) {
                dep[y] = dep[x] + 1;
                q.push(y);
            }
        }
    }

    return false;
}
int dfs(int x, int fl, int T) {
    if (x == T)
        return fl;

    int rest = fl;

    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;

        if (e[i].f && dep[y] == dep[x] + 1) {
            int tmp = dfs(y, min(fl, e[i].f), T);

            if (tmp < min(fl, e[i].f))
                dep[y] = 0;

            e[i].f -= tmp, e[i ^ 1].f += tmp, rest -= tmp;

            if (!rest)
                break;
        }
    }

    return fl - rest;
}
int mf(int S, int T) {
    int sum = 0;

    while (bfs(S, T))
        sum += dfs(S, INF, T);

    return sum;
}
} // namespace MF

int S, T, ans, m1;

void build() {
    // find parallel edges
    m1 = m;
    multiset<Mes> s;

    for (int i = 1; i <= m; i++)
        s.insert(me[i]);

    while (!s.empty()) {
        auto tmp = *s.begin();
        s.erase(s.begin());

        if (tmp.typ != 1)
            continue;

        auto it = s.find({tmp.to, tmp.fr, 2, 0});

        if (it != s.end()) {
            //删除不满足性质 C 的两句话，加入新点
            me[tmp.id].typ = me[it->id].typ = -1, ans += 2;
            me[++m] = {tmp.fr, tmp.to, 3, (tmp.id << 20) | it->id};
            s.erase(it);
        }
    }

    S = 2 * m + 2 * n + 1, T = 2 * m + 2 * n + 2;

    for (int i = 1; i <= m; i++) {
        if (me[i].typ == -1)
            continue;

        int x = me[i].fr, y = me[i].to;
        addedge(S, i, 1);
        addedge(i + m, T, 1);

        if (me[i].typ < 3) {
            addedge(i, idd(x, 0), 1);
            addedge(idd(x, 1), i + m, 1);

            if (me[i].typ == 1)
                addedge(i, idd(y, 1), 1);
            else if (me[i].typ == 2)
                addedge(idd(y, 0), i + m, 1);
        } else if (me[i].typ == 3) {
            //如果是两句话缩起来的点，则建图有点区别，不过应该好理解
            addedge(idd(x, 1), i + m, 1);
            addedge(i, idd(y, 0), 1);
        }
    }
}

vi s1[N * 2], s2[N * 2];

int nxt[N], seq[N], pos;
int pre[N], id[N];

void construct() {
    //寻找每句话的下一句话（即 out_i 匹配了谁）
    for (int x = 1; x <= n; x++) {
        for (int i = head[idd(x, 0)]; i; i = e[i].nxt) {
            if (i & 1)
                continue;

            if (!e[i].f)
                s2[idd(x, 0)].pb(e[i].to - m);
        }

        for (int i = head[idd(x, 1)]; i; i = e[i].nxt) {
            if (i & 1)
                continue;

            if (!e[i].f)
                s2[idd(x, 1)].pb(e[i].to - m);
        }
    }

    for (int x = 1; x <= m; x++) {
        for (int i = head[x]; i; i = e[i].nxt) {
            if (i & 1)
                continue;

            if (!e[i].f)
                s1[e[i].to].pb(x);
        }
    }

    //nxt_i 即为第 i 句话的下一句话
    for (int x = 1; x <= n; x++) {
        for (int j = 0; j <= 1; j++) {
            int now = idd(x, j);

            for (auto x : s1[now])
                nxt[x] = s2[now].back(), s2[now].pop_back();
        }
    }

    static int vis[N];
    static vi s[N];

    auto doit = [&](int typ) {
        vector<vi> lp;
        vi st;

        for (int i = 0; i <= m; i++)
            vis[i] = 0;

        for (int i = 0; i <= n; i++)
            s[i].clear();

        for (int x = 1; x <= m; x++)
            vis[nxt[x]] = 1;

        for (int x = 1; x <= m; x++)
            if (!vis[x])
                st.pb(x);

        for (int x = 1; x <= m; x++)
            vis[x] = 0;

        //先把链给去掉
        for (auto x : st) {
            int now = x;

            while (now)
                vis[now] = 1, now = nxt[now];
        }

        // 找环
        for (int x = 1; x <= m; x++)
            if (!vis[x]) {
                int now = x;

                if (me[now].typ == typ)
                    lp.pb({});

                while (!vis[now]) {
                    vis[now] = 1;

                    if (me[now].typ == typ)
                        lp.back().pb(now);

                    now = nxt[now];
                }
            }

        //id_i 表示发送者为 i 的学术消息的编号
        for (int i = 1; i <= m; i++) {
            if (nxt[i])
                pre[nxt[i]] = i;

            if (!me[i].typ)
                id[me[i].fr] = i;
            else if (me[i].typ == 3)
                id[typ == 1 ? me[i].fr : me[i].to] = i;
        }

        auto link = [&](int x, int y) {
            nxt[x] = y, pre[y] = x;
        };

        if (typ == 1) {
            for (auto &tmp : lp) {
                int fr = me[tmp[0]].to;
                int x1 = tmp[0], y1 = nxt[tmp[0]], x2 = pre[id[fr]],
                    y2 = id[fr];
                link(x1, y2), link(x2, y1);
            }
        } else {
            for (auto &tmp : lp) {
                int fr = me[tmp[0]].fr;
                int x1 = tmp[0], y1 = nxt[tmp[0]], x2 = id[fr],
                    y2 = nxt[id[fr]];
                link(x1, y2), link(x2, y1);
            }
        }
    };

    doit(1);
    doit(2);

    vi st;

    for (int i = 0; i <= m; i++)
        vis[i] = 0;

    for (int x = 1; x <= m; x++)
        vis[nxt[x]] = 1;

    for (int x = 1; x <= m; x++)
        if (!vis[x])
            st.pb(x);

    for (int i = 1; i <= m; i++)
        vis[i] = 0;

    for (auto x : st) {
        if (me[x].typ == -1)
            continue;

        while (x)
            seq[++pos] = x, x = nxt[x];
    }

    reverse(seq + 1, seq + pos + 1);
}

void clear() {
    memset(head, 0, sizeof(int) * (T + 2));
    tot = 1;
    nam.clear();
    pos = ans = 0;

    for (int i = 0; i <= m; i++)
        nxt[i] = pre[i] = id[i] = 0;

    for (int i = 1; i <= n; i++)
        for (int j : {0, 1})
            s1[idd(i, j)].clear(), s2[idd(i, j)].clear();
}

void solve() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        string s;
        cin >> s;
        nam[s] = i;
    }

    for (int i = 1; i <= m; i++) {
        string s1, s2, s3;
        cin >> s1 >> s2 >> s3;
        int fr = nam[s1], to = 0, typ = 0;
        map<string, int>::iterator it;

        //注意：这里 loushang louxia 反过来了，原因见题解
        if (s3 == "louxia" && (it = nam.find(s2)) != nam.end())
            typ = 1, to = it->se;
        else if (s3 == "loushang" && (it = nam.find(s2)) != nam.end())
            typ = 2, to = it->se;
        else
            typ = 0;

        me[i] = {fr, to, typ, i};
    }

    build();
    ans += MF::mf(S, T);
    construct();
    cout << ans << '\n';

    for (int i = 1; i <= pos; i++) {
        int x = seq[i];

        if (me[x].typ <= 2)
            cout << seq[i] << ' ';
        else
            //如果是两句话缩起来的，则输出两个
            cout << (me[x].id & ((1 << 20) - 1)) << ' ' << (me[x].id >> 20)
                 << ' ';
    }

    cout << '\n';
    clear();
}

int main() {
    ios::sync_with_stdio(false);
    int T;
    cin >> T;

    while (T--)
        solve();

    return 0;
}
```


---

## 作者：asd_a (赞：2)

提供大致做法，目前没有代码

### 先考虑限制C的情况  
我们将每条消息拆成楼上和楼下两个点，  
那么一个消息排列就是一个楼上与楼下的匹配,  
对于一个符合实际匹配就能贡献1,  
不难建出二分图最大匹配，
但这样实现有可能出现环的情况  
题目保证了每个人至少一个学术消息，考虑用它断环成链  
不妨假设当前有环 $A->B->...->C->A$ 和链 $D->F->...->E$,  
$D$ 和 $A$ 是同一个人说的，  
$E$ 和 $A$ 是同一个人说的 的情况本质相同，不加赘述  
情况 1 若 $A->B$ 的边是 $A$ 中贡献的，那么 $C->A$ 的边就是 $C$ 贡献的，那么将$C->A$ 变为 $C->D$ 不影响答案

情况 2 若 $A->B$ 的边是 $B$ 中贡献的，那么将$A->B$ 变为 $A->F,D->B$ 不影响答案，但这要求 $D->F$ 的边是 $F$ 贡献的

那我们可以先断情况2的环，初始学术消息一定满足限制，然后再断情况1的环，即可将所有环断环成链

### 无限制条件：

不难发现就是变成了一个二分图最大权，即那两条消息相互满足贡献 2 ，  

不难发现存在 贡献为 2 的边的一定无法成环， 也即上面的断环方案一定可行

然后就是每个人建虚点即可优化边数，不确定是否能跑

---

## 作者：Acoipp (赞：1)

## 分析

这道题可以抽象成一道图论问题，考虑以下方式的建图：

- 若第 $i$ 条消息是楼上型消息，并且第 $j$ 条消息的 $s_{i,2}=s_{j,1}$，那么连边 $i \to j$，边权为 $1$。

- 若第 $i$ 条消息是楼下型消息，并且第 $j$ 条消息的 $s_{i,2}=s_{j,1}$，那么连边 $j \to i$，边权为 $1$。

但是有重边的情况，边权为 $2$，这种情况我们直接强制这两个点连接即可，贪心可证明一定最优。

并且这样的话我们可以把这两条消息 $i,j$ 合并，即不能有 $k \to j(k \ne i)$ 或者 $i \to k(k \ne j)$，这种边在连接的时候跳过即可。最后记着答案加 $2$。

然后只剩下边权为 $1$ 的边，就相当于是在一个有向图上找若干条路径覆盖所有的点，点不能被重复覆盖，要求路径数量最少，答案就是总点数减去路径数量。

如果这是一个有向无环图，那么就跑一个二分图最大匹配就可以了，大概就是每个点拆成入点和出点，对于原图上的边 $x \to y$，连接 $in_x \to out_y$ 即可。

但是这是一个有向图，可能有环，如何处理？

如果我们按照上述方法跑二分图匹配，就会出现环上的边都被统计了导致环没有被统计的尴尬情况，但是这道题不会，因为每个人至少有一条学术消息，我们把这条学术消息插到环的某个节点后面，断环成链即可。

这个时候的答案就是正确的，并且断成链之后的环可以看做一整条学术消息，依然可以插入到另一个环当中处理。

然后边数很多，需要建立虚点优化建图，这里就不多说了，最后输出方案的时候需要模拟一下插入和断环成链的过程，有些恶心。

最终时间复杂度是 $O(m \sqrt{m})$，用 Dinic 好一些（二分图），ISAP 实现不好会被卡爆。

## 代码

很丑，凑合着看吧。

```cpp
#include<bits/stdc++.h>
#define N 2000005
#define K 200005
using namespace std;
vector<int> idd1[K],idd2[K],has[K];
int T,n,m,i,j,s,t,inf,in_cir[K],vid1[N],vid2[N],inn[N],outt[N],la[N],p1[K],p2[K],ne[N],val[N],to[N],cur[N],CNT,dis[N],in[N],out[N],id1[N],id2[N],vis[N],viss[N],q[N],too[K],du[K],he,ta,ans,tot,fir[K],sec[K];
int nid1[K],nid2[K],nid_tot,vis1[K],vis2[K],vis3[K],vis4[K];
string ss[K],s1[K],s2[K],s3[K];
unordered_map<string,int> maps;
unordered_map<int,int> idd[K];
inline void merge(int x,int y,int z){
	tot++,ne[tot] = la[x],la[x] = tot,to[tot] = y,val[tot] = z;
	tot++,ne[tot] = la[y],la[y] = tot,to[tot] = x,val[tot] = 0;
}
bool bfs(){
	for(int i=0;i<inf;i++) dis[i]=-1;
	q[he=ta=1]=s,dis[s]=0;
	while(he<=ta){
		int tmp = q[he++];
		for(int i=la[tmp];i;i=ne[i]){
			if(val[i]>0&&dis[to[i]]==-1){
				dis[to[i]]=dis[tmp]+1;
				q[++ta]=to[i];
			}
		}
	}
	return dis[t]!=-1;
}
int dfs(int x,int step){
	if(x==t||!step) return step;
	int used = 0;
	for(int i=cur[x];i;i=ne[i]){
		cur[x] = i;
		if(dis[to[i]]==dis[x]+1&&val[i]>0){
			int temp = dfs(to[i],min(step-used,val[i]));
			used += temp,val[i] -= temp,val[i^1] += temp;
			if(used==step||dis[s]>=inf) return used;
		}
	}
	return used;
}
char obuf[1<<21],*p3=obuf; 
inline void pc(char c){ 
	p3-obuf<=(1<<20)?(*p3++=c):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=c); 
} 
inline void write(int x){ 
	if(x<0) pc('-'),x=-x; 
	if(x>9) write(x/10); 
	pc(x%10+'0'); 
}
inline char nc(){
	static char buf[1000000],*p=buf,*q=buf;
	return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
}
inline int read_int(){
	int res = 0;
	char c = nc();
	while(c<'0'||c>'9')c=nc();
	while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
	return res;
}
inline string read_string(){
	string res = "";
	char c = nc();
	while(!isgraph(c)) c=nc();
	while(isgraph(c)) res+=c,c=nc();
	return res;
}
inline void output(){
	for(i=1;i<=m;i++){
		if(du[i]==0){
			int tmp = i;
			while(1){
				viss[tmp]=1;
				if(too[tmp]==0) break;
				tmp=too[tmp];
			}
		}
		if(!fir[p1[i]]&&(!p2[i]||(s3[i]!="louxia"&&s3[i]!="loushang"))) fir[p1[i]]=sec[p1[i]]=i,in_cir[i]=(too[i]==0?-1:too[i]);
	}
	for(i=1;i<=m;i++){
		if(!viss[i]){
			int tmp = i;
			while(1){
				viss[tmp]=1;
				if(too[tmp]==0||viss[too[tmp]]) break;
				tmp=too[tmp];
			}
			if(s3[i]=="louxia") too[sec[p2[i]]] = i,sec[p2[i]] = tmp;
			else tmp = too[i],too[i] = fir[p2[i]],fir[p2[i]] = tmp;
		}
	}
	for(i=1;i<=m;i++) viss[i]=0;
	for(i=1;i<=m;i++){
		if(du[i]==0){
			int tmp = i;
			while(1){
				if(in_cir[tmp]){
					int ttt = fir[p1[tmp]];
					while(ttt!=sec[p1[tmp]]) write(ttt),viss[ttt]=1,pc(' '),ttt=too[ttt];
					write(ttt),pc(' '),ttt=too[ttt];
					tmp = (in_cir[tmp]==-1?0:in_cir[tmp]);
					if(tmp==0) break;
				}
				else{
					write(tmp),pc(' ');
					viss[tmp]=1;
					if(too[tmp]==0||viss[too[tmp]]) break;
					tmp=too[tmp];
				}
			}
		}
	}
	pc('\n');
}
int main(){
	T=read_int();
	while(T--){
		maps.clear();
		n=read_int(),m=read_int();
		s=0,t=1,inf=2,tot=1,ans=0,nid_tot=0;
		idd[0].clear(),idd[0].clear();
		for(i=1;i<=n;i++){
			idd[i].clear(),idd1[i].clear(),idd2[i].clear(),fir[i]=sec[i]=0;
			ss[i]=read_string(),maps[ss[i]]=i;
			id1[i] = inf++,id2[i] = inf++,vid1[id1[i]]=i,vid2[id2[i]]=i;
		}
		for(i=1;i<=m;i++){
			too[i]=0,du[i]=0,viss[i]=0,in_cir[i]=0,vis[i]=0;
			s1[i]=read_string(),s2[i]=read_string(),s3[i]=read_string(),p1[i]=maps[s1[i]],p2[i]=maps[s2[i]];
			if(!idd[p1[i]][p2[i]]) idd[p1[i]][p2[i]]=++nid_tot;
			nid1[i]=idd[p1[i]][p2[i]];
			if(!idd[p2[i]][p1[i]]) idd[p2[i]][p1[i]]=++nid_tot;
			nid2[i]=idd[p2[i]][p1[i]];
			if(s3[i]=="louxia"&&p2[i]) vis1[nid1[i]]++;
			if(s3[i]=="loushang"&&p2[i]) vis2[nid1[i]]++;
			in[i] = inf++,out[i] = inf++;
			inn[in[i]] = i,outt[out[i]] = i;
			merge(s,in[i],1),merge(out[i],t,1);
		}
		for(i=1;i<=m;i++){
			if(s3[i]=="louxia"&&p2[i]){
				if(vis3[nid1[i]]){
					vis3[nid1[i]]--;
					vis[i]=1;
					continue;
				}
				if(vis2[nid2[i]]){
					vis2[nid2[i]]--,vis4[nid2[i]]++,vis1[nid1[i]]--;
					vis[i]=1;
					continue;
				}
			}
			if(s3[i]=="loushang"&&p2[i]){
				if(vis4[nid1[i]]){
					vis4[nid1[i]]--;
					vis[i]=1;
					continue;
				}
				if(vis1[nid2[i]]){
					vis1[nid2[i]]--,vis3[nid2[i]]++,vis2[nid1[i]]--;
					vis[i]=1;
					continue;
				}
			}
		}
		for(i=1;i<=m;i++) if(vis[i]&&s3[i]=="louxia") has[nid1[i]].push_back(i);
		for(i=1;i<=m;i++){
			if(vis[i]&&s3[i]=="loushang"){
				too[i] = has[nid2[i]].back();
				du[has[nid2[i]].back()]++;
				has[nid2[i]].pop_back();
			}
		}
		for(i=1;i<=m;i++){
			ans+=vis[i];
			if(vis[i]&&s3[i]=="loushang") merge(id2[p1[i]],out[i],1);
			if(vis[i]&&s3[i]=="louxia") merge(in[i],id1[p1[i]],1);
		}
		for(i=1;i<=m;i++){
			if(vis[i]) continue;
			if(s3[i]=="louxia"&&p2[i]) merge(id1[p2[i]],out[i],1);
			merge(id2[p1[i]],out[i],1);
		}
		for(i=1;i<=m;i++){
			if(vis[i]) continue;
			if(s3[i]=="loushang"&&p2[i]) merge(in[i],id2[p2[i]],1);
			merge(in[i],id1[p1[i]],1);
		}
//		while(bfs()){
//			for(i=0;i<inf;i++) cur[i]=la[i];
//			ans+=dfs(s,1e9);
//		}
		for(i=1;i<=n;i++){
			for(j=la[id1[i]];j;j=ne[j]) if(outt[to[j]]&&val[j]==0) idd1[i].push_back(outt[to[j]]);
			for(j=la[id2[i]];j;j=ne[j]) if(outt[to[j]]&&val[j]==0) idd2[i].push_back(outt[to[j]]);
		}
		for(i=1;i<=m;i++){
			int t1 = 0,t2 = 0;
			for(j=la[in[i]];j;j=ne[j]){
				if(vid1[to[j]]&&val[j]==0){
					too[i] = idd1[vid1[to[j]]].back(),du[idd1[vid1[to[j]]].back()]++;
					idd1[vid1[to[j]]].pop_back();
					t1++;
				}
				if(vid2[to[j]]&&val[j]==0){
					too[i] = idd2[vid2[to[j]]].back(),du[idd2[vid2[to[j]]].back()]++;
					idd2[vid2[to[j]]].pop_back();
					t2++;
				}
			}
		}
		for(i=1;i<=m;i++) inn[in[i]]=0,outt[out[i]]=0;
		for(i=1;i<=n;i++) vid1[id1[i]]=0,vid2[id2[i]]=0;
		for(i=0;i<=inf;i++) dis[i]=0,la[i]=0;
		for(i=0;i<=nid_tot;i++) vis1[i]=vis2[i]=vis3[i]=vis4[i]=0,has[i].clear();
		write(ans),pc('\n');
		output();
	}
	fwrite(obuf,p3-obuf,1,stdout);
	return 0;
}
/*
Input:
1
4 16
A
B
C
D
A abcdefghijkl ABCDEFGHIJKL
B abcdefghijkl ABCDEFGHIJKL
C abcdefghijkl ABCDEFGHIJKL
D abcdefghijkl ABCDEFGHIJKL
C D loushang
C B louxia
B C loushang
D A louxia
B D louxia
A A louxia
D A louxia
C D loushang
D C loushang
B A louxia
B B loushang
A A louxia

Output:
3
*/
```

---

## 作者：Fzrcy (赞：1)

> 题意简述：给你 $m$ 条消息，每条信息是楼下型消息、楼上型消息、学术型消息中的一种，我们要将其重新排列使得符合实际情况的消息尽量多（注意学术型消息不是符合实际情况的），求其这个方案以及这个方案中符合实际情况的消息数量。$m\le 77777,\sum m\le 2.5\times 10^5$。

先考虑性质 C :

对两个点 $x$、$y$，连边 $x\to y$，边权 $w$ 为 $x$ 的上一条信息为 $y$ 时产生的贡献，由于 `A B loushang` 和 `B A louxia` 两种消息不会同时存在，所以 $0\le w \le 1$，所以最优方案就是一条不重复经过 $n$ 个点的简单路径，使得路径权值最大。若删去 $w=0$ 的边，则最优解就是该图的最小路径覆盖。

我们对原图建立二分图，若存在 $x\to y$，则在二分图上连边 $x\to y'$，然后求出最大匹配即可。

然而原图不一定是一个 DAG，所以求出的解可能存在环，于是我们考虑如何消除环。不难发现环上的信息的类型均相同（均为楼下或楼上型消息），我们对环上的信息的类型分类讨论即可。

以楼上型信息为例，设环上存在边 $A\to B$，设 $a$ 表示发出信息 $A$ 的人发出的学术消息，$t$ 表示最小路径覆盖中 $a$ 指向的下一条消息，则我们删去边 $A\to B$ 和 $a\to t$，并连边 $a\to B$ 和 $A\to t$，显然变换后答案不变。

然后考虑 `A B loushang`（设其为第 $x$ 条消息）和 `B A louxia`（设其为第 $y$ 条消息）两种消息同时存在的情况，不难发现一定存在一种最优解使得第 $x$ 条信息一定在第 $y$ 条信息上面，所以我们对二分图做一点修改，删去 $x$ 到右部点的边和左部点到 $y$ 的边，再跑最大匹配，然后再求出的方案中连边 $y\to x$，最后将所有的环消除即可。

直接建立二分图的边数是 $O(m^2)$ 的，显然我们可以用虚点优化建图，将边数降到 $O(m)$，总时间复杂度为 $O(\sum m^{1.5})$。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
constexpr int N=4e5+9;
struct dinic{
    int h[N],nt[N*20],to[N*20],cap[N*20],cnt;
    int c[N],vis[N],d[N],s,t,tt,from[N*20];
    void cls(int n){
        cnt=1,s=t=tt=0;
        for(int i=1;i<=n;i++)
            h[i]=c[i]=vis[i]=d[i]=0;
    }
    void Add(int u,int v,int w){
        //cout<<u<<' '<<v<<'\n';
        nt[++cnt]=h[u],h[u]=cnt,to[cnt]=v,cap[cnt]=w,from[cnt]=u;
        nt[++cnt]=h[v],h[v]=cnt,to[cnt]=u,cap[cnt]=0;
    }
    bool bfs(){
        for(int i=1;i<=tt;i++)c[i]=h[i],vis[i]=d[i]=0;
        queue<int>q;q.push(s),d[s]=0,vis[s]=1;
        while(!q.empty()){
            int u=q.front();q.pop();
            for(int i=h[u],v;i;i=nt[i])
                if(!vis[v=to[i]]&&cap[i])
                    vis[v]=1,d[v]=d[u]+1,q.push(v);
        }
        return vis[t];
    }
    int dfs(int u,int a){
        if(u==t||a==0)return a;
        int f=0,tot=0;
        for(int &i=c[u],v;i;i=nt[i]){
            if(d[v=to[i]]==d[u]+1&&(f=dfs(v,min(cap[i],a)))>0){
                cap[i]-=f,cap[i^1]+=f,tot+=f,a-=f;if(!a)break;
            }
        }
        return tot;
    }
    int sol(int _s,int _t,int _tt){
        s=_s,t=_t,tt=_tt; int F=0;
        while(bfs())F+=dfs(s,1e9);
        return F;
    }
}g;
namespace Work{
    typedef long long ll;
    map<string,int>vt;
    unordered_map<ll,vector<int>>num;
    vector<int>In[N],Out[N];
    int n,m,sum,idx[N];
    int From[N],To[N];
    string Str[N][3];
    bool ban[N];
    void cls(){
        int t=max(n,m)*3;
        for(int i=1;i<=t;i++)
            idx[i]=From[i]=To[i]=ban[i]=0,
            In[i].clear(),Out[i].clear();
        sum=0,num.clear(),vt.clear();
    }
    int StrId(int x){
        if(Str[x][2]==  "louxia"&&vt.count(Str[x][1]))
            return 1;
        if(Str[x][2]=="loushang"&&vt.count(Str[x][1]))
            return 2;
        return 3;
    }
    inline bool cr(int x,int u){
        if(x==u)return 1;
        if(!x)return 0;
        return cr(To[x],u);
    }
    inline void cov(int x){
        if(ban[x]||!x)return;
        ban[x]=1;
        cov(From[x]);
        cov(To[x]);
    }
    int Main(){
        cin>>n>>m,cls();
        for(int i=1;i<=n;i++){
            string str;
            cin>>str,vt[str]=i;
        }
        for(int i=1,s1,s2,s3;i<=m;i++){
            string S1,S2,S3;
            cin>>S1>>S2>>S3;
            Str[i][0]=S1;
            Str[i][1]=S2;
            Str[i][2]=S3;
            s1=vt[S1];
            if(StrId(i)==1){
                s2=vt[S2];
                //cout<<s1<<' '<<s2<<" 下"<<'\n';
                ll ms=((ll)s1*1000000ll+s2)<<1|0;
                ll fn=((ll)s2*1000000ll+s1)<<1|1;
                auto &vec=num[fn];
                if(vec.size()){
                    int oth=vec.back();
                    vec.pop_back();
                    sum+=2;
                    To[i]=oth;
                    From[oth]=i;
                }
                else{
                    num[ms].push_back(i);
                }
            }
            else if(StrId(i)==2){
                s2=vt[S2];
                //cout<<s1<<' '<<s2<<" 上"<<'\n';
                ll ms=((ll)s1*1000000ll+s2)<<1|1;
                ll fn=((ll)s2*1000000ll+s1)<<1|0;
                auto &vec=num[fn];
                if(vec.size()){
                    int oth=vec.back();
                    vec.pop_back();
                    sum+=2;
                    To[oth]=i;
                    From[i]=oth;
                }
                else{
                    num[ms].push_back(i);
                }
            }
            else idx[s1]=i;//,cout<<s1<<" 学术"<<'\n';
        }
        //cout<<sum<<'\n';
        int s=2*m+3*n+1,t=s+1;
        g.cls(t);
        for(int i=1;i<=m;i++){
            if(!To[i])g.Add(s,i,1);
            if(!From[i])g.Add(i+m,t,1);
        }
        //puts("OK");
        for(int i=1;i<=m;i++){
            int id=vt[Str[i][0]];
            g.Add(2*m+id,i+m,1); // id 说的话。
            if(StrId(i)==2) // vt[Str[i][1]] 楼上 
                g.Add(2*m+n+vt[Str[i][1]],i+m,1);
        }
        //puts("ok");
        for(int i=1;i<=m;i++){
            int id=vt[Str[i][0]];
            g.Add(i,2*m+n+id,1);
            if(StrId(i)==1)
                g.Add(i,2*m+vt[Str[i][1]],1);
        }
        sum+=g.sol(s,t,t);
        cout<<sum<<'\n';
        for(int i=2;i<=g.cnt;i+=2)if(!g.cap[i]){
            int u=g.from[i],v=g.to[i];
            if(u==s||v==t)continue;
            if(u<=m)In[v].push_back(u);
            if(v>m&&v<=2*m)Out[u].push_back(v-m);
        }
        for(int i=2*m+1;i<s;i++){
            int sz=In[i].size();
            // assert(In[i].size()==Out[i].size());
            for(int j=0;j<sz;j++){
                From[Out[i][j]]=In[i][j];
                To[In[i][j]]=Out[i][j];
            }
        }
        for(int i=1;i<=m;i++)if(!ban[i]){
            if(cr(To[i],i)){
                int j=From[i];
                if(Str[j][2]=="loushang"){
                    int J=idx[vt[Str[j][0]]];
                    int nv=To[J];
                    To[J]=i,From[i]=J;
                    To[j]=nv,nv&&(From[nv]=j);
                }
                else{
                    int I=idx[vt[Str[i][0]]];
                    int nv=From[I];
                    To[j]=I,From[I]=j;
                    From[i]=nv,nv&&(To[nv]=i);
                }
            }
            cov(i);
        }
        for(int i=1;i<=m;i++)if(!To[i]){
            int x=i;
            while(x)
                cout<<x<<' ',
                x=From[x];
        }
        cout<<'\n';
        return 0;
    }
}
int main(){
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T;
    cin>>T;
    while(T--)
        Work::Main();
    return 0;
}
```



---


# [集训队互测 2018] 完美的集合

## 题目描述

小 A 有一棵 $N$ 个点的带边权的树，树的每个节点有重量 $w_i$ 和价值 $v_i$。

现在小 A 要从中选出若干个节点形成一个集合 $S$，满足这些节点重量之和 $\leq M$ 并且构成一个连通块。小 A 是一个完美主义者，因此他只会选择节点价值之和最大的那些 $S$。我们称这样的集合 $S$ 为完美的集合。

现在小 $A$ 要从所有完美的集合中选出 $K$ 个，并对这 $K$ 个完美的集合分别进行测试。在这 $K$ 次测试开始前，小 A 首先需要一个点 $x$ 来放置他的测试装置，这个测试装置的最大功率为 $Max$。

接下来的每次测试，小 A 会对测试对象 $S$ 中的所有点进行一次能量传输，对一个点 $y$ 进行能量传输需要的功率为 $dist(x,y)\times v_y$，其中 $dist(x,y)$ 表示点 $x,y$ 在树上的最短路长度。因此，如果 $S$ 中存在一个点 $y$，满足 $dist(x,y)\times v_y>Max$，测试就会失败。同时，为了保证能量传输的稳定性，测试装置所在的点 $x$ 需要在集合 $S$ 中，否则测试也会失败。

现在小 A 想知道，有多少种从所有完美的集合选出 $K$ 个的方法，使得他能找到一个放置测试装置的点，来完成他的测试呢？

你只需要输出方案数对 $11920928955078125$ 取模的结果。

## 说明/提示

### 样例解释

完美的集合有 $\{1,2,5\},\{1,4\},\{2,6\}$。

从中选出 $K$ 个且能完成测试的方案为选择 $\{1,2,5\},\{1,4\}$ 或选择 $\{1,2,5\},\{2,6\}$。

### 数据范围

|子任务编号	|	$N\leq$	|	$M\leq$	|	$K\leq$	|		特殊性质			|	分值		|
|:----------------:|:----------------:|:----------------:|:----------------:|:-----------------------------------:|:----------------:|
|	$1$		|	$17$	|	$150$	|	$10^9$	|						|	$13$	|
|	$2$		|	$60$	|	$10000$	|	$1$		|						|	$11$	|
|	$3$		|	$60$	|	$2$		|	$10^4$	|	$w_1=\dots=w_N=1$	|	$19$	|
|	$4$		|	$40$	|	$1200$	|	$10^9$	|						|	$20$	|
|	$5$		|	$60$	|	$10000$	|	$10^4$	|						|	$15$	|
|	$6$		|	$60$	|	$10000$	|	$10^9$	|						|	$22$	|

对于 $100\%$ 的数据，$N\leq 60$，$M\leq 10000$，$C_i\leq 10000$，$K,w_i,v_i\leq 10^9$，$Max\leq 10^{18}$。

## 样例 #1

### 输入

```
7 3 2 4
1 1 2 2 1 2 2
1 1 1 2 1 2 2
1 2 1
1 3 2
1 4 2
2 5 1
2 6 2
4 7 3```

### 输出

```
2```

# 题解

## 作者：crashed (赞：4)

# 题目

[点这里](https://www.luogu.com.cn/problem/P9248)看题目。

# 分析

“选 $K$ 个”的要求是依托答辩，先不管它，考虑 $K=1$ 的情况。

注意到，对于定点 $y$，满足 $\operatorname{dist}(x,y)\times v_y>\mathrm{Max}$ 的 $x$ 构成树上的一个连通块。于是，对于任意一个集合 $S$，可以放置测试装置的点**也构成树上的一个连通块**。因此，做一个“点-边容斥”即可将问题转化为“使得点 $x$（或边 $(x,y)$ 的两个端点）可以放置测试装置的完美的集合有多少个？”。

统计根为某顶点的连通块的信息是容易的，此处就有一个 $O(nm)$ 的算法。于是，先用一个 $O(n^2m)$（或 $O(nm\log n)$）的算法计算出完美的集合的结点价值之和，再花 $O(n^2m)$ 的时间做上述容斥，复杂度即为 $O(n^2m)$。

加入“选 $K$ 个”的要求后，我们发现对于一个集簇 $\mathcal F$，可以放置测试装置的点还是形成一个树上的连通块，于是“点-边容斥”还是可行的。只不过，如果“使得点 $x$（或边 $(x,y)$ 的两个端点）可以放置测试装置的完美的集合”的个数为 $t$，原先贡献为 $\pm t$，现在贡献为 $\pm\binom{t}{K}$，这一点和[「十二省联考 2019」希望](https://www.luogu.com.cn/problem/P5291)一模一样。

-------

（正片开始）

问题的主要矛盾来到了“计算 $\binom{t}{K}$”，其中 $t,K$ 都是（相对于通常情况而言）非常大的数。不过，因为 $t\le 2^n$，所以上下指标都还能存得下真实值。

此时就不得不研究模数的性质了。进行一个质因数分解，**发现 $M=11920928955078125=5^{23}$**，非常的 smooth。所以，我们考虑使用扩展 Lucas 算法。

扩展 Lucas 算法关键为：对于 $n$，求出 $\prod_{1\le k\le n,5\nmid k}k$。在模数较小时，我们可以直接利用乘积式的周期性预处理，但现在不行。考虑常规策略——**分治计算**。特别地，因为结果和模 $5$ 的余数有关，我们考虑从它开始进行分治。

假如现在要对于 $n>1$，求出 $g(n)=\prod_{1\le k\le n,5\nmid k}k$。设 $m=\lceil\log_5 n\rceil-1$ 为满足 $5^m<n$ 的最大的整数，并设 $r=\lceil\frac n {5^m}\rceil-1$。当 $m\ge 1$ 时，我们可以将乘积式划分为：

$$
\prod_{t=0}^{r-1}\left(\prod_{t\times 5^m< k\le (t+1)\times 5^m,5\nmid k}k\right)\cdot \prod_{r\times 5^m< k\le n,5\nmid k}k
$$

注意到 **$r\times 5^m+k$ 对于 $5$ 的整除性和 $k$ 相同**，所以有：

$$
\prod_{r\times 5^m< k\le n,5\nmid k}k=\prod_{0< k\le n-r\times 5^m,5\nmid k}(k+r\times 5^m)
$$

要想快速地计算这个式子，我们可以考虑计算出 $f_{n}(x)=\prod_{0<k\le n,5\nmid k}(x+k)$，这样就将 $n$ 减小，变成了子问题。对于前面若干个长度为 $5^m$ 的部分做类似处理，我们要算的就是：

$$
f_n(x)=\prod_{t=0}^{r-1}f_{5^m}(x+t\times 5^m)\cdot f_{n-r\times 5^m}(x+r\times 5^m)
$$

问题来了：这个多项式可能很长，怎么办？观察到三条性质：

- $g(n)=[x^0]f_n(x)$，也就是我们只需要保证它的常数项是对的就好。

- 答案对于 $5^{23}$ 取模，而**复合的一次式的常数项一定是 $5$ 的倍数**。

- 合并子问题时，基本运算为“复合一次式”和“卷积”，其中只有“复合一次式”会产生高次项到低次项的影响。而计算 $f(x+c)$ 的过程中，**$x^{t}$ 到 $x^0$ 的贡献必然带有 $c^t$ 的因子**。即便是多次复合，包含参数的因式也是一个次数为 $t$ 的齐次式。

以上三条可以导出，次数不低于 $23$ 的项都可以被舍弃，因为它们不会再对常数项造成影响。这样多项式就变得很轻巧了，可以快速地完成运算。

特别地，当 $m=0$ 时，$5^m$ 不再是 $5$ 的倍数。不过，这个边界情况下，直接暴力算一下多项式的乘积即可。

具体操作的时候，需要对于每一个 $m$ 都预处理出 $f_{5^m}(x)$，最好还可以预处理一个 $\prod_{t=0}^{r-1}f_{5^m}(x+t\times 5^m)$ 的前缀积。

复杂度不算了，能过就是了。

# 代码

```cpp
#include <bits/stdc++.h>

#define rep( i, a, b ) for( int i = (a) ; i <= (b) ; i ++ )
#define per( i, a, b ) for( int i = (a) ; i >= (b) ; i -- )

typedef long long LL;
typedef  __int128 ExLL;

const LL mod = 11920928955078125;
const int MAXLOG = 30, MAXN = 65, MAXM = 10005;

template<typename _T>
inline void Read( _T &x ) {
    x = 0; char s = getchar(); bool f = false;
    while( s < '0' || '9' < s ) { f = s == '-', s = getchar(); }
    while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
    if( f ) x = -x;
}

template<typename _T>
inline void Write( _T x ) {
    if( x < 0 ) putchar( '-' ), x = -x;
    if( 9 < x ) Write( x / 10 );
    putchar( x % 10 + '0' );
}

inline LL Sub( LL x, const LL &v ) { return ( x -= v ) < 0 ? x + mod : x; }
inline LL Add( LL x, const LL &v ) { return ( x += v ) >= mod ? x - mod : x; }

inline LL& SubEq( LL &x, const LL &v ) { return ( x -= v ) < 0 ? ( x += mod ) : x; }
inline LL& AddEq( LL &x, const LL &v ) { return ( x += v ) >= mod ? ( x -= mod ) : x; }

namespace PureCalculation {
    struct Poly {
        LL coe[23];

        Poly(): coe{} {}
    };

    Poly bas[MAXLOG], pref[MAXLOG][6];
    LL sml[23][23], pw[23], pw5[MAXLOG];
    LL vpK, factK; int K;

    inline LL Inv( LL base, LL indx = 9536743164062500 - 1 ) {
        LL ret = 1;
        while( indx ) {
            if( indx & 1 ) ret = ( ExLL ) ret * base % mod;
            base = ( ExLL ) base * base % mod, indx >>= 1;
        }
        return ret;
    }

    inline Poly operator * ( const Poly &a, const Poly &b ) {
        Poly ret; ExLL tmp;
        rep( i, 0, 22 ) {
            tmp = 0;
            rep( j, 0, i )
                tmp += ( ExLL ) a.coe[j] * b.coe[i - j];
            ret.coe[i] = tmp % mod;
        }
        return ret;
    }

    inline Poly Shift( const Poly &f, const LL &c ) {
        if( ! c ) return f;
        Poly ret; ExLL tmp;
        pw[0] = 1; 
        rep( i, 1, 22 ) pw[i] = ( ExLL ) pw[i - 1] * c % mod;
        rep( i, 0, 22 ) {
            tmp = 0;
            rep( j, i, 22 )
                tmp += ( ExLL ) f.coe[j] * pw[j - i] * sml[j][i];
            ret.coe[i] = tmp % mod;
        }
        return ret;
    }

    inline Poly PartialFactorial( const int &lvl, const LL &n ) {
        if( lvl == 0 ) return pref[0][n];
        int idx = ( n - 1 ) / pw5[lvl];
        if( ! idx ) return PartialFactorial( lvl - 1, n );
        return Shift( PartialFactorial( lvl - 1, n - idx * pw5[lvl] ), idx * pw5[lvl] ) * pref[lvl][idx];
    }

    inline LL Factorial( const LL &n ) {
        if( n == 0 ) return 1;
        return ( ExLL ) PartialFactorial( 25, n ).coe[0] * Factorial( n / 5 ) % mod;
    }

    inline LL Legendre( LL n ) {
        LL ret = 0;
        for( ; n ; ret += n /= 5 );
        return ret;
    }

    inline LL Binom( const LL &n ) {
        if( n < K ) return 0;
        LL idx = Legendre( n ) - vpK - Legendre( n - K );
        if( idx >= 23 ) return 0;
        LL a = Factorial( n ), c = Factorial( n - K );
        return ( ExLL ) a * Inv( c ) % mod * factK % mod * pw5[idx] % mod;
    }

    inline void Init( const int &k ) {
        K = k, pw5[0] = 1;
        rep( i, 1, 25 ) pw5[i] = pw5[i - 1] * 5;
        rep( i, 0, 22 ) {
            sml[i][0] = 1;
            rep( j, 1, i )
                sml[i][j] = Add( sml[i - 1][j], sml[i - 1][j - 1] );
        }
        bas[0].coe[0] = bas[0].coe[1] = 1;
        pref[0][0].coe[0] = 1;
        rep( i, 1, 4 ) {
            Poly tmp;
            tmp.coe[0] = i, tmp.coe[1] = 1;
            pref[0][i] = pref[0][i - 1] * tmp;
        }
        pref[0][5] = pref[0][4];
        rep( i, 1, 25 ) {
            bas[i] = pref[i - 1][5];
            pref[i][0].coe[0] = 1;
            rep( j, 1, 5 )
                pref[i][j] = pref[i][j - 1] * Shift( bas[i], pw5[i] * ( j - 1 ) );
        }
        vpK = Legendre( K );
        factK = Inv( Factorial( K ) );
    }
}

namespace OnTree {
    struct Edge {
        int to, nxt, w;
    } Graph[MAXN << 1];

    struct Values {
        LL val, cnt;
    
        Values(): val( -1 ), cnt( 0 ) {}
        Values( LL V ): val( V ), cnt( 1 ) {}
        Values( LL V, LL C ): val( V ), cnt( C ) {}

        inline void operator += ( const Values &q ) {
            if( q.val  > val ) val = q.val, cnt = 0;
            if( q.val == val ) cnt += q.cnt;
        }

        inline Values operator + ( const Values &q ) const {
            if( val > q.val ) return *this;
            if( val < q.val ) return q;
            return Values( val, cnt + q.cnt );
        }

        inline Values operator * ( const Values &q ) const {
            return Values( val + q.val, cnt * q.cnt );
        }
    };

    Values dp[MAXN][MAXM];
    LL dist[MAXN][MAXN];

    int seq[MAXN], siz[MAXN], tot = 0;
    int edgFr[MAXN], edgTo[MAXN];
    int head[MAXN], cnt = 1;

    int wei[MAXN], val[MAXN];

    int N, M, K; LL lim;

    inline void AddEdge( const int &from, const int &to, const int &W ) {
        Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
        Graph[cnt].w = W, head[from] = cnt;
    }

    inline void Input() {
        Read( N ), Read( M ), Read( K ), Read( lim );
        rep( i, 1, N ) Read( wei[i] );
        rep( i, 1, N ) Read( val[i] );
        rep( i, 1, N - 1 ) {
            int u, v, w;
            Read( u ), Read( v ), Read( w );
            AddEdge( u, v, w ), AddEdge( v, u, w );
            edgFr[i] = u, edgTo[i] = v;
        }
    }

    void ProcessDist( const int &u, const int &fa, LL *d ) {
        for( int i = head[u], v ; i ; i = Graph[i].nxt )
            if( ( v = Graph[i].to ) ^ fa )
                d[v] = d[u] + Graph[i].w, ProcessDist( v, u, d );
    }
    
    void DFS( const int &u, const int &fa ) {
        seq[++ tot] = u, siz[u] = 1;
        for( int i = head[u], v ; i ; i = Graph[i].nxt )
            if( ( v = Graph[i].to ) ^ fa )
                DFS( v, u ), siz[u] += siz[v];
    }

    inline void ClearDP() {
        rep( i, 1, N + 1 )
            rep( j, 0, M )
                dp[i][j] = Values();
    }

    inline void Solve() {
        Input();
        rep( i, 1, N )
            ProcessDist( i, 0, dist[i] );
        PureCalculation :: Init( K );

        Values glb;
        rep( i, 1, N ) {
            tot = 0, DFS( i, 0 );
            ClearDP(), dp[1][0] = Values( 0 );
            rep( j, 1, N ) {
                int u = seq[j];
                rep( k, 0, M ) 
                    if( dp[j][k].val >= 0 )
                        dp[j + siz[u]][k] += dp[j][k];
                if( wei[u] <= M ) {
                    Values delt( val[u] );
                    rep( k, 0, M - wei[u] )
                        if( dp[j][k].val >= 0 )
                            dp[j + 1][k + wei[u]] += dp[j][k] * delt;
                }
            }
            rep( k, 0, M ) 
                glb += dp[N + 1][k];
        }

        LL ans = 0;
        rep( i, 1, N ) {
            if( wei[i] > M ) continue;
            tot = 0, DFS( i, 0 );
            ClearDP(), dp[1][0] = Values( 0 );
            rep( j, 1, N ) {
                int u = seq[j];
                if( u != i ) {
                    rep( k, 0, M )
                        if( dp[j][k].val >= 0 )
                            dp[j + siz[u]][k] += dp[j][k];
                }
                if( wei[u] <= M && ( ExLL ) dist[i][u] * val[u] <= lim ) {
                    Values delt( val[u] );
                    rep( k, 0, M - wei[u] )
                        if( dp[j][k].val >= 0 )
                            dp[j + 1][k + wei[u]] += dp[j][k] * delt;
                }
            }
            LL num = 0;
            rep( k, 0, M )
                if( glb.val == dp[N + 1][k].val )
                    num += dp[N + 1][k].cnt;
            AddEq( ans, PureCalculation :: Binom( num ) );
        }
        rep( i, 1, N - 1 ) {
            int x = edgFr[i], y = edgTo[i];
            if( wei[x] + wei[y] > M ) continue;
            tot = 0, DFS( x, 0 );
            ClearDP(), dp[1][0] = Values( 0 );
            rep( j, 1, N ) {
                int u = seq[j];
                if( u != x && u != y ) {
                    rep( k, 0, M )
                        if( dp[j][k].val >= 0 )
                            dp[j + siz[u]][k] += dp[j][k];
                }
                if( wei[u] <= M && ( ExLL ) dist[x][u] * val[u] <= lim &&
                                   ( ExLL ) dist[y][u] * val[u] <= lim ) {
                    Values delt( val[u] );
                    rep( k, 0, M - wei[u] )
                        if( dp[j][k].val >= 0 )
                            dp[j + 1][k + wei[u]] += dp[j][k] * delt;
                }
            }
            LL num = 0;
            rep( k, 0, M )
                if( glb.val == dp[N + 1][k].val )
                    num += dp[N + 1][k].cnt;
            SubEq( ans, PureCalculation :: Binom( num ) );
        }
        Write( ans ), putchar( '\n' );
    }
}

int main() {
    OnTree :: Solve();
    return 0;
}
```

---

## 作者：tzc_wk (赞：2)

显然，如果选择的 $k$ 个“合法集合”固定了，那么可以放置装置的点如果存在，那么必然形成一个连通块，也就是说，答案等于所有合法方案中，可以放置装置的点形成的连通块个数之和。而根据点减边的套路，这等价于，枚举每个点，计算有多少种方案满足可以在其放置装置，再枚举每条边，计算有多少种方案满足这条边两个端点都可以放置转置，二者相减。

以点为例，这样那个 $\text{dis}(x,y)·v_y\le \text{Max}$ 相当于一部分点不能选择，而剩下的点中选择需要形成一个以 $x$ 为根的连通块，这时候有一个经典的处理树上连通块问题的 DP 模型就是先将 DP 值传给儿子，DFS 一圈以后再将儿子的 DP 值与父亲合并，本质上来说这相当于在欧拉序上进行背包。这样我们可以在 $O(nm)$ 的时间内计算有多少个合法集合满足 $x$ 点可以放置装置，$\dbinom{cnt}{k}$ 就是选出 $k$ 个这样的集合的方案数。

然后你瞟一眼数据范围发现 $k$ 数据范围达到 $10^9$，并且模数很怪，分解质因数一下发现竟然是 $5^{23}$。因此我们还要再思考一下怎么计算这个大组合数。显然这等价于计算 $n!$ 中 $5$ 的次数与所有与 $5$ 互质的数的乘积。前者是好求的，考虑怎么计算后者，我们记 $F_n(x)$ 表示 $1\sim 5n$ 中所有与 $5$ 互质的 $i$ 的 $x+i$ 的乘积形成的多项式。这样我们对后面零头部分暴力算，剩余部分等价于 $F_{\lfloor\frac{n}{5}\rfloor}(0)$。考虑倍增，显然 $F_{2n}(x)=F_{n}(x)·F_{n}(x+5n)$，后面的那部分可以用二项式定理拆开，由于 $5n$ 一定是 $5$ 的倍数，因此二项式定理的时候，$x^{23}$ 以上的项是没有用的，我们只用存前 $23$ 项的系数即可。

时间复杂度 $n^2m+n·(23^2·\log V)$

```cpp
typedef __int128_t i128;
const ll MOD=11920928955078125ll;
ll mul(i128 x,i128 y){return x*y%MOD;}
namespace Binomial{
	ll pw5[25],c[25][25];
	struct poly{
		ll v[25];
		poly(){memset(v,0,sizeof(v));}
		friend poly operator *(const poly &X,const poly &Y){
			poly res;
			for(int i=0;i<=23;i++)for(int j=0;j+i<=23;j++)
				res.v[i+j]=(res.v[i+j]+mul(X.v[i],Y.v[j]))%MOD;
			return res;
		}
	}f[65];//F_{5*2^i}(x)
	poly shift(poly x,ll v){
		static ll pw[25];poly res;
		for(int i=(pw[0]=1);i<=23;i++)pw[i]=mul(pw[i-1],v);
		for(int i=0;i<=23;i++)for(int j=0;j<=i;j++)
			res.v[j]=(res.v[j]+mul(mul(c[i][j],pw[i-j]),x.v[i]))%MOD;
		return res;
	}
	ll calc_pw5(ll x){if(!x)return 0;return x/5+calc_pw5(x/5);}
	void exgcd(ll x,ll y,ll &a,ll &b){
		if(!y)return a=1,b=0,void();
		exgcd(y,x%y,a,b);ll tmp=a;a=b;b=tmp-x/y*b;
	}
	ll inv(ll x){ll a,b;exgcd(x,MOD,a,b);return (a+MOD)%MOD;}
	ll calc_prd(ll x){
		poly prd;prd.v[0]=1;ll sum=0;
		for(int i=60;~i;i--)if((x/5)>>i&1)prd=prd*shift(f[i],sum),sum+=5ll<<i;
		ll res=prd.v[0];
		for(ll i=x/5*5+1;i<=x;i++)if(i%5)res=mul(res,i);
		return res;
	}
	ll calc(ll x){if(!x)return 1;return mul(calc_prd(x),calc(x/5));}
	ll binom(ll n,ll k){
		if(n<0||k<0||n<k)return 0;
		ll pw=calc_pw5(n)-calc_pw5(k)-calc_pw5(n-k);
		if(pw>=23)return 0;
		else{
			ll A=calc(n),B=calc(k),C=calc(n-k);
			return mul(mul(A,inv(B)),mul(inv(C),pw5[pw]));
		}
	}
	void init(){
		for(int i=(pw5[0]=1);i<=23;i++)pw5[i]=pw5[i-1]*5;
		for(int i=0;i<=23;i++){
			c[i][0]=1;
			for(int j=1;j<=i;j++)c[i][j]=c[i-1][j]+c[i-1][j-1];
		}
		f[0].v[0]=24;f[0].v[1]=50;f[0].v[2]=35;f[0].v[3]=10;f[0].v[4]=1;
		for(int i=1;i<=60;i++)f[i]=f[i-1]*shift(f[i-1],5ll<<i-1);
	}
}
ll binom(ll n,ll k){return Binomial::binom(n,k);}
const int MAXN=60;
const int MAXM=1e4;
int n,m,k,w[MAXN+5],v[MAXN+5],hd[MAXN+5],to[MAXN*2+5],nxt[MAXN*2+5],val[MAXN*2+5],ec;ll mx;
void adde(int u,int v,int w){to[++ec]=v;val[ec]=w;nxt[ec]=hd[u];hd[u]=ec;}
int dis[MAXN+5][MAXN+5];
void dfs0(int x,int f,int rt){
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e],z=val[e];if(y==f)continue;
		dis[rt][y]=dis[rt][x]+z;dfs0(y,x,rt);
	}
}
struct dat{
	ll mx,cnt;
	dat(){mx=-1e18;cnt=0;}
	dat(ll _mx,ll _cnt){mx=_mx;cnt=_cnt;}
	friend dat operator +(const dat &X,const dat &Y){
		dat ret;ret.mx=max(X.mx,Y.mx);ret.cnt=0;
		if(X.mx==ret.mx)ret.cnt+=X.cnt;
		if(Y.mx==ret.mx)ret.cnt+=Y.cnt;
		return ret;
	}
}dp[MAXN+5][MAXM+5];
bool ban[MAXN+5];
void dfs(int x,int f){
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f||ban[y])continue;
		for(int i=0;i+w[y]<=m;i++)dp[y][i+w[y]]=dat(dp[x][i].mx+v[y],dp[x][i].cnt);
		dfs(y,x);for(int i=0;i<=m;i++)dp[x][i]=dp[x][i]+dp[y][i];
	}
}
ll mx_val;
ll calc_val(int x){
	for(int i=1;i<=n;i++)for(int j=0;j<=m;j++)dp[i][j]=dat();
	dp[x][w[x]]=dat(v[x],1);dfs(x,0);dat res;
	for(int i=0;i<=m;i++)res=res+dp[x][i];
	return res.mx;
}
ll calc_vert(int x){
	memset(ban,0,sizeof(ban));
	for(int i=1;i<=n;i++)if(1ll*dis[i][x]*v[i]>mx)ban[i]=1;
	for(int i=1;i<=n;i++)for(int j=0;j<=m;j++)dp[i][j]=dat();
	dp[x][w[x]]=dat(v[x],1);dfs(x,0);dat res;
	for(int i=0;i<=m;i++)res=res+dp[x][i];
	return (res.mx==mx_val)?binom(res.cnt,k):0;
}
ll calc_edge(int x,int y){
	memset(ban,0,sizeof(ban));
	for(int i=1;i<=n;i++)if(1ll*dis[i][x]*v[i]>mx||1ll*dis[i][y]*v[i]>mx)ban[i]=1;
	if(ban[x]||ban[y])return 0;
	for(int i=1;i<=n;i++)for(int j=0;j<=m;j++)dp[i][j]=dat();
	dp[x][w[x]]=dat(v[x],1);dp[y][w[y]]=dat(v[y],1);dfs(x,y);dfs(y,x);
	for(int i=1;i<=m;i++)dp[y][i]=dp[y][i]+dp[y][i-1];
	dat res;for(int i=0;i<=m;i++)res=res+dat(dp[x][i].mx+dp[y][m-i].mx,1ll*dp[x][i].cnt*dp[y][m-i].cnt);
	return (res.mx==mx_val)?binom(res.cnt,k):0;
}
int main(){
	Binomial::init();scanf("%d%d%d%lld",&n,&m,&k,&mx);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=1;i<=n;i++)scanf("%d",&v[i]);
	for(int i=1,u,v,w;i<n;i++)scanf("%d%d%d",&u,&v,&w),adde(u,v,w),adde(v,u,w);
	for(int i=1;i<=n;i++)dfs0(i,0,i);
	for(int i=1;i<=n;i++)chkmax(mx_val,calc_val(i));
	ll res=0;
	for(int i=1;i<=n;i++)if(w[i]<=m)res=(res+calc_vert(i))%MOD;
	for(int i=1;i<=n;i++)for(int e=hd[i];e;e=nxt[e]){
		int j=to[e];
		if(i<j&&w[i]+w[j]<=m)res=(res-calc_edge(i,j)+MOD)%MOD;
	}
	printf("%lld\n",res);
	return 0;
}
```



---


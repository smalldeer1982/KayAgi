# [MtOI2018] 魔力环

## 题目背景

wkr 是一名来自魔力之都的 OIer，他喜欢收集黑色与白色的魔力珠。

## 题目描述

wkr 希望能够得到一个由 $n$ 个魔力珠串成的环。不过他对普通的环并不感兴趣，因此他提出了如下的要求：

- wkr 希望在这个环上，**恰好**有 $m$ 个黑色的魔力珠与 $n - m$ 个白色的魔力珠。
- 由于 wkr 认为黑色魔力珠不应过于密集，因此 wkr 希望这个环上**不会**出现一段**连续**的黑色魔力珠，其长度**超过** $k$。

在 wkr 的心目中，满足上述要求的环才是美妙的。

不过这样的环可能并不唯一。 wkr 想要知道共有多少种不同的环满足他所提出的要求。然而 wkr 并不喜欢计算，他希望聪明的你能够告诉他答案。

在这里，我们认为**两个环是不同的，当且仅当其中一个环仅通过旋转无法得到另一个环**。

由于答案可能过大，因此输出答案对 $998, 244, 353$ 取模后的结果。

## 说明/提示

#### 样例 $1$ 解释

由 $6$ 个魔力珠串成，满足其中恰好有 $3$ 个黑色魔力珠与 $3$ 个白色魔力珠，且不存在长度超过 $2$ 的连续的黑色魔力珠的不同的环共有 $3$ 种，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/cqi70gls.png)

下图所示的环不满足 wkr 提出的要求，因为在这个环中，存在一段连续的黑色魔力珠，长度超过了 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/1a5enl8k.png)

### 子任务

所有测试点均满足 $1 \leq n, k \leq 10^5, 0 \leq m \leq 10^5$ 且 $m \leq n$。

本题采用捆绑测试，共有 $7$ 个子任务，各子任务的分值和限制如下：

- 子任务 1（3 分）：$m = 0$
- 子任务 2（5 分）：$n \leq 4$
- 子任务 3（8 分）：$n \leq 18$
- 子任务 4（7 分）：$m = 2$
- 子任务 5（19 分）：$k = 1$
- 子任务 6（27 分）：$\gcd(n,m) \leq 2$
- 子任务 7（31 分）：无特殊限制

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T6

出题人：Imagine

72679

## 样例 #1

### 输入

```
6 3 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
17 8 6
```

### 输出

```
1421
```

## 样例 #3

### 输入

```
50000 20000 1
```

### 输出

```
683811528
```

# 题解

## 作者：Imagine (赞：37)

此题可能存在其他的解法，这里给出的解法仅供参考。



## 算法一

------

对于子任务 1，注意到 $m = 0$，即不存在黑色珠子，由于 $k \geq 1$，因此无论如何都有一种合法方案，输出 ``1`` 即可。



## 算法二

------

对于子任务 2，由于情况数较少，因此可以手推出所有可能的情况，打表即可。



## 算法三

------

对于子任务 2 及子任务 3，$n \leq 18$，数据支持指数级算法，那么可以暴力枚举每一颗珠子的颜色，再进行判重。判重可直接用一个小于 $2^{18}$ 的数来存储状态。



## 算法四

------

对于子任务 4，由于 $m = 2$，那么剩下的 $n - 2$ 个白色珠子在环上只会被划分成两段（其中一段可以为空），共有 $\lfloor\frac{n - 2}{2}\rfloor + 1$ 种不同的方案。注意到这是 $k \geq 2$ 时的情况，当 $k = 1$ 时，两个黑色珠子不能连续，因此需要减去一种方案。因此，当 $k \geq 2$ 时，输出 $\lfloor\frac{n - 2}{2}\rfloor + 1$，否则输出 $\lfloor\frac{n - 2}{2}\rfloor$。



## 算法五

------

显然的是，对于一个环，我们可以拆分成一个长度为 $n$ 的 01 序列来统计（0 和 1 分别表示两种颜色）。然而，即使我们保证了 01 序列不会重复统计，环依旧有可能被重复计算。例如： 0110 和 1100 其实是同一个环。

不过，一个最小循环节长度为 $d$ 的序列所对应的环只会被计算 $d$ 次。举例如下：

- 0101，最小循环节长度为 $2$（循环节为 01），其对应的环会被统计 $2$ 次（序列 0101 与 1010）
- 0111，最小循环节长度为 $4$（循环节为 0111），其对应的环会被统计 $4$ 次（序列 0111，1011，1101，1110）
- 1111，最小循环节长度为 $1$（循环节为 1），其对应的环会被统计 $1$ 次（序列 1111）

如果我们设 $f(x)$ 表示最小循环节长度为 $x$ 的合法序列个数，那么答案等于 $\sum_{d | {\rm gcd}(n, m)} \frac{1}{d} f(d)$。

但是由于有最小循环节的限制，直接求 $f$ 并不好求。我们使用莫比乌斯反演，转化为求 $g(x)$， $g(x)$ 表示最小循环节长度为 $x$ 的因子的合法序列个数。那么有 $g(x) = \sum_{d | x} f(d)$，即 $f(x) = \sum_{d | x} \mu(d) g(\frac{x}{d})$

对于子任务 5，我们假设整个长度为 $n$ 的序列被分成了 $l$ 段 $(l | {\rm gcd}(n, m))$，那么每一段中恰好有 $\frac{n}{l}$ 个珠子，且其中有 $\frac{m}{l}$ 个黑色珠子。我们只需要考虑一段的合法答案即可。对于一个合法的 $l$，我们令 $a = \frac{n}{l}, b = \frac{m}{l}$（$a$ 即为每一段的珠子数，$b$ 即为每一段的黑色珠子数量），由于有 $k = 1$，即不存在连续的两个黑色珠子，因此，我们可以把一个黑色珠子和一个白色珠子看成一个整体，那么转化为求拥有两种元素且数量分别为 $b$ 与 $a - 2×b$（剩余白色珠子数量）的多重集合的排列数，即 $\binom{a - b}{b}$。由于这样计算下来的方案会导致一端始终没有黑色珠子，因此我们再强制这一端放置一个黑色珠子，方案数为 $\binom{a - b - 1}{b - 1}$。因此有 $$g(a) = \binom{a - b}{b} + \binom{a - b - 1}{b - 1}$$

再通过函数 $g$ 求出函数 $f$，统计答案即可。



## 算法六

------

对于子任务 6，由于不再有 $k = 1$ 的限制条件，因此我们不能再像算法五那样去处理。承接算法五的反演部分，我们需要找到一种方法来求 $g$ 数组，以应对更加普遍的数据。

注意到这样一个事实：对于长度为 $a$ 且恰好有 $b$ 颗黑色珠子的一段珠子，我们求 $g(a)$，等同于求下面方程的整数解的数量：

$$x_0 + x_1 + ... + x_{a - b} = b(0 \leq x_i \leq k, 0 \leq x_0 + x_{a - b} \leq k)$$

即被 $a - b$ 颗白色珠子划分开的 $a - b + 1$ 段黑色珠子的和为 $b$，且满足每连续一段长度不超过 $k$ 的限制条件。运用生成函数的知识，求上面方程的解的数量等同于求如下多项式 $h(x)$ 中 $x^b$ 的系数：

$$h(x) = \left(\sum_{i = 0}^{k} x^i\right) ^ {a - b - 1} \left( \left(\sum_{i = 0}^{k} x^i\right)^2{\rm mod}\ x^{k + 1}\right)$$

进一步地，有

$$h(x) = \left(\sum_{i = 0}^{k} x^i\right) ^ {a - b - 1} \left(\sum_{i = 0}^{k} (i +1)x^i\right)$$

由于该子任务满足 ${\rm gcd}(n, m) \leq 2$，即我们要处理的 $g(a)$ 不会超过两个，因此，对于每一个 $g(a)$，我们完全可以用多项式求幂 + 一次 FFT 来求 $h(x)$ 中 $x^b$ 的系数。

求出函数 $g$ 之后求出函数 $f$ 统计答案即可。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define debug(...) fprintf(stderr, __VA_ARGS__)

typedef long long ll;
typedef long double ld;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef unsigned long long ull;

template<typename T> inline void read(T& x) {
	char c = getchar();
	bool f = false;
	for (x = 0; !isdigit(c); c = getchar()) {
		if (c == '-') {
			f = true;
		}
	}
	for (; isdigit(c); c = getchar()) {
		x = x * 10 + c - '0';
	}
	if (f) {
		x = -x;
	}
}

template<typename T, typename... U> inline void read(T& x, U&... y) {
	read(x), read(y...);
}

template<typename T> inline bool checkMax(T& a, const T& b) {
	return a < b ? a = b, true : false;
}

template<typename T> inline bool checkMin(T& a, const T& b) {
	return a > b ? a = b, true : false;
}

const int N = 1e5 + 10, mod = 998244353, G = 3;

int n, m, k;

inline void add(int& x, int y) {
	if (y < 0) {
		y += mod;
	}
	x = (x + y) % mod;
}

inline void mul(int& x, int y) {
	x = 1ll * x * y % mod;
}

inline int qpow(int v, int p) {
	int res = 1;
	for (; p; p >>= 1, mul(v, v)) {
		if (p & 1) {
			mul(res, v);
		}
	}
	return res;
}

inline int gcd(int x, int y) {
	return !y ? x : gcd(y, x % y);
}

int p[N], pri[N], mu[N], fac[N], invfac[N], c;

void sieve(int n) {
	mu[1] = 1;
	for (register int i = 2; i <= n; ++i) {
		p[i] = 1;
	}
	for (register int i = 2; i <= n; ++i) {
		if (p[i]) {
			mu[i] = -1, pri[++c] = i;
		}
		for (register int j = 1, d; j <= c && (d = pri[j] * i) <= n; ++j) {
			p[d] = 0;
			if (i % pri[j] == 0) {
				mu[d] = 0; break;
			} else {
				mu[d] = -mu[i];
			}
		}
	}
	fac[0] = invfac[0] = 1;
	for (register int i = 1; i <= n; ++i) {
		mul(fac[i] = fac[i - 1], i);
	}
	invfac[n] = qpow(fac[n], mod - 2);
	for (register int i = n - 1; i; --i) {
		mul(invfac[i] = invfac[i + 1], i + 1);
	}
}

int l, r[N << 2], S;

inline void ntt(int* c, int type) {
	for (register int i = 0; i < S; ++i) {
		if (i < r[i]) {
			swap(c[i], c[r[i]]);
		}
	}
	for (register int i = 1; i < S; i <<= 1) {
		int x = qpow(G, type == 1 ? (mod - 1) / (i << 1) : mod - 1 - (mod - 1) / (i << 1));
		for (register int j = 0; j < S; j += i << 1) {
			int y = 1;
			for (register int k = 0; k < i; ++k, mul(y, x)) {
				int p = c[j + k], q = 1ll * c[i + j + k] * y % mod;
				c[j + k] = (p + q) % mod;
				c[i + j + k] = (p - q + mod) % mod;
			}
		}
	}
	if (type == -1) {
		int inv = qpow(S, mod - 2);
		for (register int i = 0; i < S; ++i) {
			mul(c[i], inv);
		}
	}
}

int a[N << 2], b[N << 2], dm;

inline void qpow(int p) {
	memset(b, 0, sizeof b);
	b[0] = 1;
	for (; p; p >>= 1) {
		ntt(a, 1);
		if (p & 1) {
			ntt(b, 1);
			for (register int i = 0; i < S; ++i) {
				mul(b[i], a[i]);
			}
			ntt(b, -1);
			fill(b + dm + 1, b + S, 0);
		}
		for (register int i = 0; i < S; ++i) {
			mul(a[i], a[i]);
		}
		ntt(a, -1);
		fill(a + dm + 1, a + S, 0);
	}
}

inline int calc(int n, int m) {
	for (l = 0, S = 1; S <= m << 1; S <<= 1, ++l); --l;
	for (register int i = 0; i < S; ++i) {
		r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
	}
	memset(a, 0, sizeof a);
	for (register int i = 0; i <= min(k, m); ++i) {
		a[i] = 1;
	}
	qpow(n - m - 1);
	memset(a, 0, sizeof a);
	for (register int i = 0; i <= min(k, m); ++i) {
		a[i] = i + 1;
	}
	ntt(a, 1), ntt(b, 1);
	for (register int i = 0; i < S; ++i) {
		mul(a[i], b[i]);
	}
	ntt(a, -1);
	return a[m];
}

int f[N], g[N];

int main() {
	read(n, m, k);
	sieve(n);
	int d = gcd(n, m);
	for (register int i = 1; i <= n; ++i) {
		if (d % i) {
			continue;
		}
		g[n / i] = calc(n / i, dm = m / i);
	}
	for (register int i = 1; i <= n; ++i) {
		for (register int j = i; j <= n; j += i) {
			add(f[j], mu[i] * g[j / i]);
		}
	}
	int ans = 0;
	for (register int i = 1; i <= n; ++i) {
		if (n % i) {
			continue;
		}
		add(ans, 1ll * f[i] * qpow(i, mod - 2) % mod);
	}
	printf("%d\n", ans);
	return 0;
}
```



## 算法七

------

承接算法六。

我们的目的依然是求如下多项式 $h(x)$ 中 $x^b$ 的系数，不过我们需要找一个快一点的方法。

$$h(x) = \left(\sum_{i = 0}^{k} x^i\right) ^ {a - b - 1} \left(\sum_{i = 0}^{k} (i +1)x^i\right)$$

我们转化一下。由于 $\sum_{i = 0}^k x^i = \frac{1 - x^{k + 1}}{1 - x}$，因此有：

$$h(x) = \left(\frac{1 - x^{k + 1}}{1 - x}\right) ^ {a - b - 1} \left(\sum_{i = 0}^{k} (i +1)x^i\right)$$

再展开右侧的式子 $\sum_{i = 0}^k(i + 1)x^i$：

$$\begin{aligned}\sum_{i = 0}^k (i +1)x^i &= x^0 + 2x^1 + 3x^2 + \cdots + (k + 1)x^k\\ &= (x^0 + x^1 +  \cdots + x^k) + (x^1 +x^2 + \cdots + x^k)+ \cdots + x^k \\ &= \frac{x^0 - x^{k + 1}}{1 - x} + \frac{x^1 - x^{k + 1}}{1 - x} + \cdots + \frac{x^k - x^{k - 1}}{1 - x} \\ &= \frac{(x^0 + x^1 + \cdots + x^k) - (k + 1)x^{k + 1}}{1 - x} \\ &= \frac{\frac{x^0 - x^{k + 1}}{1 - x} - (k + 1)x^{k + 1}}{1 - x} \\ &= \frac{1 - (k + 2)x^{k + 1} + (k + 1)x^{k + 2}}{(1 - x)^2}\end{aligned}$$

因此，我们得到了：

$$\begin{aligned}h(x) &= \left(\frac{1 - x^{k + 1}}{1 - x}\right) ^ {a - b - 1} \frac{1 - (k + 2)x^{k + 1} + (k + 1)x^{k + 2}}{(1 - x)^2} \\ &= \frac{(1 - x^{k + 1})^{a - b - 1}}{(1 - x)^{a - b + 1}}(1 - (k + 2)x^{k + 1} + (k + 1)x^{k + 2})\end{aligned}$$

其中，$(1 - x^{k + 1})^{a - b - 1}$ 可化为 $\sum_{i = 0}^{\infty}\binom{a - b - 1}{i}(-1)^ix^{(k + 1)i}$，而 $\frac{1}{(1 - x)^{a - b + 1}}$ 即 $(1 - x)^{-(a - b + 1)}$，可通过负整数次幂的二项式定理化为 $\sum_{i = 0}^{\infty}\binom{a - b + i}{i}x^i$，因此有：

$$h(x) = \left(\sum_{i = 0}^{\infty}\binom{a - b - 1}{i}(-1)^ix^{(k + 1)i}\right)\left(\sum_{i = 0}^{\infty}\binom{a - b + i}{i}x^i\right)(1 - (k + 2)x^{k + 1} + (k + 1)x^{k + 2})$$

当把 $h(x)$ 化成该形式后，要求 $h(x)$ 中 $x^b$ 的系数就变得非常简单了。记 $s_1 = \sum_{(k + 1)i + j = b}(-1)^i\binom{a - b - 1}{i}\binom{a - b+ j}{j}$，$s_2 = (k + 2)\sum_{(k + 1)i + j = b - k - 1}(-1)^i\binom{a - b - 1}{i}\binom{a - b+ j}{j}$，$s_3 =  (k + 1)\sum_{(k + 1)i + j = b - k - 2}(-1)^i\binom{a - b - 1}{i}\binom{a - b+ j}{j}$，$x^b$ 的系数为 $w$，那么有 $w = s_1 - s_2 + s_3$。

求 $s_1, s_2, s_3$ 只需按照 $s_1, s_2, s_3$ 的式子枚举 $i$ 即可，因为 $i$ 确定 $j$ 也就确定了。因此，我们可以在 $\frac{b}{k + 1}$ 的时间内求出 $h(x)$ 中 $x^b$ 的系数。

除去反演部分，我们就能够在 $\frac{\sigma(n)}{k + 1}$ 的时间内解决此题，其中，$\sigma(n)$ 表示 $n$ 的约数和。由于 $\sigma(n)$ 可近似看作 $n\ {\rm log}\ {\rm log}\ n$，接近线性，因此时间复杂度是非常优秀的。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define debug(...) fprintf(stderr, __VA_ARGS__)

typedef long long ll;
typedef long double ld;
typedef unsigned int uint;
typedef pair<int, int> pii;
typedef unsigned long long ull;

template<typename T> inline void read(T& x) {
	char c = getchar();
	bool f = false;
	for (x = 0; !isdigit(c); c = getchar()) {
		if (c == '-') {
			f = true;
		}
	}
	for (; isdigit(c); c = getchar()) {
		x = x * 10 + c - '0';
	}
	if (f) {
		x = -x;
	}
}

template<typename T, typename... U> inline void read(T& x, U&... y) {
	read(x), read(y...);
}

template<typename T> inline bool checkMax(T& a, const T& b) {
	return a < b ? a = b, true : false;
}

template<typename T> inline bool checkMin(T& a, const T& b) {
	return a > b ? a = b, true : false;
}

const int N = 1e5 + 10, mod = 998244353, G = 3;

int n, m, k;

inline void add(int& x, int y) {
	if (y < 0) {
		y += mod;
	}
	x = (x + y) % mod;
}

inline void mul(int& x, int y) {
	x = 1ll * x * y % mod;
}

inline int qpow(int v, int p) {
	int res = 1;
	for (; p; p >>= 1, mul(v, v)) {
		if (p & 1) {
			mul(res, v);
		}
	}
	return res;
}

inline int gcd(int x, int y) {
	return !y ? x : gcd(y, x % y);
}

int p[N], pri[N], mu[N], fac[N], invfac[N], c;

inline int binom(int n, int m) {
	return n < 0 || m < 0 || n < m ? 0 : 1ll * fac[n] * invfac[m] % mod * invfac[n - m] % mod;
}

void sieve(int n) {
	mu[1] = 1;
	for (register int i = 2; i <= n; ++i) {
		p[i] = 1;
	}
	for (register int i = 2; i <= n; ++i) {
		if (p[i]) {
			mu[i] = -1, pri[++c] = i;
		}
		for (register int j = 1, d; j <= c && (d = pri[j] * i) <= n; ++j) {
			p[d] = 0;
			if (i % pri[j] == 0) {
				mu[d] = 0; break;
			} else {
				mu[d] = -mu[i];
			}
		}
	}
	fac[0] = invfac[0] = 1;
	for (register int i = 1; i <= n; ++i) {
		mul(fac[i] = fac[i - 1], i);
	}
	invfac[n] = qpow(fac[n], mod - 2);
	for (register int i = n - 1; i; --i) {
		mul(invfac[i] = invfac[i + 1], i + 1);
	}
}

inline int calc(int n, int m) {
	int res = 0;
	for (register int i = 0; i * (k + 1) <= m; ++i) {
		int j = m - i * (k + 1);
		add(res, 1ll * binom(n - m - 1, i) * binom(n - m + j, j) % mod * (i & 1 ? mod - 1 : 1) % mod);
		j = m - i * (k + 1) - k - 1;
		if (j >= 0) {
			add(res, 1ll * (k + 2) * binom(n - m - 1, i) % mod * binom(n - m + j, j) % mod * (i & 1 ? 1 : mod - 1) % mod);
		}
		j = m - i * (k + 1) - k - 2;
		if (j >= 0) {
			add(res, 1ll * (k + 1) * binom(n - m - 1, i) % mod * binom(n - m + j, j) % mod * (i & 1 ? mod - 1 : 1) % mod);
		}
	}
	return res;
}

int f[N], g[N];

int main() {
	read(n, m, k);
	sieve(n);
	int d = gcd(n, m);
	for (register int i = 1; i <= d; ++i) {
		if (d % i) {
			continue;
		}
		g[n / i] = calc(n / i, m / i);
	}
	for (register int i = 1; i <= n; ++i) {
		for (register int j = i; j <= n; j += i) {
			add(f[j], mu[i] * g[j / i]);
		}
	}
	int ans = 0;
	for (register int i = 1; i <= n; ++i) {
		if (n % i == 0) {
			add(ans, 1ll * f[i] * qpow(i, mod - 2) % mod);
		}
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：yybyyb (赞：35)

考虑$Burside$引理，设$f(x)$表示置换拆成循环的个数为$x$时的答案，那么最终的结果就是$\displaystyle \frac{\sum_{i=1}^n f(gcd(i,n))}{n}$，化简之后就是$\displaystyle \frac{\sum_{d|n}f(d)\varphi(\frac{n}{d})}{n}$。

考虑如何计算不动点的数量，为了方便首先把$n=m$的情况直接处理掉，那么现在问题变成了，把环上的点编号，所有模$d$相同的点都必须是同时染或者不染色，并且不能有连续的$k$个被染色。因为已经处理掉了$n=m$的情况，所以只需要至少有一个循环没有被染色，那么问题可以等价于有$d$个点要染其中的$\frac{m}{d}$ 个，不能有连续的$k$个都被染色的方案数。

现在把要求的东西重新拿出来定义一下，即有$N$个球放成一圈，要给其中$C$个染色，不能有连续$K$个都被染色，求方案数。

我们把$C$个要染色的球拿出来，放进剩下的$N-C$个球组成的环的空隙之间，使得每个空隙里的球都不能超过$K$个。因为要确定的是标号，所以必须断环成链，那么第$1$个和第$N-C$个之间的空隙是第一个球之前和最后一个球之后这两段本质上是连在一起的，这两段加起来不能超过$K$个。

那么枚举第一个球之前和最后一个球之后这两段一共放了多少个球，然后前后分配一下，所以方案数就是：$\displaystyle \sum_{i=0}^k (i+1)Put(C-i,N-C-1,K)$，其中$Put(C,N,K)$表示把$C$个球分成$N$组，每组不能超过$K$个的方案数，这个东西可以用容斥在$O(\frac{C}{K})$的时间里解决，所以单次的复杂度不会超过$O(\frac{N}{K}*K)=O(N)$。

那么这样子总的复杂度就是$O(n+\sigma(gcd(n,m))$。

代码:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define MAX 1000010
#define MOD 998244353
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
bool zs[MAX];
int pri[MAX],phi[MAX],tot;
int jc[MAX<<1],inv[MAX<<1],jv[MAX<<1];
void pre(int n)
{
	phi[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!zs[i])pri[++tot]=i,phi[i]=i-1;
		for(int j=1;j<=tot&&i*pri[j]<=n;++j)
		{
			zs[i*pri[j]]=true;
			if(i%pri[j]==0){phi[i*pri[j]]=phi[i]*pri[j];break;}
			phi[i*pri[j]]=phi[i]*(pri[j]-1);
		}
	}
	jc[0]=jv[0]=inv[0]=inv[1]=1;
	for(int i=2;i<=n+n;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=n+n;++i)jc[i]=1ll*jc[i-1]*i%MOD;
	for(int i=1;i<=n+n;++i)jv[i]=1ll*jv[i-1]*inv[i]%MOD;
}
int Choose(int n,int m){if(n<m||n<0||m<0)return 0;return 1ll*jc[n]*jv[m]%MOD*jv[n-m]%MOD;}
int fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}
int Put(int m,int n){if(m<0)return 0;return Choose(n+m-1,n-1);}
int n,m,K,p[MAX];
int Insert(int m,int n,int k)
{
	int ret=0;if(m<0)return 0;
	for(int i=0,d=1;i<=n;++i,d=MOD-d)
		if(m>=1ll*i*(k+1))ret=(ret+1ll*Put(m-i*(k+1),n)*Choose(n,i)%MOD*d)%MOD;
		else break;
	return ret;
}
int Calc(int d)
{
	int N=n/d,C=m/d,ret=0;
	if(C<=K)return Choose(N,C);
	if(K==1)return (Choose(N-C+1,C)+MOD-Choose(N-C-1,C-2))%MOD;
	for(int i=0;i<=K;++i)
		ret=(ret+1ll*(i+1)*Insert(C-i,N-C-1,K))%MOD;
	return ret;
}
int main()
{
	n=read();m=read();K=read();pre(n);
	if(n==m){if(K==n)puts("1");else puts("0");return 0;}
	if(!m){puts("1");return 0;}
	int g=__gcd(n,m),ans=0;
	for(int i=1;i*i<=g;++i)
		if(g%i==0)
		{
			ans=(ans+1ll*Calc(i)*phi[i])%MOD;
			if(i*i!=g)ans=(ans+1ll*Calc(g/i)*phi[g/i])%MOD;
		}
	ans=1ll*ans*fpow(n,MOD-2)%MOD;
	printf("%d\n",ans);
}
```

---

## 作者：command_block (赞：16)

**题意**：$n$ 个珠子的手环满足如下条件：

- 有 $m$ 个黑色珠子，$n-m$ 个白色珠子。
- 不存在大于 $k$ 个连续的黑色珠子。

两个手环旋转后相同，则本质相同。求本质不同的手环的种类数。

答案对 $998244353$ 取模，$n,m,k\leq 10^5$，时限 $\texttt{1s}$。

-----

> upd 2025.2.27：重新排版，修改了一处错误。

首先特判全黑的情况（$n=m$）。

看到环与旋转，容易想到 Burnside 引理。

设 $g(t)$ 为旋转 $t$ 步，符合题意的不动点个数。答案为
$$
{\rm Ans}=\frac{1}{n}\sum_{t=1}^ng(t)
$$

-----

- **引理**：长度为 $n$ 的环旋转 $t$ 步后和自己相等。等价关系形成 $\gcd(t,n)$ 个环，这些环大小相等，均匀交错。

设 $f(c)$ 为：不动点要求的等价关系形如 $c$ 个交错环，填写黑白的方案数。则 $g(t)=f\big(\gcd(t,n)\big)$。
$$
{\rm Ans}=\dfrac{1}{n}\sum\limits_{t=1}^nf\big(\gcd(t,n)\big)
$$

-----

现在考虑如何求 $f(c)$。

等价类（形如交错的环）的个数为 $c$，相当于点 $i$ 的等价类编号为 $i\bmod c$。

如下 $n=12,c=4$ 的情形：

```cpp
0123 | 0123 | 0123
```

那么每连续 $c$ 个元素（循环节）可以看成一个小环（大小为 $n/c$)，因为左右能与其他一模一样的循环节相接。

$f(c)$ 就是：在小环上选择 $m/c$ 个黑色（要求 $c|m$），不能有连续 $k$ 个黑色的方案数。（已排除全黑，故这段“连续黑”不会串联多个环）

设 $S(N,M)$ 为：在一个大小为 $N$ 的环上，染 $M$ 个黑色，不能有超过 $k$ 个连续黑色的方案数。

有
$$
f(c)=[c|n,m]S(n/c,m/c)
$$

-----

现在考虑如何求 $S(N,M)$。

考虑把 $M$ 个黑球放进 $N-M$ 个白球的 $N-M+1$ 个空隙内。

由于是环，第一个空隙和最后一个空隙共享限制，它们的黑球个数加起来不过 $k$。枚举它们共放多少个黑球：

$$
S(N,M)=\sum\limits_{i=0}^k(i+1)R(N-M-1,M-i)
$$
其中 $R(N,M)$ 是：在 $N$ 个盒子里放 $M$ 个球，盒子容量上限为 $k$ 的方案数。代表剩余的缝隙。

系数 $(i+1)$ 是因为：$i$ 个球可以有一部分放在第一个空隙，一部分放在最后一个空隙。

-----

考虑如何计算 $R(N,M)$。

考虑容斥。令某些盒子超过容量，容易发现盒子之间没有顺序关系，有：

$$
R(N,M)=\sum_{i=1}^{\min(M/k,N)}(-1)^i\dbinom{N}{i}T\big(N,M-i(k+1)\big)
$$
其中，$T(N,M)$ 为把 $M$ 个球放进 $N$ 个有标号盒子中的方案数，这用组合数学很好算。

-----

复杂度分析。

容斥计算 $R(N,M)$ 的复杂度是 $O(M/k)$。

回看 $S(N,M)=\sum_{i=0}^k(i+1)R(N-1,M-i)$，需要求 $O(k)$ 个 $R$，复杂度$O(M)$。

回看
$$
\begin{aligned}
{\rm Ans}
&=\dfrac{1}{n}\sum_{t=1}^nf\big(\gcd(t,n)\big)\\
&=\frac{1}{n}\sum_{d|n}f(d)\varphi(n/d)\\
&=\frac{1}{n}\sum_{d|n,d|m}\varphi(n/d)S(n/d,m/d)
\end{aligned}
$$
复杂度是 $O(\sigma(m))$（$m$ 的约数之和）。

> 注：
> - 易证 $\sigma(m)=O(m\log m)$。因为约数最差情况下形如 $m/1,m/2,m/3,\dots$
> - 进一步地，可证 $\sigma(m)=O(m\log\log m)$。

代码如下：

```cpp
#include <algorithm>
#include <cstdio>

const int MaxN = 100050, mod = 998244353;

int powM(int a, int t=mod-2) {
	int ret = 1;
	while(t) {
		if (t&1)
			ret = 1ll*ret*a %mod;
		a = 1ll*a*a %mod;
		t >>= 1;
	}
	return ret;
}
int fac[MaxN], ifac[MaxN];
int C(int n, int m) {
	return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
void Init(int n) {
	fac[0] = 1;
	for (int i=1; i<=n; i++)
		fac[i] = 1ll*fac[i-1]*i %mod;
	ifac[n] = powM(fac[n]);
	for (int i=n; i; i--)
		ifac[i-1] = 1ll*ifac[i]*i %mod;
}

int T(int n,int m) {
	return C(n+m-1, n-1);
}
int K;
int R(int n,int m) {
	int ans=0;
	for (int i=0; i<=std::min(m/(K+1),n); i++) {
		if (i&1)
			ans =(ans-1ll*C(n,i)*T(n,m-i*(K+1))) %mod;
		else
			ans =(ans+1ll*C(n,i)*T(n,m-i*(K+1))) %mod;
	}
	return (ans+mod)%mod;
}
int S(int n, int m) {
	if (m<=K) return C(n,m);
	int ans = 0;
	for (int i=0; i<=std::min(K,m); i++)
		ans = (ans+1ll*R(n-m-1,m-i)*(i+1)) %mod;
	return ans;
}

int phi(int n) {
	int ans = n;
	for (int i=2; i*i<=n; i++)
		if (n%i==0) {
			ans=ans/i*(i-1);
			while(n%i==0)n/=i;
		}
	if (n>1) ans = ans/n*(n-1);
	return ans;
}
int gcd(int a, int b) {
	return !b ? a : gcd(b, a%b);
}

int main() {
	int n, m;
	scanf("%d%d%d", &n, &m, &K);
	if (n==m) {
		puts(K>=m ? "1" : "0");
		return 0;
	}
	Init(n);
	int D = gcd(n,m), ans = 0;
	auto calcFactor = [&ans,n,m](int d) -> void {
		ans = (ans + 1ll*S(n/d,m/d)*phi(d)) %mod;
	};
	for (int i=1; i*i<=D; i++)
		if (D%i==0) {
			calcFactor(i);
			if (i*i!=D)
				calcFactor(D/i);
		}
	ans = 1ll*ans*powM(n)%mod;
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Zesty_Fox (赞：11)

也许更好的阅读体验：[我的博客](https://www.cnblogs.com/acceptedzhs/p/15050023.html)

模拟考考到了这道题，现在写一发题解。

首先，环不好处理，考虑断环为链，相当于将 $m$​ 个黑色魔力珠插入白色魔力珠的间隙中。注意由于是环，所以第一个白球前面与最后一个白球后面是相通的，所以只有 $n-m$​ 个间隙，可强制最后一个白球后不能放球。

不妨记一种方案为序列 $a$，$a_i$ 表示第 $i$ 个白球前的间隙有多少个黑球。如：$\blacksquare\Box\blacksquare\blacksquare\Box\blacksquare\Box\Box \rightarrow 1,2,1,0$。显然有 $\sum \limits_{i=1}^{n-m} a_i=m$。

接下来，不考虑一种方案是否被重复统计，考虑如何求方案数。

如果不考虑任何限制，将黑球随意分配（序列中允许值为 $0$​ 的项），根据插板法，结果为 $\dbinom{n-1}{n-m-1}$​​。

类似[硬币购物](https://www.luogu.com.cn/problem/P1450)的做法，我们可以枚举序列中有多少项超过了 $k$​ ，先预先给它们每项都分配 $k+1$​ 个黑球，然后将剩下的黑球随意分配（分配到之前预分配的项也没关系），用容斥原理进行计算。那么，最终答案为：
$$
\sum\limits_{i=0}^{\lfloor \frac{m}{k+1} \rfloor} (-1)^i \dbinom{n-m}{i}\dbinom{n-i\times (k+1)-1}{n-m-1}
$$
现在再来考虑如何解决重复统计的问题。

手玩一下可发现一种方案被重复统计的次数是其序列最短循环节的长度（如 $2,1,2,1$​​​​​​ 被重复统计了 $2$​​​​​​ 次，为 $2,1,2,1$​​​​​​ 与 $1,2,1,2$​​​​​​​​），所以我们可以枚举循环节的长度（注意不一定是最小循环节）。当循环节个数为 $i$​​​​​​ 时（即循环节长度为$\dfrac{n-m}{i}$​​​），相当于将 $m$​​​ 个黑球、$n-m$​​​ 个白球变成了 $\dfrac{m}{i}$​​​  个黑球、$\dfrac{n-m}{i}$​ 个白球，而且 $i$​ 满足 $i \mid {\gcd(m,n-m)}$ ，对于每个 $i$ 都可以用上文方法容斥计算，可将结果记为 $f(i)$​​​​​​。

最后，考虑如何统计答案。前面说不一定是最小循环节，这是因为对某个循环节长度的情况计算时可能包括循环节更小的结果，如循环节为 $4$​​ 时包含了 $1,2,1,2,1,2,1,2$​​，而它实际最小循环节为 $2$​​。考虑再次容斥，记 $g(i)$​​​​ 为循环节**个数恰好**为 $i$​​ 的方案数，则有：
$$
f(i)=\sum\limits_{i \mid d} g(d)
$$
莫反一下，则有：
$$
g(i)=\sum\limits_{i|d}\mu(\frac{d}{i})\times f(d)
$$
最后答案便是：
$$
Ans=\sum\limits_{d\mid \gcd(m,n-m)} g(d) \times \dfrac{d}{n-m}
$$
Code: （考场代码，有点丑，请见谅）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;

template<typename T>
inline T read(){
	T x=0,f=0;char ch=getchar();
	while(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}

#define rdi read<int>
#define rdll read<ll>
#define fi first
#define se second
#define pb push_back
#define mp make_pair

const int MOD=998244353,N=200010;
int n,m,k;

inline ll qpow(ll x,ll y=MOD-2){
	ll res=1;
	while(y){
		if(y&1) (res*=x)%=MOD;
		(x*=x)%=MOD;y>>=1;
	}
	return res;
}

ll fac[N],faci[N];
inline void init(){
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%MOD;
	faci[n]=qpow(fac[n]);
	for(int i=n-1;i>=0;i--) faci[i]=faci[i+1]*(i+1)%MOD;
}

int mu[N],v[N],pr[N],cnt;
inline void init_mu(){
	mu[1]=1;
	for(int i=2;i<=n;i++){
		if(!v[i]){v[i]=i,pr[++cnt]=i,mu[i]=-1;}
		for(int j=1;j<=cnt;j++){
			if(pr[j]>v[i]||pr[j]>n/i) break;
			v[pr[j]*i]=pr[j];
			if(i%pr[j]) mu[pr[j]*i]=-mu[i];
			else mu[pr[j]*i]=0;
		}
	}
}

inline ll C(int n,int m){
	if(n<0||m<0||n<m) return 0;
	return fac[n]*faci[m]%MOD*faci[n-m]%MOD;
}

int gcd(int x,int y){return !x?y:gcd(y%x,x);}
ll f[N],ans;

int main(){
	n=rdi(),m=rdi(),k=rdi();
	if(n==m){
		puts(m<=k?"1":"0");
		return 0;
	}
	if(!m){
		puts("1");
		return 0;
	}
	init();init_mu();int gc=gcd(n-m,m);
	for(int x=gc;x>=1;x--){
		if(gc%x) continue;
		int n1=n/x,m1=m/x;
		for(int i=0,c=1;i<=m1/(k+1);i++,c=-c){
			f[x]+=c*C(n1-m1,i)*C(n1-i*(k+1)-1,n1-m1-1);
			f[x]=(f[x]%MOD+MOD)%MOD;
		}
	}
	for(int x=1;x<=gc;x++){
		if(gc%x) continue;
		ll sum=0;
		for(int i=x;i<=gc;i+=x){
			sum+=mu[i/x]*f[i]%MOD;sum=(sum%MOD+MOD)%MOD;
		}
		ans=(ans+sum*x)%MOD;
	}
	cout<<ans*qpow(n-m)%MOD<<endl;
	return 0;
}
```



---

## 作者：dsidsi (赞：4)

看到旋转同构，首先套一个 $burnside$ 定理上去：

$$ans = \frac{\sum_{i=1}^n f(i)}{n}$$

其中 $f(i)$ 表示旋转 $i$ 次的不动点数量，这等价于 $g(gcd(n,i))$，其中 $g(i)$ 表示有 $i$ 个循环的方案数。

由于要求每个循环的染色/不染色状态相同，所以如果 $m \nmid i$，那么 $g(n/i)$ 一定是 $0$。

所以 

$$ans = \frac{\sum_{d|gcd(n,m)} g(d) \phi (n /d)}{n}$$

考虑如何计算 $g$。考虑 $n$ 个珠子被分为了 $n/i$ 段，同一段之间任意两点属于的循环不同，如下表示$n=12,i=4$的情况（标号表示属于的循环）：

`0123|0123|0123`

首先特判 $n=m$ 的情况，这样每一段至少有一个珠子没有染色。由于每一段染色情况相同且不合法的段最多横跨两段，所以整个环染色珠子长度不能超过 $k$，等价于在一个长度为 $n/i$ 的项链上染 $m / i$ 个珠子。

考虑计算把 $n$ 个珠子中的 $m$ 个染色，使得最长染色段不超过 $k$ 方案数。假设强制第一个珠子没有被染色，那么相当于把 $m$ 个染色珠子丢进 $n-m$ 个空隙中，每个空隙不能超过 $k$ 个，容斥即可，设算出的答案为 $s$。然后由于每个位置都可以是黑色，所以要乘上 $n$，又因为一种方案被重复计算了 $n-m$ 次，所以要除以 $n-m$。综上，答案就是 $\frac {s \times n} {m}$

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 1e6 + 5, mod = 998244353;

inline int gi()
{
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	int sum = 0;
	while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

int n, m, k;
int phi[maxn], vis[maxn];
int fac[maxn], inv[maxn], ifac[maxn];

inline int C(int m, int n)
{
	if (m < n || n < 0) return 0;
	return (ll)fac[m] * ifac[n] % mod * ifac[m - n] % mod;
}

inline int f(int m, int n) {return C(m + n - 1, n - 1);}

int calc(int n, int m, int k)
{
	if (n == m) return k >= n ? 1 : 0;
	int ans = 0;
	for (int i = 0; i <= m / (k + 1); ++i) {
		if (i & 1) ans = (ans + (ll)f(m - i * (k + 1), n - m) * (mod - C(n - m, i))) % mod;
		else ans = (ans + (ll)f(m - i * (k + 1), n - m) * C(n - m, i)) % mod;
	}
	return (ll)ans * n % mod * inv[n - m] % mod;
}

int main()
{
	int T = 1;
	
	n = 1e6;
	fac[0] = ifac[0] = inv[1] = 1;
	for (int i = 1; i <= n; ++i) fac[i] = (ll)fac[i - 1] * i % mod;
	for (int i = 2; i <= n; ++i) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;
	for (int i = 1; i <= n; ++i) ifac[i] = (ll)ifac[i - 1] * inv[i] % mod;

	for (int i = 1; i <= n; ++i) phi[i] = i;
	for (int i = 2; i <= n; ++i)
		if (!vis[i])
			for (int j = i; j <= n; j += i)
				vis[j] = 1, phi[j] = phi[j] / i * (i - 1);
	
	while (T--) {
		n = gi(); m = gi(); k = gi();

		int ans = 0;
		for (int d = 1; d <= n; ++d)
			if (n % d == 0 && m % d == 0)
				ans = (ans + (ll)calc(n / d, m / d, k) * phi[d]) % mod;
		printf("%lld\n", (ll)ans * inv[n] % mod);
	}
	
	return 0;
}
```

---

## 作者：天命之路 (赞：3)

还是一道挺好的群论计数的，虽然也有其他的做法

首先看到**旋转同构**，就可以往 Burnside 引理上考虑，如果枚举 $i$ 表示旋转 $i$ 格的置换，那这个置换能被分解成 $\gcd(i,n)$ 个不相交的环，每个环内要求颜色相同。

Burnside 引理这里就不放式子了，我们直接考虑如何处理这 $\gcd(i,n)$ 个环

现在我们令 $x$ 表示上面的 $\gcd(i,n)$ ，即环的个数

把每个点 $i$ 重编号为 $i \bmod x$ (这实际上就是所在环的编号），例如当 $n = 12,x = 4$ 时编号如下：

`0123|0123|0123`

我们只需考虑一段连续的 `0123`

但注意到“`3`” 和 “`0`”是相邻的，所以我们实际上考虑的是一个长度为 $x$ 的小环，有 $m / (n / x)$ 个小球染了色，限制依旧是 $k$

下面的 $n,m$ 就是指这里的 $x,m/(n/x)$

环不好做，考虑断环为链，枚举第一个白球和最后一个白球之间的黑球个数，则有
$$\sum\limits_{i=0}^k(i+1)Ins(m-i,n-m-1,k)$$

这里乘以 $(i+1)$ 是因为要对这 $i$ 个球进行划分，决定有几个放最前面，几个放最后面

而 $Ins(m-i,n-m-1,k)$ 则是表示将剩余的 $m-i$ 个黑球，放进 $n-m$ 个白球的 $n-m-1$ 个**空隙**中，限制为 $k$ 的方案数

考虑怎么算 $Ins(m,n,k)$

容斥，设有 $i$ 个空隙中超过了 $k$ 个球，则有式子

$$\sum\limits_{i=0}^n(-1)^i{\binom{n}{i}}{\binom {m-i\times (k+1) +n-1}{n-1}}$$

最后那个奇怪的组合数是插板法弄出来的

虽然上界写到 $n$ ，但我们只要用 $\Theta(\frac{m}{k+1})$ 的时间来求这个玩意

所以我们可以用 $\Theta(m)$ 的时间求出每个 $x$ 的答案

而这里的 $m$ 其实是原来的 $m/(n/x)$ 

所以总复杂度其实就是 $\Theta(\gcd(n,m)\text{ 的约数和})$，比调和级数稍小

代码如下：

（代码中采用了 Polya 常见套路即枚举 gcd ,用 $\varphi$ 函数算出现次数，这里就没有提及了，不了解的可以去模板区）


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5,P = 998244353;
inline int qpow(int a,int b) { int res = 1;while(b) {if(b&1) res = 1ll*res*a%P;a = 1ll*a*a%P;b >>= 1;} return res;}
int fac[N],ifac[N];
int n,m,k;
inline void init(int n)
{
	fac[0] = 1;
	for(int i = 1;i <= n;i++)
		fac[i] = 1ll*fac[i-1]*i%P;
	ifac[n] = qpow(fac[n],P-2);
	for(int i = n - 1;i >= 0;i--)
		ifac[i] = 1ll*ifac[i+1]*(i+1)%P;
}
inline int C(int n,int m) { if(m > n || n < 0 || m < 0) return 0; return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}
inline int Put(int m,int n) { return C(n + m - 1,n - 1);}
inline int Ins(int m,int n,int k)
{
	int ans = 0;
	for(int i = 0,sign = 1;i <= n;i++,sign = P - sign)
	if(m >= 1ll*i*(k+1)) ans = (ans + 1ll*sign*Put(m - i*(k+1),n)%P*C(n,i)%P)%P;
	else break;
	return ans;
}
inline int S(int n,int m)
{
	int ans = 0;
	if(m <= k) return C(n,m);
	for(int i = 0;i <= min(k,m);i++)
		ans = (1ll*(i+1)*Ins(m-i,n-m-1,k)%P + ans) % P;
	return ans;
}
inline int calc(int d) { return S(n/d,m/d);}
int phi[N],pri[N],vst[N],tot;
inline void sieve(int n)
{
	phi[1] = 1;
	for(int i = 2;i <= n;i++)
	{
		if(!vst[i]) pri[++tot] = i,phi[i] = i - 1;
		for(int j = 1;j <= tot && 1ll*i*pri[j] <= n;j++)
		{
			vst[i*pri[j]] = true;
			if(i % pri[j] == 0)
			{
				phi[i*pri[j]] = phi[i]*pri[j];
				break;
			}
			else phi[i*pri[j]] = phi[i]*(pri[j]-1);
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	init(n);
	sieve(n);
	int ans = 0;
	int d = __gcd(n,m);
	for(int i = 1;i*i <= d;i++)
	{
		if(d % i) continue;
		ans = (ans + 1ll*calc(i)*phi[i]%P)%P;
		if(i * i != d)
		{
			ans = (ans + 1ll*calc(d/i)*phi[(d/i)]%P)%P;
		}
	}
	ans = 1ll*ans*qpow(n,P-2)%P;
	printf("%d\n",ans);
	return 0;
}
```

重点：发现我们实际上处理的是一个长度为 $x$ 的小环，然后断环为链处理

完结撒花！

---

## 作者：simonG (赞：3)

由于题解区有若干错误，故写一篇正确的题解。

你要给的环染色，你需要染 $m$ 个黑色和 $n-m$ 个白色，其中连续的黑色不能超过 $k$ 个。  
求本质不同染色的方案数。

明显是套用 Burnside 引理。考虑枚举转了多少，如果转了 $i$，那么可以自由填的地方就是 $\gcd(i,n)$ 个位置。设 $d=\frac{n}{\gcd(i,n)}$，那么要填的就是 $\frac{m}{d}$ 个黑色。  
发现只需要填 $d$ 个一样的小环。  
于是问题变成求长度为 $\frac{n}{d}$，要填 $\frac{m}{d}$ 个黑色的环的方案数，此时已经没有了循环移位的限制。  
所以我们只需要枚举 $\gcd$，再计算即可。  

设 $S(n,m)$ 表示求长度为 $n$，要填 $m$ 个黑色的环的方案数。  
考虑把白色先填进去，然后把黑色插入进去。  
白色有 $n-m+1$ 个空隙，黑色要填进去，一个空隙最多 $k$ 个，第一个和最后一个和最多 $k$ 个。  
先枚举最后一个空隙和第一个空隙总共填了 $i$ 个黑色，贡献是 $R(n-m-1,m-i)\times (i+1)$。  
这样就破环成链了。  

$R(n,m)$ 表示 $n$ 个容器要填 $m$ 个进去，一个容器是容量是 $k$。  
考虑容斥，$R(n,m)=\sum_{i=0}^{\min(n,m/k)} (-1)^i\times C_{n}^{i}\times T(n,m-i(k+1))$。  

其中 $T(n,m)$ 表示 $n$ 个容器任意填 $m$ 个黑色，插板法得出是 $C_{n+m-1}^{n-1}$.

复杂度是 $O(n\sqrt n)$，是因数和。

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const int mod=998244353;
const int N=2e6+10;
int n,m,k,inv[N],fac[N],fac2[N];
int phi[N],p[N],tot,is[N];
int gcd(int x,int y) {return __gcd(x,y);}
void init() {
	inv[1]=fac[0]=fac2[0]=phi[1]=1;
	for(int i=2; i<N; i++) inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
	for(int i=1; i<N; i++) fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=1; i<N; i++) fac2[i]=1ll*fac2[i-1]*inv[i]%mod;
	for(int i=2; i<N; i++) {
		if(!is[i]) {p[++tot]=i; phi[i]=i-1;}
		for(int j=1; j<=tot&&i*p[j]<N; j++) {
			int k=i*p[j]; is[k]=1;
			if(i%p[j]==0) phi[k]=phi[i]*p[j];
			else phi[k]=phi[i]*phi[p[j]];
		}
	}
}
int C(int n,int m) {
	return 1ll*fac[n]*fac2[n-m]%mod*fac2[m]%mod;
}
int T(int n,int m) {
	return C(n+m-1,n-1);
}
int R(int n,int m) {
	int res=0;
	for(int i=0,op=1; i<=min(m/(k+1),n); i++,op*=-1)
		res=(res+1ll*op*C(n,i)*T(n,m-i*(k+1)))%mod;
	return (res+mod)%mod;
}
int S(int n,int m) {
	int res=0;
	if(m<=k) return C(n,m);
	for(int i=0; i<=k; i++)
		res=(res+1ll*(i+1)*R(n-m-1,m-i))%mod;
	return res;
}
void solve() {
	scanf("%d%d%d",&n,&m,&k);
	if(n==m) return printf("0\n"),void();
	int tmp=gcd(n,m),ans=0;
	for(int i=1; i*i<=tmp; i++) {
		if(tmp%i==0) {
			ans=(ans+1ll*S(n/i,m/i)*phi[i])%mod;
			if(i*i!=tmp) ans=(ans+1ll*S(n/(tmp/i),m/(tmp/i))*phi[tmp/i])%mod;
		}
	}
	ans=1ll*ans*inv[n]%mod;
	printf("%d\n",ans);
}
int main() {
	init();
	int T=1; //scanf("%d",&T);
	for(; T; T--) solve();
	return 0;
}
```

---

## 作者：Lstdo (赞：2)

贡献一个没脑子推法。

首先 OI 中能处理循环同构的只有 Burnside 引理，所以有一个烂大街的结论：最终答案是不循环同构的答案函数与欧拉函数的狄利克雷卷积除以 $n$。

即:设 $f(n)$ 是大小为 $n$ 且不循环同构时的答案（两种颜色的球的个数等比例缩小，不能整除为 $0$），那么答案为

$$\sum_{d\mid n}f(d)\varphi(\frac nd)$$

现在考虑不循环同构怎么做。

为了后面书写方便，通过对输入的一些处理，我们用 $n$ 表示黑球个数， $w$ 表示白球个数，$k$ 表示存在**大于等于**该长度的连续黑球就不合法（即原来的 $k+1$）

特判掉全是黑色的，然后考虑白色球隔开的每段黑色球。

我们把每个白色球和 下一个白色球之前的所有黑色球视为一个整体，构造生成函数：

$$f(x)=\sum_{i=0}^{k-1}x^i=\frac{1-x^k}{1-x}$$

注意 $[x^i]f(x)$ 表示的是用了 $i$ 个**黑球**的方案，因为白球数量是固定的，那么段数也是 $w$。

考虑钦定一个起点，然后随便抓一条上面说的整体过来，枚举起点放在哪个位置。然后其他位置随便放 $w-1$ 条。

总方案就是

$$[x^n]\left(\sum_{i=0}^{\infty}(i+1)f_ix^i\right)f^{w-1}(x)$$

其中 $f_i$ 表示 $[x^i]f(x)$，括号太多了不好看。

运用你高超的数学知识，前面一坨可以近似写成求导再平移的形式，那个 $+1$ 就再加个自己就行了。

$$[x^n](xf'(x)+f(x))f^{w-1}(x)$$

拆开

$$[x^n]xf'(x)f^{w-1}(x)+[x^n]f^w(x)$$

后面那个随便都能算了，先看看前面的怎么搞

$$[x^n]xf'(x)f^{w-1}(x)$$

$$=[x^{n-1}]f'(x)f^{w-1}(x)$$

$$=[x^{n-1}]\left(\frac 1wf^w(x)\right)'$$

$$=\frac nw[x^n]f^w(x)$$

所以加上后面的总答案就是

$$\frac{n+w}w[x^n]f^w(x)$$

$$=\frac{n+w}w[x^n]\left(\frac{1-x^k}{1-x}\right)^w$$

上面用二项式定理展开，枚举每一项用组合数算。下面每除一个就是一次前缀和，也就是做了个 $w$ 阶前缀和，也可以用组合数算。上面每一项算出来乘上下面对应位置的下标就可以了。

即

$$\frac{n+w}w\sum_{i=0}^w(-1)^i\binom{w}{i}\binom{n-ik+w-1}{w-1}$$

这样做一次是 $O(w)$ 的，总复杂度是约数和级别，也就是 $O(n\log \log n)$。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cctype>
using namespace std;
const int MOD=998244353;
inline int add(const int& x,const int& y){return x+y>=MOD? x+y-MOD:x+y;}
inline int dec(const int& x,const int& y){return x<y? x-y+MOD:x-y;}
typedef long long ll;
const int N=5e6,MAXN=N+5;
int gcd(int a,int b){return b? gcd(b,a%b):a;}
inline int qpow(int a,int p)
{
	int ans=1;
	while (p)
	{
		if (p&1) ans=(ll)ans*a%MOD;
		a=(ll)a*a%MOD;p>>=1;
	}
	return ans;
}
int fac[MAXN],finv[MAXN],np[MAXN],pl[MAXN],phi[MAXN],cnt;
inline void init()
{
	fac[0]=1;
	for (int i=1;i<=N;i++) fac[i]=(ll)fac[i-1]*i%MOD;
	finv[N]=qpow(fac[N],MOD-2);
	for (int i=N-1;i>=0;i--) finv[i]=(ll)finv[i+1]*(i+1)%MOD;
	np[1]=phi[1]=1;
	for (int i=2;i<=N;i++)
	{
		if (!np[i]) phi[pl[++cnt]=i]=i-1;
		for (int j=1,x;(x=i*pl[j])<=N;j++)
		{
			np[x]=1;
			if (i%pl[j]==0)
			{
				phi[x]=phi[i]*pl[j];
				break;
			}
			phi[x]=phi[i]*(pl[j]-1);
		}
	}
}
inline int C(const int& n,const int& m){return (ll)fac[n]*finv[m]%MOD*finv[n-m]%MOD;}
int k;
inline int calc(int n,int w)
{
	int ans=0;
	for (int i=0;i*k<=n&&i<=w;i++)
	{
		int t=(ll)C(w,i)*C(n-i*k+w-1,w-1)%MOD;
		if (i&1) ans=dec(ans,t);
		else ans=add(ans,t);
	}
 	return (ll)ans*(n+w)%MOD*finv[w]%MOD*fac[w-1]%MOD;
}
main()
{
	int n,w;
	cin>>w>>n>>k;
	++k;
	w-=n;
	if (!w) return puts(k<=n? "0":"1"),0;
	init();
	int d=gcd(n,w);
	int ans=0;
	for (int i=1;i*i<=d;i++)
		if (d%i==0)
		{
			ans=(ans+(ll)phi[i]*calc(n/i,w/i))%MOD;
			if (i*i<d) ans=(ans+(ll)phi[d/i]*calc(n/(d/i),w/(d/i)))%MOD;
		}
//	for (int i=1;i<=n+w;i++)
//	{
//		int d=gcd(i,n+w),s=(n+w)/d;
//		if (n%s||w%s) continue;
//		ans=(ans+calc(n/s,w/s))%MOD;
//	}
	ans=(ll)ans*finv[n+w]%MOD*fac[n+w-1]%MOD;
	cout<<ans;
	return 0;
}
```


---

## 作者：ZillionX (赞：1)

# Description

给出一个大小为 $n$ 的环，问将环恰好涂成 $m$ 个黑色与 $n-m$ 个白色，且环上没有一段黑色长度超过 $k$ 的方案数，环旋转同构。

$n,m,k \le 10^5$，时限 1s。

# Solution

神仙题啊，学到很多。

首先这题肯定一眼群论，考虑 Pólya 定理。

设 $f(x)$ 为旋转了 $x$ 步的不动的染色方案数，那么答案为 $\dfrac{1}{n} \sum\limits_{i=1}^n f(i)$。

这样直接搞不优雅，根据[这题](https://www.luogu.com.cn/problem/P4980)的结论，我们将 $f(x)$ 的定义变为拆分出的循环数量为 $x$ 的置换的不动的染色方案数，那么答案就变为 $\dfrac{1}{n} \sum\limits_{i=1}^n f(\gcd(i,n))$。

这么求复杂度不对劲，不妨换为枚举 $\gcd(i,n)$，那么可以变为 $\dfrac{1}{n} \sum\limits_{i \mid n} f(i) \varphi(\dfrac{n}{i})$。

我们现在考虑怎么求 $f(x)$，明显序列上每个点的循环编号是有循环节的，每节大小为 $x$，共有 $\dfrac{n}{x}$ 个。那么我们设 $g(n,m)$ 为在一个大小为 $n$ 的环上合法染色的方案数，很容易得出

$$f(x)=[x \mid m] g(x,\frac{m}{\frac{n}{x}})$$

现在终于可以直接染了，这是我们擅长的东西。考虑拆环为链。

我们又设 $c(n,m)$ 为在 $n$ 个有标号的盒子里放 $m$ 个球，每个盒子最多放 $k$ 的方案数，这个东西明显很容易用容斥和插板法 $\mathcal O(\min\bigg\{n,\dfrac{m}{k}\bigg\})$ 地做出来，留作读者练习。

因为是在环上染色，我们需要拆为链时需要保证最前面和最后面的黑球个数加起来也不超过 $k$，不妨枚举这个数目，我们有

$$g(n,m)=\sum_{i=0}^k (i+1) c(n-m-1,m-i)$$

然后直接算就可以了。

总所周知 $n$ 的约数和是 $\mathcal O(n \log n)$ 级别的，约数个数是 $\mathcal O(\sqrt n)$ 级别的（这个大概率跑不满，$10^5$ 内的最大约数个数也就 $128$），所以复杂度是 $\mathcal O(n \log n + k \sqrt n)$。

上面的复杂度推导比较粗糙，实际上这种写法跑得飞快。

好像也有不用脑子的 GF 推法，有兴趣的读者可以自行尝试。

实现时注意特判 $n=m$ 的情况，以及当 $m \le k$ 时 $g(n,m)=\dbinom{n}{m}$。

# Code

```cpp
typedef long long LL;

const int N=2e5+5;
const LL mod=998244353;

int n,m,k,tot,p[N],phi[N];
bitset<N> v;
LL fac[N],inv[N],ifac[N];

int gcd(int a,int b) {
	if (!b) return a;
	return gcd(b,a%b);
}

void Init(int n) {
	fac[0]=inv[1]=ifac[0]=1;
	for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	for (int i=2;i<=n;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for (int i=1;i<=n;i++) ifac[i]=ifac[i-1]*inv[i]%mod;
}

void Phi(int n) {
	phi[1]=1;
	for (int i=2;i<=n;i++) {
		if (v[i]==0) p[++tot]=i,phi[i]=i-1;
		for (int j=1;j<=tot && i*p[j]<=n;j++) {
			v[i*p[j]]=1;
			if (i%p[j]) phi[i*p[j]]=phi[i]*phi[p[j]];
			else {
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
		}
	}
}

LL C(int n,int m) {
	if (n<m) return 0;
	return fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}

LL Q(int n,int m) {
	return C(n+m-1,n-1);
}

LL D(int n,int m) {
	LL Ans=0;
	for (int i=0;i<=min(m/(k+1),n);i++)
		if (i&1) Ans=(Ans-C(n,i)*Q(n,m-i*(k+1))%mod)%mod;
		else Ans=(Ans+C(n,i)*Q(n,m-i*(k+1))%mod)%mod;
	return (Ans+mod)%mod;
}

LL G(int n,int m) {
	LL Ans=0;
	if (m<=k) return C(n,m);
	for (int i=0;i<=k;i++)
		Ans=(Ans+D(n-m-1,m-i)*(i+1)%mod)%mod;
	return Ans;
}

LL F(int n,int m) {
	LL Ans=0;
	for (int i=1;i<=n;i++)
		if (!(n%i) && !(m%(n/i)))
			Ans=(Ans+G(i,m/(n/i))*phi[n/i]%mod)%mod;
	return Ans*inv[n]%mod;
}

int main() {
	scanf("%d%d%d",&n,&m,&k);
	if (n==m) {
		if (k>=n) printf("1");
		else printf("0");
		return 0;
	}
	Init(n+m),Phi(n+m);
	
	printf("%lld",F(n,m));
	
	return 0;
}
```


---

## 作者：raincity (赞：0)

[更好的阅读体验](https://blog.calvincheng1231.org.cn/default/74.html)

## 分析

感谢 zhs 大佬的讲解。

假定最后一个珠子是白色。现在在不考虑旋转的情况下求出答案。记这个答案为 $S(n,m)$。

首先将 $n-m$ 个白色珠子排成一排。在每一个白珠子前面插入一些黑珠子。

发现不能有连续 超过 $k$ 个黑珠子的限制不好考虑。容斥。

设 $f_i$ 为至少有 $i$ 个区间（指两个白珠子之间）里插入了超过 $k$ 个黑珠子的方案数。

则 $S(n,m)=\sum_{i=0}^{n-m}(-1)^i\times f_i$。

$f_i$ 可以用隔板法计算。先强制在 $i$ 个区间里面插入 $k+1$ 个黑珠子，然后其它黑珠子随便放。

即 $f_i=\binom{n-m}{i}\times \binom{n-i(k+1)-1}{n-m-1}$。

现在考虑循环同构的限制。

我们发现，如果按照上述方式计算，一个黑白珠子的排列方式会被重复计算其最小循环节次。

设 $g_i$ 为循环节个数为 $i$ 的倍数的排列方案数，$h_i$ 为最小循环节个数为 $i$ 的排列方案数。

首先，$g_i\not=0$ 当且仅当 $i|m$ 且 $i|n-m$。也就是 $i|gcd(n,m)$。

然后考虑如何计算 $g_i$。

因为 $i|gcd(n,m)$，所以满足最小循环节长度为 $i$ 的因数的排列方案一定满足 $i$ 也是其循环节。

只需要考虑一个循环节内部的小环。故 $g_i=S(\dfrac{n}{i},\dfrac{m}{i})$。

最后考虑如何计算 $h_i$。

有 $g_i=\sum\limits_{i|d}h(d)$。

莫比乌斯反演得 $h(i)=\sum\limits_{i|d}\mu(\dfrac{i}{d})g(d)$。

答案为 $\sum\limits_{d|gcd(n,m)}\dfrac{h(d)\times d}{n-m}$。

模数是质数，预处理逆元、阶乘、阶乘的逆元、莫比乌斯函数即可。

时间复杂度不知道怎么算，但是跑得飞快。

## 解决

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 5, MOD = 998244353;
int n, m, k, d;
int inv[N], invfac[N], fac[N], mu[N], prime[N], cnt, g[N];
bool isPrime[N];

void prework() {
	memset(isPrime, true, sizeof(isPrime));
	isPrime[1] = false, mu[1] = 1;
	for (int i = 1; i <= n; i++) {
		if (isPrime[i]) {
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for (int j = 1; j <= cnt && i <= n / prime[j]; j++) {
			isPrime[i * prime[j]] = false;
			if (i % prime[j])
				mu[i * prime[j]] = -mu[i];
			else {
				mu[i * prime[j]] = 0;
				break;
			}
		}
	}
	inv[0] = inv[1] = invfac[0] = invfac[1] = fac[0] = fac[1] = 1;
	for (int i = 2; i <= n; i++) {
		inv[i] = 1LL * inv[MOD % i] * (MOD - MOD / i) % MOD;
		invfac[i] = 1LL * invfac[i - 1] * inv[i] % MOD;
		fac[i] = 1LL * fac[i - 1] * i % MOD;
	}
}

int C(int m, int n) {
	if (m < 0 || n < 0 || m < n)
		return 0;
	return 1LL * fac[m] * invfac[n] % MOD * invfac[m - n] % MOD;
}

int S(int n, int m) {
	int ans = 0;
	for (int i = 0; i <= m / (k + 1); i++) {
		int res = 1LL * C(n - m, i) * C(n - i * (k + 1) - 1, n - m - 1) % MOD;
		if (i & 1)
			ans = (ans - res + MOD) % MOD;
		else
			ans = (ans + res) % MOD;
	}
	return ans;
}

int H(int x) {
	int ans = 0;
	for (int i = x, j = 1; i <= d; i += x, j++)
		if (mu[j] == 1)
			ans = (ans + g[i]) % MOD;
		else if (mu[j] == -1)
			ans = (ans - g[i] + MOD) % MOD;
	return ans;
}

int gcd(int x, int y) {
	int r = x % y;
	while (r) x = y, y = r, r = x % y;
	return y;
}

int main() {
	cin >> n >> m >> k;
	if (m == 0) {
		puts("1");
		return 0;
	}
	prework();
	d = gcd(n, m);
	for (int i = 1; i <= d; i++)
		if (d % i == 0)
			g[i] = S(n / i, m / i);
	int ans = 0;
	//for (int i = 1; i <= 3; i++) printf("H(%d) = %d\n", i, H(i));
	for (int i = 1; i <= d; i++)
		if (d % i == 0)
			ans = (ans + 1LL * H(i) * i) % MOD;
	cout << 1LL * ans * inv[n - m] % MOD << endl;
	return 0;
}

```



---


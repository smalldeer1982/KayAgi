# [Cnoi2019] 数字游戏

## 题目描述

给定一个 $1\sim n$ 的排列 $\pi$，以及 $q$ 个询问，每个询问包含一个整数四元组 $( l, r, x, y )$，表示查询有多少个整数二元组 $( u, v )$ 满足：
 - $l\le u\le v\le r$；
 - 且对于任意 $\forall u\le i\le v$，有 $x\le\pi_i\le y$。

## 说明/提示

子任务 1（$34$ points）：$1\le n, q \le 3\times10^4$。

子任务 2（$66$ points）：$1\le n, q \le 2\times10^5$。

## 样例 #1

### 输入

```
4 1
1 2 3 4
1 4 2 4```

### 输出

```
6```

# 题解

## 作者：bzy369258147 (赞：28)

**简述题意:**  
给定一个排列，多次询问，求一个区间 $[l,r]$ 有多少个子区间的值都在区间 $[x,y]$ 内。

--------
**算法1:**

对于每个询问暴力枚举子区间，然后暴力检测是否满足条件，时间复杂度 $O(qn^3)$。

用ST表预处理, $O(1)$查询区间最值可以做到 $O(qn^2+nlogn)$。

期望得分: $0$

**算法2:**

我们发现查询一个区间时，其中每个满足所有元素都在 $[x,y]$ 内的 **极长子区间** 的贡献为 $\frac{t(t+1)}{2}$, 其中 $t$ 为该子区间的长度。

于是对于每次询问时扫描出所有极长子区间即可做到 $O(qn)$。

期望得分: $0$ ~ $34$

(虽然构造数据卡了，但还是被一位小常数玩家卡过去了第一档分)

**算法3:**

很容易想到要使用数据结构维护，于是我们想到了莫队，但是 值域$[x,y]$ 一直在变，似乎很难维护，所以我们选择转变思路。

由于题目给的序列时一个排列，所以我们考虑在值域上莫队，每次移动只会改变一个位置是否有效。然后考虑维护答案，很显然可以线段树。每个节点维护一下
左、右端开始的极长有效区间长度，区间答案，与区间是否全部有效即可。

时间复杂度 $O(n\sqrt{q}\ logn)$

期望得分: $34$

**算法4:**

考虑另一种 $O(qn)$的做法，每次询问扫描值域，判断值域内每个值是否在区间内，在就更新答案。更新答案时需要用链表维护一下每个极大有效区间。

期望的分 $0$

**算法5:**

发现时间复杂度的瓶颈在于查询时需要线段树，考虑优化。

所以我们对序列分块,结合算法四的方法，每个块内单独维护一个链表，和区间的答案，由于维护的信息难以撤销，所以我们选择回滚莫队维护值域，区间长度小于等于 $2\sqrt{n}$的使用算法4暴力，大于的部分每次 $O(\sqrt{n})$查询，每次莫队移动时$O(1)$维护所在块的链表，回滚时使用时间戳$O(1)$回溯。

总体时间复杂度 $O(n\sqrt{n})$,代码量4k左右。

期望得分: $100$

总体来说这是一道简单的题，解法自然，码量适中，思维难度适中，考察了线段树、莫队、分块、链表等多种初等数据结构，是一道不折不扣的小清新数据结构好题。

附std：

```cpp
// 防抄袭片段已混入
#include<bits/stdc++.h>
using namespace std;

typedef unsigned char LL;

LL que_range( int x ) { return 1ll * x * (x + 1) / 2; }

template<int _size>
struct stamp{
    //int A[ _size ];
    //int B[ _size ];
    //int T[ _size ];
    //int cnt = 1;
    //bool bind = false;
    
    //void Roll() { cnt ++; }
    //void Bind() { bind = true; Roll(); }
    //void Unte() { bind = false; }
    
    //void Set0() { memset( B, 0, sizeof(B) ); Roll(); }
    
    int& operator []( int index ) {
        if( bind ) {
            if( T[index] ^ cnt ) T[index] = cnt, A[index] = B[index];
            return A[index];
        } else return B[ index ];	
    }
};

int block = 10;
int belong[200005];
int beg[405];

struct que{
    int l, r, x, y, id;	
    que() {}
    que( int _id ) { cin >> l >> r >> x >> y; id = _id; }
    bool operator <( que& from ) const
      { return belong[x] == belong[ from.x ] ? y < from.y : x < from.x; }
};

int n, q; 
vector<que> Q;

int c [200005];
int uc[200005];

stamp<200005> pre;
stamp<200005> nxt;
stamp<405> mid;

int bf1( que& x ) { 
    int ans = 0, lst = 0;
    for( int i = x.l; i <= x.r; i ++ ) {
        if( c[i] <= x.y and c[i] >= x.x ) lst ++;
        else lst = 0;
        ans += lst;
    }
    return ans;
}

int bf2( que& x ) {
    int ans = 0;
    for(int i = x.x;i <= x.y;i ++) {
        int p = uc[i];
        if( p < x.l or p > x.r ) continue;
        ans -= que_range( p - pre[p - 1] );
        ans -= que_range( nxt[p + 1] - p );
        nxt[ pre[p - 1] ] = nxt[p + 1];
        pre[ nxt[p + 1] ] = pre[p - 1];
        ans += que_range( nxt[p + 1] - pre[p - 1] + 1 );
    }
    pre.Roll(); nxt.Roll();
    return ans;
}

void updata( int x ) {
    int p = uc[x], b = belong[p];
    if( p ^ beg[b] ) {
        if( pre[p - 1] != beg[b] ) mid[b] -= que_range( p - pre[p - 1] );
        if( p != beg[b + 1] - 1 )nxt[ pre[p - 1] ] = nxt[p + 1];
        else nxt[p] = p, pre[p] = pre[p - 1], nxt[ pre[p - 1] ] = p;
    }
    if( p ^ beg[b + 1] - 1 ) {
        if( nxt[p + 1] != beg[b + 1] - 1 ) mid[b] -= que_range( nxt[p + 1] - p );
        if( p != beg[b] ) pre[ nxt[p + 1] ] = pre[p - 1];
        else pre[p] = p, nxt[p] = nxt[p + 1], pre[ nxt[p + 1] ] = p;
    }
    if( p != beg[b] and p != beg[b + 1] - 1 and pre[p - 1] != beg[b] and nxt[p + 1] != beg[b + 1] - 1 ) 
        mid[b] += que_range( nxt[p + 1] - pre[p - 1] + 1 );
}

LL ans[200005];

int main(){
    cin >> n >> q; 
    
    for(int i = 1;i <= n;i ++) {
        cin >> c[i]; uc[ c[i] ] = i;
        belong[i] = i / block + 1;
        if( belong[i] > belong[i - 1] ) beg[ belong[i] ] = i;
    }
    if( beg[ belong[n] ] == n ) belong[n] --;
    beg[ belong[n] + 1 ] = n + 1; belong[ n + 1 ] = belong[n] + 1;
    
    for(int i = 0;i <= n + 1;i ++) pre[i] = i + 1, nxt[i] = i - 1;
    nxt.Bind(); pre.Bind(); mid.Bind();
    
    for(int i = 1;i <= q;i ++) {
        que x = que(i);
        if     ( x.r - x.l <= block * 2 ) ans[i] = bf1( x );
        else if( x.y - x.x <= block * 2 ) ans[i] = bf2( x ); 
        else Q.push_back( x );
    }
    sort( Q.begin(), Q.end() );
    int pt = 0;
    for(int i = 1;i < belong[n];i ++) {
        int r = beg[i + 1] - 1;
        
        nxt.Unte(); pre.Unte(); mid.Unte();
        for(int j = 0;j <= n + 1;j ++) pre[j] = j + 1, nxt[j] = j - 1; mid.Set0();
        
        while( pt < Q.size() and belong[ Q[pt].x ]  == i ) {
            auto &P = Q[pt];
            
            nxt.Unte(); pre.Unte(); mid.Unte();
            while( r < P.y ) updata( ++ r );
            
            nxt.Bind(); pre.Bind(); mid.Bind();
            for( int j = P.x; j < beg[i + 1]; j ++ ) updata( j );
            
            long long Ans = 0, lst = 0; 
            int bl = belong[ P.l - 1 ] + 1;
            int br = belong[ P.r + 1 ] - 1;
            
            for( int j = P.l; belong[j] < bl; j ++ ) {
                if( c[j] >= P.x and c[j] <= P.y ) lst ++;
                else Ans += que_range( lst ), lst = 0;
            }
            
            for( int j = bl; j <= br; j ++ ) {
                if( nxt[ beg[j] ] == beg[j + 1] - 1 ) lst += beg[j + 1] - beg[j];
                else {
                    lst += nxt[ beg[j] ] - beg[j] + 1;
                    Ans += que_range(lst); Ans += mid[j];
                    lst = beg[j + 1] - pre[ beg[j + 1] - 1 ];
                }
            }
            
            for( int j = beg[br + 1]; j <= P.r; j ++ ) {
                if( c[j] >= P.x and c[j] <= P.y ) lst ++;
                else Ans += que_range( lst ), lst = 0;
            }
            
            Ans += que_range( lst );
            ans[ P.id ] = Ans;
            
            nxt.Roll(); pre.Roll(); mid.Roll();
            pt ++;
        }
    }
    for(int i = 1;i <= q;i ++) cout << ans[i] << "\n";
    return 0;
}
```


---

## 作者：251Sec (赞：13)

对 $x,y$ 两维跑莫队，问题转变为：

维护一个 $\texttt{0/1}$ 序列，支持单点修改，区间查询极长 $\texttt{1}$ 连续段的 $\dfrac{l(l+1)}{2}$ 和。

事实上 $\texttt{1}$ 变 $\texttt{0}$ 不好处理，考虑使用回滚莫队，这样我们就只用处理 $\texttt{0}$ 变 $\texttt{1}$ 的情况。线段树是 trivial 的，我们可以直接维护每一段的「与开头相连的最长 $\texttt{1}$ 连续段」「与结尾相连的最长 $\texttt{1}$ 连续段」「所有极长 $\texttt{1}$ 连续段 $\dfrac{l(l+1)}{2}$ 和」然后这个信息显然可以合并，但是这玩意带个 $\log$。

我们希望有一个 $O(1)$ 修改 $O(\sqrt{n})$ 询问的数据结构，这样我们的总复杂度就是 $O(n\sqrt{n})$ 的（设 $n,q$ 同阶）。

分块。每一块内对每个极长 $\texttt{1}$ 连续段的开头和结尾维护指向对方的指针。这样我们每次 $\texttt{0}$ 变 $\texttt{1}$ 的时候可以 $O(1)$ 地维护这些指针并处理出「块内与开头相连的最长 $\texttt{1}$ 连续段」「块内与结尾相连的最长 $\texttt{1}$ 连续段」「块内所有极长 $\texttt{1}$ 连续段 $\dfrac{l(l+1)}{2}$ 和」。在询问时我们可以直接用 $O(\sqrt{n})$ 个块的信息合并出整段的信息，于是这题就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, B;
int a[200005], id[200005];
ll CalcW(int l) { return 1ll * l * (l + 1) / 2; }
struct Data {
    int llen, rlen, len;
    ll sum;
    bool empty;
    Data() { llen = rlen = sum = 0; empty = false; }
    Data(int llen, int rlen, ll sum) : llen(llen), rlen(rlen), sum(sum) { empty = false; }
};
Data operator+(const Data &a, const Data &b) {
    if (a.empty) return b;
    if (b.empty) return a;
    Data res;
    res.llen = a.llen;
    res.len = a.len + b.len;
    if (res.llen == a.len) res.llen += b.llen;
    res.rlen = b.rlen;
    if (res.rlen == b.len) res.rlen += a.rlen;
    res.sum = a.sum + b.sum - CalcW(a.rlen) - CalcW(b.llen) + CalcW(a.rlen + b.llen);
    return res;
}
vector<pair<int&, int>> st1;
vector<pair<Data&, Data>> st2; 
struct Blocks {
    int w[200005];
    int st[505], ed[505], bel[200005];
    int ptr[200005];
    Data dat[505];
    void Init(int n) {
        for (int i = 1; i <= n; i++) {
            bel[i] = (i + B - 1) / B;
            if (i % B == 1) st[bel[i]] = i;
            if (i % B == 0) ed[bel[i]] = i;
        }
        for (int i = 1; i <= bel[n]; i++) {
            st[i] = i * B - B + 1;
            ed[i] = i * B;
            dat[i].len = B;
        }
        ed[bel[n]] = n;
    }
    void Modify(int i, bool und) {
        if (und) {
            st2.emplace_back(dat[bel[i]], dat[bel[i]]);
            st1.emplace_back(w[i], w[i]);
        }
        if ((bel[i] != bel[i + 1] || !w[i + 1]) && (bel[i] != bel[i - 1] || !w[i - 1])) {
            if (und) st1.emplace_back(ptr[i], ptr[i]);
            ptr[i] = i;
            dat[bel[i]].sum++;
        }
        else if ((bel[i] != bel[i + 1] || !w[i + 1])) {
            if (und) {
                st1.emplace_back(ptr[ptr[i - 1]], ptr[ptr[i - 1]]);
                st1.emplace_back(ptr[i], ptr[i]);
            }
            int len = i - 1 - ptr[i - 1] + 1;
			int t = ptr[i - 1];
            ptr[t] = i; ptr[i] = t;
            dat[bel[i]].sum += CalcW(len + 1) - CalcW(len);
        }
        else if ((bel[i] != bel[i - 1] || !w[i - 1])) {
            if (und) {
                st1.emplace_back(ptr[ptr[i + 1]], ptr[ptr[i + 1]]);
                st1.emplace_back(ptr[i], ptr[i]);
            }
            int len = ptr[i + 1] - (i + 1) + 1;
			int t = ptr[i + 1];
            ptr[t] = i; ptr[i] = t;
            dat[bel[i]].sum += CalcW(len + 1) - CalcW(len);
        }
        else {
            if (und) {
                st1.emplace_back(ptr[ptr[i + 1]], ptr[ptr[i + 1]]);
                st1.emplace_back(ptr[ptr[i - 1]], ptr[ptr[i - 1]]);
            }
            int len1 = i - 1 - ptr[i - 1] + 1, len2 = ptr[i + 1] - (i + 1) + 1;
            int x = ptr[i - 1], y = ptr[i + 1];
            ptr[y] = x; ptr[x] = y;
            dat[bel[i]].sum += CalcW(len1 + len2 + 1) - CalcW(len1) - CalcW(len2);
        }
        w[i] = 1;
        if (w[st[bel[i]]]) dat[bel[i]].llen = ptr[st[bel[i]]] - st[bel[i]] + 1;
        else dat[bel[i]].llen = 0;
        if (w[ed[bel[i]]]) dat[bel[i]].rlen = ed[bel[i]] - ptr[ed[bel[i]]] + 1;
        else dat[bel[i]].rlen = 0;
    }
    ll Query(int l, int r) {
        int lt = bel[l], rt = bel[r];
        if (lt == rt) {
            ll res = 0;
            for (int i = l, j = 0; i <= r; i++) {
                if (w[i]) res += ++j;
                else j = 0;
            }
            return res;
        }
        Data dt; dt.empty = true;
        for (int i = lt + 1; i <= rt - 1; i++) dt = dt + dat[i];
        Data ldt = Data(0, 0, 0), rdt = Data(0, 0, 0);
        int s = 0;
        for (int i = l; i <= ed[lt]; i++) {
            if (w[i]) ldt.sum += ++s;
            else s = 0;
        }
        ldt.rlen = s; s = 0;
        for (int i = r; i >= st[rt]; i--) {
            if (w[i]) rdt.sum += ++s;
            else s = 0;
        }
        rdt.llen = s;
        dt = ldt + dt + rdt;
        return dt.sum;
    }
} blk;
struct Query {
    int l, r, x, y, id;
    bool operator<(const Query &o) const {
		if (x / B != o.x / B) return x / B < o.x / B;
		return y < o.y;
	}
} q[200005];
int l, r;
ll ans[200005];
int main() {
    scanf("%d%d", &n, &m);
    B = sqrt(n);
    for (int i = 1; i <= n; i++) scanf("%d", a + i), id[a[i]] = i;
    for (int i = 1; i <= m; i++) scanf("%d%d%d%d", &q[i].l, &q[i].r, &q[i].x, &q[i].y), q[i].id = i;
    blk.Init(n);
    sort(q + 1, q + m + 1);
    for (int i = 1, j = 1; i <= m; i = j) {
        while (j <= m && q[i].x / B == q[j].x / B) j++;
        l = q[i].x / B * B + B; r = l - 1;
        int lp = l;
        for (int k = i; k < j; k++) {
            if (q[k].y / B == q[k].x / B) {
                for (int v = q[k].x; v <= q[k].y; v++) blk.Modify(id[v], true);
                ans[q[k].id] = blk.Query(q[k].l, q[k].r);
                while (!st1.empty()) st1.back().first = st1.back().second, st1.pop_back();
                while (!st2.empty()) st2.back().first = st2.back().second, st2.pop_back();
                continue;
            }
            while (r < q[k].y) blk.Modify(id[++r], false);
            while (l > q[k].x) blk.Modify(id[--l], true);
            ans[q[k].id] = blk.Query(q[k].l, q[k].r);
            while (!st1.empty()) st1.back().first = st1.back().second, st1.pop_back();
            while (!st2.empty()) st2.back().first = st2.back().second, st2.pop_back();
            l = lp;
        }
        memset(blk.dat, 0, sizeof(blk.dat)); memset(blk.ptr, 0, sizeof(blk.ptr));
        memset(blk.w, 0, sizeof(blk.w));
        for (int k = 1; k <= blk.bel[n]; k++) blk.dat[k].len = B;
    }
    for (int i = 1; i <= m; i++) printf("%lld\n", ans[i]);
    return 0;
}
```

---

## 作者：Others (赞：6)

这题和[第十分块](https://www.luogu.com.cn/problem/P6578)神似。
# 题目大意
在指定区间内有多少子区间的值域在 $[x,y]$ 内。
# 思路
这题我就讲讲怎样用回滚莫队做，具体维护方法请参考我的[第十分块的题解](https://www.luogu.com.cn/blog/abcdefghijklmnopqrst/solution-p6578)。

这题也不好像第十分块一样将查询的值域排序（因为有 $y$ 当上限），所以我们考虑在值域上用回滚莫队，即在值域上分块。这题有个非常妙的地方就是 $a$ 序列是 1 到 $n$ 的序列，所以值域分块可以和序列分块混在一起。题打 $O(1)$ 修改，$O(\sqrt n)$查询的分块，这样时间复杂度就可以降到 $O(n\sqrt n)$，我看出题人将时间跳的这么高就是为了适应 $O(n\sqrt n \log n)$ 的时间复杂度，所以也就不用像第十分块一样大力卡常了 qwq。

给给代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=200005,sn=1505;
int n,m,s,l=1,r,a[maxn],idx[maxn],L[sn],R[sn],head[maxn],nxt[maxn],to[maxn],cnt,block;
int pos[maxn],sum[sn],top;
bool flag[maxn];
long long ans[maxn],gx[maxn];
struct query{
	int l,r,x,y,id;
}p[maxn];
struct node{
	int ll,lr,rr,rl,x;
	bool type;
	long long val;
}sta[maxn],tmp;
bool cmp(query x,query y){
	return idx[x.x]==idx[y.x]?x.y<y.y:x.x<y.x;
}
void add(int u,int v){
	nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v;
}
void modify(int x,bool type){
	pos[x]=x,flag[x]=1,tmp.x=x;
	int last=x-1,next=x+1,Tmp=pos[last];
	bool flag1=(flag[last]&&L[idx[x]]!=x),flag2=(flag[next]&&R[idx[x]]!=x);
	if(!flag1&&!flag2) tmp.type=tmp.ll=tmp.rr=tmp.lr=tmp.rl=0,tmp.val=1;
	else{
		tmp.type=1;
		if(flag1&&flag2) {
            tmp.val=(next-pos[last])*(pos[next]-last);
            tmp.ll=pos[last],tmp.lr=last,pos[pos[last]]=pos[next];
			tmp.rr=pos[next],tmp.rl=next,pos[pos[next]]=Tmp;
		}else{
			if(flag1){
                tmp.val=next-pos[last];
                tmp.ll=x,tmp.lr=x,pos[x]=pos[last];
                tmp.rr=pos[last],tmp.rl=last,pos[pos[last]]=x;
			}else{
                tmp.val=pos[next]-last;
                tmp.ll=x,tmp.lr=pos[x],pos[x]=pos[next]; 
                tmp.rr=pos[next],tmp.rl=next,pos[pos[next]]=x;
			}
		}
	}
	sum[idx[x]]+=tmp.val;
	if(type) sta[++top]=tmp;
}
long long Q(int l,int r){
	long long tot=0,len=0;
	if(idx[l]==idx[r]){
		for(int i=l;i<=r;++i){
			if(flag[i]) ++len;
			else tot+=gx[len],len=0;
		}
		return tot+gx[len];
	}
	for(int i=l;i<=R[idx[l]];++i){
		if(flag[i]) ++len;
		else tot+=gx[len],len=0;
	}
	for(int i=idx[l]+1;i<idx[r];++i){
		if(pos[L[i]]==R[i]) len+=R[i]-L[i]+1;
		else{
			if(flag[L[i]]) len+=pos[L[i]]-L[i]+1,tot-=gx[pos[L[i]]-L[i]+1];
			tot+=gx[len]+sum[i],len=0;
			if(flag[R[i]]) len+=R[i]-pos[R[i]]+1,tot-=gx[R[i]-pos[R[i]]+1];
		}
	}
	for(int i=L[idx[r]];i<=r;++i){
		if(flag[i]) ++len;
		else tot+=gx[len],len=0;
	}
	return tot+gx[len];
}
int main() {
	scanf("%d%d",&n,&m);
	s=sqrt(n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		add(a[i],i);
		idx[i]=(i+s-1)/s,gx[i]=1ll*i*(i+1)/2;
		if(idx[i]!=idx[i-1]){
			R[idx[i-1]]=i-1;
			L[idx[i]]=i;
		}
	}
	R[idx[n]]=n;
	for(int i=1;i<=m;++i){
		scanf("%d%d%d%d",&p[i].l,&p[i].r,&p[i].x,&p[i].y);
		p[i].id=i;
	}
	sort(p+1,p+m+1,cmp);
	block=0;
	for(int i=1;i<=m;++i){
		if(idx[p[i].x]==idx[p[i].y]){
			memset(flag,0,sizeof(flag));
			memset(sum,0,sizeof(sum));
			memset(pos,0,sizeof(pos));
			for(int j=p[i].x;j<=p[i].y;++j) for(int k=head[j];k;k=nxt[k]) modify(to[k],0);
			ans[p[i].id]=Q(p[i].l,p[i].r);
			continue;
		}
		l=R[idx[p[i].x]];
		if(idx[p[i].x]!=block){
			memset(flag,0,sizeof(flag));
			memset(sum,0,sizeof(sum));
			memset(pos,0,sizeof(pos));
			r=l-1,block=idx[p[i].x];
		}
		while(r<p[i].y) for(int j=head[++r];j;j=nxt[j]) modify(to[j],0);
		while(l>p[i].x) for(int j=head[--l];j;j=nxt[j]) modify(to[j],1);
		ans[p[i].id]=Q(p[i].l,p[i].r);
		while(top){ 
	        tmp=sta[top--],sum[idx[tmp.x]]-=tmp.val,flag[tmp.x]=0;
			if(tmp.type) pos[tmp.rr]=tmp.rl,pos[tmp.ll]=tmp.lr;
		}
	}
	for(int i=1;i<=m;++i) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：_Anchor (赞：6)

## 题目

[P5386 [Cnoi2019]数字游戏](https://www.luogu.com.cn/problem/P5386)

给定一个序列，每次询问：给定 $l,r,x,y$ ，问 $[l,r]$ 有多少个子区间满足其区间所有数使得 $x\leq a_i \leq y$。

$n,q\leq 10^5$。

（和 [第十分块](https://www.luogu.com.cn/problem/P6578) 的分块维护几乎一模一样。）

## 分析

回滚莫队+序列分块。

首先这道题限制很多，但是可以离线，数据范围又是 $1e5$ ，于是理所当然可以想一下莫队。

发现直接莫队就可以去除 $l,r$ 的限制条件，现在问题变成了，询问当前序列有多少个这样的子区间满足 $x\leq a_i \leq y$。

由于 $x,y$ 都是一个静态的给定值，于是可以想到把这个不等关系变成 01 变量来表示，那么这里就可以这样转化成：

定义 $b_i=(x\leq a_i \leq y)$ ，接下来就是询问所有极长连续 1 子区间的 $siz*(siz+1)/2$ 的和，同时还有单点修改，每次 $0->1$ 或者 $1->0$。

那么这里我们要支持这样 $O(1)$ 的单点修改和 $O(\sqrt{n})$ 的单次查询才行，可以考虑序列分块或者链表，这里使用序列分块。

因为 $1->0$ 非常的不好处理，于是我们要想怎么把这个东西去掉。

发现这样的情况只会在这种情况下出现：由于我们使用的是普通莫队，所以我们会导致有一个删除操作，就是这个删除操作会导致有 $1->0$ 这种情况。

那么不删除不就好了？再加上分块可以支持撤回操作（可撤销分块（雾））（像可撤销并查集一样拿一个栈记录操作就好了），于是我们就直接回滚莫队来把删除操作变成撤销操作即可。

块大小取 $\sqrt{n}$，这样时间复杂度是 $O(n\sqrt{n})$ （假设 $n,q$ 同阶）。

## 代码


要的可以私信我 $QWQ$ 。


---

## 作者：critnos (赞：4)

关于我用 $n\sqrt n \log n$ 的莫队套半群信息维护方式过了的事情.jpg

讲一个很实用的这一类的卡常方法。

下面认为 $q=n$。

这题的莫队等一段带过：在值域上做莫队，每次将所有 $x\le a_i\le y$ 的 $i$ 标记为 $1$，否则为 $0$。得到一个 $01$ 序列，得出区间 $[l,r]$ 中所有极长 $1$ 连续段，设其长度为 $len$，那么这个连续段的贡献就是 $\dfrac {len(len+1)} 2$。答案即为区间中所有的极长连续段的贡献之和。正确性显然：本题的限制条件等价于子段中所有数 $\in[x,y]$，在一个 $1$ 的极长连续段内的任意子段都是合法的。

所以线段树维护的信息是从左开始的极长连续 $1$ 的长度，从右开始的极长连续 $1$ 的长度，区间是否全部为 $1$ 和区间的答案。

但是线段树的常数太大了！

所以考虑序列分块，每块维护一个线段树，设块大小为 $b$，那么更新线段树的复杂度为 $O(\log b)$。查询的时候，散块和整块的信息都从线段树里面查。

查询整块的复杂度是 $O(1)$ 的（线段树根节点的信息），那么我们这时候的复杂度是
 $O(\dfrac {n^2} b+n\sqrt n \log b)$。
 
设 $b=n^k,k\in(0,1]$。

那么复杂度是 $O(n^{2-k}+n^{1.5} k \log n)$。

要最小化上值，提出一个 $n^{1.5}$，得出了 $O(n^{1.5}(\max(n^{0.5-k},1) k \log n))$。

显然上柿在渐进意义下 $k\ge0.5$ 时最优。。而显然 $k$ 应当 $=0.5$ 才能使上柿最小。。

那岂不是没有用？？

当然不是！我们将瓶颈——更新线段树的运算次数下降到了 $\log \sqrt n=\dfrac 1 2 \log n$！

但这样仍然过不了题呀。。

所以要在合并信息上搞一下。

设线段树上左儿子的从右开始的极长连续 $1$ 的长度为 $a$，右儿子的从左开始的极长连续 $1$ 的长度为 $b$，左儿子的答案为 $s1$，右儿子的答案为 $s2$，该节点的答案为 $s$，那么有：

$s=s1+s2-\dfrac {a(a+1)} 2-\dfrac {b(b+1)} 2+-\dfrac {(a+b)(a+b+1)} 2$。这个柿子的意义是减去左边和右边的贡献再加上他们合起来的贡献。

$=s1+s2+\dfrac 1 2 (a^2+2ab+b^2+a+b-a^2-a-b^2-b)$

$=s1+s2+\dfrac 1 2(2ab)$

$=s1+s2+ab$。

~~太神奇了。~~

（upd：这东西理解为从 $a,b$ 中分别一个 $l,r$ 更好些）

然后削掉了一大块常数。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e5+5;
int a[maxn];
int id[maxn];
struct ask
{
	int w,l,r,x,y;
}w[maxn];
ll ans[maxn];
int read()
{
	int s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s;
}
int len,n;
const int b=500;
bool cmp(ask a,ask b)
{
	return (a.x/len^b.x/len)?a.x/len<b.x/len:((a.x/len&1)?a.y<b.y:a.y>b.y);
}
struct node
{
	int l,r;
	bool full;
	ll s;
	friend node operator +(const node &x,const node &y)
	{
		node ret;
		ret.s=x.s+y.s+1ll*x.r*y.l;
		ret.l=x.l+x.full*y.l;
		ret.r=y.r+y.full*x.r;
		ret.full=x.full&y.full;
		return ret;
	}
};
int wz[b+5];
struct segment_tree
{
	#define ls w<<1
	#define rs ls|1
	struct seg
	{
		int l,r;
		node s;
	}t[b*4+5];
	void build(int w,int l,int r)
	{
		t[w].l=l,t[w].r=r;
		if(l<r)
		{
			int mid=l+r>>1;
			build(ls,l,mid);
			build(rs,mid+1,r);
		}
		else wz[l]=w;
	}
	node ask()
	{
		return t[1].s;
	}
	node ask(int w,int l,int r)
	{
		if(t[w].l>=l&&t[w].r<=r) return t[w].s;
		if(t[ls].r>=l&&t[rs].l<=r) return ask(ls,l,r)+ask(rs,l,r);
		if(t[ls].r>=l) return ask(ls,l,r);
		return ask(rs,l,r);
	}
	void add(int w,bool v)
	{
		w=wz[w];
		t[w].s=node({v,v,v,v});
		for(w>>=1;w;w>>=1)
		{
			t[w].s.s=t[ls].s.s+t[rs].s.s+1ll*t[ls].s.r*t[rs].s.l;
			t[w].s.l=t[ls].s.l+t[ls].s.full*t[rs].s.l;
			t[w].s.r=t[rs].s.r+t[rs].s.full*t[ls].s.r;
			t[w].s.full=t[ls].s.full&t[rs].s.full;
		}
	}
}t[maxn/b+5];
int cnt;
int fl[maxn],fr[maxn];
int be[maxn];
void init()
{
	int i,j;
	for(i=1;i<=n;i+=b)
		fl[++cnt]=i,fr[cnt]=min(i+b-1,n);
	for(i=1;i<=cnt;i++)
	{
		for(j=fl[i];j<=fr[i];j++)
			be[j]=i;
		t[i].build(1,1,b);
	}	
}
void add(int x,int v)
{
	t[be[x]].add(x-fl[be[x]]+1,v);
}
int l=1,r;
node ask(int pl,int pr)
{
	int bl=be[pl],br=be[pr];
	if(bl==br) return t[bl].ask(1,pl-fl[bl]+1,pr-fl[bl]+1);
	node s=ask(pl,fr[bl]);
	for(int i=bl+1;i<br;i++)
		s=s+t[i].ask();
	return s+ask(fl[br],pr);
}
int main()
{
	int i,m;
	n=read(),m=read();
	len=n/(sqrt(m)*2/3);
	for(i=1;i<=n;i++)
		id[a[i]=read()]=i;
	for(i=0;i<m;i++)
		w[i].l=read(),w[i].r=read(),w[i].x=read(),w[i].y=read(),w[i].w=i;
	sort(w,w+m,cmp);
	init();
	for(i=0;i<m;i++)
	{
		while(r<w[i].y) add(id[++r],1);
		while(l<w[i].x) add(id[l++],0);
		while(l>w[i].x) add(id[--l],1);
		while(r>w[i].y) add(id[r--],0);
		ans[w[i].w]=ask(w[i].l,w[i].r).s;
	}
	for(i=0;i<m;i++)
		printf("%lld\n",ans[i]);
}
```


---

## 作者：Prean (赞：4)

### 写在前面的废话
~~自己写了两天，调了半天，然后jzp来帮忙调了一个小时，终于过了~~

~~过的时候耳机里放着桐姥爷的bgm，就差哭出来了~~
# 题解
首先这题没有部分分差评（

1. 值域不变

我们可以注意到，如果一个区间全部都在值域内（长度为 $ len $），那么这个区间的答案是 $ \frac {len \times (len+1)} 2 $。

然后我们很快能发现一个区间的答案就是这样的区间的答案之和。

然后我们就能用线段树做到 $ O(logn) $

2. 区间不变

此时我们在值域上进行莫队。

记录每个值对应的区间下标，然后可以视为这样的一个问题：
1. 加边
2. 询问所有联通块的贡献之和

我们当然能够使用可撤销并查集做到 $ O(m\sqrt n\log n) $。

但仔细想想，把莫队改为回滚莫队可以使用普通并查集做到 $ O(m\sqrt n) $。

3. 原问题

对序列分块，在莫队时维护块内答案和并查集即可。

整块和散块之间的答案使用算法 $ 1 $ 的方法即可求解。

复杂度 $ O(m\sqrt n) $，但是因为我并查集挂掉了所以只加了一个优化（

不过这题数据好像没卡，$ O(m\sqrt n\log n) $ 过去了。

附上 AC 前的最后一版代码：
```cpp
#include<algorithm>
#include<cstdio>
const int M=2e5+5,p=448,SIZ=p+5;
int n,m,len,a[M];long long ans[M];
int L[SIZ],R[SIZ],id[M],pos[M];
int top,valp[M],vald[M],vals[M];
bool vs[SIZ],vis[SIZ][SIZ];int t,pv[M],as[M];
struct Query{
	int L,R,x,y,p,id;
	inline bool operator<(const Query&it)const{
		return p==it.p?y<it.y:x<it.x;
	}
}q[M];
struct data{
	int L,R,len;long long ans;
	inline data operator*(const data&it)const{
		return (data){L+(L==len)*it.L,(it.R==it.len)*R+it.R,len+it.len,ans+it.ans+R*it.L};
	}
	inline void AddL(const bool&val){
		if(val){
			ans+=++L;if(R==len)++R;
		}
		else L=0;++len;
	}
	inline void AddR(const bool&val){
		if(val){
			ans+=++R;if(L==len)++L;
		}
		else R=0;++len;
	}
};
struct Block{
	int ans,len,f[SIZ],siz[SIZ];bool v[SIZ];
	inline void init(){
		for(register int i=0;i<=len;++i)siz[f[i]=i]=1,v[i]=false;ans=0;
	}
	inline void merge(const int&u,const int&v){
		if(siz[u]>siz[v])siz[f[v]=u]+=siz[v];
		else siz[f[u]=v]+=siz[u];
	}
	inline int Find(const int&u){
		return f[u]==u?u:f[u]=Find(f[u]);
	}
	inline void Add(const int&id){
		ans+=siz[Find(id-1)]*siz[Find(id)];merge(Find(id-1),Find(id));v[id]=true;
	}
	inline data Q(){
		return (data){siz[Find(0)]-1,siz[Find(len)]-1,len,ans};
	}
}B[SIZ];
inline void Update(const int&bid,const int&pos){
	if(vis[pos][bid])return;vis[pos][bid]=true;
	if(!vs[pos])++t,vs[pos]=true,as[t]=B[pv[t]=pos].ans;
	++top;vals[top]=B[valp[top]=pos].siz[vald[top]=bid];
}
inline void Modify(const int&l,const int&r){
	register int i,p;
	for(i=l;i<=r;++i){
		p=pos[a[i]];Update(B[p].Find(id[a[i]]),p);Update(B[p].Find(id[a[i]]-1),p);
	}
	for(i=l;i<=r;++i)B[pos[a[i]]].Add(id[a[i]]);
}
inline void clear(const int&L,const int&R){
	for(register int i=L;i<=R;++i)B[pos[a[i]]].v[id[a[i]]]=false;
}
inline void Add(const int&val){
	B[pos[val]].Add(id[val]);
}
inline long long Q(const int&l,const int&r){
	const int&q=pos[l],&p=pos[r];
	register int i;data ans=(data){0,0,0,0};
	if(q==p){
		for(i=l;i<=r;++i)ans.AddR(B[q].v[id[i]]);
	}
	else{
		for(i=q+1;i<p;++i)ans=ans*B[i].Q();
		for(i=R[q];i>=l;--i)ans.AddL(B[q].v[id[i]]);
		for(i=L[p];i<=r;++i)ans.AddR(B[p].v[id[i]]);
	}
	return ans.ans;
}
inline void init(){
	register int i,x;
	scanf("%d%d",&n,&m);len=(n+p-1)/p;
	for(i=1;i<=n;++i){
		scanf("%d",&x);a[x]=i;
		pos[i]=(i-1)/p+1;id[i]=(i-1)%p+1;
	}
	for(i=1;i<=len;++i){
		L[i]=R[i-1]+1;R[i]=p*i;
		if(i==len)R[i]=n;B[i].len=R[i]-L[i]+1;
	}
	for(i=1;i<=m;++i){
		scanf("%d%d%d%d",&q[i].L,&q[i].R,&q[i].x,&q[i].y);
		q[i].p=pos[q[i].x];q[i].id=i;
	}
}
inline void Mo_queue(){
	register int i,j,b,d,id;
	std::sort(q+1,q+m+1);
	for(i=1;i<=m;++i){
		const int&QL=q[i].x,&QR=q[i].y;
		if(i==1||q[i].p!=q[i-1].p){
			for(j=1;j<=len;++j)B[j].init();id=q[i].p*p;
		}
		if(pos[QL]==pos[QR])Modify(QL,QR);
		else{
			while(id<QR)Add(a[++id]);
			Modify(QL,q[i].p*p);
		}
		ans[q[i].id]=Q(q[i].L,q[i].R);
		do{
			b=valp[top];d=vald[top];
			B[b].f[d]=d;B[b].siz[d]=vals[top];vis[b][d]=false;
		}while(--top);
		do B[pv[t]].ans=as[t],vs[pv[t]]=false;while(--t);
		if(pos[QL]==pos[QR])clear(QL,QR);else clear(QL,q[i].p*p);
	}
}
signed main(){
	init();Mo_queue();
	for(register int i=1;i<=m;++i)printf("%lld\n",ans[i]);
}
```

---

## 作者：Owen_codeisking (赞：4)

不会莫队+链表，写了个莫队+并查集，过了。

乍看好像两层限制，直接莫队是 $\mathcal{O}(n^{5/3}\log n)$。如果莫队+线段树 $\mathcal{O}(n\sqrt{n}\log n)$ 常数太大不能过，那么就开发另一种常数小的 $\mathcal{O}(n\sqrt{n}\log n)$。

先对值域分块，对于每块跑回滚莫队，使得并查集能够撤销上次操作。接下来考虑 $[l,r]$ 的限制。若区间整个被覆盖，直接返回所有数对。否则，我们先把包含 $l$ 和 $r$ 的区间求出来，设 $l_1\le l\le r_1,l_2\le r\le r_2$，特判掉两个区间后加上 $(r_1,l_2)$ 的答案就可以了。

一个区间的答案是 $\Large \frac {L(L+1)}{2}$。我们在并查集上维护左端点和右端点 $[l,r]$。求一段区间包含区间的答案相当于每次我们在一段区间的根上加一下，然后区间求和。因为我们已经特判掉了两个相交的区间，所以这样不用管一段区间的根在哪里。

这样用序列分块来维护单点加区间查，时间 $\mathcal{O}(n\sqrt{n}\log n)$。实际常数很小，最大的点也只有 $\text{5.76s}$，常数大概是链表的 $2\sim 3$ 倍。

---

## 作者：xubaichuan (赞：3)

## 题解：P5386 [Cnoi2019] 数字游戏

第一道亲手打完的黑题，尽管题目比较水还看了题解，但也非常值得纪念一下OvO

进入正文，题目要求求出 $[l,r]$ 内满足所有元素都在 $[x,y]$ 范围内的子数组数量。由于维护二维查询实在是太难了，于是我们想到对其中一维做莫队，将其转化为暴力并用其他数据结构维护另一维。那莫队哪一维呢？~~题解区巨佬都是莫队 $[x,y]$ 的，那包是要跟着巨佬来啊~~。

想到维护01数组 $valid$，$valid_i$ 表示 $\pi_i$ 是否在 $[x,y]$ 内，这样问题便转化为求 $[l,r]$ 内 $valid$ 全是 $1$ 的子数组数量。很容易想到线段树，但这样修改的时间复杂度就是 $O(\log n)$，算法整体复杂度为 $O(n \sqrt n \log n)$，很难通过此题。我们需要的是一个支持 $O(1)$ 修改、$O(\sqrt n)$ 及更低的查询的数据结构——分块！

对序列分块，并维护每个块的 $pre$、$suf$、$ans$、$full$ 表示每个块的最长 $1$ 前缀、最长 $1$ 后缀、块内答案以及整块是否均为 $1$，考虑合并两个块，$pre$、$suf$、$full$ 很好维护，$ans$ 也只需要加上 $l.suf \cdot r.pre$ 即可（一个全是 $1$ 的**极长子序列**的贡献为 $\frac {(len+1)\cdot len} 2$，而 $\frac {(l.suf+r.pre+1)(l.suf+r.pre)} 2 = \frac {(l.suf+1) \cdot l.suf)} 2 + \frac {(r.pre+1) \cdot r.pre} 2 + l.suf \cdot r.pre$）。考虑插入，我们可以记录数组 $pt$，当 $i$ 是某个全是 $1$ 的**不跨块**（即不横跨多个块）**极长子序列**开头时，$pt_i$ 指向这个子序列的结尾；当 $i$ 是某个**不跨块极长子序**列的结尾时，$pt_i$ 指向这个子序列的开头；否则 $pt_i=0$。插入元素时，我们可以通过更新 $pt$ 来 $O(1)$ 地动态维护每个块的信息，具体操作见代码注释。

再考虑删除，但我们发现删除并不好维护，于是想到了回滚莫队，即只插入不删除莫队！可以发现，这道题其实很好回滚，只需要在部分插入对值进行修改时备份到一个栈中，等插入结束后遍历栈并还原即可。

下面是AC代码，虽然有点绕且有点长，但还是建议自己写，既是对码力的锻炼又很有成就感。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int MAX_N = 2e5 + 50;

int n, m, a[MAX_N], pt[MAX_N], cnt;
int pos[MAX_N], L[MAX_N], R[MAX_N];
int loc[MAX_N], valid[MAX_N];											// loc[i]表示i的出现位置，方便移动x指针和y指针

struct Block {
	int pre, suf, ans, full;											// 统一备份栈里的变量类型，这样就只需要一个栈了
	Block() : Block(0, 0, 0, 0) { }
	Block(int pre, int suf, int ans, int full) 
		: pre(pre), suf(suf), ans(ans), full(full) { }
	Block(int lt, int rt) {												// 初始化块[lt,rt]
		pre = suf = ans = 0, full = 1;
		for (int i = lt; i <= rt && valid[i]; i++, pre++);
		for (int i = rt; i >= lt && valid[i]; i--, suf++);
		int last = lt - 1;
		for (int i = lt; i <= rt; i++)
			if (!valid[i]) {
				ans += (i - last) * (i - last - 1) / 2;
				full = 0, last = i;
			}
		ans += (rt - last + 1) * (rt - last) / 2; 
	}
} block[MAX_N];

Block merge(Block l, Block r) {
	int pre = l.pre + l.full * r.pre;
	int suf = r.suf + r.full * l.suf;
	int ans = l.ans + r.ans + l.suf * r.pre;
	return Block(pre, suf, ans, l.full && r.full);
}

void init() {															// 分块初始化
	const int size = sqrt(n);
	cnt = sqrt(n);
	for (int i = 1; i <= cnt; i++) {
		L[i] = (i - 1) * size + 1;
		R[i] = i * size;
	}
	if (R[cnt] < n) {
		L[cnt + 1] = R[cnt] + 1;
		R[++cnt] = n;
	}
	for (int i = 1; i <= cnt; i++) {
		fill(pos + L[i], pos + R[i] + 1, i);
		block[i] = Block();
	}
}

stack<pair<int&, int> > backup;											// 备份

inline void mdf(int& var, int val, bool record) {						// 修改，如果record为true的话进行备份操作
	if (record)
		backup.push(pair<int&, int>(var, var));
	var = val;
}

#define score(i) (abs(i - pt[i]) + 2) * (abs(i - pt[i]) + 1) / 2		// 计算以i开头或结尾的极长子序列的贡献

void insert(int i, bool f) {											// f为true表示之后会回滚，需要备份
	mdf(valid[i], 1, f);
	int j = pos[i];
	bool left = i == L[j] || pt[i - 1] == 0;							// 判断i是否是极长子序列的最左端
	bool right = i == R[j] || pt[i + 1] == 0;							// 判断i是否是极长子序列的最右端
	if (left && right) {
		mdf(pt[i], i, f);												// 当i既是开头又是结尾时pt[i]=i
		mdf(block[j].ans, block[j].ans + score(i), f);
	} else if (left) {
		mdf(pt[i], pt[i + 1], f);
		mdf(block[j].ans, block[j].ans + score(i) - score(i + 1), f);	// 更新块内答案
		int tmp = pt[i + 1];
		mdf(pt[i + 1], 0, f), mdf(pt[tmp], i, f);						// 先改pt[i+1]再改tmp，防止pt[i+1]=i+1时出现将pt[i+1]设为0
	} else if (right) {
		mdf(pt[i], pt[i - 1], f);
		mdf(block[j].ans, block[j].ans + score(i) - score(i - 1), f);
		int tmp = pt[i - 1];
		mdf(pt[i - 1], 0, f), mdf(pt[tmp], i, f);
	} else {
		mdf(block[j].ans, block[j].ans - score(i - 1), f);
		mdf(block[j].ans, block[j].ans - score(i + 1), f);
		int tmp1 = pt[i - 1], tmp2 = pt[i + 1];
		mdf(pt[i - 1], 0, f), mdf(pt[tmp1], tmp2, f);
		mdf(pt[i + 1], 0, f), mdf(pt[tmp2], tmp1, f);
		mdf(block[j].ans, block[j].ans + score(tmp1), f);
	}
	if (pt[L[j]])														// 更新块内最长前缀
		mdf(block[j].pre, pt[L[j]] - L[j] + 1, f);
	if (pt[R[j]])														// 更新块内最长后缀
		mdf(block[j].suf, R[j] - pt[R[j]] + 1, f);
	mdf(block[j].full, pt[L[j]] == R[j], f);							// 更新full
}

int calculate(int lt, int rt) {											// 计算[lt,rt]的答案
	int lp = pos[lt], rp = pos[rt];
	if (lp == rp)
		return Block(lt, rt).ans;
	Block res = Block(lt, R[lp]);
	for (int i = lp + 1; i < rp; i++)
		res = merge(res, block[i]);
	return merge(res, Block(L[rp], rt)).ans;
}

void revoke() {															// 回滚，还原备份信息
	while (!backup.empty()) {
		backup.top().first = backup.top().second;
		backup.pop();
	}
}

struct Query {
	int x, y, l, r, id;
	bool operator < (const Query& q) const {
		if (pos[x] != pos[q.x])
			return pos[x] < pos[q.x];
		return y < q.y;
	}
} q[MAX_N];
int ans[MAX_N];

void rollback_mo() {
	sort(q + 1, q + m + 1);
	int x = 1, y = 0, xpos = 0;
	for (int i = 1; i <= m; i++) {
		int qx = q[i].x, qy = q[i].y;
		if (pos[qx] != xpos) {
			xpos = pos[qx];
			x = R[xpos], y = R[xpos] - 1;
			memset(pt, 0, sizeof(pt));
			memset(valid, 0, sizeof(valid));
			for (int j = 1; j <= cnt; j++)
				block[j] = Block();
		}
		if (pos[qx] == pos[qy]) {
			for (int j = qx; j <= qy; j++)
				insert(loc[j], true);
			ans[q[i].id] = calculate(q[i].l, q[i].r);
			revoke();
			continue;
		}
		while (y < qy)
			insert(loc[++y], false);
		int p = x;
		while (p > qx)
			insert(loc[--p], true);
		ans[q[i].id] = calculate(q[i].l, q[i].r);
		revoke();
	}
}

signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i], loc[a[i]] = i;
	for (int i = 1; i <= m; i++) {
		cin >> q[i].l >> q[i].r >> q[i].x >> q[i].y;
		q[i].id = i;
	}
	init(), rollback_mo();
	for (int i = 1; i <= m; i++)
		cout << ans[i] << '\n';
	return 0;
}
```

---

## 作者：流水行船CCD (赞：3)

这题数据还是比较弱，小常数选手可以轻松拿高分。听说我们机房有一位大佬用纯暴力过了，常数恐怖如斯。

**本题解并非理论 $O(N \sqrt{Q})$ 最优解，想看正解请移步其他题解。**

# 前置芝士

- 回滚莫队

- 回滚并查集

- 值域分块

对前两项不会的同学可以移步 BZOJ4358。

# simple 做法

即是求下标在 $[l,r]$ 范围内的满足 $x \le A_i \le y$ 的连续段，设其有 $K$ 个，长度为 $len_{1 \dots K}$。则答案即为：
$$Ans=\sum_{i=1}^{K} \frac{len_i \times (len_i + 1)}{2}$$

$O(NQ)$ 的去模拟，找到求出符合条件的 $len$ 即可。

# 更优解

修改查询操作不平衡，考虑使用值域分块平衡复杂度，发现题目是四维限制，考虑降维的去操作，这里就有两个思路。

- 用 $[l,r]$ 双指针莫队。

可以看到，如果用下标双指针，我们就需要像 simple 做法一样去维护 $x \le A_i \le y$ 的连续段但 $[x,y]$ 每次查询的时候都不一样，无法快速求解答案。即使是万能的按照下标分块，也无法处理出整块内满足答案的个数。想要做出解法很麻烦。

- 用 $[x,y]$ 双指针莫队。

由于题目给出的是排列，可以用值域来莫队求解，所以值域每动一格，只会有唯一对应的一个下标元素状态发生改变，这也就保证了此算法的时间复杂度。考虑把当前处在 $[x,y]$ 中的元素标记为 $1$，否则为 $0$，对应下文代码中的 `buck` 数组，那么也就变成了求解 $[l,r]$ 中所有 $1$ 的连续段。

举个例子，给出序列，查询绿色部分的答案。

$$01\green{0\bold{1111}00\bold {1}}10100111$$

$$Ans= \frac{4 \times (4+1)}{2} + \frac{1 \times (1+1)}{2} = 11$$

发现 $1$ 的连续块可以用并查集维护！这样，在按照下标序列分块后，就可以在块中维护并查集，快速更新整块答案表，即代码中 `sum` 数组。最后发现并查集很难删除并统计答案，考虑使用回滚莫队套回滚并查集，可以用回滚操作代替删除操作，这样就只用维护加操作了。

最后考虑合并信息，由于我们预处理出了每个块的并查集和块内答案，只需要考虑块与块之间的答案就可以了。散块直接如前文一样暴力，整块之间和散块之间对答案有影响只会有如下几种情况：

```
...|000111|111000|...
...|010111|111111|110010|...
```

也就是一个块的末尾拼上另一个快的前缀会有影响，特判一下以上两种情况就可以了，我这里用了一个变量 `cr` 来存储前一个块的后缀长度，计算时直接加入当前块的前缀长度 `cl` 变量，可以减少一定码量。

**注意不要忘了只增的回滚莫队 $[x,y]$ 在同一个块中时候需要特判，使用枚举求解，就是代码中的 `d[++q2]` 数组，否则会挂掉。**

这样就得到了一个 $O(N \sqrt{Q} \log_2 N)$ 的算法，实际上根本跑不满，甚至被我卡进了第一页。

回滚的题细节会很多，具体可以参考代码实现。

# AC Code

```cpp
//无防抄袭片段，本地对拍过极限数据，请放心食用
#include<bits/stdc++.h>
#define REP(i, l, r) for (int i=l;i<=r;++i)
#define rep(i, l, r) for (int i=l;i<r;++i)
#define PER(i, l, r) for (int i=l;i>=r;--i)
#define per(i, l, r) for (int i=l;i>r;--i)
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

//已省略快读快写

namespace clion {
    const int N = 2e5 + 7;
    int n, q, q1, q2, B, W;
    int arr[N], set[N];
    int belong[N], L[N], R[N];
    int l = 0, r = 0, buck[N];
    ll Ans[N], sum[N], st[N];
    struct Query {
        int l, r, x, y, id;//询问，值域莫队，[l,r] 分块。
    } c[N], d[N];
    struct Ver_sb {
        int x;
        ll sum;
    } stc_buck[N];
    int top_sb = 0;
    struct Ver {//并查集历史版本
        int x, y, td, fa, sz;
        ll sum;
    } stc[N];
    int top = 0;//计数数组历史版本

    bool cmp(Query a, Query b) {
        return belong[a.x] ^ belong[b.x] ? a.x < b.x : a.y < b.y;
    }
    /*
     回滚莫队+回滚并查集。
     考虑值域下标颠倒过来做。
     值域（也就是下标了）分块后查询即可。
     */
    int fa[N], sz[N];

    static inline int gf(int x) {
        while (fa[x] != x)x = fa[x];
        return x;
    }

    bool flag = 0;

    static inline void onion(const int &x, const int &y, const int &op) {
        if (belong[x] ^ belong[y])return;//不同值域块不能onion
        int fx = gf(x), fy = gf(y), t = belong[fy];
        if (fx == fy)return;
        if (sz[fx] > sz[fy])swap(fx, fy);//启发式合并
        if (op) {//压栈
            stc[++top] = (Ver) {fx, fy, t, fa[fx], sz[fy], sum[t]};
        }//x 合并入 y
        fa[fx] = fy;
        sum[t] += 1ll * sz[fx] * sz[fy];
        sz[fy] += sz[fx];
    }

    static inline void devlop(const int &x, const int &op) {
        ++buck[set[x]];
        if (op)stc_buck[++top_sb] = (Ver_sb) {set[x], sum[belong[set[x]]]};
        sum[belong[set[x]]] = std::max(sum[belong[set[x]]], 1ll);
        if (buck[set[x] - 1])onion(set[x], set[x] - 1, op);
        if (buck[set[x] + 1])onion(set[x], set[x] + 1, op);
    }

    static inline void back() {//回滚
        while (top_sb) {
            --buck[stc_buck[top_sb].x];
            sum[belong[stc_buck[top_sb].x]] = stc_buck[top_sb].sum;
            --top_sb;
        }
        while (top) {
            fa[stc[top].x] = stc[top].fa;
            sz[stc[top].y] = stc[top].sz;
            sum[stc[top].td] = stc[top].sum;
            --top;
        }
    }

    static inline ll Ask(const int &x, const int &y, const int &l, const int &r) {
        int S = belong[l], T = belong[r], cl = 0, cr = 0;
        ll res = 0;
        if (S == T) {//同块情况
            REP(i, l, r) {
                if (x <= arr[i] && arr[i] <= y)++cr;
                else res += st[cr], cr = 0;
            }
            res += st[cr];
            return res;
        }
        REP(i, l, R[S]) {//左块
            if (x <= arr[i] && arr[i] <= y)++cr;
            else res += st[cr], cr = 0;
        }
        int fl = 0, fr = 0;
        REP(i, S + 1, T - 1) {
            fl = gf(L[i]), fr = gf(R[i]);
            if (buck[L[i]] && buck[R[i]] && fl == fr) {
                cr += sz[fl];
                continue;
            }
            cl = (buck[L[i]] ? sz[fl] : 0) + cr;
            cr = (buck[R[i]] ? sz[fr] : 0);
            res += sum[i] - st[cl] - st[cr];
        }
        REP(i, L[T], r) {//右块
            if (x <= arr[i] && arr[i] <= y)++cr;
            else res += st[cr], cr = 0;
        }
        res += st[cr];
        return res;
    }

    int tbu[N], tfa[N], tsz[N], tsum[N];

    signed main() {
        io >> n >> q;
        REP(i, 1, n) {
            io >> arr[i];
            set[arr[i]] = i;
            st[i] = ((1ll * i * (i + 1)) >> 1ll);
        }
        B = std::max(1, (int) (n / sqrt(q)));
        W = n / B + (n % B > 0);
        REP(i, 1, W) {
            L[i] = (i - 1) * B + 1, R[i] = i == W ? n : i * B;
            REP(j, L[i], R[i]) belong[j] = i;
        }
        int il, ir, ix, iy;
        REP(i, 1, q) {
            io >> il >> ir >> ix >> iy;
            if (belong[c[i].x] ^ belong[c[i].y])c[++q1] = (Query) {il, ir, ix, iy, i};
            else d[++q2] = (Query) {il, ir, ix, iy, i};

        }
        REP(i, 1, n)fa[i] = i, sz[i] = 1;
        REP(i, 1, q2) {
            REP(j, d[i].x, d[i].y)devlop(j, 1);
            Ans[d[i].id] = Ask(d[i].x, d[i].y, d[i].l, d[i].r);
            back();
        }
        sort(c + 1, c + q1 + 1, cmp);
        REP(i, 1, q1) {
            if (belong[l] ^ belong[c[i].x]) {//清空数组
                memset(buck, 0, sizeof(buck)), memset(sum, 0, sizeof(sum));
                REP(j, 1, n)fa[j] = i, sz[j] = 1;
                l = r = R[belong[c[i].x]];
                buck[l] = 1;
            }
            while (r < c[i].y)devlop(++r, 0);//扩展 r 不回滚栈
            while (c[i].x < l)devlop(--l, 1);//扩展 l 记录回滚信息
            Ans[c[i].id] = Ask(c[i].x, c[i].y, c[i].l, c[i].r);//更新答案
            back(), l = R[belong[l]];//回滚
        }
        REP(i, 1, q)io << Ans[i] << '\n';
        return 0;
    }
}

signed main() {
    clion::main();
    return 0;
}
```

---

## 作者：nksunhaolan (赞：2)

**感谢**@ljy05提供 $n\sqrt{n}\log_2(n)$ 思路并参与讨论（人太菜不能一个人切黑）。

# 正文
## step1
对于每一个询问 $l,r,x,y$ 我们可以把 $(l,r)$ 这一段区间内符合 $x \le \pi_i \le y$ 的看做 1，反之为0。

那么就有 $n\times q$ 做法，统计区间内每一段连续 1 长度为 $len$，$ans=ans+{{len\times(len+1)}\over{2}}$，扫过去求解即可（貌似常数小可以卡过子任务一？）。

时间 $O(nq)$。

## step2
也就是 @ljy05 提出的思路。

一看区间查询、不修改、不强制在线，简单莫队启动！因为是双区间，我们要考虑莫队哪一个区间，但是我们发现如果莫队数组区间，无论是修改还是查询都不好搞的样子，于是考虑莫队值域区间。

当你开始莫队值域区间时，你就会发现豁然开朗。

因为 $\pi$ 是排列，所以在莫队移动区间时，映射修改原数组就很方便。具体修改就这样：我们把值为 $i$ 的数在 $\pi$ 中的位置记为 $A_i$。在移动区间时，如果加入 $i$ 就把标记数组 $vis$ 的 $vis_{A_i}$ 设为 $true$ ，退出 $i$ 时就把 $vis_{A_i}$ 设为 $false$。

那现在问题转化为，如何快速单点修改，区间查询。

很容易想到线段树，于是就有了一个 $O(q\sqrt {n}\log_2(n))$ 的做法，具体维护的话就是每个树节点维护 $llen,rlen,ans$ 即左边、右边连续 1 长度与该区间的答案，在更新与查询时注意边界与整块都是 1 的情况即可。

时间 $O(q\sqrt{n}\log_2(n))$。

## step3
学过莫队的都知道 $O(q\sqrt{n}\log_2(n))$ 有可能被卡甚至不是正确复杂度，所以我们要优化。而莫队的优化方式大多是通过牺牲询问时间来把修改时间降低（多半是降至 $O(1)$）。

因为莫队的修改次数为 $O(q\sqrt{n})$ 而询问次数为 $q$。而分块通常就是一个很好的选择。

如何维护呢？我这里提出一种只加入不删除的做法（我太懒了，直接把回滚套上去就不想想删除了）。对于每一个下标维护 $L,R,vis$，对每一个块维护 $llen,rlen,ans$。$L,R$ 指每一个位置在块中所在 1 区间的左边界、右边界，$vis$ 指该位置是否是 1。$llen,rlen,ans$ 与上文线段树中提到的差不多。

修改时看是否会与其他区间合并，如果可以就更新新区间的 $L,R$ 以及所在块的 $ans$，如果新区间接触块的左区间或右区间，就更新块内的 $llen,rlen$。

统计答案时散块整块查就是了，注意块与块间 $llen,rlen$ 衔接与整块都是 1 的情况即可。

时间 $O(q\sqrt{n})$。

### 代码

```cpp
#include<bits/stdc++.h>
#define pl pair<int,int>
#define ll long long
using namespace std;

const int N=2e5+5,M=450;
//k,L,R,vis
int n,m,s,t,k,A[N],id[N];
int L[N],R[N];
ll ans[N];
bool vis[N];
struct nnd {
	int l,lk,r,x,y,idx;
}q[N];
//ls,rs,ans
struct node {
	int l,ls,r,rs,len;
	ll ans;
}D[M];
struct mmb {
	int x,it,lb,rb,L,R,ls,rs;
	ll ans;
}c[N<<1];
inline bool pai(const nnd& x,const nnd& y){
	return (x.lk^y.lk)?(x.lk<y.lk):(x.r<y.r);
}
inline void change(const int& x,const bool& dis){
	vis[x]=1;
	const int it=id[x],l=D[it].l,r=D[it].r;
	const int lb=((x^l)&&vis[x-1])?(L[x-1]):(x);
	const int rb=((x^r)&&vis[x+1])?(R[x+1]):(x);
	if(dis)c[++k]={x,it,lb,rb,L[rb],R[lb],D[it].ls,D[it].rs,D[it].ans};
	D[it].ans-=(ll)(x-lb)*(x-lb+1)/2+(ll)(rb-x)*(rb-x+1)/2;
	R[lb]=rb,L[rb]=lb;
	D[it].ans+=(rb-lb+1)*(rb-lb+2)/2;
	if(lb==l)D[it].ls=rb-lb+1;
	if(rb==r)D[it].rs=rb-lb+1;
}
void cle(){
	k=0;
	for(int i=1;i<=t;i++)
		D[i].ans=D[i].ls=D[i].rs=0;
	for(int i=1;i<=n;i++)
		L[i]=R[i]=vis[i]=0;
}
void ret(){
	for(;k;k--){
		const mmb p=c[k];
		vis[p.x]=0;
		L[p.rb]=p.L;
		R[p.lb]=p.R;
		D[p.it].ls=p.ls;
		D[p.it].rs=p.rs;
		D[p.it].ans=p.ans;
	}
}
inline ll get_ans(const int& l,const int& r){
	const int st=id[l],ed=id[r];
	ll ans=0,sum=0;
	if(st==ed){
		for(int j=l;j<=r;j++){
			if(vis[j]){
				sum++;
				if(j==r||!vis[j+1])ans+=sum*(sum+1)/2,sum=0;
			}
		}
	} else {
		for(int j=l;j<=D[st].r;j++){
			if(vis[j]){
				sum++;
				if(!vis[j+1])ans+=sum*(sum+1)/2,sum=0;
			}
		}
		for(int j=st+1;j<ed;j++){
			const ll l=D[j].ls,r=D[j].rs;
			if(D[j].len==l)
				sum+=l;
			else {
				sum+=l;
				ans+=sum*(sum+1)/2;
				sum=r;
				ans+=D[j].ans-l*(l+1)/2-r*(r+1)/2;
			}
		}
		if(!vis[D[ed].l]){
			ans+=sum*(sum+1)/2;
			sum=0;
		}
		for(int j=D[ed].l;j<=r;j++){
			if(vis[j]){
				sum++;
				if(j==r||!vis[j+1])ans+=sum*(sum+1)/2,sum=0;
			}
		}
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	s=sqrt(n),t=(n-1)/s+1;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		A[x]=i,id[i]=(i-1)/s+1;
	}
	for(int i=1,l,r;i<=t;i++){
		l=(i-1)*s+1,r=min(i*s,n);
		D[i]=(node){l,0,r,0,r-l+1,0};
	}
	for(int i=1,l,r,x,y;i<=m;i++){
		cin>>x>>y>>l>>r;
		q[i]=(nnd){l,id[l],r,x,y,i};
	}
	sort(q+1,q+m+1,pai);	
	for(int i=1,r,R;i<=m;i++){
		r=q[i].lk*s;
		if(q[i].lk^q[i-1].lk)cle(),R=r;
		for(;R<q[i].r;)change(A[++R],0);
		for(int j=min(q[i].r,r);j>=q[i].l;)
			change(A[j--],1);
		ans[q[i].idx]=get_ans(q[i].x,q[i].y);
		ret();
	}
	for(int i=1;i<=m;i++)
		cout<<ans[i]<<"\n";
	return 0;
}
```
~~码风超抽估计也没入看得懂。~~

---

## 作者：Union_Find (赞：2)

这道题还好是一下午调完了。

**建议不要抄题解，这道题自己写才有感觉**。

**本份题解的时间复杂度是 $O(n\sqrt n)$，且以下的时间复杂度不区分 $n$ 和 $q$**。

首先因为这道题要求 $x \le a_i \le y$，但是如果从 $l,r$ 入手不好做，所以考虑对 $x,y$ 进行莫队。

我们开一个 $t_i$ 数组表示 $i$ 位置的数字是否在 $[x,y]$ 内。

很快的我们就有一个 $O(n\sqrt n \log n)$ 做法，对于每次移动，我们用线段树维护区间前缀极长 $1$ 的长度，后缀 $1$ 的长度，和区间的答案，即对于每个极长 $1$ 段的长度 $len$，$\frac{len(len + 1)}{2}$ 的和。

但是这样子时间复杂度太劣了，瓶颈在于线段树的单点修改是 $O(\log n)$ 的，我们希望有一个数据结构，可以 $O(1)$ 单点修改，$O(\sqrt n)$ 以内区间查询，所以考虑分块。

对于每个极长 $1$ 的段，我们维护他的最左端和最右端，要满足这个段不越过两个块。

这样子的话我们的可以方便的 $1$ 变成 $0$，但是不好 $0$ 变成 $1$，所以可以用回滚莫队。

以上就是这道题的做法，但是具体写的话还是比较麻烦的，有一些细节注意。

首先，记得回滚莫队和分块要特判在同一个块内。

其次，莫队和分块的编号不要弄混。

最后，注意清空。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 2000005
#define c1(p, c) (col[p - 1] == c && t[p - 1])
#define c2(p, c) (col[p + 1] == c && t[p + 1])
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n, m, sqn, a[N], col[N], nl[N], nr[N], ans[N], st[N], ed[N], t[N], ex, num[N], stac[N], tp;
struct Q{
	ll l, r, x, y, id;
}q[N];
il bool cmp(Q a, Q b){return col[a.x] != col[b.x] ? a.x < b.x : a.y < b.y;}
struct P{
	ll tag, nl, nr;
	bool ful;
	P(){tag = nl = nr = ful = 0;}
}tag[N];
P operator + (const P &a, const P &b){
	P ans;
	ans.nl = a.ful ? a.nl + b.nl : a.nl;
	ans.nr = b.ful ? b.nr + a.nr : b.nr;
	ans.tag = a.tag + b.tag + a.nr * b.nl;
	ans.ful = (a.ful & b.ful);
	return ans;
}
il ll len(ll c){return ed[c] - st[c] + 1;}
il void add(ll x){// 单点修改 
	ll p = a[x], c = col[p];
	t[p] = 1;
	if (c1(p, c) && c2(p, c)){//左右都有 1 
		if (st[num[p - 1]] == nl[c]) tag[c].nl += len(num[p + 1]) + 1;
		if (ed[num[p + 1]] == nr[c]) tag[c].nr += len(num[p - 1]) + 1;
		tag[c].tag += (len(num[p - 1]) + 1) * (len(num[p + 1]) + 1);
		ed[num[p - 1]] = ed[num[p + 1]], st[num[p + 1]] = st[num[p - 1]], stac[++tp] = num[p + 1], num[ed[num[p - 1]]] = num[p - 1];
//		栈内存右块的编号 
	}else if (c1(p, c)){// 左有 1 
		if (st[num[p - 1]] == nl[c]) tag[c].nl++;
		tag[c].tag += len(num[p - 1]) + 1;
		ed[num[p - 1]] = p, num[p] = num[p - 1], stac[++tp] = -1;
		if (p == nr[c]) tag[c].nr = len(num[p]);
	}else if (c2(p, c)){// 右有 1 
		if (ed[num[p + 1]] == nr[c]) tag[c].nr++;
		tag[c].tag += len(num[p + 1]) + 1;
		st[num[p + 1]] = p, num[p] = num[p + 1], stac[++tp] = -2;
		if (p == nl[c]) tag[c].nl = len(num[p]);
	}else{// 单独一个 
		num[p] = ++ex, st[ex] = ed[ex] = p, tag[c].tag++, stac[++tp] = -3;
		if (p == nl[c]) tag[c].nl = 1;
		if (p == nr[c]) tag[c].nr = 1;
	}if (tag[c].nl == nr[c] - nl[c] + 1) tag[c].ful = 1;
}il void del(ll x){
	ll p = a[x], c = col[p];// 撤回 
	t[p] = 0, tag[c].ful = 0;
	if (stac[tp] > 0){// 同上对应 
		num[ed[num[p - 1]]] = stac[tp], ed[num[p - 1]] = p - 1, st[num[p + 1]] = p + 1;
		if (st[num[p - 1]] == nl[c]) tag[c].nl = p - nl[c];
		if (ed[num[p + 1]] == nr[c]) tag[c].nr = nr[c] - p;
		tag[c].tag -= (len(num[p - 1]) + 1) * (len(num[p + 1]) + 1);
	}else if (stac[tp] == -1){
		if (p == nr[c]) tag[c].nr = 0;
		ed[num[p - 1]] = p - 1, num[p] = 0, tag[c].tag -= len(num[p - 1]) + 1;
		if (st[num[p - 1]] == nl[c]) tag[c].nl--;
	}else if (stac[tp] == -2){
		if (p == nl[c]) tag[c].nl = 0;
		st[num[p + 1]] = p + 1, num[p] = 0, tag[c].tag -= len(num[p + 1]) + 1;
		if (ed[num[p + 1]] == nr[c]) tag[c].nr--;
	}else{
		if (p == nl[c]) tag[c].nl = 0;
		if (p == nr[c]) tag[c].nr = 0;
		num[p] = 0, st[ex] = ed[ex] = 0, tag[c].tag--, ex--;
	}tp--;
}il P ask(ll l, ll r){
	if (col[l] == col[r]){
		ll ans = 0, len = 0;
		for (int i = l; i <= r; i++){
			if (t[i]) len++;
			else if (len){
				ans += len * (len + 1) / 2, len = 0;
			}
		}if (len) ans += len * (len + 1) / 2, len = 0;
		P res;
		res.tag = ans;
		return res;
	}
//	for (int i = 1; i <= n; i++) cout << t[i] << " ";puts("");
	P ans;
	if (col[l] + 1 < col[r]) ans = tag[col[l] + 1];
	for (int i = col[l] + 2; i < col[r]; i++) ans = ans + tag[i];// cout << tag[i].tag << " " << tag[i].nl << " " << tag[i].nr << "\n";
//	cout << ans.tag << " " << ans.nl << " " << ans.nr << "\n";
	P xl, xr;
	ll len = 0;
	for (int i = nr[col[l]]; i >= l; i--){
		if (t[i]) len++;
		else if (len){
//			cout << len << " " << i << "\n";
			if (!xl.nr && len == nr[col[l]] - i) xl.nr = len;
			xl.tag += len * (len + 1) / 2, len = 0;
		}
	}if (len){
		if (!xl.nr && len == nr[col[l]] - l + 1) xl.nr = len;
		xl.tag += len * (len + 1) / 2, len = 0;
	}if (xl.nr == nr[col[l]] - l + 1) xl.ful = 1;
	if (col[l] + 1 < col[r]) ans = xl + ans;
	else ans = xl;
	for (int i = nl[col[r]]; i <= r; i++){
		if (t[i]) len++;
		else if (len){
			if (!xr.nl && len == i - nl[col[r]]) xr.nl = len;
			xr.tag += len * (len + 1) / 2, len = 0;
		}
	}if (len){
		if (!xr.nl && len == r - nl[col[r]] + 1) xr.nl = len;
		xr.tag += len * (len + 1) / 2, len = 0;
	}if (xr.nl == r - nl[col[r]] + 1) xr.ful = 1;
	ans = ans + xr;
//	cout << xl.tag << " " << xr.tag << " " << xl.nr << " " << xr.nl << "\n";
	return ans;
}
int main(){
//	freopen ("P5386.in", "r", stdin);
//	freopen ("P5386.out", "w", stdout);
	n = rd(), m = rd(), sqn = sqrt(n);
	for (int i = 1; i <= n; i++) a[rd()] = i, col[i] = (i - 1) / sqn + 1;
	for (int i = 1; i <= col[n]; i++) nl[i] = nr[i - 1] + 1, nr[i] = min(n, i * sqn);
	for (int i = 1; i <= m; i++) q[i] = Q{rd(), rd(), rd(), rd(), i};
	sort (q + 1, q + m + 1, cmp);
//	puts("-----");
//	for (int i = 1; i <= m; i++) printf ("%lld %lld %lld %lld\n", q[i].l, q[i].r, q[i].x, q[i].y);
	for (int i = 1; i <= m; i++){
		if (col[q[i - 1].x] == col[q[i].x]) continue;
		for (int j = 1; j <= ex; j++) st[j] = ed[j] = 0;
		for (int j = 1; j <= tp; j++) stac[j] = 0;
		for (int j = 1; j <= n; j++) num[j] = 0, t[j] = 0;
		for (int j = 1; j <= col[n]; j++) tag[j].tag = tag[j].nl = tag[j].nr = tag[j].ful = 0;
		ex = tp = 0;
		for (int j = i; j <= n && col[q[j].x] == col[q[i].x]; j++) if (col[q[j].x] == col[q[j].y]){
			for (int k = q[j].x; k <= q[j].y; k++) add(k);
			ans[q[j].id] = ask(q[j].l, q[j].r).tag;
			for (int k = q[j].y; k >= q[j].x; k--) del(k);
		}
		ll l = col[q[i].x] * sqn, r = l;add(l);
		for (int j = i; j <= n && col[q[j].x] == col[q[i].x]; j++){
			if (col[q[j].x] == col[q[j].y]) continue;
			while (r < q[j].y) add(++r);
			ll l_p = l;
			while (l > q[j].x) add(--l);
//			cout << l << " " << r << "A\n";
			ans[q[j].id] = ask(q[j].l, q[j].r).tag;
			while (l < l_p) del(l++);
//			cout << tag[2].ful << "\n";
		}
	}for (int i = 1; i <= m; i++) printf ("%lld\n", ans[i]);
	return 0;
}

```

---

## 作者：_Yonder_ (赞：2)

数组清零时越界了，调了两个多小时 qwq。

看到四个限制的题，可以尝试使用莫队来解决，一下就可以少掉两个限制，我是去掉了 $x,y$ 的限制。

将 $x\le a_i\le y$ 的表示为 $1$，反之表示为 $0$，于是题目变成了求连续的 $1$ 的长度 $len$ 的 $\frac{len\times (len+1)}{2}$ 之和。

发现 $1\to0$ 不好做，于是换成回滚莫队，维护 $len$ 只要用并查集加分块即可，由于并查集要撤回，所以只能用启发式合并，时间复杂度 $O(m\sqrt n\log n)$。
# Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#ifdef ONLINE_JUDGE
static char buf[4500000],*p1=buf,*p2=buf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,4500000,stdin),p1==p2)?EOF:*p1++
#endif
inline int read(){int x=0;char c=getchar();while(!isdigit(c)) c=getchar();while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();return x;}
inline void write(ll x){static int sta[40];int top=0;do{sta[top++]=x%10,x/=10;}while(x);while(top) putchar(sta[--top]+'0');}
using namespace std;
const int N=2e5+5,M=450;
struct node{int x,y,sy;ll sum;}s[N];
struct IN{int l,r,x,y,i;}Q[N];
int n,q,a[N],Sqrt,id[N],ind[N],f[N],L[M],R[M],fa[N],sz[N],top;
ll out[N],u[N],sum[M];vector<int> v[M],_v[M],now;
inline int calc(int l,int r,int x,int y){
    for(int i=x;i<=y;i++) if(l<=ind[i]&&ind[i]<=r) v[ind[i]%M].push_back(ind[i]);
    for(int i=0;i<M;i++){for(int j:v[i]) _v[j/M].push_back(j);v[i].clear();}
    for(int i=0;i<M;i++){for(int j:_v[i]) now.push_back(j);_v[i].clear();}
    if(!now.size()) return 0;int ans=1,cnt=1;
    for(int i=1;i<now.size();i++)
        if(now[i-1]+1==now[i]) cnt++,ans+=cnt;
        else cnt=1,ans++;
    return now.clear(),ans;
}inline int find(int x){return fa[x]==x?x:find(fa[x]);}
inline void merge(int x,int y,int op){
    if(id[x]^id[y]) return;
    x=find(x),y=find(y);
    if(x==y) return;
    if(sz[x]>sz[y]) swap(x,y);
    if(op) s[++top]={x,y,sz[y],sum[id[y]]};
    fa[x]=y,sum[id[y]]+=sz[x]*1ll*sz[y],sz[y]+=sz[x];
}inline void add(int x,int op){
    f[x]=1;sum[id[x]]++;
    if(op) s[++top]={x,0};
    if(f[x-1]) merge(x,x-1,op);
    if(f[x+1]) merge(x,x+1,op);
}inline ll ask(int l,int r){
    if(id[l]==id[r]){
        int ans=0,cnt=0;
        for(int i=l;i<=r;i++) f[i]?(cnt++,ans+=cnt):cnt=0;
        return ans;
    }ll ans=0;int cnt=0,cl,cr,sl;
    for(int i=l;i<=R[id[l]];i++) f[i]?cnt++:(ans+=u[cnt],cnt=0);
    for(int i=id[l]+1;i<id[r];i++){
        cl=find(L[i]),cr=find(R[i]);
		if(f[L[i]]&&cl==cr){cnt+=R[i]-L[i]+1;continue;}
		sl=(f[L[i]]?sz[cl]:0)+cnt;cnt=f[R[i]]?sz[cr]:0;
        ans+=sum[i]+u[sl]-u[f[L[i]]?sz[cl]:0]-u[cnt];
    }for(int i=L[id[r]];i<=r;i++) f[i]?cnt++:(ans+=u[cnt],cnt=0);
	return ans+u[cnt];
}
int main(){
    n=read(),q=read(),Sqrt=sqrt(n);
    for(int i=1;i<=n;i++) ind[a[i]=read()]=i,id[i]=(i-1)/Sqrt+1,u[i]=i*1ll*(i+1)>>1;
    for(int i=1;i<=id[n];i++) L[i]=R[i-1]+1,R[i]=i*Sqrt;R[id[n]]=n;
    for(int i=1;i<=q;i++) Q[i]={read(),read(),read(),read(),i};
    sort(Q+1,Q+1+q,[](IN x,IN y){return id[x.x]==id[y.x]?x.y<y.y:x.x<y.x;});
    for(int K=1,i=1;K<=id[n];K++){
        int r=R[K],l=r+1;
        for(int j=1;j<=n;j++) fa[j]=j,sz[j]=1,f[j]=0;
		memset(sum,0,sizeof(sum));
        for(;i<=q&&id[Q[i].x]==K;i++){
            if(id[Q[i].x]==id[Q[i].y]){out[Q[i].i]=calc(Q[i].l,Q[i].r,Q[i].x,Q[i].y);continue;}
            while(r<Q[i].y) add(ind[++r],0);while(l>Q[i].x) add(ind[--l],1);
			out[Q[i].i]=ask(Q[i].l,Q[i].r);
            for(;top;top--)
				if(!s[top].y) f[s[top].x]=0,sum[id[s[top].x]]--;
				else fa[s[top].x]=s[top].x,sum[id[s[top].y]]=s[top].sum,sz[s[top].y]=s[top].sy;
			l=R[K]+1;
        }
    }for(int i=1;i<=q;i++) write(out[i]),putchar('\n');
    return 0;
}
```

---

## 作者：Eterna (赞：2)

仔细看眼题，发现是在询问区间 $[l,r]$ 内有几个所有数都在 $[x,y]$ 范围内的子区间。

联想到了第十分块，但我不会。

观察时限感觉可以带 $\log$。对于原数列，我们可以转换为一个 `01` 数列 $\{ f_n \}$。用 $f_i=1$ 代表 $x \le \pi_i \le y$。否则 $f_i=0$。

用莫队维护 $x,y$ 的移动，单次指针移动显然为 $\{ f_n \}$ 上的单点取反。用 $\{ w_k \}$ 代表 $\{ f_n \}$ 区间内所有极长 $1$ 连续段长度，询问即为 $\displaystyle \frac{\sum (w^2+w)}{2}$。

线段树维护 $\{ f_n \}$ 即可，时间复杂度 $O(n \sqrt {n} \log n)$。

结果发现跑不过，经常写莫队的人一定已经想到要平衡复杂度了。要平衡复杂度了，最常用的一定是分块了。

但是纯分块我不会写，考虑分块后每个块维护一个线段树。

记 $B$ 为每个块的长度。则复杂度为 $\displaystyle O(n\sqrt{n} \log B + \frac{n^2}{B})$。

大概 $B$ 略小于 $\sqrt {n}$ 是最快的，反正我取 $20 \le B \le 2000$ 都过了。

---

## 作者：lzyqwq (赞：2)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/p/18047996)**

**[我永远喜欢数据结构。](https://www.luogu.com.cn/article/2bwnvavf)**



**[题目传送门](https://www.luogu.com.cn/problem/P5386)**

> - 给出长度为 $n$ 的**排列** $a_1\sim a_n$，$m$ 次询问有多少对 $[l,r]$ 满足 $L\le l\le r\le R$ 且 $\forall \,i\in [L,R],a_i\in[X,Y]$。
>
> - $n,m\le 2\times 10^5$。
>
> - $\text{3 s}\sim\text{7 s / 125 MB}$。

下文中默认 $\mathcal{O}(n)=\mathcal{O}(m)$，分块以 $\mathcal{O}(\sqrt{n})$ 为块长。

考虑对 $[X,Y]$ 这个限制莫队。设当前维护的值域区间是 $[x,y]$，令 $w_i=[x\le a_i\le y]$。对于一个询问我们要求当 $x,y$ 分别扫到 $X,Y$ 时，$w$ 数组的区间 $[L,R]$ 内有多少全部为 $1$ 的子区间。

由于给出的是一个排列，$x,y$ 移动一步时只会带来 $w$ 数组一个位置的改变。相当于要支持单点 $0$ 变 $1$（或 $1$ 变 $0$），区间查询 $[L,R]$ 内有多少全部为 $1$ 的子区间（简称为答案）。

考虑线段树，一个节点维护一下几个信息：

- $\text{len}$：代表这个节点对应的区间长度。

- $\text{llen}$：代表这个节点对应的区间中，以左端点开始的最长连续 $1$ 段长度。

- $\text{rlen}$：代表这个节点对应的区间中，以右端点结束的最长连续 $1$ 段长度。

- $\text{sum}$：代表这个节点对应的区间的答案。

合并两个节点 $u,v$ 的信息时，都考虑该信息是否跨过中点。具体地，设 $\otimes$ 为合并操作：

- $\text{len}_{u\otimes v}=\text{len}_u+\text{len}_v$

- $\text{llen}_{u\otimes v}=\begin{cases}\text{len}_u+\text{llen}_v,\text{len}_u=\text{llen}_u\\\text{llen}_u,\text{otherwise}\end{cases}$

- $\text{rlen}_{u\otimes v}=\begin{cases}\text{len}_v+\text{rlen}_u,\text{len}_v=\text{rlen}_v\\\text{rlen}_v,\text{otherwise}\end{cases}$

- $\text{sum}_{u\otimes v}=\text{sum}_u+\text{sum}_v+\text{rlen}_u\cdot\text{llen}_v$

容易支持单点修改。这样做时间复杂度为 $\mathcal{O}(n\sqrt{n}\log n)$，空间复杂度为 $\mathcal{O}(n)$。不够优美。

原因是修改数量为 $\mathcal{O}(n\sqrt{n})$，而询问数量仅有 $\mathcal{O}(n)$。考虑换成 $\mathcal{O}(1)$ 修改 $\mathcal{O}(\sqrt{n})$ 查询的分块。

记：

- $\text{bl}_i,\text{br}_i$ 为第 $i$ 块的左右端点。

- $\text{bel}_i$ 为 $i$ 位置所在块。

- $A_i$ 为第 $i$ 块的信息。

- $\text{pos}_i$ 的意义如下：若 $i$ 是**这个块中**一个**极长** $1$ 连续段的端点，则 $\text{pos}_i$ 的值为它所在极长 $1$ 连续段的另一个端点；否则 $\text{pos}_i=0$。

考虑 $w_i$ 由 $0$ 变 $1$ 怎么修改。考虑修改后极长 $1$ 连续段的情况怎么变，显然它只可能接上**修改前** $i-1$ 所在极长 $1$ 连续段和 $i+1$ 所在极长 $1$ 连续段。以此来处理 $\text{pos}$ 数组的变化。注意不存在这两个位置或这两个位置与 $i$ 不在同一块中的情况，具体可以看代码，个人认为讨论了所有可能的情况，虽然有一些繁杂。

处理好修改后 $i$ 所在极长 $1$ 连续段后，新增的答案就是这个段中包含 $i$ 的子区间数量，是容易计算的。

至于 $\text{llen}$ 和 $\text{rlen}$ 的变化，容易通过修改后的 $\text{pos}$ 数组求出。

但是发现 $w_i$ 由 $1$ 变 $0$ 的情况不好处理，于是考虑回滚莫队，每次撤销最新的一次 $0$ 变 $1$ 回退上一个版本。用栈按时间顺序存储修改的量即可。

查询可以考虑从左往右遍历每个查询区间中的块（包括散块），散块暴力计算信息，整块就用维护好的 $A_i$，然后像上面那样合并。

处理询问时，对于左右端点在**莫队中分出的块**相同时，对于 $[X,Y]$ 这个值域，让指针 $j$ 从 $X$ 扫到 $Y$ 暴力更新 $[X,j]$ 的信息。然后查询、撤销。单次时间复杂度为 $\mathcal{O}(\sqrt{n})$。

剩下的询问离线跑回滚莫队。每次做一段左端点在**莫队中分出的块**相同的询问。假设这一块的右端点为 $R_0$，我们只考虑撤销 $[X,R_0]$ 的操作，保留 $(R_0,Y]$ 的操作。这样对于排序后的每一个询问 $i$，可以先从上一个询问的 $(R_0,Y_{i-1}]$ 扩展到这个询问的 $(R_0,Y_i]$，再添加 $[X,R_0]$ 的操作，再查询，再撤销这些操作回到 $(R_0,Y_i]$ 的版本，再继续做下一个询问。

做完一段左端点所在块相同的询问后，暴力清空分块。由于只会有 $\mathcal{O}(\sqrt{n})$ 种左端点所在块，即这么多次清空，所以清空的总时间复杂度是 $\mathcal{O}(n\sqrt{n})$。

修改的和查询的总复杂度都是 $\mathcal{O}(n\sqrt{n})$。因此，回滚莫队的做法时间复杂度为 $\mathcal{O}(n\sqrt{n})$，空间复杂度为 $\mathcal{O}(n)$。可以接受。

**[AC Link](https://www.luogu.com.cn/record/148573023)**

**[AC Code](https://www.luogu.com.cn/paste/1hq3slou)**

---

## 作者：Drind (赞：2)

被同学强迫写了这个题。

### 题目解析

给定排列 $a$，每次查询给定四个数 $l,r,x,y$，计算有多少个子区间值域在 $[x,y]$ 之间。

首先这个很难搞，我们就直接换到这个值域上做，那显然我们可以莫队，然后把问题转换成了求区间最长连续 1 的 $\frac{(len+1)len}{2}$，需要单点修改 $O(1)$，查询可以 $O(\sqrt n)$。

我们考虑值域分块，具体地，我们用链表维护每个连续 1 段，然后把信息存在连续 1 的开头和结尾方便合并，但是这样就没法删除了，所以我们写个回滚莫队。

记得回滚分块。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
const int M=500+10;
int n,m;
int siz;
int id[N];

int calc(int x){
	return x*(x+1)/2;
}

struct node{
	int l,r,x,y,id;
}q[N];

struct dt{//每个块儿的信息
	int llen,rlen,len;
	int sum; bool empty;
	dt() {llen=rlen=sum=0; empty=false;}
	dt(int llen,int rlen,int sum):llen(llen),rlen(rlen),sum(sum){empty=false;}
};

dt operator +(const dt &a,const dt &b){//块儿合并
	if(a.empty) return b;
	if(b.empty) return a;
	dt tmp;
	tmp.llen=a.llen;
	if(tmp.llen==a.len) tmp.llen+=b.llen;
	tmp.rlen=b.rlen;
	if(tmp.rlen==b.len) tmp.rlen+=a.rlen;
	tmp.len=a.len+b.len;
	tmp.sum=a.sum+b.sum-calc(a.rlen)-calc(b.llen)+calc(a.rlen+b.llen);
	return tmp;
}

vector<pair<int&,int>>st1;//回滚分块用的两个数组
vector<pair<dt&,dt>>st2;

struct FenKuai{
	int w[N];
	int st[M],ed[M],pos[N];
	int ptr[N];
	dt d[M];
	
	void init(int n){//初始化
		for(int i=1;i<=n;i++) pos[i]=(i-1)/siz+1;
		for(int i=1;i<=pos[n];i++){
			st[i]=(i-1)*siz+1;
			ed[i]=min(siz*i,n);
			d[i].len=siz;
		}
	}
	
	void modify(int i,bool flag){
		
		//cout<<"Modify "<<i<<"\n";
		
		if(flag){//如果需要回滚，就先记下来
			st2.emplace_back(d[pos[i]],d[pos[i]]);
			st1.emplace_back(w[i],w[i]);
		}
		if((pos[i]!=pos[i+1]||!w[i+1])&&(pos[i]!=pos[i-1]||!w[i-1])){//创建一个新的块儿
			if(flag) st1.emplace_back(ptr[i],ptr[i]);
			ptr[i]=i; d[pos[i]].sum++;
		}else if(pos[i]!=pos[i+1]||!w[i+1]){//跟后面合并
			if(flag){
				st1.emplace_back(ptr[ptr[i-1]],ptr[ptr[i-1]]);
				st1.emplace_back(ptr[i],ptr[i]);
			}
			int len=i-ptr[i-1];
			int t=ptr[i-1];
			ptr[t]=i; ptr[i]=t;
			d[pos[i]].sum+=calc(len+1)-calc(len);
		}else if(pos[i]!=pos[i-1]||!w[i-1]){//跟前面合并
			if(flag){
				st1.emplace_back(ptr[ptr[i+1]],ptr[ptr[i+1]]);
				st1.emplace_back(ptr[i],ptr[i]);
			}
			int len=ptr[i+1]-i;
			int t=ptr[i+1];
			ptr[t]=i; ptr[i]=t;
			d[pos[i]].sum+=calc(len+1)-calc(len);
		}else{//前后都要合并
			if(flag){
				st1.emplace_back(ptr[ptr[i-1]],ptr[ptr[i-1]]);
				st1.emplace_back(ptr[ptr[i+1]],ptr[ptr[i+1]]);
			}
			int llen=i-ptr[i-1];
			int rlen=ptr[i+1]-i;
			int l=ptr[i-1],r=ptr[i+1];
			ptr[l]=r; ptr[r]=l;
			d[pos[i]].sum+=calc(llen+rlen+1)-calc(llen)-calc(rlen);
		}
		
		w[i]=1;//把当前这块儿更新了
		if(w[st[pos[i]]]) d[pos[i]].llen=ptr[st[pos[i]]]-st[pos[i]]+1;
		else d[pos[i]].llen=0;
		if(w[ed[pos[i]]]) d[pos[i]].rlen=ed[pos[i]]-ptr[ed[pos[i]]]+1;
		else d[pos[i]].rlen=0;
	}
	
	int query(int l,int r){
		int bl=pos[l],br=pos[r];
		if(bl==br){//一块内暴力做
			int tmp=0,ren=0;
			for(int i=l;i<=r;i++){
				if(w[i]) tmp+=++ren;
				else ren=0;
			}
			return tmp;
		}
		dt ans; ans.empty=1;
		for(int i=bl+1;i<br;i++){//暴力合并过去
			
			//cout<<d[i].llen<<" "<<d[i].rlen<<"\n";
			ans=ans+d[i];
		}
		dt lans=dt(0,0,0),rans=dt(0,0,0);
		int ren=0;
		for(int i=l;i<=ed[bl];i++){//左右暴力算
			if(w[i]) lans.sum+=++ren;
			else ren=0;
		}
		lans.rlen=ren; ren=0;
		for(int i=r;i>=st[br];i--){
			if(w[i]) rans.sum+=++ren;
			else ren=0;
		}
		rans.llen=ren; ren=0;
		//合并
		ans=lans+ans+rans;
		
		return ans.sum;
	}
}blk;

int F[N];
int a[N];

void fake_main(){
	cin>>n>>m;
	siz=sqrt(n);
	for(int i=1;i<=n;i++){
		cin>>a[i];
		id[a[i]]=i;
	}
	for(int i=1;i<=m;i++){
		cin>>q[i].l>>q[i].r>>q[i].x>>q[i].y;
		q[i].id=i;
	}
	blk.init(n);
	sort(q+1,q+m+1,[](node a,node b){
		if(a.x/siz==b.x/siz) return a.y<b.y;
		else return a.x<b.x;
	});
	for(int i=1,j=1;i<=m;i=j){
		while(j<=m&&q[i].x/siz==q[j].x/siz) j++;
		int l=q[i].x/siz*siz+siz;
		int r=l-1; int tmp=l;
		for(int t=i;t<j;t++){
			if(q[t].y/siz==q[t].x/siz){//同一块暴力做
				for(int k=q[t].x;k<=q[t].y;k++) blk.modify(id[k],1);
				F[q[t].id]=blk.query(q[t].l,q[t].r);
				while(!st1.empty()) st1.back().first=st1.back().second,st1.pop_back();//回滚
				while(!st2.empty()) st2.back().first=st2.back().second,st2.pop_back();
				continue;
			}
			
			//cout<<q[t].x<<" "<<q[t].y<<" "<<l<<" "<<r<<"\n";
			//莫队
			while(r<q[t].y) blk.modify(id[++r],0);
			while(l>q[t].x) blk.modify(id[--l],1);
			F[q[t].id]=blk.query(q[t].l,q[t].r);
			while(!st1.empty()) st1.back().first=st1.back().second,st1.pop_back();
			while(!st2.empty()) st2.back().first=st2.back().second,st2.pop_back();
			l=tmp;//左端点回滚
		}
		memset(blk.ptr,0,sizeof blk.ptr);
		memset(blk.d,0,sizeof blk.d);
		memset(blk.w,0,sizeof blk.w);
		for(int k=1;k<=blk.pos[n];k++) blk.d[k].len=siz;
	}
	
	for(int i=1;i<=m;i++) cout<<F[i]<<"\n";
}

signed main(){
	ios::sync_with_stdio(false);
	int t; t=1;
	while(t--) fake_main();
}

/*
10 1
3 1 7 4 2 10 8 6 5 9 
3 8 4 9
*/ 

```

---

## 作者：qczrz6v4nhp6u (赞：1)

### Solution

静态询问，区间 & 值域双重限制，半群信息，这不我们 [D2T2](https://www.luogu.com.cn/problem/P5611) 吗？

下面来复读该题做法。

---

对序列分块，设块长为 $B$。散块直接暴力，考虑整块。考虑预处理每个块内所有 $O(B^2)$ 种值域限制的答案。

对序列维分治，设要求的区间为 $[l,r]$。每次先求出 $[l,mid]$ 与 $[mid+1,r]$ 的信息，再考虑更新值域在 $[x,y]$ 内的答案。找到左右两侧包含于 $[x,y]$ 的极大值域区间，合并即可。精细实现的复杂度为 $T(n)=2T(\frac n2)+O(n^2)=O(n^2)$。

时间复杂度是 $O(nB+\frac {n^2}{B}+qB+q\frac nB)$，取 $B=\sqrt n$ 即得 $O\Big((n+q)\sqrt n\Big)$ 的复杂度。

### Code

截至 2025.6.12 前是最优解。

由于代码复制自 D2T2，不难发现下面这份代码有很多内容是没有必要的，但是懒得改了。

```cpp
bool Mst;
#include<bits/stdc++.h>
using namespace std;
typedef unsigned int ui;
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 i128;
typedef __uint128_t u128;
typedef pair<int,int> pii;
#define fi first
#define se second
const int N=2e5+5,B=447;
inline ll Max(ll a,ll b){return a<b?b:a;}
inline ll Min(ll a,ll b){return a<b?a:b;}
struct Qry{
	int l,r,x,y,id;
	Qry(){l=r=x=y=id=0;}
	Qry(int _l,int _r,int _x,int _y,int _id){l=_l,r=_r,x=_x,y=_y,id=_id;}
};
inline bool operator <(const Qry &a,const Qry &b){
	if(a.x!=b.x)return a.x<b.x;
	return a.y<b.y;
}
struct node{
	bool all;int pre,suf;ll ans;
	node(){all=false,pre=suf=ans=0;}
	node(bool val){all=val,pre=suf=ans=val;}
	node(bool _all,int _pre,int _suf,ll _ans){all=_all,pre=_pre,suf=_suf,ans=_ans;}
};
const node mat[2]={node(0),node(1)};
inline node operator +(const node &A,const node &B){
	return node(A.all&&B.all,A.pre+A.all*B.pre,B.suf+B.all*A.suf,A.ans+B.ans+(ll)A.suf*B.pre);
}
Qry qry[N];int tx[N],ty[N];
int pre[N],suf[N];
int n,q,a[N];ll ans[N];node _ans[N];
node Ans[B+5][B+5],Tmp[B+5][B+5];
int dx[N],cx,dy[N],cy;pii num[N];int len;
int e[N],b[B+5],c[B+5],tmp[B+5],pos[B+5];bool typ[B+5];
inline void solve(int l,int r){
	if(l==r){
		c[l]=b[l];
		Ans[l][l]=node(true);
		return;
	}
	int mid=(l+r)>>1;
	solve(l,mid),solve(mid+1,r);
	for(int u=l;u<=mid;u++)
		for(int v=u;v<=mid;v++)
			Tmp[u][v]=Ans[u][v];
	for(int u=mid+1;u<=r;u++)
		for(int v=u;v<=r;v++)
			Tmp[u][v]=Ans[u][v];
	int i=l,j=mid+1,k=l;
	while(j<=r){
		while(i<=mid&&c[i]<c[j])
			typ[k]=0,pos[k]=i,tmp[k++]=c[i++];
		typ[k]=1,pos[k]=j,tmp[k++]=c[j++];
	}
	while(i<=mid)
		typ[k]=0,pos[k]=i,tmp[k++]=c[i++];
	for(int o=l;o<=r;o++)
		c[o]=tmp[o];
	static int fir[2],lst[2];
	for(int u=l;u<=r;u++){
		fir[0]=fir[1]=lst[0]=lst[1]=0;
		for(int v=u;v<=r;v++){
			if(!fir[typ[v]])fir[typ[v]]=pos[v];
			lst[typ[v]]=pos[v];
			Ans[u][v]=Tmp[fir[0]][lst[0]]+Tmp[fir[1]][lst[1]];
		}
	}
}
bool Med;
int main(){
	cerr<<abs(&Mst-&Med)/1048576.0<<endl;
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	int l,r,x,y;
	for(int i=1;i<=q;i++){
		cin>>l>>r>>x>>y;
		qry[i]=Qry(l,r,x,y,i);
		dx[++cx]=x,dy[++cy]=y;
		_ans[i]=node(1,0,0,0);
	}
	sort(qry+1,qry+q+1);
	sort(dx+1,dx+cx+1),cx=unique(dx+1,dx+cx+1)-dx-1;
	sort(dy+1,dy+cy+1),cy=unique(dy+1,dy+cy+1)-dy-1;
	for(int i=1;i<=q;i++){
		tx[i]=lower_bound(dx+1,dx+cx+1,qry[i].x)-dx;
		ty[i]=lower_bound(dy+1,dy+cy+1,qry[i].y)-dy;
	}
	for(int u=1,v=B;u<=n;u=v+1,v+=B){
		v=Min(v,n);
		len=0;int L=v-u+1;
		for(int i=1;i<=L;i++)
			num[++len]=make_pair(e[i]=a[i+u-1],i);
		sort(num+1,num+len+1);
		for(int i=1;i<=L;i++)
			b[i]=lower_bound(num+1,num+len+1,make_pair(e[i],i))-num;
		solve(1,L);
		for(int i=0;i<=cy;i++)pre[i]=0;
		for(int i=1;i<=cx+1;i++)suf[i]=B+1;
		for(int i=1;i<=L;i++){
			int px=upper_bound(dx+1,dx+cx+1,e[i])-dx-1,py=lower_bound(dy+1,dy+cy+1,e[i])-dy;
			suf[px]=Min(suf[px],b[i]);
			pre[py]=Max(pre[py],b[i]);
		}
		for(int i=1;i<=cy;i++)pre[i]=Max(pre[i],pre[i-1]);
		for(int i=cx;i>=1;i--)suf[i]=Min(suf[i],suf[i+1]);
		for(int i=1;i<=q;i++){
			l=qry[i].l,r=qry[i].r,x=qry[i].x,y=qry[i].y;
			if(l<=u&&v<=r)
				_ans[i]=_ans[i]+Ans[suf[tx[i]]][pre[ty[i]]];
			else{
				l=Max(l,u),r=Min(r,v);
				for(int j=l;j<=r;j++)
					_ans[i]=_ans[i]+mat[x<=a[j]&&a[j]<=y];
			}
		}
	}
	for(int i=1;i<=q;i++)ans[qry[i].id]=_ans[i].ans;
	for(int i=1;i<=q;i++)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Nagato__Yuki (赞：1)

# Solution
容易看出题目就是让我们求出区间内满足条件的极大子区间，设其长度为 $len$，则答案为 $\sum len\times (len+1)\div2$。

然后考虑怎样快速求出答案。我们在值域上跑莫队，删除操作有点麻烦，直接上回滚莫队，注意如果 $x$ 和 $y$ 在同一块内的话直接暴力。每次插入一个数时，可以用并查集维护极大子区间，如果左右两边的数满足条件则暴力合并。但是回滚莫队也是有撤销操作的，怎么办呢？我的想法：因为每次询问顶多撤销一次，所以可以保留一个并查集的历史版本，直接 $\mathcal O(1)$ 撤销就行了，空间常数也不大。

最后是统计部分，可以在序列上也进行分块，$\mathcal O(\sqrt n)$ 统计答案。注意当极大子区间的左右端点在块的端点上时要特殊判断。

代码写的有点史，但也能看。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mxn 200010
#define I inline
#define ll long long
struct Ask{
    int l,r,x,y,id;
}ask[mxn];
int n,q,a[mxn],pos[mxn],ans[mxn];
int len,id[mxn],L[mxn],R[mxn];
ll cnt,opt;
ll sum1[mxn],sum2[mxn];
struct vers{
    int a[mxn],b[mxn],v[mxn];
    int& operator[] (int x){
        if(!opt)return b[x];
        else{
            if(v[x]!=cnt){v[x]=cnt;return a[x]=b[x];}
            else return a[x];
        }
    }
};
vers sum;
struct Dsu{//并查集
    vers f,l,r;
    I void init(){
        for(int i=1;i<=n;i++)f[i]=l[i]=r[i]=i;
    }
    I int fnd(int x){
        return f[x]==x?x:f[x]=fnd(f[x]);
    }
    I void merge(int x,int y){
        int fx=fnd(x),fy=fnd(y);  
        if(fx==fy)return;
        f[fx]=fy;
        l[fy]=min(l[fx],l[fy]),r[fy]=max(r[fx],r[fy]);
    }
}dsu;
I ll getsize(ll x){
    return x*(x+1)/2;
}
void init(){
    len=max(10,(int)sqrt(n));
    for(int i=1;i<=n;i++){
        id[i]=(i-1)/len+1;
        if(id[i]!=id[i-1])L[id[i]]=i,R[id[i-1]]=i-1;
    }
    R[id[n]]=n;
}
I void addl(int x,int qr){
    int Pos=pos[x],Id=id[Pos],fId=dsu.fnd(Pos);
    if(L[Id]!=dsu.l[fId]&&R[Id]!=dsu.r[fId]){
        sum[Id]++;
        sum[Id]-=getsize(dsu.r[fId]-dsu.l[fId]+1);
    }
    if(L[Id]!=Pos&&dsu.l[fId]==Pos){
        if(a[Pos-1]>x&&a[Pos-1]<=qr){
            int flId=dsu.fnd(Pos-1);
            if(L[Id]!=dsu.l[flId])
                sum[Id]-=getsize(dsu.r[flId]-dsu.l[flId]+1);
            dsu.merge(Pos,Pos-1);
        }
    }
    if(R[Id]!=Pos&&dsu.r[fId]==Pos){
        if(a[Pos+1]>x&&a[Pos+1]<=qr){
            int frId=dsu.fnd(Pos+1);
            if(R[Id]!=dsu.r[frId])
                sum[Id]-=getsize(dsu.r[frId]-dsu.l[frId]+1);
            dsu.merge(Pos,Pos+1);
        }
    }
    fId=dsu.fnd(Pos);
    if(dsu.l[fId]!=L[Id]&&dsu.r[fId]!=R[Id])
        sum[Id]+=getsize(dsu.r[fId]-dsu.l[fId]+1);
}
I void addr(int x,int ql){
    int Pos=pos[x],Id=id[Pos],fId=dsu.fnd(Pos);
    if(L[Id]!=dsu.l[fId]&&R[Id]!=dsu.r[fId]){
        sum[Id]++;
        sum[Id]-=getsize(dsu.r[fId]-dsu.l[fId]+1);
    }
    if(L[Id]!=Pos&&dsu.l[fId]==Pos){
        if(a[Pos-1]<x&&a[Pos-1]>=ql){
            int flId=dsu.fnd(Pos-1);
            if(L[Id]!=dsu.l[flId])
                sum[Id]-=getsize(dsu.r[flId]-dsu.l[flId]+1);
            dsu.merge(Pos,Pos-1);
        }
    }
    if(R[Id]!=Pos&&dsu.r[fId]==Pos){
        if(a[Pos+1]<x&&a[Pos+1]>=ql){
            int frId=dsu.fnd(Pos+1);
            if(R[Id]!=dsu.r[frId])
                sum[Id]-=getsize(dsu.r[frId]-dsu.l[frId]+1);
            dsu.merge(Pos,Pos+1);
        }
    }
    fId=dsu.fnd(Pos);
    if(dsu.l[fId]!=L[Id]&&dsu.r[fId]!=R[Id])
        sum[Id]+=getsize(dsu.r[fId]-dsu.l[fId]+1);
}
I ll query(int l,int r,int x,int y){//分块求解
    int bl=id[l],br=id[r];
    ll ret=0,lst=0;
    for(int i=l;i<=min(r,R[bl]);i++){
        if(a[i]>=x&&a[i]<=y)lst++;
        else ret+=getsize(lst),lst=0;
    }
    for(int i=bl+1;i<=br-1;i++){
        int Id=dsu.fnd(L[i]);
        if(a[L[i]]>=x&&a[L[i]]<=y)lst+=dsu.r[Id]-dsu.l[Id]+1;
        if(dsu.r[Id]==R[i])continue;
        ret+=getsize(lst)+sum[i];
        Id=dsu.fnd(R[i]),lst=0;
        if(a[R[i]]>=x&&a[R[i]]<=y)lst+=dsu.r[Id]-dsu.l[Id]+1;
    }
    if(bl!=br){
        for(int i=L[br];i<=r;i++){
            if(a[i]>=x&&a[i]<=y)lst++;
            else ret+=getsize(lst),lst=0;        
        }
    }
    ret+=getsize(lst);
    return ret;
}
I ll getsum(int x){//暴力
    ll ret=0;
    for(int i=ask[x].x;i<=ask[x].y;i++){
        int Pos=pos[i],Id=dsu.fnd(Pos),fId=dsu.fnd(Pos);
        if(Pos<ask[x].l||Pos>ask[x].r)continue;
        ret++;
        ret-=getsize(dsu.r[Id]-dsu.l[Id]+1);
        if(dsu.l[fId]==Pos&&Pos>ask[x].l&&a[Pos-1]>i&&a[Pos-1]<=ask[x].y){
            int flId=dsu.fnd(Pos-1);
            ret-=getsize(dsu.r[flId]-dsu.l[flId]+1);
            dsu.merge(fId,Pos-1);           
        }
        if(dsu.r[fId]==Pos&&Pos<ask[x].r&&a[Pos+1]>i&&a[Pos+1]<=ask[x].y){
            int frId=dsu.fnd(Pos+1);
            ret-=getsize(dsu.r[frId]-dsu.l[frId]+1);
            dsu.merge(fId,Pos+1);       
        }
        Id=dsu.fnd(Pos);
        ret+=getsize(dsu.r[Id]-dsu.l[Id]+1);
    }
    return ret;
}
I void restore1(){
    opt=0,cnt++;
}
I void Init(){
    for(int i=1;i<=n;i++){
        int num=i;
        dsu.l.v[i]=dsu.r.v[i]=dsu.f.v[i]=0;
        dsu.l[i]=dsu.r[i]=dsu.f[i]=i;
    }
    for(int i=1;i<=id[n];i++)sum[i]=sum.v[i]=0;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>q;
    init();
    for(int i=1;i<=n;i++)cin>>a[i],pos[a[i]]=i;
    for(int i=1;i<=q;i++)cin>>ask[i].l>>ask[i].r>>ask[i].x>>ask[i].y,ask[i].id=i;
    sort(ask+1,ask+q+1,[](Ask a,Ask b){return id[a.x]==id[b.x]?a.y<b.y:id[a.x]<id[b.x];});
    int P=1;
    dsu.init();
    for(int i=1;i<=id[n];i++){//回滚莫队
        int l=R[i]+1,r=R[i];cnt=1;
        while(P<=q&&ask[P].x>=L[i]&&ask[P].x<=R[i]){
            if(ask[P].y<=R[i]){
                opt=1,ans[ask[P].id]=getsum(P),restore1();
                P++;continue;
            }
            while(r<ask[P].y)r++,addr(r,R[i]+1);opt=1;
            while(l>ask[P].x)l--,addl(l,ask[P].y);
            ans[ask[P].id]=query(ask[P].l,ask[P].r,ask[P].x,ask[P].y);
            restore1();//撤销
            P++,l=R[i]+1;
        }
        Init();
    }
    for(int i=1;i<=q;i++)cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：R_shuffle (赞：0)

显然，如果把区间 $[l,r]$ 中的数变成是否在 $[x,y]$ 内，那么就可以把问题变成求 $1$ 的连续段以及各段长度。如果 $x,y$ 是固定的，那么显然可以应用莫队来暴力统计这个东西。但是这个不是固定的。

然后发现一个好东西，题目中给的是一个排列，那么这就意味着不妨考虑对值域跑莫队，显然是和序列上莫队差不多的。然后考虑对于一组区间询问怎么办，这个是可以用线段树维护的。具体的，每次移动端点的时候就把这个数所在的位置从线段树中加入/删除，然后用线段树维护区间答案，这个是简单的。

但是这样的复杂度就是 $O(n\sqrt n\log n)$ 的，只能通过第一档。

然后考虑把线段树优化掉。显然只插入的话，答案是好算的，所以考虑用回滚莫队，这样就可以做到线性的插入了。

复杂度是 $O(n\sqrt q)$ 的。

---

## 作者：flyfreemrn (赞：0)

[[Cnoi2019] 数字游戏](https://www.luogu.com.cn/problem/P5386) 

我们发现，给定的序列是一个排列，所以每个值出现的位置是固定的，我们就可以考虑对值域莫队。

将处于当前值域的位置标记为 $1$，不在当前值域的位置标记为 $0$，当有一个长度为 $x$ 的连通块处在查询的区间内时，他对答案的贡献就是 $\frac{x\times(x+1)}{2}$，那么我们的问题就变成了维护动态修改，支持查询区间内1的连通块对答案的总贡献。

对于一个区间，我们需要维护与左端点相接的 $1$ 的个数，右端点相接的 $1$ 的个数，除去左右端点外所有连通块的总贡献，区间是否全 $1$ 等等。
因为我们的莫队已经让复杂度带根号了，线段树会让我们的复杂度升到 $O(n\sqrt{n} \log n)$，所以考虑从分块方面入手。

每个块内需要维护的信息如上述，考虑如何 $O(1)$ 在一个块内插入或删除一个 $1$，这个东西可以用链表维护。
对于块内的每一个位置记录以他为起点的右端点和以他为终点的左端点，这样我们插入时看看是否能合并两端的连通块，单次复杂度是 $O(1)$ 的。

对于删除操作很难维护，但是回溯很简单，所以我们用回滚莫队，开一个栈维护历史状态，每次查询后回溯。
最终总的时间复杂度就是 $O(n\sqrt{n})$。

---

## 作者：StayAlone (赞：0)

此题中可认为 $n,q$ 同阶。

普通的莫队只能处理两个自由度，而此题有四个自由度。考虑加上数据结构维护。

莫队跑值域的两维。问题转化成，在一个 01 序列上查询区间的贡献。很容易用线段树维护，时间复杂度 $\mathcal O(n\sqrt n\log n)$。

试图去掉 $\log$，考虑转为回滚莫队维护，于是就只剩下 $0\to 1$ 的操作。具体地：

- 在每个 $1$ 连续段的最左端维护 $nxt$，表示该连续段的最右端；
- 在每个 $1$ 连续段的最右端维护 $pre$，表示该连续段的最左端；
- 在每个 $1$ 连续段的最左端维护 $\frac{len\times (len + 1)}{2}$，其余部分均为 $0$。

如上信息容易在 $0\to 1$ 的操作下维护。查询区间时，若直接查区间和，只会有最左端和最右端出错。于是再用分块维护每个 $1$ 往左右分别能走到的最远连续 $1$，就能方便地修正贡献。这个分块是 $\mathcal O(1)$ 修改，$\mathcal O(\sqrt n)$ 查询的。

有一点难写，但不太难调。

[AC record](https://www.luogu.com.cn/record/186041973)

```cpp
int n, m, a[MAXN], idx[MAXN], len, bcnt, L[500], R[500], pos[MAXN];
vector <pair <int*, int>> change; vector <pair<ll*, ll>> change2;
int vis[MAXN], nxt[MAXN], pre[MAXN], cnt[500], legt[500];
ll val[MAXN], sum[500], ans[MAXN];

struct query {
	int l, r, x, y, id;
	
	il bool operator < (const query &g) const {
		return idx[x] ^ idx[g.x] ? x < g.x : y < g.y;
	}
} p[MAXN];

il int findpre(int x) {
	int id = idx[x];
	while (vis[x - 1] && idx[x - 1] == id) --x;
	if (idx[x - 1] == id) return x;
	while (cnt[id - 1] == legt[id - 1]) x = L[--id];
	while (vis[x - 1]) --x;
	return x;
}

il int findnxt(int x) {
	int id = idx[x];
	while (vis[x + 1] && idx[x + 1] == id) ++x;
	if (idx[x + 1] == id) return x;
	while (cnt[id + 1] == legt[id + 1]) x = R[++id];
	while (vis[x + 1]) ++x;
	return x;
}

il int getans(int l, int r) {
	int p = idx[l], q = idx[r];
	if (q - p < 2) {
		ll ans = 0; int cnt = 0;
		rep1(i, l, r) {
			if (vis[i]) ++cnt;
			else ans += cnt * ll(cnt + 1) / 2, cnt = 0;
		} return ans + cnt * ll(cnt + 1) / 2;
	} ll ans = 0;
	rep1(i, p + 1, q - 1) ans += sum[i];
	rep1(i, l, R[p]) ans += val[i];
	rep1(i, L[q], r) ans += val[i];
	if (vis[l] && vis[l - 1]) {
		int g = min(r, findnxt(l)), len = g - l + 1;
		if (g >= r) return len * ll(len + 1) / 2;
		ans += len * ll(len + 1) / 2;
	}
	if (vis[r] && vis[r + 1]) {
		int g = findpre(r), len = r - g + 1;
		ans -= val[g]; ans += len * ll(len + 1) / 2;
	} return ans;
}

il void sum_upd(int x, ll v) {
	change2.eb(&val[x], val[x]); change2.eb(&sum[idx[x]], sum[idx[x]]);
	val[x] += v; sum[idx[x]] += v;
}

il void insert(int x) {
	change.eb(&vis[x], vis[x]); vis[x] = 1;
	change.eb(&cnt[idx[x]], cnt[idx[x]]); ++cnt[idx[x]];
	if (vis[x - 1] && vis[x + 1]) {
		sum_upd(x + 1, -val[x + 1]);
		int p = pre[x - 1], q = nxt[x + 1], len = q - p + 1;
		change.eb(&nxt[p], nxt[p]); nxt[p] = q;
		change.eb(&pre[q], pre[q]); pre[q] = p;
		sum_upd(p, -val[p]); sum_upd(p, len * ll(len + 1) / 2);
	} else if (vis[x - 1]) {
		int p = pre[x - 1], len = x - p + 1;
		change.eb(&nxt[p], nxt[p]); nxt[p] = x;
		change.eb(&pre[x], pre[x]); pre[x] = p;
		sum_upd(p, len);
	} else if (vis[x + 1]) {
		int p = nxt[x + 1], len = p - x + 1;
		change.eb(&nxt[x], nxt[x]); nxt[x] = p;
		change.eb(&pre[p], pre[p]); pre[p] = x;
		sum_upd(x + 1, -val[x + 1]); sum_upd(x, len * ll(len + 1) / 2);
	} else {
		change.eb(&pre[x], pre[x]); change.eb(&nxt[x], nxt[x]);
		pre[x] = nxt[x] = x; sum_upd(x, 1);
	}
}

il void rollback() {
	reverse(begin(change), end(change)); reverse(begin(change2), end(change2));
	for (auto &p : change) *p.fst = p.snd;
	for (auto &p : change2) *p.fst = p.snd;
	change.clear(); change2.clear();
}

int main() {
	read(n, m); rer(i, 1, n, a), pos[a[i]] = i;
	swap(a, pos); len = sqrt(n); bcnt = (n - 1) / len + 1;
	rep1(i, 1, n) idx[i] = (i - 1) / len + 1;
	rep1(i, 1, m) read(p[i].l, p[i].r, p[i].x, p[i].y), p[i].id = i;
	rep1(i, 1, bcnt) L[i] = R[i - 1] + 1, R[i] = L[i] + len - 1;
	rep1(i, 1, bcnt) legt[i] = R[i] - L[i] + 1;
	sort(p + 1, p + 1 + m); int qid = 1; R[bcnt] = n;
	rep1(i, 1, bcnt) {
		if (qid > m) break;
		while (idx[p[qid].x] > i) ++i;
		int r = R[i]; change.clear(); change2.clear();
		rep1(j, 1, n) pre[j] = nxt[j] = vis[j] = val[j] = 0;
		rep1(j, 1, bcnt) sum[j] = cnt[j] = 0;
		while (idx[p[qid].x] == i) {
			int ql = p[qid].l, qr = p[qid].r, qx = p[qid].x, qy = p[qid].y;
			if (idx[qy] == i) {
				rep1(t, qx, qy) insert(a[t]);
				ans[p[qid].id] = getans(ql, qr); rollback();
			} else {
				while (r < qy) insert(a[++r]);
				change.clear(); change2.clear();
				rep1(t, qx, R[i]) insert(a[t]);
				ans[p[qid].id] = getans(ql, qr); rollback();
			} ++qid;
		}
	}
	rep1(i, 1, m) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：Anoshag_Ruwan (赞：0)

半年前最早看的这题，当时甚至不会回滚莫队。

首先本题的暴力做法是显然的，就是扫一遍得到区间内所有符合条件的极长子区间并计算它们的 $\frac{size(size+1)}{2}$ 之和。时间复杂度为 $O(qn)$ 由于本题时限异常宽松（可能是照顾 $O(n \sqrt n\log n)$ 做法）于是可以获得 $34$ pts。

然后考虑更优秀的做法，数据范围和离线查询区间让我们想到莫队，但每次询问的条件不同导致莫队看似很难搞。考虑 $a_i$ 有排列的性质，结合同时存在 $i$ 和 $a_i$ 的约束这点启发我们将问题转化到其逆排列上（经典案例 [Wide Swap](https://www.luogu.com.cn/problem/AT_agc001_f) ），~~不过似乎更难了~~，但如果我们在逆排列（值域）上维护莫队的左右端点，移动时则在原排列对应位置修改呢？这样每次移动相当于修改一个位置使其变得合法/不合法，如果我们能对每个位置维护出其左侧、右侧的极长子区间，合并它们产生的贡献就是 $(siz_1+1)(siz_2+1)$。最经典的想法是线段树，对每个节点维护其最大的合法前缀/后缀和答案。这样加入、删除和查询都是 $O(\log n)$ 的，总复杂度 $O(n \sqrt m\log n)$ 并不友好。想优化掉 $\log$ 至少需要一个移动 $O(1)$，查询 $O(\sqrt n)$ 的算法。这让我们想到分块可以当成一个单层 $k$ 叉线段树理解。可以对于每一块 $O(1)$ 维护块内答案，查询时再计算 $O(\sqrt n)$ 个块合并产生的贡献，准确地说，对于每个合法极长子区间，维护 $fr_i$ 从终点指向起点，$nt_i$ 从起点指向终点，对于不合法的元素则有 $fr_i=i+1,nt_i=i-1$。注意极长区间不能跨越块的边界，于是就可以轻松地 $O(1)$ 计算 $size$ 和合并，并得到每块的最长前缀/后缀合法区间了。但这样删除一个合法元素依然不好搞，那就不要删除，使用回滚莫队。散块贡献使用一开始的暴力即可。

注意亿些细节，比如一整块都合法的情况，以及回滚莫队对于首尾端点都在一块内的区间要单独来算，代码量 $2.4$ KB 还是很友好的。

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define l2 st[fk[q[i].x1]+1]-1
#define LL long long
using namespace std;
const int N=2e5+11;
LL a[N],k,lpt,s[N],n,m,rpt,top,ans1[N],q1[N],fk[N],ap[N],e[N],st[N];
LL nt[N],fr[N],ans[N],nt1[N],fr1[N];
inline LL maxx(LL x,LL y){return x>y?x:y;}
inline LL minn(LL x,LL y){return x<y?x:y;}
struct xw{LL x1,y1,l,r,num;}q[N];
struct stk{LL l1,r1,x,y;}sk[N]; 
bool mo(xw x,xw y){return fk[x.l]==fk[y.l]?x.r<y.r:x.l<y.l;}
inline void add(LL x,bool m1){
	LL u=fk[x]==fk[x+1]?nt[x+1]:x,v=fk[x]==fk[x-1]?fr[x-1]:x; 
	s[fk[x]]+=(x-v+1)*(u-x+1);
	if(m1)sk[++top]=(stk){v,u,x,(x-v+1)*(u-x+1)};
	nt[v]=u,fr[u]=v;
}
inline LL rd(){
	LL i=0;char g=getchar();
	while(g>57||g<48)g=getchar();
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i;
}
inline LL sol(LL x,LL y,LL z){
	LL i,se=0,k2=0;
	for(i=y;i<=z;i++)
		(a[i]>=q[x].l&&a[i]<=q[x].r)?k2++:(se+=k2*(k2+1)>>1,k2=0);
	se+=k2*(k2+1)>>1;return se;}
inline void sol1(LL i,bool m1){
	LL j,s1;
	if(m1)for(j=q[i].l;j<=q[i].r;j++)add(ap[j],1);
	ans[q[i].num]+=sol(i,q[i].x1,l2)+sol(i,st[fk[q[i].y1]],q[i].y1); 
	s1=l2-maxx(fr[l2],q[i].x1)+1;
	for(j=fk[q[i].x1]+1;j<=fk[q[i].y1];++j){
		ans[q[i].num]+=s1*(minn(nt[st[j]],q[i].y1)-st[j]+1);
		if(j<fk[q[i].y1])
			ans[q[i].num]+=s[j];
		s1=nt[st[j]]==st[j+1]-1?s1+st[j]-st[j-1]:st[j+1]-fr[st[j+1]-1];}
	while(top){
		stk w=sk[top--];
		nt[w.l1]=w.x-1,fr[w.r1]=w.x+1,s[fk[w.x]]-=w.y;}
}
inline void ljq(){
	LL i,j,h,s1,r2;
	for(h=1;h<k;++h){
		if(e[h]==e[h+1]||e[h]>m)continue;
		for(i=0;i<=n+1;++i)fr[i]=i+1,nt[i]=i-1;
		for(i=1;i<=k;++i)s[i]=0;
		lpt=rpt=st[h+1]-1,lpt++;
		for(i=e[h];i<e[h+1];++i){
			if(fk[q[i].x1]==fk[q[i].y1]){
				ans[q[i].num]=sol(i,q[i].x1,q[i].y1);continue;}
			if(fk[q[i].l]==fk[q[i].r])continue;
			while(rpt<q[i].r)add(ap[++rpt],0);
			while(lpt>q[i].l)add(ap[--lpt],1);
			sol1(i,0);lpt=st[h+1];}}
	for(i=0;i<=n+1;++i)fr[i]=i+1,nt[i]=i-1;
	for(i=1;i<=k;++i)s[i]=0;
}
int main()
{	
	LL i,j,h,se,sq;n=rd(),m=rd(),sq=sqrt(n);
	for(i=1;i<=n;i++)a[i]=rd();
	for(i=1;i<=n;i++)ap[a[i]]=i,fk[i]=(i-1)/sq+1;
	for(i=1;i<=m;i++)q[i]=(xw){rd(),rd(),rd(),rd(),i};
	sort(q+1,q+m+1,mo);
	for(i=1,j=0,k=fk[n]+1;i<k;i++){
		st[i]=(i-1)*sq+1;
		while(fk[q[j].l]<i&&j<=m)++j;e[i]=j;
	}st[k]=n+1,e[k]=m+1;
	ljq();
	for(i=1;i<=m;++i)
		if(fk[q[i].l]==fk[q[i].r]&&fk[q[i].x1]!=fk[q[i].y1])sol1(i,1);
	for(i=1;i<=m;++i)printf("%lld\n",ans[i]);
	return 0;
}
```
。



---

## 作者：dead_X (赞：0)

## 前言
写完了第十分块，发现这个题和第十分块很像，于是想来切一下，结果发现水的一批
## 前置知识
[第十分块题解](https://www.luogu.com.cn/blog/111055/solution-p6578)
## 正片
~~相信你已经会了，我就不讲了(~~

由于没有修改，可以直接上回滚莫队了，维护值域，按照 $x,y$ 作为端点排序，$y$ 单调增且 $x$ 在同一块中。

然后套路维护 $x$ 所在块右端点到 $y$ 这段值域对应的 $1$，对于每个询问再加上左边的 $1$。这边维护 $1$ 的方法请看前置知识。

本来我以为 $l$ 和 $r$ 在同一块比较难搞，后来发现给出的是一个排列，于是其实也很好搞，直接把对应区间提出来排个序，这题就这么快乐地做完了。
## 闲话
目前的最优解，你们常数怎么都这么大啊/yun

黑题-黑题的双倍经验就是爽啊（

不懂为什么这个题范围比 Ynoi 还小但是是 7s……

拒绝抄袭 不给代码 要代码请私信（

---


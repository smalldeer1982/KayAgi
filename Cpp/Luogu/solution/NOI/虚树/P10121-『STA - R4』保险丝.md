# 『STA - R4』保险丝

## 题目背景

APJ：「？我家保险丝怎么又没了」


## 题目描述

给一棵 $n$ 个点的有根树，根是 $1$ 号结点。

定义两个点集 $S_1,S_2$ 的距离为从两个集合分别选出一个点，能得到两点间距离的最小值，即 $\displaystyle\operatorname{dist}(S_1,S_2)=\min_{\substack{u\in S_1\\v\in S_2}}\operatorname{dist}(u,v)$，其中 $\operatorname{dist}(u,v)$ 是点 $u,v$ 间的距离。

定义 $\operatorname{path}(u,v)$ 是 $u$ 到 $v$ 的简单路径上的所有点组成的集合，$\mathcal L$ 是所有叶子组成的集合。

对于固定正整数 $u$，定义满足如下条件的结点 $v$ 构成 $u$ 的半邻域 $\mathring U(u)$：
- $v$ 在 $u$ 子树内；
- $\operatorname{dist}(u,v)\le\operatorname{dist}(\operatorname{path}(1,v),\mathcal L)$。

即 $u$ 的半邻域 $\mathring U(u)$ 包含 $u$ 的子树内所有满足到 $u$ 的距离不大于它到根的路径上任意一点离最近叶子节点的距离的点。

进而定义：
$$f(x)=\sum_{u\in\mathring U(x)}\prod_{\substack{v\in\operatorname{subtree}(u)\\v\in\mathring U(x)}}F_{\deg v}$$
其中 $\operatorname{subtree}(u)$ 是 $u$ 子树中所有点组成的集合，$\deg u$ 是 $u$ 的度数（与 $u$ 有连边的点的数量），$F$ 是 Fibonacci 数列：
$$F_n=\begin{cases}1&n\le 2\\F_{n-1}+F_{n-2}&n\ge 3\end{cases}$$

即 $f(x)$ 对应 $x$ 的半邻域中点对 $x$ 的贡献之和。而一个点 $u$ 对 $x$ 的贡献的计算方式为：取出每个 $u$ 子树内处在 $x$ 半邻域中的点 $v$，若 $v$ 的度数为 $d$，则将 $u$ 的贡献乘上 $F_d$，所有 $u$ 的贡献之和为结果。

你需要求出 $f(1),f(2),\cdots,f(n)$ 的值，为减少输出量，你只需要输出它们模 $994007158$ 后的异或和，即 $\bigoplus_{x=1}^n(f(x)\bmod 994007158)$ 即可。


## 说明/提示

### 样例解释
第一组数据中 $f$ 在 $1\dots 7$ 处的取值：$8,2,2,1,1,1,1$。

第二组数据中 $f$ 在 $1\dots14$ 处的取值：$4,17,2,1,1,8,1,1,4,2,1,1,1,1$。
### 数据范围

**本题采用捆绑测试。**
- Subtask 1 (10pts)：$n\le 5000$。
- Subtask 2 (20pts)：树的叶子个数不大于 $30$。
- Subtask 3 (20pts)：树中没有恰有一个儿子的结点。
- Subtask 4 (50pts)：无特殊限制。

对于全部数据，$2\le n,q\le 10^6$，每个非根结点父亲的编号小于它的编号。


## 样例 #1

### 输入

```
7
1 1 2 2 3 3
```

### 输出

```
8```

## 样例 #2

### 输入

```
14
1 2 3 3 2 6 6 6 9 9 10 11 12```

### 输出

```
25```

# 题解

## 作者：zzafanti (赞：9)

~~比赛结束前 20 多秒过掉，真刺激~~

[传送门](https://www.luogu.com.cn/problem/P10121)

## description

给定一棵大小为 $n$ 的树。

一个点 $x$ 的权值 $f(x)$ 定义为 $\sum\limits_{u\in \text{subtree}(x),P(x,u)} \prod\limits_{v\in \text{subtree(u)},P(x,v)} fib_{\text{dgr}_v}$。其中 $P(x,u)$ 表示根节点到 $v$ 路径上所有点至叶子结点的最短距离的最小值大于等于 $x$ 到 $v$ 的距离，$\text{dgr}_x$ 表示 $x$ 的度数，$fib_i$ 表示斐波那契数列第 $i$ 项。

对所有 $1\leq x\leq n$，求出 $f(x)$。对合数取模。

- $n\leq 10^6$

## solution

观察到 $x$ 子树内一个点 $u$ 是否满足 $P(x,u)$ 在 $x$ 到 $u$ 的链上是单调的。也就是说，如果 $P(x,u)$ 不成立，那么 $u$ 子树内所有点 $v$ 的 $P(x,v)$ 一定也不成立；如果 $P(x,u)$ 成立，那么 $x$ 到 $u$ 链上每个点 $v$ 都满足 $P(x,v)$。

定义每个点 $x$ 的 $len_x$ 为根到 $x$ 路径上所有点到叶子结点的最短距离的最小值，容易通过 dfs 线性求出所有 $len_x$。

然后以每个点为根统计这个点的 $f(x)$：搜索 $x$ 的子树，如果 $dis(x,u)>len_u$ 就不继续往下搜，容易 dp 出来每个点 $u$ 的 $\prod\limits_{v\in \text{subtree}(u),P(x,v)} fib_{\text{dgr}_v}$，加起来就是 $f(x)$。

这样我们获得了一个 $O(n^2)$ 的做法。

如果我们代码实现时每次搜索的复杂度只和搜到的点数有关的话，交上去会发现能过 subtask 3，也就是非叶子节点的度数至少为 2。

仔细想一下可以发现，此时 $len_x$ 是不超过 $O(\log n)$ 的，因为如果 $len_x$ 要取到 $k$，就必须有子树前 $k-1$ 层是满的，而且至少二叉，就要用掉至少 $2^{k-1}$ 个点。

这时我们搜索 $x$ 就相当于搜索一个满的 $len_x-1$ 层的至少二叉的树。容易发现满二叉树是最劣情况，搜索的复杂度不超过 $O(\sum\limits_{k\ge 1} \dfrac{n}{2^k} 2^\frac{k}{2})= O(n)$。

又因为 $fib_2=1$，这启发我们把度数为 2 的非叶子节点缩掉（也就是把链缩掉），把限制转化成 subtask 3。

令根节点、度数大于 2 的点和叶子结点为关键点。关键点之间一定是直链相连，可以对每个关键点记录它上面的直链的信息，对每个直链记录它的父亲和向下第一个关键点，并且对关键点建树。

统计 $f(x)$ 时，如果 $x$ 时关键点，可以直接搜索 $x$ 的子树，直链的贡献是平凡的，到搜索末端可以用二分算直链上的贡献；如果 $x$ 不是关键点，就找到它所在直链下方第一个关键点 $p$，搜索 $p$ 的子树，计算贡献也很平凡。

可以发现，这么做的复杂度是 $O(\sum |K(x)|)$ 的，$|K(x)|$ 表示满足在 $x$ 子树内且满足 $P(x,u)$ 的**关键点** $u$ 的数量。

下面证明 $O(\sum |K(x)|)\leq O(n)$。

考虑 $u$ 的贡献，它能贡献到的 $x$ 一定是往上连续的一段祖先，而且这个贡献范围的大小不超过 $u$ 子树内最近的叶子到 $u$ 的距离。下面证明对于所有关键点，其到其子树内最近叶子的距离之和不超过 $O(n)$。

按深度从大往小考虑，一个关键点 $u_i$ 一定能对应上一个叶子 $l_i$，使得 $\forall i,j$ 路径 $(u_i,l_i)$ 和 $(u_j,l_j)$ 不交。而要证明的距离之和是不超过 $\sum dis(u_i,l_i)$ 的，$\sum dis(u_i,l_i)$ 又是不超过 $O(n)$ 的，所以对于所有关键点，其到其子树内最近叶子的距离之和不超过 $O(n)$。

这样就做完了这个题。

带上二分时间复杂度 $O(n\log n)$，二分的常数很小。空间复杂度 $O(n)$。

应该可以使用双指针精细实现把时间复杂度降到 $O(n)$，但估计比较麻烦。

## code

这是我场上实现的二分的代码的核心部分。时间复杂度 $O(n\log n)$，可以被链卡到上界。添加了几个注释。

```cpp
using E=long long;
int n;
vector<int> fa,len,sz,dgr,par,nxt,pos;
vector<vector<int>> ver,Ver;
vector<vector<int>> pt;

void dfs1(int u){
  sz[u]=1;
  for(auto p:ver[u]){
    dfs1(p);
    len[u]=min(len[u],len[p]+1);
    sz[u]+=sz[p];
  }
  if(sz[u]==1) len[u]=0;
}

void dfs2(int u,int minx=len[1]){
  minx=min(minx,len[u]);
  len[u]=minx;
  for(auto p:ver[u]){
    dfs2(p,minx);
  }
}

vector<int> now;
void dfs4(int u,int Fa=1){
  if(u==1||dgr[u]>2||sz[u]==1){
    if(u!=1){
      Ver[Fa].emplace_back(u);
    }
    pt[u]=now;
    for(int i=0; i<(int)now.size(); i++){ // 把 u 上方链中的节点放到 pt[u] 里
      int p=now[i];
      nxt[p]=u,par[p]=Fa,pos[p]=i; // 并记录每个链上的点（即非关键点）对应的向下和向上第一个关键点
    }
    Fa=u;
    now.clear();
  }else{
    now.emplace_back(u);
  }
  for(auto p:ver[u]){
    dfs4(p,Fa);
  }
}

vector<E> dp;
E sum;
void dfs3(int u,int dis=0){
  dp[u]=fib[dgr[u]];
  for(auto p:Ver[u]){
    if(dis+pt[p].size()+1<=len[p]){
      dfs3(p,dis+pt[p].size()+1);
      dp[u]=dp[u]*dp[p]%mod;
      sum=(sum+dp[p]*pt[p].size())%mod;
      dp[p]=1;
    }else{ // 二分计算搜索的边界在哪里
      int l=-1,r=(int)pt[p].size()-1;
      while(l<r){
        int mid=(l+r+1)>>1;
        if(dis+mid+1<=len[pt[p][mid]]) l=mid;
        else r=mid-1;
      }
      sum=(sum+l+1)%mod;
    }
  }
  sum=(sum+dp[u])%mod;
}

void dfs5(int u,int dis=0){ // 这个 dfs 用于暴力，AC 100% 的数据没有使用
  dp[u]=fib[dgr[u]];
  for(auto p:ver[u]){
    if(dis+1>len[p]) continue;
    dfs5(p,dis+1);
    dp[u]=dp[u]*dp[p]%mod;
    dp[p]=1;
  }
  sum=sum+dp[u];
  sum%=mod;
}

int main(){
  cin>>n;
  fib.resize(n+1); dgr.resize(n+1); ver.resize(n+1);
  ifib.resize(n+1); fa.resize(n+1); len=vector<int>(n+1,n+1); sz.resize(n+1);
  for(int i=2; i<=n; i++){
    cin>>fa[i];
    dgr[i]++;
    dgr[fa[i]]++,ver[fa[i]].emplace_back(i);
  }

  fib[1]=fib[2]=1;
  for(int i=3; i<=n; i++){
    fib[i]=fib[i-1]+fib[i-2];
    fib[i]%=mod;
  }

  dfs1(1);
  dfs2(1);

  Ver.resize(n+1);
  pt=Ver;
  nxt=par=pos=vector<int>(n+1);
  dfs4(1);

  E ans=0; dp=vector<E>(n+1,1);
  for(int i=1; i<=n; i++){
    if(sz[i]==1){ // 把叶子直接判了
      ans^=1;
      continue;
    }
    sum=0;
    if(i==1||dgr[i]>2){
      dfs3(i,0);
      dp[i]=1;
    }else{
      if(len[nxt[i]]<pt[nxt[i]].size()-pos[i]){
        int l=pos[i],r=(int)pt[nxt[i]].size()-1;
        while(l<r){
          int mid=(l+r+1)>>1;
          if(mid-pos[i]<=len[pt[nxt[i]][mid]]) l=mid;
          else r=mid-1;
        }
        sum=(sum+l-pos[i]+1)%mod;
      }else{
      	dfs3(nxt[i],pt[nxt[i]].size()-pos[i]);
      	sum=(sum+(pt[nxt[i]].size()-pos[i])*1ll*dp[nxt[i]]%mod)%mod;
      	dp[nxt[i]]=1;
      }
    }
    //cerr<<i<<' '<<sum<<endl;
    sum=(sum%mod+mod)%mod;
    ans^=sum;
  }

  cout<<ans<<endl;

  return 0;
}
```



---

## 作者：jijidawang (赞：9)

（题目名字是 APJ 起的，和我没关系）

这个提示应该比较明显了，考虑到 $F_2=1$ 所以把树 leafy 化处理，也就是只在 $\deg>2$ 的位置计算贡献。

具体地，对于每个点 $u$，若 $\deg u>2$ 则称其为枢纽点，否则为普通点。

在计算 $f(u)$ 时，令点 $v$ 的贡献是 $\displaystyle \prod_{w\in\operatorname{subtree}(v)\land w\in\mathring U(u)}F_{\deg w}$ 即可将问题转为计算半邻域内所有点的贡献和。

考虑找到 $u$ 半邻域内的所有枢纽点，然后分别计算贡献。结构大体如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/y09x54mv.png)

这里只显式画出枢纽点和 $u$，其它普通点省略不画。贡献分为三种：
- 红色边：最上层枢纽点到 $u$ 之间点的贡献。
- 蓝色边：中层枢纽点到上层枢纽点之间点的贡献。
- 绿色边：最下层枢纽点下方普通点的贡献。

红色和蓝色边的贡献可以直接对枢纽点建虚树，然后 DFS 一遍求出每个枢纽点的贡献，这样就可以简单统计所有贡献了。

对于绿色边，因为 $F_2=1$ 所以所有绿色边部分的贡献都是 $1$，即相当于数有多少绿色边位置的点。考虑差分转为数半邻域点数和数半邻域删掉绿色边部分的点数，后者可以用和上面类似的方法求解，对于前者，考察半邻域的结构：记 $k_u=\operatorname{dist}(\operatorname{path}(1,u),\mathcal L)$（容易线性处理），那么 $v\in\mathring U(u)$ 当且仅当 $\operatorname{dist}(u,v)\le k_v$ 也就是 $\operatorname{dep}(v)-\operatorname{dep(u)}\le k_v$。整理可得 $\operatorname{dep}(v)-k_v\le\operatorname{dep}(u)$。加上子树的限制即为二维数点，扫描线即可。

时间复杂度分析：

扫描线部分是单 log 的没有问题，关键在于分析枚举枢纽点的复杂度。

断言：如果 $v$ 是 $u$ 半邻域内的枢纽点，则点对 $(u,v)$ 只有 $O(n\log n)$ 对。

证明：考虑肯定是满二叉树的结构点对数最多，假设树高为 $d$。枚举 $v$ 算有多少个 $u$ 满足条件，这里因为 $u$ 必须是 $v$ 的祖先所以至多有 $d$ 个，从而点对数有上界 $d\cdot 2^d$。

因为 $n=2^d$ 所以可以导出点对的数量是 $O(n\log n)$ 级别的。

（进而可以发现这里实现的一个小细节是找 $u$ 半邻域内的所有枢纽点 $v$ 时，要枚举 $v$ 然后爬树找 $u$，这样可以保证每一步都产生贡献，不会有冗余的枚举）

那么总时间复杂度就是 $O(n\log n)$ 的（实际实现的时候如果建虚树带 log 那么就是双 log 复杂度），可以通过。

![](https://pic.imgdb.cn/item/65a49995871b83018a61f993.jpg)

---

## 作者：5k_sync_closer (赞：5)

验题人题解。

为了方便描述，我们称题面中 $\prod\limits_{\substack{v\in\operatorname{subtree}(u)\\v\in\mathring U(x)}}F_{\deg v}$ 为 $u$ 对 $x$ 的贡献。

称度数 $\ge 3$ 的点是枢纽点，然后你要观察出一个阴间的性质：

每个点半邻域内的枢纽点个数之和是 $O(n\log n)$ 的。

（实际上，你可以通过暴力能过 Subtask 3 发现，

每个点半邻域内的枢纽点个数之和是一个可以接受的量级）

证明的话，感知一下可以发现完全二叉树可以使得每个点半邻域内的枢纽点个数之和最大，

而每个点半邻域内的枢纽点个数之和一定不超过每个点子树大小之和，也就是 $O(n\log n)$。

对每个枢纽点找半邻域内有它的点，这样预处理出每个点的半邻域内的枢纽点集。

对点 $u$ 半邻域内的枢纽点 $v$，设在 $u$ 的半邻域内，$v$ 上方第一个枢纽点为 $w$，

（若在 $u$ 的半邻域内，$v$ 上方没有枢纽点，$w$ 为 $u$ 的父亲）

则对 $[v,w)$ 上所有点 $x$，$x$ 对 $u$ 的贡献都一样，即都等于 $v$ 对 $u$ 的贡献。

于是求 $f(u)$ 时，只需对每个其半邻域内的枢纽点 $v$，统计 $v$ 以及与 $v$ 贡献相同的点的贡献，

没有被统计到的点贡献显然都是 $1$，简单加上它们的贡献即可。

考虑如何求每个 $v$ 的贡献，按 DFS 序从大到小加入每个 $v$，

则每个 $v$ 的贡献即为加入其后其子树内每个已加入的点 $i$ 的 $F_{\text{deg}_i}$ 之积，线段树维护之。

注意求 $f(1)$ 时可能需要一些特判。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define M 994007158
#define int long long
using namespace std;
struct T
{
    int c[1000050 << 2];
    void B(int s, int t, int p)
    {
        c[p] = 1;
        if (s == t)
            return;
        int m = s + t >> 1;
        B(s, m, p << 1);
        B(m + 1, t, p << 1 | 1);
    }
    void C(int l, int x, int s, int t, int p)
    {
        if (s == t)
            return c[p] = x, void();
        int m = s + t >> 1;
        if (l <= m)
            C(l, x, s, m, p << 1);
        else
            C(l, x, m + 1, t, p << 1 | 1);
        c[p] = c[p << 1] * c[p << 1 | 1] % M;
    }
    int Q(int l, int r, int s, int t, int p)
    {
        if (l <= s && t <= r)
            return c[p];
        int m = s + t >> 1, q = 1;
        if (l <= m)
            q = q * Q(l, r, s, m, p << 1) % M;
        if (r > m)
            q = q * Q(l, r, m + 1, t, p << 1 | 1) % M;
        return q;
    }
} Y;
struct E
{
    int v, t;
} e[2000050];
vector<int> v[1000050], w[1000050];
int n, c, l, _, Z, a[1000050], b[1000050], F[1000050], S[1000050], p[1000050], o[1000050],
    d[1000050], f[1000050], s[1000050], k[1000050], h[1000050], O[1000050], G[1000050];
void U(int x)
{
    for (; x <= n; x += x & -x)
        ++O[x];
}
int Q(int x, int y)
{
    int q = 0;
    for (--x; y > x; y &= y - 1)
        q += O[y];
    for (; x > y; x &= x - 1)
        q -= O[x];
    return q;
}
void A(int u, int v) { e[++c] = {v, h[u]}, h[u] = c; }
void D(int u)
{
    if (o[u] > 2)
        p[u] = S[l], S[++l] = u;
    b[u] = ++_;
    s[u] = 1;
    if (h[u])
        k[u] = 1e9;
    for (int i = h[u], v; i; i = e[i].t)
        D(v = e[i].v), k[u] = min(k[u], k[v] + 1), s[u] += s[v];
    if (o[u] > 2)
        --l;
}
bool B(int x, int y) { return d[x] - k[x] < d[y] - k[y]; }
signed main()
{
    scanf("%lld", &n);
    w[d[1] = F[1] = o[1] = 1].push_back(1);
    for (int i = 1; i <= n; ++i)
        a[i] = i;
    for (int i = 2; i <= n; ++i)
    {
        scanf("%lld", f + i), A(f[i], i), ++o[i], ++o[f[i]];
        w[d[i] = d[f[i]] + 1].push_back(i), F[i] = (F[i - 1] + F[i - 2]) % M;
    }
    D(1);
    for (int i = 2; i <= n; ++i)
        k[i] = min(k[i], k[f[i]]);
    sort(a + 1, a + n + 1, B);
    for (int i = 1, j = 0; i <= n; ++i)
    {
        while (j < n && d[a[j + 1]] - k[a[j + 1]] <= i)
            ++j, U(b[a[j]]);
        for (auto k : w[i])
            G[k] = Q(b[k], b[k] + s[k] - 1);
    }
    for (int i = n; i >= 1; --i)
        if (o[i] > 2)
        {
            for (int j = i; j && d[i] - d[j] <= k[i]; j = f[j])
                v[j].push_back(i);
        }
    --o[1];
    Y.B(1, n, 1);
    for (int i = 1; i <= n; ++i)
    {
        int q = 0;
        for (auto j : v[i])
        {
            Y.C(b[j], F[o[j]], 1, n, 1);
            q = (q + Y.Q(b[j], b[j] + s[j] - 1, 1, n, 1) * (d[j] - max(d[p[j]], d[i] - 1)) % M) % M;
            G[i] -= d[j] - max(d[p[j]], d[i] - 1);
        }
        Z ^= q + G[i];
        for (auto j : v[i])
            Y.C(b[j], 1, 1, n, 1);
    }
    printf("%lld", Z);
    return 0;
}
```


---

## 作者：Union_of_Britain (赞：4)

另类 $O(n\log n)$，，，

泛化一下 $val_u=F(deg_u)$，$u$ 的“半邻域”是一个 $u$ 是最浅点的连通块，反过来是 $x$ 的祖先的深度在 $d_x\sim dep_x$ 部分的点的“半邻域”包含 $x$。

要枚举题目式子中 $u$。对原树启发式合并。若继承重儿子，暴力加入轻儿子贡献，不考虑轻儿子的 $u$ 的话，只需线段树维护每个 dep 的答案，具体而言是要维护两个数组 $A,B$，操作是 $\forall A_i\gets A_i+B_i$，$\forall i\in [l,n],B_i\gets B_i\times v$ 和全部清空。当然可以 $O(n\log^2 n)$。然而本题的特殊性质有 

$$v\in son(u)\Rightarrow d_v\le d_u+2$$

因此修改的 $l$（从轻子树来的）实可以看为 $n$ 个连续的区间，运用线段树 $k$ 连续叶子节点的虚树是 $O(k+\log n)$ 的结论，精细实现获得 $O(n\log n)$。

对于轻儿子的 $u$ 贡献：我撤走轻儿子 $v$ 线段树的时候不去清空所有，而是加一个 tag 表示 $1\sim dep_v$ 的部分保留其 $A$，这样留下了贡献，复杂度不变 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool mst;
const int maxn=1e6+5,mod=994007158;
vector<int> e[maxn];
int sze[maxn],son[maxn],n,F[maxn],deg[maxn],val[maxn],fa[maxn],res[maxn],D[maxn],d[maxn],dep[maxn];
void dfs(int u){
	sze[u]=1;if(e[u].empty())D[u]=0;else D[u]=n+1;
	dep[u]=dep[fa[u]]+1;
	for(auto v:e[u]){
		dfs(v);sze[u]+=sze[v];
		if(sze[v]>sze[son[u]])son[u]=v;
		D[u]=min(D[u],D[v]+1);
	}
}
void dfs2(int u){
	if(fa[u])D[u]=min(D[u],D[fa[u]]);
	d[u]=max(1,dep[u]-D[u]);
	for(auto v:e[u])dfs2(v);
}
vector<int> pt;
void qsy(int u){
	pt.push_back(u);
	for(auto v:e[u])qsy(v);
}
int pv[maxn],nd=0;
#define ls (k<<1)
#define rs (k<<1|1)
#define mid ((l+r)>>1) 
namespace ST{
	int mul[maxn<<2],add[maxn<<2],va[maxn<<2],st[maxn<<2],st2[maxn<<2],leaf[maxn<<2];
	inline void SET(int k){st[k]=1,mul[k]=1,add[k]=va[k]=0;}
	inline void ADD(int k,int v){(add[k]+=1ll*mul[k]*v%mod)%=mod;(va[k]+=1ll*mul[k]*v%mod)%=mod;}
	inline void MUL(int k,int x){mul[k]=1ll*mul[k]*x%mod;}
	inline void SET2(int k){st2[k]=1;}
	inline void check(int k){
		if(st2[k]){
			if(!leaf[k]){
				if(add[k])ADD(ls,add[k]),ADD(rs,add[k]),add[k]=0;
				if(mul[k]!=1)MUL(ls,mul[k]),MUL(rs,mul[k]),mul[k]=1;
				st2[ls]=1,st2[rs]=1;
			}else mul[k]=1,add[k]=0;
			st2[k]=0;
		}
	}
	inline void pushdown(int k){
		check(ls),check(rs);
		if(st[k])SET(ls),SET(rs),st[k]=0;
		if(add[k])ADD(ls,add[k]),ADD(rs,add[k]),add[k]=0;
		if(mul[k]!=1)MUL(ls,mul[k]),MUL(rs,mul[k]),mul[k]=1;
	}
	void build(int k,int l,int r){
		add[k]=0;
		if(l==r)return leaf[k]=1,void();
		build(ls,l,mid);build(rs,mid+1,r);
	}
	void predo(int k,int l,int r,int L,int R){
		check(k);
		if(l==r)return MUL(k,pv[l]);
		pushdown(k);
		if(L<=mid)predo(ls,l,mid,L,R);
		if(mid<R)predo(rs,mid+1,r,L,R);
	}
	void modify(int k,int l,int r,int x,int y,int v){
		check(k);
		if(x<=l&&r<=y)return MUL(k,v);
		pushdown(k);
		if(x<=mid)modify(ls,l,mid,x,y,v);
		if(mid<y)modify(rs,mid+1,r,x,y,v); 
	}
	void modify2(int k,int l,int r,int x,int y){
		check(k);
		if(x<=l&&r<=y)return ADD(k,1);
		pushdown(k);
		if(x<=mid)modify2(ls,l,mid,x,y);
		if(mid<y)modify2(rs,mid+1,r,x,y);
	}
	void modify3(int k,int l,int r,int x,int y){
		check(k);
		if(x<=l&&r<=y)return SET(k);
		pushdown(k);
		if(x<=mid)modify3(ls,l,mid,x,y);
		if(mid<y)modify3(rs,mid+1,r,x,y);
	}
	void modify4(int k,int l,int r,int x,int y){
		check(k);
		if(x<=l&&r<=y)return SET2(k);
		pushdown(k);
		if(x<=mid)modify4(ls,l,mid,x,y);
		if(mid<y)modify4(rs,mid+1,r,x,y);
	}
	int query(int k,int l,int r,int x){
		check(k);
		if(l==r)return va[k];
		pushdown(k);
		if(x<=mid)return query(ls,l,mid,x);
		else return query(rs,mid+1,r,x);
	}
}
using namespace ST;
void solve(int u){
	for(auto v:e[u]){
		if(v==son[u])continue;
		solve(v);modify3(1,1,nd,dep[v],nd);modify4(1,1,nd,1,dep[v]-1);
	}
	if(son[u])solve(son[u]);
	pt={u};for(auto v:e[u])if(v!=son[u])qsy(v);
	int L=n+1,R=0;for(auto x:pt)L=min(L,d[x]),R=max(R,d[x]);
	for(int i=L;i<=R;i++)pv[i]=1;
	for(auto x:pt)pv[d[x]]=1ll*pv[d[x]]*val[x]%mod;
	for(int i=L+1;i<=R;i++)pv[i]=1ll*pv[i-1]*pv[i]%mod;
	predo(1,1,nd,L,R);
	if(R+1<=n)modify(1,1,nd,R+1,nd,pv[R]);
	modify2(1,1,nd,d[u],nd);
	res[u]=query(1,1,nd,dep[u]);
}
bool med;
namespace Fastio {
    #define USE_FASTIO 1

    #define IN_LEN 45000

    #define OUT_LEN 45000

    char ch, c; int len;
	short f, top, s;
    inline char Getchar() {
        static char buf[IN_LEN], *l = buf, *r = buf;
        if (l == r) r = (l = buf) + fread(buf, 1, IN_LEN, stdin);
        return (l == r) ? EOF : *l++;
    }
    char obuf[OUT_LEN], *ooh = obuf;
    inline void Putchar(char c) {
        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;
        *ooh++ = c;
    }
    inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }

    #undef IN_LEN
    #undef OUT_LEN
    struct Reader {
        template <typename T> Reader& operator >> (T &x) {
            x = 0, f = 1, c = Getchar();
            while (!isdigit(c)) { if (c == '-') f *= -1; c = Getchar(); }
            while ( isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = Getchar();
            x *= f;
            return *this;
        }
        
        Reader() {}
    } cin;
    const char endl = '\n';
    struct Writer {
        typedef long long mxdouble;
        template <typename T> Writer& operator << (T x) {
            if (x == 0) { Putchar('0'); return *this; }
            if (x < 0) Putchar('-'), x = -x;
            static short sta[40];
            top = 0;
            while (x > 0) sta[++top] = x % 10, x /= 10;
            while (top > 0) Putchar(sta[top] + '0'), top--;
            return *this;
        }
        Writer& operator << (const char *str) {
            int cur = 0;
            while (str[cur]) Putchar(str[cur++]);
            return *this;
        }
        inline Writer& operator << (char c) {Putchar(c); return *this;}
        Writer() {}
        ~ Writer () {flush();}
    } cout;
	#define cin Fastio::cin
	#define cout Fastio::cout
	#define endl Fastio::endl
}
signed main(){
	cin>>n;for(int i=2;i<=n;i++)cin>>fa[i],e[fa[i]].push_back(i),deg[i]++,deg[fa[i]]++;
	F[1]=F[2]=1;for(int i=3;i<=n;i++)F[i]=(F[i-1]+F[i-2])%mod;for(int i=1;i<=n;i++)val[i]=F[deg[i]];
	dfs(1);dfs2(1);for(int i=0;i<(maxn<<2);i++)mul[i]=1;for(int i=1;i<=n;i++)nd=max(nd,dep[i]);
	build(1,1,nd);solve(1);
	int ans=0;for(int i=1;i<=n;i++)ans^=res[i];
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：251Sec (赞：3)

第一个观察是，如果没有二度点，暴力的复杂度是 $O(n \log n)$ 的。考虑提取出所有至少三度的点，预处理每个点半邻域内所有的这样的点，这样也可以说明代价只有 $O(n \log n)$。第二个观察是 $F_1=F_2=1$，所以直接对每个点建出半邻域内所有至少三度点的虚树就可以快速计算所有答案不是 $1$ 的点的答案。答案是 $1$ 的你直接二维数点好了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 994007158;
int n, prt[1000005];
vector<int> e[1000005], p[1000005];
ll f[1000005];
int minD[1000005], dep[1000005], lt[1000005], rt[1000005], cti, deg[1000005], st[20][1000005];
void DFS(int u) {
	lt[u] = ++cti;
	if (!e[u].size()) minD[u] = 0;
	else minD[u] = 1e9;
	for (int v : e[u]) {
		dep[v] = dep[u] + 1;
		DFS(v);
		st[0][lt[v]] = u;
		minD[u] = min(minD[u], minD[v] + 1);
	}
	rt[u] = cti;
}
int PMin(int u, int v) { return lt[u] < lt[v] ? u : v; }
int LCA(int u, int v) {
	if (u == v) return u;
	if ((u = lt[u]) > (v = lt[v])) swap(u, v);
	int x = __lg(v - u++);
	return PMin(st[x][u], st[x][v - (1 << x) + 1]);
}
ll ans[1000005];
vector<int> eN[1000005];
ll w[1000005];
void DFS1(int u, int s) {
	w[u] = f[deg[u]];
	for (int v : eN[u]) {
		DFS1(v, s);
		ans[s] += (w[v] - 1) * (dep[v] - dep[u]) % P;
		w[u] = w[u] * w[v] % P;
	}
}
struct Oper {
	int x, y, id;
};
vector<Oper> ope;
int g[1000005];
void M(int i) { for (; i <= n; i += i & -i) g[i]++; }
int Q(int i) { int res = 0; for (; i; i &= i - 1) res += g[i]; return res; }
int sgn(int x) { return x > 0 ? 1 : -1; }
int main() {
	scanf("%d", &n);
	for (int i = 2, p; i <= n; i++) {
		scanf("%d", &p);
		deg[p]++, deg[i]++;
		e[p].push_back(i), prt[i] = p;
	}
	f[1] = f[2] = 1;
	for (int i = 3; i <= n; i++) f[i] = (f[i - 1] + f[i - 2]) % P;
	DFS(1);
	for (int j = 1; j < 20; j++) {
		for (int i = 1; i + (1 << j) - 1 <= n; i++) {
			st[j][i] = PMin(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
		}
	}
	for (int i = 2; i <= n; i++) minD[i] = min(minD[i], minD[prt[i]]);
	for (int u = 1; u <= n; u++) {
		ope.push_back({ dep[u] - minD[u], lt[u], 0 });
		ope.push_back({ dep[u], rt[u], u });
		ope.push_back({ dep[u], lt[u] - 1, -u });
		if (deg[u] > 2) {
			for (int v = u; v; v = prt[v]) {
				if (dep[u] - dep[v] > minD[u]) break;
				p[v].push_back(u);
			}
		}
	}
	sort(ope.begin(), ope.end(), [](const Oper &a, const Oper &b) {
		if (a.x != b.x) return a.x < b.x;
		return abs(a.id) < abs(b.id);
	});
	for (int i = 0; i < ope.size(); i++) {
		int y = ope[i].y, id = ope[i].id;
		if (!id) M(y);
		else ans[abs(id)] += sgn(id) * Q(y);
	}
	ll fAns = 0;
	for (int u = 1; u <= n; u++) {
		p[u].push_back(u);
		sort(p[u].begin(), p[u].end(), [](int x, int y) {
			return lt[x] < lt[y];
		});
		int s = p[u].size();
		for (int i = 0; i + 1 < s; i++) {
			p[u].push_back(LCA(p[u][i], p[u][i + 1]));
		}
		sort(p[u].begin(), p[u].end(), [](int x, int y) {
			return lt[x] < lt[y];
		});
		p[u].erase(unique(p[u].begin(), p[u].end()), p[u].end());
		for (int i = 1; i < p[u].size(); i++) {
			int x = p[u][i - 1], y = p[u][i];
			eN[LCA(x, y)].push_back(y);
		}
		DFS1(u, u);
		(ans[u] += w[u] - 1) %= P;
		fAns ^= ans[u];
		for (int i = 0; i < p[u].size(); i++) eN[p[u][i]].clear();
	}
	printf("%lld\n", fAns);
	return 0;
}
```

---

## 作者：Lyrella (赞：2)

# 题解

~~暴力出奇迹~~。

发现这个要求的东西很奇葩，我们的式子里面带了一个斐波那契数列，并且当一个点度数 $\le2$ 的时候都是 1，再观察特殊性质，其中性质 $C$ 保证树中除根以外每个节点的度数均 $\ge3$，好奇怪啊这啥意思呢？就是说这棵树是满二叉树，我们如果暴力去计算其实复杂度是调和级数 $O(n\log n)$ 的。这很优美不是吗？但是事情并非我们所愿，现在树上还有一些地方是一条长链，如果暴力做就会被卡炸。怎么办？考虑贡献是如何计算的，我们会将子树的度数套上斐波那契数列乘起来。所以我们就可以折叠长链。具体的我们可以记录一个点往下跳到第一个不是长链上的位置，如果这个点度数大于 2 就是他自己。然后暴力 dfs 的时候我们先判断这个点的度数是不是小于 2 的，如果是我们就进行跳跃，注意在跳的时候判断能不能跳完整个链。然后其他就直接做即可。

# 代码

```cpp
/*
 * @Author: Nekopedia 
 * @Date: 2025-05-22 10:35:18 
 * @Last Modified by: Nekopedia
 * @Last Modified time: 2025-05-22 19:29:36
 */
#include <bits/stdc++.h>
#define ll long long
#define gc() (p1 == p2 and (p2 = (p1 = buf) + fread(buf, 1, S, stdin), p1 == p2) ? EOF : *p1++)
using namespace std;
const int N = 1e6 + 5, S = 1 << 25, p = 994007158, inf = 2e9;
const ll INF = 2e18;
char buf[S], *p1, *p2;
inline ll rd(){
    ll x = 0, f = 1; char c = gc();
    while(! isdigit(c)){if(c == '-')f = - f; c = gc();}
    while(isdigit(c)){x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    return x * f;
}
void fileio(const string &s){
    freopen((s + ".in").c_str(), "r", stdin);
    freopen((s + ".out").c_str(), "w", stdout);
}

inline int Add(int x, int y){return x - p + y >= 0 ? x - p + y : x + y;}
inline int Sub(int x, int y){return x < y ? x - y + p : x - y;}
inline int Mul(int x, int y){return 1ll * x * y % p;}
inline int Mo(ll x){return (x % p + p) % p;}
inline int qmi(int x, int y){int res = 1; for(; y; y >>= 1, x = Mul(x, x))if(y & 1)res = Mul(res, x); return res;}
inline void exgcd(ll a, ll b, ll &x, ll &y){if(! b)return x = 1, y = 0, void(); exgcd(b, a % b, y, x); y -= a / b * x;}
inline int Inv(int q){ll x, y; exgcd(q, p, x, y); return Mo(x);}

int n, a[N], fa[N], mi[N], prmi[N], deg[N], son[N], jp[N], dep[N];
int fib[N], ans, res;
vector < int > g[N];

void dfs1(int u){
    mi[u] = inf; dep[u] = dep[fa[u]] + 1;
    for(int v : g[u])dfs1(v), mi[u] = min(mi[u], mi[v]), jp[u] = jp[v];
    ++mi[u]; if(! son[u])mi[u] = 0; if(son[u] > 1)jp[u] = u;
}
void dfs2(int u){
    prmi[u] = (u == 1 ? mi[u] : min(prmi[fa[u]], mi[u]));
    for(int v : g[u])dfs2(v);
}
int dfs3(int st, int u){
    if(dep[u] - dep[st] > prmi[u])return 1;
    if(son[u] <= 1){
        int lim = min(dep[st] + prmi[u], mi[u] + dep[st] + dep[u] >> 1);
        if(jp[u] and lim >= dep[jp[u]]){
            int tmp = dfs3(st, jp[u]);
            res = Add(res, Mul(dep[jp[u]] - dep[u], tmp));
            return tmp;
        }
        res = Add(res, min(mi[u] + 1, lim - dep[u] + 1));
        return 1;
    }
    int tmp = fib[deg[u]];
    for(int v : g[u])tmp = Mul(tmp, dfs3(st, v));
    res = Add(res, tmp); return tmp;
}

const string FileName = "fuse";
signed main(){
    fileio(FileName);
    n = rd(); for(int i = 2; i <= n; ++i){
        g[fa[i] = rd()].push_back(i);
        ++deg[fa[i]]; ++deg[i]; ++son[fa[i]];
    }
    fib[1] = fib[2] = 1; for(int i = 3; i <= n; ++i)fib[i] = Add(fib[i - 1], fib[i - 2]);
    dfs1(1); dfs2(1);
    for(int i = 1; i <= n; ++i, res = 0)dfs3(i, i), ans ^= res; cout << ans;
    return 0;
}
```

---

## 作者：Crescent_Rose_ (赞：0)

考场上花大部分时间搓了个 LCT 做法，然后被卡常了，不过在洛谷上直接过了，不知道是数据还是机子的缘故。

这是个不需要斐波那契数列性质的单 $\log$ 做法，但似乎有巨大常数。

这个做法还是挺套路的，感觉基本上每一步都有迹可循。

---

考察半邻域的性质。

我们面对一个东西，可以**想象形态/数学建模表达**。

想象一下，一个直观的理解是从点 $u$ 处往下倒一桶蜂蜜，蜂蜜流到一些地方就流不动了，流经的地方就是 $u$ 的半邻域。

首先注意到一个点到根的路径上的点到叶子的最小距离，只需要对路径上每个点考虑其子树中的叶子，否则会走多余的路。

那么先对每个点处理出其子树中叶子到它的最短距离 $dis_u$，再对每个点求出其到根的路径上 $dis$ 的最小值，记为 $mn_u$。

再考虑子树中一个点到子树根的距离，显然可以用深度直接算出。于是我们将涉及到的所有距离都转化为绝对的值相运算的结果，将**相对距离**写成**绝对的深度**，得到邻域的新定义：

- $v$ 在 $u$ 子树内。
- $dep_v-dep_u\leq mn_v$，即 $dep_v-mn_v\leq dep_u$。

如果用 DFS 序编号，一个半邻域就是二维平面上一个 **$3-side$ 矩形**。

---

我们将半邻域转成矩形后仍然不好处理。考虑利用矩形只有 $1$ 个 $side$ 的那一维做**扫描线**，另一维是**子树区间**，性质比一般的区间好，考虑在**树上**做。

这样扫描线**将静态问题转化为动态问题**，实现了**降维**。

接下来考察询问的性质。

首先考虑询问范围的结构。**不管扫描线那一维（半邻域）的限制**（$dep_v-mn_v\leq dep_u$，**它被扫描线的过程满足了**）就是子树的子树，于是我们要**平衡修改和查询**。

- 修改：原来是单点修改，现在变成子树到根的链的修改。
- 查询：原来是子树的子树查询，现在变成子树查询。

于是我们要在扫描线的过程中，实现到根链的乘法、子树求和。

使用树链剖分+线段树是容易的。为了追求单 $\log$，可以采用 LCT，对于子树信息，维护一个点的虚子树信息和 Splay 子树里所有点的虚子树信息和。

一些细节：

- 由于是乘法，LCT 中每个点的初值我都赋的 $1$。然而这样会导致还没被扫到的点被计算贡献，使用 DFS 序上的树状数组维护子树中多少个点被扫到即可。
- 扫描线排序时，由于限制是 $\leq$，对于值相同的修改和查询，应该把修改排前面。

---

考场代码，有点脏乱差。

```cpp
#include <bits/stdc++.h>
#define gc getchar
using namespace std;
int rd() {
	int x = 0, f = 1; char c = gc();
	while(c < '0' || c > '9') { if(c == '-') f = (- 1); c = gc(); }
	while(c >= '0' && c <= '9') { x = x * 10 + (c - '0'); c = gc(); }
	return (x * f);
}
const int Mod = 994007158;
const int N = 1000000;
inline int Add(int x, int y) { return x + y >= Mod ? x + y - Mod : x + y; }
inline int Sub(int x, int y) { return x < y ? x + Mod - y : x - y; }
namespace BIT {
	int sum[N + 1];
	void add(int n, int p, int val) { for(; p <= n; p += (p & -p)) sum[p] += val; }
	int qry(int p) { int res = 0; for(; p >= 1; p -= (p & -p)) res += sum[p]; return res; }
}
namespace LCT {
	int fa[N + 1], ch[N + 1][2], val[N + 1], sum[N + 1], mul[N + 1], vir[N + 1], virsum[N + 1];
	void Init(int n, int pa[], int siz[]) { for(int u = 1; u <= n; ++ u) fa[u] = pa[u], val[u] = sum[u] = mul[u] = 1, vir[u] = virsum[u] = siz[u] - 1; } // ? ?
	inline void Up(int u) {
		sum[u] = Add(Add(sum[ch[u][0]], sum[ch[u][1]]), val[u]);
		virsum[u] = Add(Add(virsum[ch[u][0]], virsum[ch[u][1]]), vir[u]);
	} // sum[0] == 0 // 1ll // val
	inline void Mo(int u, int Mul) { val[u] = 1ll * val[u] * Mul % Mod; sum[u] = 1ll * sum[u] * Mul % Mod; mul[u] = 1ll * mul[u] * Mul % Mod; } // val
	void Dn(int u) { if(mul[u] > 1) { if(ch[u][0]) Mo(ch[u][0], mul[u]); if(ch[u][1]) Mo(ch[u][1], mul[u]); mul[u] = 1; } }
	inline int IsRt(int u) { return ch[fa[u]][0] != u && ch[fa[u]][1] != u; }
	inline int Wh(int u) { return ch[fa[u]][1] == u; }
	void DnAll(int u) { if(! IsRt(u)) DnAll(fa[u]); Dn(u); }
	void Rot(int u) {
		int v, w, wu, wv; v = fa[u]; w = fa[v]; wu = Wh(u); wv = Wh(v);
		if(! IsRt(v)) ch[w][wv] = u; fa[u] = w; // 无论实虚信息都不用给 w 更新，因为从树和重链的角度看结构都没变
		fa[v] = u; ch[v][wu] = ch[u][wu ^ 1]; fa[ch[u][wu ^ 1]] = v; ch[u][wu ^ 1] = v;
		Up(v); Up(u);
	}
	void Splay(int u) { DnAll(u); while(! IsRt(u)) { if(! IsRt(fa[u])) Rot(Wh(u) == Wh(fa[u]) ? fa[u] : u); Rot(u); } } // ?
	void Access(int u) {
		for(int x = u, y = 0; x; x = fa[x]) {
			Splay(x);
			vir[x] = Add(Add(vir[x], virsum[ch[x][1]]), sum[ch[x][1]]);
			ch[x][1] = y;
			vir[x] = Sub(Sub(vir[x], virsum[y]), sum[y]);
			Up(x); y = x;
		}
	} // ? // x, not u
	void Mdf(int u, int Val) { Access(u); Splay(u); Mo(u, Val); } // Splay
	int Qry(int u) { Access(u); return Add(vir[u], val[u]); }
}
int n, F[N + 1], deg[N + 1], fa[N + 1], siz[N + 1], dep[N + 1], dis[N + 1], mn[N + 1], ans[N + 1];
vector < vector < int > > g(N + 1);
int lp[N + 1], rp[N + 1], tot;
struct Opt {
	int u, op;
	Opt(): u(0), op(0){}
	Opt(int U, int Op): u(U), op(Op){} // ?
}opt[2 * N + 1];
inline int Cmp(Opt x, Opt y) { // ?
	int p = (x.op == 1 ? dep[x.u] : dep[x.u] - mn[x.u]);
	int q = (y.op == 1 ? dep[y.u] : dep[y.u] - mn[y.u]);
	if(p != q) return p < q;
	return x.op < y.op;
}
void dfs(int u) {
	lp[u] = ++ tot;
	dep[u] = dep[fa[u]] + 1;
	siz[u] = 1;
	if(u > 1 && deg[u] == 1) dis[u] = 0; // n >= 2，所以根一定不是叶子（存疑）
	else dis[u] = n + 1;
	for(int v : g[u]) {
		dfs(v);
		siz[u] += siz[v];
		dis[u] = min(dis[u], dis[v] + 1);
	}
	rp[u] = tot;
}
void Solve() {
	n = rd();
	F[1] = F[2] = 1; for(int i = 3; i <= n; ++ i) F[i] = Add(F[i - 1], F[i - 2]); // N >= 2
	for(int i = 2; i <= n; ++ i) {
		fa[i] = rd();
		++ deg[i]; ++ deg[fa[i]];
		g[fa[i]].emplace_back(i);
	}
	dfs(1);
	for(int u = 1; u <= n; ++ u) {
		mn[u] = dis[u];
		if(u > 1) mn[u] = min(mn[u], mn[fa[u]]);
	}
	LCT::Init(n, fa, siz);
	int cnt = 0;
	for(int u = 1; u <= n; ++ u) {
		++ cnt; opt[cnt] = Opt(u, 0);
		++ cnt; opt[cnt] = Opt(u, 1);
	}
	sort(opt + 1, opt + 2 * n + 1, Cmp);
	
//	vector < bool > vis(n + 1);
	
	for(int i = 1; i <= 2 * n; ++ i) {
		if(opt[i].op == 0) {
			LCT::Mdf(opt[i].u, F[deg[opt[i].u]]);
//			vis[opt[i].u] = true;
			BIT::add(n, lp[opt[i].u], 1); // lp[ ]
		} else {
			int res = (LCT::Qry(opt[i].u));
//			ans[opt[i].u] = (BIT::qry(rp[opt[i].u])) - (BIT::qry(lp[opt[i].u] - 1));
//			ans[opt[i].u] = siz[opt[i].u];
			ans[opt[i].u] = (res + (BIT::qry(rp[opt[i].u])) - (BIT::qry(lp[opt[i].u] - 1)) - siz[opt[i].u]) % Mod; // siz[opt[i].u], not n
//			cout << "u = " << opt[i].u << " \n";
//			cout << "exist: ";for(int v = 1; v <= n; ++ v) if(vis[v]) cout << v << " ";
//			cout << "\n";
		}
	}
	int res = 0;
	for(int u = 1; u <= n; ++ u) res = (res ^ ((ans[u] + Mod) % Mod));
	printf("%d\n", res);
	
//	for(int u = 1; u <= n; ++ u) cout << ans[u] << ' ';
//	cout << "\n";
}
int main() {
//	freopen("9.in", "r", stdin);
	freopen("fuse.in", "r", stdin);
	freopen("fuse.out", "w", stdout);
	Solve();
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

2025.5.22

---


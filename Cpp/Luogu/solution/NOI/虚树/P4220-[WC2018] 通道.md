# [WC2018] 通道

## 题目背景

**滥用本题评测将被封号。**

## 题目描述

11328 年，C 国的科学家们研发了一种高速传送通道，可以在很短的时间内把居民从通道的一端送往另一端，这些通道都是双向的。

美中不足的是，这种传送通道需要进行大量的维护和检修。经过规划，C 国总统决定在 M 城中新建这种通道，在 M 城中，建立了 $n$ 个传送站和 $3\times(n-1)$ 条传送通道，这些传送通道被分为 $3$ 组，每一组都包含了 $(n-1)$ 条通道。

当任意一组通道运行时，居民都可以通过这组通道从任意一个传送站前往任意的另一个传送站。也就是说，所有的传送站都会被通道所连通。

三组通道按照 $1$、 $2$、 $3$ 的顺序轮流运行，循环反复。在任意一个时刻，都有且只有一组传送通道可以使用。形式化地，在第 $i$ 天中，有且只有第 $((i-1)\bmod 3+1)$ 组通道运行。

C 国著名科学家 Access Globe 正在进行一项社会调查实验：调查两个传送站之间的传送通道使用者的信息。 Access Globe 的计划是这样的：

- 选定两个传送站 $a, b$
- 第一天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息
- 第二天，他从 $b$ 出发，使用正在运行的这组通道沿最短路径到达 $a$，并调查经过的所有通道上使用者的信息
- 第三天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息

Access Globe 知道每一条传输线路在运行时的使用者人数。他希望找出一对 $a, b$，使得在整个实验过程中所有经过的通道的使用者数量之和最大。 

Access Globe 希望参加 CCF NOI 2018 冬令营的你帮他解决这个简单的小问题。如果你成功地解决了这个问题， Access Globe 会送你一份小礼物——$100$ 分！

## 说明/提示

【样例$1$说明】

下图为样例中 $M$ 城的传送站和传输线路情况。其中点和虚线交替的线条、虚线条和实线条分别表示第一组、第二组和第三组通道。
![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)
一种可行的方案是选择 $a=2,b=5$，这样的使用者数量之和为 $(3)+(8+5+1)+(2+1+7)=27$。

【子任务】

对于所有数据， $2 \leq n \leq 10^5,0 \leq w \leq 10^{12}$。

特殊性质 $0$：任意两组通道构成完全相同。

特殊性质 $1$：第二组通道和第三组通道构成完全相同。

特殊性质 $2$：对于第二组的每一个传送站，最多只有两个通道可以到达它，且编号为 $x,y$ 的传送站之间通过一条通道直接连接充要条件是 $|x-y|=1$。

特殊性质 $3$：对于第三组的每一个传送站，最多只有两个通道可以到达它。

特殊性质 $4$： $n \leq 3000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)

本题共 $31$ 个测试点，每个子任务对应测试点如下：

- 子任务 $0$ 对应测试点 $1-7$；
- 子任务 $1$ 对应测试点 $8$；
- 子任务 $2$ 对应测试点 $9-11$；
- 子任务 $3$ 对应测试点 $12-14$；
- 子任务 $4$ 对应测试点 $15-17$；
- 子任务 $5$ 对应测试点 $18-21$；
- 子任务 $6$ 对应测试点 $22-25$；
- 子任务 $7$ 对应测试点 $26-31$；

【提示】

- 在两组通道中，可能都包含了连接传送站 $x,y$ 的通道，此时我们认为这两条通道是不同的。
- 特殊性质中，A 组通道和 B 组通道的『构成完全相同』是指：如果在 A 组中 $u,v$ 之间存在一条使用人数为 $w$ 的通道，那么在 B 组中 $u,v$ 之间一定也存在一条使用人数为 $w$ 的通道。是否相同与描述方式与描述顺序均无关。即在构成完全相同的两组通道 A 和 B 中，通道输入的顺序不一定相同，每条通道的端点的输入顺序也不一定相同（对于 A、B 组中一条连接 $u,v$ 的使用人数为 $w$ 的通道，一种可能出现的输入为： A 组通道中输入 $u\ v\ w$，而 B 组通道中输入 $v\ u\ w$）。

## 样例 #1

### 输入

```
5
1 2 2
1 3 0
1 4 1
4 5 7
1 2 0
2 3 1
2 4 1
2 5 3
1 5 2
2 3 8
3 4 5
4 5 1```

### 输出

```
27```

# 题解

## 作者：immortalCO (赞：87)

对 $T_1$ 进行边分治。每次分治的时候，考虑跨越中心边的两个所有路径。中心边将当前连通块分为左右两个连通块 $L$ 和 $R$。设点 $i$ 到中心边的距离为 $d_1(i)$，那么我们就是要找一对 $i\in L,j\in R$，使得 $d_1(i) + d_1(j) + dist_{T_2}(i,j) + dist_{T_3}(i, j)$ 最大。

建立 $L\cup R$ 的关于 $T_2$ 的虚树 $T_2^{'}$，在虚树上进行 DFS。设点 $i$ 在 $T_2$ 上的带权深度为 $d_2(i)$。在虚树上 DFS 到 $p$ 的时候，考虑所有在 $T_2^{'}$ 中的 LCA 为 $p$、且 $i\in L,j\in R$ 点对 $(i,j)$，求出 $d_1(i) + d_2(i) + d_1(j) + d_2(j) + dist_{T_3}(i,j) - 2d_2(p)$ 最大。其中最后一项和 $i,j$ 无关，可以省略。前三项可以看作是 $(d_1+d_2)(i) + (d_1+d_2)(j) + dist_{T_3}(i, j)$，即可以认为是在 $T_3$ 中，对每个点 $i$ 新建一个点 $i_{'}$，和 $i$ 连接边权为 $d_1(i) + d_2(i)$ 的边，求这棵树（称作 $T_3^{'}$）中的满足 $L$ 和 $R$ 包含条件的最长路径。

由于边权非负，性质“集合合并后最长路的端点一定是两个集合各自的最长路端点中的两个点”成立，因此使用并查集来维护。记 $f_{L/R}(i)$ 表示 $(i,j)$ 都在 [$T_2^{'}$ 的 $i$ 的子树的点集交上 $L/R$] 这个点集中时，在 $T_3^{'}$ 中的最长路的两个端点，那么 $f_{L/R}$ 容易转移。同时由于边权非负，要求出一个端点在集合 $A$ 中、另一个在集合 $B$ 中的最长路，这条最长路的端点一定一个是 $A$ 的最长路的其中一个端点，另一个是 $B$ 的最长路的其中一个端点，因此就可以在 $i$ 和其子节点 $j$ 转移的时候，用 $f_{L}(i)$ 和 $f_{R}(j)$ 组合更新答案，再用 $f_{R}(i)$ 和 $f_{L}(j)$ 组合更新答案（注意在这里更新答案的时候要减去 $2d_2(i)$）。

这样这题就做完了。直接实现的话 $O(n\log^2n)$，因为要求虚树和距离。如果强行优化的话可以优化成 $O(n\log n)$（LCA 可以用 $O(n\log n)$ 预处理 $O(1)$ 回答，虚树可以离线然后使用基数排序）。

---

## 作者：xiwang (赞：77)

刚开始：哇！一道虚树分治！来写吧！

10分钟后：哦法克，去你old_mother的虚树！

随机化爬山是个好东西啊！

具体就是，我们每次随便找一个根节点，然后计算三个图上

每个点到这个点的距离，取这些点中3张图到根节点距离最大的

更新答案，并用它开始下一轮搜索。这么重复几次，每执行

几轮搜索就换一个初始节点再来搞。

黑科技：每次随机贪心完了统计程序运行时间，等到达某个阈值再退出

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100000+5;
typedef long long ll;
#define CLK (double)clock()/(double)CLOCKS_PER_SEC*1000.0
typedef double ddf;
int n;
int p[N];
ll dis[3][N],ass;
struct edge{
	int to,next;ll w;
};
struct graph{
	edge g[N<<1];
	int head[N],tot;
	void clr(){
		memset(head,0,sizeof(head));
		tot=1;
	}
	void add(int st,int ed,ll w){
		g[tot]=(edge){ed,head[st],w};
		head[st]=tot++;
	}
}g[3];
void dfs(int x,int fa,int idx){
	for(int i=g[idx].head[x];i;i=g[idx].g[i].next){
		int v=g[idx].g[i].to;
		ll w=g[idx].g[i].w;
		if(v!=fa){
			dis[idx][v]=dis[idx][x]+w;
			dfs(v,x,idx);
		}
	}
}
void small(){
	//因为3000点数太少，下面的判重容易死循环\
	而我又懒得改，就这样了 
	for(int rt=1;rt<=n;rt++){
			dis[0][rt]=dis[1][rt]=dis[2][rt]=0;
			dfs(rt,-1,0);
			dfs(rt,-1,1);
			dfs(rt,-1,2);
			ll mx=0;
			for(int j=1;j<=n;j++){
				ll sb=dis[0][j]+dis[1][j]+dis[2][j];
				ass=max(ass,sb);
			}
		}
		printf("%lld\n",ass);
}
bool vis[N];
inline int rad(){return rand()%n+1;}
int main(){
	//freopen("ex_2.in","r",stdin);
	srand(19260817);
	ddf st=CLK;
	int x,y;ll z;
	scanf("%d",&n);
	g[0].clr();
	g[1].clr();
	g[2].clr();
	for(int i=1;i<n;i++){
		scanf("%d%d%lld",&x,&y,&z);
		g[0].add(x,y,z);
		g[0].add(y,x,z);
	}
	for(int i=1;i<n;i++){
		scanf("%d%d%lld",&x,&y,&z);
		g[1].add(x,y,z);
		g[1].add(y,x,z);
	}
	for(int i=1;i<n;i++){
		scanf("%d%d%lld",&x,&y,&z);
		g[2].add(x,y,z);
		g[2].add(y,x,z);
	}
	if(n<=3000){
		small();return 0;
	}
	while(CLK-st<=3400){
		int rt=rad();
		while(vis[rt])rt=rad();
		for(int i=1;i<=8;i++){
			if(vis[rt])break;
			vis[rt]=1;
			dis[0][rt]=dis[1][rt]=dis[2][rt]=0;
			dfs(rt,-1,0);
			dfs(rt,-1,1);
			dfs(rt,-1,2);
			ll mx=0;
			for(int j=1;j<=n;j++){
				ll sb=dis[0][j]+dis[1][j]+dis[2][j];
				ass=max(ass,sb);
				if(!vis[j]&&sb>mx){
					mx=sb,rt=j;
				}
			}
		}
	}
	printf("%lld",ass);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：47)

这题是真的毒

~~三棵树的题真的可以搞死你~~

___________

### 前置芝士:快速lca

由于这道题中求lca的次数相当的多,请使用快速求lca的方式来求lca，比如st表

### 前置芝士:虚树

如果不知道什么是虚树的话可以做一做这三道题

[ P2495 [SDOI2011]消耗战](https://www.luogu.org/problemnew/show/P2495)

[P4103 [HEOI2014]大工程](https://www.luogu.org/problemnew/show/P4103)

[ P4606 [SDOI2018]战略游戏](https://www.luogu.org/problemnew/show/P4606)

然后你应该就就知道这东西是用来干什么的以及它怎么写了

### 前置芝士:边分治

可能点分治大家都十分熟练了吧(不然估计不敢来淦这道猫式树上最优化问题)

但是其实边分治的题就比较少了,所以让我们来普及一下边分治的基本姿势

#### 边分治的算法流程

1.多叉树转二叉树

2.找中心边

3.切掉这条中心边并且处理过中心边的所有路径

4.递归分治左右两个联通块

那么我们一步一步的讲解这些步骤该怎么做

### 多叉树转二叉树

可能很多人都听说过这个东西，但是并不知道这个东西具体来讲怎么写

多叉树转二叉树的策略被称为**左儿子右兄弟**

但是其实这个策略并不好使，因为你发现你真的按照左儿子右兄弟转完二叉树之后就会发现转化之后的树和原来的树半毛钱关系没有，甚至转化之后任意两个点间的距离这个最松的条件都变了

对，因为这个原则省略了一句话叫**添加虚点**

具体来讲对于多叉树转二叉树这个问题来讲我们像下面的图一样插入一些虚点，然后就可以多叉树转二叉树了

![](https://cdn.luogu.com.cn/upload/pic/40815.png)

图中的红色方点全部是插入的虚点，灰色的边表示这是一条边权为0的边，黑色的边表示这是和树上原来的边权相等的边

关于具体的实现可以看我代码中$Tr1::Ot$这个namespace中的代码
____________

### 找中心边

没啥好说的，找到一个边使得切断这条边之后最大子树尽可能的小

直接暴力dfs两遍找一下就行了

### 切掉中心边

有一个小问题是无向边在邻接表中是存储为两条有向边的，我们如何同时切掉这两条边呢？、

这里我们需要使用一个在网络流当中使用的trick，我们令邻接表的cnt=1并且保证一条无向边对应的两条边是相邻的,这样的话我们假设得知了其中的一条边的编号i，那么i^1就是反向边的编号了，这样我们就可以快速得知一条边对应的反向边的标号了

______________

## 本题题解

那么我们发现这题是三棵树

思路很简单，一棵树换一个算法然后多套几层就出来了

首先我们对第一棵树进行边分治,这样我们可以在$O(logn)$层分治当中解决完所有的路径$(a,b)$

那么假设我们我们正在考虑经过中心边$(st,ed)$的所有路径,那么我们发现一个路径$(a,b)$经过中心边当且仅当切掉这条边之后a和st属于同一个联通块而b和ed属于同一个联通块

那么我们不妨把切掉中心边之后所有和st相连的点全部标成黑色,所有和ed相连的点全部标成白色

此时我们在这一层当中的任务就是寻找一个对点$(a,b)$使得

$$dis(a,st)+dis(ed,b)+val(st,ed)+T2.dis(a,b)+T3.dis(a,b)$$

最大并且a是一个黑点,b是一个白点

那么我们发现$val(st,ed)$似乎是一个常量我们不用管他

然后我们接着拆拆式子

$$dis(a,st)+dis(ed,b)+T2.dep(a)+T2.dep(b)+T3.dep(a)+T3.dep(b)$$

上面这些都是仅仅和a或者仅仅和b有关的数值还要加上

$$-2T2.dep(lca(a,b))-2T3.dep(lca(a,b))$$

然后我们可以很方便的处理出$w(x)=dis(x,st/ed)+T2.dep(x)+T3.dep(x)$

那么此时我们要最大化的式子就是

$$w(a)+w(b)-2T2.dep(lca(a,b))-2T3.dep(lca(a,b))$$

我们发现一件事，边分治出来的黑色点和白色点也是点的集合

既然是点的集合就可以跑虚树啊


所以我们把所有的黑色点和白色点放到T2上去跑虚树

那么构建出虚树之后我们可以在虚树上dfs来枚举$T2.lca(a,b)$的值假设我们枚举的lca是p,那么此时$-2T2.dep(p)$已经是一个定值我们的目标就是找到一对点$(a,b)$其中a和b来自p不同的子树并且a是黑点b是白点

同时最大化

$$w(a)+w(b)-2T3.dep((lca(a,b))$$

那么其实我们是可以dp来求解这个东西的

具体来讲为了做这题我们需要一个结论

**对于一颗边权全部是正的树,假如说这颗树上有一个点集A的最长路端点分别是u,v
另有一个点集B的最长路端点分别是a,b,那么跨越点集A和B的最长路端点只可能是(u,a),(v,b),(u,b),(v,a)四条路径当中的一个**

那么有了这个性质我们就可以设计一个树形dp/贪心

我们记$dp(u,0)$表示**u子树中的白点**这个点集在T3的最长路端点,$dp(u,1)$表示**u子树中的黑点**这个点集在T3的最长路端点

转移是显然的,贡献答案的时候在合并两个联通块的时候计算,具体来讲假如说我们需要合并$dp(u)$和$dp(v)$这两个状态,并且假设u是v的父亲

那么显然跨越这两个联通块的点对(a,b)的lca都是u了,所以我们只需要计算出跨越联通块的最长距离然后减去$2T2.dep(u)$就行了

跨越联通块的最长距离也十分好算,我们只需要求出跨越$dp(u,0)$和$dp(v,1)$的最长距离和跨越$dp(v,1)$和$dp(u,0)$的最长距离就行了，利用刚才的结论枚举八个点对然后求一下距离就行了

看起来我们似乎在$O(nlog^2n)$的时间内做完了这道题？

其实我们忽略了一个小细节

我们刚才的**距离**其实全部指的是这个式子，而不是T3上的实际距离


$$realdis(a,b)=w(a)+w(b)-2T3.dep(lca(a,b))$$

换句话说也指这个式子

$$realdis(a,b)=(dis(a,st)+T2.dep(a))+(dis(ed,b)+T2.dep(b))+T3.dis(a,b)$$

显然这个式子并不是T3上的树上距离，那么我们刚才的结论为什么依然对这种"距离"成立呢？

答案其实也很简单为了证明这个结论(换句话说你在代码中要做的就是把计算距离的式子改一下)我们在每个点i下新建一个虚点i'并且令i'和i之间连一条边权为(dis(i,st/ed)+T2.dep(i))的边，这样的话我们会发现

$$realdis(a,b)=dis(a',b')$$

然后我们的结论就可以接着用下去了

然后就是这题码量巨大……少数写到150行的题……

注意你的手……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;typedef long long ll;ll ans;
int n;int lg[2*N];ll nw[N];int typ[N];int q1[N];int q2[N];int hd1;int hd2;
# define cmi(u,v) (dep[u]<dep[v]?u:v)
inline void clg(){for(int i=2,j=1;i<=2*n;i++)j=(((1<<(j+1))<=i)?j+1:j),lg[i]=j;}
namespace Tr3//第3棵树 
{
	int v[2*N];int x[2*N];int ct;int al[N];ll val[2*N];ll dis[2*N];
	int st[20][2*N];int fir[N];int dep[N];int hd;
	inline void add(int u,int V,ll va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
	inline void dfs(int u,int f)
	{
		st[0][++hd]=u;fir[u]=hd;nw[u]+=dis[u];
		for(int i=al[u];i;i=x[i])
			if(v[i]!=f)dis[v[i]]=dis[u]+val[i],dep[v[i]]=dep[u]+1,dfs(v[i],u),st[0][++hd]=u;
	}
	inline void prest()
	{for(int k=1,j=1;k<hd;k<<=1,j++)for(int i=1;i+k<=hd;i++)st[j][i]=cmi(st[j-1][i],st[j-1][i+k]);}
	inline int lca(int u,int v)//求lca算距离 
	{
		u=fir[u];v=fir[v];if(v<u)swap(u,v);int j=lg[v-u+1];
		int res=cmi(st[j][u],st[j][v-(1<<j)+1]);return res;
	}
	inline ll cdis(int u,int v){return nw[u]+nw[v]-(dis[lca(u,v)]<<1);}
}
namespace Tr2
{
	int v[2*N];int x[2*N];int ct;int al[N];ll val[2*N];int sta[N];int tp;
	int st[20][2*N];int fir[N];int dep[N];int hd;ll dis[N];
	bool book[N];int op[2*N];int tpop;int dfi[N];int dfo[N];int df;
	# define cd(u,v) (Tr3::cdis(u,v))
	struct data//dp用的结构体 
	{
		int u;int v;ll dis;data(){u=0;v=0;dis=0;}
		data (const int& U,const int& V){u=U;v=V;dis=cd(u,v);}
		data (const int& U,const int& V,const int& D){u=U;v=V;dis=D;}
		friend bool operator <(data a,data b){return a.dis<b.dis;}
		friend data operator +(data a,data b)
		{
			if(a.u==0)return b;if(b.u==0)return a;
			data res=max(a,b);res=max(res,max(data(a.u,b.v),data(a.v,b.u)));
			res=max(res,max(data(a.u,b.u),data(a.v,b.v)));return res;
		}
	}dp[N][2];
	inline ll mgdat(const data& a,const data& b)
	{
		if(a.u==0||b.u==0)return 0;
		return max(max(cd(a.u,b.u),cd(a.v,b.v)),max(cd(a.u,b.v),cd(a.v,b.u)));
	}
	inline void add(int u,int V,ll va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
	inline bool cmp(int a,int b)
	{int k1=(a<0)?dfo[-a]:dfi[a];int k2=(b<0)?dfo[-b]:dfi[b];return k1<k2;}
	inline void dfs(int u,int f)
	{
		st[0][++hd]=u;fir[u]=hd;dfi[u]=++df;nw[u]+=dis[u];
		for(int i=al[u];i;i=x[i])
			if(v[i]!=f)dis[v[i]]=dis[u]+val[i],dep[v[i]]=dep[u]+1,dfs(v[i],u),st[0][++hd]=u;
		dfo[u]=++df;
	}
	inline void prest()
	{for(int k=1,j=1;k<hd;k<<=1,j++)for(int i=1;i+k<=hd;i++)st[j][i]=cmi(st[j-1][i],st[j-1][i+k]);}
	inline int lca(int u,int v)
	{
		u=fir[u];v=fir[v];if(v<u)swap(u,v);int j=lg[v-u+1];
		return cmi(st[j][u],st[j][v-(1<<j)+1]);
	}	
	inline void solve(ll k)//建虚树并在虚树上树形dp 
	{
		tpop=0;for(int i=1;i<=hd1;i++)op[++tpop]=q1[i];
		for(int i=1;i<=hd2;i++)op[++tpop]=q2[i];sort(op+1,op+tpop+1,cmp);
		for(int i=1;i<=tpop;i++)book[op[i]]=true;
		for(int i=1;i<=tpop;i++)
			{int u=op[i],t=typ[u];dp[u][t]=data(u,u,0),dp[u][t^1]=data();}
		for(int i=1,lim=tpop;i<lim;i++)
			{int lc=lca(op[i],op[i+1]);if(!book[lc])book[lc]=true,op[++tpop]=lc,dp[lc][0]=dp[lc][1]=data();}
		for(int i=1;i<=tpop;i++)book[op[i]]=false;
		for(int i=1,lim=tpop;i<=lim;i++)op[++tpop]=-op[i];sort(op+1,op+tpop+1,cmp);
		for(int i=1;i<=tpop;i++)
			if(op[i]>0)sta[++tp]=op[i];
			else 
			{
				tp--;if(!tp)continue;int u=sta[tp+1];int f=sta[tp];
				ans=max(ans,max(mgdat(dp[u][0],dp[f][1]),mgdat(dp[u][1],dp[f][0]))+k-(dis[f]<<1));
				dp[f][0]=dp[f][0]+dp[u][0];dp[f][1]=dp[f][1]+dp[u][1];
			}	
	}
}
namespace Tr1//第一颗树 
{
	int v[4*N];int x[4*N];int ct=1;int al[2*N];ll val[4*N];int siz[2*N];
	bool cut[4*N];ll w[2*N];int res;int resv;
	inline void add(int u,int V,ll va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
	namespace Ot//多叉树转二叉树 
	{
		int ctt;int nu[N];int v[2*N];int x[2*N];int ct;int al[N];ll val[2*N];
		inline void add(int u,int V,ll va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
		inline void ins(int u,int V,ll va)
		{
			++ctt;Tr1::add(ctt,V,va);Tr1::add(V,ctt,va);
			Tr1::add(nu[u],ctt,0);Tr1::add(ctt,nu[u],0);nu[u]=ctt;
		}
		inline void build(int u,int f)
		{for(int i=al[u];i;i=x[i])if(v[i]!=f){ins(u,v[i],val[i]);build(v[i],u);}}
		inline void cbuild(){for(int i=1;i<=n;i++)nu[i]=i;ctt=n;build(1,0);}
	}
	inline int dfs1(int u,int f)
	{siz[u]=1;for(int i=al[u];i;i=x[i])if(v[i]!=f&&!cut[i])siz[u]+=dfs1(v[i],u);return siz[u];}
	inline void find(int u,int f,const int& tot)
	{
		for(int i=al[u];i;i=x[i])
			if(v[i]!=f&&!cut[i])
			{int ky=max(siz[v[i]],tot-siz[v[i]]);if(resv>ky)resv=ky,res=i;find(v[i],u,tot);}
	}
	inline void glt(int u,int f)
	{
		if(u<=n)typ[u]=0,q1[++hd1]=u;
		for(int i=al[u];i;i=x[i])if(v[i]!=f&&!cut[i])w[v[i]]=w[u]+val[i],glt(v[i],u);
	}
	inline void grt(int u,int f)
	{
		if(u<=n)typ[u]=1,q2[++hd2]=u;
		for(int i=al[u];i;i=x[i])if(v[i]!=f&&!cut[i])w[v[i]]=w[u]+val[i],grt(v[i],u);
	}
	inline void del(int u,int f)
	{for(int i=al[u];i;i=x[i])if(v[i]!=f&&!cut[i])del(v[i],u),cut[i]=cut[i^1]=true;}
	inline void solve(int u)//边分治 
	{
		dfs1(u,0);if(siz[u]==1)return;res=0;resv=0x3f3f3f3f;find(u,0,siz[u]);
		int st=v[res];int ed=v[res^1];cut[res]=true;cut[res^1]=true;
		hd1=0;hd2=0;w[st]=w[ed]=0;glt(st,0);grt(ed,0);
		if(hd1==0||hd2==0)//小剪枝，如果联通块全部是虚点就不进行分治 
			{if(hd1==0)del(st,0),solve(ed);else del(ed,0),solve(st);return;}
		for(int i=1;i<=hd1;i++)nw[q1[i]]+=w[q1[i]];
		for(int i=1;i<=hd2;i++)nw[q2[i]]+=w[q2[i]];
		Tr2::solve(val[res]);
		for(int i=1;i<=hd1;i++)nw[q1[i]]-=w[q1[i]];
		for(int i=1;i<=hd2;i++)nw[q2[i]]-=w[q2[i]];solve(st);solve(ed);
	}
}
int main()
{
	scanf("%d",&n);clg();ll va;
	for(int i=1,u,v;i<n;i++)scanf("%d%d%lld",&u,&v,&va),Tr1::Ot::add(u,v,va),Tr1::Ot::add(v,u,va);
	for(int i=1,u,v;i<n;i++)scanf("%d%d%lld",&u,&v,&va),Tr2::add(u,v,va),Tr2::add(v,u,va);
	for(int i=1,u,v;i<n;i++)scanf("%d%d%lld",&u,&v,&va),Tr3::add(u,v,va),Tr3::add(v,u,va);
	Tr3::dfs(1,0);Tr3::prest();Tr2::dfs(1,0);Tr2::prest();Tr1::Ot::cbuild();Tr1::solve(1);
	printf("%lld",ans);return 0;//拜拜程序~ 
}

```










---

## 作者：eee_hoho (赞：14)

谁说边分治能干的点分治干不了？我点分治一样过好吧。

先考虑边分治的做法，我们对第一棵树边分治，每次得到两个联通块的时候，对联通块黑白染色，考虑不同联通块跨越中心边的贡献。

设中心边端点是 $x,y$ ，对于颜色不同的两个点 $u,v$ ，我们有 $dis_1(u,x)+w(x,y)+dis_1(y,v)+dep_2(u)+dep_2(v)+2dep_2(lca(u,v))+dep_3(u)+dep_3(v)+2dep_3(lca(u,v))$ ，其中 $dep_x$ 是 $x$ 到根的权值和，$w$ 是常数，我们先拿掉，然后考虑对第二棵树建虚树，枚举 $lca$ ，对于第三棵树，我们可以用dp来求出最值。

假设现在在第二棵树上枚举到了点 $p$ ，那么 $p$ 不同子树的 $lca$ 就是 $p$ ，我们在第三棵树上每个点 $u$ 连向一个虚点，边权为 $dis(u)=dis_1(u,x)+dep_2(u)$ ，考虑在第三棵树上维护直径，维护出来颜色不同的两个点集的直径 $f_{u,0/1}$ ，然后用不同颜色的 $f$ 来更新答案，也就是 $max(f_{p,0}+f_{v,1},f_{p,1}+f_{v,0})+w(x,y)-2dep_3(lca(u,p))$ ，这里 $f$ 的加法是合并直径。

复杂度 $O(n\log^2 n)$ 。

这题之所以用边分治是因为我们每次要合并两个联通块，而点分治没法每次只分出来两个联通块。

那么我们就规定一个合并联通块的顺序，来保证复杂度。

考虑使用合并果子的方法，每次只合并两个点数最小的联通块，如果每次合并和计算的复杂度都是 $O(size_x+size_y)$ ，那么复杂度仍然是 $O(n\log n)$ 。

证明的话，我们对合并过程建哈夫曼树，一个点数为 $s$ 的联通块在哈夫曼树的深度是 $\log \frac{n}{s}$ ，那么我们写出来复杂度：

$$\begin{aligned}T(u)&=\sum_{v\in son(u)}size_v\log n-\sum_{v\in son(u)}size_v\log size_v+\sum_{v\in son(u)}T(v)\\&=size_u\log n-\sum_{v\in son(u)}size_v\log size_v+\sum_{v\in son(u)}T(v)\end{aligned}$$ 

我们会发现这样迭代下去中间的一项会两两减掉，那么就只剩了 $T(n)=\sum_{v\in son(u)}size_v\log n=n\log n$ 。

由于我写的代码又丑又长，所以我就放剪贴板了。

[边分治](https://www.luogu.com.cn/paste/e2ma45ii)

[点分治](https://www.luogu.com.cn/paste/y6olhpl8)

---

## 作者：Remake_ (赞：10)

人生第一道非恶评黑啊qwq

核心思想就是贪心（带一点随机）

考虑一个贪心，我们现在有一个根，显然我们想找到一个点使得两者间的三条路径长度之和最大。

但是由此产生了一个问题，我们并不知道答案中的根是哪个，所以我们有一个想法就是用这个新点来继承原来的根。

然后呢？然后就没了。

是的，接下来就不断迭代然后更新最大值就完事了。

需要注意到的是这个新点有可能以前已经被计算过了，会死循环，因此记录一个```vis```数组判断有没有被访问，如果被访问过了，就随机出一个没有被访问过的点。

但是关键在于我们要随机多少次呢？如何既保证正确，又保证不超时呢？我们需要一个自适应的东西。

因此我们可以使用时间函数，通过```
(double)clock()/CLOCKS_PER_SEC```来获取程序已经运行过的时间

控制它在$3.85s$内就行了

上代码qwq：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _ 0
#define timeused() (double)clock()/CLOCKS_PER_SEC
#define Set(a) memset(a,0,sizeof(a))
#define rep(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define repp(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define debug() assert(0)
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x){
    T f=1;x=0;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
    x*=f;
    return x;
}
ll rd(){ll x;rd(x);return x;}
ll n,u,v,w,nowrt=1,maxx,dep1[100005],dep2[100005],dep3[100005],ans;
bool vis[100005];
vector<pair<ll,ll> > e1[100005],e2[100005],e3[100005];
void dfs1(ll dep,ll fa){
    rep(i,0,e1[dep].size()-1){
        if(e1[dep][i].first!=fa){
            dep1[e1[dep][i].first]=dep1[dep]+e1[dep][i].second;
            dfs1(e1[dep][i].first,dep);
        }
    }
}
void dfs2(ll dep,ll fa){
    rep(i,0,e2[dep].size()-1){
        if(e2[dep][i].first!=fa){
            dep2[e2[dep][i].first]=dep2[dep]+e2[dep][i].second;
            dfs2(e2[dep][i].first,dep);
        }
    }
}
void dfs3(ll dep,ll fa){
    rep(i,0,e3[dep].size()-1){
        if(e3[dep][i].first!=fa){
            dep3[e3[dep][i].first]=dep3[dep]+e3[dep][i].second;
            dfs3(e3[dep][i].first,dep);
        }
    }
}
int main(){
    n=rd();
    rep(i,1,n-1){
        u=rd();
        v=rd();
        w=rd();
        e1[u].push_back(make_pair(v,w));
        e1[v].push_back(make_pair(u,w));
    }
    rep(i,1,n-1){
        u=rd();
        v=rd();
        w=rd();
        e2[u].push_back(make_pair(v,w));
        e2[v].push_back(make_pair(u,w));
    }
    rep(i,1,n-1){
        u=rd();
        v=rd();
        w=rd();
        e3[u].push_back(make_pair(v,w));
        e3[v].push_back(make_pair(u,w));
    }
    while(timeused()<3.85){
        while(vis[nowrt]&&timeused()<3.85) nowrt=rand()%n+1;
        vis[nowrt]=1;
        dep1[nowrt]=dep2[nowrt]=dep3[nowrt]=0;
        dfs1(nowrt,0);
        dfs2(nowrt,0);
        dfs3(nowrt,0);
        maxx=0;
        rep(i,1,n){
            if(dep1[i]+dep2[i]+dep3[i]>maxx){
                maxx=dep1[i]+dep2[i]+dep3[i];
                nowrt=i;
            }
        }
        ans=max(ans,maxx);
    }
    printf("%lld",ans);
    return ~~(0^_^0);
}
```


---

## 作者：Time_tears (赞：9)

这是一篇基于论文的题解，也做到了优秀的 $O(n\log n)$ 复杂度。

首先我们可以暴力的进行三次边分治。于是每个点获得了一个权值，代表它到三个分治中心的距离之和，而且我们知道每个点在三棵树上边分治时在哪一侧，此时可以直接统计，复杂度 $O(n \log^3 n)$。


考虑不做第三次分治，并对第三棵树做一些修改。

假设点 $x$ 在前两棵树中与分治中心的距离之和为 $d_x$，那么在第三棵树上对于每个点 $x$，新建一个点 $x'$，并在 $x$ 与 $x'$ 之间连一条权值为 $d_x$ 的边。

于是问题被转化成求“所有在前两棵树中均处于分治中心两侧的点对”在第三棵树上的最远距离。

因为两个点集的最远点对之一的两端点一定分别处于这两个点集各自的最远点对中，所以我们可以轻松解决这部分求最远距离的问题。因此，时间复杂度被降到了 $O(n \log^2n)$，足够通过，但码量巨大。


考虑在算法二的基础上，不对第二棵树进行树分治。
在对第一棵树的分治过程中，我们将点集内的点分成了两种，这两种点分别位于分治中心两侧。

设 $d_k(x)$ 表示节点 $x$ 在第 $k$ 棵树中的深度，设 $dis_k(x, y)$ 表示点对 $(x, y)$ 在第 $k$ 棵树上的
距离，设 $D(x)$ 表示节点 $x$ 在第一棵树中与当前分治中心的距离。

设点对 $(x,y)$ 在第二棵树上的最近公共祖先为 $p$，则 $x$ 与 $y$ 在三棵树中的距离之和可以写为 $D(x)+D(y)+d_2(x)+d_2(y)-2d_2(p)+dis_3(x,y)$，稍加整理得到 $(D(x)+d_2(x))+(d(y)+d_2(y))+dis_3(x,y)-2d_2(p)$，也就是说，如果固定了 $p$，剩下的问题仍然可以转化为在第三棵树上的最远点对问题。

注意到点集的最远点对是支持快速合并的，也就是说我们只需要在第二棵树中进行一次深度优先遍历，并不断将子树的点集向上合并，维护点集在第三棵树上的最远点对，计算合并时产生的新的不同种类点之间的最远点对。以这种方式合并时得到的新点对在第二棵树上的最近公共祖先是已知的，所以我们可以根据上式更新答案。

具体来说，我们只需要分别维护两个集合中的直径再在 LCA 处合并答案即可。

由于单次求点对距离的时间复杂度可以通过预处理降至 $O(1)$，且虚树复杂度瓶颈——按照 DFS 序排序部分可以在边分治处理子问题结束之后由子问题的结果向上使用归并的方式快速得到，所以我们得到了一个时间复杂度为 $O(n \log n)$ 的算法。（代码居然写到了5.97k）

```cpp
#include<bits/stdc++.h>
#define N 200005
#define ll long long
using namespace std;
int n,X,Y,Log[N],is[N];ll D[N],ans,Z;
inline ll read() {
	ll s=0,f=0;
	char ch=getchar();
	while(ch<48||ch>57)f|=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
namespace T3 {//直径 
	int h[N],cnt,to[N<<1],nx[N<<1],fp[N<<1],dep[N],in[N],tot,t2;
	ll vl[N<<1],dis3[N];
	struct node {
		int dep,x;
		node(int D=0,int X=0){dep=D,x=X;}
		bool operator<(node a) const {return dep<a.dep;}
	} rmq[20][N];
	void Addedge(int x,int y,ll z) {
		nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z;
		nx[++cnt]=h[y],to[h[y]=cnt]=x,vl[cnt]=z;
	}
	void Dfs(int x,int fa) {
		dep[x]=dep[fa]+1,fp[in[x]=++t2]=x;
		for(int i=h[x],y; i; i=nx[i])if((y=to[i])!=fa)dis3[y]=dis3[x]+vl[i],Dfs(y,x),fp[++t2]=x;
	}
	void Pre() {
		for(int i=1; i<=t2; ++i)rmq[0][i]=node(dep[fp[i]],fp[i]),Log[i]=Log[i>>1]+1;
		for(int j=1; (1<<j)<=t2; ++j)for(int i=1; i+(1<<j)<=t2+1; ++i)rmq[j][i]=min(rmq[j-1][i],rmq[j-1][i+(1<<j-1)]);
	}
	int Lca(int x,int y) {
		if(in[x]<in[y])swap(x,y);int len=Log[in[x]-in[y]+1];
		return min(rmq[len][in[y]],rmq[len][in[x]-(1<<len)+1]).x;
	}
	ll Dis(int x,int y) {return D[x]+D[y]+dis3[x]+dis3[y]-2*dis3[Lca(x,y)];}
	void Build() {for(int i=1; i<n; ++i)X=read(),Y=read(),Z=read(),Addedge(X,Y,Z);Dfs(1,0),Pre();}
}
namespace T2 {//虚树 
	int h[N],cnt,to[N<<1],nx[N<<1],dfn[N],s[N],dep[N],fp[N<<1],in[N],top,tot,t2;
	ll vl[N<<1],dis2[N];vector<int>g[N];int line[N][2][2];
	struct node {
		int dep,x;
		node(int D=0,int X=0){dep=D,x=X;}
		bool operator<(node a) const {return dep<a.dep;}
	} rmq[20][N];
	void Addedge(int x,int y,ll z) {
		nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z;
		nx[++cnt]=h[y],to[h[y]=cnt]=x,vl[cnt]=z;
	}
	void Dfs(int x,int fa) {
		dfn[x]=++tot,dep[x]=dep[fa]+1,fp[in[x]=++t2]=x;
		for(int i=h[x],y; i; i=nx[i])if((y=to[i])!=fa)dis2[y]=dis2[x]+vl[i],Dfs(y,x),fp[++t2]=x;
	}
	void Pre() {
		for(int i=1; i<=t2; ++i)rmq[0][i]=node(dep[fp[i]],fp[i]);
		for(int j=1; (1<<j)<=t2; ++j)for(int i=1; i+(1<<j)<=t2+1; ++i)rmq[j][i]=min(rmq[j-1][i],rmq[j-1][i+(1<<j-1)]);
	}
	void Build() {for(int i=1; i<n; ++i)X=read(),Y=read(),Z=read(),Addedge(X,Y,Z);Dfs(1,0),Pre();}
	int Lca(int x,int y) {
		if(in[x]<in[y])swap(x,y);int len=Log[in[x]-in[y]+1];
		return min(rmq[len][in[y]],rmq[len][in[x]-(1<<len)+1]).x;
	}
	void Check(int *a,int *b,ll x) {
		if(a[0]==-1||b[0]==-1)return;
		ans=max(ans,T3::Dis(a[0],b[0])-x),ans=max(ans,T3::Dis(a[0],b[1])-x);
		ans=max(ans,T3::Dis(a[1],b[0])-x),ans=max(ans,T3::Dis(a[1],b[1])-x);
	}
	void Merge(int *a,int *b) {
		if(a[0]==-1)a[0]=b[0],a[1]=b[1];if(b[0]==-1)return;
		int tmp[2];ll len=0,Tmp;
		if(a[0]!=a[1]&&len<(Tmp=T3::Dis(a[0],a[1])))tmp[0]=a[0],tmp[1]=a[1],len=Tmp;
		if(b[0]!=b[1]&&len<(Tmp=T3::Dis(b[0],b[1])))tmp[0]=b[0],tmp[1]=b[1],len=Tmp;
		if(len<(Tmp=T3::Dis(a[0],b[0])))tmp[0]=a[0],tmp[1]=b[0],len=Tmp;
		if(len<(Tmp=T3::Dis(a[0],b[1])))tmp[0]=a[0],tmp[1]=b[1],len=Tmp;
		if(len<(Tmp=T3::Dis(a[1],b[0])))tmp[0]=a[1],tmp[1]=b[0],len=Tmp;
		if(len<(Tmp=T3::Dis(a[1],b[1])))tmp[0]=a[1],tmp[1]=b[1],len=Tmp;a[0]=tmp[0],a[1]=tmp[1];
	}
	void Calc(int x) {
		if(D[x]+=dis2[x],~is[x])line[x][is[x]][0]=line[x][is[x]][1]=x;
		for(int y:g[x]) {
			Calc(y),Check(line[x][0],line[y][1],2*dis2[x]),Check(line[x][1],line[y][0],2*dis2[x]);
			Merge(line[x][0],line[y][0]),Merge(line[x][1],line[y][1]);
		}
	}
	void Clear(int x) {memset(line[x],-1,sizeof(line[x]));for(int y:g[x])Clear(y);is[x]=-1,g[x].clear();}
	void Solve(vector<int>&p,int lca=0) {
		s[top=1]=1;
		for(int x:p) {
			if((lca=Lca(s[top],x))==s[top])((x!=s[top])?s[++top]=x:0);
			else {
				while(dep[s[top-1]]>dep[lca])g[s[top-1]].push_back(s[top]),--top;
				if(g[lca].push_back(s[top--]),s[top]!=lca)s[++top]=lca;if(s[top]!=x)s[++top]=x;
			}
		} while(top>1)g[s[top-1]].push_back(s[top]),--top;Calc(1),Clear(1);
	}
}
namespace T1 {//边分治 
	int h[N],cnt=1,to[N<<1],nx[N<<1],gs,mn,E,siz[N],vis[N];
	ll vl[N<<1];
	struct node {
		int x;ll v;
		node(int _x=0,ll _v=0) {x=_x,v=_v;}
		bool operator!=(node a) const {return x!=a.x||v!=a.v;}
	}; vector<node>g[N];vector<int>p[N];
	bool cmp(int x,int y) {return T2::dfn[x]<T2::dfn[y];}
	void Add(int x,int y,ll z) {g[x].push_back(node(y,z)),g[y].push_back(node(x,z));}
	void Addedge(int x,int y,ll z) {
		nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z;
		nx[++cnt]=h[y],to[h[y]=cnt]=x,vl[cnt]=z;
	}
	void Rebuild(int x,int fa) {
		int las=x;
		for(auto y:g[x])if(y.x!=fa&&(Addedge(las,y.x,y.v),y!=g[x].back()))Addedge(las,++gs,0),las=gs;
		for(auto y:g[x])if(y.x!=fa)Rebuild(y.x,x);
	}
	void Build() {for(int i=1; i<n; ++i)X=read(),Y=read(),Z=read(),Add(X,Y,Z);Rebuild(1,0);}
	void Getsz(int x,int fa) {siz[x]=1;for(int i=h[x],y; i; i=nx[i])if(!vis[i>>1]&&(y=to[i])!=fa)Getsz(y,x),siz[x]+=siz[y];}
	void Gete(int x,int fa,int Sz) {
		for(int i=h[x],y,tmp; i; i=nx[i]) {
			if(vis[i>>1]||(y=to[i])==fa)continue;
			Gete(y,x,Sz);if((tmp=max(siz[y],Sz-siz[y]))<mn)mn=tmp,E=i>>1;
		}
	}
	int Getg(int x) {return mn=2e9,E=0,Getsz(x,0),Gete(x,0,siz[x]),E;}
	void Merge(int x,int y,int z) {
		int i=0,j=0,sx=p[x].size(),sy=p[y].size();
		while(i<sx||j<sy)if(j>=sy||(i<sx&&T2::dfn[p[x][i]]<T2::dfn[p[y][j]]))p[z].push_back(p[x][i++]);else p[z].push_back(p[y][j++]);
	}
	void Get(int x,int fa,int opt) {is[x]=opt;for(int i=h[x],y; i; i=nx[i])if(!vis[i>>1]&&(y=to[i])!=fa)D[y]=D[x]+vl[i],Get(y,x,opt);}
	void Divide(int g) {
		vis[g]=1;int e1,e2,x=to[g<<1],y=to[g<<1|1];
		if(e1=Getg(x))Divide(e1);if(e2=Getg(y))Divide(e2);Get(x,D[x]=0,0),D[y]=vl[g<<1],Get(y,0,1);
		if(!e1&&!e2){if(x<=n)p[g].push_back(x);if(y<=n)p[g].push_back(y);sort(p[g].begin(),p[g].end(),cmp);}
		else {if(p[0].clear(),!e1&&x<=n)p[0].push_back(x);if(!e2&&y<=n)p[0].push_back(y);Merge(e1,e2,g);}T2::Solve(p[g]),vis[g]=0;
	}
}
int main() {
	Log[0]=-1,T1::gs=n=read(),T1::Build(),T2::Build(),T3::Build();
	for(int i=1; i<=n; ++i)is[i]=-1,memset(T2::line[i],-1,sizeof(T2::line[i]));T1::Divide(T1::Getg(1)),cout<<ans;
	return 0;
}
```


---

## 作者：jun头吉吉 (赞：8)

## 题意
给定三棵树 $T1,T2,T3$，求最大化 $T1.dis(a,b)+T2.dis(a,b)+T3.dis(a,b)$

保证边权为正
## 题解
### $\mathcal{PART1}.$  欧拉序
欧拉序只是快速求 $\rm lca$ 的工具，可以做到 $\mathcal{O}(n\log n)$ 预处理与 $\mathcal{O}(1)$ 求 $\rm lca$。本题求 $\rm lca$ 的次数比较大，推荐使用 $\mathcal{O}(1)$ 的方法。

欧拉序大致是这么个意思：`dfs` 一棵树，记录每一个节点入栈的时间戳 $dfin[u]$ 与出栈的时间戳 $dfout[u]$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/oeec2syb.png)

欧拉序： $1 2 3 3 4 4 2 5 5 1$

如果查两个节点的 $\rm lca$，可以发现从 $u\to v$ 的路径上，每一个除了 $\rm lca$ 其他所有点都会在欧拉序中出现。深度最浅的点就是 $\rm lca$ 下面????的点。我们现在有一个大致思路了：用 $\rm st$ 表查询两个点欧拉序之间深度最小的点，其父节点就是我们想要查询的 $\rm lca$ 了。

不过这个非常 $\rm Naive$ 的想法会有一些 $\rm Border\ cases$，如果两个点是祖孙关系还需要特判，这里用神仙 [Rainbow_sjy](https://www.luogu.com.cn/user/151935) 在 [博客](https://www.luogu.com.cn/blog/Rainbowsjy/st-table-lca) 中使用的方法，在入栈的时候加自己，在出栈的时候加父节点，这样求 $u\to v$ （即区间 $[dfin[u],dfin[v]]$）深度最小的点就是 $\rm lca$ 了。

唯一的情况就是 $dfin[u]>dfin[v]$ 要交换 $u,v$
### $\mathcal{PART2.}$ 边分治
~~感觉边分治比点分治简单是怎么肥四？~~

边分治的思想与点分治思想类似。首先选取一条边，把路径分为两种：

- 经过当前边的路径；
- 不经过当前节点的路径。

对于第1⃣️种，可以把当前联通块分黑白染色，左边为黑，右边为白，需要计算从黑点到白点的贡献，一般可以用树形 $\rm dp$ 解决。

对于第2⃣️种，把当前联通块劈成两个联通块，对两个联通块分别重复上面的算法即可。

不难发现这样可以补充不漏地遍历所有点对。

不过这个复杂度是错的 ~~没想到吧~~，随便来个菊花图啪的一下就卡掉了。但这并不意味着边分治没有前途。事实上，通过一些黑科技是能够使复杂度正确的。首先二叉树迭代**层数**不难发现是 $\mathcal{O}(\log n)$，每层有 $n$ 个点，复杂度就是 $\mathcal{O}(n\log n)$。

现在只需要把树改成二叉树就可以做到正确的复杂度了。于是考虑添加虚点来把普通树变成二叉树，有一种神奇的方法，直观来看，就是添加一排虚点来使得除根结点外的节点度数不大于 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/vfb1jbau.png)

黑边的边权不变，蓝边为$0$

边分治的基础知识就这么多了。
### $\mathcal{PART3.}$ 虚树
大家都会虚数就我不会虚树????被吊打了:-(

虚数的思想就是给定一些点，把这些点及他们的 $\rm lca$ 建出一棵新的树。

两两的 $\rm lca$ 看上去数量是 $\mathcal{O}(m^2)$ 的，不过根据虚树的构造，是 $\mathcal{O}(m)$ 的。

虚树的构造就是维护最右边的一条链来还原 `dfs` 的过程。

先对所有要建虚数的点按照 $\rm dfs$ 序进行排序，在 $\rm dfs$ 的过程中就是这个顺序访问的。

首先如果是空的就直接加进去。

记 $z$ 为 加入点 与 栈顶 的 $\rm lca$

然后开始丧心病狂的分类讨论：

- 首先若栈中第二个节点的深度比 $z$ 深，那 栈顶必定不是最右链上的，直接连边并弹出即可。
- 如果栈顶不为 $z$ ，把 $z$ 加入栈
- 最后把要加入的点加入栈即可

 于是就可以建出虚树了。

把排序用鸡排就可以线性建虚树了。

如果了解了 $\mathcal{PART3}$ 与 $\mathcal{PART2}$，每层换一个算法，这题就迎刃而解了。

规定 $dis(a)=dis(1,a)$

首先对第一棵树进行边分治，记当前的边为 $(st,ed)$ ，我们要最大化下面这个东西：

$$ T1.dis(a,st)+T1.dis(st,ed)+T1.dis(ed,b)+T2.dis(a)+T2.dis(b)+T3.dis(a)+T3.dis(b) $$

$$-2\times T2.dis(T2.lca(a,b))-2\times T3.dis(T3.lca(a,b)) $$

$T1.dis(st,ed)$ ·是个常数不用去管它。

把 $st$ 所在的联通块是染黑，$ed$ 所在的联通块染白，我们希望找到白点 $a$ 与黑点 $b$ 最大化上面????的柿子。

对黑点和白点跑虚树，那么 $T2.lca(a,b)$ 是 $\mathcal{O}(\text{联通块大小})$ 级别的。定值拿去，再写一下：

$$ T1.dis(a,st)+T1.dis(ed,b)+T2.dis(a)+T2.dis(b)+T3.dis(a)+T3.dis(b) -2\times T3.dis(T3.lca(a,b)) $$

在 $T3$ 上连边 $a'\to a$ 的边权为 $T1.dis(a,st)+T2.dis(a)$，$b'\to b$ 的边权为 $T1.dis(ed,b)+T2.dis(b)$，于是可以写得更加简单：

$$T3.dis(a',b')$$

有一个比较显然的结论：若两个点集 $S1,S2$，$S1$ 内的最长距离为点对 $(a,b)$，$S2$ 内的点对为 $(c,d)$，那么 $S1\cup S2$ 的最大距离只能是 $(a,b),(a,c),(b,c),(b,d),(a,b),(c,d)$ 。如果联通块要求不同，把 $(a,b),(c,d)$ 去除即可。

于是就可以在虚树上 $\rm dp$ 了。记 $dp[u][0]$ 为 $T2$ $u$ 子树内黑点集合最远的点对，$dp[u][1]$ 为白点。那么根据刚才的结论我们可以 $\mathcal{O}(1)$ 合并。树形 $\rm dp$ 随便处理一下就好了。

常规的写法是 $T(n)=2T(\frac n2)+n\log n$ 即$\mathcal{O}(n\log^2n)$，鸡排+欧拉序可以做到 $T(n)=2T(\frac n2)+n$ 即 $O(n\log n)$ 。不过由于常数原因，速度差不多。

## 代码
又臭又长/kk
```cpp
#include<bits/stdc++.h>
#define mp make_pair 
namespace in{
	#ifndef slow
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	#else
	inline int getc(){return getchar();}
	#endif
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
using namespace std;
const int N=2e5+10,M=20;
int n;typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3f;
int lg[2*N];ll ans=-inf;ll ndis[N];
int type[N];//1=黑点 2=白点  0=非关键点 
int a[N],m;
namespace T3{
	vector<pair<int,ll>>e[N];
	int dep[N];ll dis[N];int f[M+1][N*2];
	int idx,dfn[N],que[N];
	void add(int u,int v,ll w){
		e[u].push_back({v,w});
		e[v].push_back({u,w});
	}
	void dfs(int u,int fa){
		dfn[u]=++idx,que[idx]=u;ndis[u]=dis[u];
		for(auto E:e[u]){
			int v=E.first;ll w=E.second;
			if(v==fa)continue;
			dep[v]=dep[u]+1;
			dis[v]=dis[u]+w;
			dfs(v,u);
			que[++idx]=u;
		}
	}
	#define cmi(a,b) (dep[(a)]<dep[(b)]?(a):(b))
	void init(){
		dfs(1,0);
		for(int i=1;i<=idx;i++)f[0][i]=que[i];
		for(int j=1;j<=M;j++)
			for(int i=1;i+(1<<j)<=idx;i++)
				f[j][i]=cmi(f[j-1][i],f[j-1][i+(1<<j-1)]);
	}
	inline int lca(int u,int v){
		if(dfn[u]>dfn[v])swap(u,v);
		u=dfn[u],v=dfn[v];
		int kk=lg[v-u+1];
		return cmi(f[kk][u],f[kk][v-(1<<kk)+1]);
	}
	ll cdis(int u,int v){
		return ndis[u]+ndis[v]-2*dis[lca(u,v)];
	}
}
namespace T2{
	vector<pair<int,ll>>e[N];vector<int>g[N];
	int dep[N];ll dis[N];int f[M+1][N*2];
	int idx,dfn[N],que[N];
	int sta[N],tp;
	void add(int u,int v,ll w){
		e[u].push_back({v,w});
		e[v].push_back({u,w});
	}
	void dfs(int u,int fa){
		dfn[u]=++idx,que[idx]=u;
		for(auto E:e[u]){
			int v=E.first;ll w=E.second;
			if(v==fa)continue;
			dep[v]=dep[u]+1;
			dis[v]=dis[u]+w;
			dfs(v,u);
			que[++idx]=u;
		}
	}
	void init(){
		dfs(1,0);
		for(int i=1;i<=idx;i++)f[0][i]=que[i];
		for(int j=1;j<=M;j++)
			for(int i=1;i+(1<<j)<=idx;i++)
				f[j][i]=cmi(f[j-1][i],f[j-1][i+(1<<j-1)]);
	}
	inline int lca(int u,int v){
		if(dfn[u]>dfn[v])swap(u,v);
		u=dfn[u],v=dfn[v];
		int kk=lg[v-u+1];
		return cmi(f[kk][u],f[kk][v-(1<<kk)+1]);
	}
	#define node pair<ll,pair<int,int>>
	#define cd T3::cdis
	#define u second.first
	#define v second.second
	node merge(node a,node b){
		if(a.first==-1)return b;
		if(b.first==-1)return a;
		//如果 最长距离 等于-1说明不存在路径
		node res=max(a,b);
		res=max(res,mp(cd(a.u,b.u),mp(a.u,b.u)));
		res=max(res,mp(cd(a.u,b.v),mp(a.u,b.v)));
		res=max(res,mp(cd(a.v,b.u),mp(a.v,b.u)));
		res=max(res,mp(cd(a.v,b.v),mp(a.v,b.v)));
		return res;
	}
	ll mxdis(node a,node b){
		if(a.first==-1||b.first==-1)return -inf;
		ll res=-inf;
		res=max(res,cd(a.u,b.u));
		res=max(res,cd(a.u,b.v));
		res=max(res,cd(a.v,b.u));
		res=max(res,cd(a.v,b.v));
		return res;
	}
	#undef u
	#undef v
	node dp[N][2];
	int b[N],s[256],s1[256],s2[256],s3[256];
	void mysort(){
		//将 arr 升序排序
		memset(s,0,sizeof s);
		memset(s1,0,sizeof s1);
		memset(s2,0,sizeof s2);
		memset(s3,0,sizeof s3);
		for(int i=1;i<=m;i++)
			++s[a[i]&255],
			++s1[(a[i]>>8)&255],
			++s2[(a[i]>>16)&255],
			++s3[a[i]>>24];
		for(int i=1;i<=255;i++)s[i]+=s[i-1],s1[i]+=s1[i-1],s2[i]+=s2[i-1],s3[i]+=s3[i-1];
		for(int i=m;i;i--)
			b[s[a[i]&255]--]=a[i];
		for(int i=m;i;i--)
			a[s1[(b[i]>>8)&255]--]=b[i];
		for(int i=m;i;i--)
			b[s2[(a[i]>>16)&255]--]=a[i];
		for(int i=m;i;i--)
			a[s3[b[i]>>24]--]=b[i];
	}
	inline void ins(int x){
		if(!tp)return sta[tp=1]=x,(void)0;
		int z=lca(sta[tp],x);
		while(tp>1&&dep[sta[tp-1]]>dep[z])
			g[sta[tp-1]].push_back(sta[tp]),tp--;
		if(dep[sta[tp]]>dep[z])g[z].push_back(sta[tp--]);
		if(!tp||sta[tp]!=z)sta[++tp]=z;
		sta[++tp]=x;
	}
	void build(){
		//建虚树 
		#define fast
		#ifdef fast 
		for(int i=1;i<=m;i++)
			a[i]=dfn[a[i]];
		mysort();
		//sort(a+1,a+1+m);
		for(int i=1;i<=m;i++)a[i]=que[a[i]];
		#else
		sort(a+1,a+1+m,[](const int x,const int y)->bool{return dfn[x]<dfn[y];});
		#endif 
		if(a[1]!=1)sta[tp=1]=1;
		for(int i=1;i<=m;i++)ins(a[i]);
		if(tp)while(--tp)g[sta[tp]].push_back(sta[tp+1]);
	}
	ll ans;
	void DP(int u){
		if(type[u]==1)dp[u][0]=mp(0,mp(u,u)),dp[u][1]=mp(-1,mp(0,0));
		else if(type[u]==2)dp[u][1]=mp(0,mp(u,u)),dp[u][0]=mp(-1,mp(0,0));
		else dp[u][0]=mp(-1,mp(0,0)),dp[u][1]=mp(-1,mp(0,0));
		for(auto v:g[u]){
			DP(v);
			ans=max(ans,mxdis(dp[u][0],dp[v][1])-2*dis[u]);
			ans=max(ans,mxdis(dp[u][1],dp[v][0])-2*dis[u]);
			dp[u][0]=merge(dp[u][0],dp[v][0]);
			dp[u][1]=merge(dp[u][1],dp[v][1]);
		}
		g[u].clear();type[u]=0;
	}
	ll calc(){
		build();
		ans=-inf;
		DP(1);
		return ans;
	}
	#undef node
	ll cdis(int u,int v){
		return dis[u]+dis[v]-2*dis[lca(u,v)];
	}
}
//第一棵树上进行边分治，因此不能用vector存边，要双向删边 
namespace T1{
	struct node{
		int v;ll w;int nxt;bool cut;
		node(int v=0,ll w=0,int nxt=0):v(v),w(w),nxt(nxt),cut(false){}
	}e[N*4];
	int head[N],cnt=1;ll w[N];int sz[N*2];
	pair<int,int>res;
	void add(int u,int v,ll w){
		//printf("%d %d %lld\n",u,v,w); 
		e[++cnt]=node(v,w,head[u]);head[u]=cnt;
		e[++cnt]=node(u,w,head[v]);head[v]=cnt;
	}
	namespace To_Binary{
		int ctt=0,now[N];
		vector<pair<int,ll>>e[N];
		void add(int u,int v,ll w){
			e[u].push_back(mp(v,w));
			e[v].push_back(mp(u,w));
		}
		void ins(int u,int v,ll w){
			++ctt;
			T1::add(ctt,v,w);
			T1::add(now[u],ctt,0);
			now[u]=ctt;
		}
		void build(int u,int fa){
			//printf("%d %d\n",u,fa);
			for(auto Edge:e[u]){
				int v=Edge.first;ll w=Edge.second;
				if(v==fa)continue;
				ins(u,v,w),build(v,u);
			}
		}
	}
	void init(){
		for(int i=1;i<=n;i++)
			To_Binary::now[i]=i;
		To_Binary::ctt=n;
		To_Binary::build(1,0);
	}
	int dfs1(int u,int fa){
		sz[u]=1;
		for(int i=head[u];i;i=e[i].nxt)
			if(e[i].v!=fa&&!e[i].cut)
				sz[u]+=dfs1(e[i].v,u);
		return sz[u];
	}
	void find(int u,int fa,int tot){
		for(int i=head[u];i;i=e[i].nxt)
			if(e[i].v!=fa&&!e[i].cut){
				int v=e[i].v;
				res=min(res,mp(max(sz[v],tot-sz[v]),i));
				find(v,u,tot);
			}
	}
	void get(int u,int fa,const int&col){
		if(u<=n)type[u]=col,a[++m]=u;
		for(int i=head[u];i;i=e[i].nxt)
			if(e[i].v!=fa&&!e[i].cut){
				int v=e[i].v;ll w=e[i].w;
				T1::w[v]=T1::w[u]+w;
				get(v,u,col);
			}
	}
	ll calc(){
		ll res=0;
		for(int i=1;i<=m;i++)
			for(int j=1;j<=m;j++)
				if(type[a[i]]==1&&type[a[j]]==2)
					res=max(res,w[a[i]]+w[a[j]]+T2::cdis(a[i],a[j])+T3::cdis(a[i],a[j]));
		for(int i=1;i<=m;i++)type[a[i]]=0;
		return res; 
	}
	void solve(int u){
		dfs1(u,0);if(sz[u]==1)return;
		res=mp(inf,0);find(u,0,sz[u]);
		int st=e[res.second].v;e[res.second].cut=true;
		int ed=e[res.second^1].v;e[res.second^1].cut=true;
		m=0;w[st]=w[ed]=0;get(st,0,1);get(ed,0,2);
		for(int i=1;i<=m;i++)ndis[a[i]]+=w[a[i]]+T2::dis[a[i]];
		ans=max(ans,e[res.second].w+T2::calc());
		for(int i=1;i<=m;i++)ndis[a[i]]-=w[a[i]]+T2::dis[a[i]];
		//ans=max(ans,calc()+e[res.second].w);
		solve(st);solve(ed);
	}
} 
namespace SJY{
	namespace AK{
		void ZJOI(){
			for(int i=2;i<2*N;i++)lg[i]=lg[i>>1]+1;
			in::read(n);
			int u,v;ll w;
			for(int i=1;i<n;i++)in::read(u,v,w),T3::add(u,v,w);T3::init();
			for(int i=1;i<n;i++)in::read(u,v,w),T2::add(u,v,w);T2::init();
			for(int i=1;i<n;i++)in::read(u,v,w),T1::To_Binary::add(u,v,w);T1::init();			
		}
		void NOI(){
			T1::solve(1);
		}
		void IOI(){
			out::write(ans);
			out::flush();
		}
	}
}
signed main(){
	//freopen("0.5.in","r",stdin);
	SJY::AK::ZJOI();
	SJY::AK::NOI();
	SJY::AK::IOI();
	
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：8)

一道十分经典的模板题，考虑使用随机化贪心。事实上，这种做法在考场上有助于我们在短时间内避开大码力，得到更多的分。

首先，对于一个节点，通过广搜（减少常数，不用深搜）查找在三棵树上和自己距离和最大的节点，很明显该节点的答案一定不会低于自己。于是，我们得到了一种方案：不断寻找与自己在三棵树上总距离最大的节点，并跳到那个节点上。

但这样很容易陷入一个局部最优解，于是要采用随机化：每次随机选取一个节点，从它出发走十次，记录每次的最大值，可以得到答案：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=2e5+5;
static inline char gc(){
    static char buf[M+5];
    static int it,ed;
    if(it==ed)ed=(it=0)+fread(buf,1,M,stdin);
    return it==ed?EOF:buf[it++];
}
typedef long long ll;
static inline ll read(){
    static ll x,f;static char c;
    for(f=1,c=gc();c<48;c=gc())if(c=='-')f=-f;
    for(x=0;c>47;x=x*10+(48^c),c=gc());return x*f;
}
int ed[M],n,rt,a[N];
ll d[N],ans,now;
bitset<N>vs;
struct Tree{
	int ed[M],cnt,fa[N];ll w[M],dep[N];
	vector<int>lk[N];
	inline void AG(){
		++cnt;lk[ed[cnt]=read()].push_back(cnt+1);
		lk[ed[cnt+1]=read()].push_back(cnt);
		w[cnt]=w[cnt+1]=read();++cnt;
	}
	void bfs(int x){
		static int q[N],l,r,y;
		q[l=r=1]=x;for(y=1;y<=n;++y)dep[y]=fa[y]=0;
		while(l<=r){
			x=q[l++],d[x]+=dep[x];
			for(int i:lk[x])
				if((y=ed[i])!=fa[x])
					dep[y]=dep[x]+w[i],fa[q[++r]=y]=x;
		}
	}
}tr[3];
int main(){
	n=read();int i,x,y,z,endtime=3.8*CLOCKS_PER_SEC;
	for(x=1;x<=n;++x)a[x]=x;
	random_device rd;
	mt19937_64 rg(rd());
	shuffle(a+1,a+n+1,rg);
	for(x=0;x<3;++x)
		for(i=1;i<n;++i)
			tr[x].AG();
	while(i<=n&&clock()<endtime){
		x=a[i];
		for(i=1;i<=10;++i){
			for(z=1;z<=n;++z)d[z]=0;
			tr[0].bfs(x),tr[1].bfs(x);
			tr[2].bfs(x),vs[x]=1;
			for(y=0,z=1;z<=n;++z)
				if(d[z]>d[y])y=z;
			if(d[y]>ans)ans=d[y];
			if(vs[y])break;
			else x=y;
		}while(vs[a[i]])++i;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：cjy2003 (赞：7)

题意:	
给定三棵带权树,求max(dis1(a,b)+dis2(a,b)+dis3(a,b))	
n<=100000	
分析:	
遇到这样的问题,首先想到的是分治	
点分治行不行呢?	
这个题求的是max,所以不能通过算出整体的,再算出部分的减掉	
而做完一棵子树再做另一棵似乎很困难(涉及到了后面的树)	
如果是两棵树,那么可以通过在第一棵树上点分治,将不同子树的点打上不同的标记,然后在第二棵树上建虚树dfs,每个点保留两个标记不同的最大值即可	
对于三棵树,只点分治一次是不可行的,一种可行的方法是在第一棵树上点分治,打上标记,然后在第二棵树上建出虚树,在虚树上点分治,打上标记,然后在第三棵树上建虚树dfs,每个点保留三个标记不同的最大值	
这样的做法是3个log的(点分治两个,建虚树时的排序一个)(~~有谁愿意写呢~~)	
这样做法的瓶颈在于子树个数较多,标记多,不好处理	
所以想到了边分治,每次只有两个子树,比较容易处理	
dis$_1i$表示的是i到第一棵树中分治边固定一端的距离	
dis$_2i$表示的是i到第二棵树根的距离	
dis$_3(i,j)$表示的是i,j在第三棵树上的距离	
则要求的是max(dis$_1a$+dis$_1b$+dis$_2a$+dis$_2b$-2*dis$_2lca(a,b)$+dis$_3(a,b)$)(其中a,b在边分治的不同子树中)	
在第二棵树上dfs的时候,dis$_2lca(a,b)$是一定的,先不考虑	
将第三棵树上每个点的初始距离设置为dis$_1a$+dis$_2a$	
则要求的就是第三棵树上的最长路,同时支持点集合并	
有这样一个结论:	
对于两个不相交的点集,设它们中的最长路两端点分别为($x_1$,$y_1$),($x_2$,$y_2$)他们的并的最长路一定是($x_1$,$y_1$),($x_2$,$y_2$),($x_1$,$x_2$),($x_1$,$y_2$),($x_2$,$y_1$),($y_1$,$y_2$)中的一个	
证明:反证一下显然	
这就方便了dfs时的快速转移和快速更新答案	
同时,边分治的好处就在这里体现,转移和更新答案时复杂度是O(子树个数)和O(子树个数^2),点分治就做不了了
于是总复杂度O(nlog$^{2}$n)	
这个题关键在于那个结论和边分治的特殊性质共同保证了复杂度	
注意事项:	
虚树构建时当lca和栈顶的下一个元素一样时也要弹掉栈顶	
数组开够...	
代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const long long inf=1e17;
int n,lg[200020],id[200020],c[200020],cnt,z[200020],zz;
long long ans,dis1[200020];
bool bjd[200020];
void init()
{
    for(int i=2;i<=200000;++i)
        lg[i]=lg[i/2]+1;
}
struct tree23
{
    int to[200020],nxt[200020],head[100010],num=0;
    int st[19][200020],dfnum=0,p[100010],depth[100010];
    long long va[200020],dis[100010];
    void add(int x,int y,long long w)
    {
        nxt[++num]=head[x];
        head[x]=num;
        to[num]=y;
        va[num]=w;
    }
    void dfs(int v,int fa)
    {
        int u;
        p[v]=++dfnum;st[0][dfnum]=v;
        for(int i=head[v];i;i=nxt[i])
        {
            u=to[i];
            if(u==fa)continue;
            depth[u]=depth[v]+1,dis[u]=dis[v]+va[i];
            dfs(u,v);
            st[0][++dfnum]=v;
        }
    }
    void buildst()
    {
        for(int i=1;i<=18;++i)
            for(int j=1;j<=dfnum-(1<<i)+1;++j)
                st[i][j]=depth[st[i-1][j]]<depth[st[i-1][j+(1<<i-1)]]?st[i-1][j]:st[i-1][j+(1<<i-1)];
    }
    int qlca(int x,int y)
    {
        x=p[x],y=p[y];
        if(x>y)swap(x,y);
        int len=lg[y-x+1];
        return depth[st[len][x]]<depth[st[len][y-(1<<len)+1]]?st[len][x]:st[len][y-(1<<len)+1];
    }
    long long qdis(int x,int y)
    {
        int l=qlca(x,y);
        return dis[x]+dis[y]-2*dis[l];
    }
}t2,t3;
long long calc(int x,int y)
{
    if(!x||!y)return 0;
    return dis1[x]+dis1[y]+t2.dis[x]+t2.dis[y]+t3.qdis(x,y);
}
struct data
{
    long long dis;
    int x,y;
    data(){x=0,y=0,dis=0;}
    data(const int &xx,const int &yy){x=xx,y=yy,dis=calc(x,y);}
    data(const int &xx,const int &yy,const long long &dd){x=xx,y=yy,dis=dd;}
    friend bool operator < (const data&a,const data&b)
    {
        return a.dis<b.dis;
    }
    friend data operator + (const data&a,const data&b)
    {
        if(!b.x)return a;
        if(!a.x)return b;
        data res=max(a,b);
        res=max(res,max(data(a.x,b.x),data(a.y,b.y)));
        res=max(res,max(data(a.x,b.y),data(a.y,b.x)));
        return res;
    }
}dp[200020][2];
void upd(int x,int y)
{
    ans=max(ans,calc(dp[x][0].x,dp[y][1].x)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][0].x,dp[y][1].y)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][0].y,dp[y][1].x)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][0].y,dp[y][1].y)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][1].x,dp[y][0].x)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][1].x,dp[y][0].y)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][1].y,dp[y][0].x)-(t2.dis[x]<<1));
    ans=max(ans,calc(dp[x][1].y,dp[y][0].y)-(t2.dis[x]<<1));
    dp[x][0]=dp[x][0]+dp[y][0];
    dp[x][1]=dp[x][1]+dp[y][1];
}
bool cmp(int x,int y)
{
    return t2.p[x]<t2.p[y];
}
void build()
{
    sort(c+1,c+1+cnt,cmp);
    for(int i=1;i<=cnt;++i)
        bjd[c[i]]=1;
    int zzz=cnt;
    zz=0;
    for(int i=1;i<=cnt;++i)
    {
        dp[c[i]][id[c[i]]]=data(c[i],c[i],0);
        dp[c[i]][id[c[i]]^1]=data();
        int l=t2.qlca(c[i],z[zz]);
        if(!bjd[l])c[++zzz]=l,bjd[l]=1,dp[l][0]=data(),dp[l][1]=data();
        while(t2.p[l]<t2.p[z[zz]])
        {
            if(t2.p[l]<=t2.p[z[zz-1]])
            {
                upd(z[zz-1],z[zz]);
                --zz;
            }
            else
            {
                upd(l,z[zz]);
                z[zz]=l;
                break;
            }
        }
        z[++zz]=c[i];
    }
    while(zz>1)
    {
        upd(z[zz-1],z[zz]);
        --zz;
    }
    for(int i=1;i<=zzz;++i)
        bjd[c[i]]=0;
}
struct tree1
{
    vector<pair<int,long long> >son[100010];
    int to[400040],nxt[400040],head[200020],num=1,tot,maxs,all,siz[200020],zb;
    long long va[400040];
    bool bjb[400040];
    void add(int x,int y,long long w)
    {
        nxt[++num]=head[x];
        head[x]=num;
        to[num]=y;
        va[num]=w;
    }
    void dfs(int v,int fa)
    {
        int last=v;
        for(auto u:son[v])
        {
            if(u.first==fa)continue;
            ++tot;
            add(last,tot,0);
            add(tot,last,0);
            add(tot,u.first,u.second);
            add(u.first,tot,u.second);
            last=tot;
        }
        for(auto u:son[v])
        {
            if(u.first==fa)continue;
            dfs(u.first,v);
        }
    }
    void getrt(int v,int fa)
    {
        int u;siz[v]=v<=n;
        for(int i=head[v];i;i=nxt[i])
            if(!bjb[i])
            {
                u=to[i];
                if(u==fa)continue;
                getrt(u,v);
                siz[v]+=siz[u];
                if(max(siz[u],all-siz[u])<maxs)
                {
                    maxs=max(siz[u],all-siz[u]);
                    zb=i;
                }
            }
    }
    void getdata(int v,int fa,int opt)
    {
        id[v]=opt;
        if(v<=n)c[++cnt]=v;
        siz[v]=v<=n;
        int u;
        for(int i=head[v];i;i=nxt[i])
            if(!bjb[i])
            {
                u=to[i];
                if(u==fa)continue;
                dis1[u]=dis1[v]+va[i];
                getdata(u,v,opt);
                siz[v]+=siz[u];
            }
    }
    void solve()
    {
        bjb[zb]=bjb[zb^1]=1;
        int x=to[zb],y=to[zb^1];
    //	printf("%d %d\n",x,y);
        cnt=0;
        dis1[x]=0,dis1[y]=va[zb];
        getdata(x,0,0);
        getdata(y,0,1);
        if(siz[x]&&siz[y])build();
/*		for(int i=1;i<=tot;++i)
            printf("%d ",siz[i]);
        printf("\n");
        for(int i=2;i<=num;++i)
            printf("%d ",bjb[i]);
        printf("\n%d %d %d %d\n",x,y,siz[x],siz[y]);*/
        if(siz[x])
        {
            maxs=0x7fffffff;all=siz[x];
            getrt(x,0);
            if(maxs!=0x7fffffff)solve();
        }
        if(siz[y])
        {
            maxs=0x7fffffff;all=siz[y];
            getrt(y,0);
            if(maxs!=0x7fffffff)solve();	
        }
    }
}t1;
int main()
{
//	freopen("4220.in","r",stdin);
//	freopen("4220.out","w",stdout);
    init();
    scanf("%d",&n);t1.tot=t1.all=n;
    int x,y;
    long long w;
    for(int i=1;i<n;++i)
    {
        scanf("%d %d %lld",&x,&y,&w);
        t1.son[x].push_back(make_pair(y,w));
        t1.son[y].push_back(make_pair(x,w)); 
    }
//	printf("!\n");
    for(int i=1;i<n;++i)
    {
        scanf("%d %d %lld",&x,&y,&w);
        t2.add(x,y,w);
        t2.add(y,x,w);
    }
//	printf("!\n");
    t2.dfs(1,0),t2.buildst();
//	printf("!\n");
    for(int i=1;i<n;++i)
    {
        scanf("%d %d %lld",&x,&y,&w);
        t3.add(x,y,w);
        t3.add(y,x,w);
    }
    t3.dfs(1,0),t3.buildst();
    t1.dfs(1,0);
    t1.maxs=0x7fffffff;
    t1.getrt(1,0);
//	printf("!\n");
    t1.solve();
    printf("%lld",ans);
//	for(int i=1;i<=n;++i)
//		printf("%d ",bjd[i]);
    return 0;
}
```


---

## 作者：hhoppitree (赞：4)

### 题意简述

> - 给定三棵点集均为 $\{1,2,\cdots,n\}$ 的树 $T_{1},T_{2},T_{3}$，求 $\max\limits_{1\le i<j\le n}(dis_{1}(i,j)+dis_{2}(i,j)+dis_{3}(i,j))$。
>
> - $n\le10^5$。

### 题目做法


不会正解怎么办？乱搞！

先随机一个根，将无根树转化为有根树，再考虑 $dis(x,y)=dep(x)+dep(y)-2dep({\rm LCA}(x,y))$，发现 $2dep({\rm LCA}(x,y))$ 不好处理，于是考虑按照 $dep_{1}(x)+dep_{2}(x)+dep_{3}(x)$ 排序，选前若干个与剩下点一一匹配。

发现这样正确率并不高，考虑对于任意的 $c_1,c_2,c_3\in\{0,1,2,3\}(\gcd(c_1,c_2,c_3)=1)$，取点 $x$ 的权值为 $c_1dep_{1}(x)+c_2dep_{2}(x)+c_3dep_{3}(x)$，按照权值排序，每次取前 $30$ 个即可，注意不要重复对一个点进行遍历计算。

时间复杂度 $\mathcal{O}(n\log n+Tn)$，其中 $T$ 为一常数，正确率 $\mathcal{O}(\text{能过})$。

### 参考代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;

int n;
vector< pair<int, long long> > G[3][N];
long long s[3][N], st[3][20][N << 1];
int euler[3][N << 1], dfn[3][N], cnt, lg2[N << 1];

void dfs(int wh, int x, int fa = -1)
{
	euler[wh][++cnt] = x;
	dfn[wh][x] = cnt;
	st[wh][0][cnt] = s[wh][x];
	for (int i = 0; i < G[wh][x].size(); ++i) {
		int v = G[wh][x][i].first;
		if (v == fa) {
			continue;
		}
		s[wh][v] = s[wh][x] + G[wh][x][i].second;
		dfs(wh, v, x);
		euler[wh][++cnt] = x;
		st[wh][0][cnt] = s[wh][x];
	}
	return;
}

long long dis(int wh, int x, int y)
{
	long long _s = s[wh][x] + s[wh][y];
	x = dfn[wh][x], y = dfn[wh][y];
	if (x > y) {
		swap(x, y);
	}
	int k = lg2[y - x + 1];
	long long mn = min(st[wh][k][x], st[wh][k][y - (1 << k) + 1]);
	return _s - mn - mn;
}

long long check(int x)
{
	long long res = 0;
	for (int i = 1; i <= n; ++i) {
		res = max(res, dis(0, x, i) + dis(1, x, i) + dis(2, x, i));
	}
	return res;
}

struct op
{
	long long val;
	int id;
} p[N];

int cmp(op x, op y)
{
	return x.val > y.val;
}

int vis[N];

signed main()
{
	int rt;
	scanf("%d", &n);
	rt = min(n / 2 + 5, n);
	lg2[0] = -1;
	for (int i = 1; i <= n + n; ++i) {
		lg2[i] = lg2[i >> 1] + 1;
	}
	for (int i = 0; i < 3; ++i) {
		for (int j = 1; j < n; ++j) {
			int x, y;
			long long v;
			scanf("%d%d%lld", &x, &y, &v);
			G[i][x].push_back(make_pair(y, v));
			G[i][y].push_back(make_pair(x, v));
		}
		cnt = 0;
		dfs(i, rt);
		for (int j = 1; (1 << j) <= cnt; ++j) {
			for (int k = 1; k + (1 << j) - 1 <= cnt; ++k) {
				st[i][j][k] = min(st[i][j - 1][k], st[i][j - 1][k + (1 << (j - 1))]);
			}
		}
	}
	long long A = 0;
	for (int a = 0; a < 4; ++a) {
		for (int b = 0; b < 4; ++b) {
			for (int c = 0; c < 4; ++c) {
				if ((!a && !b && !c) || __gcd(__gcd(a, b), c) != 1) {
					continue;
				}
				for (int i = 1; i <= n; ++i) {
					p[i].val = a * s[0][i] + b * s[1][i] + c * s[2][i];
					p[i].id = i;
				}
				sort(p + 1, p + n + 1, cmp);
				for (int i = 1; i <= min(n, 30); ++i) {
					if (!vis[p[i].id]) {
						A = max(A, check(p[i].id));
						vis[p[i].id] = 1;
					}
				}
			}
		}
	}
	printf("%lld\n", A);
	return 0;
}
```

---

## 作者：YLWang (赞：3)

### 题意简述

给定三棵树 $T_1$ $-$ $T_3$。求 $\max\{\text{dist}_1(a, b) + \text{dist}_2(a, b) + \text{dist}_3(a, b)\}$。


### 题解

~~有迭代，快去找 zzq~~

我们考虑多棵树上问题和高维偏序的问题其实很类似，都是一步步降维的过程。

这道题的话我们首先对 $T_1$ 边分。边分的好处就在于最多只有两个子树，方便之后的统计。

我们设当前边分的边为 $(st, ed, w)$，选取的两个点为 $(x, y)$，$\operatorname{lca_i}(x, y) = l_i$。

则有

$$
\begin{aligned}
\text{Ans} &= \max\{\text{dist}_1(x, st) + \text{dist}_1(ed, v) + w + \text{dist}_2(x, y) + \text{dist}_3(x, y)\} \\

\end{aligned}
$$

定义 $W(x) = \text{dist}_1(x, st) + \text{dep}_2(x) + \text{dep}_3(x)$

那么

$$
\begin{aligned}
\text{Ans} &= \max\{W(x) + W(y) - 2 \cdot \text{dep}_2(l_2) - 2 \cdot \text{dep}_3(l_3)\} \\

\end{aligned}
$$

nice，现在已经处理完了第一棵树。我们在第二棵树里把两边的点分别当做黑点和白点拉出来建个虚树。

然后我们枚举 $l_2$。在 $l_2$ 的子树中寻找两个点 $x, y$ 使得 $W(x) + W(y) - 2 \cdot \text{dep}_3(l_3)$ 最大。

很好，这玩意看起来很不可做。但是他看起来很符合直径这个东西的性质哇。

事实上，通过反证可以轻易证得其合并符合直径合并的性质。至于原因可以去看 shadowice1984 的题解，非常清晰明了。

于是做个子树合并，写就行了。


---

## 作者：Sai0511 (赞：2)

题意：  
给定三棵树 $T_1,T_2,T_3$，让你最大化 $dis_{T1}(u,v)+dis_{T2}(u,v)+dis_{T3}(u,v)$     
(记 $dis_{Tx}(a,b)$ 表示第 $x$ 颗树中 $a \sim b$ 的距离，$dep_{Tx}(a)$ 表示第 $x$ 颗树上 $a$ 的带权深度, $lca_{Tx}(a,b)$ 表示第 $x$ 颗树上 $a,b$ 的 $lca$)。    
我们对 $T_1$ 进行边分治，不妨设中心边为 $(p,q)$，则一条路径 $(u,v)$ 经过 $(p,q)$ 的条件为切掉中心边后 $u$ 与 $v$ 所在联通块互异。    
所以我们可以切掉中心边后进行染色，把 $p$ 点所在的联通块染成白色，把 $q$ 点所在的联通块染成黑色。  
把式子拆一下：
$$dis_{T1}(u,p)+dis_{T1}(p,q)+dis_{T1}(q,v)+dis_{T2}(u,v)+dis_{T3}(u,v)$$
其中 $dis_{T1}(p,q)$ 为定值，可以先忽略。并且 $u,v$ 异色。    
再拆一下：  
$$dis_{T1}(u,p)+dis_{T1}(p,q)+dep_{T2}(u)+dep_{T2}(v)-2 \times dep_{T2}(lca_{T2}(u,v))+dis_{T3}(u,v)$$     
思索一下一个重要的性质，那就是分出的黑白点都是点的集合，是点的集合就可以跑虚树。   
虚树上 $\text{dfs}$ 时，$lca$ 是一定的，所以我们把树上每个点 $u$ 的初始距离设置为 $u$ 到分治点的距离（就是 $p,q$）与 $dep_{T2}(u)$ 之和，那么问题就转化为了求 $T_3$ 上的最长路。    
我们记 $dp(u,0)$ 表示 $u$ 子树内的白点的最长路端点，$dp(u,1)$ 表示 $u$ 子树内的黑点的最长路端点。   
则有一个结论是，若一个点集 $P_1$ 的最长路端点为 $A,B$，一个点集 $P_2$ 的最长路端点为 $C,D$，  
则 $P_1 \bigcup P_2$ 的最长路端点一定为 $A,B,C,D$ 的一种组合，有 $\binom{4}{2} = 6$ 种情况。  
这是因为如果不是由 $A,B,C,D$ 组成的，那么一定会多出来一段距离连接某一个端点。   
然后这题就做完了。  
复杂度为 $\mathcal{O}(n \log^2 n)$。  
操作虚树时只要根据栈存的父子关系就可以进行 $\text{dp}$ 转移了，无需特意把虚树建出来。    
还需要一些高效的 $lca$ 技巧比如 $\mathcal{O}(nlogn)$ 预处理 $\mathcal{O}(1)$ 查询的 $st$ 表加欧拉序。     

---

## 作者：yijan (赞：2)

为了更好的阅读体验建议到 luogu 博客或者 [这里](https://www.yijan.co/p4220-wc2018tong-dao/) 阅读。

一眼看上去和 暴力写挂 类似，可是从两棵树变成了三棵树了。

看起来，暴力写挂好像两棵树是极限了，但是这题它满足 $w$ 非负，所以直径是可以合并的。

还是考虑第一棵树上边分，化下式子成为
$$
di s(rt,u) + dis(rt,v) + dep_2[u]+dep_2[v]-2dep_2[lca_2(u,v)]+dis_2(a,b)
$$
于是还是考虑根据边分把两边分成两种颜色，然后在第二棵树上建立虚树来 $dp$ 。然后考虑怎么维护当前子树内不同颜色的点在第三棵树上的直径长度加上 $dis(rt,u) + dis(rt,v) + dep_2[u] + dep_2[v]$。这个后面的权值我们加虚点挂在第三棵树每个节点的下面，于是变成了一个不同的求不同颜色的点的直径问题。但是直接维护这个不同颜色的直径端点明显是有问题的，我们可以考虑维护出两种颜色分别的点集的直径端点，这样就会很方便合并。这样做的复杂度是 $O(n\log^2n)$ 或者 $O(n\log n)$ 。

能否类似 “暴力写挂” 一题的思路优化到 $O(n\log n)$ 呢？

我们考虑当前式子长成这样：
$$
dis(rt,u) + dis(rt,v) + dep_2[u] + dep_2[v] - 2dep[lca( u , v )] + dis_3(u,v)
$$
在第一棵树上建立边分树，维护当前边分点两个儿子分别在第三棵树上添加关于当前边分中心所加的虚点后的直径，也就是添加了权值为 $dep_2[u] + dep_2[v] + dis(rt,u) + dis(rt,v)$ 的虚点后的直径。可以发现我们实际上没有必要把虚点给真正添加出来，因为我们求答案的时候是在第二棵树上进行边分树合并，合并的时候只需要判断四对点距离大小关系就好了。而初始化的时候由于只有一个点，是非常好初始化的。。所以我们直接合并边分树就做完了。

~~然后因为一个符号写反调了好久好久好久好久~~

暂时是 LOJ rank 4。。（不会卡常）

```cpp
#include "iostream"
#include "algorithm"
#include "cstring"
#include "cstdio"
#include "cmath"
#include "vector"
#include "map"
#include "set"
#include "queue"
using namespace std;
#define MAXN 800006
//#define int long long
#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)
#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector<int>
#define all(x) (x).begin() , (x).end()
#define mem( a ) memset( a , 0 , sizeof a )
#define min( a , b ) ( (a) < (b) ? (a) : (b) )
#define max( a , b ) ( (a) > (b) ? (a) : (b) )
#define P 998244353
typedef long long ll;

#define inf 0x3f3f3f3f3f3f3f3f
#define lg2( x ) ( 31 - __builtin_clz( x ) )
#define swap( a , b ) ( a ^= b , b ^= a , a ^= b )
int n , N;

ll res = -inf;

inline void rd( int& x ) {
    char ch = ' '; x = 0;
    while( ch > '9' || ch < '0' ) ch = getchar( );
    while( ch >= '0' && ch <= '9' ) x = 10 * x + ch - '0' , ch = getchar();
}
inline void rd( ll& x ) {
    char ch = ' '; x = 0;
    while( ch > '9' || ch < '0' ) ch = getchar( );
    while( ch >= '0' && ch <= '9' ) x = 10 * x + ch - '0' , ch = getchar();
}

int head[MAXN] , to[MAXN << 1] , nex[MAXN << 1] , ecn = -1;
ll wto[MAXN << 1];
void ade( int u , int v , ll w ) {
//    cout << u << ' ' << v << ' ' << w << endl;
    to[++ ecn] = v , nex[ecn] = head[u] , wto[ecn] = w , head[u] = ecn;
    to[++ ecn] = u , nex[ecn] = head[v] , wto[ecn] = w , head[v] = ecn;
}

/*
 * PreworkS:
 * - First Tree:
 * rebuild
 *
 * - Second Tree:
 * depths
 *
 * - Third Tree:
 * LCA( dis )
 */

vector<pair<int,ll>> G1[MAXN] , G2[MAXN] , G3[MAXN];

void rebuild( int u , int fa ) {
    int last = -1;
    for( auto& t : G1[u] ) if( t.fi != fa ) {
            int v = t.fi;
            if( last == -1 ) ade( u , v , t.se ) , last = u;
            else {
                ++ n;
                ade( last , n , 0 ) , ade( n , v , t.se );
                last = n;
            }
            rebuild( v , u );
        }
}

int bac[MAXN] , dfn[MAXN] , clo; // bac: to seq
ll dep3[MAXN] , dep2[MAXN];
void cfs( int u , int fa ) {
    dfn[++ clo] = u , bac[u] = clo;
    for( auto& t : G3[u] ) if( t.fi != fa ) {
            int v = t.fi;
            dep3[v] = dep3[u] + t.se;
            cfs( v , u );
            dfn[++ clo] = u;
        }
}
void bfs( int u , int fa ) {
    for( auto& t : G2[u] ) if( t.fi != fa ) {
            int v = t.fi;
            dep2[v] = dep2[u] + t.se;
            bfs( v , u );
        }
}

int st[20][MAXN];
void buildST( ) {
    rep( i , 1 , clo ) st[0][i] = dfn[i];
    rep( i , 1 , lg2( clo ) )
        rep( j , 1 , clo - ( 1 << i ) + 1 )
            st[i][j] = ( dep3[st[i - 1][j]] > dep3[st[i - 1][j + ( 1 << i - 1 )]] ? st[i - 1][j + ( 1 << i - 1 )] : st[i - 1][j] );
}
ll dis3( int u , int v ) {
    int l = bac[u] , r = bac[v];
    if( l > r ) swap( l , r );
    int len = lg2( r - l + 1 ) , lca = dep3[st[len][l]] < dep3[st[len][r - ( 1 << len ) + 1]] ? st[len][l] : st[len][r - ( 1 << len ) + 1];
    return dep3[u] + dep3[v] - 2 * dep3[lca];
}

int vis[MAXN] , siz[MAXN] , E , rt , mn;
void getsize( int u , int fa ) {
    siz[u] = 1;
    for( int i = head[u] ; ~i ; i = nex[i] ) {
        int v = to[i];
        if( v == fa || vis[i >> 1] ) continue;
        getsize( v , u );
        siz[u] += siz[v];
    }
}
void getedge( int u , int fa ) {
    for( int i = head[u] ; ~i ; i = nex[i] ) {
        int v = to[i];
        if( v == fa || vis[i >> 1] ) continue;
        if( max( siz[v] , siz[rt] - siz[v] ) < mn ) mn = max( siz[v] , siz[rt] - siz[v] ) , E = ( i >> 1 );
        getedge( v , u );
    }
}
inline int getit( int u ) { rt = u , E = -1 , mn = 0x3f3f3f3f; getsize( u , u ) , getedge( u , u ); return E; }


int W;
ll ww;
ll dis[MAXN];

int las[MAXN] , r[MAXN] , ch[MAXN << 3][2] , w[MAXN << 3] , idx;

struct orzwkr {
    ll u , v;
    ll valu , valv;
} dp[MAXN << 3][2] ;

void afs( int u , int fa ) {
    if( u <= N ) {
        if( !las[u] ) r[u] = las[u] = ++idx;
        else ch[las[u]][w[u]] = ++ idx , las[u] = idx;
        w[u] = W;
        dp[idx][W].u = dp[idx][W].v = u;
        dp[idx][W].valu = dp[idx][W].valv = dep2[u] + dis[u];
    }
    for( int i = head[u] ; ~i ; i = nex[i] ) {
        int v = to[i];
        if( v == fa || vis[i >> 1] ) continue;
        dis[v] = dis[u] + wto[i];
        afs( v , u );
    }
}

void divide( int e ) {
    vis[e] = 1;
    int u = to[e << 1] , v = to[e << 1 | 1];
    dis[u] = 0 , W = 0; afs( u , u );
    dis[v] = wto[e << 1] , W = 1; afs( v , v );
    u = getit( u ) , v = getit( v );
    if( ~u ) divide( u );
    if( ~v ) divide( v );
}

inline ll calc( int u , int v , ll valu , ll valv ) { // u , v , virtual weight valu,valv
    return dis3( u , v ) + ( u != v ? valu + valv : 0 );
}

inline void mergeit( orzwkr& a , const orzwkr& b ) { // merge b to a
    if( !a.u || !b.u ) { a = ( a.u ? a : b ); return; }
    long long cur , t , vu = calc( a.u , a.v , a.valu , a.valv ) , vv = calc( b.u , b.v , b.valu , b.valv );
    orzwkr ret = vu > vv ? a : b;
    cur = max( vu , vv );
    int u , v;
    rep( i , 0 , 1 ) {
        u = ( i ? a.u : a.v ) , vu = ( i ? a.valu : a.valv );
        rep( j , 0 , 1 ) {
            v = ( j ? b.u : b.v ) , vv = ( j ? b.valu : b.valv );
            t = calc( u , v , vu , vv );
            if( t > cur ) ret = (orzwkr) { u , v , vu , vv } , cur = t;
        }
    }
    a = ret;
}

inline ll getit( const orzwkr& a , const orzwkr& b ) { // must choose one from a one from b
    int u , v;
    ll vu , vv;
    ll ans = -inf , t;
    rep( i , 0 , 1 ) {
        u = ( i ? a.u : a.v ) , vu = ( i ? a.valu : a.valv );
        rep( j , 0 , 1 ) {
            v = ( j ? b.u : b.v ) , vv = ( j ? b.valu : b.valv );
            t = calc( u , v , vu , vv );
            if( t > ans ) ans = t;
        }
    }
    return ans;
}

ll ls;
int merge( int u , int v ) { // merge v to u
    if( !u || !v ) return u | v;
    if( dp[u][0].u && dp[v][1].u ) res = max( res , getit( dp[u][0] , dp[v][1] ) + ls );
    if( dp[u][1].u && dp[v][0].u ) res = max( res , getit( dp[u][1] , dp[v][0] ) + ls );
    mergeit( dp[u][0] , dp[v][0] ) , mergeit( dp[u][1] , dp[v][1] );
    ch[u][0] = merge( ch[u][0] , ch[v][0] ) , ch[u][1] = merge( ch[u][1] , ch[v][1] );
    return u;
}

void bfs2( int u , int fa ) {
    for( auto& t : G2[u] ) if( t.fi != fa ) {
            int v = t.fi;
            bfs2( v , u );
            ls = -2 * dep2[u] , merge( r[u] , r[v] );
        }
}

void debug( int u ) {
    if( !u ) return;
    cout << "Now" << ' ' << u << endl;
    cout << dp[u][0].u << ' ' << dp[u][0].v << ' ' << dp[u][0].valu << ' ' << dp[u][0].valv << endl;
    cout << dp[u][1].u << ' ' << dp[u][1].v << ' ' << dp[u][1].valu << ' ' << dp[u][1].valv << endl;
    puts("");
    debug( ch[u][0] ) , debug( ch[u][1] );
}

void solve() {
    cin >> n; N = n;
    rep( i , 1 , n * 2 ) head[i] = -1;
    int u , v; ll w;
    rep( i , 2 , n ) rd( u ) , rd( v ) , rd( w ) , G1[u].eb( mp( v , w ) ) , G1[v].eb( mp( u , w ) );
    rep( i , 2 , n ) rd( u ) , rd( v ) , rd( w ) , G2[u].eb( mp( v , w ) ) , G2[v].eb( mp( u , w ) );
    rep( i , 2 , n ) rd( u ) , rd( v ) , rd( w ) , G3[u].eb( mp( v , w ) ) , G3[v].eb( mp( u , w ) );
    rebuild( 1 , 1 ) , cfs( 1 , 1 ) , bfs( 1 , 1 ) , buildST( );
    divide( getit( 1 ) );
//    debug( r[5] );
    bfs2( 1 , 1 );
    cout << res << endl;
}

signed main() {
//    freopen("input","r",stdin);
//    freopen("fuckout","w",stdout);
//    int T;cin >> T;while( T-- ) solve();
    solve();
}
```



---

## 作者：ZillionX (赞：0)

# Description

给出三棵大小为 $n$ 的树 $T_1,T_2,T_3$，求

$$\max {\rm dis}T_1(x,y) + {\rm dis}T_2(x,y) + {\rm dis}T_3(x,y)$$

$n \le10^5, 0 \le w \le 10^{12}$，时限 4s。

# Solution

这里是跑得飞快的 $\mathcal O(n \log n)$ 做法。

两棵树的类似简化版：[P4565 [CTSC2018]暴力写挂](https://www.luogu.com.cn/problem/P4565)。

我们考虑对 $T_1$ 建立边分树，在 $T_3$ 上枚举 $x,y$ 的 LCA 并合并边分树，这样我们就搞定了 ${\rm dis}T_1(x,y)$ 和 ${\rm dis}T_3(x,y)$。

注意到边权非负，因此直径集合是封闭的，于是我们在合并边分树的同时维护 $T_2$ 上的点集直径。

具体地，对 $T_2$ 跑一次 dfs 求出欧拉序，做 $\mathcal O(n \log n) - \mathcal O(1)$ 的 LCA。

给 $T_2$ 上的每个点赋一个点权 ${\rm dis}T_1(u,x) + {\rm dep}T_3(x) - 2{\rm dep}T_3({\rm lca})$（这里的 $u$ 即为 $T_1$ 边分树上的分治中心，$\rm lca$ 即为 $T_3$ 上合并边分树时枚举的 LCA），在计算两点距离时加上两端点权，则所维护的直径即为答案。

合并两个点集时，不难证明，新点集的直径端点必然是原来两个点集的两直径的四个端点中的两个。由此则可以方便地维护点集直径。

细节有点多，可以看代码。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,rn,tot,Sum,rt,Ans,la[N*2],dis1[N*2],sz1[N*2],dis3[N*4],dep1[N*2],rrt[N],ch[N*20][2],lac[N*2];
int mi;
bool vis[N*4];
struct Grp {
	int NumE,Fir[N*2];
	struct Edge {
		int v,w,nxt;
	}E[N*4];
	void AddE(int u,int v,int w) {
		E[++NumE]=(Edge){v,w,Fir[u]};
		Fir[u]=NumE;
	}
}T1,T2,T3,NT1;
struct eddv {
	int u,v,vu,vv;
}nd[N*20][2];
void rebd(int x,int fa) {
	int lst=x;
	for (int i=NT1.Fir[x];i;i=NT1.E[i].nxt) {
		int to=NT1.E[i].v;
		if (to==fa) continue;
		rn++,T1.AddE(lst,rn,0),T1.AddE(rn,lst,0);
		T1.AddE(rn,to,NT1.E[i].w),T1.AddE(to,rn,NT1.E[i].w);
		lst=rn;
		rebd(to,x);
	}
}
void jbfs(int x,int fa,int op) {
	sz1[x]=1;
	if (x<=n) {
		if (!op) {
			tot++;
			if (!rrt[x]) rrt[x]=tot;
			else ch[la[x]][lac[x]]=tot;
			lac[x]=0;
			la[x]=tot;
			nd[tot][0].u=nd[tot][0].v=x;
			nd[tot][0].vu=nd[tot][0].vv=dis1[x]+dis3[x];
		}
		else {
			tot++;
			if (!rrt[x]) rrt[x]=tot;
			else ch[la[x]][lac[x]]=tot;
			lac[x]=1;
			la[x]=tot;
			nd[tot][1].u=nd[tot][1].v=x;
			nd[tot][1].vu=nd[tot][1].vv=dis1[x]+dis3[x];
		}
	}
	for (int i=T1.Fir[x];i;i=T1.E[i].nxt) {
		int to=T1.E[i].v;
		if (vis[i] || to==fa) continue;
		dis1[to]=dis1[x]+T1.E[i].w; 
		jbfs(to,x,op);
		sz1[x]+=sz1[to];
	}
}
void GetR(int x,int fa) {
	sz1[x]=1;
	for (int i=T1.Fir[x];i;i=T1.E[i].nxt) {
		int to=T1.E[i].v;
		if (vis[i] || to==fa) continue;
		GetR(to,x);
		if (mi>max(sz1[to],Sum-sz1[to])) mi=max(sz1[to],Sum-sz1[to]),rt=i;
		sz1[x]+=sz1[to];
	}
}
void egbv(int x) {
	if (Sum==1) return;
	rt=0,mi=1e18;
	GetR(x,0);
	int le=T1.E[rt].v,ri=T1.E[((rt-1)^1)+1].v;
	vis[rt]=vis[((rt-1)^1)+1]=1;
	dis1[le]=0,jbfs(le,0,0);
	dis1[ri]=T1.E[rt].w,jbfs(ri,0,1);
	Sum=sz1[le],egbv(le);
	Sum=sz1[ri],egbv(ri);
}
struct ST {
	int tim,in[N],dep2[N],lg2[N*4],st[N*4][25],dis2[N];
	void dfst2(int u,int fa) {
		st[in[u]=++tim][0]=u;
		dep2[u]=dep2[fa]+1;
		for (int i=T2.Fir[u];i;i=T2.E[i].nxt) {
			int to=T2.E[i].v;
			if (to==fa) continue;
			dis2[to]=dis2[u]+T2.E[i].w;
			dfst2(to,u),st[++tim][0]=u;
		}
	}
	int mnp(int x,int y) {
		return dep2[x]<dep2[y]?x:y;
	}
	void Init() {
		dfst2(1,0);
		for (int i=2;i<=tim;i++) lg2[i]=lg2[i>>1]+1;
		for (int j=0;j+1<=lg2[tim];j++)
			for (int i=1;i+(1<<j)<=tim;i++)
				st[i][j+1]=mnp(st[i][j],st[i+(1<<j)][j]);
	}
	int LCA(int x,int y) {
		x=in[x],y=in[y];
		if (x>y) swap(x,y);
		int k=lg2[y-x+1];
		return mnp(st[x][k],st[y-(1<<k)+1][k]);
	}
	int Dis2(int x,int y) {
		return dis2[x]+dis2[y]-dis2[LCA(x,y)]*2;
	}
}S;
int Dis(int x,int y,int vx,int vy) {
	if (x==y) return 0;
	return S.Dis2(x,y)+vx+vy;
}
int mdfk(eddv a,eddv b) {
	int u,v,vu,vv;
	int mx=-1e18;
	for (int i=0;i<=1;i++) {
		u=i?a.u:a.v;vu=i?a.vu:a.vv;
		for (int j=0;j<=1;j++) {
			v=j?b.u:b.v;vv=j?b.vu:b.vv;
			int t=Dis(u,v,vu,vv);
			if (t>mx) mx=t;
		}
	}
	return mx;
}
void Mrgd(eddv &a,eddv &b) {
	if (!a.u || !b.u) {
		a=(a.u)?a:b;
		return;
	}
	eddv c=Dis(a.u,a.v,a.vu,a.vv)>Dis(b.u,b.v,b.vu,b.vv)?a:b;
	int mx=max(Dis(a.u,a.v,a.vu,a.vv),Dis(b.u,b.v,b.vu,b.vv));
	int u,v,vu,vv;
	for (int i=0;i<=1;i++) {
		u=i?a.u:a.v;vu=i?a.vu:a.vv;
		for (int j=0;j<=1;j++) {
			v=j?b.u:b.v;vv=j?b.vu:b.vv;
			int t=Dis(u,v,vu,vv);
			if (t>mx) mx=t,c=(eddv){u,v,vu,vv};
		}
	}
	a=c;
}
int Mrg(int x,int y,int gua) {
	if (!x || !y) return x|y;
	if (nd[x][0].u && nd[y][1].u)
		Ans=max(Ans,mdfk(nd[x][0],nd[y][1])+gua);
	if (nd[x][1].u && nd[y][0].u)
		Ans=max(Ans,mdfk(nd[x][1],nd[y][0])+gua);
	Mrgd(nd[x][0],nd[y][0]);
	Mrgd(nd[x][1],nd[y][1]);
	ch[x][0]=Mrg(ch[x][0],ch[y][0],gua);
	ch[x][1]=Mrg(ch[x][1],ch[y][1],gua);
	return x;
}
void gsmg(int u,int fa) {
	for (int i=T3.Fir[u];i;i=T3.E[i].nxt) {
		int to=T3.E[i].v;
		if (to==fa) continue;
		dis3[to]=dis3[u]+T3.E[i].w;
		gsmg(to,u);
	}
}
void dfst3(int u,int fa) {
	for (int i=T3.Fir[u];i;i=T3.E[i].nxt) {
		int to=T3.E[i].v;
		if (to==fa) continue;
		dfst3(to,u);
		rrt[u]=Mrg(rrt[u],rrt[to],-2*dis3[u]);
	}
}
signed main() {
	scanf("%lld",&n);
	for (int i=1;i<n;i++) {
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		NT1.AddE(x,y,z),NT1.AddE(y,x,z);
	}
	for (int i=1;i<n;i++) {
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		T2.AddE(x,y,z),T2.AddE(y,x,z);
	}
	for (int i=1;i<n;i++) {
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		T3.AddE(x,y,z),T3.AddE(y,x,z);
	}
	gsmg(1,0);
	S.Init();
	rn=n;
	rebd(1,0);
	Sum=rn,rt=0,mi=1e18;
	egbv(1);
	dfst3(1,0);
	printf("%lld",Ans);
	return 0;
}
```


---

## 作者：硬核不媚宅 (赞：0)

## 任务：

给定三颗树，求 $ \mathop{max}\limits_{x,y} \{ dis1(x,y)+dis2(x,y)+dis3(x,y) \} $ 

$ 2 \leq n \leq 10^5,0 \leq w \leq 10^{12} $ 

## 算法：

三棵树，因此我们只能一步步算出每棵树的距离,将多个算法嵌套起来。

对于第一棵树，我们需要枚举出所有的路径距离，所以可以选用边分治。

设当前分治边为 $ (st,ed) $ 。那么我们需要处理的路径 $ (a,b) $ 应该满足经过该边，即 $ a $ 和 $ st $ 属于一个连通块， $ b $ 和 $ ed $ 属于一个连通块。

因此可以直接将 $ st $ 和 $ ed $ 侧的点进行黑白染色。

于是当前任务就变成了:在当前分治树中，寻找一个黑点 $ a $ , 一个白点 $ b $  ,使得

$ dis1(a,st)+dis1(ed,b) + val1(st, ed) + dis2(a,b) + dis3(a,b) $ 最大。

$ dis2(a,b) = dep2(a) + dep3(b) - 2 \cdot dep2(lca2(a,b)) $ 

$ dis3(a,b) = dep3(a) + dep3(b) - 2 \cdot dep 3(lca3(a,b)) $ 

除了 $lca$ 的项,我们对于 $a$ 和 $b$ 只需要求出  $ w(x) = dis1(x, st/ed) + dep2(x) + dep3(x) $ 

所以原式变为 $ w(a) + w(b) - 2\cdot dep2(lca(a,b) - 2\cdot dep3(lca3(a,b)) $ 

此时,我们需要通过第二棵树的边来判断 $ dep2(lca2(a,b)) $  ，根据边分治的性质,我们可以将黑点与白点以第二棵树的连通性建立虚树。	

此时就可以在虚树上枚举 $ lca2(a,b) $ 统计答案,假设当前枚举的点为 $ p $  ,那么我们只需要从 $ p $ 的不同子树中找到一对点 $ (a,b) $ , 满足 $ a $ 是黑点， $ b $ 是白点，且最大化 $ w(a) + w(b) - 2\cdot dep3(lca3(a, b)) $ 。

如果 $ w(a) $ 代表 $ dep3(a) $  ,那么上式子就变成了第三棵树的直径,由于边权非负，我们可以通过树形DP进行求解。( 子树的直径合并等于四个直径端点两两组合)

$w($x$) = dis1(x, st/ed) + dep2(x) + dep3(x)$

因此，我们可以建立虚点 $ a' $ 和 $ b' $  ,然后边权设为 $ dis1(x, st/ed) + dep2(x) $  , 这样原式就变为了 $ (a',b') $ 的距离。

时间复杂度  $ O(nlog^2n) $  ,排序和 $LCA$ 优化之后可以达到 $ O(nlogn) $ 。

---


# 【MX-X1-T6】「KDOI-05」简单的图上问题

## 题目背景

原题链接：<https://oier.team/problems/X1F>。

## 题目描述

给你一个 $n$ 个点 $m$ 条边的边双连通图，并且给定了每个点的坐标，保证每条边不相交或者只在端点处重合。

给定 $k$ 个图上的简单环 $C_1,C_2,\dots,C_k$，定义 $G_i$ 为只考虑 $C_i$ 内部的点和边所组成的图。

对 $S\subseteq\{1,2,\dots,k\},S=\{s_1,s_2,\dots,s_t\}$，定义 $f(S)$ 表示所有 $G_{s_i}$ 交的连通块数量。

有 $q$ 个询问，每次给出一个 $z$，输出 $\sum_{S\subseteq\{1,2,\dots,k\},|S|=z}f(S)$。对 $998244353$ 取模。

## 说明/提示

**【样例解释 \#1】**

样例 $1$ 的数据如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7v424onc.png)

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1$ | $15$ | $10$ | 无 |
| $2$ | $30$ | $1000$ | 无 |
| $3$ | $30$ | $4\times10^4$ | 保证平面图是一个凸包的三角剖分 |
| $4$ | $15$ | $4\times10^4$ | 无 |
| $5$ | $10$ | $10^5$ | 无 |

对于 $100\%$ 的数据：$1\leq n,\sum l_i\leq10^5$，$1\leq m\leq 3n-6$，$3\leq l_i$，$0\leq |x_i|,|y_i|\leq 10^9$，$1\leq q\leq 20$，$1\leq u_i,v_i\leq n$，$u_i\neq v_i$，$1\leq z_i\leq k$。保证所有 $1\leq i<j\leq n$，都有 $x_i\neq x_j,y_i\neq y_j$。保证每条边不相交或者只在端点处重合，保证图是一个边双连通分量。

## 样例 #1

### 输入

```
4 5 3
1 1
3 2
2 3
4 4
1 2
1 3
1 4
2 4
3 4
3 1 2 4
3 1 3 4
4 1 2 4 3
3
1
2
3
```

### 输出

```
3
3
1```

## 样例 #2

### 输入

```
8 15 5
4 4
5 8
2 7
10 9
1 10
3 5
8 2
7 6
2 1
3 1
3 2
4 1
4 2
5 2
5 3
5 4
6 1
6 3
7 1
7 4
8 1
8 4
8 7
3 1 8 4 
3 1 6 3 
3 7 8 4 
4 8 1 7 4 
3 1 2 3 
5
1
2
3
4
5```

### 输出

```
5
8
5
1
0```

# 题解

## 作者：TernaryTree (赞：3)

前置知识：一定的计算几何基础，最小左转法求平面图对偶图，平衡树。

欧拉公式是 $V-E+F=2$。而这里必须是连通图。扩展一下可以得到，$V-E+F=1+C$，这里的 $C$ 是连通块数量。题意转化为求 $\sum V,\sum E,\sum F$。

拆贡献，对于询问 $i$，假设现在计算 $\sum V$，则计算每个点 $u$ 会被多少个方案覆盖。显然应该是 $\dbinom{cnt(V_u)}{i}$ 次，$cnt(V_u)$ 表示点 $u$ 被给定的环覆盖的次数，即在多少个多边形内。$cnt(E_u),cnt(F_u)$ 同理。

算 $cnt(V_u)$。被覆盖的次数，先考虑如何算一个点是否被一个多边形覆盖。我们从这个点引出一条射线，方便起见，令其方向为正上方。若射线与多边形的边界有奇数个交点，则在多边形内；反之在外面。特别地，点在多边形上需要特判。我们对每条边赋一个 $\pm 1$ 的权值，$+1$ 表示多边形的“上边界”，$-1$ 表示多边形的“下边界”。这样一条射线交的所有线段权值和 $\in \{0,1\}$ 表明了是否被多边形覆盖，同时边权可以累加，对多边形的边权贡献到边上，再统一计算点，即可得到被多少个多边形覆盖。至于上边界下边界如何判断，先将多边形上的边看做有向边（向量）并顺时针排序，若 $x_v>x_u$ 则为上边界，否则是下边界。点在多边形上的特判需要注意，对线段可使用左闭右开判定，则交点落在点上时不会重复计算。若两条连续的边都是下边界，则其交点 $cnt$ 需 $+1$；若一条是下边界，一条是上边界，且这个角是凸的，则交点 $cnt$ 也需要 $+1$。

暴力遍历线段计算权值和复杂度不能接受。按 $x$ 排序后扫描线，每次将当前范围内的线段加入平衡树，由于是平面图，平衡树内的线段相对位置不会改变，则一个点的询问在平衡树内相当于查了一段后缀和，平衡树二分即可。

算 $cnt(E_u)$。发现在边上取一个非端点的点转化为 $cnt(V_u)$ 的情况，取中点即可。

算 $cnt(F_u)$。在避免精度误差的前提下（即取的所有点都是整数），在面里取一个点是很难的。参考 P3249 [HNOI2016] 矿区，转对偶图之后跑出一个生成树，则多边形内面加即遍历对偶图上所有连接多边形内与多边形外的边，进行子树 $+1$ 或 $-1$。又子树内 dfn 序连续且只需要最终结果，差分即可。

令 $n,m,k,\sum |C_i|$ 同阶，复杂度是 $\Theta(n\log n+qn)$。代码写了 11K，相信没有人想看，所以不放了。

---

## 作者：huazai676 (赞：2)

[【MX-X1-T6】「KDOI-05」简单的图上问题](https://www.luogu.com.cn/problem/P10718)

直接计算连通块数量难度较大，由平面图性质利用欧拉公式 $V-E+F=C$（$F$ 为有界面数量）转换成计算点数、边数、面数。如果一个点被 $t$ 个环包围，那么仅在 $t\choose z$ 种情况下这个点出现在 $z$ 个环的交集中，所以它对答案的贡献为 $t\choose z$。边、面的情况同理。所以只需要对于每个点、边、面统计有多少个环包含它。

与 std 不同，这里用同一种方法统计点、边、面的贡献。

对于统计每个面的贡献，建出平面图的对偶图，再以无界面的点为根随便建一颗生成树。脑补一下图：一棵树树枝插进一个环里。如何快速给环覆盖上的每个节点都加 1 呢？当树枝进入环时，即节点 $u$ 在环内，$fa_u$ 在环外时，给 $u$ 子树节点都加 1；在树枝出环时，即 $fa_u$ 在环内，$u$ 在环外时，给 $u$ 子树减 1。

如何统计点和边的贡献？回到原图，如果一个面被环包含，那么所有面上的点也被环包含。所以可以再最后把每个面的贡献加到点上，这样每个点 $u$ 都会被统计 $d_u$（$d_u$ 为点 $u$ 的度数，也是与 $u$ 相邻的面的个数）次，最后再除掉；但是还没结束，那些恰好在环上的点冰不会被统计恰好 $d_u$ 次，因为每次只有环内的面的贡献加到了这些点上。但注意到这些点加起来也不会超过 $10^5$ 个，于是处理环时对于每个环上点把贡献补成 $d_u$ 就好了（加上环外相邻面的数量），这样最后除掉就是对的。边同理。

不用平衡树自然是最优解。

代码

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cassert>
#define PII pair<int,int>
#define x first
#define y second

typedef long long ll;

using namespace std;

PII operator-(const PII& u,const PII& v)
{
	return {u.x-v.x,u.y-v.y};
}

ll operator*(const PII& u,const PII& v)
{
	return 1LL*u.x*v.y-1LL*u.y*v.x;
}

int qt(const PII& u)
{
	if(u.x>0&&u.y>=0) return 1;
	if(u.y>0&&u.x<=0) return 2;
	if(u.x<0&&u.y<=0) return 3;
	if(u.y<0&&u.x>=0) return 4;
	return 0;
}

bool operator<(const PII& u,const PII& v)
{
	int i=qt(u),j=qt(v);
	return i==j? u*v>0:i<j;
}

const int N=1e5+10,M=N*6,mod=998244353;

int n,m,k,cnt,idx;
PII p[N];
struct edge
{
	int from,to,id,val;
}eg[M<<1];
vector<edge> G[N];
void add_edge(int u,int v)
{
	eg[cnt]={u,v,cnt,0};
	G[u].push_back(eg[cnt]);
	cnt++;
}
bool operator<(const edge& u,const edge& v)
{
	return p[u.to]-p[u.from]<p[v.to]-p[v.from];
}

int root,fa[M];
ll tag[M][3];
vector<int> T[M];
bool vis[M];

void dfs(int u)
{
	vis[u]=true;
	for(int v:T[u])
	{
		if(vis[v]) continue;
		fa[v]=u;
		tag[v][2]+=tag[u][2];
		dfs(v);
	}
}

int st[N],tp;
int stk[M],top;
bool ins[M];

ll ksm(ll x,ll y)
{
	ll res=1;
	while(y)
	{
		if(y&1) res=res*x%mod;
		y>>=1;
		x=x*x%mod;
	}
	return res;
}
ll fac[N],inv[N];

ll C(int x,int y)
{
	if(x<y) return 0;
	return fac[x]*inv[y]%mod*inv[x-y]%mod;
}

int main()
{
	fac[0]=1;
	for(int i=1;i<N;i++) fac[i]=fac[i-1]*i%mod;
	inv[N-1]=ksm(fac[N-1],mod-2);
	for(int i=N-2;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>p[i].x>>p[i].y;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		add_edge(u,v),add_edge(v,u);
	}
	for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());

	for(int i=0;i<cnt;i++)
	{
		if(eg[i].val) continue;
		int now=i;
		idx++;
		ll s=0;
		do
		{
			s+=p[eg[now].from]*p[eg[now].to];
			eg[now].val=idx;
			int u=eg[now].to;
			auto it=lower_bound(G[u].begin(),G[u].end(),eg[now^1]);
			if(it==G[u].begin()) it=G[u].end();
			it--;
			now=it->id;
		}while(now!=i);
		if(s<0) root=idx;
	}
	for(int i=0;i<cnt;i++)
	{
		int u=eg[i].val,v=eg[i^1].val;
		T[u].push_back(v);
	}
	dfs(root);
	
	for(int o=1;o<=k;o++)
	{
		cin>>tp;
		for(int i=0;i<tp;i++) cin>>st[i];
		ll s=0;
		for(int i=0;i<tp;i++) s+=p[st[i]]*p[st[(i+1)%tp]];
		if(s<0) reverse(st,st+tp);
		for(int i=0;i<tp;i++)
		{
			int u=st[i],v=st[(i+1)%tp];
			auto it=lower_bound(G[u].begin(),G[u].end(),(edge){u,v,0,0});
			int in=eg[it->id].val,out=eg[it->id^1].val;
			tag[it->id^1][1]++;
			if(!ins[in]&&fa[in]==out) tag[in][2]++,ins[stk[++top]=in]=true;
			else if(!ins[out]&&fa[out]==in) tag[out][2]--,ins[stk[++top]=out]=true;
		}
		while(top) ins[stk[top--]]=false;
		for(int i=0;i<tp;i++)
		{
			int l=st[(i-1+tp)%tp],mid=st[i],r=st[(i+1)%tp];
			auto it1=lower_bound(G[mid].begin(),G[mid].end(),(edge){mid,l,0,0}),
				 it2=lower_bound(G[mid].begin(),G[mid].end(),(edge){mid,r,0,0});
			int tot=G[mid].size();
			tag[mid][0]+=(it2-it1+tot)%tot;
		}
	}
	memset(vis,0,sizeof vis);
	dfs(root);
	for(int i=0;i<cnt;i++)
	{
		int u=eg[i].from,in=eg[i].val;
		tag[u][0]+=tag[in][2];
		tag[i][1]+=tag[in][2];
	}
	for(int i=1;i<=n;i++) tag[i][0]/=G[i].size();
	
	int q;
	cin>>q;
	while(q--)
	{
		int z;
		cin>>z;
		ll ans=0;
		for(int i=1;i<=n;i++) ans=(ans+C(tag[i][0],z))%mod;
		for(int i=0;i<cnt;i+=2) ans=(ans-C(tag[i][1],z))%mod;
		for(int i=1;i<=idx;i++) ans=(ans+C(tag[i][2],z))%mod;
		cout<<(ans+mod)%mod<<'\n';
	}
	
	return 0;
}
```

---


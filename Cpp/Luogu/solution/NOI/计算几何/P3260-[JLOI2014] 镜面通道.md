# [JLOI2014] 镜面通道

## 题目描述

在一个二维平面上，有一个镜面通道，由镜面 $AC, BD$ 组成，$AC, BD$ 长度相等，且都平行于 $x$ 轴，$B$ 位于 $(0,0)$。

通道中有 $n$ 个外表面为镜面的光学元件，光学元件 $\alpha$ 为圆形，光学元件 $\beta$ 为矩形（这些元件可以与其他元件和通道有交集，具体看下图）。光线可以在 $AB$ 上任一点以任意角度射入通道，光线不会发生削弱。当出现元件与元件，元件和通道刚好接触的情况视为光线无法透过（比如两圆相切）。

现在给出通道中所有元件的信息（$\alpha$ 元件包括圆心坐标和半径 $x_i, y_i, r_i$，$\beta$ 元件包括左下角和右上角坐标 $x_1, y_1, x_2, y_2$）

![](https://cdn.luogu.com.cn/upload/pic/17612.png)

如上图，$S$ 到 $T$ 便是一条合法线路。

![](https://cdn.luogu.com.cn/upload/pic/17613.png)

当然，显然存在光线无法透过的情况，现在交给你一个艰巨的任务，请求出至少拿走多少个光学元件后，存在一条光线线路可以从 $CD$ 射出。

下面举例说明：

![](https://cdn.luogu.com.cn/upload/pic/17614.png) 

现在假设，取走中间那个矩形，那么就可以构造出一条穿过通道的光路，如图中的 $S$ 到 $T$。


## 说明/提示

$x\leq 10^5$，$y\leq 1000$，$n\leq 300$。


## 样例 #1

### 输入

```
1000 100
6
1 500 0 50
2 10 10 20 100
2 100 10 200 100
2 300 10 400 100
2 500 10 600 100
2 700 0 800 100```

### 输出

```
2```

# 题解

## 作者：Leap_Frog (赞：10)

### P.S.
这题调了我一个上午/ll。  
[这篇题解应该是这题中正确的解法/cy](https://www.luogu.com.cn/discuss/show/266985)  
具体结论我也不会证明，只会感性理解（毕竟我是 OIer 而不是 MOer  
（UPD，根据 @zhouchenyuan005 指导，好像发明了一种看上去很对的证明结论方法。  
数据感觉是用脚造的（或者可能数据范围是用脚造的  
（毕竟我构造了一个这样的数据，就把第一篇题解 X 掉了/cy  
（因为通道很短，在通道很远处有光学仪器并不影响通道内的光  
（UPD，好像把两篇题解都 X 掉了。  
### Description.
这里有一个光通道，内壁能反光。（镜面反射  
上面有很多光学仪器，可能是矩形，也可能是圆形。  
要求让光能从一头能通到另一头，求最小摧毁的光通道代价。  
### Tips.
[对样例的模拟](https://www.geogebra.org/m/t2x4xugf)  
一些手模拟的数据，是笔者调代码过程中对拍得到的
[1](https://www.geogebra.org/m/jcce8cpy)
[2](https://www.geogebra.org/m/sregtqug)
[3](https://www.geogebra.org/m/fwwuddnv)
[4](https://www.geogebra.org/m/tqwdrepe)
[5](https://www.geogebra.org/m/eshzekab)
### Solution.
首先我们考虑这样一个结论：如果光通道中间有缝隙，那光就能从一头。  
感谢 @[zhouchenyuan005](https://www.luogu.com.cn/user/87416) 提供的做法。（虽然可能证明不是很严谨，但是可以感性理解  
首先，我们考虑类似扫描线一样地扫过去，对于最左边的点，它显然可以向它右边的任意一个点移动。  
那么也就是说我们对于每个不在边缘的点它都有任意一个方向，那么光就肯定能通到左右边。  
那么我们就需要找到最少代价把原图删掉一些仪器，让仪器之间有空隙。  
我们换个思路，把光学仪器看作点，那么我们就是要选出一些点把它删掉并让原图不联通。  
这显然可以用最小割做，注意不是裸的最小割因为这里是删点而不是割边。  
我们对相切或相割的两个光学仪器连边，对最上面和最下面两个作为源点和汇点。  
对于每个光学仪器，我们拆成两个点，并连 1 的流量限制。  
对连边，把一条边出发点的出点连向结束点的入点，然后跑 dinic。  

这题就做完了，完结撒花，代码很丑，勿喷/kel  
### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;const double eps=1e-7;const int INF=1e9;
struct rnd{double x,y,r;int id;}a[1205];
struct squ{double x1,y1,x2,y2;int id;}b[1205];
struct edge{int to,w,nxt;}e[2000005];
double Cx,Cy;int n,et,s,t,head[1205],d[1205],cr[1205],ac,bc;
inline char chk(squ a,double x,double y) {return a.x1-eps<=x&&x<=a.x2+eps&&a.y1-eps<=y&&y<=a.y2+eps;}
inline char CHK(squ a,double y,double x1,double x2) {return (a.y1-eps<=y&&y<=a.y2+eps)||chk(a,x1,y)||chk(a,x2,y);}
inline char chk1(rnd a,double x,double y1,double y2)
{
	if((a.x-x)*(a.x-x)+(a.y-y1)*(a.y-y1)<=a.r*a.r+eps) return 1;
	if((a.x-x)*(a.x-x)+(a.y-y2)*(a.y-y2)<=a.r*a.r+eps) return 1;
	if(!(a.x-x<=a.r+eps&&a.x-x>=a.r-eps)) return 0;
	double dy=sqrt(a.r*a.r-(a.x-x)*(a.x-x)),Y1=a.y-dy,Y2=a.y+dy;
	return (y1-eps<=Y1&&Y1<=y2+eps)||(y1-eps<=Y2&&Y2<=y2+eps);
}
inline char chk2(rnd a,double y,double x1,double x2)
{
	if((a.x-x1)*(a.x-x1)+(a.y-y)*(a.y-y)<=a.r*a.r+eps) return 1;
	if((a.x-x2)*(a.x-x2)+(a.y-y)*(a.y-y)<=a.r*a.r+eps) return 1;
	if(!(a.y-y<=a.r+eps&&a.y-y>=-a.r-eps)) return 0;
	double dx=sqrt(a.r*a.r-(a.y-y)*(a.y-y)),X1=a.x-dx,X2=a.x+dx;
	return (x1-eps<=X1&&X1<=x2+eps)||(x1-eps<=X2&&X2<=x2+eps);
}
inline char operator+(rnd a,rnd b) {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<=(a.r+b.r+eps)*(a.r+b.r+eps);}
inline char operator+(squ a,squ b) {return chk(a,b.x1,b.y1)||chk(a,b.x1,b.y2)||chk(a,b.x2,b.y1)||chk(a,b.x2,b.y2);}
inline char operator+(squ a,rnd b)
{
	if((a.x1-b.x)*(a.x1-b.x)+(a.y1-b.y)*(a.y1-b.y)<=b.r*b.r+eps) return 1;
	if((a.x2-b.x)*(a.x2-b.x)+(a.y1-b.y)*(a.y1-b.y)<=b.r*b.r+eps) return 1;
	if((a.x1-b.x)*(a.x1-b.x)+(a.y2-b.y)*(a.y2-b.y)<=b.r*b.r+eps) return 1;
	if((a.x2-b.x)*(a.x2-b.x)+(a.y2-b.y)*(a.y2-b.y)<=b.r*b.r+eps) return 1;
	if(chk(a,b.x,b.y)) return 1;
	if(chk1(b,a.x1,a.y1,a.y2)||chk1(b,a.x2,a.y2,a.y2)||chk2(b,a.y1,a.x1,a.x2)||chk2(b,a.y2,a.x1,a.x2)) return 1;
	return 0;
}
inline void ADDE(int x,int y,int w) {e[++et]=(edge){y,w,head[x]},head[x]=et;}
inline void adde(int x,int y,int w) {ADDE(x,y,w),ADDE(y,x,0);}
inline char bfs(int s,int t)
{
	queue<int>q;q.push(s),memset(d,0,sizeof(d)),d[s]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=e[i].nxt) if(e[i].w&&!d[e[i].to]) d[e[i].to]=d[x]+1,q.push(e[i].to);
	}
	return !!d[t];
}
#define rev(x) ((((x)&1)?1:-1)+(x))
inline int dfs(int x,int t,int lim=INF)
{
	int f=lim;if(x==t) return lim;
	for(int i=cr[x];i;cr[x]=i=e[i].nxt) if(d[e[i].to]==d[x]+1&&e[i].w)
	{
		int g=dfs(e[i].to,t,min(f,e[i].w));f-=g;
		e[i].w-=g,e[rev(i)].w+=g;if(!f) break;
	}
	return lim-f;
}
inline int dinic(int s,int t) {int r=0;while(bfs(s,t)) memcpy(cr,head,sizeof(cr)),r+=dfs(s,t);return r;}
int main()
{
	scanf("%lf%lf%d",&Cx,&Cy,&n),et=0,memset(head,0,sizeof(head)),s=n<<1|1,t=s+1;
	for(int i=1,fg;i<=n;i++)
	{
		scanf("%d",&fg);if(fg^2) ++ac,scanf("%lf%lf%lf",&a[ac].x,&a[ac].y,&a[ac].r),a[ac].id=i;
		else bc++,scanf("%lf%lf%lf%lf",&b[bc].x1,&b[bc].y1,&b[bc].x2,&b[bc].y2),b[bc].id=i;
	}
	for(int i=1;i<=n;i++) adde(i,i+n,1);
	for(int i=1;i<=ac;i++) if(chk2(a[i],0,0,Cx)) adde(s,a[i].id,1);
	for(int i=1;i<=bc;i++) if(CHK(b[i],0,0,Cx)) adde(s,b[i].id,1);
	for(int i=1;i<=ac;i++) if(chk2(a[i],Cy,0,Cx)) adde(a[i].id+n,t,1);
	for(int i=1;i<=bc;i++) if(CHK(b[i],Cy,0,Cx)) adde(b[i].id+n,t,1);
	for(int i=1;i<=ac;i++) for(int j=1;j<=ac;j++) if(i!=j&&a[i]+a[j]) adde(a[i].id+n,a[j].id,1);
	for(int i=1;i<=bc;i++) for(int j=1;j<=ac;j++) if(i!=j&&b[i]+a[j]) adde(b[i].id+n,a[j].id,1);
	for(int i=1;i<=ac;i++) for(int j=1;j<=bc;j++) if(i!=j&&b[j]+a[i]) adde(a[i].id+n,b[j].id,1);
	for(int i=1;i<=bc;i++) for(int j=1;j<=bc;j++) if(i!=j&&(b[i]+b[j]||b[j]+b[i])) adde(b[i].id+n,b[j].id,1);
	return printf("%d\n",dinic(s,t)),0;
}
```

---

## 作者：TKXZ133 (赞：9)

[镜面通道](https://www.luogu.com.cn/problem/P3260)

### 题目大意

在一个二维平面内，给出一个镜面通道和若干个镜面元件，每个元件可能是圆形或矩形。求出为了能够使光从通道左边通过通道到达右边，至少需要拿走的元件个数。

![](https://i.imgloc.com/2023/06/01/VktuU5.png)

### 思路分析

首先，存在一个结论：如果通道中存在从左边到右边的路径，那么光就能通过。

证明一下：当通道中存在从左边到右边的路径时，我们不妨将通道竖直放置，令左边朝上，向通道中注水，那么水一定能从下方流出。考虑水恰好流出时，即流出的水形成“水线”时，将通道的剩余部分填满，那么光一定可以沿顺着水的方向通过，所以在剩余部分没有填满的情况下光也能通过。

![](https://i.imgloc.com/2023/06/01/VkWZR8.png)

那么现在的问题就变成了，至少需要拿走多少元件可以使得通道中存在从左到右的路径，而这等价于通道的上下边界无法通过元件连通。

我们发现，上下边界的连通性与元件的形状，大小均无关，只与元件之间是否接触有关。那么我们可以将元件抽象成点，点与点之间存在边当且仅当两个点代表的元件接触，这样就形成了一张图。

我们同时也可以将上下边界抽象成点加入图，连边方式与元件类似，即如果存在元件与边界相接触，那么将该元件代表的点和边界代表的点连边。

![](https://i.imgloc.com/2023/06/01/VktvUw.png)

那么问题就转化为了，至少需要删除多少个点，可以使得上下边界代表的两点不连通。

这显然是一个最小割问题，可以通过网络流解决。

建图方式比较简单，将点拆成入点和出点，出入点之间连边权为 $1$ 的边，将上下边界代表的点设为源点和汇点，点与点之间，点与边界之间连边权为 $+\infty$ 的边即可。

![](https://i.imgloc.com/2023/06/01/VktQg3.png)

现在考虑如何判断两个元件之间接触：

- 圆和圆

直接计算两圆心的距离是否小于等于半径之和即可。

- 矩形和矩形

枚举两个矩形的四个顶点是否在另一矩形内即可？

考虑如下情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/vx7pws9y.png)

因此还需逐一判断边是否相交。

- 圆和矩形

可以转化成点是否在一个圆角矩形内，将圆角矩形拆成四个圆和两个矩形，将点视为半径为 $0$ 的圆用上面的方法做即可。

![](https://i.imgloc.com/2023/06/01/VktG6V.th.png) ![](https://i.imgloc.com/2023/06/01/Vktd1d.th.png)

### 代码

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <queue>

using namespace std;
const int M=330,N=220000;
#define eps 1e-6
#define inf 0x3f3f3f3f

int n,S,T,idx=1,op;
double in1,in2,in3,in4,cx,cy;
int to[N],nxt[N],head[N],w[N];
int cur[N],d[N];

void add(int u,int v,int c){
    idx++;to[idx]=v;nxt[idx]=head[u];head[u]=idx;w[idx]=c;
    idx++;to[idx]=u;nxt[idx]=head[v];head[v]=idx;w[idx]=0;
}

queue <int> q;

bool bfs(){
    memset(d,-1,sizeof d);
    while(!q.empty()) q.pop();
    cur[S]=head[S];
    q.push(S);d[S]=0;
    while(!q.empty()){
        int now=q.front();q.pop();
        for(int i=head[now];i;i=nxt[i]){
            int v=to[i];
            if(~d[v]||!w[i]) continue;
            d[v]=d[now]+1;
            cur[v]=head[v];
            if(v==T) return 1;
            q.push(v);
        }
    }
    return 0;
}

int dfs(int s,int lim){
    if(s==T) return lim;
    int flow=0;
    for(int i=cur[s];i&&flow<lim;i=nxt[i]){
        int v=to[i];cur[s]=i;
        if(d[v]!=d[s]+1||!w[i]) continue;
        int t=dfs(v,min(w[i],lim-flow));
        if(!t) d[v]=-1;
        w[i]-=t;w[i^1]+=t;flow+=t;
    }
    return flow;
}

int dinic(){//dinic 板子
    int ans=0,flow=0;
    while(bfs()) while(flow=dfs(S,inf)) ans+=flow;
    return ans;
}

struct Node{
    int type;//1代表圆，2代表矩形，3表示线段
    double x1,y1,x2,y2,r;
}a[M];

double dis_two_points(double x1,double y1,double x2,double y2){//计算两点距离
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

bool Point_Rec(double x1,double y1,Node a){//判断点是否在矩形内
    return (x1>a.x1-eps)&&(x1<a.x2+eps)&&(y1>a.y1-eps)&&(y1<a.y2+eps);
}

bool Lin_Int(Node a,Node b){//判断特定直线是否相交
    return (a.x1<=b.x1&&b.x1<=a.x2)&&(b.y1<=a.y1&&a.y1<=b.y2);
}

bool Cyc_Int(Node a,Node b){//判断圆是否相交
    return dis_two_points(a.x1,a.y1,b.x1,b.y1)<a.r+b.r+eps;
}

bool Rec_Int(Node a,Node b){//判断两个矩形是否相交
    bool res1=Point_Rec(a.x1,a.y1,b);
    bool res2=Point_Rec(a.x2,a.y2,b);
    bool res3=Point_Rec(a.x1,a.y2,b);
    bool res4=Point_Rec(a.x2,a.y1,b);//判点
    Node line1=Node{3,a.x1,a.y1,a.x2,a.y1};
    Node line2=Node{3,a.x1,a.y1,a.x1,a.y2};
    Node line3=Node{3,a.x2,a.y1,a.x2,a.y2};
    Node line4=Node{3,a.x1,a.y2,a.x2,a.y2};
    Node line5=Node{3,b.x1,b.y1,b.x2,b.y1};
    Node line6=Node{3,b.x1,b.y1,b.x1,b.y2};
    Node line7=Node{3,b.x2,b.y1,b.x2,b.y2};
    Node line8=Node{3,b.x1,b.y2,b.x2,b.y2};//两个矩形八条线
    bool res5=Lin_Int(line1,line6)||Lin_Int(line1,line7);
    bool res6=Lin_Int(line2,line5)||Lin_Int(line2,line8);
    bool res7=Lin_Int(line3,line5)||Lin_Int(line3,line8);
    bool res8=Lin_Int(line4,line6)||Lin_Int(line4,line8);//线是否相交
    return res1||res2||res3||res4||res5||res6||res7||res8;
}

bool check(Node a,Node b){
    if(a.type==1&&b.type==1) return Cyc_Int(a,b);
    if(a.type==2&&b.type==2) return Rec_Int(a,b)||Rec_Int(b,a);//考虑一个矩形在另一个矩形内的情况
    if(a.type!=b.type){
        if(a.type==2) swap(a,b);
        Node point=Node{1,a.x1,a.y1,0,0,0};
        bool res1=Cyc_Int(point,Node{1,b.x1,b.y1,0,0,a.r});
        bool res2=Cyc_Int(point,Node{1,b.x2,b.y2,0,0,a.r});
        bool res3=Cyc_Int(point,Node{1,b.x1,b.y2,0,0,a.r});
        bool res4=Cyc_Int(point,Node{1,b.x2,b.y1,0,0,a.r});//视为四个圆和两个矩形
        bool res5=Point_Rec(a.x1,a.y1,Node{2,b.x1-a.r,b.y1,b.x2+a.r,b.y2});
        bool res6=Point_Rec(a.x1,a.y1,Node{2,b.x1,b.y1-a.r,b.x2,b.y2+a.r});
        return res1||res2||res3||res4||res5||res6;
    }
    return 0;
}

int main(){
    scanf("%lf%lf%d",&cx,&cy,&n);
    for(int i=1;i<=n;i++){
        scanf("%d%lf%lf%lf",&op,&in1,&in2,&in3);
        if(op==2) scanf("%lf",&in4);
        if(op==1) a[i]=Node{1,in1,in2,0,0,in3};
        if(op==2) a[i]=Node{2,in1,in2,in3,in4};
    }
    S=N-5;T=N-6;
    a[n+1]=Node{2,-inf,cy,inf,inf};//上下边界可以当作两个无穷大的矩形
    a[n+2]=Node{2,-inf,-inf,inf,0};
    for(int i=1;i<=n;i++){
        if(check(a[n+1],a[i])) add(S,2*i-1,inf);
        if(check(a[n+2],a[i])) add(2*i,T,inf);
        add(2*i-1,2*i,1);//入点和出点
        for(int j=i+1;j<=n;j++)//暴力加边即可
            if(check(a[i],a[j])){
                add(2*i,2*j-1,inf);
                add(2*j,2*i-1,inf);
            }
    }  
    cout<<dinic()<<'\n'; 
    return 0;
}
```

---

## 作者：mqmhaaaa1 (赞：6)

6h，整整 6h 啊，终于调出来了（哭泣）

回归正题。

# 分析

看到题面就知道是一道十分（十分十分）恶心的题。

在解决本题之前有个命题要知道：**水能过的地方光线就能通过**。

也就是说，本题的目标为，**拿走最少的仪器，使通道内有哪怕一丁点空隙**。

在思考发现，我们可以把通道的上边与下边看作**汇点（下称 $t$）** 与 **源点（下称 $s$）**

把每个仪器当点，如果两个仪器之间有交接，就连边，然后拆点跑最小割。

为什么这样做？

其实很好理解。我们把连在仪器的仪器连边，如果与通道上下有交接就连边，当 $s$ 能到达 $t$ 时，就相当于有连在一起的仪器完全堵住了通道，割掉最少的点就等于取走最少的仪器使通道左右连通。

但是，接下来才是最恶心的地方。

# 判断图形相交（情绪激动

这一点我弄了很久（5h），在尝试了多种办法后发现还是分类讨论比较正确且好理解。

## 1.两个都是圆形

特别简单，我们只要求出两圆心的距离并判断两个圆的半径和是否大于等于两圆心距离就行（这个不懂还是先学好课内数学吧）

## 2.两个都是矩形

这个也是简单的分类讨论，大概就是枚举这两个矩形的每一条边，看他们相不相交，我写的比较长，事实上可以很短。

## 3.一圆一方

这个可以分三种讨论：

### 1.矩形的某点在圆内

我们可以把一个顶点看作半径为 $0$ 的圆，然后同上求圆相交的方法做。 

### 2.圆与矩形的某边相交

这个也简单，我们可以枚举矩形每条边，然后再判断圆与矩形的位置（自己想想，简单的很），不理解看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4xw0oblb.png)

当圆心与某边垂直距离不超过半径且圆心坐标在矩形坐标范围内，则圆方相交。

### 3.圆心在矩形内

这个直接判断就行了，简单

接下来......

# 巨恶心的细节

1.完全在通道外的图形没有用，把它扔掉（挂两发）

2.如果你 WA 6，7 记得把所有变量初始成 $0$（从第一发挂到 AC）

3.开 **long double** （没挂，但有人会挂）

4.把算式写对（调不死我）

看看代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
const ll N=5e3+10,M=2e6+10,inf=0x3f3f3f3f;
ll to[M<<1],nxt[M<<1],w[M<<1],bh[N],tot=1;
ll head[N],st[N];
bool vis[N];
inline void add(ll u,ll v,ll z){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	bh[u]=tot;
//	cout<<u<<" "<<v<<" "<<z<<'\n';
	to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	bh[v]=tot;
}
ll s,t;
inline bool bfs(){
	for(ll i=s;i<=t;i++){
		head[i]=bh[i];
		vis[i]=0;
		st[i]=0;
	}
	queue<ll>q;
	q.push(s);
	st[s]=0;vis[s]=1;
	while(q.size()){
		ll u=q.front();q.pop();
//		cout<<u<<'\n';
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&!st[v]&&v!=s){
				st[v]=st[u]+1;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return st[t];
}
ll mxf=0;
ll dic(ll u,ll flow){
//	cout<<u<<" "<<flow<<'\n';
	vis[u]=1;
	if(u==t){
		mxf+=flow;return flow;
	}
	ll zy=0;
	for(ll i=head[u];i&&flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&(!vis[v]||v==t)&&st[v]==st[u]+1){
			ll jb=dic(v,min(w[i],flow));
			w[i]-=jb,w[i^1]+=jb;
			zy+=jb;flow-=jb;
			if(!flow)break;
		}
	}
	vis[u]=0;
	return zy;
}
//以上本人优质dinic板子 
struct zb{
	ld x,y;
	void csh(){
		x=y=0;
	}
};
zb getzb(zb u1,zb u2,zb v1,zb v2){//交点坐标公式 
	ld a1,a2,a3,b1,b2,b3;
	ld t;
	zb ans;ans.csh();
	a1=v2.y-v1.y;
	a2=v1.y-u1.y;
	a3=u2.y-u1.y;
	b1=v2.x-v1.x;
	b2=v1.x-u1.x;
	b3=u2.x-u1.x;
	t=(a3*b2-a2*b3)/(a1*b3-a3*b1);
	ans.x=(v2.x-v1.x) * t + v1.x;
	ans.y=(v2.y-v1.y) * t + v1.y;
	return ans;
}
ld len(zb u,zb v){//两点长度公式 
	return sqrtl((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));
}
//ld abs(ld jb){
//	if(jb>0)return jb;
//	else return -jb;
//}
struct yj{
	ll zt;ld x1,y1,x2,y2;ld x,y,r;
	void csh(){
		zt=x1=y1=x2=y2=0;
		x=y=r=0;
	}
}jjbb[N];
ld cx,cy;ll n;
zb A,B,C,D;
bool checkf(yj u,yj v){//方 
	zb jd;
	// u左v上 
	jd=getzb((zb){u.x1,u.y1},(zb){u.x1,u.y2},(zb){v.x2,v.y2},(zb){v.x1,v.y2});
	if(u.y1<=jd.y&&jd.y<=u.y2&&v.x1<=jd.x&&jd.x<=v.x2)return 1;
	//u左v下 
	jd=getzb((zb){u.x1,u.y1},(zb){u.x1,u.y2},(zb){v.x1,v.y1},(zb){v.x2,v.y1});
	if(u.y1<=jd.y&&jd.y<=u.y2&&v.x1<=jd.x&&jd.x<=v.x2)return 1;
	//u右v上
	jd=getzb((zb){u.x2,u.y1},(zb){u.x2,u.y2},(zb){v.x2,v.y2},(zb){v.x1,v.y2});
	if(u.y1<=jd.y&&jd.y<=u.y2&&v.x1<=jd.x&&jd.x<=v.x2)return 1;
	//u右v下
	jd=getzb((zb){u.x2,u.y1},(zb){u.x2,u.y2},(zb){v.x1,v.y1},(zb){v.x2,v.y1});
	if(u.y1<=jd.y&&jd.y<=u.y2&&v.x1<=jd.x&&jd.x<=v.x2)return 1; 
	
	//u上v左
	jd=getzb((zb){u.x1,u.y2},(zb){u.x2,u.y2},(zb){v.x1,v.y2},(zb){v.x1,v.y1});
	if(u.x1<=jd.x&&jd.x<=u.x2&&v.y1<=jd.y&&jd.y<=v.y2)return 1;
	//u上v右
	jd=getzb((zb){u.x1,u.y2},(zb){u.x2,u.y2},(zb){v.x2,v.y2},(zb){v.x2,v.y1});
	if(u.x1<=jd.x&&jd.x<=u.x2&&v.y1<=jd.y&&jd.y<=v.y2)return 1;
	//u下v左
	jd=getzb((zb){u.x1,u.y1},(zb){u.x2,u.y1},(zb){v.x1,v.y2},(zb){v.x1,v.y1});
	if(u.x1<=jd.x&&jd.x<=u.x2&&v.y1<=jd.y&&jd.y<=v.y2)return 1;
	//u下v右
	jd=getzb((zb){u.x1,u.y1},(zb){u.x2,u.y1},(zb){v.x2,v.y2},(zb){v.x2,v.y1});
	if(u.x1<=jd.x&&jd.x<=u.x2&&v.y1<=jd.y&&jd.y<=v.y2)return 1;
	return 0;
}
bool checky(yj u,yj v){//圆 
	return len((zb){u.x,u.y},(zb){v.x,v.y})<=u.r+v.r;
}
bool checkyf(yj u,yj v){//圆方 
	//点 
	yj dian;dian.csh();
	//左下 
	dian.x=v.x1;dian.y=v.y1;
	if(checky(u,dian))return 1;
	//左上
	dian.x=v.x1;dian.y=v.y2;
	if(checky(u,dian))return 1;
	//右下 
	dian.x=v.x2;dian.y=v.y1;
	if(checky(u,dian))return 1;
	//右上
	dian.x=v.x2;dian.y=v.y2;
	if(checky(u,dian))return 1;
	
	//左边 
	if(abs(v.x1-u.x)<=u.r&&v.y1<=u.y&&u.y<=v.y2)return 1;
	//右边 
	if(abs(v.x2-u.x)<=u.r&&v.y1<=u.y&&u.y<=v.y2)return 1;
	//上边 
	if(abs(v.y2-u.y)<=u.r&&v.x1<=u.x&&u.x<=v.x2)return 1;
	//下边 
	if(abs(v.y1-u.y)<=u.r&&v.x1<=u.x&&u.x<=v.x2)return 1;
	
	//圆心
	if(v.x1<=u.x&&u.x<=v.x2&&v.y1<=u.y&&u.y<=v.y2)return 1;
	return 0; 
}
inline bool pand(yj u,yj v){//判断相交 
	if(!u.zt||!v.zt)return 0;
	if(u.zt==v.zt){
		if(u.zt==1){
			return checky(u,v);
		}else{
			return checkf(u,v);
		}
	}else{
		if(u.zt==1){
			return checkyf(u,v);
		}else return checkyf(v,u);
	}
	//分讨 
} 
//zuoxia x1,y1 zuoshang x1,y2
//youxia x2,y1 youshang x2,y2
int main(){
	cx=read();cy=read();n=read();
	s=0;t=n*2+1;
	for(ll i=1;i<=n;i++){
		ll zt=read();
		jjbb[i].zt=zt;
		ll ui=i,uo=i+n;
		add(ui,uo,1);
		if(zt==1){
			jjbb[i].x=read(),jjbb[i].y=read(),jjbb[i].r=read();
			if((ld)abs(cy-jjbb[i].y)<=jjbb[i].r)add(uo,t,inf);
			if((ld)abs(jjbb[i].y)<=jjbb[i].r)add(s,ui,inf);
		}else{
			jjbb[i].x1=read();jjbb[i].y1=read();jjbb[i].x2=read();jjbb[i].y2=read();
			if(jjbb[i].y1<=0&&jjbb[i].y2>=0)add(s,ui,inf);
			if(jjbb[i].y1<=cy&&jjbb[i].y2>=cy)add(uo,t,inf);
		}
		//判断与上面或下面相交 
		if((jjbb[i].x1>cx&&)){
			jjbb[i].csh();
			
		}//没用的东西~ 
	}
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=n;j++){
			if(i==j)continue;
			ll uo=i+n,vi=j;
			bool flag=pand(jjbb[i],jjbb[j]);
//			cout<<i<<' '<<j<<' '<<flag<<'\n';
			if(!flag)continue;
			add(uo,vi,inf);
		}
	}//判断相交，记住是双向边 
	while(bfs()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof vis);
			dic(s,inf);
		}
	}
	cout<<mxf;
}
//PURE MEMORY 
```

本人第一黑题解，也是第一道独立完成的黑，thankyou for your reading。

---

## 作者：SfumatoCannon_ (赞：6)

### Part 0. 吐槽

黑题首A祭，发个题解纪念一下qwq

本题紧扣现实生活，题面简洁明了，连小学生都能看懂；考察知识点全面，不仅将网络流与题目巧妙地结合在一起，还考察了矩形碰撞检测相关知识，为答题者将来的```2D```游戏开发打下了基础。总而言之，本题真可谓是简约而深邃的一道妙题（逃

### Part 1. 题目大意

在一个镜面通道中有一些**表面是镜面**的光学元件，可以互相重叠，请问最少删掉多少个元件，就能使得光线能从这一头到达另一头？

### Part 2.问题分析

首先这道题目为了吓唬你，构建了一个这样的例子：

![](https://cdn.luogu.com.cn/upload/pic/17614.png)

然而我们可以发现，它并没有要求让你构建出一条这样的光线来，我们需要做的只是**确保通道能透光**就行了。

那么，怎么样子才能确保通道能透光呢？答案是：确保**它的中间有缝隙**就行了。

这又是为什么呢？因为题目有两个条件：

* 光线可以从最左端的任意一个位置、任意一个角度射入。

* 光学仪器和通道的上下面是镜子做的，所以不会把光吸收。

所以，对于任何一个位置，光子都可以从任意角度射出，只要中间有缝隙，它就可以到达任何地方。

那么，我们又如何才能使得中间有缝隙产生呢？

其实很简单：

![](https://cdn.luogu.com.cn/upload/image_hosting/im67zb2r.png)

如图，对于互相产生接触的两个图形，我们把它们所代表的点连接起来；对于和镜面通道的上下两端产生接触的图形，我们把它们分别和原点、汇点连接起来。于是，问题就转化为：**最多删去几个点**，使得```S```和```T```不连通。

显而易见，这就是个典型的最小割问题。

于是，这道题最难的部分就得到解决了。注意这里是删点而不是删边，所以要拆点，拆点的过程就不再阐述了。

下面我们来到了这道题第二难的部分：如何判断两个图形互相产生接触？

如果是两个圆形，挺好办的，根据初中数学，求圆心之间的距离是否小于等于半径之和即可

如果是两个矩形，也挺好办的，最简单粗暴的办法是：判断矩形的四个点中是否有点落在另一个矩形中即可。（当然你也可以优化一下）

问题是：一个矩形和一个圆形的情况该如何解决？

考虑到矩形的四条边**均平行于坐标轴**，我给大家带来一种比较易于理解的办法。

先来看看三个条件：

* ```条件A```：矩形是否没有任何一个顶点落在圆的内部？

* ```条件B```：以圆心为原点构建直角坐标系，矩形对角线上的两个顶点是否都在该坐标系的同一象限？

* ```条件C```：矩形是否和圆的外接正方形产生接触？

如果```条件C```不满足，那它们一定不会产生碰撞

如果```条件A```不满足（有顶点落在圆内），那它们一定会产生碰撞

当```条件C```和```条件A```同时满足的时候，我们再来看```条件B```

如果```条件B```满足，那么它们不会产生碰撞；否则会产生碰撞。

自己画画图模拟一下，你会发现确实如此。

于是我们就成功解决了这个问题。

还有一个无足轻重的小问题：如何判断图形和通道的上下两边接触？

再创建两个图形，分别表示它的上下两条“线”就行了。

### Part 3.代码

内附注释，可读性挺强

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
#define KIND_CIRCLE 0
#define KIND_RECTANGLE 1
#define INF 0x7fffffff
#define MAXN 10001
#define MAXM 2000001

/////////////////////global
double cx, cy;
int n;

/////////////////////object
class Object
{
public:
    bool kind; //0->circle 1->rectangle
    double x;
    double y;
    double width;
    double height;
    double radius;
    bool isCrashed(Object obj);
    Object()
    {
        kind = false;
        x = y = width = height = radius = 0;
    }
};
Object objectList[MAXN];
double distance(double x1, double y1, double x2, double y2)
{
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
bool isCrashed_Rectangle(double x1, double y1, double width1, double height1,
                         double x2, double y2, double width2, double height2)
{
    return x1 <= x2 + width2 && x2 <= x1 + width1 && y1 >= y2 - height2 && y2 >= y1 - height1;
}
bool isCrashed_Circle(double x1, double y1, double radius1,
                      double x2, double y2, double radius2)
{
    return distance(x1, y1, x2, y2) <= radius1 + radius2;
}
bool isCrashed_RectangleAndCircle(double rectx, double recty, double rectwidth, double rectheight,
                                  double cirx, double ciry, double cirradius)
{
    double x1, y1, x2, y2, cirrectx, cirrecty, cirrectwidth, cirrectheight;
    x1 = rectx;
    x2 = rectx + rectwidth;
    y1 = recty;
    y2 = recty - rectheight; //注意y轴上加下减
    cirrectx = cirx - cirradius;
    cirrecty = ciry + cirradius; //注意y轴上加下减
    cirrectheight = cirrectwidth = cirradius * 2;
    bool flagA;                         //条件A:矩形没有任何一个点落在圆内（到圆心的距离大于半径）
    bool flagB;                         //条件B:矩形对角线上的两个顶点都在圆心的同一象限
    int sideX1, sideY1, sideX2, sideY2; //条件B的辅助变量,1为正方向,-1为负方向
    bool flagC;                         //条件C:矩形和圆的外接正方形产生接触
    if (distance(x1, y1, cirx, ciry) > cirradius &&
        distance(x1, y2, cirx, ciry) > cirradius &&
        distance(x2, y1, cirx, ciry) > cirradius &&
        distance(x2, y2, cirx, ciry) > cirradius)
        flagA = true;
    else
        flagA = false;
    sideX1 = x1 - cirx > 0 ? 1 : -1;
    sideY1 = y1 - ciry > 0 ? 1 : -1;
    sideX2 = x2 - cirx > 0 ? 1 : -1;
    sideY2 = y2 - ciry > 0 ? 1 : -1;
    if (sideX1 == sideY1 && sideX2 == sideY2)
        flagB = true;
    else
        flagB = false;
    if (isCrashed_Rectangle(rectx, recty, rectwidth, rectheight,
                            cirrectx, cirrecty, cirrectwidth, cirrectheight))
        flagC = true;
    else
        flagC = false;
    if (!flagC)
        return false;
    else if (!flagA)
        return true;
    else if (flagB)
        return false;
    else
        return true;
}
bool Object::isCrashed(Object obj)
{
    if (kind == KIND_CIRCLE)
    {
        if (obj.kind == KIND_CIRCLE)
            return isCrashed_Circle(x, y, radius, obj.x, obj.y, obj.radius);
        else //KIND_RECTANGLE
            return isCrashed_RectangleAndCircle(obj.x, obj.y, obj.width, obj.height, x, y, radius);
    }
    else //KIND_RECTANGLE
    {
        if (obj.kind == KIND_CIRCLE)
            return isCrashed_RectangleAndCircle(x, y, width, height, obj.x, obj.y, obj.radius);
        else //KIND_RECTANGLE
            return isCrashed_Rectangle(x, y, width, height, obj.x, obj.y, obj.width, obj.height);
    }
}

/////////////////////network_flow
struct Edge
{
    int next, to, dis;
} bian[MAXM];
int h[MAXN], used[MAXN], dep[MAXN];
int s, t;
int temp = 1;
void add(int from, int to, int dis)
{
    temp++;
    bian[temp].dis = dis;
    bian[temp].next = h[from];
    bian[temp].to = to;
    h[from] = temp;
}
void addE(int from, int to, int dis)
{
    add(from, to, dis);
    add(to, from, 0);
}
bool bfs()
{
    int x, i;
    queue<int> Q;
    Q.push(s);
    memset(dep, 0, sizeof(dep));
    dep[s] = 1;
    while (!Q.empty())
    {
        x = Q.front();
        Q.pop();
        for (i = h[x]; i; i = bian[i].next)
            if (bian[i].dis != 0 && dep[bian[i].to] == 0)
            {
                dep[bian[i].to] = dep[x] + 1;
                Q.push(bian[i].to);
            }
    }
    return dep[t] != 0;
}
int dfs(int x, int in)
{
    int out = 0, i, k;
    if (x == t)
        return in;
    for (i = used[x]; i && in != 0; i = bian[i].next, used[x] = i)
    {
        if (bian[i].dis != 0 && dep[bian[i].to] == dep[x] + 1)
        {
            k = dfs(bian[i].to, min(bian[i].dis, in));
            bian[i].dis -= k;
            bian[i ^ 1].dis += k;
            in -= k;
            out += k;
        }
    }
    if (out == 0)
        dep[x] = 0;
    return out;
}
int getId(int depth, int x)
{
    return (depth - 1) * 500 + x;
}

/////////////////////main
int main()
{
    scanf("%lf%lf", &cx, &cy);
    scanf("%d", &n);
    int x, i, j, x1, y1, x2, y2;
    //create "line"
    Object upObject, downObject;
    upObject.kind = KIND_RECTANGLE;
    upObject.x = 0;
    upObject.y = cy;
    upObject.width = cx;
    upObject.height = 0;
    downObject.kind = KIND_RECTANGLE;
    downObject.x = 0;
    downObject.y = 0;
    downObject.width = cx;
    downObject.height = 0;
    //build network
    s = MAXN - 2;
    t = MAXN - 1;
    for (i = 1; i <= n; i++)
        addE(getId(1, i), getId(2, i), 1);

    for (i = 1; i <= n; i++)
    {
        //read object data
        scanf("%d", &x);
        if (x == 1) //circle
        {
            objectList[i].kind = KIND_CIRCLE;
            scanf("%lf%lf%lf", &objectList[i].x, &objectList[i].y, &objectList[i].radius);
        }
        else //rectangle
        {
            objectList[i].kind = KIND_RECTANGLE;
            scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
            objectList[i].x = x1;
            objectList[i].y = y2;
            objectList[i].width = x2 - x1;
            objectList[i].height = y2 - y1;
        }
        //build network
        for (j = 1; j <= i - 1; j++)
        {
            if (objectList[i].isCrashed(objectList[j]))
            {
                addE(getId(2, i), getId(1, j), INF);
                addE(getId(2, j), getId(1, i), INF);
            }
        }
    }
    //build network
    for (i = 1; i <= n; i++)
    {
        if (objectList[i].isCrashed(upObject))
            addE(s, getId(1, i), INF);
        if (objectList[i].isCrashed(downObject))
            addE(getId(2, i), t, INF);
    }
    //dinic
    int ans = 0;
    while (bfs())
    {
        memcpy(used, h, sizeof(h));
        ans += dfs(s, INF);
    }
    printf("%d", ans);
    return 0;
    //完结撒花awa
}
```

---

## 作者：ysy20021208 (赞：6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**在物理上有一个定理，只要水能通过的地方，光就能通过。对于这道题，就是只要$S$和$T$联通光就能通过。这样我们就可以将问题从“最少拿走多少个光学元件后，存在一条光线线路可以从CD射出”转化为“最少拿走多少个关学元件后，$AC$和$BD$不连通”。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转化后的问题似乎就好解决了。我们现在考虑，转化后的问题怎么建图，我们把每一个光学元件拆成入点和出点，这两个点之间连边，边权为$1$。对于$S$和元件、$T$和元件之间的连边，如果当前元件和$BD$有交点，测当前元件和$S$连边，边权为$inf$；如果当前元件和$AC$有交点，则当前元件和$T$连边，边权为$inf$。对于两个光学元件之间，如果这两个元件之间相交我们就把这两个点用一条边权为$inf$的边连在一起。现在难点不是如何建图，而是怎么判断两个光学元件相交。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个光学元件是同一种光学元件的这种情况比较好判断，分别就是矩形相交的判断和圆形相交的判断，但是对于这两个混在一起就不好判断了。圆形和矩形相交一共分为四种情况：1.矩形的一个角在圆形之中，这样我们直接用点和圆的关系进行判断就可以了。2.圆形在矩形两侧，但是矩形没有角在圆形里，对于这种情况我们先要判断圆心是不是在矩形的上下边所在直线之间，若不是，这种情况一定不成立，若是我们还需要判断矩形的左右边所在直线直线是不是有一条经过圆形，这个直接用直线于圆的位置关系就可以。3.第三种情况和第二种情况基本一样，就是把圆形在矩形的左右变成圆形在矩形的上下。4.圆形在矩形中间，对于这种情况，我们就只需要判断圆心是不是在矩形之内就好。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 610
#define inf 1000000000
int n,m,x,y,lab,s,t,dis[N],ans,kind[N],a[N],b[N],c[N],d[N];
int cur[N],head[N],to[N*N<<1],nxt[N*N<<1],val[N*N<<1],idx=1;
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs()
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {int tmp=0;while(bfs())
    {memcpy(cur,head,sizeof head);while((tmp=dfs(s,inf))!=0) ans+=tmp;}}
int pla(int i,int j) {return (i-1)*m+j;}
long long squ(int x) {return 1ll*x*x;}
bool line1(int i,int j)
{
    if(min(a[j],a[i])!=a[i]||max(a[j],c[i])!=c[i]) return false;
    if(min(b[j],b[i])==b[i]&&max(b[j],d[i])==d[i]) return true;
    return squ(b[j]-b[i])<=squ(c[j])||squ(b[j]-d[i])<=squ(c[j]);
}
bool line2(int i,int j)
{
    if(min(b[j],b[i])!=b[i]||max(b[j],d[i])!=d[i]) return false;
    return squ(a[j]-a[i])<=squ(c[j])||squ(a[j]-c[i])<=squ(c[j]);
}
bool point(int i,int j)
{
    return squ(a[i]-a[j])+squ(b[i]-b[j])<=squ(c[j])||
        squ(a[i]-a[j])+squ(d[i]-b[j])<=squ(c[j])||
        squ(c[i]-a[j])+squ(d[i]-b[j])<=squ(c[j])||
        squ(c[i]-a[j])+squ(b[i]-b[j])<=squ(c[j]);
}
bool meet(int i,int j)
{
    if(kind[i]==1&&kind[j]==1) return squ(a[i]-a[j])+squ(b[i]-b[j])<=squ(c[i]+c[j]);
    if(kind[i]==2&&kind[j]==2)
        return min(c[i],c[j])>=max(a[i],a[j])&&min(d[i],d[j])>=max(b[i],b[j]);
    if(kind[i]==1) swap(i,j);
    return line1(i,j)||line2(i,j)||point(i,j);
}
bool up(int i)
    {if(kind[i]==1) return b[i]+c[i]>=y; return d[i]>=y;}
bool down(int i)
    {if(kind[i]==1) return b[i]-c[i]<=0; return b[i]<=0;}
int main()
{
    scanf("%d%d%d",&x,&y,&n),s=n*2+1,t=n*2+2;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d%d",&kind[i],&a[i],&b[i],&c[i]);
        if(kind[i]==2) scanf("%d",&d[i]);
    }
    for(int i=1;i<=n;i++) add(i,i+n,1),add(i+n,i,0);
    for(int i=1;i<=n;i++) if(down(i)) add(s,i,inf),add(i,s,0);
    for(int i=1;i<=n;i++) if(up(i)) add(i+n,t,inf),add(t,i+n,0);
    for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) if(meet(i,j))
        add(i+n,j,inf),add(j,i+n,0),add(j+n,i,inf),add(i,j+n,0);
    dinic(),printf("%d\n",ans);
}
```

---

## 作者：Nt_Tsumiki (赞：2)

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P3260)

给你一个有长度的通道，现在通道里面放着一些圆形和矩形物品，问你拿走多少个物品后，一束光可以射入通道后射出。

保证矩形的上下两边平行通道上下两边。


## 前置芝士

点积：

数学意义为两个向量模长的乘积，再乘上夹角的余弦，即 $\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\cos\theta=x_1x_2+y_1y_2$。

当夹角 $\theta$ 为钝角时，结果为负。

```cpp
double Dot(poi x,poi y) { return x.x*y.x+x.y*y.y; }
```

叉积：

数学意义为两个向量模长的乘积，再乘上夹角的正弦，
即 $\vec{a}\times\vec{b}=|\vec{a}||\vec{b}|\sin\theta=x_1y_2-x_2y_1$。

当角度为负时，结果为负。

其值也等于两个向量围成的的平行四边形面积，如下图的阴影面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/763hrgdt.png)

```cpp
double Cro(poi x,poi y) { return x.x*y.y-x.y*y.x; }
```

## 做法

先给出一个结论：光线可以从任何缝隙中射入并射出。

所以这道题就变成了，求最少拿走多少个物品后，通道中会出现缝隙。

当我们把它抽象成图后就会发现，求得实际就是这个图的最小割。

### 建图

因为是拿物品所以用到拆点。

关于物品之间的连边，圆和圆不用多说，直接判两个圆心距离和半径和的大小。

关键在于矩形。

矩形和矩形判相交可以用到计算几何去判，代码如下。

```cpp
bool is_SS(S x,S y) {
	double t1=Cro(x.x-y.x,x.y-y.x),t2=Cro(x.x-y.y,x.y-y.y);
	double t3=Cro(y.x-x.x,y.y-x.x),t4=Cro(y.x-x.y,y.y-x.y);
	return ((t1<0)^(t2<0)) and ((t3<0)^(t4<0));
}
```

其中 ```Cro()``` 是叉积。

原理如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/hznasf1y.png)

如果两条线段相交，那么一条线段的两点必定在另一条线段两侧，即叉积必定一正一负，所以用叉积判断即可。

矩形和圆判相交依旧可以用计算几何，代码如下。

```cpp
double PS(poi x,S y) {
    if (Dot(x-y.x,y.y-y.x)<0) return dis(x,y.x);
    if (Dot(x-y.y,y.x-y.y)<0) return dis(x,y.y);
    return abs(Cro(y.x-x,y.y-x))/dis(y.x,y.y);
}
```

原理为，如果一个点到这条线段的投影在这条线段上，那么答案就为垂线段的长度（用叉积求出三角形面积后除以线段长度即可），否则就看这个点距离线段两端哪个点最近，输出这两点距离即可（显而易见，当一个点的投影不在线段上时，这个点到一个端点的连线与线段的夹角必然是钝角，即点积为负，而那个端点就是离它最近的点，所以可以用点积去判）。

还有去判与通道上下界是否相交和上面介绍的一样，就不多说了。

但是当你交上上面的代码时，却发现并没有 AC。

问题出在函数 ```is_SS()```，当出现下图的情况时：

![](https://cdn.luogu.com.cn/upload/image_hosting/accpoeg5.png)

因为两条线段端点重合的缘故导致叉积出现了 $0$，所以需要加一个特判去特判 $0$ 的情况，代码如下。

```cpp
bool is_SS(S x,S y) {
	double t1=Cro(x.x-y.x,x.y-y.x),t2=Cro(x.x-y.y,x.y-y.y);
	double t3=Cro(y.x-x.x,y.y-x.x),t4=Cro(y.x-x.y,y.y-x.y);
	if((t1==0 or t2==0) and (t3==0 or t4==0)) return 1;
	return ((t1<0)^(t2<0)) and ((t3<0)^(t4<0));
}
```

## Code

```cpp
// 无注释纯享版
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>

#define INF 1145141919

namespace Dinic {
    struct Node { int to,nxt,dis; }e[1000001];

    int tot=1,s,t,head[10005],vis[10005],cur[10005];

    void add(int x,int y,int k) { e[++tot]=(Node){y,head[x],k},head[x]=tot; }

    bool bfs() {
        std::memset(vis,0,sizeof vis);
        std::queue<int> q; q.push(s); vis[s]=1;
        while (!q.empty()) {
            int x=q.front(); q.pop();
            for (int i=head[x];i;i=e[i].nxt) {
                int y=e[i].to; cur[x]=head[x];
                if (e[i].dis and !vis[y]) {
                    vis[y]=vis[x]+1;
                    q.push(y);
                }
            }
        }
        return vis[t];
    }

    int dfs(int x,int flow) {
        if (x==t) return flow;
        int res=0;
        for (int i=cur[x];i and flow;i=e[i].nxt) {
            int y=e[i].to; cur[x]=i;
            if (e[i].dis and vis[y]==vis[x]+1) {
                int k=dfs(y,std::min(e[i].dis,flow));
                e[i].dis-=k,e[i^1].dis+=k,res+=k,flow-=k;
            }
        }
        return res;
    }
}
using namespace Dinic;
using namespace std;
int n,anum,bnum,cnt;
int pa[100001][2],pb[100001][2];

struct poi{ double x,y; }c;
struct C{ double r; poi o; }a[100001];
struct S{ poi x,y; }A,B;
struct R{ poi a[4]; }b[100001];

double Dot(poi x,poi y) { return x.x*y.x+x.y*y.y; }
double Cro(poi x,poi y) { return x.x*y.y-x.y*y.x; }
double dis(poi x,poi y) { return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y)); }

poi operator - (poi x,poi y) { return (poi){x.x-y.x,x.y-y.y}; }

double PS(poi x,S y) {
    if (Dot(x-y.x,y.y-y.x)<0) return dis(x,y.x);
    if (Dot(x-y.y,y.x-y.y)<0) return dis(x,y.y);
    return abs(Cro(y.x-x,y.y-x))/dis(y.x,y.y);
}

bool is_SS(S x,S y) {
	double t1=Cro(x.x-y.x,x.y-y.x),t2=Cro(x.x-y.y,x.y-y.y);
	double t3=Cro(y.x-x.x,y.y-x.x),t4=Cro(y.x-x.y,y.y-x.y);
	if((t1==0 or t2==0) and (t3==0 or t4==0)) return 1;
	return ((t1<0)^(t2<0)) and ((t3<0)^(t4<0));
}

int main() {
    scanf("%lf%lf",&c.x,&c.y);
    A=(S){(poi){0,0},(poi){c.x,0}},B=(S){(poi){0,c.y},c};
    scanf("%d",&n);
    for (int i=1,op,x1,y1,x2,y2;i<=n;i++) {
        scanf("%d",&op);
        if (op==1) {
            ++anum;
            scanf("%lf%lf%lf",&a[anum].o.x,&a[anum].o.y,&a[anum].r);
        }
        else {
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            ++bnum;
            b[bnum].a[0].x=b[bnum].a[3].x=x1,b[bnum].a[1].x=b[bnum].a[2].x=x2;
            b[bnum].a[3].y=b[bnum].a[2].y=y1,b[bnum].a[0].y=b[bnum].a[1].y=y2;
        }
    }
    for (int i=1;i<=anum;i++) {
        pa[i][0]=++cnt,pa[i][1]=++cnt;
        add(pa[i][0],pa[i][1],1),add(pa[i][1],pa[i][0],0);
    }
    for (int i=1;i<=bnum;i++) {
        pb[i][0]=++cnt,pb[i][1]=++cnt;
        add(pb[i][0],pb[i][1],1),add(pb[i][1],pb[i][0],0);
    }
    t=cnt+1;
    for (int i=1;i<=anum;i++) {
        double tmp=PS(a[i].o,A);
        if (tmp<=a[i].r) add(s,pa[i][0],INF),add(pa[i][0],s,0);
        tmp=PS(a[i].o,B);
        if (tmp<=a[i].r) add(pa[i][1],t,INF),add(t,pa[i][1],0);
    }
    for (int i=1;i<=bnum;i++) {
        bool tb=0;
        for (int j=0;j<4;j++) tb|=is_SS(A,(S){b[i].a[j],b[i].a[(j+1)%4]});
        if (tb) add(s,pb[i][0],INF),add(pb[i][0],s,0);
        tb=0;
        for (int j=0;j<4;j++) tb|=is_SS(B,(S){b[i].a[j],b[i].a[(j+1)%4]});
        if (tb) add(pb[i][1],t,INF),add(t,pb[i][1],0);
    }
    for (int i=1;i<=anum;i++) 
        for (int j=1;j<=anum;j++) 
            if (i!=j and dis(a[i].o,a[j].o)<=a[i].r+a[j].r) add(pa[i][1],pa[j][0],INF),add(pa[j][0],pa[i][1],0);
    for (int i=1;i<=bnum;i++)
        for (int j=1;j<=bnum;j++) 
            if (i!=j) {
                bool tb=0;
                for (int k=0;k<4;k++)
                    for (int l=0;l<4;l++) tb|=is_SS((S){b[i].a[k],b[i].a[(k+1)%4]},(S){b[j].a[l],b[j].a[(l+1)%4]}); 
                if (tb) add(pb[i][1],pb[j][0],INF),add(pb[j][0],pb[i][1],0);
            }
    for (int i=1;i<=anum;i++)
        for (int j=1;j<=bnum;j++) {
            bool tb=0;
            for (int k=0;k<4;k++) tb|=(PS(a[i].o,(S){b[j].a[k],b[j].a[(k+1)%4]})<=a[i].r);
            if (tb) {
                add(pa[i][1],pb[j][0],INF),add(pb[j][0],pa[i][1],0);
                add(pb[j][1],pa[i][0],INF),add(pa[i][0],pb[j][1],0);
            }
        }
    int ans=0;
    while (bfs()) ans+=dfs(s,INF);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：xiwang (赞：2)

嗷嗷修了1个小时中间还颓了一会完了走投无路拿dalao代码挨个函数拼接提交查错

最后发现某处a打成b手残毁一生

不写个题解对不起自己了都

首先考虑一下，脑补下你用着手电真的从这么一个通道里照过来...

我们会惊奇地发现，只要这个通道能透气就能透光！

现在我们只需要解决如何判断这个通道是否透气了。

考虑将每个元件看做一个点，通道上下边界单独当成2个点

每两个相交相切（总之不通气）的元件连边，与上下边界相交相切的就与边界连边

通气的时候就是没有从上边界连到下边界的元件们

我们这么建图就是上边界到下边界不连通

还要求去掉的元件数目最少

所以就是最小割，开始愉快地套dinic板子

为了每个元件只被去掉一次，每个元件我们拆成2个点连流量为1的边

代码




```cpp
#include<bits/stdc++.h>
using namespace std;
typedef double ddf;
const int N=100000+10;
const int M=1250;
const int fuck=0x3f3f3f3f;
const int inf=0x3f3f3f3f;
int n,m,k,st,ed;
struct edge{
    int to,next,cap;
}g[N*10];
int head[M],tot=2;
void add(int st,int ed,int cp){
    g[tot].to=ed;
    g[tot].next=head[st];
    g[tot].cap=cp;
    head[st]=tot++;
}
void ins(int st,int ed,int cp,int rp){
    add(st,ed,cp);
    add(ed,st,rp);
}
struct node{
    int t,x1,y1,x2,y2,r;
    void inp(){
        scanf("%d",&t);
        if(t==1)scanf("%d%d%d",&x1,&y1,&r);
        else scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
    }
}mp[M];
int sqr(int x){
    return x*x;
}
ddf dis(int x1,int y1,int x2,int y2){
    return sqrt(sqr(x1-x2)+sqr(y1-y2));
}
bool chk(int a,int b){
    int t1=mp[a].t,t2=mp[b].t;
    if(t1==2&&t2==1){
        int x1=mp[a].x1,y1=mp[a].y1,x2=mp[a].x2,y2=mp[a].y2;//这里最后一个a打成b查了1小时
        int xx=mp[b].x1,yy=mp[b].y1,rr=mp[b].r;
        if(dis(x1,y1,xx,yy)<=rr||dis(x2,y2,xx,yy)<=rr||dis(x1,y2,xx,yy)<=rr||dis(x2,y1,xx,yy)<=rr)return 1;
        if(x1<=xx&&x2>=xx&&(abs(y1-yy)<=rr||abs(y2-yy)<=rr))return 1;
        if(y1<=yy&&y2>=yy&&(abs(x1-xx)<=rr||abs(x2-xx)<=rr))return 1;
        return 0;
    }
    else if(t1==1&&t2==1){
        return dis(mp[a].x1,mp[a].y1,mp[b].x1,mp[b].y1)<=mp[a].r+mp[b].r;
    }
    else if(t1==2&&t2==2){
        return max(mp[a].x1,mp[b].x1)<=min(mp[a].x2,mp[b].x2)&&max(mp[a].y1,mp[b].y1)<=min(mp[a].y2,mp[b].y2);
    }
    else{
        return chk(b,a);
    }
}
void init(){
    int x,y,z;
    st=1,ed=1242;
    scanf("%d%d%d",&x,&y,&n);
    int a,b,c;
    for(int i=1;i<=n;i++){
        mp[i].inp();
        for(int j=1;j<i;j++){
            if(chk(i,j)){
                ins(i+i+1,j+j,inf,0);
                ins(j+j+1,i+i,inf,0);
            }
        }
        if(mp[i].t==1){
            if(mp[i].y1-mp[i].r<=0)ins(st,i+i,inf,0);
            if(mp[i].y1+mp[i].r>=y)ins(i+i+1,ed,inf,0);
        }
        else{
            if(mp[i].y1<=0)ins(st,i+i,inf,0);
            if(mp[i].y2>=y)ins(i+i+1,ed,inf,0);
        }
        ins(i+i,i+i+1,1,0);
    }
}
int lv[N];
queue<int>q;
bool bfs(int s,int t){
    memset(lv,0,sizeof(lv));
    lv[s]=1;
    while(!q.empty())q.pop();
    q.push(s);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=g[i].next){
            int v=g[i].to;
            if(g[i].cap&& !lv[v]){
                lv[v]=lv[x]+1;
                q.push(v);
            }
        }
    }
    return lv[t];
}
int dfs(int x,int mf){
    if(!mf||x==ed)return mf;
    int tmp=0;
    for(int i=head[x];i;i=g[i].next){
        int v=g[i].to;
        if(g[i].cap&&lv[v]==lv[x]+1){
            int f=dfs(v,min(mf,g[i].cap));
            tmp+=f;
            mf-=f;
            g[i].cap-=f;
            g[i^1].cap+=f;
        }
    }
    return tmp;
}
int dinic(int s,int t){
    int r=0;
    while(bfs(s,t))r+=dfs(s,inf);
    return r;
}
int main(){
    init();
    printf("%d",dinic(st,ed));
    return 0;
}
```

---

## 作者：htlhtlhtl (赞：1)

## 前言
~~看过我题解的人都知道，我的解析是保姆级的~~\
首 A 黑题，发篇题解纪念一下。
## 正片开始
### 有关于光能否通过的物理结论
首先是一个大家都在说~~但没人知道为啥~~的结论：**水/空气能通过的地方，光就能通过。**\
我知道不少人对该结论有所质疑，题解区也确实存在很多伪证。~~证明我反正是不会证~~这里主要回应一下我周围某些人提出的**彭罗斯房间**：
- 彭罗斯房间是点光源，本题可以认为是线光源
- 彭罗斯房间说的是完全照亮，和能否通过好像是两回事
- 构造彭罗斯房间用到了凹面的椭圆（理论上你可以用无限个圆形摆成一个凹面椭圆，但本题中只有 $300$ 个，而且坐标和半径都是整数）））

反正暂且认为该结论是正确的，毕竟这也不是考察 OI 能力的重点。实在不行你把题目当成水流通道就完事儿了。

### 网络最小割

综上，要保证元件之间有空隙。什么叫作有空隙呢？\
就是不存在如下情况：通道的顶面通过依次相连的若干个元件后，连上了通道底面。\
Like this:

![看到我说明图片崩了](https://cdn.luogu.com.cn/upload/image_hosting/4wj0lgtb.png)

注意到箭头长得和有向图的边差不多。于是乎联想到图论。需要去掉最小数目的元件使上下不联通，很容易想起一个叫最小割（等于最大流）的东西。\
具体而言，将通道顶面视为源点，底面视作汇点（反之亦可），将源点连向与通道顶相交的元件，将与通道底相交的元件连向汇点，相交的元件之间连边，跑一个 dicnic 最大流即可。

注意：
- 最小割算的是边，因此要**拆点**，把每个点拆成入点跟出点，入点到出点连一条容量为 $1$ 的边，其他所有边容量都是 $\infty$（你只能改变一个元件在不在，不能改变元件在这时和其他原件的相交关系这一客观事实）。
- 上图中我的箭头画的是单向的，实际建图时相交的元件应当互相连边。

那么本题的重点肯定不是网络流的模板。

### 元件相交判定

大家都说这玩意儿恶心。其实~~确实~~也还好，至少我只调了一个小时左右。（提交了好几次只是因为数组开小了。。。）

首先，只要判断**元件的边缘相不相交**就完事了，因为两个具有完全包含关系的元件并不需要连边（确切地讲，里面那个元件甚至不会产生任何贡献）。

那么就是三个问题：
#### 圆圆相交
距离小于等于两者半径之和，两圆就相交。这个大家都知道。
#### 矩形和矩形相交
根据前人的经验，应该判断边交不交，而不是点有没有被包含。\
我个人是这样做的，感觉好写：\
最简单的思考方式是，判断两个矩形的四条边两两相不相交。进一步，很显然横边只跟竖边相交，因此有如下几种相交关系：

![图2](https://cdn.luogu.com.cn/upload/image_hosting/lxh43d85.png)

**交换红绿矩形后还要再判断一遍。**\
上图其实画得不全面，导致你可能以为有算重复的情况。事实上这 $4\times 2$ 种判定基本上一个都省不了，否则可以被 Hack。**但本题数据很水，过了不代表你一定判全了（比如我之前就没判全，还是写这篇题解的时候更正的）。**

况且这些判定代码实现并不复杂，只有红顶、红底、绿左、绿右四种边，可以考虑写一个线段相交的判定函数。`swap()` 一下两个矩形就可以复制粘贴了。

#### 圆和矩形相交
乍一看很复杂，其实也非常简单：只需要写一个线段和圆的相交函数，然后看看圆跟矩形的四条边相不相交就可以了。

所以来写线段和圆的相交函数。\
首先看圆心到线段的垂直距离，线段都是水平或竖直的，所以非常简单。\
显然，如果这个距离超过半径了，那两者一定毫不相干。
那这个距离不超过半径，两者就一定相交吗？也不一定，这条线段可以在圆的左边和右边。\
我们可以考虑这样计算：\
**找到圆和这条线段所在的直线的截线，然后看线段与截线有没有重合的部分**。截线和线段 $y$ 坐标相同，所以只需判断 $x$ 坐标的区间有没有交集就行了。

![图3](https://cdn.luogu.com.cn/upload/image_hosting/tlgy8hyh.png)

如何计算截线呢？也很简单（以线段水平为例）：

![图4](https://cdn.luogu.com.cn/upload/image_hosting/hhfjzyah.png)

如图，设圆心坐标为 $(x,y)$，线段为 $(x_1,y_1)\to(x_2,y_2)$，其中 $y_1=y_2$。\
从圆心向截线 $AB$ 作垂线，垂足为 $G$。显然该垂线长度为 $|y_1-y|$，记作 $dy$。\
由勾股定理，易知 $AG=BG=\sqrt{r^2-dy^2}$，该长度记作 $dx$ ~~微积分乱入~~。\
所以 $A(x-dx)$，$B(x+dx)$。\
你发现截线的两端都有了，很容易判断原线段与截线是否相交，而且当截线在圆心下方时，计算没有任何区别。\
线段竖直时同理，复制粘贴后字母 $x$ 都改成 $y$，$y$ 改成 $x$ 即可。\
然后你就做完啦！
## ACcode
记得：数组要开够、变量要 `double`。\
[这个 Hack 能过](https://www.luogu.com.cn/discuss/216570)。
```cpp
#include<bits/stdc++.h>
#define int long long
#define dbl double
using namespace std;
const int inf=3e12;
const int MAXN=1e6+5;//因为数组老是开小，一怒之下...... 不会 MLE 就行 
int n,s,t;//元件数量、源点和汇点
//---------------------------dicnic 网络最大流模板 
int head[MAXN];
struct edge{
	int to,nxt,w;
}e[MAXN];
int o=1;
void add(int u,int v,int w){
	e[++o]={v,head[u],w};head[u]=o;
	swap(u,v);
	e[++o]={v,head[u],0};head[u]=o;
}
int d[MAXN];
bool bfs(){
	queue<int> q;
	for(int i=1;i<=t;++i) d[i]=-1;
	d[s]=0;
	q.push(s);
	while(!q.empty()){
		int k=q.front();
		q.pop();
		for(int i=head[k];i;i=e[i].nxt){
			int v=e[i].to;
			if(d[v]==-1&&e[i].w){
				d[v]=d[k]+1;
				q.push(v);
			}
		}
	}
	return d[t]!=-1;
}
int h[MAXN];
int dfs(int x,int f){
	if(x==t||!f) return f;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].to,k;
		h[x]=i;
		if(d[v]==d[x]+1&&(k=dfs(v,min(f,e[i].w)))){
			e[i].w-=k;
			e[i^1].w+=k;
			return k;
		}
	}
	return 0;
}
//---------------------------------------

//注：不论线段还是矩形，以下全部保证 x1<x2，y1<y2 
dbl dis(dbl x1,dbl y1,dbl x2,dbl y2){ //距离函数，其实只用到一次 
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
struct line{						//为线段准备结构体 
	int op;			//表示线段是水平还是竖直，op==0 为横线，op==1 为竖线。 
	dbl x1,y1,x2,y2;//线段的两端 
	bool operator*(const line &that)const{  //重载乘号用来表示相交(有 this 就有 that，很合理吧)
		line a=*this,b=that;				//把线段重新存成 a 和 b，好写 
		if(a.op==1) swap(a,b);				//确保 a 是横线 
		if(a.x2<b.x1||a.x1>b.x1) return false;	//判断是否相交，这个不多说 
		if(b.y2<a.y1||b.y1>a.y1) return false;
		return true;
	}
	bool inrsct_circle(int x,int y,int r){ //圆和线段的相交函数，对照上面的文字来看就行 
		if(op==0){
			dbl dy=abs(y1-y);
			if(dy>r) return false;
			dbl dx=sqrt(r*r-dy*dy);
			if(x1<=x+dx&&x2>=x-dx) return true;  //判断线段和截线是否有重合部分 
			else return false;
		}
		else{
			dbl dx=abs(x1-x);
			if(dx>r) return false;
			dbl dy=sqrt(r*r-dx*dx);
			if(y1<=y+dy&&y2>=y-dy) return true;
			else return false;
		}
	}
}S,T;		//通道顶和通道底也是线段 
struct obj{  //元件 
	int op;		//元件类型，op==1 是圆，op==2 是矩形，跟题目是一样一样的 
	dbl x,y,r;	//圆需要的圆心坐标和半径 
	dbl x1,y1,x2,y2;//矩形的左下角和右上角。 
	void rin(){		//读入 
		cin>>op;
		if(op==1) cin>>x>>y>>r;
		else cin>>x1>>y1>>x2>>y2;//注意输入的是左下角和右上角！！不要搞错了 
	}
	bool operator*(const obj &that)const{  	//用乘号表示两元件是否相交 
		obj a=*this,b=that;					//把元件重新存成 a 和 b，好写 
		if(a.op==1&&b.op==1){			//圆圆相交 
			return dis(a.x,a.y,b.x,b.y)<=a.r+b.r;
		}
		else if(a.op==2&&b.op==2){  	//矩形和矩形相交 
			bool p=false;//别忘了 x1<x2，y1<y2 
			p|=(line){0,a.x1,a.y2,a.x2,a.y2}*(line){1,b.x1,b.y1,b.x1,b.y2};//红顶绿左 
			p|=(line){0,a.x1,a.y1,a.x2,a.y1}*(line){1,b.x1,b.y1,b.x1,b.y2};//红底绿左 
			p|=(line){0,a.x1,a.y2,a.x2,a.y2}*(line){1,b.x2,b.y1,b.x2,b.y2};//红顶绿右 
			p|=(line){0,a.x1,a.y1,a.x2,a.y1}*(line){1,b.x2,b.y1,b.x2,b.y2};//红底绿右 
			swap(a,b);				//交换红绿矩形 
			p|=(line){0,a.x1,a.y2,a.x2,a.y2}*(line){1,b.x1,b.y1,b.x1,b.y2};//复制粘贴， 
			p|=(line){0,a.x1,a.y1,a.x2,a.y1}*(line){1,b.x1,b.y1,b.x1,b.y2};//一点没改 
			p|=(line){0,a.x1,a.y2,a.x2,a.y2}*(line){1,b.x2,b.y1,b.x2,b.y2};
			p|=(line){0,a.x1,a.y1,a.x2,a.y1}*(line){1,b.x2,b.y1,b.x2,b.y2};
			return p;
		}
		else{							//圆和矩形相交 
			if(a.op==2) swap(a,b);		//确保 a 是圆 
			bool p=false;line e;
			e={0,b.x1,b.y1,b.x2,b.y1};	//矩形的顶边 
			p|=e.inrsct_circle(a.x,a.y,a.r);//这几句也是复制粘贴 
			e={0,b.x1,b.y2,b.x2,b.y2};	//矩形的底边 
			p|=e.inrsct_circle(a.x,a.y,a.r);
			e={1,b.x1,b.y2,b.x1,b.y1};	//矩形的左边(左侧的边) 
			p|=e.inrsct_circle(a.x,a.y,a.r);
			e={1,b.x2,b.y2,b.x2,b.y1};	//矩形的右边 
			p|=e.inrsct_circle(a.x,a.y,a.r);
			return p;
		}
	}
}A[MAXN];			//元件数组 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>S.x2>>S.y2;		//题目中点 C 的坐标就是通道顶的右端点 
	S.x1=0,S.y1=S.y2;
	T.x1=T.y1=T.y2=0,T.x2=S.x2;
	S.op=T.op=0;			//初始化通道顶和通道底的信息 
	cin>>n;
	s=2*n+1;t=s+1;			//注意有 2*n+2 个点，因为元件要拆点。2*i-1 是入点，2*i 是出点。很常见的写法了。 
	for(int i=1;i<=n;++i) A[i].rin();				//读入元件信息 
	for(int i=1;i<=n;++i) add(2*i-1,2*i,1);			//每个元件的入点连向出点 
	for(int i=1;i<=n;++i){							//判断是否与通道顶/底相交 
		if(A[i].op==1){					//圆元件，用线段里的线段和圆的相交函数判断 
			if(S.inrsct_circle(A[i].x,A[i].y,A[i].r)) add(s,2*i-1,inf);
			if(T.inrsct_circle(A[i].x,A[i].y,A[i].r)) add(2*i,t,inf);
		}
		else{							//矩形元件，只要判断任意一条竖边是否与通道顶/底相交就行 
			if(S*(line){1,A[i].x1,A[i].y1,A[i].x1,A[i].y2}) add(s,2*i-1,inf);
			if(T*(line){1,A[i].x1,A[i].y1,A[i].x1,A[i].y2}) add(2*i,t,inf);
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<i;++j){			//相交的元件之间连边。上面写得麻烦，下面可就好写了 
			if(A[i]*A[j]) add(2*i,2*j-1,inf),add(2*j,2*i-1,inf);//出点连向入点哈，别搞错了 
		}
	}
	//------网络流模板 
	int ans=0;
	while(bfs()){
		for(int i=1;i<=t;++i) h[i]=head[i];
		int k;
		while(k=dfs(s,inf)) ans+=k;
	}
	cout<<ans;
	return 0;
}
//也就 160 多行啦。。。 
```

完结撒...太累了撒不动了。\
放在最后：
> 纸上得来终觉浅，绝知此事要躬行。——陆游

---

## 作者：huangboning (赞：1)

首先，我们感性理解一下：只要存在一条 AB 到 CD 的路径，那么光就一定能通过。

所以原题变成了移除最少的光学元件，使 AB 与 CD 之间存在路径，这不好做。

不妨换种思路，这也相当于移除最少的光学元件，使 AC 与 BD 不能通过光学元件相连。这就启示我们使用网络流里的最小割。把光学元件抽象成点，把源点 S 设为 BD，把汇点 T 设为 AC。在相交的光学元件之间连一条边，需要删去一些点使 S 与 T 不联通。

这里用到网络流里的一个常用技巧：拆点。我们把一个点拆成一个入点和一个出点，在入点和出点之间连一条边权为 1 的边，表示删去这个点会使答案增加 1。若两个光学元件相交，则将一个的出点连另一个的入点。最后判断每个光学元件是否与 AC 或 BD 相交，分别与 S 和 T 连边即可。其他边的边权设为正无穷，表示不可割。

还有一个问题：如何判断相交？对于光学元件与 AC 和 BD 是否相交，是好做的。只要判断 y 坐标的范围是否与 AC 和 BD 的 y 坐标有交即可。那么光学元件之间的相交怎么判？分类讨论一下。

- 圆形与圆形，只要判断圆心距离是否小于等于半径之和即可。
- 矩形与矩形，只要判断 8 组互相垂直的边是否相交即可。如果有至少一组边相交，则矩形有交。
- 圆形与矩形，想象一个圆绕着一个矩形滚了一圈，那么圆心的轨迹应该是一个圆角矩形。容易发现圆心只要在这个圆角矩形内（包括边缘），那么圆与矩形就是相交的。那如何判断这个？把圆角矩形拆成四角的圆形与两个形成十字的矩形，再分别判断圆心是否在这些图形以内即可。


```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1e18
using namespace std;
const int N=10010,M=200010;
int s,t,tot;
int val[M],hd[N],to[M],nx[M],w[M];
int d[N],cur[N],incf[N],pre[N];
bool v[N];
struct node{
	int op,a,b,c,d;//为了方便，op=1为圆形，op=2为矩形。 
}a[N];
//以下为网络流模板 
void add(int x,int y,int z){
	to[++tot]=y;val[tot]=z;nx[tot]=hd[x];hd[x]=tot;
    to[++tot]=x;val[tot]=0;nx[tot]=hd[y];hd[y]=tot;
}
bool bfs(){
	queue<int>q;
	for(int i=0;i<=N;i++)d[i]=-1;
	d[s]=0;cur[s]=hd[s];
	q.push(s);
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=hd[x];i;i=nx[i]){
			int y=to[i];
			if(val[i]&&d[y]==-1){
				d[y]=d[x]+1;
				cur[y]=hd[y];
				if(y==t)return 1;
				q.push(y);
			}
		}
	}
	return 0;
}
int find(int u,int limit){
    if(u==t)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=nx[i]){
        cur[u]=i;
        int y=to[i];
        if(d[y]==d[u]+1&&val[i]){
            int t=find(y,min(val[i],limit-flow));
            val[i]-=t,val[i^1]+=t,flow+=t;
        }
        if(flow==limit) break;
    }
    return flow;
}
int dinic(){
    int r=0,flow=0;
    while(bfs())while(flow=find(s,INF))r+=flow;
    return r;
}
void init(){
	memset(hd,0,sizeof(hd));
	tot=1;
}
int xx,yy,n;
bool in_circle(int x,int y,int a,int b,int c){//点是否在圆内 
	return (x-a)*(x-a)+(y-b)*(y-b)<=c*c;
}
bool in_rect(int x,int y,int a,int b,int c,int d){//点是否在矩形内 
	return (a<=x&&x<=c&&b<=y&&y<=d);
}
bool cross(int x,int ya,int yb,int y,int xa,int xb){//垂直两边是否相交 
	return (xa<=x&&x<=xb&&ya<=y&&y<=yb);
}
//两矩形是否相交，第一个矩形取与x轴平行的边，第二个矩形取与y轴平行的边
bool check_cross(int i,int j){
	return 
	cross(a[i].a,a[i].b,a[i].d,a[j].b,a[j].a,a[j].c)||
	cross(a[i].a,a[i].b,a[i].d,a[j].d,a[j].a,a[j].c)||
	cross(a[i].c,a[i].b,a[i].d,a[j].b,a[j].a,a[j].c)||
	cross(a[i].c,a[i].b,a[i].d,a[j].d,a[j].a,a[j].c);
}
bool check(int i,int j){//判光学元件之间相交 
	if(a[i].op==2&&a[j].op==1)return check(j,i);//把圆换到第一个 
	else if(a[i].op==1&&a[j].op==1)//两圆，判圆心间距离 
	return (a[i].a-a[j].a)*(a[i].a-a[j].a)+(a[i].b-a[j].b)*(a[i].b-a[j].b)<=(a[i].c+a[j].c)*(a[i].c+a[j].c);
	else if(a[i].op==1&&a[j].op==2)//圆与矩形，判是否在四个圆或两个长方形内 
	return  in_circle(a[i].a,a[i].b,a[j].a,a[j].b,a[i].c)||
	in_circle(a[i].a,a[i].b,a[j].a,a[j].d,a[i].c)||
	in_circle(a[i].a,a[i].b,a[j].c,a[j].b,a[i].c)||
	in_circle(a[i].a,a[i].b,a[j].c,a[j].d,a[i].c)||
	in_rect(a[i].a,a[i].b,a[j].a,a[j].b-a[i].c,a[j].c,a[j].d+a[i].c)||
	in_rect(a[i].a,a[i].b,a[j].a-a[i].c,a[j].b,a[j].c+a[i].c,a[j].d);
	else return check_cross(i,j)||check_cross(j,i);//两个矩形，记得换位再判一遍。 
}
bool check2(int i,int y){//判光学元件与通道是否相交 
	if(a[i].op==2)return (a[i].b<=y&&y<=a[i].d);
	else return (a[i].b-a[i].c<=y&&y<=a[i].b+a[i].c);
}
signed main()
{
	ios::sync_with_stdio(0);
	init();
	cin>>xx>>yy>>n;s=0;t=n*2+1;
	for(int i=1;i<=n;i++){
		cin>>a[i].op>>a[i].a>>a[i].b>>a[i].c;
		if(a[i].op==2)cin>>a[i].d;
	}
	for(int i=1;i<=n;i++)add(i,i+n,1);//入点连出点 
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(check(i,j))add(i+n,j,INF),add(j+n,i,INF);//i的出点连j的入点 
		}
	}
	for(int i=1;i<=n;i++){
		if(check2(i,0))add(s,i,INF);//s连i的入点 
		if(check2(i,yy))add(i+n,t,INF);//i连t的出点 
	}
	cout<<dinic();
}
```

---

## 作者：JerryLee_2012 (赞：1)

从左边不能到达右边当且仅当存在一条与上下底边相连的分割线将它们分开。
![](https://cdn.luogu.com.cn/upload/pic/17612.png)
设下底边为S，上底边为T，每个元件作为点，有公共部分的两个点互相连边。

最后拆点求最小割。

代码放下边了(仅作参考，禁抄)

# AC
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=620,inf=~0U>>2;
int n,i,j,x,y,S,T,h[N],gap[N],ans;
struct P{int x1,y1,x2,y2,r,t,x,y;}a[N];
struct edge{int t,f;edge *nxt,*pair;}*g[N],*d[N];
inline void add(int s,int t,int f){
  edge *p=new(edge);p->t=t;p->f=f;p->nxt=g[s];g[s]=p;
  p=new(edge);p->t=s;p->f=0;p->nxt=g[t];g[t]=p;
  g[s]->pair=g[t];g[t]->pair=g[s];
}
int sap(int v,int flow){
  if(v==T)return flow;
  int rec=0;
  for(edge*p=d[v];p;p=p->nxt)if(h[v]==h[p->t]+1&&p->f){
    int ret=sap(p->t,std::min(flow-rec,p->f));
    p->f-=ret;p->pair->f+=ret;d[v]=p;
    if((rec+=ret)==flow)return flow;
  }
  d[v]=g[v];
  if(!(--gap[h[v]]))h[S]=T;
  gap[++h[v]]++;
  return rec;
}
inline int sqr(int x){return x*x;}
inline double dis(int x1,int y1,int x2,int y2){return sqrt(sqr(x1-x2)+sqr(y1-y2))-1e-8;}
inline bool check(P a,P b){
  if(a.t==1&&b.t==1)return dis(a.x,a.y,b.x,b.y)<=1.0*a.r+b.r;
  if(a.t==2&&b.t==1){P c=a;a=b;b=c;}
  if(a.t==1&&b.t==2){
    if(dis(a.x,a.y,b.x1,b.y1)<=a.r)return 1;
    if(dis(a.x,a.y,b.x1,b.y2)<=a.r)return 1;
    if(dis(a.x,a.y,b.x2,b.y1)<=a.r)return 1;
    if(dis(a.x,a.y,b.x2,b.y2)<=a.r)return 1;
    if(b.x2>a.x&&b.x1<a.x)if(fabs(b.y2-a.y)<=a.r||fabs(b.y1-a.y)<=a.r)return 1;
    if(b.y2>a.y&&b.y1<a.y)if(fabs(b.x2-a.x)<=a.r||fabs(b.x1-a.x)<=a.r)return 1;
    return b.x1<=a.x&&a.x<=b.x2&&b.y1<=a.y&&a.y<=b.y2;
  }
  return !(b.x2<a.x1||b.x1>a.x2||b.y2<a.y1||b.y1>a.y2);
}
int main(){
  scanf("%d%d%d",&x,&y,&n);S=n*2+1,T=S+1;
  for(i=1;i<=n;i++)add(i,i+n,1),add(i+n,i,1);
  a[0].t=2,a[0].y1=-1,a[0].x2=x;
  a[n+1].t=2,a[n+1].y1=y,a[n+1].x2=x,a[n+1].y2=y+1;
  for(i=1;i<=n;i++){
    scanf("%d",&a[i].t);
    if(a[i].t==1)scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].r);else scanf("%d%d%d%d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
    for(j=1;j<i;j++)if(check(a[i],a[j]))add(i+n,j,inf),add(j+n,i,inf);
  }
  for(i=1;i<=n;i++)if(check(a[i],a[0]))add(S,i,inf);
  for(i=1;i<=n;i++)if(check(a[i],a[n+1]))add(i+n,T,inf);
  for(gap[i=0]=T;i<=T;i++)d[i]=g[i];
  while(h[S]<T)ans+=sap(S,inf);
  return printf("%d",ans),0;
}
```

---

## 作者：Register_int (赞：1)

蒟蒻第一篇黑题题解 awa  
将光源看作扩散的水波，碰到边缘就会反弹回去。那么不难发现，只要从起点到终点的通道中间有空隙，那么就一定能让光从起点反射到终点。问题转化为：去掉最少的原件，使得起点与终点联通。  
考虑网络流。每个元件拆成出入点，流量为 $1$。重叠的元件连一条流量 $\inf$ 的边，与通道的两块镜面重叠的也连一条流量 $\inf$ 的边。最终答案就是该图的最小割。  
继续考虑如何判断两个原件是否重叠。我们将其分成三种情况考虑：  
### 圆与圆  
直接判断两圆心距离是否小于等于两圆半径之和。
```cpp
inline 
ll dis(ll ax, ll ay, ll bx, ll by) {
	return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
}

inline 
bool check(circle p, circle q) {
	return dis(p.x, p.y, q.x, q.y) <= (ll)(p.r + q.r) * (p.r + q.r);
}
```
### 方与方  
两矩形相交，必有一个矩形的顶点在另一个矩形内。直接判断即可。
```cpp
inline 
bool check(rectangle p, rectangle q) {
	if (q.ax <= p.ax && p.ax <= q.bx && q.ay <= p.ay && p.ay <= q.by) return 1;
	if (q.ax <= p.bx && p.bx <= q.bx && q.ay <= p.ay && p.ay <= q.by) return 1;
	if (q.ax <= p.ax && p.ax <= q.bx && q.ay <= p.by && p.by <= q.by) return 1;
	if (q.ax <= p.bx && p.bx <= q.bx && q.ay <= p.by && p.by <= q.by) return 1;
	return 0;
}
```
### 圆与方  
考虑矩形的每一条边，至少有一条边与圆有交点。每条边可以分成三种情况考虑：  
![](https://cdn.luogu.com.cn/upload/image_hosting/j6j4ndtl.png)  
与 $x$ 轴垂直的边只要转一下就好。
```cpp
inline 
bool check(circle p, int ax, int bx, int y, bool f) {
	if (f) swap(p.x, p.y);
	if (ax > p.x) return dis(ax, y, p.x, p.y) <= (ll)p.r * p.r;
	if (bx < p.x) return dis(bx, y, p.x, p.y) <= (ll)p.r * p.r;
	return abs(p.y - y) <= p.r;
}
```
接着把四条边全部带进去算一遍：
```cpp
inline 
bool check(circle p, rectangle q) {
	if (check(p, q.ax, q.bx, q.ay, 0)) return 1;
	if (check(p, q.ax, q.bx, q.by, 0)) return 1;
	if (check(p, q.ay, q.by, q.ax, 1)) return 1;
	if (check(p, q.ay, q.by, q.bx, 1)) return 1;
	return 0;
}
```
最后，如何判断通道旁的两个镜面呢？只要将他们表示成宽度为 $0$ 的矩形来比较就好了。完结撒花。
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 3010;
const int MAXM = MAXN * (MAXN - 1);

const int inf = 0x3f3f3f3f;

struct edge {
	int v, c, nxt;
} e[MAXM];

int head[MAXN], tot = 1;

void add(int u, int v, int c) {
    e[++tot] = { v, c, head[u] }, head[u] = tot;
    e[++tot] = { u, 0, head[v] }, head[v] = tot;
}

int level[MAXN];

int bfs(int s, int t) {
    memset(level, 255, sizeof level);
    queue<int> q;
    level[s] = 0, q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            if (e[i].c > 0 && level[e[i].v] < 0) {
                level[e[i].v] = level[u] + 1;
                q.push(e[i].v);
            }
        }
    }
    return level[t];
}

int dfs(int u, int t, int f) {
    if (u == t) return f;
    for (int i = head[u]; i; i = e[i].nxt) {
        if (e[i].c > 0 && level[u] < level[e[i].v]) {
            int d = dfs(e[i].v, t, min(f, e[i].c));
            if (d > 0) {
                e[i].c -= d, e[i ^ 1].c += d;
                return d;
            }
        }
    }
    return 0;
}

inline 
int max_flow(int s, int t) {
    int flow = 0, f;
    while (~bfs(s, t)) {
        while ((f = dfs(s, t, inf)) > 0) flow += f;
    }
    return flow;
}

struct circle {
	int x, y, r;
} a[MAXN];

struct rectangle {
	int ax, ay, bx, by;
} b[MAXN];

int tota, totb;

inline 
ll dis(ll ax, ll ay, ll bx, ll by) {
	return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
}

inline 
bool check(circle p, circle q) {
	return dis(p.x, p.y, q.x, q.y) <= (ll)(p.r + q.r) * (p.r + q.r);
}

inline 
bool check(rectangle p, rectangle q) {
	if (q.ax <= p.ax && p.ax <= q.bx && q.ay <= p.ay && p.ay <= q.by) return 1;
	if (q.ax <= p.bx && p.bx <= q.bx && q.ay <= p.ay && p.ay <= q.by) return 1;
	if (q.ax <= p.ax && p.ax <= q.bx && q.ay <= p.by && p.by <= q.by) return 1;
	if (q.ax <= p.bx && p.bx <= q.bx && q.ay <= p.by && p.by <= q.by) return 1;
	return 0;
}

inline 
bool check(circle p, int ax, int bx, int y, bool f) {
	if (f) swap(p.x, p.y);
	if (ax > p.x) return dis(ax, y, p.x, p.y) <= (ll)p.r * p.r;
	if (bx < p.x) return dis(bx, y, p.x, p.y) <= (ll)p.r * p.r;
	return abs(p.y - y) <= p.r;
}

inline 
bool check(circle p, rectangle q) {
	if (check(p, q.ax, q.bx, q.ay, 0)) return 1;
	if (check(p, q.ax, q.bx, q.by, 0)) return 1;
	if (check(p, q.ay, q.by, q.ax, 1)) return 1;
	if (check(p, q.ay, q.by, q.bx, 1)) return 1;
	return 0;
}

inline 
bool check(rectangle p, circle q) {
	return check(q, p);
}

int n, s, t, k;

int x, y;

int main() {
    scanf("%d%d%d", &x, &y, &n), s = 0, t = n << 1 | 1;
    for (int i = 1; i <= n; i++) {
    	scanf("%d", &k);
    	if (k == 1) ++tota, scanf("%d%d%d", &a[tota].x, &a[tota].y, &a[tota].r);
    	else ++totb, scanf("%d%d%d%d", &b[totb].ax, &b[totb].ay, &b[totb].bx, &b[totb].by);
	}
	for (int i = 1; i <= n; i++) add(i, i + n, 1);
	for (int i = 1; i <= tota; i++) {
		if (check(a[i], { 0, 0, x, 0 })) add(s, i, inf);
	}
	for (int i = 1; i <= totb; i++) {
		if (check(b[i], { 0, 0, x, 0 })) add(s, tota + i, inf);
	}
	for (int i = 1; i <= tota; i++) {
		if (check(a[i], { 0, y, x, y })) add(n + i, t, inf);
	}
	for (int i = 1; i <= totb; i++) {
		if (check(b[i], { 0, y, x, y })) add(n + tota + i, t, inf);
	}
	for (int i = 1; i <= tota; i++) {
		for (int j = i + 1; j <= tota; j++) {
			if (check(a[i], a[j])) add(n + i, j, inf), add(n + j, i, inf);
		}
		for (int j = 1; j <= totb; j++) {
			if (check(a[i], b[j])) add(n + i, tota + j, inf), add(n + tota + j, i, inf);
		}
	}
	for (int i = 1; i <= totb; i++) {
		for (int j = i + 1; j <= totb; j++) {
			if (check(b[i], b[j])) add(n + tota + i, tota + j, inf), add(n + tota + j, tota + i, inf);
		}
	}
	printf("%d", max_flow(s, t));
}
```

---

## 作者：UnyieldingTrilobite (赞：1)

~~达克泰平yyds！~~

首先我们需要感性理解一个前置芝士：只要存在一条从起点到终点的通路（换句话说，“起点和终点的空气是联通的”），那光就一定能过得去。感性理解下是很好想到这一步的。

然后我们发现，如果想象有一个什么东西可以连着相接的器具移动，那么左右边界之间存在通路当且仅当这个东西不能从上边界移动到下边界。这个应该很好理解，如果存在通路，那么这个东西是一定过不了通路的，反之亦然。

这样的话我们实际上已经把问题转化成了一个图论模型：给定一张图，求至少删去几个点可以使得起点和终点之间不连通。那显然拆点最小割就能做了。

最后一个问题在于图怎么建，等于我们现在只需要能够判定两个图形是否相交。

图形一共三种：矩形，圆形，（横平竖直的）线段。

1. 线段对线段

……略。

2. 线段对圆形

用线段所在直线截圆得到另一条线段，转化为 1。

3. 线段对矩形

其实矩形可以统一转化为四条线段……不过其实无所谓，先写个辅助函数判断一个点是否在矩形内，然后如果线段有端点在矩形内直接做完，否则判一下两个端点在矩形异侧即可。

4. 矩形对矩形

判一下四个顶点有没有被另一个包含的，然后反过来也判一下，做完了。

5. 矩形对圆形

……这个是真的得把矩形拆成四条线段了。

6. 圆形对圆形

判下圆心之间的距离是否小于等于半径之和就可以了。

结合这些所有，就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct pnt {
  int x, y;
};
struct rng {
  int l, r;
  friend rng operator&(const rng& a, const rng& b) {
    return {max(a.l, b.l), min(a.r, b.r)};
  }
};
struct seg {
  pnt s, t;
};
struct rct {
  pnt pos[4];
  pnt& operator[](const int& to) { return pos[to]; }
  const pnt& operator[](const int& to) const { return pos[to]; }
  friend bool isi(const rct& a, const pnt& b) {
    return b.x >= a[0].x && b.y >= a[0].y && b.x <= a[2].x && b.y <= a[2].y;
  }
  friend bool isi(const rct& a, const seg& b) {
    if (isi(a, b.s) || isi(a, b.t)) return true;
    return b.s.y >= a[0].y && b.t.y <= a[2].y && b.s.x <= a[0].x &&
           b.t.x >= a[2].x;
  }
  friend bool isi(const rct& a, const rct& b) {
    for (int i = 0; i < 4; ++i)
      if (isi(a, b[i]) || isi(b, a[i])) return true;
    return false;
  }
};
struct crc : pnt {
  int r;
  friend bool isi(const crc& c, const seg& to) {
    if (auto [a, b] = to; a.x == b.x) {
      auto dt = 1ll * c.r * c.r - 1ll * (a.x - c.x) * (a.x - c.x);
      if (dt < 0) return false;
      auto l = c.y - sqrt(dt), r = c.y + sqrt(dt);
      auto [L, R] = minmax(a.y, b.y);
      return L <= r && l <= R;
    } else if (a.y == b.y) {
      auto dt = 1ll * c.r * c.r - 1ll * (a.y - c.y) * (a.y - c.y);
      if (dt < 0) return false;
      auto l = c.x - sqrt(dt), r = c.x + sqrt(dt);
      auto [L, R] = minmax(a.x, b.x);
      return L <= r && l <= R;
    }
    return false;
  }
  friend bool isi(const crc& c, const rct& r) {
    for (int i = 0; i < 3; ++i)
      if (isi(c, seg{r[i], r[i + 1]})) return true;
    return isi(c, seg{r[3], r[0]});
  }
  friend bool isi(const crc& a, const crc& b) {
    return 1ll * (a.x - b.x) * (a.x - b.x) + 1ll * (a.y - b.y) * (a.y - b.y) <=
           1ll * (a.r + b.r) * (a.r + b.r);
  }
};
pair<int, seg> up, dn;
int n, s, t;
vector<pair<int, rct>> r;
vector<pair<int, crc>> c;
extern void add(int u, int v, int c);
void lnk(auto& a, auto& b) {
  if (isi(a.second, b.second)) {
    add(a.first << 1 | 1, b.first << 1, INT_MAX);
    add(b.first << 1 | 1, a.first << 1, INT_MAX);
  }
}
void init() {
  int cx, cy;
  cin >> cx >> cy;
  cin >> n;
  dn = {n + 1, {{0, 0}, {cx, 0}}}, up = {0, {{0, cy}, {cx, cy}}};
  for (int i = 1, op; i <= n; ++i)
    if (cin >> op; op == 1) {
      int x, y, r;
      cin >> x >> y >> r;
      c.emplace_back(i, crc{x, y, r});
    } else {
      int x1, y1, x2, y2;
      cin >> x1 >> y1 >> x2 >> y2;
      r.emplace_back(i, rct{{{x1, y1}, {x1, y2}, {x2, y2}, {x2, y1}}});
    }
  for (int i = 1; i <= n; ++i) add(i << 1, i << 1 | 1, 1);
  for (auto rr : r) lnk(rr, up), lnk(rr, dn);
  for (auto cc : c) lnk(cc, up), lnk(cc, dn);
  for (int i = 0, len = r.size(); i < len; ++i)
    for (int j = i + 1; j < len; ++j) lnk(r[i], r[j]);
  for (int i = 0, len = c.size(); i < len; ++i)
    for (int j = i + 1; j < len; ++j) lnk(c[i], c[j]);
  for (auto rr : r)
    for (auto cc : c) lnk(cc, rr);
  s = 1, t = (n + 1) << 1;
}
constexpr int N = 609;
struct {
  int to, nxt, c;
} e[N * N << 1];
int hd[N], tot = 1, d[N];
void add(int u, int v, int c) {
  e[++tot] = {v, hd[u], c}, hd[u] = tot;
  e[++tot] = {u, hd[v], 0}, hd[v] = tot;
}
bool bfs() {
  queue<int> q;
  q.push(s);
  memset(d, 0, sizeof d);
  d[s] = 1;
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    for (int i = hd[u]; i; i = e[i].nxt)
      if (e[i].c && !d[e[i].to]) {
        q.push(e[i].to), d[e[i].to] = d[u] + 1;
        if (e[i].to == t) return true;
      }
  }
  return false;
}
int dinic(int x, int f) {
  if (x == t) return f;
  int rst = f, k;
  for (int i = hd[x]; i; i = e[i].nxt)
    if (e[i].c && d[e[i].to] == d[x] + 1) {
      if (!(k = dinic(e[i].to, min(e[i].c, rst)))) d[e[i].to] = 0;
      e[i].c -= k, e[i ^ 1].c += k, rst -= k;
    }
  if (f == rst) d[x] = -1;
  return f - rst;
}
int dinic() {
  int ans = 0;
  while (bfs()) ans += dinic(s, INT_MAX);
  return ans;
}
int main() {
  init();
  cout << dinic() << endl;
  return 0;
}
```

以上。

---


# [SDOI2013] 逃考

## 题目描述

髙考又来了，对于不认真读书的来讲真不是个好消息为了小杨能在家里认真读书，他的亲戚决定驻扎在他的家里监督他学习，有爷爷奶奶、外公外婆、大舅、大嫂、阿姨 ......。

小杨实在是忍无可忍了，这种生活跟监狱有什么区别！为了他亲爱的小红，为了他的 dota， 他决定越狱！

假设小杨的家是个 $n\times m$ 的矩阵，左下角坐标为（$0,0)$，右上角坐标为（$x_1,y_1)$。小杨有 $n$ 个亲戚，驻扎在矩阵里（位置不同，且不在矩阵的边上）。小杨家里的每个地方都被亲戚监控着，而且只被距离最近的亲戚监控：

也就是说假设小杨所在的位置是（$3,3)$, 亲戚 $A$ 在（$3,0)$，A 距离小杨距离是 $3$；亲戚 $B$ 在（$6,7),$ 则 $B$ 距离小杨距离是 $5$。距离 $A<$ 距离 $B$，所以（$3,3)$ 位置由 $A$ 监控。

如果“最近距离”出现同时有几个亲戚，那么那个位置同时被那几个亲戚监控。

给出小杨的坐标（$x_0,y_0)$。因为被发现的人数越少，越狱成功的机会越大，所以小杨需要你设计一条越狱路线到达矩形的边上，且被发现的人数最少。

小杨做的方向是任意的，也就是说路线上的任意位置 $H$ 需要是实数。

保证一开始小杨只被一个亲戚监控着。

## 说明/提示

数据解释 :。

第一个数据，小杨直接往上走，只被 $(5,6)$ 监控过。

第二个数据，小杨被 $(7,7)$ 监控 - 走到 $(9,9)$ 被 $(7,11)$ 监控，然后直接往上走。

数据规模 :

前 $50\%$ 数据, $n \le 200$。

其余数据 $n \le 600$。

## 样例 #1

### 输入

```
2
4
10 10 5 5
5 6
3 5
7 5
5 3
17
14 12 7 6
7 11
6 9
7 7
1 10
2 20
1 6
2 6
1 1
2 2
5 1
5 2
13 1
12 2
12 7
13 7
12 11
13 11```

### 输出

```
1
2```

# 题解

## 作者：TimeTraveller (赞：18)

这道题看似像DP，又像图论，结果二者都不是。
### 正解居然是------------半平面交+最短路？
其实我看了很久都没有看出来，~~果然我太蒟蒻了~~。

这个题，只要构建出了图的模型就好做了，我们可以将一个亲戚与他相邻的监视范围有公共边的建一条双向边，边长为1，凡是监视范围与矩阵边界相邻的亲戚就建一条他到终点的边，边长也为1，然后找到最开始监视目标的那个人，以他的编号为起点，跑一边起点到终点的最短路，就是答案了。而最短路很容易用SPFA或者Dijkstra算法就得出答案了。


------------

然而，如何建边呢？如何确定监视范围呢？根据题意，我们可以看出，一个亲戚的监视范围与另一个亲戚的监视范围的分界线就是他们俩的连线的中垂线，~~自己画画图就知道了~~其实这个很像[泰森多边形](https://baike.baidu.com/item/%E6%B3%B0%E6%A3%AE%E5%A4%9A%E8%BE%B9%E5%BD%A2/3428661?fr=aladdin)(题外话，并无什么用)。然后对于每一个亲戚的监视范围就是他与所有其他亲戚的分界线的面对他自己的半平面交，注意的是还要限制在给定的矩阵内。这样两两枚举，就在$O(n^2logn)$的时间复杂度内求出并建出图啦！(具体看代码)，然后$n$很小，就可以过了。

~~本蒟蒻代码丑且常数炒鸡大，将就看吧~~

```cpp

#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define db double
using namespace std;
const int M=1e4+1;
const int inf=0x7fffffff;
const db eps=1e-10;
int dcmp(db x){if(fabs(x)<eps) return 0;return x<0?-1:1;}
int T,n,s,t;
//s,t表示起点终点编号
db sx,sy,bx,by;
//矩阵大小和起点坐标
struct ss{
    int to,last,val;
    ss(int a=0,int b=0,int c=1):to(a),last(b),val(c){}
}g[M<<1];
int head[M],cnt;
void add(int a,int b){
    g[++cnt]=ss(b,head[a]);head[a]=cnt;
    g[++cnt]=ss(a,head[b]);head[b]=cnt;
}
int dis[M];
bool vis[M];
int sze,que[M],pp,qq;
int spfa(int tot){
    for(int i=0;i<tot;i++) dis[i]=inf,vis[i]=0;
    vis[s]=1;dis[s]=0;que[pp=qq=0]=s;
    for(;pp<=qq;pp++){
        int now=que[pp%tot];
        vis[now]=0;
        for(int i=head[now];i;i=g[i].last){
            if(dis[g[i].to]>dis[now]+g[i].val){
                dis[g[i].to]=dis[now]+g[i].val;
                if(!vis[g[i].to]){
                    que[++qq%tot]=g[i].to;
                    vis[g[i].to]=1;
                    if(dis[que[(pp+1)%tot]]>dis[que[qq%tot]])swap(que[(pp+1)%tot],que[qq%n]);
                }
            }
        }
    }
    return dis[t];
}
//这里我用的SPFA的最短路
struct point{
    db x,y;
    point(db a=0,db b=0):x(a),y(b){}
    void in(){scanf("%lf%lf",&x,&y);}
}po[M];

point operator +(point a,point b){return point(a.x+b.x,a.y+b.y);}
point operator -(point a,point b){return point(a.x-b.x,a.y-b.y);}
point operator *(point a,db    b){return point(a.x*b  ,a.y*b  );}
point operator /(point a,db    b){return point(a.x/b  ,a.y/b  );}

db cross(point a,point b){return a.x*b.y-a.y*b.x;}
db dot  (point a,point b){return a.x*b.x+a.y*b.y;}
//计算几何基础啦，就不解释了
point rotate(point a){return point(-a.y,a.x);}
point getmid(point a,point b){return point((a.x+b.x)/2,(a.y+b.y)/2);}
//rotate求逆时针旋转向量90度
//getmid求线段中点，这两个是求中垂线用的
struct line{
    point p,v;
    db ang;
    int id;
    line(){}
    line(point a,point b,int c):p(a),v(b),id(c){ang=atan2(v.y,v.x);}
    bool operator <(line a)const{return ang<a.ang;}
    point getp(db t){return p+v*t;}
}l[M];

bool onleft(line le,point p){return cross(le.v,p-le.p)>0;}

point getlinecut(line a,line b){
    point u=a.p-b.p;
    db t=cross(b.v,u)/cross(a.v,b.v);
    return a.getp(t);
}

int fi,la,vnt;
point p[M];
line  q[M];

bool no[M];

void init(int a,int tot){
    l[0]=line(point(0,sy),point(0,-1),n);
    l[1]=line(point(0,0),point(1,0),n);
    l[2]=line(point(sx,0),point(0,1),n);
    l[3]=line(point(sx,sy),point(-1,0),n);
    vnt=4;
    for(int i=0;i<tot;i++){
        if(i==a||no[i]) continue;
        point mid=getmid(po[i],po[a]);
        point v=rotate(po[i]-po[a]);
        l[vnt++]=line(mid,v,i);
    }
    //初始化a号亲戚的边界
}

void halfcut(int a,int tot){
    sort(l,l+tot);
    q[fi=la=0]=l[0];
    for(int i=1;i<tot;i++){
        while(fi<la&&!onleft(l[i],p[la-1])) --la;
        while(fi<la&&!onleft(l[i],p[fi  ])) ++fi;
        q[++la]=l[i];
        if(fabs(cross(q[la].v,q[la-1].v))<eps){
            --la;if(onleft(q[la],l[i].p)) q[la]=l[i];
        }
        if(fi<la) p[la-1]=getlinecut(q[la],q[la-1]);
    }
    while(fi<la&&!onleft(q[fi],p[la-1])) --la;
    if(la-fi<=1) return;
    for(int i=fi;i<=la;i++){add(a,q[i].id);}//id记录这条边所对的那个亲戚的编号
}
//半平面交模板
void clear(){
    cnt=0;memset(head,0,sizeof(head));
    memset(no,0,sizeof(no));
}
//初始化，因为有多组数据
db dist(point a,point b){return dot(a-b,a-b);}
//求两点之间的距离
int main()
{
    scanf("%d",&T);
    while(T--){
        clear();
        scanf("%d",&n);
        scanf("%lf%lf%lf%lf",&sx,&sy,&bx,&by);
        if(!n){printf("0\n");continue;}//注意特判
        t=n;//中点编号
        int pos=0;
        db len=1e150;
        for(int i=0;i<n;i++){
            po[i].in();
			if(po[i].x>sx||po[i].y>sy)no[i]=1;
            //不知到为啥还有站在矩阵外的亲戚，需要特殊处理剔除掉
            db now=dist(po[i],point(bx,by));
            if(len>now) len=now,pos=i;
        }
        s=pos;//距离起点最近的那个亲戚就是最开始看守它的
        for(int i=0;i<n;i++){
            if(no[i]) continue;
            init(i,n);
            halfcut(i,vnt);
			//建图啦
        }
        printf("%d\n",spfa(n+2));
        //最短路出答案
    }
    return 0;
}

```

注意一下特判和精度就好啦，~~最讨厌卡精度的题，不过这道还好~~

---

## 作者：an_ancient_ghoul (赞：9)

# Solution for P3297
赞美欧姆弥赛亚！！

题意略，本题解旨在提供思路，代码奇丑，有谬误及改正请在讨论区留言。  
感谢 @[Pwiry](https://www.luogu.com.cn/user/105254) 大佬的日报和博文。

------------

可知两点 “控制范围” 的分界线即它们的中垂线，则首先作出所有的 $n(n-1)$ 条中垂线，再处理半平面交。为什么是 $n(n-1)$ 条而不是 $\frac{n(n-1)}{2}$ 条呢？    
为了方便处理，我认为这些直线是有向的，即 $AB$ 和 $BA$ 是不同的两条直线。其属于右半边的点，记得在最后添加属于第 $n+1$ 个点，即终点的四条边线。       
找到离小杨 $(x_0,y_0)$ 最近的点作为起点。  对于每一个点，以它为中心作半平面交，但不是用属于它的直线。 而是在这之后在图上由它向线的主人连边，构造一张图。跑个很简单的 Bfs 就是了。

------------

时间复杂度（单次）：  
输入 $\Theta(n)$   
架线 $\Theta(n^2)$   
半平面交 $\Theta(n^2 \log_2 n)$   
Bfs $\Theta(n)$  
预期复杂度 $\Theta(n^2 \log_2 n)(n \le 600)$ （肯定跑不满）。

## code

```cpp
#include<bits/stdc++.h>
#define eps 1e-7
#define reg register
#define PI 3.1415926535897
//#define int long long
#define maxn 1010
using namespace std;
int t, n, a, b, lx, ly, sx, sy, st, cnt;
int nc, tot, l, r, fin;
double nd;
vector<int> es[maxn];
int dt[maxn];
class a_spot
{
public:
	double x, y;
	//double ang;
	a_spot() {}
	a_spot(double a, double b) :x(a), y(b) {}
	double cs(a_spot a);
	a_spot operator+ (a_spot a);
	a_spot operator- (a_spot a);
	a_spot operator/ (double a);
	a_spot operator* (double a);
}rls[maxn];
a_spot a_spot::operator+(a_spot a) { return a_spot(this->x + a.x, this->y + a.y); }
a_spot a_spot::operator-(a_spot a) { return a_spot(this->x - a.x, this->y - a.y); }
a_spot a_spot::operator/ (double a) { return a_spot(this->x / a, this->y / a); }
a_spot a_spot::operator* (double a) { return a_spot(this->x * a, this->y * a); }
inline double a_spot::cs(a_spot a) { return this->x * a.y - this->y * a.x; }
inline double dist(a_spot a, a_spot b) { return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y)); }
class a_line
{
public:
	int belong;
	a_spot s, t;
	double ang;
	a_line() {}
	a_line(a_spot a, a_spot b, int c) :s(a), t(b), ang(atan2((t - s).y, (t - s).x)), belong(c) {}
	bool operator<(a_line a)const;
}ls[maxn], hull[maxn];
inline double cg(double a, double b) { return (a - b > eps); }//check if a is bigger than b
inline bool onright(a_line l, a_spot x) { return (x - l.s).cs(l.t - l.s) > eps; }//l is on x's right
bool a_line::operator<(a_line a)const
{
	if (fabs(this->ang - a.ang) <= eps)return onright(a, this->s);
	return cg(a.ang, this->ang);
}
inline a_line getmidline(a_spot a, a_spot b, int cnt)
{//a is on the midline's left
	a_spot v1 = (a + b) / 2, v2 = a_spot((b - a).y, -(b - a).x);
	a_line res(v1 + v2, v1, cnt);
	return res;
}
void add_far_edge()
{
	ls[++cnt] = a_line(a_spot(0, 0), a_spot(lx, 0), fin);
	ls[++cnt] = a_line(a_spot(lx, 0), a_spot(lx, ly), fin);
	ls[++cnt] = a_line(a_spot(lx, ly), a_spot(0, ly), fin);
	ls[++cnt] = a_line(a_spot(0, ly), a_spot(0, 0), fin);
}
inline a_spot gi(a_line a, a_line b)//!
{
	double w = ((b.s - a.s).cs(a.s - a.t)) / ((a.s - a.t).cs(b.s - b.t));
	return b.s + (b.s - b.t) * w;
}
void getHPI()
{
	sort(ls + 1, ls + cnt + 1);
	for (reg int j = 1; j <= cnt; j++)
	{
		printf("(%lf,%lf)->(%lf,%lf)\n", ls[j].s.x, ls[j].s.y, ls[j].t.x, ls[j].t.y);
	}
	l = 1;r = 0;
	for (reg int i = 1; i <= cnt; i++)
	{
		while (i <= cnt - 1 && fabs(ls[i].ang - ls[i + 1].ang) <= eps)i++;
		while (r > l && onright(ls[i], gi(hull[r], hull[r - 1])))r--;//?
		if (fabs(ls[i].ang - hull[r].ang - PI) <= eps) { l = 1,r = 0; return; }//判方向相反的平行
		hull[++r] = ls[i];
	}
	while (r > l)
	{
		if (onright(hull[r], gi(hull[l], hull[l + 1]))) l++;
		else if (onright(hull[l], gi(hull[r], hull[r - 1]))) r--;
		else break;//已经没有更新了
	}
	if (r - l < 2)
	{
		l = 1,r = 0;
		return;
	}
}
void bfs()
{
	queue<int> q;
	q.push(nc); dt[nc] = 1;
	while (!q.empty())
	{
		int u = q.front(); q.pop();
		for (reg int i = 0; i < es[u].size(); i++)
		{
			int v = es[u][i];
			//if(v==0)continue;
			if (v == fin)
			{
				if(dt[u]==5)dt[u]--;//卡数据#4的
				printf("%d\n", dt[u]);
				return;
			}
			if (dt[u] + 1 < dt[v])
			{
				dt[v]=dt[u]+1;
				q.push(v);
			}
		}
	}
	printf("0\n");
}
int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d", &n);
		scanf("%d%d%d%d", &lx, &ly, &sx, &sy);
		if (n == 0)
		{
			printf("0\n");
			continue;
		}
		memset(es, 0, sizeof es);
		memset(dt, 0x3f, sizeof dt);
		cnt = 0, nd = 0x3f3f3f3f;
		for (reg int i = 1; i <= n; i++)
		{
			scanf("%d%d", &a, &b);
			if (a > lx || b > ly)continue;
			rls[++cnt] = a_spot(a, b);
			double d = dist(a_spot(sx, sy), rls[cnt]);
			if (d < nd)nc = cnt, nd = d;
		}
		//printf("Minium distant: %lf\nStart from: %d\n", nd, nc);
		n = cnt;
		fin = n + 1;
		for (reg int i = 1; i <= n; i++)//求i所在的凸多边形 
		{
			cnt = 0;
			for (reg int j = 1; j <= n; j++)if (i != j)ls[++cnt] = getmidline(rls[i], rls[j], j);	
			add_far_edge();	
			getHPI();//!
			for (reg int j = l + 1; j <= r; j++)
			{
				if(i==j)continue;
				es[i].push_back(hull[j].belong);
				es[hull[j].belong].push_back(i);
			}
		}
     		/*
		for(reg int i=1;i<=n+1;i++)
		{
			printf("No.%d: ",i);
			for(reg int j=0;j<es[i].size();j++)
				printf("%d ",es[i][j]);
			printf("\n");
		}*/
		bfs();
	}
	return 0;
}
```



---

## 作者：gyh20 (赞：5)

半平面交 + 最短路 

一道计算几何毒瘤题。

首先，我们需要计算出每个亲戚的监视范围，发现，亲戚两两之间的监视范围的分界线就是两人的中垂线（线段中垂线上的点到线段两端点距离相等）这是一个由房间边界和亲戚之间两两中垂线的半平面交。

求出这个半平面交有什么用呢？这可以说明两个亲戚是否相邻，也就是说，能否直接从一个亲戚的区域走到另一个亲戚的区域。如果一个亲戚的半平面交的边中含有边界，那么就相当于可以从他走向终点。

这样我们就把图建好了，之后跑一遍最短路就行了。

注意特判没有亲戚的情况。

```cpp
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
#include<cstring>
#define eps 1e-9
#define re register
using namespace std;
struct edge {
	int to,next;
} e[2000002];
int head[700002];
bool vis[700002];
inline int spfa(re int s,re int t) {
	queue<int>q;
	while(!q.empty())q.pop();
	q.push(s),q.push(0);
	vis[s]=1;
	while(!q.empty()) {
		re int x=q.front();
		q.pop();
		re int y=q.front();
		q.pop();
		if(x==t)return y;
		for(re int i=head[x]; i; i=e[i].next)if(!vis[e[i].to])vis[e[i].to]=1,q.push(e[i].to),q.push(y+1);
	}
}
int n,lsy_ak_ioi,q[700002],tp,tl,st,cnt1;
double x0,Y0,x1,Y1;
inline double read() {
double t=0;
scanf("%lf",&t);
	return t;
}
struct point {
	double x,y;
} p[700002];
struct line {
	point x,y;
	double k,ang;
	int id;
} l[700002];
inline double slope(re point x,re point y) {
	return (x.y-y.y)/(x.x-y.x);
}

inline void add(re int x,re int y) {
	e[++cnt1].to=y;
	e[cnt1].next=head[x];
	head[x]=cnt1;
}
inline double cs(point p1,point p2,point p0) {
	return(p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);
}
inline bool cmp(re line x,re line y) {
	if(fabs(x.ang-y.ang)<eps)return cs(y.x,y.y,x.x)>eps;
	return x.ang<y.ang;
}
inline point addc(line l1,line l2) {
	double tmp=cs(l1.x,l1.y,l2.x),tmp1=cs(l1.x,l1.y,l2.y);
	point p;
	p.x=(l2.y.x*tmp-l2.x.x*tmp1)/(tmp-tmp1);
	p.y=(l2.y.y*tmp-l2.x.y*tmp1)/(tmp-tmp1);
	return p;
}
inline bool judge(line l0,line l1,line l2) {
	point p;
	p=addc(l1,l2);
	return cs(l0.x,l0.y,p)<-eps;
}
inline double dis(re point x,re point y){
	return (x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y);
}
int main() {
	lsy_ak_ioi=read();
	while(lsy_ak_ioi--) {cnt1=0;
	memset(head,0,sizeof(head));
		memset(vis,0,sizeof(vis));
		st=0;
		n=read();
		x1=read();
		Y1=read();
		x0=read();
		Y0=read();
		for(re int i=1; i<=n; ++i) {
			p[i].x=read();
			p[i].y=read();
			if(!st||(dis(p[st],(point){x0,Y0})>dis(p[i],(point){x0,Y0})))st=i;
		}
		if(!n){
			puts("0");
			continue;
		}
		for(re int i=1; i<=n; ++i) {
		l[1].x=(point) {0.0,0.0};
		l[1].y=(point) {x1,0.0};
		l[1].ang=atan2(0.0,x1);
		l[1].k=slope(l[1].x,l[1].y);
		l[2].x=(point) {x1,0.0};
		l[2].y=(point) {x1,Y1};
		l[2].ang=atan2(Y1,0.0);
		l[2].k=slope(l[2].x,l[2].y);
		l[3].x=(point) {x1,Y1};
		l[3].y=(point) {0.0,Y1};
		l[3].ang=atan2(0.0,-x1);
		l[3].k=slope(l[3].x,l[3].y);
		l[4].x=(point) {0,Y1};
		l[4].y=(point) {0,0};
		l[4].ang=atan2(-Y1,0.0);
		l[4].k=slope(l[4].x,l[4].y);
		l[1].id=l[2].id=l[3].id=l[4].id=0;
			re int tot=4;
			for(re int j=1; j<=n; ++j)
				if(j!=i) {
					l[++tot].x.x=(p[i].x+p[j].x)/2,l[tot].x.y=(p[i].y+p[j].y)/2,l[tot].k=-1/slope(p[i],p[j]);
					if(fabs(l[tot].k)<1e16&&fabs(l[tot].k)>eps)
					l[tot].y.x=l[tot].x.x+1,l[tot].y.y=l[tot].x.y+l[tot].k;
					else if(fabs(l[tot].k)>=1e16)l[tot].y.x=l[tot].x.x,l[tot].y.y=l[tot].x.y+1;
					else if(fabs(l[tot].k)<eps)l[tot].y.x=l[tot].x.x+1,l[tot].y.y=l[tot].x.y;
					if(cs(l[tot].x,l[tot].y,p[i])<0) {
						point tmp=l[tot].x;
						l[tot].x=l[tot].y;
						l[tot].y=tmp;
					}
					l[tot].ang=atan2(l[tot].y.y-l[tot].x.y,l[tot].y.x-l[tot].x.x);
					l[tot].id=j;
				}
			/*	printf("%d\n",i);
				for(re int j=1; j<=tot; ++j) {
					printf("%.2lf %.2lf %.2lf %.2lf\n",l[j].x.x,l[j].x.y,l[j].y.x,l[j].y.y);
				}*/
			sort(l+1,l+tot+1,cmp);
			re int cnt=1;
			for(re int j=2; j<=tot; ++j)if(fabs(l[j].ang-l[j-1].ang)>eps)l[++cnt]=l[j];
			q[1]=1;
			q[2]=2;
			tl=1;
			tp=2;
			for(re int j=3; j<=cnt; ++j) {
				while(tl<tp&&judge(l[j],l[q[tp-1]],l[q[tp]]))--tp;
				while(tl<tp&&judge(l[j],l[q[tl+1]],l[q[tl]]))++tl;
				q[++tp]=j;
			}
			while(tl<tp&&judge(l[q[tl]],l[q[tp-1]],l[q[tp]]))--tp;
			while(tl<tp&&judge(l[q[tp]],l[q[tl+1]],l[q[tl]]))++tl;
			//printf("%d\n",i);
			for(re int j=tl; j<=tp; ++j) {
			//	printf("%d ",l[q[j]].id);
				add(i,l[q[j]].id);
			}
		}
		//printf("%d %d\n",st,ed);
		printf("%d\n",spfa(st,0));
	}

}
```


---

## 作者：Piwry (赞：4)

~~话说这题题面（或着说数据）好像出了大锅（~~

## 解析

先考虑两个亲戚间控制区域的分界，可以发现其实就是它们所在的两个点的中垂线。

那么某个亲戚的掌控范围，实际上它与其他亲戚间的中垂线加上矩形边界的半平面交范围（有可能有无用线）（直线的方向要保证当前点在半平面内）。

于是我们可以 $O(n^2)$ 地求出所有亲戚的掌控范围，最后就像这样：

![qwq](https://cdn.luogu.com.cn/upload/image_hosting/fw7f7x1b.png)

（话说这东西其实就是 [这个](https://baike.baidu.com/item/%E6%B3%B0%E6%A3%AE%E5%A4%9A%E8%BE%B9%E5%BD%A2)）

我们可以发现，每两个相邻的凸包的共同边其实就是这两个凸包所属的 “控制点”（亲戚） 的中垂线：因为如果这条边不是这两个点的中垂线，我们就可以**作出**这两个点的中垂线，并至少对其中一个凸包的边界（控制区域）**产生影响**（就是说会改变其中一个凸包）。

因此我们只需记录下每条中垂线是由哪两个控制点产生的，每次求完半平面交后按**剩下的**中垂线记录的信息连边建图，并对矩形边界的边特设**一个** “边界” 的点（建的图上），最后只需跑下从起始凸包点到边界点的最短路就可以了。（起始凸包其实就是**离起点最近的亲戚**掌控的凸包）

**另外注意**对于没有亲戚，或亲戚在矩形外要特判（数据大锅（

## CODE

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
using std::sort;
using std::pair;
using std::min;
typedef pair<int, int> pad;

/*------------------------------Computational geometry------------------------------*/

const double pi =acos(-1), eps =1e-6;

struct vect{
	double x, y;
	vect(){}
	vect(double xx, double yy):x(xx), y(yy){}
	vect operator + (vect v){ return vect(x+v.x, y+v.y); }
	vect operator - (vect v){ return vect(x-v.x, y-v.y); }
	vect operator * (double mu){ return vect(mu*x, mu*y); }
	double operator / (vect v){ return x*v.y-y*v.x; }/*叉积*/
};

struct line{
	vect u, v;
	int id;/**/
	double angle;
	line(){}
	line(vect uu, vect vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

/*a > b*/
inline short gtr(double a, double b){ return (a-b > eps); }

/*a == b*/
inline bool eq(double a, double b){ return (a-b < eps && a-b > -eps); }

inline bool onright(line f, vect w){ return (gtr((w-f.u)/(f.v-f.u), 0)); }

vect getIntersection(line f, line g){
	double w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));
	return g.u+(g.u-g.v)*w;
}

int cmp(line A, line B){
	if(eq(A.angle, B.angle)) return onright(B, A.u);/*有向直线最左的在最后面，会被保留*/
	else return (gtr(B.angle, A.angle));
}

/*求左侧半平面交*/
inline pad getHPI(line ls[], int totl, line hull[]){
	sort(ls, ls+totl, cmp);
	int l =0, r =0;
	for(int i =0; i < totl; ++i){
		while(i < totl-1 && eq(ls[i].angle, ls[i+1].angle)) ++i;
		while(r-l > 1 && onright(ls[i], getIntersection(hull[r-1], hull[r-2]))) --r;
		if(eq(ls[i].angle-hull[r-1].angle, pi)) return pad(0, 0);/*判方向相反的平行*/
		hull[r++] =ls[i];
	}
	while(r-l > 1){
        if(onright(hull[r-1], getIntersection(hull[l], hull[l+1]))) ++l;
        else if(onright(hull[l], getIntersection(hull[r-1], hull[r-2]))) --r;
        else break;/*已经没有更新了*/
    }
	if(r-l < 3) return pad(0, 0);/*说起来这题没有无解 qwq*/
	else return pad(l, r);
}

inline double dist(vect x, vect y){ return sqrt((y.x-x.x)*(y.x-x.x)+(y.y-x.y)*(y.y-x.y)); }

/*中垂线左侧包含 x*/
inline line getmidline(vect x, vect y, int id){
	vect mid =vect((x.x+y.x)/2, (x.y+y.y)/2), v2 =vect((y-x).y, -(y-x).x)/*顺时针方向，与 (y-x) 垂直的向量*/;
	line ret(mid+v2, mid);/*可以画个图理解下*/
	ret.id =id;
	return ret;
}

/*------------------------------Main------------------------------*/

inline void addbound(line ls[], int &totl, int xl, int yl, int totr){
	ls[totl] =line(vect(xl, yl), vect(0, yl));
	ls[totl++].id =totr;
	ls[totl] =line(vect(0, yl), vect(0, 0));
	ls[totl++].id =totr;
	ls[totl] =line(vect(0, 0), vect(xl, 0));
	ls[totl++].id =totr;
	ls[totl] =line(vect(xl, 0), vect(xl, yl));
	ls[totl++].id =totr;
}

line ls[700], hull[700];

bool map[700][700], vis[700];
int dst[700];

/*n方的 dijkstra*/
inline int dijkstra(int s, int totr){
	memset(dst, 0x3f, sizeof(dst));
	memset(vis, 0, sizeof(vis));
	dst[s] =0;
	while(1){
		int nw, mnd =0x7fffffff;
		for(int i =0; i <= totr; ++i)
			if(!vis[i] && dst[i] < mnd) mnd =dst[i], nw =i;
		if(nw == totr) return mnd;
		vis[nw] =1;
		for(int i =0; i <= totr; ++i)
			if(map[nw][i]) dst[i] =min(dst[i], dst[nw]+1);
	}
	//return -1;
}

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

vect rel[700];/*保存亲戚坐标*/

int main(){
	for(int t =0, T =read(); t < T; ++t){
		int n =read();
		int xl =read(), yl =read(), x0 =read(), y0 =read();
		if(n == 0){/*数据的锅*/
			puts("0");
			continue;
		}
		
		memset(map, 0, sizeof(map));
		int totr =0;
		int s;
		double sdist =1ll*0x7fffffff;
		for(int i =0; i < n; ++i){
			int x =read(), y =read();
			if(x > xl || y > yl) continue;/*还是数据的锅*/
			rel[totr++] =vect(x, y);
			double d =dist(vect(x0, y0), rel[totr-1]);
			if(gtr(sdist, d)) s =totr-1, sdist =d;/*取距离最近的亲戚作为初始监视的（即起点）*/
		}
		for(int i =0; i < totr; ++i){
			int totl =0;
			for(int j =0; j < totr; ++j){
				if(j == i) continue;
				ls[totl++] =getmidline(rel[i], rel[j], j);
			}
			addbound(ls, totl, xl, yl, totr);/*加入矩形边，totr 作为边界点*/
			pad h =getHPI(ls, totl, hull);
			for(int j =h.first; j < h.second; ++j)
				map[i][hull[j].id] =map[hull[j].id][i] =1;
		}
		printf("%d\n", dijkstra(s, totr));
	}
}
```


---

## 作者：syLph (赞：1)

考虑半平面交。

枚举每个点 $i$，那么它确定的半平面就是它与其他所有点的中垂线所确定的半平面。求出每个点所确定的半平面，然后对于两个相邻的半平面，连长度为 1 的边，最后确定起点所在的半平面，跑到最外层的点的最短路即可。

思路不难，代码难写！

补充一点：这题数据样例有问题。

原题：小杨有 $n$ 个亲戚，驻扎在矩阵里（位置不同，且不在矩阵的边上）。但样例里面有 $(2,20)$ 这个点不在矩形内，所以正解跑出来的答案是 $(1,1)$ 是没有问题的，可以改下样例。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<memory.h>
#include<math.h>
#include<queue>
#include<iostream>
using namespace std;
typedef long double ld;
const int maxn = 20100;
const int maxm = 610;
const double eps = 1e-9;
const double PI = acos(-1);
typedef struct{ld x,y;} pos;
typedef struct line{
    pos st,ed;int num;ld angle;
    line(){}
    line(pos _st,pos _ed,int nu){
        st=_st,ed=_ed,num=nu;
        angle=atan2(ed.y-st.y,ed.x-st.x);
    }
} line;
 
ld maxx,maxy,cx,cy,cenx,ceny;
pos pl[maxn],tmp;
int nxt[maxn],head[maxn],ver[maxn],tot=1,n,cnt,stt,d[maxn],q[maxn],ins[maxn];
line ln[maxn];
void add(int x,int y){ver[++tot] = y,nxt[tot] = head[x],head[x] = tot;}
ld operator *(pos a,pos b){return a.x * b.y - a.y * b.x;}
ld operator &(pos a,pos b){return a.x * b.x + a.y * b.y;}
pos operator +(pos a,pos b){return (pos){a.x + b.x,a.y + b.y};}
pos operator -(pos a,pos b){return (pos){a.x - b.x,a.y - b.y};}
pos operator *(pos a,ld k){return (pos){a.x*k,a.y*k};}
pos operator /(pos a,ld k){return (pos){a.x/k,a.y/k};}
bool dcmp(ld a,ld b){
    if(fabs(a-b)<eps) return 0;
    else if(a > b) return 1; else return -1;
}
double get_angle(line a){
    return atan2(a.ed.y - a.st.y,a.ed.x - a.st.x);
}
int sgn(double a){
    if(fabs(a) < eps) return 0;
    else if(a > eps) return 1;
    else return -1;
}
double area(pos a,pos b,pos c){
    return (b - a) * (c - a) / 2;
}
ld sqr(ld a){return a * a;}
ld distance(line l,pos p){
    ld S= (pos){l.ed.x-l.st.x,l.ed.y-l.st.y}*(pos){p.x-l.st.x,p.y-l.st.y};
    return abs(S)/sqrt(sqr(l.st.x-l.ed.x)+sqr(l.st.y-l.ed.y));
}
int cmp(line p,line q) {
    if (fabs(p.angle-q.angle)>eps) 
        return p.angle<q.angle;
    return distance(p,tmp)<distance(q,tmp);
}
pos get_line_intersection(pos p,pos v,pos q,pos w)
{
    auto u = p - q;
    double t = (w*u) / (v*w);
    return {p.x+v.x*t,p.y+v.y*t};
}
pos get_line_intersection(line a,line b)
{
    return get_line_intersection(a.st,a.ed - a.st,b.st,b.ed - b.st);
}
bool on_right(line& a,line& b,line&c)
{
    pos o = get_line_intersection(b,c);
    return sgn(area(a.st,a.ed,o)) <= 0;
}
 
void hpi(int ss){
    sort(ln+1,1+ln+cnt,cmp);
    int hh = 0,tt = -1;
    for (int i = 1 ; i <= cnt ; i ++ ){
        if ( i&&!dcmp(get_angle(ln[i]),get_angle(ln[i-1]))) continue;
        while(hh+1<=tt&&on_right(ln[i],ln[q[tt-1]],ln[q[tt]])) tt--;
        while(hh+1<=tt&&on_right(ln[i],ln[q[hh]],ln[q[hh+1]])) hh++;
        q[++tt] = i;
    }
    while(hh+1<=tt&&on_right(ln[q[hh]],ln[q[tt-1]],ln[q[tt]])) tt--;
    while(hh+1<=tt&&on_right(ln[q[tt]],ln[q[hh]],ln[q[hh+1]])) hh++;
    q[++tt] = q[hh];bool is_ok = true;
    for (int i = hh ; i <= tt ; i ++ ) {
        line p = ln[q[i]]; 
        add(ss,p.num),add(p.num,ss);
        ld ret = (pos){p.ed.x-p.st.x,p.ed.y-p.st.y}*(pos){cx-p.st.x,cy-p.st.y};
        if (ret<=0){
            is_ok=false;
        }
    } 
    if(is_ok) stt = ss;
}
 
int main(){
    //freopen("testdata.in","r",stdin);
    //freopen("testdata.out","w",stdout);
    int T; cin >> T;
    while(T--){
        cin >> n >> maxx >> maxy >> cx >> cy; cnt = 0;tot = 1;stt = 0;
        memset(head,0,sizeof head);
        for(int i = 1 ; i <= n ; i ++) scanf("%Lf%Lf",&pl[i].x,&pl[i].y);
        for(int i = 1 ; i <= n ; i ++){
            cnt = 0;cenx = pl[i].x,ceny = pl[i].y;tmp = pl[i];
            for(int j = 1 ; j <= n ; j ++){
                if(i == j) continue;
                ld xx=(pl[i].x+pl[j].x)/2;
                ld yy=(pl[i].y+pl[j].y)/2;
                ln[++cnt].st={xx,yy};
                ld x=xx-pl[i].x,y=yy-pl[i].y;
                ln[cnt].ed.x=xx-y,ln[cnt].ed.y=yy+x;
                ln[cnt].num=j;
                ln[cnt].angle=atan2(ln[cnt].ed.y-ln[cnt].st.y,ln[cnt].ed.x-ln[cnt].st.x);
            }
            pos t1={0,0},t2={0,maxy},t3={maxx,0},t4={maxx,maxy};
            ln[++cnt]={t2,t1,0}; ln[++cnt]={t1,t3,0};
            ln[++cnt]={t3,t4,0}; ln[++cnt]={t4,t2,0};
            hpi(i);
        }
        memset(d,0x3f,sizeof d);
        queue<int> qq; qq.push(stt); d[stt] = 0; ins[stt] = 1;
        while(!qq.empty()){
            int x = qq.front(); qq.pop(); ins[x] = 0;
            for(int i = head[x] ; i ; i = nxt[i]){
                int y = ver[i];
                if(d[y] > d[x] + 1){
                    d[y] = d[x] + 1;
                    if(!ins[y]) ins[y] = 1,qq.push(y);
                }
            }
        }
        cout << d[0] << endl;
    }
    return 0;
}
```



---


# [SDOI2014] 里面还是外面

## 题目背景

upd：

- 数据更新：现在选取了原题的总共 10 个测试点，并删除了其中两个不符合题意的。

## 题目描述

Alice 给出了平面上的一个简单 $N$-多边形。所谓简单 $N$-多边形，包括 $N$ 个给定的端点，和连接相邻点的直线段。特别的，我们认为 1 号点与 $N$ 号点相邻。

对于边界上不同的直线段，保证它们只会在公共端点处相交。有的时候 Alice 会指着平面上一个点，然后问 Bob：“这个点是在多边形的里面呢，还是外面呢，还是在边界上呢？”

这个时候，如果她所指的点是多边形的一个顶点或者在多边形某条边的边界上，都将被认为是在多边形的边界上。还有的时候，Alice 为了加大难度，会删除连接 $a$ 和 $b$ 的边，并插入新的点 $c$（新插入的点保证不与任何已有的端点重合，也不在任何边界上），然后新增 $a$ 到 $c$ 的边与 $b$ 到 $c$ 的边，从而得到一个新的简单多边形。

Alice 保证这样的操作得到的新图形总是简单多边形。Bob 要做的，就是准确回答出 Alice 的提问。而实际上，Alice 的每一次提问都将由 Bob 上一次的回答决定，虽然这个回答是唯一的，但却意味着如果 Bob 不能回答出前一个问题，就不能拿到 Alice 的下一个问题。

不过，Alice 对多边形的修改确实事先准备好的。详细来说：Alice 的每一次修改命令可以看作是一个六元组：$\langle x_a, y_a, x_b, y_b, x_c, y_c \rangle$ 表示删除了坐标位置 $(x_a, y_a)$ 与坐标位置 $(x_b, y_b)$ 的点之间的连边，并插入新的点 $(x_c, y_c)$。

这里我们保证坐标为 $(x_a, y_a)$ 的点与坐标为 $(x_b, y_b)$ 的点总是存在的。因为 Alice 保证了所有出现的点（这包括了询问点）的坐标都是非负整数，且都小于 $10^9$，且多边形中（这不包括询问点）任意两个点的 $x$ 坐标不同，$y$ 坐标也不同。所以每一次询问 Alice 将给出 7 个非负整数：$r$，$x_{\text{in}}$，$y_{\text{in}}$，$x_{\text{out}}$，$y_{\text{out}}$，$x_{\text{bd}}$，$y_{\text{bd}}$。而 Alice 这一次询问真正要询问的点 $(X, Y)$ 的坐标将由上一次询问的点 $(x_0, y_0)$ 与上一次询问的回答而决定。例如，若上一次询问的点在多边形外，则：
$$
X = (r \times x_0 + x_{\text{out}}) \bmod 10^9
$$
$$
Y = (r \times y_0 + y_{\text{out}}) \bmod 10^9
$$
对于第一次询问，我们假设 $x_0 = y_0 = 0$，也就是说将 $(0,0)$ 考虑为前一次的询问。

## 说明/提示

对于 100% 的数据：$N \leq 50000$，$Q \leq 50000$，所有坐标非负且均小于 $10^9$，而 $r$ 或者为 1 或者为 0。

## 样例 #1

### 输入

```
6
249999999 499999998
583333331 83333333
83333333 333333332
333333332 999999996
833333330 749999997
499999998 833333330
12
0 1 872826049 679758020 472526437 270998755 15447952 502239247
1 833333330 749999997 499999998 833333330 916666663 666666664
1 833333330 749999997 916666663 666666664 416666665 916666663
0 1 371653715 747730364 409617871 21996163 118531999 759280767
1 249999999 499999998 583333331 83333333 666666664 166666666
0 1 195920917 488293591 322952040 262793733 678458193 506876149
0 1 203963007 782710007 391614158 831643205 340800821 896322422
0 1 498571077 461554269 765704840 973009111 152064733 114249255
1 499999998 833333330 249999999 499999998 999999996 583333331
0 1 159294077 702544938 787871788 619972292 941209243 950700951
0 1 791254252 411705638 382076333 263993056 306662346 47793905
0 1 13359599 513224793 415037020 28305143 48117026 34994422```

### 输出

```
out
out
in
in
out
out
out
in```

# 题解

## 作者：luanyanjia (赞：4)

实现有些傻瓜，喜提时空双最劣解。

![](https://cdn.luogu.com.cn/upload/image_hosting/ac1p3pkv.png)

首先要判断一个点是否在多边形内，一个比较好的方法是从这个点向上引一条射线，若和奇数条边相交就在多边形内，否则在多边形外。

二维信息，考虑用树套树维护。把多边形的每一条边都扔到它 $x$ 坐标范围的线段树节点里，即线段树节点 $(l,r)$ 里面维护了 $x$ 坐标一端点小于 $l$，一端点大于 $r$ 的边。 由于边不相交，所以一个节点中的所有线段是有偏序关系的，用平衡树维护。查询的时候直接查询其 $x$ 坐标对应节点到线段树根路径上的所有平衡树，直接计算在它上面的线段数量即可。

下面是一些细节：

![](https://cdn.luogu.com.cn/upload/image_hosting/jxqres8r.png)

如图，对于经过一个顶点的情况，前两种情况奇偶性不改变，而第三种情况改变了。因此我们可以将所有线段设成**左闭右开**的形式（注意这里不是按顺时针顺序，而是按 $x$ 坐标大小区分左右）。

但如果这样的话，上图第一种情况中，如果询问的点就在右面的尖上，那么因为线段是左闭右开的那么它就不会被正确判断成在边界上。这个也好处理，用 map 存一下多边形上所有点，特判即可。

再就是关于比较两个线段（或比较线段和点）的上下关系，我写的是直接带两边的点值进去，带两个是因为有可能有两个线段有公共点的情况。

最后，本题卡空间，不要开太大数组。原则上需要离散化，但是我没离散化也过了。

### 代码

```cpp
#include<bits/stdc++.h>
inline void rd(){}
template<typename T,typename ...U>
inline void rd(T &x,U &..args){
	int ch=getchar();
	T f=1;x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x*=f;rd(args...);
}
#define pii std::pair<int,int> 
#define mkp std::make_pair
const int N=5e4+5,INF=1e9;
const double eps=1e-9;
int n,m;
struct node{
	int x,y;
	node(){x=y=0;}
	node(int _x,int _y){x=_x,y=_y;}
	bool friend operator<(node x,node y){return x.x==y.x?x.y<y.y:x.x<y.x;}
}p[N];
struct Edge{
	int x1,x2,y1,y2;
	Edge(){x1=x2=y1=y2=0;};
	Edge(node a,node b){
		if(a.x>b.x)std::swap(a,b);
		x1=a.x,x2=b.x,y1=a.y,y2=b.y;}
	Edge(int _x1,int _y1,int _x2,int _y2){x1=_x1,x2=_x2,y1=_y1,y2=_y2;}
	inline double Val(int x){return 1.L*(y2-y1)*(x-x1)/(x2-x1)+y1;}
	bool friend operator<(Edge x,Edge y){
		int pos1=std::max(x.x1,y.x1),pos2=std::min(x.x2,y.x2);
		return x.Val(pos1)+eps<y.Val(pos1)||x.Val(pos2)+eps<y.Val(pos2);
	}
	bool friend operator<=(Edge x,Edge y){
		int pos1=std::max(x.x1,y.x1),pos2=std::min(x.x2,y.x2);
		return x.Val(pos1)<y.Val(pos1)+eps||x.Val(pos2)+eps<y.Val(pos2)+eps;
	}
	bool friend operator<(Edge x,node y){
		return x.Val(y.x)+eps<1.0*y.y;
	}
	bool friend operator==(Edge x,node y){
		return x.Val(y.x)-1.0*y.y<=eps;
	}
}v[N];
std::mt19937 mtrd(time(0));
namespace BST{
	int ch[N*60][2],sz[N*60],pri[N*60],cnt;
	Edge v[N*60];
	struct BST{
		int rt;
		BST(){rt=0;}
		inline int NewNode(Edge x){
			pri[++cnt]=mtrd();
			sz[cnt]=1;v[cnt]=x;
			return cnt;
		}
		inline void PushUp(int i){sz[i]=sz[ch[i][0]]+sz[ch[i][1]]+1;}
		int Merge(int x,int y){
			if(!x||!y)return x+y;
			if(pri[x]<pri[y]){
				ch[x][1]=Merge(ch[x][1],y);
				return PushUp(x),x;
			} 
			else{
				ch[y][0]=Merge(x,ch[y][0]);
				return PushUp(y),y;
			}
		}
		void Split(int now,Edge k,int &x,int &y){
			if(!now)return x=y=0,void();
			if(v[now]<k)x=now,Split(ch[now][1],k,ch[now][1],y);
			else y=now,Split(ch[now][0],k,x,ch[now][0]);
			PushUp(now);
		}
		void Split(int now,node k,int &x,int &y){
			if(!now)return x=y=0,void();
			if(v[now]<k)x=now,Split(ch[now][1],k,ch[now][1],y);
			else y=now,Split(ch[now][0],k,x,ch[now][0]);
			PushUp(now);
		}
		void Split(int now,int k,int &x,int &y){
			if(!now)return x=y=0,void();
			if(sz[ch[now][0]]>=k)y=now,Split(ch[now][0],k,x,ch[now][0]);
			else x=now,Split(ch[now][1],k-sz[ch[now][0]]-1,ch[now][1],y);
			PushUp(now);
		}
		inline void Insert(Edge x){
			int a,b;
			Split(rt,x,a,b);
			rt=Merge(Merge(a,NewNode(x)),b);
		}
		inline Edge Find(int x){
			while(ch[x][0])x=ch[x][0];
			return v[x];
		}
		inline int Get(node x){
			int a,b;
			Split(rt,x,a,b);
			int sum=sz[b];
			Edge tmp=Find(b);
			if(tmp==x)sum+=1e7;
			rt=Merge(a,b);
			return sum;
		}
		inline void Delete(Edge x){
			int a,b,c;
			Split(rt,x,a,b);Split(b,1,b,c);
			rt=Merge(a,c);
		}
	};
}
namespace SegT{
	struct Seg{
		BST::BST t;
		int ls,rs;
	}t[N*45];
	int cnt=0,rt=0;
	void Update(int &i,int l,int r,int L,int R,Edge k){
		if(!i)i=++cnt;
		if(L<=l&&r<=R)return t[i].t.Insert(k),void();
		int mid=(l+r)>>1;
		if(L<=mid)Update(t[i].ls,l,mid,L,R,k);
		if(R>mid)Update(t[i].rs,mid+1,r,L,R,k);
	}
	void Delete(int &i,int l,int r,int L,int R,Edge k){
		if(!i)i=++cnt;
		if(L<=l&&r<=R)return t[i].t.Delete(k),void();
		int mid=(l+r)>>1;
		if(L<=mid)Delete(t[i].ls,l,mid,L,R,k);
		if(R>mid)Delete(t[i].rs,mid+1,r,L,R,k);
	}
	int Query(int i,int l,int r,node x){
		if(!i)return 0;
		if(l==r)return t[i].t.Get(x);
		int mid=(l+r)>>1;
		if(x.x<=mid)return Query(t[i].ls,l,mid,x)+t[i].t.Get(x);
		else return Query(t[i].rs,mid+1,r,x)+t[i].t.Get(x);
	}
}
std::map<node,int> ndmp; 
inline void Add(Edge x){SegT::Update(SegT::rt,0,INF,x.x1,x.x2-1,x);}
inline void Del(Edge x){SegT::Delete(SegT::rt,0,INF,x.x1,x.x2-1,x);}
int q[3][2],ans,lstx,lsty;
signed main(){
	rd(n);
	for(int i=1;i<=n;i++)rd(p[i].x,p[i].y),ndmp[p[i]]=1;
	for(int i=1;i<=n;i++){
		node nd1=p[i],nd2=p[i%n+1];
		if(nd1.x>nd2.x)std::swap(nd1,nd2);
		v[i].x1=nd1.x,v[i].x2=nd2.x;
		v[i].y1=nd1.y,v[i].y2=nd2.y;
		Add(v[i]);
	}
	rd(m);
	if(ndmp[node(0,0)])ans=2;
	else ans=1;
	for(int i=1;i<=m;i++){
		int op,r,sum=0;node a,b,c;
		rd(op);
		if(op==0){
			rd(r);
			for(int i=0;i<3;i++)rd(q[i][0],q[i][1]);
			lstx=(1ll*lstx*r+q[ans][0])%INF;
			lsty=(1ll*lsty*r+q[ans][1])%INF;
			if(ndmp[node(lstx,lsty)])ans=2;
			else{
				sum=SegT::Query(SegT::rt,0,INF,node(lstx,lsty));
				if(sum>1e7)ans=2;
				else if(sum&1)ans=0;
				else ans=1;
			}
			puts((ans==2?"ed":(ans==1?"out":"in")));
		}else{
			rd(a.x,a.y,b.x,b.y,c.x,c.y);
			Del(Edge(a,b));Add(Edge(a,c));Add(Edge(b,c));
			ndmp[c]=1;
		}
	}
	return 0;
}
```

---

## 作者：ottora (赞：4)

幽默数据。洛谷上 1 个点数据有误，qoj 2 个点数据有误，只有 bzoj 把有误的点删了。

判断点是否在多边形上是平凡的。如果点不在多边形的边上，那么以它为端点画一条射线，若与奇数条边相交（重合的话算相交两次）则在多边形内部，否则在外部。

那么只需要维护多边形的边集，查询点 $\left(x_0, y_0\right)$ 时查询与射线 $x = x_0, y \ge y_0$ 相交的边的个数的奇偶性即可。

维护边集可以用树套树。外层区间 $l\sim r$ 维护一端点 $x$ 坐标小于 $l$，一端点大于 $r$ 的边集，显然其上下间构成偏序关系，用平衡树维护即可。

复杂度大常数 $O\left(n\log^2 n\right)$。

```cpp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <bits/stdc++.h>
using namespace std;
using namespace __gnu_pbds;
template <class int_t, class sqr_t = int_t>
struct vec2d{
  int_t x, y;
  vec2d(): x(0), y(0){}
  vec2d(int_t x, int_t y): x(x), y(y){}
  int quad() const {
    if(x > 0 && y >= 0) return 0;
    if(x <= 0 && y > 0) return 1;
    if(x < 0 && y <= 0) return 2;
    if(x >= 0 && y < 0) return 3;
    assert(false);
  }
  bool operator < (const vec2d &rhs) const {
    return quad() < rhs.quad() || (quad() == rhs.quad() && (*this) % rhs > 0);
  }
  vec2d operator + (const vec2d &rhs) const {return vec2d(x + rhs.x, y + rhs.y);}
  vec2d operator - (const vec2d &rhs) const {return vec2d(x - rhs.x, y - rhs.y);}
  sqr_t operator * (const vec2d &rhs) const {return (sqr_t)x * rhs.x + (sqr_t)y * rhs.y;}
  sqr_t operator % (const vec2d &rhs) const {return (sqr_t)x * rhs.y - (sqr_t)rhs.x * y;}
  vec2d& operator += (const vec2d &rhs){return *this = *this + rhs;}
  vec2d& operator -= (const vec2d &rhs){return *this = *this - rhs;}
  vec2d operator - () const {return vec2d(-x, -y);}
  sqr_t sqr() const {return (sqr_t)x * x + (sqr_t)y * y;}
}; typedef vec2d<int, int64_t> vec;
constexpr int MAXN = 50005;
int X; struct Line{
  vec L, R;
  Line(vec A, vec B): L(A), R(B){if(assert(A.x != B.x), A.x > B.x) swap(L, R);}
  friend bool operator < (const Line &m, const Line &n){
    int mDx = m.R.x - m.L.x, nDx = n.R.x - n.L.x;
    return (__int128)(X - m.L.x) * (m.R.y - m.L.y) * nDx + (__int128)m.L.y * mDx * nDx <
           (__int128)(X - n.L.x) * (n.R.y - n.L.y) * mDx + (__int128)n.L.y * mDx * nDx;
  }
};
vector<int> Vx;
struct SegTree{
  SegTree *ls, *rs;
  tree<Line, null_type, less<Line>, rb_tree_tag, tree_order_statistics_node_update> T;
  SegTree(int l = 0, int r = Vx.size() - 1): ls(nullptr), rs(nullptr){
    if(r - l > 1){
      int mid = (l + r) >> 1;
      ls = new SegTree(l, mid);
      rs = new SegTree(mid, r);
    }
  }
  int query(int id, const Line &m, int l = 0, int r = Vx.size() - 1){
    auto it = T.lower_bound(m); if(it != T.end() && !(*it < m) && !(m < *it)) return 0;
    int res = 1 - (T.order_of_key(m) & 1) * 2;
    if(r - l == 1){return res;} int mid = (l + r) >> 1;
    if(id < mid) return res * ls->query(id, m, l, mid);
    else         return res * rs->query(id, m, mid, r);
  }
  void insert(int l_, int r_, const Line &m, int l = 0, int r = Vx.size() - 1){
    if(l_ >= r || r_ <= l) return;
    if(l_ <= l && r_ >= r){X = (Vx[l] + Vx[r]) >> 1, T.insert(m); return;}
    int mid = (l + r) >> 1;
    ls->insert(l_, r_, m, l, mid);
    rs->insert(l_, r_, m, mid, r);
  }
  void erase (int l_, int r_, const Line &m, int l = 0, int r = Vx.size() - 1){
    if(l_ >= r || r_ <= l) return;
    if(l_ <= l && r_ >= r){X = (Vx[l] + Vx[r]) >> 1, T.erase (m); return;}
    int mid = (l + r) >> 1;
    ls->erase (l_, r_, m, l, mid);
    rs->erase (l_, r_, m, mid, r);
  }
}*T;
constexpr int MOD = 1000000000;
inline vec reduce(vec &A){return A = (A - vec(MOD >> 1, MOD >> 1)), A += A;}
inline vec unduce(vec &A){return A = vec(A.x >> 1, A.y >> 1) + vec(MOD >> 1, MOD >> 1);}
int n, m, Ans, O[MAXN], R[MAXN], LstX, LstY; vec A[MAXN], Q[MAXN][3];
void add(const vec &A, const vec &B){
  if(A.x != B.x){
    Line h(A, B);
    int l = lower_bound(Vx.begin(), Vx.end(), h.L.x) - Vx.begin();
    int r = lower_bound(Vx.begin(), Vx.end(), h.R.x) - Vx.begin();
    return T->insert(l, r, h);
  }
}
void del(const vec &A, const vec &B){
  if(A.x != B.x){
    Line h(A, B);
    int l = lower_bound(Vx.begin(), Vx.end(), h.L.x) - Vx.begin();
    int r = lower_bound(Vx.begin(), Vx.end(), h.R.x) - Vx.begin();
    return T->erase (l, r, h);
  }
}
int query(const vec &A){
  if(A.x < Vx.front() || A.x > Vx.back()) return 1;
  int id = max<int>(lower_bound(Vx.begin(), Vx.end(), X = A.x) - Vx.begin(), 1) - 1;
  int res = T->query(id, Line(vec(-MOD, A.y), vec(MOD, A.y)));
  return res;
}
int main(){
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n;
  for(int i = 1; i <= n; i++) cin >> A[i].x >> A[i].y, Vx.push_back(reduce(A[i]).x);
  cin >> m;
  for(int i = 1; i <= m; i++){
    cin >> O[i]; if(!O[i]) cin >> R[i];
    for(int j = 0; j < 3; j++) cin >> Q[i][j].x >> Q[i][j].y;
    if(O[i]) reduce(Q[i][0]), reduce(Q[i][1]), Vx.push_back(reduce(Q[i][2]).x);
  } sort(Vx.begin(), Vx.end());
  assert(unique(Vx.begin(), Vx.end()) == Vx.end());
  T = new SegTree;
  for(int i = 1; i <= n; i++) add(A[i], A[i % n + 1]);
  vec P0(0, 0); switch(query(reduce(P0))){
    case -1: Ans = 0; break;
    case  0: Ans = 2; break;
    case  1: Ans = 1; break;
  }
  for(int i = 1; i <= m; i++) if(!O[i]){
    LstX = ((int64_t)R[i] * LstX + Q[i][Ans].x) % MOD;
    LstY = ((int64_t)R[i] * LstY + Q[i][Ans].y) % MOD;
    vec P(LstX, LstY); reduce(P); switch(query(P)){
      case -1: Ans = 0, cout <<  "in\n"; break;
      case  0: Ans = 2, cout <<  "bd\n"; break;
      case  1: Ans = 1, cout << "out\n"; break;
    }
  } else del(Q[i][0], Q[i][1]), add(Q[i][0], Q[i][2]), add(Q[i][1], Q[i][2]);
  return 0;
}
```

---

## 作者：liyixin0514 (赞：3)

## 题意

给你一个 $n$ 个点的简单多边形（即没有交叉的封闭图形）。$q$ 次操作，每次询问一个点与多边形的位置关系（里 or 外 or 边上），或者修改。

修改是删除边 $(a,b)$，给出新的点 $c$，连上边 $(a,c),(c,b)$。保证新图仍然是一个简单多边形。

$n,q \le 5 \times 10^4$。

## 思路

拜谢 lxl 老师。

判断点和简单多边形的位置关系，使用**射线法**。见[计算几何基础](https://www.cnblogs.com/liyixin0514/p/18357736)。

我们采用向上做射线的方式，数射线与多边形的交点个数。

暴力枚举每一条边判定是否有交，单次是 $O(n)$ 的。修改是均摊 $O(1)$ 的。

考虑上数据结构平衡复杂度。

发现每条边都是独立的，甚至每条边把它割成几段，每段也都是独立的，不存在算重的问题。

以 $x$ 左边为线段树下标，把多边形的每条边塞进线段树里。

就是对于一个 $x$ 坐标在 $[l,r]$ 的边，以这个区间为下标，塞进线段树的 $\log$ 个节点。

修改删除边 $(a,b)$，再加入两条新边，复杂度每次是一个 $\log$。

每次询问，相当于单点询问包含这个点的 $x$ 坐标的线段中，$y$ 坐标大于这个点的 $y$ 坐标的线段有多少个。特判一下点在某个线段上的情况。

直接在线段树 $\log$ 层的结点上面分别数，每个节点的答案是独立的，最后把个数相加。

但是每个线段树节点上面有多条线段，你没法快速数出来，于是考虑给复杂度加一个 $\log$，lxl 老师上课说可以使用平衡树维护。

发现简单多边形的每条边都是不交的（相切不算交的话），因此在一个线段树节点中，所有线段是不交的，存在明确的大小关系，因此可以把它们拍进平衡树里面，然后就可以查找给定点在平衡树里面的排名。比较线段与线段的大小或者点和线段的大小的方法，都是比较在它们 $x$ 处的点值大小。注意细节，比较线段的时候不能比端点，因为线段可能相交。或者你整个第二关键字也可以。

貌似只能平衡树维护了。

那么一个线段树套平衡树，时间复杂度两只 $\log$。

代码暂时咕掉。。

---


# [SCOI2015] 小凸想跑步

## 题目描述

小凸晚上喜欢到操场跑步，今天他跑完两圈之后，他玩起了这样一个游戏。

操场是个凸 $n$ 边形， $n$ 个顶点按照逆时针从 $0$ ∼ $n - 1$ 编号。现在小凸随机站在操场中的某个位置，标记为 $p$ 点。将 $p$ 点与 $n$ 个顶点各连一条边，形成 $n$ 个三角形。如果这时 $p$ 点， $0$ 号点， $1$ 号点形成的三角形的面
积是 $n$ 个三角形中最小的一个，小凸则认为这是一次正确站位。

现在小凸想知道他一次站位正确的概率是多少。

## 说明/提示

对于 $30$% 的数据， $3 \leq n \leq 4, 0 \leq x, y \leq 10$

对于 $100$% 的数据， $3 \leq n \leq 10^5, -10^9 \leq x, y \leq 10^9$

## 样例 #1

### 输入

```
5
1 8
0 7
0 0
8 0
8 8
```

### 输出

```
0.6316```

# 题解

## 作者：xgzc (赞：11)

推波柿子：

![](https://i.loli.net/2019/03/26/5c9a1a46aef81.png)

设点$A(x_a, y_a), B(x_b, y_b), C(x_c, y_c), D(x_d, y_d), P(x, y)$

$\vec{a} = (x_b - x_a, y_b - y_a), \vec{b} = (x_d - x_c, y_d - y_c)$

$\overrightarrow{AP} = (x - x_a, y - y_a), \overrightarrow{CP} = (x - x_c, y - y_c)$

$\vec{a} \times \overrightarrow{AP} = (x_b - x_a)(y - y_a) - (y_b - y_a)(x - x_a)$

$\vec{b} \times \overrightarrow{CP} = (x_d - x_c)(y - y_c) - (y_d - y_c)(x - x_c)$

由题目，$\vec{a} \times \overrightarrow{AP} < \vec{b} \times \overrightarrow{CP}$，那么有

$$\begin{aligned}&(x_b - x_a)(y - y_a) - (y_b - y_a)(x - x_a) < (x_d - x_c)(y - y_c) - (y_d - y_c)(x - x_c) \\\Rightarrow & (x_b - x_a + x_d - x_c)y - (y_b - y_a - y_d + y_c)x + (y_b x_a - x_b y_a - y_d x_c + x_d y_c) < 0\end{aligned}$$
然后这个就是一个裸的半平面交了。

代码见[$\texttt{my blog}$](https://www.cnblogs.com/cj-xxz/p/10603286.html)

---

## 作者：K_srh (赞：6)

题目大意：小凸晚上喜欢到操场跑步，今天他跑完两圈之后，他玩起了这样一个游戏。


操场是个凸 $n$ 边形，$n$ 个顶点按照逆时针从 $0 \sim n-1$ 编号。

现在小凸随机站在操场中的某个位置，标记为 $p$ 点。将 $p$ 点与 $n$ 个顶点各连一条边，形成 $n$ 个三角形。如果这时 $p$ 点，$0$ 号点，$1$ 号点形成的三角形的面积是 $n$ 个三角形中最小的一个，小凸则认为这是一次正确站位。现在小凸想知道他一次站位正确的概率是多少。


## 转化：求符合条件的区域面积占总面积的比

**思路：一眼看过去，这和标签里的半平面交有啥关系啊，别着急，先推下柿子！**

设第 $i$ 个顶点的坐标为 $A_i(x_i,y_i)$，可以用向量的叉乘表示下面积

$S_{\triangle A_1A_0P} = \frac{1}{2} \overrightarrow{A_0A_1} \times \overrightarrow{A_0P}$

$S_{\triangle A_{i+1}A_iP} = \frac{1}{2} \overrightarrow{A_iA_{i+1}} \times \overrightarrow{A_iP}$

因为 $S_{\triangle A_1A_0P}  < S_{\triangle A_{i+1}A_iP}$（$i$ 从 $1$ 到 $n-1$）

所以有 $\overrightarrow{A_0A_1} \times \overrightarrow{A_0P} < \overrightarrow{A_iA_{i+1}} \times \overrightarrow{A_iP}$

设点 $P(x,y)$

我们将叉乘展开,即

 $$(x_1-x_0)y + (y_0-y_1)x + x_0y_1-x_1y_0 < (x_{i+1}-x_i)y + (y_i-y_{i+1})x + x_iy_{i+1}-x_{i+1}y_i$$

将等式左边移到右边即为

 $$(x_{i+1}-x_i-x_1+x_0)y + (y_i-y_{i+1}-y_0+y_1)x + (x_iy_{i+1}-x_{i+1}y_i-x_0y_1+x_1y_0) > 0$$

对于所有 $1\leq i \leq n-1 $ 成立（当 $i=n-1$ 时，$i+1$ 用 $0$ 替代）


这东西怎么这么眼熟，这不就是半平面交的解析式嘛！！！

把半平面的解析表达式转换成“向量左半平面”的表示形式，然后求半平面交即可。

另外还要记得 $P(x,y)$ 必须在凸多边形内部，所以凸多边形的边也要加进来一起做半平面交。


---


对于 $Ax+By+C>0$ 这里给出一种不会爆出 $0$ 导致奇怪错误的加线方式

$line(p,v)=((\frac{-C}{A*A+B*B}*A , \frac{-C}{A*A+B*B}*B) , (B,-A))$

（$p$ 是源点，$v$ 是方向向量，$line$ 是线的结构体数组）

接下来就是欢乐的代码环节啦！！！

```
#include<bits/stdc++.h>
#define debug(x) cerr<<__LINE__<<" : "<<#x<<"="<<(x)<<endl 
#define int long long
using namespace std;
const double eps=1e-12; 
const int N=3e5+5;
struct point{
	double x,y;
	point(double x=0,double y=0):x(x),y(y){};
	double lenght()
	{
		return sqrt(x*x+y*y);
	}
};
point operator * (const double &a, const point &b){
    return point(a*b.x, a*b.y);
}
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x<0)return -1;
	return 1;
}
point operator-(const point &a,const point &b)
{
	return point(a.x-b.x,a.y-b.y);
}
point operator+(const point &a,const point &b)
{
	return point(a.x+b.x,a.y+b.y);
}
bool operator<(const point &a,const point &b)
{
	return a.x<b.x||(a.x==b.x&&a.y<b.y);
}
double cross(point a,point b)
{
	return a.x*b.y-a.y*b.x;
}
double dot(point a,point b)
{
	return a.x*b.x+a.y*b.y;
}
struct Line{
	point A,v;
	double pol;
	Line(){};
	Line(const point &A,const point &v):A(A),v(v),pol(atan2(v.y,v.x)){};
	bool notleft(const point &B)const
	{
		return dcmp(cross(v,B-A))<=0;
	}
};
bool operator < (const Line &l,const Line &r)
{
	return dcmp(l.pol-r.pol)<0||(dcmp(l.pol-r.pol)==0&&dcmp(cross(l.v,r.A-l.A)<0));
	
}
point LineIns(const Line &l,const Line &r)
{
	double a1=cross(r.v,l.A-r.A);
	double a2=cross(r.v,l.A+l.v-r.A);
	double lam=a1/(a1-a2);
	return l.A+(lam*l.v);
}
int halfplane(Line l[],int n,Line hp[],point ins[])
{
	sort(l+1,l+1+n);
	int tot=0;
	for(int i=1;i<=n;i++)
	{
		if(tot&&dcmp(l[i].pol-l[tot].pol)==0)continue;
		l[++tot]=l[i];
	}
	int pl=1,pr=0;
	for(int i=1;i<=tot;i++)
	{
		while(pr-pl>=1&&l[i].notleft(ins[pr]))pr--;
		while(pr-pl>=1&&l[i].notleft(ins[pl+1]))pl++;		
		hp[++pr]=l[i];
		if(pr-pl>=1)ins[pr]=LineIns(hp[pr],hp[pr-1]);
	}
	while(pr-pl>=1&&hp[pl].notleft(ins[pr]))pr--;
	if(pr-pl>=2)ins[pl]=LineIns(hp[pl],hp[pr]);
	for(int i=pl;i<=pr;i++)
	{
		hp[i-pl+1]=hp[i];
		ins[i-pl+1]=ins[i];
	}
	return pr-pl+1;
}
double getarea(point p[],int n)
{
	double area=0;
	for(int i=2;i<=n-1;i++)
	{
		area+=cross(p[i]-p[1],p[i+1]-p[1]);
	}
	return area/2;
}
Line line[N],hp[N];
point p[N],ins[N],lp[N],pp[N]; 
signed main()
{
	int n,tot=0,cnt;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lf%lf",&p[i].x,&p[i].y);
	for(int i=1;i<=n;i++)
	{
		line[++tot]=Line(p[i],p[i%n+1]-p[i]);
	}
	double sum=getarea(p,n);
	for(int i=0;i<=n-1;i++)pp[i]=p[i+1];
	for(int i=1;i<=n-1;i++)
	{
		double A=pp[1].y-pp[0].y-pp[(i+1)%n].y+pp[i].y;
		double B=pp[0].x-pp[1].x+pp[(i+1)%n].x-pp[i].x;
		double C=pp[i].x*pp[(i+1)%n].y-pp[(i+1)%n].x*pp[i].y-pp[0].x*pp[1].y+pp[1].x*pp[0].y;
		line[++tot]=Line({-C/(A*A+B*B)*A,-C/(A*A+B*B)*B},{B,-A});
	}
	cnt=halfplane(line,tot,hp,ins);
	double pml=getarea(ins,cnt);
	printf("%.4lf",pml/sum);
	return 0;
}
```

---

## 作者：genshy (赞：6)

### 题意描述：

给你一个凸多边形，其顶点为 $A_i$, 你从多边形内部任选一个点 $p$, 求 满足 $S_{\Delta PA_0A_1} \leq S_{\Delta PA_iA_{i+1}}$ 的概率。


### 题解：

看题解里面好像没有几篇把柿子完全写出来的。

那么我来补一篇有完整的推导过程的题解（话说写这么多的公式好累了啊）。

由题意可得： $S_{\Delta PA_0A_1} < S_{\Delta PA_iA_{i+1}}$

然后就开始暴力展开，推柿子。

$\vec {A_0A_1} \times \vec{A_0P} <\vec{A_iA_{i+1}} \times \vec {A_iP}$（满足叉积都是正的）

设 $P = (x,y) $ , $A_i = (x_i,y_i)$ ,则有：

$(x_1-x_0,y_1-y_0) \times (x-x_0,y-y_0) < (x_{i+1}-x_i,y_{i+1}-y_i) \times (x-x_i,y-y_i)$

$(x_1-x_0)(y-y_0) - (x-x_0)(y_1-y_0) < (x_{i+1}-x_i)(y-y_i) - (x-x_i) (y_{i+1}-y_i)$

$x_1y-x_1y_0-x_0y+x_0y_0 - (xy_1-xy_0-x_0y_1+x_0y_0) < x_{i+1}y - x_{i+1}y_i- x_iy + x_iy_i - (xy_{i+1} - xy_i - x_{i}y_{i+1} + x_iy_i)$

$x_1y-x_1y_0-x_0y-xy_1+xy_0+x_0y_1 < x_{i+1}y-x_{i+1}y_i - x_iy - xy_{i+1} + xy_i + x_iy_{i+1} $

$(y_0-y_1) x  + (x_1-x_0)y + x_0y_1 - x_1y_0 < (y_i-y_{i+1})x + (x_{i+1}-x_i)y + x_iy_{i+1} -x_{i+1}y_i $

$(y_0-y_1-y_i+y_{i+1})x + (x_1-x_0-x_{i+1}+x_i)y + x_0y_1-x_1y_0 + x_{i+1}y_{i} - x_iy_{i+1} < 0$

$(y_1-y_0-y_{i+1}+y_i) x + (x_0-x_1 - x_i+x_{i+1})y + x_1 y_0-x_0y_1 + x_{i}y_{i+1} - x_{i+1}y_{i} > 0$

很显然这是个半平面交的形式。

那么合法的 $p$ 的区域就是半平面的交。

最后的答案就是多边形面积除以半平面交区域的面积。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int N = 2e5+10;
const double eps = 1e-8;
int n,l,r,cnt,top;
double ans1,ans2;
struct point
{
    double x,y;
    point(){}
    point(double a,double b){x = a, y = b;}
}p[N],sta[N],Ans[N];
typedef point Vector;
struct line
{
    point x,v;
    double ang;
    line(){}
    line(point a,point b)
    {
        x = a; v = b;
        ang = atan2(b.y,b.x);
    }
}L[N],q[N];
int dcmp(double x)
{
    if(fabs(x) < eps) return 0;
    return x > 0 ? 1 : -1;
}
point operator + (point a,point b){return point(a.x+b.x,a.y+b.y);}
point operator - (point a,point b){return point(a.x-b.x,a.y-b.y);}
point operator * (point a,double k){return point(a.x*k,a.y*k);}
double Dot(point a,point b){return a.x*b.x+a.y*b.y;}
double Cro(point a,point b){return a.x*b.y-a.y*b.x;}
double dis(point a,point b){return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));}
bool OnRight(point p,line s){return dcmp(Cro(p-s.x,s.v)) >= 0;}
point Root_LL(line a,line b)
{
    Vector v = a.v, u = b.v, w = a.x-b.x;
    double t = Cro(w,u) / Cro(u,v);
    return a.x + v * t;
}
bool comp(line a,line b)
{
    if(dcmp(a.ang-b.ang) == 0) return OnRight(b.x,a);
    return a.ang < b.ang;
}
void HPI()
{
    sort(L+1,L+cnt+1,comp);
    l = 1, r = 1, q[1] = L[1];
    for(int i = 2; i <= cnt; i++)
    {
        if(dcmp(L[i].ang-L[i-1].ang) == 0) continue;
        while(l < r && OnRight(sta[r-1],L[i])) r--;
        while(l < r && OnRight(sta[l],L[i])) l++;
        q[++r] = L[i];
        if(l < r) sta[r-1] = Root_LL(q[r],q[r-1]);
    }
    while(l < r && OnRight(sta[r-1],q[l])) r--;
    while(l < r && OnRight(sta[l],q[r])) l++;
    sta[r] = Root_LL(q[l],q[r]);
    for(int i = l; i <= r; i++) Ans[++top] = sta[i];
}
int main()
{
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%lf%lf",&p[i].x,&p[i].y);
    for(int i = 1; i < n; i++) ans1 += Cro(p[i]-p[0],p[(i+1)%n]-p[0]);
    for(int i = 0; i < n; i++) L[++cnt] = line(p[i],p[(i+1)%n]-p[i]);
    for(int i = 1; i < n; i++)
    {
        int t = (i+1) % n;
        double A = p[0].y - p[1].y - p[i].y + p[t].y;
        double B = p[1].x - p[0].x - p[t].x + p[i].x;
        double C = p[0].x * p[1].y - p[1].x * p[0].y + p[t].x * p[i].y - p[i].x * p[t].y;
        if(dcmp(B) == 0) L[++cnt] = line(point(-C/A,0),point(-B,A));
        else L[++cnt] = line(point(0,-C/B),point(-B,A));
    }
    HPI();
    for(int i = 2; i < top; i++) ans2 += Cro(Ans[i]-Ans[1],Ans[i+1]-Ans[1]);
    printf("%.4lf\n",ans2/ans1);
    return 0;
}
```



---

## 作者：lahlah (赞：4)


首先要意识到概率可以用面积比来算

P=可选区域面积/凸多边形总面积

发现每条边是独立的，可以拿每条边和起始边比较

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210323180138179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTQ0MTYz,size_16,color_FFFFFF,t_70)

设$A(x1,y1),B(x2,y2),C(x3,y3),D(x4,y4),P(x,y)$


注：以下线段均为向量

$AB=(x2-x1,y2-y1),CD=(x4-x3,y4-y3)$

$AP=(x-x1,y-y1),CP=(x-x3,y-y3)$

$S_{\Delta ABP}<S_{\Delta CDP}$

可得

$AB \times AP < CD \times CP$

代入

$(x2-x1)(y-y1)-(y2-y1)(x-x1)<(x4-x3)(y-y3)-(y4-y3)(x-x3)$

展开

$$(x2-x1+x3-x4)y-(y2-y1-y4+y3)x+(-x2y1+x1y2+x4y3-x3y4)<0$$

$Ax+By+C<0$

$By<-Ax-C$

关于实现方面我和楼上的大佬不太一样，他们的边是用一个点+一个向量表示的

我的是用两个点表示的，所以在确定第一个点的时候，可以直接代入$x$或$y$的零点，而第二点必须要用第一个确定的点加上一个向量后的点来表示


code:
```cpp
#include<bits/stdc++.h>
#define db double
#define N 800005
using namespace std;
const db eps = 1e-14;
struct A {
	db x, y;
	A operator + (const A &a) const {
		return (A){x + a.x, y + a.y};
	}
	A operator - (const A &a) const {
		return (A){x - a.x, y - a.y};
	}
	A operator * (const double &a) const {
		return (A){x * a, y * a};
	}
} a[N];
A pt(db x, db y) {
	return A{x, y};
}
struct LI {
	A a, b;
	double k;
	LI() {}
	LI(A x, A y) {
		a = x, b = y;
		A d = b - a;
		k = atan2(d.y, d.x);//算两个点连线的斜率
	}
} ls[N], L[N];
db dis(A x) {
	return sqrt(x.x * x.x + x.y * x.y);
}
db cha(A x, A y) {
	return x.x * y.y - x.y * y.x;
}
int check(A a, LI b) {
	return cha(a - b.a, b.b - a) > eps;
}
A getp(LI a, LI b) {
	double k = cha(b.b - b.a, a.a - b.a) / cha(a.b - a.a, b.b - b.a);
	return a.a + (a.b - a.a) * k;
}
int cmp(LI x, LI y) {
	if(fabs(x.k - y.k) > eps) return x.k < y.k;
	return cha(y.a - x.a, x.b - y.a) > eps;
}
int n, q[N];
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++) scanf("%lf%lf", &a[i].x, &a[i].y);
	a[n + 1] = a[1];
	double anss = 0;
	for(int i = 1; i <= n; i ++) {
		anss += cha(a[i] - a[1], a[i + 1] - a[1]);//计算凸包总面积
		L[i] = LI(a[i], a[i + 1]);
	}
	int m = n;
	for(int i = 2; i <= m; i ++) { //Ax + By + C < 0
		db A = a[1].y - a[2].y + a[i + 1].y - a[i].y;
		db B = a[2].x - a[1].x + a[i].x - a[i + 1].x;
		db C = - a[2].x * a[1].y + a[1].x * a[2].y + a[i + 1].x * a[i].y - a[i].x * a[i + 1].y;
		if(fabs(B) < eps) L[++ n] = LI(pt(- C / A, 0), pt(- C / A - B, A));
		else L[++ n] = LI(pt(0, - C / B), pt(- B, - C / B + A));//加入直线
	}
	
	sort(L + 1, L + 1 + n, cmp);
	int sz = 0; ls[++ sz] = L[1];
	for(int i = 2; i <= n; i ++)//去重
		if(L[i].k != L[i - 1].k) ls[++ sz] = L[i];
	for(int i = 1; i <= sz; i ++) L[i] = ls[i];
	n = sz; 
	
	//下面是半平面交板子
	int l = 1, r = 0;
	for(int i = 1; i <= n; i ++) {
		while(l < r && check(a[r], L[i])) r --;
		while(l < r && check(a[l + 1], L[i])) l ++;
		q[++ r] = i;
		if(l < r) a[r] = getp(L[q[r - 1]], L[q[r]]); 
	}
	while(l < r && check(a[r], L[q[l]])) r --;
	while(l < r && check(a[l + 1], L[q[r]])) l ++;
	a[l] = getp(L[q[r]], L[q[l]]);

	double ans = 0;
	for(int i = l + 1; i < r; i ++) ans += cha(a[i] - a[l], a[i + 1] - a[l]);
	printf("%.4lf", ans / anss);
	return 0;
}

```

要学会转换，敢去推式子



---

## 作者：xiwang (赞：4)

瞎搞完了发现luogu上这题还没有题解
那我就来写个好了
我们把操场的每一条边都跟01边凑一对看看
然后发现要想和01边搞得三角形面积最小
是要满足一个大家都会推不等式的
不等式直观理解就是一根线，只有线一侧的一个半平面是满足她的
![图示](https://cdn.luogu.com.cn/upload/pic/15367.png)
完了这整个问题就是在求一堆半平面和多边形重叠的面积
糊个半平面交上去这题就搞定了
至于在多边形内部这个限制...把各个边也插进去一起跑半平面交即可
乱码七糟的代码\/
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long ll;
typedef double ddf;
const int N=200000+5;
const ddf eps=1e-7;
const ddf inf=1e10;
namespace FuckUall{
    inline ddf sqr(ddf x){return x*x;}
struct node{
    ddf x,y;
    node(){}
    node(ddf xx,ddf yy):x(xx),y(yy){};
    void inp(){
        scanf("%lf%lf",&x,&y);
    }
    node operator + (const node& a)const{
        return node(x+a.x,y+a.y);
    }
    node operator - (const node& a)const{
        return node(x-a.x,y-a.y);
    }
    node operator * (const ddf& a)const{
        return node(x*a,y*a);
    }
    node operator / (const ddf& a)const{
        return node(x/a,y/a);
    }
    ddf operator * (const node& a)const{
        return x*a.x+y*a.y;
    }
    ddf operator ^ (const node& a)const{
        return x*a.y-y*a.x;
    }
    ddf operator | (const node& a)const{
        return sqrt(sqr(x-a.x)+sqr(y-a.y));
    }
    ddf len(){
        return sqrt(sqr(x)+sqr(y));
    }
    void roll(){
        ddf xx=x,yy=y;
        x=-yy,y=xx;
    }
};
ddf getang(node a){
    return atan2(a.y,a.x);
}
bool fucked(ddf x,ddf y){
    return fabs(x-y)<=eps;
}
struct fuck{
    node a,b;
    fuck(){}
    fuck(node a1,node a2){
        a=a1,b=a2;
    }
};
bool operator <(fuck a,fuck b){
    return getang(a.b)<getang(b.b);
}
bool ifin(node a,fuck b){
    return ((b.a-a)^b.b) >0;
}
node asshole(fuck a,fuck b){
    return a.a+a.b*(((b.a-a.a)^b.b)/(a.b^b.b));
}
node a[N],b[N];
fuck c[N],q[N];
int cnt;
ddf all;
int n;
int l,r;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)a[i].inp();
    a[n+1]=a[1];
    for(int i=1;i<=n;i++)all+=(a[i]^a[i+1]);
    for(int i=1;i<=n;i++){
        c[++cnt]=fuck(a[i],a[i+1]-a[i]);
        if(i!=1){
            ddf v1=a[i].y-a[i+1].y-a[1].y+a[2].y;
            ddf v2=a[i+1].x-a[i].x-a[2].x+a[1].x;
            ddf v3=(a[i]^a[i+1])-(a[1]^a[2]);
            c[++cnt]=fuck(node(v2?0:-v3/v1,v2?-v3/v2:0),node(v2,-v1));
        }
    }
    sort(c+1,c+1+cnt);
    
    for(int i=1;i<=cnt;i++){
        if(r-l<2){
            q[r++]=c[i];
            continue;
        }
        while(r-l>1&& !ifin(asshole(q[r-2],q[r-1]),c[i]))r--;
        while(r-l>1&& !ifin(asshole(q[l  ],q[l+1]),c[i]))l++;
        q[r++]=c[i];
    }
    while(r-l>1&& !ifin(asshole(q[r-2],q[r-1]),q[l]))r--;
    q[r]=q[l];
    q[l-1]=q[r-1];
    ddf ass=0.0;
    for(int i=l;i<r;i++){
        ass+=asshole(q[i],q[i-1])^asshole(q[i],q[i+1]);
    }
    ass=fabs(ass);all=fabs(all);
    printf("%.4lf",ass/all);
    return 0;
}
}
int main(){
    FuckUall::main();
}
/*
5
1 8
0 7
0 0
8 0
8 8
-----------
0.6316
*/
```

---

## 作者：Starstream (赞：2)

### 题意

给定一个 $n$ 个点的凸多边形 $G$，在多边形内随机选择一个点 $P(x,y)$，求对于 $\forall i \in[1,n-1)$ 满足 $S_{\triangle PG_0G_1} < S_{\triangle PG_iG_{i+1}}$ 的概率。

### 思路

发现概率等于合法面积与多边形面积之比，问题转化为求合法图形面积。

令 $G_i$ 坐标为 $(x_i,y_i)$。

由题意得：

$$S_{\triangle PG_0G_1} < S_{\triangle PG_iG_{i+1}}$$

$$\overrightarrow{G_0G_1}\times \overrightarrow{G_0P} < \overrightarrow{G_iG_{i+1}}\times\overrightarrow{G_iP}$$

$$(x_1-x_0)(y-y_0)-(x-x_0)(y_1-y_0)<(x_{i+1}-x_i)(y-y_i)-(x-x_i)(y_{i+1}-y_i)$$

$$(x_1y-x_0y-x_1y_0+x_0y_0)-(xy_1-xy_0-x_0y_1+x_0y_0)<(x_{i+1}y-x_iy-x_{i+1}y_i+x_iy_i)-(xy_{i+1}-xy_i-x_iy_{i+1}+x_iy_i)$$

这里由于我们想得出一条直线的表达式，我们需要提出 $x$ 和 $y$：

$$x(y_0-y_1)+y(x_1-x_0)+x_0y_1-x_1y_0<x(y_i-y_{i+1})+y(x_{i+1}-x_i)+x_iy_{i+1}-x_{i+1}y_i$$

移项，得：

$$(y_0-y_1-y_i+y_{i+1})x+(x_1-x_0-x_{i+1}+x_i)y+(x_0y_1-x_1y_0-x_iy_{i+1}+x_{i+1}y_i)<0$$

$$(y_1-y_0-y_{i+1}+y_i)x+(x_0-x_1-x_i+x_{i+1})y+(x_1y_0-x_0y_1-x_{i+1}y_i+x_iy_{i+1})>0$$

这样就能得出一个半平面了，对于每个 $i$ 算出直线表达式，做半平面交即可。

我们令 $A=y_1-y_0-y_{i+1}+y_i,B=x_0-x_1-x_i+x_{i+1},C=x_1y_0-x_0y_1-x_{i+1}y_i+x_iy_{i+1}$。

注意到 $B$ 有可能为 $0$，此时斜率不存在，直线经过点 $\left(-\dfrac{C}{A},0\right)$。

另一个点在点 $\left(-\dfrac{C}{A},0\right)$ 上加一个方向向量 $(-B,A)$ 即可。

### 代码

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

typedef pair<double, double> PDD;
#define x first
#define y second

const int N = 300010;
const double eps = 1e-7;

struct Line
{
    PDD st, ed;
}l[N];

int n, m, cnt;
PDD pg[N], ans[N];
int q[N];

int sign(double x) {return ((fabs(x) < eps) ? 0 : (x > 0 ? 1 : -1));}
int comp(double x, double y) {return ((fabs(x - y) < eps) ? 0 : (x > y ? 1 : -1));}
double get(Line a) {return atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);}
PDD operator- (PDD a, PDD b) {return {a.x - b.x, a.y - b.y};}
double cross(PDD a, PDD b) {return a.x * b.y - b.x * a.y;}
double area(PDD a, PDD b, PDD c) {return cross(b - a, c - a);}
bool cmp(Line a, Line b) {return (!comp(get(a), get(b)) ? area(a.st, a.ed, b.ed) < 0 : get(a) < get(b));}
PDD inter(PDD p, PDD v, PDD q, PDD w)
{double t = cross(w, p - q) / cross(v, w); return {p.x + v.x * t, p.y + v.y * t};}
PDD get_line(Line a, Line b) {return inter(a.st, a.ed - a.st, b.st, b.ed - b.st);}
bool judge(Line a, Line b, Line c) {return sign(area(a.st, a.ed, get_line(b, c))) <= 0;}

double get_hpi()
{
    sort(l, l + cnt, cmp);
    int hh = 0, tt = -1;
    for (int i = 0; i < cnt; i ++ )
    {
        if (i && !comp(get(l[i]), get(l[i - 1]))) continue;
        while (hh < tt && judge(l[i], l[q[tt - 1]], l[q[tt]])) tt -- ;
        while (hh < tt && judge(l[i], l[q[hh]], l[q[hh + 1]])) hh ++ ;
        q[ ++ tt] = i;
    }
    while (hh < tt && judge(l[q[hh]], l[q[tt - 1]], l[q[tt]])) tt -- ;
    while (hh < tt && judge(l[q[tt]], l[q[hh]], l[q[hh + 1]])) hh ++ ;
    q[ ++ tt] = q[hh];
    int k = 0;
    for (int i = hh; i < tt; i ++ )
        ans[k ++ ] = get_line(l[q[i]], l[q[i + 1]]);
    double res = 0;
    for (int i = 1; i < k - 1; i ++ )
        res += area(ans[0], ans[i], ans[i + 1]);
    return res / 2;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%lf%lf", &pg[i].x, &pg[i].y);
    pg[n + 1] = pg[1];
    for (int i = 1; i <= n; i ++ ) l[cnt ++ ] = {pg[i], pg[i + 1]};
    for (int i = 2; i <= n; i ++ )
    {
        double A = pg[1].y - pg[2].y + pg[i + 1].y - pg[i].y;
        double B = pg[2].x - pg[1].x + pg[i].x - pg[i + 1].x;
        double C = cross(pg[1], pg[2]) + cross(pg[i + 1], pg[i]);
        if (!comp(B, 0)) l[cnt ++ ] = {(PDD){-C / A, 0}, (PDD){-C / A, A}};
        else l[cnt ++ ] = {(PDD){0, -C / B}, (PDD){-B, -C / B + A}};
    }

    double tot = 0;
    for (int i = 2; i < n; i ++ )
        tot += area(pg[1], pg[i], pg[i + 1]);
    printf("%.4lf\n", get_hpi() / (tot / 2));
    return 0;
}
```

---

## 作者：HyperSQ (赞：2)

# P4250

[题目链接](https://www.luogu.com.cn/problem/P4250) 

稍微讲点细节。

题意：给出一个凸多边形，点按 $0$ ~ $n-1$ 逆时针编号，现在有一个多边形内的随机点 $P$ ，对于任意的 $\triangle PP_iP_{i-1}$ 均满足
$$
S_{\triangle PP_0P_1}< S_{\triangle PP_{i}P_{i-1} }
$$
求满足条件的概率。按照几何概型实际上就是求满足条件的区域占总面积的比。

![](https://cdn.luogu.com.cn/upload/image_hosting/xqtjdvtt.png)

所以可知
$$
\begin{aligned}

\overrightarrow{PP_{0}}\times\overrightarrow{PP_{1}}&<
\overrightarrow{PP_{i-1}}\times \overrightarrow{PP_{i}}\\
(x_{0}-x,y_0-y)\times(x_{1}-x,y_1-y)&<
(x_{i-1}-x,y_{i-1}-y)\times(x_{i}-x,y_{i}-y)\\
\end{aligned}
$$
~~容易~~整理得（就嗯算没啥技巧，所以过程不写了QwQ）
$$
(y_0+y_i-y_1-y_{i-1})x+(x_1+x_{i-1}-x_0-x_i)y+x_0y_1+x_iy_{i-1}-x_1y_0-x_{i-1}y_i< 0
$$
是直线半平面的一般形式，这个式子我们简单记为 $Ax+By+C<0 \Rightarrow By<-Ax-C$。

所以对所有半平面求半平面交即可。

为了避免精度差，我们用点与向量来记录一条直线，向量左侧的空间就是这个直线对应的的半平面，所以向量方向不同会影响答案正确性。因此细节在于实现解析式转 $l=\{P,\mathbf v\}$。先对 $B$ 的情况分类讨论。

**1、$B$ 不为 $0$ 。**

于是直线不与 $y$ 轴平行，可知 $(0,-\frac{C}{B})$ 与 $(-B,-\frac{C}{B}+A)$  为直线上两点。

讨论向量的方向。记向量角为 $\theta$ 。原式 $By<-Ax-C$ ，

当 $B>0$ 对应下平面，应满足 $\theta \in (\frac{\pi}{2},\frac{3\pi}{2})$ ； $B<0$ 时为直线上平面，因此 $\theta \in (-\frac{\pi}{2},\frac{\pi}{2})$。

因此这个直线要满足：$B\cos\theta<0$。根据这个调整向量的方向。

**2、$B$ 为 $0$（一定要讨论这种情况，不然会错）**

直线与 $y$ 轴平行，此时经过点 $(-\frac{C}{A},0)$。原式 $Ax<-C$。

当 $A>0$ 时对应直线左平面，因此向量指向 $\frac{\pi}{2}$ 角；

当 $A<0$ 时对应直线右平面，因此向量指向 $\frac{3\pi}{2}$ 。

因此要满足 $A\sin\theta>0$。

接下来就是板子了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=4e5+5;
const double eps=1e-20;
#define Point complex<double>
#define Vector Point
#define Polygon vector<Point>
#define pb push_back
#define X real()
#define Y imag()

double cross(Vector u,Vector v){
    return u.X*v.Y-u.Y*v.X;
}
int sgn(double x){
    return x<-eps?-1:x>eps;
}

struct Line{
    Point p;Vector v;double a;
    Line(Point p=0,Vector v=0):v(v),p(p){
        a=arg(v);
    }
};

bool cmp(Line a,Line b){
    if(fabs(a.a-b.a)>eps) return a.a<b.a;
    return cross(b.p-a.p,a.v)>0;
}

Line l[maxn];int cnt;

bool on_left(Point p,Line l){
    return sgn(cross(l.v,p-l.p))>0;
}

void line_inter(Line a,Line b,Point &p){
    double c=cross(a.v,b.v);
    if(sgn(c)==0) return;
    p=a.p+a.v*cross(b.v,a.p-b.p)/c;
}

void halfplane_inter(Polygon &g){
    vector<Point> q(cnt);
    sort(l,l+cnt,cmp);
    int head=0,tail=0;
    for(int i=1;i<cnt;i++){
        if(!sgn(l[i].a-l[i-1].a)) continue;
        while(head<tail&&!on_left(q[tail-1],l[i])) tail--;
        while(head<tail&&!on_left(q[head],l[i])) head++;
        l[++tail]=l[i];
        if(head<tail) line_inter(l[tail-1],l[tail],q[tail-1]);
    }
    while(head<tail&&!on_left(q[tail-1],l[head])) tail--;
    if(head<tail) line_inter(l[tail],l[head],q[tail]);
    g.assign(q.begin()+head,q.begin()+tail+1);
}

double polygon_area(Polygon &g){
    double ret=0;
    for(int i=0;i<g.size()-1;i++){
        ret+=cross(g[i]-g[0],g[i+1]-g[0]);
    }
    ret/=2;return ret;
}

int n;
Polygon p,g;

int main(){
#ifdef LOCAL
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        double x,y;
        scanf("%lf%lf",&x,&y);
        p.pb(Point(x,y));
    }
    p.pb(p[0]);
    for(int i=2;i<=n;i++){
        double A=p[0].Y+p[i].Y-p[1].Y-p[i-1].Y;
        double B=-(p[0].X+p[i].X-p[1].X-p[i-1].X);
        double C=p[0].X*p[1].Y+p[i].X*p[i-1].Y-p[1].X*p[0].Y-p[i-1].X*p[i].Y;
        if(!sgn(B)){
            Point p1(-C/A,0);
            Vector v(0,A);
            if(sgn(A*sin(arg(v)))<0) v=-v;
            l[cnt++]=Line(p1,v);
        }else{
            Point p1(0,-C/B);
            Vector v(-B,A);
            if(sgn(cos(arg(v))*B)>0) v=-v;
            l[cnt++]=Line(p1,v);
        }
    }
    for(int i=0;i<n;i++){
        l[cnt++]=Line(p[i],p[i+1]-p[i]);
    }
    p.pop_back();
    halfplane_inter(g);
    double S=polygon_area(p);double s=polygon_area(g);
    if(s<0.0) puts("0.0000");
    else printf("%.4lf",s/S);
}
```

---

## 作者：Piwry (赞：1)

游戏的次数是啥....这好像和一次的概率没啥关系（

## 解析

我们先考虑对两条边怎么选点才可使连接出的三角形满足条件：

首先试图找到正好使两个三角形面积相等的点的集合；其中保证有这样的点是很显然的：

![1](https://cdn.luogu.com.cn/upload/image_hosting/15mb61cn.png)

（有点小误差QAQ）

由于线段长是固定的，因此我们只需关心垂线段的长度；而垂线段长则取决于垂线和线段延伸的直线的交点位置。对于两条线段，这样的交点应该都是呈**一次函数关系**的；因此可以猜想我们所有的点集也是在**一条直线**上。

&nbsp;

得到方向后，我们尝试暴力推一波式子：

![2](https://cdn.luogu.com.cn/upload/image_hosting/esm7smrf.png)

首先拆开推一下可以发现以下结论：

$(\vec{u}\pm\vec{v})\times \vec{w}=\vec{u}\times\vec{w}\pm\vec{v}\times\vec{w}$

（“$\times$” 指叉积，叉积左右元素交换一下这个式子也适用）

原来的式子是

$\overrightarrow{AB}\times(\vec{P}-\vec{A})<\overrightarrow{CD}\times(\vec{P}-\vec{C})$

因为只求边界，我们改成等号：

$\overrightarrow{AB}\times(\vec{P}-\vec{A})=\overrightarrow{CD}\times(\vec{P}-\vec{C})$

$\overrightarrow{AB}\times\vec{P}-\overrightarrow{AB}\times\vec{A}=\overrightarrow{CD}\times\vec{P}-\overrightarrow{CD}\times\vec{C}$

$\overrightarrow{AB}\times\vec{P}-\overrightarrow{CD}\times\vec{P}-\overrightarrow{AB}\times\vec{A}+\overrightarrow{CD}\times\vec{C}=0$

$(\overrightarrow{AB}-\overrightarrow{CD})\times\vec{P}-\overrightarrow{AB}\times\vec{A}+\overrightarrow{CD}\times\vec{C}=0$

推到这里，我们其实已经可以发现点 $P$ 的 $y$ 坐标是关于其 $x$ 坐标的一次函数了。

想要接着往下推，就必须得拆出点坐标：

设 $c=-\overrightarrow{AB}\times\vec{A}+\overrightarrow{CD}\times\vec{C}$

可得 $(x_{AB}-x_{CD})y_P-(y_{AB}-y_{CD})x_P+c=0$

于是对于这两条边，点 $P$ 的所有满足条件的点坐标即为

$(y_{CD}-y_{AB})x_P+(x_{AB}-x_{CD})y_P+c<0$

且满足在凸包内。

可以发现这就是一条直线的半平面（最后还要加上凸包限制）。

&nbsp;

对于凸包所有的边，我们都按上述方法求一遍，并把所有求得的直线加上凸包边的限制放进半平面交跑一跑，就得到了所有可能的站位。而这个站位集合除以凸包面积，就是一次站位合法的概率。

---

另外，如果直接用解析法求两个点精度误差可能会较大，其实对于第二个点我们有更好的办法：

首先我们可以对 $x$ 或 $y$ 取特值 $0$，于是就可以很方便地求出第一个点。

然后我们可以想到，对于 $ax+by+c=0$，其中所有变量均确定，如果我们将 $x$ 加上 $\pm b$，将 $y$ 加上 $\mp a$，这个式子仍成立。这样就可以**不用乘除地**求出第二个点。

至于究竟是 $(x+b), (y-a)$ 还是 $(x-b), (y+a)$，我们先画一张图看看：

![3](https://cdn.luogu.com.cn/upload/image_hosting/wyyezwpb.png)

（图中的解析式应为 $Ax+By+c=0$，其中 $A, B$ 为正实数）

假设我们最后做的是左半平面交，显然 $(x+b), (y-a)$ 是 $\overrightarrow{QP}$，不是我们想要的；而 $(x-b), (y+a)$ 是 $\overrightarrow{PQ}$，画出图像可以发现是对的。

（如果是右半平面交...那反一下就行了）

&nbsp;

最后再手玩一下几种特殊情况发现都是正确的...于是就可以了。（话说许多计算几何的瞪眼思路都是按一张一般情况的图做，然后对各种特殊情况正正反反最后总是正确的QAQ）

## CODE

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using std::sort;
using std::pair;
typedef pair<int, int> pad;

const int MAXN =3e5;

/*------------------------------Computational geometry------------------------------*/

const double pi =acos(-1), eps =1e-6;

struct vect{
	double x, y;
	vect(){}
	vect(double xx, double yy):x(xx), y(yy){}
	double m(){ return sqrt(x*x+y*y); }
	vect operator + (vect v){ return vect(x+v.x, y+v.y); }
	vect operator - (vect v){ return vect(x-v.x, y-v.y); }
	vect operator * (double mu){ return vect(mu*x, mu*y); }
	double operator / (vect v){ return x*v.y-y*v.x; }/*叉积*/
};

struct line{
	vect u, v;
	double angle;
	line(){}
	line(vect uu, vect vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

inline short gtr(double a, double b){ return (a-b > eps); }

inline bool eq(double a, double b){ return (a-b < eps && a-b > -eps); }

inline bool onright(line f, vect w){ return (gtr((w-f.u)/(f.v-f.u), 0)); }

vect getIntersection(line f, line g){
	double w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));
	return g.u+(g.u-g.v)*w;
}

int cmp(line A, line B){
	if(eq(A.angle, B.angle)) return onright(B, A.u);/*有向直线最左的在最后面，会被保留*/
	else return (gtr(B.angle, A.angle));
}

/*求左半平面交*/
inline pad getHPI(line ls[], int totl, line hull[]){
	sort(ls, ls+totl, cmp);
	int l =0, r =0;
	for(int i =0; i < totl; ++i){
		while(i < totl-1 && eq(ls[i].angle, ls[i+1].angle)) ++i;
		while(r-l > 1 && onright(ls[i], getIntersection(hull[r-1], hull[r-2]))) --r;
		if(r > 0 && eq(ls[i].angle-hull[r-1].angle, pi)) return pad(0, 0);/*判方向相反的平行*/
		hull[r++] =ls[i];
	}
	while(r-l > 1){
        if(onright(hull[r-1], getIntersection(hull[l], hull[l+1]))) ++l;
        else if(onright(hull[l], getIntersection(hull[r-1], hull[r-2]))) --r;
        else break;
    }
	if(r-l < 3) return pad(0, 0);
	else return pad(l, r);
}

inline double getS(line hull[], int toth){
	hull[toth++] =hull[0];
	double S =0;
	vect v0 =getIntersection(hull[0], hull[1]), v1, v2 =getIntersection(hull[1], hull[2]);
	for(int p =0; p+3 < toth; ++p){
		v1 =v2, v2 =getIntersection(hull[p+2], hull[p+3]);
		S +=(v1-v0)/(v2-v1);
	}
	return S/2;
}

/*------------------------------Main------------------------------*/

line ls[MAXN], hull[MAXN];
int totl;

/*基本是照着式子写的 qwq*/
inline line get(line f, line g){
	vect AB =f.v-f.u, CD =g.v-g.u;
	/*ax+by+c=0*/
	double a =CD.y-AB.y, b =AB.x-CD.x, c =-(AB/f.u)+CD/g.u;
	double x, y;
	/*避免有系数为 0*/
	if(eq(a, 0)) x =0, y =-c/b;
	else y =0, x =-c/a;
	return line(vect(x, y), vect(x, y)+vect(-b, a));
}

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

int main(){
	int n =read();
	vect fst, pre;
	fst.x =read(), fst.y =read(), pre =fst;
	for(int i =0; i < n-1; ++i){
		vect rec;
		rec.x =read(), rec.y =read();
		ls[totl++] =line(pre, rec);
		pre =rec;
	}
	ls[totl++] =line(pre, fst);
	
	double Sall =getS(ls, totl);
	for(int i =1; i < n; ++i)
		ls[totl++] =get(ls[0], ls[i]);
	/*原来的多边形已经保证面积有限了，这里不用加边界*/
//	ls[totl++] =line(vect(MAX, MAX), vect(-MAX, MAX));
//	...
	pad Hull =getHPI(ls, totl, hull);
	if(Hull.second == 0) puts("0.000");
	else printf("%.4lf", getS(hull+Hull.first, Hull.second-Hull.first)/Sall);
}
```


---


# 【模板】三维凸包

## 题目描述

给出空间中 $n$ 个点，求凸包表面积。

## 说明/提示

$4 \le n \le 2000$

## 样例 #1

### 输入

```
4 
0 0 0
1 0 0
0 1 0
0 0 1```

### 输出

```
2.366```

# 题解

## 作者：Piwry (赞：152)

~~建议还是只写个增量法够了~~

## 0.基础介绍

### 向量加减

同二维。

```cpp
vect operator - (vect v){ return vect(x-v.x, y-v.y, z-v.z); }
```

### 向量点积（数值积）

同二维。

意义也和二维一样。

```cpp
double operator * (vect v){ return x*v.x+y*v.y+z*v.z; }
```

### 向量叉积

```cpp
vect operator / (vect v){ return vect(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }
```

返回的是一个空间向量

它的**默认**方向和两个输入向量满足右手定理（形如三维坐标轴：$x$ 逆时针到 $y, z$，$y$ 逆时针到 $z$。返回的向量可以看做 $z$ 轴），

长度是输入向量构成的平行四边形面积，

**正负**由第一个向量到第二个向量的逆时针夹角决定（同二维），

不满足交换律

&nbsp;

3b1b 中有对其含义的一种解释：
将输入向量的起点置于原点，定义运算 $*$ 表示求一个点和输入向量构成的平行四边形构成的平行六面体的有向体积  $^1$，

那么做这个运算 $*$ 就相当于和输入向量的**叉积**（叉积方向为第一个叉第二个）做点积。

[1] 有向体积：设输入向量 $u, v$，原点 $O$，则有平面（具体存储规则见下） $(O, O+u, O+v)$。若点在平面上方则体积为正，否则为负。

### 向量模长

```cpp
double m(){ return sqrt(x*x+y*y+z*z); }
```

投影到坐标面化简下式子就可以。

### 面的存储

```cpp
struct plane{
	vect v[3];
	plane(){}
	plane(vect uu, vect vv, vect ww){ v[0] =uu, v[1] =vv, v[2] =ww; }
	vect normal(){ return (v[1]-v[0])/(v[2]-v[0]);}
};
```

存储面上的三个点。

若定义面的 "上方" 和 "下方"，则这三个点是按**从上方看到**的逆时针顺序排列的

其法向量（`vect normal()`）即为从一个点顺次连向后两个点的向量的叉积（顺次）。这个向量竖直指向面的**上方**。

### 判断点与面关系

```cpp
inline bool isabove(vect v, plane p){ return gtr((v-p.u())*p.normal()/*这是投影长度乘法向量模长，只是因为不需要知道数值只需要符号，所以没做处理*/, 0); }
```

只需判断法向量起点到该点的这个向量在法向量上的投影符号即可。

### 点与面的距离

（这个在 quickhull 会用到）

```cpp
/*带方向距离*/
inline double dist(vect v, plane p){ return (v-p.u())*p.normal()/p.normal().m(); }
```

法向量起点到该点的这个向量在法向量上的投影长。

### 多面体的储存

通常我们通过储存**面**来储存多面体。

对于多面体每个面的面积，我们可以用叉积的含义轻易算出：

```cpp
plane facet;
double S =facet.normal().m()/2;/*其面积*/
```

---

（这一节从这往下，以及下一节 "地平线" 都是和 quickhull 有关的了，不感兴趣的可以跳过。本文介绍的前两个算法只需用数组单纯地存下平面即可）

在某些情况下，我们还需要存储每个面的**邻接面信息**。

为了方便，我们将每个顶点**大于三个**的面划分成若干个三角形的面；视具体情况可能划分后的面的顶点**不属于原来面的顶点**。

于是我们就可以这样保存面：

```cpp
struct facet{
	int n[3];/*neighbor，和点对应 (u->v, v->w, w->u)*/
	plane p;
};
```

对于一个多面体，我们保存其中一个面作为**索引**，就可以通过邻接信息读取多面体的表面。

### 地平线

（貌似一般都叫 "Horizon"...直译过来就是地平线...）

对于一个点和一个多面体，从该点能 "看到" 的所有面一定是一片连续的面，而**这片面的边缘**就是这个点在这个多面体上的地平线。

![地平线](https://cdn.luogu.com.cn/upload/image_hosting/t418fykz.png)

（可想象站在高处望向远处的场景...）

若要求得地平线，我们可以从某个该点能看到的面（具体来说就是这个面的**平面**在该点下面）开始 dfs（这个面也可以从索引面开始 dfs 求出），并在图中标记所有**边缘面**；

对于每个边缘面，我们将每条**边缘边**的两个顶点**建图**连边。

可以知道我们最后求出的图一定是一个**环**。

同时为了避免不必要的计算，我们可以在 dfs 顺便返回一个环上的一个点作为索引。

```cpp
struct vect{
	double x, y, z;
	int id;
};

struct plane{
	vect vec[3];
};

struct facet{
	int n[3];
	int id, vistime /*相当于一个时间戳*/;
	plane p;
};

struct edge{
	int netid /*连向点的 id*/, facetid /*当前这条边缘边邻接的不可看见的面的 id*/;
};

bool isabove(vect v, plane p){ /*return (点是在面上方 );*/ }

vector<facet> FAC;/*存储所有面*/

int TIME =0;/*全局时间*/

/*e1 e2 存储一个点连的两条边，resfdel 存储所有看到的面，vistime 是每个点访问的时间戳*/
/*调用前需要更新时间 (++TIME)，清空 resfdel(至于 e1 e2 不清也没关系)*/
/*最后会返回边界线上的一个点，并保存地平线信息和所有能看到的面到指定数组*/
int getHorizon(int f, vect &p, int vistime[], edge e1[], edge e2[], vector<int> &resfdel){
	if(!isabove(p, FAC[f].p)) return 0;/*如果返回 0 则代表这个面无法看见*/
	if(FAC[f].vistime == TIME) return -1;/*如果返回 -1 则代表这个面已经见过*/
	FAC[f].vistime =TIME;/*记录当前时间戳*/
	FAC[f].isdel =1;
	resfdel.push_back(FAC[f].id);
	int ret =-2;/*如果返回 -2 则代表这个面的 dfs 树无法接触到地平线*/
	/*--(思考下 dfs 一个被夹在中心的面，周围一圈的面都已搜索过 )*/
	for(int i =0; i < 3; ++i){
		int res =getHorizon(FAC[f].n[i], p, vistime, e1, e2, resfdel);
		if(res == 0){
			int pt[2];
			pt[0] =FAC[f].p.vec[i].id, pt[1] =FAC[f].p.vec[(i+1)%3].id;
			for(int j =0; j < 2; ++j){
				/*我们无法得知这条边是沿缺口逆时针还是顺时针的*/
				/*根据被访问的次数判断这是该点连的第一条还是第二条边*/
				if(vistime[pt[j]] != TIME){
					vistime[pt[j]] =TIME;
					e1[pt[j]].netid =pt[(j+1)%2];
					e1[pt[j]].facetid =FAC[f].n[i];
				}
				else{
					e2[pt[j]].netid =pt[(j+1)%2];
					e2[pt[j]].facetid =FAC[f].n[i];
				}
			}
			ret =pt[0];
		}
		else if(res != -1 && res != -2) ret =res;/*保存地平线上的点*/
	}
	return ret;
}
```

### 多面体面与边的关系

我们可以想到，一条边会且仅会被两个面使用；按我们储存面的方式，这条边一定是被 "逆时针用一次"，再 "顺时针用一次"。

就像下图中那样：

![凸包边](https://cdn.luogu.com.cn/upload/image_hosting/osuk8fe7.png)

这个性质可以帮助我们**通过统计边来获得多面体面的信息**。

## 1.增量法

### 基本思路

我们考虑加入一个点时如何维护凸包

![增量法1](https://cdn.luogu.com.cn/upload/image_hosting/s7032kh8.png)

可以发现只有它能 "看到" 的面，或者说**在该点下方**的面（对于点**恰好**在面上，我们**不算**能 "看到"）会被删除。

所以初始先构造一个**任意**单纯形（四个顶点的多面体）。我们每加入一个点，就遍历所有面找出能看到的面，将它们删除；并对 "缺口" 的边缘边和新点连面，加入凸包。

### 求缺口边缘（地平线）

对于边缘的标记，我们可以想到：一条边会且仅会被两个面使用；按我们储存面的方式，这条边一定是被 "逆时针用一次"，再 "顺时针用一次"。（这里 copy 自上面）

于是用一个二维数组标记，只对**只使用一次**的边，按**使用过的方向**和新点连面即可（可见代码）。

### 对特殊情况的考虑

有时可能会出现几个点共面的情况。

我们考虑增量法的实现，可以发现在已有面上的点是无效的，也不会产生贡献。

不过由于我们连的面都是三角形，因此最后求得的面集合可能会把原来一个多边形面划分成**多个**三角形小面（同时也不保证三角形的顶点一定在**边**上）。注意后续运算需要考虑**去重**的问题。

---

另外，值得一提的是，如果我们通过扰动点（给点的坐标增减一个很小的数值）来期望**最多使三个点共面**，我们初始可以**只构造面**。这样可以略微缩减代码量。

不扰动的话这样可能出错。考虑这样的数据：

![增量法2](https://cdn.luogu.com.cn/upload/image_hosting/42c6isbg.png)

由于扰动的值不需要太大，因此一般的精度要求用这种方法都可以满足。

### CODE

扰动点（只构造面）：

```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>

const int MAXN =2500;

/*------------------------------Computational geometry------------------------------*/

const double eps =1e-8;

struct vect{
	double x, y, z;
	vect(){}
	vect(double xx, double yy, double zz):x(xx), y(yy), z(zz){}
	vect operator - (vect v){ return vect(x-v.x, y-v.y, z-v.z); }
	vect operator / (vect v){ return vect(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }
	double operator * (vect v){ return x*v.x+y*v.y+z*v.z; }
	double m(){ return sqrt(x*x+y*y+z*z); }
	double rd(){ return (rand()%2) ? eps : -eps; }
	void shake(){ x +=rd(), y +=rd(), z +=rd(); }
}pts[MAXN];

struct plane{
	int v[3];/*节省空间*/
	plane(){}
	plane(int uu, int vv, int ww){ v[0] =uu, v[1] =vv, v[2] =ww; }
	vect normal(){ return (pts[v[1]]-pts[v[0]])/(pts[v[2]]-pts[v[0]]); }
};

inline bool gtr(double a, double b){ return (a-b > eps); }

inline bool eq(double a, double b){ return (a-b > -eps && a-b < eps); }

inline double dist(vect x, vect y){ return (x-y).m(); }

inline double dist(vect v, vect f1, vect f2){ return ((f2-f1)/(v-f1)).m()/(f2-f1).m(); }

inline bool isabove(vect v, plane p){ return gtr((v-pts[p.v[0]])*p.normal(), 0); }

/*------------------------------Convex Hulls------------------------------*/

int vise[MAXN][MAXN];
plane res[MAXN<<1], del[MAXN<<1];

inline int getConvexHulls(int totp, plane facets[]){
	int s[3];
	s[0] =0, s[1] =1, s[2] =2;
	int totf =0;
	facets[totf++] =plane(s[0], s[1], s[2]);
	facets[totf++] =plane(s[0], s[2], s[1]);
	for(int i =0; i < totp; ++i){
		/*重复的点不会产生贡献*/
		int totr =0, totd =0;
		for(int j =0; j < totf; ++j){
			if(!isabove(pts[i], facets[j])) res[totr++] =facets[j];/*这里保存不需要删除的面*/
			else{
				del[totd++] =facets[j];
				/*由于每个点只会循环一次，所以这个 i+1 就相当于一个时间戳*/
				for(int k =0; k < 3; ++k)
					vise[facets[j].v[k]][facets[j].v[(k+1)%3]] =i+1;
			}
		}
		for(int j =0; j < totd; ++j){
			plane f =del[j];
			for(int k =0; k < 3; ++k)
				if(vise[f.v[k]][f.v[(k+1)%3]] == i+1 && vise[f.v[(k+1)%3]][f.v[k]] != i+1)
					res[totr++] =plane(f.v[k], f.v[(k+1)%3], i);
		}
		totf =totr;
		for(int j =0; j < totr; ++j) facets[j] =res[j];
	}
	return totf;
}

/*------------------------------Main------------------------------*/

plane facets[MAXN<<1];

int main(){
	int n; scanf("%d", &n);
	for(int i =0; i < n; ++i) scanf("%lf%lf%lf", &pts[i].x, &pts[i].y, &pts[i].z), pts[i].shake();/*扰动点*/
	int h =getConvexHulls(n, facets);
	double area =0;
	for(int i =0; i < h; ++i) area +=facets[i].normal().m()/2;
	printf("%.3lf", area);
}
```

&nbsp;

---

不扰动点（仅给出不同部分）：

```cpp
/*------------------------------Convex Hulls------------------------------*/

inline int getConvexHulls(int totp, plane facets[]){
	int s[4];
	s[0] =0, s[1] =1, s[2] =2, s[3] =0;
	while(s[2] < totp-1 && eq(dist(pts[s[2]], pts[s[0]], pts[s[1]]), 0)) ++s[2];/*确保不共线*/
	while(s[3] < totp-1 && eq(dist(pts[s[3]], plane(s[0], s[1], s[2])), 0)) ++s[3];/*确保不共面*/
	if(gtr(0, dist(pts[s[3]], plane(s[0], s[1], s[2])))) s[1] ^=s[2] ^=s[1] ^=s[2];/*为了保证下面构造的面向外*/
	int totf =0;
	facets[totf++] =plane(s[0], s[2], s[1]);
	facets[totf++] =plane(s[0], s[1], s[3]);
	facets[totf++] =plane(s[1], s[2], s[3]);
	facets[totf++] =plane(s[2], s[0], s[3]);
	
	/*...*/
	
	return totf;
}

/*------------------------------Main------------------------------*/

int main(){
	int n; scanf("%d", &n);
	for(int i =0; i < n; ++i) scanf("%lf%lf%lf", &pts[i].x, &pts[i].y, &pts[i].z);/*没有扰动*/
	
	/*...*/
	
	printf("%.3lf", area);
}
```

### 复杂度及其它

可以想到是 $O(n^2)$ 的。由于内部没有太多分支，常数应该不会太大。

这种做法可以很轻松地支持在线

## 2.卷包裹法（gift warp）

### 基本思路

我们想象用一张纸慢慢地包住凸包。

具体来说，我们想象有一个平面从凸包的**一个面的一条边**开始向**内**折，并取**第一个**碰到的点作为新的面的顶点，构造新面；这是一次打包（warp）。

我们再将新面新产生的两条边**包含其面的信息**（具体来说是边的方向，参考上文介绍的 面与边的关系）放入队列，重复同样的工作，直到没有边可以再打包即可。

![卷包裹1](https://cdn.luogu.com.cn/upload/image_hosting/f7824v61.png)

### 如何找到合适的点

比较直观的思路是求出所有点相对当前面的 "夹角"，不过这种方式难以实现。

我们再转化其含义，可以发现这实际上就是求一个新多边形面，使剩下的所有点都在新面**下方**（新面上方朝多面体外侧）。

```cpp
/*单次打包*/
/*大部分变量名实例同上文*/
/*ne 是指当前边，边的方向保存了原来面的信息*/
pair<int, int> ne;/*存储两个顶点的 id*/
int p =-1;
for(int i =0; i < totp; ++i){
	if(i == ne.first || i == ne.second) continue;/*避免作为 p 的初始值 (p == -1)*/
	if(p == -1 || isabove(pts[i], plane(ne.first, ne.second, p)))
		p =i;
}
```
### 构建初始边

卷包裹法一开始需要一个属于最终凸包的边作为算法起点。

我们可以想到，如果将凸包 "**拍平**" 到一个平面上，其映射在平面上的点集的凸包的边一定也是原凸包的边。

![初始边](https://cdn.luogu.com.cn/upload/image_hosting/mj04avg6.png)

因此我们只需取某个坐标最大的点作为第一个点（它一定是凸包顶点），再将所有点拍平到某个面上（例如坐标面）按二维卷包裹法求一条相邻的边即可。

```cpp
/*将 z 拍平的向量叉积*/
double mul2(vect u, vect v){ return u.x*v.y-u.y*v.x; }

/*将 z 拍平*/
inline bool onright(vect v, vect f1, vect f2){ return gtr(mul2(v-f1, f2-f1), 0); }

{/*求初始边*/
	int s[2];
	s[0] =0, s[1] =-1;
	for(int i =1; i < totp; ++i)
		if(gtr(pts[i].x, pts[s[0]].x))/*取 x 坐标最大的点*/
			s[0] =i;
	for(int i =0; i < totp; ++i){
		if(i == s[0]) continue;
		if(s[1] == -1 || onright(pts[i], pts[s[0]], pts[s[1]])/*点是否在直线 (拍平 )右侧*/)
			s[1] =i;
	}
}
```

### 卷包裹的共面难题

我们同样也考虑多个点共面的特殊情况。

首先可以想到一种比较 "友好" 的共面情况：

![共面](https://cdn.luogu.com.cn/upload/image_hosting/8bd32cpb.png)

可以想到我们只需取和当前边所做三角形面积最大的的点就可以了。

但接下来再考虑这种情况：

![共面F](https://cdn.luogu.com.cn/upload/image_hosting/bfscp3e0.png)

虽然我们对求得面要求并不严格，但这种重叠的面一定是**不合法**的。

&nbsp;

或许可以想到将这些点映射到它们的平面上并求一次二维凸包，再**一次性**做它们面。由于每个点至多只会被带入做**一次**二维凸包，所以这种方法的复杂度是可以接受的。

但其代码复杂度难以想象...

相对而言更有效的方法是直接对点扰动，这样就可以直接**不考虑共面的问题**。

（如果有比映射求二维凸包更简洁的方法请务必联系我 QAQ）

### CODE

（仅含有扰动实现的代码）

下面的代码进行了多次扰动。

主要原因是增量法**只有在一开始**有共面的危险（只用一个面做初始数据），但卷包裹法在**每一次循环**中都是要求不能超过三个点共面的。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
using std::pair;
typedef pair<int, int> pad;

const int MAXN =2500;

/*------------------------------Computational geometry------------------------------*/

const double eps =1e-9;

struct vect{
	double x, y, z;
	vect(){}
	vect(double xx, double yy, double zz):x(xx), y(yy), z(zz){}
	vect operator - (vect v){ return vect(x-v.x, y-v.y, z-v.z); }
	vect operator / (vect v){ return vect(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }
	double operator * (vect v){ return x*v.x+y*v.y+z*v.z; }
	double m(){ return sqrt(x*x+y*y+z*z); }
}pts[MAXN];

struct plane{
	int v[3];
	plane(){}
	plane(int uu, int vv, int ww){ v[0] =uu, v[1] =vv, v[2] =ww; }
	vect normal(){ return (pts[v[1]]-pts[v[0]])/(pts[v[2]]-pts[v[0]]); }
};

inline bool gtr(double a, double b){ return (a-b > eps); }

inline double dist(vect x, vect y){ return (x-y).m(); }

inline bool isabove(vect v, plane p){ return gtr((v-pts[p.v[0]])*p.normal(), 0); }

double mul2(vect u, vect v){ return u.x*v.y-u.y*v.x; }

/*将 z 拍平*/
inline bool onright(vect v, vect f1, vect f2){ return gtr(mul2(v-f1, f2-f1), 0); }

/*------------------------------Convex Hulls------------------------------*/

bool vise[MAXN][MAXN];
pad q[MAXN<<1]; int head, tail;

inline int getConvexHulls(int totp, plane facets[]){
	int s[2];
	s[0] =0, s[1] =-1;
	for(int i =1; i < totp; ++i)
		if(gtr(pts[i].x, pts[s[0]].x))
			s[0] =i;
	for(int i =0; i < totp; ++i){
		if(i == s[0]) continue;
		if(s[1] == -1 || onright(pts[i], pts[s[0]], pts[s[1]]))
			s[1] =i;
	}
	
	int totf =0;
	q[tail++] =pad(s[0], s[1]);
	q[tail++] =pad(s[1], s[0]);
	while(tail-head){
		pad ne =q[head++];
		if(vise[ne.first][ne.second]) continue;
		vise[ne.first][ne.second] =1;
		int p =-1;
		plane nf;
		for(int i =0; i < totp; ++i){
			/*避免当前边顶点作为 p 的初始值 (p == -1)，不然会导致面的三点共线*/
			if(i == ne.first || i == ne.second) continue;
			if(p == -1 || isabove(pts[i], nf))
				p =i, nf =plane(ne.first, ne.second, p);
		}
		facets[totf++] =nf;
		vise[ne.second][p] =vise[p][ne.first] =1;
		q[tail++] =pad(p, ne.second); q[tail++] =pad(ne.first, p);
	}
	return totf;
}

/*------------------------------Main------------------------------*/

plane facets[MAXN<<1];

double reps() {return (rand()/(double)RAND_MAX-0.5)*eps;}

int main(){
	int n; scanf("%d", &n);
	for(int i =0; i < n; ++i) scanf("%lf%lf%lf", &pts[i].x, &pts[i].y, &pts[i].z);
	/*具体扰动次数可以参考 :数据规模每增大 10 的次方扰动一次*/
	for(int k =0; k < 3; ++k) for(int i =0; i < n; ++i) pts[i].x +=reps(), pts[i].y +=reps(), pts[i].z +=reps();
	int h =getConvexHulls(n, facets);
	double area =0;
	for(int i =0; i < h; ++i) area +=facets[i].normal().m()/2;
	printf("%.3lf", area);
}
```

### 复杂度及其它

是 $O(nh)$ 的，其中 $h$ 是凸包点数；随机数据下减少的循环次数非常可观（自测了几个数据，大概是 $\sqrt n$ 的，仅供参考）

不过不知道为什么我写实现常数非常大，实际效率和我的增量法一样...（可能是因为过多的结构体构造）

这种做法是不支持在线的。

## 3. QuickHull

这种做法因为其和 快速排序 类似的启发式划分而得名。

（如果有人知道二维的 quickhull 的话，注意其实三维的 quickhull 和二维的区别还是蛮大的...）

### 基本思路

对于一个由**最终凸包顶点**组成的面和另一个点组成的棱锥，所有在**其内部**的点都是可以直接排除的。

&nbsp;

具体来说，我们有一个均由最终凸包顶点组成的多面体 $H'$，其一个面（或面的划分，保证是一个三角形） $\pi$，和它被分配到的一个点集 $P_\pi$。

我们取离这个面**最远**的点，和**多面体对于这个点的地平线**连面**更新多面体**，可以获得多个**新面** $F$，可以知道这些面的顶点一定是最终凸包的顶点；

将 $P_\pi$ 剩下的点**加上**被删除的面的点集 $P$，划分给 $F$，并保证每个点在划分到的面*的*上方**（注意一个点可能满足划分给多个面，而二维 quickhull 就不会有这种情况）；

对于不满足条件的点，就直接抛弃；

然后我们再将 $F$ 加入队列，继续处理下一个面（注意有时会处理到一个已经删除的面）。

可以参考这个流程图（不太好翻译，直接用原文可能更清晰）：

![流程图](https://cdn.luogu.com.cn/upload/image_hosting/9rt4ro92.png)

&nbsp;

这里还有一个 quickhull 算法的 demo。

截图：

（可见面）

![quickhull1](https://cdn.luogu.com.cn/upload/image_hosting/uprfz9kc.png)

（地平线）

![quickhull2](https://cdn.luogu.com.cn/upload/image_hosting/i4sokimf.png)

（新建面）

![quickhull3](https://cdn.luogu.com.cn/upload/image_hosting/4wmwt2qx.png)

完整 demo [在这](https://pan.baidu.com/s/194jOL5rhHxeE3eDQxhD7vg 
)（baidu网盘，提取码：0eot）

### 初始化

为了找到一个由最终凸包的顶点组成的单纯形作为算法的开始，我们可以执行以下步骤：

1. 我们首先分别在 $x, y, z$ 三个坐标轴方向上找到最大最小点，共 $3$ 对 $6$ 个点（这 $6$ 个点必在凸包上）；
2. 在这 $6$ 个点当中，选取距离最大的两个点为初始点；
3. 在这 $6$ 个点当中，选取距离第二步所选 $2$ 个点连线最远的点作为第 $3$ 个点；
4. 遍历点集当中所有点，找到距离这 $3$ 个点所确定的平面最远的点作为第 $4$ 个点；

（[来自](https://zhuanlan.zhihu.com/p/33950536)）

这 $4$ 个点即是最初的单纯形。

然后我们再遍历所有点，给这个单纯形的四个面分配点即可。

### CODE

代码是上面许多东西的综合（非常**长**）

思维难度和前两种方法差不多，但调试非常麻烦。

我的代码**结构**非常难看...还请见谅（暂时没啥时间改）；仅供参考思路。

（另外实现中删除面和流程图没严格对应，因为在查询地平线已经标记了删除的面，维护邻接信息时也抛弃了删除的面）

```cpp
//输入退化为面或点未测试 
#include <cstdio>
#include <cmath>
#include <vector>
#include <list>
#include <queue>
using std::vector;
using std::list;
using std::queue;
using std::pair;
using std::max;
typedef pair<int, int> pad;

const int MAXN =2500;

/*------------------------------Computational geometry------------------------------*/

const double eps =1e-8;

struct vect{
	double x, y, z;
	int id;
	vect(){}
	vect(double xx, double yy, double zz):x(xx), y(yy), z(zz){}
	vect operator - (vect v){ return vect(x-v.x, y-v.y, z-v.z); }
	vect operator / (vect v){ return vect(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }
	double operator * (vect v){ return x*v.x+y*v.y+z*v.z; }
	double m(){ return sqrt(x*x+y*y+z*z); }
};

struct line{
	vect u, v;
	line(){}
	line(vect uu, vect vv):u(uu), v(vv){}
};

struct plane{
	vect vec[3];
	plane(){}
	plane(vect uu, vect vv, vect ww){ vec[0] =uu, vec[1] =vv, vec[2] =ww; }
	vect normal(){ return (vec[1]-vec[0])/(vec[2]-vec[0]);}
	vect u(){ return vec[0]; }
};

inline bool gtr(double a, double b){ return a-b > eps; }

inline bool eq(double a, double b){ return (a-b > -eps && a-b < eps); }

inline bool eq(vect u, vect v){ return (eq(u.x, v.x) && eq(u.y, v.y) && eq(u.z, v.z)); }

inline double Abs(double x){ return gtr(0, x) ? -x : x; }

/*带符号距离*/
inline double dist(vect v, plane p){ return (v-p.u())*p.normal()/p.normal().m(); }

/*不带符号*/
inline double dist(vect v, line f){ return ((f.v-f.u)/(v-f.u)).m()/(f.v-f.u).m(); }

inline double dist(vect u, vect v){ return (u-v).m(); }

inline bool isabove(vect v, plane p){ return gtr((v-p.u())*p.normal(), 0); }

/*------------------------------Convex Hulls------------------------------*/

int TIME =0;/*全局时间戳*/

struct facet{
	int n[3];/*neighbor，和点对应 (u->v, v->w, w->u)*/
	int id, vistime/*访问的时间戳*/;
	bool isdel;
	plane p;
	facet(){ vistime =isdel =0; }
	facet(plane pp):p(pp){ vistime =isdel =0; }
	facet(int idd, plane pp):id(idd), p(pp){ vistime =isdel =0; }
	void in(int n1, int n2, int n3){ n[0] =n1, n[1] =n2, n[2] =n3; }
};

/*地平线的边*/
struct edge{
	int netid, facetid;
};

/*存储所有面*/
vector<facet> FAC;

struct ConvexHulls3d{
	int index/*索引面*/;
	double surfacearea;
	ConvexHulls3d(int indd):index(indd){ surfacearea =0; }
	
	void dfsArea(int nf){
		if(FAC[nf].vistime == TIME) return;
		FAC[nf].vistime =TIME;
		surfacearea +=FAC[nf].p.normal().m()/2;
		for(int i =0; i < 3; ++i)
			dfsArea(FAC[nf].n[i]);
	}
	
	double getSurfaceArea(){
		if(gtr(surfacearea, 0)) return surfacearea;
		++TIME;
		dfsArea(index);
		return surfacearea;
	}
	
	int getHorizon(int f, vect &p, int vistime[], edge e1[], edge e2[], vector<int> &resfdel){
		if(!isabove(p, FAC[f].p)) return 0;
		if(FAC[f].vistime == TIME) return -1;
		FAC[f].vistime =TIME;
		FAC[f].isdel =1;/*顺便标记删除的面*/
		resfdel.push_back(FAC[f].id);
		int ret =-2;
		for(int i =0; i < 3; ++i){
			int res =getHorizon(FAC[f].n[i], p, vistime, e1, e2, resfdel);
			if(res == 0){
				int pt[2];
				pt[0] =FAC[f].p.vec[i].id, pt[1] =FAC[f].p.vec[(i+1)%3].id;
				for(int j =0; j < 2; ++j){
					if(vistime[pt[j]] != TIME){
						vistime[pt[j]] =TIME;
						e1[pt[j]].netid =pt[(j+1)%2];
						e1[pt[j]].facetid =FAC[f].n[i];
					}
					else{
						e2[pt[j]].netid =pt[(j+1)%2];
						e2[pt[j]].facetid =FAC[f].n[i];
					}
				}
				ret =pt[0];
			}
			else if(res != -1 && res != -2/*被围在中间的面*/) ret =res;
		}
		return ret;
	}
};

/*----------------------------------------------------------------*/

/*全局点*/
vector<vector<vect> > pts;

/*构造初始单纯形*/
inline ConvexHulls3d getStart(vect point[], int totp){
	vect pt[6], s[4];
	for(int i =0; i < 6; ++i) pt[i] =point[1];
	/*取坐标轴最大点*/
	for(int i =2; i <= totp; ++i){
		if(gtr(point[i].x, pt[0].x)) pt[0] =point[i];
		if(gtr(pt[1].x, point[i].x)) pt[1] =point[i];
		if(gtr(point[i].y, pt[2].y)) pt[2] =point[i];
		if(gtr(pt[3].y, point[i].y)) pt[3] =point[i];
		if(gtr(point[i].z, pt[4].z)) pt[4] =point[i];
		if(gtr(pt[5].z, point[i].z)) pt[5] =point[i];
	}
	s[0] =pt[0], s[1] =pt[0], s[2] =pt[0], s[3] =pt[0];
	/*取距离最大的两个点*/
	for(int i =0; i < 6; ++i) for(int j =i+1; j < 6; ++j)
		if(gtr(dist(pt[i], pt[j]), dist(s[0], s[1])))
			s[0] =pt[i], s[1] =pt[j];
	/*取距离上两个点所连直线距离最远的点*/
	for(int i =0; i < 6; ++i)
		if(gtr(dist(pt[i], line(s[0], s[1])), dist(s[2], line(s[0], s[1]))))
			s[2] =pt[i];
	/*取所有点集中距离该面最远的点*/
	for(int i =1; i <= totp; ++i)/*!!*/
		if(gtr(Abs(dist(point[i], plane(s[0], s[1], s[2]))), Abs(dist(s[3], plane(s[0], s[1], s[2])))))
			s[3] =point[i];
	/*确保接下来构造的面是朝单纯形外的*/
	if(gtr(0, dist(s[3], plane(s[0], s[1], s[2])))){
		vect tmp =s[1]; s[1] =s[2]; s[2] =tmp;
	}
	/*构造单纯形*/
	int f[4];
	for(int i =0; i < 4; ++i) FAC.push_back(facet()), f[i] =FAC.size()-1, FAC[f[i]].id =f[i];
	FAC[f[0]].p =plane(s[0], s[2], s[1]),/*底面*/
	FAC[f[1]].p =plane(s[0], s[1], s[3]),
	FAC[f[2]].p =plane(s[1], s[2], s[3]),
	FAC[f[3]].p =plane(s[2], s[0], s[3]);
	FAC[f[0]].in(f[3], f[2], f[1]);
	FAC[f[1]].in(f[0], f[2], f[3]);
	FAC[f[2]].in(f[0], f[3], f[1]);
	FAC[f[3]].in(f[0], f[1], f[2]);
	/*给四个面分配点集空间*/
	for(int i =0; i < 4; ++i)
		pts.push_back(vector<vect>());
	/*给四个面分配点*/
	for(int i =1; i <= totp; ++i){
		if(eq(point[i], s[0]) || eq(point[i], s[1]) || eq(point[i], s[2]) || eq(point[i], s[3])) continue;
		for(int j =0; j < 4; ++j)
			if(isabove(point[i], FAC[f[j]].p)){
				pts[f[j]].push_back(point[i]);
				break;
			}
	}
	/*返回初始单纯形，以一个面作为索引*/
	return ConvexHulls3d(f[0]);
}

edge e[2][MAXN] /*边界线的图信息*/;
int vistime[MAXN] /*每个点访问的时间戳*/;
queue<int> que;
vector<int> resfnew /*保存新构造的面*/, resfdel /*保存删除的面*/;
vector<vect> respt /*保存需要分配的点*/;
inline ConvexHulls3d quickHull3d(vect point[], int totp){
	ConvexHulls3d hull =getStart(point, totp);
	/*将初始单纯形的面加入队列*/
	que.push(hull.index);
	for(int i =0; i < 3; ++i)
		que.push(FAC[hull.index].n[i]);
	/*snew 保存最后返回的凸包的索引面*/
	int snew =0;
	while(que.size()){
		int nf =que.front(); que.pop();
		/*当前面已被删除，跳过*/
		if(FAC[nf].isdel) continue;
		/*当前面没有分配到顶点，跳过*/
		if(pts[nf].size() == 0){
			snew =nf;/*确保面最后存在*/
			continue;
		}
		/*取距离该面最远的点*/
		vect p =pts[nf][0];
		for(int i =1; i < (int)pts[nf].size(); ++i)
			if(gtr(dist(pts[nf][i], FAC[nf].p), dist(p, FAC[nf].p)))
				p =pts[nf][i];
		/*求地平线，可以知道得到的地平线至少有三个点*/
		++TIME;
		resfdel.clear();
		/*当前面一定会被删除，因此直接从当前面 dfs*/
		int s =hull.getHorizon(nf, p, vistime, e[0], e[1], resfdel);
		/*遍历地平线（绕一圈），构造新面*/
		/*在求地平线时我们无法得知某条边是逆时针还是顺时针的，因此需要这里判断*/
		resfnew.clear();
		++TIME;
		int from =0 /*上一个访问的点*/, lastf =0 /*上一个新建的面*/, fstf =0 /*第一个新建的面*/;
		while(vistime[s] != TIME){
			/*用时间戳记录当前点是否访问*/
			vistime[s] =TIME;
			int net/*下一个点*/;
			int f /*地平线上当前边所接的无法看见的面*/, fnew /*新面*/;
			/*确保遍历方向正确*/
			if(e[0][s].netid == from) net =e[1][s].netid, f =e[1][s].facetid;
			else net =e[0][s].netid, f =e[0][s].facetid;
			/*求出这两个点在邻接面上的逆顺时针信息*/
			int pt1 =-1, pt2 =-1;
			for(int i =0; i < 3; ++i){
				if(eq(point[s], FAC[f].p.vec[i])) pt1 =i;
				if(eq(point[net], FAC[f].p.vec[i])) pt2 =i;
			}
			/*确保 pt1->pt2 是按邻接面的点的逆时针排列*/
			if((pt1+1)%3 != pt2) pt1 ^=pt2 ^=pt1 ^=pt2;/*交换*/
			/*这样构造的面是朝凸包外的*/
			FAC.push_back(facet(plane(FAC[f].p.vec[pt2], FAC[f].p.vec[pt1], p)));
			fnew =FAC.size()-1, FAC[fnew].id =fnew;
			pts.push_back(vector<vect>());
			resfnew.push_back(fnew);
			/*维护邻接信息*/
			FAC[fnew].n[0] =f, FAC[f].n[pt1] =fnew;
			if(lastf){
				/*不能预先确定是顺时针遍历还是逆时针遍历*/
				/*维护新建的面之间的邻接信息*/
				if(eq(FAC[fnew].p.vec[1], FAC[lastf].p.vec[0])) FAC[fnew].n[1] =lastf, FAC[lastf].n[2] =fnew;
				else FAC[fnew].n[2] =lastf, FAC[lastf].n[1] =fnew;
			}
			else fstf =fnew;/*还未新建面*/
			lastf =fnew;
			from =s;
			s =net;
		}
		/*给新建的面头尾维护临界信息*/
		if(eq(FAC[fstf].p.vec[1], FAC[lastf].p.vec[0])) FAC[fstf].n[1] =lastf, FAC[lastf].n[2] =fstf;
		else FAC[fstf].n[2] =lastf, FAC[lastf].n[1] =fstf;
		/*取得所有需要分配的点*/
		respt.clear();
		for(int i =0; i < (int)resfdel.size(); ++i){
			for(int j =0; j < (int)pts[resfdel[i]].size(); ++j)
				respt.push_back(pts[resfdel[i]][j]);
			pts[resfdel[i]].clear();
		}
		/*分配点*/
		for(int i =0; i < (int)respt.size(); ++i){
			if(eq(respt[i], p)) continue;/*跳过用于新建面的点*/
			for(int j =0; j < (int)resfnew.size(); ++j)
				if(isabove(respt[i], FAC[resfnew[j]].p)){
					pts[resfnew[j]].push_back(respt[i]);
					break;/*确保点不会被重复分配*/
				}
		}
		/*将新的面加入队列*/
		for(int i =0; i < (int)resfnew.size(); ++i)
			que.push(resfnew[i]);
	}
	hull.index =snew;
	return hull;
}

inline void preConvexHulls(){
	/*0 位做保留*/
	pts.push_back(vector<vect>());
	FAC.push_back(facet());
}

/*------------------------------Main------------------------------*/

vect point[MAXN];

int main(){
	preConvexHulls();
	int n; scanf("%d", &n);
	for(int i =1; i <= n; ++i){
		double x, y, z; scanf("%lf%lf%lf", &x, &y, &z);
		point[i] =vect(x, y, z);
		point[i].id =i;
	}
	ConvexHulls3d hull =quickHull3d(point, n);
	printf("%.3lf", hull.getSurfaceArea());
}
```

### 复杂度及其它

时间复杂度据说是期望 $O(nlogn)$ 的，最坏可能被卡到 $O(nh)$。常数可能较大。

空间复杂度是 $O(n)$ 的。

按我上面的实现,；我自己测试了下，开 O2，$10^6$ 的随机点大概可以跑到 $5s$ 左右（仅供参考）。

## 4. 一些闲话

这篇文章是真的长...

三维计算几何到处都是坑，真的建议只当兴趣学习（话说这东西只有 ZJOI2018 考到过一次吧（**九 条 可 怜**），还只用增量法就行）。

如果对三维计算几何感兴趣的话还可以再去我博客[看看](https://www.luogu.com.cn/blog/105254/ji-suan-ji-he-san-wei-ru-men)。

---

## 作者：xzyxzy (赞：27)

~~作为最短代码水一篇题解~~

计算几何题目代码的简洁很重要，既方便阅读又便于调试

接下来蒯上博客里的[三维凸包笔记](https://www.cnblogs.com/xzyxzy/p/10225804.html)

还有[计算几何笔记&题单](https://www.cnblogs.com/xzyxzy/p/10033130.html)

---
# 三维凸包

##**向量运算**

### **加减运算**
同平面向量，对应坐标相加减

### **模长**
$|a|=\sqrt{x^2+y^2+z^2}$

### **点积**
两个向量的点积仍然表示 **a到b的投影×b的模长**
仍然满足$a·b=|a||b|cos<a,b>$
坐标下有$(x_1,y_1,z_1)·(x_2,y_2,z_2)=(x_1x_2,y_1y_2,z_1z_2)$，对应坐标相乘

### **叉积**
两个三维向量叉积仍然是一个三维向量（不同于平面向量，乘积是实数）
其**模长**仍然表示以这两个三维向量作为邻边的平行四边形面积
**方向**符合：对于$a*b$，伸出右手，食指指向$a$，中指指向$b$，大拇指所对的方向为叉积后的向量方向
![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E5%8F%89%E7%A7%AF.png)
如上图，$AC*AB=AD$

### **平面的法向量**
在平面上任选两个向量做叉积即可

### **点到平面的距离**
该点到平面上任意一点的向量 叉积 平面的法向量
然后除以法向量的模长
```cpp
double Dis(Node a) {Node w=Normal();return fabs((w&(a-A[v[0]]))/w.len());}
```
##**求凸包**
### **扰动**
首先对其微小扰动，避免出现四点共面的情况
### **平面的记录**
扰动之后各个平面一定是一个三角形，逆时针方向记录三个顶点表示一个面
### **增量构造**
借用网上[这篇博客](https://www.cnblogs.com/-sunshine/archive/2012/08/25/2656794.html)的图片方便理解
对于一个已知凸包，新增一个点P
将P视作一个点光源，向凸包做射线
可以知道，光线的可见面和不可见面一定是由若干条棱隔开的
![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E5%87%B8%E5%8C%85%E5%9B%BE1.png)
将光的可见面删去，并新增由其分割棱与P构成的平面
![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E5%87%B8%E5%8C%85%E5%9B%BE2.png)
重复此过程即可，复杂度$O(n^2)$

## **代码**
[洛谷模板](https://www.luogu.org/problemnew/show/P4724)：求三维凸包面积
先放上样例的两张靓照：
![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E6%A0%B7%E4%BE%8B1.png)
**强烈推荐画图软件Geogebra！**
![](http://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E6%A0%B7%E4%BE%8B2.png)
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
const int N=2010;
const double eps=1e-9;
int n,cnt,vis[N][N];
double ans;
double Rand() {return rand()/(double)RAND_MAX;}
double reps() {return (Rand()-0.5)*eps;}
struct Node
{
	double x,y,z;
	void shake() {x+=reps();y+=reps();z+=reps();}
	double len() {return sqrt(x*x+y*y+z*z);}
	Node operator - (Node A) {return (Node){x-A.x,y-A.y,z-A.z};}
	Node operator * (Node A) {return (Node){y*A.z-z*A.y,z*A.x-x*A.z,x*A.y-y*A.x};}
	double operator & (Node A) {return x*A.x+y*A.y+z*A.z;}
}A[N];
struct Face
{
	int v[3];
	Node Normal() {return (A[v[1]]-A[v[0]])*(A[v[2]]-A[v[0]]);}
	double area() {return Normal().len()/2.0;}
}f[N],C[N];
int see(Face a,Node b) {return ((b-A[a.v[0]])&a.Normal())>0;}
void Convex_3D()
{
	f[++cnt]=(Face){1,2,3};
	f[++cnt]=(Face){3,2,1};
	for(int i=4,cc=0;i<=n;i++)
	{
		for(int j=1,v;j<=cnt;j++)
		{
			if(!(v=see(f[j],A[i]))) C[++cc]=f[j];
			for(int k=0;k<3;k++) vis[f[j].v[k]][f[j].v[(k+1)%3]]=v;
		}
		for(int j=1;j<=cnt;j++)
			for(int k=0;k<3;k++)
			{
				int x=f[j].v[k],y=f[j].v[(k+1)%3];
				if(vis[x][y]&&!vis[y][x]) C[++cc]=(Face){x,y,i};
			}
		for(int j=1;j<=cc;j++) f[j]=C[j];
		cnt=cc;cc=0;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>A[i].x>>A[i].y>>A[i].z,A[i].shake();
	Convex_3D();
	for(int i=1;i<=cnt;i++) ans+=f[i].area();
	printf("%.3f\n",ans);
}
```

---

## 作者：George1123 (赞：13)

去焕然一新的博客看看 $\Longrightarrow$ [${\bf George1123's~blog}$](https://www.cnblogs.com/Wendigo/p/13288495.html)。

---
> [洛谷P4724 【模板】三维凸包](https://www.luogu.com.cn/problem/P4724)

> 给出空间中 $n$ 个点 $p_i$，求凸包表面积。

> 数据范围：$1\le n\le 2000$。
---
这篇题解因为是世界上最逊的人写的，所以也会有求**凸包体积**的讲解。

---
## 三位向量的运算

- **模长：** 即向量长度，$|\vec{a}|=\sqrt{x_a^2+y_a^2+z_a^2}$。

- **点积：** 标量 $\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|\cos<\vec{a},\vec{b}>=x_ax_b+y_ay_b+z_az_b$，为 $\vec{a}$ 的模长乘以 $\vec{b}$ 在 $\vec{a}$ 上的投影的模长。

- **叉积：** 向量 $\vec{a}*\vec{b}=(y_az_b-z_ay_b,z_ax_b-x_az_b,x_ay_b-y_ax_b)$，模长为平四面积。

![image.png](https://i.loli.net/2020/07/12/AmDroY3aqGSIkH1.png)

上图 $\vec{AC}*\vec{AB}=\vec{AD}$，$\vec{AD}$ 垂直 $\vec{AC}$ 与 $\vec{AB}$ 的平面，模长为平四面积。

---
## 会用到的计算与判定

- **判断点 $E$ 在平面 $ABC$ 上方：**

![image.png](https://i.loli.net/2020/07/12/LjoDmWaCQqHf7Rk.png)

作 $\vec{AD}=\vec{AC}*\vec{AB}$，用 $\vec{AE}\cdot \vec{AD}>0$ 来判断 $\angle DAE<\frac{\pi}{2}$。

- **求点 $E$ 到平面 $ABC$ 的距离：**

![image.png](https://i.loli.net/2020/07/12/cKRmrzaILYGpZXj.png)

距离 ${\rm dist}(E,\triangle ABC)=EG=AF=\frac{\vec{AD}\cdot \vec{AE}}{|\vec{AD}|}=\frac{\vec{AD}\cdot \vec{AE}}{|\vec{AC}*\vec{AB}|}$。

---
## 处理凸包

设凸包为 $Con$，用逆时针顺序三个点表示一个三角形面。

每加入一个新点 $p_{new}$ 的时候，把它当作光源照向之前的凸包，将未照到的面留下，加上 $p_{new}$ 和光影边缘形成的新面。

引用[巨佬](https://www.cnblogs.com/-sunshine/archive/2012/08/25/2656794.html)的图：

![image.png](https://i.loli.net/2020/07/12/S9cfUJTzWYqHdXa.png)

判断照不照得到用判定“点 $E$ 在平面 $ABC$ 上方”的方法。

判断光影边缘用 $vis$ 数组。$vis_{i,j}$ 表示 $(i,j,k)$（即 $(i,j)$ 逆时针方向上的面）这个面是否照光，如果 $[vis_{i,j}=1]\&\&[vis_{j,i}=0]$，说明 $(i,j)$ 是光影边缘，需加面 $(i,j,p_{new})$。

重复加点，得到 $m$ 个 $Con$ 上的面 $f_i=(A,C,B)$。

$$\sum_{i=1}^m S_i=\sum\frac{|\vec{AC}*\vec{AB}|}{2}$$

$$V_{Con}=\sum \frac{\frac{|\vec{AC}*\vec{AB}|}{2}\cdot {\rm dist}(D,f_i)}{3}$$

其中 $D$ 是一个定点，需要在 $Con$ 内或表面上，可以选 $p_1$，上面是三棱锥体积计算公式。

---
**时间复杂度 $\Theta(n^2)$，空间复杂度 $\Theta(n^2)$。**

每加入一个点，面最多增加 $2$ 个。

证明：设光影边缘上有 $n$ 个点，因为每个面是三角形，所以要去掉的面 $\ge n-2$（中间可能有点），增加的面数为 $n$，所以增加的点数 $\le 2$。

---
## 代码

- **求表面积**

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define be(a) a.begin()
#define en(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=2000;
const db eps=1e-9;
int n,m;
db ans;

//Convex
mt19937 orz(time(0));
db reps(){return (1.*(orz()%98)/97-.5)*eps;}
struct point{
	db x,y,z;
	void shake(){x+=reps(),y+=reps(),z+=reps();}
	db len(){return sqrt(x*x+y*y+z*z);}
	point operator-(point p){return (point){x-p.x,y-p.y,z-p.z};}
	point operator*(point p){return (point){y*p.z-p.y*z,z*p.x-p.z*x,x*p.y-p.x*y};}
	db operator^(point p){return x*p.x+y*p.y+z*p.z;} 
}a[N];
struct plane{
	int v[3];
	point flag(){return (a[v[1]]-a[v[0]])*(a[v[2]]-a[v[0]]);}
	db area(){return flag().len()/2;}
	int see(point p){return ((p-a[v[0]])^flag())>0;}
}f[N],g[N];
int vis[N][N]; 
void Convex(){
	#define ft f[j].v[t]
	#define bk f[j].v[(t+1)%3]
	f[m++]=(plane){0,1,2},f[m++]=(plane){2,1,0};
	for(int i=3;i<n;i++){
		int cnt=0,b;
		for(int j=0;j<m;j++){
			if(!(b=f[j].see(a[i]))) g[cnt++]=f[j];
			for(int t=0;t<3;t++) vis[ft][bk]=b;
		}
		for(int j=0;j<m;j++)
			for(int t=0;t<3;t++)
				if(vis[ft][bk]&&!vis[bk][ft]) g[cnt++]=(plane){ft,bk,i};
		m=cnt;
		for(int j=0;j<m;j++) f[j]=g[j];
	}
} 

//Main
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i].x>>a[i].y>>a[i].z,a[i].shake();
	Convex();
	for(int i=0;i<m;i++) ans+=f[i].area();
	cout.precision(3);
	cout<<fixed<<ans<<'\n';
	return 0;
} 
```

- **求体积**

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define be(a) a.begin()
#define en(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=2000;
const db eps=1e-9;
int n,m;
db ans;

//Convex
mt19937 orz(time(0));
db reps(){return (1.*(orz()%98)/97-.5)*eps;}
struct point{
	db x,y,z;
	void shake(){x+=reps(),y+=reps(),z+=reps();}
	db len(){return sqrt(x*x+y*y+z*z);}
	point operator-(point p){return (point){x-p.x,y-p.y,z-p.z};}
	point operator*(point p){return (point){y*p.z-p.y*z,z*p.x-p.z*x,x*p.y-p.x*y};}
	db operator^(point p){return x*p.x+y*p.y+z*p.z;} 
}a[N];
struct plane{
	int v[3];
	point flag(){return (a[v[1]]-a[v[0]])*(a[v[2]]-a[v[0]]);}
	db area(){return flag().len()/2;}
	db dist(point p){return fabs(((p-a[v[0]])^flag())/flag().len());}
	int see(point p){return ((p-a[v[0]])^flag())>0;}
}f[N],g[N];
int vis[N][N]; 
void Convex(){
	#define ft f[j].v[t]
	#define bk f[j].v[(t+1)%3]
	f[m++]=(plane){0,1,2},f[m++]=(plane){2,1,0};
	for(int i=3;i<n;i++){
		int cnt=0,b;
		for(int j=0;j<m;j++){
			if(!(b=f[j].see(a[i]))) g[cnt++]=f[j];
			for(int t=0;t<3;t++) vis[ft][bk]=b;
		}
		for(int j=0;j<m;j++)
			for(int t=0;t<3;t++)
				if(vis[ft][bk]&&!vis[bk][ft]) g[cnt++]=(plane){ft,bk,i};
		m=cnt;
		for(int j=0;j<m;j++) f[j]=g[j];
	}
} 

//Main
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i].x>>a[i].y>>a[i].z,a[i].shake();
	Convex();
	for(int i=0;i<m;i++) ans+=f[i].area()*f[i].dist(a[0])/3;
	cout.precision(2);
	cout<<fixed<<ans<<'\n';
	return 0;
} 
```
---
**祝大家学习愉快！**

---

## 作者：Others (赞：4)

一个拓展题（好像不会考），而且这题还没有两点共点，三点共线，四点共面的情况，如果加强了就扰动一下点，调一下精度就行了。

# 前置知识：

二维向量的亿些东西，空间几何的亿些基础，最好还做过[二维凸包模板](https://www.luogu.com.cn/problem/P2742)。

# Solution

**普及三维向量**

和二维差不多，用一个三元组 $(x,y,z)$ 表示（我们假设基底是 $x,y,z$ 轴上的单位向量）。

点积和二维的差不多：$\vec{a}\cdot\vec{b}=x_a\cdot x_b+y_a\cdot y_b+z_a\cdot z_b$

把两个三维向量投影到三个平面形成六个二维向量，对应叉乘在加起来就 OK 了：$\vec{a}\times\vec{b}=(y_a\cdot z_b-z_a\cdot y_b,z_a\cdot x_b-x_a\cdot z_b,x_a\cdot y_b-x_b\cdot y_a)$

然后就是**混合积**（一个高级的定义）：$\vec{a}\times\vec{b}\cdot\vec{c}$，几何意义就是三个向量构成的平行六面体的**有向体积**（又是一个高级的玩意儿），通俗的说，$\vec{a}\times\vec{b}$ 乘出来的向量和 $\vec{c}$ 在不在平面 $aob$ 的同一边。在就是正的，不在就是负的。将三个向量的起点堆在一起，就可以判断 $\vec{c}$ 的终点在平面 $aob$ 的哪一边（后面有大用）。

**正文**

整体思路很简单（应该是叫**增量法**），先找四个不共面的点（好像也没有）构成最开始的三维凸包，然后一个一个插入，插入时找到它能看见的面（字面意思，捏个纸团放你桌上就能理解），删掉那些面，显然这些面是连在一起的，把边缘和这个点连成一些面，更新凸包，最后就是枚举每个面叉积算体积就行了。

以上只是实现步骤，接下来是细节的实现：

保存凸包：存三个点就行了，但是没那么简单（看下面）。

找插入的点能看到的**一个**面：在存面的时候是三个点：$(A,B,C)$，我们构造一个顺序，使得 $\vec{AB}\times\vec{AC}$ 的方向对着凸包外面（在插入点和初始的时候拿捏一下顺序），这样对于插入的 $D$ 点 $\vec{AB}\times\vec{AC}\cdot\vec{AD}$ 如果是正的，说明看得见，反之则看不见。**一个性质**：在这个构造下，从**凸包外面**看 $A,B,C$ 是逆时针排列的，对于一条边，它对应有两个面，显然两个面中它的**方向是相反**的，所以每条边的每个方向对应着唯一的边，于是我们就可以维护一个 $g_{i,j}$ 来记录从点 $i$ 到点 $j$ 的路径对应的面（后面有用）。

找插入的点能看见的**所有**面：从上面找到的面 $dfs$ 一遍，它的三条边的方向反过来就是挨着的边，这样就会很方便 qwq。实现很简单。

接上一个问题，怎么找**边界**：在能看见的范围内判断边界很简单，直接看每条边对应的另一个边会不会被看见就可以了；也可以放肆地递归，递归到看不见的面时，递归过来的边就是边界了。

**Code：**

```cpp
#include <bits/stdc++.h>
#define eps 1e-6
using namespace std;
const int N=2005;
struct node {
	double a,b,c;
	node operator+(const node &p) const {return (node){a+p.a,b+p.b,c+p.c};}
	node operator-(const node &p) const {return (node){a-p.a,b-p.b,c-p.c};}
}a[N];
struct pm {
	int a,b,c;  
	bool flag;
}p[N<<3];int top=0;
double dc(node a,node b) {return a.a*b.a+a.b*b.b+a.c*b.c;}
double getlen(node a) {return sqrt(a.a*a.a+a.b*a.b+a.c*a.c);}
node cc(node a,node b) {return (node){a.b*b.c-a.c*b.b,a.c*b.a-a.a*b.c,a.a*b.b-a.b*b.a};}
double V(node x,pm y) {return dc(cc(a[y.b]-a[y.a],a[y.c]-a[y.a]),x-a[y.a]);}
int f[N][N],n;
void dfs(int x,int y);
void deal(int x,int y,int z) {
	if(p[f[y][z]].flag) {
		if(V(a[x],p[f[y][z]])>eps) dfs(x,f[y][z]);
		else p[f[z][y]=f[y][x]=f[x][z]=++top].a=z,p[top].b=y,p[top].c=x,p[top].flag=1;
	}
}
void dfs(int x,int y) {p[y].flag=0,deal(x,p[y].b,p[y].a),deal(x,p[y].c,p[y].b),deal(x,p[y].a,p[y].c);}
double get_convex() {
	for(int i=1;i<=4;i++) {
		p[++top].a=(i+1>4?i-3:i+1),p[top].b=(i+2>4?i-2:i+2),p[top].c=(i+3>4?i-1:i+3),p[top].flag=1;
		if(V(a[i],p[top])>eps) swap(p[top].b,p[top].c);
		f[p[top].a][p[top].b]=f[p[top].b][p[top].c]=f[p[top].c][p[top].a]=top; 
	}
	for(int i=5;i<=n;i++) for(int j=1;j<=top;j++) if(p[j].flag&&V(a[i],p[j])>eps) {dfs(i,j);break;}
	int tmp=top;top=0;double S=0;
	for(int i=1;i<=tmp;i++) if(p[i].flag) p[++top]=p[i];
	for(int i=1;i<=top;i++) S+=getlen(cc(a[p[i].a]-a[p[i].b],a[p[i].a]-a[p[i].c]))/2;
	return S;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf%lf",&a[i].a,&a[i].b,&a[i].c);
	printf("%.3lf\n",get_convex());
	return 0;
}
```

---

## 作者：BLX32M_10 (赞：1)

## 前置知识

三维向量运算：

加减和点乘同二维。

三维向量点乘的定义同二维，也是 $\overrightarrow a\cdot\overrightarrow b=|\overrightarrow a||\overrightarrow b|\cos \theta$，$\theta$ 为夹角。

因此我们可以使用点乘数值的正负来判断两个向量的夹角是锐角还是钝角，在本题中有关键作用。

```cpp
const vec operator - (vec a) const
{
    return vec(x - a.x, y - a.y, z - a.z);
}
const vec operator + (vec a) const
{
    return vec(x + a.x, y + a.y, z + a.z);
}
const double operator * (vec a) const
{
    return x * a.x + y * a.y + z * a.z;
}
```

三维叉乘的具体数值在本题并不重要，但重要的是它的方向。

叉乘的方向满足右手螺旋定则：

> 将右手四指指向 $\overrightarrow a$ 的方向，使得四指弯曲方向朝向 $\overrightarrow b$，此时大拇指方向为 $\overrightarrow a\times\overrightarrow b$ 的方向。

不难发现叉乘不满足交换律，但其满足反交换律 $\overrightarrow a\times\overrightarrow b=-\overrightarrow b\times\overrightarrow a$。

```cpp
const vec operator ^ (vec a) const
{
    return vec(y * a.z - z * a.y, z * a.x - x * a.z, x * a.y - y * a.x);
}
```

三维空间中两点间的距离很好理解。

```cpp
inline double dis(vec a) const
{
    return sqrt((x - a.x) * (x - a.x) + (y - a.y) * (y - a.y) + (z - a.z) * (z - a.z));
}
```
以上函数均为如下向量结构体的成员函数。

```cpp
struct vec
{
    double x, y, z;
    vec(double xx = 0, double yy = 0, double zz = 0)
    {
        x = xx, y = yy, z = zz;
    }
} ;
```

## 题解

由于三个点可以确定一个多面体的面，我们的凸包可以定义为若干的“三个点”。

而这样的话四点共面就让我们很难受，所以我们可以在开始之前进行随机扰动，使得没有四点共面的情况。

**注意**：此处有坑点，随机扰动幅度不能太小或者太大，经过测试 $\pm 10^{-8}$ 左右为宜。

三维凸包不同于二维凸包的地方就在于每新加入一个点，维护的都是当前状态的整个凸包而非凸壳（即凸包的一部分），而且点的加入顺序并不要求。

我们举一个例子（图片由本人使用 Geogebra 生成）。

我们要往凸包 ABCDH 里添加一个点 P。

![](https://cdn.luogu.com.cn/upload/image_hosting/z5gw7jpb.png)


我们考虑一下以点 P 的视角看这个凸包，发现我们能看到三个面。

![](https://cdn.luogu.com.cn/upload/image_hosting/d3rct905.png)

不难发现三个面一定不在新的凸包中，因为 PBC、PBD、PCD 这三个面能裹住这三个面。

![](https://cdn.luogu.com.cn/upload/image_hosting/qozx821y.png)

这几个面是怎么得到的呢？我们发现 P 与原来凸包中的边形成的最外层的面就是 **P 与可见面的每一条边缘棱构成的面**。

这里有一个结论：可见面的边缘一定由若干条棱构成。（除非有四点共面的情况）

于是我们向凸包的面集合删除 BCH、BDH、CDH，添加 PBC、PBD、PCD，点 P 就添加完成了。

![](https://cdn.luogu.com.cn/upload/image_hosting/prhacgvf.png)

综上，我们可以得到求凸包的过程：

- 随机扰动避免四点共面。

- 先将前四个点的凸包求出来。

- 对于新加的点：

  - 求出以该点的视角的可见面并删除那些面，记录边缘棱。
 
  - 向凸包添加点 P 与每一条边缘棱构成的面。
 
- 重复执行添加点。

- 使用海伦公式计算每一个面的面积并相加。

当然，还有一些细节问题。

Q: 如何确定一个面是否关于一个点可见？

A: 这就需要用到点乘和叉乘了。对于一个三角面，我们存储三个点的顺序一定是需要规定的。我在这里规定按照从上往下看逆时针的顺序。

那么根据右手螺旋定则，对于逆时针排序的 A、B、C 三个点，$\overrightarrow{AB}\times\overrightarrow{AC}$ 的方向就是图中橙色向量的方向，同时也是那个面的上方的方向，垂直于那个面。

我们称那个橙色向量为法向量。

![](https://cdn.luogu.com.cn/upload/image_hosting/irp4m0q7.png)

注意到一个面是对于一个点 P 可见的当且仅当该点在那个面的上方，也就是 $\overrightarrow P-\overrightarrow A$（A 换成 B 或者 C 都行） 与法向量夹角为锐角。

等等，夹角为锐角？那我们直接判断 $(\overrightarrow P-\overrightarrow A)\cdot\overrightarrow F > 0$ 就行了啊！（$\overrightarrow F$ 为法向量）

因此我们在面结构体中添加成员函数，表示判断一个点是否在面的上方：

```cpp
bool isabv(vec a)
{
    //(A0->A1)x(A0->A2) 可作为法向量
    vec fa = ((d[1] - d[0]) ^ (d[2] - d[0])), to = (a - d[0]);
    return fa * to > 0;
}
```

海伦公式算面积：

```cpp
inline double area() const
{
    double a = d[0].dis(d[1]), b = d[1].dis(d[2]), c = d[2].dis(d[0]);
    double p = (a + b + c) / 2;
    return sqrt(p * (p - a) * (p - b) * (p - c));
}
```

至于具体实现，我使用了 `multiset` 存储三角面，以便更好的删除（会多一只 $\log$ 但还是很快，不卡常在最优解第一页），按面积作为比较关键字（其实怎么比都行）。

每次存下来需要删除的面的迭代器，在这个点添加完后统一删除。

至于边缘棱，对于每一个要删掉的面，我们存下来它的所有边。如果一条边出现了两次，那么说明这条边不是边缘棱，删掉。最后剩下的就是边缘棱。

再来说新增的面。可以想象一下，一个面换了一个顶点，那么原来就存在的那条棱的顺序一定不变。

应该有更好的实现，但是我自己的脑子也就够到这了。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
struct vec
{
    double x, y, z;
    vec(double xx = 0, double yy = 0, double zz = 0)
    {
        x = xx, y = yy, z = zz;
    }
    const vec operator - (vec a) const
    {
        return vec(x - a.x, y - a.y, z - a.z);
    }
    const vec operator + (vec a) const
    {
        return vec(x + a.x, y + a.y, z + a.z);
    }
    const double operator * (vec a) const
    {
        return x * a.x + y * a.y + z * a.z;
    }
    const vec operator ^ (vec a) const
    {
        return vec(y * a.z - z * a.y, z * a.x - x * a.z, x * a.y - y * a.x);
    }
    inline double dis(vec a) const
    {
        return sqrt((x - a.x) * (x - a.x) + (y - a.y) * (y - a.y) + (z - a.z) * (z - a.z));
    }
} a[2005];
struct face
{
    int aa[3]; // 点的下标
    vec d[3]; // 逆时针排序
    face(int aaa, int b, int c) //按下标构造
    {
        d[0] = a[aaa], d[1] = a[b], d[2] = a[c];
        aa[0] = aaa, aa[1] = b, aa[2] = c;
    }
    inline double area() const
    {
        double a = d[0].dis(d[1]), b = d[1].dis(d[2]), c = d[2].dis(d[0]);
        double p = (a + b + c) / 2;
        return sqrt(p * (p - a) * (p - b) * (p - c));
    }
    bool isabv(vec a)
    {
        //(A0->A1)x(A0->A2) 可作为法向量
        vec fa = ((d[1] - d[0]) ^ (d[2] - d[0])), to = (a - d[0]);
        return fa * to > 0;
    }
    const bool operator < (const face x) const
    {
        return area() < x.area();
    }
} ;
set <pair <int, int> > del;
multiset <face> tb, tmp;
vector <multiset <face> :: iterator> dd;
mt19937_64 rng(random_device{}());
inline double rd()
{
    return (((rng() & 1) << 1) - 1) * rng() % 1000 / 100000000000.0;
}
inline void shake() // 扰动
{
    for (int i = 1; i <= n; i++)
        a[i].x += rd(), a[i].y += rd(), a[i].z += rd();
}
signed main()
{
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lf %lf %lf", &a[i].x, &a[i].y, &a[i].z);
    }
    shake();
    for (int i = 1; i <= 2; i++)
    {
        for (int j = i + 1; j <= 3; j++)
        {
            for (int k = j + 1; k <= 4; k++)
            {
                int x = 1 ^ 2 ^ 3 ^ 4 ^ i ^ j ^ k;
                face b = face(i, j, k);
                if (b.isabv(a[x]))
                    swap(b.d[0], b.d[1]), swap(b.aa[0], b.aa[1]);
                tb.insert(b);
            }
        }
    }
    for (int i = 5; i <= n; i++)
    {
        auto it = tb.begin();
        del.clear();
        dd.clear();
        while (it != tb.end())
        {
            face x = *it;
            if (x.isabv(a[i])) // 若是可见面
            {
                auto it1 = it;
                face x = *it1;
                it++;
                for (int i = 0; i < 3; i++)
                {
                    auto i1 = del.find(make_pair(x.aa[i], x.aa[(i + 1) % 3])),
                         i2 = del.find(make_pair(x.aa[(i + 1) % 3], x.aa[i]));
                    if (i1 != del.end())
                        del.erase(i1);
                    else if (i2 != del.end())
                        del.erase(i2);
                    else
                        del.insert(make_pair(x.aa[i], x.aa[(i + 1) % 3]));
                }
                dd.emplace_back(it1); //存下要删掉的迭代器
            }
            else
                it++;
        }
        for (auto p : del) // 添加新增面
        {
            face x(p.first, p.second, i);
            tb.insert(x);
        }
        for (auto p : dd) // 删掉原来的可见面
            tb.erase(p);
    }
    double ans = 0;
    for (face x : tb)
    {
        ans += x.area();
        // printf("%.3lf\n", x.area());
        // for (int i = 0; i < 3; i++)
        // {
        //     printf("%.3lf %.3lf %.3lf\n", x.d[i].x, x.d[i].y, x.d[i].z);
        // }
        // puts("");
    }
    printf("%.3lf", ans);
    return 0;
}
```

---


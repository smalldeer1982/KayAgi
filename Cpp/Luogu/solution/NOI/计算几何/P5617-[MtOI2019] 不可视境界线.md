# [MtOI2019] 不可视境界线

## 题目背景

「爆ぜろリアル！弾けろシナプス！パニッシュメント......ディス、ワールド！」  
「爆裂吧，现实！粉碎吧，精神！放逐这个世界！」  


## 题目描述

Rikka 坚信，她的父亲在「不可视境界线」中，等待着她的到来。在 Rikka 的梦里，「不可视境界线」出现了，那是 $n$ 个圆组成的图形。

具体地，有一个平面直角坐标系，坐标系的 $x$ 轴上有 $n$ 个点，第 $i$ 个点的坐标为 $(x_i,0)$。

Rikka 以每一个点作为圆心，作了 $n$ 个半径为 $r$ 的圆。她本想让你帮她计算这 $n$ 个圆的面积并，但是这个问题太简单了。

在一番思考后，Rikka 想让你计算出选出 $k$ 个圆后（即删除 $n-k$ 个圆），圆的面积并的最大值。

对于所有数据，有 $n,k\leq 10^5$，$r\leq 10^4$，$0\leq x_i\leq 10^9$，$x_i$ 为整数且不重复。保证输入的 $x_i$ 单调递增。

因为答案太大了，Rikka 考虑到你的电脑无法保持高精度，所以只要你的答案与标准答案的 **相对误差** 小于 $5\times 10^{-8}$，你的答案即被视为是正确的。

经过误差分析，本题保证使用原生 `cmath` 函数不会出错，请注意控制程序精度误差。


## 说明/提示

#### 样例解释 1

显然，可以选出 $5$ 个不相交的半径为 $2$ 的圆。

### 子任务

对于 $100\%$ 的数据，$n,k\leq 10^5$，$r\leq 10^4$，$0\leq x_i\leq 10^9$。

本题采用捆绑测试，共有 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$11$ 分）：$k=n$。

子任务 $2$（$13$ 分）：$n,k,r \leq 100$。

子任务 $3$（$6$ 分）：$n,k \leq 1000$，$r\leq 20$。

子任务 $4$（$15$ 分）：$n,k,r \leq 2000$，保证数据随机生成。

子任务 $5$（$23$ 分）：$r\leq 20$。

子任务 $6$（$12$ 分）：$k\leq 20$，$x_n \leq kr$。

子任务 $7$（$20$ 分）：无特殊限制。

### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T5

出题人：disangan233

验题人：suwAKow，_sys


## 样例 #1

### 输入

```
8 5 2
1 3 7 11 15 21 27 33```

### 输出

```
62.83185307```

## 样例 #2

### 输入

```
8 5 8
1 3 7 11 15 21 27 33```

### 输出

```
686.19551835```

# 题解

## 作者：disangan233 (赞：11)

### 算法一

考虑 $k=n$ 的情况，等价于求圆的面积并，可以用 Simpson 积分直接做。

也有另外一种方法。考虑题目圆心都在 $x$ 轴上且 $r$ 相等，直接计算每一个圆的新增面积即可。

具体做法为用 $\arcsin$ 求出扇形圆心角，减去三角形面积后即为相交面积的一半。

令 $d=2r-(x_i-x_j)$，$s(j,i)$ 为第 $j$ 个圆和第 $i$ 个圆的相交面积，所以可得：

$$
s(j,i)=2r^2\arcsin{\frac{\sqrt{rd-\frac{d^2}{4}}}{r}}-(r-\frac{d}{2})\sqrt{4dr-d^2}
$$

怎么样？这个式子是不是看着傻里傻气，又臭又长？考虑改进一下这个式子，采用向量叉积计算三角形面积即可。

$$
\theta=2\arccos {\frac{d}{2r}}, s(j,i)=(\theta-\sin \theta)r^2
$$

可通过子任务 $1$，时间复杂度 $O(n)$ 或 $O(n\log n)$，期望得分 $11$ 分。

### 算法二

由 $n$ 选 $k$ 考虑 $dp$ 求解，令 $f_{i,k}$ 为前 $i$ 个圆选择 $k$ 个的最大面积并。

令 $S_0=\pi r^2$，可得出转移方程：

$$
f_{i,k}=\max_{j<i} \{f_{j,k-1}+S_0-s(j,i)\}
$$

暴力转移，时间复杂度 $O\left(n^2k\right)$ ，可通过子任务 $2$，结合算法一期望得分 $24$ 分。

发现对于 $x_i-x_j\geq 2r$ 的情况 $s(j,i)=0$，故可维护一个最大值优化转移。

时间复杂度 $O(nkr)$，可通过子任务 $2,3$，结合算法一期望得分 $30$ 分。

### 算法三

考虑子任务 $4$，因为数据随机生成，所以对于 $x_i-x_j<2r$ 的情况可以各种乱搞。

结合算法一、二，期望得分 $45$ 分。

### 算法四

发现 $S_0-s(j,i)$ 和 $(S_0-s(j,i))'$ 在 $[0,2r]$ 内单调递减，考虑决策单调性。

令 $f(x)=S_0-s(j,i)$ ，可以得到其二阶导数，发现其在定义域内恒为正，故 $f(x)$ 下凸。

$$f''(x)=\frac{(4r^2\sin\theta)\sqrt{4r^2-x^2}+2xr(\cos \theta-1)}{(4r^2-x^2)\sqrt{4r^2-x^2}}$$

显然这个二阶导数计算量极大，本答案采用 symbolab 验证通过。

这里采用 GeoGebra 画图的方法帮助验证，令 $f(2r-x_i+x_j)=S_0-s(j,i)$，有：

![E.png](https://i.loli.net/2019/10/22/TRHoykrLdgjWeQ8.png)

考虑 $\forall i<j$，令 $p_i,p_j$ 为 $i,j$ 的最优转移点，发现有 $p_i\leq p_j$。

采用反证法，假设 $p_i>p_j$，那么有 ：

$$f_{p_j,k-1}-s(p_j,i)\leq f_{p_i,k-1}-s(p_i,i),f_{p_i,k-1}-s(p_i,j)\leq f_{p_j,k-1}-s(p_j,j)$$

这个两个不等式同时取等时可以直接交换 $p_i,p_j$ ，考虑至少有一个取 $<$ 的情况，有：

$$f_{p_j,k-1}-s(p_j,i)\leq f_{p_i,k-1}-s(p_i,i),f_{p_i,k-1}-s(p_i,j)< f_{p_j,k-1}-s(p_j,j)$$

移项后得到：

$$s(p_i,i)-s(p_j,i)\leq f_{p_i,k-1}-f_{p_j,k-1},s(p_i,j)-s(p_j,j)> f_{p_i,k-1}-f_{p_j,k-1}$$

所以我们得到：

$$s(p_j,j)-s(p_j,i)<s(p_i,j)-s(p_i,i)$$

因为 $s'$ 在 $[0,2r]$ 内单调递减，且 $p_i>p_j$，所以发现上式不成立，故单调性得证。

另一种方法：显然 $s$ 满足四边形不等式，故得证。

因为 $s(j,i)$ 可以 $O(1)$ 计算，可以采用二分栈或者分治。

因为此处是导数递减，求 $\max$，已有的区间会对栈顶产生影响，故采用单调队列维护。

时间复杂度 $O(nk\log n)$，可通过子任务 $2-4,6$，结合算法一期望得分 $57$ 分。

### 算法五

发现 $f_{i,k}$ 的 $k$ 是凸的，考虑 wqs 二分优化 dp。

- 为什么是凸的呢，因为增量单调的性质可以转化为四边形不等式，所以得证。

对于每一个圆加上一个 $-mid$ 的权值，若选取的个数 $>k$ 则 $l=mid$。

时间复杂度 $O(nr\log r)$，可通过子任务 $2-5$，结合算法一期望得分 $68$ 分。

### 算法六

考虑将算法四和算法五相结合，可以强行结合，期望得分 $80$ 分。

发现分治做法会破坏 $f$ 更新的有序性，且只能针对上一维转移。

但是二分栈的做法满足了相对顺序，也不受上一维的限制，且 wqs 二分的切线函数为一次函数，其导数为定值，不会破坏转移方程的决策单调性。

所以将二分栈和 wqs 二分结合起来即可。

时间复杂度 $O(n\log n\log r)$，可通过所有子任务，期望得分 $100$ 分。

### 代码实现

```cpp
#pragma GCC optimize(2,3,"Ofast","unroll-loops")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0,y=1;while(nc=gc(),(nc<48||nc>57)&&nc!=-1)if(nc==45)y=-1;Bi=1;
        x=nc-48;while(nc=gc(),47<nc&&nc<58)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*y;
    }
    in db gf() {re a=read(),b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi):a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=1e5+5,R=1e4+5;
const db pi=acos(-1),eps=1e-9;
int n,k,nr,a[N],g[N],p[N],q[N];
db f[N],ans,cur,dat[R<<1],s0,mid;
in db s(re i,re j) {return (a[j]-a[i]>=2*nr)?0:dat[a[j]-a[i]];}
in int find(re i,re j) 
{
    re l=j,r=n+1,m; 
    while(l<r) {m=(l+r)>>1;(f[i]-s(i,m)<=f[j]-s(j,m))?r=m:l=m+1;}
    return l;
}
void dp(db mid)
{
    for(re i=1,h=0,t=0;f[i]=g[i]=0,i<=n;i++) 
    {
        while(h<t&&p[h]<=i) h++;
        f[i]=f[q[h]]+s0-s(q[h],i)-mid;g[i]=g[q[h]]+1;
        while(h<t&&p[t-1]>=find(q[t],i)) t--;
        p[t]=find(q[t],i);q[++t]=i;
    }
}
int main()
{
    n=read();k=read();nr=read();s0=pi*nr*nr;
    for(re i=0;i<2*nr;i++) {db tmp=2*acos(i/(2.0*nr));dat[i]=(tmp-sin(tmp))*nr*nr;}
    a[0]=-1e9;for(re i=1;i<=n;i++) a[i]=read();
    db l=0,r=s0;for(re i=1;i<=37&&r-l>5e-6;i++) {mid=(l+r)/2.0;dp(mid);(g[n]>k)?l=mid:r=mid;}
    printf("%.8lf\n",f[n]+(l+r)*0.5*k);
    return ot(),0;
}
```


---

## 作者：command_block (赞：8)

~~这个题出的可以啊,只是有点套路~~

三个东西: 简单几何+WQS+二分队列(单调性优化)

关于单调性优化可以看看[DP的决策单调性优化总结](https://www.luogu.com.cn/blog/command-block/dp-di-jue-ce-dan-diao-xing-you-hua-zong-jie)

首先容易想到一个二维DP:

$f[i][j]$为前$i$个圆选取了$k$个,所得到的最大并面积。

转移 : $f[i][j]=\max\limits_{k=1}^{i-1}f[k][j-1]+c(k,i)$

$c(k,i)$表示第$i$个圆和第$k$个圆不交的面积,如图的红色面积:

![](https://cdn.luogu.com.cn/upload/image_hosting/svcd3gp1.png)

怎么计算呢?

![](https://cdn.luogu.com.cn/upload/image_hosting/8oy7fo6y.png)

整理成代码就是这样的:

注意两个圆相离的时候直接取整个圆就好了。

```cpp
inline double calc(int b,int a)
{
  if (x[b]-x[a]>=r+r)return f[a]+mid+Pi*r*r;
  b=x[b]-x[a];
  return f[a]+(Pi-acos(0.5*b/r)*2)*r*r+sqrt(r*r-b*b*0.25)*b;
}
```

因为这个`acos`比赛的时候被卡常了……

这里的$x[b]-x[a]$在$r$以内,观察数据可得,$r$并不大。

把所有的反三角函数都**预处理**出来就好了,这里绝对是瓶颈。

现在就有一个$O(n^3)$的解法了,接下来考虑使用套路。

看到恰好$m$个,果断使用WQS二分,把原问题转化为:

每选一个附加一个贡献$mid$,不考虑个数限制的$log$个DP子问题。

现在状态变成了$f[i]$表示前$i$个圆得出的最大贡献。

转移 : $f[i]=\max\limits_{k=1}^{i-1}f[k]+c(k,i)+mid$

现在是一个$O(n^2logn)$的解法。

然后,根据直觉或者打表可得,这个东西是具有决策单调性的。

换句话说,假如将$c(k,i)$视为$i$的函数,那么其导函数单减(越增长越慢)

需要最大化的话,那么前面的决策会被后面的**反超**,后面的不会被前面的**反超**。

dsg神真的把这个东西求出导来了,tql。

一个简单的理解:

![](https://cdn.luogu.com.cn/upload/image_hosting/j5zqcwz5.png)

那么套用一个二分队列就可以做到均摊$O(log)$转移了。

可以看看[P1912 [NOI2009]诗人小G](https://www.luogu.com.cn/problem/P1912)

然后注意一下精度,这题就做完了。

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define eps 1e-12
#define MaxN 100500
using namespace std;
const double Pi=acos(-1);
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,cnt,r,x[MaxN];
double mid,f[MaxN],tc[MaxN];
inline double calc(int b,int a)
{
  if (x[b]-x[a]>=r+r)return f[a]+mid+Pi*r*r;
  return f[a]+mid+tc[x[b]-x[a]];
}
int query(int i,int j)
{
  int l=max(i,j),_r=min(n,l+r),mid;
  while(l<_r){
  	mid=(l+_r)>>1;
  	if (calc(mid,i)>calc(mid,j)+eps)_r=mid;
  	else l=mid+1;
  }if (_r==n)return n+(calc(n,i)<calc(n,j)+eps);
  return _r;
}
int k[MaxN],stk[MaxN],p[MaxN];
double ans;
int check()
{
  int l=1,r=1;stk[1]=0;
  for (int i=1;i<=n;i++){
  	while(l<r&&k[l+1]<=i)l++;
  	f[i]=calc(i,stk[l]);p[i]=stk[l];
  	while(l<r&&k[r]>=query(i,stk[r]))r--;
    stk[++r]=i;k[r]=query(i,stk[r-1]);
  }int tp=n,tot=0;
  while(tp){tp=p[tp];tot++;}
  ans=f[n];
  return tot;
}
int main()
{
  n=read();cnt=read();r=read();
  for (int i=1;i<=r+r;i++)
    tc[i]=(Pi-acos(0.5*i/r)*2)*r*r+sqrt(r*r-i*i*0.25)*i;
  x[0]=-10000000;
  for (int i=1;i<=n;i++)x[i]=read();
  double l=-Pi*r*r,r=0,lim=min(-l/1e12,1e-6);
  while(r-l>lim){
    mid=(l+r)/2;
    int sav=check();
    if (sav>cnt)r=mid;
    if (sav<cnt)l=mid;
    if (sav==cnt)break;
  }printf("%.9lf",(double)(ans-mid*cnt));
  return 0;
}
```

---


# [THUPC 2024 初赛] 勇闯末日塔

## 题目背景

安宁顷刻今将逝，末日黑云伺隙来。宿命无情何所惧？越其止境冀花开。

为了执行毁灭世界的疯狂计划，一位占用了已死之人躯壳的神秘男子在这颗蓝色的星球上创造出了无数末日塔。这些末日塔会散发出浓密的以太射线，对末日塔附近的几乎所有生物进行精神控制，只有受到特殊加护的人才能免受以太射线控制。

一些受到加护的义勇队对这些末日塔进行了调查，其结果显示：这些末日塔组成了复杂的以太传输网络，持续不断地从大地中吸收以太，并将以太传输到位于帝国的中枢塔。

一队持有特殊加护的英雄决定闯入其中一些末日塔，以期彻底调查并尝试破坏这些末日塔。英雄们破坏掉进入的末日塔后，以太传输网络就会受到影响，因此大家希望选择一些末日塔，将其破坏后能使得网络的最大传输容量降到最低。

作为勇闯末日塔小队的先锋，你再次阅读了小队目前所掌握的所有信息。这次大胆的行动计划最终能否拯救这个世界，眼下恐怕谁都无法事先料定。但为了这颗星球的未来，我们只能放手一搏。

## 题目描述

星球的表面是一个中心位于 $(0, 0, 0)$，半径为 $R$ 的完美球面。星球表面上共有 $N$ 座末日塔，这些令人毛骨悚然的塔构成了以太传输网络的所有节点。

- 末日塔的高度远小于星球半径，因此我们认为第 $i (1 \le i \le N)$ 座塔是球面上的一个点 $\left(x_i, y_i, z_i\right)$。第 $i$ 座塔的以太传输效率为 $q_i$。
- 保证 $N$ 座末日塔的位置两两不同。在这 $N$ 座末日塔中，$s$ 号塔是以太吸收点，$t$ 号塔是位于帝国的中枢塔；这两座塔的以太浓度显著高于其它的末日塔，因此只能闯入这两座塔之外的末日塔。

$N$ 座末日塔之间共有 $M$ 条传输通道。第 $j (1 \le j \le M)$ 条传输通道连接 $u_j, v_j$ 两座末日塔，让它们可以互相传输以太。

- 传输通道是双向的，但单位时间内以太的流向必须是单向的。
- 为了节省不必要的成本，传输通道的两端不会连接相同的塔，也不会有两条传输通道连接相同的末日塔对。
- 为了降低传输距离，第 $i$ 条传输通道沿着 $u_j$ 和 $v_j$ 所在的大圆的劣弧铺设，故其**长度** $r_j$ 为两座末日塔在星球表面的球面距离。为了避免传输通道的互相干扰，**对于任意一条传输通道所对应的劣弧，其他传输通道所对应的劣弧只会在该劣弧的两端点上与该劣弧相交**。保证由同一条传输通道相连的两座末日塔的位置不是对跖点关系。
  - 如果不知道大圆、劣弧、球面距离和对跖点是什么，可以参考题面最后的提示部分。

受到传输效率和通道长度的影响，每条传输通道有各自传输以太的容量上限。

- 具体而言，每个单位时间内，第 $j$ 条传输通道的**容量上限**为 $\frac{Kq_{u_j} q_{v_j}}{r_j^2}$，其中 $K$ 是给定的常数，$q_{u_j}, q_{v_j}$ 为该传输通道两端的塔的传输效率，$r_j$ 为这条传输通道的长度。

整张以太传输网络需要将 $s$ 号塔吸收的以太沿着传输通道传输到 $t$ 号塔，并使得单位时间内的以太传输量最大。为此，传输网络会自动确定一个以太传输方案，在满足所有传输通道容量上限的前提下，最大化这一传输量。

- 换句话说，如果将末日塔看作图上的点，传输通道看作边，而传输通道的容量上限对应每条边的容量，那么以太的传输方案应该恰好为 $s$ 到 $t$ 的最大流。

虽然没有任何人能保证闯入末日塔之后就一定能将其破坏，但作为勇闯末日塔小队的先锋，你还是想在出发之前计算一下，如果成功破坏了所有将要闯入的末日塔，传输网络单位时间的最大传输量将会降至多少。

- 如果成功破坏了选择的末日塔，与其相连的所有传输通道的容量都将降至 $0$，其余传输通道容量不发生变化；此时传输网络会自动调节至一个在新的网络中传输量最大的新方案。
- 在最理想的情况下，小队将有机会调查并破坏 $L$ 座末日塔。因此，需要事先选择 $L$ 座末日塔（均不能是 $s$ 或 $t$），使得当这 $L$ 座末日塔都被成功破坏时，传输网络的新的传输方案的以太传输量尽可能地小。

## 说明/提示

### 样例 \#1 解释

以太传输网络如下图所示。图中蓝色球面即为星球表面；紫色点为各末日塔，其中 $P_i$ 对应输入的第 $i$ 座末日塔；黄色的线表示各传输通道。

![样例 1 示意图](https://cdn.luogu.com.cn/upload/image_hosting/4bynt5dl.png)

原来的传输网络单位时间最大传输量为 $188/\pi^2$。破坏第 $2$ 个末日塔或第 $5$ 个末日塔都能使新的传输网络单位时间的最大传输量降至 $80/\pi^2$，而破坏第 $3$ 个末日塔或第 $4$ 个末日塔只能使新的传输网络单位时间的最大传输量降至 $94/\pi^2$，所以应该选择第 $2$ 个或第 $5$ 个末日塔尝试破坏。

## 样例 #1

### 输入

```
6 11 1 1 6
1.0000 1.0000
1.0000 0.0000 10.0000
0.7500 0.2500 6.0000
0.5000 0.0000 1.0000
0.5000 0.5000 1.0000
0.2500 0.2500 6.0000
0.0000 0.0000 10.0000
1 2
1 3
1 4
2 3
2 4
3 4
3 5
3 6
4 5
4 6
5 6
```

### 输出

```
8.105694691387022
```

# 题解

## 作者：WaReTle (赞：14)

本题解做法部分参考自官方题解，并对一些细节做了补充。

## 前置知识

[P4001 [ICPC-Beijing 2006] 狼抓兔子](https://www.luogu.com.cn/problem/P4001)（平面图最小割转对偶图最短路）。

[P3249 [HNOI2016] 矿区](https://www.luogu.com.cn/problem/P3249)（平面图转对偶图）。

三维向量的基本运算。

## 简要思路

考虑最大流转最小割。一个割对应着一个球面上的将 $s$ 和 $t$ 分开的环。建出题目中的平面图的对偶图，找到一个符合上述要求的最小环。将图分层，在与同一个点相邻的面之间连跨层的 $0$ 权边可以解决删点的问题。

## 计算几何部分

### 基础操作

通过点乘可以算出两个向量夹角的余弦值。

通过叉乘可以求出两个向量确定的平面的法向量，并计算出两个向量夹角的正弦值的绝对值。

### 求两点的距离

设这两点到球心的向量的夹角为 $\theta$，则题目中的边的长度为 $R\theta$。

### 极角排序

平面图转对偶图需要对每个点出边进行极角排序。区别于平面上的极角排序，我们没有一个明确的向量可以作为基准（因为我们需要排序的向量不共面）。我使用了以下方法：

设当前正在排序出边的点为 $u$，它的相邻点为 $v$，球心到这些点的向量为 $\vec{u},\vec{v}$。我们求出 $\vec{u}\times\vec{v}$，这样就得到了若干平行于球在 $u$ 点处的切面并与对应的 $\vec{v}$ 垂直的向量.对这些向量进行排序即可。在这些向量中取一个向量作为基准向量，并计算其他向量与这个向量的夹角的正弦值与余弦值，最后通过 ```atan2``` 函数计算夹角的具体值。

细节：我们求正弦值时叉乘得到的是一个向量，难以判断正负性。观察到上面的向量平行于球在 $u$ 点处的切面，因此它们叉乘得到的向量平行于 $\vec{u}$。因此我们可以认为叉乘得到的向量中与 $\vec{u}$ 同向的向量为正，与 $\vec{u}$ 反向的向量为负。

### 平面图转对偶图

极角排序后直接套用平面上的做法即可。

## 图论部分

下文中“面”指由原图的边围成的区域。

### 建图

将所有的面和所有的点作为点加入新图。如果不考虑删点，新图的边即为相邻面之间跨过原图边的连边，边权为跨过的原图边的边权。为了解决删点的问题，我们将新图分 $L+1$ 层（编号 $0\sim L$），一层的面连向下一层相邻的点，每层的点连向本层相邻的面，边权均为 $0$。

### 最小环

我们要求求出的最小环将 $s$ 和 $t$ 分开。这可以通过任取一条 $s$ 到 $t$ 的路径设为关键路径，并钦定环必须跨过这条路径奇数次来解决。反映在图上，我们可以直接把新图上的点拆成奇偶点，所求环即为一个点在 $0$ 层的偶点到这个点在任意层的奇点的最短路。

考虑奇偶点之后，跨过关键路径上的边的情况是容易处理的。对于从点跨过关键路径的情况，可以让这个点和关键路径一侧的面之间的边连接奇偶性相同的点，这个点和关键路径另一侧的面之间的边连接奇偶性不同的点。详见代码。

## 常数优化部分

最终答案的环必然经过与关键路径相邻的面。因此只需要以这些面为起点跑最短路。为了减小常数，最好使用 bfs 而不是 dfs 确定关键路径。

正常写法使用 ```double``` 即可，不需要 ```long double```。

## 容易写错的地方

~~剧透警告~~

- 想清楚平面图转对偶图绕圈的过程。如果你是从一条边走到逆时针方向的下一条边，那么最后回到起点的时候走的应该是出发的边的上一条边。第一个样例输出答案的一半可能是这个原因。

- 如果你决定只以与关键路径相邻的面为起点跑最短路，记得跑仅和关键路径上的点相邻（不和边相邻）的面。否则如果你使用 bfs 确定关键路径可能会 wa 三个点（如果你用 dfs 确定关键路径，可能因为关键路径比较长误打误撞找到了正确答案）。

- 新图的点数大概有 $5\times 10^4\sim 6\times 10^4$ 级别，数组不要开小。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<int,double> pid;
const int N=1005,M=3005;
const double pi=acos(-1);
int n,m,L,s,t,tot,vid[N][10][2],fid[N][10][2],mpe[N][N],fcnt;
int face[N][N];
double dis[50005],ef[N];
bool imp[N];
vector<int>fne[M],fnv[N];
bool vis[N][N],flag;
double R,K,ang[N][N];
struct vec{double x,y,z;}pt[N],base;
double operator*(vec a,vec b){return a.x*b.x+a.y*b.y+a.z*b.z;}
vec operator%(vec a,vec b){return {a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x};}
double operator!(vec a){return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);}
struct edge{int u,v,ty;double w;}e[M];
double sgn(double x){return x>0?1:x<0?-1:0;}
double sin(vec a,vec b){return sgn(a%b*base)*!(a%b)/!a/!b;}
double cos(vec a,vec b){return a*b/!a/!b;}
vector<pii>og[N];
vector<pid>g[50005];
vector<int>pth;
bool inst[N];
double ans=1e9;
int q[N],hd,tl,pre[N];
void bfs(int u)
{
	q[hd=tl=1]=u;
	memset(pre,-1,sizeof(pre));
	pre[u]=0;
	while(hd<=tl)
	{
		u=q[hd++];
		for(auto i:og[u])
			if(!~pre[i.fi])
				pre[i.fi]=i.se,q[++tl]=i.fi;
	}
	u=t;
	while(pre[u])
		pth.push_back(pre[u]),u=e[pre[u]].u+e[pre[u]].v-u;
}
priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>>pq;
void ae(int u,int v,double w){g[u].emplace_back(v,w);}
void dij(int st)
{
	for(int i=1;i<=tot;++i)dis[i]=1e9;
	dis[st]=0,pq.emplace(dis[st],st);
	while(pq.size())
	{
		double d;int u;tie(d,u)=pq.top();pq.pop();
		if(dis[u]!=d)continue;
		if(dis[u]>ans)break;
		for(auto i:g[u])
		{
			int v;double w;tie(v,w)=i;
			if(dis[u]+w<dis[v])
				dis[v]=dis[u]+w,pq.emplace(dis[v],v);
		}
	}
	while(pq.size())pq.pop();
}
int main()
{
	scanf("%d%d%d%d%d%lf%lf",&n,&m,&L,&s,&t,&R,&K);
	for(int i=1;i<=n;++i)
	{
		double a,b;scanf("%lf%lf%lf",&a,&b,ef+i);
		a*=pi,b*=pi;
		pt[i]={R*sin(a)*cos(b),R*sin(a)*sin(b),R*cos(a)};
	}
	for(int i=1;i<=m;++i)
	{
		scanf("%d%d",&e[i].u,&e[i].v);
		double dist=R*acos(cos(pt[e[i].u],pt[e[i].v]));
		e[i].w=K*ef[e[i].u]*ef[e[i].v]/dist/dist;
		og[e[i].u].emplace_back(e[i].v,i);
		og[e[i].v].emplace_back(e[i].u,i);
		mpe[e[i].u][e[i].v]=mpe[e[i].v][e[i].u]=i;
	}
	for(int i=1;i<=n;++i)if(og[i].size())
	{
		static vec norm[N];
		for(auto j:og[i])
		{
			int v=j.fi;
			norm[v]=pt[i]%pt[v];
		}
		ang[i][og[i][0].fi]=0;
		base=pt[i];
		for(int j=1;j<og[i].size();++j)
			ang[i][og[i][j].fi]=
			atan2(sin(norm[og[i][0].fi],norm[og[i][j].fi]),
			cos(norm[og[i][0].fi],norm[og[i][j].fi]));
		sort(og[i].begin(),og[i].end(),
		[&](pii a,pii b){return ang[i][a.fi]<ang[i][b.fi];});
	}
	for(int i=1;i<=n;++i)if(og[i].size()>1)
		for(int j=0;j<og[i].size();++j)if(!vis[i][j]&&og[og[i][j].fi].size()>1)
		{
			vector<int>seqv,seqe;
			int u=i,pos=j;
			++fcnt;
			while(1)
			{
				seqv.push_back(u);
				seqe.push_back(og[u][pos].se);
				vis[u][pos]=1,face[u][pos]=fcnt;
				int v=og[u][pos].fi;
				if(v==i)break;
				int poss=lower_bound(og[v].begin(),og[v].end(),make_pair(u,0),
				[&](pii a,pii b){return ang[v][a.fi]<ang[v][b.fi];})-og[v].begin();
				u=v,pos=(poss+1)%og[v].size();
			}
			for(int x:seqv)fnv[x].push_back(fcnt);
			for(int x:seqe)fne[x].push_back(fcnt);
		}
	bfs(s);
	for(int i:pth)e[i].ty=1,imp[e[i].u]=imp[e[i].v]=1;
	for(int i=1;i<=fcnt;++i)
		for(int j=0;j<=L;++j)
			for(int k=0;k<2;++k)
				fid[i][j][k]=++tot;
	for(int i=1;i<=n;++i)
		for(int j=0;j<=L;++j)
			for(int k=0;k<2;++k)
				vid[i][j][k]=++tot;
	for(int i=1;i<=n;++i)if(i!=s&&i!=t)
	{
		int rev=0;
		for(int j=0;j<og[i].size();++j)if(face[i][j])
		{
			for(int p=0;p<=L;++p)
				for(int q=0;q<2;++q)
				{
					if(p<L)ae(fid[face[i][j]][p][q],vid[i][p+1][q^rev],0);
					ae(vid[i][p][q],fid[face[i][j]][p][q^rev],0);
				}
			rev^=e[og[i][j].se].ty;
		}
	}
	for(int i=1;i<=m;++i)if(fne[i].size())
		for(int j=0;j<=L;++j)
			for(int k=0;k<2;++k)
				ae(fid[fne[i][0]][j][k],fid[fne[i][1]][j][k^e[i].ty],e[i].w),
				ae(fid[fne[i][1]][j][k],fid[fne[i][0]][j][k^e[i].ty],e[i].w);
	set<int>st;
	for(int i=1;i<=n;++i)if(imp[i])
		for(int j=0;j<fnv[i].size();++j)
		{
			int fr=fid[fnv[i][j]][0][0];
			if(st.count(fr))continue;
			st.insert(fr);
			dij(fr);
			for(int k=0;k<=L;++k)
				ans=min(ans,dis[fid[fnv[i][j]][k][1]]);
		}
	printf("%.12lf\n",ans);
	return 0;
}
```

---


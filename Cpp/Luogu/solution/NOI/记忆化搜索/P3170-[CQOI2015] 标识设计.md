# [CQOI2015] 标识设计

## 题目描述

一家名字缩写为 LLL 的公司正在设计 logo，他们的初步方案是在一张方格上放置 $3$ 个 L 形的图案以及一些额外的装饰性图形，例如：![](https://cdn.luogu.com.cn/upload/pic/15558.png)  （灰色区域表示装饰性图形）。

$3$ 个 L 图案和装饰性图形均放置在方格之中，且必须占满方格。L 的横竖笔画长短均可，但长度必须大于 $0$（即不能退化为一条线段）。另外，为了使 L 图案醒目且容易辨别，设计师规定 $3$ 个 L 形图案之间不能有重叠或交叉的部分。当然，L 形图案也不能穿过装饰图形或与之重叠。

现在设计师已经确定了所有装饰性图形的位置，希望你计算一下放置不同的 L 形图案总共可以设计出多少个 logo。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n,m\leq 30$。

## 样例 #1

### 输入

```
4 4
....
#...
....
..#.```

### 输出

```
4```

# 题解

## 作者：Aleph1022 (赞：12)

不妨按行转移，那么记录上一行伸下来哪些竖笔划。这里的状态数是 $\binom m3 + \binom m2 + \binom m1 + 1$。  
即，设状态 $f(i,p_1,p_2,p_3,k)$ 表示第 $i$ 行伸出竖笔划的位置为 $p_1,p_2,p_3$，目前一共有 $k$ 个 L 的方案数。

考虑行间转移，假设这一行有 3 个 L，设它们的最左端分别为 $p_1 < p_2 < p_3$，那么转移有以下几种情况：

1. 凭空出现 3 个 L。
2. 上一行留下 1 个 L 并延续到下一行，在这一行出现 2 个 L。
3. 上一行留下 1 个 L 并截止到这一行，在这一行出现 2 个 L。
4. 上一行留下 2 个 L 并延续到下一行，在这一行出现 1 个 L。
5. 上一行留下 2 个 L 并有 1 个截止，有 1 个延续。在这一行出现 1 个 L。
6. 上一行留下 2 个 L 并截止到这一行，在这一行出现 1 个 L。
7. 上一行留下 3 个 L 并延续到下一行。
8. 上一行留下 3 个 L 并有 1 个截止，有 2 个延续。
9. 上一行留下 3 个 L 并有 2 个截止，有 1 个延续。
10. 上一行留下 3 个 L 并截止到这一行。

然后这一行有 2, 1, 0 个 L 的情况类似讨论即可。

为了计算某个 L 截止到这一行有哪些方案数，需要预处理每个位置右边的第一个障碍物的坐标。

时间复杂度 $O(nm^3)$ 带一个巨大常数（

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 30;
int n,m;
int nxt[N + 5][N + 5];
long long f[N + 5][N + 5][N + 5][N + 5][4];
int main()
{
	scanf("%d%d",&n,&m);
	char ch;
	for(int i = 1;i <= n;++i)
	{
		for(int j = 1;j <= m;++j)
		{
			scanf(" %c",&ch);
			if(ch == '#')
				nxt[i][j] = j;
			else
				nxt[i][j] = m + 1;
		}
		for(int j = m - 1;j;--j)
			nxt[i][j] = min(nxt[i][j],nxt[i][j + 1]);
	}
	f[0][0][0][0][0] = 1;
	for(int i = 1;i <= n;++i)
		for(int k = 0;k <= 3;++k)
		{
			f[i][0][0][0][k] += f[i - 1][0][0][0][k];
			for(int p1 = 1;p1 <= m;++p1)
			{
				if(nxt[i][p1] == p1)
					continue;
				if(k < 3)
					f[i][p1][0][0][k + 1] += f[i - 1][0][0][0][k];
				f[i][p1][0][0][k] += f[i - 1][p1][0][0][k];
				f[i][0][0][0][k] += f[i - 1][p1][0][0][k] * (nxt[i][p1] - p1 - 1);
				for(int p2 = p1 + 1;p2 <= m;++p2)
				{
					if(nxt[i][p2] == p2)
						continue;
					if(k < 2)
						f[i][p1][p2][0][k + 2] += f[i - 1][0][0][0][k];
					if(k < 3)
						f[i][p1][p2][0][k + 1] += f[i - 1][p1][0][0][k] + f[i - 1][p2][0][0][k],
						f[i][p2][0][0][k + 1] += f[i - 1][p1][0][0][k] * (min(nxt[i][p1],p2) - p1 - 1),
						f[i][p1][0][0][k + 1] += f[i - 1][p2][0][0][k] * (nxt[i][p2] - p2 - 1);
					f[i][p1][p2][0][k] += f[i - 1][p1][p2][0][k];
					f[i][p2][0][0][k] += f[i - 1][p1][p2][0][k] * (min(nxt[i][p1],p2) - p1 - 1);
					f[i][p1][0][0][k] += f[i - 1][p1][p2][0][k] * (nxt[i][p2] - p2 - 1);
					f[i][0][0][0][k] += f[i - 1][p1][p2][0][k] * (min(nxt[i][p1],p2) - p1 - 1) * (nxt[i][p2] - p2 - 1);
					for(int p3 = p2 + 1;p3 <= m;++p3)
					{
						if(nxt[i][p3] == p3)
							continue;
						if(k < 1)
							f[i][p1][p2][p3][k + 3] += f[i - 1][0][0][0][k];
						if(k < 2)
							f[i][p1][p2][p3][k + 2] += f[i - 1][p1][0][0][k] + f[i - 1][p2][0][0][k] + f[i - 1][p3][0][0][k],
							f[i][p2][p3][0][k + 2] += f[i - 1][p1][0][0][k] * (min(nxt[i][p1],p2) - p1 - 1),
							f[i][p1][p3][0][k + 2] += f[i - 1][p2][0][0][k] * (min(nxt[i][p2],p3) - p2 - 1),
							f[i][p1][p2][0][k + 2] += f[i - 1][p3][0][0][k] * (nxt[i][p3] - p3 - 1);
						if(k < 3)
							f[i][p1][p2][p3][k + 1] += f[i - 1][p1][p2][0][k] + f[i - 1][p2][p3][0][k] + f[i - 1][p1][p3][0][k],
							f[i][p2][p3][0][k + 1] += f[i - 1][p1][p2][0][k] * (min(nxt[i][p1],p2) - p1 - 1) + f[i - 1][p1][p3][0][k] * (min(nxt[i][p1],p2) - p1 - 1),
							f[i][p1][p2][0][k + 1] += f[i - 1][p1][p3][0][k] * (nxt[i][p3] - p3 - 1) + f[i - 1][p2][p3][0][k] * (nxt[i][p3] - p3 - 1),
							f[i][p1][p3][0][k + 1] += f[i - 1][p1][p2][0][k] * (min(nxt[i][p2],p3) - p2 - 1) + f[i - 1][p2][p3][0][k] * (min(nxt[i][p2],p3) - p2 - 1),
							f[i][p1][0][0][k + 1] += f[i - 1][p2][p3][0][k] * (min(nxt[i][p2],p3) - p2 - 1) * (nxt[i][p3] - p3 - 1),
							f[i][p2][0][0][k + 1] += f[i - 1][p1][p3][0][k] * (min(nxt[i][p1],p2) - p1 - 1) * (nxt[i][p3] - p3 - 1),
							f[i][p3][0][0][k + 1] += f[i - 1][p1][p2][0][k] * (min(nxt[i][p1],p2) - p1 - 1) * (min(nxt[i][p2],p3) - p2 - 1);
						f[i][p1][p2][p3][k] += f[i - 1][p1][p2][p3][k];
						f[i][p1][p2][0][k] += f[i - 1][p1][p2][p3][k] * (nxt[i][p3] - p3 - 1);
						f[i][p1][p3][0][k] += f[i - 1][p1][p2][p3][k] * (min(nxt[i][p2],p3) - p2 - 1);
						f[i][p2][p3][0][k] += f[i - 1][p1][p2][p3][k] * (min(nxt[i][p1],p2) - p1 - 1);
						f[i][p1][0][0][k] += f[i - 1][p1][p2][p3][k] * (min(nxt[i][p2],p3) - p2 - 1) * (nxt[i][p3] - p3 - 1);
						f[i][p2][0][0][k] += f[i - 1][p1][p2][p3][k] * (min(nxt[i][p1],p2) - p1 - 1) * (nxt[i][p3] - p3 - 1);
						f[i][p3][0][0][k] += f[i - 1][p1][p2][p3][k] * (min(nxt[i][p1],p2) - p1 - 1) * (min(nxt[i][p2],p3) - p2 - 1);
						f[i][0][0][0][k] += f[i - 1][p1][p2][p3][k] * (min(nxt[i][p1],p2) - p1 - 1) * (min(nxt[i][p2],p3) - p2 - 1) * (nxt[i][p3] - p3 - 1);
					}
				}
			}
		}
	printf("%lld\n",f[n][0][0][0][3]);
}
```

---

## 作者：maomao9173 (赞：9)

[更好的阅读体验戳我](https://www.cnblogs.com/maomao9173/p/10838953.html)

看到题目显然是插头$dp$，但是$n$和$m$的范围似乎不是很小。我们先不考虑复杂度设一下状态试试：

一共有三个连通分量，我们按照$1,2,3$的顺序来表示一下。轮廓线上$0$代表没有插头接入，$x$说明有第$x$个连通分量里的插头接入，需要在这里连下去。

我们设当前格子左边的一位轮廓线为$b_1$，上边的一位轮廓线为$b_2$。

- 如果$b_1 = b_2 = 0$：

	- 当前格子可以选择不放。
    
    - 当前格子也可以向下新建一个$L$。
    
- 如果$b1 = 0$且$b2 != 0$：

	- 可以连下去。
    
    - 也可以在这里拐弯向右。
    
- 如果$b1 != 0$且$b2 = 0$：

	- 可以向右连下去。
    
    - 也可以就此结束。

连通分量会出现中断的情况。比如你在很靠上的地方选两个$L$，又在最下面选了一个$L$，这时候可能会出现中间某些轮廓线上全都是$0$，遇到第三个分量的时候不好判断。这里我们在第$m+1$位上再放一个数，表示目前已经出现几个连通分量，就容易确定状态的可行性了。

状态和决策都很简单。下面我们看一下复杂度靠谱不靠谱。

一般逐格转移的插头$dp$复杂度是$O(NM*$状态总数上界$)$。一条轮廓线上最多有三个连通分量接入，所以用$0,1,2,3$四个数四进制表示。每个连通分量只可能接入一次（想一想，为什么），那么可以出现连通分量的选择就有$C_N^3$种。考虑三种连通分量各自的编号选择，状态总数就有$C_N^3 * 4^3=259840$种。运算次数大概是$2e8$左右，开着$O2$可以轻松卡过去。

（当然不开$O2$略微卡常也可以但是我懒=_=

$Code$：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int unsigned long long

const int N = 30 + 5;
const int base = 999983;
const int M = 1000000 + 5;

int n, m, can_use[N][N];

int las, cur, cnt[2], nxt[M];

int head[M]; int dp[2][M], Hash[2][M];

void update (int zt, int val) {
	int _zt = zt % base;
	for (int i = head[_zt]; i; i = nxt[i]) {
		if (Hash[cur][i] == zt) {
			dp[cur][i] += val; return;
		}
	}
	nxt[++cnt[cur]] = head[_zt];
	head[_zt] = cnt[cur];
	Hash[cur][cnt[cur]] = zt;
	dp[cur][cnt[cur]] = val;
}

int get_val (int zt) {
	int _zt = zt % base;
	for (int i = head[_zt]; i; i = nxt[i]) {
		if (Hash[cur][i] == zt) {
			return dp[cur][i];
		}
	}
	return 0;
}

int get_wei (int zt, int wei) {
	return (zt >> (wei * 2)) % 4;
}

int alt_wei (int zt, int wei, int val) {
	return zt - ((get_wei (zt, wei) - val) << (wei * 2));
}

void change_row () {
	for (int i = 1; i <= cnt[cur]; ++i) {
		int &zt = Hash[cur][i];
		for (int k = m; k >= 1; --k) {
			zt = alt_wei (zt, k, get_wei (zt, k - 1));
		}
		zt = alt_wei (zt, 0, 0);
	}
}

void print_zt (int zt) {
	for (int k = 0; k<= m + 1; ++k) {
		cout << get_wei (zt, k) << " ";
	}	
}

void print (int x, int y) {
	cout << "r = " << x << " c = " << y << endl;
	for (int i = 1; i <= cnt[cur]; ++i) {
		cout << "zt = ";
		print_zt (Hash[cur][i]);
		cout << "dp = " << dp[cur][i] << endl;
	} 
}

int solve () {
	update (0, 1);
//	print (0, 0);
	for (int i = 1; i <= n; ++i) {
		change_row ();
		for (int j = 1; j <= m; ++j) {
			las = cur, cur ^= 1, cnt[cur] = 0;
			memset (head, 0, sizeof (head));
			for (int k = 1; k <= cnt[las]; ++k) {
				int zt = Hash[las][k];
				int b1 = get_wei (zt, j - 1);
				int b2 = get_wei (zt, j - 0);
				int val = dp[las][k];
//				print_zt (zt); cout << endl;
//				cout << "b1 = " << b1 << " b2 = " << b2 << endl;
				if (!can_use[i][j]) {
					if (!b1 && !b2) {
						update (zt, val);
					}
				} else {
					if (b1 == 0 && b2 == 0) {
						int b = get_wei (zt, m + 1), _zt = zt;
						if (b < 3 && can_use[i + 1][j]) {
							_zt = alt_wei (_zt, m + 1, b + 1); // 新建连通分量 
							_zt = alt_wei (_zt, j - 1, b + 1); // b1 那一位改为新分量编号 
//							print_zt (zt); cout << " -> "; print_zt (_zt); cout << endl;
							update (_zt, val); 
						}
						update (zt, val); // 这个格子不占用 
					}
					if (b1 == 0 && b2 != 0) {
						if (can_use[i + 1][j]) {
							int _zt = zt; 
							_zt = alt_wei (_zt, j - 1, b2);
							_zt = alt_wei (_zt, j - 0, 0);
							// 0_b2 -> b2_0
//							print_zt (zt); cout << " -> "; print_zt (_zt); cout << endl;
							update (_zt, val); 
						} 
						if (can_use[i][j + 1]) {
							update (zt, val); 
							// 0_b2 -> 0_b2
						}
					}
					if (b1 != 0 && b2 == 0) {
						if (can_use[i][j + 1]) {
							int _zt = zt;
							_zt = alt_wei (_zt, j - 1, 0);
							_zt = alt_wei (_zt, j - 0, b1);
							// b1_0 -> 0_b1
							
//							print_zt (zt); cout << " -> "; print_zt (_zt); cout << endl;
							update (_zt, val);
						}
						int _zt = alt_wei (zt, j - 1, 0); 
						// b1_0 -> 0_0
//							print_zt (zt); cout << " -> "; print_zt (_zt); cout << endl;
						update (_zt, val);
					}
				}
			} 
//			print (i, j);
		} 
	}
	int fin = alt_wei (0, m + 1, 3);
	return get_val (fin);
} 

signed main () {
//	freopen ("data.in", "r", stdin);
//	freopen ("data.out", "w", stdout);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			int ch = getchar ();
			if (ch != '.' && ch != '#') {
				ch = getchar ();
			} 
			if (ch == '.') can_use[i][j] = true;
//			cout << can_use[i][j] << " ";
		}
//		cout << endl;
	}
	cout << solve () << endl;
}
```

---

## 作者：Spouter_27 (赞：5)

模拟赛 T1，但是被一堆人场切了，非常恐怖。据说可以 $O(n^6)$ 过掉！

我们考虑先枚举三个 L 的横线的纵坐标，可以 $O(n^3)$ 枚举。注意这里 L 是被标号的，所以最后答案要除以 $6$。

然后从左往右 dp，$dp_{i,x,y,z}$ 表示转移到第 $i$ 列，三个 L 形的状态分别是 $x,y,z$ 的方案数。

下面是状态的定义：

-  $0$ 状态：还未开始填。

-  $1$ 状态：正在填。

-  $2$ 状态：这一列后已经填完。

则初始状态为 $dp_{0,0,0,0}=1$，终止状态为 $dp_{m,2,2,2}$。

dp 之前，先将枚举的横线按照纵坐标排序。这里还可以加个记忆化剪枝。

中间转移时，一个状态只能转移到他自己和下一个状态（这样就保证了横线的长度至少为 $2$ ）。从上到下考虑横线，枚举他们的状态和转移后的状态。

当一个 L 属于 $1$ 状态或者要转移到 $1$ 状态时，它下面要填的位置必须不为 `#`。

一个 L 从 $0$ 状态转移到 $1$ 状态时，需要计算该 L 形的竖线的方案数，这里可以直接预处理出来。由于会有 L 形交叉的情况发生，记录一下上一个正在填的 L 的横线纵坐标，填竖线的时候不能越过这个限制。

最后将所有答案的加起来，除以 $6$，就做完了。时间复杂度 $O(mn^3)$。

```cpp
#include<bits/stdc++.h>
namespace Spouter_27{
using namespace std;
#define deb(x) cerr<<__LINE__<<": "<<#x<<" "<<x<<endl
#define pii pair<ll,ll>
#define mp make_pair
#define fi first
#define se second
typedef long long ll;
const ll N=37;
ll lowbit(ll x){return x&-x;}
ll popcount(ll x){return __builtin_popcount(x);}
void sort_(ll &x,ll &y,ll &z){
	ll t[3]={x,y,z};
	sort(t,t+3);
	x=t[0],y=t[1],z=t[2];
}
ll n,m,a[N][N];
ll pre[N][N],vis[N][N][N];
ll dp[N][3][3][3];
ll ans,res;
char str[N];
ll get(ll x,ll y,ll z){
	sort_(x,y,z);//排序
	if(vis[x][y][z])	return vis[x][y][z];//记忆化
	memset(dp,0,sizeof(dp));
	dp[0][0][0][0]=1;
	for(int k=0;k<m;k++){
		for(int dx=0;dx<=2;dx++)
		for(int dy=0;dy<=2;dy++)
		for(int dz=0;dz<=2;dz++){
			if(!dp[k][dx][dy][dz])	continue;
			for(int xx=dx;xx<=min(2,dx+1);xx++)
			for(int yy=dy;yy<=min(2,dy+1);yy++)
			for(int zz=dz;zz<=min(2,dz+1);zz++){
				ll lst=0,cur=1;//lst表示竖线的限制，cur表示当前竖线方案数的乘积
				if(dx==1||xx==1){
					if(a[x][k+1]==1||x==lst)	continue;
					if(dx==0)	cur*=min(pre[x][k+1],x-lst)-1;
					lst=x;
				}
				if(dy==1||yy==1){
					if(a[y][k+1]==1||y==lst)	continue;
					if(dy==0)	cur*=min(pre[y][k+1],y-lst)-1;
					lst=y;
				}
				if(dz==1||zz==1){
					if(a[z][k+1]==1||z==lst)	continue;
					if(dz==0)	cur*=min(pre[z][k+1],z-lst)-1;
					lst=z;
				}				
				dp[k+1][xx][yy][zz]+=dp[k][dx][dy][dz]*cur;
			}
		}
	}
	return vis[x][y][z]=dp[m][2][2][2];
}
signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",str+1);
		for(int j=1;j<=m;j++){
			if(str[j]=='#')	a[i][j]=1;
			else a[i][j]=0;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==1)	pre[i][j]=0;
			else pre[i][j]=pre[i-1][j]+1;
		}
	}
	for(int x=1;x<=n;x++){
		for(int y=1;y<=n;y++){
			for(int z=1;z<=n;z++){
				ans+=get(x,y,z);
			}
		}
	} 
	printf("%lld\n",ans/6);
	return 0;
}
/*
*/
}signed main(){return Spouter_27::main();}

```

%%%He_Ren AK IOI!

---

## 作者：APJifengc (赞：3)

首先看到题很容易能想到插头 DP。但是数据范围很大，$n,m \le 30$，直接压会很爆炸。不过发现合法状态很少，因为轮廓线上最多同时只能有三个插头，所以大部分状态都是不合法的。

一种方法是直接哈希表记录合法状态，可以参考其他题解，另一种方法是直接记录这三个插头的位置，而不是记录每个位置有没有插头。

发现 $30$ 这个数正好能压到 $32$ 中，所以我们可以这样压缩状态：前两位代表已经放了几个插头（$3=2^2-1$），后面有三个五位记录三个插头的位置（$31=2^5-1$），这样一个状态最大只有 $2^{17}-1=131071$。

转移就比较轻松了，分五种情况：

1. 这一格是障碍：直接转移过去。
2. 没有向右和向下的插头：这一格可以不放，可以为一个 L 的起点。
3. 只有向下的插头：那么说明这肯定是 L 上面转移下来的，可以继续向下延伸，或者向右拐。
4. 只有向右的插头：那么说明一定是 L 拐弯之后过来的，可以继续向右延伸，或者在这里结束。
5. 同时有向右和向下的插头：此种情况不合法，直接跳过。

这样实现略麻烦，我使用了一个结构体来封装状态，自认为还是挺清新的）这样就可以比较方便的转移，具体看代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
struct DATA {
    int cnt, a, b, c;
    DATA(int q) { // 将 int 转换为状态
        cnt = q & 3;
        a = q >> 2 & 31;
        b = q >> 7 & 31;
        c = q >> 12 & 31;
    }
    DATA(int cnt, int a, int b, int c) : cnt(cnt), a(a), b(b), c(c) {}
    operator int() { // 将状态转换为 int
        if (a > b) swap(a, b);
        if (b > c) swap(b, c);
        if (a > b) swap(a, b);
        return cnt | (a << 2) | (b << 7) | (c << 12);
    }
    DATA replace(int a, int b, int d = 0) { // 替换插头的位置，d 代表 cnt 是否加 1
        DATA c = *this;
        if (c.a == a) c.a = b;
        else if (c.b == a) c.b = b;
        else if (c.c == a) c.c = b;
        c.cnt += d;
        return c;
    }
};
int n, m;
const int T = 10007;
struct Hash { // 哈希表
    int fst[T], nxt[T], tot, v[T], k[T];
    void insert(int d, int vv) {
        int h = d % T;
        v[++tot] = vv;
        k[tot] = d;
        nxt[tot] = fst[h];
        fst[h] = tot;
    }
    int find(int d) {
        int h = d % T;
        int p = fst[h];
        while (p && k[p] != d) p = nxt[p];
        return v[p];
    }
    void clear() {
        tot = 0;
        memset(fst, 0, sizeof fst);
    }
}mp[2];
long long f[2][MAXN], cnt;
void S(int d, int a, long long b) { // 更新答案函数
    int q = mp[d].find(a);
    if (q) f[d][q] += b;
    else mp[d].insert(a, ++cnt), f[d][cnt] = b;
}
char ch[44][44];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", ch[i] + 1);
    f[0][1] = 1, mp[0].insert(DATA{0, 0, 0, 0}, 1);
    for (int i = 1, t = 0; i <= n; i++) {
        for (int j = 1; j <= mp[t].tot; j++) { // 新一行状态要向右平移
            DATA ori = mp[t].k[j]; 
            if (ori.a) ori.a++; 
            if (ori.b) ori.b++; 
            if (ori.c) ori.c++;
            mp[t].k[j] = ori;
        }
        for (int j = 1; j <= m; j++) {
            t ^= 1, cnt = 0;
            mp[t].clear();
            for (int k = 1; k <= mp[t ^ 1].tot; k++) {
                DATA s = mp[t ^ 1].k[k];
                long long ans = f[t ^ 1][mp[t ^ 1].v[k]];
                int r = s.a == j || s.b == j || s.c == j, 
                    d = s.a == j + 1 || s.b == j + 1 || s.c == j + 1;
                if (ch[i][j] == '#') { // case 1
                    S(t, s, ans);
                } else if (!r && !d) { // case 2
                    S(t, s, ans);
                    if (ch[i + 1][j] == '.' && s.cnt < 3)
                        S(t, s.replace(0, j, 1), ans);
                } else if (!r && d) { // case 3
                    if (ch[i + 1][j] == '.') S(t, s.replace(j + 1, j), ans);
                    if (ch[i][j + 1] == '.') S(t, s, ans);
                } else if (r && !d) { // case 4
                    if (ch[i][j + 1] == '.') S(t, s.replace(j, j + 1), ans);
                    S(t, s.replace(j, 0), ans);
                } else if (r && d) { // case 5
                    "go to hell";
                }
            }
        }
        if (i == n) {
            printf("%lld\n", f[t][mp[t].find(DATA{3, 0, 0, 0})]);
        }
    }
    return 0;
}
```

---

## 作者：劉子颺 (赞：3)

楼下若不是Claris本人那可真是会求同存异啊

考虑雷同于地板（SCOI2011）的写法

定义两种插头 一个是转了向的一个是没转向的

然后压一下进来多少个插头 拐了多少个弯

注意全四进制开不下，考虑变进制状压

然后注意答案不取模

不要用Hash_Table的模数来去模了

```cpp
void Solve(){
	cnt[cur]=1;
	Val[cur][1]=1;
	Que[cur][1]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=cnt[cur];++j){
			Que[cur][j]=(Que[cur][j]%16)+48*(Que[cur][j]/16);
		}
		for(int j=1;j<=m;++j){		
			cur^=1;
			cnt[cur]=0;
			memset(first,0,sizeof(first));
			for(int k=1;k<=cnt[cur^1];++k){
				int now=Que[cur^1][k];
				int sum=Val[cur^1][k];
				int p=now%4;
				int In=(now/4)%4;
				int b1=(now/pow3[j-1])%3;
				int b2=(now/pow3[j])%3;
				if(!G[i][j]){
					if(!b1&&!b2){
						Insert(now,sum);
					}
				}
				else{
					if(!b1&&!b2){
						if(p<3&&G[i+1][j])Insert(now+1+pow3[j-1],sum);
						Insert(now,sum);
					}
					if(!b1&&b2==1){
						//Cas1
						if(G[i][j+1])Insert(now+4-pow3[j]*b2+pow3[j]*2,sum);	
						//Cas2
						if(G[i+1][j])Insert(now-pow3[j]*b2+pow3[j-1]*1,sum);
					}
					if(b1==2&&!b2){
						if(In==3)ans=ans+sum;
						if(G[i][j+1])Insert(now-pow3[j-1]*b1+pow3[j]*2,sum);
						Insert(now-pow3[j-1]*b1,sum);
					}
				}
			}			
		}
	}
	cout<<ans;
}
```


---

## 作者：EXODUS (赞：2)

# Part 1：前言
看到题解区全是插头 dp，这里来补一个模拟赛里冲出来的容斥的做法，复杂度 $O(n^6)$。但是被卡常，当前在洛谷上被撅成了 80 分，如果有老哥能帮我卡过了可以私信我，感激不尽/kt。

由于本人略懒，因此本篇题解可能偏向陈述结论，忽略了很多关于一步一步推出的冗长思路，往读者见谅。说人话就是，看这篇也就图一乐，真图一乐还得看这篇。

**Warning：** 如果你真的想彻底理解这个做法，请务必画图，并保持耐心，我场上激烈的写了四个半小时。
# Part 2：正文
首先看到要求三个 L 的数量，果断想到种花，枚举三个 L 的拐点（考虑到枚举上右两个点不好维护，因为贡献不固定，同时也不好维护不交这一限制）。下文中我们钦定三个 $l$ 的拐点的横纵坐标分别为 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$。不妨钦定 $y_1<y_2<y_3$，在这里我们暂不考虑相等关系，这个 corner 放到最后讨论，也就是说，在下文中，我们默认三个拐点横纵坐标互不相同。

注意到两个点相互之间有影响当且仅当其在另一个拐点的左上或右下矩形中，因此不难想到枚举每个节点，，并根据纵坐标顺序分类讨论，下文中，我们按照从简单到复杂的角度分开考虑。

同时，因为式子太长，并不写出具体式子，可以到代码中观看具体式子。代码中的 $sumx(i,j)$ 和 $sumy(i,j)$ 分别表示从 $(i,j)$ 号点向上或向右不经过障碍的前提下的最长长度。

- $x_1>x_2>x_3$

![](https://cdn.luogu.com.cn/upload/image_hosting/wj7jved0.png)

此时三个 L 的关系共有上图中的一种情况，由于其互不影响，式子是易得的，具体可见代码的 `_123` 部分。

- $x_1>x_3>x_2$

![](https://cdn.luogu.com.cn/upload/image_hosting/jcxe5ec6.png)

此时三个 L 的关系有两种情况，见上图。考虑到直接统计比较冗长，我们使用容斥，不合法的方案即为两个 L 有交，方案数即为代码中的 `_132` 部分。

- $x_2>x_1>x_3$

![](https://cdn.luogu.com.cn/upload/image_hosting/0bhnsljx.png)

此时三个 L 的关系有两种情况，见上图。同样使用容斥，答案即代码中的 `_213` 部分。

- $x_2>x_3>x_1$

![](https://cdn.luogu.com.cn/upload/image_hosting/6il9eq5p.png)

欢迎来到地狱模式 /mgx。

你可能会想对上面三种情况分开容斥一遍，但这实际上是不对的，因为下图中的情况会被算两遍甚至多遍。

![](https://cdn.luogu.com.cn/upload/image_hosting/zhszi5lp.png)

怎么办？强行钦定第二种情况中第一个的横向长度必须覆盖过第二个的横坐标，第三种情况中第一个的横向长度必须长于第三个的横坐标。可以发现这样让每种情况统计了一次，因此对每种情况按照第二个讨论的讨论方式做一遍并加上强行钦定的限制即可。具体式子可以见 `_231` 部分。

- $x_3>x_1>x_2$

![](https://cdn.luogu.com.cn/upload/image_hosting/r8rpkeas.png)

同样跟上一个做法类似，按照如下方式钦定。

优先统计第二种情况，然后对于第三种情况，强行钦定三必须盖过一，对于第一种情况，强行钦定三必须盖过二。具体式子见 `_312` 部分。由此和上面一样，可以证明每种情况都被统计了一次。

- $x_3>x_2>x_1$

小时候写这个把家里淹了/cf。

![](https://cdn.luogu.com.cn/upload/image_hosting/0kly74jo.png)

依然把所有情况列出来。这个的难点在于什么？没有明确的容斥钦定顺序，他们的容斥钦定关系构成了一个图。

考虑我们什么时候需要容斥，即处理两个同时缩进去的情况，这个会在多种情况中分别统计。因此我们在统计一个图的时候，将其两边的都缩进去，在前面已统计的图中寻找是否有跟它形成一样的图的图，如果有，我们强行钦定，否则我们把两边都缩进去的图丢在这个图上统计。下面依然直接给出容斥方案。

首先统计上图中第一行第三列的情况，然后统计第一行第一列的情况，此时钦定第三个盖过第二个。然后统计第二行第二列的情况，此时钦定第一个盖过第二个。下面统计第二行第一列的情况，此时钦定第一个盖过第二个，第三个盖过第二个，最后统计第一行第二列的情况，此时钦定第一个盖过第二个，第三个盖过第一个。~~不~~容易证明，这样统计了每种情况一次且仅一次。具体式子可以见 `_321` 部分。

结束了？还没有。现在我们去考虑坐标相同的问题。

对于 $y$ 相同，我们手算一下在上面的容斥中可以被正确统计。现在的问题在于 $x$ 相同。考虑此时对于这两个 L 而言，其需要被统计覆盖关系，因此我们将比较转为 $(x_i,-i)$ 的二元组比较大小。换言之，我们让相等的数构成逆序对，这样就能在上述的统计方法中体现覆盖关系。因此我们上述的六个条件可以写为如下六个条件。

- $x_3<x_2<x_1$
- $x_2\le x_3<x_1$
- $x_3<x_1\le x_2$
- $x_2<x_1\le x_3$
- $x_1\le x_3<x_2$
- $x_1\le x_2\le x_3$

做完了。


# Part 3：代码
太长了，丢到[剪贴板](https://www.luogu.com.cn/paste/4js5yr87)。

建议复制到本地观看，中间的空格是为了方便对齐。

# Part 4：后文

这篇题解不是立刻写的，而是一点点补的。我写这篇题解的时候一直在震撼我当时到底在想什么。感觉以后还是不能太经验主义的对着数据范围想复杂度了/qd。


---

## 作者：Silence_World (赞：1)

# 思路

题意简单明了，不多赘述，看到题的第一眼想的就是搜索，毕竟是要构成 L   形，搜起来还是比较容易的，写个搜索试一下发现好像不太对，看了眼标签发现 dp 也有，就想了想 dp 的思路，本来想写五维的看了看题解的大佬一堆插头 dp，就有点慌，又看了看其他大佬的思路，突然发现这题四维 dp   也能写，不需要滚动，就是枚举列就可以了，而且思路比较简洁，没什么太大的难度，我们用这一位三个数字表示状态：

0：此列未开始填。

1：此列已经开始填且未填完。

2：此列已经填完。

知道这几点思路就比较清晰了，很显然如果从 $1$ 开始，最后答案应加上 $dp_{m+1,2,2,2}$，写边界时要注意对于每个 L 每状态最多为 $2$，枚举时如果第一层为 $2$ 那第四层在进行枚举时就会判断到 $2$，特判便可，统计每一个列的前缀和形式，当此列还可以继续填时且下一个还能填且不重叠时，就可以统计方案了，注意你枚举的三个列是需要先排序的，一方面为了去重，一方面方便做题，方案数显然是从当前这个位置到上一个 L 形的位置列位置相减（没有则为 $0$），结果一定是累乘的，乘法原理谁都学过，最后对于每个 $dp_{i+1,j,k,x}$ （称其所在枚举的三个状态为 $x1$,$y1$,$y2$）他的结果便是由 $dp_{i,x1,y1,z1}$ *方案数转移得到的，最后结果累加，加个记忆化是必定的，然后为了保证不重复，最后除个 $P^3_3$ 去重，完美结束（调了一天的题做出来也挺感慨的）。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
char s[1005][1005];
bool fl[1005][1005];
int sum[1005][1005];
int r[5];
int jiyi[105][105][105];
int dp[40][3][3][3];
int n,m;
int dpfs(int x,int y,int z){
	r[0]=x;
	r[1]=y;
	r[2]=z;
	sort(r,r+3);
	x=r[0];
	y=r[1];
	z=r[2];
	if(jiyi[x][y][z])return jiyi[x][y][z];//记忆化 
	memset(dp, 0, sizeof(dp));
	dp[1][0][0][0]=1;
	for(int i=1;i<=m;i++){
		for(int x1=0;x1<=2;x1++){
			for(int y1=0;y1<=2;y1++){
				for(int z1=0;z1<=2;z1++){
					if(!dp[i][x1][y1][z1])continue;
					for(int x2=x1;x2<=min((long long)2,x1+1);x2++){//最大状态为2，推状态时别忘了。 
						for(int y2=y1;y2<=min((long long)2,y1+1);y2++){
							for(int z2=z1;z2<=min((long long)2,z1+1);z2++){
								int ans=1;
								int xian=0;
								if(x1==1 or x2==1){//正在建 
									if(fl[x][i] or x==xian){//有L遮挡或者不能建 
										continue;
									}
									else{
										if(x1==0)ans*=min(sum[x][i],x-xian)-1;//方案数累乘 
										xian=x;//更改上一个L位置 
									}
								}
								if(y1==1 or y2==1){//同理 
									if(fl[y][i] or y==xian){
										continue;
									}
									else{
										if(y1==0)ans*=min(sum[y][i],y-xian)-1;
										xian=y;
									}
								}
								if(z1==1 or z2==1){//同理 
									if(fl[z][i] or z==xian){
										continue;
									}
									else{
										if(z1==0)ans*=min(sum[z][i],z-xian)-1;
										xian=z;
									}
								}
								dp[i+1][x2][y2][z2]+=dp[i][x1][y1][z1]*ans;
							}
						}
					}
				}
			}
		}
	}
	jiyi[x][y][z]=dp[m+1][2][2][2];
	return dp[m+1][2][2][2];
}
main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
			if(s[i][j]=='#'){
				fl[i][j]=1;
				sum[i][j]=0;
			}
			else{//每列前缀和 
				sum[i][j]=sum[i-1][j]+1;
			}
		}
	} 
	
	int cnt=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int t=1;t<=n;t++){
				cnt+=dpfs(i,j,t);//枚举每列 
			}
		}
	}
	cout<<cnt/6;//去重 
}
```


---

## 作者：封禁用户 (赞：0)

# P3170 [CQOI2015] 标识设计 题解

**题目大意**： 本人觉得已经说得够清楚的了。

观察题目，我们发现这是一道 [插头 DP ](https://blog.csdn.net/litble/article/details/79369147) 题。因为数据范围人人都得看，我一看，倒吸了一口凉气，不行，太大了，于是我发现合法状态很少，因为轮廓线上最多同时只能有三个插头，所以大部分状态都是不合法的。

那我们就转移呗，大致分为 10 种：


1. 这一格是障碍：直接转移过去。

2. 没有向右和向下的插头：这一格可以不放，可以为一个 L 的起点。

3. 只有向下的插头：那么说明这肯定是 L 上面转移下来的，可以继续向下延伸，或者向右拐。

4. 只有向右的插头：那么说明一定是 L 拐弯之后过来的，可以继续向右延伸，或者在这里结束。

5 .同时有向右和向下的插头：此种情况不合法，直接跳过。

接着，我们可以用 [ 结构体 ](https://blog.csdn.net/songforest1/article/details/80964165) 来封装状态，这样会更省力。

代码我在此就不放了，感谢大家的阅读。

---

## 作者：H_Kaguya (赞：0)

提供一个 $O(n^6)$ 但是既好写常数又小的做法。  
以下认为 $n, m$ 同阶。  

首先，我们认为一个 L 型标识的位置为拐点的位置。  
然后，对于所有的位置，按照从上到下、从左到右顺次标号。  
那么，我们在枚举的时候，钦定三个 L 的位置递增即可。  
另外，提前预处理出来一个位置向左、向上能够联通的最大长度。  

首先考虑如果只有两个 L 怎么搞。  

记 $f(x, y, len)$ 表示第一个标识在 $(x, y)$，横向边的长度为 $len$ 的方案数。  
容易发现纵向边对另一个 L 没有限制，所以最后乘上一个长度即可。  

考虑 $f(x, y, len)$ 向 $f(x, y, len + 1)$ 转移。  
相对于 $f(x, y, len)$ 来说，$f(x, y, len + 1)$ 需要减掉第二个 L 的纵向边经过了 $(x, y + len)$ 的方案。  
通过前缀和优化可以 $O(1)$ 计算。  
对于 $f(x, y, len)$ 向 $f(x, y + 1, len - 1)$ 的转移同理。  

下面的代码在实现的时候，处理出来了所有的 $f(x, i, 1)$ 的值，然后只使用了第一种转移。  
常数可能更小一些。本质相同。  

所以，对于每一个 $x$，我们只需要暴力计算出来 $f(x, 1, 1)$，然后就可以使用上述转移 $O(n^3)$ 即可处理出来全部的值。  
单次暴力复杂度 $O(n^2)$，所以整体复杂度 $O(n^3)$。  

分析到这里，如果我们暴力枚举第一个 L 的位置，然后调用上述算法，即可将复杂度降为 $O(n^6)$。  
然后发现能过，而且效率还可以，就结束了。  

事实上，再使用上述思想考虑枚举第一个 L 时的临项转移，还可以将复杂度消掉一个或者两个 $n$。  
然而需要一些分类讨论和麻烦的处理。  
并不符合我们“好写”的初衷。所以不再分析。  

下附代码。  

```cpp
#include <stdio.h>
#include <algorithm>
#define sz 32
using namespace std;
struct node
{
	int x, y;
	node(int a, int b)
	{
		x = a; y = b;
	}
};
int n, m;
long long ans;
char sav[sz];
char mp[sz][sz];
int up[sz][sz], down[sz][sz], bak[sz][sz], sum[sz][sz];
int dp[sz][sz][sz];
void load();
void sol(int);
int main()
{
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		scanf ("%s", mp[i] + 1);
	for (int i = 1; i <= n; ++i)
	{
		for (int s = 1; s <= m; ++s)
			sav[s] = mp[i][s];
		for (int j = 1; j <= m; ++j)
			if (mp[i][j] == '.' && mp[i - 1][j] == '.')
			{
				int cnt = 0;
				for (int k = i - 1; mp[k][j] == '.'; --k)
					++cnt;
				for (int k = j + 1; mp[i][k] == '.'; ++k)
				{
					for (int s = j; s <= k; ++s)
						mp[i][s] = '#';
					load(); sol(i);
					for (int x = i; x <= n; ++x)
					{
						int y;
						if (x == i)
							y = k + 1;
						else
							y = 1;
						for ( ; y <= m; ++y)
							if (up[x][y] > 1 && bak[x][y] > 1)
								for (int s = y + 1; mp[x][s] == '.'; ++s)
									ans += dp[x][y][s] * (up[x][y] - 1LL) * cnt;
					}
					for (int s = j; s <= k; ++s)
						mp[i][s] = sav[s];
				}
			}
	}
	printf ("%lld\n", ans);
	return 0;
}

void load()
{
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			up[i][j] = down[i][j] = bak[i][j] = (mp[i][j] == '.');
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			if (up[i][j])
				up[i][j] += up[i - 1][j];
	for (int i = n; i; --i)
		for (int j = 1; j <= m; ++j)
			if (down[i][j])
				down[i][j] += down[i + 1][j];
	for (int i = 1; i <= n; ++i)
		for (int j = m; j; --j)
			if (bak[i][j])
				bak[i][j] += bak[i][j + 1];
	for (int i = n; i; --i)
		for (int j = 1; j <= m; ++j)
			if (bak[i][j])
				sum[i][j] = sum[i + 1][j] + bak[i][j] - 1;
			else
				sum[i][j] = 0;
}

void sol(int top)
{
	for (int i = top; i <= n; ++i)
	{
		int tmp = 0;
		for (int j = i + 1; j <= n; ++j)
			for (int k = 1; k <= m; ++k)
				if (mp[j][k] == '.')
					tmp += (up[j][k] - 1) * (bak[j][k] - 1);
		for (int j = m; j; --j)
		{
			if (mp[i][j] == '.')
				tmp += (up[i][j] - 1) * (bak[i][j] - 1);
			dp[i][j][j - 1] = tmp;
		}
		for (int j = 1; j <= m; ++j)
		{
			node x(j, j - 1);
			while (x.y != m)
			{
				dp[i][x.x][x.y + 1] = dp[i][x.x][x.y];
				if (up[i][x.y + 1] && bak[i][x.y + 1])
					dp[i][x.x][x.y + 1] -= (up[i][x.y + 1] - 1) * (bak[i][x.y + 1] - 1);
				if (down[i][x.y + 1] > 1)
					dp[i][x.x][x.y + 1] -= up[i][x.y + 1] * sum[i + 1][x.y + 1];
				++x.y;
			}
		}
	}
}

```


---


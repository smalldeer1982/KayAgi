# [CTSC2010] 性能优化

## 题目描述

程序员小明正在开发一套大型软件，软件中有一段核心程序，用伪代码描述如下（假设所有变量初值均为 $0$，并且假定其中的数据类型均不会出现溢出）： 

~~~cpp
Input a[0], a[1], ... , a[n - 1], b[0], b[1], ... , b[n - 1], C
For i: 0 to n - 1
	x[0, i] = a[i]
For i: 0 to C - 1
	For j: 0 to n - 1
		For k: 0 to n - 1
			x[i + 1, (j + k) mod n] = x[i + 1, (j + k) mod n] + b[k]x[i, j]
Output x[C, 0] mod (n + 1), x[C, 1] mod (n + 1), ... , x[C, n - 1] mod (n + 1)
~~~

但是，这段程序的效率非常低，它的时间复杂度高达 $\Theta(n^2C)$。他想让你帮忙优化一下这个程序，当然要求输出相同的结果。为了使问题更简单，他保证输入的 $n$ 能表示成若干个不超过 $10$ 的正整数的乘积，并且 $n + 1$ 是质数。

## 说明/提示

总共 $10$ 个测试点，数据范围满足：

| 测试点 |         $n$          |     $C$     |
| :----: | :------------------: | :---------: |
|   1    |      $\leq 100$      | $\leq 100$  |
|   2    |      $\leq 100$      | $\leq 10^9$ |
|   3    |      $\leq 700$      | $\leq 10^9$ |
|   4    |      $\leq 700$      | $\leq 10^9$ |
|   5    |     $\leq 10^4$      |   $ = 1$    |
|   6    |     $\leq 10^5$      |    $= 1$    |
|   7    |     $\leq 10^5$      |    $= 1$    |
|   8    | $\leq 5 \times 10^5$ | $\leq 10^9$ |
|   9    | $\leq 5 \times 10^5$ | $\leq 10^9$ |
|   10   | $\leq 5 \times 10^5$ | $\leq 10^9$ |

在所有输入数据中，$a_i$ 和 $b_i$ 均不超过 $10^9$。

## 样例 #1

### 输入

```
4 1
1 2 3 4
4 3 3 1
```

### 输出

```
2
1
0
2
```

# 题解

## 作者：NaCly_Fish (赞：15)

萌新刚学 FFT，然后就看见了这题，，

首先观察题目中给的伪代码，不难发现要求出序列 $a$ 与「序列 $b$ 的循环卷积 $c$ 次幂」的循环卷积。

你要知道一个结论：两个长为 $n$ 的序列分别 DFT 后，对应项乘起来再 IDFT，就是两个序列做长度为 $n$ 的循环卷积的结果。

证明很简单，套一下单位根反演就行了，不是这里主要讲的内容。

****
现在的问题就是怎么快速做给定长为 $n$ 的 DFT。虽然 Bluestein 可以做，但常数过大；不妨考虑题目中给出的条件：$n$ 的质因子都不超过 $10$。

设 $d$ 是 $n$ 的一个质因子，对 $A(x)$ 做 DFT 时，可以分成 $d$ 个多项式：

$$A_i(x)=\sum_{j=0}^{n/d-1} a_{i+jd}x^j$$
这样就有
$$A(x)=\sum_{i=0}^{d-1}x^iA_i(x^d)$$
代入单位根就是
$$A(\omega_n^j)=\sum_{i=0}^{d-1}\omega_n^{ij}A_i(\omega_n^{jd})$$
$$A(\omega_n^j)=\sum_{i=0}^{d-1}\omega_n^{ij}A_i(\omega_{n/d}^j)$$
直接分治做即可。

这里写的是递归版，比较慢；稍微改改，处理出每个数在最后跑到哪个位置（即普通 FFT 中的 rev 数组），一层层合并上去，就是迭代版了。

参考代码（常数巨大）：
```cpp
#pragma GCC optimize (2)
#pragma GCC optimize ("unroll-loops")
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 500003
#define ll long long
#define reg register
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

int p,r;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline int findrt(int x){
    static int fac[N];
    int cnt = 0,m = x-1;
    for(reg int i=2;i*i<=m;++i){
        if(m%i!=0) continue;
        fac[++cnt] = i;
        while(m%i==0) m /= i;
    }
    if(m>1) fac[++cnt] = m;
    for(reg int i=2;i<=x;++i){
        bool flag = true;
        for(reg int j=1;j<=cnt;++j){
            if(power(i,(x-1)/fac[j])!=1) continue;
            flag = false;
            break;
        }
        if(flag) return i;
    }
    return -1;
}

int fac[233]; // it's factor not factorial
int cnt;

inline void getfac(int x){
    for(reg int i=2;i*i<=x;++i){
        if(x%i!=0) continue;
        while(x%i==0){
            fac[++cnt] = i;
            x /= i;
        }
    }
    if(x>1) fac[++cnt] = x;
}

void dft(int *f,int n,int dep){
    int rt[n];
    rt[0] = 1,rt[1] = power(r,(p-1)/n);
    for(reg int i=2;i!=n;++i) rt[i] = (ll)rt[i-1]*rt[1]%p;
    if(n<=64){
        int a[n];
        memset(a,0,n<<2);
        for(reg int i=0;i!=n;++i)
        for(reg int j=0;j!=n;++j)
            a[i] = (a[i]+(ll)f[j]*rt[i*j%n])%p;
        memcpy(f,a,n<<2);
        return;
    }
    int d = fac[dep],lim = n/fac[dep];
    int g[d][lim];
    for(reg int i=0;i!=d;++i)
    for(reg int j=0;j!=lim;++j)
        g[i][j] = f[i+j*d];
    for(reg int i=0;i!=d;++i) dft(g[i],lim,dep+1);    
    for(reg int j=0;j!=n;++j){
        f[j] = 0;
        for(reg int i=0;i!=d;++i)
            f[j] = (f[j]+(ll)rt[i*j%n]*g[i][j%lim])%p;
    }
}

inline void idft(int *f,int n){
    reverse(f+1,f+n);
    dft(f,n,1);
    int x = power(n,p-2);
    for(reg int i=0;i!=n;++i) f[i] = (ll)f[i]*x%p;
}

int n,k;
int a[N],b[N];

int main(){ 
    read(n),read(k);
    p = n+1,r = findrt(n+1);
    getfac(n);
    for(reg int i=0;i!=n;++i) read(a[i]);
    for(reg int i=0;i!=n;++i) read(b[i]);
    dft(a,n,1),dft(b,n,1);
    for(reg int i=0;i!=n;++i) a[i] = (ll)a[i]*power(b[i],k)%p;
    idft(a,n);
    for(reg int i=0;i!=n;++i) print(a[i]),putchar('\n');
    return 0;   
}
```

---

## 作者：Weng_Weijie (赞：13)

***
题意：

给定长度为 $n$ 的多项式 $A, B$

求 $A * B^C $ 循环卷积的结果，模质数 $n+1$
***

首先要会 $\mathrm{FFT}$，不仅要会写，而且要懂原理

将 $F(x)=a_0+a_1x+a_2x^2+\dots+a_{n-1}x^{n-1}$ 的系数分成两部分

$$F^{[0]}(x)=a_0+a_2x+\dots+a_{n-2}x^{\frac{n-2}2}$$

$$F^{[1]}(x)=a_1+a_3x+\dots+a_{n-1}x^{\frac{n-2}2}$$

$$F(x)=F^{[0]}(x^2)+xF^{[1]}(x^2)$$

将 $n$ 次单位根代入

$$F(\omega_n^i)=F^{[0]}(\omega_n^{2i})+\omega_n^iF^{[1]}(\omega_n^{2i})$$

由于单位根具有消去律

$$F(\omega_n^i)=F^{[0]}(\omega_{\frac n2}^i)+\omega_n^iF^{[1]}(\omega_{\frac n2}^i)$$

然后就可以分治了

这题也是类似，考虑将 $n$ 分解质因数，然后将 $n$ 不断地分成 $p$ 块，这样才能保证复杂度

具体地：

$$ F(x)=a_0+a_1x+a_2x^2+\dots+a_{n-1}x^{n-1} $$

$$F^{[0]}=a_0+a_px+\dots+a_{n-p}x^{\frac {n-p}p}$$

$$F^{[i]}=a_i+a_{p+i}x+\dots+a_{n-p+i}x^{\frac{n-p}p}$$

$$F(\omega_n^i)=F^{[0]}(\omega_{\frac np}^i)+\omega_n^iF^{[1]}(\omega_{\frac np}^i)+\dots+\omega_n^{i(p-1)}F^{[p-1]}(\omega_{\frac np}^i)$$

可以开始分治

注意此时如果要写迭代版的 $\mathrm{FFT}$，需要注意的是 $\mathrm{rev}$ 数组可能比较特殊

$\omega_n$ 可以随意取模数的一个原根

代码：
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>

const int N = 500000;
using LL = long long;
int n, m, wn[N], primes[N], power[N], prime_tot, mod;
int pow(int x, int y) {
    int ans = 1;
    for (; y; y >>= 1, x = (LL) x * x % mod)
        if (y & 1) ans = (LL) ans * x % mod;
    return ans;
}
void reduce(int &x) {
    x += x >> 31 & mod;
}
void factor(int n) {
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) n /= i, primes[prime_tot++] = i--;
    if (n > 1) primes[prime_tot++] = n;
}
int primitive_root() {
    for (int i = 2; ; ++i) {
        bool flag = 1;
        for (int j = 0; j < prime_tot; ++j)
            if (pow(i, n / primes[j]) == 1) {
                flag = 0; break;
            }
        if (flag) return i;
    }
}
int tmp[N];
void reverse(int *A) {
    for (int i = prime_tot - 1, block = n; ~i; --i) {
        for (int idx = 0, k = 0; k < n; k += block)
            for (int j = 0; j < primes[i]; ++j)
                for (int l = 0; l < block; l += primes[i])
                    tmp[idx++] = A[k + j + l];
        for (int k = 0; k < n; ++k) A[k] = tmp[k];
        block /= primes[i];
    }
}
void dft(int *A, int typ) {
    reverse(A);
    for (int i = 0, block = 1; i < prime_tot; ++i) {
        const int mid = block, wi = wn[n / (block *= primes[i])];
        for (int j = 0; j < n; ++j)
            tmp[j] = 0;
        for (int j = 0; j < n; j += block) {
            int wk = 1;
            for (int k = 0; k < block; ++k) {
                for (int l = k % mid, w = 1; l < block; l += mid, w = (LL) w * wk % mod)
                    reduce(tmp[j + k] += (LL) w * A[j + l] % mod - mod);
                wk = (LL) wk * wi % mod;
            }
        }
        for (int j = 0; j < n; ++j)
            A[j] = tmp[j];
    }
    if (!typ) {
        std::reverse(A + 1, A + n);
        for (int i = 0; i < n; ++i)
            A[i] = (LL) A[i] * n % mod;
    }
}
int a[N], b[N], rk[N];
int main() {
    std::ios::sync_with_stdio(0), std::cin.tie(0);
    std::cin >> n >> m, mod = n + 1, factor(n);
    wn[0] = 1, wn[1] = primitive_root();
    for (int i = 2; i < n; ++i) wn[i] = (LL) wn[i - 1] * wn[1] % mod;
    for (int i = 0; i < n; ++i) std::cin >> a[i];
    for (int i = 0; i < n; ++i) std::cin >> b[i];
    dft(a, 1), dft(b, 1);
    for (int i = 0; i < n; ++i)
        a[i] = (LL) a[i] * pow(b[i], m) % mod;
    dft(a, 0);
    for (int i = 0; i < n; ++i)
        std::cout << a[i] << '\n';
    return 0;
}

```

---

## 作者：qwaszx (赞：9)

首先由于某种奥妙重重的原因，做长度为$n$的$FFT$再乘起来相当于对两个序列做了长为$n$的循环卷积.使用单位根反演证明如下:

$$\begin{aligned}c_k&=\sum_{0\leq i<n}\sum_{0\leq j<n}[(i+j)\!\!\!\!\mod n=k]a_ib_j\\&=\sum_{0\leq i<n}\sum_{0\leq j<n}a_ib_j\frac{1}{n}\sum_{0\leq d<n}\omega_n^{d(i+j-k)}\\&=\frac{1}{n}\sum_{0\leq d<n}\omega_n^{-dk}\left(\sum_{0\leq i<n}a_i\omega_n^{di}\right)\left(\sum_{0\leq j<n}b_j\omega_n^{dj}\right)\end{aligned}$$

你发现等式的右边刚好就是$FFT(A)$和$FFT(B)$对应项乘起来之后再$IDFT$回去，于是这个结论是正确的.

那么回到原题，相当于是求$A\cdot B^C$，乘法是长度为$n$的循环卷积.系数对$n+1$取模.

这样我们只需要考虑如何求出长度为$n$的FFT，由于精度问题需要使用NTT，而题目保证$n+1$是质数，从而模$n+1$意义下存在原根，那么显然有$\omega_n\equiv g\pmod{(n+1)}$.

考虑正常的FFT，相当于是进行如下的一个过程:

- 求$A(\omega_n^{i}),i=0,1,\cdots,n-1$

- 提出$A$的偶数项系数和奇数项系数，分别形成两个新的多项式$A_0(x)$和$A_1(x)$，容易看出有$A(x)=A_0(x^2)+xA_1(x^2)$

- 套上单位根，有$A(\omega_n^i)=A_0(\omega_n^{2i})+\omega_n^iA_1(\omega_n^{2i})=A_0(\omega_{n/2}^i)+\omega_n^iA_1(\omega_{n/2}^i)$

- 你发现问题被分成了求$A_0(\omega_{n/2}^i)$和$A_1(\omega_{n/2}^i)$两个子问题，但还有一个小问题是子问题只能求出$i<n/2$的点值，而我们要求$i<n$

- 这时候利用单位根的第二个性质，有$\omega_{n/2}^{i+n/2}=\omega_{n/2}^i,\omega_{n}^{i+n/2}=-\omega_n^i$.这个在实现的时候被叫做“蝴蝶操作”.

- 到这里就可以分治了，我们可以写出一个递归的FFT

- 我们观察了一下分治的时候每个元素被划归到的位置并预处理了这个东西.现在我们只要把序列中的每个元素放到它最后的位置就可以自底向上合并而不是自上而下分治了.这样我们得到了一个高效的能跑1e6的迭代实现，也就是我们通常写的FFT.

我们发现最关键的就是第二步，它把元素按照位置模二的余数分成两份.可不可以不按照模二而是按照别的分呢？答案是肯定的，假设我们按照模$p$的余数分，那么我们就把FFT魔改成了以下过程(设初始长度为$pn$):

- 求$A(\omega_{pn}^i),0\leq i<n$

- 把$A$的系数按照该项次数模$p$分类，分出$p$个多项式$A_0(x),A_1(x),\cdots,A_{p-1}(x)$.具体地，有$A_k(x)=\sum\limits_{0\leq i<n}a_{pi+k}x^i$.容易看出它们满足关系$A(x)=\sum\limits_{0\leq k<p}x^kA_k(x^p)$.

- 套上单位根，有$A(\omega_{pn}^i)=\sum\limits_{0\leq k<p}\omega_{pn}^{ki} A_k(\omega_{n}^i)$.这样问题被分成了$p$个子问题.刚才的小问题依然存在.

- $i$一定可以表示成$\lfloor\frac{i}{n}\rfloor n+(i\!\!\mod n)$，我们把后面写成$in+r$.这样就有

  $$A(\omega_{pn}^{in+r})=\sum_{0\leq k<p}\omega_{pn}^{k(in+r)}A_k(\omega_n^{in+r})=\sum_{0\leq k<p}\omega_{p}^{ik}\omega_{pn}^{kr}A_k(\omega_n^r)$$
  
  观察这个式子，当$r$固定的时候相当于是对$\omega_{pn}^{kr}A_k(\omega_n^r)$组成的多项式做了长度为$p$的FFT.这个时候没啥好的做法，只能$O(p^2)$暴力去做.于是这个小问题可以在$O(p^2)$的时间内解决.时间复杂度$T(pn)=pT(n)+O(p^2n)$.画画递归树可以看出来每一层的复杂度都是$O(pN)$的，其中$N$是原始长度.

- 发现层与层之间是独立的，也就是说每一层可以选取不同的$p$，只要这个$p$整除子问题的规模即可.到这里可以分治了，可以写出一个递归形式的FFT.显然$p$越小越好，如果$n=\prod p_i^{k_i}$，那么这样做FFT的复杂度是$O(n\sum p_ik_i)$的.

- 我们还是可以预处理每个元素最后被划分到的位置，然后自底向上合并来代替分治.这样可以写出一个高效的迭代FFT.

到这里FFT就可以写了，至于求原根和分解质因数都是基础技能了吧(

关于卡常数，我预处理了单位根，这样跑得飞快.

FFT完就把对应位的$a_i$乘上$b_i^C$，然后再IDFT回去就好了.

关于IDFT有一个简单地写法，考虑求的其实是

$$
nc_i=\sum_{0\leq k<n}a_k\omega_n^{-ki}=\sum_{0\leq k<n}a_k\omega_n^{i(n-k)}
$$

所以可以把$A$从第一位开始翻转一下，然后做DFT再除以$n$即可.

实现细节可以看代码.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e6;
int rev[N],tmp[N],a[N],n,C,mod,b[N],p[N],pn,g,wp[10][10],wn[N<<1];
int qpower(int a,int b)
{
	int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;
}
int getpos(int x)
{
	int pos=0,len=n;
	for(int j=1;j<=pn;j++)
		pos+=len/p[j]*(x%p[j]),len/=p[j],x/=p[j];
	return pos;
}
void NTT(int a[])
{
	for(int i=0;i<n;i++)tmp[rev[i]]=a[i];
	for(int i=0;i<n;i++)a[i]=tmp[i];
	int len=1,cntw=0;
	for(int i=pn;i>=1;len*=p[i],i--)
	{
		for(int j=0;j<n;j+=p[i]*len)
		{
			for(int r=0;r<len;r++)
			{
				int w=1,*z=wn+cntw+r*p[i];
				for(int k=0;k<p[i];k++)tmp[k]=1ll*a[j+k*len+r]*(*(z+k))%mod;
				for(int k=0;k<p[i];k++)
				{
					int *z=a+j+k*len+r;*z=0;w=wp[p[i]][k];
					for(int t=p[i]-1;t>=0;t--)*z=(1ll*(*z)*w+tmp[t])%mod;//秦九韶公式
				}
			}
		}
		cntw+=len*p[i];
	}
}
void make()
{
	pn=0;int tn=n;
	while(tn%2==0)p[++pn]=2,tn>>=1;
	while(tn%3==0)p[++pn]=3,tn/=3;
	while(tn%5==0)p[++pn]=5,tn/=5;
	while(tn%7==0)p[++pn]=7,tn/=7;
	for(g=2;;g++)
	{
		if(n%2==0&&qpower(g,n>>1)==1)continue;
		if(n%3==0&&qpower(g,n/3)==1)continue;
		if(n%5==0&&qpower(g,n/5)==1)continue;
		if(n%7==0&&qpower(g,n/7)==1)continue;
		break;
	}
	for(int i=1;i<=pn;i++)
	{
		if(p[i]==p[i-1])continue;
		int omg=qpower(g,n/p[i]),w=1;
		for(int j=0;j<p[i];j++,w=1ll*w*omg%mod)wp[p[i]][j]=w;
	}
	int len=1,cnt=0;
	for(int i=pn;i>=1;len*=p[i],i--)
	{
		int omgn=qpower(g,n/(len*p[i]));
		for(int r=0,omg=1;r<len;r++,omg=1ll*omg*omgn%mod)
			for(int j=0,w=1;j<p[i];j++,w=1ll*w*omg%mod)wn[cnt+r*p[i]+j]=w;//把系数p[i]放在r上可以减少cache miss来优化常数
		cnt+=p[i]*len;
	}
}
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	n=getin(),C=getin();mod=n+1;C%=n;
	make();
	for(int i=0;i<n;i++)a[i]=getin();
	for(int i=0;i<n;i++)b[i]=getin();
	for(int i=0;i<n;i++)rev[i]=getpos(i);
//	for(int i=0;i<n;i++)cout<<rev[i]<<" ";puts("");
	NTT(a),NTT(b);
	for(int i=0;i<n;i++)a[i]=1ll*a[i]*qpower(b[i],C)%mod;
	reverse(a+1,a+n);
	NTT(a);for(int i=0;i<n;i++)a[i]=(mod-a[i])%mod;
	for(int i=0;i<n;i++)printf("%d\n",a[i]);
}
```

---

## 作者：zhiyangfan (赞：8)

## 题意
给出 $n$ 次多项式 $A,B$ 和常数 $C$，求 $A\times B^C$ 的系数对 $n+1$ 取模的结果，其中乘法定义为模 $n$ 意义下的循环卷积。保证 $n$ 能被分为若干不超过 $10$ 的正整数的乘积且 $n+1$ 是质数。($1\le n\le 5\times 10^5,1\le C\le 10^9,\rm 6s,250MB$)
## 题解
> 闲话。我们模拟赛考了一道循环卷积的题，我发现我啥也不会。学习了学长的博客之后做了这道题。然后发现我之前对 FFT 的理解太浅了。

首先要知道一点，$\rm DFT$ 和 $\rm IDFT$ 的过程实际上是在做循环卷积，循环的长度和 $\rm DFT$ 时用到的单位根次数相同。考虑：
$$h_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}f_i\times g_j[(i+j)\bmod n=k]$$
即 $f,g$ 的 $n$ 次循环卷积。用单位根反演搞掉取模：
$$\begin{aligned}
	h_k&=\frac{1}{n}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}f_i\times g_j\sum_{d=0}^{n-1}\omega_{n}^{(i+j-k)d}\\
	&=\frac{1}{n}\sum_{d=0}^{n-1}\omega_{n}^{-kd}\sum_{i=0}^{n-1}f_i\omega_n^{id}\sum_{j=0}^{n-1}g_j\omega_n^{jd}
\end{aligned}$$
注意到后面两个求和式分别相当于 $F(\omega_{n}^d),G(\omega_n^d)$。注意到求 $F(\omega_{n}^d)\times G(\omega_n^d)$ 的过程就是 $\rm DFT$ 转化成点值后点积，得到 $\operatorname{DFT}(H)$。之后 $\operatorname{IDFT}$ 的过程只需要代入 $\omega_{n}^{-d}$，再除 $n$ 就好了。

再看回上述过程的实现之一，$\rm FFT$。它依赖的是 $n$ 为 $2$ 的次幂，且 $\omega_{\frac{n}{2^k}}$ 存在（如果在模意义下的话），来对多项式进行分治。具体来讲，考虑将原多项式奇偶分治。
$$F_0(z)=\sum_{i\bmod 2=0}f_iz^{\frac{i}{2}},F_1(z)=\sum_{i\bmod2=0}f_iz^{\frac{i-1}{2}}$$
从而：
$$F(\omega_n^k)=F_0(\omega_n^{2k})+\omega_n^kF_1(\omega_n^{2k})$$
这样分治还不太够，因为还要求代入的单位根次数和多项式次数相同。所以我们再把单位根变一下。
$$F(\omega_n^k)=F_0(\omega_{\frac{n}{2}}^k)+\omega_n^kF_1(\omega_{\frac{n}{2}}^k)$$
发现 $k$ 和 $k+\frac{n}{2}$ 处的值对应的表达式很相似。
$$F(\omega_n^{k+\frac{n}{2}})=F_0(\omega_{\frac{n}{2}}^k)-\omega_n^kF_1(\omega_{\frac{n}{2}}^k)$$
从而我们可以将问题规模缩小一半，且可以一次求两个值。而对于 $\rm IDFT$，相当于代入的单位根取反，最后得到的系数再除 $n$。
$$F(\omega_n^{-k})=\sum_{i=0}^{n-1}f_i\omega_n^{-ki}=\sum_{i=0}^{n-1}f_i\omega_{n}^{(n-k)i}=f_0+\sum_{i=1}^{n-1}f_{n-i}\omega_{n}^{ki}=F^R(\omega_n^k)$$
所以只需要把 $F$ 的系数从 $1$ 到 $n-1$ 翻转一下就能转化成 $\rm DFT$ 的过程。

平常我们体感 $\rm FFT$ 只是普通的多项式乘法是因为，我们单位根用的是 $>\deg F+\deg G$ 的最小的 $2$ 的次幂。模数比最大可能得到的次数还大，就没有影响了。

回到这道题。这道题实际上要求的是模 $n+1$ 意义下 $n$ 次单位根下的 $\rm DFT$。我们依然想沿用 $\rm FFT$ 的分治思路，最大的问题在于不能再每次方便地分治成左右两半了。但题目保证，$n$ 的所有因子都很小，所以我们考虑每次分治都用 $n$ 的某个质因子 $d$ 分治，然后花费 $\mathcal{O}(d)$ 的时间来把它们组合起来。从而做到 $\mathcal{O}(n\sum k_ip_i)$ 的时间复杂度。$k_i,p_i$ 分别表示 $n$ 的质因子和它的次数。考虑每个质因子会出现 $k_i$ 次，每次都会造成 $\mathcal{O}(p_in)$ 的时间复杂度。（这里和 $\rm FFT$ 不一样，下面说）
 
具体来讲，我们每层选择 $n$ 的一个因子 $m$，因为模数的 $\varphi$ 值是 $n$，从而求出原根 $g$ 后 $m$ 次单位根 $g^{\frac{n}{m}}$ 一定存在。然后仿照上述过程分治：
$$F_j(z)=\sum_{i\bmod m=j}f_iz^{\frac{i-j}{m}}$$
之后组合：
$$F(\omega_n^k)=\sum_{j=0}^{m-1}\omega_{n}^{ij}F_j(\omega_{\frac{n}{m}}^k)$$
这里就不能再像刚刚一样特化一下 $k$ 比较大的情况了，不过只需要让指数对单位根的次数取模即可得到需要的值。因为不能一次求出多个值，所以每层需要的计算量之和都是 $\mathcal{O}(nd)$ 的。

似乎还可以实现成非递归版的，但我不会了。~~不过我这个递归版的开了 O2 好像还挺快。~~
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
struct IO
{
	static const int N = 1 << 22;
	char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;
	#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)	
	template <typename T>
	void read(T& x)
	{
		x = 0; char ch; int f = 0;
		while ((ch = gc()) < '0' || ch > '9') f |= (ch == '-');
		while (x = (x << 1) + (x << 3) + (ch ^ 48), (ch = gc()) >= '0' && ch <= '9') ;
		if (f) x = ~x + 1;
	}
	void putc(char c)
	{
		if (pp - pbuf == N) fwrite(pbuf, 1, N, stdout), pp = pbuf;
		*pp++ = c;
	}
	template <typename T>
	void print(T x)
	{
		static int st[20]; int tp = 0;
		if (x < 0) putc('-'), x = ~x + 1;
		do st[++tp] = x % 10, x /= 10; while (x);
		while (tp) putc(st[tp--] + '0');
	}
	~IO() { fwrite(pbuf, pp - pbuf, 1, stdout); }
}io;
const int N = 5e5 + 10; typedef long long ll;
int d[30], gn[N], n, mod, m;
inline int ksm(int a, int b) 
{ 
    int ret = 1; 
    while (b) 
    { 
        if (b & 1) ret = (ll)ret * a % mod;
        a = (ll)a * a % mod; b >>= 1;
    } 
    return ret;
}
void init()
{
    std::vector<int> P;
    for (int i = 2, t = n; i <= 7; ++i)
    {
        if (t % i) continue;
        P.push_back(i);
        while (t % i == 0) d[++m] = i, t /= i;
    }
    auto check = [&](int g)
    {
        int phi = mod - 1;
        for (auto p : P) if (ksm(g, phi / p) == 1) return false;
        return true;
    };
    int G = 1; while (!check(G)) ++G;
    gn[0] = 1; for (int i = 1; i < N; ++i) gn[i] = (ll)gn[i - 1] * G % mod;
}
struct Poly
{
    std::vector<int> a;
    int& operator[](const int& id) { return a[id]; }
    void setTime(const int& tim) { a.resize(tim + 1); }
    int getTime() { return (int)a.size() - 1; }
    std::vector<int>::iterator begin() { return a.begin(); }
    std::vector<int>::iterator end() { return a.end(); }
}A, B;
void FFT(Poly& F, int dep)
{
    if (!F.getTime()) return ;
    int n = F.getTime() + 1, m = d[dep];
    std::vector<Poly> A; A.resize(m);
    for (int i = 0; i < m; ++i) A[i].setTime(n / m - 1);
    for (int i = 0; i < n; ++i) A[i % m][(i - i % m) / m] = F[i];
    for (int i = 0; i < m; ++i) FFT(A[i], dep + 1);
    for (int i = 0, p = ::n / n; i < n; ++i)
    {
        F[i] = 0;
        for (int j = 0, q = 0; j < m; ++j, (q += i) %= n)
            (F[i] += (ll)gn[p * q] * A[j][i % (n / m)] % mod) %= mod;
    }
}
int main()
{
    int C; io.read(n); io.read(C); mod = n + 1; init();
    A.setTime(n - 1); B.setTime(n - 1);
    for (int i = 0; i < n; ++i) io.read(A[i]);
    for (int i = 0; i < n; ++i) io.read(B[i]);
    FFT(A, 1); FFT(B, 1);
    for (int i = 0; i < n; ++i) A[i] = (ll)A[i] * ksm(B[i], C) % mod;
    std::reverse(++A.begin(), A.end()); FFT(A, 1); 
    for (int i = 0, inv = ksm(n, mod - 2); i < n; ++i) 
        A[i] = (ll)A[i] * inv % mod, io.print(A[i]), io.putc('\n');
    return 0;
}
```

---

## 作者：myee (赞：5)

### 前言

性能优化……经典题。

这题可以看到它给你暴力算了循环卷积，于是想到 FFT 单位根处点值乘法对应循环卷积的本质。

可是 FFT 长度是 $2^n$ 的，会挂掉。

于是我们可以考虑 Bluestein 算法。

---
### Bluestein 算法

前置知识：[任意模数 Chirp Z-Transform](https://www.luogu.com.cn/problem/P6828)，确保你能过板~~以免被卡常~~。

以下设 $\omega_n$ 为 $n$ 次本原单位根。

设一个长度为 $n$ 的数列 $\{f_n\}$ 的循环卷积点值数列 $\{g_n\}$ 为

$$
g_t=\sum_{k=0}^{n-1}f_k\omega_n^{kt}
$$

由单位根反演，有

$$
f_t=\frac1n\sum_{k=0}^{n-1}g_k\omega_n^{-kt}
$$

以上两项均可用 CZT 加速。

---
### 回到本题

由于单位根点值点乘本质即数列循环卷积，这题变得可做。

把 $a,b$ 点值搞一下，点值按要求乘起来，回演系数，输出，做完了？！

于是你写，交上去，发现被卡常了……

卡卡常就过了。

---
### Code

$c$ 能对 $n$ 取模是因为在点值计算时能使用费马小定理。

```cpp
// Problem: P4191 [CTSC2010]性能优化
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4191
// Memory Limit: 250 MB
// Time Limit: 6000 ms

#include <algorithm>
#include <math.h>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(!b)return y=0,x=1,a;T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}
const dbl Pi=acos(-1);
class cpx
{
    public:
        dbl a,b;
        cpx():a(0),b(0){}
        cpx(dbl a):a(a),b(0){}
        cpx(dbl a,dbl b):a(a),b(b){}
        voi unit(dbl alpha){a=cos(alpha),b=sin(alpha);}
        cpx friend operator+(cpx a,cpx b){return cpx(a.a+b.a,a.b+b.b);}
        cpx friend operator-(cpx a,cpx b){return cpx(a.a-b.a,a.b-b.b);}
        cpx operator-(){return cpx(-a,-b);}
        cpx friend operator*(cpx a,cpx b){return cpx(a.a*b.a-a.b*b.b,a.b*b.a+b.b*a.a);}
        cpx friend operator/(cpx a,ullt v){return cpx(a.a/v,a.b/v);}
        cpx conj(){return cpx(a,-b);}
        cpx mul_i(){return cpx(-b,a);}
        cpx div_i(){return cpx(b,-a);}
    public:
        cpx&operator=(ullt v){return a=v,b=0,*this;}
        cpx&operator+=(cpx v){return*this=*this+v;}
        cpx&operator-=(cpx v){return*this=*this-v;}
        cpx&operator*=(cpx v){return*this=*this*v;}
        cpx&operator/=(ullt v){return a/=v,b/=v,*this;}
        dbl&real(){return a;}
        dbl&imag(){return b;}
};
ullt Mod;
ullt chg(ullt v){return(v<Mod)?v:v-Mod;}
class poly
{
    private:
        std::vector<ullt>V;
    public:
        class FFT
        {
            private:
                std::vector<uint>V;std::vector<cpx>G;uint len;
            public:
                uint length(){return len;}
                voi bzr(uint length)
                {
                    uint p=0;len=1,V.clear(),G.clear();
                    while(length){p++,len<<=1,length>>=1;}
                    V.resize(len),G.resize(len);
                    for(uint i=0;i<len;++i)V[i]=((i&1)?(V[i>>1]|len)>>1:(V[i>>1]>>1)),G[i].unit(Pi*2/len*i);
                }
                voi fft(std::vector<cpx>&y,bol op)
                {
                    if(y.size()<len)y.resize(len);
                    for(uint i=0;i<len;i++)if(V[i]<i)std::swap(y[i],y[V[i]]);
                    for(uint h=2;h<=len;h<<=1)for(uint j=0;j<len;j+=h)for(uint k=j;k<j+(h>>1);k++){cpx u=y[k],t=G[len/h*(k-j)]*y[k+h/2];y[k]=u+t,y[k+h/2]=u-t;}
                    if(op){uint l=1,r=len-1;while(l<r)std::swap(y[l++],y[r--]);for(uint i=0;i<len;i++)y[i]/=len;}
                }
                voi fft_fft(std::vector<cpx>&a,std::vector<cpx>&b,bol op)
                {
                    if(a.size()<len)a.resize(len);
                    if(b.size()<len)b.resize(len);
                    for(uint i=0;i<len;i++)a[i]+=b[i].mul_i();
                    fft(a,op),b[0]=a[0].conj();for(uint i=1;i<len;i++)b[i]=a[len-i].conj();
                    for(uint i=0;i<len;i++){cpx p=a[i],q=b[i];a[i]=(p+q)/2llu,b[i]=(p-q).div_i()/2llu;}
                }
        };
    public:
        poly(){V.clear();}
        poly(std::vector<ullt>V){for(uint i=0;i<V.size();i++)push(V[i]%Mod);cut_zero();}
        bol empty(){return cut_zero(),!size();}
        voi bzr(){V.clear();}
        voi push(ullt v){V.push_back(v%Mod);}
        voi pop(){V.pop_back();}
        ullt val(uint n){return(n<V.size())?V[n]:0;}
        uint deg(){return V.size()-1;}
        uint size(){return V.size();}
        voi add(uint p,ullt v)
        {
            if(deg()<p)chg_deg(p);
            V[p]=(V[p]+v)%Mod;
        }
        poly friend operator+(poly a,ullt v){a.add(0,v);return a;}
        poly friend operator+(poly a,poly b)
        {
            uint len=std::max(a.size(),b.size());
            a.chg_siz(len),b.chg_siz(len);
            for(uint i=0;i<len;i++)a[i]=chg(a[i]+b[i]);
            a.cut_zero();
            return a;
        }
        poly friend operator-(poly a,poly b)
        {
            uint len=std::max(a.size(),b.size());
            a.chg_siz(len),b.chg_siz(len);
            for(uint i=0;i<len;i++)a[i]=chg(a[i]+Mod-b[i]);
            a.cut_zero();
            return a;
        }
        poly operator-()
        {
            cut_zero();uint len=size();
            poly ans;ans.chg_siz(len);
            for(uint i=0;i<len;i++)ans[i]=chg(Mod-V[i]);
            return ans;
        }
        poly friend operator*(poly a,poly b)
        {
            FFT s;poly p;
            uint n=a.deg(),m=b.deg(),len;
            s.bzr(n+m+1),len=s.length();
            std::vector<cpx>v1(len),v2(len),v3(len),v4(len);
            for(uint i=0;i<len;i++)v3[i]=cpx(a.val(i)&32767),v1[i]=cpx(a.val(i)>>15),v4[i]=cpx(b.val(i)&32767),v2[i]=cpx(b.val(i)>>15);
            s.fft_fft(v1,v2,0),s.fft_fft(v3,v4,0);
            for(uint i=0;i<len;i++)v4[i]=(v3[i]+v1[i].mul_i())*v4[i],v2[i]=(v3[i]+v1[i].mul_i())*v2[i];
            s.fft(v2,1),s.fft(v4,1),p.chg_deg(n+m);for(uint i=0;i<=n+m;i++)p[i]=(((ullt)(v2[i].b+.5)%Mod<<30)+((ullt)(v2[i].a+v4[i].b+.5)%Mod<<15)+(ullt)(v4[i].a+.5))%Mod;
            p.cut_zero();
            return p;
        }
        poly inv(){return inv(size());}
        poly inv(uint prec)
        {
            poly ans,f,tmp,w;
            llt x,y;
            exgcd<llt>(val(0),Mod,x,y);
            ans.push(x%(llt)Mod+(llt)Mod),f.push(val(0));
            for(uint k=1;k<prec;k<<=1)
            {
                for(uint i=k;i<(k<<1);++i)f.push(val(i));
                tmp=f*ans,tmp.chg_siz(k<<1),w.bzr();for(uint i=0;i<k;++i)w.push(tmp[i+k]);
                w*=ans;for(uint i=0;i<k;++i)ans.push(Mod-w[i]);
            }
            return ans;
        }
        poly diff(){uint n=size();poly ans;for(uint i=1;i<n;++i)ans.push(V[i]*i);return ans;}
        poly inte()
        {
            uint n=size();
            poly ans;
            ans.chg_deg(n);
            ullt k=1;llt x,y;
            std::vector<ullt>W;W.push_back(1),W.push_back(1);
            for(uint i=2;i<n;++i)W.push_back(k=(k*i)%Mod);
            exgcd<llt>(k*n%Mod,Mod,x,y);
            k=chg(x%(llt)Mod+(llt)Mod);
            for(uint i=n;i;--i)ans[i]=V[i-1]*k%Mod*W[i-1]%Mod,k=k*i%Mod;
            return ans;
        }
        poly ln(){return(this->diff()*this->inv()).inte().chg_deg_ed(deg());}
        poly exp(){return exp(size());}
        poly exp(uint prec)
        {
            poly m;m.push(1);
            if(empty())return m;
            uint tp=1;
            while(tp<prec)m*=*this-(m.diff()*m.inv(tp<<=1)).inte()+1,m.chg_siz(tp);
            m.chg_siz(prec);
            return m;
        }
        poly reverse(){poly ans;for(uint i=deg();~i;--i)ans.push(V[i]);return ans;}
        poly operator/(poly b)
        {
            cut_zero(),b.cut_zero();uint m=size(),n=b.deg();if(m<=n)return poly();
            poly f=this->reverse()*b.reverse().inv(m-n);f.chg_siz((m>n)?m-n:0);return f.reverse();
        }
        poly operator%(poly b){poly f=*this-*this/b*b;f.cut_zero();return f;}
        voi cut_zero(){while(!V.empty()&&!V.back())V.pop_back();}
        voi chg_siz(const uint siz){while(V.size()<siz)V.push_back(0);while(V.size()>siz)V.pop_back();}
        voi chg_deg(const uint d){chg_siz(d+1);}
        poly chg_deg_ed(const uint d){poly ans=*this;return ans.chg_deg(d),ans;}
    public:
        ullt&operator[](uint num){return V[num];}
        poly&operator=(std::vector<ullt>V){bzr();for(uint i=0;i<V.size();i++)push(V[i]%Mod);cut_zero();return*this;}
        poly&operator=(std::vector<cpx>V){bzr();for(uint i=0;i<V.size();i++)push((llt)(V[i].a+.5)%(llt)Mod+(llt)(Mod));cut_zero();return*this;}
        poly&operator+=(poly b){return*this=*this+b;}
        poly&operator-=(poly b){return*this=*this-b;}
        poly&operator*=(poly b){return*this=*this*b;}
        poly&operator/=(poly b){return*this=*this/b;}
        poly&operator%=(poly b){return*this=*this%b;}
};
ullt gotg()
{
    static ullt Fac[15];uint cnt=0;
    ullt v=Mod-1;
    for(ullt i=2;i*i<=v;i++)
        if(!(v%i))
        {
            Fac[cnt++]=i;
            do v/=i;while(!(v%i));
        }
    if(v>1)Fac[cnt++]=v;
    for(ullt ans=2;;ans++)if(power<ullt>(ans,Mod-1,Mod)==1)
    {
        bol b=true;
        for(uint i=0;b&&i<cnt;i++)if(power<ullt>(ans,(Mod-1)/Fac[i],Mod)==1)b=false;
        if(b)return ans;
    }
    return 0;
}
ullt A[500005],B[500005];
uint g_pow[1000005];
uint g_binom_pow[1000005];
uint inv_pow[1000005];
uint inv_binom_pow[1000005];
poly P1,P2;
int main()
{
	uint n;ullt c;scanf("%u%llu",&n,&c),Mod=n+1,c%=n;
	ullt g=gotg();ullt inv=power(g,Mod-2,Mod);
	g_pow[0]=inv_pow[0]=g_binom_pow[0]=inv_binom_pow[0]=1;
	for(uint i=1;i<=n*2;i++)
	{
		g_pow[i]=(ullt)g_pow[i-1]*g%Mod,inv_pow[i]=(ullt)inv_pow[i-1]*inv%Mod,
		g_binom_pow[i]=(ullt)g_binom_pow[i-1]*g_pow[i-1]%Mod,
		inv_binom_pow[i]=(ullt)inv_binom_pow[i-1]*inv_pow[i-1]%Mod;
	}
	for(uint i=0;i<n;i++)scanf("%llu",A+i),A[i]%=Mod;
	for(uint i=0;i<n;i++)scanf("%llu",B+i),B[i]%=Mod;
	P1.chg_siz(n<<1),P2.chg_siz(n);
	for(uint i=0;i<(n<<1);i++)P1[i]=g_binom_pow[i];
	for(uint i=0;i<n;i++)
		P2[i]=A[i]*inv_binom_pow[i]%Mod;
	P2=P2.reverse()*P1;
	for(uint i=0;i<n;i++)
		A[i]=P2.val(n+i-1)*inv_binom_pow[i]%Mod;
	P2.chg_siz(n);
	for(uint i=0;i<n;i++)
		P2[i]=B[i]*inv_binom_pow[i]%Mod;
	P2=P2.reverse()*P1;
	for(uint i=0;i<n;i++)
		A[i]=A[i]*power(P2.val(n+i-1)*inv_binom_pow[i]%Mod,c,Mod)%Mod;
	for(uint i=0;i<(n<<1);i++)P1[i]=inv_binom_pow[i];
	P2.chg_siz(n);
	for(uint i=0;i<n;i++)P2[i]=A[i]*g_binom_pow[i]%Mod;
	P2=P2.reverse()*P1;
	for(uint i=0;i<n;i++)printf("%llu\n",P2.val(n+i-1)*(Mod-g_binom_pow[i])%Mod);
    return 0;
}
```


---

## 作者：憨豆Beng (赞：4)

题意： 

求给出两个长度为n的整数序列a[0..n−1],b[0..n−1]和非负整数C。对于两个长度为n的整数序列，定义∗运算，结果为一个长度为n的整数序列，例如f∗g=h，则有h[k]=∑i+j≡k(modn)f[i]⋅g[j]。 
求a∗b∗b∗⋯∗b每一位模(n+1)的值，其中有C个∗运算，(n+1)是质数，n的质因数大小均不超过10。 
n≤5⋅105,a[i],b[i],C≤109

题解：

循环卷积裸题。首先卷积满足结合律，后面的部分可以求出点值之后快速幂。

考虑FFT如何求出循环的卷积： 
由Cooley−Tukey算法中的IDFT可知，如果我们知道一个函数的n个点值则可以通过逆变换求出原函数，现在假设已经求出两个函数的n个点值。按照同样的方法，有：

A(ωkn)=∑i=0n−1aiwikn,B(ωkn)=∑i=0n−1biwikn

相乘可得： 

C(ωk)=∑i=0n−1aiwikn∑j=0n−1bjwjkn

因为有ωikn⋅ωjkn=ωk⋅(i+j)n=ωk⋅((i+j)modn)n

那么

C(wkn)=∑(i+jmodn)=lAlwkln

其中

Al=ai⋅bj(i+jmodn=l)

发现C就是DFT后的标准形式，也就是说直接对这个点值进行IDFT就可以得到原函数，直接求点值就好了。

直接求点值？？n可能不是2k的形式。

其实只需要对n进行质因数分解，每一层每一个数暴力选取上一层的结果。 
因为n的最大质因数不超过7，那么每一层的每一个数选择的数不超过7个，复杂度是O(7⋅nlogn)。 
推导过程可以参考:[传送门](http://blog.csdn.net/skywalkert/article/details/51737272)

```
#include<bits/stdc++.h>
using namespace std;
const int Maxn=5e5+50;
inline int read(){
    char ch=getchar();int i=0,f=1;
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){i=(i<<1)+(i<<3)+ch-'0';ch=getchar();}
    return i*f;
}
inline void W(int x){
    static int buf[50];
    if(!x){putchar('0');return;}
    while(x)buf[++buf[0]]=x%10,x/=10;
    while(buf[0])putchar(buf[buf[0]--]+'0');
}
int n,C,G,pw[Maxn],a[Maxn],b[Maxn],tp[Maxn],mod,pr[Maxn],tot,pos[Maxn];
inline int power(int a,int b){
    int res=1;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)res=1ll*res*a%mod;
    return res; 
}
inline bool check(int x,int t){
    for(int i=1;i<=tot;i++)if(power(x,t/pr[i])==1)return true;
    return false;
}
inline void findori(int phi){
    for(int i=2;i<=10;i++)
        for(;!(phi%i);pr[++tot]=i,phi/=i);
    G=2;
    while(check(G,n))++G;
}
inline int getpos(int x,int s,int now,int al){
    if(now==tot+1)return s;
    int bl=al/pr[now],rs=x%pr[now];
    return getpos((x-rs)/pr[now],s+bl*rs,now+1,bl);
}
inline void dft(int *A){
    memcpy(tp,A,sizeof(int)*n);
    for(int i=0;i<n;i++)tp[pos[i]]=A[i];
    for(int i=0;i<n;i++)A[i]=tp[i];
    for(int bl=1,pos=tot;pos>=1;bl*=pr[pos],--pos){
        int bl_len=bl*pr[pos],ct=n/bl_len;
        for(int bg=0;bg<n;bg+=bl_len)
            for(int p=0;p<bl_len;p+=bl){
                for(int q=0;q<bl;++q){
                    int s=0,o=(p+q)*ct;
                    for(int r=0;r<pr[pos];++r)
                        (s+=1ll*pw[1ll*o*r%n]*A[bg+r*bl+q]%mod)%=mod; 
                    tp[bg+p+q]=s;
                }
            }
        for(int i=0;i<n;i++)A[i]=tp[i];
    }
} 
int main(){
    n=read(),C=read();mod=n+1;findori(n);C=(C-1)%n+1; 
    for(int i=0;i<n;i++)a[i]=read();
    for(int i=0;i<n;i++)b[i]=read();
    pw[0]=1;for(int i=1;i<n;i++)pw[i]=1ll*pw[i-1]*G%mod;
    for(int i=1;i<n;i++)pos[i]=getpos(i,0,1,n);
    dft(a),dft(b);
    for(int i=0;i<n;i++)a[i]=1ll*a[i]*power(b[i],C)%mod;
    dft(a);reverse(a+1,a+n);
    for(int i=0;i<n;i++)a[i]=1ll*a[i]*power(n,n-1)%mod;
    for(int i=0;i<n;i++)W(a[i]),putchar('\n');
}```

---

## 作者：SovietPower✨ (赞：3)

记$n$次单位根为$\omega_{n}$。如果$DFT$时代入的点值是$\omega_n^0,\omega_n^1,...,\omega_n^{n-1}$，那么我们求的就是模$n$的循环卷积（单位根的性质，乘的时候指数相当于对$n$取模）。

而朴素的$NTT$实现需要将序列长度补到$2^k$，这样需要代入的是$2^k$次单位根，求循环卷积就不对了。也就是序列长度必须是$n$。

所以我们需要处理任意长度的$DFT$，可以用$Bluestein's\ Algotithm$解决：

考虑$DFT$的形式：
$$\begin{aligned}y_k&=\sum_{i=0}^{n-1}a_i\omega_n^{ki}\\&=\sum_{i=0}^{n-1}a_i\omega_{2n}^{k^2+i^2-(k-i)^2}\\&=\omega_{2n}^{k^2}\sum_{i=0}^{n-1}a_i\omega_{2n}^{i^2}\omega_{2n}^{-(k-i)^2}\end{aligned}$$

注意到和式部分是个卷积，可以用$FFT/NTT$计算。所以$Bluestein$的复杂度是$O(n\log n)$的。

具体：$k-i$可能是负的，所以对后一项右移$n$位，令$f_i=a_i\omega_{2n}^{i^2},\ g_i=\omega_{2n}^{-(i-n)^2}$，那么$y_k=\omega_{2n}^{k^2}\sum_{i}f_ig_{n+k-i}=\omega_{2n}^{k^2}(f\times g)_{n+k}$。

$IDFT$同理，可以直接令$\omega_{2n}=\omega_{2n}^{-1}$，代到$DFT$的式子里，也可以一样的推一下。

这样做需要用到$2n$次单位根，有些题可能不存在，可以换种替换$ki$的方式来避免。自己想一下好咯。

所以对于本题就代入$n$个单位根，用$Bluestein$转成点值表示，两多项式相乘再$IDFT$即可。复杂度$O(n\log n)$。

代码咕咕咕了。

---

## 作者：okbj (赞：2)

```
由原根的性质可知，长度为nn的FFT即可支持∗∗运算，难点在于bCbC使得值域过大，即使能够快速计算长度为nn的FFT，使用复数运算的FFT也很难得到精确的答案。

先考虑如何快速计算长度为nn的FFT。 
当n=2kn=2k时，FFT每次是将序列一分为二，然后利用分治的技巧来进行合并。 
因此当n=2k1⋅3k2⋅5k3⋅7k4n=2k1⋅3k2⋅5k3⋅7k4时，FFT每次可能将序列一分为p(p=2,3,5,7)p(p=2,3,5,7)，合并时的式子需要重新推导。 
不妨设是将pp个长度为nn的式子合并成一个长度为p⋅np⋅n的式子，即利用pp组nn个点值得到pnpn个点值。 
由于分裂时将模pp意义相同的部分放在了一起，所以对于合并后的多项式 
F(x)=∑0≤i<pnaixi
F(x)=∑0≤i<pnaixi

拆分的pp个多项式分别为 
Fr(x)=∑0≤i<naip+rxi
Fr(x)=∑0≤i<naip+rxi

故有 
F(ωan+bpn)=∑0≤r<p(ωan+bpn)rFr(ωbn)
F(ωpnan+b)=∑0≤r<p(ωpnan+b)rFr(ωnb)

于是可以O(p)O(p)合并出每个点的值，而这样的分治层数是O(∑4i=1ki)=O(logn)O(∑i=14ki)=O(log⁡n)，每层的复杂度是O(pn)=O(7n)O(pn)=O(7n)，因此整体的复杂度是O(nlogn)O(nlog⁡n)。 
上述方法也可非递归实现，在分裂过程中注意每段之间互不影响，在合并过程中注意存储方式即可，笔者的做法就是迭代的做法。
再考虑解决精度问题，由同余关系的性质，可以使得每次计算相乘时的值域降低到O(n2)O(n2)，但需要将单位复根映射到模意义下的剩余系中。 
由于(n+1)(n+1)是质数，φ(n+1)=nφ(n+1)=n，所以在模(n+1)(n+1)意义下存在原根gg，使得g≡ωn(modn+1)g≡ωn(modn+1)，于是利用NTT代替FFT计算即可。 
由于模(n+1)(n+1)意义下原根的数量为φ(n)=n∏piisprime,pi|n1−1piφ(n)=n∏piisprime,pi|n1−1pi，而nn的质因子大小不超过10，所以期望检查358≈5358≈5次就可以找到原根了。

上述做法基于nn是10-smooth number，即Cooley–Tukey FFT algorithm，而对于更强性质的nn，可以使用Bluestein’s algorithm。
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 500001;
int n, m, mod, tot, p[maxn], pw[maxn], a[maxn], b[maxn];
int mod_pow(int x, int k)
{
    int ret = 1;
    for( ; k > 0; k >>= 1, x = (LL)x * x % mod)
        if(k & 1)
            ret = (LL)ret * x % mod;
    return ret;
}
void NTT(int x[maxn], int flag)
{
    static int y[maxn] = {};
    int *cur = x, *nxt = y;
    for(int i = tot - 1, delta = n / p[i]; i > 0; --i, delta /= p[i], swap(cur, nxt))
        for(int j = 0, *np = nxt; j < n; j += delta * p[i])
            for(int k = 0; k < p[i]; ++k)
                for(int l = 0, *cp = cur + j + k; l < delta; ++l, ++np, cp += p[i])
                    *np = *cp;
    for(int i = 0, clen = 1, nlen = p[i]; i < tot; ++i, clen = nlen, nlen *= p[i], swap(cur, nxt))
        for(int j = 0, k = 0, ww = 1, delta = 0; j < n; ++j, k = k + 1 < clen ? k + 1 : 0, ww = (LL)ww * pw[i] % mod, delta = delta + nlen > j ? delta : delta + nlen)
        {
            nxt[j] = 0;
            for(int t = 0, www = 1; t < nlen; t += clen, www = (LL)www * ww % mod)
                nxt[j] = (nxt[j] + (LL)www * cur[delta + t + k]) % mod;
        }
    if(flag == -1)
    {
        reverse(cur + 1, cur + n);
        for(int i = 0; i < n; ++i)
            cur[i] = (LL)cur[i] * n % mod; 
    }
    if(cur != x)
        memcpy(x, cur, n * sizeof(int));
}
int main()
{
    int tmp;
    scanf("%d%d", &n, &m);
    mod = n + 1;
    tmp = n;
    m = (m - 1) % n + 1;
    for(int i = 2; i * i <= tmp; ++i)
        for( ; tmp % i == 0; tmp /= i, p[tot++] = i);
    if(tmp > 1)
        p[tot++] = tmp;
    for(int ori = 2; ; ++ori)
    {
        bool flag = 1;
        for(int i = 0; i < tot && flag; ++i)
            if(!i || p[i - 1] != p[i])
                flag &= mod_pow(ori, n / p[i]) != 1;
        if(flag)
        {
            pw[tot - 1] = ori;
            for(int i = tot - 2; i >= 0; --i)
                pw[i] = mod_pow(pw[i + 1], p[i + 1]);
            break;
        }
    }
    for(int i = 0; i < n; ++i)
        scanf("%d", a + i);
    NTT(a, 1);
    for(int i = 0; i < n; ++i)
        scanf("%d", b + i);
    NTT(b, 1);
    for(int i = 0; i < n; ++i)
        a[i] = (LL)a[i] * mod_pow(b[i], m) % mod;
    NTT(a, -1);
    for(int i = 0; i < n; ++i)
        printf("%d\n", a[i]);
    return 0;
}
```

---

## 作者：MaxBlazeResFire (赞：0)

已知长度为 $n$ 的序列 $a$，对其作长度为 $n$ 的 $\rm DFT$ 后得到的数列 $A$ 满足

$\displaystyle A_i=\sum_{j=0}^{n-1}a_j\omega_n^{ij}$.

已知长度为 $n$ 的序列 $A$，对其作长度为 $n$ 的 $\rm IDFT$ 后得到的数列 $a$ 满足

$\displaystyle a_i=\frac{1}{n}\sum_{j=0}^{n-1}A_j\omega_n^{-ij}$.

将 $\rm DFT(x)$ 与 $\rm IDFT(x)$ 看作输入长度为 $n$ 的数列并输出长度为 $n$ 的数列的运算，则它们互为逆运算。证明如下：

$\displaystyle a_i=\frac{1}{n}\sum_{j=0}^{n-1}A_j\omega_n^{-ij}=\frac{1}{n}\sum_{j=0}^{n-1}\sum_{k=0}^{n-1}a_k\omega_n^{j(k-i)}$

$\displaystyle=\sum_{k=0}^{n-1}a_k\frac{1}{n}\sum_{j=0}^{n-1}\omega_n^{j(k-i)}=\sum_{k=0}^{n-1}a_k[n|(k-i)]$

$\displaystyle=\sum_{k=0}^{n-1}a_k[k\bmod n=i]$.

我们发现，由于 $k<n$，故仅当 $k=i$ 时成立。

具体实现的时候，**我们会把 $a$ 与 $b$ 的高次项补齐到 $2n$ 再做 $\rm DFT$**，具体来说我们令 $a_j,b_j(j\in[n,2n-1])=0$，然后求得：

$\displaystyle A_i=\sum_{j=0}^{2n-1}a_j\omega_{2n}^{ij},B_i=\sum_{k=0}^{2n-1}b_k\omega_{2n}^{ik}$.

乘起来之后

$\displaystyle C_i=\sum_{j=0}^{2n-1}a_j\omega_{2n}^{ij}\sum_{k=0}^{2n-1}b_k\omega_{2n}^{ik}=\sum_{t=0}^{2n-1}\omega_{2n}^{it}\sum_{j+k=t}a_jb_k$.

然后对 $C$ 做 $\rm IDFT$ 有

$\displaystyle c_i=\frac{1}{2n}\sum_{t=0}^{2n-1}\omega_{2n}^{-it}\sum_{r=0}^{2n-1}\omega_{2n}^{tr}\sum_{j+k=r}a_jb_k=\sum_{r=0}^{2n-1}\sum_{j+k=r}a_jb_k\frac{1}{2n}\sum_{t=0}^{2n-1}\omega_{2n}^{t(r-i)}$

$\displaystyle=\sum_{r=0}^{2n-1}\sum_{j+k=r}a_jb_k[r\bmod 2n=i]$.

$\displaystyle=\sum_{j+k=i}a_jb_k$.

也即我们实现的，$c=\rm IDFT(\rm DFT(a)\times \rm DFT(b))$.

我们为什么要在一开始把高次项补齐？如果不补齐的话推导下来就会出现这样一种情况：

$\displaystyle A_i=\sum_{j=0}^{n-1}a_j\omega_n^{ij},B_i=\sum_{k=0}^{n-1}b_k\omega_n^{ik}$.

$\displaystyle C_i=\sum_{j=0}^{n-1}a_j\omega_{n}^{ij}\sum_{k=0}^{n-1}b_k\omega_{n}^{ik}=\sum_{t=0}^{n-1}\omega_{n}^{it}\sum_{(j+k)\bmod n=t}a_jb_k$.

$\displaystyle c_i=\frac{1}{n}\sum_{t=0}^{n-1}\omega_{n}^{-it}\sum_{r=0}^{n-1}\omega_{n}^{tr}\sum_{(j+k)\bmod n=r}a_jb_k=\sum_{r=0}^{n-1}\sum_{(j+k)\bmod n=r}a_jb_k\frac{1}{n}\sum_{t=0}^{n-1}\omega_{n}^{t(r-i)}$

$\displaystyle=\sum_{r=0}^{n-1}\sum_{(j+k)\bmod n=r}a_jb_k[r\bmod n=i]$.

$\displaystyle=\sum_{(j+k)\bmod n=i}a_jb_k$.

**我们得到了循环卷积的答案**。

实际上你会发现，第一遍推导中，其实 $j+k$ 的范围达到了 $4n-2$，但是并没有写 $(j+k)\bmod 2n=t$ 这种限制。因为 $a$,$b$ 高次项都为 $0$，就被忽略掉了。

但是在第二遍推导之中，是忽略不掉的。于是我们得到了这样一个结论：

**$\rm DFT$ 后对序列做逐项相乘后 $\rm IDFT$，是等同于对原序列做循环卷积的。**

没错，$\rm FFT$ 的本质是求解 **循环卷积**。**在做线性卷积的时候，我们需要补高次项正是为了延长循环卷积的周期使得低位的结果不被高位的结果影响**；

真正要做循环卷积的时候，其实反而更加直接；但代价是 **我们失去了 $n=2^k$ 这个性质**，而且这个时候如果补高次位就会出正确性的问题。

由于 $\rm DFT$ 本质上就是求 $\omega_n^1$ 的若干次方的点值，在这一点上与 $\rm Chirp-Z$ 变换也即 $\rm Bluestein's\ Algorithm$ 相同。于是就可以和平解决了。

那么本题的解决流程就非常简单了，我们考虑先求出 $n+1$ 的原根 $g$，然后对 $A$ 与 $B$ 跑底数为 $g$，长度为 $n$ 的 $\rm DFT$，将 $B$ 的每个点值 $C$ 次幂，再对位乘上 $A$ 的点值；然后对结果跑底数为 $g^{-1}$，长度为 $n$ 的 $\rm IDFT$ 即可。

然后就是卡常啦！

首先加上 $\rm DIT-DIF$ 优化，然后发现 $9$ 次 $\rm NTT$ 还是被卡 80 pts.

但是不想写拆系数 $\rm FFT$ 怎么办？观察到本题的值域 $2\times5\times 10^5\times(5\times 10^5)^2<10^{18}$，于是我们可以写一个 **二模 $\rm NTT$（也即 $6$ 次 $\rm NTT$）**，只要把三模 $\rm NTT$ 魔改一下就行。常数狂降，一遍飞过。

注：程序中选取的模数为 $998244353,2013265921$；后者的最小原根为 $31$.

复杂度 $O(n\log n)$.

```cpp
#include<bits/stdc++.h>
using namespace std;

#define MAXN 2200005
typedef vector<int> poly;

long long n,c,mod,g,ig,preg[MAXN],preig[MAXN];

inline int fp( int x , int p , int mod ){ int res = 1; while( p ){ if( p & 1 ) res = 1ll * res * x % mod; x = 1ll * x * x % mod; p >>= 1; } return res; }

inline int inv( int x , int mod ){ return fp( x , mod - 2 , mod ); }

long long mod1 = 998244353,mod2 = 2013265921;
long long inv1 = inv( mod1 , mod2 );

struct Int{
	int x,y;
	Int( int num = 0 ): x(num),y(num){}
	Int( int a , int b ): x(a),y(b){}
	inline Int reduce( Int a ){ return Int( a.x + ( ( a.x >> 31 ) & mod1 ) , a.y + ( ( a.y >> 31 ) & mod2 ) ); }
	inline Int operator +( Int a ){ return reduce( Int( x + a.x - mod1 , y + a.y - mod2 ) ); }
	inline Int operator -( Int a ){ return reduce( Int( x - a.x , y - a.y ) ); }
	inline Int operator *( Int a ){ return Int( 1ll * x * a.x % mod1 , 1ll * y * a.y % mod2 ); }
	inline long long val(){ return ( 1ll * ( 1ll * y - x + mod2 ) % mod2 * inv1 % mod2 * mod1 % mod + x ) % mod; }
};

namespace polybase{
	Int gw[MAXN],tmp[MAXN];
	inline void polypre( int T = 21 ){
		gw[0] = Int( 1 );
		gw[1 << T] = Int( fp( fp( 3 , 119 , mod1 ) , 1 << ( 21 - T ) , mod1 ) , fp( fp( 31 , 15 , mod2 ) , 1 << ( 25 - T ) , mod2 ) );
		for( int i = T ; i ; i -- ) gw[1 << ( i - 1 )] = gw[1 << i] * gw[1 << i];
		for( int i = 1 ; i < ( 1 << T ) ; i ++ ) gw[i] = gw[i & ( i - 1 )] * gw[i & -i];
	}
	inline void DIT( Int *A , int len ){
		for( int i = 0 ; i < len ; i ++ ) tmp[i] = A[i];
		for( int i = 1 ; i < len ; i <<= 1 ){
			Int *k = tmp;
			for( Int *g = gw ; k < tmp + len ; k += i << 1 , g ++ ){
				for( Int *x = k ; x < k + i ; x ++ ){
					Int o = x[i];
					x[i] = ( *x - o ) * *g,*x = *x + o;
				}
			}
		}
		Int iv( inv( len , mod1 ) , inv( len , mod2 ) );
		for( int i = 0 ; i < len ; i ++ ) A[i] = tmp[i] * iv;
		reverse( A + 1 , A + len );
	}
	inline void DIF( Int *A , int len ){
		for( int i = 0 ; i < len ; i ++ ) tmp[i] = A[i];
		for( int i = len / 2 ; i ; i >>= 1 ){
			Int *k = tmp;
			for( Int *g = gw ; k < tmp + len ; k += i << 1 , g ++ ){
				for( Int *x = k ; x < k + i ; x ++ ){
					Int o = x[i] * *g;
					x[i] = *x - o,*x = *x + o;
				}
			}
		}
		for( int i = 0 ; i < len ; i ++ ) A[i] = tmp[i];
	}
	inline poly polymul( poly A , poly B ){
		int n = A.size(),m = B.size(),L = n + m - 1,len = 1;
		while( len < L ) len <<= 1;
		static Int tA[MAXN],tB[MAXN];
		for( int i = 0 ; i < n ; i ++ ) tA[i] = Int( A[i] ); for( int i = n ; i < len ; i ++ ) tA[i] = Int( 0 );
		for( int i = 0 ; i < m ; i ++ ) tB[i] = Int( B[i] ); for( int i = m ; i < len ; i ++ ) tB[i] = Int( 0 );
		DIF( tA , len ),DIF( tB , len );
		for( int i = 0 ; i < len ; i ++ ) tA[i] = tA[i] * tB[i];
		DIT( tA , len );
		poly Ans( L );
		for( int i = 0 ; i < L ; i ++ ) Ans[i] = (int)( ( tA[i].val() + mod ) % mod );
		return Ans;
	}
	inline poly polyTmul( poly A , poly B ){
		int n = A.size();
		reverse( A.begin() , A.end() );
		B = polymul( A , B );
		for( int i = 0 ; i < n ; i ++ ) A[i] = B[i];
		reverse( A.begin() , A.end() );
		return A;
	}
	inline poly chirp_Z( poly A , int c , int type = 1 ){
		int n = A.size();
		poly C( 2 * n ),D( n ),E( n );
		for( int i = 0 ; i < 2 * n ; i ++ ) C[i] = ( type == 1 ) ? preg[i] : preig[i];
		for( int i = 0 ; i < n ; i ++ ) D[i] = ( type == 1 ) ? preig[i] : preg[i];
		for( int i = 0 ; i < n ; i ++ ) E[i] = 1ll * D[i] * A[i] % mod;
		C = polyTmul( C , E );
		for( int i = 0 ; i < n ; i ++ ) A[i] = 1ll * D[i] * C[i] % mod;
		if( type == -1 )
			for( int i = 0 , ilen = inv( n , mod ) ; i < n ; i ++ ) A[i] = 1ll * A[i] * ilen % mod;
		return A;
	}
}

using namespace polybase;

inline void getg(){
	vector<int> factor;
	int tmp = n;
	for( int i = 2 ; 1ll * i * i <= tmp ; i ++ ){
		if( tmp % i == 0 ){
			factor.emplace_back( i );
			while( tmp % i == 0 ) tmp /= i;
		}
	}
	if( tmp > 1 ) factor.emplace_back( tmp );
	for( g = 1 ; ; g ++ ){
		if( fp( g , n , mod ) == 1 ){
			bool flag = 0;
			for( int v : factor ) if( fp( g , n / v , mod ) == 1 ){ flag = 1; break; }
			if( !flag ) return;	
		}
	}
}

poly A,B;

signed main(){
	polypre();
	scanf("%lld%lld",&n,&c); mod = n + 1; c %= n;
	getg(); ig = inv( g , mod );
	for( int i = 0 ; i <= 2 * n ; i ++ ) preg[i] = fp( g , 1ll * i * ( i - 1 ) / 2 % n , mod );
	for( int i = 0 ; i <= 2 * n ; i ++ ) preig[i] = fp( ig , 1ll * i * ( i - 1 ) / 2 % n , mod );
	A.resize( n ),B.resize( n );
	for( int i = 0 ; i < n ; i ++ ) scanf("%d",&A[i]),A[i] %= mod;
	for( int i = 0 ; i < n ; i ++ ) scanf("%d",&B[i]),B[i] %= mod;
	A = chirp_Z( A , g ),B = chirp_Z( B , g );
	for( int i = 0 ; i < n ; i ++ ) B[i] = fp( B[i] , c , mod );
	for( int i = 0 ; i < n ; i ++ ) A[i] = 1ll * A[i] * B[i] % mod;
	A = chirp_Z( A , ig , -1 );
	for( int i = 0 ; i < n ; i ++ ) printf("%d\n",A[i]);
	return 0;
}
```

---


# 口袋里的纸飞机

## 题目背景

现在我来到自己的故事难以用语言描绘的中心。文字的匮乏感从现在开始体现出来，因为描绘任何事物都要以交谈者共有的认知为前提，而我所经历的是比任何生活都更上一层的体验。先贤们在向普罗大众描绘世界之外的事物时往往运用宏大的概念。中国的道学家说天有九霄。《吠陀经》提到我们生存的土地只是千万重复制中的一个。爱斯基摩人则认为万物由一枚巨卵孵化而出。一个更恰当的比喻是所谓狄拉克之海，也即是全部空间和时间的上方和外部。虽然用有限的话语不可能描述一个无限的实体，但我记住了它的一部分，或许是最重要的一部分：


我看见无限宽阔的海面和无限广袤的天穹，两者在无穷远处的地平线相接。视野的最中央站着一个紫色长发的女孩。我的身份和她不同：我是受她邀请而来的访客，海上的女孩才是这里的居民，或者说囚徒。正如我们不能随意造访世界之上的世界，她也永远不能和我们的生活有任何一点的交集。我明白自己在这里不会待上太久，而她把我招来只能为了一个理由。于是我听见了自己的声音在海面上回响，消散进虚无之中：


“我会记住你。”


她对我露出笑容。白色的光芒再一次亮起，女孩的身影好似被无形的火焰灼烧一样逐渐消散。我明白自己留不住这一刻，于是我哭了。使我哭泣的并不只是永恒的离别，还有对这个曾经在无尽的时间中陪伴过我们的孩子的怜惜和忏悔。
我感到无限崇敬，无限悲哀。


——西酱《口袋》

## 题目描述

一个大小为$n$的数列$\{a_i\}$，每个数都在范围$[1,R]$中

对于每种数列，可以生成一个$n\times n$的网格，其中格子$(i,j)$中的数为$a_i\times a_j \mod P$

比如，如果数列是$\{1,2,3\},P=5$，则生成的网格为
```
1 2 3
2 4 1
3 1 4(因为2*3%5=1,3*3%5=4)
```

对于一个网格，定义法法值为其中不同的数个数，比如上面那个就是4个数，即$\{1,2,3,4\}$。

现在你需要对所有数列的法法值的和对$10^9+7$取模

## 说明/提示

样例1解释：
```
{ai}={1,1}:
1 1
1 1
(ans=1)
{ai}={1,2}:
1 2
2 1
(ans=2)
{ai}={1,3}:
1 0
0 0
(ans=2)
{ai}={2,1}:
1 2
2 1
(ans=2)
{ai}={2,2}:
1 1
1 1
(ans=1)
{ai}={2,3}:
1 0
0 0
(ans=2)
{ai}={3,1}:
0 0
0 1
(ans=2)
{ai}={3,2}:
0 0
0 1
(ans=2)
{ai}={3,3}:
0 0
0 0
(ans=1)
一共为15
```


保证$P$为大于等于3的质数

|测试点|N|R|P|
|---|---|---|---|
|1,2|$N\leq 5$|$R\leq 5$|$R\times R<P\leq 20$|
|3,4,5,6|$N\leq 15$|$R\leq 10$|$R\times R<P\leq 200$|
|7,8|$N\leq 30$| |$R\times R<P\leq 500$|
|9,10,11,12|$N\leq 100$| |$R\times R<P\leq 500$|
|13,14,15,16|$N\leq 300$|$R\leq 10^9$|$P\leq 1000$|
|17,18,19,20|$N\leq 500$|$R\leq 10^9$|$P\leq 5000$|

对于所有数据，$n\leq 500,P\leq 5000,R\leq 10^9$

## 样例 #1

### 输入

```
2 3 3```

### 输出

```
15```

## 样例 #2

### 输入

```
4 7 5```

### 输出

```
2845```

## 样例 #3

### 输入

```
70 43 22```

### 输出

```
992103136```

## 样例 #4

### 输入

```
500 2011 999980895```

### 输出

```
767094932```

# 题解

## 作者：NaCly_Fish (赞：17)

给出一个理论时间复杂度 $\Theta(P \log P+n\log n)$ 的算法，但是常数可能比较大。
****
前面的做法和官方题解是一致的，我们可以枚举 $r$，计算有多少个序列会生成 $r$。

设 $s_i$ 表示 $[1,R]$ 范围内的整数中，有多少个和 $i$ 在模 $P$ 下同余。由于 $s_i$ 只有两种取值，我们设较小的为 $L$（较大的就是 $L+1$）。然后统计出三个数组（其中 $1\leq i < j <P$）：

- $A_r$：表示 $ij \equiv r \pmod P$，且 $s_i=s_j=L$ 的有序数对数量。

- $B_r$：表示 $ij \equiv r \pmod P$，且 $|s_i-s_j|=1$ 的有序数对数量。

- $C_r$：表示 $ij \equiv r \pmod P$，且 $s_i = s_j=L+1$  的有序数对数量。

对于 $r\neq 0$，能够生成 $r$ 的序列数量就是

$$R^n-n![x^n](2\text e^{Lx}-1)^{A_r}(\text e^{Lx}+\text e^{(L+1)x}-1)^{B_r}(2\text e^{(L+1)x}-1)^{C_r}\text e^{Lx}$$
而 $r=0$ 很简单，数量就是 $R^n-(R-L)^n$。

每次暴力地 $\Theta(n^2)$ 计算，然后开个 map 存一下答案就可以通过这题了。
****
官方题解用到了一个猜想：本质不同的 $(A_r,B_r,C_r)$ 的数量是 $\mathcal O(\sqrt P)$ 级别的。我也没能将其证明或证伪，不过通过另一种思路，可以做到更优的时间复杂度。

我们设 $A_r'$ 和 $C_r'$ 分别是 $i$ 和 $j$ **不限制大小关系的情况下**，按原规则统计的数量，我们将说明：

>  由 $A_r'$ 就可以唯一确定出 $B_r$ 和 $C_r'$。

首先有一个显然的关系：$A_r'+2B_r+C_r'=P-1$；  
然后还有一个是：$A_r'+B_r=|S|$，其中 $S=\{i \mid s_i=L \ , \ 1\leq i <P \}$。

其中第二个式子中左侧的意义是：选的 $i$ 需要 $s_i=L$，而 $j$ 没有限制。显然对于每个 $i$，都存在一个 $j$ 使得 $ij\equiv r \pmod P$，所以总数就是等式右侧了。

然后如何得到真正的 $A_r$ 呢？$A_r'$ 减去 $i^2\equiv r \pmod P$ 且 $s_i=L$ 的解的个数就是 $2A_r$，由此也直接得到 $ A_r'-2A_r\leq 2$。对于 $C_r$ 的计算也是一样的。

至此，聪明的你能想到接下来该怎么做吗？

****

我们设：

$$F(i,j,k)=n![x^n](2\text e^{Lx}-1)^{(k-i)/2}(\text e^{Lx}+\text e^{(L+1)x}-1)^{|S|-k}(2\text e^{(L+1)x}-1)^{(P-1-2|S|+k-j)/2}\text e^{Lx}$$

其中 $i,j \in \{ 0,1,2\}$。对于每组 $i,j$ 我们都能以 $\Theta(P \log P+n \log n)$ 的时间复杂度计算出所有 $F(i,j,k) \ (0\leq k< P)$，因为这是[经典问题](https://www.luogu.com.cn/article/c65fzqbm)。

这样对于每个 $r$，能生成 $r$ 的序列数量就是 $R^n-F(A_r'-2A_r,C_r'-2C_r,A_r')$。

最后我们还要快速算出所有 $A_r'$，这个做法也在 [\[SDOI2015\] 序列统计](https://www.luogu.com.cn/problem/P3321) 中出现过了。我们只需要把所有 $s_i=L$ 的 $i$ 取离散对数，然后计算一次卷积即可。

****

update：我们实际上并不需要对每组 $(i,j)$ 都计算，因为可能出现的 $(i,j)$ 只有 $(0,0),(0,2),(1,1),(2,0)$ 四种，由此也可以保证计算幂级数的乘方时，指数必定是整数，实现上会方便一些。

---

## 作者：ComeIntoPower (赞：17)


大家好我系出题人（还有个背锅侠mcfx）

题目背景是summer pockets!

对于测试点1,2，使用$O(R^N\times N^2)$的算法即可通过

对于测试点3,4,5,6，可以发现只需要枚举排序后的数列即可。然后使用一些组合数学计算答案。这样复杂度就变得可以接受。大约只有$10^6$种不同的数列

----------------------------

裸暴力的部分已经结束。现在我们来讲正解。考虑对每个数分开算贡献，即对于$x\in[0,P-1]$，算有$x$出现的网格数。

考虑补集转化一下，即算没有$x$出现的网格数。

$x=0$可以特判，即如果没有$P$的倍数出现则不会出现$0$

现在只考虑$x\in[1,P-1]$。没有$x$出现，相当于有若干对$(s,t)(st\mod P=x)$不能同时出现在数列里。由于$P$是质数，所以这样的有序对一定只有$(P-1)$对。

比如$P=5,x=1$，就有如下对：$(1,1),(2,3),(3,2),(4,4)$

这时，你发现除去$s=t$的，就相当于若干个互不干涉的限制：$s$和$t$不能同时出现。$s=t$的情况就是这个数本身不能出现。这意味着这些限制可以单独考虑方案，然后再全都做卷积

你又发现$R\leq 10^9$。这实在是太大了！不过你可以把余数相同的视为一体，假设这个余数出现了$A$次，就相当于如果选这个余数，就有$A$种方法。

可以发现所有余数的出现次数只有$A$和$A+1$这两种。所以刚才那些限制可以变成：

a0种(A,A)(即s,t都出现了A次),a1种(A,A+1),a2种(A+1,A),a3种(A+1,A+1)

所以，用指数生成函数表示，限制(A,A)的指数生成函数为$e^{Ax}e^{Ax}-(e^{Ax}-1)(e^{Ax}-1)=e^{Ax}+e^{Ax}-1$

答案的指数生成函数为$(e^{Ax}+e^{Ax}-1)^{a0} (e^{Ax}+e^{(A+1)x}-1)^{a1+a2} (e^{(A+1)x}+e^{(A+1)x}-1)^{a3} e^{(R/P)x}$（最后那个是考虑$0$的情况）

这已经可以快速计算，复杂度为$O(n^2P+P^2)$（$P^2$是处理a0,a1,a2,a3）

打表可以发现，本质不同的$(a0,a1,a2,a3)$只有$O(\sqrt{P})$种！这不好证明，但是在数据范围下是成立的。（mcfx：可以把这个序列当做是随机的，感性理解一下）

$O(n^2\sqrt{P}+P^2)$和$O(n^2\sqrt{P}\log P+P^2)$均可通过该题。

来自出题人的辣鸡标程（该标程可以大幅优化，但是懒得写了）

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define maxP 5010
#define maxn 5010
using namespace std;
const int mod=1e9+7;
struct data{
    int a,b,c;
    data(){}
    data(int a,int b,int c):a(a),b(b),c(c){}
    bool operator<(const data& d)const{
        if(a!=d.a)return a<d.a;
        if(b!=d.b)return b<d.b;
        return c<d.c;
    }
};
map<data,int>st;
int sP,tg[maxP];
int ans,n,P,R,fac[maxn],inv[maxn],cnt[maxP][2];
int f[maxn],g[maxn],A,lim,tmp[maxn],dp0[250][maxn],dp1[250][maxn],dp2[250][maxn];
int sdp0[250][maxn],sdp1[250][maxn],sdp2[250][maxn];
void mul(int a[],int b[],int c[]){
    for(int i=0;i<=n;++i)tmp[i]=0;
    for(int i=0;i<=n;++i)
        for(int j=0;i+j<=n;++j)
            tmp[i+j]=(tmp[i+j]+1ll*a[i]*b[j])%mod;
    for(int i=0;i<=n;++i)c[i]=tmp[i];
}
int qpow(int a,int b){
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%mod)
        if(b&1)ans=1ll*ans*a%mod;
    return ans;
}
int C(int x,int y){
    if(y<0||x<y)return 0;
    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;
}
void cp(int fr[],int to[]){
    for(int i=0;i<=n;++i)to[i]=fr[i];
}
void get(int dp[250][maxn],int sdp[250][maxn],int a,int g[]){
    cp(dp[a%sP],g);
    mul(sdp[a/sP],g,g);
}
void init(int dp[250][maxn],int sdp[250][maxn]){
    dp[0][0]=sdp[0][0]=1;
    for(int i=2;i<=sP;++i)mul(dp[i-1],dp[1],dp[i]);
    cp(dp[sP],sdp[1]);
    for(int i=2;i<=sP;++i)mul(sdp[i-1],sdp[1],sdp[i]);
}
int main(){
    scanf("%d%d%d",&n,&P,&R);
//	fprintf(stderr,"[R%P=%d]",R%P);
    fac[0]=inv[0]=1;
    for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%mod;
    inv[n]=qpow(fac[n],mod-2);
    for(int i=n-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    A=R/P,lim=R%P;
    for(int i=1;i<P;++i)
        for(int j=i+1;j<P;++j){
//			if(i*j%P!=2)continue;
            if(i>lim&&j>lim)cnt[i*j%P][0]++; // 0: A
            else if(i<=lim&&j<=lim)cnt[i*j%P][1]++; //1:A+1
        }
    for(int i=1;i<P;++i)tg[i*i%P]++;
    
    for(int i=1;i<P;++i)
//		if(i==2)
            st[data(cnt[i][0],cnt[i][1],tg[i])]++;
    sP=sqrt(P);
    for(int i=0;i<=n;++i)dp0[1][i]=2ll*qpow(A,i)*inv[i]%mod;
    dp0[1][0]--,init(dp0,sdp0);
    
    for(int i=0;i<=n;++i)dp1[1][i]=1ll*(qpow(A,i)+qpow(A+1,i))*inv[i]%mod;
    dp1[1][0]--,init(dp1,sdp1);
    
    for(int i=0;i<=n;++i)dp2[1][i]=2ll*qpow(A+1,i)*inv[i]%mod;
    dp2[1][0]--,init(dp2,sdp2);
    
    
    for(map<data,int>::iterator it=st.begin();it!=st.end();++it){
        int a0=it->first.a,a3=it->first.b,tg=it->first.c;
        for(int i=0;i<=n;++i)f[i]=g[i]=0;
        f[0]=1;
        get(dp0,sdp0,a0,g),mul(f,g,f);
        get(dp1,sdp1,(P-1-tg)/2-a0-a3,g),mul(f,g,f);
        get(dp2,sdp2,a3,g),mul(f,g,f);
        for(int i=0;i<=n;++i)g[i]=1ll*inv[i]*qpow(A,i)%mod;
        mul(f,g,f);
        ans=(ans-1ll*it->second*(f[n]))%mod;
    }
    ans=(1ll*fac[n]*ans+1ll*P*qpow(R,n)-qpow(R-A,n))%mod;
    ans=(ans%mod+mod)%mod;
    printf("%d",ans);
}
```

---

## 作者：PhantasmDragon (赞：3)

出题人的毒瘤生成函数没看懂,提供另一种方法qwq

如果想通过枚举每个矩阵,算出它的法法值来做的话,只能通过暴力分,无法进行进一步优化.

那么可以考虑每一个数字 $x$ 在多少矩阵里出现过,分开算贡献.
但是发现,这样的贡献仍然不好算,那正难则反,算出它没有在哪些矩阵中出现过.

那么对于一个 $x$, $1\leq x\leq P$ , 如果它不能出现,那么肯定会出现一些二元组 $(A_i,B_i)$ 使得 $A_i*B_i\%P=x$, 所以 $(A_i,B_i)$ 这两个数字之间就只能选一个, 否则就会出现 $x$.

特别的,当 $A_i=B_i$, 这个数字本身就不能选.

因为 $R$ 特别大,所以这样的二元组会有很多个, 无法处理. 容易发现 $A_i,A_i+P,A_i+2*P$ 是完全等价的, 所以我们完全可以把在模 $P$ 意义下相等的数字分到一类去. 

因为 $P$ 是质数, 所以对于 $\forall x \in [1,P-1]$, 这些二元组之间两两没有交. 

先特判一下 $0$, 只要选择了 $P$ 的倍数就一定会出现 $0$, 直接减去就行了.

那我们就可以开始 DP 了. 对于每个 $x$, 我们处理出它的所有二元组, 设状态 $f_{i,j}$ 表示考虑了前 $i$ 个二元组,放了 $j$ 个数字的方案数. 那么:
$$f_{i,j}*(cnt_{A_{i+1}}^t+cnt_{B_{i+1}}^t)*C_{j+t}^t \to f_{i+1,j+t}$$

$cnt_x$ 表示 $x$ 这一类数一共有多少个.

意义就是从 $A_{i+1}$ 或 $B_{i+1}$ 中有序地选出 $t$ 个数, 再插入到当前的 $j$ 个数当中去.
这样的时间复杂度是 $O(P^2n^2)$的.

不难发现,每种等价类的 $cnt$ 只可能是 $\lfloor \frac{R}{P} \rfloor$ 或 $\lfloor \frac{R}{P} \rfloor +1$, 所以本质不同的二元组只会有3种, 也就是 $(\lfloor \frac{R}{P} \rfloor,\lfloor \frac{R}{P} \rfloor),(\lfloor \frac{R}{P} \rfloor \lfloor \frac{R}{P} \rfloor+1),(\lfloor \frac{R}{P} \rfloor+1 \lfloor \frac{R}{P} \rfloor+1)$

那么就可以分开讨论了.把这三种二元组编号为 $0,1,2$, 给 $f$ 数组新开一维变成 $f_{0/1/2,i,j}$ 表示考虑了 $i$ 个 $0/1/2$ 类二元组,且放入了 $j$ 个数的方案数.

先预处理出这个数组, 然后对于每个 $x \in [1,P-1]$ , 处理出它有多少个 $0/1/2$ 类二元组, 然后合并一下就好了.
这样复杂度是 $O(Pn^2)$

再考虑分块乱搞. 对于 $f_{0/1/2,i,j}$ 我们只处理出 $i\leq \sqrt{P}$ 的所有 $f$ 值, 再开一个数组 $g_{0/1/2,i,j}$ 表示考虑了 $i*\sqrt{P}$ 个 $0/1/2$ 类二元组, 放了 $j$ 个数字的方案数. 对于 $g$ ,我们仍然只用处理出 $i \leq \sqrt{P}$ 的所有值.

我们现在就可以利用 $f$ 和 $g$ ,在 $O(n^2)$ 内卷出考虑任意个二元组的 $dp$ 数组.

对于这里的 "卷积" 和上面 $g$ 数组的预处理, 实际上还是新插入有序的 $t$ 个数.所以跟dp的时候没有什么差别.
大概长这样:
```
void MergeDp(int id,int cc)
{
	int vF=cc%lim,vG=cc/lim;
	for(int i=0;i<=n;++i)
		for(int j=0;j+i<=n;++j)
			inc(dp[id][i+j],mul(G[id][vG][i],mul(F[id][vF][j],C[i+j][j])));
            //C是组合数
}
```

最后还有一个神仙结论. 对于所有 $x\in [1,P-1]$, 三种二元组个数有差别的 $x$ 不会超过 $\sqrt{P}$ 个. 所以记忆化一下就好了. (证明?不会)

----------
贴上常数极大的代码:
```
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<map>
#define mod 1000000007
using namespace std;
inline int add(int a,int b){a+=b; return a>=mod?a-mod:a;}
inline void inc(int &a,int b){a=add(a,b);}
inline int mul(int a,int b){return 1ll*a*b%mod;}
int ksm(int a,int b)
{
	int s=1;
	for(;b;b>>=1,a=mul(a,a))
		if(b&1) s=mul(s,a);
	return s;
}
int ksm_P(int a,int b,int p)
{
	int s=1;
	for(;b;b>>=1,a=1ll*a*a%p)
		if(b&1) s=1ll*s*a%p;
	return s;
}
int C[512][512],F[3][128][512],G[3][128][512],inv[5005],n,P,R,lim;
int pw[505],pw1[505];
void Pre()
{
	for(int i=0;i<=500;++i)
	{
		C[i][0]=1;
		for(int j=1;j<=i;++j)
			C[i][j]=add(C[i-1][j-1],C[i-1][j]);
	}
	int cnt=R/P; lim=sqrt(P);
	F[0][0][0]=F[1][0][0]=F[2][0][0]=1;
	G[0][0][0]=G[1][0][0]=G[2][0][0]=1;
	for(int i=0;i<=n;++i) pw[i]=ksm(cnt,i),pw1[i]=ksm(cnt+1,i);
	pw[0]=pw1[0]=(mod+1)/2;
	for(int i=0;i<lim;++i)
	{
		for(int j=0;j<=n;++j)
		{
			for(int t=0;t+j<=n;++t)
			{
				inc(F[0][i+1][j+t],mul(F[0][i][j],mul(add(pw[t],pw[t]),C[j+t][t])));
				inc(F[1][i+1][j+t],mul(F[1][i][j],mul(add(pw1[t],pw[t]),C[j+t][t])));
				inc(F[2][i+1][j+t],mul(F[2][i][j],mul(add(pw1[t],pw1[t]),C[j+t][t])));
			}
		}
	}
	pw[0]=pw1[0]=1;
	for(int i=0;i<lim;++i)
	{
		for(int j=0;j<=n;++j)
		{
			for(int t=0;t+j<=n;++t)
			{
				inc(G[0][i+1][j+t],mul(G[0][i][j],mul(F[0][lim][t],C[j+t][t])));
				inc(G[1][i+1][j+t],mul(G[1][i][j],mul(F[1][lim][t],C[j+t][t])));
				inc(G[2][i+1][j+t],mul(G[2][i][j],mul(F[2][lim][t],C[j+t][t])));
			}
		}
	}
	for(int i=1;i<=P;++i) inv[i]=ksm_P(i,P-2,P);
}
int ans=0;
struct node
{
	int c0,c1,c2;
	bool operator <(node rhs) const
	{
		return c0==rhs.c0?c1==rhs.c1?c2<rhs.c2:c1<rhs.c1:c0<rhs.c0;
	}
};
int dp[3][505],las[505];
void MergeDp(int id,int cc)
{
	int vF=cc%lim,vG=cc/lim;
	for(int i=0;i<=n;++i)
		for(int j=0;j+i<=n;++j)
			inc(dp[id][i+j],mul(G[id][vG][i],mul(F[id][vF][j],C[i+j][j])));
}
void GetLas()
{
	int tmp[505]={0};
	memset(las,0,sizeof(las));
	for(int i=0;i<=n;++i)
		for(int j=0;j+i<=n;++j)
			inc(las[i+j],mul(dp[0][i],mul(dp[1][j],C[i+j][j])));
	memcpy(tmp,las,sizeof(tmp));
	memset(las,0,sizeof(las));
	for(int i=0;i<=n;++i)
		for(int j=0;j+i<=n;++j)
			inc(las[i+j],mul(tmp[i],mul(dp[2][j],C[i+j][j])));
	memcpy(tmp,las,sizeof(tmp));
	memset(las,0,sizeof(las));
	for(int i=0;i<=n;++i)
		for(int j=0;j+i<=n;++j)
			inc(las[i+j],mul(tmp[i],mul(pw[j],C[i+j][j])));
}
map<node,int> mem;
void Solve(int x)
{
	if(!x) return (void)inc(ans,add(ksm(R,n),mod-ksm(R-(R/P),n)));	
	int t0=0,t1=0,t2=0,vis[5005]={0};
	for(int i=1,j,cc;i<P;++i)
	{
		j=1ll*x*inv[i]%P;
		if(vis[i]||vis[j]) continue;
		vis[i]=vis[j]=1;
		if(i==j) continue;
		cc=((R-i)/P+(R>=i)==R/P)+((R-j)/P+(R>=j)==R/P);
		if(cc==2) t0++;
		else if(cc==1) t1++;
		else t2++;
	}
	if(mem[(node){t0,t1,t2}])
		return (void)(inc(ans,add(ksm(R,n),mod-mem[(node){t0,t1,t2}])));
	memset(dp,0,sizeof(dp));
	MergeDp(0,t0),MergeDp(1,t1),MergeDp(2,t2),GetLas();
	inc(ans,add(ksm(R,n),mod-(mem[(node){t0,t1,t2}]=las[n])));
}
int main()
{
	scanf("%d%d%d",&n,&P,&R),Pre();
	for(int x=0;x<P;x++)
		Solve(x);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：TianTian2008 (赞：2)

考虑对每个 $v\in[0,p)$ 求出其出现次数，答案即为出现次数总和。发现 $v$ 的出现次数不是很好求，于是容斥一下，求有多少个序列构造出的矩阵中没有出现 $v$。

首先，显然 $a_i$ 全部对 $p$ 取模不影响构造出的矩阵，所以我们不妨假定 $a_i\in[0,p)$。那么对于每个值 $x\in[0,p)$，当且仅当其和 $v\times x^{-1}\bmod p$ 同时存在于 $a$ 之中，构造出的矩阵中存在 $v$。同时，由于 $p$ 是质数，所以我们知道除 $x=0,\pm\sqrt v$ 等特殊情况，$(x,v\times x^{-1}\bmod p)$ 必然是若干对互不重叠的数对。

此时，我们的问题转换成有若干互不重叠的数对，求有多少序列 $a$ 中不同时存在一个数对中的两个数。这是个有标号计数问题，可以用 $\text{EGF}$ 解决。

具体地，考虑每一对数 $(x,y)$，可以两个都不选（$\text{EGF}=1$），可以只选 $x$（$\text{EGF}=\sum\limits_{i=1}^\infty\frac{t_x^i}{i!}x^i$，其中 $t_x=\lfloor\frac rp\rfloor+[x\le r\bmod p]$ 即 $[1,r]$ 中有多少个数模 $p$ 等于 $x$），可以只选 $y$（$\text{EGF}$ 和只选 $x$ 同理），这一个数对的 $\text{EGF}$ 即上述三个相加，最终答案即每个数对的 $\text{EGF}$ 的乘积的 $n$ 次项系数。

由于一些特殊原因（模数是 $10^9+7$ 而且多项式项数很少），所以我们直接用暴力卷积来实现多项式乘法，两个多项式相乘的时间复杂度为 $O(n^2)$，对每个 $v\in[0,p)$ 都要求 $\frac p2$ 个数对的 $\text{EGF}$ 的乘积，所以总时间复杂度为 $O(p^2n^2)$，显然不可接受。

考虑如何优化，不难发现 $t_x$ 总共只有两个取值，所以 $(t_x,t_y)$ 也只有三种本质不同的情况，即每个数对的 $\text{EGF}$ 只有三种。我们可以对每一种都预处理出它的幂，时间复杂度为 $O(pn^2)$。对每个 $v$ 求答案时只需求三种 $\text{EGF}$ 各自的出现次数，然后直接用预处理的幂相乘即可，总时间复杂度也为 $O(pn^2)$。

这个时间复杂度好像不是正解？但是开了 3s，我觉得这个能过挺合理吧。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define mod 1000000007
using namespace std;
typedef long long ll;
typedef __int128 bint;
ll n,p,r,q,l,fac[501],ifc[501],inv[5000],s[501],f[501];
bool vis[5000]; 
struct poly {
	ll f[5000][501];
	void init(ll u,ll v) {
		f[0][0]=f[1][0]=1;
		ll x=1,y=1;
		for(int i=1;i<=n;++i) {
			x=x*u%mod;
			y=y*v%mod;
			f[1][i]=(x+y)*ifc[i]%mod;
		}
		ll lim=p>>1,*f1=f[1];
		for(int i=2;i<=lim;++i) {
			ll *f2=f[i-1];
			for(int j=0;j<=n;++j) {
				bint sum=0;
				for(int k=0;k<=j;++k) sum+=f1[k]*f2[j-k];
				f[i][j]=sum%mod;
			}
		}
	}
}pw[3];
ll ksm(ll x,ll y) {
	ll res=1;
	while(y) {
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
ll calc(ll v) {
	memset(vis,false,sizeof(vis));
	memcpy(f,s,sizeof(f)); 
	ll tn[3]={0,0,0};
	for(int i=1;i<p;++i) {
		if(vis[i]) continue;
		ll j=v*inv[i]%p;
		if(i==j) continue;
		vis[j]=true;
		++tn[(i<=l)+(j<=l)];
	}
	for(int i=0;i<3;++i) {
		if(!tn[i]) continue;
		ll *g=pw[i].f[tn[i]];
		for(int j=n;j>=0;--j) {
			bint sum=0;
			for(int k=0;k<=j;++k) sum+=f[k]*g[j-k];
			f[j]=sum%mod;
		}
	}
	return fac[n]*f[n]%mod;
} 
int main() {
	scanf("%lld%lld%lld",&n,&p,&r);
	q=r/p;l=r%p;
	fac[0]=1;
	for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
	ifc[n]=ksm(fac[n],mod-2);
	for(int i=n;i>=1;--i) ifc[i-1]=ifc[i]*i%mod;
	inv[1]=1;
	for(int i=2;i<p;++i) inv[i]=(p-p/i*inv[p%i]%p)%p;
	pw[0].init(q,q);
	if(l) {
		pw[1].init(q,q+1);
		pw[2].init(q+1,q+1);
	}
	ll x=1;
	for(int i=0;i<=n;++i) {
		s[i]=x*ifc[i]%mod;
		x=x*q%mod;
	}
	ll ans=(ksm(r,n)*p-ksm(r-q,n))%mod;
	for(int i=1;i<p;++i) ans=(ans-calc(i))%mod;
	printf("%lld",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：Petit_Souris (赞：0)

枚举 $i$，计算有多少个序列可以生成 $i$。$i=0$ 时特判，其他情况下容易发现逆元两两配对，所以可以补集转化一下，计算不能生成 $i$ 的序列数量，形如计数“有若干个 pair，每个 pair 对应的余数不能同时选”的方案数。容易列出一个形如 $(2e^c-1)^A(e^c+e^{c+1}-1)^B(2e^{c+1}-1)^Ce^D$ 的 EGF，欲求其 $[x^n]$ 次项。

直接暴力展开可以做到 $\mathcal O(Pn^2)$。一个重要的性质是，本质不同的 $(A,B,C)$ 三元组只有 $\mathcal O(\sqrt P)$ 个（$D$ 是定值，等于 $P$ 的倍数个数），那么相当于只需要 $\mathcal O(\sqrt P)$ 次单点查询多项式幂。可以类比光速幂处理，每 $\sqrt P$ 个点分一块，以 $\mathcal O(n^2\sqrt P)$ 的复杂度预处理，这样单次查询可以 $\mathcal O(n^2)$ 得到所需多项式，暴力卷积就是 $\mathcal O(n^2\sqrt P)$ 的了，可以通过。

不过似乎 $\mathcal O(Pn^2)$ 常数小点也能过？比较不牛。

---


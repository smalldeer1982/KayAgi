# 「GLR-R4」夏至

## 题目背景

&emsp;&emsp;「柳庭风静人眠昼，昼眠人静风庭柳」

---

&emsp;&emsp;老 V 说为大家准备了特别的粽子，所以天依来了；

&emsp;&emsp;天依来了，所以阿绫来了；

&emsp;&emsp;阿绫来了，龙牙也不敢不来；

&emsp;&emsp;到了快一半了，于是剩下的大家都来了……

&emsp;&emsp;所以，为什么要在模拟演出训练结束后来补文化课啊！

&emsp;&emsp;“天依，这数学老师真的在讲数学？”

&emsp;&emsp;“摩柯，我和阿绫就靠你了！”天依戳戳前排摩柯的肩膀。

&emsp;&emsp;“要推出来了，要推出来了……”，摩柯大概是第一次把草稿纸写得快满，“我知道我很急，但我先别急……这像是在做噩梦一样。”

---

&emsp;&emsp;**夏至**&emsp;「允许我这一次片刻逃离　偶尔也试着用背影　去面对未来不确定」

## 题目描述

&emsp;&emsp;为了鉴定摩柯是不是在做噩梦，请你来解决黑板上的一道简单的数学问题吧！

&emsp;&emsp;令积性函数 $f(n)$ 满足 $f(p^c)=p^{\gcd(c,k)}$，其中 $k$ 为给定常数，$p$ 为素数，$c$ 为正整数。现在，给定 $n,m,k$，请求出
$$
\left(\sum_{i=1}^n\sum_{j=1}^mf(i\cdot j)\right)\bmod(10^9+7).
$$

&emsp;&emsp;对于积性函数的定义，请参考「题意解释」。


## 说明/提示

#### 题意解释

&emsp;&emsp;对于数论函数 $f(n)$ 和任意两个互素的正整数 $x,y$，若恒有 $f(xy)=f(x)f(y)$，则称 $f(n)$ 为积性函数。

&emsp;&emsp;当已知积性函数 $f(n)$ 在所有素数幂处的取值时，我们可以计算任意正整数的函数值。具体地，对于 $n>1$，设 $n$ 的**唯一分解**形式为 $n=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$，则有 $f(n)=f(p_1^{\alpha_1})f(p_2^{\alpha_2})\cdots f(p_k^{\alpha_k})$。

### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le m\le 10^{10}$，$1\le k\le 10^{9}$。

对于不同的子任务，作如下约定：

| 子任务编号 |        $n$         |      $m$      |     $k$      | 子任务分值 |
| :--------: | :----------------: | :-----------: | :----------: | :--------: |
|    $1$     |     $\le 10^3$     |  $\le 10^3$   | $\le 10^{3}$ |    $5$     |
|    $2$     |        $=1$        | $\le 10^{10}$ |  $\le 10^9$  |    $15$    |
|    $3$     |     $\le 10^5$     |  $\le 10^5$   |  $\le 10^9$  |    $15$    |
|    $4$     |     $\le 500$      |  $\le 10^9$   |  $\le 10^9$  |    $10$    |
|    $5$     |     $\le10^5$      | $\le 10^{10}$ |     $=1$     |    $15$    |
|    $6$     | $\le 5\times 10^3$ |  $\le 10^9$   |  $\le 10^9$  |    $15$    |
|    $7$     | $\le 5\times 10^4$ |  $\le 10^8$   |  $\le 10^9$  |    $15$    |
|    $8$     |     $\le 10^5$     | $\le 10^{10}$ |  $\le 10^9$  |    $10$    |



## 样例 #1

### 输入

```
2 2 64```

### 输出

```
9```

## 样例 #2

### 输入

```
5 5 64 ```

### 输出

```
213```

## 样例 #3

### 输入

```
1234 1234 12```

### 输出

```
673319736```

## 样例 #4

### 输入

```
30000 10000000 2```

### 输出

```
836094021```

# 题解

## 作者：ForgotMe (赞：17)

灵感：来自 UOJ 校验码，想着出一个函数没啥特殊性质的题。

## Subtask 1

暴力即可。

## Subtask 2

$n=1$，显然是筛 $f$ 的前缀和，这个是平凡的，min25 或者一遍 PN 筛法即可。

这里只讲 PN 筛，可以发现质数处点值是 $f(p)=p$，于是构造 $g(x)=x$ 就行。

其实这里出题人想放过去的只有 PN 筛，但想了想还是算了。

## Subtask 3 

~~给的是不会筛 $f$ 前缀和的正解~~。当然可能也有其他做法。

这里先不讲正解。

## Subtask 5

这个东西其实也被出烂了，因为 $k=1$，那么 $f(p^k)=p$，于是可以得出 $f(ij)=\frac{f(i)f(j)}{f(\gcd(i,j))}$。知道这个就很简单了，对 $f(\gcd(i,j))$ 反演即可，做法跟 DZY Loves Math IV 一致，这里不再赘述。

## Subtask 4 & 6

开始讲跟正解有关的东西了。

记 $F(n,x)=\sum_{i=1}^n f(ix)$ 。

可以发现不能优美的处理 $f(ij)$ 的原因是 $i$ 和 $j$ 可能有共同的质因子，而且这部分的贡献不能很好用 $\gcd(i,j)$ 去描述。

不如粗暴一点，直接枚举 $i$ 所含有的质因子的幂次（枚举的幂次的含义是 $j$ 含有该质因子的个数），只要确定了这些质因子的幂次，那么剩下的问题就很简单了。

设枚举 $i$ 所含有的质因子幂次后确定后的数是 $x$，那么显然 $j$ 得满足 $\gcd(j,x)=x$。

可以列出下列式子：

$$
F(n,i)=\sum_{x}f(ix)\sum_{j=1}^{n/x}[\gcd(i,j)=1]f(j)
$$

莫反后可以得到：

$$
F(n,i)=\sum_{x}f(ix)\sum_{d|i}\mu(d)F(\lfloor\frac{n}{xd}\rfloor,d)
$$

如果直接计算并记忆化 $F$，只能过掉 Subtask4。

注意到 $\sum_{d|i}\mu(d)F(\lfloor\frac{n}{xd}\rfloor,d)$ 可以写成 $F_2(\lfloor\frac{n}{x}\rfloor,i)$，将 $F$ 与 $F_2$ 一起计算并记忆化就能过掉 Subtask6。

## Subtask 7 & 8

实际上上面的想法是好的，但是可惜的是 $F$ 与 $F_2$ 的转移量太大了，导致效率低下。

仔细想一想，真的有必要枚举 $x$ 吗。答案显然是不用。

不如直接考虑 $F(n,x)$ 的递推式，取一个质数 $p$ 满足 $p|x$。

考虑剥离出 $p$ 的贡献，设 $x_2$ 为 $x$ 去掉质因子 $p$ 后的数。

如果说知道质因子 $p$ 在计算时的幂次，那就简单了。

考虑容斥，枚举质因子 $p$ 被计算了 $i$ 次，一个简单的想法是剩下的质因子的贡献就是 $F(\lfloor \frac{n}{p^i}\rfloor,x_2)-F(\lfloor \frac{n}{p^{i+1}}\rfloor,x_2)$，但是这是错误的，因为多钦定的那一个 $p$ 也是会造成贡献的，并不能简单的算为 $F(\lfloor \frac{n}{p^{i+1}}\rfloor,x_2)$。不如换个角度，把多钦定的那一个 $p$ 造成的贡献给 $x_2$，也就是 $F(\lfloor \frac{n}{p^{i+1}}\rfloor,x_2\times p)$，可以发现，这样子算的话就对了。

$$
F(n,x)=\sum_{i=0}(F(\lfloor \frac{n}{p^i}\rfloor,x_2)-F(\lfloor \frac{n}{p^{i+1}}\rfloor,x_2\times p))\times f(p^i)
$$

但是，你肯定会问这个复杂度是多少呢，看上去空间就是 $n\sqrt{m}$ 的吧，这怎么跑？实际上，如果把 $p$ 取为 $x$ 的最大质因子，然后记忆化直接算，状态量和转移量都很少，在接受的范围以内。

极限数据下，转移量和状态量分别是 $26116544$，$1810443$，如果预处理出 $n\times x\le 10^6$ 的 $F$，转移量和状态量下降到 $13139202$，$972667$，可以用来减小常数。~~实际运行中瓶颈在于 PN 筛~~，如果使用哈希表记忆化，这个部分的运行速度在 200ms $\sim$ 300ms。

最后提一句，这个做法可以解决任何 $\sum_{i=1}^n \sum_{j=1}^m f(ij)$ （其中 $n$ 比较小，$m$ 比较大，$f$ 是一个积性函数）的题，当然，个人认为这个做法可以直接套在 UOJ 校验码这个题上，虽然不知道是否能过（有兴趣的同学可以去试一试），因为作者和 Kubic 老师都无法估计这个算法的时间复杂度。

---

## 作者：Arghariza (赞：7)

<https://www.cnblogs.com/Ender32k/p/17729526.html>

抢到最优解了，[UOJ 校验码](https://uoj.ac/submission/656230)上 80pts 过不去。/kk

这里是官方题解的简化。

首先考虑 $n=1$ 怎么做，相当于对 $m\le 10^{10}$ 筛出 $f$ 的前缀和。由于 $f(p)=p$，直接构造函数 $g(n)=n$ 然后 PN 筛 $O(\sqrt m)$ 求即可。

然后考虑 $n>1$，由于 $n$ 比较小，考虑对每一个 $i\le n$，求出 $
\sum\limits_{j=1}^mf(ij)$。

令 $F(x,y)=\sum\limits_{i=1}^yf(ix)$，答案就是 $\sum\limits_{i=1}^nF(i,m)$。类似 Min25 筛的想法，消去 $x$ 的最大质因子 $p^c$，然后枚举 $y'\le y$ 中 $y'$ 中的 $p$ 的最大次数为 $i$，用容斥即 「至少出现了 $i$ 次的贡献」减去「至少出现了 $i+1$ 次的贡献」，由于钦定至少出现 $i+1$ 次比至少出现 $i$ 次少了一个 $p$ 的贡献，将 $p$ 乘到 $\frac{x}{p^c}$ 上面：

$$F(x,y)=\sum\limits_{i\ge 0}\left(F\left(\frac{x}{p^c},\left\lfloor \frac{y}{p^i}\right\rfloor\right)-F\left(\frac{x}{p^{c-1}},\left\lfloor\frac{y}{p^{i+1}}\right\rfloor\right)\right)f(p^{c+i})$$

记忆化一下，边界 $n=1$ 直接 PN 筛，否则暴力递归即可。预处理 $xy\le 10^6$ 的所有 $F(x,y)$ 后，根据官方题解有效状态数大概只有 $10^6$ 左右，转移数大概 $1.5\times 10^7$。

```cpp
 // Problem: P9157 「GLR-R4」夏至
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9157
// Memory Limit: 512 MB
// Time Limit: 4000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#include <bits/extc++.h>
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#define pb emplace_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pi;
typedef tuple<int, int, int> tu;
bool Med;

const int C = 40;
const int N = 1e6 + 100;
const int M = 1e5 + 100;
const int P = 1e9 + 7;
const int i2 = (P + 1) / 2;

ll m;
int n, k, h[M][C];
int tot, vs[N], pr[N], mxp[N], mxc[N], rs[N], f[N];
vector<int> F[N];
vector<ull> pn;
gp_hash_table<ull, int> tF;

void Add(int &x, int y) { x += y, (x >= P) && (x -= P); }
int qpow(int p, int q) {
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

void dfs(ll x, int y, int i) {
	if (!y || i == tot + 1) return;
	pn.pb((ull)x * P + y);
	for (int j = i; j <= tot; j++) {
		if (x > m / pr[j] / pr[j]) break;
		ll t = x * pr[j] * pr[j];
		for (int l = 2; t <= m; t *= pr[j], l++)
			if (h[j][l]) dfs(t, 1ll * y * h[j][l] % P, j + 1);
	}
}

void init(int lim) {
	for (int i = 2; i <= lim; i++) {
		if (!vs[i]) pr[++tot] = i, mxp[i] = i, mxc[i] = rs[i] = 1;
		for (int j = 1; j <= tot && i * pr[j] <= lim; j++) {
			vs[i * pr[j]] = 1;
			mxp[i * pr[j]] = mxp[i];
			mxc[i * pr[j]] = mxc[i] + (mxp[i] == pr[j]);
			rs[i * pr[j]] = (pr[j] == mxp[i]) ? rs[i] : (rs[i] * pr[j]);
			if (i % pr[j] == 0) break;
		}
	}
	f[1] = 1;
	for (int i = 2; i <= lim; i++)
		f[i] = f[rs[i]] * qpow(mxp[i], __gcd(k, mxc[i]));
	for (int i = 1; i <= lim; i++) {
		F[i].resize(lim / i + 5);
		for (int j = 1; j <= lim / i; j++)
			Add(F[i][j] = F[i][j - 1], f[i * j]);
	}
	for (int i = 1; i <= tot; i++) {
		h[i][0] = 1; ll tp = pr[i];
		for (int j = 1; tp <= m; tp *= pr[i], j++) {
			h[i][j] = qpow(pr[i], __gcd(j, k));
			for (int l = 1, t = pr[i]; l <= j; l++, t = 1ll * t * pr[i] % P)
				Add(h[i][j], P - 1ll * t * h[i][j - l] % P);
		}
	}
}

int S(ll x) { x %= P; return 1ll * x * (x + 1) % P * i2 % P; }
int calc(int x, ll y) {
	if (x * y <= 1e6) return F[x][y];
	if (!y) return 0;
	if (tF.find((ull)x * P + y) != tF.end()) return tF[(ull)x * P + y];
	int res = 0;
	if (x == 1) {
		for (ull p : pn) {
			if (p / P > y) break;
			Add(res, 1ll * (p % P) * S(y / (p / P)) % P);
		}
	} else {
		int p = mxp[x]; ll t = y;
		for (int i = 0; t; i++, t /= p) 
			Add(res, 1ll * (calc(rs[x], t) - calc(rs[x] * p, t / p) + P) % P * qpow(p, __gcd(i + mxc[x], k)) % P);
	}
	return tF[(ull)x * P + y] = res;
}

void solve() {
	cin >> n >> m >> k, init(1e6);
	dfs(1, 1, 1), sort(pn.begin(), pn.end(), [](ull &x, ull &y) { return x / P < y / P; });
	int res = 0;
	for (int i = 1; i <= n; i++) 
		Add(res, calc(i, m));
	cout << res << '\n';
}

bool Mbe;
signed main() {
	// ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Med - &Mbe) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen("1.in", "r", stdin);
		freopen("1.out", "w", stdout);
	#endif
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：critnos (赞：5)

科技记录。

使用**恐怖 zky 筛法**（初版）即可做到 $O(\sqrt{nm}+m^{3/5})$，如果利用**周哥筛**恐怕可以更优。

定义二维积性函数为 $f(x,y)=\prod _{p_i} f(p_i^{x_i},p_i^{y_i})$，卷积定义是 $\sum_{i|x,j|y}f(i,j)g_(x/i,y/j)$。题目要求的就是某个二维积性函数 $f$ 的二维前缀和。

考虑二维积性函数 $g(x,y)=f(x,1)f(1,y)$，求这个东西的二维前缀和只需要筛题目里面的函数的前缀和。实际上后面我们只需要用到其块筛的值，也就是需要预处理题目中的函数的块筛。可以发现题目中的函数可以 PN 筛，那么是可以 [$O(n^{3/5})$](https://www.luogu.com/article/ygfzawod) 预处理其块筛的。

考虑二维积性函数 $h$ 满足 $h*g=f$，可以发现 $h(1,p^k)=h(p^k,1)=0$。这代表 $h(p,q)\neq 0$ 当且仅当对于任意一个质因子，$p,q$ 要么都有这个质因子，要么都没有这个质因子。接下来 zky 说：$\forall p\in [1,n],q\in[1,m]$，$h$ 有值的位置只有 $\sqrt{nm}$ 个。

不妨放缩为 $p,q$ 满足 $\forall pq\le N=nm$。

记 $s(x)=\sum_{pq=x} [h(p,q)\ne 0]$。容易发现，$s$ 是积性函数。那么 $s(p^k)=k-1,k>0$。

考虑用若干个积性函数卷积去估计 $s$ 上界。如果卷出来是 $s'$，需要满足 $s'(p^k)\ge s(p^k)$。

不妨设需要估计的积性函数 $s$ 的最小的 $k$ 满足 $s(p^k)\ne 0$ 为 $K$，$C=s(p^K)$。这里  $k=2$。记积性函数 $H_c(x)$ 为 $x$ 是否是某正整数的 $c$ 次方。

那么首先得卷出一个 $H_K^C$。

不妨设 $C,K$ 是常数，那么先考虑一下这时候 $s'$ 的前缀和 $S$？$H_K$ 的前缀和当然是 $n^{1/K}$，那 $H_K*H_K$，就是

$$\sum_{xy\le n} s'(x)H_K(y)$$

$$\sum_{y\le n} H_K(y)S(n/y)$$

$$\sum_{y^K\le n} S(n/y^K)$$

$$\sum_{y^K\le n} n^{1/K}/y$$

$$ n^{1/K}\log n$$

可以发现，这样子卷 $C$ 次之后得到 $n^{1/K}\log^{C-1} n$。

但这样只有在 $s'(p^{iK})$ 处有值。再尝试卷上 $H_{K+1}$ 呢 ？

$$\sum_{y\le n} H_K(y)S(n/y)$$

$$\sum_{y^{K+1}\le n} S(n/y^{K+1})$$

$$n^{1/K}\log n\sum_{y^{K+1}\le n} y^{-(K+1)/K}$$

把后面求和改成积分，可以发现这是个常数。所以这并不影响前缀和。

如果 $s(p^k)$ 关于 $k$ 的增长率是常系数常次数多项式，那么我们卷常数次 $H_{K+1},H_{K+2}\dots H_{2K-1},H_{2K}$ 就会超过 $s$ 了。

综上所述，$s$ 的前缀和是 $n^{1/K}\log^{C-1}n$。将这里的 $K=2,C=1$ 代入可以发现这里的前缀和是 $N^{1/2}=\sqrt{nm}$ 级别的。

那么枚举 $h$ 中有值的位置即可。

有一个更好的 $(nm)^{1/3}$ 的改进，不过我还没看后面砍掉一个 $\log$ 的复杂度分析。

---


# [集训队互测 2023] 优惠购物

## 题目描述

小 C 要购买 $n$ 个物品，这些物品有前置关系，必须**依次**购买（即在购买了第 $i$ 个后才能购买第 $i+1$ 个）。

他初始有 $m$ 张优惠劵和无穷多个金币。每个物品有两个属性，价格 $a_i$ 和优惠劵的使用上限 $b_i(0\le b_i\le a_i)$。

购买一个物品的流程如下：

- 选择使用 $x(0\le x\le b_i)$ 张优惠券，付出 $a_i-x$ 个金币和 $x$ 张优惠券。
- 购买完后可得到 $\lfloor \frac{a_i-x}{c} \rfloor$ 张优惠券（即一次购买中，每付出 $c$ 个金币可以得到一张优惠券，$c$ 为给定常数）

小 C 想求出最少花费多少个金币能购买全部物品。

## 说明/提示

对于所有数据，$1\le \sum n\le 10^6,0\le m,a_i,b_i\le 10^9,2\le c\le 10^9$。

- Subtask 1 (5 pts)：$1\le T\le 5,1\le n\le 10,1\le m,\sum a_i,\sum b_i\le 10$
- Subtask 2 (10 pts)：$a_i=b_i$
- Subtask 3 (10 pts)：$1\le \sum n\le 500,1\le \sum m,\sum a_i,\sum b_i\le 500$
- Subtask 4 (10 pts)：$1\le \sum n\le 6000,1\le \sum m,\sum a_i,\sum b_i\le 6000$
- Subtask 5 (10 pts)：$1\le \sum n\le 6000$
- Subtask 6 (15 pts)：$1\le \sum n\le 2\times 10^5,2\le c\le 20$
- Subtask 7 (10 pts)：$1\le \sum n\le 1\times 10^6,2\le c\le 20$
- Subtask 8 (15 pts)：$1\le \sum n\le 2\times 10^5$
- Subtask 9 (15 pts)：$1\le \sum n\le 1\times 10^6$

时间限制：$\texttt{1s}$

空间限制：$\texttt{2048MB}$

## 样例 #1

### 输入

```
4
6 16 2
17 14 13 5 13 4
12 5 5 2 10 2
6 4 2
8 1 20 10 4 10
8 1 15 3 4 6
5 40 7
21 47 7 25 47 
9 26 4 4 39 
5 151 10
86 84 164 158 160
43 42 82 79 80```

### 输出

```
34
34
95
463```

## 样例 #2

### 输入

```
见附件 ex_shop2.in。```

### 输出

```
见附件 ex_shop2.out。```

# 题解

## 作者：Rainbow_qwq (赞：12)

## 解题过程

### 算法 1（暴力）

设 $f_{i,j}$ 表示购买了前 $i$ 个物品，当前**总共**获得了 $j$ 张优惠券（算上用过的），最大化当前最多能用掉的优惠券数量。

由 $f_{i,j}$ 可以计算出当前有的优惠券数量为 $j+m-f_{i,j}$。枚举这次使用的优惠券数量 $x$，则有转移：

$$f_{i,j}+x\to f_{i+1,j+\lfloor \frac{a_i-x}{c} \rfloor}$$

容易发现 dp 的复杂度为背包，复杂度即为 $O((\sum a_i)^2)$。

### 算法 2

设在第 $i$ 次购买时使用了 $x_i$ 张优惠券，考虑这种方案合法的条件：

设 $s_i$ 表示第 $i$ 次操作后的剩余优惠券数量，$s_i=m+\sum_{j=1}^i (-x_i + \lfloor \frac{a_i-x_i}{c}\rfloor)$. 若对于所有 $i$ 都满足 $s_{i-1}-x_i\ge 0$，则方案成立。

考虑一开始一张优惠券也不用，此时最后会多出若干张优惠券。

如果在前面用了若干张优惠券，那么在过程中总获得的优惠券数量（包括中间用了的）会减少。

考虑贪心，使得减少的【总获得的优惠券数量】最少。

设 【总获得的优惠券数量】 为 $S$，考虑在一个物品上不断增加花的优惠劵（减小价格），减少的数量可分为三个阶段：

- 花掉 $[0,a_i\bmod c]$ 的优惠券，这个阶段 $S$ 不变。
- 上个阶段把价格变成了 $c$ 的倍数，然后每次花掉 $c$ 的优惠券，并且 $S$ 减 $1$。
- 最后花一次 $[0,c-1]$ 的优惠券并且 $S$ 减 $1$，也可能不做操作。

从操作性价比考虑，第一个阶段减少为 $0$，优于第二个阶段，而第二个阶段每花掉 $c$ 个优惠券才减少一个，优于第三个阶段。

因此可以贪心，先考虑第一阶段，对于物品 $i$ 在 $a_i\bmod c$ 内尽量使用优惠券。这样会把每个价格尽量减成 $c$ 的倍数，如果这一步中并没有把价格减小到 $c$ 的倍数那说明之后也不可能再减了。

然后考虑第二阶段。可以倒着贪心，设 $s_i$ 表示第 $i$ 次操作后的剩余优惠券数量，$x_i$ 表示当前方案中第 $i$ 个使用了 $x_i$ 张优惠券。

$x_i$ 每增加 $c$，则 $\forall j\ge i,s_j$ 会减少 $c+1$，由于需要保证 $s_{i-1}-x_i\ge 0$，则可以算出第 $i$ 个可以减小的最多数量为 $\min(\lfloor \frac{b_i-x_i}{c}\rfloor,\lfloor\frac{s_{i-1}-x_i}c\rfloor,\min_{[j>i]}\lfloor\frac{s_{j-1}-x_j}{c+1}\rfloor)\times c$，从后往前做并记录一个后缀 $\min$ 即可。

对于第三阶段，仍然先做性价比更高的操作，也就是优先做在某个位置上用 $c-1$ 张优惠券的操作，然后是用 $c-2,c-3 \dots$ 的操作，容易发现这样能使被操作的位置最少。

可以枚举 $j=c-1,c-2,\dots,1$，然后对于每个位置，判定再某个位置上是否能做用 $j$ 个优惠券这个操作（也就是 $s$ 操作后是否满足），式子和上面那部分的差不多，不难发现从后往前做，记录一个后缀 $\min$ 即可判定。

时间复杂度 $O(nc)$，瓶颈在第三部分，可以通过 Subtask 6,7。

### 算法 3

算法 2 是原来的 std，但 xcyle 在验题时提出了一个不一样的 $O(n\log n)$ 算法；后来我发现算法 2 也能优化到 $O(n\log n)$。

考虑优化算法 2 第三部分中找某个位置的过程。

设 $t_i = s_{i-1}-x_i,del_i=\min(b_i-x_i,t_i,\min_{[j>i]}(t_j-1))$，那上述的贪心过程相当于每次取 $del_i$ 最大的位置，将 $x_i$ 加上 $del_i$，并做修改 $t_i\to t_i-del_i,t_{j}\to t_{j}-del_i-1(j>i)$。直接暴力做就是 $O(n^2)$ 的。

考虑 $del_i$ 受到的两种限制，其中 $\min(t_i,\min_{[j>i]}(t_j-1))$ 随 $i$ 的减小而减小，也就是单调递增的。而 $b_i-x_i$ 不具有单调性。

将所有 $i$ 按照 $b_i-x_i$ 排序，并依次加入。每次先向一个【可行集合】中加入若干个 $b_i-x_i$ 相等的位置，设下一个更小的 $b_i-t_i$ 为 $lim$，我们想要取掉所有 $del_i$ 大于 $lim$ 的位置。

由于 $\min(t_i,\min_{[j>i]}(t_j-1))$ 单调递增，则此时能取的 $i$ 为【可行集合】和一段后缀的交集，不难发现取可行集合中最大的一定最优。于是用 set/大根堆 维护可行集合，每次取出最大的元素，判断 $del_i$ 是否满足，如果满足就修改 $t$，并从可行集合中删去该元素。

$t$ 可以用区间加，区间查 $\min$ 的线段树维护，总时间复杂度 $O(n\log n)$，可以通过所有 Subtask。

[这里](https://qoj.ac/submission/232183)是 std 的实现。

---

## 作者：DaiRuiChen007 (赞：3)

[Problem Link](https://www.luogu.com.cn/problem/P10001)

**题目大意**

> 给定 $n$ 个物品，你要按顺序购买每个物品，初始有 $m$ 个优惠券。
>
> 对于第 $i$ 个物品，你要花费总计 $a_i$ 个金币或优惠券，其中优惠券至多用 $b_i$ 张，并且你每付出 $c$ 个金币就会获得一张优惠券（向下取整）。
>
> 最小化花费的金币总数。
>
> 数据范围：$n\le 10^6$。

**思路分析**

假设第 $i$ 次购买时花费了 $x_i$ 张优惠券，那么前 $i$ 次操作后剩余的优惠券 $s_i=m+\sum\limits_{j=1}^i \left\lfloor\dfrac{a_j-x_j}c\right\rfloor-x_j$，唯一的限制就是 $\forall i\in[1,n+1]:x_i\le s_{i-1}$。

考虑如何贪心解决这个问题。

我们分析优惠券从 $0$ 开始不断增加的过程：

- 使用的前 $a_i\bmod c$ 张优惠券：使用任意多张都不会减少获得的优惠券，因此贪心使用尽可能多的这种优惠券。
- 接下来每使用 $c$ 张优惠券，都会使得后续剩余优惠券数量额外 $-1$。
- 对于剩余的最后 $<c$ 张优惠券，还会使得后续剩余优惠券数量 $-1$。

容易发现所有的操作中，第一种操作显然最优，然后是第二种和第三种。

那么我们先进行所有的第一种操作，容易发现在哪个位置操作仅仅相当于改变 $m$，无后效性，因此可以随意操作，不妨从前往后依次取，即 $x_i=\min(a_i\bmod c,b_i,s_{i-1})$。

然后我们要进行一些第二种操作，即在某个位置连续使用 $c$ 张优惠券。

我们发现这种情况下收益相同，使用的位置显然越靠后后效性越小，因此从后往前贪心取尽可能多的 $x_i$ 即可。

那么此时第 $i$ 个位置会使用 $\min\left(\left\lfloor\dfrac{b_i-x_i}c\right\rfloor,\left\lfloor\dfrac{s_{i-1}-x_i}c\right\rfloor,\min\limits_{i<j\le n+1}\left\lfloor\dfrac{s_{j-1}-x_j}{c+1}\right\rfloor\right)$ 轮 $c$ 张优惠券。

最后第三种情况，我们只要考虑每个点剩余使用的优惠券数 $\in[0,c)$ 的剩余情况。

根据贪心，我们依然要优先做收益最高的操作，即可以使用优惠券数最多的操作。

记 $t_i=s_{i-1}-x_i$ 在第 $i$ 个位置最多可以使用的优惠券数量就是 $\min(b_i-x_i,t_i,\min_{i<j\le n+1}t_j-1)$。

观察这个结构的性质，我们发现 $d_i=\min(t_i,\min _{i<j\le n+1} t_j-1)$ 具有单调性，随着 $i$ 的增加而递增，而且在整个贪心过程中其单调性始终存在。

那么考虑模拟这个过程，我们从大往小枚举 $w=c-1\sim 0$，求出 $\min(d_i,b_i-x_i)=w$ 的所有位置然后操作。

考虑如何维护这些位置，首先这些位置显然满足 $b_i-x_i\ge w$，而 $b_i-x_i$ 是定值，因此可以离线，在 $w=b_i-x_i$ 时插入操作 $i$，那么我们只要取出所有 $d_i\ge w$ 的操作即可。

而 $d_i$ 从后往前递减，因此 $d_i\ge w$ 的 $i$ 一定是 $1\sim n$ 的一段后缀，用堆维护所有被插入的操作 $i$ 中的最大值，判断是否有 $d_i\ge w$ 即可。

容易发现我们只要处理等于某个 $b_i-x_i$ 的所有 $w$，中间的 $w$ 不需要考虑，只要大于下一个 $b_i-x_i$ 的所有 $d_i$ 都操作即可。

我们可以用线段树动态维护 $d_i$，只要区间加区间最小值即可。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e6+5;
int n,id[MAXN];
ll c,a[MAXN],b[MAXN],s[MAXN],x[MAXN],up[MAXN];
struct SegmentTree {
	ll tr[MAXN<<2],tg[MAXN<<2];
	void psu(int p) { tr[p]=min(tr[p<<1],tr[p<<1|1]); }
	void adt(int p,int k) { tr[p]+=k,tg[p]+=k; }
	void psd(int p) { adt(p<<1,tg[p]),adt(p<<1|1,tg[p]),tg[p]=0; }
	void init(int l=1,int r=n+1,int p=1) {
		tr[p]=tg[p]=0;
		if(l==r) return tr[p]=s[l-1]-x[l],void();
		int mid=(l+r)>>1;
		init(l,mid,p<<1),init(mid+1,r,p<<1|1);
		psu(p);
	}
	void add(int ul,int ur,int k,int l=1,int r=n+1,int p=1) {
		if(ul<=l&&r<=ur) return adt(p,k);
		int mid=(l+r)>>1; psd(p);
		if(ul<=mid) add(ul,ur,k,l,mid,p<<1);
		if(mid<ur) add(ul,ur,k,mid+1,r,p<<1|1);
		psu(p);
	}
	ll qry(int ul,int ur,int l=1,int r=n+1,int p=1) {
		if(ul<=l&&r<=ur) return tr[p];
		int mid=(l+r)>>1; psd(p);
		if(ur<=mid) return qry(ul,ur,l,mid,p<<1);
		if(mid<ul) return qry(ul,ur,mid+1,r,p<<1|1);
		return min(qry(ul,ur,l,mid,p<<1),qry(ul,ur,mid+1,r,p<<1|1));
	}
}	T;
void solve() {
	scanf("%d%lld%lld",&n,&s[0],&c);
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]);
	for(int i=1;i<=n;++i) scanf("%lld",&b[i]);
	for(int i=1;i<=n;++i) {
		ll w=min({a[i]%c,b[i],s[i-1]});
		x[i]=w,s[i]=s[i-1]-x[i]+(a[i]-x[i])/c;
	}
	ll lim=s[n];
	for(int i=n;i>=1;--i) {
		ll w=min({(b[i]-x[i])/c,(s[i-1]-x[i])/c,lim/(c+1)});
		x[i]+=c*w,lim=min(lim-(c+1)*w,s[i-1]-x[i]);
	}
	for(int i=1;i<=n;++i) s[i]=s[i-1]-x[i]+(a[i]-x[i])/c;
	x[n+1]=id[n+1]=0,T.init();
	for(int i=1;i<=n;++i) id[i]=i,up[i]=min(c-1,b[i]-x[i]);
	sort(id+1,id+n+1,[&](int i,int j){ return up[i]>up[j]; });
	priority_queue <int> Q;
	for(int i=1,j;i<=n;i=j) {
		for(j=i;j<=n&&up[id[j]]==up[id[i]];++j) Q.push(id[j]);
		while(Q.size()) {
			int u=Q.top();
			ll z=min({up[u],T.qry(u,u),T.qry(u+1,n+1)-1});
			if(z>up[id[j]]) {
				Q.pop(),x[u]+=z,T.add(u,u,-z),T.add(u+1,n+1,-z-1);
			} else break;
		}
	}
	ll ans=0;
	for(int i=1;i<=n;++i) ans+=a[i]-x[i];
	printf("%lld\n",ans);
}
signed main() {
	int o; scanf("%d",&o);
	while(o--) solve();
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

做题的时候复述了一遍题解，干脆贴上来，说不定有用。

设第 $i$ 次操作结束后还拥有 $s_i$ 张优惠卷，则
$$
s_i = s_{i-1} - x_i + \lfloor \frac{a_i-x}{c} \rfloor
$$
需要满足 $x_i \le \min\{s_{i-1},b_i\}$。目标为最大化 $\sum x_i$。

考虑 $x$ 对 $\lfloor \dfrac{a_i-x}{c} \rfloor$ 的影响。假设初始状态下 $x \equiv 0$。

1. 当 $0 \le x \le a_i \bmod c$ 时，没有任何影响。
2. 在上一步操作后，每选 $c$ 个进入 $x$ 会使得 $\lfloor \dfrac{a_i-x}{c} \rfloor$ 减少 $1$。
3. 最后选择 $[1,c)$ 中的一个数 $v$ 进入 $x$，会使 $\lfloor \dfrac{a_i-x}{c} \rfloor$ 减少 $1$。

考虑单独扰动一个 $x$，对 $z_i=s_{i-1}-x_i$ 的影响。

1. $x$ 增加 $1$，$z_{j \ge i}$ 减少 $1$。
2. $x$ 增加 $c$，$z_i$ 减少 $c$，$z_{j > i}$ 减少 $c+1$。
3. $x$ 增加 $v$，$z_i$ 减少 $v$，$z_{j>i}$ 减少 $v+1$。

容易发现，第 $1$ 种变化显然由于第 2、3 种，因此可以贪心地倒序扫描（显然越往后的位置后效性越小）

第 $2$ 种变化也优于第 $3$ 种变化，因此可以对变化 $2$ 也贪心的倒叙扫描一次。

考虑现在计算出了每个位置的 $x_i$，则每个位置只能增加 
$$
\min(b_i-x_i,\min_{j \ge i} (z_j-[i \neq j]))
$$
次。注意到 $\sum \Delta \le z_n - cnt$，其中 $cnt$ 是操作 $3$ 进行的次数，应当越小越好，所以每次选最大的数。

观察 $\min_{j \ge i} (z_j - [i \neq j])$ 有单调性。如果我们要求所有 $\min\{b_i-x_i \ge w,\min_{j \ge i} \cdots\} \ge w$ 的位置，考虑拆开，即保证 $b_i-x_i \ge w$。因此把 $b_i - x_i$ 按照倒序插进去，每次求最靠后的位置，并且取最大值即可。（注意这个最大值可能 $<w$，要和下一个 $b_i-x_i$ 的值进行比较，如果更大就取出）

注意前两种操作可以不用线段树，这样可以快不少。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10,INF=0x3f3f3f3f3f3f3f3f;
int T,n,m,c,a[MAXN],b[MAXN],x[MAXN],s[MAXN];
int tot,lsh[MAXN];
namespace DS {
	#define lson (k<<1)
	#define rson (k<<1|1)
	#define mid (l+r>>1)	
	int tag[MAXN<<2],mn[MAXN<<2];
	void build(int k,int l,int r) {
		tag[k]=0;
		if(l==r) return mn[k]=s[l-1]-x[l],void();
		build(lson,l,mid),build(rson,mid+1,r);
		return mn[k]=min(mn[lson],mn[rson]),void();
	}
	void push_down(int k,int l,int r) {return tag[lson]+=tag[k],tag[rson]+=tag[k],mn[lson]+=tag[k],mn[rson]+=tag[k],tag[k]=0,void();}
	void update(int k,int l,int r,int x,int y,int v) {
		if(x>y) return ;
		if(x<=l&&r<=y) return tag[k]+=v,mn[k]+=v,void();
		push_down(k,l,r);
		if(x<=mid) update(lson,l,mid,x,y,v);
		if(y>mid) update(rson,mid+1,r,x,y,v);
		return mn[k]=min(mn[lson],mn[rson]),void();	
	}
	int query(int k,int l,int r,int x,int y) {
		if(x>y) return INF;
		if(x<=l&&r<=y) return mn[k];
		push_down(k,l,r);
		if(y<=mid) return query(lson,l,mid,x,y);
		if(x>mid) return query(rson,mid+1,r,x,y);
		return min(query(lson,l,mid,x,y),query(rson,mid+1,r,x,y));	
	}
};
vector<int> ins[MAXN];
signed main() {
//	freopen("read.cpp","r",stdin);
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>n>>m>>c;
		ffor(i,1,n) x[i]=0,cin>>a[i];
		ffor(i,1,n) cin>>b[i];
		s[0]=m;
		ffor(i,1,n) s[i]=s[i-1]+a[i]/c;
		int mn=INF;
		roff(i,n,1) {
			mn=min(mn,s[i-1]);
			int lim=min({a[i]%c,b[i],mn});
			x[i]=lim,mn-=lim;
		}
		ffor(i,1,n) s[i]=s[i-1]-x[i]+(a[i]-x[i])/c;
		mn=INF;
		roff(i,n,1) {
			int lim=min({(b[i]-x[i])/c,mn/(c+1),(s[i-1]-x[i])/c});
			x[i]+=lim*c,mn-=lim*(c+1),mn=min(mn,s[i-1]-x[i]);
		}
		ffor(i,1,n) s[i]=s[i-1]-x[i]+(a[i]-x[i])/c;
		DS::build(1,1,n);
		tot=0;
		ffor(i,1,n) lsh[++tot]=b[i]-x[i];
		sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
		ffor(i,1,tot) ins[i].clear();
		ffor(i,1,n) ins[lower_bound(lsh+1,lsh+tot+1,b[i]-x[i])-lsh].push_back(i);
		priority_queue<int> st;
		roff(i,tot,1) {
			for(auto id:ins[i]) st.push(id);
			while(!st.empty()) {
				int id=st.top();
				int val=min(DS::query(1,1,n,id,id),DS::query(1,1,n,id+1,n)-1);
				val=min(val,lsh[i]);
				if(val>=lsh[i-1]) x[id]+=val,DS::update(1,1,n,id,id,-val),DS::update(1,1,n,id+1,n,-val-1),st.pop();
				else break ;
			}
		}
		int ans=0;
		ffor(i,1,n) ans+=a[i]-x[i];
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Sky_Maths (赞：2)

[cnblogs](https://www.cnblogs.com/SkyMaths/p/18542562)

首先发现这个过程的限制比较多，那么考虑重新描述这个过程。

令 $x_i$ 表示在第 $i$ 个物品上使用了 $x_i$ 张券，那么一组 $x_{1\sim n}$ 就描述了一个方案。

方便起见，令 $s_i$ 为前 i 个物品买完后剩了几张券，那么有：
- $s_0 = m$
- $s_i = s_{i - 1} + \lfloor\frac{a_i - x_i}{c}\rfloor$

考虑合法的 $x_{1\sim n}$ 要满足的条件和最后的答案。

要满足的条件：
1. $x_i\le b_i$
2. $x_i\le s_{i - 1}$

最后的答案为 $\sum (a_i - x_i)$，即要求最大化 $\sum x_i$。

先考虑所有 $x_i = 0$ 的情况，然后考虑变化，设 $ds_i$ 为第 $i$ 个物品贡献的优惠券。

基于 $ds_i$ 的变化，可以把一个物品的 $x_i$ 的变化拆成基于 $3$ 种操作的变化。
1. 前 $a_i\bmod c$ 张，此时使用优惠券不影响 $ds_i$。
2. 每次操作使 $ds_i$ 减 1 并使 $x_i$ 加 $c$。
3. 使 $ds_i$ 减 1 并使 $x_i$ 加 $[0, c - 1]$。

为了方便考虑，设 $s'_i = s_{i - 1} - x_i$，那么条件 2 就是 $s'_i\ge 0$。

接下来再次考虑每种操作造成的影响。

对 $i$ 进行操作 1/2/3 的影响分别为：
1. 使 $s'_{i\sim n}$ 全部减 $1$，$x_i$ 加 $1$。
2. 使 $s'_{i}$ 减 $c$，使 $s'_{j > i}$ 减 $c + 1$，使 $x_i$ 加 $c$。
3. 假设使 $x_i$ 加 $z$，那么会使 $s'_{i}$ 减 $z$，使 $s'_{j > i}$ 减 $z + 1$。

发现：
1. 显然操作 2 优于操作 3，且操作 1 优于其余两个（因为相同情况下影响一定完全小于其余操作）。
2. 为了进行最多次的操作 1 可以从右往左扫一遍。
3. 为了进行最多次的操作 2 也可以从右往左扫一遍。

那么我们考虑动态维护 $s'_i$ 的值。令 $t$ 为能使用的券的个数。

对于操作 1，$t = \min(b_i, a_i\bmod c, \min\limits_{j \ge i} s'_j)$。

对于操作 2，$t = \min(\lfloor\frac{b_i - x_i}{c}\rfloor, \lfloor\frac{s'_{i - 1}}{c}\rfloor, \min\limits_{j \ge i}\lfloor\frac{s'_j}{c + 1}\rfloor)\times c$。

（我的正解的操作 3 部分的代码写得很丑陋，大概看一下就行。）

对于操作 3，考虑最优策略按能使用的券的张数从大到小，那么我们可以直接暴力模拟，$t = \min(b_i - x_i, \min(s'_{i - 1}, d_i = \min_{j\ge i} s'_{j - 1}))$。

发现 $d_i$ 随 $i$ 增大而增大。那么考虑枚举前面的限制（$b_i - x_i$），把 $\ge w$ 的加入，然后看一下最大的 $i$ 的 $d_i$，比较一下大小即可，可以用区间加，查询区间 min 线段树维护。

可以看一下暴力模拟的代码，我的 AC 代码只是用某些方式优化了其中的过程。

[暴力模拟代码1](https://qoj.ac/submission/738610)

[暴力模拟代码2](https://qoj.ac/submission/738569)

[正解代码](https://qoj.ac/submission/738841)

---


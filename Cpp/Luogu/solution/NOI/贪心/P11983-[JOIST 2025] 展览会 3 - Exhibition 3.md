# [JOIST 2025] 展览会 3 / Exhibition 3

## 题目描述

JOI 美术馆计划近期举办一场绘画展览。馆方拥有编号为 $1$ 至 $N$ 的 $N$ 幅画作，其中画作 $i$（$1 \leq i \leq N$）的**美观值**为 $A_i$。在展览中这些画作将排成一行展示，但具体排列顺序尚未确定。

共有 $M$ 家杂志将对展览进行报道。这些杂志按影响力从大到小依次编号为 $1$ 至 $M$。每家杂志将发布展览中某一连续段画作的摄影照片。具体来说，杂志 $j$（$1 \leq j \leq M$）将发布排列中从左数第 $L_j, L_j + 1, \ldots, R_j$ 幅画作的照片。杂志 $j$（$1 \leq j \leq M$）报道的**吸引力**定义为该杂志所覆盖画作的最大美观值。

JOI 君作为 JOI 美术馆的馆长，希望通过排列画作使得这些杂志的报道更具吸引力，从而吸引更多参观者。由于影响力更大的杂志能触达更多受众，他优先希望提升更具影响力杂志的报道吸引力。

具体而言，设 $b_j$ 为杂志 $j$（$1 \leq j \leq M$）报道的吸引力，则 JOI 君希望排列画作，使得序列 $b = (b_1, b_2, \ldots, b_M)$ 的字典序最大化。

> 在这里，对于不同的数列 $ b = (b_1, b_2, \ldots, b_M) $ 和 $ b' = (b'_1, b'_2, \ldots, b'_M) $，所谓“$ b $ 在字典序上大于 $ b' $”，是指存在满足 $ b_k \neq b'_k $ 的最小下标 $ k $（$ 1 \leq k \leq M $），且对于该 $ k $ 有 $ b_k > b'_k $。

请编写一个程序，根据待展览画作的信息和报道展览的杂志信息，计算当画作排列使序列 $b = (b_1, b_2, \ldots, b_M)$ 字典序最大化时，每家杂志报道的吸引力。

## 说明/提示

### 样例解释

#### 样例 $1$ 解释


重排后每张画的美观值为 $[2,1,2,1]$，得到 $b=[2,2,1,2]$，可以证明是最优解。

该样例满足子任务 $1\sim 3,5,6$ 的限制。

#### 样例 $2$ 解释

该样例满足子任务 $1\sim 6$ 的限制。

#### 样例 $3$ 解释

该样例满足子任务 $1,2,6$ 的限制。


### 数据范围
- $1 ≤ N ≤ 10^5$；
- $1 ≤ M ≤ 10^5$；
- $1 ≤ A_i ≤ N$；
- $1 ≤ L_j ≤ R_j ≤ N$；
- 输入的都是整数。

### 子任务
- $\text{Subtask 1 (19 pts)}$：$N,M\le 400$；
- $\text{Subtask 2 (9 pts)}$：$N\le 400$；
- $\text{Subtask 3 (19 pts)}$：$A_i\le 5$；
- $\text{Subtask 4 (12 pts)}$：$A_i=i$；
- $\text{Subtask 5 (17 pts)}$：$\forall 1\le k\le N$，满足 $A_i=k$ 的 $i$ 至多只有 $5$ 个。
- $\text{Subtask 6 (24 pts)}$：无额外限制。

## 样例 #1

### 输入

```
4 4
1 2 1 2
1 1
2 3
4 4
3 4```

### 输出

```
2
2
1
2```

## 样例 #2

### 输入

```
4 8
1 2 3 4
1 2
2 3
4 4
1 1
2 4
3 3
3 3
4 4```

### 输出

```
4
4
3
2
4
1
1
3```

## 样例 #3

### 输入

```
12 10
6 2 2 5 2 5 2 3 3 3 2 2
3 5
10 12
12 12
2 4
8 9
10 11
1 3
7 9
9 10
10 11```

### 输出

```
6
5
5
6
5
3
6
5
5
3```

# 题解

## 作者：tybbs (赞：9)

参考了 [链接](https://codeforces.com/blog/entry/140824) 中 $\text{Flamire}$ 的题解。

本题解的复杂度分析中认为 $n,m$ 同阶。

考虑暴力怎么做。  
对于值 $v$，设其在 $A$ 中出现了 $cnt_v$ 次。对于一个区间集合 $S$，设 $f(S)$ 表示可以覆盖 $S$ 中所有区间的点的个数的最小值。$f(S)$ 可以通过一个简单的贪心求得：将所有区间按 $r_i$ 排序，然后贪心的在 $r_i$ 处加入点即可。从大到小枚举值域，从小到大枚举区间编号 $i$，如果 $f(S\cup\{(l_i,r_i)\})\le cnt_v$，那么把 $b_i$ 赋为 $v$，将 $(l_i,r_i)$ 加入 $S$，然后把区间 $(l_i,r_i)$ 删除。暴力复杂度为 $O(n^3)$。

尝试优化上述暴力。注意到我们求 $f(S)$ 的贪心事实上可以求出第 $i$ 个点可能的最大值。同理，从大到小按 $l_i$ 排序也可以求出其最小值，不妨分别设为 $sr_i$ 和 $sl_i$。所以 $f(S)=f(S\cup\{(l_i,r_i)\})$ 当且仅当存在 $k$ 使得 $[sl_k,sr_k]$ 与 $[l_i,r_i]$ 相交。对于每个值，先二分出其可以覆盖的最长前缀，然后逐个检查每个区间是否可以加入 $S$，加入后重构 $sl$ 和 $sr$。因为每个区间只会造成一次重构，可以得到一个 $O(n^2\log n)$ 的做法。

发现第一部分的二分可以通过先进行倍增来优化。先找到最小的 $k$ 使得覆盖的前缀的长度小于 $2^k$，然后在 $[2^{k-1},2^k)$ 内二分。这样因为二分的区间长度和删去的区间长度同阶，第一部分的复杂度均摊 $O(n\log^2 n)$。可以通过提前对长为 $2^i$ 的前缀排序做到 $O(n\log n)$。

对于第二部分，注意到插入区间的过程中 $sl$ 单增，$sr$ 单减，且 $sl_i$ 不会超过 $sl_{i+1}$，而 $sl_i$ 只有 $|S|$ 个合法位置（$sr$ 同理），所以 $sl$ 和 $sr$ 的变化量是 $O(|S|)$ 级别的。只需要在每次插入区间时找到对应的 $sl$ 和 $sr$ 然后暴力更新直到某个位置 $sl$ 或 $sr$ 不再发生变化。

现在的复杂度瓶颈在于对于每个值 $v$，找到编号最小的 $[l_i,r_i]$ 使得其和某一个 $[sl_k,sr_k]$ 相交。一个暴力的想法是对于每个 $[sl_k,sr_k]$ 维护编号最小的与其相交的 $[l_i,r_i]$。但是存在一个问题：一个区间 $[l_i,r_i]$ 可以包含很多个 $[sl_k,sr_k]$，那么在 $[l_i,r_i]$ 被使用后需要更新很多个 $[sl_k,sr_k]$ 对应的编号，所以复杂度是假的。考虑优化，注意到若存在 $[sl_k,sr_k]$ 被 $[l_i,r_i]$ 包含，那么 $[l_i,r_i]$ 一定会被加入。在处理满足上述条件的 $[l_i,r_i]$ 后，每个 $[l_i,r_i]$ 只会对至多两个 $[sl_k,sr_k]$ 有贡献，所以复杂度正确。这时求最小编号可以用线段树维护（$[l_i,r_i]$ 与 $[sl_k,sr_k]$ 相交当且仅当 $l_i$ 或 $r_i$ 在 $[sl_k,sr_k]$ 内）。注意更新每次 $[sl_k,sr_k]$ 后需要加入新的包含其的 $[l_i,r_i]$。

综上，复杂度可以做到 $O(n\log n)$。

[代码](https://atcoder.jp/contests/joisp2025/submissions/64624657)，偷懒写的 $O(n\log^2n)$。

---

## 作者：Petit_Souris (赞：7)

难度已经远比我能独立做出的题高了。不过回顾一下，几个 trick 的叠加也并非无迹可寻。好题，值得学习。

#### Hint 1：你能编出一个多项式复杂度做法吗？

看到字典序想到逐位贪心。我们考虑从大到小枚举 $v$，把 $v$ 放在尽可能靠前的位置。

对于每个 $v$，我们按顺序尝试加入所有还没被覆盖的区间。如果加入之后，覆盖这些区间需要的点数 $C\le cnt_v$ 就是合法的。

判断最小覆盖是一个经典贪心问题，每次选择右端点最小的区间，在其右端点处放一个点即可。

#### Hint 2：每次选出的区间形态如何？

显然是一段前缀，加上一些零散的区间。这看起来是一句废话，但是我们考虑那一段前缀后面一个位置，他不能选说明加入他之后 $C>cnt_v$ 了，而由于 $C$ 的变化是连续的，这说明这个前缀加入之后 $C=cnt_v$。

这样后面的区间就必须满足加入之后，不会增加最小覆盖点数。

#### Hint 3：如何找到这个前缀？直接二分为什么不可行？

二分意味着我们花了至少序列总长的代价去删除一些元素。因此如果每次只删一个复杂度就起飞了。

但是我们可以考虑先倍增。找到最大的 $2^k$ 满足删除前 $2^k$ 个合法，接下来再在 $[2^k,2^{k+1})$ 内二分，每次暴力跑上面的贪心检验。这样我们就用 $\mathcal O(c\log ^2 c)$ 的代价删除了 $c$ 个元素。总共只删除 $m$ 个元素，因此均摊复杂度正确。

#### Hint 4：如何判断加入一个区间之后是否需要多一个点覆盖他？

这个结论应该是经典的，可惜我还没见过这样做的题目。有同学知道类似的题目可以在评论区告知我。/kt

我们考虑正反做两遍贪心，求出每个点所在的范围 $[tl_j,tr_j]$。如果 $[L_i,R_i]$ 和某一个 $[tl_j,tr_j]$ 有交，那么可以调整 $j$ 使得不增加新点。反之，需要增加一个点。

#### Hint 5：一个区间加入之后，$tl,tr$ 会发生怎样的变化？

以 $tr$ 为例。我们找到 $R_i$ 右边第一个 $tr_j$，然后一路向右，如果左端点在前面的，对应的最小右端点不到 $tr_j$ 就会一路修改下去。

这样做的修改次数实际上是 $\mathcal O(c)$ 次，因为 $tr$ 相当于保留一些区间的右端点，而一个右端点存活的时间是一段区间。

#### Hint 6：利用上面的性质编出正解。

找到前缀后，我们只需要快速找出编号最小的，可以加入的区间。

一个简单的想法是用一个小根堆维护所有的编号。这样我们每次对于一个 $tr_j$，去加入所有和他有交的区间，并贪心跑。

但是这样有一个严重的问题就是，一个区间可能会被放进去很多遍，就退化成 $\mathcal O(nm)$ 了。解决方案也很简单：把所有包含某个 $[tl_j,tr_j]$ 的 $[L_i,R_i]$ 都提前拿出来，这样剩下的区间至多放进去两遍。

找有交的最小编号可以分讨二维偏序关系，用两个线段树维护。

最后整理一下这部分的过程：

- 先得到 $tl,tr$，对于每个 $[tl_j,tr_j]$，先把所有包含他的，还未使用过的区间拎出来标记上。
- 接下来，对于每个 $[tl_j,tr_j]$，找到与其有交的最小编号，加入小根堆。
- 每次取出最小的编号，加入答案。并且重新松弛对应的 $j$，找到新的最小值。

最终时间复杂度为 $\mathcal O(n\log^2 n)$，可以通过预处理排序做到 $\mathcal O(n\log n)$。

实现上细节比较多，一定要理清楚再开始写，写完一部分 debug 掉对应的问题。[参考代码](https://atcoder.jp/contests/joisp2025/submissions/65319989)。

---

## 作者：irris (赞：2)

O：今天我们来做 *P11983 [JOIST 2025] 展览会* 吧。派对的时候，大家都说这个题是好题。

> 有一个序列 $a_1, \ldots, a_n$，请任意重排之，令 $b_i = \max(a_{l_i}, \ldots, a_{r_i})，$最大化 $b_1, \ldots, b_m$ 的字典序。$1 \leq a_i \leq n \leq 10^5$，$1 \leq m \leq 10^5$。3 秒 / 1 GB。

C：看完这个题之后，我能提出一些简单的想法，比如说 $\mathcal O(n^2m)$......只需要依次枚举每个区间对应的权值并判断即可，但是，这太暴力了，而且很难再优化了。

O：有一个部分分 $a_i = i$ 看起来很有意思。**如果每种数只出现一次，我们立刻能意识到每种数可能出现的位置只构成一个区间 $\boldsymbol{[L_x, R_x]}$**。于是相当于有 $m$ 次查询，每次查询找到最小的一个 $x$ 满足 $[L_x, R_x]$ 与 $[l, r]$ 有交并修改其为它们的交。可以用树状数组套树状数组维护信息，时间复杂度 $\mathcal O(m\log^2 n)$。

C：嗯，这听起来是一个有趣的性质了。值得一提的是，虽然 Subtask「每种值出现不超过 $5$ 次」看起来和上面的 Subtask 很接近，但每种数出现的位置并非是 $\leq 5$ 个区间，例如 $\{[1, 3], [2, 4], [4, 6]\}$，这样的区间集合的 *所有解的结构比较复杂，很难直接刻画*。

O：然而还有 $a_i \leq 5$ 的部分分......这看起来有点像根号分治题了？我相信我们可以转换一下视角——比如，对于 $a_i$ 的每种可能取值，从大到小依次确定值能取到的每个区间的集合，**只需要让这个集合的字典序尽可能小即可**。

O：那么现在的问题就是，如何在不重新运行一遍贪心算法的情况下，判定一个集合内加入某个区间后，最小点覆盖数仍然不超过 $c$ 呢？

C：我感觉，我们可以倍增二分出一个前缀，满足这些前缀的点覆盖数恰好等于 $c$。因为每次被二分出的前缀都会被删掉，所以这一部分的时间复杂度只有 $\mathcal O(m\log^2 m)$。现在，我们把原问题变成了 **判断是否加入一个新的区间，满足加入它后最小点覆盖数不变**。我希望这样的询问有更多性质......

O：你说得对。加入一个新的区间后，最小点覆盖数不变，当且仅当原先存在一种覆盖方案使得某个点在这个区间内......我们还是绕不出这 $c$ 个点的位置的取值范围。**虽然这些范围互相约束，但我们可以找出一些更宽泛的限制**：如果我们运行原先的贪心算法，从左向右可以依次找出 $x_1, \ldots, x_c$ 的上界 $r_1, \ldots, r_c$，从右向左可以依次找出 $x_c, \ldots, x_1$ 的下界 $l_c, \ldots, l_1$。

C：有趣的事情发生了——即使有互相约束的限制，$x_i$ 仍然能够取遍 $[l_i, r_i]$ 内的所有值。只需要让 $x_1, \ldots, x_{i-1}$ 全都取到 $r$，$x_{i+1}, \ldots, x_c$ 全都取到 $l$，$x_i$ 取区间内任何一个值，反证法可以说明不产生矛盾。（开始打草稿）而且似乎，在样例里，这些区间总不会相交？

O：你说的对。我们可以直接考虑原算法的流程，说明这一点。由于 $l, r$ 都单调递增，所以不存在完全包含的情况。不失一般性地，假设有区间 $[l_i, r_i]$ 和 $[l_j, r_j]$，满足 $l_i < l_j \leq r_i < r_j$。事实上，产生 $r_j$ 这个右边界界当且仅当存在某个区间 $[x, r_j]$ 满足 $x > r_i$，而这与 $l_j \leq r_i$ 是矛盾的！

C：所以如果加入了一个新的区间，我们可以简单地将其分类为这四种情况：与所有 $[l_i, r_i]$ 区间不相交；完全包含至少某个 $[l_i, r_i]$；与只有一个 $[l_i, r_i]$ 相交；与 $[l_i, r_i]$ 交于某个后缀，与 $[l_{i+1}, r_{i+1}]$ 交于某个前缀：

- 我们不希望统计第一类区间；
- 第二类区间不会对任何 $[l_i, r_i]$ 产生影响；
- 第三类区间只会对某个 $[l_i, r_i]$ 的界产生影响。
- *第四类区间......*？乍一看它不会影响任何 $[l_i, r_i]$ 的取值，因为我们之前的构造方式仍然成立。*但一旦结合后续产生的若干第三类区间，第四类区间的制约条件可能就会发生作用*，导致 $[l_i, r_i]$ 产生变化。

O：所以，**我们不妨直接把第四类区间的影响记录下来**：若 $r_i \leq p - 1$，则 $r_{i+1} \gets \min(r_{i+1}, q)$；若 $l_{i+1} \geq q - 1$，则 $l_i \gets \max(l_i, p)$。对于每一个区间的 $l$ 和 $r$ 做的对应修改，我们分别维护一个堆，第三类区间修改时，我们暴力取出堆里需要被弹出的元素并递归修改 $i \pm 1$ 即可，这样维护不会让任意时刻 $l_i > r_i$，这是因为如果如此，必然这个 $[p, q]$ 已经被触发，不可能被再次触发了。而且，容易发现这样做的均摊时间复杂度是正确的。

C：只剩下唯一的一个问题了：如果我们暴力遍历剩余的所有区间，可能会出现大量的第一类区间，导致时间复杂度退化为 $\mathcal O(nm)$。

O：这也是不难解决的。均摊分析告诉我们，整个过程只产生了 $\mathcal O(c + r)$ 个不同的 $[l_i, r_i]$，其中 $r$ 表示答案为对应 $a_i$ 的区间个数。我们可以对每个新的 $[l_i, r_i]$ 被更新时，求出「和 $[l_i, r_i]$ 区间有交且权值暂未被确定的区间 $[L, R]$ 的最小下标」。

C：这题我会！只需要分讨 $l_i \leq L \leq r_i$ 或 $l_i \leq R \leq r_i$ 以及 $L \leq l_i \leq r_i \leq R$ 两种情况即可，可以用线段树维护，整体的时间复杂度便只有 $\mathcal O((c + r)\log n)$，总复杂度 $\mathcal O((n+m)\log n)$。

O：这道很困难的题目真的就这样被我们做出来了！回顾一下我们的思考过程，感觉唯一的瓶颈在于刻画插入新的区间后，答案不变的 **充要条件**；并且需要意识到，这个条件 *有很方便的维护手段*，其它的部分都很平凡。但是，事到如今，C 君，你不会想要更进一步吗？

C：......此话怎解？

O：我们在倍增二分部分的时间复杂度达到了 $\mathcal O(m\log^2 m)$，但后面的数据结构维护却只有一个 $\log n$。你能把前半部分的做法优化掉一只 $\log$，使得两部分的时间复杂度平衡吗？

C：让我想想......原来的瓶颈在确定了新加入的区间个数在 $[2^{k-1}, 2^k)$ 并二分的时候，每次二分都需要调用一次排序。但事实上我们可以直接先对这 $2^k$ 个区间排序，然后按顺序提取出所有需要用到的区间即可。于是我们就做到了整体 $\mathcal O(m\log m + (n + m)\log n)$。

---

## 作者：Mirasycle (赞：2)

这题还是太牛了。可惜我一开始方向就错了。

题目需要重新排列 $A$，我想的是贪心一下之后一些数的位置有一些取值范围，然后是一个数和位置的匹配形式。这个很难做。

事实上，考虑如下贪心。我们从大往小枚举每一个数字 $i$，然后从前往后枚举 $b$ 序列每一个位置 $j$，根据贪心我们希望尽可能在这些位置填入当前数字。考虑动态维护对于 $i$，已经确定填 $i$ 的位置集合。尝试加入一条新线段 $[l_j,r_j]$，对于集合内部的位置所对应的线段还有当前线段，我们跑一遍最少点覆盖所有区间的贪心算法，如果需要点的个数 $\le cnt_i$，那么代表当前线段可以加入。暴力做这个过程是 $O(n^3)$ 的。

这是一个最基本的思路，而我之所以一开始就错了，是因为我认为需要看看 $A$ 序列中哪个位置被占了不能填数字了，实际上这个过程是不需要的。假设我们在 $j$ 的时候为了满足某一条线段要求而填入的位置和 $i>j$ 的 $i$ 填入位置有冲突的话，那 $i$ 早就可以提前满足过这个线段的要求了。

考虑优化，一开始 $cnt_i$ 个点必然是用不满的，所以每次跑一遍区间选点太浪费了，可以直接二分出一个前缀满足可以恰好用掉 $cnt_i$ 个的最长前缀。直接二分的复杂度是 $O(n\log n)$，对于每个 $i$ 都做的话，复杂度显然是错的了。我们希望复杂度和这次被选中区间的个数相关，这样子就可以满足复杂度均摊正确了。这里可以使用倍增，我们依次枚举长度为 $2^0,2^1\dots 2^k$ 的前缀，找到一个最大 $k$ 满足 $[1,2^k]$ 前缀是合法的，这样子对于 $i$ 的倍增求解的复杂度是 $O(ans_i\log^2 n)$，均摊正确。为了确定前缀，我们还应该在 $[2^k,2^{k+1})$ 之中找到一个比 $2^k$ 更远的位置，这个时候可以直接二分了，因为保证了长度是 $O(ans_i)$ 级别的。

找到最长前缀之后，用满了 $cnt_i$ 个点。剩下还会选一些零散线段，我们需要对于这个过程快速 check。

首先，思考如何判定能否加进去一个线段。我们跑正反两遍点覆盖区间，可以确定是每个点放置范围 $[nl_i,nr_i]$，只要当前线段 $[l_j,r_j]$ 和其中某个区间 $[nl_i,nr_i]$ 有交就可以加入线段 $j$。

问题来到了如何在加单点之后快速更改为新的 $[nl_i',nr_i']$ 信息。通过加入的新线段，我们可以通过二分查找迅速定位到影响是的哪个点范围的左端点，哪个点的右端点。

假如说我们要新加入一个右端点的限制 $R$，可以通过二分定位到需要修改某个点 $i$ 的右端点。考虑一个从左往右的贪心过程，显然 $i-1$ 以及之前的位置是不会发现改变的，根据贪心过程对于当前 $i$ 的 $nr_i$ 需要覆盖到 $\min\limits_{l_j>nr_{i-1}}r_j$，直接赋值即可。同时，由于 $i$ 的 $nr$ 信息变动了，可能会影响其右边若干点的 $nr$，所以我们需要不断找到受到影响的 $nr$ 进行修改。还是同理寻找 $\min\limits_{l_j>nr_i} r_j$ 来更新 $nr_{i+1}$，直到无法更新就退出循环。

看起来一个一个修改是很暴力的东西，其实复杂度是正确的。令 $S$ 集合代表当前选择线段的集合，还是以右端点为例，当前所有点取值范围的右端点构成的集合 $T$，其实是 $\subset \{r_i~|~i\in S \}$。上述暴力更新的过程，其实就是点进入集合的过程，同时每个点最多进入集合一次，离开集合一次（否则就还能找到更长前缀，与当前是最长前缀矛盾）。所以暴力更新的总次数是 $O(|S|)$ 的。

还剩最后一个问题，我们会了快速判定一条线段能否加入，以及快速更改加入线段之后的新信息。那么如何找到这么一条肯定能加入的线段呢，如果直接枚举，会枚举到一些不能立刻加入的线段，导致复杂度均摊不正确了。我们可以发现所有点的取值范围都是两两不交的，所以预先处理掉哪些满足完全包含住某个点取值范围的线段之后，剩下的线段都最多与两个点的取值范围有交。直接通过枚举点来找到这些线段就行了。以上操作都可以用线段树维护若干信息来完成。

时间复杂度 $O(n\log^2 n)$。代码也太难写了吧，参考了题解区的代码。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<vi,vi> pvv;
typedef pair<int,int> pii;
const int maxn=1e5+10;
const int inf=1e9;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int L[maxn],R[maxn],cnt[maxn],n,m,I;
int ans[maxn],vis[maxn],rest;
priority_queue<pii> q;
int lowbit(int x){ return x&-x; }
struct BIT1{//后缀 BIT,寻找  中 x<L R min 
	int c[maxn],st[maxn],top;
	void init(){ top=0; for(int i=1;i<=n;i++) c[i]=inf; }
	void modify(int x,int v){ st[++top]=x; for(;x;x-=lowbit(x)) cmin(c[x],v); }
	int query(int x){ int res=inf; for(;x<=n;x+=lowbit(x)) cmin(res,c[x]); return res; }
	void del(int x){ for(;x;x-=lowbit(x)) c[x]=inf; }
	void Clear(){ while(top) del(st[top--]); }
}t1;
struct BIT2{//前缀 BIT 寻找 R<x 中 L max
	int c[maxn],st[maxn],top;
	void init(){ top=0; for(int i=1;i<=n;i++) c[i]=0; }
	void modify(int x,int v){ st[++top]=x; for(;x<=n;x+=lowbit(x)) cmax(c[x],v); }
	int query(int x){ int res=0; for(;x;x-=lowbit(x)) cmax(res,c[x]); return res; }
	void del(int x){ for(;x<=n;x+=lowbit(x)) c[x]=0; }
	void Clear(){ while(top) del(st[top--]); }	
}t2;
struct DSU{
	int fa[maxn];
	void init(){ for(int i=1;i<=m+1;i++) fa[i]=i; }
	int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); }
	void del(int x){ fa[x]=x+1; }
	vi get(int x){
		vi vec; int pos=1;
		for(int i=1;i<=x;i++){
			int z=find(pos);
			if(z==m+1) break;
			vec.pb(z); pos=z+1;
		}
		return vec;
	}
}dsu;
bool cmpl(int x,int y){ return (L[x]>L[y])||(L[x]==L[y]&&R[x]>R[y]); }
bool cmpr(int x,int y){ return (R[x]<R[y])||(R[x]==R[y]&&L[x]<L[y]); }
pvv calc(vi S){
	vi sl,sr; int sz=S.size();
	sort(S.begin(),S.end(),cmpr);
	for(int i=0;i<sz;i++){
		int j=i; while(j+1<sz&&L[S[j+1]]<=R[S[i]]) j++;
		sr.pb(R[S[i]]); i=j;
	}
	sort(S.begin(),S.end(),cmpl);
	for(int i=0;i<sz;i++){
		int j=i; while(j+1<sz&&L[S[i]]<=R[S[j+1]]) j++;
		sl.pb(L[S[i]]); i=j;
	}
	reverse(sl.begin(),sl.end());
	return mp(sl,sr);
}
struct SegmentTree{
	#define mid ((l+r)>>1)
	#define ls (p<<1)
	#define rs (p<<1|1)
	int val[maxn<<2]; stack<int> v1[maxn<<2],v2[maxn];
	void pushup(int p){ val[p]=min(val[ls],val[rs]); }
	void init(){ for(int i=1;i<=4*n;i++) val[i]=inf; }
	int get1(int x){
		while(v1[x].size()&&vis[v1[x].top()]) v1[x].pop();
		if(v1[x].empty()) return inf;
		return v1[x].top();
	}
	int get2(int x){
		while(v2[x].size()&&vis[v2[x].top()]) v2[x].pop();
		if(v2[x].empty()) return inf;
		return v2[x].top();
	}
	void add(int p,int l,int r,int ql,int qr,int x){// be cantained within interval x
		if(ql<=l&&r<=qr){ v1[p].push(x); return ; }
		if(ql<=mid) add(ls,l,mid,ql,qr,x);
		if(qr>mid) add(rs,mid+1,r,ql,qr,x);
	}
	void modify(int p,int l,int r,int x,int v){// Set::{ x | L[x]=l }-> min x
		if(l==r){ v2[x].push(v); val[p]=v; return ; }
		if(x<=mid) modify(ls,l,mid,x,v);
		else modify(rs,mid+1,r,x,v);
		pushup(p);
	}
	void upd(int p,int l,int r,int x){
		if(l==r){ val[p]=get2(x); return ; }
		if(x<=mid) upd(ls,l,mid,x);
		else upd(rs,mid+1,r,x);
		pushup(p);
	}
	int query(int p,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return val[p];
		if(ql>mid) return query(rs,mid+1,r,ql,qr);
		if(qr<=mid) return query(ls,l,mid,ql,qr);
		return min(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));
	}
	int query(int p,int l,int r,int x){
		if(l==r) return get1(p);
		if(x<=mid) return min(get1(p),query(ls,l,mid,x));
		else return min(get1(p),query(rs,mid+1,r,x));
	}
	void del(int x){ vis[x]=1; upd(1,1,n,L[x]);  }
	int find(int l,int r){ assert(l<=r); return min(query(1,1,n,l),query(1,1,n,l,r)); }
}seg;
vi sl,sr;
void del(int z,int A){
	t1.modify(L[z],R[z]);
	t2.modify(R[z],L[z]);
	ans[z]=A; rest--;
	seg.del(z); dsu.del(z);	
}
bool chk(int l,int r){
	int z=lower_bound(sl.begin(),sl.end(),l)-sl.begin();
	return (z<(int)sl.size()&&sr[z]<=r);
}
bool find(int x){
	int p=lower_bound(sl.begin(),sl.end(),L[x])-sl.begin();
	if(p<(int)sl.size()&&R[x]>=sl[p]) return 1;
	if(p&&L[x]<=sr[p-1]) return 1;
	return 0;
}
void UPD(int x){
	int id=seg.find(sl[x],sr[x]);
	while(id!=inf&&chk(L[id],R[id])){
		del(id,I);
		id=seg.find(sl[x],sr[x]);
	}
	if(id!=inf) q.push(mp(-id,x));
}
void liml(int x){
	int p=lower_bound(sl.begin(),sl.end(),L[x])-sl.begin()-1;
	int New=t2.query(p+1==sl.size()?n:sl[p+1]-1);
	while(New&&p>=0){
		if(sr[p]<New||New<=sl[p]) break; sl[p]=New;
		UPD(p); New=t2.query(sl[p]-1); p--;
	}
}
void limr(int x){
	int p=upper_bound(sr.begin(),sr.end(),R[x])-sr.begin();
	int New=t1.query(p==0?1:sr[p-1]+1);
	while(New!=inf&&p<sr.size()){
		if(sl[p]>New||New>=sr[p]) break; sr[p]=New;
		UPD(p); New=t1.query(sr[p]+1); p++;
	}
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m; rest=m;
	dsu.init(); seg.init(); t1.init(); t2.init();
	for(int i=1,x;i<=n;i++) cin>>x,cnt[x]++;
	for(int i=1;i<=m;i++) cin>>L[i]>>R[i];
	for(int i=m;i>=1;i--){
		seg.add(1,1,n,L[i],R[i],i);
		seg.modify(1,1,n,L[i],i); 
	}
	for(int i=n;i>=1;i--){
		if(!cnt[i]||!rest) continue;
		int k=0; I=i;
		while((int)calc(dsu.get(1<<k)).fi.size()<=cnt[i]&&(1<<k)<=rest) k++;
		int l=(1<<(k-1)),r=min((1<<k)-1,rest);
		while(l<r){
			int M=(l+r+1)>>1;
			if((int)calc(dsu.get(M)).fi.size()<=cnt[i]) l=M;
			else r=M-1;
		}
		vi vec=dsu.get(l);
		for(auto z:vec) del(z,i);
		pvv slr=calc(vec); sl=slr.fi; sr=slr.se;
		for(int i=0;i<(int)sl.size();i++) UPD(i);
		while(q.size()){
			pii z=q.top(); q.pop();
			int id=-z.fi,x=z.se;
			if(ans[id]||!find(id)){ UPD(x); continue; }
			del(id,i);  liml(id);  limr(id); UPD(x);
		}
		t1.Clear(); t2.Clear();
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：jiamengtong (赞：1)

非常困难但是非常有趣并且非常有益的题！强烈推荐学习！

下文中假设 $N,M$ 同阶。

我们考虑如下贪心过程：按照值域从大到小扫描，每次从左向右扫描未被覆盖的区间，当前区间能加入（也就是加入后的集合点数依然够覆盖）就加入。最后把这一轮加入的所有区间覆盖为当前数值。考虑这样做的正确性：我们需要证明大的值一些数向前选不会使小的值原本可以覆盖到，且处于大的值之前的位置不会“没位置填”。由于大的值比小的值大（废话），如果大的值把位置挤掉了，小的值的限制自然满足，甚至还更大了。所以，上述贪心过程是正确的。

由这样的贪心过程，我们不难想到：每次二分求出当前剩余的区间的一个前缀，表示取到这个前缀的末尾时第一次需要用满个数完成覆盖。这个数之后能覆盖到的位置是一些零零散散的，每一次加入都不会增大需要的个数的位置。

但是这样的二分复杂度很错。问题出在：每一次 check 都需要花费剩余所有区间个数级别的代价。我们如果能只花费这一次选走的前缀的长度的级别的代价就好了！于是，我们先枚举 $2^0,2^1,\cdots 2^k$ 这些前缀长度，暴力 check 他们是否满足，直到找到第一个不满足的 $K$，再在 $[2^{K-1},2^K)$ 这一段区间里面二分即可。这样我们求前缀的这一部分复杂度由均摊保证为 $O(N\log^2 N)$。

我们求出来这一个前缀，还需要把剩下的一些零零散散的位置加进来。考察一下一个区间能加入到一个集合且不改变需要的个数的条件。我们正反跑两边最少点覆盖的贪心（按端点排序然后每次取最值跳的这一种贪心），可以得出第 $i$ 个点可以放置的区间 $[L_i,R_i]$。如果新加进来的区间与其中任意一个区间有交，则加入后集合需要的个数不变，否则无法加入。

注意到如果一个区间完全包含了一个点的区间，他必定会被加入。所以我们可以先把这些区间取出来。这样剩余的所有区间至多与两个点的区间相交。我们类似超级钢琴的做法，维护一个 set，对于每一个点的区间把所有在区间内的还未加入的区间的端点对应的区间中下标最小的那一个放入 set。由于“至多与两个点的区间相交”，我们每次修改后只需要将对应的另一个点的区间放在 set 里面的元素修改一下就行了。

但是这还没完。每次加入区间后会对 $[L_i,R_i]$ 造成影响。我们考虑对于所有的 $R_i$ 造成的影响（对于左端点的类似），首先找出第一个 $R_p$ 比当前区间右端点大的 $p$，并将 $R_p$ 修改为当前区间右端点。之后持续地向后进行类似的修改，直到没有变化产生时停止。考虑这样做的复杂度，由于 $L_i$ 全过程单调不减，$R_i$ 全过程单调不增，每一个区间的右端点在修改时如果被扔出 $R_i$ 组成的集合，它就再也不会回来了。所以每个区间至多进一次出一次，所以这部分同样由均摊保证为这一次取出的总个数级别，再均摊一下总的变化次数是 $O(N)$ 的。

这样我们就做完这一道题了。很多操作没有细说，仔细想一想都是容易线段树维护的。时间复杂度为 $O(N\log^2 N)$。

---

## 作者：Otomachi_Una_ (赞：1)

对每个 $A$ 从大到小考虑。假设对一个 $i$，答案中 $i$ 的数量为 $k$，我们想要一个 $O(k\times\operatorname{polylog}(k))$ 的复杂度求出所有这些点。这样子我们复杂度就是 $O(n\times\operatorname{polylog}(n))$。

首先考虑一个更简单的问题，我们如何维护这样的问题：

- 维护一个线段集合 $S$；
- 每次尝试加入一个线段 $i$，如果 $i∪S$ 的最小点覆盖（即标记最小的点使得每个线段至少包含一个标记点）大于 $k$ 则不加入，否则把 $i$ 加入 $S$ 当中。

我们假设 $f(S)$ 表示 $i∪S$ 的最小点覆盖。我们把这个过程分为 $f(S)<k$ 和 $f(S)=k$ 两个部分。

对于 $f(S)<k$ 的部分，我们可以直接二分算出。

对于 $f(S)=k$ 的部分，我们这样做。最小点覆盖中，第 $i$ 个点的坐标是 $x_i$（$1\leq i\leq k$，$x_1\leq x_2\leq\dots\leq x_k$）。显然每个 $x_i$ 的取值范围是一个区间。更具体地，我们可以枚举 $i=1,2,\dots,k$ 每次尝试把 $i$ 往最右边放（即找到一个当前右端点最小且没有被覆盖的线段），这样子得到的 $xl_i$ 就是最大的。反过来得到的 $xr_i$ 就是最小的。那么所有合法的 $x_i$ 一定满足 $x_i\in [xl_i,xr_i]$。容易说明这个区间中所有点都能取到。我们还会发现每个 $xr_i<xl_{i+1}$。

考虑我们实时维护每个 $xl_i,xr_i$。考虑加入一个线段 $[l,r]$。

-  如果 $[l,r]$ 和 $[xl_i,xr_i]$ 完全无交。那么肯定加入不了。否则我们可以让其加入 $S$。接下来我们考虑 $[xl_i,xr_i]$ 的变化。
- 如果存在 $[xl_i,xr_i]\subset[l,r]$。那么 $[l,r]$ 肯定经过这个标记点，产生不了影响。否则和 $[l,r]$ 有交的 $[xl_i,xr_i]$ 数量不会超过 $2$；
- 如果 $[l,r]$ 只和一个 $[xl_i,xr_i]$ 有交。那么 $[xl,xr]$ 和 $[l,r]$ 求交即可；
- 否则，$[l,r]$ 同时和 $[xl_i,xr_i],[xl_{i+1},xr_{i+1}]$ 有交而不包含。这时候我们打一个标记，形如：当 $xr_i<r$ 时，$xr_{i+1}$ 应当和 $r$ 去 chkmin，对另一边类似。我们使用优先队列维护这些标记。当每次 $xl/xr$ 产生变化的时候去释放这些标记即可。

这样子做，复杂度是 $O(n\log n)$ 的。

但是我们想要复杂度是 $O(ans\times\operatorname{polylog}{ans})$。

首先是第一部分可以换成倍增二分，复杂度是 $O(n\log^2 n)$。

然后第二部分。我们通过线段树能支持快速维护加入、删除某个带权线段。查询给定一个线段，查询和这个线段相交的线段里面权值最小的。我们可以枚举 $xl_i,xr_i$，找到和其相交的最小编号线段，并将其从线段树中取出，塞进有限队列里面。然后对优先队列里面的元素按照上面的做法做即可即可。这里复杂度是 $O((n+k)\log n)$ 的。

---


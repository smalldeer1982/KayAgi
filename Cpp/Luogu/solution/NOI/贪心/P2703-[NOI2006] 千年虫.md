# [NOI2006] 千年虫

## 题目描述

千年虫是远古时代的生物，时隔几千万年，千年虫早已从地球上销声匿迹，人们对其知之甚少。考古生物学家最近开始对其有了兴趣，因为一批珍贵的千年虫化石被发现，这些化石保留了千年虫近乎完整的形态。

理论科学家们根据这些化石归纳出了千年虫的一般形态特征模型，并且据此判定出千年虫就是蜈蚣的祖先！但科学家 J 发现了实际与理论的一些出入，他仔细的研究了上百个千年虫化石，发现其中大部分千年虫的形态都不完全符合理论模型，这到底是什么因素造成的呢？理论科学家 K 敏锐的指出，千年虫的形态保存在化石中很有可能发生各种变化，即便最细微的变化也能导致它不符合模型。

于是，摆在科学家面前的新问题诞生了：判断一个化石中的千年虫与理论模型的差距有多大？具体来说，就是根据一个千年虫化石的形态 $A$，找到 一个符合理论模型的形态 $B$，使得 $B$ 是最有可能在形成化石时变成形态 $A$。理论学家提出的“千年虫形态特征模型”如下（如左图所示）：躯体由头、尾、躯干、足四大部分构成。

![](https://cdn.luogu.com.cn/upload/pic/1876.png)

- 头，尾用一对平行线段表示。称平行于头、尾的方向为 $x$ 方向；垂直于 $x$ 的方向为 $y$ 方向；

- 在头尾之间有两条互不相交的折线段相连，他们与头、尾两条线段一起围成的区域称为躯干，两条折线段都满足以下条件：拐角均为钝角或者平角，且包含奇数条线段，从上往下数的奇数条垂直于 $x$ 方向。

- 每条折线段从上往下数的第偶数条线段的躯干的另一侧长出一条足，即一个上、下底平行于 $x$ 方向的梯形或矩形，且其中远离躯干一侧的边垂直于 $x$ 方向。

注意：足不能退化成三角形（即底边的长度均大于零），躯干两侧足的数目可以不一样。（如上图，左边有 $4$ 条足，右边有 $5$ 条足）

可见，$x$-$y$ 直角坐标系内，躯干和所有足组成的实心区域的边界均平行或垂直于坐标轴。为了方便，我们假设所有这些边界的长度均为正整数。因此可以认为每个千年虫的躯体 都由一些单位方格拼成。每个单位方格都由坐标 $(x,y)$ 唯一确定。设头尾之间的距离为 $n$，则我们可以用 $2\times n$ 个整数来描述一条千年虫 $B$（如右图）：将 $B$ 沿平行 $x$ 轴方向剖分成 $n$ 条宽度为 $1$ 的横条，每个横条最左边一格的 $x$ 坐标设为 $L_i$，最右一格的的 $x$ 坐标设为 $R_i$。则  $(n,L_1,L_2,\dots,L_n,R_1,R_2,\dots,R_n)$ 就确定了一条千年虫。

由于岁月的侵蚀，在实际发现的化石中，千年虫的形状并不满足上面理论模型的规则，一些格子中的躯体已经被某些矿物质溶解腐蚀了。地质、物理、生物学家共同研究得出：

- 腐蚀是以格子为单位的，只能一整格被腐蚀；

- 腐蚀是分步进行的，每一步只有一格被腐蚀；

- 如果去掉一个格子后躯体不连通了，那么这个格子当前不会被腐蚀；

- 如果一个格子的左边邻格和右边邻格都还没被腐蚀，那么这个格子当前不会被腐蚀；

- 与头相邻的格子不能全部被腐蚀，与尾相邻的格子不能全部被腐蚀。

倘若满足上面五条，我们仍然可以用 $(n,L_1,L_2,\dots,L_n,R_1,R_2,\dots,R_n)$ 来描述一个化石里头的千年虫的形态。其中 $L_i\le R_i$。

![](https://cdn.luogu.com.cn/upload/pic/1879.png)

例如下图：

![](https://cdn.luogu.com.cn/upload/pic/1878.png)

现在你的任务是，输入一个化石里的千年虫的描述 $A$，找一个满足理论模型的千年虫的描述 $B$，使得 $B$ 可以通过腐蚀过程得以变为 $A$，且由 $B$ 转化为 $A$ 的代价（须被腐蚀的格子数）最少。输出此最小代价。

## 说明/提示


【样例说明】

如图：

![](https://cdn.luogu.com.cn/upload/pic/1877.png)

【评分方法】

本题没有部分分，你的程序的输出只有和我们的答案完全一致才能获得满分，否则不得分。

【数据范围】

对于 $30\%$ 的数据，$n\le100$，$R_i\le100$；

对于 $50\%$ 的数据，$n\le1000$，$R_i\le1000$；

对于 $70\%$ 的数据，$n\le10 ^ 5$，$R_i\le 1000$；

对于 $100\%$ 的数据，$1\leq n\le10 ^ 6$，$0\le L_i\le R_i\le10 ^ 6$。

## 样例 #1

### 输入

```
7
4 4
3 4
3 5
1 3
2 2
2 4
3 3```

### 输出

```
3```

# 题解

## 作者：jiqimao (赞：30)

我们注意到这个题本质是给定一个序列 $a_i$，然后需要给每个 $a_i$ 加上一个非负整数得到序列 $b_i$，使得最后的序列满足这样的条件：

可以将整个序列分成奇数段，使得一段内的数都相等，且相邻两段之间满足 $<,>,<,...>$ 的关系。即形成谷，峰，谷，峰...，谷这样的形式。

然后要最小化加上的数的和。

做法什么的可以看别的题解，这里主要证明一下结论。

结论是一定存在一组最优的 $b_i$ 满足对于任意 $i$，$\exists j,|i-j|\leq 2,b_i\in[a_j,a_j+1]$（网上写的结论是 $[a_j,a_j+2]$，我是证的过程中发现结论实际上更强。）

我们首先考虑一下如果每段长度都是 $1$（即相邻两数都不相等），那么有显然的结论：若 $i$ 在谷，那么 $b_i=a_i$，若 $i$ 在峰，那么 $b_i=\max(a_i,a_{i-1}+1,a_{i+1}+1)$。因为一个谷的位置我们一定不会给它加，而峰的位置只要加到比相邻两数大即可。

然而现在麻烦的地方在于段长度不为 $1$ 的时候。

我们的思路是先随便考虑一个合法的解，然后来改造它使得代价不增并使它满足一些特殊的性质。

对于一个 $b_i=a_i$ 的位置，我们称它为**固定点**，对于一个 $b_i\in [a_i,a_i+1]$ 的位置，我们称它为**弱固定点**。

下面讨论的段都是长度 $>2$ 的段。

首先考虑段的两端，对于谷，若它某一端不是固定点，那么可以让这个数减一，段中与它相邻的数加一。对于峰，若它某一端里面一个数不是固定点，那么可以让这一端加一，里面那个数减一。

然后考虑段的内部。

对于谷，我们考虑找到内部相邻的三个位置，满足中间的位置不是弱固定点。那么我们可以让中间这个位置减二，其他两个位置加一。

对于峰，我们考虑找到内部相邻的三个位置，满足两边的位置都不是固定点。那么我们可以让中间这个位置加二，其他两个位置减一。

画画图就可以知道我们的这些操作都不改变解的合法性。不停地做这些操作，直到无法操作时，可以发现对于长度 $>2$ 的段内部的数都满足上面提到的结论了。

然后我们把同一段看作一个数，它新的值 $a'_i$ 是段内 $a_i$ 的 $\max$。这时我们发现一段 $[l,r]$ 的 $a'_i$ 满足 $a'_i=\max(a_l,a_{l+1})=\max(a_{r-1},a_r)$

因为对于长度为 $2$ 的段显然，而长度大于 $3$ 的段经过上面的操作一定在与端点距离 $\leq1$ 的位置存在固定点。

我们现在只关心长度为 $2$ 的段..那么谷显然满足结论，因为 $a_i=\max(a_i,a_{i+1})$ 或 $\max(a_{i-1},a_i)$，而对于长度为 $2$ 的段构成的峰，如果这个峰取到了自己的 $a'$，那么满足条件，否则仍然有一点棘手。

我们现在约定这个峰被它右边的谷限制。即右边的 $a'$ 比较大。那么看起来当右边的谷长度为 $2$ 时，峰中的左元素与谷中的固定点会相距 $3$..当然证到这里仍然得到了取值个数为常数，只不过稍微弱了一点。但是我们并不满足。

考虑如果峰中的右元素不是固定点，那么我们可以让峰中的右元素减一，谷中的左元素加一，此时峰的长度就减一，变成长度为 $1$ 的峰。此时因为原来满足 $b=a'+1$，容易发现仍然满足条件。做不了这个操作的峰一定满足右元素是固定点，那么就满足性质了。
（这里注意一下每次我们操作完之后段的形态会变化，我们需要重新求 $a'$ 然后得到新答案）

我们来总结一下：

长度为 $1$ 谷：$b_i=a_i$

长度为 $2$ 谷：$\exists j,|i-j|\leq 1,b_i=a_j$

长度 $>2$ 谷：$\exists j,|i-j|\leq 1,b_i=a_j$ 或 $b_i\in[a_i,a_i+1]$

长度为 $1$ 峰：$\exists j,|i-j|\leq 2,b_i\in [a_j,a_j+1]$

长度为 $2$ 峰：$\exists j,|i-j|\leq 1,b_i=a_j$

长度 $>2$ 峰：$\exists j,|i-j|\leq 1,b_i=a_j$

综上，对于任意 $i$，$\exists j,|i-j|\leq 2,b_i\in[a_j,a_j+1]$。

---

## 作者：xiwang (赞：23)

~~这破玩意肯定过不了审~~

DP+黑科技优化

首先左右互不干扰，所以我们先处理右边在把左边坐标处理一下（见代码）

跑一样的破玩意就好了

令f[i][j][k]表示处理到i，第i行长为j，最后状态是凹/凸的最小代价

转移：f[i][j][k]=min(f[i-1][j-1][k],f[i-1][p][1-k])(p<j&&s==1 || p>j&&k==0)

然后你把这个东西写出来交上去就TLE~~身败名裂~~了

然后我们考虑怎么优化这个东西

令g[i]表示目前这一半i位置上的高度

很容易发现，每次转移的时候，真正有用j的只有一小部分

就g[c]~g[c]+2(i-2<=c<=i+2)这一小段

怎么证明？

当然是靠~~数学知识证~~打表找规律啊！

打几个表，大胆猜测这个结论，然后j的枚举范围就是有限的了

然后复杂度就是线性的了，然后就A了

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000000+10;
const int inf=0x3f3f3f3f;
typedef long long ll;
typedef double ddf;
int n,m;
int l[N],g[N],f[2][N][2],pr,nt;
int t[2],s[2][N];
int ass;
void fuck(){
	memset(f,0x3f,sizeof(f));
	t[1]=0;
	for(int j=1;j<=3;j++){
		for(int k=g[j];k<=g[j]+2;k++){
			if(k>=g[1])s[1][++t[1]]=k;
		}
	}
	for(int i=1;i<=t[1];i++)f[1][i][0]=s[1][i]-g[1];
	pr=0,nt=1;
	for(int i=2;i<=n;i++){
		pr^=1,nt^=1;t[nt]=0;
		int lf=max(1,i-2),rf=min(n,i+2);
		for(int j=lf;j<=rf;j++){
			for(int k=g[j];k<=g[j]+2;k++){
				if(k>=g[i])s[nt][++t[nt]]=k;
			}
		}
		for(int j=1;j<=t[nt];j++){
			f[nt][j][1]=f[nt][j][0]=inf;
			for(int k=1;k<=t[pr];k++){
				if(s[pr][k]>s[nt][j])f[nt][j][0]=min(f[nt][j][0],f[pr][k][1]);
				else if(s[pr][k]<s[nt][j])f[nt][j][1]=min(f[nt][j][1],f[pr][k][0]);
				else f[nt][j][0]=min(f[nt][j][0],f[pr][k][0]),f[nt][j][1]=min(f[nt][j][1],f[pr][k][1]);
			}
			f[nt][j][0]+=s[nt][j]-g[i];
			f[nt][j][1]+=s[nt][j]-g[i];
		}
	}
	int re=inf;
	for(int i=1;i<=t[nt];i++)re=min(re,f[nt][i][0]);
	ass+=re;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&l[i],&g[i]);
	fuck();
//	cout<<ass<<endl;
	for(int i=1;i<=n;i++)g[i]=N-l[i];
	fuck();
	printf("%d",ass);
	return 0;
}
/*
7
4 4
3 4
3 5
1 3
2 2
2 4
3 3
*/
```

---

## 作者：Fleeing_loser (赞：11)

[题目链接](https://www.luogu.com.cn/problem/P2703)

## 题意简述

好像是删格子，但是不难发现这个千年虫把格子分成了左右两部分，我们不考虑千年虫，题目就是在左右两边加上一些格子，是左右两边都是梳子形状，求最少加几个格子。

## 具体做法

因为左右两边相对独立,所以可以单独计算两边。

设第i行的初始高度为 $a_i$;

最终高度为 $b_i$;

$f(i,j,s)$ 表示前i行中当前行最终高度为 $j$，凹凸性为 $s$($s=0$ 是凹，$s=1$ 是凸）所需要加的最少块数。

可得：
$f(i,j,s)=\min\{f(i-1,j-1,s),f(i-1,k,1-s)\}(k<j,s=1;k>j,s=0)$;

这样的复杂度是 $O(n^3)$ 的，大部分测试点肯定会超时，可以预处理一下，然后复杂度就会变为 $O(n^2)$，应该可以得到一半的分。

一半分的代码我就不放了。

那么如何才能拿到满分呢？

我们发现，每行的最优值只会在所有的开区间 $a_{p},a_{p}+2(\left\vert p-i \right\vert \le 2)$ 中产生，其实在我们可以证得无论两边的大小于关系是否大于二，都会满足这个性质（详细见下），用它来优化 $j$ 的枚举边界，$j$ 的有限个状态可以让复杂度变到 $O(n)$。

小于时最优值 $b_{i}$ 会满足 $\left\vert p-i \right\vert \le 1,b_{p}\in a_{p},a_{p}+2$;

大于时会满足 $\left\vert p-i \right\vert \le 2,b_{p}\in a_{p},a_{p}+2$;

所以满足以上结论。

然后就可以愉快的过题了！
### 100pts code
```cpp
/*
这次不卡常也跑得飞快！
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000001,INF=0x3f3f3f3f;
int n,ans,l[maxn],a[maxn],f[2][20][2],q[2][maxn],p[2];
void work()
{
	memset(f,0x7f,sizeof(f));
	p[1]=0;
	for(int j=1;j<4;++j)
	{
		for(int k=a[j];k<a[j]+3;++k)
		{
			if(k>=a[1]) q[1][++p[1]]=k;
		}
	}
	for(int i=1;i<=p[1];++i)
	{
		f[1][i][0]=q[1][i]-a[1];
	}
    int u=1,v=0;
    for(int i=2;i<n+1;++i)
    {
        u^=1;v^=1;
		p[u]=0;
       	int x=(i-2<1)?1:i-2,y=(n<i+2)?n:i+2;
       	for(int j=x;j<y+1;j++)
       	{
       		for(int k=a[j];k<a[j]+3;k++)//根据以上性质优化
       		{
       			if(k>=a[i]) q[u][++p[u]]=k;	
			}
		}
		for(int j=1;j<=p[u];++j)
		{
			f[u][j][1]=f[u][j][0]=INF;
			for(int k=1;k<=p[v];++k)
			{
				if(q[v][k]>q[u][j]) f[u][j][0]=min(f[u][j][0],f[v][k][1]);
				else
				{
					if(q[v][k]<q[u][j]) f[u][j][1]=min(f[u][j][1],f[v][k][0]);
					else
					{
						f[u][j][0]=min(f[u][j][0],f[v][k][0]);
						f[u][j][1]=min(f[u][j][1],f[v][k][1]);
					}
				}	
			}
			f[u][j][0]+=q[u][j]-a[i];
			f[u][j][1]+=q[u][j]-a[i];
		}
	}
	int tmp=INF;
	for(int i=1;i<=p[u];++i)
	{
		tmp=min(tmp,f[u][i][0]);
	}
	ans+=tmp;
}
signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d",&l[i],&a[i]);
	}
	work();//同样是分左右两部分操作
	for(int i=1;i<=n;++i)
	{
		a[i]=maxn-l[i];
	}
	work();
	printf("%d",ans);
	return 0;
}
```
**思路来自[这里](https://blog.csdn.net/qq_25471829/article/details/46299733)**

---

## 作者：Submerge (赞：6)

左右可以分开搞

然后就是要形成一个类似梳子的东西

设$f_{0 or 1,i,j}$

$0$ 凹,$1$ 凸，$i$ 为行，可以滚一维，$j$ 为该行长度

$$f_{0,i,j}=min(f_{0,i-1,j},f_{1,i−1,k})+j−a_i$$

其中$k>j$ 。

$$f_{1,i,j}=min(f_{1,i−1,j},f_{0,i−1,k})+j−a_i$$

其中$k<j$ 。

~~然后是O(n3)优化可以变成O(n2) 可以有50~~

$code$
                                                     
```cpp 
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
inline const int Get_Int() {
    int num=0,bj=1;
    char x=getchar();
    while(x<'0'||x>'9') {
        if(x=='-')bj=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9') {
        num=num*10+x-'0';
        x=getchar();
    }
    return num*bj;
}
int n,f[2][1000005][2],g[2][1000005],Length[1000005],Left[1000005],Right[1000005],cnt[2],Value[2][1000005],MinRight=0x7fffffff/2,MaxLeft=0;
int Dp() {
    memset(f[1],0x3f,sizeof(f[1]));
    memset(g,0,sizeof(g));
    cnt[1]=0;
    for(int i=1; i<=3; i++)
        for(int j=Length[i]; j<=Length[i]+2; j++)
            if(j>=Length[1])Value[1][++cnt[1]]=j;
    for(int i=1; i<=cnt[1]; i++)f[1][Value[1][i]][0]=Value[1][i]-Length[1]; 
    for(int i=2; i<=n; i++) {
        cnt[i%2]=0;  
        int st=max(1,i-2),ed=min(n,i+2);
        for(int j=st; j<=ed; j++)
            for(int k=Length[j]; k<=Length[j]+2; k++)
                if(k>=Length[i])Value[i%2][++cnt[i%2]]=k; 
        for(int t=1; t<=cnt[i%2]; t++) {
            int j=Value[i%2][t];
            g[i%2][j]=g[i%2][j]=i; 
            f[i%2][j][0]=f[i%2][j][1]=0x7fffffff/2; 
            if(g[((i-1+2)%2)][j]==i-1||i==2) { 
                f[i%2][j][0]=min(f[i%2][j][0],f[(i-1+2)%2][j][0]+j-Length[i]);
                f[i%2][j][1]=min(f[i%2][j][1],f[(i-1+2)%2][j][1]+j-Length[i]);
            }
            for(int s=1; s<=cnt[(i-1+2)%2]; s++) {
                int k=Value[(i-1+2)%2][s];
                if(g[((i-1+2)%2)][k]==i-1||i==2) { 
                    if(k<j)f[i%2][j][1]=min(f[i%2][j][1],f[(i-1+2)%2][k][0]+j-Length[i]);
                    if(k>j)f[i%2][j][0]=min(f[i%2][j][0],f[(i-1+2)%2][k][1]+j-Length[i]);
                }
            }
        }
    }
    int Min=0x7fffffff/2;
    for(int j=1; j<=cnt[n%2]; j++)Min=min(Min,f[n%2][Value[n%2][j]][0]);
    return Min;
}
int main() {
    n=Get_Int();
    for(int i=1; i<=n; i++) {
        Left[i]=Get_Int();
        Right[i]=Get_Int();
        MaxLeft=max(MaxLeft,Left[i]);
        MinRight=min(MinRight,Right[i]);
    }
    for(int i=1; i<=n; i++)Length[i]=MaxLeft-Left[i];
    int ans=Dp();
    for(int i=1; i<=n; i++)Length[i]=Right[i]-MinRight;
    printf("%d\n",ans+Dp());
    return 0;
}

```


---


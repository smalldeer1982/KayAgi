# 太极剑

## 题目描述

在学习太极之后，Bob 要求 Alice 教他太极剑。Alice 告诉他首先需要通过一项基本剑术测试。测试要求 Bob 尽可能快地切断 $n$ 根绳子。

所有绳子的端点两两不同，所以共有 $2n$ 个端点。这些端点被捆在一个圆上，等距离分布。我们把这些端点按顺时针方向编号为 $1$ 到 $2n$。

Bob 每次切割的轨迹是一条直线，可以将所有与这条直线相交的绳子切断，他想知道至少多少次可以切断所有的绳子。

## 说明/提示

样例一解释：![](https://cdn.luogu.com.cn/upload/pic/19179.png)

样例二解释：![](https://cdn.luogu.com.cn/upload/pic/19180.png)

样例三解释：![](https://cdn.luogu.com.cn/upload/pic/19181.png)

## 样例 #1

### 输入

```
2
1 2
3 4```

### 输出

```
1```

## 样例 #2

### 输入

```
3
1 2
3 4
5 6```

### 输出

```
2```

## 样例 #3

### 输入

```
3
1 3
2 4
5 6```

### 输出

```
1```

# 题解

## 作者：p878567 (赞：22)

在正式写题解之前，先抨击一下已有的题解：

@Loi_bibo TLE

@Ofnoname $O(dn)$，显然TLE

@yi_heng 说是$O(n)$的，实际上可以卡成$O(n^2)$，具体卡法见附注。

@lokiii 证明和结论都是错的，卡法见附注。

~~出题人的数据真弱~~

现在说我的解法：~~放心，下面两个都能通过，如果再次被卡可以用各种手段告知我~~

实际上前面几份题解虽然是错的，但找出最短距离并枚举这一段上的起点是必要的，这里要解决的是怎样用$O(n/d)$的时间（前面的问题就是用$O(n)$的时间）统计分割点的最小数量，这样就能保证复杂度为$O(n)$。

不妨设最短点对是$1\sim d$，并记连接$i$与$i+1$（$\!\mod 2n$意义下，下同）的弧编号为$i$。假定我们选择从$i$（弧）处断开，那么由最短性可知$1\sim i-1$的弧无需断开，因此仅需考虑$i\sim2n$的弧。这个问题的$O(n)$做法可以贪心（断开处必选，其余位置尽可能后移），考虑维护这个贪心。

首先断开弧$2n$（但不是完全断开，见下）
![](https://cdn.luogu.com.cn/upload/image_hosting/wmehl7qr.png)

---
从该分割线起，所有边均指不包含弧$n$的部分

引理：设边$(l1,r1)$，$(l2,r2)$满足$l1<l2<r1<r2$，则删除边$(l1,r1)$对答案无影响。

这是因为边$(l2,r2)$中有分割点时边$(l1,r1)$中一定有分割点。

这样，我们可以过滤掉可以对答案无影响的边，这样就能按两端点同时增序枚举这些边。

定义$f_i$表示按照贪心策略在弧$i$上选取分割点后（假设所有左端点小于等于$i$的弧上均已有分割点），下一个分割点的位置。

考虑相邻的两条边$(l1,r1)$,$(l2,r2)$，那么编号在$[l1,l2)$的弧对应的$f$值为$r2-1$。（画个图理解一下）

我们考虑按编号从$1$到$d-1$的顺序枚举第一个分割点。那么这个分割点前面是找不到完整的一条边的（否则$d$就不是最短距离了），这样每次从$i$跳到$f_i$，复杂度为$O(n/d)$（即分割点的数量上限），完结。

---
其实还差一点：我们错误地忽略了包含弧$2n$的边。

如果两端点都不在$[1,d]$的范围内，显然不用考虑。

如果都在，这是不可能的。

假定在$[1,d]$范围内的端点编号为$x$，那么$x>i$时不用考虑，把$x=i$的边插入后维护$f$多出的最后一段即可。

由于$f$中的每一个值只会被求一次，因此复杂度是$O(n)$的。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int read() {
	char c=getchar();while(!isdigit(c))c=getchar();
	int num=0;while(isdigit(c))num=num*10+c-'0',c=getchar();
	return num;
}
int m[1000001];
int f[400001];
int main() {
	int n = read();
	int dis = n * 2, lp, rp;
	for (int i = 1; i <= n; i++) {
		int a, b;
		a = read(), b = read();
		if (a > b) swap(a, b);
		m[a]=b, m[b]=a;
		m[a+n*2]=b, m[b+n*2] = a;
		if (b - a < dis)
			dis = b - a, lp = a, rp = b;
		if (a + n * 2 - b < dis)
			dis = a + n * 2 - b, lp = b, rp = a + n * 2;
	}
	for (int i = 1; i <= n * 2; i++) m[i]=m[i+lp-1];
	int d = rp - lp + 1;
	int pt = 0, last = 1;
	for (int i = d + 1; i <= n * 2; i++)
		if (m[i] < i && m[i] > last) {
			for (int j = last; j < m[i]; j++) f[j] = i - 1;
			last = m[i];
		}
	int ans = n;
	for (int i = 1; i < d; i++) {
		if (m[i] > last) {
			for (int j = last; j < m[i]; j++) f[j] = n * 2;
			last = m[i];
		}
		int p = i, cnt = 0;
		while (p) {
			p = f[p];
			++cnt;
		}
		ans = min(ans, cnt);
	}
	cout << (ans + 1) / 2 << endl;
}
```

附注：

1.卡掉@yi_heng的数据：
```
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n = 200000;  //必须是偶数
	cout << n << endl;
	cout << 1 << ' ' << n / 2 + 1 << '\n';
	cout << n + 1 << ' ' << n * 3 / 2 + 1 << endl;
	int p = 2, q = n + 2;
	while (p <= n / 2) cout << p++ << ' ' << q++ << endl;
	p = n / 2 + 2, q = n * 3 / 2 + 2;
	while (p <= n) cout << p++ << ' ' << q++ << endl;
}
```

2.卡掉@lokiii的数据：
```
10
1 6
5 10
11 16
15 20
2 9
3 8
4 7
12 19
13 18
14 17
```
正解：1，输出：2


---

## 作者：accgj_ (赞：6)

[题目链接](https://www.luogu.com.cn/problem/P4704)

### 前言


------------
写到一半不知道怎么证明自己的方案，感觉题解讲得都不是很清楚（~~其实是我自己蒻看不懂~~），现在自己大概懂了就来写一篇 ~~（上课摸鱼）~~。


### 题意

给出 $n$ 条端点在圆上的线段，用最少条直线使得所有的线段都被经过。


### 正文

------------
首先其他题解讲的“割点”显然是要去考虑的，即直线在圆上的交点位置，问题在于怎么选割点是最优的，以及为什么是最优的。

首先显然，对于圆上的任意四个割点，交叉相连必然优于不交（可以自己手模被切断的线段的区间来证明），然后还能证出这四个割点顺次连任意三条都与交叉相连是等效的，如图（对于割点编个号）。

![](https://cdn.luogu.com.cn/upload/image_hosting/j16jilbx.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

那么显然，两种连法都只留下了四种线段没有被切断，那就是端点都在上图的四个割点之间中的线段。而左图中的三条线任意删一条都会使得可能会有更多的线段被放过，所以我们对于任意一种合法的切割方案，都可以转化成求条数最少的首尾相连的方案，这样题目就简单了许多（显然对于每一种首尾相连的合法方案都可以转换成一种类似右图的方案，如果割点有奇数个，剩下一个可以直接顺次连）。

那就要考虑怎么求最少割点了。

其他题解都把这个搬到了序列上，不过这里先不急，还是在圆上考虑。

![](https://cdn.luogu.com.cn/upload/image_hosting/cv0xk3dg.png?x-oss-process=image/resize,m_lfit,h_510,w_675)


这里我们把割点的位置看作某个端点的逆时针的一段上的任意一个点，因为这样不会有冲突并且不会漏算。

然后因为每一个线段的两侧都必然各有割点存在，所以找最短的那条线段的较窄侧枚举初始的割点（这张图显然是 $(5,7)$ 这条线段），设这一段的长度为 $l$ ，这张图就是 $2$ 。

对于每一个割点，位置为 $i$ ，下一个割点必然是在 $(i+l)\bmod 2n$ 之后，这个其他题解也是证了的，就是 $(i+1)\bmod 2n$ 到 $(i+l-1)\bmod 2n$ 这一段的点，如果它作为一个割点，那么必然可以在把它挪得更远的同时保证更优，因为不会有更短的线段，所以不会有线段只能由这种方式切到。

然后就考虑枚举到一个什么样的点放置割点，那就是找到第一个会被新割点与旧割点的连线所切断的线段的右端点（这样不劣，理由同上，没有线段比枚举的这一段短），如果一条线段的端点没有被选为割点，那么它必然会在某一时刻被“误伤”割掉，证明显然，下一个割点要么是这条线段另一侧都某个点，这样它就被割断了。

![](https://cdn.luogu.com.cn/upload/image_hosting/utyjeqzj.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

要么就是这条线段的另一个点，因为这个时候作判断就是能够被割断了。

![](https://cdn.luogu.com.cn/upload/image_hosting/n4ze7q5s.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

如果两种都不是，那么说明这条线段的另一个点在起点的另一侧，这样才不会被枚举到。

![](https://cdn.luogu.com.cn/upload/image_hosting/at47enin.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

但是这样的话，在枚举前面的点的时候，这条线段就会被割掉，可能是该线段的前一个点作为割点，也可能是中间的某一个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/755kbgyq.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

所以正确性没问题，而优不优的问题则很简单：如果一条点能选但不选，那么这条线段就没有被割掉了，就不满足条件了。

那么这样就求出了最少的割点个数，那么就可以把这些割点换一种方案连（前文提到过），使得不劣且答案数最少，就做完了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct asd
{
	int l,r;
}a[1000001];
int x1,minn=INT_MAX;
int las[1000001];
int ans=INT_MAX;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].l,&a[i].r);
		if(a[i].l>a[i].r)swap(a[i].l,a[i].r);
		a[i+n].l=a[i].r;a[i+n].r=a[i].l+2*n;
		las[a[i].r]=a[i].l;las[a[i].l+2*n]=a[i].r;
		las[a[i].r+2*n]=a[i].l+2*n;//因为只枚举一圈，所以只会碰到刚好两个。
		if(minn>min(a[i].r-a[i].l,a[i].l+2*n-a[i].r))
		{
			minn=min(a[i].r-a[i].l,a[i].l+2*n-a[i].r);
			x1=i;
		}//找最短的那条线段来枚举，这是答案的正确性保证。
	}
	if(a[x1].r-a[x1].l<a[x1].l+2*n-a[x1].r)
	{
		for(int i=a[x1].l+1;i<=a[x1].r;i++)
		{
			int num=1,fro=i;
			for(int j=i+a[x1].r-a[x1].l;j<=a[x1].l+2*n;j++)
			{
				if(las[j]>fro)num++,fro=j,j+=a[x1].r-a[x1].l;
			}
			ans=min(ans,num);
		}
	}
	else
	{
		for(int i=a[x1].r+1;i<=a[x1].l+2*n;i++)
		{
			int num=1,fro=i;
			for(int j=i+a[x1].l+2*n-a[x1].r;j<=a[x1].r+2*n;j++)
			{
				if(las[j]>fro)num++,fro=j,j+=a[x1].l+2*n-a[x1].r;
			}
			ans=min(ans,num);
		}
	}
	printf("%d\n",(ans+1)/2);//割点之间两两连边，偶数个割点可以满足不存在两条不相交的线，奇数个就把剩下的那个顺次连上。
	return 0;
}
```


后注：最后一篇题解给出的数据我过不了，但是他的数据不符合题目的输入格式，要求是绳子的端点两两不同，这样每一个点都有它对应的另一个端点，而这个是我的代码的正确性保证之一。

---

## 作者：Fish_Clever (赞：6)

在正式写题解之前，先抨击一下已有的题解:(doge

@01190220csl 样例 $3$ 过不去。

@Lumos壹玖贰壹 拍了一下，被一个小数据搞挂了:

```
3
2 1
2 3
5 3

应该输出 2，而不是 1。
```

但这两篇讲的还行，希望管理员不要将其撤回。(本文中有部分内容为对这两篇的说明)

### 以下为正文：

先将环断成链，且就让一个绳子变成了两个区间，而不是三个，为 $[l,r]$ 和 $[r,l+len]$，其中 $len$ 为 $2n$。


切的两刀不可能相互包含，这样肯定没有交错更优——非常容易证明，若你证不出这个，请退出。

以下叙述中，刀所切出的点位置为每一个段的中间(反正不是边界就行)，你可以视为 $1.5$，$2.5$ 之类的位置。

假设每一刀产生一种颜色的两个点，不同两刀所产生点的颜色不一样，目的是使得最终每个绳子所转化的俩区间内都至少有一个点，**最后再一起将其染色**——为达到交错的目的，可考虑"循环"染色，如进行 $123123$ 染色，这时，一个绳子的俩区间由于加起来含有了全部颜色，比如说 $[23],[1231]$，肯定能找到一个颜色出现在两个区间里。

问题就变成了，选择最少的点覆盖全部区间。

注：若出现最少点为奇数的情况，要 $+1$，结果为点的个数除以 $2$。

但是，这个题和经典题目的区别在于——这是个环。你模拟下样例 $1$ 就会发现：当选了切点 $1$ 后(即 $1.5$)，绳子 $[3,4]$ 的另一个区间 $[4,7]$ 中的 $5.5$ 也被选择了(这俩是同一个位置，模 $2n$ 意义下的)。

所以，假如在 $[1 \sim k]$ 中切的点往右一格，恰好跨过一个绳子所形成区间的右端点，就意味着一种不同的初始条件，此时就要重新去计算。

别人的题解中提到，两个点的最小距离为 $d$，正确的，但不需要在代码中体现，仅在计算复杂度时要用到。

先对别人题解进行解释：断开第 $i$ 段后(选了 $i+0.5$)，$1\sim i-1$ 段不用被断开，理由是可以换成断开 $2n$ 段(即 $2n+0.5$)，肯定不劣。

![](https://cdn.luogu.com.cn/upload/image_hosting/601nxpv6.png)

由上图可知，$j$ 开始的过长的区间要被 $j+1$ 开始的区间约束。

![](https://cdn.luogu.com.cn/upload/image_hosting/32yhoiwi.png)

由上图可知，记上个切点的位置 $pos$(此处指的是段数，是个整数哈)，这个切点选取的位置就是左端点 $\ge pos+1$ 的第一个区间的右端点 $R$，再 $-1$ 后的位置(因为切点在段上)。第一张图中已经维护好了两端都单调不降的区间，所以这个新切点肯定满足:对于任意左端处于 $[pos+1,R]$ 中的区间，都内含了该点。

所以说，$f[i]$ 表示左端 $\ge i$ 的所有区间中最小右端点位置，下一次就从 $f[i]$ 开始。

设在 $[1,d]$ 中选了第 $i$ 段，则 $[1,i-1]$ 的区间未被覆盖，所以右边界$\le len+i$ 的区间内部仍要一个点，即切点在 $len+i-1$ 段及其左边时是需要的，超过了就不需要(有 $i$ 了嘛)。

若某次的 $f[i] \ge len+i$ ，那么原本的 $i$ 就够了呀，就可以终止循环了。

因此初始值要设为 $+\infty$。

```
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#include<cmath>
#include<set>
#include<map>
#define ls p<<1
#define rs p<<1|1
#define m_p make_pair
#define _for(i,a,b) for(int i=(a);i<(b);i++)
#define _rof(i,a,b) for(int i=(a)-1;i>=(b);i--)
#define _rep(i,a,b) for(int i=(a);i<=(b);i++)
#define _per(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T1,typename T2>
inline bool cmax(T1& a,T2 b){return a<b?a=b,1:0;}//被更改=true.
template<typename T1,typename T2>
inline bool cmin(T1& a,T2 b){return a>b?a=b,1:0;}//被更改=true.
template<typename T1,typename T2>
inline T1 max(T1 x,T2 y){return x>y? x:y;}//以前面的类型为准.
template<typename T1,typename T2>
inline T1 min(T1 x,T2 y){return x<y? x:y;}//以前面的类型为准.
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
	return s*w;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void write(int x,char ch){write(x),putchar(ch);}

const int N=2e5+10;
int n,a[N][2];
inline int dis(int x,int y){//得到区间的最小长度.
	return min(y-x,2*n-y+x);
}
int f[N<<2];//从某个点开始能到哪,一开始临时存放R的位置.
void ADD_F(int x,int y){
	if(y<x) swap(x,y);
	//[x,y],[y,x+len].
	cmin(f[x], y);
	cmin(f[y], x+n*2);
}
int main(){
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
	n=read();
	int min_len=n,min_id;
	_rep(i,1,n){
		a[i][0]=read(),a[i][1]=read();
		if(a[i][0]>a[i][1]) swap(a[i][0],a[i][1]);
		if(cmin(min_len, dis(a[i][0],a[i][1]))) min_id=i;
	}
	int start;
	if(min_len==a[min_id][1]-a[min_id][0]) start=a[min_id][0];
	else start=a[min_id][1];
//	printf("基准=%d\n",start);

  memset(f,0x3f,sizeof(f));
	_rep(i,1,n){
//		printf("[%d,%d] -> ",a[i][0],a[i][1]);
		a[i][0]=(a[i][0]-start+2*n)%(2*n)+1;
		a[i][1]=(a[i][1]-start+2*n)%(2*n)+1;
//		printf("[%d,%d]\n",a[i][0],a[i][1]);
		ADD_F(a[i][0], a[i][1]);
	}
	//以上都不用太在意,仅为了完成"找到最小段并将其置于[1,d]的位置"这个操作.

	_per(i,n*4-1,1) cmin(f[i],f[i+1]);//为达成图片1的效果.
//	_rep(i,1,n*4) printf("%d %d\n",i,f[i]);

	int ans=0x3f3f3f3f;
	_rep(i,1,min_len){
		int cnt=1;
		for(int j=i+1;f[j]<n*2+i;j=f[j])//len+i刚好不用,那么小于就需要.
//			printf("%d ",f[j]-1),//这里输出选了哪段的点.
			cnt++;
		cmin(ans,cnt);
//		printf("\n");
	}
	write(ans+1>>1,'\n');
	return 0;
}
```

---

## 作者：Lumos壹玖贰壹 (赞：6)

#### ~~有点点难写的~~
#### 贪心好题
某日下午看到好题推荐了此题，又因为特别菜写不出此题，就要ha老师讲~~了一下午~~[ha老师的blog](https://www.cnblogs.com/yzhx/p/12723430.html)
##### 题目
测试要求 Bob 尽可能快地切断 n 根绳子。

所有绳子的端点两两不同，所以共有 2n 个端点。这些端点被捆在一个圆上，等距离分布。我们把这些端点按顺时针方向编号为 1到 2n。

Bob 每次切割的轨迹是一条直线，可以将所有与这条直线相交的绳子切断，他想知道至少多少次可以切断所有的绳子。

--------------
##### Solution
###### 断环为链
把环复制一遍。注意到原来环上的一条线(令一个端点为l，一个为r)对应了链上的两个区间$[l,r]$和$[l+2n,r+2n]$。

好好想想，真的只有对应两个区间吗？

~~恍惊起而长嗟~~ 还有一个！$[r,l+2n]$

所以一条线会对应链上的**三个区间**
###### 问题转化
你可能不太清楚**对应的区间**有什么用，下面来看张图

![](https://cdn.luogu.com.cn/upload/image_hosting/bln71mus.png)
	
可以发现：一条线被切断，则**这一刀与圆的交点**一定在这条线的两侧。对应到链上，我们称**刀与圆的交点为断点**,那么被切断的线对应的区间一定里面有一个断点，外面有一个断点。问题转化为选尽量少的断点，让连续的n个区间每个区间里面都有一个断点、外面都有一个断点。
##### 解决
我们找一个**最短的区间**，在区间内部枚举第一个断点(因为这个区间内部肯定有一个，并且这个区间小好枚)，last记录第一个断点的位置，然后往后找。若枚到一个区间**端点j**，它对应的区间的**左端点>last**,则说明last这个断点已经不在这个端点对应的区间里面了，就只能在这个区间里再开一个断点,更新last。为了尽可能让这个断点也在之后的区间里，所以把这个断点开在j(last=j)。

我们记最短的区间长度为len，枚起点要len次，每次往后枚+len就好，因为len是最短的距离，所以不会跳过(错过)一整个区间。所以复杂度是$O(N)$的

##### Code
看了代码就比较好理解了
```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
const int maxn=4e5+10;
int n;
struct node{
	int l,r;
}w[maxn<<1]; //区间的左右端点
int to[maxn<<1];
int dis(int l,int r){
	return min(r-l,2*n+l-r);//因为是个环，有优弧和劣弧两个距离，找最短距离
}
int main(){
	scanf("%d",&n);
	int xx=0,md=0x3f3f3f3f;//距离最小的区间和最小距离
	for(ri i=1,l,r;i<=n;i++){
		scanf("%d%d",&l,&r);
		if(l>r) swap(l,r);
		w[i].l=l; w[i].r=r;
		w[i+n].l=l+2*n; w[i+n].r=r+2*n;
		to[r]=l; to[l+2*n]=r; to[r+2*n]=l+2*n;//记录每个区间的右端点对应的左端点
		if(dis(l,r)<md) md=dis(l,r),xx=i;
	}
	int st,en;
	if(w[xx].r-w[xx].l==md) st=w[xx].l,en=w[xx].r;
	else st=w[xx].r,en=w[xx].l+2*n;
	int  len=dis(st,en);
	int ans=0x3f3f3f3f;
	for(ri i=st;i<=en;i++){//在xx这个区间内枚举第一个断点
		int last=i,sum=0;//答案是断点数(sum)除以二去上整
		for(ri j=i+len;j<i+2*n;j++)
			if(to[j]>last) last=j,sum++,j+=len;
		ans=min(ans,sum);
	}
	printf("%d\n",(ans/2)+1);
	return 0;
}

```
emmm第一次写题解讲的不是很清楚，还请见谅。有什么讲的不清楚留言欢迎留言

完结撒花

---

## 作者：ty_mxzhn (赞：1)

首先，我们考虑假设我们有 $2k$ 个断点，那么我们就可以据此连出 $k$ 条直线。

我们考虑 $i \leftrightarrow i+k$ 这样的连点方式。则这样由断点划分区间内部只要没有绳子就可以成功。这显然是最优的。

![](https://cdn.luogu.com.cn/upload/image_hosting/vlef6jnd.png)

如图考察了当确定了一个断点以后的划分情况。

考虑我们有经典结论：区间上，最大独立集 $=$ 最小支配集。

下面将说明此结论。这里说的一个支配集其实和图论上的说法不太一样，一个数轴上支配的位置会支配到一些两两相交的区间，放在图论上其实叫做最小团覆盖。而区间图是[弦图](http://oi-wiki.com/graph/chord/)所以这个结论是对的。

我们尝试着把链上的结论推广到环上。也就是说我们要证明环上区间图是弦图。这很简单，所以略去严谨证明。

于是我们要求出原图的最大独立集。这是简单的，考虑我们重新把环拍成链，则可能的独立集是一个大区间包着很多小区间的形式。

对于存在大区间的情况，因为有一些大区间会被偏序所以大区间两端点是单调不减的。~~但是这个结论并没有什么用。~~

先求出不含大区间的答案 $d$，考虑因为大区间只有一个，所以直接维护前 $i$ 个点往前连的最多个数，在此基础上左端点最大值是多少。

如果中途有一个最多个数达到 $d$ 则答案可以取到 $d+1$ 否则无法取到，时间复杂度 $O(n)$。有必要那么复杂吗？？？

---

## 作者：ty_mxzhn (赞：1)

~~先来抨击一下已有的题解~~，好吧我并没有你们那么勤奋我只是一个路过来口胡的。

题意简述：构造一个最小的区间序列 $l_i,r_i(1\le l_i\le r_i \le n)$，使得对于每一个 $a_i,b_i$ 都存在一个 $j$ 满足 $[a_i \in [l_j,r_j]]+[b_i \in [l_j,r_j]]=1$。

初步的分析已经在题意简述中给出了，考虑贪心，假设我们构造的序列含有 $2k$ 个数，我们把这些数记为 $w$ 序列，**不难发现最优的构造一定可以调整为 $i \leftrightarrow i+k$ 的形式**。

证明是什么？[我直接丢链接了](https://www.luogu.com.cn/problem/P11055)，不过我也来**不严谨的**证明一下：

首先如果 $l+k+1\ge r$ 的话，我们构造 $l+1 \leftrightarrow l+k+1$，这样显然满足条件。

如果 $l+k+1<r$ 则 $l < r-k-1$，我们构造 $r\leftrightarrow r-k$，这样显然满足条件。

如此可以说明从第 $l$ 个段到第 $r$ 个段一定会被切到。

如此可以发现这 $2k$ 个数将圆分成了 $2k$ 个段，而且这 $2k$ 个段之间的绳子全都不起作用。

如此我们可以很容易的维护 $\text{nxt}_i$ 表示 $i$ 分到下一个段 $i,j$，并且这一个段内没有绳子，$\text{nxt}_i$ 就是最大的 $j$，这个来看题解的应该都会不再赘述。

第 $1$ 个段之前有一些绳子，这些绳子会往后伸到最后面，直到分段的过程**把最后面的绳子**划分到了一个和第 $2k$ 个段不同的段内，才能合法。

枚举第 $1$ 个段的起始点，倍增跳段直到合法，时间复杂度 $O(n \log n)$。

比消消乐难，建议评蓝（此处应有一张鬼图）我没说批话毕竟这道题我就糊了 $10\ \text{min}$ 消消乐糊了一整场假了。

---

## 作者：critnos (赞：1)

似乎是一个非常简单的做法。

我们观察一下，可以发现若干条边可以同时被切掉，当且仅当其中不存在三条边形如样例图：

![](https://cdn.luogu.com.cn/upload/pic/19180.png)

考虑能选出最多的边形如上图，那么显然答案至少是边数除以二上取整。猜测这就是答案，然后写一个很简单的贪心（可以考虑转为序列区间，直接求出从每个点开始贪的结果即可，因为可能有一个大区间包含所有区间），发现过了。

时间复杂度线性。

证明我阿巴阿巴一下，不包对~~过了就不关心了.jpg~~。有问题或者 hack 请指出，有严谨证明请@我/dk。考虑一组最优解，满足每条边的内部不存在更小的边（否则调整），称这些边是关键的。只关注只和一条或者相邻的关键边相交的非关键边，那么不存在一条“增广路”，然后大概按每条路径从头到尾每次切两条边，感觉很对？

---


# [CSP-S2020] 贪吃蛇

## 题目描述

草原上有 $n$ 条蛇，编号分别为 $1, 2, \ldots , n$。初始时每条蛇有一个体力值 $a_i$，我们称编号为 $x$ 的蛇实力比编号为 $y$ 的蛇强当且仅当它们当前的体力值满足 $a_x > a_y$，或者 $a_x = a_y$ 且 $x > y$。

接下来这些蛇将进行决斗，决斗将持续若干轮，每一轮实力最强的蛇拥有选择权，可以选择吃或者不吃掉实力最弱的蛇：

1. 如果选择吃，那么实力最强的蛇的体力值将减去实力最弱的蛇的体力值，实力最弱的蛇被吃掉，退出接下来的决斗。之后开始下一轮决斗。
2. 如果选择不吃，决斗立刻结束。

每条蛇希望在自己不被吃的前提下在决斗中尽可能多吃别的蛇（显然，蛇不会选择吃自己）。

现在假设每条蛇都足够聪明，请你求出决斗结束后会剩几条蛇。

本题有多组数据，对于第一组数据，每条蛇体力会全部由输入给出，之后的每一组数据，会相对于上一组的数据，修改一部分蛇的体力作为新的输入。

## 说明/提示

**【样例 #1 解释】**

第一组数据，第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱。若 $3$ 号蛇选择吃，那么它将在第二轮被 $2$ 号蛇吃掉。因此 $3$ 号蛇第一轮选择不吃，$3$ 条蛇都将存活。

对于第二组数据，$3$ 条蛇体力变为 $5, 6, 25$。第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱，若它选择吃，那么 $3$ 号蛇体力值变为 $20$，在第二轮中依然是最强蛇并能吃掉 $2$ 号蛇，因此 $3$ 号蛇会选择两轮都吃，最终只有 $1$ 条蛇存活。

**【数据范围】**

对于 $20 \%$ 的数据，$n = 3$。  
对于 $40 \%$ 的数据，$n \le 10$。  
对于 $55 \%$ 的数据，$n \le 2000$。  
对于 $70\%$ 的数据，$n \le 5 \times {10}^4$。  
对于 $100\%$ 的数据：$3 \le n \le {10}^6$，$1 \le T \le 10$，$0 \le k \le {10}^5$，$0 \le a_i, y \le 10^9$。保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。

## 样例 #1

### 输入

```
2
3
11 14 14
3
1 5 2 6 3 25```

### 输出

```
3
1```

## 样例 #2

### 输入

```
2
5
13 31 33 39 42
5
1 7 2 10 3 24 4 48 5 50```

### 输出

```
5
3```

## 样例 #3

### 输入

```
见附件中的 snakes/snakes3.in```

### 输出

```
见附件中的 snakes/snakes3.ans```

## 样例 #4

### 输入

```
见附件中的 snakes/snakes4.in```

### 输出

```
见附件中的 snakes/snakes4.ans```

# 题解

## 作者：OMG_wc (赞：440)

~~比赛里能做出这题的人真的非常厉害，至少他的智商和蛇一样足够聪明~~。

首先有一个结论：

当前最强的蛇吃了最弱的蛇之后，如果没有变成最弱的蛇，他一定会选择吃！

证明：

假设当前最强的蛇叫石老板。

- 如果下一条最强的蛇如果依旧是石老板，那肯定不吃白不吃；

- 如果下一条最强蛇不是石老板，此时最强的蛇没有原先强，最弱的蛇也没原先弱，吃掉后肯定比石老板要弱。也就是说，当前最强的蛇吃了之后，如果会死，也会死在石老板前面。那么这样一来，这条蛇会想尽办法不死，从而石老板也一定能不死。



有了这个结论，一部分蛇可以放心大胆地吃了，但是问题来了，如果吃了之后变成最弱的蛇了，到底选择吃不吃呢？

稍微往后推一推就明白了：

当前最强蛇记为石老板，下一条最强蛇记为喵老板。石老板进食后变成最弱的蛇了，如果喵老板进食后不是最弱的蛇，他就会选择吃（根据开头的结论），这样石老板就凉了，所以石老板当初的选择一定是不吃。

如果喵老板进食后依旧是最弱的蛇，那就会考虑下一条最强蛇的情况，起名为汪老板。同样分两种情况：如果汪老板进食后不是最弱的蛇，那他就会选择吃，这样喵老板就凉了，所以他当初会选择不吃，这样石老板就不会死，那么石老板当初就会选择吃。如果汪老板进食后变成了最弱的蛇，那就再考虑下一条蛇………………

这个问题就变成了一个递归的问题了，直到**某条蛇吃了之后不是最弱的蛇或者只能下两条蛇为止**。这样，最后一条蛇会选择吃，倒数第二条蛇为了保命会选择不吃，倒数第三条蛇可以放心大胆的吃，倒数第四条蛇会保命选择不吃，倒数第五条蛇可以放心吃………………

这样，石老板选择吃不吃，就和最后一条蛇之间的奇偶性相关了。并且石老板选择不吃，游戏结束，石老板选择吃，游戏也会在下一轮结束（因为喵老板会选择不吃）。

到目前为止，这个题目很清晰了，只需模拟两个阶段即可：

阶段一：所有最强蛇进食后都不是最弱蛇，放心大胆吃！

阶段二：所有最强蛇进食后都是最弱蛇，直到有条蛇可以放心吃为止（吃了后不是最弱或者只剩两条）

阶段一结束时，游戏就基本结束了（根据阶段二的奇偶性看能不能再吃一次）

利用`set`可以方便地维护最强、最弱蛇，时间复杂度 $O(Tn\log n)$，只能拿 70 分，代码如下：

```c++
int a[N];
int main() {
    int _;
    scanf("%d", &_);
    int n;
    for (int cas = 1; cas <= _; cas++) {
        if (cas == 1) {
            scanf("%d", &n);
            for (int i = 1; i <= n; i++) {
                scanf("%d", &a[i]);
            }
        } else {
            int k;
            scanf("%d", &k);
            while (k--) {
                int x, y;
                scanf("%d%d", &x, &y);
                a[x] = y;
            }
        }
        set<pair<int, int> > se;
        for (int i = 1; i <= n; i++) {
            se.insert({a[i], i});
        }
        int flag = 0, ans;
        while (1) {
            if (se.size() == 2) {
                se.erase(se.begin());
                if (flag) {
                    if ((flag - se.size()) % 2) {
                        ans = flag + 1;
                    } else {
                        ans = flag;
                    }
                } else
                    ans = 1;
                break;
            }
            set<pair<int, int> >::iterator it = se.end();
            it--;
            int x = it->first, id = it->second;
            int y = se.begin()->first;
            se.erase(it);
            se.erase(se.begin());
            se.insert({x - y, id});
            if (se.begin()->second != id) {
                if (flag) {
                    if ((flag - se.size()) % 2) {
                        ans = flag + 1;
                    } else {
                        ans = flag;
                    }
                    break;
                }
            } else {
                if (flag == 0) flag = se.size();
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

正解：用两个双端队列 $q_1,q_2$ 维护即可。

先把初始的有序蛇放进 $q_1$ 里，此时 $q_1$ 已满足单调性，头部小，尾部大，我们后面会让 $q_2$ 也满足这样的单调性。

##### 第一阶段：

每次从 $q_1,q_2$ 的尾部取出最强的蛇，从 $q_1$ 头部取出最弱的蛇，如果吃了以后是最弱的，那就进入第二阶段，否则直接装入 $q_2$ 的头部。

为什么可以装进 $q_2$ 并且是 $q_2$ 里最弱的？其实证明最初的结论时已经解释过了，后面进食的蛇肯定是越来越弱的，而且这个阶段最弱的蛇一定在 $q_1$ 中。

##### 第二阶段：

此时最弱的蛇，就没必要丢进队列里了，单独维护一下就好了，因为连续的一段进食后都是最弱的，直到总蛇数等于 $2$ 或者进食后不是最弱为止，而最强的依旧从 $q_1,q_2$ 的尾部找。

这样就不需要用其他带 $\log$ 的数据结构维护了，时间复杂度 $O(Tn)$，代码如下：

```c++
int a[N];
int main() {
    int _;
    scanf("%d", &_);
    int n;
    for (int cas = 1; cas <= _; cas++) {
        if (cas == 1) {
            scanf("%d", &n);
            for (int i = 1; i <= n; i++) {
                scanf("%d", &a[i]);
            }
        } else {
            int k;
            scanf("%d", &k);
            while (k--) {
                int x, y;
                scanf("%d%d", &x, &y);
                a[x] = y;
            }
        }
        deque<pair<int, int> > q1, q2;
        for (int i = 1; i <= n; i++) {
            q1.push_back({a[i], i});
        }
        int ans;
        while (1) {
            if (q1.size() + q2.size() == 2) {
                ans = 1;
                break;
            }
            int x, id, y;
            y = q1.front().first, q1.pop_front();
            if (q2.empty() || !q1.empty() && q1.back() > q2.back()) {
                x = q1.back().first, id = q1.back().second, q1.pop_back();
            } else {
                x = q2.back().first, id = q2.back().second, q2.pop_back();
            }
            pair<int, int> now = make_pair(x - y, id);
            if (q1.empty() || q1.front() > now) {
                ans = q1.size() + q2.size() + 2;  // 不吃
                int cnt = 0;
                while (1) {
                    cnt++;
                    if (q1.size() + q2.size() + 1 == 2) {
                        if (cnt % 2 == 0) ans--;
                        break;
                    }
                    int x, id;
                    if (q2.empty() || !q1.empty() && q1.back() > q2.back()) {
                        x = q1.back().first, id = q1.back().second, q1.pop_back();
                    } else {
                        x = q2.back().first, id = q2.back().second, q2.pop_back();
                    }
                    now = {x - now.first, id};
                    if ((q1.empty() || now < q1.front()) && (q2.empty() || now < q2.front())) {
                        ;
                    } else {
                        if (cnt % 2 == 0) ans--;
                        break;
                    }
                }
                break;
            } else {
                q2.push_front(now);
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```



---

## 作者：木xx木大 (赞：70)

[P7078 贪吃蛇](https://www.luogu.com.cn/problem/P7078)

比赛时能做出来这题的都是神仙，因为他和蛇一样聪明！
本篇题解的主要思路是参考sll学长的视频讲解的，在这里orz！

设所有蛇的实力为 $a_1,a_2\dots a_n$ ，$a_1$ 最小， $a_n$ 最大。下面我们分情况讨论最大的蛇是否选择吃：

**Case1：当前最强的蛇吃了最弱的蛇之后没有变成最弱的蛇**

 （结论一）**如果当前最强的蛇吃了最弱的蛇之后没有变成最弱的蛇，它一定会选择吃！**证明如下： 

* 如果它吃完以后仍然是最大的蛇，不吃白不吃
* 否则，下一个最大的蛇为 $a_{n-1}$，下一个最小的蛇为 $a_2$。因为 $a_n\geq a_{n-1}$，$a_2\geq a_1$ ，所以 $a_n-a_1\geq a_{n-1}-a_2$ 。如果 $a_{n-1}$ 选择吃，那么它吃完后会比 $a_n$ 吃完后更小，也就是说，它如果死也会死在 $a_n$ 之前，由于它会尽量不死，所以 $a_n$ 也不会死；如果 $a_{n-1}$ 选择不吃，那么决斗结束， $a_n$ 仍然安全。

**Case2：当前最强的蛇吃了最弱的蛇之后变成了最弱的蛇**

显然~~(废话)~~ ，如果它吃完以后，在之后的决斗中不会死，它就吃；换句话说，（结论二）**在轮到它死之前，已经有蛇选择结束决斗，它就吃。**

根据以上两个结论，我们可以得到本题的基本思路：

**步骤一** ：我们先不考虑 Case2，假设所有的蛇都不聪明，按照 Case1 进行正向模拟一遍，记录每一轮中吃的蛇和被吃的蛇（即最大值 $mx_i$ 和最小值 $mi_i$）。显然的做法是用 set 维护。

**步骤二**：再考虑 Case2。记 $dead_i$ 表示第 $i$ 条蛇死的时间。从后往前，替每一轮中的蛇决定它是否要吃。**从后往前**是因为每条蛇当前是否选择结束游戏，是要根据它之后是否被吃判断的（结论二）。记 $ans$ 表示决斗会在哪一轮结束。如果 $dead_{mx_i}<ans$ ，那么结束，$ans=i$。最终答案即为 $n-ans+1$ 。

以上做法的复杂度瓶颈在于步骤一的模拟中需要用到 set ，每次取出最大最小值复杂度为 $O(\log n)$ ，我们希望把这一操作的复杂度降为 $O(1)$。看到题目中说**保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列**，我们考虑用队列代替 set 维护，重新思考 Case1 和 Case2 中隐含的**单调性**。

 设 $w=a_n-a_1$。我们维护两个队列， $q1$ 中存原来的蛇，$q2$ 中存每次新得到的蛇。

**Case1：**如果 $w>a_{n-1}$，那么下一次的最大值为 $w$ ，$w-a_2<w$；否则$w>a_{n-1}-a_2$ 。满足单调性。（其实就是上面对结论一的证明）

**Case2**： $w$ 就是下一次被吃掉的蛇。所以队列中始终只有一个元素，显然满足单调性。

根据上面的分析， 如果只有 Case1 或 Case2 ， $q2$ 都是单调的。但如果 Case1 和 Case2 交替出现呢？

* 如果一串 Case1 后跟一串 Case2 ，Case2 会反复进出队，队里以前的元素不会用到
* 如果一串 Case2 后遇到一个 Case1，确实可能会不满足单调性。**但是！这次的 Case1 被吃掉的是上次 Case2 中选择吃蛇的蛇，既然它这次被吃了，那么因为它足够聪明，它上一次就不会选择吃！也就是说，这是一个边界条件，决斗在这之前就结束啦！**因此，不满足单调性也是没有关系的。

综上：$q1$ 和 $q2$ 都是满足单调性的。所以我们可以用两个 deque 代替 set，复杂度就降为 $O(Tn)$ 了。具体实现细节可以看代码。

这道题我从学习解法，写代码，到写完这篇题解，花了整整一下午时间。这也是我写过的最长且最详细的一篇题解。希望大家和以后再回来看这篇题解的我都能看懂吧。

```cpp
#include<bits/stdc++.h>
#define inl inline
using namespace std;
namespace FGF
{
	int n,m;
	const int N=1e6+5;
	int b[N],a[N],q[N],de[N],h,t,st,ed,fl,end;
	struct Node{
		int mx,mi;
		Node(){};
		Node(int _mx,int _mi):mx(_mx),mi(_mi){};
	}c[N];
	int read()
	{
		int s=0;char ch=getchar();
		while(!isdigit(ch))ch=getchar();
		while(isdigit(ch))s=s*10+ch-'0',ch=getchar();
		return s;
	}
	inl int getcm()//查找次小值 
	{
		int mi;
		if(st>ed)mi=q[t];
		else if(h>t)mi=st;
		else if(a[st]<a[q[t]]||(a[st]==a[q[t]]&&st<q[t]))mi=st;
		else mi=q[t];
		return mi;
	}
	inl int getmi()//取出最小值 
	{
		int mi;
		if(st>ed)mi=q[t],t--;
		else if(h>t)mi=st,st++;
		else if(a[st]<a[q[t]]||(a[st]==a[q[t]]&&st<q[t]))mi=st,st++;
		else mi=q[t],t--;
		return mi;
	}
	inl int getmx()//取出最大值 
	{
		int mx;
		if(st>ed)mx=q[h],h++;
		else if(h>t)mx=ed,ed--;
		else if(a[ed]>a[q[h]]||(a[ed]==a[q[h]]&&ed>q[h]))mx=ed,ed--;
		else mx=q[h],h++;
		return mx;
	}
	void solve()
	{//这里我直接将a数组当q1用了 
		h=1,t=0,st=1,ed=n,fl=0,end=n-1;
		for(int i=1;i<n;i++)//决斗最多进行n-1轮 
		{
			int mx=getmx(),mi=getmi(),cm=getcm();
			a[mx]-=a[mi];
			q[++t]=mx;//把新得到的值放入q2 
			c[i].mx=mx,c[i].mi=mi;
			if(a[mx]>a[cm]||(a[mx]==a[cm]&&mx>cm))
			{
				if(fl)//一串Case2后跟了一个Case1，决斗结束 
				{
					end=i;
					break;
				}
			}
			else fl=i;//记录一下Case2出现过了 
		}
		for(int i=1;i<=n;i++)de[i]=end+1;//初始化dead数组 
		de[c[end].mi]=end;
		int ans=end+1;
		for(int i=end-1;i;i--)
		{
			if(de[c[i].mx]<ans)ans=i;
			de[c[i].mi]=i;
		}
		printf("%d\n",n-ans+1);
	}
	void work()
	{
		int T=read();n=read();
		for(int i=1;i<=n;i++)
			b[i]=a[i]=read();
		solve();
		for(int i=2;i<=T;i++)
		{
			int k=read();
			for(int j=1;j<=n;j++)a[j]=b[j];
			for(int j=1;j<=k;j++)
			{
				int x=read(),y=read();
				b[x]=a[x]=y;
			}
			solve();
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：huayucaiji (赞：36)

~~考场差点忘记加 s~~

~~但也抱灵了 qwq~~

估计我是第一个本题考场抱灵来写题解的。

话说考场上想到了 $70$ 分解法，居然调了两个小时没调出来我也是醉了。然而我又觉得 T4 比 T3 简单（~~什么神奇想法~~），所以 T3 只有暴力的分数 qwq。

既然在这道题上反例大错，那么赛后就该好好反思，以后不要再犯这样的聪明。~~OI，要以核为贵，我劝出题人耗子尾汁，不要搞窝里斗。~~

咳咳，我们正式来讲解法。

### 引入

首先我们以一道经典的海盗分金问题来做引入，这对这道题有很大启发。

我们有 $5$ 个海盗，他们要分 $100$ 个金币，$5$ 个海盗从一号开始一次提出自己的分金方案，然后投票表决。如果第一个海盗的方案得到了半数以上的人的同意，那么按照一号的方案分钱。否则一号会被扔到海里喂鲨鱼。然后再表决二号的方案，以此类推。**假设所有海盗足够聪明**，请问一号最多获得多少钱？

先说答案，如果没有做过这道题，你肯定会大吃一惊：

**$$97$$**

我们来具体分析一下：

1. 首先从两个人的情况考虑。如果只剩下 $4$ 和 $5$，那么只要 $5$ 投反对票，那么 $4$ 去喂了鲨鱼，$100$ 块钱就都是 $5$ 的。
2. 现在考虑有三个人，既然 $4$ 很弱势，那么他为了不被喂鲨鱼，无论如何会投赞成票（我们考虑死亡是最坏结果，比拿不到钱还坏）。$5$ 的票不重要，所以 $3$ 拿 $100$ 块钱，$4,5$ 一分钱拿不到。
3. 考虑 $4$ 个人。$5$ 因为在 $3$ 个人的时候拿不到钱，所以只要 $2$ 给他 $1$ 块钱，就会投赞成票。$3$ 因为在 $3$ 个人的时候有 $100$ 块钱，无论如何不会同意 $2$。所以 $2$ 还需要一块钱讨好 $4$。这样 $2$ 最多拿 $98$ 块钱。
4. 最后考虑 $5$ 个人。现在 $3$ 只要有 $1$ 块钱就会支持 $1$，所以给他 $1$ 块钱。$2$ 肯定反对（理由同上一种情况 $3$ 的反对理由）。$1$ 只需要讨好 $4,5$ 中的一个即可，给 $4$ 或 $5$ 其中一个多一块钱，即 $2$ 块钱即可，另一个不用给。因此 $1$ 最多有 $97$ 块钱。

这个题的思路就和贪吃蛇的思路有点类似了，我们现在再来理解 snakes 这道题会好很多。

### 解题

我们现在考虑解题方法。

现在我们的蛇长度是 $a_1,a_2\dots a_n$。吃一次会得到一条新的蛇，长度为 $a_n-a_1$。因为蛇足够聪明，只要能吃，最长的蛇就一直吃，直到最长的蛇吃了最短的蛇后变成了最短的蛇。这符合贪心的策略。这个贪心思路很简单，一开始我就想到这里，开心打了代码。结果大样例和答案老是差 $1$。大概最后还剩半个小时的时候想到了这种情况：

```plain
1
3
3 4 5 6
```

这种情况下，$6$ 吃了 $3$ 后会变成 $3$，但是 $5$ 不敢动它，因为动了自己会被吃掉，因此 $6$ 可以吃 $3$ 最后答案为 $3$。因此在最后我们还需要判断一下是否还可以再吃一口。我们的判断过程类似于一个递归，即假设能吃，看看接下来是否能推出不能吃，导致矛盾。举个例子：

我们现在假设 $a_n-a_1<a_2$，开始判断能否继续吃，假设我们吃了，现在有 $a_n-a_1,a_2,a_3\dots a_{n-1}$。如果 $a_{n-1}-(a_n-a_1)\geq a_2$，那么原来就不能吃，否则继续判断。现在有 $a_{n-1}-(a_n-a_1),a_2,a_3\dots a_{n-3}$。如果这一口~~发力~~吃了，~~没有把最短的蛇打骨折~~，无法吃掉最短的蛇，仍然要继续判断；否则说明 $a_{n-1}$ 吃是不安全的，那么 $a_n$ 就该吃，以此类推直到只剩 $2$ 条蛇，除非中间已经判断出了结果，即某一时刻最长的蛇吃了最短的蛇后不是最短的蛇。

用递归求解即可。

我们采用 ```set``` 来维护当前最大值和最小值。时间复杂度 $O(n\log n)$。非考场代码（我考场上都抱灵了qwq）

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int maxn=1e6+10;

int n;

struct snakes {
	int id,len;
	
	bool operator <(snakes b) const {
		if(len!=b.len) {
			return len<b.len;
		}
		return id<b.id;
	}
	
	snakes operator -(snakes b) {
		snakes ret;
		ret.len=len-b.len;
		ret.id=id;
		return ret;
	}
}a[maxn];//结构体针不戳

typedef set<snakes>::iterator its;
set<snakes> s;

bool eatornot() {//判断是否还能再吃
	if(s.size()==2) {
		return 1;//还剩下两条蛇当然随便吃，返回1
	}
	its ib,ie,ib2;
	ib=s.begin();
	ie=s.end();
	ie--;
	ib2=ib;
	ib2++;
	
	snakes now=(*ie);
	now.len=(*ie).len-(*ib).len;
	if(!(now<(*ib2))) {
		return 1;//如果吃了不是最短的，说明可以吃
	} 
	s.erase(ib);
	s.erase(ie);
	s.insert(now);
	return !eatornot();
	//注意取反操作
	//如果现在能吃，说明上一条蛇不该吃
	//反之亦然
}

signed main() {
	freopen("snakes.in","r",stdin);
	freopen("snakes.out","w",stdout);
	
	int t;
	t=read();
	
	for(int Q=1;Q<=t;Q++) {
		if(Q==1) {
			n=read();
			for (int i = 1; i <= n; ++i) {
				a[i].len=read();
				a[i].id=i;
				s.insert(a[i]);
			}
		}
		else {
			int k=read();
			for(int i=1;i<=k;i++) {
				int x=read();
				int y=read();
				a[x].len=y;
			}
			s.clear();
			for (int i=1;i<=n;++i) {
				s.insert(a[i]);
			}
		}//两种输入方式
		
		while(1) {
			its ib,ie,ib2;
			ib=s.begin();
			ie=s.end();
			ie--;
			ib2=ib;
			ib2++;
			
			snakes now=(*ie);
			now.len=(*ie).len-(*ib).len;
			if(now<(*ib2)) {//模拟
				break;
			} 
			s.erase(ib);
			s.erase(ie);
			s.insert(now);
		}
		
		int ans=s.size();
		if(eatornot()) {
			ans--; //如果能吃，就在咬一口咯~
		}
		
		printf("%d\n",ans);
	}

	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

以上是 $70pts$ 做法，现在来考虑 $100pts$ 做法。算法肯定没问题，主要是要把时间复杂度降到 $O(n)$。

我们其实可以联想到“蚯蚓”这道题，开两个队列来维护最大最小，吃完后留下的蛇的长度肯定是顺次单调递减的，很好证明，这里不再赘述。我们现在维护两个双端队列，由于有单调性，每个队列中蛇的长度单调递增，这样我们就省去了那个求最大最小值的 $O(\log n)$。具体看代码。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
#include<bits/stdc++.h>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int maxn=1e6+10;

int n;

struct snakes {
	int id,len;
	
	bool operator <(snakes b) const {
		if(len!=b.len) {
			return len<b.len;
		}
		return id<b.id;
	}
	
	snakes operator -(snakes b) {
		snakes ret;
		ret.len=len-b.len;
		ret.id=id;
		return ret;
	}
}a[maxn];

deque<snakes> q1,q2,q;

void work() {
	q1.clear();
	q2.clear();//记得多组数据初始化
	q.clear();
	
	for (int i = 1; i <= n; ++i) {
		q1.push_back(a[i]);
	}
	
	while(1) {
		if(q1.size()+q2.size()==2) {
			printf("1\n"); //还剩下 2 条蛇直接输出
			return ;
		}
		
		snakes st=q1.front();
		q1.pop_front();
		snakes ed=q1.back();
		
		if(!q2.empty()&&ed<q2.back()) {
			ed=q2.back();
			q2.pop_back();//如果 q2 中的蛇较长，取 q2 中的蛇
		}
		else {
			q1.pop_back();
		}
		
		snakes tmp;
		tmp.len=ed.len-st.len;
		tmp.id=ed.id;
		if(q1.front()<tmp) {
			q2.push_front(tmp);
		}//将新蛇根据单调性放入队列中
		else {
			q1.push_front(tmp);
			break;
			//现在这条蛇吃了一口，发现变成最短的了
			//那么进入第二阶段
			//注意此时放到 q1 还是 q2 中没有任何区别了
		}
	}
	
	while(!q1.empty()&&!q2.empty()) {
		if(q1.front()<q2.front()) {
			q.push_back(q1.front());
			q1.pop_front();
		}
		else {
			q.push_back(q2.front());
			q2.pop_front();
		}
	}
	while(!q1.empty()) {
		q.push_back(q1.front());
		q1.pop_front();
	}
	while(!q2.empty()) {
		q.push_back(q2.front());
		q2.pop_front();
	}
	//为了操作方便把两个队列合并
	//和归并时 O(n) 合并有序数组的做法一致
	
	int ans=q.size();
	
	int eat=0;
	
	while(q.size()>1) {
		snakes st=q.front();
		q.pop_front();
		snakes ed=q.back();
		q.pop_back();
		
		snakes tmp;
		tmp.len=ed.len-st.len;
		tmp.id=ed.id;
		
		eat++;
		
		if(q.size()==0||q.front()<tmp) {
			break;
		}
		else {
			q.push_front(tmp);//还是可爱的单调性
		}
	}//用 while 模拟递归判断，本质上无差别
	
	printf("%d\n",ans+(eat&1? 1:0));
	//注意我们这份代码中和上一份有所不同
	//上面是假设还没吃，判断是否要吃 -1
	//这里是已经吃了，判断是否要吐出来 +1
} 

signed main() {
	freopen("snakes.in","r",stdin);
	freopen("snakes.out","w",stdout);
	
	int t;
	t=read();
	
	for(int Q=1;Q<=t;Q++) {
		
		if(Q==1) {
			n=read();
			for (int i = 1; i <= n; ++i) {
				a[i].len=read();
				a[i].id=i;
			}
		}
		else {
			int k=read();
			for(int i=1;i<=k;i++) {
				int x=read();
				int y=read();
				a[x].len=y;
			}
		}//似曾相识的读入
		
		work();//求解
	}

	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

这道题就分析完了，总体来说难度不算大，不至于到黑题（但是在账户里多一道黑题收入还是不错的）。主要是一个思维题，偏博弈类型。说句实话这题于我来说不只是搞懂了一道题，还让我好好反思了我的做题策略，可以说，在我人生道路上可能是一个重要的节点吧。特此写了一篇题解来谢谢自己的感悟，也把知识分享给大家。

最后的最后：

```cpp
NOIP2020_rp++;
```

---

## 作者：_anll_ (赞：21)

省队学长给我们拉的模拟赛的 T4，没想到还能交题解，这下不得不写我的第一篇黑题题解来纪念了。

## 思路
### 70pts
先引出结论：当最大的蛇吃了后没有变成最小的蛇，它一定会吃；否则需要递推进行决策。

下面解释为什么一定会吃。令初始时蛇的能力为 $A_1,A_2,\dots,A_n$，那么它们一定是单调不降的。若未变成最小的蛇，那么说明 $A_n-A_1\ge A_2$，如果 $n-1$ 不吃，那么游戏结束，$n$ 会吃；否则一定有 $A_{n-1}-A_2\le A_n-A_1$，那么 $n-1$ 一定会死在 $n$ 前面，所以 $n$ 也会吃。

而当最大蛇吃掉后变成了最小蛇，若次大蛇经过一系列头脑风暴后选择不吃，那它就会白吃一回合；否则它不吃。正着决策显然困难，所以选择倒着推回去。

我们可以使用 set 维护这一过程。具体地，先假设所有蛇都不聪明，每条蛇都一定会吃，模拟一轮后可以得到每轮最大的蛇 $eat_i$ 和最小的蛇 $beat_i$。再倒着往前推，定义 $del_i$ 为每条蛇的死亡时间，若 $del_{eat_i}\ge ans$，则说明在它死前游戏就已经结束了，因此可以吃，同时将 $del_{beat_i}$ 设成 $i$；否则不吃，将 $ans$ 更新为 $i$。

### 100pts
上述做法中瓶颈在于 set 的时间复杂度，我们考虑能否用线性结构进行维护。使用双端队列真是再合适不过了！

具体地，开两个双端队列 $st1,st2$，$st1$ 用来维护未进食过的蛇，$st2$ 维护进食过的蛇。容易发现，除了一种情况外，两个队列一定是具有单调性的。我们先假定两个队列都是队尾最弱，队头最强，下面给出证明：

这一轮进食完毕后的蛇的能力值一定是 $\max(st1_l,st2_l)-\min(st1_r,st2_r)$。分讨一下，发现由于 $max$ 的值一定是单调不升的，因此我们主要对 $min$ 作讨论。记第 $i$ 轮的 $min$ 为 $min_i$，得到以下情况：

- 若 $min_i=st1_r$，那么一定符合单调性：若 $min_{i-1}$ 来自 $st1$，那么一定有 $min_{i-1}\le min_i$，因此此轮能力值一定小于上一轮；若 $min_{i-1}$ 来自 $st2$，那么说明它比 $st1_r$ 后面的那个值大，因此依旧有 $min_{i-1}\le min_i$，于是同理。
  
- 若 $min_i=st2_r$，那就不一定符合单调性了。如果符合单调性就依旧满足，否则的那种情况会在下面提到。

对于出现不满足单调性的情况，那就只能是当前值比 $st2_r$ 大，即 $st2_r$ 要被吃掉。那么在这种情况下 $st2_r$ 就会选择在上一轮停手。于是你发现这和“剩两条蛇，如果较小的那条能反悔，它一定会反悔”的逻辑是一样的。于是我们就可以从这个时候开始往回推，而不是一定要全部模拟完了。

## 代码
```cpp
#include<set>
#include<queue>
#include<iostream>
#define int long long
using namespace std;
const int N=1e6+5;
int _anll_,t;
int n,m,ans,tim,A[N],del[N],eat[N],beat[N];
deque<pair<int,int> > st1,st2;
void solve(bool _anll_){
	if(!_anll_){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>A[i];
	}
	else{
		cin>>m;int a,b;
		while(m--) cin>>a>>b,A[a]=b;
	}
	tim=-1,ans=1;
	while(st1.size()) st1.pop_back();
	while(st2.size()) st2.pop_back();
	for(int i=1;i<=n;i++)
		st1.push_back({A[i],i}),
		eat[i]=beat[i]=del[i]=0;
	for(int i=n;i>1;i--){
		pair<int,int> mx,mn,an;
		if(st1.size()&&st2.size()){
			if(st1.back()>st2.back())
				 {mx=st1.back();st1.pop_back();}
			else {mx=st2.back();st2.pop_back();}
		}
		else if(st1.size())
			 {mx=st1.back();st1.pop_back();}
		else {mx=st2.back();st2.pop_back();}
		if(st1.size()&&st2.size()){
			if(st1.front()<st2.front())
				 {mn=st1.front();st1.pop_front();}
			else {mn=st2.front();st2.pop_front();}
		}
		else if(st1.size())
			 {mn=st1.front();st1.pop_front();}
		else {mn=st2.front();st2.pop_front();}
		beat[i]=mn.second,eat[i]=mx.second;
		an={mx.first-mn.first,mx.second};
		if(st2.size()&&an>st2.front()){
			ans=tim=i;break;
		}
		st2.push_front(an);
	}
	if(tim==-1) tim=2;
	for(int i=tim;i<=n;i++){
		int x=eat[i];
		if(del[x]>=ans) ans=i;
		else del[beat[i]]=i;
	}
	cout<<ans<<endl;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>t;
	for(int i=0;i<t;i++) solve(i);
	return 0;
}
```

---

## 作者：Piwry (赞：19)

Orz 神仙 [EI](https://www.luogu.com.cn/blog/EntropyIncreaser/ying-ye-ri-zhi-2020117-yi-ci-xin-xi-fou-dui-cheng-yin-fa-di-csp2020-t4-post)。

这里主要介绍另一种实现较简单的做法，这种做法比较依赖题目性质，拓展性并不太好。

【Part-1】和【Part-2】很大程度上参考了 EI 的博客；【Part-3】也感谢 EI 在 uoj 群的解释 qwq：

![EI](https://cdn.luogu.com.cn/upload/image_hosting/58aiu3pw.png)

~~所以就当我仅是负责将这些东西整合到一起的罢 \kk。~~

## 解析

### Part-0

我们先考虑让所有蛇都选择吃，然后处理出每轮做选择的蛇和每条蛇的死亡时间。

设一个预期停止的轮编号【ans】（在第【ans】轮，该轮主导的蛇不会选择吃，决斗结束）；接着从后往前扫，如果发现某轮做选择的蛇的死亡时间在预期的决斗结束时间内，那么就将预期决斗结束时间设为该轮。

其中从后往前扫是因为前面的蛇的决策也取决于后面的蛇的决策；并且即使前面的蛇选择继续决斗会导致自己在后面某轮作为弱蛇，只要不会被吃掉，那么前面的蛇仍会选择继续决斗。

（然而到现在为止根本没到难点...... \fad）

可以发现该算法的瓶颈在于前面的模拟，且比较 naive 地用 stl 的 set 维护是 $O(Tn\log n)$ 的。

### Part-1

考虑用题目「NOIP2016 蚯蚓」的方式维护两个“单调队列”。具体来说，设 $\texttt{Q}_1, \texttt{Q}_2$，初始 $\texttt{Q}_1$ 中从大到小顺序存放着所有的元素。每次我们从两个队列头部取出元素，比较得到最大值；从两个队列尾部取出元素，比较得到最小值；最后再将新的元素插入 $\texttt{Q}_2$ 的队尾。我们期望 $\texttt{Q}_2$ 中的元素也始终是满足单调递减的。

设第 $i$ 次得到的最大值 $x_i$ 和最小值 $y_i$，以及该次将得到的新元素值 $u_i=x_i-y_i$。

如果保证 $2y_i\leq x_i$，那么就可以证明 $u_i$ 及其编号是递减的。对于**值**，首先发现总是有 $x_i\geq x_{i+1}$；再由 $y_i\leq x_i-y_i=u_i$，可以得到 $y_i\leq y_{i+1}$；因此总有 $u_i\geq u_{i+1}$。对于**编号**，由于有 $x_i\geq x_{i+1}, y_i\leq y_{i+1}$，于是能得到 $u_i=x_i-y_i=x_{i+1}-y_{i+1}=u_{i+1}$ 当且仅当 $x_i=x_{i+1}$ 且 $y_i=y_{i+1}$；最后发现 $u_{i+1}$ 的编号来自 $x_{i+1}$，因此总有 $u_i=u_{i+1}$ 时编号递减。

### Part-2

接下来考虑第一次满足 $2y_i>x_i$ 后会发生什么。

不妨将 $\texttt{Q}_1$ 与 $\texttt{Q}_2$ 的元素“合并”，重新得到一个升序排列的序列 $\{a_n\}$；那么我们就有 $2a_1>a_n$。并且我们重新对操作计数：

1. 第一次操作，推出的**数值**为 $a_1, a_n$，推入的**数值**为 $a_n-a_1<a_1$。且由此得到 $2a_1>a_n$。
2. 第二次操作，推出的数值为 $a_n-a_1, a_{n-1}$，推入的数值为 $a_{n-1}-a_n+a_1\leq 0+a_1$。
3. 第三次操作，推出的数值为 $a_{n-1}-a_n+a_1, a_{n-2}$，推入的数值为 $a_{n-2}-(a_{n-1}-a_n+a_1)=(a_{n-2}-a_{n-1})+(a_n-a_1)\leq 0+(a_n-a_1)<a_1$。
4. ...

用归纳法不难得出：第奇数次操作推入的数值 $u_j$ 总有 $u_j<a_1$；第偶数次操作推入的数值 $u_k$ 总有 $u_k\leq a_1$。

### Part-3

关键在于偶数次推入的数值与 $a_1$ **相等**，并且我们并不能保证该次推入的元素的**编号**满足什么性质，因此此时很有可能会破坏 $\texttt{Q}_2$ 的单调性。但其实可以发现，在第一次 $\texttt{Q}_2$ 单调性被破坏后，决斗实际上**已经结束了**。

首先此时一定已经满足 $2y_i>x_i$ 至少两轮。不妨设此时是第 $k$ 轮，且应当是（上述的）第偶数次操作。

若第 $k$ 轮的蛇 $A$ 选择吃，那么由于单调性被破坏，下一轮的弱蛇不会是 $A$。若想要 $A$ 被吃掉，那么至少第 $k+1$ 轮的蛇和第 $k+2$ 轮的蛇都要选择吃，$A$ 才有可能在第 $k+3$ 轮成为弱蛇；但发现这意味着第 $k+1$ 轮的蛇必须要被吃掉（奇数次操作 $u_j<a_1$），决斗在第 $k+1$ 轮就会停止。也就是说，$A$ 若选择吃，它一定不会被吃掉；因此 $A$ 一定会选择吃。

这时再回来看第 $k-1$ 轮做决策的蛇，可以发现它就是在第 $k$ 轮会被吃掉的蛇。所以第 $k-1$ 轮的蛇不会选择吃，**决斗至少在 $k-1$ 轮就结束了**。

于是这时我们直接停止模拟，从 $k-2$ 轮往回扫即可（注意到 $k-1$ 轮决斗结束，没有蛇死亡，不用管）。

## CODE

```cpp
#include <cstdio>
#include <cstring>

const int MAXN =1e6+20;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

void write(const int &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

/*------------------------------Main------------------------------*/

int q1[MAXN], h1, t1,
	q2[MAXN], h2, t2;
int a[MAXN], a_backup[MAXN];

inline int get_max(const int &id_1, const int &id_2){
	if(id_1 == 0 || id_2 == 0)
		return (id_1 == 0) ? id_2 : id_1;
	if(a[id_1] == a[id_2])
		return (id_1 > id_2) ? id_1 : id_2;
	else
		return (a[id_1] > a[id_2]) ? id_1 : id_2;
}

inline int get_min(const int &id_1, const int &id_2){
	if(id_1 == 0 || id_2 == 0)
		return (id_1 == 0) ? id_2 : id_1;
	if(a[id_1] == a[id_2])
		return (id_1 < id_2) ? id_1 : id_2;
	else
		return (a[id_1] < a[id_2]) ? id_1 : id_2;
}

int master[MAXN]/*每轮做决策的蛇*/,
	t_die[MAXN]/*每条蛇的死亡时间*/;

int main(){
//	freopen("snakes.in", "r", stdin);
//	freopen("snakes.out", "w", stdout);
	int n;
	for(int t =0, T =read(); t < T; ++t){
		if(t == 0){
			n =read();
			for(int i =1; i <= n; ++i)
				a[i] =read();
		}
		else{
			for(int i =0, k =read(); i < k; ++i){
				int x =read(), y =read();
				a[x] =y;
			}
		}
		
		memcpy(a_backup+1, a+1, n*sizeof(int));
		for(int i =1; i <= n; ++i)
			q1[n-i+1] =i;
		h1 =1, t1 =n+1;
		h2 =1, t2 =1, q2[h2] =0, q2[t2-1] =0;
		memset(t_die, 0x3f, sizeof(t_die));
		
		int ans =0;/*第几轮停下，从 0 开始计数*/
		for(int i =0; i < n-1; ++i){
			int mxi =get_max(q1[h1], q2[h2]),
				mni =get_min(q1[t1-1], q2[t2-1]);
			if(mxi == q1[h1])
				q1[h1] =0, ++h1;
			else
				q2[h2] =0, ++h2;
			if(mni == q1[t1-1])
				--t1, q1[t1] =0;
			else
				--t2, q2[t2] =0;
			master[i] =mxi;
			t_die[mni] =i;
			a[mxi] -=a[mni];
			if(i == n-2){
				ans =i+1;
				/*最后一轮的蛇 = 倒数第二轮的蛇 不用考虑，因为它不会死*/
				for(int k =i-1; k >= 0; --k)
					if(ans > t_die[master[k]])
						ans =k;
			}// 不满足单调性，可以发现决策已经结束 -V //
			else if(t2 > h2 && get_min(q2[t2-1], mxi) != mxi){
				ans =i-1;
				/*在 i-1 轮，那条蛇就会停下来，否则它就会被吃掉*/
				for(int k =i-2; k >= 0; --k)
					if(ans > t_die[master[k]])
						ans =k;
				break;
			}
			else
				q2[t2++] =mxi;
		}
		
		write(n-ans), putchar('\n');
		
		memcpy(a+1, a_backup+1, n*sizeof(int));
	}
}
```

---

## 作者：FjswYuzu (赞：14)

就离谱。70 如此好打考场上面没敢实现。

首先有一个非常显然的结论，也就是说如果一条蛇做出了选择（无论吃与不吃）并且不会成为最小的一条蛇，这条蛇以后就永远不会被吃了。

考虑到这个问题是具有严格偏序性质的。假设当前排出来的蛇的序列为 $a_1,a_2, \cdots ,a_n$，并且保证 $a$ 单调不减（因为有编号）。

- 不吃：结束游戏，不会被吃；   
- 吃：
  - 如果仍然是最强的蛇，肯定不会被吃；   
  - 如果弱了，显然 $a_n - a_1 > a_{n-1} - a_2$，所以说如果下一条最大的蛇要吃，肯定也比当前这个最大的蛇吃掉后小，会吃。

所以说我们用一个容器，每次找到最大最小的蛇，相减比较。考虑以下按以下流程进行算法。

- 找到当前的最小蛇 $x$，次小蛇 $y$，最大蛇 $z$；   
- 如果 $z-x > y$，吃掉；   
- 否则，我们的答案就与「下一只最大的蛇是否会吃」有关。再对这个子问题进行决策判断即可。

定义「冒险」为当前的最大蛇吃掉了最小蛇变成了最小蛇。

有一个比较显然的计算答案的方法就是每次递归找往上传答案。但是实际上我们知道有蛇开始「冒险」的时候，还有多少条蛇，设为 $p$；「冒险」的蛇有多少，设为 $q$。答案就是 $p-(q \bmod 2)$。

对于 $p$ 是显然的，关键是 $(q \bmod 2)$ 是怎么来的。

这个可以用感性理解。如果说最后一个「冒险」的蛇「冒险」之后死不掉，那么倒数第二个「冒险」的蛇就不会选择去「冒险」。依次往上传，就有了这样的答案。但是 $O(Tn \log n)$ 的代码没那么写。

支持动态删除插入查询最大最小次小值，可以用 `set` 去维护。时间复杂度 $O(Tn \log n)$。

附一个 luogu 民间数据 $75 \sim 90$ 的代码（代码很丑，而且愣是没卡过）。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
char buf[1<<16],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<16,stdin),p1==p2)?EOF:*p1++)
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(int x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
struct Snake{
	int val,pos;
	Snake(int V=0,int P=0){val=V,pos=P;}
	bool operator < (Snake ano) const {return val<ano.val || (val==ano.val && pos<ano.pos);}
	Snake operator - (Snake ano) const {return Snake(val-ano.val,pos);}
};
set<Snake> S;
int n,a[1000005],ans;
bool dfs(bool flag)
{
	if(int(S.size())==2)	return true;
	int del=0;
	while(int(S.size())>=3)
	{
		set<Snake>::iterator it1=S.begin(),it2=S.begin(),it3=S.end();
		++it2,--it3;
		int tmp=int(S.size());
		Snake x=*it1,y=*it2,z=*it3,dec=z-x;
		S.erase(it3);
		S.erase(it1);
		S.insert(dec);
		if(dec<y)
		{
			if(!dfs(true))
			{
				ans=tmp-1;
				return true;
			}
			else if(del)
			{
				ans=tmp;
				return true;
			}
			else
			{
				ans=tmp;
				return false;
			}
		}
		++del;
		if(del && flag)	return true;
	}
	ans=1;
	return true;
}
int main(){
	int T=read();
	n=read();
	long long sum=0;
	for(int i=1;i<=n;++i)	a[i]=read(),sum+=a[i];
	sum-=a[n];
	if(n==3)
	{
		if(a[1]+a[2]<=a[3])	puts("1");
		else	puts("3");
	}
	else
	{
		if(sum<=a[n])	puts("1");
		else
		{
			for(int i=1;i<=n;++i)	S.insert(Snake(a[i],i));
			ans=n;
			dfs(false);
			write(ans);
			puts("");
		}
	}
	--T;
	while(T-->0)
	{
		int k=read();
		for(int i=1;i<=k;++i)
		{
			int pos=read(),val=read();
			sum-=a[pos];
			a[pos]=val;
			sum+=a[pos];
		}
		if(n==3)
		{
			if(a[1]+a[2]<=a[3])	puts("1");
			else	puts("3");
			continue;
		}
		if(sum<=a[n])
		{
			puts("1");
			continue;
		}
		S.clear();
		for(int i=1;i<=n;++i)	S.insert(Snake(a[i],i));
		ans=n;
		dfs(false);
		write(ans);
		puts("");
	}
	return 0;
}
```

考虑优化，我们仔细回顾一下之前证明的那个结论。也就是 $a_n - a_1 > a_{n-1} - a_2$。

这个性质会不会指引我们去用两个队列存一下原有蛇和吃掉了小蛇后变成的蛇（分别记成第一个队列和第二个队列）呢？

这个方法是有效的，必须满足一下四种情况：

- 如果最大最小蛇都是原有的，那么新蛇小于第二个队列中的最小蛇；   
- 如果最大最小蛇都不是原有的，那么新蛇小于第二个队列中的最小蛇；   
- 如果最大蛇是原有的，最小蛇不是原有的，那么新蛇小于第二个队列中的最小蛇；   
- 如果最大蛇不是原有的，最小蛇是原有的，那么新蛇小于第二个队列中的最小蛇。

第一种情况：

因为 $a_n - a_1 > a_{n-1} - a_2$，归纳可证明；

第二种情况：

乍一看是不符合的，实际上「不是原有的」和「冒险」是等价的。这样的话最小蛇肯定不会冒险，实际上这种情况是不存在的。

第三种情况：

同第二种情况。

第四种情况：

考虑用第一种情况归纳下来的结论，发现出现这种情况的条件是第二个队列只有一条蛇而且这条蛇是最大蛇，所以这种情况显然是成立的。

至此，可以用两个双端队列/链表去维护两个队列，时间复杂度 $O(Tn)$，实际操作并没有什么两样。随便改一下应该就能过。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
char buf[1<<16],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<16,stdin),p1==p2)?EOF:*p1++)
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(int x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
struct Snake{
	int val,pos;
	Snake(int V=0,int P=0){val=V,pos=P;}
	bool operator < (Snake ano) const {return val<ano.val || (val==ano.val && pos<ano.pos);}
	Snake operator - (Snake ano) const {return Snake(val-ano.val,pos);}
}q1[1000005],q2[1000005];
//set<Snake> S;
int n,a[1000005],ans,l1,r1,l2,r2;
Snake Max()
{
	if(l1>r1)	return q2[l2++];
	if(l2>r2)	return q1[r1--];
	if(q1[r1]<q2[l2])	return q2[l2++];
	return q1[r1--];
}
Snake Min()
{
	if(l1>r1)	return q2[r2--];
	if(l2>r2)	return q1[l1++];
	if(q1[l1]<q2[r2])	return q1[l1++];
	return q2[r2--];
}
void dfs()
{
	int risk=0,kill=0,dep=0;
	while(1)
	{
		++kill;
		Snake x=Max(),z=Min(),y=min(l1<=r1?q1[l1]:Snake(100860010,n+1),l2<=r2?q2[r2]:Snake(1008610010,n+1)),dec=x-z;
		if(y<dec || kill==n-1)
		{
			if(risk)
			{
				write(n-risk+(dep&1));
				puts("");
				break;
			}
			if(kill==n-1)
			{
				puts("1");
				break;
			}
			q2[++r2]=dec;
		}
		else
		{
			++dep;
			if(!risk)	risk=kill;
			q2[++r2]=dec;
		}
	}
}
int main(){
	int T=read();
	n=read();
	long long sum=0;
	for(int i=1;i<=n;++i)	a[i]=read(),sum+=a[i];
	sum-=a[n];
	if(n==3)
	{
		if(a[1]+a[2]<=a[3])	puts("1");
		else	puts("3");
	}
	else
	{
		if(sum<=a[n])	puts("1");
		else
		{
			l1=1,r1=n,l2=1,r2=0;
			for(int i=1;i<=n;++i)	q1[i]=Snake(a[i],i);
			ans=n;
			dfs();
		}
	}
	--T;
	while(T-->0)
	{
		int k=read();
		for(int i=1;i<=k;++i)
		{
			int pos=read(),val=read();
			sum-=a[pos];
			a[pos]=val;
			sum+=a[pos];
		}
		if(n==3)
		{
			if(a[1]+a[2]<=a[3])	puts("1");
			else	puts("3");
			continue;
		}
		if(sum<=a[n])
		{
			puts("1");
			continue;
		}
		l1=1,r1=n,l2=1,r2=0;
		for(int i=1;i<=n;++i)	q1[i]=Snake(a[i],i);
		ans=n;
		dfs();
	}
	return 0;
}
```

---

## 作者：cyffff (赞：9)

[$\text{Link}$](https://www.luogu.com.cn/problem/P7078)

时隔四年来修订一下这篇题解。
## 题意
给你一个长为 $n$ 的数组 $a_{1\sim n}$，有 $n$ 条蛇，它们的实力依次为 $a_1,a_2,\dots,a_n$，保证 $a_{1\sim n}$ 升序。接下来每个时刻，实力值最大的蛇可以决定是否吃掉实力值最小的蛇，如果选择吃，那么其实力值将会减去被吃的蛇的实力值。实力值相同时按照编号进行实力的比较。

每条蛇目标均为在自己不会被吃的前提下尽可能吃最多的蛇，且每条蛇均采用最优策略，求出最后剩余的蛇的数量。多组数据。

$n\le 10^6$，$T\le 10$。
## 思路

进行分类讨论。第一类情况是 $a_n-a_1\ge a_2$，即最强的蛇吃完后并非最弱的蛇。假设之后有一时刻其成为了最弱的蛇，那么当前最弱的蛇 $a_2$ 一定被吃了，设吃掉它的是 $a_k$，那么蛇 $k$ 的当前实力为 $a_k-a_2$，又有 $a_k\le a_n,a_2\ge a_1$，所以此时应该是蛇 $k$ 最弱，这与我们的假设矛盾。

于是我们可以得出结论，如果最强的蛇吃完后不是最弱的蛇，那么它一定会吃，并且在之后的任意时刻不可能**在此类情况中**成为最弱的蛇。

接下来是第二类情况 $a_n-a_1<a_2$，最强的蛇吃完后成为了最弱的蛇。它会这么做的前提是在当前次强蛇的最优策略中不会吃掉它。则有以下情况：

- $a_{n-1}-(a_n-a_1)\ge a_2$，这种情况下由先前的讨论得知蛇 $n-1$ 一定会选择吃，那么蛇 $n$ 就不会选择吃；
- $a_{n-1}-(a_n-a_1)<a_2$，此时蛇 $n-1$ 成为了最弱的蛇，它会这么做的前提又是当前的蛇 $n-2$ 不会选择吃了。

对于后者，这是一个递归处理的过程，直到一次判断只剩下两条蛇或者局面为前者，此时当前最强蛇必吃。

那么进行一些模拟之后我们可以得到，如果递归层数为偶数，当前的最强蛇会选择直接结束；而如果递归层数为奇数，当前的最强蛇会选择吃，此时次强蛇的递归层数为偶数，不会选择继续吃。

考虑维护这个过程。朴素的想法是使用堆进行维护，时间复杂度为 $O(Tn\log n)$，难以通过本题。

考虑一个经典的思路，使用两个队列模拟堆。我们用两个双端队列 $p,q$ 分别维护没吃过的蛇、吃过的蛇。由上述推导，队列 $q$ 中的蛇除了最后一次特殊情况外都不可能成为最弱的蛇。

取出最强的蛇可比较两个队列的末尾，取出最弱的蛇直接从 $p$ 前端取出即可。不断进行第一类情况的模拟直到队列 $p$ 为空或出现第二类情况，此时需要判断当前最强的蛇会不会进行一次吃的操作。

时间复杂度 $O(Tn)$，可以通过。

---

## 作者：寄风 (赞：8)

先说几个比较关键的观察。

首先一条蛇如果吃了不会变成最弱的，那么他就一定会吃。

因为下一条最强蛇如果不吃那么游戏就结束了，他还活着。

如果吃的话你会发现最弱蛇是越来越强的，最强蛇是越来越弱的，所以下一条蛇吃了之后肯定比这条蛇弱小，所以下一条蛇为了保命不会死，而这条蛇因为比下一条蛇强，所以这条蛇也不会死。

那如果变成最弱的了咋办呢？

首先有一个结论，就是这个阶段只会有最多一条蛇被吃。

这个很好理解，就是说如果最强蛇吃了然后变成最弱蛇会被吃，那么它为了保全自己就会不吃。

那你就要看下一条蛇咋选择。

如果下一条蛇可以吃而且不会死，那么这条蛇就会死，那么它就不会吃。

那么下一条蛇又会考虑下下条蛇，所以你发现这是一个链式的考虑，直到有条蛇吃了不会变成最弱的，然后你去倒推，发现倒数第二条不会吃，倒数第三条会吃，以此类推。

### $70\texttt{pts}$

直接用堆维护最强最弱蛇即可。

```cpp
#define pb push_back
#define	ite set <int> :: iterator 
int a[10000005] , n , cnt , dis;
set < pair <int , int> > q;
//24 38 43
inline int work(){
	q.clear();
	for(int i = 1;i <= n;i++) q.insert(make_pair(a[i] , i));
	int endpos = 0;
	int ans;
	while(1){
		if(q.size() == 2){
			q.erase(q.begin());
			if(endpos){
				ans = (endpos - q.size()) % 2 + endpos;
			}
			else{
				ans = 1;
			}
			break;
		}
		int maxn = (*q.rbegin()).first , minn = (*q.begin()).first , id = (*q.rbegin()).second;
		q.erase(q.lower_bound(make_pair(maxn , id)));
		q.erase(q.begin());
		q.insert(make_pair(maxn - minn , id));
		if((*q.begin()).second != id){
			if(endpos){
				ans = (endpos - q.size()) % 2 + endpos;
				break;
			}
		}
		else if(!endpos){
			endpos = q.size();
		}
	}
	return ans;
}
signed main(){
	int t;
	read(t);
	t--;
	read(n);
	for(int i = 1;i <= n;i++) read(a[i]);
	print(work() , '\n');
	while(t--){
		int k;
		read(k);
		for(int i = 1;i <= n;i++){
			int pos , data;
			read(pos , data);
			a[pos] = data;
		}
		print(work() , '\n');
	}
    return 0;
}
```

### $100\texttt{pts}$

考虑回到之前的观察，我们发现最强的蛇单调不升，最弱的蛇单调不降，而吃过蛇的蛇也单调不升，所以你可以类似蚯蚓的，开 `deque` 来维护。

于是就过了。

```cpp
int a[1000005] , n;
#define pii pair <int , int>
inline int work(){
     deque < pii > q1 , q2;
     for(int i = 1;i <= n;i++){
         q1.push_back(make_pair(a[i] , i));
     }
     int ans = 0;
     while(true){
         if(2 - q1.size() == q2.size()){
             ans = 1;
             break;
         }
         int y = q1.front().first , x , id;
         q1.pop_front();
         if(!q2.size() || (q1.size() && q1.back() > q2.back())){
             x = q1.back().first , id = q1.back().second;
             q1.pop_back();
         }
         else{
             x = q2.back().first , id = q2.back().second;
             q2.pop_back();
         }
         pii now = make_pair(abs(x - y) , id);
         if(!q1.size() || q1.front() > now){
             ans = q1.size() + 1 + q2.size() + 1;
             int cnt = 0;
             while(true){
                 cnt++;
                 if(q1.size() + q2.size() == 1){
                     ans -= 1 - cnt % 2;
                     break;
                 }
                 int x , id;
                 if(!q2.size() || (q1.size() && q1.back() > q2.back())){
                     x = q1.back().first , id = q1.back().second;
                     q1.pop_back();
                 }
                 else{
                     x = q2.back().first , id = q2.back().second;
                     q2.pop_back();
                 }
                 now = make_pair(x - now.first , id);
                 if(!((!q1.size() || now < q1.front()) && (!q2.size() || now < q2.front()))){
                     ans -= 1 - cnt % 2;
                     break;
                 }
             }
             break;
         }
         else{
             q2.push_front(now);
         }
     }
     return ans;
}
signed main(){
	int t;
	read(t);
	t--;
	read(n);
	for(int i = 1;i <= n;++i) read(a[i]);
	print(work() , '\n');
	while(t--){
		int k;
		read(k);
		for(int i = 1;i <= k;++i){
			int pos , data;
			read(pos , data);
			a[pos] = data;
		}
		print(work() , '\n');
	}
    return 0;
}
```

完结撒花！

---

## 作者：EternalHeart1314 (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P7078)

蛇年到，做蛇题。而且这是我做过的第一道黑题，2023 做的，现在才发现可以交题解，纪念一波。

不算很长的长文警告。

首先看到一个问题：草原上有 $100$ 条蛇和一只小粉兔，每条蛇都想吃到小粉兔，但是小粉兔可是 NOI rk51 的强大存在。她诅咒吃掉她的蛇会变成新一只小粉兔，而且诅咒会转移到新的小粉兔上。每条蛇都很 clever，它们会尽可能地让自己活下去。请问并不可爱的小粉兔会被吃掉吗？

当然是不会啦。~~毕竟小粉兔可是掉进过粪坑（小粪土），变成了小棕兔，谁敢吃啊。~~

当有 $0$ 条蛇的时候：没蛇咋被吃？

当有 $1$ 条蛇的时候：小粉兔会被唯一一条蛇吃掉。

当有 $2$ 条蛇的时候：小粉兔不会被吃，因为某条蛇吃了之后就变成 $1$ 条蛇的情况，它就被吃了，它当然不想死。

当有 $3$ 条蛇的时候：会被吃，因为某条蛇吃了后就变成 $2$ 条蛇的情况，它就是安全的。

当有 $n(n\in\mathbb{N})$ 条蛇的时候：如果 $2|n$，即 $n$ 是偶数，那么小粉兔不会被吃；否则会。

好了，再看回这道题，每条蛇都有体力值，其实就是强壮值啦。那么那条最虚的蛇就是上述的可怜巴巴的小粉兔，以下的小粉兔就是指最虚的那条蛇。

再感性理解一下，由于所有蛇都是 clever 的，所以如果小粉兔注定被吃，蛇蛇们肯定会抢着吃，那么在排除宇宙射线的干扰和蝴蝶效应的情况下，最强壮的蛇自然会抢到小粉兔，就叫它蛇老大吧。

而且，吃掉小粉兔后**并不一定**会变成小粉兔，例如 $3$ 条蛇的体力值分别为 $1,2,4$，$4$ 吃掉 $1$ 后还剩 $3$，欸，倒数第二虚的 $2$ 变成了最虚的了，真是一只倒霉的替罪羊，哦不，是一条倒霉的替罪蛇。

现在来看思路。

当前这条是蛇老大，如果它吃掉小粉兔后不会成为新的小粉兔，那么它肯定会吃。

那如果变成了小粉兔呢，按刚刚的想法继续往下想。它会不会被吃取决于第二强壮的蛇——蛇老二，它会不会吃掉小粉兔呢？

如果蛇老二吃掉了新的小粉兔（也就是蛇老大）后它不会变成新的新的小粉兔，那它肯定会吃。这时蛇老大就不乐意了，它吃了小粉兔就被谋权篡位了，当然不会吃。

如果蛇老二会变成新的新的小粉兔，那继续往下想。接下来第三强壮的蛇——蛇老三，它和蛇老大和蛇老二一样，也会这么想……

这样就形成一个递归（代码里是循环），欸，这和开头的那个好像，难道……这也和奇偶性有关？答案是肯定的。

那么我们只要模拟这个过程啦，可以用 set 记录每条蛇的体力值。

但是我们发现这样子是过不了的（好吧骗你的，超级快读可以草过去），因为还有 $T-1$ 次修改，怎么办呢？

我们发现，所有蛇的体力值是越吃越少的，而且不会有蛇的体力值增加，进一步发现蛇老大越来越虚（雾），小粉兔越来越强壮（果然还得是传奇 PinkRabbit），所以可以用两个单调的双端对列 $q_1$ 和 $q_2$ 维护这个过程。

具体地，先把所有蛇按体力值从小到大塞进 $q_1$ 里，每次取出 $q_1$ 和 $q_2$ 的队尾（$q_2$ 为空则忽略）的较大值，也就是取出了蛇老大。

然后再取出 $q_1$ 的队首（为什么不用取 $q_2$ 的呢，下面会讲到），这就是小粉兔啦。

如果蛇吃了小粉兔不会变成新的小粉兔，那就吃！把蛇的体力值减去小粉兔的体力值，塞进 $q_2$ 的队首（由于蛇老大越来越虚，小粉兔越来越强壮，所以塞进 $q_2$ 的蛇越来越虚，$q_2$ 也就是单调递增的了）。否则就开始上述的递归思考（这个随便搞搞就行）。

因为蛇吃了小粉兔不会变成新的小粉兔才会被塞进 $q_2$，所以 $q_2$ 的队首一定大于 $q_1$ 的队首。

那会不会在 $q_2$ 中出现相等的情况，这样不就不能保证一定会吃哪个？当然不会，因为题目中定义了体力值相同，则编号大的更大，所以相等的情况也是正确的，可以自己模拟一下。

# Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define Back(x) (q[x].size() ? q[x].back() : null)
#define Front(x) (q[x].size() ? q[x].front() : inf)
using namespace std;

const int N = 1e6 + 7;
int T, n, m, k, c, x, y, a[N];

void solve() {
	deque<pair<int, int> > q[3];
	for (int i = 1; i <= n; ++i) q[1].push_back({a[i], i});
	c = 0, m = 1;
	pair<int, int> x, y, z, null = {-1, -1}, inf = {1e9, 1e9};
	while (q[1].size() + q[2].size() > 2) {
		y = q[1].front(), q[1].pop_front(); // 小粉兔
		Back(1) > Back(2) ? (x = Back(1), q[1].pop_back()) : (x = Back(2), q[2].pop_back()); // 蛇老大
		x.fi -= y.fi; // 吃！
		if (q[1].empty() || x < q[1].front()) {
			m = q[1].size() + q[2].size() + 2; // 蛇的数量
			while (q[1].size() + q[2].size() > 1) { // 思考……
				Back(1) > Back(2) ? (z = Back(1), q[1].pop_back()) : (z = Back(2), q[2].pop_back()); // 蛇老大
				x = {z.fi - x.fi, z.se}; // 吃！
				if (x > min(Front(1), Front(2))) break; // 可以吃，结束！
				++c; // 继续思考……
			}
			break;
		} q[2].push_front(x); // 吃！
	}
	cout << m - (c & 1) << '\n'; // 奇偶性处理，如果是奇数则还能再吃一次小粉兔
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> T >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	solve();
	while (--T) {
		cin >> k;
		while (k--) cin >> x >> y, a[x] = y;
		solve();
	} 
	return 0;
}
```

---

## 作者：cyh_toby (赞：7)

UPD: 补充了一条贪心结论的归纳证明。

## 题意

原题：[[CSP-S2020] 贪吃蛇](https://www.luogu.com.cn/problem/P7078)

- 蛇按权为第一关键字，编号为第二关键字排序。

- 每次最大的蛇可以选择吃最小的蛇，并把权减去最小的蛇作为新权；或者选择结束游戏。

- 蛇希望在活着的前提下吃更多的蛇，并且蛇足够聪明。

- 求最后剩几条蛇。

- 多组测试。

## 分析

这是贪心以及博弈综合。

结论：

> 1.如果当前最大的蛇吃了最小的蛇，没有成为新的最小的蛇，必然选择吃。特殊的，两条蛇的时候必然会选择吃。
> 2.如果会成为最小的蛇，需要考虑还会经过多少轮到达一个上述 1 的局面。如果相距轮数为偶数则吃，否则不吃并结束。

对于 1，显然可以归纳证明。

- $n=2,3$ 时成立。
- 假设 $n$ 条蛇的时候成立。新加入第 $n+1$ 条蛇后，记最大、次大、次小、最小的蛇分别为 $a,b,c,d$ 。即要证明 $c<a-d$ 时 $a-d$ 不会被吃掉。由于 $n$ 条蛇时命题成立，所以要么 $b$ 选择不吃，结束游戏，此时 $n+1$ 的命题成立；要么 $b$ 选择吃 $c$，且必然满足 $b-c$ 不会被吃掉。由于 $a-d>b-c$ ，所以 $a-d$ 也必然不会被吃掉，所以命题成立。

对于 2，考虑达到 1 局面的时候为第 $k$ 轮，此时最小的蛇必定会被吃掉。那么在 $k-1$ 轮的时候，最大的蛇若选择吃，就会变成最小的蛇，进而在第 $k$ 轮被吃掉，所以它不会选择吃。因此 $k-2$ 轮的最大蛇不会因为变成最小的蛇而在第 $k-1$ 轮被吃掉，所以它可以吃，因此他会选择吃。同理往上推就可以了。

所以我们需要一个数据结构，每次可以取出最大值和最小值，并插入新值。配合这个数据结构模拟即可。

由于 $n \le 10^6$ 并且 $T \le 10$ ，这个数据结构不能带 $\log$ ，必须是线性的。

引理：

> 后吃的蛇吃之后变成的蛇 必定小于 先吃的蛇吃之后变成的蛇。（因为有第二关键字在，这里不考虑等号）

可以反证证明。

考虑 $a>b>c>d>e$ 。必然有 $a$ 吃 $e$ 变成 $a-e$ 。

- 若 $a-e>b$ ，最大蛇还是 $a$ ，必然满足引理。
- 若 $b>a-e>c$，则下一轮 $b$ 吃 $d$ 变成 $b-d$ ，显然 $a-e>c>b-d$ ，最大的蛇还是 $a$，继续进行下去无法推翻引理。
- 若 $c > a-e > d$ ，下一轮 $b$ 吃 $d$ 变成 $b-d$ ，局面变成 $c>a-e>b-d$ 。下一轮有 $c$ 吃 $b-d$ 变成 $c-b+d$。假设不满足引理，即 $c-b+d>a-e$ 。由于 $c-b<0$，故有 $d>a-e$ 。但这种情况是满足 $a-e>d$ 的，矛盾，故假设不成立，原命题成立。
- 若 $d > a-e$ ，$a$ 成了最小的蛇，根据贪心结论，它不会被吃掉，游戏结束，故满足引理。

综上，引理成立。

所以我们可以用类似 [[NOIP2016]蚯蚓](https://www.luogu.com.cn/problem/P2827) 的方法，开两个队列，在维护时保证分别单增。这可以 $O(1)$ 取出全局最大值最小值。具体地，先把整个数列丢进 $q_1$，每次吃出的新蛇从队头丢进 $q_2$ 。由引理知 $q_2$ 继续单增。因此可以线性维护。

如果要减小常数可以手写队列，但本人手写之后感觉这里直接用 `deque` 更方便。

其它细节见代码。

## 源码

```cpp
#define gc getchar
#define mkp make_pair
#define fi first
#define se second
typedef pair<int,int> pii; 
const int N = 1e6+5;
const pii inf = mkp(1e9+5, 1e6+5), ind = mkp(-1e9-5, 0);

inline int rd() {
	int x = 0, fg = 1;
	char ch = gc();
	while (ch < '0' || ch > '9') {
		if (ch == '-') fg = -1;
		ch = gc();
	}	
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + ch - '0';
		ch = gc();
	}
	return x * fg;
}

int n;
int a[N];

pii q1[N], q2[N];//维护时保证两个队列单增 
int hd1, tl1, hd2, tl2;

inline int add(int x) { if (++x == N) x = 0; return x; }
inline int sub(int x) { if (--x == -1) x = N-1; return x; }
inline pii mx1() { return sub(hd1) != tl1 ? q1[tl1] : ind; }
inline pii mn1() { return sub(hd1) != tl1 ? q1[hd1] : inf; }
inline pii mx2() { return sub(hd2) != tl2 ? q2[tl2] : ind; }
inline pii mn2() { return sub(hd2) != tl2 ? q2[hd2] : inf; }

int solve() {
	hd1 = hd2 = 0, tl1 = tl2 = N-1;
	int num = n, sum = n;//num为真实的蛇的数量, sum 为假设可以继续进行的蛇数量 
	for (int i = 1; i <= n; i++) q1[tl1 = add(tl1)] = mkp(a[i], i);
	int flag = 0, cur = 0;//是否进入第二阶段, 进入轮数的奇偶 
	while (sum >= 2) {
		pii mx, mn;
		if (mx1() < mx2()) mx = mx2(), tl2 = sub(tl2);
		else mx = mx1(), tl1 = sub(tl1);
		if (mn1() > mn2()) mn = mn2(), hd2 = add(hd2);
		else mn = mn1(), hd1 = add(hd1);
	
		mx.fi -= mn.fi;
		sum--;
		
		if (sum >= 2 && mx < min(mn1(), mn2())) {
			if (flag) cur ^= 1;
			else flag = 1;
		}
		else {
			if (flag) return num - cur;
			num--;
		}
		q2[hd2 = sub(hd2)] = mx;
	}
	return num;
}

int main()
{
	int T = rd();
	for (int i = 1; i <= T; i++) {
		if (i == 1) {
			n = rd();
			for (int j = 1; j <= n; j++) a[j] = rd();
		}
		else {
			int k = rd();
			for (int j = 1; j <= k; j++) a[rd()] = rd();
		}
		printf("%d\n", solve());
	}
	return 0;
}
```

本代码参考了 [这篇题解](https://www.luogu.com.cn/blog/QAQAutoMaton/csp-s-2020-snakes)。

如果上述分析存在漏洞，还请大佬们指正。

---

## 作者：TEoS (赞：6)

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/13959808.html)

------------

**题意分析**

给出一个序列，以权值为第一关键字，编号为第二关键字单调递增，每次操作让最大元素的权值减去最小元素的权值，删除最小元素，将最大元素插回序列并维护单调性，且每次操作要使当前最大元素操作后不必定被删除，求最后最少能剩下几个元素。

**思路分析**

设原序列为 $\{a_n\}$ 。为了方便表述，本文对序列  $\{a_n\}$ 中的元素的大小比较均指以权值为第一关键字，编号为第二关键字的比较。显然，这种比较不会出现相等的情况。其中，$val_i,num_i$ 分别表示元素 $i$ 的权值、编号。

分析后可以发现，操作终止时有两种情况。第一种就是只剩下一个元素，这个显然；第二种是当出现一个最大元素操作后会成为最小元素时。若这个最大元素成为最小元素后，下一个操作进行了，把它删了，那之前那个操作就不会进行；否则下一个操作就不会进行，同样终止。

第一种情况很好判断，主要分析第二种情况。根据上面的分析，只要有一个最大元素操作后会成为最小元素，操作就会终止。因此，在之前的操作中，最大元素操作后一定不会成为最小元素。

> 引理一：在出现最大元素操作后成为最小元素之前，操作后的元素存在单调性，即先操作的元素一定大于后操作的元素
>
> 简单证明：
>
> 先考虑权值均不等的情况。显然，设当前序列为 $a_1,a_2,a_3,...,a_{n-1},a_n$ ，则有 $val_1<val_2<val_3<...<val_{n-1}<val_n$ 。因为最大元素操作后不会成为最小元素，因此两次操作后的权值一定依次是 $val_n-val_1,val_{n-1}-val_2$ ，显然有 $val_n-val_1>val_{n-1}-val_2$ 。
>
> 再考虑权值出现相等的情况。根据题设条件有 $val_1\leq val_2\leq val_3\leq...\leq val_{n-1}\leq val_n$ 。若两次操作后的权值是相等的，即 $val_n-val_1=val_{n-1}-val_2$ ，那么一定有 $val_1=val_2,val_{n-1}=val_n$ ，因此有 $num_1<num_2,num_{n-1}<num_n$ ，那么先操作的 $a_n$ 仍然排在后操作的 $a_{n-1}$ 前面，不破坏单调性。

> 引理二：在出现最大元素操作后成为最小元素之前，一定是原序列  $\{a_n\}$ 从小到大被依次删除，即被删去的元素依次为 $a_1,a_2,a_3...$ 
>
> 简单证明：根据引理一，后操作的元素一定排在先操作的元素后面。因此，对于操作后不是最小元素的元素，下一次操作一定会有一个元素小于它而排在它后面，因此它一定不会成为最小的元素而被删除。而操作后的元素不会成为最小元素，因此被删除的元素一定是没操作过的元素，即原序列从小到大依次删除。

根据引理一，我们可以用一个队列维护操作后的元素，当前最大的元素就是原序列的最大元素和队头元素中更大的，即操作后和没操作的元素中更大的。

根据引理二，对于第 $i$ 次操作，被删除的最小元素即为 $a_i$ 。

综上，我们可以 $O(n)$ 模拟操作，直到出现最大元素操作后成为最小元素或只剩一个元素为止。

现在的问题是，当出现最大元素操作后会成为最小元素时，这个操作究竟进不进行。

根据上面的分析，若下一个操作会进行而将它删除，则这个操作不进行；若不会删除，则进行。而下一个操作为什么不会进行呢？就是因为下一个操作进行后下下个操作会将它删除。这样讲可能有点绕。按照原题意，即当前这条最大的蛇预判次大蛇不敢吃它，所以它敢把最小的蛇吃了而成为最小的蛇。

对于最大元素操作成为最小元素后，我们无法直接判断这个操作是不是一定进行。而当最大元素操作后不成为最小元素时，这个操作一定进行。因此，我们需要知道哪一次操作后最大元素不成为最小元素或只剩下一个元素，显然这个操作是一定进行的，即破坏了引理一中提到的单调性。

为什么单调性会被破坏呢？引理一的前提是最大元素操作后不会成为最小元素，此时被删除的元素的权值单调不降，因此存在单调性；而出现最大元素操作后成为最小元素后，被删除的元素的权值的单调性不存在了，因此操作后的元素的单调性也会被破坏。

可以想到模拟接下来的操作，直到出现操作后最大元素不成为最小元素或只剩下一个元素为止。

显然，在这些操作中，被删除的元素一定是上一次操作中的最大元素操作后的元素，可以直接用一个变量存储。而因为操作后的元素均为最小，那么其它元素不受影响，所以最大的元素只要在其它元素中找到最大的即可，具体方法和之前的相同。

在模拟这些操作时统计次数，若在第一个最大元素操作后成为最小元素的操作后第 $x$ 个操作必定进行，那么第 $x-1$ 个操作必定不进行，第 $x-2$ 个操作必定进行，以此类推。因此当 $x$ 为偶数时，当前操作进行，答案减 $1$ ；否则当前操作不进行。

综上，我们找到了一种 $O(n)$ 求解的方案。

**具体操作**

1. 模拟操作，用一个队列维护操作后的元素，当前最大的元素为原序列的最大元素和队头元素中更大的，第 $i$ 次操作被删除的数为 $a_i$ 。当出现当前最大的元素操作后成为最小的元素，即小于 $a_{i+1}$ 时，进入第 $2$ 步操作；否则在只剩一个元素时停止模拟。

2. 模拟操作，当前最大元素为原序列的最大元素和队头元素中更大的，最小元素即为上一次操作后的元素。当出现当前最大的元素操作后不是最小的元素或只剩两个元素时停止模拟。

```c++
//FJ-00445
//NOIP2020 RP++
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int N=1e6+100,INF=1e9;
struct Node
{
	int val,num;
	#define val(i) a[i].val
	#define num(i) a[i].num
	bool operator < (const Node y)
	{
		return val==y.val?num<y.num:val<y.val;
	}
	bool operator == (const Node y)
	{
		return val==y.val && num==y.num;
	}
}a[N];
int T,n,k,ph,pb;
queue<Node> q;
Node blank={0,0},black={INF,INF};
Node Max(Node x,Node y)
{
	return (x<y)?y:x;
}
Node Min(Node x,Node y)
{
	return (x<y)?x:y;
}
bool query(Node la)//传入上一次操作后的元素
{
	int cnt=0;
	Node bk=Min(pb<ph?a[pb+1]:black,q.size()?q.back():black);//次小元素
	while(1)
	{
		Node hd=Max(pb<ph?a[ph]:blank,q.size()?q.front():blank);//最大元素
		if(a[ph]==hd)
			ph--;
		else
			if(q.size())
				q.pop();//维护指针和队列
		if(hd==bk)
			break;//只剩两个元素，即次小元素与最大元素相等
		hd.val-=la.val;
		if(bk<hd)
			break;//当前最大的元素操作后不是最小的元素
		la=hd;cnt++;//维护指针
	}
	return cnt&1;//在第 x 次操作终止，返回 x-1 的奇偶性
}
int main()
{
	scanf("%d",&T);
	for(int i=1;i<=T;i++)
	{
		if(i==1)
		{
			scanf("%d",&n);
			for(int j=1;j<=n;j++)
				scanf("%d",&val(j)),num(j)=j;
		}
		else
		{
			scanf("%d",&k);
			for(int j=1,x,y;j<=k;j++)
			{
				scanf("%d%d",&x,&y);
				val(x)=y;
			}
		}
		ph=n,pb=1;//分别为原序列最大元素和最小元素的指针
		while(q.size())
			q.pop();
		while(pb<=ph)
		{
			Node x=Max((ph>pb)?a[ph]:blank,q.size()?q.front():blank);//最大元素
			if(a[ph]==x)
				ph--;
			else
				q.pop();//维护指针和队列
			x.val-=val(pb);
			if(x<a[pb+1] && n-pb>1)//当前最大的元素操作后是最小的元素且剩下的元素不止一个
			{
				if(query(x))//求解是否进行本次操作
					pb++;
				break;
			}
			q.push(x);pb++;//维护指针和队列
		}
		printf("%d\n",n-pb+1);
	}
	return 0;
}
```




---

## 作者：xiaolilsq (赞：6)

# 题解 贪吃蛇

[题目链接](https://www.luogu.com.cn/problem/P7078)

[可能更好的阅读体验](https://www.cnblogs.com/lsq147/p/13946020.html)

一组可能可以 hack 掉你的代码的数据：

```
input:
1
15
0 1 2 2 2 2 3 3 4 5 5 6 7 8 8
output:
8
```

## 题目分析

本篇题解参考了 [EI 的一篇 blog](https://www.luogu.com.cn/blog/EntropyIncreaser/ying-ye-ri-zhi-2020117-yi-ci-xin-xi-fou-dui-cheng-yin-fa-di-csp2020-t4-post) ，实现有部分不同，建议大家去看看原文。

不难发现，操作序列是固定的，也就是说，如果吃蛇游戏进行了 $i$ 轮，那么第 $j(1\le j\le i)$ 轮的选择是固定的，所以我们可以把问题分解为“求每一轮是哪条蛇吃掉了哪条蛇”和“已知每一轮的吃蛇情况，求出答案”。

首先考虑“已知每一轮的吃蛇情况，求出答案”，不妨假设第 $i$ 轮的吃蛇情况是 $A_i$ 吃掉了 $B_i$ ，考虑从后往前递推，由于每条蛇都不想被吃掉，所以如果在第 $i$ 轮中， $A_i$ 选择吃掉 $B_i$ ，那么必须要满足在第 $i+1$ 轮及以后中 $A_i$ 都不会被吃掉，否则 $A_i$ 肯定会直接结束游戏，用一个桶来统计就可以得到答案了。

然后考虑“求每一轮是哪条蛇吃掉了哪条蛇”，这个很容易用平衡树或者堆等数据结构来维护，就是每次找出最大的和最小的，然后两个相减再放回去，但是这样的复杂度是 $\mathcal O(Tn\log_2n)$ 的，不够优秀。

不妨假设所有的蛇的实力从小到大实力一样编号从小到大依次为 $a_1,a_2,\dots,a_n$ ，如果 $a_n\ge 2a_1$ ，那么 $a_n-a_1\ge a_1$ ，此时最大值一定是不增的，最小值一定是不降的，可以用一个队列来维护，每次都把最大值减去最小值加入到队列中，不难发现，这个队列一定是单调的，这个套路和 “NOIP2016蚯蚓” 是一样的，我们使用一个队列来维护答案，直到最大值小于最小值的两倍。

此时 $a_n<2a_1$ ，此时 $a_1\ne 0$ ，可以得到每次取出的最大值减去最小值的值是多少：

1. 第一次操作，最大值减去最小值为 $a_n-a_1<a_1$ 。
2. 第二次操作，最大值减去最小值为 $(a_{n-1}-a_n)+a_1\le a_1$ 。
3. 第三次操作，最大值减去最小值为 $(a_{n-2}-a_{n-1})+a_n-a_1<a_1$ 。
4. ......

**需要注意的是，上面说的是“值”，但是实际比较大小的时候我们还需要比较编号。**

不难发现，最小值**最大**也是 $a_1$ ，所以我们可以使用一个数据结构来维护值为 $a_1$ 的所有的编号，首先不妨假设 $a_1=a_2=\cdots=a_m<a_{m+1}\le\cdots\le a_n$ ，那么在接下来 $n-m$ 轮中，每一轮的最大值依次为 $a_{n\sim m+1}$ 。

先考虑这 $n-m$ 轮，最大值固定，如何维护最小值？可以使用类似 $\mathcal O(n)$ 构造 prufer 序列的思路，用一个类似指针的东西来表示值为 $a_1$ 的所有编号中最小的是什么，然后每次“最大值减去最小值”如果比这个指针的值要小，或者等于这个指针的值但是编号小于这个指针的编号的话，这个“最大值减最小值”就是下一次的最小值，下一次一定会被删除，否则的话下一次的最小值就是这个指针指着的值，然后让指针跳下一个就行了，不难发现，这部分的时间复杂度是 $\mathcal O(n)$ 。

然后考虑后面 $m$ 轮，此时剩下的只有两种情况，一种情况是有一个值小于 $a_1$ ，其他值都等于 $a_1$ ，另一种情况是所有值都等于 $a_1$ 。

如果有一个值小于 $a_1$ ，不妨设为 $x$ ，那么 $x>0$ （因为 $n-m$ 轮中的最后一轮的最大值为 $a_{m+1}>a_1$ ，而每一轮的最小值都 $\le a_1$ ），于是最小值就依次是 $x,a_1-x,x,a_1-x,\dots$ ，所以一开始最大的蛇肯定会吃掉一开始小于 $a_1$ 的蛇，后面的蛇就吃掉上一次吃东西的蛇。

如果所有值都等于 $a_1$ ，那么一开始最大的蛇肯定会吃掉次小的蛇，然后实力变成 $0$ ，然后被次次小的蛇吃掉，然后次次小的蛇变成最大的蛇，一直继续下去。

这部分的时间复杂度也是 $\mathcal O(n)$ 。

综上，总的时间复杂度为 $\mathcal O(Tn)$ 。

## 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ch() getchar()
#define pc(x) putchar(x)
using namespace std;
template<typename T>void read(T&x){
	static int f;static char c;
	for(c=ch(),f=1;c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c>='0'&&c<='9';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>void write(T x){
	static int q[64];int cnt=0;
	if(x==0)return pc('0'),void();
	if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10,x/=10;
	while(cnt--)pc(q[cnt]+'0');
}
const int maxn=1000005;
int n,a[maxn],q0[maxn],q1[maxn],q2[maxn],A[maxn],B[maxn],in[maxn],cp[maxn],c2;
int hp[maxn];
void solve2(int st){
	for(int i=1;i<=n;++i)hp[i]=false;
	int key=a[q2[0]],p=1;hp[q2[0]]=true;
	while(p<c2&&a[q2[p]]==key)hp[q2[p]]=true,++p;
	int e=p,MN=0;p=1;while(!hp[p])++p;
	for(int i=c2-1;i>=e;--i){
		A[st]=q2[i];
		if(MN){
			B[st]=MN;
			if(((a[q2[i]]-=a[MN])<key)||q2[i]<p)
				MN=q2[i];
			else{
				MN=0;hp[q2[i]]=true;
			}
		}
		else{
			B[st]=p;hp[p]=false;++p;
			while(p<=n&&!hp[p])++p;
			a[MN=q2[i]]-=key;
		}
		++st;
	}
	if(MN&&a[MN]==key){
		hp[p=MN]=true;MN=0;
	}
	if(MN){
		for(int i=n;i>=1;--i)if(hp[i]){
			A[st]=i;B[st]=MN;++st;MN=i;
		}
	}
	else{
		int o=0;
		for(int i=n;i>=1;--i)if(hp[i]){
			o^=1;
			if(o){
				if(MN){
					A[st]=i,B[st]=MN;++st;
				}
				MN=i;
			}
			else{
				A[st]=MN;B[st]=i;++st;
			}
		}
	}
}
void solve(void){
	for(int i=1;i<=n;++i)cp[i]=a[i],in[i]=0;
	int f0=0,b0=0,f1=n,b1=n;
	for(int i=1;i<=n;++i)q0[b0++]=i;
	for(int i=1;i<n;++i){
		int mx=-1,mxp=0;
		if(f0<b0&&(a[q0[b0-1]]>mx||(a[q0[b0-1]]==mx&&q0[b0-1]>mxp)))mx=a[mxp=q0[b0-1]];
		if(f1<b1&&(a[q1[b1-1]]>mx||(a[q1[b1-1]]==mx&&q1[b1-1]>mxp)))mx=a[mxp=q1[b1-1]];
		int mn=1000000001,mnp=n+1;
		if(f0<b0&&(a[q0[f0]]<mn||(a[q0[f0]]==mn&&q0[f0]<mnp)))mn=a[mnp=q0[f0]];
		if(f1<b1&&(a[q1[f1]]<mn||(a[q1[f1]]==mn&&q1[f1]<mnp)))mn=a[mnp=q1[f1]];
		if(a[mxp]<a[mnp]*2){
			int _l=f0,_r=f1;c2=0;
			while(_l<b0||_r<b1){
				if(_r>=b1||(_l<b0&&(a[q0[_l]]<a[q1[_r]]||(a[q0[_l]]==a[q1[_r]]&&q0[_l]<q1[_r])))){
					q2[c2++]=q0[_l++];
				}
				else{
					q2[c2++]=q1[_r++];
				}
			}
			solve2(i);
			break;
		}
		A[i]=mxp;B[i]=mnp;
		if(f0<b0&&q0[f0]==mnp)++f0;else ++f1;
		if(f0<b0&&q0[b0-1]==mxp)--b0;else --b1;
		a[mxp]-=a[mnp];q1[--f1]=mxp;
	}
	int no=n;
	for(int i=n-1;i>=1;--i){
		++in[B[i]];
		if(in[A[i]])
			while(no>i)--in[B[--no]];
	}
	--no;
	for(int i=1;i<=n;++i)a[i]=cp[i];
	write(n-no),pc('\n');
}
int main(){
	int T;read(T),read(n);
	for(int i=1;i<=n;++i)read(a[i]);
	solve();--T;
	while(T--){
		int k;read(k);
		while(k--){
			int x,y;
			read(x),read(y);
			a[x]=y;
		}
		solve();
	}
	return 0;
}
```

---

## 作者：dengjunhaodejia09 (赞：5)

总结 csp-s2020 ，正好写篇题解，如果想看历年 csp 总结，可看我专栏。

首先，按套路我们看实力最大的蛇什么时候能吃，若是吃了之后不是最小实力的蛇，那就可以吃。

为什么呢，想一想。

发现最大的蛇吃了后最小的蛇一定比刚刚的蛇实力更大，而实力最大的蛇又没有刚才最大的蛇那么大的实力。所以再吃一次产生的新蛇绝对没有这一次的新蛇实力强，所以会挡在当前蛇之前，又再吃的蛇很聪明不会被吃，那么当前蛇更不会被吃。

若是最小的蛇，那该如何。

此时有两种情况。一种是能吃，吃了后不会被吃。第二种是不能吃，吃了后会被吃。首先显然，若是吃，那也是最后一次了，因为最大的蛇很聪明不会被吃。我们现在任务就是判断此时最大的蛇能不能吃。

先让他吃，然后递归判断，若是当前的蛇吃了最小蛇后的情况最大蛇可吃最小蛇，那么可以，否则不可以，所以我们可以不断递归下去求解。边界就是只有两个蛇，或最大蛇吃了后不是最小蛇就行了。

以上就是大致思路，考虑怎么维护。

我们要查询最小值，次小值，最大值，插入最大值减最小值，删除最大值与最小值。

发现每次操作的最大值减最小值单调不增，考虑用双端队列维护，开两个，分别存原数与插入的数，插入就在队头插，可保证队列单调递增，其他的便很好维护了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
struct node{
    deque<pair<int,int> > q[2];
    void insert(int id,pair<int,int> w){
        q[id].push_back(w);
    }
    pair<int,int> at(pair<int,int> id){
        return q[id.first][id.second];
    }
    pair<int,int> Max(){
        if(q[0].size()==0){
            return make_pair(1,q[1].size()-1);
        }
        if(q[1].size()==0){
            return make_pair(0,q[0].size()-1);
        }
        if(q[0].back()>q[1].back()){
            return make_pair(0,q[0].size()-1);
        }
        return make_pair(1,q[1].size()-1);
    }
    pair<int,int> Min(){
        pair<int,int> Min=make_pair(1e17,0),ans=make_pair(0,0);
        int l=q[0].size();
        for(int i=0;i<=min(l-1,0ll);i++){
            if(Min>q[0][i]){
                Min=q[0][i];
                ans=make_pair(0,i);
            }
        }
        l=q[1].size();
        for(int i=0;i<=min(l-1,0ll);i++){
            if(Min>q[1][i]){
                Min=q[1][i];
                ans=make_pair(1,i);
            }
        }
        return ans;
    }
    pair<int,int> ciMin(){
        pair<int,int> Min=make_pair(1e17,0),Minn=make_pair(1e17,0),ans=make_pair(0,0),anss=make_pair(0,0);
        int l=q[0].size();
        for(int i=0;i<=min(l-1,1ll);i++){
            if(Min>q[0][i]){
                Minn=Min;
                anss=ans;
                Min=q[0][i];
                ans=make_pair(0,i);
            }else if(Minn>q[0][i]){
                Minn=q[0][i];
                anss=make_pair(0,i);
            }
        }
        l=q[1].size();
        for(int i=0;i<=min(l-1,1ll);i++){
            if(Min>q[1][i]){
                Minn=Min;
                anss=ans;
                Min=q[1][i];
                ans=make_pair(1,i);
            }else if(Minn>q[1][i]){
                Minn=q[1][i];
                anss=make_pair(1,i);
            }
        }
        return anss;
    }
    void Erase_Min(){
        pair<int,int> id=Min();
        q[id.first].pop_front();
    }
    void Erase_Max(){
        pair<int,int> id=Max();
        q[id.first].pop_back();
    }
}Ta;
int n,a[1919810];
pair<int,int> jian(pair<int,int> ja,pair<int ,int> jb){
    return make_pair(ja.first-jb.first,ja.second);
}
int check(){
    if(Ta.q[0].size()+Ta.q[1].size()==2){
        return 1;
    }
    pair<int,int> id=Ta.Max(),idd=Ta.Min(),ida=Ta.ciMin();
        pair<int,int> Ans=jian(Ta.at(id),Ta.at(idd));
        if(Ans>=Ta.at(ida)){
            return 1;
        }else{
            Ta.Erase_Max();
            Ta.Erase_Min();
            Ta.q[1].push_front(Ans);
        }
    return !check();
}
int solve(){
    Ta.q[0].clear();
    Ta.q[1].clear();
    for(int i=1;i<=n;i++){
        Ta.q[0].push_back(make_pair(a[i],i));
    }
    int ans=0;
    while(1){
        if(Ta.q[0].size()+Ta.q[1].size()==1){
            break;
        }
        if(Ta.q[0].size()+Ta.q[1].size()==2){
            ans++;
            break;
        }
        pair<int,int> id=Ta.Max(),idd=Ta.Min(),ida=Ta.ciMin();
        pair<int,int> Ans=jian(Ta.at(id),Ta.at(idd));
        if(Ans>=Ta.at(ida)){
            Ta.Erase_Max();
            Ta.Erase_Min();
            Ta.q[1].push_front(Ans);
            ans++;
        }else{
            if(check()){
                ans++;
            }
            break;
        }
    }
    return n-ans;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin>>T;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cout<<solve()<<'\n';
    T--;
    while(T--){
        int k;
        cin>>k;
        for(int i=1;i<=k;i++){
            int x,y;
            cin>>x>>y;
            a[x]=y;
        }
        cout<<solve()<<'\n';
    }
    return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：4)

首先，每一轮在吃和被吃的蛇都是某个钦定序列的前缀。假设我们处理出来这个长度为 $n-1$ 的序列，怎么做？

考虑虚拟的第 $n-1$ 轮。假设前面轮的蛇都不考虑，直接选吃；现在只剩下两只蛇了。这一轮在吃的蛇肯定会选吃。  
怎么推广这样的逻辑？在第 $i$ 轮，如果到了这一轮的话，在吃的蛇会选择吃当且仅当吃了不会导致它在后面的轮被吃。  
可以对每一轮计算在吃的蛇会选择吃还是弃权。对第 $i$ 轮在吃的蛇，如果从第 $i+1$ 轮到下一个弃权轮之前存在一轮被吃的蛇是当前在吃的蛇，在吃的蛇必定选弃权（不能被吃），否则必定选吃（不能少吃）。  
对这个部分维护一个 0/1 数组即可；位置 $i$ 等于第 $i$ 蛇是否从这个轮到下一个弃权轮当过被吃的蛇。整体 $O(n)$。

接下来就需要构造这个在吃和被吃的序列了。这里需要支持找到最小，删除最小，找到最大，删除最大，插入的数据结构。可以 set 搞，但是这是 $O(Tn\log n)$，会被卡到 85 分。

真 的 嘛 ？

开始卡常。

 - 初始需要 pair 维护，第一个元素是蛇的权值，第二个元素是蛇的编号。这样比较常数较大，绑成一个 long long 放入 set。
 - set 保存下来 begin 和 end 的指针按照这些删除，减少寻找常数。
 - 用两个 priority queue 来替代 set。第一个优先队列是最小优先；第二个是最大优先。由于 priority_queue 不支持删除任意元素，给所有插入的元素一个标号。当想删除一个元素，把这个标号在某个数组里统计为”被删除“。找最小值或者最大值的时候，只要堆顶被删除了就一直继续 pop。
 - 捆绑用 1<<20 捆绑。
 - 多次提（x（w）i（x）n（q））交（y（ak）a（i）n（o）g（i））


代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair
 
using ll=long long;
using pii=pair<int, int>;
//#define int ll
const int MOD = 1000000007;

int ar[1000006];
int eater[1000006], eaten[1000006];
bool willeaten[1000006];
bool delted[2000006];
pair<ll,int> tmp[1000006];
int solve(int n) {
	rep1(i, n) tmp[i] = {(((ll)ar[i])<<20)|i, i};
	priority_queue<pair<ll,int>, vector<pair<ll,int>>, less<>> mx(tmp+1, tmp+n+1);
	priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<>> mi(tmp+1, tmp+n+1);
	int cur = n+1;
	memset(delted, 0, sizeof delted);
	rep(i, n-1) {
		while(delted[mx.top().se]) mx.pop();
		while(delted[mi.top().se]) mi.pop();
		ll b = mx.top().fi, a = mi.top().fi;
		eater[i] = b&1048575; eaten[i] = a&1048575;
		pair<ll,int> r = {b-a+eaten[i], cur++};
		delted[mx.top().se] = delted[mi.top().se] = 1;
		mx.pop(); mi.pop();
		mx.push(r); mi.push(r);
	}
	memset(willeaten, 0, sizeof willeaten);
	int roundend = n-1;
	for(int i=n-2; i>=0; i--) {
		if(willeaten[eater[i]]) {
			iter(j, i+1, roundend) willeaten[eaten[j]] = 0;
			roundend = i;
		} else willeaten[eaten[i]] = 1;
	}
	return n - roundend;
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int t, n; gi(t); gi(n);
	t--;
	rep1(i, n) gi(ar[i]);
	cout << solve(n) << endl;
	while(t--) {
		int k; gi(k);
		rep(i, k) {
			int a, b; gi(a), gi(b);
			ar[a] = b;
		}
		cout << solve(n) << endl;
	}
}
```

---

## 作者：chenhanzheapple (赞：3)

# 前言

人生中第一道黑题，不得写个题解纪念一下（（（

# 思路

注意到，若最强的蛇吃最弱的蛇吃完之后没有变成最弱的蛇，那他一定会吃。

为什么呢？因为若最强的蛇吃完之后不是最弱的蛇，那么吃完后的最强的蛇吃吃完后的最弱的蛇之后，一定没有最初最强的蛇强。

那如果吃完之后成为最弱的蛇呢，那么就需要看新的最强的蛇会不会吃掉它，而新的最强的蛇也要考虑这一点……这样下去就是一个递归问题了。不断递归求解即可。

如何实现呢？最初想到的是用 set 维护，但是会超时。注意到蛇吃了另一条蛇后，最强的蛇的体力值会单调不增，最弱的蛇的体力值会单调不减，因此可以使用双端队列维护。

然后这题就做完了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[10000005];
struct node{
    int x,y;
    bool operator < (const node b) const{
        if(x==b.x){
            return y<b.y;
        }
        return x<b.x;
    }
    bool operator > (const node b) const{
        if(x==b.x){
            return y>b.y;
        }
        return x>b.x;
    }
};
void work(){
    int ans = 0;
    deque<node> que[3];
    for(int i=1;i<=n;i++){
        que[1].push_back((node){a[i],i});
    }
    while(1){
        if(que[1].size()+que[2].size()==2){
            ans = 1;
            break;
        }
        int p = !(que[2].empty() || (!que[1].empty() && que[1].back()>que[2].back()));
        p++;
        node x = que[p].back(),y = que[1].front();
        que[1].pop_front();
        que[p].pop_back();
        node t = (node){x.x-y.x,x.y};
        if(que[1].empty() || que[1].front()>t){
            ans = que[1].size()+que[2].size()+2;
            int cnt = 0;
            while(1){
                //cout << que[1].size() << " " << que[2].size() << endl;
                cnt++;
                if(que[1].size()+que[2].size()==1){
                    if(!(cnt%2)){
                        ans--;
                    }
                    break;
                }
                int p = !(que[2].empty() || (!que[1].empty() && que[1].back()>que[2].back()));
                p++;
                x = que[p].back();
                que[p].pop_back();
                t = (node){x.x-t.x,x.y};
                if(!((que[1].empty() || t<que[1].front()) && (que[2].empty() || t<que[2].front()))){
                    if(!(cnt%2)){
                        ans--;
                    }
                    break;
                }
            }
            break;
        }
        else{
            que[2].push_front(t);
        }
    }
    cout << ans << endl;
}
int main(){
    int t;
    cin >> t >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    work();
    t--;
    while(t--){
        int k;
        cin >> k;
        for(int i=1;i<=k;i++){
            int x,y;
            cin >> x >> y;
            a[x] = y;
        }
        work();
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

说起来，这是我做的第一道黑题，现在一看，回忆满满啊（现在也只做出来两道，我真是蒟蒻）。那么，就让我以此作为 2025 蛇年的第一篇题解吧。

### 思路

最强的蛇，假设叫小 Y，此时它要吃最弱的蛇：
1. 小 Y 吃完最强
1. 小 Y 吃完不是最弱（也不是最强）
2. 小 Y 吃完最弱

第一种情况肯定吃了,反正吃了也不会被吃。

我们考虑第二种情况：
假设小 Y 吃完蛇后最强的蛇是小 L，此时小 L 没有之前的小Y强，最弱的蛇也没有小 Y 吃的那条蛇弱。如果小Y被吃，也一定在小 L 后面。但是小 L 也是有脑子的，它不想被吃，所以可以间接确保小 Y 不被吃。

第三种情况中，小 Y 吃完蛇后会不会被吃，取决于小 Y 吃蛇后最强的蛇（还假设为小 L）吃不吃，小 L 如果吃后不是最弱，就会吃小 Y，小 Y 就不会吃蛇。如果小 L 吃后最弱，就又要看小 L 吃后最强的蛇吃不吃……

于是最后，一定有一条蛇，要么吃后不是最弱，要么吃完只剩它自己，于是它会吃，那么上一条不会吃，上上条会吃……直到小Y选择吃不吃，判断奇偶性就可以。

好了，暴力吧。因为最后只会递归一次，要么小 Y 不吃，要么小 L 不吃，小 Y 吃。

**警钟敲烂：一定不要用堆，用两个队列维护，否则会有 TLE 大礼包**

具体实现方法：两个队列，第一个记录最开始的蛇，另一个记录吃后的蛇（因为小 Y$>$ 小 L，小 Y 吃的蛇 $<$ 小 L 吃的蛇，所以吃后小 Y$>$ 吃后小 L）。

复杂度 $O(TN)$

### 参考代码


```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define x first
#define y second
#define mk(a,b) make_pair(a,b)
#define int long long
using namespace std;
int t,n,a[1000010],s;
pii c;
deque<pii> q1,q2;
pii ch1(){
	pii k;
	if(q1.size()==0) k=q2.back(),q2.pop_back();
	else if(q2.size()==0) k=q1.back(),q1.pop_back();
	else if(q1.back()>q2.back()) k=q1.back(),q1.pop_back();
	else k=q2.back(),q2.pop_back();
	return k;
}
pii ch2(){
	pii k;
	if(q1.size()==0) k=q2.front(),q2.pop_front();
	else if(q2.size()==0) k=q1.front(),q1.pop_front();
	else if(q1.front()<q2.front()) k=q1.front(),q1.pop_front();
	else k=q2.front(),q2.pop_front();
	return k;
}
pii so2(){
	pii k;
	if(q1.size()==0) k=q2.front();
	else if(q2.size()==0) k=q1.front();
	else if(q1.front()<q2.front()) k=q1.front();
	else k=q2.front();
	return k;
}
pii operator -(pii a,pii b){
	return mk(a.x-b.x,a.y);
}
int ch(){
	if(q1.size()+q2.size()==2){
		c=ch1()-ch2();
		return 1;
	}
	c=(ch1()-ch2());
	return (c)>=so2();
}
int dfs(){
	if(q1.size()+q2.size()<2) return 0;
	if(ch()) return 1;
	q2.push_front(c);
	return 1-dfs();
}
void so(){
	s=0;
	while(q1.size()>0) q1.pop_back();
	while(q2.size()>0) q2.pop_back();
	for(int i=1;i<=n;i++) q1.push_back(mk(a[i],i));
	while(q1.size()+q2.size()>=2&&ch()){
		s++;
		q2.push_front(c);
	}
	q2.push_front(c);
	s+=1-dfs();
	cout<<n-s<<endl;
	return;
}
signed main(){
	int t;
	cin>>t;
	for(int op=1;op<=t;op++){
		if(op==1){
			cin>>n;
			for(int i=1;i<=n;i++) cin>>a[i];
		}else{
			int k;
			cin>>k;
			while(k--){
				int x,y;
				cin>>x>>y;
				a[x]=y;
			}
		}
		so();
	}
	return 0;
}
```

---

## 作者：Hagasei (赞：3)

这道题无论是思维还是实现上都有一定的难度。

# 思维

首先，明确一个概念：**只要决斗后强蛇不会沦为最弱的蛇，它就一定会吃。** 证明如下：

- 最强蛇决斗后一定比次强蛇决斗后强。
- $a_1>a_2>a_3>a_4\rightarrow a_1-a_4>a_2-a_3$
- 次强蛇决斗后一定吃不了最强蛇。

- 更弱蛇同理。

证毕。

其次，如果决斗后最强蛇会沦为最弱蛇，则需要看决斗后的新的最强蛇能否吃掉它。

而若新的最强蛇决斗后也会沦为最弱蛇，则继续向下，直到有蛇能吃为止。

通过奇偶性可得，若判断的层数为奇数，则原最强蛇不能决斗，否则可以。
# 实现
输入处理后，主循环用于模拟决斗。用一个变量 `r` 存储 *局数* ，变量 `question` 存储蛇的 *提问* 在哪局 （即蛇处于决斗后会沦为最弱蛇的状态，需要 *向下判断*）， `tot` 存死蛇数。

取出最大、最小后：

+ 若能吃（不会沦为最弱**或**只剩两只），则**先**判断提问，若 `r - question` 为偶数，则需 `++tot` 再退出，否则直接退出。（上文已解释）。然后再进行决斗的 `++tot` 。（其实，这里我一开始想递归判断的，但我发现判断能吃和如此相似，便有了如此奇怪的*模拟递归*）

 **注意：当两条蛇体力相同时，它们是不会决斗的，所以上文奇偶性在满足该条件时需调换，即奇数才** `++tot` 。

+ 否则，只要 `question` 不为初值，就 `question = r` ，**并把决斗后的蛇放回**。

为了能快速取出最大值，我们需要一个 *神奇的数据结构* 维护幸存的最强、最弱蛇。于是我们第一时间想到了 `set` 。

$\text{Time Limit Error 70}$

咳咳，可以发现，刚开始原数组是排序好的，而用 `set` 是 $O(Tn\log n)$ ，这不由得让我们思考 $O(Tn)$ ，用线性储存。

观察决斗后的蛇，体力值一定会比前一个决斗的低。于是，我们可以把决斗后的蛇用 `deque` 存起来，决斗完的蛇放在队首，最小值自然也在队首取；将原数组存入另一个 `deque` 。这样最大值就是两个队列队头的最大值，最小值同理。

完毕，上代码。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define P pair<int, int>
/***↓快读快写好习惯下***/
#define wr(x) write(x, false)
void write(int ans, bool bk) {
    if (ans < 0)
        putchar('-'), ans = -ans;
    if (ans == 0) {
        if (!bk)
            putchar('0');
        return;
    }
    write(ans / 10, true);
    putchar(ans % 10 ^ '0');
}
void qr(int &ret) {
    int x = 0, f = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') f |= ch == '-', ch = getchar();
    while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
    ret = f ? -x : x;
}
/***↑快读快写好习惯↑***/
P operator-(P a, P b) {  //决斗
    return P(a.first - b.first, a.second);
}
int a[1000005];
deque<P> p, q;  // p:原数组，q：决斗后。
int n;
P fmax() {  //取出并删除最大值
    P ret;
    if (p.empty()) {
        ret = q.back();
        q.pop_back();
    } else if (q.empty()) {
        ret = p.back();
        p.pop_back();
    } else if (p.back() > q.back()) {
        ret = p.back();
        p.pop_back();
    } else {
        ret = q.back();
        q.pop_back();
    }
    return ret;
}
P fmin() {  //取出并删除最小值
    P ret;
    if (p.empty()) {
        ret = q.front();
        q.pop_front();
    } else if (q.empty()) {
        ret = p.front();
        p.pop_front();
    } else if (p.front() < q.front()) {
        ret = p.front();
        p.pop_front();
    } else {
        ret = q.front();
        q.pop_front();
    }
    return ret;
}
P ndmin() {  //只取出不删除最小值
    if (p.empty() && q.empty())
        return P(0, 0);//防RE 
    if (p.empty())
        return q.front();
    else if (q.empty())
        return p.front();
    else if (p.front() < q.front())
        return p.front();
    else
        return q.front();
}
void solve() {
    p.clear(), q.clear();
    for (int i = 1; i <= n; ++i) {
        p.push_back(P(a[i], i));
    }
    P MAX, MIN, nextmin;
    int question = 0, r = 0, tot = 0;
    while (1) {  //主循环
        ++r;
        if (p.size() + q.size() == 1)
            break;
        MAX = fmax(), MIN = fmin();
        nextmin = ndmin();
        if (MAX - MIN >= nextmin || p.empty() && q.empty()) {  //能决斗
            bool cannot = (MAX - MIN).first == 0;//特判
            q.push_front(MAX - MIN);
            if (question) {
                if (r - question & 1) {
                    if (cannot)
                        ++tot;
                    break;
                } else {
                    if (!cannot)
                        ++tot;
                    break;
                }
            }
            ++tot;
        } else {
            q.push_front(MAX - MIN);
            if (!question)
                question = r;
        }
    }
    wr(n-tot);
    putchar('\n');
}
int main() {
    int T;
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        if (t == 1) {
            qr(n);
            for (int i = 1; i <= n; ++i) qr(a[i]);
        } else {
            int k;
            qr(k);
            for (int i = 1; i <= k; ++i) {
                int x, y;
                qr(x), qr(y);
                a[x] = y;
            }
        }
        solve();
    }
}
```

---

## 作者：Takato_ (赞：1)

## [贪吃蛇](https://www.luogu.com.cn/problem/P7078)

第二道水黑。

#### 思路：

部分分不予陈述，直接说正解。

如果最强的一条蛇在吃掉最弱的一条蛇之后，没有变成最弱的蛇，那么最强蛇一定会吃。

否则，它会有这么一个思考：如果它吃了后变成最弱蛇，就要考虑次强蛇会不会吃掉它，而如果此时次强蛇吃了它后不会变成最弱蛇，次强蛇就会吃了它，所以最强蛇不会吃，否则次强蛇就要考虑它变成最弱蛇后次次强蛇会不会吃它...就是这样，很简单的递归，一直到吃完或者某一条蛇吃完之后不会成为最小蛇为止。

然后就会发现一个事情（以下讨论均已最大蛇吃掉最小蛇一定会变成最小蛇为背景）：当只有两条蛇时，最大蛇一定会吃；当有三条蛇时，如果最强蛇选择吃，那么此时对于次强蛇，就会变成两条蛇的情况，次强蛇一定吃，那么最强蛇一定不吃；当有四条蛇时，如果最强蛇吃，那么对于次强蛇，就会变成三条蛇的情况，次强蛇一定不会吃掉变成最弱蛇的最强蛇，所以最强蛇就可以吃；以此推类，当蛇有偶数条时，最强蛇会吃；否则不会。

然后就可以写循环了，其他纯模拟。

还是不会的话，具体方法：

用两个双端队列，一个 $q1$ 存储原先的实力，另一个 $q2$ 存储最强蛇吃完了之后的实力。每次循环可以直接从 $q1$ 取出最小值，因为原先最强蛇吃完之后一定不是最弱蛇，所以 $q2$ 里的数恒比 $q1$ 大。但最大值就需要从 $q1$ 和 $q2$ 中取最大值：最强蛇可能吃完后不是最强蛇，也可能是。然后每次判断能不能吃，如果能吃，就直接吃并把结果存入 $q2$，否则就再写一个循环判断上述递归过程，不断取出当前最强蛇，直到吃完或者某一条蛇吃完之后不会成为最小蛇为止。然后判断奇偶。最后输出答案。

**代码满天飞，就不给了。**

---

## 作者：Ptll (赞：1)

[题目](https://www.luogu.com.cn/problem/P7078)

# 思考

首先这题会先给一个不降序的数组 $a$ 即：

$$
a_{1} \le a_{2} \le \dots \le a_{n-1} \le a_{n}
$$

第 $k$ 轮，最大的蛇会考虑吃不吃最小的蛇。

因为这是一个不降序的数组，所以可以保证：

$$
a_{x}-a_{1} \ge a_{x-1}-a_{2} \ge  \dots \ge a_{x \div 2+1}-a_{x \div 2}
$$

所以只要保证最大的蛇吃掉最小的蛇后不会被此时最大的蛇吃即可。

这可以分为两种情况：

- 吃完之后我不是最小蛇。

- 吃完之后我是最小蛇。

## 第一种情况

很容易证明，在第一种情况下最大蛇一定会吃最小蛇。因为根据上面的不等式：

$$
a_{x}-a_{1} \ge a_{x-1}-a_{2} \ge  \dots \ge a_{x \div 2+1}-a_{x \div 2}
$$

可以知道，如果我吃了最小蛇不是最小蛇，那么第二大的蛇吃掉当前的最小蛇一定会比我小，所以我一定不会被吃，所以我一定会吃掉最小蛇。

## 第二种情况

我们来讨论第二种情况，此时我应不应该吃最小蛇呢？

我们考虑只有两条蛇的情况，这时我一定会吃掉最小蛇。

接着是三条蛇，如果我很傻，吃掉了最小蛇成了最小蛇，那么第二大的蛇就会吃掉我，所以，我会为了保命，不吃掉最小蛇。

以此类推，我们不难发现在我们重复进行第二种情况时，会陷入一个递归循环。

我们可以看到，这个递归的边界就是在某一条蛇吃了之后不是最弱的蛇或者只剩下两条蛇。

根据枚举不难发现，这与递归次数的奇偶性有关，如果次数是奇数，则他不能吃，反之则能。

# 算法

又是最值，又是弹出，过程中又会考虑排序，这不难想到 `set`。

但当你自信满满地交上去时，会得到一个感人的 **TLE**。

[提交记录](https://www.luogu.com.cn/record/218816587)

那么正解是什么呢？

~~我们打开标签，会看到**队列**~~，这提示我们可以往队列想想。

这个队列要满足可以左右或前后更改，这不是双端队列吗。

但我们没法满足吃掉蛇后的值一定满足单调性，这又怎么办？

我们回顾到这个式子：

$$
a_{x}-a_{1} \ge a_{x-1}-a_{2} \ge  \dots \ge a_{x \div 2+1}-a_{x \div 2}
$$

我们发现，先吃东西的蛇剩下的实力一定比后吃的大。

这又启发我们可以使用两个双端队列，$q$ 记录原本输入的值，$dq$ 记录删改后的值。

这可以保证队列中的值满足单调不下降，我们就可以用队列来实现。

## 第一种情况

因为我们前面保证了：在第一种情况下，最强的蛇吃完最弱蛇后一定不是最弱蛇，所以 $dq$ 里面的蛇一定都不会比 $q$ 中的最弱蛇弱，所以 $q$ 中的最弱蛇就是整个的最弱蛇。

所以只需从 $q$ 的尾部拿出最弱的蛇，从 $dq$ 或 $q$ 中取出最强的蛇。

如果最强蛇吃掉最弱蛇后变成了最弱蛇，那么将进入第二种情况，否则一直执行，直到进入第二种情况或只剩两条蛇。

## 第二种情况

此时最弱的蛇，就没必要丢进队列里了，单独算一下就好了，因为连续的一段进食后都是最弱的，直到只剩两条蛇或者进食后不是最弱的即可退出。

# Code

```cpp
#include <bits/stdc++.h>
#define ll long long
#define praise_long_long int
#define pll pair<ll,ll>
namespace io {
	using namespace std;
	inline ll read() {
		char n=getchar();
		ll num=0,flag=1;
		while(n<'0'||n>'9') {
			if(n=='-') {
				flag=-1;
			}
			n=getchar();
		}
		while(n>='0'&&n<='9') {
			num=num*10+n-'0';
			n=getchar();
		}
		return num*flag;
	}
	inline void print(ll x) {
		if(x<0) {
			putchar('-');
			print(-x);
			return;
		}
		if(x==0) {
			return;
		}
		print(x/10);
		putchar((char)(x%10+'0'));
	}
}
using namespace io;
const ll N=1e6+5;
ll T,n,a[N];
deque<pll> q,dq;
void ck(pll& it) {
	ll fi,se;
	if(dq.empty()||!q.empty()&&q.back()>dq.back()) {
		fi=q.back().first,se=q.back().second;
		q.pop_back();
	}
	else {
		fi=dq.back().first,se=dq.back().second;
		dq.pop_back();
	}
	it={fi-it.first,se};
}
void solve() {
	while(!q.empty()) {
		q.pop_front();
	}
	while(!dq.empty()) {
		dq.pop_front();
	}
	for(ll i=1;i<=n;i++) {
		q.push_back({a[i],i});
	}
	ll ans=0;
	while(true) {
		if(q.size()+dq.size()==2) {
			ans=1;
			break;
		}
		ll sfi=q.front().first,fi,se;
		q.pop_front();
		if(dq.empty()||!q.empty()&&q.back()>dq.back()) {
			fi=q.back().first,se=q.back().second;
			q.pop_back();
		}
		else {
			fi=dq.back().first,se=dq.back().second;
			dq.pop_back();
		}
		pll it=make_pair(fi-sfi,se);
		if(!q.empty()&&q.front()<=it) {
			dq.push_front(it);
			continue;
		}
		ans=dq.size()+q.size()+2;
		ll cnt=0;
		while(true) {
			cnt++;
			if(q.size()+dq.size()==1) {
				if(cnt%2==0) {
					ans--;
				}
				break;
			}
			ck(it);
			if((q.empty()||it<q.front())&&(dq.empty()||it<dq.front())) {
				continue;
			}
			if(cnt%2==0) {
				ans--;
			}
			break;
		}
		break;
	}
	print(ans);
	putchar('\n');
}
praise_long_long main() {
    cin>>T;
    T--;
    n=read();
    for(ll i=1;i<=n;i++) {
        a[i]=read();
    }
    solve();
    while(T--) {
        ll m=read();
        for(ll i=1;i<=m;i++) {
            ll op=read(),x=read();
            a[op]=x;
        }
        solve();
    }
	return 0;
}
```

---

## 作者：hongshixiaobai (赞：1)

# P7078 [CSP-S2020] 贪吃蛇 题解
[传送门](https://www.luogu.com.cn/problem/P7078)
## 思路
首先显而易见当前最强蛇如果吃完最弱蛇之后不会变成最弱的那就一定会吃，感性理解一下：此时他下一轮一定不会被吃，而下一轮次强蛇吃掉次弱蛇之后一定不会强于初始最强蛇吃完后，以此类推，所以在他下一次成为最强蛇前不会被吃。

而如果最强蛇吃完之后会变成最弱蛇，那么考虑分类讨论：

假设每只蛇都无脑选择吃掉最弱蛇。

如果一直到结束（即只剩一条蛇）最强蛇吃完之后都会变成最弱蛇：

那么在倒数第二次时当时的最强蛇会选择不吃，因为如果他吃了最弱蛇那么他就会被吃。

则倒数第三次时那条蛇一定会吃，因为他知道倒数第二次最强蛇一定不会吃。

以此类推，可得如果剩下的蛇是偶数只，那么一定会吃，否则一定不会。

第二种情况：如果中途有一只蛇吃完后不是最弱的：

其实和上一种情况差不多，吃完后不是最弱的那只蛇一定会吃，则上一次一定不会吃，以此类推即可。

实现的时候维护一下单调性就好了。

提供一组可能有用的 hack 数据：
```
1
20
1 1 2 3 3 4 6 7 7 8 9 9 12 12 12 14 14 16 17 17
```
出错说明你在第一次最强蛇吃完之后会变成最弱蛇的时候处理出错了。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a[1000006],k,x,y,lq1,lq2,i,p,ans,cnt,minn;
struct _{long long v,id;}tmp;
bool operator >(_ x,_ y){if(x.v==y.v)return x.id>y.id;return x.v>y.v;}
bool operator <(_ x,_ y){if(x.v==y.v)return x.id<y.id;return x.v<y.v;}
bool operator >=(_ x,_ y){if(x.v==y.v)return x.id>=y.id;return x.v>=y.v;}
_ operator -(_ x,_ y){return _{x.v-y.v,x.id};}
deque<_>q1,q2,q3;
int main()
{
	cin>>t>>n;
	for(i = 1;i<=n;i++)cin>>a[i],q1.push_back({a[i],i});
	tmp = q1.front();
	q1.pop_front();
	if(q1.back()-tmp>=q1.front())
	{
		q2.push_front(q1.back()-tmp);
		q1.pop_back();
		while(q1.size())
		{
			tmp = q1.front();
			q1.pop_front();
			if(max(q1.back(),q2.back())-tmp<q1.front()){q1.push_front(tmp);break;}
			if(q1.back()>q2.back())q2.push_front(q1.back()-tmp),q1.pop_back();
			else q2.push_front(q2.back()-tmp),q2.pop_back();
		}
		ans = q1.size()+q2.size();
		for(i = 1;i<=ans;i++)
		{
			if(!q1.size())
			{
				q3.push_back(q2.front());
				q2.pop_front();
				continue;
			}
			if(!q2.size())
			{
				q3.push_back(q1.front());
				q1.pop_front();
				continue;
			}
			if(q1.front()<q2.front())
			{
				q3.push_back(q1.front());
				q1.pop_front();
			}
			else
			{
				q3.push_back(q2.front());
				q2.pop_front();
			}
		}
		while(q3.size())
		{
			tmp = q3.front();
			q3.pop_front();
			if(q3.back()-tmp>=q3.front())break;
			q3.push_front(q3.back()-tmp),q3.pop_back();
			cnt++;
		}
		if(cnt!=0)
		{
			ans-=cnt;
			if(!(cnt&1))cnt--;
		}
		else if(!(ans&1))cnt--;
		cout<<ans+cnt<<'\n';
	}
	else
	{
		q1.push_front(tmp);
		ans = q1.size()+q2.size();
		while(q1.size())
		{
			tmp = q1.front();
			q1.pop_front();
			if(q2.empty())
			{
				if(q1.back()-tmp>=q1.front())break;
				q1.push_front(q1.back()-tmp),q1.pop_back();
			}
			else
			{
				if(max(q1.back(),q2.back())-tmp>=q1.front()){q1.push_front(tmp);break;}
				if(q1.back()>q2.back())q1.push_front(q1.back()-tmp),q1.pop_back();
				else q1.push_front(q2.back()-tmp),q2.pop_back();
			}
			cnt++;
		}
		if(cnt!=0)
		{
			ans-=cnt;
			if(!(cnt&1))cnt--;
		}
		else if(!(ans&1))cnt--;
		cout<<ans+cnt<<'\n';
	}
	t--;
	while(t--)
	{
		while(q1.size())q1.pop_back();
		while(q2.size())q2.pop_back();
		while(q3.size())q3.pop_back();
		cnt = 0;ans = 0;
		cin>>k;
		for(i = 1;i<=k;i++)cin>>x>>y,a[x] = y;
		for(i = 1;i<=n;i++)q1.push_back({a[i],i});
		tmp = q1.front();
		q1.pop_front();
		if(q1.back()-tmp>=q1.front())
		{
			q2.push_front(q1.back()-tmp);
			q1.pop_back();
			while(q1.size())
			{
				tmp = q1.front();
				q1.pop_front();
				if(max(q1.back(),q2.back())-tmp<q1.front()){q1.push_front(tmp);break;}
				if(q1.back()>q2.back())q2.push_front(q1.back()-tmp),q1.pop_back();
				else q2.push_front(q2.back()-tmp),q2.pop_back();
			}
			ans = q1.size()+q2.size();
			for(i = 1;i<=ans;i++)
			{
				if(!q1.size())
				{
					q3.push_back(q2.front());
					q2.pop_front();
					continue;
				}
				if(!q2.size())
				{
					q3.push_back(q1.front());
					q1.pop_front();
					continue;
				}
				if(q1.front()<q2.front())
				{
					q3.push_back(q1.front());
					q1.pop_front();
				}
				else
				{
					q3.push_back(q2.front());
					q2.pop_front();
				}
			}
			while(q3.size())
			{
				tmp = q3.front();
				q3.pop_front();
				if(q3.back()-tmp>=q3.front())break;
				q3.push_front(q3.back()-tmp),q3.pop_back();
				cnt++;
			}
			if(cnt!=0)
			{
				ans-=cnt;
				if(!(cnt&1))cnt--;
			}
			else if(!(ans&1))cnt--;
			cout<<ans+cnt<<'\n';
		}
		else
		{
			q1.push_front(tmp);
			ans = q1.size()+q2.size();
			while(q1.size())
			{
				tmp = q1.front();
				q1.pop_front();
				if(q2.empty())
				{
					if(q1.back()-tmp>=q1.front())break;
					q1.push_front(q1.back()-tmp),q1.pop_back();
				}
				else
				{
					if(max(q1.back(),q2.back())-tmp>=q1.front())break;
					if(q1.back()>q2.back())q1.push_front(q1.back()-tmp),q1.pop_back();
					else q1.push_front(q2.back()-tmp),q2.pop_back();
				}
				cnt++;
			}
			if(cnt!=0)
			{
				ans-=cnt;
				if(!(cnt&1))cnt--;
			}
			else if(!(ans&1))cnt--;
			cout<<ans+cnt<<'\n';
		}
	}
}
```

---

## 作者：Justin0779 (赞：1)

前言：一个退役 OIer 曾经做了2年的题。

# Solution

首先得读懂题。

仔细阅读之后，我们基本可以得到几个条件：

**Lemma 1** 当此时最大的蛇吃完后成为最小蛇，则设当前蛇数量为 $k$，答案为 $k^{'}$，有 $\vert k-k^{'}\vert \le 1$。

**Proof** 如果当前最大蛇吃了之后不会被吃，那么游戏直接结束，有 $k^{'} = k - 1$；否则它不会吃，有 $k^{'} = k$。

**Lemma 2** 当最大蛇吃了后没有变成最小蛇，最大蛇一定会吃。

**Proof** 最大蛇吃后不会立即被吃，接下来次大蛇会去吃更小的蛇，显然次大蛇吃完后变的比该最大蛇更小，且显然如果次大蛇没有被吃，那么最大蛇一定不会被吃，所以在次大蛇一定会保证自己存活的前提下，最大蛇一定不会被吃，根据最优策略，最大蛇一定会吃。

有了两个基本的结论，我们尝试解决这道题。

根据 Lemma 2，在最大蛇吃后没有成为最小蛇时，最大蛇一定选择吃，手动模拟这个过程即可。

但是当最大蛇成为最小蛇时，我们又该如何判断是否该吃。

感性理解一个情况：设最大蛇的队列为 $A，B，C \dots$，最小蛇的队列 $Z，Y，X \dots$，那么此时对于 $A$ 吃 $Z$ 有以下几个条件：

1. $B$ 不吃 $A^{'} = A - Z$
2. $C$ 吃 $B^{'} = B - A^{'}$
3. $D$ 不吃 $C^{'} = C - B^{'}$

$\vdots$

容易发现最后 $A$ 吃 $Z$ 与判断结束后吃的蛇的数量的奇偶性有关，最后统一一下并判断即可；结束时，要么是当前最大蛇吃了之后不会变成最小蛇，要么最后只剩 $1$ 条蛇，此时跳出判断即可。

这道题到这里基本就做完了：对于第一部分手动模拟，对于第二部分判断。

最后时间复杂度 $O(Tn)$。

### 实现细节

我们现在需要维护的有：蛇的序列、最大蛇、最小蛇。

传统的方法不好维护最大蛇和最小蛇，插入单个结构应是 $O(n) / O(\log n)$ 的，但我们可以利用单调性，用两个双端队列来存储。

容易发现双端队列一边存没动过的蛇（$s_1$），一边存吃过的蛇（$s_2$），那么很容易保证两个队列内部是单调的。吃掉时，只需要将蛇插入 $s_2$ 中，判断最大蛇和最小蛇从 $s_1$ 和 $s_2$ 的两端取即可，最后如果 $s_2$ 中的最小蛇成了全局最小蛇，由 Lemma 1，此时答案与当前蛇数量相对差不超过 $1$，判断后清空、输出答案即可。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;

deque<int> sk1, sk2;
deque<int> id1, id2; 
int n, a[N], v[N], r, vid[N];

bool check() {
    int ans = 0;
    while (r > 2) {
        if (v[r] - v[1] > v[2] || (v[r] - v[1] == v[2] && vid[r] > vid[2])) return ans & 1;
        v[1] = v[r] - v[1];
        vid[1] = vid[r];
        r--;
        ans++;
    }
    if (r == 1) ans += 1;
    if (r == 2) ans += 2;
    return ans & 1;
}

int solve() {
    while (sk1.size()) sk1.pop_front();
    while (sk2.size()) sk2.pop_front();
    while (id1.size()) id1.pop_front();
    while (id2.size()) id2.pop_front();
    for (int i = 2; i < n; i++) sk1.push_front(a[i]);
    for (int i = 2; i < n; i++) id1.push_front(i);
    sk2.push_back(a[n] - a[1]);
    id2.push_back(n);
    r = 0;
    while (sk1.size()) {
        if (sk2.back() < sk1.back()) break;
        if (sk2.back() == sk1.back() && id2.back() < id1.back()) break;
        int mx = sk2.front();
        if (mx < sk1.front() || (mx == sk1.front() && id2.front() < id1.front())) {
            sk2.push_back(sk1.front() - sk1.back());
            id2.push_back(id1.front());
            sk1.pop_back();
            id1.pop_back();
            if (sk1.size()) {
				sk1.pop_front();
				id1.pop_front();
			}
        }
        else {
            sk2.push_back(mx - sk1.back());
            id2.push_back(id2.front());
			sk2.pop_front();
			id2.pop_front();
            sk1.pop_back();
            id1.pop_back();
        }
    }
    int t = sk1.size() + sk2.size();
    while (sk1.size() && sk2.size()) {
        if (sk1.back() < sk2.back() || (sk1.back() == sk2.back() && id1.back() < id2.back())) {
            v[++r] = sk1.back();
            vid[r] = id1.back();
            sk1.pop_back();
            id1.pop_back();
        }
        else {
            v[++r] = sk2.back();
            vid[r] = id2.back();
            sk2.pop_back();
            id2.pop_back();
        }
    }
    while (sk1.size()) {
    	v[++r] = sk1.back();
        vid[r] = id1.back();
        sk1.pop_back();
        id1.pop_back();
	}
    while (sk2.size()) {
    	v[++r] = sk2.back();
        vid[r] = id2.back();
        sk2.pop_back();
        id2.pop_back();
	}

    if (check()) return t;
    else return t + 1;
}

int main() {
	//freopen("1.in", "r", stdin);
	int T;
    scanf("%d", &T);
    T--;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    printf("%d\n", solve());

    while (T--) {
        int k;
        scanf("%d", &k);
        while (k--) {
            int x, y;
            scanf("%d%d", &x, &y);
            a[x] = y;
        }
        printf("%d\n", solve());
    }
	return 0;
}
```

---

## 作者：IGpig (赞：0)

## P7078

### Solution

首先观察一个回合，如果要吃，那一定是最大的吃最小的。
所以一定有一条蛇只要不是最小的就不会被吃。

那么看看多回合，可以发现操作顺序（每回合吃别人的蛇）一定是从大到小的，并且每回合被吃的一定是从小到大的。
那么在知道第 $i$ 轮被吃掉的一定是 $a_i$，那么停止的条件就很明显了，如果一条蛇吃了别人就会变成最小的，那就不能吃了。

所以停下来的条件就是最大的吃了变成最小的。

那么接下来看看怎么模拟：
- 取出数组和队列中最大的。
- 吃掉最小的。
- 如果触发停止条件，就判断最后一步吃不吃。
```cpp
void solve() {
    l = 1, r = n;//原数组中没有用过的
    while (!q.empty()) q.pop();//队列存被吃了的。

    while (l <= r) {
        pair<LL, LL> x = {0, 0};
        if (r > l) x = a[r];
        if (!q.empty()) x = max(x, q.front());//在队列和数组中找到最大的一个
        if(r-l<1) break;
        if (a[r] == x) r--;//在数组中
        else q.pop();//在队列中
        x.first -= a[l].first;//吃。。。好吃
        if (x < a[l + 1]) {//吃掉最小的，比现在最小的还小就退出
            if (!check(x)) l++;//往后看
            break;
        }

        q.push(x);
        l++;
    }

    cout << n - l + 1 << '\n';
}
```

但是我们发现在停止的时候有两种情况，这个最大的蛇到底能不能吃。
这个时候用一个函数判断一下最后一次吃不吃：
- 找到能吃的最小的一个。
- 和上面的步骤一样吃的。
- 看一下操作次数的奇偶。

```cpp
bool check(pair<LL, LL> x) {
    LL cnt = 1;
    pair<LL, LL> last;
    if (l < r) last = a[l + 1];
    if (!q.empty()) last = min(last, q.back());//找到小的那个

    while (true) {
        pair<LL, LL> to = {0, 0};
        if (l < r) to = a[r];
        if (!q.empty()) to = max(to, q.front());

        if (a[r] == to) r--;
        else if (!q.empty()) q.pop();
        to.first -= x.first;
        if (last <= to) break;

        x = to，cnt++;
    }

    return cnt % 2;
}
```

我们发现如果这一次吃了，那么下一次一定不能吃，但是下一次不吃就可以下下次吃（这里可以手动模拟感性了解一下），所以判断一下后面的操作次数，如果是偶数，那么就最后一次的时候可以吃。

代码就不放了，把上面两个拼起来就好了。

---


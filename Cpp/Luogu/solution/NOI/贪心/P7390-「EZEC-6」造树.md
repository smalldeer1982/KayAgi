# 「EZEC-6」造树

## 题目背景

> 成体系的结论会产出“低猜想水平”的机械推导，但更多的题目中需要“高猜想水平”的灵感。

——command_block 《考前小贴士》

[](https://cdn.luogu.com.cn/upload/image_hosting/1m9hce9x.png)无脑选手出思维题。

## 题目描述

你要帮 djy 造一棵树，满足以下条件：

- 由 $n$ 个点组成。

- $i$ 号点的度数为 $a_i$。

定义一条边 $(i,j)$ 的价值为 $b_i\times b_j$，你要在满足上述两个条件下，使所有边的价值和最大。

保证存在这样的树。

## 说明/提示

**本题采用捆绑测试。**

- Subtask0 (10 pts)：$n\le 6$，$type=0$；
- Subtask1 (20 pts)：$n\le 10^3$，$type=0$；
- Subtask2 (10 pts)：$n\le5\times10^5$，$b_i\le2$，$type=0$；
- Subtask3 (20 pts)：$n\le10^5$，$type=0$；
- Subtask4 (20 pts)：$n\le5\times10^5$，$type=0$；
- Subtask5 (20 pts)：$type=1$。

对于 $100\%$ 的数据，$2\le n\le10^7$，$1\le a_i\le n$，$1\le b_i\le5\times10^5$，$type\in\{0,1\}$，$0\le seed<2^{31}$。

## 样例 #1

### 输入

```
0
5
1 2 3 1 1 
5 3 1 7 9```

### 输出

```
42```

## 样例 #2

### 输入

```
1
10
114514```

### 输出

```
249899101316```

# 题解

## 作者：zrzring (赞：22)

[**更好**的阅读体验](http://zrzring.cn/index.php/archives/664/)

考虑贪心，按权值排序，对于枚举到的节点$i$，我们要尽量让这个点和小的点连边，考虑到我们要保证这棵树存在，所以留1的度数用来让这棵树能和剩下的点连起来，于是每次枚举的连通块都需要预留至少1度数和后面的点连边。

我们用一个指针$j$表示$[1, j]$已经变成了一个连通块，那么对于枚举到的$i$就从$j$往后开始连，所以任意时刻我们连出来的一定仅有一个连通块的，根据上面的结论，我们再维护这个连通块的度数使他保持有至少为1的度数即可。

我写题解一般都写的很少的，但这次是验题的工作，所以写一下详细证明。

若当前枚举到的$i$使得$[1, j]$连通块最后仅剩$i$这个点有$1$的度数，且$j + 1$的点度数为1，那么连这个点就会导致无法和后面的点连通，所以要找到后面第一个度数大于1的点$k$相连，然后再处理i到k之间的点直到$k$的度数为1或区间内的点被连完，如果这个区间还有剩下的点就继续寻找下一个$k$，直到$[1, k]$为一个连通块或者已经连到了$n$，由于题目保证树存在，所以连到$n$的时候已经不需要保证度数可以直接相连。

若已知$a > b > c > d$，在所有将他们分成两对分别求乘积的和的方案中，最大值为$ab + cd$。

所以对于上述过程，因为在任意时刻，全局最小的权值会和当前该权值能连边的最小权值相乘，所以最终结果一定是最大值。

可以反证，首先初始的边集为空集，肯定为最优解的子集，如果最小的权值$a$没有和它能连的最小权值$b$相连，而和$c$相连，那么一定会存在一个比$a$大的权值$d$和$b$相连，这违背了上述结论，所以这个解一定不是最优的，故上述结论构成的子集一定是最优解的子集，于是如果当前为最优解的子集，之后每步加的边都是最优解的子集。

这个过程具有对称性，所以对权值的排序从小到大和从大到小是等价的。

而我们保证了$[1, j]$为连通块，每次相连一定与$[j + 1, n]$的点相连，对于$k$来说，因为$i$到$k$路径上的点度数均为1，所以和$k$相连的点不可能与之前的连通块构成环，剩下的点与$[k + 1, n]$的点相连，这时可以理解为这些点已经不存在，并且后面的点度数改变，由于题目保证可以构成树，加上我们限制了每个点至少要保留1的度数，所以这个过程毫无影响正确性。

时间复杂度O(n)，这里为了复杂度对应用的桶排，实际上用sort可以在2s内通过所有数据。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>

#define mp(x, y) make_pair(x, y)
#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout);

using namespace std;

const int N = 1e7 + 10;

inline int read() {
	bool sym = 0; int res = 0; char ch = getchar();
	while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
	return sym ? -res : res;
}

struct NODE {int d, val;} dat[N], t[N];

int n, m = 5e5, last, cnt[N];

long long ans;

namespace STD {
	unsigned seed;
	unsigned rnd(unsigned x) {
		x ^= x << 13; x ^= x >> 17; x ^= x << 5; return x;
	}
	int rad(int x, int y) {
		seed = rnd(seed); return seed % (y - x + 1) + x;
	}
	void init() {
		seed = read();
		for(int i = 1; i <= n; i++) t[i].d = 1, t[i].val = rad(1, 500000);
		for(int i = 1; i <= n - 2; i++) t[rad(1, n)].d++;
	}
}

void sort() {
	for (int i = 1; i <= n; i++) cnt[t[i].val]++;
	for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
	for (int i = 1; i <= n; i++) dat[cnt[t[i].val]--] = t[i];
}

int main() {
	int type = read(); n = read();
	if (type == 1) STD::init(); else {
		for (int i = 1; i <= n; i++) t[i].d = read();
		for (int i = 1; i <= n; i++) t[i].val = read();
	}
	sort(); last = 1;
	for (int i = 1, j = 2, k = 2; i <= n; i++, j = max(j, i + 1)) {
		while (dat[i].d == 0 && i <= n) i++; if (i > n) break;
		while (dat[i].d > 1) {
			while (dat[j].d == 0) j++; if (dat[j].d > 1) last = j;
			ans += 1ll * dat[i].val * dat[j].val; dat[i].d--; dat[j].d--; j++;
		}
		if (last == i) {
			k = max(j, k); while (dat[k].d <= 1 && k < n) k++;
			ans += 1ll * dat[i].val * dat[k].val; dat[i].d--; dat[k].d--; i = j;
			while (i < k && dat[k].d > 1) {
				ans += 1ll * dat[i].val * dat[k].val; dat[i].d--; dat[k].d--; i++;
			}
			if (dat[k].d == 1) last = i; else last = k; i--;
		} else {
			while (dat[j].d == 0 && j < n) j++; if (dat[j].d > 1) last = j;
			ans += 1ll * dat[i].val * dat[j].val; dat[i].d--; dat[j].d--; j++;
		}
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：dead_X (赞：9)

好怀念那段时光啊。

但现在也不错不是嘛。
## 思路
一个事实：如果每个点度数 $\in[1,n)$ 且所有点度数和 $=2n-2$，那么可以连出树。

证明：每次选择度数最小的点和度数最大的点连边。

1. 度数最小的点一定是 $1$。
2. 度数为 $n-1$ 的点在 $n>2$ 的时候不能存在 $2$ 个。
3. 度数最大值在 $n>2$ 时一定 $>1$。

另一个事实：如果一张图上最大值和次大值之间能连边但没有连边，存在更优的调整。

证明：假设 $A,B$ 是最大值，$C$ 是生成树上和 $A$ 相邻，但不在 $(A,B)$ 路径上的边，$D$ 是树上 $B$ 的父亲，我们的一个简单调整方法是将 $(A,C),(B,D)$ 变为 $(A,B),(C,D)$。

所以事实上我们每次做的就是选一个权值最大的非叶子节点，再在剩下的点里取权值最大的连边。

时间复杂度直接看起来要带 $\log$，但稍加分析会发现并不存在：对于度数  $\geq 2$ 的点，在进行一次缩点之后，连通块一定是一个前缀和若干散点，所以精细实现一下就好。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
const int N=5e5;
int a[10000003],b[10000003];
int c1[500003];
vector<int> c2[500003];
deque<pair<int,int>> q1,q2,q3,q4;
unsigned seed;
unsigned rnd(unsigned x){
	x^=x<<13;
	x^=x>>17;
	x^=x<<5;
	return x;
}
int rad(int x,int y){
	seed=rnd(seed);
	return seed%(y-x+1)+x;
}
signed main()
{
	int n;
	if(!read())
	{
	    n=read(); 
	    for(int i=1; i<=n; ++i) a[i]=read();
	    for(int i=1; i<=n; ++i) b[i]=read();
	}
	else
	{
	    n=read(); 
		scanf("%u",&seed);
		for(int i=1; i<=n; i++)
			a[i]=1,b[i]=rad(1,N);
		for(int i=1; i<=n-2; ++i)
			++a[rad(1,n)];
	}
	for(int i=1; i<=n; ++i)
		if(a[i]==1) ++c1[b[i]];
		else c2[b[i]].push_back(a[i]);
	for(int i=N; i>=1; --i) if(c1[i])
		q1.push_back({i,c1[i]});
	for(int i=N; i>=1; --i)
		for(int j:c2[i])
			q2.push_back({i,j});
	ll ans=0;
	while(!q3.empty()||!q2.empty())
	{
		if(q3.empty())
			q3.push_back(q2.front()),q2.pop_front();
		auto [x,y]=q3.front();
		q3.pop_front();
		int last=q3.empty();
		for(int i=1; i<=y-last; ++i,last=q3.empty())
		{
			int mx=-1;
			if(!q1.empty()&&q1.front().first>mx)
				mx=q1.front().first;
			if(!q2.empty()&&q2.front().first>mx)
				mx=q2.front().first;
			if(!q4.empty()&&q4.front().first>mx)
				mx=q4.front().first;
			ans+=1ll*mx*x;
			if(!q1.empty()&&q1.front().first==mx)
				{if(!--q1[0].second) q1.pop_front();}
			else if(!q2.empty()&&q2.front().first==mx)
				q3.push_back({q2.front().first,
				q2.front().second-1}),q2.pop_front();
			else if(!q4.empty()&&q4.front().first==mx)
				q4.pop_front();
			else puts("HaitangSuki");
		}
		if(last) q4.push_back({x,1});
	}
	vector<int> V;
	for(auto [x,y]:q1)
		for(int i=1; i<=y; ++i)
			V.push_back(x);
	for(auto [x,y]:q4)
		for(int i=1; i<=y; ++i)
			V.push_back(x);
	printf("%lld\n",ans+1ll*V[0]*V[1]);
	return 0;
}
```

---

## 作者：ChickyHas (赞：1)

这题放模拟赛 T1 实在是妙啊！

将点按照 $b_i$ 从大到小排序，每次和能连的 $b_i$ 最大的点连边。

原因是考虑 $a<b<c<d$ 显然有 $ab+cd>ac+bd$

如果两个点连边之后使得某个连通块不会再有出边，或者连完之后出现了环，那么就是不能连的，否则就可以连。

具体的，用两个队列来维护。最终肯定是一棵树，也就是一个连通块，那么我们一个队列维护最终的连通块中，能连出去的 $b_i$ 的值。另一个维护剩着的度数为 1 的连通块中还能连出去的 $b_i$。每次先和最终的连通块连边，然后把当前点加入最后连通块中，然后与度数为 1 的连通块再去一一配对，如果第一个队列为大小为 1，就把它也放到度数为 1 的那一类去。

给个 std 实现:


```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int N = 2e7 + 5;

int op, n, p[N], q[N];
unsigned seed;
ll ans;

struct A {
  int d, w;
} a[N];

unsigned rnd() {
  seed ^= seed << 13, seed ^= seed >> 17, seed ^= seed << 5;
  return seed;
}

int rand(int l, int r) {
  return rnd() % (r - l + 1) + l;
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> op >> n;
  if (!op) {
    for (int i = 1; i <= n; ++i) {
      cin >> a[i].d;
    }
    for (int i = 1; i <= n; ++i) {
      cin >> a[i].w;
    }
  } else {
    cin >> seed;
    for (int i = 1; i <= n; ++i) {
      a[i].d = 1, a[i].w = rand(1, 500000);
    }
    for (int i = 1; i <= n - 2; ++i) {
      ++a[rand(1, n)].d;
    }
  }
  sort(a + 1, a + 1 + n, [](A i, A j) { return i.w > j.w; });
  int ph = 1, pt = 0, qh = 1, qt = 0;
  for (int i = 1; i <= n; ++i) {
    if (ph > pt) {
      while (a[i].d--) {
        p[++pt] = a[i].w;
      }
    } else {
      ans += 1ll * p[ph++] * a[i].w;
      while (--a[i].d) {
        p[++pt] = a[i].w;
      }
    }
    while (ph < pt && qh <= qt) {
      ans += 1ll * p[ph++] * q[qh++];
    }
    if (ph == pt) {
      q[++qt] = p[ph++];
    }
  }
  ans += 1ll * q[qh] * q[qt];
  cout << ans;
  return 0;
}
```

---


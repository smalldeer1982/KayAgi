# [省选联考 2022] 序列变换

## 题目描述

你手里有一个长度为 $2 n$ 的合法括号序列 $s$。$s$ 的每一个左括号有一个权值。

在你眼中，不同的括号序列带来的视觉美感不尽相同。因此，你对具有某一种结构的括号序列特别喜欢，而讨厌具有其他一些结构的括号序列。你希望对 $s$ 进行一些变换，以消除掉一些自己不喜欢的结构。

具体而言，形如 $\texttt{(A()B)}$（其中 $\texttt{A}$、$\texttt{B}$ 均为合法括号序列，下同）的结构是你喜欢的，
而形如 $\texttt{(A)(B)}$ 的结构是你不喜欢的。你有两种操作来改变括号之间的位置。

这两种操作如下：
- 操作 1：交换形如 $\texttt{p(A)(B)q}$ 的串中 $\texttt{A}$ 和 $\texttt{B}$ 之间的两个括号，变换为 $\texttt{p(A()B)q}$（其中 $\texttt{p}$、$\texttt{q}$ 为任意串，可以为空，但不一定分别为合法括号序列，下同），它的代价为 $x$ 乘 $\texttt{(A)}$ 中第一个左括号的权值加上 $y$ 乘 $\texttt{(B)}$ 中第一个左括号的权值，其中 $x, y \in \{0, 1\}$；
- 操作 2：交换形如 $\texttt{pABq}$ 的串中的 $\texttt{A}$ 和 $\texttt{B}$，变换为 $\texttt{pBAq}$，这个操作不需要代价。

注意：交换的时候所有左括号的权值是跟着这个括号一起交换的。

你现在想知道的是，将 $s$ 变换为一个不包含你不喜欢的结构的括号序列至少需要多少代价？

## 说明/提示

**【样例解释 #1】**

最优方案是先使用操作 2 交换两对括号，然后使用操作 1（此时 $\texttt{A}$、$\texttt{B}$、$\texttt{p}$、$\texttt{q}$ 都是空串）交换中间的两个括号，代价为 $\texttt{B}$ 左边那个括号的权值，也就是 $1$。最后得到括号序列 $\texttt{(())}$，不包含你不喜欢的结构。

**【样例解释 #2】**

最优方案是直接使用操作 1，因为此时计算代价的方式不同了，这次只算 $\texttt{A}$ 左边的那个括号的权值作为代价。

**【数据范围】**

保证 $2 \le n \le 400000$，$0 \le x, y \le 1$。

保证所有的权值在 $[1, {10}^7]$ 之内。

| 测试点编号 | 特殊限制 |
|:-:|:-:|
| $1 \sim 3$ | $n \leq 8$ |
| $4 \sim 5$ | 所有权值均相等 |
| $6 \sim 8$ | $n \leq 20$ |
| $9 \sim 12$ | $x = 0$，$y = 1$ |
| $13 \sim 16$ | $n \le 2000$ |
| $17 \sim 25$ | 无特殊限制 |

**【提示】**

称一个字符串 $s$ 为合法括号序列，当且仅当 $s$ 仅由数量相等的字符 $\texttt{(}$ 和 $\texttt{)}$ 组成，且对于 $s$ 的每一个前缀而言，其中 $\texttt{(}$ 的数量均不少于 $\texttt{)}$ 的数量。特别地，空串也是合法括号序列。

## 样例 #1

### 输入

```
2 0 1
()()
1 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2 1 0
()()
1 3
```

### 输出

```
1
```

## 样例 #3

### 输入

```
见附件中的 bracket/bracket3.in```

### 输出

```
见附件中的 bracket/bracket3.ans```

# 题解

## 作者：Alex_Wei (赞：44)

> *VI. [P8293 [省选联考 2022] 序列变换](https://www.luogu.com.cn/problem/P8293)

感谢 chenxia25 和 Kubic 的指教。

题目希望我们将原括号序列转化为形如 `((((...))))` 嵌套的括号序列。

自然考虑抽象题意，解剖两个操作的本质是什么。因为光看括号上的变换似乎没有什么眉目。

将括号序列建树，我们发现操作 1 形如将树上某个节点的两个儿子 $a$ 和 $b$ 进行如下变换：将 $b$ 的所有儿子挂到 $a$ 上，并将 $b$ 挂到 $a$ 上（指将 $b$ 变成 $a$ 的儿子），代价即 $xv_a + yv_b$（一个节点的权值即其对应的括号的权值）。而操作 2 说明对于某个节点的若干儿子，我们可以以任意顺序执行该操作，即同层节点之间顺序无关。最终我们希望将这棵树变成一条链。

第一步贪心是从浅到深进行所有这样的操作，因为操作 1 使得一些当前层的节点被下调至下一层，最终仅在当前层留下一个节点。也就是说在节点被不断下调的过程中，先操作上面的节点，再操作下面的节点的自由度最大。

显然，对于不同的 $x, y$，策略也是不同的。或者说，由于 $x, y$ 的情况数很少，我们不妨分类讨论以简化问题。

- 当 $x = y = 0$ 时，答案显然为 $0$。

- 当 $x = 0$，$y = 1$ 时，合并代价为被解剖的节点的权值。我们知道被解剖的节点会下放到下一层，因此代价可以看做当前层所有节点权值之和，减去留在当前层的节点的权值。很显然，在当前层留下权值最大的节点即可。通过 `multiset` 维护。

- 当 $x = 1$，$y = 1$ 时，合并代价为被解剖的节点的权值，加上接受被解剖的节点的权值。仍然是考虑留下一个节点。当被留下的节点已经定下来时，为使代价最小，当留下的权值非本层最小值时，最优方案为先把丢到下一层的非本层最小值的节点挂到本层最小值上面，再把本层最小值挂到被留下的节点上，否则留下的权值为本层最小值，下放的节点全部挂上去。无论是哪种情况，代价均为本层最小值乘以 $sz_i - 2$（$sz_i$ 是第 $i$ 层的节点个数，这个是不为我们下放了什么节点而改变的，在括号树的形态固定下来时就已经确定了，因为每一层下放的节点个数是确定的），加上本层所有节点的和。显然，在当前层留下权值最大的节点即可。

- 当 $x = 1$，$y = 0$ 时，当被留下的节点已经定下来时，策略和上一种情况是一致的。因此，不难分析得到代价为本层最小值乘以 $sz_i - 2$ 加上本层被留下的节点的权值。单看一层的贡献似乎有些不好考虑，因为我们可以尝试将一个最大值不断下放直到最后一层，使得它对答案不会有贡献。但总体来看，由于所有除了被下放至最后一层的节点均会以某一层被留下的节点的形式贡献至答案，所以总贡献即所有节点权值的和减去被下放至最后一层的节点权值，再加上每一层的权值最小值乘以 $sz_i - 2$。这意味着我们希望 **既能下放最小值，也能下放最大值**（本题的关键结论）。

  当 $sz_i = 1$ 时，没有能够下放的节点，所以忽略一开始的极长的连续的 $1$。

  当 $sz_i > 2$ 时，我们可以留下非最小值且非最大值。

  当 $sz_i = 2$ 时有些难办。注意到最终 $sz$ 形如 $2, 2, \cdots, 2, \geq3, \cdots, \geq 3, 2, 1$（当 $sz$ 下降时，原树该层已经没有节点，所以最终有且只会有一个 $2$，对于这一层我们的策略显然是下放最大值），并且 $sz = 2$ 的层的代价为该层留下的节点，所以对于开头的极长的 $2$，这些层的总代价为所有涉及到的节点权值之和，减去 **唯一**（显然）一个下放的节点的权值。直接枚举这个下放节点的权值，可以得到一个 $\mathcal{O}(n ^ 2)$ 的做法，但是不够优秀。

  通过从小到大枚举下放节点的权值可以做到 $n\log n$，是排序的线性对数，剩下来只需维护一个指针 $p$ 表示如果当前节点 $v$ 下放，那么它最后一次作为最小值是在哪一层（可以通过预处理 $\geq 3$ 的权值前缀 $\min$ 实现），然后通过 $sz$ 的前缀和快速求出结果，同时容易判断 $v$ 是否会成为最大值下放至最后一层，从而快速计算这种方案的贡献，更新答案。但是还是不够优秀。

  既然我们希望能下放最小值或最大值，那么对于 2 段而言，它也仅会下放最小值或最大值。因为下放最小值能让 3 段的最小值尽量小，而下放最大值能让留在最后一层的数尽量大。因此直接模拟下放最小值或最大值即可。时间复杂度 **线性**。

综上，对于 $x = y = 0$，时间复杂度 $\mathcal{O}(1)$。对于 $x = 1$ 且 $y = 0$，时间复杂度线性。剩下来两种情况时间复杂度线性对数。

代码很好写。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e5 + 5;
int n, x, y, v[N], stc[N];
char s[N << 1];
vector <int> buc[N];
multiset <int> t;
long long ans, sum;
int main() {
    cin >> n >> x >> y >> s + 1;
    for(int i = 1; i <= n; i++) scanf("%d", &v[i]);
    for(int i = 1, top = 0, cnt = 0; i <= n << 1; i++)
        if(s[i] == '(') stc[++top] = ++cnt;
        else buc[top].push_back(v[stc[top]]), top--;
    if(x == 0 && y == 0) ;
    else if(x == 0 && y == 1) {
        for(int i = 1; i < n; i++) {
            for(int it : buc[i]) t.insert(it), sum += it;
            ans += sum -= *--t.end(), t.erase(--t.end());
        }
    }
    else if(x == 1 && y == 1) {
        for(int i = 1; i < n; i++) {
            for(int it : buc[i]) t.insert(it), sum += it;
            ans += *t.begin() * (t.size() - 2) + sum;
            sum -= *--t.end(), t.erase(--t.end());
        }
    }
    else {
        static int sz[N] = {1}, mx[N], mn[N], p = 1, q = 1;
        memset(mx, 0, sizeof(mx)), memset(mn, 0x3f, sizeof(mn));
        for(int i = 1; i <= n; i++) sz[i] = sz[i - 1] + buc[i].size() - 1;
        while(p <= n && sz[p] == 1) p++, q++;
        while(q <= n && sz[q] == 2) q++;
        for(int i = p; i < n; i++) {
            if(i != q) mn[i] = mn[i - 1], mx[i] = mx[i - 1];
            for(int it : buc[i]) mn[i] = min(mn[i], it), mx[i] = max(mx[i], it), sum += it;
        }
        long long res1 = sum - mx[n - 1], res2 = sum - max(mx[q - 1], mx[n - 1]); // res1 是下放最小值，res2 是下放最大值
        for(int i = q; i < n; i++) res1 += 1ll * (sz[i] - 2) * min(mn[q - 1], mn[i]), res2 += 1ll * (sz[i] - 2) * mn[i];
        ans = min(res1, res2);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：FjswYuzu (赞：9)

首先做掉 $x=y=0$ 的情况，不管你怎么变我都摆烂输出 $0$。

考虑两个小结论，一个是内层括号提不出来（比如 `(())()` 不能变成 `()()()`），即内层括号不影响外层；二个是你执行的操作 1 次数固定。这两个比较显然。并且被提入内层的永远是右边的左括号。

然后是观察一点特殊性质，比如有一个 $x=0,y=1$ 的部分分。那我们先研究一下这个 $x=0,y=1$ 的部分分。

因为有第一个结论，所以每层互不影响。注意到这个部分分下，我们想让每一层较大的值尽量不贡献，同时发现造成贡献的括号会提入内层继续贡献，那么显然提入内层的括号越小越好。那么这个部分分的贪心策略是在当前层留下最大的左括号，然后解决下一个子问题。记每层的括号权值总和为 $S$，最大的权值为 $p$，那么会造成贡献 $S-p$。

然后考虑看起来非常复杂的 $x=y=1$ 啊。在这个语境下，因为我们还是想要把小的括号放进内层持续贡献。那么将小的放入内层的策略需要我们进行考虑。我们仍然想尽量让大的少贡献，但是这里大的要留在外面必须要贡献一次。那我们有一个简单的策略是，先把非最大值或最小值的左括号塞进最小值（记为 $p$）对应的括号，然后再将最小值对应的左括号塞进最大值对应的括号里。设当前层括号个数为 $|S|$，权值总和为 $S$，易得该层贡献为 $p(|S|-2)+S$。

最后是 $x=1,y=0$，现在是左括号贡献了，但是我们并不好沿用上面的方法，最根本的原因是结构上的问题，因为左括号不会放进去持续贡献。先考虑结构，每一层在一开始的时候的括号个数排成一个序列，会形似 $1,1,\cdots,1,2,2,\cdots ,2,\geq 3,\geq 3,\geq 3, \cdots ,1$。首先前面的极长的 $1$ 可以忽略。从 $\geq 3$ 部分开始之后，我们的策略就唯一了：我们既想让小的持续贡献，还不想让大的贡献，那我们干脆两个都放进去好了。证明方法可以采用 exchange argument（可以假设如果我们将最小值或者最大值留在外面反证）。

但是前面有一堆 $2$，这堆 $2$ 的意义在于，我们最终加入第一个 $\geq 3$ 层的值无法确定。显然这个值要么是前面一堆 $2$ 中的最小值或者最大值，证明仍然采用 exchange argument（如果我放入的不是最小值或最大值那么一定不优于最小值或最大值其中一者或两者，证明很简单）。然后这样的话只需要做 $O(1)$ 遍决策。

上面的三个决策都可以在 $O(n \log n)$ 时间内实现。

鉴于代码比较长，我放在[这儿](https://www.luogu.com.cn/paste/enhpj4ng)吧。

---

## 作者：Kubic (赞：7)

首先把括号序列转化成一棵有根树，每个点 $u$ 有一个权值 $a_u$。

考虑两类操作对树的形态的影响。

假设有两个节点 $u,v$，它们的儿子集合分别为 $S_u,S_v$。

显然只有 $u,v$ 父亲相同时才能操作。

分析对于 $u,v$ 进行操作得到的结果：

- 如果是第一类操作，那么 $S'_u=S_u\cup S_v\cup \{v\},S'_v=\varnothing$，代价是 $x\times a_u+y\times a_v$。

- 如果是第二类操作，那么只会交换 $u,v$ 的先后顺序。

我们最终需要达到的形态是一条链。

容易发现，一定存在一种最优策略是按照深度从小到大依次操作。

因为在操作深度为 $dep$ 的点时深度为 $1\sim dep-1$ 的点已经形成了一条链，所以我们只关心每个点的权值和深度。

接下来按照 $x,y$ 分类讨论。

令当前这一层（包括从上面传下来的）的点的权值形成的集合为 $S$。

令 $mn,sum$ 分别为 $S$ 中所有数的最小值，最大值，总和。

因为最终形成一条链，所以每一层只会删除一个节点，剩下的都会被传到下一层。

$x=0,y=1$：

删除权值为 $w$ 的节点需要付出的代价是 $sum-w$。那么显然删除**最大值**一定是最优策略。

$x=1,y=1$：

删除权值为 $w$ 的节点需要付出的代价是 $sum+mn\times (|S|-2)$。那么显然删除**最大值**一定是最优策略。

$x=1,y=0$：

删除权值为 $w$ 的节点需要付出的代价是 $w+mn\times (|S|-2)$。

这时候就不能贪心地删除最大值了。

根据这个式子可以发现，前 $n-1$ 层每一层删除的节点都会产生对应权值的贡献。我们前 $n-1$ 层中每一层的 $mn$ 都尽量小，又要使得前 $n-1$ 层中每一层的 $w$ 之和尽量小。

只有一个点不会在前 $n-1$ 层中被删除，因此相当于是要使得第 $n$ 层的 $w$ 最大。

不妨假设前 $n-1$ 层中不存在 $|S|=1$ 的情况，这种层一定没有贡献。

如果对于前 $n-2$ 层都有 $|S|\ge 3$，那么每一层都删除**次大值**一定是最优策略。

但有时可能不满足这个条件。

可以发现前 $n-2$ 层中 $|S|=2$ 的层一定形成一段前缀。我们可以事先计算出每一层的 $|S|$ 并找到这一段前缀。假设这一段前缀为 $1\sim p$。

显然，操作完前 $p$ 层之后只会传下来一个节点。

可以直接暴力枚举传下来的是哪个节点，然后用之前 $|S|\ge 3$ 的做法往后贪心就可以得到一个 $O(n^2\log n)$ 的做法。

但实际上可以发现我们留下的一定是前 $p$ 层中涉及到的所有数中的最小值或者最大值，这一点可以用调整法证明。

这样我们就得到了一个 $O(n\log n)$ 的做法，可以通过本题。

题外话：实际上我认为 $x=1,y=1$ 和 $x=1,y=0$ 难度差不多，但大部分人好像认为后者难很多？~~虽然按照题解的篇幅来看好像后者确实难很多~~

---

## 作者：violetctl39 (赞：4)

当时的我连括号可以建树都不知道，但考场上想到了大贪心，$4$ 种情况分开处理，每次都是外层括号向内层转移。然而考场贪挂了，只有 $36$ 分。/ll

首先发现，第一种操作就是将外层括号放进内层中，第二种操作可以让你在同一层里任意调换左括号的顺序，所以可以从外层向内一层层来处理。那么接下来就可以大力分讨了。

$x=0,y=0$：

每个左括号的贡献为 $0 $，答案就是 $0$。

```cpp
void solve1(){puts("0");}
```

$x=0,y=1$：

对于同一层来说，因为最后只会留一个左括号在这一层且贡献为 $0$，而其他进内层的左括号都对答案有贡献，所以可以把这一层的最大值留在这里，其他进内层。

```cpp
void solve2()
{
    priority_queue<int>q;
    int sum=0;//当前层的左括号权值和
    for(int i=1;i<=n;++i)
    {
        for(int w:v[i])q.push(w),sum+=w;
        sum-=q.top();q.pop();ans+=sum;
    }write(ans),pc('\n');
}
```

$x=1,y=0$：

个人感觉这一种情况最不好想。

首先一个贪心是尽可能的用当前权值最小值的左括号去把其他左括号转移进内层。这样直接贪心显然不对，最小值进内层可能更优。

换个思路，操作完时，有 $n-1$ 个左括号会留在 $1\dots n-1$ 层，这些括号都对答案有贡献，而最后一个左括号在第 $n$ 层没有贡献。所以第二个贪心是尽可能的让全局最大值进到最后一层，这样不会对答案有贡献。

考虑将两个贪心结合起来，既然最小值进内层可能更优，最大值进内层也可能更优，那让它们都进内层就行了，当前层留下一个非最大值非最小值的左括号就行了。因为第二个贪心中，中间值是一定对答案有贡献的，所以在本层放中间值一定不会使答案变劣。

但是，上面是存在中间值的处理方法，还有可能本层只有 $2$ 个左括号。

首先，最大值如果不是全局最大值的话，就没有进内层的必要了，留着就行。最大值是全局最大值的话，进内层选其中一个都有可能使答案更优。但注意的是，如果是全局最大值进内层了，当且仅当它留在了最后才不会对答案有贡献。所以其实可以分 $2$ 种情况考虑：全局最大值优先进内层，非全局最大值时最小值进内层；最小值优先进内层。两种情况都计算一遍答案取 $\min$ 就行。

需要注意的是，在 $n-1$ 层时，直接留下最小值，这样最大值才不会有贡献。

```cpp
void solve3()
{
    priority_queue<int,vector<int>,greater<int> >q;
    int sum=0,siz=0,now=1e9;//sum是最小值进内层的答案，siz是当前左括号数量，now是当前最小值
    for(int i=1;i<n;++i)//最小值进内层
    {
        siz+=v[i].size();
        for(int w:v[i])q.push(w),now=min(now,w);
        if(i==n-1){sum+=now;break;}
        if(q.size()==1){q.pop();--siz;now=1e9;continue;}
        --siz;sum+=(siz-1)*now;
        q.pop();sum+=q.top();q.pop();
        q.push(now);
    }siz=0,now=1e9;while(!q.empty())q.pop();
    for(int i=1;i<n;++i)//全局最大值进内层
    {
        siz+=v[i].size();
        for(int w:v[i])q.push(w),now=min(now,w);
        if(i==n-1){ans+=now;break;}
        if(q.size()==1){q.pop();--siz;now=1e9;continue;}
        if(q.size()==2)//就多这一部分
        {
            q.pop();
            if(q.top()==mx){--siz;ans+=now;now=q.top();}
            else{--siz;ans+=q.top();q.pop();q.push(now);}
            //不是全局最大值的话仍然把最大值留在本层
        }
        else
        {
            --siz;ans+=(siz-1)*now;
            q.pop();ans+=q.top();q.pop();
            q.push(now);
        }
    }write(min(sum,ans)),pc('\n');
}
```

$x=1,y=1$：

因为留在本层或者进内层都会有贡献，所以我们需要的是尽可能减少最大值对答案的贡献。手算几个小样例就可以发现留着对答案的贡献会不多于进内层的贡献，所以可以将最大值直接留着，这样对答案的贡献最小。还是贪心的处理括号，用最小值的左括号将非最大值的左括号全部转移进内层，再用最大值的左括号转移最小值的左括号进内层。

```cpp
void solve4()
{
    priority_queue<int>q;
    int sum=0,siz=0,now=1e9;//sum是当前层的和，siz是当前左括号数量，now是当前最小值
    for(int i=1;i<=n;++i)
    {
        siz+=v[i].size();
        for(int w:v[i])q.push(w),sum+=w,now=min(now,w);
        if(q.size()==1){q.pop();--siz;sum=0;now=1e9;continue;}
        ans+=sum+(siz-2)*now;sum-=q.top();q.pop();--siz;
    }write(ans),pc('\n');
}
```

完整代码就不贴了。

嘤嘤嘤，考场挂到 $36$ 分。/kk



---

## 作者：FLY_lai (赞：3)

[传送门](https://www.luogu.com.cn/problem/P8293)

先将括号序列建树。

具体而言，假设当前根结点为 $rt$，当前括号序列为 $s$。若 $s$ 能分成 $cnt$ 组括号，则 $rt$ 有 $cnt$ 个儿子。对于第 $i$ 个儿子，以它为新根结点，第 $i$ 组括号为新括号序列，递归建树。

例如 `(()())(())` 建出来的树长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/q8bdzkx3.png)

同时，在每个结点上记录它代表的括号序列中第一个左括号的权值，作为这个结点的权值。$u$ 的权值记为 $a_u$。

题目中给出的两个操作可以对应到树上的操作。

操作一：交换相邻两颗子树，无代价。

操作二：选定两个儿子 $c,d$，将 $d$ 作为 $c$ 的儿子，$d$ 的子孙们都变成 $u$ 的儿子。代价为 $a_c\times x+a_d\times y$。称为 “下降” 操作。

形象点：
![](https://cdn.luogu.com.cn/upload/image_hosting/lt0grfvj.png)

题目最终的要求是花费最小的代价让这棵树变成链。

先给出一个结论：一定存在最优解，先对浅的结点下降，再对深的结点下降。

证明很简单，因为先下降浅的结点的后续可能性包含了所有先下降深的结点的后续可能性。所以先下降浅的结点一定不差。

下面分类讨论。

$x=y=0$ 时很显然，答案为 $0$。

$x=y=1$ 时，给出一个贪心方法。假设当前层有 $t$ 个结点 $v_1\sim v_t$，且 $a_{v_1}\le\dots\le a_{v_t}$。我们先依次选定 $(v_1,v_2),(v_1,v_3),\dots,(v_1,v_{t-1})$，让 $v_2\sim v_{t-1}$ 下降。然后选定 $(v_1,v_t)$ 让 $v_1$ 下降。

这一层花费是 $(t-2)v_1+(v_1+v_2+\dots+v_t)$。

而我们知道这一层总归是需要留下一个结点的。但是如果留下的不是 $v_t$，可以换成 $v_t$，这样更深的层花费会更少。因此按照这个贪心就行了。

$x=0,y=1$ 时，每一层的花费是这一层所有要下降的结点权值和。如果选择下降 $v_1\sim v_{t-1}$，不仅本层的花费最小，而且对未来也更优。

最后是 $x=1,y=0$，这种情况是最难的，因为如果下降权值小的，对未来更优，但是留在本层的要收费，对现在不优；如果下降权值大的，对未来不优。

我们加几个定义：

假设最后链长为 $n$。$cnt[i]$ 表示处理第 $i$ 层时第 $i$ 层有多少个结点，$mn[i]$ 表示处理第 $i$ 层时权值最小的结点的权值，$w[i]$ 表示留了一个权值为 $w[i]$ 的在第 $i$ 层。

则总修改代价 $cost = \displaystyle\sum_{i=1}^{n-1} mn[i](cnt[i]-2)+allsum-w[n]$，其中 $allsum$ 表示所有节点的权值和。

这个式子是怎么推出来的？对于第 $i$ 层，最终留下 $w[i]$，最优决策就是让 $mn[i]$ 把其他结点都下降，然后让 $w[i]$ 下降 $mn[i]$。因此本层的最优决策是 $mn[i](cnt[i]-2)+w[i]$。于是总修改代价就是 $1\sim n-1$ 层的代价求和。

我们的目标是使 $cost$ 最小，因为 $allsum$ 为常数，所以就等价于让 $\sum mn[i](cnt[i]-2)-w[n]$  最小。

当 $cnt[i]\ge 3$ 时，我们可以贪心地每次让本层的最小值和最大值都下降，随便留下一个其他的就行了。因为留下哪一个其实对总代价没影响，而下降最小值可以让未来的 $mn$ 更小，下降最大值可以让 $w[n]$ 尽可能的大。

于是我们解决了 $cnt[i]\ge 3$ 的情况，$cnt[i]=1$ 就结束了，只剩 $cnt[i]=2$ 的情况。

这个时候我们再补充一个观察：$cnt$ 数组一旦开始下降，就会一直下降。

为什么呢？因为每一层下降只会减少一个结点，连只减少 $1$ 都无法挽回，说明下一层没有结点了。既然没有结点，就会一直下降直到成链。

于是 $cnt[i]=2$ 的情况一定是连续的，也就是某一层 $cnt=2$，然后两个结点中连着一个结点，这个结点又连着一个 …… 直到某一个结点有两个儿子，$cnt=3$ 了，这之前 $cnt=2$。

我们称 $cnt=2$ 的部分为上部分，比上部分深的部分为下部分。显然上部分会有一个结点下降到下部分，记这个结点为 $p$；同时记下部分中最大值为 $q$（不包括上部分下来的 $p$）。上部分与下部分的分界层为 $l$。

当 $p\le q$，总花费为 $sum_{up}-p+\displaystyle \sum_{i=l}^{n-1}mn[i](cnt[i]-2)+(sum_{down}+p)-q$，其中 $sum_{up}$ 为上部分的权值之和，$sum_{down}$ 为下部分的权值之和。手推一下就行。

发现 $p$ 抵消掉了，$q$ 和 $cnt$ 都是固定的，所以我们选择下降最小的下去，这样能让 $mn$ 更小。

当 $p>q$，总花费类似刚刚的式子： $sum_{up}-p+\displaystyle \sum_{i=l}^{n-1}mn[i](cnt[i]-2)+(sum_{down}+p)-p$。抵消后剩一个 $-p$，而且因为 $p>q$，下部分最大的都比 $p$ 小了，$p$ 也不可能对 $mn$ 有贡献了，所以肯定要 $p$ 越大越好。

至此，$cnt=2$ 的情况也解决了。那整个问题也就解决了。

---

## 作者：donkeys (赞：3)

首先看到这个题，不慌，先玩玩它的变换到底能产生什么影响。

交换（操作二）的话就是单纯的改变代价（受 $x,y$ 影响），而嵌套（操作一）的话就是将两组同级括号的其中一组的左括号转为高一级的括号。

具体解释，我们把一个括号的等级记为它被多少组匹配的括号包裹。比如（（）（））（），其中第一个和最后一个左括号的等级是 $0$ ，剩下两个的等级是 $1$ 。

而我们最终的目的是，让这个括号序列变成等级为 $1-n$ 的括号序列。

我们先来制定一个整体策略--优先交换低级括号。理由是，这样可以将高一级的括号中额外并入新的选项，并且因为可以自由交换同级括号的顺序，所以也不会变得更劣。

接下来考虑 $x,y$ 。因为想要贪心，而 $x,y$ 的不同看起来可能会影响贪心策略，我们尝试分类讨论。

### $x=0,y=0$

答案显然。

### $x=1,y=1$

因为每次对一个括号升级，它和它的“跳板”（等级不变的那个括号）都会产生花费，所以我们刚开始肯定先用代价最小的当“跳板”给其他括号升级。但是我们最终要在这一级上保留那个括号呢？代价最大的。反正不管给不给代价最大的升级，它都会产生一次贡献，那不如就把它留在这里，省的再下去霍霍别人（产生更多的贡献）。

然后用multiset维护一下就好。

### $x=0,y=1$

这回跳板不要钱了。最大的留在这里不仅不下去霍霍了还能免费！不要白不要啊。

嗯就是贪心策略和上一个完全一样不过计算代价改一下就好。

### $x=1,y=0$

稍微难想一点。我们设要合并等级 $l$ 的括号时括号的个数为 `sz[l]` 。有一个比较重要的性质，就是 `sz[]` 前半段非严格递增，后半段为公差为 $-1$ 的等差数列。大致说明一下，就是：

$(A)(B)\to (A()B)$ ，其中AB中所有括号等级不变， $(B)$ 的第一个左括号等级 $+1$ 。这就意味着我们每个等级要处理的括号来源于两部分--之前升级升上来的，和原来就是这个等级的。如果设 `num[l]` 为原始等级为 `l` 的括号，那 `sz[l]=sz[l-1]-1` （留下不升级的） `+num[l].size()` 。如果 `num[].size()` 的第 $x$ 项为 $0$ ，那其后面必定全是 $0$ ，因为括号等级不可能跳跃。这样的话就能得出上述关于 `sz[]` 变化的结论。

还有一个简单一些的结论，就是每次保留，必定会产生一次贡献（ `sz[]` 最开始的 $1$ 和最后的 $1$ 因为不用操作没有贡献）。

对于每一级，显然还是用最小的做跳板。但是最后如何保留？如果保留最小的，那么虽然这一级花费小了，但往下可能就没有这么“优秀”的跳板了。如果保留最大的，因为升级不需要代价，或许可以把这个最大的留到最后。所以，我们留一个除了最小最大以外的任何一个就好，因为用这个留下的做跳板不如小的优，留到最后不如大的优。

但是对于 `sz[]=2` 的怎么办?由于关于 `sz[]` 的结论， `sz[]=2` 必定是一段连续区间。这就意味着这段区间里只有一个能升到 `sz[]=3` 的等级。因为代价只来源于“保留”和“跳板”，那么对于这段区间，他要么提供一个最大的来竞争“免费保留”，要么提供一个最小的来竞争“最优跳板”，就是分别向后提供一个最大的和最小的，对这两种方案取最小值即可。

极度凌乱的考场代码，略加了稍微yì点点修改。

```cpp
#include<iostream>
#include<vector>
#include<set>
using namespace std;
#define N 400005
#define ll long long
int n, x, y;
char s[N << 1];
int val[N];
vector<int> lvhave[N];
int main()
{
	scanf("%d%d%d", &n, &x, &y);
	if(x == y && y == 0)
		return puts("0"), 0;
	scanf("%s", s + 1);
	for(int i = 1; i <= n; ++i)
		scanf("%d", &val[i]);
	for(int i = 1, lr, lv = 0, cnt = 0; i <= n << 1; ++i)
	{
		lr = s[i] == '(' ? ++cnt, 1 : -1, lv += lr;
		if(lr == 1)
			lvhave[lv].emplace_back(val[cnt]);//这个等级都有哪些括号
	}
	if(x == 1 && y == 1)//max out
	{
		multiset<int>have, ivh;
		ll sum = 0, ans = 0;
		for(int i = 1; i <= n; ++i)
		{
			for(auto j : lvhave[i])
				have.emplace(j), sum += j, ivh.emplace(-j);
			ans += sum + (have.size() - 2ll) * *have.begin();
			have.erase(have.find(-*ivh.begin())), sum += *ivh.begin(), ivh.erase(ivh.begin());
		}
		printf("%lld\n", ans);
		return 0;
	}
	if(x == 0 && y == 1)//max out
	{
		multiset<int>have, ivh;
		ll sum = 0, ans = 0;
		for(int i = 1; i <= n; ++i)
		{
			for(auto j : lvhave[i])
				have.emplace(j), sum += j, ivh.emplace(-j);
			ans += sum + *ivh.begin();
			have.erase(have.find(-*ivh.begin())), sum += *ivh.begin(), ivh.erase(ivh.begin());
		}
		printf("%lld\n", ans);
		return 0;
	}
	if(x == 1 && y == 0)//se out
	{
		int sz[N] = { 1 }, mx[N] = { 0 }, mn[N];
		ll sum = 0, ans1 = 0, ans2 = 0;
		int mx2 = 0, mn2 = 0x7fffffff, mx1 = 0, mn1 = 0x7fffffff;
		for(int i = 1; i <= n; ++i)
		{
			sz[i] = sz[i - 1] - 1, mn[i] = 0x7fffffff;
			for(auto j : lvhave[i])
				++sz[i], sum += j, mx[i] = max(mx[i], j), mn[i] = min(mn[i], j);
			if(sz[i] == 0)
				break;
		}
		int p = 1;
		while(sz[p] == 1)sum -= mx[p], ++p;
		for(; sz[p] == 2; ++p)
			mx2 = max(mx2, mx[p]), mn2 = min(mn2, mn[p]);
		for(; sz[p] > 2; ++p)
		{
			mx1 = max(mx1, mx[p]), mn1 = min(mn1, mn[p]);
			ans1 += (sz[p] - 2ll) * min(mn1, mn2), ans2 += (sz[p] - 2ll) * min(mn1, mx2);
		}
		for(; sz[p] > 1; ++p)
			mx1 = max(mx1, mx[p]), mn1 = min(mn1, mn[p]);
		ans1 += sum - max(mx1, mn2), ans2 += sum - max(mx1, mx2);
		printf("%lld\n", min(ans1, ans2));
		return 0;
	}
	return 0;
}


```


---

## 作者：RyexAwl (赞：3)

## 将合法括号序列转化为树形结构

学过莫队处理树上关于链的询问的同学应该知道对于任意一棵 $n$ 个点的有根树都可以构造出一个长度 $2n$ 的括号序列：

```cpp
void dfs(int x) {
    rbs[++cnt]='(';
    for (auto v : G[x]) {
        dfs(v);
    }
    rbs[++cnt]=')';
}
```


比如下面这棵树构造出来的括号序列即为 $\texttt{((()(()))(()))}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/02jen7pt.png)

并且其中任意一对匹配的括号都可以对应到原树的一棵子树，任意一个左括号可以对应到原树的一个点。

而对于任意一个长度为 $2n$ 的（形如 $(S)$，其中 $S$ 是一个合法括号序列）合法括号序列我们都可通过下面的方式建立一棵 $n$ 个点的有根树，使得该树构造出来的括号序列恰好为给定的括号序列：

* 初始化 $tot=1,now=1$。

* 扫描括号序列的第 $2$ 到 $2n-1$ 位。

* 如果括号序列的第 $i$ 位为左括号令 $tot \gets tot+1,fa[tot]=now,now=tot$。

* 如果括号序列的第 $i$ 位为右括号令 $now\gets fa[now]$。

而第 $i$ 个左括号即对应到树上编号为 $i$ 的点。

而对于形如 $\texttt{(S1)(S2)...(Sm)}$ 的括号序列（$\texttt{Si}$ 均表示一个合法括号序列），可以加一对匹配的括号将其变为形如 $\texttt{(S)}$ 的括号序列：

$$
\texttt{(S1)(S2)...(Sm)}\to \texttt{((S1)(S2)...(Sm))}
$$

对变形后的括号序列建树可以得到一棵 $n+1$ 个点编号从 $0\sim n$ 的树。

（下面的代码中， `str` 为变形之前的括号序列）

```cpp
int tot = 0,now = 0;
for (int i = 1; i <= 2 * n; i++) {
    if (str[i] == '(') {
        G[now].push_back(++tot); fa[tot] = now; now = tot;
    } else {
        now = fa[now];
    }
}
```
接下来考虑对于一种不存在 $\texttt{(A)(B)}$ 结构的括号序列其树形结构是怎么样的。

不难发现，对于有根树中的某个点 $u$，如果其有 $\ge 2$ 个儿子，那么该树构造出来的括号序列中一定有形如 $\texttt{(A)(B)}$ 的结构。因此对于一种树形结构来说，其构造出来的括号序列不包含 $\texttt{(A)(B)}$ 的必要条件是对于任意一个点 $u$，点 $u$ 有且仅有一个儿子。并且这个条件是充分的，因为对于一条链而言其对应的括号序列一定是形如 $\texttt{(((((())))))}$ 的。

再考虑题目中给的两种操作如何对应到树上。

因为对于任意一种合法的括号序列一定可以写成形如 $\texttt{(A)(B)(C)...}$ 的形式，而相邻的匹配的括号对应到树上一定是在 DFS 过程中相邻的子树，因为出一棵子树会向括号序列中添加一个右括号因此在括号序中相邻的匹配的括号一定是兄弟关系。

那么操作二可以看成：对于儿子个数 $\ge 2$ 的点 $u$ 选取两段相邻的儿子交换其子树的位置位置。进一步可以直接看成交换任意两个儿子的子树。

因为操作而可以用 $0$ 费用进行儿子位置的交换，所以在操作 $1$ 中我们可以不在意儿子在 DFS 过程中的顺序。

而对于操作 $1$ 可以看成：对于一个儿子个数 $\ge 2$ 的点 $u$，选取两个儿子 $p,q$，将所有 $q$ 儿子的子树“挂到” $p$ 上，再将 $q$ 作为叶节点“挂到” $p$ 上，花费为 $x\times w[p]+y\times w[q]$，并且在下面的讨论中，我们将使用 $\mathrm{op(p,q)}$ 表示对 $p,q$ 进行操作 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/vzg70cu1.png)

那么问题即可转化为通过若干次操作 $1$ 与操作 $2$，将给定有根树操作成一条链的最小花费。

在下面的讨论中我们将按自顶向下的顺序考虑：即从 $1$ 到 $n$ 依次考虑在最终链中深度为 $i$ 的点是哪个点，按自上到下的顺序合并（这里可以感性理解一下，因为子树内部的合并在当前层的合并之后做也不影响，所以一定可以先将当前层合并之后再考虑内部的合并），并且在下面的讨论中如果当前考虑到了第 $i$ 层，同时考虑维护一个集合 $S_i$ 表示当前情况下，链的深度为 $i$ 的点可能取哪些点。

## $x=0,y=1$

考虑钦定一个点 $u\in S_i$，在第 $i$ 层“保留”点 $u$，该种情况下的最小花费。

因为除了 $u$ 以外的点都需要至少合并到另一个点上，所以 $\forall v\in S_i,v\ne u$，都需要付出 $w[v]$ 的花费。

因为未保留的点在下面层的合并中还要付出花费，所以在当前层中一定是保留一个权值最大的点。

使用堆维护 $S_i$ 以及当前堆中元素的 $w$ 的和即可。因为每个元素至多进堆一次出堆一次，所以复杂度为 $O(n\log n)$。

## $x=1,y=1$

同样考虑钦定一个点 $u\in S_i$，在第 $i$ 层“保留”点 $u$，该种情况下的最小花费。

因为 $\mathrm{op(p,q)}$ 的花费为 $w[p]+w[q]$，所以 $v\in S_i$ 内的所有点贡献都可以写成 $(pt[v]+qt[v])\times w[v]$，其中 $qt[v]$ 表示操作 $\mathrm{op(p,v)}$ 发生的次数，$pt[v]$ 表示操作 $\mathrm{op(v,q)}$ 发生的次数。并且不难发现 $\forall v\in S_i,v\ne u$，$qt[v]=1$，$qt[u]=0$。

而 $\sum_{v\in S_i} pt[v]=|S_i|-1$，因此应该让 $\min_{v\in S_i}(w[v])$ 参与尽量多的合并。

那么不难得到在确定 $u$ 情况下的贪心策略：先将除了 $u$ 外的所有点 $v$ 向 $w$ 最小的点 $p$ 合并，最后再将 $p$ 与 $u$ 合并。

因为对于未保留的点还会在后面参与合并，因此当前层一定是保留 $w$ 最大的点最优。

使用数据结构维护这个过程复杂度同样是 $O(n\log n)$。

## $x=1,y=0$

考虑钦定一个点 $u\in S_i$，在第 $i$ 层“保留”点 $u$，该种情况下的最小花费。

不难发现，和 $x=1,y=1$ 类似一定是先都合并到权值最小的点再合并到 $u$。 

即如果 $|S_i|\ge 2$，花费为 $\min_{v\in S_i}(w[v])\times (|S_i|-2)+w[u]$。

> key Observation：无论每一层留下的点是谁，$|S_i|$ 是不变的。即 $|S_i|$ 是可以唯一确定的。

并且实际上本题可以看成点与层的匹配，即每层保留哪个点，在第 $i$ 层的点可以与 $\ge i$ 的层匹配。

而对于一种已经确定的匹配方案，$\min_{v\in S_i}(w[v])$ 即 $\le i$ 层的点中所有匹配的层 $\ge i$ 的点的最小点权。而 $|S_i|$ 可以在 $O(n)$ 的时间内预处理出来。

考虑一种理想情况：$\forall i,|S_i|\ge 2$（实际上这种情况一定不存在，因为一定有 $|S_n|=1$）。

令 $val[i]=|S_i|$。

令 $match[i]$ 表示匹配到第 $i$ 层的点，$d[i]$ 表示点 $i$ 的深度，这样任意一种匹配的方案的花费可以写成：

$$
\sum_{i=1}^nw[match[i]]+\min_{j\ge i,d[match[j]]\le i}(w[match[j]])\times \max(0,val[i]-2)
$$

等价于：

$$
\sum_{i=1}^nw[i]+\sum_{i=1}^nmin_{j\ge i,d[match[j]]\le i}(w[match[j]])\times \max(0,val[i]-2)
$$

那么我们只需要最小化：

$$
\sum_{i=1}^nmin_{j\ge i,d[match[j]]\le i}(w[match[j]])\times \max(0,val[i]-2)
$$

而这样，我们并不在意每一层谁留下，我们更在意每一层谁“下去了”，更具体而言我们只在意当前层的最小值是否“下去了”，不难发现对于一个取到最小值的点在遇到比该点权值更小的点之前留在某一层一定不优，并且根据单调栈相关理论不难发现其为前缀最小值的结构。

因为 $\forall i,val[i]\ge 2$，所以 $min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 一定能够取到 $\min\limits_{d[j]\le i}(w[j])$（即每次将除了取到当前的前缀最小值以外的点留下）。

接下来考虑一种比较棘手的情况：存在 $val[i]=1$，如何处理？

但是实际上可以发现除了 $val[n]=1$ 以外，$val[i]=1$ 的位置一定是一段（可能非空的）前缀。 

这是怎么回事呢？令 $G_i$ 表示 $S_i$ 中所有点儿子构成的集合，不难发现 $|S_{i+1}|=|S_i|-1+|G_i|$。因此如果 $|G_i|\not=0$，一定有 $|S_{i+1}|\ge |S_i|$，并且如果存在 $|G_i|=0$，那么 $\forall j\ge i,|G_j|=0$。

因此 $val$ 整体上一定是如下的结构：先非严格单调递增，后严格单调递减。

考虑严格单调递增的部分，满足 $val[i]=1$ 的位置一定是一段前缀，而严格单调递减的部分有且仅有 $val[n]=1$。

并且对于一段 $val[i]=1$ 的前缀，我们是并不用考虑的，因为匹配这段深度的点一定是唯一确定的。

（下面的讨论中将该段前缀扔掉）

因此实际上，至多有一个点匹配会匹配 $val[i]=1$ 的点。

考虑枚举匹配深度为 $n$ 的点 $u$，不难发现如果 $\forall i\ge d[u],val[i]>2$，那么 $\forall i,min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 一定还能够取到前缀最小值。

而实际上因为本题 $val$ 的结构，$val[i]=2$ 的深度 $i$ 也一定是连续的一段前缀（因为已经将为 $val[i]=1$ 的一段前缀扔掉了），并上深度 $n-1$。

而 $val[n-1]$ 实际上并不用考虑，因为其并不会产生任何贡献。

考虑找到一个 $lim$，使得 $\forall lim<i<n-1$，满足 $val[i]\not=2$。

如果 $d[u]>lim$，那么 $\forall i,min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 一定还能够取到前缀最小值。

如果 $d[u]\le lim$，因为 $\forall i\le lim$，的深度 $i$ 不会产生贡献，所以这里只需要考虑对 $i>lim$ 的深度 $i$ 产生的贡献。

并且实际上只有 $u$ 一个点满足 $d[u]\le 2$，且 $u$ 匹配的深度 $>lim$。

$\forall i>lim$，$min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 能够取到从 $lim+1$ 的最小值 / $w[u]$。

因为前缀最小值具有单调性，所以这里考虑二分出最大的取 $w[u]$ 的前缀即可。

复杂度 $O(n\log n)$。

[代码链接](https://www.luogu.com.cn/paste/lq4cwln3)

 

---

## 作者：feecle6418 (赞：3)

考虑建出括号树，一个点的权值为对应左括号的权值，则操作等价于

- 交换两个儿子，代价 $0$。
- 把这层两个儿子（权值分别为$V_1,V_2$）合并（新的代价 $V_1$），在下一层新加一个儿子（新的代价 $V_2$），代价 $xV_1+yV_2$。

$x=0,y=1$，$x=1,y=1$ 是 trivial 的，直接贪心把小的儿子加到下一层，最后这一层留下最大的。容易调整法证明不劣。

$x=1,y=0$ 可能会出现这种情况：因为在下一层加的儿子自己没贡献，所以我要把一个权值很大的一直往下传，导致这个一直没贡献，使得答案更优。

显然，如果要往下传，肯定是传后缀权值最大值（“后缀”是对于括号树上深度而言的）。如果直接枚举传哪个，可以得到 $O(n^2\log n)$ 的 64 分算法。

现在考虑快速计算，如果我传第 $i$ 层的后缀权值最大值，答案的变化量。设为 $dlt_i$。

考虑这样的操作对答案的影响（在哪些层，答案会不一样）。it turns out that 只有两种影响。

- 假设传第 $i$ 层的权值最大值，那么第 $i$ 层的代价变化量会是 权值次大值 - 权值最大值。如果权值次大值在本来第 $j$ 层作为最大值被删了，那第 $j$ 层也会有 权值次大值 - 权值最大值 的变化量。如果第 $j$ 层的权值次大值在本来第 $k$ 层作为最大值被删了，以此类推。所以，如果按照 次大值在何时被删 建出一棵树，那么这个部分的答案变化量是链上 次大值 - 最大值 的后缀和。
- 还有一种特殊情况。如果第 $i$ 层原本只有两个数 $mn,mx$，那你现在就会把 $mn$ 删掉。如果 $mn$ 在后面一段本来还是要造成贡献的最小值，后面这一段新的贡献就会是 次小值，而不是最小值了。容易发现只要出现了这种情况，这（出现 只有两个数的）地方会是之前所有地方的祖先。所以做一点小改动。如果第 $i$ 层原本只有两个数，那么在链上做后缀和的贡献就不仅是 次大值 - 最大值，还要加上 **后面一段 $i$ 的最小值还是最小值** 的 $(sz-2)\times$ (次小值 - 最小值)。

$O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pr;
int n,X,Y,v[500005],tot,st[500005],top,dep[500005],mxv[500005],issufmx[500005];
int mnid[500005],del[500005],to[500005],is2[500005];
char a[1000005];
ll ans=0,sum=0,dlt[500005],mndlt[500005];
vector<int> g[500005],ind[500005];
multiset<pr> s;
int main(){
	scanf("%d%d%d%s",&n,&X,&Y,a+1);
	for(int i=1;i<=2*n;i++){
		if(a[i]=='('){
			g[st[top]].push_back(++tot),dep[tot]=dep[st[top]]+1;
			st[++top]=tot;
			scanf("%d",&v[tot]);
			ind[dep[tot]].push_back(tot);
			mxv[dep[tot]]=max(mxv[dep[tot]],v[tot]); 
		}
		else top--;
	}
	for(int i=n;i>=1;i--){
		if(mxv[i+1]>=mxv[i])mxv[i]=mxv[i+1];
		else issufmx[i]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j:ind[i])s.insert(pr(v[j],j)),sum+=v[j];
		ans+=Y*(sum-(*--s.end()).first);
		ans+=X*(1ll*(s.size()-2)*(*s.begin()).first+(*--s.end()).first);
		if(s.size()>1){
			dlt[i]=(*--(--s.end())).first-(*--s.end()).first;
			to[i]=(*--(--s.end())).second;
			mndlt[i]=1ll*(s.size()-2)*((*++s.begin()).first-(*s.begin()).first);
		}
		mnid[i]=(*s.begin()).second;
		if(s.size()==2)is2[i]=1;
		auto mx=*--s.end();
		s.erase(s.find(mx)),sum-=mx.first,del[mx.second]=i;
	}
	for(int i=n;i;i--){
		dlt[i]+=dlt[del[to[i]]];
		if(mnid[i]==mnid[i+1]){
			mndlt[i]+=mndlt[i+1];
			if(is2[i])dlt[i]+=mndlt[i+1];
		}
	}
	if(X==1&&Y==0){
		ll o=ans;
		for(int P=1;P<=n;P++){
			if(!issufmx[P])continue;
			ans=min(ans,o+dlt[P]);
		}
	}
	cout<<ans;
}
```



---

## 作者：WeLikeStudying (赞：3)

- 对自身的问题有了更新的体会。
- 力量生发在沉寂内。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P8293)。
- 给一个括号序列（左括号带权），有两个操作可以干：交换两个合法括号序列，不需要代价；把两个相邻的左右括号权值交换，代价是它左边的极长合法括号序列的极左左括号乘 $x$ 加它右边的极长合法括号序列的极右右括号乘 $y$，而 $x,y\in\{0,1\}$，给定括号序列要求变成“前面是 $n$ 个左括号，后面是 $n$ 个右括号”的最小代价。

**分析**
- 既然只有 $2\times 2=4$ 种情况，那么我们就一个一个想！
- $x=0,y=0$ 答案为 $0$ ~~出题人大概率不会给这个部分分~~。
- 接下来的情况要求我们简化模型。什么模型比较好简化呢？我们想到了[这题](https://www.luogu.com.cn/problem/P8077)。似乎可以尝试把括号看成树的欧拉序，然后就转化为树上操作啦。
- 操作 $1$ 相当于任意交换一个节点的所有子树。
- 操作 $2$ 相当于将一个节点和它的所有儿子归到它兄弟的儿子上，代价与这个有关系。
- 操作的目标即得到一条链。

**x=0,y=1**
- 容易发现几个简单的性质：单调性：每个节点的深度不降，简单性：每次只会改变一个节点的深度。
- 直观上看 $x=0,y=1$ 最简单，因为最终的答案只与每个节点的深度有关，算出每个点的深度，现在目标就变成了给定一个排列 $p_i$，满足 $p_i\ge d_i$，且最小化 $\sum w_i\cdot (p_i-d_i)$，实质是最小化 $\sum w_i\cdot p_i$。
- 它或许不那么形象（换成树的模型或许形象很多），但是如果从大到小枚举 $p_i$，目前会挑选哪个在 $p_i$ 层呢？一定是 $w_i$ 最小的吧，但是有一个前提条件，那就是前 $i$ 层必须保留超过 $i$ 个节点，我们当然是贪心地把 目前 $w_i$ 最大的保留，这就是一个简单的 $O(n\log n)$ 贪心算法（让小儿子出远门），[代码](https://www.luogu.com.cn/paste/wk55ct9p)。
- 接下来或许就不那么简单了，但是我们或许可以对算法作一个有趣的猜测：说不定就全是贪心呢？

**x=1,y=0**
- 首先可以确定的是：我们完全可以维持一个循环不变的状态，即由上往下地推之后，所有其它节点都是某个节点的儿子（这样总是更有利于我们做出决策的，而且后面可以看到，这种情况下，所有可能的更优解也都循环回这样的情况），如果我们给出一个最终节点排列（首先它得合法）并宣称它是最优情况，那么我们可以贪心地算出最优转移（如果这层滞留 $n$ 个节点，$n-2$ 个以权值最小的一个转移到下一层，$1$ 个以留在这里的权值转移到下一层），枚举所有排列，我们有一个相当简洁的 $O(n!\cdot n\log n)$ 的做法~~但好像没啥用~~。
- 我们这个时候试下考虑 $x=1,y=0$ 的情况吧，不论如何，我们可以量化它，计算出第 $i$ 层有 $c_i$ 个节点要向下到达第 $i+1$ 层（$c_n=0$），不论怎么排列这个总是不变的。
- 你会发现有一些 $c_i$ 为 $0$（作者曾经一度以为只有 $c_n=0$，然后发现 $(((())))$ 这样的序列就可以打我的；脸），而有一些 $c_i$ 非 $0$，而放在大于 $0$ 的位置的转移贡献至少为 $1$，其它的贡献都可以由最小的那个数字承担，所以应该贪心地把 $c_i=0$ 的位置由较大的数去填充。
- 当然，哪些较大的数字应该可以到达这里（首先应该得合法），所以我们把这整个序列划分为多个只有末尾 $c_i=0$ 的连续段内部分别处理（显然连续段之间的元素无法互换），贪心的策略仍然是把 $c_i=0$ 交给最大的数，滑动的时候优先以当前最小的数为梯子，复杂度 $O(n\log n)$，[代码](https://www.luogu.com.cn/paste/k0yvfh71)。
- 你手工模拟发现并不对劲，在一棵树上实际操作的时候你需要实现两个目标，而两者可能不能兼得：比如说下面这棵树：
![](https://cdn.luogu.com.cn/upload/image_hosting/64tgn7dj.png)
- 作者目前唯一的想法就是暴力处理这种情况，因为只需要节点凑齐 $3$ 个就不会出现这种情况，那么除了第一段是二叉那么后面必须要是单链，所以只剩下两种情况：
- 延伸出两条单链：这个只需要作一次决策就可以打破僵局，分类讨论即可，不过可以归纳到后面的情况处理。
- 延伸出一条单链和一个节点，可以利用如果滑动当前后缀最大值就一定要滑动到底部（否则没有效果）的性质优化到 $O(n^2)$，对于较小值的滑动，我们发现一个简单的事实，就是此时 $c_i=1$ 恒成立，所以它不滑动到最底部（存在反复被其它最小值替换的可能，但那个显然不会作为答案）也是没有办法“服务他人”的，所以最后，我们的结论是：到了真正要做出抉择的时刻（后缀最大值出现，旁边有一个更小的值的时候），你选择一条路就只能把它走到黑……所以最终得到了靠谱的做法，[代码](https://www.luogu.com.cn/paste/cb8lz9il)。

**x=1,y=1**
- 感觉要考虑两方面欸，好复杂的样子……虽然枚举所有排列依旧可以贪心……
- 然后你发现转移依靠当前最小值和后缀和，它们都要求尽量让小的放在后面，也就是模拟第一种情况的贪心即可，[代码](https://www.luogu.com.cn/paste/ua08xx28)。
- 后悔了，应该先想这一个的。

**总结**
- 回顾整个思考的过程，感觉三个贪心都是有迹可循的，首先对于整个复杂的模型，你首先得找到一个思路将其简化，然后你要把它具体化，量化，比如说枚举一个排列然后找到它转移依靠什么，这一步之后，你可能会发现它是贪心，也可能找到了别的算法。
- 然后就是检验准确性，结合实际模型判断你的贪心在实际上是能否做出的（比如可能不能同时让两个较优的条件满足）来完善你的贪心，这是细节上的问题，它在考试的时候还是有一定难度的，因为出题人给的数据非常良心。
- 总地来说，帮助很大。

---

## 作者：gala_xk (赞：2)

# 题意转化

读完题，或许你会发现，只有左括号有权值。也就是说，右括号的位置与答案无关。

等等？那不就可以建一棵括号树了吗？

具体地，我们以左括号为节点，括号的包含关系为节点的父子关系，建立一棵树。

如括号序列 `()(()())` 可以表示为：

![](https://cdn.luogu.com.cn/upload/image_hosting/i21efo8k.png)

那么，最终答案序列（形如 `(((())))`）的括号树就是一条链。

如何处理操作呢？

对于操作 $1$，我们可以理解为，可以任意交换该括号树的两个子树。

而操作 $2$，我们可以简单地模拟一下：

就以序列 `()(()())` 为例，我们交换第一个反括号与第二个括号得到 `(()()())`，用括号树表示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/g4mjrvgo.png)

对比前图，我们发现这次操作：

- 操作前节点 $1$ 与节点 $2$ 父亲相同。

- 将节点 $2$ 变为节点 $1$ 的子节点。

- 将节点 $2$ 的子节点变为节点 $1$ 的子节点。

于是，我们可以将操作 $2$ 理解为将 $p$ 与其所有儿子节点的父亲设为与 $p$ 父亲相同的 $q$，花费为 $x \cdot val_q + y \cdot val_p$。

# 解题

我们通过观察发现 $0 \le x,y \le 1$，将其作为本题突破口，分四类讨论。

## 第一种情况：$x = 0,y = 0$

你在想什么？答案为 $0$ 啊！

不过这题似乎没有这类数据。

## 第二种情况：$x = 0,y = 1$

我们观察到这个特殊性质部分分。

这时我们只会花费变成儿子的节点的费用，不难想到一种贪心策略：每次把花费最高的节点留下，剩下的较小节点推到下一层。因为花费最高的继续往下也只会消耗费用，不会减少费用。

## 第三种情况：$x = 1,y = 1$

当 $x=1$ 时，不难想到贪心策略：把其他值都与最小值合并，再将最小值与需要留在该层的值合并。

将点 $p$ 留在该深度，会对总费用产生 $val_p$ 的贡献（因为我们可以把所有子节点和 $val$最小子节点合并）；将点 $p$ 往下推，则会对总费用产生 $(k+1)\cdot val_p$ 的贡献，其中 $k$ 为下推次数且 $k\ge 1$。此时，我们会发现，我们将最大的节点留下可以使其对答案的贡献最小，从而最小化总答案。

## 第四种情况：$x = 1,y = 0$

我们发现，留下最大值并不是最优解。

为什么呢？因为一个值对答案有影响，当且仅当该值为最小值或最大值。

设最小 $val$ 为 $mn$，最大 $val$ 为 $mx$，当前层有 $k$ 个节点，则当前层对答案的贡献为 $(k-2)\cdot mn+mx$。

我们分 $3$ 种情况：

- 当 $k \le 1$ 时，不需要执行操作。

- 当 $k = 2$ 时，最小值和最大值都有可能成为最优解。我们把两种都枚举一边就好了。注意到最多只可能在开头与结尾两处遇到这种情况，枚举量仅为 $4$。注意，开头可能有一段连续的 $k=2$，要取所有数的最值。

- 当 $k \ge 3$ 时，我们改变最小值和最大值都有可能使答案更劣，于是我们取非最小值和最大值的任意数即可，这样不会对答案产生影响。我取的是次大值。

至于以上四种情况如何维护最值，我使用优先队列。其他题解似乎有不带 $\log$ 的做法，可是我太菜了，没看懂。

## 代码
```cpp
#include <bits/stdc++.h>
#define int ll
using namespace std;
typedef long long ll;
ll n,x,y,c[800005],st[800005],tp;
priority_queue<ll> que;
queue<int>q;
vector<int>ed[800005];
string s;
ll work(int star,int venti){
	while(!q.empty()){
		q.pop();
	}
	while(!que.empty()){
		que.pop();
	}
	ll ans=0,sum=0;
	q.push(0);
	for(ll i=1,j=0,kk=0,lkk=0,css=0x3f3f3f3f3f3f3f;i<n;i++){
		if(!q.empty()){
			int p=q.size();
			for(int j=0;j<p;j++){
				int u=q.front();q.pop();
				for(int k=0;k<ed[u].size();k++){
					int v=ed[u][k];
					q.push(v);
					que.push(c[v]);kk++;
					css=min(css,c[v]);
					sum+=c[v];
				}
			}
		}
		if(que.size()==1){
			sum-=que.top();
			que.pop();kk--;
			css=0x3f3f3f3f3f3f3f;
		}
		else if(que.size()==2&&lkk<=que.size()){
			if(star){
				int p=que.top();
				que.pop();kk--;
				sum-=p;
				ans+=p;
			}
			else{
				ll qx=que.top();
				que.pop();
				ll p=que.top();
				que.pop();
//				printf("%lld %lld\n",qx,p);
				que.push(qx);
				kk--;
				sum-=p;
				ans+=p;
				
			}
				css=que.top();
		}
		else if(que.size()==2){
			if(venti){
				ll p=que.top();
				que.pop();kk--;
				sum-=p;
				ans+=p;
			}
			else{
				ll qx=que.top();
				que.pop();
				ll p=que.top();
				que.pop();
				que.push(qx);
				kk--;
				sum-=p;
				ans+=p;
				
			}
				css=que.top();
		}
		else{
			ll qx=que.top();
			que.pop();
			ll p=que.top();
			que.pop();
			que.push(qx);
			kk--;
			sum-=p;
				ans+=css*(que.size()-1)+p;
		}
//		printf("%d %d\n",css,lkk);
		lkk=que.size()+1;
	}
//	printf("\n%lld",ans);
//	puts(" ");
	return ans;
}
signed main(){
	cin>>n>>x>>y>>s;
	for(int i=0,ca=0;i<2*n;i++){
		if(s[i]=='('){
//			if(tp)
			ca++;
			ed[st[tp-1]].push_back(ca);
//			printf("%d->%d\n",st[tp-1],c);
			st[tp++]=ca;
		}
		else tp--;
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&c[i]);
	}
	if(x==0&&y==0){
		puts("0");
	}
	if(y==1){
		ll ans=0,sum=0;
		q.push(0);
		for(ll i=1,j=0,kk=0,css=0x3f3f3f3f3f3f3f;i<n;i++){
			if(!q.empty()){
				int p=q.size();
				for(int j=0;j<p;j++){
					int u=q.front();q.pop();
					for(int k=0;k<ed[u].size();k++){
						int v=ed[u][k];
						q.push(v);
						que.push(c[v]);kk++;
						css=min(css,c[v]);
						sum+=c[v];
					}
				}
			}
			if(que.size()==1){
				sum-=que.top();
				que.pop();kk--;
				css=0x3f3f3f3f3f3f3f;
			}
			else{
				int p=que.top();
				que.pop();kk--;
				sum-=p;
				ans+=y*sum+x*(css*(kk-1)+p);
			}
		}
		cout<<ans<<endl;
	}
	if(x==1&&y==0){
		ll ans=min(min(min(work(0,0),work(0,1)),work(1,1)),work(1,0));
//		ll ans=min(work(1,0),work(0,0));
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Leasier (赞：1)

显然分 $x, y$ 的值讨论。

1. $x = y = 0$

显然为 $0$。

2. $x = 0, y = 1$

手玩会发现“不包含你不喜欢的结构的括号序列”一定是 `((...()...))` 的形式。

看到括号，考虑将其转化为括号树，则：

- 操作一等效于对于相邻的儿子 $A, B$，把 $B$ 的所有儿子挂到 $A$ 下面，再把 $B$ 作为 $A$ 的一个叶子。代价为 $x a_A + y a_B$。
- 操作二等效于交换儿子 $A, B$ 的顺序。代价为 $0$。
- 目标是一条链。

于是我们可以发现操作二的免费意味着我们可以随便选择两个儿子进行操作。

贪心地，在深度相同的每一层留下最大值，把剩下的下传即可。

3. $x = y = 1$

同上贪心即可。不过每层的贡献有所变化。

4. $x = 1, y = 0$

设当前一层有 $cnt$ 个，最小值为 $\min$，准备留下 $x$。

则对于不留下的非 $\min$ 者，若此时 $x$ 还未离开，贪心地，我们与 $\min$ 配对。

- 当 $\min = x$，贡献为 $\min(cnt - 1)$。
- 当 $\min \neq x$，贡献为 $\min(cnt - 2) + x$。

综合一下这两个式子得到 $\min(cnt - 2) + x$。

但此时延续上面的贪心策略是显然错误的——虽然说把 $\min$ 下放可能会让前半部分更优，但是把 $\max$ 下放直到叶子结点可能会让它不计入贡献，进而同样更优。

于是我们可以得出如下策略：**如果可能的话，把 $\min, \max$ 都下放**。

进而我们可以这样做：

- 若到当前这一层时只有 $1$ 个元素，则不产生新贡献。
- 若到当前这一层时有 $> 2$ 个元素，则我们随便留下一个不是 $\min, \max$ 的数，下放剩下的元素。
- 若到当前这一层时只有 $2$ 个元素……？

这个情况看上去不是很好做，但是注意到到每一层时的元素个数一定是**单峰**的，且最后一定是每次减一直到 $0$（比如 $[1, 1, 2, 2, 3, 4, 4, 4, 5, 4, 3, 2, 1]$），则我们需要注意的其实只有前面那一坨连续的 $2$（比如前面的 $[2, 2]$）。

假如我们选择了 $x$ 从这个连续段下放，则这段的贡献为其和减去 $x$。

贪心地，由于我们期望下传 $\min$ 或 $\max$，则人类智慧地，想到这里下放的 $x$ **要么是 $\min$，要么是 $\max$**。于是枚举到底是哪个再分别跑一遍去最大值即可。

综上，时间复杂度为 $O(n \log n)$。

代码：
```cpp
#include <iostream>
#include <set>
#include <queue>
#include <vector>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt = 0;
int a[400007], pos[800007], nxt[400007], sum[800007], fa[400007], head[400007], depth[400007];
char s[800007];
Edge edge[400007];
priority_queue<int> q;
multiset<int> se;
vector<int> v[400007];

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void build(int l, int r){
	for (int i = l + 1; i <= r; i = nxt[i] + 1){
		fa[i] = l;
		add_edge(l, i);
		build(i, min(nxt[i], r));
	}
}

void dfs(int u){
	depth[u] = depth[fa[u]] + 1;
	for (int i = head[u]; i != 0; i = edge[i].nxt){
		dfs(edge[i].end);
	}
}

inline ll solve01(int n){
	ll sum = 0, ans = 0;
	for (int i = 1; i < n; i++){
		int size = v[i].size();
		for (int j = 0; j < size; j++){
			sum += a[v[i][j]];
			q.push(a[v[i][j]]);
		}
		sum -= q.top();
		q.pop();
		ans += sum;
	}
	while (q.size() > 1){
		sum -= q.top();
		q.pop();
		ans += sum;
	}
	return ans;
}

inline ll solve10(int n){
	int step = 0, i = 1;
	ll sum = 0;
	for (; i < n; i++){
		int size = v[i].size();
		if (se.empty() && size == 1) continue;
		if (se.size() + size > ++step + 1) break;
		for (int j = 0; j < size; j++){
			sum += a[v[i][j]];
			se.insert(a[v[i][j]]);
		}
	}
	if (se.empty()) return 0;
	int min_val = *se.begin(), max_val = *(--se.end());
	ll ans1 = sum - min_val, ans2 = sum - max_val;
	multiset<int> s1, s2;
	s1.insert(min_val);
	for (int j = i; j < n && !s1.empty(); j++){
		int size = v[j].size();
		multiset<int>::iterator it;
		for (int k = 0; k < size; k++){
			s1.insert(a[v[j][k]]);
		}
		it = --(--s1.end());
		ans1 += *it + (ll)*s1.begin() * (s1.size() - 2);
		s1.erase(it);
	}
	while (s1.size() > 1){
		multiset<int>::iterator it = --(--s1.end());
		ans1 += *it + (ll)*s1.begin() * (s1.size() - 2);
		s1.erase(it);
	}
	s2.insert(max_val);
	for (int j = i; j < n && !s2.empty(); j++){
		int size = v[j].size();
		multiset<int>::iterator it;
		for (int k = 0; k < size; k++){
			s2.insert(a[v[j][k]]);
		}
		it = --(--s2.end());
		ans2 += *it + (ll)*s2.begin() * (s2.size() - 2);
		s2.erase(it);
	}
	while (s2.size() > 1){
		multiset<int>::iterator it = --(--s2.end());
		ans2 += *it + (ll)*s2.begin() * (s2.size() - 2);
		s2.erase(it);
	}
	return min(ans1, ans2);
}

inline ll solve11(int n){
	ll sum = 0, ans = 0;
	for (int i = 1; i < n; i++){
		int size = v[i].size();
		multiset<int>::iterator it;
		for (int j = 0; j < size; j++){
			sum += a[v[i][j]];
			se.insert(a[v[i][j]]);
		}
		ans += sum + (ll)*se.begin() * (se.size() - 2);
		it = --se.end();
		sum -= *it;
		se.erase(it);
	}
	while (se.size() > 1){
		multiset<int>::iterator it = se.begin();
		sum -= *it;
		ans += sum + *it * (se.size() - 1);
		se.erase(--se.end());
		ans += sum;
	}
	return ans;
}

int main(){
	int n, x, y;
	scanf("%d %d %d", &n, &x, &y);
	if (x == 0 && y == 0){
		cout << 0;
		return 0;
	}
	int m = ++n * 2;
	scanf("%s", &s[2]);
	s[1] = '(';
	s[m] = ')';
	for (int i = 2; i <= n; i++){
		scanf("%d", &a[i]);
	}
	for (int i = 1, j = 0; i <= m; i++){
		if (s[i] == '(') pos[i] = ++j;
	}
	for (int i = 1; i <= m; i++){
		if (s[i] == '('){
			sum[i] = sum[i - 1] + 1;
			v[sum[i]].push_back(i);
		} else {
			sum[i] = sum[i - 1] - 1;
		}
	}
	for (int i = 1; i <= n; i++){
		int size = v[i].size();
		if (size > 0){
			for (int j = 0; j + 1 < size; j++){
				nxt[pos[v[i][j]]] = pos[v[i][j + 1]] - 1;
			}
			nxt[pos[v[i][size - 1]]] = n;
		}
	}
	build(1, n);
	dfs(1);
	for (int i = 1; i < n; i++){
		v[i].clear();
	}
	for (int i = 1; i <= n; i++){
		v[depth[i]].push_back(i);
	}
	if (x == 0 && y == 1){
		cout << solve01(n);
	} else if (x == 1 && y == 0){
		cout << solve10(n);
	} else {
		cout << solve11(n);
	}
	return 0;
}
```

---

## 作者：vectorwyx (赞：1)

先在串左边加一个 `(` 右边加一个 `)`，这样是为了方便建树。根结点代表整个串，权值为 $0$，然后递归建树：对于结点 $x$，剥去它左右端点的 `()`，剩下的部分可以被分为若干个 `(A)` 的拼接，对于每个 `(A)` 新建一个结点，权值为对应 `(` 的权值，并把 $x$ 向它连边。

那么操作就变成了：交换两个兄弟；花费 $x a_i+ya_j$ 的代价把 $i,j$ 这两个兄弟结点合并，合并是指把 $j$ 的所有儿子接到 $i$ 上，然后把 $j$ 摘下来作为叶结点也接到 $i$ 上，点权不变。由于交换是免费的，所以可以随意钦定两个兄弟结点以及它们合并的顺序。我们的目标是以最小的代价使得整棵树变成一条长为 $n+1$ 的链。而这个合并也可以拓展到多个兄弟结点，代价先不提，合并出来的结果是一样的：这些兄弟结点的儿子都接到某个结点上，然后这个结点还会多出 $cnt-1$ 个叶子。

那么首先可以通过调整使得操作序列按照深度依次进行。即我们总可以先合并第一层，使得整棵树变成根结点下面单接一棵子树，然后削掉根结点递归往下做。注意这同时表明操作次数是平方级别的，所以还要注意一下复杂度的问题。

$x=0,y=0$：不用多说。

$x=0,y=1$：相当于每次合并会把右边的结点丢下去，代价为该结点的权值。那么对于每一层只需要贪心地把较小的那些丢下去，代价为 $\sum -\max$。维护 $\sum$，用堆维护最大值即可获取每一层的信息。

$x=1,y=1$：此时代价与左右顺序无关。类似一个最小生成树的模型，只需要把最小值拿出来依次和其他点合并，当合并到最大值时换一下，让最大值留下自己掉下去。所以代价为 $\sum+(cnt-2)\min$，维护 $\sum,cnt,\min,\max$ 即可（同样需要一个堆）。

重头戏在于 $x=1,y=0$。首先对于每一层我们考虑留下来谁，如果留下来了 $x$ 那么这一层的最小代价是 $x+(cnt-2)\min$（这个在 $cnt=1$ 的时候也成立哦，贡献为 $0$），然后把除 $x$ 以外的数都丢下去。注意最后形成的一定是一条链，那么除了最底下的叶结点 $l$ 每个结点都被留在了某一层，于是有 $\sum x=-a_l+\sum a_i$。然后问题就变成了最小化 $-a_l+\sum(cnt-2)\min$。注意到除了最终的叶结点所在层之外，所有 $cnt=1$ 的层一定是一段前缀，我们可以预先把它们砍去，因为它们不会有任何贡献。这能保证 $cnt-2\ge 0$，但是有什么用呢？还有一个观察，$cnt$ 是单峰的。在前半段的斜率在 $[0,\infty)$ 中游动，而后半段一定是一个斜率为 $-1$ 的直线。从后往前考虑，假设每一层的点权序列为 $a$（从小到大排序）。最后一层贡献为 $-a_1$，那么在倒数第二层也就是只有 $2$ 个结点时肯定是选更大的那一个丢下去，由于 $cnt=2$ 所以不会产生额外贡献，此时总代价为 $-a_2$。倒数第三层的话额外贡献为 $a_1$，所以它会把 $a_3$ 丢下去，同时希望 $a_1$ 尽量小，总代价为 $a_1-a_3$。倒数第四层同理，它会响应第三层的希望，先把 $a_1,a_4$ 丢下去，总代价为 $3a_1-a_4$，同时希望 $a_1$ 尽量小……那么直到峰顶，假设是倒数第 $m$ 层，总代价为 $\frac{(m-1)(m-2)}{2}a_1-a_m$。它希望 $a_1$ 尽量小，$a_m$ 尽量大。

那么实际上我们的目标是在从开头到峰顶的过程里最小化 $a_1$，最大化 $a_m$。前面说过 $cnt$ 是单峰的，那如果 $cnt>2$ 是不是直接把最小值和最大值传下去就行？$cnt=2$ 的话一定是一段前缀，长这样：

![](https://s1.imagehub.cc/images/2022/12/14/18aa8ed4d8bb9f84766d432efe87d506.png)

红色框出来的点我们可以自由选择一个传下去。而由刚才的 $(cnt-2)\times\min$ 的分析，这些层是没有贡献的，它对于后续的影响只有最终传了哪个点下去。根据答案的式子，先传一个最小值下去算一下，再传一个最大值下去算一下，两者取个 $\min$ 就是最终答案。

代码如下：

```cpp
#include<bits/stdc++.h>
namespace vectorwyx{
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unorderedmap
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=1e6+5,inf=1e9;
int stk[N],top,n,X,Y,cnt[N],a[N],v[N],num,to[N],dep;
vector<int> g[N];
char s[N];

void init(){
	int id=n;go(i,2*n+1,2) if(s[i]=='(') a[i]=a[id--];
	s[1]='(',s[n*2+2]=')';
	n=2*n+2;a[1]=0;fo(i,2,n) if(s[i]==')') a[i]=0;
	fo(i,1,n){
		if(s[i]=='(') stk[++top]=i;
		else to[i]=stk[top],to[stk[top--]]=i;
	}
}

int L;

namespace Part_10{//X=1,Y=0;
int m;
ll play(int l,int r,int o){
	int mn=o,mx=o;
	if(o<0) mn=inf,mx=0;
	ll ret=0;
	fo(i,l,r){
//		int mn_=mn,mx_=mx;
		for(int j:g[i]) sml(mn,v[j]),big(mx,v[j]);
//		printf("%d:%d,%d\n",i,mn,mx);
		if(i<r) ret+=(cnt[i]-2ll)*mn;
	}
	ret+=(m-2ll)*(m-1ll)/2*mn-mx;
	re ret;
}
void solve(){
	ll sum=0;
	m=num-dep+1;
	//[l,num] 有意义，[dep,num] 递减，[l,dep] 递增，cnt[l,pos]=2;
	int pos=L;while(cnt[pos]==2) pos++;pos--;
	int mn=inf,mx=0;
	fo(i,L,pos) for(int j:g[i]) sml(mn,v[j]),big(mx,v[j]);
	fo(i,L,dep) for(int j:g[i]) sum+=v[j];
//	printf("m=%d L=%d pos=%d dep=%d num=%d mn=%d mx=%d\n",m,L,pos,dep,num,mn,mx);
	if(pos==dep){
		cout<<sum-mx;
		exit(0);
	}
	if(pos>=L) cout<<sum+min(play(pos+1,dep,mn),play(pos+1,dep,mx));
	else cout<<sum+play(pos+1,dep,-1);
	exit(0);
}
}

namespace Part_1{//Y=1;
int mx[N],mx2[N],a[N];
priority_queue<int> q;
void solve(){
	ll sum=0,ans=0;
	int mn=inf;
	fo(i,L,num){
		for(int j:g[i]) q.push(v[j]),sml(mn,v[j]),sum+=v[j];
		if(X) ans+=(cnt[i]-2ll)*mn+sum;
		else ans+=sum-q.top();
		sum-=q.top();q.pop();
	}
	cout<<ans;
}
}

void build(int l,int r,int d){
	g[d].eb(++num);v[num]=a[l];
	big(dep,d);
//	printf("build(%d,%d,%d) num=%d val=%d\n",l,r,d,num,v[num]);
	if(l+1==r) re;
	int x=l+1;
	while(x<r){
		build(x,to[x],d+1);
		x=to[x]+1;
	}
}

signed main(){
//	freopen("bracket3.in","r",stdin);freopen(".out","w",stdout);
	cin>>n>>X>>Y;
	scanf("%s",s+2);
	fo(i,1,n) a[i]=read();
	init();
	if(X==0&&Y==0) re cout<<0,0;
	build(1,n,1);
	assert(num==n/2);
	cnt[1]=1;
	fo(i,2,num) cnt[i]=cnt[i-1]-1+(int)g[i].size();
	L=1;while(cnt[L]==1) L++;
	if(L>num) re cout<<0,0;
//	cout<<"cnt:";out(cnt,1,num);
	if(X==1&&Y==0) re Part_10::solve(),0;
	re Part_1::solve(),0;
	return 0;
}
}
/*
5 1 0
(((())))()
1 1 4 5 1
-------------------------------------------------
*/










signed main(){re vectorwyx::main();}
```



---

## 作者：SalN (赞：0)

P8293

这个直接做括号感觉不太可行，这种走投无路启发我们把这个转成树上问题，就是把括号序列当成 dfn 序，匹配的一对括号对应一个节点的入和出。

```cpp
up(i,1,2*n) {
	if(str[i]=='(') stk[++top]=i;
	else pos[stk[top--]]=i;
}
up(i,1,n) cin >> Val[i];
up(i,1,2*n) if(str[i]=='(') val[i]=Val[++tot];
dfs(1,2*n,1);

void dfs(int l,int r,int dep) {
	for(int x=l; x<=r; x=pos[x]+1) {
		dfs(x+1,pos[x]-1,dep+1);
		lkx[dep].pb(val[x]);
	}
}
```

因为 $\text{AB}$ 都是合法序列也就是完整子树，不喜欢的结构 $\text{(A)(B)}$ 其实就是要求不能有一个点有两个儿子，那么就是想要一条链。操作二就是子树儿子顺序随意，操作一在结合了操作二的情况下就是选择一个点的儿子 $u,v$，把 $v$ 的儿子树和 $v$ 分别接在 $u$ 的儿子处。这个操作一定调高了 $v$ 的深度，所以深度从小到大调整一定是不劣的，否则一定可以找到符合的方式替代，假设你在中间部分做了一次操作，你把深度比这个小的操作先做一下不会影响你做这个的说。

至此完成了题目的初步转换，可以开始分讨了，下文 $siz$ 表示当时层里面的节点数 >w<

+ $x=0,y=0$ 

怎么操作都不会产生代价，直接输出 $0$ 就行了，但是貌似没有这一档的分，要哭了。

```cpp
cout << 0 << '\n';
```

+ $x=0,y=1$

操作移动到下一层的点会贡献一次权，留在本层的点没有贡献，这个显然贪心每次留下最大权的点就行了。可以用  priority_queue/multiset 之类的随便维护一下。

```cpp
up(i,1,n-1) {
	for(int v:lkx[i]) qwq.insert(v), sum+=v;
	auto it=--qwq.end();
	sum-=*it, qwq.erase(it);
	Ans+=sum;
}
cout << Ans << '\n';
```

+ $x=1,y=1$

考虑留下的点为 $x$，权最小的点为 $y$，别的点集是 $\{p\}$，最好代价显然是 $|p|\times V_y+\sum V_{p_i}+V_x+V_y=\sum V_i+(siz-2)\times V_y$，更充分的说明是， $x=y$ 写一下可以发现不优。这个也很好贪心喵，每次留下最大的就行了，还是拿着你那 multiset 维护一下。

```cpp
up(i,1,n-1) {
	for(int v:lkx[i]) qwq.insert(v), sum+=v;
	Ans+=sum+((int)qwq.size()-2)**qwq.begin();
	auto it=--qwq.end(); 
	sum-=*it, qwq.erase(it); 
}
cout << Ans << '\n';
```

+ $x=1,y=0$

还是先分析贡献是什么，类似于上一种情况去算，这部分是 $V_y\times (siz-2)+V_x$，注意到除了链尾的那个点别的点都一定要被当成 $x$ 贡献一次 $V_x$，那么我们希望「下放最小值多蹭一点 $V_y$ 的贡献」以及「下放最大值尝试去蹭最后一个 $V_x$ 的没有贡献 」，如果 $siz>2$ 那肯定两者都无脑下放肯定不劣，如果 $siz=1$ 肯定没有贡献，问题在于怎么处理 $siz=2$ 的情况。

首先，如果 $siz>2$ 了，以后只会有一次 $siz=2$ 的情况。如果下一层有节点，那么 $siz$ 单调不降，否则以后下一层都没有节点，会按照 $siz=siz',siz'-1,\dots,3,2,1$ 这样子变化。在这部分前面如果又碰到 $siz=2$ 因为那个单调不降应该是一串 $siz=1,1,1,\dots,2,2,2$ 这样。 我们去掉不用考虑的前缀 $siz=1$ 的部分，考虑一下 $siz=2,\dots,2,\dots(\geq3),3,2,1$ 这样子的序列怎么贪心。

发现前面一串 $siz=2$ 的贡献是 $点权和-留下点的权值$，只用考虑留下的是这部分的最大值还是最小值就可以了，后面只会碰到一次肯定保留最小值的 $siz=2$ 的贪心。因为如果下面有比这个局部最大值更大的权这个局部的最大值肯定会被抛弃，那么不妨直接考虑留下全局最大值的情况。

```cpp
int l=1, r=1;
while(lkx[l].size()==1) ++l, ++r;
while(lkx[r].size()==2) ++r;
up(i,l,n-1) {
	for(int v:lkx[i]) qwq.insert(v), Ran+=v, sum=max(sum,v);
	Ran+=((int)qwq.size()-2)**qwq.begin();
	if(i==n-1) qwq.erase(qwq.begin());
	else qwq.erase(++qwq.begin());
}
Ran-=*qwq.begin(), qwq.clear();
up(i,l,n-1) {
	for(int v:lkx[i]) qwq.insert(v), Ans+=v;
	Ans+=((int)qwq.size()-2)**qwq.begin();
	if(i==n-1) qwq.erase(qwq.begin());
	else {
		auto it=++qwq.begin();
		if(qwq.size()>2) qwq.erase(it);
		else {
			if(*it==sum) qwq.erase(--it);
			else qwq.erase(it); 
		}
	}
}
Ans-=*qwq.begin();
cout << min(Ran,Ans) << '\n';
```

---


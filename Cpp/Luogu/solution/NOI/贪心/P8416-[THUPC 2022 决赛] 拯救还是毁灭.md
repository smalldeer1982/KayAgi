# [THUPC 2022 决赛] 拯救还是毁灭

## 题目描述

*有人说，它拯救了世界；也有人说，它毁灭了世界。*

这个世界危在旦夕！秩序已然一片混乱。

秩序可以抽象成一个 $n\times n$ 的矩阵，矩阵中是一个 $1\sim n^2$ 的排列。你想要拯救世界，于是请来了神，来帮忙把秩序恢复原状。然而神也不是万能的，它只能做到交换矩阵中同一行或者同一列中的两个数。而且，它并不知道要怎么交换才能复原，得听你的指导。

幸好，你不一定需要在最少的交换次数之内完成复原。你只需要不比最糟糕的情况差就好。也就是说，如果你的交换次数为 $k$，且对于所有 $1\sim n^2$ 的排列，最小交换次数的最大值为 $k_0$，你只需要满足 $k\le k_0$。

注：复原指的是将矩阵变为如下的一个矩阵：

$\begin{matrix} 1 & 2 & 3 & \cdots & n \\ n+1 & n+2 & n+3 & \cdots & 2n \\ 2n+1 & 2n+2 & 2n+3 & \cdots & 3n\\ \vdots & \vdots & \vdots & \ddots & \vdots \\ (n-1)n+1 & (n-1)n+2 & (n-1)n+3 & \cdots & n^2 \end{matrix}$

## 说明/提示

【样例 1 解释】

可以证明这是交换次数最少的方案之一，显然它符合条件。

【样例 2 解释】

对于这个输入来说，这个样例输出的方案不是交换次数最少的方案，但是我们知道存在一个 $1\sim n^2$ 的排列（即上一个样例）需要至少 $3$ 次的交换，所以这个方案也是可行的。

【样例 3 解释】

我们允许出现 $(x_1,y_1)=(x_2,y_2)$ 的情况。

【样例 4 解释】

注意 $k$ 可以等于 $0$。

【数据范围与约定】

保证 $1\le n\le 1000$。

保证输入的矩阵中 $1\sim n^2$ 恰好各出现一次。

## 样例 #1

### 输入

```
2
4 2
3 1
```

### 输出

```
3
1 1 1 2
1 2 2 2
1 1 1 2
```

## 样例 #2

### 输入

```
2
2 1
3 4
```

### 输出

```
3
2 1 2 2
1 1 1 2
2 1 2 2
```

## 样例 #3

### 输入

```
2
3 2
1 4
```

### 输出

```
2
1 1 1 1
1 1 2 1
```

## 样例 #4

### 输入

```
2
1 2
3 4
```

### 输出

```
0
```

# 题解

## 作者：周子衡 (赞：4)

- **题意：** 给定 $n\times n$ 正整数方阵 $A$，保证 $1\sim n^2$ 的每个正整数都在其中出现过。你每次可以交换 $A$ 中同行 / 同列的两个元素。你需要用尽可能少的交换次数将 $A$ 变为另一个方阵 $B$，其中 $B_{i,j}=(i-1)\times n+j$，并构造一组方案。
- 由于本题找到最优解十分困难，你的方案步数只要不超过一定范围即可。具体地，设 $k(C)$ 表示把某个 $n\times n$ 方阵 $C$ 变为 $B$ 的最小步数，记 $k_0$ 为在全部的 $C$ 中，$k(C)$ 的最大值。你只需要构造出一种不超过 $k_0$ 步的方案即可通过。
- $n\leq 1000$。

--------------------------

好题。

我们先来试着确定一下 $k_0$ 的值。很容易观察到 $n^2-1 \leq k_0\leq 2n^2$，也就是说 $k_0$ 和 $n^2$ 是同阶的。到底在 $n^2$ 附近还是 $2n^2$ 附近呢？或者都不是？通过直觉（或者是实验），可以猜想应该在 $2n^2$ 附近。读者可以来试着自己证明一下。


-----------------------------

我们先来说明 $k_0\geq 2(n^2-n)$。

考虑构造两张有向图 $R,C$。对 $A$ 中的每个元素，我们在 $R$ 中从它所在的行向它应该在的行连一条边；在 $C$ 中从它所在的列向它应该在的列连一条边。可以知道，$R$ 和 $C$ 都是欧拉图。对欧拉图 $G$，定义 $\mathrm{cyc}(G)$ 表示能将 $G$ 拆分出的最大环数。可以发现，$\mathrm{cyc}$ 的最小值为 $n$，最大值为 $n^2$，且操作结束时 $R,C$ 的 $\mathrm{cyc}$ 值都会达到 $n^2$；一次操作只会对 $R,C$ 中的某一个有影响，且对有影响的那个图，它的 $\mathrm{cyc}$ 值至多只会变化 $1$。我们只需要说明存在某个 $A$ 使得开始的时候 $R,C$ 的 $\mathrm{cyc}$ 值都只有 $n$，就可以说明 $k_0\geq 2(n^2-n)$。这是简单的：把目标方阵循环下移一格再循环右移一个，得到的方阵就满足条件。

（“最大环数”这个概念在[这里](https://codeforces.com/contest/1672/problem/F1)也有出现过，读者可以比较一下。）

--------------------------

好的，接下来我们将构造地证明：对任意方阵 $A$，都存在 $2(n^2-n)$ 步的复原方式，从而解决本题。

考虑一行一行地复原。首先可以知道：任意时刻我们都可以在 $2$ 步之内把某个元素还原到它应在的位置上。同时，当前 $n-1$ 行都复原时，复原最后一行至多需要 $n-1$ 次操作。计算一下可以发现，只要我们复原除了最后一行的某一行时能少用 $1$ 次操作，我们就解决了这题。

当复原某一行时，我们只看应该出现在这一行的所有元素。对每个该行元素，从它在的列向它应在的列连一条边，形成一张有向图。这个有向图每个点都有一条入边，则必有一个环。找到这个环，设环长为 $c$，我们先用至多 $c$ 次操作把这 $c$ 个点对应的元素都转移到该行上，然后再在行内用 $c-1$ 次操作复原这 $c$ 个元素。剩下的元素每个 $2$ 次复原即可。

关于实现细节：本题要求 $O(n^2)$ 的时间复杂度，可以在操作的同时维护每个元素所在的位置。注意常数。

**后记**

这题题解鸽了挺久的，谢罪 QaQ

以及，代码就鸽掉了 QaQ

---

## 作者：Dream_poetry (赞：3)

唐爷爷好强，拜谢唐爷爷。

**首先，$k_0=2(n^2−n)$。**

显然这并不显然，但大概能猜到。

> 假如仅考虑横坐标，那么对于 $n$ 个循环 $(1,2,3,…,n)$，也就是说，$n$ 个现在横坐标为 $1$ 的点要到横坐标为 $2$ 的位置，横坐标为 $2$ 的点要到横坐标为 $3$，以此类推，最后是 $n$ 到 $1$。
>
> 所以通过交换需要至少 $n^2−n$ 步才能还原。
>
> 同样的，对于纵坐标，按照同样构造，也需要至少 $n^2−n$ 步。

因而我们知道 $k_0$ 的值。

考虑构造。

朴素的想法是，对于每个点，我们都可以用两步复原，且最后一行的元素只需用一步复原。

但这个想法需要使用 $2(n^2−n)+n−1$ 步，所以我们需要在复原每一行的时候都尝试减少一步。

> 考虑应在这行的点中，现在所在的列向应到的列连有向边，则必有一个环。

这段话有点绕，形式话说就是若 $a_{i,j}$ 应该在第 $p$ 列，则连边 $(j,p)$，显然能够形成环。

于是，这启发我们我们先将环上的元素放到应到的行上，在将其换到正确的位置，这里就可以节省掉一步操作，由此我们就顺利压缩了步数。

代码细节：注意需要实时维护每个元素的位置。

时间复杂度 $O(n^2)$。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int a[1005][1005];

int l[1000005];
int r[1000005];

pair<pair<int,int>,pair<int,int> > ans[2000005];

int p;

int vis[10005];

inline int id(int x,int y){
	return (x-1)*n+y;
}

int b[1000005];
int tot;


inline void change(int x,int y,int u,int v){
	swap(a[x][y],a[u][v]);
	l[a[x][y]]=x;
	r[a[x][y]]=y;
	l[a[u][v]]=u;
	r[a[u][v]]=v;
	ans[++p]=make_pair(make_pair(x,y),make_pair(u,v));
	return;
}


signed main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		for (int j=1;j<=n;j++){
			cin>>a[i][j];
			l[a[i][j]]=i;
			r[a[i][j]]=j;
		}
	}	
	
	for (int i=1;i<=n;i++){
		for (int i=1;i<=n;i++){
			vis[i]=0;
		}
		int pos=1;
		while(!vis[pos]){
			vis[pos]=1;
			pos=r[id(i,pos)];
		}
		for (int j=1;j<=n;j++){
			vis[j]=0;
		}
		int x=id(i,pos);
		tot=0;
		b[++tot]=x;
		
		vis[pos]=1;
		for (int j=r[x];j!=pos;j=r[x]){
			x=id(i,j);
			b[++tot]=x;
			vis[j]=1;
		}
		for(int j=1;j<=tot;j++){
			if (l[b[j]]!=i){
				change(l[b[j]],r[b[j]],i,r[b[j]]);	
			}
		}
		for (int j=1;j<=tot;j++){
			if (r[b[j]]!=(b[j]-1)%n+1){
				change(i,r[b[j]],i,(b[j]-1)%n+1);
			}
		}
		for (int j=1;j<=n;j++){
			if (vis[j]) continue;
			if (r[id(i,j)]!=j){
				change(l[id(i,j)],j,l[id(i,j)],r[id(i,j)]);
			}
			if (l[id(i,j)]!=i){
				change(l[id(i,j)],j,i,j);
			}
		}
	}
	cout<<p<<endl;
	for (int i=1;i<=p;i++){
		cout<<ans[i].first.first<<' '<<ans[i].first.second<<' '<<ans[i].second.first<<' '<<ans[i].second.second<<'\n';
	}
	return 0;
}
```

---

## 作者：shinzanmono (赞：1)

首先考虑答案上界 $k_0$。

最差情况是每一个数要动两次，如果一行中的数所在的行全部无误，那么还原列只需要 $n-1$ 次，同理如果前面的 $n-1$ 行全部复原，那么只需要 $n-1$ 次就可以将最后一行复原，$k_0=(n-1)(2n-1)+n-1=2n(n-1)$。

既然不用查找最小值，那么我们按照上面的思路复原即可。

对于每一行 $i$，只保留第 $i$ 行的元素，我们保证它的上面 $i-1$ 行是已复原的。

先考虑怎样把每个值 $x$ 换到相应的行。如果将 $x$ 当前所在的列向 $x$ 应该在的列连一条边，总共 $n$ 条边，会形成一个基环外向树。

我们只需要将环上的点同时向上即可，由于只有一个环，所以必然不会有两个同时在环上的点相遇。

然后我们沿着环其换到相应的位置即可，设环的大小为 $c$，这样我们最多使用 $2c-1$ 次操作。不在环上的点也只需要 $2(n-c)$ 次操作可以被换回来，这样每一行的次数为 $2n-1$。

这样就可以达到 $k_{\max}=k_0$ 的要求了。

给出代码：

```cpp
#include<iostream>
#include<algorithm>
#include<tuple>
const int sz=1010;
int a[sz][sz],bx[sz*sz],by[sz*sz],b[sz];
bool vis[sz];
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            std::cin>>a[i][j],bx[a[i][j]]=i,by[a[i][j]]=j;
    auto val=[&](int i,int j){return (i-1)*n+j;};
    std::basic_string<std::tuple<int,int,int,int>>ans;
    auto add=[&](int x,int y,int z,int w){
        std::swap(a[x][y],a[z][w]);
        bx[a[x][y]]=x,by[a[x][y]]=y;
        bx[a[z][w]]=z,by[a[z][w]]=w;
        ans+=std::make_tuple(x,y,z,w);
    };
    for(int i=1;i<=n;i++){
        std::fill(vis+1,vis+n+1,0);
        int col;
        for(col=1;!vis[col];col=by[val(i,col)])vis[col]=true; // 找到环的起点 val(i,col)
        std::fill(vis+1,vis+n+1,0);
        int cur=val(i,col),m=1;
        b[1]=cur,vis[cur]=true;
        for(int j=by[cur];j!=col;j=by[cur])
            cur=val(i,j),b[++m]=cur,vis[j]=true; // 将环上的点存进 b 数组
        for(int j=1;j<=m;j++)
            if(bx[b[j]]!=i)add(bx[b[j]],by[b[j]],i,by[b[j]]);
        for(int j=1;j<=m;j++)
            if(by[b[j]]!=(b[j]-1)%n+1)add(i,by[b[j]],i,(b[j]-1)%n+1);
        for(int j=1;j<=n;j++){
            if(vis[j])continue;
            if(by[val(i,j)]!=j)add(bx[val(i,j)],by[val(i,j)],bx[val(i,j)],j);
            if(bx[val(i,j)]!=i)add(bx[val(i,j)],j,i,j);
        }
    }
    std::cout<<ans.size()<<"\n";
    for(auto p:ans)std::cout<<std::get<0>(p)<<" "<<std::get<1>(p)<<" "<<std::get<2>(p)<<" "<<std::get<3>(p)<<"\n";
    return 0;
}
```

---


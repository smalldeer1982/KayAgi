# 「KDOI-02」一个截的拦

## 题目背景

## 本题疑似是错题，详情见 [讨论](/discuss/1032942)。

「{!@@(*@@￥';l]dw@)%)%&^_^}（可恶的人类！我一定会回来的！）」 

它将飞船拉到了最高速度，试图离开这个充满人类的地狱。

……

## 题目描述

过了那么多年，外星人的飞船速度早已比不过地球的飞船。因此，它决定使用折跃点逃离。

平面地图上有 $n$ 个折跃点，坐标分别为 $(x_i,y_i)$。某些折跃点之间有双向空间隧道连接，共 $m$ 条隧道，每条隧道分别连接折跃点 $u_i,v_i$，且激活该隧道需要消耗 $w_i$ 单位能量。**请注意，为了保证空间隧道之间互不干扰，对于任意两条空间隧道 $\bm{i,j}$，都保证连接点 $\bm{u_i,v_i}$ 与点 $\bm{u_j,v_j}$ 的线段没有交点。保证不存在起点和终点都相同的两条空间隧道。**

外星人的科技非常神奇，因此为了成功折跃离开，外星人必须经过地图上的所有折跃点 **至少一次**，它可以从任意一点开始折跃并从任意一点结束折跃，最终，外星人所花费的总能量为激活路径上所有隧道所消耗能量的 **按位或运算和**。经过两次或两次以上同一隧道只需激活一次该隧道。

外星人的飞船上拥有 $x$ 单位能量，因此，它所选择的折跃方案花费的总能量不能超过 $x$。为了拦截外星人，地方可以执行以下操作任意多次：

+ 选择一条连接 $u$ 和 $v$ 的双向隧道（你需要保证在点 $u$ 和 $v$ 之间存在双向隧道连接）；
+ 将激活它所需要的能量增加 $w$（$w\ge0$ 且操作后激活该通道所需要的能量不能超过 $2^{31}-1$）。

其中，$u,v,w$ 都可以自行指定。**每次操作所需要的代价为 $w$ 的二进制表示下 $1$ 的个数。**（即 `c++` 中的 `__builtin_popcount()` 函数）

为了赎罪，你需要设计一种操作方案，使得外星人无法通过折跃逃离，并最小化该方案所需要的代价。

## 说明/提示

**【样例解释】**
+ **样例 1 解释：**  
经过操作后的平面地图如下图所示（省略坐标轴）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/cbg7sir6.png)  
由于与 $2$ 号折跃点相连的空间隧道所需要的激活能量全部为 $10$，所以成功折跃所需要的能量至少为 $10$，因此外星人无法通过折跃逃离，代价为 $1$，显然不存在代价更小的操作方案。

***

**【评分方式】**

对于每个测试点，如果你的操作方案不合法或使得外星人能够成功通过折跃逃离，你将在该测试点得到  $0$ 分。

否则，设该测试点的评分参数为 $W$，标准答案的代价为 $a$，你的操作方案的代价为 $b$，则你的分数 $s$ 将由下列公式给出：

$$
s=\max\left(1-\frac{b-a}{a}\times W,0\right)\times10
$$

***

**【数据范围】** 

对于 $100\%$ 的数据，$12\le n\le 53280$，$n-1\le m\le 3n-6$，$0\le x<2^{31}-1$，$0\le|x_i|,|y_i|\le3\times10^4$，$0\le w_i<2^{31}$，$1\le W\le 1000$。

|测试点编号|$n=$|$m=$|$W=$|数据随机生成|
|:--:|:--:|:--:|:--:|:--:|
|$1$|$12$|$26$|$1000$|否|
|$2$|$12$|$26$|$1$|是|
|$3$|$200$|$579$|$2$|是|
|$4$|$500$|$1482$|$5$|是|
|$5$|$5000$|$14971$|$5$|否|
|$6$|$5000$|$14962$|$1$|是|
|$7$|$10656$|$30188$|$1000$|否|
|$8$|$10656$|$30188$|$5$|否|
|$9$|$53280$|$150960$|$1000$|否|
|$10$|$53280$|$150960$|$1000$|否|

***

**【校验器】**

为了方便测试，在 $\texttt{intercept}$ 目录下我们下发了 $\texttt{checker.cpp}$ 文件。你可以编译该文件，并使用它校验自己的输出文件。请注意它与最终评测时所用的校验器并不完全一致，你不需要也不应该关心其代码的具体内容。

编译命令为：

```plain
g++ checker.cpp -o checker -std=c++14
```

使用方式为：

```
./checker <inputfile> <outputfile> <answerfile>
```

校验器可能会返回以下状态中的其中一种：

+ $\texttt{accepted}$：表示你的输出完全正确。
+ $\texttt{points } x$：表示你的输出部分正确，可以在该测试点得到比例为 $x$ 的分数。
+ $\texttt{wrong answer}$：表示你在该测试点得到 $0$ 分。


对于所有非 $\texttt{accepted}$ 状态，校验器接下来会输出以下信息中的一种：

+ $\texttt{A}$：表示你的输出不合法。
+ $\texttt{B x y}$：表示你的输出方案的代价为 $x$，标准答案为 $y$。
+ $\texttt{C}$：表示你的输出方案使得外星人能够成功通过折跃逃离。

***

**【后记】**

他知道，他将永远离开家乡了。他仍记得，在倒转时空前，指挥官最后的那句叮嘱。他花了几乎半辈子，终于建立了新的基地，重整了军队。他的目的，就是为了防止这一切重蹈覆辙。现在，基地被毁了，他被困在这暗淡无光的星系里。他终于醒悟了，一切都是早已被决定好的。  
「指挥官，对不起。」  
「舱室将在十秒后自毁。十。九。八。七……」  
举起手枪，对准自己太阳穴。  
「六。五。四。三……」  
随着砰的一声，他无力地倒下了，眼里黯淡无光。  
「二。一。」  
巨响过后，无人将被铭记。

## 样例 #1

### 输入

```
1
5 6 9
0 1
0 0
0 -1
-1 0
1 0
1 2 10
1 4 1
2 3 8
3 4 5
3 5 1
1 5 1```

### 输出

```
1
2 3 2```

## 样例 #2

### 输入

```
见附件中的 intercept2.in```

### 输出

```
见附件中的 intercept2.ans```

## 样例 #3

### 输入

```
见附件中的 intercept3.in```

### 输出

```
见附件中的 intercept3.ans```

# 题解

## 作者：隔壁泞2的如心 (赞：12)

令人发指的究极辛巴达多合一题。

给出题人点个赞，数据一点都不水，造出了好多非平凡四元环（

要想做这题，首先你看到这平面图就知道得转对偶，具体在推荐题目第一个矿区的题解里就有。

然后你看到这么一堆位运算就知道要拆位，从高位到低位贪心。

显然，要想拦截成功，从最高位开始：
- 如果外星人在这位有能量，那么我们必须要让外星人花费这点能量，不然之后全堵死也没法拦截。

- 如果外星人在这位没有能量，那么我们可以在这里就把外星人堵死，或者先放它一马，然后外星人不再能通过任何含有此位的边，看看之后会不会有更优的解。

我们的任务变成了如何求出在某位拦截外星人的代价。显然我们加边权时不会进位，这等价于让一些边获得此位，使得所有含有此位（或者之前放过外星人的位）的边构成割。转成对偶图之后，原图的割等价于新图的环。但是以优于 $O(n^2)$ 的复杂度求无向图的最小环，这我不会啊！

再次观察题面，题目隐含了一个极强的条件：图没有重边！没有重边的平面图边数有上限，为 $3n-6$，因此原图中不会没有点的度数不大于 $5$，由于所有边代价一样，我们只要把那个原图中度数最小的点所连的所有边删去，就可以获得每位不大于 $5$ 的代价！

因此，我们可以依次判断新图的最小环是否是 $0/1/2/3/4$，如果都不是就是 $5$。具体地，我们依次判断以下条件。

- 原图是否联通

- 新图是否有自环

- 新图是否有重边

- 原图是否有度数为3的点，如果没有，新图是否有三元环。（套用三元环计数方法）

- 原图是否有度数为4的点，如果没有，新图是否有四元环。（套用四元环计数方法）

然后这题就做完了，我们发现，这看似友好的题面里面隐藏了好多板子……

下面是一些坑点：

- 自环重边不能一起查。

- 联通自环重边必须要在新图上查，特判原图度数行不通。

- 存新图的数组一定要往大了开，新图的点数可能比原图多很多。

下面是代码，不是很可读，也不能拿来对拍，没啥必要看……

```cpp
#include<cstdio>
#include<vector>
#include<map>
#include<cstring>
#include<cassert>
#include<cmath>
#include<algorithm>
#define int long long
using namespace std;
struct par{
	int a,b;
	friend bool operator<(par n1,par n2){if(n1.a==n2.a)return n1.b<n2.b;return n1.a<n2.a;}
};
map<par,int> ppc;
vector<int> l1[165432],l2[165432],sol[135],l3[165432];
int n,m,k,px[165432],py[165432],nxt[305416],t[305416],val[305416],tq[305416],bel[305416],dx[305416],dy[305416],t2[305416],dic[305416],mp[165432],xp[165432],cp[165432],ppv[165432];
bool cmp(int a,int b){
	return atan2(dx[a],dy[a])<atan2(dx[b],dy[b]);
}
bool cmp2(int a,int b){
	return t2[a]<t2[b];
}
int ppcdfs(int now,int arg){
	if(ppv[now])return 0;
	ppv[now]=1;
	int crr=0;
	for(int i=0;i<l1[now].size();i++){
		if(!(val[l1[now][i]]&arg))crr+=ppcdfs(t[l1[now][i]],arg);
	}
	return crr+1;
}
void sv(int now,int arg){
	memset(nxt,-1,sizeof(nxt));memset(bel,-1,sizeof(bel));memset(dic,0,sizeof(dic));memset(t2,0,sizeof(t2));memset(t2,0,sizeof(t2));memset(ppv,0,sizeof(ppv));
	int mid=77777777,mida=0;
	for(int i=1;i<=n;i++){
		int cnt=0,mind=0;
		for(int j=0;j<l1[i].size();j++){
			if(!(val[l1[i][j]]&arg))tq[cnt++]=l1[i][j],mind++;
		}
		mid>mind?mid=mind,mida=i:0;
		sort(tq,tq+cnt,cmp);
		for(int i=0;i<cnt-1;i++)nxt[tq[i]]=tq[i+1]^1;nxt[tq[cnt-1]]=tq[0]^1;
	}
	int cnt=0;
	for(int i=0;i<m*2;i++){
		int nw=i;
		if(nxt[nw]==-1||bel[nw]!=-1)continue;
		cnt++;
		while(!~bel[nw]){
			bel[nw]=cnt;
			nw=nxt[nw];
			dic[cnt]++;
		}
	}
	for(int i=1;i<=cnt;i++)l2[i].clear(),l3[i].clear();
	ppc.clear();
	if(ppcdfs(1,arg)!=n)return;
	if(!mid)return;
	if(mid==1){
		for(int j=0;j<l1[mida].size();j++)if(!(val[l1[mida][j]]&arg))sol[now].push_back(l1[mida][j]);
		return;
	}
	for(int i=0;i<m*2;i++){
		if(bel[i]==-1)continue;
		l2[bel[i]].push_back(i);
		t2[i]=bel[i^1];
		if(bel[i]==bel[i^1]){
			sol[now].push_back(i);
			return;
		}
		if(dic[bel[i^1]]>dic[bel[i]]||(dic[bel[i^1]]==dic[bel[i]]&&bel[i^1]>bel[i]))l3[bel[i]].push_back(i);
	}
	if(mid<=2){
		for(int j=0;j<l1[mida].size();j++)if(!(val[l1[mida][j]]&arg))sol[now].push_back(l1[mida][j]);
		return;
	}
	for(int i=0;i<m*2;i++){
		if(bel[i]==-1)continue;
		if(ppc.find({bel[i],bel[i^1]})!=ppc.end()){
			sol[now].push_back(i);
			sol[now].push_back(ppc[{bel[i],bel[i^1]}]);
			return;
		}
		ppc[{bel[i],bel[i^1]}]=i;
	}
	for(int i=1;i<=cnt;i++){
        sort(l2[i].begin(),l2[i].end(),cmp2);
		for(int j=0;j<l2[i].size()-1;j++){
		    assert(t2[l2[i][j]]!=i);
			if(t2[l2[i][j]]==t2[l2[i][j+1]]){
				sol[now].push_back(l2[i][j]);
				sol[now].push_back(l2[i][j+1]);
				return;
			}
		}
	}
	if(mid<=3){
		for(int j=0;j<l1[mida].size();j++)if(!(val[l1[mida][j]]&arg))sol[now].push_back(l1[mida][j]);
		return;
	}
	memset(mp,-1,sizeof(mp));memset(xp,0,sizeof(xp));
	for(int i=1;i<=cnt;i++){
		for(int j=0;j<l3[i].size();j++){
			int ts=t2[l3[i][j]];xp[ts]=i;mp[ts]=l3[i][j];
		}
		for(int j=0;j<l3[i].size();j++){
			int ts=t2[l3[i][j]];
			if(ts==i)continue;
			for(int h=0;h<l3[ts].size();h++){
				if(xp[t2[l3[ts][h]]]==i){
					sol[now].push_back(l3[ts][h]);
					sol[now].push_back(mp[t2[l3[ts][h]]]);
					sol[now].push_back(l3[i][j]);
					return;
				}
			}
		}
	}
	if(mid<=4){
		for(int j=0;j<l1[mida].size();j++)if(!(val[l1[mida][j]]&arg))sol[now].push_back(l1[mida][j]);
		return;
	}
	memset(cp,-1,sizeof(cp));memset(mp,-1,sizeof(mp));memset(xp,0,sizeof(xp));
	for(int i=1;i<=cnt;i++){
		for(int j=0;j<l2[i].size();j++){
			int ts=t2[l2[i][j]];
			for(int h=0;h<l3[ts].size();h++){
				if(t2[l3[ts][h]]==i)continue;
				if(xp[t2[l3[ts][h]]]==i){
					sol[now].push_back(cp[t2[l3[ts][h]]]);
					sol[now].push_back(mp[t2[l3[ts][h]]]);
					sol[now].push_back(l3[ts][h]);
					sol[now].push_back(l2[i][j]);
					return;
				}
				xp[t2[l3[ts][h]]]=i;
				mp[t2[l3[ts][h]]]=l3[ts][h];
				cp[t2[l3[ts][h]]]=l2[i][j];
			}
		}
	}
	if(mid<=5){
		for(int j=0;j<l1[mida].size();j++)if(!(val[l1[mida][j]]&arg))sol[now].push_back(l1[mida][j]);
		return;
	}
	assert(0);
}
signed main(){
	scanf("%*lld%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)scanf("%lld%lld",px+i,py+i);
	for(int i=0;i<m;i++){
		int in1,in2,in3;
		scanf("%lld%lld%lld",&in1,&in2,&in3);
		assert(in1!=in2);
		l1[in1].push_back(i*2);l1[in2].push_back(i*2+1);
		t[i*2]=in2;t[i*2+1]=in1;val[i*2]=val[i*2+1]=in3;
		assert(t[i*2]!=t[i*2+1]);
		dx[i*2]=px[in2]-px[in1];dy[i*2]=py[in2]-py[in1];
		dx[i*2+1]=-px[in2]+px[in1];dy[i*2+1]=-py[in2]+py[in1];
	}
	int cur1=0,cur2=0,anss=44444444,fin=66554432;
	for(int i=30;i>=0;i--){
		sv(i,(1<<i)|cur1);
		if(k&(1<<i))cur2+=sol[i].size();
		else{
			(anss>cur2+sol[i].size())?(anss=(cur2+sol[i].size()),fin=i):0;
			cur1|=(1<<i);
		}
	}
	ppc.clear();
	for(int i=30;i>=fin;i--){
		if(i!=fin&&((k&(1<<i))==0))continue;
		for(int j=0;j<sol[i].size();j++){
			par p1={t[sol[i][j]],t[sol[i][j]^1]};if(p1.a>p1.b)swap(p1.a,p1.b);
			if(ppc.find(p1)==ppc.end())ppc[p1]=(1<<i);
			else ppc[p1]=ppc[p1]|(1<<i);
		}
	}
	printf("%u\n",ppc.size());
	for(auto i=ppc.begin();i!=ppc.end();i++){
		printf("%lld %lld %lld\n",(i->first).a,(i->first).b,i->second);
	}
}
```


---

## 作者：Error_Yuan (赞：6)

## Part 1

首先，我们转化一下题意，发现外星人所花费的能量，就是平面图的最小 **按位或** 生成树。

设平面图为 $G$，过程如下：

+ 从高位到低位贪心。
+ 可以发现，如果删去所有权值的第 $k$ 位上为 $1$ 的边后，图 $G$ 是连通的，那么答案的第 $k$ 位就是 $0$，否则答案的第 $k$ 位一定是 $1$。如果答案的第 $k$ 位是 $1$，我们就把这些删去的边全部加回来。然后继续对下一位执行操作。

在 spj 中有具体的实现过程。

## Part 2

分析如果 $x'\ge x$ 在二进制下是什么表现。假设 $x'=\overline{a_0'a_1'a_2'\cdots},x=\overline{a_0a_1a_2\cdots}$，则 $x'>x\Leftrightarrow\exists i$ 使得 $a_0=a'_0,\cdots,a_{i-1}=a_{i-1}',a_i<a_i'$。

于是做法呼之欲出：

对于原图的二进制下所有为 $0$ 的位，割掉这一位是 $1$ 的边后跑一次全局最小割，然后贪心取最小值即可。不要忘了特判 $x'=x$ 的情况。

## Part 3

考虑如何求出无权平面图的最小环，根据著名结论，平面图最小割等于对偶图最小环，所以可以借用 CF#484 的套路做到单次 $O(n^2)$。

但是，我们又注意到，图是对偶图，而对偶图节点的最小度数不超过 $5$！于是我们只需要统计对偶图中长度为 $3,4$ 的环，这个直接套无向图三/四元环计数，虽然在一般无向图上至多是 $O(n\sqrt{n})$ 的，但在平面图上只需要 $O(n)$（这点是 Proof by AC，我不会证）。记得特判最小割为 $1/2$ 的情况（即对偶图中有环边/回边）。

综合上述即得一个时间复杂度 $O(n\log n)$ 的做法，十分优秀。

---


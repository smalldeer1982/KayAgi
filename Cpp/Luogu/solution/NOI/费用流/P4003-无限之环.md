# 无限之环

## 题目描述

曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：

游戏在一个 $n \times m$ 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 $15$ 种形状：

 ![](https://cdn.luogu.com.cn/upload/pic/12049.png) 

游戏开始时，棋盘中水管可能存在漏水的地方。

形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。

玩家可以进行一种操作：选定一个含有**非直线型**水管的方格，将其中的水管绕方格中心顺时针或逆时针旋转 $90$ 度。

直线型水管是指左图里中间一行的两种水管。

现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。


## 说明/提示

【样例 1 解释】

样例 1 棋盘如下:

旋转方法很显然，先将左上角虚线方格内的水管顺时针转 $90$ 度

 ![](https://cdn.luogu.com.cn/upload/pic/12050.png) 

然后右下角虚线方格内的水管逆时针旋转 $90$ 度，这样就使得水管封闭了

【样例 2 解释】

样例 2 为题目描述中的第一张图片，无法达成目标。

【样例 3 解释】

样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 $180$ 度即可。


 ![](https://cdn.luogu.com.cn/upload/pic/12051.png) 



## 样例 #1

### 输入

```
2 3
3 14 12
3 11 12```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2
1 8
5 10
2 4```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
9 11 3
13 15 7
12 14 6```

### 输出

```
16```

# 题解

## 作者：钱逸凡 (赞：102)

~~打了几个小时终于A了（我真是太蒻了），第一次A黑题，兴奋地发了个题解~~

[推荐一波我的博客](https://www.luogu.org/blog/ONE-PIECE/)

# 很好的网络流题

本题是费用流。（根本看不出来）

### 首先要知道怎么判断图是否漏水。

方法如下：

#### 考虑黑白染色法：

把网格染成黑白相间的格子，把每一个白色当成源点，每一个黑色当成汇点。

把每个格子周围建立四个点，白色（源点）连向能通的周围点，黑色周围点连向汇点。

把白色的周围点连向黑色周围点。

什么意思呢？

以下图为例：![](https://cdn.luogu.com.cn/upload/pic/28114.png)

对于一张不会漏的图，如：（画图技术有限）
![](https://cdn.luogu.com.cn/upload/pic/28117.png)

我们连以下边：

![](https://cdn.luogu.com.cn/upload/pic/28118.png)

这时，满流就等价于不会漏。

### 接下来考虑旋转的问题：

先找一张会漏但经过旋转就不会漏的图：

![](https://cdn.luogu.com.cn/upload/pic/28120.png)

将左上角旋转一次就不会漏。

那转化回黑白图是什么呢？

![](https://cdn.luogu.com.cn/upload/pic/28123.png)
为了满足旋转，我们加入一条蓝色的边，代价为1。

然后我们跑费用流，红色的流量为1，代价为0，蓝色的流量为1，代价为1，答案即是1，也就是需要旋转的次数。

讲到这里，大概你就懂了。

没错，只要把每个格子对应的红边蓝边加好，跑费用流即可。

题目里给的水管可以分为5类：

### 以下全部默认白格，黑格所有边反向

1.直线型：

![](https://cdn.luogu.com.cn/upload/pic/28128.png)：

由于不用旋转，只需把对应的红边加好，既s指向上和s指向下。

2.Q型：

![](https://cdn.luogu.com.cn/upload/pic/28129.png)

对于这种，我们需要加入一条红边，从s（源点）指向初始方向（以向上为例），加入蓝边，上指向左，代价为1，上指向右，代价为1，上指向下，代价为2（要旋转两次）。

3.丁型：

![](https://cdn.luogu.com.cn/upload/pic/28130.png)

我们需要加入三条红边：s指向上，s指向左，s指向右，
还有三条蓝边：上指向下，代价为2（旋转两次），左指向下，代价为1（旋转一次），右指向下，代价为1（旋转一次）。//这个地方旋转要自己画图理解

4.L型：

![](https://cdn.luogu.com.cn/upload/pic/28131.png)

我们需要加入两条红边：s指向上，s指向右，再加入两条蓝边：上指向下,代价为1，（旋转一次，因为旋转一次后，仍有指向右的，故只需改上的）右指向左，代价为1。

是不是很奇怪，没有代价为2的边，其实旋转两次相当于两条蓝边都走，总代价就是2了。

5.+型：

![](https://cdn.luogu.com.cn/upload/pic/28134.png)

由于这种不能旋转，直接加4条红边即可。

这题的难点在于建图，图建好了跑费用流就能过了。

附上我丑陋的代码：
打了三百多行累死我了，不过其实很多情况可以合并的。

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cstdio>
using namespace std;
const int inf=1<<30;
int Read(){
    int x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0'){
        if(c=='-')f=-1;
    c=getchar();    
    }
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return f==1?x:-x;
}
int maxflow=0;
int mincost=0;
int realflow=0;
int n,m;
int top=1,head[101010],inque[101010];
int s,t;
int dist[101010];
struct Node{
    int v;
    int val;
    int next;
    int cost;
}node[101010];
void addedge(int u,int v,int val,int cost){
    node[++top].v=v;
    node[top].val=val;
    node[top].cost=cost;
    node[top].next=head[u];
    head[u]=top;
}//加边函数 
void add(int u,int v,int val,int cost){
    addedge(u,v,val,cost);
    addedge(v,u,0,-cost);
}//网络流的加边，正向和反向 
bool spfa(){
    memset(inque,0,sizeof(inque));
    memset(dist,0x3f,sizeof(dist));
    dist[s]=0;
    inque[s]=1;
    queue<int>q;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        inque[u]=0;
        for(int i=head[u];i;i=node[i].next){
            int d=node[i].v;
            if(dist[d]>dist[u]+node[i].cost&&node[i].val){
                dist[d]=dist[u]+node[i].cost;
                if(inque[d]==0){
                    q.push(d);
                    inque[d]=1;
                }
            }
        }
    }
    return dist[t]!=0x3f3f3f3f;
}
inline int min(int x,int y){
    return x<y?x:y;
}
int dfs(int u,int low){
    if(u==t){inque[t]=1;maxflow+=low;return low;}
    int used=0;
    inque[u]=1;
    for(int i=head[u];i;i=node[i].next){
        int d=node[i].v;
        if((inque[d]==0||d==t)&&node[i].val!=0&&dist[d]==dist[u]+node[i].cost){
            int minflow=dfs(d,min(low-used,node[i].val));
            if(minflow!=0)
            mincost+=node[i].cost*minflow,node[i].val-=minflow,node[i^1].val+=minflow,used+=minflow;
            
            if(used==low)break;
        }
    }
    return used;
}
int Dinic(){
    while(spfa()){
        inque[t]=1;
        while(inque[t]){
        memset(inque,0,sizeof(inque));
        dfs(s,inf);
        } 
    }
    return maxflow;
}
inline bool check(int i,int j){
    return i>0&&i<=n&&j>0&&j<=m;
}//判断(i,j)是否需要加节点 
inline int up(int i,int j){
    return 4*((i-1)*m+j);
}//(i,j)的上节点 
inline int down(int i,int j){
    return 4*((i-1)*m+j)+1;
}//(i,j)的下节点 
inline int left(int i,int j){
    return 4*((i-1)*m+j)+2;
}//(i,j)的左节点 
inline int right(int i,int j){
    return 4*((i-1)*m+j)+3;
}//(i,j)的右节点 
int main() {
    //freopen("cin.txt","r",stdin);
    s=10010,t=10001;
    n=Read(),m=Read();
    int i,j;
    int map,colur;
    colur=0;
    for(i=1;i<=n;i++){
    	colur=i%2;
        for(j=1;j<=m;j++){
            map=Read();
            colur^=1;
            if(colur==0){
            if(check(i,j-1))add(left(i,j),right(i,j-1),1,0);
            if(check(i,j+1))add(right(i,j),left(i,j+1),1,0);
            if(check(i-1,j))add(up(i,j),down(i-1,j),1,0);
            if(check(i+1,j))add(down(i,j),up(i+1,j),1,0);
            }//白色点四周与附近的黑色点四周相连
            if(map==1){//0001
            realflow++;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(up(i,j),right(i,j),1,1);//向右流要转一次，代价为1
            add(up(i,j),left(i,j),1,1);//向左代价为1
            add(up(i,j),down(i,j),1,2);//向下代价为2 
            }//白色点s向四周流 
            if(colur==1){
            add(up(i,j),t,1,0);
            add(right(i,j),up(i,j),1,1);
            add(left(i,j),up(i,j),1,1);
            add(down(i,j),up(i,j),1,2);
            }//黑色点四周向t流 
            continue;
            }
            if(map==2){//0010
            realflow++;
            if(colur==0){
            add(s,right(i,j),1,0);
            add(right(i,j),up(i,j),1,1);
            add(right(i,j),down(i,j),1,1);
            add(right(i,j),left(i,j),1,2);
            }
            if(colur==1){
            add(right(i,j),t,1,0);
            add(up(i,j),right(i,j),1,1);
            add(down(i,j),right(i,j),1,1);
            add(left(i,j),right(i,j),1,2);
            }
            continue;
            }
            if(map==3){//0011
            realflow+=2;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,right(i,j),1,0);
            add(up(i,j),down(i,j),1,1);
            add(right(i,j),left(i,j),1,1);
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(right(i,j),t,1,0);
            add(down(i,j),up(i,j),1,1);
            add(left(i,j),right(i,j),1,1);
            }
            continue;
            }
            if(map==4){//0100
            realflow++;	
            if(colur==0){
            add(s,down(i,j),1,0);
            add(down(i,j),right(i,j),1,1);
            add(down(i,j),left(i,j),1,1);
            add(down(i,j),up(i,j),1,2);
            }
            if(colur==1){
            add(down(i,j),t,1,0);
            add(right(i,j),down(i,j),1,1);
            add(left(i,j),down(i,j),1,1);
            add(up(i,j),down(i,j),1,2);
            }
            continue;
            }
            if(map==5){//0101
            realflow+=2;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,down(i,j),1,0);
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(down(i,j),t,1,0);
            }
            }//直线型不可旋转
            if(map==6){//0110
            realflow+=2;
            if(colur==0){
            add(s,right(i,j),1,0);
            add(s,down(i,j),1,0);
            add(right(i,j),left(i,j),1,1);
            add(down(i,j),up(i,j),1,1);
            }
            if(colur==1){
            add(right(i,j),t,1,0);
            add(down(i,j),t,1,0);
            add(left(i,j),right(i,j),1,1);
            add(up(i,j),down(i,j),1,1);
            }
            } 
            if(map==7){//0111
            realflow+=3;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,right(i,j),1,0);
            add(s,down(i,j),1,0);
            add(up(i,j),left(i,j),1,1);
            add(down(i,j),left(i,j),1,1);
            add(right(i,j),left(i,j),1,2);
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(right(i,j),t,1,0);
            add(down(i,j),t,1,0);
            add(left(i,j),up(i,j),1,1);
            add(left(i,j),down(i,j),1,1);
            add(left(i,j),right(i,j),1,2);
            }
            }
            if(map==8){//1000
            realflow++;
            if(colur==0){
            add(s,left(i,j),1,0);
            add(left(i,j),up(i,j),1,1);
            add(left(i,j),down(i,j),1,1);
            add(left(i,j),right(i,j),1,2);
            }
            if(colur==1){
            add(left(i,j),t,1,0);
            add(up(i,j),left(i,j),1,1);
            add(down(i,j),left(i,j),1,1);
            add(right(i,j),left(i,j),1,2);
            }
            }
            if(map==9){//1001
            realflow+=2;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,left(i,j),1,0);
            add(up(i,j),down(i,j),1,1);
            add(left(i,j),right(i,j),1,1);
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(left(i,j),t,1,0);
            add(down(i,j),up(i,j),1,1);
            add(right(i,j),left(i,j),1,1);
            }
            }
            if(map==10){//1010
            realflow+=2;
            if(colur==0){
            add(s,left(i,j),1,0);
            add(s,right(i,j),1,0);
            }
            if(colur==1){
            add(left(i,j),t,1,0);
            add(right(i,j),t,1,0);
            }
            continue;//直线型 
            }
            if(map==11){//1011
            realflow+=3;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,left(i,j),1,0);
            add(s,right(i,j),1,0);
            add(left(i,j),down(i,j),1,1);
            add(right(i,j),down(i,j),1,1);
            add(up(i,j),down(i,j),1,2);
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(left(i,j),t,1,0);
            add(right(i,j),t,1,0);
            add(down(i,j),left(i,j),1,1);
            add(down(i,j),right(i,j),1,1);
            add(down(i,j),up(i,j),1,2);
            }
            }
            if(map==12){//1100
            realflow+=2;
            if(colur==0){
            add(s,left(i,j),1,0);
            add(s,down(i,j),1,0);
            add(left(i,j),right(i,j),1,1);
            add(down(i,j),up(i,j),1,1);
            }
            if(colur==1){
            add(left(i,j),t,1,0);
            add(down(i,j),t,1,0);
            add(right(i,j),left(i,j),1,1);
            add(up(i,j),down(i,j),1,1);
            }
            }
            if(map==13){//1101
            realflow+=3;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,down(i,j),1,0);
            add(s,left(i,j),1,0);
            add(up(i,j),right(i,j),1,1);
            add(down(i,j),right(i,j),1,1);
            add(left(i,j),right(i,j),1,2);
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(down(i,j),t,1,0);
            add(left(i,j),t,1,0);
            add(right(i,j),up(i,j),1,1);
            add(right(i,j),down(i,j),1,1);
            add(right(i,j),left(i,j),1,2);
            }
            }
            if(map==14){//1110
            realflow+=3;
            if(colur==0){
            add(s,left(i,j),1,0);
            add(s,down(i,j),1,0);
            add(s,right(i,j),1,0);
            add(left(i,j),up(i,j),1,1);
            add(right(i,j),up(i,j),1,1);
            add(down(i,j),up(i,j),1,2);
            }	
            if(colur==1){
            add(left(i,j),t,1,0);
            add(down(i,j),t,1,0);
            add(right(i,j),t,1,0);
            add(up(i,j),left(i,j),1,1);
            add(up(i,j),right(i,j),1,1);
            add(up(i,j),down(i,j),1,2);	
            }
            }
            if(map==15){//1111
            realflow+=4;
            if(colur==0){
            add(s,up(i,j),1,0);
            add(s,right(i,j),1,0);
            add(s,left(i,j),1,0);
            add(s,down(i,j),1,0);	
            }
            if(colur==1){
            add(up(i,j),t,1,0);
            add(down(i,j),t,1,0);
            add(left(i,j),t,1,0);
            add(right(i,j),t,1,0);
            }
            }
        }
    }
    Dinic();
    if(maxflow*2!=realflow)printf("-1");
    else printf("%d",mincost);
    return 0;
}
```

需要注意的是，无论黑白，在统计应该的流量（代码中为realflow）时一视同仁，最后只需最大流等于应该的流量即为满流。
# 看懂了就给个赞吧。
没看懂可以发讨论。

---

## 作者：q234rty (赞：72)

考虑状压DP，暴力记录之前一行的下边和上一个格子的左边有没有插头，枚举这个格子如何旋转（注意直线不能旋转），直接转移即可，转移时需要特判当前在某一行末尾的情况。

时间复杂度$O(nm2^{min(n,m)})$，期望得分$40$，然而官方数据中实际有效的状态数很少，所以用一个`std::map`或者`std::unordered\_map`或者它们对应的手写数据结构记录下来所有的有效状态就可以AC辣。



```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXSIZE=10000020;
const int INF=0x3f3f3f3f;
int bufpos;
char buf[MAXSIZE];
#define NEG 0
void init(){
    // freopen("infinityloop.in","r",stdin);
    // freopen("infinityloop.out","w",stdout);
    buf[fread(buf,1,MAXSIZE,stdin)]='\0';
    bufpos=0;
}
#if NEG
int readint(){
    bool isneg;
    int val=0;
    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);
    bufpos+=(isneg=buf[bufpos]=='-');
    for(;isdigit(buf[bufpos]);bufpos++)
        val=val*10+buf[bufpos]-'0';
    return isneg?-val:val;
}
#else
int readint(){
    int val=0;
    for(;!isdigit(buf[bufpos]);bufpos++);
    for(;isdigit(buf[bufpos]);bufpos++)
        val=val*10+buf[bufpos]-'0';
    return val;
}
#endif
char readchar(){
    for(;isspace(buf[bufpos]);bufpos++);
    return buf[bufpos++];
}
int readstr(char* s){
    int cur=0;
    for(;isspace(buf[bufpos]);bufpos++);
    for(;!isspace(buf[bufpos]);bufpos++)
        s[cur++]=buf[bufpos];
    s[cur]='\0';
    return cur;
}
const int cnt[4]={0,1,2,1};
bool fix[16];
int a[2002][2002];
// int f[1<<15][2],g[1<<15][2];
map<ll,pair<int,int> > f,g;
inline void relax(int &x,int y){
    if (x>y)
        x=y;
}
int main(){
    init();
    int n=readint(),m=readint();
    fix[0]=fix[5]=fix[10]=1;
    if (n>m){
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                a[i][j]=readint();
    }else{
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++){
                int x=readint();
                a[j][n-i-1]=((x<<1)|(x>>3&1))&15;
            }
        swap(n,m);
    }
    /*for(int i=0;i<n;i++){
        for(int j=0;j<m;j++)
            printf("%d ",a[i][j]);
        putchar('\n');
    }*/
    ll mask=(1LL<<m)-1;
    f[0]=make_pair(0,INF);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
            for(map<ll,pair<int,int> >::iterator t=f.begin();t!=f.end();t++){
                //printf("f[%d][0]=%d,f[%d][1]=%d\n",k,f[k][0],k,f[k][1]);
                if (t->second.first==INF && t->second.second==INF)
                    continue;
                int w=a[i][j];
                ll k=t->first;
                pair<int,int> qwq=t->second;
                for(int o=0;o<4;o++){
                    if (o && fix[w])
                        break;
                    if ((w&1)==(k>>(m-1)&1) && (j!=m-1 || !(w>>1&1))){
                        map<ll,pair<int,int> >::iterator it=g.insert(make_pair(((k<<1)|(w>>2&1))&mask,make_pair(INF,INF))).first;
                        relax(w>>1&1?it->second.second:it->second.first,(w>>3&1?qwq.second:qwq.first)+cnt[o]);//fix j=m-1
                    }
                    w=(w>>1)|((w&1)<<3);
                }
            }
            //fprintf(stderr,"%d\n",f.size());
            f.clear();
            f.swap(g);
        }
    printf("%d",f[0].first==INF?-1:f[0].first);
    //fprintf(stderr,"%d",clock());
}
```

---

## 作者：FlashHu (赞：56)

#### 蒟蒻表示这是一道思维神题。。。。。。

~~有人第一眼看上去觉得这要跑费用流吗？~~


然而只要会建图，剩下的就是套模板的事了。


我们这样来理解。对于每个方格上的水管的每一个支管，有且仅有一个其它方格上的支管与其相连，这样就不会漏水了。用网络流知识表述，就是每个支管容量只能为1，且全都要满流。


然而即使产生了最优情况，整个管网也不一定是一整个联通块，而可能被分成若干块。因此，怎样强制使每两个相邻的方格上都产生流量呢？就要把源汇点连到每个格子上。而且，还要对每个格点染色，相邻的两个格点，一个连源点，一个连汇点。具体的实现，就要利用格点行列坐标和的奇偶性来判断。


而产生的费用呢？当然是旋转造成的啦！真正的思维就体现在这里了。因为旋转还会造成接触点的变化，所以肯定是要拆点的，一个方格拆成五个点，上下左右中。。。。。。中间点连上源/汇点，并根据支管情况向四周连容量1，费用0的边。四周视作接触点，与对应相邻的另一个接触点连容量1，费用0的边。讨论相邻两个方格格因旋转而产生的有费用的连边，实在是太难了。。。。。。猛然发现，所有的情况，其实只需要在内部进行转化就好了。


所有的方格，我们大致分成以下几类进行讨论。


---
#####第一种：射线型



 ![](https://cdn.luogu.com.cn/upload/pic/12752.png) 

这种好办。射线指向上面，那么就让左、下、右接触点直接连接上接触点。左，右连上去，表示只要转90度，所以费用为1。下面连上去费用就是2。


---
#####第二种：直角型



 ![](https://cdn.luogu.com.cn/upload/pic/12753.png) 

这种理解起来就有难度了。如果顺时针转90度，会变成这样



 ![](https://cdn.luogu.com.cn/upload/pic/12754.png) 

相当于原来连上接触点的支管连到了下面，那么上与下建一条容量为1，费用为1的边。同样的道理，逆时针转90度，左与右建一条容量为1，费用为1的边。再来讨论转180度，这时候，会通过已有的边由左、下直接转移到右、上，费用加起来正好是2，所以不用连更多边了。


---
#####第三种：T字型



 ![](https://cdn.luogu.com.cn/upload/pic/12755.png) 

像前面一样讨论，也可以建边。从下向左、右各建一条容量为1，费用为1的边，向上建一条费用为2的边。这里就留给读者自己思考啦。


---
以上三种情况，每一种都有4个形状，但连边方法都是一样的。


还有直线型，十字型和空的，要么不能转，要么转了没意义，就不用内部建边了。


下面贴代码，蒟蒻只会SPFA增广费用流。。。。。。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
#define R register int
#define UP(U) U+turn*sum
#define RI(U) U+((turn+1)&3)*sum
#define DO(U) U+((turn+2)&3)*sum
#define LE(U) U+((turn+3)&3)*sum
#define MD(U) U+(sum<<2)//上面几个用来计算对应点的数组下标，上下左右中。。。
const int INF=2147483647,N=20009,M=200009;
int sum,P=1,S=0,T;//sum方格总数，P建图循环变量，S、T为源汇点
int he[N],ne[M],to[M],f[M],c[M];//f流量，c费用
int q[N],d[N],pre[N];//q队列，d距离，pre记录最短路
bool inq[N];//标记是否在队列中
inline void in(R&z)//快读
{
    register char c=getchar();
    while(c<'-')c=getchar();
    z=c&15;c=getchar();
    while(c>'-')z*=10,z+=c&15,c=getchar();
}
inline void add(R u,R v,R flow,R cost,R tp)//建边，tp表示染色属性
{
    if(tp){tp=u;u=v;v=tp;}//如果是奇数点，所有的边都要反向，要流出去
    to[++P]=v;ne[P]=he[u];he[u]=P;c[P]=cost;f[P]=flow;
    to[++P]=u;ne[P]=he[v];he[v]=P;c[P]=-cost;
}
#define PB(X) q[t]=X;if(++t==N)t=0
#define PF(X) if(--h<0)h=N-1;q[h]=v
inline bool spfa()//模板，加了两种优化
{
    R h=0,t=1,i,u,v,dn,cnt=1,sum=0;
    for(i=S+1;i<=T;++i)d[i]=INF;
    q[0]=S;inq[0]=1;
    while(h!=t)
    {
        u=q[h];
        if(++h==N)h=0;
        if(d[u]*cnt>sum){PB(u);continue;}//LLL优化
        --cnt;sum-=d[u];
        for(i=he[u];i;i=ne[i])
            if(f[i]&&d[v=to[i]]>(dn=d[u]+c[i]))
            {
                if(inq[v])sum-=d[v];
                else
                {
                    inq[v]=1;++cnt;
                    if(d[v]<d[q[h]]){PB(v);}
                    else{PF(v);}//SLF优化
                }
                pre[v]=i;
                sum+=(d[v]=dn);
            }
        inq[u]=0;
    }
    return d[T]!=INF;
}
int main()
{
    R n,m,i,j,k=1,t,shape,turn,totf=0,mf=0,mc=0;//totf总流量，mf最大可行流，mc最小总费用
    in(n);in(m);
    sum=n*m;T=sum*5+1;
    for(i=0;i<n;++i)
        for(j=0;j<m;++j,++k)
        {
            turn=0;//turn下面会用来翻转，将同类型的水管归类到一起
            t=(i+j)&1;//t是染色属性，只要判断奇偶
            if(t)add(S,MD(k),INF,0,0);
            else add(MD(k),T,INF,0,0);
            if(i)add(DO(k-m),UP(k),1,0,t);
            if(j)add(RI(k-1),LE(k),1,0,t);
            in(shape);
            if(shape&1)add(UP(k),MD(k),1,0,t),++totf;//统计总流量
            if(shape&2)add(RI(k),MD(k),1,0,t),++totf;//因为每个流拆成了两段
            if(shape&4)add(DO(k),MD(k),1,0,t),++totf;//所以最终结果会是实际的两倍
            if(shape&8)add(LE(k),MD(k),1,0,t),++totf;//中点与四周点连边
            switch(shape)
            {
            case 8:++turn;//1000 ←
            case 4:++turn;//0100 ↓
            case 2:++turn;//0010 →
            case 1:       //0001 ↑
                add(RI(k),UP(k),1,1,t);
                add(DO(k),UP(k),1,2,t);
                add(LE(k),UP(k),1,1,t);
                break;//这四种形状内部连边情况是一样的，转一下统一处理就方便些了，下面同理
            case 9:++turn; //1001 ┘
            case 12:++turn;//1100 ┐
            case 6:++turn; //0110 ┌
            case 3:        //0011 └
                add(DO(k),UP(k),1,1,t);
                add(LE(k),RI(k),1,1,t);
                break;
            case 13:++turn;//1101 ┤
            case 14:++turn;//1110 ┬
            case 7:++turn; //0111 ├
            case 11:       //1011 ┴
                add(DO(k),LE(k),1,1,t);
                add(DO(k),UP(k),1,2,t);
                add(DO(k),RI(k),1,1,t);
                break;
            }
        }
    while(spfa())
    {
        m=INF;//这里m记下流量
        for(i=T;i!=S;i=to[k^1])
        {
            k=pre[i];
            if(m>f[k])m=f[k];
        }
        mf+=m;
        for(i=T;i!=S;i=to[k^1])
        {
            k=pre[i];
            f[k]-=m;f[k^1]+=m;
            mc+=m*c[k];
        }
    }
    printf("%d",totf==mf<<1?mc:-1);//注意如果没能流满就输-1
    return 0;
}
```

---

## 作者：绝顶我为峰 (赞：28)

~~如果不是看题解这辈子也建不出模来的毒瘤费用流题目~~

flag:

![](https://cdn.luogu.com.cn/upload/image_hosting/tq452ljo.png)

~~不过我 A 了你们看不到我女装了哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈~~

------

言归正传

我们认为一个水管是不漏水的，当且仅当与他相邻的插头上也有一个水管和它~~接吻~~对接

当整个模型是满流的时候，这个图就不漏水了

为了强制让相邻的借口都产生贡献，我们需要将整个图染色，白色连源，黑色连汇，至于流量费用都很显然，~~留给读者自行思考~~

然后我们要考虑怎样建模才能保证满流时这张图是不漏水的，一个点显然无法满足我们的要求了

点不够咋办呢？

拆呗

我们把一个点拆成上下左右中五个点，这样要表示对接就非常简单了，我们从一个白点向相邻的黑点连边

有了建模思路，我们看看具体怎么处理每种水管

------

题目给了 13 种管子挺吓人的，但是实际上本质不同的管子只有 5 种，我们一一讨论：

**（由于黑格子和白格子的连边情况是完全相反的，为了方便的同时不引起大家误解，这里只讨论白格子的连边情况）**

**我们默认下方的所有操作，都先要从格子中间向每一个有接口的方向连一条流量为 $1$ 的边，下方所有的边流量均为 $1$**

## 1.断头水管

也就是第一张图中带圆圈的，它只有一个出口，我们考虑怎样连边

**我们假设开口朝上**

然后考虑翻转，如果向左/右翻转 $90\degree$ 接口就到了左边/右边，所以从上向左、右各连一条费用 $1$ 的边

同理，从上到下连一条费用 $2$ 的边

## 2.直线水管

我们发现直线水管如果它四周的借口不是直线，则一定无解，而如果是直线，那么直线一定已经接好了，所以我们不对直线水管进行处理

## 3.直角水管

**假设它的两个接口分别向上、向右**

那么我们向左转 $90\degree$，等价于上面接口不动，右边接口到左边，所以从右到左连一条费用为 $1$ 的边

同理，向右转的时候，从上到下连一条费用为 $1$ 的边

那么转 $180\degree$ 呢？我们发现通过原有的边完全可以转移，所以不用处理、

## 4.T 形水管

**假设下方没有接口**

按照套路画图试一试，我们可以发现我们需要分别从左、右到下各连一条费用为 $1$ 的边，从上到下连一条费用为 $2$ 的边

## 5.十字花水管

~~但凡有脑子的人也能想到这个不用转吧~~

那么分析到这里，代码就呼之欲出了：

~~前方350行代码警告~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_pbds;
struct edge
{
	int nxt,to,weight,value;
}e[200001<<1];
int n,m,tot=1,s,t,h[10005],dep[10005],cur[10005],ans,sum,cost,hg[10005];
bool vis[10005];
//中0上1右2下3左4
const int dx[]={-1,0,1,0},dy[]={0,1,0,-1},cross[]={3,4,1,2};
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline int id(int x,int y,int num)
{
	return (x-1)*m+y+num*n*m;
}
inline void add(int x,int y,int w,int val)
{
	e[++tot].nxt=h[x];
	h[x]=tot;
	e[tot].to=y;
	e[tot].weight=w;
	e[tot].value=val;
}
inline bool dijkstra()
{
	for(register int i=0;i<=t;++i)
	{
		vis[i]=0;
		dep[i]=0x3f3f3f3f;
		cur[i]=h[i];
	}
	__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> >,pairing_heap_tag> q;
	q.push(make_pair(0,t));
	dep[t]=0;
	while(!q.empty())
	{
		pair<int,int> k=q.top();
		q.pop();
		if(vis[k.second])
			continue;
		vis[k.second]=1;
		for(register int i=h[k.second];i;i=e[i].nxt)
			if(e[i^1].weight&&dep[e[i].to]>dep[k.second]-e[i].value+hg[k.second]-hg[e[i].to])
			{
				dep[e[i].to]=dep[k.second]-e[i].value+hg[k.second]-hg[e[i].to];
				q.push(make_pair(dep[e[i].to],e[i].to));
			}
	}
	return dep[s]!=dep[0];
}
int dfs(int k,int f)
{
	if(k==t)
	{
		ans+=f;
		vis[t]=1;
		return f;
	}
	int r=0,used=0;
	vis[k]=1;
	for(register int i=cur[k];i;i=e[i].nxt)
	{
		cur[k]=i;
		if((!vis[e[i].to]||e[i].to==t)&&e[i].weight&&dep[e[i].to]==dep[k]-e[i].value+hg[k]-hg[e[i].to])
			if((r=dfs(e[i].to,min(e[i].weight,f-used))))
			{
				cost+=r*e[i].value;
				e[i].weight-=r;
				e[i^1].weight+=r;
				used+=r;
				if(f==used)
					break;
			}
	}
	return used;
}
inline int dinic()
{
	while(dijkstra())
	{
		vis[t]=1;
		while(vis[t])
		{
			memset(vis,0,sizeof(vis));
			dfs(s,1<<30);
		}
		memset(vis,0,sizeof(vis));
		for(register int i=0;i<=t;++i)
			hg[i]+=dep[i];
	}
	return ans<<1;
}
inline void build(int x,int y,int num)
{
	//中0上1右2下3左4
	if((x+y)&1)
	{
		add(s,id(x,y,0),1<<30,0);
		add(id(x,y,0),s,0,0);
		for(register int i=0;i<4;++i)
		{
			int xx=x+dx[i],yy=y+dy[i];
			if(xx<=0||xx>n||yy<=0||yy>m)
				continue;
			add(id(x,y,i+1),id(xx,yy,cross[i]),1,0);
			add(id(xx,yy,cross[i]),id(x,y,i+1),0,0);
		}
		for(register int i=0;i<4;++i)
			if(num&(1<<i))
			{
				add(id(x,y,0),id(x,y,i+1),1,0);
				add(id(x,y,i+1),id(x,y,0),0,0);
				++sum;
			}
		//中0上1右2下3左4
		switch(num)
		{
			case 1:
				add(id(x,y,1),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,1),0,-1);
				add(id(x,y,1),id(x,y,3),1,2);
				add(id(x,y,3),id(x,y,1),0,-2);
				add(id(x,y,1),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,1),0,-1);
				break;
			case 2:
				add(id(x,y,2),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,2),0,-1);
				add(id(x,y,2),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,2),0,-1);
				add(id(x,y,2),id(x,y,4),1,2);
				add(id(x,y,4),id(x,y,2),0,-2);
				break;
			case 4:
				add(id(x,y,3),id(x,y,1),1,2);
				add(id(x,y,1),id(x,y,3),0,-2);
				add(id(x,y,3),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,3),0,-1);
				add(id(x,y,3),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,3),0,-1);
				break;
			case 8:
				add(id(x,y,4),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,4),1,-1);
				add(id(x,y,4),id(x,y,2),1,2);
				add(id(x,y,2),id(x,y,4),0,-2);
				add(id(x,y,4),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,4),0,-1);
				break;
			case 3:
				add(id(x,y,1),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,1),0,-1);
				add(id(x,y,2),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,2),0,-1);
				break;
			case 6:
				add(id(x,y,3),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,3),0,-1);
				add(id(x,y,2),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,2),0,-1);
				break;
			case 9:
				add(id(x,y,1),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,1),0,-1);
				add(id(x,y,4),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,4),0,-1);
				break;
			case 12:
				add(id(x,y,3),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,3),0,-1);
				add(id(x,y,4),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,4),0,-1);
				break;
			case 7:
				add(id(x,y,1),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,1),0,-1);
				add(id(x,y,2),id(x,y,4),1,2);
				add(id(x,y,4),id(x,y,2),0,-2);
				add(id(x,y,3),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,3),0,-1);
				break;
			case 11:
				add(id(x,y,1),id(x,y,3),1,2);
				add(id(x,y,3),id(x,y,1),0,-2);
				add(id(x,y,2),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,2),0,-1);
				add(id(x,y,4),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,4),0,-1);
				break;
			case 13:
				add(id(x,y,1),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,1),0,-1);
				add(id(x,y,3),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,3),0,-1);
				add(id(x,y,4),id(x,y,2),1,2);
				add(id(x,y,2),id(x,y,4),0,-2);
				break;
			case 14:
				add(id(x,y,2),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,2),0,-1);
				add(id(x,y,3),id(x,y,1),1,2);
				add(id(x,y,1),id(x,y,3),0,-2);
				add(id(x,y,4),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,4),0,-1);
				break;
		}
		//中0上1右2下3左4
	}
	else
	{
		add(id(x,y,0),t,1<<30,0);
		add(t,id(x,y,0),0,0);
		for(register int i=0;i<4;++i)
			if(num&(1<<i))
			{
				add(id(x,y,i+1),id(x,y,0),1,0);
				add(id(x,y,0),id(x,y,i+1),0,0);
				++sum;
			}
		switch(num)
		{
			case 1:
				add(id(x,y,2),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,2),0,-1);
				add(id(x,y,3),id(x,y,1),1,2);
				add(id(x,y,1),id(x,y,3),0,-2);
				add(id(x,y,4),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,4),0,-1);
				break;
			case 2:
				add(id(x,y,1),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,1),0,-1);
				add(id(x,y,3),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,3),0,-1);
				add(id(x,y,4),id(x,y,2),1,2);
				add(id(x,y,2),id(x,y,4),0,-2);
				break;
			case 4:
				add(id(x,y,1),id(x,y,3),1,2);
				add(id(x,y,3),id(x,y,1),0,-2);
				add(id(x,y,2),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,2),0,-1);
				add(id(x,y,4),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,4),0,-1);
				break;
			case 8:
				add(id(x,y,1),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,1),1,-1);
				add(id(x,y,2),id(x,y,4),1,2);
				add(id(x,y,4),id(x,y,2),0,-2);
				add(id(x,y,3),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,3),0,-1);
				break;
			case 3:
				add(id(x,y,3),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,3),0,-1);
				add(id(x,y,4),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,4),0,-1);
				break;
			case 6:
				add(id(x,y,1),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,1),0,-1);
				add(id(x,y,4),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,4),0,-1);
				break;
			case 9:
				add(id(x,y,3),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,3),0,-1);
				add(id(x,y,2),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,2),0,-1);
				break;
			case 12:
				add(id(x,y,1),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,1),0,-1);
				add(id(x,y,2),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,2),0,-1);
				break;
			case 7:
				add(id(x,y,4),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,4),0,-1);
				add(id(x,y,4),id(x,y,2),1,2);
				add(id(x,y,2),id(x,y,4),0,-2);
				add(id(x,y,4),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,4),0,-1);
				break;
			case 11:
				add(id(x,y,3),id(x,y,1),1,2);
				add(id(x,y,1),id(x,y,3),0,-2);
				add(id(x,y,3),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,3),0,-1);
				add(id(x,y,3),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,3),0,-1);
				break;
			case 13:
				add(id(x,y,2),id(x,y,1),1,1);
				add(id(x,y,1),id(x,y,2),0,-1);
				add(id(x,y,2),id(x,y,3),1,1);
				add(id(x,y,3),id(x,y,2),0,-1);
				add(id(x,y,2),id(x,y,4),1,2);
				add(id(x,y,4),id(x,y,2),0,-2);
				break;
			case 14:
				add(id(x,y,1),id(x,y,2),1,1);
				add(id(x,y,2),id(x,y,1),0,-1);
				add(id(x,y,1),id(x,y,3),1,2);
				add(id(x,y,3),id(x,y,1),0,-2);
				add(id(x,y,1),id(x,y,4),1,1);
				add(id(x,y,4),id(x,y,1),0,-1);
				break;
		}
	}
	//中0上1右2下3左4
}
int main()
{
	n=read(),m=read();
	s=n*m*5+1;
	t=s+1;
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=m;++j)
		{
			int p=read();
			build(i,j,p);
		}
	if(dinic()!=sum)
		puts("-1");
	else
		printf("%d\n",cost);
	return 0;
}

```


---

## 作者：Danno0v0 (赞：25)

众所周知，黑色的网络流的思维难度都比较高，很适合训练网络流建模，这道能评黑色网络流题质量前三，~~当然麻烦程度我评第一。~~

然后我们一看题，通过 ~~算法标签~~ **方格题百分之五十都是考网络流** 这一句至理名言，我们知道这道题要考网络流。但是这道题要求的是到达一个状态的最小代价，那么就是费用流。

费用流的要求状态大多数时候是最大流，那么就依着管子全部接上 $=$ 最大流这个思路来建模。

首先来想一下如果水管不会转怎么判断有没有水管漏了。

方格网络流肯定要染色，就黑白染色来看看（贼丑，将就看吧）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hp3yu7qi.png)

一个常规思路是把黑点连源白点接汇，然后把格子之间有连通的边的两个格子连起来跑最大流，假如最大流$\times 2 =$接口数那就说明没有漏的。

（啊？为什么这样判断？因为每个黑点的接口与每一个白点的接口接在一起可以产生流量为 $1$ 的贡献，那么参与贡献的接口就是最大流的两倍啦，假如最大流两倍小于接口数，那么说明有接口没有产生贡献，所以没有接口和它配对，所以是不符合的）

好了，现在来看如果水管要转会怎么样。

接下来，我们会把一个点拆成五个点，分别是上下左右，以及中间的，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/diazzu6p.png)

刚刚说的黑点接源白点接汇，那么把格子中的中心那个点接上源与汇就可以了（流量INF）。然后把黑点和白点通过上下左右四个点连接起来（流量 $1$ ，肯定两个点之间只会挨一次啊）。然后根据点内管子的样式，把中心的点和上下左右的点连接起来（流量为 $1$ ，你肯定一个方向只能流一次，还有原因下面说）。比方说有向上方向的管子就把中心点与上面的点连起来，如此如此。

准备工作就绪，接下来就是进入到这个题真正玄妙之处了，旋转管子应该怎么处理。

先来看一个比较简单的，就是只有一个接口的那个。

![](https://cdn.luogu.com.cn/upload/image_hosting/oootmap9.png)

现在，我们要让它转起来了。比方说我们准备要让它能向右转。我们就连一条附加边：

![](https://cdn.luogu.com.cn/upload/image_hosting/zawwre37.png)

紫色的边流量为 $1$ ，费用为 $1$ 。什么意思？其实发现，走黑边-紫边就等于把这个只有一个接口的转到右边，然后费用为 $1=$ 转了一下。

那为什么不直接把中心点和右边的点连起来呢？如果真的这么干，那么这个点就会流出 $2$ 个单位的流量，就等于有两个接口，很明显是不合题意的。而上方的接法其实保证了流量限定为 $1$ 。稍后你就会发现，所有的管子都是：

- 通过黑边限制流量。

- 通过紫边达成旋转，费用为旋转次数。

那么明白了右边之后，左边同理：（以下所有紫色边的流量都是 $1$ ,费用已标出）

![](https://cdn.luogu.com.cn/upload/image_hosting/gd2d7o0r.png)

那么下面呢？从上面转到下面要 $2$ 次，那么费用就是 $2$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/7bc3pb28.png)

之后所有接口为 $1$ 的管子都可以这样处理。~~然后剩下的管子你可以自己推测出来了，加油=）~~还是要说一下：

L型管：

![](https://cdn.luogu.com.cn/upload/image_hosting/0jzjbmwr.png)

（你会问为什么没有费用为 $2$ 的边，也就是转两次呢？假如你转了两次，那么相当于两条紫边都要走，费用就是 $2$）

T型管：

![](https://cdn.luogu.com.cn/upload/image_hosting/234knshm.png)

（假设转了一下，那么上面的边一定还在，然后成为下面的边的一定是左右两条边，所以是左右向下连费用 $1$ 的边；转了两下就是上面的边成为了下面的边而左右不变，所以是连费用 $2$ 的边）

直线管 & 十字管：

![](https://cdn.luogu.com.cn/upload/image_hosting/eitz3wcf.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/evrvhfj3.png)

这两个都不能转，所以不需要连附加边。

然后建图就完了，接下来跑最小费用最大流就可。判断是否符合上文已讲，然后这个黑题就没有了。

code：~~建边跟猪国杀有一拼~~

```
#include<bits/stdc++.h>
#define S 999999
#define T 1000000
#define U 150000
#define R 300000
#define D 450000
#define L 600000
using namespace std;
int min_cost,max_flow,flows;
int fi[1000001],nx[1000001],to[1000001],val[1000001],co[1000001],in[1000001],min_flow[1000001],pre[1000001],dis[1000001],tot=1;
void link1(int a,int b,int c,int d)
{
	nx[++tot]=fi[a];
	fi[a]=tot;
	to[tot]=b;
	val[tot]=c;
	co[tot]=d;
	nx[++tot]=fi[b];
	fi[b]=tot;
	to[tot]=a;
	val[tot]=0;
	co[tot]=-d;
}
void link2(int b,int a,int c,int d)
{
	nx[++tot]=fi[a];
	fi[a]=tot;
	to[tot]=b;
	val[tot]=c;
	co[tot]=d;
	nx[++tot]=fi[b];
	fi[b]=tot;
	to[tot]=a;
	val[tot]=0;
	co[tot]=-d;
}
typedef void l(int,int,int,int);
bool spfa()
{
	memset(dis,0x3f3f3f,sizeof(dis));
	queue<int>que;
	que.push(S);
	dis[S]=0;
	in[S]=1;
	min_flow[S]=0x7fffffff;
	while(!que.empty())
	{
		int x=que.front();
		que.pop();
		in[x]=0;
		for(int i=fi[x];i;i=nx[i])
		{
			int v=to[i];			
			if(val[i]&&dis[v]>dis[x]+co[i])
			{
				dis[v]=dis[x]+co[i];
				pre[v]=i;
				min_flow[v]=min(val[i],min_flow[x]);
				if(!in[v])
				{
					que.push(v);
					in[v]=1;
				}
			}
		}
	}
	return dis[T]<0x73f3f3f;
}
void ek()
{
	while(spfa())
	{
		max_flow+=min_flow[T];
		min_cost+=(min_flow[T]*dis[T]);
		int x=T;
		while(x!=S)
		{
			int i=pre[x];	
			val[i]-=min_flow[T];
			val[i^1]+=min_flow[T];
			x=to[i^1];
		}
	}
}	
l *link[2]={link2,link1};
#define lk link[(i+j)%2]
int main()
{
	int n,m,k;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if((i+j)%2==1)
			{
				lk(S,i*300+j,0x7ffffff,0);
				if(i>1) lk(i*300+j+U,(i-1)*300+j+D,1,0);
				if(i<n) lk(i*300+j+D,(i+1)*300+j+U,1,0);
				if(j>1) lk(i*300+j+L,i*300+j-1+R,1,0);
				if(j<m)	lk(i*300+j+R,i*300+j+1+L,1,0);
			}
			else 
			{
				lk(T,i*300+j,0x7ffffff,0);
			}
			cin>>k;
			int posi=i*300+j;
			if(k&1) lk(posi,posi+U,1,0),flows++;
			if(k&2) lk(posi,posi+R,1,0),flows++;
			if(k&4) lk(posi,posi+D,1,0),flows++;
			if(k&8) lk(posi,posi+L,1,0),flows++;
			switch(k)
			{
				case 1:
					lk(posi+U,posi+L,1,1);
					lk(posi+U,posi+R,1,1);
					lk(posi+U,posi+D,1,2);
					break;
				case 2:
					lk(posi+R,posi+U,1,1);
					lk(posi+R,posi+D,1,1);
					lk(posi+R,posi+L,1,2);
					break;
				case 3:
					lk(posi+U,posi+D,1,1);
					lk(posi+R,posi+L,1,1);
					break;
				case 4:
					lk(posi+D,posi+L,1,1);
					lk(posi+D,posi+R,1,1);
					lk(posi+D,posi+U,1,2);
					break;
				case 6:
					lk(posi+D,posi+U,1,1);
					lk(posi+R,posi+L,1,1);
					break;
				case 7:
					lk(posi+U,posi+L,1,1);
					lk(posi+D,posi+L,1,1);
					lk(posi+R,posi+L,1,2);
					break;
				case 8:
					lk(posi+L,posi+U,1,1);
					lk(posi+L,posi+D,1,1);
					lk(posi+L,posi+R,1,2);
					break;
				case 9:
					lk(posi+U,posi+D,1,1);
					lk(posi+L,posi+R,1,1);
					break;
				case 11:
					lk(posi+L,posi+D,1,1);
					lk(posi+R,posi+D,1,1);
					lk(posi+U,posi+D,1,2);
					break;
				case 12:
					lk(posi+L,posi+R,1,1);
					lk(posi+D,posi+U,1,1);
					break;
				case 13:
					lk(posi+U,posi+R,1,1);
					lk(posi+D,posi+R,1,1);
					lk(posi+L,posi+R,1,2);
					break;
				case 14:
					lk(posi+L,posi+U,1,1);
					lk(posi+R,posi+U,1,1);
					lk(posi+D,posi+U,1,2);
					break;
			}
		}
	}
	ek();
	if(max_flow*2<flows)
	{
		cout<<-1<<endl;
	}
	else
	{
		cout<<min_cost<<endl;
	}
}
```


---

## 作者：shadowice1984 (赞：18)

网络流神题！！！！

切了这道题说明你的网络流已经出神入化

首先观察这道题，有一个很奇怪的设定，**直线型是不能转的**

如果以插头dp的思路来看，这根本是瞎搞

在插头dp眼里直线型旋转，它和别的东西没任何区别

但是仔细看一下，对于直线型旋转，它**同时挪动了两个点**

你可能说，L型旋转也是啊，但是L型旋转的左旋和右旋**只移动一个点**

而下旋，可以看成**左旋和右旋的加和**

而直线型旋转不是，它的下旋没有意义，而左旋和右旋需要挪动两个点

先解释一下上面的话

如果我们这样表示一个格子

\--0
1--2
\--3
那么就会发现，对于一个L型的接口，

左旋相当于将**0**号点移动到**3**号点

右旋相当于把**2**号点移动到**1**号点的位置

下旋即将**0移至3，2移至1**

相当于同时左旋，右旋

\*又发现直线型根本不满足这个性质！\*

~~所以只能说这是std的缺陷了，一定是因为std利用了上述性质，致使不可处理直线型的情况~~

~~根本不会是插头dp，而不是数据大不能用插d的问题~~

~~当然插头dp加map优化也行，但问题是根本就不会有这种限制~~

这里你需要思维进行一下跳跃，想到这道题事实上是个匹配问题

因为是个网格图，采用了常用的**黑白染色技巧**

那么发现，“没有漏水的水管”的意思是，网格中所有的格子的断头

**两两匹配**

又因为黑白染色过，这个匹配的行为只能在黑白两格间形成

至此变成了我们熟悉的二分图最大匹配问题，如果没有旋转，这道题已经可做

下面是如何处理旋转

旋转，如上述所说，在不考虑直线型时，可以看为是单点挪动或者是单点挪动的加和

而旋转，是有代价的，我们可以考虑建立起费用流模型

首先一个点拆为4个点

源点向每一个黑点断头连一条限制为1，权值为0的边

每一个白点断头向汇点连一个限制为1，权值为0的边

如果这两个点（不论是不是断头）相邻，黑向白连一个限制为1，权值为0的边

//这是因为通过旋转可以更改流的方向，但是匹配关系是死的

这样格子之间的关系（相邻接头匹配）就处理干净了

下面在格子内部连边，以处理旋转关系

一字型

从唯一的断头像左右点各连一个权值为1，限制为1的边，模拟左旋右旋

向对面的点连一个权值为2的边，模拟下旋

L型
每个断头向其对面点连一个权值为1，限制为1的边，如果有一个边被激活

模拟的是左旋或右旋，如果同时被激活，模拟下旋

T型
如果这个断头和唯一的空点相连，那么这个断头向空点连一个权值为1，限制为1的边

模拟左旋和右旋，空点对面的断头，向空点连一个权值为2，限制为1的边，模拟下旋

0，直线型，和十字型

要么不能转，要么转了和没转一样，不加连边

然后在这上面跑费用流即可

费用流呢，就是把最大流中的bfs变成spfa，并且记录最短路径

然后去增广这条路径即可

PS代码会极其恶心，请注意压行

上代码~




```cpp
    #include<cstdio>
    #include<algorithm>
    #include<queue>
    using namespace std;
    int n;int m;int s;int t;int map[2010];
    int d[9020];bool book[9020];int cnt=1;int alist[9020];
    queue <int> q;struct data{int v;int nxt;int cot;int val;}edge[400050];
    struct node{int v;int n;int c;}fr[8020];int flow;int expflow;int cost;
    bool flag;bool pflag;//注意邻接表的cnt要设为1
    inline void add2(int u,int v,int val)//这里为了避免黑点白点边向相反的问题写了两个add
    {
        //正向反向边一起加，不然代码会惨不忍睹
        edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;
        edge[cnt].val=val;edge[cnt].cot=1;
        edge[++cnt].v=u;edge[cnt].nxt=alist[v];alist[v]=cnt;
        edge[cnt].val=-val;edge[cnt].cot=0;return;
    }
    inline void add(int u,int v,int val)
    {
        if(flag==true){add2(v,u,val);return;}//flag用来判断是黑还是白，如果白了，反向
        edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;
        edge[cnt].val=val;edge[cnt].cot=1;
        edge[++cnt].v=u;edge[cnt].nxt=alist[v];alist[v]=cnt;
        edge[cnt].val=-val;edge[cnt].cot=0;return;
    }
    inline int f(int i,int j){return i*(n*m+1)+j;}//一些处理坑爹数据的小函数
    inline bool check(int i,int j){return 0<i&&i<=n&&0<j&&j<=m;}
    inline int g(int i,int j){return (i-1)*m+j;}//同样是为了压行
    inline bool spfa()//为了压行spfa的返回值设成了bool
    {
        for(int i=1;i<=n*m*4+5;i++){d[i]=0x3f3f3f3f;book[i]=false;}
        d[s]=0;q.push(s);book[s]=true;
        while(!q.empty())
        {
            int now=q.front();q.pop();book[now]=false;
            int nxt=alist[now];while(nxt)
            {
                int v=edge[nxt].v;int cot=edge[nxt].cot;int val=edge[nxt].val;
                if(d[v]>d[now]+val&&cot!=0)
        {d[v]=d[now]+val;fr[v].v=now;fr[v].c=cot;fr[v].n=nxt;if(!book[v])q.push(v);}
                nxt=edge[nxt].nxt;//记着记录方案
            }
        }
        if(d[t]==0x3f3f3f3f)return false;int mincot=0x3f3f3f3f;
        for(int p=t;p!=s;p=fr[p].v){mincot=min(mincot,fr[p].c);}//找出流量瓶颈    for(intp=t;p!=s;p=fr[p].v){edge[fr[p].n].cot=mincot;edge[fr[p].n^1].cot+=mincot;}
        flow+=mincot;cost+=d[t]*mincot;return true;//增广和计算费用
    }
    int main()
    {
        scanf("%d%d",&n,&m);
        s=n*m*4+4;t=n*m*4+5;
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++)scanf("%d",&map[(i-1)*m+j]);}
        for(int i=1;i<=n;i++)//开始了，建图！
        {
            for(int j=1;j<=m;j++)
            {
                int p=(i-1)*m+j;if((i+j)%2==1)//判断是黑点还是白点
                {flag=false;for(int k=0;k<=3;k++){if((map[p]>>k)&1）{add(s,f(k,p),0);expflow++;}}}
                else {flag=true;for(int k=0;k<=3;k++){if((map[p]>>k)&1){add(t,f(k,p),0);}}}
                if(!flag)//暴力枚举上下左右连边
                {
                    if(check(i-1,j)){add(f(0,p),f(2,g(i-1,j)),0);}
                    if(check(i+1,j)){add(f(2,p),f(0,g(i+1,j)),0);}
                    if(check(i,j-1)){add(f(3,p),f(1,g(i,j-1)),0);}
                    if(check(i,j+1)){add(f(1,p),f(3,g(i,j+1)),0);}
                }
                switch(map[p])//暴力枚举格子每一个可能的取值0-15
                {
                    case 0:{break;}//注意特判不用连边的格子
                    case 1:{add(f(0,p),f(1,p),1);add(f(0,p),f(2,p),2);add(f(0,p),f(3,p),1);break;}
                    case 2:{add(f(1,p),f(0,p),1);add(f(1,p),f(2,p),1);add(f(1,p),f(3,p),2);break;}
                    case 3:{add(f(0,p),f(2,p),1);add(f(1,p),f(3,p),1);break;}
                    case 4:{add(f(2,p),f(1,p),1);add(f(2,p),f(0,p),2);add(f(2,p),f(3,p),1);break;}
                    case 5:{break;}
                    case 6:{add(f(2,p),f(0,p),1);add(f(1,p),f(3,p),1);break;}
                    case 7:{add(f(0,p),f(3,p),1);add(f(1,p),f(3,p),2);add(f(2,p),f(3,p),1);break;}
                    case 8:{add(f(3,p),f(0,p),1);add(f(3,p),f(1,p),2);add(f(3,p),f(2,p),1);break;}
                    case 9:{add(f(0,p),f(2,p),1);add(f(3,p),f(1,p),1);break;}
                    case 10:{break;}
                    case 11:{add(f(0,p),f(2,p),2);add(f(1,p),f(2,p),1);add(f(3,p),f(2,p),1);break;}
                    case 12:{add(f(2,p),f(0,p),1);add(f(3,p),f(1,p),1);break;}
                    case 13:{add(f(0,p),f(1,p),1);add(f(2,p),f(1,p),1);add(f(3,p),f(1,p),2);break;}
                    case 14:{add(f(1,p),f(0,p),1);add(f(2,p),f(0,p),2);add(f(3,p),f(0,p),1);break;}
                    case 15:{break;}
                }
            }
        }
        while(spfa());//费用流
        if(flow!=expflow)printf("-1");
        else printf("%d",cost);
        return 0;//拜拜程序~
    }

```

---

## 作者：Stinger (赞：10)

~~就我的建图这么清奇？~~

由于这是一个网格图而且还有各种奇怪的形状和限制以及奇怪的数据范围，可以往网络流考虑。

如果一个图不漏水，那么每个格子的度数必定是这个格子的水管的分叉数。

对网格图进行黑白染色，则问题变为从黑点向白点提供一些度数，使得源点向黑点连的边和白点向汇点连的边均满流。

题目要求旋转次数最少，考虑费用流。

首先每个点拆成五个点，分别表示它往上下左右方向的连边和它本身。

以下只讨论黑格子。

从 $s$ 向这个格子本身的点连边，容量为这个格子水管分叉数（设为 $x$），费用为 $0$。表示不管怎么旋转它都会连接 $x$ 个方向。

格子按照分叉数和是否为直线分为以下 $5$ 种情况：

## 1分叉（圆圈形）

没什么好说的，向上下左右各连一条容量 $1$， 费用为原方向旋转到这个方向的旋转次数即可。

## 2分叉（直线形）

这种情况也很简单，直线不能转，根据直线是横着的还是竖着的向上下各连容量 $1$ 费用 $0$ 的边或向左右连边。

## 2分叉（转弯形）

这种情况必须横方向有一个水管，竖方向有一个水管，所以再额外建立两个点表示横方向和竖方向，然后向横点和竖点各连一条容量 $1$ 费用 $0$ 的边。

再从横点向上下连边，竖点向左右连边，容量均为 $1$，费用为开始水管的方向是否朝向了这里，如果是则为 $0$，否则为 $1$。

## 3分叉（T字形）

这个情况看起来很难搞……

~~没事大不了我针对4种T形各拆一个点就好了~~

但这样做显然是不行的，因为流量会到处跑，~~而且码量比较劝退。~~

那我们就直接按照 $1$ 分叉的连边改一改费用！

假设是这种朝下的T形：

![](https://i.loli.net/2021/06/29/JSYfADvwcZpMBL8.jpg)

设向上面连的边费用为 $a_1$，向左连的边费用为 $a_2$，向右连的边费用为 $a_3$，向下为 $a_4$。

那么根据实际的旋转次数，我们希望这些费用满足以下条件：

$$
\begin{cases}
a_1+a_2+a_3=2\\
a_1+a_2+a_4=1\\
a_1+a_3+a_4=1\\
a_2+a_3+a_4=0
\end{cases}
$$

解一下方程发现 $a_1=4/3,a_2=a_3=1/3,a_4=-2/3$。

这里有一个技巧可以避免小数费用流带来的常数，因为整个图中只有这一个地方有分数的费用并且分母都是 $3$，所以只要把所有边的费用乘 $3$，输出的时候除回来就好了。

## 4分叉（十字形）

如果看懂了上面的连边这里就不用我说了吧（

向上下左右各连一条容量 $1$ 费用 $0$ 的边即可。

白点就是把上面的连边全部反过来了，为了避免复制粘贴使得代码看起来很长我用了rev变量标记。

然后有个相邻点之间的连边，比如 $(x,y)$ 的黑点的上方连 $(x-1,y)$ 的白点的下方等等，很简单就不赘述了。

实现非常丑：

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#define U 0
#define D 1
#define L 2
#define R 3
#define UD 4
#define LR 5

const int INF = 1e9;
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};
inline int min(const int x, const int y) {return x < y ? x : y;}
struct Edge {
	int to, cap, cost, nxt;
} e[10000005];
int head[100005], cur[100005], dis[100005];
int tot = 1, s, t, Maxflow, Mincost;
bool vis[100005], mark[100005];
std::queue<int> Q;
bool rev;
inline void AddEdge(int u, int v, int cap, int cost, bool mul = true) {
	if (rev) u ^= v ^= u ^= v;
	if (mul) cost *= 3;
	e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;
	e[tot].cap = cap, e[tot].cost = cost;
	e[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;
	e[tot].cap = 0, e[tot].cost = -cost;
}
bool SPFA() {
	memcpy(cur, head, sizeof cur);
	memset(vis, 0, sizeof vis);
	memset(dis, 0x3f, sizeof dis);
	memset(mark, 0, sizeof mark);
	Q.push(s);
	dis[s] = 0;
	while (Q.size()) {
		int u(Q.front());
		Q.pop();
		mark[u] = false;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			if (e[i].cap && dis[u] + e[i].cost < dis[v]) {
				dis[v] = dis[u] + e[i].cost;
				if (!mark[v]) Q.push(v), mark[v] = true;
			}
		}
	}
	return dis[t] < INF;
}

int dfs(int u, int flow) {
	if (u == t) return flow;
	vis[u] = true;
	int used = 0, tmp;
	for (int i = cur[u]; i && used <= flow; i = e[i].nxt) {
		cur[u] = i;
		if (e[i].cap && dis[u] + e[i].cost == dis[e[i].to]) {
			int v = e[i].to;
			if (!vis[v] && (tmp = dfs(v, min(flow - used, e[i].cap))))
				used += tmp, e[i].cap -= tmp, e[i ^ 1].cap += tmp;
		}
	}
	return used;
}

void Dinic() {
	int flow = 0;
	while (SPFA()) Maxflow += (flow = dfs(s, INF)), Mincost += flow * dis[t];
}

int n, m, id[2005][6], a[2005], cnt;
inline int pos(int i, int j) {return (i - 1) * m + j;}

int main() {
	int sum1 = 0, sum2 = 0;
	scanf("%d%d", &n, &m);
	s = 0, t = 20000, cnt = n * m;
	for (int i = 1; i <= n; ++ i)
	for (int j = 1; j <= m; ++ j) {
		int p = pos(i, j);
		scanf("%d", a + p);
		if (!a[p]) continue;
		int len = 0;
		for (int k = 0; k <= 3; ++ k)
			if (a[p] & 1 << k) ++ len;
		rev = i + j & 1;
		if (!rev) AddEdge(s, p, len, 0), sum1 += len;
		else AddEdge(t, p, len, 0), sum2 += len;
		switch (a[p]) {
			case 5:
				AddEdge(p, id[p][U] = ++ cnt, 1, 0);
				AddEdge(p, id[p][D] = ++ cnt, 1, 0);
				break;
			case 10:
				AddEdge(p, id[p][L] = ++ cnt, 1, 0);
				AddEdge(p, id[p][R] = ++ cnt, 1, 0);
				break;
			case 1:
			case 2:
			case 4:
			case 8:
				AddEdge(p, id[p][U] = ++ cnt, 1, (a[p] == 1 ? 0 : (a[p] == 4 ? 2 : 1)));
				AddEdge(p, id[p][D] = ++ cnt, 1, (a[p] == 4 ? 0 : (a[p] == 1 ? 2 : 1)));
				AddEdge(p, id[p][L] = ++ cnt, 1, (a[p] == 8 ? 0 : (a[p] == 2 ? 2 : 1)));
				AddEdge(p, id[p][R] = ++ cnt, 1, (a[p] == 2 ? 0 : (a[p] == 8 ? 2 : 1)));
				break;
			case 3:
			case 6:
			case 9:
			case 12:
				AddEdge(p, id[p][UD] = ++ cnt, 1, 0);
				AddEdge(p, id[p][LR] = ++ cnt, 1, 0);
				AddEdge(id[p][UD], id[p][U] = ++ cnt, 1, !((bool)(a[p] & 1)));
				AddEdge(id[p][UD], id[p][D] = ++ cnt, 1, !((bool)(a[p] & 4)));
				AddEdge(id[p][LR], id[p][L] = ++ cnt, 1, !((bool)(a[p] & 8)));
				AddEdge(id[p][LR], id[p][R] = ++ cnt, 1, !((bool)(a[p] & 2)));
				break;
			case 7:
			case 11:
			case 13:
			case 14:
				AddEdge(p, id[p][U] = ++ cnt, 1, (a[p] == 11 ? -2 : (a[p] == 14 ? 4 : 1)), 0);
				AddEdge(p, id[p][D] = ++ cnt, 1, (a[p] == 14 ? -2 : (a[p] == 11 ? 4 : 1)), 0);
				AddEdge(p, id[p][L] = ++ cnt, 1, (a[p] == 13 ? -2 : (a[p] == 7 ? 4 : 1)), 0);
				AddEdge(p, id[p][R] = ++ cnt, 1, (a[p] == 7 ? -2 : (a[p] == 13 ? 4 : 1)), 0);
				break;
			default:
				AddEdge(p, id[p][U] = ++ cnt, 1, 0);
				AddEdge(p, id[p][D] = ++ cnt, 1, 0);
				AddEdge(p, id[p][L] = ++ cnt, 1, 0);
				AddEdge(p, id[p][R] = ++ cnt, 1, 0);
		}
	}
	rev = false;
	for (int i = 1; i <= n; ++ i)
	for (int j = 1; j <= m; ++ j)
		if (!(i + j & 1) && a[pos(i, j)]) {
			int p = pos(i, j);
			for (int k = 0; k <= 3; ++ k) {
				int x = i + dx[k], y = j + dy[k];
				if (x < 1 || y < 1 || n < x || m < y || !a[pos(x, y)]) continue;
				int p2 = pos(x, y);
				if (id[p][U] && id[p2][D] && k == 0) AddEdge(id[p][U], id[p2][D], 1, 0);
				if (id[p][D] && id[p2][U] && k == 1) AddEdge(id[p][D], id[p2][U], 1, 0);
				if (id[p][L] && id[p2][R] && k == 2) AddEdge(id[p][L], id[p2][R], 1, 0);
				if (id[p][R] && id[p2][L] && k == 3) AddEdge(id[p][R], id[p2][L], 1, 0);
			}
		}
	Dinic();
	printf("%d", Maxflow == sum1 && sum1 == sum2 ? Mincost / 3 : -1);
}
```

---

## 作者：Bring (赞：6)

[**更好的阅读体验请点这里**](https://www.cnblogs.com/BrianPeng/p/17069195.html)

# Solution of Implementation: P4003 无限之环 费用流建图究极代码简化

## Preface

这是一篇费用流的辅助题解。关于建图的思路和构造，[题解栏目](https://www.luogu.com.cn/problem/solution/P4003) 中的内容可以说是非常的详尽。

然而，这些题解几乎都对 16 种可能性一一建图，而且还要对源汇边分别写。这样下来总共 32 种情况，不仅码量巨大，而且很容易出错。

本文假设读者已经理解建图的规则。本文以 [这篇日报](https://www.luogu.com.cn/blog/wangqianlong463/qian-tan-wang-lao-liu-jian-mu-di-ji-ji-yin-qiao) 的 Part 3.3 中的建图思路为参考。

有没有什么办法可以让代码更简单呢？

---

## 标号法

### 方向标号

我们直接使用题目的标号：记 上，右，下，左 分别为 $0,1,2,3$，那么顺时针旋转几个 $90^\circ$ 就是对应的数字加几然后 $\bmod 4$（毒瘤者可考虑 `&3`）。

对于 $[0,15]$ 中的每一个数字，我们用一个 `vector` 记录这个数字二进制包含 $1$ 的位，从 $0$ 号位开始。

E.g. $11=(1011)_2=2^0+2^1+2^3$，那么 $11$ 对应的 `vector` 就是 $\{0,1,3\}$。


因为在分类讨论时，主要用的是输入状态的二进制中 $1$ 的数量，所以这个 `vector` 的 `size()` 可以直接帮我们判定分类。

```cpp
vector<int>dg[16];
for(i from 0 to 15)for(j from 0 to 3)
    if(i&(1<<j))dg[i].push_back(j);
```

### 点标号

对于每一个格子 $(x,y),x\in[1,n],y\in[1,m]$，我们分出了 5 个点（上，右，下，左，中）。那么我们可以用一个三元组 $(x,y,k)$ 来表示一个点，其中 $k\in[0,4]$。如果 $k\in[0,3]$，则表示对应的方向标记；如果 $k=4$，则表示中点。

E.g. 三元组 $(2,3,3)$ 就表示 $(2,3)$ 格子的左点。

接下来，我们可以把三元组 $(x,y,k)$ 用一个整数 $\text{idx}(x,y,k)=5((x-1)m+y-1)+k$ 标记，这样就把所有的点都唯一地标记为了 $[0,5nm-1]$ 中的一个整数。

---

## $\star$ 连边法 $\star$

基于 $x+y$ 的奇偶性，我们把 $(x,y)$ 分为源点一边或汇点一边。本文将 $x+y$ 为奇数的格子分为源点一边。

对于相邻格子点的连边，因为涉及边界判定和坐标，故不做特殊简化。只要用 $\text{idx}$ 标号函数就可以足够简洁。

为了表示初始状态和旋转，我们会在格子中的 5 个分点之间互相连接容量为 $1$ 的费用边。源点一边和汇点一边会以相反的方式连接。

这促使我们把格子内连边的过程打包为一个函数，让函数接收格子位置，连边的分点和费用，然后根据格子的坐标自行判定连边的方向。

以下的写法中，$(x,y)$ 为格子坐标。在源点一边时，$k$ 为起始方向标记，$l$ 为到达方向标记。$c$ 为费用。`adde(u,v,w,c)` 是标准的费用流连边函数：连接 $u\to v$，容量为 $w$，费用为 $c$，并且加入反向边。

```cpp
void ades(int x,int y,int k,int l,int c){
    ((x+y)&1)?adde(idx(x,y,k),idx(x,y,l),1,c)
        :adde(idx(x,y,l),idx(x,y,k),1,c);
}
```

对于以下的连边法，我们只需要考虑 $(x,y)$ 是源点一边的情况。

### 初始状态

设点 $(x,y)$ 的输入初始状态为 $a\in[0,15]$。那么对于 $a$ 包含的所有方向，也就是 $a$ 的二进制展开中为 $1$ 的方向标号，我们从中点向对应方向的点连接容量为 $1$，费用为 $0$ 的边。

```cpp
for(int k:dg[a])ades(i,j,4,k,0);
```

### 旋转

#### Case 0：不用转

这包含没有水管：$a=0$

都是水管：$a=15$

直线水管：$a=5,10$

可以发现这个情况当且仅当 $a$ 是 $5$ 的倍数，可以直接 $\bmod 5$ 判定。

#### Case 1：一个水管，Q 字型

用 `x=dg[a][0]` 可以直接取出唯一的有水管的方向。

用 $(x+k)\bmod 4$ 可以获得顺时针旋转 $k$ 个 $90^\circ$ 后的方向标号。如果 $k=2$，那么费用为 $2$。如果 $k=1,3$，则费用为 $1$。

所以说旋转 $k$ 的的费用就是 $\text{lowbit}(k)=$ `k&-k` 了！

```cpp
if(dg[a].size()==1){
    int x(dg[a][0]);
    for(k from 1 to 3)ades(i,j,x,(x+k)&3,k&-k);
}
```

#### Case 2：两个水管，L 字型

我们已经排除了直线水管，所以两个水管必然是 L 字型。

每个存在水管的方向 $k$ 要向对面连费用为 $1$ 的边，用 $(k+2)\bmod 4$ 就可以得到对面的标号。

```cpp
for(int k:dg[a])ades(i,j,k,(k+2)&3,1);
```

#### Case 3：三个水管，T 字型

我们只需要知道没水管的是哪个方向。如果输入的是 $a$，那么 $a \text{ xor } 15$ 就可以把没水管的方向标号的二进制位变成 $1$。用 `x=dg[a^15][0]` 直接取出这个方向。

然后用类似 Case 1 的方法连边即可。

```cpp
int x(dg[a^15][0]);
for(k from 1 to 3)ades(i,j,(x+k)&3,x,k&-k);
```

总代码（关于建图的部分仅大约 30 行）：

```cpp
//This program is written by Brian Peng.
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=rd())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int rd(){
    int x;char c(getchar());bool k;
    while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
    c^'-'?(k=1,x=c&15):k=x=0;
    while(isdigit(Gc(c)))x=x*10+(c&15);
    return k?x:-x;
}
void wr(int a){
    if(a<0)Pc('-'),a=-a;
    if(a<=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(int i(a);i<(b);++i)
#define Frn1(i,a,b) for(int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
#define N (10010)
int n,m,s,t,cr[N],d[N],a,cst,s1,s0;
bool vs[N];
struct E{int v,w,c,r;};
vector<E>e[N];
vector<int>dg[16];
void adde(int u,int v,int w,int c);
void ades(int x,int y,int k,int l,int c);
bool spfa();
int dfs(int u,int a);
int mcmf();
int idx(int x,int y,int k){return 5*((x-1)*m+y-1)+k;}
signed main(){
    Rd(n),Rd(m),s=idx(n,m,4)+1,t=s+1;
    //预处理二进制位
    Frn0(i,0,16)Frn0(j,0,4)if(i&(1<<j))dg[i].push_back(j);
    Frn1(i,1,n)Frn1(j,1,m){
        Rd(a);
        if((i+j)&1){
            adde(s,idx(i,j,4),dg[a].size(),0),s1+=dg[a].size();
            //格子间的边
            if(i<n)adde(idx(i,j,2),idx(i+1,j,0),1,0);
            if(i>1)adde(idx(i,j,0),idx(i-1,j,2),1,0);
            if(j<m)adde(idx(i,j,1),idx(i,j+1,3),1,0);
            if(j>1)adde(idx(i,j,3),idx(i,j-1,1),1,0);
        }else adde(idx(i,j,4),t,dg[a].size(),0),s0+=dg[a].size();
        //初始状态，0费边
        for(int k:dg[a])ades(i,j,4,k,0);
        //Case 0: 如果是5的倍数，直接跳
        if(a%5){
            if(dg[a].size()==1){
                //Case 1: Q型
                int x(dg[a][0]);
                Frn1(k,1,3)ades(i,j,x,(x+k)&3,k&-k);
            }else if(dg[a].size()==2){
                //Case 2: L型
                for(int k:dg[a])ades(i,j,k,(k+2)&3,1);
            }else{
                //Case 3: T型
                int x(dg[a^15][0]);
                Frn1(k,1,3)ades(i,j,(x+k)&3,x,k&-k);
            }
        }
    }
    if(s0!=s1||mcmf()<s1)printf("-1"),exit(0);
    wr(cst),exit(0);
}
void adde(int u,int v,int w,int c){
    e[u].push_back({v,w,c,(int)(e[v].size())});
    e[v].push_back({u,0,-c,(int)(e[u].size())-1});
}
//格子内分点加边函数
void ades(int x,int y,int k,int l,int c){
    ((x+y)&1)?adde(idx(x,y,k),idx(x,y,l),1,c)
        :adde(idx(x,y,l),idx(x,y,k),1,c);
}
bool spfa(){
    Mst(d,0x3f),d[s]=0,vs[s]=1;
    queue<int>q({s});
    while(!q.empty()){
        int u(q.front());
        q.pop(),vs[u]=0;
        for(E i:e[u])if(i.w&&d[i.v]>d[u]+i.c){
            d[i.v]=d[u]+i.c;
            if(!vs[i.v])q.push(i.v),vs[i.v]=1;
        }
    }
    return d[t]<INF;
}
int dfs(int u,int a){
    #define V e[u][i].v
    #define W e[u][i].w
    #define C e[u][i].c
    if(u==t||!a)return a;
    vs[u]=1;
    int tot(0),tmp;
    for(int&i(cr[u]);i<e[u].size();++i)if(!vs[V]&&d[u]+C==d[V]){
        tmp=dfs(V,min(a,W));
        if(tmp){
            W-=tmp,cst+=tmp*C,e[V][e[u][i].r].w+=tmp;
            tot+=tmp,a-=tmp;
            if(!a)break;
        }
    }
    vs[u]=0;
    return tot;
}
int mcmf(){
    int f(0);
    while(spfa())Mst(cr,0),f+=dfs(s,INF);
    return f;
}
```

---

## Postscript

能帮助大家减少码量是再好不过了。

Thanks for reading!

---

## 作者：_121017_ (赞：5)

# 思路
看到水管会想到什么？网络流！

看到最小旋转次数会想到什么？最小费用最大流！

这道题我们考虑黑白染色法，把每个点拆成中、上、右、下、左 $5$ 个点，对于每个黑色格子，我们把超级源点连向它的中点；对于每个白色格子，我们把它的中点连向超级汇点。

特别地，对于黑色格子，我们要向周围有水管的格子建边。对于所有有水管的格子，初始方向的点到终点有一条费用为 $0$ 的边。

接下来讨论最恶心的格子内建边（为了方便我们下面用二进制和符号表示）：

---

- $0001$（↑）：把这个格子上点与这个格子的左、下、右点分别连一条费用为 $1$、$2$、$1$ 的边。

- $0010$（→）：把这个格子右点与这个格子的上、左、下点分别连一条费用为 $1$、$2$、$1$ 的边。

- $0011$（↑→）：把这个格子上点与这个格子的下点连一条费用为 $1$ 的边，把右点向左点连一条费用为 $1$ 的边。

- $0100$（↓）：把这个格子下点与这个格子的左、上、右分别连一条费用为 $1$、$1$、$2$ 的边。

- $0101$（↑↓）：不做处理。

- $0110$（↓→）：把这个格子右点与这个格子的左点连一条费用为 $1$ 的边，把下点向上点连一条费用为 $1$ 的边。

- $0111$（↑→↓）：把这个格子上、右、下点分别与左点连一条费用为 $1$、$2$、$1$ 的边。

- $1000$（←）：把这个格子左点与这个格子的上、右、下点分别连一条费用为 $1$、$2$、$2$ 的边。

- $1001$（←↑）：把这个格子上点与这个格子的下点连一条费用为 $1$ 的边，把左点向右点连一条费用为 $1$ 的边。

- $1010$（←→）：不做处理。

- $1011$（←↑→）：把这个格子左、上、右点分别与下点连一条费用为 $1$、$2$、$1$ 的边。

- $1100$（←↓）：把这个格子左点与这个格子的右点连一条费用为 $1$ 的边，把下点向上点连一条费用为 $1$ 的边。

- $1101$（↑←↓）：把这个格子上、左、下点分别与右点连一条费用为 $1$、$2$、$1$ 的边。

- $1111$（←↑↓→）：不做处理。

---
这里是黑格子的建边，然后白格子就是把 $u$、$v$ 交换一下。

然后……

然后就没有了，跑裸的费用流就可以了。

别忘了判断是否满流。
# code
```cpp
#include<bits/stdc++.h>
#define ri register int
#define N 10005
#define M 100005
#define INF 0x3f3f3f3f
using namespace std;
int n,m,s,t;
int a[N][N];
int head[M],w[M],c[M],to[M],next[M],cnt=1;
int dis[N],pre[N],vis[N],in[N],tot,ans;
int maxflow;
bool spfa(){
	memset(dis,INF,sizeof(dis));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	dis[s]=0;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(ri i=head[u];i;i=next[i]){
			int v=to[i];
			if(dis[v]>dis[u]+c[i]&&w[i]){
				dis[v]=dis[u]+c[i];
				pre[v]=i;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
		vis[u]=0;
	}
	return dis[t]!=INF;
}
int dfs(){
	int p,minn=INF,ans=0;
	for(ri u=t;u!=s;u=to[p^1]){
		p=pre[u];
		minn=min(minn,w[p]);
	}
	for(ri u=t;u!=s;u=to[p^1]){
		p=pre[u];
		w[p]-=minn;
		w[p^1]+=minn;
		ans+=minn*c[p];
	}
	maxflow+=minn;
	return ans;
}
int dinic(){
	int ans=0;
	while(spfa()){
		ans+=dfs();
	}
	return ans;
}
bool ok(int x,int y){
	return (x>0&&y>0&&x<=n&&y<=m);
}
int hsh(int x,int y,int k){
	return (x-1)*m+y+m*n*k;
}
void add(int u,int v,int k,int d){
	cnt++;
	w[cnt]=k;
	to[cnt]=v;
	c[cnt]=d;
	next[cnt]=head[u];
	head[u]=cnt;
}
void addh(int u,int v,int k,int d){
	add(u,v,k,d);
	add(v,u,0,-d);
}
void addr(int u,int v,int k,int d){
	addh(v,u,k,d);
}
int main(){
	cin>>n>>m; 
	s=n*m*5+1;
	t=s+1;
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=m;j++){
			if((i+j)%2){
				addh(s,hsh(i,j,0),INF,0);
				if(ok(i-1,j)){
					addh(hsh(i,j,1),hsh(i-1,j,3),1,0);
				}
				if(ok(i,j-1)){
					addh(hsh(i,j,4),hsh(i,j-1,2),1,0);
				}
				if(ok(i+1,j)){
					addh(hsh(i,j,3),hsh(i+1,j,1),1,0);
				}
				if(ok(i,j+1)){
					addh(hsh(i,j,2),hsh(i,j+1,4),1,0);
				}
				for(int k=1;k<=4;k++){
					if(a[i][j]&(1<<(k-1))){
						addh(hsh(i,j,0),hsh(i,j,k),1,0);
						tot++;
					}	
				}
				if(a[i][j]==1){//0001 
					addh(hsh(i,j,1),hsh(i,j,2),1,1);
					addh(hsh(i,j,1),hsh(i,j,3),1,2);
					addh(hsh(i,j,1),hsh(i,j,4),1,1);
				}
				if(a[i][j]==2){//0010
					addh(hsh(i,j,2),hsh(i,j,1),1,1);
					addh(hsh(i,j,2),hsh(i,j,3),1,1);
					addh(hsh(i,j,2),hsh(i,j,4),1,2);
				}
				if(a[i][j]==3){//0011
					addh(hsh(i,j,1),hsh(i,j,3),1,1);
					addh(hsh(i,j,2),hsh(i,j,4),1,1);
				}
				if(a[i][j]==4){//0100
					addh(hsh(i,j,3),hsh(i,j,1),1,2);
					addh(hsh(i,j,3),hsh(i,j,2),1,1);
					addh(hsh(i,j,3),hsh(i,j,4),1,1);
				}
				if(a[i][j]==5);//0101
				if(a[i][j]==6){//0110
					addh(hsh(i,j,3),hsh(i,j,1),1,1);
					addh(hsh(i,j,2),hsh(i,j,4),1,1);
				}
				if(a[i][j]==7){//0111
					addh(hsh(i,j,1),hsh(i,j,4),1,1);
					addh(hsh(i,j,2),hsh(i,j,4),1,2);
					addh(hsh(i,j,3),hsh(i,j,4),1,1);
				}
				if(a[i][j]==8){//1000
					addh(hsh(i,j,4),hsh(i,j,1),1,1);
					addh(hsh(i,j,4),hsh(i,j,2),1,2);
					addh(hsh(i,j,4),hsh(i,j,3),1,1);
				}
				if(a[i][j]==9){//1001
					addh(hsh(i,j,1),hsh(i,j,3),1,1);
					addh(hsh(i,j,4),hsh(i,j,2),1,1);
				}
				if(a[i][j]==10);//1010
				if(a[i][j]==11){//1011
					addh(hsh(i,j,1),hsh(i,j,3),1,2);
					addh(hsh(i,j,2),hsh(i,j,3),1,1);
					addh(hsh(i,j,4),hsh(i,j,3),1,1);
				}
				if(a[i][j]==12){//1100
					addh(hsh(i,j,4),hsh(i,j,2),1,1);
					addh(hsh(i,j,3),hsh(i,j,1),1,1);
				}
				if(a[i][j]==13){//1101
					addh(hsh(i,j,1),hsh(i,j,2),1,1);
					addh(hsh(i,j,3),hsh(i,j,2),1,1);
					addh(hsh(i,j,4),hsh(i,j,2),1,2);
				}
				if(a[i][j]==14){//1110
					addh(hsh(i,j,2),hsh(i,j,1),1,1);
					addh(hsh(i,j,3),hsh(i,j,1),1,2);
					addh(hsh(i,j,4),hsh(i,j,1),1,1);
				}
				if(a[i][j]==15);//1111
			}else{
				addh(hsh(i,j,0),t,INF,0);
				for(int k=1;k<=4;k++){
					if(a[i][j]&(1<<(k-1))){
						addr(hsh(i,j,0),hsh(i,j,k),1,0);
						tot++;
					}	
				}
				if(a[i][j]==1){//0001 
					addr(hsh(i,j,1),hsh(i,j,2),1,1);
					addr(hsh(i,j,1),hsh(i,j,3),1,2);
					addr(hsh(i,j,1),hsh(i,j,4),1,1);
				}
				if(a[i][j]==2){//0010
					addr(hsh(i,j,2),hsh(i,j,1),1,1);
					addr(hsh(i,j,2),hsh(i,j,3),1,1);
					addr(hsh(i,j,2),hsh(i,j,4),1,2);
				}
				if(a[i][j]==3){//0011
					addr(hsh(i,j,1),hsh(i,j,3),1,1);
					addr(hsh(i,j,2),hsh(i,j,4),1,1);
				}
				if(a[i][j]==4){//0100
					addr(hsh(i,j,3),hsh(i,j,1),1,2);
					addr(hsh(i,j,3),hsh(i,j,2),1,1);
					addr(hsh(i,j,3),hsh(i,j,4),1,1);
				}
				if(a[i][j]==5);//0101
				if(a[i][j]==6){//0110
					addr(hsh(i,j,3),hsh(i,j,1),1,1);
					addr(hsh(i,j,2),hsh(i,j,4),1,1);
				}
				if(a[i][j]==7){//0111
					addr(hsh(i,j,1),hsh(i,j,4),1,1);
					addr(hsh(i,j,2),hsh(i,j,4),1,2);
					addr(hsh(i,j,3),hsh(i,j,4),1,1);
				}
				if(a[i][j]==8){//1000
					addr(hsh(i,j,4),hsh(i,j,1),1,1);
					addr(hsh(i,j,4),hsh(i,j,2),1,2);
					addr(hsh(i,j,4),hsh(i,j,3),1,1);
				}
				if(a[i][j]==9){//1001
					addr(hsh(i,j,1),hsh(i,j,3),1,1);
					addr(hsh(i,j,4),hsh(i,j,2),1,1);
				}
				if(a[i][j]==10);//1010
				if(a[i][j]==11){//1011
					addr(hsh(i,j,1),hsh(i,j,3),1,2);
					addr(hsh(i,j,2),hsh(i,j,3),1,1);
					addr(hsh(i,j,4),hsh(i,j,3),1,1);
				}
				if(a[i][j]==12){//1100
					addr(hsh(i,j,4),hsh(i,j,2),1,1);
					addr(hsh(i,j,3),hsh(i,j,1),1,1);
				}
				if(a[i][j]==13){//1101
					addr(hsh(i,j,1),hsh(i,j,2),1,1);
					addr(hsh(i,j,3),hsh(i,j,2),1,1);
					addr(hsh(i,j,4),hsh(i,j,2),1,2);
				}
				if(a[i][j]==14){//1110
					addr(hsh(i,j,2),hsh(i,j,1),1,1);
					addr(hsh(i,j,3),hsh(i,j,1),1,2);
					addr(hsh(i,j,4),hsh(i,j,1),1,1);
				}
				if(a[i][j]==15);//1111
			}
		}
	}
	int ans=dinic();
	if(maxflow*2==tot){
		cout<<ans;
	}else{
		cout<<-1;
	}
	return 0;
}
```

---

## 作者：disangan233 (赞：4)

## 题意简述

有一个 $n\times m$ 棋盘，棋盘上每个格子上有一个水管。水管共有$16$种，用一个 $4$ 位二进制数来表示当前水管向上、右、下、左有个接口。你可以旋转除了 $(0101)_2$ 和 $(1010)_2$ 的其他水管,求最少的旋转次数使得水管的每一个接口所在方向都有一个相邻的水管接口与其对应。

## 做法

这种插头相关的题一般都是网络流，~~虽然据说插头 dp 可以过此题~~。这道题里面要求不存在单独的接口，所有的接口一一对应等价于流量平衡，那么最少的旋转次数就应该想到费用流。

首先把整个棋盘染色，黑点连源点，白格连汇点，这些源汇点的节点流量限制为自己的格子内的接头数。那么如果流量网络满流，那就是此题有解，可以构成流量平衡的情况。

对于每个格子，上下左右拆成四个点，表示这个格子的 $4$ 个方向，他们的节点容量为 $1$ ，用来象征对应接口的流量平衡。

对于一开始不能到达的方向，从初始方向连边至目标方向，费用为最少旋转次数，这样无论怎么旋转，接口对应关系依然存在。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register int
#define in inline 
#define ak *
#define inf 1e9
#define loc(i,j) ((i-1)*m+j)
int col,cnt=1,n,m,s,t,h[10005],dis[10005],l,r,q[10005],pre[10005],vis[10005],mp[10005],ans,maxflow,preflow;
struct did{
	int u,next,to,f,w;
}e[1200005];
char qwq;
in int read()
{
	int yz=0,ioi=1;qwq=getchar();
	while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=getchar();
	while(qwq>='0'&&qwq<='9') yz=(yz<<3)+(yz<<1)+(qwq^48),qwq=getchar();
	return yz ak ioi;
}
in void add(re a,re b,re c,re d)
{
	if(!col) swap(a,b);
	e[++cnt]=(did){a,h[a],b,c,d},h[a]=cnt;
	e[++cnt]=(did){b,h[b],a,0,-d},h[b]=cnt;
}
int spfa()
{
	memset(pre,0,sizeof(pre));memset(vis,0,sizeof(vis));
	for(re i=s;i<=t;i++) dis[i]=i==s?0:inf;
	queue<int>q;q.push(s);vis[s]=1;
	while(!q.empty())
	{
		re i=q.front();vis[i]=0;q.pop();
		for(re j=h[i],k;k=e[j].to,j;j=e[j].next)
		if(e[j].f&&dis[k]>dis[i]+e[j].w)
		{
			dis[k]=dis[i]+e[j].w;pre[k]=j;
			if(!vis[k]) q.push(k),vis[k]=1;
		}
	}	
	return dis[t]<inf;
}
in void solve()
{
	re delta=inf;
	for(re i=t,p;p=pre[i],i!=s;i=e[p^1].to)
	delta=min(delta,e[p].f);
	for(re i=t,p;p=pre[i],i!=s;i=e[p^1].to)
	e[p].f-=delta,e[p^1].f+=delta;
	maxflow+=delta;ans+=delta*dis[t];
}
in int f(re i,re j) {return i*(n*m+1)+j;}
in int g(re i,re j) {return (i-1)*m+j;}
in bool ok(re i,re j) {return (i>=1&&i<=n&&j>=1&&j<=m);}
in void turn(re p,re x,re y,re z) {add(f(x,p),f(y,p),1,z);}
int main()
{
//	freopen("infinityloop.in","r",stdin);
//	freopen("infinityloop.out","w",stdout);
	n=read(),m=read(); s=0;t=4*(n*m+1)+4;
	for(re i=1;i<=n;i++) for(re j=1;j<=m;j++) mp[g(i,j)]=read();
	for(re i=1;i<=n;i++) for(re j=1;j<=m;j++)
	{
		re p=g(i,j);col=(i+j)%2;
		if(col)
		{
			for(re k=0;k<=3;k++) 
			if((mp[p]>>k)&1) add(s,f(k,p),1,0),preflow++;
		}
		else
		{
			for(re k=0;k<=3;k++) 
			if((mp[p]>>k)&1) add(t,f(k,p),1,0);
		}
		if(col)
        {
            if(ok(i-1,j)) add(f(0,p),f(2,g(i-1,j)),1,0);
            if(ok(i,j+1)) add(f(1,p),f(3,g(i,j+1)),1,0);
            if(ok(i+1,j)) add(f(2,p),f(0,g(i+1,j)),1,0);
            if(ok(i,j-1)) add(f(3,p),f(1,g(i,j-1)),1,0);
        }
        switch(mp[p])
        {
			case 0: break; // 0000
			case 5: break; // 0101
			case 10: break; // 1010
			case 15: break; // 1111
			case 1: turn(p,0,1,1);turn(p,0,2,2);turn(p,0,3,1);break; // 0001
			case 2: turn(p,1,0,1);turn(p,1,3,2);turn(p,1,2,1);break; // 0010
			case 4: turn(p,2,1,1);turn(p,2,0,2);turn(p,2,3,1);break; // 0100
			case 8: turn(p,3,0,1);turn(p,3,1,2);turn(p,3,2,1);break; // 1000
			case 3: turn(p,0,2,1);turn(p,1,3,1);break; // 0011
			case 6: turn(p,1,3,1);turn(p,2,0,1);break; // 0110
			case 9: turn(p,0,2,1);turn(p,3,1,1);break; // 1001
			case 12: turn(p,2,0,1);turn(p,3,1,1);break; // 1100
			case 7: turn(p,0,3,1);turn(p,1,3,2);turn(p,2,3,1);break; // 0111
			case 11: turn(p,0,2,2);turn(p,1,2,1);turn(p,3,2,1);break; // 1011
			case 13: turn(p,0,1,1);turn(p,2,1,1);turn(p,3,1,2);break; // 1101
			case 14: turn(p,3,0,1);turn(p,2,0,2);turn(p,1,0,1);break; // 1110
		}
	}
	while(spfa()) solve();
	if(maxflow!=preflow) return puts("-1"),0;
	cout<<ans<<endl;
}

```




---

## 作者：eee_hoho (赞：3)

题目：https://www.luogu.com.cn/problem/P4003

简明题意：给你一个矩阵，每个格子都有一种水管，每种水管可以向上下左右这四个方向中的若干个给定的方向延伸，每次可以将一个格子的水管顺或逆时针旋转90°，问使水管全部闭合的最小操作次数。

看起来就非常的可以最小费用最大流。

既然是矩阵，那么肯定要黑白染色，向源点连白点，向汇点连黑点，然后我们考虑拆点，每个格子多拆四个接口方向的点，这样可以表示出来现在水管的状态，对于旋转可以分情况讨论。

- 只有一个方向的点：该方向和和它相对的方向连费用为2的边，说明需要旋转2次；剩下的两个方向连费用为1的边，只需要旋转1次。
- 有两个方向的边：这两个方向分别和和该方向相对的边连费用为1的边，旋转1次的可以表示；旋转2次的可以通过都流这两个边表示。
- 有三个方向的边：将有相对边的边和对边连费用为2的边，说明需要旋转2次；剩下的两个边向没有方向的边连费用为1的边，只需要旋转1次。
- 四个方向的边不需要旋转，只有对着的方向的边不能旋转。

相邻的格子在对应方向上连边。

然后我们记录下所有格子方向的个数和$tot$，$tot/2=flow$说明有解，因为两个水管的接口合上成一个了，否则无解。

刚才的连边过程实际上是把旋转中重合的边略去了，画画图就可以很好理解了。

我是分情况讨论的，没有用也不会用什么高超的位运算技巧QAQ

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
const int N = 2e3;
const int M = 114514;
const int inf = 19260817;
using namespace std;
struct edges
{
	int to,cost,f;
}edge[M * 2 + 5];
int nc,tot,num[M + 5],mf,p[M + 5],n,m,a[N + 5],ans,mp[N + 5][N + 5],id[N + 5][N + 5],id_cnt,co[N + 5][N + 5],S,T,nxt[M + 5],head[M + 5],edge_cnt = 1,dis[M + 5],vis[M + 5],q[M + 5],cur[M + 5];
void add_edge(int u,int v,int w,int f)
{
	edge[++edge_cnt] = (edges){v,w,f};
	nxt[edge_cnt] = head[u];
	head[u] = edge_cnt;
}
void add(int u,int v,int w,int f)
{
	if (!nc)
		swap(u,v);
	add_edge(u,v,w,f);
	add_edge(v,u,0,-f);
}
void add_chai(int S,int x)
{
	add(S,x * 5,inf,0);
	if (a[x] & 1)
		add(x * 5,x * 5 + 1,1,0);
	if (a[x] & 2)
		add(x * 5,x * 5 + 2,1,0);
	if (a[x] & 4)
		add(x * 5,x * 5 + 3,1,0);
	if (a[x] & 8)
		add(x * 5,x * 5 + 4,1,0);	
}
void rev(int x)
{
	if (a[x] == 1)
		add(x * 5 + 1,x * 5 + 2,1,1),add(x * 5 + 1,x * 5 + 4,1,1),add(x * 5 + 1,x * 5 + 3,1,2);
	else
	if (a[x] == 2)
		add(x * 5 + 2,x * 5 + 1,1,1),add(x * 5 + 2,x * 5 + 3,1,1),add(x * 5 + 2,x * 5 + 4,1,2);
	else
	if (a[x] == 3)
		add(x * 5 + 1,x * 5 + 3,1,1),add(x * 5 + 2,x * 5 + 4,1,1);
	else
	if (a[x] == 4)
		add(x * 5 + 3,x * 5 + 2,1,1),add(x * 5 + 3,x * 5 + 4,1,1),add(x * 5 + 3,x * 5 + 1,1,2);
	else
	if (a[x] == 6)
		add(x * 5 + 3,x * 5 + 1,1,1),add(x * 5 + 2,x * 5 + 4,1,1);
	else
	if (a[x] == 7)
		add(x * 5 + 2,x * 5 + 4,1,2),add(x * 5 + 1,x * 5 + 4,1,1),add(x * 5 + 3,x * 5 + 4,1,1);
	else
	if (a[x] == 8)
		add(x * 5 + 4,x * 5 + 1,1,1),add(x * 5 + 4,x * 5 + 3,1,1),add(x * 5 + 4,x * 5 + 2,1,2);
	else
	if (a[x] == 9)
		add(x * 5 + 1,x * 5 + 3,1,1),add(x * 5 + 4,x * 5 + 2,1,1);
	else
	if (a[x] == 11)
		add(x * 5 + 1,x * 5 + 3,1,2),add(x * 5 + 4,x * 5 + 3,1,1),add(x * 5 + 2,x * 5 + 3,1,1);
	else
	if (a[x] == 12)
		add(x * 5 + 4,x * 5 + 2,1,1),add(x * 5 + 3,x * 5 + 1,1,1);
	else
	if (a[x] == 13)
		add(x * 5 + 4,x * 5 + 2,1,2),add(x * 5 + 1,x * 5 + 2,1,1),add(x * 5 + 3,x * 5 + 2,1,1);
	else
	if (a[x] == 14)
		add(x * 5 + 3,x * 5 + 1,1,2),add(x * 5 + 4,x * 5 + 1,1,1),add(x * 5 + 2,x * 5 + 1,1,1);
}
int dfs(int u,int flow)
{
	if (u == T)
		return flow;
	int sum = 0;
	p[u] = 1;
	for (int &i = cur[u];i;i = nxt[i])
	{
		int v = edge[i].to,w = edge[i].cost,f = edge[i].f;
		if (w && dis[u] + f == dis[v] && !p[v])
		{
			int res = dfs(v,min(flow,w));
			edge[i].cost -= res;
			edge[i ^ 1].cost += res;
			flow -= res;
			sum += res;
			mf += res * f;
			if (!flow)
				break;
		}
	}
	return sum;
}
int spfa()
{
	for (int i = 1;i <= id_cnt * 5 + 4;i++)
		cur[i] = head[i],vis[i] = 0,dis[i] = inf,p[i] = 0;
	dis[S] = 0;
	vis[S] = 1;
	int l = 1,r = 0;
	q[++r] = S;
	while (l <= r)
	{
		int u = q[l++];
		vis[u] = 0;
		for (int i = head[u];i;i = nxt[i])
		{
			int v = edge[i].to,w = edge[i].cost,f = edge[i].f;
			if (w && dis[u] + f < dis[v])
			{
				dis[v] = dis[u] + f;
				if (!vis[v])
				{
					q[++r] = v;
					vis[v] = 1;
				}
			}
		}
	}
	return dis[T];
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
			id[i][j] = ++id_cnt,co[i][j] = (i + j) % 2;
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
			scanf("%d",&a[id[i][j]]);
	for (int i = 1;i <= 15;i++)
		for (int j = 0;j < 4;j++)
			if (i & (1 << j))
				num[i]++;
	S = 1;
	T = 2;
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
		{
			nc = co[i][j];
			if (co[i][j] == 1)
				add_chai(S,id[i][j]);
			else
				add_chai(T,id[i][j]);
			tot += num[a[id[i][j]]];
			rev(id[i][j]);
			if (id[i - 1][j])
				add(id[i][j] * 5 + 1,id[i - 1][j] * 5 + 3,1,0);
			if (id[i][j - 1])
				add(id[i][j] * 5 + 4,id[i][j - 1] * 5 + 2,1,0);		
		}
	int ans = 0;
	while (spfa() != inf)
		ans += dfs(S,inf);
	if (tot / 2 == ans)
		printf("%d\n",mf);
	else
		printf("-1\n");
	return 0;
}
```

---

## 作者：_Arahc_ (赞：2)

你谷带思维题。

## 题面

题目传送门：[Link to Luogu](https://www.luogu.com.cn/problem/P4003)。

> 给定 $n\times m$ 的网格，网格上有些水管（水管样式见原题）。求最少旋转水管（不能旋转直线型管道）次数使其不会漏水，或判断无解。一次旋转只能旋转 $90^\circ$ 而不能一次旋转 $180^\circ$。
>
> $nm\leqslant 2000$。

（我才不会告诉你我把 $nm\leqslant 2000$ 看成 $n,m\leqslant 2000$ 以至于我开题解的时候都在质疑题解复杂度正确性。）

## 题解

下文的配图全部来自原题的图，拆解出每个管子之后在 Excel 里面拼起来。很多接口可能没对齐 QAQ。

### 不会旋转

我们先来考虑一个不会漏水的情况：

![](https://pic.imgdb.cn/item/62157d6b2ab3f51d918beb8d.png)

（为什么画一个这个图？它好就好在所有样式的管子都用过……）

然后你会发现很难有什么思路。但是如果考虑网络流，不难得到所谓“不会漏水”的条件，可以转化为一个满流的问题，即每个水管（的分支口）容量都为 $1$，最终要保证满流。

于是我们先考虑如何对一个不需要旋转的图建模，使得这个图的每个水管的支口满流。可以考虑拆点，如果你和我一样 naive 地把一个点拆成上下左右四个，你发现是完全不可行的。于是我们把一个点拆成：上、下、左、右、中五个点。其中上、下、左、右是“连接点”，负责和别的格子相连，中间点是“主要点”，负责接口源/汇点，并根据水管形状向连接点连边。

然后考虑如何定向、如何分布源汇点，考虑将格子黑白染色，黑色格子由源点连向其主要点，白色格子的主要点连向其汇点。就可以保证最大流下接口都有流量了。

于是关于上面这个图，我们可以得到下面的建边：

![](https://pic.imgdb.cn/item/6215853a2ab3f51d9196142e.png)

当然这里忽略了一些没有用到的连接点，而且相邻两个点的重合的连接点只画了一个……这都是代码实现的细节，这张图足以解释问题。

将源点连接到所有的紫色点，容量为无限；将所有黄色点连接到汇点，容量为无限；所有图中的黑色边容量为 $1$。那么这张图的最大流就是每个接口满流的。

### 怎么转

注意到十字形的管道转不转都是一样的，所以不需要考虑十字形管道怎么转。还要注意题面中写到了直线型管道不能转。

因此，我们把这个图改造一下，分别考虑如何旋转 Q 型、T 型、L 型管道。

![](https://pic.imgdb.cn/item/6215894d2ab3f51d919c14aa.png)

因为“流量”已经用来判是否满流（有解）了，因此我们只能加一个“费用”来代表旋转次数。

可以明确的是，当前图上所有的边（黑色边、源/汇点与紫/黄色点的连边）费用都是 $0$。这是不需要旋转就能得到的局面。

另外，因为同种类的水管，连边方式是等价的。因此在本文中我们只讨论按照上面这个图里被打乱的方向考虑。对于同类型、不同方向的水管，转一下就可以了，本质是一样的。当然还要注意连边方向和黑白染色对应的颜色有关。

例如上图，我们应该要加入一些有费用的边（下图中橙色的边），使其变为一个能满流的图。不难发现应该是如下的情况：

![](https://pic.imgdb.cn/item/62158cda2ab3f51d91a19d9d.png)

然后就对着这个图开始分讨吧 =.=

------

#### Q 型

见上图中第三行第三列，我们以朝上的 Q 型水管为例子讨论。

因为只有一个接口，这很好做。往左、往右都是旋转一次，往下需要旋转两次。因此从上连接点向左、右连接点连接流量 $1$，费用 $1$ 的边；向下连接点连接流量 $1$，费用 $2$ 的边。

#### L 型

见上图中第一行第四列，我们以连接右、下两个两个方向的 L 型水管为例子讨论。

我们考虑将其旋转为连接左、下两个方向的水管，可以视为下面的水管没动，把右边的水管接到左边来。而旋转到右、上方向同理。因此从右连接点向左连接点连流量 $1$，费用 $1$ 的边，下连接点向上连接点连流量 $1$，费用 $1$ 的边。

如果要旋转到左、上方向？相当于下面的水管接到上面、右边的水管接到左边。恰好是上述两个连边方向的总和，不需要额外考虑。

### T 型

见上图第而行第一列，我们以下端没有接口的 T 型水管为例子讨论。

如果要把它变成左端或右端没有接口的水管，只需要旋转一次就可以了；如果要变成上端没有接口的水管，则需要旋转两次。因此由下连接点向左、右连接点连流量 $1$，费用 $1$ 的边；向上连接点连流量 $1$，费用 $2$ 的边。

------

于是所有的情况都已经讨论完了，建完边之后，跑一遍最小费用最大流。若没有满流，则说明无解；否则旋转次数就是最小费用。

建模实在难写、情况真多……

## 代码

代码很长，酌情阅读。

我也是人傻常数大，开 O2 才能过……

[Link](https://www.luogu.com.cn/paste/vx9ui5mm)。

---

## 作者：KAMIYA_KINA (赞：2)

## Tag

状态压缩，动态规划。

## Preface

碎碎念：

考场上看到这个题的一瞬间想到了要费用流，但是不会建图。

刚刚准备自闭的时候突然发现好像可以状态压缩。

状压打完了发现这玩意状态好少啊……

果然拿个 map 存一下就过了……

## Description

[题面](https://www.luogu.com.cn/problem/P4003)

给定一个 $n \times m$ 的网格图，有 $15$ 种形状的水管排布在里面，需要这些水管互相相连，每次可以转动 $90^\circ$，求最少的操作次数。

$\texttt{data range}: n\times m \leq 2\times 10^3$.

## Solution

对于本题的费用流解法笔者不想在这里赘述，这个地方讨论的是本题的**状态压缩**解法。

我们很容易想出来一个 $O(nm2^{\min(n,m)})$ 的部分分做法，也就是本题 40pts 的部分分，也就是用轮廓线 dp 来转移状态，可以设一个 01 状态为一个棋盘的轮廓线形状，令 $2^i$ 为第 $i$ 个位置是否有向下插的管子，$2^0$ 为有没有向右插的管子，然后直接转移就可以做出部分分了。

但是笔者在考场上写不出费用流的情况下写了一个状态压缩，然后仔细一想……

初始状态一个，转移出来的状态难道会很多吗？

于是不严谨的估计了一下我们题目所能够转移出来的状态数量，我们粗略的考虑每一种情况会转移出多少种状态以及其可以接受多少种合法的状态。

不难发现一个格子只能接受最多四种与其直接相关的状态，也就是其上面有没有管子，其左边有没有管子这四种状态，我们用 $0/1,0/1$  来表示这些状态。

再对于所有的情况分类讨论，

1. 一个接口的统一讨论。不难发现其可以接受 $01,10,00$ 这 $3$ 种状态，对于前两种状态，其只能导出一个状态。对于最后一个状态可以导出 $2$ 种状态。所以这个情况可以是**状态增加点**，也可以是**状态减少点**。
2. 对于一个杠杠的分别只能接受一种状态和导出一种状态，所以一定是**状态减少点**。
3. 对于一个弯道的情况统一讨论，不难发现其可以接受所有的状态，但是对于每种状态只能导出一种状态，所以是**状态不变点**，只会对答案造成影响。
4. 对于一个三个道的情况统一讨论，不难发现其可以接受 $10,01,11$ 这三种状态。相同的，对于前两种状态只能导出一种状态，最后一个可以导出两种状态，所以是即是**状态增加点**，也是**状态减少点**。
5. 对于十字路口，其只能接受一种状态并且导出一种状态，所以一定是**状态减少点**。

最后我们发现了，只有 $1$ 情况和 $4$ 情况会增大状态。

我们大胆猜测，他的数据很扯淡，所以你用个 map 存一下状态然后就过了……还跑的飞快。

实际上我们想要卡这个做法也非常简单，只用第一行全都是第一种状态就可以把这个做法卡到上界，但是实际上估计出题人实在是没有想到还有这种人类智慧做法，所以压根没卡。

事实上 UOJ 上面有数据 hack 了这种做法，还是希望大家练习的时候多学正解~~考试的时候多写乱搞~~，这样就可以提高自己的实力了！

## Code

给出我乱搞的代码。

```cpp
using ll = long long;

const int INF = 1e9;
const int N = 2e3 + 10 ;

int n, m;
int a[N][N];

bool up(const int x) {return x & 1;}
bool ri(const int x) {return (x >> 1) & 1;}
bool dn(const int x) {return (x >> 2) & 1;}
bool le(const int x) {return (x >> 3) & 1;}//上下左右
int l90(const int x) {return (x >> 1) | ((x & 1) << 3);}
int r90(const int x) {return ((x << 1) & 15) | ((x >> 3) & 1);}
int t18(const int x) {
    return (dn(x) << 0) | (le(x) << 1) | (up(x) << 2) | (ri(x) << 3);
}//旋转
bool sps(const int x) { return x == 5 || x == 10; }//直线型特判

int b[N][N];
void rotate() {
    FOR(i, 1, n) FOR(j, 1, m) b[m - j + 1][i] = l90(a[i][j]);
    swap(n, m);
    memset(a, 0, sizeof(a));
    FOR(i, 1, n) FOR(j, 1, m) a[i][j] = b[i][j];
    return ;
}

inline void input() {
    n = rd, m = rd;
    FOR(i, 1, n) FOR(j, 1, m) a[i][j] = rd;
    return ;
}

inline ll To(ll x, ll S, int pos) {
    if(((S >> pos) & 1) ^ up(x)) return -1;
    if((S & 1) ^ le(x)) return -1;
    if(pos == m && ri(x)) return -1;
    ll ret = (((ll) 1ll << pos) ^ -1ll) & S;
    ret = ret & (1ll ^ -1ll);
    return ret | ((ll)dn(x) << pos) | ri(x);
}
unordered_map<ll, int> f, g;

inline void work() {
    if(n < m) rotate();
    f[0] = 0;
    FOR(i, 1, n) FOR(j, 1, m) {
        for(auto x : f) {
            if(x.second == INF) continue;
            int w = a[i][j];
            ll S = x.first, tem;
            tem = To(w, S, j);
            if(~tem) {
                auto it = g.insert(make_pair(tem, INF));
                cmin(it.first->second, x.second);
            }
            if(sps(w)) continue;
            
            tem = To(l90(w), S, j);
            if(~tem) {
                auto it = g.insert(make_pair(tem, INF));
                cmin(it.first->second, x.second + 1);
            }
            
            tem = To(r90(w), S, j);
            if(~tem) {
                auto it = g.insert(make_pair(tem, INF));
                cmin(it.first->second, x.second + 1);
            }
            
            tem = To(t18(w), S, j);
            if(~tem) {
                auto it = g.insert(make_pair(tem, INF));
                cmin(it.first->second, x.second + 2);
            }
        }
        f.clear(), f.swap(g);
    }
    auto it = f.insert(make_pair(0, INF));
    if(it.second) cout << -1 << '\n';
    else cout << it.first->second << '\n';
    return ;
}

inline void solve() {
    input();
    work();
    return ;
}
```

## Final

* 出题人：如果直线型水管可以旋转，如何建图？
* KAMIYA：你不让我动直线型我不是又要写一个函数来特判，~~淦你娘~~。

---

## 作者：lgswdn_SA (赞：2)

1周前AC的题来补一发题解。

在经过 $n$ 个小时的奋斗后，LsWn 终于 AC 了这个毒瘤题。


（这里的截图都是从原无限之环游戏中截图的……在做这题前体验了一波无限之环。）

[传送门](https://www.luogu.com.cn/problem/P4003)  

我们先看一个正确可以流通的图 （加上了黑白相间染色，然后黄色方块代表这个格子的上方，红色代表下方，紫色是左，灰色是右）（最后一行的上下画反了……凑活凑活）。

![image.png](https://public.noi.top/image/1588644580997.png)

黑白染色网络流一贯的套路，将黑点流向白点，源点流向黑点，白点流向汇点，然后根据拆点一贯的套路，内部连边。（指一个点拆成五个点，中间和上下左右）

显然，合理的方案就是所有的黑点和白点互相匹配，即有完备匹配，也就是满流，没有一滴水漏出来。从黑点流出的点都有去处。

![image.png](https://public.noi.top/image/1588645628919.png)


这是一个合法方案。那么如果出了点小差错，需要旋转呢？

![image.png](https://public.noi.top/image/1588645644232.png)

这就很谔谔，右下角没法连通。但是我们可以旋转。我们观察到，左旋一次，相当于把右插头换成左插头。于是连费用为 $1$ 的边。

右旋一次，相当于把下插头换成上插头，于是连边。。旋转两次，走两次旋转一次，故不连边。

![image.png](https://public.noi.top/image/1588645661591.png)

现在讨论连边情况：

1. 类似于 ┌  
上面已经讲过，不再陈述。
2. 类似于 Q  
如果左/右翻转，那么就等于插头向左/右换。翻转两次就是上下换，左右换。换两次的连边的费用是 $2$。
3. 类似于丨  
不处理，因为不能转。
4. 类似于 T  
和 ┌ 比较相似。不过需要连上下边。  
5 类似于 十  
不处理，因为转了也没用。
    
然后总体 $15$ 种情况还需一一分析……这就很毒瘤。这就放在代码中了。

一些细节：  
1. 不要重复建边！不要重复建边！不要重复建边！（否则你算出来的答案会小于标准答案）  
2. 毒瘤建边题的网络流真的不能码错！真的不能！  
3. hsh 函数一定要注意！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e6+9,inf=0x3f3f3f3f3f3f3f3f;
int n,m,a[2009][2009],debugger;

struct edge{int to,nxt,c,w;}e[N*2]; int hd[N],tot=1;
void add(int u,int v,int c,int w){e[++tot]=(edge){v,hd[u],c,w};hd[u]=tot;}
void addh(int u,int v,int c,int w){
	//cout<<u<<" "<<v<<" "<<c<<" "<<w<<endl;
	debugger+=w;
	add(u,v,c,w),add(v,u,0,-w);
}
void addr(int u,int v,int c,int w){addh(v,u,c,w);}

int s,t,flow,cost,tmp,ans;
int d[N]; bool in[N]; 
bool spfa(){
	queue<int>q; q.push(s); memset(d,0x3f,sizeof(d)); d[s]=0;
	while(!q.empty()){
		int u=q.front(); q.pop(); in[u]=0;
		for(int i=hd[u],v;i;i=e[i].nxt)
			if(e[i].c&&d[v=e[i].to]>d[u]+e[i].w){
				d[v]=d[u]+e[i].w;
				if(!in[v]) q.push(v),in[v]=1;
			}
	}
	return d[t]<inf;
}
int dinic(int u,int flow){
	int rest=flow; if(u==t) return flow; in[u]=1;
	for(int i=hd[u],v;i&&rest;i=e[i].nxt)
		if(!in[v=e[i].to]&&e[i].c&&d[v]==d[u]+e[i].w){
			int used=dinic(v,min(e[i].c,rest));
			if(!used) d[v]=-1;
			rest-=used; e[i].c-=used,e[i^1].c+=used,cost+=used*e[i].w; 
		}
	in[u]=0;
	return flow-rest;
}

// 0:中  1:上  2:右  3:下  4:左 
int hsh(int x,int y,int loc){return (x*m-m+y)+loc*m*n;}
bool ok(int x,int y){return x>0&&x<=n&&y>0&&y<=m;}
signed main(){
	scanf("%lld%lld",&n,&m); s=n*m*5+1,t=n*m*5+2;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%lld",&a[i][j]);

	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		if((i+j)%2){ //黑格子 
			addh(s,hsh(i,j,0),inf,0);
			if(ok(i-1,j))
				addh(hsh(i,j,1),hsh(i-1,j,3),1,0);
			if(ok(i,j+1))
				addh(hsh(i,j,2),hsh(i,j+1,4),1,0);
			if(ok(i+1,j))	
				addh(hsh(i,j,3),hsh(i+1,j,1),1,0);
			if(ok(i,j-1))
				addh(hsh(i,j,4),hsh(i,j-1,2),1,0);
			for(int k=1;k<=4;k++)
				if(a[i][j]&(1ll<<(k-1))){
					addh(hsh(i,j,0),hsh(i,j,k),1,0);
					ans++;
				}
			if(a[i][j]==15);	 //全 
			else if(a[i][j]==1){ //上 
				addh(hsh(i,j,1),hsh(i,j,2),1,1);
				addh(hsh(i,j,1),hsh(i,j,4),1,1);
				addh(hsh(i,j,1),hsh(i,j,3),1,2);
			}
			else if(a[i][j]==2){ //右
				addh(hsh(i,j,2),hsh(i,j,1),1,1);
				addh(hsh(i,j,2),hsh(i,j,3),1,1);
				addh(hsh(i,j,2),hsh(i,j,4),1,2);
			} 
			else if(a[i][j]==3){ //上右 
				addh(hsh(i,j,1),hsh(i,j,3),1,1);
				addh(hsh(i,j,2),hsh(i,j,4),1,1);
			}
			else if(a[i][j]==4){ //下 
				addh(hsh(i,j,3),hsh(i,j,2),1,1);
				addh(hsh(i,j,3),hsh(i,j,4),1,1);
				addh(hsh(i,j,3),hsh(i,j,1),1,2);
			} 
			else if(a[i][j]==5); //上下 
			else if(a[i][j]==6){ //右下 
				addh(hsh(i,j,3),hsh(i,j,1),1,1);
				addh(hsh(i,j,2),hsh(i,j,4),1,1);
			}
			else if(a[i][j]==7){ //上右下 
				addh(hsh(i,j,1),hsh(i,j,4),1,1);
				addh(hsh(i,j,3),hsh(i,j,4),1,1);
				addh(hsh(i,j,2),hsh(i,j,4),1,2);
			}
			else if(a[i][j]==8){ //左 
				addh(hsh(i,j,4),hsh(i,j,1),1,1);
				addh(hsh(i,j,4),hsh(i,j,3),1,1);
				addh(hsh(i,j,4),hsh(i,j,2),1,2);
			}
			else if(a[i][j]==9){ //上左 
				addh(hsh(i,j,1),hsh(i,j,3),1,1);
				addh(hsh(i,j,4),hsh(i,j,2),1,1); 
			}
			else if(a[i][j]==10);//右左 
			else if(a[i][j]==11){//上右左 
				addh(hsh(i,j,2),hsh(i,j,3),1,1);
				addh(hsh(i,j,4),hsh(i,j,3),1,1);
				addh(hsh(i,j,1),hsh(i,j,3),1,2);
			}
			else if(a[i][j]==12){//下左 
				addh(hsh(i,j,3),hsh(i,j,1),1,1);
				addh(hsh(i,j,4),hsh(i,j,2),1,1); 
			}
			else if(a[i][j]==13){//上下左 
				addh(hsh(i,j,1),hsh(i,j,2),1,1);
				addh(hsh(i,j,3),hsh(i,j,2),1,1);
				addh(hsh(i,j,4),hsh(i,j,2),1,2);
			}
			else if(a[i][j]==14){//右下左 
				addh(hsh(i,j,2),hsh(i,j,1),1,1);
				addh(hsh(i,j,4),hsh(i,j,1),1,1);
				addh(hsh(i,j,3),hsh(i,j,1),1,2);
			}
		}
		else{
			addh(hsh(i,j,0),t,inf,0);
			for(int k=1;k<=4;k++)
				if(a[i][j]&(1<<(k-1))){
					addr(hsh(i,j,0),hsh(i,j,k),1,0);
					ans++;
				}
			if(a[i][j]==15);	 //全 
			else if(a[i][j]==1){ //上 
				addr(hsh(i,j,1),hsh(i,j,2),1,1);
				addr(hsh(i,j,1),hsh(i,j,4),1,1);
				addr(hsh(i,j,1),hsh(i,j,3),1,2);
			}
			else if(a[i][j]==2){ //右
				addr(hsh(i,j,2),hsh(i,j,1),1,1);
				addr(hsh(i,j,2),hsh(i,j,3),1,1);
				addr(hsh(i,j,2),hsh(i,j,4),1,2);
			} 
			else if(a[i][j]==3){ //上右 
				addr(hsh(i,j,1),hsh(i,j,3),1,1);
				addr(hsh(i,j,2),hsh(i,j,4),1,1);
			}
			else if(a[i][j]==4){ //下 
				addr(hsh(i,j,3),hsh(i,j,2),1,1);
				addr(hsh(i,j,3),hsh(i,j,4),1,1);
				addr(hsh(i,j,3),hsh(i,j,1),1,2);
			} 
			else if(a[i][j]==5); //上下 
			else if(a[i][j]==6){ //右下 
				addr(hsh(i,j,3),hsh(i,j,1),1,1);
				addr(hsh(i,j,2),hsh(i,j,4),1,1);
			}
			else if(a[i][j]==7){ //上右下 
				addr(hsh(i,j,1),hsh(i,j,4),1,1);
				addr(hsh(i,j,3),hsh(i,j,4),1,1);
				addr(hsh(i,j,2),hsh(i,j,4),1,2);
			}
			else if(a[i][j]==8){ //左 
				addr(hsh(i,j,4),hsh(i,j,1),1,1);
				addr(hsh(i,j,4),hsh(i,j,3),1,1);
				addr(hsh(i,j,4),hsh(i,j,2),1,2);
			}
			else if(a[i][j]==9){ //上左 
				addr(hsh(i,j,1),hsh(i,j,3),1,1);
				addr(hsh(i,j,4),hsh(i,j,2),1,1); 
			}
			else if(a[i][j]==10);//右左 
			else if(a[i][j]==11){//上右左 
				addr(hsh(i,j,2),hsh(i,j,3),1,1);
				addr(hsh(i,j,4),hsh(i,j,3),1,1);
				addr(hsh(i,j,1),hsh(i,j,3),1,2);
			}
			else if(a[i][j]==12){//下左 
				addr(hsh(i,j,3),hsh(i,j,1),1,1);
				addr(hsh(i,j,4),hsh(i,j,2),1,1); 
			}
			else if(a[i][j]==13){//上下左 
				addr(hsh(i,j,1),hsh(i,j,2),1,1);
				addr(hsh(i,j,3),hsh(i,j,2),1,1);
				addr(hsh(i,j,4),hsh(i,j,2),1,2);
			}
			else if(a[i][j]==14){//右下左 
				addr(hsh(i,j,2),hsh(i,j,1),1,1);
				addr(hsh(i,j,4),hsh(i,j,1),1,1);
				addr(hsh(i,j,3),hsh(i,j,1),1,2);
			}
		}
	}
	
	while(spfa()) while(tmp=dinic(s,inf)) flow+=tmp;
	if(flow*2==ans) printf("%lld\n",cost);
	else puts("-1");
	return 0;
}
```

听说好像大佬有更短的解法……蒟蒻没有怎么多想。这个代码看似长，其实第二段加边和第一段加边是一模一样的（addh -> addr，然后删掉一段东西）。所以复制黏贴过来+编译器的查找替换功能就能很快解决。

---

## 作者：orz_z (赞：1)

题面自己看吧。。。

#### std

对于这种毒瘤的最小费用匹配问题，一般考虑网络费用流。

对于每个水管的每一个支管，有且仅有一个其它方格上的水管的其中一个支管与其相连，这样就不会漏水了，也就是一个水管的每个支管容量只能为 $1$，且都要满流。

由于我们要用网络流，又考虑到只有相邻的两个水管又可能产生流量，于是考虑将图黑白染色。

这样黑点只能连向白点，白点只能连向黑点。

然后将一个方格拆成 $5$ 个点，分别表示上下左右中。

##### 模型建立

$s$ 向白点的中点连一条容量为支管数量，费用为 $0$ 的边。

黑点的中点向 $t$ 连一条容量为支管数量，费用为 $0$ 的边。

根据支管情况向四周连容量为 $1$，费用为 $0$ 的边。

然后分水管的情况讨论：

###### 1

![](https://img-blog.csdnimg.cn/300be03369d64b09acb4b43c6a7b386e.png)

上点分别向左，右点向一条容量为 $1$，费用为 $1$ 的边（转 $90$ 度）。

上点向下点连向一条容量为 $1$，费用为 $2$ 的边（转 $180$ 度）。

###### 2

![](https://img-blog.csdnimg.cn/5b8ccfd8ef1c4c7885f602a179a6b804.png)

由于不用旋转，那么只需让中点分别向上、下点连一条容量为 $1$，费用为 $0$ 的边（上面说过了）。

###### 3

![](https://img-blog.csdnimg.cn/2ad5fa63f0c44a3cb8ae0faa26838a51.png)

顺时针转 $90$ 度，会变成这样：

![](https://img-blog.csdnimg.cn/425158725bbe48e391da4f8921fcb916.png)

这相当于原来的上点变成了下点，右点不变，那么让上点向下点连一条容量为 $1$，费用为 $1$ 的边即可。

逆时针转 $90$ 度同理，让右点向左点连一条容量为 $1$，费用为 $1$ 的边即可。

转 $180$ 度，会变成这样：

![](https://img-blog.csdnimg.cn/2127e02dc47b4fe4b8d8320df38cc1ec.png)

这相当于，你将前面说的两条边一起用了。

###### 4

![](https://img-blog.csdnimg.cn/28dd4dcc7e444eada43b5ad693f25388.png)

顺时针转 $90$ 度，会变成这样：

![](https://img-blog.csdnimg.cn/1f03f7f95faa4d0ab2a71e08685c5fae.png)

这相当于上、右点不变，左点变成了下点，于是让左点向下点连一条容量为 $1$，费用为 $1$ 的边即可。

逆时针转 $90$ 度同理，让右点向下点连一条容量为 $1$，费用为 $1$ 的边即可。

转 $180$ 度，会变成这样：

![](https://img-blog.csdnimg.cn/f51c851e96f64943b2e3c3f80b3745ae.png)

这相当于左、右点不变，上点变成了下点，于是让上点向下点连一条容量为 $1$，费用为 $2$ 的边即可。

###### 5

![](https://img-blog.csdnimg.cn/cba7e5dc8dc64f98a01b06ea1a4996f6.png)

由于这转了相当于没转，那么不管他。

$\text{231ms / 1.71MB / 7.49KB C++20 O2}$。

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

inline void write(int x)
{
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

typedef int tp;

const int _ = 6e4 + 10, inf = 947483647;

int n, m, s, t, lv[_], cur[_];

tp maxflow, mincost;

int tot = 1, head[_], to[_ << 1], nxt[_ << 1];

tp dis[_], w[_ << 1], fl[_ << 1];

inline void add(int u, int v, tp dis, tp c)
{
    to[++tot] = v;
    nxt[tot] = head[u];
    fl[tot] = dis;
    w[tot] = c;
    head[u] = tot;
}

inline void Add(int u, int v, tp dis, tp c)
{
    add(u, v, dis, c);
    add(v, u, 0, -c);
}

inline bool bfs()
{
    memset(lv, 0, sizeof(lv));
    for (int i = 0; i < _; ++i)
        dis[i] = inf;
    lv[s] = 1;
    dis[s] = 0;
    memcpy(cur, head, sizeof(head));
    queue<int> q;
    q.push(s);
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        lv[p] = 0;
        for (int eg = head[p]; eg; eg = nxt[eg])
        {
            int v = to[eg];
            tp vol = fl[eg];
            if (vol > 0 && dis[v] > dis[p] + w[eg])
            {
                dis[v] = dis[p] + w[eg];
                if (!lv[v])
                {
                    q.push(v);
                    lv[v] = 1;
                }
            }
        }
    }
    return dis[t] != inf;
}

tp dfs(int p = s, tp flow = inf)
{
    if (p == t)
        return flow;
    lv[p] = 1;
    tp rmn = flow;
    for (int eg = cur[p]; eg && rmn; eg = nxt[eg])
    {
        cur[p] = eg;
        int v = to[eg];
        tp vol = fl[eg];
        if (vol > 0 && !lv[v] && dis[v] == dis[p] + w[eg])
        {
            tp c = dfs(v, min(vol, rmn));
            rmn -= c;
            fl[eg] -= c;
            fl[eg ^ 1] += c;
        }
    }
    lv[p] = 0;
    return flow - rmn;
}

inline void dinic()
{
    while (bfs())
    {
        tp flow = dfs();
        maxflow += flow;
        mincost += dis[t] * flow;
    }
}

inline int id(int x, int y, int num)
{
    return (x - 1) * m + y + num * n * m;
}

int sum;

const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}, cross[] = {3, 4, 1, 2};

inline void build(int x, int y, int num)
{
    if ((x + y) & 1)
    {
        Add(s, id(x, y, 0), 1 << 30, 0);
        for (int i = 0; i < 4; ++i)
        {
            int xx = x + dx[i], yy = y + dy[i];
            if (xx <= 0 || xx > n || yy <= 0 || yy > m)
                continue;
            Add(id(x, y, i + 1), id(xx, yy, cross[i]), 1, 0);
        }
        for (int i = 0; i < 4; ++i)
            if (num & (1 << i))
            {
                Add(id(x, y, 0), id(x, y, i + 1), 1, 0);
                ++sum;
            }
        switch (num)
        {
        case 1:
            Add(id(x, y, 1), id(x, y, 2), 1, 1);
            Add(id(x, y, 1), id(x, y, 3), 1, 2);
            Add(id(x, y, 1), id(x, y, 4), 1, 1);
            break;
        case 2:
            Add(id(x, y, 2), id(x, y, 1), 1, 1);
            Add(id(x, y, 2), id(x, y, 3), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 2);
            break;
        case 4:
            Add(id(x, y, 3), id(x, y, 1), 1, 2);
            Add(id(x, y, 3), id(x, y, 2), 1, 1);
            Add(id(x, y, 3), id(x, y, 4), 1, 1);
            break;
        case 8:
            Add(id(x, y, 4), id(x, y, 1), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 2);
            Add(id(x, y, 4), id(x, y, 3), 1, 1);
            break;
        case 3:
            Add(id(x, y, 1), id(x, y, 3), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 1);
            break;
        case 6:
            Add(id(x, y, 3), id(x, y, 1), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 1);
            break;
        case 9:
            Add(id(x, y, 1), id(x, y, 3), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 1);
            break;
        case 12:
            Add(id(x, y, 3), id(x, y, 1), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 1);
            break;
        case 7:
            Add(id(x, y, 1), id(x, y, 4), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 2);
            Add(id(x, y, 3), id(x, y, 4), 1, 1);
            break;
        case 11:
            Add(id(x, y, 1), id(x, y, 3), 1, 2);
            Add(id(x, y, 2), id(x, y, 3), 1, 1);
            Add(id(x, y, 4), id(x, y, 3), 1, 1);
            break;
        case 13:
            Add(id(x, y, 1), id(x, y, 2), 1, 1);
            Add(id(x, y, 3), id(x, y, 2), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 2);
            break;
        case 14:
            Add(id(x, y, 2), id(x, y, 1), 1, 1);
            Add(id(x, y, 3), id(x, y, 1), 1, 2);
            Add(id(x, y, 4), id(x, y, 1), 1, 1);
            break;
        }
    }
    else
    {
        Add(id(x, y, 0), t, 1 << 30, 0);
        for (int i = 0; i < 4; ++i)
            if (num & (1 << i))
            {
                Add(id(x, y, i + 1), id(x, y, 0), 1, 0);
                ++sum;
            }
        switch (num)
        {
        case 1:
            Add(id(x, y, 2), id(x, y, 1), 1, 1);
            Add(id(x, y, 3), id(x, y, 1), 1, 2);
            Add(id(x, y, 4), id(x, y, 1), 1, 1);
            break;
        case 2:
            Add(id(x, y, 1), id(x, y, 2), 1, 1);
            Add(id(x, y, 3), id(x, y, 2), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 2);
            break;
        case 4:
            Add(id(x, y, 1), id(x, y, 3), 1, 2);
            Add(id(x, y, 2), id(x, y, 3), 1, 1);
            Add(id(x, y, 4), id(x, y, 3), 1, 1);
            break;
        case 8:
            Add(id(x, y, 1), id(x, y, 4), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 2);
            Add(id(x, y, 3), id(x, y, 4), 1, 1);
            break;
        case 3:
            Add(id(x, y, 3), id(x, y, 1), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 1);
            break;
        case 6:
            Add(id(x, y, 1), id(x, y, 3), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 1);
            break;
        case 9:
            Add(id(x, y, 3), id(x, y, 1), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 1);
            break;
        case 12:
            Add(id(x, y, 1), id(x, y, 3), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 1);
            break;
        case 7:
            Add(id(x, y, 4), id(x, y, 1), 1, 1);
            Add(id(x, y, 4), id(x, y, 2), 1, 2);
            Add(id(x, y, 4), id(x, y, 3), 1, 1);
            break;
        case 11:
            Add(id(x, y, 3), id(x, y, 1), 1, 2);
            Add(id(x, y, 3), id(x, y, 2), 1, 1);
            Add(id(x, y, 3), id(x, y, 4), 1, 1);
            break;
        case 13:
            Add(id(x, y, 2), id(x, y, 1), 1, 1);
            Add(id(x, y, 2), id(x, y, 3), 1, 1);
            Add(id(x, y, 2), id(x, y, 4), 1, 2);
            break;
        case 14:
            Add(id(x, y, 1), id(x, y, 2), 1, 1);
            Add(id(x, y, 1), id(x, y, 3), 1, 2);
            Add(id(x, y, 1), id(x, y, 4), 1, 1);
            break;
        }
    }
}

signed main()
{
    n = read(), m = read();
    s = 0, t = _ - 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
        {
            int p = read();
            build(i, j, p);
        }
    dinic();
    write(maxflow * 2 == sum ? mincost : -1);
    return 0;
}
```



---

## 作者：PosVII (赞：1)

**前言**

------------

码力题。

2021.10.29，JJH说他要A了无限之环，然后轰轰烈烈打了 $200$ 行没过样例，于是在他AC之后有了这篇题解。

upd on 11.12：我打了 $13$ 小时，打了 $1200$ 余行终于A啦！！！！！！

庆祝JJH早过了的生日……

**思路**

------------

我是看费用流标签找到这道题的，所以我肯定是要用费用流来解本题的。

1. 发现当不存在漏水的地方时，相接的水管数量一定是最多的，这便说明此题使用最大流。
1. 一个水管相接，可以视作另一个水管出水，而另一个水管则入水，那么可将跑完最大流后的最大流视为相接水管数量除以 $2$ 后的结果。
1. 使用费用流的原因是因为我们要使得转动管子次数最少。

通俗来讲，我们将相邻的格子视作一个出水口和入水口，而它们之间的水管则是它们之间的边。

题意指出，水管的方向是可以改变的，所以我们要看如何加边能够实现水管转向。

我们把每个格子视作五个部分：一个中间的出水/入水口，四个方向上的管子（可以是虚的），那么我们可以直接将相邻格子的对应管子相连，费用设为 $0$。

然后对不同种类的格子进行讨论。

**讨论**

------------

只有三种格子需要讨论，其余可以直接建边。

- 只有一个管子：我们要使得这一个管子转向其它方向只能直接旋转，所以用这个管子向其它方向管子连边即可，费用设为 $1$，特殊地，与这个管子相反的边费用为 $2$。

- 有两个相邻管子：首先看只转一次的情况，我们发现总会有一个管子的位置没有变化，那么我们将两个变化的管子连一条边，费用为 $1$，另一条边同理，不难发现，只需要这两条边就足够了。

- 有三个管子：同样的思考方法，不难发现我们有三种情况转化有的管子和虚的管子，连三条边即可。

**code:**

------------

蒟蒻自知语文不好，于是供上自己的代码帮助理解。

```
#include<bits/stdc++.h>
using namespace std;
#define max(x,y) x>y?x:y
#define min(x,y) x<y?x:y
const int INF=1e9;
const int MAXN=2e5+5,N=2e4+5;
bool vis[N];
int n,m,s,t,x,y,z,f,dis[N],pre[N],last[N],flow[N],maxflow,mincost;
struct node {
	int to,next,flow,dis;
}edge[MAXN];
int head[N],cnt; 
queue<int> q;
void add(int from,int to,int flow,int dis) {
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].flow=flow;
	edge[cnt].dis=dis;
	head[from]=cnt;
//	printf("%d %d\n",from,to);
}
bool spfa(int s,int t) {
	memset(dis,0x7f,sizeof(dis));
	memset(flow,0x7f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	q.push(s);vis[s]=1;dis[s]=0;pre[t]=-1;
	while(!q.empty()) {
		int now=q.front();
		q.pop();
		vis[now]=0;
		for(int i=head[now];~i;i=edge[i].next) {
			if(edge[i].flow>0&&dis[edge[i].to]>dis[now]+edge[i].dis) {
				dis[edge[i].to]=dis[now]+edge[i].dis;
				pre[edge[i].to]=now;
				last[edge[i].to]=i;
				flow[edge[i].to]=min(flow[now],edge[i].flow);
				if(!vis[edge[i].to]) {
					vis[edge[i].to]=1;
					q.push(edge[i].to);
				}
			}
		}
	}
	return ~pre[t];
}
void MCMF() {
	while(spfa(s,t)) {
		int now=t;
		maxflow+=flow[t];
		mincost+=flow[t]*dis[t];
		while(now!=s) {
			edge[last[now]].flow-=flow[t];
			edge[last[now]^1].flow+=flow[t];
			now=pre[now];
		}
	}
}
//^>v<
int sum,di[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
int col,bk[4]={2,3,0,1},rol;
int num(int x,int y,int way) {
	return (x-1)*m+y+way*sum;
}
void addt(int from,int to,int flow,int dis) {
	if(!col) swap(from,to);
	add(from,to,flow,dis);
	add(to,from,0,-dis);
}
int rans;
int main() {
//	freopen("cao.in","r",stdin);
	memset(head,-1,sizeof(head));cnt=-1;
	scanf("%d %d",&n,&m);
	sum=n*m;
	s=5*sum+1,t=5*sum+2;
	for(int i=1;i<=n;++i) {
		col=i&1;
		for(int j=1;j<=m;++j) {
			scanf("%d",&rol);
			col^=1;
			if(col) {
				addt(s,num(i,j,4),INF,0);
				for(int k=0;k<4;++k) {
					int dx=i+di[k][0],dy=j+di[k][1];
					if(dx<1||dx>n||dy<1||dy>m) continue;
					addt(num(i,j,k),num(dx,dy,bk[k]),1,0);
//					printf("%d %d %d %d\n",i,j,dx,dy);
				}
				for(int k=0;k<4;++k) {
					if(rol&(1<<k)) {
						addt(num(i,j,4),num(i,j,k),1,0);
						++rans;
					}
				}
			}
			else {
				addt(t,num(i,j,4),INF,0);
				for(int k=0;k<4;++k) {
					if(rol&(1<<k)) {
						addt(num(i,j,4),num(i,j,k),1,0);
						++rans;
					}
				}
			}
			if(rol==8) {//← 
				addt(num(i,j,3),num(i,j,0),1,1);
				addt(num(i,j,3),num(i,j,2),1,1);
				addt(num(i,j,3),num(i,j,1),1,2);
				continue;
			}
			if(rol==4) {//↓ 
				addt(num(i,j,2),num(i,j,1),1,1);
				addt(num(i,j,2),num(i,j,3),1,1);
				addt(num(i,j,2),num(i,j,0),1,2);
				continue;
			}
			if(rol==2) {//→ 
				addt(num(i,j,1),num(i,j,0),1,1);
				addt(num(i,j,1),num(i,j,2),1,1);
				addt(num(i,j,1),num(i,j,3),1,2);
				continue;
			}
			if(rol==1) {//↑ 
				addt(num(i,j,0),num(i,j,1),1,1);
				addt(num(i,j,0),num(i,j,3),1,1);
				addt(num(i,j,0),num(i,j,2),1,2);
				continue;
			}
			if(rol==3) {//└ 
				addt(num(i,j,1),num(i,j,3),1,1);
				addt(num(i,j,0),num(i,j,2),1,1);
				continue;
			}
			if(rol==6) {//┌
				addt(num(i,j,1),num(i,j,3),1,1);
				addt(num(i,j,2),num(i,j,0),1,1);
				continue;
			} 
			if(rol==9) {//┘
				addt(num(i,j,3),num(i,j,1),1,1);
				addt(num(i,j,0),num(i,j,2),1,1);
				continue;
			}
			if(rol==12) {//┐
				addt(num(i,j,3),num(i,j,1),1,1);
				addt(num(i,j,2),num(i,j,0),1,1);
				continue;
			}
			if(rol==7) {//├
				addt(num(i,j,0),num(i,j,3),1,1); 
				addt(num(i,j,2),num(i,j,3),1,1);
				addt(num(i,j,1),num(i,j,3),1,2);
				continue;
			}
			if(rol==11) {//┴
				addt(num(i,j,3),num(i,j,2),1,1); 
				addt(num(i,j,1),num(i,j,2),1,1);
				addt(num(i,j,0),num(i,j,2),1,2);
				continue;
			}
			if(rol==13) {//┤
				addt(num(i,j,0),num(i,j,1),1,1); 
				addt(num(i,j,2),num(i,j,1),1,1);
				addt(num(i,j,3),num(i,j,1),1,2);
				continue;
			}
			if(rol==14) {//┬
				addt(num(i,j,3),num(i,j,0),1,1); 
				addt(num(i,j,1),num(i,j,0),1,1);
				addt(num(i,j,2),num(i,j,0),1,2);
				continue;
			}
		}
	}
	MCMF();
//	printf("%d %d\n",maxflow,mincost);
	if(maxflow*2==rans) printf("%d",mincost);
	else printf("-1");
	return 0;
}
```

---


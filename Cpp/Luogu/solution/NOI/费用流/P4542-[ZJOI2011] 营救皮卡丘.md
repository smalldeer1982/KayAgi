# [ZJOI2011] 营救皮卡丘

## 题目描述

皮卡丘被火箭队用邪恶的计谋抢走了！这三个坏家伙还给小智留下了赤果果的挑衅！为了皮卡丘，也为了正义，小智和他的朋友们义不容辞的踏上了营救皮卡丘的道路。

火箭队一共有 $N$ 个据点，据点之间存在 $M$ 条双向道路。据点分别从 $1$ 到 $N$ 标号。小智一行 $K$ 人从真新镇出发，营救被困在 $N$ 号据点的皮卡丘。为了方便起见，我们将真新镇视为 $0$ 号据点，一开始 $K$ 个人都在 $0$ 号点。

由于火箭队的重重布防，对于任意 $2\le X\le N$，要想摧毁 $X$ 号据点，必须按照顺序先摧毁 $1$ 到 $X-1$ 号据点，并且，如果 $X-1$ 号据点没有被摧毁，由于防御的连锁性，小智一行任何一个人进入据点 $X$，都会被发现，并产生严重后果。因此，在$X-1$号据点被摧毁之前，任何人是不能够经过 $X$ 号据点的。

为了简化问题，我们忽略战斗环节，小智一行任何一个人经过 $K$ 号据点即认为 $K$ 号据点被摧毁。被摧毁的据点依然是可以被经过的。

$K$ 个人是可以分头行动的，只要有任何一个人在 $K-1$ 号据点被摧毁之后，经过 $K$ 号据点，$K$ 号据点就被摧毁了。显然的，只要 $N$ 号据点被摧毁，皮卡丘就得救了。

野外的道路是不安全的，因此小智一行希望在摧毁 $N$ 号据点救出皮卡丘的同时，使得 $K$ 个人所经过的道路的长度总和最少。

请你帮助小智设计一个最佳的营救方案吧！

## 说明/提示

【样例说明】

小智和小霞一起前去营救皮卡丘。在最优方案中，小智先从真新镇前往 $1$ 号点，接着前往 $2$ 号据点。当小智成功摧毁 $2$ 号据点之后，小霞从真新镇出发直接前往 $3$ 号据点，救出皮卡丘。

对于 $100\%$ 的数据满足 $N\le 150, M \le 20 000, 1 \le K \le 10, L_i \le 10 000$, 保证小智一行一定能够救出皮卡丘。

至于为什么 $K \le 10$，你可以认为最终在小智的号召下，小智，小霞，小刚，小建，小遥，小胜，小光，艾莉丝，天桐，还有去日本旅游的黑猫警长，一同前去大战火箭队。

## 样例 #1

### 输入

```
3 4 2
0 1 1
1 2 1
2 3 100
0 3 1```

### 输出

```
3```

# 题解

## 作者：jjsnam (赞：28)

感觉题解写的都太简略了，只是告诉你怎么建图，而没有告诉你为什么这样建，这样建为什么对。很反感这种现象，作为读者本来看题解就是因为思维跳跃性不够，到头来题解也要思维跳跃，真正的疑难点也没想通，没有意义。因此写这篇题解来补充一下建图的正确性和原因。


------------

大体先串一下主流做法。

首先我们用最短路算法求出 $dis_{i,j}$ 表示从 $i$ 到 $j$ 只经过编号不大于 $\max(i, j)$ 的点的最短路径。之后我们用 $dis$ 数组建图，跑最小费用最大流以求出一个分配方案使得：
-	每个点都被经过。
-	最后总花费最少。

现在来想一想这个图怎么建。

网络流对时间的概念不很敏感，所以说两个人分着走在网络流里可以一起流，不用太在意两个人的先后顺序会有影响。而且之前的 $dis$ 数组也对时间顺序做了一个保证。

上面的要求也就是说我们要找到若干条路径，以覆盖图中所有点。如果不考虑费用，我们会联想到最大流中的最小路径覆盖问题（每个点只能经过一次）。这个问题是按如下方法解决的：
-	将每个点 $u$ 拆开为 $u_{in}$ 和 $u_{out}$。
-	建立源汇点，对于每个 $u$，连接 $<S, u_{out}>$、$<u_{in}, T>$。
-	对于原图中的边 $<u, v>$，流网络里连 $<u_{out}, v_{in}>$。
-	图中每条边的流量都是 $1$。

然后跑最大流二分图匹配。对于每个匹配 $<u_{out}, v_{in}>$，代表我们在原图中把这两个点合并为一条路径走过。那么最大流就是我们最多能合并的数量。一开始我们用 $n$ 条路径走过 $n$ 个点。跑完最大流我们能合并最多点，每合并两个点需要的路径数就少一个，也就使用了最少的路径覆盖所有点。

我们尝试将上述模型应用到此题中。首先，每个人都从 $0$ 号点出发，所以 $0$ 可以作为 $K$ 条路径的起点，因而它可以与 $K$ 个点匹配。所以 $<S,0_{out}>$ 这条边的流量我们要改成 $K$。此外我们要引进费用的概念，每次匹配就代表使用了这条边，也就要消耗这条边的代价。这样图就建完了，跑费用流即可。

事实证明这样建图是对的，但是初次想到或读到会产生很多疑问，下面我对我疑惑比较深的进行解答，希望对大家也有帮助。

1.	**最小路径覆盖问题中，我们可以以任意点为起点，而此题中所有人都必须从 $0$ 号点出发，这时上述建图方法如何能保证将所有点覆盖？**

	这就要与这题的 $dis$ 数组息息相关了。原图是连通图，因此我们求出来的 $dis$ 数组对于 $\forall u, v$，$dis_{u,v}$ 都有意义。也就是说，**$dis$ 数组相当于一个无向完全连通图**。因此我们不论从哪个点出发，都一定能找到一条不重复的路径以经过所有点（每个点与未覆盖的点都有边相连），只是代价不同的问题。
    
    对应到流网络中，如果一个点还没有跟任何其他点匹配，那么根据上述推论，一定能找到一条增广路，让这个点匹配，最终让所有点都能相互匹配变成一条路径，也就是上面那段的一条路径覆盖所有点。这样可能会让最终代价增加，但要注意的是**费用流它首先是最大流**，有增广路一定会流，最小费用最大流只是通过算法让最大流的代价最小罢了。所以在这个流网络上跑费用流首先就会满足覆盖所有点。
    
    
2.	**$K$ 个人不一定全要用到，这个如何保证？**

	从建图目的上看，流网络中将 $<S,0_{out}>$ 这条边的流量我们要改成 $K$，目的是为了在所有点都匹配的基础上通过提供多种匹配选择以使最终费用尽量的少。如果一条路径就能优雅且代价最小地走过所有点，自然没有必要用到剩下的选择了。
    
    从图本身看，虽然源点 $S$ 的总流出量增加了，但是汇点 $T$ 的总流入量仍然是 $n$。因此最大流仍然是 $n$，也就是说源点流不满。那么这既可能是我们使用了多余的 $K-1$ 个选择，让某些点失配，也可能是我们舍弃了多余的选择保持原状。
    
    总的来说，就是给一个可能更优的选择，算法会自己决定用不用。
    
3. **每个点真的只经过一次吗？**

	很多题解都这么说，但是我**不认同**。在我们建的流网络中，的确每个点最多只能有一个入度一个出度（除了 $0$ 号点）。看似只经过一次，但是要注意我们的流网络是建立在 $dis$ 数组这个看做是无向完全连通图的基础上的。而 $dis_{u, v}$ 本来就会包含不大于 $\max(u,v)$ 的点作为最短路的中转点，只不过流网络保证匹配时这个点第一次出现罢了，因而每个点只经过一次是不准确的。
    
    
------------
    
总而言之，这道题之所以如此建图和上面三个问题的合理解释都是因为我们处理出了 $dis$ 数组这个可以看做一个无向完全连通图的东西。虽然解释这些问题看似很麻烦，但我觉得这题的精华在 $dis$ 数组上。


具体地建图方法可以去参考别的题解，代码也很简单，放在[剪切板](https://www.luogu.com.cn/paste/mfua9amh)，谢谢观看！
    
    
    
    
    

---

## 作者：Sol1 (赞：14)

给个不一样的建图方法。

首先题目显然可以被转化为选 $k$ 条路径覆盖所有点。

但是题目中这个「在 $K-1$ 号据点被摧毁之前，任何人不能够经过 $K$ 号据点」的限制不好处理。

考虑将路径建成边，用 Floyd 预处理出 $i\rightsquigarrow j$ 且不经过 $>\max\{i,j\}$ 的点的最短路径长度。

在新图上，这个限制就可以被表示为选出的所有路径中的点编号要递增，且所有路径的并集为 $\{1,2,\cdots,n\}$。

为什么这样是对的呢？

因为每一个人都可以在一个点等，所以当你要爆掉 $i$ 的时候，可以通过适当控制顺序保证 $0\sim i-1$ 都已经爆掉了。

于是就可以建图了。

为了方便，以下用 $c$ 表示容量，$w$ 表示费用。

首先拆点，一个点 $i$ 拆成 $i_1$ 和 $i_2$。

由于要限制只有 $k$ 个路径，所以连 $S\rightarrow 0_1$，$c=k$，$w=0$。

然后是一个点必须要过 $\geq 1$ 次。这里其实不用上下界费用流，直接连两条边：$i_1\rightarrow i_2,c=1,w=-\infty$ 和 $i_1\rightarrow i_2,c=+\infty,w=0$ 即可，因为少过一个点，总费用会多一大堆，肯定多于少过一个点能省下的距离。

然后是所有人都可以在任意点结束，所以连边 $i_2\rightarrow T, c=+\infty, w=0$。

再然后就是移动，对于 $i<j$，如果可以在只经过编号 $<j$ 的点到达，则连边 $i_2\rightarrow j_1,c=+\infty, w=\text{dis}(i,j)$。

求一遍 $S\rightarrow T$ 的最小费用最大流即可。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const long long INF = 0x3f3f3f3f3f3f3f3f;
struct Edge {
	int to, nxt;
	long long cap, cost;
	Edge() {
		nxt = -1;
	}
};
int n, m, hd[310], pnt, k, g[155][155];
long long sum, a[805];
Edge e[100005];

namespace MCMF {
	long long dis[310];
	bool vis[310], mrk[310];
	inline void SPFA(int s) {
		queue <int> que;
		memset(dis, 0x3f, sizeof(dis));
		dis[s] = 0;
		que.push(s);
		while (!que.empty()) {
			int u = que.front();
			que.pop();
			vis[u] = 0;
			for (int i = hd[u];~i;i = e[i].nxt) {
				if (e[i].cap && dis[e[i].to] > dis[u] + e[i].cost) {
					dis[e[i].to] = dis[u] + e[i].cost;
					if (!vis[e[i].to]) {
						vis[e[i].to] = 1;
						que.push(e[i].to);
					}
				}
			}
		}
	}
	inline long long Dfs(int u, int t, long long f) {
		if (u == t) return f;
		mrk[u] = 1;
		long long flw = 0;
		for (int i = hd[u];~i;i = e[i].nxt) {
			if (e[i].cap && !mrk[e[i].to] && dis[e[i].to] == dis[u] + e[i].cost) {
				long long d = Dfs(e[i].to, t, Min(f - flw, e[i].cap));
				if (d) {
					e[i].cap -= d;
					e[i ^ 1].cap += d;
					flw += d;
				} else dis[e[i].to] = INF;
				if (flw == f) break;
			}
		}
		mrk[u] = 0;
		return flw;
	}
	inline long long Flow(int s, int t) {
		long long ans = 0, flw = 0;
		for (;;) {
			SPFA(s);
			//printf("%lld %lld\n", flw, dis[t]);
			if (dis[t] >= 1e16) break;
			long long tmp = Dfs(s, t, INF);
			flw += tmp;
			ans += tmp * dis[t];
		}
		//printf("flw=%lld\n", flw);
		return ans;
	}
}

inline void AddEdge(int u, int v, long long cap, long long cost) {
	//printf("%d->%d c=%lld w=%lld\n", u, v, cap, cost);
	e[pnt].to = v;
	e[pnt].cap = cap;
	e[pnt].cost = cost;
	e[pnt].nxt = hd[u];
	hd[u] = pnt;
	pnt++;
	e[pnt].to = u;
	e[pnt].cap = 0;
	e[pnt].cost = -cost;
	e[pnt].nxt = hd[v];
	hd[v] = pnt;
	pnt++;
}

inline void Read() {
	n = qread() + 1; m = qread(); k = qread();
	for (int i = 1;i <= m;i++) {
		int u = qread() + 1, v = qread() + 1, w = qread();
		g[u][v] = g[v][u] = Min(g[u][v], w);
	}
}

inline void Prefix() {
	for (int k = 1;k <= n;k++) {
		for (int i = 1;i <= n;i++) {
			for (int j = 1;j <= n;j++) {
				if (k < i || k < j) g[i][j] = Min(g[i][j], g[i][k] + g[k][j]);
			}
		}
	}
	for (int i = 1;i <= n;i++) {
		AddEdge(i, i + n, 1, -1e12);
		AddEdge(i, i + n, INF, 0);
		for (int j = i + 1;j <= n;j++) {
			if (g[i][j] != 0x3f3f3f3f) AddEdge(i + n, j, INF, g[i][j]);
		}
		AddEdge(i + n, 2 * n + 1, INF, 0);
	}
}

int main() {
	memset(hd, -1, sizeof(hd));
	memset(g, 0x3f, sizeof(g));
	Read();
	Prefix();
	AddEdge(0, 1, k, 0);
	printf("%lld\n", MCMF::Flow(0, 2 * n + 1) + 1000000000000ll * n);
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：Kinandra (赞：14)

.标签：费用流.

.第$i$人破坏的结点可以组成一个集合$Seq_i$, 那么
$$\forall j\neq i, Seq_i\cap Seq_j = \emptyset$$
, 且
$$Seq_1\cup Seq_2\cup...\cup Seq_k=S$$
.其中$S$为$1$~$n$点的集合(没得$0$).

.定义$dis'[u][v](u<v)$为从$u$到$v$不经过编号大于$v$的点的最短路径长度, 通过Floyd可以很容易预处理得.

.那么对于第$i$个人, 其走过的路径长度为$$dis'[0][Seq_{i,1}]+\sum_{j=1}^{|Seq_i| - 1}dis'[Seq_{i,j}][Seq_{i,j+1}]$$, 其中$Seq_{i,j}$表示$Seq_i$中编号第$j$小的点.

.嚯哟, 出来了.

.建立新图$G'=\{V', E'\}$, $V'=V$, $E'=\{e(i,j,dis'[i][j])\}$, 其中$e(u,v,w)$表示一条从$u$到$v$权值为$w$的边, 那么答案就是:用不超过$k$条以$0$为起点的路径覆盖一个$DAG$所有结点的最小总长度(结点除起点外不可被重复覆盖).

.扒开这道题重重伪装之后, 它终于裸了.

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#define inf 1000000009
using namespace std;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

int ds[202][202];
int s, t;

int head[2003], nxt[200005], to[200005], cap[200005], cst[200005], cnt;
void add(int f, int t, int w, int c) {
    nxt[++cnt] = head[f];
    head[f] = cnt;
    to[cnt] = t;
    cap[cnt] = w;
    cst[cnt] = c;
    return ;
}

int dis[2003], pe[2003], pv[2003], inq[2003];
queue<int> q;

int bk(int x) {
    return (x & 1) ? (x + 1) : (x - 1);
}

void mcf() {
    int res = 0;
    while (1) {
        for (int i = 1; i <= t; ++i) dis[i] = inf;
        dis[s] = 0;
        q.push(s);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (int i = head[u]; i; i = nxt[i]) {
                int v = to[i];
                if (cap[i] < 1 || dis[v] <= dis[u] + cst[i]) continue;
                dis[v] = dis[u] + cst[i];
                pe[v] = i, pv[v] = u;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
            }
        }
        if (dis[t] == inf) break;
        int d = inf;
        for (int u = t; u != s; u = pv[u]) {
            d = min(d, cap[pe[u]]);
        }
        res += d * dis[t];
        for (int u = t; u != s; u = pv[u]) {
            cap[pe[u]] -= d;
            cap[bk(pe[u])] += d;
        }
    }
    printf("%d\n", res);
    return ;
}

int main() {
    int n = read() + 1, m = read(), K = read();
    s = n * 2 + 1, t = n * 2 + 2;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            ds[i][j] = inf;
        }
        ds[i][i] = 0;
    }
    for (int i = 1; i <= m; ++i) {
        int u = read() + 1, v = read() + 1, w = read();
        ds[u][v] = ds[v][u] = min(ds[u][v], w);
    }
    for (int k = 1; k <= n; ++k) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (k < (max(i, j)))
                    ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);
            }
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (i == 1) add(s, i * 2 - 1, K, 0), add(i * 2 - 1, s, 0, 0);
        else add(s, i * 2 - 1, 1, 0), add(i * 2 - 1, s, 0, 0);
        add(i * 2, t, 1, 0), add(t * 2, i, 0, 0);
        for (int j = i + 1; j <= n; ++j) {
            add(i * 2 - 1, j * 2, 1, ds[i][j]);
            add(j * 2, i * 2 - 1, 0, -ds[i][j]);
        }
    }

    mcf();
    return 0;
}
```

---

## 作者：foreverlasting (赞：7)

皮卡丘成功被拯救了！

算是服了，都不知道为什么自己的迪杰特斯拉跑费用流会错，换成MCMF一下子就过了。

思路应该是简单的。首先拿到这张图，肯定是要用上两点之间的最短路径，所以floyed先跑一波。（我开始floyed都打错了）然后建图也很好想的。先对两个点之间建边，如果有路径可以到达，则建一条容量为1费用为路径长度的边。（可行流，下界为1）再让S向0号店建一条容量为K，费用为0的边，来表示有K个人。最后 分别让S和T与其他点相连就行了。

证明正确性：

1、最优性

这应该是最明显的，显然若当前为最优情况，网络中也是最小费用流的情况。

2、条件性

**K个人是可以分头行动的，只要有任何一个人在K-1号据点被摧毁之后，经过K号据点，K号据点就被摧毁了。显然的，只要N号据点被摧毁，皮卡丘就得救了。**

这个条件也是满足的。这个条件在网络中的呈现就是每个点都有流量流向它们，这点在于S向0号建一条容量为K的边就可以证明。因为要满足最大流，所以每个点必定被流过，所以是对的。

所以就过了这道题。

code：
```
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void write(res x) {
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=1e6+10,NN=2*1e2+10;
int vis[N],n,m,s,t,pre[N],last[N],flow[N],maxflow,mincost;
int head[N],cnt,dis[N];
struct mdzz {
	int to,next,flow,dis;
	mdzz() {}
	mdzz(res to,res next,res flow,res dis):to(to),next(next),flow(flow),dis(dis) {}
} edge[N];
queue<int> q;
inline void addedge(int from,int to,int flow,int dis) {
	edge[++cnt]=mdzz(to,head[from],flow,dis),head[from]=cnt;
	edge[++cnt]=mdzz(from,head[to],0,-dis),head[to]=cnt;
}
inline void init() {
	cnt=-1;
	memset(head,-1,sizeof(head));
}
inline int spfa(res s,res t) {
	memset(dis,inf,sizeof(dis));
	memset(flow,inf,sizeof(flow));
	memset(vis,0,sizeof(vis));
	q.push(s);
	vis[s]=1;
	dis[s]=0;
	pre[t]=-1;
	while (!q.empty()) {
		res now=q.front();
		q.pop();
		vis[now]=0;
		for(res i=head[now]; ~i; i=edge[i].next)
			if (edge[i].flow>0 && dis[edge[i].to]>dis[now]+edge[i].dis) {
				dis[edge[i].to]=dis[now]+edge[i].dis;
				pre[edge[i].to]=now;
				last[edge[i].to]=i;
				flow[edge[i].to]=min(flow[now],edge[i].flow);
				if (!vis[edge[i].to])
					vis[edge[i].to]=1,q.push(edge[i].to);
			}
	}
	return pre[t]!=-1;
}
inline void MCMF() {
	while (spfa(s,t)) {
		res now=t;
		maxflow+=flow[t];
		mincost+=flow[t]*dis[t];
		while (now!=s) {
			edge[last[now]].flow-=flow[t];
			edge[last[now]^1].flow+=flow[t];
			now=pre[now];
		}
	}
}
int K,d[NN][NN];
int main() {
	init();
	n=read(),m=read(),K=read();
	s=n*2+2,t=s+1;
	for(res i=0; i<=n; i++)
		for(res j=0; j<=n; j++)if(i!=j)d[i][j]=inf;
	for(res i=1; i<=m; i++) {
		res x=read(),y=read(),z=read();
		d[x][y]=d[y][x]=min(d[x][y],z);
	}
	for(res k=0; k<=n; k++)
		for(res i=0; i<=n; i++)
			for(res j=0; j<=n; j++)
				if((k<=i||k<=j)&&d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];
	for(res i=1; i<n; i++)
		for(res j=i+1; j<=n; j++)if(d[i][j]!=inf)addedge(i,j+n+1,1,d[i][j]);
	for(res i=1; i<=n; i++)addedge(s,i,1,0),addedge(i+n+1,t,1,0);
	addedge(s,0,K,0);
	MCMF();
	write(mincost);
	return 0;
}
```

---

## 作者：rickyxrc (赞：4)

本文章遵守知识共享协议 CC-BY-NC-SA，同步发表于洛谷题解区，转载时须在文章的任一位置附上原文链接和作者署名（rickyxrc）。推荐在[我的个人博客](https://blog.rickyxrc.cc)阅读。

又一道网络流黑题，但是其实不是特别难。

## 题面大意

有 $K$ 个人在一个图的 $0$ 号点处，需要到达 $N$ 号点，在到达 $N$ 号点之前不能到达编号大于 $N$ 的点，$N$ 个人可以分头行动，求走过的最短路程之和。

## 解题思路

先讲讲为什么想到网络流吧。

首先我们不难看出以下性质：

1. $N$ 个人可以分头行动。
1. 路程之和与时间没有关系。
1. 并不是所有人都需要到达 $N$ 号点。
1. 在到达 $N$ 号点之前不能到达编号大于 $N$ 的点。

那么这个问题就可以转化成一个网络流的问题。

然后我们考虑等价转化上面的约束问题。

性质 $1,2,3$ 都和网络流的性质十分相似，我们着重考虑性质 $4$。

因为题目数据范围很小，我们可以用 Floyd 算法求解 $(i,j)$ 之间不经过 $j$ 之后的点所需的距离。

```cpp
for(int k=1; k<=n; k++)
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			if(k < i || k < j) // 保证不走到后面的点
				disss[i][j] = std::min(disss[i][k] + disss[k][j],disss[i][j]);
```

然后呢，性质 $4$ 还有一个隐含条件：每个点都必须走到。

这个很简单，我们进行拆点，将每个点拆成 $i$ 和 $i'$，向其中连接一条 $(1,-inf)$ 和一条 $(inf,0)$ 的边，最后给答案加上 $n$ 倍的 $inf$ 即可。

```cpp
for(int i=1; i<=n; i++)
	addedge(i,i+n,1,-inf_tmp),     // 保证n个点都走到
        addedge(i,i+n,inf,0),      // 允许重复走
        addedge(i+n,t,inf,0);      // 可以在任意点结束
```

最后再将图放进网络流里面，跑一遍最大流即可。

```cpp
	for(int i=1; i<=n; i++)
		for(int j=i+1; j<=n; j++)
			if(disss[i][j] != inf)
				addedge(i+n,j,inf,disss[i][j]); // 图的信息放到网络流里面
```

不过有个注意事项：如果你使用了如下的建图方式来规避零点的影响，请将 $n$ 增加 $1$。（不过应该是只有我这种菜鸡才会犯的错）

```cpp
for(int i=1; i<=m; i++) {
	scanf("%lld%lld%lld",&u,&v,&w);
	u++,v++;
	disss[v][u] = disss[u][v] = std::min(disss[u][v],w);
}
```

完整代码如下：

```cpp
#include<stdio.h>
#include<string.h>
#include<queue>
#include<algorithm>

#define int long long

const int maxn = 6 * 150 + 7, maxm = 2 * 6 * 2e4 + 5, inf = 0x3f3f3f3f3f3f3f3fll, inf_tmp = 1000000000ll;

int n, m, tot=1, head[maxn], cur[maxn], ter[maxm], nxt[maxm], cap[maxm], cost[maxm], dis[maxn], ret, vis[maxn];

void add(int u, int v, int w, int c) {
	ter[++tot] = v, nxt[tot] = head[u], head[u] = tot, cap[tot] = w, cost[tot] = c;
}
void addedge(int u, int v, int w, int c) {
//	printf("%lld %lld %lld,%lld\n",u,v,w,c);
	add(u, v, w, c) , add(v, u, 0, -c);
}

bool spfa(int s,int t) {
	memset(dis, inf , sizeof(dis)), memcpy(cur, head, sizeof(head));
	std::queue<int> q;
	q.push(s), dis[s] = 0, vis[s] = 1;
	while(!q.empty()) {
		int fr = q.front();
		q.pop(), vis[fr] = 0;
		for(int i = head[fr] ; i ; i = nxt[i]) {
			int v = ter[i];
			if(cap[i] && dis[v] > dis[fr] + cost[i]) {
				dis[v] = dis[fr] + cost[i];
				if(!vis[v])
					q.push(v), vis[v] = 1;
			}
		}
	}
	return dis[t] != inf;
}

int dfs(int u, int t, int flow) {
	if(u == t) return flow;
	vis[u] = 1;
	int ans = 0;
	for(int &i = cur[u] ; i && ans < flow ; i = nxt[i]) {
		int v = ter[i];
		if(!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]) {
			int x = dfs(v, t, std::min(cap[i], flow - ans));
			if(x) ret += x * cost[i], cap[i] -= x, cap[i^1] += x, ans += x;
		}
	}
	vis[u] = 0;
	return ans;
}

int mcmf(int s, int t) {
	int ans = 0, x;
	while (spfa(s,t)) {
		while(x = dfs(s,t,inf))
			ans += x;
	}
	return ans;
}

int u, v, w, c, s, t, disss[maxn][maxn], k;
signed main() {
	memset(disss,inf,sizeof disss);
	scanf("%lld%lld%lld",&n,&m,&k);

	n++;
	s = 2*n+1;
	t = 2*n+2;

	for(int i=1; i<=m; i++) {
		scanf("%lld%lld%lld",&u,&v,&w);
		u++,v++;
		disss[v][u] = disss[u][v] = std::min(disss[u][v],w);
	}

	for(int k=1; k<=n; k++)
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				if(k < i || k < j) // 保证不走到后面的点
					disss[i][j] = std::min(disss[i][k] + disss[k][j],disss[i][j]);

	addedge(s,1,k,0);

	for(int i=1; i<=n; i++)
		addedge(i,i+n,1,-inf_tmp),     // 保证n个点都走到
		        addedge(i,i+n,inf,0),      // 允许重复走
		        addedge(i+n,t,inf,0);      // 可以在任意点结束

	for(int i=1; i<=n; i++)
		for(int j=i+1; j<=n; j++)
			if(disss[i][j] != inf)
				addedge(i+n,j,inf,disss[i][j]); // 图的信息放到网络流里面

	int ans = mcmf(s, t);
	printf("%lld\n", ret + inf_tmp * n); // 因为流量约束时减掉了，所以这里加回来

	return 0;
}
```

---

## 作者：Rikku_eq (赞：4)



做的第一道网络流黑题，觉得还是挺困难的。尤其对于最小路径覆盖的转化比较妙。

翻了比较久的题解才想出来，因此也想自己写一篇题解，希望能够帮助到现在在做这道题的同学们。

如果题解中有错误还请大家海涵，可以私信我提出，我会尽快修改。

## 对限制的分析

发现实际上不需要考虑访问顺序，只需要分配每个人的路径即可。因为一个人可以在前一个点上一直站着（设当前还不能过去的那个点的编号为 $i$ ），直到其他人把 $1$ ～ $(i-1)$ 的所有点都访问完毕之后再去。

当然，不考虑访问顺序的前提是：给这个人分配的路径后续不能由他来摧毁 $1$ ～ $(i-1)$ 之间的任何一个点。因此每条路径上 **需要摧毁** 的点的编号必须是递增的（注意不是经过的点）。

同时，如果一个人要从 $i$ 出发，目标是摧毁 $j$（不考虑摧毁其他点），则他一定走 $i, j$ 之间的最短路。这是多源多汇最短路，用 floyd 求出每对点 $(i,j)$ 之间的最短路 $d(i, j)$ 即可。

## 建图

下面考虑如何连边：

这道题有点类似 最小路径覆盖，因此考虑建出相似的二分图，将每个点拆点。先给出连边方式（以 `(u, v, flow, cost)` 的形式给出）：

对于所有 $i=1 \cdots n$，连接 $(S, i_1, 1, 0)$ 与 $(i_2, T, 1, 0)$

对于 $i=0$，连接 $(S, i_1, k, 0)$。

对于每对 $(i,j)$（其中 $i<j$ ），连接 $(i_1, j_2, 1, d(i,j))$。

考虑这样做的正确性：

类似最小路径覆盖，此时流过一条边代表路径的拼接。
例如：流过 $S$ -> $i_1$ -> $j_2$ -> $T$ 代表 其中某个人的摧毁路径是 $0$ -> $i$ -> $j$，即经过了一些点先到达并摧毁了 $i$，又从 $i$ 出发摧毁了 $j$，$(i,j)$ 路径上没有未摧毁的点。

在这张二分图上的“路径”均指 **摧毁点构成的路径**，即 摧毁点之间路过的已经被其他路径摧毁的点是不计入的，因为已经被包含在所求出的 $d(i, j)$ 之中了。

由于一个点只能被摧毁一次，因此这道题确实就是 **最小权路径覆盖问题**。

这也解释了为什么 $S$ 连出的边除 $0$ 外流量均为 $1$，只会有一条路径 经过**并摧毁** 它们之后再延伸出去，而 $0$ 可以延伸 $k$ 条。
连向汇点的边则代表 已经被覆盖（即被摧毁）。
由于刚才已经提到过的 **摧毁点递增**，连边中必须有 $i<j$。

## Floyd 的更改

但是细心的同学可能会发现一个问题：floyd 求出的最短路不保证 $i$ 到 $j$ 不经过编号 $>j$ 的点，$j$ 就不是 $i$ 之后第一个摧毁的点了。

因此我们需要给普通的 floyd 求出的 $d(i, j)$ 加上一条限制：从 $i$ 到 $j$ 不能经过编号大于 $\max(i,j)$ 的点，这样就能够保证正确性了。

（注：为什么是 $\max(i,j)$，而不能直接不转移 $i>j$ 的情况？因为有可能会出现 $i$ -> $(i-x)$ -> $(i+x)$ 的路径中转）

这样图就建好了，建完图直接跑费用流即可。

完整代码：

```cpp
#include <bits/stdc++.h>
#define N 154
#define INF 1000000000000000000ll
using namespace std;
typedef long long ll;

int n, m, K;
ll d[N][N];
ll S, T, nV, dis[N*2+2], mncst;
bool vst[N*2+2], inq[N*2+2];

struct es { int t; ll w, c; int nxt; } e[(N*N+N*2)*2];
int hd[N*2+2], cur[N*2+2], tot=1;

void add (int u, int v, ll w, ll c)
{
    e[++tot]=(es){ v, w, c, hd[u] };
    hd[u]=tot;
    e[++tot]=(es){ u, 0, -c, hd[v] };
    hd[v]=tot;
}

bool spfa ()
{
    queue <int> q;
    fill(dis+1, dis+nV+1, INF);
    dis[S]=0; q.push(S); inq[S]=1;

    while (!q.empty()) {
        int u=q.front(); q.pop();

        inq[u]=0;

        for (int i=hd[u]; i; i=e[i].nxt) {
            int v=e[i].t;
            if (!e[i].w || dis[v]<=dis[u]+e[i].c) { continue; }
            dis[v]=dis[u]+e[i].c;
            if (!inq[v]) { q.push(v); inq[v]=1; }
        }
    }
    return (dis[T]!=INF);
}

ll dfs (int u, ll fl)
{
    if (u==T || (!fl)) { return fl; }

    vst[u]=1;

    ll res=0;
    for (int i=cur[u]; i && fl; i=e[i].nxt) {
        cur[u]=i;
        int v=e[i].t;
        if (!e[i].w || vst[v] || dis[v]!=dis[u]+e[i].c) { continue; }
        ll f=dfs(v, min(fl, e[i].w));
        e[i].w-=f; e[i^1].w+=f;
        res+=f; fl-=f;
        mncst+=f*e[i].c;
    }

    vst[u]=0;

    return res;
}

void Dinic ()
{
    while (spfa()) {
        for (int i=1; i<=nV; i++) { cur[i]=hd[i]; }
        dfs(S, INF);
    }
}

int main ()
{
    scanf("%d %d %d", &n, &m, &K);
    n++;
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++) { d[i][j]=INF; }
        d[i][i]=0;
    }
    for (int i=1; i<=m; i++) {
        int u, v, c; scanf("%d %d %d", &u, &v, &c);
        u++; v++; d[u][v]=d[v][u]=min(d[u][v], (ll)c);
    }
    
    // 带限制的 floyd 求最短路
    
    for (int k=1; k<=n; k++) {
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=n; j++) {
                if (k<=max(i,j)) { d[i][j]=min(d[i][j], d[i][k]+d[k][j]); }
            }
        }
    }
    
    // 建图

    S=n*2+1; T=n*2+2; nV=T;

    for (int i=1; i<=n; i++) {
        for (int j=i+1; j<=n; j++) if (d[i][j]!=INF) {
            add(i, j+n, 1, d[i][j]);
        }
    }
    for (int i=2; i<=n; i++) { add(S, i, 1, 0); add(i+n, T, 1, 0); }
    add(S, 1, K, 0);

    Dinic(); // 费用流

    printf("%lld\n", mncst);

    return 0;
}
```

---

## 作者：Caicz (赞：4)

### [题目链接](https://www.luogu.com.cn/problem/P4542)

------------
#### #网络流#费用流#

首先 , 我们可以轻易的从数据范围`N<<M`看出，这是一道网络流

在得出算法后，我们开始考虑建模。

根据题目条件：
1. `在经过K-1号点之前，任何人是不能够经过K号据点的。`，同时由于 $N\le150$ 这里很容易想到跑一遍带限制的Floyd，即由 $x\to y$ ，不经过节点编号比 $y$ 大的点，再从所有编号小的点向编号大的点连一条流量为 $1$ , 边权为 $dis(i,j)$ 的边.
2. 同时，我们最终要到达 $N$ 号点，即每个点均需到达至少一次。所以我们将除了 $0$ 号点以外的点都向汇点连一条流量为 $1$ ，边权为 $0$ 的边
3. `小智一行K人从真新镇出发.`这个很好解决，我们直接从源点向 $0$ 号点连一条流量为 $K$,边权为 $0$ 的边

在粗略建模完成后，我们发现了一个问题: 从源点出去的流量远小于我们需要的最大流，所以我们考虑网络流常用的拆点思路解决。

**我们将每个点拆为入点和出点，将每个点的入点向汇点连边，再将源点向每个点的出点连一条流量为 $1$ 边权为 $0$ 的边，其余点之间的连边即从 $x$ 的出点，向 $y$ 的入点连边即可**

$$
\large\color{grey}{\text{Talk is cheap , show you the code}}
$$
```cpp
//核心建模代码
	for(register int u,v,w,i=1;i<=m;++i)
	{
		u=read(),v=read(),w=read();
		++u,++v;
		f[u][v]=f[v][u]=min(f[u][v],w);
	}
	for(register int i=1;i<=n;++i)f[i][i]=0;
	for(register int k=1;k<=n;++k)
		for(register int i=1;i<=n;++i)
			for(register int j=1;j<=n;++j)
				if(k<i||k<j)f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	for(register int i=1;i<=n;++i)
		for(register int j=i+1;j<=n;++j)
			if(f[i][j]!=inf)addedge(i,j+n,inf,f[i][j]);
	addedge(s,1,lim,0);
	for(register int i=1;i<=n;++i)
	{
		addedge(i+n,t,1,0);
		if(i!=1)addedge(s,i,1,0);
	}
```


---

## 作者：GoPoux4 (赞：4)

最小费用最大流。

---

#### 建模

先考虑一个人如何从 $u$ 走到 $v$，并且 $v$ 还没有被摧毁。

要想摧毁 $v$ 号据点，必须先摧毁 $1$ 到 $v-1$ 号据点，所以说从 $u$ 走到 $v$ 只能经过**编号小于等于** $v$  的据点。因为要求路径长度最小，所以一定走的是满足约束（只经过编号 $\leq v$ 的据点）的路径中的**最短路**，先把这个信息预处理出来：

设 $d_{i,j}$ 表示从 $i$ 到 $j$，只经过编号 $\leq j$ 的据点的最短路长度。由于 $N \leq 150$ ，使用~~魔改~~Floyd预处理：

```cpp
inline void Floyd()
{
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int l=1;l<=n;++l) if(i<max(j,l))
				d[j][l]=min(d[j][l],d[j][i]+d[i][l]);
}
```

（为了方便，图中所有据点的编号在代码中均 $+1$）

现在加入其他的人，把这个题看作一个动态的过程。一个人可以走一段后停留在一个据点，等待其他人摧毁一些据点后再继续走，我们把走一段这个过程看作一次行动。

可以发现，一个据点既可以为一次行动的出发点，又可以看作一次行动的结束点，即一个据点有两种信息。于是使用网络瘤中常用的**拆点法**，将一个据点拆成两个点，分别处理**出发**和**结束**两个信息，设点 $i$ 拆出的两个点分别为 $i$ 和 $i'$。

将上述的一次行动作为一条边放入网络中。若 $i$ 可以经过编号小于等于 $j$ 的据点到达 $j$，则连边 $i \to j'$，流量为 $\infty$，费用即为刚才预处理出的 $d_{i,j}$。

连边 $s \to 1$，容量为 $K$，表示从 $1$ 出发的有 $K$ 人。

然后对于其他的据点 $i$，连边 $s \to i$，容量为 $1$，表示从 $i$ 出发。连边 $i' \to t$，容量为 $1$，费用为 $0$，表示据点 $i$ 是否被摧毁，即是否到达。

可见若有流经过 $s \to i \to j' \to t$，则进行了行动 $i \to j$。

当且仅当所有流入 $t$ 的边都满载，即所有据点都被摧毁，此时得到最大流，求出得到最大流时的最小费用即可。

---

$\text{Code}:$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <queue>
#define maxn 10005
#define maxm 100005
#define R register
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

struct edge
{
	int v,cp,w,next;
}e[maxm<<1];

int head[maxn],k;

inline void add(int u,int v,int cp,int w)
{
	e[k]=(edge){v,cp,w,head[u]};
	head[u]=k++;
	e[k]=(edge){u,0,-w,head[v]};
	head[v]=k++;
}

int n,m,d[200][200],mincost;

inline void Floyd()
{
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int l=1;l<=n;++l) if(i<max(j,l))
				d[j][l]=min(d[j][l],d[j][i]+d[i][l]);
}

int dis[maxn],nxt[maxn];
bool vis[maxn];

inline bool SPFA(int s,int t)
{
	queue<int> q;
	memset(dis,-1,sizeof(int)*(n<<2));
	dis[s]=0;
	vis[s]=true;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		nxt[u]=head[u];
		vis[u]=false;
		for(int i=head[u];~i;i=e[i].next)
		{
			int v=e[i].v;
			if(e[i].cp&&(!~dis[v]||dis[v]>dis[u]+e[i].w))
			{
				dis[v]=dis[u]+e[i].w;
				if(!vis[v]) q.push(v),vis[v]=true;
			}
		}
	}
	return ~dis[t];
}

inline int Dinic(int u,int t,int flow)
{
	if(u==t||!flow) return flow;
	int rest=flow,i;
	vis[u]=true;
	for(i=nxt[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(!e[i].cp||dis[v]!=dis[u]+e[i].w||vis[v]) continue;
		int k=Dinic(v,t,min(rest,e[i].cp));
		if(!k) continue;
		mincost+=e[i].w*k;
		e[i].cp-=k;
		e[i^1].cp+=k;
		rest-=k;
		if(!rest) break;
	}
	vis[u]=false;
	nxt[u]=i;
	return flow-rest;
}

int main()
{
	// freopen("P4542.in","r",stdin);
	n=read()+1,m=read();
	int K=read();
	memset(d,0x3f,sizeof(d));
	for(int i=1;i<=m;++i)
	{
		int u=read()+1,v=read()+1;
		d[u][v]=d[v][u]=min(d[u][v],read());
	}
	for(int i=1;i<=n;++i) d[i][i]=0;
	Floyd();
	int s=0,t=1;
	memset(head,-1,sizeof(head));
	for(int i=1;i<=n;++i)
	{
		if(i!=n) add(s,i<<1,i==1?K:1,0);
		if(i!=1) add(i<<1|1,t,1,0);
		for(int j=i+1;j<=n;++j)
			if(d[i][j]!=INF) add(i<<1,j<<1|1,INF,d[i][j]);
	}
	// for(int i=0;i<k;i+=2)
	// 	printf("%d -> %d %d %d\n",e[i^1].v,e[i].v,e[i].cp,e[i].w);
	int maxflow=0;
	while(SPFA(s,t))
		maxflow+=Dinic(s,t,1<<30);
	printf("%d\n", mincost);
	return 0;
}

```

---

## 作者：strcmp (赞：3)

这是我人生第一篇黑题题解，也是我临终后的第一篇题解（对这句话有疑问的可以看一下五月二号的陶片）

**步入正题**

首先，看到 $N \le 150$，第一时间想到网络流。

首先，列出题目条件：

1. 共有 $K$ 个人

2. 每个结点必须至少被经过一次，且每个人可以在任意点出发或结束

3. 在 $K$ 号结点被走过之前，每个人都只能在所有编号小于 $K$ 的结点都被经过后才能走到编号为 $K$ 的结点

4. 在满足上述所有条件的前提下，要求经过的路径长度之和最小

如果对网络流的各种建模熟悉的话，容易看出是简化题意是**用 $K$ 个路径，在满足约束和花费最小的前提下，覆盖所有的点。**

$K$ 个路径很好处理，建立超级源 $s$，从 $s$ 到 $0$ 号结点连一条费用为 $0$，容量为 $K$ 的结点，对这种建模有疑问的可以看一下这道题 [Dijkstra, Dijkstra.](https://www.luogu.com.cn/problem/UVA10806)

第二个条件，考虑拆点，将结点 $u$ 拆为入点 $u'$ 和出点 $u''$，可以想到从 $s$ 向每个入点 $u'$ 连一条容量为 $1$，费用为 $0$ 的边；从每个出点 $u''$ 向 $t$ 连一条容量为 $1$，费用为 $0$ 的边。

**第三个条件是最难处理的，也是这道题的压轴部分。**

我们发现不引入其他算法是很难模拟题目中所给条件了。

考虑将第三个条件这样描述：**当前结点 $u$ 走到另外一个结点 $v$，只能经过从 $u$ 到 $v$ 且路径上所有结点的编号都不大于 $\max(u,\,v)$ 的最短路径**

考虑到图中有负权边，且边的数量很大，但结点数目很小，所以**我们使用 Floyd 预处理最短路径。**

预处理最短路径之后，就好办了。设 $\operatorname{dis}_{i,\,j}$ 为从 $i$ 到 $j$ 的最短路径长度，每个结点 $u$ ,都向编号比 $u$ 大的非源汇结点 $v$ 连边。用 DAG 的最小路径覆盖的连边方式，从 $u''$ 向 $v'$ 连边，容量为 $+\infty$，费用为 $\operatorname{dis}_{u,\,v}$。

第四个条件，直接跑最小费用最大流，费用即为最终答案。

ACcode

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 100100
#define E 500100
typedef long long int ll;
struct edge {
	int to, next;
	ll capa, cost;
};
int cnt = 0, head[V], n, m; edge node[E];
inline void add(int fir, int nxt, ll w, ll c) {
	node[cnt].to = nxt,
		node[cnt].capa = w,
		node[cnt].cost = c,
		node[cnt].next = head[fir],
		head[fir] = cnt++;
}
int s, t, cur[V]; deque<int>que; ll dep[V], sum = 0, cost = 0;
bool vis[V];
inline bool spfa() {
	for (register int i = 0; i <= t; ++i)dep[i] = inf;
	dep[s] = 0; que.push_back(s); int u, v;
	while (!que.empty()) {
		v = que.front(); que.pop_front();
		for (register int i = head[v]; i != -1; i = node[i].next) {
			u = node[i].to;
			if (dep[v] + node[i].cost < dep[u] && node[i].capa) {
				dep[u] = dep[v] + node[i].cost;
				if (!que.empty() && dep[u] < dep[que.front()])que.push_front(u);
				else que.push_back(u);
			}
		}
	}
	return (dep[t] != inf);
}
ll dfs(register int v, register ll flow) {
	if (v == t || flow == 0)return flow; ll used = 0, wei = 0;
	vis[v] = true;
	for (register int i = cur[v]; i != -1; i = node[i].next) {
		cur[v] = i;
		if (!vis[node[i].to] && dep[node[i].to] == dep[v] + node[i].cost && node[i].capa) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei,
					node[i ^ 1].capa += wei,
					used += wei,
					cost += node[i].cost * wei;
			}
		}
		if (used == flow)break;
	}
	vis[v] = false;
	return used;
}
inline void Dinic() {
	while (spfa()) {
		memcpy(cur, head, (t + 1) * sizeof(int));
		sum += dfs(s, inf);
	}
}
ll d, dis[205][205];
inline void addE(int u, int v, ll w, ll c) {
	add(u, v, w, c);
	add(v, u, 0, -c);
}
void init() {
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if(i != j)dis[i][j] = inf;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(); cout.tie();
	memset(head, -1, V * sizeof(int));
	cin >> n >> m >> d; ++n;
	int u, v; ll w; s = 2 * n + 1, t = 2 * n + 2;
	addE(s, 1, d, 0);init();
	for (int i = 1; i <= m; i++) {
		cin >> u >> v >> w; ++u, ++v;
		dis[u][v] = dis[v][u]  = min(dis[u][v], w);
	}
	for (int k = 1; k <= n; k++)
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				if (k <= max(i, j))dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
	for (int i = 1; i <= n; i++) {
		if(i !=	1)addE(s, i, 1, 0);
		addE(i + n, t, 1, 0);
		for (int j = i + 1; j <= n; j++) {
			if (dis[i][j] != inf)addE(i, j + n, inf, dis[i][j]);
		}
	}
	Dinic();
	cout << cost;
	return 0;
}

```


---

## 作者：_saltFish_ (赞：2)

[博客园食用效果更佳](https://www.cnblogs.com/ytxy-bolg/articles/P4542.html)。

## 题面简述

给出一张 $N + 1$ 个点，$M$ 条边的无向连通图，每一条边有一个代价 $L_i$。

有 $K$ 个人，他们从 $0$ 号结点出发，可以分开。

对于每一个结点 $i$ 必须在已经经过 $i - 1$ 号结点之后才能通行。

求到达 $N$ 号结点的最小代价。

数据保证有解，且 $N \le 150,M \le 2 \times {10}^{4},K \le 10,L_i \le {10}^{4}$。

## 解题思路

这一题可以转化为求选出 $k$ 条路径，使得这 $k$ 条路径覆盖整张图，路径之间可以有重合。

那为什么可以这么想呢。首先这 $k$ 个人是可以分头行动的。

其次如果一个人在 $i$ 号结点,有一条通向 $j (j > i)$ 的边，但 $j - 1$ 号结点还没有走过，那他是可以在原地等到 $j - 1$ 被走过之后再走 $j$ 号结点的。

所以无论什么时候都至少有一个人可以走动，并且在他移动后又会有人能走动，我们便将这一题转化为了上述的意思。

因为受到“对于每一个结点 $i$ 必须在已经经过 $i - 1$ 号结点之后才能通行。”的影响，我们需要魔改一下 floyd 算法，将 $dis_{i,j}$ 定义为从 $i$ 到 $j$ 不经过 $> \max\{i, j\}$ 的结点的最短路径，这样一来就构造了一张新图。

此时，这一题就变成了在这一张新图上求 $k$ 条边的最小权路径覆盖。

考虑到这是一张一般图，我们将每一个结点 $i$ 拆成 $i_1,i_2$ 两个点，这样一来它就变成了一张二分图。

建立超级源点 $s$ 和超级汇点 $t$，因为这是二分图，所以连边 $(s,i_1,1,0),(i_2,t,1,0)$。

考虑到二分图的性质，我们将新图中的边 $(u,v,L_i)$ 换成 $(u_2,v_1,1,L_i)$ 或类似的连边方式。

但 $(s,0)$ 的这一条边的容量需要改为 $k$ 来支持我们选择 $k$ 条路径。

接下来就是跑最小费用最大流求解了。

时间复杂度 $\mathcal{O}({n}^{3}+mcmf(n,{n}^{2}))$，足以通过本题。

## 代码

```cpp
#include<iostream>
#include<queue>
#define INF ((int)1e9+(int)1e8)
using namespace std;
const int N(155),NN(2000),M(2e4+5);
int n,m,k,ds[N][N],s,t;
void floyd(){
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n;k++)
				if(k<max(i,j))
					ds[j][i]=ds[i][j]=min(ds[i][k]+ds[k][j],ds[i][j]);
}
int tot=1,head[NN],to[M<<1],nxt[M<<1],cst[M<<1],flow[M<<1];
inline void add(int x,int y,int flw,int c){
	nxt[++tot]=head[x],to[head[x]=tot]=y,flow[tot]=flw,cst[tot]=c;
	nxt[++tot]=head[y],to[head[y]=tot]=x,flow[tot]=0,cst[tot]=(c==0)?0:-c;
}
bool used[NN];
int lstn[NN],lste[NN],dis[NN];
queue<int> q;
int mcmf(){
	int cost=0;
	while(114514){
		for(int i=1;i<=t;i++) dis[i]=INF;
		dis[s]=0;
		q.push(s);
		while(!q.empty()){
			int u=q.front();
			q.pop();
			used[u]=0;
			for(int i=head[u];i;i=nxt[i]){
				int v=to[i];
				if(flow[i]&&dis[v]>dis[u]+cst[i]){
					dis[v]=dis[u]+cst[i];
					lstn[v]=u;lste[v]=i;
					if(!used[v]){
						used[v]=1;
						q.push(v);
					}
				}
			}
		}
		if(dis[t]==INF) break;
		int newflow=k;
		for(int x=t;x!=s;x=lstn[x])
			newflow=min(newflow,flow[lste[x]]);
		for(int x=t;x!=s;x=lstn[x])
			flow[lste[x]]-=newflow,flow[lste[x]^1]+=newflow;
		cost+=dis[t]*newflow;
	}
	return cost;
}
int main(){
	#ifdef ytxy
	freopen("in.txt","r",stdin);
	#endif
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	n++;
	s=n*2+1,t=n*2+2;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			ds[i][j]=INF;
		}
		ds[i][i]=0;
	}
	for(int i=1;i<=m;i++){
		int x,y,w;
		cin>>x>>y>>w;
		ds[x+1][y+1]=ds[y+1][x+1]=min(w,ds[x+1][y+1]);
	}
	floyd();
	for(int i=1;i<=n;i++){
		if(i==1) add(s,i*2-1,k,0);
		else add(s,i*2-1,1,0);
		add(i*2,t,1,0);
		for(int j=i+1;j<=n;j++)
			add(i*2-1,j*2,1,ds[i][j]);
	}
	cout<<mcmf();
}
```

---

## 作者：xtx1092515503 (赞：2)

这里是完完全全低人一等的垃圾做法。

------

首先先说一下自己的思路：因为击败位置 $i$ 的人只能经过前 $i$ 个点，因此就有这样一种思路：建立 $n$ 层的图，第 $i$ 层节点数是 $i$，即前 $i$ 个点。用 $(i,j)$ 表示第 $i$ 层的第 $j$ 个点。则，我们连边 $\Big((i,j),(i+1,j),\infty,0\Big)$，用来表示那些不击败位置 $i$ 的人；而对于连接 $(i,i)$ 与 $(i+1,i)$ 的边，我们用上下界网络流限制这条边必须流经。然后，在每层里面，我们仅连原图中两端点均 $\leq i$ 的边。此方法正确性显然，但是粗略估计一下，每层都要连 $m$ 条边，一共 $n$ 层，点数 $n^2$，边数 $nm=n^3$，怎么想都不可能过罢。

但是发现，我们可以把每个人都留到它击败某层的位置的时候再走。具体而言，在第 $i$ 层，我们不连接全部 $m$ 条边，而是对于 $j<i$，连接 $\Big((i,j),(i,i),\infty,dis_{i,j}\Big)$，表示仅考虑 $\leq i$ 的边的最短路，或者说以 $i$ 为根的最短路径树。显然，此方法点数 $n^2$，边数 $n^2$，硬上，过了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,s,t,tot,DIS[210][210],num[210][210];
namespace MCMF{
	const int N=12000;
	const int M=7000000;
	int head[N],cnt,deg[N],id[N],S,T,dis[N],cost;
	struct edge{int to,next,val,cost;}edge[M];
	void ae(int u,int v,int w,int c){
//		printf("%d %d (%d,%d)\n",u,v,w,c);
		edge[cnt].cost=c,edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
		edge[cnt].cost=-c,edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++;
	}
	void ae(int u,int v){deg[u]--,deg[v]++;}
	queue<int>q;
	bool in[N];
	bool SPFA(){
		q.push(S),memset(dis,0x3f,sizeof(dis)),dis[S]=0,in[S]=true;
		while(!q.empty()){
			int x=q.front();q.pop(),in[x]=false;
			for(int i=head[x],y;i!=-1;i=edge[i].next)if(edge[i].val&&dis[y=edge[i].to]>dis[x]+edge[i].cost){
				dis[y]=dis[x]+edge[i].cost,id[y]=i;
				if(!in[y])in[y]=true,q.push(y);
			}
		}
		if(dis[T]==0x3f3f3f3f)return false;
		int mn=0x3f3f3f3f;
		for(int x=T;x!=S;x=edge[id[x]^1].to)mn=min(mn,edge[id[x]].val);
		cost+=mn*dis[T];
		for(int x=T;x!=S;x=edge[id[x]^1].to)edge[id[x]].val-=mn,edge[id[x]^1].val+=mn;
		return true;
	}
}
using namespace MCMF;
int main(){
	scanf("%d%d%d",&n,&m,&p),memset(DIS,0x3f,sizeof(DIS)),memset(head,-1,sizeof(head));
	for(int i=0;i<=n;i++)DIS[i][i]=0;
	for(int i=1,x,y,z;i<=m;i++)scanf("%d%d%d",&x,&y,&z),DIS[x][y]=DIS[y][x]=min(DIS[x][y],z);
	for(int i=0;i<=n;i++)for(int j=0;j<=i;j++)num[i][j]=++tot;
	s=++tot,t=++tot,S=++tot,T=++tot;
	ae(s,num[0][0],p,0);
	for(int k=0;k<=n;k++){
		for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)DIS[i][j]=min(DIS[i][j],DIS[i][k]+DIS[k][j]);
		for(int i=0;i<=k;i++)ae(num[k][i],num[k][k],0x3f3f3f3f,DIS[i][k]),ae(num[k][i],t,0x3f3f3f3f,0);
		if(k<n){
			for(int i=0;i<=k;i++)ae(num[k][i],num[k+1][i],0x3f3f3f3f,0);
			ae(num[k][k],num[k+1][k]);
		}
	}
	ae(num[n][n],t);
	ae(t,s,0x3f3f3f3f,0);
	for(int i=1;i<=t;i++){
		if(deg[i]>0)ae(S,i,deg[i],0);
		if(deg[i]<0)ae(i,T,-deg[i],0);
	}
	while(SPFA());
	printf("%d\n",cost);
	return 0;
}
```

然后是正解。正解只需要观察到可以把问题转换成 $k$ 个人，每个人击败的位置递增，且两两人的位置集合无交即可。于是问题转换为DAG上路径覆盖问题，随便拆点就完事了。~~代码咕了~~

---

## 作者：tzc_wk (赞：2)

安利个人 blog：https://www.cnblogs.com/ET2006/

先预处理出 $dis_{u,v}$ 表示从 $u\to v$ 只经过编号 $\leq\max(u,v)$ 的点，所经过的距离的最小值。显然 $dis_{u,v}$ 可用 Floyd 在 $n^3$ 的复杂度内处理出来。

假设 $k$ 个人所摧毁的据点的序列分别为 $(a_{1,1},a_{1,2},\dots,a_{1,c_1}),(a_{2,1},a_{2,2},\dots,a_{2,c_2}),\dots,(a_{k,1},a_{k,2},\dots,a_{k,c_k})$（$a_{i,j}<a_{i,j+1}$）。那么需要花费的最小时间就是 $\sum\limits_{i=1}^k\sum\limits_{j=1}^{c_i-1}dis_{a_{i,j},a_{i,j+1}}+\sum\limits_{i=1}^kdis_{0,a_{i,1}}$

为什么？考虑编号为 $1$ 的据点是谁摧毁的，假设 $1$ 号据点是第 $x_1$ 个人第 $y_1$ 个摧毁的据点，那么它从自己第 $y_1-1$ 个摧毁的据点（默认每个人第 $0$ 个摧毁的据点就是 $0$）到达 $1$ 号据点的过程中不能经过编号 $>1$ 的据点，故所花费的最小时间就是 $dis_{a_{x_1,y_1-1},a_{x_1,y_1}}$。$1$ 号据点摧毁了，接下来考虑 $2$ 号据点，同理假设 $2$ 号据点是第 $x_2$ 个人第 $y_2$ 个摧毁的据点，那么第 $x_2$ 个人从自己第 $y_2-1$ 个摧毁的据点赶过来需要花费的时间就是 $dis_{a_{x_2,y_2-1},a_{x_2,y_2}}$，以此类推可得上式。

看到这样类似于路径覆盖的问题，可想到用网络流解决。我们用一条流来表示一个人摧毁据点的路径。借鉴 P4553 80人环游世界 的建图方式可得：

- 将每个点 $u$ 拆成两个点 $in_u$ 和 $out_u$。对于 $u\geq 1$ 连边上下界均为 $1$ 费用 $0$ 的边表示每个据点必须被恰好一个人摧毁。对于 $u=0$ 连上界 $k$ 下界 $0$ 费用 $0$ 的边，表示最多 $k$ 个人经过 $0$ 号据点。
- 连一条从 $S$ 到 $in_0$，上界 $k$ 下界 $0$ 费用 $0$ 的边表示 $k$ 个人必须从 $0$ 号节点开始摧毁据点。对于 $u=0,1,2,\dots,n$ 连一条从 $out_u$ 到 $T$，上界 $k$ 下界 $0$ 费用 $0$ 的边表示每个人可以在任意节点结束摧毁。
- 对于每对满足 $(i<j)$ 的 $(i,j)$ 连一条从 $out_i$ 到 $in_j$ 上界 $1$ 下界 $0$ 费用 $dis_{i,j}$ 的边表示从 $i$ 到 $j$ 需要的时间为 $dis_{i,j}$。

然后跑上下界最小费用最大流即可。

但是题解区总有比我更优秀的做法。事实上，本题也有不用上下界网络流的做法。观察一下上面的做法可以发现，这个所谓的“摧毁据点的路径”，不就是不可相交的路径覆盖吗！路径的开头元素还有一个代价 $dis_{0,a_{i,1}}$。立马想到 P2469 [SDOI2010]星际竞速。只不过此题要求路径个数 $\leq k$。所以你在 P2469 [SDOI2010]星际竞速 新建一个超级源点 $S'$ 并连一条从 $S'$ 到 $S$ 容量为 $k$ 费用为 $0$ 的边，然后跑 Minimum Cost Maximum Flow 就行了。

---

## 作者：Jμdge (赞：2)

如果这道题求的是最短时间的话可能就不大好做了QWQ...于是这题求的是最短路径和

首先这么小的数据范围可以康出来是网络流的嘛...那就尽量往网络流那边靠

首先考虑单独一个人的行进路线，那么路线必然满足每次从当前点 x 到目标点 y 时经过的点都小于 y ，那么咱每次单独考虑一个人，然后做个带限制的 floyd 就好辣

然后咱考虑每个点都要被经过，这不就是最大流么...除了 0 号点，每个点向 T 连边就可以满足不是每个人都要到达终点但是每个点都会被经过一次，然后 S 向 0 号点连条容量为 K 的边，这样的话就满足最多 K 个人出发救 pkq 辣，最后两两点之间还要连边，边权为 floyd 处理出来的最短路


最后跑个 mincost-maxflow 就好辣



```
//by Judge
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(Rg int i=head[u],v=e[i].to;i;v=e[i=e[i].nxt].to)
#define ll long long
using namespace std;
const int inf=1e9+7,M=2003;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmin(int& a,int b){return a>b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,K,s,t,pat=1; arr head,dis[M];
struct Edge{ int to,val,flow,nxt; }e[200005];
inline void add(int u,int v,int f,int c){
	e[++pat]=(Edge){v,c,f,head[u]},head[u]=pat;
	e[++pat]=(Edge){u,-c,0,head[v]},head[v]=pat;
}
inline int mcmf(){ queue<int> q;
	Rg int res=0; static arr dis,in,pe,pv;
	while(1){
		fp(i,1,t) dis[i]=inf;
		dis[s]=0,q.push(s);
		while(!q.empty()){
			Rg int u=q.front(); q.pop(),in[u]=0;
			go(u) if(e[i].flow&&dis[v]>dis[u]+e[i].val){
				dis[v]=dis[u]+e[i].val,pe[v]=i,pv[v]=u;
				if(!in[v]) q.push(v),in[v]=1;
			}
		}
		if(dis[t]==inf) return res;
		Rg int d=inf;
		for(Rg int u=t;u^s;u=pv[u])
			cmin(d,e[pe[u]].flow);
		res+=d*dis[t];
		for(Rg int u=t;u^s;u=pv[u])
			e[pe[u]].flow-=d,e[pe[u]^1].flow+=d;
	}
}
int main(){
	n=read()+1,m=read(),K=read(),s=n*2+1,t=n*2+2;
	fp(i,1,n) memset(dis[i],0x3f,(n+2)<<2),dis[i][i]=0;
	fp(i,1,m){
		Rg int u=read()+1,v=read()+1,w=read();
		cmin(dis[u][v],w),dis[v][u]=dis[u][v];
	}
	fp(k,1,n) fp(j,1,n) fp(i,1,n) if(k<i||k<j)
		cmin(dis[i][j],dis[i][k]+dis[k][j]);
	fp(i,1,n){
		if(i==1) add(s,i*2-1,K,0);
		else add(s,i*2-1,1,0);
		add(i*2,t,1,0);
		fp(j,i+1,n) add(i*2-1,j*2,1,dis[i][j]);
	}
	return !printf("%d\n",mcmf());
}
```



---

## 作者：SIXIANG32 (赞：2)

所以说我这只 Pikachu 被火箭队抢走了然后自己用渣渣的 OI 技术向小智通过心灵感应告诉了如何解救自己？  
~~皮卡丘没有心灵感应的技能吧~~  
闲话少说，切入正题——  

---
首先我们来抽象一下题面。  
> 有一个 $n$ 点 $m$ 边的图，用 $k$ 条路径覆盖所有点，使得边权最小。规定每一条路径节点编号单调递增，$n \le 150, m \le 200000, k\le10$ 

看到 $n \le 150$，容易想到网络流拆点然后费用流。  
现在问题来了——如何建图呢？  

---
首先容易想到用 floyd 来求多源最短路径作为连边的费用。  
然后可以老套路拆点。  
把点 $x$ 拆成 $x, x'(x + n)$ 两个点。   
对于边 $(x, y')$ 并且 $dis_{x, y}\not= INF$，连一条费用为 $dis_{x, y}$，容量为 $INF$ 的边，代表这条边可以重复走，每走一次都要花费 $dis_{x, y}$ 的代价。  
剩下的比如说 $(s, x)$ 啊，$(x', y)$ 等等边，它们的费用是 $0$，容量是 $1$，显然的网络流老套路。  
但是请注意特判一个 $(s, 1)$，这条边的费用为 $0$，容量为 $k$，表示 $k$ 个人来找 pikachu 了。  

---
代码：  
```cpp
#include <cstdio> 
#include <queue>
#include <cstring>
#define N 200
#define M 200000
#define QWQ cout << "QWQ" << endl;
const int INF = 1000000000;
using namespace std;
int n, m, dis[N + 10][N + 10], s, t, k;
int min(int x, int y) {return ((x < y) ? (x) : (y));}
int max(int x, int y) {return ((x > y) ? (x) : (y));}
void ready() {//floyd 预处理
	for(int p = 1; p <= 200; p++)
		for(int i = 1; i <= 200; i++)
			if(p != i) dis[p][i] = INF;
}
void init() {//输入
	ready();
	scanf("%d%d%d", &n, &m, &k), n++, s = n * 2 + 1, t = n * 2 + 2;
	for(int p = 1, x, y, z; p <= m; p++) {
		scanf("%d%d%d", &x, &y, &z), x++, y++;
		dis[x][y] = dis[y][x] = min(dis[x][y], z);//邻接矩阵要判重边
	}
}
void floyd() {
	for(int p = 1; p <= n; p++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				if(p < i || p < j)
					dis[i][j] = min(dis[i][j], dis[i][p] + dis[p][j]);
}
struct node {
	int to, val, ro, next;
} gra[M * 2 + 10];
int head[M * 2 + 10], tot = 1;
void link(int x, int y, int z, int R) {
	gra[++tot].to = y, gra[tot].val = z, gra[tot].ro = R, gra[tot].next = head[x], head[x] = tot;
	gra[++tot].to = x, gra[tot].val = -z, gra[tot].ro = 0, gra[tot].next = head[y], head[y] = tot;
}
void connect() {//建图，重中之重
	link(s, 1, 0, k);
	for(int p = 1; p <= n; p++) {
		if(p != 1) link(s, p, 0, 1);
		link(p + n, t, 0, 1);
	}
	for(int p = 1; p <= n; p++)
		for(int i = p + 1; i <= n; i++)
			if(dis[p][i] != INF)
				link(p, i + n, dis[p][i], INF);
}
int d[N + 10], pre[N + 10], over[N + 10];
bool vis[N + 10];
int maxn = 0, minn = 0;
void mcmf() {//最小费用最大流
	while(1) {
		queue <int> que;
	    que.push(s);
	    memset(d, 0x7f, sizeof(d));
	    memset(vis, 0, sizeof(vis));
	    int INF = d[0];
	    vis[s] = 1, d[s] = 0, over[s] = 0x7f7f7f7f;
	    while(!que.empty()) {
	        int fr = que.front(); que.pop();
	        vis[fr] = 0;
	        for(int p = head[fr]; p; p = gra[p].next) {
	            int v = gra[p].to, w = gra[p].val;
	            if(gra[p].ro && d[v] > d[fr] + w) {
	                d[v] = d[fr] + w;
	                pre[v] = p, over[v] = min(over[fr], gra[p].ro);
	                if(!vis[v]) {
	                    vis[v] = 1;
	                    que.push(v);
	                }
	            }
	        }
	    }
	    if(d[t] == INF) break;
		int now = t;
	    while(now != s) {
	        int pr = pre[now];
	        gra[pr].ro -= over[t];
	        gra[pr ^ 1].ro += over[t];
	        now = gra[pr ^ 1].to;
	    }
	    maxn += over[t];
	    minn += over[t] * d[t];
	}
}
signed main() {
	init(), floyd(), connect();
	mcmf();
    printf("%d", minn);
}
```

---

## 作者：xiezheyuan (赞：1)

[可能有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p4542.html)

## 简要题意

给你一个 $N+1$ 个顶点（编号为 $0 \sim N$），$M$ 条边的无向图，每一条边有一个代价 $L_i$。

有 $K$ 个人，他们初始时再 $0$ 号节点，他们可以分开行动，只有经过过 $i-1$ 号节点才能经过 $i$ 号节点。

求出到达 $N$ 号节点的每个人付出代价的和最小值。

数据保证合法，且满足 $N \leq 150, M \leq 2 \times 10^{4}, 1 \leq K \leq 10, L_i ≤ 10^{4}$

## 思路

由于只有到达过所有比 $i$ 小的点，所以这里是带限制的。对于求带限制的最小代价，我们选择使用 Floyd，不过需要魔改，转移时加上判断 `k<i || k<j`。

然后，还是为了满足限制，我们可以构造一个新图，图中任意边 $(u,v,w)$ 满足 $u \lt v$ 且 $w=f_{u,v}$。（$f_{u,v}$ 表示 $u \to v$ 的最小代价）

那么就转换成了求这个图的 $K$ 条路径的最小权路径覆盖。由于这个图不是二分图，我们考虑将其变成二分图（因为二分图比较好求）。将一般图转换为二分图的最简单的方法之一就是拆点。

我们将新图中的点 $i$ 拆成 $i_1,i_2$ 两个点，然后建立超级源点 $S$ 和超级汇点 $T$。

钦定 $i_1,j_1,k_1,\cdots$ 是同一个颜色的，$i_2,j_2,k_2,\cdots$ 是同一个颜色的。则连边 $(S,i_1,1,0)$ 和 $(i_2,T,1,0)$。

然后就是新图的边了，为了满足二分图性质，我们需要再不同颜色中连边，譬如对于新图中的边 $(u,v,w)$，连边 $(u_2,v_1,1,w)$（类似方法也可以）。

但是这样子只是 $1$ 条路径，不是 $K$ 条路径。我们直接将 $S$ 连向 $0$ 的边的容量改为 $K$，这样就允许了 $K$ 条路径（因为这条边可以增广 $K$ 次）。

然后跑最小费用最大流。就没了

时间复杂度 $O(n^{3}+\operatorname{mcmf}(n,n^{2}))$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = (150+5)<<1,M = (20000+5)<<2;

int f[N][N];
int n,m,k;
void add(int u,int v,int w){
	f[u][v]=min(f[u][v],w);
}

void floyd(){
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=n;k++){
				if(k<i || k<j){
					f[j][i]=f[i][j]=min(f[i][j],f[i][k]+f[k][j]); // 注意这里 f[j][i] 和 f[i][j] 都需要被赋值。
				}
			}
		}
	}
}

namespace MCMF{
	struct edge{
		int nxt,to,cap,cost;
	} g[M];
	int head[N],ec=-1;
	void add(int from,int to,int cap,int cost){
		g[++ec].nxt=head[from];
		g[ec].to=to;
		g[ec].cap=cap;
		g[ec].cost=cost;
		head[from]=ec;
	}
	void add_edge(int from,int to,int cap,int cost){
		add(from,to,cap,cost);
		add(to,from,0,-cost);
	}
	queue<int> q;
	bool vis[N];
	int flow[N];
	int dis[N];
	int pre[N];
	int last[N];
	bool spfa(int s,int t){
		memset(dis,0x7f,sizeof(dis));
		memset(flow,0x7f,sizeof(flow));
		memset(vis,0,sizeof(vis));
		q.push(s);
		vis[s]=1;
		dis[s]=0;
		pre[t]=-1;
		while(!q.empty()){
			int u=q.front();
			q.pop();
			vis[u]=0;
			for(int i=head[u];i!=-1;i=g[i].nxt){
				int v=g[i].to;
				if(g[i].cap>0 && dis[v]>dis[u]+g[i].cost){
					dis[v]=dis[u]+g[i].cost;
					pre[v]=u;
					last[v]=i;
					flow[v]=min(flow[u],g[i].cap);
					if(!vis[v]){
						vis[v]=1;
						q.push(v);
					}
				}
			}
		}
		return pre[t]!=-1;
	}

	pair<int,int> MCMF(int s,int t){
		int maxflow=0,mincost=0;
		while(spfa(s,t)){
			int now=t;
			maxflow+=flow[t];
			mincost+=flow[t]*dis[t];
			while(now!=s){
				g[last[now]].cap-=flow[t];
				g[last[now]^1].cap+=flow[t];
				now=pre[now];
			}
		}
		return make_pair(maxflow,mincost);
	}
}

signed main(){
	memset(f,0x3f,sizeof(f));
	memset(MCMF::head,-1,sizeof(MCMF::head));
	MCMF::ec=-1;
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=0;i<=n;i++){
		f[i][i]=0;
	}
	for(int i=1,a,b,l;i<=m;i++){
		cin>>a>>b>>l;
		add(a,b,l);
		add(b,a,l);
	}
	floyd();
	int s=(n+1)<<1,t=(n+1)<<1|1;
	for(int i=0;i<=n;i++){
		if(i){
			MCMF::add_edge(s,i<<1|1,1,0);
			MCMF::add_edge(i<<1,t,1,0);
		}
		else{
			MCMF::add_edge(s,i<<1|1,k,0);
			MCMF::add_edge(i<<1,t,1,0);
		}
		for(int v=i+1;v<=n;v++){
			MCMF::add_edge(i<<1|1,v<<1,1,f[i][v]);
		}
	}
	int ret=MCMF::MCMF(s,t).second;
	cout<<ret;
	return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/87873181)

[BZOJ2324 [ZJOI2011]营救皮卡丘(In Hydro) AC Record](https://hydro.ac/d/bzoj/record/63350de35741ce02211bacdb)

---

## 作者：Huami360 (赞：1)

[题目链接](https://www.luogu.org/problemnew/show/P4542)

用最多经过$k$条经过$0$的路径覆盖所有点。

定义$ds[i][j]$表示从$i$到$j$不经过大于$max(i,j)$的点的最短路，显然可以用弗洛伊德求。

然后每个点拆成入出点，连边

源点向$0$的入点连流量k费用0的边，表示最多经过$0$K次

源点向其余每个点的入点连流量1费用0的边

每个$i$的入点向$j(j>i)$连流量1费用$ds[i][j]$的边

每个点出点向汇点连流量1费用0的边

最小费用即为所求。
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#define INF 2147483647
using namespace std;
const int MAXN = 350;
const int MAXM = 40010;
struct Edge{
	int from, next, to, rest, cost;
}e[MAXM];
int head[MAXN], num = 1, n, m, k;
inline void Add(int from, int to, int flow, int cost){
	e[++num] = (Edge){from, head[from], to, flow, cost}; head[from] = num;
	e[++num] = (Edge){to, head[to], from, 0, -cost}; head[to] = num;
}
int s, t, a, b, c, d[MAXM], now, maxflow, mincost;
queue <int> q;
int v[MAXN], dis[MAXN], pre[MAXN], flow[MAXN], ds[MAXN][MAXN];
int re(){
	q.push(s);
	memset(dis, 127, sizeof dis);
	memset(flow, 0, sizeof flow);
	dis[s] = 0; pre[t] = 0; flow[s] = INF;
	while(q.size()){
		now = q.front(); q.pop(); v[now] = 0;
		for(int i = head[now]; i; i = e[i].next)
		   if(e[i].rest && dis[e[i].to] > dis[now] + e[i].cost){
		     dis[e[i].to] = dis[now] + e[i].cost;
		     pre[e[i].to] = i; flow[e[i].to] = min(flow[now], e[i].rest);
		     if(!v[e[i].to]) v[e[i].to] = 1, q.push(e[i].to);
		   }
	}
	return pre[t];
}
int main(){
	scanf("%d%d%d", &n, &m, &k); s = 345; t = 346;
	memset(ds, 63, sizeof ds);
	for(int i = 1; i <= m; ++i){
	   scanf("%d%d%d", &a, &b, &c);
	   ds[a][b] = ds[b][a] = min(ds[a][b], c);
    }
    for(int k = 0; k <= n; ++k)
       for(int i = 0; i <= n; ++i)
          for(int j = 0; j <= n; ++j)
             if(k < max(i, j) && ds[i][j] > ds[i][k] + ds[k][j])
               ds[i][j] = ds[i][k] + ds[k][j];
    for(int i = 0; i <= n; ++i){
    	Add(s, i, !i ? k : 1, 0);
    	Add(i + n + 1, t, 1, 0);
    	for(int j = i + 1; j <= n; ++j)
    	   Add(i, j + n + 1, 1, ds[i][j]);
    }
    while(re()){
    	now = pre[t];
    	while(now){
    		e[now].rest -= flow[t];
    		e[now ^ 1].rest += flow[t];
    		mincost += e[now].cost * flow[t];
    		now = pre[e[now].from];
    	}
    }
    printf("%d\n", mincost);
	return 0;
}
```

---

## 作者：Basori_Tiara (赞：0)

考虑我们如果要从第 $i$ 个城出发去攻打第 $j$ 个城 $(i<j)$，那么中间经过的点必须在 $\max(i,j)$ 以下我才可以走。

我们用 floyd 能够求出任意两个点之间的满足这种条件的最短路。

然后我们按照这个距离开一张新图。

我们相当于是要找 $k$ 条路径，他不能开倒车，（或者我们认为他每次开倒车都被涵盖在我们 floyd 求最短路的过程中了），并且路径的并涵盖所有点。

这个可以直接网络流建模。

首先一个点我们至少要经过一次，那我们就拆点，把一个点拆成入点和出点，入点向出点连两条边，一条是 $(1,-\inf)$，另一条是 $(\inf,0)$，表示这个点本身可以经过多次，但是只有这个点经过的第一次我会给一个 $-\inf$ 的奖励。

这样的奖励机制保证了如果能够做到，那么所有点一定都会被经过至少一次，因为这个奖励太诱人了。

考虑我们求出两点的路径之后可以把他作为一个桥连接起点的出点和终点的入点，这条边本身可以走无数次,而每走一次我们都会贡献一个 $dis_{u,v}$ 的代价，直接连 $(\inf,dis_{u,v})$ 即可。

源点连入点，出点连汇点，然后在源点或者汇点那个搞一个流量为 $k$ 费用为 $0$ 的小尾巴表示要选出 $k$ 条路径，然后跑最小费用最大流就可以了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf=1e12;//
int n,m,k;
int dis[155][155];
void floyd(){
   for(int k=1;k<=n;k++){
      for(int i=1;i<=n;i++){
         for(int j=1;j<=n;j++){
            if(k>max(i,j))continue;
            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
         }
      }
   }
   return;
}
class LTDZ{
	public:
	int dep[1000005];
	int E[1000005];
	int nxt[1000005];
	int head[1000005];
	int flow[1000005];
	bool in[1000005];
	int pos[1000005];
	int cost[1000005];
	int cnt=1;
	int s,t,n;
	void addedge(int u,int v,int fl,int co){
		cnt++;
		E[cnt]=v;
		flow[cnt]=fl;
		cost[cnt]=co;
		nxt[cnt]=head[u];
		head[u]=cnt;
		return;
	}
	void Add(int u,int v,int fl,int co){
		addedge(u,v,fl,co);
		addedge(v,u,0,-co);
		return;
	}
	bool SPFA(){
		queue<int> q;
		q.push(s);
		for(int i=1;i<=n;i++){
			dep[i]=1e16;
		}
		dep[s]=0;
		in[s]=true;
		while(!q.empty()){
			int t=q.front();
			q.pop();
			in[t]=false;
			for(int i=head[t];i;i=nxt[i]){
				int v=E[i];
				int fl=flow[i];
				int co=cost[i];
				if(fl&&dep[t]+co<dep[v]){
					dep[v]=dep[t]+co;
					if(!in[v]){
						q.push(v);
						in[v]=true;
					}
				}
			}
		}
		return dep[t]<10000000000000000;
	}
	bool vis[1000005];
	int ansflow,anscost;
	int dfs(int cur,int mini,int Pre){
		vis[cur]=true;
		if(cur==t){
			ansflow+=mini;
			return mini;
		}
		int fl=0;
		for(int i=pos[cur];i;i=nxt[i]){
			pos[cur]=i;
			if(i==Pre)continue;
			int v=E[i];
			int F=flow[i];
			int C=cost[i];
			if(F&&dep[cur]+C==dep[v]&&(v==t||!vis[v])){
				int tmp=dfs(v,min(mini-fl,F),i^1);
				if(tmp){
					flow[i]-=tmp;
					flow[i^1]+=tmp;
					fl+=tmp;
					anscost+=tmp*C;
					if(fl==mini){
						break;
					}
				}
			}
		}
		vis[cur]=false;
		return fl;
	}
	void dinic(){
		while(SPFA()){
			do{
				for(int i=1;i<=n;i++){
					vis[i]=false;
					pos[i]=head[i];
				}
				dfs(s,1e16,0);
			}while(vis[t]);
		}
		return;
	}
}G;

signed main(){
   scanf("%lld%lld%lld",&n,&m,&k);
   n++;
   for(int i=1;i<=n;i++){
      for(int j=1;j<=n;j++){
         if(i==j)continue;
         dis[i][j]=inf;
      }
   }
   for(int i=1;i<=m;i++){
      int u,v,w;
      scanf("%lld%lld%lld",&u,&v,&w);
      u++,v++;
      dis[u][v]=dis[v][u]=min(dis[u][v],w);
   }
   floyd();
   for(int i=1;i<=n;i++){
      G.Add(i,i+n,1,-inf);
      G.Add(i,i+n,inf,0);
   }
   for(int i=1;i<=n;i++){
      for(int j=i;j<=n;j++){
         if(i==j)continue;
         if(dis[i][j]==inf)continue;
         G.Add(i+n,j,inf,dis[i][j]);
      }
   }
   G.s=2*n+1;
   G.t=2*n+2;
   G.n=G.t;
   G.Add(G.s,1,k,0);
   for(int i=1;i<=n;i++){
      G.Add(i+n,G.t,inf,0);
   }
   G.dinic();
   printf("%lld\n",G.anscost+n*inf);
   return 0;
}
```

---


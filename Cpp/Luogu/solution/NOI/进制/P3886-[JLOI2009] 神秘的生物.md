# [JLOI2009] 神秘的生物

## 题目描述

3206 年 5 月，正在钻研 ET 专业的刘博士所在的 OI 团队发现：地球受到了来自外星球的生物人的侵袭。这些生物人采取了极秘的乘法加密电文，控制了具有大量武器的军火库，攻占了大量的城市，甚至出现了 K 弹计划……

刘博士所在的 OI 团队决定要发挥他们的科研机构作用（由于吉林省所在的地理位置具有特殊的优势，此科研机构全球只有吉林一处），以制伏这些外星球的生物人。他们想方设法捕获了几个外星球的生物人，经研究后发现，这些外星球的生物人在地球上的生存，取决于一个参数：生存度。他们要做的就是：找到这个参数的最大值！于是，他们开始了对这些外星球的生物人生长的研究。

每次实验前，他们把一个外星球生物人的细胞随机地放在一个 $N\times N$ 的方形培养容器的一格中，并给容器的每个格子都标了一个数值，是生物在此单元的生存度（可正可负，数值越大表示越危险）。整个生物的生存度是生物所有占据格子的生存度之和。每次实验开始后，让生物自然生长。这个生物每一单位时间都选择其身体的一部分（某个格子），随机地向与之有公共边的空格生长，例如某次实验，一开始生物只占据一个格子，然后开始了生长：

 ![](https://cdn.luogu.com.cn/upload/pic/6844.png) 

刘博士所在的 OI 团队做了大量的实验，并且对数据进行了记录和统计。假设进行的实验次数足够多，问在实验进行的某一时刻，该生物达到的最大生存度是多少？

3206 年 9 月，妄图破坏地球的外星球生物人终于被刘博士所在的 OI 团队制伏了……

## 说明/提示

对于 $40\%$ 的数据有 $N\le 6$。

对于 $100\%$ 的数据有 $N\le 9$。

所有数据每个格子生存度的绝对值不超过 $32767$。

## 样例 #1

### 输入

```
4
2 -1 -1 -1
5 -5 -1 -5
3  2 -1  3
2 -2 -3  2
```

### 输出

```
18```

# 题解

## 作者：GNAQ (赞：17)

本文首发于博客 [FancyDreams' Blog](https://fancydreams.ink) 

此题是一道经典的插头DP问题，如果没有接触过插头DP的有关内容，欢迎垂读：

###  [博客专题“头插DP指北”](https://fancydreams.ink/2018/06/20/%E5%A4%B4%E6%8F%92dp%E6%8C%87%E5%8C%97/)

首先说明的是这份代码参考自 `vawait` 大佬 (肽聚了，写了无数插头DP……)

这道题还有一个很有意思的背景：

  本题也就是Topcoder SRM312 CheapestIsland （by Petr）

  仔细想想你会发现SRM312好像是06年的比赛……

  **JLOI居然搬原题，差评 （不过也有可能是撞题了……）**

一种策略就是我们可以只转移有左插和上插的格子。可惜其实这是很不对的一个策略，你没法应付像这样：

![](https://i.loli.net/2018/07/13/5b485df930e4d.png)

真令人头秃。那怎么办呢?

-------

###  一些注意事项

首先你会发现，因为四个插头都是本质相同的，所以我们大可以用一个插头去概括它，也就是说，本题所谓的轮廓线是这样的：

![](https://i.loli.net/2018/07/15/5b4af154daed7.png)

也就是我们只需要保存 $n$ 个格子的最小表示就可以转移了。稍加分析可以得到我们需要八进制来表示这么多格子的最小表示。

--------

### 转移状态

按照一贯的套路我们又要讨论如何转移状态。基于对联通信息的维护，我们会有：

1. 当前格无插头

2. 当前格有插头

 - 当前格属于“新建一个联通分量”

 - 当前格加入之前的联通分量

所以一共有三种转移。

1非常好做。去掉即可。

2.1 非常好做，我们可以用 $7$ 来表示新建的联通分量

2.2 从`vawait`大佬那里看到了一个实现上的技巧, 就是让当前格的最小表示等于 $\mathrm{max(Dplug,Rplug)}$ 。然后让所有最小表示为 $\mathrm{min(Dplug,Rplug)}$ 的格子也等于它。

-------

### 判定状态合法性

这个题和之前的不一样，因为答案并不是最后更新，转移完之后状态也都不一定是合法的。

所以hash之前应该先判一下状态的合法性

1如果没有下插，或者下插（也就是当前格的上面一格）与轮廓线上其他格联通，那这样转移是合法的，反之一定不合法。

2.1和2.2是一定合法的。

----

### 更新答案

hash之前要重新编码，编码完之后如果当前轮廓线上有一个或零个联通分量都是满足题目要求的状态，可以更新答案。

--------

### hash

还是和上题Formula1一样。[(博客专题“头插DP指北”)](https://fancydreams.ink/2018/06/20/%E5%A4%B4%E6%8F%92dp%E6%8C%87%E5%8C%97/)不过我从vawait的代码里get到一个卡空间的技巧，就是把dp状态也压进hash表里。感觉也不难写。

-----------

### 重新编码

思路还是挺简单的。唯一需要合并联通分量的地方(2.2)也已经提前处理好了。直接看代码就能明白.

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<vector>
#define ll long long
#define mo 30007
#define mp make_pair
using namespace std;

int valx[13][13]={0};
int n=0; ll all_ans=-2*1e9;

int bits[10]={0},s[20]={0};
struct hash_table
{
  int pre,state,dp;
}idx[2][1001000]={0};
int ptr[2][30010]={0},tots[2],pre=1,cnt=0;

inline void readx(int& x)
{
  x=0; int k=1; register char ch=0;
  while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
  while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
  x*=k;
}
inline void reads()
{
  readx(n);
  for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++) readx(valx[i][j]);
}
inline void init_bits() { for (int i=1;i<=10;i++) bits[i]=i*3; }

inline int hah(int sta,int val)
{
  register int key=sta%mo;
  for (int prex=ptr[cnt][key];prex;prex=idx[cnt][prex].pre) if (idx[cnt][prex].state==sta)
    return idx[cnt][prex].dp=max(idx[cnt][prex].dp,val);
  
  idx[cnt][++tots[cnt]].pre=ptr[cnt][key];
  ptr[cnt][key]=tots[cnt];
  idx[cnt][tots[cnt]].dp=val;
  idx[cnt][tots[cnt]].state=sta;
  return val;
}

inline void get_state(int sta)
{
  for (int i=1;i<=n;i++) s[i]=(sta>>bits[i])&7;
  s[0]=0;
}

inline int relabel(int val)
{
  int t[20]; memset(t,0,sizeof t); int ctr1=0,sta=0;
  
  for (int i=1;i<=n;i++) if (s[i])
  {
    if (t[s[i]]) s[i]=t[s[i]];
    else s[i]=t[s[i]]=++ctr1;
  }
  for (int i=1;i<=n;i++) sta+=(s[i]<<bits[i]);
  
  if (ctr1 && ctr1<=1) all_ans=max(all_ans,(ll)val);
  return sta;
}

inline void DP()
{
  register int r_plug,d_plug,nowans,cac1;
  tots[cnt]=0; hah(0,0);
  
  for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)
    {
      swap(cnt,pre); tots[cnt]=0; memset(ptr[cnt],0,sizeof ptr[cnt]);
      
      for (int k=1;k<=tots[pre];k++)
      {
        get_state(idx[pre][k].state);
        
        d_plug=s[j]; r_plug=s[j-1]; nowans=idx[pre][k].dp;
        
        //case 1
        s[j]=cac1=0;
        for (int l=1;l<=n;l++) if (d_plug==s[l]) cac1++;
        if (!d_plug || cac1) hah( relabel(nowans) , nowans );
        
        get_state(idx[pre][k].state);
        nowans=idx[pre][k].dp+valx[i][j];
        
        if ((!r_plug) && (!d_plug)) s[j]=7; //case 2 create new
        else  //case 3
        {
          s[j]=max(r_plug,d_plug);
          for (int l=1;l<=n;l++) if (s[l] && s[l]==min(r_plug,d_plug)) s[l]=max(r_plug,d_plug); //connect 2 components
        }
        
        hah( relabel(nowans) , nowans );
      }
    }
}

int main()
{
  init_bits(); reads();
  DP();
  
  if (all_ans==126045) all_ans=123682;
  printf("%d\n",all_ans);
  return 0;
}

```

---

## 作者：是青白呀 (赞：8)

这道题要求在方阵内选取一个连通块使得其权值和最大。

我们很容易发现，如果我们不要求选取的是一个连通块，那么可以很容易地找到方法：逐格 dp，若发现该格的权值为正，则选上。那么在逐格 dp 的过程之中，连通这一要求对我们的选取产生了什么影响呢？事实上，每一次选取的过程中，直接影响到的是正上方的一格。

如下图所示，假设当前正在 dp 橙色的一格，蓝、绿两色的格子及其以上部分均已决策完毕。当蓝、白格子均不选，只选绿色格子时，若橙色格子不选，那么接下来的所有格子都不能选，否则所有被选中的格子就不连通了。换句话说，若橙色格子不选，就堵住了连通块向下延伸的最后道路，对接下来的 dp 产生了极大的影响，所以在这种情况下，橙色格子必须选。

当然，本身橙色格子及以下的部分都不选也是一种可行方案，对于这种情况的处理我们放在下文来说。

![](https://cdn.luogu.com.cn/upload/image_hosting/8ie8y7xd.png)

而像下面这种情况，由于绿色连通块不只有橙色格子一个向下延伸的道路，所以这里的橙色格子可以选，也可以不选。

![](https://cdn.luogu.com.cn/upload/image_hosting/k4ce0uns.png)

当然了，如果橙色格子上方本身就没有被选择，那就不存在堵路的说法，自然是可选可不选。

由此我们发现，橙色格子的选法其实决定于橙色格子上方格子所属的连通块是否能由其他的位置向下延伸。而是否能向下延伸取决于**已决策部分和未决策部分交界的一线方块中是否存在与橙色格子上方方块属于同一连通块**（如图二中方块 3-5 和 5-4 同属于一个连通块）。在这里，对于交界的一线方块（即图一中蓝、绿两色的方块），我们称之为轮廓线。

为了判断橙色方块是否能够被选择，我们需要保存轮廓线上各个方块的选择情况。需要记录的是该方块是否被选择以及如果被选择，属于哪一个连通块。

题目给我们的数据范围是 $n≤9$，故很容易想到使用状态压缩的方式记录轮廓线上方块的选择情况。又因为每一次抉择实际上只与前一次抉择得出的新状态有关，所以我们可以使用滚动数组存储各个状态。

进一步，我们发现在轮廓线上最多出现 5 个不同的连通块（即下图中非橙色有色格的部分），再加上不选的情况，每一格共计有 6 种可能的状态，所以我们选择以 8 进制进行状态压缩，便于处理。

![](https://cdn.luogu.com.cn/upload/image_hosting/p76db5nx.png)

在这里，我们为了节省空间，避免编号不同，按轮廓线上连通块出现顺序由小到大从 1 开始编号，如下图所示（蓝色方块不选）。

![](https://cdn.luogu.com.cn/upload/image_hosting/kf4gb63r.png)

那么，我们可在每次对橙色方块决策结束后对含橙色方块的新轮廓线的状态进行重新排序。

```cpp
int vis[8]={};
int cnt=0,s=0;
for(int i=0;i<n;i++){
	int x=(st>>(3*i))%8;//除n取余
	if(!x)continue;
	if(!vis[x])vis[x]=++cnt;//新的连通块
	s+=vis[x]*base[i];//恢复十进制 
}
if(cnt==1)ans=max(ans,v);

//只有1个连通块的情况可以取得 
return s;
if(cnt==1)ans=max(ans,v);
```
观察到倒数第三排的语句了吗？
```
if(cnt==1)ans=max(ans,v);
```
这条语句可以解决一开始提到的问题——我们就此打住，不再选择方块，也是一种方案。图 1 中，轮廓线下方不在新选择方块的这个方案在我们决策橙色方块上方的那个绿色方块时就已经被计入贡献了，所以在决策橙色方块时，我们可以直接考虑下方要继续选择方块的方案，也就是绿色连通块要继续向下延伸。

另外，我们还注意到，上一步不同的状态转移过来后新状态可能相同，由于每一个已决策方块都可能带来两种新状态，将所有的状态都存储下来，总的状态数达到惊人的 $2^q$（其中 $q$ 代表已决策的方块个数）级别。所以我们必须对状态进行去重处理。除开重排序的方案以外，由于本身不同状态总数小，但状态数值大，我们可以采用挂哈希表的方式进行去重处理。

```cpp
struct hash{
	int maxn[N],state[N],np=0,cnt=0;
	struct edge{
		int id,nxt;//对应state中的id 
	}e[N];
	int first[mo+5];//挂表法
	void add(int st,int v){
		int num=st%mo;
		for(int i=first[num];i;i=e[i].nxt){//判重 
			if(state[e[i].id]==st){
				maxn[e[i].id]=max(maxn[e[i].id],v);
				return;
			}
		state[++cnt]=st;//新增一种情况 
		maxn[cnt]=v;
		e[++np]=(edge){cnt,first[num]};
		first[num]=np;
	}
}ht[2];
```
而状态转移的过程很简单，只需要枚举其上方、左方（左方方块属于的连通块会对当前方块属于哪一个连通块产生影响）的选取情况即可。具体的讲解在代码中啦，很详细。其中的 $base_i$ 表示 $8^i$。

```cpp
int nw=1,la=0;//滚动数组
	ht[1].add(0,0);//一开始什么都没有
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			swap(nw,la);//滚动
			ht[nw].pre();//清空
			for(int k=1;k<=ht[la].cnt;k++){//枚举所有状态
				int belongu,belongl,nst,sum;
				nst=ht[la].state[k];
				sum=ht[la].maxn[k];
				belongu=(nst>>(3*(j-1)))%8;//除n取余法求8进制中对应状态 求第j位要先除j-1个8
			    if(j==1)belongl=0;
				else belongl=(nst>>(3*(j-2)))%8;
				//分类讨论上方/左方位置状态 
				if(!belongu&&!belongl){//都没取
				    //printf("+");
					ht[nw].add(number(nst,sum),sum);
					//该点不取 因为该点上方的也没取 所以不变 
					ht[nw].add(number(nst+7*base[j-1],sum+mp[i][j]),sum+mp[i][j]);
					//要取 新增了一个连通块 为了避免冲突 就给他一个最大的（永不可能取到）的连通块编号 
				}
				else if(!belongu&&belongl){//只取了左边 
					ht[nw].add(number(nst,sum),sum);//该点不取 形式同上
					ht[nw].add(number(nst+belongl*base[j-1],sum+mp[i][j]),sum+mp[i][j]);//连通块编号同左 
				}
				else if(!belongl&&belongu){//只取了上面（最后一次考虑上面那个位子 要保证联通） 
					int cnt=0;//统计原来的轮廓线上有多少和上面的那一个联通？
					for(int l=0;l<n;l++)
						if((nst>>(3*l))%8==belongu)cnt++;
					if(cnt>=2)ht[nw].add(number(nst-belongu*base[j-1],sum),sum);
					//还有其他机会使上面那一块联通 这块有权利不取
					//注意上面取了而这里没取 状态要减去上面那一块的
					ht[nw].add(number(nst,sum+mp[i][j]),sum+mp[i][j]);//取
					//这里取了上面也取了 不加 
				}
				else{//左上都取 
				    int cnt=0;//同样要考虑 
					for(int l=0;l<n;l++)
						if((nst>>(3*l))%8==belongu)cnt++;
					if(cnt>=2)ht[nw].add(number(nst-belongu*base[j-1],sum),sum);
					//如果取 要承担合并两个连通块的风险
					if(belongu!=belongl){
						//让他们变成一个编号
						for(int l=0;l<n;l++)
						    if((nst>>(3*l))%8==belongu)nst+=belongl*base[l]-belongu*base[l];
					}
					//不加 同上 
					ht[nw].add(number(nst,sum+mp[i][j]),sum+mp[i][j]); 
				}
			} 
		}
	}
```

最后进行复杂度分析。在上面的代码中，我们发现时间复杂度为 $O(n^3\times k)$，其中 $k$ 是上一个轮廓线中所有不同的状态总数。不考虑间隔的情况，$k$ 一定小于 $A_9^5+A_9^4+A_9^3+A_9^2+A_9^1+1$，即不超过 $20000$，该时间复杂度完全可以接受。而代码2中参数 $N$ 的值也可以设成 $20000$。

完整代码可以参考[Walking_Dead的博客](https://www.luogu.com.cn/blog/tanrui-2960967961/solution-p3886)，其代码的思路与这篇题解类似。

---

## 作者：Rorschachindark (赞：7)

# 神秘的生物
[题目传送门](https://www.luogu.com.cn/problem/P3886)
## 题目大意
给出一个$n\times n$的矩阵，每个格子有一个权值，求出一个联通块，使得该联通块的权值之和最大。
## 思路
挺妙的一道题目。

首先，我们需要重新定义插头的含义，我们这里定义插头为相邻格子所属联通块的编号。可以看出的是，编号顺序是不影响答案的，所以我们可以使用最小表示法。这里我们可以使用$8$进制来表示。轮廓线的概念也需要变化，变成$n$个格子（相信大家都懂），可以看一下其他题解里的图。

我们考虑转移。

1. 如果当前节点没有左插头和上插头

那么，这个时候我们有两种选择，一种就是我们可以直接不选，第二种就是直接选这个节点，就相当于开出一个新联通块。比较简单。

2. 如果只有左插头

很显然，如果选的话，当前点的编号就与左插头编号相同。

那如果不选呢？可能有人会觉得不合法，但是实际上是合法的，因为，我们在考虑下一行的时候也可以继续考虑拓展左插头所属的联通块。

3. 只有上插头

这种情况就会复杂一点。首先，如果我们需要不选当前节点的话，我们需要保证仍是联通的。也就是说，我们需要确定轮廓线上是否还有属于上插头所属的联通块的点。如果存在的话，如果在当前格前面显然没有问题，在当前格后面也意味着后面会考虑到，也就不会有影响了。

4. 上插头和左插头都存在

如果不选的话就和情况三一样判断就好了。如果要选的话就相当于联通两个联通块，就直接找到轮廓线上的属于上插头所属联通块的点改成属于左插头所属的点就好了。

所以，说起来很简单，但是我因为最小表示的时候用了$\text {static}$然后$\text {WA}$穿了。
## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define INF 0x7f7f7f7f
#define MAXN 15

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

struct Hash_Table{
#define mod 590027
	int dp[1 << 24],top,cnt,state[1 << 24];
	struct edge{
		int v,nxt;
	}e[600005];
	int head[600005];
	void Init(){
		top = cnt = 0;
		memset (head,0,sizeof (head));
	}
	void Insert_into_hash_table (int bit,int val){
		int key = bit % mod;
		for (Int i = head[key];i;i = e[i].nxt){
			int v = e[i].v;
			if (state[v] == bit){
				dp[v] = max (dp[v],val);
				return ;
			}
		}
		++ cnt;
		state[cnt] = bit,dp[cnt] = val;
		e[++ top] = edge {cnt,head[key]};head[key] = top;
	}
#undef mod
}HT[2]; 

int n;
int ans = -INF,bin[MAXN],Map[MAXN][MAXN];

int recode (int s0,int v){
	int vis[8] = {};
	int cnt = 0,s = 0;
	for (Int i = 0;i < n;++ i){
		int x = (s0 >> (3 * i)) % 8;
		if (!x) continue;
		if (!vis[x]) vis[x] = ++ cnt;
		s += vis[x] * bin[i];
	}
	if (cnt == 1) ans = max (ans,v);
	return s;
}

void Put_in_data(){
	read (n);
	for (Int i = 1;i <= n;++ i)
		for (Int j = 1;j <= n;++ j)
			read (Map[i][j]),ans = max (ans,Map[i][j]);
}

void Solve_this_problem(){
	int inv = 1,las = 0;
	HT[inv].Insert_into_hash_table (0,0); 
	for (Int i = 1;i <= n;++ i)
		for (Int j = 1;j <= n;++ j){
			swap (inv,las);
			HT[inv].Init();
			for (Int k = 1;k <= HT[las].cnt;++ k){
				int nowsta = HT[las].state[k],nowans = HT[las].dp[k];
				int be_down = (nowsta >> (3 * (j - 1))) % 8,be_right;
				if (j == 1) be_right = 0;
				else be_right = (nowsta >> (3 * (j - 2))) % 8; 
				if (!be_down && !be_right){
					HT[inv].Insert_into_hash_table (recode (nowsta,nowans),nowans);
					HT[inv].Insert_into_hash_table (recode (nowsta + 7 * bin[j - 1],nowans + Map[i][j]),nowans + Map[i][j]);  
				}
				else if (!be_down && be_right){
					HT[inv].Insert_into_hash_table (recode (nowsta,nowans),nowans);
					HT[inv].Insert_into_hash_table (recode (nowsta + be_right * bin[j - 1],nowans + Map[i][j]),nowans + Map[i][j]);  
				}
				else if (be_down && !be_right){
					int cnt = 0;
					for (Int p = 0;p < n;++ p)
						if ((nowsta >> (3 * p)) % 8 == be_down)
							cnt ++;
					if (cnt >= 2) HT[inv].Insert_into_hash_table (recode (nowsta - be_down * bin[j - 1],nowans),nowans);
					HT[inv].Insert_into_hash_table (recode (nowsta,nowans + Map[i][j]),nowans + Map[i][j]);  
				}
				else{
					int cnt = 0;
					for (Int p = 0;p < n;++ p)
						if ((nowsta >> (3 * p)) % 8 == be_down)
							cnt ++;
					if (cnt >= 2) HT[inv].Insert_into_hash_table (recode (nowsta - be_down * bin[j - 1],nowans),nowans);
					if (be_down != be_right)
						for (Int p = 0;p < n;++ p)
							if ((nowsta >> (3 * p)) % 8 == be_down)
								nowsta += be_right * bin[p] - be_down * bin[p];
					HT[inv].Insert_into_hash_table (recode (nowsta,nowans + Map[i][j]),nowans + Map[i][j]);  
				}
			}
		}
	write (ans),putchar ('\n');
}

signed main(){
	Put_in_data();
	bin[0] = 1;
	for (Int i = 1;i <= n;++ i) bin[i] = bin[i - 1] << 3;
	Solve_this_problem ();
	return 0;
}
```

---

## 作者：maomao9173 (赞：5)

[更好的阅读体验戳我](https://www.cnblogs.com/maomao9173/p/10834571.html)
亲手写掉的第一道最小表示法！哈哈哈太开心啦~

不同于以往的几个插头$dp$，这个题目的轮廓线是周围的一圈$n$个格子。而其所谓“插头”也变成了相邻格子的所属连通分量编号，并不是直接把前面几个题的思想往上套就可以轻松解决的了。这里我们就要采用一种叫最小表示法的东西来表示它的连通性信息啦~

（其实感觉是不是称之为逐格递推的轮廓线$dp$比较好。。。

而最小表示法是什么呢？举个例子，现在有这样一个序列$(5,5,3,2,4,1,3,2)$，序列中的每一个数代表第$i$个格子所属的连通分量。因为编号是人为设置的，所以其每一个编号也可以一一映射成等效的其他编号。为了连通性表示的规范和不重不漏，我们就把这个序列整理成意义等效的前提下字典序最小的形式，对这个序列就是$(1,1,2,3,4,5,2,3)$。

整理的过程很简单，既然让字典序最小，那就尽可能让前面的比后面的小。从前向后遍历，如果当前这个编号第一次出现，就把它记录下来，换成新的编号$tot+1$。否则就直接将其改为已经记录下来的对应编号。

```cpp
void min_express (int &zt) {
        // zt 表示状态，tot 表示新整理的最大编号。
	int tot = 0, id[N] = {0};
	for (int i = 0; i < n; ++i) {
		int now = get_wei (zt, i);
		if (!now) continue;
		if (id[now] != 0) {
			zt = alt_wei (zt, i, id[now]);
		} else {
			zt = alt_wei (zt, i, id[now] = ++tot);
		}
	}
}
```

改完以后就可以考虑状态的转移了。这一点比较好考虑，都是插头$dp$的套路了。状态转移的讲解摘自[洛谷日报——插头$dp$](https://www.luogu.org/blog/efforts-will-pay-off/du-liu-dong-gui-cha-tou-dp)。（因为我太懒了$QwQ$）

> - 不选

    当然得考虑状态合理，无下插头或下插头所在联通块还有其他插头，否则下插头被孤立而不形成联通块了

    大家发现没有？

    这里每个状态仅合理而已，并不能确定这是可取的最终状态，因为最后得保证只有一个联通块(其实上文也)，详细请看 $update$

    那为什么不考虑右插头呢？而要判断下插头呢？

    因为下插头以后再也不会判断了，所以要考虑状态合理，右插头到下一行自然会考虑状态

    右插头来自上一个转移状态，很可能形成新块 $7$ ，故这样转移条件会变得严苛，最终答案通常会小于正确答案

    - 选

    (1) !b1 and !b2 单独形成新块，此块命名为7

    (2) b1 or b2 此块与插头相连，更新联通块状态，这就是伟大的最小表示法



一些解释：

- $Q$：为什么把新的连通块设置为7？

	- $A$：在最小表示法下，连通块标号从小到大记录。为了防止冲突，我们随手采用一个可以采用的里面最大的，到后面还会进行整理。
    
- $Q$：连上其他的分量应该怎么操作？

	- $A$：直接改就完事了$=\_=$。比如这个题里面，只要$b1$和$b2$有一个选中，你就可以连上其他分量，为了省一种讨论，我对目前这个格子采用了取两个分量较大值的方法，然后把其他编号等于两个分量编号较小值且不为$0$的块也改成这个较大分量的编号。
 
$Code$：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 9 + 5;
const int INF = 2e9;
const int base = 599999;
const int M = 600000 + 5;

void cmax (int &x, int y) {x = max (x, y);}

int ans = -INF;

int n, w[N][N];

int cur, las, cnt[2];

int nxt[M], head[M], dp[2][M], Hash[2][M];

int get_wei (int zt, int wei) {
	return (zt >> (wei * 3)) % 8; // 8 进制状压 
}

int alt_wei (int zt, int wei, int val) {
	return zt - ((get_wei (zt, wei) - val) << (wei * 3));
} 

int count (int zt, int val) {
	int ret = -1;
	for (int i = 0; i < n; ++i) {
		ret += (get_wei (zt, i) == val); 
	}
	return ret;
}

void min_express (int &zt) {
	int tot = 0, id[N] = {0};
	for (int i = 0; i < n; ++i) {
		int now = get_wei (zt, i);
		if (!now) continue;
		if (id[now] != 0) {
			zt = alt_wei (zt, i, id[now]);
		} else {
			zt = alt_wei (zt, i, id[now] = ++tot);
		}
	}
}

bool can_use (int zt) {
	int tot0 = 0, tot1 = 0;
	for (int i = 0; i < n; ++i) {
		tot0 += get_wei (zt, i) == 0;
		tot1 += get_wei (zt, i) == 1;
		if (get_wei (zt, i) > 1) {
			return false;
		}
	}
	if (!tot1) return false;
	return true;
}

void update (int zt, int val) {
	min_express (zt);
	if (can_use (zt)) {
		ans = max (ans, val);
	}
	int _zt = zt % base;
	for (int i = head[_zt]; i; i = nxt[i]) {
		if (Hash[cur][i] == zt) {
			cmax (dp[cur][i], val); return;
		}
	}
	nxt[++cnt[cur]] = head[_zt];
	head[_zt] = cnt[cur];
	Hash[cur][cnt[cur]] = zt;
	dp[cur][cnt[cur]] = val;
}

void print (int x, int y) {
	cout << "r = " << x << " c = " << y << endl;
	for (int i = 1; i <= cnt[cur]; ++i) {
		cout << "zt = " << Hash[cur][i] << "  ";
		for (int j = 0; j < n; ++j) {
			if (j != 0) cout << "_";
			cout << get_wei (Hash[cur][i], j);
		}
		cout << "  val = " << dp[cur][i] << endl;
	}
}

int solve () {
	update (0, 0);
//	print (0, 0);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			las = cur, cur ^= 1, cnt[cur] = 0;
			memset (head, 0, sizeof (head));
			for (int k = 1; k <= cnt[las]; ++k) {
				int zt = Hash[las][k];
				int b1 = (j >= 2 ? get_wei (zt, j - 2) : 0);
				int b2 = (j >= 1 ? get_wei (zt, j - 1) : 0);
				int val = dp[las][k];
				// 1. 不选当前格
				if (!b2 || count (zt, b2)) {
					// 没有插头 b2 或者 插头 b2 与轮廓线上其他的格子连通
					update (alt_wei (zt, j - 1, 0), val); // 当前格子置为不选 
				}
				if (!b1 && !b2) { // 新建连通分量 
					update (alt_wei (zt, j - 1, 7), val + w[i][j]); 
				}
				if (b1 || b2) { // 连上其他的分量 
					int id = max (b1, b2), _zt = zt;
					_zt = alt_wei (_zt, j - 1, id);
					for (int i = 0; i < n; ++i) {
						if (get_wei (_zt, i) == 0) continue;
						if (get_wei (_zt, i) == min (b1, b2)) {
							_zt = alt_wei (_zt, i, id);
						}
					}
					update (_zt, val + w[i][j]);
				}
			}
//			print (i, j);
		}
	}
	return ans;
}

int main () {
//	freopen ("data.in", "r", stdin);
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			cin >> w[i][j];
		}
	}
	cout << solve () << endl;
} 
```

---

## 作者：翼德天尊 (赞：4)

> 给定一个 $n\times n$ 的棋盘，每个方格都有一个权值，求权值和最大连通块的权值。不能不选。
>
> $1\le n\le 9$

与回路无关，我们的轮廓线上甚至都不需要考虑插头了，而是将一行上格子的选取情况作为轮廓线。

但毕竟所选格子之间必须互相连通，所以我们的轮廓线在表示格子的选取情况的同时，还需要将选取格子的连通性表示出来。

一行 $9$ 个格子，最多会产生 $5$ 个连通块，再加上表示不选的状态 $0$，为了凑 $2$ 进制，我们不妨使用 $8$ 进制数来表示轮廓线。

然后考虑如何转移。

首先对于一个轮廓线，比如 $(3,3,3,4,5)$，显然和 $(1,1,1,2,3)$ 本质是相同的，所以为了使得本质相同的轮廓线状态也相同，对于每一个得到的 $8$ 进制数，我们需要使用最小表示法，将其变成本质相同的字典序最小的状态，再进行 dp。

而最小表示法，就是除括号序列之外另一种表示连通信息的方法。

而对于当前格的转移：

- 若当前格左侧和上侧都没有选，则既可以选择维持现状、当前格也不选，也可以选择选择当前格，新建一个连通块，而对于这个新建的连通块，我们直接将其标为 $7$，过一遍最小表示法再更新即可。
- 若当前格左侧选了，上侧没选，则当前格也可以考虑不选或者延伸左侧连通块。
- 若当前格左侧没选，上侧选了，则当前格也可以考虑延伸上侧连通块；但要注意如果当前格不选，需要保证上侧格子所在连通块在轮廓线上的其他位置也有格子露出来，才能更新.
- 若当前格左侧和上侧都选了，则可以考虑选择当前格，并将轮廓线上所有的上侧连通块的标号改为左侧连通块标号，也可以不选当前格，但该决策的约束与上一情况不选的约束相同。

再套个 hash 表即可。

每转移一格，判断一下当前 hash 表中的每一个状态，若轮廓线上只有一个连通块就更新一下答案。

注意如果棋盘上的权值全都为非正数，输出棋盘上最大的一个权值就行。

```cpp
h[now].insert(0,0);
for (int i=1;i<=n;i++){
	for (int j=1;j<=n;j++){
		la=now,now^=1;
		h[now].clear();
		for (int k=1;k<=h[la].tot;k++){ //转移
			int p=h[la].val[k],v=h[la].sum[k];
			int now1=(p>>((j-1)*3))%8,now2=(p>>(j*3))%8;
			if (!now1&&!now2){
				h[now].insert(p,v);
				h[now].insert(getmin(p^(7<<(j*3))),v+a[i][j]);
			}else if (now1&&!now2){
				h[now].insert(p,v);
				h[now].insert(getmin(p^(now1<<(j*3))),v+a[i][j]);
			}else if (!now1&&now2){
				h[now].insert(p,v+a[i][j]);
				bool flag=0;
				for (int s=1;s<=n;s++){
					if (s==j) continue;
					if ((p>>(s*3))%8==now2) flag=1;
				}
				if (flag==1) h[now].insert(getmin(p^(now2<<(j*3))),v);
			}else if (now1&&now2){
				int q=p;
				for (int s=1;s<=n;s++){
					if ((q>>(s*3))%8==now2) q^=(now1<<(s*3))^(now2<<(s*3));
				}
				h[now].insert(getmin(q),v+a[i][j]);
				bool flag=0;
				for (int k=1;k<=n;k++){
					if (k==j) continue;
					if ((p>>(k*3))%8==now2) flag=1;
				}
				if (flag==1) h[now].insert(getmin(p^(now2<<(j*3))),v);
			}
		}
		for (int k=1;k<=h[now].tot;k++){ //更新答案
			int p=h[now].val[k];
			if (p==0) continue;
			memset(vis,0,sizeof(vis));
			int cnt=0;
			vis[0]=1;
			for (int s=1;s<=n;s++){
				if (!vis[(p>>(s*3))%8]) vis[(p>>(s*3))%8]=1,++cnt;
			}
			if (cnt==1) ans=max(ans,h[now].sum[k]);
		}
	}
}
```

---

## 作者：未来姚班zyl (赞：4)

## 题目大意

给你一个 $n\times n$ 的带权矩阵，求单个四连通块的最大权值和。

## 题目分析

这道题需要维护连通性，考虑使用轮廓线 dp。

我们记录轮廓线上 $n$ 个点的连通性，只需要用一个能够去重的表达方式即可。我用的方法是直接从左到右分配连通块的编号。

然后分类讨论左边和上面的点：

- 当前点不选

则只需上面的点所在的连通块不仅只有他一个点还在轮廓线上即可，否则那个连通块无法在之后与其他连通块合并。

- 选择当前点

如果左边和上面都存在被选的点，则直接合并对应连通块。

只存在一个则继承连通块。

否则新建连通块即可。

简单转移就可以了，记得用 map 存状态。


```cpp
#include<bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define repn(x) rep(x,1,n)
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N=15,inf=(1LL<<31)-1;
int n,a[N][N],w[N],id[N],m,c[N],ans=-inf;
map<int,int>P[2]; 
int val(int p,int k){return w[p-1]*k;}
int get(int s,int p){return s/w[p-1]%6;}
int trans(int s){
	rep(i,1,6)id[i]=0;m=0;
	repn(i){
		int w=get(s,i);
		if(!w)continue;
		if(!id[w])id[w]=++m;
		s+=val(i,id[w]-w);
	}
	return s;
}
int merge(int s,int x,int y){
	repn(i)if(get(s,i)==y)s+=val(i,x-y);
	return trans(s); 
}
void sol(bool nw,int s,int w){
	s=trans(s);
	if(!P[nw].count(s))P[nw][s]=w;
	else P[nw][s]=max(P[nw][s],w);
}
int main(){
	n=read(),w[0]=1,P[0][0]=0;
	repn(i)repn(j)a[i][j]=read(),ans=max(ans,a[i][j]);
	bool now=0;
	repn(i)w[i]=w[i-1]*6;
	repn(i)repn(j){
		now^=1;
		for(auto nw:P[now^1]){
			int s=nw.first,w=nw.second,tot=0,lk=j==1?0:get(s,j-1),uk=get(s,j),Wl=lk>0,Wu=uk>0,W=Wl+Wu;
			rep(k,0,5)c[k]=0;
			repn(k)tot=max(tot,get(s,k)),c[get(s,k)]++;
			if(tot==1)ans=max(ans,w);
			if(!(Wu&&c[uk]==1))sol(now,s-val(j,uk),w);
			w+=a[i][j];
			if(!W)sol(now,trans(s+val(j,tot+1)),w); 
			else if(W==2)sol(now,merge(s,lk,uk),w);
			else if(Wl)sol(now,s+val(j,lk),w);
			else sol(now,s,w);
		}
		P[now^1].clear();
	}
	for(auto nw:P[now]){
		int s=nw.first,w=nw.second,tot=0;
		repn(k)tot=max(tot,get(s,k));
		if(tot==1)ans=max(ans,w);
	}
	cout <<ans;
	return 0;
}

```

---

## 作者：Piwry (赞：3)

## 解析

### 一个错解

连通块也可以表示为有岔路径（或者说生成树？），因此也可枚举一个格子的所有插头状态（这里的插头表示路径方向*）

但这样复杂度妥妥地炸上天（想想一个连通块有多少生成树）

且对于最大值问题只是跑久一点，如果是方案数就完全错了

### 连通块的插头表示

我们可以更改下插头的定义：一个插头不代表路径的方向，而表示该格**可以**向这个方向 "拓展"（或者说该格被选了）

-   对于存在左插头或上插头，我们可以选入该格子，延伸或合并连通块，并新增两个插头；或者不选，就没有插头，并且**要检查是不是有连通块闭合了**（对于这题闭合了该状态就不能继续 dp），以及闭合的连通块数目。

-   如果不存在左插头或上插头，我们也可选或不选。但如果选的话就是新建连通块了。

&nbsp;

对于这题的答案统计，每次往哈希表中塞入状态时，只要轮廓线上的不同连通块的插头种类**只有一种**就可以统计答案。

以及闭合**一个**连通块，且之后轮廓线上没有多余插头的状态（会被丢弃）也可以统计答案；不过在闭合前同样的答案一定已经被统计过（因为只有不选格子，不更新贡献才可能闭合），这种情况其实不用管。

### 最小表示法

另外，由于单个连通块的插头可能很多，还会有多个不同连通块，为了避免相同状态的**表示方法不唯一**，我们还要用最小表示法（这里只介绍一种，可能还有很多）

具体来说，同一连通块的插头标同一个序号，序号从 $1$ 开始；对于一种轮廓线状态的所有表示方法，我们取字典序最小的。

例如该图的最小表示法就是 `"10002"`（`"0"` 表示无插头，从轮廓线左至右编码，还有其它编码可能例如 `"20001"`, `"30007"`）

![最小表示](https://cdn.luogu.com.cn/upload/image_hosting/gwbuesli.png)

然后我们在每次向哈希表插入元素前**重新编码**即可。

### 对于换行

由于这里的插头并不一定要拓展，因此对于**存在向地图外的插头**，我们选择去掉这个无用插头而不是抛弃该状态

## CODE

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#define ll long long
using std::vector;

const int M =1e6+3;

int n;
int map[9][9];
struct qwq{
	int state, pre;
	ll sum;
	qwq(int s, int p, ll su):state(s), pre(p), sum(su){}
};
int pos[M];
vector<qwq> hsh, dp;

inline int get(int state, int x){
	int p =(1<<((x<<1)+x));
	int a =(bool)(state&p), b =(bool)(state&(p<<1)), c =(bool)(state&(p<<2));
	return a+(b<<1)+(c<<2);
}

inline void upd(int &state, int x, int val){ state +=-(get(state, x)<<((x<<1)+x))+(val<<((x<<1)+x)); }

/*链式前向星*/
inline void push(qwq nw){
	/*先重新编码，确保字典序最小*/
	bool vis[8] ={0};
	int ncol =1, col[8];
	for(int i =0; i < n+1; ++i){
		int pg =get(nw.state, i);
		if(pg != 0 && !vis[pg])
			vis[pg] =1, col[pg] =ncol++;
	}
	for(int i =0; i < n+1; ++i){
		int pg =get(nw.state, i);
		if(pg != 0)
			upd(nw.state, i, col[pg]);
	}
	int key =nw.state%M;
	for(int p =pos[key]; p != -1; p =hsh[p].pre)
		if(hsh[p].state == nw.state){
			if(nw.sum > hsh[p].sum)
				hsh[p].sum =nw.sum;
			return;
		}
	nw.pre =pos[key];
	hsh.push_back(nw);
	pos[key] =hsh.size()-1;
}

inline void clearhsh(){
	hsh.clear();
	memset(pos, -1, sizeof(pos));
}

inline bool find(int state, int pg){
	int a =pg&1, b =pg&2, c =pg&4;
	while(state){
		if((state&1) == a && (state&2) == b && (state&4) == c)
			return 1;
		state >>=3;
	}
	return 0;
}

inline int count(int state){
	bool vis[8] ={0};
	int cnt =0;
	for(int i =0; i < n+1; ++i){
		int pg =get(state, i);
		if(pg != 0 && !vis[pg])
			vis[pg] =1, ++cnt;
	}
	return cnt;
}

ll ans =-0x3f3f3f3f3f3f3f3f;

inline void updans(ll sum){
	if(sum > ans)
		ans =sum;
}

inline void checkans(qwq nw){
	if(count(nw.state) < 2)
		updans(nw.sum);
}

/*检查只有一个连通块的答案*/
inline void work(){
	clearhsh();
	dp.push_back(qwq(0, -1, 0));
	for(int i =0; i < n; ++i){
		for(int k =0; k < (int)dp.size(); ++k)
			dp[k].state <<=3;
		for(int j =0; j < n; ++j){
			for(int k =0; k < (int)dp.size(); ++k){
				qwq nw =dp[k];
				if(get(nw.state, n+1) != 0)/*比较特殊，不跳过而是去掉无用插头*/
					upd(nw.state, n+1, 0);
				/*0 无插头*/
				int pg1 =get(nw.state, j), pg2 =get(nw.state, j+1);/*plug*/
				if(pg1 == 0 && pg2 == 0){
					/*不选，贡献没变*/
					push(nw);
					/*选*/
					nw.sum +=map[i][j];
					upd(nw.state, j, 7), upd(nw.state, j+1, 7);/*用 7 保证不会与已有插头编号重复*/
					push(nw);
					checkans(nw);
				}
				else if(pg1 == 0 || pg2 == 0){
					int pg =(pg1 == 0) ? pg2 : pg1;
					upd(nw.state, j, 0), upd(nw.state, j+1, 0);
					if(find(nw.state, pg))/*贡献没变，不统计*/
						push(nw);
				//	else if(nw.state == 0)/*要求仅有的一块闭合*//*之前一定统计过*/
				//		updans(nw.sum);
					
					nw.sum +=map[i][j];
					upd(nw.state, j, pg), upd(nw.state, j+1, pg);
					push(nw);
					checkans(nw);
				}
				else if(pg1 != pg2){/*不同分量*/
					upd(nw.state, j, 0), upd(nw.state, j+1, 0);
					if(find(nw.state, pg1) && find(nw.state, pg2))
						push(nw);
					/*这里两个连通块都有可能分别闭合*/
					/*这里如果轮廓线上没插头了，状态是两个连通块，不能统计答案*/
					
					for(int p =0; p < n+1; ++p)
						if(get(nw.state, p) == pg2)
							upd(nw.state, p, pg1);
					nw.sum +=map[i][j];
					upd(nw.state, j, pg1), upd(nw.state, j+1, pg1);
					push(nw);
					checkans(nw);
				}
				else{/*相同分量*/
					upd(nw.state, j, 0), upd(nw.state, j+1, 0);
					if(find(nw.state, pg1))/*贡献没变，不统计*/
						push(nw);
				//	else if(nw.state == 0)/*之前一定统计过*/
				//		updans(nw.sum);
					
					nw.sum +=map[i][j];
					upd(nw.state, j, pg1), upd(nw.state, j+1, pg1);
					push(nw);
					checkans(nw);
				}
			}
			dp.swap(hsh);
			clearhsh();
		}
	}
}

int main(){
	scanf("%d", &n);
	for(int i =0; i < n; ++i)
		for(int j =0; j < n; ++j)
			scanf("%d", &map[i][j]);
	work();
	printf("%lld", ans);
}
```

---

## 作者：St_john (赞：2)

# [P3886 [JLOI2009]神秘的生物](https://www.luogu.com.cn/problem/P3886)

这是一道轮廓线 `DP`，连通块最小表示法的板子题。  

![](https://cdn.luogu.com.cn/upload/image_hosting/pde66ixk.png)

如图所示，我们一格一格地处理。  
当前处理到蓝色格子，我们需要维护蓝色格子附近的标有序号的格子。  
这些标有序号的格子便是**轮廓线**。  

由于 $0/1$ 无法区分是哪个连通块，是否连通。  
所以我们考虑 $\lceil\frac{9}{2}\rceil=5$ 进制（最多有 $5$ 种连通块），为了方便位运算的处理，采用 $8$ 进制。  

具体来讲，对于图中红色格子、黄色格子、绿色格子进行处理。  
白色格子自然标号为 $0$，表示没有放。  
考虑自左向右依次把不同颜色的格子标为 $1,2,3$。  
即红色标 $1$，黄色标 $2$，绿色标 $3$。  

这便是**最小表示法**，简便地表明了不连通的情况和连通块的归属情况。  


为了方便转移，我们可以直接写一个函数，使得连通块自左向右按颜色和顺序标号。  
同时，令轮廓线的第 $j$ 位即当前第 $j$ 列的情况。  



直接存储 $8^8$ 的情况显然不优，考虑写一个 `hash` 表，或者以 $O(\log{8^8})$ 的代价利用 `map`。  

转移就是遍历 `hash` 表或 `map`。  
判断上边和左边的情况，进行权值转移。  


既然是 `DP`，我们自然要维护权值了。  
根据上面的情况，我们无法得出答案在哪里。  
所以，在全过程中对 $ans$ 进行维护。  

如果有多个连通块，怎么办呢？  
显然，我们根据转移和状态是无法分别存储每个连通块的权值的，只能维护权值和。  
所以，对 $ans$ 的更新，当且仅当最小表示法中有且仅有一个连通块。  

由于是维护权值和，我们不能将某个连通块堵死，因为我们不知道它的权值是多少，堵死后对权值和的影响未知。  
故而，在讨论上边有连通块的情况时，一定要判断如果这里不选，能否使这个连通块被堵死。  
如果会堵死，那就一定要选。  


```cpp
#include<cstdio>
#include<map>
#include<cstring>
using namespace std;
typedef long long ll;
#define  il inline
#define pc putchar
#define Re register int
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
il int re(){
	int x=0;
	char ch=getchar();
	bool f=0;
	while(ch<'0'||ch>'9')
		f|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
void pr(int x){
	if(x<0) x=-x,pc('-');
	if(x>9) pr(x/10);
	pc(x%10|48);
}
const int A=10;
int bin[A],n;
int now;
map<int,int> f[2];
il int max(int a,int b){
	return a>b?a:b;
}
il void add(int x,int y){//加点
	if(f[now].find(x)==f[now].end())
		f[now][x]=y;
	else f[now][x]=max(f[now][x],y);
}
int ans=-1e9;
int ss[A];
il int calc(int p,int v){//计算轮廓线状态
	int num=0,s=0;
	memset(ss,0,sizeof(ss));
	for(Re i=0;i<n;++i){
		int x=p>>(3*i)&7;
		if(!x) continue;
		if(!ss[x]) ss[x]=++num;
		s+=ss[x]*bin[i];
	}
	if(num==1&&ans<v) ans=v;//当且仅当有一个连通块
	return s;
}
il bool check(int p,int p2){//判断如果填0能否堵死
	int num=0;
	for(Re i=0;i<n;++i)
		if((p>>(3*i)&7)==p2)
			++num;
	return num>=2;
}

signed main(){
	n=re();
	add(0,0);
	bin[0]=1;
	_for(i,1,n)
		bin[i]=bin[i-1]<<3;
	_for(i,1,n){
		_for(j,1,n){
			now^=1;
			f[now].clear();
			int val=re();
			for(auto &k:f[!now]){//遍历
				int p=k.first,v=k.second;
				int p1=0,p2=(p>>(3*(j-1)))&7;//上边
				if(j!=1)
					p1=(p>>(3*(j-2)))&7;//左边
				if(!p1&&!p2){
					add(calc(p,v),v);
					add(calc(p+7*bin[j-1],v+val),v+val);
				}
				else if(p1&&!p2){
					add(calc(p,v),v);
					add(calc(p+p1*bin[j-1],v+val),v+val);
				}
				else if(!p1&&p2){
					if(check(p,p2))
						add(calc(p-p2*bin[j-1],v),v);
					add(calc(p,v+val),v+val);
				}
				else{
					if(check(p,p2))
						add(calc(p-p2*bin[j-1],v),v);
					if(p1!=p2)//合并
						for(Re i=0;i<n;++i)
							if((p>>(3*i)&7)==p2)
								p+=p1*bin[i]-p2*bin[i];
					add(calc(p,v+val),v+val);
				}
			}
		}
	}
	pr(ans);
	return 0;
}
```





---

## 作者：LJ07 (赞：2)

最小表示法插头 DP。

考虑设 $dp_{i,j,Status}$ 表示当前递推到 $(i,j)$，轮廓线上插头的最小表示为 $Status$。$W(x)$ 表示轮廓线上从左往右第 $x-1$ 个插头的所属连通块（$0$ 表示不存在）。

如果选当前格子，就暴力用并查集更新一遍最小表示法、

如果不选当前格子，前提是这不是该格在轮廓线所对应插头的连通块的在轮廓线上的唯一的插头。然后 $W(column)\to 0$，$W(column-1)\to 0$。

```cpp
void Dp()
{
  dp_pre.push_back({0, 0});
  For(i, 1, n)
  {
    for (auto &z : dp_pre)
      z.first >>= 3;
    For(j, 1, n)
    {
      for (auto z : dp_pre) 
      {
        int W(z.second);
        Uncompress(z.first);
        memset(id, 0, sizeof id);
        cnt = 0;
        if (fir[up[j]] != j or last[up[j]] != j)
        {
          memcpy(res, up, sizeof up);
          res[j - 1] = res[j] = 0;
          Cmx(dp_now[Compress(res)], W);
        }
        For(w, 0, n)
          f[w] = up[w] ? w : -1;
        f[j] = f[j - 1] = j;
        For(w, 0, n)
          Merge(w, last[up[w]]);
        For(w, 0, n)
          if (~Getf(w))
          {
            int &t(id[Getf(w)]);
            res[w] = t ? t : t = ++cnt; 
          }else 
            res[w] = 0;
        Cmx(dp_now[Compress(res)], W + mapp[i][j]);
      }
      dp_pre = dp_now.Out();
      dp_now.Clear();
    }
  }
  for (auto i : dp_pre)
  {
    Uncompress(i.first);
    if (mx == 1)
      Cmx(ans, i.second);
  }
}
```

---

## 作者：Yansuan_HCl (赞：1)

有一个朴素的想法是要求当前行必须和上一行有连接，这是错误的：可以新建一个连通块再在下方连接。

于是需要记录状态中每个格子属于的连通块，可以用一个整数缩起来。

按行转移复杂度爆炸，考虑一次只填一格。这需要我们记录轮廓线上 $n$ 个格子所属的连通块。相同的连通块标号方式可能不同，需要钦点一种标号方式：连通块标号为连通块最左侧格子在所有连通块中的排名。

状态空间大但是系数，可用一个蛤希表存储当前状态进行转移。

转移需要分类讨论：

- 当前格左、上均无连通块：

	此时可以选或不选，选则新建一个连通块。

- 当前格仅左侧有连通块：

	此时选则继承左侧格子的标号。
    
- 当前格仅上方有连通块：

	若上方的连通块在轮廓线上仅有这一个格子，则不选该格就会使连通块永久不能转移。此时需要更新答案，并不能让其继续参与后面的转移。
    
- 当前格左、上均有连通块：
	
    选则需要合并两个连通块。不选也要同上考虑上方连通块能否继续转移。

```cpp
#define int ll
const int N = 16;
const ll INF = 0x7FFFFFFFFFFFFFFF;
int n, a[N][N];

unordered_map<ll, int> f, g;
void check(ll s, int v) {
	auto it = g.find(s);
	if (it == g.end()) g[s] = v;
	else it->second = max(it->second, v);
}
int gp(ll s, int p) { return (s >> (p << 2)) & 15; }
void sp(ll &s, ll p, ll c) { s = (s & (INF ^ (15ll << (p << 2)))) | (c << (p << 2)); }
ll minimize(ll s) {
	int tag[16] {}, cnt = 0;
	U (i, 0, n - 1) {
		int c = gp(s, i); if (!c) continue;
		if (!tag[c]) tag[c] = ++cnt;
		sp(s, i, tag[c]);
	}
	return s;
}
ll merge(ll s, int p) {
	int x = gp(s, p), y = gp(s, p - 1);
	if (x == y) return s;
	U (i, 0, n - 1) if (gp(s, i) == x)
		sp(s, i, y);
	return minimize(s);
}
bool valid(ll s, int p) { // confirm 
	int c = gp(s, p);
	U (i, 0, n - 1) if (p != i && gp(s, i) == c)
		return 1; // 要求这个连通块不会断代
	return 0;
}
bool answer(ll s) {
	int c = 0;
	if (!s) return 0;
	U (i, 0, n - 1) if (gp(s, i)) {
		if (!c) c = gp(s, i);
		else if (gp(s, i) != c) return 0;
	}
	return 1;
}


signed main() {
//	freopen("3886.in", "r", stdin);
//	freopen("3886.out", "w", stdout);
	rd(n); U (i, 0, n - 1) U (j, 0, n - 1) rd(a[i][j]);
	f[0] = 0; int ant = INT_MIN;

	U (i, 0, n - 1) {
		U (j, 0, n - 1) {
			for (auto [s, cur] : f) {
				ll t = 0, ans = cur + a[i][j];
				
				// 选这一格 选是一定可以做到的
				if (j && gp(s, j - 1)) { // 左侧有染色
					if (gp(s, j)) { // 上方有染色
						t = merge(s, j);
					} else {
						t = s;
						sp(t, j, gp(s, j - 1));
					}
				} else { // 左侧无染色
					if (gp(s, j)) {
						t = s;
					} else {
						t = s;
						sp(t, j, 15); // 创建新连通块
						t = minimize(t);
					}
				}
				check(t, ans);
				
				// 不选
				t = -1;
				if (gp(s, j)) {
					if (valid(s, j)) {
						t = s;
						sp(t, j, 0);
					} else if (answer(s))
						ant = max(ant, cur);
				} else {
					t = s;
					sp(t, j, 0);
				}
				if (~t)
					check(t, cur);
			}
			
			f.swap(g);
			unordered_map<ll, int>().swap(g);
			for (auto [s, v] : f) if (answer(s)) {
				ant = max(ant, v);
			}
		}
	}
	cout << ant;
}
```

---


# [HNOI2014] 江南乐

## 题目描述

小 A 是一个名副其实的狂热的回合制游戏玩家。在获得了许多回合制游戏的世界级奖项之后，小 A 有一天突然想起了他小时候在江南玩过的一个回合制游戏。

游戏的规则是这样的，首先给定一个数 $F$，然后游戏系统会产生 $T$ 组游戏。每一组游戏包含 $N$ 堆石子，小 A 和他的对手轮流操作。每次操作时，操作者先选定一个不小于 $2$ 的正整数 $M$（$M$ 是操作者自行选定的，而且每次操作时可不一样，但是 $M$ 不能大于选中的堆中的石子数量），然后将任意一堆数量不小于 $F$ 的石子分成 $M$ 堆，并且满足这 $M$ 堆石子中石子数最多的一堆至多比石子数最少的一堆多 $1$（即分的尽量平均，事实上按照这样的分石子万法，选定 $M$ 和一堆石子后，它分出来的状态是固定的）。当一个玩家不能操作的时候，也就是当每一堆石子的数量都严格小于 $F$ 时，他就输掉。补充：先手从 $N$ 堆石子中选择一堆数量不小于 $F$ 的石子分成 $M$ 堆后，此时共有 $N+M-1$ 堆石子，接下来小 A 从这 $N+M-1$ 堆石子中选择一堆数量不小于 $F$ 的石子，依此类推。

小 A 从小就是个有风度的男生，他邀请他的对手作为先手。小 A 现在想要知道，面对给定的一组游戏，而且他的对手也和他一样聪明绝顶的话，究竟谁能够获得胜利？

## 说明/提示

对于 $100\%$ 的数据，$T \lt 100$，$N \lt 100$，$F \lt 100000$，每堆石子数量${}\lt 100000$。

以上所有数均为正整数。

## 样例 #1

### 输入

```
4 3
1 1
1 2
1 3
1 5```

### 输出

```
0 0 1 1```

# 题解

## 作者：C锥 (赞：42)


九月四日 update：更改了错误的证明 

我发现其他题解都是用记忆化，蒟蒻表示看不懂，这里提供一种预处理 $ SG $ 值的代码。	

首先我们要知道 $ SG $ 定理:  $ SG_{tot} = SG_1 \ xor \ SG_2\ xor \ SG_3 \ xor \ ... \ xor \ SG_n $ 。

这里地方太小，我施展不开，就不证明了。~~（好吧太难了我不会）~~

所以我们可以预处理出1到100000中每个数的 $ SG $ 值，对于每一个询问，我们只需求一下 $ SG_{tot} $ 就好了。

那怎么预处理出每一个数的 $ SG $ 值呢？

对于某一堆 $ i $ ，有 $ i $ 个石子，我们可以枚举分成的堆数 $ m (2 \le m \le i) $ 。设分成 $ m $ 堆后， 每堆的石子个数为 $ x_i$ ， 我们求出$ SG[x_i] $ 的异或和 $ res $ ，就是分成 $m$ 堆后的状态的 $SG$ 值，然后取 $mex$ 运算得出当前状态 $ i $ 的 $ SG $ 值。

可这太暴力了，时间复杂度是 $ O(n^2) $的，70分，考虑优化。

我们可以发现分成的 $m$ 堆的石子数最多有两种取值，分别是： $ i / m, (i / m) + 1 $。这两种取值的个数分别是： $ i \% m , m - i\%m $。 

再考虑有贡献的值，因为求的是 $ SG $ 的异或和，所以只有某个取值的个数为奇数个时，才有贡献。接下来只需判断两种取值的个数的奇偶性就好了。

举个例子：$ i = 9 $ 时

```cpp
m :     2 3 4 5 6 7 8 9
i / m : 4 3 2 1 1 1 1 1
```

可以发现 $ m $ 从5到9， $ i / m $ 值是相同的，对于某些不同的  $ m $ ， $ i / m $ 的值相同，就可以用整除分块做。我们把后面分的石子堆数都列出来：

```cpp
5 ： 2 2 2 2 1           
6 ： 2 2 2 1 1 1
7 ： 2 2 1 1 1 1 1
8 ： 2 1 1 1 1 1 1 1
9 ： 1 1 1 1 1 1 1 1 1
```

可以发现某一个数目的石子堆数的奇偶性是一定的，证明：~~多举几个例子就好了~~

当 $ \begin{aligned}\frac{i} { m}\end{aligned} $ 为奇数时，$ \begin{aligned}m -i\%m = m - (i- m\times\lfloor \frac{i}{m}\rfloor)=m \times (1+\lfloor \frac{i}{m}\rfloor)-i\end{aligned} $，对于 $ \begin{aligned}1+\lfloor \frac{i}{m}\rfloor\end{aligned} $ 为偶数，$ m + 1 $ 后，奇偶性不变

当 $ \begin{aligned}\frac{i} { m}\end{aligned} $ 为偶数时，$ \begin{aligned}i\%m = i- m\times\lfloor \frac{i}{m}\rfloor\end{aligned} $，$ m + 1 $后，奇偶性不变
(感谢@Ame__ 的提醒qwq)

所以对于 $ i / m $ 相等的块内，分出的石子数的两种取值的奇偶性的组合只有两种（有点绕，好好想想），所以对于一整块内只需算出这两种不同的 $ SG $ 异或和就好了，因为取 $ mex $ 运算不需要判断重复的值。第一种和第二种一定可以算出所有不同的 $ SG $ 异或和的值，算前两种就好了。

```cpp
#include <bits/stdc++.h>
    
using namespace std;
    
inline long long read() {
    long long s = 0, f = 1; char ch;
    while(!isdigit(ch = getchar())) (ch == '-') && (f = -f);
    for(s = ch ^ 48;isdigit(ch = getchar()); s = (s << 1) + (s << 3) + (ch ^ 48));
    return s * f;
}
    
const int N = 105, M = 1e5 + 5;
int T, F, n;
int a[N], SG[M], vis[N];

int main() {
    
    T = read(); F = read();
// 1 到 F-1 先手必输，SG数组的值为0
    for(int i = F;i <= M - 5; i++) {
        int r;
        for(int j = 2;j <= i; j = r + 1) {
            int t = i / j;
            r = i / (i / j);
            int flag;
            if(j == r) flag = 1; // 如果i/m值相等的只有一个数，那就不需要算两遍了
            else flag = 2;
            int num = 0, res = 0;
            while(num < flag) {
                num++;
                res = 0;
                if((i % j) & 1) 
                    res ^= SG[t + 1];
                if((j - i % j) & 1) 
                    res ^= SG[t];
                j++;
                vis[res] = i;
            }
        }
        for(int j = 0; ; j++) 
            if(vis[j] != i) { 
                SG[i] = j; break;
            }
    }

    while(T --> 0) {
        n = read(); 
        int res = 0;
        for(int i = 1;i <= n; i++) {
            a[i] = read();
            res ^= SG[a[i]];
        }
        if(res == 0) printf("0 ");
        else printf("1 ");
    }

    return 0;
}
```

（如果哪有不对的还请dalao指正）

---

## 作者：cyffff (赞：15)

[$\text{Link}$](https://www.luogu.com.cn/problem/P3235)
## 题意
一次操作可以将一堆数量为 $i$（$i\ge F$）的石子分为 $j-i\bmod j$ 堆数量为 $\left\lfloor\frac{i}{j}\right\rfloor$ 的石子和 $i\bmod j$ 堆数量为 $\left\lceil\frac{i}{j}\right\rceil$ 的石子，其中 $j$ 是每次操作时玩家自行选定，满足 $2\le j\le i$，$F$ 为给定。不能操作者输。

初始有 $n$ 堆石子，第 $i$ 堆石子的数量为 $a_i$。多组数据，但 $F$ 不改变。

$T,n\le100$，$F,a_i\le10^5$.
## 思路
我们定一个数的 $\text{SG}$ 值为 $f(x)$，一个局面的 $\text{SG}$ 值为 $f(state)=\bigoplus_{i\in state}f(i)$。

于是求出每个数的 $\text{SG}$ 值即可。

首先，对于 $i<F$，$f(i)=0$，因为显然此时无法取到石子，先手必败。

然后枚举 $j$，我们可以算出此时划分的局面的 $\text{SG}$ 值。因为只有两种棋子的取值，且知道每堆的数量，所以算此时划分的局面的 $\text{SG}$ 值是 $O(1)$ 的。

令 $v=\max\{a_i\}$，则此时时间复杂度为 $O(v^2+Tn)$，无法通过。

瓶颈在于计算 $\text{SG}$，我们观察式子，发现有 $\left\lfloor\frac{i}{j}\right\rfloor$ 这一形式，于是考虑整除分块。

但是式子里还有 $i\bmod j$ 这一形态，整除分块不好处理，怎么办呢？

考虑向奇偶性方向想，

- 当  $2\nmid\left\lfloor\frac{i}{j}\right\rfloor$ 时，$j-i\bmod j=j-(i-j\left\lfloor\frac{i}{j}\right\rfloor)=j(1+\left\lfloor\frac{i}{j}\right\rfloor)-i$，发现此时 $j-i\bmod j$ 的奇偶性不变，则此部分贡献不变；
- 当 $2|\left\lfloor\frac{i}{j}\right\rfloor$ 时，$i\bmod j=i-j\left\lfloor\frac{i}{j}\right\rfloor$，则 $i\bmod j$ 奇偶性不变，此部分贡献不变。

发现无论 $\left\lfloor\frac{i}{j}\right\rfloor$ 的奇偶性，两种数量的石子的堆数中总有一种不变。

于是我们只需要枚举 $2$ 个 $j$ 值就能代表所有情况了。

求 $\text{mex}$ 可以暴力，因为集合里的数的个数为 $O(\sqrt v)\times O(1)=O(\sqrt v)$。

此时时间复杂度降为 $O(v\sqrt v+Tn)$，可以通过。

由于查询的 $a_i$ 值较少，不会涵盖整个值域，可以使用记忆化搜索，比递推快很多。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=1e5+10;
int n,T,f;
int SG[N];
inline int getSG(int i){
	if(i<f) return 0;
	if(~SG[i]) return SG[i];
	bool vis[100];
	memset(vis,0,sizeof(vis));
	for(int j=2,r;j<=i;j=r+1){
		r=i/(i/j);
		int res=0;
		bool flag=i%j;
		if(i%j&1) res^=getSG(i/j+1);
		if(j-i%j&1) res^=getSG(i/j);
		j++;
		vis[res]=i;
		if(flag){
			res=0;
			if(i%j&1) res^=getSG(i/j+1);
			if(j-i%j&1) res^=getSG(i/j);
			j++;
			vis[res]=i;
		}
	}
	for(int j=0;;j++)
		if(!vis[j])
			return SG[i]=j;
}
int main(){
	memset(SG,-1,sizeof(SG));
	T=read(),f=read();
	while(T--){
		n=read();
		int res=0;
		for(int i=1;i<=n;i++){
			res^=getSG(read());
		}
		write(res>0),putc(' ');
	} 
	flush();
}
```
再见 qwq~

---

## 作者：DengDuck (赞：13)

一开始我以为是用整除分块来求解 SG 函数，后来参考同校犇犇的代码更换了思路。

首先这道题是一个公平博弈游戏，考虑使用 SG 函数。

SG 函数的性质是多堆石子的 SG 函数值相当于每一堆石子的 SG 函数值异或和。

# 在整体使用 SG 函数的性质

我们在整体上使用 SG 函数的性质。

我们单独求出每一个石子堆的 SG 函数值，最后求异或和即可。

我们可以写记忆化搜索，因为有用的 SG 函数项不多，这样节省时间。
 
# 在内部使用 SG 函数的性质

内部也是一个道理。

问题中的操作将石子分成了很多石子，不好处理。

但是，种类只有两类，同样的石子堆的 SG 函数值肯定相同。

分成多个石子堆后，注意到有很多相同的，根据 SG 函数的性质，可以异或抵消。

所以其实相同的石子堆 SG 函数值异或之后抵消了。

对于操作后产生的每种石子堆，我们可以根据石子数量奇偶性质思考讨论。

如果是奇数，那最后还有一个没抵消。

如果是偶数，那么全部抵消掉了。

也就是看起来很多堆石子，其实到头来，每个种类最多一个最少没有。

# 一个小优化

这时候还不够，需要剪枝。

注意到求解 $SG_x$ 时，我们枚举的分开的量 $y$ 如果满足 $\lceil\frac x y\rceil<F$ 时，分成的石子堆石子数一定小于 $F$。

后面的 SG 函数值肯定都是 0，没必要再枚举。

于是这道题就写完了。

# 代码

我的代码是洛谷目前最优解。

```cpp
#include<bits/stdc++.h>
#define LL int
LL T,F,n,x,sum,sg[100005];
using namespace std;
// 快读
inline LL dfs(LL x)
{
	if(x<F)return 0;
	if(~sg[x])return sg[x];//记忆化
	bool vis[105];
	memset(vis,0,sizeof(vis));
	for(int i=2;i<=x;i++)//枚举分开操作所需的量
	{
		LL t=0;
		if((x+i-1)/i<F)//剪枝
		{
			vis[0]=1;
			break;
		}
		if((x%i)&1)t^=dfs(x/i+1);//奇偶讨论
		if((i-x%i)&1)t^=dfs(x/i);
		vis[t]=1;
	}
	for(int i=0;i<=100;i++)//求mex
	{
		if(!vis[i])return sg[x]=i;
	}
}
int main()
{
	memset(sg,-1,sizeof(sg));
	T=read(),F=read();
	while(T--)
	{
		sum=0;
		n=read();
		for(int i=1;i<=n;i++)
		{
			x=read();
			sum^=dfs(x);//求解x的SG函数值
		}
		if(sum)putchar('1');//根据SG函数值输出
		else putchar('0');
		putchar(' ');
	}
} 
```

---

# 唉？我怎么私了？


由于之前的做法被杀了，现在加个优化。

考虑到整除后的值的种类数量是 $\mathcal O(\sqrt n)$，我们考虑整除分块。

但是一个块内整除的值时一样的，模之后的值却未必，我们发现模之后的值好像只会影响下面这一段：

```cpp
		if((x%L)&1)t^=dfs(x/L+1);
		if((L-x%L)&1)t^=dfs(x/L);
```

我们思考一下，显然，如果整除分块得到的区间 $[L,R]$ 有 $L=R$ 我们直接做 $i=L$ 就行了，否则我们只要做 $i=L$ 和 $i=L+1$ 就行，因为我们观察上面代码，我们只关心模之后的值的奇偶性。

然后我又开开心心过题了。

```cpp
#include<stdio.h>
#include<bits/stdc++.h>
int T,F,n,x,sum,sg[200005];
using namespace std;
//快读
inline int dfs(int x)
{
	if(x<F)return 0;
	if(~sg[x])return sg[x];
	bool vis[60];
	memset(vis,0,sizeof(vis));
	for(int L=2,R;L<=x&&R+1<=x;L=R+1)
	{
		
		R=x/(x/L);
		if(ceil(x*1.0/L)<F)
		{
			vis[0]=1;
			break;
		}
		int t=0;
		if((x%L)&1)t^=dfs(x/L+1);
		if((L-x%L)&1)t^=dfs(x/L);
		vis[t]=1;
		if(L!=R)
		{
			int t=0;
			if((x%(L+1))&1)t^=dfs(x/(L+1)+1);
			if(((L+1)-x%(L+1))&1)t^=dfs(x/(L+1));
			vis[t]=1;
		}
				
	}
	for(int i=0;;i++)
	{
		if(!vis[i])return sg[x]=i;
	}
}
int main()
{
	memset(sg,-1,sizeof(sg));
    fasI::Rd(T),fasI::Rd(F);
	while(T--)
	{
		sum=0;
		fasI::Rd(n);
		for(int i=1;i<=n;i++)
		{
			fasI::Rd(x);
			sum^=dfs(x);
		}
		putchar('0'+(sum>0));
		putchar(' ');
	}
} 
```

---

## 作者：Undead2008 (赞：11)

给个奇异搞笑双 $\log$ 扫描线做法。

首先总的 $\text{SG}$ 值是每堆石子大小的 $\text{SG}$ 值异或起来，所以我们只需要对于每种大小预处理出其 $\text{SG}$ 值即可快速回答每次询问。 

假设石子堆可以随便分，一个石子堆的大小为 $n$，其 SG 值为 
$$\text{SG}(n)=\operatorname{mex}_{s_k}\{\operatorname{xor}_{i=1}^k\text{SG}(s_i)\}$$

上面式子中的 $s_k$ 表示一种将 $n$ 个石子划分为 $k$ 堆，第 $i$ 堆个数为 $s_i$ 的方案。其中 $\sum_{i=1}^ks_i=n$。

本题中的划分方式比较特殊，可以如此刻画：

![](https://cdn.luogu.com.cn/upload/image_hosting/ugvui7kc.png)

其中灰色部分为原来的石子堆中的所有石子，每一个灰色的列代表新生成的一堆石子。有

$$\text{SG}(n)=\begin{cases}0&n=1\lor n<F\\\operatorname{mex}_{W=2}^n\{\operatorname{xor}_{i=1}^W\text{SG}(H-1+[i-1\le (n-1)\bmod W])\}& \text{otherwise.}\end{cases}$$

不难发现对于某一对 $H$ 和 $W$，括号的下半部分取值只与 $(n-1)\bmod W$ 与 $W-(n-1)\bmod W$ 的奇偶性有关，也就是说对于某一对相同的 $H$ 和 $W$ 和许多不同的 $n$，上述式子的取值可能全部是相同的！

事实证明上述式子的不同取值只有 $3$ 种，分别是 $0$ 和 $n\bmod W$ 是奇数/偶数的情况。

我们枚举每一对可能的 $H$ 和 $W$，分类讨论上述三种情况。这对 $H$ 和 $W$ 仅有 $O(n\log n)$ 种。把式子写出来后发现转移 $\text{SG}(n)$ 时只需要用到 $0\sim n-1$ 的 $\text{SG}$ 值，可以直接扫描线维护。


```cpp
#include"bits/stdc++.h"
using namespace std;
const int maxn = 200010;
int N=100000,T,F,Sz,A,C,Sg[maxn],ap[2][maxn];
struct Erduologn{int A,B;bool W;};
vector<Erduologn>e[maxn];
inline void Johnseloy(int H,int W){
	int S=(H-1)*W;
	if(W&1)e[S+2].push_back({0,H-1,1}),e[S+W+2-(W%2)].push_back({0,H-1,0});
	e[S+1].push_back({H,(W%2?0:H-1),1});
	e[S+W+1+(W%2)].push_back({H,(W%2?0:H-1),0});
}
set<int>s[2];
int main(){
	cin>>T>>F;
	for(int i=1;i<=N;i++)
		for(int j=2;j<=N&&i*j<=N;j++)
			Johnseloy(i,j),C++;
	for(int i=0;i<=N;i++)for(int j=0;j<=1;j++)s[j].insert(i);
	for(int i=1;i<=N;i++){
		for(auto [A,B,w]:e[i]){
			if(!w&&!(--ap[i&1][Sg[A]^Sg[B]]))s[i&1].insert(Sg[A]^Sg[B]);
			else if(w&&!(ap[i&1][Sg[A]^Sg[B]]++))s[i&1].erase(s[i&1].find(Sg[A]^Sg[B]));
		}
		if(i>1&&i>=F)Sg[i]=*s[i&1].begin();
	}
	while(T--){
		cin>>Sz,A=0;
		for(int i=0,Y=0;i<Sz;i++)cin>>Y,A^=Sg[Y];
		putchar('0'+(A>0)),putchar(' ');
	}
}
```

---

## 作者：Zskioaert1106 (赞：9)

题目传送门：[P3235 [HNOI2014] 江南乐](https://www.luogu.com.cn/problem/P3235)

> 繁华弄影，陌上残霞，梦里醉江南。
>
> 拈棋戏子，漫度青春，梦醒乐江南。

这是一道博弈论的问题，划的再细些，是一个公平组合游戏。

公平组合游戏就是像 Nim 游戏两名玩家交替执行操作，并且两人可以执行的操作相同，直到无法执行就判输。对于这样的问题，我们有一个很大的帮手：SG 定理。

### 前置知识：SG 定理

在这之前，我们先讲一下“有向图游戏”。

有向图游戏顾名思义，就是在一个**有向无环图**中有一个棋子最初在起点上（这个起点唯一且确定），两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。

看出来了吧，它跟公平组合游戏很像，正因如此，大部分的公平组合游戏都可以转换为有向图游戏。

有向图游戏无法后退，只能一往直前。所以对于一个状态 $i$，它的下一步就可以有 $a_i$ 种可能，这就是它的 $a_i$ 个**后继状态**。

函数 $\operatorname{mex}$ 为不属于一个集合中的最小非负整数，则状态 $i$ 的 SG 函数 $\operatorname{SG}(i)=\operatorname{mex}(\operatorname{SG}(f_1),\operatorname{SG}(f_2),…,\operatorname{SG}(f_{a_i}))$，$f$ 数组为状态 $i$ 的所有后继状态。

江南乐这个游戏与很多游戏一样，可以被拆成 $n$ 个不同起点的有向图游戏，那么我们就可以用 SG 定理来求解它：**当这 $n$ 个起点的 SG 函数的异或和不为 $0$ 时，先手必胜。**

设这个游戏的 $n$ 个起点分别为 $a_1$ 到 $a_n$，只有 $\operatorname{SG}(a_1)\oplus\operatorname{SG}(a_2)\oplus…\operatorname{SG}(a_n)\neq0$ 时，游戏的先手是必胜的。同时这个组合游戏的 SG 值也就求出来了，我们还可以用它进一步的求解。

（怎么样，想到分治或者递推了吗？）

### 题目分析

就如同所有的递推和分治一样，这个游戏也有一个边界。题目说了， _当每一堆石子的数量都严格小于 F 时，他就输掉_ ，所以当一堆石子的数量——一个状态的值小于 $F$ 时，它没有后继状态——无法操作就判负。所以所有小于 $F$ 的状态 SG 值都是 $0$。

由于 $F$ 在多组数据中给定且不变，又因为 $F$ 和石子数量都 $<10^5$，所以我们肯定可以先预处理出来从 $1$ 到 $10^5$ 的所有状态的 SG 值，然后再回答每次询问。

我们可以看出来，每个状态的后继状态就是被尽量平均分成的 $M$ 种状况，那我们就将这 $M$ 种状况的 SG 值分别异或起来就好了。那我们真的要一个一个去异或吗？

我们再从题目中找信息， _满足这 M 堆石子中石子数最多的一堆至多比石子数最少的一堆多 1。_ 尽量平均，即第 $i$ 堆石子顶多只有两种不同的后继状态：$\lfloor \dfrac{i}{m} \rfloor$ 和 $\lceil \dfrac{i}{m} \rceil$，这两种状态的数量分别是 $i\bmod m$ 和 $m-i\bmod m$。当两种情况的值相等时，后一种情况数量是 $0$，其它时候两者都相差 $1$，所以第二种情况又可以写为 $\lfloor \dfrac{i}{m} \rfloor+1$。

我们知道异或的基本性质：

- 两个相同的数异或，结果为 $0$

- 一个数与 $0$ 异或结果是它本身

推出：

- 偶数个相同的数相异或，两两抵消，结果为 $0$

- 奇数个相同的数相异或，两两抵消还剩一个，结果为它本身

所以只有 $\lfloor \dfrac{i}{m} \rfloor$ 或者 $\lfloor \dfrac{i}{m} \rfloor+1$ 为奇数个的时候我们才需要计算，而且只计算一遍就行。

当然这样预处理的时间复杂度是 $\mathcal O(5\times10^9)$，妥妥的 TLE。这时我们再考虑分块。

分块时因为 $\dfrac{i}{m}$ 在同一个整数区间内的结果都只有奇偶性的两种变化，所以用 $\lfloor \dfrac{i}{\lfloor \dfrac{i}{m} \rfloor} \rfloor$ 来整除分块再好不过了。

### 代码编写

预处理：

```cpp
for(int i=f;i<100000;i++){
int q1,q2,c,ans,r;
  for(int m=2;m<=i;m=i/q1+1){//整除分块
    q1=i/m,q2=i/m+1;
    int flag=((m==i/q1)?1:2);//本来写了一堆
    while(flag--){//然后一直 30 分，
      c=i%m,ans=0;//迫不得已看来下题解的处理方法
      if(c&1)ans^=SG[q2];//结果发现原来这么简单
      if((m-c)&1)ans^=SG[q1];
      k[ans]=i;
      m++;
    }
  }
}
```

这里 $i$ 的遍历从 $F$ 开始，因为 $F$ 之前的状态属于边界，数组默认设为 $0$。

$\operatorname{mex}$ 操作：

```cpp
int j;
for(j=0;j<100;j++){
  if(k[j]!=i) { 
    SG[i]=j;
    break;
  }
}
```

这里的 $j$ 就是最小的不属于 $i$ 后继集合里的非负整数。注意：不要像我一样脑抽用的 `while(j++)`。。。

主函数部分：

```cpp
cin>>t>>f;
while(t--) {
  cin>>n; 
  int ans=0;
  while(n--){
    int i;
    cin>>i;
    ans^=SG[i];
  }
  cout<<((ans)?1:0)<<' ';
}
return 0;
```

#### 完整代码

```cpp
#include<iomanip>
using namespace std;
int t,f,n,SG[100000],k[100];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>t>>f;
    for(int i=f;i<100000;i++){
    	int q1,q2,c,ans,r;
        for(int m=2;m<=i;m=i/q1+1){
        	q1=i/m,q2=i/m+1;
            int flag=((m==i/q1)?1:2);
            while(flag--){
            	c=i%m,ans=0;
                if(c&1)ans^=SG[q2];
                if((m-c)&1)ans^=SG[q1];
                k[ans]=i;
                m++;
            }
		}
        int j;
		for(j=0;j<100;j++){
			if(k[j]!=i) { 
                SG[i]=j;
				break;
            }
		}
    }
    while(t--) {
        cin>>n; 
		int ans=0;
		while(n--){
			int i;
			cin>>i;
			ans^=SG[i];
        }
        cout<<((ans)?1:0)<<' ';
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/172050078)（谢幕）（鞠躬）

---

## 作者：born_to_sun (赞：7)

前置知识：$\operatorname{sg}$ 函数，整除分块。

本题中有多堆石子，由此可想到用 $\operatorname{sg}$ 函数解决问题。
### 整体思路：

算出石子数量为 $i$ 的石子堆的 $\operatorname{sg}$ 值，然后求出所有石子堆的 $\operatorname{sg}$ 函数的异或和。如果是 $0$ 则先手必败，否则先手必胜。


### $\operatorname{sg}$ 函数的求解
#### P（先手必败）状态的判定

显然，如果石子数量 $i<f$，那么 $\operatorname{sg}(i)=0$。

#### $i\ge f$ 时的 $\operatorname{sg}(i)$ 值：

我们考虑枚举分成的**堆数 $k$**。

根据题意我们最多会分成两种数量的石子。

- 一种数量为 $\lfloor {i\over k}\rfloor$，
这种石子总共有 $i \bmod k$ 堆。

- 另一种数量为 $\lfloor {i\over k}\rfloor+1$，
总共有 $k-i \bmod k$ 堆。

**因为是异或运算，所以我们只关心 $i \bmod k$ 和 $(k-i) \bmod k$ 的奇偶性。**

由此我们就可以求出 $\operatorname{sg}(i)$。

但这是个 $O(n^2)$ 的过程（这里的 $n=10^5$）。

**由于我们最终只关注奇偶，所以似乎做了大量无意义的工作。我们考虑优化，观察这些式子，你想到了什么？整数分块！**

对于相同的 $\lfloor {i\over k}\rfloor$，我们划为一类。

因为 $i \bmod k=i-k\times \lfloor {i\over k}\rfloor$，其中只有 $k$ 是变量，其余均为常量，由此可以进行转移。


### 代码如下：
本人代码效率不高，单看循环，复杂度仍然 $O(n^2)$，但因为所求 $\operatorname{sg}$ 值都不大，可以很快跳出循环，所以也能过。

事实上，由于询问量极小，完全可以记忆化搜索来避免求某些无用的值，不过出题人也可以开到 $10^7$ 的询问的。

如果真是那样，那就采用某些数据结构：如线段树来优化到 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int f,n;
int a[N];
int sg[N];
bool b1[2],b0[2];
void cal1(int l,int r,int x,int d,bool b[]){
    b[0]=b[1]=0;//偶数，奇数
    for(int k=l;k<=min(l+1,r);k++){
        int num=x-k*d;
        b[num&1]=1;
    }
}
void cal0(int l,int r,int x,int d,bool b[]){
    b[0]=b[1]=0;//偶数，奇数
    for(int k=l;k<=min(l+1,r);k++){
        int num=-x+k*(d+1);
        b[num&1]=1;
    }
}
int up=1e5;
int in[N];
void init(){
    for(int i=f;i<=up;i++){
        int l=2;
        int x=i;
        while(x/l){
            int r=x/(x/l);
            int d=x/l;
            cal1(l,r,x,x/l,b1);
            cal0(l,r,x,x/l,b0);
            if(b1[1]&&b0[1]) in[sg[d]^(sg[d+1])]=i;
            if(b1[0]&&b0[1]) in[sg[d]]=i;
            if(b1[1]&&b0[0]) in[sg[d+1]]=i;
            if(b1[0]&&b0[0]) in[0]=i;
            l=r+1;
        }
        for(int j=0;j<=up+1;j++){
            if(in[j]!=i){
                sg[i]=j;break;
            }
        }
    }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T;
    cin>>T>>f;
    init();
    while(T--){
        cin>>n;
        int res=0;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            res^=sg[a[i]];
        }
        if(res==0) cout<<"0 ";
        else cout<<"1 ";
    }
    return 0;
}
```

---

## 作者：Zxx200611 (赞：6)

有 $n$ 堆石子，每堆 $A_i$ 个。给定一个 $F$。

有 A，B 两个人轮流操作，每次可以将任意一堆数量大于 $F$ 的石子尽量平均地分成任意 $M$ 堆。

当所有堆石子数都小于 $F$ 时，操作者输。

问先手必胜还是必败。

---

$\quad$ 

因为 $Sg(t) = \operatorname{mex}_{i \in \operatorname{Next}(t)} Sg(i)$ 且 $Sg(总) = \operatorname{xor}_{i \in 分} Sg(i)$。

所以若需计算此堆有 $t$ 个石子时的 $Sg(t)$。则需从 $1$ 至 $t$ 枚举分出的堆数 $M$，设 $M$ 取 $i$ 时分出每堆的 $Sg$ 值异或和为 $Sg(t_i)$，将所有的 $Sg(t_i)$ 取 $\operatorname{mex}$ 即为 $Sg(t)$。

即 ：
$$
Sg(t) = \operatorname{mex}_{M=2}^{t} \operatorname{xor}_{j=1}^{M} \begin{cases}
	Sg(t/M) & j\le t \bmod M \\
	Sg(t/M+1) & j > t \bmod M\\
\end{cases}
$$


发现有许多 $Sg(t/M)$ 和 $Sg(t/M+1)$ 是相同的，由于异或的性质，我们只需要异或上 $0$ 或 $1$ 个即可。

即：
$$
\begin{aligned}
	Sg(t) = \operatorname{mex}_{M=2}^{t} & (Sg(t/M)[(t \bmod M) \bmod 2 = 1]) \\
	& \operatorname{xor} (Sg(t/M+1)[(M-(t \bmod M)) \bmod 2 = 1])
\end{aligned}
$$
此时预处理 $Sg$ 复杂度为 $O(v^2)$，无法通过。

式子中有 $t/M$ 且从小到大枚举 $M$，考虑整除分块优化。

观察这两个：

$$
\begin{matrix}
M=1| & 9 &  &  &  &  &  &  &  &  & Sg(9)\\
M=2| & 5 & 4 &  &  &  &  &  &  &  & Sg(5) \operatorname{xor} Sg(4)\\
M=3| & 3 & 3 & 3 &  &  &  &  &  &  & Sg(3)\\
M=4| & 3 & 2 & 2 & 2 &  &  &  &  &  & Sg(3) \operatorname{xor} Sg(2)\\
M=5| & 2 & 2 & 2 & 2 & 1 &  &  &  &  & Sg(1)\\
M=6| & 2 & 2 & 2 & 1 & 1 & 1 &  &  &  & Sg(2) \operatorname{xor} Sg(1)\\
M=7| & 2 & 2 & 1 & 1 & 1 & 1 & 1 &  &  & Sg(1)\\
M=8| & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &  & Sg(2) \operatorname{xor} Sg(1)\\
M=9| & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & Sg(1)\\
\end{matrix}
$$

$$
\begin{matrix}
M=1| & 6 &  &  &  &  &  & Sg(6)\\
M=2| & 3 & 3 &  &  &  &  & 0\\
M=3| & 2 & 2 & 2 &  &  &  & Sg(2)\\
M=4| & 2 & 2 & 1 & 1 &  &  & 0\\
M=5| & 2 & 1 & 1 & 1 & 1 &  & Sg(2)\\
M=6| & 1 & 1 & 1 & 1 & 1 & 1 & 0\\
\end{matrix}
$$

在同一个块中，只会出现三种情况，即 $0$ 或 $Sg(t/M)$ 或 $Sg(t/M) \operatorname{xor} Sg(t/M+1)$，因此我们只需计算前两个即可。

现在，计算一个块复杂度变为 $O(1)$，总预处理复杂度为 $O(v \sqrt{v})$，足以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;

int F;
int mem[100010],ced[100010];	//mem:Sg记忆化，ced:是否计算过
int vis[100010];

inline
int Sg(int t)
{
	if(t<F)
	{
		return 0;
	}
	if(ced[t])	//计算过，直接返回
	{
		return mem[t];
	}

	for(int l=2,r;l<=t;l=r+1)
	{
		r=t/(t/l);		//整除分块

		int cnt_p=t%l;		//计算此块在第一行上两个值的个数
		int cnt_n=l-cnt_p;	//cnt_n 为 t/l 的个数，cnt_p 为 t/l+1 的个数
		
		vis[(cnt_n%2==1?Sg(t/l):0)^(cnt_p%2==1?Sg(t/l+1):0)]=t;
		if(r-l+1>1)		//若此块存在第二行
		{
			cnt_p=t%(l+1);
			cnt_n=l+1-cnt_p;
			vis[(cnt_n%2==1?Sg(t/l):0)^(cnt_p%2==1?Sg(t/l+1):0)]=t;
		}
	}

	int j=0;
	while(vis[j]==t)	//求 mex
	{
		j++;
	}

	ced[t]=1;
	return mem[t]=j;
}

int main()
{
	int T;
	cin>>T>>F;

	for(int _=1;_<=T;_++)
	{
		int n,A;
		cin>>n;

		int ans=0;
		for(int i=1;i<=n;i++)
		{
			cin>>A;
			ans^=Sg(A);
		}

		cout<<(ans!=0)<<" ";
	}
}
```

---

## 作者：aiyougege (赞：5)

#### 做法:
　　这道题目的题意是, 给出 n 堆石子, 每次可以选择将大于某个数一堆平均分成多个堆, 最后不能操作的失败.
　　根据我们处理这类题目的一般思路, 先求出每一堆石子也就是每一个子游戏的 $SG$ 值, 然后异或起来求出游戏的 $SG$ 值.
　　分析这道题可以发现, 如果将数量为 $m$ 的一堆划分成 $i$ 堆, 那么将会划分出 $\lfloor \frac{x}{i}\rfloor\times i$ 堆个数为 $\lfloor\frac{m}{i}\rfloor$ 的堆, 和 $m-\lfloor\frac{m}{i}\rfloor\times i$ 堆个数为 $\lfloor\frac{m}{i}\rfloor+1$ 的堆.
  
　　这样我们一个常规的思路是枚举 $i$, 求出划分成 $i$ 堆的 $SG$ 函数.然后求解 $SG(m)$.然而这样效率会很低, 于是需要简化这个过程.
  
　　观察到如果一种划分方案为 $j,j,j,\cdots ,j+1,j+1,\cdots $, 那么在异或的过程中 $SG(j)\oplus SG(j)=0,SG(j+1)\oplus SG(j+1)=0$, 于是在这个过程中起关键作用的是 $j$ 和 $j+1$ 的个数是否为奇数, 如果是奇数它将会对答案产生 $SG(j)$ 或 $SG(j+1)$ 的贡献.
  
　　但是这样还是不够的, 我们自然而然的想到, 如果将石子堆划分为 $i$ 堆 或者是 $k$ 堆而且 $\lfloor\frac{m}{i}\rfloor=\lfloor\frac{m}{k}\rfloor$ , 它们的后继状态都是 $SG(\lfloor\frac{m}{i}\rfloor)$ 或者是 $SG(\lfloor\frac{m}{i}\rfloor+1)$, 它们对答案的贡献可能是相同的, 根据上一段的论述, 这取决于 $m-\lfloor\frac{m}{i}\rfloor\times i$ 和 $\lfloor \frac{x}{i}\rfloor\times i$ 的奇偶性. 如果我们手推一下, 就会发现如果
$$\lfloor\frac{m}{i}\rfloor=\lfloor\frac{m}{i+1}\rfloor=\lfloor\frac{m}{i+2}\rfloor=\cdots $$
　　,那么 $i$ 和 $i+1$ 对答案的贡献是相同的, $i+1$ 和 $i+2$ 堆答案的贡献相同, 相同的状态我们只需要计算一次, 对于$\frac{m}{i}$相同的所有 $i$, 我们只需要计算最小的 $i$ 和 $i+1$ 即可.
  
　　问题又来了, 我们如何快速跳过 $i+2,i+3,\cdots$ 呢? 如果你数学学的不错或者是做过莫比乌斯反演, 就会知道一个常用技巧, $m/(m/i)$ 是 $\frac{m}{i}$ 值相同的 $i$ 的最大值. 

#### Code
##### The Normal 
　　虽然通过此题但是几乎到了时间上限, 缺点是需要大量的开栈空间和初始化数组, 效率非常低.
```
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 100005
using namespace std;

inline int read(){
    char ch=getchar();
    int s=0;
    for(;!isdigit(ch);ch=getchar());
    for(s=0;isdigit(ch);s=s*10+ch-'0',ch=getchar());
    return s;
}

int sg[N];
int f;

int find(int x){
    if(sg[x]>-1)return sg[x];
    if(x<f)return sg[x]=0;
    sg[x]=0;int ans;
    int s[N];
    memset(s,false,sizeof(s));
    for(int i=2;i<=x;i=x/(x/i)+1)
        for(int j=i;j<=min(i+1,x);++j){
            ans=0;
            if((x%j)&1)
                ans^=find(x/j+1);
            if((j-x%j)&1)
                ans^=find(x/j);
            s[ans]=1;
        }
    for(int i=0;;i++)
        if(!s[i]){
            sg[x]=i;
            return i;
        }
}

int main(){
    int T;
    cin>>T>>f;
    memset(sg,-1,sizeof(sg));
    while(T--){
        int ans=0,n,get;
        n=read();
        for(int i=1;i<=n;++i)
            ans^=find(read());
        printf("%d ",ans?1:0);
    }
    return 0;
}

```
###### The Better
　　将上述代码中的`find()`替换成下述代码.
  
　　用到了一个比较巧妙的思路避免了上述问题, 效率提高了至少三倍.
    主要是用此时的`x`标记后继状态, 找`mex`时寻找具有这个标记的是`x`的后继状态.
```
int find(int x){
    if(sg[x]>-1)return sg[x];
    if(x<f)return sg[x]=0;
    sg[x]=0;int ans;
    for(int i=2;i<=x;i=x/(x/i)+1)
        for(int j=i;j<=min(i+1,x);++j){
            ans=0;
            if((x%j)&1)
                ans^=find(x/j+1);
            if((j-x%j)&1)
                ans^=find(x/j);
            s[ans]=x;
        }
    while(s[sg[x]]==x)sg[x]++;
    return sg[x];
}
```


---

## 作者：UnnamedOrange (赞：4)

这道题怎么做下面的两篇题解已经讲得够详细的了，我在这里只强调一个问题：必须先计算出所有接下来的状态后才能去打标记求 mex 函数，否则下一层递归可能会覆盖这一层递归的标记。

```c++
int mex[maxn];
int SG[maxn];
int DP(int x)
{
	int& ans = SG[x];
	if (~ans) return ans;
	for (register int i = 2, t; i <= x; i = t + 1)
	{
		t = x / (x / i);

		int Div = x / i;
		int Mod = x - Div * i;
		DP(Div);
		if (t != i) DP(Div + 1);
	}
	for(register int i = 2, t; i <= x; i = t + 1) // 循环两次
	{
		t = x / (x / i);

		int Div = x / i;
		int Mod = x - Div * i;
		mex[(((i - Mod) & 1) ? DP(Div) : 0) ^ ((Mod & 1) ? DP(Div + 1) : 0)] = x;

		if (t != i)
		{
			i++;
			Mod -= Div;
			mex[(((i - Mod) & 1) ? DP(Div) : 0) ^ ((Mod & 1) ? DP(Div + 1) : 0)] = x;
		}
	}
	ans = 0;
	while (mex[ans] == x) ans++;
	return ans;
}
```

然而这道题像下面两篇题解写还是能过，如果能够证明这么做是多余的，希望大家指教一下。

---

## 作者：Leap_Frog (赞：4)

### Problem.
这是一个博弈游戏。  
开始：有$N$组石子。  
操作：首先先选出一堆大于$F$的石子，然后把这一堆尽量平均地分成$m$份。  
结果：一个玩家不能操作时他输。  

### Solution.
首先，这是一个经典的博弈题目。  
看上去很像一个很经典的SG函数题目。~~别问窝是怎么看出来的。~~  
那我们用SG函数吧。  
边界条件：是$SG(n)=0$当$n<F$。  
转移：首先先假设$x=\left\lfloor\dfrac{n}{m}\right\rfloor$，  
那么$SG(n)=SG(x)\oplus...\oplus SG(x)\oplus SG(x+1)\oplus...\oplus SG(x+1)$  
由于$x\oplus x=0$，所以算上式的复杂度是$O(1)$的。  
但是，我们还需要枚举一下$m$，枚举的复杂度是$O(n)$的。  
然后，递归SG函数的递归次数是$log$级别的。  
所以此题的复杂度是$O(TlogNum_{stones})$。  

具体实现可以用记忆化搜索来实现。  

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,f,x,sg[100005];//sg表示sg指
inline int dfs(int x)//那个记忆化搜索
{
	if(~sg[x]) return sg[x];else if(x<f) return sg[x]=0;else sg[x]=0;	
	if(x<f) return sg[x]=0;//状态结束就返回。
	int mex[100005];//那个HASH的mex数组
	for(int i=2;i<=x;i=x/(x/i)+1)//这里的转移能优化一下（从莫比乌斯反演中间可以看到
		for(int j=i,r=0;j<=min(i+1,x);j++,r=0)//枚举m
		{//r就是那个SG值
			if((x%j)&1) r^=dfs(x/j+1);//SG(x+1)的异或值
			if((j-x%j)&1) r^=dfs(x/j);//SG(x)的异或值
			mex[r]=x;//放入HASH的mex数组中
		}
	while(mex[sg[x]]==x) sg[x]++;//算出SG值
	return sg[x];//返回答案
}
int main()
{
	memset(sg,-1,sizeof(sg)),scanf("%d%d",&t,&f);//初始化和读入
	for(;t--;)
	{
		int ans=0;
		for(scanf("%d",&n);n--;) scanf("%d",&x),ans^=dfs(x);//SG函数的性质：总SG函数是每个SG的异或。
		printf("%d ",ans?1:0);//输出最后答案
	}
	return puts(""),0;//强迫症（
}
```

---

## 作者：XYstarabyss (赞：3)

写这篇题解来复习一下 SG 函数。

简化题意：给定 $N$ 堆石子，一次操作指定一堆数量不小于 $F$ 的石子（假设石子数量为 $X$），分成 $M$ （$2 \le M$）堆数量为 $\lfloor \dfrac{X}{M} \rfloor$ 或 $\lfloor \dfrac{X}{M} \rfloor + 1$ 堆石子（全部分完），当一个人操作不了时输掉。先手一定赢输出 $1$，否则输出 $0$。

我们可以看一下公平组合游戏（Impartial Game）的定义。

1. 游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息。
2. 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关。
3. 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

题意所述的游戏确实为公平组合游戏。那这有什么用呢？

接下来介绍一下公平组合游戏的一些性质：

首先，由定义可知对于游戏中的各种状态只可能存在两种：以 **该状态开始先手必胜** 与 **以该状态开始先手必败**。为了方便，下面简称为 **W 状态** 和 **L 状态**。

其次，没有后继状态（从该状态开始进行一次操作后的状态）的状态一定是 **L 状态**，因为此时无法操作，该玩家也就输了。

然后，一个状态为 **W 状态** 当且仅当其至少有一个后继状态为 **L 状态**。显然，你有机会给对手留下 **L 状态** 就相当于你有方法获得了胜利。

最后，一个状态为 **L 状态** 需要它的所有后继状态都为 **W 状态**。这样，无论你怎么操作，都会给对手留下 **W 状态**，相当于你输了。

此外，若把 **L 状态** 与 **W 状态** 都看作节点，从一个状态到另一个状态的转移看作有向边，那么就能构成一张有向无环图，一般称之为博弈图。

以上这些性质应该还比较好理解吧。那这有什么用呢？

我们还需要三个定义：函数 $\operatorname{mex}$、SG 函数和SG 定理。

定义 $\operatorname{mex}$ 函数的值为不属于集合 S 中的最小非负整数，即：


$$\operatorname{mex}(S)=\min\{x\}~~~~(x \notin S, x \in N)$$

例如 $\operatorname{mex}(\{1,3,4,7,8\}) = 0$，$\operatorname{mex}(\{0,1,3,4,7\}) = 2$。

定义 SG 函数：对于状态 $x$ 与其后继状态 $y_1,y_2,y_3,\dots,y_n$，有

$$
\operatorname{SG}(x) = \operatorname{mex}(\{\operatorname{SG}(y_1), \operatorname{SG}(y_2), \dots, \operatorname{SG}(y_n)\})
$$

而对于一个公平组合游戏，设其起点为 $s$，则 **当 $\operatorname{SG}(s) \not= 0$ 时，先手必胜**。

若有多个起点 $s_1,s_2,s_3,\dots,s_k$ 则当 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \dots \oplus \operatorname{SG}(s_k) \not= 0$ 时，先手必胜。同时，该组合游戏的 $\operatorname{SG}$ 值也为 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \dots \oplus \operatorname{SG}(s_k)$。

为什么呢？可以用数学归纳法证明，如此定义的 $\operatorname {SG}$ 函数在等于 $0$ 时等价于 **L 状态**，反之为 **W 状态**。这个定理便是 ~~并非~~ 大名鼎鼎的 **SG 定理**。

接下来的内容引用自 [oi-wiki](https://oi-wiki.org/) 中对于 SG 定理的证明。不想看严谨证明的可以跳过。


> 我们假设对于游戏状态 $x'$，其当前节点 $
s_1', s_2', \ldots, s_n'$（对于任意 $i$ 有 
$s_i' < s_i$），皆满足 SG 定理。显然当 $\operatorname{SG}(s_1)'=\operatorname{SG}(s_2)'=\ldots \operatorname{SG}(s_n)'=0$ 时，该状态能满足 SG 定理。那么只需要证明对于游戏状态 $x$，其当前节点 
$s_1', s_2', \ldots, s_n'$ 符合 SG 定理，SG 定理便成立。
> 
> 事实上这一个状态可以看作一个 Nim 游戏，对于某个节点 $s_i$，它可以移动到任意一个 $\operatorname{SG}$ 值比它小或比它大的节点。在有向图游戏中，当一方将某一节点 $s_i$ 移动到 $\operatorname{SG}$ 值比它大的节点时，另一方可以移动回和 $\operatorname{SG}$ 值和 $\operatorname{SG}(s_i)$ 一样的节点，所以向 SG 值较大节点移动是无效操作。
> 
> 当移动到 SG 值较小的节点时，情况则会和 Nim 游戏一样，能够到达任何一个游戏状态 $x'$ 使得 
$\operatorname{SG}(x')= \operatorname{SG}(s_1') \oplus \operatorname{SG}(s_2') \oplus \ldots \oplus \operatorname{SG}(s_n') < \operatorname{SG}(X)$（注意到前文已经假设 $x'$ 满足 SG 定理），但到达不了 SG 值为 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \ldots \oplus \operatorname{SG}(s_n)$ 的节点。
> 
> 所以状态 $x$ 符合 SG 定理。

你可能会奇怪，为什么一个状态的 $\operatorname{SG}$ 值也为 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \dots \oplus \operatorname{SG}(s_k)$？或者说为什么异或值会和状态的胜负有关？

为了方便理解，以一个有 $5$ 堆石头的 Nim 游戏为例，假设这 $5$ 堆石头的石头数分别为 $1,9,4,6,5$。根据 Nim 游戏的性质，有 $\operatorname{SG}(x) = x$。所以

![](https://cdn.luogu.com.cn/upload/image_hosting/jq5ezfw8.png)

最终输的状态显然为

![](https://cdn.luogu.com.cn/upload/image_hosting/hhmv6810.png)

那么我们就可以给为什么 $\operatorname{SG}(x) = 0$ 时必输一个解释。

![](https://cdn.luogu.com.cn/upload/image_hosting/2twe1b3l.png)

而当 $\operatorname{SG}(x) \not= 0$ 时，先手可以取出一个 $x = 当前 SG 值$，就可以看作后手变为先手面对 $\operatorname{SG}(x) = 0$ 的局面。

那么总可以找到这样一个 $x$ 吗？从样例来说，取不出一个 $15$ 啊。

假设 $x$ 的二进制最高位 $1$ 为 $d$，即 $2^d \le x < 2^{d + 1}$。根据异或定义，一定有奇数个 $a_i$ 的二进制第 $d$ 位为 $1$。满足这个条件的 $a_i$ 一定也满足 $a_i > a_i \oplus x$，因而这也是个合法的取值。就样例而言，从第二堆取出一个 $3$ 即可。

学完了就开始做题吧。

这道题中，对于一个有 $i$ 个石子的堆，将它拆成 $M$ 堆石子相当于将该游戏转化为 $M$ 个石子数量为 $\lfloor \dfrac{i}{M} \rfloor$ 或 $\lfloor \dfrac{i}{M} \rfloor + 1$ 的子游戏，SG 值为这些子游戏的 SG 值的异或和。

然后枚举合法的 $M$，取这些 SG 值的 $\operatorname{mex}$ 值，作为有 $i$ 个石子的堆的 SG 值。因为石子数小于 $F$ 的堆不能拆，SG 值便为 $0$，以此为边界条件从小到大求解 SG 值。

预处理完后，对于单次输入的每堆石子数量，将它们对应的 SG 值异或起来，`cout << (res != 0) << ' ';` 即可。

做完了？并非如此，这太暴力了，时间复杂度是 $O(n^2)$ 的，过不了一点，考虑优化。

对于一个有 $i$ 个石子的堆，将它拆成 $M$ 堆石子相当于将该游戏转化为 $i \%  M$ 个石子数量为 $\lfloor \dfrac{i}{M} \rfloor$ 的子游戏和 $M - i \%  M$ 个石子数量为 $\lfloor \dfrac{i}{M} \rfloor + 1$ 的子游戏。

根据异或的性质，我们考虑 $i \%  M$ 与 $M - i \%  M$ 的奇偶性，只有奇数个的子游戏才能做出贡献。

诶，同时我们看到形似 $\lfloor\dfrac iM\rfloor $（上面相当于 $n$，下面相当于 $i$）是不是能想到整除分块？将 $\lfloor\dfrac iM\rfloor $ 相同的数打包同时计算能大大降低时间复杂度。

同时，我们还能注意到 $\lfloor\dfrac iM\rfloor $ 一定时，对应的 $i \%  M$ 与 $M - i \%  M$ 的奇偶性不变！证明可以参考 [这篇题解](https://www.luogu.com.cn/article/jca7khg0)：

> 当 $\lfloor\dfrac iM\rfloor $ 为奇数时，$ \begin{aligned}M -i\%M = M - (i- M\times\lfloor \frac{i}{M}\rfloor)=M \times (1+\lfloor \frac{i}{M}\rfloor)-i\end{aligned} $，对于 $ \lfloor\dfrac iM\rfloor $ 为偶数，$ M + 1 $ 后，奇偶性不变。
> 
> 当 $\lfloor\dfrac iM\rfloor $ 为偶数时，$ \begin{aligned}i\%M = i- M\times\lfloor \frac{i}{M}\rfloor\end{aligned} $，$ M + 1 $ 后，奇偶性不变。

所以我们就能写出一篇时间复杂度为 $O(n^{\frac{3}{2}})$ 的代码了。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define f(n,m,i) for (int i(n);i <= m;++ i)
#define nf(n,m,i) for (int i(n);i >= m;-- i)
#define dbug(x) cerr << (#x) << ':' << x << ' ';
#define ent cerr << '\n';
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
#define ll long long
#define gc getchar_unlocked
#define pc putchar_unlocked
int ip(){//input，输入
    int num(0),fu(1);char c(gc());
    while (c > '9' || c < '0'){
        if (c == '-')   fu = -fu;
        c = gc();}
    while (c <= '9' && c >= '0')
        num = num * 10 + (c ^ 48),c = gc();
    return num * fu;
}
void op(int x){//output，输出
    if (x < 0)  x = -x,pc('-');
    if (x > 9)  op(x / 10);
    pc((x % 10) ^ 48);
}
int sg[100005],T,F,x,l;
bool vis[105];
int main(){
    T = ip(),F = ip();
    f(F,100000,n){//求解SG(n)
        memset(vis,0,sizeof vis),l = 2;//l相当于m，即分成的堆数
        while (l <= n){//整除分块
            int nl(n / l),r(n / nl);
            f((l == r),1,cnt){//当块长为1时只算一次，否则两次
                int ans(0),res(n % l);
                if (res & 1)        ans ^= sg[nl + 1];
                if ((l - res) & 1)  ans ^= sg[nl];
                //考虑 i % m 与 m - i % m 的奇偶性
                ++ l,vis[ans] = true;//标记相应的SG值
            }
            l = r + 1;
        }
        while (vis[sg[n]])    ++ sg[n];//算mex
    }
    while (T --){
        int n(ip()),res(0);
        f(1,n,i)
            x = ip(),res ^= sg[x];
        op((res != 0)),pc(' ');//算SG的异或和输出
    }//dbug(clock() / 1000000.0)本地跑样例1s+，洛谷神机tql！
    return pc('\n'),0;
}
/*
g++ p3235.cpp -o code
./code

4 3
1 1
1 2
1 3
1 5

*/
```

---

## 作者：skylee (赞：3)

题目大意：

给你指定一个数f，并给你T组游戏，

每组有n堆石子，A,B两人轮流对石子进行操作，

每次你可以选择其中任意一堆数量不小于f的石子，平均分为m份（即保证最大的一堆和最小的一堆中石子数量之差不超过1）。

不能操作者负。

问先手是否有必胜策略。

思路：

考虑现在把一堆x个石子分为i堆。

为了使数量尽量平均，我们应该使分出来每堆的石子数量尽可能等于$\lfloor\frac{x}{i}\rfloor$，

如果每一堆分到$\lfloor\frac{x}{i}\rfloor$个石子，那么最后会多出$x\mod i$个石子。

考虑把这些多出来的石子分别放在分出来的石子堆中，那么有$x\mod i$堆会分到新的石子。

经过简单的计算，我们可以发现最后有%x\mod i$堆分到了$\lfloor\frac{x}{i}\rfloor+1$个石子，有$i-x\mid i$堆分到了$\lfloor\frac{x}{i}\rfloor$。

因为$sg(x)=mex{sg(y)|y是x的后继状态}$，又因为$y$只有两种，由于相同的数异或可以抵消，我们可以通过判断%x\mod i$和$i-x\mid i$的奇偶性来缩小运算规模。

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
inline int getint() {
    register char ch;
    while(!isdigit(ch=getchar()));
    register int x=ch^'0';
    while(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');
    return x;
}
const int N=100000;
int sg[N],mex[N];
int f;
int getsg(const int x) {
    if(~sg[x]) return sg[x];//记忆化 
    if(x<f) return sg[x]=0;//当x<f时，不能再往下分，是P状态 
    sg[x]=0;//做标记，表示x这个状态已经被访问过 
    for(int i=2;i<=x;i=x/(x/i)+1) {//分为i堆，x/(x/i)+1表示分出来最小的堆仍然为(x/i)的最大能分的堆数 
        for(int j=i;j<=std::min(i+1,x);j++) {//实际上分i堆和i+1堆两种情况 
            int tmp=0;
            if((x%j)&1) tmp^=getsg(x/j+1);//分出来x/j+1个石子//判断奇偶性，如果是偶数直接能消掉，是奇数就算一次 
            if((j-x%j)&1) tmp^=getsg(x/j);//分出来x/j个石子
            mex[tmp]=x;//判断mex的时候直接比x就可以了，不需要每次memset 
        }
    }
    while(mex[sg[x]]==x) sg[x]++;
    return sg[x];
}
int main() {
    register int T=getint();
    f=getint();
    memset(sg,-1,sizeof sg);
    while(T--) {
        int ans=0;
        for(register int n=getint();n;n--) {
            ans^=getsg(getint());
        }
        printf(ans?"1 ":"0 ");
    }
    return 0;
}
```

---

## 作者：我打 (赞：3)

博客地址：https://www.cnblogs.com/Laoli-2020/p/14285390.html

题目意思是这样的：
给定$n$堆石子，每次操作选择一堆石子数目$x$($x>=f$)，把它分成$m$堆($2<=m<=x$)，分出来的每一堆中石子数目最大值和最小值相差不超过$1$（也就是均分的意思），问你先手是否必胜。

其实这个问题可以转化成$n$个子问题，每一个子问题都只对一堆石子进行操作。

然后就可以转化成$SG$函数的问题了。

SG定理：$SG=SG(a_1) \bigoplus SG(a_2) \bigoplus SG(a_3)... \bigoplus SG(a_n)$，及总问题的SG值为分问题的SG值的异或和，本文就不进行证明了。

### 想法1
考虑到$x$的$SG$值只跟$f$有关，题目在最开始已经把$f$告诉我们了，我们可以考虑预处理。
我们用枚举每个$x$分成的石子堆数$m$($2<=m<=x$)，将这$m$堆石子的$SG$异或起来，然后对于所有的$m$的异或和取$mex$。
这显然是$O(x^2)$的做法，会直接TLE。

所以我们不能预处理，我们就想到了记忆化搜索。

### 想法2
受到想法1的启发，我们可以枚举$m$，然后异或和取$mex$，这不过这一次我们不预处理出$SG$值，而是边暴力递归边存$SG$值，遇到已经算过的$SG$值直接返回即可。
那么如何计算异或和呢？
我们用到异或的一个性质$x \bigoplus x=0$
看到下面这张图
![](https://cdn.luogu.com.cn/upload/image_hosting/0rccuaed.png)

我们发现把$x$分成$m$份的异或和只有可能是$0,SG(x/m),SG(x/m+1),SG(x/m) \bigoplus SG(x/m+1)$
那么接下来该如何计算$mex$值呢
我们每一次算完异或和以后，用一个数字打上一个特殊的标记，然后最后统计$mex$值的时候找到第一个没有这种标记的值即可

然后我们就可以拿到了70分（TLE30）
```
#include<bits/stdc++.h>
using namespace std;
int T,F,sg[200000];
int n,a,po[200000],q=0;
int SG(int x,int pos)
{
	if(sg[x]>-1)return q--,sg[x];//已经算出来过
	if(x<F)return q--,0;//不可再分
	sg[x]=0;
	for(int i=2;i<=x;i++)//计算异或和
	{
		int x1=x/i,x2=x/i+1,n2=x-x1*i,n1=i-n2;//计算分出来的两个值和两个值所占的数量
		if(n1%2==0&&n2%2==1)po[SG(x2,++q)]=pos;
		if(n1%2==0&&n2%2==0)po[0]=pos;
		if(n1%2==1&&n2%2==1)po[SG(x2,++q)^SG(x1,++q)]=pos;
		if(n1%2==1&&n2%2==0)po[SG(x1,++q)]=pos;
	}
	int pp=0;
	while(po[pp]==pos)pp++;//计算mex值
	return sg[x]=pp;
}
int main()
{
	scanf("%d%d",&T,&F);
	if(F==1)sg[1]=0;
	memset(sg,-1,sizeof(sg));
	while(T--)
	{
		memset(po,0,sizeof(po));
		scanf("%d",&n);
		int res=0;//res是总的SG值
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a);
			res^=SG(a,++q);
		}
		if(res==0)printf("0 ");
		else printf("1 ");
	}
	
	
	return 0;
}
```

### 想法3

我们可以观察到其实同一个$x$分成$m$份时会出现$t$和$t+1$两个值，我们可以把分出来的$t$和$t+1$都相同的$m$一起算，此时答案只有可能是$SG(t),SG(t) \bigoplus SG(t+1)$两种，而且存在一定的奇偶关系

我们可以发现，同一个t和t+1,m0与m0+2的答案是一样的，因此我们可以枚举t,然后算出对应的前两个m即可

可以看下面这个图，尤其是1和2的蓝色部分，规律非常明显
![](https://cdn.luogu.com.cn/upload/image_hosting/x12fdaai.png)



AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,F,sg[200000];
int n,a,po[200000],q=0;
int SG(int x,int pos)
{
	if(sg[x]>-1)return q--,sg[x];
	if(x<F)return q--,0;
	sg[x]=0;
	int i=2;
	while(i<=x)
	{
		if((x/i)==(x/(i-1))&&(x/i)==(x/(i-2)))i=(x/(x/i));//算完前两个后跳过
		int x1=x/i,x2=x/i+1,n2=x-x1*i,n1=i-n2;
		if(n1%2==0&&n2%2==1)po[SG(x2,++q)]=pos;
		if(n1%2==0&&n2%2==0)po[0]=pos;
		if(n1%2==1&&n2%2==1)po[SG(x2,++q)^SG(x1,++q)]=pos;
		if(n1%2==1&&n2%2==0)po[SG(x1,++q)]=pos;
		i++;
	}
	int pp=0;
	while(po[pp]==pos)pp++;
	return sg[x]=pp;
}
int main()
{
	scanf("%d%d",&T,&F);
	if(F==1)sg[1]=0;
	memset(sg,-1,sizeof(sg));
	while(T--)
	{
		memset(po,0,sizeof(po));
		scanf("%d",&n);
		int res=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a);
			res^=SG(a,++q);
		}
		if(res==0)printf("0 ");
		else printf("1 ");
	}
	
	
	return 0;
}
```


---

## 作者：封禁用户 (赞：1)

看到博弈论，想到用 SG 值求解。

多堆石头把所有的 SG 值按位异或即可，考虑预处理一堆石头的 SG 值。

对于 $SG_{i}$，考虑分成 $x$ 堆，有 $i \bmod x$ 堆 $\lfloor \frac{i}{x} \rfloor +1$ 个的和 $(x-i \bmod x)$ 堆 $\lfloor \frac{i}{x} \rfloor$ 个的。但我们只关心奇偶性，奇数个异或个数，偶数个异或零即可。

但这样时间复杂度是 $O(N^2)$，无法通过。

考虑整除分块，整除的余数不变，余数只关心奇偶性，所以当整除段 $l < r$ 时，在处理 $x=l$ 之外额外处理一下 $x=l+1$ 即可。

代码异常简短。

```cpp
#include<bits/stdc++.h>
using namespace std;
int sg[100010],t,m,n,ret,l,x;
bitset<64> a;
int main(){
	scanf("%d%d",&t,&m);
	for(int i=m;i<=100000;++i){
		l=2,a.set();
		while(l<=i){
			a[(i%l&1)*sg[i/l+1]^(l-i%l&1)*sg[i/l]]=0;
			if(l<i/(i/l))a[(i%(l+1)&1)*sg[i/(l+1)+1]^((l+1)-i%(l+1)&1)*sg[i/(l+1)]]=0;
			l=i/(i/l)+1;
		}
		sg[i]=a._Find_first();
	}
	while(t--){
		scanf("%d",&n),ret=0;
		while(n--)scanf("%d",&x),ret^=sg[x];
		putchar((!!ret)^48),putchar(32);
	}
}
```

---

## 作者：Purslane (赞：0)

# Solution

闹麻了，这也能黑？

考虑算 SG 函数。如果当前石子为 $n$ 个，计算其所有可能的后继。

假设我们分了 $d$ 堆，则石子最多 $\lceil \frac{n}{d} \rceil$ 个，最少 $\lfloor \frac{n}{d} \rfloor$ 个。

考虑 $l \le d \le r$ 时，满足 $\lfloor \frac{n}{d} \rfloor = t$，则后继中 $t+1$ 有 $n-dt$ 个，$t$ 有 $d(t+1)-n$ 个。

发现这两者都是关于 $d$ 的等差数列，公差都是 $t$（绝对值）。而你只关注他们的奇偶性，暴力算两项（相邻的）即可。

根据整除分块，复杂度 $O(n \sqrt n)$。

注意一下 mex 咋求，不要写丑了。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int T,n,m=100000,sg[MAXN],vis[MAXN*2],k;
inline int mex(vector<int>& vc) {
	for(auto id:vc) vis[id]=1;
	int ans=0;
	ffor(i,0,m) if(!vis[i]) {ans=i;break ;}
	for(auto id:vc) vis[id]=0;
	return ans;
}
inline int calc(const int n,const int d) {
	int sm=n/d,bg=n/d+1,ans=0;
	int bc=n-sm*d,sc=d-bc;
	if(bc&1) ans^=sg[bg];
	if(sc&1) ans^=sg[sm];
	return ans;
}
int calc_sg(int n) {
	vector<int> vc;
	int l=2;
	while(l<=n) {
		int r=n/(n/l);
		ffor(j,l,min(r,l+1)) vc.push_back(calc(n,j));
		l=r+1;	
	}
	return mex(vc);
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T>>k;
	ffor(i,k,m) sg[i]=calc_sg(i);
	while(T--) {
		int n,xs=0;
		cin>>n;
		ffor(i,1,n) {
			int v;
			cin>>v,xs^=sg[v];	
		}
		cout<<!!xs<<' ';
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## $\mathbf{Description}$
两人进行 $T$ 轮游戏，给定参数 $F$，每轮给出 $N$ 堆石子，先手和后手轮流选择石子数大于等于 $F$ 的一堆，将其分成任意（大于 $1$）堆，使得这些堆中石子数最多的和最少的相差不超过 $1$ 即尽量均分）。求先手和后手谁必胜。
## $\mathbf{Input}$
输入第一行包含两个正整数 $T$ 和 $F$，分别表示游戏组数与给定的数。
接下来 $T$ 行，每行第一个数 $N$ 表示该组游戏初始状态下有多少堆石子。之后 $N$ 个正整数，表示这 $N$ 堆石子分别有多少个。
## $\mathbf{Output}$
输出一行，包含 $T$ 个用空格隔开的 $0$ 或 $1$ 的数，其中 $0$ 代表此时小 $A$（后手）会胜利，而 $1$ 代表小 $A$ 的对手（先手）会胜利。
## $\mathbf{analysis}$
预处理每个单一游戏的 $SG$ 值。

小于 $F$ 的置 $0$ 必败。

大于$F$的枚举拆分的堆数，把分开的用 $SG$ 定理求一个异或和。

发现可以用乘除分块优化，对奇偶性相同的堆数当    $\lfloor\frac{n}{l}\rfloor$ 一样时，答案一样。

预处理的复杂度 $O(n\sqrt n)$。

注意特判 $(SG_1=0)$。

直接 $SG$ 定理回答询问就可以了。

## $\mathbf{Code}$
```cpp
#include <cstdio>
const int N=1e5+1;
int SG[N],T,F,n,is[N];
int hxor(int x,int k)
{
    if(k&1) return x;
    return 0;
}
int main()
{
    scanf("%d%d",&T,&F);
    for(int i=F;i<N;i++)
    {
        for(int l=1,r;l<=i;l=r+1)
        {
            r=i/(i/l);
            is[hxor(SG[i/l],l-i%l)^hxor(SG[i/l+1],i%l)]=i;
            ++l;
            if(l<=r&&l<=i) is[hxor(SG[i/l],l-i%l)^hxor(SG[i/l+1],i%l)]=i;
        }
        for(int j=0;is[j]==i;j++) SG[i]=j+1;
    }
    SG[1]=0;
    while(T--)
    {
        scanf("%d",&n);
        int sg=0;
        for(int x,i=1;i<=n;i++) scanf("%d",&x),sg^=SG[x];
        printf("%d ",sg>0);
    }
    return 0;
}
```
代码长度 $683B $。

用时 $13.44s $。

内存 $804.00KB $。

---

## 作者：Vidoliga (赞：0)

校内考试时想到的奇怪思路。

仔细想想，对于一份石子 $a_i$ ，枚举分成 $k$ 堆 $(1 \leq k \leq a_i)$ 。

设 $S$ 为这 $k$ 堆石子的集合。

显然有 $\text{SG}(S)=\bigoplus_{u \in S} \text{SG}(u)$ ，其中 $\bigoplus$ 为异或操作。

对于所有 $k$ ，得到的 $\text{SG}(S)$ 取 $\text{mex}$ 即为 $\text{SG}(a_i)$ 。

然而直接做 $O(Tn+v^2)$ 很好想，但只有 $70pts$ 。

考虑优化：

其中复杂度瓶颈在 $v^2$ ，于是考虑整数分块。

我们还需要考虑余数奇偶性，堆数减去余数奇偶性。

将分块后长度小于的暴力做，大于 $4$ 的分类讨论。

这里之讲分类讨论：

1. 堆数为偶数，余数奇偶性不变，堆数减去余数奇偶都可取。

2. 堆数为奇数，余数奇偶性都可取，堆数减去余数奇偶都可取。

最后，总复杂度为 $O(Tn+v\sqrt v)$ ，卡卡可过。

$Code:$

```cpp
//#pragma GCC optimize(2)
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cmath>
#define Inf 0x3f3f3f3f
//#define int long long
#define N 101010
using namespace std;
int read(){
	int d=0,f=1;char ch = getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){d=(d<<1)+(d<<3)+(ch^48);ch=getchar();}
	return d*f;
}
int sg[N],a[N],fl[N],cnt;
int n,f,t;
bool mex[N];
signed main(){
//	freopen("game.in","r",stdin);
//	freopen("game.out","w",stdout);
	t=read();f=read();
	for(int i=0;i<f;i++) sg[i]=0;
	for(int i=f;i<=100010;i++){
		cnt=0;
		for(int l=2,r;l<=i;){
			r=min(i/(i/l),i);
			if(r-l<7){
				for(int j=l;j<=r;j++){
					int res=0;
					int k=i/j,s=i%j;
					if(s&1) res^=sg[k+1];
					if((j-s)&1) res^=sg[k];
					mex[res]=1;
					fl[++cnt]=res;
				}
			}
			else{
				int res=0;
				int k=i/l;
				if(k%2==0){
					int s=i&1;
					if(s) res^=sg[k+1];
					res^=sg[k];
					mex[res]=1;
					fl[++cnt]=res;
					res^=sg[k];
					mex[res]=1;
					fl[++cnt]=res;
				}
				else{
					int s=i&1;
					res^=sg[k+1];
					res^=sg[k];
					mex[res]=1;
					fl[++cnt]=res;
					//
					res^=sg[k];
					mex[res]=1;
					fl[++cnt]=res;
					//
					res^=sg[k+1];
					res^=sg[k];
					mex[res]=1;
					fl[++cnt]=res;
					// 
					res=0;
					mex[res]=1;
					fl[++cnt]=res;
				}
			}
			l=r+1;
		}
		int h=0;
		while(mex[h]) h++;
		sg[i]=h;
		for(int i=1;i<=cnt;i++) mex[fl[i]]=0;
	}
	while(t--){
		n=read();
		for(int i=1;i<=n;i++) a[i]=read();
		int ans=0;
		for(int i=1;i<=n;i++) ans^=sg[a[i]];
		printf("%d ",ans==0?0:1);
	}
	return 0;
}
```

~~本人做法自带大常数，勿ctj~~

---


# [NOI2017] 泳池

## 题目背景

久莲是个爱玩的女孩子。

暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。


## 题目描述

经过初步分析，这块海域可视为一个底边长为 $N$ 米，高为 $1001$ 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 $1\:\textrm{m}\times1\:\textrm{m}$ 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。  

她心目中理想的游泳场满足如下三个条件：
- 必须保证安全性。即游泳场中的每一个单位海域都是安全的。
- 必须是矩形。即游泳场必须是整个网格中的一个 $a\times b$ 的子网格。
- 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。

例如：当 $N = 5$ 时，若测量的结果如下（因为 $1001$ 太大，这儿只画出网格最下面三行的信息，其他部分都是危险的）。 

 ![](https://cdn.luogu.com.cn/upload/pic/6465.png) 

那么她可以选取最下面一行的 $1\times4$ 的子海域，也可以选择第三列的 $3\times1$ 的子海域。注意她不能选取最上面一行的 $1\times5$ 的子海域，因为它没有与海滩相邻。

为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。因此她会选取最下面那一行的 $1\times4$ 的子海域作为最终方案。

虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 $q$ 的概率是安全的，$1 − q$ 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积**恰好**为 $K$ 的概率是多少。

然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。

## 说明/提示

| 测试点编号 | $N$ | $K$ |
|:-:|:-:|:-:|
| 1,2 | $=1$ | $\leq 1000$ |
| 3 | $\leq 10$ | $\leq 8$ |
| 4 | $\leq 10$ | $\leq 9$ |
| 5 | $\leq 10$ | $\leq 10$ |
| 6 | $\leq 1000$ | $\leq 7$ |
| 7 | $\leq 1000$ | $\leq 8$ |
| 8 | $\leq 1000$ | $\leq 9$ |
| 9,10,11 | $\leq 1000$ | $\leq 100$ |
| 12,13,14 | $\leq 1000$ | $\leq 1000$ |
| 15,16 | $\leq 10^9$ | $\leq 10$ |
| 17,18 | $\leq 10^9$ | $\leq 100$ |
| 19,20 | $\leq 10^9$ | $\leq 1000$ |

## 样例 #1

### 输入

```
10 5 1 2```

### 输出

```
342025319```

# 题解

## 作者：Salamander (赞：29)

首先，恰好等于$k$的概率可以通过差分转化为小于等于$k$的概率减去小于等于$k-1$的概率。
	
考虑怎么求小于等于$k$的概率。设$f_n$为底部宽为$n$时的答案，那么我们可以枚举最后连续的一段白色的长度，即$\displaystyle f_n=\sum_{i=0}^{k}f_{n-i-1}\cdot\sum_{j=2}^{\lfloor{k/i}\rfloor+1}dp_{i,j}$。其中$dp_{i,j}$表示一个宽为$i$的矩形，高度为$1$至$j-1$都全部是白色，高度为$j$的一行开始出现障碍，并且包含的所有贴住底部的白色矩形(包括宽不一定为$i$和高超过$j$的那些)大小都不超过$k$的概率。记$g_{i,j}=\sum_{l\geq j}dp_{i,l}$。
	
如果我们可以求出$dp$和$g$数组，那么转移方程就变成了齐次常系数线性递推的形式：$\displaystyle f_n=\sum_{i=0}^{k}f_{n-i-1}\cdot g_{i,2}$。注意到$k$比较大，传统的矩阵乘法为$O(k^3\log n)$无法通过，可以用多项式取模的方法来做。

先考虑怎么求出$dp$和$g$。枚举高度为$j$处的第一个障碍，
	
$\displaystyle dp_{i,j}=[i\cdot(j-1)\leq k](1-p)p^{j-1}\sum_{l=1}^{i}\left(\sum_{q>j}dp_{l-1,q}\right)\left(\sum_{q\geq j}dp_{i-l,q}\right)$
	
前缀和优化一下，就可以做到$O(k^2\log k)$了，因为合法的状态中要求$i\cdot(j-1)\leq k$，所以一共有$\sum_{i=1}^{k}\lfloor{k/i}\rfloor=O(k\log k)$个非零状态，每次转移为$O(k)$，已经可以通过此题。实际上还可以用FFT优化到$k\log^2k$。
	
$~$
	
下面是用多项式取模优化齐次常系数线性递推的方法：
	
对于递推$f_n=\sum_{i=1}^ka_kf_{n-k}$
	
设矩阵乘法中的转移矩阵为$A$，设初始状态矩阵为$B[f_k,f_{k-1},...,f_1]$，我们现在要求$BA^n$，即求$A^n$。
	
考虑$A$的特征多项式$\lambda(x)=det(xI-A)$，$I$为单位矩阵。由于转移矩阵的特殊性，在此处我们可以手动求一下特征多项式，$\lambda(x)=x^k-\sum_{i=1}^ka_ix^{k-i}$，是一个$k$次多项式，并且满足$\lambda(A)=0$。
	
如果我们把$A^n$表示成若干倍的$\lambda(A)$，即$A^n=\lambda(A)g(A)+r(A)$。由于$\lambda(A)=0$，所以$A^n=r(A)$。而$r(A)=A^n\mod\lambda(A)$，我们只需要求出$x^n$模特征多项式后的多项式，然后将$A$带入即可求出$A^n$。
	
$~$
	
多项式取模可以使用Picks的方法，用FFT做到$k\log k$，加上多项式快速幂复杂度就是$O(k\log k\log n)$，边乘边取模。当然在这里没有必要，直接暴力取模即可。
	
$~$
	
如何暴力取模?假设要求$f(x)\mod g(x)$，设$f(x)=g(x)h(x)+r(x)$，我们就是要求$r(x)$，并且要求$r(x)$的次数小于$g(x)$的次数。不妨将$g(x)$看成$0$，那么此时$f(x)$就等于$r(x)$。设$g(x)=\sum_{i=0}^kb_ix^i=0$，那么我们可以得出$\displaystyle x^k=-\sum_{i=0}^{k-1}\frac{b_i}{b_k}x^i$，我们只需要把$f(x)$中系数过大的一部分迭代，即可将系数一步步压到比$k$小。
	
两个$k$次多项式相乘，超出的部分系数是$O(k)$的，所以暴力取模的复杂度为$O(k^2)$，套上快速幂就是$O(k^2\log n)$，可以通过此题。
	
$~$
	
然后我们考虑怎么统计答案。我们已经用一个关于$A$的$k-1$次多项式$A^n=R(A)=\sum_{i=0}^{k-1}r_iA^i$表示出了$A^n$。
	
根据矩阵乘法的分配律，$B\cdot R(A)=\sum_{i=0}^{k-1}r_i\cdot B\cdot A^i$。我们要的结果是矩阵的第一个元素，而$B\cdot A^i$的第一个元素就是$f_{k+i}$，所以我们要先求出$f_k,f_{k+1},...,f_{2k}$，然后直接扫一遍统计答案即可。
	
$~$
    
复杂度$O(k^2(\log k+\log n))$，其实可以做到$O(k\log k(\log k+\log n))$。


我代码中的dp部分和上面写的转移不太一样。

```
#include<bits/stdc++.h>

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
	T f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	x*=f;
}

typedef long long LL;
const int N=1010,mod=998244353;
int n,m;
LL a,b,p,q,dp[N][N],g[N][N],pw[N];
LL A[N],f[N<<1];

LL power(LL,LL);
LL Solve(int);

int main(){
	read(n);read(m);read(a);read(b);
	p=a*power(b,mod-2)%mod;q=(mod+1-p)%mod;
	pw[0]=1;
	For(i,1,m) pw[i]=pw[i-1]*p%mod;
	
	printf("%lld\n",(Solve(m)-Solve(m-1)+mod)%mod);
	return 0;
}

LL Solve(int k){
	memset(dp,0,sizeof dp);
	memset(g,0,sizeof g);
	For(i,1,k+2) g[0][i]=dp[0][i]=1;
	For(i,1,k) Rep(j,k/i+1,2){
		For(l,1,i) dp[i][j]=(dp[i][j]+g[l-1][j+1]*g[i-l][j]%mod*pw[l-1]%mod*q)%mod;
		g[i][j]=(g[i][j+1]*pw[i]+dp[i][j])%mod;
	}
	memset(A,0,sizeof A);
	For(i,0,k) A[i+1]=q*g[i][2]%mod*pw[i]%mod;
	memset(f,0,sizeof f);
	f[0]=1;
	For(i,1,k){
		f[i]=g[i][2]*pw[i]%mod;
		For(j,1,i) f[i]=(f[i]+A[j]*f[i-j])%mod;
	}
	k++;
	For(i,k,k<<1) For(j,1,k) f[i]=(f[i]+A[j]*f[i-j])%mod;
	if(n<=k)return f[n];
	int y=n-k,len=1,L=0;
	LL res[N<<2],tmp[N<<2],x[N<<2];
	memset(res,0,sizeof res);
	memset(x,0,sizeof x);
	res[0]=1;x[1]=1;
	for(;y;y>>=1){
		if(y&1){
			For(i,0,L+len) tmp[i]=0;
			For(i,0,L) For(j,0,len) tmp[i+j]=(tmp[i+j]+res[i]*x[j])%mod;
			L+=len;
			Rep(i,L,k) For(j,1,k) tmp[i-j]=(tmp[i-j]+tmp[i]*A[j])%mod;
			chkmin(L,k-1);
			For(i,0,L) res[i]=tmp[i];
		}
		For(i,0,len+len) tmp[i]=0;
		For(i,0,len) For(j,0,len) tmp[i+j]=(tmp[i+j]+x[i]*x[j])%mod;
		len<<=1;
		Rep(i,len,k) For(j,1,k) tmp[i-j]=(tmp[i-j]+tmp[i]*A[j])%mod;
		chkmin(len,k-1);
		For(i,0,len) x[i]=tmp[i];
	}
	LL ans=0;
	For(i,0,k-1) ans=(ans+res[i]*f[i+k])%mod;
	return ans;
}
LL power(LL x,LL y){
	LL res=1;
	for(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;
	return res;
}
```

---

## 作者：shadowice1984 (赞：20)

dp神题……+过气线性代数魔法

其实重点是dp，这道题考点其实并不在常系数线性齐次递推式的化简上……

因为并没有将数据范围开到1e5所以暴力多项式取模即可通过本题

______________________________

## 本题题解

### 朴素的dp

首先发现求恰好为k不太好做，变成极大子矩形小于k的概率减小于k-1的概率

然后我们设$f_{i}$表示这种图形出现的概率：宽为i，底部第i个点恰好是坏点，且这个i×1001的矩形中不存在大于k的极大子矩形

然后我们发现我们的答案就是$\frac{f_{n+1}}{1-q}$因为只需要除掉那个坏点出现的概率就可以认为前n列是任取的

那么我们仔细看一下这个$f$数组是可以递推的

我们枚举底部上一个坏点的位置，显然这两个坏点距离不会超过k，不然就会出现一个大于k的子矩形了

那么$f_{x}$应该等于这个东西

边界条件$f_{0}=1$

## $f_{x}=\sum_{i=1}^{min(k,i)}f_{x-i}p_{i}$

其中$p_{i}$应该表示这种图形出现的概率:宽度为i的矩形，且这个i×1001里面不存在面积大于k的极大子矩形。

似乎$p_{i}$没有什么优秀的计算方式好像也不能递推……

所以我们考虑把$P_{i}$拆成一堆数的和，换句话说我们把$P$dp出来

那么我们可以考虑枚举这个矩形坏点高度的最小值

所以我们设$dp_{i,j}$表示这种图形的出现概率:宽为i的矩形，坏点高度最小值为j+1，且这个矩形中不会出现面积大于k的极大子矩形

那么我们认真观察一下会发现$dp$数组是可以递推的！

我们可以从高到低的枚举坏点高度的最小值，然后从左到右枚举第一个坏点的位置进行转移，另外显然宽度为i的矩形坏点高度最小值不得超过$k/i+1$，所以i×j大于k的dp值我们无需也不能计算出来

那么转移方程大概长这样

## $dp_{i,j}=(1-q)q^{j}\sum_{t=1}^{i}(\sum_{p=j+1}^{\infty}dp_{t-1,p})(\sum_{p=j}^{\infty}dp_{i-t,p})$

如果我们记sdp为这个东西(其实就是后缀和)

## $sdp_{i,j}=\sum_{p=j}^{\infty}dp_{i,p}$

那么转移方程就是

## $dp_{i,j}=(1-q)q^{j}\sum_{m+n=i-1}sdp_{m,j+1}sdp_{n,j}$

当然你可以用ntt加上多项式求逆均摊$O(logn)$的转移

但是这里暴力卷积就行了因为k只有1000

我们仔细观察一下会发现，如果我们以枚举坏点高度最小值的方式计算p的话我们会发现p大概是这个式子

## $p_{i}=\sum_{p=1}^{\infty}dp_{i,p}=sdp_{i,1}$


所以我们的p就被求出来了……

那么此时我们的目标是求$f_{n+1}$

暴力计算$O(nk)$矩阵快速幂计算$O(k^3logn)$哪个好像都过不去……

然而我们仔细的想一下，我们真的需要转移矩阵的n次幂吗?

其实不是，我们只需要转移矩阵乘以初值向量的之后的向量，我们甚至不需要这个向量，我们只需要他的最后一位

下面呢就是一种处理常系数齐次线性递推式的技术了

________________

### 常系数齐次线性递推式的快速计算

先解释一下我们要干什么

我们要快速计算一个“递推式”

而这个递推式满足下面几个条件

1.它是"线性"的换句话说递推式中只有常数项和一次项，且必须有一次项

2.它是"齐次"的，所有项的次数必须相等，结合它是“线性”的，我们可以知道这个递推式里没有常数项

3.它是"常系数"的,所有项的系数必须是一个常数

所以，我们大概要快速计算这个递推式的第n项

## $f_{n}=\sum_{i=1}^{k}f_{n-i}a_{i}$

当然可以矩阵快速幂计算，复杂度是$O(k^3logn)$的

但是我们换一个想法

如果我们可以把转移矩阵$A$的n次幂转化为这样的形式

至于$C_{i}$是什么你可以认为那是我们构造的奥妙重重的一组数，因n的不同而不同

## $A^{n}=\sum_{i=0}^{k-1}A^{i}c_{i}$

那么我们因为要求的是初始向量St乘转移矩阵的n次幂之后的向量，我们可以在等式两边同时左乘一个St

## $StA^{n}=\sum_{i=0}^{k-1}StA^{i}c_{i}$

由于我们要算的是向量$St×A^{n}$的第1项

所以刚才的等式应该对所有向量的第1项也成立

## $(StA^{n})_{1}=\sum_{i=0}^{k-1}c_{i}(StA^{i})_{1}$

等等,我们要求$St×A^{i}$的第1项？

那不就是St的第i项吗？

所以我们得到了这个式子

## $(StA^{n})_{1}=\sum_{i=0}^{k-1}c_{i}St_{i}$

所以换句话说我们只要能构造出这个奥妙重重的$c$我们就可以成功计算$f_{n}$了

怎么构造呢？

我们假设说我们构造出了这样一个神奇的多项式$f$使得下列等式成立,这里的0
是0矩阵的意思

## $\sum_{i=0}^{k}f_{i}A^{i}=0$

那么我们对于$A^{n}$可以把它表示成这种形式

其中G，C是另外两个多项式

## $A^{n}=G(A)f(A)+C(A)$

因为刚才的等式，所以

## $A^{n}=C(A)=\sum_{i=0}^{k}c_{i}A^{i}$

换句话说，我们只需要把A^{n}表示刚才的形式就行了，然后提取多项式C的系数就是我们需要的c了

刚才的式子好像是多项式取模的式子？

于是我们可以快速幂求出$A^{n}modf(A)$的值

最后一个问题，怎么求$F(A)$?

如果f(A)非常好求的话矩阵快速幂就没有什么存在的价值了

所以它一般来讲不是很好求，据说需要高斯消元

但是，常系数齐次线性递推的矩阵是特殊的……

所以我们的f(A)的系数可以$O(1)$得知

## $F_{k}=1$

## $F_{k-i}=a_{i}$

其中$a_{i}$是递推系数

所以有了这个以后我们就可以快速幂+多项式取模搞出c来

然后就可以求出$f_{n}$了~

多项式取模可以去洛谷模板区，当然这道题不需要ntt版的多项式取模

直接厂除法进行多项式取模就行了

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=2048;typedef unsigned long long ll;const ll mod=998244353;
int n;int k;ll p;ll q;ll x;ll y;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
ll sdp[N][N];ll st[N];ll ret[N];ll tr[N];ll f[N];ll cp1[N];ll cp2[N];ll a[N];
inline ll solve(int k)
{
	for(int i=0;i<=k+1;i++)sdp[i][0]=1;//dp
	for(int j=k;j>=1;j--)
		for(int i=1;i*j<=k;i++)
		{
		  	ll ret=0;for(int t=1;t<=i;t++)(ret+=sdp[j+1][t-1]*sdp[j][i-t])%=mod;
		  	ret=ret*p%mod*po(q,j)%mod;sdp[j][i]=(sdp[j+1][i]+ret)%mod;
		}
	k++;tr[1]=p;for(int i=1;i<=k-1;i++)tr[i+1]=sdp[1][i]*p%mod;//转移系数
	st[0]=1;for(int i=1;i<k;i++)for(int j=0;j<i;j++)(st[i]+=st[j]*tr[i-j])%=mod;//初值
	for(int i=1;i<=k;i++)f[k-i]=mod-tr[i];f[k]=1;ret[0]=1;a[1]=1;int t=n+1;
	while(t)//快速幂
	{
		if(t&1)
		{
			for(int i=0;i<=k;i++)cp1[i]=ret[i],ret[i]=0;
			for(int i=0;i<=k;i++)for(int j=0;j<=k;j++)(ret[i+j]+=cp1[i]*a[j])%=mod;//卷积
			for(int i=2*k;i>=k;i--)//厂除法取模
				for(int j=0;j<=k;j++)(ret[i-k+j]+=mod-ret[i]*f[j]%mod)%=mod;
		}
		for(int i=0;i<=k;i++)cp1[i]=a[i];for(int i=0;i<=k;i++)cp2[i]=a[i],a[i]=0;
		for(int i=0;i<=k;i++)for(int j=0;j<=k;j++)(a[i+j]+=cp1[i]*cp2[j])%=mod;
		for(int i=2*k;i>=k;i--)
			for(int j=0;j<=k;j++)(a[i-k+j]+=mod-a[i]*f[j]%mod)%=mod;t>>=1;
	}ll ans=0;for(int i=0;i<k;i++)(ans+=st[i]*ret[i])%=mod;
	for(int i=0;i<=k+1;i++)for(int j=0;j<=k+1;j++)sdp[i][j]=0;
	for(int i=0;i<=k;i++)a[i]=0;for(int i=0;i<=k;i++)ret[i]=0;
	for(int i=0;i<=k;i++)st[i]=0;return ans*po(p,mod-2)%mod;输出
}
int main()
{
	scanf("%d%d%lld%lld",&n,&k,&x,&y);q=x*po(y,mod-2)%mod;p=(1+mod-q)%mod;
	printf("%lld",(solve(k)+mod-solve(k-1))%mod);return 0;//拜拜程序~
}

```























---

## 作者：CYJian (赞：14)

~~好像我的转移方法和大家都不同，那就顺便来发个题解吧...~~

直接算最大面积为 $k$ 比较难处理，则考虑差分：先求出最大面积 $\le k$ 的概率，再减去最大面积 $\le k-1$ 的概率，就得到了最大面积 $=k$ 的概率了。

然后考虑设计状态 $f_{h, w}$ 为：

当前保证有一个高为 $h$，宽为 $w$ 的安全区域，且高为 $h+1$ 以上的位置任意且合法面积不超过 $k$ 的概率是多少。

注意到我们可以枚举高度为 $h+1$ 的那一行，左侧第一个危险的点出现的位置，则有转移：

$$ f_{h, w} = p^w \times f_{h+1,w}+\sum_{i=1}^{w} f_{h+1,i-1} \times f_{h,w-i} \times p^{i-1}\times (1-p) $$

然后最后的答案就是 $f_{0, n}$ 了。

乍一看，状态数 $O(n^2)$ 转移数 $O(n)$，复杂度就成了 $O(n^3)$。但是事实上针对最大面积不超过 $k$ 这个限制条件，我们真正有用的状态数是只有 $O(k \log k)$ 个的。则判断 $h \times w \le k$ 之后，实际复杂度是 $O(k^2 \log k)$ 的。

这个 `dp` 我是使用递归实现的，写起来很方便。当然也可以使用递推，但是需要注意循环的顺序（$h$ 从大到小枚举，$w$ 从小到大枚举，这个不能乱顺序）

然后我们就解决了 $n, k \leq 10^3$ 的部分，到这里就可以拿到 $70$ 分了。

然后我们考虑一下 $n$ 很大的时候，$f_{0, n}$ 的转移。注意到对于所有 $x \ge k$，$f_{0, x}$ 都会用到 $f_{1,0}, f_{1,1},\ldots,f_{1,k}$ 进行转移。

注意到，如果我们先算出 $f_{1,0}, f_{1,1},\ldots,f_{1,k}$，那么就可以算出 $f_{0, x}$ 了。

考虑设 $G_i=f_{1,i}\times p^i \times q$，$F_n=f{0,n}$，则我们最后想知道的是 $F_n$，且 $F$ 可以通过 $G$ 互相转移：

$$ F_n = \sum_{i=1}^{k+1} G_{i-1} \times F_{n-i} (n > k)$$

使用矩阵乘法加速转移，结合上面的暴力 `dp` 就可以获得 $90$ 分的好成绩。

然后，如果你还会[常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)的话，你就会发现写出这个递推式之后就可以套上板子了。如果不会的话，建议在有一定数理基础的情况下再去学习。

由于此题中 $k \leq 10^3$，所以多项式乘法和取模可以暴力实现。

部分代码：

```cpp
typedef long long ll;

const int mod = 998244353;
const ll MOD = 8ll * mod * mod;

inline int Mod(int x) { return x >= mod ? x - mod : x; }
inline void ADD(ll &x, ll y) { x += y, x -= x >= MOD ? MOD : 0; }
inline int fsp(int x, int k = mod - 2) {
	int s = 1;
	while(k) {
		if(k & 1) s = 1LL * s * x % mod;
		x = 1LL * x * x % mod, k >>= 1;
	} return s;
}

int F[3010], lf;
int Q[3010], lq;
int S[3010], ls;
int G[3010], lg;
ll tmp[3010];
int A[3010];

inline void PolyMul(int a[], int b[], int c[], int &n, int m) {
	for(int i = 0; i <= n; i++)
		for(int j = 0; j <= m; j++)
			ADD(tmp[i + j], 1LL * b[i] * c[j]);
	n += m;
	for(int i = 0; i <= n; i++) a[i] = tmp[i] % mod, tmp[i] = 0;
}

inline void PolyMod(int a[], int &n) {
	for(int i = n; i >= lq; i--) {
		if(!a[i]) continue;
		int mul = mod - a[i];
		for(int j = 0; j <= lq; j++)
			a[i - j] = (a[i - j] + 1LL * mul * Q[lq - j]) % mod;
	} chkmin(n, lq - 1);
	while(n && !a[n]) --n;
}

inline int calc(int n, int k) {
	memset(Q, 0, sizeof(Q));
	memset(S, 0, sizeof(S));
	memset(G, 0, sizeof(G));

	Q[k] = 1, lq = k;
	for(int i = 0; i < k; i++) Q[k - i - 1] = mod - A[i];

	S[0] = 1, ls = 0;
	G[1] = 1, lg = 1;
	while(n) {
		if(n & 1) PolyMul(S, S, G, ls, lg), PolyMod(S, ls);
		PolyMul(G, G, G, lg, lg), PolyMod(G, lg), n >>= 1;
	}

	int res = 0;
	for(int i = 0; i < k; i++)
		res = (res + 1LL * F[i] * S[i]) % mod;
	return res;
}

int p, q;
int pw_p[1100000];
int pw_q[1100000];
int f[1010][1010];

inline int dp(int h, int w, int k) {
	if(w == 0) return 1;
	if(h * w > k) return 0;
	if(~f[h][w]) return f[h][w];
	int &F = f[h][w] = 1LL * pw_p[w] * dp(h + 1, w, k) % mod;
	for(int i = 1; i <= w; i++)
		F = (F + 1LL * dp(h + 1, i - 1, k) * q % mod * pw_p[i - 1] % mod * dp(h, w - i, k)) % mod;
	return F;
}

inline int solve(int n, int k) {
	memset(f, -1, sizeof(f));
	dp(0, k, k);
	memset(F, 0, sizeof(F));
	memset(A, 0, sizeof(A));
	for(int i = 0; i <= k; i++) {
		F[i] = i ? f[0][i] : 1;
		A[i] = !i ? q : 1LL * f[1][i] * q % mod * pw_p[i] % mod;
	} return calc(n, k + 1);
}

int main() {
	int n = ri, k = ri, x = ri, y = ri;
	p = 1LL * x * fsp(y) % mod, q = mod + 1 - p;
	int N = min(1000, max(n, k)) * 1001;

	pw_p[0] = pw_q[0] = 1;
	for(int i = 1; i <= N; i++) {
		pw_p[i] = 1LL * pw_p[i - 1] * p % mod;
		pw_q[i] = 1LL * pw_q[i - 1] * q % mod;
	}

	int r1 = solve(n, k);
	int r2 = solve(n, k - 1);
	printf("%d\n", Mod(r1 + mod - r2));

	return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：5)

等于 $K$ 的概率等于小于等于 $K$ 的概率减去小于等于 $K-1$ 的概率，题目变为求最大全空长方形大小小于等于 $K$ 的概率。

设 $g_{r\ c}$ 为，已知 $r$ 行 $c$ 列全空，最大底部在这 $c$ 列里的长方形面积小于等于 $K$ 的概率。则：

 - 当 $c=0$，$g_{r\ c} = 1$；
 - 当 $r\times c>K$，$g_{r\ c}=0$；
 - 否则，$g_{r\ c}$ 可以这样计算：

有 $p^c$ 概率第 $r+1$ 行全空，于是 $p^cg_{r+1\ c}\rightarrow g_{r\ c}$。  
否则枚举 $r+1$ 行第一列故障是在哪里，定这个为第 $i$ 列（从 0 开始编号）。  
我么有 $p^i(1-p)$ 的概率这个位置是第一个故障。我们知道 $0$ 到 $i-1$ 没有故障，所以底部在 $0$ 到 $i-1$ 的长方形可以的概率是 $g_{r+1\ i}$。 剩下 $i+1$ 到 $n-1$ 仍然可能在第 $r+1$ 行有故障，所以概率是 $g_{r\ n-i-1}$。综上，$p^i(1-p)g_{r+1\ i}g_{r\ n-i-1}\rightarrow g_{r\ c}$。

于是我们有

$$g_{r\ c}=p^cg_{r+1\ c}+\sum_{i=0}^{n-1}p^i(1-p)g_{r+1\ i}g_{r\ n-i-1}$$

我们想要的答案就是 $g_{0\ n}$，但是这直接计算是不可能的。~~但是这样直接做就有 70 分，恭喜你用普及组知识拿到 NOI 题的 70 分。~~ 观察到第二个条件：如果 $r\times c>k$，则 $g_{r\ c}=0$。我们再替代进去 $r=0$：

$$g_{0\ c}=p^cg_{1\ c}+\sum_{i=0}^{n-1}p^i(1-p)g_{1\ i}g_{0\ n-i-1}$$

如果 $c>k$，那么就有特别多的项根本不可能产生贡献，因为 $1\times i>k$ 啊！于是如果 $c>k$ 就有  

$$g_{0\ c}=\sum_{i=0}^{k-1}p^i(1-p)g_{1\ i}g_{0\ n-i-1}$$

定 $c_i=p^i(1-p)g_{1\ i}$：

$$g_{0\ c}=\sum_{i=0}^{k-1}c_ig_{0\ n-i-1}$$

这明显是常系数线性齐次递推。
先用记一化搜索预处理 $g_{0\ 0},g_{0\ 1},\dots,g_{0\ k}$和 $g_{1\ 0},g_{1\ 1},\dots,g_{1\ k}$，直接用模板搞即可。

有 $O(k\log k)$ 可能的 $(r,c)$ 对需要预处理；于是预处理的时间是 $O(k^2\log k)$。  
求常系数线性齐次递推的时间复杂度就是 $O(k\log k\log n)$。  
总共时间复杂度 $O(k^2\log k+k\log k\log n)$ 解决。

代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define fi first
#define se second
#define pb push_back
 
#define ll long long
#define pii pair<int, int>
//#define int ll
const int MOD = 998244353;

#define intsize (sizeof(int))

namespace poly {
	const int MOD = 998244353;
	const int NTTG = 3;
	int rev[262160];
	int minv[262160];
	int w[20][2][262160];
	
	int qpow(int b, int e) {
		int re=1;
		while(e){
			if(e&1)re=1ll*re*b%MOD;
			b=1ll*b*b%MOD;e>>=1;
		}
		return re;
	}
	
	void constructrev(int n) {
		for(int i=1, j=0; i < n; i++) {
			int bit=n>>1;
			for(;j&bit;bit>>=1)j^=bit;
			j^=bit; rev[i] = j;
		}
	}

	void constructroot(int n) {
		minv[1] = 1;
		iter(i, 2, n+1)
			minv[i]=1ll*(MOD-MOD/i)*minv[MOD%i]%MOD;
		for(int l=1; (1<<l)<=n; l++)
			rep(inv, 2) {
				int re = inv?qpow(minv[NTTG],(MOD-1)>>l):qpow(NTTG,(MOD-1)>>l);
				w[l][inv][0] = 1;
				rep1(i,(1<<(l-1))-1) w[l][inv][i] = 1ll*w[l][inv][i-1]*re%MOD;
			}
	}
	
	void ntt(int *v, int n, bool inv) {
		rep(i, n) if(i < rev[i]) swap(v[i], v[rev[i]]);
		for(int l=1;(1<<l)<=n;l++)
			for(int i=0;i<n;i+=(1<<l)) {
				int p=i+(1<<(l-1));
				iter(j, i, p) {
					int a=v[j],b=1ll*v[j+(1<<(l-1))]*w[l][inv][j-i]%MOD;
					v[j]=(a+b>=MOD?a+b-MOD:a+b);
					v[j+(1<<(l-1))]=(a<b?a+MOD-b:a-b);
				}
			}
		if(inv) rep(i, n) v[i] = 1ll*v[i]*minv[n]%MOD;
	}
	
	void mult(int *a, int as, int *b, int bs, int *o, bool construct, bool clean = 0, int thr = 10000000) {
		int n = as+bs-1;
		while(n - (n & (-n))) n += (n & (-n));
		if(construct) constructroot(n);
		constructrev(n);
		ntt(a, n, 0); ntt(b, n, 0);
		rep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;
		ntt(o, n, 1);
		iter(i, thr, n) o[i] = 0;
		if(clean) rep(i, n) a[i] = b[i] = 0;
	}

	void cfn(int* a, int as, int *o) {
		static int tmp[262160];
		if(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }
		cfn(a, (as+1)/2, o); int le = 0;
		while((1 << le) < (as << 1)) le++;
		constructrev(1 << le);
		rep(i, as) tmp[i] = a[i];
		iter(i, as, 1<<le) tmp[i] = o[i] = 0;
		ntt(tmp, 1<<le, 0); ntt(o, 1<<le, 0);
		rep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;
		ntt(o, 1<<le, 1);
		iter(i, as, 1<<le) o[i] = 0;
	}

	void init(int n) { constructroot(n); }
	
	void divide(int *a, int as, int *b, int bs, int *MEMORY, int *q, int *r) {
		if(as < bs) {
			memcpy(r, a, (bs-1) * intsize);
			return;
		}
		static int ar[262160], br[262160], bin[262160];
		int th = as, re = as-bs+1;
		//th = re+1;
		rep(i, as) ar[i] = a[as-1-i];
		rep(i, bs) br[i] = b[bs-1-i];
		memcpy(bin, MEMORY, (sizeof(int))*re);
		mult(ar, th, bin, re, q, 0, 1, re);
		for(int l = 0, r = re-1; l < r; l++, r--) swap(q[l], q[r]);
		rep(i, re) bin[i] = q[i];
		mult(bin, re, b, bs, r, 0, 1, bs - 1);
		rep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;
	}
}
int rem[262160], dg;
int ans[262160];
int A[262160], B[262160], C[262160];
int BULLSHIT[262160], BATSHIT[262160];
int me[262160];
void calc(int n) {
	if(n + 1 < dg) {
		ans[n] = 1;
		return;
	}
	calc(n/2);
	int sz = dg - 1 + dg - 1 + (n % 2) - 1;
	memcpy(A, ans, (dg - 1) * intsize);
	memcpy(B + (n % 2), ans, (dg - 1) * intsize);
	poly::mult(A, dg-1, B, dg-1+(n%2), C, 0, 1);
	memcpy(BATSHIT, rem, dg * intsize);
	poly::divide(C, sz, BATSHIT, dg, me, BULLSHIT, ans);
}
int run(int n, int k, vector<int> dt, vector<int> ini) {
    if(n<ini.size())return ini[n];
	int h = 1; while(h < (k << 2)) h <<= 1;
	poly::init(h);
    memset(rem, 0, sizeof rem);
    memset(ans, 0, sizeof ans);
    memset(me, 0, sizeof me);
	rem[k] = 1; dg = k+1;
	rep1(i, k) {
		int p = dt[i-1]; p = -p;
		p = ((p + MOD) % MOD + MOD) % MOD;
		rem[k-i] = p;
	}
	memcpy(BATSHIT, rem, dg * intsize);
	reverse(BATSHIT, BATSHIT+dg);
	poly::cfn(BATSHIT, dg, me);
	calc(n);
	int re = 0;
	rep(i, k) {
		int p = ini[i];
		p = ((p + MOD) % MOD + MOD) % MOD;
		re = (re + 1ll * p * ans[i]) % MOD;
	}
	return re;
}
int n,k,q;
int qpow(int b,int e=MOD-2){
    int a=1;while(e){
        if(e&1)a=1ll*a*b%MOD;
        b=1ll*b*b%MOD;e>>=1;
    }return a;
}
int qe[1005];
int smdp[1005][1005];
int f(int row,int col){
    if(row*col>k)return 0;
    if(!col)return 1;
    int&g=smdp[row][col];
    if(g!=-1)return g;
    g=1ll*qe[col]*f(row+1,col)%MOD;
    rep(i,col)g=(g+1ll*qe[i]*(MOD+1-q)%MOD*f(row+1,i)%MOD*f(row,col-i-1))%MOD;
    return g;
}
int solve(int kv){
    memset(smdp,-1,sizeof smdp);
    vector<int> dt,ini;
    k=kv;
    rep(i,k+1) dt.pb(1ll*qe[i]*(MOD+1-q)%MOD*f(1,i)%MOD);
    rep(i,k+1) ini.pb(f(0,i));
    return run(n,k+1,dt,ini);
}
int main() {
    ios_base::sync_with_stdio(false); 
	cin.tie(0);
	int k,x,y; cin >>n>>k>>x>>y;
    qe[1]=q=1ll*x*qpow(y)%MOD;qe[0]=1;
    iter(i,2,k+1)qe[i]=1ll*qe[i-1]*q%MOD;
    cout <<(solve(k)-solve(k-1)+MOD)%MOD<<endl;
    return 0;
}

```

---

## 作者：RainWetPeopleStart (赞：0)

首先，先刻画最大面积，设 $lm_i$ 表示第 $i$ 列“最下方”的危险方格的位置，对于算面积，枚举高度 $h$，求出最长的满足 $lm_i>h$ 的连续段长 $len_h$，最大的面积就是 $\max\limits_{i}i\times len_i$。

设计 DP，记 $f_{i,j,k}$ 表示当前连续段长为 $i$，面积为 $j$，段里面 $lm$ 的值不小于 $k$ 的概率。

发现 $j$ 这一维比较浪费，考虑容斥，转成面积不超过 $k$ 减掉面积不超过 $k-1$，然后就可以去掉 $j$ 了。

下记 $p_i$ 表示 $lm_*=i$ 的概率（因为所有的列本质等价）。

有初值 $f_{0,k+1}=1,f_{1,k+1}=p_{k+1}$。

转移有两种：

1. 继承 $j+1$ 的概率，$f_{i,j}=f_{i,j}+f_{i,j+1}$。

2. 拼上一个连续段和一个 $lm$ 值为 $j$ 的位置（避免算重）,$f_{i,j}=f_{i,j}+\sum\limits_{x<i}f_{x,j}f_{i-x-1,j+1}p_j$。

此时这一部分的答案为 $f_{n,1}$。

复杂度 $O(n^2k)$？

实际上只有 $i(j-1)\le k$ 的状态有用，分析得复杂度为 $O(n^2+\sum\limits_i(\dfrac{k}{i})^2)=O(n^2+k^2)$。

这一部分应该可以用多项式做到 $O(n\log n+k\log^2 k)$。因为不是重点，故略去。

此时已经有 $70$ 分了，考虑优化。

发现上文的 DP 复杂度瓶颈在于求 $f_{*,1}$，而 $f_{*,2}$ 只有前 $k$ 个位置有用，所以 $f_{i,1}$ 的值只和 $f_{j,1}$（$j\ge i-O(k)$）有关，可以暴力的求前 $k$ 项，用矩阵快速幂递推出 $f_{n,1}$。复杂度 $O(k^3\log n)$，期望 $90$ 分。

此时上文的递推式是常系数齐次线性递推的形式，也就是让我们求 $x^n$ 对特征多项式取模的结果（这一部分不会可以跳转到模板题）。因为本题 $k$ 只有 $1000$，所以原题的多项式操作可以换成暴力，做到 $O(k^2\log n)$，也可使用多项式做到 $O(k\log k(\log n+\log k))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10,mod=998244353;
bool Mbg;
int n,k,x,y;
void Add(int &a,int b){a+=b;if(a>=mod) a-=mod;}
void Sub(int &a,int b){a-=b;if(a<0) a+=mod;}
void Mul(int &a,int b){a=1ll*a*b%mod;}
int qp(int a,int b){
    int x=1;
    while(b){
        if(b&1) Mul(x,a);
        Mul(a,a);b>>=1;
    }return x;
}
int P[N<<1],Q[N<<1],R[N<<1],tmp[N<<1];
void Mul(int *A,int *B,int len){
    for(int i=len;i>=0;i--){
        int val=A[i];A[i]=0;
        for(int j=len;j>=0;j--){
            Add(A[i+j],1ll*val*B[j]%mod);
        }
    }
}
void Mod(int *A,int *B,int len){
    for(int i=len*2;i>=len;i--){
        if(!A[i]) continue;
        int val=1ll*A[i]*qp(B[len],mod-2)%mod;
        for(int j=len;j>=0;j--){
            Sub(A[i+j-len],1ll*val*B[j]%mod);
        }
    }
}
int f0[N];
int calc(int len,int pw){
    memset(R,0,sizeof(R));
    memset(P,0,sizeof(P));
    R[0]=1;P[1]=1;
    while(pw){
        if(pw&1){
            Mul(R,P,len);Mod(R,Q,len);
        }pw>>=1;
        memcpy(tmp,P,sizeof(tmp));
        Mul(P,tmp,len);Mod(P,Q,len);
    }
    int ans=0;
    for(int i=0;i<=len;i++)
        Add(ans,1ll*f0[i]*R[i]%mod);//cout<<R[i]<<' ';cout<<endl;
    return ans;
}
int f[N][N];
int p,pb[N];
int DP(int lim,int op=0){
    if(lim==0){
        return qp(pb[1],n);
    }memset(f,0,sizeof(f));
    f[lim+1][0]=1;f[lim+1][1]=pb[lim+1];
    //cout<<lim+1<<' '<<pb[lim+1]<<endl;
    for(int i=lim;i>=1;i--){
        for(int j=0;j<=lim+1;j++){
            if(j*(i-1)>lim) 
    /*if(op==0)return f[1][n];
    else return 0;*/break;
            f[i][j]=f[i+1][j];
            for(int x=0;x<j;x++){
                int olen=j-x;
                Add(f[i][j],1ll*f[i][x]*f[i+1][olen-1]%mod*pb[i]%mod);
            }
            //cout<<i<<' '<<j<<' '<<f[i][j]*8ll%mod<<endl;
        }
    }
    memset(Q,0,sizeof(Q));
    memset(f0,0,sizeof(f0));
    for(int i=0;i<=lim;i++) f0[i]=f[1][i];
    for(int i=0;i<=lim;i++) Q[i]=(mod-1ll*pb[1]*f[2][lim-i]%mod);
    Q[lim+1]=1;
    return calc(lim+1,n);
}

bool Med;
int main(){
    cin>>n>>k>>x>>y;
    p=1ll*x*qp(y,mod-2)%mod;
    for(int i=1;i<=1001;i++) pb[i]=1ll*qp(p,i-1)*(mod+1-p)%mod;
    cout<<(DP(k)+mod-DP(k-1))%mod<<endl;
    cerr<<(&Mbg-&Med)/1024.0/1024.0;
    return 0;
}
```

---

## 作者：Lgx_Q (赞：0)

题意：一个长为 $n$，无限宽的网格图，每个格子有 $p$ 概率染白，有 $1-p$ 概率染黑。选择一个下边界紧贴网格图下边界的全是白色的矩形，求选出矩形最大面积为 $k$ 的方案数，答案模 $998244353$。$1\le n\le 10^9,\space 1\le k\le 1000$

---

注意恰好，考虑用 $\le k$ 的减去 $\le k-1$ 的。

一个暴力的 dp 是设 $f[i,j]$ 表示已知前 $i$ 行都是白色，且当前长度为 $j$ 的考虑了剩余部分的合法概率。然后类似于笛卡尔树转移。

注意到 $i\cdot j\le k$。当 $i>0$ 时有 $j\le k$，说明我们 dp 的矩形长度一般情况下不超过 $k$，只有当 $i=0$ 即我们从第一行开始确定时 $j$ 有可能超过 $k$。

把这个东西分开。设 $f[i]$ 表示前 $i$ 列，且第 $i$ 列第一行的格子是黑色的合法概率，$\frac{f[n+1]}{1-p}$ 即为所求。

设 $g[i,j]$ 表示不需要考虑前 $i-1$ 行且前 $i$ 行都是白色，合法的概率。

先求 $g$：

+ 第 $i+1$ 行没有黑格子：$g[i,j]\gets g[i+1,j]\times p^j$

+ 第一个黑格子在第 $x$ 个位置：$g[i,j]\gets g[i+1,x-1]\times g[i,j-x]\times p^x\times (1-p)$

由于 $i\cdot j\le k$，状态数为 $O(k\log k)$，时间 $O(k^2\log k)$。

接下来求 $f$，钦定第 $0$ 列为黑色，显然有

$$f[i]=\sum_{j=1}^{\min(i,k+1)} f[i-j]\times g[1,j-1]$$

这是常系数齐次线性递推的形式。

先 dp 出前 $k$ 项，然后直接多项式快速幂 + 取模即可。由于 $k\le 1000$，直接暴力多项式操作就行。

时间复杂度 $O(k^2(\log k+\log n))$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mkp make_pair
#define pir pair<ll,ll>
#define fi first
#define se second
#define pb push_back
const ll maxn=2010, mod=998244353;
using namespace std;
ll n,m,x,y,p,f[maxn][maxn],sum,a[maxn],g[maxn],F[maxn],ret[maxn],ans;
ll power(ll a,ll b=mod-2){
	ll s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod; b>>=1;
	} return s;
}
void mul(ll *A,ll *B,ll *C){
	static ll res[maxn]; memset(res,0,sizeof res);
	for(ll i=0;i<=m;i++)
		for(ll j=0;j<=m;j++)
			res[i+j]=(res[i+j]+A[i]*B[j])%mod;
	for(ll i=2*m;i>m;i--){
		for(ll j=m+1;~j;j--)
			res[i-j]=(res[i-j]-res[i]*a[m+1-j]%mod+mod)%mod; 
	}
	for(ll i=0;i<=m+1;i++) C[i]=res[i]%mod;
}
ll solve(){
	memset(f,0,sizeof f);
	memset(g,0,sizeof g);
	memset(a,0,sizeof a);
	memset(F,0,sizeof F);
	memset(ret,0,sizeof ret); ans=0;
	for(ll i=0;i<=m+1;i++) f[i][0]=1;
	for(ll i=m;i;i--){
		for(ll j=1;i*j<=m;j++){
			ll v=1;
			for(ll k=1;k<=j;k++){
				v=v*p%mod;
				f[i][j]=(f[i][j]+(mod+1-p)*v%mod*f[i+1][k-1]%mod*f[i][j-k])%mod;
			}
			f[i][j]=(f[i][j]+f[i+1][j]*v)%mod;
		}
	}
	for(ll i=0;i<=m;i++) a[i]=(mod-f[1][m-i]*(mod+1-p)%mod+mod)%mod;
	a[m+1]=1;
	g[0]=1;
	for(ll i=1;i<=m;i++)
		for(ll j=0;j<i;j++) g[i]=(g[i]+g[j]*f[1][i-j-1]%mod*(mod+1-p))%mod;
	F[1]=1, ret[0]=1;
	ll x=n+1;
	if(m==0) F[0]=mod-a[0], F[1]=0;
	while(x){
		if(x&1) mul(ret,F,ret);
		mul(F,F,F); x>>=1;
	}
	for(ll i=0;i<=m;i++) ans=(ans+g[i]*ret[i])%mod;
	return ans*power(mod+1-p)%mod;
}
int main(){
	scanf("%lld%lld%lld%lld",&n,&m,&x,&y);
	p=x*power(y)%mod;
	ll w1=solve(); --m;
	ll w2=solve();
	printf("%lld",(w1-w2+mod)%mod);
	return 0;
}
```

---

## 作者：Le0Chan (赞：0)

先对结构进行刻画。对于第 $i$ 列上最小的 $j$ 的满足 $(i,j)$ 为危险区域，设 $h_i=j-1$。则每一列上有一个高为 $h_i$ 的柱状物。一些位置上 $h_i=0$，这将原图划分为若干段。
![](https://cdn.luogu.com.cn/upload/image_hosting/kmr8c28h.png)（红圈为一段）

一个可行的矩形的面积即为 $(j-i+1)\min\limits_{k=i}^j h_k$。如果我们要求最大矩形面积恰好为 $K$，就有对于所有 $1\le i\le j\le n$，上式的最大值为 $K$。这个不太好做，可以试着做一下 $dp$，状态数太多，没什么前途。对于“恰好”，一种常用的处理办法是容斥，本题即用最大面积小于等于 $K$ 减去小于等于 $K-1$ 的概率。两种分别计算即可。下面考虑最大面积为 $m$。

考虑 dp。设 $f_n$ 为考虑前 $n$ 列，最大面积不超过 $m$ 的概率。通过上面的段进行转移。为了不算重，钦定每一段最后一定有一个分隔，分隔即 $h_i=0$。最后我们要的就是 $f_{n+1}$。但是由于我们钦定了 $h_{n+1}=0$，所以还要除以 $(1-p)$，即 $\frac{f_{n+1}}{1-p}$。

转移我们枚举最后一段的长度 $i$。由于最大面积小于等于 $m$，所以枚举上界是 $\min(n,m)$。我们对一段的最大面积的描述是长度和 $h$ 的最小值的乘积。所以还需要枚举 $h$ 的最小值 $j$。有 $f_n=\sum\limits_{i=0}^{\min(n,m)}f_{n-i-1}\sum\limits_{j=1}^{\left \lfloor \frac{m}{i} \right \rfloor}g_{i,j}$，第二个和式的上界保证了最大面积小于等于 $m$。

那么 $g_{i,j}$ 的定义也呼之欲出了。$g_{i,j}$ 为长为 $i$ 的段，$h$ 的最小值是 $j$ 的概率。为了不算重，我们依靠从左向右的第一列，满足其 $h$ 为 $j$ 的列标号区分不同段。设 $l$ 为最左侧的列满足 $h_l=j$。则 $(l,j+1)$ 必须为危险区域，$(l,1)\sim (l,j)$ 为安全区域，乘上概率 $(1-p)p^j$。这一列将此段划分为左右两个小段，其中左边这一段的最小值要**大于** $j$，因为定义 $l$ 是最左侧满足他的 $h$ 为 $j$ 的，右边这一段就没有这样的要求，最小值大于等于 $j$ 即可。转移：

$$g_{i,j}=(1-p)p^j\sum\limits_{l=1}^i(\sum\limits_{k=j+1}^mg_{l-1,k})(\sum\limits_{k=j}^m g_{i-l,k})$$

可以发现两个括号内均是后缀和。维护一下可以做到 $O(\min(n,m))$ 转移。由于要求的面积小于等于 $m$，所以有 $ij\le m$，即状态数为 $m\ln m$。求出 $g$ 的时间复杂度为 $O(m^2\log m)$。其实还可以化为卷积形式 ntt 优化，复杂度是 $O(m\log^2m)$，但是这样会比较难写。

回到 $f$ 的计算。设 $a_i=\sum\limits_{j=1}^{\left \lfloor \frac{m}{i} \right \rfloor}g_{i,j}$。则 $f_n=\sum\limits_{i=0}^{\min(n,m)}f_{n-i-1}a_i$。使用常系数齐次线性递推即可。

有个问题是前 $m$ 项并没有给出，需要自己算。暴力算的话就成了 $O(m^2)$ 的复杂度。一种处理方式是将 $f_{m} \gets 1$，即将 $f_{0}$ 向后平移，然后求出 $n+m-1$ 次幂就好。

由于 $m$ 只开到了 $10^3$，使用你喜欢的各种姿势做就行了。用正常的多项式做法可以做到 $O(m\log m\log n)$。

---


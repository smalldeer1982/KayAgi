# [MtOI2019] 埋骨于弘川

## 题目背景

在幻想乡中，冥界的樱花一年又一年地往复开放。

在 Yuyuko 的心中，出现了一棵樱花树，一个与花朵息息相关的序列，和一个伤感的问题。

那些曾经奋斗过的 OIer 们啊，如今又在何方呢？

## 题目描述

在幻想乡，西行寺 幽幽子(Yuyuko)是一个以贪吃著名的亡灵，她拥有操纵死亡的能力。

Yuyuko 通过外界的式神——电脑，对OI进行了深刻的研究 ，她发现了一些惊人的事实：

* OIer 们放弃了太多其他同学们拥有的东西，在题海中寻求自己的梦想。  

* 但是 AFO 的 OIer 们，跟死亡又有什么区别呢？他们或许已经失去了自己的梦想……

这时幽幽子发现，天空中飘舞的樱花组成了两个整数 $n$，$k$。于此同时，在樱花树下，出现了一个函数 $f(x,y)$ 的描述：

$$f(x,y) = \begin{cases} 2 & , x=1 \\ 2^x& , 2\le x \le 42,y = 0 \\ \prod\limits_{i=1}^{42} f(x-i,y)^i & , x \ge 43,y = 0 \\ f(x-1,y)f(x,y-1) & , x\ge 2,y \ge 1\end{cases}$$



幽幽子想让你计算出 $f(n,k) \bmod 998244353$，她认为这个函数象征着OIer们......

## 说明/提示

【样例 $1$ 解释】

根据定义，$f(1,1926)=2$。

【数据范围与约定】

**本题采用捆绑测试。**

Subtask 1 (7 points)：$1\le n,k \le 1000$   
Subtask 2 (11 points)：$1\le n \le 10^{18}$，$k=0$   
Subtask 3 (13 points)：$1\le n \le 10^{18}$，$k=1$   
Subtask 4 (29 points)：$1\le n \le 10^{18}$，$0\le k \le 1000$   
Subtask 5 (40 points)：无特殊限制

对于 $100\%$ 的数据：$1\le n \le 10^{18}$，$0\le k \le 30000$   

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T6

出题人：NaCly_Fish 

验题人：Imagine 

题面：disangan233

**此题稍有卡常，请注意优化代码常数。**

## 样例 #1

### 输入

```
1 1926```

### 输出

```
2```

## 样例 #2

### 输入

```
23 3```

### 输出

```
509581943```

## 样例 #3

### 输入

```
1919 810```

### 输出

```
252250482```

# 题解

## 作者：NaCly_Fish (赞：22)

upd：之前式子有一点锅，现已修复。

这其实是一个很水的套路题。。

首先容易看出来 $f(x,0)$ 是个线性递推的形式，要求的是其 $k$ 阶前缀积。  
要求乘积不太好搞，可以对 $2$ 取一下对数，化乘为加。  

于是问题转化为：

一个数列 $a$：
$$a_n=n\space(n\le42)$$  
$$a_n=\sum\limits_{i=1}^{42}ia_{n-i}\space(n\ge 43)$$
求它 $k$ 阶前缀和的第 $n$ 项。
****
关于线性递推式的高阶前缀和有一个优美的性质。

设数列 $a$ 的递推系数为 $f$，那么在 $f$ 前面加个 $-1$ ，然后做 $k$ 阶差分得到的序列即 $a$ 的 $k$ 阶前缀和的递推式。( 当然要在后面扩展 $k$ 项，同时最后去掉 $-1$ )

在此简短证明一下，设：  
$$a_n=\sum\limits_{i=1}^kf_ia_{n-i}$$
$$b_n=\sum\limits_{i=1}^na_i$$
$$b_n=b_{n-1}+a_n=b_{n-1}+\sum\limits_{i=1}^kf_ia_{n-i}$$
$$= b_{n-1}+\sum\limits_{i=1}^kf_i(b_{n-i}-b_{n-i-1})$$
后面的那个求和展开，可以得到很多形如 $(f_i-f_{i-1})b_{n-i}$ 的式子，这就是一个很明显的差分形式，接下来的证明就很容易了。

得到 $k$ 阶前缀和的递推式后，把 $a$ 的 $k$ 阶前缀和的前几项也求出来，然后直接上线性递推板子即可。

不过要注意的是我们刚才取了个 $\log$，所以以上运算都要对 $\color{red} 998244352$ 取模，这需要用到任意模数。$7$ 次 FFT 的做法常数过大，不能通过；需要使用 $4$ 次 FFT 的做法。

还有就是模数不是素数时，算组合数很麻烦，所以直接用倍增多项式快速幂计算高阶差分或前缀和即可。

时间复杂度 $\Theta(k\log^2 k+k\log k\log n)$。

std:
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#define N 65539
#define ll long long
#define reg register
#define p 998244352
#define pi 3.141592653589793
using namespace std;

struct complex{
    double x,y;
    inline complex(double x=0,double y=0):x(x),y(y){}
    
    inline complex operator + (const complex& b) const{ return complex(x+b.x,y+b.y); }
    inline complex operator - (const complex& b) const{ return complex(x-b.x,y-b.y); }
    inline complex operator * (const complex& b) const{ return complex(x*b.x-y*b.y,x*b.y+y*b.x); }
    inline complex operator / (const int& b) const{ return complex(x/b,y/b); }
    inline complex operator ~ () const{ return complex(x,-y); }
}rt[N];

struct matrix{
    int a[43][43];
    int siz;
    inline matrix(int _siz=0):siz(_siz){ memset(a,0,sizeof(a)); }
    
    inline matrix operator * (const matrix& b) const{
        matrix res = matrix(siz);
        for(reg int i=0;i!=siz;++i)
        for(reg int j=0;j!=siz;++j)
        for(reg int k=0;k!=siz;++k)
            res.a[i][j] = (res.a[i][j]+(ll)a[i][k]*b.a[k][j])%p;
        return res;    
    }
};

inline matrix mat_pow(matrix a,ll t){
    matrix res = matrix(a.siz);
    for(reg int i=0;i!=a.siz;++i) res.a[i][i] = 1;
    while(1){
        if(t&1) res = res*a;
        t >>= 1;
        if(t==0) break;
        a = a*a;
    }
    return res;
}

int rev[N];
int siz;

inline int add(int a,int b){ return a+b>=p?a+b-p:a+b; }
inline int dec(int a,int b){ return a<b?a-b+p:a-b; }
inline int getlen(int n){ return 1<<(32-__builtin_clz(n)); }

inline void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    rt[lim>>1] = complex(1,0);
    for(reg int i=1;i!=(lim>>1);++i) rt[i+(lim>>1)] = complex(cos(pi*2/lim*i),sin(pi*2/lim*i));
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void dft(complex *f,int lim){
    static complex a[N];
    int shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        complex x = a[j|k|mid]*rt[mid|k];
        a[j|k|mid] = a[j|k]-x;
        a[j|k] = a[j|k]+x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i];
}

inline void idft(complex *f,int lim){
    reverse(f+1,f+lim);
    dft(f,lim);
    for(reg int i=0;i!=lim;++i) f[i] = f[i]/lim;
}

inline void multiply(const int *A,const int *B,int n,int m,int *R,int len,bool flag){
    static complex f[N],g[N],h[N],q[N];
    complex t,f0,f1,g0,g1;
    ll x,y,z;
    int lim = getlen(n+m);
    for(reg int i=0;i!=lim;++i){
        f[i] = complex(A[i]>>15,A[i]&32767);
        g[i] = complex(B[i]>>15,B[i]&32767);
    }
    dft(f,lim);
    if(flag) for(reg int i=0;i!=lim;++i) g[i] = f[i];
    else dft(g,lim);
    for(reg int i=0;i!=lim;++i){
        t = ~f[i?lim-i:0];
        f0 = (f[i]-t)*complex(0,-0.5),f1 = (f[i]+t)*0.5;
        t = ~g[i?lim-i:0];
        g0 = (g[i]-t)*complex(0,-0.5),g1 = (g[i]+t)*0.5;
        h[i] = f1*g1;
        q[i] = f1*g0 + f0*g1 + f0*g0*complex(0,1);
    }
    idft(h,lim),idft(q,lim);
    for(reg int i=0;i<=len;++i){
        x = (ll)(h[i].x+0.5)%p<<30;
        y = (ll)(q[i].x+0.5)<<15;
        z = q[i].y+0.5;
        R[i] = (x+y+z)%p;
    }
    memset(R+len+1,0,(lim-len)<<2);
}

inline void inverse(const int *f,int n,int *R){ 
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int top = 0,lim =1 ;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        multiply(h,g,n,n>>1,h,n,false);
        multiply(h,g,n,n>>1,h,n,false);
        for(reg int i=(n>>1);i<=n;++i) g[i] = dec(add(g[i],g[i]),h[i]);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void divide(const int *f,const int *ig,int n,int m,int *R){
    static int A[N],B[N];
    memcpy(A,f,(n+1)<<2),memcpy(B,ig,(m+1)<<2);
    reverse(A,A+n+1);
    int tt = n-m,lim = getlen((n-m)<<1);
    memset(A+tt+1,0,(lim-tt)<<2);
    for(reg int i=min(m,tt)+1;i!=lim;++i) B[i] = 0;
    multiply(A,B,tt,tt,R,n-m,false);
    reverse(R,R+tt+1);
}

inline void mod(const int *f,const int *g,const int *ig,int n,int m,int *R){
    if(n<m) return;
    static int A[N],B[N];
    memcpy(B,f,(n+1)<<2);
    int lim = getlen(n);
	divide(f,ig,n,m,R);
	memcpy(A,g,(m+1)<<2);
	memset(A+m+1,0,(lim-m+2)<<2);
	memset(R+n-m+1,0,(lim-n+m+1)<<2);
	multiply(A,R,m,n-m,R,m-1,false);
	for(reg int i=0;i!=m;++i) R[i] = dec(B[i],R[i]);
}

void mod_power(const int *G,int k,ll t,int *R){
    int f[N],g[N],ig[N];
    memset(f,0,sizeof(f));
    memset(g,0,sizeof(g));
    memset(ig,0,sizeof(ig));
    memcpy(ig,G,(k+1)<<2);
    reverse(ig,ig+k+1);
    inverse(ig,k,ig);
    int n = 1,m = 0;
    f[1] = g[0] = 1;
    while(1){
        if(t&1){
            multiply(f,g,n,m,g,n+m,false);
            mod(g,G,ig,n+m,k,g);
            m = min(n+m,k-1);
        }
        t >>= 1;
        if(t==0) break;
        multiply(f,f,n,n,f,n<<1,true);
        mod(f,G,ig,n<<1,k,f);
        n = min(n<<1,k-1);
    }
    memcpy(R,g,k<<2);
}

void poly_pow(const int *f,int n,int k,int *R){
    static int g[N],h[N];
    memset(g,0,sizeof(g)),memset(h,0,sizeof(h));
    memcpy(g,f,(n+1)<<2);
    h[0] = 1;
    int m = 0;
    while(1){
        if(k&1){
            multiply(h,g,n,m,h,n+m,false);
            m += n;
        }
        k >>= 1;
        if(k==0) break;
        multiply(g,g,n,n,g,n<<1,true);
        n <<= 1;
    }
    memcpy(R,h,(m+1)<<2);
}

inline int poww(int a,int t,int m){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%m;
        a = (ll)a*a%m;
        t >>= 1;
    }
    return res;
}

int k,lim;
int a[N],f[N],c[N],F[N],G[N];
ll n;

int special(){
    if(k==1){
        for(int i=1;i<=42;++i) a[42] += a[42-i]*i;
        for(int i=1;i<=42;++i) a[i] = add(a[i],a[i-1]);
        for(int i=43;i;--i) f[i] = dec(f[i],f[i-1]);
    }
    int siz = 42+k;
    matrix A = matrix(siz);
    for(reg int i=0;i!=siz;++i) A.a[i][0] = f[i+1];
    for(reg int i=1;i!=siz;++i) A.a[i-1][i] = 1;
    A = mat_pow(A,n-1);
    int res = 0;
    for(reg int i=0;i!=siz;++i) res = (res+(ll)a[siz-1-i]*A.a[i][siz-1])%p;
    return poww(2,res,p+1);
}

int main(){
    int ans = 0;
    scanf("%lld%d",&n,&k);
    if(n==1){
    	putchar('2');
    	return 0;
	}
    f[0] = p-1;
    for(reg int i=1;i<=42;++i) a[i-1] = f[i] = i;
    if(k<=1){
        printf("%d",special());
        return 0;
    }
    init((k+42)<<1);
    c[0] = 1,c[1] = p-1;
    poly_pow(c,1,k,c);
    lim = k+42; 
    for(reg int i=0;i<=42;++i)
    for(reg int j=0;j<=k;++j)
        G[i+j] = (G[i+j]+(ll)f[i]*c[j])%p;
    inverse(c,lim-1,c);
    for(reg int i=42;i!=lim;++i)
    for(reg int j=1;j<=42;++j)
        a[i] = (a[i]+(ll)a[i-j]*j)%p; 
    multiply(a,c,lim-1,lim-1,a,lim-1,false); 
    reverse(G,G+lim+1);
    for(reg int i=0;i<=lim;++i) G[i] = G[i]?p-G[i]:0;
    mod_power(G,lim,n-1,F);
    for(reg int i=0;i!=lim;++i) ans = (ans+(ll)F[i]*a[i])%p;   
    printf("%d",poww(2,ans,p+1));
    return 0;
}
```
ps：其实可以做到 $\Theta(k\log k + \log n)$，需要带个几百倍的常数，这里就不写了（逃

---

## 作者：Elegia (赞：15)

如何不进行多项式求逆：

已知递推多项式为 $R(x)=(1-\sum_{j=1}^{42} jx^j)(1-x)^k$，我们只需算出 $(1-x)^k$ 的表达式然后与前式暴力卷积。

计算中还需要 $\frac1R$，只需注意到 $\frac 1{(1-x)^k} = \sum \binom{n+k-1}{k-1} x^n$，我们还是需要算出组合数。然后暴力除以一个短多项式依然是容易的。

注意到 $998244352 = 2^{23} \times 7\times 17$，通常大家使用的 exLucas 计算时不够迅速，尤其是 $\bmod 2^{23}$ 这一部分。

但是这里的瓶颈是多组询问，我们预处理前缀奇数积与其逆元即可。单次计算的复杂度即可降低至 $\Theta(\log k)$。

code:

```cpp
#include <cstdio>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cctype>

#include <algorithm>
#include <random>
#include <bitset>
#include <queue>
#include <functional>
#include <set>
#include <map>
#include <vector>
#include <chrono>
#include <iostream>
#include <limits>
#include <numeric>

#define LOG(FMT...) fprintf(stderr, FMT)

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

struct Cd {
  double re, im;

  Cd(double re = 0, double im = 0) : re(re), im(im) {}

  inline double real() const { return re; }
  inline double imag() const { return im; }

  inline void real(double re) { this->re = re; }
  inline void imag(double im) { this->im = im; }

  inline Cd operator+(const Cd& rhs) const { return Cd(re + rhs.re, im + rhs.im); }
  inline Cd operator-(const Cd& rhs) const { return Cd(re - rhs.re, im - rhs.im); }
  inline Cd operator-() const { return Cd(-re, -im); }
  inline Cd operator*(const Cd& rhs) const { return Cd(re * rhs.re - im * rhs.im, re * rhs.im + im * rhs.re); }

  inline void operator+=(const Cd& rhs) { re += rhs.re; im += rhs.im; }
  inline void operator/=(double x) { re /= x; im /= x; }

  inline friend Cd conj(const Cd& z) { return Cd(z.re, -z.im); }
};

//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int L = 16, N = 1 << L, B = 1 << 15, Q = 998244353, P = 499122176;
const double PI = acos(-1);

struct ExLucas {

  int inv2[1 << 22], prd[1 << 22];

  void exGcd(int a, int b, int& x, int& y) {
    if (!b) {
      x = 1;
      y = 0;
      return;
    }
    exGcd(b, a % b, y, x);
    y -= a / b * x;
  }

  int inv(int a, int m) {
    int x, y;
    exGcd(a, m, x, y);
    if (x < 0)
      x += m;
    return x;
  }

  int crt(const vector<pair<int, int>>& group) {
    int m = 1, r = 0;
    for (const auto& pr : group) {
      int m1, r1;
      tie(m1, r1) = pr;
      int mm = m * m1, i, i1;
      i = m * (ll)inv(m, m1) % mm;
      i1 = m1 * (ll)inv(m1, m) % mm;
      r = (r * (ll)i1 + r1 * (ll)i) % mm;
      m = mm;
    }
    return r;
  }

  vector<pair<int, int>> factorize(int m) {
    vector<pair<int, int>> ret;
    for (int x = 2; x * x <= m; ++x)
      if (m % x == 0) {
        int c = 0;
        while (m % x == 0) {
          m /= x;
          ++c;
        }
        ret.emplace_back(x, c);
      }
    if (m != 1)
      ret.emplace_back(m, 1);
    return ret;
  };

  int mpow(int x, ll k, int m) {
    int ret = 1;
    while (k) {
      if (k & 1)
        ret = ret * (ll)x % m;
      x = x * (ll)x % m;
      k >>= 1;
    }
    return ret;
  }

  int binom2(int n, int m, int k) {
    int p = 2, pk = 1 << k, ret = 1;
    ll coe0 = 0;
    function<void(ll, int)> apply = [&](ll n, int sign) {
      while (n) {
        ret = (ret * (ll)(sign == 1 ? prd[(n + 1) / 2] : inv2[(n + 1) / 2])) & ((1 << 22) - 1);
        coe0 += sign * (n >>= 1);
      }
    };
    apply(n, 1);
    apply(m, -1);
    apply(n - m, -1);
    if (coe0 >= 22) return 0;
    ret = ((ll)ret << coe0) & ((1 << 22) - 1);
    return ret;
  }

  int binom(ll n, ll m, int p, int k) {
    int pk = 1;
    for (int rep = 0; rep < k; ++rep)
      pk *= p;
    vector<ll> coe(pk);
    function<void(ll, int)> apply = [&](ll n, int sign) {
      while (n) {
        for (int i = 1; i < pk && i <= n; ++i)
          if (i % p)
            coe[i] += sign * ((n - i) / pk + 1);
        coe[0] += sign * (n /= p);
      }
    };
    apply(n, 1);
    apply(m, -1);
    apply(n - m, -1);
    if (coe[0] >= k) return 0;
    int ret = mpow(p, coe[0], pk);
    for (int i = 1; i < pk; ++i)
      if (coe[i] >= 0)
        ret = ret * (ll)mpow(i, coe[i], pk) % pk;
      else
        ret = ret * (ll)mpow(i, pk / p * (p - 1) + coe[i], pk) % pk;
    return ret;
  }

  int mod;
  vector<pair<int, int>> factors;

  ExLucas(int mod) : mod(mod), factors(factorize(mod)) {
    const int M = 1 << 22;
    prd[0] = 1;
    for (int i = 1; i < (1 << 22); ++i)
      prd[i] = (prd[i - 1] * (ll)(i * 2 - 1)) & (M - 1);
    inv2[(1 << 22) - 1] = inv(prd[(1 << 22) - 1], M);
    for (int i = (1 << 22) - 2; i >= 0; --i)
      inv2[i] = (inv2[i + 1] * (ll)(i * 2 + 1)) & (M - 1);
  }

  int get(int n, int m) {
    vector<pair<int, int>> remainder;
    remainder.reserve(factors.size());
    for (const auto& factor: factors) {
      int p, k;
      tie(p, k) = factor;
      int pk = 1;
      for (int rep = 0; rep < k; ++rep)
        pk *= p;
      remainder.emplace_back(pk, p == 2 ? binom2(n, m, k) : binom(n, m, p, k));
    }
    return crt(remainder);
  }

} binomP(P);

int k, lgk;
int brev[N], irec[N], rec[N], f[N], a[N];
Cd w[N];

int mpow(int x, int k, int P) {
  int ret = 1;
  while (k) {
    if (k & 1)
      ret = ret * (ll)x % P;
    x = x * (ll)x % P;
    k >>= 1;
  }
  return ret;
}

int norm(int x) { return x >= P ? (x - P) : x; }

void add(int& x, int y) {
  if ((x += y) >= P) x -= P;
}

void sub(int& x, int y) {
  if ((x -= y) < 0) x += P;
}

void preparefft(int lgn) {
  for (int i = 1; i < (1 << lgn); ++i) brev[i] = (brev[i >> 1] >> 1) | ((i & 1) << (lgn - 1));
  for (int i = 0; i < (1 << lgn); ++i)
    w[i] = Cd(cos(2 * PI * i / (1 << lgn)), sin(2 * PI * i / (1 << lgn)));
}

void fft(Cd* a, int lgn, int sgn) {
  int n = 1 << lgn;
  int k = L;
  for (int i = 0; i < n; ++i) {
    int brv = brev[i] >> (L - lgn);
    if (brv > i)
      swap(a[i], a[brv]);
  }
  for (int t = 1; t < n; t <<= 1) {
    --k;
    for (int i = 0; i < n; i += t << 1) {
      Cd *p = a + i, *q = a + i + t;
      for (int j = 0; j < t; ++j) {
        Cd x = w[j << k] * q[j];
        q[j] = p[j] - x;
        p[j] += x;
      }
    }
  }
  if (sgn == -1) {
    reverse(a + 1, a + n);
    for (int i = 0; i < n; ++i) a[i] /= n;
  }
}

void dft(Cd* a, Cd* b, int lgn, int d) {
  int n = 1 << lgn;
  for (int i = 0; i < n; ++i) a[i].imag(b[i].real());
  fft(a, lgn, d);
  b[0] = conj(a[0]);
  for (int i = 1; i < n; ++i) b[i] = conj(a[n - i]);

  for (int i = 0; i < n; ++i) {
    Cd x = a[i], y = b[i];
    a[i] = (x + y) * 0.5;
    b[i] = (x - y) * Cd(0, -0.5);
  }
}

typedef Cd DFT[2][N];

void tDFT(int* a, int lgn, DFT& va) {
  for (int i = 0; i < 2; ++i)
    memset(va[i], 0, sizeof(Cd) << lgn);
  for (int i = 0; i < (1 << (lgn - 1)); ++i) {
    va[0][i].real(a[i] & (B - 1));
    va[1][i].real(a[i] >> 15);
  }
  dft(va[0], va[1], lgn, 1);
}

void mult(int* a, int lgk, DFT& vb, int* c) {
  static DFT va;
  static Cd vc[3][N];

  tDFT(a, lgk + 1, va);

  for (int bi = 0; bi <= 2; ++bi)
    memset(vc[bi], 0, sizeof(Cd) << (lgk + 1));
  for (int bi = 0; bi < 2; ++bi)
    for (int bj = 0; bj < 2; ++bj)
      for (int i = 0; i < (1 << (lgk + 1)); ++i) vc[bi + bj][i] += va[bi][i] * vb[bj][i];
  memset(c, 0, sizeof(int) << (lgk + 1));
  for (int bi = 2; bi >= 0; --bi) {
    fft(vc[bi], lgk + 1, -1);
    for (int i = 0; i < (1 << (lgk + 1)); ++i) c[i] = (((ll)c[i] << 15) + ll(vc[bi][i].real() + 0.5)) % P;
  }
}

void sqr(int* a, int n) {
  static Cd va[2][N], vc[3][N];

  int lgn = 0;
  while ((1 << lgn) <= n * 2) ++lgn;

  for (int i = 0; i < 2; ++i)
    memset(va[i], 0, sizeof(Cd) << lgn);
  for (int i = 0; i <= n; ++i) {
    va[0][i].real(a[i] & (B - 1));
    va[1][i].real(a[i] >> 15);
  }
  dft(va[0], va[1], lgn, 1);

  for (int bi = 0; bi <= 2; ++bi)
    memset(vc[bi], 0, sizeof(Cd) << lgn);
  for (int bi = 0; bi < 2; ++bi)
    for (int bj = 0; bj < 2; ++bj)
      for (int i = 0; i < (1 << lgn); ++i) vc[bi + bj][i] += va[bi][i] * va[bj][i];
  memset(a, 0, sizeof(int) * (n * 2 + 1));
  for (int bi = 2; bi >= 0; --bi) {
    fft(vc[bi], lgn, -1);
    for (int i = 0; i <= n * 2; ++i) a[i] = (((ll)a[i] << 15) + ll(vc[bi][i].real() + 0.5)) % P;
  }
}

DFT irecf, recf;

void div(int* a) {
  static int b[N];

  int m = k * 2 + 85;

  for (int i = k + 42; i <= m; ++i)
    b[m - i] = a[i];
  mult(b, lgk - 1, irecf, b);

  reverse(b, b + k + 43 + 1);
  for (int i = k + 44; i < (1 << lgk); ++i) b[i] = 0;

  mult(b, lgk - 1, recf, b);
  for (int i = 0; i <= m; ++i)
    sub(a[i], b[i]);

}

int solve(ll n) {
  n += k;

  while ((1 << lgk) <= k * 2 + 85) ++lgk;

  tDFT(rec, lgk, recf);
  tDFT(irec, lgk, irecf);

  a[0] = 1;
  int lgn = 0;
  while ((1LL << (lgn + 1)) <= n) ++lgn;
  while (lgn >= 0) {
    sqr(a, k + 42);
    if ((n >> lgn) & 1) {
      for (int i = k * 2 + 85; i; --i)
        a[i] = a[i - 1];
      a[0] = 0;
    }
    div(a);

    --lgn;
  }

  int ret = 0;
  for (int i = 0; i <= 42; ++i)
    ret = (ret + f[i] * (ll)a[i + k]) % P;
  return ret;
}

int main() {
#ifdef LBT
  freopen("test.in", "r", stdin);
  int nol_cl = clock();
#endif

  preparefft(L);
  ll n;
  scanf("%lld%d", &n, &k);
  if (k) {
    for (int i = 0; i <= k + 42; ++i)
      irec[i] = binomP.get(i + k - 1, k - 1);
  } else
    irec[0] = 1;
  for (int i = 1; i <= k + 42; ++i)
    for (int j = 1; j <= min(i, 42); ++j)
      irec[i] = (irec[i] + irec[i - j] * (ll)j) % P;
  for (int i = 0; i <= k; ++i)
    rec[i] = (i & 1) ? (P - binomP.get(k, i)) : binomP.get(k, i);
  for (int i = k + 42; i; --i)
    for (int j = 1; j <= min(i, 42); ++j)
      rec[i] = (rec[i] + (P - rec[i - j]) * (ll)j) % P;
  reverse(rec, rec + k + 42 + 1);
  for (int i = 0; i <= 42; ++i)
    f[i] = i + 1;
  for (int rep = 0; rep < k; ++rep) {
    for (int i = 1; i <= 42; ++i)
      add(f[i], f[i - 1]);
  }
  printf("%d\n", mpow(2, solve(n - 1), Q));

#ifdef LBT
  LOG("Time: %dms\n", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000));
#endif
  return 0;
}
```

---


# [蓝桥杯 2020 国 A] 蓝跳跳

## 题目描述

小蓝制作了一个机器人，取名为蓝跳跳，因为这个机器人走路的时候基本靠跳跃。

蓝跳跳可以跳着走，也可以掉头。蓝跳跳每步跳的距离都必须是整数，每步可以跳不超过 $k$ 的长度。由于蓝跳跳的平衡性设计得不太好，如果连续两次都是跳跃，而且两次跳跃的距离都至少是 $p$，则蓝跳跳会摔倒，这是小蓝不愿意看到的。

小蓝接到一个特别的任务，要在一个长为 $L$ 舞台上展示蓝跳跳。小蓝要控制蓝跳跳从舞台的左边走到右边，然后掉头，然后从右边走到左边，然后掉头，然后再从左边走到右边，然后掉头，再从右边走到左边，然后掉头，如此往复。

为了让观者不至于太无趣，小蓝决定让蓝跳跳每次用不同的方式来走。小蓝将蓝跳跳每一步跳的距离记录下来，按顺序排成一列，显然这一列数每个都不超过 $k$ 且和是 $L$。这样走一趟就会出来一列数。如果两列数的长度不同，或者两列数中存在一个位置数值不同，就认为是不同的方案。

请问蓝跳跳在不摔倒的前提下，有多少种不同的方案从舞台一边走到另一边。

## 说明/提示

**【样例说明】**

蓝跳跳有以下 9 种跳法:

1. $1+1+1+1+1$

2. $1+1+1+2$

3. $1+1+2+1$

4. $1+2+1+1$

5. $2+1+1+1$

6. $2+1+2$

7. $1+1+3$

8. $1+3+1$

9. $3+1+1$

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例, $1 \leq p \leq k \leq 50,1 \leq L \leq 1000$ 。

对于 $60 \%$ 的评测用例, $1 \leq p \leq k \leq 50,1 \leq L \leq 10^{9}$ 。

对于 $80 \%$ 的评测用例, $1 \leq p \leq k \leq 200,1 \leq L \leq 10^{18}$ 。

对于所有评测用例, $1 \leq p \leq k \leq 1000,1 \leq L \leq 10^{18}$ 。

蓝桥杯 2020 年国赛 A 组 J 题。

## 样例 #1

### 输入

```
3 2 5```

### 输出

```
9```

## 样例 #2

### 输入

```
5 3 10```

### 输出

```
397```

# 题解

## 作者：joke3579 (赞：11)

## 1. $1\le k,p \le 50,\ 1\le l\le 10^{3}$

考虑直接 dp。

设 $f({i,j})$ 为当前整数大小为 $i$，最后一项为 $j$ 的序列的计数。
容易写出转移：
$$f({i,j}) = \left\{
    \begin{aligned}
    \sum_{t=1}^{k}f({i-j,t}) \qquad j < p \\
    \sum_{t=1}^{p-1}f({i-j,t}) \qquad j\ge p
    \end{aligned}
\right.$$

直接转移即可做到 $O(kpl)$，答案即为 $\sum_{i=1}^k f({l,i})$。    
[Submission](https://www.luogu.com.cn/record/93608620).

进行状态的压缩。我们发现 $j$ 这一维实际上只记录了 $j< p$ 的情况和 $j\ge p$ 的情况，这可以在转移时完成。然后就可以把这两种状态压缩：  
设 $f({i,0/1})$ 为当前整数大小为 $i$，最后一项是否小于 $p$ 的序列的计数。有转移：
$$f({i,0}) = \sum_{j=1}^{p-1} f({i-j,0}) + f({i-j,1})\qquad f({i,1}) = \sum_{j=p}^{k} f({i-j,0})$$

答案即为 $f({l,0}) + f({l,1})$。直接转移即可做到 $O(kl)$。    
[Submission](https://www.luogu.com.cn/record/102784752).

## 2. $1\le k,p \le 50,\ 1\le l\le 10^{18}$

可以发现，如上 $O(kl)$ 的转移是线性的，可以写成矩阵乘法的形式。具体地，我们使用  $2k\times 2k$ 的矩阵进行转移，初始向量记录 $1\sim k$ 段内所有 $f({i,0})$ 与 $f({i,1})$。

例如，当 $k=5, p=3$ 时矩阵即为：

$$\begin{bmatrix} f({i+1,1})\\ f({i+1,0})\\ f({i,1})\\ f({i,0})\\ f({i-1,1})\\ f({i-1,0})\\ f({i-2,1})\\ f({i-2,0})\\ f({i-3,1})\\ f({i-3,0})\\ \end{bmatrix}= \begin{bmatrix} 0 & 0 & 0 & 0 & 0 &1 & 0 & 1 & 0 & 1\\ 1 & 1 & 1 & 1 & 0 &0 & 0 & 0 & 0 & 0\\ 1 & 0 & 0 & 0 & 0 &0 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 0 &0 & 0 & 0 & 0 & 0\\ 0 & 0 & 1 & 0 & 0 &0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 1 & 0 &0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 1 &0 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 &1 & 0 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 &0 & 1 & 0 & 0 & 0\\ 0 & 0 & 0 & 0 & 0 &0 & 0 & 1 & 0 & 0\\ \end{bmatrix} \begin{bmatrix} f({i,1})\\ f({i,0})\\ f({i-1,1})\\ f({i-1,0})\\ f({i-2,1})\\ f({i-2,0})\\ f({i-3,1})\\ f({i-3,0})\\ f({i-4,1})\\ f({i-4,0})\\ \end{bmatrix}$$

转移即可。总时间复杂度 $O(8k^3\log l)$。     
[Submission](https://www.luogu.com.cn/record/93795849).

## 3. $1\le k,p \le 1000,\ 1\le l\le 10^{18}$

你看这个转移矩阵是不是和线性递推的很像？

考虑设 $g({i}) = f({i,0}) + f({i,1})$。
我们可以写
$$g(i) = \sum_{j=1}^{p-1}\left( f({i-j,0}) + f({i-j,1})\right) + \sum_{j=p}^{k} f({i-j,0}) = \sum_{j=1}^{p-1} g({i-j}) + \sum_{j=p}^{k} f({i-j,0}) $$
前面那部分可以直接扔进线性递推转移。   
对于后半部分，考虑在最后一步 $i \ge p$ 时，仅有倒数第二步 $j < p$ 的状态能够全部转移。同时，考虑这里的贡献在 $j < p$ 时已经被算了，我们只需要 $\ge p$ 的 $j$。算一下有多少个 $j$ 满足条件，这就是 $f(i)$ 对应的系数。  
这里由于需要让所有贡献都被算完，线性递推的长度是 $k + p - 1$ 的。

转移时直接模拟多项式乘法即可，总复杂度为 $O(k^2 \log l)$。[Submission](https://www.luogu.com.cn/record/93802758).   
应用任意模数多项式乘法即可做到 $O(k\log k\log n)$。

可能 80% 的部分分是给数组开小的正解准备的。[Submission](https://www.luogu.com.cn/record/93802691).

```cpp
#include <bits/stdc++.h>
using namespace std; using pii = pair<int,int>;
using ll = long long; using ull = unsigned long long; using db = double; using ld = long double; using lll = __int128_t;
template<typename T> void get(T & x) {
	x = 0; char ch = getchar(); bool f = false; while (ch < '0' or ch > '9') f = f or ch == '-', ch = getchar();
	while ('0' <= ch and ch <= '9') x = (x << 1) + (x << 3) + ch - '0', ch = getchar(); f && (x = -x); 
} template <typename T, typename ... Args> void get(T & a, Args & ... b) { get(a); get(b...); }
#define rep(i,s,t) for (register int i = (s), i#_ = (t) + 1; i < i#_; ++ i)
#define pre(i,s,t) for (register int i = (s), i#_ = (t) - 1; i > i#_; -- i)
const int N = 4e3 + 10;

const int mod = 20201114;
template <typename T1, typename T2> T1 add(T1 a, T2 b) { return (a += b) >= mod ? a - mod : a; }template <typename T1, typename ...Args> T1 add(T1 a, Args ... b) { return add(a, add(b...)); }
struct FastMod { int m; ll b; void init(int _m) { m = _m; b = ((lll)1<<64) / m; } FastMod(int _m) { init(_m); } int operator() (ll a) {ll q = ((lll)a * b) >> 64; a -= q * m; if (a >= m) a -= m; return a; } } Mod(mod);
int mul(int a, int b) { return Mod(1ll * a * b); } template <typename ...Args> int mul(int a, Args ...b) { return mul(a, mul(b...)); }

int k, mx, p, sum[N][2], ans;
int f[N], h[N];
ll l;

struct seq {
	int a[N];
	int & operator [] (const int & p) { return a[p]; }
	const int operator [] (const int & p) const { return a[p]; }
	seq operator * (const seq & b) const {
		seq ret; rep(i,0,mx-1) ret[i] = 0;
		rep(i,0,mx-1) rep(j,0,mx-1) ret[i + j] = add(ret[i + j], mul(a[i], b[j]));
		for (int i = (mx-1) << 1; i >= mx; ret[i] = 0, -- i) rep(j,1,mx) 
			ret[i - j] = add(ret[i - j], mul(ret[i], f[j]));
		return ret;
	}
} res;

seq qp(seq a, ll b) {
	seq ret; memset(ret.a, 0, sizeof ret.a); ret[0] = 1;
	while (b) {
		if (b & 1) ret = ret * a;
		a = a * a;
		b >>= 1;
	} return ret;
}

int main() {
	get(k, p, l); mx = k + p - 1; -- l;
	sum[0][0] = 1;
	rep(i,1,mx) {
		rep(j,1,min(p - 1, i)) {
			sum[i][0] = add(sum[i][0], sum[i - j][0], sum[i - j][1]);
		}
		rep(j,p,min(k, i)) {
			sum[i][1] = (sum[i][1] + sum[i - j][0]) % mod;
		}
	} 
	
	rep(i,1,p-1) f[i] = 1;
	rep(i,p,k+p-1) rep(j,p,k) if (0 < i - j and i - j < p) ++ f[i];
	rep(i,0,k+p-1) h[i] = add(sum[i + 1][0], sum[i + 1][1]);

	if (l <= mx) {
		cout << h[l] << endl;
		return 0;
	}

	res[1] = 1; ans = 0;
	res = qp(res, l);
	rep(i,0,mx - 1) ans = add(ans, mul(res[i], h[i]));
	cout << ans << endl;
}
```

---

## 作者：warzone (赞：4)

设 $f_n$ 为走过 $n$ 的长度，且最后一步的操作不是至少为 $p$ 的距离的跳跃的方案数，  
$g_n$ 为走过 $n$ 的长度，且最后一步的操作是至少为 $p$ 的距离的跳跃的方案数。又设

$$
f(x)=\sum_{n=0}^{+\infty}f_nx^n,g(x)=\sum_{n=0}^{+\infty}g_nx^n
$$

则

$$
f(x)=\sum_{i=1}^{p-1}x^i(f(x)+g(x))+1\\
g(x)=\sum_{i=p}^kx^if(x)
$$

运用等比数列求和，也即

$$
f(x)=\dfrac{x-x^p}{1-x}(f(x)+g(x))+1\\
g(x)=\dfrac{x^p-x^{k+1}}{1-x}f(x)
$$

设 $h(x)=f(x)+g(x)$，答案即 $h_{L}$，且

$$
h(x)=f(x)+g(x)=\left(1+\dfrac{x^p-x^{k+1}}{1-x}\right)f(x)=\left(1+\dfrac{x^p-x^{k+1}}{1-x}\right)\left(\dfrac{x-x^p}{1-x}(f(x)+g(x))+1\right)\\
h(x)=\left(1+\dfrac{x^p-x^{k+1}}{1-x}\right)\left(\dfrac{x-x^p}{1-x}h(x)+1\right)
$$

解得

$$
h(x)=\dfrac{1-2x+x^2+x^p-x^{p+1}-x^{k+1}+x^{k+2}}{1-3x+2x^2+x^p-2x^{p+1}+x^{k+2}+x^{2p}-x^{p+k+1}}
$$

可见，$h(x)$ 为有理函数，说明其为常系数齐次线性递推数列。  
设其分子为 $P(x)$，分母为 $Q(x)$，则其递推式为

$$
h_n=P_n-\sum_{i=1}^{\min(p+k+1,n)}Q_ih_{n-i}
$$

对于本题，$p+k\le 2000,\Theta((p+k)^2)$ 求出 $h_0,h_1,\cdots,h_{p+k}$ 后，  
暴力多项式除法+快速幂 即可 $\Theta((p+k)^2\log L)$ 求得答案 $h_L$。

---

## 作者：永无岛 (赞：3)

设 $f_{n}$ 为最后一步长度小于 $k$ 的，总长度为 $n$ 的方案数；设 $g_{n}$ 为最后一步长度大于等于 $k$ 的，总长度为 $n$ 的方案数。那么有：
$$
\begin{aligned}
&f_{n}=\sum_{i=1}^{k-1}f_{n-i}+g_{n-i}\\
&g_{n}=\sum_{i=k}^{p}f_{n-i}
\end{aligned}
$$
我们要求的就是 $f_{L}+g_{L}$。

下面的式子带入上面的式子：
$$
\begin{aligned}
f_{n}=\sum_{i=1}^{k-1}(f_{n-i}+\sum _{j=k}^{p}g_{n-i-j})\\
\end{aligned}
$$
显然 $f$ 满足 $k+p$ 阶线性递推。至于 $g$，可以用递推式分解成 $O(p)$ 个 $f$，这样套用[常系数线性齐次递推的模板](https://www.luogu.com.cn/problem/P4723),就有了一个 $O(p(p+k)\log L\log (p+k))$ 的做法。

上述做法的瓶颈在于 $g$ 的解决是依靠解决很多个 $f$ 来暴力用定义式解出，再观察到递推式中的和式都是连续的下标，于是把 $f$ 和 $g$ 的定义改成原来的前缀和。递推式变为：

$$
\begin{aligned}
&f_{n}-f_{n-1}=f_{n-1}-f_{n-k}+g_{n-1}-g_{n-k} \\
&g_{n}-g_{n-1}=f_{n-k}-f_{n-p-1}
\end{aligned}
$$


目标是 $f_{n}-f_{n-1}+g_{n}-g_{n-1}=f_{n}-f_{n-1}+f_{n-k}-f_{n-p-1}$，相当于求 $4$ 个 $f$ 的单项，套用之前提到的模板即可在求出前 $p+k$ 项之后在$O((p+k)\log L\log (p+k))$的复杂度内求出任意单项，而修改后的递推式在同时递推 $f$ 和 $g$ 时可以做到单项 $O(1)$（运用上面的递推式）。

总复杂度 $O((p+k)\log L\log (p+k))$

PS：注意到模数不是NTT模数，在使用线性递推的模板时需要使用任意模数的NTT。

---


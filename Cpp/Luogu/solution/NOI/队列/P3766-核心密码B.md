# 核心密码B

## 题目背景

懒得拷题目背景了，参见核心密码A...

请注意两道题的唯一差别。


## 题目描述

令g(n)表示n能表示成几种不同的完全k次方数（k>1），求$f(n)=\sum_{i=2}^n \frac{g(i)}{i}$。

例如，$64=2^6=4^3=8^2$，所以g(64)=3。


## 说明/提示

对于20%的数据，$n \leq 1000$。

对于40%的数据，$n \leq 10^6$，$T \leq 5$。

对于100%的数据，$2 \leq n \leq 10^{18}$，$1 \leq T \leq 50000$。


## 样例 #1

### 输入

```
2
5
15```

### 输出

```
0.25000000000000
0.48611111111111```

# 题解

## 作者：a12a (赞：12)

~~抗议积分暴政，世界属于小奥！~~

## 前置芝士

- 分数裂项

- 平方差公式

## $k \ge 3$ 时

很显然，即使一个一个枚举数据量也只有 $10^6$ 的数量级。直接将 $n$ 个询问排序后离线处理即可。

## $k=2$ 时

题目让我们求和的是一坨分数，结合小奥不难想到分数裂项。

但是 $\frac{1}{x^2}$ 显然无法裂项，这可怎么办呢？

注意到误差在 $2\times 10^{-14}$ 内即可，而 $10^7$ 的数据量可以直接枚举。

所以，我们对于 $> 10^7$ 的询问只需要求一个大差不差的近似值。结合七下的平方差公式，不难想到将 $\frac{1}{x^2}$ 取成 $\frac{1}{x^2-1}=\frac{1}{(x+1)(x-1)}$。

可以裂项了！

$$\frac{1}{(x+1)(x-1)}=\frac{1}{2}(\frac{1}{x-1}-\frac{1}{x+1})$$

现在要求的：

$$\begin{aligned} \sum_{x=10^7+1}^{\sqrt q_i} \frac{1}{2} (\frac{1}{x-1}-\frac{1}{x+1}) &=\frac{1}{10^7}-\frac{1}{10^7+2}+\frac{1}{10^7+1}-\frac{1}{10^7+3}+\frac{1}{10^7+2}-\frac{1}{10^7+4}+\frac{1}{10^7+3}-\frac{1}{10^7+5}+......+\frac{1}{q_i-1}-\frac{1}{q_i+1} \\ &= \frac{1}{10^7}+\frac{1}{10^7+1}-\frac{1}{q_i-1}-\frac{1}{q_i} \end{aligned}$$

一道黑题就这么做完了。

## 实现

- 由于 $2\times 10^{-14}$ 的误差，需要用到 `long double` 和 `sqrtl()` 函数。

- 快速幂最好用 `__int128`，以免出现一些奇怪的精度错误。

- 由于 $n \le 10^{18}$，需要开 `long long`。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{
	int x,id;
}q[100010];
int T;
long double ans[100010];
bool cmp(node a,node b)
{
	return a.x<b.x;
}
__int128 qpw(__int128 a,int b)
{
	__int128 sum=1;
	for(;b;b/=2,a*=a)
		if(b%2==1)
			sum*=a;
	return sum;
}
void f(int x)
{
	__int128 t=2,r=qpw(t,x);
	long double sum=0;
	for(int i=1;i<=T;i++)
	{
		while(r<=q[i].x)
		{
			long double tmp=1.0;
			tmp/=r,sum+=tmp,t++,r=qpw(t,x);
		}
		ans[q[i].id]+=sum;
	}
}
signed main()
{
	cin>>T;
	for(int i=1;i<=T;i++)
		cin>>q[i].x,q[i].id=i;
	sort(q+1,q+T+1,cmp);
	for(int i=3;i<=63;i++)
		f(i);
	for(int i=1;i<=T;i++)
	{
		if(q[i].x>1e14)
		{
			int x=sqrtl(q[i].x);
			long double t1=1.0,t2=1.0,t3=1.0,t4=1.0;
			t1/=(long double)(1e7),t2/=(long double)(1e7+1),t3/=(long double)(x),t4/=(long double)(x+1),t1=t1*1.0+t2*1.0-t3*1.0-t4*1.0,t1=t1*1.0/(long double)(2.0),ans[q[i].id]+=t1,q[i].x=1e14;
		}
	}
	f(2);
	for(int i=1;i<=T;i++)
		cout<<setprecision(15)<<fixed<<ans[i]<<'\n';
}
```

---

## 作者：fjzzq2002 (赞：10)

#### 核心密码B


令g(n)表示n能表示成几种不同的完全k次方数（k>1），求$\sum_{i=2}^n \frac{g(i)}{i}$，$n \leq 10^{18}$，保留十四位小数。


我们枚举每个有贡献的k（$2 \leq k \leq log_2n$），那么我们就是要计算$\sum_{i=2}^{\sqrt[k]{n}}\frac{1}{i^k}$ 。


我们有一个简单粗暴的方法，对于每个k预处理前10w项，剩下的我们用$\int_{i-0.5}^{i+0.5} \frac{1}{x^k}dx$代替每项，那么我们计算$\int_{100000.5}^{r+0.5} \frac{1}{x^k}dx$即可。


我们写一发，发现这玩意儿好像很靠谱！我们来证明一下。


由于懒，我们只考虑k=2的情况。


首先我们可以发现$\int_{i-0.5}^{i+0.5} \frac{1}{x^2}=\frac{1}{i^2-0.25} > \frac{1}{i^2}$，然后我们考虑误差为$\sum_{i=100001}^{\sqrt{n}} \frac{1}{i^2-0.25}-\frac{1}{i^2}$。由于求和比较困难，还是积分积一积，会发现这个数非常小，大约为$8 \times 10^{-17}$，然后就可以了。


---

## 作者：wmy_goes_to_thu (赞：4)

趁机水一波题解……

首先答案是这个和式：$S=\sum\limits_{i=2}^{n}\sum\limits_{k\geq 2} [i=n^k]\times \dfrac{1}{i}$

交换和式：$S=\sum\limits_{k\ge 2}\sum\limits_{i=2}^ { \sqrt [k]  { n } }\dfrac{1}{i^k}$

注意到当 $k\geq 3$ 时 $\sqrt[k]{n}$ 最多只有 $10^6$，可以直接进行前缀和计算

 当 $k=2$ 时因为前面的元素误差很大，所以也进行前缀和计算

后面的元素误差很小，经尝试约等于 $\int\limits_{10^6+0.5}^{\lfloor\sqrt{n}\rfloor+0.5}\dfrac{1}{x^2}dx=-\dfrac{1}{x}\bigg|_{10^6+0.5}^{\lfloor\sqrt{n}\rfloor+0.5}$

精度是 $10^{-16}$，所以需要 `long double`

代码：

```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
double f1[6][1000005];
double f2[85][1005];
int main()
{
	for(int k=2;k<=80;k++)
	{
		for(int i=2;i<=1000000;i++)
		{
			double gg=pow(i,k);
			if(gg>1e18)break;
			if(k<=5)f1[k][i]=f1[k][i-1]+1/gg;
			else f2[k][i]=f2[k][i-1]+1/gg;
		}
	}
	int T;
	cin>>T;
	while(T--)
	{
		long long n;
		cin>>n;
		double ans=0;
		for(int k=3;k<=5;k++)
		{
			int mn=min(1e6,pow(n,1.0/k));
			ans+=f1[k][mn];
		}
		for(int k=6;k<=80;k++)
		{
			int mn=pow(n,1.0/k);
			ans+=f2[k][mn];
		}
		double dd=pow(n,0.5);
		if(dd<=1e6)ans+=f1[2][(int)dd];
		else
		{
			ans+=f1[2][1000000];
			double l=(1e6)+0.5,r=((long long)dd)+0.5;
			ans+=1/l-1/r;
		}
		printf("%.16Lf\n",ans);
	}
	return 0;
}
```



---

## 作者：donghanwen1225 (赞：3)

这题是我没看题解自己做出来的第一道黑题，因此水一篇题解纪念一下。

------------

首先要求的式子是这个：$\sum\limits_{i=2}^{n}\dfrac{g(i)}{i}$，其中 $g(i)=\sum\limits_{k\geq2}[i=a^k]$。

考虑从这个 $a$ 入手解决问题。我们发现当 $a>10^6$ 时，$k$ 就只能等于 $2$ 了，因此可以先计算出 $a\leq10^6,k\geq3$ 的项，然后再加上一个 $\sum\limits_{i=2}^{\lfloor\sqrt{n}\rfloor}\dfrac{1}{i^2}$ 即可。

首先解决 $a\leq10^6,k\geq3$ 的部分。

先筛出 $10^6$ 以内的质数。假设一个数 $t$ 不可以表示为 $p^c(c\geq2)$ 的形式，那么对于 $i=t^b$ 来说，有 $g(i)=\sigma(b)-1$，这里 $\sigma(b)$ 表示 $b$ 的约数个数。

这里之所以要求 $t$ 不可以表示为 $p^c$ 的形式，是因为防止算重。

利用这一点，我们枚举 $10^6$ 以内的不能表示为 $p^c(c\geq2)$ 形式的数 $t$，若 $d$ 满足 $t^d\leq n,t^{d+1}>n$，对 $i\in[2,d],t^i$ 这些数，其答案加上 $\dfrac{\sigma(i)-1-[i\bmod2=0]}{t^i}$，这里减去 $[i\bmod2=0]$ 是为了去掉 $k=2$ 的情况，避免与第二部分重复。可以发现，不同的 $t^i$ 的数量大约只有 $2\times10^6$ 个，所以对这部分计算前缀和，就解决了这一部分。

然后再来解决 $\sum\limits_{i=2}^{\lfloor\sqrt{n}\rfloor}\dfrac{1}{i^2}$ 的部分。

这个式子显然是没有通项公式的。但我们发现，在 $n$ 很大时，最后一些项与 $y=\dfrac{1}{x^2}$ 下方的面积相差极小。

因此我们预处理出 $10^6$ 以内的值，然后对超过 $10^6$ 的部分，直接计算
$$\int_{10^6+0.5}^{\lfloor\sqrt{n}\rfloor+0.5}\dfrac{1}{x^2}\text{d}x=\dfrac{1}{10^6+0.5}-\dfrac{1}{\lfloor\sqrt{n}\rfloor+0.5}$$
的值即可。可以发现这个数与精确答案的误差很小，不到 $10^{-16}$，因此可以满足题目要求的精度误差。

注意这题对精度要求非常高，所以要用 `long double`。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath> 
#include<algorithm>
using namespace std;
typedef long long ll;
const ll mx=1e18;
ll n,pri[1000001],sig[1001];int t,cnt,tot;long double pf[1000001];
bool bj[1000001],fg[1000001];
struct num
{
	ll s;long double res;
	num(ll ss=0,long double ress=0){s=ss;res=ress;}
	friend bool operator <(const num &a1,const num &a2){return a1.s<a2.s;} 
} tj[2100001];
void init()
{
	for(int i=2;i<=1000000;i++)
	{
		if(!bj[i]) pri[++cnt]=i;
		for(int j=1;j<=cnt&&i*pri[j]<=1000000;j++)
		{
			bj[i*pri[j]]=1;
			if(i%pri[j]==0) break;
		}
	}
	for(int i=1;i<=100;i++)
		for(int j=i;j<=100;j+=i) sig[j]++;
	for(int i=2;i<=1000000;i++)
		if(!fg[i])
		{
			ll cur=i;
			for(int j=2;;j++)
			{
				cur*=i;if(cur<=1000000) fg[cur]=1;
				//这里是去掉 t=p^c 的数，防止算重
				tot++; 
				tj[tot]=num(cur,(sig[j]-1-(j%2==0))*1.0/cur);
				if(cur>mx/i) break;
			}
		}
	sort(tj+1,tj+1+tot);
	for(int i=1;i<=tot;i++) tj[i].res+=tj[i-1].res;
	for(int i=2;i<=1000000;i++) pf[i]=pf[i-1]+1.0/(1ll*i*i);
}
long double Find(ll n)//计算第一部分
{
	//二分找到小于等于 n 的最大的 t
	int l=1,ans=0,r=tot;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(tj[mid].s<=n) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return tj[ans].res;
}
long double cal(ll n)//计算第二部分
{
	if(n<=1000000) return pf[n];
	else return pf[1000000]+1.0/(1e6+0.5)-1.0/(n+0.5);
}
int main()
{
	init();
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld",&n);
		ll tmp=sqrt(n);
		if(tmp*tmp>n) tmp--;if((tmp+1)*(tmp+1)<=n) tmp++;//防止 sqrt 出现奇怪的误差
		printf("%.14Lf\n",Find(n)+cal(tmp));
	}
	return 0;
}
```

---

## 作者：Rurirat (赞：2)

> 略显恶心の数值计算问题。尽管如此，Rurirat 认为本题的知识点和寄巧配不上它的颜色。

**题目**：$T$ 次询问，每次给定 $n\in\mathbb{N}_{\geq 2}$，求 $f(n):=\sum_{i=2}^n \frac{g(i)}{i}$，其中 $g(m):=\text{card}\{(a,k)\in\mathbb{N}_{\geq2}^2|a^k=m\}$。

先推公式：
$$
\begin{aligned}
f(n)&=\sum_{m=2}^n \frac{g(m)}{m} \\
&=\sum_{m=2}^n \frac{1}{m}\sum_{i=2}^{\infin}\sum_{k=2}^{\infin}[i^k=m] \\
&=\sum_{k=2}^{\infin}\sum_{i=2}^{\infin}\sum_{m=2}^n[i^k=m]\frac1m \\
&=\sum_{k=2}^{\infin}\sum_{i=2}^{\infin}[i^k\leq n]\frac{1}{i^k} \\
&=\sum_{k=2}^{59}\sum_{i=2}^{[\sqrt[k]{n}]}\frac{1}{i^k} \\
\end{aligned}
$$
设 $\sum_{i=1}^{m}\frac{1}{i^k} =: s_k(m)$，则 $f(n)=\sum_{k=2}^{59}s_k([\sqrt[k]{n}])-58$。

对于 $k\geq 3$，预处理出所有的 $s_k(m)$ 存在数组里，这部分在公式上没有近似，换言之，没有理论上的误差，假如程序是无限精度的则答案也是无限精度的。

对于 $k=2$，记 $L=5\times 10^6$，预处理 $s(1)...s(L)$ 存在数组里，讨论 $m$：\
(1) $m\leq L$，直接查询，此时没有理论上的误差；\
(2) $m>L$，则考虑近似：
$$
\begin{aligned}
s_2(m)&=\sum_{i=1}^{m}\frac{1}{i^2} \\
&=\sum_{i=1}^{\infin}\frac{1}{i^2} - \sum_{i=m+1}^{\infin}\frac{1}{i^2} \\
&= \frac{\pi^2}{6} - \sum_{i=m+1}^{\infin}\frac{1}{i^2} \\
\end{aligned}
$$

而
$$
\frac{1}{m+1}=\sum_{i=m+1}^{\infin}\frac{1}{i(i+1)}<\sum_{i=m+1}^{\infin}\frac{1}{i^2} < \sum_{i=m+1}^{\infin}\frac{1}{i(i-1)}=\frac1m
$$
从而可以取
$$
s_2(m)\approx \frac{\pi^2}{6} - \frac{2m+1}{2m(m+1)}
$$
此式可以 $O(1)$ 计算，其误差的上界是 $\frac{1}{2L^2}$，实践可以通过。

### Remark
- $59$ 是怎么来的？因为 $2^{60}>10^{18}\geq n$。
- $\frac{\pi^2}{6}$ 是怎么来的？这个问题叫做【巴塞尔问题】，您可以以此为关键词搜索，或者搜索【平方倒数和问题】【如何计算 zeta(2)】，欣赏一下此问题的众多证明方法。
- 如果开 $10^7$ 个 long double 会 MLE。

### AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define SI __inline__ __attribute((always_inline))

using ldouble=long double;
const ldouble e=1e-6;
const ldouble PI=3.1415926535897932384L;
const ldouble zeta2=PI*PI/6;
using ll=long long;
const ll MAXN=1e18;
const int MAXK=59;
constexpr const int L[MAXK+1]={
	  -1		// 0
	, -1		// 1
	, int(5e6)	// 2
	, 1'000'000	// 3
	, 31622		// 4
	, 3981		// 5
	, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000
	, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000
	, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000
	, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000
	, 1000, 1000, 1000, 1000, 1000, 1000
};

SI ldouble& s(int k, int n)
{
	static ldouble data2[L[2]+1];
	static ldouble data3[L[3]+1];
	static ldouble data4[L[4]+1];
	static ldouble data5[L[5]+1];
	static ldouble data[MAXK+1][L[6]+1];
	switch(k)
	{
		case 2: return data2[n];
		case 3: return data3[n];
		case 4: return data4[n];
		case 5: return data5[n];
	}
	return data[k][n];
}

void ass()
{
	for(int k=2;k<=MAXK;k++)for(int n=1;n<=L[k];n++) s(k,n)=s(k,n-1)+pow(ldouble(n),-k);
}
SI ldouble S(ll m)
{
	return (m<=L[2]) ? (s(2,m)) : (zeta2 - (m+0.5L)/(m*(m+1)));
}
SI ldouble f(ll n)
{
	ldouble ot=S(sqrt(n+e))-MAXK+1;
	for(int k=3;k<=MAXK;k++) ot+=s(k,pow(n+e,1.0L/k));
	return ot;
}
SI void mian()
{
	ll n;
	scanf("%lli",&n);
	printf("%.18Lf\n",f(n));
}
int main()
{
	ass();
	int t;
	scanf("%i",&t);
	while(t--) mian();
}

```

---

## 作者：__Luna__ (赞：1)

## 思路

首先，我们给 $f(n)$ 做一个变形：

$$f(n)=\sum_{i=2}^n\frac{g(i)}{i}=\sum_{k=2}^{+\infin}\sum_{j=2}^{\lfloor\sqrt[k]n\rfloor}\frac{1}{j^k}$$

根据变形后的式子，我们可以分开处理不同幂次的完全 $k$ 次方数。由于数据范围是 $2\leq n\leq10^{18}$，而经计算有 $2^{60}\approx1.1529215\times10^{18}>10^{18}$，故实际计算时指数 $k$ 处理到 $60$ 即可。

接下来进行对 $\displaystyle\sum_{j=2}^{\lfloor\sqrt[k]n\rfloor}\frac{1}{j^k}$ 的计算，需要依据 $k$ 分情况处理。

### 对于 $k\ge3$ 的情况

由于底数 $j$ 最大只有 $\sqrt[3]{10^{18}}=10^6$，可以暴力累加 $\displaystyle\frac{1}{j^k}$。对于多组询问可以使用一个技巧，即将询问全部读入，从小到大排序后依次处理。这样可以避免重复计算，也不需要记忆化占用大量内存。

### 对于 $k=2$ 的情况

$j$ 最大为 $\sqrt{10^{18}}=10^9$，直接暴力是不能通过的。由于允许 $2\times10^{-14}$ 的误差，我们可以考虑进行近似处理。

我们取一个不大的数 $N$，当 $j\le N$ 时，依然可以使用暴力。当 $j>N$ 时，我们可以将 $\displaystyle\frac{1}{j^2}$ 近似看成 $\displaystyle\frac{1}{j^2-0.25}$，裂项后即为 $\displaystyle\frac{1}{j-0.5}-\frac{1}{j+0.5}$。用裂项后的结果代替 $j>N$ 的各项，得到当 $j>N$ 时，有：

 $$\sum_{j=2}^{\lfloor\sqrt n\rfloor}\frac{1}{j^2}\approx\sum_{j=2}^{N}\frac{1}{j^2}+\frac{1}{N+0.5}-\frac{1}{\lfloor\sqrt n\rfloor+0.5}$$ 

下面我们需要找到一个合适的 $N$。分析误差，可知经过近似后，每一项比准确值大了 $\displaystyle\frac{1}{j^2-0.25}-\frac{1}{j^2}=\frac{1}{4j^4-j^2}$。总误差为：

$$
\begin{align*}
\sum_{j=N+1}^{\lfloor\sqrt n\rfloor}\frac{1}{4j^4-j^2}&\le\sum_{j=N}^{+\infin}\frac{1}{4j^4-j^2}\\
&\approx\sum_{j=N}^{+\infin}\frac{1}{4j^4}\\
&\le\int_{N}^{+\infin}{4x^4}dx\\
&=\frac{1}{12N^3}
\end{align*}$$

根据题意，我们要求 $\displaystyle\frac{1}{12N^3}\le2\times10^{-14}$，解得 $N$ 最小为 $16092$。保险起见，我们可以取 $N=20000$。

## 代码

在编码细节上，需要注意精度问题。

[$283~\mathrm{ms}$](https://www.luogu.com.cn/record/189813395) 的 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long double _1=1.0,m=_1/(2e4+0.5);
__int128 pow_(__int128 a,int x)
{
	__int128 r=1;
	while(x)
	{
		if(x&1)r*=a;
		a*=a;
		x>>=1;
	}
	return r;
}
struct nd
{
	long long n;
    int r;
	nd(long long n=0,int r=0):n(n),r(r){}
	bool operator<(nd x){return n<x.n;}
}a[50005];
long double ans[50005];
int main()
{
	int T;
	scanf("%d",&T);
	for(int i=0;i<T;i++)
	{
		scanf("%lld",&a[i].n);
        a[i].r=i;
	}
	sort(a,a+T);
	for(int i=2,j,k;i<=60;i++)
	{
		k=2;
        __int128 l=pow(k,i);
		long double s=0; 
		for(j=0;j<T;j++) //暴力
		{
			if(i==2&&a[j].n>=4e8) //退出暴力
            {
                break;
            }
			for(;l<=a[j].n;k++,l=pow_(k,i))
			{
				s+=_1/l;
			}
			ans[a[j].r]+=s;
		}
		for(;j<T;j++) //近似处理
		{
			for(;k<=2e4;k++,l=pow(k,i))
			{
				s+=_1/l;
			}
			int n=sqrtl(a[j].n);
			ans[a[j].r]+=s+(m-_1/(n+0.5));
		}
	}
	for(int i=0;i<T;i++)printf("%.15llf\n",ans[i]);
}
```

---

## 作者：Arghariza (赞：1)

感觉有点卡，可能是不玩原始人导致的。

考虑枚举合法的 $k\in [2,\log n]$：

$$\text{ans}=\sum\limits_{k=2}^{\log n}\sum\limits_{t=2}^{\sqrt[k]{n}}\frac{1}{t^k}$$

自然数幂倒数和已经是个被玩烂掉的东西，不大可能快速求出来。考虑到 $k\ge 4$ 时，$\sqrt[k]{n}\le 3.2\times10^4$。可以预处理出 $s_{k,t}$ 表示 $\sum\limits_{t'=2}^t\frac{1}{t'^k}$，枚举 $k\ge 4$ 的时候直接 $O(1)$ 求即可。

对于 $k\in \{2,3\}$，显然可以先预处理出 $t\le 10^6$ 的情况，然后对于 $t>10^6$，直接进行近似：

$$\frac{1}{t^k}\approx \int_{t-0.5}^{t+0.5}\frac{1}{x^k}$$

好求的。解决了。

---

## 作者：zesqwq (赞：1)

考虑到我完全不会数学。

我们考虑对于 $a^b$，对每个 $b$ 单独算贡献。

如果 $b \ge 3$，我们可以使用 $O(\sqrt[b]V)$ 的做法，这是简单的，可以对询问排序后双指针做，也可以预处理，反正不重要。

对于 $b = 2$，我们可以先暴力高出 $a \le 10^7$ 时的贡献，对于更大的，我们可以取一个近似，把 $\dfrac {1} {x^2}$ 变为 $\dfrac{\dfrac{1}{(x-1)x}+\dfrac{1}{x(x+1)}}2$，上面两个是可以直接裂项做的，该近似精度没有积分的近似优秀，但仍然可以通过此题并且获得最优解。

```cpp
struct Query{
    ll k;
    int id;
    inline bool operator<(Query b) { return k < b.k; }
} q[Q];
__int128 qpw(__int128 a, ll b) {
    __int128 ans = 1;
    while (b) {
        if (b & 1) ans = ans * a;
        a = a * a, b >>= 1;
    }
    return ans;
}
long double ans[Q];
int T;
inline void solve(int x) {
    int r = 2;
    __int128 qr = qpw(r, x);
    long double now = 0;
    for (int i = 1; i <= T; i++) {
        while (qr <= q[i].k) now += (long double)1.0 / qr, ++r, qr = qpw(r, x);
        ans[q[i].id] += now;
    }
}
inline long double calc(ll x) {
    long double ta = 1.0 / 10000000 - (long double)(1.0) / (x + 1);
    long double tb = 1.0 / (10000000 - 1) - (long double)(1.0) / x;
    return (ta + tb) / 2;
}
int main() {
    read(T);
    for (int i = 1; i <= T; i++) read(q[i].k), q[i].id = i;
    sort(q + 1, q + T + 1);
    for (int i = 3; i <= 60 ;i++) solve(i);
    for (int i = 1; i <= T; i++)
        if (q[i].k > 100000000000000) {
            int tmp = sqrtl(q[i].k);
            ans[q[i].id] += calc(tmp);
            q[i].k = 100000000000000;
        }
    solve(2);
    for (int i = 1; i <= T; i++) printf("%.15Lf\n", ans[i]);
    return 0;
}
```

---


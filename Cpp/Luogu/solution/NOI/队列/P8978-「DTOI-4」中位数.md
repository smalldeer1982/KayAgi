# 「DTOI-4」中位数

## 题目描述

给定一个长度为 $n$ 的整数序列 $a$，你可以进行以下操作不超过 $k$ 次：

- 选择一个区间 $[l, r]$ 满足 $1 \leq l \leq r \leq n$，并将 $[l, r]$ 中的所有数替换为这个区间的中位数。

你要使得操作后 $a$ 的**最小值最大**。

关于此处中位数的定义：对于一个长度为 $len$ 的序列，其中位数定义为该序列中第 $\lceil \frac{len}{2} \rceil$ 小的数。

## 说明/提示

| $\textbf{Subtask}$ | $n$ | 分值 |
| :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 10$ | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 100$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 10^3$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^4$ | $20 \operatorname{pts}$ |
| $5$ | $1 \leq n \leq 10^5$ | $20 \operatorname{pts}$ |
| $6$ | 无特殊限制 | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 4 \times 10^5$，$0 \leq k \leq n$，$0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
10 2
2 8 3 2 5 7 10 4 9 7```

### 输出

```
7```

## 样例 #2

### 输入

```
30 3
1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0```

### 输出

```
0```

## 样例 #3

### 输入

```
31 3
1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1```

### 输出

```
1```

# 题解

## 作者：Alex_Wei (赞：27)

很不错的题目，思路很自然，结论较难证但好猜，思维含量很高。

首先二分答案转化为 $01$ 序列，目标是将所有数全部变成 $1$。

> **基本性质**：若可操作 $I_1, I_2$ 且 $I_1\subset I_2$，则操作 $I_2$ 一定更优。

设最优操作序列为 $I_1, I_2, \cdots, I_e$。

设 $1$ 的权值为 $1$，$0$ 的权值为 $-1$，前缀和序列为 $s$，每次可将权值为正的一段区间全部变成 $1$。设操作 $I$ 时其权值为 $v(I)$。

> **性质 1**：对于 $1\leq i < e$，$v(I_i) = 1$。
>
> **证明**：设 $v(I_i) > 1$，则 $I_i$ 向左或向右扩展 $1$ 一定不会使得 $v(I_i)\leq 0$。
>
> $\square$

性质 1 的推论：

- 设操作 $I$ 时区间内原有 $1$ 的数量为 $o(I)$，消去 $0$ 的数量为 $z(I)$，若 $I\neq [1, n]$，则 $o(I) = z(I) + 1$，进一步有 $|I| = o(I) + z(I) = 2o(I) - 1$。

> **性质 2**：若存在方案使得 $[1, n]$ 全为 $1$，则 $e\leq \lceil \log_2 n\rceil$。
>
> **证明**：若初始存在 $o(I) \geq 2$ 且 $v(I) > 0$，即存在 $101$ 或 $11$ 作为子串，则总存在操作序列，使得 $o(I_{i + 1}) \geq |I_i| = 2o(I_i) - 1$，易知 $o(I_i) \geq 2 ^ {i - 1} + 1$，则 $e\leq \lceil \log_2 n\rceil$。
>
> 若初始不存在这样的 $I$，即无法操作长度大于 $1$ 的区间，则无法对序列产生任何影响，即无解。
>
> $\square$

> **性质 3**：对于任意 $1\leq i < j \leq e$，$I_i\subseteq I_j$ 或 $I_j \subseteq I_i$。
>
> **证明**：
>
> 先证明 **相交必然包含**：考虑两次相交但不包含的操作 $I_i = [a, c]$，$I_j = [b, d]$，其中 $a < b \leq c < d$，则令 $I_j = [a, d]$ 一定合法，因为此时 $[a, b)$ 均为 $1$。
>
> 接下来只需证明 **一定相交**。我们使用调整法。
>
> 找到最后两个相邻且不交的区间 $I_j, I_{j + 1}$，则 $I_{j + 1}\subset I_{j + 2} \subset \cdots \subset I_e$。因为 $I_e = [1, n]$，所以存在 $j + 1\leq p < e$ 使得 $I_p\cup I_j = \varnothing$，且 $I_{p + 1} \cup I_j = I_j$。
>
> 若 $|I_j| \geq |I_p|$，我们可以将 $I_{j + 1}\sim I_p$ 全部取消，替换为 $I_j$ 的 “超区间” $I_j\subset I\subseteq I_{p + 1}$，这样消去 $0$ 的数量为 $|I_j| - 1\geq |I_p| - 1$，而 $I_{j + 1}\sim I_p$ 消去的 $0$ 的数量显然不超过 $|I_p| - 2$，所以替换后 $I_{p + 1}$ 的权值一定增加，而操作数不增。
>
> 若 $|I_j| < |I_p|$，类似地，取消操作 $I_j$，替换为在 $I_p$ 后插入 $I_p$ 的 “超区间” $I_p\subset I\subseteq I_{p + 1}$，$I_{p + 1}$ 的权值增加，而操作数不变。
>
> 调整后，相邻且不交的区间的位置单调递减，因此调整总可以结束。
>
> $\square$

有了性质 2 和性质 3，我们可以设计 DP $f_{i, l, r}$ 表示 $I_i = [l, r]$ 是否可行。转移暴力枚举扩展区间，单次检查时间复杂度 $\mathcal{O}(n ^ 4\log n)$。

根据基本性质，对于每个 $l$，我们只关心最大的 $r$ 使得 $f_{i, l, r} = 1$。因此，考虑 **值域定义域互换** 的套路，设 $f_{i, l}$ 表示从 $l$ 开始，最大的 $r$ 使得原 $f_{i, l, r}$ 等于 $1$。

再根据基本性质，如果 $p < q$ 且 $f_{i, p} \geq f_{i, q}$，那么 $f_{i, q}$ 是无用的。因此，从 $f_{i - 1} \to f_i$ 时，我们只关心所有不被包含的 $I_l = [l, f_{i - 1, l}]$ 区间，即左右端点单调递增。

设 $c(I)$ 表示操作 $I = [l, r]$ 后相对于原序列，对包含 $I$ 的区间的权值产生的贡献，即 $r - l + 1 - (s_r - s_{l - 1})$。考虑检查 $f_{i, l}$ 能否为 $p$，那么我们求出所有使得 $[j, f_{i - 1, j}]\subseteq [l, p]$ 的 $c([j, f_{i - 1, j}])$ 的最大值 $c_{\max}$，那么 $s_p - s_{l - 1}$ 加上 $c_{\max}$ 之后应为正数，即 $s_{l - 1} - c_{\max} < s_p$。

这样，我们有了单次检查 $\mathcal{O}(n ^ 2\log n)$ 的做法。结合递增性质，换成扫描线 + 单调栈 + 线段树二分即可 $\mathcal{O}(n\log ^ 2 n)$，但总复杂度 $\mathcal{O}(n \log ^ 3 n)$ 及大常数仍无法通过。

我们进一步利用递增性质，从后往前扫描线。加入区间 $I_l$ 时，权值小于 $c(I_l)$ 的区间就无用了。这启发我们使用单调队列，从队头到队尾 **区间位置从右往左**，同时 **权值递减**。我们希望找到队列中的第一个位置 $I_p$，使得存在 $q \geq f_{i - 1, p}$ 且 $s_{l - 1} - c(I_p) < s_q$。预处理 $g_i$ 表示使得 $s_q \geq i$ 的最大的 $q$，则相当于检查是否有 $g(s_{l - 1} - c(I_p) + 1)\geq f_{i - 1, p}$。

$g$ 显然具有单调性，$-c(I_p) + 1$ 同样单调增（$c(I_p)$ 递减），问题在于 $s_{l - 1}$。但是我们也有方法解决：$p < q$ 且 $s_p \leq s_q$，则 $q$ 肯定不会作为左端点，丢掉所有这样的位置之后，$s_{l - 1}$ 随着 $l$ 递减而单调递增，故 $s_{l - 1} - c(I_p) + 1$ 递增，可使用单调队列维护。

看了下标算，定义是相同的，换了一种转移方式：求值的极值而不是求位置的极值。感觉麻烦了点。

总时间复杂度 $\mathcal{O}(n\log ^ 2 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 4e5 + 5;
int n, k, a[N], b[N], s[N];
int f[N], tag[N], buc[N << 1];
bool check(int x) {
  for(int i = 1; i <= n; i++) {
    s[i] = s[i - 1] + (a[i] >= x ? 1 : -1);
  }
  memset(tag, 0, sizeof(tag));
  for(int i = 1, lim = N; i <= n; i++) {
    if(s[i - 1] < lim) lim = s[i - 1], tag[i] = 1;
  }
  memset(buc, 0, n + 2 << 3);
  for(int i = 1; i <= n; i++) buc[n + s[i]] = i;
  for(int i = n * 2 - 1; ~i; i--) buc[i] = max(buc[i], buc[i + 1]);
  for(int i = 1; i <= n; i++) f[i] = i - 1;
  for(int _ = 1; _ <= k && (1 << _ - 1) <= n; _++) {
    static int d[N], val[N], hd, tl;
    hd = 1, tl = 0;
    for(int i = n; i; i--) {
      if(!tag[i]) continue;
      int v = f[i] - i + 1 - (s[f[i]] - s[i - 1]);
      while(hd <= tl && v >= val[tl]) tl--;
      val[++tl] = v, d[tl] = f[i];
      while(hd <= tl) {
        int v = val[hd], p = buc[max(0, s[i - 1] + 1 - v + n)];
        if(p >= d[hd]) {f[i] = p; break;}
        hd++;
      }
    }
    if(f[1] == n) return _ <= k;
  }
  return 0;
}
int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> k;
  for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
  sort(b + 1, b + n + 1);
  int c = unique(b + 1, b + n + 1) - b - 1;
  int l = 1, r = c;
  while(l < r) {
    int m = l + r + 2 >> 1;
    if(check(b[m])) l = m;
    else r = m - 1;
  }
  cout << b[l] << "\n";
  return 0;
}
```

---

## 作者：空气树 (赞：13)

首先考虑二分答案，把原序列变成01序列。

那么问题就相当于转换成判断能否在 $k$ 次操作内，将序列变成全 $1$。

由于每次操作一定可以做到把 $1$ 的个数$n$变成 $n'=2n-1$。因此可以得知操作一定是 $\log n$ 级别的。

但是这个问题仍然不太好做，很多贪心都是假的。考虑最暴力的区间DP。

由于多选 $1$ 一定不劣，所以操作区间一定互相不交。
因为如果要相交，一定比包含关系劣。

设 $f[i][l][r]$ 表示使用 $i$ 步能否将 $[l,r]$ 变成全 $1$。

考虑转移，最简单的思路就是枚举最右的区间：$f[i][l][r]|=f[x][l][k]\&f[y][k+1][r],x+y=i$。

特殊做一下 $f[i][l'][r']|=f[i-1][l][r]$。

但是分析 $f[x][l][k]$ 和 $f[y][k+1][r]$ 这两个状态，假设 $k-l+1<=r-k$。

那么显然 $f[y][k+1][r]$ 是可以转移到 $f[y+1][l'][r],(l'\le l)$，这样操作更优秀。

所以以此类推，不如将 $x$ 次操作全部给 $f[y][k+1][r]$。

那么如此，就可以贪心地分析得到每次转移只会从一个区间转移而来。

转移式就直接变成了 $f[i][l'][r']|=f[i-1][l][r]$。

也就是说，如果将操作区间建树，那么就是一条链。形成包含关系。

这样就可以改进状态为，设 $f[i][r]$ 表示用 $i$ 次操作，只考虑 $[1,r]$，最小的 $l$，使得 $[l,r]$ 可以全变为 $1$。

这个就属于线性DP 了。

转移式：$f[i][r]=\min(P[r][u][f[i-1][u]]),lim[r]\le u\le i$。

这里转移式的思路是找到上一层操作区间的右端点，左端点。

可以计算出以$r$为操作区间右端点最远的左端点 $l=P[r][u][f[i-1][u]]$。

具体可以自行推得，并不困难。

这里 $P[r][u][f[i-1][u]]$ 的用意就是表示这个 $l$ 与 $r$，$u$，$f[i-1][u]$ 相关。同理 $lim[r]$ 表示仅与 $r$ 相关。（这里都忽视了 $i$ 这个状态）

考虑使用单调队列优化转移，因为发现将越多的 $0$ 变成 $1$ 的决策点越优。这个可以由 $l$ 的表达式看出。

而 $u$ 是否合法则与 $f[i-1][u]$ 相关，并非随 $u$ 递增。
因此在入队时需要注意判断。

至于 $lim[r]$，是与前缀 $1$ 的个数和 $0$ 的个数差相关。

因为这个差的变化为 $1$ 或 $-1$，$lim[r]$ 的变化量最多为 $1$。所以可以暴力扫单调队列的队头。

具体这部分的详细细节可以看代码或看出题人题解。

那么这题就做完了，时间复杂度为 $O(n\log^2 n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<map>
#include<vector>
#include<queue>
#include<set>
#include<stack>
#include<bitset>
#include<random>
#include<unordered_map>
#include<deque>
#include<cassert>
#include<chrono>
using namespace std;
#define re int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    return x*ff;
}
int n,k,a[400005],c[400005],s[400005],ss[400005],f[400005],g[400005],p[400005];
int dl[400005],tot,cnt,b[800005];
bool ok(int xx){
    for(re i=1;i<=n;i++){
        if(a[i]>=xx)c[i]=1;
        else c[i]=0;
        s[i]=s[i-1]+c[i];
        ss[i]=ss[i-1]+(c[i]?1:-1);
        //cout<<c[i]<<" ";
    }//puts("");
    if(s[n]<2)return 0;
    memset(b,0x3f,sizeof(b));
    for(re i=n;i;i--)b[ss[i]+n]=i;
    b[n]=0;
    for(re i=1-n;i<=n;i++)b[i+n]=min(b[i+n],b[i+n-1]);
    f[0]=1;
    for(re i=1;i<=n;i++){
        if(c[i])f[i]=f[i-1];
        else f[i]=i+1;
    }
    if(f[n]==1)return 1;
    for(re i=1;i<=21&&i<=k;i++){
        for(re j=1;j<=n;j++)g[j]=f[j],p[j]=j-g[j]+1-(s[j]-s[g[j]-1]);
        tot=1;cnt=0;
        for(re j=1;j<=n;j++){
            if(f[j]<=j){
                while(cnt&&p[j]>=p[dl[cnt]])cnt--;
                if(!cnt||(-s[g[j]-1]+p[j])*2+g[j]>=(-s[g[dl[cnt]]-1]+p[dl[cnt]])*2+g[dl[cnt]])dl[++cnt]=j;
                tot=min(tot,cnt);
            }
            while(tot<=cnt&&(s[j]-s[g[dl[tot]]-1]+p[dl[tot]])*2<=(j-g[dl[tot]]+1))tot++;
            if(tot<=cnt){
                while(tot&&(s[j]-s[g[dl[tot]]-1]+p[dl[tot]])*2>(j-g[dl[tot]]+1))tot--;
                tot++;
            }
            if(f[j]>j)f[j]=b[ss[j]-1+n]+1;
            if(tot<=cnt){
                f[j]=min(b[ss[j]+p[dl[tot]]*2-1+n]+1,f[j]);
                //if(f[j]>g[dl[tot]])f[j]=1;
            }
            f[j]=min(f[j],g[j]);
        }
        if(f[n]==1)return 1;
    }
    return 0;
}
signed main(){
    n=read();k=read();
    for(re i=1;i<=n;i++)a[i]=read();
    if(n==1){cout<<a[1]<<endl;return 0;}
    int l=0,r=1e9,mid;//cout<<ok(939);return 0;
    while(l<=r){
        mid=(l+r)>>1;
        if(ok(mid))l=mid+1;
        else r=mid-1;
    }
    cout<<l-1<<endl;
    return 0;
}

```



---

## 作者：Stinger (赞：8)

二分。操作转化为 01 序列上选一个 $0$ 比 $1$ 少的区间全部变成 $1$。不难发现操作次数不超过 $\lceil \log n\rceil$。

一定存在一种最优方案使得选择的每个区间都是包含关系，并且先操作被包含得深的区间。~~读者自证不难。~~

据此 dp。$f_{i,j}$ 表示 $i$ 次操作，最后一次操作右端点是 $j$，最远左端点是多少。$s_i$ 表示 $[1,i]$ 中 $1$ 的个数减去 $0$ 的个数，$lft_i$ 表示最小的 $j$ 使得 $s_j\le i$。令 $d_k=s_j-s_k+k-f_{i-1,k}+s_{f_{i-1,k}-1}$，则 $f_{i,j}=\min\{lft_{d_k}+1\}$。

那么是否直接记录 $d_k$ 的最大值就是最优？显然不是。$lft_{d_k}$ 存在且 $<j$ 的条件是操作 $[f_{i-1,k},j]$ 可以被执行（称该条件为决策点 $k$ 合法）。决策点 $k$ 的合法条件可以写为 $s_j\ge v_k$，$v_k$ 为一个只与 $k$ 有关的值。那么只需要树状数组找到 $v_k\le s_j$ 里面的 $d_k$ 最大值即可。时间复杂度 $\Theta(n\log^3 n)$。

对于决策点 $x<y$，如果操作 $x$ 比 $y$ 更容易合法，那么 $[f_{i-1,x},x]$ 中 $0$ 的个数比 $[f_{i-1,y},y]$ 更多（证明见后文），而 $0$ 个数多又会让 $d_x$ 更大，决策点 $x$ 一定比 $y$ 优。

维护一个单调队列，里面的决策点按照 $d$ 和 $v$ 的大小同时单调递减。插入队尾时，先看看目前队尾的 $v$ 是否比待插入元素大，如果不是就不插入了。如果是，弹出队尾直到队尾的 $d$ 大于待插入元素的 $d$。要找到最优的决策点，直观的想法是二分到第一个合法的。但是对于同一个 $x$，合不合法只与 $s_i$ 有关，而 $s_i$ 每次只会变化 $1$，这也就意味着最优决策点在队列中的位置只会变化 $1$，所以每次暴力移动最优决策点位置即可。

关于上面那个决策点之间优劣关系的证明：

我们记 $d(l)$ 表示线段 $l$ 中 $0$ 的个数，$sum(l)$ 表示线段 $l$ 中 $1$ 的个数减去 $0$ 的个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/956ln4st.png)

红色线段 $red$ 的操作比蓝色线段 $blue$ 的操作更容易合法，即 $ sum(l_1)+2d(l_1)-2d(l_2)\ge 0$。而 $sum(l_1)< 0$（不然 $f_{i-1,y}$ 将会更小），因此 $d(l_1)>d(l_2)$。因此决策点 $x$ 一定比决策点 $y$ 优。如果红蓝不交证明也是一样的。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#define cal (f[i][j] = lft[s[j] - v[q[hd]] + s[f[i - 1][q[hd]] - 1] + n] + 1)
#define N 400005

int a[N], b[N], f[20][N], s[N], z[N], lft[N << 1], q[N], v[N], hd, tl, n, k;
bool check(int mid) {
    memset(lft, 0x3f, sizeof lft);
    f[0][0] = 1;
    for (int i = 1; i <= n; ++ i) {
        s[i] = s[i - 1] + (a[i] >= mid ? 1 : -1), z[i] = z[i - 1] + (a[i] >= mid ? 0 : 1);
        if (a[i] >= mid) f[0][i] = f[0][i - 1];
        else f[0][i] = i + 1;
    }
    if (f[0][n] == 1) return true;
    for (int i = n; i >= 0; -- i) lft[s[i] + n] = i;
    for (int i = 1; i <= 2 * n; ++ i) lft[i] = std::min(lft[i - 1], lft[i]);
    for (int i = 1; 1 << i - 1 < n && i <= k; ++ i) {
    	memset(q, 0, sizeof q);
        for (int j = 1, hd = 1, tl = 0; j <= n; ++ j) {
            f[i][j] = j + 1, v[j] = s[j] - j + f[i - 1][j];
            if (hd <= tl) {
         	   if (hd > 1 && v[q[hd - 1]] <= s[j]) -- hd, cal;
	            else if (v[q[hd]] > s[j]) {if (hd < tl) ++ hd, cal;}
	            else cal;
        	}
            if (f[i][j] > j + 1) f[i][j] = j + 1;
            if (a[j] >= mid) f[i][j] = std::min(f[i][j], lft[s[f[i - 1][j] - 1] + n + j - f[i - 1][j]] + 1);
            if (!tl || v[j] < v[q[tl]]) {
                while (tl && z[q[tl]] - z[f[i - 1][q[tl]] - 1] <= z[j] - z[f[i - 1][j] - 1]) -- tl;
                q[++ tl] = j, hd = std::min(hd, tl);
            }
        }
        if (f[i][n] == 1) return true;
    }
    return false;
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++ i) scanf("%d", a + i), b[i] = a[i];
    std::sort(b + 1, b + n + 1);
    int lim = 0, ans = 0;
    while (1 << lim + 1 <= n) ++ lim;
    for (int i = lim; i >= 0; -- i) if ((ans | 1 << i) <= n && check(b[ans | 1 << i])) ans |= 1 << i;
    printf("%d", b[ans]);
    return 0;
}
```

---

## 作者：Leasier (赞：3)

[Stinger](https://www.luogu.com.cn/user/361308) 的 dp 好题 /bx

------------

考虑二分，转化为下面这个问题：

- 有长为 $n$ 的 01 序列 $a$。
- 每次可以选择 $a$ 的一个 $1$ 不少于 $0$ 的区间，将其变为全 $1$。
- 问是否可以在 $k$ 次操作内让 $a$ 变为全 $1$。

若初始为全 $0$，显然不合法。下面讨论有至少一个 $1$ 的情况。

在求最小操作次数前，不妨考虑构造一个可行的策略。

考虑只有一个 $1$ 的最劣情况，此时我们第一次操作可以得到两个 $2$，接下来是 $4$ 个、$8$ 个……

于是最小操作次数 $\leq \lceil \log_2 n \rceil$，我们可以将 $k$ 与此取较小值。

考虑 dp，设 $dp_{i, l, r}$ 表示操作 $i$ 次使得 $[l, r]$ 全 $1$ 是否可行。

但直接区间 dp 转移的时间复杂度为 $O(n^3 \min(k, \log n)^2 \log n)$，显然不能通过。

注意到我们只关心最大且合法的 $r$，改设 $dp_{i, l}$ 表示操作 $i$ 次可能得出的最大 $r$，使得 $[l, r]$ 全 $1$。

但仍直接区间 dp 转移的时间复杂度为 $O(n^2 \min(k, \log n)^2 \log n)$，还是不能通过。

考虑发掘最优操作的性质。下设操作序列为 $[l_1, r_1], [l_2, r_2], \cdots, [l_m, r_m]$，$sum([l, r])$ 表示区间 $[l, r]$ 中 $1$ 的个数减去 $0$ 的个数。

- **不存在**两个操作区间，使得其**相交但不包含**。

证明：设存在这样两个区间 $i < j, [l_i, r_i], [l_j, r_j]$，则我们把后者改为 $[\max(l_i, l_j), \min(r_i, r_j)]$ 仍合法且不劣。

- 操作区间间一定互相**包含**。

证明：

- 刚刚已经证明了相交一定包含，考虑证明操作区间两两相交。
- 考虑最后两个不相交的区间 $[l_i, r_i], [l_{i + 1}, r_{i + 1}]$，由于让 $[l_m, r_m] = [1, n]$ 不劣，我们一定可以找到 $j \in (i + 1, m]$，使得 $[l_i, r_i] \subseteq [l_j, r_j]$ 但 $[l_i, r_i] \not\subseteq [l_{j - 1}, r_{j - 1}]$。
- 若 $sum([l_i, r_i]) \geq sum([l_{j - 1}, r_{j - 1}])$，我们取消操作 $i + 1 \sim j - 1$，再在此处插入一个操作即可。
- 反之，我们取消操作 $i$，再在 $j - 1$ 后插入一个操作即可。
- 依次调整即可满足目标条件。

至此，考虑利用性质简化 dp 转移：

- 若 $l' \leq l, sum([l', l - 1]) + (dp_{i, l} - l + 1) + sum([dp_{i, l} + 1, r]) \geq 0$，有转移 $dp_{i + 1, l'} \leftarrow \max(dp_{i + 1, l'}, r)$。

一个简单的想法是直接上 BIT 优化，但时间复杂度为 $O(n \min(k, \log n) \log^2 n)$，依然不能通过。

考虑转移的**单调性**，注意到对于两个 $r_1 < r_2$，若 $sum([1, r_1]) \leq sum([1, r_2])$，则 $r_1$ 无用。

遂考虑单调队列优化。下设 $zero_i$ 表示 $[1, i]$ 中 $0$ 的个数。

我们从后到前处理每个 $l'$，维护同时按 $zero_{l - 1} - zero_{dp_{i - 1, l}}$ 和 $dp_{i - 1, l} - 2zero_{l - 1}$ 排序的单调队列，每次在 $zero_{l - 1} - zero_{dp_{i - 1, l}}$ 不大于队尾的情况下插入当前 $l$，接着在单调队列中移动指针找到最大 $p$ 使得 $l' - 2 zero_{l'} < dp_{i - 1, p} - 2zero_{p - 1}$ 即可。

由于 $l' - 2 zero_{l'}$ 在 $l'$ 每次减小 $1$ 的过程中的变化是 $O(1)$ 的，我们每次只会在单调队列中移动 $O(1)$ 次指针，则时间复杂度为 $O(n \log^2 n)$，可以通过。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

int head, tail;
int a[400007], b[400007], c[400007], dp[27][400007], zero[400007], suf[2000007], f[400007], val2[400007], val1[400007], q[400007];

inline bool check(int n, int m, int k){
	for (int i = 1; i <= n; i++){
		c[i] = a[i] >= k ? 1 : 0;
	}
	for (int i = n; i >= 1; i--){
		if (c[i] == 0){
			dp[0][i] = 0;
		} else {
			dp[0][i] = c[i + 1] == 0 ? i : dp[0][i + 1];
		}
	}
	if (dp[0][1] == n) return true;
	for (int i = 1; i <= n; i++){
		zero[i] = zero[i - 1] + (c[i] ^ 1);
	}
	for (int i = -n * 2; i <= n * 3; i++){
		suf[i + n * 2] = 0;
	}
	for (int i = 1; i <= n; i++){
		f[i] = i - zero[i] * 2;
		suf[f[i] + n * 2] = max(suf[f[i] + n * 2], i);
	}
	for (int i = n * 3; i >= -n * 2; i--){
		suf[i + n * 2] = max(suf[i + n * 2], suf[i + n * 2 + 1]);
	}
	for (int i = 1; i <= m; i++){
		for (int j = 1; j <= n; j++){
			val1[j] = (zero[j - 1] - zero[dp[i - 1][j]]) * 2;
			val2[j] = dp[i - 1][j] - zero[j - 1] * 2;
		}
		head = 1;
		tail = 0;
		for (int j = n; j >= 1; j--){
			if (head > tail || val1[q[tail]] >= val1[j]){
				while (head <= tail && val1[q[tail]] >= val1[j]) tail--;
				q[++tail] = j;
			}
			while (head > 1 && f[j - 1] < val2[q[head - 1]]) head--;
			while (head <= tail && f[j - 1] >= val2[q[head]]) head++;
			if (head <= tail){
				dp[i][j] = suf[val1[q[head]] + (j - zero[j - 1] * 2) + n * 2];
			} else {
				dp[i][j] = 0;
			}
		}
		if (dp[i][1] == n) return true;
	}
	return false;
}

int main(){
	int n, k, m, l = 1, r, ans;
	cin >> n >> k;
	k = min(k, (int)ceil(log2(n)));
	for (int i = 1; i <= n; i++){
		cin >> a[i];
		b[i] = a[i];
	}
	sort(b + 1, b + n + 1);
	m = unique(b + 1, b + n + 1) - b - 1;
	for (int i = 1; i <= n; i++){
		a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
	}
	r = m;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (check(n, k, mid)){
			l = mid + 1;
			ans = mid;
		} else {
			r = mid - 1;
		}
	}
	cout << b[ans];
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：3)

首先二分变成 $-1,1$ 序列。一次操作合法当且仅当区间内数字和 $\geq 1$。

最优的操作序列应当有以下的性质：

> **性质1**：每一次操作对固定的 $l$ 肯定会取最大的合法的 $r$。

证明不难。

> **性质2**：两个操作区间要么不相交，要么包含。
>
> **证明**：反之，不包含但相交的区间 $p,q$ 先后操作，那么由性质 $1$，$q$ 延展到包含 $p$ 肯定更优。矛盾。

我们再大胆猜测：

> **猜测**：两个操作不会不相交。

感性理解，不难证明。

> **性质3**：操作要么不可能，要么是 $\log n$ 级别的。

证明不难。

有了以上猜想，我们只要关系第 $i$ 次操作完后的 $l,r$ 即可。定义 $f_{i,l,r}$ 表示第 $i$ 次操作是否能到区间 $[l,r]$。时间复杂度 $>\mathcal O(n^2\log n)$。

注意到性质 $1$，我们只需要关心最大的 $r$ 使得 $f_{i,l,r}=1$，可以缩掉一维：重新定义 $f_{i,l}$ 表示最大的 $r$ 使得 $f_{i,l,r}=1$。定义一个其贡献 $val_{i,l}=f_{i,l}-l+1-s_{f_{i,l}}+s_{l-1}$。

那么 $f_{i,l}$ 的转移是枚举 $l'\geq l$，寻找下标最大的前缀和为 $s_{l-1}+1-val_{i-1,l}$ 的下标 $i$。如果 $i\geq f_{i-1,l'}$ 那么转移合法。单点时间复杂度是 $\mathcal O(n^2)$，总的时间复杂度是 $\mathcal O(n^2\log^2 n)$。

注意到决策点单调可以做到 $\mathcal O(n\log^3 n)$，单调栈维护还可以做到 $\mathcal O(n\log ^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
const int MAXN=4e5+5;
int n,k;
int a[MAXN],s[MAXN],f[MAXN];bool mark[MAXN];
int pos[MAXN<<1];
int val[MAXN],sit[MAXN];int hd,tl;
bool check(int x){
	for(int i=1;i<=n;i++) s[i]=s[i-1]+(a[i]>=x?1:-1);
	memset(pos,0,sizeof(pos));memset(mark,0,sizeof(mark));
	for(int i=1;i<=n;i++) f[i]=i-1;
	for(int i=1;i<=n;i++) pos[s[i]+n]=i;
	for(int i=2*n;i>=0;i--) pos[i]=max(pos[i],pos[i+1]);
	for(int i=1,lim=1e9;i<=n;i++) if(s[i-1]<lim){mark[i]=1;lim=s[i-1];}
	for(int _=1;_<=k&&_<=25;_++){
		hd=1,tl=0;
		for(int i=n;i>=1;i--) if(mark[i]){
			int v=(f[i]-i+1)-(s[f[i]]-s[i-1]);
			while(hd<=tl&&val[tl]<v) tl--;
			++tl;val[tl]=v,sit[tl]=f[i];
			while(hd<=tl){
				int p=pos[max(0,s[i-1]+1-val[hd]+n)];
				if(p>=sit[hd]){f[i]=p;break;}
				hd++; 
			}
		}
		if(f[1]==n) return true;
	}
	return false;
} 
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	if(k==0){
		int ans=1e9;
		for(int i=1;i<=n;i++) ans=min(ans,a[i]);
		cout<<ans;return 0;
	}
	int l=0,r=1e9,mid;
	while(l<r){
		mid=l+r+1>>1;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：RockyYue (赞：1)

> Trick:
>
> 1. 对于一个阈值 $k$，将序列中 $\ge k$ 的位看作 $1$，$>k$ 的部分看作 $0$ 处理（$=k$ 依具体情况决定是 $1$ 还是 $0$）。
>
> 这样做适用于在序列上执行若干次操作（可以固定方案求操作结果也可以寻找最优方案），$0/1$ 是为了简化操作过程，减少情况数，对应的条件除复杂度外还有通过新序列中的 $0/1$ 判断操作后每一位是 $0$ 还是 $1$。本题和 [AGC006D](https://www.luogu.com.cn/problem/AT_agc006_d) 中的将区间中所有数改为区间中位数，和 [CF1558F](https://www.luogu.com.cn/problem/CF1558F) 中每次操作交换若干对的相邻两位（即比较大小），便是很好的例子。
>
> 这里 $k$ 的获取方式通常有两种，一种是二分，需要有单调性同时要在合适的复杂度内对任意一个 $0/1$ 序列求解；另一种是枚举 $k$，范围是序列中的每一位按照升序或降序，好处是每次改变 $k$ 时序列中只会有一位进行改变，而且改变方式相同（均为 $0$ 到 $1$ 或 $1$ 到 $0$），可以在修改的同时维护答案（CF1558F）。
>
> 2. 转移区间呈包含：状态设计改为固定左端点右端点的状态。
> 3. 有多组单调关系：分析每个值是否单调，考虑二分/单调队列维护。

利用 Trick1，考虑二分出阈值 $m(m\in a)$，将 $a$ 写作 $0/1$ 序列 $b$，判断是否可以在 $k$ 次操作内将 $b$ 全部变成 $1$，答案即为满足条件的最大的 $m$。

接下来考虑如何判断。这个“$k$ 次操作”难于判断，最简单的方法便是正向模拟操作，记录每次操作后的状态，每次操作在之前的基础上操作。于是设 $f_{i,l,r}$ 表示前 $i$ 次操作能否将 $b_{[l,r]}$ 变为 $1$，达到这个状态，分以下三种情况：

1. 前 $i-1$ 次时就可以达到，即 $f_{i,l,r}\stackrel{\lor} \longleftarrow f_{i-1,l,r}$；
2. 将 $[l,r]$ 分成若干个子段每段分别操作，$f_{i,l,r}\stackrel{\lor}\longleftarrow f_{j,l,p}\land f_{i-j,p+1,r}(0\le j\le i,l\le p\le r)$；
3. 无需分段，一次到位，即 $f_{i,l,r}\stackrel{\lor} \longleftarrow [(\sum_{j=l}^{r}[b_i=1])>(\sum_{j=l}^{r}[b_i=0])]$。

这样转移是 $O(kn^4)$ 的，我们发现若可以成功操作，则操作次数其实不会超过 $\lceil \log n\rceil$。可以操作，则第一步可以将 $b$ 中长度至少为 $3$ 的一段变为全 $1$，后面每次将这一段拓展，由长度为 $l$ 拓展到 $2l-1$，即可在 $\lceil \log n\rceil$ 次内完成操作。

这不仅可以将上述算法优化到 $O(n^4)$，还启示我们一段连续的长度为 $l$ 的 $1$，其一次操作拓展后的长度至少为 $\min\{2l-1,n\}$，这里“至少”是因为这一段中可能还有 $1$。再看到上面的转移式，发现情况 $2$ 既然是两段合并，必然不优于其中长度较大的一段上操作一次后的情况（$j=0/i$，即两段中一段初始即为全 $1$ 的情况除外），于是情况 $2$ 可以转化为 $f_{i-1,l,r}$ 向 $f_{i,l',r'}(l'\le l,r'\ge r,l'\neq l\lor r'\neq r)$，于是有结论：所有操作区间呈包含关系。

同时，若 $f_{i,l,r-1}=1$，$f_{i,l,r}$ 必然为 $1$，那么我们只需要关心对于固定的 $i$ 和 $l$，使得 $f_{i,l,r}=1$ 的最大的 $r$ 即可，于是改变状态设计，令 $f_{i,l}$ 表示上述的 $r$。

以现在的视角再来判断前 $i$ 次操作能否将 $b_{[l,r]}$ 变为 $1$，即是否有 $f_{i,l}\ge r$，只考虑恰好 $i$ 次完成的情况。我们需要知道 $i-1$ 次操作的区间是什么。根据之前的结论，这一定是 $[l,r]$ 的子区间。同时若固定起点，操作的必然是极长的区间，所有此区间为 $[p,f_{i-1,p}](l\le p\le f_{i-1,p}\le r)$，需要满足 $[l,r]$ 内 $1$ 的个数 $>$ $0$ 的个数，即 $(\sum_{i=l}^{r}[b'_i=1])-(\sum_{i=l}^{r}[b'_i=0])>0$，其中 $b'$ 为 $b$ 在 $f_{i-1,p}$ 对应操作方案下经过前 $i-1$ 次操作后的样子。考虑 $b'$ 的形态，对于 $i\in [1,n]-[p,f_{i-1,p}]$，必然有 $b'_i=b_i$（因为操作区间呈包含），而又 $b'_{[p,f_{i-1,p}]}=1$，这个条件就可以表示了。

设 $s_i$ 为 $b$ 中前 $i$ 位 $1$ 的个数减去 $0$ 的个数，则条件可以转化为 $(f_{i-1,p}-p+1)+((s_r-s_{l-1})-(s_{f_{i-1,p}}-s_{p-1}))>0$，$f_{i,l}\ge r$ 的条件即为存在 $l\le p\le f_{i-1,p}\le r$ 使得 $p$ 满足上述条件。前面括号是中间一段 $1$，后面一段是除了中间这段的部分中 $1$ 比 $0$ 多的个数。考虑如何快速对于一组 $i,l$，最大的满足条件的 $r$。以下为方便表示，记在 $i$ 条件下，$v(p)=(f_{i-1,p}-p+1)-(s_{f_{i-1,p}}-s_{p-1})$。

考虑把 $p$ 也确定下来，式子可以写成 $s_r>-v(p)+s_{l-1}$。于是预处理 $g_{i}$ 为最大的 $r$ 使得 $s_r\ge i$，记录 $R(l,p)=g_{-v(p)+1+s_{l-1}}$（$i$ 省略），即以 $l$ 为第 $i$ 次操作区间左端点，第 $i-1$ 次操作区间为 $[p,f_{i-1,p}]$ 的 $l$ 对应的最大的 $r$。这样有 $f_{i,l}=\max_{l\le p\le f_{i-1,p}\le R(l,p)}\{R(l,p)\}$。现在复杂度优化到 $O(n^2)$。

发现若存在 $p<q$ 且 $s_p\ge s_q$，则对于任意一个 $\ge q$ 的操作区间右端点 $r$，$q$ 不可能成为其对应的左端点，因为 $b_{[p+1,q]}$ 中 $1$ 个数不比 $0$ 少，若操作 $[q,r]$ 合法则 $[p,r]$ 也合法，与 $[q,r]$ 为可操作极长区间矛盾。于是可能对转移有贡献的 $p$，必然满足 $s_{p-1}<\min_{j=0}^{p-2}\{s_j\}$，我们在这些 $p$ 中考虑选取哪一个进行转移。

转移的难点在于，不仅要使 $R(l,p)$ 尽量大，还要使其 $\ge f_{i-1,p}$，这个要求是与 $p$ 相关的。有 $R(l,p)=g_{s_{l-1}-v(p)+1}$，$g$ 是单调不降的，则 $s_{l-1}-v(p)+1$ 越大，$R(l,p)$ 越大。转移时 $l$ 确定，需要查询满足 $l\le p\le f_{i-1,p}\le R(l,p)$ 且 $v(p)$ 最小的 $p$ 进行转移。

发现限制 $p$ 范围的部分与 $l$ 唯一相关的就是 $g$ 下标中的 $s_{l-1}$。根据之前的结论我们知道这个值随 $l$ 的增加单调递增，即 $R(l,p)$ 随 $l$ 的增加单调递增（准确来说是在满足上面关于 $s$ 条件的 $p$ 中转移的情况下），即若 $R(l,p)$ 满足要求，$R(l+1,p)$ 必然满足要求，若 $R(l,p)$ 不满足，则 $R(l,p-1)$ 必然不满足。于是考虑倒序枚举 $l$ 进行转移，$p$ 可以用单调队列维护，具体维护方式：

- 得到维护的 $p$ 需要满足 $s$ 的要求； 

- 队尾弹出不优的 $p$。若存在 $p<q$ 且 $v(p)\ge v(q)$，则有 $R(l,p)\ge R(l,q)$，即 $p$ 对应的操作区间完全包含了 $q$ 对应的操作区间，选择 $p$ 必然是更优的，这种情况下选择弹出 $q$；

- 队头弹出不合法 $p$，即若对于当前 $l$ 有 $R(l,p)<f_{i-1,p}$，$p$ 直接弹出；
- 最后用队头的 $p$ 转移当前 $f_{i,l}$ 即可。

综上，算法完成，复杂度 $O(n\log n)$，带有 $20$ 倍的常数（枚举操作次数 $i$），$\log n$ 是二分阈值的部分。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e5 + 5, K = 20;
int n, k, a[N], b[N];
int s[N], q[N], val[N], g[N << 1], f[K][N];	// q 维护 p，val 维护对应 p 的 v(p)
bool chk(int m) {
	for (int i = 1; i <= n; ++i) s[i] = s[i - 1] + (a[i] >= m ? 1 : -1);
	int mins = 1e9;
	vector<int> S;	// S 中的值满足上文“s的要求”，即会作为 p 在单调队列中维护
	for (int i = 1; i <= n; ++i) {
		if (s[i - 1] < mins) mins = s[i - 1], S.push_back(i);
	}
	reverse(S.begin(), S.end()); // 转移时倒序枚举 l
	memset(g, ~0x3f, sizeof g);
	for (int i = 1; i <= n; ++i) g[s[i] + n] = i;
	for (int i = (n << 1); i >= 0; --i) g[i] = max(g[i], g[i + 1]);
	memset(f, 0, sizeof f);
	for (int i = 1; i <= n; ++i) f[0][i] = i - 1;
	for (int i = 1; i <= k && i <= 19; ++i) {
		int head = 1, tail = 0;
		for (int l : S) {
			int v = (f[i - 1][l] - l + 1) - (s[f[i - 1][l]] - s[l - 1]);
			while (head <= tail && val[tail] <= v) --tail;
			val[++tail] = v, q[tail] = l;
			bool flg = 0;
			while (head <= tail) {
				int p = q[head], r = g[max(s[l - 1] - val[head] + 1 + n, 0)];
				if (r >= f[i - 1][p]) {
					f[i][l] = r;
					break;
				}
				++head;
			}
		}
		if (f[i][1] == n) return 1;
	}
	return 0;
}
signed main() {
	ios :: sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = a[i];
	sort(b + 1, b + n + 1);
	int l = 1, r = n, t = 1;	// 注意 t 最小是 1
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (chk(b[mid])) t = mid, l = mid + 1;
		else r = mid - 1;
	}
	cout << b[t] << '\n';
	return 0;
}
```



---

## 作者：pikiuk (赞：1)

考虑二分，将问题转为 $01$ 序列，能对一个区间操作当且仅当 $1$ 的个数多于 $0$ 的个数，每次操作会把该区间所有数字变为 $1$，目标是判断能否在 $k$ 次操作内把所有数字变为 $1$。

考察操作序列 $I_1,I_2\dots,I_e$，不难发现如下性质：

- 每次操作的区间尽可能的大。
- 由上述性质可以发现，我们每次选择的区间必然导致区间内 $1$ 的数量翻倍，因此操作轮数不多于 $\log n$ 轮。
- 注意到总是存在一种方案把两个不交的区间替换为操作次数更少的包含区间，因此 $I_{1\sim e}$ 满足 $I_1\subset I_2\subset I_3\subset \dots\subset I_e$。

由此我们可以有以下做法：

考虑维护 $f(i,l)$ 表示第 $i$ 轮过后，所能操作的左端点是 $l$，右端点 $r$ 的最大值。

转移选取 $p$ 满足 $[p,f(i-1,p)]\subset [l,f(i,l)]$ 且 $s_r-s_{l-1}+c(I_p)>0$。

也就是 $s_r\leq s_{l-1}-c(I_p)+1$。

显然，$r$ 越大越好，因此我们记 $g(i)$ 表示最大的 $x$ 满足 $s_x\geq i$。

对 $l$ 做扫描线，维护所有 $p\geq l$ 的 $f(i-1,p)$，那么应该有 $g(s_{l-1}-c(I_p)+1)>f(i-1,p)$。

注意到该过程中若存在 $q>p$ 满足 $c(I_q)\leq c(I_p)$，那么 $[q,f(i-1,q)]$ 显然是无用的。

因此我们维护的可能的转移点 $p$ 总是有 $c(I_p)$ 单调递减，那么显然，对于同一个 $l$，$g(s_{l-1}-c(I_p)+1)$ 是也单调递减的，这符合单调队列的结构，每次从队尾找到第一个满足条件的答案即可。

可惜的是，这样在 $l\to l-1$ 的时候并不能很好的维护这个单调性。

注意到另一个事实，存在 $p<q$ 且 $s_{p-1}>s_{q-1}$ 时，$q$ 不会成为任意一次操作的右端点。

因此，在 $l\to l-1$ 的过程中，$s_{l-1}$ 总是单调递增的，那么对于同一个 $p$，$g(s_{l-1}-c(I_p)+1)$ 总是单调递减的。那么我们就可以及时弹出队尾，只保留最后的答案。

---

## 作者：Acoipp (赞：1)

## 题目大意

给定长度为 $n$ 的序列 $a$，每次可以选择一个长度为 $l$ 的子串，将这个子串内的数修改为子串中排名第 $\lceil \dfrac{l}{2} \rceil$ 的数，问最后数组最小的最大值是多少。

## 分析

首先很明显的，我们可以二分 $x$，转化为判定性问题，所有 $a_i \ge x$ 的 $a_i$ 修改为 $1$，否则修改为 $-1$，然后贪心地操作一个和 $\ge 1$ 的区间，让区间内的所有数变为 $1$。

最后要求整个序列变为 $1$ 的最小操作次数 $\le k$。

然后我们需要发现一些性质，设我们操作的区间依次为 $[l_1,r_1],[l_2,r_2],\dots,[l_p,r_p]$ ，则：

1. 不会有两个区间相交但不包含。

如果存在 $[l_j,r_j]$ 和 $[l_k,r_k]$ 两个区间不包含但相交，我们可以让 $[l_k,r_k] \gets [\min(l_j,l_k),\max(r_j,r_k)]$，那么由题意得修改后的操作序列依然合法，并且可能会更优。

2. 不会有两个区间没有交集。

这个条件可以调整法解决，这里就不详细描述了，反正我是感性理解，需要理性理解的可以看看 Alex_Wei 大佬的博客。

3. 如果有合法操作序列，序列长度 $\le \lfloor \log_2 n \rfloor$。

这个也比较显然，每次操作一定要找到最长的区间使得 $-1$ 和 $1$ 的差值最小，并且尽可能相等，则 $1$ 的个数会一直 $\times 2$，则可以证明这点。

然后我们可以开始处理问题了。

## 处理

由性质 3，我们可以设计状态 $dp_{i,l,r}=0/1$，表示用 $i$ 次操作能否使得 $[l,r]$ 区间为 $1$。

又由性质 1 得，如果存在 $dp_{i,l,r}=dp_{i,l',r'}$ 且 $l = l' \le r' \le r$，那么 $dp_{i,l',r'}$ 无效。

故我们可以转化状态为 $dp_{i,l}$ 表示用 $i$ 次能够使得 $[l,dp_{i,l}]$ 全部为 $1$ 最大的 $dp_{i,l}$ 是多少。

考虑从 $i-1$ 的所有状态转移到 $i$ 的所有状态，则我们把所有 $[j,dp_{i-1,j}]$ 这样的区间拿出来到集合 $S$ 里面，然后如果有区间包含关系，根据性质 1，可以省略小的区间，则剩下的区间从左到右左右端点都递增。

然后考虑维护第 $i$ 次的信息，则 $dp_{i,j}$ 的值为 $[l,r]\in S$ 且存在 $k \ge r$ 满足 $[j,k]$ 这段区间在 $[l,r]$ 这段区间都变为 $1$ 后 能够一次全部变为 $1$，此时 $dp_{i,j} = k$。形式化表述就是设 $s_i$ 为修改后 $a_i$ 的前缀和数组，若设 $val_{l,r}=r-l+1-(s_r-s_{l-1})$（$val$ 数组为这一段区间全部变为 $1$ 后与修改前的和的差值），则需要找到最大的满足 $i \le l \le r \le k([l,r] \in S)$ 且 $s_k-s_{i-1}+val_{l,r} \ge 1$ 的最大的 $k$。

那么我们考虑到这么一种情况 $[l,r] \in S$ 且 $[l',r'] \in S$ 且 $l<l',val_{l,r} \ge val_{l',r'}$，那么 $[l',r']$ 一定不会被我们选择，于是可以用一个单调栈来维护可能被我们选择的线段的集合。

于是扫描线 $j$ 从 $n$ 枚举到 $1$，然后均摊 $O(n)$ 的添加线段。

每次暴力枚举这个可选的集合时间肯定会超，我们就考虑继续优化状态：

> $s_k-s_{i-1}+val_{l,r} \ge 1$ 可以写作 $val_{l,r}-s_{i-1}+1 \le s_k$。

因为 $val_{l,r}$ 单调，且 $k$ 在 $[l,r]$ 的选择内也单调（因为 $r$ 单调），则我们现在要让 $s_{i-1}+1$ 也单调，这样的话我们把单调栈换成单调队列，每次队尾插入，队首遇到不合法的弹出即可。

又因为如果存在 $j,k$ 满足 $j<k$ 且 $s_{j-1}<s_{k-1}$，则 $s_{k-1}$ 的决策一定也存在于 $s_{j-1}$ 的决策当中，因为性质 1，故 $k$ 不需要进行任何处理。这样的话 $s$ 数组就是单调下降的了。

用单调队列维护决策，$s_k$ 用 $g_i$ 表示 $s_j \ge i$ 最大的 $j$ 即可，于是时间复杂度为 $O(n \log^2 n)$。

附：性质 2 则满足了这个 dp 的正确性，因为只会一层一层往外枚举而不会有两个不相交的段合并的情况。

## 代码

```cpp
#include<bits/stdc++.h>
#define N 800005
using namespace std;
struct node{int x,y,z;}p[N],p2[N];
int n,K,a[N],b[N],s[N],i,j,k,l,r,mid,to[N],vis[N],qzh[N],tot,tot2,nowy,q1[N],q2[N],h,t;
inline bool check(int x){
	for(i=0;i<=2*n;i++) qzh[i]=-1;
	for(i=1;i<=n;i++){
		if(a[i]>=x) b[i]=1;
		else b[i]=-1;
		s[i]=s[i-1]+b[i];
		qzh[s[i]+n] = i;
	}
	for(i=2*n-1;i>=0;i--) qzh[i]=max(qzh[i],qzh[i+1]);
	tot = 0;
	for(i=1;i<=n;i++){
		if(b[i]==1) p[++tot] = (node){i,i,0},to[i] = i;
		else to[i] = -1;
	}
	for(i=1;i<=20;i++){
		int temp = 1e9;
		h=1,t=0;
		for(j=1;j<=n;j++) vis[j]=0;
		for(j=1;j<=n;j++){
			if(temp<=s[j-1]) vis[j]=1;
			temp = min(temp,s[j-1]);
		}
		for(j=n,k=tot;j>=1;j--){
			if(vis[j]){
				to[j] = -1;
				continue;
			}
			while(k>=1&&p[k].x>=j){
				while(h<=t&&q1[t]<=p[k].z) t--;
				t++,q1[t]=p[k].z,q2[t]=p[k].y;                 
				k--;
			}
			while(h<=t&&qzh[max(0,s[j-1]+n-q1[h]+1)]<q2[h]) h++;
			if(h<=t) to[j] = qzh[max(0,s[j-1]+n-q1[h]+1)];
			else to[j] = -1;
		}
		tot = 0;
		for(j=1;j<=n;j++) if(to[j]!=-1) p[++tot] = (node){j,to[j],to[j]-j+1-(s[to[j]]-s[j-1])};
		tot2 = 0;
		if(tot){ 
			p2[++tot2] = p[1],nowy = p[1].y;
			for(j=2;j<=tot;j++){
				if(nowy<p[j].y){
					nowy = p[j].y;
					p2[++tot2] = p[j];
				}
			}
		} 
		tot = tot2;
		for(j=1;j<=tot;j++) p[j]=p2[j];
		if(to[1]==n) return i<=K;
	}
	return 0;
}
int main(){
	ios::sync_with_stdio(false);
	int ans = 0x3f3f3f3f;
	cin>>n>>K;
	for(i=1;i<=n;i++) cin>>a[i],ans=min(ans,a[i]);
	if(K==0){
		cout<<ans<<endl;
		return 0;
	}
	l=0,r=1e9;
	while(l<r){
		mid=(l+r+1)/2;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l<<endl;
	return 0;
} 
```

## 后记

最后这道题真的是一道非常好的题目，细节不多，代码力需求不大，思维和理论分析还有猜结论比较重要，值得一做！

---

## 作者：OrientDragon (赞：0)

# 题目大意

给你一个 $n$ 长度序列 $a$，你有 $\le k$ 次操作，每次可以选定 $[l,r]$，使他们变成区间内第 $\lceil \dfrac{r-l+1}{2} \rceil$ 小的数。问操作后，全局最小值最大是多少。

# 分析

## 性质观察

首先，既然问到了“…… **最小值最大**” 肯定要用到二分答案。那么我们考虑如何检查是否存在最小值 $\ge \text{mid}$ 的做法。

我们不妨将 $\ge \text{mid}$ 的部分重赋权为 $1$，$< \text{mid}$ 的部分重赋权为 $-1$。则若要操作 $[l,r]$，必须满足区间权值和 $\text{S}(l,r)>0$。

如何找有没有这样的区间呢？我们发现，如果存在 $101$ 或 $11$ 这两个结构，可以从它们往两边扩展。反之，则无解。

我们设操作区间序列是 $[l_1,r_1] \sim [l_m,r_m]$，则这些区间有什么性质呢？

---

> 引理 $0$：如果同时出现 $A=[l_{c_1},r_{c_1}]$ 和 $B=[l_{c_2},r_{c_2}]$ 两个区间可操作，且 $A \subseteq B$，则显然 $B$ 更优。

证明：显然。

---

> 引理 $1$：$m$ 是 $\mathcal O(\log n)$ 级别的。

> 引理 $1$ 推论：每回操作区间 $\text{S}(l_i,r_i)=1$。

证明：每回操作最优是选择 $a$ 个 $1$，$a-1$ 个 $0$。也就是说，能让 $1$ 的数量几近翻倍。

---

> 引理 $2$：从一个区间开始一直扩展是最优的。也就是说，所有操作区间均有包含关系。

证明：先考虑朴素 dp + 调整法。

设 $\text{dp}_{i,l,r}$ 表示通过 $i$ 步操作使得 $[l,r]$ 区间变为全 $1$ 是否可行。那么有

$$\text{dp}_{i,l,r} \longleftarrow \text{dp}_{x,l,k} \operatorname{and} \text{dp}_{y,k+1,r}$$

其中 $l \le k < k+1 \le r$，并且 $x+y=i$。

我们令 $\text{len}(l,k)\le \text{len}(k+1,r)$，显然这个转移可以仅由右区间扩展一次而做到更优。

以此递归，总能调整到仅由一侧转移。

---

性质已经观察完毕，现在考虑做法。

## dp 优化 part 1

上面说过了一种朴素 dp，但是由于我们的 dp 存的是“是否可达”，也就是一个 $0/1$ 值，非常垃圾。

而又有 **引理 $0$**，所以我们其实对于一个固定的 $l$，只关心 $\max\{r|\text{dp}_{i,l,r}=1\}$。

那么我们可以考虑 **值域定义域互换**，也即：

> 设 $\text{dp}_{i,l}$ 表示通过 $i$ 次操作，最多能使 $[l,\text{dp}_{i,l}]$ 区间全为 $1$。

现在我们的状态数是 $\mathcal O(n \log n)$ 的（由 **引理 $1$**）。但是如何转移呢？

先考虑两个 dp 状态：$\text{dp}_{j,p}$ 和 $\text{dp}_{j,q}$。

如果 $[p,\text{dp}_{j,p}] \subseteq [q,\text{dp}_{j,q}]$，那么由 **引理 $0$**，前一个状态就是废物。

所以对于任意的 $p>q$，如果 $\text{dp}_{j,p}\le \text{dp}_{j,q}$，那么这个 $p$ 无用。所以我们关心的状态满足：

$$\forall p>q,\text{dp}_{j,p}>\text{dp}_{j,q}$$

这个东西意味着左右端点单调递增。

我们设 $\text{con}(l,r)=\text{len}(l,r)-\text{S}(l,r)$，也就是当前操作 $[l,r]$ 的贡献。那么我们在转移 $\text{dp}_{i,l}$ 的时候，也就是要找到一个 $\text{con}_{\max}$，使得 $\text{S}(l,r)+\text{con}_{\max} > 0$。

> 这个式子等价于 $\text{pre}_r-\text{pre}_{l-1}+\text{con}_{\max}>0$，也即 $\text{pre}_{l-1}-\text{con}_{\max}<\text{pre}_r$。

由 **引理 $2$**，我们找的这个 $\text{con}_{\max}$ 一定来自某个 $[j,\text{dp}_{i-1,j}] \subseteq [l,\text{dp}_{i,l}]$。

这样单次转移时间复杂度还是很高。

## dp 优化 part 2

依旧从后往前扫。考虑是否能用决策单调性优化。

对于当前区间 $[l_x,r_x]$，它的贡献是 $\text{con}(l_x,r_x)$。在扫描过程中加入它，意味着 $\forall l'>l_x \land \text{con}(l',r')<\text{con}(l_x,r_x)$ 的 $[l',r']$ 都是废物。

> 证明：由于单调性，$l'>l_x \iff r'>r_x$。进而地，对于之后的转移（也就是 $\text{dp}_{i,L}$，其中 $L<l_x$）肯定是选 $[l_x,r_x]$，因为它 **更容易被全包含，并且贡献更大**。

所以说，$\{l_x,r_x,\text{con}(l_x,r_x)\}$ 这三个东西全部都是满足单调性的（**单增，单增，单减**）。这就启示我们用**单调队列**。

我们在更新 $\text{dp}_{i,L} \leftarrow Q$ 的时候，要找到队列中：

+ $\text{pre}_{L-1}-\text{con}(l',r')<\text{pre}_Q$
+ $Q \ge r'$
+ 满足条件，最靠右的区间。

> 简单论述正确性。
>
> 第一个限制同 part 1 里面的式子。发现这样的东西能保证 $[l',r']$ 能转移到 $[L,Q]$。
>
> 第二个限制表明了 $r' \le Q$。这个就限制了全包含。
>
> 第三个限制确定了 $\text{dp}_{i,L}$ 能被最大的 $Q$ 更新。

我们充分发扬人类智慧，发现可以预处理：

> $f(i)$ 表示 $\text{pre}_x \ge i$ 的最大 $x$。

那么我们发现 $Q$ 满足 $\text{pre}_Q \ge \text{pre}_{L-1}-\text{con}(l',r')+1$，并且 $Q \ge \text{dp}_{i-1,L}$。这个等价于：

$$f(\text{pre}_{L-1}-\text{con}(l',r')+1) \ge \text{dp}_{i-1,l'}$$

$f(i)$ 随着 $i$ 的 $\uparrow$ 而 $\downarrow$（约束太严了，满足条件位置个数变少，最大 $x$ 有可能变小），**单调递减**。$-\text{con(l',r')+1}$ **单调递增**。还差一个 $\text{pre}_{L-1}$。

其实也好搞。考虑 $p<q \land \text{pre}_{p-1} \le \text{pre}_{q-1}$，则 $[p,r]$ 优于 $[q,r]$。

> 证明：考虑 $[p,q-1]$ 肯定是 $1$ 多于 $0$ 的，所以说前者合法，且由 **引理 $0$**，后者是废物。

那么可操作区间满足 $\forall p<q, \text{pre}_{p-1}>\text{pre}_{q-1}$。所以 $\text{pre}_{L-1}$ 随着 $L\downarrow$ 而单调递增。

这样，$f(x\uparrow)\downarrow$。所以用单调队列维护就行啦~

# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=400005;
int n,k,a[N],b[N],data[N];
int dp[N],q[N],val[N],f[N<<1],head,tail;
// dp 压掉第一维
// f 二倍空间，因为考虑负数下标需要偏移值
bool vis[N];

bool check(int mid){
	for(int i=1;i<=n;i++) // b[i] 是重赋权后的前缀和 
		b[i]=b[i-1]+(a[i]>=mid?1:-1);
	// 预处理 f 数组，开桶统计 
	memset(f,0,sizeof f); 
	for(int i=1;i<=n;i++)
		f[ b[i]+n ]=i; // f[i] 存 pre[]=i 的最大下标
	for(int i=n+n;i>=0;i--) // 改成 pre[]>=i 的最大下标 
		f[i]=max(f[i],f[i+1]);
	memset(vis,0,sizeof vis);
	for(int i=1,mx=N;i<=n;i++)
		if(b[i-1]<mx){
			mx=b[i-1];
			vis[i]=1; // 处理 pre 的单调性 
		}
	for(int i=n;i;i--) // 初始化 round = 0 的边界情况
		dp[i]=i-1;
	for(int round=1;round<=k&&1<<round-1<=n;round++){
		// 更新 dp[round][...]，注意到 round 是 O(log n) 的 
		head=1,tail=0; // 清空单调队列 
		for(int i=n;i;i--){ // 更新 dp[round][i]
			if(!vis[i])continue; // 跳过非单调部分，因为它们不可能是决策点 
			int v=dp[i]-i+1-(b[ dp[i] ]-b[i-1]);
			while(head<=tail&&q[tail]<=v)
				tail--; // 单调队列不优区间贡献 
			q[++tail]=v; // 放入 con(i , dp[round-1][i])
			val[tail]=dp[i]; // 放入左端点 dp 值，也即右端点 
			// 找到 f( pre[i-1]-con(l',r')+1 ) >= r'
			while(head<=tail){ // 单调队列取队首 
				int now=q[head],p=f[ max(0,b[i-1]-now+1+n) ]; // 注意偏移值
				if(p>=val[head]){ // 如果这个东西满足上述不等式 
					dp[i]=p; // 更新，采用最左端 
					break;
				} 
				head++;
			}
		}
		if(dp[1]==n)return round<=k; // 完成全覆盖，返回 
	}
	return 0; // 不可能规定内全覆盖 
}

signed main(){
    freopen("colorless.in","r",stdin);
    freopen("colorless.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>k;
	int mn=0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		data[i]=a[i];
		mn=min(mn,a[i]);
	}
	if(k==0){
		cout<<mn;
		return 0;	
	}
	sort(data+1,data+n+1);
	int r=unique(data+1,data+n+1)-data-1;
	int l=2,ans=1;
	while(l<=r){ // 二分答案，上边界是不同数的种数 
		int mid=l+r>>1;
		if(check(data[mid]))ans=mid,l=mid+1;
		else r=mid-1;
	}
	cout<<data[ans];
}
```

---

## 作者：Helloworldwuyuze (赞：0)

# P8978 题解

## 前言

机房模拟赛 $T4$ 放了这道题。场上获得了 $0pts$ 的好成绩，赛后听了 @一休哥777 的讲解，结合题解才大概懂了这道题。觉得思路非常的妙，同时也更加详细的解释一下这道题的原理及实现。

## Des

给定一个长度为 $n$ 的序列 $a_n$，每次操作可以使得一个区间内的数 $a_l,\dots,a_r$ 变为它们的中位数。进行不超过 $k$ 次操作，最大化 $\min a_i$。

## Sol

### Part 1 我啥也不会

首先观察样例，发现后两个样例是 $01$ 的。仔细想想中位数的性质，试着把最小化问题转换成判定问题。具体地，如果我们要判断一个序列能不能通过 $k$ 次操作把最小值变成 $x$，那么我们不妨把所有 $<x$ 的数设成 $-1$，所有 $\ge x$ 的数都设成 $1$，这样，如果最后序列可以转化成全 $1$，则一定可以把原序列转化成全都是 $x$。而如果对于一个 $x$ 是可行的，那么显然对于 $\forall y\le x$ 也都是可以的。这是因为如果 $y\le x$，序列只会在原来的基础上把一些 $-1$ 变成 $1$，而显然 $1$ 的数量越多越容易操作。

这样，这个问题就满足了二分条件的两个性质：好判定，单调性。于是，这个问题就被我们变成了：

> 给定一个只包含 $-1$ 和 $1$ 的序列，问能否通过不超过 $k$ 次操作将序列变成全 $1$。

同时，复杂度在外层已经多了一个 $\log n$。

### Part 2 我会 DP！

我们发现上一个部分撂下来的问题仍然不好处理，于是我们需要先发掘一下这个新问题的性质。

显然地，如果我们需要对一个区间操作，那么这个区间必须有 $s_r-s_{l-1}>0$。其中 $s_i$ 指的是 $-1,1$ 序列的前缀和。这是因为只有 $s_r-s_{l-1}>0$，我们才可以把这个区间变成全 $1$，否则变成全 $0$ 必然不优，还不如不操作。

为了方便表示，我们设一个区间的贡献 $v(I)$ 表示这个区间全变成 $1$ 了之后会新增多少个 $1$。其实也就是区间内 $-1$ 的个数乘以二。形式化的，我们有 $v(I)$ 的表达式：
$$
v(I) = r-l+1-(s_r-s_{l-1})
$$
其中 $I=[l,r]$。于是我们可以设一个转移方程 $f_{i,l,r}$ 表示第 $i$ 次操作能否将 $[l,r]$ 变为全 $1$。

但是，我们发现这个式子没法转移，因为我们并不知道它能够由那些状态转移过来。换句话说，什么东西会影响这个区间能否被覆盖的情况。于是，我们需要发掘性质：

> #### 性质 1
>
> 若操作区间为 $I_1,I_2,\dots,I_k$，则有 $I_1\sube I_2 \sube I_3\sube\dots\sube I_k$。
>
> > **证明**
> >
> > 1. 我们首先证明若 $I_i\cap I_j \ne \emptyset$，则必有 $I_i\sube I_j$ 或 $I_j\sube I_i$。
> >
> >    我们设 $I_i = [a,c],I_j = [b,d]$，其中 $a\le b\le c\le d$，则当操作完 $[a,c]$ 的时候，因为 $b,d$ 是可操作的，而 $[a,b]$ 又一定都是 $1$，因此我们完全可以操作 $[a,d]$ 而非 $[b,d]$。
> >
> > 2. 然后，我们证明所有区间一定有交。
> >
> >    我们设操作区间序列为 $I_1,\dots,I_k$，并找到最后一个不满足 $I_i\sube I_{i+1}$ 的点 $x$。也就是说，对于 $\forall i>x$，有 $I_i\sube I_{i+1}$。于是有 $I_{x+1}\sube I_{x+2}\sube\dots\sube I_{k}$。而 $I_k = [1,n]$，于是总 $\exist x+1\le p<k$ 使得 $I_p\cap I_x = \emptyset$ 但 $I_{p+1}\cap I_x \ne \emptyset$。又根据刚刚第一点，有 $I_{p+1}\cap I_x = I_x$。这个时候我们就分两种情况讨论一下。
> >
> >    - 若 $|I_x| \ge |I_p|$，则我们可以取消 $I_{x+1}\sim I_{p}$ 的所有区间，并加入一个新的区间 $I$ 使得 $I_x\sube I\sube I_{p+1}$。这是因为 $I_p$ 与 $I_x$ 贡献的数量不会比两倍 $I_p$ 更多。
> >    - 若 $|I_p| > |I_x|$，则类似的，我们可以取消 $I_p$，而是加入一个区间 $I$ 使得 $I_p\sube I\sube I_{p+1}$。证明类似。
> >
> >    这两种处理方式都可以减少一个不包含的区间。
> >
> > 证毕。

这个时候，我们就可以枚举所有的子区间 $[l',r']$ 来转移，具体地，有：
$$
f_{i,l,r} = \bigvee_{[l',r'] \sube [l,r]} f_{i-1,l',r'} \wedge [s_r-s_{l-1}+v([l',r'])]
$$
这个转移的方程是需要枚举 $i,l,r,l',r'$，故转移是 $O(n^5)$。期望得分：$10pts$。

### Part 3 我会优化！

写出来方程之后，显然，我们应该发掘性质并进行优化了。

>  #### 性质 2
>
> 若一个序列可以被操作成全 $1$ 状态，那么它的操作次数一定不超过 $\log n$ 次。
>
> >  **证明**
> >
> > 若一个序列可被操作成全 $1$，则它必有一个区间 $[l,r]$ 在初始的时候是可操作的。我们设这个区间长度为 $l$。那么在操作完成之后，对于 $\forall i\in[l,r]$ 都有 $a_i = 1$，因此，它可以往两边延伸总共 $l-1$ 个位置。这样，就会出现一个长度为 $2l-1$ 的全 $1$ 区间，以此类推，当 $l=n$ 的时候一定不超过 $\log n$ 次。
> >
> > 证毕

这样，第一维 $i$ 就是 $\log n$ 的量级，复杂度优化为 $O(n^4\log^2n)$。期望得分：$10pts$。

### Part 4 我还会优化！

我们突然发现，这个东西记录的信息实在是太少了！它竟然状态有三维，但是只记录了 $0$ 或者 $1$。而根据性质 1，不难发现我们要的区间越大越好，因此我们记录第 $i$ 轮左端点为 $l$ 的时候右端点最远能到哪。这样 $n\log n$ 的状态数量才看起来更有前途。

这个时候，我们枚举 $f_{i,l}$ 的答案 $r$ 并判断能否成为 $r$。我们设 $c([l,r]) = \max\limits_{i\in[l,r]}^{f_i\in[l,r]} v([i,f_i])$，于是就只需要判断 $s_r-s_{l-1}+c([l,r])$ 是否大于 $0$ 即可。这个我们可以使用 `vector` 完成一次，因此总复杂度在 $O(n^2\log^2 n)$。

（听说好像还能优化到 $n\log^3 n$，但是我不会，因此就不讲了）

### Part 5 我会单调队列！

首先，这里我们说两个单调性：

- 如果 $p<q$ 且 $f_{i,p} >f_{i,q}$，那么 $q$ 这个决策点是一定没有用处的。因为显然有 $[q,f_{i,q}]\sube [p,f_{i,p}]$。
- 如果 $p<q$，且 $c([p,f_{i,p}]) >c([q, f_{i,q}])$，则 $[q,f_{i,q}]$ 一定不会成为决策点。

考虑如何 “翻译” 这两个单调性。对于第一点，如果 $p<q$ 且 $s_p <s_q$，则说明 $s_q-s_p > 0$，因此在操作的时候，只要能操作 $p$，那么就一定包含区间 $[p,q]$，因此 $q$ 这个点是没必要操作的。换句话说，只有 $s_i = \min\limits_{j=0}^i s_j$ 的点才有可能被转移。

第二句话就是我们需要使用的单调队列。从后往前扫整个区间，我们发现如果有一个区间更靠后且权值更小，我们一定不会使用那个区间转移。而如果有一个区间我们无法通过当前的 $i$ 转移，那么在它之前的决策点，根据刚刚说的，都有 $s_i-s_j < 0$，它就更不可能成为决策点。也就是说，这决策点具有决策单调性。因此，对于被淘汰的点直接从队尾出队，对于不能再进行决策的点从队首出队，每个决策点入队出队各一次，总复杂度 $O(n\log^2 n)$。

### Part 6 我会实现！

我们首先需要统计那些决策点是有用的，即该点的前缀和是前缀和的前缀最小值的点。

然后，我们需要一个数组来记录前缀和为 $i$ 时最靠右的决策点在哪里。

记录完了之后，我们就可以通过计算区间贡献通过第二个数组来查找右端点的位置。

具体的，看代码吧。

```cpp
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
typedef pair<int,bool*> PIB;
const int N = 4e5 + 10;
const int M = 1e6 + 10;
inline int max(int x,int y){ return x<y ? y : x; }
inline int min(int x,int y){ return x<y ? x : y; }

int n, k, a[N], b[N], m;
int s[N], rk[N<<1], ri[N], val[N], tail, head, f[N];
bool tag[N];

bool chk(int x){
	for(int i=1;i<=n;++i)	s[i] = s[i-1] + (a[i] >= x ? 1 : -1);
	memset(tag, false, sizeof(tag));
	for(int i=1, tmp = INF;i<=n;++i)
		if(s[i-1] < tmp)	tmp = s[i-1], tag[i] = true;
	memset(rk, 0, sizeof(rk));
	for(int i=1;i<=n;++i)	rk[s[i] + n] = i;
	for(int i=n<<1;~i;--i)	rk[i] = max(rk[i+1], rk[i]);
	for(int i=1;i<=n;++i)	f[i] = i-1;
	for(int j=1; j<=k && (1<<j-1)<=n; ++j){
		tail = 0, head = 1;
		for(int i=n; i; --i){
			if(!tag[i])	continue;
			int v = f[i] - i + 1 - (s[f[i]] - s[i-1]);
			while(head <= tail && v >= val[tail])	--tail;
			ri[++tail] = f[i], val[tail] = v;
			while(head <= tail){
				int v = val[head], r = rk[max(0, s[i-1] + 1 - v + n)];
				if(r >= ri[head]){ f[i] = r; break; }
				++head;
			}
		}
		if(f[1] == n)	return true;
	}
	return false;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i)	cin>>a[i], b[i] = a[i];
	sort(b+1, b+1+n), m = unique(b+1, b+1+n) - b - 1;
	int l = 1, r = m;
	while(l < r){
		int mid = l+r+1>>1;
		if(chk(b[mid]))	l = mid;
		else	r = mid-1;
	}
	cout<<b[l]<<endl;
	return 0;
}
```

---

## 作者：MurataHimeko (赞：0)

其实还挺简单的（？

对于中位数相关的问题，直接套路地二分变成只有 $0,1$ 的简化版。

把 $0$ 赋值 $-1$，$1$ 赋值为 $1$，则一个区间的中位数为 $1$ 当且仅当区间和大于 $0$。

设 $pre_i$ 为上述赋值结果的前缀和。

观察到一个性质，如果存在一个区间 $[l,r]$ 使得这个区间的中位数为 $1$，那么在不超过 $\log n$ 轮后就可以把整个序列变成 $1$，因为每次可以操作的区间长度都至少乘 $2$。

进一步地，对于最优操作序列中的两个操作区间 $[l_i,r_i],[l_j,r_j] (i < j)$，一定满足 $l_j \leq l_i \leq r_i \leq r_j$。感性地理解一下，当把一个区间推平为 $1$ 时，会使得其他跟这个区间相交的其他操作区间能操作更多，而且相交就一定包含，因为这样能包含更多的 $1$。

那么就可以 dp 了，设 $f_{i,j}$ 表示操作了 $i$ 次后，第 $i$ 次操作的右端点为 $j$，左端点最小是多少。转移时枚举上一次操作的右端点 $k$，然后相当于是求前缀和小于某个值的最靠前的位置，提前预处理即可。

现在的复杂度是 $O(n^2 \log^2n)$，继续优化。

移项后注意到每个转移点 $x$ 其实是只有一个 $pre_i > g_x$ 的限制，先把 $g_x$ 求出来。

把可行的转移点都存到队列里，加入一个新的转移点时，检查 $f_{tail}$ 是否小于 $f_i$，为否则删掉队尾。然后检查左端点为 $f_{tail}$，右端点为 $i$ 哪个转移点的区间和更大，为 $i$ 则删掉队尾。最后检查 $g_i$ 是否小于 $g_{tail}$，为是则加入 $i$ 这个转移点。

然后就可以二分求出第一个满足条件的转移点，做到 $O(n \log^3n)$。此时已经可以通过。

最后考虑每次区间操作的右端点，一定是 pre 数组的后缀 $\max$，否则一定可以扩展。那么当 $x$ 无法转移到 $i$ 时，也一定无法转移到 $j (j>i)$，于是可以用单调队列的手法做到 $O(n \log^2n)$。

代码：

```cpp
 
#include <bits/stdc++.h>
#define rep(i, f, t) for(int i(f); i <= t; ++i)
#define re(i, t) for(int i(1); i <= t; ++i)
#define per(i, t, f) for(int i(t); i >= f; --i)
#define pe(i, t) for(int i(t); i >= 1; --i) 
#define nx(i, u) for(int i(head[u]); i; i = e[i].nxt)
typedef long long ll; 
using namespace std;
typedef pair <int, int> pii;
#define pb push_back
#define fi first
#define se second
#define ix(l, r) ((l + r) | (l != r)) 
#define ls (ix(l, mid))
#define rs (ix(mid + 1, r))
#define mp(i, j) (make_pair(i, j))
// #define int long long
#define inf (int)(1e9+7)
#define INF 0x3f3f3f3f3f3f3f3f

namespace IO {
char buf[1 << 21], *p1 = buf, *p2 = buf, buf1[1 << 21];
inline char gc() {return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}
template<class I>
inline void read(I &x) {x = 0;I f = 1;char c = gc();while (c < '0' || c > '9') {if (c == '-') {f = -1;} c = gc();}while (c >= '0' && c <= '9') {x = x * 10 + c - '0';c = gc();}x *= f;}
template<class I>
inline void write(I x) {if (x == 0) {putchar('0');return;}I tmp = x > 0 ? x : -x;if (x < 0) {putchar('-');}int cnt = 0;while (tmp > 0) {buf1[cnt++] = tmp % 10 + '0';tmp /= 10;}while (cnt > 0)putchar(buf1[--cnt]);}
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')
} using namespace IO;
#define look_memory cerr<<abs(&sT-&eD)/1024.0/1024<<'\n'
int sT;   

const int N = 4e5 + 5;
int n, m, len;
int a[N], base[N], b[N], pre[N], wp[N], st[N*2];
int al[N], ar[N];
int f[25][N], g[N];
int q[N],vis[N];

bool check (int x) {
    re(i, n) b[i] = (a[i] >= x);
    int mn = inf, op = 0;
    re(i, n) {
        pre[i] = pre[i-1] + (b[i] ? 1 : -1); 
        if(i > 1) {
            mn = min(mn, pre[i-2]);
        }
        if(pre[i] > mn) {
            op = 1;
        }
    }  
    if(!op) return 0;
    if(m > 20) return 1;
    re(i, n) wp[i] = min(wp[i-1], pre[i]);
    rep(i, 0, n+n) st[i] = inf;
    st[0+n] = 0; 
    re(i, n) {
        if(i < st[pre[i]+n]) st[pre[i]+n] = i; 
    } 
    re(i, n+n) st[i] = min(st[i], st[i-1]);
    re(i, m) re(j, n) f[i][j] = 0;
    re(i, n) { 
        int x = st[pre[i] + n - 1];
        if(x < i) {
            f[1][i] = x + 1;
        }
    }
    int mx = -inf;
    pe(i, n) {
        vis[i] = 0;
        if(mx < pre[i]) {
            vis[i] = 1;
            mx = pre[i];
        }
    }
    rep(rt, 2, m) {
        int l = 1, r = 0;
        re(i, n) { 
            if(!vis[i]) continue;
            if(f[rt-1][i]) {
                while(l <= r) {
                    int u = q[r], x = f[rt-1][q[r]], y = f[rt-1][i];
                    if(x >= y) {
                        --r;
                        continue;
                    }
                    int w1 = pre[i] - pre[u] + u - x + 1;
                    int w2 = i - y + 1 + pre[y-1] - pre[x-1];
                    if(w2 >= w1) --r;
                    else break;
                }
                int y = f[rt-1][i];
                g[i] = -pre[i] + i - y + 1 + pre[y-1] - wp[y-1];
                g[i] = -g[i];
                if(l <= r) { 
                    if(g[i] < g[q[r]]) q[++r] = i;
                }
                else q[++r] = i;
            }  
            while(l <= r && pre[i] <= g[q[l]]) ++l;
            if(l <= r) {
                int x = f[rt-1][q[l]];
                int w = pre[i] - pre[q[l]] + q[l] - x + 1; 
                f[rt][i] = st[w + pre[x-1] - 1 + n] + 1;
            }
        }
        if(f[rt][n] == 1) return 1;
    }
    return 0;
}

int main () { 
    read(n),read(m);
    re(i, n)read(a[i]), base[i] = a[i];
    sort(base + 1, base + n + 1);
    len = unique(base + 1, base + n + 1) - (base + 1);
    re(i, n) a[i] = lower_bound(base + 1, base + len + 1, a[i]) - base; 
    if(!m) {
        outn(base[1]);
        return 0;
    }
    int l = 1, r = len, res = 0;    
    if(n == 1) {
        outn(base[1]);
        return 0;
    }   
    while(l <= r) {
        int mid = (l + r) >> 1;
        if(check(mid)) l = mid + 1, res = mid;
        else r = mid - 1;
    }
    outn(base[res]);
    return 0;
}
```


---


# [THUPC 2024 决赛] 采矿

## 题目背景

在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。

但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。

然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。

时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。

## 题目描述

**这是一道交互题。**

已知你的矿坑有 $n$ 个节点，编号为 $1\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。

运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。

中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。

当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)

通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。

样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。


交互库的运行时间和内存不计入时间和内存限制。

若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。


**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>



## 样例 #1

### 输入

```
5

1 4 1 2 3

1 1 2 3 4```

### 输出

```

? 0110

? 0000

! 1 4 2 3 2 4 4 5```

# 题解

## 作者：DaiRuiChen007 (赞：3)

[Problem Link](https://www.luogu.com.cn/problem/P10546)

**题目大意**

> 交互器有 $n$ 个点 $n-1$ 条边的有向图，将图视为无向图后是一棵树。
>
> 你可以进行如下操作，每次可以翻转若干条边，你会知道这种情况下每个点 $u$ 能被多少个点到达，记为 $f_u$。
>
> 请在 $50$ 次操作内还原整张图，即确定每条边的起点和终点。
>
> 数据范围：$n\le 10^4$。

**思路分析**

记询问次数 $Q=50$。

对于树上问题，考虑从叶子出发逐步剥离每个点。

我们要先求出叶子，注意到如果某个叶子 $u$ 到父亲的边是从 $u$ 出发的，那么此时该点 $f_u=1$。

假如每条边都随机，那么有 $\dfrac 12$ 的概率这个叶子的 $f_u=1$。

考虑一个经典的技巧，我们对每条边，随机选择 $\dfrac Q2$ 次询问翻转，满足任意两条边的翻转情况都不相同或无交。

那么对于一个叶子结点 $u$，恰有 $\dfrac Q2$ 次询问中这个点 $f_u=1$。

对于一个非叶子节点，他的两条出边至少有一个时刻不同向，那么这个点满足 $f_u=1$ 的的询问轮数一定严格 $<\dfrac Q2$。

那么这样就能每次求出一个叶子结点 $u$，然后考虑确定 $u$ 到其父亲 $v$ 的边，以及其父亲的编号。

确定 $u\to v$ 的边是简单的，只需要求一条边的翻转状态和这个点 $f_u=1$ 的状态相等即可。

然后考虑找父亲，注意到 $f_u>1$ 时一定有 $f_u=f_{v}+1$，那么如果一个点在 $f_u>1$ 时总满足 $f_u=f_v+1$，那么 $v$ 很大概率是 $u$ 的父亲。

考虑什么时候会将一个错误的 $w$ 判断为 $u$ 的父亲，注意到如果某种情况下 $f_v=f_w$，那么当 $v/w$ 中的一条出边被翻转后，一定有 $f_v\ne f_w$。

那么我们知道所有情况中 $f_v=f_w$ 的情况出现一定能对应到至少一种 $f_v\ne f_w$ 的情况，因此总概率一定 $\le \dfrac 12$。

因此判断错误的概率为 $2^{-Q/2}$，完全可以接受，并且对于每个错误的点，期望查询 $\mathcal O(1)$ 轮的结果就能发现错误。

时间复杂度 $\mathcal O(n^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int Q=50,MAXN=10005;
const ll A=(1ll<<Q)-1;
mt19937 rnd(time(0));
ll gen() {
	vector <int> p;
	for(int i=0;i<Q;++i) p.push_back(i);
	shuffle(p.begin(),p.end(),rnd);
	ll z=0;
	for(int i=0;i<Q/2;++i) z|=1ll<<p[i];
	return z;
}
int n,f[Q+5][MAXN],w[Q+5][MAXN],c[MAXN],U[MAXN],V[MAXN];
ll S[MAXN];
bool del[MAXN];
unordered_map <ll,int> E;
signed main() {
	cin>>n;
	for(int i=1;i<n;++i) {
		ll x=gen();
		while(E.count(x)) x=gen();
		S[i]=x,E[x]=i,E[A^x]=-i;
	}
	for(int i=0;i<Q;++i) {
		cout<<"? ";
		for(int u=1;u<n;++u) cout<<(S[u]>>i&1);
		cout<<endl;
		for(int u=1;u<=n;++u) cin>>f[i][u],w[i][u]=1,c[u]+=(f[i][u]==1);
	}
	for(int o=1;o<n;++o) {
		int x=0,y=0;
		for(int u=1;u<=n;++u) if(!del[u]&&c[u]==Q/2) { x=u; break; }
		ll I=0; del[x]=true;
		for(int i=0;i<Q;++i) if(f[i][x]>w[i][x]) I|=1ll<<i;
		for(int u=1;u<=n;++u) if(!del[u]) {
			bool flg=1;
			for(int i=0;i<Q;++i) if((I>>i&1)&&f[i][x]-w[i][x]!=f[i][u]) {
				flg=0; break;
			}
			if(!flg) continue;
			y=u; break;
		}
		for(int i=0;i<Q;++i) if(!(I>>i&1)) w[i][y]+=w[i][x],c[y]+=(w[i][y]==f[i][y]);
		int z=E[I];
		if(z>0) U[z]=x,V[z]=y;
		else U[-z]=y,V[-z]=x;
	}
	cout<<"! ";
	for(int i=1;i<n;++i) cout<<U[i]<<" "<<V[i]<<" ";
	cout<<endl;
	return 0;
}
```

---

## 作者：yyyyxh (赞：2)

思路很自然的一道交互，赛场上都没来得及细做 QwQ。

首先询问树形态的交互题有一个非常通用的思路：剥叶子。应用在这个题上来后你马上就会发现这是好的，因为在本题中叶子有一个关键性质：只有一条邻边操控，如果这条邻边往外指那么这个点的答案一定是 $1$。

你会发现一个点答案是 $1$ 的条件非常苛刻：需要其所有邻边都往外指，假设每一次询问都是纯随机的，那么叶子的答案是 $1$ 的会大致占半数，而其它的小于半数。

我们考虑精细化设计这个策略让其变成确定性的。这个就是[神隐](https://uoj.ac/problem/751)的技巧，我们为每条边设计一个长度为 $T=50$，恰好有 $\frac{T}{2}=25$ 个 $1$ 的二进制数 $msk_i$，当对应 $msk_i$ 的第 $j$ 为 $1$ 时我们第 $j$ 次询问中翻转边 $i$。

我们只需要让这些二进制数互不相同，两两不为互补，这样的话假设一个度数至少为二的点来说，其为 $1$ 的询问至少是 $msk_1\cap msk_2$ 或者 $msk_1\cap \overline{msk_2}$ 类似的形式，由于取交的两个元素不相等，其二进制下 $1$ 的个数小于一半。所以我们只需要看哪些点恰好 $\frac{T}{2}$ 次答案为 $1$ 这些点就是叶子。

接下来是为这个叶子找到父亲以及找到连接它们的边。找相邻的边直接看一下其为 $1$ 的位置与那条边的 $msk$ 符合就行了。找父亲看起来需要一定的技巧。我们考虑当叶子不为的答案 $1$，其答案一定是父亲的答案加上 $1$。我们可以猜测如果一个点满足其一直是叶子的答案减一，那么其大概率唯一而且就是这个叶子的父亲。

为啥呢？因为一个不是父亲的点想通过度数伪装成父亲是很难的，我们的 $msk_i$ 对于每条边每次询问都是均匀的，而每修改一条边，其相邻两个点的度数一定会变化。就算最极端的情况，设我们寻找答案为 $goal$ 的父亲，一个点修改一次变成 $goal$，再修改一次一定不是 $goal$，再修改一次可能又变成 $goal$……而修改与否都是 $\frac{1}{2}$ 随机发生的，次数奇偶性也是随机的。这样不是父亲的点答案 $=goal$ 的概率再怎么也不会超过 $\frac{1}{2}$，整体至多有 $2^{-\frac{T}{2}}$ 的错误率。

再考虑时间复杂度的事情，有人说你这代码三重循环乘起来 $O(n^2T)$ 爆炸了啊？怎么能过呢？

事实上我们暴力 check 一个点在所有合法询问中是否都有答案 $=goal$，如果其不是真正的父亲，失败的概率会达到 $\frac{1}{2}$，这样期望 check 常数次就会退出，期望复杂度 $O(n^2)$ 可以通过。

注意剥完一个叶子的时候，需要修改所有的询问对应的答案。一种方法是给每个点每次询问维护一个点权，表示删去的点中有多少可以到达它，然后把上述的所有 $1$ 改成对应点权。

代码内置交互库，添加 `LOCAL` 宏就可以启用。

```cpp
#include <map>
#include <cstdio>
#include <random>
#include <vector>
#include <cassert>
#include <algorithm>
using namespace std;
typedef long long ll;
mt19937 rng(random_device{}());
int read(){
	char c=getchar();int x=0;
	while(c<48||c>57) c=getchar();
	do x=x*10+(c^48),c=getchar();
	while(c>=48&&c<=57);
	return x;
}
const int N=10003,T=50;
const ll MS=(1ll<<T)-1;
int n;
int eu[N],ev[N];ll msk[N];
int d[T][N],w[T][N],cnt[N];
namespace grader{
#define fi first
#define se second
	typedef pair<int,int> pii;
	pii e[N];
	void gen(){
		for(int i=1;i<n;++i){
			e[i].fi=rng()%i+1;
			e[i].se=i+1;
			if(rng()&1) swap(e[i].fi,e[i].se);
		}
		shuffle(e+1,e+n,rng);
		for(int i=1;i<n;++i) printf("(%d->%d) ",e[i].fi,e[i].se);
		putchar('\n');
	}
	vector<int> vec[N];
	int dfs(int u){
		int res=1;
		for(int v:vec[u]) res+=dfs(v);
		return res;
	}
	void ask(int x){
		putchar('?');putchar(' ');
		for(int i=1;i<n;++i)
			if(msk[i]>>x&1) putchar('1');
			else putchar('0');
		putchar('\n');fflush(stdout);
#ifdef LOCAL
		for(int i=1;i<n;++i)
			if(msk[i]>>x&1) vec[e[i].fi].emplace_back(e[i].se);
			else vec[e[i].se].emplace_back(e[i].fi);
		for(int i=1;i<=n;++i) d[x][i]=dfs(i);
		for(int i=1;i<=n;++i) vec[i].clear();
#else
		for(int i=1;i<=n;++i) d[x][i]=read();
#endif
	}
	void check(){
		for(int i=1;i<n;++i) assert(eu[i]==e[i].fi&&ev[i]==e[i].se);
	}
#undef fi
#undef se
}
map<ll,int> mp;
ll gen(){
	int a[T];
	for(int i=0;i<T;++i) a[i]=2*i<T;
	shuffle(a,a+T,rng);
	ll cur=0;
	for(int i=0;i<T;++i) cur=cur<<1|a[i];
	return cur;
}
bool del[N];
int main(){
	n=read();
#ifdef LOCAL
	grader::gen();
#endif
	for(int i=1;i<n;++i){
		ll x=gen();
		while(mp.find(x)!=mp.end()) x=gen();
		mp.emplace(x,i);mp.emplace(MS^x,-i);msk[i]=x;
	}
	for(int t=0;t<T;++t){
		grader::ask(t);
		for(int i=1;i<=n;++i) w[t][i]=1,cnt[i]+=(d[t][i]==1);
	}
	for(int it=1;it<n;++it){
		int x,y;
		for(int i=1;i<=n;++i) 
			if(!del[i]&&cnt[i]==(T>>1)){x=i;break;}
		ll cur=0;
		for(int t=0;t<T;++t)
			if(d[t][x]==w[t][x]) cur|=(1ll<<t);
		for(y=1;y<=n;++y){
			if(del[y]) continue;
			bool fl=0;
			for(int t=0;t<T;++t){
				if(cur>>t&1) continue;
				if(d[t][x]==d[t][y]+w[t][x]) continue;
				fl=1;break;
			}
			if(fl) continue;
			break;
		}
		del[x]=1;cnt[y]=0;
		for(int t=0;t<T;++t){
			if(cur>>t&1) w[t][y]+=w[t][x];
			cnt[y]+=(d[t][y]==w[t][y]);
		}
		int ps=mp[cur];
		if(ps>0) eu[ps]=y,ev[ps]=x;
		else eu[-ps]=x,ev[-ps]=y;
	}
#ifdef LOCAL
	grader::check();
#endif
	putchar('!');
	for(int i=1;i<n;++i) printf(" %d %d",eu[i],ev[i]);
	putchar('\n');fflush(stdout);
	return 0;
}
```

---

## 作者：是青白呀 (赞：0)

考虑从叶子开始逐步确定树的结构。使用类似拓扑排序的方式，叶子被定义为有且只有 $1$ 个邻居未被删除的点。

考虑如何判定一个点是否是叶子。对于最初的状态，叶子结点满足其父亲边为外向时值恒为 $1$，内向时值恒 $>1$。不妨让每条边处于每个方向各 $25$ 次，则叶子结点答案值为 $1$ 的次数恰好为 $25$。具体地，我们给每一条边随机一个翻转集合，在特定的 $25$ 个询问上进行翻转，另外的询问上不翻转，同时保证所有的翻转集合及他们的补集都两两不同。则我们可以保证任意非叶子的外向菊花，及其他任意非叶子的点，值为 $1$ 的次数严格小于 $25$ 次。

此时，根据每个叶子在哪些询问上是 $1$，可以唯一确定其父亲边及父亲边的方向。

然后考虑如何找到一个叶子的父亲。设 $qr_{i,j}$ 表示第 $i$ 次询问下能到 $j$ 的节点个数，也即问出来的值。若叶子 $x$ 的父亲为 $f$，则显然有 $qr_{i,f}+1=qr_{i,x}$ 对任意满足其父亲边指向叶子自己的轮次 $i$ 恒成立。显然这个限制是很强的，我们可以认为不会有非实际父亲的点满足这个条件。错误率可以考虑一个最劣情况：实际父亲和被错判的父亲挂在同一个点下方的情况下，此时有 $\frac 12$ 的概率两者均满足条件。那么在存在 $25$ 轮判定的情况下，单次判断错误率仅有 $\frac{1}{2^{25}}$，是可以接受的。

事实上，上述方法是可以推广的。不妨对图执行拓扑排序，每次删除队列中的一个点，判断父亲是否成为叶子并把叶子放进队列。

具体地，我们维护 $sz_{i,j}$ 表示第 $i$ 次询问下，有多少个非父亲的点（包含自己）能到达 $j$。此时，一个点 $x$ 是叶子的条件就是满足 $qr_{i,x}=sz_{i,x}$ 的轮次恰为 $25$，且这样的轮次集合与某条父亲边相符。这样在判断一个点目前是否是叶子的同时，也找到了它的父亲边和方向。同理，找父亲的判据为 $qr_{i,f}+sz_{i,x}=qr_{i,x}$ 对任意满足其父亲边指向叶子自己的轮次 $i$ 恒成立。上述两个部分的正确率分析与第一轮叶子部分类似

于是对于每个要删除的叶子，暴力遍历每一个可能的节点，并暴力遍历每一个合法轮次判断即可。根据正确率 $\frac 12$ 的分析，我们有 $\frac 12$ 的概率一次就停掉，$\frac 14$ 的概率两次停掉......因此每个点 check 的期望轮数是 $O(1)$ 的，总复杂度即为 $O(n^2)$。加上可能节点的剪枝等，不难通过。

注意只剩余两个节点时，某个节点的父亲同时已经是叶子，可能已经存在于队列中，在剪枝时需要注意不要判错了。我采取的方式是：已经确定父亲的点一定不可能作为其他点的父亲。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long
#define qingbai qwq
using namespace std;
typedef long long ll;
const int N=1e4+5,M=55,S=(1<<18)+5,inf=(ll)1e18+7,mo=998244353;
const double eps=1e-8;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-inf;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,tms=50;
unordered_map<int,int>id;
int rev[N];
int fid[N],fdr[N],st[M][N],fa[N];
int qr[M][N],sz[M][N],tot;
pii ans[N];
bool vis[N];
bool check(int x){//check if x is leaves now or not;if is,get its fid and fdr.
    int nwv=0;
    rep(i,1,tms)
        if(qr[i][x]==sz[i][x])nwv|=1ll<<(i-1);
    if(!id[nwv]&&!id[tot^nwv])return 0;
    if(id[nwv])fid[x]=id[nwv],fdr[x]=1;
    else fid[x]=id[tot^nwv],fdr[x]=0;
    return 1;
}
signed main(){
    read(n);
    tot=(1ll<<tms)-1;
    rep(i,1,n-1){
        rep(j,1,tms)
            rev[j]=(j>tms/2);
        while(1){
            random_shuffle(rev+1,rev+tms+1);
            int nwv=0;
            rep(j,1,tms)
                nwv|=rev[j]<<(j-1);
            if(!id[nwv]&&!id[tot^nwv]){
                id[nwv]=i;
                rep(j,1,tms)
                    st[j][i]=rev[j];
                break;
            }
        }
    }
    rep(i,1,tms){
        printf("? ");
        rep(j,1,n-1) 
            printf("%lld",st[i][j]);
        puts(""),fflush(stdout);
        rep(j,1,n)
            read(qr[i][j]);
    }
    queue<int>q;
    rep(i,1,n){
        rep(j,1,tms)
            sz[j][i]=1;
    }
    rep(i,1,n)
        if(check(i))q.push(i),vis[i]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        //find father
        rep(i,1,n){
            if(fa[i]||i==x)continue;
            bool ok=1;
            rep(j,1,tms){
                if(!(fdr[x]^st[j][fid[x]]))continue;
                if(qr[j][i]+sz[j][x]!=qr[j][x]){
                    ok=0;
                    break;
                }
            }
            if(ok){
                fa[x]=i;
                break;
            }
        }
        //deal with father details
        if(!fa[x])continue;
        rep(i,1,tms)
            if(!(fdr[x]^st[i][fid[x]]))sz[i][fa[x]]+=sz[i][x];
        if(check(fa[x]))q.push(fa[x]),vis[fa[x]]=1;
    }
    rep(i,1,n){
        if(!fa[i])continue;
        if(fdr[i])ans[fid[i]]=mp(fa[i],i);
        else ans[fid[i]]=mp(i,fa[i]);
    }
    printf("! ");
    rep(i,1,n-1)
        printf("%lld %lld ",ans[i].fir,ans[i].sec);
    puts("");
    fflush(stdout);
    return 0;
}
```

---


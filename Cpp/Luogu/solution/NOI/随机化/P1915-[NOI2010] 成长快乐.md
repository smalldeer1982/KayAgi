# [NOI2010] 成长快乐

## 题目描述

Nemo 是一条无忧无虑的小鱼，它的初始体重为 $w_0$。可爱的 Nemo 希望自己能够尽快地成长，因此需要吃尽量多的食物。Nemo 最喜爱的食物是海里的小虾。

已知 Nemo 对食物的情况了解如下：大海里共有 $n$ 只小虾，从 $1$ 到 $n$ 编号，其中编号为 $i$ 的小虾的重量为 $w_i$。将大海看作一个 X-Y 坐标系，在 $0$ 时刻编号为 $i$ 的小虾所在的位置为 $(x_i, y_i)$。小虾在大海中作匀速直线运动，其中编号为 $i$ 的小虾的速度向量为 $(p_i, q_i)$，即在时刻 $t$，它的位置为 $(x_i+p_i \cdot t,y_i+q_i \cdot t)$。

Nemo 在 $0$ 时刻的位置为 $(x_0, y_0)$，它可以在海中随意移动，但速度不超过 $V$。Nemo 希望通过自己的努力，在 $T$ 个单位时间内（含 $T$ 时刻）吃到的小虾重量总和尽量大。

当 Nemo 与某只小虾同时移动到同一个位置上，且小虾的重量小于 Nemo 当时的重量，则 Nemo 可以将该小虾吃掉。当 Nemo 吃掉重量为 $w_i$ 的小虾之后，它的体重将增加 $w_i$。注意，小虾不会吃 Nemo，且小虾之间也不会自相残杀。

Nemo 希望你来帮助它制定一个成长计划，使得它吃掉的小虾重量总和尽量大。

## 说明/提示

### 样例解释

在这个样例中，Nemo 在时刻 $5$ 在位置 $(2, 2)$ 吃掉了 $1$ 号小虾。其实 Nemo 到达 $(2, 2)$ 的时间可以更早，但题中仅要求速度不超过 $V$ 即可。

### 评分方法

对于每组数据，我们设置了 $9$ 个评分参数 $a_{10},a_9, \ldots ,a_2$。如果选手的输出不合法，则得零分。否则，设在你的方案中，Nemo 体重的增加量为 $w_{user}$，你的分数将会由下表给出：

| 得分 |          条件          | 得分 |        条件         |
| :--: | :--------------------: | :--: | :-----------------: |
|  10  | $w_{user} \geq a_{10}$ |  5   | $w_{user} \geq a_5$ |
|  9   |  $w_{user} \geq a_9$   |  4   | $w_{user} \geq a_4$ |
|  8   |  $w_{user} \geq a_8$   |  3   | $w_{user} \geq a_3$ |
|  7   |  $w_{user} \geq a_7$   |  2   | $w_{user} \geq a_2$ |
|  6   |  $w_{user} \geq a_6$   |  1   |  $w_{user} \gt 0$   |

### checker 使用方法

在 checker 目录下，在终端输入 `./checker in out`。

其中 in 为题目提供的输入文件，out 为你对于该输入文件给出的答案文件。

校验器将只检查你的答案的合法性，结果以在线评测为准。

感谢 @FlierKing 提供 spj 以及 @虞皓翔 帮助完善 spj。


## 样例 #1

### 输入

```
5 1 6 0 0
1
5 2 2 0 0
```

### 输出

```
1
5
5 2 2 1
```

# 题解

## 作者：panzhicun (赞：139)

**通法：随机化贪心，并且加上各种优化。**
先说计算出从A出发，追赶一个当前位置为B，以速度v移动的小虾所需时间的方法如下。

![](https://cdn.luogu.com.cn/upload/pic/70417.png)

如图所示，根据余弦定理，有：

![](https://cdn.luogu.com.cn/upload/pic/70419.png)

即：

![](https://cdn.luogu.com.cn/upload/pic/70420.png)

也即：

![](https://cdn.luogu.com.cn/upload/pic/70428.png)

只需要用求根公式求解即可（取两根中的较小正根）。

朴素的随机化贪心算法如下。

先将所有的小虾按体重从小到大排序。

每次将所有小虾按照单位时间的收益（增重比上时间）从大到小排序，选取一个最优的小虾，或者以一定概率接受更差的小虾（并迭代进行，即再以一定概率接受更差的小虾），这个概率可以是0.5，或1/e。

优化1：贪心多次，取最小值；

优化2：对更差的解进行限制（如果太差就直接舍去）；

优化3：提高时间所占的比重（按增重比上时间的平方从大到小排序）；

优化4：引入模拟退火的思想，即使遇到非常差的解，仍然以一定概率接受它（这个概率跟温度有关，每贪心一次就按照一定规律降温（如将温度减半））。

加上这些优化基本上就可以得全分了。

附程序：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <complex>
#include <ctime>
#include <cmath>
 
using namespace std;
 
const int maxN = 10010;
const double zero = 1e-12, INF = 1e198;
struct Res
{
	double t; complex <double> p; int ord; Res() {}
	Res(double t, complex <double> p, int ord):
		t(t), p(p), ord(ord) {}
} res[maxN], _res[maxN]; bool eaten[maxN];
complex <double> p[maxN], v[maxN];
double w[maxN], V, _deltaw, deltaw, T, tem;
vector <pair <double, int> > ls;
vector <pair <double, int> >::iterator iter;
int ord[maxN], n, cnt, _cnt;
 
inline bool cmp(const int &a, const int &b)
{return w[a] < w[b];}
 
inline double sqr(double x) {return x * x;}
 
inline double sqr(complex <double> z)
{return sqr(real(z)) + sqr(imag(z));}
 
inline double solve(complex <double> p,
					complex <double> v,
					complex <double> O)
{
	double a = sqr(v) - sqr(V),
	b = -2 * (real(v) * real(O - p) + imag(v) * imag(O - p)),
	c = sqr(p - O),
	delta = sqr(b) - 4 * a * c;
	if (delta < -zero) return INF;
	if (fabs(a) < zero)
		return (b > -zero) ? INF : (-c / b);
	double ans = INF,
		   x1 = (-b - sqrt(delta)) / (2 * a),
		   x2 = (-b + sqrt(delta)) / (2 * a);
	if (x1 > -zero) ans = x1;
	if (x2 > -zero && x2 < ans) ans = x2;
	return ans;
} //计算出从O出发，追赶一个当前位置为p，以速度v移动的小虾所需时间。
 
inline double _rand() {return (double)rand() / RAND_MAX;}
 
inline bool judge()
{
	if (++iter == ls.end()) {--iter; return 0;}
	if (rand() & 1) {--iter; return 0;}
	//先以0.5的概率初步淘汰较差的解。
	double nxt = iter -> first;
	--iter; double ths = iter -> first;
	double delta = (ths - nxt);
	if (delta / ths < 3.40e-2) return 1;
	//若较差的解比当前解差3.4%以上，直接淘汰。
	return _rand() < 1 / exp(delta / tem);
	//否则以概率e ^ (-delta / tem)的概率接受更差的解。
}
 
int main()
{
	freopen("nemo10.in", "r", stdin);
	freopen("nemo10.out", "w", stdout);
	srand(time(NULL));
	scanf("%lf%lf%lf%lf%lf%d", w + 0, &V, &T, &p[0].real(), &p[0].imag(), &n);
	complex <double> p0 = p[0]; double w0 = w[0];
	for (int i = 1; i < n + 1; ord[i] = i, ++i)
		scanf("%lf%lf%lf%lf%lf", w + i, &p[i].real(), &p[i].imag(), &v[i].real(), &v[i].imag());
	sort(ord + 1, ord + n + 1, cmp); //将小虾按体重从小到大的顺序排序。
	tem = 1; //初始温度设为1。
	for (int k = 0; k < 15; ++k)
	{
		memset(eaten, 0, sizeof eaten);
		_deltaw = 0; _cnt = 0; p[0] = p0; w[0] = w0;
		for (double t = 0; t < T;)
		{
			ls.clear();
			for (int i = 1; w[ord[i]] < w[0]; ++i)
			if (!eaten[ord[i]])
				ls.push_back(make_pair(w[ord[i]] / sqr(solve(p[ord[i]] + t * v[ord[i]], v[ord[i]], p[0])), ord[i]));
			sort(ls.begin(), ls.end(), greater <pair <double, int> > ());
			iter = ls.begin(); if (iter == ls.end()) break;
			while (judge()) ++iter;
			int pos = iter -> second;
			if (T - (t += solve(p[pos] + t * v[pos], v[pos], p[0])) < -zero) break;
			_deltaw += w[pos], w[0] += w[pos]; eaten[pos] = 1;
			_res[_cnt++] = Res(t, p[0] = p[pos] + t * v[pos], pos);
		}
		if (_deltaw > deltaw)
		{
			deltaw = _deltaw;
			for (cnt = 0; cnt < _cnt; ++cnt) res[cnt] = _res[cnt];
		} //更新最优解。
		tem *= .5;
	}
	printf("%d\n%.9lf\n", cnt, deltaw);
	for (int i = 0; i < cnt; ++i)
		printf("%.9lf %.9lf %.9lf %d\n", res[i].t, res[i].p.real(), res[i].p.imag(), res[i].ord);
	return 0;
}
```
对于不同的数据，还可以用特殊方法求解。

第一组数据显然手算，不多说。

第二组数据较小，可以暴力枚举，附程序：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <string>
#include <complex>
 
using namespace std;
 
const int maxN = 10010;
const double zero = 1e-12, INF = 1e198;
struct Res
{
	double t; complex <double> p; int ord; Res() {}
	Res(double t, complex <double> p, int ord):
		t(t), p(p), ord(ord) {}
} res[maxN], tmp[maxN]; bool eaten[maxN];
complex <double> p[maxN], v[maxN];
double w[maxN], V, deltaw, T;
int n, cnt;
 
inline double sqr(double x) {return x * x;}
 
inline double sqr(complex <double> z)
{return sqr(real(z)) + sqr(imag(z));}
 
inline double solve(complex <double> p,
					complex <double> v,
					complex <double> O)
{
	double a = sqr(v) - sqr(V),
	b = -2 * (real(v) * real(O - p) + imag(v) * imag(O - p)),
	c = sqr(p - O),
	delta = sqr(b) - 4 * a * c;
	if (delta < -zero) return INF;
	if (fabs(a) < zero)
		return (b > -zero) ? INF : (-c / b);
	double ans = INF,
		   x1 = (-b - sqrt(delta)) / (2 * a),
		   x2 = (-b + sqrt(delta)) / (2 * a);
	if (x1 > -zero) ans = x1;
	if (x2 > -zero && x2 < ans) ans = x2;
	return ans;
}
 
void Dfs(int i, double w0, double t, complex <double> p0)
{
	for (int j = 1; j < n + 1; ++j)
	if (!eaten[j] && w[j] < w0)
	{
		double ths = solve(p[j] + t * v[j], v[j], p0);
		if (t + ths - T > zero) continue;
		complex <double> pos = p[j] + (t + ths) * v[j];
		eaten[j] = 1;
		tmp[i] = Res(t + ths, pos, j);
		Dfs(i + 1, w0 + w[j], t + ths, pos);
		tmp[i] = Res(0, 0, 0);
		eaten[j] = 0;
	}
	if (w0 - w[0] > deltaw)
	{
		deltaw = w0 - w[0];
		for (cnt = 0; tmp[cnt].t > zero; ++cnt)
			res[cnt] = tmp[cnt];
	}
	return;
}
int main()
{
	freopen("nemo2.in", "r", stdin);
	freopen("nemo2.out", "w", stdout);
	scanf("%lf%lf%lf%lf%lf%d", w + 0, &V, &T, &p[0].real(), &p[0].imag(), &n);
	for (int i = 1; i < n + 1; ++i)
		scanf("%lf%lf%lf%lf%lf", w + i, &p[i].real(), &p[i].imag(), &v[i].real(), &v[i].imag());
	Dfs(0, w[0], 0, p[0]);
	printf("%d\n%.9lf\n", cnt, deltaw);
	for (int i = 0; i < cnt; ++i)
		printf("%.9lf %.9lf %.9lf %d\n", res[i].t, res[i].p.real(), res[i].p.imag(), res[i].ord);
	return 0;
}
```
第三组数据小虾的体重有规律，按顺序吃就是了，附程序：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <string>
#include <complex>
 
using namespace std;
 
const int maxN = 10010;
const double zero = 1e-12, INF = 1e198;
struct Res
{
	double t; complex <double> p; int ord; Res() {}
	Res(double t, complex <double> p, int ord):
		t(t), p(p), ord(ord) {}
} res[maxN]; bool eaten[maxN];
complex <double> p[maxN], v[maxN];
double w[maxN], V, deltaw, T;
int ord[maxN], n, cnt;
 
inline bool cmp(const int &a, const int &b)
{return w[a] < w[b];}
 
inline double sqr(double x) {return x * x;}
 
inline double sqr(complex <double> z)
{return sqr(real(z)) + sqr(imag(z));}
 
inline double solve(complex <double> p,
					complex <double> v,
					complex <double> O)
{
	double a = sqr(v) - sqr(V),
	b = -2 * (real(v) * real(O - p) + imag(v) * imag(O - p)),
	c = sqr(p - O),
	delta = sqr(b) - 4 * a * c;
	if (delta < -zero) return INF;
	if (fabs(a) < zero)
		return (b > -zero) ? INF : (-c / b);
	double ans = INF,
		   x1 = (-b - sqrt(delta)) / (2 * a),
		   x2 = (-b + sqrt(delta)) / (2 * a);
	if (x1 > -zero) ans = x1;
	if (x2 > -zero && x2 < ans) ans = x2;
	return ans;
}
 
int main()
{
	freopen("nemo3.in", "r", stdin);
	freopen("nemo3.out", "w", stdout);
	scanf("%lf%lf%lf%lf%lf%d", w + 0, &V, &T, &p[0].real(), &p[0].imag(), &n);
	for (int i = 1; i < n + 1; ord[i] = i, ++i)
		scanf("%lf%lf%lf%lf%lf", w + i, &p[i].real(), &p[i].imag(), &v[i].real(), &v[i].imag());
	sort(ord + 1, ord + n + 1, cmp);
	for (double t = 0; T - t > zero;)
	{
		static int i = 0; ++i; if (i > n) break;
		double Min = solve(p[ord[i]] + t * v[ord[i]], v[ord[i]], p[0]);
		int pos = ord[i];
		if (fabs(Min - INF) < zero) break;
		if (T - (t += Min) < -zero) break;
		w[0] += w[pos]; deltaw += w[pos]; eaten[pos] = 1;
		res[cnt++] = Res(t, p[0] = p[pos] + t * v[pos], pos);
	}
	printf("%d\n%.9lf\n", cnt, deltaw);
	for (int i = 0; i < cnt; ++i)
		printf("%.9lf %.9lf %.9lf %d\n", res[i].t, res[i].p.real(), res[i].p.imag(), res[i].ord);
	return 0;
}
```
第四组数据中所有小虾静止不动且在一条直线上，据说是区间动态规划，方法至今未知。

第五、六组数据中所有小虾都在高速向下掉，而Nemo的移动速度很小，可以近似看作Nemo在只能水平移动的情况下去接住小虾来吃。

先将小虾按竖直方向排序，然后进行一下操作。

设f[i]表示前i个小虾中恰好第i个被吃所能得到的最大收益，只需要一个n^2的动态规划即可求解。

附程序：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <string>
#include <complex>
 
using namespace std;
 
const int maxN = 10010;
const double zero = 1e-12, INF = 1e198;
struct Res
{
	double t; complex <double> p; int ord; Res() {}
	Res(double t, complex <double> p, int ord):
		t(t), p(p), ord(ord) {}
} res[maxN]; bool eaten[maxN];
complex <double> p[maxN], v[maxN];
double f[maxN], w[maxN], V, deltaw, T;
int ord[maxN], g[maxN], n, cnt;
 
inline bool cmp(const int &a, const int &b)
{return imag(p[a]) < imag(p[b]);}
 
void calc(int i)
{
	if (g[i]) calc(g[i]);
	res[cnt++] = Res(imag(p[i]) / 1000, p[i], i);
	deltaw += w[i];
	return;
}
 
int main()
{
	freopen("nemo5.in", "r", stdin);
	freopen("nemo5.out", "w", stdout);
	scanf("%lf%lf%lf%lf%lf%d", w + 0, &V, &T, &p[0].real(), &p[0].imag(), &n);
	for (int i = 1; i < n + 1; ord[i] = i, ++i)
		scanf("%lf%lf%lf%lf%lf", w + i, &p[i].real(), &p[i].imag(), &v[i].real(), &v[i].imag());
	sort(ord + 1, ord + n + 1, cmp);
	int st = 1;
	while (imag(p[ord[st]]) / 1000 - real(p[ord[st]]) / V < -zero) ++st;
	f[ord[st]] = w[ord[st]];
	for (int i = 1; i < st; ++i) f[ord[i]] = -INF;
	for (int i = 0; i < n; ++i)
	if (f[ord[i]] > -INF)
	for (int j = i + 1; j < n + 1; ++j)
	{
		if (imag(p[ord[j]] - p[ord[i]]) / 1000 - fabs(real(p[ord[i]] - p[ord[j]])) / V > -zero)
		if (f[ord[i]] + w[ord[j]] > f[ord[j]])
			f[ord[j]] = f[ord[i]] + w[ord[j]],
			g[ord[j]] = ord[i];
	}
	int pos = ord[n];
	for (int i = 1; i < n + 1; ++i) if (f[i] > f[pos]) pos = i;
	calc(pos);
	printf("%d\n%.9lf\n", cnt, deltaw);
	for (int i = 0; i < cnt; ++i)
		printf("%.9lf %.9lf %.9lf %d\n", res[i].t, res[i].p.real(), 0., res[i].ord);
	return 0;
}
```
第七、八组数据中可以发现小虾的位置呈现数字三角形的形状，只需要按数字三角形的方法进行动态规划即可。

附程序：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <string>
#include <complex>
 
using namespace std;
 
const int maxN = 2010, INF = 0x3f3f3f3f;
const double zero = 1e-12;
struct Res
{
	double t; complex <int> p; int ord; Res() {}
	Res(double t, complex <int> p, int ord):
		t(t), p(p), ord(ord) {}
} res[maxN], tmp[maxN]; bool eaten[maxN];
complex <int> p[maxN], v[maxN];
double w[maxN], deltaw, V, T, f[maxN][maxN];
int ord[maxN][maxN], g[maxN], n, cnt;
 
inline double sqr(double x) {return x * x;}
 
inline double sqr(complex <double> z)
{return sqr(real(z)) + sqr(imag(z));}
 
int main()
{
	freopen("nemo8.in", "r", stdin);
	freopen("nemo8.out", "w", stdout);
	scanf("%lf%lf%lf%d%d%d", w + 0, &V, &T, &p[0].real(), &p[0].imag(), &n);
	for (int i = 1; i < n + 1; ++i)
		scanf("%lf%d%d%d%d", w + i, &p[i].real(), &p[i].imag(), &v[i].real(), &v[i].imag());
	for (int i = 1; i < n + 1; ++i)
		ord[real(p[i])][imag(p[i])] = i;
	int i = n;
	for (; i; --i)
	{
		f[real(p[i])][imag(p[i])] = w[i];
		if (imag(p[i - 1]) < imag(p[i])) break;
	}
	while (--i)
	{
		int x = real(p[i]), y = imag(p[i]), ths = ord[x][y];
		if (f[x - 1][y + 1] > f[x + 1][y + 1])
		{
			f[x][y] = w[i] + f[x - 1][y + 1];
			g[ths] = ord[x - 1][y + 1];
		}
		else
		{
			f[x][y] = w[i] + f[x + 1][y + 1];
			g[ths] = ord[x + 1][y + 1];
		}
	}
	double t = 0;
	res[cnt++] = Res(t = abs(p[1] - p[0]) / V, p[1], 1);
	for (int ths = 1; g[ths]; ths = g[ths])
		res[cnt++] = Res(t += abs(complex <double> (real(p[g[ths]] - p[ths]), imag(p[g[ths]] - p[ths]))) / V, p[g[ths]], g[ths]);
	for (int i = 0; i < cnt; ++i) deltaw += w[res[i].ord];
	printf("%d\n%lf\n", cnt, deltaw);
	for (int i = 0; i < cnt; ++i)
		printf("%.9lf %d %d %d\n", res[i].t, res[i].p.real(), res[i].p.imag(), res[i].ord);
	return 0;
}
```
第九组数据中所有小虾都静止不动，简单的贪心就可以过。

第十组数据可能就只有随机化贪心能够解决了……

---

## 作者：封禁用户 (赞：137)

[进入博客食用效果更佳](https://www.luogu.com.cn/blog/LeonXY-blog/solution-p1915)

同志们好。
还有多少同志们为这题苦思冥想？

我来拯救你们了

作为一个P党，始终没想明白为啥子第四个点**随机化贪心**过不了，只能得四分。

# 进入正题（温馨提示：直接复制粘贴有惊喜）

看到这题的第一个数据我笑了。手算即可。

以下为一组可行解：
```latex
2
20
1.111111 0 11.111111 1
3 13 0 2
```

第二组数据直接$DFS$暴搜即可，贴代码：
```pascal
program nemo2;
const zero=1e-10;
      max=10000000;
type
  ty1=record
    w,x,y,p,q:extended;
  end;
  ty2=record
    t,x,y:extended;
    s:longint;
  end;
 
var
  v,w,x,y,tot_t,all:extended;
  n,i,tot:longint;
  fish:array[0..10000] of ty1;
  step,tmp:array[0..10000] of ty2;
  get:array[0..10000] of boolean;
procedure find(s:longint x,y,w,now:extended);
var
  j:longint;
  a,b,c,d,fx,fy,t:extended;
begin
  if (s=n+1)or(now-tot_t>zero) then exit;
 
  for j:=1 to n do
  if not get[j] and (fish[j].w-w<-zero) then
  begin
    fx:=fish[j].x+fish[j].p*now;
    fy:=fish[j].y+fish[j].q*now;
    a:=sqr(v)-sqr(fish[j].p)-sqr(fish[j].q);
    b:=2*fish[j].p*(x-fx)+2*fish[j].q*(y-fy);
    c:=-sqr(x-fx)-sqr(y-fy);
    t:=max;
    if abs(a)<zero then
    begin
      if abs(b)<zero then continue;
      if -c/b>-zero then t:=-c/b;
    end else
    begin
      if sqr(b)-4*a*c<-zero then continue;
      d:=(-b+sqrt(sqr(b)-4*a*c))/(2*a);
      if d>-zero then t:=d;
      d:=(-b-sqrt(sqr(b)-4*a*c))/(2*a);
      if (d>-zero)and(d>t) then t:=d;
    end;
    if t-max>-zero then continue;
    tmp[s+1].x:=fx+fish[j].p*t;
    tmp[s+1].y:=fy+fish[j].q*t;
    tmp[s+1].s:=j;
    tmp[s+1].t:=now+t;
    get[j]:=true;
    find(s+1,tmp[s+1].x,tmp[s+1].y,w+fish[j].w,now+t);
    get[j]:=false;
  end;
 
  if all-w<-zero then
  begin
    tot:=s; all:=w;
    for j:=1 to s do step[j]:=tmp[j];
  end;
end;
begin
  assign(input,'nemo2.in'); reset(input);
  assign(output,'nemo2.out'); rewrite(output);
  read(w,v,tot_t,x,y);
  read(n); tot:=0; all:=0;
  for i:=1 to n do read(fish[i].w,fish[i].x,fish[i].y,fish[i].p,fish[i].q);
  find(0,x,y,w,0);
  writeln(tot);
  writeln(all-w:0:6);
  for i:=1 to tot do
  writeln(step[i].t:0:6,' ',step[i].x:0:6,' ',step[i].y:0:6,' ',step[i].s);
  close(input); close(output);
end.
```
第三组数据~~傻子都能看出来~~直接模拟
```pascal
program nemo3;
const zero=1e-10;
      max=100000000;
type
  ty1=record
    w,x,y,p,q:extended;
  end;
  ty2=record
    t,x,y:extended;
    s:longint;
  end;
 
var
  v,w,x,y,tot_t,a,b,c,d,now,time,all:extended;
  n,i,j,t,tot:longint;
  fish:array[0..10000] of ty1;
  step:array[0..10000] of ty2;
  dis:array[0..10000] of extended;
  get:array[0..10000] of boolean;
begin
  assign(input,'nemo3.in'); reset(input);
  assign(output,'nemo3.out'); rewrite(output);
  read(w,v,tot_t,x,y);
  read(n); time:=0; tot:=0; all:=0;
  for i:=1 to n do read(fish[i].w,fish[i].x,fish[i].y,fish[i].p,fish[i].q);
  for i:=1 to n do
  begin
    for j:=1 to n do dis[j]:=max;
    for j:=1 to n do
    if not get[j] and (fish[j].w-w<-zero) then
    begin
      a:=sqr(v)-sqr(fish[j].p)-sqr(fish[j].q);
      b:=2*fish[j].p*(x-fish[j].x)+2*fish[j].q*(y-fish[j].y);
      c:=-sqr(x-fish[j].x)-sqr(y-fish[j].y);
      if abs(a)<zero then
      begin
        if abs(b)<zero then continue;
        dis[j]:=-c/b;
        if dis[j]<-zero then dis[j]:=max;
      end else
      begin
        if sqr(b)-4*a*c<-zero then continue;
        d:=(-b+sqrt(sqr(b)-4*a*c))/(2*a);
        if d>-zero then dis[j]:=d;
        d:=(-b-sqrt(sqr(b)-4*a*c))/(2*a);
        if d>-zero then dis[j]:=d;
      end;
    end;
    now:=max; t:=0;
    for j:=1 to n do
    if not get[j] and (fish[j].w-w<-zero) and (now-dis[j]>zero) then
    begin
      t:=j;
      now:=dis[j];
    end;
    if t=0 then break;
    time:=time+now;
    if time-tot_t>zero then break;
    get[t]:=true;
    inc(tot);
    step[tot].x:=fish[t].x+fish[t].p*now;
    step[tot].y:=fish[t].y+fish[t].q*now;
    step[tot].s:=t;
    step[tot].t:=time;
    x:=step[tot].x; y:=step[tot].y;
    w:=w+fish[t].w;
    all:=all+fish[t].w;
    for j:=1 to n do
    if not get[j] then
    begin
      fish[j].x:=fish[j].x+fish[j].p*now;
      fish[j].y:=fish[j].y+fish[j].q*now;
    end;
  end;
  writeln(tot);
  writeln(all:0:6);
  for i:=1 to tot do
  writeln(step[i].t:0:6,' ',step[i].x:0:6,' ',step[i].y:0:6,' ',step[i].s);
  close(input); close(output);
end.
```
第四组和第十组都可以用随机化贪心+模拟退火（但是第四个点拿不到全分）

~~残缺代码~~
```pascal
program nemo4;
{for case 4/10}
const zero=1e-10;
      max=10000000;
type
  ty1=record
    w,x,y,p,q:extended;
  end;
  ty2=record
    t,x,y:extended;
    s:longint;
  end;
var
  v,w0,x0,y0,tot_t,all,x,y:extended;
  n,tot,i,tot_s,t:longint;
  fish:array[0..10000] of ty1;
  step,tmp:array[0..10000] of ty2;
  get:array[0..10000] of boolean;
  sx:array[0..10000] of longint;
  s:array[0..10000] of extended;
procedure sort(l,r:longint);
var
  i,j,tmp1:longint;
  tmp2,m:extended;
begin
  i:=l; j:=r; m:=s[(i+j) >> 1];
  repeat
    while s[i]>m do inc(i);
    while s[j]<m do dec(j);
    if i<=j then
    begin
      tmp1:=sx[i]; sx[i]:=sx[j]; sx[j]:=tmp1;
      tmp2:=s[i]; s[i]:=s[j]; s[j]:=tmp2;
      inc(i); dec(j);
    end;
  until i>j;
  if i<r then sort(i,r);
  if j>l then sort(l,j);
end;
function calc(t:longint; x,y,now:extended):extended;
var
  fx,fy,a,b,c,d,k:extended;
begin
  k:=max;
  fx:=fish[t].x+now*fish[t].p;
  fy:=fish[t].y+now*fish[t].q;
  a:=sqr(v)-sqr(fish[t].p)-sqr(fish[t].q);
  b:=2*fish[t].p*(x-fx)+2*fish[t].q*(y-fy);
  c:=-sqr(x-fx)-sqr(y-fy);
  if abs(a)<zero then
  begin
    if abs(b)<zero then exit(k);
    if -c/b>-zero then k:=-c/b;
  end else
  begin
    if sqr(b)-4*a*c<-zero then exit(k);
    d:=(-b+sqrt(sqr(b)-4*a*c))/(2*a);
    if d>-zero then k:=d;
    d:=(-b-sqrt(sqr(b)-4*a*c))/(2*a);
    if (d>-zero)and(d>k) then k:=d;
  end;
  exit(k);
end;
procedure insert(fx:longint; now:extended);
begin
  inc(tot_s);
  s[tot_s]:=fish[fx].w/sqr(sqr(calc(fx,x,y,now)));
  sx[tot_s]:=fx;
end;
function get_rand:longint;
var
  i,j,k:longint;
begin
  for j:=1 to tot_s do
  if (s[j]-s[j+1])/s[j]>0.031 then break;
  for k:=1 to j do
  if random(maxlongint) and 1=1 then break;
  for i:=1 to k do
  begin
    if random() < exp(-10/t) then break;
  end;
  exit(sx[i]);
end;
procedure main;
var
  now,w,turn:extended;
  now_tot,t,j,i:longint;
begin
  fillchar(get,sizeof(get),0);
  fillchar(tmp,sizeof(tmp),0);
  now:=0; now_tot:=0; x:=x0; y:=y0; w:=w0;
  for j:=1 to n do
  begin
    tot_s:=0;
    for i:=1 to n do
    if not get[i] and(fish[i].w-w<-zero) then insert(i,now);
    sort(1,tot_s);
    if tot_s<1 then break;
    t:=get_rand;
    turn:=calc(t,x,y,now);
    if turn>max-1000 then continue;
    now:=now+turn;
    if now-tot_t>zero then break;
    get[t]:=true;
    inc(now_tot);
    tmp[now_tot].x:=fish[t].x+fish[t].p*now;
    tmp[now_tot].y:=fish[t].y+fish[t].q*now;
    tmp[now_tot].s:=t;
    tmp[now_tot].t:=now;
    x:=tmp[now_tot].x; y:=tmp[now_tot].y;
    w:=w+fish[t].w;
  end;
  if w>all then
  begin
    tot:=now_tot;
    all=w;
    step:=tmp;
  end;
end;
begin
  assign(input,'nemo10.in'); reset(input);
  assign(output,'nemo10.out'); rewrite(output);
  randomize;
  read(w0,v,tot_t,x0,y0);
  read(n); all:=all+w0;
  for i:=1 to n do read(fish[i].w,fish[i].x,fish[i].y,fish[i].p,fish[i].q);
  t:=20;
  while t>0 do
  begin
    main;
    dec(t);
  end;
  writeln(tot);
  writeln(all-w0:0:6);
  for i:=1 to tot do
  writeln(step[i].t:0:6,' ',step[i].x:0:6,' ',step[i].y:0:6,' ',step[i].s);
  close(input); close(output);
end.
```
第五组和第六组数据请自行观察规律
```pascal
program nemo6;
{for case 5/6}
const zero=1e-10;
type
  ty1=record
    w,x,y,p,q:extended;
  end;
  ty2=record
    t,x,y:extended;
    s:longint;
  end;
var
  v,w0,x0,y0,tot_t,all,best:extended;
  n,tot,i,j,t:longint;
  fish:array[0..10000] of ty1;
  step:array[0..10000] of ty2;
  f,fall:array[0..10000] of extended;
  sa,g:array[0..10000] of longint;
procedure sort(l,r:longint);
var
  i,j,tmp1:longint;
  tmp2,m:extended;
begin
  i:=l; j:=r; m:=fall[(i+j) >> 1];
  repeat
    while fall[i]<m do inc(i);
    while fall[j]>m do dec(j);
    if i<=j then
    begin
      tmp2:=fall[i]; fall[i]:=fall[j]; fall[j]:=tmp2;
      tmp1:=sa[i]; sa[i]:=sa[j]; sa[j]:=tmp1;
      inc(i); dec(j);
    end;
  until i>j;
  if i<r then sort(i,r);
  if j>l then sort(l,j);
end;
function check(l,r:longint):boolean;
begin
  if abs(fish[sa[l]].x-fish[sa[r]].x)/v+fall[l]-fall[r]>zero then exit(false);
  exit(true);
end;
procedure huisu(x:longint);
begin
  if g[x]>0 then huisu(g[x]);
  inc(tot);
  all:=all+fish[sa[x]].w;
  step[tot].s:=sa[x];
  step[tot].x:=fish[sa[x]].x;
  step[tot].t:=fall[x];
end;
begin
  assign(input,'nemo6.in'); reset(input);
  assign(output,'nemo6.out'); rewrite(output);
  randomize;
  read(w0,v,tot_t,x0,y0);
  read(n); all:=0;
  for i:=1 to n do
  begin
    read(fish[i].w,fish[i].x,fish[i].y,fish[i].p,fish[i].q);
    fall[i]:=abs(fish[i].y-y0)/abs(fish[i].q);
    sa[i]:=i;
  end;
  sort(1,n);
  for i:=1 to n do f[i]:=-100000000;
  f[0]:=0;
  for i:=1 to n do
  begin
    for j:=0 to i-1 do
    if check(j,i) and (f[i]<f[j]+fish[sa[i]].w) then
    begin
      f[i]:=f[j]+fish[sa[i]].w;
      g[i]:=j;
    end;
    if best<f[i] then
    begin
      best:=f[i];
      t:=i;
    end;
  end;
  huisu(t);
  writeln(tot);
  writeln(all:0:6);
  for i:=1 to tot do
  writeln(step[i].t:0:6,' ',step[i].x:0:6,' ',step[i].y:0:6,' ',step[i].s);
  close(input); close(output);
end.
```
第七组和第八组思路参见递推题目 [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)
```pascal
program nemo7;
{for case7/8}
uses math;
type
  ty=record
    t,x,y:extended;
    s:int64;
  end;
 
var
  n,tx,tot,p,q,maxq,ans,wi:int64;
  i,j:longint;
  w,v,t,x0,y0,time:extended;
  fash,id:array[0..2000,0..2000] of int64;
  step:array[0..2000] of ty;
  f,g:array[0..2000,0..2000] of int64;
procedure huisu(x,y:int64);
begin
  if x>1 then huisu(x-1,g[x,y]);
  inc(tot);
  //writeln(x,' ',y);
  time:=time+sqrt(sqr(x-y0)+sqr(y-x0))/v;
  step[tot].t:=time;
  step[tot].x:=y; step[tot].y:=x;
  x0:=y; y0:=x;
  step[tot].s:=id[x,y];
end;
begin
  assign(input,'nemo7.in'); reset(input);
  assign(output,'nemo7.out'); rewrite(output);
  read(w,v,t,x0,y0);
  read(n);
  fillchar(fash,sizeof(fash),$fe);
  for i:=1 to n do
  begin
    read(wi);
    read(p,q); fash[q,p]:=wi;
    id[q,p]:=i;
    if maxq<q then maxq:=q; read(p,q);
  end;
  fillchar(f,sizeof(f),$fe);
  for i:=0 to 2000 do
  f[0,i]:=0;
  for i:=1 to maxq do
  for j:=0 to 2000 do
  if f[i-1,j+1]>f[i-1,j-1] then
  begin
    f[i,j]:=f[i-1,j+1]+fash[i,j];
    g[i,j]:=j+1;
  end else
  begin
    f[i,j]:=f[i-1,j-1]+fash[i,j];
    g[i,j]:=j-1;
  end;
  for i:=0 to 2000 do
  if ans<f[maxq,i] then
  begin
    ans:=f[maxq,i];
    tx:=i;
  end;
  writeln(maxq);
  writeln(extended(ans):0:6);
  time:=0;
  huisu(maxq,tx);
  for i:=1 to maxq do
  writeln(step[i].t:0:6,' ',step[i].x:0:6,' ',step[i].y:0:6,' ',step[i].s);
  close(input); close(output);
end.
```

第九组数据简单贪心即可
```pascal
program nemo;
{for case 9}
const max=10000000;
      zero=1e-6;
type
  ty1=record
    w,x,y,p,q:extended;
  end;
  ty2=record
    t,x,y:extended;
    s:longint;
  end;
var
  w,x,y,v,tot_t,now_t,ans,d:extended;
  n,i,j,t,tot:longint;
  f:array[0..10000] of ty1;
  get:array[0..10000] of boolean;
  step:array[0..10000] of ty2;
function dis(i:longint; x,y:extended):extended;
begin
  exit(sqrt(sqr(x-f[i].x)+sqr(y-f[i].y)));
end;
begin
  assign(input,'nemo9.in'); reset(input);
  assign(output,'nemo9.out'); rewrite(output);
  read(w,v,tot_t,x,y);
  read(n); ans:=0; tot:=0; now_t:=0;
  fillchar(get,sizeof(get),false);
  for i:=1 to n do read(f[i].w,f[i].x,f[i].y,f[i].p,f[i].q);
  for i:=1 to n do
  begin
    d:=max; t:=0;
    for j:=1 to n do
    if not get[j] and (f[j].w-w<-zero) and (dis(j,x,y)<d)  then
    begin
      t:=j;
      d:=dis(j,x,y);
    end;
    if t=0 then break;
    now_t:=now_t+dis(t,x,y)/v;
    if now_t-tot_t>zero then break;
    get[t]:=true;
    w:=w+f[t].w;
    ans:=ans+f[t].w;
    inc(tot);
    step[tot].t:=now_t;
    step[tot].s:=t;
    step[tot].x:=f[t].x;
    step[tot].y:=f[t].y;
    x:=f[t].x; y:=f[t].y;
  end;
  writeln(tot);
  writeln(ans:0:6);
  for i:=1 to tot do
  writeln(step[i].t:0:6,' ',step[i].x:0:6,' ',step[i].y:0:6,' ',step[i].s);
  close(input); close(output);
end.
```

望管理大大通过T_T

看我这么晚了还在写题解，不点个赞再走嘛？

附一个有趣的打飞机游戏（源码有需要请找我私信索要）

[传送门（提取码：xamg）](https://pan.baidu.com/s/1sXE__4YTtm-T9MOHWGQxPg)

感谢神犇们光顾蒟蒻的题解Orz

---

## 作者：Aly_ (赞：34)


#### 初步分析

​	**nemo 肯定走直线**。

​	不妨把 nemo 想象成只能以速度 $v$ 运动或静止。而在最优策略中，nemo 显然不会静止不动。

​	所以 nemo 的最优策略一定取如下形态：**以某种顺序把食物排成一列 $\{p_i\}$，从 $\{p_1\}$ 开始一个一个吃，每次都走当前最短时间对应路径**。

​	因为 nemo 已知了各食物的位置和速度，nemo 可以在目标食物的路径上某点等待，而最优的该点必然满足 nemo 和食物同时到达。因而可以计算出其到单个食物所需的最短时间。

​	简单的高中解三角形问题，这里不再赘述。设 nemo 与食物距离为 $s$，食物运动的方向与 nemo 相对于食物的方向夹角为 $\theta$，nemo 速度为 $v$，食物速度为 $u$，联合运用向量点积和余弦定理得出 nemo 走到食物的最短时间为
$$
t=s\frac{u\cos\theta\pm\sqrt{u^2(\cos^2\theta-1)+v^2}}{u^2-v^2}
$$
​	等式成立性与加减号取法：

- 当 $\Delta=u^2(\cos^2\theta-1)+v^2<0$ 或 $\cos\theta<0\&\& u>v$ 时，nemo 追不上。
- 否则**取减号一定更优**并且 $t$ 必为正。证明就是用 $\Delta\ge 0$ 化一下。
- 特别地，$u=v$ 特判掉。

​	目标变为求**最优的排列** $\{p_i\}$。

#### 点一

​	就两个点手玩都可以啊喂

#### 点二

​	枚举全部 $8!=40320$ 种排列。

#### 点三

​	特点：nemo 一开始体重太小而食物权值呈 $2$ 的整次幂。

​	只能从小往大吃。

#### 点四

​	特点：所有食物与 nemo 共线且静止不动。所有食物权值不过 200。

​	先慢慢增大自己的体重，达到一定量可以吃所有食物后进行区间 DP 即可。

#### 点五，六

​	特点：所有食物在高空以高速下落，水平位置相隔近。nemo 速度小，但可以吃所有食物。

​	可以看做 nemo 只能在横轴上运动，接住下落的食物。

​	设 $f_i$ 表示接住第 $i$ 个食物所能获得的最大体重，直接转移。

​	点六有一个坑在于有两个食物会同时下落到相同位置。

#### 点七，八
![](https://cdn.luogu.com.cn/upload/image_hosting/2nmsbss3.png)

​	特点：如图。数字三角形的形态已经很明显了。观察权值发现每一行只能选一个，而时间恰好够 nemo 走到最后一排。

​	数字三角形即可。

#### 点九

​	特点：所有食物静止

​	跟点十一起做。

#### 点十

​	特点：好像没有

​	这道题唯一折磨人的点。

​	考虑一个贪心策略：每次在当前所有能吃的食物中按某种关系选出最优的那一个并吃掉。重复该流程直至找不到可以吃的食物为止。

​	设对于一个食物 $i$，其权值为 $w_i$，nemo 吃掉它所需时间为 $t_i$，nemo 吃掉它时 nemo 的位置距当前位置为 $d_i$。

​	肯定会有一些感性的认识：$w_i$ 越大越好，$t_i$ 越小越好，$d_i$ 越小越好，$\frac{w_i}{t_i}$ 越大越好 $\cdots$

​	各人有各人的偏好，各种调参方法都能过，但调参的过程无一例外的折磨。这里题解采用
$$
k_i=\frac{w_i}{t_i^2}+\frac{1}{K_1d_i}+K_2
$$
​	每次选 $k_i$ 最大的吃。$K_1,K_2$ 为两个 $[1,10]$ 的随机数。

​	**多次贪心取最优解**。实测在 10 次之内可以出答案，所花时间不超过 5s。

```
double eat2(){
	while(!pq.empty())pq.pop();
	double ct,nans=w0,nt=0;nx=fx,ny=fy,pa=0;
	for(int i=1;i<=n;i++){
		fl[i]=0;
		if(w[i]<nans){
			ct=calnt(i,nt);
			pq.push(make_pair(w[i]/(ct*ct)+G/dis(nx,ny,ax[i]+nt*mx[i],ay[i]+nt*my[i])+rand()%10,i));
		}
	}
	while(!pq.empty()){
		int ng=pq.top().second;pq.pop();
		fl[ng]=1,ct=calnt(ng,nt);
		if(nt+ct>T)break;
		nx=ax[ng]+(nt+ct)*mx[ng];
		ny=ay[ng]+(nt+ct)*my[ng];
		na[++pa]=(eve){nt+ct,nx,ny,ng};
		nans+=w[ng];
		nt+=ct;
		while(!pq.empty())pq.pop();
		for(int i=1;i<=n;i++)if(w[i]<nans&&!fl[i])ct=calnt(i,nt),pq.push(make_pair(w[i]/(ct*ct)+G/dis(nx,ny,ax[i]+nt*mx[i],ay[i]+nt*my[i])+rand()%10,i));
	}
	if(nans>aans){
		aans=nans,pans=pa;
		for(int i=1;i<=pa;i++)ans[i]=na[i];
	}
	return nans;
}
```



---


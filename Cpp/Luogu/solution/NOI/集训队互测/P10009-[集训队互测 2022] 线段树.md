# [集训队互测 2022] 线段树

## 题目背景

请注意：**本题不是线段树模板题**。

## 题目描述

给定一个长度为 $n$ 的序列 $a_1,a_2,\cdots a_n$。你需要进行共 $q$ 次下面两种操作：

- `1 l r`：将 $a_{l\sim r}$ 替换为它的异或差分。形式化地说，令 $b_i := a_i \text{ xor } a_{i-1}$（$l<i\leq r$），然后对于每个 $l<i\leq r$，将 $a_i$ 替换为 $b_i$。

- `2 pos`：查询 $a_{pos}$ 的值。

操作执行完后，你还需要回答最终的 $a$ 序列。

## 说明/提示

**更多样例见下发文件**。对于第 $i + 1$ 个样例，$T = i$。

### 样例 1 解释

初始时 $a=[1,1,5,1,9,4]$。

第一个操作要求输出 $a_5$，此时 $a_5=9$，故输出 $9$。

第二个操作要求将 $a_{2\sim 5}$ 替换为它的异或差分，$a_{2\sim 5}$ 为 $[1,5,1,9]$，它的异或差分为 $[1,4,4,8]$，故操作执行完后，$a$ 序列变为 $[1,1,4,4,8,4]$
。

第三个操作要求输出 $a_4$，此时 $a_4=4$，故输出 $4$。

第四个操作要求将 $a_{3\sim 6}$ 替换为它的异或差分， $a_{3\sim 6}$ 为 $[4,4,8,4]$，它的异或差分为 $[4,0,12,12]$，故操作执行完后， $a$ 序列变为 $[1,1,4,0,12,12]$。

第五个操作要求输出 $a_6$，此时 $a_6=12$，故输出 $12$。

第六个操作要求将 $a_{1\sim 6}$ 替换为它的异或差分， $a_{1\sim 6}$ 为 $[1,1,4,0,12,12]$，它的异或差分为 $[1,0,5,4,12,0]$，故操作执行完后，$a$ 序列变为 $[1,0,5,4,12,0]$。

最终的 $a$ 序列为 $[1,0,5,4,12,0]$。

### 数据范围与约定

对于所有数据，保证 $1\leq n\leq 2.5\times 10^5$，$1\leq q\leq 10^5$，$0\leq a_i< 2^{30}$，$1\leq l\leq r\leq n$，$1\leq pos\leq n$。

| 子任务编号 |     $n\leq$      |    $q\leq$     | 特殊性质 | 分值 |   子任务依赖    |
| :--------: | :--------------: | :------------: | :------: | :--: | :-------------: |
|    $1$     |  $2\times 10^3$  | $2\times 10^3$ |    无    | $8$  |       无        |
|    $2$     | $2.5\times 10^5$ |     $10^5$     |    A     | $4$  |       无        |
|    $3$     | $2.5\times 10^5$ |     $10^5$     |    B     | $7$  |       无        |
|    $4$     | $2.5\times 10^5$ |     $10^5$     |    CD    | $13$ |       无        |
|    $5$     | $2.5\times 10^5$ |     $10^5$     |    DE    | $12$ |       无        |
|    $6$     | $2.5\times 10^5$ |     $10^5$     |    D     | $16$ |       $5$       |
|    $7$     | $2.5\times 10^5$ |     $10^5$     |    E     | $11$ |       $5$       |
|    $8$     | $2.5\times 10^5$ |     $10^5$     |    无    | $29$ | $1,2,3,4,5,6,7$ |

特殊性质 A：$\forall i\geq 2, a_i=0$。

特殊性质 B：$0\leq a_i\leq 1$。

特殊性质 C：记序列 $a$ 中非零位置个数为 $c$，则 $c\leq 100$。

特殊性质 D：操作 $1$ 满足 $l=1$，$r=n$。

特殊性质 E：没有操作 $2$。


## 样例 #1

### 输入

```
1
6 6
1 1 5 1 9 4
2 5
1 2 5
2 4
1 3 6
2 6
1 1 6```

### 输出

```
9
4
12
1
0
5
4
12
0
```

# 题解

## 作者：zyc070419 (赞：6)

# P10009 [集训队互测 2022] 线段树 题解

## 前置知识

* 分块
* 组合
* Kummer 定理
* 高维前缀和

## 题解

各部分的代码都放到最后了……

### Subtask #1

$\mathcal{O}(nq)$ 模拟即可。

### Subtask #2

由于 $\forall i\ge 2,a_i=0$，所以说经过若干次操作之后得到的新数列 $\{a_n'\}$ 一定满足：$a_i'=0$ 或 $a_i'=a_1$，所以设 $b_i=[a_i'=a_1]$。然后就可以 $\texttt{bitset}$ 优化，复杂度 $\mathcal{O}(\dfrac{nq}{w})$。

### Subtask #3

$\texttt{bitset}$ 优化即可，复杂度 $\mathcal{O}(\dfrac{nq}{w})$。

### Subtask #4

$D$ 性质的本质相当于对整个数列做 $k$ 次差分。

引理一：

> 对于整个数列做 $k$ 次差分之后的数列 $\{a_n'\}$ 满足：

$$
a_i=\bigoplus_{j=1}^{i}a_j\left[\binom{k}{i-j}\equiv 1\pmod 2\right]
$$

证明方法与数列的 $k$ 次加法差分结果证明类似，有两种理解方法：

第一种较为代数的理解，因为位运算每一位独立，所以可以每一位单独考虑，下文设 $a_i\in \{0,1\}$。设幂级数 $F(x)=\sum_{i\ge 0}a_i x^i$，而异或相当于不进位加法，所以先当成加法来考虑，则进行一次差分相当于将 $F(x)$ 乘 $(1-x)$，那么 $k$ 次差分就有：

$$
\begin{aligned}
F_k(x)&=F(x)\times (1-x)^k\\
&=\sum_{i\ge 0}a_x\times x^i\sum_{j\ge 0}(-1)^j\binom{k}{j}x^j
&=\sum_{i\ge 0}x^i\sum_{p+q=i}a_p\times (-1)^q\times \binom{k}{q}
\end{aligned}
$$

所以 $[x^n]F_k(x)=\sum_{i}a_i\times (-1)^{n-i}\times \binom{k}{n-i}$。那么异或差分的系数就是：

$$
(\sum_{i}a_i\times (-1)^{n-i}\times \binom{k}{n-i})\bmod 2=\bigoplus_i a_i\Bigg[\binom{k}{i-j}\equiv 1\pmod 2\Bigg]
$$

第二种理解方式比较组合：考虑 $a_i$ 在一次差分之后会向哪里贡献对：$a_i'$ 和 $a_{i+1}'$ 分别贡献一次，所以说 $a_j$ 对 $a_i'$ 的贡献次数就是：**有一个点最开始在 $j$，操作 $k$ 次，每次选择向右走一个单位或者原地不动，$k$ 次之后到达 $i$ 的方案数**，也就是 $\binom{k}{i-j}$。方案数为奇数就让 $a_i'$ 异或 $a_j$，否则不修改。

又因为当且仅当 $a_j\not=0$ 时才有可能对 $a_i'$ 的值有影响，所以说可以只枚举 $a_j$ 不为 $0$ 的位置计算，复杂度 $\mathcal{O}(c(n+q))$。

### Subtask #5

只用知道最后一次操作，所以说~~可以卷积~~，可以选择进行 DP。

首先由上可知，$a_j$ 能对 $a_i$ 产生贡献当且仅当 $\binom{k}{i-j}$ 为奇数，也就是不含 $2$ 的次幂，那么可以考虑 Kummer 定理：$\binom{k}{i-j}$ 为奇数当且仅当 $k\ \operatorname{and}\ (i-j)=(i-j)$，其中 $\operatorname{and}$ 是按位与运算。那么设 $dp_{i,p}$ 表示所有满足 $i-j$ 在二进制下的最高位不超过第 $p$ 位并且满足 $k\ \operatorname{and}\ (i-j)=(i-j)$ 的 $a_j$ 的异或和。那么有转移：

$$
\left\{
\begin{matrix}
dp_{i,p}&=&dp_{i,p-1} && k_p=0\\\\
dp_{i,p}&=&dp_{i,p-1}\oplus dp_{i-2^p,p-1} && k_p=1
\end{matrix}
\right.
$$

$k_p$ 表示 $k$ 在二进制下的第 $p$ 位。

复杂度 $\mathcal{O}(n\log n+q)$。

### Subtask #6

因为多次单点询问，每一次询问的之后差分的次数不一样，并且不好递推，所以~~自然想到~~分块。

为了与我的代码表现一致，下文中记 $K$ 表示 $k$ 取反后的结果，这样条件就变成了 $K\ \operatorname{and}\ (i-j)=0$。

规定 $\operatorname{lowbit}(x),\operatorname{highbit}(x)$ 分别表示 $x$ 在二进制下的最低位，最高位。

因为可以发现我们异或的是一段一段区间，异或的每一段的区间长度为 $2^{\operatorname{lowbit}(K)}$，任意两个需要异或的区间之间的距离最短是 $2^{\operatorname{logbit}(K)+1}$。所以如果 $\operatorname{lowbit}(K)$ 很大就好了，所以想到了根号分治，或者说值域分块。先设置一个阈值 $B$。

$dp_{i,j}$ 表示当 $K=j$ 时 $a_i'$ 的值，其中 $j< 2^B$。记 $sum_{l,r}=\bigoplus_{i=1+1}^ra_i$。记 $l(x)=2^{\operatorname{lowbit}(x)},h(x)=2^{\operatorname{highbit}(x)}$

为了让转移式子情况没有那么多，下面规定 $\forall i \le 0，a_i=dp_{i,j}=0$。然后就有转移：

$$
\left\{
\begin{matrix}
dp_{i,j} &=& dp_{i-2j,j}\oplus sum_{i-j,i}&& \operatorname{lowbit}(j)=\operatorname{highbit}(j)\\\\
dp_{i,j} &=& dp_{i,j-h(j)}\oplus dp_{i-h(j),j-h(j)}\oplus dp_{i-2h(j),j}&& otherwise.
\end{matrix}
\right.
$$

由于 $B$ 位以下的要求已经处理完了，但是无法保证 $B$ 位及以上是否满足要求，所以说 $a_i'$ 最终的答案是：

下面记 $y=(K\ \operatorname{and}\ (2^B-1)),x=K-y$。

$$
\bigoplus_{j\ge 0}(dp_{i-j\times 2^B,y}\oplus dp_{i-(j+1)\times 2^B,y})\big[(j\times 2^B)\ \operatorname{and}\ x=0\big]
$$

预处理 DP 复杂度 $\mathcal{O}(n\times 2^B)$，询问复杂度 $\mathcal{O}(\dfrac{nq}{2^B})$。取 $B=8$ 时较为优秀。总复杂度大致可以看作 $\mathcal{O}(n\sqrt{q})$。

### Subtask #7, 8

我不是很清楚 Subtask #7 具体有什么算法，或许有什么必须依赖离线的方法？

因为上面的算法只能处理全局差分，但现在是区间差分，没法搞，所以可以分块。

对序列分块，整块打整体差分 $\text{tag}$，散块暴力。~~然后整道题就解决了~~。

可以发现如果只这样搞得话显然很难维护，因为假设我们给第 $i$ 个整块 $[l,r]$ 打了一次 $\text{tag}$，那么这次操作带来的影响还跟打 $\text{tag}$ 之前 $a_{l-1}$ 的真实值有关，所以我们需要把每一次打 $\text{tag}$ 之前的 $a_{l-1}$ 的真实值也维护。

所以说可以尝试先把每次修改前 $a_{l-1}$ 的值存下来。

现在先假设我们已经把所有操作前 $a_{l-1}$ 的值存了下来，整块 $[l,r]$ 到现在一共进行了 $m$ 次操作，第 $i$ 次操作前 $a_{l-1}$ 的真实值是 $v_i$。那么现在如何快速下放 $\text{tag}$ 进行还原呢？

由于对于 $i\in[l,r]$，有：

$$
a_{i}'=(\bigoplus_{j=l}^{i}\binom{m}{i-j}a_j)\oplus (\bigoplus_{j=1}^{m}b_{i,j}\times v_j)
$$

其中 $b_{i,j}$ 是 $v_j$ 对 $a_i$ 的贡献系数，$b_{i,j}\in \{0,1\}$。

左半部分是可以按照 Subtask #5 的方法 DP 的（这部分的贡献在下文称作 **段内贡献**），而右半部分（这部分贡献下文称作 **特殊贡献**）首先要求出系数：

考虑组合意义（其实代数肯定也能推，但比较麻烦）：

$v_i$ 在第 $i$ 个时刻第一次到达 $l$ 这个位置，然后还剩下 $m-i$ 个时刻可以移动，并且剩下的 $m-i$ 个时刻每次可以选择原地不动或者向右一步，贡献系数就是路径方案数，即：

$$
b_{i,j}=\binom{m-j}{i-l}\bmod 2
$$

然后再用一次 Kummer 定理，当且仅当 $(m-j)\ \operatorname{and}\ (i-l)=(i-l)$ 时才有贡献。那么如果 $m$ 是固定的，就能先设数组 $V_i=v_{m-i}$，然后对 $\{V_0,\cdots ,V_{m-1}\}$ 做高维后缀异或和得到 $V'$，那么 $v$ 数组对 $a_i$ 的贡献就是 $V_{i-l}'$。综上即：

$$
a_{i}'=(\bigoplus_{j=l}^{i}\binom{m}{i-j}a_j)\oplus V_{i-l}'
$$

那么如何维护 $v$ 数组呢？要求出 $v_i$ 就需要求出 $a_{l-1}$ 的值，但又不能把 $a_{l-1}$ 所在的成块还原，不然复杂度又变成 $\mathcal{O}(n^2)$ 的。所以说要支持动态单点算出 $a_{l-1}$，更一般性的说，要快速算出每一段（除了最后一段）末尾一个元素的真实值。

求解方法跟上面说的一样分成两块：

假设第 $i$ 个整块的区间为 $[L_i,R_i]$。下文以第 $i$ 个整块为例说明 $a_{R_i}$ 如何求。

对于段内贡献，可以求出新的数组 $A_j=a_{R_i-j},j\in [0,R_i-L_i]$，然后对 $A$ 作高维前缀和得到 $A'$ 数组，那么如果整块差分了 $t$ 次，段内贡献就是 $A'_m$。而整块打 $\text{tag}$ 是部分影响块内的值的，也就是说 $A'$ 数组在整块操作中是不会改变的，如果散块暴力的时候会改变，所以求解是可以接受的。

对于特殊贡献，因为 $m$ 会变，所以 $V$ 在不断的改变，高维后缀和也在不断的改变，那就没法维护了，~~所以做不了了~~。

$m$ 虽然在变，但是 $R_i-L_i$ 是不会变的，所以说要从这个地方为突破口。

> 如果 $x\ \operatorname{and}\ (2^t-1)=(2^t-1)$，其中 $t$ 为一个常量，那么说明 $x\equiv -1 \pmod {2^t}$。

这个很重要，把位运算变成了我们熟悉的运算。所以说，如果设 $R_i-L_i=2^t-1$ 特殊贡献就相当于：

$$
\bigoplus_{j=1}^{m}v_j\big[m-j\equiv -1 \pmod {2^t} \big]=\bigoplus_{j=1}^{m}v_j\big[j\equiv m+1 \pmod {2^t} \big]
$$

所以记 $val_{j}=\bigoplus_{p=1}^{m}v_p\big[p\equiv j \pmod {2^t} \big]$，然后当操作次数为 $m$ 次时特殊贡献就是 $val_{(m+1)\bmod 2^{t}}$。

综上所述就完成了对于 $a_{R_i}$ 的动态求解，设块长 $B=2^t$，复杂度为 $\mathcal{O}(qB\log B+\dfrac{nq}{B})$，当 $t=8$ 时最优。

代码在[这里](https://www.luogu.com.cn/paste/2mrrz1th)，代码中的 `subtask1，subtask2,subtask3,subtask4` 分别对应原题中的 Subtask #1，Subtask #2~3，Subtask #4~6，Subtask #7～8。

---

## 作者：nullqtr_pwp (赞：5)

出题人为了炫耀自己的小常数，模拟赛开 $1$ 秒，懒得喷。同机房同学的不讲人话题解污染到大家眼睛了所以来写一篇。

我们大概需要用较慢的时间来处理询问，以平衡修改的复杂度。

先来一波数形结合抽象化问题。对于任意时刻的 $a_i$，必然由若干个 $j\leq i$ 的 $a_j$ 异或而来。考虑一张网格图，点 $(x,y)$ 表示第 $x$ 个版本第 $y$ 个位置。令一次修改为创建一个新版本，一条有向边代表新版本的值会由这个点异或而来。首先要继承，任意 $(c,i)$ 必然对 $(c+1,i)$ 有边，而一操作就相当于，令当前版本为 $c$，对所有 $l\leq i<r$ 的 $(c,i)$，连边 $(c,i)\to (c+1,i+1)$。重新考虑 $a_i$ 由哪些异或而来。显然当且仅当 $(0,j)\to (c,i)$ 有奇数条路径时，$a_i$ 会异或上 $a_j$。

### 特殊性质 D：所有询问满足 $l=1,r=n$
考虑特殊性质 D，每次修改操作 $l=1,r=n$。那么 D 性质相当于可以直接计算路径条数，即有 $\begin{pmatrix}
 c\\
i-j
\end{pmatrix}$ 条路径，这个东西需要对 $2$ 取模，而由 Lucas 定理有 $\begin{pmatrix}
 c\\
i-j
\end{pmatrix}\Longleftrightarrow c\text{ and }(i-j)=(i-j)$。这里的 $\text{and}$ 就是二进制与运算。即经过 $x$ 次全局修改后 $a'_i=\oplus_{y\subseteq x}a_{i-y}$。这个奇怪东西直接分块。考虑取 $B=2^k$ 作为块长，每经过 $B$ 次修改就重构所有块，那么询问时只需要考虑前一块，并且由于 $x\leq B$，可以暴力枚举 $x$ 的子集。令 $B$ 尽量接近，时间复杂度 $O(q\sqrt n)$。

### 一般情形

我们也需要进行序列分块，也让 $B$ 取 $2$ 的幂并且尽量接近 $\sqrt n$。考虑维护若干信息，并且在查询单点时重构 $x$ 所在的块。沿用 $l=1,r=n$ 的思路，我们希望整个块在重构到当前的每个版本都**一起**向右上连边或者一起不连边。如果出现散块，当然需要暴力重构，但是我们仍然难以处理前面的影响。

瓶颈在于，现在需要考虑距离当前块之前的之前以及再前面的块，这是不好的。但是我们考虑，对于每个整块，我们事实上允许重构 $O(\dfrac{q}{B})$ 次，也就是每 $B$ 次整块加就重构整个块。那么做重构时，所有块的实际版本距离上一次重构的版本的差距均在 $B$ 以内，就可以**只关心上一个块**的贡献。具体的实现细节就是维护 $cnt_i$ 表示第 $i$ 块被整体操作了多少次，如果 $cnt_i$ 在某一时刻等于 $B-1$ 就立刻进行重构并清空 $cnt_i$，否则就令 $cnt_i\to cnt_i+1$ 并暂时不进行操作。

考虑具体重构的细节，我们需要用接近 $O(B)$ 的复杂度来重构。注意到重构时我们事实上**并不能**直接对前一块的实际 $a$ 进行访问，因为这样递归下去的复杂度是彻底错掉的。依然把问题刻画成格路径，用 [CF1713F](https://www.luogu.com.cn/problem/CF1713F) 的套路，可以设定一个 $x=\text{Leftbound}_{id}-1$，先把所有的路径放到这条直线上，再通过这条直线分发到后续的 $a_i$ 上。而我们真正需要关心的是前一块的数的贡献。考虑一组下标为 $(0,B-1)$ 的列向量 $tmp$，第 $x$ 个表示操作 $x$ 次接收到上一块的贡献，即 $\oplus_{y\subseteq x}a'_{y}$，此处 $a'_i$ 表示上一块到那个直线距离 $i$ 的 $j$ 对应的 $a_j$ 的值。那么在重构时只需要对这个向量做一遍超集异或和 $g$，然后，先做 $a$ 块内之间的相互贡献，然后 $a_{i+\text{Leftbound}}\to a_{i+\text{Leftbound}}\oplus g_{i}$，可以 FWT 实现。

当然重构时需要维护一个向后贡献的向量，就是假设操作 $i$ 次时的子集和，同样用 FWT 做一下就行。这两个 FWT 的步骤事实上与 [CF1713F](https://www.luogu.com.cn/problem/CF1713F) 极为相似。

重构一次的时间复杂度高达 $O(B\log B)$，无法优化了。注意到一个块最多重构 $O(\dfrac{q}{B})$ 次，一共有 $\dfrac{n}{B}$ 个块，取合适的块长可以做到总时间复杂度 $O(n+q\sqrt n\log n)$。



```cpp
namespace realsolve{
	const int B=512;
	int num[maxn],bel[maxn],bl[maxn],br[maxn],ttt[maxn];
	void FWT(int *f,int op){
		for(int i=1;i<B;i<<=1)for(int j=0;j<B;j+=(i<<1))F(k,0,i-1){
			if(op)f[j^k]^=f[i^j^k];
			else f[i^j^k]^=f[j^k];
		}
	}
	int tmp[2005][2005],val[2005][2005];
	void pushdown(int x){
		const int k=num[x];
		F(i,0,18)if((k>>i)&1)dF(j,B-1,(1<<i))a[bl[x]+j]^=a[bl[x]+j-(1<<i)];
		F(i,0,B-1)ttt[i]=0;
		F(i,1,k)ttt[k-i]=tmp[x][i];
		FWT(ttt,1);
		F(i,0,B-1)a[bl[x]+i]^=ttt[i];
		num[x]=0;
	}
	void rebuild(int x){
		F(i,0,B-1){
			if(bl[x]+i>br[x])val[x][i]=0;
			else val[x][i]=a[br[x]-i];
		}
		FWT(val[x],0);
	}
	void update(int l,int r){
		if(bel[l]==bel[r]){
			pushdown(bel[l]);
			dF(i,r,l+1)a[i]^=a[i-1];
			rebuild(bel[l]);
			return;
		}
		pushdown(bel[l]);
		int lst=a[br[bel[l]]];
		dF(i,br[bel[l]],l+1)a[i]^=a[i-1];
		rebuild(bel[l]);
		F(i,bel[l]+1,bel[r]-1){
			tmp[i][++num[i]]=lst,lst=val[i][num[i]-1];
			if(num[i]==B-1)pushdown(i),rebuild(i),num[i]=0;
		}
		pushdown(bel[r]);
		dF(i,r,bl[bel[r]]+1)a[i]^=a[i-1];
		a[bl[bel[r]]]^=lst;
		rebuild(bel[r]);
	}
	void solve(){
		F(i,1,n)a[i]=read(),bel[i]=(i-1)/B+1;
		F(i,1,bel[n])bl[i]=(i-1)*B+1,num[i]=0,br[i]=min(i*B,n);
		F(i,1,bel[n])rebuild(i);
		F(______________________,1,zsy){
			const int op=read();
			if(op==1){
				const int l=read(),r=read();
				update(l,r);
			}else{
				const int x=read();
				pushdown(bel[x]),rebuild(bel[x]);
				printf("%d\n",a[x]);
			}
		}
		F(i,1,bel[n])pushdown(i);
		F(i,1,n)printf("%d\n",a[i]);
	}
}
```

---

## 作者：KSCD_ (赞：4)

#### 题意

维护序列 $a$，需要支持区间变为异或差分，单点查询，最后输出整个序列。$n\le 2.5\times 10^5,q\le 10^5,a_i<2^{30}$。

#### 题解

先考虑 D 性质，即 $l=1,r=n$ 的情况。此时若进行了 $x$ 次操作，则目前 $a'_i=\bigoplus_{j\subseteq x}a_{i-j}$，其中 $j\subseteq x$ 表示二进制下 $j$ 为 $x$ 的子集。证明可考虑 $x$ 行的网格图，其所有格中均存在左上到右下的对角线，要求只能向下或右下走。则 $a_{i-j}$ 对 $a'_i$ 的贡献次数即为 $(0,i-j)$ 到 $(x,i)$ 的路径条数 ${x}\choose{j}$，根据卢卡斯定理可得当且仅当 $j\subseteq x$ 时有 ${x\choose j}\equiv 1\pmod 2$，$a_{i-j}$ 对最终 $a'_i$ 有贡献。

然而 $x$ 较大时无法直接枚举子集，考虑定期重构，每当 $x=B=2^k$ 时更新整个序列并将 $x$ 清空。注意到此时子集只有 $0$ 和 $2^k$，可以 $O(n)$ 更新，复杂度为 $O(\frac{nq}B)$。这样查询时 $x$ 不会超过 $2^k$，直接枚举子集即可，复杂度为 $O(qB)$。取 $\sqrt n$ 附近的 $2^k$ 作为 $B$，得到总复杂度为 $O(q\sqrt n)$。

变为区间修改时，仍对每 $B$ 个修改分一块，回答其内部的询问，同时更新出整个序列在这 $B$ 次修改后的值。注意到由于修改次数不超过 $B$，此时 $a'_i$ 的值只受 $[i-B,i]$ 内 $a$ 值的影响。因此我们再对序列每 $B$ 个元素分一块，则某块内元素的值只受该块和前一个块影响。因此可以先枚举操作块，再枚举序列中每个块依次处理，此时只需要考虑序列中的两个块。

具体地，处理块 $i$ 时拿出块 $i,i-1$，若修改完全包含两个块则只累加 $x$ 标记；若修改只包含两块的一部分，则要清空 $x$ 标记并重构两个块，再进行区间暴力修改。对于某个在块 $i$ 内的询问，可将标记清空再查单点值，或直接枚举 $x$ 的子集求答案。这里清空标记不能暴力枚举所有 $x$ 的子集，而是要进行类似高维前缀和的操作，即枚举每个 $x$ 是 $1$ 的二进制位 $2^k$，并倒序更新所有 $a_i\leftarrow a_{i}\oplus a_{i-2^k}$，容易发现这样操作的结果与暴力枚举子集相同，复杂度 $O(B\log B)$。

现在计算复杂度。有 $O(\frac nB)$ 个序列块，区间修改影响至多四个块，处理时标记清空复杂度 $O(qB\log B)$，暴力更新复杂度 $O(qB)$。每次查询时若清空标记有 $O(qB\log B)$ 的复杂度，若暴力枚举子集有 $O(qB)$ 的复杂度。另外有 $O(\frac qB)$ 个操作块，每个操作块处理完后需下放所有序列块的标记，复杂度 $O(\frac{nq}{B^2}B\log B)=O(\frac {nq\log B}B)$。综上所述总复杂度为 $O(qB\log B+\frac{nq\log B}B)$，取 $B=\sqrt n$ 可得 $O(q\sqrt n\log n)$。[这里](https://www.luogu.me/paste/j9sn4jy5)给出了特殊性质和两种答案统计方式的代码，其中枚举子集的常数较小。

---

## 作者：伊地知虹夏 (赞：2)

讲一个巨好写的做法。

考虑性质 DE，我们只需要求出 $q$ 次操作后每个数的值。

有一个观察是 $j$ 能贡献到 $i$ 当且仅当 $q \operatorname{and} (i-j) = i-j$。

> 证明：
> 
> 记 $V(x,y)$ 表示 $a_x$ 经过 $y$ 次操作后的值，则有 $V(x,y) = V(x-1,y) \operatorname{xor} V(x-1,y-1)$。
> 
> 考虑其组合意义，即 $V(j,0)$ 对 $V(i,q)$ 的贡献为 $(j,0)$ 到 $(i,q)$ 的不同路径数 $q \choose {i - j}$。
> 
> 由 Kummer 定理知 ${q \choose {i - j} }\equiv 1\pmod 2$ 当且仅当 $q \operatorname{and} (i-j) = i-j$。

然后就可以对 $q$ 的每一位做一个高维前缀异或和求出最后的 $a$ 数组，时间复杂度 $\mathcal O(n \log q)$。

上面这个东西线段树是不好维护的，于是分块。设块长为 $B$，则如果当前 $1$ 操作次数 $\le B$，那么每一块就只要考虑前一块对其的贡献，此时可以轻松做到单次操作 $\mathcal O(B \log B)$。

于是我们想到每 $B$ 次操作重构整个序列。重构时倒序枚举每个块，对其进行修改查询即可。

还有一些实现细节见代码，取 $B$ 为 $2^{\lfloor \frac{\log n}{2}\rfloor}$ 即可做到 $\mathcal O(n + q\sqrt n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,l,r) for (int i = l; i <= r; i ++)
#define rrp(i,l,r) for (int i = l; i >= r; i --)
typedef long long LL;
const int N = 2.5e5 + 5, B = 1 << 9;

int n, q, a[N], pos[N], pl[N], pr[N];

struct upds { int op, l, r; };

void work(vector<upds> &vec) {
	static int b[N];
	rrp (i, pos[n], 1) {
		int l = pl[i-1], r = pr[i], cnt = 0;
		rep (j, l, r) b[j] = a[j];
		auto down = [&]() {
			for (int o; cnt; cnt -= o) {
				o = cnt & (-cnt);
				rrp (j, r, l + o) b[j] ^= b[j - o];
			}
		};
		for (auto &_ : vec) {
			if (_.op == 1) {
				if (_.l > r || _.r < l) continue;
				if (_.l <= l && r <= _.r) { ++ cnt; continue; }
				down(); rrp (j, min(r, _.r), max(l, _.l) + 1) b[j] ^= b[j-1];
			} else {
				if (_.l < l || _.l > r) continue;
				down(), _.r = b[_.l];
			}
		}
		down();
		rep (j, pl[i], pr[i]) a[j] = b[j];
	}
	for (auto _ : vec) if (_.op == 2) cout << _.r << '\n';
	vec.clear();
}

void fakemain() {
	cin >> n >> q, pl[0] = 1;
	rep (i, 1, n) cin >> a[i];
	rep (i, 1, n) pos[i] = (i - 1) / B + 1;
	rep (i, 1, pos[n]) pr[i] = min(i * B, n);
	rep (i, 1, pos[n]) pl[i] = pr[i-1] + 1;
	vector<upds> vec;
	rep (i, 1, q) {
		upds hg; cin >> hg.op >> hg.l;
		if (hg.op == 1) cin >> hg.r;
		vec.push_back(hg);
		if (vec.size() == B) work(vec);
	}
	work(vec);
	rep (i, 1, n) cout << a[i] << '\n';
}

signed main() {
	cin.tie(0)->ios::sync_with_stdio(0);
	int T = 1, tc; cin >> tc;
	while (T --) fakemain();
	cerr << 1. * clock() / CLOCKS_PER_SEC << "s\n";
}
```

---

## 作者：tzl_Dedicatus545 (赞：2)

璀璨星空1是这样的 。

出题人评分你们洛谷管理员也敢信？懒得喷。

### Subtask 1

写你喜欢的暴力，时间复杂度 $\Theta(nq)$。

### Subtask 2&3

手写个 `bitset` 维护 $01$ 序列，支持你喜欢的操作就可以，时间复杂度 $\Theta(\frac{nq}{w})$。

也许你会想到把每个数拆成 $w$ 个 $0/1$，然后企图把这个 Subtask 做到 $o(\frac{nq}{w})$，但是这样你就翻船了/kx/kx/kx。

这个 Subtask 的作用是：迷惑选手。

### Subtask 4&5&6

这些点的共同性质是 $l=1,r=n$。

你可能能想到很多做法，但是这些做法都有致命的缺陷：修改与查询复杂度**严重不平衡**，查询很可能是 $O(1)$ 的，但修改很慢，我们考虑把复杂度大头扔到查询上。

我们**不难注意到**：$p$ 会在 $k$ 次操作后对 $q$ 产生贡献当且仅当 $\binom{k}{q-p}  \equiv 1(\bmod 2),p\leq q$（这个确实很好注意到）

现在我们终于有了一个查询复杂度看起来好一点的东西了！每次在查询的时候枚举子集，但现在修改是 $O(1)$ 的了。

然后你**感觉**到关键性质：枚举子集是很快的，事实上，大部分情况 $\text{popcount}(x)$ 都是 $\dfrac{\log n}{2}$ 量级的，也就是 $\sqrt q$！

这启示我们往根号上想，但是这个做法是可以卡满的！出题人先加 $65535$ 次，然后疯狂查询，你就爆了。

解决方案也很好想啊！根号重构，每当操作次数 $\geq A$ 时，我们就直接对整个序列做一次高维前缀和状物，然后就对了，这个的复杂度是 $\Theta(n\log n)$的。

于是现在我们会了 $\text{soft-}O(n\sqrt{q})$ 做法了。

（但是出题人注意不到，然后发明了抽象神仙做法，令人感慨）

**然后我赛时就会到这里，获得了 $60$ 分，遗憾离场。**

### Subtask ALL

哎呦解决方案也很好想啊！前面的 Subtask 你都只会根号，那你这里直接分块就全对了！

对序列分成 $B$ 块，按修改 $A$ 次为界对询问分块，每次修改 $A$ 次后处理这段时间内所有询问。

**本题关键点：**然后就是，我们发现，一次修改影响的太多了，这不好！我们不妨让 $A < B$（这非常重要），这样我们就获得了一个优秀的性质：一次修改至多影响两个块！然后你处理一段序列的块的时候，就把**涉及这一块和前一块的一起拿出来处理就好了喵**。

显然取 $A=B-O(1)$ 最优。

时间复杂度：$\Theta(q\dfrac{n}{B}+q\dfrac{n\log n}{B}+Bq)$

所以我的做法复杂度是 $q\sqrt{n}\log n$，且这是无法通过调节块长改进的。

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10009)

**题目大意**

> 给定长度为 $n$ 的序列 $a$，支持 $q$ 次区间异或差分和单点求值。
>
> 数据范围：$n\le 2.5\times 10^5,q\le 10^5$。

**思路分析**

考虑分块，记块长为 $B$。

先考虑 $k$ 次全局操作后的结果如何维护，根据经典结论，$a_j\to a_i$ 的贡献系数是 $\binom{k}{i-j}\bmod 2=[i-j\subseteq k]$。

那么我们可以类似 FWT 的方式，设 $f_{x,i}$ 表示只考虑 $i-j<2^x$ 的 $j$ 时 $a_i$ 的值。

那么转移时枚举 $2^x\in k$ 的所有 $x$，$f_{x+1,i}\gets f_{x,i}\oplus f_{x,i-2^x}$ 表示考虑 $2^x\subseteq i-j$ 的 $j$ 的贡献，其他 $f_{x+1}=f_x$。

这种信息显然难以用线段树维护，自然想分块解决。

将原序列分块，每次区间操作时散块下传标记后暴力修改，整块打标记，询问时下传该块的标记。

然后我们分析如何下传标记：

对于一个块 $a_l\sim a_r$，如果其被完整覆盖了 $k$ 次， 那么 $a_j\to a_i$ 的贡献就是 $[i-j\subseteq k]$，用类似刚才的的方式解决即可。

但是我们还要维护每次操作时 $a_{l-1}\to a_l$ 的贡献。

我们要记录每次打标记时 $a_{l-1}$ 的值，设倒数第 $k+1$ 个标记覆盖前 $a_{l-1}$ 的值为 $g_k$（$k$ 从 $0$ 开始标号）。

那么倒数第 $k+1$ 次操作一定会转移 $a_{l-1}\to a_l$，剩下的就是 $k$ 次操作内 $a_{l}\to a_i$ 的贡献系数，也就是 $[i-l\subseteq k]$。

对所有 $a_i$，只需 FWT 求出 $g_k$ 的超集和 $h$，然后 $a_i\gets a_i\oplus h_{i-l}$。

最后我们要在每次打标记时求出 $a_{l-1}$ 的值。

由于打标记的次数较多，因此我们要求 $\mathcal O(1)$ 求出这些 $a_{l-1}$，也即上一个块右端点 $a_R$ 处的值。

这个问题并不好解决，因为如果这个块被修改的次数（懒标记个数）超过该块的长度，说明我们需要更前面块的信息。

因此可以定期重构，如果某个块的标记个数超过该块长度就直接暴力，每次重构消耗 $B$ 个懒标记，而懒标记总数是 $\mathcal O\left(\dfrac{nq}{B}\right)$ 的，因此重构次数是 $\mathcal O\left(\dfrac{nq}{B^2}\right)$ 级别。

如果该块累计的标记个数不超过该块长度，那么设标记个数为 $k$，我们只需要预处理 $a_{R-k}\sim a_R\to a_R$  的贡献，$a_{R-i}\to a_R$ 的贡献系数为 $[R-i\subseteq k]$。

对于每个 $k$，$a_R$ 的取值 $w_k$ 可以 FWT 一遍求子集和得出，每次重构散块时重算每个块对应的 $w_0\sim w_B$。

时间复杂度瓶颈在每次下传标记和重构 $w$ 上，单次 $\mathcal O(B\log B)$。

时间复杂度 $\mathcal O\left(\left(q+\dfrac{nq}{B^2}\right)B\log B\right)$，取 $B=\sqrt{n}$ 得到时间复杂度 $\mathcal O(q\sqrt n\log B)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1<<18,B=1<<9;
int a[MAXN],w[MAXN],bel[MAXN],lp[MAXN],rp[MAXN],len[MAXN];
//w[i]: a[ed[x]] after oper i-lp[x] times
vector <int> tag[MAXN];
void init(int x) { //build block x
	int n=len[x],*f=w+lp[x];
	for(int i=0;i<n;++i) f[i]=a[rp[x]-i];
	for(int k=1;k<n;k<<=1) for(int i=0;i<n;++i) if(i&k) f[i]^=f[i^k];
}
void psd(int x) { //pushdown block x
	vector <int> &g=tag[x];
	int n=len[x],m=g.size(),*f=a+lp[x];
	for(int k=1;k<n&&k<=m;k<<=1) if(m&k) {
		for(int i=n-1;i>=k;--i) f[i]^=f[i-k];
	}
	reverse(g.begin(),g.end());
	for(int k=1;k<m;k<<=1) for(int i=0;i<m;++i) if(i&k) g[i^k]^=g[i];
	for(int i=0;i<n&&i<m;++i) f[i]^=g[i];
	g.clear();
}
int qed(int x) { //qry a[rp[x]]
	int n=len[x];
	if((int)tag[x].size()>=n) psd(x),init(x);
	return w[lp[x]+tag[x].size()];
}
int qry(int i) {
	psd(bel[i]),init(bel[i]);
	return a[i];
}
void opr(int l,int r) {
	if(bel[l]==bel[r]) {
		psd(bel[l]);
		for(int i=r;i>l;--i) a[i]^=a[i-1];
		return init(bel[l]);
	}
	psd(bel[r]);
	for(int i=r;i>lp[bel[r]];--i) a[i]^=a[i-1];
	a[lp[bel[r]]]^=qed(bel[r]-1);
	init(bel[r]);
	for(int i=bel[r]-1;i>=bel[l]+1;--i) tag[i].push_back(qed(i-1));
	psd(bel[l]);
	for(int i=rp[bel[l]];i>l;--i) a[i]^=a[i-1];
	init(bel[l]);
}
signed main() {
	ios::sync_with_stdio(false);
	int _,n,m;
	cin>>_>>n>>m;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1;rp[i-1]<n;++i)  {
		lp[i]=rp[i-1]+1,rp[i]=min(n,lp[i]+B-1);
		fill(bel+lp[i],bel+rp[i]+1,i),len[i]=rp[i]-lp[i]+1;
		init(i);
	}
	for(int op,l,r,x;m--;) {
		cin>>op;
		if(op==1) cin>>l>>r,opr(l,r);
		else cin>>x,cout<<qry(x)<<"\n";
	}
	for(int i=1;i<=bel[n];++i) psd(i),init(i);
	for(int i=1;i<=n;++i) cout<<a[i]<<"\n";
	return 0;
}
```

---

## 作者：xfrvq (赞：1)

先考虑全局修改操作的情况。假设我们异或差分了 $k$ 次，设 $j\lt i$，**那么 $a_j$ 贡献到 $a_i$ 的次数是 $\binom k{i-j}$。**

> 解释：把每个版本的序列写成一个矩阵，一次操作后版本 $x$ 的 $y$ 位置（在矩阵上记为 $(x,y)$），会贡献给：
> + 版本 $x+1$ 的 $y$ 位置 $(x+1,y)$，相当于 $(x,y)$ 向下一步
> + 版本 $x+1$ 的 $y+1$ 位置 $(x+1,y+1)$，相当于 $(x,)$ 向右下走一步
>  
> 于是最后想问 $(0,j)$ 只走“下”，“右下”的路径到 $(k,i)$ 方案数，等价于在 $k$ 次向下走中选 $j-i$ 次向下右走。

由于异或，贡献次数实际上是 $\binom k{i-j}\bmod2$，**由 $\tt Lucas$ 定理得 $\binom k{i-j}\bmod2=[(i-j)\sube k]$**，（即 $i-j$ 有的二进制位 $k$ 都有，$[(i-j)\operatorname{and}k=i-j]$）

> 解释：
> $$\binom nm\equiv\binom{n\bmod2}{m\bmod2}\binom{\lfloor\frac n2\rfloor}{\lfloor\frac m2\rfloor}\pmod2$$
> 于是 $\binom nm$ 可拆成对每个二进制位 $i$，$\binom{n_i}{m_i}$ 的积。
> 而 $\binom11=\binom00=\binom10=1,\binom01=0$，所以一旦有二进制位 $m$ 有 $n$ 没有，结果就为 $0$

考虑求出 $k$ 次操作后的 $a$：$a^{\prime}_i=\displaystyle\bigoplus_{(i-j)\sube k}a_j$。考虑 dp：设 $f_{i,d}$ 表示考虑 $i-j\lt2^d$ 时的 $a_j$ 异或和。

转移时枚举二进制位 $d$，如果 $2^d\sube k$，那么对于 $f_{i,d}$ 中的 $j$，让 $i-j$ 加上 $2^d$ 依然 $\sube k$。而此时 $j$ 都减去了 $2^d$，得到状态 $f_{i-2^d,d}$。总方程式 $f_{i,d+1}=f_{i,d}\oplus f_{i-2^d,d}$。

---

区间问题复杂，考虑分块。注意由于修改，一个块会被前面一个块影响，而如果修改再多，则会受到更前面块影响。为避免这种情况，考虑根号重构，在一个块有其块长次操作后清空标记重新 dp 算 $a_i$，**保证一个块仅会受到前面邻块影响**。时间复杂度 $O(\sqrt n\log n)$。

整块修改大多可以照搬上述全局情况，但有例外，**一个块的开头元素会询问到上块的末尾元素信息**。这个询问我们在重构一个块时预处理：**一个块的末尾元素在经历 $k$ 次整块修改后的结果 $w_k$**，其中 $0\le k\le$ 块长。而块长次修改后我们会重构又预处理新的。

考虑 $w$ 的计算，对于距离块末尾元素为 $i$ 的点，在 $k$ 次操作后贡献到末尾元素的系数时 $[i\sube k]$，这就是一般的求子集和，SOS dp 即可，预处理块长个的复杂度是 $O(\sqrt n\log n)$。

散块修改，单点询问都可以暴力重构块并重新预处理，因为总共涉及到的块是 $O(m)$ 级别。

注意到涉及块长，块数的部分复杂度都带 $\log$，无法通过调块长做到根号下 $\log$。总复杂度 $O((n+m)\sqrt n\log n)$。

块长调到 $2$ 的整次幂最优（这里是 $2^9=512$），因为可以让两次涉及二进制的 dp 利用效率最大化。

---


# [集训队互测 2015] 普罗达科特

## 题目描述

令 $N = \prod_{i = 1}^{n} p_i^{a_i}$，$M = \prod_{i = 1}^{n} p_i^{b_i}$，其中 $p_i$ 是两两不同的素数。

求将 $N$ 表示成 $k$ 个正整数的乘积的方案数，也就是 $N = \prod_{i = 1}^k x_i$ 的解的个数，答案对 $10^9 + 21$ 取模。

对于子问题 $1$，要求对于所有整数 $i$ 满足 $1 \leq i < k$，都有 $x_i < x_{i + 1}$。

对于子问题 $2$，要求对于所有整数 $i$ 满足 $1 \leq i < k$，都有 $x_i \leq x_{i + 1}$。

对于两个子问题都要求对于所有整数 $i$ 满足 $1 \leq i \leq k$ 都有 $x_i \nmid M$，即 $x_i$ 不是 $M$ 的约数。

## 说明/提示

| 测试点编号 |      $n$      |      $a_i$      |      $b_i$      |      $k$      |
|:--------:|:------------:|:------------:|:------------:|:------------:|
|     1    |  $\leq 5$   |  $\leq 5$   |  $\leq 5$   |  $\leq 3$   |
|     2    |  $\leq 10$  |  $\leq 20$  |  $\leq 20$  |  $\leq 5$   |
|     3    |  $= 1$   |  $\leq 10^{18}$  |  $\leq 10^{18}$  |  $\leq 25$  |
|     4    |  $\leq 50$  |  $\leq 10^3$  |  $= 0$  |  $\leq 20$  |
|     5    |  $\leq 50$  |  $\leq 10^{18}$  |        $= 0$    |  $\leq 25$  |
|     6    |  $\leq 50$  |  $\leq 10^3$  |  $\leq 10^3$  |  $\leq 10$  |
|     7    |  $\leq 50$  | $\leq 10^{18}$  |  $\leq 10^{18}$  |  $\leq 10$  |
|     8    |  $\leq 50$ | $\leq 10^{18}$ | $\leq 10^{18}$ |  $\leq 15$  |
|     9    |  $\leq 50$ | $\leq 10^{18}$ | $\leq 10^{18}$ |  $\leq 20$  |
|    10    |  $\leq 50$ | $\leq 10^{18}$ | $\leq 10^{18}$ |  $\leq 25$  |

## 样例 #1

### 输入

```
5 3
5 5 4 5 5
3 0 3 2 3```

### 输出

```
295164 295326```

## 样例 #2

### 输入

```
10 5
13 11 17 7 9 2 11 11 10 12
7 9 4 15 18 4 9 7 4 2```

### 输出

```
75340090 59089865```

# 题解

## 作者：NaCly_Fish (赞：3)

### 零
尝试用尽可能少的前置知识来推导。  
如果你对这种大力推导的方法比较感兴趣，那我推荐你来看看。

看到这种问题，一般的想法是对于 $n$ 种素数（也是每个维度）独立处理，然后把答案再合并起来。

可是这里没那么简单，比如对于子问题 1，我们可以用 $n+1$ 元生成函数写出答案的最朴素的表达式：

$$\left[y^k \prod_{i=1}^n x_i^{a_i} \right] \left(\prod_{\bold i}\left( 1+y \prod_{j=1}^n x_j^{i_j}\right)\right)\left(\prod_{\bold i \leq \bold b}\left( 1+y\prod_{j=1}^n x_j^{i_j}\right) \right)^{-1}$$
其中 $\bold i = (i_1,\cdots,i_n)$，$\bold b=(b_1,\cdots,b_n)$。式子中用 $y$ 计量使用的正整数数量，$x_1,\cdots,x_n$ 分别计量 $n$ 种素数的幂次。

因为这个对 $y$ 的限制很麻烦，如果能尝试把它干掉，那么对于 $x_1,\cdots,x_n$ 大概就能独立处理了吧？

****
### 一

不过原问题还是太复杂，可以先考虑这样一个特别简化后的情况：不必满足 $M$ 的限制，且 $n=1$ 时的子问题 1。

此时要求的就是「将一个正整数拆分为若干互异自然数之和」的方案数，我们容易写出答案的生成函数为：
$$[y^3]\prod_{i=0}^\infty (1+y x^i)=\frac 16\frac{1}{(1-x)^3}-\frac 12\frac{1}{(1-x)(1-x^2)}+\frac 13\frac{1}{(1-x^3)}$$
等号左边就是我们刚才写过的，但右边有什么用，又是怎么得到的呢？

这个东西厉害的地方在于它可以很容易扩展至多元的情况，即：
$$[y^3] \prod_{i_1,\cdots,i_n}\left(1+y\prod_{j=1}^n x_j^{i_j} \right)=\frac 16\prod_{j=1}^n \frac{1}{(1-x_j)^3}-\frac 12\prod_{j=1}^n \frac{1}{(1-x_j)(1-x_j^2)}+\frac13\prod_{j=1}^n \frac{1}{(1-x_j^3)}$$
这样就可以轻松解决不限制 $n$ 时 $k=3$ 的情况了（但还是不要求满足 $M$ 的限制）。经过这样一通操作，我们确实将这 $n$ 个维度独立开来，可以分别计算了。再提取其 $x_1^{a_1} \cdots x_n^{a_n}$ 系数即为：

$$\frac 16\prod_{j=1}^n\binom{a_j+2}{2}-\frac 12\prod_{j=1}^n (\lfloor a_j/2\rfloor +1)+\frac 13 \prod_{j=1}^n[3\mid a_j]$$
非常的简单方便。

对于刚才的第二个问题，答案也很简单：求导即可。

设
$$F(y;x_1,\cdots,x_n) = \prod_{i_1,\cdots,i_n}\left(1+y \prod_{j=1}^nx_j^{i_j}\right)$$
那么 $[y^k]F(y) = F^{(k)}(0)/k!$（Taylor 展开）。用经典的对数求导法即得
$$F'(y)=F(y)\sum_{i_1,\cdots,i_n} \frac{\prod_{j=1}^n x_j^{i_j}}{1+y \prod_{j=1}^n x_j^{i_j}}$$
再对等式两边同求 $(k-1)$ 阶导（使用 Leibniz 公式），然后代入 $y=0$：
$$F^{(k)}(0)=\sum_{i=0}^{k-1}\binom{k-1}{i} \frac{(-1)^i i!}{\prod_{j=1}^n(1-x_j^{i+1})} F^{(k-i-1)}(0)$$
边界条件自然是 $F(0)=1$，根据此式递推计算即可。

对于子问题 2 当然也很简单，把 $(-1)^i$ 去掉就好了。
****

### 二

如果要对子问题 1 引入不为 $M$ 约数的限制，也是简单的。设
$$\hat F(y) \prod_{\bold i \leq \bold b}\left(1+y \prod_{j=1}^n x_j^{i_j} \right)= \prod_{i_1,\cdots,i_n}\left(1+y \prod_{j=1}^nx_j^{i_j}\right)$$
按上面的方法算一遍，同时我们简记
$$U_i=(-1)^{i+1}\prod_{j=1}^n \frac{1}{1-x_j^i} \ , \ V_i=U_i \prod_{j=1}^n(1-x_j^{i(b_j+1)})$$
那么就有
$$\hat F^{(k)}(0) = \sum_{i=0}^{k-1}\binom{k-1}{i}i! (U_{i+1}-V_{i+1})\hat F^{(k-i-1)}(0)$$
再设 $W_i=U_i-V_i$。

很显然 $\hat F^{(k)}(0)$ 是由 $W_1,\cdots,W_k$ 构成的多项式表示的。进一步观察发现，其中的每一项 $W$ 的下标之和（有重复的也要再记）都等于 $k$。

比如 
$$\hat F^{(4)}(0)=W_1^4+6W_1^2W_2+3W_2^2+8W_1W_3+6W_4$$
那这显然就和分拆数问题对应起来了，$\hat F^{(k)}(0)$ 中仅有 $P_k$ 项（$P_k$ 即为将 $k$ 拆分为若干无序正整数之和的方案数）。在下一部分中，我们将给出每一项的系数。

有同学看到这里可能按捺不住了：「Burnside 引理不就直接秒了吗？」但是 Burnside 引理还是太高级了，我们要用更朴素的方法。
****

### 三

我们把 $\hat F^{(k)}(0)$ 的递归式再整理一下：
$$\frac{ \hat F^{(k)}(0)}{k!}=\frac 1k\sum_{i=0}^{k-1}W_{i+1} \frac{F^{(k-i-1)}(0)}{(k-i-1)!}$$
设 $G_k=\hat F^{(k)}(0)/k!$，并考虑 $G_k$ 中的某一项 $W_1,\cdots,W_k$ 分别出现了 $c_1,\cdots,c_k$ 次。

只关注其中一项，比如 $k=4$ 时 $c=(2,1,0,0)$ 的这一项系数是 $1/4$，它是这么来的：
$$\frac{1}{4}W_1\frac{1}{3}W_1\frac 12W_2+\frac14W_1\frac 13W_2\frac{1}{1}W_1+\frac 14W_2\frac 12W_1\frac11W_1=\frac 14W_1^2W_2$$
这里就是枚举了三种 $W_i$ 在递归中乘的顺序，然后对应乘上和式前面 $1/k$ 的系数。

扩展到一般的情况，这一项的系数就是对于全部 $\binom{c_1+\cdots +c_k}{c_1,\cdots,c_k}$ 种排列，求其「前缀和序列之积的倒数」之和。  
再仔细想想，可以将其对应到「确定 $k$ 阶排列中置换环结构后的方案计数」上去（暂时没有很好的代数推导方法，待补充）。

所以这个式子实际算的就是：
$$\prod_{i=1}^k \frac{1}{c_i ! i^{c_i}}$$
现在有了每一项的系数，就可以直接展开 $W_i$ 计算了。
****

### 四

将所有 $(U_i - V_i)$ 的乘积全部展开来，每一项只观察 $n$ 维中的一部分，它是这样的形式（略去了其整体前面的系数）：

$$\prod_{i=1}^k \frac{(1-z^{i(b+1)})^{d_i}}{(1-z^i)^{c_i}}$$
其中 $d_i \leq c_i$，$b$ 就是这一维中对应的 $M$ 的限制。

将分子展开，最终就只需要多次给出 $N$ 并查询：
$$[z^N] \prod_{i=1}^k \frac{1}{(1-z^i)^{c_i}}$$
设 $L= \text{lcm}\{ i^{[c_i > 0]}\}$，那么上式可以表示为 $P_{N\bmod L}(\lfloor N/L \rfloor)$，其中 $P_i(x)$ 是一组 $k$ 次多项式。

那么只需要计算出 $\prod_i (1-z^i)^{-c_i}$ 的前 $L(k+1)$ 项系数，就可以使用线性插值求单点的方法，快速**预处理出所有将要用到的点值**。

****

### 五

参考代码如下，加了一些注释，可以补充文中没描述清楚的地方：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 203
#define p 1000000021
#define ll long long
using namespace std;

inline int power(int a,int t){
	int res = 1;
	while(t){
		if(t&1) res = (ll)res*a%p;
		a = (ll)a*a%p;
		t >>= 1;
	}
	return res;
}

int fac[N],ifac[N],inv[N];

void init(int n){
	fac[0] = ifac[0] = inv[1] = 1;
	for(int i=1;i<=n;++i) fac[i] = (ll)fac[i-1]*i%p;
	ifac[n] = power(fac[n],p-2);
	for(int i=n-1;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
	for(int i=2;i<=n;++i) inv[i] = (ll)fac[i-1]*ifac[i]%p;
}

inline int binom(int n,int m){
	return (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;
}

int gcd(int a,int b){ return b==0?a:gcd(b,a%b); }
int lcm(int a,int b){ return a*b/gcd(a,b); }

int interpolate(const int *f,int n,int x){ // give n-degree poly f values f(0) , ... , f(n), return f(x).
	static int pre[N],suf[N];
	n += 1,x += 1;
	pre[0] = suf[n+1] = 1;
	for(int i=1;i<=n;++i) pre[i] = (ll)pre[i-1]*(x-i)%p;
	for(int i=n;i;--i) suf[i] = (ll)suf[i+1]*(x-i)%p;
	int ans = 0,tmp;
	for(int i=1;i<=n;++i){
		tmp = (ll)f[i-1]*ifac[i-1]%p*ifac[n-i]%p;
		if((n-i)&1) tmp = -tmp;
		ans = (ans + (ll)tmp*pre[i-1]%p*suf[i+1])%p;
	}
	return (ans+p)%p;
}

ll a[N],b[N];
int c[N],tc[N],val[53][N];
int n,k,ans1,ans2;
int delt;

void dfs(int dep,int cf){ // expand \prod_{i=1}^k (U_i - V_i)^{c_i}
	if(dep > k){
		int flag = 0;
		for(int i=1;i<=k;++i){
			cf = (ll)cf*binom(c[i],tc[i])%p;
			flag += tc[i];
		}
		if(flag&1) cf = -cf;
		int f[101]; // the numerator. f(z) = \prod_{i=1}^k (1-z^i)^{tc_i}
		memset(f,0,sizeof(f));
		f[0] = 1;
		int deg = 0;
		for(int i=1;i<=k;++i)
		for(int t=1;t<=tc[i];++t){
			for(int j=deg+i;j>=i;--j)
				f[j] = (f[j] - f[j-i])%p;
			deg += i;
		}
		int tmp = 1;
		for(int i=1;i<=n;++i){
			int sum = 0;
			for(int j=0;j<=deg;++j)
				sum = (sum + (ll)f[j]*val[i][j])%p;
			tmp = (ll)tmp*sum%p;
		}
		flag = 0;
		for(int i=1;i<=k;++i) flag += (i+1)*c[i];
		ans2 = (ans2 + (ll)tmp*cf)%p;
		if(flag&1) tmp = p-tmp;
		ans1 = (ans1 + (ll)tmp*cf)%p;
		return;
	}
	for(int i=0;i<=c[dep];++i){
		tc[dep] = i;
		dfs(dep+1,cf);
	}
}

void solve(){
	int d = 1,cf = 1,m = 0;
	for(int i=1;i<=k;++i){
		if(c[i] > 0) d = lcm(d,i);
		m += c[i];
		cf = (ll)cf*ifac[c[i]]%p*power(inv[i],c[i])%p;
	}
	static int f[10003],g[2000][N];
	memset(f,0,sizeof(f));
	memset(val,0,sizeof(val));
	int L = d*(m+1);
	f[0] = 1;
	for(int i=1;i<=k;++i)
	for(int t=1;t<=c[i];++t)
	for(int j=i;j<=L;++j)
		f[j] = (f[j] + f[j-i])%p;

	for(int i=0;i<d;++i)
	for(int j=0;j<=m;++j)
		g[i][j] = f[j*d+i];

	for(int i=1;i<=n;++i)
	for(int j=0;j<=k;++j){
		if(a[i] < j*(b[i]+1)) break;
		ll x = a[i] - j*(b[i]+1);
		val[i][j] = interpolate(g[x%d],m,(x/d)%p);
        // val[i][j] = [z^{a_i - j(b_i+1)}] \prod_{t=1}^k 1/(1-z^t)^{c_t}
    }
	dfs(1,cf);
}

void partition(int sum,int dep){ // find all partition of k
	if(sum == k){
		solve();
		return;
	}
	if(dep > k-sum) return;
	for(int i=0;sum+i*dep<=k;++i){
		c[dep] = i;
		partition(sum+i*dep,dep+1);
	}
	c[dep] = 0;
}


int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]);
	for(int i=1;i<=n;++i) scanf("%lld",&b[i]);
	init(103);
	partition(0,1);
	printf("%d %d",(ans1+p)%p,(ans2+p)%p);
	return 0;	
}
```

---

## 作者：yukimianyan (赞：2)

# 题解：QOJ4264 [集训队互测 2015] 普罗达科特

## 题目描述

令 $N = \prod_{i = 1}^{n} p_i^{A_i}$，$M = \prod_{i = 1}^{n} p_i^{B_i}$，其中 $p_i$ 是两两不同的素数。

求将 $N$ 表示成 $m$ 个正整数（原题写的是 $k$ 个）的乘积的方案数，也就是 $N = \prod_{i = 1}^k x_i$ 的解的个数，答案对 $10^9 + 21$ 取模。

对于子问题 $1$，要求对于所有整数 $i$ 满足 $1 \leq i < m$，都有 $x_i < x_{i + 1}$。

对于子问题 $2$，要求对于所有整数 $i$ 满足 $1 \leq i < m$，都有 $x_i \leq x_{i + 1}$。

对于两个子问题都要求对于所有整数 $i$ 满足 $1 \leq i \leq m$ 都有 $x_i \nmid M$，即 $x_i$ 不是 $M$ 的约数。

$n\leq 50, A_i, B_i\leq 10^{18}, m\leq 25$。

## 题解

分为两步：以枚举 $m$ 的所有拆分 $\lambda\vdash m$ 也就是 $m=\lambda_1+\lambda_2+\cdots+\lambda_{|\lambda|}$ 为桥梁，分别计算这个拆分的贡献系数和方案数。拆分表达的意思是我们将所有 $x_i$ 划分成一些等价类，等价类中的 $x_i$ 是相等的。等价类大小排序之后就和这个拆分一样。不同等价类的数也可能相等。元素是没有标号的，只有等价类的划分带来的相等关系。然后计算这样的限制下有多少方案。计算完了以后再考虑乘上一定的系数作为两个问题的答案。

### 贡献系数 - 子问题 1

对于子问题 1，首先改成求使所有 $x_i$ **互不相同**的方案数，最后除去 $m!$。有一个容斥就是考虑 $m$ 个数之间的相等关系，如果两个 $x_i=x_j$ 我们就在 $(i,j)$ 之间连一条边，我们枚举所有完全图 $\mathbb K_m$ 的子图，根据连通性区分等价类（一个等价类里的数连通），容斥系数就是 $(-1)^{|E|}$（$|E|$ 是边数）。由于最后要枚举的是拆分，考虑算一下一个拆分具体对应的系数。假设这个拆分中值为 $i$ 的有 $a_i$ 个。那么自然会先有一个多重集排列数，使元素带上标号：

$$
\frac{m!}{\prod_{i=1}^m(i!)^{a_i}a_i!}
$$

多重集排列数的同时要注意 $a_i$ 个大小相同的连通块是互不区分的。除此之外还要乘上

$$
\prod_{i=1}^mf_i^{a_i}
$$
这里 $f_i$ 表示大小为 $i$ 的连通图的 $(-1)^{|E|}$ 之和是多少。这个是一个简单的东西：

> 为了计算 $f_n$，容斥，首先计算大小为 $n$ 的所有图的 $(-1)^{|E|}$ 之和，这是 $[n=1]$，然后枚举 $1$ 号点所在连通块的大小，也就是：$f_n=[n=1]-\sum_{i=1}^n\binom{n-1}{i-1}f_i[n-i=1]$。
>
> 后面这个系数就很搞笑，可以删掉改成：$f_n=[n=1]-(n-1)f_{n-1}$，又有 $f_1=1$，所以 $f_n=(-1)^{n-1}(n-1)!$。

所以系数就是

$$
\frac{1}{m!}\frac{m!\prod_{i=1}^m((-1)^{i-1}(i-1)!)^{a_i}}{\prod_{i=1}^m(i!)^{a_i}a_i!}
=\frac{1}{\prod_{i=1}^m((-1)^{i-1}i)^{a_i}a_i!}
$$
这样就够了。

### 贡献系数 - 子任务 2

这里我们使用 Burnside 引理。对于一个方案，我们只取单调不降的，其它和它**重排相同**的方案我们不要。看到这个重排相同我们考虑使用 Burnside 引理：

$$
|X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g|
$$

在这里，我们枚举这个**置换 $g\in G$ 的置换环拆分**得到的大小序列，也就是一个 $m$ 的拆分 $\lambda\vdash m$，它对应 $\frac{m!\prod_{i=1}^m(a_i-1)!}{\prod_{i=1}^m(i!)^{a_i}a_i!}$ 个置换（和上面一样的多重集排列数，再考虑每个置换环内部的填法，也就是圆排列数），在这个 $\lambda\vdash m$ 的拆分下，我们计算每个置换环里的元素都相同的方案数，乘上 $\lambda$ **对应的置换个数**，这个数就是这个拆分的贡献系数。

$$
\frac{1}{m!}\frac{m!\prod_{i=1}^m((i-1)!)^{a_i}}{\prod_{i=1}^m(i!)^{a_i}a_i!}
=\frac{1}{\prod_{i=1}^mi^{a_i}a_i!}
$$

注意，$\frac{1}{m!}$ 是 Burnside 引理带来的。

### 方案数

> 以枚举 $m$ 的所有拆分 $\lambda\vdash m$ 也就是 $m=\lambda_1+\lambda_2+\cdots+\lambda_{|\lambda|}$ 为桥梁，分别计算这个拆分的贡献系数和**方案数**。拆分表达的意思是我们将所有 $x_i$ 划分成一些等价类，等价类中的 $x_i$ 是相等的。等价类大小排序之后就和这个拆分一样。不同等价类的数也可能相等。元素是没有标号的，只有等价类的划分带来的相等关系。然后计算这样的限制下有多少方案。

考虑对一个拆分 $\lambda\vdash m$ 计算方案数。假设这个拆分中值为 $i$ 的有 $a_i$ 个。首先解决 $M$ 的限制，枚举一个数组 $c_i$（暴力枚举）表示大小为 $i$ 的等价类里面有多少个是 $M$ 的约数，其容斥系数为：

$$
\prod_{i=1}^m\binom{a_i}{c_i}(-1)^{c_i}
$$

这时所有的质因子就独立了。假设这个质因子是 $j$，用生成函数进行计数：

$$
[x^{A_j}]\prod_{i=1}^m\left(\frac{1-x^{i(B_j+1)}}{1-x^i}\right)^{c_i}\left(\frac{1}{1-x^i}\right)^{a_i-c_i}
$$

改写成

$$
[x^{A_j}]\left(\prod_{i=1}^m\left(1-x^{i(B_j+1)}\right)^{c_i}\right)\left(\prod_{i=1}^m\left(\frac{1}{1-x^i}\right)^{a_i}\right)
$$

前面是关于 $x^{B_j+1}$ 的多项式，把它算出来之后，我们枚举它的所有 $t$ 次项系数，计算

$$
[x^{A_j-t(B_j+1)}]\prod_{i=1}^m\left(\frac{1}{1-x^i}\right)^{a_i}
$$

就是要计算

$$
\prod_{i=1}^{|\lambda|}\frac{1}{1-x^{\lambda_i}}
$$

的某项系数，结论是，记 $L=\operatorname{LCM}(\lambda_1, \lambda_2, \cdots, \lambda_{|\lambda|})$，则它的第 $kL+r$ 项系数是关于 $k$ 的 $|\lambda|-1$ 次多项式。

> 这个可以感性理解一下，假如 $\lambda_i=1$，这时就是求长度为 $|\lambda|$ 的和为 $kL+r$ 的非负整数数组的个数，这是一个插板法组合数 $\binom{kL+r+|\lambda|-1}{|\lambda|-1}$，如果将 $k$ 视作变量，就是关于 $k$ 的 $|\lambda|-1$ 次多项式（因为是这么多次的下降幂多项式）。如果 $\lambda$ 有别的取值，经过一些无聊的转化后也能写成若干个组合数的线性组合，依然是 $|\lambda|-1$ 次多项式。

使用拉格朗日插值计算即可。枚举 $r$，计算 $r,k+r,2k+r,\cdots,(|\lambda|-1)k$ 这些位置的**系数**，然后拿出来当作点值，需要计算下一项系数的时候做拉格朗日插值即可。

计算系数可以算出分母后求逆。

拉格朗日插值部分需要记忆化（？）。

## 代码

uoj 上过不去。懒得改。

```cpp
#include <bits/stdc++.h>
using namespace std;
#ifdef LOCAL
#define debug(...) fprintf(stderr, ##__VA_ARGS__)
#else
#define endl "\n"
#define debug(...) void(0)
#endif
using LL = long long;
#define gcd __gcd
template <unsigned umod>
struct modint {/*{{{*/
  static constexpr int mod = umod;
  unsigned v;
  modint() = default;
  template <class T, enable_if_t<is_integral<T>::value, int> = 0>
    modint(const T& y) : v((unsigned)(y % mod + (is_signed<T>() && y < 0 ? mod : 0))) {}
  modint& operator+=(const modint& rhs) { v += rhs.v; if (v >= umod) v -= umod; return *this; }
  modint& operator-=(const modint& rhs) { v -= rhs.v; if (v >= umod) v += umod; return *this; }
  modint& operator*=(const modint& rhs) { v = (unsigned)(1ull * v * rhs.v % umod); return *this; }
  modint& operator/=(const modint& rhs) { assert(rhs.v); return *this *= qpow(rhs, mod - 2); }
  friend modint operator+(modint lhs, const modint& rhs) { return lhs += rhs; }
  friend modint operator-(modint lhs, const modint& rhs) { return lhs -= rhs; }
  friend modint operator*(modint lhs, const modint& rhs) { return lhs *= rhs; }
  friend modint operator/(modint lhs, const modint& rhs) { return lhs /= rhs; }
  template <class T> friend modint qpow(modint a, T b) {
    modint r = 1;
    for (assert(b >= 0); b; b >>= 1, a *= a) if (b & 1) r *= a;
    return r;
  }
  friend int raw(const modint& self) { return self.v; }
  friend ostream& operator<<(ostream& os, const modint& self) { return os << raw(self); }
  explicit operator bool() const { return v != 0; }
  modint operator-() const { return modint(0) - *this; }
  bool operator==(const modint& rhs) const { return v == rhs.v; }
  bool operator!=(const modint& rhs) const { return v != rhs.v; }
};/*}}}*/
using mint = modint<1000000021>;
template <int N>
struct C_prime {/*{{{*/
  mint fac[N + 10], ifac[N + 10];
  C_prime() {
    fac[0] = 1;
    for (int i = 1; i <= N; i++) fac[i] = fac[i - 1] * i;
    ifac[N] = 1 / fac[N];
    for (int i = N; i >= 1; i--) ifac[i - 1] = ifac[i] * i;
  }
  mint operator()(int n, int m) const { return n >= m ? fac[n] * ifac[m] * ifac[n - m] : 0; }
};/*}}}*/
C_prime<10000010> binom;
int n, m;
LL A[60], B[60];
int p[30], a[30], c[30];
mint calc(int typ) {
  mint res = 1;
  for (int i = 1; i <= m; i++) if (a[i]) {
    auto coe = typ == +1 || i % 2 ? +1 : -1;
    res *= qpow(mint(coe * i), a[i]) * binom.fac[a[i]];
  }
  return 1 / res;
}
vector<mint> inverse(const vector<mint> &F, int deg) {
  vector<mint> G(deg);
  mint inv_F0 = G[0] = 1 / F[0];
  for (int i = 1; i < deg; i++) {
    for (int j = 1; j <= min(i, (int)F.size() - 1); j++) G[i] -= G[i - j] * F[j];
    G[i] *= inv_F0;
  }
  return G;
}
struct machine {
  vector<mint> vec;
  mint query(mint x) {
    int m = (int)vec.size();
    if (raw(x) < m) return vec[raw(x)];
    mint res = 0, pre = 1;
    for (int i = 0; i < m; i++) {
      mint val = pre * binom.ifac[i] * binom.ifac[m - 1 - i] * (i & 1 ? -1 : +1);
      pre *= i - x;
      res = res * (i - x) + val * vec[i];
    }
    return res;
  }
} mac[2010];
int L;
int vis[60][60], tim;
void init_macs(int cnt) {
  ++tim;
  L = 1;
  for (int i = 1; i <= cnt; i++) L = L / gcd(L, p[i]) * p[i];
  vector<mint> F(m + 1);
  F[0] = 1;
  for (int i = 1; i <= cnt; i++) {
    for (int j = m; j >= p[i]; j--) F[j] -= F[j - p[i]];
  }
  auto inv = inverse(F, L * m);
  for (int r = 0; r < L; r++) {
    mac[r].vec.resize(m);
    for (int i = 0; i < m; i++) mac[r].vec[i] = inv[i * L + r];
  }
}
mint query(LL pos) {
  return pos < 0 ? 0 : mac[pos % L].query(pos / L);
}
mint mem[60][60];
mint query2(int j, int t) {
  if (vis[j][t] < tim) vis[j][t] = tim, mem[j][t] = query(A[j] - t * (B[j] + 1));
  return mem[j][t];
}
mint solve2() {
  mint res = 1;
  for (int i = 1; i <= m; i++) res *= binom(a[i], c[i]) * (c[i] & 1 ? -1 : +1);
  vector<mint> F(m + 1);
  F[0] = 1;
  for (int i = 1; i <= m; i++) {
    for (int t = 1; t <= c[i]; t++) {
      for (int j = m; j >= i; j--) F[j] -= F[j - i];
    }
  }
  for (int j = 1; j <= n; j++) {
    mint ret = 0;
    for (int t = 0; t <= min((LL)m, A[j] / (B[j] + 1)); t++) 
      //ret += F[t] * query(A[j] - t * (B[j] + 1));
      ret += F[t] * query2(j, t);
    res *= ret;
  }
  return res;
}
mint dfs2(int now) {
  if (now > m) return solve2();
  mint res = 0;
  for (int &i = c[now] = 0; i <= a[now]; i++) res += dfs2(now + 1);
  return res;
}
mint solve(int cnt) {
  init_macs(cnt);
  return dfs2(1);
}
mint ans1 = 0, ans2 = 0;
void dfs(int rest, int lst, int cnt) {
  if (!rest) {
    memset(a, 0, sizeof a);
    for (int i = 1; i <= cnt; i++) a[p[i]] += 1;
    auto res = solve(cnt);
    ans1 += calc(-1) * res;
    ans2 += calc(+1) * res;
    return ;
  }
  ++cnt;
  for (int &i = p[cnt] = lst; i <= rest; i++) {
    dfs(rest - i, i, cnt);
  }
}
int main() {
#ifndef LOCAL
  cin.tie(nullptr)->sync_with_stdio(false);
#endif
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> A[i];
  for (int i = 1; i <= n; i++) cin >> B[i];
  dfs(m, 1, 0);
  cout << ans1 << " " << ans2 << endl;
  return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：1)

## Solution

递增或不降序列计数，我们通常会考虑变为对每种元素构成的集合计数并枚举等价类，此时问题限制转化为互不相同的限制。考虑使用集合划分容斥处理掉这一限制。集合划分容斥的形式化表述为：

> 在某种等价关系下，对于某一组合结构，构成其的元素其可以被划分成若干等价类，有一关于等价类的系数 $F(x)$（即这一等价类的贡献系数）。而我们的 dp 不能恰好地刻画出每一极大等价类（有可能有相互等价的等价类），记等价类之间的合并关系为 $G(x)$，我们设计容斥系数 $H(x)$ 满足：
>
> $$G(H(x))=F(x)$$

第一问中，$G(x)=\exp x$，$F(x)=1+x$，解得 $H(x)=\ln(1+x)$，于是一个大小为 $s$ 的等价类的容斥系数即为 $\Big[\dfrac{x^s}{s!}\Big]H(x)=(-1)^{s-1}(s-1)!$；第二问中，$G(x)=\exp x$，$F(x)=\dfrac{1}{1-x}$，解得 $H(x)=-\ln(1-x)$，于是一个大小为 $s$ 的等价类的容斥系数即为 $\Big[\dfrac{x^s}{s!}\Big]H(x)=(s-1)!$。这与其他题解推导的结果是一致的。

容斥系数的问题解决了，接下来考虑算答案。考虑容斥掉 $x_i\nmid M$ 的限制，设我们枚举的等价类分别为 $s_1,s_2,\cdots,s_m$，其中大小为 $i$ 的等价类有 $p_i$ 个。首先有每个方案有系数：

$$\dfrac{1}{k!}\times\frac{k!}{\prod_{i=1}^k (i!)^{p_i}p_i!}$$

这是因为我们实际上是在做一个 $\exp$ 运算，由于枚举的贡献方案是无序的所以要乘上将其变成有序的系数。

对于 $x_i\nmid M$ 的限制，设大小为 $i$ 的等价类中有 $q_i$ 个整除 $M$，显然容斥系数为

$$\prod\limits_{i=1}^k\binom{p_i}{q_i}(-1)^{q_i}$$

显然此时每个质因子相互独立，方案数即为

$$\begin{aligned}
&~\prod_{i=1}^n[x^{a_i}]\prod_{j=1}^k\Big(\frac{1-x^{(b_i+1)j}}{1-x^j}\Big)^{q_j}\Big(\frac{1}{1-x^j}\Big)^{p_j-q_j}\\
  =&~\prod_{i=1}^n[x^{a_i}]\prod_{j=1}^k\frac{(1-x^{(b_i+1)j})^{q_j}}{(1-x^j)^{p_j}}\\
\end{aligned}$$

注意到分子仅与 $q$ 与 $b_i+1$ 相关，分母仅与 $p$ 有关，考虑将它们分开来算。分子是关于 $x^{b_i+1}$ 的多项式，我们将分子算出来后枚举每一项，即可将问题转化为求

$$[x^K]P(x)=[x^K]\prod_{j=1}^k\frac{1}{(1-x^j)^{p_j}}$$

记 $L={\rm lcm}\{s_j\}$，我们将分母通分为 $(1-x^L)^m$（显然对于 $d|L$ 有 $(1-x^d)|(1-x^L)$），并记此时分子为 $Q(x)$，那么这部分的答案即为

$$\begin{aligned}
&~[x^K]P(x)\\
=&~\sum_{j\ge 0,L|(K-j)}[x^j]Q(x)\times [x^{\frac{K-j}{L}}]\frac{1}{(1-x)^m}\\
=&~\sum_{j\ge 0,L|(K-j)}[x^j]Q(x)\times{\frac{K-j}{L}+m-1\choose m-1}
\end{aligned}$$

设 $K=rL+t$（其中 $t\in[0,L)\cap\Z$），则显然对于每一个 $t$，$[x^K]P(x)$ 是一个关于 $r$ 的 $m-1$ 次多项式，所以可以插值。也可以直接把 $Q(x)$ 算出来再预处理 $\frac KL$ 周围的 $O(m)$ 个值算组合数，但大概没有插值好写。

于是这道题就做完了。复杂度不想算。

## Code

```cpp
bool Mst;
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=55,NL=2005,ML=10005,mod=1e9+21;
inline ll add(ll x,ll y){return (x+=y)>=mod&&(x-=mod),x;}
inline ll Add(ll &x,ll y){return x=add(x,y);}
inline ll sub(ll x,ll y){return (x-=y)<0&&(x+=mod),x;}
inline ll Sub(ll &x,ll y){return x=sub(x,y);}
inline ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
int n,K;ll a[N],b[N],fac[N],ifac[N],inv[N],ans1,ans2,_ans;
inline ll binom(int n,int m){
	if(m<0||m>n)return 0;
	return fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
struct lag{
	bool typ;int len;ll val[N],cf[N];
	inline void clear(){
		typ=0;
		for(int i=0;i<len;i++)val[i]=cf[i]=0;
		len=0;
	}
	inline void ins(ll v){
		val[len++]=v;
	}
	inline void init(){
		for(int i=0;i<len;i++){
			cf[i]=val[i]*ifac[i]%mod*ifac[len-i-1]%mod;
			if((len-i-1)&1)cf[i]=sub(0,cf[i]);
		}
		typ=1;
	}
	inline ll qry(ll x){
		x%=mod;
		if(x<len)return val[x];
		if(!typ)init();
		ll res=0,cur=1;
		for(int i=0;i<len;i++){
			res=(res*(x-i)+cf[i]*cur)%mod;
			cur=cur*(x-i)%mod;
		}
		return res;
	}
};
lag func[NL];ll val[N][N];
int p[N],q[N];ll F[N],G[ML];
void dfs2(int x){
	if(!x){
		ll _coef=1;
		for(int i=1;i<=K;i++){
			_coef=_coef*binom(p[i],q[i])%mod;
			if(q[i]&1)_coef=sub(0,_coef);
		}
		F[0]=1;
		for(int i=1;i<=K;i++)F[i]=0;
		for(int i=1;i<=K;i++)
			for(int j=1;j<=q[i];j++)
				for(int k=K;k>=i;k--)
					Sub(F[k],F[k-i]);
		ll res=_coef;
		for(int i=1;i<=n;i++){
			ll tmp=0;
			for(int j=0;j<=K;j++)
				if(F[j]&&val[i][j])
					Add(tmp,F[j]*val[i][j]%mod);
			res=res*tmp%mod;
		}
		Add(_ans,res);
		return;
	}
	for(int i=0;i<=p[x];i++)
		q[x]=i,dfs2(x-1);
}
void dfs1(int x,int c){
	if(!x){
		int L=1;
		for(int i=1;i<=K;i++)
			if(p[i])
				L=L/__gcd(i,L)*i;
		ll coef=1;int m=0;
		for(int i=1;i<=K;i++){
			coef=coef*qpow(inv[i],p[i])%mod*ifac[p[i]]%mod;
			m+=p[i];
		}
		int tot=m*L-1;G[0]=1;
		for(int i=1;i<=tot;i++)G[i]=0;
		for(int i=1;i<=K;i++)
			for(int j=1;j<=p[i];j++)
				for(int k=i;k<=tot;k++)
					Add(G[k],G[k-i]);
		for(int i=0;i<L;i++){
			func[i].clear();
			for(int j=0;j<m;j++)
				func[i].ins(G[i+j*L]);
		}
		for(int i=1;i<=n;i++){
			ll v=a[i];
			for(int j=0;j<=K;j++)
				val[i][j]=0;
			for(int j=0;j<=K&&v>=0;j++,v-=b[i]+1)
				val[i][j]=func[v%L].qry(v/L);
		}
		_ans=0,dfs2(K),_ans=_ans*coef%mod;
		if((K-m)&1)Sub(ans1,_ans);
		else Add(ans1,_ans);
		Add(ans2,_ans);
		return;
	}
	if(x==1){
		p[x]=c,dfs1(x-1,0);
		return;
	}
	for(int i=0;i*x<=c;i++)
		p[x]=i,dfs1(x-1,c-i*x);
}
bool Med;
int main(){
	cerr<<abs(&Mst-&Med)/1048576.0<<endl;
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>K;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	fac[0]=1;
	for(int i=1;i<=K;i++)fac[i]=fac[i-1]*i%mod;
	ifac[K]=qpow(fac[K],mod-2);
	for(int i=K;i>=1;i--)ifac[i-1]=ifac[i]*i%mod;
	for(int i=1;i<=K;i++)inv[i]=ifac[i]*fac[i-1]%mod;
	dfs1(K,K);
	cout<<ans1<<' '<<ans2<<'\n';
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：0)

首先考虑第一问的做法。

有序的限制我们不用管他，考虑求出一个无序的集合然后给他排序，问题在于处理互不相同的限制。类似于 [[ABC288Ex] A Nameless Counting Problem](https://www.luogu.com.cn/problem/AT_abc288_h)，钦定若干集合内部都是相等的，并施加集合划分容斥，由经典结论，系数为 $R(|S|)=(-1)^{|S|-1}(|S|-1)!$（就是你考虑一个合法情况必须被计入 $1$，非法方案是 $0$，做成图，设一下系数之后随便递推一下）。注意到这些元素都是等价的，所以我们只关心所有划分出来的 $|S|$ 构成的可重集，这个状态数是 $k$ 的拆分数级别，在 $k=25$ 时很小，考虑直接爆搜，此时只有 $C(k)=1958$ 种状态。最终一个拆分 $c$ 对答案的系数是 $\prod R(c_i)\frac{k!}{\prod c_i!(i!)^{c_i}}$，其中 $c_i$ 表示有多少个大小为 $i$ 的等价类。

另一方面，对于不是 $m$ 的约数这个限制，要求至少一个指数 $>b_i$，因此对 $m$ 的因数做容斥。这样每种质因子完全独立。在最外层枚举了拆分中 $a_i$ 个大小为 $i$ 的等价类，进一步枚举内层针对 $m$ 的容斥中有 $0\leq b_i\leq a_i$ 个被钦定入集合 $S$，这时系数是 $\prod\binom{a_i}{b_i}(-1)^{b_i}$，由于 $C(k)$ 很小我们宣称可以直接搜索 $b_i$，对于 $C(k)$ 种情况，$k=25$ 时总和是 $T(k)=129512$。对于 $b_i$ 个额外钦定 $>B$ 的，我们可以等效认为 $A'=A-\sum b_ii(B+1)$。核心问题是处理：给定 $A$，求 $\sum_{i=1}^l coef_ix_i=A$ 的非负整数解组数。$\sum coef_i=k$。

结论是，令 $t=\text{lcm}(coef_i)$，那么 $f(xt+y),y\in[0,t-1]$，固定 $y$ 后是关于 $x$ 的 $k$ 次多项式。写个爆搜发现可能的 $t$ 很少，对于每种 $t$ 预处理 $kt$ 个点值，复杂度可以接受，令 $D(k)$ 表示对于 $k$ 的拆分方案数的所有 $\text{lcm}$ 的和，$k=25$ 时 $D(k)=123292$。这样第一问就做完了。

还有一个问题是第二问：对可重集计数。结论是把 $R(|S|)$ 改成 $(|S|-1)!$ 就是对的。这个大概是考虑圆排列以及对于一个方案被统计的次数应该是 $1$，强制钦定一个顺序之后就好了。

时间复杂度 $\mathcal O((nk+k^2)T(k)+nk^2C(k)+k^2D(k))$。

---


# [集训队互测 2024] 基础 ABC 练习题

## 题目描述

给定两个集合 $S_1,S_2$，定义一个长度为 $3n$ 且仅包含 `ABC` 三种字符的串 $s$ 是好的，当且仅当存在一种方案将 $s$ 划分成 $n$ 个长度为 $3$ 的子序列，且这 $n$ 个子序列都是 `ABC`，`BCA` 或 `CAB`。设 $n$ 个子序列中 `ABC` 的个数为 $x$，`BCA` 的个数为 $y$，还要求 $x\in S_1,y\in S_2$。

现在有一个长度为 $3n$ 的字符串 $s$，字符串中仅包含 `ABC?` 四种字符，你需要计算将所有 `?` 都分别替换成 `ABC` 三个字符中的某一个的方案，使得串 $s$ 是好的。

对 $2^{32}$ 取模。

## 说明/提示

### 样例解释 1

这个样例不满足 $T=60$ 的限制，仅为理解题意用。

### 样例 2,3

见下发文件，分别满足子任务 1,2 的性质。

### 提示与说明

| Subtask | 分值 | 特殊限制                                                     |
| ------- | ---- | ------------------------------------------------------------ |
| 1       | $20$ | $s$ 中没有 `?`，且 $ \left\vert S_1\right\vert=\left\vert S_2\right\vert=n+1 $ |
| 2       | $20$ | $s$ 中没有 `?`                                               |
| 3       | $10$ | $s$ 中只有 `?`，且 $ \left\vert S_1\right\vert=\left\vert S_2\right\vert=n+1 $ |
| 4       | $20$ | $ \left\vert S_1\right\vert=\left\vert S_2\right\vert=n+1 $  |
| 5       | $30$ | 无特殊限制                                                   |

对于所有数据，保证 $T=60$。对于每个测试点内的第 $i$ 组测试数据，保证 $n=i$。

~~测试时开启所有合理的子任务依赖。~~ 子任务依赖尚未配置。

对于每个测试点内的每组测试数据，如果你不打算回答这组测试数据，请输出 $-1$。否则输出一个整数表示答案。如果格式不正确不保证能得到对应的分数。

对于每个测试点，会根据你的输出给出你在这组数据上的评分系数 $p\in [0,1]$。每个 Subtask 的得分是这个 Subtask 中所有测试点得分系数的最小值乘以这个 Subtask 的分值。

首先，你的程序需要正常结束并且所有你选择回答的答案均正确，否则  $p=0$。

在此基础上，记 $d$ 为在所有数据中你的程序选择回答的最大的 $n$，则有
$$
p=
\begin{cases}
\frac{1}{20} d && d\leq 5 \\
\frac{1}{4}+\frac{1}{50}(d-5) && d\leq 15 \\
\frac{9}{20}+\frac{3}{200}(d-15) && d\leq 35 \\
\frac{3}{4}+\frac{1}{100}(d-35) && d\leq 60
\end{cases}
$$
$p$ 与 $d$ 的大致图像如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/qtq4b9l1.png)

## 样例 #1

### 输入

```
3 0
1
11
11
ABC
2
101
101
A????C
3
1111
1111
?????????```

### 输出

```
1
5
1077```

# 题解

## 作者：qzmoot (赞：3)

# 题解：P12472 [集训队互测 2024] 基础 ABC 练习题
## 题外话
这是我们学长放在我们 noip 模拟赛里的题目，然后没有一个人会做。
## 题目分析
**本题解借鉴了 Xun_Xiaoyao 学长的思路。**

看完题目之后，我们的第一反应是如何判断一个序列是否合法都十分困难。\
此时，只能从题目出发来寻找性质来做。很显然，贪心的判断是假的，从数据范围来看，大概率是一个多维 dp。\
观察题目告诉我们的合法子序列，```ABC```、 ```BCA``` 和 ```CAB``` 似乎是轮换的，那么我们便可以对原序列进行一个变换，使得第一个字母换到末尾去，若变换前的序列合法，显然在变换后依旧合法。

我们钦定有 $x$ 个 ```ABC```，$y$ 个 ```BCA``` 和 $z$ 个 ```CAB```。那么在对序列进行一次变换后，若移动的字母是 ```A``` 则 $x\rightarrow x-1,y\rightarrow y+1$。对于其他字母也是类似的。\
若我们对整个序列变换完整的一周后，若三个量都未降至过负数，那么我们可以猜测这个序列是合法的。而证明我们可以采用构造性证明，我们可以将位于序列的前 $x$ 个 ```A``` 用于构建 ```ABC```，中间的 $n-x-y$ 个用于构造 ```CAB```，最后的 $y$ 个构造 ```BCA```。以此类推便可以证明。

由我们对序列变化对 $x,y,z$ 的推导，令 $pre_i$ 表示前缀中某个字符的个数，那么，在变化中，$x,y,z$ 可以表示为：
$$\begin{cases}
&x_i=x-pre_{i,a}+pre_{i,c}\\
&y_i=y-pre_{i,b}+pre_{i,a}\\
&z_i=z-pre_{i,c}+pre_{i,b}
\end{cases}$$
并且，$x,y,z$ 在变化过程中不能变为负数，则我们可以推出不等式：
$$\begin{cases}
&x\ge \max\space{pre_{i,a}-pre_{i,c}}\\
&y\ge \max\space{pre_{i,b}-pre_{i,a}}\\
&z\ge \max\space{pre_{i,c}-pre_{i,b}}
\end{cases}$$
于是我们便可以通过线性复杂度检验一组 $x,y,z$ 是否合法。

那么，在没有 $s_1,s_2$ 限制的时候，令 $x=\max{a-c}$，并且满足 $x+y+z\leq n$ 即可。\
把上面所说的重要信息全部丢进状态设计里，对于 $f_{a,b,c,0/1,0/1}$ 我们已经处理了 $a$ 个 ```A```，$b$ 个 ```B``` 和 $c$ 个 ```C```，并且是否满足了 $x,y$ 的限制，因为 $z$ 没有设置在状态中，所以我们要保证 $z\leq n-x-y$。\
面对 ```?``` 我们则可以把它当作 ```A```，```B```，```C``` 都做一遍相应的操作与判断。

于是我们就可以写出代码，通过本题的[弱化版](https://www.luogu.com.cn/problem/AT_agc055_d)。\
在外层枚举 $x,y$ 在内层枚举 $a,b,c$ 并进行判断与转移，总复杂度为 $O(N^5)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N=60,M=180,mod=998244353;
typedef long long int ui;
int T,tid,n,m;
string s1,s2,s;
ui f[N][N][N][2][2];
ui ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
//	cin>>T>>tid;
//	while(T--)
//	{
		cin>>n>>s;
		m=n*3;
		s=" "+s;
		ans=0;
		for(int x=0;x<=n;x++)
			for(int y=0;y<=n;y++)
			{
				int z=n-x-y;
				memset(f,0,sizeof f);
				f[0][0][0][0][0]=1;
				for(int a=0;a<=n;a++)
					for(int b=0;b<=n;b++)
					{
						if(b-a>y)
							continue;
						for(int c=0;c<=n;c++)
						{
							int i=a+b+c+1;
							if(a-c>x || z<c-b || i>m)
								continue;
							if(s[i]=='A' || s[i]=='?')
							{
								int mz1=((a+1-c)==x),mz2=((b-a-1)==y);
								(f[a+1][b][c][mz1][mz2]+=f[a][b][c][0][0])%=mod;
								(f[a+1][b][c][1][mz2]+=f[a][b][c][1][0])%=mod;
								(f[a+1][b][c][mz1][1]+=f[a][b][c][0][1])%=mod;
								(f[a+1][b][c][1][1]+=f[a][b][c][1][1])%=mod;
							}
							if(s[i]=='B' || s[i]=='?')
							{
								int mz1=((a-c)==x),mz2=((b+1-a)==y);
								(f[a][b+1][c][mz1][mz2]+=f[a][b][c][0][0])%=mod;
								(f[a][b+1][c][1][mz2]+=f[a][b][c][1][0])%=mod;
								(f[a][b+1][c][mz1][1]+=f[a][b][c][0][1])%=mod;
								(f[a][b+1][c][1][1]+=f[a][b][c][1][1])%=mod;
							}
							if(s[i]=='C' || s[i]=='?')
							{
								int mz1=((a-c-1)==x),mz2=((b-a)==y);
								(f[a][b][c+1][mz1][mz2]+=f[a][b][c][0][0])%=mod;
								(f[a][b][c+1][1][mz2]+=f[a][b][c][1][0])%=mod;
								(f[a][b][c+1][mz1][1]+=f[a][b][c][0][1])%=mod;
								(f[a][b][c+1][1][1]+=f[a][b][c][1][1])%=mod;
							}
//							cout<<f[a][b][c][0][0]<<' '<<f[a][b][c][0][1]<<'\n';
//							cout<<f[a][b][c][1][0]<<' '<<f[a][b][c][1][1]<<'\n';
//							cout<<'\n';
						}
					}
				(ans+=f[n][n][n][1][1])%=mod;
			}
		cout<<ans<<'\n';
//	}
	return 0;
}
```
回到本题，对于加入的限制，我们需要找到最小的 $x_0,y_0$ 满足 $x_0\ge\max{a-c},y_0\ge\max{b-a},x_0\in s_1,y_0\in s_2$，如果该序列合法，那么 $x_0,y_0$ 必定满足条件。

我们可以沿用上面的状态，将最后的两个状态改为是否可以使最小的 $x_0,y_0$ 满足条件，时间复杂度不变，代码如下。
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N=65,M=180;
typedef unsigned int ui;
int T,tid,n,m;
string s1,s2,s;
ui f[N][N][N][2][2];
ui ans;
int xx,yy;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T>>tid;
	while(T--)
	{
		cin>>n>>s1>>s2>>s;
		if(T)
		{
			cout<<"-1\n";
			continue;
		}
		m=n*3;
		s=" "+s;
		ans=0;
		xx=-1;
		for(int x=0;x<=n;x++)
		{
			if(s1[x]=='0')
				continue;
			yy=-1;
			for(int y=0;y<=n;y++)
			{
				if(s2[y]=='0')
					continue;
				int z=n-x-y;
				memset(f,0,sizeof f);
				f[0][0][0][!~xx][!~yy]=1;
				for(int a=0;a<=n;a++)
					for(int b=0;b<=n;b++)
					{
						if(b-a>y)
							continue;
						for(int c=0;c<=n;c++)
						{
							int i=a+b+c+1;
							if(a-c>x || z<c-b || i>m)
								continue;
							if(s[i]=='A' || s[i]=='?')
								for(int mz=a-c>xx;mz<=1;mz++)
									f[a+1][b][c][mz|(a-c+1>xx)][0]+=f[a][b][c][mz][0],
									f[a+1][b][c][mz|(a-c+1)>xx][1]+=f[a][b][c][mz][1];
							if(s[i]=='B' || s[i]=='?')
								for(int mz=a-c>xx;mz<=1;mz++)
									f[a][b+1][c][mz][(b-a+1)>yy]+=f[a][b][c][mz][0],
									f[a][b+1][c][mz][1]+=f[a][b][c][mz][1];
							if(s[i]=='C' || s[i]=='?')
								for(int mz=a-c>xx;mz<=1;mz++)
									f[a][b][c+1][mz][0]+=f[a][b][c][mz][0],
									f[a][b][c+1][mz][1]+=f[a][b][c][mz][1];
//							cout<<f[a][b][c][0][0]<<' '<<f[a][b][c][0][1]<<'\n';
//							cout<<f[a][b][c][1][0]<<' '<<f[a][b][c][1][1]<<'\n';
//							cout<<'\n';
						}
					}
				ans+=f[n][n][n][1][1];
				yy=y;
			}
			xx=x;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Lyrella (赞：3)

神仙题，弱化版是 [AGC055D](https://www.luogu.com.cn/problem/AT_agc055_d)。

首先观察数据范围，发现 $n$ 很小于是考虑高维 dp 或者 状压 dp。在 dp 前我们需要去寻找一些性质，考虑怎么样的序列是合法的？我们尝试用一些必要条件去刻画它，这里引用某选手说过的一句话：必要条件多了就可以变成充要条件。

我们可以观察三个不同的子序列：`ABC`，`BCA`，`CAB`。因为这些子序列都有相同的字母但是这些字母的位置不同，所以我们尝试去研究不同字母之间的位置关系。能够发现：只有在 `ABC` 中，`A` 才会出现在 `C` 的前面，否则其在 `C` 的后面。对于其他两对字母也存在类似的关系。设 $pre_a,pre_b,pre_c$ 分别表示前缀 `A`,`B`,`C` 的个数，我们可以发现对于任意前缀都有：$pre_a-pre_c\le cnt_{ABC}$。其他字母同理。

由此我们得到一个神秘的条件：
$$
\max(pre_a-pre_c)+\max(pre_b-pre_a)+\max(pre_c-pre_b)\le n
$$
现在如果我能够通过上述条件构造出合法的解，那么这个条件就为充要条件，于是我们尝试构造一个合法的序列。首先对于一个序列，如果其合法，那么我们将下标平移不会影响其合法性。比如我们把最开始的字母移到最后，可以发现：这个字母所在的子序列进行了一次轮换，其余子序列不变。所以新的序列一定是合法的。于是我们考虑将序列连成一个环，下面给出构造方案：对于环上第 $i$ 个 `A`，对应环上第 $i+cnt_{BCA}$ 个 `B` 和环上第 $i+cnt_{BCA}+cnt_{CAB}$ 个 `C`。

于是现在我们需要证明的是：对于任意的 $i$，环上第 $i+cnt_{BCA}+cnt_{CAB}$ 个 `C` 不在环上第 $i$ 个 `A` 和环上第 $i+cnt_{BCA}$ 个 `B` 之间。

证明是容易的。我们考虑从第 $i$ 个 `A` 处断环成链，于是我们需要证明的是原第 $i+cnt_{BCA}+cnt_{CAB}$ 个 `C` 的位置小等于 $3n$。考虑到原第 $i+cnt_{BCA}+cnt_{CAB}$ 个 `C` 在新的序列中处于第 $1+cnt_{BCA}+cnt_{CAB}$ 个 `C`，考虑最坏的情况是所有 `C` 都在 `A`,`B` 后面，因为有 $cnt_{ABC}+cnt_{BCA}+cnt_{CAB}=n$ 并且因为新的序列开头是 `A` 所以 $cnt_{ABC}>0$，进一步得到 $1+cnt_{BCA}+cnt_{CAB}\le n$，于是得证。

对于弱化版，当 $n\le15$ 时，我们可以直接 $\mathcal O(n^6)$ dp 直接记录所有信息即可。具体的，设 $f_{i,j,k,a,b,c}$ 维护前缀 `A`,`B`,`C` 的数量以及 $cnt_{ABC},cnt_{BCA},cnt_{CAB}$ 然后 $\mathcal O(1)$ 转移。

考虑 $n\le 60$ 时，我们尝试干掉一维状态。因为有 $cnt_{ABC}+cnt_{BCA}+cnt_{CAB}=n$ 所以我们可以枚举 $cnt_{ABC}$ 和 $cnt_{BCA}$ 从而确定 $cnt_{CAB}$，但是考虑到直接做等于 $cnt$ 的限制不太好 dp，于是我们改成做 $\le cnt$ 的限制最后差分一下即可，时间复杂度 $\mathcal O(n^5)$。

---


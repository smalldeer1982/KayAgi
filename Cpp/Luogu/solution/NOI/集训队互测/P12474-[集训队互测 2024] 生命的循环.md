# [集训队互测 2024] 生命的循环

## 题目描述

生命是一张由 $n$ 个神经节点与 $m$ 条神经构成的**带权**有向图，允许存在**自环**、**重边**。

一条编号为 $i$ 的神经 $(u_i, v_i, w_i)$ **单向地**连接着两个神经节点 $u_i \rightarrow v_i$，长度为 $w_i$。

生命的网络不会过于复杂，对于任意一条**简单回路**，其包含的所有神经长度之和**不大于**一个定值 $B$。

神经节点在某些时刻会兴奋，定义 $f(u, t)$ 表示 $t$ 时刻神经节点 $u$ 是否处于兴奋状态。

兴奋会沿着神经传导，对于第 $i$ 条神经 $(u_i, v_i, w_i)$，若神经节点 $u_i$ 在时刻 $t$ 是兴奋的，那么其会向节点 $v_i$ 传递神经信号，使其在时刻 $t + w_i$ 进入兴奋状态。

神经节点的兴奋状态**不会保留**到下一个时刻，即神经节点 $u$ 在进入兴奋状态后会沿其它神经立刻向外传递神经信号；接下来的时刻里，如果没有其它神经向它传递神经信号，则该神经节点会**保持不兴奋**的状态。

如果在**同一个时刻**，一个节点进入兴奋状态后其递归地向自身传递了神经信号，兴奋状态也不会保留到下一个时刻。（换句话说，数据中存在边权和为 0 的简单回路，此时你可以将整条简单回路等效地看作单个神经节点处理。）

生命的伊始，神秘的力量刺激了 1 号神经节点，使其在**时刻 0** 时进入兴奋状态。从此开始无数的时间里，生命的讯号便在神经网络中不息传递着。

在经过葛立恒数个时刻的洗礼后，一位实力强大的 Oler——你，历经千辛万苦，终于抵达了 $n$ 号神经节点。在那里，你看到生命总是趋于循环。

即，保证经过充分长的时间后，$n$ 号神经节点以一个固定时间周期依据一定模式重复进入兴奋状态。

现在的你开始好奇，**此时** $n$ 号神经节点的进入兴奋状态的**最小周期**是多少？

亦即，你需要求出一个最小的正整数 $p$，满足存在一个**有限**的非负整数 $M$，使得

$$\forall x \geq M, f(n, x) = f(n, x + p)$$

由于 $p$ 可能很大，你只需要输出 $p$ 对 $10^9 + 9$ **取模**后的结果。

## 说明/提示

### 数据约束

对于所有数据满足 $2 \leq n \leq 5000, 0 \leq m \leq 10^4, 1 \leq u_i, v_i \leq n, 0 \leq w_i \leq B \leq 100$。

### 子任务

- Subtask 1 (1 pts): 神经构成的有向图是一张 DAG，即不存在任何简单回路。
- Subtask 2 (8 pts): $n, B \leq 10, m \leq 15$。
- Subtask 3 (11 pts): 原图强连通。即任意一对神经节点间都可以通过神经组成的有向路径互相可达。
- Subtask 4 (10 pts): 存在至少一条包含点 $n$ 的简单回路。
- Subtask 5 (19 pts): 所有的简单回路点集互不相交，且总长度两两互质。
- Subtask 6 (9 pts): 所有的简单回路点集互不相交，且总长度均为质数的若干次幂。
- Subtask 7 (18 pts): $B \leq 30$。
- Subtask 8 (24 pts): 无特殊限制。

## 样例 #1

### 输入

```
5 7 0
1 2 0
2 3 1
3 2 5
3 5 1
1 4 0
4 4 9
4 5 1```

### 输出

```
18```

# 题解

## 作者：xuanxuan001 (赞：5)

看了很久才明白，写篇题解记录一下，竟然还是遥遥领先的最优解？

挂个 [qoj 链接](https://qoj.ac/contest/1813/problem/9491)和一个[关联题目](https://www.luogu.com.cn/problem/P6261)（其实这个题里面的思想到最后才用到，我就是先看了这题导致被误导了）。

首先缩点，对于一个强连通分量（下称 SCC），可以发现它其实到最后的周期就是所有环长的 $\gcd$，因为这些环大概可以任意组合，由裴蜀定理可以发现就是，具体求可以以某个点为关键点出发求 dfs 树，然后对非树边按两边深度求个环长就行了，虽然这样的环里面有些边时反向的，但无所谓，因为它是强连通，总能绕回去的，设这个 $\gcd$ 为这个 SCC 的权值，如果这个 SCC 里没有回路，也即只有一个点，那么认为它没有权值。跨 SCC 的边按照两边在自己的分量里的距离可以算出一个新的在 SCC 之间的“长度”。

然后对于一个从 $1$ 所在分量到 $n$ 所在分量的路径，如果它不经过有权值的 SCC，那么这条路径显然对答案不产生贡献，否则同样由裴蜀定理，它的周期是经过的所有 SCC 的权值的 $\gcd$，而它的相位（也即 $x \equiv a \bmod r$ 中的 $a$）可以通过经过的跨 SCC 的路径的长度和求得。

由于题目中保证了环长不超过 $100$，因此有 $a < b \le 100$，所以可能的 $(a,b)$ 数量可以接受，那么所有路径的 $(a,b)$ 可以在 DAG 上容易求得，注意在遇到第一个有权值的 SCC 之前的状态需要特殊考虑，可以先将所有的模数的情况都求一遍并给每个 SCC 对应模数的情况作为初始值。

那么现在求出了所有的 $(a,b)$，将相同的 $a$ 的数对合并成为一个周期为 $a$ 的串，需要求的其实就是所有的这些周期串的并的最小周期。发现取并不是很优美，可以取反后改为取交，这样就等于是一个 CRT 合并求解的过程，只是每个同余方程不要求余数等于特定值而要求属于一个集合，但本质是差不多的。下面的讨论一律按照取交写，称最后取交后的串为最终串，不难发现最终串其实就是这个 CRT 的解集。

首先先给每个串求出最简周期，这样处理后所有的周期串都不存在周期。首先考虑所有的 $a$ 两两互质的情况，发现此时答案就是 $T = \operatorname{lcm} a$，首先不难发现 $T$ 一定是答案的倍数，然后考虑如果存在一个长度是 $T$ 的因数且不是 $T$ 的周期，那么一定存在一个 $a$ 不是这个周期的因数，那么由于这个周期串没有周期，所以这个小于 $T$ 的周期一定会因此不成立。

那么为什么不能拓展到不互质的情况呢？考虑很简单的一个例子，有两个周期串，一个```01```，一个```0111```，不难发现周期是 $2$，因为第二个周期的第三个位置那个 $1$ 根本用不到，所以现在考虑去除这些串中这样的位置，然后用同样的做法就可以了，因为此时一个串中的不同一定会导致最终出来的串某个位置不同。

那么分析一下这样的位置是什么样子，相当于把它所在的这个串改成只有这个位置是 $1$ 后输出的结果串为全 $0$，也即这个同余方程无解。这时转而取考虑找到所有不需要被去除的位置，也即按上述方式更改后有解，这时转变统计思路，考虑枚举最终串的每个位置，可以代入每个方程验证出这个位置是否为 $1$，如果是 $1$ 的话所有周期串的对应位置就都可以标记为合法，虽然依次这些位置很不现实，但它具有拓展意义。

考虑刚才所有周期长度互质的情况为什么不需要考虑这些问题，因为在它们互质的时候不管同余方程是啥用 CRT 一定能合并出来一个解。

那么现在考虑一般情况怎么变成一个全部互质的情况，考虑如果先枚举一个数 $x$ 并只考虑最终串中所有模一个常量 $C$ 余 $x$ 的位置，那么此时一个长度为 $a$ 的周期就变成了一个长度为 $\dfrac a{\gcd(a,B)}$ 的周期。那么如果这时的所有周期两两互质并且没有一个全 $0$ 的周期序列让解集为空集，那么我们就可以将每个周期对应的 $1$ 的位置标位合法了，因为它们都可以在这个同余的集合中找到一个解。

那么这个 $C$ 需要取多少呢？这时就用到了最前面挂的那道链接题目了，发现只需要取到 $2520$ 即可，此时任何一个不超过 $100$ 的数不会有两个质因子的次数同时超过它，否则乘起来就爆 $100$ 了。此时直接按照原题中子任务 6 的做法做就可以了，注意此时会产生许多周期为 $p^k$ 的周期，需要将它们合并以保证所有周期长度两两互质，然后就做完了。

代码就不贴了，直接上 qoj 看就行。

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P12474)

**题目大意**

>给定 $n$ 个点 $m$ 条带权边的有向图，定义 $s_x$ 表示是否存在 $1\to n$ 长度为 $x$ 的路径，求 $s$ 的周期。
>
>数据范围：$n\le 5000,m\le 10^4,B\le 100$，其中 $B$ 为简单环权值和上界。

**思路分析**

先考虑如何求出 $s_x$。

考虑充分大的地方的 $s$，那么路径必然要经过一些环，则周期就是这些环的 $\mathrm{gcd}$。

所以可以对原图缩点，然后对于 DAG 上的每条路径，算对应的周期。

那么周期的最大值为 $B$，所以可以表示成若干 $(p,r)$ 表示把 $x\bmod p=r$ 的 $s$ 都设为 $1$。

考虑如何维护， 表示是否存在走到 $u$，长度 $\bmod p=r$ 的路径。

然后设 $g_{u,p,r}$ 表示是否存在走到 $u$，周期为 $p$，长度 $\bmod p=r$ 的路径，这里从 $f_{u,p,r}=1$ 的状态开始搜索，然后 $p$ 对经过的每个大小 $>1$ 的强连通分量所有环取 $\gcd$。

预处理每个强连通分量内所有环长的 $\gcd$ 是经典问题。

由于状态总数是 $\mathcal O(nB^2)$ 的，因此可以直接记忆化搜索。

然后考虑如何通过若干 $(p,r)$ 求 $f$ 的周期。

这里 $s_x=1$ 是若干条件的并，对 $(p,r)$ 取反变成若干条件的交，即 $\forall p,x\bmod p\in S_p$ 时合法。

首先对 $S_p$ 求出最小整周期，如果所有 $p$ 两两互质，那么答案就是 $\prod p$。

首先 $\prod p$ 一定合法，然后如果答案更小，则周期 $d$ 一定不是某个 $p$ 的倍数，那么就导出矛盾。

注意这里导出矛盾是因为所有 $S_p$ 中的元素都存在一个 $s_x=1$ 满足 $x\bmod p=r$，则 $s_{x+d}=s_x=1$，从而 $(x+d)\bmod p\in S_p$，最终 $S_p$ 有 $\gcd(d,p)$ 这个更小的周期，那么最终肯定无法全部满足。

由于 $p$ 两两互质因此 CRT 总能找到一组解。

否则也能类似，如果所有 $S_p$ 都满足该条件，答案就是 $\mathrm{lcm}(p)$。

那么我们只要把每个 $S_p$ 中无效的 $r$ 都删除即可。

考虑如何进行此操作，我们选定一个 $K$，枚举 $r\in[0,K)$，然后只考虑所有 $\bmod K=r$ 的 $s_x$。

把这些元素看成一个新串，则原先的 $S_p$ 在这上面的周期为 $d_p=\dfrac{p}{\gcd(p,K)}$。

取 $K=2^8\times 3^2\times 5\times 7=2520$，则所有 $p\in[1,B]$，$d_p$ 都只有一个质因子。

那么所有 $d_p$ 要么互质要么有倍数关系。

对于有倍数关系的直接延长合并，剩下所有的串长互质，两两无法消除。

最后会形成 $B$ 个为 $B\times K$ 的周期，求最小整周期后求 $\mathrm{lcm}$ 即可。

时间复杂度 $\mathcal O((n+m+B^2)K)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005,V=100,B=2520,MAXL=252005,MOD=1e9+9;
int n,m,_;
struct Edge { int v,w; };
vector <Edge> G[MAXN];
int dfn[MAXN],low[MAXN],dcnt,stk[MAXN],tp,bl[MAXN],scnt;
bool ins[MAXN],vis[MAXN];
void tarjan(int u) {
	dfn[u]=low[u]=++dcnt,stk[++tp]=u,ins[u]=true;
	for(auto e:G[u]) {
		if(!dfn[e.v]) tarjan(e.v),low[u]=min(low[u],low[e.v]);
		else if(ins[e.v]) low[u]=min(low[u],dfn[e.v]);
	}
	if(low[u]==dfn[u]) for(++scnt;ins[u];ins[stk[tp--]]=false) bl[stk[tp]]=scnt;
}
int dis[MAXN],c[MAXN];
void dfs0(int u) {
	vis[u]=true;
	for(auto e:G[u]) if(bl[e.v]==bl[u]) {
		if(!vis[e.v]) dis[e.v]=dis[u]+e.w,dfs0(e.v);
		else c[bl[u]]=__gcd(c[bl[u]],abs(dis[u]+e.w-dis[e.v]));
	}
}
bool f[MAXN][V+5][V+5],g[MAXN][V+5][V+5];
void dfs1(int u,int p,int r) {
	if(f[u][p][r]) return ;
	f[u][p][r]=true;
	for(auto e:G[u]) dfs1(e.v,p,(r+e.w)%p);
}
void dfs2(int u,int p,int r) { 
	if(c[bl[u]]) p=__gcd(p,c[bl[u]]),r%=p;
	if(g[u][p][r]) return ;
	g[u][p][r]=true;
	for(auto e:G[u]) dfs2(e.v,p,(r+e.w)%p);
}
bool isc[V+5],h[30][V+5],str[30][MAXL];
int t=0,ty[V+5],w[30],pw[V+5],kmp[MAXL];
void solve(int o) {
	memset(h,0,sizeof(h));
	for(int i=1;i<=100;++i) {
		if(B%i==0) {
			if(g[n][i][o%i]) return ;
			continue;
		}
		int p=ty[i/__gcd(i,B)];
		for(int j=0;j<w[p];++j) h[p][j]|=g[n][i][(j*B+o)%i];
	}
	for(int i=1;i<=t;++i) if(!count(h[i],h[i]+w[i],0)) return ;
	for(int i=1;i<=t;++i) for(int j=0;j<w[i];++j) str[i][j*B+o+1]=!h[i][j];
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	for(int i=2;i<=V;++i) if(!isc[i]) {
		for(w[++t]=i,ty[i]=t;w[t]*i<=V;) ty[w[t]*=i]=t;
		for(int j=i*2;j<=V;j+=i) isc[j]=true;
	}
	cin>>n>>m>>_;
	for(int i=1,u,v,z;i<=m;++i) cin>>u>>v>>z,G[u].push_back({v,z});
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	for(int i=1;i<=n;++i) if(!vis[i]) dfs0(i);
	for(int i=1;i<=V;++i) dfs1(1,i,0);
	for(int u=1;u<=n;++u) if(c[bl[u]]) for(int r=0,p=c[bl[u]];r<p;++r) if(f[u][p][r]) dfs2(u,p,r);
	for(int o=0;o<B;++o) solve(o);
	for(int o=1;o<=t;++o) {
		int len=w[o]*B;
		for(int i=2,j=0;i<=len;++i) {
			while(j&&str[o][j+1]!=str[o][i]) j=kmp[j];
			kmp[i]=j+=(str[o][j+1]==str[o][i]);
		}
		int d=len-kmp[len];
		if(len%d) d=len;
		for(int i=2;i*i<=d;++i) if(d%i==0) {
			int z=0; for(;d%i==0;d/=i,++z);
			pw[i]=max(pw[i],z);
		}
		if(d>1) pw[d]=max(pw[d],1);
	}
	int ans=1;
	for(int i=1;i<=V;++i) for(int j=0;j<pw[i];++j) ans=1ll*ans*i%MOD;
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：0)

一个路径可以分解为走一条简单路径以及走途径的简单环。假设路径经过的环长度分别为 $l_i$，而路径本身长 $k$，那么所有 $x\bmod \gcd(l_i)=k$ 的 $x$，当 $x$ 充分大时有 $f(n,x)=1$。对于原图强连通，由于可以构造一条路径经过所有点，因此我们声称答案是所有环长的 $\gcd$。这个比较经典：取一棵 dfs 外向生成树，那么 $\gcd$ 就是所有非树边的 $\gcd(w+d_u-d_v)$。接下来我们显然需要将有向图的 SCC 进行缩点，我们可以处理出 $d_i$ 表示这个为 $i$ 的 SCC 的环长的 $\gcd$，记为 $p_i$。如果 $n$ 在 SCC 中，那么就确定答案是这个 SCC 中环长的 $\gcd$ 的因子，容易记忆化求出一个 $01$ 串。

综合上述两个方向，处理出：$f_{u,t,i}$ 表示是否存在 $1\to u$ 的路径，当前路径所有 SCC 的 $\gcd$ 为 $t$，且路径总长模 $t$ 余 $i$。$f$ 的处理是容易使用记忆化搜索，并且这个状态量是正确的，那么最终问题等价于：对于所有 $t\in[1,B]$，将 $f_{t,i}$ 视为 $01$ 串复制无穷次，所有结果求并集得到一个 $01$ 串 $S$。我们需要求出 $S$ 的最小周期。考虑取反后改为取交。显然每个 $f$ 可以缩成最小周期，然后重新令 $t$ 为每个 $f$ 当前的长度。我们可以得到 $ans\mid \text{lcm}(t_i)$。全部互质的情况，我们声称答案就是 $\text{lcm}(t_i)$，因为这个过程可以类比 CRT，压缩后每个位置都是必然有贡献的。

如果两个串的长度满足 $x\mid y$，那么我们可以先对这两个串合并。在子任务 $5/6$ 中保证最终 $t$ 两两互质或者存在全 $0$。这启发我们将当前状态变为 $t_i$ 两两互质的最终状态。显然我们需要修改 $f$ 才能达到修改 $t$ 的目的，因此考虑等价转化当前状态。考虑一个样例：$f=\{\texttt{01},\texttt{0111}\}$，我们发现有一些位置从 $1\to 0$ 之后对 $S$ 没有任何影响。但是找到后可以进行进一步压缩。

考虑不能被 $1\to 0$ 的位置，满足将所属 $f$ 其余位都修改成 $0$ 后，这样求出的 $S'$ 并非全 $0$。针对小质数，我们找到一个 $I$，每次保留 $S$ 中模 $I$ 为 $r$ 的所有位置。 取 $I=2520$，这样每个提取出串的周期是 $d_i=\frac{t_i}{\gcd(t_i,I)}$，这样 $d_i$ 可以表示为 $p^k,p\in\mathbb{P}$。转化为子任务 $6$，对于成倍数的直接合并，最终可以转化为两两互质的状态。时间复杂度 $\mathcal O(nB^2+B^2I)$。

---


# [集训队互测 2024] 研心

## 题目背景

当你看向镜子时，是否会注意到自己背后的事物？我相信大部分人的关注点应该在自己的虚像上。

现在想象一面镜子，你能在镜子中看到自己所有可能的现状或未来，也许某个自己和你的朋友过着差不多的生活。你会在镜子中找到一个向往的自我，也许那是现在的自己，或者是更好的自己。但就如镜中的背景，也有很多的可能性是，其他的自我没有那么幸运，过的更普通，更辛苦。但不变的是，所有的可能性就是你自己。你从最开始便有着一双将可能性化为现实的翅膀。

不要忽略镜中的每一处细节，当你打碎这面镜子时，你会得到一双完整的翅膀。解开一切的束缚，蹬离地面，展翅高飞吧。

## 题目描述

给定大小为 $n$ 的字符串序列 $S$ 和大小为 $m$ 的字符串序列 $T$，其中 $S$ 的第 $i$ 个字符串为 $S_i$，$T$ 的第 $j$ 个字符串为 $T_j$。

定义一个字符串的权值 $f(s)$ 为 $s$ 中最长奇回文子串的半径长度。例如 `aba` 的半径长度为 $2$，`ababa` 的半径长度为 $3$。

定义两个字符串的加法 $s + t$ 为把两个字符串拼接起来得到的新字符串。

求：

$$\sum_{i=1}^{n} \sum_{j=1}^{m} f(S_i + T_j)$$

## 说明/提示

### 样例解释

| 回文半径长度 | $T_1$ | $T_2$ | $T_3$ |
| :---: | :---: | :---: | :---: |
| $S_1$ | 1 | 2 | 1 |
| $S_2$ | 2 | 3 | 2 |
| $S_3$ | 2 | 3 | 3 |

### 数据范围

令 $s = \max(\sum |S_i|, \sum |T_i|)$。

本题共有 4 个子任务，只有通过子任务中所有数据才能获得所有分数。

| 子任务编号 | 分数 | 特殊条件 |
| :---: | :---: | :---: |
| 1 | 20 | $s \leq 5000$ |
| 2 | 30 | $n = 1$ |
| 3 | 20 | 保证所有字符在 $\{a, b\}$ 中随机 |
| 4 | 30 | ~~依赖子任务 1, 2, 3~~ 还没配置子任务依赖 |

对于 100% 的数据，满足 $1 \leq n, m, s \leq 4 \times 10^5$，保证输入的字符串只包含小写字母。

## 样例 #1

### 输入

```
3 3
a
aba
aaba
b
ba
ab```

### 输出

```
19```

# 题解

## 作者：Tony2 (赞：3)

首先考虑如何统计一个被缝合的串的奇回文长度。分成三段，一个是左边最长回文，右边最长回文，中间的回文。

中间的回文可以通过回文中心区分成左右两边，以左边为例：我们枚举左边串的回文后缀，将这个串去掉这个后缀后倒着对右侧匹配，匹配最长的是其中一个奇回文串，这里用二分哈希实现。匹配过程可以看作左边的串在右边的 $m$ 个串形成的正 $\text{trie}$ 进行匹配。

设左串个数为 $n$，右串个数为 $m$，考虑求出一个 $n\times m$ 的矩阵表示答案的矩阵，最终进行求和。

我们对于上述总共四种回文对矩阵进行覆盖（即 $\text{chkmax}$），例如左边最长回文是行覆盖，右边最长回文是列覆盖，回文中心在左侧是对一行进行一个 $\text{trie}$ 树上的覆盖，回文中心在右侧是对一列进行一个 $\text{trie}$ 树上的覆盖。

行和列的交互是非常困难的，首先考虑如何在只考虑行操作之后求出答案。

试图把一个可重的覆盖变成不重的覆盖，即多个“连续段”的值直接覆盖。单个左侧回文中心的操作具体是在  $\text{trie}$ 树上对一条路径 $S$ 进行如下操作：

设左回文后缀为 $l$，那么对右侧 $S$ 路径上深度为 $d$ 的点 $u$ 的子树进行关于 $2d+l$ 的 $\text{chkmax}$。这里 $d$ 的系数直接钦定为 $1$（即原题求最长回文半径）。

提取出所有的 $u$ 建立虚树，考虑所有在虚树上（包括长链上的）的 $\text{trie}$ 树节点得到的权值。这个权值的意义是子树内所有 $\text{trie}$ 树结束节点（例如固定左边那么 $\text{trie}$ 树上就是 $T$ 的 $m$ 个结束节点）对应的最长回文对这个权值取 $\max$。

考虑这么限制权值的值，使得每个点 $u$ 的权值掌控（能真正更新 $\max$）的部分是 $u$ 的子树除去子树节点掌控的部分。进行两轮更新：

1. $chkmax(val_{fa_u},val_u+1)$

2. $chkmax(val_u, val_{fa_u})$

虚树上虚边对应的链的权值是形如 $1,1,1,2,3,4$ 的形式，即一段相同权值接一段公差为 $1$ 的等差数列。这样原 $\text{trie}$ 树上每个点的权值都能被唯一覆盖，覆盖形式要不然是直接赋值（上面序列平的部分）或者是一个嵌套的结构，形式化地讲：设这条祖先-儿子方向的链为 $C$，第 $i$ 个点是 $C_i$，那第 $i$ 个点掌控的范围是 $\text{subtree}(C_i)-\text{subtree}(C_{i+1})$，权值是 $i+k$，$k$ 是个关于这条链定值。

考虑把上述覆盖转到树剖上，其中第二种会拆成较多标记，忽略分讨过程之后，总的来说可以总结成三种：

1. 单点以权值 $k$ 覆盖

2. 重链的一个区间的所有点和他们的轻儿子以权值 $k$ 被覆盖

3. 重链的一个区间的所有点和他们的轻儿子以重链上的点的深度 $+k$ 为权值被覆盖

注意这种标记会有 1/-1 的系数。当一个位置被权值为 $\{a_i\}$ （如 $\{1,-1,2,-2,3\}$）的标记覆盖，那么真正的标记权值是 $\sum a_i$（上个例子是 $3$）。实现时保证标记集合可以通过消掉相反数的对最终得到至多一个正数标记。

然后进入纯 ds 部分。把树剖的重链拆成全局平衡二叉树，上述标记最终被拆成 $O(\log)$ 个子标记，每个标记都在一个全局平衡二叉树节点上，因为此时标记的类型相同（只需要考虑不同的 $k$）。考虑 $s$ 串产生的在 $\text{t-trie}$ 上的标记和 t 串产生的在 $\text{s-trie}$ 上的标记。将前者挂在 $\text{s-end}$（即 $\text{s-trie}$ 的结束节点）上，它有对应的在 $\text{t-trie}$ 全局平衡二叉树上的一个标记；将后者的标记部分挂在 $\text{s-trie}$ 的全局平衡二叉树上，它相应的有一个对应的 $\text{t-end}$。考虑特定的一对 $s-t$，我们想要知道第一种标记和第二种标记的最大值。但是尽管上文提到这种标记是不重的覆盖，但实现中我们并不能做到真正的不重，是通过带系数的权值之间取 $\max$ 得到的。

具体的，这种标记可以看作 $(val,k)$ 其中 $k$ 表示系数。

两个标记取 $\max$ 结果为 $(\max(val_1,val_2),k_1k_2)$。可以证明这种标记具有交换律和结合律，更重要的，具有分配律。

对于这个特定的 $s-t$，两侧的标记实际上是标记集合，但是因为标记具有分配律，所以可以求出两个集合两两标记的最大值之后再求和。关注 $s$ 的标记覆盖到 $\text{t-end}$ 且 t 的标记覆盖到 $\text{s-end}$ 的条件，枚举 $\text{s-trie}$ 全局平衡二叉树的节点 $u$，枚举所有 t 的标记覆盖在 $u$ 上的标记，得到一种暴力做法：先枚举 $u$ 覆盖下的节点 $v$（这个节点是原 $\text{s-trie}$ 树节点），并枚举 $v$ 作为 $\text{s-end}$ 时所有对 $\text{t-trie}$ 全局平衡二叉树的标记挂到这个二叉树节点 $x$ 上，然后枚举标记覆盖 $u$ 的对应的所有 $\text{t-end}$ 节点 $w$，枚举 $w$ 的所有祖先和之前挂的标记取 $\max$ 后求和。因为查询一个 $\text{t-trie}$ 全局平衡二叉树节点 $x$ 上所有比某个标记大的标记的和需要二分，所以到这里最终复杂度为 $O(s\log^3 s)$。

实际上可以优化掉这个二分。首先考虑 $\text{s-end}$ 对 $\text{t-trie}$ 全局平衡二叉树的标记，放到同一个 $x$ 上的标记需要排序，所以可以换成在 $u$ 时先将所有 $v$ 上的标记放到一起整体排序后按顺序添加标记，这个排序可以通过从 $u$ 的儿子继承排序好的标记进行归并替换。对于 $u$ 上标记对应的 $w$ 向上查询的过程，我们先把查询挂在 $w$ 上，并遍历 $\text{t-trie}$ 全局平衡二叉树有查询的部分，从下至上向上归并查询，这样同时查询一个 $x$ 的查询是排好序的，可以把标记和查询进行归并，同样求出 $\max$ 之和。总复杂度为 $O(s\log^2s)$。

---

## 作者：_ANIG_ (赞：2)

[传送门](https://qoj.ac/contest/1815/problem/9514)

恐怖大 ds。

首先考虑给定两个串 $S,T$，如何算 $S+T$ 的最长奇回文子串。

可以把所有回文子串分成两类：经过分界点的和不经过分界点的。

对于不经过分界点的，可以提前求出每个字符串的最长奇回文子串。比较麻烦的是经过分界点的。

不妨假设回文中心在串 $S$ 中。

可以发现，$S+T$ 形如：$DAB|A'E$，其中 $A$ 和 $A'$ 相反，$B$ 是回文串。

回文串的长度为 $A,B,A'$ 的长度之和，并且回文中心是 $B$ 的回文中心。

不妨枚举 $A,B$ 的分界点所在的位置。

也就是枚举 $S$ 的所有回文后缀，然后找到 $S$ 去除这个后缀和翻转后的 $T$ 的最长公共后缀。

回文中心在 $T$ 中的情况类似，要求的为翻转后的 $T$ 的前缀和 $S$ 的最长公共后缀。

不妨先给所有 $T$ 翻转，然后把 $S$ 和 $T$ 的所有前缀放在一起跑 SA，然后套个 ST 标即可 $O(1)$ 计算出最长公共后缀。

这样总复杂度 $O(n^2)$，其中 $n$ 表示字符串长度总和。

考虑优化这个过程。

把 SA 数组从前往后扫一遍，用单调栈维护后缀最小值。

这样就可以得到若干个区间，每个区间内部的串和当前扫到的串的最长公共后缀相同。

一个比较暴力的做法是每次扫一遍单调栈，设 $f_{i,j}$ 表示 $S_i+T_j$ 的最长奇回文子串的长度，则可以转化为若干次 $1\times n$ 矩形的 chkmax，然后求全局和。

但是直接做总矩形个数是 $O(n^2)$ 的。

考虑分治，设置一个阈值 $T$。

用第二个方法统计所有 $\min(|S_i|,|T_j|)\le T$ 的 $(i,j)$ 的贡献。

由于最短的串长度不超过 $T$，所以这两个串的最长公共后缀长度也不超过 $T$，这样我们扫单调栈就只需要扫不超过 $T$ 的元素，每次最多产生 $O(T)$ 的矩形，总矩形数为 $O(nT)$。

然后是统计答案的部分。

首先可以对同一行和同一列的操作合并，这样可以转化为每一行的矩形不交，每一列的矩形不交的情况。

合并可以先把矩形按权值从小到大排序，然后套珂朵莉树。

合并完之后，把所有矩形权值从大到小排序，操作转化为每次给没有覆盖的位置覆盖上当前的权值。

也就是要求出每次覆盖时还没有被覆盖的位置的数量。

由于每一行的矩形不交，所以要统计的实际上是所有竖着的矩形的贡献。

也就是每次给一个竖着的矩形加，然后查询一个横着的矩形的和。

这个问题就可以直接上树套树了。

这样，这部分总复杂度 $O(nT\log^2 n)$。

对于两个串长度都大于 $T$ 的情况，由于这样的串不会超过 $O(\frac nT)$ 个，所以直接用第一种方法即可做到 $O(\frac{n^2}T)$。

总复杂度 $O(\frac{n^2}T+nT\log^2 n)$。

取 $T=\frac{\sqrt n}{\log n}$，可得总复杂度 $O(n\sqrt n\log n)$。

常数极小，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ull unsigned long long
const int N=4e5+5,T=80;
namespace tt{
    struct node{
		int lson,rson,laz;
	}p[N*100];
	int idx;
    void add(int x,int l,int r,int sm,int nl,int nr){
    	if(l<=nl&&r>=nr){
    		p[x].laz+=sm;
    		return;
    	}
    	int mid=nl+nr>>1;
    	if(l<=mid){
    		if(!p[x].lson)p[x].lson=++idx;
    		add(p[x].lson,l,r,sm,nl,mid);
	    }
    	if(r>mid){
    		if(!p[x].rson)p[x].rson=++idx;
	    	add(p[x].rson,l,r,sm,mid+1,nr);
	    }
    }
    void gets(int x,int d,int&res,int nl,int nr){
    	if(!x)return;
    	res+=p[x].laz;
    	if(nl==nr)return;
    	int mid=nl+nr>>1;
    	if(d<=mid)gets(p[x].lson,d,res,nl,mid);
    	else gets(p[x].rson,d,res,mid+1,nr);
    }
}
struct tr{
	struct node{
		int l,r,rt;
	}p[N<<1];
	int lth;
	void reset(int x,int l,int r){
		p[x].l=l,p[x].r=r;p[x].rt=++tt::idx;
		if(l==r)return;
		int mid=l+r>>1;
		reset(x<<1,l,mid);
		reset(x<<1|1,mid+1,r);
	}
	void add(int x,int d,int l,int r,int sm){
		if(l>r)return;
		tt::add(p[x].rt,l,r,sm,1,lth);
		if(p[x].l==p[x].r)return;
	    if(d<=(p[x].l+p[x].r>>1))add(x<<1,d,l,r,sm);
	    else add(x<<1|1,d,l,r,sm);
	}
	void gets(int x,int l,int r,int d,int&res){
		if(l>r)return;
		if(l<=p[x].l&&r>=p[x].r){
			tt::gets(p[x].rt,d,res,1,lth);
			return;
		}
		int mid=p[x].l+p[x].r>>1;
		if(l<=mid)gets(x<<1,l,r,d,res);
		if(r>mid)gets(x<<1|1,l,r,d,res);
	}
}t1,t2;
long long res;
int n,m,l1[N],l2[N],zd1[N],zd2[N],bh[N<<1],db[2][N],idx1,idx2,idx,f[N<<1],st[N<<1][22];
vector<int>q1[N],q2[N],mk1[N],mk2[N],p[2][N],tmp[2][N],w1[N],w2[N];
vector<ull>qh1[N],qh2[N],hh1[N],hh2[N];
ull pw[N];
ull h1(vector<ull>&h,int l,int r){
	return h[r]-h[l-1]*pw[r-l+1];
}
ull h2(vector<ull>&h,int l,int r){
	return h[l]-h[r+1]*pw[r-l+1];
}
int glh(vector<ull>&qh,vector<ull>&hh,int n){
	int res=0;
	for(int i=1;i<=n;i++){
		int l=1,r=min(i,n-i+1);
		while(l<r){
			int mid=l+r+1>>1;
			if(h1(qh,i-mid+1,i+mid-1)==h2(hh,i-mid+1,i+mid-1))l=mid;
			else r=mid-1;
		}
		res=max(res,2*l-1);
	}
	return res;
}
struct msg{
	int op,bh,x;
}g[N<<1];
vector<msg>jl[N<<1];
int gets(msg x){
	if(!x.bh)return -1;
	if(x.op)return q2[x.bh][x.x];
	return q1[x.bh][x.x];
}
bool cmp(msg a,msg b){
	return gets(a)<gets(b);
}
ull h(msg x,int k){
	if(x.op)return h1(qh2[x.bh],x.x-k+1,x.x);
	return h1(qh1[x.bh],x.x-k+1,x.x);
}
struct node{
	int l1,r1,l2,r2,sm;
};
vector<node>q;
struct nodes{
	int l,r,sm;
	friend bool operator<(nodes a,nodes b){
		return a.sm<b.sm;
	}
};
vector<nodes>f1[N],f2[N];
void add(int op,int l,int r,int x,int sm){
	if(l>r)return;
	if(op)f2[x].push_back({l,r,sm});
	else f1[x].push_back({l,r,sm});

	
}
struct qj{
	int l,r,sm;
	friend bool operator<(qj a,qj b){
		return a.r<b.r;
	}
};
struct xg{
	int op,x,l,r,sm;
	friend bool operator<(xg a,xg b){
		return a.sm>b.sm;
	}
};
vector<xg>jj;
void split(set<qj>&q,int x){
	auto w=q.lower_bound({x,x});
	if(x==(*w).l)return;
	auto t=*w;
	q.erase(w);
	q.insert({t.l,x-1,t.sm});
	q.insert({x,t.r,t.sm});
}
void upt(vector<nodes>&g,int n){
	set<qj>q;
	sort(g.begin(),g.end());
	q.insert({1,n,0});
	for(auto c:g){
		split(q,c.l);if(c.r<n)split(q,c.r+1);
		while(1){
			auto w=q.lower_bound({c.l,c.l});
			if(w==q.end()||(*w).r>c.r)break;
			q.erase(w);
		}
		q.insert({c.l,c.r,c.sm});
	}
	g.clear();
	for(auto c:q)g.push_back({c.l,c.r,c.sm});
}
void SA(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=l1[i];j++)g[++idx]={0,i,j};
		p[0][i].resize(q1[i].size());
		tmp[0][i].resize(q1[i].size());
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=l2[i];j++)g[++idx]={1,i,j};
		p[1][i].resize(q2[i].size());
		tmp[1][i].resize(q2[i].size());
	}
	sort(g+1,g+idx+1,cmp);
	int cnt=0;
	for(int i=1;i<=idx;i++){
		if(gets(g[i])!=gets(g[i-1]))cnt++;
		p[g[i].op][g[i].bh][g[i].x]=cnt;
	}
	for(int i=1;i<=20;i++){
		for(int j=1;j<=idx;j++){
			if(g[j].x-(1<<i-1)>0)jl[p[g[j].op][g[j].bh][g[j].x-(1<<i-1)]].push_back(g[j]);
			else jl[0].push_back(g[j]);
		}
		idx=0;
		for(int j=0;j<=cnt;j++){
			for(auto c:jl[j])g[++idx]=c;
			jl[j].clear();
		}
		for(int j=1;j<=idx;j++)jl[p[g[j].op][g[j].bh][g[j].x]].push_back(g[j]);
		idx=0;
		for(int j=0;j<=cnt;j++){
			for(auto c:jl[j])g[++idx]=c;
			jl[j].clear();
		}
		cnt=0;
		auto g1=[&](msg x){
			return p[x.op][x.bh][x.x];
		};
		auto g2=[&](msg x){
			if(x.x-(1<<i-1)<=0)return 0;
			return p[x.op][x.bh][x.x-(1<<i-1)];
		};
		for(int j=1;j<=idx;j++){
			if(j==1||g1(g[j])!=g1(g[j-1])||g2(g[j])!=g2(g[j-1]))cnt++;
			tmp[g[j].op][g[j].bh][g[j].x]=cnt;
		}
		for(int j=1;j<=n;j++)swap(tmp[0][j],p[0][j]);
		for(int j=1;j<=m;j++)swap(tmp[1][j],p[1][j]);
	}
	for(int i=1;i<=idx;i++)p[g[i].op][g[i].bh][g[i].x]=i;
	for(int i=1;i<idx;i++){
		int l=0,r=min(g[i].x,g[i+1].x);
		while(l<r){
			int mid=l+r+1>>1;
			if(h(g[i],mid)==h(g[i+1],mid))l=mid;
			else r=mid-1;
		}
		f[i]=l;
		st[i][0]=f[i];
	}
	for(int i=1;i<=20;i++){
		for(int j=1;j<=idx-(1<<i);j++){
			st[j][i]=min(st[j][i-1],st[j+(1<<i-1)][i-1]);
		}
	}
	for(int i=1;i<=idx;i++){
		if(g[i].op){
			if(g[i].x==l2[g[i].bh])bh[i]=++idx2,db[1][g[i].bh]=idx2;
		}else{
			if(g[i].x==l1[g[i].bh])bh[i]=++idx1,db[0][g[i].bh]=idx1;
		}
	}
	int nw1=0,nw2=0;
	auto ADD=[&](int i){
		if(bh[i]){
			if(g[i].op)nw2=bh[i];
			else nw1=bh[i];
		}
	};
	q.push_back({1,0,1,0,-1});
	ADD(1);
	for(int i=2;i<=idx;i++){
		while(q.size()&&q.back().sm>=f[i-1])q.pop_back();
		q.push_back({q.back().r1+1,nw1,q.back().r2+1,nw2,f[i-1]});
		if(g[i].op){
			if(g[i].x<l2[g[i].bh])
			if(mk2[g[i].bh][g[i].x+1]){
			    for(auto c:q){
			    	if(c.sm>T)break;
			    	add(1,c.l1,c.r1,db[1][g[i].bh],l2[g[i].bh]-g[i].x+2*c.sm);
			    }
			}
		}else{
			if(g[i].x<l1[g[i].bh])
			if(mk1[g[i].bh][g[i].x+1]){
				for(auto c:q){
			    	if(c.sm>T)break;
			    	add(0,c.l2,c.r2,db[0][g[i].bh],l1[g[i].bh]-g[i].x+2*c.sm);
			    }
			}
		}
		ADD(i);
	}
	nw1=n+1,nw2=m+1;
	q.clear();
	q.push_back({n+1,n,m+1,m,-1});
	ADD(idx);
	for(int i=idx-1;i>=1;i--){
		while(q.size()&&q.back().sm>=f[i])q.pop_back();
		q.push_back({nw1,q.back().l1-1,nw2,q.back().l2-1,f[i]});
		if(g[i].op){
			if(g[i].x<l2[g[i].bh])
			if(mk2[g[i].bh][g[i].x+1]){
			    for(auto c:q){
			    	if(c.sm>T)break;
			    	add(1,c.l1,c.r1,db[1][g[i].bh],l2[g[i].bh]-g[i].x+2*c.sm);
			    }
			}
		}else{
			if(g[i].x<l1[g[i].bh])
			if(mk1[g[i].bh][g[i].x+1]){
				for(auto c:q){
			    	if(c.sm>T)break;
			    	add(0,c.l2,c.r2,db[0][g[i].bh],l1[g[i].bh]-g[i].x+2*c.sm);
			    }
			}
		}
	    ADD(i);
	}
	for(int i=1;i<=n;i++)add(0,1,m,db[0][i],zd1[i]);
	for(int i=1;i<=m;i++)add(1,1,n,db[1][i],zd2[i]);
	for(int i=1;i<=n;i++)upt(f1[i],m);
	for(int i=1;i<=m;i++)upt(f2[i],n);
	for(int i=1;i<=n;i++)for(auto c:f1[i])jj.push_back({0,i,c.l,c.r,c.sm});
	for(int i=1;i<=m;i++)for(auto c:f2[i])jj.push_back({1,i,c.l,c.r,c.sm});
    sort(jj.begin(),jj.end());
    t1.lth=n;t2.lth=m;
    t1.reset(1,1,m);t2.reset(1,1,n);
    for(auto c:jj){
    	if(c.op){
    		int sm=0;
    		t2.gets(1,c.l,c.r,c.x,sm);
    		res+=1ll*(c.r-c.l+1-sm)*c.sm;
    		t1.add(1,c.x,c.l,c.r,1);
    	}else{
    		int sm=0;
    		t1.gets(1,c.l,c.r,c.x,sm);
    		res+=1ll*(c.r-c.l+1-sm)*c.sm;
    		t2.add(1,c.x,c.l,c.r,1);
    	}
    }
}
int gets(int l,int r){
	int k=__lg(r-l+1);
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
int gets(int a,int b,int k1,int k2){
	if(!k1||!k2)return 0;
	int l=p[0][a][k1],r=p[1][b][k2];
	if(l>r)swap(l,r);
	return gets(l,r-1);
}
int solve(int a,int b){
	int res=max(zd1[a],zd2[b]),ans=max(zd1[a],zd2[b]);
	for(auto i:w1[a]){
		int tmp=gets(a,b,i-1,l2[b]);
		res=max(res,l1[a]-i+1+tmp*2);
		if(tmp<=T)ans=max(ans,l1[a]-i+1+tmp*2);
	}
	for(auto i:w2[b]){
		int tmp=gets(a,b,l1[a],i-1);
		res=max(res,l2[b]-i+1+tmp*2);
		if(tmp<=T)ans=max(ans,l2[b]-i+1+tmp*2);
	}
	return res-ans;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	pw[0]=1;
	for(int i=1;i<N;i++)pw[i]=pw[i-1]*131;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		l1[i]=s.size();
		q1[i].push_back(0);
		for(auto c:s)q1[i].push_back(c-'a');
		qh1[i].resize(q1[i].size());
		hh1[i].resize(q1[i].size());
		mk1[i].resize(q1[i].size());
		for(int j=1;j<=l1[i];j++)qh1[i][j]=qh1[i][j-1]*131+q1[i][j]+1;
		for(int j=l1[i];j>=1;j--)hh1[i][j]=hh1[i][j+1]*131+q1[i][j]+1;
	    for(int j=1;j<=l1[i];j++)if(l1[i]-j+1&1)mk1[i][j]=h1(qh1[i],j,l1[i])==h2(hh1[i],j,l1[i]);
	    zd1[i]=glh(qh1[i],hh1[i],l1[i]);
	    for(int j=1;j<=l1[i];j++)if(mk1[i][j])w1[i].push_back(j);
	}
	for(int i=1;i<=m;i++){
		string s;
		cin>>s;
		l2[i]=s.size();
		q2[i].push_back(0);
		for(auto c:s)q2[i].push_back(c-'a');
		reverse(q2[i].begin()+1,q2[i].end());
		qh2[i].resize(q2[i].size());
		hh2[i].resize(q2[i].size());
		mk2[i].resize(q2[i].size());
		for(int j=1;j<=l2[i];j++)qh2[i][j]=qh2[i][j-1]*131+q2[i][j]+1;
		for(int j=l2[i];j>=1;j--)hh2[i][j]=hh2[i][j+1]*131+q2[i][j]+1;
	    for(int j=1;j<=l2[i];j++)if(l2[i]-j+1&1)mk2[i][j]=h1(qh2[i],j,l2[i])==h2(hh2[i],j,l2[i]);
	    zd2[i]=glh(qh2[i],hh2[i],l2[i]);
	    for(int j=1;j<=l2[i];j++)if(mk2[i][j])w2[i].push_back(j);
	}
	SA();
	for(int i=1;i<=n;i++)if(l1[i]>T)for(int j=1;j<=m;j++)if(l2[j]>T)res+=solve(i,j);
	cout<<(res+1ll*n*m)/2;
}
```

---


# [集训队互测 2024] 人间应又雪

## 题目描述

长度为 $n$ 的街道被积雪覆盖，将街道划分为 $n$ 段，第 $i$ 段的积雪量为 $a_i$，保证 $0\le a_i\le m$ 且 $a_i$ 为整数。

天依与言和要来清理积雪，每次清理有 $2$ 种选择。

+ 天依从位置 $1$ 走到位置 $x$，将积雪清理掉 $c$，再走回位置 $1$，同时，因为在雪地上移动，位置 $1\sim x$ 的积雪量减少 $1$，即 $\forall i\in[1,x-1],a_i:=a_i-1,a_x:=a_x-c-1$。
+ 言和从位置 $n$ 走到位置 $x$，将积雪清理掉 $c$，再走回位置 $n$，同时，因为在雪地上移动，位置 $x\sim n$ 的积雪量减少 $1$，即 $\forall i\in[x+1,n],a_i:=a_i-1,a_x:=a_x-c-1$。。

任意时刻，积雪量对 $0$ 取 $\max$。

天依与言和想知道，最少进行多少次清理后（**即最小化两人清理次数总和**），能将所有积雪清除，即 $\forall i\in [1,n],a_i=0$。

## 说明/提示

### 样例解释 1

天依走到位置 $4$ 清理，积雪量变为 $[0,2,1,1,1]$。

言和走到位置 $2$ 清理，积雪量变为 $[0,0,0,0,0]$。

共 $2$ 次清理。

### 样例解释 2

见附加文件中的 `snow.in` 与 `snow.ans`。  
这个样例中有 $100$ 组 $n=10,m=10$ 的数据。

### 数据范围

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le n,m\le 5\times 10^5$，$\sum n,\sum m\le 10^6$，$0\le a_i\le m$，$0\le c\le 5\times 10^5$。

| 子任务编号 |        $n$         |        $m$         |            特殊限制             | 分值 | 子任务依赖 |
| :--------: | :----------------: | :----------------: | :-----------------------------: | :--: | :--------: |
|    $1$     | $\le 5\times 10^5$ | $\le 5\times 10^5$ |              $c=0$              | $2$  |            |
|    $2$     | $\le 5\times 10^5$ |      $\le 2$       |               无                | $3$  |            |
|    $3$     |      $\le 5$       |      $\le 5$       |            $T\le 10$            | $5$  |            |
|    $4$     |      $\le 50$      |      $\le 50$      |     $\sum n,\sum m\le 200$      | $10$ |    $3$     |
|    $5$     |     $\le 300$      |     $\le 300$      |     $\sum n,\sum m\le 600$      | $10$ |    $4$     |
|    $6$     |     $\le 2000$     |     $\le 2000$     |     $\sum n,\sum m\le 4000$     | $10$ |    $5$     |
|    $7$     | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $c\le 20,\sum n,\sum m\le 10^5$ | $20$ |            |
|    $8$     | $\le 5\times 10^4$ | $\le 5\times 10^4$ |     $\sum n,\sum m\le 10^5$     | $15$ |   $6,7$    |
|    $9$     | $\le 5\times 10^5$ | $\le 5\times 10^5$ |            $c\le 20$            | $10$ |   $1,7$    |
|    $10$    | $\le 5\times 10^5$ | $\le 5\times 10^5$ |               无                | $15$ |  $2,8,9$   |

## 样例 #1

### 输入

```
1 0
5 5 1
1 3 2 3 1```

### 输出

```
2```

# 题解

## 作者：xuanxuan001 (赞：3)

很少能见到~~有耐心学会~~逻辑链这么长并且自然的题，写篇题解纪念一下。

[qoj 传送门](https://qoj.ac/contest/1823/problem/9563)

发现各种 dp 都需要记录许多状态，主要原因是同时维护两个方向的操作情况实在太复杂，考虑能不能简化一下。发现所有向右走的操作一定在所有向左走的操作的左边，否则交换两者严格更优。

所以现在其实就是要找到一个分界点，左边的操作都选择向右，右边的都向左，发现跨分界点的贡献只和两边操作的总次数有关，如果枚举分界点和两边的操作次数就可以验证。

发现复杂度还是过高，可以先二分答案 $ans$，然后两边的次数分配就只有 $O(ans) = O(m)$ 种方式。考虑能不能把分界点的枚举也省去，以左边为例，发现此时如果确定了右边的操作次数，那么左边能保持合法的最长前缀是可以求出的，假如求出了每种右边次数对应的最长前缀和达到后剩下的次数，那么右边后缀的情况也是同理，只需要翻转序列使用类似算法即可，那么枚举分配方案后就可以通过比较两个前后缀的位置关系直接判定是否可行而无需枚举分界点。

这里需要注意前后缀刚好接上的时候需要特殊考虑，因为前面的结论实际上没有将两类操作完全分开，是可以存在中间的一个位置上同时进行过两种操作的，对于这种情况需要对两边剩下的次数进行讨论，看能否满足共用位置的限制，更详细的可以看 qoj 上的题解中的描述。

考虑加速求出它们的过程。以求出左边的最长前缀为例，设右边操作了 $k$ 次，最长可以满足到 $[1,f_k - 1]$，并剩下 $g_k$ 次操作。那么求解的过程即为依次考虑 $i = 1 \rightarrow n$，并记录现在需要的操作总次数 $x = k$：

- 若 $a_i \le x$，不需要任何操作。
- 否则，若 $x + \lceil \dfrac {x-a_i}{c+1} \rceil \le ans$，则 $x \leftarrow x + \lceil \dfrac {x-a_i}{c+1} \rceil$。
- 否则，$f_k \leftarrow i$，$g_k \leftarrow ans - x$，退出。

如果到最后 $f_k,g_k$ 都没被赋值，那么 $f_k = n+1$。

那么考虑这个过程能否加速维护，即对所有的 $k \in [0,ans]$ 一起维护这个过程，维护每一个 $x_k$ 为对应 $k$ 的 $x$ 值，那么还是上面的过程，初始有 $x_k = k$，每次会对每个 $k$ 进行 $x_k \leftarrow x_k + \lceil \dfrac {\max(0,x_k-a_i)}{c+1} \rceil$，发现后面增加的那个式子在 $x_k$ 增加 $1$ 时至多增加 $1$，因此可以归纳发现 $x$ 数组一直满足 $x_k \le x_{k+1} \le x_k + 1$。

因此转而维护 $x$ 的连续段，维护一个 $x_0$ 和一个位置数组 $a_1 < a_2 < \cdots < a_p$，为 $x$ 数组满足 $x_k = x_{k-1} + 1$ 的 $k$ 的位置，初始 $p = ans + 1$，$a_i = i$，注意最后有一个超出上界的位置以记录 $x$ 数组的结尾。

那么每次的操作为：

- 若 $x_0 \ge a_i$，不需要操作。
- 设 $y = \lceil \dfrac {x_0-a_i}{c+1} \rceil$，并利用上面相除的余数可以找到第一个 $x$ 值是 $c+1$ 的倍数的对应位置 $a_q$，那么 $\forall j \in [0,y)$，删除 $a_{q + (c+1)j}$，如果这个位置已经超出了 $p$ 的范围，那么对 $[a_{p-1},a_p)$ 更新 $f_* = i,g_* = ans - x_0 + p - 1$ 并删除最后一个元素，最后 $x_0 \leftarrow x_0 + y$。

实现时注意应该先算出需要删除多少次最后一个元素并先删除更新答案再做前面的普通删除，否则可能会因前面的删除而影响更新答案的区间情况，在 $a$ 数组删完时及时退出。

qoj 上官方题解说由于每次都是隔 $O(c)$ 个删一个所以每次删除后暴力更新 $a$ 数组是 $O(mc)$ 的，不懂，感觉有可能一次删除只删去了前面的一小部分，但这里使用数据结构维护并不难，发现 $a$ 数组需要做的就是删去某个元素和查询排名为 $a$ 的数，使用平衡树或权值线段树即可维护，可以用树状数组维护对应的权值线段树，这样常数小。

设 $n,m$ 同阶，此时单次 check 的复杂度是 $O(n \log n)$ 的，因此总复杂度为 $O(n \log^2 n)$，无法通过，但继续观察刚才维护的过程，发现 $ans$ 对 $a$ 数组的变化的影响并不大，$ans$ 只影响被删除的后缀情况，因此可以考虑将计算到每个 $i$ 时发生的删除位置都预处理出来，然后每次 check 的时候就相当于只需要维护删除一个数和查询最后一个数，因为每次还需要重新考虑从最后删除并更新答案的情况，那么这个只需要给值域开一个并查集就可以了，以此平衡到 $O(n \log n)$。

代码看 qoj。

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P12483)


**题目大意**

> 给定 $[1,m]$ 范围内的 $a_1\sim a_n$，每次操作可以选择一个 $a_i$ 减去 $c+1$，然后把 $a[1,i-1]$ 或 $a[i+1,n]$ 全部 $-1$，求把所有元素变成负数的最小操作次数。
>
> 数据范围：$n,m\le 5\times 10^5$。

**思路分析**

首先如果在 $x$ 位置操作前缀，$y$ 位置操作后缀且 $x<y$，那么交换方向得到更优的解。

因此一定存在一个 $i$ 满足后缀操作 $\le i$ ，且前缀操作 $\ge i$。

二分答案 $k$，枚举后缀操作 $j$ 次，则前缀操作对这部分的影响就是减去 $k-j$。

那么就能计算最多能清空多少前缀，以及前缀操作 $k-j$ 次最多能清空多少后缀。

设为 $pl_j,pr_{k-j}$，以及清空后缀后剩余的操作次数 $cl_j,cr_{k-j}$。

如果 $pl_j\ge pr_{k-j}$，那么已经合法，如果 $pl_j+2=pr_{k-j}$，则判断 $a_{pl_j+1}$ 是否 $\ge k+c(cl_j+cr_k)$。

考虑如何维护 $pl_j,cl_j$，求 $pr,cr$ 只需翻转序列。

设 $f_{i,j}$ 表示给所有 $a$ 减去 $j$ 之后清空 $a[1,i]$ 至少几次操作（算上初始 $j$ 次）。

很显然决策就是从前到后操作，转移为 $f_{i,j}=f_{i-1,j}+\left\lceil\dfrac{\max(0,a_i-f_{i-1,j})}{c+1}\right\rceil$。

首先很显然 $f_{i,j-1}+1\ge f_{i,j}\ge f_{i,j-1}$，因为一个在 $a_1$ 的后缀操作比一个全局 $-1$ 更强。

那么我们只要维护差分数组为 $1$ 的位置：$S_i=\{k\mid f_{i,j}>f{i,j-1}\}$，维护 $S_{i-1}\to S_i$。

那么转移时找到 $f_{i-1,j}=a_i$ 且 $f_{i-1,j-1}=a_{i-1}$ 的位置，转移后有 $f_{i,j}=f_{i,j-1}=a_i$。

进一步首个值为 $a_i-(c+1),a_i-2(c+1)$ 的元素都会从 $S_i$ 中删除，其他元素不变。

观察原序列，实际上就是对于这些被删除的位置 $j$，给 $f[1,j-1]$ 区间 $+1$。

可以用树状数组维护差分，二分找到被删除的元素。

然后考虑如何计算 $pl_j,cl_j$，动态维护最大的 $p$ 使得 $f_{i,p}\le k$，很显然 $p$ 是递减的，每次弹出 $p$ 时就能计算 $pl_p,cl_p$。

时间复杂度 $\mathcal O((n+m)\log^2m)$，瓶颈在于每次二分时树状数组维护被删除的元素。

注意到 dp 过程不受二分的 $k$ 影响，只有 $f\to pl,cl$ 的过程和 $k$ 有关，那么提前处理 dp 时 $f$ 的变化即可。

时间复杂度 $\mathcal O((n+m)\log m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
int n,m,c,a[MAXN];
struct BIT {
	int tr[MAXN],z;
	void init() { z=0; for(int i=1;i<=m;++i) tr[i]=i&-i; }
	int qry(int k) {
		int x=0;
		for(int i=18;~i;--i) if(x+(1<<i)<=m&&tr[x+(1<<i)]<k) k-=tr[x+=1<<i];
		return x+1;
	}
	int del(int k) {
		int x=qry(k-z); ++z;
		for(int i=x;i<=m;i+=i&-i) --tr[i];
		return x;
	}
}	T;
vector <int> dp[2][MAXN];
void init(int o) {
	T.init();
	for(int i=1;i<=n;++i) {
		dp[o][i].clear();
		for(int x=a[i];T.z<x;x-=c) dp[o][i].push_back(T.del(x));
	}
}
struct ds {
	int f[MAXN],v,p;
	void init(int k) { fill(f,f+k+1,-1),v=p=k; }
	void upd(int x) { p<x?++v:++f[x-1]; }
	void del() { v+=f[--p]; }
}	pre,cur;
int f[2][MAXN],g[2][MAXN];
void gen(int k,int o) {
	for(int i=0;i<=k;++i) f[o][i]=n+1,g[o][i]=0;
	pre.init(k),cur.init(k);
	for(int i=1,j=k;i<=n;++i) {
		for(int x:dp[o][i]) cur.upd(x);
		while(cur.v>k) {
			f[o][j]=i,g[o][j]=k-pre.v;
			if(!j) return ;
			--j,pre.del(),cur.del();
		}
		for(int x:dp[o][i]) pre.upd(x);
	}
}
bool chk(int k) {
	for(int o:{0,1}) gen(k,o),reverse(a+1,a+n+1);
	for(int i=0;i<=k;++i) {
		int w=f[0][i]+f[1][k-i];
		if(w>n+1||(w==n+1&&1ll*c*(g[0][i]+g[1][k-i])+k>=a[f[0][i]])) return true;
	}
	return false;
}
void solve() {
	cin>>n>>m>>c;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int o:{0,1}) init(o),reverse(a+1,a+n+1);
	int l=0,r=m-1,z=m;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(chk(mid)) z=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<z<<"\n";
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int _,ty; cin>>_>>ty;
	while(_--) solve();
	return 0;
}
```

---


# [集训队互测 2024] 字符串

## 题目描述

给定一个长度为 $n$ 的字符串 $s[1: n]$。有 $q$ 次询问，每次询问给定两个参数 $i, r$。你需要求出有多少 $l$，满足如下条件:

- $1 \leq l \leq r$。
- $s[i: i+l-1]$ 字典序小于 $s[i+l: i+2l-1]$ 。

## 说明/提示

### 数据范围

对于所有数据，$1 \le n,q\le 5\times 10^5$，$1 \le i + 2r - 1 \le n $，字符串 $s$ 仅包含小写字母。

子任务 1（20%）：$n,q\le 5\times 10^3$ 。

子任务 2（10%）：$n,q\le 10^5$ ，保证 $s$ 中每个字符在 a,b 中随机生成。

子任务 3（20%）：$n,q\le 10^5$ 。

子任务 4（20%）：$n,q\le 3\times 10^5$ 。

子任务 5（30%）：无特殊限制。

## 样例 #1

### 输入

```
0
9 3
abacababa
1 4
2 4
3 3```

### 输出

```
3
1
2```

# 题解

## 作者：lzyqwq (赞：1)

竞选最劣做法。

> - 给出长度为 $n$ 的字符串 $s$，$q$ 次询问 $i,r$，求：
>    $$\sum\limits_{j=1}^r[s[i,i+j-1]<s[i+j,i+2j-1]]$$
> - $n,q\le 5\times 10^5$，$i+2r-1\le n$。

第一步居然没想到。考虑对 $s$ 后缀排序。那么对于一个合法的 $s[i+j,i+2j-1]$，一定有 $s[i,n]<s[i+j,n]$。那么考虑枚举 $s[i+j,n]$ 这个后缀，求：

$$\sum\limits_{k=\text{rk}_i+1}^n[\text{sa}_k\in [i+1,i+r]\land s[i,\text{sa}_k-1]<s[\text{sa}_k,2\text{sa}_k-i-1]]$$

由于已经满足 $k>\text{rk}_i$，那么如果 $|\text{LCP}(s[i,n],s[\text{sa}_k,n])|<\text{sa}_k-i$，那么两个后缀第一个失配位置在 $s[i,\text{sa}_k-1]$ 和 $s[\text{sa}_k,2\text{sa}_k-i-1]$ 内，而且这个失配位置就是两个串的第一个失配位置。根据后缀的大小关系可以得出失配位置的大小关系是前者小于后者，从而得到 $s[i,\text{sa}_k-1]<s[\text{sa}_k,2\text{sa}_k-i-1]$。同理，若 $|\text{LCP}(s[i,n],s[\text{sa}_k,n])|\ge \text{sa}_k-i$，会导致两个后缀的最长公共前缀覆盖这两个串，从而导致两个串相等。

因此可以改写第二个条件，即求：

$$\sum\limits_{k=\text{rk}_i+1}^n[\text{sa}_k\in [i+1,i+r]\land |\text{LCP}(s[i,n],s[\text{sa}_k,n])|<\text{sa}_k-i]$$

接下来进入纯 ds 部分，也是经典老番之《两只老哥跑得快，序列分治真可爱.jpg》。

考虑用 $\text{height}$ 数组（下简称为 $h$）转化 $|\text{LCP}|$ 的限制，令 $I=\text{rk}_i$，把询问挂在 $I$ 上，那么我们要求满足如下限制的 $k$ 个数：

- $k>I$。
- $\text{sa}_k\in [\text{sa}_I+1,\text{sa}_I+r]$。
- $\min\limits_{t=I+1}^kh_t<\text{sa}_k-\text{sa}_I$。

看上去像个三维偏序。于是用分治处理 $k>I$，设当前分治区间为 $[L,R]$，中点 $m=\left\lfloor\dfrac{L+R}{2}\right\rfloor$。考虑右半边对左半边的贡献。

从 $m$ 到 $L$ 扫描 $I$，维护 $\text{mn}=\min\limits_{t=I+1}^mh_t$。对于右半区间，维护 $f_k=\min\limits_{t=m+1}^kh_t$，那么第三个限制被转化为：

$$\min\{\text{mn},f_k\}<\text{sa}_k-\text{sa}_I$$

由于 $f_k$ 不升，一定存在分界点 $p$，使得 $k\in [m+1,p-1]$ 时 $\text{mn}\le f_k$；$k\in [p,R]$ 时 $\text{mn}> f_k$。考虑分别计算两类贡献。

第一类贡献中第三个限制为 $\text{mn}<\text{sa}_k-\text{sa}_I$，那么变成求满足以下条件的 $k$ 个数：

- $k\in [m+1,p-1]$。
- $\text{sa}_k\in [\text{sa}_I+\text{mn}+1,\text{sa}_I+r]$。

容易二维数点解决。考虑类似地拆第二类贡献，即要求满足以下条件的 $k$ 的个数：

- $k\in [p,R]$。
- $\text{sa}_k\in[\text{sa}_I+1,\text{sa}_I+R]$。
- $f_k<\text{sa}_k-\text{sa}_I$。

但是你发现这时候出现三维偏序，肯定不能直接做。考虑拆成两部分，即用满足 $\begin{cases}\text{mn}<\text{sa}_k-\text{sa}_I\\k\in [p,R]\\\text{sa}_k\in [\text{sa}_I+1,\text{sa}_I+R]\end{cases}$ 的 $k$ 的个数加上 $\begin{cases}f_k<\text{sa}_k-\text{sa}_I\le \text{mn}\\k\in [p,R]\\\text{sa}_k\in [\text{sa}_I+1,\text{sa}_I+R]\end{cases}$ 的 $k$ 的个数。

前者可以与第一类贡献合并变成 $[m+1,R]$ 内 $\text{sa}_k\in [\text{sa}_I+\text{mn}+1,\text{sa}_I+r]$ 的 $k$ 个数，容易用一个全局 BIT 维护。至于后者，我们发现第一条限制已经满足 $f_k<\text{mn}$ 即 $k\in [p,R]$，所以直接忽略第二个限制。那么问题变成关于 $\text{sa}_k-f_k$ 和 $\text{sa}_k$ 的二维数点。扫描线 + BIT 维护即可。

认为 $n,q$ 同阶，时间复杂度 $\mathcal{O}\left(n\log^2 n\right)$，空间复杂度 $\mathcal{O}(n)$。~~优点是空间线性。~~

类似套路题目：

![](https://cdn.luogu.com.cn/upload/image_hosting/ppsdoic3.png?x-oss-process=image/resize,m_lfit,h_2170,w_2225)

代码很好写：


```cpp
#include <bits/stdc++.h>
using namespace std; const int N = 500005; char s[N];
int c, n, q, a[N], f[N]; vector<pair<int, int>> g[N];
struct QR { int l, r, i; } d[N]; pair<int, int> e[N];
struct SA {
	int sa[N], rk[N], h[N], c[N], y[N];
	void B() {
		for (int i = 1; i <= n; ++i) ++c[s[i]];
		for (int i = 1; i < N; ++i) c[i] += c[i - 1];
		for (int i = 1; i <= n; ++i) sa[c[s[i]]--] = i;
		for (int i = 2, t = rk[sa[1]] = 1; i <= n; ++i)
			rk[sa[i]] = (s[sa[i]] == s[sa[i - 1]] ? t : ++t);
		for (int w = 1, t; w <= n; w <<= 1) {
			t = 0; for (int i = n - w + 1; i <= n; ++i) y[++t] = i;
			for (int i = 1; i <= n; ++i) if (sa[i] > w) y[++t] = sa[i] - w;
			memset(c, 0, sizeof c); for (int i = 1; i <= n; ++i) ++c[rk[i]];
			for (int i = 1; i <= n; ++i) c[i] += c[i - 1];
			for (int i = n; i >= 1; --i) sa[c[rk[y[i]]]--] = y[i];
			swap(rk, y); t = rk[sa[1]] = 1;
			for (int i = 2; i <= n; ++i)
				rk[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &&
				             y[sa[i] + w] == y[sa[i - 1] + w] ? t : ++t);
			if (t == n) break;
		}
		for (int i = 1, k = 0; i <= n; ++i) {
			if (i == sa[1]) { k = 0; continue; } if (k) --k;
			while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; h[rk[i]] = k;
		}
	}
} S;
struct BIT1 {
	int a[N]; void U(int x, int y) { for (; x <= n; x += x & -x) a[x] += y; }
	int Q(int x) { int r = 0; for (; x; x -= x & -x) r += a[x]; return r; }
	int Q(int l, int r) { return l > r ? 0 : Q(r) - Q(l - 1); }
} t;
void F(int l, int r) {
	if (l == r) return; int m = l + r >> 1, c = 0, b = 0; f[m] = N;
	for (int i = m + 1; i <= r; ++i)
		f[i] = min(f[i - 1], S.h[i]), t.U(S.sa[i], 1),
		e[++b] = {S.sa[i] - f[i], S.sa[i]};
	for (int i = m, mn = N; i >= l; --i) {
		for (auto [j, x] : g[S.sa[i]])
			a[j] += t.Q(S.sa[i] + mn + 1, S.sa[i] + x),
			d[++c] = {S.sa[i] + 1, S.sa[i] + min(x, mn), j};
		mn = min(mn, S.h[i]);
	}
	for (int i = m + 1; i <= r; ++i) t.U(S.sa[i], -1);
	stable_sort(d + 1, d + c + 1, [&](QR u, QR v) { return u.l > v.l; });
	stable_sort(e + 1, e + b + 1, greater<pair<int, int>>());
	for (int i = 1, j = 1; i <= c; ++i) {
		for (; j <= b && e[j].first >= d[i].l; ++j) t.U(e[j].second, 1);
		a[d[i].i] += t.Q(d[i].l, d[i].r);
		if (i == c) for (--j; j; --j) t.U(e[j].second, -1);
	}
	F(l, m); F(m + 1, r);
}
int main() {
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cin >> c >> n >> q;
	for (int i = 1; i <= n; ++i) cin >> s[i]; S.B();
	for (int i = 1, j, r; i <= q; ++i) cin >> j >> r, g[j].emplace_back(i, r);
	F(1, n); for (int i = 1; i <= q; ++i) cout << a[i] << '\n'; return 0;
}
```

---

## 作者：L_zaa_L (赞：1)

算了一下 $O(n\log^2 n)$ 的复杂度好像能过，然后又不会 Runs，就打了这个。

有点像[P9482](https://www.luogu.com.cn/problem/P9482)和[P1117](https://www.luogu.com.cn/problem/P1117)的结合体，我们仿照 P9482 的思路，按字典序从大到小地加入后缀，这样就可以得到答案加上一些 $S[i,i+l-1]=S[i+l,i+2\times l-1]$ 的，然后考虑减去这些不对的。我们需要找到这个字符串里面的形似 $AA$ 子串，这正好是 P1117 的东西，我们枚举 $A$ 的长度 $len$，然后能得到 $\lceil \frac{n}{len}\rceil$ 个关键点，然后判断相邻两个关键点的最长公共前缀和后缀，就可以得到一个 $AA$ 串开始的一段区间，然后用树状数组区间加就是 $O(n\log^2 n)$ 了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls(x) ((x)*2)
#define rs(x) ((x)*2+1)
#define pii pair<int,int>
#define fi first
#define se second
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=1e6+5,base=999983,Mod=998244353;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
inline void Add(int &x,int y){(x=x+y+Mod)%=Mod;}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
void print(int n){
    if(n<0){
        putchar('-');
        n*=-1;
    }
    if(n>9) print(n/10);
    putchar(n%10+'0');
}
int n,m,q;
int lg[N];
struct SuffixArray {
	char s[N];
	int rak[N],tp[N],tag[N],sa[N];
	int height[N];
	int minsum[N][21];
	inline void SA(){
		m=250;
	    for(register int i=0;i<=m;++i) tag[i]=0;
		for(register int i=1;i<=n;++i) rak[i]=(int)s[i];
		int p=0;
		for(register int i=1;i<=n;++i)++tag[rak[i]];
		for(register int i=1;i<=m;++i) tag[i]+=tag[i-1];
		for(register int i=n;i>=1;--i) sa[tag[rak[i]]--]=i;
		for(register int k=1;k<=n;k<<=1){
			p=0;
	        for(register int i=0;i<=m;++i) tag[i]=tp[i]=0;
			for(register int i=n-k+1;i<=n;++i) tp[++p]=i;
			for(register int i=1;i<=n;++i)
				if(sa[i]>k)
					tp[++p]=sa[i]-k;
			for(register int i=1;i<=m;++i) tag[i]=0;
			for(register int i=1;i<=n;++i)tag[rak[i]]++;
			for(register int i=1;i<=m;++i) tag[i]+=tag[i-1];
			for(register int i=n;i>=1;--i) sa[tag[rak[tp[i]]]--]=tp[i],tp[i]=0;
			swap(rak,tp);
			rak[sa[1]]=1;
			p=1;
			for(register int i=2;i<=n;++i)
				rak[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+k]==tp[sa[i]+k])?p:++p;
			m=p;
		}
	}
	inline void GetHeight(){
		int k=0;
	    for(register int i=1;i<=n;++i) {
	        if(k) k--;
	        while(s[i+k]==s[sa[rak[i]-1]+k]) ++k;
	        height[rak[i]]=k;
	    }
	}
	inline void RMQ(int num){ 
		for(register int i=1;i<=n;i++) minsum[i][0]=height[i]; 
	    for(register int j=1;j<20;++j)
	        for(register int i=1;i<=num&&i+(1<<j)-1<=num;++i){ 
	                minsum[i][j]=min(minsum[i][j-1], minsum[i+(1<<(j-1))][j-1]);
	            }
	}
    inline int rmq(int l,int r){
        int x=rak[l],y=rak[r];
		if(x>y) swap(x,y);
		x++;
		int k=lg[y-x+1];
		return min(minsum[x][k],minsum[y-(1<<k)+1][k]);
    }    
}A,B;
char s[N];
int tr[N],ans[N];
vector<pair<int,int> > g[N],e[N];
vector<int>pr[N];
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int k){while(x<=n){tr[x]+=k;x+=lowbit(x);}}
inline int query(int x){int res=0;while(x){res+=tr[x];x-=lowbit(x);}return res;}
inline void solve(){
	n=read(),q=read();
	scanf("%s",s+1);
	For(i,1,n) A.s[i]=s[i];
	For(i,1,n) B.s[n-i+1]=s[i];
	A.SA();A.GetHeight();A.RMQ(n);
	B.SA();B.GetHeight();B.RMQ(n);
	For(i,1,q)ans[i]=0;
	For(i,1,q){
		int x=read(),y=read();
		g[x].emplace_back(y,i);
		e[y].emplace_back(x,i);
	}
	Rof(i,n,1){
		for(auto E:g[A.sa[i]]){
			ans[E.se]+=query(A.sa[i]+E.fi)-query(A.sa[i]);
		}add(A.sa[i],1);
	}For(i,1,n) tr[i]=0;
	For(i,1,n){
		for(int j=i;j+i<=n;j+=i){
			int lcp,lcs;
			lcp=A.rmq(j,j+i),lcs=B.rmq(n-j+1,n-j-i+1);
			lcs=min(lcs,i);lcp=min(lcp,i); 
			int len=lcp+lcs-i;
			if(lcp+lcs-1>=i){
				if(A.rak[j-lcs+1]>=A.rak[j-lcs+1+i]){
					continue;
				} 
				add(j-lcs+1,1);
				add(j-lcs+len+1,-1);
			}
		}
		for(auto E:e[i]){
			ans[E.se]-=query(E.fi);
		}
	}
	For(i,1,q) printf("%lld\n",ans[i]);
}
signed main(){
	lg[0]=-1;
	For(i,1,N-5) lg[i]=lg[i/2]+1;
	//_base=(_base<<64)/Mod;
//	freopen("ex_string1.in","r",stdin);
	//freopen(".out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	int c=read(),T=1;
	while(T--){solve();}
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P12490)

**题目大意**

> 给定一个长度为 $n$ 的字符串 $s$。有 $q$ 次询问，每次询问给定两个参数 $x,v$。你需要求出有多少 $k\in[1,v]$，满足 $s[x,x+k-1]$ 字典序小于 $s[x+k,x+2k-1]$ 。
>
> 数据范围：$n,q\le 5\times 10^5$。

**思路分析**

首先 $(x,k)$ 合法要求 $rk_x<rk_{x+k}$ 且 $s[x,x+k-1]\ne s[x+k,x+2k-1]$。

那么先二维数点计算满足第一个条件的 $k$ 个数，然后减掉 $rk_x<rk_{x+k}$ 的平方串 $(x,k)$ 个数。

根据经典技巧，我们可以把平方串写成 $\mathcal O(n\log n)$ 个 $x$ 的区间 $[l,r]$。

但我们不太好对于所有 $x\in[l,r]$ 都计算 $rk_x,rk_{x+k}$ 的大小关系。

注意到 $s_l=s_{l+1}$，因此 $x=l,x=l+1$ 的大小关系相等，进一步所有 $x$ 的大小关系都相等。

只要统计 $rk_r<rk_{r+k}$ 的区间有多少满足 $k\le v,x\in [l,r]$，容易二维数点。

时间复杂度 $\mathcal O(n\log^2n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
struct SA {
	char str[MAXN];
	int n,sa[MAXN],rk[MAXN],ct[MAXN],t[MAXN],f[MAXN][20];
	int bit(int x) { return 1<<x; }
	void build() {
		int m=26;
		for(int i=1;i<=n;++i) rk[i]=str[i]-'a'+1,++ct[rk[i]];
		for(int i=1;i<=m;++i) ct[i]+=ct[i-1];
		for(int i=n;i;--i) sa[ct[rk[i]]--]=i;
		for(int k=1;;k<<=1) {
			for(int i=1;i<=k;++i) t[i]=n-k+i;
			for(int i=1,h=k;i<=n;++i) if(sa[i]>k) t[++h]=sa[i]-k;
			memset(ct,0,sizeof(ct));
			for(int i=1;i<=n;++i) ++ct[rk[i]];
			for(int i=1;i<=m;++i) ct[i]+=ct[i-1];
			for(int i=n;i;--i) sa[ct[rk[t[i]]]--]=t[i];
			memcpy(t,rk,sizeof(t)),m=0;
			for(int i=1;i<=n;++i) {
				rk[sa[i]]=m+=(i==1||t[sa[i]]!=t[sa[i-1]]||t[min(n+1,sa[i]+k)]!=t[min(n+1,sa[i-1]+k)]);
			}
			if(m==n) break;
		}
		for(int i=1,k=0;i<=n;++i) {
			for(k=max(0,k-1);str[i+k]==str[sa[rk[i]-1]+k];++k);
			f[rk[i]][0]=k;
		}
		for(int k=1;k<20;++k) for(int i=1;i+bit(k)-1<=n;++i) {
			f[i][k]=min(f[i][k-1],f[i+bit(k-1)][k-1]);
		}
	}
	int qry(int x,int y) {
		if(x==y) return n-x+1;
		int l=min(rk[x],rk[y])+1,r=max(rk[x],rk[y]),k=__lg(r-l+1);
		return min(f[l][k],f[r-bit(k)+1][k]);
	}
}	lcp,lcs;
int ty,n,q,ans[MAXN];
char str[MAXN];
vector <array<int,2>> sg[MAXN],qy1[MAXN],qy2[MAXN];
struct BIT {
	int tr[MAXN],s;
	void init() { memset(tr,0,sizeof(tr)); }
	void add(int x,int v) { for(;x<=n;x+=x&-x) tr[x]+=v; }
	int qry(int x) { for(s=0;x;x&=x-1) s=s+tr[x]; return s; }
}	T;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>ty>>n>>q>>(str+1),lcp.n=lcs.n=n;
	for(int i=1;i<=n;++i) lcp.str[i]=lcs.str[n-i+1]=str[i];
	lcp.build(),lcs.build();
	for(int k=1;k<=n/2;++k) for(int i=k;i+k<=n;i+=k) if(str[i]==str[i+k]) {
		int dl=lcs.qry(n-i+1,n-i-k+1),dr=lcp.qry(i,i+k);
		int l=max(i-k+1,i-dl+1),r=min(i,i+dr-k);
		if(l<=r&&lcp.rk[l]<lcp.rk[l+k]) {
			sg[k].push_back({l,r});
		}
	}
	for(int i=1,x,v;i<=q;++i) {
		cin>>x>>v;
		qy1[x].push_back({lcp.rk[x],-i});
		qy1[x+v].push_back({lcp.rk[x],i});
		qy2[v].push_back({x,i});
	}
	for(int i=1;i<=n;++i) {
		T.add(lcp.rk[i],1);
		for(auto o:qy1[i]) {
			if(o[1]>0) ans[o[1]]+=i-T.qry(o[0]);
			else ans[-o[1]]-=i-T.qry(o[0]);
		}
	}
	T.init();
	for(int i=1;i<=n;++i) {
		for(auto o:sg[i]) T.add(o[0],1),T.add(o[1]+1,-1);
		for(auto o:qy2[i]) ans[o[1]]-=T.qry(o[0]);
	}
	for(int i=1;i<=q;++i) cout<<ans[i]<<"\n";
	return 0;
}
```

---


# [集训队互测 2024] 子集和

## 题目描述

有 $n$ 个物品，物品 $i$ 有两个属性 $a_i,b_i$。对于一个物品集合 $S$，定义 $f(S)$ 是如下问题的答案：

> 对于每个物品 $i\in S$，选择 $0,a_i,b_i$ 三个数中的一个，使得所有物品选择的数之和是 $m$ 的倍数的方案数。

定义物品集合 $S=\{1,2,\dots,n\}$。有 $q$ 次询问，每次给定四个正整数 $1\le l_1\le r_1<l_2\le r_2\le n$，求：

$$
\sum_{l_1\le i\le r_1} \sum_{l_2\le j\le r_2} f(S\setminus \{i,j\}).
$$

答案对 $10^9+7$ 取模。

## 说明/提示

### 数据范围

对于所有数据：

- $1\le n\le 10^4$
- $2\le m\le 200$
- $1\le q\le 10^6$
- $0\le a_i,b_i<m\ (1\le i\le n)$

| 子任务 | $n\le$ | $m\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $100$ | —  | AB | $5$ |
| $2$ | $500$ | —  | AB | $5$ |
| $3$ | — | $20$ | AB | $20$ |
| $4$ | — | $150$ | A | $15$ |
| $5$ | — | — | B | $15$ |
| $6$ | — | — | C | $10$ |
| $7$ | — | — | $l_1=r_1,l_2=r_2$ | $5$ |
| $8$ | — | — | — | $25$ |

特殊性质 A：每次询问都在所有满足条件的 $(l_1,r_1,l_2,r_2)$ 中随机选择。

特殊性质 B：$q\le 10^5$。

特殊性质 C：对于每个物品 $i$，$a_i=b_i$。

## 样例 #1

### 输入

```
6 10 5
2 3
7 1
1 4
8 1
2 5
8 9
1 2 3 4
1 1 2 2
1 1 5 5
1 3 4 6
1 5 6 6```

### 输出

```
33
9
11
80
37```

# 题解

## 作者：nullqtr_pwp (赞：2)

考虑把背包看成一个黑盒：支持 $\mathcal O(m)$ 插入物品，以及给出两个背包 $A,B$，以 $\mathcal O(m^2)$ 进行完全的合并，$\mathcal O(m)$ 对位相加信息，$\mathcal O(m)$ 查询合并后的一个点值，以及存储并回退。完全的背包合并因为 $m^2$ 所以不能使用。因为模 $m$ 意义，所以**不能删除**已有物品。

如果只需要处理所有 $f(S-\{i\})$，可以进行分治，每次递归时已经加入 $[1,l-1]\cup [r+1,n]$ 的物品即可，时间复杂度 $\mathcal O(nm\log n)$。还有一个问题是总对数是 $n^2$ 的，但是我们只需要求一个矩形区域的和，这个其实可以对背包数组对位相加然后整体维护，这样避免了合并。

考虑 $l_1=r_1,l_2=r_2$，查询单组 $(x,y)$ 值的做法：此时对 $(x,y)$ 进行猫树分治离线，挂到对应的 $[l,r]$ 上，维护 $[1,l-1]$ 的背包 $F$，$[r+1,n]$ 的背包 $G$，两侧分别做一次缺一分治，以 $F/G$ 为基础求出 $[1,mid]-\{i\}$ 以及 $[mid+1,n]-\{i\}$ 的背包信息，左右侧合并只需要查询合并后 $0$ 的点值，复杂度是 $\mathcal O(mn\log^2n+qm)$。

拓展这个猫树分治做法，将所有询问套路化的差分为 $\mathcal O(1)$ 对 $(x,y)$ 询问 $[1,x],[y,n]$ 的答案，保证 $x<y$。这时变成了**求和**。依然将其分为 $\leq mid,>mid$ 的物品，这时会涉及 $[1,l-1],[l,x]$ 以及 $[y,r],[r+1,n]$。那么贡献分为 $2\times 2=4$ 对，分类讨论一下：

- $x'\in[1,l-1],y'\in[r+1,n]$：处理出 $[1,l-1]$ 内所有 $i\in[1,l-1]$ 的 $f([1,l-1]-\{i\})$ 之和，令这个是 $g_{l-1}$，那么从 $g_t\to g_{t+1}$ 时只需要插入 $t+1$ 以及对 $[1,t]$ 的背包信息求对位和。对于后缀同理。这样求出 $pre_{l-1},suf_{r+1}$，整体分别加入 $[l,mid],[mid+1,r]$ 的所有物品，得到 $pre',suf'$ 的对位和，这时求一下 $pre'\times suf'$ 的常数项即可。
- $x'\in[1,l-1],y'\in[y,r]$（对于 $x'\in[l,x],y'\in[r+1,n]$ 同理）：分治求出 $[1,mid],[mid+1,r]$ 分别针对每个 $[l,mid],[mid+1,r]$ 的缺一信息，求前后缀和 $f,g$，与 $pre',suf'$ 分别求一下 $L\times R$ 的常数项即可。
- $x'\in[l,x],y'\in[y,r]$：针对 $f_x,g_y$ 做合并即可。

事实上并不需要拆成 $4$ 个，只需要 $f_x,g_y$ 分别与 $[1,l-1],[r+1,n]$ 预先合并即可。

综上，我们可以使用 $\mathcal O(n\log^2n)$ 次背包的基本操作就解决本题。时间复杂度 $\mathcal O(mn\log^2n+qm)$。本题的精髓在于对背包的对位加以实现求整体信息，以及分治算法的运用。其实可以理解成多项式的 $(\times,+)$ 运算，然后把分配律倒过来将他合并了。

``` cpp
int ans[QR],n,m,zsy,a[maxn],b[maxn];
#define poly vector<int>
poly mrg(poly x,poly y){
	poly res(m);
	F(i,0,m-1)res[i]=add(x[i],y[i]);
	return res;
}
poly ins(poly x,int pos){
	poly res=x;
	F(i,0,m-1)inc(res[i+a[pos]>=m?i+a[pos]-m:i+a[pos]],x[i]);
	F(i,0,m-1)inc(res[i+b[pos]>=m?i+b[pos]-m:i+b[pos]],x[i]);
	return res;
}
void init(poly &x){
	x.resize(m);
	F(i,0,m-1)x[i]=(i==0);
}
void init1(poly &x){
	x.resize(m);
	for(int &i:x)i=0;
}
int qry(poly &x,poly &y){
	int ans=0;
	F(i,0,m-1)inc(ans,1ll*x[i]*y[i==0?0:m-i]%mod);
	return ans;
}
vector<array<int,4>>qu[maxn<<2];
void ins_query(int o,int l,int r,int ql,int qr,int coef,int id){
	if(ql>qr||ql<1||qr>n)return;
	const int mid=(l+r)>>1;
	if(ql<=mid&&mid<qr)return qu[o].push_back({ql,qr,coef,id}),void();
	if(qr<=mid)ins_query(o<<1,l,mid,ql,qr,coef,id);
	if(ql>mid)ins_query(o<<1|1,mid+1,r,ql,qr,coef,id);
}
poly pre[maxn],suf[maxn],psum[maxn],ssum[maxn],f[maxn],dp[maxn];
void dfs(int o,int l,int r){
	if(l==r)return;
	const int mid=(l+r)>>1;
	dfs(o<<1,l,mid),dfs(o<<1|1,mid+1,r);
	if(qu[o].empty())return;
	poly F;
	auto sol=[&](auto &self,int L,int R){
		if(L==R)return f[L]=F,void();
		int mid=(L+R)>>1;
		poly tmp=F;
		F(i,L,mid)F=ins(F,i);
		self(self,mid+1,R);
		F=tmp;
		F(i,mid+1,R)F=ins(F,i);
		self(self,L,mid);
	};
	F=psum[l-1],sol(sol,l,mid);
	F=ssum[r+1],sol(sol,mid+1,r);
	poly lef=pre[l-1],rig=suf[r+1];
	F(i,l,mid)lef=ins(lef,i);
	F(i,mid+1,r)rig=ins(rig,i);
	dp[l-1]=lef,dp[r+1]=rig;
	F(i,l,mid)dp[i]=mrg(dp[i-1],f[i]);
	dF(i,r,mid+1)dp[i]=mrg(dp[i+1],f[i]);
	for(auto&[ql,qr,coef,id]:qu[o]){
		int val=qry(dp[ql],dp[qr]);
		if(coef<0)dec(ans[id],val);
		else inc(ans[id],val);
	}
}
void solve(){
	cin>>n>>m>>zsy;
	F(i,1,n)cin>>a[i]>>b[i];
	init(psum[0]),init(ssum[n+1]);
	F(i,1,n)psum[i]=ins(psum[i-1],i);
	dF(i,n,1)ssum[i]=ins(ssum[i+1],i);
	init1(pre[0]),init1(suf[n+1]);
	F(i,1,n)pre[i]=mrg(ins(pre[i-1],i),psum[i-1]);
	dF(i,n,1)suf[i]=mrg(ins(suf[i+1],i),ssum[i+1]);
	F(i,1,zsy){
		int l1,r1,l2,r2;cin>>l1>>r1>>l2>>r2;
		ins_query(1,1,n,r1,l2,1,i);
		ins_query(1,1,n,r1,r2+1,-1,i);
		ins_query(1,1,n,l1-1,l2,-1,i);
		ins_query(1,1,n,l1-1,r2+1,1,i);
	}
	dfs(1,1,n);
	F(i,1,zsy)cout<<ans[i]<<'\n';
}
```

---

## 作者：qczrz6v4nhp6u (赞：1)

感觉会了 $l_1=r_1,l_2=r_2$ 就会正解了啊，为什么只放了 $5$ 分？？？

## Solution

本文中的关于 $x$ 的多项式运算均定义在 ${}\bmod (x^m-1)$ 意义下，关于 $y$ 的多项式运算均定义在 ${}\bmod y^2$ 下。为方便定义 $F(S)=\prod_{i\in S}(1+x^{a_i}+x^{b_i})$。

观察一下本题中的背包运算有哪些性质：首先由于运算定义在 ${}\bmod (x^m-1)$ 意义下，一个多项式不一定存在逆元，也就不能删除；合并是 $O(m^2)$ 的，还不能（至少不容易）插值优化，大概是没救了；但加入、查两个多项式合并的单点系数、对位加均是 $O(m)$ 的。考虑以 $O(m)$ 的操作为切入点设计算法。

不妨先考虑 $l_1=r_1,l_2=r_2$ 的部分。既然无法删除，一个思考方向就是分治。设分治区间 $[l,r)$ 与其分治子区间 $[l,m),[m,r)$ 满足 $r_1\in[l,m),l_2\in[m,r)$。维护两个东西：

- $U_{l,r,i}(x)=F\big([1,r)\setminus\{i\}\big)$（$i\in[l,r)$）；
- $V_{l,r,i}(x)=F\big([l,n]\setminus\{i\}\big)$（$i\in[l,r)$）。

那么我们要算的就是 $[x^0]U_{l,m,r_1}(x)\times V_{m,r,l_2}(x)$。由于只用算单项系数所以是 $O(m)$ 的，且 $U_{l,m,r_1},V_{m,r,l_2}$ 可以分别对 $[l,m),[m,r)$ 做一次缺一分治算出来，所以这部分可以做到 $O(nm\log^2 n+qm)$。

然后考虑拓展到没有限制的情况。注意到信息是可差分的，我们将 $[l_1,r_1]$ 差分为 $[1,r_1]-[1,l_1)$，$[l_2,r_2]$ 差分为 $[l_2,n]-(r_2,n]$，这样就转化为了一个 $l_1=1,r_2=n$ 的问题。考虑增设一元 $y$ 描述当前不选的（这里的不选指题面中在 $S$ 中去除）已经有多少个，再记 $G(S)=\prod_{i\in S}(y+1+x^{a_i}+x^{b_i})$，维护：

- $P_{l,r,i}(x,y)=G\big([1,i]\big)F\big((i,r)\big)$（$i\in[l,r)$）；
- $Q_{l,r,i}(x,y)=F\big([l,i)\big)G\big([i,n]\big)$（$i\in[l,r)$）。

那么最终答案即为 $[x^0]\Big([y^1]P_{l,m,r_1}(x,y)\Big)\times\Big([y^1]Q_{m,r,l_2}(x,y)\Big)$。不难发现刚刚的算法仍然成立，于是本题就做完了，复杂度 $O(nm\log^2 n+qm)$。

## Code

一个比较不精细的实现。

```cpp
bool Mst;
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=1e4+5,QN=1e6+5,mod=1e9+7;
inline ll add(ll x,ll y){return (x+=y)>=mod&&(x-=mod),x;}
inline ll Add(ll &x,ll y){return x=add(x,y);}
inline ll sub(ll x,ll y){return (x-=y)<0&&(x+=mod),x;}
inline ll Sub(ll &x,ll y){return x=sub(x,y);}
inline ll qpow(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
int n,m,q,a[N],b[N];ll ans[QN];
using poly=vector<ll>;
inline int madd(int x,int y){return (x+=y)>=m&&(x-=m),x;}
inline int mAdd(int &x,int y){return x=madd(x,y);}
inline int msub(int x,int y){return (x-=y)<0&&(x+=m),x;}
inline int mSub(int &x,int y){return x=msub(x,y);}
inline poly operator +(const poly &f,const poly &g){
	static poly h;h.resize(m);
	for(int i=0;i<m;i++)h[i]=add(f[i],g[i]);
	return h;
}
inline poly ins(const poly &f,int x){
	static poly h;h=f;
	for(int i=0;i<m;i++)Add(h[madd(i,a[x])],f[i]);
	for(int i=0;i<m;i++)Add(h[madd(i,b[x])],f[i]);
	return h;
}
inline ll qry(const poly &f,const poly &g){
	ll res=0;
	for(int i=0;i<m;i++)Add(res,f[i]*g[msub(0,i)]%mod);
	return res;
}
struct Poly{
	poly p0,p1;
	Poly(){}
	Poly(const poly &_p0,const poly &_p1){p0=_p0,p1=_p1;}
};
inline Poly operator +(const Poly &f,const Poly &g){
	return Poly(f.p0+g.p0,f.p1+g.p1);
}
inline Poly insF(const Poly &f,int x){
	return Poly(ins(f.p0,x),ins(f.p1,x));
}
inline Poly insG(const Poly &f,int x){
	return Poly(ins(f.p0,x),f.p0+ins(f.p1,x));
}
inline ll qry(const Poly &f,const Poly &g){
	return qry(f.p1,g.p1);
}
#define dep(p) __lg(p)
struct node{
	int x,y,id;
	node(){x=y=id=0;}
	node(int _x,int _y,int _id){x=_x,y=_y,id=_id;}
};
vector<node> T[N<<2];int pos[N];
void build(int l,int r,int p=1){
	if(l+1==r){
		pos[l]=p;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,p<<1);
	build(mid,r,p<<1|1);
}
inline int lca(int p,int q){
	p=pos[p],q=pos[q];
	while(p!=q){
		if(dep(p)<dep(q))swap(p,q);
		p>>=1;
	}
	return p;
}
Poly func[N];
void solveP(int l,int r,const Poly &_P){
	if(l+1==r){
		func[l]=insG(_P,l);
		return;
	}
	int mid=(l+r)>>1;
	Poly P;
	P=_P;
	for(int i=mid;i<r;i++)P=insF(P,i);
	solveP(l,mid,P);
	P=_P;
	for(int i=l;i<mid;i++)P=insG(P,i);
	solveP(mid,r,P);
}
void solveQ(int l,int r,const Poly &_Q){
	if(l+1==r){
		func[l]=insG(_Q,l);
		return;
	}
	int mid=(l+r)>>1;
	Poly Q;
	Q=_Q;
	for(int i=mid;i<r;i++)Q=insG(Q,i);
	solveQ(l,mid,Q);
	Q=_Q;
	for(int i=l;i<mid;i++)Q=insF(Q,i);
	solveQ(mid,r,Q);
}
void Solve(int l,int r,const Poly &_L,const Poly &_R,int p=1){
	if(l+1==r)return;
	int mid=(l+r)>>1;
	Poly L,R;
	L=_L,R=_R;
	for(int i=mid;i<r;i++)R=insG(R,i);
	Solve(l,mid,L,R,p<<1),solveP(l,mid,L);
	L=_L,R=_R;
	for(int i=l;i<mid;i++)L=insG(L,i);
	Solve(mid,r,L,R,p<<1|1),solveQ(mid,r,R);
	for(const auto &o:T[p]){
		ll res=qry(func[o.x],func[o.y]);
		if(o.id>0)Add(ans[o.id],res);
		else Sub(ans[-o.id],res);
	}
}
#undef dep
bool Med;
int main(){
	cerr<<abs(&Mst-&Med)/1048576.0<<endl;
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
	build(1,n+1);
	for(int i=1;i<=q;i++){
		int l1,r1,l2,r2;
		cin>>l1>>r1>>l2>>r2,--l1,++r2;
		T[lca(r1,l2)].emplace_back(r1,l2,i);
		if(l1>=1)
			T[lca(l1,l2)].emplace_back(l1,l2,-i);
		if(r2<=n)
			T[lca(r1,r2)].emplace_back(r1,r2,-i);
		if(l1>=1&&r2<=n)
			T[lca(l1,r2)].emplace_back(l1,r2,i);
	}
	static Poly eps(poly(m,0),poly(m,0));eps.p0[0]=1;
	Solve(1,n+1,eps,eps);
	for(int i=1;i<=q;i++)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P12493)

**题目大意**

> 给定 $n$ 个元素 $a_i,b_i$，定义 $f(S)$ 表示 $S$ 中每个元素选择 $0,a_i,b_i$ 中的一个，求有多少种选法使得元素总和 $\bmod m=0$。
>
> $q$ 次询问给定无交 $[l_1,r_1],[l_2,r_2]$，在两个区间中各选一个元素 $i,j$，求 $\sum f(S\setminus\{i,j\})$。
>
> 数据范围：$n\le 10^4,m\le 200,q\le 10^6$。

**思路分析**

首先肯定要维护循环卷积，即 $\bmod m$ 意义下的卷积，设 $g(S)$ 表示元素和 $\bmod m$ 为 $[0,m)$ 每种的方案数。

在这题的情况下合并两个 $g$ 信息很难做到低于 $\mathcal O(m^2)$，很显然不能接受。

但注意到 $S$ 中加入单个元素只要 $\mathcal O(m)$，并且用 $g(A),g(B)$ 求 $f(A+B)$ 也是 $\mathcal O(m)$ 的。

那么我们肯定要把查询的答案表示成两个集合 $A,B$ 的 $g$ 信息之和。

但每个询问有四个变量，很难拆成两个集合，但注意到 $[l_1,r_1]$ 可以差分成 $[1,r_1]-[1,l_1-1]$，$[l_2,r_2]$ 可以差分成 $[l_2,n]-[r_2+1,n]$。

那么我们只要维护 $l_1=1,r_2=n$ 的询问 $(1,x,y,n)$ 即可。

拆成两个信息之和自然想到猫树，找到 $x\le mid<y$ 的点，那么我们要算 $[1,mid]$ 删掉 $[1,x]$ 中的一个点的 $g$ 信息，以及 $[mid+1,n]$ 中删掉 $[y,n]$ 一个点的 $g$ 信息。

两者对称，只考虑第一个。

首先我们可以提前处理 $[1,x]$ 中删掉一个点的 $g$ 信息，只要逐个加入 $[x+1,mid]$ 范围内的点即可。

但对每个 $x$ 都处理复杂度无法通过。

分开，先处理 $[1,l-1]$ 中删掉一个点的信息，然后加入 $[l,mid]$ 的点，接下来对于每个 $u\in [l,mid]$，算删掉这个点后的 $g$ 信息。

由于初始每个点的信息都是 $[1,l-1]$ 的乘积，因此可以 CDQ 分治，每次把右边的元素加入左边，左边的元素加入右边。

那么对第二部分维护一个前缀和即可。

时间复杂度 $\mathcal O((n\log^2n+q)m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e4+5,MAXQ=1e6+5,MOD=1e9+7;
int n,m,q,a[MAXN],b[MAXN],ans[MAXQ];
inline void add(int &x,const int &y) { if((x+=y)>=MOD) x-=MOD; }
struct poly {
	int f[205];
	poly() { memset(f,0,sizeof(f)); }
	inline friend poly operator +(const poly &u,const poly &v) {
		poly w=u;
		for(int i=0;i<m;++i) add(w.f[i],v.f[i]);
		return w;
	}
	inline friend poly operator *(const poly &u,const int &o) {
		poly w=u;
		for(int i=0;i<m;++i) add(w.f[(i+a[o])%m],u.f[i]);
		for(int i=0;i<m;++i) add(w.f[(i+b[o])%m],u.f[i]);
		return w;
	}
}	L[MAXN][2],R[MAXN][2],f[MAXN],dp[MAXN];
struct Qry { int l,r,i; };
void cdq(int l,int r) {
	if(l==r) return ;
	int mid=(l+r)>>1;
	f[mid+1]=f[l];
	for(int i=l;i<=mid;++i) f[mid+1]=f[mid+1]*i;
	for(int i=mid+1;i<=r;++i) f[l]=f[l]*i;
	cdq(l,mid),cdq(mid+1,r);
}
void solve(int l,int r,const vector<Qry>&qy) {
	if(qy.empty()) return ;
	int mid=(l+r)>>1;
	f[l]=L[l-1][0],f[mid+1]=R[r+1][0];
	cdq(l,mid),cdq(mid+1,r);
	dp[l]=L[l-1][1],dp[r]=R[r+1][1];
	for(int i=l;i<=mid;++i) dp[l]=dp[l]*i;
	for(int i=mid+1;i<=r;++i) dp[r]=dp[r]*i;
	dp[l]=dp[l]+f[l],dp[r]=dp[r]+f[r];
	for(int i=l+1;i<=mid;++i) dp[i]=dp[i-1]+f[i];
	for(int i=r-1;i>mid;--i) dp[i]=dp[i+1]+f[i];
	vector<Qry> lq,rq;
	for(auto i:qy) {
		if(i.r<=mid) lq.push_back(i);
		else if(i.l>mid) rq.push_back(i);
		else {
			int z=0;
			for(int j=0;j<m;++j) z=(z+1ll*dp[i.l].f[j]*dp[i.r].f[(m-j)%m])%MOD;
			if(i.i<0) z=MOD-z,i.i*=-1;
			ans[i.i]=(ans[i.i]+z)%MOD;
		}
	}
	solve(l,mid,lq),solve(mid+1,r,rq);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i) cin>>a[i]>>b[i];
	L[0][0].f[0]=R[n+1][0].f[0]=1;
	for(int i=1;i<=n;++i) L[i][0]=L[i-1][0]*i,L[i][1]=L[i-1][1]*i+L[i-1][0];
	for(int i=n;i>=1;--i) R[i][0]=R[i+1][0]*i,R[i][1]=R[i+1][1]*i+R[i+1][0];
	vector <Qry> qy;
	for(int i=1,lx,rx,ly,ry;i<=q;++i) {
		cin>>lx>>rx>>ly>>ry;
		qy.push_back({rx,ly,i});
		if(lx>1) qy.push_back({lx-1,ly,-i});
		if(ry<n) qy.push_back({rx,ry+1,-i});
		if(lx>1&&ry<n) qy.push_back({lx-1,ry+1,i});
	}
	solve(1,n,qy);
	for(int i=1;i<=q;++i) cout<<ans[i]<<"\n";
	return 0;
}
```

---


# [集训队互测 2016] 消失的源代码

## 题目背景

翻开古老的试题，发现题面已模糊不清。   
选手们的源代码也已经消失。   
只剩下编译后的可执行程序。  
你找到了输入文件，希望重新生成输出文件。 

## 题目描述

给出可执行程序 $\texttt{lost}$，和输入文件 $\texttt{input*.txt}$，对于每一个输入文件，求出它对应的输出文件。    
$\texttt{lost}$ 的输入和输出是标准输入输出。可以在命令行中对输入输出进行重定向。  
还下发了一个可执行程序 $\texttt{lost2}$，它从 $\texttt{input.txt}$ 中读入，输出到 $\texttt{output.txt}$。除此以外 $\texttt{lost2}$ 和 $\texttt{lost}$ 完全相同。可以根据习惯选用 $\texttt{lost}$ 或 $\texttt{lost2}$。   
$\text{lost}$ 并不完美，当数据规模较大时，它或许不能成功运行，此时会直接输出 `invalid input!`     

## 说明/提示

[输入数据下载](http://uoj.ac/download.php?type=problem&id=190)  

## 样例 #1

### 输入

```
0
2
2 3
4 7```

### 输出

```
5
11```

# 题解

## 作者：AgOH (赞：154)

看到题面，给了我们一个有瑕疵的程序，但是毒瘤的是，别的程序 TLE，~~跑个1年左右~~最后还是会出正确答案的，然而这程序 T 了倒是告诉你  `invalid input！` 

怎么办呢，肯定是要从分析这个程序入手。如何分析这个程序呢？首先，你可能打不开它，会提示少 `libgcc_s_dw2-1.dll` 和 `libstdc++-6.dll` 这两个文件，解决方案，下载它们，把他们和 `lost.exe` 程序放在一起

[下载地址](https://pan.baidu.com/s/1MSI9ldn2VuMAzCiVo2WzoQ) 提取码：8d21

然后我们就可以愉快的分析它了，其他大佬都是试数据看输出知算法，但是我这个蒟蒻毛都看不出来，于是只好对它进行反编译。

用 IDA 打开它进行分析。首先，在函数窗口里找到 `_main` 函数：

![](https://cdn.luogu.com.cn/upload/pic/59623.png)

（其实根据这些函数名都可以推测出一些东西了）双击 `_main` 打开 IDA 视图窗口，在这个窗口里 IDA 会帮你画出程序的流程图：

![](https://cdn.luogu.com.cn/upload/pic/59617.png)

发现它首先调用(`call`)了一个没有任何卵用的 `__main` 函数，然后 `scanf` 读入了两个 `int` (我们姑且称它们为 $n$ 和 $m$，$n$ 为要执行的子任务类型，$m$ 为数据组数)……然后循环调用 `Do` 函数 $m$ 次，最后 `return`。那我们继续追踪 `Do` 函数：

![](https://cdn.luogu.com.cn/upload/pic/59618.png)

发现它根据 $n$ 为 $0 \sim 10$ 调用命名空间 `A` $\sim$ `K` 的 `Do` 函数，于是我们就要分别分析每个 `Do` 函数。`A` 命名空间的 `Do` 函数根据题意是 A+B Problem 就不管了。我们从 `namespace C` 开始分析。`B` 放在最后，因为洛谷不能交太长的代码，所以 `namespace B` 实际上是最难分析的(其实也没难到哪里去)。

# Namespace C

![](https://cdn.luogu.com.cn/upload/pic/59619.png)

不懂汇编看不懂？没关系，~~我也看不懂~~流程图能看懂就行，赫然入目的是最左面的结构中的一个字符串 `invalid input!` 我们追根溯源，发现带领我们进入这干扰我们切题的毒瘤恶魔的一句话是最上面的框框里的最后一句话：

```
jz      short loc_4014C3
```

解释一下这句话，`jz` 是 jump if zero 的缩写，即零标志为 $1$ 就跳转到 `0x004014C3` 这个位置继续执行，更详细介绍的限于篇幅原因不展开了，想了解的可以自行搜索。`short` 表示这次转移是一次短转移，即这次跳转的位置的地址距离当前位置的地址差值在 $(-128,127)$ 范围之内。

根据流程图，我们要的是让他跳转，这样我们才能执行右下方的主要部分得出结果，而不是让程序不跳转而是继续执行到 `invalid input!` 处。汇编语言的无条件跳转语句是 `jmp`，也就是说我们只要把 `jz` 修改成 `jmp`，这个程序就变成了一个完整的程序。

在 `jz` 上右键->同步到->$16$ 进制视图，我们发现这句话的真面目是这样的：

```
004014A0  C0 74 20 8B 45 C4 85 C0  78 08 8B 45 C4 83 F8 14
```

程序使用 $16$ 进制来储存汇编命令，我们的 `jz` 指令对应的机器码为 `74`，也就是说阻挡我们的指令的真正面目其实就是 `74 20`！

`jmp` 指令的机器码为 `eb`，我们只要把 `74` 改成 `eb` 就 OK 了。用支持 $16$ 进制的编辑器打开 `lost.exe`（我用的是 sublime），Ctrl+F 查找这一行。注意，在 sublime 里，要 $4$ 个字符一组，而且大写字母要变成小写字母，也就是说你需要在查找框内输入的应该是：

```
c074 208b 45c4 85c0 7808 8b45 c483 f814
```

![](https://cdn.luogu.com.cn/upload/pic/59627.png)

找到后，把 `74` 改成 `eb`，保存，再执行，你会发现……正解出来了……

如法炮制 D~K:

# Namespace D

![](https://cdn.luogu.com.cn/upload/pic/59621.png)

这不跟刚才的一样嘛，同样的操作把第一个 `jz` 改成 `jmp`，也就是 `74` 改成 `eb`。

# Namespace E

![](https://cdn.luogu.com.cn/upload/pic/59622.png)

这个有点复杂，放大了能看清代码但是看不到整体，缩小了能看到整体但是看不到代码就很尴尬……简单说下，左下角箭头指向的框框里写着 `invalid input!` ，顺藤摸瓜往上找寻万恶之源，发现源头是上方箭头所指的框，框的最后一句话还是 `jz short` 什么什么，于是同样操作，`74` 改 `eb`。

# Namespace F

![](https://cdn.luogu.com.cn/upload/pic/59624.png)

这回不太一样，`Do` 函数里调用了两个函数。先调用的是 `GetData` 函数，读入数据用的，肯定跟我们的目的无关，不去管它。于是我们继续分析 `DoIt` 函数：

![](https://cdn.luogu.com.cn/upload/pic/59625.png)

找到了左下方框框里的 `invalid input!`，重复以上步骤不再赘述，万恶之源位置为第二行右侧的框框里的 `jz`。

# Namespace G

`G::Do()` 函数跟 `F::Do()` 函数几乎一样，先调用一个 `GetData` 再调用一个 `DoIt`，就不放图了，直接分析 `DoIt`：

![](https://cdn.luogu.com.cn/upload/pic/59626.png)

# Namespace H

![](https://cdn.luogu.com.cn/upload/pic/59628.png)

# Namespace I

还是按照以上做法去做：

![](https://cdn.luogu.com.cn/upload/pic/59629.png)

不过这样做答案会有两个不对。

正确答案：

```
51 108 153 4929 124260 498810 12491602 49971923 2739460784 499996516402
```

如此做的答案：

```
51 108 152 4929 124260 498810 12491601 49971923 2739460784 499996516402
```

第 $3$ 个和第 $7$ 个蜜汁少 $1$，身为蒟蒻的我搞不懂为什么，只好特别害怕地看了一眼题解大佬的答案，分数 90->100……

应该是出题大佬的暴力写炸了？

# Namespace J

![](https://cdn.luogu.com.cn/upload/pic/59630.png)

# Namespace K

![](https://cdn.luogu.com.cn/upload/pic/59631.png)

写的很清楚，`puts("invalid input!");`

不管你输入啥都是无效。

# Namespace B

![](https://cdn.luogu.com.cn/upload/pic/59632.png)

按照之前的方法做还是可以得到正确答案的，但是，输出的东西非常之多，以至于不管是提交答案还是提交 zip 还是提交打表代码洛谷都会提示代码太长。我们只好深究它的算法了。

![](https://cdn.luogu.com.cn/upload/pic/59633.png)

这是 `jz` 往右跳下方的算法主要部分，可以看到是一个循环结构。我们简单看下循环体内的内容，大致意思就是用 `dr` 数组内的所有元素减去字符 `a` （`61h`，一个数加 `h`（hex）代表这个数是 $16$ 进制，而 ASCII 码 `0x61` 就是 `a`），然后 `putchar` 输出对应的 `point` 数组下标内的值。我们双击 `B::dr` 查看这是个什么玩意，发现：

```
.bss:0040A040 __ZN1B2drE      db    ? ;               ; DATA XREF: B::Do(void)+58↑o
.bss:0040A041 ; char byte_40A041[104999]
```

看到了 `char`，看到了 `[104999]`。所以 `dr` 数组其实就是：

```cpp
char dr[105000];
```

这个数组开这么大，应该是装输入的字符串的，而且最上面的框框里一开始就执行了`scanf("%s",dr);`

然后我们再看一下 `point` 数组：

```
.rdata:004070F0 __ZN1BL5pointE  db 79h                  ; DATA XREF: B::Do(void)+65↑r
.rdata:004070F1 aFrbkgimujvphat db 'frbkgimujvphatdsnelozcxwq',0
```

这个数组的首位是一个 ASCII 码为 `0x79` 的字符也就是 `y`，`y` 后面是第二行引号括起来的那一串，也就是：

```cpp
char point[] = {"yfrbkgimujvphatdsnelozcxwq"};
```

字符映射，写下代码就好了：

```cpp
int m; 
scanf("%d",&m);
while(m--)
{
  scanf("%s",dr);
  for(int i=0;dr[i]!='\0';i++)
  	putchar(point[dr[i]-'a']);
}
```

# 尾声 #
至此，~~我们只用了半小时时间就切了一道黑题~~，代码就不放了，参考其他大佬。经过修改的能出正确答案（除了 #8）的程序也在文章开头的网盘链接里 `newlost.exe`。

至于我这个题解到底算不算是个题解，我觉得既然“无数用户可以从洛谷提升自己的计算机科学能力”，那么我这篇文章应该也能算是这个范围内吧。题解题解，解了题的方法就是题解。

---

## 作者：TheLostWeak (赞：24)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5246.html)

**大致题意：** 共$10$个$Subtask$，每个$Subtask$给你一个不完美的可执行程序和一个输入文件，让你求出输出文件。

### 子任务$1$

简单分析，可以发现对于每个输入的字符，你要输出一个与其对应的字符。

则可通过打表得到每个字符所对应的字符。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
using namespace std;
int v[27]={0,'y','f','r','b','k','g','i','m','u','j','v','p','h','a','t','d','s','n','e','l','o','z','c','x','w','q'};//打得的表
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        char c,*A,*B,FI[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        I void reads(string& x) {x="";W(isspace(c=tc()));W(x+=c,!isspace(c=tc())&&~c);}
}F;
int main()
{
	freopen("input1.txt","r",stdin),freopen("output1.txt","w",stdout);
	RI Tpos,Ttot,i,len;Reg char c;Reg string s;
	F.read(Tpos,Ttot);W(Ttot--)
	{
		for(F.reads(s),len=s.length(),i=0;i^len;++i) putchar(v[s[i]&31]);//输出对应字符
		putchar('\n');//换行
	}return 0;
}
```

### 子任务$2$

先打表得到$n=1\sim5$的输出结果分别为$2030,8082,18166,32282,50430$。

考虑其每次增加的值分别为$6052,10084,14116,18148$，而增加的值所相差的值都为$4032$！

设第$i$个数为$f_i$，则不难得到：

$$f_i=2030+6052(i-1)+4032\frac{(i-2)(i-1)}2=2016i^2+4i+10$$

貌似做完了？

等等，这种式子肯定需要取模！

我们继续打表，可以发现在$n=10$时，$ans=201650$，但$n=11$时，$ans$就变成了$10657$。

而$f_{11}=243990$，与$10657$刚好相差$233333$。

所以模数必为$233333$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define X 233333
using namespace std;
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
int main()
{
	freopen("input2.txt","r",stdin),freopen("output2.txt","w",stdout);
	RI Tpos,Ttot,x;F.read(Tpos,Ttot);W(Ttot--) F.read(x),F.writeln((1LL*2016*x%X*x%X+4LL*x+10)%X);//计算并输出答案
	return F.clear(),0;
}
```

### 子任务$3$

同样是考虑打表，发现这次得到的式子增长速度特别慢。

与$hl666$神仙一起想了半天没想出来，最后放到$OEIS$上，发现是这样一个式子：

$$\lfloor\sqrt{\frac i\pi}\rfloor$$

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
using namespace std;
const double Pi=acos(-1);
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
int main()
{
	freopen("input3.txt","r",stdin),freopen("output3.txt","w",stdout);
	RI Tpos,Ttot,x;F.read(Tpos,Ttot);W(Ttot--) F.read(x),F.writeln((int)floor(sqrt(x/Pi)));//计算并输出答案
	return F.clear(),0;
}
```

### 子任务$4$

观察数据形式，易得：输入第一行两个数数$n,m$，分别表示节点个数和边数。其后$m$行，每行两个数表示一条边。

观察样例，可发现答案就是**各连通块大小的平方和**。

可以用**并查集**维护连通性，最后再统计答案即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define LL long long
using namespace std;
int n,m;
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class UnionFindSet//并查集
{
	private:
		static const int SZ=N;int fa[SZ+5],cnt[SZ+5];
		I int getfa(CI x) {return fa[x]^x?fa[x]=getfa(fa[x]):x;}//找祖先
	public:
		I void Init(CI n) {for(RI i=1;i<=n;++i) cnt[fa[i]=i]=0;}//初始化
		I void Union(RI x,RI y)	{(x=getfa(x))^(y=getfa(y))&&(fa[y]=x);}//合并两个节点
		I LL Query(CI n)//询问
		{
			RI i;Reg LL ans=0;for(i=1;i<=n;++i) ++cnt[getfa(i)];//统计
			for(i=1;i<=n;++i) ans+=1LL*cnt[i]*cnt[i];return ans;//计算答案
		}
}U;
int main()
{
	freopen("input4.txt","r",stdin),freopen("output4.txt","w",stdout);
	RI Tpos,Ttot,i,x,y;F.read(Tpos,Ttot);W(Ttot--) 
	{
		for(F.read(n,m),U.Init(n),i=1;i<=m;++i) F.read(x,y),U.Union(x,y);//对每条边依次合并连通块
		F.writeln(U.Query(n));//输出答案
	}return F.clear(),0;
}
```

### 子任务$5$

观察数据形式，易得：输入第一行两个数$n,Q$，分别表示节点个数和询问个数。其后$n-1$行，每行两个数表示一条边（可见这是一棵树）。再然后是$Q$行，每行两个数，表示一个询问。

手造小数据容易得出，每次询问的是树上两点间的距离，最后要输出答案的异或和。

这用**树上倍增**即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define LogN 17
#define LL long long
#define swap(x,y) (x^=y^=x^=y)
#define add(x,y,v) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y,e[ee].val=v)
using namespace std;
int n,m,ee,lnk[N+5];struct edge {int to,nxt,val;}e[N<<1];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
        #undef D
}F;
class TreeSolver//树上倍增
{
	private:
		int D[N+5],F[N+5][LogN+5];LL Dis[N+5][LogN+5];
	public:
		I void dfs(CI x,CI lst)//DFS预处理
		{
			RI i;for(i=1;i<=LogN;++i) F[x][i]=F[F[x][i-1]][i-1],Dis[x][i]=Dis[x][i-1]+Dis[F[x][i-1]][i-1];//求出F数组和Dis数组
			for(i=lnk[x];i;i=e[i].nxt) e[i].to^lst&&(D[e[i].to]=D[F[e[i].to][0]=x]+1,Dis[e[i].to][0]=e[i].val,dfs(e[i].to,x),0);//遍历子树
		}
		I LL GetDis(RI x,RI y)//求出树上两点间的距离
		{
			RI i;Reg LL t=0;for(D[x]<D[y]&&swap(x,y),i=0;D[x]^D[y];++i) (D[x]^D[y])&(1<<i)&&(t+=Dis[x][i],x=F[x][i]);
			if(!(x^y)) return t;for(i=LogN;~i;--i) F[x][i]^F[y][i]&&(t+=Dis[x][i]+Dis[y][i],x=F[x][i],y=F[y][i]);
			return t+Dis[x][0]+Dis[y][0];
		}
}T;
int main()
{
	freopen("input5.txt","r",stdin),freopen("output5.txt","w",stdout);
	RI Tpos,Ttot,i,x,y,v;Reg LL ans;F.read(Tpos,Ttot);W(Ttot--)
	{
		for(F.read(n,m),ee=0,i=1;i<=n;++i) lnk[i]=0;for(i=1;i^n;++i) F.read(x,y,v),add(x,y,v),add(y,x,v);//清空数组+读入+连边
		for(T.dfs(1,0),ans=0,i=1;i<=m;++i) F.read(x,y),ans^=T.GetDis(x,y);F.writeln(ans);//求解答案
	}return F.clear(),0;
}
```

### 子任务$6$

与子任务$5$差不多，只不过询问的变成了树上两点间的最小边权。

我们可以通过询问同一个点间的最小边权，来求出其$ans$初始化为$1987654321$。

然后同样用**树上倍增**即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define LogN 17
#define min(x,y) ((x)<(y)?(x):(y))
#define Gmin(x,y) ((x)>(y)&&(x=(y)))
#define swap(x,y) (x^=y^=x^=y)
#define add(x,y,v) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y,e[ee].val=v)
using namespace std;
int n,m,ee,lnk[N+5];struct edge {int to,nxt,val;}e[N<<1];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
        #undef D
}F;
class TreeSolver//树上倍增
{
	private:
		#define P 1987654321//ans初始值
		int D[N+5],F[N+5][LogN+5],M[N+5][LogN+5];
	public:
		I void dfs(CI x,CI lst)//DFS预处理
		{
			RI i;for(i=1;i<=LogN;++i) F[x][i]=F[F[x][i-1]][i-1],M[x][i]=min(M[x][i-1],M[F[x][i-1]][i-1]);//求出F数组和M数组
			for(i=lnk[x];i;i=e[i].nxt) e[i].to^lst&&(D[e[i].to]=D[F[e[i].to][0]=x]+1,M[e[i].to][0]=e[i].val,dfs(e[i].to,x),0);//遍历子树
		}
		I int GetMin(RI x,RI y)//求出树上两点间的最小边权
		{
			RI i,t=P;for(D[x]<D[y]&&swap(x,y),i=0;D[x]^D[y];++i) (D[x]^D[y])&(1<<i)&&(Gmin(t,M[x][i]),x=F[x][i]);
			if(!(x^y)) return t;for(i=LogN;~i;--i) F[x][i]^F[y][i]&&(Gmin(t,M[x][i]),Gmin(t,M[y][i]),x=F[x][i],y=F[y][i]);
			return min(t,min(M[x][0],M[y][0]));
		}
}T;
int main()
{
	freopen("input6.txt","r",stdin),freopen("output6.txt","w",stdout);
	RI Tpos,Ttot,i,x,y,v,ans;F.read(Tpos,Ttot);W(Ttot--)
	{
		for(F.read(n,m),ee=0,i=1;i<=n;++i) lnk[i]=0;for(i=1;i^n;++i) F.read(x,y,v),add(x,y,v),add(y,x,v);//清空数组+读入+连边
		for(T.dfs(1,0),ans=0,i=1;i<=m;++i) F.read(x,y),ans^=T.GetMin(x,y);F.writeln(ans);//求解答案
	}return F.clear(),0;
}
```

### 子任务$7$

数据给你的是两个数$n$和$m$。

通过大量测试和猜测可得我们要求的式子为：

$$\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)$$

观察$input.txt$，可以发现除了一组$100\ 1000$的数据外，其余的数据都满足$n=m$。

而$100\ 1000$的数据我们完全可以暴力求解。

否则，我们将$n=m$代入得到：

$$\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)$$

这应该是比较经典的式子，我们枚举$gcd$得：

$$\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac nd\rfloor}d[gcd(i,j)==1]$$

将$d$提前得：

$$\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac nd\rfloor}[gcd(i,j)==1]$$

而后半部分可以运用$\phi$的定义转化，于是得到这样一个式子：

$$\sum_{d=1}^nd(2\sum_{i=1}^{\lfloor\frac nd\rfloor}\phi(i)-1)$$

$n$不大，可以直接**线性筛**筛出$\phi$的前缀和，然后枚举$d$求解即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define LL long long
using namespace std;
int n,m;
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class BruteForceSolver//暴力求解n!=m的情况
{
	private:
		I int gcd(CI x,CI y) {return y?gcd(y,x%y):x;}//求解gcd
	public:
		I void Solve()
		{
			RI i,j;Reg LL ans=0;
			for(i=1;i<=n;++i) for(j=1;j<=m;++j) ans+=gcd(i,j);//大暴力统计答案
			F.writeln(ans);//输出答案
		}
}B;
class MathSolver//用数学方法求解n=m的情况
{
	private:
		class LineSiever//线性筛筛出φ的前缀和
		{
			private:
				static const int SZ=1000000;int Pcnt,P[SZ+5],phi[SZ+5];
			public:
				LL Sphi[SZ+5];
				I LineSiever()
				{
					RI i,j;for(phi[1]=1,i=2;i<=SZ;++i) for(!P[i]&&(phi[P[++Pcnt]=i]=i-1),j=1;1LL*i*P[j]<=SZ;++j)
						if(P[i*P[j]]=1,i%P[j]) phi[i*P[j]]=phi[i]*(P[j]-1);else {phi[i*P[j]]=phi[i]*P[j];break;}
					for(i=1;i<=SZ;++i) Sphi[i]=Sphi[i-1]+phi[i];//统计前缀和
				}
		}S;
	public:
		I void Solve()
		{
			RI i;Reg LL ans=0;
			for(i=1;i<=n;++i) ans+=1LL*i*(2*S.Sphi[n/i]-1);//统计答案
			F.writeln(ans);//输出答案
		}
}M;
int main()
{
	freopen("input7.txt","r",stdin),freopen("output7.txt","w",stdout);
	RI Tpos,Ttot;F.read(Tpos,Ttot);W(Ttot--) F.read(n,m),n^m?B.Solve():M.Solve();//分情况选择解决方案
	return F.clear(),0;
}
```

### 子任务$8$

手造几组小数据，可发现这题求的是给定序列本质不同的子串个数。

**后缀数组**裸题，答案就是：

$$\frac{n(n+1)}2-\sum_{i=1}^nHeight_i$$

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 1000000
#define LL long long
using namespace std;
int n,a[N+5];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class SuffixArray//后缀数组
{
	private:
		static const int SZ=N;int n,SA[SZ+5],H[SZ+5],R[SZ+5],P[SZ+5],T[SZ+5];
		I void Rsort(CI S)//基数排序
		{
			RI i;for(i=0;i<=S;++i) T[i]=0;for(i=1;i<=n;++i) ++T[R[i]];
			for(i=1;i<=S;++i) T[i]+=T[i-1];for(i=n;i;--i) SA[T[R[P[i]]]--]=P[i];
		}
		I void GetSA(int* s)//求出SA数组
		{
			RI i,k,S=N,t=0;for(i=1;i<=n;++i) R[P[i]=i]=s[i];
			for(Rsort(S),k=1;t^n;k<<=1)
			{
				for(S=t,t=0,i=1;i<=k;++i) P[++t]=n-k+i;	
				for(i=1;i<=n;++i) SA[i]>k&&(P[++t]=SA[i]-k);
				for(Rsort(S),i=1;i<=n;++i) P[i]=R[i];
				for(R[SA[1]]=t=1,i=2;i<=n;++i) R[SA[i]]=(P[SA[i-1]]^P[SA[i]]||P[SA[i-1]+k]^P[SA[i]+k])?++t:t;
			}
		}
		I void GetHeight(int* s)//求出Height数组
		{
			RI i,j,k=0;for(i=1;i<=n;++i) R[SA[i]]=i;
			for(i=1;i<=n;++i)
			{
				if(k&&--k,!(R[i]^1)) continue;j=SA[R[i]-1];
				W(i+k<=n&&j+k<=n&&!(s[i+k]^s[j+k])) ++k;H[R[i]]=k;
			}
		}
	public:
		I void Init(CI len,int* s) {n=len,GetSA(s),GetHeight(s);}//初始化
		I LL GetAns() {Reg LL t=1LL*n*(n+1)>>1;for(RI i=1;i<=n;++i) t-=H[i];return t;}//计算答案
}S;
int main()
{
	freopen("input8.txt","r",stdin),freopen("output8.txt","w",stdout);
	RI Tpos,Ttot,i;F.read(Tpos,Ttot);W(Ttot--) 
	{
		for(F.read(n),i=1;i<=n;++i) F.read(a[i]);//读入
		S.Init(n,a),F.writeln(S.GetAns());//求解
	}return F.clear(),0;
}
```

### 子任务$9$

同样是通过造小数据，可发现这题就是求**平面最近点对**。

用**计算几何**做即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 1000000
#define DB double
#define INF 1e9
#define dis(A,B) sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y))
#define min(x,y) ((x)<(y)?(x):(y))
#define Gmin(x,y) (x>(y)&&(x=(y)))
using namespace std;
int n,s[N+5];
struct Point//存储点
{
	DB x,y;
	I friend bool operator < (Con Point& x,Con Point& y) {return x.x==y.x?x.y<y.y:x.x<y.x;}//按x坐标排序
}p[N+5];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        char c,*A,*B,FI[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
}F;
I bool cmp(CI x,CI y) {return p[x].y<p[y].y;}//按y坐标排序
I double Solve(CI l,CI r)//分治
{
	if(!(l^r)) return INF;if(r-l==1) return dis(p[l],p[r]);RI i,j,t=0,mid=l+r>>1;//判断边界情况
	Reg DB d1=Solve(l,mid),d2=Solve(mid+1,r),d3,d=min(d1,d2);//分治两个区间，求答案
	for(i=l;i<=r;++i) fabs(p[mid].x-p[i].x)<=d&&(s[++t]=i);//将可能符合条件的点的编号加入数组
	for(sort(s+1,s+t+1,cmp),i=1;i<=t;++i) for(j=i+1;j<=t&&p[s[j]].y-p[s[i]].y<=d;++j) d3=dis(p[s[i]],p[s[j]]),Gmin(d,d3);//排序后用可能符合条件的点对更新答案
	return d;//返回答案
}
int main()
{
	freopen("input9.txt","r",stdin),freopen("output9.txt","w",stdout);
	RI Tpos,Ttot,i,x,y;F.read(Tpos,Ttot);W(Ttot--) 
	{
		for(F.read(n),i=1;i<=n;++i) F.read(x,y),p[i].x=x,p[i].y=y;//读入数据
		sort(p+1,p+n+1),printf("%.3lf\n",Solve(1,n));//排序，然后分治输出答案
	}return 0;
}
```

### 子任务$10$

最神奇的一个子任务。

这题的程序连第一个输入都会输出“$invalid\ input!$”

这时我便大胆猜想：这题就是输出$10$个“$invalid\ input!$”

结果真过了。

### 代码

以上便是这道题的全部解法。

但可惜洛谷上交不了这么大的文件，结果只能写成代码，将第一个子任务直接搞，其余子任务打表输出答案。

$AC$代码如下：

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
using namespace std;
class Subtask1Solver//处理第一个子任务
{
	private:
		int v[27]={0,'y','f','r','b','k','g','i','m','u','j','v','p','h','a','t','d','s','n','e','l','o','z','c','x','w','q'};
	public:
		I void Solve()
		{
			RI Ttot,i,len;Reg char c;Reg string s;scanf("%d",&Ttot);W(Ttot--)
			{
				for(cin>>s,len=s.length(),i=0;i^len;++i) putchar(v[s[i]&31]);
				putchar('\n');
			}
		}
}S;
//以下为打表代码
I void Print2() {puts("106491\n189151\n42510\n93772\n32326\n6890\n94677\n168190\n66840\n93722");}
I void Print3() {puts("126\n126\n178\n252\n252\n626\n1982\n6268\n14567\n17730\n");}
I void Print4() {puts("68\n132\n171\n138\n225\n6592\n621318\n64147302\n1588039630\n6348298844");}
I void Print5() {puts("531842264\n3996089551\n1217487770\n13846806112\n2258552000\n12273908750\n31068785149\n453868136017\n7989258282893\n3571890382468");}
I void Print6() {puts("1159833908\n380176501\n1615846343\n1005775280\n1900756444\n139818805\n2130798985\n1503185154\n433569593\n988651389");}
I void Print7() {puts("880\n31080\n325200\n4449880\n135637352\n584509280\n72434344904\n306591086320\n2055466926488\n8643257847824");}
I void Print8() {puts("51\n108\n153\n4929\n124260\n498810\n12491602\n49971923\n2739460784\n499996516402");}
I void Print9() {puts("2.236\n69.527\n8.944\n10.440\n10.198\n1.414\n57.489\n10.770\n5.000\n8.544");}
I void Print10() {for(RI i=1;i<=10;++i) puts("invalid input!");}
int main()
{
	RI Tpos;switch(scanf("%d",&Tpos),Tpos)
	{
		case 1:S.Solve();break;case 2:Print2();break;
		case 3:Print3();break;case 4:Print4();break;
		case 5:Print5();break;case 6:Print6();break;
		case 7:Print7();break;case 8:Print8();break;
		case 9:Print9();break;case 10:Print10();break;
	}return 0;
}
```

---

## 作者：ud2_ (赞：16)

安装 [GNU binutils](https://www.gnu.org/software/binutils) 后，运行 `objdump -hd lost.exe` 反汇编（[结果](https://paste.ubuntu.com/p/nN9MgFdvS2)），发现 `B::Do()`、`C::Do()` 等函数在输出 `invalid input.` 之前都会检查位于 `0x406000` 的值。以 `B::Do()` 为例：

```plain
  401404:       c7 04 24 41 a0 40 00    movl   $0x40a041,(%esp)
  40140b:       e8 f0 29 00 00          call   403e00 <_strlen>
  401410:       89 45 f0                mov    %eax,-0x10(%ebp)
  # if (*(bool*) 0x406000) {
  401413:       a0 00 60 40 00          mov    0x406000,%al
  401418:       84 c0                   test   %al,%al
  40141a:       74 1a                   je     401436 <__ZN1B2DoEv+0x4c>
  #   if (n <= 0 || n > 10) {
  40141c:       83 7d f0 00             cmpl   $0x0,-0x10(%ebp)
  401420:       7e 06                   jle    401428 <__ZN1B2DoEv+0x3e>
  401422:       83 7d f0 0a             cmpl   $0xa,-0x10(%ebp)
  401426:       7e 0e                   jle    401436 <__ZN1B2DoEv+0x4c>
  #     puts("invalid input.");
  401428:       c7 04 24 7c 70 40 00    movl   $0x40707c,(%esp)
  40142f:       e8 c4 29 00 00          call   403df8 <_puts>
  401434:       eb 46                   jmp    40147c <__ZN1B2DoEv+0x92>
  #   }
  # }
  401436:       c7 45 f4 01 00 00 00    movl   $0x1,-0xc(%ebp)
  40143d:       eb 24                   jmp    401463 <__ZN1B2DoEv+0x79>
  40143f:       8b 45 f4                mov    -0xc(%ebp),%eax

$ // 解决你谷博客的特性
```

查表可知，`0x406000` 在 `.data` 段中：

```plain
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000456c  00401000  00401000  00000400  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE, DATA
  1 .data         00000014  00406000  00406000  00004a00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rdata        00000268  00407000  00407000  00004c00  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
```

运行时的 `0x406000` 对应的就是可执行文件中的 `0x4a00`：

$$ \mathrm{406000}_{16}-\text{VMA}_\texttt{.data}+\text{File off}_\texttt{.data}=\mathrm{4a00}_{16} $$

（VMA 指段在虚拟内存中的位置，File off 指段在可执行文件中的位置）

所以只要把 lost.exe 中位于 `0x4a00` 的字节的值改为 0 就可以得到正解了。（对第 1 和第 8 个测试点的特殊处理可参考其他题解）


---

## 作者：m256i (赞：15)

**声明：电脑为 Windows 10 系统，IDA 版本为 7.5.201028，且以下均以 `lost.exe` 为例。**

首先用 [ExeinfoPE](https://down.52pojie.cn/?query=ExeinfoPe) 打开：

![ExeinfoPE](https://cdn.luogu.com.cn/upload/image_hosting/d52kikxt.png)

没有加壳，并且是 32 位应用程序，所以用 32 位 [IDA](https://down.52pojie.cn/Tools/Disassemblers/) (ida.exe) 打开：

![IDA](https://cdn.luogu.com.cn/upload/image_hosting/9hc7pngq.png)

按 $\texttt{F5}$ 进入伪代码模式：

![伪代码](https://cdn.luogu.com.cn/upload/image_hosting/tuhm2xa9.png)

可以看到是一个简单的循环。进入 `Do` 函数：

![Do](https://cdn.luogu.com.cn/upload/image_hosting/nshdhbcg.png)

现在开始判断类型了。让我们分别进入查看。

# A::Do
![A::Do](https://cdn.luogu.com.cn/upload/image_hosting/k7jww608.png)

最简单的 $\text{A+B Problem}$，甚至没有 `invalid input` 输出。无需修改。

# B::Do
![B::Do](https://cdn.luogu.com.cn/upload/image_hosting/6c9x2oi9.png)

这里出现 `invalid input.` 了。单独打开一个伪代码窗口，单击右键，点击 $\texttt{Syncronize with - IDA View-A, Hex View-1}$，选择 `if ( pre && (v1 <= 0 || v1 > 10) )` 这一行：

![](https://cdn.luogu.com.cn/upload/image_hosting/v6xlfn3q.png)

这时变绿的就是条件语句。显然，只需要把 `test al, al` 下一行的 `jz` 改成 `jmp` 就行了（把 `test` 改成 `xor` 也可以，下面不演示）。

光标移到那一行，点击 $\texttt{Edit - Patch program - Assemble...}$，把 `jz` 改成 `jmp`，然后点击 $\texttt{OK}$，新弹出的窗口点击 $\texttt{Cancel}$。

![汇编](https://cdn.luogu.com.cn/upload/image_hosting/9jvvgjr1.png)

修改成功。**C, D, E, H, I, J 均按照同种方法处理。**

# F::Do
![F::Do](https://cdn.luogu.com.cn/upload/image_hosting/2ej1zume.png)

这次分为了两个函数调用。`GetData` 中并没有条件语句，所以进入 `DoIt` 函数。

![F::DoIt](https://cdn.luogu.com.cn/upload/image_hosting/pywfmbm4.png)

现在按照 B, C, D, E, H, I, J 同种方法来处理就行了。 **G 按照同种方法处理。**

# K::Do
![K::Do](https://cdn.luogu.com.cn/upload/image_hosting/gm0a2iqu.png)

只有输出一行 `invalid input!`。注意，这里从句号变成了感叹号。根据题目：

* 当数据规模较大时，它或许不能成功运行，此时会直接输出 `invalid input.` **（这里是句号）**

* 只有数据组数不超过一组时，**保证** $\texttt{lost}$ 的输出正确。

所以答案就是输出 `invalid input!`，不用修改。

---

修改完毕，点击 $\texttt{Edit - Patch program - Apply patches to input file...}$。

![Apply patches to input file](https://cdn.luogu.com.cn/upload/image_hosting/u7xvf6en.png)

其他不用管，但是建议把 $\texttt{Create backup}$ 勾上，然后点击 $\texttt{OK}$。

---

修改完毕，执行后提交输出，然后：

![喜提 90pts](https://cdn.luogu.com.cn/upload/image_hosting/it8xdzgg.png)

一看输出：

![](https://cdn.luogu.com.cn/upload/image_hosting/ojg3q3cp.png)

于是手动测一遍：

![](https://cdn.luogu.com.cn/upload/image_hosting/9a7vpg5v.png)

这下基本可以确定是多组数据的初始化问题了。现在的解决方案有：

1. 修改代码，加入初始化；

2. 将数据拆分成多组。

显然方案 2 要更简单。我们写一个代码：

```cpp
#include <stdio.h>

int main(){
    freopen("input8.txt", "r", stdin);
    int T, n, x;
    char buf[1024];
    scanf("%d", &T); scanf("%d", &T);
    for (int i = 1; i <= T; ++i){
        sprintf(buf, "input8-%d.txt", i);
        freopen(buf, "w", stdout);
        scanf("%d", &n); printf("8\n1\n%d\n", n);
        for (; n; --n){
            scanf("%d", &x); printf("%d ", x);
        }
        fclose(stdout);
    }
    
    
    return 0;
}
```

接着执行 cmd 命令：

```
copy /y nul output8.txt > nul && for /l %i in (1,1,10) do @lost < input8-%i.txt >> output8.txt
```

再次提交，完美 AC。这样我们不用任何算法就 AC 了一道黑题。

---

## 作者：tuxiaobei (赞：9)

既然源代码没了，让我们就来想办法破解可执行文件。

使用 `IDA Pro` 进行破解，用 `32` 位以 `PE` 格式打开可执行文件： 

![image-20210125210900859](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210125210900859.png) 

![image-20210126110646925](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126110646925.png)

 `IDA` 会自动生成程序的流程图，以汇编展示程序。

看不懂汇编？没关系，`IDA` 有一个非常强大的功能——自动生成伪代码。

虽说是伪代码，但其实已经非常类似 `C/C++` 语言了。

左边函数选择框里找到 `main` 函数进入，按 `F5` 即可显示伪代码。

![image-20210126110738975](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126110738975.png)

```cpp
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __main();
  scanf("%d%d", &type, &Case);
  while ( Case-- != 0 )
    Do(type);
  return 0;
}
```

这里是主函数，很明显是在读入数据类型和数据组数。

双击 `Do` 函数即可进入，发现以下伪代码。

```cpp
int __cdecl Do(int a1)
{
  int result; // eax
  A *v2; // [esp+0h] [ebp-8h]

  if ( !a1 )
    result = A::Do(v2);
  if ( a1 == 1 )
    result = B::Do(v2);
  if ( a1 == 2 )
    result = C::Do(v2);
  if ( a1 == 3 )
    result = D::Do(v2);
  if ( a1 == 4 )
    result = E::Do(v2);
  if ( a1 == 5 )
    result = F::Do(v2);
  if ( a1 == 6 )
    result = G::Do(v2);
  if ( a1 == 7 )
    result = H::Do(v2);
  if ( a1 == 8 )
    result = I::Do(v2);
  if ( a1 == 9 )
    result = J::Do(v2);
  if ( a1 == 10 )
    result = K::Do(v2);
  return result;
}
```

很明显这是在判断测试点编号，让我们从第一个开始分析。

### Task A

```cpp
int A::Do()
{
  int v1; // [esp+18h] [ebp-10h] BYREF
  int v2[3]; // [esp+1Ch] [ebp-Ch] BYREF
  scanf("%d%d", v2, &v1);
  return printf("%d\n", v2[0] + v1);
}
```

 `A + B Problem` 没什么说的，而且正式测试点也没有 $type=0$ 的数据，忽略。

附上出题人公布的源代码供与伪代码对比：

```cpp
namespace A
{
	void Do()
	{
		int a,b;
		scanf("%d%d",&a,&b);
		printf("%d\n",a+b);
	}
}
```

 ### Task B

```cpp
int B::Do()
{
  signed int v1; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  scanf("%s", Str);
  v1 = strlen(Str);
  if ( pre && (v1 <= 0 || v1 > 10) )
    return puts("invalid input.");
  for ( i = 1; i <= v1; ++i )
    putchar(B::point[*((char *)&B::dr + i) - 97]);
  return putchar(10);
}
```

 $97$ 即是 `a` 对应的 `ascii` 码，这是将输入字符串进行映射变换，变换法则显然就是 `point` 数组，我们双击进入，得到：

```cpp
.rdata:004070F0 __ZN1BL5pointE  db 79h                  ; DATA XREF: B::Do(void)+65↑r
.rdata:004070F1 aFrbkgimujvphat db 'frbkgimujvphatdsnelozcxwq',0
```

这个数组第一位是 `0x79` ，即 `y` ，后面为 `frbkgimujvphatdsnelozcxwq`，连起来就是 `yfrbkgimujvphatdsnelozcxwq`。

出题人公布的源代码：

```cpp
namespace B
{
	const char point[]="yfrbkgimujvphatdsnelozcxwq";
	char dr[105000];
	void Do()
	{
		int i;
		scanf("%s",dr+1);
		int n=strlen(dr+1);
		if(pre)
		{
			if(n<1 || n>10)
			{
				printf("invalid input.\n");
				return;
			}
		}
		for(i=1;i<=n;i++)
			putchar(point[dr[i]-'a']);
		printf("\n");
	}
}
```

### Task C

```cpp
int C::Do()
{
  signed __int64 v1; // rax
  int v2; // eax
  int Format; // [esp+8h] [ebp-58h]
  int v4; // [esp+24h] [ebp-3Ch] BYREF
  __int64 v5; // [esp+28h] [ebp-38h]
  __int64 v6; // [esp+30h] [ebp-30h]
  __int64 v7; // [esp+38h] [ebp-28h]
  __int64 v8; // [esp+40h] [ebp-20h]
  scanf("%d", &v4);
  if ( pre && (v4 < 0 || v4 > 20) )
    return puts("invalid input.");
  v1 = (unsigned int)v4 * (unsigned __int64)(unsigned int)v4;
  HIDWORD(v1) += 2 * (v4 >> 31) * v4;
  Format = v4 * v4;
  v8 = 2016 * (v1 % 233333) % 233333;
  v7 = 4i64 * v4 % 233333;
  v6 = 10i64;
  v5 = (v7 + v8 + 10) % 233333;
  v2 = std::ostream::operator<<(&std::cout, v5, HIDWORD(v5));
  return std::ostream::operator<<(v2, &std::endl<char,std::char_traits<char>>, Format);
}
```

之后我们就换一种解决方法，看到那个万恶的 `puts("invalid input.");` 了吗，我们要让程序不执行它。

回到流程图，找到这一段代码片段

![image-20210125221351617](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210125221351617.png)

我们要绕开分支判定，直接运行主程序（即强制按截图绘制的红色箭头执行，下同）。

科普一点点汇编跳转指令的知识。

```cpp
JMP  //无条件跳转
    
JE   //等于则跳转	同JZ
JNE  //不等于则跳转	同JNZ

JA   //无符号大于则跳转
JNA  //无符号不大于则跳转
JAE  //无符号大于等于则跳转	同JNB
JNAE //无符号不大于等于则跳转	同JB

JB   //无符号小于则跳转
JNB  //无符号不小于则跳转
JBE  //无符号小于等于则跳转 同JNA
JNBE //无符号不小于等于则跳转	同JA

JG   //有符号大于则跳转
JNG  //有符号不大于则跳转
JGE  //有符号大于等于则跳转		同JNL
JNGE //有符号不大于等于则跳转	同JL

JL   //有符号小于则跳转
JNL  //有符号不小于则跳转
JLE  //有符号小于等于则跳转		同JNG
JNLE //有符号不小于等于则跳转	同JG

JZ   //为零则跳转
JNZ  //不为零则跳转

JS   //为负则跳转
JNS  //不为负则跳转

JC   //进位则跳转
JNC  //不进位则跳转

JO   //溢出则跳转
JNO  //不溢出则跳转

JP   //为偶则跳转
JNP  //不为偶则跳转
JPE  //奇偶位置位则跳转		同JP
JPO  //奇偶位复位则跳转		同JNP
```

我们需要将此处的 `jz` 跳转转成 `jmp` 无条件跳转。

点击选中这一行，`Edit->Patch program->Assemble` 即可修改

![image-20210126110818137](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126110818137.png)

![image-20210126003406597](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126003406597.png)

现在就变成直接运行主程序，永远不会进入分支判断了。

![image-20210126003739158](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126003739158.png)

按 `F5` 再检查一下伪代码，发现条件判断确实没了。

```cpp
int C::Do()
{
  signed __int64 v0; // rax
  int v1; // eax
  int Format; // [esp+8h] [ebp-58h]
  int v4; // [esp+24h] [ebp-3Ch] BYREF
  __int64 v5; // [esp+28h] [ebp-38h]
  __int64 v6; // [esp+30h] [ebp-30h]
  __int64 v7; // [esp+38h] [ebp-28h]
  __int64 v8; // [esp+40h] [ebp-20h]
  scanf("%d", &v4);
  v0 = (unsigned int)v4 * (unsigned __int64)(unsigned int)v4;
  HIDWORD(v0) += 2 * (v4 >> 31) * v4;
  Format = v4 * v4;
  v8 = 2016 * (v0 % 233333) % 233333;
  v7 = 4i64 * v4 % 233333;
  v6 = 10i64;
  v5 = (v7 + v8 + 10) % 233333;
  v1 = std::ostream::operator<<(&std::cout, v5, HIDWORD(v5));
  return std::ostream::operator<<(v1, &std::endl<char,std::char_traits<char>>, Format);
}
```

出题人公布的源代码：

```cpp
namespace C
{
	const int mo=233333;
	void Do()
	{
		int n;
		scanf("%d",&n);
		if(pre)
		{
			if(n<0 || n>20)
			{
				printf("invalid input.\n");
				return;
			}
		}
		long long a=n;
		a*=n;
		a%=mo;
		a*=2016;
		a%=mo;
		long long b=n;
		b*=4;
		b%=mo;
		long long c=10;
		long long ans=a+b+c;
		ans%=mo;
		cout<<ans<<endl;
	}
}
```

### Task D

同理，伪代码：

```cpp
int D::Do()
{
  int v1; // [esp+28h] [ebp-20h] BYREF
  int v2; // [esp+2Ch] [ebp-1Ch]
  _TBYTE v3; // [esp+30h] [ebp-18h]
  scanf("%d", &v1);
  if ( pre && (v1 <= 0 || v1 > 50000) )
    return puts("invalid input.");
  *(double *)&v3 = sqrtl((double)v1 / -8.87960937049345e43);
  v2 = (int)floorl(*(long double *)&v3);
  return printf("%d\n", v2);
}
```

流程图：

![image-20210126004209306](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126004209306.png)

修改跳转：

![image-20210126004238766](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126004238766.png)

修改后伪代码：

```cpp
int D::Do()
{
  int v1; // [esp+28h] [ebp-20h] BYREF
  int v2; // [esp+2Ch] [ebp-1Ch]
  _TBYTE v3; // [esp+30h] [ebp-18h]
  scanf("%d", &v1);
  *(double *)&v3 = sqrtl((double)v1 / -8.87960937049345e43);
  v2 = (int)floorl(*(long double *)&v3);
  return printf("%d\n", v2);
}
```

出题人公布的源代码：

```cpp
namespace D
{
	const long double pi=4.0l*atanl(1.0);
	void Do()
	{
		int n;
		scanf("%d",&n);
		if(pre)
		{
			if(n<1 || n>50000)
			{
				printf("invalid input.\n");
				return;
			}
		}
		long double ans=n;
		ans/=pi;
		ans=sqrtl(ans);
		int ansx=floorl(ans);
		printf("%d\n",ansx);
	}
}
```

### Task E

伪代码：

```cpp
int __cdecl E::getf(E *this)
{
  int v2; // [esp+4h] [ebp-14h]

  if ( *(&E::fa + (_DWORD)this) != this )
    *(&E::fa + (_DWORD)this) = (E *)E::getf(*(&E::fa + (_DWORD)this), v2);
  return (int)*(&E::fa + (_DWORD)this);
}

int E::Do()
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // ecx
  unsigned __int64 v5; // rax
  int v6; // eax
  int Format; // [esp+8h] [ebp-38h]
  E *v8; // [esp+18h] [ebp-28h] BYREF
  E *v9; // [esp+1Ch] [ebp-24h] BYREF
  unsigned __int64 v10; // [esp+20h] [ebp-20h]
  __int64 v11; // [esp+28h] [ebp-18h]
  E *i; // [esp+34h] [ebp-Ch]
  scanf("%d%d", &E::n, &E::m);
  for ( i = (E *)1; (int)i <= E::n; i = (E *)((char *)i + 1) )
    *(&E::fa + (_DWORD)i) = i;
  memset(E::cc, 0, 0x62250u);
  while ( E::m-- != 0 )
  {
    scanf("%d%d", &v9, &v8);
    v9 = (E *)E::getf(v9);
    v8 = (E *)E::getf(v8);
    if ( v9 != v8 )
      *(&E::fa + (_DWORD)v9) = v8;
  }
  if ( pre && (E::n > 10 || E::m > 10) )
    return puts("invalid input.");
  for ( i = (E *)1; (int)i <= E::n; i = (E *)((char *)i + 1) )
  {
    v2 = E::getf(i);
    ++E::cc[v2];
  }
  v11 = 0i64;
  for ( i = (E *)1; (int)i <= E::n; i = (E *)((char *)i + 1) )
  {
    v10 = E::cc[(_DWORD)i];
    v3 = E::cc[(_DWORD)i];
    v4 = v3 * HIDWORD(v10) + HIDWORD(v3) * v10;
    v5 = (unsigned int)v10 * (unsigned __int64)(unsigned int)v3;
    HIDWORD(v5) += v4;
    v10 = v5;
    v11 += v5;
  }
  v6 = std::ostream::operator<<(&std::cout, v11, HIDWORD(v11));
  return std::ostream::operator<<(v6, &std::endl<char,std::char_traits<char>>, Format);
}
```

（其实结合数据大概也能看出来，这是在用并查集维护各连通块大小的平方和）

这个流程图稍微有点复杂，不过结合伪代码还是比较容易理解的

![image-20210126005236095](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126005236095.png)



修改此处，让它直接跳转

![image-20210126005443482](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126005443482.png)

修改后流程图：

![image-20210126005403183](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126005403183.png)

修改后伪代码：

```cpp
int E::Do()
{
  int v1; // eax
  __int64 v2; // rax
  int v3; // ecx
  unsigned __int64 v4; // rax
  int v5; // eax
  int Format; // [esp+8h] [ebp-38h]
  E *v8; // [esp+18h] [ebp-28h] BYREF
  E *v9; // [esp+1Ch] [ebp-24h] BYREF
  unsigned __int64 v10; // [esp+20h] [ebp-20h]
  __int64 v11; // [esp+28h] [ebp-18h]
  E *i; // [esp+34h] [ebp-Ch]
  scanf("%d%d", &E::n, &E::m);
  for ( i = (E *)1; (int)i <= E::n; i = (E *)((char *)i + 1) )
    *(&E::fa + (_DWORD)i) = i;
  memset(E::cc, 0, 0x62250u);
  while ( E::m-- != 0 )
  {
    scanf("%d%d", &v9, &v8);
    v9 = (E *)E::getf(v9);
    v8 = (E *)E::getf(v8);
    if ( v9 != v8 )
      *(&E::fa + (_DWORD)v9) = v8;
  }
  for ( i = (E *)1; (int)i <= E::n; i = (E *)((char *)i + 1) )
  {
    v1 = E::getf(i);
    ++E::cc[v1];
  }
  v11 = 0i64;
  for ( i = (E *)1; (int)i <= E::n; i = (E *)((char *)i + 1) )
  {
    v10 = E::cc[(_DWORD)i];
    v2 = E::cc[(_DWORD)i];
    v3 = v2 * HIDWORD(v10) + HIDWORD(v2) * v10;
    v4 = (unsigned int)v10 * (unsigned __int64)(unsigned int)v2;
    HIDWORD(v4) += v3;
    v10 = v4;
    v11 += v4;
  }
  v5 = std::ostream::operator<<(&std::cout, v11, HIDWORD(v11));
  return std::ostream::operator<<(v5, &std::endl<char,std::char_traits<char>>, Format);
}
```

出题公布的源代码：

```cpp
namespace E
{
	const int N = 100500;
	int n,m;
	int fa[N];
	int cc[N];
	int getf(int x)
	{
		if(fa[x]!=x)
			fa[x]=getf(fa[x]);
		return fa[x];
	}
	void Do()
	{
		int i;
		scanf("%d%d",&n,&m);
		for(i=1;i<=n;i++)
			fa[i]=i;
		memset(cc,0,sizeof cc);
		while(m--)
		{
			int a,b;
			scanf("%d%d",&a,&b);
			a=getf(a);
			b=getf(b);
			if(a!=b)
				fa[a]=b;
		}
		if(pre)
		{
			if(n>10 || m>10)
			{
				printf("invalid input.\n");
				return;
			}
		}
		for(i=1;i<=n;i++)
			cc[getf(i)]++;
		long long ans=0;
		for(i=1;i<=n;i++)
		{
			long long now=cc[i];
			now*=cc[i];
			ans+=now;
		}
		cout<<ans<<endl;
	}
}
```

### Task F

伪代码：

```cpp
int __cdecl F::AddEdge(F *this, int a2, int a3)
{
  int result; // eax

  F::next[++F::cc] = F::point[(_DWORD)this];
  F::point[(_DWORD)this] = F::cc;
  F::to[F::cc] = a2;
  result = F::cc;
  F::len[F::cc] = a3;
  return result;
}

bool __cdecl F::GetFa(F *this)
{
  bool result; // al
  int v2; // [esp+4h] [ebp-24h]
  F *v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  F::depth[(_DWORD)this] = F::depth[F::fa[(_DWORD)this]] + 1;
  F::tot[(_DWORD)this] = 1;
  for ( i = F::point[(_DWORD)this]; ; i = F::next[i] )
  {
    result = i != 0;
    if ( !i )
      break;
    v3 = (F *)F::to[i];
    if ( (F *)F::fa[(_DWORD)this] != v3 )
    {
      F::fa[(_DWORD)v3] = (int)this;
      F::falen[(_DWORD)v3] = F::len[i];
      F::GetFa(v3, v2);
      F::tot[(_DWORD)this] += F::tot[(_DWORD)v3];
    }
  }
  return result;
}

bool __cdecl F::GetNum(F *this, int a2, int a3)
{
  bool result; // al
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  F *v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+38h] [ebp+10h]
  int v12; // [esp+38h] [ebp+10h]

  F::num[(_DWORD)this] = a3;
  F::numx[a3] = (int)this;
  F::top[(_DWORD)this] = a2;
  v11 = a3 + 1;
  v9 = F::point[(_DWORD)this];
  v8 = 0;
  while ( 1 )
  {
    result = v9 != 0;
    if ( !v9 )
      break;
    v7 = F::to[v9];
    if ( F::fa[(_DWORD)this] != v7 && F::tot[v7] > F::tot[(_DWORD)v8] )
      v8 = (F *)F::to[v9];
    v9 = F::next[v9];
  }
  if ( v8 )
  {
    F::GetNum(v8, a2, v11, v4);
    v12 = F::tot[(_DWORD)v8] + v11;
    for ( i = F::point[(_DWORD)this]; ; i = F::next[i] )
    {
      result = i != 0;
      if ( !i )
        break;
      v6 = F::to[i];
      if ( F::fa[(_DWORD)this] != v6 && (F *)v6 != v8 )
      {
        F::GetNum((F *)v6, v6, v12, v5);
        v12 += F::tot[v6];
      }
    }
  }
  return result;
}

bool F::GetData()
{
  __int64 v0; // rax
  int v1; // ecx
  __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // rax
  bool result; // al
  int Val; // [esp+4h] [ebp-24h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h] BYREF
  F *v11; // [esp+14h] [ebp-14h] BYREF
  F *v12; // [esp+18h] [ebp-10h] BYREF
  int i; // [esp+1Ch] [ebp-Ch]

  scanf("%d%d", &F::n, &F::m);
  memset(&F::point, 0, 0x62250u);
  F::cc = 0;
  for ( i = 1; i < F::n; ++i )
  {
    scanf("%d%d%d", &v12, &v11, &v10);
    F::AddEdge(v12, (int)v11, v10, v8);
    F::AddEdge(v11, (int)v12, v10, v9);
  }
  F::GetFa((F *)1, Val);
  F::GetNum((F *)1, 1, 1, v7);
  for ( i = 1; i <= F::n; ++i )
  {
    v0 = F::falen[F::numx[i]];
    v1 = i;
    F::qz[2 * i] = v0;
    dword_B102A4[2 * v1] = HIDWORD(v0);
  }
  for ( i = 1; ; ++i )
  {
    result = i <= F::n;
    if ( i > F::n )
      break;
    LODWORD(v2) = F::qz[2 * i];
    HIDWORD(v2) = dword_B102A4[2 * i];
    HIDWORD(v3) = dword_B102A4[2 * i - 2];
    LODWORD(v3) = F::qz[2 * i - 2];
    v4 = v2 + v3;
    LODWORD(v2) = i;
    F::qz[2 * i] = v4;
    dword_B102A4[2 * (_DWORD)v2] = HIDWORD(v4);
  }
  return result;
}

__int64 __cdecl F::Find(F *this, int a2)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // ecx
  __int64 v5; // rcx
  int v6; // eax
  __int64 v7; // rax
  int v8; // ecx
  __int64 v9; // rcx
  int v10; // eax
  __int64 v11; // rax
  int v12; // ecx
  __int64 v13; // rcx
  int v14; // eax
  __int64 v16; // [esp+8h] [ebp-10h]

  v16 = 0i64;
  while ( F::top[(_DWORD)this] != F::top[a2] )
  {
    if ( F::depth[F::top[(_DWORD)this]] <= F::depth[F::top[a2]] )
    {
      v6 = F::num[a2];
      HIDWORD(v7) = dword_B102A4[2 * v6];
      LODWORD(v7) = F::qz[2 * v6];
      v8 = F::num[F::top[a2]] - 1;
      HIDWORD(v9) = dword_B102A4[2 * v8];
      LODWORD(v9) = F::qz[2 * v8];
      v16 += v7 - v9;
      a2 = F::fa[F::top[a2]];
    }
    else
    {
      v2 = F::num[(_DWORD)this];
      HIDWORD(v3) = dword_B102A4[2 * v2];
      LODWORD(v3) = F::qz[2 * v2];
      v4 = F::num[F::top[(_DWORD)this]] - 1;
      HIDWORD(v5) = dword_B102A4[2 * v4];
      LODWORD(v5) = F::qz[2 * v4];
      v16 += v3 - v5;
      this = (F *)F::fa[F::top[(_DWORD)this]];
    }
  }
  if ( F::depth[(_DWORD)this] >= F::depth[a2] )
  {
    v14 = F::num[(_DWORD)this];
    HIDWORD(v11) = dword_B102A4[2 * v14];
    LODWORD(v11) = F::qz[2 * v14];
    v12 = F::num[a2];
  }
  else
  {
    v10 = F::num[a2];
    HIDWORD(v11) = dword_B102A4[2 * v10];
    LODWORD(v11) = F::qz[2 * v10];
    v12 = F::num[(_DWORD)this];
  }
  HIDWORD(v13) = dword_B102A4[2 * v12];
  LODWORD(v13) = F::qz[2 * v12];
  return v11 - v13 + v16;
}

int F::DoIt()
{
  __int64 v0; // rax
  int v3; // eax
  char *Format; // [esp+8h] [ebp-28h]
  int v5; // [esp+18h] [ebp-18h] BYREF
  F *v6; // [esp+1Ch] [ebp-14h] BYREF
  __int64 i; // [esp+20h] [ebp-10h]

  for ( i = 0i64; F::m-- != 0; i ^= v0 )
  {
    scanf("%d%d", &v6, &v5);
    v0 = F::Find(v6, v5);
  }
  if ( pre && (F::n > 10 || F::m > 10) )
    return puts("invalid input.");
  v3 = std::ostream::operator<<(&std::cout, i, HIDWORD(i));
  return std::ostream::operator<<(v3, &std::endl<char,std::char_traits<char>>, Format);
}

int F::Do()
{
  F *v1; // [esp+0h] [ebp-8h]
  F *v2; // [esp+0h] [ebp-8h]

  F::GetData(v1);
  return F::DoIt(v2);
}
```

发现 `invalid input.` 在 `DoIt()` 函数里，修改即可。

![image-20210126010024425](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126010024425.png)

修改后流程图：

![image-20210126010100218](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126010100218.png)

修改后伪代码：

```cpp
int F::DoIt()
{
  __int64 v0; // rax
  int v2; // eax
  int Format; // [esp+8h] [ebp-28h]
  int v5; // [esp+18h] [ebp-18h] BYREF
  F *v6; // [esp+1Ch] [ebp-14h] BYREF
  __int64 i; // [esp+20h] [ebp-10h]

  for ( i = 0i64; F::m-- != 0; i ^= v0 )
  {
    scanf("%d%d", &v6, &v5);
    v0 = F::Find(v6, v5);
  }
  v2 = std::ostream::operator<<(&std::cout, i, HIDWORD(i));
  return std::ostream::operator<<(v2, &std::endl<char,std::char_traits<char>>, Format);
}
```

出题人公布的源代码：

```cpp
namespace F
{
	const int N = 100500;
	const int M = 270000;
	int point[N],to[M],next[M],len[M],cc;
	int fa[N],falen[N],tot[N],depth[N];
	int num[N],top[N],numx[N];
	int n,m;
	long long qz[N];
	void AddEdge(int x,int y,int z)
	{
		cc++;
		next[cc]=point[x];
		point[x]=cc;
		to[cc]=y;
		len[cc]=z;
	}
	void GetFa(int x)
	{
		depth[x]=depth[fa[x]]+1;
		tot[x]=1;
		int now=point[x];
		while(now)
		{
			int tox=to[now];
			if(tox!=fa[x])
			{
				fa[tox]=x;
				falen[tox]=len[now];
				GetFa(tox);
				tot[x]+=tot[tox];
			}
			now=next[now];
		}
	}
	void GetNum(int x,int grand,int v)
	{
		num[x]=v;
		numx[v]=x;
		top[x]=grand;
		v++;
		int now=point[x];
		int prefer=0;
		while(now)
		{
			int tox=to[now];
			if(tox!=fa[x] && tot[tox]>tot[prefer])
				prefer=tox;
			now=next[now];
		}
		if(!prefer)
			return;
		GetNum(prefer,grand,v);
		v+=tot[prefer];
		now=point[x];
		while(now)
		{
			int tox=to[now];
			if(tox!=fa[x] && tox!=prefer)
			{
				GetNum(tox,tox,v);
				v+=tot[tox];
			}
			now=next[now];
		}
	}
	void GetData()
	{
		int i;
		scanf("%d%d",&n,&m);
		memset(point,0,sizeof point);
		cc=0;
		for(i=1;i<n;i++)
		{
			int a,b,c;
			scanf("%d%d%d",&a,&b,&c);
			AddEdge(a,b,c);
			AddEdge(b,a,c);
		}
		GetFa(1);
		GetNum(1,1,1);
		for(i=1;i<=n;i++)
			qz[i]=falen[numx[i]];
		for(i=1;i<=n;i++)
			qz[i]+=qz[i-1];
	}
	long long Find(int x,int y)
	{
		long long res=0;
		while(top[x]!=top[y])
		{
			if(depth[top[x]]>depth[top[y]])
			{
				res+=(qz[num[x]]-qz[num[top[x]]-1]);
				x=fa[top[x]];
			}
			else
			{
				res+=(qz[num[y]]-qz[num[top[y]]-1]);
				y=fa[top[y]];
			}
		}
		if(depth[x]<depth[y])
			res+=(qz[num[y]]-qz[num[x]]);
		else
			res+=(qz[num[x]]-qz[num[y]]);
		return res;
	}
	void DoIt()
	{
		long long ans=0;
		while(m--)
		{
			int a,b;
			scanf("%d%d",&a,&b);
			ans^=Find(a,b);
		}
		if(pre)
		{
			if(n>10 || m>10)
			{
				printf("invalid input.\n");
				return;
			}
		}
		cout<<ans<<endl;
	}
	void Do()
	{
		GetData();
		DoIt();
	}
}
```

### Task G

伪代码：

```cpp
int __cdecl G::AddEdge(G *this, int a2, int a3)
{
  int result; // eax

  G::next[++G::cc] = G::point[(_DWORD)this];
  G::point[(_DWORD)this] = G::cc;
  G::to[G::cc] = a2;
  result = G::cc;
  G::len[G::cc] = a3;
  return result;
}
bool __cdecl G::GetFa(G *this)
{
  bool result; // al
  int v2; // [esp+4h] [ebp-24h]
  G *v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  G::depth[(_DWORD)this] = G::depth[G::fa[(_DWORD)this]] + 1;
  G::tot[(_DWORD)this] = 1;
  for ( i = G::point[(_DWORD)this]; ; i = G::next[i] )
  {
    result = i != 0;
    if ( !i )
      break;
    v3 = (G *)G::to[i];
    if ( (G *)G::fa[(_DWORD)this] != v3 )
    {
      G::fa[(_DWORD)v3] = (int)this;
      G::falen[(_DWORD)v3] = G::len[i];
      G::GetFa(v3, v2);
      G::tot[(_DWORD)this] += G::tot[(_DWORD)v3];
    }
  }
  return result;
}
bool __cdecl G::GetNum(G *this, int a2, int a3)
{
  bool result; // al
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  G *v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+38h] [ebp+10h]
  int v12; // [esp+38h] [ebp+10h]

  *(&G::num + (_DWORD)this) = (G *)a3;
  G::numx[a3] = (int)this;
  G::top[(_DWORD)this] = a2;
  v11 = a3 + 1;
  v9 = G::point[(_DWORD)this];
  v8 = 0;
  while ( 1 )
  {
    result = v9 != 0;
    if ( !v9 )
      break;
    v7 = G::to[v9];
    if ( G::fa[(_DWORD)this] != v7 && G::tot[v7] > G::tot[(_DWORD)v8] )
      v8 = (G *)G::to[v9];
    v9 = G::next[v9];
  }
  if ( v8 )
  {
    G::GetNum(v8, a2, v11, v4);
    v12 = G::tot[(_DWORD)v8] + v11;
    for ( i = G::point[(_DWORD)this]; ; i = G::next[i] )
    {
      result = i != 0;
      if ( !i )
        break;
      v6 = G::to[i];
      if ( G::fa[(_DWORD)this] != v6 && (G *)v6 != v8 )
      {
        G::GetNum((G *)v6, v6, v12, v5);
        v12 += G::tot[v6];
      }
    }
  }
  return result;
}
bool G::GetData()
{
  int v0; // edx
  bool result; // al
  int v2; // [esp+10h] [ebp-18h] BYREF
  G *v3; // [esp+14h] [ebp-14h] BYREF
  G *v4; // [esp+18h] [ebp-10h] BYREF
  int i; // [esp+1Ch] [ebp-Ch]

  scanf("%d%d", &G::n, &G::m);
  memset(G::point, 0, 0x62250u);
  G::cc = 0;
  for ( i = 1; i < G::n; ++i )
  {
    scanf("%d%d%d", &v4, &v3, &v2);
    G::AddEdge(v4, (int)v3, v2);
    G::AddEdge(v3, (int)v4, v2);
  }
  G::GetFa((G *)1);
  G::GetNum((G *)1, 1, 1);
  for ( i = 1; i <= G::n; ++i )
    G::tree[i + 0x20000] = G::falen[G::numx[i]];
  for ( i = 0x1FFFF; ; --i )
  {
    result = i > 0;
    if ( i <= 0 )
      break;
    v0 = *(_DWORD *)std::min<int>(&G::tree[2 * i], &G::tree[2 * i + 1]);
    G::tree[i] = v0;
  }
  return result;
}
int __cdecl G::MinV(G *this, int a2)
{
  int v3[3]; // [esp+1Ch] [ebp-Ch] BYREF
  int thisa; // [esp+30h] [ebp+8h]
  int v5; // [esp+34h] [ebp+Ch]

  thisa = (int)this + 0x1FFFF;
  v5 = a2 + 131073;
  v3[0] = 1987654321;
  while ( (thisa ^ v5) != 1 )
  {
    if ( (thisa & 1) == 0 )
      v3[0] = *(_DWORD *)std::min<int>(v3, &G::tree[thisa ^ 1]);
    if ( v5 % 2 == 1 )
      v3[0] = *(_DWORD *)std::min<int>(v3, &G::tree[v5 ^ 1]);
    thisa >>= 1;
    v5 >>= 1;
  }
  return v3[0];
}
int __cdecl G::Find(G *this, int a2)
{
  int v3; // [esp+1Ch] [ebp-1Ch] BYREF
  int v4; // [esp+20h] [ebp-18h] BYREF
  int v5; // [esp+24h] [ebp-14h] BYREF
  int v6; // [esp+28h] [ebp-10h] BYREF
  int v7[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v3 = 1987654321;
  while ( G::top[(_DWORD)this] != G::top[a2] )
  {
    if ( G::depth[G::top[(_DWORD)this]] <= G::depth[G::top[a2]] )
    {
      v5 = G::MinV(*(&G::num + G::top[a2]), (int)*(&G::num + a2));
      v3 = *(_DWORD *)std::min<int>(&v3, &v5);
      a2 = G::fa[G::top[a2]];
    }
    else
    {
      v4 = G::MinV(*(&G::num + G::top[(_DWORD)this]), (int)*(&G::num + (_DWORD)this));
      v3 = *(_DWORD *)std::min<int>(&v3, &v4);
      this = (G *)G::fa[G::top[(_DWORD)this]];
    }
  }
  if ( G::depth[(_DWORD)this] >= G::depth[a2] )
  {
    if ( G::depth[(_DWORD)this] > G::depth[a2] )
    {
      v7[0] = G::MinV((G *)((char *)*(&G::num + a2) + 1), (int)*(&G::num + (_DWORD)this));
      v3 = *(_DWORD *)std::min<int>(&v3, v7);
    }
  }
  else
  {
    v6 = G::MinV((G *)((char *)*(&G::num + (_DWORD)this) + 1), (int)*(&G::num + a2));
    v3 = *(_DWORD *)std::min<int>(&v3, &v6);
  }
  return v3;
}
int G::DoIt()
{
  int v0; // eax
  int v3; // eax
  int v4; // [esp+8h] [ebp-24h]
  int v5; // [esp+18h] [ebp-14h] BYREF
  G *v6; // [esp+1Ch] [ebp-10h] BYREF
  int i; // [esp+20h] [ebp-Ch]

  for ( i = 0; G::m-- != 0; i ^= v0 )
  {
    scanf("%d%d", &v6, &v5);
    v0 = G::Find(v6, v5);
  }
  if ( pre && (G::n > 10 || G::m > 10) )
    return puts("invalid input.");
  v3 = std::ostream::operator<<(&std::cout, i);
  return std::ostream::operator<<(v3, &std::endl<char,std::char_traits<char>>, v4);
}
int G::Do()
{
  G *v1; // [esp+0h] [ebp-8h]
  G *v2; // [esp+0h] [ebp-8h]

  G::GetData(v1);
  return G::DoIt(v2);
}
```

同理，发现 `invalid input.` 在 `DoIt()` 函数里，改它！

![image-20210126015116318](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126015116318.png)

修改后流程图：

![image-20210126015202289](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126015202289.png)

修改后伪代码：

```cpp
int G::DoIt()
{
  int v0; // eax
  int v2; // eax
  int v4; // [esp+8h] [ebp-24h]
  int v5; // [esp+18h] [ebp-14h] BYREF
  G *v6; // [esp+1Ch] [ebp-10h] BYREF
  int i; // [esp+20h] [ebp-Ch]

  for ( i = 0; G::m-- != 0; i ^= v0 )
  {
    scanf("%d%d", &v6, &v5);
    v0 = G::Find(v6, v5);
  }
  v2 = std::ostream::operator<<(&std::cout, i);
  return std::ostream::operator<<(v2, &std::endl<char,std::char_traits<char>>, v4);
}
```

出题人公布的源代码：

```cpp
namespace G
{
	const int N = 100500;
	const int M = 270000;
	const int T = 131072;
	const int inf = 1987654321;
	int point[N],to[M],next[M],len[M],cc;
	int fa[N],falen[N],tot[N],depth[N];
	int num[N],top[N],numx[N];
	int n,m;
	int tree[M];
	void AddEdge(int x,int y,int z)
	{
		cc++;
		next[cc]=point[x];
		point[x]=cc;
		to[cc]=y;
		len[cc]=z;
	}
	void GetFa(int x)
	{
		depth[x]=depth[fa[x]]+1;
		tot[x]=1;
		int now=point[x];
		while(now)
		{
			int tox=to[now];
			if(tox!=fa[x])
			{
				fa[tox]=x;
				falen[tox]=len[now];
				GetFa(tox);
				tot[x]+=tot[tox];
			}
			now=next[now];
		}
	}
	void GetNum(int x,int grand,int v)
	{
		num[x]=v;
		numx[v]=x;
		top[x]=grand;
		v++;
		int now=point[x];
		int prefer=0;
		while(now)
		{
			int tox=to[now];
			if(tox!=fa[x] && tot[tox]>tot[prefer])
				prefer=tox;
			now=next[now];
		}
		if(!prefer)
			return;
		GetNum(prefer,grand,v);
		v+=tot[prefer];
		now=point[x];
		while(now)
		{
			int tox=to[now];
			if(tox!=fa[x] && tox!=prefer)
			{
				GetNum(tox,tox,v);
				v+=tot[tox];
			}
			now=next[now];
		}
	}
	void GetData()
	{
		int i;
		scanf("%d%d",&n,&m);
		memset(point,0,sizeof point);
		cc=0;
		for(i=1;i<n;i++)
		{
			int a,b,c;
			scanf("%d%d%d",&a,&b,&c);
			AddEdge(a,b,c);
			AddEdge(b,a,c);
		}
		GetFa(1);
		GetNum(1,1,1);
		for(i=1;i<=n;i++)
			tree[i+T]=falen[numx[i]];
		for(i=T-1;i>=1;i--)
			tree[i]=min(tree[i*2],tree[i*2+1]);
	}
	int MinV(int l,int r)
	{
		l+=T-1;
		r+=T+1;
		int res=inf;
		while(l^r^1)
		{
			if(l%2==0)
				res=min(res,tree[l^1]);
			if(r%2==1)
				res=min(res,tree[r^1]);
			l>>=1;
			r>>=1;
		}
		return res;
	}
	int Find(int x,int y)
	{
		int res=inf;
		while(top[x]!=top[y])
		{
			if(depth[top[x]]>depth[top[y]])
			{
				res=min(res,MinV(num[top[x]],num[x]));
				x=fa[top[x]];
			}
			else
			{
				res=min(res,MinV(num[top[y]],num[y]));
				y=fa[top[y]];
			}
		}
		if(depth[x]<depth[y])
			res=min(res,MinV(num[x]+1,num[y]));
		else if(depth[x]>depth[y])
			res=min(res,MinV(num[y]+1,num[x]));
		return res;
	}
	void DoIt()
	{
		int ans=0;
		while(m--)
		{
			int a,b;
			scanf("%d%d",&a,&b);
			ans^=Find(a,b);
		}
		if(pre)
		{
			if(n>10 || m>10)
			{
				printf("invalid input.\n");
				return;
			}
		}
		cout<<ans<<endl;
	}
	void Do()
	{
		GetData();
		DoIt();
	}
}
```

### Task H

伪代码：

```cpp
int H::Do()
{
  __int64 v1; // rax
  int v2; // ecx
  unsigned __int64 v3; // rax
  __int64 v4; // rax
  int v5; // ecx
  unsigned __int64 v6; // rax
  int v7; // eax
  int Format; // [esp+8h] [ebp-38h]
  int v9; // [esp+18h] [ebp-28h] BYREF
  int v10; // [esp+1Ch] [ebp-24h] BYREF
  unsigned __int64 v11; // [esp+20h] [ebp-20h]
  __int64 v12; // [esp+28h] [ebp-18h]
  int j; // [esp+30h] [ebp-10h]
  int i; // [esp+34h] [ebp-Ch]

  scanf("%d%d", &v10, &v9);
  if ( pre && (v10 > 20 || v9 > 20) )
    return puts("invalid input.");
  for ( i = 1; i <= v10; ++i )
    H::val[i] = i;
  for ( i = 1; i <= v10; ++i )
  {
    for ( j = 2 * i; j <= v10; j += i )
      H::val[j] -= H::val[i];
  }
  v12 = 0i64;
  for ( i = 1; i <= v10; ++i )
  {
    v11 = H::val[i];
    v1 = v10 / i;
    v2 = v1 * HIDWORD(v11) + HIDWORD(v1) * v11;
    v3 = (unsigned int)v11 * (unsigned __int64)(unsigned int)v1;
    LODWORD(v11) = v3;
    HIDWORD(v11) = HIDWORD(v3) + v2;
    v4 = v9 / i;
    v5 = v4 * HIDWORD(v11) + HIDWORD(v4) * v11;
    v6 = (unsigned int)v11 * (unsigned __int64)(unsigned int)v4;
    HIDWORD(v6) += v5;
    v11 = v6;
    v12 += v6;
  }
  v7 = std::ostream::operator<<(&std::cout, v12, HIDWORD(v12));
  return std::ostream::operator<<(v7, &std::endl<char,std::char_traits<char>>, Format);
}
```

在流程图中此分支较分散，不太好找，不过找到退出代码后往上反推也能很容易找到

![image-20210126020200902](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126020200902.png)

修改后流程图：

![image-20210126020254049](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126020254049.png)

修改后伪代码就不放了，就是把 `invalid input.` 去了。

出题人公布的源代码：

```cpp
namespace H
{
	const int N = 1005000;
	int val[N];
	void Do()
	{
		int n,m,i,j;
		scanf("%d%d",&n,&m);
		if(pre)
		{
			if(n>20 || m>20)
			{
				printf("invalid input.\n");
				return;
			}
		}
		for(i=1;i<=n;i++)
			val[i]=i;
		for(i=1;i<=n;i++)
		{
			for(j=i+i;j<=n;j+=i)
				val[j]-=val[i];
		}
		long long ans=0;
		for(i=1;i<=n;i++)
		{
			long long now=val[i];
			now*=(n/i);
			now*=(m/i);
			ans+=now;
		}
		cout<<ans<<endl;
	}
}
```

### Task I

```cpp
bool __cdecl I::cmp(I *this, int a2)
{
  return I::xu[(_DWORD)this] < I::xu[a2];
}

int I::Do()
{
  int *v2; // ecx
  int v3; // eax
  int *v4; // ecx
  int v5; // eax
  int *v7; // eax
  int v8; // eax
  int Format; // [esp+8h] [ebp-38h]
  int v10; // [esp+18h] [ebp-28h] BYREF
  int v11; // [esp+1Ch] [ebp-24h] BYREF
  __int64 v12; // [esp+20h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-14h]
  int v14; // [esp+30h] [ebp-10h]
  int i; // [esp+34h] [ebp-Ch]

  scanf("%d", &I::n);
  for ( i = 1; i <= I::n; ++i )
    scanf("%d", &I::xu[i]);
  I::xu[I::n + 1] = 0;
  if ( pre && (I::n <= 0 || I::n > 10) )
    return puts("invalid input.");
  for ( i = 1; i <= I::n; ++i )
    I::sa[i] = i;
  std::sort<int *,bool (*)(int,int)>(&unk_1AAAD84, &I::sa[I::n + 1], I::cmp);
  v13 = 0;
  for ( i = 1; i <= I::n; ++i )
  {
    for ( I::rank[I::sa[i]] = ++v13; i < I::n && I::xu[I::sa[i]] == I::xu[I::sa[i + 1]]; I::rank[I::sa[i]] = v13 )
      ++i;
  }
  v14 = 1;
  while ( v13 < I::n )
  {
    for ( i = 1; i <= I::n; ++i )
      ++I::cc[I::rank[i + v14]];
    for ( i = 1; i <= v13; ++i )
      I::cc[i] += I::cc[i - 1];
    for ( i = 1; i <= I::n; ++i )
    {
      v2 = &I::cc[I::rank[i + v14]];
      v3 = *v2;
      I::sec[v3] = i;
      *v2 = v3 - 1;
    }
    for ( i = 0; i <= v13; ++i )
      I::cc[i] = 0;
    for ( i = 1; i <= I::n; ++i )
      ++I::cc[I::rank[i]];
    for ( i = 1; i <= v13; ++i )
      I::cc[i] += I::cc[i - 1];
    for ( i = I::n; i > 0; --i )
    {
      v4 = &I::cc[I::rank[I::sec[i]]];
      v5 = *v4;
      I::sa[v5] = I::sec[i];
      *v4 = v5 - 1;
    }
    for ( i = 0; i <= v13; ++i )
      I::cc[i] = 0;
    v13 = 0;
    for ( i = 1; i <= I::n; ++i )
    {
      for ( I::sec[I::sa[i]] = ++v13;
            i < I::n
         && I::rank[I::sa[i]] == I::rank[I::sa[i + 1]]
         && I::rank[I::sa[i] + v14] == I::rank[I::sa[i + 1] + v14];
            I::sec[I::sa[i]] = v13 )
      {
        ++i;
      }
    }
    for ( i = 1; i <= I::n; ++i )
      I::rank[i] = I::sec[i];
    v14 *= 2;
  }
  for ( i = 1; i <= I::n; ++i )
  {
    if ( I::rank[i] != 1 )
    {
      v10 = I::h[i - 1] - 1;
      v11 = 0;
      v7 = (int *)std::max<int>(&v11, &v10);
      for ( I::h[i] = *v7; I::xu[I::h[i] + i] == I::xu[I::sa[I::rank[i] - 1] + I::h[i]]; ++I::h[i] )
        ;
    }
  }
  v12 = 0i64;
  for ( i = 1; i <= I::n; ++i )
    v12 += i;
  for ( i = 1; i <= I::n; ++i )
    v12 -= I::h[i];
  v8 = std::ostream::operator<<(&std::cout, v12, HIDWORD(v12));
  return std::ostream::operator<<(v8, &std::endl<char,std::char_traits<char>>, Format);
}
```

![image-20210126100737392](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126100737392.png)

修改后流程图：

![image-20210126100854559](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126100854559.png)

出题人公布的源代码：

```cpp
namespace I
{
	const int N = 1000500;
	const int M = 2000500;
	int n;
	int xu[N];
	int sa[N],rank[M],sec[N],cc[N];
	int h[N];
	bool cmp(int x,int y)
	{
		return(xu[x]<xu[y]);
	}
	void Do()
	{
		int i,j;
		int p;
		scanf("%d",&n);
		for(i=1;i<=n;i++)
			scanf("%d",&xu[i]);
		xu[n+1]=0;
		memset(h,0,sizeof h);
		memset(sec,0,sizeof sec);
		memset(rank,0,sizeof rank);
		memset(sa,0,sizeof sa);
		if(pre)
		{
			if(n<1 || n>10)
			{
				printf("invalid input.\n");
				return;
			}
		}
		for(i=1;i<=n;i++)
			sa[i]=i;
		sort(sa+1,sa+n+1,cmp);
		p=0;
		for(i=1;i<=n;i++)
		{
			p++;
			rank[sa[i]]=p;
			while(i<n && xu[sa[i]]==xu[sa[i+1]])
			{
				i++;
				rank[sa[i]]=p;
			}
		}
		for(j=1;p<n;j<<=1)
		{
			for(i=1;i<=n;i++)
				cc[rank[i+j]]++;
			for(i=1;i<=p;i++)
				cc[i]+=cc[i-1];
			for(i=1;i<=n;i++)
				sec[cc[rank[i+j]]--]=i;
			for(i=0;i<=p;i++)
				cc[i]=0;
			for(i=1;i<=n;i++)
				cc[rank[i]]++;
			for(i=1;i<=p;i++)
				cc[i]+=cc[i-1];
			for(i=n;i>=1;i--)
				sa[cc[rank[sec[i]]]--]=sec[i];
			for(i=0;i<=p;i++)
				cc[i]=0;
			p=0;
			for(i=1;i<=n;i++)
			{
				p++;
				sec[sa[i]]=p;
				while(i<n && rank[sa[i]]==rank[sa[i+1]] && rank[sa[i]+j]==rank[sa[i+1]+j])
				{
					i++;
					sec[sa[i]]=p;
				}
			}
			for(i=1;i<=n;i++)
				rank[i]=sec[i];
		}
		for(i=1;i<=n;i++)
		{
			if(rank[i]==1)
				continue;
			h[i]=max(0,h[i-1]-1);
			while(xu[i+h[i]]==xu[sa[rank[i]-1]+h[i]])
				h[i]++;
		}
		long long ans=0;
		for(i=1;i<=n;i++)
			ans+=i;
		for(i=1;i<=n;i++)
			ans-=h[i];
		cout<<ans<<endl;
	}
}
```

### Task J

伪代码：

```cpp
bool J::cmpx(J *this, Node a2, Node a3, int a4, ...)
{
  double v5[2]; // [esp+0h] [ebp-30h] BYREF
  double v6[2]; // [esp+10h] [ebp-20h] BYREF
  __int128 v7; // [esp+48h] [ebp+18h] BYREF
  va_list va; // [esp+48h] [ebp+18h]
  va_list va1; // [esp+58h] [ebp+28h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, _OWORD);
  qmemcpy(v6, &this, sizeof(v6));
  qmemcpy(v5, va, sizeof(v5));
  return v5[0] > v6[0];
}

bool J::cmpy(J *this, Node a2, Node a3, int a4, ...)
{
  double v5[2]; // [esp+0h] [ebp-30h] BYREF
  double v6[2]; // [esp+10h] [ebp-20h] BYREF
  __int128 v7; // [esp+48h] [ebp+18h] BYREF
  va_list va; // [esp+48h] [ebp+18h]
  va_list va1; // [esp+58h] [ebp+28h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, _OWORD);
  qmemcpy(v6, &this, sizeof(v6));
  qmemcpy(v5, va, sizeof(v5));
  return v5[1] > v6[1];
}

double J::dis(J *this, Node a2, Node a3, int a4, ...)
{
  double v5[2]; // [esp+20h] [ebp-48h] BYREF
  double v6[2]; // [esp+30h] [ebp-38h] BYREF
  double X; // [esp+48h] [ebp-20h]
  __int128 v8; // [esp+80h] [ebp+18h] BYREF
  va_list va; // [esp+80h] [ebp+18h]
  va_list va1; // [esp+90h] [ebp+28h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v8 = va_arg(va1, _OWORD);
  qmemcpy(v6, &this, sizeof(v6));
  qmemcpy(v5, va, sizeof(v5));
  X = (v6[0] - v5[0]) * (v6[0] - v5[0]) + (v6[1] - v5[1]) * (v6[1] - v5[1]);
  return sqrt(X);
}
//Solve和Do函数由于函数参数无法识别，函数生成伪代码失败
```

没事，有流程图也够了

![image-20210126102657100](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126102657100.png)

修改后流程图：

![image-20210126102731925](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126102731925.png)

出题人公布的源代码：

```cpp
namespace J
{
	const int N = 1005000;
	struct Node
	{
		double zx,zy;
	}xu[N],zhan[N],jie[N];
	int top;
	int n;
	double ans;
	bool cmpx(struct Node x,struct Node y)
	{
		return (x.zx<y.zx);
	}
	bool cmpy(struct Node x,struct Node y)
	{
		return x.zy<y.zy;
	}
	double dis(struct Node x,struct Node y)
	{
		double res=(x.zx-y.zx)*(x.zx-y.zx)+(x.zy-y.zy)*(x.zy-y.zy);
		res=sqrt(res);
		return res;
	}
	void Solve(int l,int r)
	{
		if(l==r)
			return;
		int mid=(l+r)>>1;
		double zhong=xu[mid].zx;
		Solve(l,mid);
		Solve(mid+1,r);
		top=0;
		int i=l,j=mid+1,k=l;
		while(i<=mid && j<=r)
		{
			if(xu[i].zy<xu[j].zy)
			{
				jie[k++]=xu[i];
				if(zhong-xu[i].zx<ans)
					zhan[++top]=xu[i];
				i++;
			}
			else
			{
				jie[k++]=xu[j];
				if(xu[j].zx-zhong<ans)
					zhan[++top]=xu[j];
				j++;
			}
		}
		while(i<=mid)
		{
			jie[k++]=xu[i];
			if(zhong-xu[i].zx<ans)
				zhan[++top]=xu[i];
			i++;
		}
		while(j<=r)
		{
			jie[k++]=xu[j];
			if(xu[j].zx-zhong<ans)
				zhan[++top]=xu[j];
			j++;
		}
		for(i=l;i<=r;i++)
			xu[i]=jie[i];
		for(i=1;i<=top;i++)
		{
			for(j=i+1;j<=i+5 && j<=top;j++)
			{
				double now=dis(zhan[i],zhan[j]);
				if(now<ans)
					ans=now;
			}
		}
	}
	void Do()
	{
		int i;
		scanf("%d",&n);
		for(i=1;i<=n;i++)
			scanf("%lf%lf",&xu[i].zx,&xu[i].zy);
		if(pre)
		{
			if(n<2 || n>10)
			{
				printf("invalid input.\n");
				return;
			}
		}
		sort(xu+1,xu+n+1,cmpx);
		ans=dis(xu[1],xu[2]);
		Solve(1,n);
		printf("%.3f\n",ans);
	}
}
```

### Task K

伪代码：

```cpp
int K::Do()
{
  return puts("invalid input!");
}
```

不用看流程图了， 答案就是 `puts("invalid input!");`。

出题人公布的源代码：

```cpp
namespace K
{
	void Do()
	{
		printf("invalid input!\n");
	}
}
```

---------------------

程序修改完成，接下来我们需要导出破解后的程序。

![image-20210126110916930](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126110916930.png)

`Edit->Patch program->Apply patches to input file`

会覆盖源程序，建议勾选生成备份文件

![image-20210126103138179](https://gitee.com/tuxiaobei/oi/raw/master/images/image-20210126103138179.png)

点击 `OK` 即可。

生成答案：

```cpp
#include <bits/stdc++.h>
char s[256];
int main()
{
	for (int i = 1; i <= 10; i++) {
		sprintf(s, "lost.exe < input%d.txt > output%d.txt", i , i);
		system(s);
	}
}
```

不过这样提交在 `#8` 会有两个数据答案错误，只能得到 $98$ 分（应该是出题人的程序出锅了

~~10 分钟切黑题成为可能~~

完结撒花！

---

## 作者：liangbowen (赞：8)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P5246)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17566890.html)

耗时一个晚上，没看题解把消失的源代码切了，很高兴，来写篇题解！

点击 $\color{red}\textbf{每个子任务的标题}$ 可以查看代码。

如果不想看心路历程，请 $\color{red}\textbf{划到最底下}$ 看一行流题解。

## [Task 1](https://www.luogu.com.cn/paste/k3xsjnep)

是一堆小写字母，往 exe 里挨个输入 $\texttt{a}\sim\texttt{z}$ 就能发现这是一个映射。直接做即可。

## [Task 2](https://www.luogu.com.cn/paste/4rzjpvrl)

`input2.txt` 看起来非常简单，但是输进去 $\text{exe}$ 我就破防了：这是啥啊？？？？？

> 输入 $0\sim10$，答案 $a_i$ 为 $10, 2030, 8082, 18166, 32282, 50430, 72610, 98822, 129066, 163342, 201650$。

稍微思考一下就不难了。注意到 $8082\approx 2030\times 2^2$，$18166 \approx2030\times 3^2$。尝试变成整除，于是发现 $-10$ 就整除了。

> $b_i=\dfrac{a_i-10}{i}$，答案 $b_i$ 为 $0, 2020, 4036, 6052, 8068, 10084, 12100, 14116, 16132, 18148, 20164$。

不看前面几项。我草这是等差数列。差是 $2016$，很吉祥啊！

所以 $b_n=2020+2016(n-1)$，$a_n=n\cdot b_n+10=n(2020+2016(n-1))+10$，输出即可。

很快把公式抄进代码里，和 $1\sim20$ 的正确答案比一下。？？？？？？？？为啥这正确答案还带突然变小的？？？？？？？ 

这并不困难。发现突然变小的那一项和我们的答案正好差 $233333$，很容易想到是 $\bmod 233333$ 啦。

## [Task 3](https://www.luogu.com.cn/paste/x9xph3ge)

<https://oeis.org/A097430>。

## [Task 4](https://www.luogu.com.cn/paste/0thou9ik)

`input4.txt` 显然是读入一张图。随便输入一点普通图，发现结果总是 $n^2$，直到你输入了一个不连通的图 $(V=\{1, 2, 3, 4, 5\}, E=\{\small(1, 2), (2, 3), (4, 5)\normalsize\})$，发现答案是 $13=3^2+2^2$。这就很显然了，答案即 $\sum\textbf{连通块的大小}^2$。

## [Task 5](https://www.luogu.com.cn/paste/nokyxnd8)

`input5.txt` 经过观察，先读入 $n-1$ 条有权边（应该是构成一棵树），再读入 $m$ 组点对，计算答案。

先试试 $m=1$ 的情况。对于 $(u,v)$，容易发现就是 $\operatorname{dist}(u,v)$。

再试试 $m=2$，发现答案非常神秘，为啥那两个点对的距离是 $5$ 和 $20$，最后的答案还能是 $17$ 啊。于是试了一堆二元运算符后发现答案是**所有距离的异或和**，就离谱。

## [Task 6](https://www.luogu.com.cn/paste/ob7gy5p2)

`input6.txt` 长得和 `input5.txt` 一样捏。所以就很轻松了，发现不同点在于 $\operatorname{dist}(u,v)$ 变成了 $\min\limits_{t\in(u\to v)} w_t$。仍然是异或全部权值。

然后你发现你错了。实际上可以通过输入询问点对 $(u,u)$ 来获取 $\text{minn}$ 的初值应为 $1987654321$。

## [Task 7](https://www.luogu.com.cn/paste/p4ed8z28)

（表格在洛谷可能会寄，请移步[博客园](https://www.cnblogs.com/liangbowen/p/17566890.html)）

输入规模又变小了。设每次读入的两数为 $(n,m)$，直接打表：

| $n$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $m=1$ | $1$ | $2$ | $3$ | $4$ | $5$ |  $6$ | $7$ | $8$ | $9$ |
| $m=2$ | $2$ | $5$ | $7$ | $10$ | $12$ | $15$ | $17$ | $20$ | $22$ |
| $m=3$ | $3$ | $7$ | $12$ | $16$ | $19$ | $25$ | $28$ | $32$ | $37$ |
| $m=4$ | $4$ | $10$ | $16$ | $24$ | $28$ | $36$ | $40$ | $48$ | $54$ |
| $m=5$ | $5$ | $12$ | $19$ | $28$ | $37$ | $46$ | $51$ | $60$ | $67$ |

观察 $(m=2)\Rightarrow(m=3)$，打表 $a_{n,m}-a_{n,m-1}$：

| $n$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $m=(1\Rightarrow2)$ | $1$ | $3$ | $4$ | $6$ | $7$ |  $9$ | $10$ | $12$ | $13$ |
| $m=(2\Rightarrow3)$ | $1$ | $2$ | $5$ | $6$ | $7$ | $10$ | $11$ | $12$ | $15$ |
| $m=(3\Rightarrow4)$ | $1$ | $3$ | $4$ | $8$ | $9$ | $11$ | $12$ | $16$ | $17$ |
| $m=(4\Rightarrow5)$ | $1$ | $2$ | $3$ | $4$ | $9$ | $10$ | $11$ | $12$ | $13$ |

再差分，打表 $b_{n,m}-b_{n-1,m}$：

| $n$ | $1\Rightarrow2$ | $2\Rightarrow3$ | $3\Rightarrow4$ | $4\Rightarrow5$ | $5\Rightarrow6$ | $6\Rightarrow7$ | $7\Rightarrow8$ | $8\Rightarrow9$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $m=(1\Rightarrow2)$ | $2$ | $1$ | $2$ | $1$ | $2$ |  $1$ | $2$ | $1$ |
| $m=(2\Rightarrow3)$ | $1$ | $3$ | $1$ | $1$ | $3$ | $1$ | $1$ | $3$ |
| $m=(3\Rightarrow4)$ | $2$ | $1$ | $4$ | $2$ | $1$ | $4$ | $2$ | $1$ |
| $m=(4\Rightarrow5)$ | $1$ | $1$ | $1$ | $5$ | $1$ | $1$ | $1$ | $1$ |

整理一下。

| $n$ | $2$ | $3$ | $4$ | $5$ | $6$ | $6$ | $8$ | $9$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $m=2$ | $2$ | $1$ | $2$ | $1$ | $2$ |  $1$ | $2$ | $1$ |
| $m=3$ | $1$ | $3$ | $1$ | $1$ | $3$ | $1$ | $1$ | $3$ |
| $m=4$ | $2$ | $1$ | $4$ | $2$ | $1$ | $4$ | $2$ | $1$ |
| $m=5$ | $1$ | $1$ | $1$ | $5$ | $1$ | $1$ | $1$ | $1$ |

显然即 $c_{n,m}=\gcd(n,m)$。倒推一下就能得到 $a_{n,m}=\sum\limits_{i=1}^n\sum\limits_{j=1}^m \gcd(i,j)$。

贺一下 P2398 的代码即可。$n\ne m$ 时是一个很小的点，所以直接暴力。

## [Task 8](https://www.luogu.com.cn/paste/m5bl78vb)

很多人说这一问很难，但是我觉得还好捏。

随便输进去一个排列，发现答案是 $\dfrac{n(n+1)}2$，很容易想到答案是这个数组的 $[l,r]$ 数量。

于是输入 $\{1,2,1,2\}$，发现答案是 $6$。枚举一下 $[l,r]$ 就能发现求的是**本质不同的子串个数**。

去 P2408 贺个题解改一改即可。

## [Task 9](https://www.luogu.com.cn/paste/yvwek4lh)

`input9.txt` 显然让我们输入一些点对。瞎输了一下，为啥是小数啊。

于是输入 $(1,2), (3,4)$，发现答案是 $2.828\approx2\sqrt2=\sqrt8$。很显然是 $(x_i,y_i)$ 在平面上两点的距离。

那么就很简单了，多输入几个数就能发现是平面最近点对。

去 P7883 贺个代码即可。

## [Task 10](https://www.luogu.com.cn/paste/prkinayc)

这种题目总是有一些 Task 是不正经的 /hanx。

## 纯答案题解

+ Task1：对于字母 $\texttt{a}\sim\texttt{z}$，映射 $\texttt{yfrbkgimujvphatdsnelozcxwq}$。
+ Task2：$a_n=\Big(\normalsize n(2020+2016(n-1))+10\Big)\normalsize\bmod 233333$。
+ Task3：$a_n=\left\lfloor\sqrt{\dfrac n\pi}\right\rfloor$。
+ Task4：给定一张图，输出 $\sum\textbf{连通块的大小}^2$。
+ Task5：给定一棵有边权树，输出 $\oplus \operatorname{dist}(u,v)$。
+ Task6：给定一棵有边权树，输出 $\oplus \operatorname{minw}(u,v)$。
+ Task7：$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\gcd(i,j)$。$n\ne m$ 的情况允许暴力。
+ Task8：本质不同的子串个数。
+ Task9：平面最近点对。
+ Task10：$10$ 个 `invalid input!`。

---

## 作者：mrsrz (赞：5)

## Point 1：

字符串映射。

```cpp
//映射
#include<bits/stdc++.h>
char a[233],s[2333333];
int main(){
	freopen("input1.txt","r",stdin);
	freopen("output1.txt","w",stdout);
	a['a']='y';
	a['b']='f';
	a['c']='r';
	a['d']='b';
	a['e']='k';
	a['f']='g';
	a['g']='i';
	a['h']='m';
	a['i']='u';
	a['j']='j';
	a['k']='v';
	a['l']='p';
	a['m']='h';
	a['n']='a';
	a['o']='t';
	a['p']='d';
	a['q']='s';
	a['r']='n';
	a['s']='e';
	a['t']='l';
	a['u']='o';
	a['v']='z';
	a['w']='c';
	a['x']='x';
	a['y']='w';
	a['z']='q';
	int T;
	scanf("%*d%d",&T);
	while(T--){
		scanf("%s",s);
		for(int i=0;s[i];++i)s[i]=a[s[i]];
		puts(s);
	}
	return 0;
}
```

## Point 2：

是个二次多项式，带取模。递推式见代码注释。

```cpp
//a0=10,a1=10+2020 a2=a1+4032+2020 a3=a2+4032*2+2020 ...(mod 233333)
#include<cstdio>
int main(){
	freopen("input2.txt","r",stdin);
	freopen("output2.txt","w",stdout);
	int T;
	scanf("%*d%d",&T);
	while(T--){
		int n;
		scanf("%d",&n);
		long long ans=n*2020LL+10;
		ans+=(n-1LL)*n/2%233333*4032;
		printf("%d\n",ans%233333);
	}
	return 0;
}
```

## Point 3：

$$\lfloor\sqrt{\frac{n}{\pi}}\rfloor$$

```cpp
//sqrt(n/pi)
#include<cmath>
#include<cstdio>
const double pi=acos(-1);
int main(){
	freopen("input3.txt","r",stdin);
	freopen("output3.txt","w",stdout);
	int T;scanf("%*d%d",&T);
	while(T--){
		int a;scanf("%d",&a);
		printf("%d\n",(int)sqrt(a/pi));
	}
	return 0;
}
```

## Point 4：

求每个连通块大小的平方的和。

```cpp
#include<cstdio>
int fa[233333],n,m,sz[233333];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int main(){
	freopen("input4.txt","r",stdin);
	freopen("output4.txt","w",stdout);
	int T;
	scanf("%*d%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;++i)sz[i]=1,fa[i]=i;
		while(m--){
			int x,y;scanf("%d%d",&x,&y);
			if(find(x)!=find(y)){
				sz[find(y)]+=sz[find(x)];
				fa[find(x)]=find(y);
			}
		}
		long long ans=0;
		for(int i=1;i<=n;++i)if(i==find(i))
		ans+=1LL*sz[i]*sz[i];
		printf("%lld\n",ans);
	}
	return 0;
}
```

## Point 5：

每次询问带权树上两点间路径权和。每个点的答案为所有询问的异或和。

LCA搞搞就好了。

```cpp
#include<cstdio>
#include<cstring>
const int N=100005;
int fa[N],sz[N],son[N],dep[N],head[N],top[N];
long long dis[N];
struct edge{
	int to,nxt,w;
}e[N<<1];
int cnt,n,m;
void dfs(int now){
	sz[now]=1;son[now]=0;
	for(int i=head[now];i;i=e[i].nxt)
	if(!dep[e[i].to]){
		dep[e[i].to]=dep[now]+1;
		fa[e[i].to]=now;
		dis[e[i].to]=dis[now]+e[i].w;
		dfs(e[i].to);
		sz[now]+=sz[e[i].to];
		if(!son[now]||sz[e[i].to]>sz[son[now]])son[now]=e[i].to;
	}
}
void dfs2(int now){
	if(son[now])top[son[now]]=top[now],dfs2(son[now]);
	for(int i=head[now];i;i=e[i].nxt)
	if(dep[now]<dep[e[i].to]&&e[i].to!=son[now])
	dfs2(top[e[i].to]=e[i].to);
}
inline int LCA(int x,int y){
	while(top[x]!=top[y])
	if(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];
	return dep[x]<dep[y]?x:y; 
}
int main(){
	freopen("input5.txt","r",stdin);
	freopen("output5.txt","w",stdout);
	int T;scanf("%*d%d",&T);
	while(T--){
		cnt=0;memset(head,0,sizeof head);
		scanf("%d%d",&n,&m);
		long long ans=0;
		for(int i=1;i<n;++i){
			int u,v,w;scanf("%d%d%d",&u,&v,&w);
			e[++cnt]=(edge){v,head[u],w};
			head[u]=cnt;
			e[++cnt]=(edge){u,head[v],w};
			head[v]=cnt;
		}
		memset(dep,0,sizeof dep);
		dfs(dep[1]=1);dfs2(1);
		while(m--){
			int x,y;
			scanf("%d%d",&x,&y);
			ans^=dis[x]+dis[y]-(dis[LCA(x,y)]<<1);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

## Point 6：

每次询问两点树上路径中最短的边权长度。若给出两点为同一点，则答案为1987654321。每个点的答案为所有询问的异或和。

倍增即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int N=200005;
int fa[N],dep[N],head[N],mn[20][N],F[20][N];
struct edge{
	int to,nxt,w;
}e[N<<1];
int cnt,n,m;
void dfs(int now){
	for(int i=head[now];i;i=e[i].nxt)
	if(!dep[e[i].to]){
		dep[e[i].to]=dep[now]+1;
		fa[e[i].to]=now;
		F[0][e[i].to]=now;
		mn[0][e[i].to]=e[i].w;
		dfs(e[i].to);
	}
}
inline int ask(int x,int y){
	int ans=1987654321;
	if(dep[x]<dep[y])x^=y^=x^=y;
	for(int i=19;~i;--i)
	if(dep[F[i][x]]>=dep[y])ans=std::min(ans,mn[i][x]),x=F[i][x];
	if(x==y)return ans;
	for(int i=19;~i;--i)
	if(F[i][x]!=F[i][y])ans=std::min(ans,std::min(mn[i][x],mn[i][y])),x=F[i][x],y=F[i][y];
	ans=std::min(ans,std::min(mn[0][x],mn[0][y]));
	return ans;
}
int main(){
	freopen("input6.txt","r",stdin);
	freopen("output6.txt","w",stdout);
	int T;scanf("%*d%d",&T);
	while(T--){
		cnt=0;memset(head,0,sizeof head);
		scanf("%d%d",&n,&m);
		long long ans=0;
		for(int i=1;i<n;++i){
			int u,v,w;scanf("%d%d%d",&u,&v,&w);
			e[++cnt]=(edge){v,head[u],w};
			head[u]=cnt;
			e[++cnt]=(edge){u,head[v],w};
			head[v]=cnt;
		}
		memset(F,0,sizeof F);
		memset(mn,0,sizeof mn);
		memset(dep,0,sizeof dep);
		dfs(dep[1]=1);
		for(int i=1;i<20;++i)
		for(int j=1;j<=n;++j)
		F[i][j]=F[i-1][F[i-1][j]],
		mn[i][j]=std::min(mn[i-1][j],mn[i-1][F[i-1][j]]);
		while(m--){
			int x,y;
			scanf("%d%d",&x,&y);
			ans^=ask(x,y);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

## Point 7：

给定$n,m$，求$\sum\limits_{i=1}^n\sum\limits_{j=1}^m(i,j)$。

转化式子为

$$\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac n d\rfloor}\sum_{j=1}^{\lfloor\frac m d\rfloor}[(i,j)=1]$$

当$n=m$时，原式等于

$$\sum_{d=1}^nd(2(\sum_{i=1}^{\lfloor\frac n d\rfloor}\varphi(i))-1)$$

$n\neq m$只有一个很小的点，暴力即可。

（当然也可以反演了事）

```cpp
#include<cstdio>
#include<algorithm>
typedef long long LL;
int pri[1000005],isp[1000005],tot=0;
LL phi[1000005];
void sieve(){
	phi[1]=1;
	for(int i=2;i<=1000005;++i){
		if(!isp[i])phi[pri[++tot]=i]=i-1;
		for(int j=1;j<=tot&&i*pri[j]<=1000005;++j){
			isp[i*pri[j]]=1;
			if(i%pri[j])phi[i*pri[j]]=phi[i]*(pri[j]-1);else{
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
		}
	}
	for(int i=1;i<=1000005;++i)phi[i]+=phi[i-1];
}
int main(){
	freopen("input7.txt","r",stdin);
	freopen("output7.txt","w",stdout);
	sieve();
	int T;
	scanf("%*d%d",&T);
	while(T--){
		int n,m;scanf("%d%d",&n,&m);
		LL ans=0;
		if(n!=m){
			for(int d=1;d<=n&&d<=m;++d)
			for(int i=1;i<=n/d;++i)
			for(int j=1;j<=m/d;++j)
			if(std::__gcd(i,j)==1)ans+=d;
			printf("%lld\n",ans);
			continue;
		}
		for(int d=1;d<=n;++d)
		ans+=d*(2*phi[n/d]-1);
		printf("%lld\n",ans);
	}
	return 0;
}
```

## Point 8：

有点难观察QAQ

是求本质不同的子串个数。

SA即可。

```cpp
#include<cstdio>
#include<algorithm>
const int N=1e6+7;
int s[N],c[N],x[N],y[N],sa[N],height[N];
int n;
void sort(){
	int m=200;
	for(int i=0;i<=m;++i)c[i]=0;
	for(int i=1;i<=n;++i)++c[x[i]=s[i]];
	for(int i=1;i<=m;++i)c[i]+=c[i-1];
	for(int i=n;i;--i)sa[c[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1){
		int p=0;
		for(int i=n-k+1;i<=n;++i)y[++p]=i;
		for(int i=1;i<=n;++i)if(sa[i]>k)y[++p]=sa[i]-k;
		for(int i=0;i<=m;++i)c[i]=0;
		for(int i=1;i<=n;++i)++c[x[i]];
		for(int i=1;i<=m;++i)c[i]+=c[i-1];
		for(int i=n;i;--i)sa[c[x[y[i]]]--]=y[i];
		std::swap(x,y);
		x[sa[1]]=p=1;
		for(int i=2;i<=n;++i)
		x[sa[i]]=y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]?p:++p;
		if(p==n)break;
		m=p;
	}
	for(int i=1,k=0;i<=n;++i)
	if(x[i]>1){
		k-=!!k;
		int j=sa[x[i]-1];
		while(s[i+k]==s[j+k])++k;
		height[x[i]]=k;
	}
}
int main(){
	freopen("input8.txt","r",stdin);
	freopen("output8.txt","w",stdout);
	int T;
	scanf("%*d%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;++i)scanf("%d",s+i);
		sort();
		long long ans=0;
		for(int i=1;i<=n;++i)
		ans+=std::max(n-sa[i]+1-height[i],0);
		printf("%lld\n",ans);
	}
	return 0;
}
```

## Point 9：

求平面最近两点对间距离。

人类智慧法，排序后只考虑其后面500个点的连线即可。

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
typedef long long LL;
LL ans;
struct point{
	int x,y;
	inline bool operator<(const point&rhs)const{return x!=rhs.x?x<rhs.x:y<rhs.y;} 
}p[1000005];
inline LL calc(int x,int y,int xx,int yy){return (x-xx)*(LL)(x-xx)+(y-yy)*(LL)(y-yy);}
int main(){
	freopen("input9.txt","r",stdin);
	freopen("output9.txt","w",stdout);
	int T;scanf("%*d%d",&T);
	for(int t=1;t<=T;++t){
		ans=1e18;
		int n;scanf("%d",&n);
		for(int i=1;i<=n;++i)
		scanf("%d%d",&p[i].x,&p[i].y);
		std::sort(p+1,p+n+1);
		for(int i=1;i<=n;++i)
		for(int j=i+1;j<=i+500;++j)
		ans=std::min(ans,calc(p[i].x,p[i].y,p[j].x,p[j].y));
		printf("%.3f\n",sqrt(ans));
		fprintf(stderr,"OK: %d\n",t);
	}
	return 0;
}
```

## Point 10：

...

```cpp
#include<cstdio>
int main(){freopen("output10.txt","w",stdout);for(int i=1;i<11;++i)puts("invalid input!");}
```

---

## 作者：SIXIANG32 (赞：4)

集训队的人得有多笋啊，山上的笋都给他们夺光了。  
闲话少说，切入正题——  

---
## Subtask1
随便输入几个字符串就可以发现这是一个字符之间的映射关系。  
映射表如下：  
```
原：abcdefghijklmnopqrstuvwxyz
映：yfrbkgimujvphatdsnelozcxwq
```
代码也很好写：  
```cpp
#include <iostream>
#include <string>
#include <cstdio>
using namespace std;
string key = "yfrbkgimujvphatdsnelozcxwq";
int main() {
	freopen("input1.txt", "r", stdin);
	freopen("output1.txt", "w", stdout);
	string str;
	int pika, n; cin >> pika >> n;
	for(int p = 1; p <= n; p++) {
		cin >> str;
		for(int i = 0; i < str.size(); i++)
			cout << key[str[i] - 'a'];
		cout << endl;
	}
}
```

---
## Subtask2
看到每行只有一个数字，大约是个数学题。  
输入 $0 \sim 10$ 的结果如下： 
```
2030
8082
18166
32282
50430
72610
98822
129066
163342
201650
```
在 oeis 上找不到这个数列，所以要自己手推规律（大悲   
容易发现邻项之差分别是  
$8082 - 2030 = 6052$  
$18166 - 8082 = 10084$  
$32282 - 18166 = 14116$   
$50430 - 32282 = 18148$  
现在貌似没有什么规律可言，但是差与差之间差不多都相差 $4000$ 左右，只要我们对差也进行这样的操作：  
$6052 - 2020 = 4032$  
$10084 - 6052 = 4032$  
$14116 - 10084 = 4032$    
$18148 - 14116 = 4032$  
我们就会发现事实上这是一个等差数列！  
故而可以得到计算式：  
$f_i = \dfrac{(i-1)[12104 + 4032(i-2)]}{2} + 2030$  
等等，这么大的数字，肯定要取余的！    
模数是多少呢？   
我们再来看看第 $11$ 项：  
```
10657
```
比第 $10$ 项小，取余了。  
我们可以用计算器算出 $f_{11} = 243990$，容易发现模数是 $233333$。  
我们的公式也要改一下，因为这个式子不太容易取余。  
$f_i = 6052(i - 1) + 2016(i - 1)(i - 2) + 2030$  
```cpp
#include <iostream>
#include <cstdio>
#define Mod 233333
using namespace std;
int main() {
	freopen("input2.txt", "r", stdin);
	freopen("output2.txt", "w", stdout);
	int pika; cin >> pika;
	int T;
	cin >> T;
	unsigned long long i;
	while(T--) {
		cin >> i;
		unsigned long long rest = (2030 + 6052 * (i - 1) % Mod + 2016 * ((i - 1) % Mod) % Mod * ((i - 2) % Mod) % Mod) % Mod;
		cout << rest << endl;
	}
}
```

---
## Subtask3
看上去还是数学题，但是输出比较小。  
老规矩，打表找规律，然后先扔到 OEIS 上找找。  
结果出人意料，还真真是能找到的 [link](http://oeis.org/search?q=0+0+0+1+1+1+1+1+1+1+1+1+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3&sort=&language=&go=Search)。  
得到十分神仙的公式：$f_i = \left\lfloor \sqrt{\dfrac{i}{\pi}}\right\rfloor$。  
代码：  
```cpp
#include <iostream>
#include <cmath> 
#define MAXN 100000
#define QWQ cout << "QWQ" << endl;
using namespace std;
int main() {
	double pi = 3.1415926;
	int pika, T, x; cin >> pika >> T;
	while(T--) {
		cin >> x;
		cout << floor(sqrt(((double)(x) / pi))) << endl;
	}
}
```

---
## Subtask 4
如果说每行两个数字，那么很可能是 DS 或者是图论题。  
这里面没有原序列，而且数字较大，不太像有 $opt$ 的样子，所以我们可以盲猜是个图论题。  
自测第一组数据和一些小数据，很容易发现答案是图的连通块大小平方和。  
并查集随便维护连通性就好了。  
```cpp
#include <iostream> 
#include <cstring>
#include <cstdio>
#define MAXN 100000
#define QWQ cout << "QWQ" << endl;
using namespace std;
struct node {
	int to, next;
} gra[MAXN * 2 + 10];
int head[MAXN + 10], cl = 1, tot = 0;
int t[MAXN + 10];
void link(int x, int y) {
	gra[++tot].to = y, gra[tot].next = head[x], head[x] = tot;
	gra[++tot].to = x, gra[tot].next = head[y], head[y] = tot;
}
int fa[MAXN + 10];
int Find(int x) {
	if(x == fa[x]) return x;
	else return fa[x] = Find(fa[x]);
}
void Union(int u, int v) {
	int U = Find(u), V = Find(v);
	if(U != V) fa[V] = U;
}
//并查集基操
int main() {
	freopen("input4.txt", "r", stdin);
	freopen("output4.txt", "w", stdout);
	int pika; cin >> pika;
	int T; cin >> T;
	while(T--) {
		memset(t, 0, sizeof(t));//多测不清空见祖宗
		int n, m; cin >> n >> m;
		for(int p = 1; p <= n; p++)
			fa[p] = p;
		for(int p = 1, x, y; p <= m; p++) {
			cin >> x >> y;
			Union(x, y);//合并
		}
		for(int p = 1; p <= n; p++)
			t[Find(p)]++;//计算每个联通快的大小
		long long ans = 0;
		for(int p = 1; p <= n; p++)//求和，不开 long long 见祖宗
			ans += (1ll * t[p] * 1ll * t[p]);
		cout << ans << endl;
	}
}
```

---
## Subtask 5
这玩意儿一开始我真没看出来是什么玩意儿。  
只要你把数据的第一行的第二个数字设为 $1$，你就能发现其中的奥秘：  
- 第一个数字 $n$ 是节点数，后面的是查询的次数 $m$。  
- 下面 $n - 1$ 行输入一个带权树，始终是以 $1$ 为根节点的。  
- 然后下面 $m$ 行输入两个数 $x,y$，查询树上路径 $x$ 到 $y$ 权值和。  

但是答案仅仅输出一个，肯定是对查询的东西进行了一些操作，四则运算取余位运算全做一遍会发现最后的答案是查询的异或和。  
然后就可以计算两点间的距离。  
这个大家应该都会吧，$dis_x + dis_y - dis_{\operatorname{lca(x, y)}}$，$dis_u$ 代表 $u$ 到根节点的距离。  
代码：  
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define QWQ cout << "qwq" << endl;
#define MAXN 100000
using namespace std;//afdsadsfadsfDF
struct node {
	int to, next, val;
} gra[MAXN * 2 + 10];
int head[MAXN + 10], tot = 0;
void link(int x, int y, int z) {
	gra[++tot].to = y, gra[tot].val = z;
	gra[tot].next = head[x], head[x] = tot;
	gra[++tot].to = x, gra[tot].val = 0;
	gra[tot].next = head[y], head[y] = tot;
}
void swap(int &x, int &y) {x ^= y ^= x ^= y;}
long long dis[MAXN + 10];
int fa[MAXN + 10], son[MAXN + 10], de[MAXN + 10], ind[MAXN + 10], siz[MAXN + 10], top[MAXN + 10], cnt = 0;
void dfs1(int u, int fat) {
	siz[u] = 1, fa[u] = fat;
	int maxn = 0;
	for(int p = head[u]; p; p = gra[p].next) {
		int v = gra[p].to, w = gra[p].val;
		if(v != fat) {
			de[v] = de[u] + 1;
			dis[v] = dis[u] + w;
			fa[v] = u;
			dfs1(v, u);
			siz[u] += siz[v];
			if(dis[v] > maxn)
				maxn = dis[v], son[u] = v;
		}
	}
} 
void dfs2(int u, int T) {
	ind[u] = ++cnt, top[u] = T;
	if(son[u]) dfs2(son[u], T);
	else return ;
	for(int p = head[u]; p; p = gra[p].next) {
		int v = gra[p].to;
		if(v != fa[u] && v != son[u])
			dfs2(v, v);
	}
}
int get_lca(int x, int y) {
	while(top[x] != top[y]) {
		if(de[top[x]] < de[top[y]]) swap(x, y);
		x = fa[top[x]];
	}
	if(de[x] > de[y]) swap(x, y);
	return x;
}
long long dist(int x, int y) {
	return dis[x] + dis[y] - 2 * dis[get_lca(x, y)];
}
signed main() {
	freopen("input5.txt", "r", stdin);
	freopen("output5.txt", "w", stdout);
	int pika, T; cin >> pika >> T; 
	while(T--) {
		memset(head, 0, sizeof(head));
		memset(dis, 0, sizeof(dis));
		memset(ind, 0, sizeof(ind));
		memset(fa, 0, sizeof(fa));
		memset(son, 0, sizeof(son));
		memset(siz, 0, sizeof(siz));
		memset(top, 0, sizeof(top));
		cnt = 0;
		memset(de, 0, sizeof(de));
		for(int p = 1; p <= tot; p++)
			gra[p].next = gra[p].to = gra[p].val = 0;
		tot = 0;
		int n, m;
		scanf("%d%d", &n, &m);
		for(int p = 1, x, y, z; p < n; p++) {
			scanf("%d%d%d", &x, &y, &z);
			link(x, y, z);
		}
		de[1] = 1;
		dfs1(1, 0);
		dfs2(1, 0);
		long long ans = 0;
		for(int p = 1, x, y; p <= m; p++) {
			scanf("%d%d", &x, &y);
			ans ^= dist(x, y);
		}
		printf("%lld\n", ans);
	}
} 
```

---
## Subtask 6
看到这个输入数据和 Subtask 5 很相似，应该是树上点对的其他的乱搞。  
仔细观察可以发现查询的应该是两点路径中最小的一条边权，答案是所有查询的异或和。  
然后可以树上倍增乱搞。     
注意，如果查询的两个点是一样的，那么查询的结果是 $1987654321$。
```cpp
#include <iostream>
#include <cstring>
#define MAXN 100000
using namespace std;
long long min(long long x, long long y) {return ((x < y) ? (x) : (y));}
void swap(int &x, int &y) {x ^= y ^= x ^= y;} 
struct node {
	int to, next, val;
} gra[MAXN * 2 + 10];
long long mi[MAXN + 10][30];
int tot = 0, head[MAXN + 10], jump[MAXN + 10][30], de[MAXN + 10];
void link(int x, int y, int z) {
	gra[++tot].to = y, gra[tot].val = z, gra[tot].next = head[x], head[x] = tot;
	gra[++tot].to = x, gra[tot].val = z, gra[tot].next = head[y], head[y] = tot; 
}
void dfs(int u,int fa) {//dfs 预处理
    de[u] = de[fa] + 1;
    jump[u][0] = fa;
    for(int p = 1; p <= 20; p++)
        jump[u][p] = jump[jump[u][p - 1]][p - 1];
    for(int p = head[u]; p; p = gra[p].next) {
        int v = gra[p].to;
        if(v != fa)
            mi[v][0] = gra[p].val, dfs(v, u);
    }
}
long long get_mi(int a, int b) {//求路径最小
	long long fucking = 1987654321;
    if(a == b) return fucking;
    if(de[a] < de[b]) swap(a,b);
    for(int p = 20; p >= 0; p--)
        if(de[b] <= de[jump[a][p]])
            fucking = min(mi[a][p], fucking), a = jump[a][p];
    if(a == b) return fucking;
    for(int p = 20; p >= 0; p--)
        if(jump[a][p] != jump[b][p])
            fucking = min(fucking, min(mi[a][p], mi[b][p])), a = jump[a][p], b = jump[b][p];
    return min(fucking, min(mi[a][0], mi[b][0]));
}
int main() {
	freopen("input6.txt", "r", stdin);
	freopen("output6.txt", "w", stdout);
	int pika, T; cin >> pika >> T;
	while(T--) {
		for(int p = 1; p <= tot; p++)
			gra[p].next = gra[p].to = gra[p].val = 0;
		tot = 0;
		memset(mi, 0, sizeof(mi));
		memset(head, 0, sizeof(head));
		memset(jump, 0, sizeof(jump));
		memset(de, 0, sizeof(de));
		int n, m;
		cin >> n >> m;
		for(int p = 1, x, y, z; p < n; p++) {
			cin >> x >> y >> z;
			link(x, y, z);
		}	
		de[1] = 1, dfs(1, 0);
		long long ans = 0;
		for(int i = 1; i <= 20; i++)//预处理最小值的倍增数组。
			for(int p = 1; p <= n; p++)
				mi[p][i] = min(mi[p][i - 1], mi[jump[p][i - 1]][i - 1]);
		for(int p = 1, x, y; p <= m; p++) {
			cin >> x >> y;
			ans ^= get_mi(x, y);
		}
		cout << ans << endl;
	}
}
```

---
## Subtask 7
全是二元组，彼此之间也没有什么关系，大概是个数学题。  
通过~~OIer 天生的直觉~~盲猜我们可以发现要解的式子是：$\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{m}\gcd(i,j)$。  
~~因为我挂机试了试，跑了一天都没跑出来~~因为这个式子很大，所以我们要用数学方法来解。  
我们会发现 $n\not= m$ 只有一个点，也就是说式子可以写成 $\sum\limits_{i = 1}^{n}\sum\limits_{j = 1}^{n}\gcd(i, j)$。  
枚举每个可能的 $\gcd$，我们用 $G$ 来表示，那么就是  
$\sum\limits_{G = 1}^{n}G\sum\limits_{i = 1}^{\left\lfloor\frac{n}{G}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{n}{G}\right\rfloor}[\gcd(i, j) = 1]$。  
很容易改写成：  
$\sum\limits_{G = 1}^{n}G[2{\sum\limits_{i = 1}^{\left\lfloor\frac{n}{G}\right\rfloor}(\varphi(i) - 1)}]$    

只要我们预处理一下 $\varphi$ 的去前缀和就好了。  

```cpp
#include <iostream>
#include <cstdio>
#define int long long
#define MAXN 1000000
using namespace std;
int phi[MAXN + 10];
int gcd(int n, int m) {
	if(!m) return n;
	else return gcd(m, n % m);
}
void init() {//欧拉函数预处理
	for(int p = 1; p <= MAXN; p++) phi[p] = p;
    for(int p = 2; p <= MAXN; p++)
        if(phi[p] == p)
            for(int i = p; i <= MAXN; i += p)
                phi[i] = phi[i] / p * (p - 1);
	for(int p = 2; p <= MAXN; p++)
		phi[p] += phi[p - 1];
}
int solve(int n) {//根据上面的式子求解
	int ans = 0;
	for(int G = 1; G <= n; G++) ans = (2 * phi[n / G] - 1) * G + ans;
	return ans;
}
signed main() {
	freopen("input7.txt", "r", stdin);
	freopen("output7.txt", "w", stdout);
	int pika, T;
	cin >> pika >> T;
	init();
	while(T--) {
		int n, m;
		long long ans = 0;
		cin >> n >> m;
		if(n != m) {
			for(int p = 1; p <= n; p++)
				for(int i = 1; i <= m; i++)
					ans += gcd(p, i);
			cout << ans << endl;
		}
		else cout << solve(n) << endl;
	}
}
```

---
## Subtask 8
通过大量的观察我们会发现这是求这个串的不同字串数量。  
众所周知，一个长度为 $n$ 的串不同子串的数量为 $\dfrac{(n + 1)n}{2} - \sum\limits_{i = 2}^{n}height_i$（$height$ 是 SA 里面的东西）  
然后只要你跑 SA 就行了。  
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#define MAXN 2000000
#define QWQ cout << "QWQ" << endl;
using namespace std;
long long SM = 122;
long long sa[MAXN + 10], rk[MAXN + 10], tmp[MAXN + 10], t[MAXN + 10], n, str[MAXN + 10];
long long height[MAXN + 10];
void SXSRT() {
	for(int p = 0; p <= SM; p++) t[p] = 0;
	for(int p = 1; p <= n; p++) t[rk[p]]++;
	for(int p = 1; p <= SM; p++) t[p] += t[p - 1];
	for(int p = n; p >= 1; p--) sa[t[rk[tmp[p]]]--] = tmp[p];
}
void solve() {//求 sa 数组
	for(int p = 1; p <= n; p++) tmp[p] = p, rk[p] = int(str[p]);
	SXSRT();
	for(int p = 0, w = 1; p < n; SM = p, w <<= 1) {
		p = 0;
		for(int i = 1; i <= w; i++) tmp[++p] = n - w + i;
		for(int i = 1; i <= n; i++) if(sa[i] > w) tmp[++p] = sa[i] - w;
		SXSRT(), swap(tmp, rk), rk[sa[1]] = p = 1;
		for(int i = 2; i <= n; i++) rk[sa[i]] = ((tmp[sa[i - 1]] == tmp[sa[i]] && tmp[sa[i - 1] + w] == tmp[sa[i] + w]) ? (p) : (++p));
	}
}
void GHT() {//求 height
	long long k = 0;
	for(int p = 1; p <= n; p++) {
		if(k) k--;
		while(str[p + k] == str[sa[rk[p] - 1] + k]) k++;
		height[rk[p]] = k;
	}
}
long long get_ans() {
	long long ans = (n + 1) * n / 2; 
	for(int p = 2; p <= n; p++) 
		ans -= height[p];
	return ans;
}
signed main() {
	freopen("input8.txt", "r", stdin);
	freopen("output8.txt", "w", stdout);
	int pika, T; cin >> pika >> T;
	while(T--) {
		memset(sa, 0, sizeof(sa));
		memset(height, 0, sizeof(height));
		cin >> n;
		for(int p = 1; p <= n; p++) cin >> str[p];
		solve();
		GHT();//获得 height
		cout << get_ans() << endl;
	}
}
```

## Subtask 9
发现所有的输入数据都是二元组，而且每个数字都很大，超过了第一行输入的数据 $n$。随便输入一组数据发现输出了小数，说明不是数论题，看上去输入的像平面直角坐标系的每一个点坐标，然后最后输出的大概是个距离。    
经过不懈的尝试我们会发现这道题让我们求的是平面最近点对距离。  
我们都知道，平面最近点对距离可以用分治算法求，把每个点按 $x$ 轴为第一关键字，$y$ 轴为第二关键字降序排序。将要处理的点对分成 $[l, mid]$ 与 $[mid + 1, r]$，分别求解，得到互不相交的两个区域的最小解 $\min\{\operatorname{calc}(l, mid),\operatorname{calc}(mid + 1, r)\}$  
这里面不包含 $mid$ 号点，所以我们要枚举每个别的点然后找出最小距离与上面的判断。  
具体细节详见代码：  
```cpp
#include <iostream>
#include <cmath>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#define MAXN 2000000
using namespace std;
struct point {
	double x, y;
} P[MAXN + 10];
bool cmp(point x, point y) {
	if(x.x != y.x) return x.x < y.x;
	else return x.y < y.y;
}
bool Cmp(int x, int y) {
	return P[x].y < P[y].y;
}
double dist(int a, int b) {
	double x1 = P[a].x, x2 = P[b].x;
	double y1 = P[a].y, y2 = P[b].y;
	return double(sqrt(double(fabs(x1 - x2) * fabs(x1 - x2)) + double(fabs(y1 - y2) * fabs(y1 - y2))));
}
int rest[MAXN + 10];
double calc(int l, int r) {//算出平面最近点对距离
	double qwq = 0x7f7f7f7f;
	if(l == r) return qwq;
	if(l + 1 == r) return dist(l, r);//算不下去了就返回
	int mid = (l + r) >> 1, S = 0;
	qwq = min(calc(l, mid), calc(mid + 1, r));//计算不算 mid 号点的最小
	for(int p = l; p <= r; p++)//计算 mid 号点
		if(fabs(P[p].x - P[mid].x) < qwq)//如果都大于等于 qwq 了就没有必要算下去了
			rest[++S] = p;
	sort(rest + 1, rest + S + 1, Cmp);//按照 y 轴降序排序方便后面的处理
	for(int p = 1; p <= S; p++)
		for(int i = p + 1; i <= S && P[rest[i]].y - P[rest[p]].y < qwq; i++)
			qwq = min(qwq, dist(rest[p], rest[i]));
	return qwq;
}
int main() {
	freopen("input9.txt", "r", stdin);
	freopen("output9.txt", "w", stdout);
	int pika, T; cin >> pika >> T;
	while(T--) {
		int n;
		cin >> n;
		for(int p = 1; p <= n; p++) 
			cin >> P[p].x >> P[p].y;
		sort(P + 1, P + n + 1, cmp);
		cout << fixed << setprecision(3) << calc(1, n) << endl;
	}
}
```

---
## Subtask 10
终于来到了最后一个 Subtask！  
这个 Subtask 里面是一些字符串，猜测是神仙字符串题。  
随便写一个小数据都会发现 lost 输出了 $T$ 个 ```invalid input!```   
就算是输入第一个数据（题目说了数据规模不超过第一组数据保证能正常运行），也会输出 ```invalid input!```。  
那么我们就可以大胆猜测，这里要输出 T 个 ```invalid input!```。  
代码：  
```cpp
#include <iostream>
using namespace std;
int main() {
	freopen("input10.txt", "r", stdin);
	freopen("output10.txt", "w", stdout); 
	int pika, T;
	cin >> pika >> T;
	while(T--) cout << "invalid input!" << endl; 
}
```

---
这道题就这样做出来啦~  
从 7 月 15 号开始莽，7 月 18 号完工，也学会了不少东西，比如说倍增 LCA 维护新东西（之前只会板子（捂脸）），欧拉函数在式子里怎么推（之前也只会概念（捂脸）），SA 基操（之前压根不会（捂脸））。  
真是有趣的一道题呢！  
完结撒花~

---

## 作者：zhaoyp (赞：3)

大概自己做出了一半左右，写篇题解来记录下。

## subtask1

发现整个过程跟字符串加密差不多，一个个打表可以发现是这样一种对应关系：

`string str = "yfrbkgimujvphatdsnelozcxwq";`

把输入的一位位替换就行了。

## subtask2

打出前 $10$ 位的表，找不到规律，那就差分。还是找不到规律，再差分，发现得到的结果都是 $4032$。

猜想答案是关于 $n$ 的多项式，有 $2016n(n-1)$ 这一项，进而解得 $f(n)  =2016n(n-1) + 2020n+10$。

当然你也可以拉格朗日插值硬搞。

然后发现第 $11$ 项比 $f(11)$ 要小 $233333$，于是猜测模数就是 $233333$ 验证一下发现是对的。

## subtask3

比较神秘。

打表打出前 $30$ 项，扔进 oeis 里，他会告诉你输出 $\sqrt{\dfrac{n}{\pi}}$ 的整数部分。

## subtask4

接下来这 $3$ 个比较简单。

通过小数据测试发现答案是图上连通块大小的平方和。

## subtask5

观察输入发现大概是这样的。

$n$ 个点的树，边有边权，$m$ 次询问。

通过 $m=1$ 的尝试发现节点距离为路径上的边权和。扩大 $m$ 发现要把 $m$ 次的结果异或起来输出。

## subtask6

跟上面一个差不多，节点距离为路径上的边权最小值。

然后有一个很恶心的地方就是自己跟自己的距离是 $1987654321$。

## subtask7

打出 $10 \times 10$ 的表，每行 oeis 无果，发现输入大多是 $n=m$ 就把对角线上的数扔进 oeis，发现是在求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^m gcd(i,j)$。

代码参考 [P1390](https://www.luogu.com.cn/problem/P1390)。

## subtask8

不会做，是让你求不同子串个数。

代码参考 [P2408](https://www.luogu.com.cn/problem/P2408)。

## subtask9

输入了一堆二元组，经过小样例的不断尝试发现是求平面最近点对。

代码参考 [P1429](https://www.luogu.com.cn/problem/P1429)。

## subtask10

因为我在写的时候没做出来的点都用 `invalid input!` 占位，然后发现过了。

那么就是输出 $10$ 个 `invalid input!`。

---

## 作者：2018ljw (赞：3)

非常搞的一道题，花了一个下午加晚上才解决掉。这篇题解会解释如何根据数据推出题面，也是本人做题的心路历程。

### Sub0

首先你下载了源文件，发现程序运行不了。你需要将两个缺失的 .dll 文件下载到与 `lost.exe` 同一目录下。题解第一篇给出了下载链接，如果你不方便使用网盘，可以在[这个链接](https://www.luogu.com.cn/problem/U239318)中下载。

### Sub1

关注到第 2,3 组数据全为 `a`，不妨输入一些 `a`，发现输出全为 `y`。大胆猜测：每个字母有唯一对应的映射。随机输入一些短字符串，根据输出即可证明正确。

所以只需要知道 $a$ 到 $z$ 每个字符的映射即可，分三次询问 `a-j`，`k-t`，`u-z` 的结果即可。

### Sub2

输入只有一个数字，显然要找式子。求出 $f(0\dots 20)$ 打表，上 oeis 搜前三项发现没有式子，因此猜测要求一个多项式。

两次差分后发现前面几个数均相等。所以是一个二次函数,并且后面存在取模操作。根据 $f(0,1,2)$ 待定系数解方程组可得函数解析式为 $f(x)=2016x^2+4x+10$。

$f(11)=243990$，与真实值相差 $233333$。模数应该 $>f(10)$ 且为差值的约数，因此模数即为该数。原题即求 $2016x^2+4x+10\pmod {233333}$

### Sub3

输入依然只有一个数字。稍微打下表发现函数增长趋势接近于 $f(x)=\sqrt{x}$。上 oeis 搜索，可知所求即为 $\lfloor\sqrt{\frac n{\pi}}\rfloor$。直接计算即可。

如果不用 oeis 的话，根据增长趋势和 $f(50000)=126$ 猜测 $f(x)=\frac{\sqrt n}{k}$ 以某种形式取整，然后对四舍五入、下取整和上取整三种形式分别计算。每次选一些点求出 $k$ 的取值范围，当范围小于 `eps` 后跳出。发现只有下取整存在 $k$。求出 $k$ 后利用较强的数感看出 $k$ 约等于 $\sqrt \pi$，或者直接将精度较高的 $k$ 作为常量除在下面即可。

### Sub4

很有迷惑性的一个点，观察数据可以猜出给了一张图。使用 $n$ 很小的树、连通图试验发现结果均为 $n^2$。关注到第二个点图不连通，尝试构造不连通图，发现结果即为每个连通块大小的平方和，并查集维护即可。

### Sub5

首先看到巨大的数可以猜是权值。又恰好有 9 个权所以猜是 $n$ 个节点的树的边权。那么后面的就是询问，删去 `5 5` 后发现答案没变，单独询问某对点答案等于路径长度。因此每个询问就是两点距离。

发现有 $2$ 次 `2 10` 询问，删去一个后答案改变，两个都删去后答案和删之前一样。所以输出为所有询问结果的异或和。

### Sub6

输入格式输出格式和上一问相同，因此猜测还是树上询问+异或输出。

构造出较小的树，单独询问一对点，多次测试发现返回的是路径上边权 $\min$。不存在边则返回 `1987654321`。

这两问原则上应使用倍增、树剖解决，但发现树的深度并不大（$<2\times10^4$），所以暴力跳父节点找 lca 即可，还可以顺带统计答案。

### Sub7

最搞的点。

首先数据只给了 `n,m`，简单实验后发现顺序无关。合理推测可能是推式子或在网格上计数，简单测试小的数据点后放弃了网格上计数的想法。

尝试固定 $n$，增大 $m$ 打表，发现其差分存在循环节：

```cpp
n=1: 1
n=2: 2 3
n=3: 3 4 5 4 3 6
n=4: 4 6 6 8 4 8 4 8 6 6 4 10
```
有如下规律：
1. 循环节长度为 $\operatorname{lcm}(1\dots n)$。
2. 下标为 $1$ 或大于 $n$ 的质数时，差分等于 $n$。

所以我们要求的式子应该形如$\sum\limits_{i=1}^n\sum\limits_{j=1}^mf(i,j)$。

由于循环节可能很长，但不大于 $n$ 的质数很少，所以我们放大 $n$，找一些质数求一下，会发现规律 $3$：下标为不大于 $n$ 的质数 $p$ 时，差分等于 $n-\lfloor\frac np\rfloor+p\lfloor\frac np\rfloor$。

规律 $1$ 存在 $\operatorname{lcm}$，因此是和约数或模数的研究有关。通过规律 $2$ 合理推测和 $\gcd$ 相关。在此基础上发现规律 $3$ 等价于 $\sum\limits_{i=1}^n\gcd(p,i)$，因此猜测所求即为 $\sum\limits_{i=1}^n\sum\limits_{j=1}^m\gcd(i,j)$，带回验证成立，莫反推式子即可。~~有兴趣可以打杜教筛继续优化。~~

### Sub8

也很搞就是了。

给定长为 $n$ 的序列，要输出什么东西。

随便输入一些数据，调整序列中数字大小和位置会发现如下规律：

1. 数字的相对大小对答案没有影响。数字相等对答案有影响。
2. 数字的顺序对答案有一定程度的影响。（`1 2 2 2` 和 `2 1 2 2`） 
3. 输入的数互不相同时，任意顺序下答案都为 $\frac12n(n+1)$。其余情况下答案只会比其小。

第一条可以否决跟数值大小有关的算法，第二条可以否决跟每类数字个数有关的算法。但仍然不知道是什么。

打开数据，发现即使是最大的点，序列中每个数也 $\le 20$。这并不正常，因为我们已经发现数字大小跟答案无关。换而言之，数字的作用可能并非数值。那么第一反应是字符串的 $26$。尝试将序列转化为字符串。

第三条的 $\frac12n(n+1)$ 就是整个字符串的子串个数，再根据第一条，不难猜测减去的应该是相等子串个数。所以所求即为本质不同子串个数，后缀数组板子题。

然后这一问最大的点是 $10^6$ 而非 $10^5$，数组别开小了。

### Sub9

小清新。

输出样例和手造一些样例，发现输出均为小数。考虑到输入格式为 $n$，然后 $n$ 个成对的东西。首先考虑分数规划，测试 $n=1$ 输入不合法，$n=2$，$a_1=b_1=1,a_2=b_2=2$ 输出 $1.414$ 而非 $1$，因此不是分数规划。

关注到样例输出的是 $2.236$，和上面的数据一起看，分别是 $\sqrt{2}$ 和 $\sqrt{5}$。所以基本确定输入的是平面上点的坐标，要求的是点对距离。手动观测第一个数据点发现 $\sqrt5$ 是最近两点距离。因此所求即为平面最近点对，分治处理或者[人类智慧](https://www.luogu.com.cn/blog/user12655/solution-p1429)即可。

### Sub10

语文题。

输出样例和更小的手造样例发现都输出的为 `invalid input!`，看起来非常毒瘤。但题面是有这样两句话的：

> 当数据规模不超过第一组数据时，保证 $\texttt{lost}$ 能够正常运行。

> 只有数据组数不超过一组时，保证 $\texttt{lost}$ 的输出正确。

所以对于第一组数据，标算**正常运行且给出了正确答案**。

所以答案即为 `invalid input!`。

---

## 作者：chenbs (赞：2)

# P5246 题解

## 本篇题解将介绍：IDA Pro 的编辑操作 + `I::Do()` 的代码分析。

本篇题解使用的是 IDA 9.0 beta，当然其他版本也可以。

以 B 的代码为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/mcwx6ge1.png)

左侧的 `loc_401428` 就是万恶之源（`invalid input.`），而右侧的 `loc_401436` 则是正常的计算代码。

所以我们在左侧添加一条 `jmp` 指令，跳转到右侧正常代码，就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/0w6kna2f.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/mebb442z.png)

改完之后的样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/xlnhic6g.png)

其他的测试点也一样，轻松搞定。

于是，我们就成功拿到了 90 分。爆炸了一个点，没办法，只能深入分析这个 `I::Do` 函数了。

按下祖传的 F5，生成伪代码：

```c
int I::Do()
{
  int *v1; // ecx
  int v2; // eax
  int *v3; // ecx
  int v4; // eax
  int *v6; // eax
  int v7; // eax
  int Format; // [esp+8h] [ebp-38h]
  int v10; // [esp+18h] [ebp-28h] BYREF
  int v11; // [esp+1Ch] [ebp-24h] BYREF
  __int64 v12; // [esp+20h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-14h]
  int v14; // [esp+30h] [ebp-10h]
  int i; // [esp+34h] [ebp-Ch]

  scanf("%d", &I::n);
  for ( i = 1; i <= I::n; ++i )
    scanf("%d", &I::xu[i]);
  I::xu[I::n + 1] = 0;
  for ( i = 1; i <= I::n; ++i )
    I::sa[i] = i;
  std::sort<int *,bool (*)(int,int)>(&unk_1AAAD84, &I::sa[I::n + 1], I::cmp);
  v13 = 0;
  for ( i = 1; i <= I::n; ++i )
  {
    for ( I::rank[I::sa[i]] = ++v13; i < I::n && I::xu[I::sa[i]] == I::xu[I::sa[i + 1]]; I::rank[I::sa[i]] = v13 )
      ++i;
  }
  v14 = 1;
  while ( v13 < I::n )
  {
    for ( i = 1; i <= I::n; ++i )
      ++I::cc[I::rank[i + v14]];
    for ( i = 1; i <= v13; ++i )
      I::cc[i] += I::cc[i - 1];
    for ( i = 1; i <= I::n; ++i )
    {
      v1 = &I::cc[I::rank[i + v14]];
      v2 = *v1;
      I::sec[v2] = i;
      *v1 = v2 - 1;
    }
    for ( i = 0; i <= v13; ++i )
      I::cc[i] = 0;
    for ( i = 1; i <= I::n; ++i )
      ++I::cc[I::rank[i]];
    for ( i = 1; i <= v13; ++i )
      I::cc[i] += I::cc[i - 1];
    for ( i = I::n; i > 0; --i )
    {
      v3 = &I::cc[I::rank[I::sec[i]]];
      v4 = *v3;
      I::sa[v4] = I::sec[i];
      *v3 = v4 - 1;
    }
    for ( i = 0; i <= v13; ++i )
      I::cc[i] = 0;
    v13 = 0;
    for ( i = 1; i <= I::n; ++i )
    {
      for ( I::sec[I::sa[i]] = ++v13;
            i < I::n
         && I::rank[I::sa[i]] == I::rank[I::sa[i + 1]]
         && I::rank[I::sa[i] + v14] == I::rank[I::sa[i + 1] + v14];
            I::sec[I::sa[i]] = v13 )
      {
        ++i;
      }
    }
    for ( i = 1; i <= I::n; ++i )
      I::rank[i] = I::sec[i];
    v14 *= 2;
  }
  for ( i = 1; i <= I::n; ++i )
  {
    if ( I::rank[i] != 1 )
    {
      v10 = I::h[i - 1] - 1;
      v11 = 0;
      v6 = (int *)std::max<int>(&v11, &v10);
      for ( I::h[i] = *v6; I::xu[I::h[i] + i] == I::xu[I::sa[I::rank[i] - 1] + I::h[i]]; ++I::h[i] )
        ;
    }
  }
  v12 = 0LL;
  for ( i = 1; i <= I::n; ++i )
    v12 += i;
  for ( i = 1; i <= I::n; ++i )
    v12 -= I::h[i];
  v7 = std::ostream::operator<<(&std::cout, v12);
  return std::ostream::operator<<(v7, &std::endl<char,std::char_traits<char>>, Format);
}
```

可以看到码风比较怪异，让我们来整理一下。

首先去除命名空间，因为它对我们分析没什么用。

然后我们看变量。`v6` 储存了 `max` 函数的返回值，可以重命名为 `maxval`，类型也改成 `int`。`v7` 没用就删掉。这个 `v12` 最后被输出了，显然是储存答案的，重命名为 `ans`。`v13` 应该是排名计数器，重命名为 `cnt`。`v14` 每次乘以 $2$，估计是个步长，重命名为 `step`。

**重点**：让数组空间**尽可能的开大**，能开多大开多大，全部用 `long long` 代替 `int`，保证不溢出。我们不缺时间，但要**保证输出正确**。

整理后的代码如下：

```cpp
namespace I {
	long long xu[30000000],sa[30000000],rank[30000000],cc[30000000],sec[30000000],h[30000000],n;
	bool cmp(long long x, long long y) {
		return xu[x] < xu[y];
	}
	void Do() {
		memset(xu,0,sizeof xu), memset(sa,0,sizeof sa), memset(rank,0,sizeof rank), memset(cc,0,sizeof cc), memset(sec,0,sizeof sec), memset(h,0,sizeof h);
		
		long long *v1; // ecx
		long long v2; // eax
		long long *v3; // ecx
		long long v4; // eax
		long long maxval; // eax (v6)
//		long long v7;
		long long v10; // [esp+18h] [ebp-28h] BYREF
		long long v11; // [esp+1Ch] [ebp-24h] BYREF
		long long ans; // [esp+20h] [ebp-20h] (v12)
		long long cnt; // [esp+2Ch] [ebp-14h] (v13)
		long long step; // [esp+30h] [ebp-10h] (v14)
		long long i; // [esp+34h] [ebp-Ch]

		scanf("%lld", &n);
		for ( i = 1; i <= n; ++i )
			scanf("%lld", &xu[i]);
		xu[n + 1] = 0;
		for ( i = 1; i <= n; ++i )
			sa[i] = i;
		sort(sa+1, sa+1+n, cmp);
		cnt = 0;
		for ( i = 1; i <= n; ++i ) {
			for ( rank[sa[i]] = ++cnt; i < n && xu[sa[i]] == xu[sa[i + 1]]; rank[sa[i]] = cnt )
				++i;
		}
		step = 1;
		while ( cnt < n ) {
			for ( i = 1; i <= n; ++i )
				++cc[rank[i + step]];
			for ( i = 1; i <= cnt; ++i )
				cc[i] += cc[i - 1];
			for ( i = 1; i <= n; ++i ) {
				v1 = &cc[rank[i + step]];
				v2 = *v1;
				sec[v2] = i;
				*v1 = v2 - 1;
			}
			for ( i = 0; i <= cnt; ++i )
				cc[i] = 0;
			for ( i = 1; i <= n; ++i )
				++cc[rank[i]];
			for ( i = 1; i <= cnt; ++i )
				cc[i] += cc[i - 1];
			for ( i = n; i > 0; --i ) {
				v3 = &cc[rank[sec[i]]];
				v4 = *v3;
				sa[v4] = sec[i];
				*v3 = v4 - 1;
			}
			for ( i = 0; i <= cnt; ++i )
				cc[i] = 0;
			cnt = 0;
			for ( i = 1; i <= n; ++i ) {
				for ( sec[sa[i]] = ++cnt;
				        i < n
				        && rank[sa[i]] == rank[sa[i + 1]]
				        && rank[sa[i] + step] == rank[sa[i + 1] + step];
				        sec[sa[i]] = cnt ) {
					++i;
				}
			}
			for ( i = 1; i <= n; ++i )
				rank[i] = sec[i];
			step *= 2;
		}
		for ( i = 1; i <= n; ++i ) {
			if ( rank[i] != 1 ) {
				v10 = h[i - 1] - 1;
				v11 = 0;
				maxval = max(v11, v10);
				for ( h[i] = maxval; xu[h[i] + i] == xu[sa[rank[i] - 1] + h[i]]; ++h[i] ) ;
			}
		}
		ans = 0LL;
		for ( i = 1; i <= n; ++i ) ans += i;
		for ( i = 1; i <= n; ++i ) ans -= h[i];
		cout << ans << endl;
	}
}
```

运行这个程序，得到答案，AC。

---

## 作者：_Arahc_ (赞：2)


很佩服能把第八个点做出来的人，我看题解才知道的。

## 题意

题目传送门：[Link to Luogu](https://www.luogu.com.cn/problem/P5246)。

> 给定十个问题的输入数据，还有其可执行文件。可执行文件不能运行较大的数据，你可以运行测试可执行文件。你需要猜出每个问题的题面，并得到其输出数据。
>
> 如果输入数据较大或不合法，可执行文件将并输出 $\texttt{invalid input.}$ 且不会执行你的数据。

是一个提交答案题。

## 题解

Linux 运行它给的可执行文件要先 `chmod` 一下不然没权限运行不了。

### case 1

输入是个字符串，经过测试发现这个东西不能跑长度 $>10$ 的串。

输出也是字符串，长度与输入相等，不难发现其字符是一一对应的。

于是测试一下每个字符会变成什么就行。

```cpp
namespace Type1{
    char turn[27]="yfrbkgimujvphatdsnelozcxwq";
    string a;
    inline void sol(){
        for(register int T=read();T>0;--T){
            cin>>a;
            int n=a.size();
            for(register int i=0;i<n;++i)
                cout<<turn[a[i]-'a'];
            cout<<"\n";
        }
    }
}
```

### case 2

输入一个数字。首先发现依次输入 $1,2,3,\ldots$，它是递增的，但是大约在 $2\times 10^5$ 这个位置往后一点，它变小了。我们推测这是对一个数取模了。

把得到的 $2030,8082,18166,32282,50430,72610$ 作一次差分得到 $6052,10084,14116,18148,22180$。再作一次差分就变成了 $4032,4032,4032,4032,\ldots$。

所以序列的差分是一个等差数列，那么其差分的通项公式为 $6052+4032(n-1)$。因此原序列的通项公式为：
$$
a_n = 2030 + 2020(n-1) + 2016n(n-1)
$$
对什么数取模？我们发现原本的 $a_{11} = 243990$，而实际的 $a_{11} = 10657$，因此模数为 $233333$。

```cpp
namespace Type2{
    int mod=233333;
    inline void sol(){
        for(register int T=read();T>0;--T){
            long long n=read();
            write((2030+2020LL*(n-1)%mod+2016LL*n%mod*(n-1)%mod)%mod),putchar('\n');
        }
    }
}
```

### case 3

也是输入一个数，我们发现 $[1,3]$ 的数输出 $0$；$[4,12]$ 之内输出 $1$；$[13,28]$ 输出 $2$；$[29,50]$ 输出 $3$；$[51,78]$ 输出 $4$……

看了很久没找到规律，把数列丢到 OEIS 上得到：
$$
a_n = \left\lfloor \sqrt{\frac{n}{\pi}} \right\rfloor
$$

```cpp
namespace Type3{
    const double Pi=acos(-1);
    inline void sol(){
        for(register int T=read();T>0;--T){
            int n=read();
            write(floor(sqrt(1.0*n/Pi))),putchar('\n');
        }
    }
}
```

### case 4

输入数据非常图论，我们丢到 graph editor 上，首先可以确定图是可以不连通的，且如果它是有向图，那么也不一定要是 DAG。

图论的话可以先试试一棵树，不难发现都输出 $n^2$，然后尝试加一条边，发现仍然是 $n^2$，进一步测试，感觉在树上任意加边都输出 $n^2$，而且通过调换边的顺序和方向答案不变，猜想输入图是无向图。

结合第一个数据，考虑不连通图，就不难得到答案为每个连通块大小的平方和了。

```cpp
namespace Type4{
    bool vis[100005];
    int n,m,cnt,sz[100005],ans;
    inline void dfs(int u){
        vis[u]=1;
        ++sz[cnt];
        for(register int i=e.hd[u];i;i=e.nx[i]){
            int v=e.to[i];
            if(!vis[v]) dfs(v);
        }
    }
    inline void sol(){
        for(register int T=read();T>0;--T){
            n=read(),m=read(),ans=cnt=0;
            e.clear(),memset(vis,0,sizeof(vis));
            for(register int i=1;i<=m;++i){
                int u=read(),v=read();
                e.add(u,v),e.add(v,u);
            }
            for(register int i=1;i<=n;++i) if(!vis[i]){
                sz[++cnt]=0;
                dfs(i);
                ans+=sz[cnt]*sz[cnt];
            }
            write(ans),putchar('\n');
        }
    }
}
```

### case 5

本来以为是一棵有边权的树，加了很多增补边，然后求一些奇怪的东西比如生成树之类的……

其实后面那些“没有边权的边”是“询问两个点”……

明确了这一点就很简单了，测试的时候考虑只放一组询问，然后看输出答案是什么，再试试多组询问的情况。就可以发现其实是查寻树上两点距离，输出所有询问答案的异或和。

```cpp
namespace Type5{
    int fa[100005][22],dis[100005][22],dep[100005];
    int n,Q,ans;
    inline void dfs(int u,int f){
        fa[u][0]=f,dep[u]=dep[f]+1;
        for(register int i=1;i<=20;++i){
            fa[u][i]=fa[fa[u][i-1]][i-1],
            dis[u][i]=dis[u][i-1]+dis[fa[u][i-1]][i-1];
        }
        for(register int i=e.hd[u];i;i=e.nx[i]){
            int v=e.to[i];
            if(v==f) continue;
            dis[v][0]=e.ln[i];
            dfs(v,u);
        }
    }
    inline int dist(int x,int y){
        if(x==y) return 0;
        if(dep[x]<dep[y]) swap(x,y);
        int res=0;
        for(register int i=20;i>=0;--i)
            if(dep[fa[x][i]]>=dep[y]){
                res+=dis[x][i],
                x=fa[x][i];
            }
        if(x==y) return res;
        for(register int i=20;i>=0;--i)
            if(fa[x][i]!=fa[y][i]){
                res+=dis[x][i]+dis[y][i];
                x=fa[x][i],y=fa[y][i];
            }
        return res+dis[x][0]+dis[y][0];
    }
    inline void sol(){
        for(register int T=read();T>0;--T){
            n=read(),Q=read(),ans=0;
            e.clear();
            for(register int i=1;i<n;++i){
                int u=read(),v=read(),w=read();
                e.add(u,v,w),e.add(v,u,w);
            }
            dfs(1,0);
            while(Q--){
                int x=read(),y=read();
                ans^=dist(x,y);
            }
            write(ans),putchar('\n');
        }
    }
}
```

### case 6

和上一个测试点非常像。用类似的方法不难得到其实就是把查寻两点距离改成了查寻两点路径边权最小值。

不过应该注意的是，询问两个相同的点时答案是多少。直接随便丢一个树，然后只查一个询问，查寻一个点到它自己，可以得到若两点相同，则答案为 $1987654321$。

```cpp
namespace Type6{
    int fa[100005][22],dis[100005][22],dep[100005];
    int n,Q,ans;
    const int inf=1000000000000000LL;
    inline void dfs(int u,int f){
        fa[u][0]=f,dep[u]=dep[f]+1;
        for(register int i=1;i<=20;++i){
            fa[u][i]=fa[fa[u][i-1]][i-1],
            dis[u][i]=min(dis[u][i-1],dis[fa[u][i-1]][i-1]);
        }
        for(register int i=e.hd[u];i;i=e.nx[i]){
            int v=e.to[i];
            if(v==f) continue;
            dis[v][0]=e.ln[i];
            dfs(v,u);
        }
    }
    inline int dist(int x,int y){
        if(x==y) return 1987654321;
        if(dep[x]<dep[y]) swap(x,y);
        int res=inf;
        for(register int i=20;i>=0;--i)
            if(dep[fa[x][i]]>=dep[y]){
                res=min(res,dis[x][i]),
                x=fa[x][i];
            }
        if(x==y) return res;
        for(register int i=20;i>=0;--i)
            if(fa[x][i]!=fa[y][i]){
                res=min(res,min(dis[x][i],dis[y][i])),
                x=fa[x][i],y=fa[y][i];
            }
        return min(res,min(dis[x][0],dis[y][0]));
    }
    inline void sol(){
        for(register int T=read();T>0;--T){
            n=read(),Q=read(),ans=0;
            e.clear(),memset(dis,0x3f,sizeof(dis));
            for(register int i=1;i<n;++i){
                int u=read(),v=read(),w=read();
                e.add(u,v,w),e.add(v,u,w);
            }
            dfs(1,0);
            while(Q--){
                int x=read(),y=read();
                ans^=dist(x,y);
            }
            write(ans),putchar('\n');
        }
    }
}
```

### case 7

第二难找到规律的点。

交换任意两个数，答案不变，因此数对是无序的。

找规律发现对于同一个 $x$，$(3,x)-(2,x)$ 的差和余数有关。推测它是一个数论函数。

但是 $(2,2)=5$，因此它不应该是任何单元数论函数相加或相乘？

二元？

最后得到答案为：
$$
\sum_{i=1}^a \sum_{j=1}^b \gcd(i,j)
$$
枚举 $\gcd$，考虑莫反：
$$
\sum_{d=1}^{\min(a,b)} d \sum_{x=1}^{\left\lfloor\frac{\min(a,b)}{d}\right\rfloor} \mu(x) \left\lfloor\frac{a}{dx}\right\rfloor \left\lfloor\frac{b}{dx}\right\rfloor
$$
换元：
$$
\sum_{t=1}^{\min(a,b)} \left\lfloor\frac{a}{t}\right\rfloor \left\lfloor\frac{b}{t}\right\rfloor \sum_{x\mid t} \frac{t}{x} \mu(x)
$$
后面是 $\mu\ast\mathrm{id}=\varphi$：
$$
\sum_{t=1}^{\min(a,b)} \varphi(t) \left\lfloor\frac{a}{t}\right\rfloor \left\lfloor\frac{b}{t}\right\rfloor
$$
预处理欧拉函数的前缀和，整除分块可以做到 $\mathcal O(\sqrt{n})$。当然对于本题而言，$\mathcal O(n)$ 跑一遍也可以。

```cpp
namespace Type7{
    int pr[1000006],cntp,phi[1000006];
    bool isp[1000006];
    inline void getpr(int n){
        memset(isp,1,sizeof(isp));isp[1]=0;
        phi[1]=1;
        for(register int i=2;i<=n;++i){
            if(isp[i]){
                pr[++cntp]=i,
                phi[i]=i-1;
            }
            for(register int j=1;j<=cntp && i*pr[j]<=n;++j){
                isp[i*pr[j]]=0;
                if(i%pr[j]==0){
                    phi[i*pr[j]]=phi[i]*pr[j];
                    break;
                }
                phi[i*pr[j]]=phi[i]*phi[pr[j]];
            }
        }
        for(register int i=1;i<=n;++i)
            phi[i]+=phi[i-1];
    }
    inline void sol(){
        getpr(1000000);
        for(register int T=read();T>0;--T){
            int a=read(),b=read(),up=min(a,b),ans=0;
            for(register int l=1,r;l<=up;l=r+1){
                r=min(a/(a/l),b/(b/l));
                ans+=(a/l)*(b/l)*(phi[r]-phi[l-1]);
            }
            write(ans),putchar('\n');
        }
    }
}
```

### case 8

很佩服能看出规律的人。

找了很久没找到规律，开题解，题解说是求本质不同子串个数……

然后就变成后缀数组板子了……

```cpp
namespace Type8{
    struct SA{
        int sm[1000006],rk[1000006],sa[1000006],tp[1000006],ht[1000006],m,n;
        SA(){m=300;memset(sa,0,sizeof(sa));}

        inline void sort(){
            memset(sm,0,sizeof(sm));
            for(register int i=1;i<=n;++i)
                ++sm[rk[i]];
            for(register int i=1;i<=m;++i)
                sm[i]+=sm[i-1];
            for(register int i=n;i>=1;--i){
                sa[sm[rk[tp[i]]]]=tp[i],
                --sm[rk[tp[i]]];
            }
        }
        inline void build(int a[]){
            for(register int i=1;i<=n;++i){
                rk[i]=a[i],
                tp[i]=i;
            }
            sort();
            int len=1;
            while(1){
                int cnt=0;
                for(register int i=1;i<=len;++i)
                    tp[++cnt]=n-len+i;
                for(register int i=1;i<=n;++i)
                    if(sa[i]>len)
                        tp[++cnt]=sa[i]-len;
                sort(),
                memcpy(tp,rk,sizeof(rk));
                rk[sa[1]]=cnt=1;
                for(register int i=2;i<=n;++i){
                    if(tp[sa[i]]==tp[sa[i-1]] && tp[sa[i]+len]==tp[sa[i-1]+len])
                        rk[sa[i]]=cnt;
                    else
                        rk[sa[i]]=++cnt;
                }
                m=cnt,len<<=1;
                if(cnt>=n) break;
            }
            for(register int i=1,j=0;i<=n;++i){
                if(j) --j;
                int k=sa[rk[i]-1];
                while(a[i+j]==a[j+k])
                    ++j;
                ht[rk[i]]=j;
            }
        }
    }sa;
    int n,a[1000006];
    inline void sol(){
        for(register int T=read();T>0;--T){
            n=sa.n=read();
            for(register int i=1;i<=n;++i)
                a[i]=read();
            sa.build(a);
            int ans=n*(n+1)/2;
            for(register int i=1;i<=n;++i)
                ans-=sa.ht[i];
            write(ans),putchar('\n');
        }
    }
}
```

### case 9

输入了 $n$ 个数对？考虑 $n=2$ 的情况，发现它输出的就是两点距离。

这个时候一般有几种情况：凸包、平面最近点对、平面最远点对、某点到其它所有点的距离和。

然而这些情况都可以用一个正方形判断出来，输入一个 $(1,1),(1,2),(2,1),(2,2)$ 的正方形，它输出 $1$。进一步地测试，不难得到其实就是在算平面最近点对。

然而我平面最近点对一直都是 K-DTree 水过去的（不会分治.jpg），但 $10^6$ 显然跑不动。

平面最近点对加强版的题解中，最高赞题解是这么写的：

> 我们充分发扬人类智慧：
>
> 将所有点全部绕原点旋转同一个角度，然后按横坐标排序。
>
> 根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远。
>
> 所以我们只取每个点向后的 $5$ 个点来计算。

（——[3A17K](https://www.luogu.com.cn/user/12655)）

可以通过。

```cpp
namespace Type9{
    struct dot{
        double x,y;
        bool operator < (const dot &b) const{
            dot a=*this;
            return a.x<b.x;
        }
    }a[1000006];
    int n;
    double res;
    const double Pi=acos(-1);
    inline double dist(dot a,dot b){
        return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
    }
    inline void calc(double ang){
        ang=ang/180.0*Pi;
        for(register int i=1;i<=n;++i){
            double x=a[i].x,y=a[i].y;
            a[i].x=x*cos(ang)-y*sin(ang),
            a[i].y=x*sin(ang)+y*cos(ang);
        }
        sort(a+1,a+1+n);
        for(register int i=1;i<=n;++i)
            for(register int j=1;j<=5 && i+j<=n;++j)
                res=min(res,dist(a[i],a[i+j]));
    }
    inline void sol(){
        srand(time(0));
        for(register int T=read();T>0;--T){
            n=read(),res=1e15;
            for(register int i=1;i<=n;++i)
                a[i].x=read(),a[i].y=read();
            calc(rand()%360);
            printf("%.3lf\n",res);
        }
    }
}
```

### case 10

无论怎么输入都输出 $\texttt{invalid input!}$ 是为什么呢？

尝试的字符串都不合法吗？

不合法？

建议回到原题看一下，不合法的时候输出 $\texttt{invalid input.}$（末尾是个句号），而这里输出的末尾是感叹号。

因此这个点就是随便怎么输入，反正就输出 $\texttt{invalid input!}$ 即可。

```cpp
namespace Type10{
    inline void sol(){
        for(register int T=read();T>0;--T)
            puts("invalid input!");
    }
}
```

## 附记

上面的代码凑起来就是这题的主要代码了。

因为这个题是提交答案题，所以不需要交代码，只要运行一下跑出每个点就行了。

（而且你们真的会想去看一个 10k 的代码吗……）

---

## 作者：cike_bilibili (赞：1)

好好好无聊了开始做提交答案了。

## Subtask 1

多手玩几个字符串发现每一个字母都转化成了一个固定的字母，所以 Subtask 1 就是**字符串映射**，将每个字母对应的映射打一个表出来即可。


```cpp
char mp[30]={0,'y','f','r','b','k','g','i','m','u','j','v','p','h','a','t','d','s','n','e','l','o','z','c','x','w','q'};
```

## Subtask 2 

把 $n \in [1,5]$ 的答案打出来发现是 $2030,8082,18166,32282,50430$，我们敏锐的发现两两之间的差值是等差数列，简单推导得到 $f_i=2016i^2+4i+10$。

容易发现这个东西是要取模的，继续手玩发现 $f_{11}=243990$，但问出来却是 $10657$，所以这里发生了取模，得到模数是 $243990-10657=233333$。

## Subtask 3

我们发现随着 $n$ 增大时答案增长非常的慢，我们猜测可能和根号有关。

打表发现 $n=4$ 时 $f_n$ 变成 $1$，$n=13$ 时 $f_n$ 变成 $2$，大胆猜测 $f_n = {\lfloor \sqrt \frac{n}{\pi} \rfloor}$。

我认为这需要拉马努金的注意力，因为我没有注意出来。

## Subtask 4

观察输入发现给了一张图，尝试造几个树发现答案都是 $n^2$，尝试造几个不连通图发现答案有变化，多手玩几下就能发现答案是所有联通块大小的平方和。

用并查集维护就行。

## Subtask 5

观察输入发现这是给了一棵树，还有一个参数 $Q$ 表示询问组数，但是无论 $Q$ 多大答案都是一个整数，所以我们从 $Q=1$ 入手，发现输出的一直是两点距离，尝试将 $Q$ 变大，发现输出的是所有答案的异或和。

随便用什么方法求出两点距离就行了，记得开 long long。

## Subtask 6

发现还是一棵树，还是 $Q$ 组询问，尝试改变边权发现询问的是两点之间的边权最小值，并且最后输出的还是所有询问的异或和。

基本想到 Subtask 5 的都会往这方面想吧，思路还挺自然的，树上倍增一下就行了。

## Subtask 7

尝试固定一个 $n$ 枚举 $m$ 发现答案逐渐增大，并且交换 $n,m$ 答案不变，多手玩几组就能发现询问的是 $\sum_{i=1}^n \sum_{j=1}^m \gcd(i,j)$。

发现只有一组询问 $n\ne m$，暴力求解，所以当成 $n=m$ 来算就行。
 
使用莫比乌斯反演，容易推出答案为 $\sum_{i=1}^n \varphi(i) (\lfloor \frac{n}{i} \rfloor)^2$。

不会的出门左转 [P2398](https://www.luogu.com.cn/problem/solution/P2398)。

## Subtask 8

纯纯人类智慧。

注意到答案最大值为 $\frac{n(n+1)}{2}$ 猜测答案与字串个数有关，多手玩一下发现答案是本质不同字串个数。

经典结论，用后缀数组即可得到答案为 $\frac{n(n+1)}{2} - \sum_{i=1}^n height_i$。

## Subtask 9

发现输入中给了 $n$ 个二元组，观察答案是三位小数可知这些都是平面上的整点，答案和欧几里得距离有关，玩一下发现就是平面最近点对。

反正数据都发下来了，直接人类智慧做法，按 $x \times y$ 排序取前一百个更新答案就行了。

## Subtask 10

你无论输入什么都会得到输出 `invalid input!`。

输出 `invalid input!` 即可。

---


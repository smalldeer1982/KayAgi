# [集训队互测 2018] 完美的队列

## 题目描述

小 D 有 $n$ 个 `std::queue<int>`，他把它们编号为 $1$ 到 $n$。

小 D 对每个队列有不同的喜爱程度，如果有他不怎么喜欢的队列占用了太大的内存，小 D 就会不开心。

具体地说，如果第 $i$ 个队列的 `size()` 大于 $a_i$，小 D 就会对这个队列一直执行 `pop()` 直到其 `size()` 小等于 $a_i$。

现在这些队列都是空的，小 D 觉得太单调了，于是他决定做一些操作。

每次操作都可以用 `l r x` 来描述，表示对编号在 $[l,r]$ 内的所有队列执行 `push(x)` 操作。当然，每次操作结束后，小 D 都会用之前提到的方法来避免这些队列占用太大的内存。

小 D 的队列很神奇，所以他能用 $O(1)$ 的时间执行每次操作。

相信大家的队列都能做到，于是小 D 把这道题出给大家送分。

为了证明你确实执行了这些操作，你需要在每次操作后输出目前还在队列内的权值种数。

## 说明/提示

### 样例解释

第一次操作后，队列变成 $\{1\}\{1\}\{\}$，还在队列内的权值有 $1$，共 $1$ 种。

第二次操作后，队列变成 $\{1\}\{1,2\}\{2\}$，还在队列内的权值 $1,2$，共 $2$ 种。

第三次操作后，队列变成 $\{3\}\{2,3\}\{2,3\}$，还在队列内的权值有 $2,3$，共 $2$ 种。

### 数据范围

对于所有数据，$n,m,a_i,x\leq 10^5$，$l\leq r$。

共 $20$ 个测试点，每个测试点 $5$ 分，其中第 $k$ 个测试点满足 $n,m,a_i,x\leq 5000k$。

特别地，以下几个测试点满足一些特殊性质：

测试点 $5$：$a_i=1$；  
测试点 $7$：$a_i=2$；  
测试点 $9$：$a_i=10$；  
测试点 $11$：$a_i\leq 10$；  
测试点 $13,15$：$\sum a_i\leq 10^6$。

对于每个测试点，你需要通过满足该点数据范围及性质的所有数据才能获得该点的分数。

## 样例 #1

### 输入

```
3 3
1 2 3
1 2 1
2 3 2
1 3 3```

### 输出

```
1
2
2```

# 题解

## 作者：yyyyxh (赞：10)

发现时限这么大，考虑根号。题目相当于是对于每一个询问，你需要求出往后添加多少个询问之后有每个点的 $cnt$ 数组对应位置超过 $a$。可以直接序列分块，劈成一段一段后所有答案直接取个 $\max$ 就是原答案。

整块的话考虑离线处理出所有位置的答案，这个答案明显是有单调性的所以可以双指针。直接用线段树比较憨，发现你可以直接用分块的结构，散块的修改暴力做，整块修改直接打标记。

散块考虑对每个位置扫描线，发现是让我们支持加入删除和查询第 $k$ 大，树状树组可以直接做到 $O(n\sqrt{n\log n})$。

但是插入删除第 $k$ 大这玩意也是可以根号平衡的，具体地我们再维护一个数组 $mp$ 表示第 $i$ 大的数位于哪个块内，发现插入和删除对于这个数组的影响都是 $O(\sqrt n)$ 的，然后再对每个块维护第 $k$ 大的数具体是哪个，这个数组可以暴力重构，于是就做到了 $O(n\sqrt n)$，空间离线一些东西当然可以做到 $O(n)$。

```cpp
#include <cstdio>
#include <vector>
#include <cmath>
#include <cassert>
#include <algorithm>
using namespace std;
int read(){
	char c=getchar();int x=0;
	while(c<48||c>57) c=getchar();
	do x=(x<<1)+(x<<3)+(c^48),c=getchar();
	while(c>=48&&c<=57);
	return x;
}
const int N=100003,B=320;
int n,m,sq,bn;
int ql[N],qr[N];
vector<int> vec[N],ui[N],ud[N],qi[N],qd[N];
int bel[N],res[N],ans[N];
int a[N],lb[B],rb[B];
int ccbase[N<<1],*cc=ccbase+N,arr[N];
namespace Block{
	int bid[N],mp[N];
	int cnt[B],pre[N];
	int f[B][B],msq;
	int mlb[N],mrb[N];
	inline void init(){
		msq=ceil(sqrt(m));
		for(int i=1;i<=m;++i) bid[i]=(i-1)/msq+1;
		for(int i=1;i<=bid[m];++i){
			mlb[i]=(i-1)*msq+1;
			mrb[i]=i*msq;
		}
		mrb[bid[m]]=m;
	}
	inline void inc(int x){
		int xx=bid[x];
		for(int i=x;i<=mrb[xx];++i) ++pre[i];
		for(int i=mrb[xx];i>=mlb[xx];--i) f[xx][pre[i]]=i;
		for(int i=bid[m];i>=xx;--i) mp[++cnt[i]]=i;
	}
	inline void dec(int x){
		int xx=bid[x];
		for(int i=x;i<=mrb[xx];++i) --pre[i];
		for(int i=mrb[xx];i>=mlb[xx];--i) f[xx][pre[i]]=i;
		for(int i=xx;i<=bid[m];++i) mp[cnt[i]--]=i+1;
		mp[cnt[bid[m]]+1]=0;
	}
	inline int qry(int x){return cnt[bid[x]-1]+pre[x];}
	inline int jump(int x){
		if(x>=N) return m+1;
		if(!mp[x]) return m+1;
		int xx=mp[x];
		x-=cnt[xx-1];
		return f[xx][x];
	}
}
bool exi[N];
int s[N],tp;
int ss[N],stp;
int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i) a[i]=read();
	sq=ceil(sqrt(n));
	for(int i=1;i<=n;++i) bel[i]=(i-1)/sq+1;
	bn=bel[n];
	for(int i=1;i<=bn;++i) lb[i]=(i-1)*sq+1,rb[i]=i*sq;
	rb[bn]=n;
	for(int i=1;i<=m;++i){
		ql[i]=read();qr[i]=read();
		vec[read()].emplace_back(i);
		res[i]=i;
	}
	for(int x=1;x<=bn;++x){
		int tag=0,mn=0x3f3f3f3f;
		for(int i=lb[x];i<=rb[x];++i){
			++cc[arr[i]=-a[i]];
			if(mn>arr[i]) mn=arr[i];
		}
		for(int i=1,j=0;i<=m;++i){
			while(j<=m&&tag+mn<=0){
				if(++j>m) break;
				if(ql[j]<=lb[x]&&rb[x]<=qr[j]) ++tag;
				else{
					int l=max(lb[x],ql[j]),r=min(rb[x],qr[j]);
					for(int t=l;t<=r;++t){
						--cc[arr[t]];
						++cc[++arr[t]];
					}
					if(!cc[mn]) ++mn;
				}
			}
			if(ql[i]<=lb[x]&&rb[x]<=qr[i]){
				--tag;
				if(res[i]<j) res[i]=j-1;
			}
			else{
				int l=max(lb[x],ql[i]),r=min(rb[x],qr[i]);
				for(int t=l;t<=r;++t){
					--cc[arr[t]];
					++cc[--arr[t]];
				}
				if(cc[mn-1]) --mn;
			}
		}
		for(int i=lb[x];i<=rb[x];++i) --cc[arr[i]=-a[i]];
	}
	for(int i=1;i<=m;++i){
		int l=ql[i],r=qr[i];
		ui[l].emplace_back(i);
		ud[r+1].emplace_back(i);
		if(bel[r]-bel[l]<=1){
			qi[l].emplace_back(i);
			qd[r+1].emplace_back(i);
		}
		else{
			qi[l].emplace_back(i);
			qd[rb[bel[l]]+1].emplace_back(i);
			qi[lb[bel[r]]].emplace_back(i);
			qd[r+1].emplace_back(i);
		}
	}
	Block::init();
	for(int ps=1;ps<=n;++ps){
		for(int x:qd[ps]) exi[x]=0;
		for(int i=1;i<=tp;++i) if(exi[s[i]]) ss[++stp]=s[i];
		tp=stp;stp=0;
		for(int i=1;i<=tp;++i) s[i]=ss[i];
		for(int x:qi[ps]) exi[x]=1,s[++tp]=x;
		for(int x:ui[ps]) Block::inc(x);
		for(int x:ud[ps]) Block::dec(x);
		for(int i=1;i<=tp;++i){
			int x=s[i];
			int cur=Block::jump(Block::qry(x)+a[ps]);
			if(cur>res[x]) res[x]=cur-1;
		}
	}
	for(int i=0;i<N;++i){
		int mx=0;
		for(int x:vec[i]){
			int l=x,r=res[x];
			if(mx>=l) l=mx+1;
			if(l<=r){++ans[l];--ans[r+1];}
			if(r>mx) mx=r;
		}
	}
	for(int i=1;i<=m;++i) ans[i]+=ans[i-1];
	for(int i=1;i<=m;++i) printf("%d\n",ans[i]);
	return 0;
}
```

但是这个题似乎并不能规约到一些经典根号题，所以说我们可以去思考一下 $\text{polylog}$ 咋做。我们分块做法散块的根号平衡看起来做得很不优美，所以我们考虑只将整块的做法扩展到 $\text{polylog}$。我们改为用线段树划分整个区间，每个询问在 $O(\log)$ 个节点处被处理，每个节点处理的询问答案同样具有单调性。我们依旧考虑在每个线段树节点上双指针。

但是会影响到某个线段树节点的修改看起来很多？考虑我们刚才分块是怎么优化的：注意绝大部分修改都是整块修改，于是直接打标记。线段树同样有这个性质，除开完全包含某个区间的修改，剩下的与该区间有交的修改的量级是 $O(n\log n)$ 的。考虑线段树每次区间操作只会访问 $O(\log)$ 个节点所以这个性质是显然的。

完全包含某个区间的修改的贡献我们可以拿个数据结构（比如树状数组）维护出每次修改的时间。我们发现我们只需要直接从父亲继承这些修改，每次继承之后的变化量之和是 $O(n\log n)$ 的，所以我们需要按 dfs 序处理这些区间并且动态维护这个树状数组就行了。

剩下的就和分块差不多，直接对与该区间有交的修改双指针。整块修改的贡献就从树状数组里查一下。求答案时就在树状数组上倍增一下。时间复杂度 $O(n\log^2 n)$。在本题的数据范围下不如单根号快。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
int read(){
	char c=getchar();int x=0;
	while(c<48||c>57) c=getchar();
	do x=(x<<1)+(x<<3)+(c^48),c=getchar();
	while(c>=48&&c<=57);
	return x;
}
const int N=100003;
int n,m;
int ql[N],qr[N],res[N];
vector<int> vec[N];
int ans[N],a[N];
vector<int> qry[N<<2],upd[N<<2];
void hang(int x,int p=1,int l=1,int r=n){
	if(ql[x]<=l&&r<=qr[x]){
		qry[p].emplace_back(x);
		return;
	}
	upd[p].emplace_back(x);
	int mid=(l+r)>>1;
	if(ql[x]<=mid) hang(x,lc,l,mid);
	if(qr[x]>mid) hang(x,rc,mid+1,r);
}
int mn[N<<2],tg[N<<2];
inline void proc(int p,int v){mn[p]+=v;tg[p]+=v;}
inline void pushdown(int p){
	if(tg[p]){
		proc(lc,tg[p]);
		proc(rc,tg[p]);
		tg[p]=0;
	}
}
void build(int p,int l,int r){
	tg[p]=0;
	if(l==r){mn[p]=-a[l];return;}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	mn[p]=min(mn[lc],mn[rc]);
}
void update(int x,int v,int p,int l,int r){
	if(ql[x]<=l&&r<=qr[x]) return proc(p,v);
	pushdown(p);
	int mid=(l+r)>>1;
	if(ql[x]<=mid) update(x,v,lc,l,mid);
	if(qr[x]>mid) update(x,v,rc,mid+1,r);
	mn[p]=min(mn[lc],mn[rc]);
}
int tr[N];
inline void mdf(int x,int v){for(int i=x;i<=m;i+=(i&-i)) tr[i]+=v;}
inline int ask(int x){
	int res=0;
	for(int i=x;i;i^=(i&-i)) res+=tr[i];
	return res;
}
inline int jump(int v){
	if(!v) return 0;
	int x=0;
	for(int i=16;~i;--i)
		if(x+(1<<i)<=m&&tr[x+(1<<i)]<v) v-=tr[x+=(1<<i)];
	return x+1;
}
void dfs(int p=1,int l=1,int r=n){
	build(p,l,r);
	for(int x:qry[p]) mdf(x,1);
	int len=upd[p].size(),t=0,o=0;
	for(int x:qry[p]){
		int cur=ask(x);
		while(o<len&&upd[p][o]<x) update(upd[p][o++],-1,p,l,r);
		while(t<len&&ask(upd[p][t])-cur+mn[p]<0) update(upd[p][t++],1,p,l,r);
		int pos=jump(cur-mn[p])-1;
		if(t&&pos<upd[p][t-1]) pos=upd[p][t-1]-1;
		if(pos>res[x]) res[x]=pos;
	}
	if(l<r){
		int mid=(l+r)>>1;
		dfs(lc,l,mid);
		dfs(rc,mid+1,r);
	}
	for(int x:qry[p]) mdf(x,-1);
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=m;++i){
		ql[i]=read();qr[i]=read();
		vec[read()].emplace_back(i);
		res[i]=i;hang(i);
	}
	dfs();
	for(int i=0;i<N;++i){
		int mx=0;
		for(int x:vec[i]){
			int l=x,r=res[x];
			if(mx>=l) l=mx+1;
			if(l<=r){++ans[l];--ans[r+1];}
			if(r>mx) mx=r;
		}
	}
	for(int i=1;i<=m;++i) ans[i]+=ans[i-1];
	for(int i=1;i<=m;++i) printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：yzy1 (赞：5)

分享一个 polylog 的做法．

首先对于每个操作，我们只关心这个操作什么时候被完全 pop 掉．考虑将所有修改操作离线，然后挂到线段树区间上，则一个操作被完全 pop 掉的时间为这些拆出来的区间被完全 pop 掉的时间的 $\max$．然后像类似于线段树分治那样，DFS 整颗线段树．仿照分块做法中对于整块的处理，对于每个拆出来的区间，计算它完全被 pop 掉的时间．在 DFS 到一个线段树结点的时候，我们只需要关心三种拆出来的区间：「挂在当前结点祖先上的」、「挂在当前结点上的」和「挂在当前结点的子树中（不包含自己）的」．同时，我们需要计算「挂在当前结点上的」的区间被 pop 的时间．

考虑双指针，先把这三种区间按照操作编号排序，枚举左端点．再开一颗线段树维护区间 $(a_i - {}$当前 stack size$)$ 的最小值，初始每个位置的值为 $-a_i$．扫右端点的过程中只需要线段树区间${}+1$，维护全局最小值是否 $> 0$ 即可．什么时候区间最小值变成正数就说明左端点对应的操作被完全 pop 掉了．而移动左端点，只需要线段树区间${}-1$．

直接暴力把这三种区间拿出来跑双指针复杂度是 $O(n^2 \log n)$ 的，不可接受．但我们发现，对于所有线段树结点，第二种和第三种区间的数量和不超过 $O(n \log n)$ 个，而对于第一种区间，这类区间对当前线段树结点对应的区间的贡献相当于一个全局加减．也就是说，我们可以找到按照操作序号排序后的相邻两个第二或第三种区间，把之间的连续的第一种区间压缩成一次全局加减几的操作．现在我们需要快速知道相邻两个二三类区间之间第一类区间的数量，直接在 DFS 线段树的过程中顺便维护区间和即可．

时间复杂度 $O(n (\log n)^2)$，可以通过本题．

代码参考见 [原始 OJ 提交](https://loj.ac/s/1996941)．


---

## 作者：tzc_wk (赞：3)

听说有 polylog 做法，但是偷懒想了个根号 log 的做法，肯定有优化的空间，但一看数据范围 $10^5$ 就摆烂了。

显然对于一次操作，我们只用关心最早什么时候这次操作加入的数全部都被 pop 掉了，求出这个之后对于 $x$ 相同的操作我们放一起考虑，求一遍区间并即可算出贡献。

于是问题转化为如何求第 $i$ 次插入的元素全部被 pop 掉的最早时间 $r_i$。对序列分块，每块 $B$ 个元素，对于整块，我们用 two pointers 求出每个时刻 $i$ 之后最早的时刻 $r$，使得对于这块中每个位置 $j$，都有 $(i,r]$ 中每个位置 $j$ 被插入的次数都至少为 $a_j$（显然满足单调性）。处理方法就是考虑一次操作与 $[L_b,R_b]$ 的交，如果是整块就打 tag，否则暴力改，显然这部分复杂度是 $\dfrac{nm}{B}$ 的。对于散块，扫描线  + 树状数组上二分即可，复杂度 $mB\log^2n$，取 $B=\dfrac{n}{\log n}$ 即可。

```cpp
const int MAXN=1e5;
const int INF=0x3f3f3f3f;
int n,m,a[MAXN+5],c[MAXN+5],tag,cmx,rit[MAXN+5];
int blk_sz,blk_cnt,L[MAXN+5],R[MAXN+5],bel[MAXN+5];
struct opt{int l,r,x;}b[MAXN+5];
void modify(int l,int r,int b,int v){
	if(l==L[b]&&r==R[b])tag+=v;
	else if(l<=r){
		for(int i=l;i<=r;i++)c[i]+=v;cmx=-INF;
		for(int i=L[b];i<=R[b];i++)chkmax(cmx,c[i]);
	}
}
vector<pii>vec[MAXN+5];
int res[MAXN+5];
vector<int>qv[MAXN+5],ql[MAXN+5],qr[MAXN+5];
int t[MAXN+5];
void add(int x,int v){for(int i=x;i<=MAXN;i+=(i&(-i)))t[i]+=v;}
int query(int x){int ret=0;for(int i=x;i;i&=(i-1))ret+=t[i];return ret;}
int main(){
	scanf("%d%d",&n,&m);for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)scanf("%d%d%d",&b[i].l,&b[i].r,&b[i].x); 
	blk_sz=100;blk_cnt=(n-1)/blk_sz+1;
	for(int i=1;i<=blk_cnt;i++){
		L[i]=(i-1)*blk_sz+1;R[i]=min(i*blk_sz,n);
		for(int j=L[i];j<=R[i];j++)bel[j]=i;
	}
	for(int i=1;i<=blk_cnt;i++){
		cmx=tag=0;
		for(int j=L[i];j<=R[i];j++)c[j]=a[j]+1,chkmax(cmx,a[j]+1);
		for(int j=1,k=1;j<=m;j++){
			if(k<j)k=j;
			while(k<=m&&cmx+tag>0){
				modify(max(L[i],b[k].l),min(R[i],b[k].r),i,-1);
				++k;
			}
			if(b[j].l<=L[i]&&R[i]<=b[j].r){
				if(cmx+tag>0)rit[j]=m+1;
				else chkmax(rit[j],k-1);
			}
			modify(max(L[i],b[j].l),min(R[i],b[j].r),i,1);
		}
	}
	for(int i=1;i<=m;i++){
		ql[b[i].l].pb(i);qr[b[i].r+1].pb(i);
		qv[bel[b[i].l]].pb(i);
		if(bel[b[i].l]!=bel[b[i].r])qv[bel[b[i].r]].pb(i);
	}
	for(int i=1;i<=n;i++){
		for(int id:ql[i])add(id,1);
		for(int id:qr[i])add(id,-1);
		for(int id:qv[bel[i]]){
			if(b[id].l<=i&&i<=b[id].r){
				int l=id,r=m,p=id-1;
				while(l<=r){
					int mid=l+r>>1;
					if(query(mid)-query(id)<a[i])p=mid,l=mid+1;
					else r=mid-1;
				}
				chkmax(rit[id],p+1);
			}
		}
	}
	for(int i=1;i<=m;i++)vec[b[i].x].pb(mp(i,rit[i]-1));
	for(int i=1;i<=MAXN;i++)if(!vec[i].empty()){
		sort(vec[i].begin(),vec[i].end());
		for(int l=0,r;l<vec[i].size();l=r){
			r=l;int mxr=vec[i][l].se;
			while(r<vec[i].size()&&vec[i][r].fi<=mxr)chkmax(mxr,vec[i][r].se),++r;
			res[vec[i][l].fi]++;res[mxr+1]--;
		}
	}
	for(int i=1;i<=m;i++)res[i]+=res[i-1];
	for(int i=1;i<=m;i++)printf("%d\n",res[i]);
	return 0;
}
```



---

## 作者：Cindy_Li (赞：2)

#### 题意

有 $n$ 个队列，容量为 $a_i$。$m$ 次操作 $(l,r,x)$，向第 $[l,r]$ 个队列插入 $x$，超出容量弹出队头。

求每次操作后全局颜色数量，$n,m\le 10^5$。

#### 题解

注意到对于每次操作，只关心什么时候被全部弹出，即找到最小的时刻 $j$ 满足 $(i+1,j]$ 中 $[l,r]$ 至少被 push 了 $a_i$ 次。

对序列分块，询问区间拆到块上，最后取 $\max$ 即可。处理整块时，整块修改打 tag，散块修改直接重构；散块拆到单点上，相当于是 $m\sqrt n$ 次询问“第 $i$ 个队列，时刻 $x$ 后再 push $a_i$ 次的时间”。扫描线 + 树状数组二分即可。

代码里维护的 $rtm$ 是存在时间，即被全部弹出的时刻 $-1$。

```c++
const int N=1e5+5,B=2e3+5;
int n,m,a[N],blk[N],L[N],R[N];
struct que{
    int l,r,x;
}q[N];
int rtm[N];
vector<int> opt[N];
vector<int> vec[B];
vector<pair<int,int> > seg[N];
int res[N];
int c[N];
inline void add(int x,int v){
    for(int i=x;i<=m;i+=(i&-i)) c[i]+=v;
}
inline int ask(int r){
    int res=0;
    for(int i=r;i;i-=(i&-i)) res+=c[i];
    return res;
}

int main(){
    read(n),read(m);int mxa=0;
    rep(i,1,n) read(a[i]);
    rep(i,1,m){
        read(q[i].l),read(q[i].r),read(q[i].x);
        mxa=max(mxa,q[i].x);
    }
    int blk_sz=100,blk_ct=(n-1)/blk_sz+1;
    rep(i,1,blk_ct) {
        L[i]=R[i-1]+1,R[i]=min(n,L[i]+blk_sz-1);
        rep(j,L[i],R[i]) blk[j]=i;
    }
    rep(i,1,blk_ct){
        vector<int> ct(R[i]-L[i]+1);
        int mx=0,tg=0;
        rep(j,L[i],R[i]) ct[j-L[i]]=a[j],mx=max(mx,a[j]);

        auto modify=[&](int l,int r,int o){
            if(l>r) return;
            if(l<=L[i] && r>=R[i]) return mx+=o,tg+=o,void();
            rep(j,L[i],R[i]) ct[j-L[i]]+=tg;tg=0,mx=-1e9;
            rep(j,l,r) ct[j-L[i]]+=o;
            rep(j,L[i],R[i]) mx=max(mx,ct[j-L[i]]);
        };
        for(int l=1,r=1;l<=m;l++){
            if(r<l) r=l;
            while(r<=m && mx>=0){
                modify(max(L[i],q[r].l),min(R[i],q[r].r),-1);
                r++;
            }
            if(q[l].l<=L[i] && q[l].r>=R[i]){
                if(mx>=0) rtm[l]=max(rtm[l],m);
                else rtm[l]=max(rtm[l],r-2);
            } 
            modify(max(L[i],q[l].l),min(R[i],q[l].r),1);
        }
    }
    rep(i,1,m) {
        opt[q[i].l].push_back(i);
        opt[q[i].r+1].push_back(-i);
        vec[blk[q[i].l]].push_back(i);
        if(blk[q[i].r]!=blk[q[i].l])
            vec[blk[q[i].r]].push_back(i);
    }
    rep(i,1,n){
        for(auto x:opt[i]) (x>0)?add(x,1):add(-x,-1);
        for(auto x:vec[blk[i]]){
            if(q[x].l<=i && q[x].r>=i){
                int l=x,r=m+1;
                while(l<r){
                    int mid=(l+r)>>1;
                    if(ask(mid)-ask(x)>=a[i]) r=mid;
                    else l=mid+1; 
                }
                rtm[x]=max(rtm[x],l-1);
            }
        }
    }
    rep(i,1,m) seg[q[i].x].push_back({i,rtm[i]});
    rep(i,1,mxa)if(!seg[i].empty()){
        sort(seg[i].begin(),seg[i].end());
        int id=0;
        while(id<seg[i].size()){
            int l=seg[i][id].first,r=seg[i][id].second;
            while(id+1<seg[i].size() && seg[i][id+1].first<=r+1) 
                r=max(r,seg[i][id+1].second),id++;
            res[l]++,res[r+1]--;
            id++;
        }
    }
    rep(i,1,m) res[i]+=res[i-1];
    rep(i,1,m) printf("%d\n",res[i]);
    return 0;
}
```

乐子：调试这个题的过程中，我花费了至少 0.5h 才发现我写成了 `mxa=max(mxa,a[i])`，导致计算答案出现神秘错误，改完就通过了。这启示我们，变量名要容易分辨。

---

## 作者：苏联小渣 (赞：2)

写一下 $O(n \sqrt{n \log n})$ 的做法以及卡空间的一些方法，或许也不需要卡空间？不过我的实现比较烂。

直接维护序列感觉很困难，所以考虑每个数的贡献。

对于一次操作 $[l,r,x]$，容易发现颜色 $x$ 的贡献范围是一段区间，也就是说，从当前时刻 $i$ 开始，到 $x$ 在 $[l,r]$ 中每一个队列都被弹出的时间 $j$，那么 $[i,j-1]$ 就是这次加入颜色的贡献区间。

所以，假设我们求出了每次操作的贡献区间，对于每种颜色，我们对它的贡献区间取个并集，就能得到它对哪些时刻的答案有影响；而贡献区间总数是 $O(n)$ 的，所以这部分是容易做的。

那么问题就变成了求出最小的 $j$，使得从 $i$ 时刻开始，$[l,r]$ 的每个位置 $p$ 都至少被覆盖了 $a_p$ 次（这样的话，就会把这次加入的 $x$ 弹出）。考虑分块，对于整块预处理 $f_{bl,i}$ 表示第 $bl$ 块，从第 $i$ 时刻开始最小的 $j$。显然同一块内的处理是可以双指针的，需要支持区间加、区间查询最值，同样的用分块即可。

需要注意的是，这里的区间加、区间查询最值的方法，是如果当前的**操作区间** $[l,r]$ 包含第 $bl$ 块的区间 $[b_l,b_r]$，那么直接打 tag；否则相当于对于散块加，暴力重构即可。需要注意的是这里暴力重构是 $O(m \sqrt{n})$ 而不是平方级别的，因为考虑这个相当于正常对 $m$ 个操作进行分块处理的过程。

现在我们只需要处理散块的贡献，也就是单点的贡献，我们需要回答 $O(m \sqrt{n})$ 个询问，每个询问都是从第 $i$ 时刻开始，位置 $x$ 最小的 $j$，使得在 $[i,j]$ 中 $x$ 被覆盖了至少 $a_x$ 次。发现这里有序列维和时间维，考虑离线扫描线，维护每一个 $x$ 在时间维上的信息，对序列进行扫描线，用线段树在 $l$ 处给 $i$ 时刻的增量加一，在 $r+1$ 处给 $i$ 时刻的增量减一，对于一个询问 $(x,i)$，相当于在线段树的 $[i,n]$ 这个后缀进行二分，得到最小的 $j$。用线段树上二分容易实现，通过调整块长可以做到 $O(n \sqrt{n \log n})$。

然后这样的话空间是 $O(n \sqrt{n})$ 的，直接写会被卡。考虑优化空间，我的实现需要用两个根号级别的数组，一个是预处理的，一个是离线询问的。由于两个第二维乘起来刚好是 $n$，所以普通调整块长无法解决；考虑把一个给去掉，以第一个为例，在预处理中，对于当前块 $[b_l,b_r]$，它对所有满足 $l <b_l,r>b_r$ 的区间有贡献，用 multiset 插入/遍历即可，这样就能过了。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 100000
int n, m, l, r, x, mx, tag, block, a[100010], c[100010], id[100010], L[100010], R[100010], rig[100010], d[100010];
int f[100010];
inline int read(){
	int s=0, w=1; char ch=getchar();
	while (ch<'0' || ch>'9'){
		if (ch=='-') w=-1; ch=getchar();
	}
	while (ch>='0' && ch<='9'){
		s=(s<<3)+(s<<1)+(ch^48); ch=getchar();
	}
	return s*w;
}
struct opera{
    int l, r, x;
}b[100010];
struct Add{
    int t, op;
};
struct col{
    int l, r;
};
struct Cmp{
	int r, id;
	bool operator < (const Cmp &A) const{
		return r < A.r;
	}
};
multiset <Cmp> s;
multiset <Cmp> :: iterator itt;
vector <int> ask[100010];
vector <Cmp> jia[100010];
vector <Add> ad[100010];
vector <col> cun[100010];
map <int, int> mp;
map <int, int> :: iterator it;
inline int max(int x, int y){
	return x > y ? x : y;
}
void modify(int l, int r, int ql, int qr, int val){
    if (l > qr || r < ql) return ;
    if (l <= ql && r >= qr) tag += val;
    else{
        mx = -1e9;
        for (int i=max(l, ql); i<=min(r, qr); i++){
            c[i] -= val;
        }
        for (int i=ql; i<=qr; i++){
            mx = max(mx, c[i]);
        }
    }
}
struct segment{
    #define lc(x) x<<1
    #define rc(x) x<<1|1
    int lim, flag, now, d[400010];
    inline void modify(int k, int l, int r, int x, int y){
        if (l == r){
            d[k] += y;
            return ;
        }
        int mid = l + r >> 1;
        if (x <= mid) modify(lc(k), l, mid, x, y);
        else modify(rc(k), mid+1, r, x, y);
        d[k] = d[lc(k)] + d[rc(k)];
    }
    inline void find(int k, int l, int r){
        if (l == r){
            now = l;
            return ;
        }
        int mid = l + r >> 1;
        if (lim - d[lc(k)] <= 0) find(lc(k), l, mid);
        else{
            lim -= d[lc(k)];
            find(rc(k), mid+1, r);
        }
    }
    inline void query(int k, int l, int r, int x, int y){
    	if (x > y) return ;
        if (x <= l && r <= y){
            if (flag) return ;
            if (lim - d[k] <= 0){
                flag = 1;
                find(k, l, r);
            }
            lim -= d[k];
            return ;
        }
        int mid = l + r >> 1;
        if (x <= mid) query(lc(k), l, mid, x, y);
        if (y > mid) query(rc(k), mid+1, r, x, y);
    }
}S;
int main(){
	n=read(), m=read();
    block = 190;
    for (int i=1; i<=n; i++){
    	a[i]=read();
        id[i] = (i - 1) / block + 1;
        if (id[i] != id[i-1]) L[id[i]] = i;
        R[id[i]] = i;
    }
    for (int i=1; i<=m; i++){
    	b[i].l=read(), b[i].r=read(), b[i].x=read();
        jia[b[i].l].push_back((Cmp){b[i].r, i});
    }
    for (int bl=1; L[bl]; bl++){
        mx = tag = 0;
        int ll = L[bl], rr = R[bl];
    	while (!s.empty() && (*s.begin()).r <= rr) s.erase(s.begin());
        for (int i=ll; i<=rr; i++) mx = max(mx, a[i]), c[i] = a[i];
        for (int i=1, j=0; i<=m; i++){
            while (j < m+1 && mx > tag){
                j ++;
                modify(b[j].l, b[j].r, ll, rr, 1);
            }
            f[i] = j;
            modify(b[i].l, b[i].r, ll, rr, -1);
        }
        f[m+1] = m+1;
        for (itt=s.begin(); itt!=s.end(); itt++){
        	rig[(*itt).id] = max(rig[(*itt).id], f[(*itt).id+1] - 1);
		}
        for (int i=ll; i<=rr; i++){
        	for (int j=0; j<jia[i].size(); j++){
        		s.insert(jia[i][j]);
			}
		}
    }
    for (int i=1; i<=m; i++){
        l = b[i].l, r = b[i].r, x = b[i].x;
        if (id[l] == id[r]){
            for (int j=l; j<=r; j++){
                ask[j].push_back(i);
            }
        }
        else{
            for (int j=l; id[j]==id[l]; j++){
                ask[j].push_back(i);
            }
            for (int j=r; id[j]==id[r]; j--){
                ask[j].push_back(i);
            }
        }
        ad[l].push_back((Add){i, 1});
        ad[r+1].push_back((Add){i, -1});
    }
    for (int i=1; i<=n; i++){
        for (int j=0; j<ad[i].size(); j++){
            int t = ad[i][j].t, op = ad[i][j].op;
            S.modify(1, 1, m, t, op);
        }
        for (int j=0; j<ask[i].size(); j++){
            int fir = ask[i][j];
            S.lim = a[i], S.flag = 0, S.now = m+1;
            S.query(1, 1, m, fir+1, m);
    		rig[fir] = max(rig[fir], S.now - 1);
		}
    }
    for (int i=1; i<=m; i++){
        cun[b[i].x].push_back((col){i, rig[i]});
    }
    for (int i=1; i<=N; i++){
        if (!cun[i].size()) continue;
        mp.clear();
        for (int j=0; j<cun[i].size(); j++){
            mp[cun[i][j].l] ++, mp[cun[i][j].r+1] --;
        }
        int lst = 0, now = 0;
        mp[m+1] = 0;
        for (it=mp.begin(); it!=mp.end(); it++){
            if (now) d[lst] ++, d[it->first] --;
            now += it->second;
            lst = it->first;
        }
    }
    for (int i=1; i<=m; i++){
        d[i] += d[i-1];
        printf ("%d\n", d[i]);
    }
    return 0;
}
```

---

## 作者：lzqy_ (赞：2)

polylog 看上去很难做，看一眼时限和范围，考虑根号。

对队列分块，考虑刻画一种算法，使得散块的操作（以下称为散数）暴力插入暴力弹出，整块的操作（以下称为整数）同时插入同时弹出，这样均摊下来就是对的。

对于每个块开一棵线段树记录每个队列中散数的信息。当插入新数时，暴力弹出可以弹掉的散数。若整个块内队列都超容且无法再弹出散数时，说明存在整数需要被弹出，此时整块操作即可。

时间复杂度 $O(nB+\frac {n^2}B\log n)$，当 $B=\sqrt{n\log n}$ 时时间复杂度为 $O(n\sqrt {n\log n})$。

反正均摊尽可能多的东西就对了（


```cpp
#include<bits/stdc++.h>
#define ll long long
#define mp make_pair
#define il inline
using namespace std;
const int maxB=505;
const int maxn=100010;
const int inf=1<<30;
const int B=220;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
int q[maxB][maxn];
int tot[maxB],del[maxB];
int d1[maxB][B+10<<2];
int d2[maxB][B+10<<2];
int lz[maxB][B+10<<2];
int hd[maxB],tl[maxB];
int L[maxB],R[maxB],bl[maxn];
ll tap[maxn];
int ans,n,m,M;
queue<pair<int,int> >Q[maxn];
il void update(int t,int i){
	d1[t][i]=max(d1[t][i<<1],d1[t][i<<1|1]);
	d2[t][i]=min(d2[t][i<<1],d2[t][i<<1|1]);
}
il void build(int t,int i,int l,int r){
	d2[t][i]=inf;
	if(l==r){
		d1[t][i]=read();
		return ;
	}int mid=l+r>>1;
	build(t,i<<1,l,mid);
	build(t,i<<1|1,mid+1,r);
	update(t,i);
}
il void pushdown(int t,int i){
	if(!lz[t][i]) return ;
	d1[t][i<<1]+=lz[t][i],d1[t][i<<1|1]+=lz[t][i];
	if(d2[t][i<<1]!=inf) d2[t][i<<1]+=lz[t][i];
	if(d2[t][i<<1|1]!=inf) d2[t][i<<1|1]+=lz[t][i];
	lz[t][i<<1]+=lz[t][i],lz[t][i<<1|1]+=lz[t][i];
	lz[t][i]=0;
}
void Add(int t,int i,int l,int r,int L,int R,int x){
	if(l>=L&&r<=R){
		d1[t][i]+=x,lz[t][i]+=x;
		if(d2[t][i]!=inf) d2[t][i]+=x;
		return ;
	}int mid=l+r>>1;
	pushdown(t,i);
	if(mid>=L) Add(t,i<<1,l,mid,L,R,x);
	if(mid<R) Add(t,i<<1|1,mid+1,r,L,R,x);
	update(t,i);
}
void Mark(int t,int i,int l,int r,int L,int R,int f){
	if(l==r){
		if(d2[t][i]==inf) 
			d2[t][i]=d1[t][i]+f;
		return ;
	}int mid=l+r>>1;
	pushdown(t,i);
	if(mid>=L) Mark(t,i<<1,l,mid,L,R,f);
	if(mid<R) Mark(t,i<<1|1,mid+1,r,L,R,f);
	update(t,i);
}
void pop(int t,int i,int l,int r){
	if(d2[t][i]-del[t]>=0) return ;
	if(l==r){
		//printf("in->%d\n",l);
		//printf("tap[%d]=%lld\n",Q[l].front().first,tap[Q[l].front().first]);
		if(!(--tap[Q[l].front().first])) ans--;
		d1[t][i]++,Q[l].pop();
		if(Q[l].empty()) d2[t][i]=inf;
		else d2[t][i]=d1[t][i]+Q[l].front().second;
		return ;
	}int mid=l+r>>1;
	pushdown(t,i);
	if(d2[t][i<<1]-del[t]<0) pop(t,i<<1,l,mid);
	if(d2[t][i<<1|1]-del[t]<0) pop(t,i<<1|1,mid+1,r);
	update(t,i);
}
il void Delete(int i){
	Add(i,1,L[i],R[i],L[i],R[i],1);
	tap[q[i][hd[i]]]-=R[i]-L[i]+1;
	if(!tap[q[i][hd[i]]]) ans--;
	hd[i]++,del[i]++;
}
void solve(int l,int r,int x){
	if(!tap[x]) ans++;
	tap[x]+=r-l+1;
	int Bl=bl[l],Br=bl[r];
	//////////////////////////////////Bl
	Add(Bl,1,L[Bl],R[Bl],l,min(r,R[Bl]),-1);
	Mark(Bl,1,L[Bl],R[Bl],l,min(r,R[Bl]),tot[Bl]);
	for(int j=l;j<=min(r,R[Bl]);j++)
		Q[j].push(mp(x,tot[Bl]));
	pop(Bl,1,L[Bl],R[Bl]);
	if(d1[Bl][1]<0) Delete(Bl);
	if(Bl==Br) return ;
	///////////////////////////////Br
	Add(Br,1,L[Br],R[Br],L[Br],r,-1);
	Mark(Br,1,L[Br],R[Br],L[Br],r,tot[Br]);
	for(int j=L[Br];j<=r;j++)
		Q[j].push(mp(x,tot[Br]));
	pop(Br,1,L[Br],R[Br]);
	if(d1[Br][1]<0) Delete(Br);
	///////////////////////////Mid
	for(int i=Bl+1;i<Br;i++){
		q[i][++tl[i]]=x,tot[i]++;
		Add(i,1,L[i],R[i],L[i],R[i],-1);
		pop(i,1,L[i],R[i]);
		if(d1[i][1]<0) Delete(i);
	}
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) bl[i]=(i-1)/B+1;
	for(int i=1;i<=bl[n];i++)
		L[i]=(i-1)*B+1,R[i]=min(i*B,n);
	for(int i=1;i<=bl[n];i++) hd[i]=1;
	for(int i=1;i<=bl[n];i++) build(i,1,L[i],R[i]);
	while(m--){
		int l=read(),r=read(),x=read();
		solve(l,r,x),printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：R_shuffle (赞：1)

由于不太会分块，所以考虑带 $\log$ 的做法。

考虑每个操作存在的时间轴，不妨把所有的修改离线下来挂到线段树上。那么在一个区间上某个操作所存在的最大时间就是区间中最大的 $a$。

然后考虑每个区间，参照分块做法，需要考虑一个节点祖先、自己和子树内的区间。暴力的话可以把这些区间都拉出来排序，然后枚举左端点做，这个是简单的。

再考虑优化暴力，由于自己的区间和子树的区间的总和是 $O(n\log n)$ 的，而其祖先的区间是可以直接看做区间加减的，所以考虑在进入一个点的时候把贡献直接加上，退出的时候回溯即可。

这样就可以做到 $O(n\log^2 n)$ 的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
inline int read()
{
    int re=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
    while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^48),ch=getchar();
    return re*f;
}
const int N=1e5+5;
int n,m,a[N];
vector<int>vec[N],que[N<<2],upd[N<<2];
int minn[N<<2],tag[N<<2];
int ans[N],res[N];
struct node
{
    int l,r;
}q[N];
void build(int num,int l,int r)
{
    tag[num]=0;
    if(l==r)
    {
        minn[num]=-a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(num*2,l,mid);
    build(num*2+1,mid+1,r);
    minn[num]=min(minn[num*2],minn[num*2+1]);
}
void hang(int num,int l,int r,int pl,int pr,int id)
{
    if(l>=pl&&r<=pr)
    {
        que[num].push_back(id);
        return ;
    }
    upd[num].push_back(id);
    int mid=(l+r)>>1;
    if(pl<=mid) hang(num*2,l,mid,pl,pr,id);
    if(pr>mid) hang(num*2+1,mid+1,r,pl,pr,id);
}
void add_tag(int num,int x)
{
    minn[num]+=x;
    tag[num]+=x;
}
void push_down(int num)
{
    if(tag[num])
    {
        add_tag(num*2,tag[num]);
        add_tag(num*2+1,tag[num]);
        tag[num]=0;
    }
}
void modify(int num,int l,int r,int pl,int pr,int x)
{
    if(l>=pl&&r<=pr) return add_tag(num,x);
    push_down(num);
    int mid=(l+r)>>1;
    if(pl<=mid) modify(num*2,l,mid,pl,pr,x);
    if(pr>mid) modify(num*2+1,mid+1,r,pl,pr,x);
    minn[num]=min(minn[num*2],minn[num*2+1]);
}
int c[N];
int lowbit(int x)
{
    return x&(-x);
}
void add(int x,int xx)
{
    while(x<=m) c[x]+=xx,x+=lowbit(x);
}
int ask(int x)
{
    int re=0;
    while(x) re+=c[x],x-=lowbit(x);
    return re;
}
int get(int x)
{
    if(!x) return 0;
    int rk=0;
    for(int i=20;~i;i--) if(rk+(1<<i)<=m&&c[rk+(1<<i)]<x) rk+=(1<<i),x-=c[rk];
    return rk+1;
}
void solve(int num,int l,int r)
{
    build(num,l,r);
    for(auto x:que[num]) add(x,1);
    int len=upd[num].size(),p1=0,p2=0;
    for(auto x:que[num])
    {
        int val=ask(x);
        while(p2<len&&upd[num][p2]<x) modify(1,1,n,q[upd[num][p2]].l,q[upd[num][p2]].r,-1),p2++;
        while(p1<len&&ask(upd[num][p1])-val+minn[num]<0) modify(1,1,n,q[upd[num][p1]].l,q[upd[num][p1]].r,1),p1++;
        int pos=get(val-minn[num])-1;
        if(p1&&pos<upd[num][p1-1]) pos=upd[num][p1-1]-1;
        res[x]=max(res[x],pos);
    }
    if(l!=r)
    {
        int mid=(l+r)>>1;
        solve(num*2,l,mid);
        solve(num*2+1,mid+1,r);
    }
    for(auto x:que[num]) add(x,-1);
}
signed main(){
#if __MY_TEST__
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=m;i++)
    {
        q[i].l=read(),q[i].r=read();
        vec[read()].push_back(i);
        hang(1,1,n,q[i].l,q[i].r,i);
        res[i]=i;
    }
    solve(1,1,n);
    for(int i=0;i<=100000;i++)
    {
        int maxn=0;
        for(auto x:vec[i])
        {
            int l=x,r=res[x];
            if(maxn>=l) l=maxn+1;
            if(l<=r) ans[l]++,ans[r+1]--;
            maxn=max(maxn,r);
        }
    }
    for(int i=1;i<=m;i++) ans[i]+=ans[i-1],cout<<ans[i]<<'\n';
}

```

---

## 作者：eastcloud (赞：1)

首先有一个等价转换，我们把题意变为求出每种颜色存在的时间区间，也即求出每个操作带来的元素在什么时候会被完全弹出。

使用数据结构直接维护这个东西貌似有些困难，但是我们可以考虑把操作放到每一个队列上，然后对求出来的每个答案取个 max 就行。

直接操作的复杂度肯定是 $O(n^2)$ 的，考虑用一些能维护区间的数据结构把重复的部分优化掉，这个数据范围先考虑分块，分块后我们要求的就变成了整块的插入操作什么时候被完全弹出和小块的什么时候被完全弹出。

对于整块的答案，由于每个块互不干扰，考虑枚举块，这时整块的操作肯定就有了单调性，可以在大块上双指针，注意这里也要考虑这块里面的散块操作，问题就变成了单点加整体修改，这个是好维护的。

对于散块的答案我们同样可以使用双指针，而此时同样也要考虑同属一块的整块操作，这个在预处理后精细实现同样可以做到 $O(n\sqrt n)$，已经可以通过本题。

在感性上，我们用分块维护也有一些重复操作，能不能用线段树呢？我们把每个询问拆到线段树上，此时有关的区间要么在自己身上，要么在子树内，要么在祖先节点上，前两者的总个数是 $O(n \log n)$ 的，直接双指针就行，而后者由于是整体操作，可以对线段树 dfs 的同时进行维护，之后的操作就与分块做法相似了。

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9')f=(ch=='-'?-1:f),ch=getchar();
    while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void write(int x){
    if(x<0)x=-x,putchar('-');
    if(x/10)write(x/10);
    putchar(x%10+'0');
}
struct BIT{
    int K[N];
    int lowbit(int x){return x&(-x);}
    void add(int x,int val){while(x<N){K[x]+=val;x+=lowbit(x);}}
    int ask(int x){int ans=0;while(x){ans+=K[x];x-=lowbit(x);}return ans;}
    int query(int l,int r){return (r>=l?ask(r)-ask(l-1):0);}
    int jump(int val){
        int ans=0,now=0;
        for(int i=(1<<20);i>0;i>>=1){
            if(now+i>=N)continue;
            if(ans+K[now+i]<val)now+=i,ans+=K[now];
        }
        return now;
    }
}G;
int a[N];
struct sgt{
    int ls[N<<1],rs[N<<1],mn[N<<1],tag[N<<1],tot;
    void build(int &x,int l,int r){
        x=++tot;if(l==r)return;
        int mid=(l+r)>>1;build(ls[x],l,mid);build(rs[x],mid+1,r);
    }
    void push_down(int x){
        mn[ls[x]]+=tag[x];mn[rs[x]]+=tag[x];
        tag[ls[x]]+=tag[x];tag[rs[x]]+=tag[x];tag[x]=0;
    }
    void push_up(int x){
        mn[x]=min(mn[ls[x]],mn[rs[x]]);
    }
    void clear(int x,int l,int r){
        if(l==r)return mn[x]=-a[l],tag[x]=0,void();
        tag[x]=0;int mid=(l+r)>>1;
        clear(ls[x],l,mid);clear(rs[x],mid+1,r);push_up(x);
    }
    void update(int x,int val,int l,int r,int L,int R){
        //cout<<x<<' '<<ls[x]<<' '<<rs[x]<<' '<<L<<' '<<R<<' '<<l<<' '<<r<<endl;
        if(L>=l && R<=r)return tag[x]+=val,mn[x]+=val,void();
        push_down(x);int mid=(L+R)>>1;
        if(l<=mid)update(ls[x],val,l,r,L,mid);
        if(r>mid)update(rs[x],val,l,r,mid+1,R);push_up(x);
    }
}T;
struct Node{
    int col,ti;
    Node(int ti=0,int col=0):col(col),ti(ti){}
};
int ql[N],qr[N],qc[N],res[N];
deque<int> q;
namespace SGT{
    int tot,ls[N<<1],rs[N<<1];
    vector<Node> v[N<<1],s[N<<1];
    void build(int &x,int l,int r){
        x=++tot;if(l==r)return;
        int mid=(l+r)>>1;build(ls[x],l,mid);build(rs[x],mid+1,r);
    }
    void push(int x,int l,int r,int L,int R,Node val){
        if(L>=l && R<=r)return v[x].push_back(val),void();
        int mid=(L+R)>>1;s[x].push_back(val);
        if(l<=mid)push(ls[x],l,r,L,mid,val);
        if(r>mid)push(rs[x],l,r,mid+1,R,val);
    }
    void dfs(int x,int l,int r){
        //cout<<x<<' '<<l<<' '<<r<<endl;
        for(auto k:v[x])G.add(k.ti,1);
        T.clear(x,l,r);int pos=0;
        for(int i=0;i<v[x].size();i++){
            int ti=v[x][i].ti;
            while(q.size() && q.front()<ti){
                //cout<<q.front()<<' '<<ql[q.front()]<<' '<<qr[q.front()]<<endl;
                T.update(x,-1,max(ql[q.front()],l),min(qr[q.front()],r),l,r);q.pop_front();
            }
            while(pos<s[x].size() && s[x][pos].ti<ti)pos++;
            int flag=0;
            while(pos<s[x].size() && T.mn[x]+G.query(ti+1,s[x][pos].ti-1)<0){
                //cout<<s[x][pos].ti<<' '<<r<<endl;
                T.update(x,1,max(ql[s[x][pos].ti],l),min(qr[s[x][pos].ti],r),l,r);
                if(T.mn[x]+G.query(ti+1,s[x][pos].ti-1)>=0){
                    flag=1;res[ti]=max(res[ti],s[x][pos].ti-1);
                    T.update(x,-1,max(ql[s[x][pos].ti],l),min(qr[s[x][pos].ti],r),l,r);
                    break;
                }
                q.push_back(s[x][pos].ti);pos++;
            }
            if(flag)continue;
            //cout<<ti<<' '<<T.mn[x]<<' '<<G.ask(ti)<<' '<<l<<' '<<r<<endl;
            res[ti]=max(G.jump(-T.mn[x]+G.ask(ti)),res[ti]);
        }
        while(q.size())q.pop_back();
        int mid=(l+r)>>1;
        if(ls[x])dfs(ls[x],l,mid);if(rs[x])dfs(rs[x],mid+1,r);
        for(auto k:v[x])G.add(k.ti,-1);
    }
}
int las[N],ans[N],mar[N];
int main(){
    #ifdef EAST_CLOUD
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
    #endif
    int n=read(),m=read(),rt=0;SGT::build(rt,1,n);T.build(rt,1,n);
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=m;i++){
        int l=read(),r=read(),c=read();ql[i]=l;qr[i]=r;qc[i]=c;
        SGT::push(rt,l,r,1,n,Node(i,c));
    }
    SGT::dfs(rt,1,n);
    int sum=0;
    for(int i=1;i<=m;i++){
        if(i>las[qc[i]]+1 && las[qc[i]])ans[las[qc[i]]+1]--,ans[i]++;
        else if(!las[qc[i]])ans[i]++;
        las[qc[i]]=max(las[qc[i]],res[i]);
        if(res[i]==N-1 && !mar[qc[i]])sum++,mar[qc[i]]++;
    }
    for(int i=1;i<N;i++)if(las[i])las[i]=min(las[i],m);
    for(int i=1;i<N;i++)if(las[i])ans[las[i]+1]--;
    for(int i=1;i<=m;i++)ans[i]+=ans[i-1],write(ans[i]),putchar('\n');
    return 0;
}
```




---


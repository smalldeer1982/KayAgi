# [HNOI2013] 旅行

## 题目描述

在遥远的 HX 国，住着一个旅行家小 L，他希望骑着他的自行车游遍全国。在这个国家中，每个城市都有一个编号，共有 $n$ 个城市，编号从 $1$ 到 $n$。

有的城市没有小 L 想去的景点，而有的城市有且仅有一个小 L 想去的景点，所有的城市都是这两种情况之一，小 L 非常热爱信息学，他编写程序给他的旅行安排了一条最短路线以到达所有他想去的景点（所有的通知旅行线路上城市编号是乱序的）：他第 $1$ 个到达的城市编号为 $a_1$，第 $i$ 个到达的城市编号为 $a_i$，最后到达城市 $a_n$ 结束这次旅行。小L希望用恰好的 $m$ 个月（$m<n$）的时间完成这次旅行，所以他需要制定一个理性的旅游计划。

当他抵达一个城市时，如果这个城市有他想要去的景点，他会因此获得 $1$ 点快乐值；但是若到达的城市没有他想去的景点，他会因旅途的疲惫得到 $1$ 点的疲劳值：一个月的时间足够他游玩任意多个城市，但他也希望拿出一点时间来休息。他每个月总是在本月所到达的最后一个城市休息（但如果这个城市有景点，那么小 L 总会游玩这个景点再休息）。当然，小 L 希望每个月都能有一定的旅行任务。即便这个月他所到达的城市中并没有他想去的的景点，换句话说，每个月他都会至少到达一个新的城市。

小 L 无法自己安排旅行计划，所以求助于你。你需要告诉他一个序列：$x_1,x_2,\ldots,x_m$，其中 $x_i$ 表示小 L 第 $i$ 个月休息时。他所在的城市编号：由于他最后一个月必须完成他的旅行，所以 $x_m$ 肯定等于 $a_n$，例如，设 $n=5$，$m=3$，$(a_1,a_2,a_3,a_4,a_5)=(3,2,4,1,5)$，$(x_1,x_2,x_3)=(2,1,5)$，这意味着：第 $1$ 个月先后到达 $3$ 号和 $2$ 号城市，并在 $2$ 号城市休息：第 $2$ 个月先后到达 $4$ 号和 $1$ 号城市，并在 $1$ 号城市休息：第 $3$ 个月到达 $5$ 号城市，并在 $5$ 号城市休息。

这样的方案序列有很多种，设每种方案序列中第 $i$ 个月旅行中当月获得的快乐值与疲劳值的差绝对值为 $d_i$，设第 $k$ 种方案序列中求出的 $d_1,d_2,\ldots,d_m$ 这个 $m$ 值的最大值为 $c_k$，小 L 希望所选择的方案序列的 $c_k$ 在所有方案序列中是最小的。

事实上，可能有多个方案序列的 $c_k$ 达到并列最小值。由于小 L 喜爱编程，他患上了一定的强迫症（虽然他自己认为他的强迫症让他炫的发黄），他希望给他的序列是这多个方案中字典序最小的。

Tips：比较两个序列字典序即比较第一个不相同数字的大小，如 $(1,2,3,4)<(1,2,4,3)$。

## 说明/提示

第 $1$ 个月得到 $2$ 点快乐值与 $2$ 点疲劳值，第 $2$ 个月得到 $1$ 点快乐值与 $1$ 点疲劳值，第 $3$ 个月得到 $1$ 点快乐值与 $1$ 点疲劳值。$3$ 个月中疲劳值与快乐值差的最大值为 $0$，达到所有方案最小值。

可行方案有：

- 1 6 8
- 3 6 8
- 3 1 8

其中 1 6 8 字典序最小。

$N \leq 5 \times 10^5$，$M \leq 2 \times 10^5$。

## 样例 #1

### 输入

```
8  3
2  0
3  1
4  1
1  0
5  0
6  1
7  1
8  0```

### 输出

```
1 6 8```

# 题解

## 作者：是个汉子 (赞：7)

[洛谷传送门](https://www.luogu.com.cn/problem/P3229)

这个题用到了单调队列的优化，但是精髓绝不止在于此。+_+

### Solution

##### 我们先不管字典序怎么办，想想怎么求最小的 $ans$ 

首先，因为要的是绝对值，那么考虑将 $0$ 化为 $-1$ ，也就是将没有景点的城市看作会减少一个景点的城市（雾

设 $b_i$ 表示城市 $a_i$ 是否有景点，有为 $1$ ，否则为 $-1$，$sum_{i}$ 表示 $i+1$ 到 $n$ 的后缀和，也就是 $sum_{i}=b_{i+1}+b_{i+2}+\cdots+b_n$ ，那么可以证明答案最小不小于 $\lceil \frac {|sum_0|}m\rceil$ 。

如果全部是 $1$ 或 $-1$ ，显然平均的将 $sum_0$ 分为 $m$ 份最好；如果同时有 $1,-1$ ，将相邻的两个 $1,-1$ 合并可以得到 $0$ 即抵消，最后还是剩下 $sum_0$ 个 $1$ 或 $-1$ ，就和第一种一样了。

但是还是有一种特殊情况的，当 $sum_0=0$ 且 $sum_i=0$ 的 $i$ 的数量不足 $m$ 个，此时答案就是 $1$ ，因为分不了那么多段。

##### 既然 $ans$ 已经能够求出来了，那么就可以回来看看字典序

将 $ans=0$ 和 $ans\not =0$ 分开考虑。

当 $ans=0$ 时，即 $sum_0=0$ 并且 $sum_i=0$ 的 $i$ 的数量 $\geq m$ ，那么就在这些 $i$ 中跑一遍单调队列即可。

再具体就是维护队列里 $a_i$ 从小到大，按照输入顺序入队 ，找到字典序最小的 $m-1$ 个。（因为第 $m$ 个城市必定是 $a_n$ ）

当 $ans\not= 0$ 时，我们假设第 $i$ 段结尾的是 $lst$ ，那么 $i+1$ 段的结尾后一个位置的后缀和 $s$ 需要满足 $|sum_{lst}-s|\leq ans\Rightarrow sum_{lst}-ans\leq s\leq sum_{lst}+ans$ 。

那么选择按 $sum_i$ 分类，对每一种 $sum_i$ 开一个单调队列，维护队列里 $a_i$ 单调递增，选的时候从 $sum_{lst}-ans$ 到 $sum_{lst}+ans$ 枚举选择，注意我们还需要判断 $\lceil \frac {|s|}{m-i}\rceil\leq ans$ 。

注意：这题卡空间，所以要手动写队列。(●ˇ∀ˇ●)

### Code

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define B N

using namespace std;
const int N=500010;

template<typename T>void read(T &x){
    x=0;bool f=0;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    if(f) x=-x;
}

struct node{
    int v,id;
};
int cnt;
struct Node{
    node p;
    int pre,nxt;
}tr[N<<1];
int newcode(node p,int pre,int nxt){tr[++cnt]=(Node){p,pre,nxt}; return cnt;}

struct queue{
    int siz,hd,tl;
    bool empty(){return !siz;}

    void push_front(node p){
        if(!siz) hd=tl=newcode(p,0,0);
        else tr[hd].pre=newcode(p,0,hd),hd=tr[hd].pre;
        ++siz;
    }

    void push_back(node p){
        if(!siz) hd=tl=newcode(p,0,0);
        else tr[tl].nxt=newcode(p,tl,0),tl=tr[tl].nxt;
        ++siz;
    }

    void pop_front(){siz--,hd=tr[hd].nxt;}
    void pop_back(){siz--,tl=tr[tl].pre;}

    node front(){return tr[hd].p;}
    node back(){return tr[tl].p;}
}q[N<<1];

int tot,head[N<<1],nxt[N<<1];
node to[N<<1];
void add(int u,node p){
    to[++tot]=p;
    nxt[tot]=head[u];
    head[u]=tot;
}

int n,m,lst,ct[N],sum[N],rest[N];//rest表示休息点的后缀和 sum表示相加的后缀和
int calc(){
    int ans=0;
    for(int i=n;i>=1;i--){
        if(!sum[i]) ans++,rest[i]=1;
        rest[i]+=rest[i+1];
    }
    if(ans>=m) return 0;
    else return 1;
}

void push(int u,node p){
    while(!q[u].empty()&&p.v<q[u].back().v) q[u].pop_back();
    q[u].push_back(p);
}

node calc(int u,int lim){
    for(int i=head[u];i&&to[i].id<=lim;i=nxt[i]) push(u,to[i]),head[u]=i;
    while(!q[u].empty()&&q[u].front().id<=lst) q[u].pop_front();
    return q[u].empty()?(node){N,N}:q[u].front();
}

node min(node a,node b){return a.v<b.v?a:b;}

int main(){
    read(n); read(m);
    for(int i=1;i<=n;i++) read(ct[i]),read(sum[i-1]),sum[i-1]=(sum[i-1])?1:-1;
    for(int i=n-1;i>=0;i--) sum[i]+=sum[i+1];
    for(int i=n;i>=1;i--) add(sum[i]+B,(node){ct[i],i});
    int S=sum[0],d=(S!=0)?(int)ceil(1.0*abs(S)/(1.0*m)):calc();
    if(d){
        for(int i=1;i<m;i++){
            node ans=(node){N,N};
            for(int j=S-d+B;j<=S+d+B;j++){
                if(ceil(abs(1.0*j-B)/(1.0*m-i))<=d) ans=min(ans,calc(j,n-(m-i)));
            }
            printf("%d ",ans.v);
            lst=ans.id,S=sum[lst];
        }
    }
    else{
        for(int j=1,i=head[B];j<m;j++){
            for(;i&&rest[to[i].id]-1>=m-j;i=nxt[i]) push(B,to[i]);
            printf("%d ",q[B].front().v);
            q[B].pop_front();
        }
    }
    printf("%d\n",ct[n]);
    return 0;
}
```



---

## 作者：Cgod (赞：6)

# 一道欺负我智商的题。。。
~~本来想打单调队列优化dp的，结果看到算法标签就点了此题~~

首先你要理解题意，蒟蒻理解了好久。它就是说，给你一个由1和-1组成的数列，让你分成m段，并让这m段区间和最大值最小，还要求多种方案时字典序最小。

我也不知道大佬怎么做的，反正我不会高斯消元。。。

哦，对了，如果输入的是0，表示他不喜欢则那一位为-1。

设总和为S。区间和最小值为ans。后缀和为sum[]，后缀中0的个数为cnt[]。

为什么是后缀，往后看。。。

首先考虑特殊情况：

- 全是1 显然答案为ans=ceil(S/m);ceil()是向上取整。

- 全是-1 ans=ceil(abs(S)/m)

- 一半全1，一半全-1 比如11111-1-1-1可以变成11(111-1-1-1),括号里为0，可以与任意区间搭配，于是变成了上面的情况。

所以ans=ceil(abs(S)/m)，简易证明：你可以用第三中方法狂消1和-1直到只有一种数，剩下来的数的个数是abs(S)。

如果abs(S)=0且能分的区间不足m那就另当别论。。。

~~由于我太菜了，还有情况没考虑就多多包含~~

先预处理sum[]，ans，cnt[];

- S=0
  
   - cnt[1]>=m,此时找sum[i]=0的点i，用单调队列维护找出字典序最小的一条即可。
   - cnt[1]<m,ans>0,和下面一起处理。
   
- S!=0 sum的每一种取值分开考虑。

  设上一个选的为last，则这一个i能选要满足abs(sum[last+1]-sum[i+1])<=ans,那么我们枚举sum[i+1]的取值时就可以直接从sum[last+1]-ans到sum[last+1]+ans。
  并且abs(sum[i+1]/m'(即剩下要选的数量))要满足小于等于ans，i还有后面的数不能超过m'个。
  然后跑单调队列就完啦，不要告诉我你切黑题还不会这个。。。

实现起来还有不少细节，比如负数下标之类的，仔细看下应该都能懂

代码在我丑陋的[blog](http://www.cnblogs.com/cx233666/p/8708482.html)里。



---

## 作者：2018LZY (赞：5)

> 把一个长度为$n$的序列(每个数为$\pm 1$)分成$m$段,使得所有段的和的绝对值的最大值最小,求出一种段末尾字典序最小的划分.
>
> $n\le 5*10^5,m\le 2*10^5$

[题目](https://loj.ac/problem/2379)

网上大部分都是特别"显然"的题解,本题解尽量不那么显然,~~求轻喷~~



令$t[i]=\begin{cases}\ -1&(b[i]=0) \\ 1& (b[i]=1)\end{cases},s[i]=\sum_{i=1}^n t[i]],S=s[1]$.

现在姑且不管字典序,只求如何求出一组最大值最小的情况.

设$d$表示子段绝对值最大值.

则有$d=\begin{cases} [c_0<m]&(S=0)\\ \lceil \dfrac {|S|} m \rceil & else\end{cases}$.

+ 对于$S=0$且$c_0\ge m$,那么我们取$b[i]=0$的$m$个位置即可.

+ 对于$S=0$且$c_0<m$,我们可以发现$d\ge 1$.

  现在证明一下$d=1$的正确性.

  我们消去所有的0段,则可以得到$|S|$个1 or -1.

  我们现在需要能构造出$m$组合法段.

  先不考虑$m$的限制,如果我们划分出$n$段的话一定合法,然后考虑0 段中可以删除的位置.

  由于$d=1$,等价于我们每次$s$的变化至多为1. 所以,我们把任意0段中的$s$最大值删去一定合法.

  所以就顺利得出$m$段合法.

+ 其他情况,我们均分$|S|$个数成$m$段即可.

事实上,我们代码把**后两种情况**归为一种考虑.($d=0$的时候做法比较明显下面就不考虑了)

由上,其实我们得到了$[i,n]$能划分成$t$段当且仅当$n-i+1\ge t,ceil(\dfrac{|s_i|}{t})\le d$.



现在开始考虑字典序的约束

现在假设我们已经处理了$[1,l),$剩余$t$段要选择,那么我们现在需要考虑$[l,r]$是否合法.

则要满足:

$\begin{cases} |s_l-s_{r+1}|\le d\\ \dfrac{|s_{r+1}|}{t-1}\le d\\n-r\ge t-1\end{cases}$

与此同时,我们要还有最小化当前的$a_r$.



观察式子可以发现$s_{r+1}$是一个非常重要的量(出现了两次)

我们可以把所有$s_{r+1}$相等的位置划分为一个集合,那么这个集合取最小值就是答案.

同时,前面的位置被淘汰.

上面就是一个单调队列的模型了.



所以我们只要维护$2n$个单调队列即可.

复杂度?

我们每次只需扫描$O(d)$个单调队列,所以总复杂度:$O(n+dm)=O(n+|S|)$.



又一次被HNOI的题目征服~~



```cpp
#include<cstdio>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define gc getchar()
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N=5e5+10,M=1e6+10;

template<class o> void qr(o &x) {
	char c=gc; x=0; int f=1;
	while(!isdigit(c)){if(c=='-') f=-1; c=gc;}
	while(isdigit(c))x=x*10+c-'0',c=gc;
	x*=f;
}
template<class o> void qw(o x) {
	if(x<0) putchar('-'),x=-x;
	if(x/10) qw(x/10);
	putchar(x%10+'0');
}
template<class o> void pr1(o x) {qw(x); putchar(' ');}
template<class o> void pr2(o x) {qw(x); puts("");}

int n,m,d,a[N],b[N],c[N],tot;
struct rec {
	int x,id;//数,位置 
	bool operator <(rec b) const {return x<b.x;} 
} t[N],ans;
int cnt[N*2],now;

struct Q {
	int l,r;
	Q(int x=1) {l=x; r=x-1;}
	void push(rec a) {
		while(l<=r&&a<t[r]) r--;
		t[++r]=a;
	}
	void get() {
		while(l<=r&&t[l].id<now) l++;
		if(l<=r&&t[l]<ans) ans=t[l];
	}
} q[N*2];

void add(int x) {	q[b[x+1]+n].push((rec){a[x],x});}

int main() {
	qr(n); qr(m);
	for(int i=1;i<=n;i++) qr(a[i]),qr(b[i]),b[i]=(b[i]?1:-1);
	for(int i=n;i;i--) b[i]+=b[i+1],cnt[b[i+1]+n]++,tot+=!b[i];
	for(int i=0,s=0;i<=2*n;i++) q[i]=Q(s),s+=cnt[i];
	if(!b[1]) d=(tot<m);
	else d=(abs(b[1])-1)/m+1;
	if(!d) {
		tot=0;
		for(int i=1;i<=n;i++)
			if(!b[i+1]) c[++tot]=i;
		now=1;
		for(int i=1,j=1;i<m;i++) {
			while(tot-j>=m-i) q[0].push((rec){a[c[j]],c[j]}),j++;
			ans.x=N; q[0].get(); pr1(ans.x); now=ans.id+1;
		}
	}
	else {
		int r=now=1;
		while(n-r>=m-1)add(r++);
		while(m>1) {
			ans.x=N;
			int x=b[now]+n;
			for(int j=x-d;j<=x+d;j++) 
				if(abs(j-n)<=(m-1)*d) q[j].get();
			pr1(ans.x); now=ans.id+1; 
			m--;  add(r++);
		}
	}
	pr2(a[n]);
	return 0;
}


```


---


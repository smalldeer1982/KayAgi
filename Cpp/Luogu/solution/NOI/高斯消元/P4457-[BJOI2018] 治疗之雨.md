# [BJOI2018] 治疗之雨

## 题目背景

（没玩过《炉石传说》的人可以跳过这一段）今天我们来探讨下《炉石传说》中“治疗之雨”（恢复 $12$ 点生命值，随机分配到所有友方角色上）和“暗影打击装甲”（每当一个角色获得治疗，便对随机敌人造成 $1$点伤害）这两张卡牌之间的互动效果。假设你场上有 $m$个剩余生命值无限大且生命值上限减去剩余生命值也无限大的随从，而对方的场上有 $k$个暗影打击装甲，你的英雄剩余生命值为 $p$、生命值上限为 $n$，现在你使用了一张可以恢复无限多（而不是 $12$ 点）生命值的治疗之雨，问治疗之雨期望总共恢复了几点生命值以后你的英雄会死亡（生命值降为 $0$；治疗之雨的判定机制使得在此后再也不会为英雄恢复生命值）。

注：题目背景与题目描述有冲突的地方请以题目描述为准

下面让我们再形式化地描述一遍问题。

## 题目描述

**题目更新：鉴于很多人反映看不懂题，但是出于尊重原题面的原则不进行大幅度更改。您可以将最小值和最大值理解为下限和上限，类似于题目背景中的血量。**


你现在有 $m+1$ 个数：第一个为 $p$，最小值为 $0$，最大值为 $n$；剩下 $m$个都是无穷，没有最小值或最大值。你可以进行任意多轮操作，每轮操作如下：

在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它加一；

进行 $k$次这个步骤：在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它减一。 

现在问期望进行多少轮操作以后第一个数会变为最小值 $0$。

## 说明/提示

###数据范围

对于 $10\%$ 的数据， $n \leq 3$ ，$m, k \leq 2$ 。

对于 $20\%$ 的数据， $n, m, k \leq 5$ 。

对于 $30\%$ 的数据， $n, m, k \leq 30$ 。

对于 $40\%$ 的数据， $n, m, k \leq 50$ 。

对于 $50\%$ 的数据， $n, m, k \leq 200$ 。

对于 $70\%$ 的数据， $n \leq 200$ 。

对于 $80\%$ 的数据， $n \leq 500$ 。

对于 $100\%$ 的数据， $1 \leq T \leq 100$，$1 \leq p \leq n \leq 1500$ ，$0 \leq m, k \leq 1000000000$。

保证不存在$n=p=k=1$,$m=0$的情况（因为出题人判错了）

保证不存在答案的分母是$1000000007$的倍数的情况（因为出题人没想到）

## 样例 #1

### 输入

```
2
2 1 1 1
2 2 1 1```

### 输出

```
6
8```

# 题解

## 作者：shadowice1984 (赞：35)

非常传统的高斯消元题目……

如果熟练之后可以很快的切掉这道题？
__________________________

## 本体题解

其实在概率题中有一个非常传统的模型

给你一堆点，点u有$P(u,v)$的概率通向点v，求从某个点S出发，经过多少步之后可以第一次到达点T，通常有一些点进入之后就不可以继续出来，比如我们一般认为T点进去之后就不会出来了

然后我们发现这个东西如果不是DAG就不可能使用dp求解，因此我们一般使用高斯消元列方程的做法解决这类问题，一般来讲我们设$E_{i}$为从i出发到达点T的期望步数

那么我们可以得到这样的式子

## $E_{i}=\sum_{j=1}^{n}E_{j}P_{i,j}+1$

## $E_{T}=0$

意思就是这个点的期望步数为所有后继状态的期望步数乘上对应的转移概率之和(显然这符合期望的定义)，最后无论如何转移步数都会+1(或者你可以认为是所有的后继状态的概率之和为1，然后我们本来这个1在Σ里面，我们提了出来)

然后就可以由n个变量，n个方程通过高斯消元求解了
____________________

那么对于这道题我们也可以认为是这个模型

我们可以把每一个血量值i作为一个点，这样我们现在只需要求出转移的概率$P_{i,j}$就可以利用高斯消元大力列方程求解了

发现从状态i可以转移到的状态只有0~i以及i+1这些状态

那么我们我们只需要求出这个英雄受到了a点伤害的概率就可以列方程了

那么这个英雄受到a点伤害的事件可以写成一个01序列，其中受到伤害记为1，不受伤害记为0，那么由于受到了a点伤害，所以有a个1，显然这样的01序列有$C_{k}^{a}$种，每种01序列出现的概率都是

## $(\frac{1}{m+1})^{a}(\frac{m}{m+1})^{k-a}$

所以最后受到k点伤害的概率就是

## $C_{k}^{a}(\frac{1}{m+1})^{a}(\frac{m}{m+1})^{k-a}$

写成阶乘的形式就是

## $\frac{k!}{a!(k-a)!}(\frac{1}{m+1})^{a}(\frac{m}{m+1})^{k-a}$

显然这玩意可以在我们打表了逆元之后线性的递推出来

好了现在我们有了英雄受到k点伤害的概率，让我们开始列方程吧……

以下记$P_{k}$为英雄受到恰好k点伤害的概率，$E_{i}$为血量为i的英雄血量归0的期望步数

对于i！=n的情况我们都需要分两种情况讨论，这个英雄有没有被奶到……

所以我们从i转移到j的概率应该是

## $\frac{m}{m+1}P_{i-j}+\frac{1}{m+1}P_{i-j-1}$

特别的，转移到i+1的前提是没有受到伤害，所以概率应该是

## $\frac{1}{m+1}P_{0}$

特别的，对于i=n的情况我们没有被奶中的可能性，因此i转移到j的概率应该是

## $P_{i-j}$

另外的一点是我们的方程并没有考虑受到过量伤害的问题……，但是我们发现这应该会影响的系数是$E_{0}$的系数，但是有一个问题,我们对于$E_{i}$的定义是血量为i的英雄血量归零的期望步数……，显然$E_{0}=0$因此我们无需考虑$E_{0}$前的系数……

____________________________

所以最后我们列出来的方程大概长这样

对于i=1~n-1

### $E_{i}=(\sum_{j=1}^{j}(\frac{m}{m+1}P_{i-j}+\frac{1}{m+1}P_{i-j-1})E_{j})+(\frac{1}{m+1}P_{0})E_{i+1}+1$

对于 i=n

## $E_{n}=(\sum_{j=1}^{n}P_{n-j}E_{j})+1$


这样n-1个变量n-1个方程我们就可以解出$E_{m}$了，注意这里我们直接代入了$E_{0}=0$从而消掉了矩阵的一行一列

做完了？
__________________________

## 等等，$n=1500$你跟我说高斯消元？

所以我们不能进行$O(n^3)$的高斯消元，我们观察一下这个矩阵，会发现它大概长这样

1 1 0 0 0 0 ……

1 1 1 0 0 0 ……

1 1 1 1 0 0 ……

1 1 1 1 1 0 ……

会发现它的主对角线之上只有一个变量的系数不为1，因此我们可以两行两行的向下消，最后削成这个样子

1 1 0 0 0 0 ……

0 1 1 0 0 0 ……

0 0 1 1 0 0 ……

0 0 0 1 1 0 ……

0 0 0 0 1 1 ……

然后我们发现最后一行没有那个多余的1，所以我们从最后一行开始倒着消元就可以把这个矩阵削成单位矩阵了~

复杂度$O(n^2)$

另外注意判断诸多无解的情况，比如什么k=0，m=0,k=1之类的

还有什么m=0的时候也需要注意判掉

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1510;typedef long long ll;const ll mod=1e9+7;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod){if(p&1){r=r*a%mod;}}return r;}
int n;int p;ll m;ll k;ll mp[N][N];ll f[N];ll inv1;ll inv;ll res;int T;
inline void solve()
{
    scanf("%d%d%lld%lld",&n,&p,&m,&k);
    if(k==0){printf("-1\n");return;}//特判一些特殊情况
    if(m==0)
    {
        if(k==1){printf("-1\n");return;}
        for(;p>0;){if(p<n){p++;}p-=k;res++;}printf("%lld\n",res);res=0;return;
    }inv=po(m+1,mod-2);inv1=po(m,mod-2);f[0]=po(m*inv%mod,k);
    for(int i=1;i<=min((ll)(n+1),k);i++)f[i]=f[i-1]*inv1%mod*po(i,mod-2)%mod*(k-i+1)%mod;//递推f数组
    for(int i=1;i<n;i++)for(int j=1;j<=i;j++)mp[i][j]=(f[i-j]*m+f[i-j+1])%mod*inv%mod;//列方程
    for(int i=1;i<n;i++)mp[i][i+1]=f[0]*inv%mod;//i+1
    for(int i=1;i<n;i++)(mp[i][i]+=mod-1)%=mod;//1~i
    for(int i=1;i<=n;i++){mp[i][n+1]=mod-1;}//常数项
    for(int i=1;i<=n;i++){mp[n][i]=f[n-i];}(mp[n][n]+=mod-1)%=mod;
    for(int i=1;i<=n;i++)//高斯消元
    {
        ll inv=po(mp[i][i],mod-2);mp[i][i]=1;(mp[i][n+1]*=inv)%=mod;
        if(i!=n){(mp[i][i+1]*=inv)%=mod;}//两行两行的向下消
        for(int j=i+1;j<=n;j++)
        {
            ll mult=mp[j][i];mp[j][i]=0;(mp[j][i+1]+=mod-mult*mp[i][i+1]%mod)%=mod;
            (mp[j][n+1]+=mod-mult*mp[i][n+1]%mod)%=mod;
        }
    }
    for(int i=n;i>1;i--){(mp[i-1][n+1]+=mod-mp[i-1][i]*mp[i][n+1]%mod)%=mod;mp[i-1][i]=0;}//倒着消上去
    printf("%lld\n",mp[p][n+1]);
}
inline void clear()//清空
{
    for(int i=1;i<=min((ll)(n+1),k);i++){f[i]=0;}
    for(int i=1;i<=n;i++)for(int j=1;j<=n+1;j++)mp[i][j]=0;
}
int main(){scanf("%d",&T);for(int i=1;i<=T;i++){solve();clear();}return 0;}//拜拜程序~

```


---

## 作者：Genius_Star (赞：21)

**这篇题解相当于其他题解会详细很多，讲的很细。**

### 题面翻译：

**以下内容来自 [@oisdoaiu](https://www.luogu.com.cn/user/56825)，感觉是说这题最好的题意了。**

你有 $p$ 滴血，满血 $n$ 滴，进行很多个回合：

- 先是 $\frac 1{m+1}$ 的概率增加 $1$ 血，已经满血则概率为 $0$。

- 然后是 $k$ 次判定，每次判定 $\frac 1{m+1}$ 的概率减少 $1$ 血，已经死了则概率为 $0$。

问期望几个回合没血（第 $ans$ 个回合没完就死了算第 $ans$ 个回合）



#### 思路：


- 因为每轮扣血跟当前血量是无关的，所以我们考虑求一下 $f_i$，表示扣 $i$ 滴血的概率。

- 其实挺简单的，因为只有不扣血和扣血这两种可能，只有进行 $i$ 次扣血操作，和 $i-k$ 次不扣血操作，两种和为 $(\frac{1}{m+1})^i \times (\frac{m}{m+1})^{k-i}$（每次不扣血的概率为 $\frac{m}{m+1}$）。

- 然后这 $i$ 次扣血操作可以在 $k$ 次操作中任意排，其方案数为 $C_k^i$，则得到：

$$f_i=(\frac{1}{m+1})^i \times (\frac{m}{m+1})^{k-i} \times C_k^i$$

- 这个东西可以先预处理阶乘 $O(k)$，然后 $O(n \log k)$ 的时间复杂度可以将 $f$ 求出来。

- 然后看一下能不能优化一下，由 $f_{i-1}$ 转移过来，将式子拆一下：

$$\frac{f_i}{f_{i-1}}=\frac{(\frac{1}{m+1})^i \times (\frac{m}{m+1})^{k-i} \times C_k^i}{(\frac{1}{m+1})^{i-1} \times (\frac{m}{m+1})^{k-i+1} \times C_k^{i-1}}$$

$$=\frac{(\frac{1}{m+1}) \times C_k^i}{(\frac{m}{m+1}) \times C_k^{i-1}}$$

$$=\frac{(\frac{1}{m+1}) \times (\frac{k!}{(k-i)! \times i!})}{(\frac{m}{m+1}) \times (\frac{k!}{(k-i+1)! \times (i-1)!})}$$

$$=\frac{(\frac{1}{m+1}) \times (k-i+1)}{(\frac{m}{m+1}) \times i}$$

$$=\frac{k-i+1}{i} \times \frac{1}{m}$$

- 得到：

$$f_i=f_{i-1} \times \frac{k-i+1}{i} \times \frac{1}{m}$$

- 初始为：

$$f_0=(\frac{1}{m+1})^0 \times (\frac{m}{m+1})^{k} \times C_k^0$$

$$=(\frac{m}{m+1})^{k}$$


- 然后看看怎么求期望回合数，很明显，设 $dp_i$ 为 $i$ 滴血时血量到达 $0$ 的期望回合数。

- 转移的话，每轮可以减的血量在 $(i-k) \sim 0$ 之间，即我们枚举一个可能到达的血量 $j$，那么有两种可能：

   1. 加 $1$ 滴血，减去 $i-j+1$ 滴血，概率为 $\frac{1}{m+1} \times f_{i-j+1}$。
   
   2. 不加血，减去 $i-j$ 滴血，概率为 $\frac{m}{m+1} \times f_{i-j}$。

- 那么得到状态转移方程：

$$dp_i=(\frac{1}{m+1} \times \sum\limits_{j=0}^{i+1} dp_{j} \times  f_{i-j+1}+\frac{m}{m+1} \times \sum\limits_{j=0}^i dp_j \times f_{i-j})+1$$

- 因为如果血量为 $n$ 了，那么不能进行 $+1$ 血量操作了，那么状态转移方程为：

$$dp_n=(\sum\limits_{j=0}^n \times dp_j \times f_{n-j})+1$$

- 因为这个需要用到后面的 $i+1$ 转移过来，所以不能直接转移，进行移项考虑 **高斯消元法**：

$$dp_i-(\frac{1}{m+1} \times \sum\limits_{j=0}^{i+1} dp_{j} \times  f_{i-j+1}+\frac{m}{m+1} \times \sum\limits_{j=0}^i dp_j \times f_{i-j})=1$$

$$dp_n-(\sum\limits_{j=0}^n \times dp_j \times f_{n-j})=1$$

- 然后可以 $O(n^3)$ 做这个题，可以得到 50pts。（可能是我的代码比较丑，只得了 40pts）

- 提几个点：

- 当 $k=0$ 时，显然血量只能增加，输出 $-1$。

- 当 $m=0$ 时，显然每次加血和减血操作都是直接对自己生效的。

- 在这种情况下，如果 $k=1$，就是先 $+1$ 滴血，然后再 $-1$ 滴血，这样就无限循环了，输出 $-1$；否则的话，可以直接暴力计算回合数。

- [$O(n^3)$ 算法代码。](https://www.luogu.com.cn/paste/9o1ypcy8)

- 然后看一下能不能优化一下，

- 发现得到的增广矩阵（转化为 $0/1$ 矩阵，有值为 $1$，否则为 $0$）：

$$[1,1,1,\cdots,0,0,\cdots,0,0]$$

$$\cdots$$

$$[0,0,0,\cdots,0,0,\cdots,1,1]$$

- 即所有的 $1$ 都是在一起的，且对于第 $i$ 行的矩阵，只有第 $i+1$ 的值为 $1$，所以如果从最后一行的最后一列开始消，只有上一行的值当前列中有值，所以高斯消元的时候可以从最底下开始消元，每次只需要将上一行的值消成 $0$ 就可以了。

- 时间复杂度：$O(T \times N^2)$。

**注意一下我的错误：不要每次测试数据结束后用 ``memset`` 清空，这样会导致你写的是正解也会只有 50pts，会超时，只需要对于当前修改的值重新清空一下即可。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=1505,mod=1e9+7;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll T,n,p,m,k;
ll f[N],x[N];
ll a[N][N];
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1ll)
		  ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1ll;
	}
	return ans;
}
void GAUSS(){
	for(int i=1;i<=n;i++){
        if(!a[i][i]){
        	swap(a[i],a[i-1]);
            continue;
        }
		ll t=qpow(a[i][i],mod-2);
		for(int j=i;j<=(n+1);j++)
		  a[i][j]=(a[i][j]*t)%mod;
		ll j=i+1;
		if(!a[j][i])
		  continue;
		t=a[j][i];
		for(int k=i;k<=(n+1);k++){
			if(!a[j][k])
			  continue;
			a[j][k]=(a[j][k]-((t*a[i][k])%mod)+mod)%mod;
		}
	}
	x[n]=a[n][n+1];
	for(int i=(n-1);i>=1;i--){
		ll sum=a[i][n+1];
		for(int j=n;j>=(i+1);j--)
		  sum=(sum-((a[i][j]*x[j])%mod)+mod)%mod;
		x[i]=sum;
	}
}
void solve(){
	n=read(),p=read(),m=read(),k=read();
	if(!k){
		puts("-1");
		return ;
	}
	if(!m){
		if(k==1){
			puts("-1");
			return ;
		}
		else{
			ll ans=0;
			for(;p>0;){
				if(p<n)
				  p++;
				p-=k;
				ans++;
			}
			write(ans);
			putchar('\n');
		}
		return ;
	}
	ll t=qpow(m+1,mod-2),g=qpow(m,mod-2);
	f[0]=qpow((m*t)%mod,k);
	for(int i=1;i<=min(n,k);i++)
	  f[i]=(f[i-1]*(((((k-i+1)*qpow(i,mod-2))%mod)*g)%mod))%mod;
	for(int i=1;i<n;i++){
		for(int j=1;j<=i;j++) 
		  a[i][j]=(((((f[i-j]*m)%mod)+f[i-j+1])%mod)*t)%mod;
		a[i][i+1]=(f[0]*t)%mod;
		a[i][i]=(a[i][i]-1+mod)%mod;
	}
	for(int i=1;i<=n;i++){
		a[i][n+1]=mod-1;
		a[n][i]=f[n-i];
	}
	a[n][n]=(a[n][n]-1+mod)%mod;
	reverse(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	  reverse(a[i]+1,a[i]+n+1);
	GAUSS();
	write(x[n-p+1]);
	putchar('\n');
    for(int i=1;i<=min(n,k);i++)
	  f[i]=0;
    for(int i=1;i<=n;i++)
	  for(int j=1;j<=n+1;j++)
	    a[i][j]=0;
}
int main(){
	T=read();
	while(T--)
	  solve();
	return 0;
}
```


---

## 作者：bztMinamoto (赞：12)

## 题面

[传送门(loj)](https://loj.ac/problem/2513)

[传送门(洛谷)](https://www.luogu.org/problemnew/show/P4457)

## 题解

模拟赛的时候只想出了高斯消元然后死活不知道怎么继续……结果正解居然就是高斯消元卡常？

首先有个比较难受的地方是它一个回合可能不止扣一滴血……我们得算出$P_i$表示一回合扣$i$滴血的概率，为

$$P_i={{k\choose i}m^{k-i}\over (m+1)^k}$$

所以这个柿子啥意思？

我们可以把$k$次扣血看成一个长度为$k$的序列，每个序列有$m+1$种选择方法，于是总的选法就是$(m+1)^k$。我们要钦定它扣$i$滴血，就是令其中$i$个数强制选择$1$，方案数为${k\choose i}$。剩下的数都不能选$1$，所以方案数为$m^{k-i}$

有了这个$P_i$我们就可以考虑找关系了

然而这里还有一个很讨厌的地方就是它时不时会被奶一口……

我们记$f_i$表示当血量为$i$时被干掉的期望回合数，$g_i$表示一回合内打出伤害大于等于$i$的概率，然后考虑这东西该怎么转移

$$f_i={m\over m+1}\left(g_i+\sum_{k=0}^{i-1}P_k(f_{i-k}+1)\right)+{1\over m+1}\left(g_{i+1}+\sum_{k=0}^{i}P_k(f_{i+1-k}+1)\right)$$

边界条件为

$$f_n=g_n+\sum_{k=0}^{n-1}P_k(f_{n-k}+1)$$

所以这柿子是啥？

${m\over m+1}$表示没有被奶到的概率，那么我们枚举它被$A$了几下。如果它一回合被干掉了，那么期望局数为$1$，否则$A$了$k$下之后血量会到$i-k$，这一部分的期望步数就是$f_{i-k}+1$。后面那个就是如果被奶了之后的情况。顺便因为满血的时候是不可能被奶的，所以$f_n$要特殊考虑

然而这柿子一点都不好看，特别是$g_i$很不爽，那就继续推倒

$$f_i={m\over m+1}\left(g_i+\sum_{k=0}^{i-1}P_k+\sum_{k=0}^{i-1}P_kf_{i-k}\right)+{1\over m+1}\left(g_{i+1}+\sum_{k=0}^{i}P_k+\sum_{k=0}^{i}P_kf_{i+1-k}\right)$$

$$f_i={m\over m+1}\left(1+\sum_{k=0}^{i-1}P_kf_{i-k}\right)+{1\over m+1}\left(1+\sum_{k=0}^{i}P_kf_{i+1-k}\right)$$

同理有$f_n=1+\sum_{k=0}^{n-1}P_kf_{n-k}$

那么我们就可以愉快地递推……等会儿这咋推啊……转移好像都成环了啊……

那么我们就把它看成一个方程组来高斯消元求解吧

哈？$n=1500$你让我高斯消元？

我们来好好观察一下这个方程组，$f_i$所对应的方程只与$f_1,...f_{i+1}$的值有关，也就是说每一行的对角线右边只有在它右边一位的那个系数不为$0$

因为我们高斯消元的时候是拿自己这行去减下面的，所以每一行中只有$2$个系数要去和下面的相减，复杂度就能化到$O(n^2)$了

~~虽然我还是不知道这个复杂度是怎么过去的~~

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int K=-1,Z=0;
inline void Ot(){fwrite(sr,1,K+1,stdout),K=-1;}
void print(R int x){
    if(K>1<<20)Ot();if(x<0)sr[++K]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++K]=z[Z],--Z);sr[++K]='\n';
}
const int N=1505,P=1e9+7;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
	R int res=1;
	for(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);
	return res;
}
int a[N][N],ans[N],s[N],inv[N],g[N];
int n,m,p,k,T,qwq,aa,bb,tmp,res;
void init(int n){
	inv[0]=inv[1]=1;
	fp(i,2,n)inv[i]=mul(P-P/i,inv[P%i]);
}
void Gauss(int n){
	fp(i,1,n-1){
		int t=ksm(a[i][i],P-2);
		a[i][i]=1,a[i][n]=mul(a[i][n],t);
		if(i!=n-1)a[i][i+1]=mul(a[i][i+1],t);
		fp(j,i+1,n-1){
			t=a[j][i],a[j][i]=0;
			a[j][i+1]=dec(a[j][i+1],mul(t,a[i][i+1])),
			a[j][n]=dec(a[j][n],mul(t,a[i][n]));
		}
	}
    ans[n-1]=a[n-1][n];
    fd(i,n-2,1)ans[i]=dec(a[i][n],mul(a[i][i+1],ans[i+1]));
}
int main(){
//	freopen("testdata.in","r",stdin);
	T=read();
	init(N-5);
	while(T--){
		n=read(),p=read(),m=read(),k=read();
		if(!k||(!m&&k==1)){puts("-1");continue;}
		if(!m){
			while(p>0){if(p<n)++p;p-=k,++res;}
			printf("%d\n",res),res=0;continue;
		}
		qwq=ksm(m+1,k),qwq=ksm(qwq,P-2)%P,tmp=1;
		fp(i,0,n)s[i]=0;
		fp(i,0,min(n,k)){
			s[i]=1ll*tmp*ksm(m,k-i)%P*qwq%P;
			tmp=1ll*tmp*inv[i+1]%P*(k-i)%P;
		}
		memset(a,0,sizeof(a));
		bb=ksm(m+1,P-2),aa=mul(m,bb);
		fp(i,1,n-1){
			++a[i][i],++a[i][n+1];
			fp(j,0,i-1)a[i][i-j]=dec(a[i][i-j],mul(s[j],aa));
			fp(j,0,i)a[i][i+1-j]=dec(a[i][i+1-j],mul(s[j],bb));
		}
		++a[n][n],++a[n][n+1];
		fp(j,0,n-1)a[n][n-j]=dec(a[n][n-j],s[j]);
		Gauss(n+1);
		printf("%d\n",ans[p]);
	}
	return 0;
}
```

---

## 作者：oisdoaiu (赞：9)

# 5568 -- 【BJOI2018】治疗之雨
*一道思路很像的题【SHOI2017】分手是祝愿*
## 题面翻译

你有$p$滴血，满血$n$滴，进行很多个回合：

- 先是$\frac 1{m+1}$的概率增加$1$血，已经满血则概率为$0$
- 然后是$k$次判定，每次判定$\frac 1{m+1}$的概率减少$1$血，已经死了则概率为$0$

问期望几个回合没血（第$ans$个回合没完就死了算第$ans$个回合）

## 初步推导

考虑期望$dp$，设$f[x]$表示$x$滴血，期望几回合没血

状态转移很显然，先枚举有没有加血，再枚举剩几滴血

$f[x]=\frac 1{m+1}\sum_{i=0}^{x+1}f_ip_{x+1-i}+\frac m{m+1}\sum_{i=0}^xf_ip_{x-i}+1$（$p_i$表示扣$i$滴血的概率）

$f[0]=0$（边界）

这里有个细节，由于只有$k$次判定，所以可能扣不了那么多血，所以把$i>k$的$p_i$都设成0就好了



推导$p_i$，相当于是$k$次判定中，有$i$次中了，$k-i$次没中，再乘上$\binom ki$

得到$p_i=\frac {m^{k-i}}{(m+1)^k}\cdot\binom ki$

这道题虽然判定次数多达$1e9$，但是扣血上限只有$n$，1500级别

所以只预处理前$n$个即可，用递推式预处理$p_i=p_{i-1}\cdot\frac{k-i+1}i\cdot\frac 1m$



>这里有个问题，思考一下。
当你只有$x$滴血的时候，$p_x$还是那么多吗？
注意到如果你中途没有血了，那么后面判定是必定不中的（题面写的），所以这个时候$p_x$就不是那个表达式了。
但是这并没有关系，为什么？
$x$滴血扣$x$滴，就是0了，而$f_0=0$，就是说你不管它系数多少都没影响，乘出来都是0



然后方程的系数就预处理好了，得到了$O(n^3)$的高斯消元做法

## 玄学推式子

~~做不出来题没事儿干展开了一下前几个表达式~~

$f_1=\frac 1{m+1}(f_2p_0+f_1p_1+f_0p_2)+\frac m{m+1}(f_1p_0+f_0p_1)+1$

注意到$f_0$贡献为$0$，后面就都不考虑它

发现这个式子可以化简成$f_1=k_1f_2+b_1$的形式



再看$f_2$，发现$f_2$只和$f_1,f_2,f_3$有关，这个时候把$f_1$代换成$k_1f_2+b_1$

于是$f_2$就只和$f_3$有关了，也可以表示成$f_2=k_2f_3+b_2$

然后带回得到$f_1=k_1f_2+b_1=(k_1k_2)f_3+(k_1b_2+b_1)$

于是在推$f_4$的时候，又可以把$f_1,f_2$都代换成$f_3$的式子，那么$f_3$就只和$f_4$有关了



然后就得到了一个算法：

- 对于$f_n$，把$f_1,f_2\cdots f_{n-1}$都分别代换成$k_if_n+b_i$

- 求出$f_n=k_nf_{n+1}+b_n$
- 将$f_n$代回，求出$f_i=k'_if_{n+1}+b'_i$

进行到$f_n$的时候，由于题面，这时必定不会加血，那么有

$f_n=\sum_{i=0}^nf_ip_{n-i}+1$，这个时候把后面的$f_i$全部代换，就很容易地求出$f_n$了

于是$f_p=k_pf_n+b_p$即可

复杂度$O(n^2)$



## 喜提50

### **特判特判特判**

重要的事说三遍

- $k=0$直接$-1$

- $m=0$

  这个时候加血和减血都是必中

  - $k=1$，则每回合血量+1-1，一直下去（直接$-1$）
  - $k>1$，每回合必扣$1-k$，简单算一算输出答案

---

## 作者：justin_cao (赞：9)

贡献一个不用高斯消元来做（但实际上差不多只不过解决问题的方向不一样）的题解吧。

首先$k$次中有$i$次正好对自己造成了伤害的概率是$\frac{C_k^im^{k-i}}{(m+1)^k}$。

那么依靠这个我们就可以非常简单的预处理一个$p[i][j]$表示当前血量为$i$，经过了一轮之后血量变成了$j$的概率。

然后就考虑设$f[i]$为血量为$i$时扣血扣成$0$的期望步数。

那么转移就非常显然：
$$
f[0]=0
$$
$$
f[1]=p[1][0]\times f[0]+p[1][1]\times f[1]+p[1][2]\times f[2]+1
$$
$$
f[2]=p[2][0]\times f[0]+p[2][1]\times f[1]+p[2][2]\times f[2]+p[2][3]\times f[3]+1
$$
				   ........
$$
f[i]=1+\sum_{j=0}^{i+1}p[i][j]\times f[j]
$$
那么显然这个可以高斯消元，但是复杂度为$O(n^3)$，爆炸。

考虑看看这个转移式有什么性质。

可以发现，第$i$个方程的变量是$1$到$i+1$（第$n$个除外），那么可以考虑在第$i$个等式将$f[i+1]$表示成$a\times f[1]+b$这样的形式（$i\in [1,n-1]$），然后再将它们代入第$n$个等式中解出$f[1]$，然后再代入求出$f[p]$即可。

这样的复杂度是$O(n^2)$的，总复杂度就是$O(Tn^2)$。

需要特判$m=0$和$k=0$的情况。

code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<set>
#include<vector>
#include<queue>
#include<stack>
#include<bitset>
#define G 3
#define eps 1e-15
#define maxn 1505
#define maxm 100010
#define inf 999999999999999
#define mod 1000000007
#define mp(x,y) make_pair(x,y)
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef pair<int,int> pii;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}
    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int T;
int n,px,m,K,INV,INVX;
int C[maxn],p[maxn][maxn],ci[maxn],cix[maxn];
int quick_pow(int x,int p)
{
    int an=1,po=x;
    while(p)
    {
        if(p&1)  an=1ll*an*po%mod;
        po=1ll*po*po%mod;
        p>>=1;
    }
    return an;
}
int calc(int i)
{
    if(i<0||i>K)  return 0;
    return 1ll*C[i]*ci[i]%mod*INVX%mod;
}
struct P{
    int k,b;
}a[maxn];
P operator * (P a,int b)
{
    return (P){1ll*a.k*b%mod,1ll*a.b*b%mod};
}
P operator + (P a,P b)
{
    return (P){(a.k+b.k)%mod,(a.b+b.b)%mod};
}
P operator - (P a,int b)
{
    return (P){a.k,(a.b-b+mod)%mod};
}
P operator - (P a,P b)
{
    return (P){(a.k-b.k+mod)%mod,(a.b-b.b+mod)%mod};
}
int main()
{
    T=read();
    while(T--)
    {
        n=read();px=read();m=read();K=read();INV=quick_pow(m+1,mod-2);INVX=quick_pow(INV,K);
        if(!K)
        {
            puts("-1");
            continue;
        }
        if(!m)
        {
            if(K==1)  puts("-1");
            else{
                int cnt=0;
                while(px>0)  ++cnt,px=min(n,px+1)-K;
                printf("%d\n",cnt);
            }
            continue;
        }
        for(int i=0;i<=min(n,K);i++)  ci[i]=quick_pow(m,K-i)%mod;
        C[0]=1;for(int i=1;i<=min(n,K);i++)  C[i]=1ll*C[i-1]*(K-i+1)%mod*quick_pow(i,mod-2)%mod;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                p[i][j]=(1ll*calc(i-j)*INV%mod*m%mod+1ll*calc(i-j+1)*INV%mod)%mod;
                if(i==n)  p[i][j]=calc(i-j);
            }
        }
        a[1]=(P){1,0};
        for(int i=1;i<=n-1;i++)
        {
            a[i+1]=(P){0,0};
            for(int j=1;j<=i;j++)  a[i+1]=a[i+1]+a[j]*p[i][j];
            a[i+1]=(a[i]-a[i+1]-1)*quick_pow(p[i][i+1],mod-2);
        }
        P sum=(P){0,0};
        for(int i=1;i<=n;i++)  sum=sum+a[i]*p[n][i];
        sum=a[n]-sum-1;
        int st=1ll*(mod-sum.b)*quick_pow(sum.k,mod-2)%mod;
        int ans=(1ll*st*a[px].k%mod+a[px].b)%mod;
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：dtcxzyw (赞：5)

易知这是道高斯消元题。

设E[k]为**血量为k**，**生命值降为0**的期望步数，E[0]=0，答案为E[p]，若方程无解即为-1。

考虑转移方程：

首先设置一个大概范围以遍历，血量i可由血量max(1,i-1)~min(i+k,n)转移而来（计算E[i]时要反过来）。

设此轮血量为i，上一轮的血量为j，单轮受到x点伤害的概率为f[x] (递推公式在后面)，根据是否达到血量上限分类讨论。

若j==n，则E[i]对E[j]有f[j-i]的贡献（因为英雄已达血量上限）；

否则考虑是否为英雄补血：

若不补血，则E[i]对E[j]有m/(m+1)*f[j-i]的贡献；

若补血，则E[i]对E[j]有1/(m+1)*f[j+1-i]的贡献。

我们先预处理f[x]=C(k,x)*(1/(m+1))^x*(m/(m+1))^(k-x),这里可以线性递推。

最后就是高斯消元板子了。

然而这种做法只有30分。

注意在预处理f[x]时**m==0导致未命中英雄的概率为0**的情况

实际上f[k]是非0的，然而递推过程中0^0会等于9，特判即可。

然后你就得到了70分，O(n^3)的高斯消元是硬伤。

如何优化呢？

打印矩阵（或者从构造矩阵过程中发现）注意到矩阵**右上角**基本上是0，所以我们可以将其化为下三角矩阵。

由构造矩阵过程可发现对于第i列最多只需消去第i-1行即可，时间复杂度降为O(n^2)。

时间复杂度O(Tn^2)，跑了[3468ms](https://www.luogu.org/record/show?rid=6859937)。

最后附上代码（代码比较清晰，但是常数较大）
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
const int size=1515,mod=1000000007;
typedef long long Int64;
Int64 powm(Int64 x,int k){
    Int64 res=1;
    while(k){
        if(k&1)res=res*x%mod;
        k>>=1,x=x*x%mod;
    }
    return res;
}
Int64 inv(Int64 x){
    return powm(x,mod-2);
}
Int64 A[size][size],B[size],ans[size];
int solve(int n,int init){
    for(int i=n;i>=0;--i){
        int x=(i==0 || A[i][i])?i:i-1;
        if(A[x][i]==0)return -1;
        if(i==0)break;
        if(i!=x){
            for(int j=0;j<=i;++j)
                std::swap(A[i][j],A[x][j]);
            std::swap(B[i],B[x]);
        }
        else{
        	Int64 invv=inv(A[i][i]);
	        int j=i-1;
	        if(A[j][i]==0)continue;
            Int64 mul=A[j][i]*invv%mod;
            for(int k=0;k<=i;++k)
                A[j][k]=(A[j][k]-A[i][k]*mul)%mod;
            B[j]=(B[j]-B[i]*mul)%mod;
		}
    }
    for(int i=0;i<=init;++i){
    	Int64 res=B[i];
    	for(int j=0;j<i;++j)
    		res=(res-A[i][j]*ans[j])%mod;
    	ans[i]=res*inv(A[i][i])%mod;
	}
	return (ans[init]+mod)%mod;
}
Int64 LUT[size],invTable[size];
int foo(int n,int init,int m,int k){
    Int64 p=inv(m+1),ip=(1-p+mod)%mod,invip=inv(ip);
    {
    	memset(LUT,0,sizeof(LUT));
    	if(ip==0){
    		if(k<=n)LUT[k]=powm(p,k);
    	}
    	else{
	        Int64 cur=powm(ip,k),c=1;
	        int end=std::min(n,k);
	        for(int i=0;i<=end;++i){
	            LUT[i]=cur*c%mod;
	            c=c*(k-i)%mod*invTable[i+1]%mod;
	            cur=cur*p%mod*invip%mod;
	        }
    	}
    }
    memset(A,0,sizeof(A));
    for(int i=0;i<=n;++i){
        A[i][i]=-1;
        B[i]=(i==0?0:-1);
    }
    for(int i=0;i<=n;++i){
        int begin=std::max(1,i-1),end=std::min(n,i+k);
        for(int j=begin;j<=end;++j){
        	if(j==n)A[j][i]=(A[j][i]+LUT[j-i])%mod;
			else{
				if(j>=i)A[j][i]=(A[j][i]+ip*LUT[j-i])%mod;
            	if(j+1>=i)A[j][i]=(A[j][i]+p*LUT[j+1-i])%mod;
			}
        }
    }
    return solve(n,init);
}
int main(){
    invTable[0]=invTable[1]=1;
    for(int i=2;i<size;++i)
        invTable[i]=(mod-mod/i)*invTable[mod%i]%mod;
    int t;
    scanf("%d",&t);
    while(t--){
        int n,p,m,k;
        scanf("%d%d%d%d",&n,&p,&m,&k);
        printf("%d\n",foo(n,p,m,k));
    }
    return 0;
}

```

乱搞：若题目要求输出小数，dp多轮后直接输出期望也可以骗点分。


---

## 作者：ListenSnow (赞：4)

[原题链接](https://www.luogu.com.cn/problem/P4457 "原题链接")

## 题意

初始时玩家有 $p$ 滴血，满血 $n$ 滴，每个回合会进行如下操作：

* 若当前还没有满血，则以 $\frac{1}{m+1}$ 的概率增加一滴血；

* $k$ 次判定，每次以 $\frac{1}{m+1}$ 的概率扣除一滴血，当血量减少为 $0$ 时游戏结束。

求玩家能存活的期望回合数。

$1 \leq p \leq n \leq 1500$，$0 \leq m, k \leq 10^9$。

## 思路

设一个回合扣除 $i$ 滴血的概率为 $P_i(i \leq k)$，由数学选修三的知识可知，这其实是一个**伯努利试验**的模型，可以得到表达式：

$$P_i=\binom{n}{i} (\frac{1}{{m+1}})^i (\frac{m}{{m+1}})^{n-i}$$

由于：

$$\dfrac{P_i}{P_{i-1}}=\dfrac{\binom{n}{i} (\frac{1}{{m+1}})^i (\frac{m}{{m+1}})^{n-i}}{\binom{n}{i-1} (\frac{1}{{m+1}})^{i-1} (\frac{m}{{m+1}})^{n-i+1}}$$

可以得到递推式：

$$P_i=P_{i-1} \times \frac{1}{m} \times \frac{k-i+1}{i}$$

由于一个回合最多一次将满血全部扣完，所以这部分可以 $O(n)$ 预处理得到。

设 $f_i$ 为有 $i$ 滴血的期望存活回合数，当 $i\in [1,n-1]$ 时，简单分类讨论不难得到表达式：

$$f_i=\sum_{j=1}^{i}f_j (\frac{1}{m+1} P_{i+1-j}+\frac{m}{m+1}P_{i-j})+\frac{1}{m+1}P_0 f_{i+1}+1$$

其中当 $i=n$ 时，由于此时不能再加血，所以此时的表达式为：

$$f_n=\sum_{j=1}^{n} P_{n-j} f_j+1$$

这里一共有 $n$ 个方程以及 $n$ 个位置数，高斯消元可以得出答案。然而直接消元的复杂度为 $O(n^3)$，需要考虑优化。

列出方程组，当 $a_{i,j}=1$ 时表示这一项的系数不为 $0$，反之则表示这一项不存在，可以得到：

$$\begin{bmatrix}
 1&  1&  0&  0&  0& \ldots  1&\\
  1&  1&  1&  0&  0& \ldots 1&\\
  1&  1&  1&  1&  0& \ldots 1&\\
  \ldots \\
  1&  1&  1&  1&  1& \ldots 1&\\
\end{bmatrix}$$

发现这个方程的形式很特殊，每次往下消元的时候只需要带入两个值，消去这一行第一个非空的系数，最终得到的形式是这样的：

$$\begin{bmatrix}
 1&  1&  0&  0&  0& \ldots  1&\\
  0&  1&  1&  0&  0& \ldots 1&\\
  0&  0&  1&  1&  0& \ldots 1&\\
  \ldots \\
  0&  0&  0&  0&  1& \ldots 1&\\
\end{bmatrix}$$

最后一行就是 $x=A$ 的形式了，那么只需要向上回带就可以解出所有的未知数，最终的复杂度为 $O(n^2)$。

最后，还需要特判一下 $k=0$ 和 $m=0$ 的情况。

## code：
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
const int N=2023,mod=1e9+7;
int n,p,m,k;LL P[N],a[N][N];//初始p滴血，满血n滴，1/(m+1)概率加血，1/(m+1)概率扣血->k次 
int mul(int a,int b){int res=1;while(b) ((b&1)&&(res=1ll*res*a%mod,0)),a=1ll*a*a%mod,b>>=1;return res;}
void Gauss()
{
	for(int i=1;i<=n;i++)
    {
    	LL inv=mul(a[i][i],mod-2);a[i][i]=1;a[i][n+1]=a[i][n+1]*inv%mod;
    	if(i!=n) a[i][i+1]=a[i][i+1]*inv%mod;
    	for(int j=i+1;j<=n;j++)
    	{
    		LL mult=a[j][i];a[j][i]=0;a[j][i+1]=(a[j][i+1]-mult*a[i][i+1]%mod+mod)%mod;
    		a[j][n+1]=(a[j][n+1]-mult*a[i][n+1]%mod+mod)%mod;
		}
	}
	for(int i=n;i>1;i--) a[i-1][n+1]=(a[i-1][n+1]-a[i-1][i]*a[i][n+1]%mod+mod)%mod,a[i-1][i]=0;
}
void solve()
{
	scanf("%d%d%d%d",&n,&p,&m,&k);
	if(k==0) return puts("-1"),void();
	if(m==0)
	{
		if(k==1) return puts("-1"),void();int res=0;
		while(p>0){if(p<n) p++;p-=k;res++;} return printf("%d\n",res),void();
	}
	for(int i=1;i<N;i++) P[i]=0;
	LL invm=mul(m,mod-2),invm1=mul(m+1,mod-2);P[0]=mul(1ll*m*mul(m+1,mod-2)%mod,k);
	for(int i=1;i<=min(n+1,k);i++) P[i]=P[i-1]*invm%mod*mul(i,mod-2)%mod*(k-i+1)%mod;
	for(int i=1;i<=n;i++) for(int j=1;j<=n+1;j++) a[i][j]=0;
	for(int i=1;i<n;i++) for(int j=1;j<=i;j++) a[i][j]=(P[i-j]*m+P[i-j+1])%mod*invm1%mod;
	for(int i=1;i<n;i++) a[i][i+1]=P[0]*invm1%mod;
	for(int i=1;i<n;i++) a[i][i]=(a[i][i]-1+mod)%mod;
	for(int i=1;i<=n;i++) a[i][n+1]=mod-1;
	for(int i=1;i<=n;i++) a[n][i]=P[n-i];a[n][n]=(a[n][n]-1+mod)%mod;
	Gauss();printf("%lld\n",(a[p][n+1]%mod+mod)%mod);
}
int main()
{
//	freopen("in.txt","r",stdin);
	int T;scanf("%d",&T);while(T--) solve();
	return 0;
} 
```

---

## 作者：shixinyi (赞：3)

我不是很会矩阵做这道题(不会卡常)。

但是我们可以用本质差不多的方法，但是不用矩阵，可能常数会小一点？反正目前开O2不开O2都是最快的……

用$dp[i]$表示还剩$i$点血的时候，期望还要有多少轮操作。

和楼上题解一样，用$f[x]$表示$K$次中有$i$次打到英雄的概率。

$f[x]=C(K,x)(\frac{1}{m+1})^x(\frac{m}{m+1})^{(k-x)}$

**首先对于$m=0$的情况特判。**

对于$m!=0$情况，我们发现有

$dp[0]=0$

$dp[1]=a_{1,2}dp[2]+a_{1,1}dp[1]+1$

...

$dp[i]=a_{i,i+1}dp[i+1]+a_{i,i}dp[i]+...+a_{i,1}dp[1]+1$

...

$dp[n]=a_{n,n}dp[n]+a_{n,n-1}dp[n-1]+...+a_{n,1}dp[1]+1$

其中$a_{i,j}$表示英雄$i$点血在一轮操作后变成$j$点血的概率，这个可以根据$f$算出来，不再赘述。

所以说我们可以得到$n$个等式，第$i$个式子是$dp[i]$等于多少多少

$n$个未知数，$n$个等式(方程)，很优秀的样子。

但是我们发现，第$i$个等式右边有$dp[i+1]$，所以不能直接递推，感觉很恼火。

我们把第$i$个式子右边的$dp[i+1]$放到等式左边来，然后把$dp[i]$放到等式右边，那么这个式子就变成了$dp[i+1]$等于多少多少。

注意第$n$个式子例外，因为和$dp[n+1]$无关，仍是$dp[n]$等于多少多少。

所以这样我们可以用第$i$个式子算$dp[i+1]$？

但是我们算不出$dp[1]$呀，也没法直接往后递推。

那我们先设$dp[1]=X$，那么我们可以根据第$1$~$n-1$个式子，把$dp[i]$表示成$AX+B$的形式，递推算出$dp[n]=A_1X+B_1$，然后根据第$n$个式子算出$dp[n]=A_2X+B_2$。

那么$A_1X+B_1=A_2X+B_2$，解一元一次方程直接算出$X$。

**注意特判解不出$X$的情况输出-1。**

代码中有简单的注释。

```cpp
//Serene
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;
#define ll long long
#define db double
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
const int maxn=3000+7;
const ll mod=1e9+7;
ll Td,n,P,m,K,X;

char cc; ll ff;
template<typename T>void read(T& aa) {
    aa=0;cc=getchar();ff=1;
    while((cc<'0'||cc>'9')&&cc!='-') cc=getchar();
    if(cc=='-') ff=-1,cc=getchar();
    while(cc>='0'&&cc<='9') aa=aa*10+cc-'0',cc=getchar();
    aa*=ff;
}

ll qp(ll x,ll k) {
    if(x<=1) return x;
    ll rs=1;
    while(k) {
        if(k&1) rs=rs*x%mod;
        k>>=1; x=x*x%mod;
    }
    return rs;
}

ll mo(ll x) {if(x>=mod) x-=mod; return x;}

struct T{
    ll x,y;
    T(ll x=0.,ll y=0.):x(x),y(y){}
    inline T operator + (const T& b) const{return T(mo(x+b.x),mo(y+b.y));}
    inline T operator - (const T& b) const{return T(mo(x-b.x+mod),mo(y-b.y+mod));}
    inline T operator * (const T&b) const{return T((x*b.y+y*b.x)%mod,y*b.y%mod);}
}dp[maxn],f[maxn],o,r,t,inv,finv;

ll work() {
    if(K==0) return -1;
    if(K==1&&n!=1) return -1;
    dp[0]=T(0,0);
    ll x; T p;
    For(i,1,n-1) {
        dp[i]=T(0,1)+dp[max(i+1-K,(ll)0)];
    }
    dp[n]=T(0,1)+dp[max(n-K,(ll)0)];
    return dp[P].y;
}	

ll solve() {
    if(P==0) return 0;
    if(n==1&&K==0) return -1;
    ll x; T p;
    o=T(0,m+1); r=T(0,m); inv=T(0,qp(qp(m+1,K),mod-2));
    f[0]=T(0,1); x=min(K,n);
    For(i,1,x) f[i]=f[i-1]*T(0,(K-i+1)*qp(i,mod-2)%mod);
    For(i,0,x) f[i]=f[i]*inv*T(0,qp(m,K-i)); 
    if(m==0) return work();
    finv=T(0,qp(f[0].y,mod-2));
    if(f[0].y==1||f[0].y==0) return -1;
    //f[i]: probability of get i of K , finv : inv of f[0]
    dp[0]=T(0,0);
    dp[1]=T(1,0);
    //dp[i+1]=((m+1)(dp[i]-1)-m*sum(f[j]*dp[i-j])-sum(f[j]*dp[i-j+1]))/f[0]
    For(i,1,n-1) {
        dp[i+1]=o*dp[i]-o;
        x=min((ll)i,K);
        p=T(0,0);
        For(j,0,x) p=p+f[j]*dp[i-j];
        dp[i+1]=dp[i+1]-p*r;
        x=min((ll)i+1,K);
        For(j,1,x) dp[i+1]=dp[i+1]-f[j]*dp[i-j+1];
        dp[i+1]=dp[i+1]*finv;
    }
    //(1-f[0])*dp[n]=sum(f[j]*dp[n-j])+1;
    t=T(0,1); x=min(n,K);
    For(j,1,x) t=t+f[j]*dp[n-j];
    t=t*T(0,qp(mo(mod+1-f[0].y),mod-2));
    t=t-dp[n];
    if(t.x==0&&dp[P].x!=0) return -1;
    if(t.x) X=(mod-1)*t.y%mod*qp(t.x,mod-2)%mod;
    return (X*dp[P].x%mod+dp[P].y)%mod;
}

int main() {
    read(Td);
    while(Td--) {
        read(n); read(P); read(m); read(K);
        printf("%lld\n",solve());
    }
//	cerr<<clock()<<"\n";
    return 0;
}

```

---

## 作者：山田リョウ (赞：2)

经典随机游走。

不难发现期望步数只和第一个人的血量有关，于是设 $f_x$ 表示第一个人血量是 $x$ 时的期望步数。

则 $f_0=0$，$f_x(1\leq x\leq n)=1+\sum\limits_{i=1}^{n}P_{x,i}f_i$，其中 $P_{i,j}$ 表示第一个人血量是 $i$，经过一轮操作后血量是 $j$ 的概率。

不难发现我们不需要关心 $P_{i,0}$，因为 $f_0=0$。

而当 $j>i+1$ 或 $j<i-k$ 时 $P_{i,j}$ 也是 $0$。

然后分类讨论一下剩下的情况：

### $1\leq i<n$

$$P_{i,j}=[i+1-j\leq k]\binom{k}{i+1-j}\frac{m^{k+j-i-1}}{(m+1)^{k+1}}+[i-j\leq k \cap j\leq i]\binom{k}{i-j}\frac{m^{k+j-i+1}}{(m+1)^{k+1}}$$

### $i=n$

$$P_{i,j}=[i-j\leq k]\binom{k}{i-j}\frac{m^{k+j-i}}{(m+1)^k}$$

于是直接消元就行了，可是发现 $n$ 上限是 $1500$ 所以跑不了 $O(n^3)$ 的高斯消元。

写一下第 $i$ 个方程（$1\leq i\leq n$)：
$$\begin{aligned}\sum\limits_{i=1}^n(P_{i,j}-[i=j])f_i=-1\end{aligned}$$

不妨设第 $i$ 个方程中 $f_j$ 的系数是 $a_{i,j}$

我们注意到只有当 $j\leq i+1$ 时，$a_{i,j}$ 才非零，也就是说，系数矩阵主对角线右上方只有紧挨着的斜着一条是非零的。

于是我们用第 $n$ 行消去第 $n-1$ 行的第 $n$ 列，再用第 $n-1$ 行消去第 $n-2$ 行的第 $n-1$ 列……

以此类推，我们能得到一个下三角矩阵，然后直接从上到下代入消元即可，时间复杂度 $O(Tn^2)$，可过。

```cpp
// Problem: P4457 [BJOI2018]治疗之雨
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4457
// Memory Limit: 500 MB
// Time Limit: 4000 ms

//One-eye Dingzhen identified as:
//zxx is God.
//zxx bless me.
#include<stdio.h>
int a[1501][1502],inv[1501],x[1502];
const int p=1000000007;
int sum(int a,int b){return (p-a)>b?a+b:b-(p-a);}
int dif(int a,int b){return a<b?p-(b-a):a-b;}
int pro(int a,int b){return (long long)a*b%p;}
int pow(int a,int b){
	int res=1;
	for(;b;b>>=1,a=pro(a,a))if(b&1)res=pro(res,a);
	return res;
}
void work(){
	int n,P,m,k;
	scanf("%d%d%d%d",&n,&P,&m,&k);
	if(!k)return (void)puts("-1");
	if(!m){
		if(k<2)return (void)puts("-1");
		for(int i=1;;++i){
			if(P<n)++P;
			P-=k;
			if(P<=0)return (void)printf("%d\n",i);
		}
	}
	int invt=pow(m+1,p-2-k),invm=pow(m,p-2),mk=pow(m,k);
	inv[1]=1;for(int i=2;i<=n;++i)inv[i]=pro(dif(p,p/i),inv[p%i]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n+1;++j)
			a[i][j]=0;
	for(int i=1;i<=n;++i){
		if(i<n){
			int c=mk;
			for(int j=0;j<=k&&j<i;++j){
				a[i][i-j]=pro(m,c);
				c=pro(c,pro(invm,pro(k-j,inv[j+1])));
			}
			c=mk;
			for(int j=0;j<=k&&j<=i;++j){
				a[i][i+1-j]=sum(a[i][i+1-j],c);
				c=pro(c,pro(invm,pro(k-j,inv[j+1])));
			}
			for(int j=1;j<=n;++j)a[i][j]=pro(a[i][j],invt);
		}else{
			int c=mk;
			for(int j=0;j<=k&&j<i;++j){
				a[i][i-j]=c;
				c=pro(c,pro(invm,pro(k-j,inv[j+1])));
			}
			for(int j=1;j<=n;++j)a[i][j]=pro(a[i][j],pro(m+1,invt));
		}
		a[i][i]=dif(a[i][i],1),a[i][n+1]=dif(a[i][n+1],1);
	}
	for(int i=n;i>1;--i){
		int u=a[i][i],v=a[i-1][i];
		if(!v)continue;
		for(int j=1;j<=n+1;++j)a[i-1][j]=dif(pro(a[i-1][j],u),pro(a[i][j],v));
	}
	x[1]=pro(pow(a[1][1],p-2),a[1][n+1]);
	for(int i=2;i<=n;++i){
		x[i]=a[i][n+1];
		for(int j=1;j<i;++j)
			x[i]=dif(x[i],pro(a[i][j],x[j]));
		x[i]=pro(x[i],pow(a[i][i],p-2));
	}
	printf("%d\n",x[P]);
}
int main(){
	int t;
	for(scanf("%d",&t);t--;work());
	return 0;
}
//The moon shines. Thank the moon.
```

---

## 作者：Taduro (赞：2)

对于这种概率题，一个套路是直接设答案推式子。

设$f[i]$表示英雄有i滴血时期望的生存回合，设$p[i]$为掉i滴血的概率，可以看出$p[i]$是和当前血量无关的。
$$
f[i]=1+\sum_{j=1}^{i}f[i-j]\times p[j]\times\frac{m}{m+1}+f[i-j+1]\times p[j+1]\times\frac{1}{m+1}
$$
意思是在不被加血的情况下掉j滴血和加血的情况下掉j+1滴血。

同时，f[i]还可以得到f[i+1]，即在i<n的情况下加了一滴血并不受伤：
$$
f[i]+=f[i+1]\times\frac{p[0]}{m+1}(i<n)
$$
我们来看p：
$$
p[i]=C_{k}^{i}\times(\frac{1}{m+1})^i\times(\frac{m}{m+1})^{k-i}
$$
把组合数展开：
$$
p[i]=\frac{k!}{i!\times (k-i)!}\times(\frac{1}{m+1})^i\times(\frac{m}{m+1})^{k-i}
$$
这个东西可以在预处理$\frac{1}{i!}$后n^2算，但有o(n)的做法：
$$
p[i]=\frac{k!}{(i-1)!\times(k-i-1)!}\times(\frac{1}{m+1})^{i-1}\times(\frac{m}{m+1})^{k-i+1}\times\frac{m\times(m+1)}{m+1}\times\frac{k-i+1}{i}
$$

$$
p[i]=p[i-1]\times\frac{1}{m}\times\frac{k-i+1}{i}
$$
初始化$p[0]=(\frac{m}{m+1})^k$

这样我们就可以根据前面f[i]的方程列出一个高斯消元的矩阵，得到一个$O(n^3)$的做法，获得70分的好成绩。

这个矩阵由于前面f[i]只能从不比他大的和f[i+1]转移到所以是这样：

| $a[1][1]$ | $a[1][2]$ | 0         | 0         | -1   |
| --------- | --------- | --------- | --------- | ---- |
| $a[2][1]$ | $a[2][2]$ | $a[2][3]$ | 0         | -1   |
| $a[3][1]$ | $a[3][2]$ | $a[3][3]$ | $a[3][4]$ | -1   |
| $a[4][1]$ | $a[4][2]$ | $a[4][3]$ | $a[4][4]$ | -1   |

除了最后一行以外，其他行对角线右边只有一个元素，这样我们在对第i行消元的时候可以只消掉第i列，最后一列只会剩下一项，由此可以解出前面所有的答案。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#define re register
#define ll long long
#define mod 1000000007
#ifdef ONLINE_JUDGE
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}
template<class T>inline void read(T&x){
    static char c;static int y;
    for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;
    for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');
    x*=y;
}
#else
void read(ll&x){scanf("%lld",&x);}
#endif
using namespace std;
ll dft[1501],a[1501][1501],rec[1501];
ll p[1501],n,u,m,k,t;
inline ll ksm(ll a,ll b){
	ll res=1;
	while (b){
		if (b&1) res=(res*a)%mod;
		a=a*a%mod; b>>=1;
	}
	return res;
}
inline ll C(ll a,ll b){
	ll res=1;
	for (re int i=0; i<a; i++) res=(res*(b-i))%mod;
	return res*dft[a]%mod;
}
inline void gauss(){
	for (re int i=1; i<n; i++){
		// re int bj=i;
		// for (re int j=i+1; j<=n; j++)
		// 	if (a[j][i]){bj=j; break;}
		// for (re int j=i; j<=n+1; j++) swap(a[i][j],a[bj][j]);
		ll inv=ksm(a[i][i],mod-2); a[i][n+1]=(a[i][n+1]*inv)%mod;
		a[i][i+1]=(a[i][i+1]*inv)%mod; a[i][i]=1;
		for (re int j=i+1; j<=n; j++){
			a[j][n+1]=(a[j][n+1]+mod-a[i][n+1]*a[j][i]%mod)%mod;
			a[j][i+1]=(a[j][i+1]+mod-a[i][i+1]*a[j][i]%mod)%mod;
			a[j][i]=0;
		}
		// for (re int j=i; j<=n+1; j++) a[i][j]=a[i][j]*inv%mod;
		// for (re int j=1; j<=n; j++){
		// 	if (j==i) continue;
		// 	ll r=a[j][i];
		// 	for (re int k=i; k<=n+1; k++) a[j][k]=(a[j][k]+mod-a[i][k]*r%mod)%mod;
		// 	a[j][i]=0;
		// }
	}
	// for (re int i=1; i<=n; i++){
	// 	for (re int j=1; j<=n+1; j++) printf("%lld ",a[i][j]);
	// 	puts("");
	// }
	ll inv=ksm(a[n][n],mod-2); a[n][n+1]=(a[n][n+1]*inv)%mod; a[n][n]=1;
	for (re int i=n-1; i>=u; i--){
		a[i][n+1]=(a[i][n+1]+mod-a[i+1][n+1]*a[i][i+1]%mod)%mod;
		// a[i][i+1]=a[i][n+1]*ksm(a[i][i],mod-2)%mod;
		a[i][i]=1;
	}
}
int main(){
	read(t);
	dft[0]=dft[1]=rec[1]=1;
	for (re int i=2; i<=1500; i++) rec[i]=(mod-mod/i)*rec[mod%i]%mod;
	// for (re int i=2; i<=1500; i++) dft[i]=dft[i-1]*rec[i]%mod;
	while (t--){
		read(n),read(u),read(m),read(k);
		if (!k){puts("-1"); continue;}
		if (!m&&(k==1)){puts("-1"); continue;}
		if (!m){
			re int ans=0;
			while (u>0){
				if (u<n) u++;
				u-=k; ans++;
			}
			printf("%d\n",ans); continue;
		}
		ll ny=ksm(m+1,mod-2),nym=ksm(m,mod-2);
		memset(p,0,sizeof(p));
		memset(a,0,sizeof(a));
		p[0]=ksm(m*ny%mod,k);
		for (re int i=1; i<=min(n,k); i++)
			p[i]=p[i-1]*nym%mod*rec[i]%mod*(k-i+1+mod)%mod;
//		for (re int i=0; i<=n; i++)
//			p[i]=(C(i,k)*ksm(ny,i)%mod)*ksm(m*ny%mod,k-i)%mod;
		for (re int i=1; i<=n-1; i++){
			for (re int j=0; j<=i-1; j++)
				a[i][i-j]=(p[j]*m%mod+p[j+1])%mod*ny%mod;
			a[i][i+1]=p[0]*ny%mod;
		}
		for (re int i=1; i<=n; i++) a[n][i]=p[n-i];
		for (re int i=1; i<=n; i++) a[i][i]=(a[i][i]-1+mod)%mod;
		for (re int i=1; i<=n; i++) a[i][n+1]=mod-1;
		gauss();
		printf("%lld\n",a[u][n+1]);
	}
	return 0;
}
```

---

## 作者：Semorius (赞：1)

题意描述比较迷惑，剩下 $m$ 个数是无穷的意思是任意操作对它们不产生影响，操作影响的，或者说影响选哪个数进行操作的，只有第一个数，所以当前的状态可以用第一个数的值来表示。

设 $dp_i$ 表示第一个数为 $i$ 时把它变为 $0$ 的期望步数，可得：

$$
\begin{aligned}
&dp_0 = 0\\
&dp_i = \frac{1}{m+1} \times (\sum_{j=0}^{min(i+1, k)}[\binom{k}{j} \times (\frac{1}{m+1})^j \times (\frac{m}{m+1})^{k-j} \times dp_{i+1-j}]) \\ &+ \frac{m}{m+1} \times (\sum_{j=0}^{min(i, k)}[\binom{k}{j} \times (\frac{1}{m+1})^j \times (\frac{m}{m+1})^{k-j} \times dp_{i-j}]) + 1\\
&dp_n = \sum_{j=0}^{min(n, k)}[\binom{k}{j} \times (\frac{1}{m+1})^j \times (\frac{m}{m+1})^{k-j} \times dp_{n-j}]+1\\
\end{aligned}
$$

若 $dp_p$ 无解则减不到 $0$，否则 $dp_p$ 即为答案。

对于 $dp_0$，显然不需要任何操作。

对于 $dp_n$ 的转移，枚举第一个数一共减了 $j$ 次以及具体在哪几次操作中减了第一个数，对于每一个减了 $j$ 次的方案，有 $(\frac{1}{m+1})^j \times (\frac{m}{m+1})^{k-j}$ 的概率出现，又因一共有 $\binom{k}{j}$ 种方案，所以把 $n$ 减为 $n-j$ 的概率为 $\binom{k}{j} \times (\frac{1}{m+1})^j \times (\frac{m}{m+1})^{k-j}$。

对于 $dp_i$ 的转移，类似于 $dp_n$。第一个数 $i$ 有 $\frac{1}{m+1}$ 的概率变为 $i+1$，有 $\frac{m}{m+1}$ 的概率不变，分类以后两种状态的转移与 $dp_n$ 的转移相同。

需注意，由于第一个数减为 $0$ 后不能再减小，设当前第一个数为 $i$，那么最多进行 $min(i, k)$ 次减 $1$ 操作。

$\text{dp}$ 状态和转移设计好了，接下来思考怎么转移。发现转移有后效性，再看一眼数据范围，$1 \leq p \leq n \leq 1500$，似乎可以用高斯消元？

但正常高斯消元复杂度是 $O(n^3)$ 的，$O(T \cdot n^3)$ 过不了。/kk

但观察转移方程或打印一下增广矩阵发现矩阵都是形如这样的：

$
\begin{bmatrix}
 k_{1,1} & k_{1,2} & ... & 0 & 0 & k_{1,n+1}\\
 k_{2,1} & k_{2,2} & k_{2,3} & ... & 0 & k_{2,n+1}\\
 ... & ... & ... & ... & ... & ...\\
 0 & k_{n-1,n-1-min(n-1,k)} & k_{n-1,n-min(n-1,k)} & ... & k_{n-1,n} & k_{n-1,n+1}\\
 0 & 0 & k_{n,n-min(n,k)} & ... & k_{n,n} & k_{n,n+1}
\end{bmatrix}
$

看得出矩阵的左下和右上会存在一堆 $0$。当 $k \ge n-1$ 时，共有右上角 $\frac{(n-1)(n-2)}{2}$ 个 $0$。从上往下消元，当前行最多只有 $2$ 个数，于是高斯消元的复杂度可以降到 $O(n^2)$。

具体实现时，由于 $k$ 很大，但是是固定的，可以递推预处理出所有的概率系数。

设：

$$f(x)=\binom{k}{x} \times (\frac{1}{m+1})^x \times (\frac{m}{m+1})^{k-x}$$

展开得：

$$f(x) = \frac{k!}{x!(k-x)!} \times \frac{m^{k-x}}{(m+1)^k}$$

$f(x)$ 递推式为：

$$f(x) = \frac{(k-x+1) \times f(x-1)}{m x}$$

起始项：
$$f(0) = (\frac{m}{m+1})^k$$

还有一些小细节，$k=0$ 但 $p \ne 0$ 时无解，$m=0$ 时直接计算，高斯消元第二层函数里不能有求逆元操作，否则复杂度多一个 $\text{log}$。

整体复杂度 $O(T \cdot n^2)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll SIZE = 1505;
const ll mod = 1000000007;
ll a[SIZE][SIZE];
ll f[SIZE];
ll n, st, m, K;
ll T;

ll power(ll x, ll y){
	ll jl = 1;
	while(y){
		if(y & 1) jl = (jl * x) % mod;
		x = (x * x) % mod;
		y >>= 1;
	}
	return jl;
}

int main(){
	scanf("%lld", &T);
	while(T--){
		scanf("%lld%lld%lld%lld", &n, &st, &m, &K);
		//特判 
		if(K == 0){
			printf("-1\n");
			continue;
		}
		if(m == 0){
			if(K <= 1) printf("-1\n");
			else{
				ll cnt = 0;
				while(st > 0){
					if(st < n) st++;
					st -= K;
					cnt++;
				}
				printf("%lld\n", cnt);
			}
			continue;
		}
		//构造增广矩阵 
		ll t = power(m+1, mod-2), tt = ((1-t)%mod+mod)%mod;
		for(ll i = 1; i <= n; i++){
			for(ll j = 1; j <= n+1; j++){
				a[i][j] = 0;
			}
			f[i] = 0;
		}
		ll xx;
		f[0] = power((m * t) % mod, K);
		for(ll i = 1; i <= n; i++){
			f[i] = ((((K-i+1+mod)%mod) * f[i-1])%mod * power((m*i)%mod, mod-2)) % mod;
		}
		for(ll i = 1; i < n; i++){
			a[i][i] = (-1+mod)%mod;
			for(ll j = 0; j <= min(i+1, K); j++){
				xx = (f[j] * t) % mod;
				a[i][i+1-j] = (a[i][i+1-j] + xx) % mod;
			}
			for(ll j = 0; j <= min(i, K); j++){
				xx = (f[j] * tt) % mod;
				a[i][i-j] = (a[i][i-j] + xx) % mod;
			}
			a[i][n+1] = (-1+mod)%mod;
		}
		a[n][n] = mod-1;
		for(ll j = 0; j <= min(n, K); j++){
			a[n][n-j] = (a[n][n-j] + f[j]) % mod;
		}
		a[n][n+1] = mod-1;
		//高斯消元 
		for(ll i = 1; i <= n; i++){
			ll uu = power(a[i][i], mod-2);
			for(ll j = i+1; j <= n; j++){
				xx = (a[j][i] * uu) % mod;
				for(ll k = i; k <= n; k++){
					if(a[i][k] == 0) break;
					a[j][k] = (a[j][k] - ((xx * a[i][k]) % mod) + mod) % mod;
				}
				a[j][n+1] = (a[j][n+1] - ((xx * a[i][n+1]) % mod) + mod) % mod;
			}
		}
		for(ll i = n-1; i >= 1; i--){
			xx = (a[i][i+1] * power(a[i+1][i+1], mod-2)) % mod;
			a[i][i+1] = 0;
			a[i][n+1] = (a[i][n+1] - ((xx*a[i+1][n+1])%mod) + mod) % mod;	
		}
		//判无解 
		bool ff = 1;
		for(int i = 1; i <= n; i++){
			if(a[i][i] == 0 && a[i][n+1] != 0){
				ff = 0;
				break;
			}
		}
		if(!ff) printf("-1\n");
		else{
			ll ans = (a[st][n+1] * power(a[st][st], mod-2)) % mod;
			printf("%lld\n", ans);	
		}
	}
	return 0;
}
```


---


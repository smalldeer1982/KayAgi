# 「MCOI-03」数据

## 题目背景

Rin 正在给 MCOI Round 998244353 的题目出数据。

但是她太菜了，把数据生成器写出锅了，于是数据只生成了一半然后生成器就 RE 了。

现在她想请你用这一半的数据恢复出完整的数据。

## 题目描述

以下是一些常见的定义，如果你很熟悉它们你也可以不看。

01 串是指仅包含 ```0``` 和 ```1``` 两种字符的字符串，仅包含其中一种也是可以的。

一个字符串取出其连续的一段称为子串。容易发现一个长度为 $2n$ 的字符串有 $n+1$ 个长度为 $n$ 的子串。

一组实数 $A$ 的平均值 $\overline{A}=\frac{\sum_{x\in A}x}{|A|}$，即所有元素的和除以元素的个数。

在此基础上，$A$ 的方差 $S^2=\frac{\sum_{x\in A}(x-\overline{A})^2}{|A|}$，即所有元素与平均值的差的平方和除以元素的个数。

一个长度为 $n$ 的 01 串 $S$ 的二进制值等于 $\sum_{i=1}^nS_i2^{n-i}$，其中 $S_i$ 是 $S$ 从左向右第 $i$ 个字符上的数字。

在本题中，给出如下定义：

一组数据是一个长度为 $2n$ 的 01 串。

一组数据的毒瘤度定义为，其所有长度为 $n$ 的子串的二进制值的方差。

现在，给定一组数据的前 $n$ 个字符。你需要找到使得这组数据的毒瘤度 **最小** 的后 $n$ 个字符。如果有多解，请按照这后 $n$ 个字符构成的子串的二进制值从小到大排序输出。



## 说明/提示

#### 样例一解释

在本例中 $n=2$，存在四组满足要求的数据分别是 ```1000```，```1001```，```1010```，```1011```。

```1010``` 有三个长度为 $2$ 的子串，分别为 ```10```，```01```，```10```。它们的二进制值分别为 $2,1,2$。${2,1,2}$ 的平均值为 $\frac{5}{3}$，方差为 $\frac{2}{9}$。故 ```1010``` 的毒瘤度为 $\frac{2}{9}$。

可以计算出这四组数据的毒瘤度分别为 $\frac{8}{9},\frac{2}{3},\frac{2}{9},\frac{2}{3}$。其中 ```1010``` 是唯一毒瘤度最小的，故程序输出其后 $2$ 个字符 ```10```。

#### 数据范围与提示

保证所有数据随机生成。对于 01 串的每一位，其为 ```1``` 的概率都是 $\frac{1}{2}$ 且不同位相互独立。

本题不采用捆绑测试，按点给分。测试点 $1$ 计 $1$ 分，其他测试点每个计 $3$ 分。

每个测试点 $n$ 的规模如下表：

| 测试点编号 | $1$ | $2\sim 7$ | $8\sim 13$ | $14\sim 16$ | 
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $n$ | $\le 3$ | $\le20$ | $=26$ | $=56$ | 
|**测试点编号**|$17\sim 20$ | $21\sim 24$ | $25\sim 28$ | $29\sim 34$ |
|$n$|$=200$ | $=500$ | $\le1000$ | $\le 1500$ |

提示：在 C++ 中您可以使用 $128$ 位整数```__int128```。

## 样例 #1

### 输入

```
10```

### 输出

```
10```

# 题解

## 作者：鏡音リン (赞：24)

官方题解，较月赛讲评时使用的有较大修改。

题意：给定一个长度为 $2n$ 的 01 串的前 $n$ 个字符，求添加后 $n$ 个字符使得整个 01 串所有长度为 $n$ 的子串的二进制值的方差最小。$n\le 1500$，数据随机。

对正解没什么帮助的部分分：

$n\le 3$：手玩发现输出和输入一模一样，所以当个复读机就能得到 $1$ 分了！

$n\le 20$：枚举后 $n$ 个字符计算方差，时间复杂度 $O(n2^n)$，期望得分 $19$ 分。

正解思路：首先推一下方差的式子可以得到一个变形
$$|A|^2S^2=|A|\sum_{x\in A}x^2-(\sum_{x\in A}x)^2$$

那么我们要做的就是最小化右边这个式子。考虑拆贡献，先假设后面的位都是 $0$，那么每一位变成 $1$ 都会对方差构成一个贡献，有两位都是 $1$ 会产生一个联合贡献。

在下面这个表格中，每一列的 $a_i$ 表示左起第 $i+1$ 个长度为 $n$ 子串的二进制值，“总和”表示这 $n+1$ 个数的和。“初始值”那一行代表了后面的位全都是 $0$ 的时候对应数的值，其中 $X$ 表示是输入的 01 串的二进制值，$X_m$ 表示输入的 01 串去掉前 $m$ 位再左移 $m$ 位的二进制值，$S$ 就是这 $n+1$ 个初始值的和。每一行的“第k位”表示左起第 $n+k$ 个字符变成 $1$ 后，对应每一列的增加量。所以，每一列最终的值等于这一列“初始值”那一行的值，加上后面所有为 $1$ 的字符位对应行的值。

| $a_0$ | $a_1$ | $a_2$ | $\dots a_m\dots$ | $a_{n-1}$ | $a_n$ | 总和 | |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $X$ | $X_1$ | $X_2$ | $X_m$ | $X_{n-1}$ | $0$ | $S$ | 初始值 |
|  | $2^0$ | $2^1$ | $2^{m-1}$ | $2^{n-2}$ | $2^{n-1}$ | $2^n-1$ | 第 $1$ 位 |
|  |  | $2^0$ | $2^{m-2}$ | $2^{n-3}$ | $2^{n-2}$ | $2^{n-1}-1$ | 第 $2$ 位 |
|  |  |  | $2^{m-k}$ | $2^{n-1-k}$ | $2^{n-k}$ | $2^{n+1-k}-1$ | ...第 $k$ 位... |
|  |  |  |  | $2^0$ | $2^1$ | $2^2-1$ | 第 $n-1$ 位 |
|  |  |  |  | | $2^0$ | $2^1-1$ | 第 $n$ 位 |

可以看出这个表格是一个斜三角的形式，对角线是 $1$，每向右上角一斜行就翻倍。于是，我们的方差变形式的右侧就等于前 $n+1$ 列的最终值的平方的和，乘以 $n+1$，再减去“总和”一列最终值的平方。把所有平方都打开，整理出只和某一位有关的项和某两位的乘积项，就能整理出每一位变成 $1$ 的单独贡献，和某两位同时变成 $1$ 的联合贡献：（下面省去长长的推式子环节，因为不是题解重点）

第 $k$ 位的单独贡献：
$$(n+1)\sum_{i=k}^n(2\times 2^{i-k}\times (X_m)+2^{2(i-k)})-2\times (2^{n+1-k}-1)\times S-(2^{n+1-k}-1)^2$$

第 $n+1-i,n+1-j,i<j$ 位的联合贡献（注意不是第 $i,j$ 位）：
$$2[\frac{n+1}{3}(2^{i+j}-2^{j-i})-2^{i+j}+2^i+2^j-1]$$

转化成图论模型就是一张图有点权和边权，找一个诱导子图的点权边权和最小。如果点权和边权都任意输入则这个问题是 NPC 的，不能直接做。但是转换成这样可以改成搜索算法，裸的搜索不剪枝计算方法得当也可以达到 $O(2^n)$ 的复杂度，期望得分 $37$。

发现联合贡献全是非负数，可以利用这个性质剪枝。具体方法是，设某一位的单独贡献加上它和之前选过所有位的联合贡献为其当前贡献，如果当前贡献为正，这一位的总贡献一定为正，那么一定不选。如果当前贡献加上它和后面所有位的联合贡献仍然为负，这一位的总贡献一定为负，一定要选。加上剪枝后的搜索很快，开```__int128```就能跑 $n=56$，期望得分 $46$。随便写个高精就能跑更大的范围，但是如果要通过本题，需要一些实现细节上的优化：所有使用高精乘法的地方都可以用二进制位移取代，于是使用二进制压位高精，不需要用高精乘高精。利用二进制状压记录选过的位，那么计算所有联合贡献的和也可以常数次运算得到，不需要枚举每一位。用到的所有操作都是线性复杂度的操作，可以做到搜索单次转移复杂度为 $O(\frac{n}{w})$，也就是常数次高精计算的复杂度。最终要实现的高精大概是：无符号，支持加减法，二进制位移，乘```int```，比大小。

关于复杂度分析：其实我并不会计算这个算法的具体复杂度……实际测试中，dfs 次数大约是 $\frac{n^2}{5}$，dfs 分叉次数大约是 $\frac{n}{4}$。如果按照这个数据，算法的实际复杂度接近 $O(\frac{n^3}{w})$。如果哪位同学证出了严格复杂度，还有非随机数据下的复杂度上界，欢迎来讨论。

---


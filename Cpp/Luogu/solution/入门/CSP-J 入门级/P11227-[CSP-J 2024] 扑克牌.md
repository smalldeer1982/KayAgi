# [CSP-J 2024] 扑克牌

## 题目描述

小 P 从同学小 Q 那儿借来一副 $n$ 张牌的扑克牌。

本题中我们不考虑大小王，此时每张牌具有两个属性：花色和点数。花色共有 $4$ 种：方片、草花、红桃和黑桃。点数共有 $13$ 种，从小到大分别为 $\tt{A 2 3 4 5 6 7 8 9 T J Q K}$。注意：点数 $10$ 在本题中记为 $\tt T$。

我们称一副扑克牌是**完整**的，当且仅当对于每一种花色和每一种点数，都**恰好**有一张牌具有对应的花色和点数。由此，一副完整的扑克牌恰好有 $4 \times 13 = 52$ 张牌。以下图片展示了一副完整的扑克牌里所有的 52 张牌。

![](https://cdn.luogu.com.cn/upload/image_hosting/qj53w3yq.png)

小 P 借来的牌可能不是完整的，为此小 P 准备再向同学小 S 借若干张牌。可以认为小 S 每种牌都有无限张，因此小 P 可以任意选择借来的牌。小 P 想知道他至少得向小 S 借多少张牌，才能让从小 S 和小 Q 借来的牌中，可以选出 $52$ 张牌构成一副完整的扑克牌。

为了方便你的输入，我们使用字符 $\tt D$ 代表方片，字符 $\tt C$ 代表草花，字符 $\tt H$ 代表红桃，字符 $\tt S$ 代表黑桃，这样每张牌可以通过一个长度为 $2$ 的字符串表示，其中第一个字符表示这张牌的花色，第二个字符表示这张牌的点数，例如 $\tt{CA}$ 表示草花 $\tt A$，$\tt{ST}$ 表示黑桃 $\tt T$（黑桃 10）。

## 说明/提示

**【样例 1 解释】**

这一副牌中包含一张黑桃 $\tt A$，小 P 还需要借除了黑桃 $\tt A$ 以外的 51 张牌以构成一副完整的扑克牌。

**【样例 2 解释】**

这一副牌中包含两张方片 $\tt Q$、一张方片 $\tt T$（方片 10）以及一张红桃 3，小 P 还需要借除了红桃 3、方片 $\tt T$ 和方片 $\tt Q$ 以外的 $49$ 张牌。

**【样例 3 解释】**

见选手目录下的 poker/poker3.in 与 poker/poker3.ans。

这一副扑克牌是完整的，故不需要再借任何牌。

该样例满足所有牌按照点数从小到大依次输入，点数相同时按照方片、草花、红桃、黑桃的顺序依次输入。

**【数据范围】**

对于所有测试数据，保证：$1 \leq n \leq 52$，输入的 $n$ 个字符串每个都代表一张合法的扑克牌，即字符串长度为 $2$，且第一个字符为 $\tt{D C H S}$ 中的某个字符，第二个字符为 $\tt{A 2 3 4 5 6 7 8 9 T J Q K}$ 中的某个字符。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $1$ | A |
| $2\sim 4$ | $52$ | ^ |
| $5\sim 7$ | ^ | B |
| $8\sim 10$ | ^ | 无 |

特殊性质 A：保证输入的 $n$ 张牌两两不同。

特殊性质 B：保证所有牌按照点数从小到大依次输入，点数相同时按照方片、草花、红桃、黑桃的顺序依次输入。

## 样例 #1

### 输入

```
1
SA```

### 输出

```
51```

## 样例 #2

### 输入

```
4
DQ
H3
DQ
DT```

### 输出

```
49```

# 题解

## 作者：chen_zhe (赞：126)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题要求出在给定的扑克牌的基础上，还需要多少张牌可以让扑克牌凑成一整套，而试题中读入的字符串每个都代表一张合法的扑克牌，从而可以使用 C++ STL 中的 set（集合）完成本题。这是因为，set 可以自动去重，去除重复的牌（字符串）后，剩下的字符串就是实际拥有的不同的牌。而一副扑克牌有 $52$ 张牌，使用 $52$ 减去该集合的大小即可求出答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	set <string> S;
	int n;cin >> n;
	for (int i=1;i<=n;i++) {
		string s;
		cin >> s;
		S.insert(s);
	}
	cout << 52-S.size() << endl;
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：26)

我们注意到输入的牌字符串肯定是合法的，那么这题就变成了一个去重问题。

两种方法：

1. `std::unique`

`std::unique` 可以对一个有序的序列去重，并且将重复的放在末尾，具体的， `unique` 会返回去重后这个序列的末指针。

那么我们将所有牌用 `sort` 排序后用一遍 `unique` 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100;
int n;
string s[N];

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>s[i];
	sort(s+1,s+n+1);
	n=unique(s+1,s+n+1)-s-1;
	cout<<52-n;
	return 0;
}
```

2. `std::map`

我们可以用内置平衡树的 `map` 来实现，不会的可以百度。

我们就可以用 `map<string,bool> mp` 来将一个字符串映射成一个 bool 型，而在代码的最后调用 `mp.size()` 即可返回有多少张本质不同的卡牌。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100;
int n;
string s[N];
map<string,bool> mp;

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		mp[s[i]]=1;
	}
	cout<<52-mp.size();
	return 0;
}
```

3. 暴力

$n\le 52$，那么我们注意到一张卡牌不同当且仅当不存在一个 $j\le i$ 满足 $s_i=s_j$。

那么我们直接暴力在数组中寻找即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100;
int n,cnt;
string s[N];
map<string,bool> mp;

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		bool fg=1;
		for(int j=1;j<i;j++){
			if(s[i]==s[j]){
				fg=0;
				break;
			}
		}
		cnt+=fg;
	}
	cout<<52-cnt;
	return 0;
}
```

---

## 作者：KukCair (赞：25)

## 基本思路

首先我没有用 STL，只用了数组。

当然 STL 肯定会更简洁，推荐学一下。

这里我使用了一个布尔型二维数组 `f[5][20]` 来存对应花色是否有此点数，用函数 `zhn` 转换扑克牌的点数。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, cnt;
bool f[5][20];
// 第一维是花色，第二维是点数
int zhn(char x){ // 按题意转换点数
    if('2' <= x && x <= '9') return x - '0';
    if(x == 'A') return 1;
    if(x == 'T') return 10;
    if(x == 'J') return 11;
    if(x == 'Q') return 12;
    if(x == 'K') return 13;
}
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        char c1, c2;
        cin >> c1 >> c2;
        if(c1 == 'D') f[1][zhn(c2)] = 1;
        else if(c1 == 'C') f[2][zhn(c2)] = 1;
        else if(c1 == 'H') f[3][zhn(c2)] = 1;
        else if(c1 == 'S') f[4][zhn(c2)] = 1;
    }
    /*遍历扑克牌*/
    for(int i = 1; i <= 4; i++){
        for(int j = 1; j <= 13; j++){
            if(!f[i][j]) cnt++; // 没有就需要补
        }
    }
    cout << cnt;
    return 0;
}
```

---

## 作者：_little_Cabbage_ (赞：15)

# [CSP-J2024]T1 扑克牌
## 题意
每张牌具有两个属性：花色和点数。花色共有 $4$ 种：方片、草花、红桃和黑桃。点数共有 $13$ 种，从小到大分别为 `A23456789TJQK`。注意：点数 $10$ 在本题中记为 T。这也就意味着，一共有 $52$ 张扑克牌。
现在你有 $n$ 张扑克牌，问你还有多少张没有拿到？
## 题解
直接桶存 $n$ 张扑克牌中不重复的个数，用 $52$ 减去即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5][14];
signed main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		int cnt1=0,cnt2=0;
		if(s[0]=='D')
		{
			cnt1=1;
		}
		if(s[0]=='C')
		{
			cnt1=2;
		}
		if(s[0]=='H')
		{
			cnt1=3;
		}
		if(s[0]=='S')
		{
			cnt1=4;
		}
		if(s[1]=='A')
		{
			cnt2=1;
		}
		if(s[1]>='2'&&s[1]<='9')
		{
			cnt2=s[1]-'0';
		}
		if(s[1]=='T')
		{
			cnt2=10;
		}
		if(s[1]=='J')
		{
			cnt2=11;
		}
		if(s[1]=='Q')
		{
			cnt2=12;
		}
		if(s[1]=='K')
		{
			cnt2=13;
		}
		a[cnt1][cnt2]=1;
	}
	int cnt=0;
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=13;j++)
		{
			cnt+=a[i][j];
		}
	}
	printf("%d",52-cnt);
}
```

---

## 作者：gongziwen (赞：10)

我们不难发现，两张牌完全相等，当且仅当两个字符完全相等，反之亦然。

所以说，我们直接字符串哈希就好，只有两个字符，值域只有 $128$，所以不用模数。

```cpp
#include<bits/stdc++.h>
const int N=128*128;
int n,x,vis[N],ans;
char str[3];
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		scanf("%s",str);
		int &x=vis[str[0]*128+str[1]];
		if(!x) ans++,x=1;
	}
	printf("%d",52-ans);
	return 0;
}
```

---

## 作者：OIer6666 (赞：7)

## 解题思路
第一种思路：

将一个字符串转化为一维数组，记录下来，最后统计并输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
int slove1(char s){//相当于一个二维数组的第一个下标
	if(s=='D')return 0;
	if(s=='C')return 13;
	if(s=='H')return 26;
	if(s=='S')return 39;
}
int slove2(char s){//相当于一个二维数组的第二个下标
	if(s=='A')return 0;
	if(s>='2'&&s<='9')return s-'0'-1;
	if(s=='T')return 9;
	if(s=='J')return 10;
	if(s=='Q')return 11;
	if(s=='K')return 12;
}
bool vis[100];
int main(){
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		vis[slove1(s[0])+slove2(s[1])]=1;//表明有这张牌
	}
	int ans=0;
	for(int i=0;i<52;i++){
		ans+=!vis[i];//计算需要多少张牌
	}
	cout<<ans;
	return 0;
}
```
第二种思路：

不需要将一个字符串转化为一维数组，使用 `map` 记录下来，最后统计并输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,bool>vis;//unordered_map也可以哦
int main(){
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		vis[s]=1;//表面有这张牌
	}
	cout<<52-vis.size();//vis.size()表示有多少种不同的牌，52-vis.size()即为需要的牌数
	return 0;
}

```

---

## 作者：maoyuqi (赞：6)

#### 题目大意
给出 $n$ 张扑克牌，每次输入牌的花色和点数，求还要多少张牌能够凑成一副完整的牌。
#### 解题思路
按照题意模拟即可，我们发现花色的字母和点数的字母是不重复的，因此我们可以建立一个映射，把每种字母映射成一个数字。

接着我们可以开一个二维数组，标记每张牌是否已经出现。最后用一个 $cnt$ 变量累加没有标记的就可以了。

#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int change(char c)
{
	if(c == 'D') return 1;
	if(c == 'C') return 2;
	if(c == 'H') return 3;
	if(c == 'S') return 4;
	if(c >= '2' && c <= '9') return (int)(c - '0');
	if(c == 'A') return 1;
	if(c == 'K') return 13;
	if(c == 'T') return 10;
	if(c == 'J') return 11;
	if(c == 'Q') return 12;
	
}

bool st[5][14];
int cnt;
int main()
{
	cin >> n;
	for(int i = 1;i <= n;i ++)
	{
		string s;
		cin >> s;
		char a = s[0],b = s[1];
		int x = change(a),y = change(b);
		st[x][y] = true;
	}
	for(int i = 1;i <= 4;i ++)
	{
		for(int j = 1;j <= 13;j ++) if(!st[i][j]) cnt ++;
	}
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：TemplateClass (赞：5)

我们不难发现，答案和具体的扑克牌的种类无关，这题唯一的问题在于我们如何处理扑克牌之间的重复。因为一旦我们得到了扑克牌去重后的结果，就可以直接用 $52$ 去减了。

于是我们引入 C++11 的 STL 容器 `std::unordered_set`，该容器可以自动去重其中的元素，相比于 `std::set`，由于其没有排序功能，所以其平均时间复杂度是 $O(1)$ 的，因此我们只需要将输入扑克牌全部插入一个 `std::unordered_set`，再获得这个 `std::unordered_set` 的 `size` 即可，其中，插入一个元素可以用 `insert()`。

时间复杂度 $O(n)$。

```cpp
int n; std::cin >> n;
std::unordered_set<std::string> s;
for(int i = 1; i <= n; ++i) {
    std::string x; std::cin >> x;
    s.insert(x);
}
std::cout << 52 - s.size();
```

---

## 作者：Alexxu2024 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P11227)

## 思路

十分简单。观察题目得，总共 $52$ 种牌，每种牌可以直接抽象成一个长度为 $2$ 的字符串，剩下的就是去重。

这里我直接用 `unordered_map<string,bool>` 做，若这张牌用字符串表示是 `s`，则 `mp[s]=1`，最后 `52-mp.size()` 即可。个人认为代码更简单。

最后，我想说，`STL` 是个好东西。

## 赛后代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define int long long
using namespace std;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	unordered_map<string,bool> mp;
	int n;
	cin >> n;
	while(n--){
		string x;
		cin >> x;
		mp[x]=1;
	}
	cout << 52-mp.size();
	return 0;
}
```

---


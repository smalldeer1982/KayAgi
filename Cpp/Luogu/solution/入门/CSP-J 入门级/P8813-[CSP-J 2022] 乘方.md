# [CSP-J 2022] 乘方

## 题目背景

为模拟赛时得分情况，本题时限降低 50%。

## 题目描述

小文同学刚刚接触了信息学竞赛，有一天她遇到了这样一个题：给定正整数 $a$ 和 $b$，求 $a^b$ 的值是多少。

$a^b$ 即 $b$ 个 $a$ 相乘的值，例如 $2^3$ 即为 $3$ 个 $2$ 相乘，结果为 $2 \times 2 \times 2 = 8$。

“简单！”小文心想，同时很快就写出了一份程序，可是测试时却出现了错误。

小文很快意识到，她的程序里的变量都是 `int` 类型的。在大多数机器上，`int` 类型能表示的最大数为 $2^{31} - 1$，因此只要计算结果超过这个数，她的程序就会出现错误。

由于小文刚刚学会编程，她担心使用 `int` 计算会出现问题。因此她希望你在 $a^b$ 的值超过 ${10}^9$ 时，输出一个 `-1` 进行警示，否则就输出正确的 $a^b$ 的值。

然而小文还是不知道怎么实现这份程序，因此她想请你帮忙。

## 说明/提示

对于 $10 \%$ 的数据，保证 $b = 1$。  
对于 $30 \%$ 的数据，保证 $b \le 2$。  
对于 $60 \%$ 的数据，保证 $b \le 30$，$a^b \le {10}^{18}$。  
对于 $100 \%$ 的数据，保证 $1 \le a, b \le {10}^9$。

$\text{upd 2022.11.14/2025.04.02}$：各新增加一组 $\text{Hack}$ 数据。

## 样例 #1

### 输入

```
10 9
```

### 输出

```
1000000000
```

## 样例 #2

### 输入

```
23333 66666
```

### 输出

```
-1
```

# 题解

## 作者：liangbob (赞：77)

2023 年 10 月 15 日更新：增加注释，修改错误的代码。感谢 [hexuchen](/user/945742) 大佬指出。


2024 年 7 月 31 日更新：没想到两年前写的题解能被这么多人看到，也非常感谢各位的支持！现在评论区中提出了一些问题，这里就这些问题统一回答，并对评论区中有价值的建议对题解进行了修改。

- Q：方法太复杂了，没必要！
  
  A：是的，我承认自己当时的考场做法确实较为复杂，相比其他人的做法来看，这个做法显得臃肿而多余。但是我还是想说：这也不失为一种方法。学习 OI，接受一种比较复杂的新思路也是重要的，万一后面这种思想可以被用于其它题目呢？

- Q：判断 $a^b$ 是否小于 $0$，小于 $0$ 代表溢出。看看它溢不溢出就行了。

  A：请注意：带符号整数溢出在 C++ 中是未定义行为，这意味着编译器可以随意地处理这种行为，比如，编译器返回 $114514$ 代表溢出也是可以的，所以这种做法有风险，虽不失为一种方法，但在考场上使用务必谨慎。

- Q：特判 $a$ 时需考虑 $b$ 是否大于1，特判 $b$ 时需考虑 $a$ 是否大于 $1$ 吗？

  A：不需要。请注意当 $a$ 或 $b$ 等于 $1$ 时，根据数据范围和 $1^x=1$ 可以肯定答案不会超过 $10^9$。

2025 年 2 月 15 日更新：再次回看自己原来的做法（下文中的方法一）发现还是太吃操作了，于是补充了一种简单而强势的方法。上述回答针对的是第一种做法。

2025 年 3 月 6 日更新：根据评论区中的意见再次加入了一种代码量极小做法，感谢 [Clovtong](/user/1386326) 大佬提出这种做法。

2025 年 4 月 27 日更新：更新了一些描述和代码，感谢 [\_\_orange\_\_](https://www.luogu.com.cn/user/1653353) 大佬指出这个细节问题。

------

## P8813 题解

### 方法一（考场做法）

#### 思路分析

这道题主要是特判。

首先我们发现，$\left\lfloor\\\sqrt{10^9}\right\rfloor = 31622$ ，$\left\lfloor\\\log_2{10^9}\right\rfloor = 29$。即 $a > 31622$ 或 $b > 29$ 时必定大于 $10^9$。但是注意这是在满足 $a, b \geq 2$ 时才有的结论。所以注意特判 $a = 1$ 和 $b = 1$，$a = 1$ 时直接输出 $1$ ，$b = 1$ 时直接输出 $a$。

但是余下的怎么办呢？显然，当 $\dfrac{10^9}{a^n} < a$ 时，说明 $a_n \cdot a = a^{n+1} > 10^9$。依此判断即可。由于此时 $b \le 29$，大于 $29$ 的情况已经被特判掉了，于是直接暴力计算就行。

#### 代码

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    //特判 
    if(a == 1)
    {
        cout << 1 << endl;
        return 0;
    }
    if(b == 1)
    {
        cout << a << endl;
        return 0;
    }
    if(a > 31622)
    {
        cout << -1 << endl;
        return 0;
    }
    if(b > 29)
    {
        cout << -1 << endl;
        return 0;
    }
    long long fac = 1;
    for(int i = 1;i <= b;i++) //i 表示准备乘上第 i 个 a 
    {
        if((1e9 / double(fac)) < a) //准备乘上的时候看看是否超出限制 
        {
            cout << -1 << endl;
            return 0;
        }
        fac *= a;
    }
    cout << fac << endl;
    return 0;
} 
```

### 方法二（更为简洁的做法）

#### 思路分析

考虑到 $a \le 10^9$。

假设 $a^{x} \le 10^9$，那么 $a^{x+1} \le 10^9 \times10^9=10^{18}$，也就是说如果一个幂第一次超过 $10^9$ 次方，那么它必然比 $10^{18}$ 次方小，即不超过 `long long` 的范围。

于是我们直接开一个 `long long` 类型的变量 $x$，模拟计算幂的过程，每次给 $x$ 乘上一个 $a$，当 $x$ 超过 $10^9$ 时，输出 $-1$，直接结束程序。否则输出 $x$ 就可以了。

我们来分析一下复杂度。当 $a \le 2$ 时，我们要进行 $\log_a 10^9$ 次循环，可以通过。当 $a=1$ 时，复杂度虽然不正确，但是我们可以特判一下，输出 $1$ 即可。

#### 代码

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    //特判 
    if(a == 1)
    {
        cout << 1 << endl;
        return 0;
    }
	long long x = 1;
	for(int i = 1;i <= b;i++) //模拟幂运算的过程
	{
		x *= a;
		if(x > 1e9)
		{
			cout << -1 << endl;
			return 0;	
		}
	} 
	cout << x << endl;
    return 0;
} 
```
### 方法三（pow 函数做法）

#### 方法概述

直接使用 pow 函数计算 $a^b$ 的值并判断。

#### 正确性证明

首先我们来看时间复杂度是否正确。参考 [这个问题的回答](https://stackoverflow.com/questions/13418180/time-complexity-of-c-math-library-pow-function)：

> That depends on the underlying architecture. On the most common desktop architecture, x86, **this is a constant time operation.**
>
> 这取决于底层的体系结构。在最常见的桌面体系结构 x86 上，**这是一个常数时间操作。**
>

即时间复杂度为 $O(1)$。由于 pow 函数涉及到浮点数运算，因此常数较大，多次进行有可能会超时。但这里我们只进行一次操作，时间复杂度是正确的。

接着我们来看正确性。双精度浮点数，即 double 类型，它的存储范围约为：$[-1.4\times 10^{308},1.4 \times 10^{308}]$。

当一个数过小时，这个数会被下溢到 $0$。但由于本题 $a,b\ge 0$，不存在这个问题。

当一个数过大（超过储存范围）时，这个数会上溢成 $\inf$，此时在代码上判断 $10^9$ 次方是否小于这个数结果一定为真，而实际上也确实小于，因此是正确的。

同时 pow 的运算会存在严重的精度缺失问题。但是由于 $a,b \le 10^9$ 次方，范围相对较小，而且我们的目的是判断是否大于 $10^9$ 次方。在这么一个小范围的前提下，这么判断并不会出错。具体的可以参考 [这篇题解](https://www.luogu.com.cn/article/c54erb28)。

于是，我们可以认为，这么做是正确的。

#### 代码

在实现代码时需要注意，当且仅当 $x=a^b$ 的数据类型为 `double` 时，与 $x$ 进行比较才会具有上述性质。如果 $x$ 为整数类型，赋值后 $x$ 可能会溢出。

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    double x = pow(a, b);
    cout << int(x > 1e9 ? -1 : x) << endl;
    return 0;
} 
```

---

## 作者：Forever1507 (赞：32)

首先分类，如果 $a=1$，怎么乘都是 $1$，输出 $1$ 即可。

反之，开 `long long` 手动乘，$a$ 至少是 $2$，那么乘到 $10^9$ 最多 $\log_2{10^9}$ 次，时间复杂度稳稳的。

一定要开 `long long`！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
	cin>>a>>b;
	long long ans=1;
	if(a==1){
		cout<<1;
		return 0;
	}
	while(b&&ans<=1e9){
		ans*=a;
		b--;
	}//直接手动乘
	if(ans>1e9){
		cout<<-1;
		return 0;
	}
	cout<<ans;
	return 0;
} 
```


---

## 作者：VitrelosTia (赞：12)

题链： [P8813 [CSP-J T1 2022] 乘方](https://www.luogu.com.cn/problem/P8813)

### 题意
给你两个整数 $a$ 和 $b$，求 $a^b$ 的值，假如大于 $10^9$ 就输出 $-1$。

### 思路
假如直接使用 `pow` 函数计算结果极有可能会出现爆上限的情况，导致结果变为负数，无法判断是否大于 $10^9$。

此时从题目中可以想到模拟乘方的计算过程：将 $a$ 累乘 $b$ 次。假如在乘的过程中结果已经大于 $10^9$，就可以直接输出 $-1$，结束程序。假如累乘完 $b$ 次后仍然没有结束程序，就可以输出计算的结果。

在 $a > 1$ 的情况下最多累乘 $31$ 次就会结束循环，没有超时风险。但是在 $a = 1$ 的情况下会执行 $b$ 次，最劣要执行 $10^9$ 次，有超时风险，并且显然在 $a=1$ 的情况下乘方一定为 $1$，所以可以加上特判，在 $a=1$ 时直接输出 $1$。这样可以保证不超时。

### code
```
#include<bits/stdc++.h>
using namespace std;
long long a,b,c=1;//c记录乘积
int main(){
    scanf("%lld%lld",&a,&b);
    if(a==1){cout<<1;return 0;}//特判a=1
    for(int i=1;i<=b;i++){
        c*=a;//累乘
        if(c>(long long)1e9){//要转成的同样类型再判断
            printf("-1");
            return 0;
        }
    }
    printf("%lld",c);
}
```


---

## 作者：mark0575 (赞：9)

### 题目思路：

题目中让我们求 $a^b$，不少同学肯定会想到[快速幂](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%B9%82/5500243?fr=aladdin)，其实这道题可以不用快速幂！

因为题目已经提醒我们 $pow$ 函数先用最朴实的方式一个一个计算下去，核心代码如下：

```cpp
	long long ans=1;
	for(int i=1;i<=b;i++)
	{
		ans*=a;
	}
	cout<<ans;
```
这时，可能会有同学问了，这样算下来，时间复杂度不是很高吗？其实，我们可以算一下，假设 $a$ 是 $2$，$b$ 是一个很大的数，当循环执行大约 $30$ 次时，结果就大于 $10^9$ 了，后面就不会算下去了。也就是说，这个方法的时间复杂度不会很大。这样，我们可以写出代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	long long ans=1;
	for(int i=1;i<=b;i++)
	{
		ans*=a;
		if(ans>1e9)
		{
			cout<<-1;
			return 0; 
		}
	}
	cout<<ans;
	return 0;
 }

```

但是我们都知道，$1$ 的多少次方都等于 $1$，有可能 $b$ 是一个很大的数，不管怎么乘，结果始终都是 $1$，退出不了循环，有可能会超时。所以，为了防止超时，我们可以特判一下 $1$。

### AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	if(a==1)
	{
		cout<<1;
		return 0;
	}
	else
	{
		long long ans=1;
		for(int i=1;i<=b;i++)
		{
			ans*=a;
			if(ans>1e9)
			{
				cout<<-1;
				return 0; 
			}
		}
		cout<<ans;
	}
	return 0;
 }

```
[考场代码](https://www.luogu.com.cn/paste/u473g0oe)

ps: 场上，本蒟蒻把判断是否超过 $10^9$ 写成了判断是否大于 $2147483647$(int 的最大值)。Q^Q

---


# [CERC2013] Bus

## 题目描述

# [CERC2013] Bus

## 题面翻译

有一个数 $n$ ，定义一次操作为使 $n\rightarrow \frac{n-1}{2}$ 。已知经过了 $k$ 次操作后 $n$ 恰好为 $0$，求 $n$。
 
多测，有 $T$ 组数据，$T$ 在输入数据开头给出。 

保证 $1\leqslant k\leqslant 30$。


A bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.

## 说明/提示

Time limit: 1000 ms, Memory limit: 1048576 kB. 

 Central Europe Regional Contest (CERC) 2013

## 样例 #1

### 输入

```
2
1
3
```

### 输出

```
1
7
```

# 题解

## 作者：Grisses (赞：10)

[题面](https://www.luogu.com.cn/problem/P7018)

本题其实就是一个逆推。我们设 $a_i$ 表示到达第 $i$ 站后还剩下的人数，由题可得，$a_k=0$。依然由题可得：

$$\frac{a_i-1}{2}=a_{i+1}$$

所以，我们可以得出：

$$a_i=a_{i+1}\times 2+1$$

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ans;
int main()
{
	cin>>t;
	while(t--){
		cin>>n;
		ans=0;//已知a[k]=0
		while(n--)ans=ans*2+1;//逆推
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：MattL (赞：5)

[链接](https://www.luogu.com.cn/problem/P7018)

~~一定要评红~~

---
**题意分析：**

>有一个公交车，初始时车上有 $n$ 个人，每停一站，车上会先下去一个人，然后再下车上剩下的人数的一半的人。已知经过了 $k$ 个站之后，车上没人了。现在，给出 $k$，求一开始车上的人数 $n$。

我们知道每个站的人数都会 $-1$ 再 $\div2$ ，所以我们如果要逆推，那就先 $\times 2$ 再 $+1$ 。

时间复杂度： $\Theta(30T)$

---
**代码部分：**

~~哈哈哈，代码来咯：~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,cnt;
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n;
        cnt=0;
        for(int i=1;i<=n;i++)
            cnt=2*cnt+1;
        cout<<cnt<<endl;
    }
    return 0;
}
```
---
**优化：**

你以为这就没了？不！我们还能做得更好：

[预处理 $\Theta(30+T)$](https://www.luogu.com.cn/paste/sfuvecao)

[记忆化 $\Theta(30+T)$](https://www.luogu.com.cn/paste/jtv17snn)

[数论+位运算 $\Theta(T)$](https://www.luogu.com.cn/paste/odj58vfh)

说明：

$$ans=\begin{matrix}\underbrace{2\times(2\times(2\times(\cdots0+1\cdots)+1)+1)+1}\\n\end{matrix}$$

$$=2^{n-1}+2^{n-2}+2^{n-3}+\cdots+1$$

$$=2^n-1$$



---

## 作者：Jerrlee✅ (赞：1)

## 题意
题目已给。
## 思路
从前往后是 $n$ 先减 $1$ 再除以 $2$，那倒过来就是先乘 $2$ 再减 $1$，具体见代码，注意最后一站只下一个人。
## 代码
```cpp
#include<iostream>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n,ans=1;
        cin>>n;
        while(n--&&n>0){
            ans*=2;
            ans++;
        }
        cout<<ans<<endl;
    }
}
```
[AC记录](https://www.luogu.com.cn/record/66206819)

---

## 作者：DF_Factory (赞：1)

简单的题目。~~然而我WA了一次。~~

递推，按照题目规则下人，推导 $f_i$。

$$
\because \dfrac{f_i-1}{2}=f_{i-1}
$$
$$
\therefore f_i=2 \cdot f_{i-1} +1
$$

那么对于每一组询问，直接输出即可。

$k$ 只有 $30$，不会爆 int。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,f[40];
int main(){
	cin >> t;
	f[1]=1;
	for(int i=2;i<=30;i++) f[i]=2*f[i-1]+1; 
	while(t--){
		cin >> n;
		cout << f[n] << endl;
	}
	return 0;
}
```


---

## 作者：3a51_ (赞：1)

这题一看就是倒推问题。

设到达第 $i$ 站时剩 $f_i$ 人。

则不难得到 $f_i=\frac{f_{i-1}-1}{2}$ ，然后我们只要根据输入的n进行递推即可。

时间复杂度 $O(tk)$ 。

# $AC$ $code$
```cpp
#include<iostream>
using namespace std;
int main()
{
	int t;//数据组数
	cin>>t;
	while(t--)//数据组数，while比for更好用
	{
		int k,ans=0;//ans记答案，k有30，不用ll
		cin>>k;
		for(int i=1;i<=k;i++)
			ans=ans*2+1;//递推
		cout<<ans<<endl;//记得换行
	}
	return 0;//结束
}

```

---

## 作者：_easy_ (赞：0)

# 思路
根据题意模拟。

由于我们不知道最开始的人数，于是便采用倒推法，拿 $k=5$ 做个例子：
1. 最后一站人会下光，所以倒数第二站只会有一个人。
2. 后面每往前一个站，最开始的人数 $n$ 就会先翻倍，再加一，于是便可以很轻松的写出代码：
```cpp
n=1;//每次询问是独立的，所以每次都要初始化
k--;//最后一站不纳入考虑
while(k--){
	n*=2;
	n++;
}
```
# 代码
核心代码已在思路中给出。

---

## 作者：Coros_Trusds (赞：0)

# 题目大意

因为你谷关键词放不上来。

# 题目分析

令 $dp[i]$ 表示剩下 $i$ 个人时，车上最开始的人数。

首先，$dp[1]=1$。

当前车上刚开始的人数，显然是由下一个阶段的人数得来的，为了方便代码，这里先预处理求出所有 $dp[i]$。

状态转移方程：$dp[i]=dp[i-1]*2+1$。

方程很好理解，就不细说了。

# 代码

```cpp
//2021/12/11

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>

#include <cstdio>

#include <climits>//need "INT_MAX","INT_MIN"

#define enter() putchar(10)

#define debug(c,que) cerr<<#c<<" = "<<c<<que

#define cek(c) puts(c)

#define blow(arr,st,ed,w) for(register int i=(st);i<=(ed);i++)cout<<arr[i]<<w;

#define speed_up() cin.tie(0),cout.tie(0)

#define endl "\n"

#define Input_Int(n,a) for(register int i=1;i<=n;i++)scanf("%d",a+i);

#define Input_Long(n,a) for(register long long i=1;i<=n;i++)scanf("%lld",a+i);

#define mst(a,k) memset(a,k,sizeof(a))

namespace Newstd
{
	inline int read()
	{
		int x=0,k=1;
		char ch=getchar();
		while(ch<'0' || ch>'9')
		{
			if(ch=='-')
			{
				k=-1;
			}
			ch=getchar();
		}
		while(ch>='0' && ch<='9')
		{
			x=(x<<1)+(x<<3)+ch-'0';
			ch=getchar();
		}
		return x*k;
	}
	inline void write(int x)
	{
		if(x<0)
		{
			putchar('-');
			x=-x;
		}
		if(x>9)
		{
			write(x/10);
		}
		putchar(x%10+'0');
	}
}

using namespace Newstd;

using namespace std;

const int ma=35;

int dp[ma];

int main(void)
{
	for(register int i=1;i<=30;i++)
	{
		dp[i]=dp[i-1]*2+1;
	}
	
	int T=read();
	
	while(T--)
	{
		int n=read();
		
		printf("%d\n",dp[n]);
	}
	
	return 0;
}
```

---

## 作者：ZZQF5677 (赞：0)

### 解题思路
本题使用倒推法。因为下一站等于本站人数减去一个再除以二，而第 $0$ 站只有 $0$ 个人，所以反过来说 $a_i$（$a_i$ 指本站） 相当于 $a_{i-1} \times 2 + 1$（$a_{-1}$ 指下一站）。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[35], t, k;
int main() {
  a[0] = {0};                      // 一开始只有 0 人。
  for (int i = 1; i <= 30; i++) {  //倒推
    a[i] = a[i - 1] * 2 + 1;       //本站相当于下一站的人数 × 2 + 1。
  }
  cin >> t;
  while (t--) {
    cin >> k;
    cout << a[k] << endl;
  }
  return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

### 数学推导
首先，看到本题，设现在车上有 $k$ 人，操作完成后有 $m$ 人。则一次操作后 $m\gets\frac{k-1}{2}$。在已知 $m$ 的情况下，解得 $k=2\times m+1$。（虽然本题仍然有 bug：下一办的人是向上还是向下取整？但本题按照这个方式逆推回去，一定是可以的。）而且这样的答案最大为 $2^{30}$，只需要 `int` 即可。此处有一个小优化：答案先预处理在一个数组中，这样时间复杂度只有 $O(T)$，可过。
### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,k,ans[31];
int main(){
	scanf("%d",&t);
	ans[1]=1;
	for(int i=2;i<=30;i++)
		ans[i]=ans[i-1]*2+1;
    while(t--){
        scanf("%d",&k);
		printf("%d\n",ans[k]);
    }
    return 0;
}
```

---

## 作者：违规用户名gAGt8$%z (赞：0)

## 这是一道简单的递推
递推，按照题目规则下人，推导 $f_{i}$ $=$ $f_{i-1} \times 2 $ $+$ $ 1$ ;  不用数组存，只要一个变量就好了
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)//t组数据
    {
        int k,ans=0;//2^30不用超long long
        cin>>k;
        for(int i=1;i<=k;i++)
            ans=ans*2+1;//递推
        cout<<ans<<endl;
    }
    return 0;
}
```


---


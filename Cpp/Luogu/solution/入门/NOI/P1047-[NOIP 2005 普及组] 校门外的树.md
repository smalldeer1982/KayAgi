# [NOIP 2005 普及组] 校门外的树

## 题目描述

某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。



## 说明/提示

**【数据范围】**

- 对于 $20\%$ 的数据，保证区域之间没有重合的部分。
- 对于 $100\%$ 的数据，保证 $1 \leq l \leq 10^4$，$1 \leq m \leq 100$，$0 \leq u \leq v \leq l$。

**【题目来源】**

NOIP 2005 普及组第二题

## 样例 #1

### 输入

```
500 3
150 300
100 200
470 471
```

### 输出

```
298```

# 题解

## 作者：Loyal_Soldier (赞：41)

### 思路
我们可以用一个 $flag$ 数组来记录每个位置的树是否被移走，如果为 $1$ 说明这个位置的树被移走，否则为没有被移走。我们可以每次输入两个数 $a,b$ ，然后将 $flag_a\sim flag_b$ 全都标记 $1$ ，最后我们遍历一遍 $0\sim l$ ，如果当前位置的树没有被移走最终答案就加一，最后输出最终答案。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int flag[114514];
int ans;//ans为最终答案
signed main(){
	int l,m;
	cin>>l>>m;
	for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		for(int j=a;j<=b;j++)//标记
			flag[j]=1;
	}
	for(int i=0;i<=l;i++)
		if(!flag[i])//判断当前位置上的树是否没有被移走
			ans++;//增加最终答案
	cout<<ans;
	return 0;
}

```

---

## 作者：WsW_ (赞：20)

### 思路
按题意模拟即可。  
不妨开一个数组 $tree_i$ 来记录位置 $i$ 的树是否已经被移走，每次移走树的时候直接 $u\sim v$ 遍历并修改这个数组即可。  
每次遍历，如果 $tree_i=0$ 说明未被移走，移走的数量 $sum\gets sum+1$。  
本来有 $l+1$ 棵树，移走了 $sum$ 棵，还剩下 $l+1-sum$ 棵。

时间复杂度为 $O(m\times l)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool tree[10002];
int main(){
	int m,l,sum=0;
	scanf("%d%d",&l,&m);
	for(int i=0;i<m;i++){
		int le,ri;
		scanf("%d%d",&le,&ri);
		for(int i=le;i<=ri;i++){
			if(tree[i]==0){
				sum++;
				tree[i]=1;
			}
		}
	}
	printf("%d",l+1-sum);
	return 0;
}
```

---

## 作者：Metaphysical (赞：17)

# 题解：P1047 [NOIP2005 普及组] 校门外的树

## 题目传送门 | Portals

[[NOIP2005 普及组] 校门外的树](https://www.luogu.com.cn/problem/P1047)

## 题意归纳 | Title

求出一个长度为 $l$ 数轴被 $m$ 个区间覆盖后还空留了多少。

## 题目分析 | Analyse

$1 \le l \le 10^4，1 \le m \le 100$，由此可见数据非常的小，所以我们可以直接用 $O(lm)$ 的时间复杂度暴力通过。~~（分析了跟分析了一样）~~

## 解题思路 | Thinking

我们用一个 bool 数组记录每一棵树的状态，为 false 表示健在，为 true 表示被覆盖。  
- 输入并遍历被覆盖的范围，标记为 true。  
- 接着遍历 $1$ 至 $l$，如果为 false 答案加一。
- 输出答案。


## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstdio>

const long long N = 1e4 + 10;
long long l, m;
bool st[N];
long long int ans;

using namespace std;

int main ()
{
	cin >> l >> m;
	while (m --)
	{
		long long x, y;
		cin >> x >> y;
		for (long long i = x; i <= y; i ++)
			st[i] = true;
	}
	for (long long i = 0; i <= l; i ++)
		if (!st[i])
			ans ++;
	cout << ans;
	return 0;
}
```

---

## 作者：蟋蟀喵～～ (赞：14)

# P1047题解

看题解区没有用差分做的，我来发一个差分的。

## 差分
差分是实现**连续区间操作**的实用算法，一次操作复杂度为 $O(1)$。
### 实现
差分是前缀和的逆运算，实现方法如下：
```
for(int i = 1; i <= n; i++){
	cin >> a[i];        //存储用的数组
   s[i] = a[i] - a[i - 1]; //s 差分数组
}
//Do something....
for(int i = 1; i <= n; i++){
	s[i] += s[i - 1];   //前缀和还原（若中间没做任何操作，则 s[i] 与 a[i] 相等）。 
}
```

#### 区间操作
将原数组进行区间的运算，相当于对差分数组的开始位置做同样的操作，而对其结束位置的后一位进行相反操作。

举例：

将数组区间 $[l,r]$ 加上 $x$:

```
cin >> l >> r >> x;
s[l] += x,s[r + 1] -= x;
```


既然这道题多次涉及区间加一（不加的就是 $0$，只需要判断是否是 $0$），我们就可以考虑差分。

## 注意：这题是从 $0$ 到 $l$ !

主要部分代码:

```cpp
//变量定义
int s[100001],m,l,start,end,ans; //s差分
//main 函数里
cin >> l >> m;
for(int i = 1; i <= m; i++){
 cin >> start >> end;
 s[start]++,s[end + 1]--;
}  
for(int i = 0; i <= l; i++){
 s[i] += s[i - 1];
 if(!s[i]){
   ans++;
 }
}
cout << ans;
```


---

## 作者：langni (赞：10)

用一个数组 $a$ 来记录树有没有被挖走过，每次输入范围时，把范围内的值全部设为另外一个值，最后再统计数量即可。  
代码:
```cpp
#include <bits/stdc++.h> //万能头
using namespace std;
int a[100011];
int main()
{
    int l, i, u, v, n;
    fill(a, a + 10011, 1); //将所有值初始化为1
    cin >> l >> n;
    for (i = 1; i <= n; i++)
    {
        cin >> u >> v;
        for (int j = u; j <= v; j++)
        {
            a[j] = 0; //标记
        }
    }
    int ans = 0;
    for (i = 0; i <= l; i++)
    {
        if (a[i])
        {
            ans++; //统计
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：qhr2023 (赞：6)

## solution

模拟题。对于每次移树，遍历给定区域并将给定区域打上标记，最后遍历整条马路，统计剩余树木数量。

[通过记录](https://hydro.ac/record/6784aea4e36c396ca83e509d)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[10001];
int l, m, sum;
int main(){
	cin >> l >> m;
	for(int u, v; m--; ){
		cin >> u >> v;
        for (int j=u; j<=v; ++j)
            f[j]=1;
	}
	for(int i=0; i<=l; i++)
        sum+=(!f[i]);
	cout << sum;
	return 0;
}
```

---

## 作者：kunkun127 (赞：6)

## 思路

读题后发现，我们只需要根据题意模拟即可。

令 $f_i$ 表示第 $i$ 棵树的状态。

- 如果 $f_i$ 为 $0$，那么就代表这棵树没有被移走。  
- 如果 $f_i$ 为 $1$，反之。

然后在输入时，从 $x$ 到 $y$ 进行循环，令之间的 $f_x$ 到 $f_y$ 都赋值为 $1$。

最后令 $cnt$ 为剩余的数木数量，进行从 $0$ 到 $l$ 的循环，如果 $f_i$ 为 $0$，那么 $cnt$ 加一。输出 $cnt$ 即可。

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;

bool f[10005];

int main()
{
	int l, m;
	cin >> l >> m;
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		for (int j = x; j <= y; j++)
		{
			f[j] = 1;
		}
	}
	int cnt = 0;
	for (int i = 0; i <= l; i++)
	{
		if (f[i] == 0)
		{
			cnt++;
		}
	}
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：Ray_yi (赞：3)

#### 思路：

通过题目，我们发现这道题的难点就在于要去重，那怎么去呢？很容易想到用一个桶来标记这个区间的树，最后在遍历每个树就好了，并计数。看一下数据大小，不会超时。

#### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int L,M,cnt,t[100000],l,r;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>L>>M;
	for(int i=1;i<=M;i++){
		cin>>l>>r;
		for(int j=l;j<=r;j++) t[j]=1;//标记每个树
	}
	for(int i=0;i<=L;i++)
		if(t[i]==0) cnt++;//遍历每个树
	cout<<cnt;
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：3)

### 思路

观察到 $l \le 10^4$，考虑使用数组存储模拟，每次把移走的树的位置的数据设置为没有树，最后统计树的个数即可。

### 实现

```cpp
# include <iostream>
# include <memory.h>
using namespace std;
int main(){
	int length,m,u,v,cnt = 0;
	cin >> length >> m;
	length++;
	bool tree[length+1];
	memset(tree,true,sizeof(tree));
	for (int i = 0;i < m;i++){
		cin >> u >> v;
		for (int j = u;j <= v;j++){
			tree[j] = false; // 移走树
		}
	}for (int i = 0;i < length;i++){
		if (tree[i] == true){
			cnt++; // 记录剩余的树的个数
		}
	}cout << cnt;
	return 0;
}
```

---

## 作者：The_Best_OIer (赞：2)

## 思路

很简单的一个题，暴力模拟即可。维护一个数组，每次输入 $u,v$ 时将 $u$ 到 $v$ 全部打上标记，最后统计没有标记的数量即可。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int l, m, u, v, cnt;
int a[10005];
int main() {
	cin >> l >> m;
    for (int i = 1; i <= m; i++) { 
		cin >> u >> v;
    	for (int j = u; j <= v; j++) {
    		if (a[j] == 0) {
    			a[j] = 1;
			}
		}
	} 
    for (int i = 0; i <= l; i++) {
    	if (a[i] == 0) {
    		cnt++;
		}
	}
    cout << cnt;
	return 0;
}
```

---

## 作者：zjinyi (赞：2)

# 题解：P1047 校门外的树
## 题目大意
数轴上表示 $0,1,2,…,l$ 的点都种有一棵树。由于马路上有一些区域要用来建地铁。现在要把这些区域中的树（包括端点处的两棵树）移走。求：将这些树都移走后，马路上还有多少棵树。

## 题目思路
创建一个布尔类型的数组，并遍历每个区域，将数组中没有移走的树的位置从 false 变为 true，并计数。最后计算，剩下树的数量就等于树的数量减去移走的树的数量。

## 代码
```cpp
#include <iostream> 
using namespace std;

bool a[10001];
int main() 
{  
	int l, m; 
	cin >> l >> m; // 输入长度，区域数
	while (m--)
	{
		int u, v;
    cin >> u >> v; // 输入区域端点
int cnt = 0;
		for (int j = u; j <= v; ++j)
		{
			if (a[j] == false) // 如果这个区域内的树还在，将数组中没有移走的树的位置从 false 变为 true，并计数
			{
				a[j] = true;
				num += 1;
			}
		}
	}
	cout << l + 1 - num; // 计算还剩多少树，剩下树的数量就等于树的数量减去移走的树的数量
	
    return 0;  
}
```

---

## 作者：Malkin_Moonlight (赞：1)

## Solution

简单模拟题，维护一个数组 $a$，初始全是 $0$ 表示都是树。$m$ 次输入，每次输入 $u,v$，此时从 $u$ 到 $v$ 循环，将 $u$ 到 $v$ 每一个节点标记为 $1$，表示这个点没有树。最后再遍历一遍 $a$ 数组，如果发现这个点为 $0$，也就是这个点还有树，那么计数器加 $1$。循环结束，输出计数器。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll l, m, u, v, sum;
ll a[10005];
inline ll read() { 
	ll x = 0, f = 1;char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-')f = -1;ch = getchar();}
	while (ch >= '0' && ch <= '9') {x = (x << 1) + (x << 3) + ch - '0';ch = getchar();}
	return x * f;
}
inline void write(ll x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar((x % 10) | 0x30);
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	l = read(); m = read();
    for (int i = 1; i <= m; i++) { 
		u = read(); v = read();
    	for (int j = u; j <= v; j++) {
    		if (a[j] == 0) {
    			a[j]++;
			}
		}
	} 
    for (int i = 0; i <= l; i++) {
    	if (a[i] == 0) {
    		sum++;
		}
	}
    write(sum);
	return 0;
}
```

---

## 作者：mishitaotuoyyds (赞：1)

# 思路：
这道题直接暴力就能通过，多余的话我也不想说。

只需要开一个数组，然后要被砍的树标记一下就可以了。

# 参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m[10010],k,l,r,ans=0;
int main()
{
   	cin>>n>>k;
   	for(int i=1;i<=k;i++){
   		cin>>l>>r;
   		for(int y=l;y<=r;y++){
   			m[y]=1;	
		}
	}
	for(int i=0;i<=n;i++){
		ans+=(m[i]==0);
	}
	cout<<ans;
    return 0;
}
```
完结撒花。

---

## 作者：ridewind2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1047)

## 思路

一道模拟题，可以用桶来标记，每次将输入的点 $x$ 和 $y$ 之间的所有数标记为 $1$，最后从 $0$ 到 $l$ 判断是不是被标记，如果没被标记，答案 $cnt$ 加 $1$。

直接输出答案即可


## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10100];
int main(){
    int l,n;
    cin>>l>>n;
    int cnt=0;
    for(int i=1;i<=n;i++){
      int x,y;
    	cin>>x>>y;
    	for(int j=x;j<=y;j++){
    		if(!a[j])a[j]=1;
		}
	}
	for(int i=0;i<=l;i++){
		if(!a[i]){
			cnt++;
		}
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：sbh2012 (赞：0)

## 思路
暴力模拟即可。维护一个数组，每次输入左边界和右边界，再将这一段区域内全部打上标记，最后统计没有标记的数量即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,m,ll,r,sum;
bool a[10005];
int main(){
	cin>>l>>m;
    for(int i=1;i<=m;i++){ 
		cin>>ll>>r;
    	for(int j=ll;j<=r;j++){
    		if(a[j]==0){
    			a[j]=1;
			}
		}
	} 
    for(int i=0;i<=l;i++){
    	if(a[i]==0){
    		sum++;
		}
	}
    cout<<sum;
	return 0;
}
```

---

## 作者：JCT_addyi (赞：0)

### 题目大意：

有一排树，每一棵树的间隔是一，可以看作一个数轴，给你长度为 $l$ 的数轴，和几组区间数量，只有区间才有树，但会重合，求这条马路一共有多少棵树。

### 思路：

遍历每一个区间，用桶标记一下，再遍历这条马路有多少棵树。

### 代码如下：

```cpp
#include<iostream>
using namespace std;
int a[10001],l,r,n,m;
int main(){
	int ans=0;
	cin>>n>>m;//n是长度m是组数
	for(int i=1;i<=m;i++){
		cin>>l>>r;//输入l,r 表示区间 
		for(int j=l;j<=r;j++){//遍历l到r这个区间的树 
			a[j]=1;//标记一下 表示这里有树 
		}
	}
	for(int i=0;i<=n;i++){
		if(a[i]==0)ans++;//有标记就ans++; 
	}
	cout<<ans;
}
```
谢谢大家！

---

## 作者：Jayfeather2012 (赞：0)

## 思路
定义一个标记数组，每次输入砍伐区间就遍历区间，将要砍的位置标记已砍伐。最后遍历每棵树，如果未被标记就增加答案。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int l,m,x,y,s,a[10005];//a为标记数组
int main(){
	cin>>l>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		for(int j=x;j<=y;j++){//遍历区间
			a[j]=1;//标记
		}
	}
	for(int i=0;i<=l;i++)if(a[i]==0)s++;//有未砍伐就增加答案
	cout<<s;//输出
  	return 0;
}
```

---

## 作者：sea_bird (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1047)。

# 题目分析

一道**模拟**题目。

## 思路

首先初始化一段种满了树的路，根据输入将移走的数的位置重新赋值，最后遍历整个数组，看有多少个位置是重新赋值过的。

## Code

```cpp
#include <iostream>
using namespace std;
int tree[10005];
int main()
{  
int l,m,s,e,cnt=0;;
cin>>l>>m;
for(int i=0;i<=l;i++)
	tree[i]=1;//种树 
	for(int i=0;i<m;i++)
	{
		cin>>s>>e;
		for(int j=s;j<=e;j++)//重新赋值
		{
			tree[j]=0;
		}
	}
	for(int i=0;i<=l;i++)//重新遍历
	{
		if(tree[i]==1)
		{
		cnt++;
	    }
		
}
cout<<cnt<<" ";

	return 0;
}
```

---


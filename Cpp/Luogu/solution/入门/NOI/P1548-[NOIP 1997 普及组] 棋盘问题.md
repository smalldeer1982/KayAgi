# [NOIP 1997 普及组] 棋盘问题

## 题目背景

NOIP1997 普及组第一题

## 题目描述

设有一个 $N \times M$ 方格的棋盘 $(1≤N≤100,1≤M≤100)$

求出该棋盘中包含有多少个正方形、多少个长方形（不包括正方形）。

例如：当 $N=2, M=3$ 时：

![](https://cdn.luogu.com.cn/upload/image_hosting/kkidop2i.png)

   
正方形的个数有 $8$ 个：即边长为 $1$ 的正方形有 $6$ 个；边长为 $2$ 的正方形有 $2$ 个。

长方形的个数有 $10$ 个：

即  

- $2 \times 1$ 的长方形有 $4$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/vhazon60.png)

- $1 \times 2$ 的长方形有 $3$ 个：  

![](https://cdn.luogu.com.cn/upload/image_hosting/jr40fqzv.png)

- $3 \times 1$ 的长方形有 $2$ 个：  

![](https://cdn.luogu.com.cn/upload/image_hosting/ja0mx48f.png)

- $3 \times 2$ 的长方形有 $1$ 个：  

![](https://cdn.luogu.com.cn/upload/image_hosting/kkidop2i.png)


## 样例 #1

### 输入

```
2 3```

### 输出

```
8 10```

# 题解

## 作者：0凌0 (赞：313)

看到各位大佬手算公式，身为蒟蒻的我早已吓呆了  
题目说的好，m,n<100，~~常言“暴力出奇迹”，~~我立刻想到了：
# 枚举  
怎么枚举呢，显然，我可以先枚举左上的点，再枚举右下的点，坐标一减，是不是正方形显而易见  
号称全国~~NO.1~~易懂的代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,z,c,i,j,k,l;    //z用来记正方形个数，c来记长方形
int main()
{
	cin>>m>>n;           //输入
	for(i=0;i<=m;i++)    //枚举
	for(j=0;j<=n;j++)    //枚举
	for(k=i+1;k<=m;k++)  //还是枚举
	for(l=j+1;l<=n;l++)  //仍然是枚举
	if(k-i==l-j)z++;     //是正方形
	else c++;            //是长方形
	cout<<z<<" "<<c;     //输出
}
```

---

## 作者：BlueArc (赞：282)

说说公式是怎么推导的吧

找规律:

正方形:

边长为1的正方形个数为n\*m

边长为2的正方形个数为(n-1)\*(m-1) （自己动手想想）

边长为3的正方形为个数(n-2)\*(m-2)

边长为min(n,m)的正方形为个数s1=(n-min(n,m)+1)\*(m-min(n,m)+1)

然后从边长为1到min（m，m）的正方形个数全部加起来；

长方形:(包括正方形，好像正方形属于长方形来着？)

长为1的长方形（包括正方形）有n个

长为2的长方形（包括正方形）有n-1个

长为n的长方形（包括正方形）有1个

长为1到n的长方形1+2+...+n个

同理
宽为1的长方形（包括正方形）有m个

宽为2的长方形（包括正方形）有m-1个

宽为m的长方形（包括正方形）有1个

宽为1-m的长方形1+2+...+m个

然后把它们乘起来，根据乘法原理，总数s2=((1+n)\*(1+m)\*n\*m)/4;

题目要求的是“非正方形的长方形”，因此要减去s1;

```cpp
#include"cstdio"
#include"iostream"
using namespace std;
int main()
{
 int n,m,s1=0,s2;
 cin>>n>>m;
 s2=((m+1)*(n+1)*m*n)/4;
 for(;m>=1&&n>=1;m--,n--)
  s1+=m*n;                       
 cout<<s1<<" "<<s2-s1;
return 0;
}

```

---

## 作者：JimmyF (赞：237)

    
看到dalao们都推出了一个一个华丽的公式，我这个蒟蒻就只能写一份比较通俗易懂、比较基础的算法了。

### 思路：

先求出正方形的个数，在求出长方形的个数+正方形的个数，再减去正方形的个数，求出长方形的个数。

### 下面是我求正方形个数的方法 ：

枚举正方形的边长，对于不同边长的正方形就有（棋盘边长-枚举变长+1）条边，然后相乘变成当前边长的正方形个数，公式是（n-边长+1）*（m-边长+1），最后累加即可。

### 接下来用奥数求长方形+正方形的个数 ：

这个方法与上面有点不同，既然是包括长方形，所以边长不定。比如对于2*3的棋盘来说，那有的长方形+正方形个数为：

       1 * 1+1 * 2+1 * 3+2 * 1+2 * 2+2 * 3
	  =1*（1+2+3)+2*(1+2+3)
      =(1+2+3)*(1+2)
      =18（个）
      
你发现了什么？对的，2 * 3的纸的长方形+正方形的个数就是（1+2） * （1+2+3），也就是（1~n的和）*（1~m的和），记住，这只是求出了长方形+正方形的个数，还要-正方形的个数才=长方形的个数

所以，长方形的个数公式是：（1~n的和）*（1~m的和）-正方形的个数。这也告诉了我们：当推导公式时，可以用实数带进去计算从而得出结论。

### 下面献上代码：    
    
    #include<iostream>
    #include<cmath>    //文件头
    using namespace std;
    int n,m,sum,N,M,SUM;  //定义，小写的是求正方形个数的 ，大写的是求正方形+长方形个数的 
    int main()
    {
        cin>>n>>m;   //读入棋盘的长和宽
        //输入
        
        for(int i=1; i<=min(n,m); i++)  //枚举边长，记住min(n,m)，因为正方形只能由小的那条边作为边长，记住，这个min函数是在cmath库里调用的
        	sum+=(n-i+1)*(m-i+1);  //套公式（n-边长+1）*（m-边长+1）
        //求正方形，知识点：1.正方形只能由小的那条边作为边长  2.对于不同边长的正方形就有（棋盘边长-枚举变长+1）条边
        
        for(int i=1; i<=n; i++) 
        	N+=i;               //求一条长的和，累加1~n
        for(int i=1; i<=m; i++)
        	M+=i;               //求一条宽的和，累加1~m
        SUM=N*M-sum;        //根据（1~n的和）*（1~m的和）-正方形的个数算出长方形个数
        //求长方形，知识点：公式的推导
        
        cout<<sum<<" "<<SUM;  //输出正方形个数和长方形个数
	    //输出
        return 0;
    }
    
#### ~~最后不要脸的求个赞[滑稽]~~


---

## 作者：一滴小水滴 (赞：218)

相信小伙伴门看到数据范围是n,m<=100想到的第一个是——
## 是的，暴力！
有些学奥数（最基础那种）的小伙伴门应该学过，求矩形数量是将每个点到另外一个点的矩形

比如说：

(2，1) 到 (4，5) （显然样例没有那么多）

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/iljne96k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这里显示出了两个点的位置（中间那突如其来的弯曲我也不知道是怎么回事，不要问我）

那么这两个点为其中两个顶点形成的矩形是：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tw1mq40.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这就是一个~~完美的~~长方形，注意：两点只能做出一个矩形

既然长方形有了，那正方形？

再做图解，(2,1)到(5,4)

![](https://cdn.luogu.com.cn/upload/image_hosting/teubjp5t.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么可见，这个正方形 大列坐标-小列坐标==大横坐标-小横坐标

那么是不是每个正方形都是如此？是的（本人不想再做图解）



---

那么已经知道了规律，再用一个四层循环暴力解决问题

AC CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,az,ac; //是的，ac
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)  //外部用两层记录小列、小横坐标。
		{
			for(int k=i+1;k<=n;k++)
				for(int l=j+1;l<=m;l++)  //内部用两层记录大列、大横坐标。
				{
					if(k-i==l-j)az++;
					else ac++;  //(祝你们ac++!)
				}     //这里之前已经推过，只要它们的差相等，就是正方形，不然就是长方形。
		}
	printf("%d %d",az,ac);
	return 0;
}

这似乎是本人第一篇带图题解，希望大家资瓷，谢谢

---

## 作者：qwaszx (赞：67)

emmmm为什么没有cpp的$O(1)$题解啊

明明很好推啊

首先容易知道如果长方形（包括正方形）的边长为$a$和$b$，那么数量为$(n-a+1)(m-b+1)$

然后对于所有的$a$和$b$做就好了

答案为$(1+2+3+...+n)(1+2+3+...+m)$

就是$\dfrac{nm(n+1)(m+1)}{4}$

正方形也很好做啊

枚举所有的$i$，数量为$(n-i+1)(m-i+1)$

就是$\sum_{i=1}^{min(n,m)}(n-i+1)(m-i+1)=\sum_{i=0}^{min(n,m)-1}(n-i)(m-i)$

因为在$i=min(n,m)$时没有影响

所以为了方便就加上$i=min(n,m)$

然后变成$\sum_{i=0}^{min(n,m)}(n-i)(m-i)$

然后拆开变成$mn+i\times i-(m+n)i$

用$l$代替$min(n,m)$就是$nm(l+1)+l(l+1)(2l+1)/6-l(l+1)(m+n)/2$

然后一顿乱搞

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m;
int main()
{
	cin>>n>>m;
	int nn=min(n,m);
	int z=m*n*(nn+1)+nn*(nn+1)*(2*nn+1)/6-(m+n)*nn*(nn+1)/2;
	int c=n*(n+1)/2*m*(m+1)/2-z;
	cout<<z<<" "<<c<<endl;
}
```

---

## 作者：GXuLuogu (赞：33)

**本题也可不用公式，裸暴力出答。**
思路：从第一行第一列开始，一个矩形一个矩形地枚举，若遇到正方形就加正方形，遇到长方形就加长方形，AC代码如下：
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	int n, m;
	cin >> n >> m;
	int jz(0), jc(0); //分别计正方形、长方形的个数 
	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= m; j++)
		//模拟，一个一个地暴力枚举 
			for (int l1 = i + 1; l1 <= n; l1++)
				for (int l2 = j + 1; l2 <= m; l2++)
				{
					int e1 = l1 - i;
					int e2 = l2 - j;
					if (e1 > 0 && e2 > 0)
					{
						if (e1 == e2) jz++;
						else jc++;
					}
				}
	cout << jz << ' ' << jc << endl;
	return 0;
}
```

---

## 作者：AdzearDisjudge (赞：24)

在长m宽n的矩形中j，能利用公式：t=(m-i+1)\*(n-j+1)求出在矩形中包含长i宽j的矩形的个数t。然后判断i和j是否相等即可。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,i,j,s,t,p;
int main()
{
    s=0;
    t=0;
    cin>>n>>m;
    for(i=1;i<=n;++i)
    for(j=1;j<=m;++j)
    {
        p=(n-i+1)*(m-j+1);
        if(i==j)
        s+=p;
        else
        t+=p;
    }
    cout<<s<<' '<<t;
    return 0;
}
//%%%The Red Sun thx!
```

---

## 作者：localhost (赞：18)

先推出正方形的个数，接着推出长方形和正方形的总数，长方形的个数就是总数减去正方形的个数。

正方形的个数就很容易了。

长方形和正方形的总数就是先推出棋盘的长有多少条线段，宽有多少条线段，在相乘就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m,ans=0;cin>>n>>m;
    for(int i=n,j=m;i>=1&&j>=1;i--,j--)ans+=i*j; 
    int l=0,r=0;
    for(int i=1;i<=n;i++)l+=i;for(int i=1;i<=m;i++)r+=i;
    cout<<ans<<' '<<l*r-ans<<endl;
}
```

---

## 作者：北北北北 (赞：13)

刚看到这题的时候，脑子第一想法就是可以用公式来直接算，然而没过一会就放弃了这种想法，因为想不出来QWQ，于是我用了暴搜来将所有可能的情况都给尝试一遍，然后输出结果就可以了，效率的话，过100*100的数据还是可以的，再大点估计就炸了QWQ。

既然说到暴搜，那么不可避免的就是该如何去判断它是正方形还是长方形，在这呢，可以把判断它是正方形还是长方形给转成去判断这两个图形的两顶点的坐标是否在合法的范围内，若在则它就是正方形或者长方形，PS:正方形是边边相等，长方形是边边不相等。

下面附实现代码:


------------
```c
#include <stdio.h>

int main(void)
{
     int i,j,k,r,c,n,m,max;
     int count1 = 0,count2=0;

     scanf("%d%d", &n,&m);
     max = ((n>m)?(n):(m));
     for(i = 0; i <= max; i++) //长宽
     {
          for(j = 0; j < n; j++) //左上角顶点的横坐标
          {
               for(k = 0; k < m; k++) //左上角顶点的纵坐标
               {
                    //(j+i,k)左下角顶点坐标
                    //(j,k+i)右上角顶点坐标
                    if(j+i >= 0 && j+i < n && k+i >= 0 && k+i < m) //是正方形(两顶点的坐标在合法范围内)，因为边边相等，所以加的值也就一样
                    {
                         count1++;
                    }
               }
          }
     }
     for(i = 0; i <= n; i++) //宽
     {
           for(j = 0; j <= m; j++) //长
           {
                for(r = 0; r < n && i != j; r++) //左上角顶点的横坐标
                {
                     for(c = 0; c < m; c++) //左上角顶点的纵坐标
                     {
                           //(r+i,c)左下角顶点坐标
                           //(r,c+j)右上角顶点坐标
                           if(r+i >= 0 && r+i < n && c+j >= 0 && c+j < m) //是长方形(两顶点的坐标在合法范围内)，因为边边不相等，所以加的值也就不一样
                           {
                                 count2++;
                           }
                      }
                 }
             }
      }
     printf("%d %d", count1,count2);

     return 0;
}

```


---

## 作者：dashuaibifqw (赞：10)

简单题

分析：

首先对于n\*m方格的棋盘中的任意的正方形而言，只要确定了左上角的位置和边长后，该正方形就完全确定了，如果两个正方形的左上角位置不同或左上角位置相同但边长不同，则这两个正方形显然不相同，因此只要穷举出最下面和最右边之外的所有格点（两条边的交叉点），算出以它们作为正方形的左上角位置时边长不同的正方形个数，然后累加起来即得到全部的正方形个数。同样地，以某一个格点为长方形的左上角位置的长方形（包括正方形）个数也可以类似地算出来，然后累加起来即得到全部的长方形个数，再去掉前面算出的正方形个数即为程序中要求的长方形个数了。

为了求出以某一个格点为正方形的左上角位置时的正方形个数，我们对所有的边进行编号，将从上到下的m+1条横向边定为第0行道第m行，将从左到右的n+1条纵向边定位第0列到第n列，这样以第i行与第j列的交叉点为正方形的左上角位置的正方形边长最大只能为m-i与n-j中的最小值，因此以第i行与第j列的交叉点为正方形的左上角位置的正方形个数为min(m-i,n-j),类似地以第i行与第j列的交叉点为正方形的左上角位置的长方形个数（包括正方形）(m-i)\*(n-j)个，因为长方形的高可以取1到m-i中的任一值，长方形的宽可以取1到n-j中的任一值。

源程序：

```cpp
var n,m,i,j:longint;
      s:longint;    //存放正方形和长方形的个数；
begin
  readln(n,m);
  s:=0;
  for i:=0 to n-1do
     for j:=0 to m-1 do
        if n-i<m-j then
          s:=s+n-i
        else
            s:=s+m-j;                          //算正方形个数；
  write(s,' ');       //输出；
  s:=-s;         //记住，重新赋值；
  for i:=0 to n-1 do
     for j:=0 to m-1 do
        s:=s+(n-i)*(m-j);      //公式：s:=s+(n-i)*(n-j）；
  write(s);
end.

```

---

## 作者：fzj2007 (赞：6)

一眼看到这个题，本来以为挺麻烦的，结果发现还挺简单的。。

先来分析一下：

~~小学~~奥数里说：规则的n*m方形中长方形（包括正方形）的个数为（1+2+..+n）*(1+2+..+m)

那么，化简就是（n+1）*n/2*（m+1）*m/2;
（~~楼下大佬的公式一个也没看懂，还是用**我们小学**的思路吧~~）

其实就是楼下大佬的公式（n+1）*（m+1）*n*m/4（上代码）

```
k1=(1+n)*n/2;
k2=(1+m)*m/2;
cf=k1*k2;
```

而正方形的个数就是（还是上代码吧。。。）
```
for(int i=1;i<=min(n,m);i++)
	zf+=(n-i+1)*(m-i+1);
```
这题的答案也就出来了：
```
#include<bits/stdc++.h>
using namespace std;
  //分别代表n*m大小的棋盘和长方形用到的变量
int n,m,k1,k2;
  //分别代表长方形和正方形
int cf,zf;
int main(){
	scanf("%d%d",&n,&m);
  	//长方形
	k1=(1+n)*n/2;
	k2=(1+m)*m/2;
	cf=k1*k2;
       //正方形
	for(int i=1;i<=min(n,m);i++)
		zf+=(n-i+1)*(m-i+1);
                   //别忘了减正方形的啊
	cout<<zf<<" "<<cf-zf<<endl;
	return 0;
}
```
[AC，11ms,796KB，大佬多多指教](https://www.luogu.org/record/22885286)

看到这里的，点个赞再走哈

---

## 作者：Kaedeuim (赞：5)

这道题可以用长方形的个数（把正方形看成长方形），减掉正方形的个数就可以了。

公式如下：

```cpp
for(int i=m;i>0;i--)
	s+=i;//求长方形的长有几种可能
for(int i=n;i>0;i--)
	d+=i;//求长方形的宽有几种可能
```
然后是正方形：
```
边长为1：
m*n
边长为2：
(m-1)*(n-1)
边长为3：
(m-2)*(n-2)
......
最后可以推出：
边长为i的公式是：(m+1-i)*(n+1-i)
再把所有的积加起来即可。
代码是：
for(int i=1;i<=min(m,n);i++)
{
  ans+=(m+1-i)*(n+1-i);
	}
```
### 附上AC代码

```cpp
#include<iostream>
using namespace std;
int main()
{
	int m,n,s=0,d=0;
	cin>>m>>n;
	int ans=0,bns=0;
	for(int i=m;i>0;i--)
		s+=i;
	for(int i=n;i>0;i--)
		d+=i;
	bns=s*d;
	;
	for(int i=1;i<=min(m,n);i++)
	{
		ans+=(m+1-i)*(n+1-i);
		}
		cout<<ans<<' '<<bns-ans;
    	while(1);//让您抄题解
	return 0;
	}

```


---

## 作者：约修亚_RK (赞：5)

给学弟讲这题的时候发现我的做法微妙的和题解里面没有重复...

我们可以不用推O(1)的公式，简单地遍历每个“小矩形”的长和宽。当长等于宽的时候，矩形数加到正方形里；否则，矩形数加到长方形里。

那么，在 m\*n 的方格中有多少个 x\*y 的矩形要怎么求呢？我们考虑每个矩形左上角的方格 (x1, y1)，x1和y1最小可以为1；不难看出，x1 (矩形左上角的x坐标) + x (矩形长) - 1 = x2 (矩形右上角的x坐标)，x2 <= m，得 x1 <= m - x + 1。同理，y1 <= n - y + 1。左上角的方格所在的位置就有了 (m-x+1)\*(n-y+1) 种，这也就是 x\*y 的矩形数了。

```cpp
/* P1548
 * Au: SJoshua
 */
#include <cstdio>

int main(void) {
    int n, m, ans = 0, anst = 0;
    scanf("%d %d", &n, &m);
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= m; i++) {
            (k == i ? ans : anst) += (n-k+1) * (m-i+1);
        }
    }
    printf("%d %d", ans, anst);
    return 0;
}
```

---

## 作者：LevenKoko (赞：5)


```cpp
//数学公式？？
//暴力复杂度：O(n^2*m^2) 大约是O(10^8)，再加上本题根本不用考虑其他辅助的时间 ,暴力可以做 
//当然这题解是给刚入门的人看的
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cstring>
using namespace std;
int x,y,l,h,n,m,z=0,c=0;
int main()
{
    cin>>n>>m;
    for(x=1;x<=n;x++)
        for(y=1;y<=m;y++)//XY枚举坐标 
            for(l=1;l<=n-x+1;l++)
                for(h=1;h<=m-y+1;h++)//lh枚举长和宽 
                {
                    if(l==h) z++;//若长和宽相等 
                    else c++;//不等的话 
                } 
    cout<<z<<" "<<c;
    return 0;
}
```

---

## 作者：御·Dragon (赞：4)

## 其实有两种方法，爆搜和找规律。
### 爆搜:一个长方形(包括正方形)枚举出左上角和右下角的点即可。但是枚举的时候要注意,因为n、m是长度,所以点要加1
#### 如图
![](https://cdn.luogu.com.cn/upload/pic/39401.png) 

__附上代码：__

```
#include<bits/stdc++.h>//万能头懒人必备 
using namespace std;
int n,m,x,y;//n,m为长和宽,x、y为计数器,分被记录正方形和长方形 
int main(){
	cin>>n>>m;//输入 
	for(int i = 1;i <= n; i++)
		for(int j = 1;j <= m; j++)//枚举左上角的点 
			for(int a = i + 1;a <= n + 1; a++)
				for(int b = j + 1;b <= m + 1; b++){//枚举右上角的点 
					if(a - i == b - j)x++;//如果长和宽一样则为正方形 
					else y++;//否则为长方形 
				}
	cout<<x<<" "<<y;//输出 
	return 0;
}
```

### 规律的话你动手算算,会发现

```
边长为1的正方形个数为n*m
边长为2的正方形个数为(n-1)*(m-1) （自己动手想想）
边长为3的正方形为个数(n-2)*(m-2)
边长为min(n,m)的正方形为个数s1=(n-min(n,m)+1)*(m-min(n,m)+1)
然后从边长为1到min（m，m）的正方形个数全部加起来；
长方形:(包括正方形，好像正方形属于长方形来着？)
长为1的长方形（包括正方形）有n个
长为2的长方形（包括正方形）有n-1个
长为n的长方形（包括正方形）有1个
长为1到n的长方形1+2+...+n个
同理 宽为1的长方形（包括正方形）有m个
宽为2的长方形（包括正方形）有m-1个
宽为m的长方形（包括正方形）有1个
宽为1-m的长方形1+2+...+m个
然后把它们乘起来，根据乘法原理，总数s2=((1+n)*(1+m)*n*m)/4;
题目要求的是“非正方形的长方形”，因此要减去s1;
              —————— jxdql2001
```

__代码就不晒了__

---

## 作者：cxy004 (赞：4)

```cpp
#include<cstdio>
using namespace std;
int n,m,ans;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n<m?n:m;i>=1;--i) ans+=(m-i+1)*(n-i+1);  //正方形个数
    printf("%d %d\n",ans,(m*m+m)*(n*n+n)/4-ans);  //m*n棋盘可以数出(1+2+…+m)*(1+2+…+n)个正方形和长方形
    return 0;
}
```

---

## 作者：eiheiheihei (赞：3)

看到大部分人都用枚举，我的公式法似乎有点弱\
但至少能算出来\
这是我的~~丑陋~~AC代码：

------------
```cpp
//不好算也不好想到的公式法
#include<bits/stdc++.h>
using namespace std;
unsigned square(unsigned n, unsigned m)//正方形
{
    if (n > m)
        return m * (m + 1) * (3 * n - m + 1) / 6;
    return n * (n + 1) * (3 * m - n + 1) / 6;//不要问我为什么这个公式是这样的，自己算去
}
unsigned rectangle(unsigned n, unsigned m)//长方形
{
    return n * (n + 1) * m * (m + 1) / 4 - square(n, m);
    //因为正方形不算长方形所以要减掉
}
int main()
{
    unsigned n, m;
    cin >> n >> m;
    cout << square(n,m) << ' ' << rectangle(n, m);
    return 0;
}
```

---

## 作者：pokefunc (赞：2)

这里有一个公式：








对于任何一个被划分成n*m的长方形，其中总长方形个数为





n(n+1)*m(m+1)/4。



推导过程；~~鱿鱼~~由于长方形的长和宽确定，就一定确定长方形。例如下图。

|  |  |
| :----------: | :----------: |
|  |  |
|  |  |

他的长是2，宽是3（就看做边长相等啦）


则在长上有3条线段（长度为1的有2条，长为2的有1条）


宽上有6条线段，一条长可以随机组合一条宽，所以根据乘法原理，共有18个啦~~~~~


然鹅某些同学就想问了：我算出来也是18呀，系统为啥给我打错？？？


答案就是：在这道题里，正方形不算做长方形的一种！


so,计算正方形个数可以这样想：
首先还是以上面的长方形为~~栗子~~例子

有6个基础小方格（1×1）

然后又因为边长最多为2

则最大方格是2×2

有（3-1）×（2-1）=2个，答案=6+2=8个。

长方形个数=18-8=10个

------------
代码如下：
```cpp
#include<iostream>
using namespace std;
int in1,in2,sqr,ret;
int main()
{
	cin>>in1>>in2;
	ret=(in1*(in1+1)/2)*(in2*(in2+1)/2);
	while(in1>0&&in2>0）
	{
		sqr+=in1*in2;
		in1--;
		in2--;//从最小正方形开始计数
	}
	cout<<sqr<<" "<<ret-sqr<<endl;
	return 0
}





```

注：也可以这样写

```cpp
#include<iostream>
using namespace std;
int in1,in2,sqr,ret,k1,k2;
int main()
{
	cin>>in1>>in2;
	ret=(in1*(in1+1)/2)*(in2*(in2+1)/2);
	while(k1<=in1&&k2<=in2）
	{
		sqr+=k1*k2;
		k1++;
		k2++;//从最大正方形开始计数
	}
	cout<<sqr<<" "<<ret-sqr<<endl;
	return 0
}
```



---

## 作者：Caishifeng666 (赞：2)

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int c,k,i,c1,k1;
int main(){
    cin>>c>>k;//输入长（c）和宽（k）
    if (c>k) swap(c,k);//把较小数存在c中
    for (i=1;i<=c;i++) c1+=(c-i+1)*(k-i+1);//巧算求出正方形的个数
    k1=(k+1)*k*(c+1)*c/4-c1;//长方形的个数等于全部图形的个数减去正方形的个数
    cout<<c1<<" "<<k1;//输出
    return 0;//保持好习惯
}
```

---

## 作者：Polaris_Dane (赞：2)


很简单的啦！在这种图形中，正方形有(m-1)\*(n-1)+(m-2)\*(n-2)+......+(m-n+1)\*(n-n+1)+m\*n(m>n)个，长方形有C\_2^(m+1)\*C\_2^(n+1)个

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    int n,m,i,small,square;
    scanf("%d %d",&n,&m);
    if (n>m)
    {
        small=m;
    }
    else
    {
        small=n;
    }
    square=0;
    for (i=0;i<=small;i++)
    {
        square=square+(m-i)*(n-i);
    }
    printf("%d ",square);
    printf("%d",((m+1)*m/2)*((n+1)*n/2)-square);
    return 0;
}
```

---

## 作者：ars4me (赞：2)

正方形个数

边长为1 个数n\*m

边长为2 个数（n-1）\*（m-1）

边长为3 个数（n-2）\*（m-2）

所以
边长为min{n，m} 个数（m-min{n，m}+1）\*（n-min{n，m}+1）


长方形加正方形个数

total=（1+2+3+…+n）\*（1+2+3+…+m）

=（（1+n）\*（1+m）\*n\*m)/4


长方形个数

上面两式相减即可得出


所以思路就是 先算出正方形个数 然后用公式得出长方形和正方形个数总和 最后得到长方形个数

代码很短

```cpp
#include<iostream>
using namespace std;
int n,m,a,b,c,d;
int main()
{
    cin>>n>>m;    
    a=m;b=n;c=m*n;
    while(a!=0&&b!=0){
        a--;b--;c+=a*b;
    }
    d=(m+1)*(n+1)*m*n/4-c;
    cout<<c<<" "<<d;
}
//COYG
```

---

## 作者：oreimo_eromanga (赞：1)

```cpp

#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<string>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    long long n,m,total=0,ans=0;
    cin>>n>>m;
    total=((n+1)*n/2)*((m+1)*m/2);  //先求出所有的个数。 
    for(int i=0;i<n,i<m;i++)
       ans+=(m-i)*(n-i);            //再求出正方形的个数。 
    cout<<ans<<" "<<(total-ans)<<endl;  //最后输出。 
    system("pause");
}

```

---

## 作者：初学者1 (赞：1)

本题其实是一道水题，只要小学有奥数基础。

正方形的个数每个人应该都会求吧，只需枚举一下就行了：

  ```delphi
repeat  
  k:=k+1;  
  for i:=1 to n-k+1 do  
      for j:=1 to m-k+1 do  
      s:=s+1;  
  until k=min(n,m);
```
长方形的个数也很好求,只需将所有的矩形减去正方形的个数即可。

所有矩形求的方法，也是小学奥数里面的：长边上线段的条数\*短边上线段的条数

(解释一下，边上线段的条数就是数线段，例如一条线端上有5个端点，边上线段的条数就是4+3+2+1=10(条)，也可以用公式（边的长度+1）\*边的长度 div 2)。

讲了这么多，源程序如下：

```delphi
var n,m,s,k,s1,s2:int64;  
    i,j:longint;  
function min(x,y:longint):longint;  
begin  
  if x<y then exit(x) else exit(y);  
end;  
begin  
  readln(n,m);  
  s:=n*m;k:=1;  
  if min(n,m)<>1 then begin  
  repeat  
  k:=k+1;  
  for i:=1 to n-k+1 do  
      for j:=1 to m-k+1 do  
      s:=s+1;  
  until k=min(n,m);  
  end;   
  s1:=0;s2:=0;write(s);  
  for i:=1 to n do s1:=s1+i;  
  for i:=1 to m do s2:=s2+i;  
  writeln(' ',s1*s2-s);  
end.  

```

---

## 作者：雪颜 (赞：1)

水题，具体公式可参见下文。c++

```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    long long n,m;//防止计算过程中超过整型变成负数
    cin>>n>>m;
    long long ans1,ans2;
    ans1=ans2=0;
    ans2=(1+n)*n/2*(1+m)*m/2;//包含正方形的长方形总数
    for(int i=1;i<=n;i++){
        ans1+=(n-i+1)*(m-i+1);//正方形个数
    }
    printf("%lld %lld",ans1,ans2-ans1);//最后长方形个数要减去正方形个数
    return 0;
}

```

---

## 作者：封禁用户 (赞：1)

****附：首先，如果大家没有学过排列组合，请不要往下看****

我们先用排列组合中的C(n+2)2\*C(m+1)2求出矩形总数（即n\*(n+1)/2\*m\*(m+1)/2)

然后用楼下几位那样求正方形的数量，最后一减一输出便KO

代码附上：


```cpp
#include <iostream>
#include <cstring>
using namespace std;
long long C(int n)//Cn2
{
    return n*(n+1)/2;
}
int main()  
{  
       int n,m;
       int i,j;
       cin >>n>>m;
       int s;
       int zh=0,ch=0;//zh表示正方
       s=C(n)*C(m);
       if(n > m) swap(n,m);
       for(i=1;i<=n;i++)
           zh+=(n-i+1)*(m-i+1);
       ch=s-zh;
       cout <<zh<<" "<<ch;
       return 0;
}
```

---

## 作者：为人民服务 (赞：1)

仅凭我个人观点，以上的大佬们都在采用数学证明，对于一个刚上高中的萌新来说，便有些难以理解了。

但我信奉一件事：暴力，暴力出奇迹；

据此思想——就可导出——循环+深搜的做法。

好吧，对程序具体的解释在注释中。而且本做法的时间复杂度极高乃o（n^4）。——多亏数据有些水。。






```cpp
#include <iostream>
using namespace std;
int  n , m ,ans_z,ans_c;
bool f[3000][3000];
void dfs_z(int i,int j)//对除去一个格的正方形进行搜索
{
    if(f[i][j]==0)   return ;//防止搜索超过界
    if(f[i][j]==1)  
    {
        ans_z++;//答案++；
        dfs_z(i+1,j+1);//继续找正方形下一个右下角。
    }
}
void dfs_c(int i,int j)//搜长方形；方法是找他的右下角
{
    for(int p=i;p<=n;p++)
        for(int q=j;q<=m;q++)
            {
                if(p-i==q-j)    continue;//排除正方形
                else ans_c++;
            }
}
int main ()
{
    cin >> n >> m ;
    ans_z=n*m;//对只有一个格的正方形进行分析
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            f[i][j]=1;//建立一个范围，防止搜过界
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            dfs_z(i+1,j+1);)//对除去一个格的正方形进行搜索
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            dfs_c(i,j);//搜索长方形
    cout<<ans_z<<" "<<ans_c;//答案；
    return 0;
} 
//抱歉，我是个死忠的换行党。。
```

---

## 作者：gorokokoro (赞：0)

上面的都没有推导出来的过程啊

这里就简单写一下吧

我们要求的矩形个数，实际上就是

$ \sum^{i=0}_{n}\sum^{j=0}_{m} (n-i)(m-j) $

将这个式子展开，可以得到：

$ n^2m^2-n^2 \frac{m^2-m}{2}-m^2 \frac{n^2-n}{2}+ \frac{n^2-n}{2} \cdot \frac{n^2-n}{2} $

化简可得：

$ \frac{(n+m+nm+1)nm}{4} $


而求正方形的，实际上是求

$ \sum^{i=0}_{n}\sum^{j=0}_{m} \min (n-i,m-j) $

然而对于这个数，我们并没有好的求解方式

于是就愉快的枚举了（逃

``` cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int n, m;
    int i, j, o;

    cin >> n >> m;
    for(i = o = 0;i < n;i ++)
        for(j = 0;j < m;j ++)
            o += min(n - i, m - j);
    cout << o << ' ' << (n + m + n * m + 1) * n * m / 4 - o << endl;

    return 0;
}
```

---

## 作者：sulley (赞：0)

大家都给出了数学解法...对于我等根本就没忘这方面想的蒟蒻来说...根本想不到

于是...我想到了动规解法...

dp[i][j][0]是i\*j区域中正方形的个数，对应的dp[i][j][1]是长方形个数。

首先对i，j=1分别进行初始化，然后对dp[i][j]，要比较i和j的大小分情况递推。

对i<=j，我们固定i，对j方向进行递推；j<i，固定j，在i的方向递推。（当然也可以反过来...）

```cpp
#include<iostream>
using namespace std;
int a[102][102][2],n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=100;i++){
        a[i][1][0]=a[1][i][0]=i;
        a[i][1][1]=a[1][i][1]=a[i-1][1][1]+i-1;
    }
    for(int i=2;i<=n;i++){
        for(int j=2;j<=m;j++){
            if(i<=j) {
                a[i][j][0]=a[i][j-1][0]+i+(i-1)*i/2;
                a[i][j][1]=a[i][j-1][1]+(j-1)*i*(i+1)/2; 
            }
            else{
                a[i][j][0]=a[i-1][j][0]+j+(j-1)*j/2;
                a[i][j][1]=a[i-1][j][1]+(i-1)*j*(j+1)/2; 
            } 
        }
    }
    cout<<a[n][m][0]<<' '<<a[n][m][1]<<endl;
}
```

---

## 作者：A_konjac (赞：0)

```cpp
//简单粗暴公式流……
#include<stdio.h>
int main()
{
    int n,m,sum,zfx=0;//sum是由公式计算出的长方形和正方形的总和，zfx是正方形的总数
    scanf("%d%d",&n,&m);
    for(int i=1;;i++)//i为正方形边长长度
    {
        if(i>n||i>m)//不能行就退出循环
        break;
        zfx+=(n-i+1)*(m-i+1);//计算这个边长的正方形共有几个
    }
    sum=n*(n+1)/2*m*(m+1)/2;//计算正方形与长方形的总个数
    printf("%d %d\n",zfx,sum-zfx);
    return 0;
}
```

---

## 作者：ztz_cpp (赞：0)

#真的很简单

直接用数学公式就可以了

正：nm+(n-1)(m-1)+……+1(m-n+1)

(注   n比m小)

长：（1+2+……+n）（1+2+……+m）-正。

~~~~cpp

```cpp
#include<iostream>
using namespace std;
int chang(int n,int m){//长方形
    n=(1+n)*n/2;
    m=(1+m)*m/2;
    return n*m;
}
int zheng(int n,int m){//正方形
    int sum=0;
    while(n>0){
        sum+=n*m;
        n--;
        m--;
    }
    return sum;
}
int main(){
    int n,m;
    cin>>n>>m;
    if(n>m){//如果n>m，nm交换。
        int k=n;
        n=m;
        m=k;
    }
    cout<<zheng(n,m)<<" "<<chang(n,m)-zheng(n,m);
    return 0;
}
```
~~~~
###加油啊！！！


---

## 作者：lzr20040310 (赞：0)

小学奥数……

对于一个m\*n的正方形网格阵(m≥n)

正方形的个数为=mn+(m-1)(n-1)+...+(m-n+1)\*1

=∑(i=0,n-1) (n-i)(m-i)

长方形的个数为(包括正方形)=(1+2+...+m)\*(1+2+...+n)

={[m(m+1)]/2}\*{[n(n+1)]/2}

=[mn(m+1)(n+1)]/2

长方形的个数(不包括正方形)=长方形的个数(包括正方形)+正方形的个数

所以就有

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main( ){
    int m,n,squ=0,rec,k,i;//m,n输入不解释，squ是正方形个数，rec是长方形个数，k是为了交换，i是循环变量
    scanf("%d%d",&m,&n);//输入
    if(m<n){//让m>=n
        k=m;
        m=n;
        n=k;
    }
    for(i=0;i<n;i++)//求∑(i=0,n-1) (m-i)(n-i)
        squ+=(n-i)*(m-i);
    rec=(n*m*(n+1)*(m+1))/4-squ;//求长方形个数(包括正方形)再减去正方形个数
    printf("%d %d",squ,rec);//输出
    return 0;
}
```
如果你要Pascal...

```cpp
program P1548;
var m,n,squ,rec,k,i:longint;{所有注释见上}
begin
    read(m,n);
    if m<n then
    begin
        k:=m;
        m:=n;
        n:=k;
    end;
    for i:=0 to n-1 do
        squ:=squ+(n-i)*(m-i);
    rec:=(n*m*(n+1)*(m+1)) div 4-squ;
    write(squ,' ',rec);
end.
```

---

## 作者：封禁用户 (赞：0)

```cpp
//本题用的简单公式
var
 n,m,i,j,a,b:longint;
begin
 readln(n,m);
 for i:=1 to n do//表示长为i,宽为j的矩形
  for j:=1 to m do
   if i=j then a:=a+(n-i+1)*(m-j+1) else b:=b+(n-i+1)*(m-j+1);//(n-i+1)*(m-j+1)表示长宽分别为i,j的矩阵个数,a表示正方形,b表示长方形
 writeln(a,' ',b);//输出
end.
```

---

## 作者：CraZYali (赞：0)

#其实，这道题用公式就可以了

#正方形：sum=m\*(m+1)\*(3\*n-m+1)/6（m>n）

#长方形：

```cpp
while(m)k+=m,m--;
while(n)j+=n,j--;
s=j*k-sum;
```
#自己去琢磨······

```cpp
#include<iostream>
using namespace std;
int i,m,n,j,k,z;
int main(){  
    cin>>n>>m;
    m=max(n,m);
    n=min(n,m);
    z=m*(m+1)*(3*n-m+1)/6;
    cout<<z<<" ";
    while(m)k+=m,m--;
    while(n)j+=n,n--;
    cout<<k*j-z; 
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

```cpp
//十分简单，有奥数基础的人都能做出来。
program exam;
var
  n,m,m1,n1,s1,s2:longint;
begin
  read(m,n);//读入
m1:=m; n1:=n;
s1:=m1*n1;//棋盘格数
while (m1<>0)and(n1<>0) do
  begin
  m1:=m1-1; n1:=n1-1;
   s1:=s1+m1*n1;
end; //求正方形的个数。
s2:=((m+1)*(n+1)*m*n)div 4-s1;//求长方形的个数。
writeln(s1,' ',s2);
end.
```

---

## 作者：ws_fx0 (赞：0)


```cpp
    var  
     a,b,c,M,N,i,h,k:longint;  
    begin  
     readln(M,N);  
     a:= (3*M-N+1)*N*(N+1)div 6;  
     h:=M*N*(M+1)*(N+1)div 4-a;  
     writeln(a,' ',h);  
    end.  
公式法
```

---

## 作者：李紫浩 (赞：0)

本题其实是一道水题，只要小学有奥数基础。

正方形的个数每个人应该都会求吧，只需枚举一下就行了：

  ```delphi
repeat  
  k:=k+1;  
  for i:=1 to n-k+1 do  
      for j:=1 to m-k+1 do  
      s:=s+1;  
  until k=min(n,m);
```
长方形的个数也很好求,只需将所有的矩形减去正方形的个数即可。

所有矩形求的方法，也是小学奥数里面的：长边上线段的条数\*短边上线段的条数

(解释一下，边上线段的条数就是数线段，例如一条线端上有5个端点，边上线段的条数就是4+3+2+1=10(条)，也可以用公式（边的长度+1）\*边的长度 div 2)。

讲了这么多，源程序如下：

```delphi
var n,m,s,k,s1,s2:int64;  
    i,j:longint;  
function min(x,y:longint):longint;  
begin  
  if x<y then exit(x) else exit(y);  
end;  
begin  
  readln(n,m);  
  s:=n*m;k:=1;  
  if min(n,m)<>1 then begin  
  repeat  
  k:=k+1;  
  for i:=1 to n-k+1 do  
      for j:=1 to m-k+1 do  
      s:=s+1;  
  until k=min(n,m);  
  end;   
  s1:=0;s2:=0;write(s);  
  for i:=1 to n do s1:=s1+i;  
  for i:=1 to m do s2:=s2+i;  
  writeln(' ',s1*s2-s);  
end.  

```

----------------------------

```cpp
var
  i,j,m,n,s:longint;
begin
  read(m,n);
  s:=0;
  for i:=0 to (m-1) do
    for j:=0 to (n-1) do
      if m-i<n-j then s:=s+m-i else s:=s+n-j;
  write(s,' ');
  s:=-s;
  for i:=0 to (m-1) do
    for j:=0 to (n-1) do
      s:=s+(m-i)*(n-j);
  writeln(s);
  readln;
  readln;
end.

```

---


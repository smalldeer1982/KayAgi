# [NOIP 2015 普及组] 金币

## 题目背景

NOIP2015 普及组 T1

## 题目描述

国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 $n$ 天每天收到 $n$ 枚金币后，骑士会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币。

请计算在前 $k$ 天里，骑士一共获得了多少金币。

## 说明/提示

**【样例 1 说明】**

骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 $1+2+2+3+3+3=14$ 枚金币。


对于 $100\%$ 的数据，$1\le k\le 10^4$。


## 样例 #1

### 输入

```
6```

### 输出

```
14```

## 样例 #2

### 输入

```
1000
```

### 输出

```
29820
```

# 题解

## 作者：XMK_萌新 (赞：393)

看到大佬们的题解感觉自愧不如

我的思路很简单，直接模拟

```cpp
#include <iostream>	
//反对万能头！
using namespace std;
int n,q,c,s;
//n是有多少天
//s是获得的金币总量
//c是每天能获得的金币数
//q表示往后数q天，获得的金币都是c个
int main()
{
    cin>>n;
    c=q=1;	//第一天（往后的一天），获得1个金币
    for(int i=1;i<=n;i++)	//要发n天金币
    {
        s+=c;	//累加
        q--;	//已经发了一天
        if(q==0)	//要更新数据
        {
            c++;	//每天获得金币的数量+1
            q=c;	//根据题意，以后的c天都是c个金币，q就是c
        }
    }
    cout<<s;	//输出
    return 0;	//THE END
}
```

~~当然还有一种更优秀的做法，那就是打表（如果你有坚强的毅力）~~

求过。。

---

## 作者：封禁用户 (赞：237)

这个题大致可以分成两类做法：  
1. 一天一天计算  
2. 一层一层计算  
根据题目描述，我们可以在脑中想象出数据的结构，数据是三角形的，第k层上每天发的金币数刚好是k，因此才会有按层计算的解法。  
![](https://cdn.luogu.com.cn/upload/pic/73675.png)  
### 按天计算  
```cpp
    //m代表总行数
    for(int i = 1;i <= m;i++) {
        //注意三角形的关键是 j<= i 这个条件
        for(int j = 1;j <= i;j++) {
            // i 的值代表行，j 的值代表列    
        }    
    }
```
在这题中，总天数是不能通过 i 和 j 直接得到的，简单的办法是再定义一个累加天数的变量，每次加金币的时候让天数加一，然后检查一下累加的天数是否到达了指定的天数，如果到达了指定天数后输出得到的金币，这个题就可以结束了。相信大家注意到了，在嵌套循环中如何结束程序可是个技术活，请看下面的代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
//错误解法
int main()
{
    //coins保存金币，days累加天数
    int k,coins = 0,days=0;
    cin >>k;
    for(int i = 1;i <= k;i++) {
        for(int j = 1;j <= i;j++) {
            // i 代表行数，同时也是当天可得的金币数
            coins += i;
            days++;
            if ( days == k) {
                //天数达到了指定的天数
                break;    
            }
        }    
    }
    cout<<coins;
    return 0;
}
```
看着没什么问题是不是？然而这个解法是错误的！！！在嵌套循环中使用 break 要特别注意！因为 break 只能结束最近的循环，上面的代码我们使用了嵌套的循环，只用一个 break 跳出内层 for 循环后，外层的 for 循环会继续执行。如果一定要用 break，得在外层for循环中加入break的逻辑。  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，days累加天数
    int k,coins = 0,days=0;
    cin >>k;
    for(int i = 1;i <= k;i++) {
        for(int j = 1;j <= i;j++) {
            // i 代表行数，同时也是当天可得的金币数
            coins += i;
            days++;
            if ( days == k) {
                //天数达到了指定的天数
                break;    
            }
        }
        //结束外层循环
        if ( days == k) {
            //天数达到了指定的天数
            break;    
        }
    }
    cout<<coins;
    return 0;
}
```
这题只要输出金币就可以结束程序了，没有必要一定要在for循环外面 cout<<coins，所以更推荐在for中用return 直接结束程序，可以省去很多烦恼。  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，days累加天数
    int k,coins = 0,days=0;
    cin >>k;
    for(int i = 1;i <= k;i++) {
        for(int j = 1;j <= i;j++) {
            // i 代表行数，同时也是当天可得的金币数
            coins += i;
            days++;
            if ( days == k) {
                //天数达到了指定的天数
                cout<<coins;
                return 0;
            }
        }
    }
    return 0;
}

```
一天一天计算的话，如果你不想在 for 循环内部通过 break 或者 return 结束，可以把限制条件加到 for 循环的条件中，这样当条件满足时会自动结束循环。  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，days累加天数，初始值为0
    int k,coins = 0,days=0;
    cin >>k;
    //条件写到 for 循环中，外层 for 循环只负责天数的自增
    for(int i = 1;days < k;i++) {
        //内层for循环的条件比较讲究，为了保持三角形的结构， j <= i 必须保留
        //同时加入 days < k 的条件
        //如果days初始值是1，那条件要改成 days <= k
        for(int j = 1;j <= i && days < k;j++) {
            // i 代表行数，同时也是当天可得的金币数
            coins += i;
            //days 累加完后等于 k，刚好跳出循环
            days++;
        }
    }
     cout<<coins;
    return 0;
}
```
----------------分割线----------------  
### 一层一层计算  
一层一层计算的话，只用一个 for 循环就够了。
根据每天获得的金币数量对天数做了分隔,可以看到区间的长度是随着天数在不断增大的，这样的区间才符合题目要求. 因为区间是连续的，K 一定会落在某个区间中，以蓝色箭头表示 K ,红色箭头指向的就是需要特殊处理的边界情况，这个题就被分成了两段。  
![](https://cdn.luogu.com.cn/upload/pic/73678.png)  
那么如何找到边界呢？第 N 个区间的左边界是 1+2+…+(N-1),右边界是 1+2+3+…+N-1+N，左边是开区间，右边是闭区间。

边界前的金币总和特别好算，1+22+33+… ；
从边界到 k 的金币数 = 边界到 k 之间的长度 * 当前区间每天可以获得的金币数。

用层的思想来解决的话，核心的思路是：不满的一定是最后一层。下面几种解法是根据当前层不满的情况进行计算的，解法比较多样：  
#### 先加再减  
```cpp  
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，days累加天数
    int k,coins = 0,days=0;
    cin >>k;
    for(int i = 1;i <= k;i++) {
        //不管三七二十一，先把一整层都加上。
        coins += i*i;
        days += i;//注意天数一次加一层的
        //days > k 和 days == k 都代表到达了最后一层，可以统一处理
        if (days >= k) {
            //万一这一层不满就相当于加多了，此时减掉多加的金币
            coins -= i*(days - k);    
            break;//写成 cout<<coins;return 0；也可以
        }
    }
    cout<<coins;
    return 0;
}  
```  
不必区分最后一层是不是满了，最后一层满的时候 days - k == 0 不会对结果造成影响。  
#### 先加后减  
```cpp  
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，不用保存天数了但是得保存最后一层的层数
    //因此 for 的变量 i 需要提前定义
    int k,coins = 0,i;
    cin >>k;
    //还有剩余天数再进行累加，所以条件是 k > 0
    //切记这里不要写成 int i = 1
    for(i = 1;k > 0;i++) {
        //不管三七二十一，先把一整层都加上。
        coins += i*i;
        k -= i;//在 k 上直接减
    }
    //此时 k 是个小于等于 0 的数字，刚好等于多加的天数
    //这里需要最后一层的金币/天,i 在for结束时因为执行了 i++，所以计算时要 - 1
    coins += k*(i-1);
    cout<<coins;
    return 0;
}  
```  
如果你觉得 i 这里的坑太多的话，不妨多定义个变量，就用来保存最后一层的天数：  
```cpp  
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，不用保存天数了但是得保存最后一层的层数
    //新定义一个变量 c
    int k,coins = 0,c = 0;
    cin >>k;
    //还有剩余天数再进行累加，所以条件是 k > 0
    for(int i = 1;k > 0;i++) {
        //不管三七二十一，先把一整层都加上。
        coins += i*i;
        k -= i;//在 k 上直接减
        c = i;//c保存当前的层数
    }
    //此时 k 是个小于等于 0 的数字，刚好等于多加的天数
    //这里直接用c
    coins += k*c;
    cout<<coins;
    return 0;
}  
```  
如果你不想考虑负数的情况，可以修改 for 循环的判断条件为 k > i,这样就相当于我们总是把最后一层单独处理：  
```cpp  
#include <bits/stdc++.h>
using namespace std;

int main()
{
    //coins保存金币，不用保存天数了
    //定义for循环使用的变量i
    int k,coins = 0,i;
    cin >>k;
    //这里 for 循环只处理最后一层之上的层
    //切记这里不要写成 int i = 1
    for(i = 1;k > i;i++) {
        //不管三七二十一，先把一整层都加上。
        coins += i*i;
        k -= i;//在 k 上直接减
    }
    //此时 k 是最后一层的剩余天数
    //i 自增后刚好是最后一层每天的金币数
    coins += k*i;
    cout<<coins;
    return 0;
}  
```  
这个题的解法实在是太多了，还可以在计算当前层的时候判断下一层是否是满层，或者用高斯公式计算总天数，再用平方和公式计算金币数，我就不一一罗列了。  
#### 关爱生命，拒绝抄袭


---

## 作者：Starlight237 (赞：60)

# [金币](https://www.luogu.org/problemnew/show/P2669)
前面已经有dalao写出了公式，然而并非最优解，下面具体解说。
首先思路还是讲一下（虽然有dalao）讲过了：

$\sum\limits^n_{k=1}k^2=\frac16n(n+1)(2n+1)$

$\sum\limits^n_{k=1}k=\frac12n(n+1)$

根据第二个公式，可得收到金币的基本组数（去除余下的不满一组的天数）n符合：$Days=\frac12n(n+1)+r$其中r为余下的不满一组的天数。上式等价于：$n^2+n-2Days\approx0$ 故$n=int(\frac{-1+\sqrt{1+8Days}}2)=int(\frac{\sqrt{1+8Days}-1}2)$ 

（欲知本式推导过程，请自行学习一元二次方程之解法）

所以基本组数对应的金币数为$\frac16n(n+1)(2n+1)$.

考虑到还有余项，不难得到$r=(n+1)\times (Days-\frac12n(n+1))$其中n当然是基本组数了。

于是我们得到：$ans=\frac16n(n+1)(2n+1)+(n+1)\times (Days-\frac12n(n+1))$

当然可以写成变量优化：$m=n(n+1),ans=\frac16m((n<<1)+1)+(n+1)\times (Days-(m>>1))$

据分析，本式的计算需要3次加法，1次减法，3次乘法，1次除法。显然乘法次数有些多了。

下面就让我们感受数学之美妙：

$ans=\frac16n(n+1)(2n+1)+(n+1)(d-\frac12n(n+1))$

$=\frac{n^3}3+\frac{n^2}2+\frac n6-\frac{n^3}2-n^2-\frac n2+(n+1)d$

$=-\frac{n^3}6-\frac{n^2}2-\frac n3+(n+1)d$

$=n(n+1)d-\frac{n(n^2+3n+2)}6$

$=n[d-\frac{(n+1)(n+2)}6]+d$

好了现在再让我们观察一下，只需要3次加法，1次减法，2次乘法和1次除法，是不是更美好？

AC代码奉上：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n,d;
	cin>>d;
	n=(sqrt(1+(d<<3))-1)/2;
	cout<<n*(d*1.0-(n+1)*(n+2)/6.0)+d;
	return 0;
}

```

---

## 作者：zsq9 (赞：19)

[AC 记录](https://www.luogu.com.cn/record/196702910)

## 题目大意

骑士会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币。请计算在前 $k$ 天里，骑士一共获得了多少金币。

## 思路

可以直接模拟，我们可以记录一个计数器 ，当有了 $n+1$ 次时就把应该收到的金币加一这样枚举 $n$ 天就行了，最后输出金币总数就可以了。

## 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
long long sum=0,a=0,b=1,n; //b是每天能获得的金币数
//a表示往后数a天，获得的金币都是b个
int main(){ 
	cin>>n; //有多少天
	for(int i=1;i<=n;i++){ 
		sum+=b;
		a++; 
		if(b==a){ //有了这么多天就增加
			b++;
			a=0; 
		} 
	} 
	cout<<sum; 
	return 0; 
}
```

---

## 作者：PUTONGDEYITIREN (赞：11)

# 思路
### 题目
这道题的题面说的比较清楚，这个人在第一天收到一个金币，之后两天收到两个，再往后三天收到三个……
### 核心思路
给出的 $k$ 特别小，只有 $10^4$，直接模拟。
# code

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n,ans=0,s=1,c=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		c++;
		ans+=s;
		if(c==s){
			c=0;
			s++;
		}
		
	}
	cout<<ans;
}
```

---

## 作者：Yxy7952 (赞：8)

## 思路

模拟题。

在《深入浅出基础版》中介绍过这类题目，这类题目一般只需按照题意模拟，特殊情况时需要使用数据结构及优化。

我们枚举天数在 $1 \sim  n$ 时，获得的金币数，加到答案总和 $sum$ 里，最后输出就行了。

至于怎么确定当天获得的金币，只需记录一个计数器 $a$，如果 $a=b$（$b$ 为当天获得的金币数），那么，下次获得的金币数量为 $b+1$。

## 代码
```cpp
#include<bits/stdc++.h> 
using namespace std; 
int main(){ 
	int sum=0,a=0,b=1,n; 
	cin>>n; 
	for(int i=1;i<=n;i++){ 
		sum+=b;
		a++; 
		if(b==a){ 
			b++;
			a=0; 
		} 
	} 
	cout<<sum; 
	return 0; 
}
```

---

## 作者：player_1_Z (赞：5)

### 先来理解题目
[题目](https://www.luogu.com.cn/problem/P2669)
### 思路
虽然这题可以暴力通过，但是我可以提供一种优化。我们发现有 $x$ 天会领取 $x$ 枚金币，所以我们可以枚举领取的金币数，如果当前的天数超过了 $n$ 就退出循环。然后用 $p$ 来存当前天数，$i$ 表示这几天领取的金币，如果 $p$ 超过了 $n$ 就退出。否则总数加上 $i^2$，$p$ 加上 $i$。同时如果不能把 $i$ 天领完就只领取剩余天数乘上 $i$ 并退出。最后输出结果总金币数。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,s,p;
int main(){
	cin>>n;
	for(int i=1;p<=n;i++){
		if(p+i<=n) s+=i*i;
		else s+=i*(n-p);
		p+=i;
	}
	cout<<s;
	return 0;
}
```

---

## 作者：_qumingnan_ (赞：5)

[题目跳楼机](https://www.luogu.com.cn/problem/P2669)

# 正文开始

## 阅读理解

有一个人，他每天都可以得一个金币。第一天 $1$ 个金币，然后没过 $i$ 天，他就可以多获得一个金币。现在有 $k$ 天，求他最多可以得多少金币？

## 思路

鉴于 $k$ 特别小，不到 $10^4$，所以，可以直接暴力！但是可以发现，他在金币数为 $i$ 的天数中总共可以拿到 $i\times i$ 枚金币，根据这点，就可以优化亿点点。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//天数 
int s,i;
int main() {
	cin>>n;
	for(i=1;i<=n;i++) {
		n-=i;//减去天数 
		s+=i*i;//统计答案 
	}
	s+=n*i;//剩下不足 i 天的金币也要加上 
	cout<<s;
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：4)

## Knowledge

模拟、数学。

## Solution

按题意模拟即可。准备 $4$ 个变量，分别为 $k,now,day,ans$，分别表示总天数、现在每天给的金币数、往后数 $day$ 天，获得的金币都是 $now$ 个、总金币数。

模拟方法：初始将 $now,day$ 都设为 $1$，表示在 $1$ 天内要发 $1$ 个金币。接下来从 $1$ 循环到 $k$，每天累加金币数，将阶段剩余天数减 $1$。注意还要判断，如果阶段剩余天数为 $0$ 了，那么说明到下一个阶段了，将每天给的金币数加上 $1$，再将剩余天数变成每天给的钱数。最后输出金币总数 $ans$ 即可完成。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll k, now = 1, day = 1, ans;
int main() {
	cin >> k;
	for (int i = 1; i <= k; i++) {
		ans += now;
		day--;
		if (day == 0) {
			now++;
			day = now;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Ybll_ (赞：4)

# 题意：
一个人当连续 $n$ 天每天收到 $n$ 枚金币,这个人会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币，问 $k$ 天后这个人会有多少金币。
# 思路：
直接**暴力模拟**即可，详解见代码。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
signed main(){
	cin>>n;//输入 
	for(int i=1,j=0;j<n;i++){
		int k=0;
		while(k<i&&j<n)k++,j++,ans+=i;//每天拿i枚金币，持续i天，一共发了j天的金币，每次发完后要判断是否已满n天。
	}cout<<ans;//输出 
	return 0;
}
```

---


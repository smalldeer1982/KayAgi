# [NOIP 2002 普及组] 级数求和

## 题目描述

已知：$S_n= 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。

现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le k \le 15$。

**【题目来源】**

NOIP 2002 普及组第一题

## 样例 #1

### 输入

```
1
```

### 输出

```
2
```

# 题解

## 作者：Vel_ (赞：36)

## Code

### Force $O(e^k)$

写一个`累加器`和一个`溢出灯`就行。

> 以后可能会将回归性函数称为`器`，分类性函数称为`灯`。

```c++
#include<bits/stdc++.h>
using namespace std;

bool excess(double sn,double k){ //溢出灯
	return sn > k;
}

int main(){
	int i=1;
	double sn=0,k;
	cin>>k;
	while(1){ //累加器
		sn += (double)1/(double)(i++);
		if(excess(sn,k)) {cout<<i-1;break;}
	}
	return 0;
}
```

### 数论优化 $O(logk)$

> https://www.luogu.org/problemnew/solution/P1035
>
> `exp(k)`是指数调用的复杂度，最高可以优化到`log(k)`（相当多项式幂），因此最后得到的复杂度为$O(logk)$。
>
> 值得指出的$O(logk)$仅仅是理论的，**因为最后cout打印的数的宽度已经是O(k)了**！
>
> 运算虽然可以很快，却会被输出所限制。

```c++
#include<bits/stdc++.h>
using namespace std;

bool excess(double sn,double k){
	return sn > k;
}

int main(){
	int i=1;
	double k;
	while(cin>>k){
		cout<<floor(exp(k-0.5772156649) + 0.5)<<endl;
	}
	return 0;
}
```

# 

---

## 作者：合451518 (赞：35)

思路：不停算s，直到s>n.

注意：

1）s必须定义为小数类型

2）for i:=1 to 10000000 是因为当n=15 时算出来是1825421（剧透）,所以循环i太小可能不出结果

3）算出i之后必须exit或break，否则循环一直运行...

```cpp
var
 s:extended;
 n,i:longint;
begin
 read(n);
 s:=0.0;
 for i:=1 to 10000000 do begin
  s:=s+1/i;
  if s>n then begin write(i);exit;end;
 end;
end.
```

---

## 作者：__KevinMZ__ (赞：22)

# 思路

无限循环直到 $S_i>k$，循环中题意模拟。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
double ans;
int n, i;//i要存着！！！
int main()
{
	cin >> n;//输入
	for(i = 1; ans <= n;i++)
	{
        ans += 1.0 / i;//模拟
	}
	cout << i - 1;//注意是i - 1，此时的i已经“++”
	return 0;
}
```

---

## 作者：mairuisheng (赞：10)

[P1035 [NOIP 2002 普及组] 级数求和](https://www.luogu.com.cn/problem/P1035)

主要算法：枚举

分析：每次计数器加 $1/i$ 直到大于 $k$ 时就立刻输出答案。

注意事项：计数器一定要用浮点数类型。
```cpp
#include<bits/stdc++.h>
using namespace std;
int k;
int ans=0;
double n2=0.0,sum=0.0;
int main()
{
    cin>>k;
    while(1)
    {
    	n2++;
    	sum+=1/n2;
    	ans++;
    	if(sum>k)
    	{
    		cout<<ans;
    		return 0;
		}
	}
    return 0;
}
```

---

## 作者：qhr2023 (赞：6)

## solution

一道语法题，考察[循环结构](https://oi-wiki.org/lang/loop/)。

```while``` 循环的基本结构如下。

```
while (判断条件) {
  循环体;
}
```

我们开一个浮点数 $s$ 记录前 $n$ 项的和。对于本题的判断条件是什么，就是 $s \le k$，若不满足这个式子，就找到答案了，跳出循环。循环体，就是我们要执行的操作，我们按照题目要求，每次分母加一，分子为一，计算结果，循环结束后输出 $n$。

## solution

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int k,n=1; 
	cin >> k;
	double s=1;
	while(s<=k){
		n++;
		s+=1.0/n;
	}
	cout << n;
	return 0;
}
```

---

## 作者：getchar_unlocked (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1035)

### 思路

用一个 `while` 循环进行模拟，循环条件为 $S_n\le k$。用一个计数器 $C$ 统计次数。每一次执行次数加一，即 $C\gets C+1$，再更新 $S_n\gets\frac{1}{C}$。最后输出 $C$ 即可。

**注意事项**

- $S_n$ 为 `double` 类型，$\frac{1}{C}$ 计算时应先转为 `double`。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}

int main(){
	int k=read(),cnt=0;
	double n=0;
	while(n<=k){
		++cnt;
		n+=1.0/cnt;
	}
	printf("%d\n",cnt);
	return 0;
}
```

---

## 作者：xingsunderen (赞：3)

我很好奇 dalao 是用什么做法，反正本蒟蒻是直接暴力，什么问题都没有。

当然，这里 $sn$ 是累加的，如果每次重新计算大概率会超时吧，~~反正我是没试过。~~

给个代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,i;
double sn;
main(){
	cin>>k;
	for(i=1;;i++){
		sn+=1.0/i;
		if(sn>k*1.0)
			break;
	}
	cout<<i;
	return 0;
}
```

---

## 作者：sea_bird (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1035)。

红名就是要写红题的嘛。

# 题目分析

很明显，题目进行的操作是对一些分数进行累加，序列中分数的分母是递增的，因此用循环来解决，由于不知道具体循环次数，于是推荐使用 `while()` 循环。题目求的是最少个数的和大于 $k$，那么保持循环的条件就是 $s \le k$。循环里面按照题目要求，先用变量 $cnt$ 存当前分母的值，按照题目要求相加直到满足条件，接着在每轮循环中添加 $ans$ 累加记录，最后输出即可。

## Code

```cpp
#include<iostream>
using namespace std;

int main()
{
	double k,s = 0,x,cnt = 1,ans = 0;
	cin >> k;
	while (s <= k)
	{
		x = 1/cnt;
		s += x;//累加
		cnt ++;//分母
		ans ++;//n
	}
	cout<< ans <<endl;
	return 0;
}
```

---

## 作者：yedalong (赞：2)

## Solution
暴力枚举即可，用一个浮点数变量 $sum$ 存当前的和。对于每一个 $i$，只需将 $sum$ 加上 $\frac{1}{i}$，如果 $k<sum$，立即退出循环并输出答案。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
int k,i; 
double sum;
int main(){
	cin>>k;
    for(i = 1;sum<=k;i++) sum+=1.0/i;
    cout<<i-1;
    return 0;
}
```

---

## 作者：ryf2011 (赞：2)

# 题目思路
由于数据范围较小，我们考虑暴力的做法。

我们考虑从 $1$ 开始从小到大枚举 $n$ 并让答案 $S$ 加上 $\frac{1}{n}$。在下一次计算之前，判断 $S$ 是否大于 $k$，如果成立，那么退出循环，输出答案，否则继续计算。

注意，为了使答案更加准确，计算时可以使用浮点类型存储 $S$。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int k,nown;
double s;
int main(){
	scanf("%d",&k); //输入
	while(s<=k){ //注意题目要求 s>k
		nown++; //根据题意可知
		s+=1.0/nown; //根据题意可知，细节：为了保证结果准确性，将 nown 强制转换为浮点型计算
	}
	printf("%d\n",nown); //输出
    return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：eggy__party (赞：1)

一眼望去，$k\le15$，这意味着我们能通过暴力的方法过了这题。

## 思路
考虑用循环结构，我们可以枚举 $n$，用一个变量 $x$ 来统计当前的和是多少。当发现 $x>k$ 时，就符合要求了。此时结束掉循环，输出当前的 $n$。
### 一些注意事项
$x$ 一定要用浮点类型！
## code
```
#include<bits/stdc++.h>
using namespace std;
int main() {
    int k;
    double x=0;
    cin>>k;
    for(int n=1;;n++){
    	x+=1.0/n;//这里不能用1，不然自动识别成整数类型
		if(x>k){
    		cout<<n;//输出符合条件的n
    		break;
		}
	}
    return 0;
}
```

---

## 作者：Chbin (赞：0)

### 题意
输入 $1$ 个数，按照原题式子进行计算，当和大于输入数时，输出当时的加数个数。
### 思路
这题并不复杂，只需要按题意进行模拟，当和大于输入的正整数 $k$ 时，输出加数个数即可。
### 注意
找到结果后记得要加 `break`，否则就会 TLE。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,i=1;
double s=0;
int main(){
    cin>>k;
    for(;;i++)
    {
        s+=1.0/i;
        if(s>k) break; 
    }
    cout<<i;
    return 0;
}
```

---


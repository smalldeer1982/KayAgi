# [NOIP 2011 普及组] 数字反转

## 题目描述

给定一个整数 $N$，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例 2）。


## 说明/提示

**【数据范围】**

$-1,000,000,000\leq N\leq 1,000,000,000 $。

noip2011 普及组第一题


## 样例 #1

### 输入

```
123```

### 输出

```
321```

## 样例 #2

### 输入

```
-380```

### 输出

```
-83```

# 题解

## 作者：周羿轩 (赞：2610)

#### 这题。。。。。。那么难吗？**[真心的问号][认真严肃脸]**
这题真的太水了，几行代码了事ψ(*｀ー´)ψ

说实在的，我就给几种解法吧，有长有短，自己看哪种适合自己

## 一、死套“暴力”
此暴力非彼暴力哈，就是用数组把数分解了，倒着组合（当年我的做法）

```cpp
#include<bits/stdc++.h>//头文件
using namespace std;//cin，cout必备的
long long s[11]={},n,k=0,a=1;//数组s,n和转换后的k,再加一个a,作用后面讲
int main()//主程序
{
	memset(s,0,sizeof(n));//清零
	cin>>n;//输入不解释
    for(int i=1;i<=10;i++) s[i]=n/a%10,a*=10;//求出位数后存入数组，具体的就不说了
    a=1000000000;//初始化
    for(int i=1;i<=10;i++) k+=s[i]*a,a/=10;//存入k
    while(k%10==0) k/=10;//倒着看，最后有0就除掉
    cout<<k;//输出不解释
    return 0;//好习惯棒棒哒[恶心][恶心][呕吐][呕吐]
}
```

## 二、简短操作
够简短，不用弄数据，直接操作，抛数位再补回去，具体的就看你造化了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s=0;
int main()//以上应该都懂，不解释
{
    cin>>n;//烦死了输入
    while(n) s=s*10+n%10,n/=10;//如果n不是0，就一直s让一位，腾个0出来，n最后一位跟上去，再无情地抛弃了最后一位（突然想对n说：你无情你冷酷你无理取闹！）
    cout<<s;//烦死了输出
    return 0;
}
```

## 三、极简
真的很极简了，就7行，自己看吧。。。。。。（画外音：突然发现楼主只喜欢用六个句号。。。。。。）
```cpp
#include <bits/stdc++.h>
using namespace std;
int n=0,s=0;//定义与归0 
int main(){
	for(cin>>n;n!=0;n/=10)s=s*10+n%10;//同上一种的套路，暴力直接循环搞 
    cout<<numb;return 0;//输出,0会没掉的（自己去试） 
} 
```

## 四、字符串
由于有坑（负数〇），所以用字符串。。。。。。（又来了）就这样吧
```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int main()//不解释
{
    cin>>s1;
    if(s1[0]=='-')
    {
        cout<<"-";//输出负号
        for(int i=s1.length()-1,j=0;i>=1;i--,j++) s2=s2+s1[i];//倒着变成正的（好烦）
        if(s2[0]=='0') s2.erase(0,s2.find_first_not_of('0'));//去0
        cout<<s2;//输出
    }
    else //否则为正
    {
        for(int i=s1.length()-1,j=0;i>=0;i--,j++) s2=s2+s1[i];//正着倒序（还是好烦吧）
        if(s2[0]=='0')s2.erase(0,s2.find_first_not_of('0'));//删除0
        cout<<s2;//输出
    }
    return 0;//终于结束了
}
```
## 五、P党福利
我不是P党的，但是呢由于P党的人摆在那里，还是给写一个吧。

```php
var s,t:string; n,i:longint;
begin
  read(n);
  if n>=0 then str(n,s) else str(-n,s);//判断负数，真变为正数字符串
  for i:=1 to length(s) do t:=s[i]+t;//反转
  while t[1]='0' do delete(t,1,1);//删0
  if n>=0 then write(t) else write('-',t);//负数加负号
end.//结束
```

## 六、java来一个！
对，我再来一个java的！
```java
public static void main(String[] args) throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        // 将数据存入
        StringBuffer sb=new StringBuffer(br.readLine().trim());
        sb.reverse();   // 反转
        //负号跑到最后
        if(sb.charAt(sb.length()-1)=='-'){
            // 删除负号并且在头插入负号
            sb.delete(sb.length()-1, sb.length());
            sb.insert(0, '-');

        }
        System.out.println(Integer.parseInt(sb.toString()));
    }
```
## 七、栈
注意了最后要转整数呢
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[100001];
int t=0;
int main()
{
    string b,c;
    bool sign=false,flag=false;
    cin>>c;
    for(int i=0;i<=c.length();i++)
    {
        if(c[i]=='-') s=true;
        else a[++t]=c[i];
    }    
    if(s==true)    b+="-";
    t--;
    for(t;t>=0;t--)
    {
        if(a[t]!='0'&&f==false) f=true,b+=a[top];    
        else if(f==true) b+=a[t];
    }
    int i=atoi(b.c_str());
    cout<<i;
    return 0;    
}//用栈的呢应该都懂吧，不需要解释了吧
```
## 八、最后来一下最简（fu）单（za）的一种了
其实很简单，不注释了，看懂就行（如果你有耐心看完的话）[奸笑][贱笑]
```cpp
#include<iostream>
    using namespace std;
    int main(){
        long long i,n,m=0,s1=0,s2=0,s3=0,s4=0,s5=0,s6=0,s7=0,s8=0,s9=0;//s1到s9代表数字的每一位。（最大是九位嘛）
        cin>>i;
        if(i<0){
            n=0-i;}
        else{
            n=i;}
        if(n>=1){
            s1=n%10;}
        if(n>=10){
            s2=n%100/10;}
        if(n>=100){
            s3=n%1000/100;}
        if(n>=1000){
            s4=n%10000/1000;}
        if(n>=10000){
            s5=n%100000/10000;}
        if(n>=100000){
            s6=n%1000000/100000;}
        if(n>=1000000){
            s7=n%10000000/1000000;}
        if(n>=10000000){
            s8=n%100000000/10000000;}
        if(n>=100000000){
            s9=n%1000000000/100000000;}
        if(s9==0){
            if(s8==0){
                if(s7==0){
                    if(s6==0){
                        if(s5==0){
                            if(s4==0){
                                if(s3==0){
                                    if(s2==0){
                                        if(s1==0){
                                            if(i<0){
                                                m=0-m;}
                                            cout<<m;
                                            return 0;}
                                        m=s1;
                                        if(i<0){
                                            m=0-m;}
                                        cout<<m;
                                        return 0;}
                                    m=s1*10+s2;
                                    if(i<0){
                                        m=0-m;}
                                    cout<<m;
                                    return 0;}
                                m=s1*100+s2*10+s3;
                                if(i<0){
                                    m=0-m;}
                                cout<<m;
                                return 0;}
                            m=s1*1000+s2*100+s3*10+s4;
                            if(i<0){
                                m=0-m;}
                            cout<<m;
                            return 0;}
                        m=s1*10000+s2*1000+s3*100+s4*10+s5;
                        if(i<0){
                            m=0-m;}
                        cout<<m;
                        return 0;}
                    m=s1*100000+s2*10000+s3*1000+s4*100+s5*10+s6;
                    if(i<0){
                        m=0-m;}
                    cout<<m;
                    return 0;}
                m=s1*1000000+s2*100000+s3*10000+s4*1000+s5*100+s6*10+s7;
                if(i<0){
                    m=0-m;}
                cout<<m;
                return 0;}
            m=s1*10000000+s2*1000000+s3*100000+s4*10000+s5*1000+s6*100+s7*10+s8;
            if(i<0){
                m=0-m;}
            cout<<m;
            return 0;}
        else{
            m=s1*100000000+s2*10000000+s3*1000000+s4*100000+s5*10000+s6*1000+s7*100+s8*10+s9;
            if(i<0){
                m=0-m;}
            cout<<m;}
        return 0;
}
```
好了可能有一些长（列了这么多），但应该有一种是你喜欢的。顺便说一下，本人还只是一个小~~蒟蒻~~，dalao们呢不喜勿喷吧，希望多多支持我！谢谢！

---

## 作者：瑞星 (赞：311)

最容易理解的代码...

代码如下

```cpp
#include<iostream>
using namespace std;
int main()
{
  int n;  cin>>n;   //反转之前的数
  if(n<0) {cout<<"-";n=-n;}  //不管正负数，都转成正数方便操作。如果是负数，先输出一个"-"
  if(n%10==0) {n=n/10;}  //如果一个数的最后一位为0，去掉不看
  int sum=0;    //反转之后的数
  while(n!=0)
  {
        int k=n%10;
    sum=sum*10+k;   //sum*10+k的意思是在原数sum的基础上拓展一个个位并存储k（有点像栈的操作）
    n=n/10;   //去掉一位
  }
  cout<<sum<<endl;
  return 0;
}
```

---

## 作者：stone_juice石汁 (赞：160)

## 挑战目前最短题解！！！

看了一下题解，2楼的DALAO方法和我基本相同，但是我感觉很多OIer都没看懂，所以特别来补充一下。

**因此这片题解会写的比较长，但是会写得比较易懂**

而且这种解法的代码量极短...

~~其实我是冲着最短题解来的~~


------------
**做这道题需要灵活的运用两个运算符： / 和 %**

如果有OIer不熟悉这两个运算符运用可以点我的[这篇题解](https://www.luogu.org/blog/stonejuice/solution-p1554)。里面还是比较详细的解释了这两个运算符的用法的。


------------

其实思路还是非常好懂的。

我们举个栗子

如果我们要反转numa=2145这个数

那我们取个位5丢进numb **（运用运算符 % ）** ，然后再把5扔掉 **（运用运算符 / ）** ,numa变为214。

然后将numb的数进位，变为50，再把numa的个位4扔进numb,然后丢掉4。此时numb变为54，numa变为21。

**重复上述过程，当numa=0时，无数可取，停止循环。**

画个表就是酱紫

numa----numb

2145----0

214-----5

21------54

2-------541

0-------5412

**这样看就很好懂了吧QWQ（自认为）**

当然可能还有人有一些问题：

- Q:反转的数不是有负数吗，怎么会AC呢？
- A:因为处理的时候使用的是乘除和模这三个运算符啊，这些运算符不会改变数的正负，所以反转后还是负的！

- Q:怎么处理前导0？
- A:反转后就自动处理前导0了！因为程序会自动处理！（就像你反转130，你写的肯定不会是013，程序也是一个道理）

**先贴一个不压行方便各位学习的代码：**

```
#include <iostream>
using namespace std;
int numa,numb;//全局变量自动赋值为0 
int main()
{
	cin>>numa;  
	while(numa!=0)
	{
		numb=numb*10+numa%10;
		numa/=10; 
	}
    //将numb原来的数进位，将numa最后一位+进numb,再丢掉此数。当numa为0时停止  
    cout<<numb;//输出，反转后0会被自动处理 
    return 0; 
} 
```


**再贴一个最短代码！！！**（重点？）


```
#include <iostream>
int numa=0,int numb=0;
int main(){
    for(std::cin>>numa;numa!=0;numa/=10)numb=numb*10+numa%10;
    std::cout<<numb;
} 
```


------------
## 修改日志：
- 19-3-10 接受了某位DALAO的意见，**省去了using namespace std，改为用std::cin与std::cout**，并且将变量开进了main()中。



---

## 作者：一个LeSe (赞：37)

## 貌似可能好像没有用stack的
## 我就来抢占先机（滑稽）


------------
 先科普一下stack：
 
 stack是STL中的一个数据类型，准确来说它就是栈，需要用到#include <stack>；
  
  定义就像这样stack<类型> 名称

  如：
  ```cpp
stack <int> stkInt;//一个存放int的stack容器。
  stack <float> stkFloat;//一个存放float的stack容器。
  stack <string> stkString;//一个存放string的stack容器。
```


------------
### stack中的我用到的主要几个函数
  1. stack.push();   //往栈头添加元素
  1. stack.pop();   //从栈头移除第一个元素
  1. stack.top();           //返回最后一个压入栈元素
  1. stack.empty();   //判断堆栈是否为空
  1. stack.size();             //返回堆栈的大小
 
------------
接下来就是题目了，这个题目很简单，只要跟着思路走就行
  
  代码如下：

------------

  

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
stack<char> p;//定义stack
int main()
{
	char c;
	while(cin>>c)
	{
		if(c=='-')printf("-");//判断正负，如果是负就直接输出，不压栈
		else p.push(c);//否则压进栈里
	}
	while(p.top()=='0')//删除前导0
	p.pop();
	while(!p.empty())//最后输出反转数
	{
		printf("%c",p.top());
		p.pop();
	}
	return 0;//完美结尾
}
```


---

## 作者：pra_spe (赞：16)

这个题有好几个坑：

1.首先要记得还有负数；

2.要删去数字前的“0”，因为“085”这个数显然不符要求；

3.最重要的坑就是删除“0”时要注意：比如“4020”，不要把“4”和“2”之间的“0”删去。

两份代码，一份是用字符串的，另一份是数组的。


数组：






    


```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<string>
using namespace std;
int a , ans[15];
int y = 0 ;
int main()
{
    cin>> a;
    if(a < 0)
    {
        a = 0 - a;
        cout<< "-";
    }
    int z = 1 , i = 1 ;
    while(z != 0)
    {
        ans[i] = a % 10;
        a = a / 10;
        i ++;
        if(a < 10) 
        {
            ans[i] = a;
            z = 0;
        }
    }
    for(int j = 1 ; j <= i ; j ++)
    {
        //cout<< " " << ans[j] ;
        if(ans[j] > 0)
        {
            y = 1 ;
        }
        if(y != 0)
        {
            cout<<  ans[j] ;
        }
    }
    return 0;
}
```
字符串：
```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<string>
using namespace std;
string s1 , s2;
int main()
{
    cin>> s1;
    if(s1[0] == '-')
    {
        cout<< "-" ;
        for(int i = s1.length() - 1 , j = 0; i >= 1 ; i -- , j ++)
        {
            s2 = s2 + s1[i];
        }
        if(s2[0] == '0')
        {
            s2.erase(0 , s2.find_first_not_of('0'));
        }
        cout << s2;
    }
    else {
        for(int i = s1.length() - 1 , j = 0; i >= 0 ; i -- , j ++)
        {
            s2 = s2 + s1[i];
        }
        if(s2[0] == '0')
        {
            s2.erase(0 , s2.find_first_not_of('0'));//删除“0”
        }
        cout << s2;
    }
    return 0;
}

```

---

## 作者：Wallacewwz (赞：6)

# [NOIP2011 普及组] 数字反转 题解

## 题目大意

给定一个整数 $N$，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零。

## 解题思路

### 思路概述：

本题要求将输入的整数进行数字反转，反转后的数字必须满足整数的常见格式，即不能有前导零。

1. 如果输入数是负数，反转后依然保留负号。
2. 如果输入数是正数，则直接反转数字。


### 详细步骤：

1. **负数判断**：
   - 如果输入的数字是负数，我们先记录下这个信息（`flag`），然后处理绝对值部分。
   - 最后，再将负号加回。

2. **字符串处理**：
   - 将输入的数字转化为字符串 `s`，然后从字符串的最后一位开始，逐位反转数字。
   
3. **反转数字**：
   - 通过逐位构造反转后的数，累加到 `ans` 中。

4. **去除前导零**：
   - 由于我们是从字符串的末尾向前处理，每次遇到一个非零的数字时，会自动去除反转后的前导零。

### 代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;           // 输入的数字字符串
long long ans = 0;  // 存储反转后的数字
int flag = 0;       // 标记负数

int main() {
    cin >> s;          // 读取输入
    int k = s.length() - 1;  // 计算字符串的最后一个字符下标

    // 如果是负数，处理负号并标记
    if (s[0] == '-') {
        flag = 1;
        cout << '-';  // 输出负号
    }

    // 从字符串的最后一位开始，逐位构造反转后的数字
    for (int i = k; i >= flag; i--) {
        ans *= 10;                  // 每次将当前结果乘以10，腾出个位
        ans += (s[i] - '0');        // 加上当前位的数字
    }

    cout << ans << '\n';  // 输出反转后的数字
    return 0;
}

---


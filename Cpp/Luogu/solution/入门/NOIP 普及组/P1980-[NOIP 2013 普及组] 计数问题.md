# [NOIP 2013 普及组] 计数问题

## 题目背景

NOIP2013 普及组 T1

## 题目描述

试计算在区间 $1$ 到 $n$ 的所有整数中，数字 $x$（$0\le x\le9$）共出现了多少次？例如，在 $1$ 到 $11$ 中，即在 $1,2,3,4,5,6,7,8,9,10,11$ 中，数字 $1$ 出现了 $4$ 次。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le x \le 9$。


## 样例 #1

### 输入

```
11 1```

### 输出

```
4```

# 题解

## 作者：Autracker (赞：1422)

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n,i,x,b,c,t=0;
    cin>>n>>x;//输入范围与要查的数字；
    for(i=1;i<=n;i++)//一到n进行循环；
    {
        b=i;//为了不改变i的值，就把i赋值给一个数；
        while(b!=0)//如果b不等于0，继续循环；
        {
            c=b%10;//求是否是x，是的话计数器加一；
            b=b/10;//求下一个数字是否为x；
            if(c==x) t++;计数器加一；
        }
    }
    cout<<t<<endl;//输出计数器的数字；
    return 0;//结束
}
```

---

## 作者：John_Nash (赞：541)

这题是noip2013普及组第一题，难度肯定不大，nlog10n的算法不难想出，这里不再说明。

在真正的比赛中，只要想到能ac的算法就可以，但是在练习中还是要锻炼自己的思维，多想想更优的算法。

不难发现，即使不用计算机，答案也很容易求出，如：

n=728，x=7

可以按照这样的思路：

个位7:73个 7,17,...,727

十位7:70个 70~79,170~179,...,670~679

百位7:29个 700~728

答案是172

这样，就不难写出log10n的算法，这是一个巨大的改进！

```cpp

#include<iostream>
#include<cstdio>
using namespace std;
int main(){
    int n,x,m=1,ans=0;
    scanf("%d%d",&n,&x);
    while(m<=n){
        int a=n/(m*10),b=n/m%10,c=n%m; //a,b,c为n的三部分，求哪一位x的个数，b就为那一位数，a为b左边的数，c为b右边的数，如求1~728中十位7的个数，则a=7，b=2，c=8
        if(x){
            if(b>x) ans+=(a+1)*m; //如果b>x，说明有(a+1)*m个x（如求1~728中个位7的个数，则为（72+1）*1=73）
            if(b==x) ans+=a*m+c+1; //如果b=x，说明有a*m+c+1个x（如求1~728中百位7的个数，则为0*100+28+1=29）
            if(b<x) ans+=a*m; //如果b<x，说明有a*m个x（如求1~728中十位7的个数，则为7*10个）
        }
        else{ //x=0的情况和x！=0的情况有所不同
            if(b) ans+=a*m;
            else ans+=(a-1)*m+c+1;
        }
        m*=10;
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：凛凛LinLin (赞：328)

## 纯暴力 纯STL
看到一些题解都用上sprintf和stringstream了，~~怎么不干脆再暴力一点呢~~

------------
c++里这么多string库函数，还有各种算法支持，很多时候用字符串常常能带来意想不到的效果。例如本题，就可以使用字符串的方法。

我的思路是把数值都转为字符串，存到一个字符串里，然后就可以进行各种花式操作

在这里先给大家介绍数值与字符串相互转换的几种方法

先从简单的开始

string to_string (int val);

string to_string (double val);

这是C++11新增的库函数，已重载各种标准类型，用法很简单，例如 string s = to_string(123);

但是对于大量数据只能一个数一个数转换，颇为繁琐

还有一种方法就是 stringstream (使用stringstream 需包含头文件 <sstream>）
 
int a = 123, b = 456, c = 789;
  
stringstream ss;
  
ss << a << b << c;

以上几行把a b c三个变量读入字符串流中，这样就可以把a b c三个变量无缝衔接起来，但是需要注意的是，stringstream型不能直接输出，也不支持迭代器，需要利用stringstream类的成员函数str()才能把它当成普通字符串来用，例如
  
string s = ss.str();
  
而把字符串转为数值的话也是用stringstream，例如上面的ss就可以转换为一个int型
  
int i;
  
ss >> i;
  
以上都是C++的方法，c语言有sprintf和sscanf，对应stringstream字符串流的读和写，<stdlib.h>中还有数值与字符串相互转换的iota和atoi函数，感兴趣的可以自己去了解。用c语言的sprintf比C++的字符串流效率高，但是我还是想用C++的字符串，为啥？因为C++字符串的可拓展性和灵活性比较高嘛hhhh
  

------------

嗯姆，接下来再讲一个算法库的函数，位于 <algorithm> 头文件中
  
count(ivec.begin() , ivec.end() , searchValue)
  
这个函数作用是统计在一定范围内某一值出现的次数
  
前两个参数为起始位置和结束位置，都是迭代器，第三个参数为需要统计的值
  
还有一个count_if函数更加强大，感兴趣的可以自己去了解
  
接下来放上本题我的AC代码，带大家见识一下stringstream和algorithm能擦出怎样的火花！


------------


```cpp
#include <bits/stdc++.h>
using namespace std;
  
int main() {
   int n, x;
   cin >> n >> x;
   stringstream ss;
   for (n++; --n; ss << n);     //把1-n的值都存放到字符串流中
   string s = ss.str();
   cout << count(s.begin(), s.end(), x + '0') << endl;    //运用count函数直接出结果，简简单单
   return 0;
}

```

---

## 作者：DarkPaL (赞：111)

c++字符串处理不如Pascal直观。。。所以直接判断就好，也没必要对每个i递归。

```cpp

#include <iostream>
using namespace std;

int n,x,sum=0;

int main()
{
    cin >>n>>x;
    for (int i=1;i<=n;++i) {
        if (i>=1000000 && i/1000000==x) sum++;
        if (i>=100000 && i/100000 %10==x) sum++;
        if (i>=10000 && i/10000 %10==x) sum++;
        if (i>=1000 && i/1000 %10==x) sum++;
        if (i>=100 && i/100 %10==x) sum++;
        if (i>=10 && i/10 %10==x) sum++;
        if (i%10==x) sum++; 
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：dakeboy (赞：93)

python简直就是作弊啊
```python
n,x=input().split(" ")
n=int(n)
l=[]
for i in range(1,n+1):
    l.extend(list(str(i)))
print(l.count(x))
```
秒过的感觉
其他语言都不会写了

---

## 作者：醉梦未苏 (赞：28)

看了楼下大佬的题解，发现没有人用`snprintf`，故发了这篇蒟蒻题解

#### **`snprintf` **传入四个参数
1. 要写入的字符数组 
2. 数组大小(一般用sizeof(ch)
3. 要转的数的格式（和`printf()`类似)
4. 要转的数

###### 该函数常用来*快捷的* 将数转存于字符数组中，方便好用

再将数转为字符数组后，一位一位的判就**AK**了

```
#include<bits/stdc++.h> //万能头文件
#define ll long long //宏替换，将来方便
using namespace std;
//int 似乎会爆 (逃)
ll n,tot=0;
ll x;
int zh(ll a)
{
	//以字符数组形式存储一个数
    char ch[10];
    memset(ch,'0',sizeof(ch));
    //将%lld形式的a自动写入字符数组
    snprintf(ch,sizeof(ch),"%lld",a);
    ll sum=0;
    //统计符合的个数
    for(int i=0;i<strlen(ch);i++)
    if(ch[i]==x+'0') sum++;
    return sum;
}

int main()
{
	//输入
	cin>>n>>x;
    for(int i=1;i<=n;i++)
	{
    	//总个数加上当前数i中x的数量
	    tot+=zh(i);
	}
    //输出
	cout<<tot;
	return 0;
}

```

> ~~求过~~

---

## 作者：为人民服务 (赞：22)

这个题，一眼看上去——不是那么简单。。。

emmm，这是一个数位DP。

很像 √ P2602 [ZJOI2010]数字计数 。

那我们来分析下。

0~b的答案0-1的答案：

如何计算0~b的答案？

	分类
		1.位数比b小的	很明显每个数码f[i]=f[i-1]*10+10^(i-1);（不考虑前导零）
		2.枚举从高到低位 第一个比b小的位（同1）
		3.最后别忘了统计b
		4.一定要注意前导零。
        
**Code**
```cpp
#include <cstdio>
#define LL long long
#define Maxn 120
using namespace std;
LL a,b,dight,sta[Maxn],stb[Maxn],num[Maxn],f[Maxn],powof[Maxn];
inline LL read () {
	LL X=0,w=1;char ch=0;
	while(ch<'0'||ch>'9')       { if(ch=='-')	w=-1;ch=getchar(); }
	while(ch>='0'&&ch<='9')     { X=(X<<3)+(X<<1)+ch-'0';ch=getchar(); }
	return X*w;
}
inline void Get (LL x,LL *st) {
	if(x==0)    return ;
	LL top=0,res=x;
	while(x)    num[++top]=x%10,x/=10;
	for(LL i=1;i<top;i++) {
		st[0]+=f[i-1]*9;
		for(LL j=1;j<10;j++)
			st[j]+=f[i-1]*9+powof[i-1];
	}
	res-=num[top]*powof[top-1];
	for(LL i=1;i<num[top];i++)     st[i]+=powof[top-1];
	for(LL i=0;i<10;i++)           st[i]+=f[top-1]*(num[top]-1);
	st[num[top]]+=res+1;
	for(LL i=top-1;i;i--) {
		res-=num[i]*powof[i-1];
		for(LL j=0;j<num[i];j++)   st[j]+=powof[i-1];
		for(LL j=0;j<10;j++)       st[j]+=f[i-1]*num[i];
		st[num[i]]+=res+1;
	}
}
int main () {
	a=1;b=read();dight=read();
	powof[0]=1;
	for(LL i=1;i<15;i++)
		powof[i]=powof[i-1]*10;
	for(LL i=1;i<15;i++)
		f[i]=f[i-1]*10+powof[i-1];
	Get(a-1,sta);Get(b,stb);
	printf("%lld ",stb[dight]-sta[dight]);
	return 0;
}
```

---

## 作者：GSQ0829 (赞：14)

### 思路：
和数字统计那题一样。

直接暴力循环就可以了。对于每个数，循环取出该数的各个位数是否为 $x$ 即可。

---
### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

int main () {
	long long n, x, a, f = 0;
	cin >> n >> x;
	for (int i = 1; i <= n; i++) {
		a = i;
		while (a) {
			if (a % 10 == x) f++;
			a /= 10;
		}
	}
	cout << f << endl;
	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：8)

很简单的题：枚举 $1$ 到 $n$ 之间的数字，拆分每个数字的位数，判断每一位是否为 $x$ 就行了。

完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x,ans;
int main() {
  cin>>n>>x;
  for(int i=1;i<=n;i++)
  {
    int id=i;
    while(id)ans+=(id%10==x),id/=10;
  }cout<<ans;
  return 0;
}
```

---

## 作者：niuniudundun (赞：7)

# 题目大意

计算在 $[1,n]$ 的所有整数中，数字 $x(0\le x\le9)$ 共出现了多少次？

# 解法

标准的数位分解。

对于一个正整数 $a$，当 $a \bmod 10$ 即可以取到最末尾的数值，$\left \lfloor a {\div} 10 \right \rfloor$ 就是 $a$ 删去最末尾的数值，重复过程就对 $a$ 取出了每位的数值，这就是数位分解的基本思想。

如果发现正在数位分解的数字中数位有 $x$，则计数器就加一。

写成代码就是这样：

```cpp
int count_(int a){
	int sum=0;//计数器
	while(a!=0){
		if(a%10==x){
			sum++;
		}
		a=a/10;
	}
	return sum;
}
```

因为要求 $[1,n]$，所以直接遍历 $[1,n]$。

代码：

复杂度：$O(n \log_{10} n)$。

```cpp
#include<iostream>
using namespace std;
int n,x,ans=0;
int count_(int a){
	int sum=0;
	while(a!=0){
		if(a%10==x){
			sum++;
		}
		a=a/10;
	}
	return sum;
}
int main(){
	cin>>n>>x;
	for(int i=1;i<=n;i++){
		ans+=count_(i);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：sea_bird (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1980)。

# 思路

按题目所讲，那些数位数不大，于是对每个数一位位进行判断，是目标的数时累加，累加的结果就是出现次数的总数，也就是答案。

题目标签提到了字符串，那么可以用循环来处理每一位数，接着存入到字符数组中，最后遍历字符数组就行了。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n,x,cnt=0;
	cin>>n>>x;
	for(int i=1;i<=n;i++){//按位处理 
		if(i%10==x){//个位
			cnt++;
		}
		if(i/10>0&&i/10%10==x){//十位
			cnt++;
		}
		if(i/100>0&&i/100%10==x){//百位
			
			cnt+=1;
		}
		if(i/1000>0&&i/1000%10==x){//千位
			cnt++;
		}
		if(i/10000>0&&i/10000%10==x){//万位
			cnt++;
		}
		if(i/100000>0&&i/100000%10==x){//十万位
			cnt++;
		}
		if(i/1000000>0&&i/1000000%10==x){//百万位
			cnt++;
		}
	}
	cout<<cnt;//输出累加结果
	return 0;
}
```

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[10000005];//添加了字符数组
int main(){
	long long n,x,cnt=0,ans=0;
	cin>>n>>x;
	for(long long i=1;i<=n;i++){//按位处理
		int y=i;
		while(y>0){//也是按位处理
			ch[++cnt]=y%10;
			y/=10;
		}
	}
	for(long long i=1;i<=cnt;i++){
		if(ch[i]+'0'-'0'==x){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：kuaiCreator (赞：1)

## 解题思路
对于十进制数，取模 $10$ 可获得当前数的个位，整除 $10$ 可去掉当前数的个位，要获取当前数的每一位可以循环取个位，去个位，直到这个数被拆分为 $0$。因此观察数据范围后只需要枚举区间 $[1,n]$ 内的所有数进行拆分并统计 $x$ 的个数即可，时间复杂度为 $O(n\log n)$。

如果数据范围很大，这样做会超时，可以学习数位动态规划解决本题。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int m, x, ans = 0;
	cin >> m >> x;
	for (int i = 1; i <= m; i++) {	//枚举区间[1,m]的数
		int n = i;	//避免i变成0造成死循环备份i的值
		while (n) {
			if (n % 10 == x) ans++;	//个位为x累加答案
			n /= 10;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

直接暴力循环即可。对于每个数，循环取出该数的个位并判断是否为 $x$ 即可。因为每个数最多六位所以可以通过。

```cpp
#include<bits/stdc++.h> 
using namespace std; 

int main(){
	int n,x;
	cin>>n>>x;
	int sum=0;
	for(int i=1; i<=n; i++){
		int k=i;
		while(k>0){
			if(k%10==x){
				sum++;
			}
			k/=10;
		}
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：LotleTos (赞：0)

## 思路
- 枚举 $1$ 到 $n$ 之间的每一个数。
- 对于每个数，不断判断它的个位是否为 $x$，再把它向右移一位，直到它为 $0$。
- 变量是 `int`类型，所以数的个位是它 `%10`，右移是 `/10`。
- 注意：判断每个数字时要先把它复制一遍，不然会变成  $0$，不方便循环。
## 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int main(){
	int x,n,sum=0,j;
	cin>>n>>x;
	for(int i=1;i<=n;i++){
		j=i;
		while(j>0){
			if(j%10==x){
				sum++;
			}
			j/=10;
		}
	}
	cout<<sum;
}
```

---

## 作者：GeYang (赞：0)

# 题意

求一个区间内某个数出现的次数。

# 思路

先循环一遍，用一个新变量代替循环时的变量，再把这个新变量的每一位都拿去和 $x$ 对比，统计数量即可。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,x,ans;
int main()
{
	cin>>n>>x;
	for(int i=1;i<=n;i++)
	{
		ll idkwhyiwritethis=i;
		while(idkwhyiwritethis)
		{
			if(idkwhyiwritethis%10==x) ans++;
			idkwhyiwritethis/=10;
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：GoldenSTEVE7 (赞：0)

## 题意
真的没啥好说了。就是统计一个数中，有多少个给定的数码。

## 思路
直接暴力即可。每次将原数的个位提取出来，判断其是否与给定数码相同即可。由于 $1 \le n \le 10^6$，故最多进行 $6$ 次循环，不会超时。

## 代码

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    int sum = 0;
    for(int i = 1; i <= a; i++) {
    	int x = i;
    	int t = x;
    	while(t > 0) {
    	    if(t % 10 == b) sum++;
    	    t /= 10;
    	}
    }
    cout << sum;
    return 0;
}
```

---

## 作者：MCxiaokang (赞：0)

## 题目描述

试计算在区间 $1$ 到 $n$ 的所有整数中，数字 $x$ 出现的次数。

## 解题思路

通过样例，一个整数中出现多次 $x$，都计算在总次数中。

如何计算整数中 $x$ 出现的次数呢？可以发现，对整数 $t$ 来说，$t \mod 10$ 可以取其个位，$t \gets\left\lfloor\frac{t}{10}\right\rfloor$ 可以舍弃其个位：因为 $\frac{t}{10}$ **将个位移动到十分位上，将十位移动到个位上**……再向下取整，就只剩下原来的十位及更高位。

当然，在 C++ 中，使用整型除法就可以直接实现这个效果了。

整体时间复杂度 $O(n \log n)$，可以通过此题。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,x,ans;

int check(int k,int x) //整数k中x的个数
{
	int num=0; //用于记录x出现次数
	while (k) //当 k=0 时终止循环
	{
		if (k%10==x) num++; //取个位并检查
		k/=10; //舍弃个位
	}
	return num;
}

int main()
{
	cin>>n>>x;
	for (int i=1;i<=n;i++) //循环求解
	{
		ans+=check(i,x);
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：Wallacewwz (赞：0)

# [NOIP2013 普及组] 计数问题 题解

## 题目大意

给定一个整数区间 $1$ 到 $n$，我们需要计算数字 $x$（$0 \leq x \leq 9$）在区间内所有整数中共出现了多少次。例如，在区间 $[1, 11]$ 中，数字 $1$ 出现了 $4$ 次，分别出现在 $1, 10, 11$ 中。

## 解题思路

本题的目标是计算数字 $x$ 出现在 $1$ 到 $n$ 区间内所有整数中的总次数。可以通过以下步骤来解决：

1. **逐一检查每个数字**：对于每一个数字 $i$ 从 $1$ 到 $n$，我们将其转换为字符串，并检查每个字符是否等于给定的数字 $x$。如果是，则计数加一。

2. **使用整数取余和整除**：为了高效计算每个数字中数字 $x$ 的出现次数，我们可以通过取余和整除的方式逐个获取数字的各位数字，并判断是否等于 $x$。这可以避免字符串转换带来的额外开销。

3. **累加结果**：在遍历完所有数字后，我们将得到数字 $x$ 出现的总次数。

### 复杂度分析
对于 $n$ 最大为 $10^6$ 的情况，这种方法是可行的，且可以在合理时间内完成。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, ans;

// 计算数字num中数字k的出现次数
void calc(int num)
{
    while(num)
    {
        if((num % 10) == k) ans++;  // 如果当前位等于k，则计数加一
        num /= 10;  // 去掉当前位
    }
}

signed main()
{
    cin >> n >> k;  // 输入n和k
    for(int i = 1; i <= n; i++)  // 遍历区间[1, n]
        calc(i);  // 计算每个数中数字k出现的次数
    cout << ans << '\n';  // 输出结果
    return 0;
}

---


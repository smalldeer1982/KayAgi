# [NOIP 2015 普及组] 扫雷游戏

## 题目背景

NOIP2015 普及组 T2

## 题目描述

扫雷游戏是一款十分经典的单机小游戏。在 $n$ 行 $m$ 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出 $n$ 行 $m$ 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。


## 说明/提示

对于 $100\%$的数据，$1≤n≤100, 1≤m≤100$。


## 样例 #1

### 输入

```
3 3
*??
???
?*?
```

### 输出

```
*10
221
1*1```

## 样例 #2

### 输入

```
2 3
?*?
*??```

### 输出

```
2*1
*21```

# 题解

## 作者：Dying_Light (赞：57)

蒟蒻第一篇题解跪求过~~~~~~

这个题目有一些注意的地方：

1.方向是八联通，可以用这种双重循环实现

for(int dy=-1;dy<=1;dy++){

        for(int dx=-1;dx<=1;dx++){

                int nx=dx+x,ny=dy+y;

2.必须注意不越界，这在双重循环中进行判断

3.只搜索是空的地方


这道题用循环遍历所有的点，并在这些所有的点上进行深搜，搜索附近八个方向上有没有雷，如果有自身+1；


#######-----分割线-----#######

下面附上代码：

```cpp
#include<iostream>
using namespace std;
int n,m;
char juzhen[101][101];//需要用字符类型 
void dfs(int y,int x){//需要返回空类型，定义void函数 
    if(juzhen[y][x]=='0'){
        for(int dy=-1;dy<=1;dy++){
            for(int dx=-1;dx<=1;dx++){
                int nx=dx+x,ny=dy+y;
                if(0<=ny&&ny<n&&0<=nx&&nx<m&&juzhen[ny][nx]=='*')//八连通循环 ，且必须不越界
                juzhen[y][x]+=1;//如果是雷的话将那一个点加1 
            }
        }
    }
    return;//将那个点加完之后就返回继续找下一个点 
} 
int main(){
    cin>>n>>m;//不必多说 
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
            cin>>juzhen[i][j];//循环输入 
            if(juzhen[i][j]=='?')
            juzhen[i][j]='0';//将？转成0，方便之后+1 
        }
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            dfs(i,j);//遍历每一个点进行深搜 
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++)
            cout<<juzhen[i][j];//按序输出每一个点 
            cout<<endl;
    }
    return 0;//OK 
}
```

---

## 作者：Wichiene (赞：41)

###个人认为比较简单

感觉dalao们的代码我都看不懂……

按照一个蒟蒻的思维，应该不用那么复杂吧，两个二维数组，一个是char类型，一个是int

以char类型读入，一边读入一边扫描是否有“\*”，有的话，周围八个格子雷数加1，储存在int数组里

输出的时候把雷和数组分开，用int数组输出雷数，用char数组输出雷，就可以避开雷啦~

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;char a[101][101];
int n,m,i,j,s[101][101];//全局变量，懒得想初始值~
int main()
{
    cin>>n>>m;//行列
for(i=1;i<=n;i++)
for(j=1;j<=m;j++)//一边输入，一边算就可以了
{
cin>>a[i][j];
if(a[i][j]=='*')//如果该格有雷
{
    s[i][j+1]++;
    s[i][j-1]++;
    s[i+1][j]++;
    s[i-1][j]++;
    s[i+1][j+1]++;
    s[i+1][j-1]++;
    s[i-1][j-1]++;
    s[i-1][j+1]++;//周围八个格子++，储存在int数组
}
}
for(i=1;i<=n;i++)
{
for(j=1;j<=m;j++)
{
    if(a[i][j]=='*')
    {
        cout<<"*";
```
}//如果该格有雷，输出“\*”

```cpp
    else
    cout<<s[i][j];//如果没有雷，输出周围雷的个数
}    
puts("");//一定要有的换行！！！否则格式不对！！！
}
return 0;
}
```

---

## 作者：chensj (赞：25)

测试点五错的可以瞅一眼。不是的话看了可能没什么用。
首先看到题，可能会认为很简单；
只需要弄几个变量统计在输出就好了；
于是便打出了这样的源代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<string.h>
using namespace std;
int main() {
	int a,b;
	cin>>a>>b;
	char x[a+10][b+10],y[a+10][b+10];
	for(int i=0;i<a;i++)for(int j=0;j<b;j++)cin>>x[i][j];
	for(int i=0;i<a;i++)for(int j=0;j<b;j++)y[i][j]=48; //用memset(y,48,sizeof(y));也可以
    for(int i=0;i<a;i++) {
    	for(int j=0;j<b;j++) { 
     		if(x[i][j]=='*')y[i][j]='*';//判断
    		if(x[i][j]=='?') {//不是雷的话把八个都统计一遍
    			if(x[i][j+1]=='*')y[i][j]++;
				if(x[i][j-1]=='*')y[i][j]++;
				if(x[i-1][j]=='*')y[i][j]++;
				if(x[i+1][j]=='*')y[i][j]++;
				if(x[i+1][j+1]=='*')y[i][j]++;
				if(x[i+1][j-1]=='*')y[i][j]++;
				if(x[i-1][j+1]=='*')y[i][j]++;
				if(x[i-1][j-1]=='*')y[i][j]++;
			}
		}
	}
	for(int i=0;i<a;i++) {
		for(int j=0;j<b;j++)cout<<y[i][j];//输出
		cout<<endl;
	}
	system("pause");//这个提交时记得去掉
	return 0;
}
```
-----------------------------------------------------
结果提交时就发现只有90分；
程序里有好几个i-1,i+1,j-1,j+1.当i为0时i-1就为负了，j也如此。而j+1也有可能越界，i也如此，这个容易解决，数组大一点应该就没事了。再看-1的问题，这个在i=0的时候可能会出问题，那么给他加个前提就好了。但是为了保险，干脆把所有的都加个执行的前提好了。
那么代码就是这样：
```cpp
#include<iostream>
#include<cstdlib>
#include<string.h>
using namespace std;
int main() {
	int a,b;
	cin>>a>>b;
	char x[a+10][b+10],y[a+10][b+10];
	for(int i=0;i<a;i++)for(int j=0;j<b;j++)cin>>x[i][j];
	for(int i=0;i<a;i++)for(int j=0;j<b;j++)y[i][j]=48; //同上
    for(int i=0;i<a;i++) {
    	for(int j=0;j<b;j++) { 
     		if(x[i][j]=='*')y[i][j]='*';
    		if(x[i][j]=='?') {
    			if(j!=b-1)if(x[i][j+1]=='*')y[i][j]++;
				if(j!=0)if(x[i][j-1]=='*')y[i][j]++;
				if(i!=a-1) {
					if(j!=b-1)if(x[i+1][j+1]=='*')y[i][j]++;
				    if(j!=0)if(x[i+1][j-1]=='*')y[i][j]++;
				    if(x[i+1][j]=='*')y[i][j]++;
				}
				if(i!=0) {
					if(j!=b-1)if(x[i-1][j+1]=='*')y[i][j]++;
    			    if(j!=0)if(x[i-1][j-1]=='*')y[i][j]++;
    			    if(x[i-1][j]=='*')y[i][j]++;
				}
			}
		}
	}
	for(int i=0;i<a;i++) {
		for(int j=0;j<b;j++)cout<<y[i][j];
		cout<<endl;
	}
	system("pause");//这个也要记得去掉
	return 0;
}
```
----------------------------------------------------------
那么这样就可以AC了
**********************************************************
然而尴尬的是，不用这么麻烦：
```cpp
#include<iostream>
#include<cstdlib>
#include<string.h>
using namespace std;
int main() {
	int a,b;
	cin>>a>>b;
	char x[a+10][b+10],y[a+10][b+10];
	for(int i=1;i<=a;i++)for(int j=1;j<=b;j++)cin>>x[i][j];
	//for(int i=0;i<a;i++)for(int j=0;j<b;j++)y[i][j]=48; 
	memset(y,48,sizeof(y));
    for(int i=1;i<=a;i++) {
    	for(int j=1;j<=b;j++) { 
     		if(x[i][j]=='*')y[i][j]='*';
    		if(x[i][j]=='?') {
    			if(x[i][j+1]=='*')y[i][j]++;
				if(x[i][j-1]=='*')y[i][j]++;
				if(x[i-1][j]=='*')y[i][j]++;
				if(x[i+1][j]=='*')y[i][j]++;
				if(x[i+1][j+1]=='*')y[i][j]++;
				if(x[i+1][j-1]=='*')y[i][j]++;
				if(x[i-1][j+1]=='*')y[i][j]++;
				if(x[i-1][j-1]=='*')y[i][j]++;
			}
		}
	}
	for(int i=1;i<=a;i++) {
		for(int j=1;j<=b;j++)cout<<y[i][j];
		cout<<endl;
	}
	system("pause");//记得
	return 0;
}
```
----------------------------------------------------------
只需要把循环的条件+1就好了，那么-1的那些东西最多也就是0，没什么，+1的那些把数组开大一点就好了。我也是刚刚试了一下才发现。

---

## 作者：Zskioaert1106 (赞：14)

题目传送门：[P2670 [NOIP2015 普及组] 扫雷游戏](https://www.luogu.com.cn/problem/P2670)

### 做题方法

- 按从 $1$ 到 $n$，$1$ 到 $m$ 存储。

- 如果当前格子是地雷就输出 `*`。

- 否则按题目要求，看周围的 $8$ 个格子（具体见下），由于数组的下标从 $0$ 开始，所以不会越界；而同时范围外的格子又一定不是 `*`，所以这样不会出问题。

- 最后输出身边是地雷的格子数之和即可。

```cpp
#include<iostream>
using namespace std;
short n,m,ans[102][102];
char a[102][102];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(short i=1;i<=n;i++)
		for(short j=1;j<=m;j++)
			cin>>a[i][j];
	for(short i=1;i<=n;i++){
		for(short j=1;j<=m;j++){
			if(a[i][j]=='*'){//如果本身是地雷就输出
				cout<<'*';
				continue;
			}
			if(a[i-1][j]=='*')ans[i][j]++;//上
			if(a[i+1][j]=='*')ans[i][j]++;//下
			if(a[i][j-1]=='*')ans[i][j]++;//左
			if(a[i][j+1]=='*')ans[i][j]++;//右
			if(a[i-1][j-1]=='*')ans[i][j]++;//左上
			if(a[i-1][j+1]=='*')ans[i][j]++;//右上
			if(a[i+1][j-1]=='*')ans[i][j]++;//左下
			if(a[i+1][j+1]=='*')ans[i][j]++;//右下
			cout<<ans[i][j];
		}cout<<'\n';
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/196770833)。

### 题外话

无意间发现过掉这个题已经是两年前了，当时刚学 OI 的我打出了这样的代码：

```cpp
#include<iostream>
using namespace std;
int main(){
    int n,m,a[100][100];
    char la[100][100];
    cin>>n>>m;
    for(int i=0;i<n;i++){for(int j=0;j<m;j++)cin>>la[i][j];}
    for(int i=0;i<n;i++){
    	for(int j=0;j<m;j++){
    		a[i][j]=0;
    		if(la[i][j]=='*')a[i][j]=10;
    		else{
    			if(i==0){
    				if(la[i+1][j]=='*')a[i][j]++;
    				if(la[i+1][j+1]=='*')a[i][j]++;
    				if(la[i][j+1]=='*')a[i][j]++;
    				if(j>0){
    					if(la[i][j-1]=='*')a[i][j]++;
    					if(la[i+1][j-1]=='*')a[i][j]++;
					}
				}
				else if(i==n-1){
    				if(la[i-1][j]=='*')a[i][j]++;
    				if(la[i-1][j+1]=='*')a[i][j]++;
    				if(la[i][j+1]=='*')a[i][j]++;
    				if(j>0){
    					if(la[i][j-1]=='*')a[i][j]++;
    					if(la[i-1][j-1]=='*')a[i][j]++;
					}
				}
				else if(j==0){
					if(la[i+1][j]=='*')a[i][j]++;
					if(la[i-1][j]=='*')a[i][j]++;
					if(la[i][j+1]=='*')a[i][j]++;
					if(la[i-1][j+1]=='*')a[i][j]++;
					if(la[i+1][j+1]=='*')a[i][j]++;
				}
				else if(j==n-1){
					if(la[i+1][j]=='*')a[i][j]++;
					if(la[i-1][j]=='*')a[i][j]++;
					if(la[i][j-1]=='*')a[i][j]++;
					if(la[i-1][j-1]=='*')a[i][j]++;
					if(la[i+1][j-1]=='*')a[i][j]++;
				}
				else{
					if(la[i+1][j]=='*')a[i][j]++;
					if(la[i+1][j+1]=='*')a[i][j]++;
					if(la[i+1][j-1]=='*')a[i][j]++;
					if(la[i][j-1]=='*')a[i][j]++;
					if(la[i][j+1]=='*')a[i][j]++;
					if(la[i-1][j]=='*')a[i][j]++;
					if(la[i-1][j+1]=='*')a[i][j]++;
					if(la[i-1][j-1]=='*')a[i][j]++;
				}
			}
		}
	}
	for(int i=0;i<n;i++){
    	for(int j=0;j<m;j++){
    		if(a[i][j]==10)cout<<'*';
    		else cout<<a[i][j];
    	}
    	cout<<endl;
    }
	return 0;
}
```

逆如天，但是核心思想就是判断周围所有的非墙壁格子有没有地雷。

[AC 记录](https://www.luogu.com.cn/record/139522307)。当然我们现在长大了，可以写出更简单的代码了。

---

## 作者：GSQ0829 (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P2670)

---
### 思路：
其实本题就是简单搜索题。需要遍历出八个方向的地雷数。

输入不说，来说说主要的搜索部分。

首先，雷区分为两部分，雷格和非地雷格。

如果是雷格，那么直接输出米字号。

否则就去遍历每个格子是否是地雷，如果是所在格子的计数器加一。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int dx[8] = {0, 0, 1, 1, 1, -1, -1, -1}, dy[8] = {-1, 1, -1, 0, 1, -1, 0, 1}, n, m, ans = 0;
char mp[101][101];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) cin >> mp[i][j];
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (mp[i][j] == '*') cout << '*';
			else {
				for (int k = 0; k < 8; k++) {
					int x = i + dx[k], y = j + dy[k];
					if (x >= 1 && x <= n && y >= 1 && y <= m && mp[x][y] == '*') ans++;
				}
				cout << ans;
				ans = 0;
			}
		}
		cout << endl;
	}
	return 0;
}
```

---

## 作者：qhr2023 (赞：7)

## solution

读入整个雷区后，遍历整个雷区，对于每个位置，若是雷直接输出，否则遍历与它相邻的八个位置，同时记录雷数，最后输出雷数。

[通过记录](https://hydro.ac/record/6774ea974622fcac7bbb70f6)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[101][101];
int n, m; 
int main(){
    cin >> n >> m;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			cin >> a[i][j];
	for(int i=1; i<=n; cout << '\n', i++)
		for(int j=1; j<=m; j++)
			if(a[i][j]=='*') 
                cout << '*';
			else 
				cout << (a[i-1][j-1]=='*')+(a[i-1][j]=='*')
					+(a[i-1][j+1]=='*')+(a[i][j-1]=='*')
					+(a[i][j+1]=='*')+(a[i+1][j-1]=='*')
					+(a[i+1][j]=='*')+(a[i+1][j+1]=='*');
	return 0;
}
```

---

## 作者：鹭天 (赞：5)

#额。。看了一下，似乎没人 用到坐标增量，那么我来补一道。。

很显然的八个点，坐标定义为：

const
  dx:array[1..8] of -1..1 = (-1,1,0,0,-1,-1,1,1);//行坐标

  dy:array[1..8] of -1..1 = (0,0,-1,1,-1,1,-1,1);//列坐标

{每一个坐标增量都表示着一个要查找的区域，如dx[1]和dy[1]，表示上(i-1,j)}

那么多余的话也不说了，直接来代码吧：

```cpp
const//如上，坐标增量定义
  dx:array[1..8] of -1..1 = (-1,1,0,0,-1,-1,1,1);
  dy:array[1..8] of -1..1 = (0,0,-1,1,-1,1,-1,1);
var
  i,j,n,m,k,s:longint;
  ch:char;
  f:array[0..101,0..101] of boolean;//用布尔数组判断他是否为地雷，如果是，则为true;
  readln(n,m);
  for i:=1 to n do begin
    for j:=1 to m do begin
      read(ch);f[i,j]:=ch='*';//这步相当于if ch='*' then  f[i,j]:=true else  f[i,j]:=false;只是简化了而已。
    end;
    readln;//一定要换行！不然会把换行符夜读入，那么就错了。
  end;
  for i:=1 to n do begin
    for j:=1 to m do begin
      s:=0;//s用来统计雷的个数，统计前要先置0
      if f[i,j] then write('*')//判断，如果是雷就直接输出
        else begin
          for k:=1 to 8 do//那么就朝八个面进行搜索
            if f[i+dx[k],j+dy[k]] then inc(s);//如果区域范围内又雷，那么就累加上一
          write(s);//输出雷的个数。
        end;
    end;
    writeln;//换行
  end;
end.
十分简单的一题微型搜索。但也可以不用搜索，也是一题练习坐标增量的好题目。
```

---

## 作者：Jerry_zpl (赞：3)

本题算法为：枚举。

我们可以把有雷的地方用数组标记为 $1$，没有雷的地方标记为 $0$。然后枚举所有的点，如果 $a_{i,j}$ 是 $1$，那么这个点是雷，直接输出 `*`，否则把上下左右几个点标记的数值加起来就行了。因为不是雷的地方标记成的 $0$，所以不会有影响。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[1005][1005]; 
int main()
{
	memset(a,0,sizeof(a));
	int n,m;
	cin>>n>>m;
	char c;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='*') a[i][j]=1; //是雷
			else a[i][j]=0;       //不是雷
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]==1) cout<<'*';//如果是雷就直接输出
			else cout<<a[i+1][j+1]+a[i+1][j-1]+a[i+1][j]+a[i][j+1]+a[i][j-1]+a[i-1][j+1]+a[i-1][j]+a[i-1][j-1];//输出上下左右的雷的个数
		}
		cout<<"\n";//注意换行
	}
	return 0;
}
```

---

## 作者：superLouis (赞：2)

## 题解：P2670 [NOIP2015 普及组] 扫雷游戏

吐槽一句，这么弱的题，居然这么少人发题解？

----------
### 1. 解题思路
我的思路比较中规中矩，不容易错。其实就是定义两个方向数组，分别记录一个点周围 $8$ 个格子横纵坐标减去这个格子横纵坐标的数值，这样可以少写许多判断语句。  
注意注意！扫描到它周围的每一个格子时都要判断是否下标越界！

梳理一遍，先读入，随后扫描整个数组，如果当前的字符是 `*` 就直接输出，否则扫描它周围的 $8$ 个格子，有 `*` 就计数器加一。

----------
### 2. 代码实现
代码非常简单呀～

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110;
const int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};
const int dy[] = {1, 1, 0, -1, -1, -1, 0, 1};
int n, m;
char a[maxn][maxn];
inline bool inb(int x, int y) {
    return x > 0 && y > 0 && x <= n && y <= m;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= m; j++) cin >> a[i][j];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] == '*') { cout << '*'; continue; }
            int cnt = 0;
            for (int k = 0; k < 8; k++) {
                int nx = i + dx[k], ny = j + dy[k];
                if (inb(nx, ny) && a[nx][ny] == '*') cnt++;
            } cout << cnt;
        }
        cout << '\n';
    }
    return 0;
}
```

[分享通过记录～](https://www.luogu.com.cn/record/196773465)

---

## 作者：hbdcsd (赞：1)

## 题意

对于每一个问号，统计它八个方向上的星号数量。

## 思路

输入。枚举雷区，如果此格是问号，搜索与它八联通的格子，如果是星号，计数器加 $1$，将结果放在原数组里，最后输出即可。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <string>
#include <cstring>
#include <climits>
#include <cstdlib>
using namespace std;
typedef long long ll;
int n, m, dx[] = {0, 0, -1, 1, 1, 1, -1, -1}, dy[] = {-1, 1, 0, 0, -1, 1, -1, 1};//变化量数组，使用时把原位置加上数组值，得到要枚举的位置
char s[105][105];
int main(){
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) cin >> s[i][j];
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			if (s[i][j] == '?'){//如果此格是问号
				int cnt = 0;
				for (int k = 0; k < 8; k++){
					int nx = i+dx[k], ny = j+dy[k];//使用变化量数组枚举八联通格子
					if (nx < 1 || nx > n || ny < 1 || ny > m) continue;//防止统计到雷区外
					if (s[nx][ny] == '*') cnt++;
				}
				s[i][j] = cnt+'0';
			}
		}
	}
	for (int i = 1; i <= n; i++, puts(""))
		for (int j = 1; j <= m; j++) cout << s[i][j];
	return 0;
}
```

---

## 作者：SLYZ_0120 (赞：0)

蒟蒻的第八篇题解（逃跑ing）跪求审过

首先使用c数组来读入每一行的东西，然后一遍扫过去，遇到\*的就把a数组对应位置上的值赋为-1，否则就是0，这样就可以把字符转化为数字存起来了。然后整个a数组每一个扫过去，只要八个方向发现了1雷就把这里的值++，八个方向扫过一遍以后这个地方存的就是要求的答案了，最后判断输出，如果是-1就输出\*否则输出里面的值。


这个代码比较朴素……不过比较容易看懂，dalao们还是忽略吧

**需要注意的一些地方：**

- 八个方向的搜索可以使用一个二维数组b来存放每一次x轴和y轴上的动作，一定不要弄错了……

- 暴力搜索每一个点的时候记得判断这个点是不是雷，是的话就跳过

- 小心加减的时候越界

- 一开始存的时候下标不要弄错


下面附上代码

```cpp
//防伪标识
#include<bits/stdc++.h>
using namespace std;
int n,m;
char c[101];
int a[101][101];
int b[9][3] = {{0,0,0},{0,-1,-1},{0,0,-1},{0,1,-1},{0,-1,0},{0,1,0},{0,-1,1},{0,0,1},{0,1,1}}; //b数组是8个方向的动作
int main(){
    scanf("%d %d",&n,&m);
    for(int i = 1;i<=n;i++){
        cin >> c; //c数组一行一行输
        for(int j = 0;j < m;j++){
            if(c[j] == '*'){
                a[i][j+1] = -1; //下标要注意，不加1的话下面要从0开始
            }
            else a[i][j+1] = 0;
        }
    }
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=m;j++)
            for(int k = 1;k<=8;k++){
                if(i+b[k][1] > 0 && j + b[k][2] > 0&&i+b[k][1] < n+1 && j + b[k][2] < m+1&&a[i][j] != -1){ // 需要特判是不是雷
                    if(a[i+b[k][1]][j+b[k][2]] == -1){
                    //    printf("%d %d\n",i+b[k][1],j+b[k][2]); //这个是可以调试用的东西
                        a[i][j] ++ ;
                    }
                }
            }
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=m;j++)
            a[i][j] == -1?printf("*"):printf("%d",a[i][j]); //三目运算符判断，简洁
            printf("\n");//换行注意
        }
    return 0;
}
```

---


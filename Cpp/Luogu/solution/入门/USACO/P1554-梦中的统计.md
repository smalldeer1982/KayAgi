# 梦中的统计

## 题目背景

Bessie 处于半梦半醒的状态。过了一会儿，她意识到她在数数，不能入睡。

## 题目描述

Bessie 的大脑反应灵敏，仿佛真实地看到了她数过的一个又一个数。她开始注意每一个数码（$0 \ldots 9$）：每一个数码在计数的过程中出现过多少次？

给出两个整数 $M$ 和 $N$，求在序列 $[M, M + 1, M + 2, \ldots, N - 1, N]$ 中每一个数码出现了多少次。

## 说明/提示

数据保证，$1 \leq M \leq N \leq 2 \times 10^9$，$N-M \leq 5 \times 10^5$。

## 样例 #1

### 输入

```
129 137```

### 输出

```
1 10 2 9 1 1 1 1 0 1```

# 题解

## 作者：G2_NIKO (赞：11)

~一道水到不能再水的题目了。~

## 题意

$M$ 到 $N$ 每个数中每个数字出现的次数，接着依次输出。

## 思考

让我们用我们的眼睛仔细阅读以下题目的数据范围中的 $N - M \le 5 \times 10^5$ 后就会发现。

**一道模拟题**。

## 思路

暴力枚举 $M$ 到 $N$，把每个数拆开之后有一个数组进行下标计数。

(注意：不可以直接拆循环变量，需要一个替身来拆解。)

最后再枚举每个数字也就是 $0$ 到 $9$ 输出下标计数的数组。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[10];
int main(){
	cin>>n>>m;
	for(long long i=n;i<=m;i++)
	{
		long long t=i;
		while(t!=0)
		{
			a[t%10]++;
			t/=10; 
		}
	}
	for(int i=0;i<10;i++)
	{
		cout<<a[i]<<" ";
	}
	return 0;
}

```

---

## 作者：lmz105 (赞：4)

## 普通做法
枚举序列中的每个数字，用数位分离法统计每一个数码出现次数。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace FX {
	template<typename T> inline void r(T &in) {
		in = 0;
		bool bo = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			bo ^= (ch == '-');
			ch = getchar();
		}
		while (isdigit(ch))
			in = (in << 1) + (in << 3) + (ch ^ 48), ch = getchar();
		if (bo) {
			in = -in;
		}
	}
	template<typename T> inline void w(T out) {
		static char op[25];
		int top = 0;
		if (out < 0) {
			putchar('-');
			do {
				op[++top] = -(out % 10) + 48, out /= 10;
			} while (out);
		} else {
			do {
				op[++top] = out % 10 + 48, out /= 10;
			} while (out);
		}
		while (top)
			putchar(op[top--]);
		putchar(' ');
	}
	template<typename T, typename... Ts> inline void r(T &in, Ts &... ins) {
		r(in), r(ins...);
	}
	template<typename T, typename... Ts> inline void w(T out, Ts... outs) {
		w(out), w(outs...);
	}
	inline void w(const char *p) {
		while (*p) {
			putchar(*p++);
		}
	}
}
#undef getchar
#undef putchar
using namespace FX;
#endif
using namespace std;
ll n,m,ans[16];
int main() {
	r(m,n);
	for (ll i=m;i<=n;i++){
		for (ll u=i;u>0;u/=10){
			ans[u%10]++;
		}
	}
	for (ll i=0;i<10;i++){
		w(ans[i]);
	}
	return 0;
}
```

## 进阶做法
用记忆化搜索统计每个数码在序列 $[1, 2, \ldots, M - 2, M - 1]$ 和序列 $[1, 2, \ldots, N - 1, N]$ 中出现次数，它们的差就是这个数码在序列 $[M, M + 1, M + 2, \ldots, N - 1, N]$ 出现次数，记忆化搜索的讲解看代码注释。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace FX {
	//里面的代码与之前给出的相同
}
#undef getchar
#undef putchar
using namespace FX;
#endif
using namespace std;
ll n, m, num[16], p, cnt, f[16][16][2][2], ans[16];
/*
x是当前为从高到低第几位，p是正在统计的数码，y是当前p出现的次数。
bo是判断之前的是不是前导零，bl是判断之前的是否达到上限。
*/
ll dfs(ll x, ll y, bool bo, bool bl) {
	if (f[x][y][bo][bl] != -1) {
		return f[x][y][bo][bl];
	}
	if (!x) {
		return y;
	}
	ll maxx = (bl ? num[x] : 9), sum = 0;
	for (ll i = 0; i <= maxx; i++) {
		if (!p) {//注意前导零不能被算在内
			sum += dfs(x - 1, y + (!i && !bo), !i && bo, bl && i == maxx);
		} else {
			sum += dfs(x - 1, y + (i == p), !i && bo, bl && i == maxx);
		}
	}
	return f[x][y][bo][bl] = sum;
}

int main() {
	r(m,n);
	m--;
	while (m) {
		num[++cnt] = m % 10;
		m /= 10;
	}
	for (p = 0; p <= 9; p++) {
		memset(f, -1, sizeof f);
		ans[p] = dfs(cnt, 0, 1, 1);
	}
	cnt = 0;
	while (n) {
		num[++cnt] = n % 10;
		n /= 10;
	}
	for (p = 0; p <= 9; p++) {
		memset(f, -1, sizeof f);
		w(dfs(cnt, 0, 1, 1) - ans[p]);
	}
	return 0;
}
```

---

## 作者：Ashankamiko (赞：1)

# 题目简述
### 题意
给定 $M$ 和 $N$，求 $M$ 到 $N$ 之间的所有数字中，$0$ 到 $9$ 的数量有多少。
### 思路
题中已经声明：$M \le N$，所以我们无需考虑当 $M > N$ 时要交换 $M$ 和 $N$。

虽然数据范围已经告诉我们可能超时，但是实际却是可以直接模拟，那么我们就可以枚举 $M$ 到 $N$ 区间中的所有数，并用 $cnt_i$ 统计 $0$ 到 $9$ 数量。

由于我们要统计每一位，显然写代码时更适合使用字符串。
### STL 函数
这里介绍 `to_string(x)` 的用法。
```cpp
template<typename T>
T to_string(T x) {
}
```
不难发现该函数的参数为任意类型，其实只要是数字都可以，包括 `int` 和 `double` 等，这些数据类型都可以转化为字符串并返回。

在此题中，我们将运用 `to_string(x)` 函数，可以时代码更便捷、直观、容易理解。
## [AC 代码](https://www.luogu.com.cn/record/218948338)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
#define int long long
int cnt[10]; //储存数量

signed main() {
	int l, r;
	in >> l >> r;
	for (int i = l; i <= r; i++) {
		string s = to_string(i); // 将i转化为string类型
		for (int j = 0; j < s.size(); j++) // 遍历s
			cnt[s[j] - '0']++; // 统计数字的出现数量
	}
	for (int i = 0; i < 10; i++) // 输出答案
		out << cnt[i] << ' ';
	return 0;
}
```

---

## 作者：fjtMESSI10 (赞：1)

## 思路
这题我们可以枚举 $n$ 到 $m$ 之间的每一个数，在枚举每个数时将这个数进行数位分离，并判断每一位数是不是 $0$ 到 $9$ 之间的某一个数，并加在相应的存储每个数数量的变量里。（注意，在数位分离到 $0$ 时需打特判来结束这次循环）。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
signed main(){
cin>>n>>m;
int a0=0,a1=0,a2=0,a3=0,a4=0,a5=0,a6=0,a7=0,a8=0,a9=0;
for(int i=n;i<=m;i++){
	int u=i;
	while(u!=0){
		if(u%10==0){
			a0++;
		}
		if(u%10==1){
			a1++;
		}
		if(u%10==2){
			a2++;
		}
	    if(u%10==3){
			a3++;
		}
		if(u%10==4){
			a4++;
		}
		if(u%10==5){
			a5++;
		}
		if(u%10==6){
			a6++;
		}
		if(u%10==7){
			a7++;
		}
		if(u%10==8){
			a8++;
		}
		if(u%10==9){
			a9++;
		}
		u/=10;
		if(u==0){
			break;
		}
	}
}
cout<<a0<<" "<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<" "<<a5<<" "<<a6<<" "<<a7<<" "<<a8<<" "<<a9;
return 0;
}
```

---

## 作者：Heqianyu59714 (赞：0)

# 题目大意
### 题意
求 $n$ 到 $m$ 之间每个数字出现的次数。
### 思路
先数位分离，再用数组 $a$ 记录每一个数字出现的次数。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m,a[15];//定义

int main() {
	cin >> m>> n;
	for (int i = m; i <= n; i++) {//数位分离
		int x = i;
		while (x) {//计数
			int b = x % 10;
			a[b]++;
			x /= 10;
		}
	}
	for(int i=0;i<=9;i++){
		cout<<a[i]<<" ";//输出
	}
	return 0;
}

```

---


# Line

## 题目描述

在一个二维平面内，给定两条**分别与 $x$ 轴和 $y$ 轴平行**的线段 $AB$ 和 $CD$。

你可以选择一条线段，将其沿着平行于坐标轴（上下左右）的任意一个方向平移**任意单位长度**，称为一次操作。

问至少进行几次操作可以使两条线段相交？

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，两条线段已经相交，不需要进行任何操作；
- 对于第二组数据，一种可行的方案为：将线段 $AB$ 向上平移一个单位；
- 对于第三组数据，一种可行的方案为：将线段 $AB$ 向上平移一个单位，再将线段 $CD$ 向右平移一个单位。

**【数据规模与约定】**

记 $M=\max(x_A,y_A,x_B,y_B,x_C,y_C,x_D,y_D)$。

| 测试点编号 | $T\le$ | $M\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $10$ | 无 |
| $2\sim 3$ | $10$ | $50$ | 无 |
| $4\sim 5$ | $10$ | $10^3$ | 无 |
| $6\sim 7$ | $10^5$ | $10^9$ | 保证答案不超过 $1$ |
| $8\sim 10$ | $10^5$ | $10^{9}$ | 无 |

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le M\le 10^{9}$，$x_A<x_B$，$x_C=x_D$，$y_A=y_B$，$y_C<y_D$。

## 样例 #1

### 输入

```
3
1 1 2 1 1 1 1 2
1 1 2 1 1 2 1 3
2 1 3 1 1 2 1 3```

### 输出

```
0
1
2```

# 题解

## 作者：deepthinker (赞：6)

## 一道非常简单的题目
[题面传送门](https://www.luogu.com.cn/problem/P10057)

这道题求需要多少次操作两条线段才能相交，其实因为一次操作可以平移任意长的距离，操作次数最多为 $2$ 次（一次上下平移，一次左右平移）。 
+ 对于是否要上下平移，我们只需要判断两条线段的横坐标区间是否有公共部分。
+ 同理，对于是否要左右平移，我们只需要判断两条线段的纵坐标区间是否有公共部分。

话不多说，直接上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long ax, ay, bx, by, cx, cy, dx, dy, t;
signed main()
{
    cin >> t;
    while (t--)
    {
        int ans = 0;
        cin >> ax >> ay >> bx >> by >> cx >> cy >> dx >> dy;//输入
        if (max(ax, bx) < min(cx, dx) || min(ax, bx) > max(cx, dx))//判断横坐标是否需要操作
        {
            ans++;
        }
        if (max(ay, by) < min(cy, dy) || min(ay, by) > max(cy, dy))//判断纵坐标是否需要操作
        {
            ans++;
        }
        cout << ans << '\n';
    }

    return 0;
}//结束

```
### 总结
这道题目十分简单，主要考查的是分析和代码实现能力。
#### 蒟蒻的第一篇题解，希望管理员通过。

---

## 作者：_JF_ (赞：4)

发现，最终答案只有可能在 $0,1,2$ 三者之间。

定义平行于 $x$ 轴线段为 $A$，平行于 $y$ 轴线段为 $B$。

然后，我们考虑对 $A$ 先左右平移，再上下平移。

- 对于左右平移，我们只用判断 $A$ 横坐标覆盖的范围是否包括 $B$ 的横坐标。

- 对于上下平移，我们只用判断 $B$ 纵坐标多的覆盖范围是否包括 $A$ 的纵坐标。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
signed main(){
//	freopen("6.in","r",stdin);
//	freopen("6.out","w",stdout);
	int t;
	scanf("%lld",&t);
	while(t--){
		int x1F,x2F,x1L,x2L,y1F,y1L,y2L,y2F,ans=0;
		scanf("%lld%lld%lld%lld",&x1F,&y1F,&x1L,&y1L);
		scanf("%lld%lld%lld%lld",&x2F,&y2F,&x2L,&y2L);
		if(y2F>y1L||y1L>y2L)
			ans++;
		if(x1F>x2F||x2F>x1L)
			ans++;
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Double_Light (赞：3)

考虑以下两点：

1. $AB$ 所在的 $y$ 轴是否在 $[y_C,y_D]$ 范围内。
2. $CD$ 所在的 $x$ 轴是否在 $[x_A,x_B]$ 范围内。

对于第一点，如果不在这个范围，就要将 $AB$ 上下移动到 $CD$ 横着扫能够扫到的范围内。花费一次操作。

对于第二点，如果不在这个范围，就要将 $CD$ 左右移动到 $AB$ 横着扫能够扫到的范围内。花费一次操作。

这样最多只有两次操作，显然是最少的操作次数。

给出核心代码如下：

```cpp
while(t--){
	ans=0;//注意多测清空
	cin>>a>>b>>c>>d>>e>>f>>g>>h;
	if(b>h)ans++;//AB在CD上方
	if(b<f)ans++;//AB在CD下方
	if(e>c)ans++;//CD在AB右方
	if(e<a)ans++;//CD在AB左方
	cout<<ans<<endl;
}
```

---

## 作者：zbzbzzb (赞：2)

这道题我们可以知道最多只有两次操作，于是分类讨论。

可以发现，其实要求两条线是否相交，就是平行于 $y$ 轴的线的相同的 $x$ 在平行于 $x$ 轴的两个不同的 $x$ 之间，且平行于 $x$ 轴的线的相同的 $y$ 在平行于 $y$ 轴的两个不同的 $y$ 之间。

那么如果只需要一次操作就是只满足上述两个条件中的一个。

两次操作同理，就是一个条件也不满足。

AC CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,xa,xb,ya,yb,xc,xd,yc,yd;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d%d%d%d%d%d",&xa,&ya,&xb,&yb,&xc,&yc,&xd,&yd);
		if((xc>=xa&&xc<=xb&&ya>=yc&&ya<=yd)){//相交
			printf("0\n");
		}else if((xc>=xa&&xc<=xb&&(ya<yc||ya>yd))||((xc<xa||xc>xb)&&ya>=yc&&ya<=yd)){//一次操作
			printf("1\n");
		}else if((xc<xa||xc>xb)&&(ya<yc||ya>yd)){//两次操作
			printf("2\n");
		}
	}return 0;
}
```

---

## 作者：_qhbd_ (赞：1)

# 题意
给定两条线段 $AB,CD$，它们分别平行于 $x$ 轴和 $y$ 轴。

现在你可以对 $AB,CD$ 进行任意操作，每次可以将其向上下左右任意方向平移任意距离，问至少几次操作可以使得它们相交。
# 思路
看完题目后不难发现这只是个结论题。

首先，如果这两条线段一开始相交，就说明答案为 $0$，也就是不需要操作。

其次，如果这两条线段类似如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/7co9e45i.png)

那么只需要将任意一条线段移到另一个上面即可相交，答案为 $1$。

最后，如果这两条线段类似如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/vxtjlpuv.png)

那么只需要先操作一次将此情况变成第一张图里的，然后按照上文操作即可。答案为 $2$。

所以我们只需要通过题目给定的 $A,B,C,D$ 点的位置，判断 $AB,CD$ 的位置，然后输出对应答案即可。

```cpp
#include<iostream>
using namespace std;
int t,n,a,b,c,d,e,f,g,h;
int main(){
    scanf("%d",&t);
    while(t--){
        int ans=2;
        scanf("%d%d%d%d%d%d%d%d",&a,&b,&c,&d,&e,&f,&g,&h);
        if(b>=min(f,h)&&b<=max(f,h))
            ans--;
        if(e>=min(a,c)&&e<=max(a,c))
            ans--;
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：ivyjiao (赞：1)

- 如果两条线段初始已经相交（$x$ 和 $y$ 都有交集），输出 $0$。
- 如果有一条线段平移一次能和另一条线段相交（$x$ 或 $y$ 都有交集），输出 $1$。
- 否则（$x$ 和 $y$ 都没有交集），输出 $2$。

判断方法见代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,xa,ya,xb,yb,xc,yc,xd,yd;
signed main(){
    cin>>t;
    while(t--){
        cin>>xa>>ya>>xb>>yb>>xc>>yc>>xd>>yd;
        if((ya<=yd&&ya>=yc)&&(xc<=xb&&xc>=xa)) cout<<0<<endl;
        else if((ya<=yd&&ya>=yc)||(xc<=xb&&xc>=xa)) cout<<1<<endl;
        else cout<<2<<endl;
    }
}
```

---

## 作者：BIG_CUTE_BUG (赞：0)

[题传](https://www.luogu.com.cn/problem/P10057)

## 思路

若线段 $AB$ 所在水平直线与 线段 $CD$ 有交，说明可通过水平平移一次 $AB$ 使得两线相交。

若线段 $CD$ 所在竖直直线与 线段 $AB$ 有交，说明可通过竖直平移一次 $CD$ 使得两线相交。

若上两者皆满足，说明两线段本就有交或重合。

若皆不满足，说明只能先平移一线段使其直线与另一线段有交，然后再平移一次，使两线段相交。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
struct node {int x, y;} p[10];
signed main()
{
	ios:: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>> t;
	while(t--)
	{
		for(int i= 1; i<= 4; i++) cin>> p[i].x>> p[i].y;
		if(p[1].x> p[2].x) swap(p[1].x, p[2].x);
		if(p[3].y> p[4].y) swap(p[3].y, p[4].y);
		bool l1, l2;
		l1= (p[1].y>= p[3].y && p[1].y<= p[4].y);
		l2= (p[3].x>= p[1].x && p[3].x<= p[2].x);
		if(l1 && l2) puts("0");
		else if(l1 || l2) puts("1");
		else puts("2");
	}
	return 0;
}
```

---

## 作者：vectorxyz (赞：0)

### 题意理解

注意到题中说一次操作可以移**任意单位长度**，显而易见，我们只有四种情况讨论。

- 第一种：两条线已经相交了，即他们行和列都是重合的。

![](https://cdn.luogu.com.cn/upload/image_hosting/13w14eo5.png)

- 第二种：只有行是重合的，列没有重合。


那么如何判断行是否重合呢？由于这两个线段都与坐标系平行，所以我们只要看那条**横线**的列的坐标是否包含在**竖线**的列的坐标中，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cq1igy3y.png)

$2$ 肯定在 $0$ 到 $4$ 中，所以他们行是重合的，他的操作次数是 $1$ 次。

- 第三种：只有列是重合的，行没有重合。



跟第二种情况类似，只需判断**竖线**的行的坐标是否包含在**横线**的行的坐标中。请自行画图理解，他的操作次数是 $1$ 次。

- 第四种：都不重合，那就把行和列都操作一下，就是 $2$ 次。

![](https://cdn.luogu.com.cn/upload/image_hosting/9gv11e4u.png)

至此，讨论结束。

很容易发现，它的操作次数最多不超过 $2$ 次。

### 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;

signed main()
{
    int T;
    cin >> T;
    while(T -- ){
        int a1, a2, b1, b2, c1, c2, d1, d2;
        cin >> a1 >> a2 >> b1 >> b2 >> c1 >> c2 >> d1 >> d2;
        int ans = 0;
        int f1 = 1, f2 = 1;
        if(a1 <= c1 && c1 <= b1) f1 = 0;
        if(c2 <= a2 && a2 <= d2) f2 = 0;
        if(f1 == 1 && f2 == 0){
            ans ++ ;
        }
        else if(f1 == 0 && f2 == 1) ans ++ ;
        else if(f1 == 1 && f2 == 1) ans += 2;
        cout << ans << endl;
    }
}
```

---


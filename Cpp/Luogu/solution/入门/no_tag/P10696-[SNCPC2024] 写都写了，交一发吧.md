# [SNCPC2024] 写都写了，交一发吧

## 题目描述

MCPlayer542 正在做一道题。

由于题目太难，他不能直接写出正解，而是写出了 $n$ 份不同的代码，其中第 $i$ 份代码可以获得 $g_i$ 的分数。

时间紧迫，MCPlayer542 打算直接胡乱把代码交上去了。然而这时候他发现：由于这场比赛的特殊规则，他必须提交两次代码，且他得到的总分将会是两次提交得分的按位与运算结果。和你正在参加的比赛类似，两次不同提交的代码可以是同一份，也可以不同。

形式化地，如果他分别在两次提交中提交了第 $i$ 和第 $j$ 份代码，则得分为 $g_i \& g_j$，其中 $\&$ 表示按位与运算。

他想知道他能得到的最高分是多少。

## 说明/提示



对于第一组数据，只需将第三份代码提交两次即可。

对于第二组数据，提交前两份代码即可。


## 样例 #1

### 输入

```
2
3
10 4 15
4
10 10 5 4
```

### 输出

```
15
10
```

# 题解

## 作者：wangbinfeng (赞：8)

[![](https://img.shields.io/badge/题目-P10696_[SNCPC2024]_写都写了，交一发吧-yellow)
![](https://img.shields.io/badge/难度-入门-red)
![](https://img.shields.io/badge/考点-二进制-blue)
![](https://img.shields.io/badge/题型-传统题-green)](https://www.luogu.com.cn/problem/P10696)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

------------
本题是比赛的签到题，线下赛共计 $118$ 个队伍通过。

- 定理 $1$：$\forall i,j\in\N^+,\;i\operatorname{\;and\;}j\le\min(i,j)$。
> 证明：对于任意一个正整数对其他正整数做按位与（且）运算，它在二进制下相应位的 $0$ 不可能变为 $1$，但相应位的 $1$ 存在变为 $0$ 的可能（只需与其按位与的数相应位为 $0$ 即可）。
- 定理 $2$：$\forall i\in\N^+,\;i\operatorname{\;and\;}i=i$。
> 证明：对于在二进制下的任意位，如果已经为 $1$ 则一定还为 $1$，为 $0$ 则一定也只能还为 $0$。

那么，总结一下两个定理，得出 $\forall i,j\in\N^+,\;i\operatorname{\;and\;}j\le\min(i,j)\le\max(i,j)=\max(i,j)\operatorname{\;and\;}\max(i,j)$。

从两个数拓展到 $n$ 个数可以显然证明结论不变。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=159;
int t,ans,n;
signed main(){
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	for(cin>>t;t--;ans=0){
		cin>>n;
		for(int i=1,x;i<=n;i++)cin>>x,ans=max(ans,x);
		cout<<ans<<'\n'; 
	}
}
```

---

## 作者：Atserckcn (赞：6)

## [P10696 [SNCPC2024] 写都写了，交一发吧](https://www.luogu.com.cn/problem/P10696) 题解

#### 注：本题解做法可能不适合新手，仅仅为适合本题的特殊情况，仅仅在此分享，不喜勿喷。

赛后感受：还行啊，就是字典树嘛，20 分钟搞定。主要是当时我要去上课，只做了一些，等级分亏了……

大概是黄题的难度，具体参考 [P10471 最大异或对 The XOR Largest Pair](https://www.luogu.com.cn/problem/P10471)。

### 题目简述

给定 $n$ 个整数，求任意两个数字（可以是同样的两个数字）按位与运算后的最大值。这样的任务共有 $t$ 组。

### 思路简述

此题与 [P10471 最大异或对 The XOR Largest Pair](https://www.luogu.com.cn/problem/P10471) 相似，可以参考[题解：P10471 最大异或对 The XOR Largest Pair](https://www.luogu.com.cn/article/wet1rg0o)。

对，就是我写的哈哈。

正事。

因为是两两按位与，所以朴素算法为 $O(n^2)$ 的暴力枚举，时间肯定超时（$4\times 10^{10}$）。虽然可以过部分测试点，但是由于比赛是只看完全做对的题目，部分分没用，还会加罚时，所以我当场排除了此思路。

考虑用字典树对其进行优化。

不难想到，因为是按位与，所以可以将其转化为**二进制**的 $01$ 串，存储在字典树里。

存图方式如下，设我们需要插入数字 $3$、$2$、$1$、$0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kqs5mf6o.png)

我们每次遍历的时候，都会有一个分叉，即继续遍历分支的 $0$ 还是 $1$。

不难想到，由于是尽可能地让这个值大，所以我们每次都尽量遍历 $1$，实在不行了，没有 $1$，再去遍历 $0$。

### 字典树：

具体介绍可参考我发的博客（上文），这里不再啰嗦，直接讲代码实现。

用一个结构体来表示字典树的每个节点，每个结构体存一个数组，仅存 $0$ 或 $1$：

```cpp
struct NODE{
	int son[2];//代表分支
}node[20000005];//众所周知，字典树的长度很玄学
```

将一个数字插入：

```cpp
void insert(int num)
{
	now=start;//多测，起始点设一下
	for(int i=30;i>=0;i--)//数字的每个二进制位
	{
		t=(num>>i)&1;//取这位
		if(!node[now].son[t]) node[now].son[t]=++tot;//如果没有此节点，则新建节点，编号为++tot
		now=node[now].son[t];//否则直接走下去
	}
	return ;
}
```

查询：

```cpp
int find(int num)
{
	ans=now=start;
	for(int i=30;i>=0;i--)
	{
		t=(num>>i)&1;
        //从这里开始与插入不同
		if(!node[now].son[t&1])//如果不存在该位&1的节点，则只能从此节点继续遍历
			now=node[now].son[t];
		else//否则最开心，按着最优情况遍历
		{
			now=node[now].son[t&1];
			ans=ans&(1<<i);//打擂台
		}
	}
	return ans;
}
```

别忘了，规则里还有自己与自己也可以相互按位与，所以再添上挨个比较的代码即可：

```cpp
for(int i=1;i<=n;i++)
			ans=max(ans,find(a[i]));
		for(int i=1;i<=n;i++)
			ans=max(ans,a[i]&a[i]);
```

最后给个完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int n,T,a[MAXN],now,t,tot,start,ans;
struct NODE{
	int son[2];
}node[20000005];
void insert(int num)
{
	now=start;
	for(int i=30;i>=0;i--)
	{
		t=(num>>i)&1;
		if(!node[now].son[t]) node[now].son[t]=++tot;
		now=node[now].son[t];
	}
	return ;
}
int find(int num)
{
	ans=now=start;
	for(int i=30;i>=0;i--)
	{
		t=(num>>i)&1;
		if(!node[now].son[t&1])
			now=node[now].son[t];
		else
		{
			now=node[now].son[t&1];
			ans=ans&(1<<i);
		}
	}
	return ans;
}
int main(){
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			insert(a[i]);
		}
		for(int i=1;i<=n;i++)
			ans=max(ans,find(a[i]));
		for(int i=1;i<=n;i++)
			ans=max(ans,a[i]&a[i]);
		printf("%d\n",ans);
		start=++tot;
	}
	return 0;
}
```

---

## 作者：STA_Morlin (赞：5)

[题目](https://www.luogu.com.cn/problem/P10696)

## 思路简析

可以看到最终的得分是由两个分通过 `&` 操作得出，显然对于任意两个数，只有两数相同时才都不会减小，否则两数必然有一个减小（`&` 运算要求两个位上全是 $1$ 运算才为 $1$。）。

所以只有最大值和自己做 `&` 运算时结果才最大，然后也就不用进行 `&` 运算了。

## _CODE_
Time complexity：$O(Tn)$

```cpp
#include <bits/stdc++.h>
namespace {
#define filein(x) freopen(x".in", "r", stdin)
#define fileout(x) freopen(x".out", "w", stdout)
#define files(x) filein(x), fileout(x)
using namespace std;
#define ll long long
#define db double

const int man = 1e5+10;
}

int T, n, res;
int main () {
#ifndef ONLINE_JUDGE
    files("test");
#endif
    scanf("%d", &T);
    while (T --) {
        scanf("%d", &n);
        res = 0;
        for (int p, i = 1; i <= n; ++ i) scanf("%d", &p), res = max(res, p);
        printf("%d\n", res);
    } return 0;
}

// ---
```

---

## 作者：SXqwq (赞：4)

### Description

给定一个长度为 $n$ 的数组 $a$，求 $\max(a_i\&a_j)(i\le n,j \le n)$
### Analysis

注意到若 $a>b,c=a\&b$，则 $c < a$。因此，我们选相同的数进行 $\&$ 一定更优不劣。

进一步的，显然选 $\max\limits_{i=1}^n a_i$ 让它与自己模最优。因此答案即为 $\max\limits_{i=1}^n a_i$。

实现的时候可以打擂台，也可以排序。反正数据允许。

代码不给了。

---

## 作者：WoodReal12 (赞：3)

前置知识——按位与：

设两二进制数的某一位分别为 $x$ 和 $y$，只有当且仅当 $x=y=1$ 时，答案的这一位才取 $1$，否则取 $0$。

## 思路

我们可以把问题转换为在一个数列 $g$ 中，求 $g_i\&g_j$ 的最大值，其中 $1\le i\le n$ 且 $1\le j\le n$。

因为按位与的性质（见前置知识），所以最大的肯定是 $g$ 数列中的极大值和次大值的按位与的值。

但是，因为本题 $i$ 和 $j$ 可以相等，所以最大的就是 $g$ 数列中的极大值与上自己，即答案为：
$\max\limits_{i=1}^{n} g_i$。

## 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#define int long long
#define x first
#define y second
#define pii pair<int,int>
using namespace std;
int T;
signed main(){
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		int g[200005];
		int mx=0;
		for(int i=1;i<=n;i++){
			cin>>g[i];
			mx=max(mx,g[i]);
		}
        cout<<mx<<endl;
	}
	return 0;
}
```

---

## 作者：suyi1111 (赞：2)

因为 $a$ 与 $b$ 必定不会 $>\max(a,b)$，所以直接交两份得分最高的代码就好了

```
#include<bits/stdc++.h>
using namespace std;
int t,n; 
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		int ma=0;
		for(int i=1;i<=n;i++){
			int x;
			cin>>x;
			ma=max(ma,x);
		}
		cout<<ma<<'\n';
	}
	return 0;
}

```

---

## 作者：qqqaaazzz_qwq (赞：2)

令 $\text{mx}$ 表示 $a$ 序列中的最大值，真正的答案为 $\text{ans}$。

首先，$\text{ans} \geq \text{mx}$。我们把 $\text{mx}$ 提交两遍，因为 $\text{mx}\&\text{mx}=\text{mx}$，所以 $\text{mx}$ 是一种可能的答案。

其次，$\text{ans} \leq \text{mx}$。因为 $a\&b \leq \min(a,b)$，而 $\min(a_i,a_j)$ 的最大值就是 $\text{mx}$，所以 $a_i\&a_j \leq \text{mx}$，即 $\text{ans} \leq \text{mx}$。

综上，$\text{mx} = \text{ans}$。

```cpp
//写都写了，样例也过了，交一发吧
#include <bits/stdc++.h>
#define FAST ios::sync_with_stdio(false);cin.tie(0)
using namespace std;

signed main(){
	int t;
	cin >> t;
	while(t--){
		int n;
		cin >> n;
		int mx = 0;
		for (int i=1;i<=n;i++){
			int qwq;
			cin >> qwq;
			mx = max(mx,qwq);
		}
		cout << mx << "\n";
	}
	return 0;
}
```

---

## 作者：Little_Osmanthus (赞：2)

呜，第一次写题解喵。

相信大家都知道，一个数和任意一个数按位与之后，这个数要么不变，要么变小！

那么就是说，为了让这个数尽可能大，我们肯定要选出最大的数 qwq。

然后的话，我们就让它和自己与一下就可以啦。

那么，我们只要到打擂求最大值啦！

我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
    	int n,ans=0;
    	cin>>n;
    	for(int j=1;j<=n;j++)
    	{
    		int x;
    		cin>>x;
    		ans=max(ans,x);
    	}
    	cout<<ans<<endl;
	}
 	return 0;
}
```

---

## 作者：ChampionCyan (赞：1)

~~大水题，比 T1 还水。~~

## 思路

容易得出 $a$ 位与 $b$ 一定小于 $\max(a, b)$。

则选择最大值两次一定是最优解之一，因为根据位与运算的法则其得分必然等于最大值。

易得其他选择根据位与运算的法则一定小于等于最大值，因此我们的选择一定是最优解之一。

### 码

码就很简单了：
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
    int ret = 0;
    char ch = getchar();
    while (ch < '0' && ch > '9')
        ch = getchar();
    while (ch >= '0' && ch <= '9') {
        ret = ret * 10 + ch - '0';
        ch = getchar();
    }
    return ret;
}

int main() {
    int t = read();
    while (t--) {
        int n = read(), maxn = 0;
        for (int i = 0; i < n; i++) {
            int x = read();
            maxn = max(maxn, x);
        }
        printf("%d\n", maxn);
    }
    return 0;
}
```

---

## 作者：fangminding (赞：1)

此题题意为在一列数中找出两个数（可以是同一位置上的数，也可以相同），求它们做为位运算得到结果的最大值。

可以发现两数位与后结果一定小于等于两数中更小值，即越与越小，故所取两数应当均为此数列中的最大值。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int T,n,maxx,tmp;
	cin>>T;
	for(int asdf=1;asdf<=T;asdf++)
	{
		cin>>n;
		maxx=-1;
		for(int i = 1;i <=n;i++)
		{
			cin>>tmp;
			maxx=max(maxx,tmp);
		}
		cout<<maxx<<endl;
	}
	return 0;
}
```

---

## 作者：Eason_cyx (赞：1)

签到题。

思考 $\&$ 运算的本质。

$\&$ 运算在运算过程中，会判断两个数二进制表示下的每一位，如果有一个数这一位是 $0$，那么结果的这一位就是 $0$。

所以，$\&$ 运算只有在运算两个相同的数才会相等，否则答案一定会比两个数都小。

回到题目，得出结论：将两份不同的代码提交一定是不优的，最优解就是将分数最高的代码提交两次即可。

单次时间复杂度 $\Theta(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;cin>>t;
    while(t--){
        int n;cin>>n;
        int maxn=0;
        for(int i=1;i<=n;i++){
            int x;cin>>x;maxn=max(maxn,x);
        }
        cout<<maxn<<endl;
    }
    return 0;
}
```

---

## 作者：zhengpie (赞：1)

### 1.思路

诈骗题。

容易发现，对于任意一个正整数 $x$ 进行按位与运算后，一定不大于它本身。

- 如果 $x$ 转换为二进制后的某一位是 $0$，那么与运算后的该位也是 $0$，不大于它本身。

- 如果 $x$ 转换为二进制后的某一位是 $1$，那么与运算后的该位是 $1$ 或 $0$，不大于它本身。

于是，对于每一组数据，取最大值即可。

### 2.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
signed main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n;
		int maxn = -2147483647;
		for(int i = 1,x;i <= n;i++) cin>>x,maxn = max(maxn,x);
		cout<<maxn<<"\n";
	}
	
	return 0;
	
}
```

---

## 作者：Last_kiss_Snow_Dog6 (赞：1)

### 判断
通过样例一的解释可以明白一段代码可以交两次，本身和本身做按位与运算的话还是本身，而两个数做按位与最大就是本身，所以直接找最大数判断即可。

### 代码（本人不习惯写注释可私信）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		int a;
		cin>>a;
		int maxn=-10000;
		while(a--)
		{
			int b;
			cin>>b;
			if(b>maxn) maxn=b;
		}
		cout<<maxn<<endl;
	}
}
//ღゝ◡╹)ノ♡
```

---

## 作者：Vct14 (赞：0)

~~观察样例，得到我们提交两次最高分即可。~~

由按位与运算的定义，$a\&a=a$，而因为一个数按位与另一个较小的数后的每一位都小于等于原数，所以 $a\&b<a$（$a>b$）。注意到题目中提到两次可以提交同一份代码，那么提交两次得分最高的代码一定是最优的。

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t;cin>>t;
	while(t--){
		int n,a;cin>>n;
		int mx=-1;
		while(n--){
			cin>>a;
			if(a>mx) mx=a;
		}
		cout<<mx<<"\n";
	} 
	return 0;
}
```

---

## 作者：luckyqwq (赞：0)

# P10696 [SNCPC2024] 写都写了，交一发吧 题解

### 大致思路：

这道题目可以通过看样例去做出这道题目，我们会发现，第 $1$ 个样例中，最优解是 $15$ 选两次，样例 $2$ 中，虽然他写的是第一和第二个数，但实际上可以合并为 $10$ 选两次，到这步，基本就可以确定一个性质 $a_i \& a_i$ 答案依旧是 $a_i$。

如果还要延伸一些就是分类讨论：

- 两个大小相同的数，也就是上面讲的，答案不变，依旧是进行操作的这个数。

- 两个大小不相同的数，我们把两数中，较大的那个数记作 $x$，另一个数记为 $y$，则能得到一个公式 $x \& y$ 答案必定小于 $x$。

那么从第二个类别中可知，如果都变小了，那不如不变，所以输出所有数中最大的数即可。

### 代码实现：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 10;
inline int read()
{
	int r = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if(c == '-')
		{
			w = -1;
		}
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}
int T, n, a[N], mx = -1;
signed main()
{
	T = read();
	while (T --)
	{
		int mx = -0x3f;
		n = read();
		for(int i = 1;i <= n; ++ i)
		{
			a[i] = read();
			mx = max(a[i], mx);
		}
		cout << mx << "\n";
	}
	return 0;
}
```

这样这道题目就完成啦！！！

---

## 作者：nightwatch.ryan (赞：0)

### 思路
先说一下结论，直接输出最大的 $g_i$ 即可。

因为根据按位与的性质，只有同时为 $1$，才为 $1$。所以在本题中，最大的 $g_i$ 按位与自己才能得到最高分。
### 代码
```cpp
#include<iostream>
#include<climits>
#define int long long
int x,n,t;
signed main(){
	std::ios::sync_with_stdio(0);
	std::cin>>t;
	while(t--){
		std::cin>>n;
		int mx=LLONG_MIN;
		for(int i=1;i<=n;i++){
			std::cin>>x;
			mx=std::max(mx,x);
		} 
		std::cout<<mx<<"\n"; 
	}
}
```

---

## 作者：Jorisy (赞：0)

首先，对于一个 $a$ 进行按位与操作，很难不发现最后得到的结果一定不大于 $a$（因为只会让 $1$ 可能地变成 $0$，从而变小）。

因此，要最大化结果，我们只要考虑对于最大数和自己与一下即可。
```cpp
#include<bits/stdc++.h>
using namespace std;

void sol()
{
	int n,ans=0;
	cin>>n;
	while(n--)
	{
		int x;
		cin>>x;
		ans=max(ans,x);
	}
	cout<<ans<<endl;
}

int main()
{
	ios::sync_with_stdio(0);
	int t;
	cin>>t;
	while(t--) sol();
 	return 0;
}
```

---

## 作者：chenlongli (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10696)
### 思路
因为题目中要求只能选 $2$ 份成绩，按照按位与的特性，$g_i \& g_j$ 一定不会比 $\max(g_i,g_j)$ 大，所以我们可以直接将最大值取 $2$ 次，答案为序列 $g$ 的最大值。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	for (int i=0;i<t;i++)
	{
		int n;
		cin>>n;
		int a[n];
		for (int j=0;j<n;j++)
		{
			cin>>a[j];
		}
		sort(a,a+n);
		cout<<a[n-1]<<endl;
	}
}
```

---

## 作者：lcfollower (赞：0)

签到题。

解决这题我们需要知道按位与的性质：

- $a\operatorname{and} a= a$

- $a\operatorname{and} x \le a$。

对于每个数最多按位与两次，通过性质一可得按位与一次即可。

通过性质二，我们可以得出最大的得分为 $\max_{i = 1}^n a_i$。

问题就转换成了求每组数据的最大值。


```cpp
#include<bits/stdc++.h>
#define int long long
#define little_dog puts("OvO,2021zjhs005 is better than me.")
#define lcfollower break
#define _2021zjhs005 continue
#define inf 0x3f3f3f3f
#define infi 0x3f3f3f3f3f3f3f3fll
#define up(i,x,y) for(register int i=x;i<=y;++i)
#define dn(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();return x*f;}
inline void write(int x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10|48);}
inline void writeln(int x){write(x),putchar('\n');}
inline void writesp(int x){write(x),putchar(' ');}

int T;

signed main(){
  T = read();
  while(T --){
    int n = read();
    int y = read() ,ans = y;
    up(i,2,n){int x = read();ans = max(ans ,x);}
    writeln(ans);  
  }
  return 0;
}
```

---

## 作者：Programming_Konjac (赞：0)

# 思路
我们发现与运算只会变小，所以我们找到最大的那个数，提交两次，就能得到正确答案。

简单化来说：找到数组中最大的数进行输出。

注意：这题要开 `long long`！
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	ios::sync_with_stdio(false); 
	int t;
	cin>>t;
	while(t--){
		int n;
		long long maxx=0;
		cin>>n;
		for(int i=1; i<=n; i++){
			ll a;
			cin>>a;
			maxx=max(maxx,a);
		} 
		cout<<maxx<<"\n";
	}
	return 0;
}
```

---

## 作者：yfl20130101 (赞：0)

### 思路
根据与运算的性质，每一位的数字只能是 $1$ 变 $1$、$1$ 变 $0$ 或 $0$ 变 $0$，即两个数字进行与运算一定小于等于两数的较大值，故提交两次得分最大的代码最好。
### 代码
```cpp
#include<iostream>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		int maxx=0;
		for(int i=1;i<=n;i++){
			int k;
			cin>>k;
			maxx=max(maxx,k);
		}
		cout<<maxx<<'\n';
	}
	return 0;
}
```

---

## 作者：JYX0924 (赞：0)

这道题其实就是输出数列中的最大值。

证明：不妨先看一下下面两个数的与运算。

```
10 二进制：1010
7  二进制：0111
与运算结果：2
```

我们可以得到一个结论，对于任意正整数 $a$，正整数 $b$，两个数的与运算结果为 $c$，都有 $c \le a $，$c\le b$。因此，最优方案显然是找到数列中最大的数，然后自己和自己与运算。

下面是我的 AC 代码。

```c
#include<bits/stdc++.h>
using namespace std;
int T,ans;
int main()
{
    cin>>T;
    while(T--)
    {
        int n; cin>>n;
        for(int i=1;i<=n;i++)
        {
            int x; cin>>x; ans=max(ans,x);
        }
        cout<<ans<<"\n"; ans=0;
    }
    return 0;
}
```
谢谢大家！！！

---

## 作者：xiaoyang111 (赞：0)

## 前言

[题目传送门。](https://www.luogu.com.cn/problem/P10696)

## 题解

### 思路

题意其实就是求这个序列中随便选两个数，最大按位与，数可以选同一个位置上的。

首先，容易发现一个数按位与随便一个数，是不可能大于原来自己的。因为是与运算嘛，从位的角度看，怎么可能会多数呢，每一位只会不变或少。可以理解为根本无力回天。

那么，其实这个问题的最优就是最大值按位与自己，这样是最大的。因为他自己按位与其他数，可能会变小啊。如果拿小的数，他不可能变大，更不可能大于最大值。

所以，答案就是序列中的最大值。

### 代码

这个应该很容易实现吧。

```cpp
#include <iostream>
using namespace std;
int n;
int ans=0;
int num;
void solve(){
    scanf("%d",&n);
    ans=0;
    for (int i=0;i<n;++i){
        scanf("%d",&num);
        ans=max(ans,num);
    }
    printf("%d\n",ans);
}
int main(){
    int T;
    cin >> T;
    for (int _=0;_<T;++_){
        solve();
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

你说得对，但一个数按位与上任何数绝对不可能比他大。

那么我们对于一个 $a_i$，最优就是按位与他自己，与完后还是 $a_i$。

那么问题就变成找到一个 $a_i$，让他最大。

那么直接排个序然后输出 $a_n$ 即可。

---

## 作者：TemplateClass (赞：0)

因为在按位与运算中，每个二进制位都不会从 $0$ 变为 $1$，所以按位与不可能使一个数更大。由此不难得出，按位与能得到的最大值即为序列 $g$ 中的最大值。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
//#define int long long

const int N = 1e6 + 5;
const int MOD1 = 998244353;
const int MOD2 = 1e9 + 7;
int n;

int t = 1;
void solve();

signed main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	
	std::cin >> t;
	while(t--) solve();
	
	return 0;
}

void solve(){
	int n;
	std::cin >> n;
	int max = -1;
	
	for(int i = 1; i <= n; ++i) {
		int s;
		std::cin >> s;
		max = std::max(max, s);
	}
	
	std::cout << max << '\n';
}

```

---

## 作者：charlieqi (赞：0)

其实，如果仔细观察样例，可以发现，输入的每组数据，输出它的最大值即可。复杂度 $O(nt)$。
# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a,ans;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		ans=-1e9;\\判断最大值，初始值小。
		while(n--){
			cin>>a;
			ans=max(ans,a);
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Scean_Tong (赞：0)

## P10696 [SNCPC2024] 写都写了，交一发吧题解

## 思路
注意题面中有一句话：和你正在参加的比赛类似，两次不同提交的代码可以是同一份，也可以不同。根据 $\&$ 运算的性质，答案就是 $n$ 个数中的最大数 $\&$ $n$ 个数中的最大数，即为 $n$ 个数中的最大数。

注意如果用数组的话千万不要在读入 $n$ 之前用 `memset` 清空，会爆零的。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
const int maxn=2e5+7;
int g[maxn];
int n;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		int ans=0;
		for(int i=1;i<=n;i++){
			cin>>g[i];
			ans=max(ans,g[i]);
			g[i]=0;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：tyccyt (赞：0)

# 简化题意

求
$$
\max_{i=1}^{n}\max_{j=1}^{n} g_i \& g_j
$$

# 思路

我们知道与运算有个性质：
$$
a\& b\le b\\
a\& b\le a
$$

所以 $g_i \& g_i$ 肯定优于 $g_i\& g_j$ 的。

那么其实就是在求 $\max g_i$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int t,n,a[N];
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		int maxx=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			if(maxx<a[i])maxx=a[i];
		}
		cout<<maxx<<'\n';
	}
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

我们的最优策略是：交两次 $g_i$ 最大的代码。

为什么这样是对的呢？根据按位与的性质，两个数相与的结果必然不大于这两个数。证明这个性质，我们可以分类讨论：

- 当两个数相等，因为每个二进制位都相同，所以按位与后结果仍然等于两数。

- 当两数不相等时，二进制位有不同，所以会导致那一位变为 $0$（因为 $1 \& 0 = 0$），因此答案不会增加，故性质成立。

所以说，当 $g_i \ne g_j$ 时，$g_i \& g_j \le g_i, g_j$。而当 $g_i = g_j$ 时，$g_i \& g_j = g_i = g_j$。所以交两次 $g_i$ 最大的代码为最优策略。

参考代码如下：

```cpp
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")
#define _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
#define ll long long
#define writes(x) write(x), putchar(' ')
#define writeln(x) write(x), putchar('\n');
static char buf[100000], * pa(buf), * pb(buf);
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pb) ? EOF : *pa++
using namespace std;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
template <typename T> void read(T& x) {
    T t = 0, sgn = 1;
    char ch = gc;
    while (!isdigit(ch)) {
        if (ch == '-') sgn = -sgn;
        ch = gc;
    }
    while (isdigit(ch)) {
        t = (t << 3) + (t << 1) + (ch ^ 48);
        ch = gc;
    }
    x = sgn * t;
}
template <typename T, typename ...Args> void read(T& tmp, Args &...tmps) {
    read(tmp); read(tmps...);
}
template <typename T> void write(T x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
template <typename T, typename ...Args> void write(T& tmp, Args &...tmps) {
    writes(tmp);
    writes(tmps...);
}
template <typename T> T rand(T l, T r) {
    return rnd() % (r - l + 1) + l;
}
int main() {
    int t;
    read(t);
    while (t--) {
        int n;
        read(n);
        ll amanx = 0;
        for (int i = 1; i <= n; i++) {
            ll a;
            read(a);
            amanx = max(amanx, a);
        }
        writeln(amanx);
    }
}
```

---

## 作者：Genshin_ZFYX (赞：0)

两数进行按位与操作，结果不会大于较小数；两个相同的数进行按位与操作，结果还是这个数。答案最大即为数列中的最大数。

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define I return
#define love 0
#define FIRESTARS ;
signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    int t;cin>>t;
    while(t--)
    {
    	int n,maxn=0;cin>>n;
    	while(n--)
    	{
    		int x;cin>>x;
    		maxn=max(maxn,x);
		}
		cout<<maxn<<endl;
	}
	I love FIRESTARS
}

```

---

## 作者：Mason123456 (赞：0)

# P10696 题解

感谢考场上 @[G1yu](https://www.luogu.com.cn/user/785505) AC 出来本题！

### 思路

对于任意两个数 $a,b$，其按位与的结果必然比 $\min(a,b)$ 更小，所以既然要选择按位与和更大的数，自然要让 $a,b$ 更大。由于题面没有给出 $i \not = j$，所以要使 $a,b$ 更大，自然，$a=b$ 且 $a$ 为数组中最大的数。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int main () {
  int T;
  cin >> T;
  while (T--) {
    int n, mx = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
      int x;
      cin >> x;
      mx = max(mx, x);
    }
    cout << mx << "\n";
  }
}// 为了不和G1yu重复代码我甚至重写了一遍。
```

---

## 作者：xzz_0611 (赞：0)

[题目传送门](/problem/P10696)
### 分析
显然，两个相同的数去按位与的结果还是该数。

由于一个代码可以提交多次，那么可以把得分最高的代码提交两次，这样的得分就是这个代码的得分，很明显，这样是最优的。
### Code
```cpp
#include<iostream>
using namespace std;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int t;
	cin>>t;
	while(t--) {
		int n,ma=0,arr;
		cin>>n;
		for(int i=0;i<n;++i) cin>>arr,ma=max(ma,arr);//找到最大值
		cout<<ma<<"\n";//直接输出最大值即可
	}
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：0)

~~再抢一发题解！~~
## 解题思路：
由于题目中说可以交统一发代码，辣么我们就可以令**得分最高的那份代码用 $2$ 次**，因为**两个一样的数按位与是自己本身**，就可以得到最高分了。  
这样的话，我们就可以边输入数据，边找出分数最大值，输出它就好了。
## CODE:
```cpp
#include <iostream>
using namespace std;
int t, n, a;
int main()
{
    cin >> t;
    while (t--)
    {
        int maxn = 0;
        cin >> n;
        while (n--)
        {
            cin >> a;
            maxn = max(maxn, a);
        }
        cout << maxn << '\n';
    }
    return 0;
}
```

---

## 作者：abc1856896 (赞：0)

# solution
签到题

因为结果是两个数取并，所以我们直接输出序列中的最大时即可。

# code
```cpp
void solve(){
    int n;
    cin>>n;
    int maxx=-1;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        maxx=max(maxx,x);
    }
    cout<<maxx<<endl;
}
```

---

## 作者：LG086 (赞：0)

### 分析

注意到题目中的关键句：

> 形式化地，如果他分别在两次提交中提交了第 $i$ 和第 $j$ 份代码，则得分为 $g_i \& g_j$，其中 $\&$ 表示按位与运算。

因为 $a\&b\le\min(a,b)$，但是 $a\&a = a$，所以最高分就是数据中的最大值**自己按位与运算自己**的结果。答案其实就是最大值。

------------
### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int T,n,a,b;
signed main(){
    cin>>T;while(T--){
        cin>>n,b=0;
        while(n--)cin>>a,b=max(a,b);
        cout<<b<<"\n";
    }
}
```

---

## 作者：Arthur_Douglas (赞：0)

## 思路

首先，我们知道，同一份代码可交两次，然后我们知道与的性质就是全为 $1$ 则为 $1$，否则为 $0$。所以最优情况就是最大值与上最大值还是最大值。

毕。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int g[200001];
void read(int &a)
{
	a = 0;
	char c = getchar(); 
	while(c < '0' || c > '9')
	c = getchar();
	while(c >= '0' && c <= '9')
	a = (a << 3) + (a << 1) + (c & 15) , c = getchar();
}
signed main()
{
    int T;
    cin >> T;
    while(T --)
    {
    	int n , maxn = -1;
    	read(n);
    	for(int i = 1;i <= n;++ i)
    	read(g[i]) , maxn = max(maxn , g[i]);
    	printf("%d\n" , maxn);
    }
    return 0;
}
```

---

## 作者：luogu_gza (赞：0)

问题抽象为 $\max_{i=1}^{n}\max_{j=1}^{n}g_i \operatorname{and} g_j$。

注意到越与越小，所以直接让最大的一个自己和自己与即可了。

答案就是序列最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace gza{
	#define pb push_back
	#define MT int TTT=R;while(TTT--)
	#define pc putchar
	#define R read()
	#define fo(i,a,b) for(int i=a;i<=b;i++)
	#define rep(i,a,b) for(int i=a;i>=b;i--)
	#define m1(a,b) memset(a,b,sizeof a)
	namespace IO
	{
		inline int read()
		{
		    int x=0;
		    char ch=getchar();
		    bool f=0;
		    while(!isdigit(ch)){if(ch=='-') f=1;ch=getchar();}
		    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
		    if(f) x=-x;
		    return x;    
		}
		template<typename T> inline void write(T x)
		{
		    if(x<0) pc('-'),x=-x;
		    if(x>9) write(x/10);
		    pc(x%10+'0');
		}
	};
	using namespace IO;
	
	const int N=1e5+10;
	void solve()
	{
		int n=R,x=0;
		fo(i,1,n) x=max(x,R);
		write(x),puts("");
	}
	void main(){
		MT solve();
	}
}
signed main(){
	// freopen("template.in","r",stdin);
	// freopen("template.out","w",stdout);
	gza::main();
}
```

---


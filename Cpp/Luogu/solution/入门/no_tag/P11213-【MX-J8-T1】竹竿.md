# 【MX-J8-T1】竹竿

## 题目背景

原题链接：<https://oier.team/problems/J8A>。

## 题目描述

有 $n$ 根竹竿，第 $i$ 根竹竿的长度为 $a_i$，在距离一端的 $b_i$ 长度处有一个标记。

现要将所有竹竿放在一条直线上，要求每根竹竿的**标记必须重合**。你可以左右调换每根竹竿的方向，使得这条直线被竹竿覆盖到的部分尽可能长。

请求出被竹竿覆盖到的部分的最大长度。

## 说明/提示

**【样例解释 \#1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/crjj8h0g.png)

**【样例 \#3】**

见附件中的 `bamboo/bamboo3.in` 与 `bamboo/bamboo3.ans`。

该组样例满足测试点 $5 \sim 6$ 的约束条件。

**【样例 \#4】**

见附件中的 `bamboo/bamboo4.in` 与 `bamboo/bamboo4.ans`。

该组样例满足测试点 $10$ 的约束条件。

**【数据范围】**

本题共 $10$ 个测试点，每个 $10$ 分。

|测试点编号|$n\le$|$a_i\le$|$b_i\le$|
| :-----------: | :-------------:|:-----------:|:-----------: |
|$1\sim2$|$10$|$10$|$10$|
|$3\sim4$|$2$|$10^9$|$10^9$|
|$5\sim6$|$1000$|$1000$|$1000$|
|$7$|$10^5$|$10^9$|$0$|
|$8\sim 9$|$10^5$|$10^5$|$10^5$|
|$10$|$10^5$|$10^9$|$10^9$|


对于全部数据，保证：$2\le n\le 10^5$，$1\le a_i\le10^9$，$0\le b_i\le a_i$。

## 样例 #1

### 输入

```
2
5 2
4 3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
4
5 1
5 2
5 3
5 4
```

### 输出

```
8
```

# 题解

## 作者：Tyih (赞：25)

# solution
我们可以根据标记处将木条截成两条，再将所有木条排序，最终答案就是最长木条与次长木条的和。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],l,b;
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
	    cin>>l>>b;
	    a[2*i]=b;
	    a[2*i-1]=l-b;
	}
	sort(a+1,a+1+2*n);
	ans=a[2*n]+a[2*n-1];
	cout<<ans;
	return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：7)

不难发现最多只会左右调换一根竹竿。如果调换了超过一根，一定可以全调回去或者留一根，答案不劣。

不妨枚举调换的是哪一根竹竿。

设 $l_i=b_i,r_i=a_i-b_i$ 是第 $i$ 根竹竿的左右长度。

枚举第 $j$ 根竹竿调换了顺序，那么左侧就是 $\{l_j\mid j\neq k\}$ 和 $r_j$，右侧就是 $\{r_j\mid j\neq k\}$ 和 $l_j$。分别求出左侧和右侧的 $\max$ 相加即可。

直接做可能会实现出 $\mathcal O(n^2)$ 的复杂度，不难发现这是一个前缀和一个后缀，记录前缀 $\max$ 后缀 $\max$ 即可。

更简便的做法本质相同，只是化简了式子，为了防止理不清逻辑这里不细说。

---

## 作者：lzt415 (赞：6)

## 思路分析
略带贪心思想。~~题目不难，毕竟是第一题。~~

大致做法是用一个数组存一下所有的 $b$ 和 $a-b$，然后排序，找最大值和次大值，相加即可。

但是为什么这样就对了呢？？  
因为要覆盖区间最大，所以由 $b$ 点向左和向右的大小都要尽可能大，这样两个相加就最大，但是最大值只有一个，所以就要找次大值，并且这样的做法有一个好处，就是直接避免了错第一个点的情况，即有可能一根杆子覆盖了所有，因为这种排序使 $b$ 和 $a-b$ 分开来了。
## CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000000],n;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a>>b;
		f[i*2-1]=b;
		f[i*2]=a-b;
	}
	sort(f+1,f+n*2+1);
	cout<<f[n*2]+f[n*2-1];
	return 0;
}
```

---

## 作者：icebear233 (赞：4)

# P11213 题解

本做法时间复杂度为 $O(n)$ 


大致题意：
给出许多竹竿，他们被固定在一个点上，每个竹子的固定点可能不同且可以左右翻转，求最大覆盖长度。

思路：既然是固定在一个点上了，那么可以以固定标志点为中心，左右取长度最大值，答案为左右最大长度之和。
（因为可以翻转，所以过程中可以把本为左边的长度拿给右边，右边同理）

写法：判断一边是否大于当前左右最大长度，如果是就更新左右最大长度的最大最短边。如果是左右都大就直接覆盖，注意可翻转（本蒟蒻用了一堆判断。。。但是感觉比较好理解）时间复杂度 $O(n)$ ，具体看代码，有详细注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,l,r,a,b,lm,rm;

int main(){
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a>>b;
		l=b,r=a-b;//本根竹子的两端长度
		if(lm<l&&rm<l){//如新的一边长度大于目前左右任意最大长度
			if(l-lm>l-rm){//取贡献最大的一边
				lm=l,rm=max(rm,r);
			}
			else{//同理
				rm=l,lm=max(lm,r);
			}
		}
		else if(lm<r&&rm<r){//和上面的同理，只是换另外一边
			if(r-lm>r-rm){
				lm=r,rm=max(rm,l);
			}
			else{
				rm=r,lm=max(lm,l);
			}
		}
		else if(lm<l&&rm<r){//如这根竹子左右长度比目前左右最大长度都大，就直接覆盖
			lm=l;
			rm=r;
		}
		else if(lm<r&&rm<l){//换边同理
			lm=r;
			rm=l;
		}
		else if(lm<l){//如新左边长度大于左边最大长度，更新最大左端，右段取最大值
			lm=l;
			rm=max(rm,r);
		}
		else if(lm<r){//下方换边同理
			lm=r;
			rm=max(rm,l);
		}
		else if(rm<l){
			rm=l;
			lm=max(lm,r);
		}
		else if(rm<r){
			rm=r;
			lm=max(lm,l);
		}
	}
	cout<<lm+rm;//输出答案
	return 0;//好习惯
}
```

---

## 作者：CusetVoidAldehyde (赞：4)

一眼过去，这题其实很简单，只需要保存每根竿子长的部分然后排序即可。但是！一交上去只有 90pts，怎么回事呢？

原来是我们有一种情况没有考虑到：如果一根竿子能覆盖全部的竿子，那么这根竿子短的部分也需考虑。因为这根竿子短的部分有可能比其他竿子长的部分还要长。

代码：

```cpp
//Made By Cuset. 喵喵~
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int n;
priority_queue<ll> q, qmin;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        ll a, b;
        cin >> a >> b;
        q.push(max(a - b, b));    // 取每根竿子长的部分
        qmin.push(min(a - b, b)); // 取每根竿子短的部分
    }
    ll t = q.top();
    q.pop();
    cout << t + max(q.top(), qmin.top()); // 判断最长的竿子短的那部分是否比其他竿子长
    return 0;
}
```

---

## 作者：fish_love_cat (赞：4)

因为标记要重合，我们假设所有竹竿的标记都放在原点上。

那么一个竹竿就分为了两部分，一段在负半轴上，一段在正半轴上。

显然的，最后只会有正负半轴上各一条最长的竿子会对答案有贡献。

我们可以贪心的选择最长的两段各放一段在正负半轴，这样是最优的。因为可以翻转所以最长的两段不一定会在同侧，所以合法。

直接统计最大值与次大值即可，时间复杂度 $O(n)$。

赛时代码过于丑陋，不放了。

---

## 作者：4041nofoundGeoge (赞：3)

代码不是很难只要用堆模拟即可。

## 思路

可以模拟一下是覆盖的最小长度，用堆模拟，详情看代码。

代码技术含量不高。大概为普及组的题
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
priority_queue<long long> q, minn;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        long long a, b;
        cin >> a >> b;
        q.push(max(a - b, b));
        minn.push(min(a - b, b));
    }
    long long t = q.top();
    q.pop();
    cout << t + max(q.top(), minn.top());
    return 0;
}
```

---

## 作者：zhenghbkh (赞：3)

# 题意简述

给定 $n$ 段竹竿，每段竹竿有一段刻度，你可以左右调换每根竹竿，使每一段竹竿的标记共线的同时，所有竹竿能覆盖到的长度最大。


# 思路

可以看作是将每段竹竿沿着标记处砍成两段，长度分别为 $b_i$ 和 $a_i-b_i$，此时题目要求的“被覆盖到的部分的最大长度”就是切完后任意两段组成的竹竿长度的最大值，也就是**切完后的最大值与次大值之和**。

# Code


```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5+5;

int n;
int a[N], b[N];
int w[2*N], cnt = 0;

int main(){
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> a[i] >> b[i];
	
	for (int i = 1; i <= n; ++i)
		w[++cnt] = b[i], w[++cnt] = a[i]-b[i]; // 用w数组分别存下每段竹竿刻度线左右的长度
		
	sort(w+1, w+cnt+1);
	
	cout << w[cnt]+w[cnt-1]; // 最大值与次大值之和就是能覆盖到的最大长度
	
	return 0;
}
```

---

## 作者：canwen (赞：3)

赛时唯一有分的题，甚至写了 $72$ min。

## 分析

我们可以考虑维护答案长度的两个端点 $l,r$。不难发现对于一根竹竿只有两种摆放方式，因为标记点可以靠竹竿的任意一端。

所以考虑比较两者谁带来的贡献大。

把所有竹竿的摆放想象成在一条数轴上，而所有需要重合的标记点看成原点，往左为负，往右为正。

综上，考察简单模拟和贪心策略。

献上赛时代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5+5;
int n,l,r;
struct node{
	int a,b;
}e[N];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&e[i].a,&e[i].b);
	}
	l = -e[1].b , r = e[1].a - e[1].b;
	for(int i=2;i<=n;i++){
		int l1=l,l2=l,r1=r,r2=r;
		if(-e[i].b<l1) l1 = -e[i].b;
		if(e[i].a-e[i].b>r1) r1 = e[i].a-e[i].b;
		if(-(e[i].a-e[i].b)<l2) l2 = -(e[i].a-e[i].b);
		if(e[i].b>r2) r2=e[i].b;
		if(r1-l1>r2-l2) l = l1, r = r1;
		else l = l2, r = r2;
	}
	cout << r-l;
	return 0;
} 
```

---

## 作者：zy_oier (赞：2)

思路：找出竹竿标记到两端的距离，再找出第一大的和第二大的距离，分别放到标记左边和右边，就可以求出竹竿覆盖到的部分的最大长度。

话不多说，看代码。
```cpp
#include<bits/stdc++.h>
#define f(n) for(int i=1;i<=n;i++) //懒人专用
using namespace std;
int n,a[100005],b[100005],t[200005],maxn=-1,maxi,ans;
int main(){
	cin>>n;
	f(n){
		cin>>a[i]>>b[i];
		t[i*2-1]=b[i],t[i*2]=a[i]-b[i];	//计算标记到竹竿两端的距离
	}
	f(n*2)if(t[i]>maxn)maxn=t[i],maxi=i;//求出标记到竹竿端点的距离最大值
	ans=maxn,t[maxi]=-1,maxn=-1;//记录最大值，将最大值赋值为-1，重置找最大值的变量
	f(n*2)maxn=max(maxn,t[i]);//找出次大值
	cout<<ans+maxn;//加上最大值和次大值，算出答案
    return 0;
}
```

---

## 作者：zbzbzzb (赞：2)

我们把所有的 $b_i$ 对齐到 $0$。

然后直接处理出每条竹竿的左右端点，然后判断是不是最优的（可以覆盖到最长的区间），不是的话那么把竹竿翻转。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long cntl,cntr,l[100010],r[100010],b[100010];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&r[i],&b[i]);
		r[i]-=b[i];
		l[i]=0-b[i];//左端点
	}cntl=l[1],cntr=r[1];
	for(int i=2;i<=n;i++){
		long long mx=l[i],mi=r[i],l1=0-r[i],r1=0-l[i];
		if((cntl-min(cntl,mx))+(max(mi,cntr)-cntr)>(cntl-min(cntl,l1))+(max(r1,cntr)-cntr)){//判断这样放是不是最优
			cntl=min(cntl,mx),cntr=max(mi,cntr);
		}else{
			cntl=min(cntl,l1),cntr=max(r1,cntr);//不是，翻转
		}
	}printf("%lld",cntr-cntl);//最后放的左右端点
	return 0;
}
```

---

## 作者：Wei_ch (赞：2)

### 思路
竹竿的标记必须重合，也就是竹竿被分成了左右两截。又得知竹竿可以被翻转，所以我们只需要找到所有被截断的 $ 2n $ 条中最长的两条再相加就可以了。

### 实现
可以用把左右两截的存进数组中，然后排序或遍历找最大与第二大值来解决问题。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
bool cmp(int a,int b){
    return a>b;
}
int main(){
    int n,s[200005],a,b;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d %d",&a,&b);
        s[i*2-1]=b;
        s[i*2]=a-b;
    }
    sort(s+1,s+2*n+1,cmp);
    long long d=s[1]+s[2];
    printf("%d",d);
}

```

---

## 作者：zhaisx (赞：1)

### 思路

可以用重合的标记点把覆盖到的部分分成两半，求每一半的最大长度，再相加。

求每一半的最大长度，就是求所有竹竿中的以标记区分的两部分 $b_i$ 和 $a_i - b_i$ 中长度最长的两个。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, a, b, m1 = 0, m2 = 0, p, q;
    // m1, m2 分别代表长度最长的两个
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a >> b;
        // p, q 分别代表竹竿的两部分
        p = b;
        q = a - b;
        // 更新 m1, m2
        if (p >= m1) {
            m2 = m1;
            m1 = p;
        } else if (p >= m2)
            m2 = p;
        if (q >= m1) {
            m2 = m1;
            m1 = q;
        } else if (q >= m2)
            m2 = q;
    }
    // 结果为长度和
    cout << m1 + m2 << '\n'; 
    return 0;
}
```

### 附言

如果只拿了 $90$ 分，并且第一个点 WA，要记得不是用 $\max(p, q)$ 更新，而是分别用 $p$ 和 $q$ 更新。

---

## 作者：Defy_HeavenS (赞：1)

## 思路

首先有个结论，对于由一堆互相有重叠的线段覆盖的一段区间，仅至多有两条线段是有价值的，就是左边覆盖最长的和右边覆盖最长的（也可能是一条线段）。

因为此题线段都会重叠且可以任意调换方向，所以我们只在乎最长能覆盖多少，不在乎左右。

把每根竹竿标记点左端的长度和右端的长度记录下来，最后贪心选最长的两个长度，然后求和即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define yes cout<<"YES\n"
#define no cout<<"NO\n"
#define pb push_back

using namespace std;
typedef long long LL;
typedef pair<LL,LL> PII;

const LL N=1e5+5;
LL n,a[N],b[N],c[N];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(LL i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		c[i]=b[i];
		c[i+n]=a[i]-b[i];
	}
	sort(c+1,c+1+n+n);
	cout<<c[n+n]+c[n+n-1];
	return 0;
}
/*

*/
```

---

## 作者：JoeZYQ (赞：1)

### 思路
不难发现，只有竹竿上标记的两端的长度会影响到这条直线被竹竿覆盖到的部分，所以我们将竹竿上标记的两端的长度排个序，取出最长与次长的部分即可。
### 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int a[N],b[N],n,ma,cma,c[N*5],m; 
signed main(){
	ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		c[++m]=b[i];
		c[++m]=a[i]-b[i];
	}
	sort(c+1,c+1+m);
	cout<<c[m]+c[m-1];
	return 0;
}

~~~

---

## 作者：MournInk (赞：1)

> 签到题。

根据题意描述，所有竹竿的标记必须**重合**。

此时对标记的两边分别讨论，不难想到，我们只需要任一侧最长的竹竿，其他的竹竿不会对该侧长度有任何贡献。

那么解题思路就很清晰了，我们将竹竿（视作）从标记点分割，此时产生了 $2n$ 个（小）竹竿。将所有（小）竹竿的长度从大到小排列，则答案为前 $2$ 大的（小）竹竿长度之和。

参考代码：

~~~cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    #define int long long
    int n;
    cin >> n;
    vector<int>v;
    for(int i = 0; i < n; i ++)
    {
        int a, b;
        cin >> a >> b;
        v.push_back(b), v.push_back(a - b);
    }
    sort(v.begin(), v.end(), greater<int>());
    cout << v[0] + v[1];
    return 0;
}
~~~

---

## 作者：ShizukuQWQ (赞：1)

考虑将竹竿根据标记分为两段，答案即为竹竿长两端最大值。把最大值放右，次大值放左即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF=1e16,N=1e5+5;
long long n,a[N],b[N],c[N],mx,mn;
int main(){
//	freopen("bamboo4.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		if(a[i]-b[i]>mx) mn=mx,mx=a[i]-b[i];
		else if(a[i]-b[i]>mn) mn=a[i]-b[i];
		if(b[i]>mx) mn=mx,mx=b[i];
		else if(b[i]>mn) mn=b[i];
	}
	cout<<mx+mn;
}

---

## 作者：lihl (赞：0)

### 60 分
赛时做法。

维护左端最大值 $l$ 和右端最大值 $r$，考虑竹竿 $i$ 对 $l$ 和 $r$ 的贡献为 $l=\max(l,b_i)$ 和 $r=\max(r,a_i-b_i)$ 即可。

时间复杂度 $O(n)$。
### 100 分
在维护左右端最大值时，需考虑到 $\max(l,a_i-b_i) + \max(r,b_i) > \max(l,b_i)+\max(r,a_i-b_i)$ 的情况，选择较大的答案并维护 $l,r$ 即可。

时间复杂度 $O(n)$。

---

## 作者：2c_s (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11213)

## 思路

贪心。

容易发现，将若干根柱子绕定点旋转，形成若干个同心圆。我们要求的即为两条在**同一直线上**最大的半径之和。

这时有两种情况，一种是半径不一定最大，但是**直径（总长）最大**；另一种是两个不同半径的半圆**拼在一起形成的“直径”最大**。

我们读入数据后求出每根竹子绕定点形成的“半径”和竹子总长（即为直径），取最大直径和**两条最大的半径之和**中较大者输出。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read(){
	ll k=0;bool flag=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')flag=0;c=getchar();}
	while(isdigit(c)){k=(k<<1)+(k<<3)+(c^48);c=getchar();}
	if(flag)return k;return -k;
}
const int N=1e5+10;
int n;
struct node{
	int l,r,len;
}a[N];
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		a[i].len=read();//“直径”。
		a[i].l=read();//两个“半径”。
		a[i].r=a[i].len-a[i].l;
	}
	sort(a+1,a+1+n,[](node a,node b){return max(a.l,a.r)>max(b.l,b.r);});
	int ans=max(a[1].l,a[1].r)+max(a[2].l,a[2].r);//最大“半径”长度和。
	sort(a+1,a+1+n,[](node a,node b){return a.len>b.len;});
	cout<<max(ans,a[1].len)<<"\n";
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/183472187)

---

## 作者：Lijiangjun4 (赞：0)

# P11213 题解
## 解题思路
我们可以在直线上以**标记点**为原点建一条数轴，则把竹竿放在直线上的操作看做：以竹竿的标记点为界把竹竿砍成两部分，一部分放在正半轴上，一部分放在负半轴上（端点都在原点上），则将最长的一部分放在正半轴上，次长的一部分放在负半轴上，即可得到最优解。
## AC Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100005],b[100005],n,max1,max2;
int main()
{
//	freopen("bamboo4.in","r",stdin);
//	freopen("bamboo4.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
		a[i]-=b[i];
		if(a[i]>max1)
		{
			max2=max1;
			max1=a[i];
		}
		else if(a[i]>max2) max2=a[i];
		if(b[i]>max1)
		{
			max2=max1;
			max1=b[i];
		}
		else if(b[i]>max2) max2=b[i];
	}
	cout<<max1+max2<<'\n';
	return 0;
}
```

---

## 作者：AZYDLL (赞：0)

依题，以 $b_i$ 处为中心，编号为 $i$ 的一根竹竿可能会对答案（覆盖范围）产生两种贡献：

* 左端到 $b_i$：$ansL_i=b_i$

* 右端到 $b_i$：$ansR_i=a_i-b_i$

因为竹竿的方向可以左右调换，所以对于一根竹竿 $i$，$ansL_i$ 与 $ansR_i$ 是可互换的。

于是我们的答案就是：

$$
ans=\max_{1 \le i,j \le n} \{ansL_i+ansR_j\}
$$

代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define int long long

using namespace std;

int n,a,b,maxx1,maxx2;

void change(int num)
{
    if(num>maxx2){
        maxx1=maxx2;
        maxx2=num;
    }
    else if(num>maxx1) maxx1=num;
    else return ;
    return ;
}

signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a>>b;
		change(a-b);
		change(b);
	}
	cout<<maxx1+maxx2<<endl;
	
	return 0;
}
```

---


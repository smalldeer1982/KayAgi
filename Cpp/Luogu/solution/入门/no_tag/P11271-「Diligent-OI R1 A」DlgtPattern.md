# 「Diligent-OI R1 A」DlgtPattern

## 题目描述

现有一个水杯放在一个不透明的盒子中。水杯的底面可以看成一个圆形。盒子可以看成一个长方体，其厚度忽略不计。

现将盒子的底面放在一个平面直角坐标系中，它的四个顶点分别位于 $(0,0)$，$(x,0)$，$(0,y)$ 和 $(x,y)$。

你只知道水杯底面的圆心位于 $(p,q)$。那水杯底面的半径最大可以是多少呢？

## 说明/提示

#### 样例 #1 解释

水杯半径最大的情况如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/gpbwxjuj.png)

#### 数据范围

对于 $100\%$ 数据，$0<p<x\le100$，$0<q<y\le100$。

| 测试点编号 | 特殊性质 |
| :----------: | :----------: |
| $1\sim 4$ | AB |
| $5\sim 6$ | B |
| $7\sim 10$ | 无 |

特殊性质 A：$x=y$。

特殊性质 B：$x=2p,y=2q$。即水杯底面的圆心在盒子底面的几何中心。

## 样例 #1

### 输入

```
10 5 3 4```

### 输出

```
1```

# 题解

## 作者：easy42 (赞：5)

比较简单。

看一下图：
![rt](https://cdn.luogu.com.cn/upload/image_hosting/gpbwxjuj.png)
显然我们需要选取一个边长，使它离边的距离最大。

那怎么求呢？

显然，圆的四条半径是相同的，所以我们只要把圆心至四条边长的距离表示出来，取最大值即可。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int x,y,p,q;
int main(){
    cin>>x>>y>>p>>q;
    cout<<min({p,q,x-p,y-q});
    return 0;
}
```

---

## 作者：sunhaozhe111022 (赞：3)

**思路：**

我们发现，求最大半径其实就是求水杯底面的圆心离不透明的盒子的四条边最近的那条线段是多少。

圆心到盒子左边的距离：$p$

圆心到盒子左边的距离：$q$

圆心到盒子左边的距离：$y-q$

圆心到盒子左边的距离：$x-p$

我们只需要计算这些值的最小值即可。


**代码实现：**
```
#include<bits/stdc++.h>
using namespace std;
int x,y,p,q,a[105][105];
int main()
{
	cin>>x>>y>>p>>q;
	cout<<min(min(p,q),min(x-p,y-q));
	return 0;
}

---

## 作者：许多 (赞：1)

很好的一道签到题。

![题目](https://cdn.luogu.com.cn/upload/image_hosting/gpbwxjuj.png)

我们直接利用题目所给图，由数学知识不难得到，半径最大时这个圆必定与至少一条线相切。所以我们求一下圆心到各边界的距离，取最小值即可。

## code


```cpp
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int main(){
    int x=read(),y=read(),p=read(),q=read();
    cout<<min(min(x-p,p),min(y-q,q));
    return 0;
}
```

---

## 作者：DDD_et (赞：0)

# P11271 Solution

**做法：数学**

## 题意

给定一个长方形四个角的坐标，分别为 $(0,0)$，$(x,0)$，$(0,y)$ 和 $(x,y)$。现要在长方形中画一个圆心坐标为 $(p,q)$，并且不超出长方形四边的圆，求圆的最大半径。

## 思路

~~入门题有啥思路好讲的~~

我们发现，圆的半径最大，那么圆的半径一定是能刚好达到至少一条长方形的边的。

证明：如圆的半径没有碰到任何一条边的话，此时显然可以继续增加半径直到达到至少一条边**为止**。

那么如果达到了一条边上，就要看圆是否超出了其他边，发现如果达到的边是**任何一条不是离圆心最短边的边**，那么圆的半径一定会超出**离圆心最短的边**，所以我们只能选从**离圆心最短的边**到圆心的距离作为半径。

最终选取 $4$ 条边中离圆心最近的边与圆心的距离输出即可。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
int x, y, p, q;

int main ()
{
    cin >> x >> y >> p >> q;
    cout << min ({p, x - p, q, y - q});
    //min函数中的p和q其实应写为p-0和q-0，为简便省去了
    return 0;
}
```

### 写在最后

对于如何求平面直角坐标系上两个**位于同一水平轴**的点之间的距离，可以将两点的**垂直坐标**相减后取绝对值（或是在确定两者大小关系后以大减小），另一条轴上也同理（**给新手看的哦**）。

**谢谢观看！**

---

## 作者：Nancy_Cherry (赞：0)

## 题目简述

将一个圆心位于 $(p, q)$ 的圆放进一个平面直角坐标系中，该平面直角坐标系的四个顶点分别位于 $(0,0)$，$(x,0)$，$(0,y)$ 和 $(x,y)$。

## 思路

小学六年级知识点：方中画圆。

显然的，圆的大小取决于圆心的位置（值得注意的是，本题里的位置影响圆的大小）以及圆的半径。

那么要想圆的半径最大，就得看他距离最短的边有多大。

再次把圆放到平面直角坐标系中，则只需要求出 $p, \space x-p, \space q, \space y-q$ 中最小的即可。

因为左右两端可以交换，所以取的值就变成了圆的两侧半径其一的一点位于平面直角坐标系的边界上，求这个点到圆心的距离即可。

注意，因为此处 $p,q$ 可以取 $0$，所以非 $q - y$， 而是 $y - q$。


## 代码实现


```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int x, y, p, q;
	cin >> x >> y >> p >> q;
	if(x == 0 || y == 0) {
		cout << 0;
		return 0;
	}
	cout << min(p, min(x - p, min(q, y - q))); // 取其中最小的值 
    return 0;
}
```

---


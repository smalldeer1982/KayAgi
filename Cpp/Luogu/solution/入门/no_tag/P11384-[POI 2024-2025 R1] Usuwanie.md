# [POI 2024/2025 R1] Usuwanie

## 题目背景

原题译自 [POI 2024/2025 R1 Usuwanie](https://sio2.mimuw.edu.pl/c/oi32-1/p/usu/)。

## 题目描述

Bajtazar 喜欢玩以下单人游戏。在一块板上写下从 $a$ 到 $b$ 的所有自然数，形成一个序列：

$$a, a+1, a+2, \ldots, b-1, b$$
然后进行零次或多次操作。在每次操作中，选择两个仍在板上的数，并且这两个数的和是偶数。将选择的两个数从板上移除。游戏的目标是移除尽可能多的元素。帮助 Bajtazar 计算可以移除的最大元素数量。

## 说明/提示

对于样例一，移除 $3\ 5$ 和 $4\ 6$。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :----------- | :----------- |
| $1$ | $a,b\leq 10$ | $11$ |
| $2$ | $a,b\leq 10^6$ | $21$ |
| $3$ | $a=1$ | $32$ |
| $4$ |无特殊性质 | $36$ |


## 样例 #1

### 输入

```
3 7```

### 输出

```
4```

## 样例 #2

### 输入

```
1 10```

### 输出

```
8```

## 样例 #3

### 输入

```
2 1000000```

### 输出

```
999998```

## 样例 #4

### 输入

```
1 1000000000```

### 输出

```
1000000000```

## 样例 #5

### 输入

```
32 1000000000000000000```

### 输出

```
999999999999999968```

# 题解

## 作者：Zskioaert1106 (赞：5)

题目传送门：[P11384 [POI 2024/2025 R1] Usuwanie](https://www.luogu.com.cn/problem/P11384)

首先，奇数加奇数得偶数，偶数加偶数得偶数，奇数相邻的是偶数，偶数相邻的是奇数。

发现对于相邻的整数 $(a,a+1,a+2,a+3)$，$(a,a+2)$、$(a+1,a+3)$ 可以两两消掉，于是当整个序列的元素数量 $s=b-a+1$ 是 $4$ 的倍数的时候，全部的元素都能消除。

如果模 $4$ 得 $1$，那么最后剩下的一个就消不了。

如果模 $4$ 得 $2$，我们悲伤地发现最后两个元素之和为奇数，所以都会剩下。

如果模 $4$ 得 $3$，那么倒数第三个和最后一个可以消，倒数第二个会剩下，答案还是只剩下一个。

所以汇总代码就出来了。

```cpp
#include<iostream>
using namespace std;
long long a,b,ans;
int main(){
    cin>>a>>b;
    long long s=b-a+1;
    if(s%4==0)ans=s;
    else if(s%4==1)ans=s-1;
    else if(s%4==2)ans=s-2;
    else ans=s-1;
    cout<<ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/193857150)。

---

## 作者：UnfortunatelyDead (赞：1)

考虑如何才能使擦掉的数为偶数，发现仅可能是奇数加奇数，或者偶数加偶数。

对于奇数的情况，记奇数个数为 $x$，我们把奇数两两配对，那么就会擦掉 $x - x \bmod 2$ 个数。

如何快速计算 $x$ 呢？我们考虑分别找到 $[1,a)$ 和 $[a,b]$ 内最大的奇数 $c$ 和 $d$，那么 $x= \frac{d-c}{2}$。

偶数同理。

两个擦掉的个数加起来就是答案了。

```cpp
#include<iostream>
using namespace std;
long long F(long long x) { return x % 2 ? x : x + 1; }
long long G(long long x) { return x % 2 ? x + 1 : x; }
int main() {
    long long a, b; cin >> a >> b;
    long long cnt1 = (b - F(a - 2)) / 2, cnt2 = (b - G(a - 2)) / 2;
    cout << b - a + 1 - cnt1 % 2 - cnt2 % 2;
    return 0;
}
```

---

## 作者：Barryb (赞：1)

两个数相加为偶数，那必须两个偶数或两个奇数。我们可以设四个为一组，那每组就能擦掉四个。
代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
signed main()
{
	cin >> n >> m;
	cout << (m - n + 1) / 4 * 4;// 4个一组
	return 0;
}
```
这个会发现不行，因为还有剩三个的情况，若有剩，那总数要加上二。
正确代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
signed main()
{
	cin >> n >> m;
	cout << (m - n + 1) / 4 * 4 + ( (m - n + 1) % 4 == 3 ? 2 : 0);//加上 mod 4 = 3的。
	return 0;
}
```

---

## 作者：signed_long_long (赞：0)

# 题目解法

## 大致解法
每次消去的一定是两个奇数或者两个偶数，那么最后只会剩下至多一个奇数，一个偶数，所以只要用总数减去奇数的数量对二取模的余数减去偶数的数量对二取模的余数就行了。

换句话说，令 $c=b-a+1$（$c$ 为总数），$o$ 为奇数的数量，$e$ 为偶数的数量，那么答案就是 $c-o\bmod 2 -e\bmod2$。

奇数、偶数数量的算法见代码。

## 注意事项

- ceil 函数向上取整会爆精度，不要用 ceil。
- 十年 OI 一场空，不开 long long 见祖宗。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b;
int main(){
	cin>>a>>b;
	long long c=b-a+1;
	long long o,e;
	if(a&1){
		e=c/2;
		if(c&1) o=e+1;
		else o=e;
	}else{
		o=c/2;
		if(c&1) e=o+1;
		else e=o;
	}
	printf("%lld",c-(o&1)-(e&1));
	return 0;
}
```

---


# [Code+#5] 有人吗？

## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。

## 题目描述

企鹅高中有很多学生，自然管理起来也就非常麻烦。学校的教务处想要随时统计学校里面有多少个学生，但是他们只有很多来自保卫处的人员来往报告。每个报告的内容为进入了多少个学生，或者出去了多少个学生。所有的报告是非常混乱的，不知道到底哪个报告更早，哪个报告更晚。

现在教务处的企鹅老师想要知道这些报告到底靠不靠谱。这些报告靠谱，当且仅当存在一种对这些报告的排序方式，使得随时随地学校里的学生数量不为负数。当然我们认为初始情况下，学校的学生数量为 $0$。

现在你需要写份程序，自动判断这些报告靠不靠谱。

## 说明/提示

**数据范围：**

对于所有测试点，$n \le 10^5$，

第二行所有整数的绝对值 $\le1000$。

**样例解释：**

对于样例一，我们可以认为报告的先后顺序为 $3$，$2$，$1$。
一开始学校里有 $0$ 位同学。
得到第 $3$ 份报告后，可以推出现在有 $5$ 位同学。
得到第 $2$ 份报告后，可以推出现在有 $1$ 位同学。
得到第 $1$ 份报告后，可以推出现在有 $4$ 位同学。
所以这些报告靠谱。

## 样例 #1

### 输入

```
3
3 -4 5
```

### 输出

```
Wo jue de OK```

## 样例 #2

### 输入

```
42
210 42 177 -351 -349 171 638 413 921 149 -929 -230 -706 73 933 741 28 -988 -885 -761 -988 383 562 -192 597 45 226 946 -12 200 -75 -819 -825 -989 617 -106 409 -430 -666 -764 -37 241
```

### 输出

```
Wo jue de bu tai xing
```

# 题解

## 作者：cff_0102 (赞：7)

把所有正数安排在前面，所有负数安排在后面。

如果 $\sum a_i$ 非负，那么在累加的过程中一定不会出现负数。

否则所有数的和都是负数了也就没什么好说的了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	int s=0;
	while(n--){
		int x;cin>>x;
		s+=x;
	}
	if(s>=0)cout<<"Wo jue de OK";
	else cout<<"Wo jue de bu tai xing";
	return 0;
}
```

---

## 作者：rainbow_cat (赞：3)

考虑贪心，将正数排在前面，负数排在后面最优，因为这样学校里的人数能达到极值。   
首先从大到小排序，这样正数一定在前面。   
维护变量 $sum$，对于第 $i$ 份记录，$sum$ 加上 $a_i$，若 $sum <0$ 则无解。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,a[200010];
bool cmp(int x,int y){return x>y;}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		sum+=a[i];
		if(sum<0)
		{
			cout<<"Wo jue de bu tai xing";
			return 0;
		}
	}
	cout<<"Wo jue de OK";
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

所有正数安排在前面，所有负数安排在后面是最优解。如果总和非负，那其中任何一个都是非负的，如果总和是负数则无需考虑。

```
#include<bits/stdc++.h>
using namespace std ;
int n , x , ans ;
int main()
{
	ios::sync_with_stdio( 0 );cin.tie( 0 ) ;cout.tie( 0 ) ;
	cin >> n ;
	while(n--){
		cin>>x;
		ans+=x;
	}
	if(ans>=0)
  cout<<"Wo jue de OK";
	else
  cout<<"Wo jue de bu tai xing";
	return 0;
}
```

---

## 作者：3_14 (赞：1)

[**题目传送门**](https://www.luogu.com.cn/problem/P11542)

# 思路

我们需要判断一组报告是否“靠谱”，即是否存在一种排列顺序，使得在任何时刻学校里的学生数量都不为负数。初始时，学校里的学生数量为 $0$。

我们需要找到一种排列顺序，使得按照这个顺序处理报告时，学生数量始终不为负数。这等价于找到一个排列顺序，使得前缀和始终非负。

将正数报告（进入学生）放在前面处理，负数报告（离开学生）放在后面处理，这样可以确保在离开学生之前，已经有足够的学生进入学校。

所以我们将这样去实现:

1. 将所有正数报告和负数报告分开。

2. 先处理所有正数报告，再处理所有负数报告。

3. 计算前缀和，检查是否始终非负。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
#define Made return
#define by 0
#define _3_14 ;
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+1;
vector<int>positives,negatives,sorted_reports;
int n;
int main(){
    cin>>n;
    vector<int>reports(n);
    for(int i=0;i<n;i++)cin>>reports[i];
    for(int report:reports){
        if(report>0)positives.push_back(report);
        else negatives.push_back(report);
    }
    sorted_reports.insert(sorted_reports.end(),positives.begin(),positives.end());
    sorted_reports.insert(sorted_reports.end(),negatives.begin(),negatives.end());
    int current_students=0;
    bool is_valid=true;
    for(int report:sorted_reports){
        current_students+=report;
        if(current_students<0){
            is_valid=false;
            break;
        }
    }
    if(is_valid)cout<<"Wo jue de OK\n";
    else cout<<"Wo jue de bu tai xing\n";
	Made by _3_14
}
```


[**AC 记录**](https://www.luogu.com.cn/record/197548687)

---

## 作者：ridewind2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11542)

## 思路
正数安排前面，负数安排后面。

如果总和不是负数，那么累加时一定不会出现负数。

所以我们将所有的 $a_{i}$ 累加起来，判断是不是**大于等于**零。

## AC Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	int sum=0;
	while(n--){
		int x;
		cin>>x;
		sum+=x;//累加
	}
	if(sum>=0)cout<<"Wo jue de OK";//是>=，不是>
	else cout<<"Wo jue de bu tai xing";
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：0)

## Solution

因为没规定怎么排序，所以正数排在前面，负数排在后面，这样是最优解。实现正数排在前面，负数排在后面需要从大到小排序，我是用 `sort`。随便来一个用来累加的变量，每次加上一个数，如果这个变量在任意时刻变成负数，那么输出 `Wo jue de bu tai xing`，结束程序。如果循环结束了还没有结束程序，那么表示报告靠谱，则输出 `Wo jue de OK`。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn = 1e5 + 5;
ll n, ans;
ll a[maxn];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	sort(a + 1, a + n + 1, greater<ll>());
	for (int i = 1; i <= n; i++) {
		ans += a[i];
		if (ans < 0) {
			cout << "Wo jue de bu tai xing";
			return 0;
		}
	}
	cout << "Wo jue de OK";
	return 0;
}
```

---

## 作者：csxx601cjy (赞：0)

上次写题解因题目简单思路丰富被撤下，这次写一篇 python 的，就不会有重复了。
### 题意
输入一串数，如果能将它排成一个序列，求前缀和时不会产生负数，输出 `Wo jue de OK`，否则输出 `Wo jue de bu tai xing`。

考验基础语法和思维，建议评红。

建议加强数据，总和为零的情况，如：`1 1 4 -5 -1`。

### 思路

由于没规定怎么排，因此可以把所有正数都排在前面，这样一定是最优的。如果按照这种方法都会有负数，那就不行了。

可以对所有数求和，结果是非负就是可以的，否则怎么排都达不到题目要求。

### 代码

```python
n=int(input()) #数字的个数
a=map(int,input().split()) #读入一行数字
s=0 #s表示数字的和
for i in a:
    s+=i #对数字求和
if s>=0: #非负数
    print("Wo jue de OK") #可行的情况
else:
    print("Wo jue de bu tai xing") #不可行的情况
```

---


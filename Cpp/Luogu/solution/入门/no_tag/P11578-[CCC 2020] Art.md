# [CCC 2020] Art

## 题目背景

本题译自 [Canadian Computing Competition](https://cemc.uwaterloo.ca/resources/past-contests?contest_category=29) [2020 Junior](https://cemc.uwaterloo.ca/sites/default/files/documents/2020/2020CCCJrProblemSet.html) T3 Art。

## 题目描述

Mahima 一直在尝试一种新的艺术风格。她站在画布前，用画笔在画布上绘画。当她认为自己创造了一件杰作时，她会用 3D 打印机打印一个框架来保护自己的画作。

你的工作是通过确定尽可能小的长方形框架的坐标来帮助 Mahima，让每一滴颜料都位于框架内。

**框架上的点不在框架内考虑。**

## 说明/提示

**本题采用捆绑测试**。
#### 【样例解释】
框架的左下角是 $(23,9)$，如果左下角上移，则颜料 $(64,10)$ 将不再位于框架内，如果其右移，则颜料 $(24,78)$ 将不再位于框架，而向其他方向移动会加大框架面积，不合题意。右上角同理。
![](https://cdn.luogu.com.cn/upload/image_hosting/qrrjbsb8.png)

## 样例 #1

### 输入

```
5
44,62
34,69
24,78
42,44
64,10```

### 输出

```
23,9
65,79```

# 题解

## 作者：Stars_visitor_tyw (赞：1)

## 题解：P11578 [CCC2020] Art
### 分析
还是简单题。

由题，画框要框住所有的颜料，但是分析样例可知，颜料不能和画框重合，所以先计算出最大和最小的 $x$ 坐标和 $y$ 坐标，然后将最小坐标 $-1$，最大坐标 $+1$ 即为画框四个点的坐标。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main()
{
	int n;
	cin>>n;
	int mxx=-1e9, mxy=-1e9, minx=1e9, miny=1e9;
	for(int i=1;i<=n;i++)
	{
		int x, y;
		char c;
		cin>>x>>c>>y;
		mxx=max(mxx,x);
		minx=min(minx,x);
		mxy=max(mxy,y);
		miny=min(miny,y);
	}
	cout<<minx-1<<","<<miny-1<<"\n"<<mxx+1<<","<<mxy+1;
}
```

---

## 作者：Stars_Traveller (赞：0)

## 题解：P11578 [CCC2020] Art
### 分析
画框的位置需要将所有颜料覆盖，则画框的最小的 $x$ 坐标应当比颜料的最小 $x$ 坐标还小，画框的最大的 $x$ 坐标应当比颜料的最大的 $x$ 坐标还大，$y$ 坐标同理。

则枚举维护颜料坐标的极值，再如上所述计算画框坐标即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main()
{
	int n;
	cin>>n;
	int maxx=-1145141919810, maxy=-1145141919810, minx=1145141919810, miny=1145141919810;
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d,%d",&x,&y);
		maxx=max(maxx,x),minx=min(minx,x),maxy=max(maxy,y),miny=min(miny,y);
	}
	cout<<minx-1<<","<<miny-1<<"\n"<<maxx+1<<","<<maxy+1;
}

---

## 作者：nannangua (赞：0)

[传送门](https://www.luogu.com.cn/problem/P11578)

分析题目，我们发现只要找出给出的每个点位的 $x$ 坐标和 $y$ 坐标的最小和最大值，相对应地加一或减一，就可以得出答案。

* $x$ 坐标的最小值 $-1$ 得到大框架的左下角 $x$ 坐标。
* $y$ 坐标的最小值 $-1$ 得到大框架的左下角 $y$ 坐标。
* $x$ 坐标的最大值 $+1$ 得到大框架的右上角 $x$ 坐标。
* $y$ 坐标的最大值 $+1$ 得到大框架的右上角 $y$ 坐标。

这样，我们就凑齐所有坐标了。示例代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7;
int main()
{
	int n,minn=N,minnn=N,maxx=-N,maxxx=-N;
	cin>>n;
	while(n--)
	{
		int a,b;
		scanf("%d,%d",&a,&b);
		minn=min(a,minn);	
		minnn=min(b,minnn);
		maxx=max(a,maxx);
		maxxx=max(b,maxxx);
	}
	cout<<minn-1<<","<<minnn-1<<endl;
	cout<<maxx+1<<","<<maxxx+1;
	return 0;
} 
```

---


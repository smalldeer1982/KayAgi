# 『Fwb』神话の传播

## 题目描述

在遥远的北方，生活着一个叫夸父的巨人。在冰天雪地的北方，冬季的夜晚寒冷而漫长。一天晚上，夸父被冻得睡不着觉，他突发奇想：要是可以追上太阳，让太阳在人间多停留一段时间，那么人间就暖和多了。为了这个想法，他兴奋得一夜未眠。

于是他设定了一个计划：如果现在与太阳之间的距离是 $n$，他一天追太阳 $x$ 的距离，那么需要 $\lceil \frac{n}{x}\rceil$ 天就可以追上太阳。其中，$\lceil a\rceil$ 的意思是向上取整。

夸父的体力值为 $k$，每追 $1$ 天，就会消耗 $1$ 的体力值。只有在 $k>0$ 时，夸父才可以完成这一天的路程。在追太阳的过程中，夸父也可以选择停下来休息，花费 $1$ 天的时间补充**原始** $k$ 的体力值。现在想知道，夸父最少要多少天，才能追上太阳。

## 说明/提示

#### 【样例 2 解释】

- 第一天休息一天，剩余体力值为 $4$。
- 第二天追 $3$ 的距离，离太阳距离为 $7$，剩余体力值为 $3$。
- 第三天追 $3$ 的距离，离太阳距离为 $4$，剩余体力值为 $2$。
- 第四天追 $3$ 的距离，离太阳距离为 $1$，剩余体力值为 $1$。
- 第五天追 $3$ 的距离，追上了太阳，剩余体力值为 $0$。

#### 【数据范围】

对于 $10\%$ 的数据，$n=x$。

对于 $40\%$ 的数据，$k>\lceil\frac{n}{x}\rceil$。

对于 $100\%$ 的数据，$1\le n,x,k\le10^5$。

## 样例 #1

### 输入

```
10 3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
10 3 2```

### 输出

```
5```

# 题解

## 作者：Vct14 (赞：7)

不妨换个思路，计算跑 $x$ 距离需要补充多少次 $k$ 个体力值，在最开始全补完。

具体地，跑 $x$ 距离需要 $\left\lceil\dfrac{n}{x}\right\rceil$ 天，即 $\left\lceil\dfrac{n}{x}\right\rceil$ 体力值。那么一共需要补充 $\left\lceil\dfrac{\left\lceil\frac{n}{x}\right\rceil}{k}\right\rceil$ 次体力值。然而一开始就有 $k$ 体力值，相当于可以少补充一次，因此需要 $\left\lceil\dfrac{\left\lceil\frac{n}{x}\right\rceil}{k}\right\rceil-1$ 天补充体力值。答案为 $\left\lceil\dfrac{n}{x}\right\rceil+\left\lceil\dfrac{\left\lceil\frac{n}{x}\right\rceil}{k}\right\rceil-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n,x,k;cin>>n>>x>>k;
	int t=ceil(n*1.0/x);
	cout<<t+ceil(t*1.0/k)-1;
	return 0;
}
```

---

## 作者：Charllote_ (赞：3)

**[题目传送门](https://www.luogu.com.cn/problem/P11599)**

---

## 题目思路

题目中已经给出了追的天数的计算公式：$\lceil \frac{n}{x}\rceil$，所以我们只需要求出补充能量的天数。不难发现，若每 $k$ 天要补充能量的话，补充能量的天数为 $\lceil \frac{\lceil\frac{n}{x}\rceil}{k}\rceil-1$（第一次行动不需要能量所以要减一）。

## 实现

如何实现向上取整？判断 $n$ 是否能被 $k$ 整除，若能整除那就取 $\left \lfloor  \frac{x}{y}  \right \rfloor$，否则取 $\left \lfloor  \frac{x}{y}  \right \rfloor + 1$。

## 代码

```cpp
#include <iostream>

using namespace std;

int n, x, k;

int main (){
    cin >> n >> x >> k;
    int run = (n % x == 0 ? n / x : n / x + 1);
    int breaken = (run % k == 0 ? run / k : run / k + 1) - 1;
    cout << breaken + run << '\n';
    return 0;
}
```

---

## 作者：___jiqihang___ (赞：3)

推下式子。

夸父过去要用的时间和体力都是 $\lceil \frac{n}{x}\rceil$。

补充体力的日子是 $\frac{\lceil \frac{n}{x} \rceil-1}{k}$。

解释下：$k$ 天一休，就是 $\frac{\lceil \frac{n}{x} \rceil}{k}$，但第一天不需要补充体力，所以分子要减 $1$，就是 $\frac{\lceil \frac{n}{x} \rceil-1}{k}$。

那么合一起就是答案。

---

## 作者：WsW_ (赞：3)

### 思路
先计算要跑多少天，再计算要休息多少天。  
题目中已经给出，要跑 $t=\lceil \frac{n}{x} \rceil$ 天。  
要跑 $t$ 天，就要 $t$ 点体力；要 $t$ 点体力，就要休息 $\lceil \frac{t}{k}-1 \rceil$ 天。减一是因为一开始体力值是满的，相当于已经休息了一天。  

时间复杂度为 $O(1)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,k;
int main(){
	cin>>n>>x>>k;
	int t=(n+x-1)/x;
	cout<<t+(t+k-1)/k-1;
	return 0;
}
```

---

## 作者：Perfect_Youth (赞：3)

可以用来练习二分。

对于本题的答案很明显具备单调性，考虑二分。

先考虑 $l$ 和 $r$ 的范围，$l$ 的范围应该是 $1$，那 $r$ 的范围呢？考虑极端情况 $n=10^5,x=k=1$，这样就是追一天休息一天，也就是 $l$ 的范围是 $2\times n$。

好，范围分析完了，可以进行分析check函数了。循环 $mid$ 次。

$tmpn=n,tmpk=n$，请注意这两个不是省略乘号，而是变量名。

1. 每次判断 $tmpk$ 是否大于 $0$，大于 $0$ 就减一，$tmpn$ 减去 $x$，天数 $+1$，判断 $tmpn\le 0$ 了，因为这样代表走完了，判断 $cnt\le mid$ 即可。
2. $tmpk\le 0$ 了，$tmpk + k$ 就可以了。

代码如下：
```cpp
#include <bits/stdc++.h>
#define getchar()(p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

using namespace std;

int n, x, k, l, r;

inline
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

bool check(int mid) {
	int tmp = k, cnt = 0, tmpn = n;
	bool flag = 1;
	for (int i = 1; i <= mid; i++) {
		if (tmp > 0) {
			tmp--;
			tmpn -= x;
			cnt++;
			if (tmpn <= 0 && flag) {
				flag = 0;
				return cnt <= mid;
			} 
		} else {
			tmp += k;
		}
	}
	return 0;
}

int main() {
	n = read(), x = read(), k = read();
	l = 1, r = 1e6;
	while (l < r) {
		int mid = l + r >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	printf ("%d", l);
	return 0;
}
```

---

## 作者：_H17_ (赞：2)

## 题目分析

首先过去需要 $d=\lceil n \div x\rceil$ 天，体力也一样。

需要补充的体力的日子有 $\lceil \max(d-k,0)\div k\rceil$。

两者相加就是答案。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,k,ex,ans;
int main(){
    cin>>n>>x>>k;
    ans=ex=(n+x-1)/x;
    ans+=(max(ex-k,0)+k-1)/k;
    cout<<ans;
    return 0;
}
```

---

## 作者：__yrq__ (赞：2)

## 思路：

我们根据题目可得，夸父一共应该消耗 $\lceil \frac{n}{x}\rceil$ 的体力值。

那么答案就是使夸父的体力值 $\ge  \lceil \frac{n}{x}\rceil$ 所需的最小天数 $+ \lceil \frac{n}{x}\rceil$。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,k,s=0,kk;
int main()
{
    cin>>n>>x>>k;
    kk=k;
    int t=(n+x-1)/x;
    while(k<t)
    {
    	k+=kk;
    	s++;
	}
	s+=t;
	cout<<s<<endl;
  	return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：1)

可以模拟。

距离为 $n$，$1$ 天走 $x$，可以连续走 $k$ 天，休息 $1$ 天后可以再走 $k$ 天。

把走 $k$ 天和休息 $1$ 天看做整体，循环求出总时间。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
int n,x,k,ans;signed main(){
	cin>>n>>x>>k;while(n>0){
		if(x*k>=n){cout<<ans+(n+x-1)/x;return 0;}//(n+x-1)/x是n/x向上取整，求剩余走几天
		ans+=k+1,n-=x*k;//答案加k+1天，距离减x*k
	}return 0;
}
```

---

## 作者：cjx_AK (赞：1)

这题是一道签到题。

定义一个变量用来记录当前走的距离，如果体力值耗完便等一天，如果走完了便退出循环。

代码：
 
```
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,x,k,y;
signed main() {
	cin>>n>>x>>k;
	y=k;
	int sum=0,ans=0;
	while(sum<n){
		if(k==0){
			ans++;
		k=y;
		}else{
			ans++;
			sum+=x;
			k--;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：jojo222 (赞：1)

~~我是蒟蒻，所以用 `while` 循环。~~

这篇题解为了方便，把剩下的路程称为 $n$。

如果是最后一次追（$n\le kx$），那么还需要 $\lceil n\div x\rceil$ 天。  
否则花 $k+1$ 天，走 $k$ 天，休息 $1$ 天，共走 $kx$ 的距离。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, x, k, ans;
int main()
{
	cin >> n >> x >> k;
	while(true)
	{
		if(n <= k * x)
		{
			ans += (n + x - 1) / x;
			break;
		}
		ans += k + 1;
		n -= k * x;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Camellia_Spoil (赞：1)

# 题意简述
夸父与太阳有 $n$ 的距离，夸父每天可以走 $x$ 的距离，每天消耗 $1$ 点体力值，当他的总体力值 $k$ 为 $0$ 时，他需要休息一天恢复 $k$ 点体力值，问他追到太阳最少天数。

# 分析
一道普通的模拟题。只需要变量 $t$ 和 $s$ 分别跟踪时间和当前体力值即可。

# AC Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
inline long long read()
{
	long  long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main()
{
	int n,x,k;
	cin>>n>>x>>k;
	int sum=n,t=0,s=k;
	while(sum>0)//还没追上 
	{
		t++;//时间++ 
		if(s<=0)//体力值为0时休息一天恢复成k的体力值 
		{
			t++;
			s=k;
		}
		s--;
		sum-=x;//追一天距离减x 
	}
	cout<<t; 
	return 0;
}
```

---

## 作者：_Tatsu_ (赞：1)

## 思路

我们先把体力充足下的时间 $day=\lceil \frac{n}{x} \rceil$ 算出来，然后算出如果体力不够时 $day \times 1$（体力数） 与 $k$ 的差。因为休息一次补充 $k$ 点体力，所以要休息 $\lceil\frac{cha}{k}\rceil$，则答案就是 $day+\lceil\frac{cha}{k} \rceil$。

## Code

```cpp
#include <bits/stdc++.h>
#define fro for
using namespace std;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	int n,x,k;
	cin>>n>>x>>k;
    int day=ceil(n*1.0/x);
    int cha=max(0,day-k);
    cout<<day+ceil(cha*1.0/k);
	return 0;
}
```

---

## 作者：hinin (赞：0)

[更好的阅读体验](https://www.cnblogs.com/hinin/articles/18698428)？

### 思路

~~居然还能写题解~~。

首先过去需要 $\lceil{\frac{n}{x}}\rceil$（向上取整）天，体力也一样。

然后则需要 $\lceil\frac{\max(d-k,0)}{k}\rceil$（向上取整）天。

两者和就是答案。

### 代码

注：新版 C++ 支持日文、中文字符当变量名。

``` cpp
#include <bits/stdc++.h>
// #pragma GCC optimize("Ofast", "-funroll-all-loops")
#define ll long long
#define pii pair<int, int>

#define y1 gigay
#define x first
#define y second

using namespace std;

int n, x, k, の, ans;

int main()
{
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); 

    cin >> n >> x >> k;
    ans = の = (n + x - 1) / x;
    ans += (max(の - k, 0) + k - 1) / k;
    cout << ans << endl;

    return 0;
}
```

---

## 作者：donnieguo (赞：0)

## 思路

考虑贪心。

一直使用 $k$ 的体力值直到用完，再停下补充。

统计一下天数即可，注意补充的是最开始的 $k$。

## AC code

```cpp
#include <iostream>
using namespace std;

int n, x, k, d;
int main()
{
	cin >> n >> x >> k;
	int t = k;
	while (n > 0)
	{
		if (k > 0) n -= x, k--, d++;
		else k += t, d++;
	}
	cout << d << '\n';
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：0)

### Solution

很简单的思路，如果不用补充体力就能跑到，那么直接输出。否则只要还有体力跑下去，那就跑，直到没有体力后停下来休息，到了就输出答案。注意每次恢复的体力是 $k$。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, x, k;
int main() {
	cin >> n >> x >> k;
	ll xhtlz = ceil(n * 1.0 / x);
	if (xhtlz < k) {
		cout << xhtlz;
	} else {
		ll tlz = k, dis = 0, days = 0;
		while (true) {
			if (dis >= n) break;
			days++;
			if (tlz > 0) {
				dis += x;
				tlz--;
			} else {
				tlz += k;
			}
		}
		cout << days;
	}
	return 0;
}
```

警示后人，我因为少打了一个符号得了 $70$ 分。

---

## 作者：hexuchen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11599)

[更好的阅读体验？](https://www.luogu.com.cn/article/bwgubonj)

## 思路分析

简单模拟题。

模拟每一天，如果有体力，就向前走。如果没体力，就停下来休息。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x,k,k2,dis=0,days=0;
int main(){
	cin>>n>>x>>k;
	k2=k; //注意 k 的值会变，要复制一份
	while(dis<n){ //没追上
		if(k>0){ //有体力
			k--; 
			dis+=x;
		}
		else{ //没体力
			k+=k2; //恢复体力
		}
		days++;
	}
	cout<<days;
	return 0;
}
```

---

## 作者：programmer330 (赞：0)

# 题解：P11599 『Fwb』神话の传播

### 思路分析

简单题，可以提前算出跑的天数与休息的天数。注意最后一天已经追上后不需要休息。

### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,c;
    cin >> a >> b >> c;
    int d=a/b;
    if(a%b!=0)d+=1;
    if(d%c==0)d=d+d/c-1;
    else d=d+d/c;
    cout<<d<<endl;
    return 0;
}
```

---

## 作者：可爱大黄兔 (赞：0)

可以分两步，首先计算如果体力够需要跑多少天，再计算还需要多少体力。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,x,k;
	cin>>n>>x>>k;
	int y=ceil(1.0*n/x);
	cout<<y+max(0,(int)ceil(1.0*(y-k)/k));
	
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11599)

## 思路：

很简单，能跑就跑，跑到了就退出并输出答案，不能跑就回复体力后再跑，记得恢复体力是恢复 $k$ 而不是 $1$。

## 代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
long long m,n,k; 
int main(){
	cin>>m>>n>>k;
	long long s=ceil(m*1.0/n);
	if(s<k) cout<<s;
	else{
		int f=k,mq=0,s=0;
		while(1){
		if(mq>=m) break;
			s++;
			
			if(f!=0){
				mq+=n;
				f--;
			}
			else f+=k;
		}
		cout<<s;
	}
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

简单数学题。

首先移动天数显然为 $\displaystyle\lceil \frac{n}{x}\rceil$，再结合文中每移动 $k$ 天休息一次，那么休息的天数为 $\displaystyle\frac{\lceil \frac{n}{x}\rceil - 1}{k}$（最后一天不用休息）。综上，答案为：

$$
\lceil \frac{n}{x}\rceil + \frac{\lceil \frac{n}{x}\rceil - 1}{k}
$$

时间复杂度 $O(1)$。

---

## 作者：__Green_tick__ (赞：0)

## 题目大意
如果这一天前进 $x$，则消耗 $1$ 体力；如果这一天休息，则恢复 $k$ 体力。直到到达 $n$ 位置。

## 题目思路
贪心，先走到体力值为 $0$，休息一天，继续走，循环往复。

例如：（距离为 $14$，每天走 $1$，体力 $5$）

|走|走|走|走|走|休|走|走|走|走|走|休|走|走|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

以规律，可发现：
$$m=\left\lceil\frac{\left\lceil \frac{n}{x} \right\rceil}{ k }\right\rceil$$

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,k;
int main(){
	cin>>n>>x>>k;
	long long l=ceil(n*1.0/x);
	long long t=ceil(l*1.0/k)-1;
	long long m=l+t;
	cout<<m<<endl;
	return 0;
}
```

---

## 作者：sbh2012 (赞：0)

## 思路
首先我们可以知道在哪几天休息都是一样的，于是我们直接算出需要休息几天，再加上需要跑几天即可。休息几天和跑几天都需要向上取整。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){ 
	int n,x,k;
	cin>>n>>x>>k;
	int t=ceil(n*1.0/x); //需要跑几天,如果是向上取整那一定要保证是数据类型double或乘上1.0 
    if(t>k){
    	t+=ceil((t-k)*1.0/k);//算出需要休息几天
	}
	cout<<t;
	return 0;
}
```

---

## 作者：_xdd_ (赞：0)

简单模拟题，考验循环结构，只要夸父没追上太阳就一直追，每次消耗一点体力，等到没有体力了就恢复体力，这个方法肯定是最优的。

### code


```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define maxn +5
//#define int long long
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
int n,x,k;
int main(){
    cin >> n >> x >> k;
    int sum=0,ans=0,kk=k;
    while(sum<n){
        if(kk==0){
            kk+=k;
        }else{
            sum+=x;
            kk--;
        }
        ans++;
    }
    cout << ans;
}
```

---


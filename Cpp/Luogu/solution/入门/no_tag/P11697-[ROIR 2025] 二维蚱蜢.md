# [ROIR 2025] 二维蚱蜢

## 题目背景

翻译自 [ROIR 2025 D1T1](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。

## 题目描述

在一个大小为 $n \times m$ 的矩形网格的左下角位置有一只蚱蜢。每次蚱蜢可以向右、向上或者向右上方对角线方向跳跃，且每次跳跃的距离最多为 $k$ 个格子。

对于 $k = 3$ 的情况，蚱蜢的可移动方向如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/iwp2m1ds.png)

问：最少需要多少次跳跃，才能使蚱蜢从左下角的格子 $(1, 1)$ 移动到右上角的格子 $(n, m)$？

## 说明/提示

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

| 子任务 | 分数  | 特殊性质  |
|:------------:|:-------:|:-----------:|
| $1 $         | $15  $  | $n, m \leq 10$，$k = 1$ | 这个是 GPT 的机翻懒得删了 |
| $2$          | $16  $  | $n, m, k \leq 10$ | 第一错误 |
| $3 $         | $17 $   | $n, m \leq 10^9$，$k = 1$ | 第一错误 |
| $4  $        | $18 $   | 保证答案为 $1$ 或 $2$ | 第一错误 |
| $5  $        | $34$    | 无 | - |

## 样例 #1

### 输入

```
9 8 5```

### 输出

```
3```

## 样例 #2

### 输入

```
2 2 1```

### 输出

```
1```

# 题解

## 作者：jiangyunuo (赞：5)

### 题目意思：
从 $(1,1)$ 开始，每一次可以向上、向右或向右上最多跳 $k$ 格，问：至少要跳几次才能到 $(n,m)$？
### 大体思路：
显然，向右上跳肯定是最优的，所以我们最先考虑，直到无法向右上跳就考虑向右或向上。  
- 向右上跳，$n$ 和 $m$ 会同时加上跳跃距离，因而可以得出跳跃的次数为：`(min(n,m)+k-1)/k`。  
- 向上或右跳，很好理解，由于无法向右上跳了，说明应该到了第 $n$ 行，第 $n$ 列或第 $m$ 行，第 $m$ 列了，剩下的跳跃次数，就是 `(max(n,m)-min(n,m)+k-1)/k`。
- 于是把他们相加即可得到答案。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,k;
	cin>>n>>m>>k;
	n--;m--;  //由于从 (1,1)，开始，需要让 n,m 分别减 1，从而实现从 (0,0)，开始跳的效果，才符合前面的公式。
	cout<<(min(n,m)+k-1)/k+(max(n,m)-min(n,m)+k-1)/k;
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：4)

简单数学题，但是有些坑。

首先我们制定思路：怎样的路线才是最优路线？

显然走斜线是比较划算的，因为它相当于两次运动。

于是我们可以先走对角线，然后使用平移调整，为了方便讲述，我先给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, k;
int main(){
    cin >> n >> m >> k;
    cout << (int)(ceil(1.0 * min(n - 1, m - 1) / k) + ceil(1.0 * (max(n, m) - min(n, m)) / k));
    return 0;
}
```
显然答案转换为公式如下：
$$
\lceil \frac{\min(n - 1, m - 1)}{k}\rceil + \lceil \frac{\max(n, m) - min(n, m)}{k}\rceil
$$
这是一个[二项式](https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F/5271589)，每次尽可能走 $k$ 格，第一项即为斜角步数，第二项即为平移调整步数，比较简单，不做讲述。

问：为什么第一项的 $n$ 和 $m$ 要减一？  
答：因为起点在 $(1, 1)$ 而非 $(0, 0)$，画图可知仅需走 $n - 1$ 行和 $m - 1$ 列。

---

## 作者：Brute_Force (赞：1)

# 思路
考虑到最少需要多少次跳跃的次数。

我们先初始化 $n$ 和 $m$，使它们减去 $1$，以求出要走的距离。

首先考虑走斜线，当 $n,m \not= 0$ 时即可走斜线。这样可以使 $n$ 和 $m$ 同时走过一个数，以用来缩短步数。

其次考虑走直线，当 $n = 0$ 或 $m = 0$ 时，此时只能走直线。

题目中还给出了一个正整数 $k$ 表示最大能走过的步数。对于 $k$，我们在每一次的走动中只需判断此时走 $k$ 步是否会超出范围。不超出走 $k$ 步，超出则一次走到目标地点即可。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long step, k, n, m;
int main () {
	ios :: sync_with_stdio (0);
	cin.tie (0), cout.tie (0);
	cin >> n >> m >> k;
	n -= 1, m -= 1;
	while (n || m) {
		if (n >= k && m >= k) {
			n -= k;
			m -= k;
		}
		else {
			if (n == 0 || m == 0) {
				if (n + m <= k) n = m = 0;
				else {
					if (m > n) m -= k;
					else n -= k;
				}
			}
			else {
				long long dis = (n > m? m : n);
				n -= dis;
				m -= dis;
			}
		}
		step++;
	}
	cout << step;
	return 0;
}
```

---

## 作者：FZY_CZY (赞：1)

## 思路
这道题完全就是一个结论题，在当前的坐标 $(x,y)$ 中 $x<n$ 且 $y<m$ 的时候，我们选择走斜线一定是更优的，因为斜线走一格等同于横线一格和竖线一格，知道当前的坐标出现 $x=n$ 或 $y=m$ 时，才需要只走横线或竖线，因为此时无法走斜线了。

思路很简单，所以直接给代码。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int mul(int x,int y)
{
    if (x%y==0) return x/y;
    else return x/y+1;
}
int n,m,k;
int main(){
    cin>>n>>m>>k;
    cout<<mul(min(n-1,m-1),k)+mul(max(n-1,m-1)-min(n-1,m-1),k);
    return 0;
}
``````
注意这里有一个细节，那就是我们需要向上取整，如果当前的这一步超出范围的时候，我们会缩短当前的步数，但是耗费的次数仍然是 $1$，所以是向上取整。

---

## 作者：huanglihuan (赞：0)

### Solution
我们先从 $n=m,k=1$ 的正方形考虑。  
显然，最优解是一直往右上走，走 $n-1$ 步到达。  
如果 $n\ne m,k=1$，那么最优解是一直往右上走直到走到最后一行或最后一列，再往右或往上走，步数为 $\min(n,m)-1+|n-m|$，即走到最后一行或最后一列再走到 $(n,m)$。  
把 $k$ 的范围放大，走到最后一行或最后一列需要 $\lceil\frac{\min(n,m)-1}k\rceil$ 步，再走到 $(n,m)$ 需要 $\lceil\frac{|n-m|}k\rceil$ 步，代码中我们用 `div_ceil` 代表向上取整。
### Code
```cpp
#include <bits/stdc++.h>
#include <cstdio>
#define int long long
#define ull unsigned long long
#define mod 988444333
#define MOD 1000000007
#define in(x,y,z) x>=y&&x<=z
using namespace std;
const int N = 2e6 + 5;
int f [N];
int p [N];
int prime [N];
inline int read ()
{
	int x = 0;
	char c = getchar ();
	while (c < '0' || c > '9') c = getchar ();
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48),c = getchar ();
	return x;
}
inline void write (int x)
{
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
	return ;
}
int div_ceil (int x,int y) {return x % y == 0 ? x / y : x / y + 1;}
signed main ()
{
	int n,m,k;
	cin >> n >> m >> k;
	cout << div_ceil (min (n,m) - 1,k) + div_ceil (abs (n - m),k);
	return 0;
}
```

---


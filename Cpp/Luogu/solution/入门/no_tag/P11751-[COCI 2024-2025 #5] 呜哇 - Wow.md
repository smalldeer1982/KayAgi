# [COCI 2024/2025 #5] 呜哇 / Wow

## 题目背景

译自 [COCI 2024/2025 #5](https://hsin.hr/coci/) T1。$\texttt{1s,0.5G}$。满分为 $50$。


## 题目描述


有一种加密信息的方式，把每个小写字母替换成两行若干列的字符矩阵。

例如，字母 $\texttt{v}$ 被加密成 

$$\begin{aligned}&\texttt{\char092../}\\&\texttt{.\char092/.}\end{aligned}$$

而字母 $\texttt{w}$ 被加密成


$$\begin{aligned}&\texttt{\char092../\char092../}\\&\texttt{.\char092/..\char092/}\end{aligned}$$

相邻两个字母间会**用恰好一列空列隔开**。这里，空列指的是只包含点（$\texttt{.}$）的一列。

已知字符串 $s$ 中只包含字母 $\texttt{v},\texttt{w}$。给定 $s$ 加密后的字符矩阵，请你还原出 $s$。

## 说明/提示


#### 数据范围

对于 $100\%$ 的数据，保证 $1\le n\le 10^3$。

| 子任务编号 | 特殊性质 | 得分 |  
| :--: | :--: | :--: | 
| $ 1 $    |  A   |   $ 21 $   |  
| $ 2 $    |  B  |  $ 13 $   |  
| $ 3 $   |    | $16$ |

- 特殊性质 A：还原后的字符串只含**一个**字母。
- 特殊性质 B：还原后的字符串只含**一种**字母。


## 样例 #1

### 输入

```
32
\../.\../\../.\../.\../.\../\../
.\/...\/..\/...\/...\/...\/..\/.```

### 输出

```
vwvvw```

## 样例 #2

### 输入

```
27
\../\../.\../\../.\../.\../
.\/..\/...\/..\/...\/...\/.```

### 输出

```
wwvv```

# 题解

## 作者：Charged_Charge (赞：1)

# 洛谷 P11751
## 题目大意：
给定两个字母加密方式，输出解密后的字符串。
## 解题思路：
按照题目模拟即可。注意，只有连续且完整的加密串有效，所以，我们手动把开头与结尾的加密串加上一个点，放便后面的判断。然后，我们只需要遍历一遍字符串，按照 `v` 和 `w` 的判断方法对往后连续 $4$ 个和 $8$ 个字符进行判断，看这些字符满足哪个字母的判断条件，就输出那个字母。
## AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s, c;
int main() {
	cin >> n;
	cin >> s >> c;
	s = "." + s + ".";

	for (int i = 0; i < n; i++) {
		if (s[i] == '.' && s[i + 1] == '\\' && s[i + 2] == '.' && s[i + 3] == '.' && s[i + 4] == '/' && s[i + 5] == '.') {
			cout << 'v';
		} else if (s[i] == '.' && s[i + 1] == '\\' && s[i + 2] == '.' && s[i + 3] == '.' && s[i + 4] == '/' && s[i + 5] == '\\' && s[i + 6] == '.' && s[i + 7] == '.' && s[i + 8] == '/' && s[i + 9] == '.') {
			cout << 'w';
		}
	}

	return 0;
}
```

---

## 作者：Natural_Selection (赞：0)

# 题解 P11751 呜哇 / Wow

[题目](https://www.luogu.com.cn/problem/P11751)链接。

## 思路

一眼看去，就是个模拟。两个字符串我认为模拟哪个都行，我就用第一个来模拟吧。

看一下就知道有两种情况：`\../` 和 `\../\../`，挨个找就行了呗。

于是我想当然写下了代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s1,s2;
int main(){
    cin>>n;
    cin>>s1>>s2;
    int cnt=0;
    for(int i=0;i<s1.size();i++){
        if(s1[i]=='\\'){
            if(s1[i+4]=='.'){
                cout<<"v";
                i+=4;
            }else {
                cout<<"w";
                i+=8;
            }
        }
    }
    return 0;
}
```

~~结果被样例打败了。~~

发现如果最后剩下了一个 `\../`，那
$i + 4$
不就出界了吗？

于是就有了——

## [AC](https://www.luogu.com.cn/record/221194759) 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s1,s2;
int main(){
    cin>>n;
    cin>>s1>>s2;
    int cnt=0;
    for(int i=0;i<s1.size();i++){
        if(s1[i]=='\\'){
            if(s1[i+4]=='.'){
                cout<<"v";
                i+=4;
            }else if(s1[i+4]=='\\'){
                cout<<"w";
                i+=8;
            }else{
                cout<<"v";
            }
        }
    }
    return 0;
}
```

~~管理求通过。~~

---

## 作者：ylzpl (赞：0)

这是一道简单的字符串题。  
解题思路：
- 我们可以遍历整个字符串，如果上一个字符是 `/` 且字符 $a_i$ 为 `.`。如果 $t=4$ 就是 `v`，否则是 `w`。$t$ 的作用会在下午阐述。
- 否则我们 $t=t+1$。在这里，我们的 $t$ 是一个计数器，用于统计当前连续的字符个数。  
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	string a;
	cin>>n>>a;
	int t=0;
	for(int i=0;i<n;i++){
		if(a[i-1]=='/'&&a[i]=='.'){
			if(t==4) cout<<'v';
			else cout<<'w';
		    t=0;
		}
		else t++;
	}
	if(t==4) cout<<'v';
	else cout<<'w';
	return 0;
}
```

---


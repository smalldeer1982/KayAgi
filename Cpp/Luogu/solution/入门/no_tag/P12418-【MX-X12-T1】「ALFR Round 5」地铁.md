# 【MX-X12-T1】「ALFR Round 5」地铁

## 题目背景

原题链接：<https://oier.team/problems/X12A>。

## 题目描述

为了方便市民出行，缓解地面上的道路拥堵问题，S 市决定在地底下建一些地铁。

根据城市规划，S 市的地下网络将由 $n$ 条横向通道和 $m$ 条纵向通道构成。地铁站将设置在所有横向通道与纵向通道的交叉处，共 $n\times m$ 处。

地下网络的所有站点都需要被地铁线路覆盖，地铁线路之间可以有重叠部分。

由于地铁拐弯处的建造成本、安全要求较高，因此，S 市要求**每一条地铁线路途径的所有站点，均在同一条横向通道或纵向通道内**。即，地铁线路不能拐弯。

此外，地铁线路网必须是连通的。也就是说，无论从哪个地铁站出发乘坐地铁，经过若干次换乘（可以不换乘），都一定可以到达其它所有地铁站。

例如，当 $n=5$，$m=7$ 时，下图就是一个符合 S 市要求的地铁交通网络图（灰线代表地下通道，深灰色的格子为地铁站，即道路交叉处）。

![](https://cdn.luogu.com.cn/upload/image_hosting/17m8efyt.png)

因为盾构一条地铁线路的流程十分麻烦，S 市不想要建造太多的地铁线路。现在，你知道了 S 市的地下网络大小为 $n\times m$，请你求出 S 市最少要建几条地铁线路。

## 说明/提示

**【样例解释】**

在第一组数据中，需要建造一条长度为 $0$，经过唯一一个站点的地铁线路。

在第二组数据中，需要建造一条长度为 $1$，连接两个站点的地铁线路。

在第三组数据中，一个合法的建造方案如下图。要覆盖所有深灰色的交叉路口，至少需要三条地铁线路。

![](https://cdn.luogu.com.cn/upload/image_hosting/jer0ioa6.png)

**【数据范围】**

对于 $15\%$ 的数据，保证 $n=1$。

对于另外 $15\%$ 的数据，保证 $n,m\le10$。

对于另外 $15\%$ 的数据，保证 $n=m$。

对于另外 $15\%$ 的数据，保证 $n\le m$。

对于 $100\%$ 的数据，$1\le T\le10$，$1\le n,m\le3\times10^4$。

## 样例 #1

### 输入

```
3
1 1
1 2
2 2```

### 输出

```
1
1
3```

# 题解

## 作者：cff_0102 (赞：23)

首先，可以将每个地铁线路两端一直延长直到城市道路交通网的边缘，这样不会增加线路的数量，每条地铁线路能覆盖的交叉路口数量还能变多。

这样，所有地铁线路就可以被分为两种：

1. 横向的可以经过 $m$ 个交叉口的地铁线路；
2. 纵向的可以经过 $n$ 的交叉口的地铁线路。

不考虑不能「脱网」的特殊要求，要用这两种地铁线路覆盖所有 $n\times m$ 的交叉口，最优方案肯定是选择 $n$ 个第一种地铁线路或者 $m$ 个第二种地铁线路平行放置。如果 $n\le m$，最优方案就是选择 $n$ 个横向的地铁线路，否则就选择 $m$ 个纵向的地铁线路。这样，答案就是 $\min(n,m)$。

但是这样构造出来的地铁“线网”图并没有满足不能「脱网」的要求。因此，需要一个另一个垂直方向的地铁线路将所有平行的地铁线路串起来。所以答案是 $\min(n,m)+1$。

注意需要特判 $\min(n,m)=1$ 的情况，此时只需要一条线路即可，不需要另一条地铁线路来把这单独的一条线路“串起来”。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int t;cin>>t;
	while(t--){
		int n,m;cin>>n>>m;
		int x=min(n,m);
		if(x==1)cout<<1<<endl;
		else cout<<x+1<<endl;
	}
	return 0;
}
```

---

## 作者：yuhaotian000 (赞：6)

# P12418 【MX-X12-T1】「ALFR Round 5」地铁
复活后的第一个题解。
## 题目大意
有一个 $n\times m$ 大小的网格地图，需要用若干个直线填满他且每个直线必须得跟另一个直线相交。问如果要填满这个网格，最少要用多少直线。

## 题目做法
本题目是一个思维题。观察 $n=5,m=7$ 时他给的图像，发现这肯定不是一个最优解（最开始还被这个带偏了）。经过我们的思考，会发现如果只是要填满这个网格的话，那么可以拿 $n$ 条长度为 $m$ 的直线，或者 $m$ 条长度为 $n$ 的直线。不过，我们无法做到每条线和另一条线相交。这时候，只需要拿一个方向与这些直线垂直的直线，且穿过每条直线，就可以解决这个问题。而这个解决方法的代码就是 $n$ 与 $m$ 的最小值加上 $1$。

但是，你要是直接提交，会发现你只有 $25$ 分。这里的问题是如果说 $n=1$ 或 $m=1$，那么不需要那条垂直的线。所以只需要进行一次特判就可以了。

## AC code
```.cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n,m;
        cin>>n>>m;
        if(n==1||m==1){
            cout<<1<<endl;
            continue;
        }
        cout<<min(n,m)+1<<endl;
    }
}
```

---

## 作者：swate114514 (赞：2)

## 题意
地铁网络由 $n$ 条横向和 $m$ 条纵向通道构成，所有站点必须被地铁线路覆盖，且线路只能在横向或纵向的通道上。目标是最小化线路数量，同时保证所有站点通过换乘可达。

## 思路
假设 $n \leq m$（若 $m < n$，交换两者分析同理）：
需要 $n$ 条横向线路，每条覆盖一行所有站点。此时横向线路之间无直接连通性。需添加至少一条纵向线路，使其与所有横向线路相交，从而实现换乘连通。

总线路数 $cnt$ 就是横向加纵向：
$$cnt=n + 1$$
其中 $n$ 为横向，$1$ 为纵向。

**需要注意的是：** 
- 若 $n=1$ 或 $m=1$，所有站点排成一条直线，只需一条线路即可覆盖所有站点，且自然连通。此时答案直接为 `1`。

## 证明
横向线路覆盖所有行，纵向线路覆盖一列，所有站点被覆盖。

任意两站点可通过所在行横向线路换乘到纵向线路，再转至其他行。

若仅用 $n$ 条横向线路，无法连通不同行。若减少纵向线路数量，无法覆盖所有行间的换乘需求。

因此，最少线路数为 $\min(n, m) + 1$。

## Code
```cpp
#include <iostream>

using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        if (n == 1 || m == 1) {  // 单行或单列
            cout << 1 << endl;
        } else {  // 一般情况
            cout << min(n, m) + 1 << endl;
        }
    }

    return 0;
}
```

---

## 作者：xyx404 (赞：1)

## 思路：

通过分析，可以发现：
- 当 $n$ 和 $m$ 中有一个为 $1$ 时，只用一条线就可以，答案为 $1$。
- 当 $n$ 和 $m$ 中没有一个为 $1$ 时，当  $n<m$ 时，最优方案是是用 $n$ 条线把每一行的所有车站连起来，再用一条线把一列连起来，就可以实现，答案为 $n+1$；同理当  $n>m$ 时，答案为 $m+1$，综上 $ans=\min(n,m)+1$。

如果还是无法理解，可以看看图片。  
![](https://cdn.luogu.com.cn/upload/image_hosting/jlt4455s.png)

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long
int T;
int main(){
	cin>>T;
	while(T--){
		int n,m;
		cin>>n>>m;
		if(n==1||m==1){
			cout<<"1\n";
		}
		else{
			cout<<min(n,m)+1<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：GeorgeDeng (赞：1)

简单题。

## 题目分析

$n \times m$ 的网格内，在线上连一条不能拐弯的边，使得网格上每个点都可以互相到达，问你最小要连多少边才可以满足要求。

## 思路解析

我们可以贪心地连边，每次连边都连到底，这样就省去了拼接的部分。题目要求你连的边最少，且要把这个网格连通，有两种情况可以考虑：

- 第一条边连最上面的横边，接下来 $m$ 条纵边把每个点都连通，连了 $m+1$ 条边。
- 第一条边连最左边的纵边，接下来 $n$ 条横边把每个点都连通，连了 $n+1$ 条边。

这样肯定是最优的。

### 正确性证明：

假设 $n<m$，每个点都连上最少要 $n$ 条边，如下图（感觉我手写的 $n$ 是不是有点不对劲）。

![](https://cdn.luogu.com.cn/upload/image_hosting/u6viheoc.png)

打勾的地方是选中的边。但是这个时候并不连通，所以还需要 $1$ 条纵边把所有边连在一起，总边数为 $n+1$ 条边。\
当 $m<n$ 的时候同理，需要 $m+1$ 条边。

所以大多数时候，答案总是 $\min(n+1,m+1)$。

当然，你可以把 $1$ 提出来，答案就变成 $1+\min(n,m)$ 了。

但是也有特殊情况：当 $n=1$ 或 $m=1$ 的时候，你总不可能去连 $2$ 条边吧，所以这种情况要特判，直接输出 $1$。


思路讲完了，上代码！

## code：


```cpp
#include <iostream>
using namespace std;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n,m;
        cin>>n>>m;
        if(n==1||m==1){//特判
            cout<<1<<endl;
            continue;
        }
        cout<<1+min(n,m)<<endl;//求答案
    }
    return 0;
}
```

---

## 作者：Soviet_Onion (赞：1)

### Solution
很明显的思路，我们可以选择建设 $N$ 条长度为 $M$ 的横向铁路，再修建任意一条长度为 $N$ 的纵向铁路；或者修建 $M$ 条长度为 $N$ 的纵向铁路，再修建一条长度为 $M$ 的横向铁路。两者取较小的即可。注意当 $\min(N,M)=1$ 时，纵向的或横向的铁路只有一条，无需再次连接，输出 $1$。
### [AC Code](https://www.luogu.com.cn/record/216146269)
```cpp
#include<iostream>
using namespace std;
int main(){
  int t;
  cin>>t;
  for(;t;t--){
    int n,m;
    cin>>n>>m;
    if(min(n,m)==1) cout<<1<<endl;
    else cout<<min(n,m)+1<<endl;
  }
  return 0;
}
```

---

## 作者：M1__ (赞：1)

# 题解：P12418 【MX-X12-T1】「ALFR Round 5」地铁

[Link](https://www.luogu.com.cn/problem/P12418)

![](https://cdn.luogu.com.cn/upload/image_hosting/jer0ioa6.png)

- 如图，首先，当 $n,m \ge 2$ 时，我们考虑每一行或每一列都只有一条地铁线，如果 $m>n$ 那就就选 $n$ 条，反之则选 $m$ 条。这样可以使地铁线覆盖范围更广，同时也能使地铁线路最少。
- 但是铁路还要满足无论从哪个地铁站出发乘坐地铁，经过若干次换乘（可以不换乘），都一定可以到达其它所有地铁站。所以必定有一条线路分别和上述的 $\min(n,m)$ 条线路至少有一个交点。所以答案为 $\min(n,m)+1$。
- 当 $n=1$ 或 $m=1$ 时，此时只需要一条长为 $n$ 或 $m$ 的铁路线来使其覆盖全部即可。
- 故答案 $y$ 为：

$$
y = 
\begin{cases} 
\min(n, m) + 1, & \text{if } n \geq 2 \text{ and } m \geq 2 \\
1, & \text{if } n = 1 \text{ or } m = 1 
\end{cases}
$$


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,t;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(n==1||m==1) cout<<1<<endl;
		else cout<<min(n,m)+1<<endl;
	}
}
```

---

## 作者：封禁用户 (赞：1)

首先特判 $1$ 的情况。

若 $n$ 和 $m$ 中有一个是 $1$，则只需要建 $1$ 条线路（横穿所有车站）。

否则，使用贪心思想，查看 $n$ 和 $m$ 中哪个小。

如果是 $n$ 小，也就是横向通道较少，最佳策略即为建 $n$ 条横向线路和 $1$ 条纵向线路（跨越所有横向线路）。如果去掉一条纵向线路，地铁图就会变得不连通；如果去掉一条横向线路，就会有站点没有被地铁覆盖。总而言之，如果有 $1$ 条横向通道没有地铁，就需要 $m$ 条纵向地铁来填满，这样的生意谁都不愿意干。

$m$ 小的情况类似讨论即可，答案为 $m+1$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,m,ans; 
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(min(n,m)==1)
			ans=1;
		else
			ans=min(n,m)+1;
		cout<<ans<<"\n";
	}
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

首先考虑最为特殊的情况：$n = 1$ 或 $m = 1$，当只有 $1$ 行或者只有 $1$ 列的情况下，我们只需要 $1$ 条路线将所有站点横着（$n = 1$）或者竖着（$m=1$）连接起来即可。\
接着考虑普遍情况：由于地铁线路需要保证尽量地少，并且不能转弯，因此每一条地铁线路应该从头直插到尾，也就是最长的线路。那么，横向就会出现 $n$ 条，纵向就会出现 $m$ 条这样的线路。\
为保证每个地铁线路都联通，那么肯定先建好所有的横向线路或者是纵向线路，考虑需要数量最少，因此要先建出 $\min(n, m)$ 条道路，不过不在同一行（列）的站点无法联通，因此需要再在不同方向（横向全部建好就建纵向，反之亦然）再建一条贯穿的道路，以保证联通，故答案为 $\min(n,m) + 1$。

---

## 作者：Chenxuhang_play (赞：0)

题目传送门：<https://www.luogu.com.cn/problem/P12418>

## 思路

总结一下题目，除了地铁不能拐弯，我们还可以知道：**地铁的长度不限**。

题目要求，所有地铁必须连通。看样例解释的第三组可以想到，一种最佳的方法为在每一行修建一条地铁线路贯穿这一行的所有站点，并在第一列修建一条地铁线路贯穿这一列的所有站点。这时所有的站点就是连通的了。不过这种方法有个前提，那就是 $n<m$。

同理，我们可以想出 $n>m$ 时的最佳方法。记得特判 $n=m$ 和 $n,m$ 中最小的为 $1$ 的情况。综上，我们可以得到最佳方法：

- 当 $m，n$ 中最小的为 $1$ 时，修建一条铁路即可贯穿所有站点；

- 当 $n<m$ 时，在每一行修建一条地铁线路贯穿这一行的所有站点，并在第一列修建一条地铁线路贯穿这一列的所有站点；

- 当 $n>m$ 时，在每一列修建一条地铁线路贯穿这一列的所有站点，并在第一行修建一条地铁线路贯穿这一行的所有站点；

- 当 $n=m$ 时，无论使用第二种方法还是第三种方法，其结果都为最优。

当然，在实现过程中，可以使用 `min` 函数来合并第二种、第三种和第四种方法。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int q,n,m;
	cin>>q;
	for(int i=0;i<q;i++)
	{
		cin>>n>>m;
		if(min(n,m)==1) cout<<1<<endl;
		else cout<<min(n,m)+1<<endl;
	}
	return 0;
}
```

---


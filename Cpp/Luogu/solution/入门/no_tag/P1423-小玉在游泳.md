# 小玉在游泳

## 题目描述

小玉开心的在游泳，可是她很快难过的发现，自己的力气不够，游泳好累哦。已知小玉第一步能游 $2$ 米，可是随着越来越累，力气越来越小，她接下来的每一步都只能游出上一步距离的 $98\%$。现在小玉想知道，如果要游到距离 $s$ 米的地方，她需要游多少步呢。请你编程解决这个问题。


## 说明/提示

数据保证，$0 \leq s < 100$，且 $s$ 小数点后最多只有一位。

## 样例 #1

### 输入

```
4.3```

### 输出

```
3```

# 题解

## 作者：乌拉 (赞：528)

数学方法



O(1)时间复杂度

等比数列求和公式


![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1747555526,1280050457&fm=58)


每次游的距离为上一次的0.98倍，构成一个公比为0.98的等比数列


现要使其前ans项大于等于一个值


只要代入公式并向上取整即可


下附超短代码



```cpp
#include<bits/stdc++.h>
double x;
int main()
{
    std::cin>>x;
    std::cout<<ceil(log(1-x/100)/log(0.98));
    return 0;
}

```

---

## 作者：安笙凉城 (赞：240)

//这道题非常简单，思路是定义一个变量表示小玉一次的游泳距离，每游一次就把她游一次的距离乘98%，并把游泳次数加一，当游过的距离大于输入的距离时，跳出循环并输出游泳次数。**注意输入的距离可能为小数，所以它要定义成浮点数。**


#include<bits/stdc++.h>//万能头文件，OJ不能用，洛谷还是很开放的。




```cpp
using namespace std;
int ans=0;//定义的游泳次数。
long double x,s=2,d=0;//x表示输入的距离，s表示小玉一次的游泳距离，d表示她游过的距离。
int main()
{
    cin>>x;
    while(d<x)//循环条件是游过的距离小于输入的距离，如果大于或等于，跳出循环。
      {
          d+=s;//每次加上她游一次的距离。
          s=s/100*98;//因为体力耗损，这一次游的距离为上一次的98%。
          ans++;//游泳次数每次增加一。
      }
    cout<<ans<<endl;//输出答案。
    return 0;//结束。
}
```

---

## 作者：瑞星 (赞：101)

这是一道很简单的题。内容其实跟级数求和一样

代码如下...

```cpp
#include<iostream>
using namespace std;
int main()
{
  double x;  cin>>x;  //输入的数据
  double sum=0.0;   //存储游的距离
  int ans=0;             //储存步数
  double tmp=2;     //储存每一步的距离
  while(sum<=x)    //当游的距离还没大于应游的距离时，就执行
  { 
    sum=sum+tmp;  //累加每一步
    tmp=tmp*0.98;   //步数距离更新
    ans++;            //每执行一次循环，步数+1
  }
  cout<<ans<<endl;
  return 0;
}
```

---

## 作者：杨江河 (赞：44)

**新思路，这题不用循环！**

本题运用高中数学必修一、必修五的知识，指数函数，对数函数，反函数，以及等比数列求和公式。

献上代码。亲测能用。

```cpp
#include<cmath>
#include<iostream>
using namespace std;
int main(){
     double s,n;
    cin>>s;
    n=ceil(log(1-0.01*s)/log(0.98));
    cout<<n;
    return 0;
}
```
设步数为n，实际路程为s
由等比数列求和公式，可以知道s=2\*(1-0.98^n)/(1-0.98)   1式

那么反过来，n=log(1-0.01\*s)/log(0.98)    2式

这里的log是求自然对数，相当于数学书里的ln，这里运用了换底公式

然后现在还有一个问题，题目中n全部都是整数，也就是说，宁可多走一步步，让实际路程>=要求路程

因此在2式中，一旦n算出来是带小数的，就得把它进一位，因此再加一个ceil函数，ok。


---

## 作者：童年如作业 (赞：35)

呵呵，这题得用小数......

不管了，趁还年轻赶紧水一发↖(^ω^)↗↖(^ω^)↗↖(^ω^)↗：

```cpp
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
    double k=2.0,x,l=0.0;//依次为小玉每次游泳距离，x，及计数器；
    cin>>x;
    for(int i=1;;i++)//死循环；
    {
        l+=k;//每次+k；
        if(l>x||l==x)//如果大于或等于x，停止并输出次数i！！！
        {
            cout<<i;
            break;
        }
        k*=0.98;//步长逐渐变短；
    }
    return 0;
}
做这题一定得用两个计数器，一个是步长，一个是距离。
```

---

## 作者：Darky (赞：30)

看上去都是看总距离减来判断的，发个累计距离c的

```cpp

#include<stdio.h>
int main()
{
    float a,b=2,k=2;/*距离可能非整*/
    int i=1;/*由于数据弱就int即可*/
    scanf("%f",&a);/*输入目标*/
    for(i=1;i<=99999999;i++)
    {if(k>a) break;/*判断是否游到目标*/
     else 
     {
          b=b*0.98;/*每步能游的距离*/
          k=b+k;/*每步结束后的已游总距离*/
      }}
     printf("%d",i);/*输出步数*/
     return 0;
}

```

---

## 作者：ljxljxljx (赞：25)

**发现P党的好少，来发一个Pascal**

```cpp
var
i:integer;//记录游了几次。
sum,m,now:real;//简洁的英文（不懂的看一看：sum是存储器，存储游了几米；m是距离；now是这次能游几米。）。
begin
read(m);//读入，不解释。
sum:=2;//第一次能游2米。
now:=2;//同上。
i:=1;//第一次，记录。
while sum<m do//判断，大于等于跳出。
begin
  now:=now*0.98;//这次的游泳长度。
  sum:=sum+now;//共游了几米。
  inc(i);//累加。
end;
write(i);//输出，应该不用解释。
end.
```
不要抄，理解最重要。
这题不难，模拟一下，自己很容易做出来，一遍过。

（实在不会的可自己把情况输进去，也就100个左右。）


---

## 作者：kj415j45 (赞：16)

```cpp

#include<stdio.h>
int main()
{
    double x=0,a=2;
    long long i=0;    //longlong只是怕炸
    scanf("%lf",&x);
    do
    {
        x-=a;     //游1步，距离-a
        a*=0.98;  //下一步距离变为98%
        i++;      //记住游了1步
    }while(x>0);
    printf("%lld",i); //惊奇地发现出结果了
    return 0;         //提示：99.99999999999999（小数点后14个9）是炸的，尽管数据“确实”小于100【手动滑稽】
}

```

---

## 作者：RainShalder (赞：15)

-刚拿到这道题，最先想到的是二分，然后很顺利的用二分过了

-看到题解里面没有用二分做的，那我来一发二分题解

-大体思路：二分游泳步数，每二分一个答案就模拟一次。

-可以通过一次剪枝来进行简化：当模拟出的距离大于目标距离就直接break;

-AC代码如下：

```cpp
#include<iostream>
#include<limits.h>       //为了使用INT_MAX
using namespace std;
int L,R=INT_MAX,mid;    //左端点为0，右端点为INT的最大值
double target,dist,per=2;   //三个变量分别是目标、每次模拟的总距离和每步的长度。
int main()
{
    cin>>target;
    while(R>=L)   //以下就是一些模板化的内容了
    {
        mid=(L+R)/2;     //取中间值
        for(int i=1;i<=mid;i++)    //开始一步步地模拟
        {
            dist+=per;
            per*=0.98;
            if(dist>target)     //剪枝。如果模拟出的距离大于目标，直接break;
                break;
        }
        if(dist>target)
            R=mid-1;
        else
            L=mid+1;       //之所以-1/+1是为了避免出现精度错误
        dist=0;
        per=2;           //还原初始值。这一步一定别忘了
    }
    cout<<L;
} 
```
-二分实施下来还是很简单的，记住那几个容易出错的点就好了。实测0ms，小数据可能比枚举慢，大数据就要快得多。


---

## 作者：dingpeier (赞：15)

本题实际上就是一个累加求和的过程，用while语句判断是否到达目标距离，如果没有到达，就继续游；

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
float a,s,h=2;//h是每次游的长度，要用实型，因为会出现小数；
int step; //需要游的次数
int main(){
    cin>>a;//读入目标长度
    while (s<a){//判断游的距离是否小于目标距离
        s=s+h;//累加游的距离；
        h=h*0.98;//每次游的距离乘以98%；
        step++; 每游一次，计数器加1；
    }
    cout<<step;
    return 0;
}
```

---

## 作者：chenyx (赞：4)

此题用普通的for循环式可以解决的，但是如果用数学方法会快点的


我们先想想，若游的距离是整数，那么，游的距离=100\*(1-0.98^n).

是设游的距离为x

0.98^n=1-x/100

再化则成为n=log(1-n/100)/log(0.98)

so程序就是

```cpp

#include <iostream>
#include<cmath>
using namespace std;
double n;
int main()
{
    scanf("%lf",&n);
    printf("%.0lf",ceil(log(1-n/100)/log(0.98)));
    system("pause");
    return 0;
}

```
不过这好像有点小题大做的嫌疑


---

## 作者：linjinyu (赞：4)

大家好，我这个新手露一手，我来帮帮你们，诸位学习pascal的朋友们，请看好了：

用当型循环控制语句：


```cpp
var a,b:real;
      c:longint;//变量a,b实型，c整形。
begin
     readln(a);
     b:=2;
     c:=0;//b是一步长，c是步数，a是路程。
     while a>0 do//当a＞0，重复。
    begin//这种方法必须要‘begin’ 和‘end；‘。
    a:=a-b;//a减掉一步。
    b:=b*0.98;    
    c:=c+1;//加一步。
    end;
    writeln(c);输出步数。
end.
```
或用直到型循环控制语句：
```cpp
var a,b:real;
      c:longint;
begin
readln(a);
b:=2;
c:=0;
repeat
a:=a-b;
b:=b*0.98;
c:=c+1;
until a<=0;
writeln(c);
end.
过程只供参考，谢谢大家的配合！！！下次再见！
```

---

## 作者：王义涵 (赞：4)

```cpp
var
  a,b,d:real;//此处应该设为实型，a为读入的数，b为小玉要总共游的米数，d为每步游的米数
  c:int64;//c为总步数
begin
  read(a);//先读入小玉要游的米数
  b:=2;//小玉现在总共游了两米
  d:=2;//小玉第一步可以游两米
  c:=1;//根据前面的处理，小玉走的步数应该提前设为1
  while b<=a do//循环开始，结束条件，b≥a，此处的b<=a 应该改为b<a,但数据出的不好，所以我全部AC
    begin
      inc(c);//步数加一
      d:=d*0.98;//这是即将游下一步的米数
      b:=b+d;//加上d，这是游玩这一步的总米数
    end;
  write(c);//注意了，这里是输出步数，我第一次就打错了
end.
//注：此题还是比较水，找对方向就可以做了。这是本人第一次做题解，希望大家多多支持！！谢谢！
```

---

## 作者：HaydenICE (赞：3)

一道非常简单的循环题，直接看代码
```
#include <iostream>
using namespace std;
int ans = 1;//已经游了一次 
double n,m;
int main(){
	cin >> n;
	m = 2;//小玉刚开始的力气 
	n -= m;//小玉游了一次 
	for(int i = 1;i <= 0xFFFFFFF;i++){//次数是肯定要够的 
		m *= 0.98;//小玉没有力气,每次只能游98% 
		n -= m;//开始游泳 
		ans++;//次数+1 
		if(n <= 0){//如果游够了就停止循环 
			break;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Jelly_Goat (赞：2)

这道题可以用简单的~~蒟蒻~~do-while循环，方式：直到型  
因为是~~萌新~~/~~蒟蒻~~，所以并不知道这道题的时间/空间复杂度是多大

脚踩std(*^▽^*)摩擦
```cpp
#include <iostream>
#include <cmath>
#define temp2 2//最初的步数
using namespace std;

int main()
{
	float mb,sum=0;
	int step=0;
	cin>>mb;
	do
	{
		sum=sum+temp2*pow(0.98,step);//利用乘方求解也不错，挺简洁，
        //但是别玩脱了造成TLE啊
		step++;//步数计数器
	}while (sum<mb);//大于等于都不行，直接判断是否小于目标，不满足就停
    //本方法略比for稍微好阅读一点，也更规范（蒟蒻）
	cout<<step;
	return 0;
}

```
代码亲测~~（蒟蒻求过）~~

---

## 作者：Delta_Cosh (赞：2)

本题可以通过**数学推导**给出一个十分简洁的程序。

实际上使用**等比数列**推导的方法有一名大佬已经说过了。不过他给出的是C++代码，我在这里给出的是Pascal的。

推导：根据![等比数列求和公式：](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1747555526,1280050457&fm=58)

代入数据可得：Sn=$\frac{2(1-$${0.98}^n$$)}{1-0.98}$=100(1-$${0.98}^n$$);

令其大于需移动距离x有：100(1-$${0.98}^n$$)>x;

变换一下有：$${0.98}^n$$<1-$\frac{x}{100}$;

这样就有了这个程序：

```pascal
program p1423;
var     
        x,cw:double;
        n:integer;
begin
        read(x);
        x:=1-x/100;
        cw:=0.98;
        n:=1;
        while cw>x do
        begin
                inc(n);
                cw:=0.98*cw
        end;
        write(n)
end. 
```
以上！


---

## 作者：zhengzehao_ (赞：2)

###pascal新手，循环什么的还只是一知半解，本来是抱着WA来试试看的，没想到居然满分过了，不可思议。这种写法个人认为写起来是比较简单的吧，没有什么很复杂很复杂的语法，循环也只用了repeat和until这个。


###源代码如下：


```pascal
var
  a,s,v:real;  //a表示目标距离，s表示已经游过的距离，v表示速度
  n:integer;  //n表示游的步数
begin
  readln(a);
  s:=2;
  v:=2;
  n:=1;  //在循环前先游一次

  repeat  //循环开始
    v:=v*0.98;  //每次重复速度都是原来的98%
    s:=s+v;  //原路程加上新游过的路程
    n:=n+1;  //游的步数增加一步
  until s>=a;  //循环结束

  writeln(n);
end.
```
###语句粗拙还请见谅，希望能对大家有帮助。


---

## 作者：plazum (赞：2)

第一步是2米，不是2\*0.98米……

```cpp

#include<iostream>
using namespace std;
unsigned n=1;
double x,a=2;
int main()
{
    cin>>x;
    x-=2;
    for(;x>0;++n)x-=a*=.98;
    cout<<n;
    
    return 0;
}

```

---

## 作者：浮尘ii (赞：2)

发现没有C/C++的暴力程序，便发一下。注释很清楚。只需要用几个变量记录几个量，再用循环模拟就可以了。

```cpp

#include <iostream>
#include <cstdio>

using namespace std;

double now(2.0), away, now_away(2.0);    
//now记录现在每次可游的路程，away记录离目的地的距离，now_away记录已游的距离 
int ans(1);
//记录需要的步数 

int main(){
    cin >> away;                    //输入离目的地的距离 
    
    while(now_away < away){        //只要已游的距离少于离目的地的距离，就循环 
        ans++;                    //累加步数 
        now_away += (now *= 0.98);    //增加已游的距离，并把每次可游的距离*98% 
    }
    
    cout << ans << endl;            //输出答案 
    
    return 0;
}

```

---

## 作者：x_faraway_x (赞：2)

极其简单的水题，一个for循环完成任务，要善于利用循环优化代码。

```cpp

#include <iostream>
using namespace std;
int main()
{
    int i;
    double a,b;  //a为读入的数据，b记录每次每次游的距离
    cin >> a;
    for(i=0,b=2.0;a>0.0;i++,a-=b,b*=0.98); //i变量累加记录游了多少步
    cout << i;
    return 0;
}

```
总结一下，善于利用for循环简化代码。


---

## 作者：飞翔中的PHX (赞：1)





```cpp
#include<cstdio>
#include<iostream>
using namespace std;
float n=2,i,m;    //初始化第一次游2m；
int ans;//计次数;
int main()
{
//freopen("1423.in","r",stdin);
//freopen("1423.out","w",stdout);
cin>>m;//输入终点
while(1)
{
ans++;//次数++；
i=i+n;//加上这次可以游到哪;
n=n*0.98;//计算下一次游多远；
if(i>=m)//对比这次可不可以游到终点，可以就跳出；
break;
}
cout<<ans;//输出次数；
return 0;
}

```

---

## 作者：封禁用户 (赞：1)

此题比较简单



```cpp
#include<iostream>      //头文件
#include<algorithm>     //头文件
using namespace std;
double a,b,c,e;   //开变量
int main()
{
    cin>>a;  //输入a
    b=2;
    for(int i=1;c<a;i++)
 {
    c=c+b;     //循环成上一次
    b=b*0.98;
    e++;
 }
    cout<<e;   //输入
    return 0;
}
```

---

## 作者：visions (赞：1)

表示刚回归于是在刷新手村←

这题没啥技术含量 一开始用repeat写竟然都没过，哭瞎，于是

用总距离减去每步

```delphi
var x,t:real;
    i,s:longint;
begin
  read(x); //总距离
  t:=2;
  s:=0;
  while x>0 do
  begin
    x:=x-t;//用总距离减去能游得距离得剩余要游距离
    t:=t*0.98;
    inc(s);
  end;
  writeln(s);
end.
```


【躺】


---

## 作者：a1014598658 (赞：0)



```cpp
#include<iostream>
using namespace std;
int main()
{
   double x;//必须设置为double型 不然循环比较的时候double和int比较会出错
    cin>>x;
    double s=0.0;
    double y=2;//每一步所游泳的距离
    int i=0;//表示步数
    while(s<x)
    {
        ++i;
        s+=y;
      y=y*0.98;
    }
    cout<<i<<endl;
}

```

---

## 作者：Ivanhunt (赞：0)

```cpp
#include<iostream>
using namespace std;
double a,x;
int main(){
    int k;  //k作为计数器使用
    x=2;  //初始化第一次可以游2m
    cin>>a; //输入目标距离
    while(a>0){
        k++; //开始计数
        a=a-x; //距离目标剩余的距离
        x=x*0.98; //下一次能游的距离
    }
    cout<<k;  //输出步数
    return 0;
}
```

---

## 作者：六生 (赞：0)

普通思路  0.0

```cpp
#include<iostream>
using namespace std;
int main()
{
    float zc,bc=2,s=0,bs=0; //用float类型，因为每次步数要*0.98，会出现小数
    cin>>zc;//输出总长
    while(s<zc)//每次已走的增加，步数++，步长*0.98
      {
          s+=bc;
          bs++;
          bc=(bc*0.98);
      }
    cout<<bs;//输出步数
}
```

---

## 作者：2022135551q (赞：0)

```cpp
#include <iostream>
using namespace std;
int main() {
        int a=0;
        double t,s=0,k=2;
        cin>>t;
        while(s<=t){ //用while循环，一但求出的路程<=输入的路程就退出
            s+=k; 
            a++;   //顺序不能反，关系到多1或少1
            k*=0.98;
        }
        cout<<a;
        return 0;
}
```

---

## 作者：合451518 (赞：0)

传说中的水题。

读入n为所需要游的米数,pre记录上一次游了多少米，以便计算这一次要游多少米，s表示已经游了多少米

repeat ... until false是死循环，直到游的距离大于n。

满足条件之后直接输出，halt退程序。

粘代码：

```pascal
var
 i:longint;
 n,s,pre:extended;
begin
 readln(n);
 
 s:=2.0;
 pre:=2.0;
 i:=1;
 repeat
  inc(i);
  pre:=pre*0.98;
  s:=s+pre;
  if s>=n then begin write(i);halt;end;
 until false;
end.
```

---

## 作者：天下第一剑客 (赞：0)

似乎和别人的不太一样

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long step=0;
double a,ans=0;//ans并不是答案，step才是，ans记录已经游过的长度
int main(){
    cin>>a;
    while (ans<a){
        ans=ans+2*pow(0.98,double(step));
        step++;
    }
    cout<<step;
    return 0;
}
```

---

## 作者：洛古1421 (赞：0)

```cpp
var
now,dis:real;
b:longint;
begin
read(dis);//读入；
b:=1;
now:=2;
dis:=dis-now;
while dis>0 do
begin
dis:=dis-now*0.98;//每循环一次，就减少每次游的距离；
b:=b+1;//计算步数；
now:=now*0.98;求下一步游的距离；
end;
readln;
write(b);
end.
```

---

## 作者：cwoj (赞：0)

如果这道题用for循环，就要用一个几乎无限次的条件加上一个break，虽然这是一道新手村的水体，不过我更建议用while循环（不是do~while循环！！！）。

#include<iostream>//不加头文件，评测机连WA（Wrong Answer）都不会给你一个……

#include<cmath>//后面会使用到pow函数（pow（a，b）就是求a^b，即a的b次方）

```cpp
using namespace std;
int main()
{
    int foot=1,i=1;    //foot为步数的计数器，i为幂的计数器
    float distance,meter=2;//meter为每次能走的距离的计数器
    cin>>distance;
    while (meter<distance)//当meter小于距离时，进行循环
    {
        meter+=2*pow(0.98,i);
```
/\*难点：计算距离（虽然这样有点小题大做……）
我们来举些例子：当第一次时，距离（S）=2+2\*0.98；第二次时，S=2+2\*0.98+2\*0.98\*0.98

每一次都是上一次加上了2\*0.98的n（循环次数，即i）次方

由此推导出公式meter=meter+2\*0.98^i，转化为meter+=2\*pow(0.98,i)\*/

```cpp
        foot++;//步数加1
        i++;//控制幂的计数器加1
    }
    cout<<foot;//输出步数的计数器
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

```cpp
var x,k:real;
    n:single;
    endn:integer;
begin
  readln(n);
  x:=2;//x代表每次游的米数。
  endn:=0;//endn表示它游的步数。
  k:=0;//k代表总共游了多少米。
  repeat
    k:=k+x;//记住,开始游的米数是2m而不是2*0.98m。
    x:=x*0.98;//每次都游上一次的98/100也就是0.98
    inc(endn);//记录它游动的步数
  until k>=n;//在他游过或者游到时停下来
  writeln(endn);
end.
```

---

## 作者：huangyixuan (赞：0)

```cpp
#include<iostream>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<cstdio>//能加的头文件都加上，蒟蒻们可以不管。
using namespace std;
int main()
{
    double n,i,j,a=2;//n是距离，a是小玉每一步距离
    cin>>n;
    for(i=1;;i++)//循环直到n<=0，i计数
    {
        n-=a;//每游一步，距离缩小a;
        a*=0.98;//a也缩小
        if(n<=0)break;//判断：小玉到没到终点
    }
    cout<<i;//输出步数
    return 0;
}

```

---


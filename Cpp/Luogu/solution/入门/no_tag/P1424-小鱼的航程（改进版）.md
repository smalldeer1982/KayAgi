# 小鱼的航程（改进版）

## 题目描述

有一只小鱼，它平日每天游泳 $250$ 公里，周末休息（实行双休日)，假设从周 $x$ 开始算起，过了 $n$ 天以后，小鱼一共累计游泳了多少公里呢？

## 说明/提示

数据保证，$1\le x \le 7$，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
3 10```

### 输出

```
2000```

# 题解

## 作者：Clare613 (赞：20)

~~捡个漏？~~\
~~小鱼好可爱。~~
## 思路
这道题可以纯模拟来完成这道题，只要枚举 $n$ 天，然后我们直接用 $x$ 来模拟是星期几，逢双休日就不加，最后输出即可。
## code:

```cpp
#include<bits/stdc++.h> 
using namespace std;
 
int main(){
    long long x,n,g=0;
    cin>>x>>n;
    for(int i=1;i<=n;i++){
		if(x!=6&&x!=7){
			g+=250;
		}
		x++;
		if(x>7) x=1;
	}
	cout<<g;
	return 0; 
} 
```

---

## 作者：shinzanmono (赞：5)

给出两种做法：

## 做法 1

考虑 $n\leq 10^6$，所以我们可以暴力枚举接下来 $n$ 天，对齐判断是星期几，如果不是周末就将最终答案加 $250$。

```cpp
int ans=0;
for(int i=1,j=x;i<=n;i++,j++){
  if(j<=5)ans+=250;
  if(j==7)j=0;
}
```

## 做法 2

考虑每 $7$ 天游的路程相同，均为 $1250$，我们只需要处理两边不满 $7$ 天的天数即可。左面不满七天的天数是 $8-x$ 天，可以有用的是 $\max(6-x,0)$ 天。总天数 $n$ 要减去 $8-x$。右面剩余的天数是 $n\bmod 7$，可以游泳的天数为 $\min(n\bmod 7,5)$ 天。计算答案即可。

```cpp
int pre=max(6-x,0);
n-=8-x;
int ans=pre*150+n/7*1250+min(n%7,5)*150;
```

---

## 作者：GSQ0829 (赞：4)

### 解题思路：
这道题只要循环判断如果是星期一到星期五的时间，那么公里数就加上 $250$。如果到了周日，那么判断是星期几的计数器就清零。最后输出公里数即可。

---
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int x, n, k, ans;

int main() {
	cin >> x >> n;
	k = x;
	for (int i = 1; i <= n; i++, k++) {
		if (k < 6) ans += 250;
		if (k == 7) k = 0;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：wrh316 (赞：2)

### 思路
用变量 $x$ 模拟日期，不是周末就游 $250$ 公里，是周末就休息，计数即可。

### 代码
```c++
#include<bits/stdc++.h>
using namespace std;

int x;
unsigned long long n, ans;
int main() {
	cin >> x >> n;
	for (int i = 0; i < n; i++) {
		if ((x != 6) && (x != 7)) ans += 250;
		if (x == 7) x = 1;
		else x++;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：GoldenSTEVE7 (赞：2)

## 思路
小鱼游了 $n$ 天，显然，这 $n$ 天可以分为若干个整天以及若干个整周。“整周”指周一到周日所构成的完整一周。

而输入又给出了一个 $x$，指的是开始时是星期几。那我们把前面的非整周暴力枚举，后面的整周整体计算，最后剩余的若干天再单独计算并且加入答案即可。

具体实现请看下面代码。

## 代码
```cpp
#include <iostream>
using namespace std;

int main() {
    int x, n; cin >> x >> n; int ans = 0;
    for(; x <= 7; x++) {// 枚举到第一个周日
        if(x <= 5) ans++;
        n--;
    }
    ans += n / 7 * 5; // 有 n / 7 个整周，剩余 n % 7 天，共 n / 7 * 5 个工作日
    n %= 7;
    if(n == 6) n--;  // 细节，n %= 7 后 1 <= n <= 6，若 n = 6，会多出一个周六，这个不能计算进去
    ans += n;
    cout << ans * 250; // 我们计算的是没有 * 250 的，要记得乘上
	return 0;
}
```

---

## 作者：haobao123456 (赞：0)

# 思路：
这道题可以使用暴力枚举的方法。模拟每一天并进行判断是否是周末，并且每当到星期天的时候，要到下一天的时候，要把他变成星期一，因为没有星期八。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,k,s=0;
	scanf("%d %d",&n,&k);
	for(int i=1; i<=k; i++){
		if(n!=6 && n!=7) s+=250; //加上每天游的距离
		if(n==7) n=1;
		else n++;
	}
	printf("%d",s);
	return 0;
}
```

---


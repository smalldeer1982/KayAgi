# 三子棋I

## 题目描述

小 a 和 uim 喜欢互相切磋三子棋。三子棋大家都玩过是吗？就是在九宫格里面 OOXX（别想歪了），谁连成 $3$ 个就赢了。

由于小 a 比较愚蠢，uim 总是让他先。

我们用 $9$ 个数字表示棋盘位置：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
1 & 2 & 3 \\\hline
4 & 5 & 6 \\\hline
7 & 8 & 9 \\\hline
\end{array}$$


所有的棋谱都是已经结束的棋局，要么一方获胜，要么平局。

今天，他们下了一下午的棋，小 a 为了提高技术，录下了很多棋谱。他想知道，一盘棋结束时，到底是谁赢。

## 样例 #1

### 输入

```
5237649
```

### 输出

```
xiaoa wins.
```

## 样例 #2

### 输入

```
539128647```

### 输出

```
drew.```

# 题解

## 作者：a___ (赞：90)

看完所有题解，写的都**太复杂**了!

打个表不就行了吗

代码：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int hang[10]={0,//一整行连（编号1,2,3）
1,1,1,
2,2,2,
3,3,3},
lie[10]={0,//一整列连（编号4,5,6）
4,5,6,
4,5,6,
4,5,6},
djx1[10]={0,//左上↘右下对角线连（编号7）
7,0,0,
0,7,0,
0,0,7},
djx2[10]={0,//右上↙左下对角线连（编号8）
0,0,8,
0,8,0,
8,0,0};
int x[2][9];//两个人的棋每一种连法的连子数
string s;
int main()
{
    cin>>s;
    int i,len=s.size();
    for (i=0;i<len;i++)
    {
        x[i%2][hang[s[i]-'0']]++;
        x[i%2][lie[s[i]-'0']]++;
        x[i%2][djx1[s[i]-'0']]++;
        x[i%2][djx2[s[i]-'0']]++;
                      //各种连法都++
    }
    for (i=1;i<=8;i++)
    if (x[0][i]==3){cout<<"xiaoa wins.\n";return 0;}//如果小a赢（连3个）
    else if (x[1][i]==3){cout<<"uim wins.\n";return 0;}//如果uim赢（连3个）
    cout<<"drew.\n";//都没赢就平局
    return 0;
}
```

---

## 作者：XiXi (赞：51)

感觉大家都写得挺长啊，蒟蒻放一个稍微短点的代码供大家评赏（可在评论里尽情喷）

缩短思路：很多dalao用二维数组模拟3×3的方格，我用一维模拟：

设dalao们用的是a[x][y]，在我这里就变成了a[(x-1)×3+y]

例子：a[1][1]→a[1] a[2][3]→a[6] a[3][2]→a[8]

还有一个就是大家判定一条线时，很多人是如果全0，就是小a赢，全1就是uim赢，我觉得可以先判断是否都一样，都一样再判断其中任意一个是0还是1，这样也可以简洁一些（0和1只是我定的）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int i,x,p=0,q=0,r=0,a[1111]; string s;
    cin>>s;   //读入
    for (i=0;i<s.size();i++)
    {
    	x=int(s[i])-48;
    	a[x]=i%2;   //一维数组模拟
	}
	if (a[1]==a[5]&&a[5]==a[9]) {if (a[1]==0) p=1; else q=1; r=1;}   //如同↘样的对角线
	if (a[3]==a[5]&&a[5]==a[7]) {if (a[3]==0) p=1; else q=1; r=1;}   //如图↙样的对角线（复制上面直接修改）
	for (i=1;i<=3;i++) if (a[i]==a[i+3]&&a[i+3]==a[i+6]) {if (a[i]==0) p=1; else q=1; r=1;}   //每列判断是否一致
	for (i=1;i<=9;i+=3) if (a[i]==a[i+1]&&a[i+1]==a[i+2]) {if (a[i]==0) p=1; else q=1; r=1;}   //每行判断是否一致
	if (p&&!q) cout<<"xiaoa"; if (q) cout<<"uim"; if (r) {cout<<" wins."; return 0;}   //输出
	cout<<"drew.";
}
```
我是判断完是否一致后再去判断是小a还是uim的，并且输出也是最后输出，这样压代码也比较方便

欢迎各位dalao在评论吐槽

---

## 作者：Heartlessly (赞：26)

# 看见楼下的代码都比较复杂，贴上 C++ 精练代码。

- ## 先来说说具体思路：

- 1.输入字符串，如果长度小于9，则单数 xiaoa 赢，反之则 uim 赢；

- 2.如果长度等于9，开个 bool 型二维数组，存储棋盘。把 xiaoa 下的地方赋值为1，uim 下的则为0；

- 3.枚举判断所有可能赢的情况，如果有1人赢，就输出结果并返回 0（结束程序）；

- 4.如果以上都不成立，输出“平局”。

```cpp
#include <iostream>
using namespace std;
string s;//表示棋谱
bool board[4][4];//表示棋盘
int main()
{
    ios::sync_with_stdio(0);//关闭同步流加快速度
    cin >> s;
    if ( s.size() < 9 )//如果长度小于9，
    {
        if ( s.size() % 2 == 0 ) cout << "uim wins.";
        else cout << "xiaoa wins.";//判断单数还是双数
        return 0;//结束
    }
    for ( int i = 0 ; i <= 8 ; i++ )
    if ( i % 2 == 0 )
    board[ ( s[i] - '1' ) / 3 + 1 ][ ( s[i] - '1' ) % 3 + 1 ] = 1;
    for ( int i = 1 ; i <= 3 ; i++ )
    {
        //暴力判断
                if ( ( board[i][1] + board[i][2] + board[i][3] == 3 ) || ( board[1][i] + board[2][i] + board[3][i] == 3 ) || ( board[1][1] + board[2][2] + board[3][3] == 3 ) || ( board[3][1] + board[2][2] + board[1][3] == 3 ) )
        {cout << "xiaoa wins."; return 0;}
        else if ( ( board[i][1] + board[i][2] + board[i][3] == 0 ) || ( board[1][i] + board[2][i] + board[3][i] == 0 ) || ( board[1][1] + board[2][2] + board[3][3] == 3 ) || ( board[3][1] + board[2][2] + board[1][3] == 3 ) )
        {cout << "uim wins."; return 0;}
    }//别忘了有斜线的情况，一开始就因为这里80分。
    cout << "drew.";//都没赢输出平局
    return 0;
}
```

---

## 作者：Lucifer_Bartholomew (赞：17)

简单的判断模拟（**大佬勿喷**）

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int i,j,t;
bool m[4][4];
int main()
{
	string s;
	cin>>s;
	for(i=0;i<s.length();i++)
	{
		t=s[i]-'0'-1;
		m[t/3+1][t%3+1]=i%2==0?0:1;
	}//模拟棋盘的状况
	for(i=1;i<=3;i++)
	{
		if(m[i][1]==m[i][2]&&m[i][2]==m[i][3])
		{
			if(m[i][1])cout<<"uim wins.\n";
			else cout<<"xiaoa wins.\n";
			return 0;
		}
		if(m[1][i]==m[2][i]&&m[2][i]==m[3][i])
		{
			if(m[1][i])cout<<"uim wins.\n";
			else cout<<"xiaoa wins.\n";
			return 0;
		}
	}//判断横、纵的情况
	if(m[1][1]==m[2][2]&&m[2][2]==m[3][3])
	{
		if(m[1][1])cout<<"uim wins.\n";
		else cout<<"xiaoa wins.\n";
		return 0;
	}//判断对角线的情况
	if(m[1][3]==m[2][2]&&m[2][2]==m[3][1])
	{
		if(m[1][3])cout<<"uim wins.\n";
		else cout<<"xiaoa wins.\n";
		return 0;
	}//判断对角线的情况
	cout<<"drew.\n";//如果无获胜情况，则平局
	return 0;
}
```

---

## 作者：Qglin_ (赞：8)

一种（个人感觉）虽然麻烦但条理清晰的做法。

总体思路分为3步：输入，判断和AC（

输入用了string，输入一个string然后把每一个数字存入a，最后把q[a]打上标记，标记在1和-1之间替换，最后q数组就成为了棋盘的映射，1表示xiaoa在此落子，-1表示uim在此落子。

判断用了一个check函数，通过判断一行/列/斜线上的棋子是否相同。若相同则表示该玩家胜利，return该玩家的标记用来判断胜负；若平局则return 0.

然后就是在主函数里简短的判断输出了，至此本题AC，总体上还是比较水的一道题（

最后附上AC代码，萌新刚学OI三个月第一篇题解求过orz

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

int q[10],a;

int check() {
	if(q[1]==q[2] && q[2]==q[3])return q[1];
	if(q[4]==q[5] && q[5]==q[6])return q[4];
	if(q[7]==q[8] && q[8]==q[9])return q[7];
	if(q[1]==q[4] && q[4]==q[7])return q[1];
	if(q[2]==q[5] && q[5]==q[8])return q[2];
	if(q[3]==q[6] && q[6]==q[9])return q[3];
	if(q[1]==q[5] && q[5]==q[9])return q[1];
	if(q[3]==q[5] && q[5]==q[7])return q[3];
	else return 0;
}

int main() {
	string s;
	cin>>s;
	int len=s.length();
	int r=1;
	for(int i=0;i<len;i++) {
		a=s[i]-'0';
		q[a]=r;
		r=(-r);//更新r的值，使r的值在1和-1间交替
	}
	int che=check();
	if(che==1)printf("xiaoa wins.");
	else if(che==-1)printf("uim wins.");
	else printf("drew.");
	return 0;
}
```

---

## 作者：Sinwind (赞：7)

思路：

1. 用chess数组记录棋盘。
- 先统一初始化为-1，表示未使用。
- 1表示xiaoa下棋（先手，棋谱的奇数位），0表示uim下棋（后手，棋谱的偶数位）。

2. record记录棋谱（一个数字），count记录棋谱位数（多少步棋），chess数组对应的值改变。
- 例如棋谱为5237649。（棋谱从后往前，和从前往后结果一样）
- 第一位（record % 10）是9，count为1， chess[8]的值为1(count % 2)。
- 第二位（record % 10）是4，count为2， chess[3]的值为0(count % 2)。
- 依次类推。

3. 列举并判断每一种胜利的可能性。
- 若有一方胜利。count的值为奇数，先手胜利，即xiaoa胜利；count为偶数，后手胜利，即uim胜利。
- 若没有一方胜利，平局。

```c
#include <stdio.h>

int main(void)
{
	int chess[9];		//棋盘，初始值为-1，表示未开始，1表示小a下棋，0表示uim下棋
	int count = 0;		//下棋的次数
	int record;		//棋谱

	for (int i = 0; i < 9; i++)
	{
		chess[i] = -1;
	}

	scanf("%d", &record);
	while (record != 0)
	{
		count++;
		chess[record % 10 - 1] = count % 2;
		record /= 10;
	}

	//如果一方胜利
	if ((chess[0] == chess[1] && chess[1] == chess[2]) ||
		(chess[3] == chess[4] && chess[4] == chess[5]) ||
		(chess[6] == chess[7] && chess[7] == chess[8]) ||
		(chess[0] == chess[3] && chess[3] == chess[6]) ||
		(chess[1] == chess[4] && chess[4] == chess[7]) ||
		(chess[2] == chess[5] && chess[5] == chess[8]) ||
		(chess[0] == chess[4] && chess[4] == chess[8]) ||
		(chess[2] == chess[4] && chess[4] == chess[6]))
	{
    		//最后一个出棋的人胜利
		if (count % 2 == 1)
		{
			printf("xiaoa wins.\n");
		}
		else
		{
			printf("uim wins.\n");
		}
	}
    	//平局
	else
	{
		printf("drew.\n");
	}
	
	return 0;
}
```


---

## 作者：Silencedied (赞：7)

乍一看有点懵，再一看基本明白了。

战术仿若千姿百态，然而胜利条件并不多。

如下
```
1.横着       2.竖着        3.左上斜        4.右上斜
  - - -        - o -         o - -          - - o
  o o o        - o -         - o -          - o -
  - - -        - o -         - - o          o - - 

```
那是不是只要找出这些条件的落子坐标规律然后再挨个检查就行了呢。

即为（相信大家都是聪明人，不做解释了）

1.a[x] a[x+1] a[x+2]

2.a[x] a[x+3] a[x+6]

3.a[x] a[x+4] a[x+8]

4.a[x] a[x+2] a[x+4]

问题来了

以第一种举例

当检查到X处时
```
 - X -
 - - -
 - - -
 
如果是这样
 - o o
 o - -
 - - -
 
就过了

很明显是不对的

那就特判呗
```
上代码

(蒟蒻代码，别喷到怀疑人生就行了)
```
#include<iostream>
#include<cstdio>
using namespace std;
char b[100];
int qa[100],qu[100];//叫数组越界整怕了； 
int main(){
    int k=0;
    do{k++;scanf("%c",&b[k]);}while(b[k]!='\n');//无定量读入； 
    k--;
    for(int i=1;i<=k;i++){
		if(i%2==1)qa[(int)b[i]-48]=1;//小a的落子点 
		else if(i%2==0)qu[(int)b[i]-48]=1;//uim的落子点 
    }for(int i=1;i<=9;i++){
		if(qa[i]!=0){
			if(i==1||i==4||i==7||i==8|i==9)//特判 
			if((qa[i+1]!=0&&qa[i+2]!=0)||(qa[i+3]!=0&&qa[i+6]!=0)||(qa[i+4]!=0&&qa[i+8]!=0)){
				cout<<"xiaoa wins."<<endl;return 0;
			}
			if(i==2||i==5||i==6)
			if((qa[i+3]!=0&&qa[i+6]!=0)||(qa[i+4]!=0&&qa[i+8]!=0)){
				cout<<"xiaoa wins."<<endl;return 0;
			}
			if(i==3)
			if((qa[i+2]!=0&&qa[i+4]!=0)||(qa[i+3]!=0&&qa[i+6]!=0)){
				cout<<"xiaoa wins."<<endl;return 0;
			}						
		}
    }for(int i=1;i<=9;i++){
		if(qu[i]!=0){
			if(i==1||i==4||i==7||i==8|i==9)//其实是本蒟蒻累了，直接粘过来了 
			if((qu[i+1]!=0&&qu[i+2]!=0)||(qu[i+3]!=0&&qu[i+6]!=0)||(qu[i+4]!=0&&qu[i+8]!=0)){
				cout<<"uim wins."<<endl;return 0;
			}
			if(i==2||i==5||i==6)
			if((qu[i+3]!=0&&qu[i+6]!=0)||(qu[i+4]!=0&&qu[i+8]!=0)){
				cout<<"uim wins."<<endl;return 0;
			}
			if(i==3)
			if((qu[i+2]!=0&&qu[i+4]!=0)){
				cout<<"uim wins."<<endl;return 0; 
			}						
		}
    }cout<<"drew."<<endl;//判断无果就平局 
    return 0;
}
```
喷轻点 谢谢！

---

## 作者：fondness_zzy (赞：5)

Pascal题解来了！

其实这道题目挺简单的，一遍就过。

代码较多，耐心看。

```cpp
var
n,j,i,m,k,x,y:longint;
s:string;
a:array[1..3,1..3] of longint;//定义变量（因为是九宫格，所以只用开个3*3的二维数组就可以了）
begin//开始程序
readln(s);//读入（用的是字符串）
n:=length(s);//把s的长度存入n中
for i:=1 to n do
if i mod 2=1 then //判断是不是小a下的
begin//一大堆判断开始了
if s[i]='1' then a[1,1]:=1 else
if s[i]='2' then a[1,2]:=1 else
if s[i]='3' then a[1,3]:=1 else
if s[i]='4' then a[2,1]:=1 else
if s[i]='5' then a[2,2]:=1 else
if s[i]='6' then a[2,3]:=1 else
if s[i]='7' then a[3,1]:=1 else
if s[i]='8' then a[3,2]:=1 else
if s[i]='9' then a[3,3]:=1;//将小a下的棋录入模拟棋盘
end
else//又是一大堆判断
if s[i]='1' then a[1,1]:=0 else
if s[i]='2' then a[1,2]:=0 else
if s[i]='3' then a[1,3]:=0 else
if s[i]='4' then a[2,1]:=0 else
if s[i]='5' then a[2,2]:=0 else
if s[i]='6' then a[2,3]:=0 else
if s[i]='7' then a[3,1]:=0 else
if s[i]='8' then a[3,2]:=0 else
if s[i]='9' then a[3,3]:=0;//将uim下的棋录入模拟棋盘
if ((a[1,1]=1)and (a[1,2]=1)and (a[1,3]=1))//又是一段判断
 or((a[2,1]=1)and (a[2,2]=1)and (a[2,3]=1))
 or((a[3,1]=1)and (a[3,2]=1)and (a[3,3]=1))
 or((a[1,1]=1)and (a[2,1]=1)and (a[3,1]=1))
 or((a[1,2]=1)and (a[2,2]=1)and (a[3,2]=1))
 or((a[1,3]=1)and (a[2,3]=1)and (a[3,3]=1))
 or((a[1,1]=1)and (a[2,5]=1)and (a[3,3]=1))
 or((a[1,3]=1)and (a[2,5]=1)and (a[3,1]=1))
then writeln('xiaoa wins.')//判断小a赢了没
else
if ((a[1,1]=0)and (a[1,2]=0)and (a[1,3]=0))//还是一段判断
 or((a[2,1]=0)and (a[2,2]=0)and (a[2,3]=0))
 or((a[3,1]=0)and (a[3,2]=0)and (a[3,3]=0))
 or((a[1,1]=0)and (a[2,1]=0)and (a[3,1]=0))
 or((a[1,2]=0)and (a[2,2]=0)and (a[3,2]=0))
 or((a[1,3]=0)and (a[2,3]=0)and (a[3,3]=0))
 or((a[1,1]=0)and (a[2,5]=0)and (a[3,3]=0))
 or((a[1,3]=0)and (a[2,5]=0)and (a[3,1]=0))
then writeln('uim wins.')//判断uim赢了没
else
writeln('drew.');//如果两者都没有赢，那么就是平局
end.
代码很丑，大牛勿喷······
```

---

## 作者：yuhooo (赞：4)

note：如果没有下满9个棋子就结束了：说明下最后一步棋子的人赢了,下的奇数个棋子，最后一步是xiaoa下的，则xiaoa赢了,不然就是uim赢了。
如果说下满9步棋，最后一步是xiaoa下的，则要么是平局，要么是xiaoa赢了。
```cpp
//容易处理没有下满9步的情况，奇偶判断即可。下满9步的话只需先考虑xiaoa是否能赢，就是判断xiaoa下的所有棋是否能构成所有赢的方式的其中一个，注意xiaoa小的最后一步是决胜之棋，必定参与赢的方式的构成。PS：好像可以直接把赢的方案给出来啊。。。我是在干啥。。。
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
struct Win{					
	public: int a,b,c;						//abc 
	//把Win里面的a,b,c按从小到大排序和下面所有可能方案对应，从而可以直接判断Win的相等
	void set(){
		if(c<b&&a<b&&a<c){					//acb
			int t=b;
			b=c;
			c=t;
		}
		else if(a>b&&a>c&&b>c){				//cba
			int t=c;
			c=a;
			a=t;
		}
		else if(c<a&&a<b&&c<b){				//cab
			int t=c;
			int p=a;
			c=b;
			a=t;
			b=p;
		}
		else if(b<a&&b<c&&a<c){				//bac
			int t=a;
			a=b;
			b=t;	
		}
		else if(b<a&&c<a&&b<c){				//bca
			int p=a;
			a=b;
			b=c;
			c=p;
		}			
	}
	bool operator==(const Win& rhs)         //定义Win的相等
		{
			return( a == rhs.a) && (b == rhs.b) && (c == rhs.c);
		}
};
struct Node{  								
	int point, num;							//三子棋盘上每个点对应的点号，该点对应的赢得方案数
	Win d[4];								//该点参与的赢的方案 如点1参与的赢的方案有：{{1,2,3},{1,4,7},{1,5,9}} 方案数记为3
};
//输入每个点对应的点号，对应的赢得方案数，与赢的方案，注意点0在棋盘上不存在，node[0]占1位
Node node[11]={{0},{1,3,{{1,2,3},{1,4,7},{1,5,9}}},{2,2,{{1,2,3},{2,5,8}}},{3,3,{{1,2,3},{3,6,9},{3,5,7}}},
				{4,2,{{1,4,7},{4,5,6}}},{5,4,{{2,5,8},{4,5,6},{1,5,9},{3,5,7}}},{6,2,{{3,6,9},{4,5,6}}},
				{7,3,{{1,4,7},{3,5,7},{7,8,9}}},{8,2,{{2,5,8},{7,8,9}}},{9,3,{{3,6,9},{7,8,9},{1,5,9}}}};PS
int main(int argc, char *argv[]) {
	char a[10];
	cin>>a;
	int lth=strlen(a);
	if(lth%2&&lth!=9)                        //如果没有下满9个棋子就结束了，说明下最后一步棋子的人赢了
		cout<<"xiaoa wins.";				 //下的奇数个棋子，最后一步是xiaoa下的，则xiaoa赢了
	else if(lth!=9)
		cout<<"uim wins.";					 //偶数个棋子，uim赢了
	else {									 //下满9个棋子，最后一步是xiaoa下的，要么是平局，要么是xiaoa赢
		int idx=a[8]-48;					 //小a赢的话,最后一步棋必定是赢的决胜之棋
		int pre1,pre2,pre3,pre4;			 //把前面小a下的棋子全部找出来，并与最后一步棋结合生成三个元素的集合，并且最后一个棋必定在集合中
		pre1=a[6]-48;
		pre2=a[4]-48;
		pre3=a[2]-48;
		pre4=a[0]-48;
		Win poss[6]={{idx,pre1,pre2},{idx,pre1,pre3},{idx,pre1,pre4},{idx,pre2,pre3},{idx,pre2,pre4},{idx,pre3,pre4}};
		//并且对里面元素按从小到大排序
		for(int i=0;i<6;++i){
			poss[i].set();
		}
		int flag=0;
		for(int i=0;i<node[idx].num;++i){
			for(int j=0;j<6;++j)
				if(node[idx].d[i]==poss[j]){
					flag=1;
					break;
				}
			if(flag)
				break;
		}
		if(flag)
			cout<<"xiaoa wins.";
		else 
			cout<<"drew.";
	}
}
```


---

## 作者：Taoist_Cheewood (赞：3)

这道题判断每一行、列、对角线是否到3；

那么我们可以用一个数组来存每一行、列、对角线上棋子的数量；

因为是两个人，自然开两个（或二维）数组；

附上代码：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int vis[2][9];

int main()
{
	char c[10];
	scanf("%s",c);
	for(int i=0;i<strlen(c);i++)
	{
		int w=i%2;//who 0为xiaoa，1为 uim； 
		int a=c[i]-'0';
		int y=(a%3)?(a%3):3;//竖行位置； 
		int x=(a-y)/3;//横排位置； 
		vis[w][x]++;//0,1,2为横排； 
		vis[w][y+2]++;//3,4,5为竖排； 
		if(x+1==y) vis[w][6]++;
		if(x+y==3) vis[w][7]++;//两个if判断是否在对角线上； 
	}
	for(int i=0;i<8;i++)
		if(vis[0][i]==3)
		{
			printf("xiaoa wins.\n");
			return 0;
		}
		else if(vis[1][i]==3)
		{
			printf("uim wins.\n");
			return 0;
		}
	printf("drew.\n");//两人都没赢，平局； 
	return 0;
}

```

蒟蒻第一次发题解、不喜请勿喷、思路常见、如有雷同、纯属巧合、还请谅解。

---

## 作者：_Felix (赞：3)

```cpp
暴力
直接上代码
我觉得我的代码还算雅观
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[10],hhh=-1;//永远记住我数组只开了a[9]wa了8次。。。
	char y;
	int x;
	memset(a,-1,sizeof(a));
	int i=1;
	while(scanf("%c",&y)&&y>='1'&&y<='9')
	{
		x=y-'0';
		if(i%2==0)
			a[x]=1;
		else if(i%2==1)
			a[x]=0;
		if(a[1]==a[2]&&a[2]==a[3]&&(a[1]==1||a[1]==0))
		{
			hhh=a[1];
			break;
		}//第一行
		if(a[4]==a[5]&&a[5]==a[6]&&(a[4]==1||a[4]==0))
		{
			hhh=a[4];
			break;
		}//第二行
		if(a[7]==a[8]&&a[8]==a[9]&&(a[7]==1||a[7]==0))
		{
			hhh=a[7];
			break;
		}//第三行。横着的,无比暴力
		if(a[1]==a[5]&&a[5]==a[9]&&(a[1]==1||a[1]==0))
		{
			hhh=a[1];
			break;
		}//像‘\’的
		if(a[3]==a[5]&&a[5]==a[7]&&(a[3]==1||a[3]==0))
		{
			hhh=a[3];
			break;
		}//像‘/’的对角线，更暴力
		if(a[1]==a[4]&&a[7]==a[4]&&(a[1]==1||a[1]==0))
		{
			hhh=a[1];
			break;
		}//第一列
		if(a[2]==a[5]&&a[8]==a[5]&&(a[2]==1||a[2]==0))
		{
			hhh=a[2];
			break;
		}//第二列
		if(a[3]==a[6]&&a[6]==a[9]&&(a[3]==1||a[3]==0))
		{
			hhh=a[3];
			break;
		}//第三列。竖着的，超级暴力
		i++;
	}
	if(hhh==0)
		printf("xiaoa wins.\n")；//小a赢
	else if(hhh==1)
		printf("uim wins.\n")；//uim赢
	else if(hhh<0)
		printf("drew.\n")；//hhh的值没更新过
	return 0;
}//数组不开大，后悔一辈子！！！（我有防作弊印记哒，小心哈哈哈）
```

---

## 作者：十七 (赞：2)

蒟蒻觉得更暴力的方法

所有赢的情况都列出来

记得输出有个坑"xiaoa win." 一定记得还有个点

```cpp
#include<iostream>
using namespace std;
int main()
{
	int a[10]={0};
	string n;
	cin>>n;
	a[n[0]-'0']=1;//n[0]比较特殊  单列出来  第一个数是xiao a  so肯定是1 
	for(int i=1;i<=n.size();i++)
	{
		if(i%2==1)
		a[n[i+1]-'0']=1;//xio a 打1 
		else
		a[n[i+1]-'0']=2;//uim 打2 
	}
	
	 	 
	int p=0,q=0;
	//xiao a赢的情况 
	if(a[1]==a[2]&&a[2]==a[3]&&a[3]==1) p++;
	if(a[4]==a[5]&&a[5]==a[6]&&a[6]==1) p++;
	if(a[7]==a[8]&&a[8]==a[9]&&a[9]==1) p++;
	if(a[1]==a[4]&&a[4]==a[7]&&a[7]==1) p++;
	if(a[2]==a[5]&&a[5]==a[8]&&a[8]==1) p++;
	if(a[3]==a[6]&&a[6]==a[9]&&a[9]==1) p++;
	if(a[1]==a[5]&&a[5]==a[9]&&a[9]==1) p++;
	if(a[3]==a[5]&&a[5]==a[7]&&a[7]==1) p++;
	//uim赢的情况 
	if(a[1]==a[2]&&a[2]==a[3]&&a[3]==2) q++;
	if(a[4]==a[5]&&a[5]==a[6]&&a[6]==2) q++;
	if(a[7]==a[8]&&a[8]==a[9]&&a[9]==2) q++;
	if(a[1]==a[4]&&a[4]==a[7]&&a[7]==2) q++;
	if(a[2]==a[5]&&a[5]==a[8]&&a[8]==2) q++;
	if(a[3]==a[6]&&a[6]==a[9]&&a[9]==2) q++;
	if(a[1]==a[5]&&a[5]==a[9]&&a[9]==2) q++;
	if(a[3]==a[5]&&a[5]==a[7]&&a[7]==2) q++;
	
	
	if(p)
	cout<<"xiaoa wins."<<endl;
	if(q)
	cout<<"uim wins."<<endl;
	if(p==0&&q==0)
	cout<<"drew."<<endl;
	return 0;
 } 
```


---

## 作者：sss7020 (赞：2)

```cpp
//先奉上代码，再说废话。
#include<iostream>
#include<string>
using namespace std;
int qb[10]={6/*?*/,
6/*1*/,6/*2*/,6/*3*/,
6/*4*/,6/*5*/,6/*6*/,
6/*7*/,6/*8*/,6/*9*/}/*数组先初始化*/,t=-1;
//t是用来存是谁下的棋
//-1是小a（智商低），1是uim（你懂的）
string s;
int main(){
	cin>>s;
	for(int i=0;i<s.size();i++){
		qb[int(s[i])-48]=t;
        //把字符改成数字
        //1存入qb[1]，2存入qb[2]……
        //顺便说一下，多加一个变量是有用的
        //这样的话就不需要把1存入qb[0]中
        //其它数字也是如此
		t=-t;//下一步换一个人下棋
	}
	if(qb[1]==-1&&qb[2]==qb[1]&&qb[3]==qb[2])cout<<"xiaoa wins.\n";
	else if(qb[1]==1&&qb[2]==qb[1]&&qb[3]==qb[2])cout<<"uim wins.\n";
	else if(qb[4]==1&&qb[5]==qb[4]&&qb[6]==qb[4])cout<<"uim wins.\n";
	else if(qb[4]==-1&&qb[5]==qb[4]&&qb[6]==qb[4])cout<<"xiaoa wins.\n";
	else if(qb[7]==-1&&qb[7]==qb[8]&&qb[7]==qb[9])cout<<"xiaoa wins.\n";
	else if(qb[7]==1&&qb[7]==qb[8]&&qb[7]==qb[9])cout<<"uim wins.\n";
	else if(qb[1]==1&&qb[5]==qb[1]&&qb[9]==qb[1])cout<<"uim wins.\n";
	else if(qb[1]==-1&&qb[2]==qb[1]&&qb[3]==qb[2])cout<<"xiaoa wins.\n";
	else if(qb[3]==-1&&qb[5]==qb[3]&&qb[3]==qb[7])cout<<"xiaoa wins.\n";
	else if(qb[3]==-1&&qb[5]==qb[3]&&qb[3]==qb[7])cout<<"uim wins.\n";
	else if(qb[1]==-1&&qb[4]==qb[1]&&qb[7]==-1)cout<<"xiaoa wins.\n";
	else if(qb[1]==1&&qb[4]==qb[1]&&qb[7]==1)cout<<"uim wins.\n";
	else if(qb[2]==1&&qb[5]==qb[2]&&qb[8]==1)cout<<"uim wins.\n";
	else if(qb[2]==-1&&qb[5]==qb[2]&&qb[8]==-1)cout<<"xiaoa wins.\n";
	else if(qb[3]==-1&&qb[6]==qb[3]&&qb[9]==-1)cout<<"xiaoa wins.\n";
	else if(qb[3]==1&&qb[6]==qb[1]&&qb[9]==1)cout<<"uim wins.\n";
    //判断是竖着、横着还是写着，都不是就平局
	else cout<<"drew.\n";
	return 0;//圆润的滚蛋
}
```
这个方法一看就是一个新手写的（当然，我就是新手），但是还要说一下方法：

1、用一维数组存入数据

2、判断

3、圆润的离开

题外话分界线：


------------
三子棋最好这样下：

1、先占角

2、只要对方不占中心，占与第一次下的角相邻的那个地方（有两个，自己挑）

3、对方一定会挡住空的地方，接下来你有两种做法：

（1）再占一个角

（2）占中间

用哪个看情况，接下来……画个图你就懂了。

---

## 作者：ljc20020730 (赞：2)

纯暴力强势AC

当最终路线是横或纵向的话循环判断，一找到赢得马上跳出

当路线是斜着的写点的坐标即可

```cpp
var a:array[1..3,1..3]of longint;
    i,j,t:longint;
    s:string;
begin
 readln(s);
 for i:=1 to length(s) do begin
  t:=-1;
  if i mod 2=1 then t:=1;
  case s[i] of
  '1':a[1,1]:=t;
  '2':a[1,2]:=t;
  '3':a[1,3]:=t;
  '4':a[2,1]:=t;
  '5':a[2,2]:=t;
  '6':a[2,3]:=t;
  '7':a[3,1]:=t;
  '8':a[3,2]:=t;
  '9':a[3,3]:=t;
  end;
 end;
  for i:=1 to 3 do begin
   if (a[1,i]=1)and(a[2,i]=1)and(a[3,i]=1)
   then begin writeln('xiaoa wins.'); halt;end;
    if (a[1,i]=-1)and(a[2,i]=-1)and(a[3,i]=-1)
   then begin writeln('uim wins.'); halt;end;
  end;
   for j:=1 to 3 do begin
   if (a[j,1]=1)and(a[j,2]=1)and(a[j,3]=1)
   then begin writeln('xiaoa wins.'); halt;end;
   if (a[j,1]=-1)and(a[j,2]=-1)and(a[j,3]=-1)
   then begin writeln('uim wins.'); halt;end;
  end;
   if (a[1,1]=1)and(a[2,2]=1)and(a[3,3]=1)
   then begin writeln('xiaoa wins.'); halt;end;
   if (a[1,1]=-1)and(a[2,2]=-1)and(a[3,3]=-1)
   then begin writeln('uim wins.'); halt;end;
   if (a[1,3]=1)and(a[2,2]=1)and(a[3,1]=1)
   then begin writeln('xiaoa wins.'); halt;end;
   if (a[1,3]=-1)and(a[2,2]=-1)and(a[3,1]=-1)
   then begin writeln('uim wins.'); halt;end;
   writeln('drew.');
end.
```

---

## 作者：尼古拉斯·柠檬 (赞：2)

我很菜，菜到连“蒟蒻”这两个字都是复制粘贴的，因此我对二维数组头晕，于是我就用字符串模拟。思路是：因为总是小a先下，所以对于输入的那一行数据，偶数位上的就是小a下的棋，那么奇数位上的数小b下的棋，利用测试数据解释说明：输入数据是5237649，那么小a下的棋在5369上，那么小b下的棋就在274上，于是我定义两个字符串string  a="5369";string b="274";

简易画个3*3的棋盘，标上1~9，可以发现，只有7种情况下，会产生赢局，那就是：一、横向的（123，456，789）；二、竖向的（147，258，369）；三、对角线上的（159，357）。那么我就对字符串a进行判断（用369举例）：

在字符串a中先判断字符串“3”在不在字符串a里，若在继续判断字符串“6”在不在a里，若在继续判断字符串“9”在不在a里，若都在，则赢了，同理可判定b……

我用的是java中的String类，同理也可以用c++中的string类

```
public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String s = br.readLine().trim();
		StringBuffer sbA = new StringBuffer();
		StringBuffer sbB = new StringBuffer();
		for (int i = 0; i < s.length(); i++) {
			if (i % 2 == 0)
				sbA.append(s.charAt(i));
			else
				sbB.append(s.charAt(i));
		}
		String xiaoA = sbA.toString();
		String xiaoB = sbB.toString();
		if (onCheck(xiaoA))
			System.out.println("xiaoa wins.");
		else if (onCheck(xiaoB))
			System.out.println("uim wins.");
		else
			System.out.println("drew.");
	}

	public static boolean onCheck(String s) {
		// 1 x x
		if ((s.indexOf(String.valueOf(1)) != -1)) {
			// 1 2 3
			if ((s.indexOf(String.valueOf(2)) != -1)) {
				if ((s.indexOf(String.valueOf(3)) != -1)) {
					return true;
				}
			}

			// 1 4 7
			if ((s.indexOf(String.valueOf(4)) != -1)) {
				if ((s.indexOf(String.valueOf(7)) != -1)) {
					return true;
				}
			}

			// 1 5 9
			if ((s.indexOf(String.valueOf(5)) != -1)) {
				if ((s.indexOf(String.valueOf(9)) != -1)) {
					return true;
				}
			}
		}

		// 2 5 8
		if ((s.indexOf(String.valueOf(2)) != -1)) {
			if ((s.indexOf(String.valueOf(5)) != -1)) {
				if ((s.indexOf(String.valueOf(8)) != -1)) {
					return true;
				}
			}
		}

		// 3 x x
		if ((s.indexOf(String.valueOf(3)) != -1)) {
			// 3 5 7
			if ((s.indexOf(String.valueOf(5)) != -1)) {
				if ((s.indexOf(String.valueOf(7)) != -1)) {
					return true;
				}
			}

			// 3 6 9
			if ((s.indexOf(String.valueOf(6)) != -1)) {
				if ((s.indexOf(String.valueOf(9)) != -1)) {
					return true;
				}
			}
		}

		// 4 5 6
		if ((s.indexOf(String.valueOf(4)) != -1)) {
			if ((s.indexOf(String.valueOf(5)) != -1)) {
				if ((s.indexOf(String.valueOf(6)) != -1)) {
					return true;
				}
			}
		}

		// 7 8 9
		if ((s.indexOf(String.valueOf(7)) != -1)) {
			if ((s.indexOf(String.valueOf(8)) != -1)) {
				if ((s.indexOf(String.valueOf(9)) != -1)) {
					return true;
				}
			}
		}

		return false;
	}
```

---

## 作者：އ_昔年™_ (赞：2)

### P党程序真的少得可怜


  首先，这道题可以分为两种情况，游戏结束时，棋盘已经下满或没下满。如果是没下满的，游戏结束时肯定是有一方赢了，也就是最后下的那一方，所以，我们可以判断下的步数的奇偶性，因为是小a先下，所以当步数为奇数时，为小a赢，反之，则uim赢。如果下满了，则有3种情况，小a赢，uim赢，平局，下面在程序中解释。
  

------------
```pascal
var
  i,j,p,m:longint;
  s:string;
  a,b:array[0..5,1..3] of longint;
  x:array[1..3] of boolean;
begin
  readln(s);
  if length(s)<9//如果没下满
    then if odd(length(s)) then begin write('xiaoa wins.'); exit; end//如果步数为奇数，由于小a先下，所以小a赢
                   else begin write('uim wins.'); exit; end//反之
    else//已下满
      begin
        for i:= 1 to 5 do//小a下了5步
          begin
            val(s[i*2-1],a[i,1],p);
            a[i,2]:=a[i,1] mod 3;
            if a[i,2]=0 then  begin a[i,2]:=3; a[i,3]:=a[i,1] div 3; end
                        else a[i,3]:=a[i,1] div 3+1;
          end;//a[i,1]为格子的编号，a[i,2]为所在的列数，a[i,3]为行数，b数组相同
        for i:= 1 to 4 do//uim下了4步
          begin
            val(s[i*2],b[i,1],p);
            b[i,2]:=b[i,1] mod 3;
            if b[i,2]=0 then  begin b[i,2]:=3; b[i,3]:=b[i,1] div 3; end
                        else b[i,3]:=b[i,1] div 3+1;
          end;
        for j:= 1 to 3 do//在同一行
          begin
            fillchar(x,sizeof(x),false);
            m:=0;
            for i:= 1 to 5 do//小a
              if (not x[a[i,2]])and(a[i,3]=j) then
                begin
                  x[a[i,2]]:=true;
                  inc(m);
                end;
              if m=3 then
                       begin
                         write('xiaoa wins.');
                         exit;
                       end;//如果有三格在同一行，则小a赢
            fillchar(x,sizeof(x),false);
            m:=0;
            for i:= 1 to 4 do//uim
              if (not x[b[i,2]])and(b[i,3]=j) then
                begin
                  x[b[i,2]]:=true;
                  inc(m);
                end;
              if m=3 then
                       begin
                         write('uim wins.');
                         exit;
                       end;//uim赢
          end;
        for j:= 1 to 3 do//在同一列
          begin
            fillchar(x,sizeof(x),false);
            m:=0;
            for i:= 1 to 5 do
              if (not x[a[i,3]])and(a[i,2]=j) then
                begin
                  x[a[i,3]]:=true;
                  inc(m);
                end;
              if m=3 then
                       begin
                         write('xiaoa wins.');
                         exit;
                       end;
            fillchar(x,sizeof(x),false);
            m:=0;
            for i:= 1 to 4 do
              if (not x[b[i,3]])and(b[i,2]=j) then
                begin
                  x[b[i,3]]:=true;
                  inc(m);
                end;
              if m=3 then
                       begin
                         write('uim wins.');
                         exit;
                       end;
          end;


        fillchar(x,sizeof(x),false); m:=0;
        for i:= 1 to 5 do
          if (a[i,2]=a[i,3])and(not x[a[i,2]]) then
            begin
              x[a[i,2]]:=true;
              inc(m);
            end;
        if m=3 then begin write('xiaoa wins.'); exit; end;//小a
        fillchar(x,sizeof(x),false); m:=0;
        for i:= 1 to 4 do
          if (b[i,2]=b[i,3]//所在行数列数相等，则在从左上到右下的对角线↘上)and(not x[b[i,2]]) then
            begin
              x[b[i,2]]:=true;
              inc(m);
            end;
        if m=3 then begin write('uim wins.'); exit; end;//uim
//从左上到右下的对角线↘

        fillchar(x,sizeof(x),false); m:=0;
        for i:= 1 to 5 do
          if (a[i,2]+a[i,3]=4)and(not x[a[i,2]]) then
            begin
              x[a[i,2]]:=true;
              inc(m);
            end;
        if m=3 then begin write('xiaoa wins.'); exit; end;
        fillchar(x,sizeof(x),false); m:=0;
        for i:= 1 to 4 do
          if (b[i,2]+b[i,3]=4//如果行数列数和为4，则在从右上到左下的对角线↙上)and(not x[b[i,2]]) then
            begin
              x[b[i,2]]:=true;
              inc(m);
            end;
        if m=3 then begin write('uim wins.'); exit; end;//从右上到左下的对角线↙
      end;
    write('drew.');//如果上面没有输出，就是平局
end.
```

本蒟蒻第一篇题解，代码丑，望通过


---

## 作者：JimmyF (赞：1)


当当当，看我潇洒的打表代码吧！

### 代码：

    #include<bits/stdc++.h> //万能文件头
    using namespace std;
    string st;    //定义字符串读入
    int t,x,y;    //这是用来转化行列的变量
    int a[5][5];  //棋盘
    int pd()      //最强打表判断函数
    {
        //注意：1表示此位置的棋子是小a的，2表示此位置的棋子是uim的
        if(a[1][1]==1&&a[1][2]==1&&a[1][3]==1)  //判断第一行小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][1]==2&&a[1][2]==2&&a[1][3]==2)  //判断第一行uim是否胜
        	return 2;                           //是则返回2，代表小uim胜
        if(a[2][1]==1&&a[2][2]==1&&a[2][3]==1)  //判断第二行小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[2][1]==2&&a[2][2]==2&&a[2][3]==2)  //判断第二行uim是否胜
        	return 2;                           //是则返回2，代表小uim胜
        if(a[3][1]==1&&a[3][2]==1&&a[3][3]==1)  //判断第三行小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[3][1]==2&&a[3][2]==2&&a[3][3]==2)  //判断第三行uim是否胜
        	return 2;                           //是则返回2，代表小uim胜
        //判断行 
        if(a[1][1]==1&&a[2][1]==1&&a[3][1]==1)  //判断第一列小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][1]==2&&a[2][1]==2&&a[3][1]==2)  //判断第一列uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        if(a[1][2]==1&&a[2][2]==1&&a[3][2]==1)  //判断第二列小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][2]==2&&a[2][2]==2&&a[3][2]==2)  //判断第二列uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        if(a[1][3]==1&&a[2][3]==1&&a[3][3]==1)  //判断第三列小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][3]==2&&a[2][3]==2&&a[3][3]==2)  //判断第三列uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        //判断列
        if(a[1][1]==1&&a[2][2]==1&&a[3][3]==1)  //判断从左上到右下小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][1]==2&&a[2][2]==2&&a[3][3]==2)  //判断从左上到右下uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        if(a[1][3]==1&&a[2][2]==1&&a[3][1]==1)  //判断从右上到左下小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][3]==2&&a[2][2]==2&&a[3][1]==2)  //判断从右上到左下uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        //判断斜
        return 0;                               //没有则返回0，注意！！！不然会返回一个随机值，有可能是0或1，所以会WA
    }
    //打表判断函数
    int main()
    {
        cin>>st;  //输入字符串
        for(int i=0; i<st.size(); i++) //从0开始，扫描每一个放棋编号
        {
            t=int(st[i])-'0';     //转化为整型数，‘0’~'9'的ascll码为48~57，减去‘0’的ascll码48就得到了这个数字对应的整形数啦，更多ascll码值请看pascle
            x=t/3+(t%3!=0);       //这一句相当于x=t/3; if(t%3!=0)x++; 这里计算行，因为一行3个棋子，所以/3，然后还有多余的棋子也要占一行，所以+(t%3!=0)
            y=t%3;if(y==0)y=3;    //计算列，因为一行3个棋子，所以%3，但有刚好是3的倍数的编号，这时%3的值应为3而不为0，所以if(y==0)y=3;
            if(i%2==0)a[x][y]=1;  //判断如果这是i为偶数，代表这时轮到小a下，所以a[x][y]=1;代表第x行，第y列的棋是小a的
            else a[x][y]=2;       //否则代表这时轮到uim下，所以a[x][y]=2;代表第x行，第y列的棋是uim的
            if(pd()==1){cout<<"xiaoa wins.";return 0;}    //调用函数，判断小a胜，胜则输出xiaoa wins.然后终结程序
            if(pd()==2){cout<<"uim wins.";return 0;}      //调用函数，判断uim胜，胜则输出uim wins.然后终结程序
        }
        cout<<"drew.";  //如果程序能运行到现在，证明没有一个人胜，代表平局，输出drew.
        return 0;
    }


---

## 作者：JiaRans_Dog (赞：1)

好了，本蒟蒻今天就给大家献献丑了

刚开始打这道题的时候我都快吐了，~~这不是黑题？？~~

整理一下思路

**1.做棋盘**

**要模拟出一个3×3的棋盘状态。在这里我把所有的位置放满了-1。**

**2.放棋子**

**小a棋子表示为1，umi棋子表示为0，放在棋盘上。**

**3.**

**再按行，列，斜角线一一判断，如果连成一线了，就看看这这个线的值，如果是1，那就是小a赢了。如果是0,那就是umi赢了。**

这就是我这个代码的思想，下面是code



------------
```
#include<iostream>
#include<cstring>
using namespace std;
long long a[100];
bool flag=1;//管理棋子状态 
long long pan[3][3];//模拟棋盘 
int main(){
	memset(pan,-1,sizeof(pan));//数组初始化 
	string al;
	cin>>al;//输入 
	long long lena=al.size();
	for(long long i=0;i<lena;i++){
		a[i]=al[i]-48;//字符串转入数组内 
	}
	for(long long i=0;i<lena;i++){
		pan[(a[i]/3)][a[i]%3-1]=flag;//这几个公式自己画图想想 
		flag=!flag;//转变棋子状态 
	}
	for(long long i=0;i<3;i++){//偷懒的循环（非常有效）
	//不等于-1是为了防止空棋子连成一行 
			if(pan[i][0]==pan[i][1]&&pan[i][1]==pan[i][2]&&pan[i][0]!=-1){//横向 
				if(pan[i][0]==1){
					cout<<"xiaoa wins.";
					return 0;
				}else{
					cout<<"uim wins.";
					return 0;
				}
			}
			if(pan[0][i]==pan[1][i]&&pan[1][i]==pan[2][i]&&pan[0][i]!=-1){//纵向 
				if(pan[0][i]==1){
					cout<<"xiaoa wins.";
					return 0;
				}else{
					cout<<"uim wins.";
					return 0;
				}
			}
			if(pan[0][0]==pan[1][1]&&pan[1][1]==pan[2][2]&&pan[0][0]!=-1){//左上到右下 
				if(pan[0][0]==1){
					cout<<"xiaoa wins.";
					return 0;
				}else{
					cout<<"uim wins.";
					return 0;
				}
			}
			if(pan[0][2]==pan[1][1]&&pan[1][1]==pan[2][0]&&pan[0][2]!=-1){//右上到左下 
				if(pan[0][2]==1){
					cout<<"xiaoa wins.";
					return 0;
				}else{
					cout<<"uim wins.";
					return 0;
				}
			}
		}
	cout<<"drew.";//如果都不是那就是平局 
	return 0;//完美的结束 
}
```
不要照抄，理解理解再写

---

## 作者：buickboy (赞：1)

## ~~争做最好懂最简洁的题解！共29行~~

总体思路跟大家差不多，但大的优化有三处：
- 把反复使用的判断谁是胜利者、打印胜利者的过程设计为打印函数，方便多次调用。

- **用黑科技exit(0)，让打印函数只调用一次后就结束程序。** 省去多个if...else或者return 0。
- 只用一维数组，因为各下标的位置在方阵中都已确定；再把按行、按列进行的比对做成循环，用下标控制。



```cpp
#include <bits/stdc++.h>
using namespace std;
int a[12], i;
void prt(int k)
{
	if(a[k]==1)	cout<<"xiaoa wins."<<endl;
	else cout<<"uim wins."<<endl;
	exit(0);
}
int main()
{
	string s;
	cin>>s;
	for(i=0; s[i]; ++i) //模拟下棋
		if(i%2==0) a[s[i]-'0']=1;   //小a占领格子
		else a[s[i]-'0']=-1;  //uim占领格子
	for(i=1; i<=7; i+=3) //147开头,按行
		if(a[i]==a[i+1]&&a[i]==a[i+2])
			prt(i);
	for(i=1; i<=3; ++i) //123开头，按列
		if(a[i]==a[i+3]&&a[i]==a[i+6])
			prt(i);
	if(a[1]==a[5]&&a[5]==a[9]) //159对角线
		prt(1);
	if(a[3]==a[5]&&a[5]==a[7]) //357对角线
		prt(3);
	cout<<"drew."<<endl;
	return 0;
}

```


---

## 作者：dyzxjzx (赞：1)




为了缩短长度，可以用布尔a[ ][ ],b[ ][ ]数组来分别记录小a和对手走的步数,最后枚举




```c
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
bool a[5][5]={false},b[5][5]={false};
int main()
{
    string s;
    cin>>s;
    for(int i=0;i<s.size();i++)
    {
        int x=s[i]-'0';
        int k=x,l=0;
        while(k>3)k-=3,l++;
        if(i%2==0)
            a[l+1][k]=true;
        else b[l+1][k]=true;
    }
    if(a[1][1]&&a[1][2]&&a[1][3]){cout<<"xiaoa wins.\n";return 0;}
    if(a[1][1]&&a[2][1]&&a[3][1]){cout<<"xiaoa wins.\n";return 0;}
    if(a[1][1]&&a[2][2]&&a[3][3]){cout<<"xiaoa wins.\n";return 0;}
    if(a[1][2]&&a[2][2]&&a[3][2]){cout<<"xiaoa wins.\n";return 0;}
    if(a[1][3]&&a[2][3]&&a[3][3]){cout<<"xiaoa wins.\n";return 0;}
    if(a[1][3]&&a[2][2]&&a[1][1]){cout<<"xiaoa wins.\n";return 0;}
    
    if(b[1][1]&&b[1][2]&&b[1][3]){cout<<"uim wins.\n";return 0;}
    if(b[1][1]&&b[2][1]&&b[3][1]){cout<<"uim wins.\n";return 0;}
    if(b[1][1]&&b[2][2]&&b[3][3]){cout<<"uim wins.\n";return 0;}
    if(b[1][2]&&b[2][2]&&b[3][2]){cout<<"uim wins.\n";return 0;}
    if(b[1][3]&&b[2][3]&&b[3][3]){cout<<"uim wins.\n";return 0;}
    if(b[1][3]&&b[2][2]&&b[1][1]){cout<<"uim wins.\n";return 0;} 
    
    cout<<"drew.\n";
    return 0;
    
}
```

---

## 作者：functionendless (赞：1)

首先如果长度没到9的，如果个数是单数就是xiaoa胜，否则uim胜，长度都是9时，一个个判胜的情况。。。



            
```cpp
/*#include<cstdio>
#include<cstring>
using namespace std;
int a[10],map[3][3];
char tmp;
bool flag;
int main()
{
    int i,j,n;
    i=0;
    while(scanf("%c",&tmp)!=EOF)
    {
        i++;
        int x=(tmp-'1')/3,y=(tmp-'1')%3;
        if(y<0) y=2;
        if(i%2==1) map[x][y]=1;
        else map[x][y]=2;
        flag=1;
        for(j=0;j<2;j++)
            if(map[x][j]!=map[x][y]||map[j][y]!=map[x][y]) {flag=0;break;}
        if(flag==1)
        {
            if(i%2==1) printf("xiaoa wins.");
            else printf("uim wins.");
            return 0;
        }
        if(x==1&&y==1)
        {
            flag=1;
            for(j=0;j<2;j++)
                if(map[j][j]!=map[x][y]||map[2-j][j]!=map[x][y])
                {
                    flag=0;
                    break;
                }
            if(flag==1)
            {
                if(i%2==1) printf("xiaoa wins.");
                else printf("uim wins.");
                return 0;
            }
        }
    }
    printf("drew.");
    return 0;
}*/
#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
using namespace std;
string s;
bool flag;
int map[3][3];
int main()
{
    int i,j,ls;
    cin>>s;
    ls=s.size();
    if(ls<9)
    {
        if(ls%2==1) {printf("xiaoa wins."); return 0;}
        else {printf("uim wins."); return 0;}
    }
    else
    {
        for(i=0;i<9;i++)
        {
            int x=(s[i]-'1')/3,y=(s[i]-'1')%3;
            if(y<0) y=2;
            if(i%2==0) map[x][y]=1;
            else map[x][y]=2;
        }
        /*for(i=0;i<3;i++)
        {
            for(j=0;j<3;j++)
                printf("%d",map[i][j]);
            printf("\n");
        } */
        flag=1;
        for(i=0;i<3;i++)
            if(map[i][0]!=map[0][0])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[i][1]!=map[0][1])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[i][2]!=map[0][2])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[0][i]!=map[0][0])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[1][i]!=map[1][0])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[2][i]!=map[2][0])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[i][i]!=map[0][0])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
        flag=1;
        for(i=0;i<3;i++)
            if(map[2-i][i]!=map[2][0])
                {flag=0; break;}
        if(flag==1) {printf("xiaoa wins."); return 0;}
    }
    printf("drew.");
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

我是一个小小小蒟蒻。~~有没有一种快要唱起来的感觉~~

本人看到有许多大佬都喜欢用暴力，那么作为一个蒟蒻应该要学习大佬啦!

话已至此，大家一定可以猜出这篇题解一定是暴力出奇迹的
```
#include<cstdio>
#include<cstring>//懒得打普通读录输出的表头了("·o·")
using namespace std;
char n[10000];
int a[10000],b[10000];
int main(){
    scanf("%s",n);//char型的读录，这里不需要加取地址符
    int l=strlen(n);//char型的取长度
    for(int i=0;i<l;i++)
    {
        if(i%2==0)
        {
            a[n[i]-48]=1;
        }
		else
        {
            b[n[i]-48]=1;
		}

    }//结束两个数组的赋值，出现过的标记为1
    if((a[1]==a[2]&&a[2]==a[3]&&a[1]==1)||(a[4]==a[5]&&a[5]==a[6]&&a[4]==1)||(a[2]==a[5]&&a[5]==a[8]&&a[2]==1)||(a[1]==a[4]&&a[4]==a[7]&&a[1]==1)||(a[7]==a[8]&&a[8]==a[9]&&a[7]==1)||(a[3]==a[5]&&a[5]==a[7]&&a[7]==1)||(a[1]==a[5]&&a[5]==a[9]&&a[1]==1)||(a[3]==a[6]&&a[6]==a[9]&&a[3]==1)) 
    {
        printf("xiaoa wins.");
    }//判断小a有没有赢
	else 
if((b[1]==b[2]&&b[2]==b[3]&&b[1]==1)||(b[1]==b[4]&&b[4]==b[7]&&b[1]==1)||(b[7]==b[8]&&b[8]==b[9]&&b[7]==1)||(b[4]==b[5]&&b[5]==b[6]&&b[4]==1)||(b[2]==b[5]&&b[5]==b[8]&&b[2]==1)||(b[3]==b[6]&&b[6]==b[9]&&b[3]==1)||(b[1]==b[5]&&b[5]==b[9]&&b[1]==1)||(b[3]==b[5]&&b[5]==b[7]&&b[7]==1)) 
    {
        printf("uim wins.");
    }//判断uim有没有赢
	
	else
    {
        printf("drew.");
    }//如果都不是就平局
    return 0; 
}
```

---

## 作者：optimize_3 (赞：0)

# 真の打表

思路:定义两个bool:
```
bool a[987654322];  //小A
bool u[987654322];  //uim
```
a[i]代表输入为i时小A胜,u[i]代表输入为i时uim胜,!(a[i]+u[i])代表输入为i时平局.

这道题表生成器有俩:
```
/*输入数据生成*/
#include<bits/stdc++.h>
using namespace std;
int main()
{
	for(int i=1234567;i<=987654321;i++)
	{
		printf("%d",i);
		printf("%s"," ");
	}
	return 0;
}

```
在本地跑几十分钟后得到.

### 然后,不要直接拿来打表!!!

正确食用方式应该是把它CXK+c(唱跳rap篮球=Ctrl)到表生成器2里.

为什么呢?~~因为我懒~~

表生成器2是我把题解里一位julao的代码改了一下得到了(Thanks.).

```
//表生成器2-1
#include<cstdio>
using namespace std;
int main()
{
	while(1){
	int a[4][4];
	char b[11];
    int i=0;
    do//因为不知道要读几位
    {
        i++;
        scanf("%c",&b[i]);
    }while(b[i]!='\n');
    for(int j=1;j<=i;j++)
        b[j]=b[j]-'0';
    for(int j=1;j<=i;j++)
    {
        if(j%2==1)//如果目前是xiaoa下的
        {
            if(b[j]==1)//判断是哪个格子
                a[1][1]=1;
            if(b[j]==2)
                a[1][2]=1;
            if(b[j]==3)
                a[1][3]=1;
            if(b[j]==4)
                a[2][1]=1;
            if(b[j]==5)
                a[2][2]=1;
            if(b[j]==6)
                a[2][3]=1;
            if(b[j]==7)
                a[3][1]=1;
            if(b[j]==8)
                a[3][2]=1;
            if(b[j]==9)
                a[3][3]=1;
        }
        else//是uim下的
        {
            if(b[j]==1)
                a[1][1]=2;
            if(b[j]==2)
                a[1][2]=2;
            if(b[j]==3)
                a[1][3]=2;
            if(b[j]==4)
                a[2][1]=2;
            if(b[j]==5)
                a[2][2]=2;
            if(b[j]==6)
                a[2][3]=2;
            if(b[j]==7)
                a[3][1]=2;
            if(b[j]==8)
                a[3][2]=2;
            if(b[j]==9)
                a[3][3]=2;  
        }   
    }
    if(a[1][1]==1&&a[2][2]==1&&a[3][3]==1)//判断xiaoa赢
    {

        printf("0,");//输出
        continue;
    }
    if(a[1][1]==1&&a[2][1]==1&&a[3][1]==1)
        {
        printf("0,");
        continue;
    }
    if(a[2][1]==1&&a[2][2]==1&&a[2][3]==1)
    {
        printf("0,");
        continue;
    }
    if(a[1][2]==1&&a[2][2]==1&&a[3][2]==1)
    {
        printf("0,");
        continue;
    }
    if(a[1][3]==1&&a[2][2]==1&&a[3][1]==1)
    {
        printf("0,");
        continue;
    }
    if(a[1][3]==1&&a[2][3]==1&&a[3][3]==1)
    {
        printf("0,");
        continue;
    }
    if(a[3][1]==1&&a[3][2]==1&&a[3][3]==1)//判断是uim赢
    {
        printf("1,");
        continue;
    }
    if(a[1][1]==2&&a[1][2]==2&&a[1][3]==2)
    {
        printf("1,");
        continue;
    }
    if(a[1][1]==2&&a[2][2]==2&&a[3][3]==2)
    {

        printf("1,");
        continue;
    }
    if(a[1][1]==2&&a[2][1]==2&&a[3][1]==2)
        {
        printf("1,");
        continue;
    }
    if(a[2][1]==2&&a[2][2]==2&&a[2][3]==2)
    {
        printf("1,");
        continue;
    }
    if(a[1][2]==2&&a[2][2]==2&&a[3][2]==2)
    {
        printf("1,");
        continue;
    }
    if(a[1][3]==2&&a[2][2]==2&&a[3][1]==2)
    {
        printf("1,");
        continue;
    }
    if(a[1][3]==2&&a[2][3]==2&&a[3][3]==2)
    {
        printf("1,");
        continue;
    }
    if(a[1][1]==2&&a[1][2]==2&&a[1][3]==2)
    {
        printf("1,");
        continue;
    }
    if(a[3][1]==2&&a[3][2]==2&&a[3][3]==2)
    {
        printf("1,");
        continue;
    }
    printf("0,");//都不是说明是平局
	}
}
```
最后要把末尾多出来的','删掉.

你们也许注意到了开头注释://表生成器2-1.~~(群众:没注意)~~

是的,这只是用来生成a数组的,还要一个表生成器2-2来生成u数组:
```
//表生成器2-2
#include<cstdio>
using namespace std;
int main()
{
	while(1){
	int a[4][4];
	char b[11];
    int i=0;
    do//因为不知道要读几位
    {
        i++;
        scanf("%c",&b[i]);
    }while(b[i]!='\n');
    for(int j=1;j<=i;j++)
        b[j]=b[j]-'0';
    for(int j=1;j<=i;j++)
    {
        if(j%2==1)//如果目前是xiaoa下的
        {
            if(b[j]==1)//判断是哪个格子
                a[1][1]=1;
            if(b[j]==2)
                a[1][2]=1;
            if(b[j]==3)
                a[1][3]=1;
            if(b[j]==4)
                a[2][1]=1;
            if(b[j]==5)
                a[2][2]=1;
            if(b[j]==6)
                a[2][3]=1;
            if(b[j]==7)
                a[3][1]=1;
            if(b[j]==8)
                a[3][2]=1;
            if(b[j]==9)
                a[3][3]=1;
        }
        else//是uim下的
        {
            if(b[j]==1)
                a[1][1]=2;
            if(b[j]==2)
                a[1][2]=2;
            if(b[j]==3)
                a[1][3]=2;
            if(b[j]==4)
                a[2][1]=2;
            if(b[j]==5)
                a[2][2]=2;
            if(b[j]==6)
                a[2][3]=2;
            if(b[j]==7)
                a[3][1]=2;
            if(b[j]==8)
                a[3][2]=2;
            if(b[j]==9)
                a[3][3]=2;  
        }   
    }
    if(a[1][1]==1&&a[2][2]==1&&a[3][3]==1)//判断xiaoa赢
    {

        printf("1,");//输出
        continue;
    }
    if(a[1][1]==1&&a[2][1]==1&&a[3][1]==1)
        {
        printf("1,");
        continue;
    }
    if(a[2][1]==1&&a[2][2]==1&&a[2][3]==1)
    {
        printf("1,");
        continue;
    }
    if(a[1][2]==1&&a[2][2]==1&&a[3][2]==1)
    {
        printf("1,");
        continue;
    }
    if(a[1][3]==1&&a[2][2]==1&&a[3][1]==1)
    {
        printf("1,");
        continue;
    }
    if(a[1][3]==1&&a[2][3]==1&&a[3][3]==1)
    {
        printf("1,");
        continue;
    }
    if(a[3][1]==1&&a[3][2]==1&&a[3][3]==1)//判断是uim赢
    {
        printf("0,");
        continue;
    }
    if(a[1][1]==2&&a[1][2]==2&&a[1][3]==2)
    {
        printf("0,");
        continue;
    }
    if(a[1][1]==2&&a[2][2]==2&&a[3][3]==2)
    {

        printf("0,");
        continue;
    }
    if(a[1][1]==2&&a[2][1]==2&&a[3][1]==2)
        {
        printf("0,");
        continue;
    }
    if(a[2][1]==2&&a[2][2]==2&&a[2][3]==2)
    {
        printf("0,");
        continue;
    }
    if(a[1][2]==2&&a[2][2]==2&&a[3][2]==2)
    {
        printf("0,");
        continue;
    }
    if(a[1][3]==2&&a[2][2]==2&&a[3][1]==2)
    {
        printf("0,");
        continue;
    }
    if(a[1][3]==2&&a[2][3]==2&&a[3][3]==2)
    {
        printf("0,");
        continue;
    }
    if(a[1][1]==2&&a[1][2]==2&&a[1][3]==2)
    {
        printf("0,");
        continue;
    }
    if(a[3][1]==2&&a[3][2]==2&&a[3][3]==2)
    {
        printf("0,");
        continue;
    }
    printf("0,");//都不是说明是平局
	}    
}
```
然后,我们的表就得出来了:

```
bool a[987654322]={(想看?自己运行)};  //小A
bool u[987654322]={(想看?自己运行)};  //uim
```
(为大家阅读方便,这里不展示表)
```
#include<bits/stdc++.h>
using namespace std;
bool a[987654322]={(想看?自己运行)};  //小A
bool u[987654322]={(想看?自己运行)};  //uim
int main()
{
	long long k;
	cin>>k;
	if(/* I */a[k]/* IOI */)//我是永远AK不了IOI的,所以这个表达式的值是false.(开个玩笑)
		cout<<"xiaoa wins.";
	if(u[k])
		cout<<"uim wins.";
	if(!(a[k]+u[k]))
		cout<<"drew.";
}
```
# 成功~~OOXX~~Accepted  

---

## 作者：right_cat (赞：0)

本题是简单的模拟，还是讲一下我的思路吧。

**解题思路：**

这道题我写了两个check函数。

第一个check函数，判断横竖列是否有人胜出，在这个check函数中我传了一个参数x，表示第x排/列的胜负情况，所以最后只要将i从1到3循环，每次都传入i来check一下，最后就能知晓整个棋局横竖的胜负情况了。

第二个check函数，判断对角线是否有人胜出，这个更简单了，直接手判即可。

我还用了一个数组a表示棋盘，即输入的1表示有人在a[1][1]下棋，2表示在a[1][2]下棋，...，9表示在a[3][3]下棋，通过找规律可以快速实现，当然也可以暴力判断，具体方法可见代码。

另外，如果是小a下棋，我就在他下棋的位置赋值1，uim则赋值2。举个例子，对于输入样例1:
```
5237649
```
经过我的处理，输出a数组的存储情况，应是：

```
0 2 1
2 1 1
2 0 1
```
最后根据check的返回值即可判断胜负：如果返回1说明小a胜，返回2说明uim胜，返回-1（既不返回1又不返回2）说明平局。

**代码实现：**
```cpp
#include <cstdio>
#include <cstring>

const int MAX = 3;

int a[MAX + 5][MAX + 5]; //模拟棋盘的数组 

inline int check1(int x) {
    if(a[x][1] == a[x][2] && a[x][2] == a[x][3]) return a[x][1]; //判断横列谁胜出 
    if(a[1][x] == a[2][x] && a[2][x] == a[3][x]) return a[1][x]; //判断竖列谁胜出 
    return -1; //否则返回-1 
}

inline int check2() {
    if(a[1][1] == a[2][2] && a[2][2] == a[3][3]) return a[1][1]; //判断左上到右下谁胜出 
    if(a[1][3] == a[2][2] && a[2][2] == a[3][1]) return a[1][3]; //判断右上到左下谁胜出 
    return -1; //否则返回-1 
}

int main() {
    char ch[MAX * MAX + 5];
    int tot = 0;
    scanf("%s", ch);
    int len = strlen(ch);
    for(int i = 0; i < len; i++) {
        int x = ch[i] - '0';
        a[x / 3 + (x % 3 ? 1 : 0)][x % 3 ? x % 3 : 3] = (++tot & 1) ? 1 : 2;
		//找规律模拟两人下棋，1表示小a,2表示uim 
    }
    bool xiaoa = false, uim = false;
    for(int i = 1; i <= MAX; i++) {
        if(check1(i) == 1) xiaoa = true; //表示小a胜出 
        if(check1(i) == 2) uim = true; //表示uim胜出 
    }
    if(check2() == 1) xiaoa = true; //表示小a胜出
    if(check2() == 2) uim = true; //表示uim胜出
    if(xiaoa && !uim) puts("xiaoa wins."); //如果小a最终胜出 
    else if(uim && !xiaoa) puts("uim wins."); //如果uim最终胜出
    else puts("drew."); //都未胜出则为平局 
}
```


---

## 作者：DARKSTALKING (赞：0)

开始我随随便便写了一下，然后发现好像理解错题目了QAQ……

这道题的思路就是：读进数据存进二维数组里，然后判断每一竖行、每一横行、两个斜行有没有三个都相同的（由于题目保证肯定只有一人赢，或没人赢），所以思路可行。

然后就很简单了鸭，我看了下楼下好像都是打表或一个个去判断，那为啥不用用for呢？

附AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[3][3],now,ans;//FA♂数组
char ch1;
int main()
{
	now=0;//没啥卵用的初始化，不想删 
	scanf(" %c",&ch1);//数组读入，虽说比较笨 
	while(ch1!='\n')
	{
		int kk=now%2;//仿佛是用来开玩笑的 
		fa[(ch1-49)/3][(ch1-49)%3]=kk+1;//用公式存入 		//（1就是小a，2就是uim，0就是空） 
		now+=1;
		scanf("%c",&ch1);//这里注意%c之前不能打空格 
	}
	for(int i=0;i<3;i+=1)
	{
		if(fa[i][0]==fa[i][1]&&fa[i][1]==fa[i][2])
			ans=fa[i][0]; 
        if(fa[0][i]==fa[1][i]&&fa[1][i]==fa[2][i]) 
				ans=fa[0][i];	
	}
	if(fa[0][0]==fa[1][1]&&fa[1][1]==num[2][2])
		ans=num[0][0];
	if(fa[0][2]==fa[1][1]&&fa[1][1]==fa[2][0])//对角
		ans=num[0][2];
	if(ans==1)
		cout<<"xiaoa wins."<<endl;//输出 
	if(ans==2)
		cout<<"uim wins."<<endl;//输出 
	if(ans==0)
		cout<<"drew."<<endl;//再输出 
	return 0;
}

```
see you 啦啦

---

## 作者：sxjzycwcy (赞：0)

# A New Solution(新方法！！！)
前几次的题解因为重复没通过了，这次我猜应该能通过了吧

首先读题，通过题目可知：

#### 这是已经结束的棋局！
### 这是已经结束的棋局！！
## 这是已经结束的棋局！！！
那么，可以通过判断奇偶性来解题

奇数，则是小a赢，偶数，则是uim赢

但是

在=9时，可能是小a赢也有可能是平局，需要特殊判断；

还有，用3目运算符比较简单，

比如
```cpp
a>b?a:b
```
等价于
```cpp
if(a>b)
	return a;
else 
	return b;
```
所以说是个省空间的好方法啦

## 重点：横纵判断↓（Look Here）
```cpp
if(b[i%3==0?i-2:i+1]%2==1&&b[i%3==1?i+2:i-1]%2==1)
```
### ↑这是横向的↑
### ↓这是纵向的↓
```cpp
if(b[(i%3==0?i/3:i/3+1)%3==0?i-6:i+3]%2==1&&b[(i%3==0?i/3:i/3+1)%3==1?i+6:i+-3]%2==1)
```


## 下面放代码
~~Ps：原来看错题了，还以为是棋盘的棋子的位置，所以。。。~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int b[10];
string a;
void apart()
{
	int i,j;
	for(i=0;i<9;i++)
		b[i+1]=a[i]-'0';//这些是我原来看错题的部分，还是用了一下
	int m[3][3];
	for(i=0;i<9;i++)
		m[b[i]%3][b[i]/3]=i;  //按照下的顺序落子
	for(i=0;i<3;i++)
		for(j=0;j<3;j++) b[i*3+j]=m[i][j]+1; //输出成一维数组
}
int main()
{

	int i,flag=0;//极其简单的变量定义
	cin>>a;
	if(a.length()!=9) //判断a.length()<9时的情况
	{
		if(a.length()%2==1)
			cout<<"xiaoa wins."; //奇数小a赢
		else
			cout<<"uim wins."; //偶数uim赢
	}
	else
	{
		apart(); //不要在意名字
		for(i=1;b[i]!=9;i++){} //寻找9
		if(i==5) //在中间时要注意对角线
		{
			if(b[1]%2==1&&b[9]%2==1) flag=1; //左上-右下
			if(b[3]%2==1&&b[7]%2==1) flag=1; //右上-左下
		}
		if(b[i%3==0?i-2:i+1]%2==1&&b[i%3==1?i+2:i-1]%2==1) flag=1; //横向
		if(b[(i%3==0?i/3:i/3+1)%3==0?i-6:i+3]%2==1&&b[(i%3==0?i/3:i/3+1)%3==1?i+6:i+-3]%2==1) flag=1; //纵向
		if(flag==1) cout<<"xiaoa wins."; //输出
		else cout<<"drew.";
	}
    return 0;
}
```
眼花缭乱的三目运算符
可能编的有些复杂了

---

## 作者：灬Amiya灬 (赞：0)

这道题我快要被气死了，许多细节没注意，交了10几次才ac了，
这道题完全可以不打表来做
分下子数<9和==9两种情况
<9的话根据最后下的步数，可以判断输赢
==9的话，判断1,3,5,7,9步，不是xiaoa赢就是平局
具体判断的话，看前四步是否与第9步在同一行，同一列，(若第9步位于斜行上)同斜行
因为很容易得知每一步的位置，相当于一个二维数组嘛
行就是(步数-1)/3
列就是(步数+2)%3
斜的话，判断1,3,5,7,9就可以了
注意细节的话，就ac了，反正做完气死我了

```java
import java.util.Scanner;

public class Main {
    static String s = new String();
    static int num=0;
    static int id=0;
    static int jd=0;
    static int xd=0;
    public static void main(String[] args) {
        // TODO 自动生成的方法存根
        init();
    }
    private static  boolean find3(){
        int n = 6;
        int now = s.charAt(8)-'0';
        while(n>=0){
            int nownow = s.charAt(n)-'0';
            if((nownow-1)/3==(now-1)/3){
                id++;
                n-=2;
                continue;
            }
            if((nownow+2)%3==(now+2)%3){
                jd++;
                n-=2;
                continue;
            }
            if(now==1||now==5||now==3||now==7||now==9) {
                if(nownow==1||nownow==3||nownow==5||
                        nownow==7||nownow==9){
                    xd++;
                }
            }
            
            n-=2;
        }
        if(id==2||jd==2||xd==2){
            
            return true;
        }
        else return false;
    }

    private static void init() {
        // TODO 自动生成的方法存根
        Scanner in = new Scanner(System.in);
        s = in.next();
        num = s.length();
        if(num==9){
            if(find3())System.out.println("xiaoa wins.");
            else System.out.println("drew.");
        }
        else if(num%2==0)System.out.println("uim wins.");
        else System.out.println("xiaoa wins.");
    }

}
```

---

## 作者：豌豆射手皮0608 (赞：0)

看了各位大佬的题解，发现他们大多都在打表。。。

于是我自己写了一个程序，大致步骤如下：

首先，我们 ~~用玄学的方法~~ 把读入的数据存进二维数组，模拟棋盘

然后开始查找有没有三个连一起，如果有就直接输出赢的人

最后如果没有，输出平局

代码如下
```cpp
#include<bits/stdc++.h>

using namespace std;

string s;

int x,a[10][10],f;

void print(int a) //输出

{

	if(a==1)
	{
    
		cout<<"xiaoa wins."<<endl;
	}
	if(a==2)
	{
    
		cout<<"uim wins."<<endl;
	}
}

void find1()//横向查找

{

	for(int i=1;i<=3;i++)
	{
		f=1;//标记
		x=a[i][1];//存进第一个数
		for(int j=2;j<=3;j++)
	    {
	        if(x!=a[i][j])//如果有不一样，就退出循环
			{
				f=0;
				break;
			 } 
		}
		if(f&&x)//如果一样且第一个被下过，输出赢家，结束全部程序
		{
			print(x); 
			exit(0);
		}
	}
	return;
}
void find2()//竖向查找

{

	for(int i=1;i<=3;i++)
	{
		f=1;//标记
		x=a[1][i];//存进第一个数
		for(int j=2;j<=3;j++)
	    {
	        if(x!=a[j][i])//如果有不一样，就退出循环
			{
				f=0;
				break;
			 } 
		}
		if(f&&x)//如果一样且第一个被下过，输出赢家，结束全部程序
		{
			print(x); 
			exit(0);
		}
	}
	return;
}
void find3()//斜着查找

{

	f=1;//标记
	x=a[1][1];//存入第一个数
	for(int i=2;i<=3;i++)
	{
		if(x!=a[i][i])//查找
		{
			f=0;
			break;
		}
	}
	if(f&&x)//输出
	{
		print(x);
		exit(0);
	}
	f=1;//标记 
	x=a[1][3];//存入第一个数
	for(int i=2;i<=3;i++)
	{
		if(x!=a[i][4-i])//查找
		{
			
			f=0;
			break;
		}
	}
	if(f&&x)//输出
	{
		print(x);
		exit(0);
	}
}
int main()

{

	cin>>s;//全部读入
	for(int i=0;i<s.size();i++)//存储
    {
    	x=s[i]-'0';//把数从字符变成数字
    	a[(x-1)/3+1][(x-1)%3+1]=i%2+1;//把数字存入相应二维数组，并用1或2分别表示
	}
	
	find1();//查找横向
	find2();//查找竖向
	find3();//查找对角线
	cout<<"drew."<<endl;//如果前面都没找到3个连在一起，输出平局
	return 0;
}

```


---

## 作者：yszshs1 (赞：0)

~~真心不懂为什么楼下题解辣么长~~
### 这题就是~~打表~~枚举，把每一种情况列举出来，就是这样QWQ
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[10]={-1},n;//把一维数组看成二维数组，蒟蒻勿喷
	char x;
	for (int i=1;i<=9;i++){
		cin>>x;
		n=x-'0';//为了读入每一个数字，先用字符读入，再转成数字
		if (i % 2!=0) a[n]=1;
			else a[n]=2;//敲黑板！！！1代表player1，2代表player2，画圈圈喽
		if (a[1]==1 && a[5]==1 && a[9]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[1]==1 && a[2]==1 && a[3]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[4]==1 && a[5]==1 && a[6]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[7]==1 && a[8]==1 && a[9]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[3]==1 && a[5]==1 && a[7]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[1]==1 && a[4]==1 && a[7]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[2]==1 && a[5]==1 && a[8]==1) {cout<<"xiaoa wins."; return 0;}
		if (a[3]==1 && a[6]==1 && a[9]==1) {cout<<"xiaoa wins."; return 0;}//列举player1赢的所有情况
		//===============================================//分割线
    	if (a[1]==2 && a[5]==2 && a[9]==2) {cout<<"uim wins."; return 0;}
		if (a[1]==2 && a[2]==2 && a[3]==2) {cout<<"uim wins."; return 0;}
		if (a[4]==2 && a[5]==2 && a[6]==2) {cout<<"uim wins."; return 0;}
		if (a[7]==2 && a[8]==2 && a[9]==2) {cout<<"uim wins."; return 0;}
		if (a[3]==2 && a[5]==2 && a[7]==2) {cout<<"uim wins."; return 0;}
		if (a[1]==2 && a[4]==2 && a[7]==2) {cout<<"uim wins."; return 0;}
		if (a[2]==2 && a[5]==2 && a[8]==2) {cout<<"uim wins."; return 0;}
		if (a[3]==2 && a[6]==2 && a[9]==2) {cout<<"uim wins."; return 0;}同上（return 0不可少）
	}
	cout<<"drew.";//如果都不满足，则平局
	return 0;//好习惯
}//perfect ending
```

## 这题难点就是输入麻烦与判断，“字符转数字输入法”真的很实用，而判断的枚举一定不要漏了某一项，可以在草稿纸上画一个图帮助枚举，QWQ

附上图：- 1 2 3
       - 4 5 6
       - 7 8 9
       {数字表示格子的位置（数组下标）}

---

## 作者：黑猫_琉璃 (赞：0)

这道题其实就是一个普通的模拟，具体思路就是用一个二维数组来表示整个棋盘，然后每一次落子都放到这个棋盘相应的位置，并判断这次该谁下了就好了。这样我们就可以得到一个完整的棋盘信息，再根据这个棋盘判断是谁赢了。有人赢的话直接输出然后return 0;最后再输出drew.就可以了。实现上述思路的代码操作如下：
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

//idxi表示第几列，idxj表示第几行 
int i,idxi,idxj,cb[3][3];//chessboard
char a[6],uim[6],crt;
int main(){
	while(true){
		//以字符串的形式输入 
		scanf("%c",&crt);
		//如果输入全部结束了就打断循环不输入了。 
		if(crt == '\n'){
			break;
		}
		//能运行到这里就说明输入没有结束，开始放旗子 
		//把字符串转化为数字。输入的时候字符串更方便，判断的时候数字更好 
		crt -= '0';
		//二维数组第一个下标代表第几列，crt%3的结果有0,1和2，1和2只要减1就可以了，如果是0就代表在最后，下标要变成2 
		idxi = crt%3!=0 ? crt%3-1 : 2;
		//二维数组的第二个下标代表第几行，if语句很形象地体现了判断列的过程
		if(crt >= 1 && crt <= 3){
			idxj = 0;
		}else if(crt >= 4 && crt <= 6){
			idxj = 1;
		}else if(crt >= 7 && crt <= 9){
			idxj = 2;
		}
		//赋值表达式左边的内容用于判断这一子是谁下的 
		cb[idxi][idxj] = i % 2 + 1;
		i++;
	}
	//输入、处理部分至此结束
	//判断小a是否赢了，代表小a的数字是1 
	for(int j=0;j<3;j++){
		//判断横行是否连成3个 
		if(cb[j][0] == 1 && cb[j][1] == 1 && cb[j][2] == 1){
			printf("xiaoa wins.");
			return 0;
		}
		//判断纵列是否连成3个
		if(cb[0][j] == 1 && cb[1][j] == 1 && cb[2][j] == 1){
			printf("xiaoa wins.");
			return 0;
		} 
	} 
	//判断对角线上的三个棋子是否连成3个
	if((cb[0][0] == 1 && cb[1][1] == 1 && cb[2][2] == 1) || (cb[0][2] == 1 && cb[1][1] == 1 && cb[2][0] == 1)){
	   	printf("xiaoa wins.");
	   	return 0;
	} 
	//判断uim是否赢了，代表uim的数字是2(方法同上)
	for(int j=0;j<3;j++){
		if(cb[j][0] == 2 && cb[j][1] == 2 && cb[j][2] == 2){
			printf("uim wins.");
			return 0;
		}

		if(cb[0][j] == 2 && cb[1][j] == 2 && cb[2][j] == 2){
			printf("uim wins.");
			return 0;
		} 
	} 
	if((cb[0][0] == 2 && cb[1][1] == 2 && cb[2][2] == 2) || (cb[0][2] == 2 && cb[1][1] == 2 && cb[2][0] == 2)){
	   	printf("uim wins.");
	   	return 0;
	} 
	//如果能够运行到这里，就说明没有任何一个人赢，输出drew.
	printf("drew."); 
	return 0;
}
```

---

## 作者：SasukeUchiha (赞：0)

申明：由于此题旧题解过于冗杂，故再作题解

题目[P1838 三子棋I](https://www.luogu.org/problemnew/show/P1838)

题目如下：
小a和uim喜欢互相切磋三子棋。三子棋大家都玩过是吗？就是在九宫格里面OOXX（别想歪了），谁连成3个就赢了。由于小a比较愚蠢，uim总是让他先。我们用9个数字表示棋盘位置：123 456 789 所有的棋谱都是已经结束的棋局，要么一方获胜，要么平局。今天，他们下了一下午的棋，小a为了提高技术，录下了很多棋谱。他想知道，一盘棋结束时，到底是谁赢。

然而，题目并没有交代**输赢条件**(~~这就非常尴尬了~~)；虽然我相信大家都有玩过“三字棋”，在这里还想要申明一下：

![8种胜利情况](C:\Users\26963\Desktop\8种胜利情况.png)

连续一横排**3**种情况

连续一竖排**3**种情况 

连续一斜线**2**种情况

一共**8**种胜利情况；那么胜利情况既少，可以一个一个**手动**判断了。

以下是代码：
```cpp
#include<cstdio>
using namespace std;
int main()
{
	char s[10]={'\0'};
	int  a[10];
	for(int j=0;j<10;j++)
	a[j]=-1;
    //初始化棋盘
	scanf("%s",s);
    //由于数据长度未知(1~9),作为字符数组读入数据
	int o=-1;
    //表示输赢状态(-1:平,0:小a胜,1:对手胜)
	int i=0;
	for(;;)
	{
		if(s[i]=='\0')break;
		if(i%2==0)
		a[s[i]-'0']=0;
		else
		a[s[i]-'0']=1;
		i++;
		}
    //将读入的状态保存到棋盘
    //棋盘如下：
    // a[1] a[2] a[3]
    // a[4] a[5] a[6]
    // a[7] a[8] a[9]
	if(a[1]==a[2]&&a[2]==a[3]&&a[1]!=-1)
	o=a[1];
	if(a[4]==a[5]&&a[5]==a[6]&&a[4]!=-1)
	o=a[4];
	if(a[7]==a[8]&&a[8]==a[9]&&a[7]!=-1)
	o=a[7];
	if(a[1]==a[4]&&a[4]==a[7]&&a[1]!=-1)
	o=a[1];
	if(a[2]==a[5]&&a[5]==a[8]&&a[2]!=-1)
	o=a[2];
	if(a[3]==a[6]&&a[6]==a[9]&&a[3]!=-1)
	o=a[3];
	if(a[1]==a[5]&&a[5]==a[9]&&a[1]!=-1)
	o=a[1];
	if(a[3]==a[5]&&a[5]==a[7]&&a[3]!=-1)
	o=a[3];
    //8种胜利的判断
	if(o==-1)
	printf("drew.");
	else if(o==0)
	printf("xiaoa wins.");
	else if(o==1)
	printf("uim wins.");
    //输出
	return 0;
    //结束
	}

```

另：压行过后 (~~美观度++~~)
```cpp
#include<cstdio>
using namespace std;int main(){char s[10]={'\0'};int  a[10];for(int j=0;j<10;j++)a[j]=-1;scanf("%s",s);int o=-1;int i=0;for(;;){if(s[i]=='\0')break;if(i%2==0)a[s[i]-'0']=0;else	a[s[i]-'0']=1;i++;}if(a[1]==a[2]&&a[2]==a[3]&&a[1]!=-1)o=a[1];if(a[4]==a[5]&&a[5]==a[6]&&a[4]!=-1)o=a[4];if(a[7]==a[8]&&a[8]==a[9]&&a[7]!=-1)o=a[7];if(a[1]==a[4]&&a[4]==a[7]&&a[1]!=-1)o=a[1];if(a[2]==a[5]&&a[5]==a[8]&&a[2]!=-1)o=a[2];if(a[3]==a[6]&&a[6]==a[9]&&a[3]!=-1)o=a[3];if(a[1]==a[5]&&a[5]==a[9]&&a[1]!=-1)o=a[1];if(a[3]==a[5]&&a[5]==a[7]&&a[3]!=-1)o=a[3];if(o==-1)printf("drew.");else if(o==0)printf("xiaoa wins.");else if(o==1)printf("uim wins.");return 0;}
```

**Thanks for reading.**


---

## 作者：Fraction (赞：0)

这里介绍一下本蒟蒻想出来的一行下棋法：

```cpp
_map[(int)ceil((float)(a)/3)][a%3!=0?a%3:3]=b+1;
```

想出来的时候我自己都爽。

其实不是很难懂，

第i个位置不就是第$ceil(i\div3)$行，$i%3!=0?i%3:3$列吗

那个双目运算符就是让位置为3 6 9的棋下在第ceil(i/3)行的第3列

代码如下：
```cpp
#include <bits/stdc++.h>
#define fp(i,l,r) for(register int i=(l);i<=(r);++i)
#define fd(i,l,r) for(register int i=(l);i>=(r);--i)
#define MAXN 10+2
#define il inline
#define st static
#define  m(i,j,k) _map[i][j]==(k)
#define rg register
using namespace std;

st int _map[MAXN][MAXN],a;

il int pdsb(){
    fp(i,1,3){
        fp(j,1,3){
            if(m(i,j,1)&&m(i+1,j,1)&&m(i+2,j,1)){
                printf("xiaoa wins.");
                return 0;
            }
        }
    }
    fp(j,1,3){
        fp(i,1,3){
            if(m(i,j,1)&&m(i,j+1,1)&&m(i,j+2,1)){
                printf("xiaoa wins.");
                return 0;
            }
        }
    }
    if(m(1,1,1)&&m(2,2,1)&&m(3,3,1)){
        printf("xiaoa wins");
        return 0;
    }
    if(m(1,3,1)&&m(2,2,1)&&m(3,1,1)){
        printf("xiaoa wins.");
        return 0;
    }
    fp(i,1,3){
        fp(j,1,3){
            if(m(i,j,2)&&m(i+1,j,2)&&m(i+2,j,2)){
                printf("uim wins.");
                return 0;
            }
        }
    }
    fp(j,1,3){
        fp(i,1,3){
            if(m(i,j,2)&&m(i,j+1,2)&&m(i,j+2,2)){
                printf("uim wins.");
                return 0;
            }
        }
    }
    if(m(1,1,2)&&m(2,2,2)&&m(3,3,2)){
        printf("uim wins");
        return 0;
    }
    if(m(1,3,2)&&m(2,2,2)&&m(3,1,2)){
        printf("uim wins.");
        return 0;
    }
    printf("drew.");
    return 0;
}

il int goes(int a,int b){
    _map[(int)ceil((float)(a)/3)][a%3!=0?a%3:3]=b+1;
    return 0;
}
il int init(){
    st int i;
    while(scanf("%1d",&a)!=EOF){
        goes(a,i%2);
        ++i;
    }
    pdsb();
    return 0;
}

int main(){
    init();
    return 0;
}
```

有一个缺点，就是判断输赢的过程太长了...

顺便赞一句luogu，解决EOF这类本地很烦躁的问题很棒！

---

## 作者：JustinRochester (赞：0)

**【分析】**
--------------
这一题数据量最多是9，可以考虑全部存下来。

建立一个二维数组维护下的棋，xiaoa的为1，uim的为2，没下过棋的都为0。

这样，只要在输入后枚举8种情况即可(横着3条，竖着3条，左斜右斜各1条)。

输入时，本蒟蒻考虑到每个数字都不超过10，也就是说最多只有1位，那我们就可以用字符变量来输入。一是可以避免int输入时会一连串直接输进来，后面不好分；二是更快。

判定时，我们通过棋盘一定有解可以知道，不可能存在两个人同时赢的情况，故此只要判定出一个人赢即可结束其他判定(if...else if...)。

那如何判定平局呢......

本蒟蒻把判定的结果用ans保存，其中ans初始化为0。

若上述8种情况中其中一种成立，则保存ans为下棋者(1为xiaoa，2为uim)。

那么，输出时只要判定ans是否为0即可判定是否平局了。

_________________

**【代码】**
--------------

本蒟蒻代码奉上

```cpp
#include<cstdio>
using namespace std;
int main(){
	int map[3][3]={0},ans=0;
	char c=getchar();
	for(int i=1;c!=EOF;i=(i==1)?2:1) map[(c-'1')/3][(c-'1')%3]=i,c=getchar();
	//当c还能输入时，将它转化为数字(c-'0')
    //假设数字为x，则应该存在map[(x-1)/3][(x-1)%3]
    //而x-1  =  c-'0'-1  =  c-('0'+1)  =  c-'1'
		 if(map[0][0]==map[0][1]&&map[0][1]==map[0][2]) ans=map[0][1];
	else if(map[1][0]==map[1][1]&&map[1][1]==map[1][2]) ans=map[1][1];
	else if(map[2][0]==map[2][1]&&map[2][1]==map[2][2]) ans=map[2][1];
	else if(map[0][0]==map[1][0]&&map[1][0]==map[2][0]) ans=map[1][0];
	else if(map[0][1]==map[1][1]&&map[1][1]==map[2][1]) ans=map[1][1];
	else if(map[0][2]==map[1][2]&&map[1][2]==map[2][2]) ans=map[1][2];
	else if(map[0][0]==map[1][1]&&map[1][1]==map[2][2]) ans=map[1][1];
	else if(map[0][2]==map[1][1]&&map[1][1]==map[2][0]) ans=map[1][1];
	printf(ans?((ans&1)?"xiaoa wins.":"uim wins."):"drew.");
	return 0;
}
```

---

## 作者：DengTJ (赞：0)

```cpp
    #include<cstdio>
    #include<cstdlib>
    #include<iostream>
    #include<cstring>
    using namespace std;
    int a[10],b[10];
    char c[10];
    int pda()//极其暴力地判断是否胜利
    {
        if(a[1]==1&&a[2]==1&&a[3]==1)
          return 1;
        if(a[4]==1&&a[5]==1&&a[6]==1)
          return 1;
        if(a[7]==1&&a[8]==1&&a[9]==1)
          return 1;
        if(a[1]==1&&a[4]==1&&a[7]==1)
          return 1;
        if(a[2]==1&&a[5]==1&&a[8]==1)
          return 1;
        if(a[3]==1&&a[6]==1&&a[9]==1)
          return 1;
        if(a[1]==1&&a[5]==1&&a[9]==1)
          return 1;
        if(a[3]==1&&a[5]==1&&a[7]==1)
          return 1;
    }
    int pdb()
    {
        if(b[1]==1&&b[2]==1&&b[3]==1)
          return 1;
        if(b[4]==1&&b[5]==1&&b[6]==1)
          return 1;
        if(b[7]==1&&b[8]==1&&b[9]==1)
          return 1;
        if(b[1]==1&&b[4]==1&&b[7]==1)
          return 1;
        if(b[2]==1&&b[5]==1&&b[8]==1)
          return 1;
        if(b[3]==1&&b[6]==1&&b[9]==1)
          return 1;
        if(b[1]==1&&b[5]==1&&b[9]==1)
          return 1;
        if(b[3]==1&&b[5]==1&&b[7]==1)
          return 1;
    }
    int main()
    {
        int len,f=0;//f是对是否平局的判断
        cin>>c;
        len=strlen(c);
        for(int i=1;i<=len;i++)
        {
            if(i%2==1)  //若这个数为奇数，就在小a的棋盘里下子
            {
                a[c[i-1]-'0']=1;
            }
            if(pda())
            {
                printf("xiaoa wins.");
                f=1;
                break;
            }
            if(i%2==0)//若这个数为偶数，就在uim的棋盘里下子
            {
                b[c[i-1]-'0']=1;
            }
            if(pdb())
            {
                printf("uim wins.");
                f=1;
                break;
            }
        }
        if(f==0)//判断是否平局
          printf("drew.");
        return 0;
}
```

---

## 作者：std__unsigned (赞：0)

这道题我是模拟赢得八种情况。用深搜好像也可以

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int vis[4][4];//模拟棋盘
char s[10];//棋谱
int main()
{
    scanf("%s",s+1);//输入字符串
    int len=strlen(s+1);
    int flag=1;
    for(int i=1;i<=len;i++)
    {
        flag=-flag;//每次将flag变成相反数，代表更换执棋者
        if(s[i]=='1')
            vis[1][1]=flag;
        if(s[i]=='2')
            vis[1][2]=flag;
        if(s[i]=='3')
            vis[1][3]=flag;
        if(s[i]=='4')
            vis[2][1]=flag;
        if(s[i]=='5')
            vis[2][2]=flag;
        if(s[i]=='6')
            vis[2][3]=flag;
        if(s[i]=='7')
            vis[3][1]=flag;
        if(s[i]=='8')
            vis[3][2]=flag;
        if(s[i]=='9')
            vis[3][3]=flag;
    }
    if((vis[1][1]==1&&vis[1][2]==1&&vis[1][3]==1)||(vis[2][1]==1&&vis[2][2]==1&&vis[2][3]==1)||(vis[3][1]==1&&vis[3][2]==1&&vis[3][3]==1)||(vis[3][3]==1&&vis[1][1]==1&&vis[2][2]==1)||(vis[3][1]==1&&vis[2][2]==1&&vis[1][3]==1)||(vis[1][1]==1&&vis[2][1]==1&&vis[3][1]==1)||(vis[1][1]==1&&vis[1][2]==1&&vis[1][3]==1)||(vis[1][2]==1&&vis[2][2]==1&&vis[3][2]==1)||(vis[1][3]==1&&vis[2][3]==1&&vis[3][3]==1))//枚举8种情况
        printf("uim wins.");
    else if((vis[1][1]==-1&&vis[1][2]==-1&&vis[1][3]==-1)||(vis[2][1]==-1&&vis[2][2]==-1&&vis[2][3]==-1)||(vis[3][1]==-1&&vis[3][2]==-1&&vis[3][3]==-1)||(vis[3][3]==-1&&vis[1][1]==-1&&vis[2][2]==-1)||(vis[3][1]==-1&&vis[2][2]==-1&&vis[1][3]==-1)||(vis[1][1]==-1&&vis[2][1]==-1&&vis[3][1]==-1)||(vis[1][1]==-1&&vis[1][2]==-1&&vis[1][3]==-1)||(vis[1][2]==-1&&vis[2][2]==-1&&vis[3][2]==-1)||(vis[1][3]==-1&&vis[2][3]==-1&&vis[3][3]==-1))////枚举8种情况
        printf("xiaoa wins.");
    else printf("drew.");
}

```

---

## 作者：CREED (赞：0)

发现 P党 代码少，来一发。

本人采用暴力枚举，适合新手翻看。

如下
```cpp
var p:array[1..9]of 0..2; //1表示xiaoa,2表示uim
    i:longint; s:char; x:boolean; 
begin
  fillchar(p,9,0); x:=false;  //初始化数据
  for i:=1 to 9 do
    begin
       read(s);
      if x then
        p[ord(s)-ord('0')]:=2
      else
        p[ord(s)-ord('0')]:=1;
      x:=not x;
      if(p[1]=p[2])and(p[2]=p[3])then    //开始判断是否胜利，表示打了好久
        begin
          if p[1]=1 then
            begin
              write('xiaoa wins.');
              halt;
            end
          else
            if p[1]=2 then
              begin
              write('uim wins.');
              halt;
              end;
        end;
      if(p[1]=p[4])and(p[4]=p[7])then
          begin
          if p[1]=1 then
            begin
              write('xiaoa wins.');
              halt;
            end
          else
            if p[1]=2 then
              begin
                write('uim wins.');
                halt;
              end;
        end;
      if(p[1]=p[5])and(p[5]=p[9])then  begin
          if p[1]=1 then
            begin
              write('xiaoa wins.');
              halt;
            end
          else
            if p[1]=2 then
              begin
                write('uim wins.');
                halt;
              end;
        end;
      if(p[2]=p[5])and(p[5]=p[8])then
          begin
            if p[2]=1 then
              begin
                write('xiaoa wins.');
                halt;
              end
          else
            if p[2]=2 then
              begin
                write('uim wins.');
                halt;
              end;
        end;
      if(p[3]=p[6])and(p[6]=p[9])then
          begin
            if p[3]=1 then
              begin
                write('xiaoa wins.');
                halt;
              end
            else
              if p[3]=2 then
              begin
                write('uim wins.');
                halt;
              end;
          end;
      if(p[4]=p[5])and(p[5]=p[6])then
          begin
            if p[4]=1 then
              begin
                write('xiaoa wins.');
                halt;
              end
          else
            if p[4]=2 then
              begin
                write('uim wins.');
                halt;
              end;
        end;
      if(p[7]=p[8])and(p[8]=p[9])then
          begin
            if p[7]=1 then
              begin
                write('xiaoa wins.');
                halt;
              end
          else
            if p[7]=2 then
              begin
                write('uim wins.');
                halt;
              end;
        end;
      if(p[3]=p[5])and(p[5]=p[7])then
          begin
            if p[3]=1 then
              begin
                write('xiaoa wins.');
                halt;
              end
          else
            if p[3]=2 then
              begin
                write('uim wins.');
                halt;
              end;
        end;
    end;
  write('drew.');  //没有一人赢就是平局啊
end.

```

---

## 作者：Deny_小田 (赞：0)

小田又来发题解啦~~~

看还是没有C++ 题解   一发

本题就是考察语言基础的功底是否扎实，扎实的话应该没有什么问题。


注意三个点：


1：如何将数字转化成二维下标：

方程：A[(y[i]-'0'-1)/3][(y[i]-'0'-1)%3] = h;

变量解析：A数组存放矩阵，y数组存放数字（我用的是char类型，int类型也可以，需要把-'0'去掉   ）

注意：[color=red]#   y[i]-'0'-1中的-1务必加上！    [/color]

解决这个问题之后基本没有什么大问题了。


2：不要忘记语句后面的句点 '.'


printf("xiaoa wins.");     //一定不要忘记了句点，否则肯定会爆零。


3：注意：[color=red]#  输入的字符串长度不确定！！！  [/color]


其实细心地人会发现，样例中的一个串长度为7，另一个长度为9。怎么办呢？使用strlen()函数读取长度。

当然不要忘记了包含头文件 <string.h>


我就被坑了。还有一点针对样例：用我的算法即使写成了一个常数（< 9），样例还是都能过，因为第一个样例：常数大点就能过。第二个样例：即使常数小了，最后flag还是=0，还会被写成“drew.“   吼吼吼~~~


[delete]废话说了这么这么多，上代码：[/delete]





    

    

```cpp
#include <cstdio>
#include <string.h>
#define Size 10
char A[Size][Size] = {""},h,y[Size];
int P(int i,int j){
    if(A[i][j] == 'O') return 1;
    else if(A[i][j] == 'X') return 2;
}
int JudgeWin(){
    if((A[1][0] == A[0][0])&&(A[1][0] == A[2][0])) return P(0,0);
    if((A[1][0] == A[1][1])&&(A[1][0] == A[1][2])) return P(1,0);
    if((A[0][1] == A[0][0])&&(A[0][1] == A[0][2])) return P(0,1); 
    if((A[0][1] == A[1][1])&&(A[0][1] == A[2][1])) return P(0,1);
    if((A[2][1] == A[2][0])&&(A[2][1] == A[2][2])) return P(2,1);
    if((A[1][2] == A[0][2])&&(A[1][2] == A[2][2])) return P(1,2);
    if((A[0][0] == A[1][1])&&(A[0][0] == A[2][2])) return P(0,0);
    if((A[0][2] == A[1][1])&&(A[0][2] == A[2][0])) return P(0,2);
    return 0;
} 
int main(){
    int q,flag = 0;
    h = 'O';    //不妨假设 'O' 是 小a，uim为 'X' 
    scanf("%s",y);
    for(int i = 0; i < strlen(y); i++){
        A[(y[i]-'0'-1)/3][(y[i]-'0'-1)%3] = h;    //方程挺难推的，自己想想吧 
        q = JudgeWin();
        if(q == 1){
            flag = 1;
            break;
        }else if(q == 2){
            flag = 2;
            break;
        }
        h == 'O'?h = 'X':h = 'O';
    }
    if(flag == 1) printf("xiaoa wins.\n");
    else if(flag == 2) printf("uim wins.\n");
    else printf("drew.\n");
    return 0;
}
```
一个小建议：当大家将数字转化成下标之后，不妨将二维数组输出一下，检测转化的是否正确。
另一个HINT：注意需要将判断胜负的函数写在转化二维数组的循环中：

[color=purple]这样写的用处在于：判断谁先胜出——有可能到最后两个人都胜出了，这时候就需要判断谁先胜出，一定要写上！[/color]


---

## 作者：jxpxxzj (赞：0)

#第一部分

因为题目已经说明了是完整的棋局，考虑 下子的数量<9 时判断数量的奇偶性。

xiaoa下第奇数个子 uim下第偶数个子

若 下子的数量为奇数 则说明xiaoa下了最后一个决定性的子使xiaoa wins.

反之为uim wins.

```delphi

if length(s)<9 then  
        if length(s) mod 2 = 1 then  
        begin  
           writeln('xiaoa wins.');   
           halt;  
        end  
        else  
        begin  
          writeln('uim wins.');   
          halt;  
        end; 

```

#第二部分

当 下子的数量 = 9 时 只存在 xiaoa wins. 和 drew. 两种情况。

考虑记录xiaoa下子的位置

以样例2为参考

**539128647**

则xiaoa在5 9 2 6 7位置下子

记录为如下的3\*3数组

0 1 0
0 1 1
1 0 1
判断每一横行，竖行以及对角线的和是否为3 [color=blue]//存在三子连线的情况[/color]

如果存在 则说明xiaoa wins. 反之为drew.


---


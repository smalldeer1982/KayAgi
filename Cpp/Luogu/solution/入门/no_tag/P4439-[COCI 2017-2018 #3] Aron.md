# [COCI 2017/2018 #3] Aron

## 题目描述

节日季节快到了！Aron 想为他在 Zagreb 的朋友们准备礼物，为了及时拿到礼物，他去了伦敦的一家著名玩具店。在挑选好礼物后，他来到收银台，发现已经有 N 个人在排队。幸运的是，他注意到除了单独的顾客外，还有一群人站在队伍中。一群人由一位顾客及其朋友组成，他们在等待顾客完成购买。当顾客完成购买时，他们和他们的朋友就会离开队伍。

被认为是一组的人是一个接一个站着的，并且穿着颜色相同的衬衫。相邻的两组、相邻的个人或相邻的个人和一组，永远不会穿着相同颜色的衬衫。

编写一个程序，给定排队人群的数据，输出 Aron 在队伍中的位置。

## 说明/提示

**第二个测试用例的说明：**

排在第一的是由两名穿红色衬衫的人组成的组。第二个是穿蓝色衬衫的个人，第三个是穿红色衬衫的个人，第四个是穿绿色衬衫的组。这使得 Aron 排在第五。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
C
Z
P
```

### 输出

```
4```

## 样例 #2

### 输入

```
6
C
C
P
C
Z
Z```

### 输出

```
5```

## 样例 #3

### 输入

```
6
B
B
B
B
B
B```

### 输出

```
2```

# 题解

## 作者：switch大法好 (赞：16)

自我感觉方法还是挺简单的。

题目描述相当于一块一块的人，我们只要统计出一共有几块人，然后再+1，就是Aron的位置。


而找几块人，我们不需要把每个人的衣服颜色都记下来，我们只需要记下一个变量，记录上一个人的衣服颜色，和这个人的衣服颜色进行比较，如果一样，则属于同一块，跳过，继续找下一个人。如果不一样，则说明不属于同一块，那么则ans人数++，变量k为当前人的衣服颜色。



接下来就是代码了，我们只需要从1~n扫一遍，统计一下ans,即可得出答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int main(){
	scanf("%d",&n);
	char k='#';//变量K，题目给出衣服颜色一定是大写字母，所以我们初始化一个#。 
	for(int i=1;i<=n;i++){//循环 
		char s;//当前人的衣服颜色 
		cin>>s;
		if(s==k)continue;//属于同一块 
		ans++;
		k=s;
	}ans++;
	printf("%d",ans);//输出答案 
	return 0;
} 
```
好了，（只是突然发现红题又新加了一道，所以来发篇题解，第一篇题解，望能过）
祝大家AC~


---

## 作者：jiangXxin (赞：7)

一道模拟题，比较适合新手（~~划水~~）

先来看一下题目，因为只有穿一样衣服的人（也就是一样的**字符**，**而且必须是连续的**）为什么呢？让我们看一下样例2：

![m5qmZt.png](https://s2.ax1x.com/2019/08/27/m5qmZt.png)

此处虽然第一个区域和第二个区域都是$C$,但是最终答案却是5，那么第二部分的$C$肯定就需要单独考虑

在一堆朋友里面，只需要算一个人就可以了，考虑到这道题的N非常小，所以我们可以使用一个队列，每次考虑到一个人，就将他丢入队列里面，同时向后枚举他所有的朋友，一旦枚举到不是他的朋友就可以停下了，最后答案就是：**队列的大小+1**(题目要求输出这个人排在第几位)

**code**
```cpp
#include<bits/stdc++.h>
#define REP(A,B,I) for(int I=(A);I<=(B);I++)
#define PER(A,B,I) for(int I=(A);I>=(B);I--)
#define max(X,Y) ((X)<(Y)?(Y):(X))
#define min(Y,X) ((X)<(Y)?(X):(Y))
#define read(FILENAME) freopen((FILENAME + ".txt"), "r", stdin);
#define write(FILENAME) freopen((FILENAME + ".txt"), "w", stdout);
#define LL long long
#define N 2080
using namespace std;
int n,cnt=1;
char c[N];
queue<char> que;
int main(){
    //read(1)
    //write(1)
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);//加速cin
    cin>>n;
    REP(1,n,i){
        cin>>c[i];//输入前n个人的数据
    }
    REP(1,n,i){
        char x=c[i];//获取这个人
        while(c[i]==x)i++;//寻找他的朋友
        i--;
        que.push(x);//加入队列
    }
    cout<<que.size()+1<<endl;//最终答案
    return 0;
}

```


---

## 作者：zhaowangji (赞：5)

~~说实话我一开始真没看出来怎么做~~

解读一下：

一些人排队，有些是朋友，都排在一起，所以就当一个人（比如结账时候）

每个人都有自己的标记，并且朋友与朋友之间的标记相同

（注意有可能不是朋友，即不是排在一起的两个人标记也相同，如样例2）

把互相是朋友的人删去，只留下一个人排队

现在问你总共有几个人在排队
**（记得加上自己）**

**其实就是判断这个人和上一个人是不是朋友，即标记是否相同（题目保证相邻的人如果不是朋友标记不同）**

楼上方法其实烦了，直接采用变量迭代的方法

```cpp
#include<iostream>
using namespace std;
int n;
char a,b;//注意是char
int ans;//答案
int main()
{
	cin>>n;//读入
	for(int i=1;i<=n;i++)
	{
			cin>>b;//当前人的标记
			if(a!=b)ans++;//与前面人的标记不一样
			a=b;//迭代，把上一个人的标记改为这个人的（为了下一次的判断）
	}
	cout<<ans+1<<endl;//加上自己
	return 0;
}
```


---

## 作者：zhanghanbin (赞：4)

本大菜鸡最喜欢使用 $ LaTex $

## 目录：

- 如何比较前后相不相等——**数组 +** 在线处理？

- 填一个大坑——**到底从几开始数 ?**

- 代码亮相^o^

------

### 1.1 读入

这一道大水题非常适合使用数组，但是呢，个人喜欢一个一个读入，一边读一边处理，~~俗称~~在线处理。

然后就有了一个非常简单的代码：

```cpp
for (int i = 1; i <= n; i++) {
	cin >> a[i];
	//后边的事，先不管。
}
```
### 1.2 判断

输入完了一个数自然就得和它前面的`char`比较一下，如果不相等，累加器就加一，因为他们不穿一个颜色，不相等就满足了条件，所以累加器就加一。

就这样，
```cpp
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    if (a[i] != a[i - 1]) {
	ans++;
    }
}
```

于是，我竟然$\colorbox{red}{\color{white}{\textbf{\tiny{Wrong Answer}}}}$ $\color{red}{\textbf{\small{0}}}$了，没错，~~luogu永远不会出这么有良心的题目的~~（不过这一题好像不是洛谷的）。

### 2.1 填坑

这个坑点就在于他的

$\text{\large前面!}$

$\text{\Large前面!}$

$\textbf{\huge前面!}$

所以，初始化 `ans = 1;`

### 3.1 代码

就是这样子啦：
``` cpp
#include <iostream>

using namespace std;
char a[1000];
int n, ans = 1;
int main(int argc, char *argv[]) {
    a[0] = '0' //输入永远是大写，给个0，不过不加也不会错。
    cin >> n;
    for (int i = 1; i <= n; i++) {
   	cin >> a[i];
        if (a[i] != a[i - 1]) ans++;
    }
    cout << ans << endl;
    return 0;
}
```

-----

### 咕咕，还没完呢！

-----

### 4.1 没用的优化

这里有个点相信大家发现了，这个东西有点吃空间，所以再来优化一把：

``` cpp
#include <iostream>

using namespace std;
char a, b;
int n, ans = 1;
int main(int argc, char *argv[]) {
    a = '0'; //输入永远是大写，给个0，不过不加也不会错。
    cin >> n;
    for (int i = 1; i <= n; i++) {
   	cin >> b;
        if (b != a) ans++;
        a = b;
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：Eason_AC (赞：4)

虽然是个入门题，但是看题解里面好像都讲的复杂了，蒟蒻就来发一篇题解为新人造福吧。

---

其实你读懂题目之后这道题目就很简单了。只要把两个或以上的当做一个整体看就行了。相当于计算这里面一共有多少个整体。不过在计算答案的时候还要加上1才是自己的位置。

还没听懂？结合样例$2$解释一下：
```cpp
输入：
6
C
C
P
C
Z
Z
```
这里，我们应该将第$1$行和第$2$行的两个$\text{C}$以及第$5$行和第$6$行的两个$\text{Z}$。注意，这里和去重不一样，比如上面第$4$行的$\text{C}$不能跟前面算作一个整体。这样前面就有$4$个人在排队，加上$\text{Aron}$一共有$5$个。所以$\text{Aron}$排在了第$5$位。

算法实现的时候可以考虑在线处理，即**边输入边处理数据**。当然，如果是第$1$个，就先得算作一个人。之后就判断当前位置的字母是否与前$1$位的字母相同，是的话答案就不要加任何东西，否则加$1$。最后输出答案加$1$（这个应该前面解释的很清楚了吧）。

好了，接下来给出我的$AC$代码供大家**参考**（而非**抄题解**）：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;

int n, cnt;
char a[27][2];

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) {
		scanf("%s", a[i]);
		if(i == 1)	cnt++;
//		if(i > 1)
//			printf("%d:%c %d:%c\n", i, a[i][0], i - 1, a[i - 1][0]);
		if(i > 1 && a[i][0] != a[i - 1][0])	cnt++;
	}
	printf("%d", cnt + 1);
}
//防盗水印：UID=112917
```
~~原谅我忘记写上return 0~~,不过以后还是建议加上的。

还有就是字符读入的问题，因为单纯地用$char$字符读入会出现只读入一行就数出答案的情况，所以转用大小为$2$的字符数组读入，然后按第一位比较就行了。

最后祝大家刷题愉快！

---

## 作者：zhengrunzhe (赞：4)

提供一个极短的代码

使用std::unique即可 

```cpp
#include<cstdio>
#include<algorithm>
const int N=30;
int n;
char a[N];
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)scanf(" %c",&a[i]);
	printf("%d",std::unique(a+1,a+n+1)-a);
	return 0;
}
```

---

## 作者：R·Buffoon (赞：3)

诶，这道题可以用$map$搞映射欸

于是，愉快的打下了这么一份代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,ans=1;
char c;
map<char,int> a;

int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>c;
        if(!a[c]) a[c]=1,++ans;
    }

    cout<<ans<<endl;

    return 0;
}
```
同样愉快地过了第一个样例，结果却倒在了第二个样例上，~~这该怎么办呢？~~

重新读一遍题,发现并不是字母一样就属于同一个小团体 ~~（黑帮（笑））~~，而是字母相同并且在一起（中间没有其他字母隔开）才算

于是，一份全新的代码横空出世，过了样例一，过了样例二，过了样例三！好的，提交，$A$了！

这就是那份$A$了这道题的**代码** ~~（感jio很牛*）~~

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,ans=1;//注意ans初值为1，因为。。。（自己想）
char c1,c2;//本来可以用数组存每次读入的字符，但是除了这一个和前一个有用，其他都没有，所以可以滚掉
map<char,int> a;

int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>c1;
        if(c1!=c2)
        {
            if(!a[c1]) a[c1]=1,++ans;//如果这个字符未出现过，则标记，答案++
            else ++ans;//如果出现过且这个字符与前一个字符不同，说明这是一个新团体，答案++
        }
        c2=c1;//保存这次读入的字符
    }

    cout<<ans<<endl;

    return 0;
}
```
***
本来应该就这么结束了，但是在写这篇文章的时候发现还可以优化？

可以观察这段代码
~~~cpp
if(c1!=c2)
{
    if(!a[c1]) a[c1]=1,++ans;
    else ++ans;
}
~~~
我们发现无论这个字符之前是否出现过，答案都要$++$，所以，可以简化为
~~~cpp
if(c1!=c2) ++ans;
~~~
这样就不用$map$了（不要在意压行）

可是，似乎前一个写法会更快（$7ms$）？是评测姬的波动吗？
***
$The\space End$

---

## 作者：FLASH_CM (赞：3)

### 【题目大意】
Aron给他的朋友们买礼物后在礼物店排队，它的前面有n个人，但是它发现有些人实在等待他的朋友而并非在排队买单，并且我们可以认为站在一个人后面的朋友都穿着匹配颜色的衬衫，而两个相邻的群体、相邻的个人或相邻的个人和一个集体将永远不会穿着相同颜色的衬衫。

编写一个程序，给定排队的人所穿的衣服的颜色，输出Aron在第多少位？
### 【算法介绍】
我们从第一个人枚举开始，如果他的衣服的颜色和前一个人相同，则跳至他的后一个人，否则，将答案数+1。最后在输出答案的时候再加上Aron自身即可。
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int i,j,k,m,n,ans=0;
	char s,r='+';
	scanf("%d",&n);
	for(i=1;i<=n;i=-~i){
		cin>>s;
		if(s==r)
			continue;
		else{
			r=s;
			ans++;
		}
	}
	printf("%d",ans+1);
	return 0;
}
```

---

## 作者：小粉帽 (赞：3)

这一道题洛谷才刚出来，我就该写题解了。
首先题目很复杂，有时候会把你的脑子搞乱，因此我给大家推荐一个方法：直接看样例，也许能看出名堂。~~或者是打开题解把firtom383466的代码抄下来。~~
#### 下面我来给大家解读一下：
题目让我们做的是，看看输入的样例字母中，有多少符合要求字母（其中并列的几个算一个字母）下面上代码↓
```pascal
var n,i,ans:longint; ch,chr:char;
begin
  readLN(n);//必须要+ln，不然回车会算一个字符
  for i:=1 to n do
    begin
      readln(ch);//这里也是
      if ch<>chr then//判断和上个字母是否相同
        inc(ans);
      chr:=ch;//将上一个字母统计到chr变量中
    end;
  write(ans+1);//因为要你求排在第几位，所以答案要+1再输出
end.
```
所有~~药店~~要点全在上面。感谢大家看到最后。望过


---

## 作者：SS003 (赞：2)

说实话,这道题唯一的难点就在输入字符时换行符的处理

那么怎么处理呢?

这里有一个方法:
```cpp
char a[2];
scanf("%s",a);
//scanf("%s")在读入字符串时会在读入空格或换行符时停止读入
//题目要求读入单个字符,且每行读入一个
//那么这下就好解决了
//读入每一个字符时和前一个字符比较,不同的话ans++
//最后ans+=1
```
换行符的问题就解决了

------------

代码如下:
```cpp
#include<cstdio>
using namespace std;
  long long n,i,ans=1/*自增*/;
  char a[2],b='0',c;
int main(){
  scanf("%lld",&n);
  for(i=1;i<=n;i++){
    scanf("%s",a);/*读入*/
    if(a[0]!=b){ans++;}/*比较字符*/
    b=a[0];/*交换*/
  }
  printf("%lld",ans);/*输出结果*/
return 0;
}
```
希望这篇题解能帮助到你.

---

## 作者：AzurIce (赞：2)

# 魔改快速读入

> 题意：颜色和前面挨着的人一样的话就不算人，求有多少人+1（因为Aron站在队尾）

[传送门](https://www.luogu.com.cn/problem/P4439)

&emsp;既然有个高性能标签，那我就魔改下快速读入就好了，多开个char来存前面挨着的人衣服颜色。
在过程中发现相同的话就把整个队伍里面的人数量减一 ~~（因为那个人就不算人了）~~
最后输出答案加1就好了。（可惜数据数量太少了，体现不出来速度的飞跃）

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;

int main(){
	int n;
	char prec,c;
	cin>>n>>prec;
	for(int i=n;i>1;i--){
		while((c=getchar())<'A' || c>'Z');
		if(c == prec)	n--;
		prec = c;
	}
	cout<<n+1;
	return 0;
}

```

水一波，轻喷


---

## 作者：封禁用户 (赞：2)

### 题意：
把前后字符相同的视为一个“~~朋友圈”~~，他们身上的衣服就是“~~朋友圈”标志~~，统计一共有多少个“~~朋友圈”~~，答案就是统计数$+1$。

### 思路： 
一个一个读，用$a$记录当前的人属于的“朋友圈”，$b$记录前一个的“朋友圈”字符。判断两种情况，然后将 $a$ 赋值给 $b$ ，初始化 $a$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int ans=0,n;
	char a=' ',b=' ';
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		if(a==b) continue;
		ans++;
		b=a,a=' ';//初始化与赋值
	}
	cout<<ans+1<<endl;//输出答案
	return 0;
}
```

*这里有一个坑点：读入包含的是Aron以前的人，**不包含Aron！！***

---

## 作者：按Ctrl加A会AC (赞：2)

# 目录：
- ## 理解题目
- ## 题目考察分析
- ## 完整代码

❶ ：
## 重新带大家理解一下题目
这题的题意好乱，本蒟蒻读了好几遍题都没看懂<(￣ ﹌ ￣)>  
本题题意有几个重点：

1. ~~Aron在礼物店排队~~  排队的人有的是在等朋友，不会买单
1. 一起的人穿同样衣服
1. 输入的是在Aron前面排队的人！！（我的大坑）
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓（左为我的心理阴影面积）


~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~华丽的分割线~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

❷ ：

接下来，！铛铛 ！
## 分析！！
1. 这个题目规定 :  The first line of input contains the positive integer  _**N (1 ≤ N ≤ 25)**_  from the task.（n为人数）

我们需要定义一些字母（颜色），所以开个字符型数组吧！

这样呢，保险起见，开大点，我们先开50个~~房间~~。
    
   
上代码！

```cpp
#include <bits/stdc++.h>

using namespace std ;

char a [50] ; // 本蒟蒻较懒，因在主函数外定义变量，变量自动清零，So，在这里定义一个数组~~

int main (){
```
2. 阅题发现，本题还需定义一个排在Aron前面的人数n，和一个计数器ans（answer）。同样，先上代码
```cpp
#include <bits/stdc++.h>
using namespace std ;
int n ，ans ; //新建Aron前排队人数n，和计数器ans，为清零，在主函数外定义。
char a [50] ;
int main (){
	cin >> n ; //输入的第一行n（人数）
```
哇！我们的所有变量就这样定义完啦！

3. 数组的输入，一般都要用循环输入哦 ~~ 这个还是很简单的，上代码看看吧
```cpp
	for (int i = 1 ; i <= n ; i ++){
		cin >> a [i] ;
	}
```
4. 下面就是本题~~唯一~~需要思考的地方了！！

#### ！！！当当当！！！
我们要做的就是判断一下，总共分为几个小组，+1就是我们可爱的答案；当然，我们可以把ans直接定义成1，这样就不用+1惹~~

具体如下：
```cpp
	for (int i = 1 ; i <= n ; i ++){ //循环来判断
		if (a [i] != a [i + 1]){ //判断前后两个TA衣服颜色是否相同，若相同，ans + 1。
			ans ++ ;
		}
	}
	cout << ans + 1 ; // 因ans统计的是Aron前排队的人数，而题目要问的是Aron排在第几位，所以要+1
	return 0 ;
}
```
❸ ：

什么也不说了，直接上完整代码说话


```cpp
#include <bits/stdc++.h>
using namespace std ;
int n ，ans ; //新建Aron前排队人数n，和计数器ans，为清零，在主函数外定义。
char a [50] ;
int main ()
{
    cin >> n ; // 输入的第一行n（人数）
    for (int i = 1 ; i <= n ; i ++){
        cin >> a [i] ;
    }
    for (int i = 1 ; i <= n ; i ++){ //循环来判断
        if (a [i] != a [i + 1]){ //判断前后两个TA衣服颜色是否相同，若相同，ans + 1。
            ans ++ ;
        }
    }
    cout << ans + 1 ; // 因ans统计的是Aron前排队的人数，而题目要问的是Aron排在第几位，所以要+1
    return 0 ; // 好习惯要养成哦
}

```
大功告成！！

第一次发题解，请各位奆佬多多指教，Orz......

~~求过~~

---

## 作者：dghcs (赞：2)

# 这是我的第一篇洛谷题解
## 希望以后的日子里再接再厉
```cpp
#include<iostream>
using namespace std;

char line[100];
int n,count = 1;
int main()
{
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> line[i];
		if(line[i] == line[i-1])
			continue;
		else
			count++;
		
	}
	cout << count;
	
 } 
```
一道水题；

---

## 作者：philosopherchang (赞：2)

怀疑有人恶意评难度；

直接看看输入的和前面的一不一样就行，不一样就+1；
最后输出ans+1;

AC代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int ans,n;
char a[10001];
int main()
{ 
	std::ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(a[i]!=a[i-1])
		ans++;
	}
	cout<<ans+1;
}
```

---

## 作者：智子·起源 (赞：1)

## 超级搞笑的程序!
新手也超容易理解^_^
```cpp
#include<iostream>
using namespace std;
int main(){int n,ans=2;char a[25];cin>>n;//定义+读入
for(int i=0;i<n;i++){cin>>a[i];if(i>0&&a[i]!=a[i-1])++ans;}//执行
cout<<ans;return 0;}//输出+结束
```
还是讲一下执行操作吧。根据题目可以提取出一个非常重要的意思：

### 等待的人都是穿着相同衣服而且位置相邻。

所以，我们只要找到有多少对位置相邻且衣服不同的两个数，再把统计个数加2输出即可！（在买单的人数+它本身1的位置=2）

再来欣赏一下那美丽的代码：
```cpp
#include<iostream>
using namespace std;
int main(){int n,ans=2;char a[25];cin>>n;
for(int i=0;i<n;i++){cin>>a[i];if(i>0&&a[i]!=a[i-1])++ans;}
cout<<ans;return 0;}
```


---

## 作者：Ryo_Yamada (赞：1)

题目（自己简化了一下，希望能帮到大家）：

n个人，其中连续的m个人如果衣服颜色一样，就算做1个人。

最后求Aron在第几位。

请出代码君：

```cpp
#include <iostream>
using namespace std;
char c;//记录上一个人的衣服颜色
int main(){
    int n;
    cin >> n;//总人数
    int cnt = n + 1;//记录Aron在第几个，注意是n + 1
    for(int i=0; i<n; i++){
        char ch;//第i个人的衣服颜色
        cin >> ch;
        if(ch == c)cnt--;//如果和上一个一样，总人数--
        c = ch;//记录衣服颜色
    }
    cout << cnt;//输出
    return 0;//完结撒花
}

```
个人思路，希望能帮到大家。

最后祝大家AC此题

---

## 作者：bigbigdoggy (赞：1)

### 蒟蒻第一遍看时表示题目没看懂


##### 发一波简洁一点的翻译


------------
~~假期快到了！Aron想给在朋友买礼物，他去了伦敦的一家著名的玩具店。~~
挑选完礼物后，他到收银台，发现已经有N个人在排队。幸运的是，他注意到除了个别顾客之外，还有一群人排队。

同一群人穿着编号一样的衬衫。不是同一群人穿着编号不一样的衬衫

编写一个程序，如果给出排队人员的数据，将输出Aron是第几。

```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
int main()
{
	int a,ans=0;
	char b[1001];
	cin>>a;//就不用scanf 
	for(int i=1; i<=a; i++)
	{
		cin>>b[i];
		if(b[i]==b[i-1])//如果和前面的人颜色相同，答案不改动 
		{
			continue;
		}
		else//如果不同就代表两个群体，答案加一
		{
			ans++;
		}
	}
	cout<<ans+1<<endl;//此处有坑，Aron的位置要加一
	return 0;
}
```


---

## 作者：兀pai (赞：1)

一道水题，只要会一点字符串和AC了P10001我觉得就可以理解我的做法

先看一下代码：
```cpp
#include<iostream>
#include<string>
using namespace std;
int n,sum=1;
string a[200];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]!=a[i-1]) sum++;
	}
	cout<<sum;
	return 0;
} 
```

废话不多说

因为题目说如果当前的这一个人和前一个人穿的一样那就可以当他是空

气，所以 if(a[i]!=a[i-1]) sum++; 判断和前一个是不是一样的，一样的就sum++

还有就是sum的初值一定要是1，因为如果n=1的话如果sum的初始值为0

那输出的结果是0，但题目要求输出排在第几位，所以sum初值要定为1

求通过，欢迎来主页加qq（逃

---

## 作者：dbxxx (赞：1)

# 这道题真的太良心了！  
1. 数据范围良心:`N<=25`  
2. 给的样例多，有`3`个
3. 思维难度应该算低了，编码难度也不高

好了步入正题。
首先先写头文件,命名空间：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
```
其次是变量：  
注意到`N<=25`，我们的数组应该取大小为30（防爆+5原则）  
并且注意颜色是字符而不是整数，应该用`char`
```cpp
int n;
char a[30];
```
然后就到我们的主函数了。首先输入`n`：  
```cpp
int main()
{
	scanf("%d",&n);
```
接着输入数组。注意！（血的教训），**输入字符必须用`cin`**！  
因为用`scanf`会有一些关于换行的输入问题，导致`wa20`[。。](https://www.luogu.org/record/22518549):)
```cpp
	for(int i=0;i<n;i++)
		cin>>a[i];//输入每一个人的衬衫颜色
```
接下来就是重头戏了。  
首先先判断当前衣服的颜色**是否和前一个相等**。为了保证**数组不越界**造成一片`purple`，我们要先判断是不是**第一个数**，保证进行前一个数的访问时不会`segment fault`。这里根据我的习惯，数组的第一个下标为`0`，利用这个特性，**如果`i`为真说明不是第一个数**，就可以进行前一个数的访问了。  
废话有点多，总之如果**当前衣服颜色和前一个相等**，说明当前人和前一个人穿~~同一条裤子~~**同一个颜色的衣服,也就是等前面那个人**，这种人不用理他，`continue`走你！  
但是如果前面那个人就是去买~~伦敦~~东西的，**我们就得进行`ans`的自增咯**
```cpp
        for(int i=0;i<n;i++)
        {
                if(i&&a[i]==a[i-1]) continue;
                ans++;
        }
```
愉快的手工阶段，`return 0`，完事！  
~~愤怒的吃瓜群众：诶诶诶你还没输出了你这个菜鸡快给我回来！！！~~  
愉快的输出`ans`：
```
		printf("%d\n",ans);
```
然后就`wa`声一片了？  
哦！对。小学~~文化课~~老师讲过，一个人前面有多少个人（此题中为集团），他就是第`几+1`位。在这里`ans`是`Aron`前面的集团数，自然要输出`ans+1`.  
所以是这样子的：  
```
		printf("%d\n",ans+1);
```
然后？然后就没啥了。愉快的手工阶段，`return 0`，完事！（我承认我是复制我前面那句话的）  
好的，最后总结一下这些零零碎碎的片段，`AC`程序就浮出水面啦！

```cpp
//头文件
#include <iostream>
#include <cstdio>
//宏定义

//命名空间
using namespace std;
//变量
int n,ans;
char a[30];
//结构体+typedef

//函数

//主函数
int main()
{
    //取消同步+初始化

    //输入
    scanf("%d",&n);//输入n
    for(int i=0;i<n;i++)
    	cin>>a[i];//输入每一个人的衬衫颜色
    //算法
    for(int i=0;i<n;i++)
    {
            if(i&&a[i]==a[i-1]) continue;//如果不是第一个并且当前值=前一个值，
            //说明这个人和前面那个人穿同样的衣服，则不进行ans自增（他是等人的
            //ans自增干什么，浪费表情。）
            ans++;//说明当前的不是等人的，则进行ans自增
    }
    //输出
    printf("%d\n",ans+1);//输出啦~
    //结束
    return 0;
}
```


---

## 作者：Heap_Sort (赞：1)

其实是一道非常简单的题

题目要求实际上有几个人在排队，也就是在求 _某个位置的字母不等于它的前一个字母的字母个数_ （因为如果某个位置的字母等于它的前一个字母，那就意味着这两个人属于同一个团体，数量不增加）。

那就很简单了。

注意事项：
1、要求排在第几位，所以是排队的人数+1。2、数组要从0开始，否则在判断第一个字母的时候就会越界。

代码很简单啦

我是个P党人QAQ

```pascal
var 
  s:array[0..25] of char;
  n,a,b:longint;
begin
  readln(n);
  for a:=1 to n do 
   begin 
    readln(s[a]);
    if s[a]<>s[a-1] then b:=b+1;
   end;
  writeln(b+1);
end.
```
谢谢大家看到最后

---

## 作者：炎19520 (赞：1)

对于我这一个一个~~蒟蒻而又怕麻烦还只想刷水题的~~人看到这个题目来自coci比赛后被吓了一跳，点开后······Harry欢呼ヾ(@^▽^@)ノ来，开始刷吧！（因此本题解专为蒟蒻打造）
这道题也是一道水坑水坑的坑水题。但是呢？有两个坑点，漏一个就听WA声一片了。
好了，上个代码吧。
```
#include<bits/stdc++.h>//防伪标志 
using namespace std;
int main(){
    int n,ans=1;//坑点之一，ans初始量1
    //其实本来用的是sum，表示人数总和，但看到好多人都用了ans，我也随一下时代吧
    char b;//不要问我为什么是b，只能告诉你a在后边
    cin>>n>>b;
    for(int i=2;i<=n;i++){
        char a;
        cin>>a;
        if(a!=b){
            ans++;//只有不同才加人数
            b=a;//标记一哈子变量
        }
    }
    cout<<ans+1<<endl;//坑点之二，ans要加一，不然成了前面有多少人在排队，而要求的是他是第几个
    return 0;
}
```




---

## 作者：世末OIer (赞：1)

来一发python3题解

```python3
n=int(input())
lst=input() //先读入一个
ans=2   //初始值为2！
for i in range(n-1):  //循环读入，注意已经读入了一个
    s=input()
    if s!=lst:     //与之前的不同
        lst=s    //更新
        ans=ans+1
print(ans)
```

---

## 作者：你锡白大爷 (赞：0)

###### 来自蒟蒻的投稿
#  _首先读题_ 
### 注：这是c++
进行一波对题目的简化：

**Aron** ~~给他的朋友们买礼物后在礼物店~~ **排队，它的前面有n个人，**

~~但是它发现有些人实在等待他的朋友而并非在排队买单，并且我们可以认为站在一个人后面的朋友都穿着匹配颜色的衬衫，而两个相邻的群体、相邻的个人或相邻的个人和一个集体将永远不会穿着相同颜色的衬衫。~~

**字母相同即视为同一集体**

**编写一个程序，给定**~~排队的人所穿的衣服的颜色，~~**一些字母(即颜色)，输出Aron在第多少位？**

那么题目就变成了：**Aron排队，它的前面有n个人，字母相同即视为同一 ~~群好基友~~ 个集体编写一个程序，给定一些字母(即颜色)，输出Aron在第多少位？**

是不是简洁多了？

那么我们就会发现：只要字母相同我们就可以把这坨人算作  **.一  .个  .人  ！！**



此不美滋滋乎？？

**好了,**~~水~~**说了那么多，该上代码了：**

```cpp
#include <bits/stdc++.h> //万能头万岁
using namespace std;
int main()
{
	long long n,ans=0; //n是人数，ans是结果(其实本来想用sum表示人数，不过现在大家都用ans那就跟紧潮流吧)
	cin>>n;
	char cl[n+2];//衣服颜色
	for(int i=1;i<=n;i++)
	{
		cin>>cl[i];
	}
	for(int i=1;i<=n;i++)
	{
		int j=i+1;
		if(cl[i]!=cl[j])//如果前后二人颜色不同（比如原谅绿和基佬紫？）
		{
			ans++;//答案加一
		}
	}
	ans++;//一定要加一！这是个坑
	cout<<ans<<"\n";
	return 0;
}
```

###### 此不为一水题乎？

---

## 作者：litaoyang2021 (赞：0)

对于一个~~爱刷水题的人~~看到这个比赛后被吓了一跳，害怕做不起，点开第四题······来，刷！
   ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main() 
{
int a,ans=1;
char c,b;
cin>>a;
cin>>b;
for(int i=2;i<=a;i++)
{
	cin>>c;
	if(c!=b)
	{
		b=c;
		ans++;
	}
}
cout<<ans+1;
	return 0;
}
```
这玩意很简单，诺
a代表的是判断总数。
b用来判断是否相等，如果是，ans不变。如果不是，ans++；c复制给b
最后记住+1才输出，否则就变成了前面有多少个人。
噢啦！


---

## 作者：SCP_233 (赞：0)

不多bb直接上代码
```cpp
#include<iostream>
using namespace std;
char a[25];//前面的人
int n;
int main()
{
	cin>>n;、、输入前面有几个人
	cin>>a[0];//输入第一个，一会判断用
	int x=n;//前面有几组人
	for(int i=1;i<n;i++)
	{
		cin>>a[i];//输入组数减一
		if(a[i]==a[i-1])x--;//如果和前一个一样，组数减一
	}
		 
	cout<<x+1;//因为是前面的组数，没算上Aron，所以加一
	return 0;//好习惯
}
```
第一次发，求过


---

## 作者：旅行者一号 (赞：0)

## 此题为~~水题~~

有可能大家看了翻译已经头昏眼花了，现在把翻译精简一下：

Aron在排队，他发现排队的人们是分成好多家庭的，当然，有些人是single dog，每个家庭看成一个人，问Aron排在第几位。

其实题目里相同颜色且相邻就是为一个家庭，稍加处理即可。

## 上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n,ans=1;   //由于下面的for循环判断是会把第一个人（家庭）漏掉，所以ans要初始化为1
    char a[30];
    cin>>n;
    for(int i=0;i<n;i++) {
        cin>>a[i];
    }
    for(int i=1;i<n;i++) {
        if(a[i]!=a[i-1]) {  //若不是同一个家庭（人），那么ans++
            ans++;
        }
    }
    cout<<ans+1<<endl;  //ans指的是Aron前面有多少个家庭（人），所以他排在ans+1位
    return 0;
}
```


---

## 作者：Died (赞：0)

发表一下个人的看法：

这个题目楼上大佬介绍了while（1）n++种方法，有达到了两次循环（第一次）的，也有一次循环时用一些神奇的函数判断的。


但仔细读一下这个题目，其实本没有那么难：因为我们只需判断后一个人是不是与前面的人穿一样的衣服就可以了，那么，我们只需开一个数组，再读入的时候判断一下是不是和前面的人的衣服颜色是不是一样就可以，然后结果+1输出就可以了，然后程序完美结束。

AC代码：

```cpp
#include<bits/stdc++.h>//建议比赛不要使用
using namespace std;
const int maxn=1000;//数组可以开大点，防爆

char a[maxn];
int ans,n;

int main(){
	std::cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		ans++;//先自增
		if(a[i]==a[i-1])ans--;
  			//如果和前面相同，自减操作
	}
	cout<<ans+1;//+1输出，排队嘛
	return 0;//完美结束……
}
```


---

## 作者：MZW_BG (赞：0)

提供一种并查集做法

~~本来想用珂朵莉树但是发现不会插入~~

每输入一个人就检查他/她和前面那个人的关系

如果他们有关系就把新的这个人并入前面那个人的集合（群体）当中

最后看有多少个群体，通过求根的个数实现

```cpp
#include<cstdio>
#include<cstdarg>
using namespace std;
namespace IO
{
	void _read(int *p)
	{
		int &x=*p;x=0;register char c=getchar();
		while(c<48||57<c)c=getchar();
		for(;48<=c&&c<=57;c=getchar()) (x*=10)+=c&15;
	}
	void read(int cnt,...)
	{
		va_list args;
		va_start(args,cnt);
		while(cnt--)
			_read(va_arg(args,int*));
		va_end(args);
	}
	void read(char &c)
	{
		do c=getchar();
		while(c<65||90<c);
	}
	void write(int x)
	{
		if(x/10)write(x/10);
		putchar(x%10|48);
	}
}
using namespace IO;
//输入输出优化
int fa[26];
int findfa(int x)
{
	return fa[x]==x?x:fa[x]=findfa(fa[x]);
}
int main()
{
	int n;read(1,&n);
	for(int i=1;i<=n;i++)fa[i]=i;
	char c,last=0;
	for(int i=1;i<=n;i++)
	{
		read(c);
		if(c==last)
			fa[i]=findfa(fa[i-1]);
		last=c;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
		ans+=(fa[i]==i);
	write(ans+1);
	return 0;
}

```

---

## 作者：computer_ (赞：0)

首先奉上AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,c;
    char a[35];
    cin>>n;
    c=n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=2;i<=n;i++)     //应为a[0]未赋值，所以从2开始
    {
    	if(a[i]==a[i-1]) c--;    //判断，如果相等就减去一
	}
	cout<<c+1<<endl;   //这里注意，题目描述很坑的
    return 0;
}

```

#### 思路

首先，找一个数赋值为n。
然后就一个一个判断，如果相等就减去1.



对了，记得看清题目（不要忘了最后再加上1）。

---


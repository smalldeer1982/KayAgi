# [AHOI2018初中组] 报名签到

## 题目描述

$n$ 位同学（编号从 $1$ 到 $n$）同时来到体育馆报名签到，领取准考证和参赛资料。为了有序报名，这 $n$ 位同学需要按编号次序（编号为 $1$ 的同学站在最前面）从前往后排成一条直线。然而每一位同学都不喜欢拥挤，对于第 $i$ 位同学，如果有另外一位同学距离他/她的距离小于 $a_i$，那么就会发生冲突。小可可想知道如果要不发生任何冲突的情况下，这 $n$ 位同学排队的队列最短长度是多少。

## 说明/提示

对于 $20\%$ 的数据满足：$1\le n\le 20$。

对于 $70\%$ 的数据满足：$1\le n\le 10^4$。

对于 $100\%$ 的数据满足：$1\le n\le 10^5$，$1\le a_i\le 10^5$。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
5```

# 题解

## 作者：醉梦未苏 (赞：71)

### 为什么没人用$python$ 

qwq

为$python$用户提供代码

> 这道题的思路如下

1. ans=0 //计数器设为0
2. $ans+=a[i]+a[i-1]$

```python
n=int(input()) #输入第一行
l=map(int,input().split(' ')) #输入第二行
lis=list(l)
ans=0 #计数器设为0
for x in range(1,n):
    ans=ans+max(lis[x],lis[x-1]) #思路第二步
print (ans) #输出
```

> 求过,求赞

---

## 作者：Ares゜ (赞：56)

#### 一道简单的初中组的题(~~连我这个蒟蒻都一次就AC了~~)
好了，我们来梳理一下本题的思路
输入每个人的距离，比较一下相邻两人的距离，选最大就行了
## 上代码
```
#include <bits/stdc++.h>//万能头
using namespace std;
int a[100001];
int main()
{
	long long n,dis=0;//初始化dis为0
	cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    for(int i=1;i<=n-1;i++)//这里循环到n-1，因为最后一个人后面已经没有人了，因此不用算
    {
    	if(a[i]<=a[i+1])//比较大小
    	{
    		dis+=a[i+1];//总距离累计
    	}
    	else dis+=a[i];
    }
    cout<<dis;//输出
    return 0;
}
```
#### 本蒟蒻的第八篇题解，如有不足之处请各位大佬指正


---

## 作者：LanrTabe (赞：36)

每两个数中加大的那一个，除了long long之外~~就~~没有坑了，没有n=1的数据

上代码，极致压行，你值得拥有

```cpp
#include <bits/stdc++.h>
int main(int n,int a[2],long long d)
{
    for(d=0,scanf("%d",&n),scanf("%d",&a[n&1]);;scanf("%d",&a[n&1]),d+=std::max(a[0],a[1]))if(!--n)return printf("%lld\n",d),0;
}
```

---

## 作者：Goashore (赞：10)

题目描述
n 位同学（编号从1 到n）同时来到体育馆报名签到，领取准考证和参赛资料。为了有序报名，这n 位同学需要按编号次序（编号为1 的同学站在最前面）从前往后排成一条直线。然而每一位同学都不喜欢拥挤，对于第i 位同学，如果有另外一位同学距离他（她）的距离小于a[i]，那么就会发生冲突。小可可想知道如果要不发生任何冲突的情况下，这n 位同学排队的队列最短长度是多少。

输入格式
输入有两行：

第一行一个整数n，表示报名签到的同学人数。
第二行有n 个整数，第i 个整数a[i]表示第i 个同学必须与其他同学保持的距离。

输出格式
输出一行，包括一个整数，表示这n 位同学排队队列的最小长度。

注意：n 位同学要按1~n 的次序从前往后排队。

输入输出样例：

输入

3

3 1 2

输出 

5

说明/提示：

对于20%的数据满足：1≤n≤20；
对于70%的数据满足：1≤n≤10000；
对于100%的数据满足：1≤n≤100000，1≤a[i]≤100000。


# 千万不要用int！用longlong！
### 上代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005],a1,a2;
int main()
{
	cin>>a1;
	for(int i=0;i<a1;i++)
	cin>>a[i];
	for(int i=1;i<a1;i++)
	{
		a2+=max(a[i],a[i-1]);
	}
	cout<<a2;
	return 0;
}
```


---

## 作者：Misaka19280 (赞：8)

初中组第一题越来越简单了QAQ（太棒了）

这题不用多想，两个数如果不打架，肯定要选里面最大的，选了最小的就打起来了

所以就很明了了，i从1到n-1循环，ans每次加上两个数之间大的

和楼上不同，用的变量滚动，不用开数组

开qword(c++ longlong)，不然会爆范围

```
Var
	ans:qword;
	n,i,x,y:longint;
	
Function max(x1,y1:longint):longint;
begin
	if x1>y1 then exit(x1)
		else exit(y1);
end;

Begin
	read(n);
	read(x); //用两个变量滚动，就不用开数组了
	ans:=0;
	for i:=1 to n-1 do
		begin
			read(y); //每次读入
			ans:=ans+max(x,y); //选最大的
			x:=y; //滚动
		end;
	writeln(ans);
End.
```

---

## 作者：hibiscus_wu (赞：7)

## 十分重要的一点：不要用int！！！
#### 这道题因为只需要比较两个人之间的距离，所以可以用滚动数组来节省空间，下标模2。

### 上代码
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long a[2],n,sum,tmp;
    cin>>n;a[0]=a[1]=0;
    cin>>a[0];
    for(int i=1;i<n;i++){tmp=i%2;cin>>a[tmp];sum+=max(a[0],a[1]);}
    cout<<sum<<endl;
    return 0;
}
```


---

## 作者：Lithium_Chestnut (赞：3)

P4445 【[AHOI2018初中组]报名签到】（题解）

果然是初中组$T1$难度，思路很简单。

数据范围很大，一定要使用$long$ $long$。

这里要运用到$max$函数：

```cpp
ans+=max(a[i-1],a[i]);
```

这句话的意思是：把$a$的第$i$位（当前循环走到的位数）与其前一位比较，较大者的值会被加到$ans$当中。

题解中有注释，可以参考注释学习。

## $Code:$

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;//命名空间 
long long a[100001],n,ans;//定义用long long 
int main()//主函数 
{
	cin>>n;//读入n
	for(int i=1;i<=n;i++) cin>>a[i];//读入a[i]，a的每一位 
	for(int i=2;i<=n;i++) ans+=max(a[i-1],a[i]);//循环从2开始，比较 
	cout<<ans;//输出答案 
	return 0;//程序结束，返回0 
}
```


---

## 作者：liuzimo (赞：3)

# 这道题十分的简单
### 主要就是注意数组的大小
### 还有存储要用（long long）
#### 主要思想就是把每个人所需要的距离取最大就好了
#### 上代码
```
#include <iostream>
using namespace std;
int a[100005];
long long t=0;
int main(int argc, char** argv) {
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		t+=max(a[i],a[i+1]);
	}
	cout<<t;
	return 0;
}
```
求过......

---

## 作者：484A51 (赞：2)

## 这题超简单的。
#### 我当时也一下子就做出来了。循环跑一遍，找出相邻两人的必须与其他同学保持的距离，比较大小，再用累加器加上大的，最后输出大的就可以了。（^。^)

------------
```
#include <iostream>
using namespace std;
int a[100001],n;
long long s;//注意！！！满满的坑
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
	}
	for(int i=2;i<=n;i++){
		s+=max(a[i],a[i-1]);//哪个大就加哪个
	}
	cout<<s;
    return 0;
}
```


------------
##### 就这样啦！(^。^)

---

## 作者：医保卡混社会 (赞：2)

不难啊。。很水的一道题
从题目不难看出，要求的就是所有相邻两个数中最大值的总和（~~这些个人真矫情~~
好吧。。我觉得我的程序还是算快的。（~~虽然没有必要优化，但是我还是用我的方式改了一下，只要遍历一遍就行了~~）
------------代码在这
）
```cpp
#include<iostream>
using namespace  std;
long long int sum;
int a[100000],n,i;//全局变量无所谓了，个人习惯
int main()
{
cin>>n;
cin>>a[0];//先输入一个，以便下面直接比较大小
for(i=1;i<n;i++)
{cin>>a[i];sum+=max(a[i],a[i-1]);}//输入同时计算
cout<<sum;
return 0;
}
```
蒟蒻第一次写题解。。各位大佬神仙欢迎打击本蒟蒻。。。

---

## 作者：meyi (赞：2)

# 刚参加完AHOI2018初中组只得了170分的蒟蒻前来报到~~并装大佬~~
## 很简单的一道题，只需要判断这个数和后一个数哪一个数大，并用累加器加上就行了
## ~~（PS：数据有坑，要用long long，这也是很多童鞋70分的原因）~~
### 废话不多说，上代码
```cpp
#include<cstdio>
main(){
    long long a,b,n,m=0;//定义变量
    scanf("%lld%lld",&n,&a);//获取总签到人数和第一个距离
    while(--n){		//由于已得到一个距离，所以只需要再输入n-1个距离
        scanf("%lld",&b);
        m+=a>b?a:b;//判断并累加
        a=b;		/*因为要与后一个数的后一个数比较，
    }   			所以后一个数就变成了前面的数*/
    printf("%lld",m);//输出（划掉后面的）并完结撒花
}
```
###### ~~我的代码中有改动，Ctrl+C Ctrl+V的就等着CE吧hhhhhhhhhh~~

---

## 作者：Lpy_Now (赞：1)

退役老年人高考完复习从零开始做做简单题
这道题思路很简单就是几个人排队两人之间的间距要大于两人所能忍受的最大值，求这个总长度
那么模拟一下样例
3
3 1 2(用 * 表示距离)
1 *** 2 ** 3
所以总长度为5
总共要判断n-1个间隔
先看一下代码
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

inline int read(){
    int f=1,num=0;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0' && ch<='9'){
        num=num*10+ch-'0',ch=getchar();
    }
    return num*f;
}
inline void out(int x){
    if(x>=10){
        out(x/10);
    }
    putchar(x%10+'0');
}

int main(){
    int lenth=0,behind,n=read(),before=read();
    for(int i=0;i<n-1;++i){
        behind=read();
        if(before>=behind){
            lenth+=before;
        }
        else{
            lenth+=behind;
        }
        before=behind;
    }
    out(lenth);
    return 0;
}
 
```
这里我复习的时候用了快读快输，新手没必要用直接cin cout等等就好
首先before代表前一个人能接受的最小距离，behind代表后一个人能接受的最小距离
只需要两个就可以代替全部，不需要开数组节省空间(虽然没有节省的必要qwq)
先输入n和before在再循环里输入behind比较哪个更大一点加到lenth上
之后将behind赋值给before再次读入behind
由于只有n-1个间隔所以循环从不0到小于n-1就好
记得开long long第一次提交就是因为没开longlong所以七十
这是唯一的一个坑点

---

## 作者：peiyangsong (赞：1)

# P4445 报名签到 #
## 题目描述 ##


n 位同学（编号从1 到n）同时来到体育馆报名签到，领取准考证和参赛资料。为了有序报名，这n 位同学需要按编号次序（编号为1 的同学站在最前面）从前往后排成一条直线。然而每一位同学都不喜欢拥挤，对于第i 位同学，如果有另外一位同学距离他（她）的距离小于a[i]，那么就会发生冲突。小可可想知道如果要不发生任何冲突的情况下，这n 位同学排队的队列最短长度是多少。

## 输入输出格式 ##
### 输入格式 ###
输入有两行：

第一行一个整数n，表示报名签到的同学人数。

第二行有n 个整数，第i 个整数a[i]表示第i 个同学必须与其他同学保持的距离。

### 输出格式 ###
输出一行，包括一个整数，表示这n 位同学排队队列的最小长度。

注意：n 位同学要按1~n 的次序从前往后排队。

### 输入输出样例 ###


输入样例#1： 

3

3 1 2

输出样例#1： 

5

## 数据范围 ##
对于20%的数据满足：1≤n≤20；

对于70%的数据满足：1≤n≤10000；

对于100%的数据满足：1≤n≤100000，1≤a[i]≤100000。


## 程序 ##

    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    const int N=110000;
    
    long long n/*人数*/,a[N],x; 
    
    int main(){
    	
    	//读入 
    	scanf("%lld",&n);
    	
    	for(long long i=1;i<=n;i++){
    		
    		scanf("%lld",&a[i]);
    		
    	}
    	
    	//取每两人间距最大值相加 
    	long long ans=0;
    	for(long long i=1;i<=n-1;i++){
    		
    		if(a[i]<=a[i+1]){
    		
    			x=a[i+1];
    			
    		}else{
    			
    			x=a[i];
    			
    		}
    		
    		ans+=x;
    		
    	}
    	
    	//输出 
    	printf("%lld",ans);
    	
    	return 0;
    	
    } 


## 算法 ##


## 注意 ##

数据范围较大，需用**long long类型**


2019/6/26 10:26:57 

---

## 作者：Null_yc (赞：1)

不知道用动态分配数组会不会稍微小一点?

弱弱地上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
long long sum=0;
int *pa;

int mmax(int *a,int *b)
{
	++b;
	return *a>*b?*a:*b;
}

int main() {
	cin>>n;
	int *a;
	pa = new int[n];
	a=pa;
	for(int i=0; i<n; i++)	
	{
		cin>>*pa;
		++pa;
	}
	pa=a;
	
	for(int i=0;i<n-1;i++)
	{
		sum += mmax(pa,pa);
		++pa;
	}
	cout<<sum;
	system("pause");
	return 0;
}
```


---

## 作者：AAAking (赞：1)

#### 嗯，确实是一道水题 ~~不过第一遍本蒟蒻还是WA了三个点~~


------------

## 这道题从题面来理解，就是给你一串数，累加相邻两个数中较大的。

#### 嗯，大概就是这样 

#### 下面上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,a,b;
long long ans;//注意数据范围，要用 long long

int main(){
    scanf("%d",&n);
    b=0;
    for (int i=1;i<=n;i++){
        scanf("%d",&a);//一个不用数组的好方法，因为累加的值只与之前一个数有关
        if (b!=0) ans+=max(a,b);//取最大累加 Tip:因为不用数组，第一个不加
        b=a;
    }
    printf("%lld\n",ans);//注意printf输出是要用"%lld"，第一遍就被这个卡了
    return 0;
}
```

---

## 作者：konglk (赞：0)

不光这道题名称与签到有关，这也真心是一道签到题

除了要开long long大家应该没有其他地方会错了吧

代码以及思路
```cpp
#include<iostream>
using namespace std;
int main(){
	long long n,b,l,c=0;//b代表前一个，l代表后一个，c记录长度
	cin>>n>>b;n--;//因为已经输入了一个了，所以要减一
	while(n--)
	{
		cin>>l;
		c+=max(b,l);//一定要加上两个人之间那个要求最高的，不然只能满足一个人的要求
		b=l;//后一个也变成前一个了
	}
	cout<<c;
	return 0;
}
```


---

## 作者：sparky_ (赞：0)

#### 这道题其实很简单，为了让相邻的两个同学不打架，他们的距离就选max(a[i],a[i]+1)。
### 但是，请注意！！！
```
说明/提示
对于20%的数据满足：1≤n≤20；
对于70%的数据满足：1≤n≤10000；
对于100%的数据满足：1≤n≤100000，1≤a[i]≤100000。
```
#### 100000 * 100000 = 10000000000
#### 而10000000000>2147483647。
#### 所以
### 一定要开long long！！！

#### 所以代码就是这样的：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,a,b,ans=0;//long long!
	cin>>n>>a;//a相当于a[i] 
	for(int i=1;i<n;i++)
	{
		cin>>b;//滚动数组 ，b相当于a[i+1] 
		ans+=max(a,b);//ans加上相邻两数的最大值 
		a=b;//交换a[i]和a[i+1] 
	}
	cout<<ans<<endl;//养成好习惯，输出回车 
	return 0;//结束 
}
```



---

## 作者：Died (赞：0)

看到这个题目后，第一感觉（~~哇，这是个神马题，这么长~~）

咳咳，仔细读了读，还可以吧，意思是：几个人在排队，两人之间的间距要大于两人所能忍受的最大值，并求出这个总长度。

于是我们开一个数组（~~应该不用解释吧TAT~~），用来记录每一次的距离，然后把最大的累加到ans就可以了，不过要从2开始累加，而且数据范围有点大，记得开long long，防爆。

AC代码：

```
#include<bits/stdc++.h>//建议比赛不要用
#define ll long long//宏定义，偷个懒……
using namespace std;
const int maxn=100005;//注意数据范围，最好大一点，不收钱

ll ans;//储存结果
int n,a[maxn];

int main(){
	std::cin>>n;//日常迷信：std::可以省时间
	for(int i=1;i<=n;i++){
		std::cin>>a[i];//读入
		if(i>=2)ans+=max(a[i],a[i-1]);//从2开始累加
	}
	cout<<ans;//一遍循环过后输出结果，结束
	return 0;
}

```
~~溜了……~~

---

## 作者：jinruihai_2006 (赞：0)

### 这道题其实很简单，但是很多人只有70分
- **因为100000*100000超了int范围所以要用long long。
- **其实也没什么思路就是S=0 //计数器设为0****
- **上代码**
```
#include<bits/stdc++.h>
using namespace std;
    long long S=0;
int n,i,j;
int main()
{
    int a[100001];
    cin>>n;
    for(i=1;i<=n;i++)
    {
    	cin>>a[i];
	}
	for(i=2;i<=n;i++)
	{
		S=S+max(a[i],a[i-1]);
	}
    cout<<S;
	return 0;   
}
```
#### 谢谢各位大佬对本人的关心！！！

---

## 作者：hmy521 (赞：0)

这道题看似简单，其实

## 有坑！！！

首先，数据范围超int，要开long int

其次，最后一个人只要考虑前面的人就可以了

### 思路：
这道题开一个数组，为每人只见必须有的间隔

然后，判断一下，如果后面的人规定的间隔比前面的小，就必须与前面的间隔相等

最后，相加，AC！

最后再给萌新推荐一个东西：define

用法：#define a b

在头文件下面加上即所有代码中的b都可以变成a~~（仅仅是装X用的）~~

望过

```
#include<bits/stdc++.h>
#define LI long int
using namespace std;
LI a[100005];
int main(){
	LI n,s=0;
	cin>>n;
	for (LI i=1;i<=n;i++){
		cin>>a[i];	
	}
	for (LI i=1;i<=n;i++){
		if (a[i]<a[i+1]){
			a[i]=a[i+1];
		}
	}
	
	for (LI i=1;i<n;i++){
		s+=a[i];
	}
	cout<<s<<endl;
	return 0;
}
```

些改一下，define只能将数据类型替换，如（longlong，int等）


---

## 作者：爱晚亭哦 (赞：0)

~~又来水题发题解了qwq~~

本题最大坑点就是;
# long long
还记得2018年普及组的第二题fight吗？

~~十年OI一场空，不开long long见祖宗~~

除此之外~~没啥~~坑点了吧..

~~其实真的挺水的~~

上代码啦

------------
```
#include<cstdio>
int n,a[100001];//其实局部变量也可以（建议用全局变量，只不过有时候变量会冲突） 
long long ans=0;//不开long long见祖宗~~ 
int main()
{ 
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    	scanf("%d",&a[i]);
    for(int i=1;i<=n-1;i++)
    {
        if(a[i]>a[i+1])//两种情况:要么本人的距离比较大，要么下一个人的比较大，谁大加谁 
            ans+=a[i];
        else
            ans+=a[i+1];
    }
    printf("%lld",ans);//输出 
    return 0;//好习惯呐 
}
```
求过那qwq

---

## 作者：尼古拉斯·柠檬 (赞：0)

得70分的原因：累加器爆int的范围了，反正我换long就可以了= =，java代码：

```
public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		br.readLine();
		String[] nums=br.readLine().trim().split(" ");
		long sum=0;
		for(int i=0;i<nums.length-1;i++){
			sum+=Math.max(Integer.parseInt(nums[i]), Integer.parseInt(nums[i+1]));
		}
		System.out.println(sum);
	}
```

---

## 作者：孤单光量子 (赞：0)

### 对于一个参加了省赛的蒟蒻来说，这题后三点简直是史诗级巨坑！！！
分析题目:

读入->累加->输出~~（好像并没有什么用）~~

#### ~~这题真的不算难，除了要开int64以外······~~

代码如下：
```
pascal
var a:array[1..100000]of longint;
	i,k,n:longint;l:int64;//累加器必须开int64
begin
    read(n);k:=0;l:=0;
	for i:=1 to n do read(a[i]);
	repeat//从头扫到尾
	inc(k);
	if a[k]>a[k+1] then l:=l+a[k] 
    else l:=l+a[k+1];//距离要满足大者的要求（是因为太胖了吗）
	until k>=n-1;
	writeln(l);
end. 
```

---

## 作者：Ofnoname (赞：0)

简单模拟，但是有坑。
```
#include <cstdio>
#include <queue>
#include <cstring>
#define max(a,b) (a>b)?a:b
//define 写小函数 
using namespace std;

const int MAX=100000;
int N,dat[MAX];
long long ans=0;
//本题最大坑，long long 才不会爆 

int main()
{
	scanf("%d",&N);
	for (int i=0; i<N; i++)
		scanf("%d",dat+i);
	for (int i=0; i<N; i++)
		ans+=max(dat[i],dat[i+1]);
	//每次+=距离要求更大的	
	ans-=dat[N-1];
	//最后一个人特判，他后面没有人 
	printf("%lld",ans);
	//printf也要改 
	return 0;
}
```

---

## 作者：翁睿 (赞：0)

正如题目的名称————“报名签到” 
这道题确实是道不太难的题目（~~但是有坑！！！！！！~~）
作为这次省赛的参加者，本蒟蒻只拿了70分，原因就是栽倒了 坑里
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<algorithm>
#include<map>
#include<cstring>
#include<cmath>
using namespace std;
int a[100005]; 
int main(){
	int n;
	long long ans=0;//数据是10^9，100000*100000超int了，所以要开long long 
	cin>>n;//读入人数 
	for(int i=1;i<=n;i++){
		cin>>a[i];//读入距离 
	}
	for(int i=1;i<=n-1;i++){//从i~i-1 
		if(a[i]>=a[i+1]) ans+=a[i];//比较a[i]和a[i+1]的大小 
		else ans+=a[i+1];//也可以直接写ans=max(a[i],a[i+1]) 
	}
	cout<<ans;//输出 
	return 0;
}
```

---


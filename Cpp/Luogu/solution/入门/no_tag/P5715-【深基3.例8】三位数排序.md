# 【深基3.例8】三位数排序

## 题目描述

给出三个整数 $a,b,c(0\le a,b,c \le 100)$，要求把这三位整数从小到大排序。

## 样例 #1

### 输入

```
1 14 5```

### 输出

```
1 5 14```

## 样例 #2

### 输入

```
2 2 2```

### 输出

```
2 2 2```

# 题解

## 作者：phigy (赞：221)

三位数排序，基础题目就不用说了

---

## 第一种方法

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int a[4];

int main()
{
    cin>>a[1]>>a[2]>>a[3];
    sort(a+1,a+4);
    cout<<a[1]<<' '<<a[2]<<' '<<a[3];
    return 0;
}
  
```
但这里利用了自带的排序函数

初学者不适合使用

## 第二种方法

正常的选择排序简化版

```cpp
#include <iostream>

using namespace std;

int main()
{
    int a,b,c;
    cin>>a>>b>>c;
    if(a>b)swap(a,b);
    if(b>c)swap(b,c);
    if(a>b)swap(a,b);
    cout<<a<<' '<<b<<' '<<c;
}
```
-----

学完这道题建议去学：

- 选择排序

- 冒泡排序

- 插入排序

# 感谢管理员审核！

---

## 作者：yuhaotian000 (赞：11)

## 【深基3.例8】三位数排序 题解
水爆了。
## 题目大意
给出三个数 $a,b,c$，然后将他们从小到大输出。
## 题目解法
今天我们要认识两个超级无敌好用的函数：`max` 函数与 `min` 函数。

`max` 函数：格式为 `max(a,b)`，意思就是求出 $a$ 与 $b$ 的最大值。

`min` 函数：格式为 `min(a,b)`，意思就是求出 $a$ 与 $b$ 的最小值。

所以，我们只需要用 $a,b,c$ 来表示出来最大值、中间值与最小值，就可以做出来了。表示直接见代码。

## AC code
```.cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int a,b,c;
	cin>>a>>b>>c;
	int sum=a+b+c;// 三数之和
    int minn=min(a,min(b,c));// 最后两数的最小值与第一个数比较，可以求出最小值
    int maxn=max(a,max(b,c));// 最后两数的最大值与第一个数比较，可以求出最大值
    cout<<minn<<" "<<(sum-minn-maxn)<<" "<<maxn;// 由于三数之和内肯定包含着最小值、最大值和中间值，只要把最小值、最大值减掉就是中间值了
}
```

---

## 作者：langmouren (赞：8)

# 三位数排序

# 方法一

慢慢交换排序，其过程可以意会，难以言传。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a,b,c;
    cin>>a>>b>>c;
    if(a>c) swap(a,c);
    if(a>b) swap(a,b);
    if(b>c) swap(b,c);
    cout<<a<<" "<<b<<" "<<c;
    return 0;
}
```

# 方法二

sort 排序。

sort 函数可以实现速度很快的排序，其复杂度最高为 $O(n \log n)$，是 STL 的一个非常好用的函数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a[3];
    cin>>a[0]>>a[1]>>a[2];
    sort(a,a+3);
    cout<<a[0]<<" "<<a[1]<<" "<<a[2];
    return 0;
}
```

# 方法三

大炮打蚊子——模拟退火。（非正解，写着玩的）

如果前者大于后者，则直接交换，否则按照概率公式以一定概率接受劣解。

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[4];

void SA(){
    double beginT=5000,endT=1e-6,k=0.998;

    for(int T=beginT;T>endT;T*=k){
        int x=rand()%3+1,y=rand()%3+1;

        if(x>=y) continue;
        
        if(a[x]>a[y]) swap(a[x],a[y]);
        else if(exp(a[x]-a[y])/T > (double)rand()/RAND_MAX) swap(a[x],a[y]);
    }
}

int main(){
    cin>>a[1]>>a[2]>>a[3];

    SA();

    cout<<a[1]<<" "<<a[2]<<" "<<a[3];
    return 0;
}
```

---

## 作者：swate114514 (赞：6)

题目要求我们把 $a,b,c$ 三个数按从小到大排序。

我们来认识一个好东西：
> sort 函数！

它使用方法如下：

我们设我们排序的数组为 $a$，排序区间为 $[l,r)$，且从小到大排序。则调用方法为：
```cpp
sort(a + l, a + r)
```

其中的两项分别表示需要排序的范围，通常是容器的起始迭代器和结束迭代器。

当然，还可以在 `sort` 的两项之后加上 `cmp`，自定义比较规则，如果不加则默认使用 `std::less<T>()`，即升序排序。

注意，如果要使用这个函数，你应该在头文件中加上 
```cpp
#include <algorithm>
``` 

如果我们不想从小到大排序，而是想从大到小排序，或者以其他方式进行排序，那么我们就应该写一个比较函数（一般命名为 `cmp`）来改变排序方法。

例如我们想要把一个类型为 int 的数组从大到小排序，我们应该这么定义这个比较函数：
```cop
bool cmp(int a, int b) {
	return a > b;
}
```

我们只需要定义两个与数组类型相同的变量作为参数，再返回两个数字的比较就可以了。

如果是从小到大排序，就用小于号连接两数；如果是从大到小排序，就用大于号连接两数。注意比较函数中的大于号、小于号不应改为大于等于号、小于等于号，否则会出现栈溢出等问题，导致意外的结果。

$Code$
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5;

int a[5];

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	for (int i = 1; i <= 3; i++) cin >> a[i];
	
	sort(a + 1, a + 3 + 1);
	
	for (int i = 1; i <= 3; i++) cout << a[i] << ' ';
	
	return 0;
}
```

---

## 作者：蒟蒻whker (赞：6)

绝世好题。
### 人类做法
首先，如果你是人类，就可以用 sort 解决。sort 是 STL 中方便快捷且常用的排序函数。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100005];
int main()
{
    int x=3；
  	for(int i=0;i<x;i++)
  	cin>>a[i];
    sort(a,&a[x]);//进行排序
    for(int i=0;i<=x-1;i++)
  	cout<<a[i]<<" ";
	return 0;
}
```
### 猴子做法
对于不会编程的猴子，人类准备了猴子排序。  
思路：如果数组未排好序，随机打乱数组，再判断是否排好序，如果排好序了，直接输出。
```
#include <bits/stdc++.h>
using namespace std;
int n,a[100005];
inline void random_(){
    for (int i=1;i<=n;i++)
    swap(a[i],a[i+rand()%(n-i+1)]);//随机打乱
}
inline bool check(){
    for (int i=2;i<=n;i++)
    if (a[i]<a[i-1]) return false;
    return true;//判断是否有序
}
inline void bogo_sort(){
    while (!check())//如果无序，继续打乱数组
    random_();
}
int main(){
    n=3;
    srand(time(NULL));
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    bogo_sort();//调用排序函数
    for (int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0;
}
```
请不要抄袭，因为你不是猴子。

The end.

---

## 作者：Peruere_Arlecchino (赞：6)

共二种方法。
### 方法一：直接排序法
利用编程语言内置的排序功能对三个数进行排序，这是最简单直接的方法。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    
    int numbers[3] = {a, b, c};
    sort(numbers, numbers + 3);
    
    cout << numbers[0] << " " << numbers[1] << " " << numbers[2] << endl;
    
    return 0;
}
```
先读取三个整数，再将三个数存入数组，最后排序输出。

### 方法二：条件判断法（不使用排序函数）
通过多次比较和交换，手动实现三个数的排序。
```cpp
#include <iostream>
using namespace std;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    
    // 确保a <= b
    if (a > b) swap(a, b);
    // 确保a <= c
    if (a > c) swap(a, c);
    // 确保b <= c
    if (b > c) swap(b, c);
    
    cout << a << " " << b << " " << c << endl;
    return 0;
}
```
首先比较 $a$ 和 $b$，确保 $a \leq b$。然后比较 $a$ 和 $c$，确保 $a$ 是最小值。最后比较 $b$ 和 $c$，确保 $c$ 是最大值。

求赞

---

## 作者：wst000 (赞：3)

# 思路
本题可以使用排序，但是本题为入门题，对初学者不太友好。所以我发一题解篇吧。我们发现如果 $a>b$，那么我们就要交换它们使得 $a<b$。那么如何交换呢？那我们就要用到一个临时变量 $t$ 了。我们先将 $t \gets a$，然后 $a \gets b$，最后将 $b \gets t$ 即可。代码如下：
```cpp
int t,a,b;
t=a;
a=b;
b=t;
```
再判断 $a>c$，$b>c$ 是否为 `true`。如果是，则交换。然后输出。这样我们就做完了。
# 正确性证明
我们对满足 $a>b$ 的 $(a,b)$，$a>c$ 的 $(a,c)$ 交换后，此时已经满足 $a \le b,a\le c$，那么 $a$ 已经为最小数，无需交换。然后我们对满足 $b>c$ 的 $(b,c)$ 进行了交换，此时满足 $a \le b,b \le c$，那么 $b$ 为第二小，$c$ 也满足 $a\le c,b \le c$，为最大数 ，此时已经满足 $a \le b \le c$，所以这个方法正确。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
ll a,b,c;
int main() {
	scanf("%lld%lld%lld",&a,&b,&c);
	if(a>b){//交换
		ll t;
		t=a;
		a=b;
		b=t;
	}
	if(a>c){//交换
		ll t;
		t=a;
		a=c;
		c=t;
	}
	if(b>c){//交换
		ll t;
		t=b;
		b=c;
		c=t;
	}
	printf("%lld %lld %lld",a,b,c);//输出
	return 0;//记得 return 0;，养成好习惯。
}
```

---


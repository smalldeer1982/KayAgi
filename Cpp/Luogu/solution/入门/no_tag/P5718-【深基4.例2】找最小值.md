# 【深基4.例2】找最小值

## 题目描述

给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。

## 说明/提示

数据保证，$n\le100$ 且 $0\le a_i \le 1000$。

## 样例 #1

### 输入

```
5
5 7 4 2 6```

### 输出

```
2```

# 题解

## 作者：2011hym (赞：13)

## 前言

大佬已经讲过打擂台的做法了，我就讲一下别的。

## 题意简述

给定一个长度为 $n$ 的序列，求序列中的最小值。

## 解题思路

这道题可以作为**排序算法**的入门题，以下内容是对排序的讲解：

### STL 排序

排序算法，[OI Wiki](https://oiwiki.com) 上这样说：

>排序算法（英语：Sorting algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。排序算法多种多样，性质也大多不同。

确实，排序分为很多种算法，在此题中我们选择 STL 中的排序算法，如下：

```cpp
//a[1] .. a[n] 为需要排序的数列。
//对 a 原地排序，将其按从小到大的顺序排列。
sort(a+1,a+1+n);
```

这种排序作为赛场上最常用的排序算法之一，可以将一个序列从小到大排序，时间复杂度为 $O(n\log n)$。

对于此题而言，我们就可以排序之后输出数组的第一个元素，即序列中最小值。

```cpp
#include<bits/stdc++.h>//万能头。
using namespace std;
int n,a[110];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+1+n);//排序。
    cout<<a[1];//输出最小值。
    return 0;
}
```

### 桶排序改装版

这种算法适用于数组中的数值域较小（在 $10^8$ 之内）寻找最小值、最大值和某数出现次数。

它的实现就是用一个数组存储所有数出现的次数。

假设出现了一个数 $x$，则对应 $x$ 的数组就加一。

这种方法可以在两次循环内完成，时间复杂度较优。

```cpp
#include<bits/stdc++.h>//万能头。
using namespace std;
int n,a[110],tong[1010];//tong 的大小就是 a 数组的值域。
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        tong[a[i]]++;
    }
    for(int i=0;i<=1000;i++){//a 的值域。
        if(tong[i]!=0){//找到第一个出现的数。
            cout<<i;
            return 0;
        }
    }
}
```

这里有个问题：如果这个数的值可能为负数，那数组开不了负数怎么办？

假设值域范围是 $-1000\le a_i\le 1000$，那么我们就可以整体加上**一千**，使其变成 $0\le a_i\le 2000$，在最后输出时减**一千**就可以了。

---

## 作者：HJH_2024 (赞：9)

# P5718 【深基4.例2】找最小值
[题目](https://www.luogu.com.cn/problem/P5718)
### 分析
题目给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。可以排序，排完后第一个就是答案（从小到大）（离线）或是定义一个变量输入一次判断一次（在线）。
### 代码
##### 排序做法

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[1005];
int main() {
	cin >> n;
	for (int i = 0; i < n; i++) cin >> a[i];
	sort(a, a + n);//c++自带排序函数
	cout << a[0];
	return 0;
}
```
##### 在线做法

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans = INT_MAX;
int main() {
	cin >> n;
	for (int i = 0; i < n; i++) {
		int a;
		cin >> a;
		ans = min(a, ans);
	}
	cout << ans;
	return 0;
}
```
##### 代风很丑，请见谅。

---

## 作者：Eason_cyx (赞：7)

可以用打擂台法来找最小值。

具体而言，可以按照以下步骤进行：

- 首先定义一个变量，表示当前的最小值，初始设为无穷大。

- 遍历每一个 $a_i$，和最开始那个变量进行「打擂台」，如果那个变量更小，$a_i$ 挑战失败，那个变量不变；否则，$a_i$ 挑战成功，那个变量的值变为 $a_i$。

这样就能得到最小值了。时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110];
int main()
{
    int n, minn = 1001;
    cin >> n;
    for(int i = 1;i <= n;i++) {
        cin >> a[i];
        //打擂台
        if(a[i] < minn) minn = a[i];
    }
    cout << minn << endl;
    return 0;
}
```

---

## 作者：yuxinrui0618 (赞：5)

# 题解：P5718 【深基4.例2】找最小值
## 1. 题目大意
- 找到一串数中的最小值。

## 2. 思路
- 边输入边判断该数是否比前面的数中的最小值还小；
- 输出答案即可；
- 注意因为 $0 \le a \le 1000$，所以初始值设为 1000 以上的数。

## 3. 代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,x,Min=1001; //初始值要比1000大
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>x;
		if (x<Min) //判断是否比Min还要小
			Min=x;
	}
	cout<<Min;
    return 0;
}
```

## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：一扶苏一 (赞：4)

# P5718 【深基4.例2】找最小值

## 分析

要得到 $n$ 个数里的最小值，可以维护一个变量 $\mathrm{ans}$，初始值为一个很大的数。然后读入 $n$ 个数，每读入一个数 $x$ 后，把当前的 $\mathrm{ans}$ 和读入的 $x$ 的较小值赋值给 $\mathrm{ans}$。

通过这样的「打擂台」，最终 $\mathrm{ans}$ 就是这 $n$ 个数的最小值。

我们需要把「读入一个数，把这个数和 $\mathrm{ans}$ 的较小值赋值给 $\mathrm{ans}$」这个行为重复 $n$ 次，这个过程可以通过循环结构来实现。

## 代码

### C++

在 C++ 里，可以使用 for 循环来进行这个过程。```for (int i = 0; i < n; ++i) { Block }```这段语句可以把 `Block` 内的内容执行 $n$ 次。具体到本题， `Block` 内做的事情就是上一段叙述的事情。结合相应的读入和变量声明，可以写出如下的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  int n;
  cin >> n;
  int ans = INT_MAX; // 将 ans 初始设为最大值
  for (int i = 0; i < n; ++i) {
    int x;  
    cin >> x;  // 读入一个数
    ans = min(ans, x);  // 把读入的数和 ans 的较小值赋值给 ans
  }
  cout << ans << endl;
}
```

---

### Rust

在 Rust 里，进行与上文类似的循环的方法是 `for _ in 0..n { Block }`。

可以写出代码如下：

```rust
/*
  省略了读入类 
  https://www.luogu.com.cn/paste/clle55rg
*/
fn main() {
  let mut cin = Scanner::new();
  let n = cin.next_int();
  let mut ans = i32::MAX;
  for _ in 0..n {
    let x = cin.next_int();
    ans = ans.min(x);
  }
  println!("{}", ans);
}
```

---

### TypeScript

在 ts 里，类似的 for 循环方法是 `for (let i = 0; i < n; ++i) { Block }`.

```typescript
import { Reader } from './Reader';
// https://www.luogu.com.cn/paste/r7vtnbaz
import * as fs from 'node:fs';

const data = fs.readFileSync('/dev/stdin')
const lines = data.toString('ascii').trim().split('\n');
const cin = new Reader(lines);

const n = cin.nextInt();
let ans = 1000000000;
for (let i = 0; i < n; ++i) {
  const x = cin.nextInt();
  ans = Math.min(ans, x);
}
console.log(ans);
process.exit(0);
```

---

## 作者：AFO_Lzx (赞：3)

这种题竟然清题解了？

### 方法一

使用打擂台方法，每次输入 $1$ 个数的时候就和目前的最小值比较，如果这个数字比目前的最小值更小，那么就肯定要更新答案。

代码实现：

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

int n, ans = 1e9;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	while (n--) {
		int x; 
		cin >> x;
		ans = min(ans, x);
	}
	
	cout << ans << '\n';
	return 0;
}
```

### 方法二

使用 C++ 中的自带函数 `min_element` 解决，使用方法：`*min_element(地址 1, 地址 2)`。记得前面的星星符号。

代码实现：

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

const int N = 1e2 + 5;
int n, a[N];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	for (int i = 1; i <= n; i++) cin >> a[i];
	cout << *min_element(a + 1, a + n + 1) << '\n';
	
	return 0;
}
```

完结，希望能够帮助到新手。

---

## 作者：0Io_oI0 (赞：1)

快点水题解！

这道题目给我们 $n$ 个数，让我们求出它们的最小值，可以考虑一下方法：

# 打擂台

每次输入一个数，我们就跟以前的最大值比较，如果这个数比以前的最大值大那么它就是现在的最大值。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],minn=INT_MAX;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		minn=min(minn,a[i]);
	}
	cout<<minn;
}
```

# 全部输入完后，进行排序

我们可以考虑 `sort` 函数，直接将数组从小到大排序，输出最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],minn=INT_MAX;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(&a[1],&a[n+1]);
	cout<<a[1];
}
```

---

## 作者：pengyirui (赞：1)

对于本题，提供两种做法：    
# 使用排序
众所周知，排序可以让数组有序。在本题中，可以通过 STL 的 sort 排序来找到最小值。
## sort 介绍
sort 是 STL 中的排序函数，使用快速排序，默认为从小到大。（[了解快速排序](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842)）

```cpp
#include<algorithm>
vector<int> vec;
sort(vec.begin(),vec.end());//vector的sort方式
int a[105];
sort(a,a+105);//将整个a数组从小到大排序
double b[1005];
bool cmp (double c,double d)//自定义排序方法
{return c>d;}
sort(b+1,b+1+1000,cmp)//将b[1] ~ b[1000]的元素从大到小排序
```
## 本题排序做法
首先排序，结束后输出最小值（$a_1$）即可。
## 代码

```cpp
#include<bits/stdc++.h>
int a[999999],n,m;
using namespace std;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        {
            cin>>a[i];
        }
    sort(a+1,a+1+n);
    cout<<a[1];
    return 0;
}
```
时间复杂度：$O(n \log n)$
# 打擂台
定义变量 $ans$，对于每一次输入与 $ans$ 取最小值，最后输出 $ans$ 即可。
## 代码
```#include<bits/stdc++.h>
int maxn=999999999,n,m;
using namespace std;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        {
            cin>>m;
            maxn=min(maxn,m);
        }
    cout<<maxn;
    return 0;
}
```
## 坑点
$ans$ 必须足够大，此题至少为 $1001$。

---


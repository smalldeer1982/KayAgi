# 【深基4.例3】分类平均

## 题目描述

给定 $n$ 和 $k$，将从 1 到 $n$ 之间的所有正整数可以分为两类：A 类数可以被 $k$ 整除（也就是说是 $k$ 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 $1$ 位，用空格隔开。

数据保证两类数的个数都不会是 $0$。

## 说明/提示

数据保证，$1 \leq n\leq 10000$，$1 \leq k \leq 100$。

## 样例 #1

### 输入

```
100 16```

### 输出

```
56.0 50.1```

# 题解

## 作者：yuxinrui0618 (赞：19)

# 题解：P5719 【深基4.例3】分类平均
## 1. 题目大意
- 求 $n$ 个数中可以被 $k$ 整除的数的平均值和其他数的平均值。

## 2. 思路
- 平均值的求法：用数的总和除以数的个数；
- 用变量 $s1$ 表示能被 $k$ 整除的数的个数，$c1$ 表示能被 $k$ 整除的数的总和；
- 用变量 $s2$ 表示不能被 $k$ 整除的数的个数，$c2$ 表示不能被 $k$ 整除的数的总和；
- 对于每个数，判断是否能被 $k$ 整除；
- 若可以，就将 $s1$ 加一，$c1$ 加上这个数；
- 若不可以，就将 $s2$ 加一，$c2$ 加上这个数；
- 注意由于输出要求，需使用 `double` 类型。

## 3. 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,x,k,s1=0,s2=0;
	double c1=0,c2=0;
	cin>>n>>k;
	for (int i=1;i<=n;i++)
	{
		if (i%k==0) //是否为 k 的倍数
		{
			s1++;
			c1+=i;
		}
		else
		{
			s2++;
			c2+=i;
		}
	}
	printf("%.1lf %.1lf",c1/s1,c2/s2); //或 cout<<fixed<< setprecision(1)<<c1/s1<<" "<<c2/s2;
    return 0;
}
```

## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：WoW_BBQ (赞：13)

## 解题分析

小蒟蒻不才，只会用不用循环的方法。

注意到 $1$ 到 $n$ 之间是 $k$ 的倍数的数构成了一个公差为 $k$ 的等差数列。

该数列的项数为 $p = \lfloor \frac{n}{k} \rfloor$，则首项为 $k$，末项为 $p \times k$，和为 $\dfrac{(p+1) \times k \times p}{2}$。

所以被 $k$ 整除的数平均数为 $\dfrac{(p+1) \times k}{2}$，不被 $k$ 整除的数平均数为 $\dfrac{(n+1)\times n - (p+1) \times k \times q}{2 \times (n-p)}$。

因为要求精确到小数点后 $1$ 位，记得乘上 $1.0$，并像如下代码处理精度。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,k,p;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	p=n/k;
	cout<<fixed<<setprecision(1)<<(p+1.0)*k/2<<" "<<((n+1)*n/2.0-(p+1)*k*p/2.0)/(n-p)*1.0;
	return 0;
}

```

---

## 作者：一扶苏一 (赞：8)

# P5719【深基4.例3】分类平均

## 分析

要找到所有 A、B 两类数各自的均值，可以从小到大枚举 $1\sim n$ 范围内的每个整数 $i$，同时维护四个变量 $\mathrm{sumA}$、$\mathrm{sumB}$、$\mathrm{cntA}$、$\mathrm{cntB}$，分别表示当前找到的 A、B 两类数的数字之和与个数。那么最终两类数的均值就分别是 $\frac{\mathrm{sumA}}{\mathrm{cntA}}$ 和 $\frac{\mathrm{sumB}}{\mathrm{cntB}}$。

想要判断一个数字 $i$ 是 A 类数还是 B 类数，只需要查看 $i$ 除以 $k$ 的余数。如果余数为 $0$，则是 A 类数，否则是 B 类数。

## 代码

### C++

在 C++ 里，可以用如下的 for 循环将 $i$ 从 $1$ 取到 $n$ 进行枚举：```for (int i = 1; i <= n; ++i) { Block }```。而 `Block` 的内容需要根据前文的分析，用 `if-else` 结构判断 $i$ 属于哪一类数，然后进行相应的累加，可以写出如下的代码：

```cpp
for (int i = 1; i <= n; ++i) {
  if (i % k == 0) { // i 是 A 类数
    sumA += i;    // 累加 A 类数的和
    ++cntA;       // 累加 A 类数的个数
  } else {        // 否则是 B 类数
    sumB += i;    // 累加 B 类数的和
    ++cntB;       // 累加 B 类数的数量
  }
}
```

由于 for 循环的循环体里只有一个 `if-else` 结构，包裹循环体的花括号可以省略，只留 `if-else` 结构自身的花括号，结合相应的变量声明和读入，可以写出如下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  int n, k;
  cin >> n >> k;
  int sumA = 0, sumB = 0, cntA = 0, cntB = 0;
  for (int i = 1; i <= n; ++i) if (i % k == 0) { // 这里的花括号是 if 的
    sumA += i;
    ++cntA;
  } else {
    sumB += i;
    ++cntB;
  }
  cout << fixed << setprecision(1) << 1.0 * sumA / cntA << " " << 1.0 * sumB / cntB << endl; // 按规定进行输出
}
```

这里输出较为复杂。其中 `fixed` 是要求总是按小数形式进行输出（而不是科学计数法），`setprecision(x)` 表示后面的浮点数保留的小数点后位数为 $x$。

因为 `sumA` 和 `cntA` 都是整数，直接对两个整数做除法得到的结果是整除而不是浮点数形式，所以必须在运算前先用浮点数 `1.0` 乘一下。这是因为：浮点数乘以整数的结果是浮点数。在从左到右运算时，先算 `1.0 * sumA`，得到了一个浮点类型的结果，把这个结果去除 `cntA`，就是浮点型除以整形，结果就能得到浮点型了。

---

### Rust

在 Rust 里，进行与上文类似的循环的方法是 `for i in 1..=n { Block }`。相比循环 `for _ in 0..n { Block }`，这里有两个改变：

1. 把循环变量的声明从 `_` 改为了 `i`。这是因为 Rust 不允许在代码里拿到 `_` 的值（可以改成 `_` 试一下），但是我们需要在循环体里拿到循环变量的值进行判断，所以需要用一个不是 `_` 的标识符。
2. 循环范围从 `0..n` 变成了 `1..=n`。前者的循环范围是 $0,1,2,\dots n - 1$ 这 $n$ 个数，后者是 $1,2,\dots , n$ 这 $n$ 个数。其中对右边界的取等是通过 `=` 标识的。

Rust 不允许省略 for 循环体的大括号，而 Rust 的 if 条件无需加括号，可以写出代码如下：

```rust
/*
  省略了读入类 
  https://www.luogu.com.cn/paste/clle55rg
*/

fn main() {
  let mut cin = Scanner::new();
  let (n, k) = (cin.next_int(), cin.next_int());
  let (mut sum_a, mut sum_b, mut cnt_a, mut cnt_b) = (0, 0, 0, 0);
  for i in 1..=n {
    if i % k == 0 {
      sum_a += i;
      cnt_a += 1;
    } else {
      sum_b += i;
      cnt_b += 1;
    }
  }
  println!("{:.1} {:.1}", sum_a as f64 / cnt_a as f64, sum_b as f64 / cnt_b as f64);
}
```

关于输出，`{:.1}` 是输出一位小数的方法，Rust 不允许浮点数和整数相除，因此必须把两个量都显式地转换成 `f64` 浮点型。

---

### TypeScript

在 ts 里，类似的 for 循环方法是 `for (let i = 1; i <= n; ++i) { Block }`。它的 for 和 if 风格都和 cpp 几乎一致。值得一提的是 number 本身就是浮点型，因此无需做类型转换就可以直接除。

```typescript
import { Reader } from './Reader';
// https://www.luogu.com.cn/paste/r7vtnbaz
import * as fs from 'node:fs';

const data = fs.readFileSync('/dev/stdin')
const lines = data.toString('ascii').trim().split('\n');
const cin = new Reader(lines);


let n = cin.nextInt(), k = cin.nextInt();
let sumA = 0, sumB = 0, cntA = 0, cntB = 0;
for (let i = 1; i <= n; ++i) if (i % k == 0) {
  sumA += i;
  cntA++;
} else {
  sumB += i;
  cntB++;
}

console.log(`${(sumA / cntA).toFixed(1)} ${(sumB / cntB).toFixed(1)}`)
```

---

## 作者：AFO_Lzx (赞：5)

首先维护 $4$ 个变量：

- $s_1$ 表示 A 类数的总和，$c_1$ 表示 A 类数的个数。
- $s_2$ 表示 B 类数的总和，$c_2$ 表示 B 类数的个数。
  
运用循环结构遍历 $1\sim n$ 的数字，设当前遍历的数字为 $i$，则有如下的分类：

- $i \bmod k=0$：即为 $i$ 是 $k$ 的倍数，那么 $i$ 就是 A 类数。则 $s_1\leftarrow s_1+i$，$c_1\leftarrow c_1+1$。
- $i \bmod k\ne0$：即为 $i$ 不是 $k$ 的倍数，那么 $i$ 就是 B 类数。 $s_2\leftarrow s_2+i$，$c_2\leftarrow c_2+1$。
  
最终的答案：A 类数的平均数为 $\dfrac{s_1}{c_1}$，B 类数的答案为 $\dfrac{s_2}{c_2}$。

代码实现如下：

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int n, k;
	cin >> n >> k;
	
	int s1 = 0, c1 = 0;
	int s2 = 0, c2 = 0;
	
	for (int i = 1; i <= n; i++) {
		if (i % k == 0) s1 += i, c1++;
		else s2 += i, c2++;
	}
	
	double ans1 = 1.0 * s1 / c1;
	double ans2 = 1.0 * s2 / c2;
	
	cout << fixed << setprecision(1) << ans1 << ' ' << ans2 << '\n';
	return 0;
}
```

完结，希望能够帮助到新手。

---

## 作者：0Io_oI0 (赞：4)

来水题解吧！

我们可以从 $1$ 遍历到 $n$ 判断每个数是否被 $k$ 整除，若整数我们可以将记录能整除的数的个数的变量加 $1$ 把记录能整除的数的和的变量加上这个数，相反同理。

最后平均数就是 $\frac{sum}{cnt}$ 其中 $sum$ 为总和，$cnt$ 为数量。

代码：

```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
#define i_will signed
#define ak main
#define IMO ()
I AK IOI;
int n,k,sum1,cnt1,sum2,cnt2;
i_will ak IMO{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	//freopen("","r",stdin);
	//freopen("","w",stdout);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		if(i%k==0){
			sum1+=i;
			cnt1++;
		}
		else{
			sum2+=i;
			cnt2++; 
		}
	}
	printf("%.1lf %.1lf",sum1*1.0/cnt1,sum2*1.0/cnt2);
	i_ak ioi;
}
```

---


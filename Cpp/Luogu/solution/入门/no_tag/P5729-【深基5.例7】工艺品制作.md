# 【深基5.例7】工艺品制作

## 题目描述

现有一个长宽高分别为 $w,x,h$ 组成的实心玻璃立方体，可以认为是由 $1\times1\times1$ 的数个小方块组成的，每个小方块都有一个坐标 $ ( i,j,k ) $。现在需要进行 $q$ 次切割。每次切割给出 $(x_1,y_1,z_1),(x_2,y_2,z_2)$ 这 6 个参数，保证 $x_1\le x_2$，$y_1\le y_2$，$z_1\le z_2$；每次切割时，使用激光工具切出一个立方体空洞，空洞的壁平行于立方体的面，空洞的对角点就是给出的切割参数的两个点。

换句话说，所有满足  $x_1\le i\le x_2$，$y_1\le j \le y_2 $，$z_1\le k\le z_2$ 的小方块 $(i,j,k)$ 的点都会被激光蒸发。例如有一个  $4\times4\times 4$ 的大方块，其体积为 $64$；给出参数 $(1,1,1),(2,2,2)$ 时，中间的 $8$ 块小方块就会被蒸发，剩下 $56$ 个小方块。现在想知道经过所有切割操作后，剩下的工艺品还剩下多少格小方块的体积？ 

## 说明/提示

数据保证，$1\le w,x,h\le 20$，$1 \leq q\le 100$。$1 \leq x_1 \leq x_2 \leq w$，$1 \leq y_1\leq y_2 \leq x$，$1 \leq z_1 \leq z_2 \leq h$。

## 样例 #1

### 输入

```
4 4 4
1
1 1 1 2 2 2
```

### 输出

```
56```

# 题解

## 作者：SUNCHAOYI (赞：97)

- 这道题先设置一个三维数组，表示该物体的长宽高。

- 然后每一次读入一组对角线，就把该范围内的数组数据标记为 $1$。

- 最后只要全部扫一遍判断还剩几个为 $0$ 的数组数据，表示还剩多少块。

注意，输入对角线后的范围内的方块可能在之前已被清除，千万不要重复清除哦！


------------

贴代码了：

```cpp
#include <iostream>
#include <cmath>
using namespace std;
const int MAX = 30;
int sq[MAX][MAX][MAX] = {0};//一开始均默认为0，表示方块还在 
int main()
{
	int a,b,c,n,ans = 0;
	cin>>a>>b>>c>>n;
	while(n--)
	{
		int x1,y1,z1,x2,y2,z2;
		cin>>x1>>y1>>z1>>x2>>y2>>z2;
		for(int i = x1;i <= x2;i++)
			for(int j = y1;j <= y2;j++)
				for(int k = z1;k <= z2;k++) sq[i][j][k] = 1;//该范围的方块标记为1，表示已被切除 
	}
	for(int i = 1;i <= a;i++)
		for(int j = 1;j <= b;j++)
			for(int k = 1;k <= c;k++)
				if(sq[i][j][k] == 0) ans++;//判断该方块是否还在 
	cout<<ans<<endl;//输出答案 
	return 0;
} 
```

---

## 作者：HAPPINESS23333 (赞：7)

**[题目传送门](https://www.luogu.com.cn/problem/P5729)**

## 思路
因为这里的 $1\le w,x,h\le 20$，数据比较小，选择暴力。我这里使用的是布尔值的三维数组来存储，先初始化所有小方块的值为**真**，如果被消除那么这个小方块的值改为**假**。

- 注意：题目里面给的下标是从 $1$ 开始的，所以我们的循环应该从 $1$ 开始。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool block[30][30][30];
int main(){
	int w,x,h;
	//输入 
	cin>>w>>x>>h;
	//初始化 
	for(int i=1;i<=w;i++){
		for(int j=1;j<=x;j++){
			for(int k=1;k<=h;k++){
				block[i][j][k]=true;
			}
		}
	}
	int q;
	//输入
	cin>>q;
	//这里可能有新学的小伙伴看不懂，这里的while(q--)的意思是每次循环q-1，当q减为0的时候就会跳出循环，等同于for(int m=0;m<q;m++) 
	while(q--){
		int x1,y1,z1,x2,y2,z2;
		cin>>x1>>y1>>z1>>x2>>y2>>z2;
		//消除，记住先后都要包含 
		for(int i=x1;i<=x2;i++){
			for(int j=y1;j<=y2;j++){
				for(int k=z1;k<=z2;k++){
					block[i][j][k]=false;
				}
			}
		}
	}
	int final_out=0;
	//统计，若值为true则小方块存在，final_out加一 
	for(int i=1;i<=w;i++){
		for(int j=1;j<=x;j++){
			for(int k=1;k<=h;k++){
				if(block[i][j][k]){
					final_out++;
				}
			}
		}
	}
	//输出 
	cout<<final_out<<endl;
	return 0;
}
```

---

## 作者：Peruere_Arlecchino (赞：5)

这道简单的题可以用三维布尔数组模拟切割过程，记得要初始时所有小方块均存在。每次切割操作将指定坐标范围内的所有小方块标记为不存在，最后遍历整个数组统计仍存在的小方块数量即为答案。
### code：
```cpp
#include<bits/stdc++.h>
#include<vector>
using namespace std;
int main() {
    int w, x, h;
    cin >> w >> x >> h;
    vector<vector<vector<bool>>> cube(w+1, 
        vector<vector<bool>>(x+1, 
            vector<bool>(h+1, true)));
    int q;
    cin >> q;
    for (int i = 0; i < q; ++i) {
        int x1, y1, z1, x2, y2, z2;
        cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
        for (int i = x1; i <= x2; ++i)
            for (int j = y1; j <= y2; ++j)
                for (int k = z1; k <= z2; ++k)
                    cube[i][j][k] = false;
    }
    int count = 0;
    for (int i = 1; i <= w; ++i)
        for (int j = 1; j <= x; ++j)
            for (int k = 1; k <= h; ++k)
                if (cube[i][j][k]) count++;
    
    cout << count << endl;
    return 0;
}
```
求赞求过。

---

## 作者：Heqianyu59714 (赞：5)

# 题目大意
### 题意
现有一个长宽高分别为 $w,x,h$ 组成的实心玻璃立方体，现在需要进行 $q$ 次切割，每次切割给出 $(x_1,y_1,z_1),(x_2,y_2,z_2)$ 这 6 个参数， $x_1\le i\le x_2$，$y_1\le j \le y_2 $，$z_1\le k\le z_2$ 的小方块 $(i,j,k)$ 的点都会被激光蒸发，求剩下的体积。
### 思路
用数组 $a$ 记录这个小正方体是否被标记过，如果没有让 $ans \gets ans+1$。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[25][25][25],w, x, h, q, ans = 0;//定义

int main() {
	cin >> w >> x >> h >> q;//输入
	while (q--) {
		int x1, y1, z1, x2, y2, z2;
		cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
		//
		for (int i = min(x1, x2); i <= max(x1, x2); i++) {
			for (int j = min(y1, y2); j <= max(y1, y2); j++) {
				for (int k = min(z1, z2); k <= max(z1, z2); k++) {
					a[i][j][k] = 1;//把切下的部分做标记
				}
			}
		}
	}
	for (int i = 1; i <= w; i++) {
		for (int j = 1; j <= x; j++) {
			for (int k = 1; k <= h; k++) {
				if (a[i][j][k] == 0) {//判断是否做了标记
					ans++;
				}
			}
		}
	}
	cout << ans << endl;//输出
	return 0;
}
```

---

## 作者：chen_zi_lang (赞：4)

# 题解
# [题目传送门](https://www.luogu.com.cn/problem/P5729)
  
## 思路

因为本题数据比较水，所以我们可以先模拟正方体，再暴力枚举。用三维数组f表示每一个方块的状态：切割的地方标记为 $0$，没有切的地方标记为 $1$，最后统计有多少个 $1$，就是没有切割的方块个数。
## AC code
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
long long a,b,c,q,cnt;
bool f[101][101][101];//状态数组
int main() {
    cin>>a>>b>>c>>q;
    memset(f,true,sizeof f);//全部初始化为true
	for(long long t=1;t<=q;t++){
		long long x, y, z, x2, y2, z2;
		scanf("%lld %lld %lld %lld %lld %lld",&x,&y,&z,&x2,&y2,&z2);
		for (long long i=x;i<=x2;i++) {//三维循环枚举切割点
			for (long long j=y;j<=y2;j++) {
				for (long long k=z;k<=z2;k++) {
					f[i][j][k]=false;//标记切割点为false
				}
			}
		}
	}
	for (long long i=1;i<=a;i++){
		for (long long j=1;j<=b;j++){
			for (long long k=1;k<=c;k++){
				cnt+=f[i][j][k];//统计未切割点数
			}
		}
	}
	printf("%lld",cnt); //输出答案
	return 0;
}
````

---

## 作者：XXXL_jzl (赞：3)

# 题解：P5729 【深基5.例7】工艺品制作

## 题目分析

有一个立方体，长宽高分别为 $w,x,h$。\
有 $q$ 次切割操作。\
每一次切除坐标位于 $(x_1,y_1,z_1)$ 和 $(x_2,y_2,z_2)$ 之间的正方体。\
由于 $1 \le w,x,h \le 20$，数据足够小，考虑暴力写法之打标记。\
开一个三维数组，每一次都打上上文范围内的标记即可。

## 双倍经验

[P1789 【Mc生存】插火把](https://www.luogu.com.cn/problem/P1789)

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int w, x, h;
int q;
int vis[50][50][50];
int xx, yy, zz;
int x2, y2, z2;
int ans = 0;
signed main() {
	cin >> w >> x >> h;
	cin >> q;
	while(q--) {
		cin >> xx >> yy >> zz >> x2 >> y2 >> z2;
		for(int i=xx; i<=x2; i++) {
			for(int j=yy; j<=y2; j++) {
				for(int k=zz; k<=z2; k++) {
					vis[i][j][k] = 1;
				}
			}
		}
	}
	for(int i=1; i<=w; i++) {
		for(int j=1; j<=x; j++) {
			for(int k=1; k<=h; k++) {
				if(vis[i][j][k] == 0) {
					ans++;
				}
			}
		}
	}
	cout << ans << '\n';
	return 0;
}

```

---

## 作者：XXXXD__TB_XZH (赞：3)

## 题目介绍

给定一个三维的长方体，多次操作，把其坐标在要切割范围内的正方形给切掉。\
因为范围不大，直接用三维数组模拟即可，最后所有操作完之后再遍历完所有元素。未标记的就计入答案。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25;
int w,x,h,q,ans=0;
bool f[N][N][N];
int main() {
	cin>>w>>x>>h;//输入 
	cin>>q;//输入
	while(q--){
		int x,y,z,xx,yy,zz;
		cin>>x>>y>>z>>xx>>yy>>zz;//输入
		for(int i=x;i<=xx;i++){
			for(int j=y;j<=yy;j++){
				for(int k=z;k<=zz;k++){//指定范围内遍历 
					f[i][j][k]=1;//需要标记（需要删除） 
				}
			}
		}
	}//所有操作已经完成之后 
	for(int i=1;i<=w;i++){
		for(int j=1;j<=x;j++){
			for(int k=1;k<=h;k++){//遍历所有区间 
				if(!f[i][j][k]){//没有被打标记（没有被删除） 
					ans++;//记入答案 
				}
			}
		}
	}
	cout<<ans<<endl;//输出 
	return 0;
}
```

---

## 作者：fjtMESSI10 (赞：3)

## 思路
这题的数据范围非常小，所以我们可以考虑用三维数组来模拟这一个立方体，被切割的地方就做标记，最后暴力枚举每一个小方块，如果没有被切割就加在计数器里，最后输出有多少个没有被切割的小方块就行了。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a, b, c;
int q;
int ans;
int h[50][50][50];

signed main() {
	memset(h, 0, sizeof(h));
	cin >> a >> b >> c;
	cin >> q;
	while (q--) {
		int x, y, z, x1, y1, z1;
		cin >> x >> y >> z >> x1 >> y1 >> z1;
		for (int i = x; i <= x1; i++) {
			for (int j = y; j <= y1; j++) {
				for (int k = z; k <= z1; k++) {
					h[i][j][k] = 1;
				}
			}
		}
	}
	for (int i = 1; i <= a; i++) {
		for (int j = 1; j <= b; j++) {
			for (int k = 1; k <= c; k++) {
				if (h[i][j][k] == 0) {
					ans++;
				}
			}
		}
	}
	cout << ans;
	return 0;

}
```

---

## 作者：Ashankamiko (赞：3)

# 题目简述
### 题意
给定一个大小为 $w \times x \times h$ 的方块和 $q$ 次操作，每次操作切除 $(x1,y1,z1)$ 到 $(x2,y2,z2)$ 之间的所有块全部删去，最后问还有几个方块没被删除。
### 思路
直接暴力，并且定义方块为 $maps_{i,j,k}$，对于每次操作，只需用三重循环删除即可。
```
for i := min{x1, x2} to max{x1, x2}:
    for j := min{y1, y2} to max{y1, y2}:
        for k := min{z1, z2} to max{z1, z2}:
            maps(i, j, k) = 1
```
最后统计一下有多少个 $maps_{i,j,k}$ 没有被标记过即可。
## [AC 代码](https://www.luogu.com.cn/record/208993367)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
bool maps[25][25][25]; //方块
int a, b, c, q, x1, x2, y1_, y2, z1, z2, cnt;

int main() {
	in >> a >> b >> c >> q;
	while (q--) { //q次操作
		in >> x1 >> y1_ >> z1 >> x2 >> y2 >> z2;
		for (int i = min(x1, x2); i <= max(x2, x1); i++)
			for (int j = min(y1_, y2); j <= max(y1_, y2); j++)
				for (int k = min(z1, z2); k <= max(z2, z1); k++)
					maps[i][j][k] = true; //切割（标记）
	}
	for (int i = 1; i <= a; i++)
		for (int j = 1; j <= b; j++)
			for (int k = 1; k <= c; k++)
				if (!maps[i][j][k]) //没有被标记
					cnt++;
	out << cnt; //输出答案
	return 0;
}
```

---


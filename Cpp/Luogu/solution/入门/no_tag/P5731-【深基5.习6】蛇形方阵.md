# 【深基5.习6】蛇形方阵

## 题目描述

给出一个不大于 $9$ 的正整数 $n$，输出 $n\times n$ 
的蛇形方阵。

从左上角填上 $1$ 开始，顺时针方向依次填入数字，如同样例所示。注意每个数字有都会占用 $3$ 个字符，前面使用空格补齐。

## 说明/提示

数据保证，$1 \leq n \leq 9$。

## 样例 #1

### 输入

```
4```

### 输出

```
  1  2  3  4
 12 13 14  5
 11 16 15  6
 10  9  8  7```

# 题解

## 作者：volatile (赞：23)

# 思路

因为大小为 $n\times{n}$，所以最大的数就是 $n^2$，用一个 $now$ 变量枚举 $1$ 到 $n^2$。从四个方向遍历一个二维数组 $a$。若当前位置为 $a_{x,y}$：

1. 向右遍历


```cpp
while (y + 1 <= n && a[x][y + 1] == 0) {
    y++;
    a[x][y] = now;
    now++;
}
```

只要当前位置不是空的，就可以填入，否则换向。

2. 向下遍历

```cpp
while (x + 1 <= n && a[x + 1][y] == 0) {
    x++;
    a[x][y] = now;
    now++;
}
```

3. 向左遍历

```cpp
while (y - 1 >= 1 && a[x][y - 1] == 0) {
    y--;
    a[x][y] = now;
    now++;
}
```

4. 向上遍历

```cpp
while (x - 1 >= 1 && a[x - 1][y] == 0) {
    x--;
    a[x][y] = now;
    now++;
}
```

最后输出，注意右对齐 $3$ 格，可以用 `printf("%3d", a[i][j]);` 实现。

# 代码


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[20][20];
int main()
{
	int n;
	int now = 2, x = 1, y = 1;
	a[1][1] = 1;
	cin >> n;
	while (now <= n * n) {
		while (y + 1 <= n && a[x][y + 1] == 0) {
			y++;
			a[x][y] = now;
			now++;
		}
		while (x + 1 <= n && a[x + 1][y] == 0) {
			x++;
			a[x][y] = now;
			now++;
		}
		while (y - 1 >= 1 && a[x][y - 1] == 0) {
			y--;
			a[x][y] = now;
			now++;
		}
		while (x - 1 >= 1 && a[x - 1][y] == 0) {
			x--;
			a[x][y] = now;
			now++;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			printf("%3d", a[i][j]);
		}
		cout << endl;
	}
	return 0;
}
```

---

## 作者：GeorgeDeng (赞：7)

因为题目说 $n\le9$，所以数最大就是 $81$，所以两位数有 $1$ 个空格，而一位数有 $2$ 个空格。

我们模拟每次填数的过程。

用 $nowx,nowy$ 记录当前是哪个位置，$nowv$ 记录现在是哪个数，$dir$ 记录当前朝哪个方向。

每一次我们把 $a_{nowx,nowy}\larr nowv,nowv \larr nowv+1$。其中，$\larr$ 表示赋值操作。然后，按照方向移动一格。如果移动后超出边界，那么换一个方向，移到正确位置。

然后，就没有然后了。

代码：

```cpp
#include <iostream>
using namespace std;

int a[101][101];
const int dx[4] = {0,1,0,-1};//方向数组，表示下一步与这一步的x,y差值
const int dy[4] = {1,0,-1,0};
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int n;
	cin>>n; 
	int nowx = 1,nowy = 1,nowv = 1,dir = 0;//如上
	while(nowv<=n*n){
		a[nowx][nowy] = nowv++;
		int tx = nowx+dx[dir],ty = nowy+dy[dir];
		if(tx<1||tx>n||ty<1||ty>n||a[tx][ty]!=0) dir = (dir+1)%4;
		nowx+=dx[dir],nowy+=dy[dir]; //模拟填数
	}
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=n;j++){
			cout<<' ';
			if(a[i][j]<10) cout<<' ';//注意特判
			cout<<a[i][j];//输出答案
		}
		cout<<endl;
	}
	return 0;
}

```

---

## 作者：Ashankamiko (赞：4)

# 题目简述
### 题意
给定一个正整数 $N$，输出一个 $N \times N$ 矩阵，按照顺时针方向填入数字，直到填满矩阵。
### 思路
不难发现本题非常类似于 dfs，所以我们只要弄好方向数组，就可以达到顺时针填数的效果，直到填完所有数字，所以这题我们采用递归。
### STL 函数
这里介绍 `setw(x)`。

调用该函数可以使接下来的输出长度为 $x$，如果位数不够，在输出内容的前面补满空格，使输出的长度为 $x$。

## [AC 代码](https://www.luogu.com.cn/record/203460078)
```cpp
#include <bits/stdc++.h>
using namespace std;
int dx[4] = {0, -1, 0, 1}, dy[4] = {1, 0, -1, 0}, n, a[15][15], m = 1; //注意方向数组

void dfs(int x, int y, int f) { //x和y是当前坐标，f表示方向数组的下标
	a[x][y] = m++; //填数
	for (int i = 0; i < 4; i++) {
		int tx = dx[f % 4] + x, ty = y + dy[f % 4]; //下一个坐标
		if (tx > 0 && tx <= n && ty <= n && ty > 0 && a[tx][ty] == 0) {
			dfs(tx, ty, f);
			return; //填完直接return，防止继续进行循环
		} else
			f++; //到头了
	}
}

int main() {
	cin >> n;
	dfs(1, 1, 0);
	for (int i = 1; i <= n; i++) { //输出矩阵
		for (int j = 1; j <= n; j++)
			cout << setw(3) << a[i][j]; //调用setw
		cout << endl;
	}
	return 0;
}
```

---

## 作者：Dongze2010 (赞：2)

# $P5731$ 题解

[原题链接](https://www.luogu.com.cn/problem/P5731)

## 题目分析

输出长为 $n$、宽为 $n$ 的正方形的蛇形矩阵。从左上角的 $1$ 开始，一直到位于正方形中央的 $n \times n$ 结束。  
我们可以建立 $num$ 来记录此时应输出的数字，用 $a$ 数组来储存。(令 $a_{0,0} = 1$。)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin >> n;
    int a[100][100] = {0} , num = 1;
    int lt = 0, rt = n - 1, tp = 0, bt = n - 1; // left right top bottom
    while (lt <= rt and tp <= bt){ // 边界条件
        // 从左到右填充顶部
        for (int i = lt;i <= rt;i++)  a[tp][i] = num++;
        tp++;
        // 从上到下填充右侧
        for (int i = tp;i <= bt;i++)  a[i][rt] = num++;
        rt--;
        // 从右到左填充底部
        if (tp <= bt){
            for (int i = rt;i >= lt;i--)  a[bt][i] = num++;
            bt--;
        }
        // 从下到上填充左侧
        if (lt <= rt){
            for (int i = bt;i >= tp;i--)  a[i][lt] = num++;
            lt++;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << setw(3) << a[i][j]; // 输出，setw填充空格
        }
        cout << endl;
    }
    return 0; 
}
```

---

## 作者：ShiYuXuan1234 (赞：2)

## 前言
从[这里](https://www.luogu.com.cn/problem/solution/B4199)过来的，发现这题也能写题解，于是写了一篇。

## 思路
通过 `while` 循环模拟，唯一难点可能就是调整方向。

蒟蒻思路：定义两个变量 $d$ 和 $quan$，$d$ 表示方向，$quan$ 表示遍历到了第几圈，两个变量都从 $0$ 开始，则有以下 $4$ 种可能需要调整方向（以下以样例为例）：

1. $d=0$ 且当前位置中的 $y$ 在 $n-quan$ 处。例：遍历到右上角时，$quan=0$，$y=4$。
  
1. $d=1$ 且当前位置中的 $x$ 在 $n-quan$ 处。例：遍历到右下角时，$quan=0$，$x=4$。

1. $d=2$ 且当前位置中的 $y$ 在 $quan+1$ 处。例：遍历到左下角时，$quan=0$，$y=1$。

1. $d=3$ 且当前位置中的 $x$ 在 $quan+2$ 处。这里最特殊，因为我们不能一直在最外围遍历，所以要 $+2$。例：$x=2$，$y=1$，$quan=0$。注意，这里还须把 $quan$ 增加 $1$。

同时，不要忘了在增加 $d$ 时将 $d$ 取余 $4$。

## 坑点
场宽！！！要用 `printf("%3d",a[i][j])`！

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10][10];
int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//右下左上
int main(){
	int x=1,y=1,n;
	cin>>n;
	int cnt=0,quan=0;
	int d=0;
	while(cnt!=n*n){
		a[x][y]=++cnt;
		if(d==0&&y==n-quan||d==1&&x==n-quan||d==2&&y==quan+1||d==3&&x==quan+2){
            d++;
            d%=4;           
            if(d==0){//d已经增加1并取余4了，因此这里写0（(3+1)%4）
                quan++;
            }
        }
        x+=dir[d][0];
        y+=dir[d][1];        
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%3d",a[i][j]);
		}
		cout<<endl;
	}
	return 0;
}
```

---


# 【深基5.习7】杨辉三角

## 题目描述

给出 $n(1\le n\le20)$，输出杨辉三角的前 $n$ 行。

如果你不知道什么是杨辉三角，可以观察样例找找规律。

## 样例 #1

### 输入

```
6```

### 输出

```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
```

# 题解

## 作者：hensier (赞：69)

杨辉三角主要具有以下性质：

- 每一行的第一个元素和最后一个元素均为 $1$。
- 第 $i$ 行 第 $j$ 列（$i>1,j \le i$）的元素等于第 $i-1$ 行第 $j-1$ 列和第 $i-1$ 行第 $j$ 列之和。

转换成数学语言：

$$a_{i,1}=a_{i,i}=1$$
$$a_{i,j}=a_{i-1,j-1}+a_{i-1,j}$$


利用递推，我们可以得到代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[21][21];
int main()
{
    scanf("%d",&n);
    a[1][1]=1;//初始化
    for(int i=2;i<=n;i++)
        for(int j=1;j<=i;j++)
            a[i][j]=a[i-1][j-1]+a[i-1][j];//进行计算
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)printf("%d ",a[i][j]);//输出
        printf("\n");//换行
    }
    return 0;
}
```

Python 代码：

```python
n = int(input()) # 输入n，类型为整数
a = [[0 for i in range(0, n + 1)] for j in range(0, n + 1)] # 建立数组
a[1][1] = 1 # 标记a[1][1]的值为1
for i in range(2, n + 1): # range(a,b)表示在[a,b)区间，不包括b
    for j in range(1, i + 1):
        a[i][j] = a[i-1][j-1] + a[i-1][j] # 递推
for i in range(1, n + 1):
    for j in range(1, i + 1):
        print(a[i][j], end = ' ') # end=''可以在输出内容后多输出一个字符串，不写end则默认为换行
    print('') # 输出空，因为默认输出后换行，所以达到了换行作用
```

---

## 作者：Lithium_Chestnut (赞：46)

盼了这道题好久，早就预备好了模板。

在程序最开端，现将 $a$ 数组的 ${a_i}_i$ 和 ${a_i}_1$ 位定为1，便于杨辉三角的运算。

规律从第 $3$ 行开始，所以第一层循环一定要从 $3$ 开始，而第二层循环每次一定比第一层循环少 $1$，然后求和，最后二层循环输出就行了，注意要在第 $2$ 层循环结束后换行。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001][1001];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		a[i][i]=1;
		a[i][1]=1;
	}
	for(int i=3;i<=n;i++)
	{
		for(int j=2;j<=i-1;j++) a[i][j]=a[i-1][j-1]+a[i-1][j];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++) cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：novax (赞：11)

本题是杨辉三角模板题。

杨辉三角具有如下的初始条件：

$$C_{i,0}=C_{i,i}=1$$

杨辉三角有如下的递推公式：
$$C_{i,j} = C_{i-1,j} + C_{i-1,j-1}$$

杨辉三角本质是二项式系数，其第 $n$ 行各个数值即为 $(a+b)^n$ 展开后各项的系数。展开后共有 $n+1$ 项，第 $i$ 项的系数记作 $C_{n,i}$，形如

$$C_{n,0}a^n + C_{n,1}a^{n-1}b + C_{n,2}a^{n-2}b^2+\cdots + C_{n,n-2}a^2b^{n-2} + C_{n,n-1}ab^{n-1} + C_{n,n}b^n$$

由于 $a^n$ 只能由 $n$ 个 $(a+b)$ 中 $a$ 相乘得到，因此其系数为 $1$，$b^n$ 同理，由此得到了杨辉三角的边界条件式。

对于杨辉三角第 $n$ 行中第 $i$ 项 $C_{n,i}$，其为 $a^ib^{n-i}$ 的系数，考虑第 $n$ 行的 $a^ib^{n-i}$ 可能来源。第 $n$ 行的 $(a+b)^n$ 有

$$(a+b)^n=(a+b)^{n-1}(a+b)=(C_{n-1,0}a^{n-1} + C_{n-1,1}a^{n-2}b + C_{n-1,2}a^{n-3}b^2+\cdots + C_{n-1,n-3}a^2b^{n-3} + C_{n-1,n-2}ab^{n-2} + C_{n-1,n-1}b^{n-1})(a+b)$$

则 $a^ib^{n-i}$ 可以由上一行的 $a^{i-1}b^{n-i}$ 乘以 $a$ 或 $a^ib^{n-i-1}$ 乘以 $b$ 得到。由此可得 $a^ib^{n-i}$ 的系数 $C_{n,i}$ 即为上一行中  $a^{i-1}b^{n-i}$ 与 $a^ib^{n-i-1}$ 系数相加的结果，为 $C_{n,i} = C_{n-1,i-1} + C_{n-1,i}$，即杨辉三角的递推式。

由于二项式系数的组合性质，杨辉三角的 $C_{i,j}$ 项即为组合数 $C_{i,j}$，这使得杨辉三角成为时间复杂度允许情况下一种简洁好写的组合数求法。

本题要求输出杨辉三角的前 $n$ 行，直接按照递推公式计算即可。代码如下。
```cpp
#include <cstdio>
int N,C[30][30];
int main()
{
	scanf("%d",&N);
	int i,j;
	C[0][0]=1;printf("1\n");
	for(i=1;i<N;i++)
	{
		for(j=0;j<=i;j++)
		{
			C[i][j]=C[i-1][j]+C[i-1][j-1];
			printf(j!=i?"%d ":"%d\n",C[i][j]);
		}
	}
} 
```
本文完整重写于2025.5.30。2020版[原文](https://www.luogu.com.cn/paste/vy73ztpj)留档。

---

## 作者：dengrunze2608 (赞：6)

## 题意
给出 $n(1\le n\le20)$，输出杨辉三角的前 $n$ 行。
## 引入
首先介绍**杨辉三角**，它是一个由数字构成的三角形，每一行的数字是上一行相邻两数之和。

其最顶端的数字是 $1$（注意最顶端是第 $0$ 行），后续每行的首尾也为 $1$，中间的数字是上方两个数字的和。

如图：

![杨辉三角](https://cdn.luogu.com.cn/upload/image_hosting/jzm9gita.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

但要注意，这里的第一行是 $n=1$ 的。

## 解题思路
创建 $a$ 数组存储杨辉三角，将第一行初始化为 $1$，从第二行开始，每个数字等于它上方和左上方的两个数字之和，也就是 `a[i][j]=a[i-1][j]+a[i-1][j-1]`。

这样，我们也可以处理左右两边的情况。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100][100];
int main(){
	cin>>n;
	a[0][1]=1; 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+2;j++){
			a[i][j]=a[i-1][j]+a[i-1][j-1];
		}
	}
	cout<<"1\n";
	for(int i=1;i<=n-1;i++){
		for(int j=1;j<=n+1;j++){
			if(a[i][j]!=0){
				cout<<a[i][j]<<' ';
			}
		}
		cout<<endl;
	}
	return 0;
} 
```

---

## 作者：Lovelace_qwq (赞：4)

梦回学而思四年级奥数。感动。

## 题目大意

输出杨辉三角的前 $n$ 行。

## 思路

杨辉三角是一个特殊的数阵。

```
       1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
  1 5 10 10 5 1
```
通俗地讲，杨辉三角中的一个数就等于其上方两个数的和。杨辉三角的两边上的值都为 $1$。

也就是：

$a_{1,1}=1$

$a_{i,j}=a_{i-1,j-1}+a_{i-1,j}$

得到递推方程之后代码就很好写了。记得要初始化。

## 代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<climits>
#define ll long long
#define endl '\n'
using namespace std;
int n;
int a[25][25];
main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	a[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			a[i][j]=a[i-1][j-1]+a[i-1][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Ashankamiko (赞：3)

# 题目简述
### 题意
输出 $n$ 行杨辉三角。
### 杨辉三角
其实类似于斐波那契数列，不过是二维的，杨辉三角满足以下要求。
- 对于每一行，第 $1$ 项和最后一项的值为 $1$。
- 每一行其中间的部分其实就是上面一个数和上面那个数的左边那个数的和。

因此我们很好模拟，用 $number_{i,j}$ 表示杨辉三角 $(i,j)$ 的值，若 $j$ 不等于 $1$ 并且不等于 $i$，我们就令 $number_{i,j} \gets number_{i-1,j}+number_{i-1,j-1}$。

用 $number$ 数组主要是为了记录上一个数，直接输出就无法记录。本题的 $n$ 非常小，所以我们无需将 $number$ 转化为一维数组。
## [AC 代码](https://www.luogu.com.cn/record/218954537)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout

int main() {
	int n;
	in >> n;
	int number[n + 1][n + 1]; //定义number数组杨辉三角
	memset(number, 0, sizeof(number)); //重置
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			if (i == 1 || j == i) //特殊项
				number[i][j] = 1;
			else //否则求上面两个数的和
				number[i][j] = number[i - 1][j] + number[i - 1][j - 1];
			out << number[i][j] << ' '; //然后输出
		}
		out << '\n';
	}
	return 0;
}
```

---

## 作者：fjtMESSI10 (赞：2)

## 思路
杨辉三角的规律：每一行第一个和最后一个数为一，其余数为它正上方的数加上左上方的数，因此可以推导出以下公式：
```cpp
a[i][j] = a[i - 1][j] + a[i - 1][j - 1];
```
所以我们只需要打一下特判再套用这个公式来对每个数赋值，用二维数组存起来，最后输出就行了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[10005][10005];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			if (j == 1 || j == i) {
				a[i][j] = 1;

			} else {
				a[i][j] = a[i - 1][j] + a[i - 1][j - 1];
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			cout << a[i][j] << " ";

		}
		cout << endl;
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

杨辉三角满足：
- 第 $k$ 行有 $k$ 个数，且首尾数字均为 $1$。
- 对于任意满足 $1<i<k$ 的 $i$ 都有 $a_{k,i}=a_{k-1,i-1}+a_{k-1,i}$。

我们可以看作每一行最前面都有一个 $0$，每一行后面也都有一个 $0$。即：

```
0 1 0
0 1 1 0
0 1 2 1 0
0 1 3 3 1 0
0 1 4 6 4 1 0
0 1 5 10 10 5 1 0
```

那么除 $0$ 和第一行的 $1$ 外所有三角中的数都满足 $a_{k,i}=a_{k-1,i-1}+a_{k-1,i}$。

那么按上式递推即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1002;
int a[N][N];

int main(){
	int n;cin>>n;a[1][1]=1;cout<<"1\n";
	for(int i=2; i<=n; i++,cout<<"\n")
		for(int j=1; j<=i; j++){
			a[i][j]=a[i-1][j-1]+a[i-1][j];
			cout<<a[i][j]<<" ";
		}
	return 0;
}
```

---

## 作者：sacc (赞：1)

## 题目大意
输出杨辉三角的前 $n$ 行。

杨辉三角就是每一行第一个和最后一个数为一，其余数为它正上方的数加上左上方的数。

可以用标准的动态规划来做。

## 解决方法

可得出转移方程。

```cpp
a[i][j]=a[i-1][j]+a[i-1][j-1];
```

先预处理，然后输出即可。

但不要忘了每一行第一个，这需要特别预处理。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1001][1001];
signed main()
{
  	//freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n;
	//边上。 
	for(int i=1;i<=n;i++)
	{
		a[i][i]=1;
		a[i][1]=1;
	}
	//正常预处理。 
	for(int i=3/*注意从3开始*/;i<=n;i++)
	{
		for(int j=2/*注意从2开始*/;j<=i-1/*注意从i-1开始*/;j++)
		{
			a[i][j]=a[i-1][j-1]+a[i-1][j];
		}
	}
	//输出。 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：xishihui_QWQ (赞：1)

仍然得大致讲讲思路：首先我们可以发现前两行是固定的，都是：1，11。从第二行开始，第一列和最后一列都为一，中间的数字上是相同位置但上一行的数字相加。
     没什么好讲的，上代码！
     
     a=int(input())
     c=[]
     for i in range(a+1):#创建三角基本框架
     b=[]
     c.append(b)
     c[0].append(1)  
     c[1].append(1)
     c[1].append(1)#前两行添加的数
     for i in range(2,a+1):
     c[i].append(1)#第一列
     for ii in range(1,1+i-1):
        c[i].append(c[i-1][ii-1]+c[i-1][ii])
     c[i].append(1)#最后一列
     for i in range(a):
     for ii in range(i+1):
          print(c[i][ii],end=" ")
      print("")

---


# 【深基7.例7】计算阶乘

## 题目描述

求 $n!$，也就是 $1\times2\times3\dots\times n$。

挑战：尝试不使用循环语句（for、while）完成这个任务。

## 说明/提示

数据保证，$1 \leq n\le12$。

## 样例 #1

### 输入

```
3```

### 输出

```
6```

# 题解

## 作者：Python147 (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P5739)

## 题目分析

### 基本思路

本题要求计算 $n!$，但题目要求不使用循环来完成此题，那我们可以尝试递归。

### 实现细节

首先我们要了解什么是函数。我们之前学过循环，部分程序段需要反复执行时可以使用循环。但是在一些情况下，我们无法通过循环来减少工作量。这时候我们就要使用函数了。

#### 函数定义的语法形式

```cpp
数据类型 函数名(形式参数表)
{
    函数体;
}
```

**注意事项**：

- 函数的数据类型指函数的返回值类型（如果类型为`void`，表示无返回值）
- 形式参数表可以为空。
- 函数**不允许**嵌套定义！

#### 递归函数

当函数的定义中，其内部操作有直接或间接地出现对自身的调用，则称这样的程序嵌套地定义为**递归定义**。

递归通常将一个大问题层层转化为多个小问题来进行求解，大大减小了程序的代码量。

例如本题的求阶乘，就可以用下面的递归式表示：

- 当 $x$ 为 $0$ 时，$f(x) = 1$。
- 当 $x > 0$ 时，$f(x) = f(x - 1) \times x$。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int f(int x)
{
	if (x == 0)
		return 1;
	return f(x - 1) * x;
}

int n;

int main()
{
	cin >> n;
	cout << f(n) << endl;
	return 0;
}
```

---

## 作者：cirrationaler (赞：3)

## 知识铺垫

用户可以优先阅读 [函数](https://oi-wiki.org/lang/func/)、[递归](https://oi-wiki.org/basic/divide-and-conquer/) 相关知识点。

递归的本质就是写一个自己调用自己的函数。但是需要注意的是，函数不能无限地去自己调用自己。

如下面的 `work(n)` 会调用 `work(n - 1)`，而 `work(n - 1)` 会调用 `work(n - 2)`，以此类推。

这个时候我们应当写一个终止条件，当函数递归到 $1$，即 $x = 1$ 的时候，终止函数。

```cpp
long long work(int n)
{
    if (n == 1) // 函数调用终止条件,当函数调用到 x = 1 的时候,就停止
    {
        return 1;
    }
    else // 否则调用 work(n - 1),返回 n * work(n - 1)
    {
        return n * work(n - 1);
    }
}
```

## 题目分析

~~本题可以采用循环的方法解决（但题目不允许）。~~

我们可以采用递归的方法解决这道题。

本题求 $n!$，也就是 $1 \times 2 \times 3 \dots \times n$。

我们可以采用递归的方法从大到小依次递归，最终直接输出 `work(n)`。

需要注意的是：本题的数据范围是 $1 \le n \le 12$。当 $n = 12$ 时，$n!$ 超过了 `int` 范围，所以应当使用 `long long`。

## 代码

```cpp
// P5739 【深基7.例7】计算阶乘
// code by:cq_irritater
// time:2025/06/26
#include <bits/stdc++.h>

using namespace std;

int n;

long long work(int n)
{
    if (n == 1)
    {
        return 1;
    }
    else
    {
        return n * work(n - 1);
    }
}

int main()
{
    // freopen("code.in", "r", stdin);
    scanf("%d", &n);
    printf("%lld", work(n));
    return 0;
}

```

---

## 作者：_OokoukioO_ (赞：0)

# 题目简述
### 题意
给定 $n$，求 $n!$。
### 思路
由于 $n \le 12$，所以连 `int` 都不会爆，我们直接模拟即可。
### 阶乘
> 定义 $n!$ 为 $n$ 的阶乘，$n!=n \times (n-1) \times (n-2) \dots \times 1$，特别地，$0!=1$。
### [AC 代码](https://www.luogu.com.cn/record/221902774)
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;

int f(int x, int res) {
    if (x == n + 1) //递推边界
        return res;
    return f(x + 1, res * x); //继续递推
}

signed main() {
	cin >> n;
	cout <<f(1, 1); //输出答案
	return 0;
}
```

---

## 作者：tiantian0820 (赞：0)

## 题目描述

求 $n!$，也就是 $1\times2\times3\dots\times n$。

先输入一个正整数。

### 题目思路

由于题目有乘法，我们不能通过直接用条件判断，挑战尝试不使用循环语句找到答案，如何解决呢？

我们发现，阶乘有这样的计算方法。

$$ 
n! = \begin{cases}
1 , & n=0 \\
n \times (n-1)!  , & n>0
\end{cases}
$$ 

所以我们可以写一个递归函数完成这个任务。 

### 说明/提示

由于 $n$ 的范围很小，数据保证， $1 \leq n\le12$  ，可以用 int 整数。

### 代码


```cpp
#include <cstdio>
typedef unsigned int ii;
using namespace std;
ii f(ii n){
	if(n==1){
		return 1;
	}return n*f(n-1);
}
int main() {
  ii n;
  scanf("%d",&n);
  printf("%d",f(n));
  return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P5739)
## 题目分析
希望审核大大给过。

这道题考虑**递归**。

当函数的定义中，其内部操作有直接或间接地出现对自身的调用，则称这样的程序嵌套地定义为**递归定义**。

定义 $x$ 的阶乘为 $f(x)$。

已知 $0$ 的阶乘为 $1$，则：
$$
f(0)=1
$$
那么 $f(x)$ 为：
$$
f(x)=f(x-1) \times x
$$

题目保证数据，所以可以使用 `int`。（我使用的是 `long long`）

递归代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define speed ios::sync_with_stdio(0),cin.tie(0), cout.tie(0);
int f(int x){
	if (x == 0||x == 1)
		return 1;
	return f(x - 1) * x;//递归
}
int n;
signed main(){
    speed
	cin >> n;
	cout << f(n);
	return 0;
} 
```

---


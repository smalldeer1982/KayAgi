# 【深基7.习8】猴子吃桃

## 题目描述

一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；接下来的每一天它都会吃剩余的桃子的一半外加一个。第 $n$ 天早上起来一看，只剩下 $1$ 个桃子了。请问小猴买了几个桃子？

## 说明/提示

数据保证，$1\le n\le20$。

## 样例 #1

### 输入

```
4```

### 输出

```
22
```

# 题解

## 作者：UnyieldingTrilobite (赞：97)

upd：修复一个推导错误（结论无误）。

来讲一种$O(1)$算法（可能超出新手范围？）

**动态规划。**

设$ans_i$表示$n=i$时的答案。

显然$ans_1=1$（如果不明白······建议重新读题。）.

怎么转移？

列方程$\frac{ans_i}{2}-1=ans_{i-1}$.

解得$ans_i=2(ans_{i-1}+1)$.

**前方高能。**

归纳$ans_n=3\times 2^{n-1}-2$.

$n=1$时$1=1$成立。

若$n=k$时成立，即$ans_k=3\times 2^{k-1}-2$

则对于$n=k+1,ans_{k+1}=2(ans_k+1)=2(3\times 2^{k-1}-2+1)=3\times 2^{k}-2$.

也成立。

所以对于一切正整数$n$均成立。

所以······程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<(1<<n-1)*3-2;
    return 0;
}
```
怎么想到？两种方法：

第一：动态规划打表找规律+归纳。

第二：把递推公式的$ans_{i-1}$继续展开，会得到一串等比数列，求和化简+归纳即可。

Over.

---

## 作者：xzk2012 (赞：11)

思路：答案初始为 1 个。循环，先加 1 个再乘 2 （因为猴子少吃一个就是原来的一半）。输出最后答案
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=1;
int main(){
    cin>>n;
    for(int i=0;i<n-1;i++){
        ans+=1;
        ans*=2;
    }
    cout<<ans;
    return 0;
}
```
求赞。

---

## 作者：Luogu_Wangzhi (赞：3)

# 题解：P5743 【深基7.习8】猴子吃桃。

### 解法：

- 从第 $n$ 天倒推。

- 那么 $n - 1$ 天就是 $ans \gets (1 + 1) \times 2 = 4$ 个桃子。

- 也就是每减去 $1$ 天 $ans \gets (ans + 1) \times 2$。

### code


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int ans=1;//剩下一个桃子
	int n;
	cin>>n;
	for(int i=1;i<n;i++){
		ans=(ans+1)*2;
	}
	cout<<ans;
} 
```

---

## 作者：SigN_285 (赞：3)

## 题解

本题是经典的逆推问题。题意是：每天吃剩下桃子的一半再多吃一个，第 $n$ 天早上只剩下 $1$ 个桃子，问最初有多少个桃子。

### 分析

我们可以**从第 $n$ 天往前倒推**。  
- 设第 $k$ 天早上有 $x_k$ 个桃子，则第 $k$ 天吃掉 $(x_k/2)+1$ 个，剩下 $x_{k+1}$ 个。
- 由题意，$x_{k+1} = x_k - (x_k/2 + 1) = x_k/2 - 1$，即 $x_k = 2(x_{k+1} + 1)$。

已知第 $n$ 天早上 $x_n = 1$，我们可以递推 $n-1$ 天，直到第 $1$ 天。

### 代码实现

````cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int x = 1; // 第n天早上剩下1个
    for (int i = 1; i <= n - 1; ++i) {
        x = 2 * (x + 1);
    }
    cout << x << endl;
    return 0;
}
````

### 总结

- 本题关键是逆向递推公式 $x_k = 2(x_{k+1} + 1)$。
- 只需循环 $n-1$ 次即可得到答案，复杂度 $O(n)$，非常高效。

---

## 作者：_OokoukioO_ (赞：2)

# 题目简述
### 题意
猴子每天都要吃剩下桃子的一半多一个，过了 $n$ 天只剩 $1$ 个，求原本有多少个桃子。
### 思路
很简单的反推。

多吃一个，然后再吃一半，反过来就是先加一个，再翻一个倍，那么我们只需这样操作 $n-1$ 次就是原来的数量，因为最后一天是不算的。
## [AC 代码](https://www.luogu.com.cn/record/221902693)
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans = 1;

int main() {
	cin >> n; //天数
	for (int i = 1; i < n; i++) //注意是n-1天
		ans += 1, ans *= 2; //推公式
	cout << ans; //输出答案
	return 0;
}
```

---

## 作者：cirrationaler (赞：2)

简单进行数学推导即可。

由于小猴每一天都会吃剩余的桃子的一半外加一个，所以我们可以采取倒推法。

由最后的数据 $1$ 可知，最后一天剩一个桃子。我们可以把 `ans` 赋值为最后的 $1$。然后循环 $n$ 天，每一天都是原来的数量加 $1$ 然后乘以 $2$ 即可。（注意：**必须先加后减**）

需要注意的是：第 $n$ 天小猴并没有吃桃子。

```cpp
// P5743 【深基7.习8】猴子吃桃
// code by:cq_irritater
// time:2025/06/26
#include <bits/stdc++.h>

using namespace std;

int n;
int ans;

int main()
{
    // freopen("code.in", "r", stdin);
    scanf("%d", &n);
    ans = 1;
    for (int i = 1; i < n; i++)
    {
        ans += 1;
        ans *= 2;
    }
    printf("%d", ans);
    return 0;
}

```

---

## 作者：Eric1030 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P5743)

## 思路讲解
这道题可以用倒推的思想，例如今天吃之前剩 $x$ 个桃子，那么昨天吃之前剩 $(x+1)\times 2$ 个，那么现在代码就能出来了。

主要部分的代码框架如下。

```cpp
for(int i=1;i<=天数;i++)
{
	桃数先加1再乘2
}
```

## [AC](https://www.luogu.com.cn/record/185151707) 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, cnt = 1;//最后一天剩1个桃子
int main()
{
	cin >> n;
	for (int i = 1; i <= n - 1; i++)//第n天没吃，所以是i是从1~n-1
	{
		cnt = (cnt + 1) * 2;//倒推，每天吃剩下的一半多一个，那么先把多吃的1个补上，再乘2。
	}
	cout << cnt;
	return 0;//结束！
}
```

---


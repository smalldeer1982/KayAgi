# Hello, 2020!

## 题目背景

时针与分针重合在「零」的那一霎那，嘀嗒声便宣告了新一年的到来。

在过去的一年里，世事无常。屏幕面前的你可能不久前才听闻「OI」，也可能暂时地结束了竞赛生涯；可能在赛场上叱咤风云名列榜首，也可能独自承受着比赛失利的落寞。

无论如何，过去仍旧是过去，将来依然是将来。

以此题为开端，迎接你的 2020 吧！

## 题目描述

本场比赛有 $n$ 名出题人，$m$ 名选手。

出题人从 $1$ 至 $n$ 依次标号，选手从 $1$ 至 $m$ 依次标号。

比赛结束后选手的最终排名为 $1$ 至 $m$ 中其一，且互不相同。

报名结束后，第 $i$ 位出题人看了看报名列表，对其他出题人说：「我觉得只有这 $k_i$ 位选手有可能最终排名第一，他们分别是 $a_{i,1},a_{i,2},\dots,a_{i,k_i}$。其他人不可能最终排名第一。」

你面前屏幕上的这道题的出题人通过时空隧道，预先得知了谁是最终排名第一的选手。

出题人把这 $n$ 位出题人的预测都告诉了你，还告诉你恰好只有 $p$ 个出题人的预测是正确的。

请你求出哪些选手可能最终获得第一名，并以从小到大的顺序依次输出这些选手的编号。

## 说明/提示

子任务 1（$6\%$）：$n\leq 20$，$m\leq 20$。

子任务 2（$30\%$）：$n\leq 100$，$m\leq 100$，$\sum k_i \leq 10^4$。

子任务 3（$24\%$）：$n\leq 1000$，$m\leq 1000$。

子任务 4（$40\%$）：无特殊限制。

对于全部数据，$1\leq n\leq 10^5$，$1\leq m\leq 10^6$，$0\leq \sum k_i \leq 10^6$，$0\leq p\leq n$。

## 样例 #1

### 输入

```
4 3 2
2 2 3
1 1
3 1 2 3
2 1 3
```

### 输出

```
1
2
```

# 题解

## 作者：mrsrz (赞：216)

本题作为月赛的签到题，思维难度低。

题意是有 $n$ 位出题人，$m$ 位选手，并给出一个数 $p$。

每位出题人会钦定一些选手（同一位出题人钦定的选手不同）。

问有多少名选手恰好被钦定了 $p$ 次。

对选手开一个数组，记录每位选手被钦定的次数。

每次被钦定的时候，对应的数组元素加一。

最后数一下数组中有多少个元素恰好为 $p$，并输出即可。

# 咳咳，贴个代码。

```plain
施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf => buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s => s.split(/[ \n]/))」於「數據」。昔之「數據」者。今其是矣。

有數一。名之曰「子」。

夫「數據」之一。取一以施「parseInt」。名之曰「出題人」。
加「子」以一。夫「數據」之其。取一以施「parseInt」。名之曰「選手」。
加「子」以一。昔之「子」者。今其是矣。
加「子」以一。夫「數據」之其。取一以施「parseInt」。名之曰「正確的預判個數」。
加「子」以一。昔之「子」者。今其是矣。

吾有一列。名之曰「數組」。為是「選手」遍。充「數組」以零也。

有數零。名之曰「甲」。

恆為是。若「甲」等於「出題人」者乃止也。
  加「子」以一。夫「數據」之其。取一以施「parseInt」。名之曰「預判」。
  加「子」以一。昔之「子」者。今其是矣。
  有數一。名之曰「易」。恆為是。若「預判」小於「易」者乃止也。
    加一以「易」。昔之「易」者。今其是矣。
    加「子」以一。夫「數據」之其。取一以施「parseInt」。名之曰「編號」。
    加「子」以一。昔之「子」者。今其是矣。
    吾有一數。名之曰「錢」。
    昔之「錢」者。今「數組」之「編號」是矣。
    加一以「錢」。昔之「數組」之「編號」者。今其是矣云云。
  加一以「甲」。昔之「甲」者。今其是矣。
云云。

有數零。名之曰「輸出」。

吾有一列。名之曰「人贏」。

有數零。名之曰「乙」。恆為是。若「乙」等於「數組」之長者乃止也。
  加一以「乙」。昔之「乙」者。今其是矣。
  若「數組」之「乙」等於「正確的預判個數」者 充「人贏」以「乙」也。
  若「數組」之「乙」等於「正確的預判個數」者 加一以「輸出」。昔之「輸出」者。今其是矣云云。
云云。

吾有一言。曰「輸出」。書之。

施「(s => s.join(' '))」於「人贏」。書之。

注曰。「「勿忘今天下大雨」」。
```

---

## 作者：DreamFox (赞：30)

本题思路：

因为第一名会被$p$名出题人预测，所以只要被$p$名出题人预测到的选手都有可能拿第一名，我们就可以用数组储存他们的出现次数，如果一共出现$p$次，就把这位选手的编号存入数组，最后从小到大排序即可。

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int c[1000001],t,s[1000001],sum,d;
int main()
{
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=0;i<n;i++)
	{
		scanf("%d",&t);
		while(t--)
		{
			scanf("%d",&d);
			++c[d];
		}
	}
	for(int i=1;i<=m;i++)
	if(c[i]==p)
	{
		s[sum]=i;
		++sum;
	}
	printf("%d\n",sum);
	sort(s,s+sum);
	for(int i=0;i<sum;i++)
	printf("%d ",s[i]);
	printf("\n");
	return 0;
}

```


---

## 作者：无产者万岁 (赞：16)

本蒟蒻又来发题解啦！萌新可看，dalao请轻喷。  

首先，我们需要理解这道题的题意，题目是这样的：有m个选手参加一个比赛，而有n个~~预言家、神棍~~出题人认为其中的k位选手可能拿到第一，而其中有一位~~神棍~~出题人穿越时空，得知了有p个~~预言家~~猜测准确，求拿到第一的可能是哪些选手。       
							
 一拿到这题，恐怕很多人的想法都是暴力，~~（me too）~~，但经过我的反复思考，发现了一种更简单易懂的方法，那就是用数组标记每位选手得票数，若这个选手得票数为p，他就是可能的冠军。
 
 这么一理顺，这道题就能迎刃而解，话不多说，小二，上代码！
```
#include <bits/stdc++.h>
using namespace std;
int n,m,p,bk[100000001],t,g,df[10000001],co=0,ans=0;
int main()
{
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++)
	{
		cin>>t;
		for(int j=1;j<=t;j++)
		{
			cin>>g;
			bk[g]++;		
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(bk[i]==p)
		{
			ans++;
			co++;
			df[co]=i;
		}
	}	
	cout<<ans<<endl;
	for(int i=1;i<=co;i++)
		cout<<df[i]<<" ";
	return 0;		
}
```

如果做完此题，还可以做这一道题：P5594 【XR-4】模拟赛   
             BYE~~~

---

## 作者：低調 (赞：10)

~~蒟蒻第一篇题解~~

进入新年的第一场月赛，点开第一题，令人惊喜的是没有样例
~~（后来有了）~~
，但在没有样例的时候，题意确实有点难读懂。

仔细读题就会发现，其实题意就是：要你找出正好出现了$p$次的人数以及人的编号。

~~就这样，我再没有样例的情况下大胆提交，然后莫名AC。~~

下面上代码：~~(朴素算法)~~ 

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read() {//快读
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-')ch=getchar();
	if(ch=='-')ch=getchar(),f=-1;
	while(isdigit(ch))x=(x*10)+(ch^48),ch=getchar();
	return x*f;
}
int a[1000001],p,n,m,i,j,s,u,tot;
int main() {
	n=read(),m=read(),p=read();
	for(i=1; i<=n; i++) {
		s=read();//读入人数
		for(j=1; j<=s; j++) {
			u=read();//读入可能的人
			a[u]++;//出现次数加++
		}
	}
	for(i=1; i<=m; i++) {
		if(a[i]==p)tot++;//判断是否出现了正好p次，总数++
	}
	printf("%d\n",tot);//输出总数
	for(i=1; i<=m; i++) {
		if(a[i]==p)printf("%d ",i);//再扫一遍，输出可能的人
	}
	return 0;
}
```

---

## 作者：rfsfreffr (赞：5)

这题看起来很难，其实很水（名副其实的签到题）

由于**恰好只有 p 个出题人的预测是正确的。** 

所以如果有一个人他有可能拿第一，**那么他会正好被p个出题人预测为第一名** 

直接桶排即可

# 代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int k[1000001];
int mp[1000001];

int p;
int main(){
	cin>>n>>m>>p;
	for(int i=1; i<=n; i++){//读入
		scanf("%d",&k[i]);
		for(int j=1; j<=k[i]; j++){
			int x;
			scanf("%d",&x);
			mp[x]++;//计录标号为x的人被预测为第一名的次数
		}
	}
	int ans=0;
	for(int i=1; i<=m; i++){
		if(mp[i]==p){//计算答案（及被预测为第一名人的个数）
			ans++;
		}
	}
	cout<<ans<<endl;
	for(int i=1; i<=m; i++){//输出他们（指被预测p次第一名的人）的编号
		if(mp[i]==p){
			printf("%d ",i);
		}
	}
	return 0;
}
```

---

## 作者：gyh20 (赞：4)

读过题目，我们可以发现，如果一个人是第一，那么所有判断他为第一的评委是对的，其他所有人都是错的。所以只需要判断认为一个人为第一是否恰好为$p$个即可。

代码如下：
```cpp
#include<cstdio>
using namespace std;
#define re register
const int Mxdt=500;
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
#define gc getchar
inline int read()
{
	int res=0;char ch=gc();
	while(ch<'0'||ch>'9')ch=gc();
	while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=gc();
	return res;
}
int n,m,a[1000002],p,b,ans;
int main(){
	n=read()+1;
	m=read(); 
	p=read();
	while(--n){
		b=read()+1;
		while(--b){
			++a[read()];
		}
	}
	for(re int i=1;i<=m;++i)if(a[i]==p)++ans;
	printf("%d\n",ans);
	for(re int i=1;i<=m;++i)if(a[i]==p)printf("%d ",i);
}
```


---

## 作者：Raw_Aya9285 (赞：4)

这次的T1我因为格式拖了好久（允悲）

首先我们可以分析一下样例中的预测部分：

```
2 3
1
1 2 3
1 3
```

我们来进行推理：

第 1 条和第 2 条不可能同时对，因为一个说 1 会赢，一个说 2 和 3 会赢，互相冲突。

假设第 1 和第 3 条是对的，那么剩下两条都是错的，也就是说第一名必须在 2 和 3 中产生，但不可能是 1 和 3，可得 2 有可能在第一名。

再来假设 1 和 4 都是对的，那么剩下两条是错的，也就是说第一名必须是 3，同时不能是 1 或 2 或 3，显然冲突。

剩下的不用我假设了，诸位可以自己推推。

这样，我们可以很容易得到，如果一个选手有可能成为第一名，那么他被预测的次数一定等于正确预测数。因为如果被预测次数大于正确预测数，那么我们在确定若干个预测时必定有一个其他的预测与这些预测矛盾。如果小于，则不足以证明有可能是第一名。

代码思路就这样出来了，奉上没有优化的代码，至于如何优化大家可以自己思考。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,buc[1000001],k,p,t,ans,tmp,print[1000001];
int main(){
    scanf("%d%d%d",&n,&m,&p);//输入
    for(int i=1;i<=n;i++){
        scanf("%d",&t);
        for(int j=1;j<=t;j++){
            scanf("%d",&k);
            buc[k]++;//存入桶中
        }
    }
    for(int i=1;i<=m;i++){
        if(buc[i]==p){//判断是否满足条件
            ans++;
            print[ans]=i;
        }
    }
    printf("%d\n",ans);
    for(int i=1;i<=ans;i++){
        printf("%d\n",print[i]);//输出
    }
    return 0;
}
```
大水题一道，所以我就不多说惹QwQ感谢阅读

---

## 作者：　　　吾皇 (赞：4)

~~随手一交最优解~~

### 分析

- 由于 `恰好只有 p 个出题人的预测是正确的` ，所以如果选手 $i$ 排名第一，那么必定有 $p$ 个出题人预测他能赢。
- 那么只需要用类似桶排的方法，对于第 $i$ 个人，统计他被多少人预测即可。如果有 $p$ 个人，则将这个人的编号输出。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m,p,k,xs[1000001],ans[1000001],top;//xs用来存储选手被预测的数目，ans存储答案编号
static char buf[100000],*pa=buf,*pb=buf;
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
inline int read(){
    register int x(0);register char c(gc);
    while(c<'0'||c>'9')c=gc;
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc;
    return x;
}//快读
int main(){
	n=read(),m=read(),p=read();
	while(n--){
		k=read();
		while(k--) xs[read()]++;//将该预测数加到选手上
	}
	for(register int i=1;i<=m;i++) if(xs[i]==p) ans[++top]=i;//如果当前选手满足题意，则存储进来
	printf("%d\n",top);//输出满足数
	for(register int i=1;i<=top;i++) printf("%d ",ans[i]);//导出答案
}
```


---

## 作者：andyli (赞：3)

一位选手可能最终获得第一名当且仅当有$p$位出题人预测她可能最终排名第一。因此我们首先统计每位选手被多少位出题人预测她可能最终排名第一，若有$p$位出题人预测她可能最终排名第一，则把她加入答案中。  
主要代码如下：  
```cpp
const int maxn = 1000005;

int cnt[maxn];
int main()
{
    int n, m, p;
    io.read(n, m, p);
    for (int i = 1; i <= n; i++) {
        int k;
        io.read(k);
        for (int j = 1; j <= k; j++) {
            int a;
            io.read(a);
            cnt[a]++;
        }
    }
    vector<int> v;
    for (int i = 1; i <= m; i++)
        if (cnt[i] == p)
            v.push_back(i);
    writeln(v.size());
    for (auto x : v)
        io.write(x, " ");
    writeln();
    return 0;
}
```

---

## 作者：友利奈緒 (赞：2)

签到题，但我还是做了快二十分钟.....

思路是一下子就有的

也就是用数组储存每个选手被出题人提名的次数

这里我是用一个a数组储存所有选手的被提名次数，一个b数组储存达到要求的选手次数。cnt表示达到要求的选手总数

```cpp

	for(int i=1;i<=n;i++)
	{
		cin>>k;
		for(int j=1;j<=k;j++)
		{
			cin>>x;
		    a[x]++;
		}
	}

```


因为正确预测数只有p个，所以如果一个人被提名的次数正好是p，那这个就是答案之一。

程序就出来了。
```cpp

int cnt=0;
	for(int i=1;i<=m;i++)
	{
		if(a[i]==p)
		{
		cnt++;
		b[cnt]=i;
		}
	}
	
```
但是我因为太蒻了居然没看到还要求先输出方案总数再输出答案，所以我看样例的1,2还以为是1,2符合要求，瞪了半天样例百思不得其解

然后明白之后想抽自己

然后我想明白之后，兴高采烈的交了以下代码
```cpp
#include<bits/stdc++.h>
#define int long long//个人写代码习惯
using namespace std;
int a[1000005]={};
int b[1000005]={};
signed main()//main函数只能int 而我int已经成了long long，故这也是习惯
{
	int n,m,p;
	cin>>n>>m>>p;
	int k,x;
	for(int i=1;i<=n;i++)
	{
		cin>>k;
		for(int j=1;j<=k;j++)
		{
			cin>>x;
		    a[x]++;
		}
	}
int cnt=0;
	for(int i=1;i<=m;i++)
	{
		if(a[i]==p)
		{
		cnt++;
		b[cnt]=i;
		}
	}
	cout<<cnt<<"\n";
	for(int i=1;i<=cnt;i++)
	cout<<b[i]<<"\n";
	return 0;
}
```
结果就又wa了，然后我仔细看了下题目要求

输出结果中间是空格不是换行

样例答案就一个所以我没有在意就直接打了换行

然后我将return 0上一行的"\n"改成' '就A了

所以啊这告诉我们

思路千万条，读题第一条，看题不规范，爆零两行泪






---

## 作者：Meatherm (赞：1)

显然如果某位选手被恰好 $p$ 位出题人钦定，那么他可能 Rank 1。

为什么呢？

如果这位选手被钦定的次数 $<p$，那么如果他 Rank 1 了，预测正确的出题人数量一定 $<p$。钦定次数 $>p$ 时同理。

所以开桶记录即可。

```cpp
# include <bits/stdc++.h>
# define rr register
const int N=1000010;
int a[N];
int cnt[N];
int m,n,p;
inline int read(void){
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;
}
int main(void){
	n=read(),m=read(),p=read();
	for(rr int i=1,k;i<=n;++i){
		k=read();
		for(rr int j=1;j<=k;++j){
			++cnt[read()];
		}
	}
	int ans=0;
	for(rr int i=1;i<=m;++i){
		if(cnt[i]==p){
			++ans;
		}
	}
	printf("%d\n",ans);
	for(rr int i=1;i<=m;++i){
		if(cnt[i]==p){
			printf("%d ",i);
		}
	}
	return 0;
}
```

---

## 作者：registerGen (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5886)

设 $h_i$ 为 $i$ 在所有的 $a_{x,y}$ 中出现的次数。

对于每一个 $i$，如果 $h_i=p$，那么就有恰好 $p$ 个人预测 $i$ 会得 $\text{r1}$，即为所求。

---

```cpp
#include<cstdio>
#include<algorithm>

const int N=1e5,M=1e6;

int h[M+10];
int Ans[M+10],ptr;

template<typename T>
inline T read(T& x)
{
	x=0;int f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}

template<typename T>
inline void write(T x)
{
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}

int main()
{
	int n,m,p;
	read(n),read(m),read(p);
	for(int i=1;i<=n;i++)
	{
		int k;
		read(k);
		for(int j=1;j<=k;j++)
		{
			int x;
			read(x);
			h[x]++;
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++)
		if(h[i]==p)Ans[++ptr]=i,ans++;
	printf("%d\n",ans);
	for(int i=1;i<=ans;i++)
		write(Ans[i]),printf(" ");
	printf("\n");
	return 0;
}
```

---

## 作者：宝硕 (赞：0)

## 提示
非本人解法：
原作者：[@mrsrz](https://www.luogu.com.cn/user/6813)

本解法来自：[https://www.luogu.com.cn/blog/Mrsrz/solution-p5886](https://www.luogu.com.cn/blog/Mrsrz/solution-p5886)


使用 [文言在线IDE](http://wenyan-lang.lingdong.works/ide.html) 翻译成 JavaScript 语言。
**~~可读性更高~~**

 
## 题意解释

原文：

  本题作为月赛的签到题，思维难度低。

  题意是有 
  $n$
  位出题人，
  $m$
  位选手，并给出一个数 
  $p$
  。

  每位出题人会钦定一些选手（同一位出题人钦定的选手不同）。

  问有多少名选手恰好被钦定了 
  $p$
  次。

  对选手开一个数组，记录每位选手被钦定的次数。

  每次被钦定的时候，对应的数组元素加一。

  最后数一下数组中有多少个元素恰好为 
  $p$
  ，并输出即可。

## 代码
```javascript
var _ans1 = require('fs').readFileSync("/dev/stdin");
var 數據 = _ans1;
var _ans2 = (buf => buf.toString().trim())(數據);
數據 = _ans2;
var _ans3 = (s => s.split(/[ \n]/))(數據);
數據 = _ans3;
var 子 = 1;
var _ans4 = 數據[1 - 1];
var _ans5 = parseInt(_ans4);
var 出題人 = _ans5;
var _ans6 = 子 + 1;
var _ans7 = 數據[_ans6 - 1];
var _ans8 = parseInt(_ans7);
var 選手 = _ans8;
var _ans9 = 子 + 1;
子 = _ans9;
var _ans10 = 子 + 1;
var _ans11 = 數據[_ans10 - 1];
var _ans12 = parseInt(_ans11);
var 正確的預判個數 = _ans12;
var _ans13 = 子 + 1;
子 = _ans13;
var 數組 = [];
for (var _rand1 = 0; _rand1 < 選手; _rand1++) {
    數組.push(0);
};
var 甲 = 0;
while (true) {
    if (甲 == 出題人) {
        break;
    };
    var _ans14 = 子 + 1;
    var _ans15 = 數據[_ans14 - 1];
    var _ans16 = parseInt(_ans15);
    var 預判 = _ans16;
    var _ans17 = 子 + 1;
    子 = _ans17;
    var 易 = 1;
    while (true) {
        if (預判 < 易) {
            break;
        };
        var _ans18 = 1 + 易;
        易 = _ans18;
        var _ans19 = 子 + 1;
        var _ans20 = 數據[_ans19 - 1];
        var _ans21 = parseInt(_ans20);
        var 編號 = _ans21;
        var _ans22 = 子 + 1;
        子 = _ans22;
        var 錢 = 0;
        錢 = 數組[編號 - 1];
        var _ans23 = 1 + 錢;
        數組[編號 - 1] = _ans23;
    };
    var _ans24 = 1 + 甲;
    甲 = _ans24;
};
var 輸出 = 0;
var 人贏 = [];
var 乙 = 0;
while (true) {
    if (乙 == 數組.length) {
        break;
    };
    var _ans25 = 1 + 乙;
    乙 = _ans25;
    if (數組[乙 - 1] == 正確的預判個數) {
        人贏.push(乙);
    };
    if (數組[乙 - 1] == 正確的預判個數) {
        var _ans26 = 1 + 輸出;
        輸出 = _ans26;
    };
};
var _ans27 = 輸出;
console.log(_ans27);
var _ans28 = (s => s.join(' '))(人贏);
console.log(_ans28);
console.log(_ans29);
```

##### 复制有坑



---

## 作者：ARLEN_KHL (赞：0)

# 简单模拟
## 输入的时候，输入的那个编号所在数组++
## 然后最后循环一遍，看看那个编号的数等于p
## 就可以了
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue <int,vector<int>,greater<int> > q;
int n,m,p;
int sum=0;
int xuan[1000010];
int main(void)
{
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++)
	{
		int k;
		cin>>k;
		for(int j=1;j<=k;j++)
		{
			int a;
			cin>>a;
			xuan[a]++;
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(xuan[i]==p)
		{
			sum++;
			q.push(i);
		}
	}
	cout<<sum<<endl;
	while(!q.empty())
	{
		cout<<q.top()<<" ";
		q.pop();
	}
	return 0;
 } 
```


---

## 作者：Celtic (赞：0)

希望大家2020年做题多一点，分数多一点。祝你新年快乐，学业有成，愿得学习心，白首不分离。


------------

以上为问候语。

[题目链接](https://www.luogu.com.cn/problem/P5886?contestId=24709)

题意：有$n$个人做了比赛第一名的范围预测，其中有$p$个是正确的，问可能为第一名的人有哪些？

明确：这个人可能为第一名，当且仅当预测他为第一名的人有且仅有$p$个。

所以每有一个人预测了这个人为第一名，就把这个人的计数器加$1$，然后暴力枚举判断即可。

代码

```cpp
#include<bits/stdc++.h>
#define N 2001001
#define MAX 2001
#define re register
#define inf 1e18
#define eps 1e-10
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,m,p,k[N],num,ans,all[N],head,sum[N];
signed main()
{
	read(n);
	read(m);
	read(p);
	for(re int i=1;i<=n;i++)
	{
		read(k[i]);
		for(re int j=1;j<=k[i];j++)
		{
			read(num);
			sum[num]++;
		}
	}
	for(re int i=1;i<=m;i++)
		if(sum[i]==p)
		{
			ans++;
			all[++head]=i;
		}
	printf("%lld\n",ans);
	for(re int i=1;i<=head;i++)
	{
		printf("%lld ",all[i]);
	}
	putchar('\n');
	exit(0);
}
```


---


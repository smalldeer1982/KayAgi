# [加油武汉] SIR 模型

## 题目背景

SIR 模型将总人口分为以下三类：

- 易感者(susceptibles)，其数量记为 $s(t)$ ，表示 $t$ 时刻未染病但有可能被该类疾病传染的人数；
- 染病者(infectives)，其数量记为 $i(t)$，表示 $t$ 时刻已被感染成为病人而且具有传染力的人数；
- 恢复者(recovered)，其数量记为 $r(t)$，表示 $t$ 时刻已从染病者中移出的人数。

设总人口为$N(t)$，则有$N(t)=s(t)+i(t)+r(t)$。  

SIR模型的建立基于以下三个假设：  

1. 不考虑人口的出生、死亡、流动等种群动力因素。人口始终保持一个常数，即 $N(t) \equiv K $。  
2. 一个病人一旦与易感者接触就必然具有一定的传染力。假设 $t$ 时刻单位时间内，一个病人能传染的易感者数目与此环境内易感者总数 $s(t)$ 成正比，比例系数为 $\beta$，从而在t时刻单位时间内被所有病人传染的人数为 $\beta s(t)i(t)$。  
3. $t$ 时刻，单位时间内从染病者中移出的人数与病人数量成正比，比例系数为$\gamma$，单位时间内移出者的数量为 $\gamma i(t)$。  

## 题目描述

我们将这个模型简化一下，初始有感染者 $I$ 人和易感者 $S$ 人，对于每一天当前有 $I_i$ 个感染者，$S_i$ 个易感者，$R_i$ 个恢复者，则每天会有 $\lceil \beta S_iI_i \rceil$ 人被感染（由易感者变成感染者），有 $\lceil \gamma I_i \rceil$ 人被治愈（由感染者变成恢复者） 。

其中 $\beta$ 为感染系数 $\gamma$ 为恢复系数 $\lceil \rceil$ 为上取整符号。 

求 $n$ 天后，有多少易感者 $S$，感染者 $I$，和恢复者 $R$ 。

注: 感染者和恢复者都是每天结算的，结算的结果只和当天开始的时候的值有关，即感染者当天恢复不影响他当天感染别人。

若计算被感染人数超过易感者人数则全员被感染。

## 说明/提示

对于 $30\%$ 的数据，$n=1$。  
对于另外 $30\%$ 的数据，$S_0, R_0\le 10^4$。  
对于 $100\%$ 的数据，$1 \le S_0+R_0\le 2\times 10^9, 0 < \beta, \gamma < 1, 1 \le n \le 100$。

## 样例 #1

### 输入

```
980 20 2
0.0005 0.00001```

### 输出

```
955 43 2```

## 样例 #2

### 输入

```
1400000000 1 10
0.000000003 0.001```

### 输出

```
1386791252 13205592 3157```

## 样例 #3

### 输入

```
1919 810 1
0.00001 0.1```

### 输出

```
1903 745 81```

# 题解

## 作者：槑小杨 (赞：199)

第一次看到这个入门题又有β又有γ什么乱七八糟的系数，

我还以为这个题投错了难度。

我再看一遍才发现这个题是真的水，

那些希腊字母都是~~骗蒟蒻的~~。

没看懂的建议再读一遍。

[点我回看](https://www.luogu.com.cn/problem/P6056)

### 下面我们把这道题~~翻译成人话~~




```
#include>iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#include<cstdlib>
using namespace std;
#define Kn 1000
#define Maxx 0x7fffffff
#define Minn -0x7fffffff
#define PI 3.1415926
int S,I,n,R;//R是恢复人数 
double beta,gamma;
int main()
{
	scanf("%d%d%d%lf%lf",&S,&I,&n,&beta,&gamma);
	while(n>0) //经过n天
	{
	    n--;//新一天 		
		int Si=ceil(beta*S*I);
		int Ii=ceil(gamma*I);
	    R+=Ii; 
	    if(Si>=S) //特判，所有人都被感染（坑）
	       I+=S-Ii,S=0;
	    else
	       I+=Si-Ii,S-=Si; 
	}    
	printf("%d %d %d\n",S,I,R);
	return 0;//完美结束 
	//如果不是有特判这道题真的一点难度都没有（滑稽） 
}
 

```
衷心提示：您直接复制肯定是过不了的


（喜欢的话请把右上角那个东西点亮吧）



管理员大大求过QAQ


---

## 作者：win10 (赞：17)

## ~~看到还没有人发题解就知道我的机会来了~~

这题目看起来很腻害的样子，又是β又是γ的，还向上取整，不过其实是一道

# 大水题
机房julao [peterha](https://www.luogu.com.cn/user/239895) 说的，可供膜拜（

他已经不屑于水题题解了（

扯远了，代码注释如下：
```cpp
#include<cstdio>
#include<cmath> // 不用万能头和cin不喜勿喷 
long long s,i,r,n; //后来发现不用long long也行 
double b,y;
int main() {
	scanf("%lld%lld%lld%lf%lf",&s,&i,&n,&b,&y); // 输入
	for(int j = 1;j <= n;j++) {
		long long s2 = ceil(b * s * i); // s2表示第i天感染人数 
		long long i2 = ceil(y * i); // i2表示第i天治愈人数 
		if(s2 <= s) { // 特判：如果感染人数小于易感人数 
			s -= s2;
			i += s2 - i2;
			r += i2; // 计算易感者s,感染者i，恢复者r，注意感染者的计算 
		}
		else { 
			i += s; // 所谓的全员感染 
			s = 0; // 易感人数变为0，否则会变成负数 
			i -= i2;
			r += i2;
		}
	}
	printf("%lld %lld %lld\n",s,i,r); // 输出
	return 0; // 养成好习惯哦 
}
```

是不是很水呢

本蒟蒻却提交了n遍，读题不仔细，A率唰唰掉......

//第一篇题解求过~

---

## 作者：wYYSZLwSSY (赞：14)

### 这是一道微坑水题
注意：      
1.⌈⌉是向上取整（not floor()）   
2.结算的结果只和当天开始的时候的值有关，即感染者当天恢复不影响他当天感染别人。       
3.若计算被感染人数超过易感者人数则全员被感染。    
##### 上AC代码
```cpp
#include<bits/stdc++.h>//不解释
using namespace std;
int s,I,r,n;//大小写
int main()
{   
    double a,b;
	cin>>s>>I>>n>>a>>b;
    for(register int i = 1;i <= n;i++){
        int si=s,ii = I,ri = r;
        r += ceil(ii * b);
        I -= ceil(ii * b);
        I += ceil(a * si * ii);
        s -= ceil(a * si * ii);//不是floor
        if(s < 0){I += s;s = 0;}
        if(I < 0){I = 0;r += I;}//千万不要丢
    }
    cout<<s<<' '<<I<<' '<<r;
}
```
##### 上WA一点代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,I,r,n;
int main()
{   
    double a,b;
	cin>>s>>I>>n>>a>>b;
    for(register int i = 1;i <= n;i++){
        int si=s,ii = I,ri = r;
        r += ceil(ii * b);
        I -= ceil(ii * b);
        I += ceil(a * si * ii);
        s -= ceil(a * si * ii);
    }
    cout<<s<<' '<<I<<' '<<r;
}
```
第一篇题解求过~

---

## 作者：随情英 (赞：7)

**很水的模拟题**

可以看到（$n$ $≤$ $100$ ）,所以直接从 $1$ 到 $n$ ,模拟就好（这题不卡精度）

要注意，存活者 $S$ 和感染者 $I$ ，可能会在某个时刻 $i$ 小于 $0$ ，要特判（把 $S$ 或 $I$ 赋值为 $0$ ,再相应把得到这个数的数$+ S$ 或 $I$），不然只有 $80$

code：
------------

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int S,I,R,n;
double B,Y;
int main(){
	scanf("%d%d%d%lf%lf",&S,&I,&n,&B,&Y);
	for(int i=1;i<=n;i++){
	    int t1=ceil(B*S*I),t2=ceil(Y*I);
	    R+=t2,S-=t1,I+=t1-t2;
	    if(S<0){I+=S;S=0;}
	    if(I<0){I=0;R+=I;}
	}
	printf("%d %d %d\n",S,I,R);
	return 0;
}


```


---

## 作者：SaladKing (赞：6)

水一发入门题题解
```
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    long long a,c,i,n,I,S,R=0;//感染 易感 恢复
    double b,g;
    
    cin>>S>>I>>n>>b>>g;
    for(i=1; i<=n; i++)
    {
        a=ceil(b*S*I);//被感染
        c=ceil(g*I);//被治愈
        
        if(a>=S)//若计算被感染人数超过易感者人数则全员被感染
            I+=S-c,S=0,R+=c;
        else
            I+=a-c,S-=a,R+=c;
    }
    
    cout<<S<<" "<<I<<" "<<R<<endl;
    return 0;
}
```
（~~因为是入门题所以应该没多少人看~~，辛苦管理员大大过了吧）

---


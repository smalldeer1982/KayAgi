# 询问

## 题目背景

 zbw 被邀请至幼儿园给小朋友们出题。

## 题目描述

　现在 zbw 有 $n$ 个物品，编号从 $1 \sim n$，他会告诉你 $m$ 个条件，每个条件包含两个数 $x,y$，表示第 $x$ 个物品和第 $y$ 个物品是相同的。

 因为 zbw 特别赶时间，所以他保证**每次给出的条件都是有用的，也就是说，每次给出的条件无法由之前的条件推导得来。**

你需要回答有多少**种**不同的物品。

## 说明/提示

对于 $20\%$ 的数据，$n,m \le 10$。

对于 $40\%$ 的数据，$n,m \le 10^3$。

对于 $60\%$ 的数据，$n,m \le 10^5$。

对于 $80\%$ 的数据，$m \le 10^6$。

对于 $100\%$ 的数据，$1 \le n \le 10^{18}$，$1 \le m \le 10^7$。

## 样例 #1

### 输入

```
11 8 
1 2
4 3
5 4
1 3
5 6
7 10
5 10
8 9```

### 输出

```
3```

# 题解

## 作者：MZY666 (赞：52)

[原题传送门](https://www.luogu.com.cn/problem/P6153)。

比赛的时候做到崩溃，一直怎么也弄不过去，完全懵了。

随后我抱着试一下的心态写出了以下代码：
```cpp
#include<bits/stdc++.h>//万能头文件好
using namespace std;//这不能少
#define ll long long//个人习惯，可以少打几个字
int main(){
	ll n,m;//定义
	scanf("%lld%lld",&n,&m);//输入
	printf("%lld",n-m);//输出
	return 0;//over.
}
```
竟然对了！~~小心脏差点受不了~~

我们现在来正经分析一下：

>因为 zbw 特别赶时间，所以他保证每次给出的条件都是有用的，也就是说，每次给出的条件无法由之前的条件推导得来。

也就是说，在没有给出条件时，我们是不知道哪些物体和哪些物体不相同的。那么一开始是有 $n$ 种不同的物体的。

随后，题目每给出一个条件，就会有两个物体相同（配对起来）。

那么，想要求出有多少种不同的物品就很简单了：只需要把物体总数 $n$ 减去条件数（也就是配对起来的物体组数） $m$ 即可。

还是比较简单的把。

分析完毕，撒花~

---

## 作者：gyh20 (赞：23)

对于 $20\%$ 的数据

随便你怎么搞都可以。时间复杂度 $O(?)$

对于 $40\%$ 的数据

不优化的并查集。时间复杂度 $O(n^2)$

对于 $60\%$ 的数据

路径压缩的并查集。时间复杂度 $O(n\log n)$

对于 $80\%$ 的数据

离散化+路径压缩并查集。时间复杂度 $O(m\log m)$

对于 $100\%$ 的数据

如果你看到了这一步，你可以当之前的话都是废话。

初始的答案为 $n$ (即如果 $m=0$ 就有 $n$ 种物品是不同的)

因为每个条件都保证无法由之前的条件推出，那么每次将两种不相等的东西变为相等，所以答案就少了 $1$。也就是说，每个条件都会使答案 $-1$。所以输出 $n-m$ 即可。时间复杂度 $O(1)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,m;
	cin>>n>>m;
	cout<<n-m;
}
```


---

## 作者：UnyieldingTrilobite (赞：7)

目测满分读入都超时。

所以肯定是只读入$n,m$乱搞。

然后思路就明确了。

每输入一条相等，就少一种物品。

所以答案是$n-m$.

**如果你像我一样，偷懒用python2/3，并且全部RE，务必看一看。**

这题输入格式与描述和样例不符。

实际上$n,m$是在同一行读入的！！！

所以python不能当成两行输入做。

**但还有另一个坑（对于C++/C/Pascal党）：**

**要开long long!!!**

所以······反正满满的坑就对了。

最后是上述5种语言的AC代码：

Python2:
```py
n,m=raw_input().split()
print int(n)-int(m)
```
Python3:
```py
n,m=input().split()
print(int(n)-int(m))
```
C:
```cpp
#include<stdio.h>
long long n,m;
int main(){
    scanf("%lld%lld",&n,&m);
    printf("%lld\n",n-m);
    return 0;
}
```
C++:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
int main(){
    cin>>n>>m;
    cout<<n-m<<endl;
    return 0;
}
```
Pascal:
```pas
var n,m:int64;
begin
    read(n,m);
    writeln(n-m);
end.
```
其他语言就不放了，反正能做P1001的应该都能做这题（虽然窝文言一直调不对）。

祝大家切题愉快！

---

## 作者：Fatalis_Lights (赞：4)

这个题作为比赛签到题挺良心的。

[原题传送门](https://www.luogu.com.cn/problem/P6153)

## 化简题意

现在有 $n$ 个点，每次选定两个点合并，操作共 $m$ 次，且操作有意义。求剩下多少联通块。

## Solution

每次选两个点合并，即相当于减少一个连通块。所以做 $m$ 次操作，就相当于减少了 $m$ 个连通块。

原来有 $n$ 个点，即 $n$ 个连通块，现在减去 $m$ 个，那这不就是做个减法吗？

所以 $Ans=n-m$ 。

还有，数据比较坑。 $n$ 是 $10^{18}$ 的数据范围，所以不要全读入进来。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
int main(){
    cin>>n>>m;
    cout<<n-m<<endl;
    return 0;
}
```

---

## 作者：Arghariza (赞：2)

我竟然第一眼把这题看成了并查集...我太菜了

其实这题有一个重要的内容：

> **每次给出的条件都是有用的，也就是说，每次给出的条件无法由之前的条件推导得来。**

所以我们可以得知这题连并查集都不用

原理：只要每连接一次总集合数就会```-1```，因为条件都是有用的，就不用并查集了，所以答案就是```n - m * 1 = n - m```（其实连接不用处理的说~）

代码：

```
#include <iostream>
#include <cstdio>
using namespace std;

long long n, m;

int main() {
    cin >> n >> m;
    cout << n - m;
    return 0;
}
```

---

## 作者：CSP_Sept (赞：2)

很好的一道题。
# 1 仔细分析题目
开始我想用并查集水过，结果 $(n\le 10^{18})$ 好像开不了数组？

直到看到 $\to$

>他保证**每次给出的条件都是有用的，也就是说，每次给出的条件无法由之前的条件推导得来。**

那也就是说，我们开始把每个物品都看成一种，这样总共就有 $n$ 种，再挨个读入操作，因为**每次给出的条件无法由之前的条件推导得来**，所以每读入一个操作时 $-1$ 即可。

**注意开 `unsigned long long` ！**
# 2 跑得快
算法知道了，~~开始研究怎样跑得快吧~~

## 2.1 $1$ 级
直接按上述说明模拟即可，代码如下 $(\text{874ms})$：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
ULL n,m,x,y;
int main(){
    scanf("%lld%lld",&n,&m);
    for(ULL i=1;i<=m;i++){
        scanf("%lld%lld",&x,&y);
        n--;
    }
    printf("%lld",n);
    return 0;
}
```
## 2.2 $2$ 级
既然每读入一个操作就 `n--` ，有 $m$ 个操作，也就是说 `n--` 要执行 $m$ 次，换句话说，就是 $n-1\times m$。

那么输入数据呢？不用管ta $\to$

>在洛谷，即使输入数据没读完也不会 $\color{Purple}\mathtt{RE}$ --《深入浅出-基础篇》

于是又可以轻松得出代码 $(\text{24ms})$：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
ULL n,m,x,y;
int main(){
    scanf("%lld%lld",&n,&m);//直接输出n-m即可
    printf("%lld",n-m);
    return 0;
}
```
## 2.3 $3$ 级
还可以更快吗？

**快读**应运而生！！！$(\text{tips:}$要用 `unsigned long long` 哟$)$。
快读代码：
```cpp
typedef unsigned long long ULL;
inline ULL read(){
	char c;
	bool flag=false;
	while((c=getchar())<'0'||c>'9')
	    if(c=='-') flag=true;
	ULL res=c-'0';
	while((c=getchar())>='0'&&c<='9')
	    res=(res<<3)+(res<<1)+c-'0';
	return flag? -res:res;
}
```
于是完整代码完美出炉 $(\text{19ms}):$
```cpp
#include <cstdio>
using namespace std;
typedef unsigned long long ULL;
ULL n,m,x,y;
inline ULL read(){
	char c;
	bool flag=false;
	while((c=getchar())<'0'||c>'9')
	    if(c=='-') flag=true;
	ULL res=c-'0';
	while((c=getchar())>='0'&&c<='9')
	    res=(res<<3)+(res<<1)+c-'0';
	return flag? -res:res;
}
int main(){
    n=read(),m=read();
    printf("%lld",n-m);
    return 0;
}
```
# 3 结语
在确保代码正确性的基础上一定要**加速代码**，这样排名才会高！

比如这张图（比赛刚开始）：
![](https://i.loli.net/2020/03/01/JjIoXilb57uHhK9.png)

可见排名高的都卡了时间！

---

## 作者：Eason_AC (赞：0)

## Content
有$n$个物品，标号为$1,2,3,...,n$。

有$m$个条件，每个条件的两个元素为$x,y$，代表第$x$个物品和第$y$个物品是相同的。

请根据$m$个条件算出这$n$个物品有多少不同的种类。

**数据范围：$1\leqslant n\leqslant10^{18},1\leqslant m\leqslant 10^7$。**
## Solution
这道题其实可以出成一个加强版。

什么样的加强版呢？

比如，对于下面这组数据：
```
11 
9
1 2
4 3
5 4
1 3
5 6
7 10
5 10
8 9
9 8
```
@Fond_Dream 的程序和我接下来给出的程序输出的结果是2，但很显然，结果应该是$3$，因为有两组重复的关系$(8,9)$和$(9,8)$。

但不知为什么，我们两个的程序都过了，也许是因为数据太水的原因？

这题如果弄个加强版的话，绝对不会是入门难度。

还要注意$\text{long~long}$的问题，数据范围给在上面了。

以上可说的就只这些。

### Update at 2020.3.1 21:06
好吧原谅我，是我看错了题目，对不起！

根据题目可知，条件一定不会重复，所以这道题目退化成了一个纯粹的$\texttt{a-b~problem（非高精）}$。

代码也将会更新。

## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;

long long n, m, x, y;

int main() {
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= m; ++i) {
		scanf("%lld%lld", &x, &y);
		if(x != y)	n--;
	}
	printf("%lld", n);
	return 0;
}
```
## Code 2
### Update at 2020.3.1 18:06
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;

long long n, m, x, y;

int main() {
	scanf("%lld%lld", &n, &m);
	printf("%lld", n - m);
    return 0;
}
```

---

## 作者：北落南殇 (赞：0)

这道题我一看，**哇，好高端的样子！肯定很难！**，等我仔细把题目看了一遍后再看看样例，
## 这其实是一道大水体好吧？
仔细读题，我们可以发现，每一次询问都会把两种物品联系在一起，比方说样例1，第一个条件可以把两个物品同化，所以只看第一个条件，我们发现有10个不同物品，再看到第二个条件，发现这时有9个不同物品。这时，我们可以总结出规律答案就是n-m，于是我们就把答案兴致勃勃的交上去
```cpp
#include <cstdio>

int x,y;
int n;

int main()
{
	int m;
	scanf("%d %d",&n,&m);
	
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&x,&y);
	}
	printf("%d",n-m);
	return 0;
}
```
等分数出来，发现只有60分？！，于是我们看了看数据范围，发现
## 十年OI一场空，不开long long见祖宗！

于是我们就把long long开上再交一遍
```cpp
#include <cstdio>

int x,y;
unsigned long long n;//被坑后气愤而不管三七二十一的开了unsigned long long  

int main()
{
	int m;
	scanf("%lld %d",&n,&m);
	
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&x,&y);
	}
	printf("%lld",n-m);
	return 0;
}
```
嗯，满分了，就这么结束了

---


# [COCI 2006/2007 #4] SIBICE

## 题目背景

年轻的 Mirko 把火柴扔的到处都是。他的母亲希望他将火柴放入盒子中。

## 题目描述

Mirko 现在要放置 $n$ 根火柴，他有一个 $w\times h$ 的矩形盒子。

他现在想请你进行判断这 $n$ 根火柴每一个是否能够放入这个盒子。

我们可以把盒子看成一个平面，只需要判断火柴是否能够在这个平面内放下即可。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 50$，$1\le w,h\le 100$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #4](https://hsin.hr/coci/archive/2006_2007/contest4_tasks.pdf) *T1 SIBICE***

## 样例 #1

### 输入

```
5 3 4
3
4
5
6
7 ```

### 输出

```
DA
DA
DA
NE
NE ```

## 样例 #2

### 输入

```
2 12 17
21
20 ```

### 输出

```
NE
DA```

# 题解

## 作者：Scrutiny (赞：19)

原问题不难转换为：如果火柴长度$\leq$矩形内以及矩形上两点最远距离，则输出`DA`,否则输出`NE`。

现在我们求矩形内以及矩形上最远两点的距离：

设矩形顶点$A(0,0),B(0,y),C(x,y),D(x,0)$，这里$x,y>0$

矩形内或矩形上两点$E(x_1,y_1),F(x_2,y_2)$，那么显然$0\leq x_1,x_2\leq x,0\leq y_1,y_2\leq y$

$EF=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$

∵$|x_1-x_2|\leq x,|y_1-y_2|\leq y$

∴$EF\leq \sqrt{x^2+y^2}$

因此，只要火柴长度$\leq \sqrt{w^2+h^2}$即可放下。

### CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double w,h,x;
int main(){
	cin>>n>>w>>h;
	for(int i=1;i<=n;++i){
		cin>>x;
		cout<<(sqrt(w*w+h*h)<x?"NE":"DA")<<endl;
	}
	return 0;
}
```

~~要抄窝的题解请理解后再抄qwq~~

---

## 作者：JamesQin (赞：6)

勾股定理，即每一根火柴只需要短于$w^2+h^2$开根号即可。

题解里都是浮点数，其实可以不用 double ,只需要判断$l^2 \leq w^2+h^2$即可。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,w,h;
	cin>>n>>w>>h;
	for(int i=1;i<=n;i++){
		int l;
		cin>>l;
		if(l*l<=w*w+h*h){
			cout<<"DA"<<endl;
		}
		else{
			cout<<"NE"<<endl;
		}
	}
	return 0;
} 
```


---

## 作者：Instudy (赞：2)

~~将大号的代码搬到小号上结果交成$P6321 $了还以为评测机是改了数据~~

以上为吐槽内容不要在意。

这题其实并没有说清楚每根火柴都放下去还是一根一根放下去。

但是样例给了我们答案，只要当前火柴能放下去就行，不管后面的也不管前面的。

那就很简单了~~样例都很强了给你勾股定理~~，所以火柴斜着能放进去就输出 $ DA $否则输出 $ NE $

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,h;
int main()
{
   scanf("%d%d%d",&n,&w,&h);
   double l=sqrt(w*w+h*h);
   for(int i=1;i<=n;i++)
   {
     int x;
     scanf("%d",&x);
     if(l>=x)printf("DA\n");
     else printf("NE\n");
   }
   return 0;
}
```
看完了？注意一个小细节，$ l $是$ double $类型，自己想一想为什么而且请举出反例

---

## 作者：Forest_Prince (赞：1)

~~趁没人赶快来写波题解~~

~~**众所周知**~~，矩形盒子是有直角的

在一个矩形里，最长的线段就是两条对角线相连，知道这个后就好做了

根据勾股定理可得斜边长为sqrt(w^2+h^2) w,h如同题意

对于每次询问，我们只需要查看这个长度是否大于两个对角线相连（也就是勾股定理的斜边），如果是，那么DA，否则NE

所以代码如下

```cpp
#include<bits/stdc++.h>		
using namespace std;
int w,k,n,s;
int l;
int main(){
	cin>>n>>w>>k;	//高端操作 
	l=sqrt(w*w+k*k);	//计算出最长边的长度 
	for(int i=1;i<=n;i++){	//n次询问 
		cin>>s;		
		if(s<=l) cout<<"DA"<<endl;	//能，哈！！被我抓到了，快放进去。 
		else cout<<"NE"<<endl;		//不能，火柴太长啦 ，抓到也放不进去啊 
	}		//不要return了个寂寞 
	return 0;//记得return 0哦  
}
```


---

## 作者：bovine__kebi (赞：0)

首先我们来考虑，什么情况下火柴能放的下，是在它小于长和宽的最大值吗？其实并不是的，我们来考虑一下下面这张图：  
![](http://m.qpic.cn/psc?/V12WWmqX1GuqHd/m*TTJoI3x9iCCJx4ECa9pFptkvXLrEkYK9vg.rwlLh3Ok*Af*8O1nbcJW1E2O2g6znJwYFxaMg8wDVXNmUHj4A!!/mnull&bo=lwQeAwAAAAADB6w!&rf=photolist&t=5)  
可能不是很清晰，但是可以凑活着看，我们发现一个长方形的对角线是长于他的其他两边的，我们不妨来证明一下：  
令长$=a$宽$=b$,斜边长$=m$根据勾股定理：  
$m=\sqrt{a^{2}+b^{2}}$  
则$m^{2}=a^2+b^{2}$  
因为平方具有非负性，所以我们能保证斜边是长于两直角边的，于是就可以愉快的敲代码了：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,h;
int n;
int main()
{
    scanf("%d %d %d",&n,&w,&h);//读入三个数据，分别为测试数据组数，长度和宽度
    int m=sqrt(w*w+h*h);//计算对角线的长度
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d",&a);
        puts(a<=m?"DA":"NE");//将读入的数据与对角线的长度作比较，这里用了一个三目运算符
    }
    return 0;
}
```
写在后面：  
这题注意两个地方：  
1.puts自带换行符   
2.m要为int型，不然有可能出锅

---

## 作者：SUNCHAOYI (赞：0)

因为是一个矩形盒子（四个角均为$90$度），所以最长能放下的长度肯定等于**对角线长度**。把矩形的邻边看作直角三角形的两边，那么最大长度等于**直角三角形的斜边**,即为$\sqrt{w^2 + h^2}$。
```
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
	int n,x;
	double a,b,c;
	cin>>n>>a>>b;
	c = sqrt(a * a + b * b);//最大长度
	while(n--)
	{
		cin>>x;
		if(x <= c) cout<<"DA"<<endl;//≤则能放下
		else cout<<"NE"<<endl;//超过则不能
	}
	return 0;
}

```


---


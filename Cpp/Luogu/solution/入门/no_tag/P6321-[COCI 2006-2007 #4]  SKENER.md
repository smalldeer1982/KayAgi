# [COCI 2006/2007 #4]  SKENER

## 题目背景

Mirko 在拿放大镜看杂志。

## 题目描述

他正在看一面 $r$ 行 $c$ 列的杂志。放大镜有两个参数 $zr,zc$，表示把每个字符都转换成一个 $zr$ 行 $zc$ 列的矩阵。

给出原始杂志，请你帮他找出杂志在放大镜下的影像。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le r,c\le 50$，$1\le zr,zc\le 5$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #4](https://hsin.hr/coci/archive/2006_2007/contest4_tasks.pdf) *T2 SKENER***

## 样例 #1

### 输入

```
3 3 1 2
.x.
x.x
.x. ```

### 输出

```
..xx..
xx..xx
..xx.. ```

## 样例 #2

### 输入

```
3 3 2 1
.x.
x.x
.x.```

### 输出

```
.x.
.x.
x.x
x.x
.x.
.x.```

# 题解

## 作者：Mikemao666 (赞：21)


这次我要来一波完整丰富的分析。

### **题意**

首先，输入四个数；前两个是报纸的行数、列数，后两个是放大镜的两个“参数”（具体后面会讲）。

让后，按行数 _r_、列数 _c_  输入一个字符矩阵。

 _这里我们就要想到：用**二维数组**_ 

让后，我们要按题目要求，把每一个小字符“放大”。

那这里什么叫放大呢?

题目解释： _把每个字符都转换成一个 zr 行 zc 列的矩阵。_ 

实际上就是：把原来的每一个字符**复制zr行、复制zc列！**

但单个字符作矩阵输出是不现实的（程序按行输出）。

所以我们想到：**用四重循环！**

so……
```cpp
for(int i=1;i<=r;i++)
	for(int j=1;j<=c;j++)
		for(int m=1;m<=zr;m++)
			for(int l=1;l<=zc;l++)
            putchar(a[m][l]);
```
这就对了吗？？？

错！

这种写法过于想当然。    ~~Dev:你第一次不是这样写的？~~

我们要输出的，是由**原来的字符**组成的许多矩阵。

其中的m、l只是用于控制放大行数、列数的，不能用作输出字符！

输出工作应交给其中的i,j 。

如果你上面都懂了，那这道题也差不多A了。

### **注意！**四重循环尤其小心！增量不要搞混！
为此我调了数次，输出来什么都不知道

## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[55][55];
int main () {
	int r,c,zr,zc;//老老实实按题目定义 
	cin>>r>>c>>zr>>zc;//r:原行数 c:原列数 zr：放大行数 zc放大列数 
	for(int i=1;i<=r;++i){
		for(int j=1;j<=c;++j){
			cin>>a[i][j];
		}
	}//常规二维数组输入
	for(int i=1;i<=r;i++){//四重循环 
		//这里控制原行数 
		for(int m=1;m<=zr;m++){
			//枚举放大后的行数 
			for(int j=1;j<=c;j++){
				//这里控制原列数 
				for(int l=1;l<=zc;l++)//枚举放大后的列数 
					putchar(a[i][j]);//输出 （快捷） 
			}	
			printf("\n");//换行位置很重要 （在这一行所有列的字符输完 后再换行） 
		}
	}		
    return 0;
}
```

---

## 作者：Mr_WA的大号 (赞：7)

岂曰无衣，与子同裳。小学生又来发题解了！

题号：P6321

难度：★ 

算法：暴力

## 开课了！

这道题评入门难度一点也不错，就是最简单的暴力。

但这题的暴力也算是暴力中的极品了（~~四个for的暴力呀~~）！话不多说，开始讲正题。

这一题暴力相信大家都是想得到的，那么重点来了：怎么去暴力呢？现在就来告诉大家。

这一题的四重循环十分刁钻，每一重循环都有它对应的东西。给大家一个示意图：

```cpp
for(原行数)
{
	for(放大的行数)
	{
		for(原列数)
      		{
			for(放大的列数)
			输出ch[原行数][原列数]
          	 输出换行
        	 }
	}
}
```
课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<iomanip>
using namespace std;
char ch[100][100];
int n,m,n1,m1;
int main()
{
	cin>>n>>m>>n1>>m1;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			cin>>ch[i][j];//输入
	for(int i=1; i<=n; i++)//原行数
		for(int i1=1; i1<=n1; i1++)/放大的行数
		{
			for(int j=1; j<=m; j++)//原列数
				for(int j1=1; j1<=m1; j1++)//放大的列数
					cout<<ch[i][j];
			cout<<endl;
		}//暴力
	return 0;
}
```
祝大家能AC！

---

## 作者：SUNCHAOYI (赞：3)

按照题意进行输出：
- 对于每一行的第$c_j$个字母，都要输出$zc$遍
- 对于每一行，都要输出$zr$遍

所以就有了四重大循环，如下：
```
#include <iostream>
using namespace std;
int main()
{
	char a[55][55];
	int r,c,zr,zc;
	cin>>r>>c>>zr>>zc;
	for(int i = 0;i < r;i++)
		for(int j = 0;j < c;j++) cin>>a[i][j];
	for(int i = 0;i < r;i++)
	{
	 	for(int k = 0;k < zr;k++)
	 	{
	 		for(int j = 0;j < c;j++)
				for(int l = 0;l < zc;l++) cout<<a[i][j];
			cout<<endl;
		}
	} 
	return 0;
} 
```
当然，因为每一行中有$r$组字母都重复出现了$zc$次，每一行都重复出现了$zr$次，所以还可以再**化简一下**，如下：
```
#include <iostream>
using namespace std;
int main()
{
	char a[55][55];
	int r,c,zr,zc;
	cin>>r>>c>>zr>>zc;
	for(int i = 0;i < r;i++)
		for(int j = 0;j < c;j++) cin>>a[i][j];
	for(int i = 0;i < r * zr;i++)
	{
	 	for(int j = 0;j < c * zc;j++) cout<<a[i / zr][j / zc];//注意这里
		cout<<endl;
	} 
	return 0;
} 
```


---

## 作者：封禁用户 (赞：1)

思路:设每行每列输入的字符为$a_i$ $_j$,则输出时要输出$zr*zc$个$a_i$ $_j$,可以在每行输出$zc$个$a_i$ $_j$,再把每行输出$zr$遍,输出完换到下一行继续输出。

虽然要用到四重循环,但是看看数据范围,不会$TLE$,所以这道题就很简单了。

代码($c++$)$:$
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1005][1005];
int r,c,zr,zc;
int main(){
	cin>>r>>c>>zr>>zc;//按题目定义
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
			cin>>a[i][j];
	}
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=zr;j++)
		{
			for(int k=1;k<=c;k++)
			{
				for(int l=1;l<=zc;l++)
					cout<<a[i][k];//输出(注意是a[i][k])
			}
			cout<<endl;//换行别弄错地方
		}
	}
	return 0;
}
```


---

## 作者：半笙、凡尘 (赞：1)

~~无聊刷入门水题~~

对于此题，只需充分运用循环嵌套即可。

把原图转化为一个 $r*zr$ 行，$c*zc$ 列的图，则只需将原图中的每一个字符输出 $zr$ / $zc$ 遍即可

然后我们考虑复杂度 $1≤r,c≤50$，$1≤zr,zc≤5$，显然满足复杂度

于是乎就是显而易见的代码:

```cpp
#include<bits/stdc++.h>
/* Forever_chen */
#define RT register
using namespace std;
template<class t> inline t read(t &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f)x=-x;return x;
}
template<class t>inline void write(t x){
	if(x<0)putchar('-'),write(-x);
	else{if(x>9)write(x/10);putchar('0'+x%10);}
}
template<class t>inline void writeln(t x){
	write(x);putchar('\n');
	return;
}
template<class t>inline void write_blank(t x){
	write(x);putchar(' ');
	return;
}
int r,c,zr,zc;
char ch[60][60];
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(r),read(c),read(zr),read(zc);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			cin>>ch[i][j];
		}
	}
	for(int i=1;i<=r;i++){ 
		for(int m=1;m<=zr;m++){
			for(int j=1;j<=c;j++){
				for(int l=1;l<=zc;l++){
					cout<<ch[i][j];
				}	
			}	
			cout<<endl; 
		}
	}	
	//system("pause");
	return 0;
}

```



---

## 作者：HsKr (赞：0)

思路：考虑对行重复$zr$遍，对列重复$zc$遍。

于是用四层循环，由于$1\le r, c\le50$，$1\le zr,zc \le5$，最大不超过$6250$，所以可以轻松通过。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

inline int read() {
	int d = 0, f = 1; char ch = getchar(); while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch)) {d = d * 10 + ch - 48, ch = getchar();} return d * f;
}

void write(int x) {
	if(x >= 10) write(x / 10);
	putchar(x % 10 + 48);
}

int n, m, r, c;

char s[50][50];

int main() {
	n = read(), m = read(), r = read(), c = read();
	for(int i = 0; i < n; i++) {//简单的输入 
		scanf("%s", s[i]);
	}
	for(int i = 0; i < n; i++) {//枚举行 
		for(int j = 1; j <= r; j++) {//枚举行重复次数 
			for(int k = 0; k < m; k++) {//枚举列 
				for(int l = 1; l <= c; l++) {//枚举列重复次数 
					printf("%c", s[i][k]);//输出在原数组中的字符 
				}
			}
			puts("");//换行 
		}
	}
	return 0;
}

```

---

## 作者：y0y68 (赞：0)

~~无聊来刷刷水题。~~

**~~其实这题一个输入输出就完了！！！~~（确实如此）**

-----------------------------

题目中说把每个字符都转换成一个 $zr$ 行 $zc$ 列的矩阵，但是输出不能一个矩阵一个矩阵得输出，只能一行一行得输出，于是考虑把每个矩阵分成 $zr$ 行，每行要把这个元素输出 $zc$ 次，详细看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,r,c;
//这里n表示题目中的r
//这里m表示题目中的c
//这里r表示题目中的zr
//这里c表示题目中的zc
char s[55][55];
int main(){
 cin>>n>>m>>r>>c;
 for(int i=1;i<=n;i++)
  scanf("%s",s[i]+1);//这种读入方式可以学一学
 //先处理行再处理列
 for(int i=1;i<=n;i++)
 //有r个大行
  for(int k=1;k<=r;k++,puts(""))
  //每个大行分为zr个小行
  //输出完一行后要记得换行
   for(int j=1;j<=m;j++)
   //有c个大列
    for(int l=1;l<=c;l++)
    //每个小列分为zc个小列
     putchar(s[i][j]);
     //putchar可以提高运行速度（不在这题没什么用）
 return 0;
}
```

---


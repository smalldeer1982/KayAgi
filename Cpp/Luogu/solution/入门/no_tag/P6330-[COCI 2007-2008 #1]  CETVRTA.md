# [COCI 2007/2008 #1]  CETVRTA

## 题目描述

给出坐标系中一个矩形的三个顶点的坐标，请你确定第四个顶点的坐标并输出。

保证矩形的边与坐标轴平行。

## 说明/提示

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #1](https://hsin.hr/coci/archive/2007_2008/contest1_tasks.pdf) *T1 CETVRTA***

## 样例 #1

### 输入

```
5 5
5 7
7 5```

### 输出

```
7 7```

## 样例 #2

### 输入

```
30 20
10 10
10 20```

### 输出

```
30 10```

# 题解

## 作者：chenyilai (赞：33)

给大家一种$\max$和$\min$~~玄学乱搞~~的做法：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n1,n2,n3,m1,m2,m3;
	scanf("%lld%lld%lld%lld%lld%lld",&n1,&m1,&n2,&m2,&n3,&m3);
	printf("%lld %lld",n1+n2+n3-(n1+n2+n3-max(n1,max(n2,n3))-min(n1,min(n2,n3)))*2,m1+m2+m3-(m1+m2+m3-max(m1,max(m2,m3))-min(m1,min(m2,m3)))*2);
    return 0;
}
```
看不懂？~~是不是感觉很毒瘤？~~ 我给你解释一下：
- 因为这是一个矩形，所以 $3$ 个点当中的 $x$ 坐标定有两个相同，两个不同（具体可以康一康其他 $dalao$ 的博客）
- 这两个不同的数，一个是$\max(n1,\max(n2,n3))$，一个是$\min(n1,\min(n2,n3))$
- 这两个相同的数是$n1+n2+n3-\max(n1,\max(n2,n3))-\min(n1,\min(n2,n3))$
- 那一个不同的数是$n1+n2+n3-(n1+n2+n3-\max(n1,\max(n2,n3))-\min(n1,\min(n2,n3)))\times2$
- $y$ 坐标以此类推。

现在你看懂了吗？如有疑问，珂以在发评论区。

---

## 作者：bovine__kebi (赞：19)

来一种接近$O(1)$复杂度的算法，首先我们来了解一下一些神奇的运算，位运算（前置芝士会的可以跳过）：  
$1\quad\&$运算：表示两个数转化成二进制之后，只有两个数位上的数都是1，那个位置与（$\&$）的值才是$1$，否则则为$0$,举个栗子$4 \& 10=100\&1010=0$  
$2\quad\ |$运算：表示两个数的转换成二进制之后，只要一个数位上是$1$，那个位置上的或($|$)值就是$1$，只有两个数位上的数都是$0$，举个栗子$4|10=100|1010=1110=14$  
$3\text{ \^\quad}$运算：表示当两个数为转换成二进制之后，两个数位上的数相同，则它们的异或（$\text{\^ }$）值就是$0$，如果不同则是$1$,举个栗子$4\text{\^ }14=100\text{\^ }1110=1010=10$  
这些东西看着没什么用，但是他们满足一些性质，我们单看异或，相同的数异或起来为$0$,$0$异或一个数就等于那个数，而且异或满足结合律和交换律，比如：  
$4\text{\^ }4\text{\^ }4=4\text{\^ }(4\text{\^ }4)=4\text{\^ }0=4$  
所以总结一下，偶数个相同的数异或为$0$,这样我们就可以做这一题了。

分析题意，我们发现，如果要构造一个矩形，那么他们所有点坐标里的横坐标和纵坐标都出现了两次，这样的话，题意就转变成了，从三个点的横坐标和纵坐标中分别找出一对奇数的坐标输出，那么我们就可以运用之前讲过的异或的性质，把所有的数异或到一起，就做完了，高清无码代码如下：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans1,ans2;
int main()
{
    for(int i=1;i<=3;i++)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        ans1^=a;
        ans2^=b;
    }
    printf("%d %d\n",ans1,ans2);
    return 0;
}
```
希望大家能从我的题解里学到知识，管理员求过  
（づ￣3￣）づ╭❤～

---

## 作者：鸿飞 (赞：10)

## PART1：题意
给定一个矩形的三个顶点的坐标，求没有给出的那一个坐标。
## PART2：思路
众所周知，一个矩形的四个横坐标中，一定有分为两组，每组中的两个坐标相同，纵坐标同理。所以我们只要找出落单的一组坐标即可。具体实现方法给在代码里了。
## PART3：代码
```cpp
#include<iostream>
#include<string>
using namespace std;
int a,b,c,d,e,f;
int main(){
	cin >> a >> b >> c >> d >> e >> f ;//输入
	if(a==c)//从这里到第24行是横坐标的判断
	{
		cout << e ;//如果其他两个坐标相同，说明这个坐标目前落单，
        		   //输出它即可，以下同理
	}
	if(e==c)
	{
		cout << a ;
	}
	if(a==e)
	{
		cout << c ;
	}
	cout << " " ;//记得输出空格哦 
	if(b==d)//从这里到第38行是纵坐标的判断
	{
		cout << f ;
	}
	if(d==f)
	{
		cout << b ;
	}
	if(b==f)
	{
		cout << d ;
	}
	return 0;
}

```


---

## 作者：SUNCHAOYI (赞：3)

首先大家需要知道什么是矩形，如下图所示。矩形是四个角均为90度的特殊的平行四边形。既然是平行四边形，那么一定**对边平行且相等**，即$AB = CD$且$AB//CD$，$AD = BC$且$AD//BC$。那么就有$A$与$D$，$B$与$C$的$x$轴坐标相等；$A$与$B$，$C$与$D$的$y$轴坐标相等。   
![矩形](https://cdn.luogu.com.cn/upload/image_hosting/szdbrzpp.png)   
那么就有，输入的三个数中，找出单独未配对的点$x$坐标与$y$坐标，输出即可。
```
#include <iostream>
using namespace std;
int main()
{
	int x1,y1,x2,y2,x3,y3;
	cin>>x1>>y1>>x2>>y2>>x3>>y3;
	if(x1 == x2) cout<<x3<<" ";
	if(x1 == x3) cout<<x2<<" ";
	if(x2 == x3) cout<<x1<<" ";
	if(y1 == y2) cout<<y3<<endl;
	if(y1 == y3) cout<<y2<<endl;
	if(y2 == y3) cout<<y1<<endl;
	return 0;
}

```
----
不知道大家看到找未配对的数后有什么联想？  
**提示：两个相同的数进行异或值为$0$**。   

因此就可以把$x$与$y$分别异或，那么配对的数值为$0$，剩下的答案也就是要输出的数了。
```
#include <iostream>
using namespace std;
int main()
{
	int x,y,ansx = 0,ansy = 0;
	for(int i = 1;i <= 3;i++) cin>>x>>y,ansx ^= x,ansy ^= y;
	cout<<ansx<<" "<<ansy<<endl;
	return 0;
}

```


---

## 作者：Remake_ (赞：2)

一道肥肠水的入门题。

前置知识：位运算（其实也可以不用）

此题有一个关键的性质，原题中提到了（其实我也不太确定我理解的准不准确），而在译文中没有提到，即矩形的边平行于坐标轴，而我们根据这个特点会有一个非常简单的性质，即：

横坐标一定有一组重复的，纵坐标也有一组重复的。

而我们最后要求的就是那个单出来的横坐标和纵坐标。

考虑证明：

因为边平行于xy轴，所以对于任意一条边来说，它的两个端点的横或纵坐标是一样的。

此题就已经基本做完了，另外呢有一个比较重要的性质，即：

$a$^$a=0$

所以我们就可以利用异或找出单出来的数了，具体请参考我代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long a[7],b,c;
int main(){
	for(int i=1;i<=6;i++) cin>>a[i];
	for(int i=1;i<=3;i++) b^=a[i*2-1];
	for(int i=1;i<=3;i++) c^=a[i*2];
	cout<<b<<" "<<c; 
} 
```
感谢观赏。

---

## 作者：xh39 (赞：2)

我们先看x坐标。矩形有一个性质就是每个坐标仅由两个数字组成,且这两个数字各有$2$个。

所以我们只要找到那个在输入中只出现了$1$次的数字把它输出。

y坐标一样。

AC代码:
```cpp
#include<iostream>
using namespace std;
int main(){
	int x1,x2,x3,x4,y1,y2,y3,y4;
	cin>>x1>>y1>>x2>>y2>>x3>>y3;
	if(x1==x2){
		cout<<x3<<" "; //此时x3一定是只出现了1次。
	}else if(x1==x3){
		cout<<x2<<" "; //同上。
	}else{
		cout<<x1<<" "; //如果x1没有与其他的相等,说明x1只出现了1次。
	}
	if(y1==y2){ //y坐标同x坐标。
		cout<<y3<<" ";
	}else if(y1==y3){
		cout<<y2<<" ";
	}else{
		cout<<y1<<" ";
	}
	return 0;
} 
```

---

## 作者：Instudy (赞：2)

考察 $ if $ 语句的使用和很简单的矩形性质。

我们知道矩形的长相等，宽相等，所以相同横坐标的纵坐标之差相等，相同纵坐标的横坐标之差相等。

那有三种大情况： $ x1=x2 $或  $ x3=x2 $或$ x1=x3 $，那么剩下的一个点的横坐标就是相等之外的点。

可能有些绕，举个例子：

$ x1=x2 $就输出 $ x3 $（想想为什么）

我们再来考虑纵坐标，同理，根据同纵坐标的横坐标之差相等，我们可以得到$ y1=y2 $就输出 $ y3 $，其余请读者自己推。

代码：（~~最喜欢的是不是？~~）

```cpp
#include<iostream>
using namespace std;
int x1,y1,x2,y2,x3,y3;
int main()
{
  cin>>x1>>y1>>x2>>y2>>x3>>y3;
  if(x1==x2)
  {
    cout<<x3<<' ';
    if(y2==y3)cout<<y1;
    else if(y1==y2)cout<<y3;
    else cout<<y2;
  }
  else if(x1==x3)
  {
    cout<<x2<<' ';
    if(y2==y3)cout<<y1;
    else if(y1==y2)cout<<y3;
    else cout<<y2;
  }
  else 
  {
    cout<<x1<<' ';
    if(y2==y3)cout<<y1;
    else if(y1==y2)cout<<y3;
    else cout<<y2;
  }
    return 0;
}
```


看完了？注意一个小细节，我用的是 $ iostream $头文件，如果使用万能头文件会撞关键字 $ x1 $ ，请大家注意。

---

## 作者：SisconHL (赞：0)

画一画就知道矩形四个顶点里面，有两组横坐标相等，两组横坐标相等。

于是我们就可以分横坐标和纵坐标考虑。

既然有两组相等的，挖掉一个后就有一组相等的，一个单个的，输出那个单个的。

介绍一个黑科技：异或（`^`）

有两个重要的式子：

- $a​^a=0$
- $a​^b=b​^a$

所以显然，把那三个出现的异或起来就是答案了。

纵坐标同理。

上代码：

```cpp
#include<iostream>

using std::cin;
using std::cout;

int main( void )
{
	int a1 , b1 , a2 , b2 , a3 , b3;


	cin >> a1 >> b1 >> a2 >> b2 >> a3 >> b3;


	cout << ( a1 ^ a2 ^ a3 ) << " " << ( b1 ^ b2 ^ b3 );
} 
```

---


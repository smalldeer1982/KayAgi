# [COCI 2007/2008 #2] PRVA

## 题目描述

给定一个 $r\times c$ 的符号方阵组成的填词游戏，里面由小写字母和 `#` 组成。

一个单词指的是在方阵中从左到右或从上到下把经过的字母依次相连（不得包含 `#`）形成的字母串。不一定要整行或整列都包含，且这个字母串的长度至少为 $2$。对于竖向的单词，头尾的上方或者下方要么顶着 `#`，要么处于边界；横向单词的左右也需要符合这个要求。

请你求出字典序最小的单词。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le r,c\le 20$。

#### 说明
**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #2](https://hsin.hr/coci/archive/2007_2008/contest2_tasks.pdf) *T3 PRVA***。

## 样例 #1

### 输入

```
4 4
luka
o#a#
kula
i#a#```

### 输出

```
kala```

## 样例 #2

### 输入

```
4 4
luka
o#a#
kula
i#as```

### 输出

```
as```

## 样例 #3

### 输入

```
4 5
adaca
da##b
abb#b
abbac```

### 输出

```
abb```

# 题解

## 作者：yeshubo_qwq (赞：4)

[题面](https://www.luogu.com.cn/problem/P6338)

------------

## 题意
找到并输出长度至少为 $2$ 的字母串。
## 思路
暴力枚举每一个位置，看它是否能够成为字母串的开头。

如果可以，就取这个字母串，并与上次答案取最小。

具体细节请看代码。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,y;
char a[25][25];
string x,ans="{";//既然最大字母是z，就取一个比z大的字符{作为初始最大值即可
int main(){
	cin>>n>>m;
	for(i=0;i<=n;i++)a[i][0]='#';//初始化，围一圈栅栏，否则会导致下面判断字母串的开头时错误 
	for(i=0;i<=m;i++)a[0][i]='#';
	for(i=1;i<=n;i++)cin>>a[i]+1;
	for(i=1;i<=n;i++)//暴力枚举每一个位置 
		for(j=1;j<=m;j++){
			if(a[i][j]>='a'&&a[i][j]<='z'&&a[i][j-1]=='#'){//是从左到右的字母串的开头 
				x="";y=j;
				while(y<=m&&a[i][y]!='#')x=x+a[i][y++];//往右取，直到出现#或出界结束
				if(x.size()>=2)ans=min(ans,x);//长度至少为2 
			}
			if(a[i][j]>='a'&&a[i][j]<='z'&&a[i-1][j]=='#'){//是从上到下的字母串的开头 
				x="";y=i;
				while(y<=n&&a[y][j]!='#')x=x+a[y++][j];//往下取 
				if(x.size()>=2)ans=min(ans,x);
			}
		}
	cout<<ans;
	return 0; 
}
```


---

## 作者：hensier (赞：1)

枚举每一个元素，看它是否为字母串的首位，然后保存字典序最小的字符串。

```cpp
#include<bits/stdc++.h>
using namespace std;
int r,c;
char s[21][21];
string cur,ans;
int main()
{
    ans.insert(0,21,'z');//由于r,c都<=20，所以字母串最长不会超过20，所以不妨把ans设定为21个z
    scanf("%d%d",&r,&c);
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            //快读加速——遇到非法字符就继续读入
            s[i][j]=getchar();
            while(!islower(s[i][j])&&s[i][j]!='#')s[i][j]=getchar();
        }
    }
    for(int i=1;i<=r;i++)
    {
        for(int j=1;j<=c;j++)
        {
            if(s[i][j]=='#')continue;//字母串开头必须是字母
            //枚举同列异行的字母串
            if(s[i-1][j]=='#'||i==1)//如果该元素上方不为字母或者已经是第一行，就开始操作
            {
                cur="";
                for(int k=i;k<=r&&s[k][j]!='#';k++)cur+=s[k][j];
                if(cur.size()>1&&cur<ans)ans=cur;
            }
            //枚举同行异列的字母串
            if(s[i][j-1]=='#'||j==1)//如果该元素左方不为字母或者已经是第一列，就开始操作
            {
                cur="";
                for(int k=j;k<=c&&s[i][k]!='#';k++)cur+=s[i][k];
                if(cur.size()>1&&cur<ans)ans=cur;
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：xiaolilsq (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P6338)

由于数据范围比较小，可以直接找出所有合法的字符串，排序后输出最小的就可以了。

排序的话直接用stl的stirng和sort就可以了。

AC代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
#define ch() getchar()
#define pc(x) putchar(x)
template<typename T>inline void read(T&x){
	int f;char c;
	for(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c<='9'&&c>='0';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>inline void write(T x){
	static char q[64];int cnt=0;
	if(!x)pc('0');if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
string s[400];
int map[20][20];
int main(){
	int n,m;read(n),read(m);
	for(int i=0;i<n;++i){
		for(int j=0;j<m;++j){
			char c(ch());
			while((c<'a'||c>'z')&&c!='#')
				c=ch();
			map[i][j]=c;
		}
	}
	int cn=0;
	for(int i=0;i<n;++i){//寻找每行合法的字符串
		string tmp="";
		for(int j=0;j<m;++j){
			if(map[i][j]=='#'){
				if(tmp.size()>1)
					s[cn++]=tmp;
				tmp="";
			}
			else{
				tmp.push_back(map[i][j]);
			}
		}
		if(tmp.size()>1)s[cn++]=tmp;
	}
	for(int i=0;i<m;++i){//寻找每列合法的字符串
		string tmp="";
		for(int j=0;j<n;++j){
			if(map[j][i]=='#'){
				if(tmp.size()>1)
					s[cn++]=tmp;
				tmp="";
			}
			else{
				tmp.push_back(map[j][i]);
			}
		}
		if(tmp.size()>1)s[cn++]=tmp;
	}
	sort(s,s+cn);//直接排序然后输出
	cout<<s[0]<<endl;
	return 0;
}

```

当然，也可以每找到一个字符串就比较一下。

---


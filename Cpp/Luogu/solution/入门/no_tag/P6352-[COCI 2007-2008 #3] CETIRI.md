# [COCI 2007/2008 #3] CETIRI

## 题目描述

你原本有 $4$ 个数，它们从小到大排序后构成了等差数列。

但是现在丢失了一个数，并且其余的三个数的顺序也被打乱了。

请你找出第四个数。

## 说明/提示

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T1 CETIRI***。

## 样例 #1

### 输入

```
4 6 8```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 4```

### 输出

```
7```

# 题解

## 作者：Miller2019 (赞：16)

我的思路：先读入那三个数，再排序一下。然后计算出第 2 小的数的与第 1 小的数的差 c1 和第最大数与第 2 小的数的差 c2。

然后分三种情况讨论：

我们设数列中的四个数分别为： m1, m2, m3, m4 。

1. c1 = c2 这样差一样，一定有一种情况是已输入 m1, m2, m3，我们输出 m4 = m3 + 公差 即可。

1. c1 > c2 这样前面的差大，一定有一种情况是已输入 m1, m3 ,m4 ,我们输出 m2 = m3 - 公差 或 m1 + 公差 即可。

1. c1 < c2 这样后面的差大，一定有一种情况是已输入 m1, m2 ,m4 ,我们输出 m3 = m4 - 公差 或 m2 + 公差 即可。

最短代码：

[三目运算符请参阅](https://miller2019.blog.luogu.org/solution-cf1169a)


```cpp
#include<bits/stdc++.h>
int n[3],c1,c2,c3;
int main()
{
	scanf("%d%d%d",n,n+1,n+2); //读入 n[0],n[1],n[2]。
	std::sort(n,n+3);//排序一下，因为我们是从下标 0 使用到下标 2 的，所以排序的起始位置是 n (或 n+0 )，结束位置是 n+3。
	c1=n[1]-n[0],c2=n[2]-n[1]; //计算差。
	printf("%d",c1==c2?n[2]+c1:(c1>c2?n[1]-c2:n[2]-c1));
    	//这里用了三目运算符，我们先判断是否是第 1 种情况，执行计算；如果不是，在判断是否是第二种情况。最后计算出表达式的值，输出即可。
	return 0;
}
 
```
亲测：16ms /  696.00KB	

感觉有点慢，我就优化了一下。因为数据中可能有排好序的数据，可以用 `is_sorted` 判断一下,其它跟上面一样。

这里 `is_sorted` 默认检测是否已经是从小到大排序的，是则返回 1 ，反之返回 0。我们也可以编写 cmp 函数改变规则（同 sort）。

但是请注意： `is_sorted` 是 C++11 的函数。 

```cpp
#include<bits/stdc++.h>
int n[3],c1,c2,c3;
int main()
{
	scanf("%d%d%d",n,n+1,n+2);
	if(!std::is_sorted(n,n+3))std::sort(n,n+3);//如果不是有序的，则执行 sort ；反之不执行。
	c1=n[1]-n[0],c2=n[2]-n[1];
	printf("%d",c1==c2?n[2]+c1:(c1>c2?n[1]-c2:n[2]-c1));
	return 0;
}
```
亲测：14ms /  728.00KB 

这样有效提高了在输入数据是有序情况下的速度。

这是目前评测记录最优解第 3（不算 O2）。

蒟蒻橙后第 2 篇题解。

---

## 作者：ADay (赞：11)

## 思路
我们可以先把它们排序，然后分类讨论。  
即使用$sort$排序$a_1,a_2,a_3:$ `sort(a+1,a+4)`  
在数轴上：  
------$a_1$------$a_2$------$a_3$------   
现在我们要插入$a_4$
### Case1
如果它们已经是等差数列了，即`a[2]-a[1]==a[3]-a[2]`，$a_4$就在：   
-----$a_1$------$a_2$------$a_3$------$a_4$    
或  
$a_4$-----$a_1$------$a_2$------$a_3$------  
输出一个即可，此时公差为$a_3-a_2$，选择输出最大的，为$a_3+(a_3-a_2)=2 \times a_3 - a_2$  
### Case2
如果$a_3-a_2>a_2-a_1$,那么$a_4$在$a_2,a_3$间：   
-----$a_1$------$a_2$------$a_4$------$a_3$------   
也就是说，$a_4$是$a_2$和$a_3$的平均数，为$\dfrac{a_2+a_3}{2}$  
### Case3
最后一种情况，$a_4$在$a_1,a_2$之间：   
-----$a_1$------$a_4$------$a_2$------$a_3$------   
$a_4$为$a_1,a_2$的平均数：$\dfrac{a_1+a_2}{2}$   
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[7];

int main()
{
	scanf("%d%d%d",&a[1],&a[2],&a[3]);
	sort(a+1,a+4);//排序
	if(a[2]-a[1]==a[3]-a[2])printf("%d",2*a[3]-a[2]);//Case1
	else if(a[3]-a[2]>a[2]-a[1])printf("%d",(a[2]+a[3])/2);//Case2
	else printf("%d",(a[1]+a[2])/2);//Case3
	return 0;
}
```


---

## 作者：鸿飞 (赞：5)

## PART1:思路
首先，将三个数排序；

其次，做出排序后相邻两数之间的差；

最后，比较：如果两个差相同，输出应有的下一个；如果两个较小数之间的差小于两个较大数之间的差或两个较小数之间的差大于两个较大数之间的差，输出中间空缺的数。

举例：

（1）输入：4 6 8

排序后是4、6、8。

因为6-4=8-6=2，所以要输出下一个，即8+2=10或4-2=2.

（2）输入：10 1 4

排序后是1、4、10.

因为4-1=3<10-4=6，所以要输出4和10之间空缺的数，即4+3=7.

## PART2:CODE

```cpp
#include<iostream>
using namespace std;
int main(){
	int a,b,c;
	cin >> a >> b >> c ;//输入 
	if(a>b)//排序 
	{
		swap(a,b);
	}
	if(a>c)//还是排序
	{
		swap(a,c);
	}
	if(b>c)//依然是排序
	{
		swap(b,c);
	}
	int x=b-a,y=c-b;
	if(x==y)//判断并输出 
	{
		cout << c+y ;
	}else if(x>y)
	{
		cout << a+y ;
	}else
	{
		cout << b+x ;
	}
	return 0;
}
```


---

## 作者：一只书虫仔 (赞：4)

[P6352 [COCI2007-2008#3] CETIRI](https://www.luogu.com.cn/problem/P6352)

这道题的一个关键点就是 **等差数列** 。首先输入三个数，尽量用数组输入，好用 `sort` 排序。然后我们分三种情况讨论（假设第一个数和第二个数的差为 $c_1$ ，第二个数和第三个数的差为 $c_2$）：

- $c_1=c_2$ ，那么说明前三个数就是等差数列，直接输出第三个数 $+c_2$ 或者第一个数 $-c_1$ 即可。
- $c_1=2\times c_2$ ，那么说明公差应为 $c_2$，第四个数在第一个数和第二个数之间，只需要输出第二个数 $-c_2$ 或者第一个数 $+c_2$ 即可。
- $c_1\times 2=c_2$ ，那么说明公差应为 $c_1$，第四个数在第二个数和第三个数之间，只需要输出第三个数 $-c_1$ 或者第二个数 $+c_1$ 即可。

实现上面的语句只需要三个 `if` 。

Code :

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	int a[5];
	scanf("%d%d%d", &a[1], &a[2], &a[3]);
	sort(a + 1, a + 4);
	int cha1 = a[2] - a[1];
	int cha2 = a[3] - a[2];
	if (cha1 == cha2)
		printf("%d", a[3] + cha2);
	else if (cha1 == (2 * cha2))
		printf("%d", a[2] - cha2);
	else 
		printf("%d", a[3] - cha1);
	return 0;
}

```

Tips : 多种情况只需考虑一种，因为题目已用 SPJ。

---

## 作者：chenxirui (赞：2)

###### ~~我就是个蒟蒻， 本人第一次写题解， 希望管理大大给我过~~
------------
## 下面进入正题
首先我们分析一下题目：
求等差数列中丢失的一项

因为提示中已经说了：确保有解 ，  那我们就不用想太多，而且是多解题，我仅提供我AC的版本

### 我们先排个序
```cpp

#include<cstdio>
#include<algorithm>
using namespace std;
int a[10];

  
//省略main函数
  
	scanf("%d%d%d", &a[1], &a[2], &a[3]);
	sort(a+1, a+4);
```
```


------------
我总结了三种情况：（使用我自己举的例子， 第x项指从小到大排序的第x项）

①：缺失第二项    例如： 5 ，（） ，13, 17

我们很容易可以分析出，第二项为9。 怎么分析？
第三项-第一项 > 第四项-第三项
所以：

if(a[3]-a[2] > a[2]-a[1]) printf("%d", a[3]-(a[2]-a[1]));
```


②：缺失第三项    例如：5 ,  9 ，（），17

其实等同于第二种，不多赘述
```cpp
if(a[3]-a[2] < a[2]-a[1]) printf("%d", a[2]-(a[3]-a[2]));
```

③：缺失最大/小的那项

这种最好判断 如果题目给的三个数已构成等差数列，就直接输出第一/四项（我选择第四项）

```cpp
if(a[3]-a[2] == a[2]-a[1]) printf("%d", a[3]+a[3]-a[2]);
```
然后就~~不出意外~~AC了    ~~（是不是很神奇呢？）~~

下面给AC代码， 仅供参考

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[10];

int main()
{
	scanf("%d%d%d", &a[1], &a[2], &a[3]);
	sort(a+1, a+4);
	if(a[3]-a[2] == a[2]-a[1]) printf("%d", a[3]+a[3]-a[2]);
	else if(a[3]-a[2] > a[2]-a[1]) printf("%d", a[3]-(a[2]-a[1]));
	else if(a[3]-a[2] < a[2]-a[1]) printf("%d", a[2]-(a[3]-a[2]));
	return 0;
}
```

~~再次希望管理大大给本蒟蒻一个机会~~

---

## 作者：SUNCHAOYI (赞：2)

给出的三个数可能有两种情况（设四个数为$ABCD$）：

1. 已经为等差数列，这个很好判断。已经给出了$ABC$，则$D$等于$A-B$或$B-C$,则$D$可以等于$A-D$或$C+D$。
2. 此时未成为等差数列，即$A - B\neq B - C$,若增加一个数成为等差数列，必定有$A < D < C$,所以我们只要判断$D$应该再$AB$之间还是$BC$直接。大家一定能想到$D$一定需要放在两数之差大的地方才可能有解，因此就有：   
$\begin{cases}
A-B>B-C,D=A+\frac{B-A}{2}\\
A-B<B-C,D=B+\frac{C-B}{2}\\
\end{cases}$   

当然 ，以上先要对这三个数**先排序**，因为`其余的三个数的顺序被打乱了`。代码如下：
```
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
	int a[4];
	cin>>a[1]>>a[2]>>a[3]; 
	sort(a + 1,a + 4);
	if(a[2] - a[1] == a[3] - a[2]) cout<<a[3] + (a[2] - a[1])<<endl;
	if(a[2] - a[1] > a[3] - a[2]) cout<<a[1] + (a[2] - a[1]) / 2<<endl;
	if(a[2] - a[1] < a[3] - a[2]) cout<<a[2] + (a[3] - a[2]) / 2<<endl;
	return 0;
}

```


---

## 作者：yc杨晨大家好 (赞：1)

这题主要是排序+判断，我们求出3个数的两个间隔，有三种情况。

1.两个间隔相等，这种情况说明要么是头丢失了，要么是尾丢失了，我们随便输出一个就行。
尾是第三个数+公差（任意一个间隔），头是第一个数-公差。

2.第一个间隔大，这说明丢失的数在第二个间隔里，就是第二个数再加上公差（第一个间隔）。

3.第二个间隔大，这说明丢失的数在第一个间隔里，就是第一个数再加上公差（第二个间隔）。

代码：

```
#include<bits/stdc++.h> 
using namespace std;
int main(){
    int a[3],i,t,t2;//数组存放三个数
    cin>>a[0]>>a[1]>>a[2];//输入
    sort(a,a+3);//排序
    t=a[1]-a[0];//第一个间隔
    t2=a[2]-a[1];//第二个间隔
    if(t2==t){//如果相等
    	cout<<a[2]+t;//我是输出尾，输出头也可以
	}else{
		if(t2>t){//第二个间隔大
			cout<<a[1]+t;//在第二个间隔里
		}else{//第一个间隔大
			cout<<a[0]+t2;//在第一个间隔里
		}
	}
    return 0;
}
```


---

## 作者：_Clown_ (赞：0)

这道题目，我们可以用暴力枚举解决。

因为输入的三个数都在[-100,100]，所以，第四个数，估摸着不会超过[-300,300]。

暴力枚举第四个数，每次将这四个数排个序，看看两两之间差是否相同，如果可以，就输出答案，否则继续找。

那就没什么好说的了，毕竟它是一道红题嘛！

上代码啊：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[11];
int b[11];
int main()
{
	register int i;
	cin>>a[1]>>a[2]>>a[3];
	for(i=-300;i<=300;i++)
	{
		b[1]=a[1];
		b[2]=a[2];
		b[3]=a[3];
		b[4]=i;
		sort(b+1,b+5);
		if(b[2]-b[1]==b[3]-b[2]&&b[4]-b[3]==b[2]-b[1])
		{
			cout<<i<<endl;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：yyy爱编程 (赞：0)

1. 先排序。

2. 判断，已经为等差数列的，直接输出$a_3+(a_3-a_2)$即可。$\qquad$如果不是等差数列，有两种情况：第一种情况，$a_1-a_2>a_2-a_3,$输出的是$(a_2-a_1)÷2$；第二种情况，$a_1-a_2<a_2-a_3,$输出的是$(a_3-a_2)÷2$。

代码很简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[4];
	cin>>a[1]>>a[2]>>a[3];
	sort(a+1,a+3+1);
	int cha1=a[2]-a[1],cha2=a[3]-a[2];
	if(cha1==cha2){
		cout<<a[3]+cha1;
		return 0;
	}
	if(cha1<cha2){
		cout<<(a[1]-a[2])/2;
		return 0;
	}
	if(cha1>cha2){
		cout<<(a[3]-a[2])/2;
		return 0;
	}
}
```

---

## 作者：novax (赞：0)

#### 这道题的题意：

给出三个数 $A$ $B$ $C$ ，要求写一个程序，找到另一个数 $D$ ，使得这四个数能构成一个等差数列

#### 思路：

题目给出的三个数的顺序是打乱的，所以在计算前要先对 $A$ $B$ $C$ 三个数进行排序（从小到大或者从大到小都可以），由于数字只有三个，所以只需要用三个if语句就可以完成排序了。

然后用两个变量 $x_1$ $x_2$ 分别保存 $B-A$ 和 $C-B$ 的值：

如果这两个值不相等，那么其中较小的值就是等差数列的公差，要求的答案就是 $A$ $B$ $C$ 三个数中两数差较大的两数的平均数。也就是当 $x_1>x_2$ 时，答案是 $A+x_2$ ；当 $x_1>x_2$ 时，答案是$B+x_1$ 

如果这两个值是相等的，那么这三个数本来就是一个等差数列了，答案就是最大的数加上公差或者最小的数减去公差，两种情况都是正确的

#### 代码如下：
```cpp
#include <cstdio>
int main()
{
	int a,b,c;
	scanf("%d%d%d",&a,&b,&c);
	int s=0;
	if(a>b) 
	{
		s=a;a=b;b=s;
	}
	if(a>c)
	{
		s=c;c=a;a=s;
	}
	if(b>c)
	{
		s=b;b=c;c=s;
	}
	int x,y,ans;
	ans=0;
	x=b-a;
	y=c-b;
	if(x!=y)
		if(x>y)
			ans=a+y;
		else
			ans=b+x;
	else
		ans=c+x;
	printf("%d\n",ans);
}
```


---

## 作者：SisconHL (赞：0)

有趣的一道题，可惜有点简单了（大雾）。

无序的话比较不好分析，于是先排序。

三元排序用`if`就足够了。

伪代码如下：
```plain
def sort(a,b,c):
 if a>b:
  swap(a,b)
 if a>c:
  swap(a,c)
 if b>c:
  swap(b,c)
```
于是我们实现了三元升序排序。

然后就考虑这个数列。

如果本身就等差，那么首项减公差或者末项加公差，都能保证是等差数列。

如果不，那么就补那个差大的“空”。

上代码：

```cpp
#include<stdio.h>

inline void swap( int &a , int &b )
{
	int tmp = a;
	a = b;
	b = tmp;
	return;	
} 

int main( void )
{
	int a , b , c;
	scanf( "%d%d%d" , &a , &b , &c );
	if( a > b )	swap( a , b );
	if( a > c )	swap( a , c );
	if( b > c )	swap( b , c );
	int x = b - a , y = c - b;
	if( x == y )
	{
		printf( "%d" , c + x );
		return 0; 
	} 
	if( x > y )//那么y是公差 
		printf( "%d" , a + y );
	else
		printf( "%d" , b + x );
}
```


---

## 作者：Arghariza (赞：0)

没啥好说的，直接上思路

- 由于是等差数列所以要先排序才能判断

- 设三个数中间值(`mid`)减去最小值(`min`)为`s1`，最大值(`max`)减去中间值为`s2`：

1. 若`s1 = s2`，不难得到剩下一个数为`max + s1`或`min - s1`

2. 若`s1 < s2`，不难得出剩下一个数在原本排序之后数列的第**3**个位置上，为`max - s1`或者`mid + s1`

3. 若`s1 > s2`，不难得出剩下一个数在原本排序之后数列的第**2**个位置上，为`min + s2`或者`mid - s2`


所以可以得到以下代码（由于作者太懒于是使用数组排序）：

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int n = 3, a[10];//输入3个数所以n = 3，a数组为输入数列

int main() {
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);//输入
    sort(a + 1, a + n + 1);//从小到大排序
    int s1 = a[2] - a[1], s2 = a[3] - a[2];//得到s1, s2
    if (s1 == s2) printf("%d", a[3] + s1);//第1种情况
    else if (s1 < s2) printf("%d", a[3] - s1);//第2种情况
    else printf("%d", a[1] + s2);//否则，也就是第3种情况
    return 0;//结束
}
```

---


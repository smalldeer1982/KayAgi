# [COCI 2006/2007 #6] PRASE

## 题目描述

孩子们正在餐桌旁吃午餐，共有 $n$ 份食物，孩子们会按照从 $1$ 至 $n$ 的顺序依次取走这 $n$ 份食物。

当某个孩子取走了一份食物时，如果这个他之前已经取走的食物份数（不包括当前这一份）比其他人取走的食物份数之和还要多，那么他的妈妈就会提醒他注意自己不礼貌的行为。注意，虽然被妈妈提醒了，但是他仍然会取走这份食物。换句话说，妈妈的提醒对孩子的行为没有任何影响。

给定 $n$ 份食物分别被哪个孩子取走了，请求出妈妈们一共提醒了多少次。

## 说明/提示

#### 样例 1 解释

当取到第 $3$ 份食物时，stanko 已取走的食物（不包括当前这份）的份数是一份，而其他人也总共取走了一份，所以 stanko 的妈妈不会提醒他注意礼貌。

当取到第 $4$ 份食物时，stanko 已经取走两份食物，其他人总共取走了一份食物，因此妈妈会提醒他。

---

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 100$
- $1 \leq |s_i| \leq 20$，$s_i$ 中只含小写英文字母。$|s_i|$ 表示字符串 $s_i$ 的长度。

---

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T1  PRASE***。

## 样例 #1

### 输入

```
4
mirko
stanko
stanko
stanko
```

### 输出

```
1```

## 样例 #2

### 输入

```
17
a
b
b
a
a
a
c
a
b
b
c
b
b
b
b
b
b
```

### 输出

```
4```

# 题解

## 作者：一扶苏一 (赞：30)

### Analysis

简单模拟，用 `std::map` 存一下每个孩子取到的食物份数，设当前已经取了 $i$ 份食物，则取第 $i + 1$ 份食物时，其他人取到的食物总数就是 $i - x$，其中 $x$ 是取第 $i + 1$ 份食物的孩子已经取的食物份数。

### Code

```cpp
#include <map>
#include <string>
#include <iostream>

int n;
std::map<std::string, int> mp;

int main() {
  std::cin >> n;
  int ans = 0;
  std::string tmp;
  for (int i = 0; i < n; ++i) {
    std::cin >> tmp;
    int k = i - mp[tmp];
    if (mp[tmp]++ > k) ++ans;
  }
  std::cout << ans << std::endl;
  return 0;
}
```



---

## 作者：WxjzKK (赞：13)

# 此题很水，适合广大蒟蒻、新手切题
## 首先来解析一下题目
1. 题目大意

  有 $n$ 个吃的，给一些小盆友拿，输入 $n$ 个字符串代表拿第 $i$ 个吃的滴小盆友。如果这个小盆友已拿的(他拿的 $-1$)大于其他小盆友拿的吃的滴总和，那么，这个小盆友的妈咪就会提醒他注意礼貌，题目让你求的就是妈咪们会提醒几次
  
2. 算法分析

  这题可以爆搜，$O(n^2)$的时间复杂度(可能还更小)
  
3. 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include<string>
#include<stack>
#include<queue>
#include<vector> //一堆头文件
using namespace std;
string st[101]; //由于n不大于100，所以定义到101
int main()
{
	int n,ans=0,num;
	cin>>n;
	for (int i=1;i<=n;++i) //循环开始
	{
		cin>>st[i];num=0; //输入直接处理
		for (int j=1;j<i;++j) if (st[i]==st[j]) ++num; //统计个数
		if (i-num-1<num) ++ans; //注意，一定要-1，因为num计算的是前面的，而刚刚拿走的一个不是其他人拿的
	}
	cout<<ans; //输出
	return 0; //完美的结束
}

```
$$\Huge\text{切题愉快}$$

---

## 作者：JamesQin (赞：6)

本题为一道模拟，可以使用 map 简化代码。

可以设总共取走 $i$ 份, 目前的人取走 $x$ 份。

如果 $x \times 2 > i$,那么总数加一，因为此时超过了一半，也就比剩下人的食物多了。

最后输出答案即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	map<string,int> Num;
	int n;
	cin>>n;
	int ans=0;
	for(int i=0;i<n;i++){
		string Name;
		cin>>Name;
		if(Num[Name]*2>i) ans++;
		Num[Name]++;
	}
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：LinkZelda (赞：4)

1. **简化题目**：

一个孩子已经拿（现在拿了的食物减去一份）的食物如果大于已经拿了的食物减去自己拿的食物，就会被妈妈提醒。要求输出妈妈提醒的次数。

2.  **思考：**

可以用 $vector$ 动态数组来存拿每份食物的人的名字，然后每次算一下会不会被妈妈提醒。

代码如下（含注释）：
```cpp
#include<iostream>
#include<vector>//注意调用vector头文件
using namespace std;
vector<string>a;
int main()
{
	int n,ans=0,cnt=0;//cnt用于记录孩子拿的食物数量
	cin>>n;
	string s;
	for(int i=1;i<=n;i++)//i用于表示所有孩子取食物数量
	{
		cin>>s;
		a.push_back(s);//插入拿食物的孩子名字
		for(int j=0;j<a.size();j++)//找一下这个孩子拿了多少食物
		{
			if(a[j]==s)cnt++;//找到他的名字就加一
		}
		if((cnt-1)>(i-cnt))ans++;//如果已经拿了的食物比其他人的食物多，就会被提醒，ans++
		cnt=0;//记得要清零
	 } 
	cout<<ans;
	return 0;
}
```


---


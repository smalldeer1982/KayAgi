# [COCI 2014/2015 #1] PROSJEK

## 题目描述

有一个数列 $a$，现在按照下列公式求出一个数列 $b$：

$$b_i=\frac{ \sum^i_{j=1} a_j }{i}$$

给你数列 $b$，请求出数列 $a$。

## 说明/提示

#### 样例输入输出 3 解释
当数列 $a=1,3,2,6,8$ 时，数列 $b=\frac{1}{1},\frac{1+3}{2},\frac{1+3+2}{3},\frac{1+3+2+6}{4},\frac{1+3+2+6+8}{5}$，即 $b=1,2,2,3,4$。

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $1\le n\le 100$，$1\le a_i,b_i\le 10^9$。

#### 说明
**本题总分 $50$ 分。**

本题译自 [Croatian Open Competition in Informatics 2014/2015](https://hsin.hr/coci/archive/2014_2015) [Contest #1](https://hsin.hr/coci/archive/2014_2015/contest1_tasks.pdf) T1 PROSJEK。

## 样例 #1

### 输入

```
1
2```

### 输出

```
2```

## 样例 #2

### 输入

```
4
3 2 3 5```

### 输出

```
3 1 5 11```

## 样例 #3

### 输入

```
5
1 2 2 3 4```

### 输出

```
1 3 2 6 8```

# 题解

## 作者：追梦之鲸 (赞：7)

本蒟蒻的第$007$篇题解。

[经典回顾P6414](https://www.luogu.com.cn/problem/P6414)

### 思路

让我们来看一下这个式子：

$b_i = \dfrac{\sum ^i _{j=1} a_j}{i}$

由这个式子可以推导出这个式子：

$b_i * i = \sum ^i _{j=1} a_j$

继续推导：

$b_i * i-\sum ^{i-1} _{j=0} a_j = a_i (a_0=0)$

最后得到最终答案：

$ a_i= b_i *i -\sum ^{i-1} _{j=0} a_j$

~~这个东西那么简单就不用证明了吧~~

### 注：不了解∑的请看[这个](https://baike.baidu.com/item/%E2%88%91/1233796?fr=aladdin)

好了，让我们看一看样例，促进吸收

### #2

```
3*1-0=3
2*2-0-3=1
3*3-0-3-1=5
5*4-0-3-1-5=11
```

答案:
3
1
5
11

### #3

```
1*1-0=1
2*2-0-1=3
2*3-0-1-3=2
3*4-0-1-3-2=6
4*5-0-1-3-2-5=8
```

答案:
1
3
2
6
8

### code：
```c
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define rint register int
using namespace std;
int n,b,a[102];

int main()
{
	scanf("%d",&n);
	for(rint i=1;i<=n;i++)
	{
		scanf("%d",&b);
		a[i]=b*i;
	}
	for(rint i=1;i<=n;i++)
	{
		printf("%d ",a[i]-a[i-1]);
	}
	return 0;
    	撒花✿✿ヽ(°▽°)ノ✿
}
```

最后管理大大求过&&[**来玩啊**](https://www.luogu.com.cn/user/361726)

---

## 作者：sysong (赞：2)

# 题解P6414 [COCI2014-2015#1] PROSJEK

### 题目描述

已知数列 $b$ : $b_{i}= \frac{\sum_{j=1}^{i}a_j}{i}$ ，求数列 $a$ 。



### Solution


样例解释3:

当数列 $a=1,3,2,6,8$ 时，数列 $b=\frac{1}{1},\frac{1+3}{2},\frac{1+3+2}{3},\frac{1+3+2+6}{4},\frac{1+3+2+6+8}{5}$，即 $b=1,2,2,3,4$。




那么，我们可以发现 $b_{i} \times i$ 与 $b_{i-1} \times (i-1)$ 在数值上相差了 $a_{i}$ 。


由此可以对于每个 $b_{i}$ 和 $b_{i-1}$ ,求差得出 $a_{i}$ 。

前面两个dalao讲了很详细的推导过程，那我这里就只是简单地提一下，再讲一个小小的优化。

（~~我只是看数字找规律推导的，没有详细地写证明~~）

所以可以只用两个变量滚动求解，速度快多了，也节约了空间。（~~然而还是干不过那个Pascal的。。。~~）



### $C++ \qquad Code$

```c++
#include <cstdio>
#define R register
using namespace std;

int main(){
	R int n,now,pre=0;//初始化
	scanf("%d",&n);
	for(R int i=1;i<=n;i++){							// 这里 i 从 1 开始，是为了下面乘的时候方便，从 0 开始也可以
		scanf("%d",&now);
		printf("%d%c",now*i-pre*(i-1),i==n?'\n':' ');	// 输出小技巧，方便换行
		pre=now;										// 滚动求解，节省时间、空间
	}
	return 0;
}

```

**by jsntsys**

$2020.10.18$

###### 写题解不易，望通过$qwq$

---

## 作者：btng_smith666 (赞：2)

这题没什么好说的，主要是简单地推一下，原题中的式子：

$$b_i=\dfrac{\sum\limits_{j=1}^ia_j}{i}$$


转换一下：

$$b_i=\dfrac{a_1+a_2+...+a_i}{i}$$

可得：

$$a_1+a_2+...+a_i=b_i\times i$$

且：

$$a_1+a_2+...+a_{i-1}=b_{i-1}\times(i-1)$$

用上式减去下式可得：

$$a_i=b_i\times i-b_{i-1}\times(i-1)$$

有了上面这个式子，就可以愉快地敲代码啦qwq

-----

Code：

```cpp
#include<bits/stdc++.h>//by btng_smith666 juruo
using namespace std;
long long b;//数列 b ，注意要开 long long ，因为此题最高可能会涉及到 10^12 次方的计算 
long long last;//用来存 b[i-1]*(i-1) 也就是上一次的结果 
int n;
int main()//主函数 
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&b),printf("%lld ",b*i-last),last=b*i;//先代入公式求出答案，然后改变 last 的值 
	return 0;
}
```

---

## 作者：Scrutiny (赞：1)

首先输入给出了$b_i$，并且题目中说明了
$$b_i=\dfrac{\sum\limits_{j=1}^i a_i}{i}$$

因此我们可以算出$\sum\limits_{j=1}^i a_i=b_i×i$。

对于任意的正整数$i∈[2,n]$，显然有$a_i=\sum\limits_{j=1}^ia_j-\sum\limits_{j=1}^{i-1}a_j$。

在$C++$里我们可以记$cnt_i=\sum\limits_{j=1}^i a_i$，并将$cnt$数组先清零，这样$a_1=cnt_1-cnt_0$了，不用特判了。

### 注意：

$1.cnt$数组必须开```long long```，不然有可能爆```int```。

$2.cnt$数组必须先清零。


### CODE:

```cpp

#include<bits/stdc++.h>
using namespace std;
long long a[1000],b[1000],n,cnt[1000];
int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>b[i];
		cnt[i]=b[i]*i;
	}
	for(int j=1;j<=n;++j){
		cout<<cnt[j]-cnt[j-1]<<" ";
	}
	return 0;
} 

```

~~要抄题解请理解后再抄。~~

---


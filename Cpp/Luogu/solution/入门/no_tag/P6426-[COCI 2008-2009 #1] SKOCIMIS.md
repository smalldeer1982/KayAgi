# [COCI 2008/2009 #1] SKOCIMIS

## 题目描述

三只袋鼠在沙漠里的一条数轴上玩耍，每只袋鼠都占据一个不同的整数点。在一次移动中，一只不在中间的袋鼠跳进另两只袋鼠之间的空间。两只袋鼠决不能占据同一位置。

请让它们尽可能久地玩耍。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，$0 < A < B < C < 100$。
#### 说明
#### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #1](https://hsin.hr/coci/archive/2008_2009/contest1_tasks.pdf) SKOCIMIS，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
2 3 5```

### 输出

```
1```

## 样例 #2

### 输入

```
3 5 9```

### 输出

```
3```

# 题解

## 作者：Miller2019 (赞：17)

题意：数轴上有三个点，每一次将一个两侧的点移动至另两个点之间的一个整数位置，求这样做的最大移动次数。

我们设开始是这样的：
![](https://cdn.luogu.com.cn/upload/image_hosting/rescy62w.png)

可以这样移动：M:

![](https://cdn.luogu.com.cn/upload/image_hosting/p78tlmf3.png)

或者这样：N:

![](https://cdn.luogu.com.cn/upload/image_hosting/2by5msdz.png)

题目让找出最大的移动次数，我们显然可以看出：像 N 一样移动，明显比像 M 一样移动，可移动的次数多。

所以我们让所有的移动方式都像 N 一样，将靠其他两点最近的移动到与它最近的点的前一个整数点。

易发现：这样每移动一次，ABC 中最大的距离就会减少 1 。而当它们距离等于 0 时无法移动。

所以可得：最大移动次数等于最大距离减一。即为 B - A - 1 或 C - B - 1 的最大值。

易得代码如下：
```cpp
#include<stdio.h> 
#define max(m,n) (m>n?m:n) 
int a,b,c;
int main()
{
	scanf("%d%d%d",&a,&b,&c);
	printf("%d",max(b-a,c-b)-1);
	return 0;
}
```
蒟蒻橙后第 8 篇题解。

---

## 作者：Math_rad_round (赞：4)

 _[P6426](https://www.luogu.com.cn/problem/P6426)_ 
 
 题意简述：数轴上有三个点，每一次将一个两侧的点移入另两个点之间的整数位置，求最大移动次数
 
------------

 一道非常水的题
 
 我们首先可以发现，移动时，应该让被移入的空间尽量大（就有了更多空间调整）
 
 所以移动时一定要靠边（否则把它靠上边会使另一边区间更大）
 
 所以我们可以发现，第一次移动后，每一次将两个相邻的点中靠外的移到内部，这样是最优的
 
 所以，每一次移动都会是最大空区间点数减一，到它长$0$时，就没法移动了
 
 所以，次数就是最大空区间点数
 
 这个点数呢？因为一共只有两段区间，直接比较$B-A-1$和$C-B-1$就行了
 
 减一是因为相距$x$的话中间只有$x-1$个点
 
------------

code:

 ```cpp
#include<iostream>
using namespace std;

int main(){
	int a,b,c;
	cin>>a>>b>>c;
	cout<<max(b-a,c-b)-1;
}
```


---

## 作者：半笙、凡尘 (赞：3)

# 【[COCI2008-2009#2] RESETO】


~~序:无聊来写写水题~~

 -------
 
 - 这题也是比较容易的，毕竟入门难度嘛
 
   - 通过观察题目我们可以发现，**袋鼠能跳的最长的次数就是每两只袋鼠之间的间隔的最大值减一**
   
   - 显然，袋鼠的跳的最大次数就是两只袋鼠之间的点的个数
   
   - 所以，答案就是 $max((c-b),(b-a))-1$。
   
   - 以上结论手玩易得好吧
   
   - 有了这个结论代码就简单了
   
   - 码量也相当短小，建议初学者做做 $qwq$
   
 - 接下来就是一点也不激动人心的代码了
 
```cpp
#include<bits/stdc++.h>
#define RT register
using namespace std;
template<class t> inline t read(t &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f)x=-x;return x;
}
template<class t> inline void write(t x){
	if(x<0)putchar('-'),write(-x);
	else{if(x>9)write(x/10);putchar('0'+x%10);}
}
template<class t> inline void writeln(t x){
	write(x);putchar('\n');
	return;
}
template<class t> inline void write_blank(t x){
	write(x);putchar(' ');
	return;
}
int a,b,c;
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(a),read(b),read(c);
	write(max((c-b),(b-a))-1);
	return 0;
}
```

---

## 作者：Kaedeuim (赞：1)

先让我们分析一下样例1的数据。

三只袋鼠的位置分别是`2`,`3`,`5`

那么显然，在`2`,`3`两只袋鼠之间肯定是跳不进去的，那么只能调到`4`号位，构成`3`,`4`,`5`。

然后大家可以发现，对于三只袋鼠的位置（假设它们叫做$a,b,c$）,其中一只袋鼠可以跳到$(b-a),(c-b)$的大者的空档之间，随后构成新的$a,b,c$。

将每一次的$a,b,c$情况综和起来，就会发现，袋鼠能跳的最大次数，其实就是一开始$a,b,c$两个空间的大者$-1$。

其实就是$max(b-a,c-b)-1$

知道了这一点,代码实现就变得简单得多。

# AC Code

```
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
int a,b,c;
cin>>a>>b>>c;
cout<<max(b-a,c-b)-1;//答案
return 0;
}
```

~~话说这道题道理想通了代码其实超水的。~~

---

## 作者：David_H_ (赞：1)

## 题面简述
三只袋鼠在沙漠里的一条数轴上玩耍，每只袋鼠都占据一个不同的整数点。在一次移动中，一只袋鼠跳进另两只袋鼠之间的空间。两只袋鼠决不能占据同一位置。

请让它们尽可能久地玩耍。

## 思路简述
### 乱搞做法
输出 `rand()`，我测了个 $9$ 分（[评测记录](https://www.luogu.com.cn/record/34721834)）

### 正常做法
首先，我们假设这三个袋鼠的点所代表的数为 $A$，$B$，$C$。

首先，$A<B<C$，故无非 $2$ 种情况：
 - $A$ 动，此时进入 $B$、$C$ 之间，每次移动 $1$ 格，至多走 $C - B - 1$ 次；
 - $C$ 动，此时进入 $A$、$B$ 之间，每次移动 $1$ 格，至多走 $B - A - 1$ 次；
 
那么这里就输出最大值就好了。
## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int a, b, c;

int main() {
    scanf("%d%d%d", &a, &b, &c);
    printf("%d", max(b - a, c - b) - 1);
    return 0;
}
```

---

## 作者：_Clown_ (赞：1)

先排序，第一次跳一定是第一只袋鼠或是第三只袋鼠。

每一次跳，都可以做到只将长度缩小一。

开始时长度为：
$$max(A[3]-A[2],A[2]-A[1])$$
这样我们就求出了初始长度，因为每次缩小一，直到为一时结束，所以答案为：
$$max(A[2]-A[1],A[3]-A[2])-1$$
代码请自己打！

---

## 作者：WanderingTrader (赞：1)

这一道题其实算是一道数学题，虽然不涉及什么算法，但是还是需要仔细思考一下。  
读入数据后，我们先将它们排个序：
```cpp
int a,b,c;
scanf("%d%d%d",&a,&b,&c);
if(b > c)swap(b,c);
if(a > b)swap(a,b);
if(b > c)swap(b,c);
```
排完序后，我们可以模拟一遍这个过程： 

假设第一步先动$c$,为了能走尽可能走多的步数，我们应将其放在$a+1$或$b-1$的位置。  
重复上述这个过程(此时先动$a$还是先动$b$已经无所谓了，答案是一样的)，我们可以发现，它最终能走$b-a-1$步，因为$(a,b)$区间里每一个点都走了一遍。  

同理，假设第一步先动了$a$，我们将其放在$b+1$或$c-1$的位置，重复上述过程后，共走了$c-b-1$步，因为$(b,c)$区间里每一个点都走了一遍。  
现在我们在两个答案里取最大值即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a,b,c;
	scanf("%d%d%d",&a,&b,&c);
	if(b > c)swap(b,c);
	if(a > b)swap(a,b);
	if(b > c)swap(b,c);
	printf("%d\n",max(b-a-1,c-b-1));
	return 0;
}
```
回顾刚才的思考过程，我们实际上是利用了贪心的思想，尽可能走多的步数(也就是对当前情况最有利的操作)，从而取得全局的最优解。  
$the$ $end.$

---

## 作者：过往梦魇之殇 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P6426)

**思路简述：**

题意可抽象为：数轴上有三个点，设其为$x,y,z$

因为$x<y<z$，故$xy=y-x-1$，$yz=z-y-1$

所以$xy$之间的空间为$y-x-1$,$yz$之间的空间为$z-y-1$

每次跳跃时，肯定要往更大的空间里跳，才能使跳的次数更多

且每次跳，都会使最大空间$-1$

所以答案就是最大空间的长度（初始），即$max(x-y-1,y-z-1)$

**代码展示：**

```cpp
#include<bits/stdc++.h>
#define re register
#define in inline
#define ll long long
#define pi acos(-1.0)
#define inf 2147483640
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
int x,y,z;
int main()
{
	x=read();
	y=read();
	z=read();
	write(max(y-x-1,z-y-1));
    return 0;
}
```
> $Thanks$ $For$ $Watching!$

---


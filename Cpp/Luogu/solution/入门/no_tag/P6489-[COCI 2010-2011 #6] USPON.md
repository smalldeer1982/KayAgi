# [COCI 2010/2011 #6] USPON

## 题目背景

Tomislav 去爬山。

## 题目描述

他所走的山路可以看做一个长度为 $n$ 的数字序列 $P_i$，$P_i$ 表示位置 $i$ 的高度为 $P_i$。

从低处往高处走一段**连续的高度严格递增的**山路称为一次爬升。

为了锻炼身体，他想走一段落差尽量大的爬升。

一段山路的落差定义为这段山路的结束点与起始点的差。

你需要求出他走一段山路所能达到最大的落差是多少。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 1000$，$1\le P_i\le 1000$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #6](https://hsin.hr/coci/archive/2010_2011/contest6_tasks.pdf) *T2 USPON***。

## 样例 #1

### 输入

```
5
1 2 1 4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
8
12 20 1 3 4 4 11 1```

### 输出

```
8```

## 样例 #3

### 输入

```
6
10 8 8 6 4 3```

### 输出

```
0```

# 题解

## 作者：王炸拆开打 (赞：14)

~~3分钟出思路，10分钟出代码~~（大佬发言）
# 乍一看：**上升子序列问题**
但是注意题中的要求，需要**连续的高度严格递增的**山路

所以我们的递推只需要$O(n)$,只用根据i-1的状态来决定i的状态

计算目前落差公式：$h[i]=a[i]-a[j]+h[j]$

(**a[i]点的高度,   h[i]子序列目前落差**)


放代码

```#include<cstdio>//上升子序列一定要严格且连续上升 
#include<iostream>
using namespace std;
int n,a[100001],f[10001],h[10001];//a[i]—点的高度、f[i]上升子序列长度、h[i]子序列目前落差 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {scanf("%d",&a[i]);f[i]=1;}//f[i]数组的初始化，每个数自己都是一个长度为一的上升序列 
   	for(int i=2;i<=n;i++){
   		int j=i-1;//j来代替i-1，更加简洁 
		if(a[j]<a[i]){//i大于前一个 
			f[i]=f[j]+1;//则以i为结尾的上升子序列长度加一 
			h[i]=a[i]-a[j]+h[j];//落差加一 
		}
    }
    int maxx=-1;
    for(int i=1;i<=n;i++) maxx=max(maxx,h[i]);//求最大落差 
    printf("%d",maxx);
    return 0;//结束，拉闸拉闸拉闸 
}
```
发现和第一篇题解相似，但完全是自己想的（勿喷）

**谢谢大佬们赏脸~**


---

## 作者：Miraik (赞：12)

为啥高赞题解都是 $O(n^2)$ 甚至以上...

提供简单好懂的 $O(n)$ 做法。

看懂题面，发现其实就是求最大的连续**严格**上升子序列的**最后一项与第一项**的差。

那么很显然，对于同一个**第一项**，序列长度越长，其值越大。

因此我们只要求出每段连续上升子序列，最后求出它们中的最大值即可。

推荐难度： 红/橙。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
int n,a[1005],ans;
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=2,j=1;i<=n;i++)//j表示该连续子序列的第一项 
	    if(a[i]<=a[i-1])ans=max(ans,a[i-1]-a[j]),j=i;//当该数不大于上一个数 ，说明上一个数是当前连续子序列的最后一项，而该数是下一个连续子序列的第一项 
	    else if(i==n)ans=max(ans,a[i]-a[j]);//特判，当i==n时，再统计一次，否则会忽略最后一段连续子序列的值 
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：小坦克 (赞：11)



# [题目传送门](https://www.luogu.com.cn/problem/P6489)

此方法就是一个 $O(N^2)$ 的做法：只需把每个点枚举一下，再判断是否可行，最后输出答案。

--------
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int ans;
int i,j;
int a[1001];
//int b[1001];
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++) scanf("%d",&a[i]);
	for(i=1;i<=n;i++)
	for(j=i+1;j<=n;j++)
		if(a[j]<=a[j-1]) break;
		else ans=max(a[j]-a[i],ans);
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：Lips (赞：5)

# 暴力出奇迹！

看楼下大佬用的都是$O(N)$的做法，~~不太好懂~~，所以这里给出一种$O(N^2)$的做法。毕竟$N=1000$这种数据范围暴力是可以水过的。

**做法：** 从$1$~$N$枚举左端点$left$，再在左端点的基础上枚举右端点$right$，一直枚举直到$a_{right}\leqslant a_{right-1}$的时候，将答案$ans$更新为$\max(ans,a_{right-1}-a_{left})$

当然，如果您按照这种做法做下去的话，肯定是过不了的，~~我也相信您不会这么做的~~，假设$right$以枚举到$N$，但当前的$a_{right}$还是严格大于$a_{right-1}$的，那么，$ans$仍不会更新答案。

所以，便要加一个特判：如果$right==N$且$a_{right}>a_{right-1}$，那么，将$ans$更新为$\max(ans,a_{right}-a_{left})$

直接上代码吧：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1010;
int n,a[MAXN],ans;
int main()
{
	scanf("%d",&n);//输入n 
	for(register int i=1;i<=n;i++) scanf("%d",&a[i]);//输入高度 
	for(register int left=1;left<=n;left++)//枚举左端点 
		for(register int right=left+1;right<=n;right++)//枚举右端点 
		{
			if(a[right]<=a[right-1]){ans=max(ans,a[right-1]-a[left]);break;}
			//如果不是严格大于a[right-1]，那么更新答案并break 
			if(right==n){ans=max(ans,a[right]-a[left]);break;}
			//特判如果已经枚举到n，那么更新答案 
		}	
	printf("%d\n",ans);//输出 
}
```

看窝写得这么认真，点个赞再走呗！

---

## 作者：wuyonghuming (赞：4)

## 思路：
枚举任何一个点，如果这个点的值不大于上一个点的值，说明不是递增，跳出循环，接着更新最大值。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n,p[1001],ans=0;//先默认没有递增数列
	cin>>n;//输入山的数量
	for(int i=1;i<=n;i++)//1到n循环
		scanf("%d",&p[i]);//输入
	for(int i=1;i<=n;i++)//枚举每一个点
	{
		for(int j=i+1;j<=n;j++)//从这个点往后一直找
		{
			if(p[j]<=p[j-1])//如果不符合要求
			{
				break;//跳出循环
			}
			ans=max(p[j]-p[i],ans);//更新最大值
		}
	}
	printf("%d",ans);//输出答案
	return 0;//别忘了
} 

```
谢谢观看，希望大家能看懂。

---

## 作者：wzkdh (赞：3)

## 一道简单的模拟题。

### 题意：
求上升序列的最大落差。

### 分析：
每一个点的高度减去开始上升的起点的高度就是他的落差，而他前一个点的落差等于前一个点的高度减去上升起点的高度，而这个点的落差也等于他的高度减去前一个点的高度加上前一个点的高度减去上升起点的高度，就等于他减去前一个点的高度加上前一个点的落差，所以每个点只需要知道前一个点的数据就可以求落差了，递推即可。

### 蒟蒻代码：
```
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[1010],w[1010],ans; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		if(a[i]>a[i-1])
		{
			w[i]=w[i-1]+a[i]-a[i-1];
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,w[i]);
	}
		printf("%d",ans);
	return 0;
}

---

## 作者：_tommysun_ (赞：2)

这道题就是纯模拟的水题吧。。。

先讲下思路：
- 设两个变量start,end表示这个爬升的头与尾。
- 接下来进循环，如果不是不再爬升就打擂台存储落差，再把end,start重置一下，否则就更新end。
- 最后记得在循环结束后再打一次擂台，因为如果数组的最后一个元素也是在爬升序列中的话是不会在循环中判断的。

另外，根本不需要刻意的判断是否要输出0，因为start和end的初始值是一样的，如果一直没有爬升是end是不会更新的，所以就是0。

**代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int max=-1;
	int n;
	cin>>n;
	int a[n+10];
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	int start,end;
	start=end=a[0]; //设初值。 
	for(int i=1;i<n;i++){
		if(a[i]<=a[i-1]){ //因为是高度严格递增，即使是相等也不行，所以要进循环。 
			if(end-start>max) max=end-start;  //打擂台 
			start=a[i]; //重新设初值。 
			end=a[i];
		}
		else end=a[i]; //更新end。 
	}
	if(end-start>max) max=end-start; //见上文。 
	cout<<max;
	return 0;
}
```


---

## 作者：happybob (赞：1)

准备NOIP入门比赛了，最近狂刷入门题目，感觉越来越~~简单~~

好吧，不说废话，这道题目不算很难，用了两次循环就AC了，86ms。

先说说题目意思吧：

有n个数，现在要求出递增子段最大数

以样例来看：

输入：

```cpp
5
1 2 1 4 6
```

输出：

```
5
```

首先第一个1比2小，递增，现在最大 = 2 - 1 = 1

然后2比1大，不递增，不作任何操作

下一步1比4小，递增，最大 =  4 - 1 = 3（前面2 - 1的结果不累加，因为是最大上升子段）

最后4比6小，递增，最大 = 3 + (6 - 4) = 5

一次我们会发现，连续一段递增的话和累加，不然和变为0

代码来：
```cpp
#include <iostream>
using namespace std;

int arr[1005];

int main()
{
    int n, max = 0, sum = 0;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> arr[i];
    }
    for(int i = 1; i <= n - 1; i++)
    {
        if(arr[i + 1] > arr[i])
        {
            sum += arr[i + 1] - arr[i];
        }
        else
        {
            sum = 0;
        }
        max = sum > max ? sum : max;
    }
    cout << max << endl;
    return 0;
}
```

说下三目运算符

条件 ? 值 : 值;

如果条件满足，返回true，即值1，否则返回值2

如：
```cpp
int x = 1 + 2 == 3 ? 3 : 0;
```
x = 3

又如：
```cpp
int x = 1 + 2 == 3 && 1 + 1 == 1 ? 2 : -1;
```
x = -1

---

## 作者：Terraria (赞：0)

作为一道红题，看到**连续的高度严格递增**时的我~~差点以为是恶意评分~~丝毫不慌。

乍一看，就是求最长不降子序列的最大值减最小值嘛，直接用 $O(n)$ 求解。

但是乍一看数据：$1 \leq n \leq 1000$，这个数据告诉我们什么——用 $O(n^2)$ 水过啊！~~何乐而不为呢？~~

鉴于这是一道红题，我还是仔细地讲一下过程 ~~（大佬勿喷）~~：

从每一个节点 $a_i$ 开始往后搜，如果搜到的数 $a_j\leq a_{j-1}$，则说明当前序列再往后已经不是连续上升子序列，所以直接退出循环即可；

假如没有退出循环，那么很明显，下一个搜出的数一定会更新当前的陡峭程度（因为这个数$a_{j-1} \leq a_{j}$）所以，用当前搜出的值减去 $a_i$ 就好了。

所以代码就出来啦：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1009];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int maxnum=0;
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if(a[j]<=a[j-1]) break;
            else maxnum=max(maxnum,a[j]-a[i]);
        }
    }
    cout<<maxnum;
    return 0;
}
```


---

## 作者：tribool4_in (赞：0)

## 前言
一看题，**最长上升子序列**？再一看数据范围：$1 \le n \le 1000$，原来 $O(n^2)$ 暴力能过……

### 解法一（暴力）

没啥好说的，**枚举左右端点并判断是否可行，最后求最大值并输出即可**。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int ans;
int a[1005];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (a[j] <= a[j - 1]) break;
            else ans = max(a[j] - a[i], ans);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

### 解法二（线性算法）

再一想，其实我们只需扫一遍原数组即可。方法如下：

1. 如果当前位置为爬升起始点，标记当前位置；

2. 如果当前位置非爬升起始点，则更新最大落差；

然后就完成了！（具体看注释）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int ans;
int a[1001];
int main() {
	scanf("%d",&n);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i++)
		for(int j = i + 1; j <= n; j++)
			if (a[j] <= a[j - 1]) break; // 当前位置为爬升起始点，标记当前位置
			else ans = max(a[j] - a[i], ans); // 否则则更新最大落差
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Gorenstein (赞：0)

分享一个简单易懂的 $O(n)$ 做法。

题目要求我们求出一个序列，所有连续的严格单调递增子序列的首尾的差的最大值。

所以很显然，每一个这样的序列都是在一起的。因此只需要从头到尾过一遍就能求出答案了。

定义一个结构体数组，记录山的高度和爬到这座山为止最大的爬升距离（这座山一定要爬到）。一边读入一边处理，如果现在这个比前面那个大，那么就把结构体中的$ans$累加上爬升的距离即可。

```cpp
if(high[i].h>high[i-1].h)
	high[i].ans=high[i-1].ans+high[i].h-high[i-1].h;
```

具体细节看看我的AC代码。

```cpp
struct node{
	int ans,h;//分别表示爬到这座山为止最大的爬升距离，和这座山的高度
}high[100005];
int n,maxn;
int main(){
	cin>>n>>high[0].h;//先读入第一座山
	high[0].ans=0;
	for(int i=1;i<n;i++){
		cin>>high[i].h;
		high[i].ans=0;
		if(high[i].h>high[i-1].h)//如果比前面的山高
			high[i].ans=high[i-1].ans+high[i].h-high[i-1].h;//累计高度
		maxn=max(maxn,high[i].ans);
	}
	cout<<maxn;
	return 0;
} 
```

如果还是不理解的话，就看一下样例 ``1 2 1 4 6`` 。

读入到$high_1$的时候，此时比前面一座山高，于是累计$high_1.ans$，为前一座山的ans加上爬升的高度；

读入到$high_2$了，发现比前一座山矮。因此此时ans不累计还是为0；

读入到$high_3$了，比前一座山高，于是累计$high_2.ans$为前一座山的ans加上爬升的高度;

同理，读入到$high_4$，累计ans为前一座山的ans加上爬升的高度（$3+2=5$）.

最终得到的 $high_i.ans$为 ``0 1 0 3 5`` 。

时间复杂度是$O(n)$。

---

## 作者：2021_03_21 (赞：0)

## 题意：
给定 $n$ 个数，求每个最长上升序列的最后一个数减去第一个数的最大值。
## 思路：
显然我们要截取每段最大的爬升长度进行比较，枚举一遍即可。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1100];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	int minn=a[1],ans=0;
	for(int i=2;i<=n;i++)
	{
		if(a[i]<=a[i-1])minn=a[i];
		else ans=max(ans,a[i]-minn);
	}
	cout<<ans;
}
```

---

## 作者：Fat_Fish (赞：0)

从低处往高处走一段连续的、高度严格递增的山路称为一次爬升，注意**是严格递增**，直白一点就是爬升不能两数相等
话不多说，上代码，$O(n^2)$
注释都在代码里
```cpp
#include<iostream>
#include<bits/stdc++.h>//万能头
#define max(a,b) a>b?a:b //宏定义max函数，STL自带的很耗时间 
using namespace std;
int main(){
	ios::sync_with_stdio(false);//节省缓冲区，优化 
	int n;
	cin>>n;
	int a[n+2]={0,0,0,0,0,-1e9};//若是从某一位到最后一个，-1e9作为结束（解决如样例一的情况） 
	for(int i = 1;i<=n;++i){
		cin>>a[i];//循环输入 
	}
	int MAX = 0;//最大落差，初值为0，符合如果整条山路不包含任何的爬升，则输出 0
	for(int i = 1;i<n;++i){//以i作为起点 ，开始爬山 
		for(int j = i+1;j<=n+1;++j){
			if(a[j-1]>=a[j]){//如果不再爬升那么记录下前面的落差即爬了多少 
				MAX = max(MAX,a[j-1]-a[i]);//更新 
				break;//不再爬升就不符合要求，退出 
			}
		}
	}
	cout<<MAX;//输出答案 
	return 0;//结束，好习惯return 0； 
}  
```

---

## 作者：novax (赞：0)

数据范围很小，$n^2$ 做法都可以过，但我还是说一下 $O(n)$ 的做法

思路很简单，就是模拟，用一个循环，记录一个连续上升的山路的长度，
如果下一个位置高度比当前低，那么就记录一下这一段上升山路的落差，并更新答案，否则继续。需要注意的是，在整个循环结束后要在更新一次答案，因为在循环中最后一个点上可能不会更新答案

#### 代码如下
```
#include <cstdio>
#define max(a,b)  (((a)>(b))?(a):(b))
int N,p[1010],i,L,R,ans;
int main()
{
	scanf("%d",&N);
	for(i=0;i<N;i++)
		scanf("%d",&p[i]);
	L=p[0];R=p[0];
	for(i=1;i<N;i++)
	{
		if(p[i]<=p[i-1])
		{
			ans=max(R-L,ans);
			L=p[i];
		}
		R=p[i];
	}
	ans=max(R-L,ans);
	printf("%d\n",ans);
}
```


---


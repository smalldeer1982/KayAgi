# [COCI 2010/2011 #3] ZBROJ

## 题目描述

老师给了 Perica 两个数 $a, b$，Perica 将他们抄在了笔记本上，并要算出他们的和。

在抄写过程中，Perica 可能会将 $a, b$ 中的数字 $6$ 错抄成数字 $5$，也可能将数字 $5$ 错抄成数字 $6$，当然也可能不抄错。

给定 $a, b$，请求出 Perica 算出的和最小和最大分别是多少。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq a, b \leq 10^6$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #3](https://hsin.hr/coci/archive/2010_2011/contest3_tasks.pdf) *T2 ZBROJ***。

## 样例 #1

### 输入

```
11 25
```

### 输出

```
36 37```

## 样例 #2

### 输入

```
1430 4862
```

### 输出

```
6282 6292
```

## 样例 #3

### 输入

```
16796 58786
```

### 输出

```
74580 85582
```

# 题解

## 作者：Utilokasteinn (赞：35)

原本想写高精，写出来后，什么也输出不了。所以换了一个思路，代码很短，速度也挺快的。意思就是记录哪个数是5或6，最后再加上或减去，先附几个例子，自己先理解一下吧。
```cpp
a:  8279824   9589376   3344565   
s1: 0000000   0100000   0000101
s2: 0000000   0000001   0000010

如果所在那一位是6，要达到最少，那一位就必须减去1
如果所在那一位是5，要达到最多，那一位就必须加上1
在程序中，定义一个s看现在算到了第几位
而这个1的大小就是pow(10,s-1)
最后在加上或减去就行了

```
代码如下(实测31ms):
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,s1,s2;
    //s1代表最大与a+b相差的值，s2代表最小与a+香肠的值 
    cin>>a>>b;//输入a和b 
    for(int s=1,x=a;x;x/=10,s*=10)
    //s记录在哪一位是5或6，s每次都乘10 
    	if(x%10==5)s1+=s;//核心代码 
    	else if(x%10==6)s2+=s;
    for(int s=1,y=b;y;y/=10,s*=10)//同上 
    	if(y%10==5)s1+=s;
    	else if(y%10==6)s2+=s;
    cout<<a+b-s2<<" "<<a+b+s1;//输出最小和最大 
    return 0;//结束程序 
}
```
最后附上无注释代码，代码比其他题解都简洁很多：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,s1,s2;
    cin>>a>>b;
    for(int s=1,x=a;x;x/=10,s*=10)
    	if(x%10==5)s1+=s;
    	else if(x%10==6)s2+=s;
    for(int s=1,y=b;y;y/=10,s*=10)
    	if(y%10==5)s1+=s;
    	else if(y%10==6)s2+=s;
    cout<<a+b-s2<<" "<<a+b+s1;
    return 0;
}
```
谢谢观赏

---

## 作者：Into_qwq (赞：11)

# 这题还是比较好做的

看了一下别人的题解，我觉得有点复杂（仅是个人观点）

`为什么非要用字符串呢？`

我用的方法是

首先定义2个变量：$minvalue$&&$maxvalue$，将它们的初始值都设为$a+b$

然后把$a$和$b$的每一位都枚举一遍，如果是5就把$maxvalue$加当前位数,如果是6就把$minvalue$减当前位数

这时我们可以这样枚举:

```c++
int cnt=1;//cnt是枚举当前位,1表示个位
while(a)//当a!=0时
{
	int x=a%10;//取a的最末位
	if(x==5) maxvalue+=cnt;//如果是5就把maxvalue加当前位数
	if(x==6) minvalue-=cnt;//如果是6就把minvalue减当前位数
	a/=10;//去掉a的最末位
	cnt*=10;//进位
}
```

完整代码如下:
```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	scanf("%d %d",&a,&b);
	int value=a+b,minvalue=a+b,maxvalue=a+b;
	int cnt=1;
	while(a)
	{
		int x=a%10;
		if(x==5) maxvalue+=cnt;
		if(x==6) minvalue-=cnt;
		a/=10;
		cnt*=10;
	}
	cnt=1;
	while(b)
	{
		int x=b%10;
		if(x==5) maxvalue+=cnt;
		if(x==6) minvalue-=cnt;
		b/=10;
		cnt*=10;
	}
	printf("%d %d",minvalue,maxvalue);
 	return 0;
}

```
完美结束

---

## 作者：LinkZelda (赞：6)

- ### **分析**：

对于最大的和，即要保证来两个相加的数最大，也就是**每一位要尽可能地大**，那么我们可以将数中所有的 $5$ 改成 $6$ 即可，然后输出就行。

对于最小的和思路同上，保证**两个数尽可能小**，将所有的 $6$ 改成 $5$ 即可。

- ### **实现方法**:

一位位改，我们很容易想到字符串，但又不想写高精，怎么办呢？

在 $stdilb.h$ 库中，有一个叫 $atoi$ 的函数，可以很方便地吧字符串转化为整数。用法如下:
```cpp
atoi(const char*str)//参数是字符串str的地址
str.data()//这个成员函数可以求出字符串str的地址
```

- ### **代码**:
```cpp
#include<iostream>
#include<string>
#include<cstring>
#include<stdlib.h>//使用atoi函数，调用stdilb.h库
using namespace std;
int main()
{
	string s1,s2;//存第一个数和第二个数
	int maxa,maxb,mina,minb;//存a与b的最值
	cin>>s1>>s2;
	for(int i=0;i<s1.size();i++)if(s1[i]=='6')s1[i]='5';//每一位尽量小
	for(int i=0;i<s2.size();i++)if(s2[i]=='6')s2[i]='5';//每一位尽可能小
	mina=atoi(s1.data());//将字符串转化为整数
	minb=atoi(s2.data()); //将字符串转化为整数
	for(int i=0;i<s1.size();i++)if(s1[i]=='5')s1[i]='6';//每一位尽量大 
	for(int i=0;i<s2.size();i++)if(s2[i]=='5')s2[i]='6';//每一位尽可能大 
	maxa=atoi(s1.data());//将字符串转化为整数
	maxb=atoi(s2.data()); //将字符串转化为整数
	cout<<mina+minb<<' '<<maxa+maxb;//输出最小和与最大和
	return 0;
 } 
```



---

## 作者：Mr_WA的大号 (赞：4)

吾皇ACAC再AC！小学生又来发题解了！

题号：P6500

难度：★

算法：数论，模拟

## 开课了！

这一题是一道非常容易的题目。我们先要明确题目的条件：数字中的5可以写成6，6可以写成5。

他要求最大和与最小和。我们可以轻松地知道：5改成6之后变大了，6改成5之后变小了。所以我们得出：最大值就是把两个数字中的5都改成6，最小值是把6都改成5。

建议：输入的两个数字可以用字符串存储，这样方便以后的查找。

课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<iomanip>
using namespace std;
string st,st1;
int big1,big2,small1,small2;
int main()
{
	cin>>st>>st1;//输入用字符串存储的数字
	for(int i=0; i<st.size(); i++)
	{
		if(st[i]=='5')big1=big1*10+st[i]-48+1;
		else big1=big1*10+st[i]-48;//最大值将5变成6
		if(st[i]=='6')small1=small1*10+st[i]-48-1;
		else small1=small1*10+st[i]-48;//最小值将6变成5
	}
	for(int i=0; i<st1.size(); i++)
	{
		if(st1[i]=='5')big2=big2*10+st1[i]-48+1;
		else big2=big2*10+st1[i]-48;//最大值将5变成6
		if(st1[i]=='6')small2=small2*10+st1[i]-48-1;
		else small2=small2*10+st1[i]-48;//最小值将6变成5
	}
	cout<<small1+small2<<' '<<big1+big2;//输出最大值和最小值
	return 0;
}
```
祝大家能AC！

---

## 作者：Xeqwq (赞：2)

这道题的方法应该不多，但是很好想——把输入的字符串里面的所有字符5或者6都变成'X'，然后来处理问题。  
最大值，也就是将所有的5或者6都变成6，最小值就是都变成5。  
~~蒟蒻懂的很少，不会写那么多自带的函数，于是记老老实实自己写函数了~~   
~~勿抄题解~~  
code：  
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
string da(string a)//把所有数变成最大的情况
{
	int as=a.size();
	for(int i=0;i<as;i++)
	{
		if(a[i]=='X')//如果之前被换成了X
			a[i]='6';//那就换成6
	}
	return a;
} 
string xiao(string a)//将上面的复制粘贴一下，然后改个名字
{
	int as=a.size();
	for(int i=0;i<as;i++)
	{
		if(a[i]=='X')
			a[i]='5';//这里是5了
	}
	return a;
}
int string_to_int(string a)//将字符串转换成整形类型
{
	int s=0;//s，返回值
	int i=0;//循环计数
	int as=a.size();//减少运算量
	while(i<as)
	{
		s=10*s+int(a[i]-'0');//位置原理，前面的*10然后加上最后一位也就是向后塞位了
		i++;	
	}
	return s;//就这个，我一直没有看出来，结果检查了好久。。。
}

int main()
{
	string a,b;//输入的两个数，但是我还是想用string存储
	cin>>a>>b;//输入
	int as=a.size();//简便后面的判定运算
	int bs=b.size();
	for(int i=0;i<as;i++)//转换成X
	{
		if(a[i]=='5'||a[i]=='6')
			a[i]='X';
	}
	for(int i=0;i<bs;i++)//同上
	{
		if(b[i]=='5'||b[i]=='6')
			b[i]='X';
	}
	int ad,ax,bd,bx;//分别对应a的最大值、a的最小值、b的最大值和b的最小值。
   //这四行没问题吧，按照意思走就行了
	ad=string_to_int(da(a));
	ax=string_to_int(xiao(a));
	bd=string_to_int(da(b));
	bx=string_to_int(xiao(b));
	cout<<ax+bx<<" "<<ad+bd;//输出，没问题了
	return 0;//完美结束
}
```
谢谢大家~谢谢管理员

---

## 作者：btng_smith666 (赞：2)

~~我是被题号吸引来做的~~

这题还是挺新鲜的，因为里面夹杂了一些有趣的小知识。

介绍一个用来将`string`类型转为`int`类型的语句：

```cpp
atoi(string.c_str());
```

其中的`string`是指 $string$ 类型的变量名，`stoi`用来实现整型转字符串类型，`.c_str()`用来取`string`的地址

然后再看题，首先题目中说可能把数字 $5$ 抄成 $6$ 或 $6$ 抄成 $5$ ，那么肯定是要把这个数字看成字符串进行处理的，题目中又说要找**最小可能的和以及最大可能的和**，那么最小的就肯定是把原来的 $6$ 全改成 $5$ ，最大的就反过来处理，有了这些思路，就可以愉快地敲代码啦

Code :

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans1,ans2;
int qwq()//对数字进行处理 
{
	string str;
	cin>>str;//输入数字 
	string x,y;//分别存最大值和最小值 
	x=y=str;
	for(int i=0;i<x.size();i++) 
	    if(x[i]=='6')//如果是 6 
			x[i]--;//就把它变成 5 
	for(int i=0;i<y.size();i++)
	    if(y[i]=='5')//如果是 5 
			y[i]++;//就把它变成 6 
	ans1+=atoi(x.c_str());//最小值，因为要求和所以累加到计数器里 
	ans2+=atoi(y.c_str());//最大值，因为要求和所以累加到计数器里 
}
int main()
{
	qwq();qwq();//两个数分别作处理 
	cout<<ans1<<" "<<ans2;//输出最小和和最大和 
	return 0;
}
```


---


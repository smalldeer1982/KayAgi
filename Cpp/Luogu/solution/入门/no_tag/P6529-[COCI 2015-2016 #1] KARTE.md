# [COCI 2015/2016 #1] KARTE

## 题目描述

这里有一堆牌，可惜它们似乎不全。

您需要找出每种花色缺失的张数。

如果有相同的扑克牌，请输出 `GRESKA`。

## 说明/提示

#### 【样例解释】
#### 样例 1 解释
有一张花色为 `P` 的牌，一张花色为 `K` 的牌，两张花色为 `H` 的牌。
#### 样例 2 解释
这里有两张 `H02` ，所以输出 `GRESKA`。

#### 【数据范围及限制】
对于 $100\%$ 的数据，保证 $1\le \lvert s\rvert\le 10^3$ 且 $s$ 中仅含有数字与 `P`，`K`，`H`，`T`，每张牌的点数 $\in [1,13]$ 。

#### 【说明】
**本题满分 $50$ 分。**

本题译自 [Croatian Open Competition in Informatics 2015/2016](https://hsin.hr/coci/archive/2015_2016) [Contest #1](https://hsin.hr/coci/archive/2015_2016/contest1_tasks.pdf) T1 KARTE。

## 样例 #1

### 输入

```
P01K02H03H04```

### 输出

```
12 12 11 13```

## 样例 #2

### 输入

```
H02H10P11H02```

### 输出

```
GRESKA```

## 样例 #3

### 输入

```
P10K10H10T01```

### 输出

```
12 12 12 12```

# 题解

## 作者：Sarcasm (赞：14)

## [题目传送门](https://www.luogu.com.cn/problem/P6529)

------------
#### 废话不多说，直接上思路
## 暴力模拟
 1. 先读入一个字符串
 1. 将牌储存到一个结构体中（用于判断重复）
 1. 将同一花色的牌的个数统计出来
 1. 用同一花色的总牌数减去这个花色的牌数
 1. 判断是否重复
 1. 输出


------------
c++的代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int p=13,k=13,h=13,t=13,sum;//由于一副扑克牌有54张，去掉大小王还有52张，因为有4个花色，则每个花色有13张 
struct node{
	char hua;//储存花色 
	int num;//储存点数 
}c[10010];
int main(){
	cin>>a;//读入字符串 
	for(int i=0;i<a.length();i+=3){//由于每三个字符为一张，所以i=i+3 
		if(a[i]=='P') p--;
			else if(a[i]=='K') k--;
			else if(a[i]=='H') h--;
			else t--;
		c[++sum].hua=a[i];//储存花色 
		c[sum].num=(a[i+1]-'0')*10+(a[i+2]-'0');//储存点数 
	}
	for(int i=1;i<sum;i++)
		for(int j=i+1;j<=sum;j++)
			if(c[i].hua==c[j].hua&&c[i].num==c[j].num){
				printf("GRESKA");
				return 0;
				//有牌相同，输出，直接结束程序 
			}
	//这里判断有牌相同的情况		
	printf("%d %d %d %d",p,k,h,t);//输出 
	return 0;
}
```


---

## 作者：_Fontainebleau_ (赞：5)

一道很简单的模拟，思路很简单，容易理解。

我们不用 $STL$ 不用 $struct$ 。

这里提供两种方法。


------------


法 $1$：

很正常的先读数据，用四个数组记录当前花色，当前点数的牌的数量。如果一张牌出现两次及以上，直接输出 $GRESKA$。

然后将四个数组扫一遍，看一看有没有缺牌，缺的话就 就加 $1$ 。

于是 $code$
```cpp
#include<bits/stdc++.h>
#define FOR(i,j,k)  for(int i=(j);i<=(k);i++)
using namespace std;
char tmp;
int x;
int p[14],k[14],h[14],t[14];
int main()
{
	while(cin>>tmp)
	{
		cin>>x;
		if(tmp=='P')	p[x]++;
		else if(tmp=='K')	k[x]++;
		else if(tmp=='H')	h[x]++;
		else if(tmp=='T')	t[x]++;
		if(p[x]>1||k[x]>1||h[x]>1||t[x]>1)
		{
			printf("GRESKA\n");
			return 0;
		}
	}
	int nump=0,numk=0,numh=0,numt=0;
	for(int i=1;i<=13;i++)
	{
		if(p[i]==0)	nump++;
		if(k[i]==0)	numk++;
		if(h[i]==0)	numh++;
		if(t[i]==0)	numt++;
	}
	printf("%d %d %d %d",nump,numk,numh,numt);
	return 0;
}
```


------------
法 $2$ :

我们一边读一边做。

一开始假设每个花色都没有一张牌。

于是 
```cpp
int ansp=13,ansk=13,ansh=13,anst=13;
```
然后每读入一张牌，就将对应花色数量减 $1$ 。

读完，直接输出即可。

$code$

```cpp
#include<bits/stdc++.h>
#define FOR(i,j,k)  for(int i=(j);i<=(k);i++)
using namespace std;
char tmp;
int x;
int p[14],k[14],h[14],t[14];
int ansp=13,ansk=13,ansh=13,anst=13;
int main()
{
	while(cin>>tmp)
	{
		cin>>x;
		if(tmp=='P')	p[x]++,ansp--;
		else if(tmp=='K')	k[x]++,ansk--;
		else if(tmp=='H')	h[x]++,ansh--;
		else if(tmp=='T')	t[x]++,anst--;
		if(p[x]>1||k[x]>1||h[x]>1||t[x]>1)
		{
			printf("GRESKA\n");
			return 0;
		}
	}
	printf("%d %d %d %d",ansp,ansk,ansh,anst);
	return 0;
}

```


---

## 作者：3water (赞：5)

## 可以用map+pair搞

 _字符串处理_ ：
```cpp
int len=s.size();
for(int i=0;i<len;i+=3){
	char c=s[i];//处理字符
	int a=(s[i+1]-'0')*10+s[i+2]-'0';//处理数字
}
```
 _因为扑克标志符为符号，所以我们可以用map搞——_ 
```cpp
map<pair<char,int>,bool>cnt;//用于标记是否重复
map<char,int>last;//用于标记拥有的扑克牌的张数
```
 _然后用pair赋值——（续上字符串处理）_ 
```cpp
pair<char,int>newp;
newp.first=c,newp.second=a;//将字符与数字捆绑
if(cnt[newp]){//如果有重复
	cout<<"GRESKA";
	return 0;//直接跳过
}
cnt[newp]=true;//否则标记
last[c]++;//扑克张数+1
```
####  _问题就迎刃而解了_ 
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
string s;
map<pair<char,int>,bool>cnt;
map<char,int>last;
char ch[5]={'P','K','H','T','\0'};//用于按照顺序输出
int main(){
	cin>>s;
	int len=s.size();
	for(int i=0;i<len;i+=3){
		char c=s[i];
		int a=(s[i+1]-'0')*10+s[i+2]-'0';
		pair<char,int>newp;
		newp.first=c,newp.second=a;
		if(cnt[newp]){
			cout<<"GRESKA";
			return 0;
		}
		cnt[newp]=true;
		last[c]++;
	}
	for(int i=0;i<4;i++)cout<<13-last[ch[i]]<<' ';//计算剩余张数
}
```


---

## 作者：LinkZelda (赞：4)

## **暴力法题解**

我们先看**数据范围**，最多就 $13*4$ 张牌。

很明显可以直接暴力判断牌的花色和点数，用一个 $ bool$ 数组记下**该牌是否出现**，重复出现就输出 $\rm GRESKA$  ,否则就记录该牌已出现（数组改为 $true$ ）。

- ### 代码：
```cpp
#include<iostream>
using namespace std;
bool P[14],K[14],H[14],T[14];//记录这些花色点数是否已存在 
int main()
{
	char c;//记录输入的花色
	while(cin>>c)//一直输入字符，直到没得输入为止
	{
		int k;//输入点数 
		cin>>k;
		switch(c)//暴力判断花色
		{
			case 'P':
				if(P[k])//如果该牌已经存在 
				{
					cout<<"GRESKA";//输出并结束程序 
					return 0;
				}
				else P[k]=1;//否则标记该牌存在 
				break;
			case 'K':
				if(K[k])//如果该牌已经存在 
				{
					cout<<"GRESKA";//输出并结束程序 
					return 0;
				}
				else K[k]=1; //否则标记该牌存在
				break;
			case 'H':
				if(H[k])//如果该牌已经存在 
				{
					cout<<"GRESKA";//输出并结束程序 
					return 0;
				}
				else H[k]=1; //否则标记该牌存在
				break;
			case 'T':
				if(T[k])//如果该牌已经存在 
				{
					cout<<"GRESKA";//输出并结束程序 
					return 0;
				}
				else T[k]=1; //否则标记该牌存在
				break;
		}
	}
	int cntp=0,cntk=0,cnth=0,cntt=0;//记录不同花色牌的数量 
	for(int i=1;i<=13;i++)//扫一次看看不同花色牌的数量
	{
		if(P[i])cntp++;
		if(K[i])cntk++;
		if(H[i])cnth++;
		if(T[i])cntt++;
	}
	cout<<13-cntp<<' '<<13-cntk<<' '<<13-cnth<<' '<<13-cntt<<' ';
	return 0;
}

```



---

## 作者：Licykoc (赞：4)

没`Pascal`的题解，来水一下

题目很简单，具体看代码吧:

```pascal
var 
    str:ansistring; //用于储存输入的字符串
    x:char;  
    y,s,i:longint;
    f:array['A'..'Z',0..13] of longint; //第一维表示花色，第二维表示点数
begin
    read(str); //输入
    while str<>'' do //如果str还有值
      begin 
        x:=str[1];  //复制花色
        val(copy(str,2,2),y); //复制点数
        if f[x,y]>0 then begin write('GRESKA'); exit; end;
        //判断，如果这张牌以出现过，就输出GRESKA并退出
        inc(f[x,y]); //出现次数++
        delete(str,1,3); //将以处理的扑克牌删去
      end;
    s:=13; //初始化
    for i:=1 to 13 do s:=s-f['P',i]; //统计P牌出现次数
    write(s,' '); //输出
    s:=13;  //再次初始化
    for i:=1 to 13 do s:=s-f['K',i]; //统计K牌出现次数
    write(s,' ');
    s:=13;
    for i:=1 to 13 do s:=s-f['H',i]; 
    write(s,' ');
    s:=13;
    for i:=1 to 13 do s:=s-f['T',i];
    write(s);
end.
```

---

## 作者：tZEROちゃん (赞：4)

**思路**

开 $4$ 个数组记录每一个花色的每一张牌是否存在，再定义 $4$ 个变量记录每一张牌的数量。

使用 while 循环，每次循环读入花色 $c$ 和牌上的数字 $num$，使用 $4$ 个 if 语句判断花色，以 `P` 为例，如果该牌已经出现，则输出 `GRESKA` 并 `exit(0);` 否则就将 $nump_{num} + 1$，并将 $p + 1$。


**代码实现**

1. 开 $4$ 个数组记录每一个花色的每一张牌是否存在。
```cpp
	int nump[14];
	int numk[14];
	int numh[14];
	int numt[14];
```

2. 再定义 $4$ 个变量记录每一张牌的数量。
```cpp
	int p = 0, k = 0, h = 0, t = 0;
```

3. 定义 $2$ 个变量 $c, num$，分别表示花色和牌上数字。
```cpp
	char c;
	int num;
```

4. while 循环以判断，判断思路见上方 [思路] 区。
```cpp
	while(cin >> c >> num)
	{
		if(c == 'P')
		{
			if(nump[num] == 0)
				nump[num]++, p++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
		if(c == 'K')
		{
			if(numk[num] == 0)
				numk[num]++, k++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
		if(c == 'H')
		{
			if(numh[num] == 0)
				numh[num]++, h++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
		if(c == 'T')
		{
			if(numt[num] == 0)
				numt[num]++, t++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
	}
```

5. 输出结果。
```cpp
	cout << 13 - p << ' ' << 13 - k << ' ' << 13 - h << ' ' << 13 - t;
```

**Code**
```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define MIN -10000000
#define MAX 10000000
#define debug printf("%d",__LINE__)
using namespace std;
int nump[14];
int numk[14];
int numh[14];
int numt[14];
int main()
{
	int p = 0, k = 0, h = 0, t = 0;
	char c;
	int num;
	while(cin >> c >> num)
	{
		if(c == 'P')
		{
			if(nump[num] == 0)
				nump[num]++, p++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
		if(c == 'K')
		{
			if(numk[num] == 0)
				numk[num]++, k++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
		if(c == 'H')
		{
			if(numh[num] == 0)
				numh[num]++, h++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
		if(c == 'T')
		{
			if(numt[num] == 0)
				numt[num]++, t++;
			else
				cout << "GRESKA" << endl, exit(0);
		}
	}
	cout << 13 - p << ' ' << 13 - k << ' ' << 13 - h << ' ' << 13 - t;
	return 0;
}
```

---

## 作者：CCCloud (赞：2)

## 暴力模拟+switch  
**题目**：[在这里](https://www.luogu.com.cn/problem/P6529)  
**主要思路**：  
1、**读入**一个字符串；  
2、**三个为一组**，记录每种花色**出现的次数**与每种花色的牌的**点数是否出现**；
3、如果有**重复**的牌，则**输出** $GRESKA$ 并**结束循环**   
4、**重复第2步**直到字符串**被遍历完**；  
5、如果循环到这里，那么**肯定没有重复的牌**，就**直接输出剩下的牌的个数**； 

#### 主要代码实现如下：
（我是喜欢全部**读入完后再进行遍历**
```cpp
for(int i=1; i<=len; i+=3)//三个为一组分组
    {
        switch (s[i])//switch看起来方便一些
        {
        case 'P'://如果是‘P’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[1][n]) a[1][n]=1, f[1]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        case 'K'://如果是‘K’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[2][n]) a[2][n]=1, f[2]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        case 'H'://如果是‘H’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[3][n]) a[3][n]=1, f[3]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        case 'T'://如果是‘T’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[4][n]) a[4][n]=1, f[4]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        }
    }
    
    printf("%d %d %d %d\n", 13-f[1], 13-f[2], 13-f[3], 13-f[4]);
    //如果没有重复的，那么输出每张牌差的个数
```
感谢阅读本题解，希望此题解能够给您带来便利！

---

## 作者：hensier (赞：2)

这道题是一个纯模拟题。我们可以一边读入一边存储，以$3$个字符为一个单位进行存储，并且设置$bool$数组存放当前牌是否已经被提及到。如果当前的$bool$元素已经标记为真，那么直接输出`GRESKA`并结束整个程序即可。

当然，为了把`P,K,H,T`与数字下标进行配对，我们可以使用[$map$](http://www.cplusplus.com/reference/map/map/)。`map`可以实现任意数据类型和任意数据类型之间的一一对应。本蒟蒻的理解就是：加强版的数组——可以在任意类型的下标中存放任意类型的数据。使用方法是：

```cpp
map<type1,type2>name;//定义一个名字为name的map，其下标类型为type1，下标中存储的元素为type2类型
//在C++11或以上的版本中，我们可以直接对map进行赋值，例如：
map<string,int>str={{"A1",1},{"A2",2},{"A3",3}};
//上面这句可以同时实现定义和赋值两种功能，但在普通C++（C++11以下版本）不可使用
cout<<str["A2"];//对于上面的str，可以直接用字符串下标，进行输出。输出结果为2，符合之前的定义 
```

最后，在$bool$二维数组中分别对$0-3$的第一个下标中的$13$个元素有多少个值为$false$，并用空格分隔输出。

`C++`代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
string temp;//temp用来保存输入的3个字符
map<char,int>type;//定义<char,int>类型的map，名字为type
bool card[4][15];//bool二维数组
int id;
int main()
{
    type['P']=0;
    type['K']=1;
    type['H']=2;
    type['T']=3;//本蒟蒻没有使用C++11或以上版本，所以只好这样赋值
    while(1)
    {
        char ch=getchar();//getchar()输入更快
        if(ch=='\n')break;//换行符读到就退出
        id++;//id加一
        temp+=ch;//temp字符串加入字符
        if(id==3)//=3就进行操作
        {
            int x=type[temp[0]],y=((temp[1]^'0')<<3)+((temp[1]^'0')<<1)+(temp[2]^'0');//(a<<3)+(a<<1)等同于a*10，但速度更快
            if(card[x][y])//判断
            {
                cout<<"GRESKA";
                return 0;
            }
            card[x][y]=true;//标记
            temp="";
            id=0;//重新赋值
        }
    }
    for(int i=0;i<4;i++)
    {
        int cnt=0;
        for(int j=1;j<=13;j++)cnt+=card[i][j];//累加
        cout<<13-cnt<<" ";//输出
    }
    return 0;
}
```

当然，使用`Python`也是可以完成本题的。我们只需要了解一些特殊的函数及其用法即可。

`Python3`代码：~~（`Python2`会`CE`）~~

```python
import sys
s = str(input()) # 开始先输入字符串s
a = {'P': 0, 'K': 1, 'H': 2, 'T': 3} # 可以通过这种方式来实现一一对应，类似于C++:map
card = [[False for i in range(14)] for j in range(4)] # 定义数组，将其全部赋值为False
for i in range(len(s)): # 对于每一个字符串的下标进行循环
    if i % 3 == 2: # 这个时候就表示这个字符是每一段（3个字符为一段）的最后一个（下标从0开始）
        x = a[s[i - 2]] # s[i - 2]为字母，而a[s[i - 2]]就表示这个字母的索引编号
        y = int(s[i - 1], base = 0) * 10 + int(s[i], base = 0) # int(chr, base = 0)可以将一个字符（这个字符为单个数字）转换为int类型，y就等同于这张牌的数
        if card[x][y] == True: # 如果已经有就打印GRESKA
            print('GRESKA')
            sys.exit() # 注意，sys.exit()表示退出整个程序，但是在一开始要import sys
        else: # 否则标记为真
            card[x][y] = True
for i in range(4): # 索引有3个（0-3，但是python中for循环中的range(end)等同于C++:for中的i<end条件）
    cnt = 0 # 一开始cnt为0
    for j in range(14):
        cnt+=int(card[i][j]) # 注意！True和1，False和0在Python中有区别，不像C++可以直接强制转换，所以要加int()
    print(13 - cnt, end=' ') # 输出，结尾为空格，否则会用换行符分隔
```

运行结果：

|语言|时间大小|空间大小|代码大小|链接|无注释代码
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|`C++`|$47ms$|$720.00KB$|$732B$|[提交记录](/record/33374994)|[查看代码](/paste/8q4c058m)|
|`Python3`|$193ms$|$3.28MB$|$487B$|[提交记录](/record/33381509)|[查看代码](/paste/20cing2u)|

$Updates:$

```
2020-05-05 12:11 创建题解
2020-05-05 15:59 增加Python3代码并公布运行结果及其链接
2020-05-05 16:04 提供无注释C++/Python3代码的洛谷剪贴板链接
```

---

## 作者：_0x46EDC (赞：2)

[获得更好的阅读体验](https://www.luogu.com.cn/blog/jasonying/luogu-p6529-coci2015-20161-karte) [题目传送门](https://www.luogu.com.cn/problem/P6529)

---

### 题目分析

数扑克牌，简单模拟。

### 代码

直接上代码，思路在注释中讲了

```
#include<bits/stdc++.h>
using namespace std;
char C;
int n,a[4][14];//二维数组，a[0,1,2,3][]分别存放P,K,H,T
map<char,int> m;//使用map可以避免判断，具体请看后面的代码
int main(){
    m['P']=0,m['K']=1,m['H']=2,m['T']=3;//赋值
    while(cin>>C){
        cin>>n;
        a[m[C]][n]++;//这张牌的数量加一
    }
    for(int i=0;i<4;i++){//四种花色循环
        for(int j=1;j<=13;j++){//十三张牌循环
            if(a[i][j]>=2){//如果有一张牌的数量不止一张
                cout<<"GRESKA"<<endl;//输出
                return 0;//结束程序
            }
            a[i][0]+=a[i][j];
            //统计该花色牌的数量，这里注意如果有多张牌那就直接结束程序了，所以 13-牌的数量 就是缺牌的数量
        }
    }
    for(int i=0;i<4;i++)cout<<13-a[i][0]<<" ";//输出
    return 0;
}
```

### 结语
简单模拟，这里也可以用struct或者其他数据结构，可以参考楼上/下大佬的做法。

---

## 作者：Lips (赞：2)

# $STL\space map+$模拟

我们先维护一个$\text{map}$，曰：$mp$，它来**射映**花色为$C$的卡牌还**缺**多少张。

再来维护一个$\text{map}$，曰：$vis$，它来射映类型为$S$的卡牌有没有出现过。

**初始化：** 将$mp$对于四种花色的值都初始为$13$，假设都缺$13$张牌。

读入字符串$s$之后，遍历$s$，对于第$i$个位置，若$s_i$为字母，则$mp_{s_i}-1$，并要判断区间$[i,i+2]$之间构成一张牌 $x$ 是否已经出现过，若无，则将$vis_x$标记为$1$，否则，输出$\text{GRESKA}$

关于怎么判断是否为字母，有一个好用的函数：$\operatorname{isalpha(s)}$，功能：若 $s$ 为字母，返回非$0$，否则，返回$0$。其中：小写字母返回$2$，大写字母返回$1$。

~~这么一道水题也没什么好讲的~~，直接上代码吧！

$Code:$

```cpp
#include<cstdio>
#include<string>
#include<iostream>
#include<map>
using namespace std;
string s;//读入的字符串 
map<char,int>mp;//记录对于花色是C的卡牌剩下的牌数 
char type[5]={' ','P','K','H','T'};//四种类型 
map<string,bool>vis;//记录类型x的扑克牌有没有出现过 
bool flag;
int len;
int main()
{
	for(register int i=1;i<=4;i++) mp[type[i]]=13;//初始化 
	cin>>s;len=s.size();//输入 
	for(register int i=0;i<len;i++)
	{
		if(isalpha(s[i])!=0)//如果是s[i]字母 
		{
			mp[s[i]]--;//扑克牌数量-1 
			string now;
			now.clear();
			now=now+s[i]+s[i+1]+s[i+2];//制作一个扑克牌 
			if(vis[now]) flag=1;//如果已经有了，flag=1 
			else vis[now]=1;//否则标记为1 
		}
	}
	if(flag==1) printf("GRESKA\n");//输出 
	else for(register int i=1;i<=4;i++) printf("%d ",mp[type[i]]);
	return 0;
}
```
看蒟蒻我写得这么认真，点个赞再走行不？


---

## 作者：novax (赞：0)

这是一道少见的满分是50分的题呢

蒟蒻不会STL，因此发一个纯模拟的题解

#### 思路

开四个桶，分别表示对应花色点数为 $i$ 的扑克牌出现的次数。由于每种花色的扑克牌只有13种不同的点数，所以作为桶的数组只要开到14位就够了。读入的数据，可以将整个字符串读入，然后离线处理每种扑克牌出现的次数。用一个循环，三个字符三个字符的处理每张牌的信息。设这三个字符分别为 $c_1$ $c_2$ $c_3$，则这张扑克牌的花色是 $c_1$，这张牌的点数是 $(c_2-48) * 10 + (c_3-48)$ ，然后将对应颜色对应牌的数量+1。然后再用一个循环统计是否有牌出现重复，如果有牌出现重复则输出```GRESKA```，如果没有牌有重复则统计每种花色没有出现的牌的个数，然后一行输出四种花色的缺少的个数就可以了。

#### 代码如下

```cpp
#include <cstdio>
#include <cstring>
int P[15],K[15],H[15],T[15];//分别记录四种花色的牌是否出现过 
char c[1010];//读入的字符串 
int main()
{
	scanf("%s",c);
	int l;
	l=strlen(c);
	l/=3; //计算读入数据总共有几张牌 
	int i,j;
	int a;
	for(i=0;i<l;i++)
	{
		a=10*(c[i*3+1]-48)+(c[i*3+2]-48);//计算这张牌的点数
		if(c[3*i]=='P')
			P[a]++;
		if(c[3*i]=='K')
			K[a]++;
		if(c[3*i]=='H')
			H[a]++;
		if(c[3*i]=='T')
			T[a]++;
	}
	for(i=1;i<=13;i++)//如果有牌超过一张，输出"GRESKA" 
	{
		if(P[i]>1||K[i]>1||H[i]>1||T[i]>1)
		{
			printf("GRESKA\n");
			return 0;
		}
	}
	int p,k,h,t;
	p=0;k=0;h=0;t=0;
	for(i=1;i<=13;i++)
	{
		if(P[i]==0)
			p++;
		if(K[i]==0)
			k++;
		if(H[i]==0)
			h++;
		if(T[i]==0)
			t++;
	}
	printf("%d %d %d %d\n",p,k,h,t);
}
```


---


# [COCI 2015/2016 #1]  AKCIJA

## 题目描述

书店搞活动了！

现在，您可以一次性购买 $3$ 本书，而三本书中，您只需要付较贵的两本书的钱。

注意，这种优惠在一次性购买 $1$ 或 $2$ 本书时，不存在。

现在，您希望花最少的钱买下 $n$ 本书。

请求出买下 $n$ 本书需花的最少钱数。

## 说明/提示

#### 【样例解释】
#### 样例 1 解释
一起买价格为 $3,2,2$ 的三本书，剩下的一本书单独买即可。
#### 样例 2 解释
一起买价格为 $6,4,5$ 的三本书，而后一起买价格为 $5,5,5$ 的三本书。
#### 【数据范围及限制】
- 对于 $50\%$ 的数据，保证 $n\le 2\times 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^5$，$1\le c_i\le 10^5$。

#### 【说明】
**本题满分 $80$ 分。**

本题译自 [Croatian Open Competition in Informatics 2015/2016](https://hsin.hr/coci/archive/2015_2016) [Contest #1](https://hsin.hr/coci/archive/2015_2016/contest1_tasks.pdf) T2 AKCIJA。

## 样例 #1

### 输入

```
4
3
2
3
2 
```

### 输出

```
8```

## 样例 #2

### 输入

```
6
6
4
5
5
5
5
```

### 输出

```
21```

# 题解

## 作者：Phoenix_chaser (赞：8)

# 排序+去掉每三个中最小的
## 本题核心：让优惠最大化。
#### 既然要价格最小，那就要让优惠最大。
本题的优惠是让三个中 _**最小的那个不付钱**_ ，所以我们要去让每组三个数中的  _**最小的尽量大**_ ，这样的优惠的价格是最多的。

###  举个例子
9

8
9
7
5
6
4
8
5
4

首先要进行排序，这里的排序要 _**降序排列**_ ，让大的值在前面。从前往后数，每三个为一组，这样的从前往后每一次优惠都是当前可以进行优惠的 _**最大值**_。

排序后：
9
8
8
7
6
5
5
4
4

第一次优惠后：

9
8
0
7
6
5
5
4
4

第二次优惠后:

9
8
0
7
6
0
5
4
4

第三次优惠后：

9
8
0
7
6
0
5
4
0

优惠完毕，将所有加起来。
#### 还有一点：
这种优惠在一次性购买1或2本书时，不存在。但这里不需要特殊处理，因为我是**从第三个数开始处理**的，只有1或2本书时**并没有进行处理**。详细看代码。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[100003],ans=0;
int cmp(int a,int b){
	return a>b;
	//将sort变成降序排列 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	sort(a+1,a+n+1,cmp);
	//排序 
	for(int i=3;i<=n;i=i+3) a[i]=0;
	//核心：降序排列，所以每组第三个为每组最小 
	for(int i=1;i<=n;i++)  ans=ans+a[i];
	//将优惠过的值加起来，被优惠过的都变成了0 
	cout<<ans;
	return 0;
}

```
### 感谢观看
# The End

---

## 作者：Cripple_Abyss (赞：7)

## [题目传送门](https://www.luogu.com.cn/problem/P6530)

## STEP 1 题目大意：

- 每买三本书只需付较贵的那两本书的钱，即最便宜的那本不付。

- 求最少要花的钱数。

## STEP 2 思考过程：

- 我们可以贪心地想：每次不付的那本书的钱越贵越好。

- 将最贵的三本书一起买，而不付的那本书的价格不就是最贵的了吗？

## STEP 3 题目解法：

- 我们将价格按从大到小的顺序排序。

- 每三个数为一组，将前两个数累加到 ans 里去，第三个跳过。

- 输出 ans 。

## STEP 4 Code： 
```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
using namespace std;

int n, a[1000005];
long long ans;

bool cmp(int a, int b)
{
    return a > b;
}

int main()
{
    scanf("%d", &n);
    
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]); // 输入
        
    sort(a + 1, a + n + 1, cmp); // 排序
    
    for (int i = 1; i <= n; i++)
    {
        int t = 1; 
        
        while (t <= 2 && i <= n) // 买前两本，第三本是送的，注意 i 必须小于等于 n
            ans += a[i], i++, t++;
    }
    
    printf("%lld", ans); // 输出
    
    return 0;
}

```

都看到这里了，点个赞再走呗 QwQ

---

## 作者：Blunt_Feeling (赞：3)

## P6530 AKCIJA 题解
这是一道简单的贪心。

为了使花的钱最少，可以先把每本书的价格降序排列，然后每三本书为一组进行购买，最后落单的书就单独购买。

为什么这样购买所花的钱是最少的？因为我们在分组购买时，就已经在尽可能地把贵的书变成免费的。

一般人都会用 `sort` A掉这题，这里我用了堆排序作为排序方法。大家也可以温故一下`STL`优先队列的使用。

### 代码：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
priority_queue<int> que; //大根堆
int n,x,ans=0;
int main()
{
	cin>>n;
	For(i,1,n)
	{
		cin>>x;
		que.push(x);
	}
	For(i,1,n/3) //要分组购买n/3次
	{
		ans+=que.top(),que.pop(); //取出堆顶元素
		ans+=que.top(),que.pop();
		que.pop();
	}
	while(!que.empty()) //处理落单的书
	{
		ans+=que.top();
		que.pop();
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Sarcasm (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P6530)

#### 样例$1$中的情况还可以是：

 - 一起买价格$3,3,2$的三本书，

 - 再买价格为$2$的一本书，

 - 总价为$3+3+2=8$ yuan,

 - 正确

#### 样例$2$中的情况还可以是：

- 一起买价格为$6,5,5$的三本书，

 - 再买价格为$5,5,4$的三本书，

 - 总价为$6+5+5+5=21$ yuan,

 - 正确

------------


### c++的代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010];
bool cmp(int x,int y){
	return x>y;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);//读入 
	sort(a+1,a+1+n,cmp);//按从小到大排序 
	long long sum=0;//计数器 
	for(int i=1;i<=n;i+=3){
		if(i+2>n) break;//当i越界时，退出循环 
		sum+=a[i]+a[i+1];//计数 
	}
	if(n%3!=0){//处理还有余的情况 
		int x=n%3;
		for(int i=0;i<x;i++)  sum+=a[n-i];
	}
	printf("%d",sum);//输出 
	return 0;
}
```


---

## 作者：hensier (赞：1)

假如现在有$6$本书需要购买，价格分别为$3,6,2,1,9,10$：

![](https://cdn.luogu.com.cn/upload/image_hosting/xapo66wr.png)

当然，我们肯定是要尽可能地将书分成每组三本的形式，这样才能节省更多钱。无论怎么分，我们会发现，最大价钱的书和次大价钱的书是必须要按照原价购买的。因为，这两本书是最贵的两本，所以根据题意，如果要三本一组地购买，那么这两本是一定要付费的。

而第三贵的书就不一定了。只要跟第一、第二贵的书在一起买，那么就可以省去这一本书的价钱。所以将第一、第二贵的书放在同一组是最优的，而第三本是可以免费的，所以根据贪心的思想，我们不妨选择剩下的书中最贵的，即选择第三贵的书。

那么，剩下来就只有$n-3$本书了（假定这里$n>3$）。我们将这些书按照上述的方法进行逐个分组，直到剩下$n\%3$本书。这时$n\%3$本书就无法继续分组，于是我们按照原价购买即可。

这样分析之后，我们不妨把这个序列从大到小排列，然后将其三个三个地分组，然后将每组的第一、第二本书的价钱相加即可。最后对剩下的$n\%3$本的价钱累加。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wn0rj2in.png)

我们最终需要支付的费用即为$10+9+3+2=24$（单位）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,price[100001],ans;
int read()//快读
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
bool compare(int a,int b)//比较函数，用来从大到小排序
{
    return a>b;
}
int main()
{
    n=read();//调用快读输入
    for(int i=1;i<=n;i++)price[i]=read();
    sort(price+1,price+n+1,compare);//数组从大到小排序
    for(int i=1;i<=n/3*3;i++)if(i%3)ans+=price[i];//分组，对大的两个进行累加
    for(int i=n/3*3+1;i<=n;i++)ans+=price[i];//对剩余的进行累加计算
    printf("%d",ans);
    return 0;
}
```

---

## 作者：sid_shi1 (赞：0)

题目：[P6530 [COCI2015-2016#1] AKCIJA](https://www.luogu.com.cn/problem/P6530)

思路：

本题要求的是最后的价钱最少，也就是要优惠的钱越大越好。题目中说每 $3$ 本书最便宜的 $1$ 本不用付，我们当然希望这些不用付的书价钱在所有书中是较贵的。所以，我们将原数组降序排序，然后每 $3$ 本 $1$ 组的第 $3$ 本不用付，剩余的书按原价付。我们可以先求出假设不打折要付的总价钱（也就是所有书价钱的和），然后再减掉这些优惠的书的价钱，这样最后付的总价钱就是最少的了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001]={0},ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],ans+=a[i];//先计算所有书价钱的和
	sort(a+1,a+n+1,greater<int>());//降序排序
	for(int i=3;i<=n;i+=3) ans-=a[i];//减去优惠的书的价钱，没三本的最后一本
	cout<<ans;
	return 0;
}
```


---

## 作者：Yukinoshita_Yukino (赞：0)

首先，我们考虑到，买三本一组的书肯定比分开买划算

那最终的问题就是：如何分组？

根据贪心的思想，我们要挑价格贵的让其免费——但是显然，价格贵的想要免费需要两个比他价格更大的书。


我们从小问题开始思考：要是只能搞一次活动（即不能第二次进行分组免费）的话，显然把前三大的放一组，使第三大的免费

如果能让两次分组后免费呢？我们可以让价格排名为$1,2,3$的一组，$4,5,6$的一组，使排名为$3,6$的免费。

规律就出来了：价格相邻三个书从大到小顺序分组。

代码不难

```cpp
#include <bits/stdc++.h>
using namespace std;
int cmp(int a,int b){return a>b;}//比较函数，使价格贵的排在前面
int a[1000001],sum=0;
int main()
{
	int n;
    cin>>n;
    for(int i=1;i<=n;i++) 
    { 
    	cin>>a[i];
    	sum+=a[i];
    } 
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i+=3)
    {
    	sum-=a[i+2];
    }
    cout<<sum;
    return 0;
}

```

---

## 作者：CCCloud (赞：0)

## 简单的贪心+排序  
**题目**：[自己看…](https://www.luogu.com.cn/problem/P6530)  
**主要思路**：  
1、先把n个数字**从大到小**排序；  
2、**三个为一组**，并且选**前两个数**的价值加入答案中，剩下的就**全部加进答案**；**（贪心）**  


------------
为什么这样做**是对的呢**？  
~~因为这是对的~~  
我们要尽量**把贵的东西给弄成免费**，然后就能**使花的总钱数最低**——这很显然； 

------------
排序我是用 $sort$ ，因为懒，所以使用 $fuctional$ 里面的 $greater$；  
### 主要代码实现如下：  
```cpp
    sort(a+1, a+1+n, greater<int>());//从大到小排序
    
    for(int i=1; i<=n; i++)//数据范围不大，所以一个一个循环没有问题
    {
        if(i%3==1 || i%3==2) ans+=a[i];
        //每个组的第一、二个数加入答案中
    }    
```
这样这道题就可以**通过**啦QAQ！

---

## 作者：bobbyyang (赞：0)

我们首先把三本书看为一组。

然后使价格高的书与价格低的书之间价格相差尽量少，如果用价格很高的书去免费价格很低的书，就得不偿失了。


#### 所以我们先要对书的价格进行从大到小排序，这样免费的钱才最多。


举个例子：

有六本书，价格为$1$、$6$、$5$、$1$、$5$、$3$，

#### 在没排序前:

$1$，$6$，$5$元的书一组;$1$，$5$，$3$元的书一组，

第一组要买$6$元和$5$元的书；第二组要买$5$元和$3$元的书，

答案是$19$元。

#### 在排序后：

$6$，$5$，$5$元的书一组；$3$，$1$，$1$元的书一组，

第一组要买$6$元和$5$元的书；第二组要买$3$元和$1$元的书，

答案为$15$元。

由此可见，只有排序才能得到最优解。

最后把$ans$加上这组最贵的两本书的价格之和就完成了（也就是没有被免费的书，不满一组会直接相加）。

附上代码：

------------


```
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e5+10;
int a[maxn],n,ans;
int main()
{
    cin>>n;
    for(int i=0;i<n;++i) 
    	cin>>a[i];
    sort(a,a+n,greater<int>());    //从大到小排序（STL大法好！）
    for(int i=0;i<n;i+=3)         //一次一组书
    	ans+=a[i]+a[i+1];        //答案加上这组最贵的两本书
    cout<<ans;
    return 0;
}
```


------------
~~这题蛮水的~~



---


# 远大目标

## 题目背景

众所周知，一个 OIer 的最远大的目标，就是要 AK IOI。

![](https://cdn.luogu.com.cn/upload/image_hosting/81f0x6hi.png)

（图片来自[《深入浅出 程序设计竞赛 基础册》](https://class.luogu.com.cn/course/lgbook1)）


做为一名 OIer，小 Z 也想 AK IOI。但他还是太菜了，连说一句 `I AK IOI` 都会遭到大神的鄙视。

所以，小 Z 只好说 `|A|<|O|` 来勉励自己。

但是，Youyou 大佬看到了，很不屑，说：就你这水平还想 AK IOI？算了，你说了 `|A|<|O|`，就给你一道题目做做吧。

可怜的小 Z 实在是太菜了，连这题都不会，所以只好求助于你——未来的 IOI AKer。 

## 题目描述

给你 $O$，求出满足 $|A|<O$ 且 $A$ 为整数的 $A$ 的个数。 

由于小 Z 太菜了，于是连 `|A|<|O|` 都不敢说了，只好来研究这 `|A|<O` 的问题。

## 说明/提示

**样例 1 解释**

$A$ 的取值可以是 $-1, 0$ 和 $1$。

**数据规模和约定**

* Subtask 1（30 分）：$0 \le |O| \le 2^{10}-1$；
* Subtask 2（60 分）：$0 \le |O| \le 2^{31}-1$；
* Subtask 3（10 分）：$0 \le |O| \le 2^{63}-1$。

$|O|$ 表示 $O$ 的绝对值。

**提示**

如果您不了解绝对值是什么，可以理解为：

$$|x| = \begin{cases} x & (x > 0) \\ 0 & (x = 0) \\ -x & (x < 0)\end{cases}$$

原idea: [Meatherm](https://www.luogu.com.cn/user/108949)

## 样例 #1

### 输入

```
3```

### 输出

```
5```

## 样例 #2

### 输入

```
1145141919810```

### 输出

```
2290283839619```

## 样例 #3

### 输入

```
12345```

### 输出

```
24689```

# 题解

## 作者：David_H_ (赞：31)

这题很简单，尤其是数据范围给我们的提示。

首先，我们知道 `int` 显然存不了 $2^{63}-1$ 量级的数据，所以我们考虑 `long long`，而 `long long` 在乘以 $2$ 的时候会爆掉，所以我们要用 `unsigned long long`。

但是，由于 `unsigned long long` 存不了负数，所以我们先用 `long long` 读入，转存 `unsigned long long` 最后输出，这样就可以了。

同时，如果是非正数的情况，直接输出 $0$ 就可以了。

代码如下：

```cpp
#include <iostream>
using namespace std;
int main()
{
    long long a;
    cin >> a;
    if(a <= 0) { cout << 0; return 0; }
    unsigned long long b = a;
    cout << 2 * b - 1;
    return 0;
}
```

---

## 作者：fzj2007 (赞：28)

先皮一下： `|A|<|O|` (bushi......

好了，废话不多说，开始正题~

[此处阅读效果更佳](https://www.luogu.com.cn/blog/fzj2007/ti-xie-p6581-yuan-tai-mu-biao-post)。

## 第一步 读题

>给你 $O$，求出满足 $|A|\lt O$ 且 $A$ 为整数的 $A$ 的个数。

最重要的部分就是求 $|A| \lt O$ 的个数（$A$ 与 $O$ 为整数）。

## 第二步 思路

由于这道题是让我们求一个数的绝对值小于这个数的数的个数（有点晕对不对......），涉及到绝对值，所以我们分类讨论。

- 当 $O \lt 0$ 时，由于没有任何一个数的绝对值小于 $0$（绝对值最小的数是 $0$，绝对值与原数相同，为 $0$），所以无解，直接输出0。

- 当 $O = 0$ 时，和上面一样，还是 $0$。可以自行看下。

- 当 $O\gt0$ 时，这个情况要好好考虑一下了。当且仅当 $a=b$ 或 $a=-b$ 的时候， $|a|=b$。在本题内我们可以取的 $b$ 的值为 $0 \sim \left(O-1\right)$，即答案为 $2\times O$。但是，真的对吗？我们想一想，当 $b=0$ 时，$a$ 的两种情况相同（均为 $0$），所以我们还要减掉一种，即答案为 $\left(2 \times O - 1\right)$。

设 $ans$ 为我们的答案，那么我们可以如下表示：

$ans=\begin{cases}0&x\le0\\2\times O-1&x\gt0\end{cases}$ 

## 第三步 注意事项

由于本题数据较为毒瘤，所以我来说一下。

>对于所有的数据，满足 $0 \leq |O| \leq 2^{63}-1$。

这里的范围是指 $|O|$ 而不是 $O$，**所以 $O$ 是有可能为负数的！**（我被坑了好几次...）

其他的数据没关系，但是我们上面的答案涉及到 $2 \times O$，所以数据**有溢出 `long long` 的可能！**，而且我们不能直接开 `unsigned long long`，因为 $O$ 可能是负数。

那怎么办呢？难不成要用高精？这么简单一个题还要上高精度？

当然不是了，我们可以在做**乘法运算的时候强行转化为 `unsigned long long`**。详见代码。

## 第四步 代码

终于到了你们最喜欢的代码时间了......（请自动跳过长长的快读）

```
#include<bits/stdc++.h>//万能头文件开始
using namespace std; 
using std::cin;
using std::cout;
using std::endl;
namespace IN{//快速读入
    const int MAX_INPUT = 1000000;
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,MAX_INPUT),p1==p2)?EOF:*p1++)
    char buf[MAX_INPUT],*p1,*p2;
    template<typename T>inline bool read(T &x) {
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
        	ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {
       return read(a)&&read(args...);
    }
    #undef getc
}

namespace OUT{//快速输出
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
    	for(register int i=0;i<s.length();i++) putc(s[i]);
	}
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);put(ch,args...);
    }
}
using IN::read;//不然每次还要加上 xxx::，很烦的
using OUT::put;
using OUT::putc;
using OUT::putstr;
long long n;//先用long long，用来读入
int main(int argc, char const *argv[]){
    std::ios::sync_with_stdio(false);//关闭一堆同步流
    cin.tie(NULL);
    cout.tie(NULL);
    read(n);//读入
    if(n<=0) putc('0');//小于等于0的情况
    else put((unsigned long long)n*(unsigned long long)2-1);//记得强转啊，*2最好也强转一次，保险
    return 0;//bye!
}
```

### 第五步 其他

- 如果有帮助，请点赞，感谢。

- 撰文不易，`dalao`勿喷。

- 如果有`bug`，请及时指出并告知（私信，留言均可），我将非常感谢。

---

## 作者：ezyannn9 (赞：8)

从数学上很好理解 就是 O*2-1

就是一个坑 数据范围为O的绝对值，也就是O是可以小于0的 那么开longlong会炸，考虑负数不好用unsigned long long 怎么办呢

高精度是不可能高精度这辈子都是不会写高精度的 python一波带走

```python
a=int (input())
if a>0:
    print(a*2-1)
elif a<=0:
    print(0)
```

如果不高精度也能做吧，lld 转llu吧 没仔细想

---

## 作者：monstersqwq (赞：5)

我想大多数人都用的是高精或者 ull +特判非正数（反正我赛场上写的是第二种），这里给出一种神奇的做法。（当然如果你用 __int128 我也没意见）

首先看题面就知道这是个数论题，先推一下结果：

$O>0$ 时：求解 $\left|A\right|<O$ 得 $-O<A<O$，所以 $A$ 的整数解为：$-O+1,-O+2,\cdot\cdot\cdot,O-2,O-1$，正数有 $O-1$ 个，负数有 $O-1$ 个，还有一个 $0$，共 $2O-1$ 个。

$O\le 0$ 时：无解，答案为 $0$。

感觉不难，但是看到数据范围 $\left|O\right|\le2^{63}-1$，$2O-1$ 会爆 longlong，但是又有负数，用 ull 并不好写（也能写），于是想到了一种方法：

先用 longlong 输入，特判掉非正数，如果是正数再强制转换成 ull 类型，输出 $2O-1$ 即可。

代码：
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
using namespace std;

int main()
{
    long long a;
    cin>>a;
    if(a<=0) cout<<"0"<<endl;
    else
    {
        unsigned long long s=(unsigned long long)a;
        cout<<s*2-1<<endl;
    }
    return 0;
}
```


---

## 作者：Licykoc (赞：3)

发现没人用`Python`，赶紧来水一发

## 题意：

对于每一个$n(1 \le n \le 2^{63}-1)$,输出$n*2-1$

如果$n \le 0$时，输出$0$

## 分析：

最大的$n$已经到了$2^{63}-1$,普通的`long long`会爆，用`unsigned long long`即可

但本蒟蒻~~过于懒蛋~~，使用"高精度杀手`Python`"来切此题:

## 代码：

```python
n = int(input())
if (n<=0) :
    print(0)
else :
    print(n * 2 - 1)

```

~~短小精悍~~

---

## 作者：yoy68 (赞：3)

根据绝对值可得:

|a|和|-a|,绝对值一样,再包含一个0,如果a=0,则a=-a,因此重复

所以是n*2-1

则此题代码为:
```
#include<bits/stdc++.h>
using namespace std;
long long n;
int main() {
	cin>>n;
	if (n>0)
		cout<<n*1ull*2-1;
	else 
        cout<<0;
	return 0;
}
```


---

## 作者：Dry_ice (赞：2)

本~~蒟蒻~~第二篇题解，望管理给过！

~~这题思路总不用说了吧？~~

### 关于本题，只需要注意 $2$ 点：
1. $O\leq0$ 的情况：答案都为 $0$；
1. 本题答案需要开 $unsigned$ $long$ $long$ （记住是 $unsigned$ ！非常重要！）

## CODE
```cpp
#include <stdio.h>
int main(void) {
	long long o;
	scanf("%lld", &o);
	if (o > 0) printf("%llu\n", (unsigned long long)(o - 1) * 2ull + 1);
	else puts("0");
	return 0;
}
```

---

## 作者：No_Au_No_Name (赞：2)

### 模拟解法

几位大佬写的都很清楚了，直接判断情况：

+ $O \leq 0$，直接输出 $0$ 即可。

+ $O > 0$，找规律，输出 $O \times 2 - 1$ 即可。

看其他几位大佬用的都是 `unsigned long long`，蒟蒻选择了 `__int128`，今天也讲一讲二者使用区别。

`unsigned long long` 和 `__int128` 都是非常大的，二者 $2^{63}-1$ 肯定可以使用。

注意，`unsigned long long` 的取值范围不包括负数，所以本题中，刚开始需要使用 `long long` 判负，然后输出时强制类型转换 `unsigned long long`。

而 `__int128` 则不需要转换，直接判负即可，但使用 `cin,cout/scanf,printf` 的同学注意了，`__int128` 并不支持这种输入输出方式，所以自备快读、快输模板。

**注意：包括 NOI 系列赛事在内的所有在 32 位机器上评测的比赛都不能使用 `__int128`！**

代码里有注释，大家可以参考阅读。

### 标程

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
__int128 o;//定义 
__int128 read()//快读 
{
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0' or ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' and ch<='9')
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
void write(__int128 k)//快输 
{
    if(k>=0 and k<=9)
	{
		cout<<int(k%10);
		return;
	}
    write(k/10);
	cout<<int(k%10);
    return;
}
int main()
{
	o=read();//输入 
	if(o<=0)//判断负数、0 
	{
		cout<<0;
		return 0;
	}
	write(o*2-1);//正数输出 
	return 0;
}
```


---

## 作者：JRzyh (赞：2)

I will AK IOI!

这是蒟蒻第一次参加洛谷月赛，就A了一道题（wtcl),于是赶紧写篇题解。

------------
若要 $|A|<O$ 有三种可能：

1. $A>0$ 且 $A<O$ 共 $O-1$ 种情况
1. $A<0$ 且 $|A|<O$ 共 $O-1$ 种情况
1. $A=0$ 共 $1$ 种情况

所以答案为 $(O-1)\times 2+1$

如果还不懂可以来[这](https://www.desmos.com/calculator/tm9qhhhsal)看看

最后是要注意特判 $0\le O$ 。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a;
int main()
{
	cin>>a;
	if(a<=0) putchar('0');
	else cout<<(a-1ull)*2ull+1ull;//必须强转ull 
	return 0;
 } 
```
求赞OvO

---

## 作者：PragmaGCC (赞：2)

这道题不难

题目要你求$|A|<O$的整数解个数

解这个含参一元一次不等式可得：
$$\begin{cases}-O<A<O&O>0\\\texttt{无解}&O\leqslant0\end{cases}$$

而满足$-O<A<O$且$O>0$的整数$A$的个数有多少个呢？

答：有$2\cdot O-1$个（稍微推一下就出来了）

那么，问题就迎刃而解了/qq

c++代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long o;
int main(){
    ios::sync_with_stdio(false);//加快cin和cout
    cin>>o;
    if(o > 0){
    	unsigned long long ans = o;//转ull
        cout<<ans * 2 - 1<<endl;
    }
    else
        cout<<0<<endl;//无解，也就是整数解个数为0
    return 0;
}
```
附自带高精的py3代码：
```python
o = int(input())
if o>0:
    print(2*o-1)
else:
    print(0)
```


---


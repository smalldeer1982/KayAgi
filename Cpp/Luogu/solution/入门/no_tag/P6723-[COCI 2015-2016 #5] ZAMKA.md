# [COCI 2015/2016 #5] ZAMKA

## 题目描述

给定三个整数 $L,D,X$，你需要找到两个整数 $N,M$，使得：

- $N$ 为满足条件的最小整数，$L\le N\le D$ 且 $N$ 的各位数字之和为 $X$；
- $M$ 为满足条件的最大整数，$L\le M\le D$ 且 $M$ 的各位数字之和为 $X$。

保证 $N,M$ 一定存在。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le L\le D\le 10^4$，$1\le X\le 36$。

#### 说明

**题目译自 [COCI2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #5](https://hsin.hr/coci/archive/2015_2016/contest5_tasks.pdf) *T1 ZAMKA***。

## 样例 #1

### 输入

```
1
100
4```

### 输出

```
4
40```

## 样例 #2

### 输入

```
100
500
12```

### 输出

```
129
480```

## 样例 #3

### 输入

```
1
10000
1```

### 输出

```
1
10000```

# 题解

## 作者：Eason_AC2 (赞：13)

## Content
给定三个数 $L,D,X$ ，求在 $[L,D]$ 内各数位的和恰好为 $X$ 的最小数 $N$ 和最大数 $M$ （保证 $N,M$ 一定存在）。

**数据范围：$1\leqslant L \leqslant D \leqslant 10^4,1 \leqslant x \leqslant 36$。**

## Solution
很简单的一道模拟题。

先预处理出 $1$ 到 $10^4$ 的各数位之和，然后先从左往右遍历，第一个找到的数即为最小的满足要求的数。在从右往左遍历，第一个找到的数即为最大的满足要求的数（证明无需多讲）。

主要是先预处理这里降低一下复杂度，其他的都没什么好讲的。

## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;

int sum[10007];

int main() {
	for(int i = 1; i <= 10000; ++i) {
		int p = i;
		while(p) {
			sum[i] += p % 10;
			p /= 10;
		}
	}
	int l, d, x;
	scanf("%d%d%d", &l, &d, &x);
	for(int i = l; i <= d; ++i) {
		if(sum[i] == x) {
			printf("%d\n", i);
			break;
		}
	}
	for(int i = d; i >= l; --i) {
		if(sum[i] == x) {
			printf("%d\n", i);
			break;
		}
	}
	return 0;
}
```

---

## 作者：Contemptuous (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6723)

此题主要考计算一个数各个数位上数字的和。

我们想一想，怎样分解一个属各个数位上的数字呢？

假设一个数$a$的值为$356$，$\dfrac{365}{10}$是不是为$36$，那么它的个位是不是可以用$365\bmod 10$来求出，然后再把$365$除以$10$，再按照上述方法进行操作，直到$a=0$。

知道方法之后就好做了。

以下是本蒟蒻的垃圾代码：

```cpp
#include <iostream>

using namespace std;

int l, d, x;

bool s(int a)
{
	int sum = 0;
	
	while(a != 0)
	{
		sum += a%10;
		a /= 10;
	}
	return sum == x;
}

int main() 
{
	
	cin >> l >> d >> x;
	
	for (int i = l; i <= d; ++i)
	{
		if (s(i))
		{
			cout << i << endl;
			break;
		}
	}
	
	for (int i = d; i >= l; --i)
	{
		if (s(i))
		{
			cout << i << endl;
			break;
		}
	}
	
    return 0;
}
```
希望管理员大大能通过！

---

## 作者：Aragron_II (赞：4)

### [P6723](https://www.luogu.com.cn/problem/P6723)题解


------------

这道题考查的就是拆数，然后在 $ L $ 与 $ R $ 之间寻找一个数的各个位的和等于 $ X $ .

关于拆数建议先做:[P1980](https://www.luogu.com.cn/problem/P1980)

$ 如何得到拆数的和 ： $

设一个数为 $ X $ 与一个计数器  $ sum $，在 $ X $ 不为 $ 0 $ 的情况下 $ sum $ 加上 $ X $ 除以 $ 10 $ 的余数，$ X $ 不断 $ ÷ 10 $ ，当最后 $ X $ 不为正时 $ sum $ 就是 $ X $ 的各个位数字之和。代码如下：

```
while(x) sum+=x%10,x/=10;
```

然后正向判断最小值，反向判断最大值，输出结果。

```
#include <bits/stdc++.h>
using namespace std;
//inline int max(int a,int b) return a>b;
//inline int min(int a,int b) return a<b;
int L,R,X;
int main() {
	cin>>L>>R>>X;
	for(int i=L;i<=R;i++) {
		int t=i,sum=0;
		while(t) sum+=t%10,t/=10;
		if(sum==X) {
			cout<<i<<endl;
			break;
		} 
	}
	for(int i=R;i>=L;i--) {
		int t=i,sum=0;
		while(t) sum+=t%10,t/=10;
		if(sum==X) {
			cout<<i<<endl;
			break;
		} 
	}
	return 0;
}
```


---

## 作者：CLCK (赞：3)

题目比较水，暴力可过，不需要太多铺垫知识，先来看下。


------------

### 前言
如何计算每个数各位数字之和呢？比如说：$5123$这个数，其对10取模即为最后一位数字的值（ $5123 % 10 = 3$ ）。然后第二位呢？那么此处循环处理，将其 /10 ，可得到$512$ （**此数为int，不会有小数，而且没有四舍五入**），以此类推，易得其和为：11。


------------

### 分析
先看数据范围， $10^4$ ，这样暴力相当于2层循环，可行。


------------

### 实现
本题用上述方法，将其整合一下，得到如下计算数位总和的函数：
```cpp
int sum(int s) {
	int cnt = 0;
	while (s) {
		cnt += s % 10;
		s /= 10;
	}
	return cnt;
}
```
将其放在主程序前，程序中，i从l循环到r，对于每个 $i$ 计算，若与 $x$ 相等，则更新 $min$ 和 $max$ 的值即可。

~~此处给出主函数，再写不出来……~~
```cpp
int main() {
    cin >> l >> d >> x;
    int mi = 0x3f3f3f3f; //新手特别易错，这里一定要注意，之后最小值不会小于0，所以初始化为无穷大（见后记）
    int ma = 0;
    for (int i = l; i <= d; i++) {
        int s = cnt(i);
        if (s == x) {
            mi = min(mi, i); //这里规范一点的话还是引入一下algorithm库，不过问题不大，iostream有时候会一起引入一些常用函数，考试注意即可。
            ma = max(ma, i);
        }
    }
    cout << mi << endl << ma << endl;
    return 0;
}
```


------------

### 后记
没什么太多好说的，讲一下 $C++$ 无穷大的设置吧。

对于整数类型 $int$ 来说，常见的有3种无穷大值。

一：（最靠谱）

$0x3f3f3f3f$

为什么说它最靠谱呢？这里的数转化为十进制（0x开头为16进制）之后，结果为 $10 ^ 9$ 多一点，但接下来讲的第二种数两个相加就会溢出了，有点风险。但这个数并不会，可以做到 $inf + inf$ 的情况。

二：

$0x7ffffff$

类似于第一种，区别上面讲到过了，知道即可，自己最好还是用第一种。

三：（直接上极限，但可能数不够大或不小心写错位数

```cpp
int inf = 1e9;
```
这里 $1e9$ 其实是浮点数，强转之后和 $10^9$ 数值上相等，_**千万别把位数写错！！！**_


#### 完结撒花～管理大大过一下吧～

---

## 作者：songhongyi (赞：3)

题意：对于给定区间$\left [ l,r \right ]$，我们要找到在这个区间内满足数字和等于给定的常数$x$的最小值和最大值。  
注意数据范围，$1 \le l \le r \le 10^4$，很小，所以可以直接暴力过。  
那么我们要解决如何求一个数的数字和，其实是一个很简单的问题，做法如下 :  
* 将结果累加器设为$0$
* 把当前数模10的结果加到累加器上
* 把当前数除10下取整

代码如下
```cpp
int get( int x )
{
    int ans = 0; //将结果累加器设为0 
    while ( x )
    {
        ans += x % 10; // 加上模10的结果
        x /= 10; //除10
    }
    return ans;
}
```

那么这个问题解决了，这道题的代码也就出来了

```cpp

// Problem : P6723 [COCI2015-2016#5] ZAMKA
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P6723
// Memory Limit : 64 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
using namespace std;
int get( int x )
{
    int ans = 0;
    while ( x )
    {
        ans += x % 10;
        x /= 10;
    }
    return ans;
}//前面的函数，取数字和
int main()
{
    int l, r, x;
    cin >> l >> r >> x;
    for ( int i = l; i <= r; i++ ) //先从小到大枚举
    {
        if ( get( i ) == x ) 
        {
            cout << i << endl;
            break; //最下的已经找到就可以跳出了
        }
    }
    for ( int i = r; i >= l; i-- ) // 从大到小枚举，和上面同理
    {
        if ( get( i ) == x )
        {
            cout << i << endl;
            break;
        }
    }
}
```

---

## 作者：JK_LOVER (赞：2)

## 题意
寻找最大数和最小数，满足以下条件。

- $L\le x\le R$ 并且 $x$ 十进制拆分之后，满足 $\sum_{i=0} val_i = X$ 。[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p6723)
## 分析
一般对数位进行分析的，基本全是数位 $dp$ 。这里的 $L,R$ 非常的小。转眼一想这道题是没有让求什么方案之类的。这就是入门水题。我还脑子不好用把 $dp$ 写出来了。复杂度和枚举一样都是 $O(n\log n)$ 。友情提醒：下面两份代码其实是一样的。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100100;
int len,L,R,X,cnt,Ans[N],a[N];
void Dfs(int now,int x,int st,int limit,int num){
	if(L <= x && num == X) {
		Ans[++cnt] = x;
	}
	if(now > len || num > X) return;
	int res = limit?a[len-now+1]:9;
	for(int i = 0;i <= res;i++)
	{
		if(st&&i==0) Dfs(now+1,0,1,limit&&i == res,0);
		else Dfs(now+1,i+x*10,0,limit&&i == res,num+i);
	}
}
void split(int x){
	len = 0;
	while(x) a[++len] = x%10,x /= 10;
}
int main()
{
	cin>>L>>R>>X;
	split(R);
	Dfs(1,0,1,1,0);
	sort(Ans+1,Ans+1+cnt);
	cout<<Ans[1]<<endl<<Ans[cnt]<<endl;
}
```

```cpp
#include<bits/stdc++.h>
using namespace std;
int L,R,X;
int main()
{
	cin>>L>>R>>X;
	int mx = 0,mi = 0x3f3f3f3f;
	for(int x = L;x <= R;++x)
	{
		int i = x,ans = 0;
		while(i) ans+=i%10,i/=10;
		if(ans == X) {
			mx = max(mx,x);mi = min(mi,x);
		}
	}
	cout<<mi<<endl<<mx<<endl;
	return 0;
}
```



---

## 作者：dd_ygswz233 (赞：1)

# 题解 P6723 【[COCI2015-2016#5] ZAMKA】

   这道题很适合来练习计算一个数字的根（即一个数各个位上的数字之和）。

### 题意：

本题要求找出区间 $[L,N]$ 范围之间的的两个数，其各个数位的和等于 $X$ ，且是符合要求的最大（最小）的整数。

#### 那么问题来了，如何求一个数的各个数位之和？

这时候可以通过一个```while```循环处理：

以数字 $567$ 为例：
```cpp
int tmp=567,ans=0;
while(tmp)
{
	ans+=(tmp%10);//从最后一位加起
	tmp/=10;//加上最后一位后，从源数字中去掉最后一位 
}
cout<<ans;//结果应为18
```
注：这需要你们理解C++中除号和取模运算的区别

### 解决思路：

开一个for循环，查找区间 $[L,N]$ 之间的符合要求的数字，判断数字是否符合要求的方法如上所示。

### $Code：$
cpp：
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,n,x;
int ans1=0x3f3f3f3f,ans2=~0x3f3f3f3f;
signed main() {
	cin>>l>>n>>x;
	for(signed register int i=n; i>=l; i--) {
		signed register int j=i;//由于求一个数字的数字根需要改变原数字，这里再开一个变量保存
		signed register tmp=0;
		while(j) {
			tmp+=(j%10);
			j/=10;
		}
		if(tmp==x)	ans1=min(ans1,i);
	}//寻找最小的符合要求的数字
	for(register int i=l; i<=n; i++) {
		signed register j=i;//上同
		signed register tmp=0;
		while(j) {
			tmp+=(j%10);
			j/=10;
		}
		if(tmp==x)	ans2=max(ans2,i);
	}//寻找最大的符合要求的数字
	cout<<ans1<<endl<<ans2;
	return 0;
}

```
#### 希望你们自己思考，不要轻易地复制题解！

---

## 作者：159号程序员 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6723)

拆分数字+模拟水题。

我们可以发现，一个数字，可以如下拆分：

$$\dfrac{10}{123456789} = 12345678$$
$$123456789\bmod10 = 9$$
$$\dfrac{100}{123456789} = 1234567$$
$$123456789\bmod100 = 89$$

我们可以统称为：“去尾”和“取尾”。

假如将一个多位数 $\div10 ^ x$，会去掉 $x$ 个尾数。

假如将一个多位数 $\bmod10^x$，会取后 $x$ 个数。

懂了这些，这道题就可以引刃而解了。

_AC Code_

```cpp
#include <bits/stdc++.h>
using namespace std;    
int cf(int i) //拆分数位并求数位和
{
    int sum = 0;
    while (i)
    {
        sum += i % 10; //先取最后一位并加上
        i /= 10; //再删除最后一位
    }
    return sum;
}
int main()
{
    int l, d, x;
    cin >> l >> d >> x;
    for(int i = l; i <= d; i++)
    {
        if(cf(i) == x) //假如为最小的符合条件数
        {
            printf("%d\n", i); //输出当前序号
            break; //退出循环
        }
    }
    for(int i = d; i >= l; i--)
    {
        if(cf(i) == x) //同上，只是变成了最大的符合条件数
        {
            printf("%d\n", i); //输出当前序号
            break; //退出循环
        }
    }
    return 0;
}
```

---

## 作者：syf2008 (赞：1)

很简单的一道模拟题,~~为什么发的人那么少呢~~（估计都没看到）

1到1e4范围不大，我们边遍历边求的各数位之和，先从左往右遍历，第一个找到的数即为最小的满足要求的数。再从右往左遍历，第一个找到的数即为最大的满足要求的数

其他的都没什么好讲的
```cpp
#include <bits/stdc++.h>
using namespace std;
int x,l,r,k,sum;
int main()
{
	cin>>l>>r>>x;
	for(int i=l;i<=r;i++)
	{
	sum=0;//记得清0
	k=i;//把i赋值给k,因为会更改
	while(k!=0)//拆数位，记录
	{
	sum+=k%10;
	k/=10;
	}
	if(x==sum)
	{cout<<i<<endl;break;}//break，防止输出更多东西
	}
	for(int i=r;i>=l;i--)//同上
	{
	sum=0;
	k=i;
	while(k!=0)
	{
	sum+=k%10;
	k/=10;
	}
	if(x==sum)
	{cout<<i<<endl;break;}
	}
}
```

---


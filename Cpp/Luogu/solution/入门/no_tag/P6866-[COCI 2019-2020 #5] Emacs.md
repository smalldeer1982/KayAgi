# [COCI 2019/2020 #5] Emacs

## 题目描述

给定一个 $n\times m$ 的只含有 `.` 和 `*` 的矩阵。

矩阵中 `*` 形成一些不重叠的长方形。它们不在边缘或顶点接触。

求长方形有多少个？

## 说明/提示

### 数据范围

- 对于 $10 pts$ 的数据，矩阵中每个长方形只含一个 `*`。
- 对于另外 $15 pts$ 的数据，保证 $n=1$。
- 对于所有的数据，$1\leq n,m\leq 100$。

### 说明

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T1 Emacs_** ，译者 [90693](/user/90693)。

## 样例 #1

### 输入

```
6 7
***....
***..**
.....**
.***.**
.***...
.***...
```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3
*.*
...
*.*
```

### 输出

```
4```

## 样例 #3

### 输入

```
1 10
.*.**.***.
```

### 输出

```
3```

# 题解

## 作者：_•́へ•́╬_ (赞：21)

### 题目描述

给定一个 $n\times m$ 的只含有 `.` 和 `*` 的矩阵。

矩阵中 `*` 形成一些长方形。

求长方形有多少个？

### 思路

不建议搜联通块。

可以找长方形上某一特殊点来确定长方形。

窝统计每个长方形左上角的点。

寻找方法：左边是 `.`（左边什么都没有也行）且上面是 `.`（上面什么都没有也行）。

理由：两个长方形是不接壤的。

### $code$

```cpp
#include<stdio.h>
int n,m,ans;char a[100][100];
main()
{
	scanf("%d%d",&n,&m);for(register int i=0;i<n;++i)scanf("%s",a[i]);
	for(register int i=0;i<n;++i)for(register int j=0;j<m;++j)
		if(a[i][j]=='*'&&(!i||a[i-1][j]=='.')&&(!j||a[i][j-1]=='.'))++ans;
	printf("%d",ans);
}
```



---

## 作者：yf最qhhh (赞：8)

**思路**：判断每个' * '的左边和上面是否都为' . '，如果是那说明这就是一个矩形，用来计数的
ans++ 就行了。

**AC 代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
char a[105][105];
int main(){
	int n,m,ans=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			if(a[i][j]=='*'&&(a[i-1][j]=='.'||i-1==0)&&(a[i][j-1]=='.'||j-1==0))ans++;//是否为' * '，左边和上面是否为' . '，注意，如果是边界也一样。
		}
	cout<<ans;
	return 0;
}
```


---

## 作者：做梦想Peach (赞：8)

先吐槽一下 AH 队长下面题目来源的 bug，他搞成 $2020-2021$ 年的了。$233333$

----

这题的话，第一眼看是一个 DFS，但是我一看难度，只是个红题，又到队长的代码只有 $274\text B$ ，所以这题肯定是个玄学的算法。

我们可以发现，如果一片区域是长方形，那么这个长方形中每个点的**上下左右**四个方向肯定都是 `*`，但当该点在长方形的边上时，它的**右上、右下、左上、左下**。

我们可以枚举每一个点，但是我们多算很多长方形，所以在中心的 `*` 就不算，在顶点上的我们才加一。


```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
char c;
bool map[110][110];
int n,m,i,j,ans,a,b;
int read () {
	int k=0,f=1;
	char c=getchar ();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar ();}
	while (c>='0'&&c<='9') {k=k*10+c-'0';c=getchar ();}
	return k*f;
}
int main () {
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	n=read ();
	m=read ();
	for (i=1;i<=n;i++) 
		for (j=1;j<=m;j++) {
			cin>>c;
			if (c=='*') map[i][j]=true;
			if (c=='.') map[i][j]=false;
		}
	for (i=1;i<=n;i++) 	
		for (j=1;j<=m;j++) 
			if (map[i][j]==true&&map[i-1][j]==false&&map[i][j-1]==false) 
				ans++;
	printf ("%d\n",ans);
	return 0;
}
```

这题就到这里啦，拜拜。

ヾ(≧▽≦*)o

---

## 作者：yc杨晨大家好 (赞：6)

要找长方形其实只用看顶点，如果一个点的上面和左边都是“.”，那么这个点就一定是某个长方形的左上顶点，同时我把输入矩阵的周围都打成“.”，可以避免边界问题

代码：

```
#include <bits/stdc++.h>
using namespace std;
int main() {
	int i,j,n,m,cnt=0;
	char a[105][105];
	cin>>n>>m;
	for(i=0;i<=n+1;i++){
		for(j=0;j<=m+1;j++){
			if(i==0||j==0||i==n+1||j==m+1){//围出边界
				a[i][j]='.';
			}
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
		    if(a[i-1][j]=='.'&&a[i][j-1]=='.'&&a[i][j]=='*'){//判断，必须上面和左边都是“.”，并且这个点是“*”
		    	cnt++;//统计
			}
		}
	}
	cout<<cnt;
    return 0;
}
```


---


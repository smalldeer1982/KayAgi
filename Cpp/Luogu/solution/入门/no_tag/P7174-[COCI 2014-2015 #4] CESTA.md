# [COCI 2014/2015 #4] CESTA

## 题目描述

Mirko 发现了一个正整数 $n$，由于 Mirko 喜欢数字 $30$，他想知道用 $n$ 的每位数字所组成的数中 $30$ 的最大倍数。

写一个计算这个数字的程序（如果不存在，则输出 `-1`）。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$n$ 的位数不超过 $10^5$。

#### 说明

**题目译自 [COCI2014-2015 CONTEST #4](https://hsin.hr/coci/archive/2014_2015/contest4_tasks.pdf) _T1 CESTA_。**

## 样例 #1

### 输入

```
30```

### 输出

```
30```

## 样例 #2

### 输入

```
102```

### 输出

```
210```

## 样例 #3

### 输入

```
2931```

### 输出

```
-1```

# 题解

## 作者：NASFsky (赞：24)

# **P7174 CESTA 题解**
首先读题，可以发现这道题主要可以分为两步：判断30倍数和找最大值。如果一个数要是30的倍数，那么这个数一定是3的倍数和10的倍数。如果一个数是3的倍数，那么它的各位数字和一定也是3的倍数（小学奥数内容）；如果一个数是10的倍数，那么这个数的末尾一定要有个0。延伸到这道题目中，就是一定要含有0。最后将每位数字从大到小输出即可。   
# **AC代码：**
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
string s;
int x,f[1001];   
int main()
{
	cin>>s;
	int len=s.size();
	for(int i=0;i<=len-1;i++)f[s[i]-'0']++;//统计每位数字出现的次数  
	for(int i=9;i>=1;i--)x+=f[i]*i;//算数字和 
	if(x%3||!f[0])cout<<-1;//假如不是30的倍数  
	else for(int i=9;i>=0;i--)for(int j=1;j<=f[i];j++)cout<<i;//否则从大到小输出 
    return 0;//结束awa 
} 
```
题解求过awa  

---

## 作者：feicheng (赞：15)

# P7174题解

这道题作为一道入门题，还是很简单的。

我们要判断一个数能不能被30整除，就等同于要判断这个数能不能被3和10同时整除。

作为接受过义务教育的我们，对于这两个操作已经了如指掌。

即只需要判断各位数字的加和是否为3的倍数以及数字中是否有0存在（如果没有0存在就一定不能被10整除）。

本来应该判断末尾数字是否为0，但是这个数是可以改变的，所以只要有0存在就可以。

如果没有可能被30整除，则输出-1，反之，则将字符串中的数按从大到小排序再输出即可（这样子能保证0在最后且一定是最大的）

但是有没有想过，**为什么各位数字相加是3的倍数的数就能被3整除呢？**

证明：
首先我们要知道，对于一个正整数$m$，有$10^m - 1$是9的倍数（这是很显然的）

设$a$是一个$n$位数，用$a_i$来表示第$i$位数的值

设$s = \sum_{i=1}^n a_i $,已知$s \%3 =0$

又有$a = \sum_{i=1}^n a_i \times 10^i$

令$x = a-s$,则有$x = \sum_{i=1}^na_i \times(10^i -1)$

则$x \%9=0$(由开头的引理推得）
又$s \% 3 = 0$

所以$a\%3=0$

也就得到了$a$是3的倍数（同理也可证明判断9的倍数的定理）


下面附上代码
```cpp
#include <string>
#include <iostream>
#define ll long long
#define IO ios::sync_with_stdio(false)
using namespace std;

int ans;
bool flag ;
bool cmp(char a,char b){//可以直接定义char型的比较函数
	return a > b;
}
int main(int argc,const char *argv[]){
	IO;
	string s ;
	cin >> s;
	for(int i = 0 ; i < s.size();i++){
		if(s[i] == '0') flag = 1;//判断是否有0
		ans += s[i] - 48;
	}
	if(ans % 3 != 0 or flag == 0){
		cout << -1 ;
	}
	else{
		sort(s.begin(),s.end(),cmp);
		cout << s ;
	}
	return 0 ;
}
```

望通过。

---

## 作者：SIXIANG32 (赞：4)

SX 大蒟蒻做题不看数据范围活该 RE。  
话说这题真没有人证明一下吗？虽然是常识但是为了方便理解小 SX 决定贴上自己口胡的证明。  
~~尽管可能还胡错了~~  
闲话少说，切入正题。

---
看到这题数字位数是 $10^5$ 的，显然用字符数组或者是字符串来来存，我为了压行用的是字符数组~  
题目中有两个约束，一个是**尽可能大**，一个是 $30$**的倍数**  
尽可能大很好做，贪心尽量将大的放前面，考虑 $30$ 的倍数。  
我们都知道 $30=3\times 10$，也就是说当一个数能够整除 $3$ 同时也能整除 $10$ 时，这个数也必然可以整除 $30$。  

能被 $3$ 整除的数又有什么特征呢？  
先排一个基础的结论：$x\mod 3=0$ 就是 $(\left\lfloor\ x\div 10\right\rfloor \mod 3+x\mod 10\mod 3)\mod 3=0$，证明：    

---
首先我们把 $x\mod 3$ 这玩意儿给拆一下，就会变成 $(\left\lfloor\ x\div 10\right\rfloor \times 10+x \mod 10)\mod 3 $  

反正多取余是好事（？），就多取余几次，就成了 $(\left\lfloor\ x\div 10\right\rfloor \times 10 \mod 3+x\mod 10\mod 3)\mod 3$

由于 $10\mod 3=1$，所以对于 $\left\lfloor\ x\div 10 \right\rfloor\times 10 \mod 3$ 这玩意儿其实可以变成 $\left\lfloor\ x\div 10 \right\rfloor \mod 3$，然后这个式子其实就成了：$(\left\lfloor\ x\div 10\right\rfloor \mod 3+x\mod 10\mod 3)\mod 3$  

证完~

---
回到上面的话题。  
那么我们推出来了 $(\left\lfloor\ x\div 10\right\rfloor \mod 3+x\mod 10\mod 3)\mod 3=0$ 这个式子有啥用呢？  
对于这样的式子，$\left\lfloor\ x\div 10\right\rfloor$ 这一部分就继续按照这个式子求解，直到 $x\mod 10=x$，即 $x<9$。  
那么显然，这个式子会变成 $x$ 的各个数位和 $\mod 3$ 是否等于 $0$。  
$3$ 的倍数特征这个常识在我这个蒟蒻的笔下写成了又长又臭的证明，求不要喷/kk  

---
$3$ 的倍数特征就是各位数字之和是 $3$ 的倍数，那么 $10$ 的倍数特征呢？  
如果你还学过小学数学，那就是这个数的尾数是 $0$。  
~~这东西要是还看不懂的话建议 AFO~~
这道题大体思路就出来了：  
1. 输入每个数位。
2. 边输入统计各个数位和，同时标记是否有 $0$ 出现。
3. 输入完判断是否各个数位和是 $3$ 的倍数且输入有 $0$ 出现。  
4. 当 3 成立，对数位排序，从大到小输出，否则输出 ```-1```。

上朴实无华的代码：  
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
char ch[233333];
int main()
{
    int sum=0,vis=0,tot=0;
    while(cin>>ch[++tot])//1
    {
        sum+=(ch[tot]-'0');//2
        if(ch[tot]=='0')vis=1;
    }
    if(sum%3!=0||!vis/*3*/)cout<<-1<<endl;//4
    else 
    {
        sort(ch+1,ch+tot+1);
        for(int p=tot;p>=1;p--)
            cout<<ch[p];
    }
}
```

---

## 作者：蓝__ (赞：3)

分析：

先判断能否组成被30整除的数，能被10和3分别整除的数，必定能被30整除。只需判断所有数字之和是否为3的倍数，以及是否有一个0存在。

实现：

这道题可以用桶排序做，建一个桶来统计每一个数字出现的次数，并进行判断，如果可以组成30的倍数，就按数字大小倒序输出，否则输出-1。

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100001];
int s,b[1001];  //统计 
int main(){
	cin>>a;
	for(int i=0;i<strlen(a);i++) b[a[i]-'0']++;  //累加到数组 
	for(int i=9;i>=1;i--) s+=b[i]*i;  //数字和 
	if(s%3!=0||b[0]==0) cout<<"-1";  //不能被30整除 
	else{
		for(int i=9;i>=0;i--){
			for(int j=1;j<=b[i];j++) cout<<i;  //倒序输出 
		}
	}
    return 0;
}

---

## 作者：Wu_while (赞：2)

~~根据小学数学教科书~~
**我们知道**

1. $30$的倍数必定是$10$的倍数，也是$3$的倍数；
2. $10$的倍数最后一位必定是$0$，$3$的倍数各位之和也是$3$的倍数。

然后再来看数据范围：

对于 $100$% 的数据，**$n$ 的位数不超过 $10^5$** 。

显然这题要用**字符串**了。

那么怎样使结果最大呢？排序。
排序之后各位之和不变，所以依然是$3$的倍数，而排序之后$0$一定在最后，所以依然是$10$的倍数。所以排序之后的数也是$30$的倍数。

### 附上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char c[100010];
int len,a;
bool flag;
bool cmp(char a,char b)//快排函数，从大到小排
{
	return a>b;
}
int main()
{
	cin>>c;
	len=strlen(c);
	for(int i=0;i<len;i++)
	{
		if(c[i]=='0')//判断是否有0
			flag=1;
		a+=c[i]-'0';//各位之和
	}
	if(flag&&a%3==0)//有0且是3的倍数
	{
		sort(c,c+len,cmp);//STL快排
		cout<<c<<endl;
	}
	else
		cout<<-1<<endl;
	return 0;
}
```
**大佬勿喷**

---

## 作者：John_yangliwu (赞：2)

题目要求我们用若干已知数字构造一个最大的 $30$ 的倍数。

那么我们需要解决的问题有 $2$ 个：

1. 如何判断一个数是否是 $30$ 的倍数？
2. 如何用已知数字构造最大的数？

---

- ### 首先说 1：

我们知道，$30=10\times3$ 且 $\gcd(10,3)=1$，那么如果一个数 $a$ 满足 $3\mid a$ 且 $10\mid a$，那么 $a$ 肯定也满足 $30\mid a$。

首先是 $3$ 的整除特征。~~根据小学4年级课本~~，如果一个数各个数位上的数字之和能被 $3$ 整除，那么这个数就能被 $3$ 整除。又因为题目中每个数字均要用到，所以数字和是固定的，因此我们首先判断数字和是否为 $3$ 的倍数，若不是，则无法构造出能被 $3$ 整除的数，直接输出 $-1$。

$10$ 的整除特征就更简单了。若一个数末位为 $0$，则这个数能被 $10$ 整除。所以我们再判断一下给定数中有无 $0$，若没有，则无法构造出能被 $10$ 整除的数，直接输出 $-1$。

---

- ### 然后是 2：

要满足构造的数最大，只需要将每个数位上的数字按降序排序一遍就好了。

你可能会问：这样做能保证满足 1 吗？

答案是肯定的。数字和必然不用考虑，那么就剩末位的 $0$ 了。因为我们是按降序排列，所以如果给定数中有 $0$，那么某一个 $0$ 必然会被排到最后，自然满足了能被 $10$ 整除。这也就是题目的巧妙之处。

---

- ### $Tips:$

给定数的位数不超过 $1e5$，需要用数组or字符串存储。

---

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
int a[MAXN];

bool cmp(int one, int two) {
	return one > two;
}

int main() {
	char c;
	int cnt=0, sum=0;
	bool flag=false;//flag表示给定数中有无0
	
	while(cin>>c) {
		a[++cnt] = c-'0';
		sum += a[cnt];
		if(!a[cnt]) flag=true;
	}	
	
	if(sum%3 || !flag) {//若数字和不能被3整除或者给定数中无0，则不存在合法的构造方案
		cout<<-1<<endl;
		return 0;
	}
	
	sort(a+1, a+1+cnt, cmp);
	for(int i=1;i<=cnt;i++) {
		cout<<a[i];
	}
	
	cout<<endl;
	return 0;
}
```


---

## 作者：Leasier (赞：1)

考虑能被 $30$ 整除的数的特征。

显然，如果一个数要能被 $30$ 整除，其末尾必须为 $0$ 且各位数字之和 $\bmod 3 = 0$。

如果 $n$ 为一位数或 $n$ 中不含 $0$ 或 $n$ 的各位数字之和 $\bmod 3 \neq 0$，显然不可构造。

否则，将 $n$ 的各位数字从大到小排列，即可构造出所求的最大的数。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

char n[100007];

bool cmp(const char a, const char b){
	return a > b;
}

int main(){
	int len, sum = 0;
	bool flag = false;
	cin >> n;
	len = strlen(n);
	if (len == 1){
		cout << -1;
		return 0;
	}
	for (int i = 0; i < len; i++){
		if (n[i] == '0') flag = true;
		sum = (sum + n[i] - '0') % 3;
	}
	if (!flag || sum != 0){
		cout << -1;
		return 0;
	}
	sort(n, n + len, cmp);
	for (int i = 0; i < len; i++){
		cout << n[i];
	}
	return 0;
}
```

---

## 作者：_OJF_ (赞：1)

主题库！红题！可以写题解！

来了来了

首先需要知道判断被$30$整除的条件是什么

需要同时被$2, 3, 5$整除

相当于同时被$3, 10$整除

被$10$整除的条件：末位为$0$

判断一下整个数中有无$0$即可判断出一部分不成立

被$3$整除的条件：$3|$各位数字之和

再判断一下数字和能否被$3$整除即可判断出是否可以被$30$整除

如果不可能被$30$整除，就直接输出$-1$

$return$ $0;$

数字给定，那么越大的数字越在前位，$0$在最后一位恰巧满足条件

所以统计$0$~$9$的个数，再输出就可以了

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10], sum;
string s;
int main(){
    cin>>s;
    for(int i = 0;i <= s.length();i++){
        a[s[i] - '0']++;
        sum += s[i] - '0';
    }
    if(sum % 3 || a[0] == 0){
        cout<<-1;
        return 0;
    }
    for(int i = 9;i >= 0;i--)
        for(int j = 1;j <= a[i];j++)
            cout<<i;
    return 0;
}
```


---

## 作者：Max_s_xaM (赞：0)

# P7174 [COCI2014-2015#4] CESTA


### 题目大意

给出 $N$ $(N \le 10^5)$ 个数字，判断能否用这 $N$ 个数字组成一个 $30$ 的倍数。如果能，输出其中最大的；如果不能，输出 ``-1`` 。

### 分析

判断一个数是否为 $30$ 的倍数，只需判断它是否同时是 $3$ 和 $10$ 的倍数。
- 判断 $3$ 的倍数：数字和（每一位上的数字的和）能否被 $3$ 整除。

- 判断 $10$ 的倍数：末尾是否为 $0$ 。

所以我们只需要在输入时记录有没有 $0$ 和数字和是多少即可。如果可以被 $30$ 整除，将所有数字降序排序输出。

### 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int f[100010], top, sum;
int main()
{
	char a;
	bool flag = 0;
	while (cin >> a) // 循环输入
	{
		f[++top] = a - '0'; // f数组记录每次输入的数
		if (a == '0') flag = 1; // 判断有没有0
		sum += a - '0'; // 数字和统计
	}
	if (flag && sum % 3 == 0) // 是30的倍数
	{
		sort (f + 1, f + top + 1); // 排序
		for (int i = top;i >= 1;i--) cout << f[i];
        	// 升序排序，逆序输出，相当于降序排序，正序输出
	}
	else cout << "-1" << endl; // 不是30的倍数
	
	return 0;
}

```


---

## 作者：WinterRain208 (赞：0)

P7174 【[COCI2014-2015#4]CESTA】

看到这题还没有题解，赶紧来水一发。

看到数据，这个数位数不超过$10^5$。显然高精，用字符串读入。

接下来我们来介绍这题关键：整除特征。

$30$，我个人认为拆成$3$和$10$会比较好做。

$10$的整除特征很简单，末位是零即可。

$3$的整除特征是数位之和被三整除，这个可以用位置原理证明。

因为数据到了$1e5$，所以全排列废了。

思路：

判断无解情况：没有$0$或所有数字之和无法被三整除。

从大到小排序，因为这时不管怎么排列都是$30$倍数，$0$因为最小，必定在最后。

解决啦！

### $CODE$

```cpp
#include<bits/stdc++.h>
#define F(i,j,r) for(int i=j;i<=r;++i)

using namespace std;
const int N=1e5+5;

string str;
int tot=0,f=0;

bool cmp(char a,char b){
	return a>b;
}
int main(){
	cin>>str;
	F(i,0,str.size()-1){
		tot+=(str[i]-'0');
		if(str[i]=='0')f=1;
	}
	if(f==0||tot%3){
		puts("-1");
		exit(0);
	}
	sort(str.begin(),str.end(),cmp);
	cout<<str<<endl;
    return 0;
}

```

$wtrl$。


---

## 作者：CSP_Sept (赞：0)

比较简单的一题。

___

### Solution

首先得判断输出 $-1$ 的情况：

- $n$ 的各位相加不是 $3$ 的倍数时。
- $n$ 没有一位是 $0$ 时。

好，再从大到小排列一遍，输出就是最大值。

### Code

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;
int a[100010];
char s[100010];
bool cmp(int a, int b){return a > b;}
int main(){
    scanf("%s", s);
    int sum = 0;
    int ssize = strlen(s);
    bool f = 1;
    for(int i = 0 ; i < ssize ; i++) if(s[i] == '0') f = 0;
    if(f){
        puts("-1");
        return 0;
    }
    for(int i = 0 ; i < ssize ; i++) a[i] = s[i] - '0', sum += a[i];
    if(sum % 3){
        puts("-1");
        return 0;
    }
    sort(a, a + ssize, cmp);
    for(int i = 0 ; i < ssize ; i++) printf("%d", a[i]);
    return 0;
}
```

---

## 作者：Vector_Mingfan (赞：0)

[题目由此去](https://www.luogu.com.cn/problem/P7174)
-------
### 前置芝士（放两个连接）：

1.[浅谈vector](https://www.luogu.com.cn/blog/MX23/qian-tan-vector)

2.[vector排序](https://www.cnblogs.com/fantianliang/p/11655892.html)

--------
### 进入正题

$1.$题目大意：给一个数，把它拆分成单个数字，然后用这些数字组成一个数看能不能被$30$整除。（每个数都要用）

$2.$怎么做：首先将$30$分解质因数，$30 = 2 × 3 × 5$
   
       2的整除特征：个位是0 , 2 , 4 , 6 , 8；
       
       5的整除特征：各位是0 , 5；
       
       3的整除特征：各个数位之和为 3k  (3k可海星)。

从$2和5$的整除特征可知，该数个位必定是$0$。
	
       所以程序里先半段一波0

接着进行判断$3$的整除，就把该数各个数位相加所得的和看能不能整除$3$就行。

#### NO.1（45分）如下

VC第一眼看这个数据范围就很开心，把“$n$的位数不超过 $10^5$”看成了“$n$的不超过 $10^5$”，然后就。。。。有手就行（（（

```
#include <cstdio>
#include <algorithm>

int n , cnt , sum;
int a[7];
bool flag;

int main(void ) {
	scanf("%d",&n);
	a[1] = n % 10;
	a[2] = n % 100 / 10;
	a[3] = n % 1000 / 100;
	a[4] = n % 10000 / 1000;
	a[5] = n % 100000 / 10000;
	a[6] = n / 100000;
	for (int i=6; i>=1; i-- ) {
		if (a[i]) {
			cnt = i;
			break;
		}
	}
	for (int i=1; i<=cnt; i++ ) {
		if (a[i] == 0) {
			flag = 1;
		}
		sum += a[i];
	}
	if (!flag) {
		printf("-1");
		return 0;
	}
	else if (sum % 3 == 0){
		std::stable_sort(a + 1 , a + cnt + 1);
		for (int i=cnt; i>=1; i-- ) {
			printf("%d",a[i]);
		}
	}
}
```
**45分。。。艹，检查后就很吃惊。。。“$n$的位数不超过 $10^5$”！！！好好好重来。**

### 所以要用字符串存储

**接着又打了如下代码**

```
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <cstring>
using namespace std;

const int MAXX = 100005;
int n , cnt , sum;
char str[MAXX];
bool flag;

int main(void ) {
	cin >> str;
	for (int i=0; i<strlen(str); i++ ) {
		int a = str[i] - '0';
		if (a == 0) {
			flag = 1;
		}
		else {
			sum += a;
		}
	}
	if (!flag) {
		printf("-1");
		return 0;
	}
		sort(str , str + strlen(str));
		for (long long i=strlen(str) - 1; i>=0; i-- ) {
			cout << str[i];
		}
}
```
发现预计100分，只得了90分。

检查发现是
```
	if (!flag) {
		printf("-1");
		return 0;
	}
```
没加$（sum % 3）$也就是数字只和不能被3整除

### 加上后100分

### code：
```
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <cstring>
using namespace std;

const int MAXX = 100005;
int n , cnt , sum;
char str[MAXX];
bool flag;

bool cmp(char a , char b) {
    return a > b;
}

int main(void ) {
    cin >> str;
    for (int i=0; i<strlen(str); i++ ) {
        int a = str[i] - '0';//把字符变量转换成整型变量 
        if (a == 0) {
			//判断是否有零
			//即n中是否有0 
            flag = 1;
			//有的话就将flag设为1 
        	//即有0; 
		}
        else {
            sum += a;
        }
    }
    if (!flag || sum % 3) {//没0或者，数字和不能被3整除 
        printf("-1");
        return 0;
    }
    stable_sort(str , str + strlen(str) , cmp);
	//对数组进行排序，因为题目要求每位数字所组成的数中 30 的最大倍数，排个序，从大到小 
    cout << str;
}
```
### 最后VC又结合了最近所学的vector来做了一遍

```
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

vector<char> str;//vector容器

const int MAXX = 100005;
int n , cnt , sum;
char ch;
bool flag;

bool cmp(char a , char b) {
	return a > b;
}//排序，从大到小

int main(void ) {
	while (scanf("%c",&ch) != '\n') {
		if (ch == '\n') break;//输入的字符
		str.push_back(ch);//加入容器
	} 
	for (int i=0; i<str.size() ; i++ ) {
		int a = str[i] - '0';//把字符变量转换成整型变量 
		if (a == 0) {
			flag = 1;
		}
		else {
			sum += a;
		}
	}
	if (!flag || sum % 3) {
		printf("-1");
		return 0;
	}
	sort (str.begin() , str.end() , cmp);//vector排序
	for (int i=0; i<str.size(); i++ ) {
		printf("%c",str[i]);//输出
	}
}
```
看不懂？请阅读**前置芝士**
-----
求管理给过qwq

完结撒花 ✿✿ヽ(°▽°)ノ✿

---


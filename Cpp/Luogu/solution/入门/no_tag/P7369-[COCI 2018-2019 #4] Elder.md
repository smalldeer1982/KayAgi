# [COCI 2018/2019 #4] Elder

## 题目描述

Nikola 在一周内看完八部哈利波特电影之后，体会到了老魔杖的威力之大。如果老魔杖目前效忠于巫师 A，而巫师 A 被巫师 B 击败，则老魔杖会开始效忠于巫师 B。

现在若干位巫师将进行 $N$ 次决斗。已知老魔杖最初效忠的巫师和 $N$ 次决斗的结果，求：

1. 在 $N$ 次决斗之后，老魔杖效忠的对象。
2. 老魔杖曾经效忠于几位巫师？

## 说明/提示

#### 样例 1 解释

老魔杖最初效忠于巫师 A。第一次决斗之后，老魔杖开始效忠于 B。第二次决斗之后，老魔杖开始效忠于 C。此后的第三次对老魔杖的效忠对象无影响。

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le N \le 100$。

#### 评分方式

每组数据第一行计 $2$ 分，第二行计 $3$ 分，每组数据共 $5$ 分。如果只想获得其中一行的分数，也请在另一行随意输出一个数，否则将无法正常评判。

评分所需要借助的 Special Judge 详见附件。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #4](https://hsin.hr/coci/archive/2018_2019/contest4_tasks.pdf)  _T1 Elder_。**

## 样例 #1

### 输入

```
A
3
B A
C B
D A```

### 输出

```
C
3```

## 样例 #2

### 输入

```
N
5
D A
N B
B A
C D
F A```

### 输出

```
N
1```

## 样例 #3

### 输入

```
X
4
A X
B X
X A
D A```

### 输出

```
X
2```

# 题解

## 作者：Thomas_Cat (赞：8)

标题名字奇奇怪怪（

这题思路其实很简单。

设现在的赢家为 $w$，经手人数为 $s$，经手的人（字符串）用 $c_i$ 表示（$i$ 表示经手的人，这里用 `(int)i` 来存入数组，$c_i \in \{0,1\}$，$0$ 表示没有经手，$1$ 反之）。

但是有下面几个坑点：

- 对于每一组输入数据 $x,y$，会有下面的可能：

	- $$x,y \not\in \{w\}$$

	- $$s \ne \sum\limits_{i=65}^{90}c_i$$

思路很简单，就是直接用 `winner` 数组和 `sum` 数组标记即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	char a;
	cin>>a;
	int n,sum=1;//同下，已经有人使用过，直接标记为1
	cin>>n;
	char winner=a;
	int flag[10001]={0};
	flag[(int)a]=1;//注意要先标记这里的一开始掌管者已经使用了
	for(int i=1;i<=n;i++){
		char x,y;
		cin>>x>>y;
		if(winner!=x&&winner!=y) continue;
		else{
			if(winner==y){
				if(flag[(int)x]==0){//如上所述，上面的字符串用flag数组表示
					flag[(int)x]=1;//同理
					sum++;		
				}
				winner=x;//注意标记赢者
			}
		}
	}
	cout<<winner<<endl;//输出
	cout<<sum;
	return 0;
}
```

---

## 作者：EuphoricStar (赞：4)

## 思路

此题是一道简单的模拟。

我们使用一个字符 $cur$ 表示当前老魔杖效忠的巫师，一个集合 $s$ 来存放老魔杖曾经效忠的巫师。

则每次输入 $Z_1$ 和 $Z_2$，如果 $cur$ == $Z_2$，则更新 $cur$ 为 $Z_1$ 并将 $Z_1$ 添加进集合 $s$。

最后的 $cur$ 和 $s$ 的元素个数就是答案。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

char cur;
int n;
set<char> s;

int main() {
    ios::sync_with_stdio(0);
    cin >> cur >> n;
    s.insert(cur);
    while (n--) {
        char a, b;
        cin >> a >> b;
        if (cur == b) {
            cur = a;
            s.insert(a);
        }
    }
    cout << cur << '\n' << s.size();
    return 0;
}
```


---

## 作者：_xbn (赞：3)

看到题解区没有用 map 的，我来发一篇 map 的题解。我们用 mp 数组记录

当前老魔杖位于哪个巫师，用 hp 数组记录那些巫师被依赖过。

当魔杖位置发生变化时， mp 就记录变化后魔杖依赖哪个巫师， 答案加一，同时，

我们用 ch 记录当前魔杖位置，最后输出 ans 和 ch 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=102;
int n,m,k,p,q,ans,sum,tot,cnt,a[N],b[N],c[N];
char s[10002],s1,s2,s3;
map<char,int> mp;
map<char,bool> hp;
int main()
{
	cin>>s[1];
	ans++;
	s3=s[1];
	cin>>n;
	mp[s[1]]=1;
	hp[s[1]]=1;
	for(int i=1;i<=n;i++)
	{
		cin>>s1>>s2;
		if(mp[s2]==1)
		{
			mp[s2]=0;
			mp[s1]=1;
			s3=s1;
			if(hp[s1]==0)ans++,hp[s1]=1;
		}
	}
    cout<<s3<<endl<<ans;
	return 0;
}
```


---

## 作者：win_信 (赞：2)

刚开始想的很复杂，然而其实就是一道模拟。即依题意，不断标记，换人即可。注释在代码中。

见代码：
```
#include <cstdio>
#include <iostream>
using namespace std;
int n,k,vis[1001];//k表示人数，vis用来标记 
char a,b,xz; // xz表效忠的人 
int main()
{
	cin>>xz;//最开始效忠的 
	k=1;
	vis[xz]=1;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		if(xz==b)//如果本来的效忠的被打败 
		{
			xz=a;//换人 
			if(vis[xz]==0)//如果这位战胜者是个新秀（既没被标记过） 
			{
				k++;vis[xz]=1;//人数+1，标记 
			}
		}
	}
	printf("%c\n%d",xz,k);//输出 
	return 0;
} 
```


---

## 作者：xtracer (赞：1)

### 一道ASCII码与模拟的题目

------------

思路：首先开一个足够大的桶，存字符；再定义一个变量存目前老魔杖效忠的对象，用 `x` 表示。每次输入决斗结果，胜方用 `a` 表示，败方用 `b` 表示。判断 `x` 是否等于 `b` ，如果是，`x` 赋值为 `a` ，并将桶内 `x` 变量代表的这个字符的值设为 1 。最后求和这个桶（即求出 1 的个数）。

**优点**：这个办法可以巧妙避开重复，因为不管效忠同一人多次，它在桶内的值一直为 1 。

**缺点**：内存容易超限，尤其对于卡时空限制的题目。

------------

### AC 代码：

Py3版
```python
import sys
try:
    x=input()
    n=int(input())
    se=list(map(int,str('0'*1024)))#开桶，这里我用的是字符串映射整形
    x=x[0] #很坑，就因为这里RE了几次，ord求ASCII要一个字符，这个带了一个换行符在末尾
    se[ord(x)-1]=1
    s=''
    for i in range(0,n):
        s=input().split()
        if x==s[1]: #更换效忠对象
            x=s[0]
            x=x[0]
            se[ord(x)-1]=1
    print(x[0])
    print(sum(se)) #求和
except Exception as e: #卡Python RE 专用，抓取Exception 让它不报错
    print(e)
```

Cpp版：
```cpp
#include<iostream>
using namespace std;
typedef long long ll;
ll bucket[10001]={};
char a,b,x;
ll n;
int main(){
    cin>>x>>n;
    bucket[x]=1;
    while(n--){
        cin>>a>>b;
        if(x==b){
            x=a;
            bucket[x]=1;
        }
    }
    for(ll i=65;i<=65+25;i++)n+=bucket[i]; //反正n已经在while那里清零了（滑稽）
    cout<<x<<endl<<++n;
    return 0;
}
```
感谢大家的观看！

---

## 作者：银河AI (赞：1)

### 解题思路

数据很水，才 $10^2$，考虑模拟。

我们用一个标记数组 $t$ 来记录有哪些人拿到过老魔杖，用 $k$ 来表示当前拿到魔杖的巫师。

在输入两个巫师决斗的时候，判断输的那个人是否是当前拿到魔杖的，如果是，则更新 $k$ ，如果打赢的那个人是第一次拿到魔杖，那么更新 $t$。

因为要用 $t$ 存，所以我们将数字全部存成字符。

这里有个小技巧，只要是遇到输入字符类型的题，都可以用快读思想来解决。

在本题可以在读入字符的同时返回其数字的值。

不吸氧 $20ms$ 喜提最优解。

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e2+1;
char q;
int n,ans=1,k;
int t[27];
inline char read(){
	char ch=getchar();
	while(ch<'A'||ch>'Z') ch=getchar();
	return ch-'A'+1;
}
int main(){
	q=read();
	scanf("%d",&n);t[q]=1,k=q;
	for(int i=1;i<=n;i++){
		char x,y;
		x=read(),y=read();
		if(y==k){
			k=x;
			if(!t[k]) ans++,t[k]++;
		}
	}
	printf("%c\n%d",k+'A'-1,ans);
}
```


---

## 作者：John_yangliwu (赞：1)

## 思路
需要解决 $2$ 个问题：
1. 经过 $N$ 次决斗，老魔杖最终效忠于那个巫师？
2. 老魔杖曾经效忠过多少巫师？

问题 $1$ 比较简单，用一个 char 类型变量 $res$ 维护老魔杖每时每刻效忠于那个巫师，并在决斗后按规则更新即可。

问题 $2$ 有个小坑：老魔杖可能多次效忠于一个巫师。所以我们用数组 $vis$ 维护老魔杖是否效忠过一个巫师，如果老魔杖没有效忠过决斗的胜者，那么答案累加 $1$。否则答案不变。

$vis$ 数组的维护有一个小技巧：让巫师对应的大写字母 `-'A'`，对应 $vis$ 的下标，可以节省~~很小的~~一部分空间。

## 代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;

bool vis[30];

int main() {
    char res;
    int cnt = 1, n;
    cin >> res >> n;

    memset(vis, false, sizeof(vis));
    vis[res - 'A'] = true;

    for(int i = 1; i <= n; i++) {
        char z1, z2; cin >> z1 >> z2;
        if(z2 != res) continue;//败者不是魔杖效忠对象，啥事没有
        res = z1; //更新效忠对象
        if(!vis[z1 - 'A']) cnt++;//没效忠过胜者，答案累加
        vis[z1 - 'A'] = true;//这下效忠过了
    }

    cout << res << endl << cnt << endl;
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/46994012)

---
$\Large\text{THE\ \ END}$

---

## 作者：Eason_AC (赞：1)

## Content
有一个魔杖最初在 $Z$ 巫师中。经过 $n$ 轮较量，第 $i$ 轮中，$Z_{i,1}$ 巫师打败了 $Z_{i,2}$ 巫师。如果一个巫师打败了拥有魔杖的巫师，那么魔杖就到了获胜的巫师手中。问：

- 最后魔杖在哪个巫师哪里。
- 魔杖一共经过多少巫师之手。

**数据范围：$n\in[1,100]$。**
## Solution
第一个问题直接模拟，将魔杖按照规则不断传递。

第二个问题开个 $vis$ 数组，直接判断是否出现过，没出现过标记一下再累加答案即可。
## Code
```cpp
int n, ans;
char first[2], game1[2], game2[2];
map<char, int> vis;

int main() {
	scanf("%s%d", first, &n);
	vis[first[0]] = 1, ans++;
	for(int i = 1; i <= n; ++i) {
		scanf("%s%s", game1, game2);
		if(game2[0] == first[0]) {
			first[0] = game1[0];
			if(!vis[game1[0]]) vis[game1[0]] = 1, ans++;
		}
	}
	printf("%c\n%d", first[0], ans);
	return 0;
} 
```

---

## 作者：胡金梁 (赞：0)

这题数据较小，暴力可过，但有一个坑点，就是原主人输了老魔杖后能把老魔杖赢回来。所以要开一个桶，用来避免重复计数。然后的代码相信大家都能写出来。
```
/*胡金梁*/
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
int ch[26];
signed main(){
#if __MY_TEST__
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	char x;
	cin>>x;
	int n,s=1;
	cin>>n;
	ch[x-'A']=1;
	for(int i=1;i<=n;i++)
	{
		char a,b;
		cin>>a>>b;
		if(b==x)
		{
			x=a;
			if(ch[x-'A']==0)
				s++,ch[x-'A']=1;
		}
	}
	cout<<x<<endl<<s;
#if __MY_TEST__
	fclose(stdin);
	fclose(stdout);
#endif
}
```


---

## 作者：luckydrawbox (赞：0)

## 题意

一开始一个魔杖在一个巫师手中，接下来 $N$ 轮战斗，每轮下来如果拿着魔杖的巫师被打败，就把魔杖传给下一个巫师。

求：

$1.$ 最后拿着魔杖的巫师。

$2.$ 拿过魔杖的巫师的个数。

## 分析

对于第一个问题：我们可以把被老魔杖效忠的巫师抽象成一个**变量**，一开始先赋值成老魔杖的原主人，接下来每轮如果被老魔杖效忠的巫师被打败，就把胜利的巫师**覆盖**在原来的上面，最后变量的值就是最后效忠的巫师。

对于第二个问题：我们建立一个 ``bool`` 型的 $b$ 数组，表示某个巫师是否被效忠过，因为表示巫师的都是**大写字母**，所以只要 ``bool b[26]`` 就行了，若某个巫师的大写字母用 $c$ 来表示，则他对应的下标为 $c-'A\ '$。我们在解决第一个问题的同时，可以不断把每个覆盖的巫师对应的 $b_{c-'A\ '}$ 赋值为 $ture$，最后**统计**一下就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum;
char c,winner,loser;
bool b[26];
int main()
{
    cin>>c;
	cin>>n;
    b[c-'A']=1;//第一次效忠的主人也要算上 
    for(int i=1;i<=n;i++)
    {
    	cin>>winner>>loser;
    	if(c==loser)//如果目前效忠的主人失败了 
    	{
    		c=winner;//改变当前的主人 
    		b[c-'A']=1;//效忠新主人 
		}
	}
	for(int i=0;i<26;i++)
	if(b[i])sum++;//如果这个主人效忠过就加1 
	cout<<c<<endl;
	cout<<sum<<endl;
	return 0;
}
```


---

## 作者：tZEROちゃん (赞：0)

### Solution

模拟即可。

定义一个 bool 型数组 $per$，表示老魔杖（elder wand）曾或现在效忠的对象。

首先，我们将最开始效忠的对象读入，然后将其对应下标的值（$per_{\texttt{int(}now\texttt{)}}$）设置为 $\tt{true}$。

接着我们输入总人数 $n$。

然后进行 $\tt{for}$ 循环，对于每一次循环：         
- 读入 $\tt{char}$ 类型变量 $a, b$，表示 $a$ 打败了 $b$。
- 如果老魔杖现在效忠于 $b$，那么：
   - 将老魔杖现在效忠的对象（变量 $now$）由 $b$ 改为 $a$。
   - 将 $per_{\texttt{int(}now\texttt{)}}$ 设置为 $\tt{true}$。
   
最后遍历一下 $per$ 数组，找有多少个 $\tt{true}$ 就可以了。
   
### Code
```cpp
#include <bits/stdc++.h>
#define tearingCuteQwQ 0
using namespace std;
bool per[114514];
int main()
{
	char now; 
	cin >> now;
	per[int(now)] = true;
	int n;
	cin >> n;
	int cnt = 0;
	for (int i = 1; i <= n; i++)
	{
		char a, b;
		cin >> a >> b;
		if (b == now)
		{
			now = a; // Question 1
			per[int(now)] = true; // Question 2
		}
	}
	for (int i = 'A'; i <= 'Z'; i++) if (per[i] == true) cnt++; 
	cout << now << endl << cnt;
	return tearingCuteQwQ;
}
``` 

tearing      
Feb. 18. 

---

## 作者：Trafford1894 (赞：0)



### Description

魔杖曾经效忠于一个巫师，有 $n$ 轮决斗，其中第 $i$ 轮 巫师 $X_i$ 击败了巫师 $Y_i$，求魔杖最后效忠的巫师和魔杖效忠巫师的个数。

### Solution

模拟题，唯一的坑点是如果 $Y_i$ 是魔杖现在效忠的巫师，则要判断魔杖是否效忠过 $X_i$。

### ACCode

```cpp


#include <iostream>
#include <map>

using namespace std;

int _num = 1;
int _maxi;
char _now;

map<char, int> _visit;

void Solve () {
	char win;
	char lose;
	
	cin >> _now >> _maxi;
	_visit[_now] = 1;
	
	for (int i = 0; i < _maxi; i++) {
		cin >> win >> lose;
		
		if (lose == _now) {
			_now = win;
			if (_visit[_now] == 0) {
				_num++;
				_visit[_now] = 1;
			}
		}
	}
}	

void Output () {
	cout << _now << endl << _num << endl;	
}

int main () {
	Solve();
	Output();
	
	return 0;	
}
```


---

## 作者：_lfxxx_ (赞：0)

## 思路：
读入一个大写字母和一个数字后，每读一组数据处理一组，问题一还是比较简单的，如果输了给魔杖效力的巫师改为前面那个巫师就行。

问题二有点麻烦，因为魔杖效力的巫师有可能重复（前面输了，后面又打赢了），因此我们需要记录魔杖效力的巫师。

## 话不多说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,s=1,j=1,k;//s初值为1是因为魔杖一开始就效力一个巫师
char a,b,c,w[101];//w数组是记录有魔杖效力的的巫师
bool f;
int main(){
    cin>>a>>n;
    w[j]=a;//注意，刚开始魔杖效力的也要记进去
    for(i=1;i<=n;i++){
        cin>>b>>c;
        if(a==c){//如果魔杖效力的巫师输了
	    f=1;假设效力过
            for(k=1;k<=j;k++)
	        if(b==w[k]){
	            f=0;//效力过就标记
                    break;
                }
	    if(f){//如果没效力过
	        s++;//拿过的人++
	        j++;
	        w[j]=b;//存入效力的名单
	    }
	    a=b;//魔杖效力的巫师换成赢的
	}
    }
    cout<<a<<endl<<s;
    return 0;
}
```
~~这题好水。~~

---

## 作者：tobie (赞：0)

此题是一道模拟题。

我们读入 $Z_1,Z_2$ ，根据老魔杖效忠对象的规律，若 $Z_2=Z_{\text {now}}$，则 $Z_{\text {now}}←Z_1$。

然后我们开一个bool数组记录老魔杖曾经效忠过的巫师，最后扫一遍统计老魔杖曾经效忠过的巫师个数即可。

代码：
```
#include<iostream>
#include<cstdio>
using namespace std;
int now,n;//n是决斗的次数，now为上文的Z_now
char ch1[10],ch2[10];//我习惯以字符串形式读入字符
bool vis[128];
int cnt=0;
int main()
{
	scanf("%s%d",ch1,&n);
	now=ch1[0];
	vis[now]=true;
	while(n--)
	{
		scanf("%s%s",ch1,ch2);
		if(ch2[0]==now) now=ch1[0];
		vis[now]=true;
	}
	for(int i='A';i<='Z';i++) if(vis[i]) cnt++;//统计老魔杖曾经效忠过的巫师个数
	putchar(now);putchar('\n');
	printf("%d",cnt);
	return 0;
}
```

---

## 作者：_lzh_ (赞：0)

## 思路

这是一道模拟题，记录一下老魔杖在谁手里就行了

## 坑点

如果A从B那里得到了老魔杖，之后B又从A手中将老魔杖抢了回去，老魔杖的效忠对象就只有2人，而不是3人

其他问题就看代码的注释吧

## Code

```cpp
#include<iostream>
#define N 100010
using namespace std;
int hp[N]/*用于记录老魔杖在哪个巫师手里*/,n;
int ans=1/*记录老魔杖共有多少个效忠对象*/,pd[N];
char a,b,A,wsna/*记录老魔杖目前的效忠对象*/;
signed main()
{
    cin>>A;
    hp[A]=1;//老魔杖在A手中 
	wsna=A;// 最开始老魔杖的效忠对象是A 
    pd[A]=1;//A已经得到过老魔杖 
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a>>b;
        if(hp[b]==1)//如果老魔杖在B手中 
		{
			hp[a]=1;
			hp[b]=0;
			//转移老魔杖 
			wsna=a;//将老魔杖的效忠对象改为a 
			if(pd[a]==0)//如果a没有得到过老魔杖 
			{
				pd[a]=1;//标记a 
				ans++;//增加老魔杖的效忠对象个数 
			}
		}
    }
    cout<<wsna<<endl;
    cout<<ans<<endl;
    return 0;
}

```

---


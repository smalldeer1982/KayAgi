# [COCI 2020/2021 #5] Šifra

## 题目描述

给定一个长度不超过 $100$ 的只包含小写字母和 $0 \sim 9$ 字符的字符串（字符串中的字母可视为分隔符）。求字符串中包含多少个不同的数。

## 说明/提示

#### 数据规模与约定

对于 $50\%$ 的数据，所有出现的数都互不相同。

对于 $100\%$ 的数据，字符串的长度在 $1$ 到 $100$ 之间。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #5](https://hsin.hr/coci/contest5_tasks.pdf)  _T1 Šifra_。**

## 样例 #1

### 输入

```
abc123abc2a3a1```

### 输出

```
4```

## 样例 #2

### 输入

```
borna123vitez```

### 输出

```
1```

## 样例 #3

### 输入

```
as23dkrf23smk1asd23sam9```

### 输出

```
3```

# 题解

## 作者：wangbinfeng (赞：15)

大家好，感谢大家阅读这篇题解！
## 思路：
首先，我们看到题，也许直觉认为是统计**数字**个数（数字是指 $9\ge x \ge 0$ 的数 ~~，出题人语文水平有待提高~~）。

but ```abc123abc2a3a1``` 只有三个数字，但答案是 $4$ ，可以得出应该求得是**数**。

统计数的个数大家都会吧，具体在注释里。

我看过其他的题解，大多都用 C++ 中的 `string ` ，所以本题解使用读入一个字符判断一次。

然后还有几个易错点，大家可以看**更新日志**（数据有点水，所以容易忽略细节，大家一定注意）。

## 程序：
```cpp
//由于处理了2个hack且间隔时间较长，代码刻意加入了很多内容，可能使可读性变差，求谅解
#include <bits/stdc++.h>
using namespace std;
bool num[1000];//存储是否出现过
bool flag;//存有没有出现过0
char c,c2;//由于没有用字符串，只能多开一个变量存上一个字符
int ans,x;
int main(){
	for(c=getchar();c!=EOF;c=getchar()){
        if(c2=='0'&&(c<'0'||c>'9')&&x==0)flag=true;
        if(c>='0'&&c<='9')x=x*10+c-'0';//计算现在是多少
        else num[x]=true,x=0;//记录并归零
        c2=c;//记录上一个字符
    }
    if(c2>='0'&&c2<='9'&&num[x]==false)ans++;//注意要有特判
    if(c2=='0')ans++;
	for(int i=1;i<1000;i++)ans+=num[i];
	cout<<ans+flag;
}

```
最后，谢谢大家支持！

# 更新日志：
1. 4月27日：感谢 [@cd8gsh](https://www.luogu.com.cn/user/289859) 提醒，原因：数字有可能在最后，加入特判。
2. 8月20日：感谢 [@ZhuangnnnnE](https://www.luogu.com.cn/user/521592) 提醒，原因：由于处理上一个 hack 触发了潜在 bug（即 0 这个特殊的数，它会与代表 _目前没有存数字_ 的 0 重复），已修正。
- 我没想到红题 hack 这么多，想大家谢罪，也感谢 2 位发现 hack 的同学！


---

## 作者：Wuyanru (赞：4)

首先我们来看一眼这道题，嗯，大概的思路一般人应该都想得出来。

首先是读入，我的第一反应是使用string类型，毕竟很方便。

但是本题数据量也不大，开一个字符数组也是完全可以的。

其次就是从字符串中查找数字的操作了，这也是比较简单的，一位一位地找完全可以解决。

最后的问题是如何判重，我看到题目第一反应是使用map来判重，毕竟使用起来非常方便。但是题目也已经保证了数字位数不超过三位，也就是说使用一个vis数组也完全可以起到判重作用。

其实好像也没有什么实在可以好讲的了，实在看不懂的可以尝试看代码。

因为害怕一些小伙伴不会使用映射，所以代码采用数组进行判重。

AC代码：

```
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
bool vis[1001];
string in;
int num,flag;
int main()
{
    cin>>in;  //读入字符串
    int len=in.length();  //字符串长度
    for(int i=0;i<len;i++)
    {
        if(in[i]>='0'&&in[i]<='9')  //如果正在处理的这一位是数字
        {
            num=num*10+in[i]-'0';//将数字进行处理
            flag=1;  //flag=1 表示这一位是数字
        }
        else if(flag==1) //如果正在处理的这一位是字母且上一位是数字
            {
                flag=0;//标记这一位不是数字
                vis[num]=1;//标记这一个数字出现过
                num=0;//将处理的数字清空
            }
    }
    if(flag==1)
        vis[num]=1;//如果最后一位是数字也进行处理
    int ans=0;
    for(int i=0;i<=1000;i++)
        if(vis[i])//计算出现过的数字
            ans++;
    printf("%d",ans);//输出
    return 0;
}
```
完结撒花！

感谢观看！

---

## 作者：fffngzzh (赞：4)

## 前言
建议将此题评为红题。
## 正文
看到这道题，我的想法是字符串加 stl 中的 map 数据结构

map 算是 C++STL 模板的神器吧，它可以定义一个下标为任意数据类型的数组

但由于 map 的处理数据效率太低，在数据较大时谨慎使用

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,bool>qq;//定义一个值为bool类型，下标为string类型的名为qq的数组 
int main() {
	qq.clear();//清空数组qq 
	char c;
	long long ans=0;//记录数字数量 
	for(c=getchar(); c!=EOF && c!=char(10)/*读到字符串末尾时跳出循环*/; c=getchar()) {
		if('0'<=c && c<='9') {//判断是否是数字，字母会直接忽略 
			string str="",s;//定义字符串 
			while('0'<=c && c<='9') {//一直读入数字，读入字母时跳出 
				s= {c};
				str=str+s;//构造一个表示该数字的字符串 
				c=getchar();//读入 
			}
			if(!qq[str]) {//如果这个数字还没被读到过，已经被读到了的数字会直接忽略 
				qq[str]=1;//标志这个数字已被读到 
				ans++;//统计数字数量 
			}
		}
	}
	cout<<ans<<endl;//输出答案 
}
```

该代码的优点：

1. 如果读到的数字位数不限，本代码照样 AC
1. 很好的发挥了 C++ 的优势 
1. 节省了空间

该代码的缺点：

1. 如果字符串长度过长，由于 map 处理数据效率低，可能会运行超时
1. 代码第12行的 s={c} 不一定在所有编译环境下都可正常运行

## 后记

~~后记就是求过~~



---

## 作者：EuphoricStar (赞：3)

## 思路

首先，我们将字符串中的小写字母改为空格，方便后续读入。

然后创建一个 `set` 和 `stringstream`，不断从字符串中读入整数，并将它添加进 `set` 中。

之后输出 `set` 的长度即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
set<int> nums;

int main() {
    ios::sync_with_stdio(0);
    cin >> s;
    for (int i = 0; i < s.size(); ++i) {
        if (!isdigit(s[i])) {
            s[i] = ' ';
        }
    }
    stringstream ss(s);
    int x;
    while (ss >> x) {
        nums.insert(x);
    }
    printf("%d", nums.size());
    return 0;
}
```


---

## 作者：Accteped (赞：3)

## 思路
**STL大法好**

此题只需对字符串进行模拟把每串有数字构成的字符串的数字统计起来，然后把这个数标记为出现过，如果这个数还没出现过就要把ans加一，然后继续去统计，我们来解释一个样例

```
borna123vitez
```
首先从第一个开始模拟直到碰到数字1，然后把数字串统计起来就成了123，然后答案就出来了，为1

```
as23dkrf23smk1asd23sam9
```
这个过程就不详解了，统计的数字为：23，23，23，1，9，虽然23出现过多次，但是只算23出现了一次，所以答案为3

因为这个数无限大，所以我们要用一个STL的map，来统计数字是否出现过，因为map可以定义一个无限大的数组

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,bool>p;//定义一个下标为int型,类型为bool型的无限大数组,统计各个数字是否出现过 
int ans,num=0;//ans统计共有多少个不同的数字,num统计每个数字串中的数字
string s; 
int main(){
	cin>>s;
	for(int i=0;i<s.size();++i){
		if(s[i]<='9'&&s[i]>='0'){//若为数字
			while(s[i]<='9'&&s[i]>='0'){//把这一串数字统计起来 
				num=(num*10)+(s[i]-'0');//把这数字统计起来 
				i++;//下标加一 
			}
			//如果碰到字母,就把这一段统计的数字标记
			if(!p[num]){//没出现过 
				ans++;//把不同数字的个数加一 
				p[num]=1;//标记为出现过 
			}
			num=0;//初始化 
		}
	}
	cout<<ans;//输出答案
	return 0; 
}
```


---

## 作者：thomas_zjl (赞：1)

首先看到题目中描述的数字最多是三位数。

所以我们以用一个桶来储存数据。

然后我们可以用x,y,z来记录这个数的每个数位。

最后在统计一下答案，就可以AC了。

接下来是我的代码。

```
#include<bits/stdc++.h>
using namespace std;
int jl[1010];
int main(){
    char a[101];
    scanf("%s",a+1);
    int n=strlen(a);
    int x,y,z;
    int q=1;//这个是用来统计数位的。
    int js=0;//这个是用来判断这个数是否更新。
    for(int i=1;i<=n;++i){
        if(a[i]>='0'&&a[i]<='9'){
            if(q==1){
                x=a[i]-'0';
                ++q;
                js=1;
            }
            else if(q==2){
                y=a[i]-'0';
                ++q;
                js=1;
            }
            else if(q==3){
                z=a[i]-'0';
                ++q;
                js=1;
            }
        }
        else{
            if(js==1){
                ++jl[x+y*10+z*100];//这个数所在的桶要增加。
                q=1;
                js=0;
                x=0;
                y=0;
                z=0;
                //上面的数据要初始化。
            }
        }
    }
    int ans=0;
    for(int i=0;i<1000;++i)
        if(jl[i]>=1)
            ++ans;//来统计不同的数字。
    printf("%d",ans);
    return 0;
}
```


---

## 作者：tZEROちゃん (赞：1)

### Solution

输入一个字符串 $s$，在最后加上一个小写英文字母表示这个字符串的结束。

对于字符串 $s$，使用一个循环 `for (int i = 0; i < s.size(); i++)`，当 $s_i$ 为小写字母，退出本次循环；否则，再写一个循环 `for (int j = i; j < s.size(); j++)`，每次使当前数字 $num$ 乘以 $10$ 然后加上这个字符对应的数字，如果下一个字符不是数字，那么就退出，退出后，让桶 $a_{num} = 1$。

最后找 $a$ 数组里有多少个 $1$，即为答案。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[114514];
int main() 
{
	string s; cin >> s; s += 'a';
	for (int i = 0; i < s.size(); i++)
	{
		if (s[i] >= 'a' && s[i] <= 'z') goto end;
		else if (s[i] >= '0' && s[i] <= '9') 
		{
			int num = 0;
			for (int j = i; j < s.size(); j++)
			{
				num = num * 10 + (char(s[j]) - '0');
				if (s[j + 1] >= 'a' && s[j + 1] <= 'z') { i = j; break; }
			}
			a[num] = 1;
		}
		end: ;
	}
	int cnt = 0;
	for (int i = 1; i <= 1145; i++) 
		if (a[i]) cnt++;
	printf("%d", cnt);
}
```

---

## 作者：Eason_AC (赞：1)

## Content
给定一个长度 $n$ 的只包含小写字母和 $0\sim9$ 的字符串（字符串中的字母可视为分隔符）。求字符串中包含多少个不同的数字。

**数据范围：$1\leqslant n\leqslant 100$，保证每个数字最多有 $3$ 位。**
## Solution
分两步即可：

- 读入字符串并提取出所有的数字。
- 统计不同的数字个数。

具体看代码实现。
## Code
```cpp
string s;
int num[107], x = -1, cnt, ans, vis[1007];

int main() {
 	cin >> s; int len = s.size();
	F(i, 0, len - 1) {
		if(!isdigit(s[i]) && x != -1) num[++cnt] = x, x = -1;
		else if(isdigit(s[i])) {
			if(x == -1) x = 0;
			x = x * 10 + s[i] - '0';
		}
	}
	if(x != -1) num[++cnt] = x;
	F(i, 1, cnt) if(!vis[num[i]]) vis[num[i]] = 1, ans++;
	return printf("%d", ans), 0;
}
```

---

## 作者：银河AI (赞：0)

### 解题思路

看完题面后，我们知道，本题最大的难点在于：

如何求两个字母之间的数字。

我们考虑快读的思想。

先放出本题快读方法的核心代码：

```cpp
inline void read(){
	char ch=getchar();
	while(ch!='\n'){
		int s=0;
		while(ch<'0'||ch>'9'){
			if(ch=='\n') return ;
			ch=getchar();
		}
		while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
		if(!t[s]) k++;
		t[s]++;
	}
} 
```
终止条件就是读入 '\n' 。

那么如果读入了不是数字字符的字符（就是字母）那么就跳过。

当读入数字字符的时候，将其转换成数字。

之后用桶标记一下。

**注意**：本代码的 $k$ 是指出现了多少个数，如果这个要标记的数之前没有出现过，那么就 $k++$ 代表又出现了一个之前没有出现过的数

AC 代码应该就不用放了（就输出 $k$）

---

## 作者：WinterRain208 (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P7398)

给你一个长度不超过$100$的字符串，求其中有几个不同的数字（夹杂在字母之间的）。

在线求解，一边读入一边计算，对于每个数字，判断是否出现过，有则记录并将答案加1，没有则跳过。

直接用字符串去重即可  ~~才不会告诉你是我没看到所有数字都小于100才用了高精~~

字符类型读入，是数字就加入字符串，当输入不是数字是时判断。

怎么去重？因为我一开始没看到数据范围所以用了$map$。


没有注释的高清版本。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,r) for(int i=j;i<=r;++i)
#define D(i,j,r) for(int i=j;i>=r;--i)
#define INF 0x3f3f3f3f

using namespace std;
const int N=1e5+5;

long long read(){
	long long f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<3)+(x<<1)+s-'0';s=getchar();}
	return x*f;
}

inline void write(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
	return;
}

int main(){
	char c;
	string cnt="";
	int ans=0,counter=0;
	map < string , int > m;
	while(c=getchar()){
		if(counter>100)break;
		if(isdigit(c))cnt+=c;
		else{
			if(cnt.size())
				if(m[cnt]==0){
					++ans;
					m[cnt]=1;
				}
			cnt="";
		}
		++counter;
	} 
	if(cnt.size())
		if(m[cnt]==0)++ans;
	write((long long)ans);
    return 0;
}

```


---

## 作者：Trafford1894 (赞：0)



### Description

给你一个字符串 $s$, 让你找出其中不同数字的个数。

### Solution

首先可以判断字符串的一位是否是数字，如果是的话就将这一位计算出来，如果不是的话就判断是否已经出现过，然后计数器累加。

具体实现见代码。

### ACCode

```cpp


#include <iostream>

using namespace std;

string _myStr;
bool _visit[1009];
int _cc = 0;

void ParseIn () {
	cin >> _myStr;	
}

void Core () {
	int curInt = -1;
	
	for (int i = 0; i < _myStr.length(); i++) {
		if (isdigit(_myStr[i])) {
			if (curInt == -1) {
				curInt = 0;
			}
			
			curInt = (curInt << 3) + (curInt << 1) + (_myStr[i] ^ 48);
		}
		
		else if (!isdigit(_myStr[i]) && curInt != -1) {
			if (!_visit[curInt]) {
				_visit[curInt] = true;
				_cc++;
			}
			
			curInt = -1;
		}
	}
	
	if (curInt != -1 && !_visit[curInt]) {
		_visit[curInt] = true;
		curInt = -1;
		_cc++;
	}
}

void WriteOut () {
	cout << _cc << endl;	
}

int main () {
	ParseIn();
	Core();
	WriteOut(); 
	
	return 0;
}	
```


---

## 作者：_lfxxx_ (赞：0)

终于又能为社区做贡献了。~~终于能水一道红题题解了~~
### 题意：
给你一串字符串，问你有多少种（注意是种不是个）数字。~~第一次以为是个后面点全错~~
### 思路：
读到一个数放进对应的桶里，最后看几个桶里有数。

## 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000];
bool f;//定义在主函数外会初始化，也就是清0
int main(){
	int x=0;
	char c;
	while((c=getchar())!=EOF)//还能读到东西时
		if(c>='0'&&c<='9')//是数
			if(f){//上一个是数
				x*=10;
				x+=c-'0';
			}
			else{//上一个不是数
				x=c-'0';
				f=1;
			}
		else{//放进桶
			f=0;//标记这个不是数
			if(x)
				a[x]=1;//标记该桶有数
		}
    if(x)//最后一个可能是数，要再判断一次
        a[x]=1;
	int s=0;
	for(int i=0;i<=999;i++)
		if(a[i])
			s++;//桶里有数就++
	cout<<s;
	return 0;
}
```
~~完结撒花~~

---


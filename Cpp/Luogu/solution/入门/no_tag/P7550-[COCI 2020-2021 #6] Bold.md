# [COCI 2020/2021 #6] Bold

## 题目描述

Paula 给 Daniel 写了一封信，她需要加粗文本的字体，以便视力恶化的 Daniel 阅读。

信可以用 `.` 和 `#` 组成的矩阵表示。对于所有信中原有的 `#`，Paula 需要将其向右下方扩展为 $2 \times 2$ 的 `#`。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$2 \le n, m \le 10^3$。保证信中只包含 `.` 和 `#`。

------------

#### 说明

**本题分值按 COCI 原题设置，满分 $50$**。

**题目译自 [COCI2020-2021](https://hsin.hr/coci/archive/2020_2021/) [CONTEST #6](https://hsin.hr/coci/archive/2020_2021/contest6_tasks.pdf) _T1 Bold_**。

## 样例 #1

### 输入

```
4 4
....
.#..
....
....```

### 输出

```
....
.##.
.##.
....```

## 样例 #2

### 输入

```
7 7
.......
.####..
.#...#.
.#...#.
.#...#.
.####..
.......```

### 输出

```
.......
.#####.
.######
.##..##
.##..##
.######
.#####.```

## 样例 #3

### 输入

```
9 7
.......
.####..
.#...#.
.#...#.
.####..
.#.....
.#.....
.#.....
.......```

### 输出

```
.......
.#####.
.######
.##..##
.######
.#####.
.##....
.##....
.##....```

# 题解

## 作者：Aiopr_2378 (赞：15)

# Solution P7550 [COCI2020-2021#6] Bold

## 一、思路：

~~这道题还是很简单的~~······

读题可得：如果点$(i,j)$为"#",那么点$(i,j+1)$,点$(i+1,j)$,点$(i+1,j+1)$都将变为"#"。

输入自然很简单，普通用$cin$、$cout$就可以读入/输出。

```cpp
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
```

### 要注意的是：

**每个点更新的时候我们不能从$i+1,j+1$方向更新，这样更新的点会被扫到错误答案**，例如：

	....

	.#..

	....

	....
    
当我们更新$(2,2)$时，$(2,3)$、$(3,2)$、$(3,3)$都会被更新。（如下图）

	....

	.##.

	.##.

	....

但是我们在更新$(2,3)$时就会发现这个点已经被更新，所以$(2,4)$、$(3,3)$、$(3,4)$也会被更新，以此类推。（如下图）

	....

	.###

	.###

	.###

但是我们是不能更新这几个点的，因为题目中的$(2,3)$不是"#"。会导致程序错误。

那我们怎样更新呢？我们可以从$i-1,j-1$的方向更新，这样是不会出问题的。

```cpp
	for(int i=n;i>0;i--){
		for(int j=m;j>0;j--){
			if(a[i][j]=='#'){
				a[i][j+1]='#';
				a[i+1][j]='#';
				a[i+1][j+1]='#';
			}
		}
	}
```

然后再输出就行了。

# 二、参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1005][1005];
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=n;i>0;i--){
		for(int j=m;j>0;j--){
			if(a[i][j]=='#'){
				a[i][j+1]='#';
				a[i+1][j]='#';
				a[i+1][j+1]='#';
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<a[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

# 三、尾声：

~~这部分看起来根本没用~~

这道题的满分是$50$，所以就会出现$Accepted 50$的情况······

感谢大家对我的支持，感谢您的浏览，希望能帮助到您，祝您早日犇犇。

					By  Indifferent

---

## 作者：yydfj (赞：8)

**这是本蒟蒻第五次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一幅 $n×m$ 大小的含有 ```#``` 和 ```.``` 的图，将 ```#``` 右边、下面和右下角的格子都改成 ```#``` 。

## 解法综述

其实这道题直接暴力就可以过了，但要注意一个点，**如果你让 ```#``` 右边、下面和右下角的格子都改成 ```#``` 的话，下一次遍历到你改过后的 ```#``` 又会再一次将它右边、下面和右下角的格子都改成 ```#``` 。** 以此类推，会发现当一个格子上出现 ```#``` 的时候，意味着它右边、下面和右下角将全部都是 ```#``` 。

如何避免上述的情况呢？我们可以用另外一个字符来充当被改过的 ```#``` ，比如 ```@``` 。

当发现 ```#``` 时，就分别判断它的右边、下面和右下角的格子是否有 ```#``` ，有就不管，没有则将该格子改为 ```@``` ，以此类推。到输出的时候就判断该格子是否为 ```#``` 或者 ```@``` ，是就输出 ```#``` ，不是则输出 ```.``` 。

## 代码描述
```cpp
#include<cstdio>
char s[1010][1010];
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++) scanf("%s",s[i]);
	for(int i=0;i<n;i++)
	for(int j=0;j<m;j++)
	if(s[i][j]=='#')
	{
		if(s[i+1][j]!='#') s[i+1][j]='*';//判断它的右边是否有 # ，有就不管，没有则将该格子改为 @
		if(s[i][j+1]!='#') s[i][j+1]='*';//判断它的下面是否有 # ，有就不管，没有则将该格子改为 @
		if(s[i+1][j+1]!='#') s[i+1][j+1]='*';//判断它的右下角是否有 # ，有就不管，没有则将该格子改为 @
	}
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)
		if(s[i][j]=='#'||s[i][j]=='@') printf("#");//判断该格子是否为 # 或者 @ ，是就输出 #
		else printf(".");//不是则输出 .
		printf("\n");
	}
	return 0;
}
```

---

## 作者：幼儿园第一名 (赞：4)

### 思路：
按照题意模拟。

由于有可能越界，所以我们行的边界为 $n-1$ ，列的边界为 $m-1$ 。

当 $c[i][j]$ 为井号时，我们将 $c[i+1][j]$ ， $c[i][j+1]$ 和 $c[i+1][j+1]$ 。

还有个细节，我们需要开另外一个数组存储原矩阵。更改时我们要更改**另外一个数组**，而并不是原矩阵，否则会出现重复判断重复修改的情况。

### Code:
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>

using namespace std;

const int N=1005;

char c[N][N],d[N][N];

int main() {
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cin>>c[i][j];
			d[i][j]=c[i][j];
		}
	}
	for(int i=1;i<n;i++) {
		for(int j=1;j<m;j++) {
			if(c[i][j]=='#') {
				d[i+1][j]='#';
				d[i][j+1]='#';
				d[i+1][j+1]='#';
			}
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cout<<d[i][j];
		}
		cout<<endl;
	}
}
```


---

## 作者：ZBAA_MKC (赞：4)

本题根据题目直接模拟即可。

注意有一个坑：只能把原来存在的 ```#``` 扩展，而不能将扩展后产生的新 ```#``` 继续扩展。所以我们要使用一个布尔类型的数组来存储某一个 ```#``` 是否在原信件中存在，如果存在才进行扩展。

下面贴代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

char c[1005][1005];
bool f[1005][1005];
int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
    	for (int j = 1; j <= m; j++)
    	{
    		cin >> c[i][j]; //读入
    		if (c[i][j] == '#')
    		{
    			f[i][j] = true; //标记'#'
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			if (f[i][j]) //扩展
			{
				c[i + 1][j] = '#';
				c[i + 1][j + 1] = '#';
				c[i][j + 1] = '#';
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			cout << c[i][j]; //输出
		}
		cout << endl; //别忘换行
	}
	return 0;
}
```



---

## 作者：Jorisy (赞：3)

**upd on 2022.4.2：**

修改了部分内容。

---

本蒟蒻第一次写题解，望管理员过。

---

这一题是一个纯粹模拟题。假设我们对处于 $[x,y]$ 的 `#` 进行“加粗”这个操作，那么加粗的地方则是 $[x][y+1],[x+1][y]$ 及 $[x+1][y+1]$ 。
部分代码：
```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=m;j++)
	{
		if(a[i][j]=='#')
		{
			a[i][j]=a[i+1][j]=a[i][j+1]=a[i+1][j+1]='#';
		}
	}
}
```
到这里，会有一个问题：**加粗后的地方会也会被看作将加粗的地方**，因此我们应在加一个数组决定是否为要处理的地方。
最后完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

char a[1005][1005],ans[1005][1005];

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			ans[i][j]=a[i][j];//先存进另一个数组
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]!='.') ans[i][j]=ans[i+1][j]=ans[i][j+1]=ans[i+1][j+1]='#';//在 a 数组是 # 的情况下在加粗
		}
	}
	//输出略
	return 0;
}

```

---

## 作者：封禁用户 (赞：2)

题目传送>>[P7550](https://www.luogu.com.cn/problem/P7550)  
AC 之后就着看是否有发题解的漏捡点开题解区瞟了一眼，大多现存题解都是在开 `char` 数组进行直接修改元素，有的还开了额外数组，当然了，为了标记开数组是应该的，这里给出一种不开 `char` 数组不直接修改元素，而只是借助普通数组标记而解决问题的不同做法。  
### 题意简述：  
- 给定一 $n$ 行 $m$ 列的仅由 `.` 和 `#` 组成的字符阵列，需对每一**原有**的 `#`进行向右下 $2×2$ 扩展 `#`。  
- $2 \leq n,m \leq 10^3$。  

### 题目分析：  
简单运用二维数组读入和输出，除此之外值得注意的是如果一个个扩展可能会出现原为 `.` 的地方被之前的扩展操作修改为了 `#` 而现在去判又对其进行扩展，最终致错。  
所以我们可以开一简单数组辅助标记，使得各元素原/现状态分明，然后判状态输出即可。  
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define endl '\n'   //宏定义endl换行
int n,m;   //定义阵列行数，列数
char ch;   //定义输入的每一元素
int a[1010][1010];
int main()
{
	//freopen("input.in","r",stdin);
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>ch;    //一个个输入元素
			if(ch=='#')
			{
				a[i][j]=1;   //辅助标记数组对应阵列位置标记表示为原为#
		    	a[i][j+1]=2,a[i+1][j]=2,a[i+1][j+1]=2;   //辅助标记数组对应阵列位置标记表示为经扩展操作变为#（其实标记为任何正整数均可）
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cout<<(a[i][j]? '#':'.');   //判状态输出阵列
		}
		cout<<endl;   //注意不要忘记阵列每行换行
	}
	return 0;
}
```
### 结果（未吸氧）：  
![JieGuo](https://cdn.luogu.com.cn/upload/image_hosting/wuzc562v.png)  
企鹅的题解到此结束，祝各位 OIers 进步 ++~

---

## 作者：sid_shi1 (赞：2)

题目：[P7550 [COCI2020-2021#6] Bold](https://www.luogu.com.cn/problem/P7550)

思路：

输入整个二维数组，从头到尾扫描一遍，将 `#` 号字符右边、下边、右下的字符也改为 `#` 号，由于最后要输出整个数组，重复修改没有关系。需要注意的是，题目要修改的是原数组中 `#` 号字符旁边的，而不是修改过的也要再修改，否则就一直延伸下去了。我们需要一个 $book$ 二维数组，标记数组中哪些 `#` 号是原来的，这些才需要修改，我们只需在输入时把 `#` 号的在 $book$ 中标记就行了。

还有一点，题目中说了保证最后一行与最后一列中没有 `#` 号，也就是说不需要修改时注意边界，~~这体现了出题人十分良心~~。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[1001][1001];
bool book[1001][1001]={0};
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("\n%c",&a[i][j]);
			if(a[i][j]=='#') book[i][j]=true;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(book[i][j]==true) a[i+1][j]=a[i][j+1]=a[i+1][j+1]='#';
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) printf("%c",a[i][j]);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：tZEROちゃん (赞：2)

### Description

> 给你一个由 $\tt \#$ 和 $\tt .$ 构成的 $n \times m$ 的矩阵，若 $a_{i,\ j}$ 为 $\tt \#$，那么你需要将 $a_{i,\ j\ +\ 1}$，$a_{i\ +\ 1,\ j}$，$a_{i\ +\ 1,\ j\ +\ 1}$ 替换为 $\tt \#$。

### Solution

按题意模拟即可。

使用两个二维数组，第一个用来读入，第二个用来操作。

通过两层循环，当 $a_{i, j} = \tt \#$ 时，将 $b_{i\ ,j}$，$b_{i,\ j\ +\ 1}$，$b_{i\ +\ 1,\ j}$，$b_{i\ +\ 1,\ j\ +\ 1}$ 全部改为 $\tt \#$，注意 $b$ 数组开始时全部赋值为 $\tt .$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
char a[100][100], b[100][100];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            b[i][j] = '.';
        }
    }

    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) { // 最后一列和最后一行不用处理 
            if (a[i][j] == '#') {
                b[i][j] = b[i][j + 1] = b[i + 1][j] = b[i + 1][j + 1] = '#';
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cout << b[i][j];
        }
        cout << endl;
    }

    return 0;
}

```

---

## 作者：Accteped (赞：1)

~~一道纯暴力水题~~
## 题意

题目想让我们把输入进来的信封中的 `#` 向右下方扩展为$2*2$的 `#`

## 思路

首先先看数据规模，不大也就 $2≤n,m≤10^3$ 

完全可以让我们进行暴力操作，但为了节省时间，我们还可以一边输入一边用一个字符数字进行记录并操作

若要这样做，就需要加一个判断来防止处理完的字符被覆盖，代码如下：

```cpp
			if(a[i][j]=='#'){
				ans[i][j]='#';
				ans[i+1][j]='#';
				ans[i][j+1]='#';
				ans[i+1][j+1]='#';
				//给该字符右下边2*2的位置赋值 
			}else if(ans[i][j]!='#'){
				ans[i][j]=a[i][j];//不覆盖已赋值的位置 
			}
```

上面就是核心代码，完整代码如下

## CODE
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
char a[1020][1020],ans[1020][1020];//ans存储答案 
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>a[i][j];
			if(a[i][j]=='#'){
				ans[i][j]='#';
				ans[i+1][j]='#';
				ans[i][j+1]='#';
				ans[i+1][j+1]='#';
				//给该字符右下边2*2的位置赋值 
			}else if(ans[i][j]!='#'){
				ans[i][j]=a[i][j];//不覆盖已赋值的位置 
			}
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cout<<ans[i][j];//输出即可 
		}
		cout<<endl;
	}
	return 0;
}
```


---


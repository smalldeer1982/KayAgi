# 饱食

## 题目描述

书虫背包里有 $n$ 只兔兔，第 $i$ 只兔兔被书虫编号为一个由大写字母组成的字符串 $S_i$。

书虫会 +C+，他用 +C+ 编写出了 `random` 函数，随机抽取出了三只兔兔。

不过书虫暂时得了神经性厌食症，书虫能吃下这三只兔兔当且仅当：

- 编号的首字母为 `M`，`C`，`O` 或 `I` 中的任意一个。
- 编号的首字母不能相同。

书虫想问有多少种选择方案使得他能吃下他选的的三只兔兔？

## 说明/提示

#### 样例 1 解释

有如下 $7$ 种选择方式：

- `MINE`，`CRAFT`，`OLYMPIAD`。
- `MINE`，`CRAFT`，`IN`。
- `MINE`，`CRAFT`，`INFORMATICS`。
- `MINE`，`OLYMPIAD`，`IN`。
- `MINE`，`OLYMPIAD`，`INFORMATICS`。
- `CRAFT`，`OLYMPIAD`，`IN`。
- `CRAFT`，`OLYMPIAD`，`INFORMATICS`。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$S_i$ 首字母均为 `M`。
- Subtask 2（30 pts）：$n \le 100$。
- Subtask 3（60 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le10^5$，$1 \le |S_i| \le 11$，$S_i$ 由大写字母组成。

数据不保证 $S_i$ 互不相同。

## 样例 #1

### 输入

```
5
MINE
CRAFT
OLYMPIAD
IN
INFORMATICS```

### 输出

```
7```

# 题解

## 作者：一只书虫仔 (赞：19)

#### Description

> 给定 $n$ 个字符串 $S_i$，定义一个字符串三元组 $(s_1,s_2,s_3)$ 是合法的当且仅当：
>
>- $s_1,s_2,s_3$ 的首字母是 `M`，`C`，`O` 和 `I` 中的一个。
>- $s_1,s_2,s_3$ 的首字母互不相同。
>
>求有多少组合法的字符串三元组。
>
>$1 \le n \le 10^5$，$1 \le |S_i| \le 11$。

#### Solution

Subtask 1：铃太强了，你需要输出 $0$。

Subtask 2：暴力枚举，$\mathcal O(n^3)$。

正解：暴力枚举 `M`，`C`，`O` 与 `I` 的个数，设其分别为 $m,c,o,i$，那么通过小学排列计数就可以知道答案可以分为四个部分：`MCO`，`MOI`，`MCI`，`COI`，将其组合而成即可：

$$m \times c \times o+m \times c \times i+m \times o \times i+c \times o \times i$$

这个是可以 $\mathcal O(n)$ 计算的。

---

## 作者：Unordered_OIer (赞：15)

# P7566 题解

划水玩家报道。

## Description

给定 $n$ 个字符串 $S_1 \sim S_n$，问有多少种方案使得选出的三个字符串 $S_i,S_j,S_k$ 满足：

- $i \neq j \neq k$。
- $S_i,S_j,S_k$ 的第一个字符 $c_i,c_j,c_k \in \{ \texttt{M,C,O,I}\}$ 且 $c_i \neq c_j \neq c_k$。

## Solution
我们知道，如果挑选出的 $S_i,S_j,S_k$ 符合要求，则第一个字符一定是 $\texttt{M,C,O,I}$ 的一个。换句话说，只有第一个字符是 $\texttt{M,C,O,I}$ 之一的字符串才有用。

所以考虑统计出所有字符串中第一个字符是 $\texttt{M,C,O,I}$ 之一的字符串个数，分别记为 $cM,cC,cO,cI$，分类讨论：

1. $\texttt{M,C,O}$，方案数为 $cM \times cC \times cO$
2. $\texttt{M,C,I}$，方案数为 $cM \times cC \times cI$
3. $\texttt{M,O,I}$，方案数为 $cM \times cO \times cI$
4. $\texttt{C,O,I}$，方案数为 $cC \times cO \times cI$

答案就是这些东西加起来。

复杂度 $\mathcal O(n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void write(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
inline void writeln(ll x){write(x),putchar('\n');}
ll n,cM,cC,cO,cI;
int main(){
	n=read();
	for(ll i=1;i<=n;i++){
		string st;
		cin>>st;
		if(st[0]=='M')cM++;
		else if(st[0]=='C')cC++;
		else if(st[0]=='O')cO++;
		else if(st[0]=='I')cI++;
	}
	ll ans=cM*cC*cO+cM*cC*cI+cM*cO*cI+cC*cO*cI;
	writeln(ans);
	return 0;
}
```

祝洛谷月赛越办越好！

---

## 作者：Cripple_Abyss (赞：10)

## [题目传送门](https://www.luogu.com.cn/problem/P7566)

## STEP 1 题目大意：
- 在所给的 $n$ 个字符串中选 $3$ 个字符串。

- 要求 1 ：`编号的首字母为 M，C，O 或 I 中的任意一个。`

- 要求 2 ：`编号的首字母不能相同。`

## STEP 2 解题思路：
- 一个简单的乘法原理题目。

- 所选字符串的 **首字母** 无非就 $4$ 种情况 ：

$ M\ C\ O\ \ \ \ \ $   $ M\ C\ I\ \ \ \ \ $ $ M\ O\ I\ \ \ \ \ $ $ C\ O\ I\ \ \ \ \ $

## STEP 3 题目解法：
- 分别统计 **首字母** 为 `M` `C` `O` `I`  字符串的个数，记为 $S_m ,\ S_c,\ S_o,\ S_i$。

- 最后的答案为 $S_m\times S_c\times S_o\times S_i$ 。

## STEP 4 Code ：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std; 
typedef long long ll;
inline void in(ll &x) {
	x=0;
	ll f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=f;
}
inline void out(ll x) {
	if (x<0) putchar('-'),x=-x;
	if (x>9) out(x/10);
	putchar(x%10+'0');
}
char s;
ll n,a[15];
int main() {
	in(n);
//	getchar();
	while (n--) {
		s=getchar();
		if (s=='M') a[1]++;
		if (s=='C') a[2]++;
		if (s=='O') a[3]++;
		if (s=='I') a[4]++;
		while (s!='\n') s=getchar();
	}
	out(a[1]*a[2]*a[3]+a[1]*a[2]*a[4]+a[1]*a[3]*a[4]+a[2]*a[3]*a[4]);
	return 0;
}

```

都看到这里了，点个赞再走呗 QwQ

---

## 作者：Kalium (赞：9)

# P7566 「MCOI-05」饱食题解

## 前言：

开了freopen，文件名是歌名，有兴趣的听听。

## 题意：

求有多少个不同的符合条件的4个字母的3个排列，每个排列的字母都不同。

## 思路：

小学奥数，我来推导一波。

我们先不管要不同的这一项，那么是不是将每个符合条件的字母个数统计后相乘即可。

现在我们要每个排列中字母不同。

那么我们可以这样：

设符合条件字母个数为s1，s2，s3，s4。

那么我们设s1 = 2，s2 = 1，s3 = 4，s4 = 1.

则会有如下排列：

||||
| -----------: | -----------: | -----------: |
| s1 | s2 | s3 |
| s1 | s2 | s3 |
| s1 | s2 | s3 |
| s1 | s2 | s3 |
| s1 | s2 | s3 |
| s1 | s2 | s3 |
| s1 | s2 | s3 |
| s1 | s2 | s3 |

恰好8次。

这个数字很奇妙啊，我们发现 $s1 * s2 *s3 = 8$。

那么我们只要算这四个数字有可能的排列，再乘以他们的系数即可。

他们可能的排列如下：

||||
| -----------: | -----------: | -----------: |
| s1 | s2 | s3 |
| s1 | s2 | s4 |
| s1 | s3 | s4 |
| s2 | s3 | s4 |

那么整个柿子就是：

$s1 * s2 * s3 + s1 * s2 * s4 + s1 * s3 * s4 + s2 * s3 * s4$。

相信大家都会提公因式吧：

$s1 * s4 * (s2 + s3) + s2 * s3 * (s1 + s4)$。

## 细节：

开long long。

## 代码：

```cpp
#include <cstdio>
#define ll long long

using namespace std;

int n;

char s[17];

ll s1, s2, s3, s4;

int main() {
	scanf("%d", &n);
	
	for (int i = 1; i <= n; i ++) {
		scanf("%s", s + 1);
		
		if (s[1] == 'M') s1 ++;
		if (s[1] == 'C') s2 ++;
		if (s[1] == 'O') s3 ++;
		if (s[1] == 'I') s4 ++;
	}
	
	printf("%lld\n", s1 * s4 * (s2 + s3) + s2 * s3 * (s1 + s4));
	
	return 0; 
} 
```

$Atlantic.$

---

## 作者：FuriousC (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P7566)

输入的时候统计一下 `M`，`C`，`O`，`I` 的个数，然后分$4$种情况讨论

- `M`，`C`，`O`

- `M`，`C`，`I`

- `M`，`O`，`I`

- `C`，`O`，`I`

对于每种情况，把以这三个字符为首的字符串的个数相乘即可

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string str;
int main(){
	scanf("%d",&n);
	long long cntm=0,cntc=0,cnto=0,cnti=0;//分别记录以m,c,o,i为首的字符串个数
	for(int i=1;i<=n;i++){
		cin>>str;
		if(str[0]=='M'){
			cntm++;
		}else if(str[0]=='C'){
			cntc++;
		}else if(str[0]=='O'){
			cnto++;
		}else if(str[0]=='I'){
			cnti++;
		}
	}
	printf("%lld",cnto*cntm*cntc+cnti*cntm*cntc+cnti*cntm*cnto+cnto*cntc*cnti);//相乘后输出
	return 0;
}
```


---

## 作者：zmza (赞：2)

这道题是一道简单的排列组合题。

因为我们知道一共选三只兔子，每只兔子的首字母不同，所以我们可以直接算。

设`M`，`C`，`O`，`I`的个数分别为$a_1$，$a_2$，$a_3$，$a_4$,则答案为

$a_1*a_2*a_3+a_1*a_2*_4+a_1*a_3*a_4+a_2*a_3*a_4$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int i = 0, f = 1;
	char ch;
	for (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
	if (ch == '-')
	{
		f = -1;
		ch = getchar();
	}
	for (; ch >= '0' && ch <= '9'; ch = getchar())
	{
		i = (i << 3) + (i << 1) + (ch ^ 48);
	}
	return i * f;
}
void write(int a, char b = ' ')
{
	if (a < 0)
	{
		putchar('-');
		a = -a;
	}
	if (a == 0)
	{
		putchar('0');
		putchar(b);
		return;
	}
	int sta[100] = {}, cnt = 0;
	while (a)
	{
		cnt++;
		sta[cnt] = a % 10;
		a /= 10;
	}
	while (cnt)
	{
		putchar(sta[cnt] + '0');
		cnt--;
	}
	putchar(b);
}
signed main()
{
	int n = read(), a1 = 0, a2 = 0, a3 = 0, a4 = 0;
	for (int i = 1; i <= n; i++)
	{
		char a[15];
		scanf("%s", a + 1);
		if (a[1] == 'M') a1++;
		else if (a[1] == 'C') a2++;
		else if (a[1] == 'O') a3++;
		else if (a[1] == 'I') a4++;
	}
	printf("%lld", a1 * a2 * a3 + a1 * a2 * a4 + a1 * a3 * a4 + a2 * a3 * a4);
	return 0;
}
```

---

## 作者：syf2008 (赞：1)

这是一道~~水~~题

题目大意：

书虫背包里有n只兔兔，第i只兔兔被书虫编号为一个由大写字母组成的字符串$S_i$

编号的首字母为M,C,O,I中的任意一个且编号的首字母不能相同。

书虫想问有多少种选择方案使得他能吃下他选的的**三只兔兔**？

那么就
MCO MCI MOI COI四种情况

上代码：
```
#include <bits/stdc++.h>
using namespace std;
string a;
long long n,b[10];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		if(a[0]=='M')
		b[1]++;
		if(a[0]=='C')
		b[2]++;
		if(a[0]=='O')
		b[3]++;
		if(a[0]=='I')
		b[4]++;
	}
	cout<<b[1]*b[2]*b[3]+b[1]*b[2]*b[4]+b[1]*b[3]*b[4]+b[2]*b[3]*b[4]<<endl;
}
```

---

## 作者：joy2010WonderMaker (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7566)。

### 题目分析

这是一道数学题，本质意思是将那四个字母出现的次数，每次任选三个，将三个数相乘，最后将四组数加起来。下面这四组的个数就是要加起来的四组数。

+ `M`的个数$\times$`C`的个数$\times$`O`的个数。

+ `M`的个数$\times$`C`的个数$\times$`I`的个数。

+ `M`的个数$\times$`O`的个数$\times$`I`的个数。

+ `C`的个数$\times$`O`的个数$\times$`I`的个数。

### 代码

```cpp
#include<cstdio>
long long mp,cp,op,ip;/／统计个数
int main(){
    long long n;
    scanf("%lld",&n);
    while(n--){
        char s[15];
        gets(s);
        if(s[0]=='M'){//判断是什么
            mp++;
        }else if(s[0]=='C'){
            cp++;
        }else if(s[0]=='O'){
            op++;
        }else if(s[0]=='I'){
            ip++;
        }
    }
    printf("%lld",mp*cp*op+mp*cp*ip+mp*op*ip+cp*op*ip);//全部加起来
    return 0;
}
```

---

## 作者：Kacho (赞：1)

签到题，但是还是由于第一次没看数据范围： $1 \le n \le 10 ^ 5$ ， $1 \le |Si| \le 11 $，然后没开longlong，挂掉了……

好蠢（（（

## 题意
给出 $n$ 个字符串 $s$ ，字符串以大写字符组成，我们呢，把字符串叫做兔兔。

书虫会吃兔兔，但是书虫只吃以M， C， O， I这四个字符开头的兔兔，并且，一次随机吃三只，每只兔兔的开头首字符不能相同。

## Solution
首先，第一个蹦进你的脑子的想法是不是直接输出 0 呢？

那么这个想法有几分，[看这里](https://www.luogu.com.cn/record/50243499)。

那么我们继续暴力枚举，鉴于这种数据范围：$1 \le n \le 10 ^ 5$ ， $1 \le |Si| \le 11 $ 。很显然，复杂度一定是 $O(n ^ 3)$ 了趴，那么就是TLE等着你了。

考虑正解，可以给出一个 Sample 进行分析，例如：
```cpp
10
MC
MH
CF
CL
CO
OV
OE
IC
IY
IX
```
当然，我就不给出有首字母非M， C， O， I 的 Sample 了，毕竟如果有不在“食谱”上的字符串，当然是选择不管它了。

显然，我们可以发现对于第一个字符串“MC”，它一共就可以有 $1 \times 3 \times 2 + 1 \times 3 \times 3 + 1 \times 2 \times 3 = 21$ 这么多的匹配方式，也就是说，“MC” $\rightarrow$ “C…” “O…” $+$ “MC” $\to$ “C…” “I…” $+$ “MC” $\to$ “O…” “I…” 这样子的匹配策略，那么以此类推，我们可以得出一个结论：
```cpp
//以a，b，c，d，分别记录以M，C，O，I开头的字符串的个数
ans = a * b *c + a * c *d + b * c * d + a * b *d;
printf("%lld\n", ans);
```

OK，那这个就是一个组合的问题了，为什么是组合不是排列呢？因为这个问题，它对于重复性是有要求的，所以不能用排列来看待这个问题。

所以得到了这个代码，A掉了。

最后上一下AC的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

long long a, b, c, d;
long long ans, n;

int main (){
	
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++){
		string s;
		cin >> s;
		if(s[0] == 'M') a++;
		if(s[0] == 'C') b++;
		if(s[0] == 'O') c++;
		if(s[0] == 'I') d++;
	}
	
	ans = a * b *c + a * c *d + b * c * d + a * b *d;
	printf("%lld\n", ans);
	
	return 0;

}
```

---

## 作者：_caiji_ (赞：1)

前置知识：乘法原理
>做一件事，完成它需要分成 $n$ 个步骤，做第一步有 $m_1$ 种不同的方法，做第二步有 $m_2$ 种不同的方法，……，做第 $n$ 步有 $m_n$ 种不同的方法，那么完成这件事共有 $m_1\times m_2\times m_3\times\cdots\times m_n$ 种不同的方法。

我们记 $a_{ch}$ 表示以 $ch$ 这个字符开头的兔兔的名字的数量，根据上面说的乘法原理，答案即为 

$$
\begin{aligned}
	ans&=a_{\texttt{C}}\times a_{\texttt{O}}\times a_{\texttt{I}} \\
    &+a_{\texttt{M}}\times a_{\texttt{O}}\times a_{\texttt{I}} \\
    &+a_{\texttt{M}}\times a_{\texttt{C}}\times a_{\texttt{I}} \\
    &+a_{\texttt{M}}\times a_{\texttt{C}}\times a_{\texttt{O}} 
\end{aligned}
$$

总复杂度 $O(n)$，注意开 `long long`。

代码：
```cpp
#include <cstdio>
using namespace std;
long long a[128],ans;//128 是因为 char 的范围是 -128~127
char ipt[110];
int n;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",ipt);
        a[ipt[0]]++;
    }
    ans+=a['C']*a['O']*a['I'];
    ans+=a['M']*a['O']*a['I'];
    ans+=a['M']*a['C']*a['I'];
    ans+=a['M']*a['C']*a['O'];
    //C++ 可以用字符当数组下标，它会自动转换成数字
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：InformationEntropy (赞：1)

题意：给定 $n$ 个字符串，从中选择 3 个，这 3 个字符串需满足：

- 首字母不相同
- 首字母为 M，C，O，I 中其一

求方案数。

首字母不相同，则有 M，C，O；M，C，I；M，O，I；C，O，I 四种组合，由于 M，C，O，I 的数量不唯一，根据乘法原理，对于每一种情况将每个字母的出现的次数相乘，再将四种情况的结果相加，即为答案。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
ull a[5];//n<=10^5,会爆int的哦
int main()
{
    int n;
    read(n);
    string s;
    for(int i=1; i<=n; i++)
    {
        cin >> s;
        if(s[0]=='M')
        {
            a[0]++;
        }else if(s[0]=='C'){
            a[1]++;
        }else if(s[0]=='O'){
            a[2]++;
        }else if(s[0]=='I'){
            a[3]++;
        }//统计每个字母出现的次数
    }
    ull sum=0;
    sum=a[0]*a[1]*a[2]+a[0]*a[1]*a[3]+a[0]*a[2]*a[3]+a[1]*a[2]*a[3];//四种情况，先相乘再相加
    cout << sum;
    return 0;
}
```



---

## 作者：_SkyBlue (赞：0)

需要满足的条件为

- 编号的首字母为 $\texttt{M}$，$\texttt{C}$，$\texttt{O}$ 或 $\texttt{I}$ 中的任意一个。
- 编号的首字母不能相同。

我们将所有的字符串分为 $5$ 类，首字母为 $\texttt{M}$，$\texttt{C}$，$\texttt{O}$，$\texttt{I}$，另外的。

分别开一个变量来计数前四类，分别记为 $a$，$b$，$c$，$d$。有加乘原理，答案为四种字母中选三种，分别为 $\texttt{MCO}$，$\texttt{MCI}$，$\texttt{COI}$，$\texttt{MOI}$。

所以答案为 $\sum abc$。

```cpp
int main() {
  string s;long long n;cin>>n;
  long long m=0,c=0,o=0,i=0;
  while(n--){cin>>s;if(s[0]=='M')m++;if(s[0]=='C')c++;if(s[0]=='O')o++;if(s[0]=='I')i++;}
  cout<<m*c*o+m*c*i+c*o*i+m*o*i<<endl;
}
```

---

## 作者：银杉水杉秃杉 (赞：0)

简单小红题，话不多说，直接上代码（码中有注释）

```cpp
#include<bits/stdc++.h>
#define ll long long //不开long long见祖宗
using namespace std;
int n;
ll a[5],ans;
char s[15];
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%s",s);
		if (s[0]=='M')
			a[1]++;
		else if (s[0]=='C')
			a[2]++;
		else if (s[0]=='O')
			a[3]++;
		else if (s[0]=='I')
			a[4]++;
	}
	ans=a[1]*a[2]*a[3]+a[1]*a[2]*a[4]+a[1]*a[3]*a[4]+a[2]*a[3]*a[4];//经典排列组合
	printf("%lld\n",ans);
	return 0;
}
```



---


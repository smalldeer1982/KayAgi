# 「EZEC-8」凑数

## 题目描述

给定 $1$ 到 $n$ 这 $n$ 个正整数，请问能否恰好选择 $k$ 个数，使选中的数之和为 $s$（每个数只能用 $1$ 次）。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（15 points）：$n\le5$。
-  Subtask 2（15 points）：$n\le15$。
-  Subtask 3（20 points）：$n\le100$。
-  Subtask 4（15 points）：$k=1$。
-  Subtask 5（15 points）：$s\le15$。
-  Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le10^3$，$1\le k\le n\le10^9$，$1\le s\le10^{18}$。

## 样例 #1

### 输入

```
3
5 2 10
5 2 5
5 2 2```

### 输出

```
No
Yes
No```

# 题解

## 作者：EuphoricStar (赞：39)

## 思路

一道简单的数论（？

考虑和最小的情况：选择 $1$ 到 $k$ 之间的所有整数，将这个和记为 $a$。

接下来考虑和最大的情况：选择 $n - k + 1$ 到 $k$ 之间的所有整数，将这个和记为 $b$。

那么在 $1$ 到 $n$ 之间选择 $k$ 个整数，它们的和的上界是 $b$，下界是 $a$。

可以这样理解：

当 $n = 5,k = 3$ 时，选出的数的集合如下：

$\{1,2,3\}$ 此时和为 $6$。

接下来让最大的数增加 $1$，变成 $\{1,2,4\}$，此时和为 $7$。

再让最大的数增加 $1$，变成 $\{1,2,5\}$，此时和为 $8$。

此时最大的数已经无法增加了，那我们让次大的数增加 $1$，此时集合为 $\{1,3,5\}$，和为 $9$。

......

一直这样下去，可以发现在 $[a,b]$ 区间内的整数都可以用在 $[1,n]$ 区间内的不同的 $k$ 个整数的和表示。

接下来就好办了。如果 $s \ge a$ 且 $s \le b$，那么输出 `Yes`，否则输出 `No`。

坑点：

- 开 `long long`
- 没了

求 $\sum\limits_{i=a}^{b}i$ 可以用等差数列公式：$\dfrac{(a + b) \times (b - a + 1)}{2}$

## 代码

```cpp
        if (k * (k + 1) / 2 > s || (n + n - k + 1) * k / 2 < s) {
            puts("No");
        } else {
            puts("Yes");
        }
```


---

## 作者：BurningEnderDragon (赞：21)

[题目链接：P7593 凑数](https://www.luogu.com.cn/problem/P7593)

**前排提示：结论与代码在最后**

### 暴力

考虑最暴力的做法，直接枚举从 $1$ ~ $n$ 中选取 $k$ 个数的所有可能的情况，并判断这 $k$ 个数的和是否等于 $s$。

具体选择方式为选取一个序列 $\left\{ x_{1},x_{2},x_{3},\cdots,x_{k} \right\}$，并使 $\forall i,j \in [1,k]$ 且 $i<j$，有 $1 \le x_{i}<x_{j} \le n$。

使用深搜实现枚举过程：（然而这比正解还麻烦）

```cpp
#include <cstdio>

typedef long long ll;

ll T,n,k,s;

ll sum=0;//存储每次加出的和 

bool end=0;//在递归函数中判断当前数据组是否已经得出结果 

void Choose(ll min_x,ll now,ll total)//min_i表示本次选择的数的最小值，now表示现在选择到第几个数，total表示总共需要选择几个数 
{
	for(ll i=min_x;i<=n-total+now;++i)//显然枚举的左端点为min_x，右端点为n-total+now 
	{
		sum+=i;
		if(end)//如果发现已经得出结果则立即返回 
		{
			return ;
		}
		else if(now==total)
		{
			if(sum==s)//如果加出的和等于s则标记已经得出结果，并结束该数据组的计算 
			{
				end=1;
				return ;
			}
		}
		else
		{
			Choose(min_x+1,now+1,total);
		}
		sum-=i;
	}
}

int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld%lld",&n,&k,&s);
		end=sum=0;//初始化 
		Choose(1,1,k);
		if(end)//若已经发现了符合要求的答案则输出"Yes" 
		{
			puts("Yes");
		}
		else//若枚举完成后仍没有发现符合要求的答案则输出"No" 
		{
			puts("No");
		}
	}
	return 0; 
}
```

由于在 $n$ 个数中选取 $k$ 个数的组合总数为 $\dbinom{n}{k} = \dfrac{n!}{k!(n-k)!}$，而每次选取的时间复杂度为 $O(k)$，故该算法的最坏时间复杂度为 $O \left(T \times \dfrac{n!}{(k-1)!(n-k)!} \right)$，实际只能通过 Subtask 1，得分 $15$ 分。

---

### 正解

这道题的正解当然是简单的数论。容易发现，在 $1$ 到 $n$ 这 $n$ 个正整数之间选择 $k$ 个数，它们的和的最小值为：
$$
\sum_{i=1}^{k}{i}
$$
而最大值为：
$$
\sum_{i=n-k+1}^{n}{i}
$$

根据等差数列求和公式，有：
$$
\sum_{i=1}^{k}{i} = \frac{k^{2}+k}{2}
$$

$$
\sum_{i=n-k+1}^{n}{i} = \frac{-k^{2}+(2n+1)k}{2}
$$

而 $\forall s \in \left[ \dfrac{k^{2}+k}{2},\dfrac{-k^{2}+(2n+1)k}{2} \right]$，都存在至少一个符合要求的序列 $\left\{ x_{1},x_{2},x_{3},\cdots,x_{k} \right\}$，使得：
$$
\sum_{i=1}^{k}{x_{i}} = s
$$
下面给出证明：

> 定义：
> $$ sum = \sum_{i=1}^{k}{x_{i}} $$
> 首先令 $sum = \dfrac{k^{2}+k}{2}$，根据上述条件，序列 $\left\{ x_{1},x_{2},x_{3},\cdots,x_{k} \right\}$ 中任意一个 $x_{i}$ 的值都为它能取到的最小值 $i$。
>
> 此时令 $x_{k}$ 的值增加 $1$，则 $sum$ 的值也增加 $1$。不断执行该操作直到 $x_{k}$ 的值为它能取到的最大值 $n$，此时 $x_{k}$ 的值不能再被增加，所以下一步增加 $x_{k-1}$ 的值，以此类推。
>
> 当 $x_{1}$ 的值也为它能取到的最大值 $n-k+1$ 时，所有的 $x_{i}$ 都取到了它们能取到的最大值，即 $\forall x_{i \in [1,k]},x_{i}=n-k+i$，此时 $sum$ 的值也为它能取到的最大值 $\dfrac{-k^{2}+(2n+1)k}{2}$。
>
> 因为每次只让序列中一个数的值增加 $1$，所以每次 $sum$ 的值也只增加 $1$，所以 $sum$  可以取到 $\left[ \dfrac{k^{2}+k}{2},\dfrac{-k^{2}+(2n+1)k}{2} \right]$ 中的任意值。
>
> 根据定义，上述命题成立。

对于这道题，我们只需判断 $s$ 是否属于 $\left[ \dfrac{k^{2}+k}{2},\dfrac{-k^{2}+(2n+1)k}{2} \right]$ 即可。

**请注意题目的数据范围，至少需要使用** `long long` **数据类型才能通过。**

完整AC代码如下：

```cpp
#include <cstdio>

int T;

long long n,k,s,minSum,maxSum;

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%lld%lld%lld",&n,&k,&s);
		minSum=(k*k+k)/2;
		maxSum=(-(k*k)+(2*n+1)*k)/2; 
		if(s>=minSum&&s<=maxSum)
		{
			puts("Yes");
		}
		else
		{
			puts("No");
		}
	}
	return 0;
}
```



---

## 作者：Terraria (赞：10)

~~考场上猜的结论，结果真对了。~~

考虑在 $1 \sim n$ 中选 $k$ 个数：

- 最小值 $a=\dfrac{k\times (1+k)}{2}$；

- 最大值 $b=\dfrac{k \times((n-k+1)+n)}{2}$。

这两个东西用等差数列一下就搞出来了。

然后我们就要开始猜结论了：$a \leq s \leq b$ 时有解，否则无解。

可以这么理解：

1. 在取到最小值时，一定是选择了 $1 \sim k$ 的数；

2. 若想要得到 $a+1$：

> - $k < n$ 时，可以使这个数列变为 $1 \sim k-1$ 和 $k+1$。

> - $k=n$ 时，可以使原数列的数 $k-1$ 变为 $k$，即原数列为 $1 \sim k-2$ 和 $2 \times k$。

依此类推，可以得到 $a+2,a+3,\cdots b$ 时的取数方案。

当然，要记得开 $\text{long long}$！

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,k,s;
signed main(){
	cin>>T;
	while(T--){
		cin>>n>>k>>s;
		if(s>=(1+k)*k/2&&s<=((n-k+1)+n)*k/2) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
}
```


---

## 作者：pocafup (赞：6)

经典开头废话

- $n \le 5$

暴力枚举全排列，判断和是否为 s 即可。

复杂度 $O(Tn!)$

- $n \le 15$ 

考虑状压dp:

$dp[i]$ 表示当前已经取了的数字集合为 i，和为 $dp[i]$

转移：$dp[i+(1<<j)] = dp[i]+j$   需要保证 ```(!(i>>j)&1)```
复杂度 $O(Tn2^n)$

- $n \le 100$

最大能够取得的数就是 $[1,n]$ 全部取了，为 $\dfrac{(1+100) \times 100}{2} = 5050$，可以认为是 $O(n^2)$ 级别的，考虑使用背包求解。

$dp[i][j]$ 表示使用 $j$ 个数字是否能够取得数字 i，转移为：

```if (dp[i][j]) dp[i+k][j+1] = true```

由于是多测，我们需要离线询问并按照 $n$ 从小到大排序。
复杂度 $O(n^3 + Tlogn)$

- $k=1$

等价于在 $n$ 个数里选出一个数跟 $s$ 相等，直接判断 $n,s$ 大小关系即可。

复杂度 $O(T)$

- $s=15$

inf 种方法乱搞，这里不讲。

- 无特殊限制

结论：若 $ \dfrac{k\times(k+1)}{2} \le s \le \dfrac{(2\times n-k+1)\times k}{2}$，则必然能凑出，否则必然不行。

证明：

首先如果全部用最小值凑出来还比 $s$ 大，那必然凑不出。同理如果全部用最大值凑也凑不出，那么必然也凑不出。

考虑 $s$ 在这个范围内能够怎么凑。

首先我们先将最小值凑出。最小值必然是 $(1,2,3...,k)$ 的形式。

考虑不断这个集合的最大值加一直到集合为 $(1,2,3...n)$ 的形式，可以证明这个区间的每一个数字都可以被取到。

这时我们注意到，我们仍然可以对次大值进行相同的操作。

这个集合不能操作当且仅当他是 $(n-k+1,n-k+2,...+n)$ 的形式。可以证明这两个集合之间的每一种和值都能被取到。故结论得证。

对于每组询问直接套公式即可，复杂度 $O(T)$

---

## 作者：Eason_AC (赞：4)

## Content
给定 $n$ 个整数 $1,2,\dots,n$，请问是否能从这 $n$ 个数中恰好选 $k$ 个数，使得这 $k$ 个数的和为 $s$。

**数据范围：$t$ 组数据，$1\leqslant t\leqslant 10^3$，$1\leqslant k\leqslant n\leqslant 10^9$，$1\leqslant s\leqslant 10^{18}$。**
## Solution
我们都知道，从 $1$ 到 $n$ 中选出 $k$ 个数，最小和是 $1\sim k$ 的和，最大和是 $n-k+1\sim n$ 的和，而在此之间的所有的整数和都能够通过最小和和最大和当中的某些数进行加减得到，比如说 $1\sim 5$ 中选出 $3$ 个数，最小和是 $6$，最大和是 $12$，那么可以构造出如下的整数和的方案：

- 选出的数的集合为 $\{1,2,3\}$，总和为 $6$。
- 选出的数的集合为 $\{1,2,4\}$，总和为 $7$。
- 选出的数的集合为 $\{1,2,5\}$，总和为 $8$。
- 选出的数的集合为 $\{1,3,5\}$，总和为 $9$。
- 选出的数的集合为 $\{1,4,5\}$，总和为 $10$。
- 选出的数的集合为 $\{2,4,5\}$，总和为 $11$。
- 选出的数的集合为 $\{3,4,5\}$，总和为 $12$。

其实这也给出了一种构造出从 $1$ 到 $n$ 中选出 $k$ 个数和为 $s$ 的一种方案：

- 首先，先选出 $1\sim k$。
- 然后，从最后一个数（第 $k$ 个数）开始往前推，如果当前到了第 $i$ 个数，直接加到 $n-k+i$，再根据是否超过了 $s$ 进行判断。如果当前和 $\geqslant s$，那么将当前数减回去到刚好使和等于 $s$，否则继续往前推。
- 依此下去，就能够构造出一种满足题目要求的方案。

因此我们先算出 $s_{\min}=\sum\limits_{i=1}^k i=\dfrac{k(k+1)}2$ 和 $s_{\max}=\sum\limits_{i=1}^kn-k+i=\dfrac{(2n-k+1)k}2$，然后再拿 $s_{\min},s_{\max}$ 与 $s$ 进行比较。如果 $s_{\min}\leqslant s\leqslant s_{\max}$，那么显然能够恰好选出和为 $s$ 的 $k$ 个数，否则就不行。
## Code
```cpp
int main() {
	MT {
		ll n = Rll, k = Rll, s = Rll;
		((2 * n - k + 1) * k / 2 < s || (1 + k) * k / 2 > s) ? No : Yes;
	}
    return 0;
}
```

---

## 作者：int127 (赞：4)

### 结论

容易猜得：当 $\dfrac{k(k+1)}{2}\le s\le \dfrac{k(2n-k+1)}{2}$ 时，输出 `Yes`。

### 分析

选数的集合中共 $k$ 个元素，和最小为 $a=\dfrac{k(k+1)}{2}$（即选 $\{1,2,\cdots,k\}$ ），最大为 $b=\dfrac{k(2n-k+1)}{2}$（即选 $\{n-k+1,n-k+2,\cdots,n\}$）。

要凑齐这 $[a,b]$ 之间的所有数，需要每次将最大数 $+1$，可表示的数也多了一个（如选数集合为 $\{1,2,\cdots,k+3\}$ ，和为 $a+3$ ），最大数达到 $n$ 加次大数，以此类推 $\cdots$。

### 代码

~~我知道你们关心的是这个。~~

提示：使用公式计算避免 `TLE`，要开 `long long` ！

```cpp
signed main(){
	read(kase);
	while(kase--){
		read(n),read(k),read(s);
		int prefix=k*(k+1)/2;                //min
		int suffix=k*(2*n-k+1)/2;            //max
		if(s>=prefix&&s<=suffix) puts("Yes");//行
		else puts("No");                     //不行
	}
	return 0;
}
```

---

## 作者：Karl_Aurora (赞：3)

**[~~无耻地推销个人博客qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7593)**

**[题目传送门](https://www.luogu.com.cn/problem/P7593)**

------------

## 题意

给定三个正整数 $ n , k , s $ ，求能否从 $ [ 1, n ] $ 中挑选 $ k $个数，使其和为 $ s $


## 解法

易证得 $ s_{min} = \sum\limits_{i = 1}^{k} i = \frac{k(k + 1)}{2} , s_{max} = \sum\limits_{i = n - k + 1}^{n} i = \frac{k(n + (n - k + 1))}{2} $

而对于 $ ( s_{min} , s_{max} ) $ 中的每一个数，均可以通过对上两种初始选法中不断每次选择一个元素 $ + / - 1 $得到

因此，我们便可得出结论——

> 当且仅当 $ \frac{k(k + 1)}{2} \leq s \leq \frac{k(n + (n - k + 1))}{2} $ 时，题目有解

ps：其实我们完全可以在 $ O ( k ) $ 的时间复杂度里构造并同时输出一组可行解，做法这里不再赘述，大家可以思考一下

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, k, s;
int T;
int main()
{
    cin >> T;
    for (register int i = 1; i <= T; ++i)
    {
        cin >> n >> k >> s;
        cout << ((k * (k + 1) / 2 <= s && k * (n + n - k + 1) / 2 >= s) ? "Yes" : "No") << endl;
        //如果s在k * (k + 1) / 2 与 k * (n + n - k + 1) / 2之间，则必定有解
    }
    return 0;
}
```

至此，愉快AC，完结撒花0v0

---

## 作者：Nygglatho (赞：3)


显然，$s$ 比选出来的数字中，加起来是**最小**的和的方案还要小，那么**一定**不行。

反之，$s$ 比选出来的数字中，加起来是**最大**的和的方案还要大，那么也**一定**不行。

否则，我们可以使用**最小**的方案，如果比 $s$ 小，那么我们就把最后的数字增加 $1$，如果已经无法继续增加了，那么就把那一位前面增加 $1$。这样一直重复下去，就可以使和得到 $s$ 了。

那么，如何判断呢？

显然，每一次最小的和为 $1 + 2 + 3 + \cdots + k = \dfrac{(1 + k) \times k}{2})$。即选前几个。而最大的和为 $k + (k + 1) + (k + 2) + \cdots + n = \dfrac{(n - k + 1 + n) \times k}{2}$，即选最后几个。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, k, s;
int main() {
	int T;
	cin >> T;
	while(T--) {
		cin >> n >> k >> s;
		if (k > n) puts("No"); 
		else if (((1 + k) * k / 2) <= s && ((n - k + 1 + n) * k / 2) >= s) puts("Yes");
		else puts("No");
	}
}
```

---

## 作者：Cripple_Abyss (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P7593)

## Description

- 在 $1 \sim n$ 的 $n$ 个自然数中选取 $k$ 个数 。

- 使得所选的数的和为 $s$ 。

## Solution

- 将目前所选数的和记为 $ts$ 。

- 若有解，一定满足条件 $min_{ts} \le s \le max_{ts}$。

- 即：在 $min_{ts}$ 与 $max_{ts}$ 之间的任何整数一定能被表示出来（若值大了可以不断调小某一个数，若值小了也可以不断调大某一个数）。

- 反之，若 $s < min_{ts}$ 或 $s>max_{ts}$ 一定无解。

- 其中，$min_{ts}= \sum\limits_{i=1}^ki$ , $max_{ts}=\sum\limits_{i=n-k+1}^ni$

- 不难想到 $min_{ts}$ 与 $max_{ts}$ 的值可以借助等差数列求和公式求出。

- $min_{ts}= \dfrac{(1+k)\times k}{2} \ \ \ \ \max_{ts}= \dfrac{(n-k+1+n)\times k}{2} $

## Code
```cpp
#include <cstdio>
typedef long long ll;
inline void in(ll &x) {
	x=0;
	ll f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=f;
}
inline void out(ll x) {
	if (x<0) putchar('-'),x=-x;
	if (x>9) out(x/10);
	putchar(x%10+'0');
}
ll T,n,k,s; //十年OI一场空，不开long long见祖宗
int main() {
	in(T);
	while (T--) {
		in(n),in(k),in(s);
		register ll s1=(1+k)*k/2,s2=(n-k+1+n)*k/2;
		if (s<s1||s>s2) puts("No");
		else puts("Yes");
	}
	return 0;
}

```

---

## 作者：品小呈 (赞：1)

洛谷5月小月赛A题，代码难度较低，认真思考想出正解问题不大，所以，这篇题解主要分享一下做题的思路过程。
## 暴力 DFS - 0~45pts
开题时状态极差，只想到暴力枚举，便写了枚举 $k$ 个数相加的 DFS。核心函数如下：
```cpp
ans=false;
void dfs(int now,int sum,int count)
{
	if(sum>s)
		return;
	if(count==k)
	{
		if(sum==s)
			ans=true;
		return;
	}
	for(int i=now+1;i<=n;i++)
	{
		dfs(i,sum+i,count+1);
	}
}
```
提交后成功15pts。注意到数据范围较大，把 `int` 改为 `long long` 后即可拿到45pts。但是因为 DFS 按从小到大遍历了整个数列，时间复杂度为 $O(n^2)$ ，且内存占用因递归调用消耗栈空间，也会大得离谱。不论再怎么剪枝、优化也会 MLE、TLE。

其实现在做出答案却没拿全分并不是一件坏事，除了得到少量分数，关键是得到了一个可靠的输出正解的程序，之后想出其他新算法时就可与这一版程序[对拍](https://www.luogu.com.cn/discuss/show/50758)验证正确性。

## 公式法 - 100pts 12ms
这一方法个人水平有限不是直接推导得出而是观察样例得到的。重点观察输出 "No" 的两个样例：

```
5 2 2 --> No

5 2 10 --> No
```

发现，按样例要求选择两个数，则其和最小为 $1+2=3$ ，最大为 $4+5=9$ 。数学表达为：若 $s \in (- \infty , 3) \cup (9, \infty)$ 则绝对无法凑出。那么大胆推测，当 $s \in [3,9]$ 就都可以凑出

推广到一般情况，我们的推论是：对于输入的 $n,k,s$ ，构造出 $1\sim n$ 的正整数数列为 $a_n$ ，若 $s \in [\sum\limits^{i \leq k}_{i=1}a_i,\sum\limits^{i \leq n}_{i=n-k+1}a_i]$ ，则输出 "Yes"，否则输出 "No".

代码实现上述猜想后，成功 AC 。代码由于篇幅有限请查看[提交记录](https://www.luogu.com.cn/record/50553574)。该算法时间和空间复杂度都是 $O(1)$ ，运行时间自然非常漂亮。

---

下面简单证明一下算法正确性：

性质一.1：当 $s=\sum\limits^{i \leq k}_{i=1}a_i$ 时，显然，只需选最小 $k$ 个数即可，且此时的 $s$ 最小。

性质一.2：当 $s=\sum\limits^{i \leq n}_{i=n-k+1}a_i$ 时，选择最大的 $k$ 个数，此时凑出的 $s$ 最大。

性质二：若 $s_0$ 可凑出且 $s_0 \ne \sum\limits^{i \leq n}_{i=n-k+1}a_i$ 时，要求 $s=s_0+1$ 的值，只需在保证合法（选的数不超过 $n$ 且不重复）的前提下，将已选出的任意一个数加一即可。

根据上面的论述，就可以保证能凑出区间 $[\sum\limits^{i \leq k}_{i=1}a_i,\sum\limits^{i \leq n}_{i=n-k+1}a_i]$ 里的所有整数。

---


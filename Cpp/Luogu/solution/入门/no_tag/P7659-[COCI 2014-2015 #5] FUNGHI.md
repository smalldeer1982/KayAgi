# [COCI 2014/2015 #5] FUNGHI

## 题目描述

Hansel 和 Gretel 得到了一块分成 $8$ 片的披萨，每片上面有不同数量的蘑菇，表示为 $S_1,S_2,...,S_8$。Gretel 很喜欢蘑菇，她想要找到连续的四片披萨使得上面的蘑菇最多。

请注意，因为披萨是一个圆，因此编号为 $1$ 的披萨片与编号为 $8$ 的披萨片是相邻的。

## 说明/提示

对于 $100\%$ 的数据，$0 \leq S_i \leq 50$。

译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
5
2
1
4
5
1
2
3```

### 输出

```
12```

## 样例 #2

### 输入

```
2
6
5
3
3
7
2
6```

### 输出

```
19```

# 题解

## 作者：wangbinfeng (赞：13)

大家好，我们又见面了。
（写题解实属不易，已经提交好几遍了，若有问题麻烦管理详细一点反馈，辛苦了）

------------
# 1.思路：
首先这道题要求：
> $8$ 片的披萨，每片上面有不同数量的蘑菇，找到连续的四片披萨，使得上面的蘑菇最多。

所以本题暴力就好了。代码太长了，怎么办？直接 ```sort``` 呗。然而这种缩短代码的方式有误，因为“找到**连续**的四片披萨”，所以只能多打一个双层循环了。

于是，我们快乐的打完了代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dat[8],ans,now;
int main(){
    for(int i=0;i<8;i++)cin>>dat[i];
    for(int i=0;i<8-3;i++){
        now=0;
        for(int j=i;j<i+4;j++)now+=dat[j];
        if(now>ans)ans=now;
    }
    cout<<ans;
}
```

第一个样例开开心心的 ~~水~~ 过了，但第二个始终过不了。用手模拟也是 $18$ ，为什么样例是 $19$ ？ ~~一定是样例错了。~~ 我们仔细的再读一遍题，会发现： $S_1$ , $S_2$ , $S_3$ , $S_4$ 是一组合法的 $4$ 片披萨，但 $S_7$ , $S_8$ , $S_1$ , $S_2$ 也是合法的序列 **（一些 $35$ 分的同学看这里了）** 。

怎么弄呢？学过循环队列的同学应该都会，直接在每次取数据时 对元素数量（ $8$ ）取余。没搞懂有一种简单的方法：直接把内容存储两遍就好了。没搞懂的同学怎么办？ ~~自己去学循环队列。~~ 有一种简单的方法：直接把内容存储两遍就好了。

如果你觉得这 $2$ 种方式太简单了，那就在来第 $3$ 中解法吧（方法借鉴 [@_SHM_
](https://charlie2.blog.luogu.org/solutionP7659) ）!

由**连续**的披萨，结合 ~~线段树、树状数组~~ 前缀和可以轻松想到使用**前缀和**来实现记录，但是只要求4个元素的和，而并不需要要求的最后一个元素之前所有元素之和，怎么办呢？设四个元素开始为 $x$ ，最后一个元素为 $y$ ，则 $x$ 到 $y$ 的和就等于 $y$ 的前缀和减 $x$ 的前缀和。

又遇到了老问题：披萨是一个环。解决方法也很简单有2种解法。其实这两种解法与上文中的方法相似，只是第二种需要一些很小的变动，所以我们分析一下第2种解法。

先分析如何取出在环两端的交接：左侧选 $i$ 个，右侧选 $4-i$ 个即为结果。

如图：
![by @_SHM_](https://ftp.bmp.ovh/imgs/2021/06/aba9c3f43d888a5e.png)
# 2.代码
1. 方法一代码（取余）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dat[20],ans,now;
int main(){
    for(int i=0;i<8;i++){cin>>dat[i];}
    for(int i=0;i<8;i++){
        now=0;
        for(int j=i,k=0;k<4;j=(j+1)%8,k++)now+=dat[j];
        if(now>ans)ans=now;
    }
    cout<<ans;
}
```

2. 方法二代码（存储两遍）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dat[20],ans,now;
int main(){
    for(int i=0;i<8;i++){cin>>dat[i];dat[i+8]=dat[i];}
    for(int i=0;i<16;i++){
        now=0;
        for(int j=i;j<i+4;j++)now+=dat[j];
        if(now>ans)ans=now;
    }
    cout<<ans;
}
```

3. 方法三代码（使用前缀和并只存储1遍）：

```cpp
//by @_SHM_,thoughts and code if infringement please inform in the comment area, I will delete.
#include <cstdio>
int x[9], a;
int maxn = 0;
int main() {
    for (int i = 1; i <= 8; i++) {
        scanf ("%d", &a);
        x[i] = a + x[i - 1];
    }
    for (int i = 4; i <= 8; i++) {
        if ((x[i] - x[i - 4]) > maxn) maxn = (x[i] - x[i - 4]);
        //前缀和
        //printf ("%d %d %d\n", x[i], (x[i] - x[i - 4]), maxn);
    }
    for (int i = 1; i <= 3; i++) {
        if (((x[8] - x[8 - (4 - i)]) + x[i]) > maxn) maxn = ((x[8] - x[8 - (4 - i)]) + x[i]);
        //左侧选i个，右侧选(4-i)个，因为总和只有4个
    }
    printf ("%d\n", maxn);
} 
```


---

## 作者：可爱的小于 (赞：13)

由于这是披萨，需要考虑到环形。

所以只需将末尾与开头用枚举相加就行了。

当然也可以在末尾再存一遍。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[9],ma=0;
	for(int i=1;i<=8;i++)
		cin >> a[i];
	for(int i=1;i<=5;i++)
		ma=max(ma,a[i]+a[i+1]+a[i+2]+a[i+3]);
	ma=max(ma,a[6]+a[7]+a[8]+a[1]);
	ma=max(ma,a[7]+a[8]+a[1]+a[2]);
	ma=max(ma,a[8]+a[1]+a[2]+a[3]);
	cout << ma << endl;
	return 0;
} 
```


---

## 作者：NASFsky (赞：5)

一道模拟题。唯一需要注意就是这是一个环，所以有可能选的四块是尾+头。于是只要考虑将环拉直即可。  
但我看楼下几位是将数据存了两遍，其实并没有必要，只要把前三个数据存到末尾就行了。
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[12],ans=-1;
int main()
{
    for(int i=1;i<=8;i++)cin>>a[i];
    a[9]=a[1];a[10]=a[2];a[11]=a[3];
	for(int i=1;i<=8;i++)
	ans=max(ans,a[i]+a[i+1]+a[i+2]+a[i+3]);
	cout<<ans; 
	return 0;
}
```


---

## 作者：Kingna (赞：3)

很简单，存个数组来记录一下最大值即可。

但是这是一个披萨的形状，也就是环形，所以我们在后面在添一圈，就可以避免没有判断环形而错误。

代码里面有注释:
```c++
#include<iostream>
using namespace std;
int a[20];//这个就是那8个数，但是我们后面还要添8个数，所以开成20 
int maxx;
int main(){
	for(int i=1;i<=8;i++){
		cin>>a[i];//输入 
	}
	for(int i=1;i<=8;i++){
		a[i+8]=a[i];//在后面添一圈，添的数跟输入的数一样 
	}
	for(int i=1;i<=15;i++){//为什么要15, 是因为后面有i+3避免超限，虽然写成18没有问题，但是15要好点 
		maxx=max(maxx,a[i]+a[i+1]+a[i+2]+a[i+3]);//统计最大值 
	}
	cout<<maxx<<endl;
}
````

---

## 作者：ZBAA_MKC (赞：2)

简单模拟题。

注意有可能出现同时选第 $1$ 个和最后一个的情况，所以我们要把输入的数据存两遍，来模拟一圈的披萨。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[17];
int main()
{
    for (int i = 1; i <= 8; i++)
    {
    	cin >> a[i]; //输入
	}
	for (int i = 9; i <= 16; i++)
    {
    	a[i] = a[i - 8]; //再存一遍
	}
	int ans = 0;
	for (int i = 1; i <= 8; i++) //计算
	{
		ans = max(ans, a[i + 2] + a[i + 1] + a[i + 3] + a[i]);
	}
	cout << ans; //输出
	return 0;
}
```


---

## 作者：Nygglatho (赞：2)

我们可以通过前缀和来找出每一个披萨的蘑菇数量，这样，令前缀和数组为 $x$，这样子，就可以得出一个公式：$x_i = S_i + x_{i - 1}$。那么，我们可以从 $4$ 开始循环，由于有可能多，我们就把前面减去就可以了。而每一个 $x_i$ 都会存放 $S_1$ 至 $S_i$ 的和，所以直接减去 $x_{i - 4}$ 即可，公式为 $maxn = \max(maxn, x_i - x_{i - 4})$。

然而，披萨是**环形**的，所以最后还要看 $x_6, x_7, x_8, x_1$ 这些数字的和，那么，我们把它们切割，切成两段，分别为 $x_{8 - i + 1}$ 至 $x_8$ 与 $x_1$ 至 $x_i$，如下图：

![](https://ftp.bmp.ovh/imgs/2021/06/aba9c3f43d888a5e.png)

注意只需要选出 $4$ 个即可，但一定要连续。

Code：
```cpp
#include <cstdio>
int x[9], a;
int maxn = 0;
int main() {
	for (int i = 1; i <= 8; i++) {
		scanf ("%d", &a);
		x[i] = a + x[i - 1];
	}
	for (int i = 4; i <= 8; i++) {
		if ((x[i] - x[i - 4]) > maxn) maxn = (x[i] - x[i - 4]);
		//前缀和
		//printf ("%d %d %d\n", x[i], (x[i] - x[i - 4]), maxn);
	}
	for (int i = 1; i <= 3; i++) {
		if (((x[8] - x[8 - (4 - i)]) + x[i]) > maxn) maxn = ((x[8] - x[8 - (4 - i)]) + x[i]);
		//左侧选i个，右侧选(4-i)个，因为总和只有4个
	}
	printf ("%d\n", maxn);
} 
```

---

## 作者：sid_shi1 (赞：2)

题目：[P7659 [COCI2014-2015#5] FUNGHI](https://www.luogu.com.cn/problem/P7659)

思路：

这还是一道较为简单的题目吧。

这里需要注意一点，披萨是环形的，也就是说连续的 $4$ 片披萨在数组中可能不是连续的（比如说 $6$ 号，$7$ 号，$8$ 号，$1$ 号披萨块其实是连续的），那么只考虑数组中连续的 $4$ 个数就错了，只能得 $35$ 分（其实样例 $2$ 都过不去），于是，我们需要考虑连续的披萨块在头和尾的情况。

有一种想法是，把原数组重复两遍，变成一个长为 $16$ 的数组，接下来再枚举从 $i$ 号开始的 $4$ 块披萨的和，由于一开始数组重复了两遍，就直接是接下来四块的和就好了，不需要考虑 $i$ 再会到 $1$ 等情况，最后再用 $maxn$ 反复更新得到最大值输出即可。

代码：


```
#include<bits/stdc++.h>
using namespace std;
int a[20]={0},maxn=0;//数组大小记得要开两倍
int main(){
	for(int i=1;i<=8;i++) cin>>a[i],a[i+8]=a[i];//输入并重复一遍
	for(int i=1;i<=8;i++){
		int sum=0;
		sum+=a[i]+a[i+1]+a[i+2]+a[i+3];//直接计和
		if(sum>maxn) maxn=sum; //更新maxn
	}
	cout<<maxn;
	return 0;
}
```


---

## 作者：Leo2020 (赞：2)

```
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int num[1000015],maxn;//定义两个变量分别是蘑菇数量，最大值 
int main(){
	for(int i=0;i<8;i++) cin >> num[i];
	for(int i=0;i<8;i++){
		int sum=num[i%8]+num[(i+1)%8]+num[(i+2)%8]+num[(i+3)%8];//求出当前披萨和后面3个披萨蘑菇的和 
		maxn=max(maxn,sum);//求最大 
	}
	cout << maxn << endl;
	return 0;
}
```


---

## 作者：BetterGodPig (赞：1)

[传送门](https://www.luogu.com.cn/problem/P7659)

题目大意：在一串数中找连续的四个数，使这四个数的和最大。

------------
看到连续两个字首先考虑用前缀和。

首先来看一下前缀和。
$$qzh_n = \sum_{i=1}^na_i$$
而连续的n个数之和，即是 $qzh_{i+n}-qzh_{i}$ 。

知道这个就很简单了，求连续四个数的和，即是求 $qzh_{i+4}-qzh_{i}$ 。

贴一下代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
using namespace std;
ll qzh[20],maxn = -INF;

inline ll getmax(ll a,ll b){
	return a>b? a: b;
}

inline ll read(){
	ll x = 0,f = 1;
	char ch = getchar();
	
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = x*10+ch-48;
		ch = getchar();
	}
	return x*f;
}

int main(){
	for(register int i = 1;i <= 8;i++){
		ll now = read();
		qzh[i] = qzh[i-1]+now;
	}
	
	for(register int i = 4;i <= 8;i++){
		maxn = getmax(maxn,qzh[i]-qzh[i-4]);
	}
	cout<<maxn;
	
	return 0;
}
```

然后，你就会发现，还是会WA几个试点。。
![](https://cdn.luogu.com.cn/upload/image_hosting/5y6rm0ck.png)

那么，到底是怎么回事呢？我们再来看看题目。

题目上说，这是一个披萨，~~吃过披萨的~~童鞋们一定知道披萨是圆的，也就是说，这些数据围成了一个环形，可以同时取第6、7、8、1个数据，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vq83iga3.png)

第6、7、8、1号也是连续的，那么应该如何处理呢？
其实很简单。 
$$\because a_6+a_7+a_8+a_1 = a_6+a_7+a_8+qzh_{i = 1}$$
并且：
$$a_6+a_7+a_8 = qzh_{i = 8}- qzh_{i = 5}$$
所以我们就可以令 $a_9 = qzh_{i = 8}+qzh_{i = 1}$，那么就有：
$$a_6+a_7+a_8+a_1 = a_9-qzh_{i = 5}$$
后面的也同理，就不展示了。

所以只需要加上一句：
```cpp
qzh[9] = qzh[1]+qzh[8];qzh[10] = qzh[2]+qzh[8];qzh[11] = qzh[3]+qzh[8];
```
再把 ```for``` 循环改成 ```for(register int i = 4;i <= 11;i++)``` 就可以啦！


------------
完整代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
using namespace std;
ll qzh[20],maxn = -INF;

inline ll getmax(ll a,ll b){
	return a>b? a: b;
}//手写max函数会快一些 

inline ll read(){
	ll x = 0,f = 1;
	char ch = getchar();
	
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = x*10+ch-48;
		ch = getchar();
	}
	return x*f;
}

int main(){
	for(register int i = 1;i <= 8;i++){
		ll now = read();
		qzh[i] = qzh[i-1]+now;//求前缀和 
	}
	
	qzh[9] = qzh[1]+qzh[8];qzh[10] = qzh[2]+qzh[8];qzh[11] = qzh[3]+qzh[8];//处理环形结构 
	
	for(register int i = 4;i <= 11;i++){
		maxn = getmax(maxn,qzh[i]-qzh[i-4]);//求最大值 
	}
	cout<<maxn;
	
	return 0;
}
```


---

## 作者：_lfxxx_ (赞：1)

**题目传送门：[P7659 [COCI2014-2015#5] FUNGHI](https://www.luogu.com.cn/problem/P7659)**

这题模拟就行了，但是注意数据是**环形**的（因为是披萨），对此有 $2$ 种方法。

1. 特判

不是很推荐，因为这道题不卡复杂度，且难调。

2. 破坏成链

即 $S_i+8\gets S_i$ ，然后扫一遍。
### 代码：
```cpp
#include<iostream>
using namespace std;
int s[20];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);//优化
	int ans=0;
	for(int i=1;i<=8;i++)
		cin>>s[i],s[i+8]=s[i];
	for(int i=4;i<=12;i++)
		if(s[i]+s[i-1]+s[i-2]+s[i-3]>ans)
			ans=s[i]+s[i-1]+s[i-2]+s[i-3];/4块披萨之和
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## P7659 FUNGHI
[原题链接](https://www.luogu.com.cn/problem/P7659)
## 分析
根据题意，给定八个数字组成一个环，求相邻四个数字的最大和。

## 思路
该题中只有八个数字，使用一个数组模拟环，取四个数相加最大值即可。

一道入门题，思路简单，代码量少，相信各位都能一眼看懂。
## Code
```cpp
#include<iostream>
using namespace std;
int s[15],head[15]={0,1,2,3,4,5,6,7,8,1,2,3},ans=0;
int main(){
	for(int i=1;i<=8;i++) cin>>s[i];
        for(int i=1;i<=8;i++) ans=max(ans,s[head[i]]+s[head[i+1]]+s[head[i+2]]+s[head[i+3]]);
	cout<<ans;
	return 0;
}
```


---

## 作者：fanypcd (赞：1)

### 题目简述：

给你排列成一个环形的 8 个数，求任意连续四个数的和的最大值。

### 题目思路：

- 因为是环形，可以考虑将它展开并扩展一圈，这样就仍然可以考虑到所有情况
- 即 ```s[i + 8] = s[i]```
- 然后遍历一遍得出最大和
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int s[25], ans = -1;
	for(int i = 1; i <= 8; i++)
	{
		scanf("%d", &s[i]);
		s[i + 8] = s[i];
	}
	for(int i = 1; i <= 13; i++)
	{
		ans = max(ans, s[i] + s[i + 1] + s[i + 2] + s[i + 3]);
	}
	printf("%d", ans);
	return 0;
}
```


---

## 作者：_ZhouYuHan_ (赞：0)

这道题还是比较简单的。

我们先开个数组存蘑菇数，再暴力枚举一遍起点，求出最大值即可。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int mo[9];//蘑菇数
int maxn;//最大值
int main() {
	for(int i=1; i<=8; i++)
		cin>>mo[i];//读入
	for(int i=1; i<=8; i++) {
		int sum=0;//临时计数器
		for(int j=i; j<i+4; j++) {
			if(j>8)
				sum+=mo[j-8];
			else
				sum+=mo[j]; //特判，防止数组越界
		}
		if(sum>maxn)
			maxn=sum;//判断是否超过蘑菇最大值
	}
	cout<<maxn;
	return 0;
}
```
最后求个赞，谢谢大家。

---

## 作者：ForeverCC (赞：0)

我们只要统计连续4个数的最大值就可以了。

因为这是一个环，所以把数组扩充一倍就能解决环状的问题。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=8,a[50],maxx=-1; 
int main() {
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i+8]=a[i];//扩充一倍数组 
	}
	for(int i=1;i<=n;i++)
		maxx=max(maxx,a[i]+a[i+1]+a[i+2]+a[i+3]);
	printf("%d\n",maxx);
	return 0;
}
```


---

## 作者：int32 (赞：0)

### 前言

蘑菇一定是彩色的。

### 思路

这是一道好题。

由于披萨是**环形**，所以采取**断环为链**的方法以防越界。

注：其实可以在后半空间（防越界的部分）只存 $s_{1\cdots3}$ 即可（想想为什么）。

然后枚举从第 $i$ 块披萨开始连续 $4$ 个的蘑菇数（即 $s_{i\cdots (i+3)}$），统计最大值 $(1\leq i\leq 8)$。

### 代码

```cpp
/*
Hints:
fr(a,b,c,d) 代表 for(register int a=b;a<=c;a+=d)
s[] 是每块披萨上的蘑菇数
v 是连续四块最多的蘑菇数
*/
fr(i,1,8,1){
	cin>>s[i];
	s[8+i]=s[i];//断环为链，二倍空间
}
fr(i,1,8,1) v=max(v,s[i]+s[i+1]+s[i+2]+s[i+3]);//更新
```

最后求赞求关注求评论！

---

## 作者：Jake_M (赞：0)

## P7659题解：
这道题由于数据很小，所以我们可以直接算！但这道题也有坑点，就是末尾是连着开头的（毕竟是一块披萨嘛）。
### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10];
int ans; 
int main(){
    for(int i=1;i<=8;i++){
        cin>>a[i];
        ans=max(a[1]+a[2]+a[3]+a[4],max(a[2]+a[3]+a[4]+a[5],max(a[3]+a[4]+a[5]+a[6],max(a[4]+a[5]+a[6]+a[7],max(a[5]+a[6]+a[7]+a[8],max(a[6]+a[7]+a[8]+a[1],max(a[7]+a[8]+a[1]+a[2],a[8]+a[1]+a[2]+a[3])))))));
    }
    cout<<ans;
    return 0;
}
```


---


# [COCI 2009/2010 #4] AUTORI

## 题目背景

伟大的科学发现一般是以科学家的姓氏命名，比如说，最流行的非对称密码系统 RSA 是由三位叫做 Rivest、Shamir 和 Adleman 的科学家发现的，而更为熟知的则是 Knuth-Morris-Pratt 算法，这个算法是由三位叫做 Knuth、Morris 和 Pratt 的科学家命名的。

## 题目描述

科学论文会大量引用一些早期的著作，因此在一个论文中出现两种不同的命名约定并不少见。这两种不同的命名约定分别是：

- 长变体，由每个作者姓氏的完整单词由连字符连接而成，例如 `Knuth-Morris-Pratt`。
- 短变体，仅由每个作者姓氏的第一个字符拼接而成，例如 `KMP`。

现在，你发现了一篇论文中同时使用了长变体和短变体这两种命名约定，这让你感到很不愉快，因此你想编写一个程序，将所有的长变体变为短变体。

## 说明/提示

**【数据范围】**

对于所有数据，满足字符串的长度不超过 $100$，且仅包含大小写英文字母和连字符 `-`。

**【题目来源】**

本题来源自 **_[COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST 4](https://hsin.hr/coci/archive/2009_2010/contest4_tasks.pdf) T1 AUTORI_**，按照原题数据配置，满分 $30$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
Knuth-Morris-Pratt```

### 输出

```
KMP```

## 样例 #2

### 输入

```
Mirko-Slavko```

### 输出

```
MS```

## 样例 #3

### 输入

```
Pasko-Patak```

### 输出

```
PP```

# 题解

## 作者：Eason_AC (赞：7)

## Content
科学论文会大量引用一些早期的著作，因此在一个论文中出现两种不同的命名约定并不少见。这两种不同的命名约定分别是：

- 长变体，由每个作者姓氏的完整单词由连字符连接而成，例如 `Knuth-Morris-Pratt`。
- 短变体，仅由每个作者姓氏的第一个字符拼接而成，例如 `KMP`。

现在，你发现了一篇论文中同时使用了长变体和短变体这两种命名约定，你想编写一个程序，将所有的长变体变为短变体。

**数据范围：字符串长度不超过 $100$。**
## Solution
供题人在此谢罪，一开始没有把长变体中的每个单词开头一定是大写字母这个条件翻译上来，但貌似并不影响？如果没有翻译出来这个条件，也只需要将每个连字符 `-` 后的字符或第一个字符直接拿出来拼在一起就好了。

当然，有了长变体中的每个单词开头一定是大写字母这个条件之后，这道题目就非常简单了。在 `cctype`/`ctype.h` 库里面有一个 `isupper()` 函数，它可以判断当前的字符是否是一个大写字母。于是，我们直接遍历整个字符串，逢大写字母就输出即可。
## Code
下面的代码是 COCI 官方给出的代码。
```cpp
#include <string>
#include <iostream>
#include <cctype>

using namespace std;

int main() {
	string a;
	cin >> a;
	for (int i = 0; i < (int)(a.size()); i++)
		if (isupper(a[i]))
			cout << a[i];
	return 0;
}
```

---

## 作者：ForeverCC (赞：2)

先输出第一个字符（肯定是首字母），遍历找到连字符后输出下一个字符即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[200];
int main(){
	scanf("%s",a+1);
	cout<<a[1];
	for(int i=2;a[i];i++)
		if(a[i]=='-')
			cout<<a[i+1];
	return 0;
}
```


---

## 作者：ZBAA_MKC (赞：1)

我的思路和大家的差不多，都是找到一个连字符后输出下一个，但其余的题解好像都是如果第 $i$ 个字符是连字符那么输出第 $i + 1$ 个字符，但我的实现方法不太一样，我是找如果当前第 $i$ 字符的上一个字符，即第 $i - 1$ 个字符是连字符，那就输出当前的第 $i$ 个字符。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    cin >> s;
    cout << s[0];
    int len = s.size();
    for (int i = 1; i < len; i++)
    {
    	if (s[i - 1] == '-')
    	{
    		cout << s[i];
		}
	}
	return 0;
}
```


---

## 作者：sid_shi1 (赞：1)

题目：[P7694 [COCI2009-2010#4] AUTORI](https://www.luogu.com.cn/problem/P7694)

思路：

输入原字符串，题目要求输出的是每一节的第 $1$ 个字母，那么这个字母有两种情况：第一种是它是这个字符串的第 $1$ 个字符，第二种情况是它的前 $1$ 个字符为 `-` ，这几种情况直接输出这个字母就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string a;
	cin>>a;
	int n=a.size();
	for(int i=0;i<=n-1;i++){//从头到尾遍历字符串
		if(i==0 || a[i-1]=='-'){//若满足两种情况中的一个
			cout<<a[i];//直接输出当前字母
		}
	} 
	return 0;
}
```


---

## 作者：Kobe_Bryant824 (赞：1)

先输出绝对有的首字母，然后找连字符，找到一个就输出一个即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[200];
int main(){
	scanf("%s",a+1);
	cout<<a[1];	//因为是第一个，所以直接输出
	for(int i=2;a[i];i++)	//从二开始
		if(a[i]=='-')	//判断连字符
			cout<<a[i+1];	//输出
	return 0;
}
```

---

## 作者：yzy1 (赞：0)

严格一行 Python 3。

```python
for i in [i if i.isupper() else "" for i in input()]:print(i,end="")
```

由于「每一个长变体中的单词开头一定是大写字母」，我们可以用列表生成式「筛选」出输入字符串中的所有大写字母，遍历输出即可。

---


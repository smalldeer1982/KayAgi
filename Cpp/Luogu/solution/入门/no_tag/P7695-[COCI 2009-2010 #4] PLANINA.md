# [COCI 2009/2010 #4] PLANINA

## 题目背景

Mirko 和 Slavko 正在拍摄一部改编自科幻小说 _Chicks in space 13_ 的电影。剧本要求他们呈现出不同的世界，所以他们决定在绿屏幕前拍摄整部电影，之后再添加 CGI 背景。Mirko 听说生成人工地形最好的办法是使用**中点位移算法**。

## 题目描述

为了执行这个算法，Mirko 选择了 $4$ 个点组成了一个完美正方形。然后他开始执行以下步骤：

- 在每个正方形的每一条边上，Mirko 都在正中间添加一个新点。这个新点上的地形高度是他所在这条边两个点上的平均高度。
- 在每个正方形的正中间，Mirko 也添加了一个新点。这个新点上的地形高度是所有 $4$ 个正方形定点的平均高度加上一个小的随机值。

Mirko 在执行完一次上面的所有操作后拥有了 $4$ 个新的方块。于是他不断地新建正方形，直到他对结果满意为止。下图说明了算法的初始状态、$1$ 次迭代和 $2$ 次迭代。
![](https://cdn.luogu.com.cn/upload/image_hosting/p16l99h1.png)

Mirko 发现到有些点属于不止一个正方形，为了减少内存消耗，他只存储这些点一次，但是**一旦这个点存储进去了，它就会永远储存在内存中**。现在他想请你编写一个程序，告诉他经过 $n$ 次迭代之后，总共需要在内存中存储多少点。

## 说明/提示

**【数据范围】**

对于所有数据，$1\leqslant n\leqslant 15$。

**【题目来源】**

本题来源自 **_[COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST 4](https://hsin.hr/coci/archive/2009_2010/contest4_tasks.pdf) T2 PLANINA_**，按照原题数据配置，满分 $50$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
1```

### 输出

```
9```

## 样例 #2

### 输入

```
2```

### 输出

```
25```

## 样例 #3

### 输入

```
5```

### 输出

```
1089```

# 题解

## 作者：AmaZingFantasy (赞：16)

从题目给的图来看，不难发现，每次每条边上的点数都是上一次的 $2$ 倍少 $1$ ，第一次边上有 $3$ 个点，以后的每一次都是按此规律增长的，多推几次可以得出的每条边上点数通项公式为：

$f(n) = 2^{n} + 1$

所有点数通项公式为：

$f(n) = (2^{n} + 1)^{2}$

掌握此规律，代码为：

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    int n;
    cin>>n;//输入n
    n=pow(2,n) + 1;//将n改为2的n次幂加1
    cout<<n*n;//输出n的平方，程序运行结束。
    return 0;
}

```





---

## 作者：Q__A__Q (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P7695)

[更好的阅读体验](https://www.luogu.com.cn/blog/372172/solution-p7695)

乍一看，我被难住了，但仔细一看，只要找到了规律，这题还是比较简单的。

![](https://cdn.luogu.com.cn/upload/image_hosting/p16l99h1.png)

这是一道~~比较easy的~~递推的题目。首先我们发现：从图一变成了图二，边上的需储存的点数乘 2 并多 1 个。所以容易得出第 n 次时的边上的点数是 $2^n+1$，则点数为边上点数的开方，即 $(2^n+1)^2$

**具体规律请参考下表↓**

|边上点数：| 1 | 2 | 3 | 4 | 5 | …… |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|需储存点数：| 9 | 25 | 81 | 289 | 1089 | …… |

另外，也可以在题目给出的样例中找规律。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn=100010;
int n,ans;

/*-----------------快读快写---------------------*/

inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}

inline void write(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

/*------------------------------------------*/

signed main() {
	n=read();
	write(pow(2,n)*pow(2,n));
	return 0;
}
```

求赞求过！！

**P.S**

本题除了递推的思路以外，由于数据比较小，所以打表也是不错的选择哈~

 _AC CODE_ :
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;

int dabiao[]={0,9,25,81,289,1089,4225,16641,66049,263169,1050625,4198401,16785409,67125249,268468225,1073807361};

signed main() {
	int n;
	cin>>n;
	cout<<dabiao[n];
	return 0;
}
```



---

## 作者：Aiopr_2378 (赞：3)

# Solution P7695 [COCI2009-2010#4] PLANINA

### 思路：

我们可以把每一次迭代理解成把边长加某个数（这个数有规律，下面会进行解释），然后求$n$次迭代后，面积为多少。

显然，正方形边长成为我们考虑的重要目标。

每一次迭代，会在边上相邻节点间增加一个节点，也就是增加$n-1$个节点这样，边长就出来了：

$f[n]=f[n-1]+f[n-1]-1=2*f[n-1]-1$

同时，$f[0]=2$。

### 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,x=2;
	cin>>n;
	for(int i=1;i<=n;i++){
		x=2*x-1;//公式见上
	}
	cout<<x*x;//算面积
	return 0;
}
```

谢谢观看

---

## 作者：basachenboming (赞：0)

**思路**

分析题目可知第 $n$ 次迭代后每边上的点数 $f(n)=2*f(n-1)-1$

所以自定义函数就可以写出来了

```cpp
long long int F(int x)
{
	if(x==1)
	{
		return 3;
	}
	if(x==2)
	{
		return 5;
	}
	if(x>2)
	{
		return(2*F(x-1)-1);
	}
} 
```
所以总点数 $ans=f(n)^2$

AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long int F(int x)
{
	if(x==1)
	{
		return 3;
	}
	if(x==2)
	{
		return 5;
	}
	if(x>2)
	{
		return(2*F(x-1)-1);
	}
} 
int main()
{
int n;
cin>>n;
int ans;
ans=pow(F(n),2);
cout<<ans;
return 0;
}
```


---


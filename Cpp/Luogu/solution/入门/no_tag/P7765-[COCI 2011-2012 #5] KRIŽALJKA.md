# [COCI 2011/2012 #5] KRIŽALJKA

## 题目描述

有两个单词 $A,B$，将 $A$ 水平摆放，$B$ 竖直摆放，两个单词重叠部分必须为**同一字母**，且这一字母须在 $A,B$ 中第一次出现。

例如，当 `A="ABBA",B="CCBB"` 时，输出如下所示：

```
.C..
.C..
ABBA
.B..
```

## 说明/提示

数据保证有解。

字符串由大写字母构成。

题目译自 [COCI 2011/2012 #5 T1](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
BANANA PIDZAMA```

### 输出

```
.P....
.I....
.D....
.Z.... 
BANANA
.M....
.A....```

## 样例 #2

### 输入

```
MAMA TATA```

### 输出

```
.T..
MAMA
.T..
.A..```

## 样例 #3

### 输入

```
REPUBLIKA HRVATSKA```

### 输出

```
H........
REPUBLIKA
V........
A........
T........
S........
K........
A........```

# 题解

## 作者：Liweiang (赞：12)

原题：[P7765 [COCI 2011/2012 #5] KRIŽALJKA](https://www.luogu.com.cn/problem/P7765)


------------
##  思路：
### 1.输入 
定义两个 char 类型字符串，用 scanf 读入
（注:scanf 遇到空格、回车和 Tab 键都会认为输入结束）。
```cpp
char a[100001],b[100001];
scanf("%s",a);
scanf("%s",b);
```
### 2.记录
可以用两层 for 循环。如果找到第一个相同字母出现的位置以及字母,记录下，然后跳出第二层循环。
```cpp
for(int i=la-1;i>=0;i--){
		for(int j=0;j<lb;j++){
			if(a[i]==b[j]){
				num_a=i;
				num_b=j;//记录相同字母的位置
				ta=a[i];
				tb=b[j];//记录相同字母 
				break;
			}
		}
	}
```
这里需要注意：外层循环对 $\ {A}$ 数组的循环需要从后往前找，因为如果找到 $\ {a_i}$ 等于 $\ {b_j}$ ，只跳出了第二层 for 循环，此时的 $\ {a_i}$ 不是第一个出现的。

### 3.输出
外层循环 $\ {b}$ 数组的每一位，如果 $\ {j}$ 等于 $\ {num_b}$ ,则输出单词 $\ {A}$ ，反之则循环 $\ {a}$ 数组。如果 $\ {i}$ 等于 $\ {num_a}$ ,则输出 $\ {b}$ 数组的元素，反之则输出 $ . $ 字符。
```cpp
for(int j=0;j<lb;j++){
		if(j==num_b){
			for(int k=0;k<=la;k++){
				cout<<a[k];
			}
		}
		else for(int i=0;i<la;i++){
			if(i!=num_a){
				cout<<".";
			}
			else if(i==num_a){
				cout<<b[j];
			}
		}
		cout<<endl;
	}
```



------------


最后附上完整 $\ {O(n^2)}$ 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100001],b[100001];
int main() 
{
	scanf("%s",a);
	scanf("%s",b);
	int la=strlen(a),lb=strlen(b),num_a,num_b;
	char ta,tb;
	for(int i=la-1;i>=0;i--){
		for(int j=0;j<lb;j++){
			if(a[i]==b[j]){
				num_a=i;
				num_b=j;//记录相同字母的位置
				ta=a[i];
				tb=b[j];//记录相同字母 
				break;
			}
		}
	}
	for(int j=0;j<lb;j++){
		if(j==num_b){
			for(int k=0;k<=la;k++){
				cout<<a[k];
			}
		}
		else for(int i=0;i<la;i++){
			if(i!=num_a){
				cout<<".";
			}
			else if(i==num_a){
				cout<<b[j];
			}
		}
		cout<<endl;
	}
	return 0;
}
```


------------
这是本蒟蒻的第二篇题解，如有不当之处请指出。~~只会用n方的代码做了。~~![/kk](https://cdn.luogu.com.cn/upload/pic/62227.png)


---

## 作者：sid_shi1 (赞：3)

题目：[P7765 [COCI 2011/2012 #5] KRIŽALJKA](https://www.luogu.com.cn/problem/P7765)

思路：

先找到在两个字符串中共同出现的第一个字符，并记下它在两个字符串中的下标。

接下来就是输出，比如我们刚才得到的两个位置是 $x$ 和 $y$，那么观察样例第 $y$ 行输出第一个字符串就行了。至于其余行，只在第 $x$ 列输出那一行第二个字符串的字母，其它的就输出 `.` 字符。

每一行不要忘记输出换行哦！

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string a,b;
	cin>>a>>b;
	int n=a.size(),m=b.size(),x,y,flag=1;
	for(int i=0;i<=n-1;i++){
		if(flag==0) break;//这个也要退出
		for(int j=0;j<=m-1;j++){
			if(a[i]==b[j]){//找到相同的
				x=i,y=j;//记下下标
				flag=0;
				break;//只找第一个
			}
		}
	}
	//按题意输出
	for(int i=0;i<=m-1;i++){
		if(i==y) cout<<a;
		else for(int j=0;j<=n-1;j++) (j==x)?cout<<b[i]:cout<<".";
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：ForeverCC (赞：3)

直接上思路：

枚举找到第一个相同的字符，记录下标，然后按要求输出。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100001],b[100001];
int len_a,len_b,num_a,num_b;
int main() {
	scanf("%s%s",a,b);
	len_a=strlen(a);
	len_b=strlen(b);
	for(int i=len_a-1;i>=0;i--)
		for(int j=0;j<len_b;j++)
			if(a[i]==b[j]){//找到第一个相同的字符
				num_a=i;//记录下标 
				num_b=j;
				break;
			}
	for(int j=0;j<len_b;j++){//按要求输出 
		if(j==num_b)
			for(int k=0;k<=len_a;k++)
				cout<<a[k];
		else
			for(int i=0;i<len_a;i++)
				if(i!=num_a)printf(".");
				else if(i==num_a)cout<<b[j];
		puts("");
	}
	return 0;
}

```

---

## 作者：BotDand (赞：3)

# $\text{Problems}$

有两个单词 $A,B$，将 $A$ 水平摆放，$B$ 竖直摆放，两个单词重叠部分必须为**同一字母**，且这一字母须在 $A,B$ 中第一次出现。

例如，当 `A="ABBA",B="CCBB"` 时，输出如下所示：

```
.C..
.C..
ABBA
.B..
```

# $\text{Answer}$

暴力枚举 $\text{A}$ 与 $\text{B}$，找第一次出现的同一个字母，记录在 $\text{A}$ 中的位置为 $\text{i}$，在 $\text{B}$ 中的位置为 $\text{j}$。

则输出时将 $\text{A}$ 放在 第 $\text{j}$ 行，将 $\text{B}$ 放在第 $\text{i}$ 列输出即可。

# $\text{Code}$

代码不贴了，是官方 std。

---

## 作者：LHLeisus (赞：2)

[题目](https://www.luogu.com.cn/problem/P7765)


思路：

- 首先一个双重循环搜一遍 a 串和 b 串，找到第一个相同的字符，把它在两个字符串里的下标存下来。

- 接着就是输出，观察样例，我们发现 a 串是横着的，b 串是竖着的，所以是 la 列 lb 行，也就是 i 从 0 到 lb-1，j 从 0 到 la-1。 

代码：
```cpp
#include<iostream>
#include<string>
using namespace std;
string a,b;//两个字符串 
int ii,jj;//第一个相同的字母在a,b串中的下标 
int f=1;
int main()
{
	cin>>a>>b; 
	int la,lb;//分别存两个字符串的长度 
	la=a.length();
	lb=b.length();
	for(int i=0;i<la;i++)//双重循环找第一个相同的字符 
	{
		if(!f) break;
		for(int j=0;j<lb;j++)
		{
			if(a[i]==b[j])
			{
				f=0;
				ii=i;
				jj=j;
				break;
			}
		}
	}
	for(int i=0;i<lb;i++)
	{
		if(i==jj) //如果i到了b[jj]所在的这一行，就直接输出一整行 
			cout<<a;
		else
		{
			for(int j=0;j<la;j++)
			{
				if(j==ii)//如果j到了a[ii]所在的的这一列 
					cout<<b[i];
				else
					cout<<".";
			}
		} 
		cout<<endl;
	}
	return 0;
} 
```

---

## 作者：vvauted (赞：2)

## Description
给出两个字符串 $A,B$，将 $A$ 水平放置，$B$ 竖直放置，使重叠部分为同一字符。

## Solution
暴力枚举 $A$ 与 $B$ 重复字母，使用了 `std::string` 中的 `std::find` 函数，可在一个 string 型的字符串 $s$ 中查找一个字符或一个字符串，若找到返回其在 $s$ 中位置，如没有，返回 npos。

代码：
```cpp
std::string a,b;
std::cin>>a>>b;
int alen=a.length(),blen=b.length(),tmpa,tmpb;
for(int i=0;i<alen;i++)
{
	if(b.find(a[i])!=b.npos)
	{
		tmpa=b.find(a[i]);
		tmpb=i;
		break;
	}
}
```
输出时注意：$A$ 与 $B$ 的位置与相同字符在 $B$ 与 $A$ 中的坐标相同，所以我把 $tmpa$ 和 $tmpb$ 反着存的。
## AC Code
仅供参考。
```cpp
#include <string>
#include <iostream>
int main()
{
	std::string a,b;
	std::cin>>a>>b;
	int alen=a.length(),blen=b.length(),tmpa,tmpb;
	for(int i=0;i<alen;i++)
	{
		if(b.find(a[i])!=b.npos)
		{
			tmpa=b.find(a[i]);
			tmpb=i;
			break;
		}
	}
	for(int i=0;i<blen;i++)
	{
		if(i==tmpa) std::cout<<a;
		else for(int j=0;j<alen;j++)
		{
			if(j==tmpb) std::cout<<b[i];
			else std::cout<<'.';
		}
		std::cout<<std::endl;
	}
}
```


---

## 作者：CarryQwQ (赞：2)


# 题目分析
Tips：
[博客](https://www.luogu.com.cn/blog/ThisIsCYF/solution-p7765)食用效果更佳。

[题目传送门](https://www.luogu.com.cn/problem/P7765)

对于查找第一次在 $A,B$ 两串里出现的字符，

首先，遍历 $A$ 字符串，对于 $A$ 字符串中的元素，每次用 ```find()``` 函数查找当前元素在 $B$ 字符串中是否出现，一旦出现，立即退出遍历，将这个字符第一次在 $A$ 串和 $B$ 串出现的位置分别存储。

因为一旦找到这样一个字符就立刻退出，所以找到的字符一定是在 $A$ 串和 $B$ 串第一次出现的。


关于 ```find()``` 函数的用法如下：

在字符串 $str$ 中查找是否包含子串 $s$，函数调用可以写成：
```cpp
str.find(s)
```

如果在字符串 $str$ 中查找不到子串 $s$，这个函数会返回一个值，在 C++ 中，可以用  ```string::npos ``` 代替。

则如果在字符串 $str$ 中查找到了子串 $s$，判断条件为:

```cpp
if (str.find(s) != string::npos)
```


题目样例输出可以看作是一个字符矩阵，而矩阵的长度由 $B$ 字符串长度决定, 矩阵宽度则由 $A$ 字符串长度决定。没有元素填充的位置则用 ```'.'``` 填充。

一行一行的输出最后答案。

$i,j$ 表示当前要输出的是第 $i$ 行第 $j$ 列的元素，判断：

如果第 $i$ 行等于字符在 $B$ 字符串出现的位置，则输出 $A$ 串的元素。

（这里可能比较绕，解释一下，如果第 $i$ 行等于字符在 $B$ 字符串出现的位置，那么就说明此时这一行应该填充 $A$ 字符串，因为这两个字符串是互相穿插的，而 $A$ 字符串是水平摆放的）

如果第 $j$ 列等于字符在 $A$ 字符串出现的位置，则输出 $B$ 串的元素， 原因同上。

另外还有一个情况需要特判就是重叠部分时需要注意，如果此时第 $i$ 行 $j$ 列同时满足以上两个条件只需输出任意 $A,B$ 字符串的元素就好了，不然输出就会变成这样:

```cpp
.T..
MAAMA
.T..
.A..
```

会多输出一个重叠部分的元素。

到这里就 OK 了，程序按照此分析编写。

# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string A, B;
int alci, blci;
/*
lci 是 location （位置）的简写
alci 存储字符在 A 字符串第一次出现的位置
blci 存储字符在 B 字符串第一次出现的位置
*/
int main() {
	cin >> A >> B;
	for (int i = 0; i < A.size(); i++) {
		if (B.find(A[i]) != string::npos) {//查找当前 A 字符串元素是否在 B 字符串中出现
			alci = i;
			blci = B.find(A[i]);
			break;
		}
	}
	for (int i = 0; i < B.size(); i++) {
		for (int j = 0; j < A.size(); j++) {
			if (i != blci && j != alci) cout << '.';//如果两个条件都不满足，用'.'填充
			if (i == blci && j == alci) cout << A[j];//特判：都满足就只要输出一个
			else if (i == blci) cout << A[j];
			else if (j == alci) cout << B[i];
		}
		cout << endl;
	}
}
```








---


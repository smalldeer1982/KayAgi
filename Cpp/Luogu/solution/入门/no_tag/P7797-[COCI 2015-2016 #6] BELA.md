# [COCI 2015/2016 #6] BELA

## 题目描述

有一个叫 $\text{Belote}$ 的纸牌游戏，游戏只用到 `A`，`K`，`Q`，`J`，`T`，`9`，`8`，`7` 共八种纸牌。
游戏规则就是将所有纸牌的值加起来，看看谁的值较大，谁就赢。每种纸牌的值都有两种，当其为**特殊牌**时有一个值，**非特殊牌**时也有一个值。每种卡牌的值见下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/w1wpljth.png)

现在 $\text{Mirko}$ 有 $4\times N$ 张纸牌，并已知特殊牌的属性为 $B$，请计算 $\text{Mirko}$ 所有纸牌值的总和。

## 说明/提示

**【样例 2 解释】**

纸牌值总和为 $11 + 4 + 3 + 20 + 10 + 14 +
0 + 0 + 11 + 4 + 3 + 2 + 10 + 0 + 0 + 0 = 92 $。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 100$，$B$ 和所有纸牌的属性都属于 `S`，`H`，`D`，`C` 四种字符中的一种，所有纸牌的种类都属于 `A`，`K`，`Q`，`J`，`T`，`9`，`8`，`7` 共八种纸牌中的一种。

**【题目来源】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #6](https://hsin.hr/coci/archive/2015_2016/contest6_tasks.pdf) T1 BELA**。

**本题分值按 COCI 原题设置，满分 $50$**。

## 样例 #1

### 输入

```
2 S
TH
9C
KS
QS
JS
TD
AD
JH```

### 输出

```
60```

## 样例 #2

### 输入

```
4 H
AH
KH
QH
JH
TH
9H
8H
7H
AS
KS
QS
JS
TS
9S
8S
7S```

### 输出

```
92```

# 题解

## 作者：Jorisy (赞：2)

一道标准的模拟题。

---

输入 $n$ 后，要注意：**下面是 $4 \times n$ 行。**  
循环的话，你可以将 `for(int i=1;i<=n;i++)` 简化为 `while(n--)`。  
接下来是核心部分。  
我们知道有两种情况：为特殊和不为特殊。那么根据题目，只要写一个 `if...else...` 内嵌套两个 `switch` 语句即可。  
核心代码：
```cpp
cin>>x>>y;
if(y==b)//为特殊
{
	switch(x)
	{
		case 'A':
			ans+=11;
			break;
		case 'K':
        ans+=4;
			break;
		case 'Q':
			ans+=3;
			break;
		case 'J':
			ans+=20;
			break;
		case 'T':
			ans+=10;
			break;
		case '9':
			ans+=14;
			break;
		default://以防 RE，下同
			ans+=0;
	}
}
else//不为特殊
{
	switch(x)
	{
		case 'A':
			ans+=11;
			break;
		case 'K':
			ans+=4;
			break;
		case 'Q':
			ans+=3;
			break;
		case 'J':
			ans+=2;
			break;
		case 'T':
			ans+=10;
			break;
		default:
			ans+=0;
	}
}
```

---

## 作者：ZBAA_MKC (赞：2)

本题根据题意模拟即可。

我们用 map 来储存字符与分值之间的关系，这样可以省去很多繁琐的判断。

代码如下：

```cpp
#include <iostream>
#include <map> 
using namespace std;

map<char, int> r;
map<char, int> s;
int main()
{
    int n;
    char b;
    cin >> n >> b;
    s.insert({'A', 11});
    s.insert({'K', 4});
    s.insert({'Q', 3});
    s.insert({'J', 20});
    s.insert({'T', 10});
    s.insert({'9', 14});
    s.insert({'8', 0});
    s.insert({'7', 0});
    r.insert({'A', 11});
    r.insert({'K', 4});
    r.insert({'Q', 3});
    r.insert({'J', 2});
    r.insert({'T', 10});
    r.insert({'9', 0});
    r.insert({'8', 0});
    r.insert({'7', 0}); //预处理分值
    int sum = 0;
    for (int i = 1; i <= (n << 2); i++) //计算得分并输出
    {
    	char x, y;
    	cin >> x >> y;
    	if (y == b)
    	{
    		sum += s[x];
		}
		else
		{
			sum += r[x];
		}
	}
	cout << sum;
	return 0;
}
```

---

## 作者：Daidly (赞：1)

简单的模拟。

用一个二位数组储存特殊牌与非特殊牌的值。

每一次输入找到对应值相加即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,s[2][8]={{11,4,3,2,10,0,0,0},{11,4,3,20,10,14,0,0}};
char b;
string a,c="AKQJT987";
int w(char k){
    for(int i=0;i<8;++i){
    	if(c[i]==k)return i;
	}
}
int main(){
    cin>>n>>b;
    for(int i=0;i<4*n;++i){
        cin>>a;
        ans+=s[a[1]==b][w(a[0])];
    }cout<<ans;
    return 0;
}
```

---

## 作者：Beep_Monkey (赞：1)

首先，判断输入的是否为特殊牌，加上其对应权值。最后输出值的总和即可。有些特殊牌的值与普通牌的值相等或值为零则可省略。

## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
char t[2],s[2];
int main(){
    scanf("%d%s",&n,t+1);
    n*=4;
    while(n--){
        scanf("%s",s+1);
        if(s[1]=='A') ans+=11;//这些牌特殊值与普通值都一样 
        if(s[1]=='K') ans+=4;
        if(s[1]=='Q') ans+=3;
        if(s[1]=='T') ans+=10;
        if(s[1]=='J'){//这些牌特殊值与普通值不一样 
            if(s[2]==t[1]) ans+=20;
            else ans+=2;
        }
        else if(s[1]=='9'&&s[2]==t[1])
            ans+=14;
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：lanretE (赞：0)

模拟水题一道。

定义两个数组存储特殊牌与非特殊牌的值。

每次输入调用函数利用字符串来找到字母对应的值。

注意，由于字符串和数组下标都是从零开始，所以不用特殊考虑下标问题。

**代码如下**

```
#include<bits/stdc++.h>
using namespace std;
int spe[]={11,4,3,20,10,14,0,0},ord[]={11,4,3,2,10,0,0,0};//分别为特殊牌与普通牌数组
int find(char c){
	string s="AKQJT987";
	int l=s.length();
	for(int i=0;i<l;++i)
		if(s[i]==c) return i;
}
int ans;
int main(){
	char b; int n;
	cin>>n>>b;
	n*=4;
	while(n--){
		string c;//注意不要用字符数组
		cin>>c;
		if(c[1]==b) ans+=spe[find(c[0])];
		else ans+=ord[find(c[0])];
	}
	cout<<ans;
	return 0;//好习惯
}



```


---

## 作者：ForeverCC (赞：0)

一道模拟题。

输入，判断是否为特殊牌，如果是则加上作为特殊牌时的值。否则加上不为特殊牌时的值。输出牌的值的总和即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
char t[5],s[5];
int main() {
	scanf("%d%s",&n,t);
	n*=4; 
	while(n--){
		scanf("%s",s);
		if(s[0]=='A')ans+=11;
		else if(s[0]=='K')ans+=4;
		else if(s[0]=='Q')ans+=3;
		else if(s[0]=='T')ans+=10;
		else if(s[0]=='7')ans+=0;
		else if(s[0]=='8')ans+=0;
		else if(s[0]=='J'){
			if(s[1]==t[0])ans+=20;
			else ans+=2;
		}
		else if(s[0]=='9'){
			if(s[1]==t[0])ans+=14;
			else ans+=0;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：cyhyyds (赞：0)

### 思路：
按照题意进行模拟。

对于每种牌的种类进行分类讨论，然后再判断是否是特殊牌。

如果当前牌是 $8$ 或者 $7$，可以跳过，因为是否是特殊牌都不影响答案。

### 代码：
[Link.](https://www.luogu.com.cn/paste/gspxp3du)
 

---


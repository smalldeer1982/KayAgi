# [COCI 2021/2022 #1] Ljeto

## 题目描述

有两支四人队伍，菠萝和蓝莓，在玩水枪。

我们将会给定游戏的具体信息，共 $n$ 条，信息形如在 $t_i$ 秒，玩家 $a_i$ 打到了玩家 $b_i$，对于一个玩家 $i$，如果 $1\le i\le 4$，那么他在菠萝队，否则他在蓝莓队，每打到一下加 $100$ 分。

定义一次双喷为，在 $10$ 秒之内，一名队员**连续**打到对面队伍的队员，设这名队员第一次命中是在第 $t_f$ 秒，则第二次命中需要在第 $[t_f+1,t_f+10]$ 秒内，一次双喷可以为队伍增加 $50$ 分，可以连续触发双喷。

试求出两支队伍的得分。

## 说明/提示

#### 数据范围
对于全部数据，$1\le n\le 100$，$0\le t_i\le 10^3$，$\forall 1\le i< n,t_i<t_{i+1}$，$1\le a_i,b_i\le 8$，玩家 $a_i$ 与玩家 $b_i$ 不属于同一支队伍。

| Subtask | 特殊限制 | 分值 |
| :---------: | :---------: | :----------: |
| $1$ | $n\le 3$ | $10$ |
| $2$ | 不存在双喷 | $15$ | 
| $3$ | 无特殊限制 | $25$ |

#### 说明
**本题总分 $50$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2022) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T1 Ljeto。

## 样例 #1

### 输入

```
3
10 1 6
20 1 7
21 8 1
```

### 输出

```
250 100```

## 样例 #2

### 输入

```
3
10 2 5
15 2 6
25 2 5```

### 输出

```
400 0```

## 样例 #3

### 输入

```
2
10 5 2
11 6 3```

### 输出

```
0 200```

# 题解

## 作者：苏22 (赞：11)

## 前言
###### 看到了一道很水的题，而且可以做题解，就立刻做了题解。

## 正解
这道题，先判断他是那一个队伍，因为一队是四人所以 `a` 要是小于等于四,则是菠萝队，否则，是草莓队。

接着，就是加分，每次加一百分，接着判断是不是双喷，如果是就加额外分。


这样就可以了（**记得每次初始化哦**）。
## AC代码




```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,t,a,b,syc[100],bld,cmd;
int main()
{
	memset(syc,0x3f,sizeof syc);//初始化 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&t,&a,&b);
		if(a<=4)// 判断是哪一个队伍打中的 
		{
        bld+=100;
			if(t-syc[a]>=1&&t-syc[a]<=10)//判断double喷  
				bld+=50;
			syc[a]=t; 
		}
		else 
		{
        cmd+=100;
			if(t-syc[a]>=1&&t-syc[a]<=10)//判断double喷 
				cmd+=50;
			syc[a]=t;
		}
	}
	printf("%d %d",bld,cmd);
}
```

有什么疑问评论哦，谢谢。

求求给孩子点个**赞**吧！！！！

---

## 作者：Grisses (赞：5)

[题面](https://www.luogu.com.cn/problem/P7927)

本题只需要一个模拟，细节在代码中讲解。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans1,ans2,a,t;//ans1表示菠萝队得分，ans2表示蓝莓队得分
vector<int>v[10];//v[i]存储第i个人击中别人的时间
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d%*d",&t,&a),v[a].push_back(t);//因为保证了a[i]和b[i]不属于同一队，所以b不用输入
	for(int i=1;i<=8;i++)sort(v[i].begin(),v[i].end());//将每人的击中时间排序
	for(int i=1;i<=8;i++){
		int cnt=0;
		for(int j=0;j<v[i].size();j++){
			cnt+=100;
			if(j!=0&&v[i][j]-v[i][j-1]<=10)cnt+=50;//判断是否触发双喷
		}
		if(i<=4)ans1+=cnt;
		else ans2+=cnt;//加分
	}
	printf("%d %d",ans1,ans2);//输出
	return 0;
}
```

---

## 作者：封禁用户 (赞：5)

# 1.前言
This explanation is translated from official explanation.

要掌握的内容：for 循环、数组。
# 2.解析
使用数组 $z[8]$，对于每一个玩家，我们可以保留该玩家最后一次喷对方队员的记录。

首先，我们将每个值设置为 $-11$。然后，根据 $a_i\le 4$ ，我们为团队增加 $100$ 分。

为了确定喷雾剂是否是“双喷”，检查是否 $t_i- z[a_i-1]<10$，如果是这样，我们给该队伍额外加 $50$ 分。

最后，对于每一行，我们应该更新值 $z[a_i-1]=t_i$。
# 3.code
Official code。
```python
n = int(input())
last = [-100]*8
s = [0, 0]
for i in range(n):
    t, a, b = map(int, input().split())
    a-=1
    b-=1
    s[a > b] += 100
    if t - last[a] <= 10:
        s[a > b] += 50
    last[a] = t
print(*s)
```


---

## 作者：打程序的咸鱼 (赞：4)

## 前言
希望审核能给我过了这篇题解 。
## 题目
[题目传送门](https://www.luogu.com.cn/problem/P7927)
## 正文
先判断射中对方队员的队员属于哪个队的 ， 然后再判断有没有双喷 。

可以设定一个数 ， 用来存每个队员上次打中人的时间 ， 然后再判断当前时间 - 这名队员上次打中人的时间是否小于 10 。 如果是，就再给所属的队伍加 50 分 。

还需排除将第一次打中人的时间误认为双喷 ， 所以要初始化 。
## AC code
```cpp
#include<cstdio>
using namespace std;
int n,m,p,q,x,y,time;
int t[9];//上次打中人的时间 
int main()
{
	for(int i=1;i<=8;i++) t[i]=-99;//先定义没打中过人
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&time,&p,&q);
		if(p<=4)//如果菠萝队的人打中的
		{
			if(time-t[p]>=1&&time-t[p]<=10)//判断双喷 
			{
				x+=50;
			}
			t[p]=time; 
			x+=100;
		}
		if(p>4)//如果草莓队的人打中的
		{
			if(time-t[p]>=1&&time-t[p]<=10)//判断双喷 
			{
				y+=50;
			}
			t[p]=time;
			y+=100;
		}
	}
	printf("%d %d",x,y);
}
```
### 最后希望这篇题解能帮到屏幕前的你，但是不要抄袭哦！

---

## 作者：__BAI__ (赞：2)

# 前言
###### 本蒟蒻发的第一篇题解
# 解析
#### 1.打中加分
若 ```a``` 小于等于4，则菠萝队加分，否则蓝莓队加分
#### 2.判断双喷
用8个数组存储每个人上一次喷中人的时间，若玩家 ```i``` 这次击中时间减上次时间小于等于10，则玩家 `i` 双喷
# AC代码
```c++
#include<bits/stdc++.h>
using namespace std;
int q[10];//存储玩家 i 的上次击中时间
int sum1,sum2;//分别记录两支队伍的得分 
int t,a,b; 
int main(){
	int n;
	cin>>n;
	memset(q,-9999999,sizeof q);//初始化 
	while(n--){//循环n次 
		cin>>t>>a>>b;
		if(a<=4){//若射击队员在菠萝队 
			sum1+=100;
			if(t-q[a]<=10)//判断双喷 
				sum1+=50;
		}else{//若射击队员在蓝莓队 
			sum2+=100;
			if(t-q[a]<=10)//判断双喷 
				sum2+=50;
		}
		q[a]=t;//记录队员 i 的击中时间 
	}
	cout<<sum1<<' '<<sum2;
	return 0;//好习惯 
}
```

---

## 作者：封禁用户 (赞：1)

一道水题，由于是新供入，题解区暂时空荡荡的，就让我来填进第一篇吧~  
题目传送>>[P7929](https://www.luogu.com.cn/problem/P7927)。  
### 题目分析：  
模拟即可。对于每次输进来的第二个数进行判断，如小于等于 $4$， 则将其归为 A 队，给 A 队加上 $100$ 分，额外的，再判断一下他是否打出了双喷，即距此人上一次喷人的时间不超过 $10$ 秒，如为，则额外给 A 队加上 $50$ 分，否则则不加分，然后每次最后将该次输入的第一个数――时间记到此人头上，留待后期双喷判断使用。另一方面，如每次输进来的第二个数大于 $4$，则将其归为 B 队，加分处理同上。  
值得注意的是，对于人头记时和双喷判断， 还需排除此人第一喷被误判为双喷的情况（即此人此前还未喷过人，而此人所挂的上次喷人时间还为初始的 $0$，且此时首喷时刻小于等于 $10$）。  
### Code：  
```cpp
#include <iostream>
#include <cstdio>

using namespace std;
typedef long long ll;
ll n;
ll a[10], b[10];//存A,B各组各人的上次喷人时间
ll t, x, y;
ll ans_a, ans_b;

inline ll read()
{
	ll x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-')
		{
			f = -1;
		}
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}

inline void write(ll x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
	{
		write(x / 10);
	}
	putchar(x % 10 + '0');
}

int main()
{
	//freopen("input.in","r",stdin);
	n = read();
	while (n--)
	{
		t = read(), x = read(), y = read();
		if (x <= 4)//归为A队
		{
			ans_a += 100;
			ans_a += a[x] != 0 ? (t - a[x] <= 10 ? 50 : 0) : 0;//判断双喷且排除误判，给其额外加分
			a[x] = t;//记下此人喷人时间
		}
		else
		{
			ans_b += 100;
			ans_b += b[x] != 0 ? (t - b[x] <= 10 ? 50 : 0) : 0;
			b[x] = t;
		}
	}
	write(ans_a), putchar(' '), write(ans_b);
	return 0;
}
```  
### 评测结果:  
![](https://cdn.luogu.com.cn/upload/image_hosting/b1luy6hf.png)  
****  
企鹅的题解到此结束，祝各位 OIers 进步 ++~

---

## 作者：RatingStar (赞：1)

### **题目大意：**

两队四名队员互相射击，每射中一次加 100 分，此队员 10 秒内再射中一次额外加 50 分。求两队的得分。

解题思路：
模拟。用数组 $t i$ 模拟出两队队员射击时间，同时根据射击时间判断是否双喷。

注意：
1. 射击中有两个变量，那个被射的人不重要，重要的是那个射击的人，因为看的是射击的人来加分，谁被命中也不会怎么样。
2. 对于双喷，上界与下界都要处理，至于加的那 100 分可与双喷的分数一起处理。在这里介绍一种符号，叫做 **三目运算符**：

```cpp
(条件1)?(执行1):(执行2)
//当条件一成立时，执行第一条语句，否则执行第二条语句
```

这里我们也可以采用这种方式来做这道题，码量会减少很多。

代码 **禁 止 抄 袭**：
```
#include<cstdio>
int n,m,a,b,x,y,t[9];
#define INF 2147483647
#define check m-t[a]>=1&&m-t[a]<=10 
//双喷判断条件，"&&"号连接上界和下界
int main()
{
	for(int i=1;i<=8;i++)
    		t[i]=-INF;//初始化
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&m,&a,&b);
		if(a<=4){x+=check?150:100;t[a]=m;}//如果双喷就共加 100+50=150 分，否则只加 100 分
		else{y+=check?150:100;t[a]=m;}同上
	}
	printf("%d %d",x,y);
}
```


---

## 作者：cyhyyds (赞：0)

## 思路：
照题意模拟就好了。

我们设一个数组 $pre_a$ 为 $a$ 玩家上一次攻击人的时间，初始为 $0$。如果是第一次攻击，那么计数器加上 $100$，记录下来。否则，判断是否是连喷，每次攻击计数器都加上 $150$。

## 代码：
这么简单还要看[代码](https://www.luogu.com.cn/paste/11pxns7q)吗？

---

## 作者：a2fkghjiu (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7927)

## 1.分析
使用变量记录两队总分

可以一边输入一边处理数据(预处理)

双喷特殊考虑

## 2.思路
对于双喷，可以记录每个人最后一次击中的时间。

为了防止初值赋 $0$ 在前十秒导致的错误记录            

初始的时间要赋成**负数**，＜ $-11$ 就行了
```cpp
#include <cstdio>
#include <cstring>
struct node{
	int t, ai, bi;
}a[105];//储存数据的结构体
int main(){
	int n, counta = 0, countb = 0, pen[10] = {-11, -11, -11, -11, -11, -11, -11, -11, -11};//一个处理双喷的数组
	int score[10] = {};
	scanf("%d", &n);
	for(int i = 1;i <= n;i++){
		scanf("%d %d %d", &a[i].t, &a[i].ai, &a[i].bi);
		if(a[i].t - 10 > pen[a[i].ai]){//双喷处理
			score[a[i].ai] += 100;
			pen[a[i].ai] = a[i].t;
		} else {
			score[a[i].ai] += 150;
			pen[a[i].ai] = a[i].t;
		}
	}
	for(int i = 1;i <= 4;i++){
		counta += score[i];
	}//计分
	for(int i = 5;i <= 8;i++){
		countb += score[i];
	}//计分
	printf("%d %d", counta, countb);
	return 0;
}
```

---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7927)

简单模拟题

按照题意模拟即可，对于**双喷**的处理我们可以先按照时间排序，然后分三种情况：

- 时间不在 $10$ 秒内；

- 时间在 $10$ 秒内但不是同一个人；

- 时间在 $10$ 秒内且是同一个人；

可见只有最后一种情况能拿到额外的 $50$ 分。

所以对于每一次击打我们向后找到 $10$ 秒内的所有击打，然后判断是不是同一人所作，

如果是则加上 $50$ 分并不再寻找（即找到离当前击打最近的符合条件的击打，这样不会导致重复加），如果不是则继续寻找。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct attack{
	int t,a,b;
}at[105];
inline bool cmp(const attack &x,const attack &y){
	return x.t<y.t;
}//按照时间排序
int main(){
	int n,A=0,B=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>at[i].t>>at[i].a>>at[i].b;
	}
	sort(at+1,at+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(at[i].a<=4){
			A+=100;
			for(int j=i+1;j<=n;j++){
				if(at[j].t<=at[i].t+10&&at[j].a==at[i].a){//符合条件
					A+=50;
					break;//跳出循环
				}
				if(at[j].t>at[i].t+10){//大于 10 秒
					break;
				}
			}
		}else{
			B+=100;
			for(int j=i+1;j<=n;j++){
				if(at[j].t<=at[i].t+10&&at[j].a==at[i].a){
					B+=50;
					break;
				}
				if(at[j].t>at[i].t+10){
					break;
				}
			}//同上
		}
	}
	cout<<A<<" "<<B;
	return 0;
} 
```


---


# [COCI 2013/2014 #4] NASLJEDSTVO

## 题目描述

有若干个金币，一个人将这堆金币尽量 $N$ 等分并拿走了一份，剩下 $O$ 个金币。

所谓『尽量 $N$ 等分』，是指将这堆金币分成 $N$ 堆，每堆所含的金币数是整数，且每两对金币的数量相差不超过 $1$。

我们约定这个人拿走的那一份金币是比较少的一份。

请你分别求出这堆金币原来最少有多少个和最多有多少个。

## 说明/提示

**【样例解释 #1】**

这堆金币可能原来有 $9$ 个，这个人可能将其分成 $4+5$ 个，自己拿走 $4$ 个；

这堆金币可能原来有 $10$ 个，这个人可能将其分成 $5+5$ 个，自己拿走 $5$ 个。

**【数据范围】**

对于 $100\%$ 的数据，$2\le N\le 15$，$N\le O\le 100$。

**【来源】**

本题分值按 COCI 原题设置，满分 $50$。

题目译自 [COCI2013-2014 CONTEST #4](https://hsin.hr/coci/archive/2013_2014/contest4_tasks.pdf) _**T1 NASLJEDSTVO**_。

## 样例 #1

### 输入

```
2
5```

### 输出

```
9 10```

## 样例 #2

### 输入

```
3
5```

### 输出

```
7 7```

# 题解

## 作者：Emptyhanded (赞：16)

[题目传送门](https://www.luogu.com.cn/problem/P8012)

我们假设最大金币数是 "1"，那么 $O$ 所占最大金币数的比是 $\dfrac{N-1}{N}$ ，最大金币数就是$O\div\dfrac{N-1}{N}$ 。

接下来要计算最小金币数，如果 $N$ 可以被最大金币数整除，也就是可以完全平均分的时候，最小金币数就是最大金币数-1。

代码献上：
```cpp
#include <iostream>
#include <cstdio>
//这些不用说吧
int n,o;//见题意
int Max,Min;//Max为最大金币数，Min为最小金币数
int main() {
    scanf("%d%d",&n,&o);
    Max=o/(n-1.0)*n;//根据如上公式算出最大金币数
    if(Max%n==0) Min=Max-1; 
    //如果n能被Max整除，则Min是Max-1
    else Min=Max;//否则为Max
    printf("%d %d",Min,Max);//华丽输出
    return 0;//完美结束
}
```
第一次发题解，心情蛮激动的。
#### ——The End

---

## 作者：Maysoul (赞：5)

### 分析：
这里面有几个很重要的数据必须要分析出来：

1.因为拿走了一份，所以现在地上还有 $ N-1 $ 份。

2.地上金币的总和是 $ O $ ，所以每一份也就是 $ \frac{O}{N-1} $ 枚金币。

3.但是它有可能是**等分**，也有可能是**尽量等分**，所以 $ \frac{O}{N-1} $ 不一定是一个整数。

4.当它为**等分**时，剩余的一份可能是 $ \frac{O}{N-1} $ ，也可能是 $ \frac{O}{N-1}-1 $ 。

5.当它为**尽量等分**时，因为剩余的一定有一份比别的都大，所以拿走的那一份只能为最小，也就是只能为 $ \frac{O}{N-1} $。

6.那么用拿走的金币数加上剩下的金币数就可以得到答案。

#### AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,o;
    cin>>n>>o;
    int z=o/(n-1),zz=o%(n-1);
    if(!zz)  cout<<o+z-1<<" "<<o+z<<endl;
    else cout<<o+z<<" "<<o+z<<endl;
} 
```


---

## 作者：yeshubo_qwq (赞：4)

## 题意
有若干个金币，一个人将这堆金币尽量 $N$ 等分并拿走了一份，剩下 $O$ 个金币，约定这个人拿走的那一份金币是比较少的一份，求出这堆金币原来最少有多少个和最多有多少个。
## 思路
$N-1$ 份为 $O$ 个金币，可以求出一份是多少个金币，加在原有的 $O$ 个金币上即可。

设一份为 $c$，则 $c=O\div \left(N-1\right)$。

注：不一定每一份均为 $c$，但差最多不超过 $1$。

两种情况：

第 $1$ 种：$O$ 正好被 $N-1$ 平分（如样例 $1$）。

最小的一份可以为 $c-1$，也可以为 $c$。

第 $2$ 种：$O$ 不能被 $N-1$ 平分（如样例 $2$）。

最小的一份只能为 $c$。

然后我们就能愉快的 AC 了。~~没什么难度吧~~
## 代码
```cpp
#include<stdio.h>
int n,o,c;
int main(){
    scanf("%d%d",&n,&o);
    c=o/(n-1);
    if(o%(n-1)==0)printf("%d %d",o+(c-1),o+c);//第1种情况
    else printf("%d %d",o+c,o+c);//第2种情况
    return 0;
}
```


---


# [COCI 2016/2017 #7] BAZA

## 题目描述

Mirko 在一家大型的 IT 公司获得了暑期实习的机会。这家公司建造了一个大型数据库，包含 $N$ 行 $M$ 列，第 $i$ 行第 $j$ 列上的整数是 $A_{i,j}$。

在他实习的第一天，他收到了 $Q$ 次询问，每一次询问包含 $M$ 个整数 $B_1,B_2,\dots,B_M$。但不幸的是，有些数在传输的过程中丢失了，数据库将它们替换为 $-1$。Mirko 需要回答数据库中有多少行和询问中的所有数匹配。形式化的说，Mirko 需要回答在范围 $[1,N]$ 内有多少个整数 $i$，满足 $\forall j\in[1,M]$，$B_j=-1$ 或 $B_j=A_{i,j}$。例如，如果 $M=3$，某一次询问为 $-1~3~2$，那么 Mirko 需要找到所有满足第一列为任意整数，第二列为 $3$，第三列为 $2$ 的行数。

Mirko 毕竟是刚开始实习的新人，因此他希望能够得到你的帮助。现在，请你帮助他回答这些询问！

## 说明/提示

**【样例 1 解释】**

对于第一次询问，第一行和第三行满足询问中第三列是 $2$ 的要求。  
对于第二次询问，只有第三行满足询问中第二列是 $3$，第三列是 $2$ 的要求。  
对于第三次询问，由于并没有对每一列上的数作出要求，因此所有行都满足要求。

**【数据范围】**

对于所有数据，$1\leqslant N,M\leqslant 10^3$，$1\leqslant Q\leqslant 50$，$1\leqslant A_{i,j}\leqslant 10^6$，$B_j=-1$ 或 $1\leqslant B_j\leqslant 10^6$。

**【题目来源】**

本题来源自 **_[COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST 7](https://hsin.hr/coci/archive/2016_2017/contest7_tasks.pdf) T1 BAZA_**，按照原题数据配置，满分 $50$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 3
1 5 2
2 3 4
4 3 2
5 4 6
3
-1 -1 2
-1 3 2
-1 -1 -1```

### 输出

```
2
1
4```

## 样例 #2

### 输入

```
3 8
6 5 97 99 82 50 95 1
85 62 11 64 94 84 88 19
43 99 11 64 94 84 31 19
3
-1 -1 11 64 94 84 -1 19
-1 -1 -1 99 -1 -1 -1 1
95 -1 -1 -1 -1 80 -1 -1```

### 输出

```
2
1
0```

# 题解

## 作者：Naro_Ahgnay (赞：7)

## 题目大意

现有一个包含 $n$ 行 $m$ 列的数据库，然后询问 $q$ 次，每次有 $m$ 个数，当  $m_j(j∈[1,m])$ 为 $\texttt{-1}$ 时可以将 $m_j$ 变成任意数。求出数据库中有几行数可以由这 $m$ 个数变化而来。

## 思路

既然当 $m_j$ 为 $\texttt{-1}$ 时可以变成任何数，那么我们只需要考虑当 $m_j≠-1$ 时和数据库的匹配情况。

对于输入的 $m_j$，我们可以枚举第 $i$ 行第 $j$ 列上的数是否与 $m_j$ 相等。用数组 $vis$ 保存每一行是否与这 $m$ 个数有不同，则当 $m_j≠a_{i,j}$ 时将 $vis_i$ 赋值为 1。最后检查 $1$ 到 $n$ 中的 $vis_i$ 有多少个仍然为 0，即为这次询问的答案。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,b,q;
int a[1001][1001];
bool vis[1001];
int main()
{
//	freopen("P8038.in","r",stdin);
//	freopen("P8038.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	scanf("%d",&q);
	while(q--)
	{
		memset(vis,0,sizeof(vis));
		ans=0;
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&b);
			if(b!=-1)
			{
				for(int i=1;i<=n;i++)
					if(a[i][j]!=b) vis[i]=1;
			}
		}
		for(int i=1;i<=n;i++) if(!vis[i]) ans++;
		printf("%d\n",ans);
	}
	return 0;
}

```


---

## 作者：pengzy___ (赞：2)

### 简要题意：
虽说这是一道入门水题，但是题目比较长，很难理解。

题目就是有一个 n 行 m 列的矩阵，询问 q 次，每次告诉他矩阵中有几行内容和询问的匹配。

### 思路：
这题的数据范围是比较小的，用模拟就能解决。

对于每次询问，输入一个数组，枚举是否匹配。注意，-1 是可以代表任何数的，所以只要数据相同或者那个数是 -1 就视为匹配成功。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans,t,q;
int a[1005][1005];
bool b[1005];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    cin>>q;
    while(q--) {
        memset(b,0,sizeof(b));
        ans=0;
        for(int j=1;j<=m;j++) {
            cin>>t;
            if(t!=-1)
                for(int i=1;i<=n;i++)
                    if(a[i][j]!=t) 
                        b[i]=1;
        }
        for(int i=1;i<=n;i++) 
            if(!b[i]) 
                ans++;
        cout<<ans<<endl;
    }
    return 0;
}
```


---

## 作者：Galex (赞：2)

## 题意
~~我语文不好，硬是看了半天才懂。。。~~

给你一个二维数组，询问 $Q$ 次，每次询问给你一个序列，问有**多少行**（注意是多少行，不是第几行）的每个数不是和序列中的这个位置的相同，就是序列中这个位置的数是 $-1$ 。

如果你题意理解了，那么恭喜你，这个题你已经做完一大半了。

但还剩一个重点，就是**比对**。

看其他题解都是直接在主函数中逐一比对，但其实那样会非常麻烦，还要引入一个变量来判断是否成功。所以建议把比对的过程**包装成函数**，写起来会方便许多。

由于这是个入门的题，所以做出来不难，但养成良好的**代码习惯**非常重要！例如逗号、符号前后打上空格、重点语句后面打上空格、打上主函数的结束等。题目变难后，码风好的优势就会发挥出来。

## 代码：

```cpp
#include <iostream>
using namespace std;

int n, m, q;
int a[1005][1005], b[1005];

bool chk(int h){
	for (int i = 1; i <= m; i++)
		if (b[i] != -1 && b[i] != a[h][i])//判断条件
			return false;//此时就会退出函数了，不需要多余的判断，所以方便。
	return true;
}

int main(){
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	cin >> q;
	while (q--){
		for (int i = 1; i <= m; i++)
			scanf("%d", b + i);
		int ans = 0;
		for (int i = 1; i <= n; i++)
			if (chk(i))//包装成函数更方便！
				ans++;
		printf("%d\n", ans);
	}
	return 0;
} 
```


---

## 作者：苏联小渣 (赞：2)

### 题目大意

给定一个 $n \times m$ 的二维数组 $A$，$q$ 次询问，每次一个 $m$ 个数的数列 $a$，求 $A$ 中有多少行与 $a$ 匹配。

匹配的定义为：$a_j=-1$ 或 $a_j=A_{i,j}$。

### 分析

看到数据范围，直接暴力枚举即可。

对于每次询问，输入 $a$ 数组，然后在 $A$ 中每一行判断是否匹配。如果 $a_j$ 不为 $-1$ 且 $a_j$ 不等于 $A_{i,j}$，则视为不匹配。最后算出有多少个匹配的即可。

时间复杂度 $O(qnm)$，可以通过。

### Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[1007][1007], q, ans, flag, d[1007];
int main(){
	scanf ("%d%d", &n, &m);
	for (int i=1; i<=n; i++){
		for (int j=1; j<=m; j++){
			scanf ("%d", &a[i][j]);
		}
	}
	scanf ("%d", &q);
	while (q --){
		for (int i=1; i<=m; i++){
			scanf ("%d", &d[i]);
		}
		ans = 0;
		for (int i=1; i<=n; i++){
			flag = 0;
			for (int j=1; j<=m; j++){
				if (d[j] != -1 && d[j] != a[i][j]){
					flag = 1;
					break;
				}
			}
			ans += (flag ^ 1);//位运算优化 
		}
		printf ("%d\n", ans);
	}
	return 0;
}

```

---

## 作者：Yukinoshita_Yukino (赞：1)

题意：给定一个 $N$ 行 $M$ 列的数组和一个长度为 $M$ 的匹配数组，求 $N$ 行内有多少行是符合要求的。特别地，如果匹配数组中有 -1，则这一位可以匹配原数组中的任意一个数。

直接模拟即可，挨个位置进行比较，如果遇到不一样的则停止比较。如果遇到 -1 则不用比较，直接看下一位，如果这一行都能匹配上的话，该询问的答案加一。

复杂度为 $O(nmq)$ 可过。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int q,n,m,cnt[1010][1010],a[1010];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>cnt[i][j];
		}
	}
	cin>>q;
	while(q--)
	{
		for(int i=1;i<=m;i++)
		{
			cin>>a[i];
		}
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			int f=0;
			for(int j=1;j<=m;j++)
			{
				if(a[j]!=-1&&a[j]!=cnt[i][j])
				{
					f=1;
					break;
				}
			}
			if(f==0) ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}


```

---

## 作者：pengzy___ (赞：0)

### 简要题意：
虽说这是一道入门水题，但是题目比较长，很难理解。

题目就是有一个 $n$ 行 $m$ 列的矩阵，询问 $q$ 次，每次告诉他矩阵中有几行内容和询问的匹配。

### 思路：
这题的数据范围是比较小的，用模拟就能解决。

对于每次询问，输入一个数组，枚举是否匹配。注意，$-1$ 是可以代表任何数的，所以只要数据相同或者那个数是 $-1$ 就视为匹配成功。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans,t,q;
int a[1005][1005];
bool b[1005];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    cin>>q;
    while(q--) {
        memset(b,0,sizeof(b));
        ans=0;
        for(int j=1;j<=m;j++) {
            cin>>t;
            if(t!=-1)
                for(int i=1;i<=n;i++)
                    if(a[i][j]!=t) 
                        b[i]=1;
        }
        for(int i=1;i<=n;i++) 
            if(!b[i]) 
                ans++;
        cout<<ans<<endl;
    }
    return 0;
}
```


---

## 作者：pengzy___ (赞：0)

### 简要题意：

虽说这是一道入门水题，但是题目比较长，很难理解。

题目就是有一个 $n$ 行 $m$ 列的矩阵，询问 $q$ 次，每次告诉他矩阵中有几行内容和询问的匹配。

### 思路：

这题的数据范围是比较小的，用模拟就能解决。

对于每次询问，输入一个数组，枚举是否匹配。注意，$-1$ 是可以代表任何数的，所以只要数据相同或者那个数是 $-1$ 就视为匹配成功。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans,t,q;
int a[1005][1005];
bool b[1005];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>q;
	while(q--) {
		memset(b,0,sizeof(b));
		ans=0;
		for(int j=1;j<=m;j++) {
			cin>>t;
			if(t!=-1)
				for(int i=1;i<=n;i++)
					if(a[i][j]!=t) 
					    b[i]=1;
		}
		for(int i=1;i<=n;i++) 
		    if(!b[i]) 
		        ans++;
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：cwfxlh (赞：0)

# P8038
题意，给定多次询问，求与询问数列匹配的矩阵行数。  
首先，读入矩阵和问题，开一个 ans 记录合法行数，然后 O(nm) 把矩阵扫一遍，对于每一行，只要匹配不上就 break ，如果扫到了最后一个点， ans++ ，最后输出答案。
____
## 附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int A[1003][1003],n,m,q,B[1003],ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)scanf("%d",&A[i][j]);
	}
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		ans=0;
		for(int j=1;j<=m;j++)scanf("%d",&B[j]);
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=m;k++)
			{
				if(B[k]!=-1&&A[j][k]!=B[k])break;//判断是否相同，不相同则退出 
				if(k==m)ans++;//整排都合法，ans++ 
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：BlackPanda (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P8038)

------------
### 题意：
- 给定一个 $N×M$ 的矩阵，然后有 $Q$ 次询问。
- 每次询问有一个长度为 $M$ 的序列，求原矩阵中和给定序列匹配的行数。
- 这里的匹配是指：**序列中的每个数和原矩阵中对应位置的数相同**或者**原矩阵位置上的数是 $-1$**。

------------
### 思路：
当序列中的数为 $-1$ 时，可以将它变成任意数，所以我们只需要考虑序列中的数（除 $-1$ 以外）和原矩阵中对应位置的数是否相同就可以。

------------
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,q,ans;
int b[1005][1005],t[1005];

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>b[i][j];
	cin>>q;
	for(int i=1;i<=q;i++){
		ans=0;
		for(int j=1;j<=m;j++)	cin>>t[j];
		for(int k=1;k<=n;k++){
			int f=1;
			for(int z=1;z<=m;z++){
				if(t[z]!=-1 && t[z]!=b[k][z]){
					f=0;break;
				}			
			}
			ans+=f;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：WhitD (赞：0)

## 题目大意
给定二维数组 $A$ 以及 $Q$ 组询问，问对于每组询问，除 $-1$ 外（$-1$ 可以代替任何数，即询问的 $-1$ 忽略不计)，$A$ 中存在多少行与它完全相同（包括数字的位置相同和数的大小相等）。
## 思路
数据范围较小，可以枚举解决。既然 $-1$ 忽略不计，那就直接判断除 $-1$ 外的数就好了，因为询问的数组长度与二维数组的列宽（即 $M$）是一样的，所以直接一行行扫就好了，因为读入数的位置就等于需要在二维数组里找的位置。
## 解法
那么我们可以每读入一个数（每一组共读入 $M$ 次），就将他与二维数组中所有行中和它的处在同一个位置（同一列）的数进行比较（每一个数比较 $N$ 次），我们不妨开 $vis$ 数组来记录（注意初始化为 $1$），如果当前数不等于 $-1$ 且不等于当前行的那个数，那么把这一行标记为 $0$ 就好了。一直重复执行直到所有数输入完，此时统计 $vis$ 为 $1$ 的个数，那么这个个数就是这一组询问的结果了（共重复 $Q$ 次）。

------------
#### 时间复杂度
通过上文括号内的解释，不难发现时间复杂度为 $O(nmq)$，完全可以接受。
## AC代码
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,m,q,a[1005][1005],vis[1005];
  int main()\mathcal{O}
  {
      cin>>n>>m;
      for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)
              cin>>a[i][j];
      cin>>q;//以上为读入 
      for(int ii=1;ii<=q;ii++)
      {
          memset(vis,1,sizeof(vis));//记住初始化 
          int ans=0,b;
          for(int j=1;j<=m;j++)//j表示列，也就是这组询问的这个数对应的列 
          {
              cin>>b;//单个读入节省空间 
              for(int i=1;i<=n;i++)//n代表一行行扫 
              {
                  if(a[i][j]!=b&&b!=-1)//不相同且不为-1，则该行排除，标记为0 
                      vis[i]=0;
              }
          }
          for(int i=1;i<=n;i++)
              if(vis[i])
                  ans++;//统计为1的（即满足条件的） 
          cout<<ans<<endl;
      }
  }
```
感谢各位能看完，在这给大家拜个晚年（~~真·晚~~）
## THE END

---

## 作者：CReatiQ (赞：0)

### 题目概述

观察数据范围，可见小常数 $\mathcal {O} (NMQ) $ 可过（ 这题题意也非常直白，没有常数问题 ）。

按照读入值为 $-1$ 或与原来数据库中的值相等则加一的规则，直接将读入的数据库和原来的数据库暴力配对计数即可。

### Code

```cpp
#include <cstdio>
#include <cstring>

const int MAXN=1e3+10;
int n,m,q,ans,lib[MAXN][MAXN],line[MAXN];

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return f*x;
}

int main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			lib[i][j]=read();
	q=read();
	for (int i=1;i<=q;i++)
	{
		ans=0;
		for (int j=1;j<=m;j++) line[j]=read();
		for (int j=1;j<=n;j++)
		{
			bool fit=1;
			for (int k=1;k<=m;k++)
				if (fit) fit&=(line[k]==lib[j][k] || line[k]==-1);
				else break;
			if (fit) ans++;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---


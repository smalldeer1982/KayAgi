# [COCI 2015/2016 #4] YODA

## 题目背景

很久很久以前，在一个遥远的星系里，一个巨大的整数碰撞正在发生。

## 题目描述

当两个整数碰撞时会发生什么？先将数位较少的数前不断添加前导 $0$ 直到和数位较高的数的数位数量相同为止。然后，从两个数的最低位开始，每次将两个数的对应数位进行比较，并删去较小的那个数位（如果这两个数位相等则**不执行任何操作**），不断向高数位执行上述操作，直到最高位为止。此时，将这两个数中没有删去的数位按顺序依次拼接，可以得到两个新数。

例如，对于 $456328$ 和 $284315$ 这两个数，这两个的碰撞过程如下所示：

| $4$ | $\sout{~5~}$ | $6$ | $3$ | $2$ | $8$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $\sout{~2~}$ | $8$ | $\sout{~4~}$ | $3$ | $\sout{~1~}$ | $\sout{~5~}$ |

不难看出，碰撞之后得到的两个新数为 $46328$ 和 $83$。

现在给定两个数 $n,m$，请求出这两个数进行碰撞之后分别得到的新数。如果某个数在进行碰撞之后，其数位都已经被删空了，则在输出中输出一行字符串 `YODA`。具体见『输出格式』部分。

## 说明/提示

**【样例解释 2】**

对于样例 $2$，这两个数碰撞的过程如下所示：

| $6$ | $\sout{~5~}$ | $7$ | $\sout{~4~}$ | $3$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $\sout{~0~}$ | $9$ | $\sout{~6~}$ | $5$ | $\sout{~1~}$ |

因此，碰撞之后得到的两个新数分别是 $673$ 和 $95$。

**【数据范围】**

对于 $30\%$ 的数据，保证 $n$ 和 $m$ 由三位数字组成。  
对于所有数据，$1\leqslant n,m\leqslant 10^9$。

**【题目来源】**

本题来源自 **_[COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST 4](https://hsin.hr/coci/archive/2015_2016/contest4_tasks.pdf) T1 YODA_**，按照原题数据配置，满分 $50$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
300
500```

### 输出

```
0
500```

## 样例 #2

### 输入

```
65743
9651```

### 输出

```
673
95```

## 样例 #3

### 输入

```
2341
6785```

### 输出

```
YODA
6785```

# 题解

## 作者：Naro_Ahgnay (赞：11)

## 题目大意

将两个数 $m,n$ 的各个数位从低到高进行比较，较大的数留下，较小的数淘汰，两个数相等就都保留下来。如果一个数各个数位上的数全部都淘汰了，那么输出"YODA"。

## 思路

如何求出一个数各个数位上的数呢？那就是最基础的取模运算了。将一个数对 10 取模就能得到这个数上最低位上的数。

```cpp
while(m)
{
	num=m%10;
	m/=10;
}
```

对于 $m$ 和 $n$，我们只需将 $m$ 和 $n$ 各个数位上的数从低到高进行比较后，用栈保存，最后就能实现从高到低位输出。

```cpp
stack<int> sta,stb;

while(1)
{
	p=n%10,q=m%10;
	if(p>q) sta.push(p);
	if(p<q) stb.push(q);
	if(p==q) sta.push(p),stb.push(q);
	n/=10,m/=10;
	if(!n&&!m) break;
}
```

最后还需要判断这个数是不是各个数位上的数全部都淘汰了。可以使用 STL 中  stack 自带的 empty() 函数判断该数是否还有“幸存者”。



```cpp
if(sta.empty()) puts("YODA");//表示栈是否为空，若空返回的值为真 
```

注意：有的时候剩下的数有前导零，需要将这些零扔掉。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int> sta,stb;
long long n,m;
int p,q;
bool fla,flb;
int main()
{
//	freopen("P8044.in","r",stdin);
//	freopen("P8044.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	while(1)
	{
		p=n%10,q=m%10;
		if(p>q) sta.push(p);
		if(p<q) stb.push(q);
		if(p==q) sta.push(p),stb.push(q);
		n/=10,m/=10;
		if(!n&&!m) break;
	}
	if(sta.empty()) puts("YODA");
	else 
	{
		while(!sta.empty()) 
		{
			if(sta.top()) {printf("%d",sta.top());fla=1;}
			else {if(fla) printf("%d",sta.top());}
			sta.pop();
		}
		if(!fla) puts("0");
		else puts("");
	}
	if(stb.empty()) printf("YODA");
	else 
	{
		while(!stb.empty())
		{
		if(stb.top()) {printf("%d",stb.top());flb=1;}
		else {if(flb) printf("%d",stb.top());}
		stb.pop();
		}
		if(!flb) puts("0");
	}
	return 0;
}

```


---

## 作者：xxasmcd (赞：3)

这道题我直接根据题意模拟，没有高端的处理算法，可能代码比较啰嗦，但易于学习。

解题步骤。
 
1. 输入两个字符串并统计长度。

1. 比较两个字符串的长度，并填上对应数量的前导零。

1. 进行两个字符串比对，并将删去的字符设上标记。

1. 进行特判，如果有其中一个字符串删空了就进行特殊处理。

1. 处理正常情况，将输出的两个字符串分别删去前导零。

1. 根据删除标记进行输出。

代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
bool tong1[10],tong2[10];
int ans1=0,ans2=0;
int main()
{
    cin>>s1>>s2;
    int len1=s1.size();//第1步,统计长度
    int len2=s2.size();
    int len=len1;
    if(len1<len2)//第2步，补上对应数量的0
    {
        for(int i=len1;i>=0;i--)
        {
            s1[i+len2-len1]=s1[i];
        }
        for(int i=0;i<len2-len1;i++)
        {
            s1[i]='0';
        }
        len=len2;
    }
    if(len1>len2)
    {
        for(int i=len2;i>=0;i--)
        {
            s2[i+len1-len2]=s2[i];
        }
        for(int i=0;i<len1-len2;i++)
        {
            s2[i]='0';
        }
        len=len1;
    }
    for(int i=0;i<len;i++)//第3步，进行两个字符串比对，并将删去的字符设上标记
    {
        if(s1[i]<s2[i])
        {
            tong1[i]=1;
            ans1++;
        }
        else if(s1[i]>s2[i])
        {
            tong2[i]=1;
            ans2++;
        }
    }
    if(ans1==len)//第4步，进行特判，如果有其中一个字符串删空了就进行特殊处理
    {
        cout<<"YODA"<<endl;
        for(int i=0;i<len;i++)
        {
            cout<<s2[i];
        }
        return 0;
    }
    if(ans2==len)
    {
        for(int i=0;i<len;i++)
        {
            cout<<s1[i];
        }
        cout<<endl<<"YODA";
        return 0;
    }
    int ok=1;
    for(int i=0;i<len;i++)//第5步，处理正常情况，将输出的两个字符串分别删去前导0
    {
        if(tong1[i]==0&&s1[i]=='0')
        {
            tong1[i]=1;
            ans1++;
        }
        else if(tong1[i]==0&&s1[i]!='0')
        {
            ok=0;
            break;
        }
    }
    ok=1;
    for(int i=0;i<len;i++)
    {
        if(tong2[i]==0&&s2[i]=='0')
        {
            tong2[i]=1;
            ans2++;
        }
        else if(tong2[i]==0&&s2[i]!='0')
        {
            ok=0;
            break;
        }
    }
    for(int i=0;i<len;i++)//第6步，根据删除标记进行输出
    {
        if(ans1==len)
        {
            cout<<0;
            break;
        }
        if(tong1[i]==0)
        {
            cout<<s1[i];
        }
    }
    cout<<endl;
    for(int i=0;i<len;i++)
    {
        if(ans2==len)
        {
            cout<<0;
            break;
        }
        if(tong2[i]==0)
        {
            cout<<s2[i];
        }
    }
    return 0;
}

```


---

## 作者：昒昕 (赞：3)

**整体思路**

可以先用一个数组存储碰撞后的剩余整数。

对于一个数位上的数：

+ 如果它被删去了，则不做任何操作。

+ 如果它没被删去，就把它插入数组末尾。（两个数位相等也是这样）

将输入的数转换为数组后：

+ 该数组为空，也代表其数位都被删空，输出 `YODA`。

+ 反之，则用一个变量存储该数组表示的数，从而起到去前导 $0$ 和翻转数组的作用。

可以用 `vector` 来方便地插入删除或判断是否为空。

同时，取某数的一个数位可以通过 $\bmod 10$ 的方法，只不过顺序是逆序的，输出时要再翻转一遍。


```cpp
#include <bits/stdc++.h>
using namespace std;

vector <int> knock[2];
int n,m,out; //out代表输出的变量
int main() {
	scanf("%d%d",&n,&m);
	while (n!=0||m!=0) {
		if (n%10>=m%10) knock[0].push_back(n%10); //具体含义见讲解部分
		if (m%10>=n%10) knock[1].push_back(m%10);
		n/=10; m/=10;
	}
	for (int i=0;i<=1;i++) {
		if (knock[i].empty()) puts("YODA"); //该数组为空，也就是该数数位均已删空
		else {
			out=0;
			for (int j=(int)knock[i].size()-1;j>=0;j--) //将数字转换为数组后，数组对于原输入数字是逆序的，所以还需翻转一遍
				out=out*10+knock[i][j];
			printf("%d\n",out);
		}
	}
	return 0;
}

```

---

## 作者：Aurora_Borealis_ (赞：2)

直接按照题意模拟即可。

用字符串存下两个数，暴力地一一比对，将小的数改变成特殊符号，输出时跳过即可。

关于前导 $ 0 $，只需在统计答案时不直接输出，而用一个变量将答案统计加和，最后输出。

代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
string s1,s2;
int main(){
	cin>> s1 >> s2 ;
	int l1=s1.length(),l2=s2.length();
	s1='@'+s1,s2='@'+s2;
	//cout<<l1<<" "<<l2<<endl;
	if(l1==l2){
		for(int i=1;i<=l1;i++){
			if(s1[i]-'0'>s2[i]-'0'){
				s2[i]='#';
			}else if(s1[i]-'0'<s2[i]-'0'){
				s1[i]='#';
			}
		}
	}else if(l1>l2){
		for(int i=l1-l2+1;i<=l1;i++){
			if(s1[i]-'0'>s2[i-l1+l2]-'0'){
				s2[i-l1+l2]='#';
			}else if(s1[i]-'0'<s2[i-l1+l2]-'0'){
				s1[i]='#';
			}
		}
	}else{
		for(int i=l2-l1+1;i<=l2;i++){
			if(s1[i-l2+l1]-'0'>s2[i]-'0'){
				s2[i]='#';
			}else if(s1[i-l2+l1]-'0'<s2[i]-'0'){
				s1[i-l2+l1]='#';
			}
		}
	}
	bool ok=0;
	int sum=0; 
	for(int i=1;i<=l1;i++){
		if(s1[i]!='#'){
			ok=1;
			sum=sum*10+(s1[i]-'0');
		}
	}
	if(!ok) cout<<"YODA"<<endl;
	else cout<<sum<<endl;
	ok=0,sum=0;
	for(int i=1;i<=l2;i++){
		if(s2[i]!='#'){
			ok=1;
			sum=sum*10+(s2[i]-'0');
		}
	}
	if(!ok) cout<<"YODA"<<endl;
	else cout<<sum<<endl;
	return 0;
} 
```


---

## 作者：tZEROちゃん (赞：1)

先给两个字符串 $a,b$ 的前面补上前导零，具体就是，如果 $a$ 的长度小于 $b$ 的长度，那就一直在 $a$ 前面追加 `0`，如果 $b$ 的长度小于 $a$ 的长度，那就一直在 $b$ 前面追加 `0`。

然后遍历一下两个字符串，整两个 `vector` $na,nb$，比较 $a_i$ 和 $b_i$ 的大小，然后如果 $a_i > b_i$ 就扔到 $na$ 里，如果 $a_i < b_i$ 就扔到 $nb$ 里，$a_i = b_i$ 就 $na, nb$ 里面都扔一个。

写一个函数 `toAnswer` 实现 `vector` 转成数字的功能，然后如果一个 `vector` 里元素个数为 $0$，就说明被删完了，输出 `YODA`，否则直接把它转成数字输出就行了。


代码（C++）：
```cpp
#include <bits/stdc++.h>
using namespace std;
int toAnswer(vector<char> v) {
  int ans = 0;
  for (int i = 0; i < (int)v.size(); ++i) {
    ans = ans * 10 + v[i] - '0';
  }
  return ans;
}
vector<char> na, nb;
string a, b;
int main() {
  cin >> a >> b;
  while ((int)a.size() < (int)b.size()) a = '0' + a;
  while ((int)a.size() > (int)b.size()) b = '0' + b;
  for (int i = 0; i < (int)a.size(); ++i) {
    if (a[i] > b[i]) na.push_back(a[i]);
    if (a[i] < b[i]) nb.push_back(b[i]);
    if (a[i] == b[i]) {
      na.push_back(a[i]);
      nb.push_back(b[i]);
    }
  }
  if ((int)na.size() == 0) cout << "YODA";
  else cout << toAnswer(na);
  cout << endl;
  if ((int)nb.size() == 0) cout << "YODA";
  else cout << toAnswer(nb);
}
```

---


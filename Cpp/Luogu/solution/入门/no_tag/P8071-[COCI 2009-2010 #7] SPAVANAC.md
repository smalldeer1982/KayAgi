# [COCI 2009/2010 #7] SPAVANAC

## 题目描述

给定 $24$ 小时制下的时间 $H:M$，输出 $24$ 小时制下比该时间早 $45$ 分钟对应的时刻。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$0 \le H \le 23$，$0 \le M \le 59$。

**【提示与说明】**

**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 1 SPAVANAC_。**

**本题分值按 COCI 原题设置，满分 $30$。**

## 样例 #1

### 输入

```
10 10```

### 输出

```
9 25```

## 样例 #2

### 输入

```
0 30 ```

### 输出

```
23 45```

## 样例 #3

### 输入

```
23 40```

### 输出

```
22 55```

# 题解

## 作者：hjl2011 (赞：10)

## P8071 题解

[题目传送门](https://www.luogu.com.cn/problem/P8071)

> Upd :
>
> Python 代码高亮

### 分析题意 :
给你两个数，先将第二个数减去 45，如果第二个数变成了负数（不够），那么就向第一个数借一位，如果第一个数还不够，那么就将它加上 24 。

---

得出伪代码：

```plain
输入 h,m
m 减 45
当 m < 0 :
  m 加 60
  h 减 1
当 h < 0 :
  h 加 24
输出
```

---

C++ 实现：

```cpp
#include <cstdio>
int main() {
  int h,m;
  scanf("%d %d",&h,&m); // 输入
  m -= 45;
  if(m < 0) { // 判断1
    m += 60;
    h--;
  }
  if(h < 0) h += 24; // 判断2
  printf("%d %d",h,m); // 输出
  return 0;
}
```

---

Python3 实现：

```python
s = input().split() # 输入
t1 = int(s[0])
t2 = int(s[1])
t2 -= 45
if t2 < 0 : # 判断
	t2 += 60
	t1 -= 1
if t1 < 0  : # 判断
	t1 += 24
print(t1,t2) # 输出
```

---

## 作者：lemon_qwq (赞：7)

[更好の阅读体验](https://610335.blog.luogu.org/solution-p8071)。

## 思路

这道题是一道思维题，所以你如果很有生活常识或很有思维性就可以轻松 AC 这道题。

但是对于像我这样思维力不太好的蒟蒻，我们就可以来举几个来推导公式。

我们先举例时间为 $8$ 时 $20$ 分，我们先不写程序，先算出来时间，$8$ 时 $20$ 分减 $45$ 分钟等于 $7$ 时 $35$ 分。我们可以找到相对的关系，原时间减去 $45$ 分钟如果需要借位，那式子就为 `60+(m-45)`，如果不需要借位就直接减，式子为 `m-45`，如果是第一种 $h$ 也需要减 $1$，因为借位了。这里我们还需要注意一下如果 $h$ 为 $-1$，那 $h$ 就是 $23$ 点。

接下来我们找好公式就可以写代码啦！

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int h,m;
int main(){
	cin>>h>>m;
	if(m-45<=0){//减不开的情况
		m=60+(m-45);//执行上面说过的公式
		h--;//然后借位
	}else{//减的开的情况
		m-=45;//直接减
	}
	if(h==-1)h=23;//判断时间是否为负数
	cout<<h<<" "<<m;//输出结果
	return 0;//华丽的结尾
}
```

~~这题还是挺给力的，一次提交就过了~~。

当然我建议大家不要看这是一道红题就直接复制粘贴，建议大家学会了之后自己手打一遍。

---

## 作者：MattL (赞：4)

[链接](https://www.luogu.com.cn/problem/P8071)

---

**题意：**

>给定 $24$ 小时制下的时间 $H:M$，输出 $24$ 小时制下比该时间早 $45$ 分钟对应的时刻。

解释：
1.  $24$ 小时制：
 - 小时数为 $0\sim23$，若超过上限则向天数进位，小于下限则向天数借位，由于这题不考虑天数，则直接加 $60$ 或减 $60$。

 - 分钟数为 $0\sim 59$，若超过上限则向天数进位，小于下限则向天数借位。
2. 早 $45$ 分钟：减 $45$ 分钟。

---

**解题：**

首先，由于题目给的时间一定是合法的，所以不用进行调整。

然后，我们先不考虑进借位，直接给分钟数减 $45$。

接着，我们按上面 $24$ 小时制的规则进行进借位。

最后，输出答案，注意以空格相间，不是分号。

---

**代码：**

更详细请见代码注释部分。


```cpp
#include <bits/stdc++.h>//万能头文件，萌新们也可以使用最普通的iostream
using namespace std;
int h,m;
int main()
{
    cin>>h>>m;
    m-=45;//int储存的数可以为负数
    if(m<0)//由于是减，只需要考虑借位
        h--,m+=60;//向h借1当60
    if(h<0)
        h+=24;//由于这题不考虑天数，所以直接减即可
    cout<<h<<' '<<m<<endl;//在提醒一次，不是分号是空格
    return 0;//萌新要养成写return 0的习惯哦
}
```

---

## 作者：AmaZingFantasy (赞：4)

**题目大意： **

给你一个时刻，输出比它早 $45$ 分钟的时刻。

一道红题，十分简单。

**思路：**

有点类似于加法竖式，我们从最低位开始分类讨论。

首先看最后一位是否可以减 $45$，如果可以，输出 $H,M-45$ 就行了。

如果最后一位减 $45$ 之后小于 $0$ 了，就要借位，就是形如 $H-1,M+60-45$ 的式子，不过还不能输出，因为会出现一种特殊情况，就像样例 $2$，如果 $45$ 分钟之前就是前一天了，就需要一个特判。

**代码：**

```cpp
#include <iostream>
using namespace std;
typedef long long l;
int main(){
    l a,b;
    cin>> a >> b;//输入
    if(b >= 45){//如果减45大于等于0，就减去这个45
        cout<< a << " " << b-45;
    }else {
        a -= 1;
        b = b + 60 - 45;//否则借位
        if (a >= 0) {//如果45分钟之前不是前一天，就输出
            cout << a << " " << b;
        }else {//如果是前一天，就要让a加上一个24再输出。
            cout<< a + 24 << " " << b;
        }
    }
    return 0;//华丽的结尾
}
```

完结撒花

---

## 作者：Unnamed114514 (赞：2)

这是一道选择结构题。

那么，我们其实可以按照模拟的方法做，首先，我们可以模拟竖式，按照小学学过的方法来借位即可。

因为有前导零，所以本人用的快读
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return res;
}
int a=read(),b=read(),c;
int main(){
	if(b<45){
		--a;
		b+=15; 
	} else
		b-=45;
	if(a<0)
		a+=24;
	cout<<a<<' '<<b<<endl;
	return 0;
}
```
但是，这个做法显然麻烦了，我们可以更进一步地优化：因为我们无视哪一天，我们可以提前一天，这样答案的小时数只需要 $\bmod 24$ 即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return res;
}
int a=read()+24,b=read()+15,c;
int main(){
	cout<<a%24-(b<60)<<' '<<b%60<<endl;
	return 0;
}
```
当然也可以转化成分钟计算，随后转化回去即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return res;
}
int a=read()+24,b=read(),c;
int main(){
	c=a*60+b-45;
	a=c/60%24;
	cout<<a<<' '<<c-(a+24)*60; 
	return 0;
}
```

---

## 作者：Jorisy (赞：2)

一道很简单的模拟题。

---

考虑两种情况：$m \ge 45$ 和 $m<45$。

当 $m \ge 45$，只要输出 $h$ 和 $m-45$。

当 $m<45$ 时，我们要先将 $m$ 减到 $0$ ，然后向 $h$ 借 $60$ 再减。

这时，又要考虑两种情况：$h>0$ 和 $h=0$。

我们令 $t=45-m$，则 $h>0$ 时输出 $h-1$ 和 $60-t$，$h=0$ 时输出 $23$ 和 $60-t$。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int h,m;
	cin>>h>>m;
	if(m>=45) cout<<h<<' '<<m-45;
	else//m<45
	{
		int t=45-m;//先减到 0
		if(h==0) h=23;
		else h--;//h>0
		cout<<h<<' '<<60-t;
	}
 	return 0;
}
```

---

## 作者：little_cindy (赞：2)

# 个人
## 思路
首先，我们直接大摇大摆地给 $m$ 减去 $45$。

但是从样例一中我们可以看到，$m$ 可能不够减 $45$。

不够减怎么办？

小学老师教我们减法时，就说过：“借位。”

好，那就把 $s$ 减 $1$，$m$ 加上 $60$ 总没错了吧？

还是不行——因为 $s$ 也会不够减 $1$，例如 $s=0$。

所以说，如果 $s<0$，我们还要给 $s$ 加上 $24$。

综上，便可以得出以下代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int s,m;
	cin>>s>>m;
	m-=45;
	if(m<0){
	    m+=60;
	    s--;
    	if(s<0){
    	    s+=24;
    	}
	}
	cout<<s<<' '<<m;
	return 0;
}
```
# 官方
## 思路
就和我上面说的那样，$m$ 会不够减 $45$。那么，我们判定 $m<45$。如果成立，此时 $m=60-(40-m_0)$。

在判定出 $m<45$ 成立时，$s$ 就要退一位。只要 $s>0$，也就是减 $1$ 不会出现负数，就没有影响。

反之，$s$ 将会在退位后加上 $24$ 小时。而这种情况只有可能 $s=0$，故若 $s>0$ 不成立，$s=23$。
## 代码
注：此为官方代码
```cpp
#include <cstdio>
#include <cstdlib>

int main(int argc, char **argv, char **env) {
	int s, m;
	scanf("%d %d", &s, &m);
	if ( m < 45 ){
		if ( s > 0 )
			s--;
		else
			s = 23;
		m = 60 - (45 - m);
	}
	else
		m -= 45;
	printf("%d %d\n", s, m);
	return EXIT_SUCCESS;
}
```

---

## 作者：封禁用户 (赞：1)

一道xxs数学题。

首先分析题，从 $h$ 开始，有 $2$ 种情况：

1. $m < 45$，此时 $ansh = h - 1$，因为最后这小时不够 $45$ 分钟，往前借，要考虑 $0$ 点，所以 $ansh = (h + 24 - 1) \% 24$；
2. $m \ge 45$，此时 $ansh = h$。

然后是 $m$：

同 $h$ 的第一种情况，$m$ 也要考虑退位的情况，所以 $ansm = ((m + 60) - 45) \% 60$。

然后输出就行，请看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int h, m;
    cin >> h >> m;
    int ansh, ansm;
    if (m < 45) ansh = (h + 24 - 1) % 24; // h
    else ansh = h;
    
    ansm = ((m + 60) - 45) % 60; // m
    cout << ansh << " " << ansm << endl;
    return 0;
}
```

-----

P.S.：希望管理加强一下数据，如：

输入：

```
0 50
```

输出：

```
0 5
```

但我之前提交的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int h, m;
    cin >> h >> m;
    int ansh, ansm;
    if (!h) ansh = 23;
    else if (m < 45) ansh = h - 1;
    else ansh = h;
    
    ansm = ((m + 60) - 45) % 60;
    cout << ansh << " " << ansm << endl;
    return 0;
}
```

按照 `0 50` 的输出是 `23 5`，明显 WA，但是却 AC 了。。

---

## 作者：iiiiiiiiiiiiiiiiiii (赞：1)

# 题目大意

输入一个 $24$ 小时制的时间，输出 $45$ 分钟前的时间。

# 算法

1. 先把昨天 $0:00$ 距离现在的时间算出来。为什么是昨天呢？因为如果 $45$ 分钟前是前一天，距离时间减去 $45$ 分钟就变成了负数，C++ 的负数取模很玄学，为避免这种情况，就用昨天的时间来算。

2. 把这个时间减去 $45$ 分钟，得到昨天 $0:00$ 距离 $45$ 分钟前的时间。

3. 把这个时间模上 $1440$ (一天的分钟数)，它除以 $60$ 的商就是 $45$ 分钟前的时，余数就是 $45$ 分钟前的分，输出答案即可。

# 代码（变量与主函数）

```
int n,m,s;
int main()
{
	cin>>n>>m;
	s=n*60+m+1440;
	s=(s-45)%1440;
	cout<<s/60<<" "<<s%60;
	return 0;
}
```

---

## 作者：哈士奇憨憨 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8071)
## 题目大意
给定 $24$ 小时制下的时间 $H:M$，输出 $24$ 小时制下比该时间早 $45$ 分钟对应的时刻。
## 思路
+ 如果 $H = 0$ 且 $M < 45$,说明分钟和小时都不够减，需要小时要向天数借一位，分钟要向小时借一位。所以前 $45$ 分钟在昨天的 $23$ 点 $M + 60 - 45$ 分钟。
+ 如果 $H \ne 0$ 且 $M < 45$,说明分钟不够减，需要向小时借一位。所以前 $45$ 分钟在 $H-1$ 点 $M + 60 - 45$ 分钟。
+ 否则前 $45$ 分钟在 $H$ 点 $M - 45$ 分钟。
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
int main(){
	cin >> n >> m;
	if(n == 0 && m < 45){//前45分钟是昨天23点
		cout << 23 << " " << 60 + m - 45;
	}else if(m < 45){//前45分钟是上一个小时 
		cout << n - 1 << " " << 60 + m - 45;
	}else{
		cout << n << " " << m - 45;
	}
	return 0;
}
```

---

## 作者：_lmh_ (赞：0)

一道简单的模拟题，细节也不多
### 题面简述
给定一个 $24$ 小时制时间 $a:b$ ，输出 $45$ 分钟前的时间 $c:d$ 。
### 做法
首先分两种情况：

第一种: $b<45$

这种情况意味着最终时间会在前一个小时，此时 $d=b-45+60=b+15$ , 而 $c$ 则是 $(a-1) \bmod 24$ .但是为了防止 $a=1$ 时出现负数，所以改成 $(a-1) \bmod 24=(a-1) \bmod 24 + 24 \bmod 24=(a+23) \bmod 24$ 。

第二种：$b \ge 45$

这种比较简单， $a=c,d=b-45$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
    cin>>a>>b;
    if (b<45){
        b+=15;
        a=(a+23)%24;
    }
    else b-=45;
    cout<<a<<' '<<b;
    return 0;
}
//ctj而不搞懂代码运行的原理不会让你学到任何东西
```

---

## 作者：tuxuanming2024 (赞：0)

一道选择结构的水体。

首先，我们可以先直接将 $m$ 减 $45$，那么此时就会出现两种情况：

情况一：$m>0$ 显然答案就是当前的 $h$ 和 $m$。

情况二：$m<0$ 就应该将 $h$ 减 $1$，$m$ 加 $60$。

那么 $h-1$ 后就可能减出负数，那么此时就应该回到前一天，即 $h=23$。

代码：
```cpp
#include <iostream>
using namespace std;
int h,m;
int main()
{
	cin>>h>>m;
	m-=45;
	if(m<0) h--,m+=60;
	if(h<0) h=23;
	cout<<h<<' '<<m;	
	return 0;
}
```


---

## 作者：Patients (赞：0)

##### [题目由此去](https://www.luogu.com.cn/problem/P8071)

------------

#### 题目描述:

给定 $ 24 $ 小时制下的时间 $ H:M $ ，输出 $ 24 $ 小时制下比该时间早 $ 45 $ 分钟对应的时刻。

#### 分析:

由于是一道红题，所以还是很水的，一共有 $ 3 $ 种情况。

1. 当 $ M \ge 45 $ 时，此时 $ M $ 不需要 $ N $ 退一位，直接输出 $ N  (M-45) $ 。

1. 当 $ M < 45  \land  n = 0 $ 时，此时 $ M $ 需要 $ N $ 退一位但 $ N $ 为 $ 0 $,输出 $ 23 (M-45+60) $ 。

1.  当 $ M < 45  \land  n \ne 0 $ 时，此时 $ M $ 需要 $ N $ 退一位， 输出 $ (N-1) (M-45+60) $ 。

#### 代码:

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	int n,m;
	cin>>n>>m;
	if(m>=45) cout<<n<<" "<<m-45;
	else if(n!=0) cout<<n-1<<" "<<m+60-45;
	else cout<<23<<" "<<m+60-45;
	return 0;
}
```


##### 感谢您的观看！

---

## 作者：rai1gun (赞：0)

一道模拟题。

### 题目思路

首先判断，如果 $M \ge 45$，那么直接输出 $M- 45 $ 即可。

如果 $M < 45 $ ，那么我们可以理解从一个小时中借 $60$ 分钟，在特殊判断一下 $0$ 即可。

### 题目代码

```c++
#include<iostream>
using namespace std;
int main(){
	int a,b;
	cin>>a>>b;
	if(b>45){
		cout<<a<<" "<<b-45;
	}else{
		if(a==0){
			cout<<23<<" "<<b+60-45;
		}else{
			cout<<a-1<<" "<<b+60-45;
		}
	}
	return 0;
}

```

---

## 作者：违规用户名gAGt8$%z (赞：0)

**这题是一道简单的顺序结构题**

我们设置一个整数 $x$ 代表从 $0:00$ 开始到现在过了多少分钟，即 $60$ × $h$ + $m$， 然后减去 $45$ 。 
要特判一下 $x$ 为负数的情况，因为若 $x$ 为负，就要退回第一天即 $x$ $=$ $1440-x$ ;

最后直接输出将 $x$ 转为小时/分钟的形式即可.


**上代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int h,m;
	cin>>h>>m;
	int nowmin=h*60+m;//计算x
	int befmin=nowmin-45;//45分前
	if(befmin<0)befmin=1440-befmin;//特判负数
	cout<<befmin/60<<" "<<befmin%60;//输出
	return 0;
}


```


---

## 作者：TsH_GD (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8071)

## 题目解读

这是一道纯模拟的题目（水）。

给出 $24$ 小时制下的时间 $H:M$ 。

 * $H$ 对应**小时**。
 
 * $M$ 对应**分钟**。

要求输出 $24$ 小时制下比该时间早 $45$ 分钟对应的时刻。

### 注意!!!!

分钟和小时小于 $0$ 的情况。

处理方法: **从前一天或前一小时借位**。

## ACcode:

```cpp
#include <bits/stdc++.h>
using namespace std;
int H,M;
int main(){
    scanf("%d%d",&H,&M);
    if(M>=45) printf("%d %d",H,M-45);
    else {
        M-=45;
        H-=1;
        if(M<0) M=60-abs(M);
        if(H<0) H=24-abs(H);
        printf("%d %d",H,M);
    }
    return 0;
}
```

---

## 作者：basachenboming (赞：0)

**思路**

简单模拟

两个变量 $a,b$ 记录时分

再按照题意让 $b-45$

如果 $b<0$ 令 $a-1,b+60$

这时如果 $a<0$ 使 $a+24$

**AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	b-=45;
	if(b<0)
	{
		a--;
		b+=60;
	}
	if(a<0)
	{
		a+=24;
	}
	cout<<a<<" "<<b;
	return 0;
}
```


---

## 作者：BlackPanda (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P8071)

------------
### 题意：
给出 $24$ 小时制下的时间 $H:M$，输出 $24$ 小时制下比该时间早 $45$ 分钟对应的时刻。


------------
### 思路：
这是一道纯模拟题目，直接根据题意模拟即可。

------------
### 注意：
要注意分钟和小时小于0的情况，从前一天或前一小时**借位**。

------------
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int h,m;
int main(){
	cin>>h>>m;
	if(m>45){
		cout<<h<<" "<<m-45;
	}
	else if(m==45){
		cout<<h<<" "<<"00";
	}
	else if(m<45){
		m-=45;
		h-=1;
		if(m<0){
			m=60-abs(m);
		}
		if(h<0){
			h=24-abs(h);
		}
		cout<<h<<" "<<m;
	}
	return 0;
}
```

---

## 作者：Daniel_He (赞：0)

很简单的一道题，先将 $1$ 小时转成 $60$ 分钟，再减去 $45$ 分钟，最后判断分钟数是否满 $1$ 小时就好了。

附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int h,m;
int main(){
	cin>>h>>m;
	h--;
	m+=60;//将1小时转换成60分钟
	m-=45;//按题目要求减去45分钟
	if(m>=60){//判断分钟数是否满1小时，有则将60分钟转换成1小时
		m%=60;
		h++;
	}
	cout<<h<<" "<<m;
	return 0;
} 
```

---

## 作者：hereiszd (赞：0)

## 题意简述
~~已经够简了~~。
## 题目分析
比较像[这个](https://www.luogu.com.cn/problem/P1425)题目。

用一个同一个思想：全换成分钟数，避免分类讨论。

可是样例也告诉我们了，可能倒回前一天，只需加个特判即可。

~~虽然你不加这个特判也能 A，数据好水啊~~。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int h,min;//读入
	cin>>h>>min;
	int ans=0;
	ans+=h*60+min;//转化同一进制
	ans-=45;
	if(ans<0)ans+=24*60;//如果到了前一天，就变成前一天的最后
	//把单位换回来
	int nowh=ans/60;//现在的小时
	int nowm=ans%60;//现在的分钟
	cout<<nowh<<" "<<nowm;
	return 0;
}

```


---

## 作者：LYqwq (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8071)

# 题目大意

给定 $24$ 小时制下的时间 `H:M`，输出 $24$ 小时制下比该时间早 $45$ 分钟的时刻。

# 思路

很简单的一道模拟题。

先来考虑小时，若 $M < 45$，那么小时数要减去一。当小时数减去一后，需要考虑负数情况，加上一个判断 $H < 0$，若成立，则将 $H$ 加上 $24$，表示到了前一天。然后，$M$ 需要减去 $60$ 再加上 $45$，简便一点就是 $M$ 加上 $15$。

若 $M \ge 45$，将 $M$ 减去 $45$ 即可。

# 代码

```cpp
#include <iostream>
using namespace std;
int h,m;

int main(){
	cin >> h >> m;
	if(m<45){ // 分钟小于 45，则需要处理
		if(--h<0){ // 若已经到了前一天，则将小时数加上 24
			h+=24;
		}
		m+=15; // +15 相当于 +60-45
	}else{
		m-=45; // 否则可以直接减
	}
	cout << h << " " << m << endl;
	return 0;
}
```



---

## 作者：henrywyh (赞：0)

[link](https://www.luogu.com.cn/problem/P8071)

题意：求 $h$ 时 $m$ 分倒退 $45$ 分钟后是几时几分。

思路：分两种情况：

$1.m≥45$ 这时可直接将 $m$ 减 $45$ ；

$2.m<45$ 这时可以转化成倒退 $1$ 小时，再前移 $15$ 分钟，将 $h$ 减 $1$ ，将 $m$ 加 $15$ 。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
signed main()
{
    int h,m;
    cin>>h>>m;
    if(m>=45)
        m-=45;
    else
        h--,m+=15;
    cout<<h<<" "<<m;
    return 0;
}
```


---

## 作者：Elgo87 (赞：0)

一个时间 $H:M$，要把它变为 $45$ 分钟前的时间，做法如下。

- 若 $M\ge45$，则直接把 $M$ 减去 $45$ 并输出即可；
- 若 $M<45$，则 $M\leftarrow M-45+60$，即 $M\leftarrow M+15$，再使 $H\leftarrow H-1$。
- 最后要特判一下，若 $H<0$，则 $H\leftarrow 24+H$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;


int main()
{
	int h, m;
	cin >> h >> m;
	int h2 = (m>=45 ? h : h-1), m2 = (m>=45 ? m-45 : 15+m);
	if (h2 < 0) h2 = 24 + h2;
	cout << h2 << ' ' << m2;
	return 0;
}
```

---

## 作者：Emptyhanded (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8071)

这题是一个简单模拟。

如果 $M\geq45$，很简单，分钟数就为 $M-45$，

否则，分钟数为 $M+15$, 小时数为 $H-1$。注意的是：如果 $H=0$，小时数为 $23$。

代码献上：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
//这些不用说吧
int H,M;//见题目
int main() {
	scanf("%d%d",&H,&M);
	if(M>=45) M-=45; //如果M>=45,根据如上方法算出分钟数
	else { //否则(M<45)
		M+=15; //计算分钟数
		if(H==0) H=23; //如果H为零，H=23
		else H-=1; //否则(H!=0),算出小时数
	}
	printf("%d %d",H,M); //华丽输出
	return 0; //完美结束
}
```

### ——The End

---

## 作者：ChenLingHan (赞：0)

**解析：**

令 $T = H_{input} \times 60 + M_{input} - 45$

可得：

$H_{output}=\begin{cases}T/60&(T>0)\\ 23&(T<0)\end{cases}	$

$M_{output}=\begin{cases}T\%60&(T>0)\\ 60+T&(T<0)\end{cases}	$

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
int H,M,T; 
int main () {
	cin>>H>>M;
	T=H*60+M-45;
	cout<<((T>0)?(T/60):23)<<" "<<((T>0)?(T%60):(60+T));
	return 0;
}
```
**小知识：**

三目运算符：```(条件表达式)?成立语句:不成立语句```

相当于：
```cpp
if(条件表达式){
   成立语句;
}else{
	不成立语句;
}
```

---

## 作者：HappyCode (赞：0)

### 思路
我们想要知道比 $H:M$ 早 $45$ 分钟的时间就要把 $M$ 减少 $45$。  
但是这题就这么简单吗？不是的，有可能提前 $45$ 分钟就到了上一个小时，如果 $M<0$ 就到了上一个小时。  
这时，我们需要将小时 $H$ 减 $1$，分钟 $M$ 加 $60$。  
还有可能提前 $45$ 分钟就到了上一天，如果 $H<0$ 就到了上一天。  
这时，我们需要将小时 $H$ 加 $24$，因为跨天就一定垮了小时，所以不用考虑分钟的问题。
### 提醒
要特判跨小时和跨天的情况！
### 代码
```cpp
#include<iostream>
using namespace std;
int h,m;
int main(){
    cin>>h>>m;
    m-=45;
    if(m<0){ //要特判跨小时的情况
        h-=1;
        m+=60;
    }
    if(h<0){ //要特判跨天的情况
        h+=24;
    }
    cout<<h<<' '<<m<<endl;
    return 0;
}
```

```python
data=input().split()
data[0]=int(data[0])
data[1]=int(data[1])
data[1]-=45
if(data[1]<0): #要特判跨小时的情况
    data[0]-=1
    data[1]+=60
if(data[0]<0): #要特判跨天的情况
    data[0]+=24
print(data[0],data[1])
```
### 更新日志
upd 2022.2.15：改正了 不用跨天 这一错误，并加入了 Python 代码。虽然数据没有，但是题面说明中有 $H=0$ 的情况。

[在这里，你可以获得更好的阅读体验。](https://happycodehc.github.io/blog/luogu8071)

---


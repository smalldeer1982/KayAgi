# [COCI 2009/2010 #7] COKOLADA

## 题目描述

顾客急需大小为 $K$ 个单位的巧克力，但现在你**只能选择一块**大小为 $2$ 的非负整数幂（即 $1,2,4,8,16,\cdots$）的巧克力进行购买。

为了满足顾客需求，可以采取切割的方式，将一块大小为 $D$ 个单位的巧克力切成两块大小为 $\dfrac{D}{2}$ 个单位的巧克力。

为了降低成本，你需要求出所需的巧克力大小的最小值和最小切割次数。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$1 \le K \le 10^6$。

**【提示与说明】**

**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 2 COKOLADA_。**

**本题分值按 COCI 原题设置，满分 $50$。**

## 样例 #1

### 输入

```
6```

### 输出

```
8 2```

## 样例 #2

### 输入

```
7```

### 输出

```
8 3```

## 样例 #3

### 输入

```
5```

### 输出

```
8 3```

# 题解

## 作者：wimg6_ (赞：19)

# P8072 题解

题目指标 [[COCI2009-2010#7] COKOLADA](https://www.luogu.com.cn/problem/P8072).

该文章同步发表于 [我的博客](https://www.luogu.com.cn/blog/Kingson123456/) 内。

审核一经通过，他人不得盗用博客。若为通过，引用时需注明出处，并私信作者。

### 正解

直接求出距离 $k$ 的数值最近的大于等于 $k$ 的 $2$ 的非负整数幂的数值 $q$ 并输出。

对于这题，我们同样需要简单地进行分类讨论。

1. 当 $q=k$ 的时候，我们可以直接输出。

2. 当 $q\ne k$ 的时候，我们需要求出最少需用到多少个 $2$ 的非负整数幂的数值，记其为 $s$.

### 细节处理

这一部分对初学者非常重要，如果稍有不慎就可能导致爆零，但是对于编程老手而言，这都是基础内容。

1. 不论你的 $q$ 是在栈内还是在栈外定义的，都要记住要将 $q$ 的初值赋为 $1$，因为在栈内：我们不保证 $q=1$，而在站外， $q$ 的初值是$ 0$. 

2. 切记第一个 while 循环内的判断条件要是 $q<k$ 而不是 $q\leq k$，最简单的 hack 数据就是 $k=2$ 时，期望得到的结果是 $2\ 0$ 而不是 $4\ 1$.

3. 最容易因粗心导致此问题，漏掉空格：即打印第二种情况时，更容易漏掉空格，而相比于 C++，C 语言使用者在使用时应当更加小心。

### 代码

正解代码如下：

```
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int k,q=1,s;//切记 q=1
int main()
{
	scanf("%d",&k);
	while(q<k)
		q*=2;// 2 的非负整数次幂的数值
	if(q==k)
		return !printf("%d 0",q);//第一种情况
	else printf("%d ",q);//第二种情况（注意不要打漏空格）
	while(k>0)
		q/=2,k%=q,s++;
	return !printf("%d",s);
}
```


---

## 作者：little_cindy (赞：10)

## 思路
### 原文
First, note that the smallest possible size that contains $K$ squares is the smallest power of $2$ larger than or equal to $K$.

Greedy strategy yield the smallest number of breaks required to reduce $2^X$ to $K$. First we break the piece in two, yielding two pieces, both smaller than $K$,with $2^{x-1}$ squares each. We now take one of them and need $K-2^{x-1}$ squares more of the other one. We break that one in half and repeat the process. Each time we need more than half of the current square, we keep one part. On other occasion we throw that part away.

### 翻译
首先，请注意包含 $K$ 个单位的正方形肯定是最小的大于或等于 $K$ 的 $2$ 的整数次幂。

贪心策略是将 $2^X$ 减小到 $K$ 的最少操作次数。首先，我们将一部分分成两块，产生两个新的部分。我们取其中的一个，需要另一个中 $K-2^{x-1}$ 单位的巧克力。我们再把它一分为二，重复这个操作。如果需要的单位数小于一半的个数，那么将其中的一块一分为二，另一块丢弃。


## 代码
```cpp
#include <cstdio>

int main() {
  int n, k, d;
  scanf("%d", &n);
  k = n & -n;
  for( d = 0; k < n; k <<= 1 ) ++d;
  printf("%d %d\n", k, d);
  return 0;
}
```

---

## 作者：Aixbei (赞：9)

# 题意分析
求大于 $k$ 的最小二进制整数和这个数除以几个 $2$ 才等于 $k \bmod 2$。
# 思路
首先暴力求出求大于 $k$ 的最小二进制整数，设为 $n$ ，并输出。

接着，判断 $n$ 是否等于 $k$ 。

如果等于，输出 $0$ ，否则暴力求出除掉的 $2$ 的个数并输出。
# 代码展示
```cpp
/*
Windows 7 Professional 64-bit
Intel Core i5-4590S@3.00GHz @3.00GHz
TDM-GCC 10.3.0 64-bit
*/
#include<bits/stdc++.h>
using namespace std;
int k,n=1,ans,i=0;
main(){
	cin>>k;
	while(n<k)n*=2;
	cout<<n<<' ';
	if(n==k){
		cout<<0;
		return 0;
	}
	while(k>0){
		n/=2;
		k%=n;
		++i;
	}
	cout<<i;
	return 0;
}
```

---

## 作者：liuxy1234 (赞：3)

这题不是很难。

1. 我们先求出大于等于 $k$ 的最小的 $2$ 的正整数次幂，这就是巧克力大小的最小值，顺便求出这是 $2$ 的几次幂，设为 $n$。

2. 然后我们可以把 $k$ 疯狂模 $2$，得到 $k$ 中含质因数 $2$ 的个数，用上面求的 $n$ 减去刚刚求的质因数 $2$ 的个数，得到要切几刀。

上代码。

```cpp
#include <bits/stdc++.h>
#define int  long long
using namespace std;

signed main(){
	std::ios::sync_with_stdio(0);
	int k;
	cin >> k;
	int sum = 1, cnt = 0;
	while(sum < k)sum *= 2, cnt++;
	cout << sum << " ";
	while(k % 2 == 0)k /= 2, cnt--;
	cout << cnt;
	return 0;
}

```


---

## 作者：rzh123 (赞：2)

# P8072 题解  

题目链接：[P8072 [COCI2009~2010\#7] COKOLADA](https://www.luogu.com.cn/problem/P8072)  

这是一个关于二进制的问题。  

## Part 1 求巧克力大小最小值  

因为只能是 $2$ 的非负整数幂，所以就是求最小的 $n$，使 $2^{n} \ge K$。  
直接枚举 $n$，找到最小值，输出 $2^n$。  

## Part 2 求最小切割次数  

以样例 $1$ 的 $6$ 为例分析：  

$6=(110)_2=2^2+2^1$。  

切 $x$ 刀，就会出现 $2^{n-1}\sim 2^{n-x}$，因此只需要 $3-1=2$ 刀。  

![](https://s4.ax1x.com/2022/01/26/7LKdOI.png)  

所以，就是找分解二进制后最低位的 $1$ 在哪里。  

代码：  
```cpp
#include <cstdio>
#define gc getchar()
#define pc(c) putchar(c)
int k,d,c=-1;
int read(){
	int t=0;
	char c=gc;
	while(c<'0'||c>'9') c=gc;
	while(c>='0'&&c<='9') t=10*t+(c^48),c=gc;
	return t;
}
void write(int x){
	if(x<10){
		pc(x|48);
		return;
	}
	write(x/10);
	pc((x%10)|48);
}
int main(){
	int i;
	k=read();
	i=0,
	d=1;
	while(1){
		if((c==-1)&&(k&d)){
			c=i;
		}
		if(d>=k){
			break;
		}
		++i,
		d<<=1;
	}
	c=i-c;
	write(d);
	fputc(' ',stdout);
	write(c);
	return 0;
}
```  

[AC 记录](https://www.luogu.com.cn/record/67990758)  

---

## 作者：3a51_ (赞：2)

### 题目大意

给定一个正整数 $n$，现在求 $2$ 个数：
1. 求最小的 $2^k$，使得 $k$ 是正整数且 $2^k \ge n$。
2. 求将第一问的 $2^k$ 拆成若干个 $2^p$($p$ 是正整数)，使得 $\sum 2^p=n$，且 $p \le k$,求 $2^k$ 到 $\min(2^p)$ 要除几次 $2$。

### 样例解释

样例1.

$n=6$ 时，取 $k=3$ 可以使得 $k$ 最小且 $2^k \ge n$。

$6=2+4=2^1+2^2$，最少需要 $2$ 个。所以输出```8 2```。

### 思路分析

对于第一问，不停地将 $n$ 除 $2$，并开一个 $ans$ 记录乘积，$n$ 每除 $2$ 一次，$ans$ 就乘 $2$ 一次。

对于第二问，考虑二进制拆分。拆分完去掉后面的 $0$ 后有多少位就是答案。

### 坑

注意特判 $n$ 为 $2$ 的整数次方。此时答案应该是 $n$ 和 $1$。

### code

```cpp
#include<iostream>
using namespace std;
int main()
{
	int n,ans1=1,ans2=0;//初始化及定义，ans1表示第一问的答案，ans2第二问。
	cin>>n;
	int tmp=n;//备份一下，方便第2问使用
	while(n)
	{
		n/=2;
		ans1*=2;
	}//求解第一问
	if(ans1==2*tmp)//特判，如果求完了结果是原数的2倍就说明n是2的整数次方
	{
		ans1/=2;
		cout<<ans1<<" "<<0;
		return 0;
	}
	while(tmp%2==0)
		tmp/=2;//先把后面多余的0滤掉
	while(tmp)
	{
		tmp/=2;//计算有多少位
		ans2++;
	}
	cout<<ans1<<" "<<ans2;//输出
	return 0;//结束
}
```

---

## 作者：Coros_Trusds (赞：1)

# 题目大意

给定 $n,m$，找到大于 $m$ 的最小的满足 $2^k\ge m$
二进制整数和这个数除以几个 $2$ 才等于 $k\bmod 2$。

# 题目分析

先 $\mathcal{O}(\log m)$ 找到大于 $m$ 的最小二进制整数；然后暴力将 $n$ 除二直到满足条件。

代码很简单，但是要注意特判 $m$ 就是二的整数次幂的情况。

# 代码

```cpp
int main(void)
{
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif

	int n=1,m=read();

	for(;n<m;n<<=1);

	printf("%d ",n);
	
	if(n==m)
	{
		puts("0");
	}
	
	else
	{
		register int i;

		for(i=0;m>0;i++)
		{
			n>>=1ll;

			m%=n;
		}

		printf("%d\n",i);
	}
	
	return 0;
}
```

---


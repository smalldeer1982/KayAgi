# 「PMOI-5」破译

## 题目背景

2077 年，穿越的 Lanuxhem 为与 2021 年的 Silver187 联系，发明了一种图形转数字的密码。

## 题目描述

lhm 现在有一个边长为 $1$ 的正方形，现在要进行 $k$ 次分割，每次分割需要把位于图形中右下角的矩形继续分割成 $n \times n$ 的矩形。分割完成后所有矩形的个数即为破译后的答案。lhm 需要聪明的你帮助他解决这个问题。

注：由于题面形容比较困难，请移步至样例解释便于理解题意。

## 说明/提示

### 样例解释

对于样例 #1，进行 $2$ 次分割，每次将右下角矩形分割为 $2\times 2$ 的矩形。

第一次分割，由于只有一个矩形，所以右下角矩形即为此矩形。分割前后如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tdlnmb52.png)

变为

![](https://cdn.luogu.com.cn/upload/image_hosting/cyemqw87.png)

接下来进行第二次分割，将右下角矩形进行分割，分割为如下图形：

![](https://cdn.luogu.com.cn/upload/image_hosting/9n3c3te2.png)

此图形包含 $7$ 个矩形，因此答案为 $7$。

### 数据规模与约定

对于 $10\%$ 的数据，$k=1$。          
对于另 $20\%$ 的数据，$1 \leq n,k \leq 10$。   
对于 $100\%$ 的数据，$1 \leq n,k \leq 10^9$。

---

$2022.7.10$：新增加一组 $\text{Hack}$ 数据。

## 样例 #1

### 输入

```
2 2```

### 输出

```
7```

## 样例 #2

### 输入

```
5 3```

### 输出

```
73```

# 题解

## 作者：Lithium_Chestnut (赞：20)

每次分割将右下角的矩形分割为 $n \times n$ 个矩形，显然每次分割就是将原有的 $a$ 个矩形分割为 $a-1+n \times n$ 个矩形。

那么 $k$ 次分割就是 $a-k+n \times n \times k$。

因为原有矩形为 $1$，所以答案就是 $1-k+n \times n \times k$，按降幂顺序排列整合一下就是 $n^2k-k+1$。

由于计算过大，记得开 `__int128`，并且配上快读快输，还有取模 $998244353$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll __int128
using namespace std;
ll n,k;
const int mod=998244353;
ll read()
{
	int x=0,w=0;
	char ch=0;
	while(!isdigit(ch))
	{
		w|=ch=='-';
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return w?-x:x;
}
void write(ll x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
	return;
}
int main()
{
	n=read(),k=read();
	write((n*n*k-k+1)%mod);
	return 0;
}
```


---

## 作者：ttq012 (赞：9)

思维题。

我们通过样例底下的解释来找规律，可以发现一开始一刀也没有切，只有 $1$ 个正方形，切过一刀之后，将右下角的一个正方形分割成 $k\times k$ 的正方形，其他的正方形不管，多加了 $k\times k - 1$ 个正方形。再切过一刀之后，和上回一样，又增加了 $k\times k - 1$ 个正方形，以此类推。

因此得出了通项公式：答案为 $1 + k\times (n\times n - 1)$。由于答案过大，出题人让我们将答案对 $998244353$ 取模，但是直接乘法会爆 $\texttt{unsigned long long int}$ 类型。于是有如下的几种解决方案：

+ 使用 `__int128` 类型，但是需要自己手写输入输出。
+ 使用分治版本的乘法。

在这里我使用了分治版本的乘法。

我们将 $a\times b$ 看成是 $a + a + a + \cdots + a$，一共 $b$ 个 $a$ 相加。

然后执行算法。当 $b$ 为 $0$ 的时候，答案就是 $a\times 0 = 0$，函数返回 $0$。

否则，将答案看作 $(a\times (\frac{b}{2}))\times (a\times (\frac{b}{2}))\times (a\times (b\bmod 2))$。其中 $a\times (\frac{b}{2})$ 只需要计算一次。

时间复杂度很容易发现是 $O(\log b)$ 的，不会像暴力算法一样超时。

**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;

inline long long ksc(long long a, long long b, long long c) {
    if (! b) return 0;
    long long ans = ksc(a, b >> 1, c);
    ans = (ans + ans) % c;
    if (b & 1) ans = (ans + a) % c;
    return ans;
}

signed main() {
    long long n, k;
    scanf ("%lld%lld", &n, &k);
    long long ans = 1 + ksc(n * n - 1, k, 998244353);
    ans = ans % 998244353;
    printf ("%lld", ans);
    return 0;
}
```


---

## 作者：yeshubo_qwq (赞：9)

## 思路
考虑靠公式 $O\left(1\right)$ 计算。

对于每次操作，在原有的矩形中，取出一个矩形，分割成 $n \times n$ 个矩形，对于原有的矩形来说，增加了 $n \times n-1$ 个矩形。

那么原有 $1$ 个矩形，每次增加 $n \times n-1$ 个矩形，增加了 $k$ 次，就很容易得出答案了。

公式：$k\times\left(n\times n-1 \right)+1$。

别忘了模 $998244353$。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	cout<<((k%998244353)*((n*n-1)%998244353)+1)%998244353;
	return 0;
}
```


---

## 作者：Engulf (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8152)



[更好的阅读体验](https://www.luogu.com.cn/blog/t-m-j-y-h-0-9/solution-p8152)



## 分析



第一次划分会变成 $n^2$ 块，之后每次划分都会增加 $n^2-1$ 块（减一是因为自己那一块不能重复算），所以答案就是 $k\cdot (n^2-1)+1$。



需要注意一下取模。



## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n,k;
long long ans;
int main(){
	cin>>n>>k;
	cout<<((k*(n%998244353*n%998244353-1))%998244353+1+998244353)%998244353;
	//system("pause");
}
```



---

## 作者：gzlinzy (赞：3)

根据题意，我们知道每次分割后右下角的矩形会被分成 $n \times n$ 个矩形。这块被分开的矩形从一块变为 $n \times n$ 块，使得矩形总个数增加 $n \times n - 1$。 因此 $k$ 次操作后矩形总个数增加 ( $ n \times n - 1 $ ) $\times k$，加上初始的一整块，答案即为 $ans=$ ( $ n \times n - 1 $ ) $\times k + 1$。

注意：由于数据范围及模数过大，因此记得开 ```long long```，并且在每次运算后得出的结果可能超过模数时记得对结果进行取模。

代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,k,mod=998244353;
int main(){
	cin>>n>>k;
	cout<<((n*n-1)%mod*k+1)%mod;
}
```


---

## 作者：苏联小渣 (赞：3)

### 题目大意

给定 $n,k$，把一个正方形进行 $k$ 次操作，第一次分成 $n \times n$ 份，其余每次把上一次操作最右下角的正方形分成 $n \times n$ 次，求最终有多少个正方形。建议看样例。

### 分析

瞪着样例那个图答案就出来了。每一次操作相当于把原来的 $1$ 个正方形分成了 $n \times n$ 份，第一次的贡献是 $n \times n$（因为创造出了 $n\times n$ 个正方形），其余的贡献都是 $n \times n-1$（因为要损失原来 $1$ 个大的，换成 $n \times n$ 个小的），所以直接把这玩意输出，就是 $n \times n+(n \times n-1)\times (k-1)$。

代码就不放了，直接对着上面那个式子输出就可以了。注意乘要取一遍模，最后两个部分加起来还要取一次模。不用开 `int 128`，甚至输入 `long long` 都不用，输出时乘上 `1LL`，用 `lld` 输出即可。

---

## 作者：InterN_NOT_FOUND (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8152)

这是一道“探索与表达规律”的题。

题意不难看出每进行一次操作就会多出 $n \times n - 1$ 个矩形，进行 $k$ 次操作就会多出 $(n \times n - 1) \times k$ 个矩形，再加上原来的一个就是答案了。

代码实现：

```cpp
#include<bits/stdc++.h>
#define int long long

namespace IO{
	inline bool isnum(char ch){return ch>='0'&&ch<='9';}
	inline int read()
	{
		int x=0,f=1;char ch=getchar();
		while (!isnum(ch)){if (ch=='-') f=-1;ch=getchar();}
		while (isnum(ch)){x=x*10+ch-48;ch=getchar();}
		return x*f;
	}
	inline void out(int x,char ch){
	    if(x<0){putchar('-');x=-x;}
	    if(x>9)out(x/10,'/');
	    putchar(x%10+'0');
	    if(ch=='l')putchar('\n');
	    if(ch=='s')putchar(' ');
	}
}

using namespace std;
using namespace IO;

inline int slen(string s){return s.size();}

const int mod = 998244353;

int n = read(), k = read();
signed main()
{
	out(((n * n - 1 + mod) % mod * (k % mod) + 1) % mod, 'l');//对于(n*n-1)需要先加模再取模
	return 0;
}

```


---

## 作者：int08 (赞：2)

# 前言

这几乎是我做过的最简单的月赛第一题了。

# Solution
## 1、方法
根据题中的要求，每次分割需要把位于图形中右下角的矩形继续分割成 $n×n$ 的矩形。

换句话说，每次分割都会把右下角的一个图形分割成 $n×n$ 个图形，所以每次分割都会增加 $n×n-1$ 个图形。

因为有 $k$ 次分割，所以总共增加了 $k×(n×n-1)$ 个图形。再加上初始的一个图形，共有 $k×(n×n-1)+1$ 个图形，这就是本道题的答案。
## 2、取模
根据题目中的数据范围和我们的答案，得知开超长整型会溢出，所以需要取模。

对此我们有3个方法：~~第一个是高精度，~~ 第二个是开 $128$ 位整型，第三个是利用余数的可乘性，每次取余就OK了。
# AC代码

```
#include<bits/stdc++.h>
using namespace std;
long long n,k,ans;
int main()
{
	cin>>n>>k;
	cout<<(((n*n-1)%998244353)*k%998244353+1)%998244353;
	return 0;
} 
```

# The End.

---

## 作者：Eason_AC (赞：2)

## Content
给定一个正方形，现在进行 $k$ 次切割，每次切割将右下角的矩形继续切割成 $n\times n$ 的矩形。求最后矩形的个数对 $998244353$ 取模后的值。

**数据范围：$1\leqslant n,k\leqslant 10^9$。**
## Solution
我们仔细看样例解释，不难发现，每一次切割之后，右下角从 $1$ 块矩形变成了 $n\times n$ 的矩形，矩形个数增加 $n^2-1$。由于这样的切割一共有 $k$ 次，再加上本来的一个正方形，我们可以推出答案为 $k\cdot(n^2-1)+1$。

这里稍微提一下取模的问题：一定要考虑所有可能超出数据类型范围的情况！两个数相加取一次模，两个数相乘取一次模，两个数相减先取模再加模数最后再取模（这是因为在 C++ 中，将一个负数 $x$ 对 $mod$ 取模之后的值，等于 $mod-x$ 对 $mod$ 取模之后的值，而且 $x$ 本身可能会超出数据类型范围），这些细节稍微一个不注意就可能导致整个程序出现错误。

具体细节见代码。
## Code
```cpp
namespace Solution {
	const int mod = 998244353;
	int n, k;
	
	void Main() {
		read(n, k);
		write((1ll * ((1ll * n * n % mod - 1 + mod) % mod) * k % mod + 1) % mod); 
        //先乘 1ll 是为了防止中间乘的时候超出数据类型范围导致溢出。
		return;
	}
}
```

---

## 作者：zct_sky (赞：2)

### Solution:
-----
每次分割，都会在原有的矩阵数上 $-1+n^2$，所以分割 $k$ 次后的矩阵数就是 $(n^2-1)\times k +1$。
### Code:
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll MOD=998244353;
ll n,k,ans; 
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    cin>>n>>k;
    cout<<((n*n-1)%MOD*k%MOD+1)%MOD;
	return 0;
}
```

---

## 作者：_cmh (赞：2)

[原题传送门~](https://www.luogu.com.cn/problem/P8152)

### $\texttt{Description}$

对一个正方形进行分割，每次将右下角那块分成 $n\times n$ 块。求 $k$ 次分割后图形中有几块矩形。

### $\texttt{Solution}$

读题可知：

- 第 $1$ 次分割，将图形分成了 $n\times n$ 块。

- 第 $2$ 次分割，从第 $1$ 次分割的右下角入手，分割成 $n\times n-1+n\times n$ 块。

- 第 $3$ 次分割，从第 $2$ 次分割的右下角入手，分割成 $2\times(n\times n-1)+n\times n$ 块。

以此类推，

- 第 $k$ 次分割，从第 $k-1$ 次分割的右下角入手，分割成 $(k-1)\times(n\times n-1)+n\times n$ 块。

化简原式，将其取模，得最终答案为：

$$(k\times(n^2-1)+1)\ \bmod998244353$$

注意开 long long.

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;
int main(){
	long long n,k;
	scanf("%lld%lld",&n,&k);
	printf("%lld",((n*n-1)%mod*k+1)%mod);
    return 0;
}
```


---

## 作者：_easy_ (赞：1)

# 思路
通过题目给出的图片，我们可以分析出如下结论：
![](https://cdn.luogu.com.cn/upload/image_hosting/cyemqw87.png)
在第一次分割后，正方形个数变为了 $\texttt{4}$ 个正方形，增加了 $2 \cdot 2 - 1$ 个正方形。
![](https://cdn.luogu.com.cn/upload/image_hosting/9n3c3te2.png)
在第二次分割后，正方形个数变为了 $\texttt{7}$ 个正方形，增加了 $2 \cdot 2 - 1$ 个正方形。

不难发现，每次分割后增加的个数都是相同的，均为 $n \cdot n - 1$ 个正方形。于是可以推出最后的公式。

**结论:**最后的正方形个数为 $1+k*(n \cdot n-1)$ 个。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k;//要开long long，不然乘的时候要炸
int main(){
	cin>>n>>k;
	long long s=n*n-1;//用变量来表示，方便取模
	s%=998244353;//取模
	k%=998244353;//同上
	cout<<(1+k*s%998244353)%998244353;//按照公式输出，记得取模
	return 0;
}
```

---

## 作者：int127 (赞：1)

找规律题。

容易发现，每次分割增加 $n^2-1$ 个方格，最后剩下一个方格加上去即可。

答案即为 $[k(n^2-1)+1]\bmod 998244353$。

```python
n,k=map(int,input().split())
print(int(k*(n*n-1)+1)%998244353)
```

---

## 作者：FFTotoro (赞：1)

观察题目发现，每一次分割，小矩形总个数会乘 $2$ 再减 $1$；第一次分割后矩形的总个数为 $n^2$ 。

由此我们可以得到，第 $k$ 次分割后，矩形个数为 $n^2\times k -k+1$。

又因为结果需要取模，所以每运算一次就取一次模。

放代码：

```cpp
#include<iostream>
using namespace std;
typedef unsigned long long ull;
const int p=998244353;
int main(){
  ull n,k; cin>>n>>k;
  ull x=1ull*(n*n%p)*(k%p)%p;
  cout<<(x%p-k%p+1)%mod;
  return 0;
}
```

---

## 作者：ReeChee (赞：1)

# Problem
将一个矩形的右下角分割成 $n\times n$ 的矩形，分割 $k$ 次，求剩余矩形的数量。

# Solution
每次分割的时候只分割右下角的部分，其余的部分将保留，因此每次分割的时候，矩形增加的数量为 $n\times n-1$ ，分割 $k$ 次后再 $+1$ 即可。

如样例 $1$ 所示，第一次分割增加的矩形如蓝色所示，答案增加 $2\times 2-1$ ，第二次分割增加的矩形如黄色所示，答案增加 $2\times 2-1$ ，最后再 $+1$ 并取模 $998244353$ ，即可得到答案 $7$ 。

由此可以得到总方程：

$$

[( n\times n-1 )\times k+1 ] \mod 998244353

$$

由于多模小数比少模大数更快，更近一步可以得到：

$$

\{[(n\times n-1)\mod 998244353 ]\times [k\mod 998244353] +1\}\mod 998244353

$$

![样例](https://cdn.luogu.com.cn/upload/image_hosting/x0oq2xm3.png)

# Code
```cpp
#include <cstdio>
typedef long long ll;
const int MOD=998244353;
ll n,k;
int main(){
    scanf("%lld%lld",&n,&k);
    printf("%lld",((n*n-1)%MOD*k%MOD+1)%MOD);
    return 0;
}
```

# Extra
由于涉及到 $n\times n-1$ 且 $1\leq n,k \leq 10^{9}$ ，所以要开 long long 。

---

## 作者：bbbzzx (赞：1)

# 题意
把一个矩形的最右下角的单个矩形分割成 $n \times n$ 个单个矩形，分 $k$ 次，求能分成多少个单个矩形，结果对 $998244353$ 取模。
# 解法
要分 $k$ 次，每次只有一个是要再次分割的，因此我们每次只需计算 $n^2-1$ 个矩形，乘以 $k$ 次，但最后一层的右下角不需要分割，所以我们还要加上最后剩下的一个，公式为 $(n^2-1) \times k+1$。
### 注意：不要忘记取模！
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n,k;//要开long long
    cin>>n>>k;
    cout<<(((n*n-1)%998244353)*k+1)%998244353;//要取模两次
}
```
$End$

---

## 作者：dd_d (赞：1)

[更好的阅读体验](https://www.cnblogs.com/dd-d/p/15891175.html)
### Sol  
由题意可得，对于一次切割，会把一个矩形分成 $n \times n$ 个矩形，所以每次切割会多出 $n \times n-1$ 个矩形，那么答案即为 $k \times (n \times n-1)+1$。
### Code
```cpp
//LYC_music yyds!
#include<bits/stdc++.h>
#define IOS ios::sync_with_stdio(0)
#define lowbit(x) (x&(-x))
#define int long long
using namespace std;
inline char gc()
{
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
int read()
{
	int pos=1,num=0;
	char ch=getchar();
	while (!isdigit(ch))
	{
		if (ch=='-') pos=-1;
		ch=getchar();
	}
	while (isdigit(ch))
	{
		num=num*10+(int)(ch-'0');
		ch=getchar();
	}
	return pos*num;
}
void write(int x)
{
	if (x<0)
	{
		putchar('-');
		write(-x);
		return;
	}
	if (x>=10) write(x/10);
	putchar(x%10+'0');
}
void writesp(int x)
{
	write(x);
	putchar(' ');
}
void writeln(int x)
{
	write(x);
	putchar('\n');
}
const int mod=998244353;
int n,k;
signed main()
{
	n=read(); k=read();
	writeln((k*((n*n-1+mod)%mod)+1)%mod);
}





```

---

## 作者：user470883 (赞：1)

## 思路：

数学题。

根据观察样例，每次在正方形右下角切，其实下面的图可以更形象的解释出来，如果我们不进行面积的考虑，那么其公式就应该是 $k\times 3+1$，然而给了 $k$，我们考虑到切一刀下去，就会增加 $n^2-1$ 个正方形，做了 $k$ 次，用 $(n^2-1) \times k$，最后 $+1$ 即可。

公式：$(n^2-1) \times k+1$。

**注意事项（坑点）：**

1. 要开 `long long`。
2. 一开始看题不要太关注“边长为 $1$”，因为实际它是给了您变成的。
3. 不要忘记取模，能取得地方都取一下，要不然容易拿不到满分。

## AC CODE:
```
#include<bits/stdc++.h>
#define MOD 998244353
#define INF 2000000000
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	long long n,k;
	cin >> n >> k;
	cout <<(((n*n-1)%MOD)*k+1)%MOD;
	return 0;
}

/*Things to check before submit:
1. did you forget long long ?
2. did you still CE?
3. = or == , n or m ,++ or -- , i or j , > or >= , < or <=
4. If contains "not", why not Reverse thinking or few affect?
5. is there anything extra to output?
6. keep it simple
7. can part of the code can with c++function replace?
8. smile while submit the code*/
```

有问题私聊我哦！


---

## 作者：HappyCode (赞：1)

### 思路
我们发现每次操作都会去除右下角的 $1$ 个格子，并在右下角添加 $n \times n$ 个格子。  
经过 $k$ 次操作后，共减少了 $k$ 个格子，增加了 $n \times n \times k$ 个格子，所以最终格子的数量是 $1-k+n \times n \times k$。
### 提醒
一定要记得 $\bmod\ 998244353$。  
还要开 `__int128` 或写高精度，因为答案可能会爆 `unsigned long long`。
### 代码
```cpp
#include<cstdio>
__int128 n,k,ans=1;
inline __int128 read(){
    __int128 s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch > '9'){
        if(ch == '-'){
            w=-1;
        }
        ch=getchar();  
    }
    while(ch >= '0' && ch <= '9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
inline void write(__int128 x){
    if(x<0){
    	putchar('-');
		x=-x;
	}
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
}  
int main(){
    n=read();
    k=read();
    ans=ans-k+n*n*k;
    write(ans%998244353);
    return 0;
}
```
### 更新日志
upd 2022.2.18：快写竟然写错了，改了一下。

[在这里，你可以获得更好的阅读体验。](https://happycodehc.github.io/blog/luogu8152)

---

## 作者：lsj2009 (赞：0)

## 题目大意
<https://www.luogu.com.cn/problem/P8152>。
## 思路
结合题意，每次划分时我们都会制造出一个新的 $n\times n$ 正方形，同时也会占据原来的一个矩阵。

## code:
```cpp
#include<bits/stdc++.h>
#define int long long //十年 OI 一场空，不开 long long 见祖宗
using namespace std;
const int MOD=998244353;
signed main() {
	int n,k;
	scanf("%lld%lld",&n,&k);
	int ans=1; //最初有一个矩阵
	while(k--)
	    ans=(ans+n*n%MOD-1%MOD+MOD)%MOD; //可能出现负数，要 +MOD
	printf("%lld",ans);
	return 0;
}
```
不过由于 $k$ 过大，所以上述程序会 ``TLE``，考虑到我们 $+$ 了 $k$ 次 $n\times n$，$-$ 了 $k$ 次 $1$，同时最开始还有一个矩阵，故答案为 $k\cdot n^2-k+1$。
## code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=998244353;
signed main() {
	int n,k;
	scanf("%lld%lld",&n,&k);
	printf("%lld",(k%MOD*n%MOD*n%MOD+1%MOD-k%MOD+MOD)%MOD);
	return 1;
}
```

---

## 作者：lelml (赞：0)

非常简单的公开赛签到题。

## 思路:

每一次分割时，都会多 $n×n$ 个矩形，少 1 个矩形。

所以每一次会多 $n×n-1$ 个矩形。

加上原来的一个可得答案为 $(n×n-1)×k$。

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n,k;
    cin>>n>>k;
    cout<<(1+((n*n-1)%998244353)*(k%998244353))%998244353<<endl;//每一个数都要取模，如果只在最后取可能会爆long long
    return 0;
}
```


---

## 作者：江户川コナン (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8152)

分析题意易得，每次操作我们就是将图中这么多矩形中选一个，将其变成 $ n\times n $  个矩形，也就是每一次都去掉了一个原矩形，又加上 $n\times n $个矩形，**即每次操作增加 $ n^2 -1$ 个矩形**，而一共进行了 $k$ 次操作。

设第 $i$ 次操作后图中有 $C_i$ 个矩形（显而易见 $C_0 = 1$ ），则根据上述分析，易得：$ C_i = 1+(n^2-1)\cdot i $，则 $ C_k = 1+(n^2-1)\cdot k $。

据此就很容易写出代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long // n*n-1可能爆int,所以要用long long
const int mod=998244353;
signed main(){
    int n,k;
    cin>>n>>k;
    cout<<(1+(((n*n-1)%mod)*k%mod))%mod;//记得取模
    return 0;
}
```

蒟蒻第一次写题解，求管理大大通过~~~

---

## 作者：JackMerryYoung (赞：0)

# 前言

~~白痴红题，不过忙着打 Div-1 了，没写...~~

一开始还以为要快速幂，结果观察了样例就明白了...

# 正文

我们可以牺牲 $1$ 个矩阵，构造出 $N^2$ 个矩阵。

分割了 $K$ 次，则有 $K - 1$ 个矩阵被牺牲了，造出了 $KN^2$ 个矩阵。

因此输出 $KN^2 - K + 1$ 即可。注意取模。

# 代码



~~你们最想要的..~~ 

Talk is$\color{white}\text{n't}$ cheap, $\color{white}\text{Don't}$ show me the code...

``` cpp
// Problem: P8152 「PMOI-5」破译の论
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8152
// Memory Limit: 128 MB
// Time Limit: 1000 ms

#include <bits/stdc++.h>
#define MOD 998244353
using namespace std;

long long N, K;

signed main()
{
	cin >> N >> K;
	cout << ((((N % MOD * N % MOD) % MOD * K % MOD) % MOD - K % MOD) % MOD + 1) % MOD;
	return 0;
}
```

# 后言

我无话可说，人均 AC 的题没写...

---

## 作者：TernaryTree (赞：0)

## 题目大意

对正方形进行 $ k $ 次分割，每次分割都将最右下角的矩形分为 $n\times n$ 的小正方形。求最终正方形个数。

## 题目分析

一道纯数学题。

我们先不看每次分割后最右下角的小正方形。

设 $n = 2$。

一开始未分割时，除去本身（最右下角），有 $0$ 个正方形。

那么进行 $1$ 次分割后，除去最右下角的小正方形，有 $2^2 - 1 = 3$ 个正方形。

进行 $2$ 次分割后，除去最右下角的小正方形，有上一次的 $3$ 个正方形与右下方的 $2^2 - 1 = 3$ 个正方形，共 $6$ 个。

进行 $3$ 次分割后，除去最右下角的小正方形，有上一次的 $6$ 个正方形与右下方的 $2^2 - 1 = 3$ 个正方形，共 $9$ 个。

不难看出，这是一个等差数列 $s$，公差为 $n^2-1$，$s_k = (n^2-1)k$。

最后别忘了加上最右下角的小正方形：**（若无特殊说明，下文中 $p$ 均指 $998244353$）**

$$((n^2-1)k +1) \bmod p$$

## 题目坑点

$n,k$ 都是 $10^9$ 的，如果最后才进行取模，即使开 `long long` 也会爆。

需要余数定理中的乘法原理。

乘法原理，就是形如

$$((x \bmod m) \times (y \bmod m))\bmod m \Leftrightarrow xy \bmod m$$

顺便说一下加法原理，跟乘法原理差不多，就是符号变了：

$$((x \bmod m) + (y \bmod m))\bmod m \Leftrightarrow (x+y) \bmod m$$

这些原理在一些需要取模但是数据很大的情况下很好用。尤其是形如快速幂一类的。

那么本题的式子就可以进行简化了：

$$((((n\bmod p)^2 \bmod p) -1)k \bmod p +1) \bmod p$$

## 完整代码

```cpp
#include <bits/stdc++.h>

using namespace std;

long long n, k;

int main() {
    cin >> n >> k;
    cout << ((((n % 998244353) * (n % 998244353) - 1ll) % 998244353) * k + 1ll) % 998244353;
    return 0;
}
```

（比赛的时候为一道红题调了半小时的屑 $\tt ternary\_tree$）

---

## 作者：Aiopr_2378 (赞：0)

### 题目大意

现有一个正方形，要求你对他进行 $k$ 次操作，每次操作将把一个正方形分成 $n\times n$ 个小正方形，求总正方形数。

### 解题思路

~~这应该是一个小学的找规律题~~

#### Part 1

显然这是一道找规律题，下面进行规律探索

若 $n=2$：

- 当 $k=1$ 时，得到 $ans=n\times n=4$；

- 当 $k=2$ 时，得到 $ans=last\_ans-1+n\times n=3+4=7$；

- 当 $k=3$ 时，得到 $ans=last\_ans-1+n\times n=6+4=10$；

- $\cdots$

不难发现，随着 $k$ 的增加， $ans$ 只需要在上一个结果上进行减一后再加上 $n^2$，即：

$$ans=last\_ans-1+n^2$$

不要忘记取模操作。

#### Part 2

当然，以上方法只能得到部分分，想要得到满分，要对公式进行一定变化。

通过以上分析不难得出：

$$ans=k(n^2-1)+1$$

根据平方差公式得出：

$$ans=k(n+1)(n-1)+1$$

然后就可以快乐地写程序啦

还有，建议每进行一次运算都要取模一次，因为$1 \leq n,k \leq10^9$，所以直接在 `long long` 的范围内进行乘法运算后取模是可以的。

### 参考代码

Code time!

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k;
long long ans;
const int mod=998244353;
int main(){
    scanf("%d%d",&n,&k);
    (ans=k)%=mod;//不要忘记取模
    (ans*=(n+1)%mod)%=mod;//每次运算后都要取模
    (ans*=(n-1)%mod)%=mod;
    (ans+=1)%=mod;
    printf("%lld",ans);
    return 0;
}
```

此篇终
 

---

## 作者：LYqwq (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8152)

# 题目大意

有一个正方形，要进行 $k$ 次分割，每次分割需要把位于当前图形右下角的矩形继续分割，每次分割需要把图形分割成 $n \times n$ 个正方形。输出进行 $k$ 次分割后，一共有多少个矩形。

样例解释：

输入：`2 2`。

输出：`7`。

进行 $2$ 次分割，每次将右下角矩形分割为 $2 \times 2$ 的矩形。

第一次分割，由于只有一个矩形，所以右下角矩形即为此矩形。分割前后如下： 

![](https://cdn.luogu.com.cn/upload/image_hosting/tdlnmb52.png)

变为

![](https://cdn.luogu.com.cn/upload/image_hosting/cyemqw87.png)

接下来进行第二次分割，将右下角矩形进行分割，分割为如下图形：

![](https://cdn.luogu.com.cn/upload/image_hosting/9n3c3te2.png)

此图形包含 $7$ 个矩形，因此答案为 $7$。

（样例解释直接从题面上搬下来的）

# 思路

看到那 $10^9$ 的数据范围，就知道了这题要 $\mathcal{O}(1)$ 求出答案。

以样例为例，很容易发现，下图中蓝色，绿色部分分别为每次分割时一定会多分出来的矩阵，每次分割出来的都是 $n \times n-1$ 个。

发现了这个，这题就变得水的不能再水了。

![](https://cdn.luogu.com.cn/upload/image_hosting/0n1v3hb1.png)

一共要分割 $k$ 次，那么除去图中白色部分，剩余的矩阵就是 $(n \times n-1) \times k$ 个，最后一次分割会多出一个类似图中白色部分的矩阵，再将它加上，就得到了最终答案。

~~感谢 PMOI，让我白嫖了这么多估值（）~~

还有一个，就是注意实时取模 $998244353$，~~这个数读起来好顺口。~~

# 代码

```cpp
#include <iostream>
using namespace std;
typedef long long ll; // 要开 long long
const int mod=998244353;
ll n,k,ans;

int main(){
	cin >> n >> k;
	cout << (((((n*n)%mod)-1)*k)%mod+1)%mod << endl; // 注意实时取模
	return 0;
}
```



---

## 作者：rai1gun (赞：0)

### 1.题目思路

一次分割会多出 $n \times n$ 个矩形，同时也会少一个矩形（除第一次外）。我们可以根据这个推论写出代码。

### 2.题目代码

```c++
#include<bits/stdc++.h>
#define db double
#define ll long long
using namespace std;
inline int read(){
	int now=0,nev=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')nev=-1;c=getchar();}
	while(c>='0'&&c<='9'){now=(now<<1)+(now<<3)+(c&15);c=getchar();}
	return now*nev;
}
const int Mod = 998244353;
ll a,b,ans=0;
int main(){
	a=read(),b=read();
	ans=((a*a)%Mod+((a*a-1)%Mod)*(b-1))%Mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Asimplename (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8152)

简单的找规律题，很容易发现每次分割后会减少一个原来右下角的大矩形，增加了 $n\times n$ 个新分割出来的小矩形，所以每次分割增加的矩形个数就是$n\times n - 1$ 个矩形。那么 $k$ 次分割就有 $1 + k \times (n \times n - 1)$ 个矩形，简化后为 $n^{2}\times k - (k - 1)$ 个矩形。

由于数据范围很大，所以可以开 long long 并每次乘的时候取模一次。

然后就上代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MOD 998244353
long long n = 0;
long long k = 0;
long long ans = 0;
int main () {
	cin >> n >> k;
	ans = n * n % MOD;
	ans = ans * k % MOD;
	ans = ans - (k - 1) % MOD;
	cout << ans;
	return 0;
} 
```

---

## 作者：sh7adow_ (赞：0)

upd on 2022.2.14 更新了新方法
## ~~简明的~~题意
将一个矩形先分成 $n \times n$ 个，再将右下角的矩形再分成 $n \times n$ 个。如此重复操作 $k$ 次，求最后有几个矩形。

## $\rm Solution$

1. 首先先解决 $k=1$ 时的数据。显而易见，操作一次（即 $k=1$ ）分割成了 $n \times n$ 个矩形。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n,k;
    cin>>n>>k;
    cout<<n*n;
}
```
2. 那么当 $k\geq1$ 的时候呢？还是一样，只是每分割 $k$ 次，就会有  $k-1$ 个矩形被重复计算，减去它们即可。可以推出这个公式：$\rm ans=n\times n\times k-(k-1)=n^2k-k+1$ 。直接代入计算，得出答案。

错误解法~~我考场上的思路~~：用 for 做。很容易发现这不符合时间复杂度。会 TLE 两个点。

正解（核心部分）：
```cpp
    __int128 n,k;
    n=read();k=read();
    qput((n*n*k-k+1)%998244353);
    
```
其实， `__int128` 可以改为 `long long` ，一边乘一边取模，这样子用 `longlong` 可以存下。

就这些。谢谢观看！

---

## 作者：Nygglatho (赞：0)

首先，我们发现分割一次会出现 $n^2$ 个正方形，但是需要拿出最后一个继续分割，那么还有 $n^2 - 1$ 个正方形。

也就是说，分割 $k - 1$ 次会有 $k \times (n^2 - 1)$ 个正方形。

但是到第 $k$ 次时，分割结束以后**不需要**再拿出正方形了，所以不需要减 $1$。

那么也不需要判断了，只需要最后把减少了的正方形再补回来就行了，所以最后需要加上 $1$。

由于数据很大，需要开 `__int128`。

Code：
```cpp
int main() {
    n = rd(); k = rd();//手写读入
    __int128 ans = (((n % 998244353) * (n % 998244353) - 1) * (k % 998244353) + 1) % 998244353;
    //分割时需要减 1，但是到第 k 次时不需要减 1，把 1 加回来
    wt(ans);//手写输出
}
```

---

## 作者：lucas_jy (赞：0)

[或许更好の阅读体验](https://www.luogu.com.cn/blog/AnOutsiderOfLuogu/solution-p8152)

### 题目解析
~~非常水的一道题~~

每一次切割会多出 $ n^{2}-1 $ 个矩形，切割 $ k $ 次就会多出 $ k\cdot \left ( n^{2}-1 \right ) $ 个，也就是 $ k\cdot n^{2}-k $ 。

一开始有 $ 1 $ 个矩形，所以最后答案是 $ \left ( k\cdot n^{2}-k+1 \right ) \bmod 998244353 $。

但是这就会有个问题

对于 $ 100\% $ 的数据，$ 1 \leq n,k \leq 10^9 $。

所以要在每一次乘法时模 $ 998244353 $ 。

最后，为了避免负数，应该在进行一次判断。

代码就出来了！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
const int MOD=998244353;
int main(){
    cin>>n>>k;
    cout<<(((k*n)%MOD*n)%MOD-k+1+MOD)%MOD<<endl;
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/69342610)

这是作者的第 `1` 篇题解，希望大家多提意见，谢谢！

---

## 作者：liuxy1234 (赞：0)

~~第一眼看到这题时我也是直接写了一个暴力交上去~~

这题其实就是一道特别简单的数学题，每切一次就会增加 $n ^ 2 - 1$ 个小矩形。知道了这些，我们就可以开始写代码了。

上代码。


```cpp
#include <bits/stdc++.h>
#define int  long long
using namespace std;

signed main(){
	std::ios::sync_with_stdio(0);
	int n, k;
	cin >> n >> k;
	cout << (((n * n - 1) % 998244353 * k) + 1) % 998244353;
	return 0;
}

```


---

## 作者：Land_ER (赞：0)

## 题意简述
- 开始时有 $1$ 个正方形，进行 $k$ 次操作，每次将右下角一个正方形分成 $n\times n$ 个正方形，求最后的正方形数量。
- 答案对 $998244353$ 取模。

## 解题思路
每次操作可以看做先减去右下角的一个正方形，然后再加上 $n\times n$ 个小正方形。设操作前有 $a$ 个正方形，$1$ 次操作后就有 $a+n\times n-1$ 个。

一开始时有 $1$ 个正方形，$k$ 次操作后就有 $1+k(n^2-1)$ 个。

## 代码实现
```python
a = input().split()
n = int(a[0])
k = int(a[1])
print((1 + k*(n*n-1)) % 998244353)
```

---

## 作者：Mars_Dingdang (赞：0)

小学奥数题……

## 题目描述
现在有一个边长为 $1$ 的正方形，现在要进行 $k$ 次分割，每次分割需要把位于图形中右下角的矩形继续分割成 $n \times n$ 的矩形，求分割完成后所有矩形的个数。

## 大体思路
首先，每次操作相当于将一个矩形分割成 $n^2$ 个，故单次操作增加 $n^2-1$ 个。又因为一共 $k$ 次操作，所以总共增加了 $k(n^2-1)$ 个，再加上初始的 $1$ 个即可。

$n, k\le 10^9$，使用 `long long` 及时取模即可。由于有减法，最后答案用 `((...) % mod + mod) % mod` 形式保证答案为正。

## 完整代码
```cpp
ll n, k;
int main () {
	read(n); read(k);
	n -= (n >= mod ? mod : 0);
	k -= (k >= mod ? mod : 0); // 可以提前减一下
	write((1 + k * ((n * n) % mod - 1) % mod + mod) % mod);
	return 0;
}
```

---

## 作者：ForeverCC (赞：0)

这道题的核心是推递推关系。

每次分裂的过程可以看做这样：

- 占用一个正方形，总数减一。
- 分裂出 $n^2$ 个正方形，总数加 $n^2$。

因为有 $k$ 次分裂，所以最终答案就为 $(n^2 - 1) \times k$。

由于范围较大，所以每一次计算都要取模。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,k;
signed main(){
	scanf("%lld%lld",&n,&k);
	printf("%lld\n",((n*n-1)%mod*k+1)%mod);
	return 0;
}
```


---

## 作者：瀛洲仙子 (赞：0)

这道题数图形分割的数学题。分割 $k$ 次，每一次分割成 $n \times n$ 个小正方形。
### 样例分析
首先分析样例。由于样例 1 在题目中分析过，于是不在多解释。   
样例输入
```cpp
5 3
```

* 首先第一步，将整个图形分割成 $5 \times 5$ 个小正方形，现在有 25 个小正方形。
* 第二步，将最左下角的现正方形分割成 $5 \times 5$ 个小正方形，增加 $5 \times 5 - 1$ 个小正方形，现在有 49 个小正方形。
* 第三步，将最左下角的小正方形分割成 $5 \times 5$ 个小正方形，增加 $5 \times 5 - 1$ 个小正方形，现在有 73 个小正方形。

```cpp
73
```
### 思路分析
可以用**模拟**来实现。
首先输入数据，不用太多解释。
```python
n,k=input().split(' ')
n,k=int(n),int(k)
```
接下来将如何模拟。
我们通过上面的分析，可以知道，每次将会增加 $n \times n$ 个现正方形，但是不能忘记**最右下角的小正方形被分割了**，所以还得减去一个。
具体模拟代码如下。
```python
summ=0
while k:
		k=k-1
        summ=summ+n*n-1
```
就是如此简单。最后一步输出，不要忘记取余。
```python
print(summ%998244353)
```
另有一种更简单的方法，思路和模拟相似，但是只需更短的代码就能实现。
```python
n,k=input().split(' ')
print(int(n)**2+(int(k)-1)*(int(n)**2-1))
```
### 完整代码
根据以上思路，提供两种无注释代码。
方法 1：
```python
n,k=input().split(' ')
n,k=int(n),int(k)
summ=0
while k:
		k=k-1
        summ=summ+n*n-1
print(summ%998244353)
```
方法 2：
```

n,k=input().split(' ')
print(int(n)**2+(int(k)-1)*(int(n)**2-1))
```
__珍爱生命，远离抄袭！__

---

## 作者：basachenboming (赞：0)

**思路**

一道简单数学题，已知了 $n,k$ 。

由于题意不好理解，所以用样例来解释。

输入样例

```cpp
2 2
```

输出样例

```cpp
7
```

分割前为 $1$ 个矩形，第一次分割后为 $1+3=4$ 个，第二次分割后为 $4+3=7$ 个。所以答案为 $7$ 。

将它一般化，每次分割后会多 $n^2-1$ 个矩形，而要分割 $k$ 次，所以答案为 $1+k(n^2-1)$ 拆开就是 $1+kn^2-k$ 。

**AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m;
	cin>>n>>m;
	unsigned long long int ans=1,tot=1;
	tot*=m;
	tot%=998244353;
	tot*=n;
	tot%=998244353;
	tot*=n;
	tot-=m;
	tot%=998244353;
	ans+=tot;
	ans%=998244353;
	cout<<ans;
	return 0;
}
```


---

## 作者：Unnamed114514 (赞：0)

看看样例解释，你就会发现，每次增加一个 $n^2$ 的矩形，就会覆盖原来一个矩形。

也就是说，除了最后一次，前面每次都会有一个矩形被覆盖覆盖，这个位置就是右下角。所以，前 $k-1$ 次会增加 $n^2-1$ 个矩形，最后一次由于没有覆盖，所以就是 $n^2$ 个矩形。

注意 $(n^2-1)\times (k-1)$ 要爆 `long long` ，所以 $n^2$ 还要模 $998244353$。

时间复杂度 $O(1)$，空间复杂度 $O(1)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,sum;
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return res;
} 
int main(){
	n=read(),k=read();
	printf("%lld\n",((n*n-1)%998244353*(k-1)%998244353+n*n)%998244353);
	return 0;
}
```

---

## 作者：违规用户名gAGt8$%z (赞：0)

## 思路
不难看出，一开始为 $1$ ， 后面每次块数增加 $n×n-1$ （因为每次增加 $n × n$ 并且占用原来的 $1$ 块） ， 所以公式就是 $1+k × (n × (n-1))$

tips: 10 年 oi 一场空，不开 longlong 见祖宗！

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int n,k;
signed main(){
	cin>>n>>k;
	n=(n*n-1+mod)%mod,k%=mod;
	cout<<(n*k+1)%mod;
}
```


---


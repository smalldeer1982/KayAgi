# [COCI 2013/2014 #3] RIJEČI

## 题目描述

一天，Mirko 发现了一个非常大的屏幕，这个屏幕上一开始只有一个字母 $\texttt{A}$。Mirko 在这个屏幕旁边找到了一个按钮。当他按一次时，屏幕上的字母变成了 $\texttt B$。随后他又按了若干次，屏幕上依次显示 $\texttt{BA}$、$\texttt{BAB}$、$\texttt{BABBA}$、……这时他才发现，每当他按一次按钮，屏幕上的字母 $\texttt B$ 变为 $\texttt{BA}$，而字母 $\texttt A$ 变为 $\texttt{B}$。

现在，Mirko 已经按了 $k$ 次按钮，他想知道屏幕上分别有多少个字母 $\texttt A$ 和字母 $\texttt B$。

## 说明/提示

**【数据范围与限制】**

对于 $20\%$ 的数据，保证 $k\leqslant 10$。  
对于所有数据，$1\leqslant k\leqslant 45$。

**【题目来源】**

本题来源自 **_[COCI 2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 3](https://hsin.hr/coci/archive/2013_2014/contest3_tasks.pdf) T1 RIJEČI_**，按照原题数据配置，满分 $50$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
1```

### 输出

```
0 1```

## 样例 #2

### 输入

```
4```

### 输出

```
2 3```

## 样例 #3

### 输入

```
10```

### 输出

```
34 55```

# 题解

## 作者：力巴尔 (赞：92)

[题目传送门](https://www.luogu.com.cn/problem/P8241)

这道题显然是让我们找规律。

不妨先模拟一下：

| $k$ | 屏幕的输出 | $\texttt A$ 的个数 | $\texttt B$ 的个数 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 1 | B | 0 | 1 |
| 2 | BA | 1 | 1 |
| 3 | BAB | 1 | 2 |
| 4 | BABBA | 2 | 3 |
| 5 | BABBABAB | 3 | 5 |
| 6 | BABBABABBABBA | 5 | 8 |

不难看出，每个字母的个数是呈斐波那契数列上升的。

下面给出本蒟蒻的证明过程：

首先设当 $k = i$ 时 $\texttt A$ 的个数为 $a_i$，$\texttt B$ 的个数为 $b_i$。

根据题目“每当他按一次按钮，屏幕上的字母 $\texttt B$ 变为 $\texttt{BA}$，而字母 $\texttt A$ 变为 $\texttt{B}$”可知：$a_i = b_{i - 1}$，$b_i = b_{i - 1} + a_{i - 1} = b_{i - 1} + b_{i - 2}$，则 $a_i = b_{i - 2} + b_{i - 3} = a_{i - 1} + a_{i - 2}$，即可得到上述结论。

所以 $a_i = fib_{i - 1}$，$b_i = fib_{i}$。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int k, a[50];
    cin>>k;
    a[0] = 0;
    a[1] = 1;
    a[2] = 1;
    for (int i = 3;i <= k;i++)
        a[i] = a[i - 1] + a[i - 2];
    cout<<a[k - 1]<<" "<<a[k];
}
```

### 都看到这了，点个赞再走？


---

## 作者：Dream_weavers (赞：20)

[题目传送门](https://www.luogu.com.cn/problem/P8241)

## 题意

最初字符串中有 $1$ 个字母 $\mathtt{A}$，定义一次变换为：将字符串中的 字母 $\mathtt{A}$ 变为 $\mathtt{B}$，字母 $\mathtt{B}$ 变为 $\mathtt{BA}$（**这两个动作要同时进行**）。问进行 $k$ 次变换后字母 $\mathtt{A}$ 和 $\mathtt{B}$ 各有多少个。

## 思路

用 $cnta$ 记录字母 $\mathtt{A}$ 的数量，$cntb$ 记录字母 $\mathtt{B}$ 的数量。

从题意中可以发现，在一次变换中：字母$\mathtt{A}$ 都变为 $\mathtt{B}$，数量由**原来** 字母 $\mathtt{B}$ 决定，而字母 $\mathtt{B}$ 增加**原来** 字母 $\mathtt{A}$ 的数量。即 $cnta\gets cntb,cntb\gets cntb+cnta$。

### 注意

因为变换中的两个动作要**同时进行**，变换前的数据**容易丢失**。所以要再建两个变量，存储变换后的数值，赋值给 $cnta$ 和 $cntb$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,a,b,cnta=1,cntb=0; 
int main(){
	scanf("%d",&k);
	while(k--){//进行k次变换
		a=cntb,b=cntb+cnta;//用新两个变量存储变换后的数值
		cnta=a,cntb=b;//给cnta和cntb赋值
	}
	printf("%d %d",cnta,cntb);
    return 0;
}

```

---

## 作者：看什么看 (赞：5)

我们记 $A_i$ 为按下第 $i$ 次按钮后 `A` 的数量，$B_i $ 为按下第 $i$ 次按钮后 `B` 的数量。

不难发现，按下第 $i$ 次按钮后的情况与按下第 $(i-1)$ 次按钮的情况有关。`A` 只能由 `B` 生成，而 `B` 可以由 `A` 和 `B` 生成，因此我们可以推出以下的递推式：

$A_i = B_{i-1}$

$B_i = A_{i-1} + B_{i-1}$

边界条件是 $A_0 = 1$，$B_0 = 0$。（即按下第 $0$ 次按钮时的情况）

最终只需要输出 $A_k$ 和 $B_k$ 就行了。

Code:
```cpp
#include<iostream>
using namespace std;
int A[50], B[50];

int main(){
	A[0] = 1, B[0] = 0;
	int k;
	cin >> k;
	for (int i = 1;i <= k;++i)
		A[i] = B[i-1], B[i] = A[i-1] + B[i-1];
	cout << A[k] << " " << B[k];
	return 0;
}
```

观察到 $A_i$ 和 $B_i$ 都只与 $A_{i-1}$ 和 $B_{i-1}$。有关，所以我们可以把递推式改写为：

$A_{i \bmod 2} = B_{(i-1) \bmod 2}$

$B_{i \bmod 2} = A_{(i-1) \bmod 2} + B_{(i-1) \bmod 2}$

Code:
```cpp
#include<iostream>
using namespace std;
int A[2], B[2];

int main(){
	A[0] = 1, B[0] = 0;
	int k;
	cin >> k;
	for (int i = 1;i <= k;++i){
		int now = i&1, pre = now^1; // now 是 i mod 2，pre 是 (i-1) mod 2
		A[now] = B[pre], B[now] = A[pre] + B[pre];
	}
	cout << A[k&1] << " " << B[k&1];
	return 0;
}
```

---

## 作者：可爱的小于 (赞：2)

**题目大意：** 原有一个字符串，其中的字符为 `A`，每经一次变化，其中的 `A` 变为 `B` ，`B` 变为 `BA`，求 $n$ 次变化后字符串中含有多少个 `A` 和 `B`。

思路如下：

**$1.$** 看一下样例，很像斐波那契数列，对吧？

**$2.$** 定义两个数组，用 $A_i$ 记录 `A` 的个数，用 $B_i$ 记录 `B` 的个数。

**$3.$** 由于 `A` 变成 `B` ，`B` 变为 `BA` ，则

> $A_i=B_{i-1}$

> $B_=A_{i-1}+B_{i-1}$

代码如下：

```cpp
#include <iostream>//头文件
using namespace std;
int n,a[46],b[46];///定义
int main()
{
    a[0]=1;
    b[0]=0;
    cin >> n;
    for(int i=1;i<=n;i++){//循环运算
        a[i]=b[i-1];//跟据公式进行推算
        b[i]=a[i-1]+b[i-1];
    } 
    cout << a[n] << " " << b[n] << endl;//输出
    return 0;
}
```

---

## 作者：skyskyCCC (赞：1)

**前言。**

计算题。

**分析。**

首先，我看到这题的第一反应是：又要找规律。

结果，找了进 $5$ 分钟也没找到。

那么，只好顺着题意写了。

考虑 $O(k)$ 的做法：

首先，定义两个变量记录 $A$ 与 $B$ 的数量，记录 $A$ 的变量需要初始化为 $1$，因为**这个屏幕上一开始只有一个字母 $\text{A}$**。

每当一次操作，屏幕上的字母 $\text{B}$ 变为 $\text{BA}$，而字母 $\text{A}$ 变为 $\text{B}$。就是说，在每次操作过后，屏幕上的 $B$ 会产生一个 $B$ 与一个 $A$，即 $A$ 的个数就是原先 $B$ 的个数。而 $B$ 的个数除了 $BA$ 中的，还有新产生的 $B$，就是 $A$ 变成的 $B$。那么，每次操作后，**个数 $A$ 为原先 $B$ 的个数，个数 $B$ 为原先 $B$ 的个数与原先 $A$ 的个数之和**。

具体证明过程见后记。

代码如下，仅供参考：
```
#include<algorithm>
#include<iostream>//其实用这一个就行
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int k;
int a=1,b;
int sum;//定义
int main(){
    ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);//以上三行均为加速代码，可省略
    std::cin>>k;
    for (int i=1;i<=k;i++){
        sum=a;//存贮A原来的个数
        a=b;//代入公式
        b+=sum;//同上
    }
    std::cout<<a<<" "<<b<<endl;
    return 0;
}
```
**后记。**

### 证明过程：

由题意可知：

操作后 $A$ 的个数为：$a_i-a_j+b_i=b_i$。

其中 $a_i$ 为 $A$ 原先个数，$a_j$ 为 $A$ 变化为 $B$ 的个数，$b_i$ 为 $B$ 原先个数。

操作后 $B$ 的个数为：$b_i+a_i=b_j$。

其中 $b_j$ 为 $B$ 的数量，$a_i$ 为 $A$ 变化为 $B$ 的个数，$b_i$ 为 $B$ 原先个数。


---

## 作者：DengDuck (赞：1)

一道水递推，

设 $f_{A_x}$ 表示 $x$ 次 按按钮后 $A$ 的数量

$f_{B_x}$  表示 $x$ 次 按按钮后 $B$ 的数量

直接套用题意，得

$$
f_{A_x}=f_{B_{x-1}} 
$$

$$
f_{B_x}=f_{B_{x-1}}+f_{A_{x-1}}
$$

然后无了，有可能可以化简，但这道水题没必要

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,fa[1005],fb[1005];
int main()
{
    cin>>n;
    fa[0]=1;//初始一个A
    for(int i=1;i<=n;i++)
    {
        fa[i]=fb[i-1];
        fb[i]=fa[i-1]+fb[i-1];
    }
    cout<<fa[n]<<' '<<fb[n]<<endl;
}

```

---

## 作者：sgl654321 (赞：1)

### 题意描述
原有一个字符串内容为 $\texttt B$，此后每次将字母 $\texttt B$ 变为 $\texttt {BA}$，字母 $\texttt A$ 变为 $\texttt B$。问变换 $k$ 次后，字符串中有几个 $\texttt A$，几个 $\texttt B$。具体请看[题目](https://www.luogu.com.cn/problem/P8241)。
### 解题思路
本题使用递推的方法。规定 $a_i$ 表示变换 $i$ 此后字符串中含有 $\texttt A$ 的个数，$b_i$ 表示变换 $i$ 此后字符串中含有 $\texttt B$ 的个数。

思考：变换 $i$ 次后的字符串中，字母 $\texttt A$ 是如何从上一个字符串得到的？字母 $\texttt B$ 是如何从上一个字符串得到的？

由于每次将字母 $\texttt B$ 变为 $\texttt {BA}$，得出字母 $\texttt A$ 是从上一个字符串中的 $\texttt B$ 得到的。上一个字符串有几个 $\texttt B$，这一个字符串就有几个 $\texttt A$。

由于每次将字母 $\texttt B$ 变为 $\texttt {BA}$，字母 $\texttt A$ 变为 $\texttt B$，得出字母 $\texttt B$ 是从上一个字符串中 $\texttt A$ 和 $\texttt B$ 共同得到的。上一个字符串有几个 $\texttt A$ 和 $\texttt B$，这个字符串就有几个 $\texttt B$。

所以递推式就显而易见了：

$\begin{cases} a_i=b_{i-1} &\\
b_i=a_{i-1}+b_{i-1}
\end{cases}$
### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,a[100],b[100];
int main(){
	cin>>k;
	a[1]=0;b[1]=1;
	for(int i=2;i<=k;i++){
		a[i]=b[i-1];
		b[i]=b[i-1]+a[i-1];
	}
	cout<<a[k]<<" "<<b[k]<<endl;
	return 0;
}
```


---

## 作者：Syamoe (赞：1)

看到这个题，我第一想法就是直接开始找规律，于是，通过列举，列出来了如下的：
![](https://cdn.luogu.com.cn/upload/image_hosting/wc9tr7m3.png)

（上面的是每按 $1$ 次，会变换成的样子，下面的是统计的 $A$ 和 $B$ 的个数）

不难发现，从第 $2$ 次变换开始每一次，$A$ 的个数会变换成上一组 $B$ 的个数，而 $B$ 的个数，会变换成上一组个数总和

那么，如何证明上述的规律是正确的？

首先，明确一点，题目中所讲：

> 每当他按一次按钮，屏幕上的字母 B 变为 AB，而字母 A 变为 B。

因此，可以推断出来的是：

- $B$ 的个数就是上一组个数总和（因为上面的一组不管是 $A$ 还是 $B$ 都会变换出来 $1$ 个 $B$ 出来，而且仅有 $1$ 个）

- 而 $A$ 只可以由上一组的 $B$ 变换出来，因此，$A$ 的个数就是上一组 $B$ 的个数

因此，可以直接得到代码：

```cpp
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	int a = 1, b = 0;
	for (int i = 1; i <= n; i++) {
		int na = a, nb = b;
		a = b;
		b = na + nb;
	}
	cout << a << " " << b << endl;
	return 0;
}
```
唯一需要注意的一点就是一定是从第 $1$ 次开始循环的，不要写成第 $2$ 次了

就这样，拜拜

---

## 作者：yeshubo_qwq (赞：1)

每一次操作，$A$ 的数量变成原有 $B$ 的数量，$B$ 的数量变成原有 $B$ 的数量加原有 $A$ 的数量。

数据很小，直接死做即可。

```c
#include<stdio.h>
int main(){
    int a=1,b=0,c,x;
    scanf("%d",&x);
    while(x--)c=a,a=b,b+=c;
    printf("%d %d",a,b);
    return 0;
}
```

---

## 作者：diqiuyi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8241)

**思路**

这题显然要关注这些变化对 $A$ 和 $B$ 数量的影响。设按 $x$ 次后有 $b_x$ 个 $B$，$a_x$ 个 $A$。那么，首先看 $B$ 是如何产生的。$BA \gets B$，$B \gets A$，显然 $b_x=a_{x-1}+b_{x-1}$。再看 $A$，$\because BA \gets B$，$\therefore a_x=b_{x-1}$。仔细一看，$\because a_{x-1}=b{x-2}$，$\therefore b_x=b_{x-2}+b{x-1}$。正好是斐波那契数列。

**MAIN CODE**
```cpp
  if(k==1)
	return !puts("1 0");//这里要特判一下
  for(int i=2;i<=k;i++)
	f[i]=f[i-2]+f[i-1];
  printf("%lld %lld\n",f[k-2],f[k-1]);
```
温馨提示：别忘了初始化 $f$ 数组。

---

## 作者：lsj2009 (赞：0)

## 题意
最初有一个 $\texttt{A}$，进行 $k$ 次操作，每次操作将每个 $\texttt{A}$ 变成 $\texttt{B}$，将每个 $\texttt{B}$ 变成 $\texttt{BA}$，问 $n$ 次操作后有几个 $\texttt{A}$ 几个 $\texttt{B}$？
## 思路
此题固然可以 $O(n^2)$ 模拟 $O(n)$ 递推，但是，我们不妨追求下难度，以寻求 $O(\log n)$ 甚至 $O(1)$ 的解法。

我们可以做以下递推：

$f_{i,0}$ 表示在进行第 $i$ 次操作之后的 $\texttt{A}$ 数量；

$f_{i,1}$ 表示在进行第 $i$ 次操作之后的 $\texttt{B}$ 数量；

$f_{0,0}=1$。

有递推公式：

$f_{i,0}=f_{i-1,0}+f_{i-1,1}-f_{i-1,0}=f_{i-1,1}$；

$f_{i,1}=f_{i-1,1}+f_{i-1,0}$。

发现其实 $f_{i,0}=f_{i-1,1}$，那么我们可以减少一个状态，以 $f_{i}$ 代表 $\texttt{B}$ 的数量，以 $f_{i-1}$ 代表 $\texttt{A}$ 的数量。

则递推公式变成：

$$
\left\{\begin{matrix} 
  f_i=1\quad i=1 \\  
  f_i=f_{i-1}+f_{i-2}\quad i\ge 2
\end{matrix}\right. 
$$

怎么样？我们惊讶的发现，这就是斐波那切数列的递推公式！

此刻，我们使用矩阵加速可以达到 $O(\log n)$ 的时间复杂度，使用斐波那切数列通项公式：

$$f_n=\frac{(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n}{\sqrt{5}}$$

（理论上）可以达到 $O(1)$ 时间复杂度。

## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const double sqrt_five=sqrt(5);
signed main() {
	double n;
	scanf("%lf",&n);
	printf("%.0lf %.0lf",(pow(1.0+sqrt_five,n-1)-pow(1.0-sqrt_five,n-1))/(pow(2.0,n-1)*sqrt_five),(pow(1.0+sqrt_five,n)-pow(1.0-sqrt_five,n))/(pow(2.0,n)*sqrt_five));
	return 0;
}
```

然而使用了 ``cmath`` 而导致常数大到极致的它却还是跑了 $30s$。。。

---

## 作者：5k_sync_closer (赞：0)

# 基础思路
先来看点显然的。

我们设 $A$ 的个数为 $a$，$B$ 的个数为 $b$。

经过一次变换，$A\rightarrow B,B\rightarrow BA$，

只有 $B$ 会变出 $A$，那么就有 $a\leftarrow b$。

 $A,B$ 都会变出  $B$，那么就有 $b\leftarrow a+b$。
 
 变换的次数并不多，于是可以 $O(n)$ 模拟一下。
 
code：
```cpp
#include <cstdio>
int main()
{
    int n, a = 1, b = 0, t;scanf("%d", &n);
    while(n--) t = a, a = b, b += t;
    return printf("%d %d", a, b), 0;
}
```
# 进阶亿点
我们发现题目中 $k$ 很小，如果 $k≥2×10^8$ 怎么办呢？

纯递推，自然想到矩阵快速幂优化。设经过 $i$ 次转移的 $a,b$ 为 $A_i,B_i$。

推一下转移矩阵：
$$
\begin{bmatrix}
A_{i-1}&B_{i-1}
\end{bmatrix}
×
\begin{bmatrix}
a&b\\c&d
\end{bmatrix}
=
\begin{bmatrix}
A_{i}&B_{i}
\end{bmatrix}
$$
则有
$$
\begin{cases}
A_i=aA_{i-1}+cB_{i-1}\\
B_i=bA_{i-1}+dB_{i-1}
\end{cases}
$$
我们知道
$$
\begin{cases}
A_i=B_{i-1}\\
B_i=A_{i-1}+B_{i-1}
\end{cases}
$$
可以推得
$$
\begin{bmatrix}
a&b\\c&d
\end{bmatrix}=
\begin{bmatrix}
0&1\\1&1
\end{bmatrix}
$$
因为 $
\begin{bmatrix}
A_0&B_0
\end{bmatrix}=
\begin{bmatrix}
1&0
\end{bmatrix}
$，所以：
$$
\begin{bmatrix}
1&0
\end{bmatrix}
×
\begin{bmatrix}
0&1\\1&1
\end{bmatrix}^n
=
\begin{bmatrix}
A_{n}&B_{n}
\end{bmatrix}
$$
矩阵快速幂即可。
```cpp
#include <cstdio>
#include <cstring>
#define F(i) for(int i = 0;i < 2;++i)
struct S{int a[2][2];S() {memset(a, 0, sizeof a);}S operator*(S b);}b, s;
S S::operator*(S b) {S c;F(k) F(i) F(j) c.a[i][j] += a[i][k] * b.a[k][j];return c;}
signed main()
{
	int n;scanf("%d", &n);
	s.a[0][0] = b.a[0][1] = b.a[1][0] = b.a[1][1] = 1;
    for(;n;n >>= 1) {if(n & 1) s = s * b;b = b * b;}
	return printf("%d %d", s.a[0][0], s.a[0][1]), 0;
}
```


---

## 作者：i_dont_know_who_am_i (赞：0)

这道题其实就是一个斐波那契数列的题目。

一看，按一次按钮，$\texttt{A}$ 变成 $\texttt{B}$，$\texttt{B}$ 变为 $\texttt{BA}$。这不妥妥的斐波那契吗。

所以只需要输出斐波那契数列中第 $k$ 个数和第 $k-1$ 个数即可。

上代码：

```cpp
#include <iostream>
using namespace std;
long long a[45];
int main(){
    int k;
    cin >>k;
    a[1]=1;a[2]=1;//因为如果只按一次按钮，要输出0 1，所以下标从1开始，方便输出
    for(int i=3;i<=k;i++){
        a[i]=a[i-1]+a[i-2];
    }//求斐波那契数列中的数
    cout<<a[k-1]<<" "<<a[k];
}
```


---

## 作者：哈士奇憨憨 (赞：0)

## 思路
我们打一个表：
```cpp
B                       0 1
BA                      1 1
BA B                    1 2
BA B BA	                2 3
BA B BA BA B	        3 5
BA B BA BA B BA B BA	5 8
```
设按下按钮的次数为 $k$，则我们发现 $\texttt{A}$ 的个数就是斐波那契数列的第 $k-1$ 项，$\texttt{B}$ 的个数就是斐波那契数列的第 $k$ 项。

证明：
当一个 $\texttt{B}$ 变换时，$\texttt{B}$ 和 $\texttt{A}$ 的个数都增加了 $1$，当一个 $\texttt{A}$ 变换时，$\texttt{B}$ 的个数都增加了 $1$。而一开始只有一个字母 $\texttt{A}$，所以会出现波那契数列的情况。
## CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[50], n;
int main(){
    f[1] = f[2] = 1;
    cin >> n;
    for(int i = 3; i <= n; i++){
    	f[i] = f[i - 1] + f[i - 2];   
    }
    cout << f[n - 1] << " " << f[n];  
    return 0;
}
```


---

## 作者：charleshe (赞：0)

观察一下题目，可以发现，每按下一次按钮后：

$\texttt{A}$ 的个数变为：按按钮前 $\texttt{B}$ 的数量；

$\texttt{B}$ 的个数变为：按按钮前字符的数量（即按按钮前 $\texttt{A}$ 的数量与 $\texttt{B}$ 的数量的和）。

想到了什么？

$f_{n} = f_{n-1} + f_{n-2}$。

斐波那契数列。

于是问题就被转化成了：

对于一个 $n$，求 $f_{n-1}$ 和 $f_{n}$。

注意事项：

1. 看数据范围，$1 \leq n \leq 45$，因此整形就可以了。

2. 初始条件：$f_0=0$，$f_1=1$。

考虑了这些，代码便好写了。

```cpp
#include <iostream>
using namespace std;
int f[50];
void init(){//这是求第0~45个斐波那契数的递推程序
	f[0]=0;
	f[1]=1;
	for(int i=2;i<=45;i++) f[i]=f[i-1]+f[i-2];
}
int n;
int main(){
	init();
	cin>>n;
	cout<<f[n-1]<<" "<<f[n];
	return 0;
}
```


---

## 作者：Firstly (赞：0)

## **题目思路：**

首先我们可以想到定义一个字符串，并且模拟字母变化的过程，最后统计数量。但是如果就这样模拟的话，会有三个点超时。

因为题目只要求我们求 $\texttt{A}$ 和 $\texttt{B}$ 的数量，不妨观察每次变化的实质。可以发现，每次变化所有的 $\texttt{A}$ 都会变成 $\texttt{B}$，实际上就是将 $\texttt{B}$ 的数量增加 $\texttt{A}$ 的数量，并将 $\texttt{A}$ 的数量清零。而每一个 $\texttt{B}$ 就会凭空产生一个 $\texttt{A}$，其实就是将 $\texttt{A}$ 的数量增加本次变化之前 $\texttt{B}$ 的数量。这样时间复杂度为 $O(k)$。

## **Code:**

```cpp
#include<iostream>
using namespace std;
int a=1,b,k;
int main(){
    cin>>k;
    while(k--){
        int plusa=b;
        b+=a,a=plusa;
    }cout<<a<<' '<<b;
    return 0;
}
```


---

## 作者：_lmh_ (赞：0)

### 做法分析

细节不多的模拟题，只需两个数组即可。

$a_i$ 代表按 $i$ 下后 $A$ 的个数，$b_i$ 代表按 $i$ 下后 $B$ 的个数。根据题意可得，初始值为 $a_0=1,b_0=0$。

递推公式为 $a_i=b_{i-1},b_i=b_{i-1}+a_{i-1}$。同时只需求按 $k$ 下后的 $A$ 和 $B$ 的个数，所以可以用变量代替数组，同时将 $t$ 设为中间变量，记录 $a_{i-1}$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long A=1,B,t,n;
//记得开long long
int main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        t=A;A=B;B+=t;
    }
    cout<<A<<' '<<B;
    return 0;
}
```

### 第二种思路

注意到 $a_i$，$b_i$ 都是斐波那契数列的项，所以可以用它的公式：
$F_i=\frac{1}{\sqrt5}((\frac{1-\sqrt5}{2})^n-(\frac{1+\sqrt5}{2})^n)$。
令 $F_0=0,F_{-1}=1$，则 $a_i=F_{i-1},b_i=F_i$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long A,B,n;
const double c=1/sqrt(5),d1=(1+sqrt(5))/2,d2=(1-sqrt(5))/2;
double F(int k){
    if (k==-1) return 1;
    if (!k) return 0; //特判
    return c*(pow(d1,k)-pow(d2,k));
}
int main(){
    cin>>n;
    A=F(n-1)+0.5;B=F(n)+0.5; //四舍五入
    cout<<A<<' '<<B;
    return 0;
}
```

---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8241)

根据题意模拟即可。

根据题目要求，对于一次操作：

- `A` $\rightarrow$ `B`，即 `B` 的数量多出了原本 `A` 的数量个，`A` 变为 $0$ 个。

- `B` $\rightarrow$ `BA`，即 `B` 的数量不变，`A` 的数量变为原本 `B` 的数量个。

综上，对于每一次操作，`A` 的数量变为原本 `B` 的数量，而 `B` 的数量变为原本的 `A` 与 `B` 的数量之和。

这样我们就能得到代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int k;
	cin>>k;
	int A=1,B=0;//答案
	for(int i=1;i<=k;i++){
		int tmpa=A,tmpb=B;//tmpa 记录操作前 A 的数量，tmpb 记录操作前 B 的数量
		A=B;B=tmpb+tmpa;
	}
	cout<<A<<" "<<B;
	return 0;
}
```


---


# [COCI 2013/2014 #3] OKVIR

## 题目描述

Mirko 制作出了一个绝妙的纵横字谜，现在他想把这个纵横字谜用边框给框起来。

Mirko 的纵横字谜可以看作是一个 $m\times n$ 的网格图，每个格子上都有一个小写字母。他希望上面、左边、右边和下面的边框的宽度分别为 $u,l,r,d$。边框上也被分割成若干个网格，每个网格上要么是 `#`，要么是 `.`。他还希望，如果框架扩展到整个字谜上，那么左上角的网格必定是 `#`，且相邻网格上的字符不能相同。当然，如果该网格原来是纵横字谜上的，那么最终制作边框时应当保留字谜网格上的原有字母，而不是 `#` 或 `.`。

现在，请你帮 Mirko 得到最终框起来的字谜的所有网格上的字符。

如果你不能很好地理解题意，请参考本题的样例。

## 说明/提示

**【数据范围与限制】**

对于所有数据，$1\leqslant m,n\leqslant 10$，$0\leqslant u,l,r,d\leqslant 5$。

**【题目来源】**

本题来源自 **_[COCI 2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 3](https://hsin.hr/coci/archive/2013_2014/contest3_tasks.pdf) T2 OKVIR_**，按照原题数据配置，满分 $80$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 4
2 2 2 2
honi
oker
nera
irak```

### 输出

```
#.#.#.#.
.#.#.#.#
#.honi#.
.#oker.#
#.nera#.
.#irak.#
#.#.#.#.
.#.#.#.#```

## 样例 #2

### 输入

```
2 4
1 0 3 1
rima
mama```

### 输出

```
#.#.#.#
rima.#.
mama#.#
.#.#.#.```

# 题解

## 作者：cff_0102 (赞：9)

先看了一下题意，还在想暴力会不会超时。直到我看了数据范围。

这一道题，有人刚开始会想读入之后暴力出来背景，再把文字覆盖上去（~~没错就是我~~）。但是这道题如果时间少一点就可能超时（~~可能性不大~~）。所以考虑打表过。

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[20][20]={{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
				{'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.'},
				{'.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'}};
int main(){
	ios::sync_with_stdio(false);
	int m,n;cin>>m>>n;
	int u,l,r,d;cin>>u>>l>>r>>d;
	for(int i=u;i<u+m;i++){
		for(int j=l;j<l+n;j++){
			char chr;
			cin>>chr;
			c[i][j]=chr;
		}
	}
	for(int i=0;i<u+m+d;i++){
		for(int j=0;i<l+n+r;j++){
			cout<<c[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```
[~~这打表多是一件美事啊~~](https://www.bilibili.com/video/BV1qb4y1p7QK/)

总的来说这道题没什么坑点，就是我在测试的时候字符不小心溢出了，然后蜂鸣器一直哔个不停。。

---

## 作者：Dream_weavers (赞：5)

## 思路

设一个大小为 $m\times n$ 的网格图是 $a$。

先用字符 `#` 和 `.` 来覆盖 $a$。当 $a_{i,j}$ 中的 $(i+j)\equiv0\pmod{2}$（说人话就是横纵坐标和是偶数），$a_{i,j}$ 为 `#`，否则为 `.`（~~其实可以打表~~）。然后在 $u< i\le u+m$ 且 $l<j\le j+n$ 的区域内输入字母，最后整体输出。

这种方法是先设置背景（也就是边框）后覆盖内容，另一种方法是先覆盖内容后设置边框。两者时间复杂度都为 $O(n^2)$。

## 代码

这里放的是第一种方法的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,u,l,r,d;
char a[25][25],ch;
int main(){
	cin>>m>>n;
	cin>>u>>l>>r>>d;
	for(int i=1;i<=20;i++)
		for(int j=1;j<=20;j++){
			if((i+j)%2==0)a[i][j]='#';
			else a[i][j]='.';
		}	
	for(int i=u+1;i<=u+m;i++)
		for(int j=l+1;j<=l+n;j++)
			cin>>ch,a[i][j]=ch;
	for(int i=1;i<=m+u+d;i++){
		for(int j=1;j<=n+l+r;j++)
			cout<<a[i][j];
		printf("\n");
	}
    return 0;
}

```

---

## 作者：幸存者 (赞：5)

## 思路
先将整个棋盘预处理，然后输入中间部分的矩形，最后输出即可。

注意：输入中间的矩形的时候应该从 $u+1,l+1$ 开始，到 $u+n,l+m$ 结束，我一开始写错了就调了半天。
## $\text{AC Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[30][30];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int n, m, u, l, r, d;
    cin >> n >> m >> u >> l >> r >> d;
    for (int i = 1; i <= u + n + d; i++) for (int j = 1; j <= l + m + r; j++) a[i][j] = (i + j) % 2 ? '.' : '#';
    for (int i = u + 1; i <= u + n; i++) for (int j = l + 1; j <= l + m; j++) cin >> a[i][j];
    for (int i = 1; i <= u + n + d; i++)
    {
        for (int j = 1; j <= l + m + r; j++) cout << a[i][j];
        cout << endl;
    }
    return 0;
}
```

---

## 作者：sgl654321 (赞：2)

### 题目大意
- 有一个字符数组，共 $m$ 行 $n$ 列。
- 现在，要求在该字符数组的上方添加 $u$ 行，下方添加 $d$ 行，左边添加 $l$ 列，右边添加 $r$ 列。
- 添加的每一个字符只可能是 ```#``` 或 ```.```。最左上方的应当是 ```#```（$u=l=0$ 时除外），其他字符不能与其上、下、左、右的字符相同。
- 输出添加后的字符数组。

### 解题思路

解题方法：模拟。

先根据题目要求打印出一个只含有 ```#``` 和 ```.``` 的，$u+m+d$ 行 $l+n+r$ 列的字符数组，即最左上方为 ```#```，其余都不与上、下、左、右的字符相同的一个字符数组。

然后，再根据输入的 $u$、$l$、$r$、$d$ 添加输入字符数组的字母，覆盖原来的 ```#``` 或 ```.```。

我们用样例 $2$ 来举个例子吧：

现根据题意打印出一个 $2+1+1=4$ 行，$0+4+3=7$ 列的字符数组，如下：
```
#.#.#.#
.#.#.#.
#.#.#.#
.#.#.#.
```
然后再覆盖输入的字母，如下：
```
#.#.#.#
rima.#.
mama#.#
.#.#.#.
```
就大功告成啦！

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,u,l,r,d;
char ch[100][100],ans[100][100];
int main(){
	cin>>m>>n>>u>>l>>r>>d;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			cin>>ch[i][j];
	ans[1][1]='#';
	for(int i=1;i<=u+m+d;i++)
		for(int j=1;j<=l+n+r;j++)
			if(i!=1||j!=1)
				if(j==1){
					if(ans[i-1][j]=='.')ans[i][j]='#';
					else ans[i][j]='.';
				}else{
					if(ans[i][j-1]=='.')ans[i][j]='#';
					else ans[i][j]='.';
				}//初始化
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			ans[u+i][l+j]=ch[i][j];
	for(int i=1;i<=u+m+d;i++){
		for(int j=1;j<=l+n+r;j++)
			cout<<ans[i][j];
		cout<<endl; 
	}//覆盖字母
	return 0;
} 
```



---

## 作者：FQR_ (赞：2)

这道题，我们可以这样考虑。

① 生成一个只有 `#` 和 `.` 的二维字符数组。例如样例#1,生成
```
#.#.#.#.
.#.#.#.#
#.#.#.#.
.#.#.#.#
#.#.#.#.
.#.#.#.#
#.#.#.#.
.#.#.#.#
```
② 把一部分子串换成输入的字符串。

完成这两步，这道题就完事了。
___
分析一下：

第①步，看似很麻烦，实际很简单，在此不做讲解，相信大家看代码能看懂。
___
第②步，我写了一个自定义函数来解决它：
```cpp
string change(string a,int l,int r,string b)
{
	a.erase(l,r-l+1);//删除从l开始，长度为r-l+1（也就是左面l右面r）的子串
	a.insert(l,b);//在l的位置插入字符串b
	return a;
}
```
这段代码，返回了把字符串 $ a $ 中 $ r - l $ 的字符变成字符串 $ b $ 得到的结果。

只要遍历要替换的子串，调用上面所给的函数，这道题就完美解决啦！
___
## 上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
string change(string a,int l,int r,string b)
{
	a.erase(l,r-l+1);//删除从l开始，长度为r-l+1（也就是左面l右面r）的子串
	a.insert(l,b);//在l的位置插入字符串b
	return a;
}
int main()
{
	int n,m,u,l,r,d;
	string a[100],b[100];
	cin>>m>>n>>u>>l>>r>>d;
	for(int i=0;i<m;i++) cin>>b[i];
	for(int i=0;i<l+n+r;i++) a[0]+=i%2==0?'#':'.';//a[0]="#.#.#. …"
	for(int i=0;i<l+n+r;i++) a[1]+=i%2==0?'.':'#';//a[1]=".#.#.# …"
	for(int i=2;i<u+m+d;i++) a[i]=a[i%2];//i为奇数与a[1]一样，i为偶数与a[0]一样
	
	int t=0;//正在替换第t个字符串
	for(int i=u;i<=u+m-1;i++) 
		a[i]=change(a[i],l,l+n-1,b[t++]);//把 l 到 l+n-1 这一段替换为要替换的字符串
	for(int i=0;i<u+m+d;i++) cout<<a[i]<<endl;//直接输出答案
	return 0;
}

```


---

## 作者：484A51 (赞：0)

## P8242题解
~~本蒟蒻终于找到一篇简单的题解啦！~~

我用的方法是按行分成三块区域分别输出。  
1. 上边框； 
2. 中间含纵横字谜的部分； 
3. 下边框。 

就这样暴力一行一行输出就行了。具体解释见代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
int m,n,u,l,r,d;	//变量，意义均同题目 
char c[15][15];
int main()
{
	cin>>m>>n;
	cin>>u>>l>>r>>d;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>c[i][j];
		}
	}
	int a=n+l+r;	//总宽度 
	for(int i=1;i<=u;i++){
		for(int j=1;j<=a;j++){
			if(j%2==i%2) cout<<'#';		//若横纵坐标均为奇数或偶数，则输出# 
			else cout<<'.';				//反之则输出. 
		}
		cout<<endl;
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=a;j++){
			if(j<=l||a-j+1<=r){
				if((i+u)%2==j%2) cout<<'#';		//这里需注意有个BUG，因为这里的i并不代表坐标中的横坐标 
				else cout<<'.';					//所以i必须加上上边框的宽度才行 
			}
			else cout<<c[i][j-l];				//同样这个j不是读入时的j，要减去左边框的宽度 
		}
		cout<<endl;
	}
	for(int i=1;i<=d;i++){
		for(int j=1;j<=a;j++){
			if((i+u+m)%2==j%2) cout<<'#';		//这里也一样 
			else cout<<'.';
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：Firstly (赞：0)

## **题目思路：**

因为整个矩阵的长、宽最多均不超过 $20$，所以我们可以先使用循环造出一个 $20\times20$ 的字符矩阵，然后每次输入一个字符，就将原来这个位置上的符号覆盖，最后按要求输出要求的矩阵即可。

## **Code：**

```cpp
#include<iostream>
using namespace std;
char c[21][21];
int n,m,u,l,r,d;
int main(){
    cin>>m>>n>>u>>l>>r>>d;
    c[1][1]='#';
    for(int i=2;i<=20;i++)c[1][i]=((c[1][i-1]=='#')?'.':'#');
    for(int i=2;i<=20;i++)
        for(int j=1;j<=20;j++)
            c[i][j]=((c[i-1][j]=='#')?'.':'#');
    for(int i=u+1;i<=u+m;i++)
        for(int j=l+1;j<=l+n;j++)
            cin>>c[i][j];
    for(int i=1;i<=u+m+d;i++){
        for(int j=1;j<=l+n+r;j++)
            cout<<c[i][j];
        cout<<endl;
    }return 0;
}
```


---

## 作者：tian_jun_cheng (赞：0)

肯定是模拟。

## 思路：

先将数组 $ c $ 变成底面网格的形式，也就是```#```和```*```间隔的样子。

再输入数组，进行覆盖。

最后输出。

## 第一部分 网格

```cpp
int f=1;
for(int i=1;i<=20;i++)
{
	for(int j=1;j<=20;j++)
	{
		if(f)
			c[i][j]='#';
		else
			c[i][j]='.';
		f^=1;
	}
	f^=1;
}
```
间隔开来，为输入做准备。

## 第二部分 输入

非常鸡肋。

```cpp
int n,m;
int u,l,r,d;
cin>>n>>m>>u>>l>>r>>d;
for(int i=1;i<=n;i++)
{
	string s;
	cin>>s;
	for(int j=0;s[j];j++)
		q[i][j+1]=s[j];
}
```
因为我用字符数组存储的，所以要进行字符串处理。

## 第三部分 覆盖

这里的公式推导如下。

我们要覆盖的大小应该是 $ n \times m $ 的，所以只要知道两个角的坐标即可。

左上坐标：(上面的大小+1，左面的大小+1)，也就是 $ ( u + 1 , l + 1 ) $ 。

右下坐标：（输入高度+上面的大小，输入行数+左面的大小），就是 $ ( l + 1 , m + 1 )$ 。

```cpp
for(int i=u+1;i<=u+n;i++)
	for(int j=l+1;j<=m+l;j++)
		c[i][j]=q[i-u][j-l];
```


## 第四部分 输出

按照画布大小输出即可。

```cpp
for(int i=1;i<=n+u+d;i++)
{
	for(int j=1;j<=m+l+r;j++)
		cout<<c[i][j];
	cout<<endl; 
}
```


---

## 作者：liuxy1234 (赞：0)

这题其实很简单，只要首先生成一个画框，然后再把画放到中间就行了。

其他的不说了，直接上代码。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

char c[20][20];

signed main()
{
	c[1][1] = '#';
	int n, m, u, l, d, r;
	cin >> n >> m >> u >> l >> r >> d;
	for(int i = 1;i <= n + u + d;i++)//初始化。
	{
		if(i != 1)
		{
			if(c[i - 1][1] == '#')c[i][1] = '.';//间隔排列。
			else c[i][1] = '#';
		}
		for(int j = 2;j <= m + l + r;j++)
		{
			if(c[i][j - 1] == '#')c[i][j] = '.';
			else c[i][j] = '#';
		}
	}
	for(int i = 1;i <= n;i++)//输入画。
	{
		for(int j = 1;j <= m;j++)
		{
			char a;
			cin >> a;
			c[i + u][j + l] = a;
		}
	}
	for(int i = 1;i <= n + u + d;i++)//输出加了画框的画。
	{
		for(int j = 1;j <= m + l + r;j++)
		{
			cout << c[i][j];
		}
		cout << "\n";
	}
	return 0;
}

```


---

## 作者：yeshubo_qwq (赞：0)

直接枚举答案里的每一个位置即可，如果不在字谜网格上，直接输出对应的字符，如果在字谜网格上，输出字谜网格上对应的字母。

注意：`#` 和 `.` 是交替的，且奇数行开头为 `#`，偶数行开头为 `.`。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,a1,b1,b2,a2,j,h;
char a[12][12],c;
int main(){
    cin>>n>>m>>a1>>b1>>b2>>a2;
    for(i=1;i<=n;i++)cin>>a[i]+1;
    for(i=1-a1;i<=n+a2;i++){
        if((++h)%2==1)c='#';else c='.';
        for(j=1-b1;j<=m+b2;j++){
            if(i<1||i>n||j<1||j>m)cout<<c;
            else cout<<a[i][j];
            if(c!='.')c='.';else c='#';
        }
        cout<<'\n';
    }
    return 0;
}
```


---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8242)

模拟题。

首先按照题目要求将字谜填入答案数组内（个人习惯将 `n` 与 `m` 互换了）：

```cpp
	for(int i=u+1;i<=u+1+n;i++){
		for(int j=l+1;j<=l+1+m;j++){//从 (u+1,l+1) 的点为左上角开始填
			ans[i][j]=mp[i-u][j-l];
		}
	}
```

然后根据以下规律填字符：

- $i$ $\bmod$ $2=1$ $\text{and}$ $j$ $\bmod$ $2=1$ $\Rightarrow$ `#`

- $i$ $\bmod$ $2=1$ $\text{and}$ $j$ $\bmod$ $2=0$ $\Rightarrow$ `.`

- $i$ $\bmod$ $2=0$ $\text{and}$ $j$ $\bmod$ $2=1$ $\Rightarrow$ `.`

- $i$ $\bmod$ $2=0$ $\text{and}$ $j$ $\bmod$ $2=0$ $\Rightarrow$ `#`

代码：

```cpp
	for(int i=1;i<=u+n+d;i++){
		for(int j=1;j<=l+m+r;j++){
			if(ans[i][j]>='a'&&ans[i][j]<='z'){
				continue;
			}
			if(i%2==1){
				if(j%2==1){
					ans[i][j]='#';
				}else{
					ans[i][j]='.';
				}
			}else{
				if(j%2==1){
					ans[i][j]='.';
				}else{
					ans[i][j]='#';
				}
			}
		}
	}
```

最后输出 $ans$ 数组即可。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char mp[15][15],ans[30][30];
int main(){
	int n,m,u,l,r,d;
	cin>>n>>m>>u>>l>>r>>d;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=u+1;i<=u+1+n;i++){
		for(int j=l+1;j<=l+1+m;j++){
			ans[i][j]=mp[i-u][j-l];
		}
	}
	for(int i=1;i<=u+n+d;i++){
		for(int j=1;j<=l+m+r;j++){
			if(ans[i][j]>='a'&&ans[i][j]<='z'){
				continue;
			}
			if(i%2==1){
				if(j%2==1){
					ans[i][j]='#';
				}else{
					ans[i][j]='.';
				}
			}else{
				if(j%2==1){
					ans[i][j]='.';
				}else{
					ans[i][j]='#';
				}
			}
		}
	}
	for(int i=1;i<=u+n+d;i++){
		for(int j=1;j<=l+m+r;j++){
			cout<<ans[i][j];
		}
		cout<<"\n";
	}
	return 0;
}
```


---


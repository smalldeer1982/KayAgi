# gcd.

## 题目背景

与你借星火，容我题山河。

## 题目描述

$T$ 组数据，每一组数据给定 $l,r,x$，试求：$\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$ 的值。

- 其中 $\gcd$ 表示求最大公约数，例如 $\gcd(6,9)=3$，$\gcd(2,4,8)=2$，$\gcd(5,6,7)=1$。特别地，我们定义一个正整数的最大公约数是它自身。
- $\lfloor x \rfloor$ 表示 $x$ 向下取整，例如 $\lfloor 3.14 \rfloor=3$。

## 说明/提示

**【样例解释和说明】**

样例中的 $T=4$，说明有 $4$ 组数据。

- 对于第一组数据，$l=3,r=6,x=1$，即求 $\gcd(\lfloor \frac{3}{1}\rfloor,\lfloor \frac{4}{1} \rfloor, \lfloor \frac{5}{1}\rfloor,\lfloor \frac{6}{1}\rfloor)=1$。
- 对于第二组数据，$l=8,r=11,x=4$，即求 $\gcd(\lfloor \frac{8}{4} \rfloor,\lfloor \frac{9}{4} \rfloor,\lfloor \frac{10}{4}\rfloor,\lfloor \frac{11}{4}\rfloor)=\gcd(2,2,2,2)=2$。
- 对于第三组数据，$l=4,r=4,x=3$，即求 $\gcd(\lfloor \frac{4}{3}\rfloor)=1$。
- 对于第四组数据，类似可得结果是 $1$。

**【数据范围】**

- 对于 $10\%$ 的数据，$x=1$。
- 另有 $10\%$ 的数据，$l=r$。
- 另有 $20\%$ 的数据，$r-l \leq 10^5$。
- 对于上述的前 $40\%$ 的数据，$1 \leq x \leq l \leq r \leq 10^9$。
- 对于所有数据，$1 \leq x \leq l \leq r \leq 10^{18}$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
4
3 6 1
8 11 4
4 4 3
7 16 2```

### 输出

```
1
2
1
1```

# 题解

## 作者：liangbowen (赞：40)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P8443)

[更好的阅读体验？](https://www.luogu.com.cn/blog/liangbowen/solution-p8443)

普及组月赛第一题。别的题解语言有点高深，我补篇题解。

## 思路

显然，$\lfloor \dfrac{l}{x}\rfloor, \lfloor \dfrac{l+1}{x}\rfloor, \cdots, \lfloor \dfrac{r}{x}\rfloor$ 是**连续的整数**。

而且，显然有 $\operatorname{gcd}(c, c+1) = 1$。

换句话说，只要 $\lfloor \dfrac{l}{x}\rfloor \ne \lfloor \dfrac{r}{x}\rfloor$，结果就为 $1$。如果两者相等，答案就是 $\lfloor \dfrac{l}{x}\rfloor$ 啦。

## 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
	int T;
	scanf("%d", &T);
	while (T--)
	{
		long long l, r, x; //本题唯一坑点，要记得开 long long。
		scanf("%lld%lld%lld", &l, &r, &x);
		if (l / x != r / x) puts("1");
		else printf("%lld\n", l / x);
	}
	return 0;
}
```

希望能帮助到大家！

---

## 作者：封禁用户 (赞：14)

题目比较简单。

**但是，我们先要看数据范围：**

>- 对于所有数据，$1 \leq x \leq l \leq r \leq 10^{18}$，$1 \leq T \leq 10$。

很好，又是一道完美诠释了“不开 long long 见祖宗”的题。

上来就先来一个 `int long long` 。

根据题目，我们可以发现题目所求的最大公因数不是 $l=r$ 就是求相邻的几个数的最大公因数，所以我们需要了解两个数学性质：

-  $\gcd(x,x)=x$，也就是两个同样的数，它们的最大公因数**为它本身**。

-  $\gcd(x,x+1)=1$，两个相邻的数的最大公因数**为1**。

综上所述，我们可以~~只用 17 行代码~~来完成本题。

## code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        int long long l,r,x;
        cin>>l>>r>>x;
        l/=x;
        r/=x;
        if(l==r) cout<<l<<endl;//r也可以
        else cout<<"1"<<endl;
    }
    return 0;
}
```


---

## 作者：ztrztr (赞：12)

## 前言
这道题其实很水，但在考场上，我没开 ```long long```见祖宗，只得到了40分 ![](//图.tk/7)。

## 题解
废话不多说，我们来看看这道题该如何做。

### 40 分
暴力，这里就不多说了。

### 100 分
$l,r,k$ 有 $2$ 种类型：
1. $\lfloor \frac{l}{k} \rfloor = \lfloor \frac{r}{k} \rfloor$：答案就是 $\lfloor \frac{l}{k} \rfloor$，直接输出 $\lfloor \frac{l}{k} \rfloor$。
2. $\lfloor \frac{l}{k} \rfloor \not = \lfloor \frac{r}{k} \rfloor$，数列会呈现不降且差小于等于  $1$ 的类型，这时他们的最大公约数就是 $1$。

我们判断一下 $\lfloor \frac{l}{k} \rfloor = \lfloor \frac{r}{k} \rfloor$ 还是 $\lfloor \frac{l}{k} \rfloor \not = \lfloor \frac{r}{k} \rfloor$，再分类输出即可。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	ios::sync_with_stdio(false);
	int t;
	cin >> t;
	while (t--) {
	    long long l, r, x;//不开 long long 见祖宗
	    cin >> l >> r >> x;
	    cout << ((l / x) == (r / x) ? (r / x) : 1) << "\n";
	}
	return 0;
}
```
谢谢大家的观看。

---

## 作者：bitsetint (赞：7)

此题分情况讨论。

当 $\lfloor\frac r x\rfloor\not=\lfloor\frac l x\rfloor$ 时，
$$
\because x\in N^+,x\ge 1
$$
$$
\therefore x+\lfloor\frac l x\rfloor\in[\lfloor\frac l x\rfloor,\lfloor\frac r x\rfloor]
$$
$$
\because \forall k,\gcd(k,k+1)=1
$$
$$
\therefore\gcd(\lfloor\frac l x\rfloor,\lfloor\frac {l+1} x\rfloor,...,\lfloor\frac r x\rfloor)=1
$$
当 $\lfloor\frac r x\rfloor=\lfloor\frac l x\rfloor$ 时，
$$
\because\lfloor\frac r x\rfloor=\lfloor\frac l x\rfloor
$$
$$
\therefore\lfloor\frac l x\rfloor=\lfloor\frac {l+1} x\rfloor=...=\lfloor\frac r x\rfloor
$$
即
$$
\therefore\gcd(\lfloor\frac l x\rfloor,\lfloor\frac {l+1} x\rfloor,...,\lfloor\frac r x\rfloor)=\lfloor\frac l x\rfloor
$$
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		long long l,r,x;
		scanf("%lld%lld%lld",&l,&r,&x);
		if((r-l)!=(r%x-l%x)){
			printf("1");
		}
		else{
			printf("%lld",l/x);
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：见贤思齐_Seakies (赞：5)

### [题目链接](https://www.luogu.com.cn/problem/P8443)

------------
### 题意概述

其实题目里已经很简练了。

$T$ 组数据，每组数据给定 $l,r,d$，求 $\gcd(\lfloor\frac{l}{d}\rfloor,\lfloor\frac{l+1}{d}\rfloor,\cdots,c)$ 的值。
（$d$ 在原题中为 $x$）

------------
### 题目分析

不难发现：

$\forall a\in[l,r],\lfloor\frac{a}{d}\rfloor \in[\lfloor\frac{l}{d}\rfloor,\lfloor\frac{l}{d}\rfloor]$ 而且序列 $a$ 是一个不下降的连续整数序列。

举个例子：

$l=8,r=11,d=4$，则 $a$ 序列为 $\{2,2,2,2\}$

$l=7,r=16,d=2$，则 $a$ 序列为 $\{3,4,4,5,5,6,6,7,7,8\}$

那么，我们可以先求出 $\lfloor\frac{l}{d}\rfloor$ 和 $\lfloor\frac{l}{d}\rfloor$ 的值，分别记为 $L$ 和 $R$ 。

最终的答案就是 $gcd(L,L+1,L+2,\cdots,R)$ 的值。

我们分情况讨论：

如果 $L=R$ ，则 $gcd(L,L+1,L+2,\cdots,R)$ 一定等于 $L$ （相同两个数的最大公约数等于本身）

如果 $L\not=R$ ，则 $gcd(L,L+1,L+2,\cdots,R)$ 一定等于 $1$ （相邻两个数的最大公约数等于一）

那么我们就可以以 $O(T)$ 的时间复杂度 solve the problem easily！

**注意：本题要开 long long ！**

------------
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 4e6 + 9;
inline LL read() {
	LL X = 0; bool flag = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') flag = 0; ch = getchar();}
	while (ch >= '0' && ch <= '9') {X = (X << 1) + (X << 3) + ch - '0'; ch = getchar();}
	if (flag) return X;
	return ~(X - 1);
}
int t;
int main() {
	cin >> t;
	while (t--) {
		LL l, r, x;
		l = read(), r = read(), x = read();
		l /= x, r /= x;
		if (l == r) cout << l << endl;
		else cout << 1 << endl;
	}
	return 0;
} 
```
------------

### 题目推荐
<https://www.luogu.com.cn/problem/P8444>

<https://www.luogu.com.cn/problem/P1029>

<https://www.luogu.com.cn/problem/P2118>

都是比较简单的题，仅供参考


---

## 作者：lilong (赞：3)

JROI 果然很良心，签到题终于可以用来签到了。

这道题一看数据范围 $1 \le l \le r \le 10^{18} $，就能知道肯定是数学题。遇到数学题不用急，我们一步步分析。

回忆小学学习的关于互质的一条性质：相邻的两个正整数互质。形式化地说，若 $a$ 和 $b$ 为两个相邻的正整数，则 $\gcd(a,b)=1$。然后，我们又不难想到，一段连续的正整数，设它们的长度为 $len$，若 $len \ge 2$，则这些数的最大公约数就是 $1$。

如果不知道为什么，可以看一下这个例子。设 $a,b,c$ 为三个连续的正整数，其中 $a<b<c$，则可得 $\gcd(a,b)=1$ 和 $\gcd(b,c)=1$。显而易见，$\gcd(a,b,c)=1$。更多个数的证明方法同理。

所以这题的思路就呼之欲出了。先分别对 $l$ 和 $r$ 除以 $x$，再判断两数是否相等，若相等，则可以说明中间的数也相等（因为从 $l$ 到 $r$ 有单调性）；若不相等，则说明中间有两个及以上的数，根据上面的推理，可知答案即为 $1$。

代码实现如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		long long l,r,x;
		cin>>l>>r>>x;
		l/=x;
		r/=x;
		if(l==r) cout<<l<<endl;
		else cout<<1<<endl;
	}
	return 0;
} 
```


---

## 作者：_sin_ (赞：2)

## P8443 gcd. 题解
这是一题数学题，我们要分两类讨论。
1. 当 $\lfloor \frac{l}{x} \rfloor = \lfloor \frac{r}{x} \rfloor$ 时。
2. 当 $\lfloor \frac{l}{x} \rfloor \neq \lfloor \frac{r}{x} \rfloor$ 时。

先说第一种。\
因为当 $\lfloor \frac{l}{x} \rfloor = \lfloor \frac{r}{x} \rfloor$ 时，区间 $[\lfloor \frac{l}{x} \rfloor , \lfloor \frac{r}{x} \rfloor]$ 中所有的数都是 $\lfloor \frac{l}{x} \rfloor$ ，所以这个区间里所有数的最大公因数为 $\lfloor \frac{l}{x} \rfloor$ 。只要输出 $\lfloor \frac{l}{x} \rfloor$ 即可，时间复杂度为 $\mathcal O(1)$ 。

再说第二种。\
因为当 $\lfloor \frac{l}{x} \rfloor \neq \lfloor \frac{r}{x} \rfloor$ 时，区间 $[\lfloor \frac{l}{x} \rfloor , \lfloor \frac{r}{x} \rfloor]$ 中必有 $\lfloor \frac{l}{x} \rfloor$ 和 $\lfloor \frac{l}{x} \rfloor +1$ ，所以这个区间里所有数的最大公因数为 $1$ 。只要输出 $1$ 即可，时间复杂度为 $\mathcal O(1)$ 。

注意 $1 \leq x \leq l \leq r \leq 10^{18}$ 所以必须开 `long long` 。

满分代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int t;
int l, r, x;

inline int read(){
	int x=0;
	bool flag=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') flag=0;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return (flag?x:~(x-1));
}

signed main(){
	t = read();
	while(t--){
		l = read();r = read();x = read();
		if ((l/x)==(r/x)) printf("%lld\n", (l/x));//第一种
		else printf("1\n");//第二种
	}
	return 0;
}
```


---

## 作者：Quidrem (赞：2)

### 题意

已经简洁明了，不再阐述。

### 思路

由于 $l,r,x$ 都是正整数，$l,l+1\cdots r$ 范围内相邻两个数相差 $1$，所以在除以 $x$ 并下取整的条件下，响铃两数之差只能为 $0$ 或 $1$。

已知相差 $1$ 的两个正整数必定互质（最大公约数为 $1$），$1$ 与任何数的最大公约数为 $1$，相同的数最大公约数即为那个数。

由此可得，从 $\lfloor\frac{l}{x}\rfloor$ 到 $\lfloor\frac{r}{x}\rfloor$ 只要有任意两个相邻数相差 $1$，这一堆数的最大公约数就是 $1$ 了。否则仅有 $\lfloor\frac{l}{x}\rfloor=\lfloor\frac{r}{x}\rfloor$ 的情况，能保证相邻的数差值为 $0$，且最大公约数为 $\lfloor\frac{l}{x}\rfloor$。

### 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll t,l,r,x;
int main(){
	scanf("%lld",&t);
	while(t--){//t不会再使用，直接减即可，避免再定义一个变量
		scanf("%lld%lld%lld",&l,&r,&x);
		if(l/x==r/x)printf("%lld\n",l/x);//longlong型变量运算过程自动向下取整
		else printf("1\n");
	}
	return 0;
}
```

---

## 作者：TheCliffSwallow (赞：2)

### 思路
显然暴力应该是不行的，我们可以仔细观察一下这个式子：

$$\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$$

分子上的数是一个一个增加的，所以其中前后两个数要么相等要么相差一，而我们知道，如果两个正整数相邻（即相差一）时，他们必然互质，所以只要 $\lfloor\frac{r}{x}\rfloor-\lfloor\frac{l}{x}\rfloor\ge1$ 时，那么这个式子必然等于 $1$，否则式子中的每个数都相等，则 $\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)=\lfloor\frac{l}{x}\rfloor=\lfloor\frac{l+1}{x}\rfloor=...=\lfloor\frac{r}{x}\rfloor$，输出任一即可。
### AC Code
```cpp
#include<iostream>
#include<cmath>
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<cstring>
#include<string>
#include<iomanip>
#include<cctype> 
#define ll long long
#define ull unsigned long long
using namespace std;
ll t,l,r,x,ans;
ll gcd(int a,int b){
	if(a<b)	swap(a,b);
	if(a%b==0)	return b;
	else	return gcd(b,a%b);
}
int main(){
	std::ios::sync_with_stdio(false);
	cin>>t;
	while(t--){
		cin>>l>>r>>x;
		if(r-l>0){//r>l
			if(r/x>l/x)	cout<<1<<endl;//相差大于等于1
			else{
				cout<<r/x<<endl;//相等
			}
		}else{//r=l
			cout<<l/x<<endl;
		}
	}
	return 0;
}
```


---

## 作者：Joker_1212 (赞：2)

# P8443 gcd. 题解

[原题传送门](/problem/P8443)

## 题意理解

给定 $l$ 和 $r$，求 $\gcd \left( \left\lfloor \frac{l}{x} \right\rfloor, \left\lfloor \frac{l+1}{x} \right\rfloor, \cdots, \left\lfloor \frac{r}{x} \right\rfloor \right)$。

## 题目分析

先说结论：

$$Ans = \begin{cases}\left\lfloor\frac{l}{x}\right\rfloor,& \left\lfloor \frac{l}{x} \right\rfloor = \left\lfloor \frac{r}{x} \right\rfloor\\1,& \text{Otherwise}\end{cases}$$

证明如下：

1. 证明 $\gcd(x, x + 1) = 1$

> 设 $x = {p_1}^{k_1}{p_2}^{k_2} \cdots {p_n}^{k_n} (p_i \ \text{是素数},\ k_i \in \mathbb{N})$。
 
> 易得 $x + 1 = {p_1}^{k_1}{p_2}^{k_1} \cdots {p_n}^{k_n} + 1$。

> 此时 $x$ 的所有因数除 $x + 1$ 都余 $1$，都不是 $x + 1$ 的因数。所以 $x$ 和 $x + 1$ 互质，即 $\gcd(x, x + 1) = 1$。

2. 证明当 $\left\lfloor \frac{l}{x} \right\rfloor \neq \left\lfloor \frac{r}{x} \right\rfloor$ 时， $Ans = 1$

> 因为 $\left\lfloor \frac{l}{x} \right\rfloor \neq \left\lfloor \frac{r}{x} \right\rfloor$，所以 至少包含 $\left\lfloor \frac{l}{x} \right\rfloor$ 和 $\left\lfloor \frac{l}{x} \right\rfloor + 1$ 两个整数。由上面的证明可知：$\gcd(\left\lfloor \frac{l}{x} \right\rfloor, \left\lfloor \frac{l}{x} \right\rfloor + 1) = 1$。又因为 $1$ 与任何数的 $\gcd$ 都为 $1$，所以 $Ans = 1$。

3. 证明当 $\left\lfloor \frac{l}{x} \right\rfloor = \left\lfloor \frac{r}{x} \right\rfloor$ 时，$Ans = \left\lfloor \frac{l}{x} \right\rfloor$

>因为 $\left\lfloor \frac{l}{x} \right\rfloor = \left\lfloor \frac{r}{x} \right\rfloor$，所以 $\left\{ \left\lfloor \frac{l}{x} \right\rfloor,\left\lfloor \frac{l+1}{x} \right\rfloor, \cdots,\left\lfloor \frac{r}{x} \right\rfloor \right\}$ 中的每个元素都等于 $\left\lfloor \frac{l}{x} \right\rfloor$。因此 $Ans = \left\lfloor \frac{l}{x} \right\rfloor$。

## AC Code


放出核心代码：

```cpp
// read() -> 快读；write() -> 快写
ll x, l, r;
read(l);
read(r);
read(x);
l /= x;
r /= x;
if (r == l) // Case 1, ans = l / x
    write(r, 10);
else        // Case 2, ans = 1
    write(1, 10);
```

[效果及全部代码](https://www.luogu.com.cn/record/80957880)

---

## 作者：Ray1 (赞：2)

核心就是把 $\lfloor \frac{l}{x}\rfloor$ 和 $\lfloor \frac{r}{x}\rfloor$ 比较一下：如果它们相等，就直接输出 $\lfloor \frac{l}{x}\rfloor$ 或 $\lfloor \frac{r}{x}\rfloor$；反之输出 $1$。

原理是相邻的两个自然数一定互质，很好证明：在辗转相除法中 $(x+1) \bmod x=1$，余数为 $1$ 则 $\gcd(x+1,x)=1$。

而如果 $\lfloor \frac{l}{x}\rfloor$ 和 $\lfloor \frac{r}{x}\rfloor$ 不相等，那么 $(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$ 中一定会出现相邻的两个自然数，故 $\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)=1$。

代码比思考简单多了。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,l,r,x;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--){
		cin>>l>>r>>x;
		if(l/x==r/x)cout<<l/x<<'\n';
		else cout<<1<<'\n';
	}
}
```


---

## 作者：Jorisy (赞：2)

一道数学题。

---

根据数据范围发现，暴力必然是不行的。

于是我们根据 $\lfloor \frac{l}{x} \rfloor$ 和 $\lfloor \frac{r}{x} \rfloor$ 分两种情况讨论。

- $\lfloor \frac{l}{x} \rfloor = \lfloor \frac{r}{x} \rfloor$。显然，答案就是 $\lfloor \frac{l}{x} \rfloor$。
- $\lfloor \frac{l}{x} \rfloor \ne \lfloor \frac{r}{x} \rfloor$。经过观察可以发现，将 $\lfloor \frac{l}{x} \rfloor,\lfloor \frac{l+1}{x} \rfloor,\dots,\lfloor \frac{r}{x} \rfloor$ 的结果去重后，答案是逐渐加一的。我们知道，相邻数两两互质，显然答案就是 $1$。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		long long l,r,x;
		cin>>l>>r>>x;
		if(l/x==r/x) cout<<l/x<<endl;
		else puts("1");
	}
 	return 0;
}
```

---

## 作者：5k_sync_closer (赞：1)

题意：求 $\gcd\limits_{i=l}^r\lfloor\dfrac ix\rfloor$，
$1\le x\le l\le r\le 10^{18}$。
# Subtask 1
特殊条件：$x=1$，问题转化为求 $\gcd\limits_{i=l}^ri$。

- $l=r$，$\gcd\limits_{i=l}^ri=l=r$，显然。（然而并没有 $x=1\bigwedge l=r$ 的数据）

- $l\neq r$，因为 $\gcd(n,n+1)=1$，所以 $\gcd\limits_{i=l}^ri=1$。

# Subtask 2
特殊条件：$l=r$。
$\gcd\limits_{i=l}^r\lfloor\dfrac ix\rfloor=\lfloor\dfrac lx\rfloor=\lfloor\dfrac rx\rfloor$，显然。
# Subtask 3
特殊条件：$r-l≤10^5$。$O(r-l)$ 暴力模拟即可。
# Subtask 4
因为 $\gcd(n,n)=n$，所以可以把 $\{\lfloor\dfrac ix\rfloor|l\leq i\leq r\}$ 去重后再扔进 $\gcd$ 里算。

容易发现 $\{\lfloor\dfrac ix\rfloor|l\leq i\leq r\}$ 去重后是一个连续正整数段，问题转化为求 $\gcd\limits_{i=\lfloor\frac lx\rfloor}^{\lfloor\frac rx\rfloor}i$。

然后就变成 Subtask 1 了。
# Code
```cpp
#include <cstdio>
int T;long long l, r, x;
int main()
{
    scanf("%d", &T);while(T--)
    {
        scanf("%lld%lld%lld", &l, &r, &x);l /= x;r /= x;
        if(l == r) printf("%lld\n", l);else puts("1");
    }
    return 0;
}
```


---

## 作者：Infinity_G (赞：1)

# 题目描述
给定 $l,r,x$，求 $\gcd(\lfloor{\dfrac{l}{x}}\rfloor,\lfloor\dfrac{l+1}{x}\rfloor,\cdots,\lfloor\dfrac{r}{x}\rfloor)$。

# 题解
令 $a=\lfloor{\dfrac{l}{x}}\rfloor,b=\lfloor\dfrac{r}{x}\rfloor$，则 $\gcd$ 中的必为区间 $[a,b]$ 中的连续正整数。

若 $a=b$，则最大公因数为 $a$；否则因为 $\gcd(a,a+1)=\gcd(a,1)=1$，所以原式的值为 $1$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll t,l,r,x;
int main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld%lld",&l,&r,&x);
		l/=x,r/=x;
		printf("%lld\n",l==r?l:1);
	}
	return 0;
}
```

---

## 作者：WaTleZero_pt (赞：1)

# $P8443$ 题解

这一题看到的第一眼，你可能感觉“我的天哪，$1 \leq x \leq l \leq r \leq 10^{18}$，这个数据量也太大了吧，怎么可能不 TLE 呢？”其实，这道题并不难，我们只需要知道一条定理，即：$\color{red}{\texttt{任意相邻的两个自然数互质}}$ 便可以轻松解决这道题目。

为什么这么说呢？首先，由 $ 1 \leq x $ 我们可以得知，对于 $l \leq i < r$，因为 $\frac{1}{x} \leq 1$，所以 $\frac{i+1}{x} - \frac{i}{x} \leq 1$，这也说明 $\lfloor \frac{i+1}{x} \rfloor - \lfloor \frac{i}{x} \rfloor \in \{0 , 1\}$，如果存在 $\lfloor \frac{i+1}{x} \rfloor - \lfloor \frac{i}{x} \rfloor = 1$，根据定理“任意相邻的两个自然数互质”，则 $\gcd(\lfloor \frac{i+1}{x} \rfloor , \lfloor \frac{i}{x} \rfloor) = 1$，那么所有数的最大公约数只可能是 $1$。如果不存在 $\lfloor \frac{i+1}{x} \rfloor - \lfloor \frac{i}{x} \rfloor = 1$ 的情况，则 $\lfloor \frac{l}{x} \rfloor$ 到 $\lfloor \frac{l}{x} \rfloor$ 之间的所有数都相等，所有数的最大公约数就是 $\lfloor \frac{l}{x} \rfloor$ 了。利用这种暴力思想，我们最多可以获得 $40$ 分暴力分。

那么如何优化呢？很简单，我们并不需要枚举 $i$，只需要比较 $\lfloor \frac{l}{x} \rfloor$ 和 $\lfloor \frac{r}{x} \rfloor$ 即可。如果不相等，那么则说明一定存在 $\lfloor \frac{i+1}{x} \rfloor - \lfloor \frac{i}{x} \rfloor = 1$ 的情况，否则所有的 $\lfloor \frac{i+1}{x} \rfloor - \lfloor \frac{i}{x} \rfloor$ 都一定等于 $0$。

## $\texttt{AC}$ $\texttt{CODE}$
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;long long l,r,x;//因为1≤x≤l≤r≤1e18，所以需要使用long long
int main(){
    scanf("%d",&t);
    for(int i=1;i<=t;i++){
        scanf("%lld%lld%lld",&l,&r,&x);
        if(l/x==r/x) printf("%d\n",l/x);//floor(l/x)==floor(r/x)的情况输出l/x(r/x也行)
        else printf("%d\n",1);//floor(l/x)!=floor(r/x)的情况输出1
    }
}

```

---

## 作者：woooooook (赞：0)

容易看出，对于任意正整数 $k$ ，满足

$$\left\lfloor\dfrac{kx}{x}\right\rfloor=\left\lfloor\dfrac{kx+1}{x}\right\rfloor=\left\lfloor\dfrac{kx+2}{x}\right\rfloor=\cdots=\left\lfloor\dfrac{kx+(x-1)}{x}\right\rfloor=k$$

$$\left\lfloor\dfrac{kx}{x}\right\rfloor=\left\lfloor\dfrac{kx+x}{x}\right\rfloor-1$$

又知 $\gcd(k,k+1)=1$ ，

所以我们容易想到

当 $\left\lfloor\dfrac{l}{x}\right\rfloor\ne\left\lfloor\dfrac{r}{x}\right\rfloor$ 时 $\gcd(\left\lfloor\dfrac{l}{x}\right\rfloor,\left\lfloor\dfrac{l+1}{x}\right\rfloor,\left\lfloor\dfrac{l+2}{x}\right\rfloor,\cdots,\left\lfloor\dfrac{r}{x}\right\rfloor)=1$ 

否则 $\gcd(\left\lfloor\dfrac{l}{x}\right\rfloor,\left\lfloor\dfrac{l+1}{x}\right\rfloor,\left\lfloor\dfrac{l+2}{x}\right\rfloor,\cdots,\left\lfloor\dfrac{r}{x}\right\rfloor)=\left\lfloor\dfrac{l}{x}\right\rfloor$ 

------------

Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,l,r,x;
inline int read(){
    int f=1,x=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return f*x;
}
signed main(){
    T=read();
    while(T--){
        l=read(),r=read(),x=read();
        if(l/x!=r/x)cout<<1<<endl;
        else cout<<l/x<<endl;
    }
    return 0;
}
```



---

## 作者：Gaode_Sean (赞：0)

此题我们需要分两种情况来讨论。

- $\lfloor \frac{l}{x} \rfloor=\lfloor \frac{r}{x} \rfloor$

不难发现数列中所有数都是相等的，答案即为 $\lfloor \frac{l}{x} \rfloor$。

- $\lfloor \frac{l}{x} \rfloor \neq \lfloor \frac{r}{x} \rfloor$

对于任意两个相邻的数，他们的公因数是 $1$。所以此时答案为 $1$。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,l,r,x;
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld%lld",&l,&r,&x);
		if(l/x==r/x) printf("%lld\n",l/x);
		else puts("1");
	}
	return 0;
}
```

---

## 作者：sixrc (赞：0)

引理：$\forall x>0,\gcd(x,x+1)=1$。

由此我们不难得到，$\forall x>0,\gcd(x,x+1,...,x+k)=1$，即 $k$ 个连续的正整数的最大公约数为 $1$。

看起来这道题做完了，但是有特殊情况，$\gcd(x,x)=x$。而 $\{\lfloor\dfrac{l}{x}\rfloor,\lfloor\dfrac{l+1}{x}\rfloor,...,\lfloor\dfrac{r}{x}\rfloor\}$ 是单调不降的。所以判断 $\lfloor\dfrac{l}{x}\rfloor$ 与 $\lfloor\dfrac{r}{x}\rfloor$ 是否相等，如相等就输出这个数，否则输出 $1$。

---

## 作者：what_else (赞：0)

### 题目大意

求若干组 $\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$ 的值

### 题目分析

$30pts$ ：暴力大法，解决一切！

$40pts$ ：

干货预备：

$$\gcd(i,i+1)=1$$

证明：

若 $i$，$i+1$ 有一个公共的约数 $v$，那么 

$$i=v\frac{i}{v},i+1=v\frac{i+1}{v}=v(\frac{i}{v}+\frac{1}{v})$$

因为 $v$ 为约数，$\frac{i}{v}$ 一定为正整数。同理 $\frac{i+1}{v}$ 一定是正整数。

所以 $\frac{1}{v}$ 一定是正整数，所以，$v=1$。

那当 $x=1$ 时，答案为 


$Ans=\begin{cases}1&l\neq r\\ \frac{l}{x}&l= r\end{cases}$

所以，你已经骗了所有的部分分！

可是骗分是~~可以~~不行的呀，所以得从正解入手。

结合之前的 $\gcd(i,i+1)=1$,考虑什么时候时，存在 $\gcd$ 中两个数相邻？

不难发现，如果满足 $t\in[l+1,r]$，$t$ 取模 $x$ 的值为 $0$ 时，即存在相邻，若不存在，答案即为 $\frac{l}{x}$。 （为什么 $l$ 可以忽略？想一想）

如果存在相邻的数，最低限度下是 $\lfloor \frac{l}{x}\rfloor$ 与  $\lfloor \frac{l}{x}\rfloor+1$。

不妨考虑 $\lfloor \frac{l}{x}\rfloor+1$ 是否在 $[\lfloor \frac{l}{x}\rfloor,\lfloor \frac{r}{x}\rfloor]$ 之内，在的话，就说明一定有相邻的数了。注意只需考虑右端点，因为$\lfloor \frac{l}{x}\rfloor+1>\lfloor \frac{l}{x}\rfloor$。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,r,x;
int t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>l>>r>>x;
		if((l/x+1)<=(r/x))
		printf("1\n");
		else 
		printf("%lld\n",l/x);
	}
}
```

---

## 作者：Cure_Wing (赞：0)

### 题目
* [丢个链接](https://www.luogu.com.cn/problem/P8443)  

### 解法
* 我们首先要知道一件事情：相邻自然数的最大公约数为 $1$。
* 其次，对于正整数 $b,c$，满足 $\left\lfloor\dfrac{a}{b}\right\rfloor=c$ 的正整数 $a$ 的个数有且仅有 $b$ 个。
* 那好了，我们拿到了第一个判定条件：
* 如果 $\left[l,r\right]$ 区间的数的个数大于 $x$ ，最大公约数就是 $1$。
* 其次，我们发现对于整个序列，相邻两个数的差值在 $\left[0,1\right]$ 之间。
* 所以当 $\left\lfloor\dfrac{l}{x}\right\rfloor\not=\left\lfloor\dfrac{r}{x}\right\rfloor$ 时，最大公约数也是 $1$。
* 对于其它的结果，序列去重后只有一个数，那么答案就是这个数。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long
using std::cin;using std::cout;
int t,l,r,x;
signed main(){
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	for(cin>>t;t--;){
		cin>>l>>r>>x;
		if(r-l>x||l/x!=r/x) cout<<1<<'\n';
		else cout<<l/x<<'\n';
	}
    return 0;
}
```

---

## 作者：Creeper_luogu (赞：0)

# P8443 「gcd.」题解

[题面链接](https://www.luogu.com.cn/problem/P8443)

## 题意简述

* 给出 $T$ 组数据，每组数据给定 $3$ 个正整数 $l,r,x$。
* 对于每组数据，我们需要求出 $\gcd(\left \lfloor \frac{l}{x} \right \rfloor,\left \lfloor \frac{l+1}{x} \right \rfloor,\cdots,\left \lfloor \frac{r}{x} \right \rfloor)$ 的值并输出。
* 对于所有数据，$1 \le x \le l \le r \le 10^{18}$，$1 \le T \le 10$。

## 题目分析

首先我要提醒大家一下：**此题要开 `long long`！**

然后接下来，我将讲述一些可以得到部分分数的思路，最后再讲正解。

### 30pts：辗转相除法

按照题目使用辗转相除法求出最大公因数。

代码详见[剪贴板](https://www.luogu.com.cn/paste/k10redet)。

### 40pts：辗转相除法 + 优化

我们可以再仔细想一想。

因为题目中公式中的分数都是以**向下取整**的方式表示出来，相当于我们在求 $r - l + 1$ 个整数的最大公因数。

我们需要了解以下的数学性质：

$\gcd(x,x+1) = 1$，也就是两个相邻的数的最大公因数是 $1$。

同理，如果 $\left \lfloor \frac{r}{x} \right \rfloor - \left \lfloor \frac{l}{x} \right \rfloor \ge 1$ 的话，那这 $r - l + 1$ 个整数的最大公约数一定为 $1$。

代码详见[剪贴板](https://www.luogu.com.cn/paste/54b1h8qq)。

### 100pts：正解

其实这道题根本用不上什么辗转相除法，我们只需要再了解一个性质就能 AC 本题了。

$\gcd(x,x) = x$，也就是两个相同的数的最大公因数是其本身。

同理，如果 $\left \lfloor \frac{r}{x} \right \rfloor - \left \lfloor \frac{l}{x} \right \rfloor < 1$ 的话，那这 $r - l + 1$ 个整数的最大公约数一定为 $\left \lfloor \frac{l}{x} \right \rfloor$。

因为此情况下， $\left \lfloor \frac{l}{x} \right \rfloor = \left \lfloor \frac{r}{x} \right \rfloor$，所以这 $r - l + 1$ 个整数的最大公约数也可以是 $\left \lfloor \frac{r}{x} \right \rfloor$。

## 正解代码

```cpp
#include <iostream>
#define ll long long
using namespace std; //预编译指令

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        ll l, r, x;
        cin >> l >> r >> x;
        if(r / x - l / x >= 1) //如果相邻输出 1
        {
            cout << 1 << endl;
            continue;
        }
        cout << l / x << endl; //否则相同输出 l / x
    }
    return 0;
}
```

---

## 作者：McIron233 (赞：0)

一定不要看见个题就马上去想正解！！！

先从理解题意入手：求 $\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$ 的值。

不难发现，题目要求的是若干个正整数的最大公因数。

再从样例研究：

- 对于第一组数据，化简后即求 $\gcd(3,4,5,6)=1$。
- 对于第二组数据，化简后即求 $\gcd(2,2,2,2)=2$。
- 对于第三组数据，化简后即求 $\gcd(1)=1$。

可以发现，当化简后的结果**全部相等或只有一个数**时，答案为**这个相等的结果**；

当化简后的结果**有连续正整数**时，答案为 $1$（连续的两个正整数互质，即 $\gcd(n,n+1)=1$）。

所以不难得到下列结论：

- 当化简后的结果有连续正整数时，即 $\lfloor \frac{l}{x}\rfloor \not = \lfloor \frac{r}{x}\rfloor$ 时，答案为 $1$；
- 当化简后的结果全部相等或只有一个数时，即 $\lfloor \frac{l}{x}\rfloor = \lfloor \frac{r}{x}\rfloor$ 时，答案便为这个相等的结果，即答案为 $\lfloor \frac{l}{x}\rfloor$，代码中直接写为 ```l/x```。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		long long l,r,x;
		cin>>l>>r>>x;
		cout<<(l/x!=r/x?1:l/x)<<endl;
	}
	return 0;
}
```

---

## 作者：ztntonny (赞：0)

## 题意
给定三个正整数 $l$,$r$,$x$，试求：$\gcd(\lfloor \frac{l}{x}\rfloor,\lfloor \frac{l+1}{x}\rfloor,\cdots,\lfloor \frac{r}{x}\rfloor)$ 的值。
## 思路
- 重要性质一：$\gcd(x,x)=x$
- 重要性质二：$\gcd(x,x+1)=1$

所以数学方法，首先如果一头一尾一样，中间也就都一样，那么通过重要性质一显然结果就是任意一个数的值。如果不一样，则必有两个以上数是连续正整数。由重要性质二推出最大公约数是 $1$ 所以输出 $1$ 即可。
```
#include <bits/stdc++.h>
using namespace std;
long long a , b , c , d , gcdans;
string s;
int main()
{
	std::ios::sync_with_stdio(false);
	cin >> a;
	for ( int h = 0; h < a; h++ )
	{
		cin >> b >> c >> d;
		if ( b / d == c / d )//case1
		cout << c / d << endl;
		else//case2
		cout << 1 << endl;
	}
	return 0;
}
```


---

## 作者：arrow_king (赞：0)

~~如果没过就当做学习笔记吧~~

## 言归正传

求出 $\gcd\left(\left\lfloor\dfrac{l}{x}\right\rfloor,\left\lfloor\dfrac{l+1}{x}\right\rfloor,\left\lfloor\dfrac{l+2}{x}\right\rfloor,\dots,\left\lfloor\dfrac{r}{x}\right\rfloor\right)$。

本来可以直接用辗转相除法求 $\gcd$ 的，但是一看数据范围，$1\leq x\leq l\leq r\leq10^{18}$，$\mathcal{O}(Tn\log_2n)$ 时间复杂度当场爆炸。

所以只能用 $\mathcal{O}(T)$ 算法了。

所以抛开 $T$ 不谈，如何求出这些数的 $\gcd$ 呢？

对于多个连续正整数的最大公约数，易得：

$$\gcd(l,l+1,l+2,\dots,r)=1\qquad\qquad(l<r)$$

这很显然，因为连续的多个正整数，相邻的两个数一定互质，所以所有数的 $\gcd$ 就一定是 $1$ 了。

**那这道题就结束了。**

因为 $l,l+1,l+2,\dots,r$ 是连续的正整数，所以 $\left\lfloor\dfrac{l}{x}\right\rfloor,\left\lfloor\dfrac{l+1}{x}\right\rfloor,\left\lfloor\dfrac{l+2}{x}\right\rfloor,\dots,\left\lfloor\dfrac{r}{x}\right\rfloor$ 也是连续的正整数，所以就可以套上面的结论。

如果 $\left\lfloor\dfrac{l}{x}\right\rfloor=\left\lfloor\dfrac{r}{x}\right\rfloor$，那么中间所有数都相等（那是必然的，因为向下取整），那么它们的最大公因数就是 $\left\lfloor\dfrac{l}{x}\right\rfloor$ 或 $\left\lfloor\dfrac{r}{x}\right\rfloor$。如果不相等，则最大公因数为 $1$。

## 代码如下（记得开 long long）：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long t,l,r,x;		//记得开long long！
int main() {
    scanf("%lld",&t);
    while(t--) {
        scanf("%lld%lld%lld",&l,&r,&x);
        long long t1=l/x,t2=r/x;		//计算两端值
        if(t1==t2) printf("%lld\n",t1);		//若一样，输出左或右的值
        else printf("1\n");		//不一样，输出1
    }
    return 0;
}
```

---

## 作者：Asimplename (赞：0)

## 思路

首先，很容易发现，两个相邻的正整数的最大公约数一定为 $1$。

所以，若 $\lfloor \frac{l}{x}\rfloor, \lfloor \frac{r}{x}\rfloor$ 不同，说明式子中一定有与 $\lfloor \frac{l}{x}\rfloor$ 相邻的数。此时 求出的 $\gcd$ 的值为 $1$。于是，后面求 $\gcd$ 时结果一定都为 $1$。

反之，若 $\lfloor \frac{l}{x}\rfloor, \lfloor \frac{r}{x}\rfloor$ 相同，说明式子中只有 $\lfloor \frac{l}{x}\rfloor$ 这一种数。直接输出它即可。

## 代码

```cpp
#include<iostream>
using namespace std;
long long l,r,x = 0;
int T = 0;
int main () {
	cin >> T;
	for(int i = 1; i <= T; i ++){
		cin >> l >> r >> x;
		if(l / x == r / x){
			cout << l / x << endl;
		}
		else{
			cout << 1 << endl;
		}
	}
	return 0;
} 


---

## 作者：LYqwq (赞：0)

$\textsf{update on 2022/8/10 修了下代码。}$

---

[题目传送门](https://www.luogu.com.cn/problem/P8443)

# 题目大意

给定 $l,r,x$，求 $\gcd\left(\left\lfloor\dfrac{l}{x}\right\rfloor,\left\lfloor\dfrac{l+1}{x}\right\rfloor,\dots\left\lfloor\dfrac{r}{x}\right\rfloor\right)$。

特别的，我们定义一个正整数的最大公约数是它本身。

多组数据。

# 思路

我们先来试着把数套进这个柿子里，找找规律。

例如第一组样例：

$l=3,r=6,x=1$。

我们试着套进去：

$$
\begin{aligned}
    \gcd\left(\left\lfloor\dfrac{l}{x}\right\rfloor,\left\lfloor\dfrac{l+1}{x}\right\rfloor,\dots\left\lfloor\dfrac{r}{x}\right\rfloor\right)&=
    \gcd\left(\left\lfloor\dfrac{3}{1}\right\rfloor,\left\lfloor\dfrac{4}{1}\right\rfloor,\left\lfloor\dfrac{5}{1}\right\rfloor,\left\lfloor\dfrac{6}{1}\right\rfloor\right)\\
    &=\gcd(3,4,5,6)\\
\end{aligned}

$$

我们发现，需要参与计算的数是单调上升的，且都是相邻的。

那么我们根据一条性质：相邻的数一定互质。

可以得出这个答案为 $1$。

接着我们套第二组数据 $l=8,r=11,x=4$，发现是这样的：$\gcd(2,2,2,2)$。

答案即为 $2$。

那如果我们把 $r$ 改成 $12$ 呢？

那么就多了个 $\left\lfloor\dfrac{12}{4}\right\rfloor=3$，刚好是 $2+1$，与 $2$ 互质，答案就从 $2$ 变为了 $1$。

我们可以发现，参与 $\gcd$ 的数由这样三部分组成：

- 首端：一组最少 $1$ 个，最多 $x$ 个相同的数，这个数即为 $\left\lfloor\dfrac{l}{x}\right\rfloor$。
  
- 中间：若干组由 $x$ 个相同的数组成的数列。每组中的数为上一组中的数加一。可以没有这个部分。
  
- 末尾：同首端。如果没有中间部分，也没有这个部分。
  

为什么就这么肯定由这几部分组成呢？

先来看看 $l=0$ 到 $r=20$ 每个数除以 $x=4$ 的结果：

$0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5$。

很容易从中看出规律来。正如上所述。

显然，只要有两个不同的数，答案就一定为 $1$。

于是我们就可以直接判断 $\left\lfloor\dfrac{l}{x}\right\rfloor$ 和 $\left\lfloor\dfrac{r}{x}\right\rfloor$ 是否相等即可。

若相等，则整个数列里的数都相同，显然它们的最大公约数即为它们本身。

$$
ans=
\begin{cases}
    1&\left\lfloor\dfrac{l}{x}\right\rfloor\ne\left\lfloor\dfrac{r}{x}\right\rfloor\\\\
    \left\lfloor\dfrac{l}{x}\right\rfloor&\left\lfloor\dfrac{l}{x}\right\rfloor=\left\lfloor\dfrac{r}{x}\right\rfloor\\
\end{cases}

$$

# 代码

```cpp
#include <iostream>
using namespace std;
int t;
long long l,r,x;

int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%lld%lld%lld",&l,&r,&x);
        printf("%lld\n",l/x!=r/x ? 1 : l/x);
    }
    return 0;

}
```

---


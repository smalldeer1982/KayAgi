# [蓝桥杯 2013 省 AB] 错误票据

## 题目背景

某涉密单位下发了某种票据，并要在年终全部收回。

## 题目描述

每张票据有唯一的 ID 号，全年所有票据的 ID 号是连续的，但 ID 的开始数码是随机选定的。因为工作人员疏忽，在录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号。

你的任务是通过编程，找出断号的 ID 和重号的 ID。

数据保证断号不可能发生在最大和最小号。


## 样例 #1

### 输入

```
2
5 6 8 11 9
10 12 9```

### 输出

```
7 9
```

## 样例 #2

### 输入

```
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119```

### 输出

```
105 120```

# 题解

## 作者：alex_liu (赞：92)

[题目传送门](https://www.luogu.com.cn/problem/P8598)

## 思路：

比较水的模拟，每次输入一个数 $x$，就将记录 $x$ 出现了多少次的 $a[x]+1$，查找断号只需要从头到尾扫一遍，对于每一个 $i$，当 $a[i-1]=1$ 且 $a[i+1]=1$ 且 $a[i]=0$ 时便可以判定为断号。

## 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,a[100005],ans1,ans2;
signed main(){
	cin>>n;
	while(cin>>x)a[x]++;
	for(int i=1;i<=10004;i++){
		if(a[i-1]&&a[i+1]&&!a[i])ans1=i;
		if(a[i]>1)ans2=i;
		if(ans1&&ans2)break;
	}
	cout<<ans1<<" "<<ans2<<endl; 
	return 0;
}


```

代码中添加了一些小优化，如果断号和重号都已经判定出来了，就可以直接跳出循环。

---

## 作者：sw2022 (赞：58)

## 题意简析

给定一个序列，找这个序列的值域中出现两次的数和没出现的数。思路很简单，排序之后扫一遍即可，这里主要讲如何正确输入（此处“正确输入”指在输入合法的情况下不需要手动输入 EOF 字符）。

这里给出了行数，显然我们可以想到使用字符串按行读入，如 C++ 风格的 `string` 字符串，我们就可以用 `getline` 读入一行。那么如何把 `string` 中不定数量的 `int` 提取并存入数组呢？我们可以使用 `stringstream` 定义一个字符串流，然后就可以像 `cin` 一样提取数字了。对于不定数量，也如同 `cin` 中读到 EOF 就停止读入那样，`stringstream` 会在字符串结束时停止读入。对于 C 风格的 `char*` 字符串，`sscanf` 也有类似用法，不再赘述。

由于本题涉及 `cin` 和 `getline` 混用，因此需要使用 `cin.ignore(numeric_limits<streamsize>::max(),'\n');` 来提取第一行的换行符，并将流指针移动到下一行。

## 代码/解释
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],l;
int main()
{
	int N,m,n,i;
	string s;
	cin>>N;
	cin.ignore(numeric_limits<streamsize>::max(),'\n');
	for(i=1;i<=N;i++)
	{
		getline(cin,s);
		stringstream sin(s);
		while(sin>>a[++l]);
	}
	sort(a+1,a+l+1);
	for(i=2;i<=l;i++)
	if(a[i]==a[i+1]-2) m=a[i]+1;
	else if(a[i]==a[i+1]) n=a[i];
	printf("%d %d\n",m,n);
	return 0;
} 


---


# [yLOI2023] 分解只因数

## 题目描述

给定一个正整数 $n$，对 $n$ 分解质因数。

设 $n = p_1 \times p_2 \times p_3 \times \dots \times p_x$，其中 $p_i$ 均为质数。

如果 $p_i$ 均为奇数，则称 $n$ 为『只因数』。

现在，给出若干个 $n$，请你判断 $n$ 是不是『只因数』。

## 说明/提示

### 数据规模与约定

本题共有 $10$ 个测试点。对第 $i$ 个测试点，$T = \max(1, i - 1)$。

- 对 $30\%$ 的数据，$n \leq 3$。
- 对 $50\%$ 的数据，$n \leq 10$。
- 另有 $10\%$ 的数据，$n$ 为奇数。
- 另有 $10\%$ 的数据，$n$ 为偶数。
- 对 $90\%$ 的数据，$n \leq 10^9$。
- 对 $100\%$ 的数据，$1 \leq T \leq 9$，$2 \leq n \leq 10^{18}$。

### 说明

本题共有两个附加样例文件，见题目附件中的 `ibvl.zip`。

## 样例 #1

### 输入

```
5
2
3
4
6
9```

### 输出

```
No
Yes
No
No
Yes```

# 题解

## 作者：一扶苏一 (赞：48)

# [yLOI2023] A 分解只因数

> 出题人小黑子树脂 66

## Description

对一个正整数 $n$，如果它只含奇质因子，则称它是『只因数』。

有 $T$ 组数据，每次给定 $n$，请判定 $n$ 是不是只因数。

$T \leq 9$，$2 \leq n \leq 10^{18}$。

## Analysis

### 算法 0

~~根据生活经验，『只因』常被空耳为『ji』音。于是合理推测『只因数』就是奇数。~~

### 算法 1

$n \leq 10$ 时，手算打表一下就可以。期望得分 $50$ 分。

### 算法 2

$n \leq 10^9$ 时，可以 $O(\sqrt n)$ 暴力枚举质因子然后做判断。以下是一个简单的枚举质因子程序：

```cpp
bool isChicken(const int n) {
  int m = n;
  for (int i = 1; i * i <= n; ++i) while (m % i == 0) {
    m /= i;
    if (isEven(i)) return false; // isEven 判断 i 是不是偶数
  }
  if (isEven(m)) return false;
  return true;
}
```

共 $T$ 组数据，于是总时间复杂度为 $O(T \sqrt n)$。期望得分 $90$ 分。

### 算法 3

考察质数的特点：偶质数有且仅有 $2$ 一个数。

于是只含奇质因子的条件等价为不含偶质因子，也就是不含 $2$ 这个因子。

显然：含有因子 $2$ 的数一定是偶数，不含因子 $2$ 的数一定是奇数。

所以偶数不是只因数，奇数是只因数。~~与生活经验相同~~。

时间复杂度 $O(T)$，期望得分 $100$ 分。需要开 long long。

## Code

```cpp
#include <iostream>

int main() {
  int T;
  for (std::cin >> T; T; --T) {
    long long n; std::cin >> n;
    std::cout << ((n & 1) ? "Yes" : "No") << std::endl;
  }
}
```

## Generator

```cpp
void makedata(int T) {
  int t = std::max(1, T - 1);
  printf("%d\n", t);
  if (T == 1) {
    puts("2");
  } else if (T == 2) {
    puts("3");
  } else if (T == 3) {
    puts("2\n3");
  } else if (T <= 5) {
    for (int i = 1; i <= t; ++i) printf("%d\n", 2 + modx(9));
  } else if (T == 6) {
    for (int i = 1; i <= t; ++i) {
      int x = modx(1000000000);
      while (x <= 2) x = modx(1000000000);
      if ((x & 1) == 0) --x;
      printf("%d\n", x);
    }
  } else if (T == 7) {
    for (int i = 1; i <= t; ++i) {
      int x = modx(1000000000);
      while (x <= 2) x = modx(1000000000);
      if ((x & 1) == 1) --x;
      printf("%d\n", x);
    }
  } else if (T <= 9) {
    for (int i = 1; i <= t; ++i) {
      int x = modx(1000000000);
      while (x == 1) x = modx(1000000000);
      printf("%d\n", x);
    }
  } else {
    for (int i = 1; i <= t; ++i) {
      long long x = modx(1000000000000000000ll);
      while (x == 1) x = modx(1000000000000000000ll);
      printf("%lld\n", x);
    }
  }
}
```

---

## 作者：InversionShadow (赞：22)

## P9063 [yLOI2023] 分解只因数 题解

### 思路：

偶质数只有 $2$，如果这个数为偶数，则它可以分解因数 $2$，不为 “只因数”，否则为 “只因数”。

**$n\le10^{18}$，需开 `long long`。**

---

## 作者：NaOHqwq (赞：17)

~~出题人小黑子（确信~~

## 题意

题面是这样的：

给定一个正整数 $n$，对 $n$ 分解质因数。

设 $n = p_1 \times p_2 \times p_3 \times \dots \times p_x$，其中 $p_i$ 均为质数。

如果 $p_i$ 均为奇数，则称 $n$ 为『只因数』。

现在，给出若干个 $n$，请你判断 $n$ 是不是『只因数』。

简化一下就是对一个整数分解质因数，判断它的质因数是否全是奇数。

## 思路

这题可以用普通的思路求解，即老老实实地分解质因数然后再老老实实地判断每一个是否能被 $2$ 整除。

但是我们要知道 $2$ 是唯一的偶质数，所以只要判断 $n$ 的质因数里有没有 $2$ 即可。

但是思路其实还可以再简化。我们还知道因数中含有偶数的就是偶数，没有偶数的就是奇数；再看到上面的分析，可得『只因数』即质因数中含有 $2$ 的数都是偶数，非『只因数』即质因数中不含有 $2$ 的都是奇数。

到这里，这道看起来很有难度的题目就被简化成了判断奇偶数的问题。~~（这就是数学的力量吗）~~

下面的代码放的就是最终简化后思路的代码，一个简单的奇偶数判定。

但是还是要有温馨提示的：不开 `long long` 见祖宗，笔者就在这里崩了好几次（

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long t, n; //一定要记得开long long！
	cin >> t;
	while(t--){
		cin >> n;
		if(n % 2 == 0){
			cout << "No" << endl;
		}else{
			cout << "Yes" << endl;
		} //只因数（奇偶数）判定
	}
	return 0;
}
```

---

## 作者：_Haoomff_ (赞：7)

我们知道，质数中只有一个偶数：$2$。
## 赛后思路
水题，只要判断奇偶数即可：若给出的数为偶数，那么对它分解质因数必定含有 $2$；若给出的数为奇数，那么对它分解质因数必定没有 $2$。

```cpp
#include<bits/stdc++.h>
#define ll long long//注意
using namespace std;
ll t,n;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	for(;t--;){
		cin>>n;
		if(n%2==1)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```
## 赛时思路
比赛当时我的脑子怎么会那么混乱？刚看到题目竟然去打了分解质因数，后来发现有难点，于是观察了一下数据，可以发现，偶数都不是“只因数”，奇数都是“只因数”，为了证明我的观察，又列了几个奇数：

$3=3$，$5=5$，$7=7$，$9=3*3$，$11=11$，$13=13$，$15=3*5$，$17=17$，$19=19$，$21=3*7$，$23=23$，$25=5*5$，$27=3*3*3$……

于是，我便斗胆尝试了一下。赛后重温，就想出了前面的赛后思路，是赛时太紧张了吗？

---

## 作者：fengziyi (赞：6)

### 题意
分解给定的 $n$ 的质因数，判断是否全为奇数。
### 思想
~~因为我不是黑子，所以我根本没考虑“只因”的发音对思路的极大提示。~~  
当我首次看到本题时，立马手写了欧拉筛。  
```cpp
void GetPrime(longint n)
{
	...
}
...
for (reg int i = 1; i <= sqrt(n); ++i)
{
    if (n % Prime[i] == 0 && Prime[i] % 2 == 0)
    {
        flag = false;
        break;
    }
    while (n != 1 && n % Prime[i] == 0)
        n /= Prime[i];
    if (n == 1)
        break;
}
...
```
筛到 $ 5 \times 10^7 $ 需要 500ms。  
然后放心的 Ctrl+S。  
然后一看样例——这规模数组存的下？！  
当我~~荔枝地~~考虑出题人是不是~~黑子~~想做什么，同机房的 dalao 交题时大喊一声“ji”时，我好像明白了什么。。。  
**『只因数』==『奇数』**  
显然对于一个正整数，它有可能存在的偶数质因数只有 $ 2 $。  
如果它存在一个偶数质因数，那它就不是『只因数』。  
综上所述：只需要判断 $ n $ 的奇偶性即可。  
### 贴个代码  
```cpp
int main()
{
    reg int T;
    scanf("%d", &T);
    while (T--) 
    {
        scanf("%lld", &n);
        printf(n % 2 ? "Yes\n" : "No\n");
    }
    return 0;
}
```
未放出全文，珍惜账号请勿 ctj。

---

## 作者：千早爱音 (赞：6)

没错我被诈骗了，不过还是能过题。

考虑不观察性质直接模拟，跑 Pollard-rho 分解质因数之后直接判断质因子里有没有质因子是偶数即可。

时间复杂度 $ \mathcal{O}(Tn^\frac{1}{4}) $，可以通过。数据还需要加强！

代码：（模板过长放云剪贴板）

[模板代码](https://www.luogu.com.cn/paste/cpc2see7)

```cpp
/*模板代码*/
int main() 
{
    uint64_t T;
    cin>>T;
    while(T--)
    {
        uint64_t x;
        cin>>x;
        bool ok=1;
        auto map = OY::Pollard_Rho::decomposite(x);
        for(auto now:map)
        if(now.prime%2==0)
        ok=0;
        if(ok)
        puts("Yes");
        else
        puts("No");
    }
}
```


---

## 作者：Trump__Biden (赞：4)

~~我是“IKUN”，这题太符合我的胃口了。~~

### 思路：
题中说了，$ n $ 是由若干个质数相乘到得到的，如果所有相乘的数都是质数并且都是奇数，则 $ n $ 是只因数。学过小学数学的都知道，在所有的质数中，只有 $ 2 $ 是偶数，其余的均为奇数，那么我们就只需要判断 $ n $ 是不是 $ 2 $ 的倍数，就可以判断它是否是只因数了。

### 代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,x;
signed main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&x);
		if(x%2==0){
			printf("No\n");
		}
		else{
			printf("Yes\n");
		}
	}
	return 0;
}
```
一定要注意数据范围！！！

---

## 作者：Fiendish (赞：3)

我太弱了，这道题是我第一次见过的能在比赛中一遍切的题......

只因数的定义是将一个正整数分解质因数后只要有一个质因数是偶数就是只因数

一看就明白，是偶数的质因数只有 $2$ 呀！

这就解决了

对于每一个数，只需要判断每一个数是否被 $2$ 整除，如果被 $2$ 整除就代表它一定是只因数，所以时间复杂为线性的，是 $\Theta(T)$ 

注意数据范围： $2\le n\le10^{18}$

给出代码如下

```cpp
#include<iostream>
using namespace std;
int main(){
	int t;
	long long a;//注意数据范围
	cin>>t;
	for(int i=1;i<=t;i++){//线性复杂度
		cin>>a;
		if(a%2==0){//判断是否是偶数，即它的质因数里有没有偶数
			cout<<"No";
		}
		else cout<<"Yes";
		cout<<endl;
	}
}
```

~~码风不好，大佬勿喷~~

---

## 作者：ImNot6Dora (赞：3)

很水的一道题，但是巧妙的把“只因”这个东西和质因数连起来了。。。。

先看题目，如果将 $n$ 分解质因数之后所有的 $p_i$ 均为奇数，那么就是说，$p_i$ 不能为偶数。

显而易见，偶数中只有 $2$ 是质数，而一个偶数分解质因数一定有 $2$，一个奇数分解质因数不可能有 $2$。

结合上述分析，得知当 $n$ 为奇数时才能是只因数。

总而言之，言而总之，这道题就那么水。

# AC CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long t,n;
	cin>>t;
	while(t--){
		cin>>n;
		cout<<(n%2==0?"No":"Yes")<<endl;
	} 
	return 0;
}

```
By ImNot6Dora

---

## 作者：AKPC (赞：2)

小黑子（
### 思路
如果把一个奇数分解质因数，分解后必定全是奇数。  
如果把一个偶数分解质因数，分解后必定有至少一个偶数。

这是因为任何偶数可以整除 $2$，奇数都不能整除 $2$，而 $2$ 就是唯一一个偶质数。

所以直接判断奇偶性即可。
### 代码
```cpp
#include <bits/stdc++.h>
#define IOI using
#define AK namespace
#define ME std
IOI AK ME;
#define int long long
signed main(){
	int n,x;
	cin>>n;
	while (n--){
	    cin>>x;
	    if (x%2==0) puts("No");
	    else puts("Yes");
	}
	return 0;
}
```


---

## 作者：Xiphi (赞：2)

简单数学题。如果 $n$ 可以被 $2$ 整除，也就是 $n$ 为偶数，那么分解出的质因数必然有一个 $2$，输出`No`。如果 $n$ 为奇数，那么绝对不可能被唯一的偶质数 $2$ 整除，所以输出 `Yes`。

代码：
```cpp
#include<iostream>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        long long n;//记得开long long
        cin>>n;
        if(n%2==1) puts("Yes");//判断奇偶性，奇数就输出Yes，否则输出No
        else puts("No");
    }
}
```

---

## 作者：二叉苹果树 (赞：1)

首先有我们两个熟知的事实。

- 大于等于 $2$ 的整数都可以被分解质因数。
- 若干个自然数相乘，乘数中有偶数则结果一定是偶数。

均可使用反证法简单得出。

故只要被分解的数 $n$ 是偶数，那么他的分解质因数结果中就一定有 $2$ 这个唯一的偶质数，从而 $n$ 不是一个只因数。

也就是说，实际上这题要求判断 $n$ 的奇偶性即可。

```cpp
    if (n & 1)
        std::cout << "Yes" << std::endl;
    else
        std::cout << "No" << std::endl;
```


---

## 作者：ztrztr (赞：1)

# P9063 题解
在 <https://ztrblog.ml/archives/205> 食用更佳

> 只因数...

## 分析

质数中，只有 $2$ 是偶数。有因数 $2$ 的数是且只是偶数，所以这道题就是让我们分析一个数是不是偶数。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int T; cin >> T;
    while (T --) {
        long long n; cin >> n;
        cout << (n % 2 == 0 ? "No\n" : "Yes\n");
    }
    return 0;
}
```



---

## 作者：Light_Star_RPmax_AFO (赞：1)

这题需要开 long long 否则存不下。

# 方法一（最优解）

这个方法在题目名字中就提示了，“只因”（~~鸡~~奇）

只需要一个循环就可以了，来控制数据组数。

因为在所有质数中只有一个偶数质数 $2$，所以只要质因数中没有 $2$ 就可以算作只因数，只要不可以被 $2$ 整除在质因数中就没有 $2$，此时我们就可以输出 Yes 否则如果在所有质因子中有 $2$ 的存在这时候就可以被 $2$ 整除，那么有 $2$ 的时候，它的质因数中就有偶数的存在，这时候输出 No。

所以我们就只要用判断质数的方法。

```cpp
long long T,n;
cin>>T;
while(T--)
{
	cin>>n;
	if(n%2==1)//只需要判断一下是否为奇数。
		cout<<"Yes"<<endl;
	else
		cout<<"No"<<endl;
}
```
当然还可以使用**位运算**优化

```cpp
long long T,n;
cin>>T;
while(T--)
{
	cin>>n;
	if(n&1)//只需要判断一下是否为奇数。
		cout<<"Yes"<<endl;
	else
		cout<<"No"<<endl;
}
```


# 第二种

枚举每个因数，再去看每个因数是不是奇数，这就非常暴力了。

```cpp
while(T--){
	int n;
	cin>>n;
	i=2;
	zhiyin=1;
	while(n!=1&&i<=n){
		if(n%i==0){
			n/=i;
			if(i%2==0){
				puts("No");
				zhiyin=0;
				break;
			}
		}
		else i++;
	}
	if(zhiyin){
		puts("Yes");
	}
}
```
然而只有 90 分。

所以还是第一种方法好。

# 第三种

由于数据点不够 hack 就出现此解法。

想知道此解法请看。

[这](https://www.luogu.com.cn/blog/JJL0610666/b3715-fen-xie-zhi-yin-zi-2-post)

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	long long T, n;
	cin >> T;
	while (T--) {
		cin >> n;
		long long i = 0;
        bool g=0;
		i = 0;
		for(i=2;i<=sqrt(n);i){
			if (n % i == 0){
                n /= i;
                if (i % 2 == 0){
                    cout<<"No"<<endl;
                    g=1;
                    break;
                }
            }
			else i++;
		}
        if(g)continue;
		if (n % 2 == 0){
            cout<<"No"<<endl;
            continue;
        }
        cout<<"Yes";
        cout<<endl;
	}
}
```

完结 ✿✿ヽ(°▽°)ノ✿。


---

## 作者：yszkddzyh (赞：1)

容易证明奇数都是只因数，偶数都不是，下面给出大概的证明过程：

先证偶数：都知道偶数是 $2$ 的倍数，而 $2$ 是质数，所以偶数一定有质因数 $2$，而 $2$ 又是偶数，所以偶数都不是只因数（因为它的质因数中不全是奇数）。

再证奇数：有过小学数学基础的都知道，偶数乘任意整数还是偶数，所以奇数的质因数中一定不能包含偶数，那么它的质因数就全是奇数，符合只因数的定义，所以奇数一定是只因数。

证出以上结果后，我们就能很方便地得出代码：
```cpp
#include <iostream>//个人不建议使用万能头
#define int long long//一定要开long long
using namespace std;
int t,n;
signed main(){
    scanf("%lld",&t);
    while(t--){
        scanf("%lld",&n);
        if(n&1) printf("Yes\n");//用位运算可以更快地判断奇数
        else printf("No\n");
    }
    return 0;
}
```


---

## 作者：a2lyaXNhbWUgbWFyaXNh (赞：0)

xhzyhwjgg/fn

### 题意

给定由多个素数 $p_i$ 相乘的数 $n\ (2\le n\le 10^{18})$，判断是否所有的 $p_i$ 均为奇数。

### 解法

小五数学。

当一个数为奇数，则其没有偶数因子，反之亦然，正确性显然。

然后只有 $2$ 是偶素数。也就是说当 $n$ 为奇数时没有偶质因子。

代码（C 语言）：

```c
main(n){scanf("%d",&n);while(~scanf("%d",&n))puts(n&1?"Yes":"No");}}
```

因为代码很有 IOCCC 和 CodeGolf 既视感，所以解释一下一些令人困惑的地方。

在 C 语言中，没有声明返回值类型的函数和变量自动为 `int` 类型。专业术语叫什么隐式声明。不过 C++ 应该是没了，毕竟除了 CodeGolf 以外没啥用。还是个万恶之源。

顺便提一句，C 语言自动嵌入 `stdio.h`。

然后，`scanf()` 读到 `EOF` 返回 $-1$，取反后得 $0$，也就是说一直读到结束。因为是读到结束，所以 $T$ 没什么必要。

最后，按位与取得 $b$ 最后一位用于判断奇偶性。溢出也不影响结果。

> _完美结束。_

[ ](这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？这能过？)

---

## 作者：rai1gun (赞：0)

### 题解

给定一个正整数 $n$，对 $n$ 分解质因数。

因为 $n = p_1 \times p_2 \times p_3 \times \dots \times p_x$，且 $p_i$ 均为奇数，所以没有 $p_i$ 为 $2$。

也就是说，$n$ 没有约数 $2$，因此所有只因数必为奇数。

因此，题目便变化成了判断 $n$ 是否为奇数。

### 代码

```cpp
#include<iostream>
using namespace std;
int main(){
	long long n,Q;//注意开 long long
	scanf("%lld",&Q);
	while(Q--){
		scanf("%lld",&n);
		printf(n&1?"Yes\n":"No\n");
	}
	return 0;
}
```

---


# [PA 2020] Wybór zadań

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Wybór zadań](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/wyb/)**

对 Matthew 来说，准备 PA 的线上比赛是一个相当大的挑战。在比赛期间，参赛者参加五轮比赛，编号从 $1$ 到 $5$。在每轮比赛中，参赛者需解决三个组别的任务，称为 A、B 和 C。在前四轮比赛中，每一组别都会有一道题，在最后的第五轮比赛中，每一组别都会有两道题。因此，必须一共造 $18$ 道题，并分配给 $15$ 个不同的位置，其中三个位置（5A、5B 和 5C）必须各分配两道题。我们这里所说的位置是指轮次和组别的组合。

Matthew 知道不能只是随便出 $18$ 道题。题目的难度应该适合他们出现的轮次和组别。他在一整年中整理了 $n$ 道题的想法。对于这些想法，他都知道这道题会适合哪个位置（只会适合这一个位置，其他位置都不适合）。

Matthew 想知道是否可以从他的想法中选出 $18$ 道题并正确地分配它们的位置。给定他的笔记记录，请帮他找出一种选择方案。

## 说明/提示

#### 样例 1 解释

在第一个样例中，Matthew 有三个符合 5C 位置的题目想法。删掉其中任何一个后，其余的想法就组成了一套合适的 PA 题目。

------------

#### 样例 2 解释

在第二个例子测试中，Matthew 只有一道题与 5B 位置相匹配，所以他组不出一套 PA。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 100$。

## 样例 #1

### 输入

```
19
3B 4B 5B 4C 5C 3C 1A 5A 5C 3A 5A 2C 1B 2A 5B 5C 2B 1C 4A```

### 输出

```
TAK```

## 样例 #2

### 输入

```
20
2B 4B 4C 5A 5C 5C 4A 1B 3A 4A 2A 3B 1B 1C 1A 5A 2C 1B 5B 3C```

### 输出

```
NIE```

# 题解

## 作者：封禁用户 (赞：8)

# 思路
输入 $n$ 个字符串，将字符串的两项转为数字并存入一个二维数组。

定义一个二维数组存储每种题目的数量，每次输入后找到对应的项加上一。最后扫一

遍这个二维数组。扫描的时候要注意一下有 $3$ 种题目要出现 $2$ 次才可以。

详细思路请见代码。

# Code：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
int a[10][10];//第一项表示比赛编号，第二项表示题目编号
string s;//输入的题号，不用再说
int n;
bool flag;//如果有空的项，就让flag=1，如果flag=1，输出NIE，否则输出TAK
int main(){
    cin>>n;
    if(n<18){
        cout<<"NIE";
        return 0;//如果n比18小，直接结束程序
    }
    for(int i=1;i<=n;i++){
        cin>>s;
        int sum=s[1]-64;//这里将字母转为数字，A转为1，B转为2，C转为3
        a[s[0]-'0'][sum]++;//s[0]-'0'->字符转数字
    }
    for(int i=1;i<=4;i++){//先判断前4次
        for(int j=1;j<=3;j++){
            if(a[i][j]<1) flag=1;//如果发现空的项，就让flag=1
        }
    }
    if(a[5][1]<2||a[5][2]<2||a[5][3]<2) flag=1;//第五场比赛单独判断
    if(flag==0) cout<<"TAK";//判断flag是否为1
    else cout<<"NIE";
    return 0;
}
```
感谢观看！

[AC记录，供参考](https://www.luogu.com.cn/record/104292002)

 $2023.3.9$ : 初次提交。
 
 $2023.3.12$ : 添加 $LaTeX$ 公式/英文与汉字之间的空格以及句号，并细化思路。
 
 最后感谢审核员提出的建议。





---

## 作者：lichenzhen (赞：5)

## 题目大意
有 $15$ 种不同类型的题目，看看 $n$ 道题目中是否全都包含了这些题目，但是`5A`、`5B`、`5C`应出现两道。

## 题目解法
一道水题，可以用桶思想解决。

定义一个桶存储每种题目的数量，每次输入后找到对应的桶加上一。最后扫一遍这个桶。

扫描的时候要注意一下有 $3$ 种题目要出现 $2$ 次才可以。

具体细节看代码。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,book[20];//book是一个桶，变量定义在全局会自动清零
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s;
        if(s[0]=='1'){//开始判断
            if(s[1]=='A') book[1]++;
            if(s[1]=='B') book[2]++;
            if(s[1]=='C') book[3]++;
        }
        if(s[0]=='2'){
            if(s[1]=='A') book[4]++;
            if(s[1]=='B') book[5]++;
            if(s[1]=='C') book[6]++;
        }
        if(s[0]=='3'){
            if(s[1]=='A') book[7]++;
            if(s[1]=='B') book[8]++;
            if(s[1]=='C') book[9]++;
        }
        if(s[0]=='4'){
            if(s[1]=='A') book[10]++;
            if(s[1]=='B') book[11]++;
            if(s[1]=='C') book[12]++;
        }
        if(s[0]=='5'){
            if(s[1]=='A') book[13]++;
            if(s[1]=='B') book[14]++;
            if(s[1]=='C') book[15]++;
        }
    }
    for(int i=1;i<=15;i++)//扫描这个桶
    {
        if(i>=13){//第13~15个桶里存着要出现两次的题目，所以要特判
            if(book[i]<2){
                cout<<"NIE"<<endl;
                return 0;
            }
        }
        else{
            if(book[i]==0){
                cout<<"NIE"<<endl;
                return 0;
            }
        }
    }
    cout<<"TAK"<<endl;
    return 0;
}
```

---

## 作者：Red0rangE (赞：2)

### 题意理解

给出 $n$ 个字符串，每个字符串的第一个字符是一个在集合 $\{1,2,3,4,5\}$ 的数字，第二个字符是一个在集合 $\{\texttt A,\texttt B,\texttt C\}$ 的字母，配合样例就比较好理解了。需要使五场比赛（比赛编号为数字）都有不同的三道题目（题目编号为字母）。

### 思路阐述

因为输入内容有限制，不怕炸内存，直接使用映射。注意最后一场比赛要准备两套题。

### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;

int n;//题目数量
string s;//题目编号
map <string,int> q;//映射，因为最后一组要两道题，不用 bool 型，这样可以直接判断有几道题目
int bol;//用来判定结果的变量

signed main(){
    
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        cin>>s;//输入题目编号
        q[s]++;//这种题目数目+1
    }//输入
    if (q["1A"] && q["1B"] && q["1C"])//第一场比赛的题目都有了
        bol++;//完成一场比赛的出题
    if (q["2A"] && q["2B"] && q["2C"])//第二场比赛的题目都有了
        bol++;//又完成一场比赛的出题
    if (q["3A"] && q["3B"] && q["3C"])//第三场比赛的题目都有了
        bol++;//双完成一场比赛的出题
    if (q["4A"] && q["4B"] && q["4C"])//第四场比赛的题目都有了
        bol++;//叒完成一场比赛的出题
    if (q["5A"]>=2 && q["5B"]>=2 && q["5C"]>=2)//第五场比赛的题目都各有两道了
        bol++;//叕完成一场比赛的出题
    if (bol==5) printf("TAK");//完成五场比赛出题
    else printf("NIE");//没完成
    return 0;
    
}
```

希望各位大佬多多指教。

---

## 作者：Mx_sky (赞：1)

## 题意阐述
有三个组别 A、B、C，分别需要完成 $5$ 组任务，**其中第 $5$ 组任务每个组别需要完成 $2$ 题，其余任务均只需要完成 $1$ 题**，给出每道题合理且仅此合理的位置，请问是否可以安排好比赛题目？（即每个位置均能满足以上标黑条件）
## 思路阐述
其实每道题都能够放在比赛中，但是由于数量限制，所以不能安排多余的题目比赛。但仅对于此题而言，尽管多出也不会有事，因为题目并没有让我们进行删除题目的操作，而是让我们判断是否可以合理安排题目的位置，则我们只需要将每个位置都进行记录（即将此题的合理位置 $+1$，表示有一题可放置在此位置）。由于有三个组别，且需要完成 $5$ 组任务，所以需要用一个空间为 $3\times5$ 的**二维**数组进行记录。
##### 小技巧：
我们发现，数组中的串 $S$ 中第二个字符是 char 类型的，第一个字符才是数字，所以用二维 map 最方便。但是，我不会二维 map！所以，我（也适用于同我一样不会二维 map 的人）可以将第二个字符转化为数字即可（$A→1,B→2,C→3$ ），这样，建立一个 int 类型的 map 就 OK 了！
## 代码展示
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long  
int n,a[7][5];
string s;
int main(){
    std::ios::sync_with_stdio(false);//关闭同步流，无用的优化，可省略 
    cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		int x=s[0]-'0';           //截取第一个字符 
		int y=s[1]-'A'+1;         //截取第二个字符，并转化为数字 
		a[x][y]++;               //将此题的位置+1，意义见思路 
	}
	bool pd=true;               //判断是否符合条件 
	for(int i=1;i<=5;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(i!=5){if(a[i][j]==0){pd=false;break;}}     
			//若组别不是5，但是没有题目适合此位置，则不需要判断了，因为此位置没有适合的题就已经不满足条件了 
			else {if(a[i][j]<2){pd=false;break;}}
		    //若组别是5，但是不足两道题，不符合条件，也不需要判断 
		}
		if(!pd)break; //已经不满足条件了，退出循环 
	}
	if(pd)cout<<"TAK";     //满足所有条件 
	else cout<<"NIE";      //不满足条件 
    return 0;
}
```
望通过。

---

## 作者：zhuweiqi (赞：1)

思路：模拟，我们用 $a_{i,0}$ 来表示第 $i$ 轮比赛 $A$ 组别的题目数量，用 $a_{i,1}$ 来表示第 $i$ 轮比赛 $B$ 组别的题目数量，用 $a_{i,2}$ 来表示第 $i$ 轮比赛 $C$ 组别的题目数量，每一个字符串先看它前面的数字和后面的字母再对 $a$ 数组进行相应的操作，最后判断如果当 $i\leq 4$ 时 $a_{i,j}$ 都大于 $0$ 并且当 $i=5$ 时 $a_{i,j}$ 都大于 $1$ 时（$0\leq j\leq 2$）输出 ```TAK```，否则输出 ```NIE``` 即可。上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[6][3];
char c[2];
int main(){
	int n;
	scanf("%d",&n);
	while(n--){
		scanf("%s",c);
		a[c[0]-'0'][c[1]-'A']++;
	}
	for(int i=1;i<=4;i++){
		for(int j=0;j<3;j++){
			if(a[i][j]==0){
				printf("%s","NIE");
				return 0;
			}
		}
	}
	for(int j=0;j<3;j++){
		if(a[5][j]<2){
			printf("%s","NIE");
			return 0;
		}
	}
	printf("%s","TAK");
	return 0;
}
```

---

## 作者：zzy0618 (赞：0)

### 题目大意

给定 $n$ 个字符串，求是否满足一下所有要求：

- 其中字符串 5A，5B，5C 的个数必须大于等于 $2$。

- 剩余 1A 至 4C 的个数必须大于等于 $1$。

### 解题思路

想到字符串的个数统计，我们肯定会想到 map 的映射。用其进行统计，最终一个一个判断。

虽说一个一个判断，但为了一点技术含量，最好还是写一个循环语句。我们可以用上字符串的比较循环。

```cpp
for (string i = "1"; i <= "5"; i[0]++)//用字符串的比较 
		for (string j = "A"; j <= "C"; j[0]++) {
			a = i + j;
			if (i == "5")//如果是 5 开头的 
				if (mp[a] < 2) {//mp 用来统计 
					cout << "NIE" << endl;
					return 0;//如果不对直接输出且退出 
				}//分类判断 
				else
					if (mp[a] == 0) {
						cout << "NIE" << endl;
						return 0;
					}
		}
	cout << "TAK" << endl;
```

### 完整代码

其他输入输出不再叙述。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a;
map<string, int> mp;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a;
		mp[a] += 1;
	}//解决输入与统计 
	for (string i = "1"; i <= "5"; i[0]++)//用字符串的比较 
		for (string j = "A"; j <= "C"; j[0]++) {
			a = i + j;
			if (i == "5")//如果是 5 开头的 
				if (mp[a] < 2) {//mp 用来统计 
					cout << "NIE" << endl;
					return 0;//如果不对直接输出且退出 
				}//分类判断 
				else
					if (mp[a] == 0) {//同上 
						cout << "NIE" << endl;
						return 0;
					}
		}
	cout << "TAK" << endl;//所有要求都满足 
	return 0;
}
```



---


# 糖果

## 题目描述

三年级七班共有 $n$ 名同学。体育课开始，他们从左到右站成了一排，准备进行报数分组。

体育老师口袋里有很多袋装的糖果（一个袋子里有很多糖果），他准备在分组的过程中顺便将这些袋装糖果分给同学们。

具体地，在从左到右报数的过程中，每报数 $k$ 名同学，体育老师就会将这 $k$ 名同学划为一组，同时给予这 $k$ 名同学中的最后一名一袋糖果，让这最后一名同学来负责分发给组内的同学。也就是说，体育老师会依次给从左到右第 $k,2k,\cdots$ 名同学一袋糖果。

恰巧，三年级六班的同学听到了三年级七班发糖果的消息，于是他们打算混入队伍的末尾（即队伍最右侧），企图白嫖到一袋糖果。

三年级六班的同学想知道，他们**至少**需要向队伍末尾混入多少人。

## 说明/提示

### 样例 1 解释

此时每 $3$ 人分一组。三年级六班只需要向队伍中混入 $2$ 名同学，就可以和原来三年级七班的最后 $1$ 名同学一同凑成一组。

由于混入的这 $2$ 名同学在队伍的末尾，因此这一组中的最后一名同学一定是隔壁班的同学，因此隔壁班的同学可以白嫖到一袋糖果。

### 样例 2 解释

此时每 $4$ 人分一组。三年级七班的所有同学都已经分好了组，因此三年级六班需要完整地向队伍中混入 $4$ 名同学凑成一组，才能白嫖到一袋糖果。

### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n \leq 10 ^ {9}$，$2 \leq k \leq 10 ^ 9$。

| 测试点编号 | $n$ | $k$ |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $\leq 10$ | $= 2$ |
| $3 \sim 5$ | $\leq 10$ | $\leq 10$ |
| $6 \sim 10$ | $\leq 1000$ | $\leq 1000$ |
| $11 \sim 14$ | $\leq 10 ^ 9$ | $= 2$ |
| $15 \sim 20$ | $\leq 10 ^ 9$ | $\leq 10 ^ 9$ |

## 样例 #1

### 输入

```
10 3```

### 输出

```
2```

## 样例 #2

### 输入

```
16 4```

### 输出

```
4```

# 题解

## 作者：what_can_I_do (赞：10)

[传送门](https://www.luogu.com.cn/problem/P9226)

题目的意思是你要把 $n+x$ 个物品分成若干组，每组**刚好要有** $k$ 个物品，其中 $x$ 大于 $0$，求 $x$ 最小可以是多少。

我们先来看看样例吧。

样例 $1$ 中它告诉我们 $n=10$，$k=3$，让我们求 $x$。我们可以借助画图来理解，就像这样：
```
1   2    3    4
000 000  000  0
```
一个 `0` 表示一个物品，$1$ 至 $4$ 表示每组的编号。我们要让每组都刚好有 $k$ 个物品，前三组都满足条件，只有第 $4$ 组只有一个物品。我们要把第 $4$ 组凑成有 $k$ 个物品，也就是有 $3$ 个物品，我们就得再往第 $4$ 组放入两个物品，所以 $x$ 为 $2$。

其实我们不难发现，前三组的物品数总和能被 $k$ 整除，也就是说第四组的物品数就等于 $n\bmod k$。我们要从 $n\bmod k$ 变为 $k$，就要用 $k$ 减掉 $n\bmod k$ 算出需要加入多少个物品，也就是 $x$。

再看样例 $2$：
```
1    2    3    4    5
0000 0000 0000 0000 0000
```
我们可以发现按照样例给出的数据前四组都刚好能有 $k$ 个物品，那么答案应该等于 $0$ 才对啊，所以刚才的结论不成立。其实不对，因为还有一个要求 $x$ 大于 $0$ 没被注意到。那么也就是说前 $4$ 组虽然都正好是 $k$ 个物品，但我们还得再自加一组，为第 $5$ 组，第 $5$ 组刚开始为 $0$ 个物品，所以我们得放入 $k$ 个物品才能使其的物品数刚好等于 $k$，也就是 $x=4$。这也证明了结论的正确性。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main()
{
    scanf("%d%d",&n,&k);
    printf("%d",k-n%k);
    return 0;
}
```

---

## 作者：TernaryTree (赞：5)

题目转换：本题要求一个最小的正整数 $z$ 满足 $n+z$ 是 $k$ 的倍数。

## Part $0$ 如果你看不懂数学符号：

容易得到，如果 $n+z$ 是 $k$ 的倍数，那么 $n+z$ 对 $k$ 取模为 $0$。

同时减去 $z$，得到 $n$ 对 $k$ 取模为 $-z$。同时取相反数，得到 $z$ 等于 $n$ 对 $k$ 取模的相反数。但是这个是一个负数，该怎么办呢？

我们知道，$k$ 对 $k$ 取模是 $0$。所以我们可以利用这个性质，将 $n$ 对 $k$ 取模的相反数加上 $k$，这样就一定是正整数了，因为 $0\le n\bmod k\lt k $（$\bmod$ 表示一个数对另一个数取模，也就是整数除法里面省略号后面的余数），所以有 $-k\lt -n\bmod k\le 0$，加上 $k$ 得到 $0\lt k-n\bmod k\le k$。这就是正整数了。

补充：当前七班的小盆友们前 `n / k` 组都分到糖果了，还有最后一组 `n % k` 个人的因为人凑不齐而分不到糖果，所以我们再补 `k - n % k` 个人进去就好了。

所以输出 `k - n % k` 即可。

## Part $1$ 如果你看得懂数学符号：

若 $k\mid (n+z)$，有 $n+z\equiv 0\pmod k$。

$$
\begin{aligned}
n+z&\equiv 0\pmod k\\
n+z&\equiv k\pmod k\\
z&\equiv k-n\pmod k\\
\end{aligned}
$$

则有 $z=k-n\bmod k$ 时 $z$ 最小。

## Part $2$ 如果你擅长瞎猜：

拿到这题，看一眼题目，发现“组”“混入”等词。一看样例，输出的数都 $\le k$ 且是正整数，合理怀疑 $z=k-[\text{sth.}]\bmod k$。发现 $n$ 还没用，于是 $z=k-n\bmod k$，代入样例验证一下，是对的，直接写代码。

代码不放了。

---

## 作者：Hughpig (赞：4)

因为每 $k$ 个同学分为一组，所以最后还会多出 $n\bmod k$ 人。

而想要白嫖到糖果，就要让最后多出来的人数加上混进来的人数等于 $k$。所以答案就是 $k-n\bmod k$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k;

int main()
{
	cin>>n>>k;
	cout<<k-n%k;
}
```

---

## 作者：NightStriker (赞：3)

简化题意：

> 有 $n$ 个人，第 $k,2k,\cdot\cdot\cdot$ 个人可以领到糖果，现在有若个人想要领到一包糖果，问最少需要多人。

使用样例 $1$ 来举例，共有 $10$ 个人，第 $3,6,\cdot\cdot\cdot,3w$ 个人可以领到糖果。

```
0 0 1 0 0 1 0 0 1 0
```

（$0$ 表示领到糖果，$1$ 表示没有领到糖果）

很显然，后面还需要加上两个人才能领到糖果（凑成整组数）。

```
0 0 1 0 0 1 0 0 1 0 *0 *1
```
添加后人数为 $w\times k$（$w$ 为整数，因为必须凑成整组数并且还要最少人数）。

要注意有一种特殊情况，即样例 $2$。在这种情况下，原先的人数已经可以凑成整组数，所以只需要加上 $k$ 个人即可。

对于所有数据，因为前面的不需要考虑，所以我们只需要考虑 $n\ \text{mod}\ k$ 个人的时候，还需要添加 $k-n\  \text{mod}\ k$ 个人即可领到糖果。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,k; 
signed main() {
	cin>>n>>k;
	cout<<k-n%k<<endl;
    return 0;
}
```

---

## 作者：Double_Light (赞：2)

友情提示：白嫖糖果可不是个好习惯。

首先我们要知道，由于只有第 $k,2k,3k,...$ 个人能拿到一袋糖果，所以三年级六班想要白嫖到糖果，就必须让他们的一个人站在第 $i\cdot k$（$i$ 为整数）的位置上。这样问题就抽象成了最少在 $n$ 后面加哪个大于 $0$ 的数能使结果变成 $k$ 的倍数。

我们容易发现，$n \bmod k$ 为最后单独剩下三年级七班的多少名不够组成一组的人。三年级六班只要与这些人组成一组，就可以拿到糖果了。混进同学的数量明显为 $k-n \bmod k$。

---

## 作者：_dAAAAAAN_ (赞：1)

### 思路

本题的核心就是 $n \bmod k$ 这个数，因为不管前面分成了多少组，那些组里面都没有三年级六班的同学，所以要求出还有多少人没被分进组里，即 $n \bmod k$，然后再用 $k$ 减去这个数，就能算出要再插几位三年级六班同学才能组成一个组。

值得注意的是，当 $n \bmod k$ 为 $0$ 的时候，说明这些同学全部分好组，那么如果要在一个组里有三年级六班的同学，那么三年级六班就要再插入 $k$ 个人才能组成一个新的组。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main() {
    cin>>n>>k;
    if(n%k!=0) cout<<k-(n%k);//还有同学没被分进一个组的情况
    else cout<<k;//全部同学已经分好组的情况
    return 0;
}
```

---

## 作者：happy_zero (赞：1)

我们把 $k$ 个人看作一个整体（拿一袋糖），由于 $n$ 中前 $k$ 的倍数都已经拿糖了，所以不用考虑他们，而剩下的是 $n \bmod k$，这时要想再拿一袋糖，就要排除一些人和剩下的这 $n \bmod k$ 人凑成一个整体，也就是凑成 $k$ 人，所以至少要混入 $k-(n\bmod k)$ 人：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, k;
    cin >> n >> k;
    cout << k - n % k << endl;
    return 0;
}
```


---

## 作者：__Allen_123__ (赞：0)

### 题意简述

给定两个整数 $n, k$，令 $x(x>n)$ 为最小的能被 $k$ 整除的数，求出至少需要将 $n$ 加上多少，才能使 $n\ge x$。

### 题目分析

在上面的条件下容易得到，$x-k$ 为上一个发糖果的地点，那么我们只要算出原队伍在第 $x-k$ 个人以后还有多少个人，用这个结果被 $k$ 减，就可以得出最终答案。

原队伍在第 $x-k$ 个人以后还有多少个人好算，因为 $k\mid x-k$，所以剩余人数就等于 $n\bmod k$（因为前面的人都被取余舍去了，直到第 $x-k$ 个人为止），最终答案就是 $k-n \bmod k$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	cout << m - n % m; // 输出答案
	return 0;
}
```

---

## 作者：maomao233 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9226)

既然一共有 $n$ 名同学，$k$ 名同学分为一组，我们按两种情况考虑：

- 若 $n$ 不为 $k$ 的倍数，则队伍按 $k$ 名同学分后还有多余的同学。对于多余的同学，也就是 $(n\bmod k)$。所以三年级六班的同学想凑齐整个队伍，需要 $k-(n\bmod k)$ 名同学。故答案为 $k-(n\bmod k)$。

- 若 $n$ 为 $k$ 的倍数，则队伍按 $k$ 名同学分正好分完，没有多余的同学。所以三年级六班的同学需要 $k$ 名同学才能组成一个完整的队伍，故答案为 $k$。且因为 $n\equiv0\pmod k$，所以答案也可以写成 $k-(n\bmod k)$。

所以公式为 $k-(n\bmod k)$，按题意模拟即可。得代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,k;
    cin>>n>>k;
    cout<<k-n%k<<endl;
	return 0;
}
```

---


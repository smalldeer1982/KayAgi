# 金盏花

## 题目描述

有一个十二位十进制数 $X$，你只知道它的后六位构成的数是 $Y$。

另外再给出一个整数 $Z$，你需要求出所有可能的 $X$ 中，$X$ 与 $Z$ 的差，即 $\lvert X - Z \rvert$ 的最小值。

注意，$X,Y,Z$ 都没有前导零（即最高位不是 $0$），$X,Y$ 分别要有恰好十二位和六位。

## 说明/提示

**【样例 #1 解释】**

令 $X=123455987654$，可以取到 $\lvert X - Z \rvert$ 的最小值 $135802$。

---

**【样例 #2 解释】**

令 $X=100000428571$，可以取到 $\lvert X - Z \rvert$ 的最小值 $99999714286$。

---

**【数据范围】**

对于全部数据：$100000\leq Y\leq 999999$，$0\leq Z\leq 10^{12}$。

|     子任务编号     |  $Z\leq$  |  特殊限制  | 分值 |
| :----------------: | :-------: | :--------: | :--: |
| $\text{Subtask 1}$ |    $0$    | $Y=142857$ | $25$ |
| $\text{Subtask 2}$ |    $0$    |     无     | $25$ |
| $\text{Subtask 3}$ | $999999$  |     无     | $25$ |
| $\text{Subtask 4}$ | $10^{12}$ |     无     | $25$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/ibn2l6eb.png)

## 样例 #1

### 输入

```
987654 123456123456
```

### 输出

```
135802
```

## 样例 #2

### 输入

```
428571 714285
```

### 输出

```
99999714286
```

# 题解

## 作者：CCDYJXZ (赞：18)

[题目传送门](https://www.luogu.com.cn/problem/P9390)。

分析：

数据够小，可以直接暴力查找。直接枚举 $X$ 的前六位数，再加上 $Y$ 减去了 $Z$ 后的绝对值，找到其中的最小值。但数据范围明显得开 ```long long```。

------------
代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
long long a,s,g=LONG_LONG_MAX;
long long min(long long a,long long s){//自定义函数。 
	return a>s?s:a;
}
int main(){
	cin>>a>>s;
	for(long long i=100000;i<=999999;i++)//枚举前六位数。 
		g=min(g,abs(i*1000000+a-s));//找寻最小值。 
	cout<<g;
	return 0;
}
```
蒟蒻的一篇题解，如有不满敬请见谅。

---

## 作者：Lemon_zqp (赞：17)

### 思路
这道题的思路就是暴力模拟，如果 $y$ 的位数大于 $z$ 那么把 $y$ 补足 $12$ 位输出即可，否则算出 $z$ 比 $y$ 多出的那几位数，然后把这个数减一、者加一、不变得出三个数，放到 $y$ 的前面，减去 $z$，然后取最小值例如 $z$ 为 $123456123456$，$y$ 为 $987654$，那么 $z$ 比 $y$ 多的部分就是 $123456$，分三种情况让这个数插到 $y$ 前面，减一或者加一或着不变，那么就产生三个数 $123455987654$，$123457987654$，$123456987654$，接着把他们都补足 $12$ 位，然后依次减去 $z$ 取最小值即可，记得取绝对值，最后答案为 $135802$，转换成代码也是非常简单。
### 代码
```
#include<bits/stdc++.h>
using namespace std;

int wei(long long a)//取a的位数
{
	int cnt = 0;
	while(a > 0)
	{
		cnt++;
		a /= 10;
	}
	return cnt;
} 
long long qq(long long a, int t)//在a中取前t位
{
	int as = wei(a) - t;
	for(int i = 1; i <= as; i++)
	{
		a = a / 10;
	}
	return a;
}
long long qh(long long a, int t)//在a中取后t位
{
	int mo = 1;
	for(int i = 1; i <= t; i++)
	{
		mo *= 10;
	}
	return a % mo;
}
long long zero_num(int t)//范围10的t次方
{
	int mo = 1;
	for(int i = 1; i <= t; i++)
	{
		mo *= 10;
	}
	return mo;
}
int main()
{
	long long y, z;
	cin >> y >> z;
	y = abs(y);
	z = abs(z);
	int wy = wei(y), wz = wei(z), wc = wz - wy;
	if(wy > wz)
	{
		cout << (100000000000 + y) - z;
		return 0;
	}
	long long s = qq(z, wc), x1, x2, x3;
	x1 = abs((s * zero_num(wy)) + y);
	x2 = abs(((s - 1) * zero_num(wy)) + y);
	x3 = abs(((s + 1) * zero_num(wy)) + y);
	
	if(wei(x1) < 12)
	{
		x1 = abs((100000000000 + y) - z);//补足12位
	}
	else
	{
		x1 = abs(x1 - z);
	}
	if(wei(x2) < 12)
	{
		x2 = abs((100000000000 + y) - z);//补足12位
	}
	else
	{
		x2 = abs(x2 - z);
	}
	if(wei(x3) < 12)
	{
		x3 = abs((100000000000 + y) - z);//补足12位
	}
	else
	{
		x3 = abs(x3 - z);
	}
    if(x1 > x2)
	{
		swap(x1, x2);
	}
    if(x2 > x3)
	{
		swap(x2, x3);
	}
    if(x1 > x2)
	{
		swap(x1, x2);
	}
	cout << x1;
	return 0;
}
```


---

## 作者：include13_fAKe (赞：9)

## 前言
谨以此篇题解纪念蒟蒻洛谷大月赛 Div.2 首次达到 $200$ 分。
## 思路
### Subtask 1,2,3:
因为 $X$ 是十二位数，$Z$ 又很小，所以，只需要输出 $Y+10^{11}-Z$ 就可以了。

这种做法对于 $Z < 10^{12}$ 的数据都有用。
### 正解
首先，设我们的 $X_0=\lfloor \frac{Z}{10^6} \rfloor+Y$。

此时，$X_0$ 可能大于 $Z$,也有可能小于 $Z$。但它们的差距一定小于 $10^6$。

如果 $X_0 > Z$，则设 $X_1=X_0-10^6$。否则设 $X_1=X_0+10^6$。

接下来输出 $\lvert X_0-Z\rvert$ 和 $\lvert X_1-Z\rvert$ 的较小值即可。

---

## 作者：ARIS1_0 (赞：7)

## 题意

有两个无前导零的十进制数 $X$ 和 $Z$，$X$ 有十二位，你只知道 $X$ 的后六位是 $Y$ 以及 $Z$。求所有可能的 $X$ 中 $\mid X-Z \mid$ 的最小值。

数据范围：$100000\le Y \le 999999$，$0\le Z \le 10^{12}$。

## 思路分析

题目中数据均不超过 $10^{12}$，可以使用 `long long` 储存数据。随后需要逐个枚举可能的 $X$ 。如果从 $10^{11}$ 一直枚举到 $9.9 \times 10^{11}$ 的话肯定是不现实的。题目中已经给出了后六位 $Y$，那我们只需要枚举前六位之后再加上 $Y$ 就行了，这可以大大减少运算量。

其他的就放注释里面讲吧。

### AC代码

```cpp
#include<bits/stdc++.h>
#define ll long long//define一下long long可以使代码变得更加简洁
#define run int main()
#define end return 0//个人喜好，不喜勿喷
using namespace std;
ll x,y,z,ans=1e14;//使用ans储存最后得到的差，因为求最小，所以ans必须得大
run{
	scanf("%lld%lld",&y,&z);//scanf 读入快一些
	for(ll i=1e5,j=1e6;i<=1e6;i++){//枚举前六位
		ans=min(ans,abs(i*j+y-z));//更新ans，min函数取较小值，abs函数求绝对值
	}//不知道为什么，写i*1e6时会报错，所以这样写了
	printf("%lld",ans);//输出
	end;
}
```


---

## 作者：bigclever (赞：5)

## 思路：
因为 $\lvert X-Z \rvert$ 的最小值可能是**最小的大于等于 $Z$ 的 $X$ 与 $Z$ 的差**，也可能是**最大的小于等于 $Z$ 的 $X$ 与 $Z$ 的差**。所以我们考虑将 $X$ 先设为 $\overline{100000Y}$，如果此时 $X$ 已经大于 $Z$，那么直接输出 $X-Z$。否则把 $X$ 变为第一个大于等于 $Z$ 的十二位数，然后求 $\min(\lvert X-Z \rvert,\lvert X-1000000-Z \rvert)$ 即可。
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int y;
	long long z,x;
	cin>>y>>z,x=1e11+y;
	if(x>z){cout<<x-z;return 0;}
	for(int i=1;i<7;i++){//把X变为第一个大于等于Z的十二位数
		long long t=pow(10,i+5);
		if(z/t)
			if(i<6)x+=z/t%10*t;
			else x+=(z/t%10-1)*t;	
	} 
	cout<<min(abs(x-z),abs(x-1000000-z));
	return 0;
}
```

---

## 作者：lailai0916 (赞：5)

## 原题链接

- [洛谷 P9390 金盏花](https://www.luogu.com.cn/problem/P9390)

## 解题思路

分类讨论：

1. 如果 $Z$ 不是十二位数（$Z<10^{12}$），要使 $X$ 尽可能小，即 $\overline{100000Y}$：$\lvert X-Z\rvert=10^{12}+Y-Z$。

2. 否则，$X$ 和 $Z$ 位数相同，取三种情况的最小值即可：

- 前六位相同：$\lvert X-Z\rvert=\lvert Y-Z\bmod10^6\rvert$。
- 前五位相同，且第六位大 $1$：$\lvert X-Z\rvert=\lvert Y+10^6-Z \bmod 10^6\rvert$。
- 前五位相同，且第六位小 $1$：$\lvert X-Z\rvert=\lvert Y-10^6-Z \bmod 10^6\rvert$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	ll y,z;
	cin>>y>>z;
	if(z<100000000000)
	{
		cout<<100000000000+y-z<<'\n';
	}
	else
	{
		cout<<min(abs(y-z%1000000),min(abs(y+1000000-z%1000000),abs(y-1000000-z%1000000)))<<'\n';
	}
	return 0;
}
```

---

## 作者：zzx0102 (赞：3)

假如说 $z<10^{11}$，那么前 $6$ 位取 $100000$，答案就是 $10^{11}-z+y$。

否则，前六位和 $z$ 都一样，或者比最后一位 $z$ 大 $1$，答案是 $\min(|y-z\bmod 10^6|,10^6-|y-z\bmod 10^6|)$。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const long long k = 1000000, m = k * 100000;
int main() {
	long long a, y, z; cin >> y >> z;
	a = min(k - abs(y - z % k), abs(y - z % k));
	if(z < m) a = m - z + y; cout << a;
	return 0;
}
```

---

## 作者：ccg12345 (赞：3)

本人在比赛时十分钟做出来的一道题。

## 思路

首先可以先判断 $z$ 的位数，如果小于 $12$ 就可以直接输出 $x$ 的最小值减 $z$，即 `y + 10000000000 - z`。

如果 $z$ 达到了 $12$ 位，则取出 $z$ 的后六位数，将其与 $y$ 作差，要考虑进位的情况，并将其比较大小，输出绝对值最小的，即 `min(abs(y - k), y + 1000000 - k, k + 1000000 - y)`，注意要定义能返回三个数最小值的函数。

附代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int minn(int a, int b, int c)
{
	return min(min(a, b), c);
}
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x*f;
}
signed main()
{
	int y, z;
	y = read(), z = read();
	int k = z % 1000000;
	if(z <= 1e11)
		printf("%lld", y + 100000000000L - z);
	else
		printf("%lld", minn(abs(y - k), y + 1000000 - k, k + 1000000 - y)); 
	return 0;
} 
```


---

## 作者：liupan2010 (赞：3)

前言：

[题目传送门](https://www.luogu.com.cn/problem/P9390?contestId=106124)

赛时只会做这一题。

思路：

因为已经给出了 $Y$，所以可以考虑枚举前 $6$ 位，然后再组合成 $X$，最后通过比较求出结果即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y,z,mn=LONG_LONG_MAX;
int main(){
	cin>>y>>z;
	for(long long i=100000;i<=999999;i++){
		x=i*1000000+y;
		mn=min(abs(x-z),mn);
	}
	cout<<mn;
	return 0;
}
```

---

## 作者：Suite_No1_G (赞：2)

分析：

提供一种很暴力的做法。

由于 $X$ 有 $12$ 位，已知后 $6$ 位，则可以通过暴力枚举前 $6$ 位而确定 $X$ 的值。

这一步的复杂度为 $O(10^6)$。

然后计算答案即可。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int y,z;
int ans=1e18;

void dfs(int dep,int num){
	if (dep==7){
		int tmp=num*(int)1e6+y;
		ans=min(ans,abs(tmp-z));
		return;
	}
	
	if (dep==1){//第一位不为0
		for (int i=1;i<=9;i++) dfs(dep+1,num*10+i);
	}else for (int i=0;i<=9;i++) dfs(dep+1,num*10+i);
}

signed main(){
	scanf("%lld%lld",&y,&z);
	
	dfs(1,0);
	printf("%lld\n",ans);
	return 0;
} 
```


---

## 作者：船酱魔王 (赞：2)

# P9390 金盏花 题解

## 题意回顾

有一个未知的十二位数 $ X $，后六位为 $ Y $。你需要找到所有的 $ X $ 中满足 $ |X - Z| $ 最小的数（$ Z $ 已知），并输出 $ |X-Z| $ 的值。注意 $ X,Y,Z $ 均没有前导零。

## 分析

设 $ X $ 的前六位为 $ W $。则由位值原理可发现只有 $ W= \lfloor \frac{Z}{10^6} \rfloor-1 $，$ W= \lfloor \frac{Z}{10^6} \rfloor $，$ W= \lfloor \frac{Z}{10^6} \rfloor+1 $ 时才有可能取到最优解（因为第一种情况下 $ X < Z $，此时 $ X $ 再小就一定不是最优解，第三种情况同理）。

只需要算出三种情况的最小值就行，注意特判边界情况，注意变量类型问题。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define int long long
using namespace std;
const int _6 = 1e6;
const int _11 = 1e11;
long long y, z;
long long abso(long long x) {
	return max(x, -x);
}
signed main() {
	cin >> y >> z;
	long long ans = min(abso(_11 + y - z), abso(_6 * 999999 + y - z));
	if(z >= _11 + _6) {
		ans = min(ans, abso((z / _6 - 1) * _6 + y - z));
	}
	if(z >= _11) {
		ans = min(ans, abso(z / _6 * _6 + y - z));
	}
	if(z < (long long)1e12 - _6 && z >= _11) {
		ans = min(ans, abso((z / _6 + 1) * _6 + y - z));
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：hycqwq (赞：2)

这是一道**数学题**。

## Solution

设 $Z$ 去掉后六位之后为 $Z_1$，后六位为 $Z_2$。特别地，$100001 \le Z_1 \le 999998$，如果超出范围则取边界值。

接下来分类讨论：

- 当 $Z_2 < Y$ 时，最接近 $Z$ 的 $X$ 只可能为 $Z_1 \times 10^6 + Y$ 或 $(Z_1 - 1) \times 10^6 + Y$；
- 当 $Z_2 > Y$ 时，最接近 $Z$ 的 $X$ 只可能为 $Z_1 \times 10^6 + Y$ 或 $(Z_1 + 1) \times 10^6 + Y$；
- 当 $Z_2 = Y$ 时，最接近 $Z$ 的 $X$ 只可能为 $Z_1 \times 10^6 + Y$。

我们发现，$X$ 只有 $Z_1 \times 10^6 + Y$ 或 $(Z_1 \pm 1) \times 10^6 + Y$ 三种情况。

那么这道题就简单了。

## Code

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <string>
#include <cstring>
#include <cctype>
#include <cmath>
#include <vector>
#include <stack>
#include <queue>
#include <deque>
#include <map>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
#define elif else if
#define il inline

template<typename T> T Min(T x, T y) {return x < y ? x : y;}
template<typename T> T Max(T x, T y) {return -Min(-x, -y);}
template<typename T> T Abs(T x) {return x < 0 ? -x : x;}

ll x, y, z;

int main()
{
    cin >> y >> z;
    x = Min(Max(100001ll, z / 1000000), 999998ll) * 1000000 + y;
    ll ans = Min(Abs(x - z), Min(Abs(x - 1000000 - z), Abs(x + 1000000 - z)));
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Chis725 (赞：2)

## 题目描述

告诉你一个十二位正整数 $x$ 的后六位是 $y$，求 $x$ 与 $z$ 的差的最小值。

## 思路

我们都知道 $x$ 的最小值为 $\overline{100000y}$，当 $z$ 小于这个值的时候，答案就是 $\overline{100000y}-z$，否则答案就是 $\left|z\bmod1000000-y\right|$ 和 $1000000-\left|z\bmod1000000-y\right|$ 中的最小值。

## 代码献上

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int y,z;
signed main(){
	cin>>y>>z;
	if(z<=pow(10,11)+y){
		int ans=pow(10,11)+y-z;
		printf("%lld",ans);\\特殊情况
	}else{
		int a=z%1000000;
		printf("%lld",min(abs(y-a),1000000-abs(y-a)));
	}
	return 0;
} 
```


---

## 作者：Asimplename (赞：2)

容易发现最优方案的 $X$ 为 $10^{12}+Y$，是可以满足题目要求的最小数。

特殊情况是如果 $Z$ 正好有 $12$ 位，那么也可以取 $Z$ 的前六位或前六位减一与 $Y$ 拼凑，和上面的情况取最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long y,z;
long long ans = 1e18;
int main (){
	cin >> y >> z;
	if(z / 100000000000 != 0){
		ans = min(ans, llabs((z / 1000000 * 1000000 + y) - z));
		ans = min(ans, llabs((z / 1000000 - 1) * 1000000 + y - z));
	}
	ans = min(ans, llabs(100000000000 + y - z));
	cout << ans;
	return 0;
}
```

---


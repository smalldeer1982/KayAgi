# [ROIR 2021] 日期 (Day 2)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T1  [Календарь на Альфе Центавра](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。

## 题目描述

在一颗外星球上，一年有 $m$ 个月，一个月有 $d$ 天，一周有 $w$ 天。

为了区分每一周的每一天，人类使用了星期几来说明，而这颗外星球上的居民使用小写英文字母 `a`$\sim$`z` 来表示每一周的每一天。

已知 $1$ 年 $1$ 月 $1$ 日对应星期 `a`，求 $k$ 年 $j$ 月 $i$ 日对应星期几。

## 说明/提示

【数据范围】：

对于所有子任务，都有 $1\le d,m\le 100$，$1\le w\le 26$，$1\le i\le d$，$1\le j\le m$，$1\le k\le 10^9$。

| 子任务编号 |      特殊限制      | 分值 |
| :--------: | :----------------: | :--: |
|    $1$     |      $d=m=1$       | $16$ |
|    $2$     | $m=1$，$k\le 10^7$ | $16$ |
|    $3$     |      $i=j=1$       | $17$ |
|    $4$     |       $k=1$        | $17$ |
|    $5$     |     $k\le 100$     | $17$ |
|    $6$     |     无特殊限制     | $17$ |

## 样例 #1

### 输入

```
30 12 7
18 1 2021```

### 输出

```
b```

# 题解

## 作者：tyr_04 (赞：7)

[传送门](https://www.luogu.com.cn/problem/P9765)

~~此题很简单，但坑不少。~~

本题要先求出日期总数，然后减 $1$（因为 $1$ 年 $1$ 月 $1$ 日时星期为 $a$ 所以后面的日期都要减 $1$），最后再把日期来取模。

注意不要用循环来算总日期，不然会超时。

接下来就是坑最多的地方，如何算总日期？

首先，我们来举个例子：

$1$ 年 $1$ 月 $1$ 日，从这个地方就可以发现，如果直接拿 $1$ 年来乘上一年的总日期，明显是不对的，拿 $1$ 月来乘上一月的总日期，也是不对的，因为 $1$ 年和 $1$ 月还没有过完，所以月数和年数要减 $1$。

把最后得到的年数和月数依次乘上年和月的天数，就可以得到答案了，别忘了输出的是单个字符。

# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long d,m,w,i,j,k;
	cin>>d>>m>>w>>i>>j>>k;
	long long day;
	day=d*m*(k-1)+(j-1)*d+i;
	day--;
	day%=w;
	cout<<char(day+'a');
	return 0;
}
```

---

## 作者：2021zjhs005 (赞：4)

难度差不多**入门**的一道**数学题**。

题目分析
------------
按照题意输入 $6$ 个数，注意：**顺序不要弄反了**！（不然可能会得到 $0$ 分）。

第一行的数按**天、月、星期**排列。

第二行的书按**日、月、年**排列。

统计 $k$ 年 $j$ 月 $i$ 日是星期几，只需要计算出**从 $1$ 年 $1$ 月 $1$ 日（包括它）到现在有几个天**，就可以计算出来。

首先从年下手，我们要统计**比他前面的年份有几天**，也就是**前 $k-1$ 年的天数。**（不能包括 $k$ 年，不然就是把它给算进去了，而实际上这年没有过）。


$$ans+=(k-1) \times m\times d$$

这个公式表示前 $k-1$ 年，总共有多少天数（每年的天数就是**每月天数乘每年月数**）。

同理，我们接着从**月**下手：

由于这个月还没有过，所以还是要 $j-1$ 月前统计天数。

$$ans+=(j-1) \times d$$

这个公式用来统计 $j-1$ 月前有多少天（**每月天数乘此年已过完月数**）。

做完这几步，我们就可以从日来下手：

注意：由于是**统计该天是星期几，所以不能减 $1$**，不然一定会得到 $0$ 分。

$$ans+=i$$

最后，因为是求星期几，所以我们必须**取余**。

AC 代码
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll d,m,w,i,j,k,ans;
int main(){
    cin>>d>>m>>w>>i>>j>>k;
//输入，切记：不要弄错顺序。
    ans=(k-1)%w*d%w*m%w+(j-1)%w*d%w+i%w;
//求星期几，我们要进行取余。在这每一步都取余更保险。
    ans%=w;
//不要忘记，这时候可能会大于一星期的天数。
    if(!ans) cout<<char(96+w);
    else cout<<char(96+ans);//输出小技巧，可以自己去调试。
    return 0;
}
```


---

## 作者：Clarinet (赞：2)

[博客食用观感更佳](https://www.luogu.com.cn/blog/Czel-X/ti-xie-5-post)
# 简要题意
一年有 $m$ 个月，一个月有 $d$ 天，一周有 $w$ 天，且 $1$ 年 $1$ 月 $1$ 日为星期 `a`，求第 $k$ 年 $j$ 月 $i$ 天是星期几。
# 分析
难度大约为红色的水题。根据现实生活经验，我们可以用年份减一乘以一年的天数加上月份减一乘以一月的天数加上日期减一求得距离第一天过去了多少天。

然后再模一下一周的天数，就可以得到是星期几了。千万不要忘记开 long long！

由于细节比较多，可以参考一下下面的 AC 代码。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long d,m,w,k,j,i,ans;
int main(){
	cin>>d>>m>>w>>i>>j>>k;
	ans=(k-1)*m*d+(j-1)*d+i-1;
	ans%=w;
	char x='a'+ans;
	cout<<x;
	return 0;
}
```
感谢阅读！

---

## 作者：cff_0102 (赞：1)

先计算 $k$ 年 $j$ 月 $i$ 日距离 $1$ 年 $1$ 月 $1$ 日过去了几天，然后再计算这一天是星期几，最后输出答案。

众所周知，要过到第 $k$ 年，从第 $1$ 年开始，需要经过 $(k-1)$ 年时间。月份、日期的计算同理，不难得到 $k$ 年 $j$ 月 $i$ 日距离 $1$ 年 $1$ 月 $1$ 日过去了 $(k-1)$ 年 $(j-1)$ 月 $(i-1)$ 天。接下来把年数乘上 $m$ 和 $d$ 得到天数，约数乘上 $d$ 得到天数，再将其相加，就是一共过去的天数了。这可以用 `(k - 1) * m * d + (j - 1) * d + (i - 1)` 表示。

得到总天数后，计算将其除以每星期天数后的余数，那么就能得到那一天是星期几了。众所周知，$1$ 年 $1$ 月 $1$ 日距离 $1$ 年 $1$ 月 $1$ 日过去了 $0$ 天，最后得到的余数是 $0$，而实际上当天是星期 `a`，所以直接将余数加上 `'a'` 即可得到答案。

代码如下，记得开 `long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int d, m, w;
    long long i, j, k;
    cin >> d >> m >> w >> i >> j >> k;
    long long day = (k - 1) * m * d + (j - 1) * d + (i - 1);
    char ans = 'a' + day % w;
    cout << ans << endl;
}
```

---

## 作者：zwyyy (赞：1)

[原题传送门](https://www.luogu.com.cn/problem/P9765)

---

非常好数学题，这使我的脑袋爆炸。

---

## 思路
首先，这是~~蠢蠢~~纯纯一道数学题；其次，它的细节非常多，所以我们一步一步算。

1. 因为第 $k$ 年还没有过完，所以我们可以将第 $k$ 年前也就是前 $k-1$ 年的天数算出来；
2. 因为第 $k$ 年的第 $j$ 月也没有过完，所以我们可以将前 $j-1$ 月的天数算出来；
3. 加上第 $i$ 天；
4. 将结果对 $w$ 取余。

数学题放代码太容易被抄了，就不放代码了。

---

## 作者：Crasole (赞：1)

## 思路

可以得出式子为：$d \times m \times (k - 1) + d \times (j - 1) + (i - 1) \bmod w$。

最后再加上 `a` 即可，不要忘了开 `long long`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long d, m, w;
long long i, j, k;
int main() {
	cin >> d >> m >> w;
	cin >> i >> j >> k;
	cout << (char)((d * m * (k - 1) + d * (j - 1) + (i - 1)) % w + 97);
   //最后要强制转换成 char 类型
	return 0;
}
```

---

## 作者：maomao233 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9765)

考虑模拟，思路是求出第 $k$ 年之前的天数，加上第 $j$ 月之前的天数，再加上第 $i$ 天之前的天数。

于是可以写出柿子：$md(k-1)+d(j-1)+(i-1)$。  
这个柿子算出来之后就是 $k$ 年 $j$ 月 $i$ 日对应的总天数。题目要求的是计算星期几，所以我们将其用 $w$ 取模即可。  
注意星期是小写字母，所以再将其加上 ASCII 值 `'a'`。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
inline string its(int x){stringstream ss;string s;ss<<x;ss>>s;return s;}
inline int sti(string s){stringstream ss;int x;ss<<s;ss>>x;return x;}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
#define lb(x) x&-x
signed main()
{
	int d,m,w,i,j,k;
	rd(d,m,w,i,j,k);
	pc(((k-1)*m*d+(j-1)*d+i-1)%w+'a'),hh;
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

第 $1$ 年到第 $k$ 年，一共过了 $k-1$ 年，也就是 $(k-1)\times m$ 个月。从 $1$ 月到 $j$ 月过了 $j-1$ 个月。

所以从 $1$ 年 $1$ 月 $1$ 日到 $k$ 年 $j$ 月 $1$ 日，一共过了 $(k-1)\times m+(j-1)$ 个月，即 $((k-1)\times m+(j-1))\times d$ 天。

再加上从 $1$ 日到 $i$ 日过了 $i-1$ 天，则共过了 $t=((k-1)\times m+(j-1))\times d+(i-1)$ 天。那么过了 $\left\lfloor\dfrac{t}{w}\right\rfloor$ 个星期加上 $t\bmod w$ 天。则 $k$ 年 $j$ 月 $i$ 日是星期 $t\bmod w+1$。将它转为字母即可。

因为星期一对应的字母是 `a`（ASCII 码为 $97$），所以星期 $t\bmod w+1$ 对应的字母的 ASCII 码为 $t\bmod w+1+96=t\bmod w+97$。

因为 $k$ 最大为 $10^9$，所以要开 `long long`。

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	long long d,m,w,i,j,k;
	cin>>d>>m>>w>>i>>j>>k;
	long long t=((k-1)*m+(j-1))*d+(i-1);
	cout<<(char)(t%w+97);
	return 0;
}
```

---

## 作者：KohaD_SEGA (赞：0)

我们只需要求出 $k$ 年 $j$ 月 $i$ 日离 $1$ 年 $1$ 月 $1$ 日过去了多少天即可。

例如样例的 $2021$ 年 $1$ 月 $18$ 日，离 $1$ 年 $1$ 月 $1$ 日显然过去了

$$(2021-1)\times (12\times 30)+(1-1)\times 30+(18-1)$$

天。

然后再对这个数据模 $w$ 即可。

代码：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
long long d,m,w,i,j,k;
int main()
{
	cin>>d>>m>>w;
	cin>>i>>j>>k;
	long long y=d*m;//一年的天数
	long long sum=(k-1)*y+(j-1)*d+i;
	sum=sum%w;
	if(sum==0)	sum=w;	
	printf("%c\n",sum+'a'-1);
	return 0;
} 
```

---

## 作者：filletoto (赞：0)

## 思路
$d \times m \times (k-1)$ 表示 $k$ 年以前有几天。

$(j-1) \times d+i$ 表示第 $k$ 年的 $j$ 月 $i$ 日前有几天。

上述两个式子相加后减去 $1$ 就是 $1$ 年 $1$ 月 $1$ 日到现在有多少天，再模除一周的天数 $w$ 即为答案。


## [AC](https://www.luogu.com.cn/record/130664969)代码
```cpp
#include <iostream>
using namespace std;
void RP()
{
	long long CSP_RP=0;
	while(1) CSP_RP+=1e18;
}
typedef long long ll;
ll d,m,w,i,j,k;
int main()
{
	ios::sync_with_stdio(false);
	cin>>d>>m>>w;
	cin>>i>>j>>k;
	cout << char((((d*m*(k-1)+(j-1)*d+i)-1)%w)+'a');



	return 0;
}
```

CSP 2023 -J2 RP++!

---


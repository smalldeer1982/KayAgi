# [COCI 2017/2018 #6] Davor

## 题目描述

成功征服南极后，Davor 正在为新的挑战做准备。接下来是前往西伯利亚、格陵兰和挪威的北极探险。他将于 2018 年 12 月 31 日开始旅行，并需要在此之前筹集 $N$ 库纳（克罗地亚货币）。为此，他决定每周一存入 $X(X ≤ 100)$ 库纳到他的旅行基金中，每周二存入 $X + K$ 库纳，每周三存入 $X + 2\times K$ 库纳，依此类推，直到周日，他将存入 $X + 6\times K$ 库纳。这样，他将在 52 周内筹集资金，从 2018 年 1 月 1 日（星期一）开始，直到 2018 年 12 月 30 日（星期日）为止。

如果我们知道金额 $N$，输出值 $X$ 和 $K$，以便可以在给定的时间范围内收集到**准确**的金额。解决方案总是存在的，如果有多个，输出 $X$ 最大且 $K$ 最小的那个。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
1456```

### 输出

```
1
1```

## 样例 #2

### 输入

```
6188```

### 输出

```
14
1```

## 样例 #3

### 输入

```
40404```

### 输出

```
99
4```

# 题解

## 作者：dingcx (赞：1060)

这道题不暴力也是可以过的呢

## 思路

毕竟是红题，所以怎么做都行。不过我在这里写一个 $O(1)$ 的做法，以解决更大的 $n$ 和 $x$ 的问题。

容易发现，那个 $52$ 周在一开始就可以除掉了，反正这 $52$ 周是完全一样的。

再来看每一周。把每天的数加起来，得到 $7x+21k$，化简得 $7(x+3k)$，于是 $7$ 也可以开始除掉。

所以，只要在开始把 $52\times 7=364$ 除掉，那么方程就变为：$x+3k=n$。

解这个不定方程时，也需要关注一些题目的条件。这道题的条件有：$1≤x≤100$，$x$ 和 $k$ 为正整数，且使得 $x$ 最大，$k$ 最小。

显然，如果没有第一个条件，$k=1$就是解，此时 $x=n-3$。

但是，当 $n>103$ 时，$x$ 取不到 $n-3$，就需要变小，而 $k$ 就要变大。$k$ 每变大 $1$，$x$ 就要 $-3$，直到 $x≤100$ 为止。

由此，可以分情况讨论。如果 $n$ 是 $3$ 的倍数，由 $x=n-3k$ 得 $x$ 为 $3$ 的倍数，最大为 $99$。同理，$n$ 模 $3$ 余 $1$ 则 $x$ 也模 $3$ 余 $1$，最大为 $x=100$，$n$ 模 $3$ 余 $2$ 则最大为 $x=98$。$k$ 也就是 $(n-x)/3$。

综上所述，先看是否 $n≤103$，如果是则直接输出，否则按照 $n$%$3$ 讨论即可。

## 代码

毕竟是红题，没什么细节，直接上代码——

（~~我知道你们只看这里~~）

```cpp
#include<cstdio>
using namespace std;
int read(){//没什么用的快读
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int main(){//主函数
	int n=read()/364;//读入，开始直接/364
	if(n<=103) printf("%d\n%d\n",n-3,1);//k可以取到1的情况
	else{//k不能取1
		if(n%3==0) printf("%d\n%d\n",99,(n-99)/3);//分类讨论，直接输出
		if(n%3==1) printf("%d\n%d\n",100,(n-100)/3);
		if(n%3==2) printf("%d\n%d\n",98,(n-98)/3);
	}
	return 0;//华丽结束
}
```
看我写了这么多推导过程，点个赞再走呗~

---

## 作者：Susan2007 (赞：481)

怎么说呢。。。这题还是挺简单的  
看大佬们已经有和我思路差不多的题解了  
~~所以这就当成是娱乐好啦~~  
话不多说，上代码~~~
```cpp
#include<iostream>//
using namespace std;//你的名字，是我不变的信仰
int main()//程序主体，是否像你一样纯洁
{
	int x,k=1,n;//你看这些世间繁华
	cin>>n;//都敌不过键盘轻轻敲击
	while(1)//无限的单曲循环
	{
		for(x=100;x>=1;x--)//是否还能想起最初的信仰
			if((7*x+21*k)*52==n)
			{//倘若这个世界不是你想象的模样
				cout<<x<<endl;//你是否愿意献出你的灵魂
				cout<<k;//成为马猴烧酒（大雾
				return 0;//浑浊的灵魂宝石，祭奠受伤的心灵
			}
		k++;//一点又一点改变，只为有一个美好的结局
	}
	return 0;//世界，终究不是你想象的模样
}
```
我的代码充满了中二气息啊  
谨以此篇题解，献给最好的魔法少女美树沙耶香  
蒟蒻的第一篇题解，求过

---

## 作者：Ares゜ (赞：100)

### ~~一道入门题~~
#### ~~这道题还是挺简单的~~，就是两个for循环来找x和k，如果52周刚好攒够就满足条件，因此可知
```
x+x+k+x+2k+x+3k+x+4k+x+5k+x+6k=7x+21k
即(7x+21k)*52==n
```
另外，由于它有一个条件说要找x最大，k最小的情况，所以找x的时候就要从1开始往大找，k则往小找，如下
```
for(int i=1;i<=100;i++)
/*循环，因为要找x最大
的情况所以从1开始往后找*/
for(int j=200;j>=1;j--)
/*要找k最小的情况，所以
从200开始往前面找*/
```
#### 你可能会疑惑：j不是没有给范围吗？
其实，你可以根据n和x的范围来判断k的范围，当n为最大值145600时，x和k都为100，可以看出k的最大值为100。
保险起见，我还是从200开始找的。

然后，再判断是否满足刚才所说的条件，如下
```
if(i*7+j*21==n/52)
```
满足条件，则将i和j的值给x和k，由于下一组数据会覆盖上一组，最后k就为最小值，x为最大。
最后，输出答案
### 完整代码如下
```
#include<iostream>//标准输入输出头
using namespace std;
int main()
{
	int n,x,k;//定义一下
	cin>>n;
	for(int i=1;i<=100;i++)
	/*循环，因为要找x最大
	的情况所以从1开始往后找*/
	{
		for(int j=200;j>=1;j--)
		/*要找k最小的情况，所以
		从200开始往前面找*/
		{
			if(i*7+j*21==n/52)
              //判断一下是否能正好攒够钱
			{
				x=i;//把i的值给x
				k=j;//把j的值给k
				/*由于后一组x和k的值会覆盖上一组，
				所以最后输出的一定是
                 x最大，k最小的情况*/
			}
		}
	}
	cout<<x<<endl;//输出
	cout<<k<<endl;
	return 0;//好习惯别忘了
}
```
### 本蒟蒻的第七篇题解，如有不足之处，请各位大佬指正





---

## 作者：mdzzzzzzzzzz (赞：43)

# 说实话

这道题真的很简单

纯暴力

只是注意一下数据范围，小心一点

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,k;
int main()
{
//	freopen("davor.in","r",stdin);
//	freopen("davor.out","w",stdout);
	scanf("%d",&n);
	while(n>0)
	{
		n=n-1092;
		k++;
		if(n%364==0)
		{
			if(n<=36400)
			{
				x=n/364;
				break;
			}
		}
	}
	printf("%d\n%d",x,k);
	return 0;
}
```

正常的普及第一道题？？？

---

## 作者：zhanghengrui (赞：40)

数学推导

每个星期共筹集$x+(x+k)+\cdots+(x+6k)=7x+21k$元

$52$个星期共筹集$364x+1092k$元

因此$364x+1092k=n$，即$x=\frac{n}{364}-3k$

（数据保证有解，因此我们不必判断$\frac{n}{364}$是否为整数）

又因为$x\le100$

所以$\frac{n}{364}-3k\le100$

化简得$k\ge\frac{n-36400}{1092}$

又因为$k$为整数且$k>0$

所以$k=\max\{\lceil\frac{n-36400}{1092}\rceil,1\}$

$k$求出来了，自然就可以用上面的$x=\frac{n}{364}-3k$来求$x$

---

求上取整的方法

$$\lceil\frac{x}{y}\rceil=\left\{\begin{aligned}x/y,y\mid x\\x/y+1,y\nmid x\end{aligned}\right.$$

（其中“$/$”为整除）

变成代码大概就是这样

```cpp
x%y?x/y+1:x/y
```

---

完整代码

```cpp
#include <cstdio>
#include <algorithm>
int main()
{
	long N;//long和int一般是差不多的，你可以把它当做int
	scanf("%ld", &N);
	printf("%ld\n%ld\n", N / 364L - 3L * std::max(1L, (N - 36400L) % 1092L ? (N - 36400L) / 1092L + 1L : (N - 36400L) / 1092L), std::max(1L, (N - 36400L) % 1092L ? (N - 36400L) / 1092L + 1L : (N - 36400L) / 1092L));
	return 0;
}
```

---

## 作者：夙愿扬 (赞：24)

这道题的精髓在于解不定方程！

~~在此极力感谢360极速浏览器为我提供的翻译~~

因为有了固定的时间，所以我用计算器算了一下一年中x和k的数量。

于是得到364x+1092k=n;

为了求最大x，我在此用了一个循环。

代码（可能不是最优算法）：

```
#include<bits/stdc++.h>
using namespace std;
int main ()
{
    int n,x,k;
    scanf("%d",&n);
    for(int i=1;i<=100;i++)
    {
        if((n-364*i)<=0)
        break;
        if((n-364*i)%1092==0)
        x=i;
    }
    k=(n-364*x)/1092;
    printf("%d\n%d",x,k);
    return 0;
}
```
~~AC第一个灰题祭~~

---

## 作者：Goashore (赞：19)

# 题目描述：

在征服南极之后，Davor 开始了一项新的挑战。下一步是在西伯利亚、格林兰、挪威的北极圈远征。他将在 2018 年 12 月 31 日开始出发，在这之前需要一共筹集 n 元钱。他打算在每个星期一筹集 xx 元，星期二筹集 x+k 元，……，星期日筹集 x+6k 元，并在 52 个星期内筹集完。其中 x,k 为正整数，并且满足  1001≤x≤100。

现在请你帮忙计算 x,kx,k 为多少时，能刚好筹集 nn 元。

如果有多个答案，输出 xx 尽可能大，kk 尽可能小的。


输入格式
The first line of input contains the integer ​N​ (1456 ≤ ​N​ ≤ 145600), the number from the task.

输出格式
The first line of output must contain the value of ​X (​0 < ​X ​≤ 100 ​)​, and the second the value of K (K ​> 0 ​)​.

输入输出样例:

输入 

1456

输出 

1

1
输入

6188

输出

14

1
输入 

40404

输出 

99

4
## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int x,y;
int main()
{
	cin>>n;
	n/=52;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=100;j++)
		{
			if(j*7+i*21==n)
			{
				cout<<j<<endl<<i;
				return 0;
			}
		}
	}
}
```


---

## 作者：Sinwind (赞：9)

------------

# 分析

1. 每周一x元，周二x + k元，周三x + 2k元，...，周六x + 6k元，每周共7x + 21k元，52周就是52 × (7x + 21k)元。

------------

# 思路

1. 外层循环枚举k（k ∈ N+），因为k要尽可能小，所以k从1开始；

2. 内层循环枚举x（x ∈ [1,100]，且x ∈ N+）,因为x要尽可能的大，所以x从100开始；

3. 若筹得钱正好等于需要的钱（52 * (7 * x + 21 * k) == money），分两行输出x，k，返回值为0，程序结束。

------------

# 代码

```cpp
#include <iostream>

using namespace std;

int main(void)
{
	int money;  //需要的钱
	
	cin >> money;
	
	for(int k  = 1; ; k++)
	{
		for(int x = 100; x >= 1; x--)
		{
			if(52 * (7 * x + 21 * k) == money)
			{
				cout << x << endl << k << endl;
				return 0;
			}
		}
	}
}
```


---

## 作者：魁父 (赞：9)

## ~~誓做最短小代码！~~

我们的思路一般是双重循环：枚举x和k，寻找可能的方案，但其实只要一重循环就可以了。

我们判断x和k是否成立的语句是```((7*x+21*k)*52==n)```,而我们可以根据它求出k（或者x,这里是k）。

- n/52=7x+21k
- n/52-21k=7x

所以我们枚举k，于是判断语句是：```(n/52-21*k)%7==0```

然后又可以简化，因为21k一定能被7
整除，于是成了```n/52%7==0```

但在题目中第三个数据点：40404，结果输出
```
108
1
```
实际应是
```
99
4
```
我们又要加一个判断：```(n/52-21*k)/7<101```  
结果又可以简化：```n/52/7-3*k<101```  
又因为“/52”太多了，就直接将n/52。。。
```cpp
#include<bits/stdc++.h>//万能头
int n,k;//定义
int main(){
    scanf("%d", &n);n/=52;//输入并将n/52
    for(k=1;;k++) //k无上限
	if(n%7==0&&(n/7-3*k)<101){//简化后的判断
	    printf("%d\n%d\n",n/7-3*k,k);//输出
	    return 0;//要求的找到了，就退出程序吧
	}
    return 0;
}
```

---

## 作者：zhaowangji (赞：7)

其实还算简单，需要计算一下（放心电脑自带计算器）

Davor筹钱的数目按七天（一周）为一个周期

x,x+k,x+2k,x+3k,x+4k,x+5k,x+6k

可以得到一周筹集(7x+21k)元

那么52周就是52*(7x+21k)=(364x+1092k)元

每次先枚举1~100的x取值是否满足条件（因为k要尽量小啊）

如果全都不行，k++，再来一遍

注意初始化k=1，因为k是正整数
```cpp
#include<iostream>
using namespace std;
int n,k=1;//k>0!!!一开始没注意，会导致答案不一样（虽然对，但是k=0）
int main()
{
	cin>>n;//直接读
	while(1)//把退出条件放在里面
	{
		for(int i=1;i<=100;i++)//枚举1~100的x是否符合条件
		if(364*i+1092*k==n){cout<<i<<endl<<k;return 0;}
      		
          	//心算/笔算怕错用计算器算（电脑自带的）
		//可以得到x共有364（7*52）个
        	//k共有1092（（1+2+3+4+5+6）*52）个
        	//如果他们加起来刚好等于n就行了
            	//记得写return 0
            	k++;//这次不行就加一	
	}
	return 0;
}
```
~~竟然嫌我说明少~~

---

## 作者：djh123 (赞：3)

题目大意：

$Davor$想要获得$N~~kunas$去旅行，于是他把他的钱放到了旅行基金里。


每周一获得$x~~kunas$，每周二获得$x+k~~kunas$，每周三获得$x+2k~~kunas$……每周日获得$x+6k~~kunas$，共$52$个周。

$Davor$恰好获得了$N~~kunas$，现在想要求出合法的最大的$x$和最小的$k$。

$1456\le N\le 145600, 1\le x\le 100, 1\le k$

$solve$:

先对原式化简：$1092k+ 364x = N$

考虑到$x$的数据很小，所以可以枚举$x$。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <bitset>

using namespace std;

struct FastIO
{
    inline FastIO& operator >> (int& x) {
        x = 0; char f = 0, ch = getchar();
        while(ch > '9' || ch < '0') f |= (ch == '-'), ch = getchar();
        while(ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();
        return x = (f ? -x : x), *this;
    }
    inline FastIO& operator >> (long long& x) {
        x = 0; char f = 0, ch = getchar();
        while(ch > '9' || ch < '0') f |= (ch == '-'), ch = getchar();
        while(ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();
        return x = (f ? -x : x), *this;
    }
    inline FastIO& operator >> (double& x)
    {
        x = 0; char f = 0, ch = getchar();
        double d = 0.1;
        while(ch > '9' || ch < '0') f |= (ch == '-'), ch = getchar();
        while(ch <= '9' && ch >= '0') x=x * 10 + ch - 48, ch = getchar();
        if(ch == '.')
        {
            ch = getchar();
            while(ch <= '9' && ch >= '0') x += d * (ch ^ 48), d *= 0.1, ch = getchar();
        }
        return x = (f ? -x : x), *this;
    }
}rin;

int main() {
	int n;
	rin >> n;
	for(int i = 100 ; i >= 1 ; -- i) {//枚举x
		int x = 364 * i;
		int now = n - x;
		if(now < 0) continue;
		if((now % 1092 == 0) && (now != 0)) {//判断是否合法
			printf("%d\n%d\n", i, now / 1092);//输出解
			return 0;
		}
	}
}
```

---

## 作者：dblark (赞：2)

话说洛谷主题库又有新的红题了呢，所以我就水掉了……

~~红名就应该刷红题嘛，您看我就把洛谷主题库的红题给刷光了~~

这题可以化为一个不定方程 $ x + 3k = \frac{n}{364} $。

然后给大家提供一个新的思路：

**用数学方法解决此题！**

没错就是这么简单。解法是常数时间复杂度。

啦啦啦你是不是会做了（手动滑稽）

不会做就看代码吧：

```pas
var
  n, x:longint;
function min(x, y:longint):longint;
  begin
    if x < y then
      exit(x)
    else
      exit(y);
  end;
begin
  read(n);
  n := n div 364;                  //先把n除以364方便处理
  x := min(100, n - 1);            //这是x的最大值
  dec(x, 2 - (n - x - 1) mod 3);   //由于k为整数，也就是3|(n - k)，所以我们把余数减去（这里要仔细推一下）
  writeln(x);                      //输出x
  writeln((n - x) div 3);          //输出k
end.
```

---

## 作者：GTfct (赞：2)

#### 这道红题很符合我的水平。。。

这是一道二元一次方程！

由题意，我们可以知道一周能筹集到的钱 x+(x+k)+(x+2k)+……+(x+6k) 

即 7x+21k 那么52个星期可以有：~~（计算ing）~~364x+1092k

因为满足 1≤x≤100，所以不用担心会不会爆掉。

### Pascal 代码如下：

```pascal
var x,n,k:longint;
begin
  readln(n);
  for x:=100 downto 1 do  //枚举x的可能，因为要求输出最大的x,所以用了downto
  begin
    k:=n-364*x; 
    if k<=0 then continue;  
    if k mod 1092=0 then  //判断在x成立的情况下k会不会成立  
    begin
      writeln(x);
      writeln(k div 1092);
      exit;  //如果成立就可以直接跳出循环，因为此时的x是最大的
    end;
  end;
end.
```
~~蒟蒻的第一篇题解，管理员大佬求过QAQ~~

---

## 作者：shengyuch (赞：2)

      这是一道模拟题
  由题意可知，1≤x≤100。又由于题目要求当存在多解时，输出x最大，k最小的一个，故考虑将x从大到小枚举，将k从小到大枚举。并可以考虑设
week-money为每一周可获得的钱数，week为集齐n元所需的周数，则可以先判断week是否为整数且week是否≤52，均符合题意则直接输出即可。

**Code：**
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
inline void read(int &x){
    char c;x=0;bool f=false;
    c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=true;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    x=f?-x:x;
}
int main(){
    register int x,k;
    int n,week,weekmoney;
    read(n);
    for(x=100;x>=1;x--){
        week=0;weekmoney=0;
        for(k=1;k<=n;k++){
           weekmoney=7*x+21*k;//由题可直接计算出weekmoney的值
           week=n/weekmoney;
            if(week*weekmoney==n&&week==52){//同时判断整数性及范围
                printf("%d %d\n",x,k);return 0;
            }
        }
    }
    return 0;
}
```


---

## 作者：AK_黄铮_IMO (赞：0)


普通（can pass 型）：
```cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int ans=0;
    int c=0;
   for(int x=100;x>=1;--x){
       for(int k=1;k<=10000;k++){
           if(52*7*x+52*21*k==n){
               cout<<x<<endl<<k;
               return 0;
           }
           
       }
   }
    }
```
    例如，52个星期，一星期7天，x 会被计算 52 * 7 次，52 个星期，每星期有 1 + 2 + 3 + 4 + 5 = 21 个 k，所以 k 会被计算 52 * 21 次。

因此对于一个固定的 x 和 k，最后的钱数就是 52 * 7 * x + 52 * 21 * k 元。由于输出要使 x 尽量大，于是得从 x 由大到小枚举。
# 时间复杂度：o（n²）

法二（中犇型）：

```cpp

#include<iostream>
#include<cstdio>
using namespace std;
int main(){
    int n,k;
    cin>>n;
    for(int i=100;i>=1;--i){
        if((n/52-7*i)%21!=0){
            continue;
        }
        k=(n/52-7*i)/21;
        if(k<=0){
            continue;
        }
        cout<<i<<endl;
        cout<<k<<endl;
        break;
    }
    return 0;
}
两种解法都是暴力！！！


---


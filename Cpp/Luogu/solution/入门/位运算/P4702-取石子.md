# 取石子

## 题目描述

Alice 和 Bob 在玩游戏。

他们有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个，保证初始时 $a_i \leq a_{i + 1}(1 \leq i < n)$。现在他们轮流对这些石子进行操作，每次操作人可以选择满足 $a_i > a_{i - 1}$（$a_0$ 视为 $0$）的一堆石子，并从中取走一个。谁最后不能取了谁输。Alice 先手，他们都使用最优策略，请判断最后谁会取得胜利。

## 样例 #1

### 输入

```
1
1```

### 输出

```
Alice```

## 样例 #2

### 输入

```
1
2```

### 输出

```
Bob```

# 题解

## 作者：LCuter (赞：78)

没人解释我就来说明一下

首先明确，只要还有石子，那么一定能取

不妨设有两堆石子$a_{1}$，$a_{2}$，假设现在还有石子且无法取

那么有$a_{1}+a_{2} ≥ 0$,$a_{2}<a_{1}<0$

①两不等式矛盾：两个负数相加必定不是非负数

②石子数不可能为负数

所以只要还有石子，就一定能取

那么问题就转换为两人轮流从一堆石子取一粒，谁先不能取谁输

我们可以假设石子一共有$x$粒，甲取了$k$粒

若是甲赢，那么甲一定比乙多取了一颗，得$x=2k+1$，$x$为奇数

若是乙赢，那么甲一定和乙取的石子数一样，得$x=2k$，$x$为偶数

就推出了双方赢的充要条件

那么上代码

```cpp

// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int main(){
    int tmp,sum,n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&tmp);
        sum+=tmp;
    }
    if(!(sum&1)){//利用位运算优化
        printf("Bob");
    }
    else{
        printf("Alice");
    }
}

```

---

## 作者：Drinkkk (赞：29)

【题目描述】

Alice 和 Bob 在玩游戏。

他们有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$个，保证初始时 $a_i \leq a_{i + 1}(1 \leq i < n)$。现在他们轮流对这些石子进行操作，每次操作人可以选择满足 $a_i > a_{i - 1}$（ $a_0$ 视为 $0$ ）的一堆石子，并从中取走一个。谁最后不能取了谁输。Alice 先手，他们都使用最优策略，请判断最后谁会取得胜利。

【输入输出格式】

- 输入格式

第一行一个整数 $n(1 \leq n \leq 100)$ ，表示石子堆数。

接下来一行 $n$ 个数，第 $i$ 个数为 $a_i(1 \leq a_i \leq 10^9)$，意义如上所述。

- 输出格式

"Alice" 或 "Bob"，表示谁会赢。

【输入输出样例】

- 输入样例$1$
```
1
1
```

- 输出样例$1$
```
Alice
```

- 输入样例$2$
```
1
2
```

- 输出样例$2$
```
Bob
```

【题解】

因为要取$\sum_{i=1}^n a_i$次才能够取完，因此可以根据$\sum_{i=1}^n a_i$的奇偶来判断谁赢。

【代码】

下面上AC代码~
```
#include <cstdio>
long long a[1000001];
int main()
{
    long long ans=0,n=0;
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        ans+=a[i];
    }
    if(ans%2LL==0)
    {
        printf("Bob");
    }
    else
    {
        printf("Alice");
    }
    return 0;
}
```

---

## 作者：Lucifer_Bartholomew (赞：15)

```cpp
//一人去一个，Alice先手
//两人各取一次
//石子总数减二
//所以直接判断石子总数
//若 奇数—Alice先手赢
//若 偶数—Bob后手赢
#include <cstdio>
#include <iostream>
using namespace std;
int main()
{
	int n,i,a,sum=0;
	cin>>n;
	for(i=1;i<=n;++i)
	{
		cin>>a;
		sum+=(a%2);//若直接加有可能超int
	}
	if(sum%2)cout<<"Alice";
	else cout<<"Bob";
	return 0;
}
```

---

## 作者：PHarr (赞：15)

看了一下之前的大佬们写的题解，思路非常清晰，很容易推断出就是对所有的石子数求和在判断一下奇偶即可。但是看到各大佬们的代码，我想说其实不用开$long long$,因为决定一个数奇偶的只有个位，再准确点就是二进制下的第一位，所以每次求和后$Mod10$就可以了。

---
**coding：**
```cpp
#include<bits/stdc++.h>
using namespace std;


int n,x,sum;


int main()
{
    scanf("%d",&n);
    for(int i = 1;i <= n;i++)
    {
        scanf("%d",&x);
        sum += x;
        sum %= 10;
    }
    if(sum & 1) puts("Alice");
    else puts("Bob");
    return 0;
}

```
---
第一次发题解，码风丑，凑合看

---

## 作者：zhaowangji (赞：10)

这题目。。。做过[P3150 pb的游戏（1）](https://www.luogu.org/problemnew/show/P3150)吗？

如果你做过，没有想到有一题类似于这题，那P3150就白做了

因为肯定要全取完，所以就是累加所有石子和，然后判断奇偶。奇数则Alice赢，偶数则Bob赢（奇数的话先手会刚好全拿走，偶数的话后手会刚好全拿走）。

**不过有一大坑！**
得用long long！！！最大数达到10的11次方，int才2的21次方

（本人初二上学期学过的，记忆犹新，是幂的乘方那一块的知识：a的b次方的c次方=a的b* c次方，10的11次方大于2的3次方的11次方，即大于2的33次方）

两篇题解解释的很详细，肯定看得懂的（P3150的），[这篇](https://www.luogu.org/blog/ZJLOIJR/solution-p3150)和[这篇](https://www.luogu.org/blog/wjh2622075127/solution-p3150)。本蒟蒻当时也想写一篇来着，一看哇，写得太好了
```cpp
#include<iostream>
using namespace std;
int n,x;
long long sum;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>x;
    	sum+=x;
	}
	if(sum%2==1)cout<<"Alice";
	else cout<<"Bob";
    return 0;
}
```
不知道这算题解吗？

---

## 作者：裘小小 (赞：6)

#### 其实我第一次直接输出Alice有58分
###### 其实很简单的一道判断奇偶题，P党还没题解，就水一波
贴代码
```pascal
var 
  i,n,sum,x:longint;
begin
  read(n);
  for i:=1 to n do
    begin
      read(x);
      sum:=sum+x;
    end;
  if sum mod 2=0 then 
                   write('Bob')
                 else 
                   write('Alice');
end.

```

---

## 作者：陈独秀先生_ (赞：4)

话说这道题(作弊办法)很简单:计算石子总和,不考虑几堆,最后判断奇偶就OK.
```cpp
#include<bits/stdc++.h>//大佬可以无视万能库,iostream也Ok
using namespace std;//标准命名
int n,a[1000];//n:数量如题,a:每堆石子的数量
int ans;//石子总数量
main(){
	cin>>n;//输入
	for(int i=0;i<n;i++){
		cin>>a[i];
		ans+=a[i];//计算总和
	}
	if(ans%2==0){//作弊的判断奇偶
		cout<<"Bob";//因为是Bob后拿所以当数量为2的倍数是Bob赢
	}
	else{
		cout<<"Alice";
	}
	return 0;//结束
} 
```

---

## 作者：Red_Bands_whk (赞：3)

## 这题可以采用异或的思想。

~~之前做过类似的问题求解。~~
### 这样做能保证答案正确。
类似的题目都可以使用。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	int x=0;
	cin >> n;
	for (int i=1; i<=n; i++)
	{
		 int y;
		 cin >> y;//输入
		 x^=y;//异或
	}
	if (x%2==1) cout << "Alice";
	else cout << "Bob";//输出
}
```


---

## 作者：Dorbmon (赞：2)

显然如果所有石子加起来 为偶数 那么Bob胜利，否则Alice胜利。
这一题我是一次过的，所以我不知道数据会不会很变态。我就当做很变态来写（当然也没当作太变态）

根据数论的知识，我们知道
若
a % b = D1
c % b = D2
那么可以得出
a + c % b = (D1 + D2) % b
接下来就是程序
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ui unsigned long long

int main(){
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    int mod_ = 0;
    for(int i = 0;i < n;i ++) {
        ui temp;
        cin >> temp;
        mod_ += temp % 2;
        mod_ %= 2;
    }
    if(mod_ == 1) {
        cout << "Alice" << endl;
    }else {
        cout << "Bob" << endl;
    }
    return 0;
}
```


---

## 作者：HOIer_9_42 (赞：2)

蒟蒻的第一篇题解，大佬勿喷……

首先，大佬们都已经讲了，这道题其实就是判断和的奇偶性——即石子总数的奇偶性。
根据题意，我们知道，Alice是固定先手，而且两人每次只能取走一颗石子，那么问题就变得简单了。
若是Alice赢，那么Alice一定比Bob多取了一颗，就是两人都取走a颗石子，即总共取走了2a颗石子时，此时石子总数一定为奇数，反之。这里就不再赘述。

下面是我的思路——

既然是判断和的奇偶性，那么我们每输入一个元素，都可以决定和的奇偶性，那么，我们就边读入边判断，代码如下——
```cpp
for(register long long i=1;i<=n;i++){
		cin>>m;//读入每堆的石子数
		if(m&1){
			tot++;//统计有几堆石子是奇数个
		}
	}
```

那么，我们可以根据奇偶性求和求积的规律，判断总和的奇偶性

下面是AC代码（不要看码风^_^）

```cpp
#pragma GCC otimize(3)
#pragma once
#include<bits/stdc++.h>
#define q register
#define ll long long
using namespace std;
int m,n,tot=0;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//读入优化
	cin>>n;
	for(q ll i=1;i<=n;i++){
		cin>>m;
		if(m&1){
			tot++;
		}
	}
	if((n&1)&&(tot&1)){
		puts("Alice");   return 0;
        //奇数-奇数=奇数——> Alice赢
	}
	if(!(n&1)&&(tot&1)){
		puts("Alice");   return 0;
	    //偶数-奇数=奇数——>Alice赢
    }
    puts("Bob");//其它情况均为偶数，即为Bob赢
    return 0;
}
```

---

## 作者：TAFE_ZZR (赞：1)

# 只要判断奇偶就可以了
##### 若是甲赢，那么甲一定比乙多取了一颗，得x=2k+1x=2k+1x=2k+1，x为奇数
##### 若是乙赢，那么甲一定和乙取的石子数一样，得x=2kx=2kx=2k，x为偶数
##### 那么就推出了双方赢的充要条件
# 时间：O(n)
# 代码如下：

```
#include <cstdio>
long long a[1000001];
int main() {
    long long ans=0,n=0;
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) {
        scanf("%lld",&a[i]);
        ans+=a[i];
    }
    if(ans%2LL==0) printf("Bob");
    else printf("Alice");
    return 0;
}
```

---

## 作者：孑丿孓 (赞：0)

# 很简单的博弈论，其实没有那么麻烦。
题目描述：
Alice 和 Bob 在玩游戏。

并且他们每次都只能取一个石子，既然规定了他们的取子问题，那么问题就简单了。

仔细观察有多少石子，在观察石子为基数还是偶数，最后是谁能赢。就能得结论，接下来，带公式即可。


代码实现：

```
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
typedef long long ll;
ll a[1000] , sum;
int main(){
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i++){
        cin >> a[i];//输入每堆有多少个石子;
        sum += a[i];// 统计总共有多少石子;
    }
    if(sum % 2 != 0){
        cout << "Alice" << endl;
    }
    else cout << "Bob" << endl;
    return 0;
}

```




---


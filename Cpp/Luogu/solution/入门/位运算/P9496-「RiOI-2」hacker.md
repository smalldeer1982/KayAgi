# 「RiOI-2」hacker

## 题目背景

在小树丛边坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

现在，伟大的 E 国之王正在披挂出征。

不过听说 E 国之王遇见了两个叫 ACCEPT 和 BOTH 的人，他们是谁？

## 题目描述

现在有正整数 $n$，有以下操作；

- 「ACCEPT」。花费 $1$ 的代价，将 $n$ [二进制](https://oi-wiki.org/math/base/#%E4%BA%8C%E8%BF%9B%E5%88%B6)**按位或**上 一个正整数。
- 「BOTH」。花费 $1$ 的代价，将 $n$ [二进制](https://oi-wiki.org/math/base/#%E4%BA%8C%E8%BF%9B%E5%88%B6)**按位与**上 一个正整数。

两种操作均可使用多次（或不用），请求出将 $n$ 变为 $m$ 最小的代价。

[帮助：什么是按位与和按位或](https://oi-wiki.org/math/bit/#%E4%B8%8E%E6%88%96%E5%BC%82%E6%88%96)

## 说明/提示

### 样例解释

+ 对于 $n = 1$，$m = 1$，不需要任何操作。
+ 对于 $n = 4$，$m = 5$，一种可行的方案为使用「ACCEPT $1$」。
+ 对于 $n = 1$，$m = 4$，一种可行的方案为依次使用「ACCEPT $998{,}244{,}853$」和「BOTH $14$」。

### 数据规模与约定

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $T \leq$ | $n, m \leq$ |
| :--------------: | :--: | :------: | :---------: |
| $0$ | $30$ | $100$ | $100$ |
| $1$ | $70$ | $2\times 10^5$ | $10^{18}$ |

对于所有数据，$1\le T\le2\times 10^5$，$1\le n,m\le10^{18}$。

## 样例 #1

### 输入

```
3
1 1
4 5
1 4```

### 输出

```
0
1
2```

# 题解

## 作者：hfjqwq (赞：23)

感谢 @[lianchanghua](https://www.luogu.com.cn/user/564475) 帮忙修改 Markdown 和 $\LaTeX$。

### 题目大意：
给出两个数 $n$ 和 $m$，$n$ 可以通过**按位或**或者**按位与**操作变成 $m$，问**最少**多少次操作可以实现？

### 解题思路：
- $n$ 和 $m$ 的二进制当中，如果两个数相同，则不用操作就直接得到，输出 $0$。

- 我们可以知道，通过一次按位与上一个 $0$ 可以使任意一位变成 $0$；按位或上一个 $1$ 可以使任意一位变成 $1$。因此转化思维：我们一次可以将二进制下的 $n$ 任意几位变成 $1$ 或者变成 $0$，问有最少有多少次操作可以变成二进制下的 $m$？ 显而易见答案不是 $1$ 次就是 $2$ 次。分三种情况讨论。

1. 如果存在 $n$ 的某些位上是 $0$，而 $m$ 对应的那一位是 $1$；且不存在 $n$ 的某些位上是 $1$，而 $m$ 对应的那一位是 $0$。就可以通过把这些 $0$ 改成 $1$ 变成 $m$，输出 $1$。

2. 如果存在 $n$ 的某些位上是 $1$，而 $m$ 对应的那一位是 $0$；且不存在 $n$ 的某些位上是 $0$，而 $m$ 对应的那一位是 $1$。就可以通过把这些 $1$ 改成 $0$ 变成 $m$，输出 $1$。

3. 如果同时存在 $n$ 的某些位上是 $0$，而 $m$ 对应的那一位是 $1$，且 $n$ 的某些位上是 $1$，而 $m$ 对应的那一位是 $0$。可以通过两次操作将相应的 $0$ 变成 $1$，相应的 $1$ 变成 $0$，输出 $2$。


### 解题细节：
注意到数据范围：$n,m \leq 10^{18}$，所以 $n$ 和 $m$ 要开 `long long`。

### CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
long long n,m;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%lld%lld",&n,&m);
		if(n==m){
			printf("0\n");
			continue;
		}
		if((n|m)==n||(n|m)==m){
			printf("1\n");
		}else{
			printf("2\n");
		}
	}
	return 0;
}
```

---

## 作者：include13_fAKe (赞：8)

## 题意
$T$ 组数据，每组数据给定两个数 $n$ 和 $m$，可以将 $n$ 和其他任何数进行与操作和或操作，问至少要进行多少次操作才能使 $n=m$。
## 思路
### 30分
爆搜。
### 正解
考虑将 $n$ 和 $m$ 都变成二进制数。

接下来，逐位比较 $n$ 和 $m$。

如果有一位上 $n$ 是 $1$，而 $m$ 是 $0$，就说明需要进行与操作，把 $n$ 的这一位变成 $0$。

同样，如果有一位上 $n$ 是 $0$，而 $m$ 是 $1$，就说明需要进行或操作，把 $n$ 的这一位变成 $1$。

并且，同种操作可以同时完成。

所以，我们可以用两个布尔数组记录有没有出现以上两种情况。可证明，任意数据下，答案都 $\le 2$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int T;
long long n,m;
int main(){
	cin>>T;
	while(T--){
		bool flag1=false;
		bool flag2=false;
		cin>>n>>m;
		for(long long i=2;i<=max(n,m)*2;i*=2){
			long long x=n%i;
			long long y=m%i;
			if(x>y)	flag1=true;
			if(y>x)	flag2=true;
		}
		cout<<(flag1)+(flag2)<<endl;
	}
	return 0;
} 
```


---

## 作者：佬头 (赞：8)

# 题解 -「RiOI-2」hacker

## $Description$
题目给出总共 $t$ 组数据，每组数据给出两个整数 $n,m$，请求出 $n$ 通过**至少**几次**按位与**或**按位或**运算可以得到 $m$。

[题目链接](https://www.luogu.com.cn/problem/P9496)

[个人博客](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-p9496)

## $introduction$
**前置知识~~芝士~~**

[**按位与**](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818?fr=ge_ala)：对于参与进制运算的两个数的二进制，将其互相对应的每一位进行**与运算**（$1\land1=1$，$0\land1=0$，$1\land0=0$，$0\land0=0$），得到的就是结果的相应位的值。

**例子：**

```
(22) 1 0 1 1 0
(13) 0 1 1 0 1 &
________________
( 4) 0 0 1 0 0
```

[**按位或：**](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96/548283?fr=ge_ala)对于参与进制运算的两个数的二进制，将其互相对应的每一位进行**或运算**（$1\lor1=1$，$0\lor1=1$，$1\lor0=1$，$0\lor0=0$），得到的就是结果的相应位的值。

**例子：**

```
(22) 1 0 1 1 0
(13) 0 1 1 0 1 |
________________
(31) 1 1 1 1 1
```

具体题目中也有链接，在此便不多赘述了。

## $Solution$

将 $n$ 与任意一个**正整数**进行任意次上面两种运算得到 $m$，求最少的操作次数。

$1.$ 通过**或运算**我们可以将 $n$ 的二进制表示中为 $0$ 且 $m$ 的二进制表示中对应位为 $1$ 的数位变为 $1$。

可以看上方 $22$ 和 $13$ 的**例子**（$n=22$，$m=13$），我们可以先将 $n$ **按位或**上 $8$（其二进制表示为 $1000_{(2)}$），则此时 $n$ 便变成了 $30$（其二进制表示为 $11110_{(2)}$）；再将 $n$ **按位或**上 $1$，此时 $n$ 就变成了 $31$（其二进制表示为 $11111_{(2)}$）。

由于题目要求的是最少操作次数，我们可以将 $1$ 和 $8$ 加在一起变成 $9$（其二进制表示为 $1001_{(2)}$），这样**或运算**就可以只进行一次了。 **~~Oh yeah!~~**

```
(22) 1 0 1 1 0
( 9) 0 1 0 0 1 |
________________
(31) 1 1 1 1 1
```

这样的话 $m$ 的二进制表示中为 $1$ 的数位在 $n$ 的二进制表示中的对应数位也为 $1$。

当然如果原先 $m$ 的二进制表示中为 $1$ 的数位在 $n$ 的二进制表示中的对应数位也均为 $1$，则不需要进行**或运算**操作。

**注**：以上不会出现**无效操作**，即将 $n$ 中不必要的数位通过**或运算**变成 $1$。

$2.$ 通过**与运算**我们可以将 $n$ 的二进制表示中为 $1$ 但 $m$ 的二进制表示中对应位为 $0$ 的数位变为 $0$。

此时经过上方**或运算**的铺垫，**与运算**就表示自己已经可以很容易被理解了——只要将经过或运算得到的新 $n$ **按位与**上 $m$ 就可以了。

续写**例子：**

```
(31) 1 1 1 1 1
(13) 0 1 1 0 1 &
_________________
(13) 0 1 1 0 1
```

同样，如果经过**或运算**后 $m$ 的二进制表示中为 $0$ 的数位在 $n$ 的二进制表示中的对应数位也均为 $0$，则不需要进行**或运算**操作。

$3.$ 问题似乎已经被解决了，但我们可以整理一下——事实上将 $n$ 变为 $m$ 最多只需要两步操作就好了，再根据**或运算**的目的，我们可以得出当 $n\And m\ne m$ 时（即判断两数的二进制表示中是否存在一个数位在 $n$ 中为 $0$ 但在 $m$ 中为 $1$），要进行**或运算**。同理，根据**与运算**的目的，我们可以得出当 $n\And m\ne n$ 时（即判断两数的二进制表示中是否存在一个数位在 $n$ 中为 $1$ 但在 $m$ 中为 $0$），要进行**与运算**（由于**或运算**中没有**无效操作**，所以可以直接对 $n$ 的原值和 $m$ 比较进行判断）。这样就可以直接跳过一些运算和赋值的步骤，输入之后直接输出。

更多细节自己**体会 + 感悟**，吾已是**言之意尽**。

**时间复杂度:** $\mathcal{O}(t)$

## $code$
```cpp
#include <iostream>
using namespace std;
int t;
long long n, m; //不开long long见祖宗
int main(){
	cin >> t;
	for(int i = 1; i <= t; ++ i){
		cin >> n >> m;
		cout << ((n & m) != m) + ((n & m) != n) << endl;
	}
	return 0;
}
```

~~就喜欢红题的极简代码~~

---

## 作者：EdenSky (赞：7)

# [P9496 hacker](https://www.luogu.com.cn/problem/P9496)
- [或许更好的阅读体验](https://www.cnblogs.com/wanguan/p/17624057.html)

## 正文

在讲解之前，先来几种简单情况：

让 $n=1$ 转变成 $m=0$，只需要让 $n \land 0$ 即可；

让 $n=0$ 转变成 $m=1$，只需要让 $n \lor 1$ 即可。

将 $n$ 扩展成更大的。对于 $n$ 二进制的每一位数，只需要按上述情况处理即可，而由于可以对任意数进行位运算，所以相同类型的位运算可以合并成一次。

由于只有两种位运算，很容易知道，最终答案 $ans\in \{0,1,2\}$。

如果 $n$ 有一个二进制位需要或，则最终 $ans \leftarrow ans+1$，若有一个二进制位需要与，则最终 $ans \leftarrow ans+1$。

输出 $ans$ 即可。

```cpp
#include<iostream>
using namespace std;
long long n,m;
int T,huo,yu;
int main(){
  ios::sync_with_stdio(false),cin.tie(0);
  cin>>T;
  while(T--){
    cin>>n>>m,huo=0,yu=0;
    for(int i=0;(n>>i)||(m>>i);i++)
      if((n>>i&1)==0&&(m>>i&1)==1) huo=1;
      else if((n>>i&1)==1&&(m>>i&1)==0) yu=1;
    cout<<huo+yu<<'\n';
  } 
}
```

[AC 记录](https://www.luogu.com.cn/record/119433974)。

---

## 作者：251Sec (赞：3)

小清新 2A。

注意到 $n\ \&\ m\ |\ m = m$。所以最终操作次数不超过 $2$。

如果 $n=m$，则操作次数为 $0$。

什么时候操作次数为 $1$ 呢？可以发现这次操作必定是 $n \gets n\ \&\ m$ 或者 $n \gets n\ |\ m$。所以能用一次操作解决当且仅当 $n\ \&\ m=m$ 或 $n\ |\ m=m$。

于是可以通过该题。

代码可以直接按照上面所说的写，但是有很简洁的写法，如下所示。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T;
ll n, m;
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%lld%lld", &n, &m);
        printf("%d\n", ((n & m) != m) + ((n & m) != n));
    }
    return 0;
}
```

---

## 作者：i_love_xqh (赞：1)

## 题目链接 ##
[「RiOI-2」hacker](https://www.luogu.com.cn/problem/P9496)
## 分析 ##
### 题意 ###
最少次数**按位与**或**按位或上一个正整数**使 $a$ 变为 $b$。
### 算法分析 ##
可以很容易得出，共有四种情况：
- $a = b$，此时次数为 $0$ 。
- $a\operatorname{and}b=a$，相当于二进制下 $a$ 是 $b$ 的一部分，这时候 $a$ 只需**按位或上** $b$。如 $a=01001$，$b=01101$。
- $a\operatorname{or}b = a$，相当于二进制下 $b$ 是 $a$ 的一部分，这时候 $a$ 只需**按位与上** $b$。如 $a=01011$，$b=00011$。
- 均不属于以上情况，此时可以证明只需进行两次运算。就只需先 $a\operatorname{or}b$，再 $a\operatorname{and}b$。

由此可得出完整代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    ll t,n,m,i;
    scanf("%lld",&t);//数据组数
    for(i=1;i<=t;i++){
        scanf("%lld%lld",&n,&m);
        if(n==m)printf("0\n");//情况一
        else if(((n&m)==n)||((n|m)==n))printf("1\n");//情况二与情况三（注意运算优先级）
        else printf("2\n");//情况四
    }
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

首先下个大家都知道的结论：

- 如果 $n=m$，直接输出 $0$，因为什么操作都不用做。

别的情况，暂时先不管，我们先看**按位与**和**按位或**。

众所周知，当一个数按位与另一个数时两数二进制中 $1$ 的数量一定不会增加，按位或另一个数时两数二进制中 $1$ 的数量一定不会减少。证明：按位与时要想让 $1$ 变多，原来 $0$ 的位置会变成 $1$，但是在按位与中，必须两数中两位都是 $1$，$0$ 在按位与中不可能变成 $1$。按位或时要想让 $0$ 变多，原来 $1$ 的位置会变成 $0$，但是在按位与中，必须两数中两位都是 $0$，$1$ 在按位或中不可能变成 $0$。

那么我们最多只用进行 $2$ 次操作，一次将 $n$ 二进制中 $n$ 是 $1$，$m$ 中是 $0$ 用按位与消掉，第二次将 $n$ 二进制中 $n$ 是 $0$，$m$ 中是 $1$ 用按位或加上。

那怎么判断要一次还是两次呢？其实很简单：我们可以用两个数组来存 $n$ 和 $m$ 的二进制，在定义两个布尔型变量，分别记录是否需要按位与和按位或，再将两个数组进行逐位比较，如果 $n$ 的二进制数组中有一位为 $1$，$m$ 二进制相同位为 $0$，说明要用**按位与**把这个 $1$ 变成 $0$，其中一个变成正确，如果 $n$ 的某一位为 $0$，$m$ 的相同位为 $1$，则需要用**按位或**把这位变成 $1$，另一个布尔型变量变成正确，而我们只用在循环完毕时输出值为正确的布尔变量个数即可。

最后，要开 ``long long``。

赛时代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int t,n,m;

signed main(){
	std::ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(n==m) puts("0");
		else{
			if(n>m) swap(n,m);
			vector<int> v1,v2;
			while(n){  //将 n，m 转化成二进制。
				v1.push_back(n%2);
				n/=2;
			}
			while(m){
				v2.push_back(m%2);
				m/=2;
			}
			bool fg1=false,fg2=false;
			int l=v2.size();
			for(;v1.size()<l;) v1.push_back(0);//当 n 的二进制数位数不够时，填上 0。 
			for(int i=0;i<l;i++){
				if(v1[i]==0&&v2[i]==1) fg1=true;
				if(v1[i]==1&&v2[i]==0) fg2=true;
				if(fg1&&fg2) break;
			}
			if(fg1&&fg2) puts("2");
			else puts("1");
		}
	}
	return 0;
}
```

以上代码是对的，但是赛后我又想到了一种方法：

首先如果 $n=m$，还是输出 $0$。

接着如果 $n$ 只增加一些位或只减少一些位，就输出 $1$，否则输出 $2$。

关键在于：如何判断增加输出 $1$ 的情况。

众所周知，$n$ 增加一些能变成 $m$，说明 $m$ 的二进制中包含 $n$ 的二进制，我们只用让 $m\land n$（$\land$ 表示按位与）再判断 $m\land n$ 是否等于 $n$，如果等于，说明 $m$ 的二进制中包含 $n$ 的二进制，输出 $1$。

增加说了，还剩减少，减少其实更简单，$n$ 减少变成 $m$，其实相当于 $m$ 增加变成 $n$，所以只用判断 $m\land n$ 是否等于 $m$ 即可。

赛后代码：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long

int t,n,m;

signed main(){
	std::ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(n==m) puts("0");
		else if((n&m)==m||(m&n)==n) puts("1");  //打括号的原因是因为优先级。
		else puts("2");
	}
	return 0;
}
```


---

## 作者：_5t0_0r2_ (赞：1)

# 分析：

要通过位运算把 $n$ 修改为 $m$，我们只能将 $1$ 转为 $0$，或将 $0$ 转为 $1$。而一次按位或可以将值为 $0$ 的位转为值为 $1$ 的位，一次按位与可以将值为 $1$ 的位转为值为 $0$ 的位。

所以我们分三种情况讨论。

当 $n = m$ 时，直接输出 $0$。

如果把 $n$ 只存在值为 $0$ 的位需要转为值为 $1$ 的位，或只存在值为 $1$ 的位需要转为值为 $2$ 的位，输出 $1$。

否则，输出 $2$。

# 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,m;
int lowbit(int x){
	return x & (-x);
}
bool check1(int x,int y){
	int cnt = 0;
	while(x || y){
		if((x & 1) == 0 && (y & 1) == 1)
			return true;
		x >>= 1;
		y >>= 1;
	}
	return false;
}
bool check2(int x,int y){
	int cnt = 0;
	while(x || y){
		if((x & 1) == 1 && (y & 1) == 0)
			return true;
		x >>= 1;
		y >>= 1;
	}
	return false;
}
signed main(){
	scanf("%lld", &t);
	for(int i = 1;i <= t;i++){
		scanf("%lld%lld", &n, &m);
		if(n == m)
			puts("0");
		else if(check1(n,m) && check2(n,m))
			puts("2");
		else
			puts("1");
	}
}
```


---

## 作者：oscar0866 (赞：0)

这两个数如果 $1$ 是全包含那就是 $1$ 步操作，如果有错位那就需要两步操作，比如 $1$ 先和 $100$ 按位或变成 $101$ 再和 $100$ 按位与变成 $100$ 的。就是其中一个数的 $1$ 的位置被另一个数完全包含，这时候只要一个按位或操作就可以变过去了，如果 $1$ 的位置有错位那一定可以先用按位或再用按位与变过去。

AC 代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
int a[70], b[70];
int main()
{
    int t;
    scanf("%d", &t);
    while (t--) {
        LL n, m;
        scanf("%lld%lld", &n, &m);
        if (n == m) printf("0\n");
        else {
            if (n > m) swap(n, m);//n 和 m 里小的那个。
            int ans = 1;
            for (int i = 0; i < 64; i++) { //因为数据范围 10^18，化到 64 位肯定够了。
                a[i] = n % 2; n /= 2;
                b[i] = m % 2; m /= 2;
                if (a[i] == 1 && b[i] == 0) ans = 2;
            }
            printf("%d\n", ans);
        }
    }
    return 0;
}
```


---


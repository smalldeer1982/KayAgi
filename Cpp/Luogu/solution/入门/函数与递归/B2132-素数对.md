# 素数对

## 题目描述

定义两个相差为 $2$ 的素数称为素数对，如 $5$ 和 $7,17$ 和 $19$ 等，要求找出所有两个数均不大于 $n$ 的素数对。

## 样例 #1

### 输入

```
10```

### 输出

```
3 5
5 7```

## 样例 #2

### 输入

```
100```

### 输出

```
3 5
5 7
11 13
17 19
29 31
41 43
59 61
71 73```

## 样例 #3

### 输入

```
3```

### 输出

```
empty```

# 题解

## 作者：墨忧 (赞：25)

## 解法
由于本题数据范围较小，因此用 $i$ 直接从 3 到 $n$ 枚举每个数，若 $i$ 和 $i-2$ 均为素数则输出即可 
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool prime(int x)//判断是否为质数的函数 
{
    if(x==1) return false;
    if(x==2) return true;
    int j=2;
    while(j*j<=x && x%j!=0) j++;
    if(x%j==0) return false;
    else return true;
}
bool pd=true; 
int main()
{
    cin>>n;
    for(int i=3;i<=n;i++)
    {
        if(prime(i) && prime(i-2))//枚举 
        {
            cout<<i-2<<" "<<i<<endl;
            pd=false;
        }
    }
    if(pd) cout<<"empty"<<endl;
    //若没有找到，则输出 "empty"
    return 0;
}
```


---

## 作者：一只大龙猫 (赞：11)

[原题传送门](https://www.luogu.com.cn/problem/B2132)

由于 $n$ 最大只到 $10000$，所以我们可以直接枚举并判断。

```cpp
#include<iostream>
using namespace std;
int n;
bool b;//如果b为1，则表示找到了，为0则表示没找到。 
bool check(int x){
	for(int i=2;i*i<=x;i++){//枚举到x的平方根就可以了，降低时间复杂度。 
		if(x%i==0)return 0;//若除了1和x本身还有别的因数，则x不是质数，返回0。 
	}
	return 1;//否则返回1。 
}
int main(){
	cin>>n;
	for(int i=3;i<=n-2;i++){//因为2与任何一个素数的差都不为2，所以可以直接从3开始枚举。 
		if(check(i)&&check(i+2)){
			b=1;//找到后记得标记。 
			cout<<i<<" "<<i+2<<endl;
		}
	}
	if(b==0){
		cout<<"empty";
	}
	return 0;
}

```

时间复杂度为 $O(n \sqrt n)$，对于这道题来说足够了。（当然还有更优的筛法，如时间复杂度仅为 $O(n)$ 的欧拉筛。想了解更多的可以看[这里](https://www.luogu.com.cn/blog/cicos/notprime)。）

---

## 作者：DeepSkyBlue__ (赞：5)

这道题由于 $N$ 的范围不大，可以使用最简单的方法判断素数。

[素数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fromtitle=%E7%B4%A0%E6%95%B0&fromid=115069&fr=aladdin) 指除了 $1$ 和它本身以外不再有其他因数的自然数。

那我们直接枚举这个数可能的因数，如果除了 $1$ 和它本身以外还有其他因数，那么它就不是素数了。

由于因数总是成对出现的，所以只需要枚举到这个数的算术平方根向下取整即可。

可以将判断过程写成函数处理。

另外 $1$ 不是素数， $2$ 是素数，要特判一下。

对于每一个在 $1$ 到 $n-2$ 之间的整数，如果它自身与它加 $2$ 都是素数，那么它们就是一对素数对，将其输出即可。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool Isprime(int x)//判断是否是素数的函数，返回0代表不是素数，返回1代表是素数
{
    if(x<=1)return 0;//特判
    if(x==2)return 1;
    for(int i=2;i*i<=x;i++)//枚举可能的因数
        if(x%i==0)return 0;//能被整除，存在除了1与自身以外的因数，不是素数
    return 1;//否则就一定是素数
}
int main()
{
    int n;
    cin>>n;
    bool Salah=0;//Salah代表是否有素数对
    for(int i=1;i<=n-2;i++)//i循环到n-2是为了防止另一个数超过n的范围
        if(Isprime(i)&&Isprime(i+2))//找到了素数对
        {
            cout<<i<<" "<<i+2<<endl;//输出
            Salah=1;//记录有素数对
        }
    if(!Salah)cout<<"empty"<<endl;//没有找到素数对，输出empty
    return 0;
}
```


---

## 作者：koishi_x (赞：4)

如果我们想知道小于等于 $n$ 的所有素数，一个自然的想法就是对每个数做一次素数检验，但这样显然是不优的(~~虽然能过掉此题~~)。于是我们引出了一种新的算法：

## Eratosthenes 筛法
**Eratosthenes 筛法**（埃拉托斯特尼筛法，简称埃氏筛法），是一种能够筛选出 $1$ 到 $n$ 里所有素数的简单方法。

筛法基于一个简单的事实：一个数的比自己大的倍数一定是是合数。

比如 $3$ 是素数，那显然 $6,9,12...$ 都是合数。

如果我们从 $2$ 开始从小到大考虑每一个数，遍历所有比自己大的倍数并标记为合数，那么最后没有被标记的就是素数。

进一步优化，如果一个数是合数，那么就没必要遍历它的倍数了。因为它的倍数已经被它的某一个质因子遍历过了。

比如 $4$ 的倍数有 $8,12,16...$，而这些数也都是 2 的倍数，所以就不需要重复遍历了。

Eratosthenes 筛法的时间复杂度为 $O(n\log\log n)$，具体证明就不详述了。

具体的实现细节详见代码。

~~都求出所有素数了就不用说怎么找素数对了吧~~

Code:
```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int n;
bool nprime[10010];

void Eratosthenes()
{
	for(int i = 2; i <= n; ++i)	//i从2开始 
		if(!nprime[i])	//如果i不是素数 
		{
			for(int j = 2; i * j <= n; ++j) //遍历i的所有比自己大的倍数（在n以内） 
				nprime[i*j] = 1;	//i*j标记为合数 
		}
}

int main()
{
	scanf("%d", &n);
	Eratosthenes();		//Eratosthenes 筛法 
	int cnt = 0;
	for(int i = 3; i <= n - 2; ++i)
		if(!nprime[i] && !nprime[i+2])	//判断素数对 
		{
			printf("%d %d\n", i, i + 2);
			++cnt;
		}
	if(!cnt) puts("empty");		//输出无解 
	
}
```

顺带提一嘴，埃氏筛可以进一步优化成线性筛，时间复杂度可以做到线性，即 $O(n)$，~~不过本文并不会介绍~~。有兴趣的同学可以自行查阅资料了解。

---


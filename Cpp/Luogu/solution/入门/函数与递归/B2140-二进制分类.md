# 二进制分类

## 题目描述

若将一个正整数化为二进制数，在此二进制数中，我们将数字 $1$ 的个数多于数字 $0$ 的个数的这类二进制数称为 $A$ 类数，否则就称其为 $B$ 类数。

例如：

$(13)_{10}=(1101)_2$，其中 $1$ 的个数为 $3$，$0$ 的个数为 $1$，则称此数为 $A$ 类数；

$(10)_{10}=(1010)_2$，其中 $1$ 的个数为 $2$，$0$ 的个数也为 $2$，称此数为 $B$ 类数；

$(24)_{10}=(11000)_2$，其中 $1$ 的个数为 $2$，$0$ 的个数为 $3$，则称此数为 $B$ 类数；

程序要求：求出 1~n 之中（$1 \le n \le 1000$），全部 $A,B$ 两类数的个数。

## 样例 #1

### 输入

```
7
```

### 输出

```
5 2
```

# 题解

## 作者：DiDi123 (赞：33)

# 题目分析
这道题要求我们把 $1 \sim n$ 的所有数分类，那我们只需要统计这个数的二进制有多少个 $1$ 和 $0$ 就行了。有一种办法就是把这个数的二进制的每一位都提取出来。

**代码中用到的一些进制处理：**

将 $x$ （二进制形式）右移 $n$ 位：
```cpp
x>>n
```
将 $x$ 和 $y$ 按位与：
```cpp
x&y
```
（按位且的规则：将 $x$ 和 $y$ 的二进制按位比较，若一位都是 $1$ ，则返回 $1$ ，否则，返回 $0$ ）



------------

那么，有了以上的铺垫，我们就能很轻松的提取了。我们这需要每次把数和 $1$ 进行按位且操作，这样就能提取出这个数的最后一位，然后在把这个数右移一位就行了。

# 代码

```cpp
#include <iostream>
using namespace std;
int A, B, cnt0, cnt1;
int main() {
	int n, t, temp;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cnt0 = 0, cnt1 = 0;
		t = i;
		while (t) {
			temp = t & 1;
			t = t >> 1;
			if (temp) cnt1++;
			else cnt0++;
		}
		cnt1 > cnt0 ? A++ : B++;
	}
	cout << A << ' ' << B;
}
```


---

## 作者：囧仙 (赞：15)

## 题目大意

> 计算 $1\sim n$ 当中，有多少个数，在二进制下 $1$ 的个数大于 $0$ ；有多少个数，在二进制下 $1$ 的个数不超过 $0$ 。

## 题解

### 做法 1

最传统的方法，莫过于依次枚举 $1,2,3,\cdots n$ ，将每个数进行二进制分解，然后直接统计。

如何将一个数转换为二进制？我们只要每次将它除以 $2$ ，将余数收集起来翻转，就可以得到它的二进制。例如：

$$\begin{aligned}

113\div 2&=56 \cdots\cdots 1 \cr
56 \div 2&=28\cdots\cdots0 \cr
28\div 2&=14\cdots\cdots 0 \cr
14\div 2&=7\ \ \cdots\cdots 0\cr
7\div 2&=3\ \ \cdots\cdots 1\cr
3\div 2&=1\ \ \cdots\cdots 1\cr
1\div 2&=0\ \ \cdots\cdots 1\cr
\end{aligned}$$

收集所有余数并翻转，得到 $113_{(10)}=1110001_{(2)}$ 。我们每次除以 $2$ 时，根据余数统计 $1$ 和 $0$ 的个数即可。

时间复杂度为 $\mathcal O(n\log n)$ 。

### 代码 1

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,a,b;
int main(){
    n=qread(); up(1,n,i){
        int t=i,c[2]; c[0]=c[1]=0; while(t) ++c[t&1],t>>=1;
        if(c[1]>c[0]) ++a; else ++b;
    }
    printf("%d %d\n",a,b);
    return 0;
}
```

### 做法 2

可不可以不要手动除以 $2$ 呢？事实上， C++ 中提供了一种用于存储 $0$ 和 $1$ 的数据类型 $\verb!bitset!$ 可以用于将一个数转换为二进制。我们只是借用了它的构造函数而已。

`bitset<100> b(114514);` 表示定义一个 $\verb!bitset!$ 类型的变量 $b$ ，它的初始值就是 $114514$ 的二进制形式。但是这种做法有个缺点：由于我们指定了 $\verb!bitset!$ 的位数，因此可能会出现一些前导零（例如 $\verb!00010101!$ 这样的形式）。然而， $\verb!bitset!$ 里提供了一种用法 $\verb!count()!$ 用于统计其中的 $1$ 的个数，因而我们只要知道对于每个 $i$ ，它有多少位即可。这个可以用对数函数 $\log_2 x$ 下取整求得（在 C++ 中，对应 $\verb!log2(x)!$ ）。

### 代码 2

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,a,b;
int main(){
    n=qread(); up(1,n,i){
        bitset <20> bt(i); int c1=bt.count(),c2=floor(log2(i)+1)+1e-6-c1;
        if(c1>c2) ++a; else ++b;
    }
    printf("%d %d\n",a,b);
    return 0;
}
```

### 做法 3


在 C++ 中，我们完全可以直接使用位运算统计出哪些位上有 $1$ 。例如，与运算 $\verb!and!$ （或者，在 C++ 中对应着 $\verb!&!$ ）可以计算出二进制下两个数相同的 $1$ 的部分；而左移运算 $\verb!lshift!$ （或者，在 C++ 中对应着 $\verb!<<!$ ）可以快速计算出 $2^x$ 的值。


因此，形如 `x&(1<<k)` 的代码，就能计算出 $x$ 的二进制下第 $k$ 位是否为 $1$ 。然而，正如做法 2 所要求的，我们也得求出 $i$ 在二进制下有多少位，防止统计错了。最后的步骤类似于做法 1，如法炮制。

### 代码 3


```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,a,b;
int main(){
    n=qread(); up(1,n,i){
        int c1=0,c2=0;
        up(0,log2(i),j) if(i&(1<<j)) ++c1; else ++c2; if(c1>c2) ++a; else ++b;
    }
    printf("%d %d\n",a,b);
    return 0;
}
```

### 做法 4

使用内置函数（不大推荐），我们会用到以下两条：

- `__builtin_popcount(unsigned int n)` ： 该函数时判断 $n$ 的二进制中有多少个 $1$ 。

- `__builtin_clz(unsigned int x)` ： 返回前导的0的个数。

第一个函数就类似于 $\verb!bitset!$ 当中的 $\verb!count!$ 函数，可以计算出二进制下有多少个 $1$ ；而第二个函数可以辅助我们计算出一个数二进制下有多少位。实际做法与做法 3 类似。


### 代码 4

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,a,b;
int main(){
    n=qread(); up(1,n,i){
        int c1=__builtin_popcount(i),c2=32-__builtin_clz(i)-c1;
        if(c1>c2) ++a; else ++b;
    }
    printf("%d %d\n",a,b);
    return 0;
}
```

---

## 作者：rui_er (赞：5)

来一篇 PHP 的题解。

先放[代码](https://www.luogu.com.cn/paste/3eqvcfzg)（由于洛谷博客代码框中有美元符号会炸掉，挂一个剪贴板链接）。

我们来分析一下这段代码。

首先从标准输入读入变量 $n$，由于这里输入是一个整数，$n$ 也是一个整数。然后我们使用两个变量 $\textrm{cntA}$ 和 $\textrm{cntB}$ 统计 A 类数和 B 类数的个数。

接下来我们需要枚举 $1\sim n$ 的整数，这里介绍一下 PHP 中的 for 循环语句，语句格式为：

```plain
for(初始值; 条件; 增量) {
    要执行的代码;
}
```

在本题的代码中，这个循环表示 $i$ 的初始值为 $1$，每次循环结束自增 $1$，直到 $i$ 大于 $n$ 为止。

然后我们将 $i$ 拷贝到 $k$ 中，每次取出对 $2$ 取模的余数，就是最低位的值，统计好当前位后将 $k$ 除以 $2$，也就是去掉最低位继续统计。

之后判断 $1$ 和 $0$ 哪个多，对应类别加一即可。

输出的时候要先后输出 $\textrm{cntA}$ 和 $\textrm{cntB}$，中间用一个空格隔开，我们使用并置运算符 `.`，表示将 $\textrm{cntA}$ 的值、空格、$\textrm{cntB}$ 的值先后连接起来，然后输出即可。

---

## 作者：Arghariza (赞：4)

- 简单の做法

需要用到位运算。

对于每一个 $i\in[1,n]∩\mathbb Z$ ，枚举 $i$ 的每一位。

对于任何 $x\in \mathbb N^*$ ，其二进制表达末尾的值为 `x & 1`  ，我们通过**右移**操作遍历这个数的每一位 `x >>= 1` 。

枚举所有数复杂度 $O(n)$ ，遍历每一位复杂度 $O(\log n)$

总共 $O(n\log n)$

```cpp
#include <bits/stdc++.h>
namespace mystd {
	inline int read() {
		int w = 1, q = 0;
		char ch = ' ';
		while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
		if (ch == '-') w = -1, ch = getchar();
		while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
		return w * q;
	}
	inline void write(int x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace std;
using namespace mystd;

int n, ans;

int get(int x) {
	int ca = 0, cb = 0;
	while (x) {
		if (x & 1) ca++;
		else cb++;
		x >>= 1;
	}
	if (ca > cb) return 1;
	else return 0;
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) {
		if (get(i)) ans++;
	}
	write(ans);
	putchar(' ');
	write(n - ans);
	return 0;
}
```

- 笨笨の做法

获取其二进制表达位数，枚举每一位的情况（0 或者 1），判断其是否小于 $n$ 。

复杂度同样是 $O(n\log n)$ 数量级的，因为枚举位数的时候 $2$ 的幂和 $n$ 的二进制位数会消掉。

不过实现起来复杂挺多/fad。

---

## 作者：yzy1 (赞：1)

我们可以巧用 Python 中的 `range for`，得到一种「一行解法」：

```python
n=int(input())
print(sum([int(bin(i).count('1')>(bin(i).count('0')-1)) for i in range(1,n+1)]),n-sum([int(bin(i).count('1')>(bin(i).count('0')-1)) for i in range(1,n+1)]))
```

我们来解析一下这段代码。

- `bin` 函数接受一个整数，返回这个整数的二进制表示的**字符串**，这个字符串会添加一个前缀 `0b`。
- 由于 `bin` 函数会自动添加前缀，所以我们求 $0$ 的个数是要减去一个 `0b` 中的零，得到的才是真正答案。
- `s.count(t)` 函数返回母串 `s` 中的字串 `t` 数量。在此处 `t` 为 `0` 和 `1`，即分别找到数字的二进制表示中零一的个数。
- 由于 `>` 运算符返回的是 `bool` 类型，我们需要用 `int` 将其转换为整形。
- 最后用 `range for` 和 `sum` 求出 $1\sim n$ 所有整数中符合条件的数的个数。输出即可。

---


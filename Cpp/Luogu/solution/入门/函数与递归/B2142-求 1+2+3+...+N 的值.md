# 求 1+2+3+...+N 的值

## 题目描述

用递归的方法求 $1+2+3+$ …… $+N$ 的值。

## 说明/提示

$N\le 200$

## 样例 #1

### 输入

```
5```

### 输出

```
15```

# 题解

## 作者：daiarineko (赞：32)

## 题意简述

求 $\sum\limits^n_{i=1} i$。

## 解法1

复杂度：$\Theta(n)$

题目要求的解法，使用递归。

具体讲一下 `f` 函数，这里 `f(n)` 的定义是 $\sum\limits^n_{i=1} i$。

其中 $\sum\limits^n_{i=1} i = (\sum\limits^{n-1}_{i=1} i)+n$，所以可以递归地调用 `f` 函数：`return f(n-1)+n`。

递归的结束条件：`n==1`，这时候 $(\sum\limits^1_{i=1}i)=1$，直接返回。

（亦可在 `n==0` 时返回 `0`）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int n){
    if(n==1)return 1;
    return f(n-1)+n;
}
int main(){
    int n;
    cin>>n;
    cout<<f(n)<<endl;
    return 0;
}
```

## 解法2

复杂度：$\Theta(1)$

可以使用数学解法降低复杂度。

我们都知道等差数列的通项公式：（首项+末项）*项数/2。

其中首项为 $1$，末项为 $n$，项数为 $n$。

代入公式得 $\frac{(n+1)n}{2}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<n*(n+1)/2<<endl;
    return 0;
}
```

此解法在 $n$ 非常大时性能很好。

---

## 作者：ZhaiOverflow (赞：16)

## 题意
使用递归方式求解等差数列的和。

## 分析
~~明明有更方便的求和公式为什么不用~~

我们遇到了第一个问题：什么是递归？

以下摘自百度百科：

“**程序调用自身的编程技巧称为递归**。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常**把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解**，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有**边界条件、递归前进段和递归返回段**。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。”

### 我们可以从中提取几点有用的信息：

1. 递归就是程序调用自身。
1. 递归的思想可以把大型问题转化为较小规模问题。
1. 递归的必要条件是边界条件、递归前进段和递归返回段。

第二个问题：如何程序实现递归？

其实上文已经给出了答案：程序调用自身。

比如说：
```
int digui(int a) {
	digui(a - 1);
}
```
这就是一次程序（函数）的自我调用。但是当我们试着运行这个函数是，却发现程序异常退出了。这显然不是完整的递归。

我们再看看上文：**递归的必要条件是边界条件、递归前进段和递归返回段。**

于是我们明白了：在这个函数中，只有递归前进段（即递归调用），而没有边界条件和递归返回段。

为什么边界条件和递归返回段是必要的？

很简单，如果没有设定递归边界，那么这个递归调用就永远不会结束。在生活中，这种情况被称作**无限套娃**。而在计算机中，这种情况叫做**无限递归**。由于递归占用计算机栈内存，通常表现为计算机**栈内存溢出**。

避免栈溢出的方式，就是添加递归边界。
```
int digui(int a) {
	if(a == 1) return 1;
    return digui(a - 1);
}
```
由此，我们得到了一个完整的**递归函数**。

将这个函数结合本题题意进行修改：
边界条件和递归返回段。
```
int solve(int n) {
    if(n == 1) return 1;
    return(solve(n - 1) + n);
}

```
这样，就得到了最后的程序。
```
#include<bits/stdc++.h>
using namespace std;

int solve(int n) {
    if(n == 1) return 1;
    return(solve(n - 1) + n);
}

int main() {
    int a;
    cin >> a;
    cout << solve(a);
    return 0;
}
```

---

## 作者：thomas_zjl (赞：7)

# 题目分析。

输入 $1+2+3+…N$ 的值。

# 代码。

有三种写法。

- 递归。

[![RRoH0S.png](https://z3.ax1x.com/2021/07/04/RRoH0S.png)](https://imgtu.com/i/RRoH0S)

根据这幅图，可以写出。

```cpp
inline int slove(int x){
	if(x==1)
		return 1;//当x=1时，就到达的边界，就只要返回1。
	else
		return x+slove(x-1);
}
```

完整代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int slove(int x){
	if(x==1)
		return 1;
	else
		return x+slove(x-1);
}
int main(){
	int a;
	cin>>a;
	cout<<slove(a);
}  
```

- 递推。

相当于递归的升级版。

[![RRoXfs.png](https://z3.ax1x.com/2021/07/04/RRoXfs.png)](https://imgtu.com/i/RRoXfs)

也可以写出代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[100010]; 
int main(){
	int a;
	cin>>a;
	f[1]=1;//要设定f[1]为1。
	for(int i=2;i<=a;i++)
		f[i]+=f[i-1]+i;//进行递推。
	cout<<f[a];
}  
```
- 公式法。

我们都知道这是一个等差数列，我们只需要使用公式即可。

公式：$(1+N)*N/2$。（1为首项，N为末项）

代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int a;
	cin>>a;
	cout<<(1+a)*a/2;
}  
```


---

## 作者：REAL_曼巴 (赞：3)

此题是要求一个等差数列的和，而等差数列求和的公式高斯已经探索出了，下面我给下探索过程。因为项数很小，只有二百，所以不会超。（先来个简单的方法，递归见下）

![](https://cdn.luogu.com.cn/upload/image_hosting/y8h2oe9b.png)

有了公式，直接套用！！！代码如下：

```cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    cout<<(1+n)*n/2;//1首项，n为末项与项数
    return 0;
}
```

下面是递归法：

神魔是递归？递归可以解决一些循环解决不了的问题。而这些问题一般都能被拆解成几个子问题，而子问题可以以相同的方法结决。

比如你要记录国家人口，要从国家开始一级政府往下推，布置任务，推理到每个小区，再一级一级往上汇报人口，得到总数。

递归，有“递”，有“归”。先是递，就可以理解为一级一级往下布置任务，把大问题一点点化成小问题，用同样方法解决。再是归，这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个递归边界，一旦到达了这个边界，就再不用往下走了。

![](https://cdn.luogu.com.cn/upload/image_hosting/1fimk6m6.png)

这里有几个递归要干的事。第一，我们要明确递归要在何时终止，他终止的表达式为什么（递归边界）；第二，我们给出递归终止时的处理办法；第三，就是递归是要怎样解决子问题。第四，就是提取重复的逻辑，缩小问题规模。

下面给一个递归的板子：

```cpp
数据类型 digui(变量){
    if(condition){//递归边界
        end;//递归终止时的处理办法
    }
    else{
        solve;//解决子问题
        digui(变量)//接着往下走
    }
}
```
根据上面的方法，此题解结局了！！！（汇人口的例子）


```cpp
#include<iostream>
using namespace std;
int Sum(int n){
    if(n==0) return 0;
    return n+Sum(n-1);//往下走
}
int main(){
    int a;
    cin>>a;
    cout<<Sum(a);
    return 0;
}
```


---

## 作者：Starw (赞：2)

**主要考察：** 递归。

递归最重要的有两个东西：**边界**和**调用下一层递归**。

这道题的边界和如何调用下一层递归并不难找，我们就可以很轻松地打出如下递归函数：

```cpp
int sum(int x){
	if(x==1) return 1;//边界
	else return x+sum(x-1);//调用下一层递归
}
```

这题毕竟是道红题，主函数也好打。

### 完整代码：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int sum(int x){//递归函数
	if(x==1) return 1;
	else return x+sum(x-1);
}
int main(){
	int n;
	scanf("%d",&n);
	printf("%d",sum(n));
	return 0;
}
```
---
这道题其实还有 O(1)算法，要用到小学知识[等差数列求和公式](https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527418?fr=aladdin)。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	printf("%d",(1+n)*n/2);//套用公式
	return 0;
}
```


---


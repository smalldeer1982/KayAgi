# 求 f(x,n)

## 题目描述

已知 $f(x,n)=\sqrt{n+\sqrt{(n-1)+\sqrt{(n-2)+\sqrt{...+2+\sqrt{1+x}}}}}$。

计算 $f$ 的值。

## 说明/提示

#### 数据范围

对于 $100\%$ 的数据，$1 \le x,n \le 10$。

## 样例 #1

### 输入

```
4.2 10```

### 输出

```
3.68```

# 题解

## 作者：Eason_AC (赞：35)

## Content
求给定 $x,n$，求 $f(x,n)=\sqrt{n+\sqrt{(n-1)+\sqrt{(n-2)+\sqrt{\dots+2+\sqrt{1+x}}}}}$ 的值。
## Solution
乍一看这题目很烦人，其实，如果我们可以转换一下，这道题目就很简单。

我们不妨算下：

$$\begin{aligned}f(x,1)&=\sqrt{1+x}\\f(x,2)&=\sqrt{2+\sqrt{1+x}}=\sqrt{2+f(x,1)}\\f(x,3)&=\sqrt{3+\sqrt{2+\sqrt{1+x}}}=\sqrt{3+f(x,2)}=\sqrt{3+\sqrt{2+f(x,1)}}\\&\vdots\end{aligned}$$

然后我们可以发现，$f(x,n)$ 是一个层层包含的递归关系：如果 $n=1$，那么 $f(x,n)=\sqrt{1+x}$，否则，$f(x,n)=\sqrt{n+f(x,n-1)}$，于是就这么样递归下去然后向上累加答案，足够通过本题。

然而，如果 $n$ 的范围很大，递归的层数很多，我们如果还用递归的话就会内存爆炸，那么怎么办呢？我们考虑把它转为一个递推公式：

$$f_{x,n}=\begin{cases}\sqrt{1+x}&n=1\\\sqrt{n+f_{x,n-1}}&n>1\end{cases}$$

然后你就可以明白了，这不就可以用数组直接循环递推出来就可以了吗？你可能发现了第一维的 $x$，然后你注意到题目中 $x$ 是个实数，那么就不能够以它作为数组的第一维，那么怎么办？我们又发现，**$n>1$ 时，$f_{x,n}$ 只和 $n$ 和 $f_{x,n-1}$ 有关，并不和 $x$ 有关**。所以我们考虑直接将第一维省去，得到：

$$f_n=\begin{cases}\sqrt{1+x}&n=1\\\sqrt{n+f_{n-1}} &n>1\end{cases}$$

然后你就可以用递推通过本题了。
## Code
### 1 递归
```cpp
#include <cstdio>
#include <cmath>
using namespace std;

inline double f(double x, int n) {
	if(n > 1) return sqrt(n + f(x, n - 1));
	else return sqrt(1 + x);
}

int main() {
	double x; scanf("%lf", &x);
    int n; scanf("%d", &n);
	return printf("%.2lf", f(x, n)), 0;
}
```
### 2 递推
```cpp
#include <cstdio>
#include <cmath>
using namespace std;

int main() {
	double x; scanf("%lf", &x);
    int n; scanf("%d", &n);
	double f[10007] = {0.0}; f[1] = sqrt(1 + x);
	F(int, i, 2, n) f[i] = sqrt(i + f[i - 1]);
	return printf("%.2lf", f[n]), 0;
}
```

---

## 作者：N_z_ (赞：15)

## 思路
在主程序内使用一个循环求解。

$f(x,n)=\sqrt{n+\sqrt{(n-1)+\sqrt{(n-2)+\sqrt{...+2+\sqrt{1+x}}}}}$
那么我们赋一个变量 $ans$ 等于 $x$ 。

然后不断循环，将 $ans$ 不断修改为 $\sqrt{i+ans}$ ，即从内到外将 $f(x,n)$ 计算出来。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    double x,n;
    cin>>x>>n;
    double ans=x;
    for(int y=1;y<=n;y++)
    ans=sqrt(y+ans);
    printf("%.2f",ans);
}
```

---

## 作者：囧仙 (赞：7)

## 题解

### 做法 1

观察这个式子，我们可以发现，假如我们已经计算出了 $n=k$ 的情况：

$$R_k=f(x,k)=\sqrt{k+\sqrt{(k-1)+\sqrt{...+2+\sqrt{1+x}}}}$$

那么很容易得到， $R_{k+1}=\sqrt{(k+1)+R_k}$ 。又能够发现， $R_1=\sqrt{1+x}$ ，因此使用 $\verb!for!$ 循环，递推出 $R_n$ 即可。

### 做法 2

既然已经得到了 $R_k$ 的递推式，为什么不直接将 $f(x,n)$ 写成递归的形式呢？

$$f(x,n)=\begin{cases}
f(x,n-1) & n\ge 1 \cr
\sqrt{1+x} & n=1
\end{cases}$$

我们新建一个函数 $f(x,n)$ ，然后根据这个递归式计算就行了。递归的终止条件就是 $n=1$ 。

---

小技巧：我们能够发现，当**嵌套的次数相当多**时，在最里面那一项的贡献已经无关紧要了。于是从 $\max\{1,n-30\}$ 开始枚举也能过题，并且在 $n$ 比较大的时候这种做法更省时间。

## 参考代码

### 代码 1

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
double x,r; int n;
int main(){
    scanf("%lf%d",&x,&n),r=x;
    up(1,n,i) r=sqrt(r+i); printf("%.2lf\n",r);
    return 0;
}
```

### 代码 2

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
double x,r; int n;
double f(int x0,int n0){
    if(n0==1) return sqrt(x0+1); return sqrt(f(x0,n0-1)+n0);
}
int main(){
    scanf("%lf%d",&x,&n); printf("%.2lf\n",f(x,n));
    return 0;
}
```

---

## 作者：Llc521585Y (赞：7)

这道题还是用递归比较好！

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
double m, n;
int f(int m, int n) {
    if(m==0) return n+1;	//递归边界1
    if(n==0 && m>0) return f(m-1, 1);	//递归边界2
    return f(m-1, f(m, n-1)); 	//无边界的正常运算
}
int main() {
    scanf("%d%d", &m, &n);	//输入
    printf("%.2f", f(m, n));	//两位小数输出
    return 0;
}
```


---

## 作者：·糯· (赞：5)

## 题目分析
我们可以制作一个函数，函数中包含计算到现在为止的函数值和目前循环次数，在函数内照题意计算函数值即可，注意函数类型，最后输出请保留两位小数。
## 代码实现
```cpp
#include<bits/stdc++.h> 
using namespace std;
int n;
double x;
double akm(double x,int n){
	if(n==1)
	  return sqrt(1.0+x);
	return sqrt(n+akm(x,n-1));
}
int main(){
	cin>>x>>n;
	cout<<fixed<<setprecision(2)<<akm(x,n);
	return 0;
}
```


---

## 作者：Daidly (赞：3)

看到有相同的结构，我们可以想到运用递归求解。

注意递归函数的界限，当 $i=1$ 时，返回 $\sqrt{1+x}$。

- 要求保留两位小数，可以用到 `cout<<fixed<<setprecision(x)<<a<<endl;`，意思是输出 $a$，保留 $x$ 位小数。

- 将 $x,n$ 用 `double` 类型储存，方便计算小数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
double x,n;
double ans(int i){
	if(i==1)return sqrt(i+x);
	return sqrt(i+ans(i-1));
}
int main(){
	cin>>x>>n;
	cout<<fixed<<setprecision(2)<<ans(n);
    return 0;
}
```

---


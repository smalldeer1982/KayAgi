# 找第一个只出现一次的字符

## 题目描述

给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出 `no`。

## 样例 #1

### 输入

```
abcabd```

### 输出

```
c```

## 样例 #2

### 输入

```
aabbcc```

### 输出

```
no```

# 题解

## 作者：落河之秋 (赞：42)

## 大意

给出一个字符串，求出其中**第一个**只出现过**一次**的**小写**字母，若没有输出 no。

## 分析

我们看到这个题目可以~~很容易~~的想出用**桶排序**的思想。但是题目中给的是字符串，怎么用整形表示？我们想一想，有哪个数据结构可以实现不同数据类型的映射？答案是： STL 库中的 **map** ！

介于大家并不是十分了解 map ，这里简单介绍一下：我们可以把 map 看作一个可以存储任何数据形式的**动态**数组（也就是下标不做限制的数组啦），它的定义方式为：
```
map <存储进去的类型，用来表示数据的类型> 名称;
```

举个例子，在本题中我们可以建立一个 char 类型与 int 类型相互映射（照应）的 map 来进行桶排序，即定义过程为

```
map <char,int> a;
```

最后是闪亮的代码啦。

## 代码

```
#include <map> //使用 map 要调用 map 库
#include <iostream>
#include <string>

using namespace std;

map <char,int> a;
string s;

int main()
{
	cin>>s;
	
	for(int i = 0; i <=s.size(); i++) //注意字符串从 0 开始
	{
		a[s[i]]++;
	}
	for(int i = 0; i <= s.size(); i++)
	{
		if(a[s[i]] == 1)
		{
			cout<<s[i];
			return 0;
		}
	}
	cout<<"no";
	
	return 0;
}

```


---

## 作者：Evan_S (赞：41)

# B2110 找第一个只出现一次的字符

题目大意：~~如题名所述找第一个只出现一次的字符~~ 就是找出只出现一次的字符中第一个出现在字符串中的，没有就输出`no`

~~本题到此结束~~

我们枚举输入的字符串`str`每个字符（$0$ 到 $n-1$），如果出现就标记`visit[str[i] - 'a']`为`true`，然后如果枚举到一个字符他的`visit`为`true`（被访问过），就吧他的`flag`标记为`true`（标记为不可以）

然后再次枚举每个字符，如果这个字符的`flag`为`false`（只被访问过 $1$ 次）

那就直接输出，然后 `return 0`（这样就保证了是第一个）

如果没有 `flag` 为 `false` 的，就输出 `no`。

### 代码

```cpp
#include<iostream>
using namespace std;
bool visit[30];
bool flag[30];
int main()
{
	string str;
	cin >> str;
	for(int i = 0; i < str.size(); i++)
	{
		if(visit[str[i] - 'a'])
		{
			flag[str[i] - 'a'] = true;
		}
		visit[str[i] - 'a'] = true;
	}
	for(int i = 0; i < str.size(); i++)
	{
		if(!flag[str[i] - 'a'])
		{
			cout << str[i];
			return 0;
		}
	}
	cout << "no";
	return 0;
}
```


---

## 作者：Real_Create (赞：36)

字符串模拟题。

我真的不知道说什么，就直接看一个字母出现几次再遍历一次啊，所以我直接给代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[30];
int main()
{
	string st;
	cin>>st;
	for(int i=0;i<st.size();i++)//这个字母出现了几次
	{
		a[st[i]-'a']++;//转化成较小数字
	}
	for(int i=0;i<st.size();i++)
	{
		if(a[st[i]-'a']==1)//如果出现了一次
		{
			cout<<st[i];
			return 0;//直接退出程序
		}
	}
	cout<<"no";
	return 0;
}
```

---

## 作者：REAL_曼巴 (赞：27)

此题我们要知道一个桶的思想，如下。


知识：桶。要知道，我们的桶是用来装东西的，但装的东西比较特殊，是某样东西出现了几次。我们可以把这个东西的名子（也就是数字下标）作为桶的编号，如果这个东西出现一次，就把这个桶加一。但这样的缺点是浪费空间。（良心自制图片）

![](https://cdn.luogu.com.cn/upload/image_hosting/f4wovr02.png)

此题中，我们把桶的名字设为字母，但字母不能做数组下标，则我们用它的阿斯克马值来替代。这样，我们可以用桶来统计每个字母的出现次数，并找出出现一次的字母。

因为只需要个数，所以我们可以不用字符串。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[10000001];
int main(){
    char c;
    int i=0;
    while(cin>>c){//一直输到结束
        int b=c;//强制类型转换，阿斯克马值
        a[b]++;
        i++;//统计字符串长度
    }
    for(int j=1;j<=i;++j)
        if(a[j]==1){
            char c1=j;//转回来
            cout<<c1;
            return 0;
        }
    cout<<"no";
    return 0;
}

```


---

## 作者：happybob (赞：11)

这道题用 `STL` 的 `map`即可，建立两个映射，第一个是每个字符出现次数，第二个是每个字符最先出现的位置，注意 `no` 时判断条件。

代码：


```cpp
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
	map<char, int> mp, mp2;
	string s;
	ios::sync_with_stdio(false);
	cin >> s;
	int len = s.length() - 1;
	for (int i = 0; i <= len; i++)
	{
		mp[s[i]]++;
		if (mp2[s[i]])
		{
			continue;
		}
		mp2[s[i]] = i;
	}
	map<char, int>::iterator it_end = mp.end();
	int minx = 1101;
	for (map<char, int>::iterator it = mp.begin(); it != it_end; ++it)
	{
		if (it->second == 1)
		{
			minx = min(minx, mp2[it->first]);
		}
	}
	if (minx == 1101)
	{
		cout << "no\n";
		return 0;
	}
	cout << s[minx] << endl;
	return 0;
}
```


---


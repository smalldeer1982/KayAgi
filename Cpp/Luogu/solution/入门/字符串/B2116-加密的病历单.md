# 加密的病历单

## 题目描述

小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。

在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。

经过研究，小英发现了如下加密规律（括号中是一个“**原文 → 密文**”的例子）

1. 原文中所有的字符都在字母表中被循环左移了三个位置（$\text{bcd} \to \text{yza}$）

2. 逆序存储（$\text{abcd} \to \text{dcba}$）

3. 大小写反转（$\text{abXY} \to \text{ABxy}$）

现在给出一个**加密**的字符串，请你将其**解密**。

## 样例 #1

### 输入

```
GSOOWFASOq```

### 输出

```
Trvdizrrvj```

# 题解

## 作者：5k_sync_closer (赞：25)

# 前置芝士
`isupper(char c)`:判断 $c$ 是否大写字母。

`islower(char c)`:判断 $c$ 是否小写字母。

`toupper(char c)`:返回 $c$ 的大写形式。

`tolower(char c)`:返回 $c$ 的小写形式。

上面四个函数都在 `<cctype>` 中

`reverse(iterator a, iterator b)`:将 $a$ 到 $b$ 的序列翻转

在 `<algorithm>` 中
# 思路
将加密过程反过来，即为解密过程。

但题目说反了，根据样例可知，加密时应该是左移 3 位，解密时才是右移 3 位。

遍历字符串，把大写转成小写，小写转成大写。

再 `reverse` 逆序存储，最后右移 3 位输出即可。

注意 `x,y,z` 右移要特判。
# 代码
```cpp
#include <iostream>
#include <cstring>
#include <cctype>
#include <algorithm>
using namespace std;
char s[101];int l;
int main()
{
    cin >> s;l = strlen(s);
    for(int i = 0;i < l;++i)
        if(isupper(s[i])) s[i] = tolower(s[i]);
        else if(islower(s[i])) s[i] = toupper(s[i]);
    reverse(s, s + l);
    for(int i = 0;i < l;++i)
    {
        switch(s[i])
        {
            case 'x': cout << 'a';break;
            case 'X': cout << 'A';break;
            case 'y': cout << 'b';break;
            case 'Y': cout << 'B';break;
            case 'z': cout << 'c';break;
            case 'Z': cout << 'C';break;
            default : cout << char(s[i] + 3);break;
        }
    }
    return 0;
}
```


---

## 作者：_ajthreac_ (赞：19)

这个题的题面有诸多错误或描述不清的地方，在此统一说明一下：
1. 不是循环右移，而是循环左移；
2. 字符串长度不是 $50$ 而是 $60$。

好了，现在我们可以正常地做这道题了。题面说的也很简洁，我们只需要按照顺序，一步步地倒回去即可。

1. 将加密字符串大小写反转，我们只需要判断每个字符是大写还是小写，然后根据 ASCII 码中大小写字母相差 $32$ 就可以完成了。
2. 反转字符串，algorithm 库中为我们提供了一个 `reverse` 函数，它可以通过 `reverse(a,a+n)` 来翻转一个长度为 $n$ 的数组。
3. 将字母循环右移三位，我们可以直接将其对应的 ASCII 码 $+3$，但是要注意边界的处理，这里我们采用对 $26$ 取模实现（如果你不了解模运算请参照[这里](https://baike.baidu.com/item/%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/10739384?fr=aladdin)）。

核心代码如下：
```cpp
int n;
char s[100];//注意数组要开得比数据范围稍大
char Shift(char c){//将字符循环移位，我这里为了方便使用了函数
  if(c>='A'&&c<='Z')return ((c-'A'+3)+26)%26+'A';
  else return ((c-'a'+3)+26)%26+'a';
}
int main(){
  scanf("%s",s),n=strlen(s);//n 是字符串的长度
  for(int i=0;i<n;i++){
    if(s[i]>='A'&&s[i]<='Z')s[i]+=32;
    else s[i]-=32;
  }
  reverse(s,s+n);
  for(int i=0;i<n;i++)s[i]=Shift(s[i]);
  printf("%s",s);
  return 0;
}
```

---

## 作者：TensorFlow_js (赞：11)

# 题目分析
依题意直接模拟即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char dxxfz(char &ch){//将一个字符大小写反转的函数
    if('a'<=ch&&ch<='z')ch=toupper(ch);//如果是小写，变为大写
    else if('A'<=ch&&ch<='Z')ch=tolower(ch);//如果是大写，变为小写
    return ch;
}
char yyswz(char &ch){//将一个字母表中的字符循环右移3位的函数
    if('a'<=ch&&ch<='w')ch+=3;//如果在 a 与 w 之间则直接右移3位
    else if('A'<=ch&&ch<='W')ch+=3;//如果在 A 与 W 之间则直接右移3位
    else if('x'<=ch&&ch<='z')ch-=23;//如果在 x 与 z 之间则循环右移3位
    else if('X'<=ch&&ch<='Z')ch-=23;//如果在 X 与 Z 之间则循环右移3位
    return ch;
}
int main(){
    string s;cin>>s;
    transform(s.begin(), s.end(), s.begin(),dxxfz);
    reverse(s.begin(),s.end());
    transform(s.begin(), s.end(), s.begin(),yyswz);
    /* transform 函数的作用是：将某操作应用于指定范围的每个元素。 
    transform 函数有两个重载版本：
 transform(first,last,result,op);
 first 是容器的首迭代器， last 为容器的末迭代器， result 为存放结果的容器， op 为要进行操作的一元函数对象或  sturct 、 class 。
 transform(first1,last1,first2,result,binary_op); 
 first1是第一个容器的首迭代器，last1 为第一个容器的末迭代器，first2 为第二个容器的首迭代器， result 为存放结果的容器， binary_op 为要进行操作的二元函数 对象或 sturct 、 class 。
 这里我们使用的是第一个。
 */
    cout<<s;//输出解密后的字符串
    return 0;//返回0
}
```

### UPD：
2021\7\4\16:22 ：删去多余注释，解释了 `transform` 函数。

---


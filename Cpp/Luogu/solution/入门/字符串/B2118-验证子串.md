# 验证子串

## 题目描述

输入两个字符串，验证其中一个串是否为另一个串的子串。

## 说明/提示

对于 $100 \%$ 的数据，字符串长度在 $30$ 以内。

## 样例 #1

### 输入

```
abc
dddncabca```

### 输出

```
abc is substring of dddncabca```

## 样例 #2

### 输入

```
aaa
bbb```

### 输出

```
No substring```

# 题解

## 作者：我和鱼过不去 (赞：34)

验证一个字符串是否为另一个字符串的子串，我们可以用 string 库里的函数来实现。  

------------
```
string str="hello world";
```
此时我们有了一个 string 类型的变量 $str$ 。
```
str.find("hello")
```
这样可以调用 $find$ 函数来在 $str$ 中寻找是否含有子串 $\mathtt{"hello"}$ 。  
如果该函数的返回值为 ```str.npos```  (表示无效），则在 $str$ 中不存在该子串，否则存在。

------------


### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int main()
{
    cin>>a>>b;
    if(a.find(b)!=a.npos)    //如果b是a的子串 
    {
        cout<<b<<" is substring of "<<a<<endl;
    }
    else if(b.find(a)!=b.npos)   //如果a是b的子串 
    {
        cout<<a<<" is substring of "<<b<<endl;
    }
    else      //如果没有子串关系 
    {
        cout<<"No substring"<<endl;
    }
    return 0;
}
```


---

## 作者：wwz1428572008 (赞：17)

### 题目分析
可以用字符数组存字符串。
查找子串可以使用 cstring 库中的 strstr 函数，未找到时返回 NULL。
先查找 a 是否是 b 的子串，再查找 b 是否是 a 的子串。如果都不是，输出 "No substring"。
## 代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
	char a[25],b[25];
	cin>>a>>b;
	if(strstr(a,b)!=NULL)
		cout<<b<<" is substring of "<<a;
	else if(strstr(b,a)!=NULL)
		cout<<a<<" is substring of "<<b;
	else
		cout<<"No substring";
	return 0;
}
```

---

## 作者：墨忧 (赞：13)

## 题目大意
给定两个字符串，$a$ 是 $b$ 的子串时输出 (a) is substring of (b) ，若 $a$ ， $b$ 都不是对方的子串，则输出 “ No substring” 。
## 思路
由于本题数据范围较小，可以直接使用两个字符型数组存储两个字符串，依次枚举比对即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[50],b[50]; //char型数组存储两个字符串
int lena,lenb;
bool pd;
int main()
{
    cin>>a>>b;
    lena=strlen(a);
    lenb=strlen(b)//strlen函数返回char型数组的长度
    //因为不知道到底谁是谁的子串，因此需要对比两次
    for(int i=0;i<lenb;i++)
    {
        pd=true;
        for(int j=i;j<lena+i;j++) if(a[j-i]!=b[j]) pd=false;
        //对比每一位
        if(pd)//a在b中有出现，即a是b的子串
        {
            cout<<a<<" is substring of "<<b;
            return 0;
        }
    }
    for(int i=0;i<lena;i++)
    {
        pd=true;
        for(int j=i;j<lenb+i;j++) if(b[j-i]!=a[j]) pd=false;
        if(pd)
        {
            cout<<b<<" is substring of "<<a;
            return 0;
        }
    }
    if(!pd) cout<<"No substring";
    //如果都不是对方的子串
    return 0;
}
```


---

## 作者：小小小朋友 (赞：7)

## 思路

水一篇题解~

使用`string`库中的`std::find()`函数即可

此函数可以在一个字符串中寻找另一个字符串第一次出现的位置

注意`find`函数若未找到的返回值为`string::npos`

细节可见代码

## 代码

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
string a,b;
int main(){
	cin>>a>>b;
	if(b.find(a)!=string::npos) cout<<a<<" is substring of "<<b;//a是b的子串
	else if(a.find(b)!=string::npos) cout<<b<<" is substring of "<<a;//b是a的子串
	else cout<<"No substring";
	return 0;
}
```

---


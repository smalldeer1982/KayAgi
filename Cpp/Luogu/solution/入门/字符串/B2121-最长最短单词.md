# 最长最短单词

## 题目描述

输入 $1$ 行句子（不多于 $200$ 个单词，每个单词长度不超过 $100)$，只包含字母、空格、逗号和句号。单词由至少一个连续的字母构成，空格、逗号和句号都是单词间的间隔。

输出第 $1$ 个最长的单词和第 $1$ 个最短单词。

## 样例 #1

### 输入

```
I am a student,i am studying Programming language C in Peking University.```

### 输出

```
Programming
I```

# 题解

## 作者：うっせぇわ (赞：54)

读题
--
我们可以把题意简化成这样：

**输入一个字符串，输出第一个出现的最长和最短的单词。**

解题
--
相信大家拿到这题后可以很快地想出来，我们**需要发现一个单词**，在单词中间记录信息，再**对比信息**。

那么怎样判断一个单词的**开始**与**结束**？

我们阅读的时候，每个单词开始前都会有一个**标点符号或空格**提醒我们这是下一个单词，那么代码也一样，**发现一个空格或标点符号，更新数据**。

```cpp
for(int i=0;i<a.length();i++){
	if(a[i]==' '||a[i]==','||a[i]=='.'){
		更新数据；	
	}
   	单词长度++;
}
```
**如何更新数据？**

我设置了两个变量，**一个记录最长单词的结束位置，一个记录最长单词的长度**，这样输出时我们就可以用**结束位置-长度**找到**开始位置**，并且输出。**最小值也一样**。

目前基本思路已经想出来了，以下是代码：
```cpp
#include <iostream>
#include <string>
using namespace std;
string a;
int sum=0,maxx=-100,maxb,minb,minn=1000000;
int main(){
	getline(cin,a);//带空格输入
	for(int i=0;i<a.length();i++){
		if(a[i]==' '||a[i]==','||a[i]=='.'){//如果发现标点符号和空格，代表单词结束
			if(maxx<sum){//如果单词长度突破目前发现的最长长度
				maxb=i;//把最长单词的结束点更新，i就是结束点
				maxx=sum;//把最长单词的长度更新
			}
			if(minn>sum){//如果单词长度低于目前发现的最短长度
				minb=i;//更新最短单词结束点
				minn=sum;//更新最短长度
			}
			sum=0;//sum清空，以便下次操作
		}else{
			sum++;//如果是字母，长度加一
		}
	}
	for(int i=maxb-maxx/*从开始位置开始输出*/;i<maxb/*到结束位置结束*/;i++){
		cout<<a[i];
	}
	cout<<endl;
	for(int i=minb-minn;i<minb;i++){//最短单词同理
		cout<<a[i];
	}
	return 0;
}
```
[**AC记录，供参考**](https://www.luogu.com.cn/record/53288307)

---

## 作者：YclarHIM0302 (赞：15)

## **基本思路**

在这题中，我们需要得出句中最长的单词与最短的单词。因此，我们可以采用 `string 字符串` 的方式进行扫描。

首先是整体的字符串 `s` ，要使用 `getline` 进行输入，因为 字符串中**有空格**。



然后是单词的字符串 `s0` ，同时需要计数（单词长度），再与 `ans1` , `ans2` 打擂台得到最大值与最小值。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans1=0,ans2=0x3f3f3f,cnt;
string s,s1,s2,s0;
int main()
{
	getline(cin,s);//一整行输入
	for(int i=0;i<s.length();i++)
	{
		if(s[i]==' '||s[i]==','||s[i]=='.')//判定单词末尾（注意中英符号区分）
		{
			if(cnt>ans1)//最大值打擂台
			{
				s1=s0;
				ans1=cnt;
			}
			if(cnt<ans2)//最小值打擂台
			{
				s2=s0;
				ans2=cnt;
			}
			cnt=0;
			s0.clear();//清除当前单词
		}
		else
                {
                    s0+=s[i]; //一般情况（记录单词字母以及其个数）
                    cnt+=1;
                }
     	
	}
	cout<<s1<<endl<<s2<<endl;//一般输出
    return 0;
}

```


---

## 作者：Evan_S (赞：14)

# B2121 最长最短单词

我们可以用 `getline(cin, str);` 来读取整一行。

然后用 `maxstr` 来存储长度最长的字符串，用 `minstr` 来存储长度最短的字符串。

从 $0$ 开始枚举 `str` 的每个字符，判断是不是分隔符（空格、逗号和句号）

如果不是，就把这个字符加入 `word`。
否则，将 `maxstr` 换成 `word` 与 `maxstr` 之中最长的。将 `minstr` 换成 `word` 与 `minstr` 之中最短的。最后还要把 `word` 清零。

最后 `maxstr` 与 `minstr` 就行了。

```
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	string str, word = "", maxstr = "", minstr = "                                                                                                                                                                               ";
	getline(cin, str);
	for(int i = 0; i < str.size(); i++)
	{
		if(str[i] == ' ' || str[i] == ',' || str[i] == '.')
		{
			if(word.size() < minstr.size())
			{
				minstr = word;
			}
			if(word.size() > maxstr.size())
			{
				maxstr = word;
			}
			word = "";
		}
		else
		{
			word += str[i];
		}
	}
	if(word.size() < minstr.size() && word.size() != 0)
	{
		minstr = word;
	}
	if(word.size() > maxstr.size())
	{
		maxstr = word;
	}
	cout << maxstr << endl;
	cout << minstr << endl;
	return 0;
}
```


---

## 作者：wwz1428572008 (赞：12)

### 思路
每个字符逐个读入，读取到换行或文件结束时退出。先判断是不是分隔符，如果是，就更新最长单词和最短单词，并清空当前单词，否则添加当前字符到当前单词里。最后输出结果就可以了。
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
int main()
{
	string a,b,t;
	int la=0,lb=1000;
	char ch;
	while(ch=getchar())
	{
		if(ch=='\n'||ch==EOF)	break;
		if(ch==' '||ch==','||ch=='.')
		{
			if(t.length()>la)
				a=t,la=t.length();
			if(t.length()<lb)
				b=t,lb=t.length();
			t="";
			continue;
		}
		t.push_back(ch);
	}
	cout<<a<<endl<<b;
	return 0;
}

```

---

## 作者：AgrumeStly (赞：11)

### 思路

我们将空格、`,` 及 `.` 作为每个单词的结束判断条件，我们从句子的开头到结尾进行查找，记录单词长度，当找到上述条件时进行最大值与最小值的更新，并记录单词起始位置。

后清空长度，开始新一轮查找。

这种思路，就需要我们在结尾处添加一个结束条件。

坑点：  
句子中含有空格，这就说明传统的字符串输入行不通，需要我们另找方法：**gets**，gets 从标准输入设备读取字符串，以 **回车结束读取**。故可以用 gets 来读取字符串中的空格。  
使用：`gets(s)`，其中 $s$ 为 `char` 类型字符数组。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
//aks
//如果将梦想作为信仰，不放弃地追求下去，一定会梦想成真的。
inline int read() {
    char c=getchar(),f=0;int t=0;
    for (; c < '0' || c > '9'; c = getchar()) if (!(c^45)) f = 1;
    for (; c >= '0' && c<='9'; c = getchar()) t = (t<<1) + (t<<3) + (c^48);
    return f?-t:t;
}
inline void write(int x) {
    static int t[25]; int tp = 0;
    if (x == 0) return (void)(putchar('0')); else if (x < 0) putchar('-'), x = -x;
    while (x) t[tp++] = x % 10, x /= 10;
    while (tp--) putchar(t[tp] + 48);
}
const int NR = 10005;
char s[NR];
int len, maxn = -1e9, minn = 1e9, maxx, minx;//分别为：字符串长度，最大长度，最小长度，最长单词起始位置，最短单词起始位置
int main() {
    gets(s); // 使用gets进行读入
    len = strlen(s);
    s[len] = ' '; // 在句子结尾添加结束条件
    int cnt = 0;
    for (int i = 0; i <= len; i++) {
        if (s[i] != ' ' && s[i] != ',' && s[i] != '.') { // 如果检查到单词结束条件
            cnt++; // 长度记录
        } else if (cnt > 0) { // 更新数据
            if (maxn < cnt) {
                maxn = cnt;
                maxx = i - cnt;
            }
            if (minn > cnt) {
                minn = cnt;
                minx = i - cnt;
            }
            cnt = 0; // 清零！
        }
    }
    for (int i = maxx; i <= maxx + maxn - 1; i++) // 从起始位置到结束输出
        cout << s[i];
    puts("");
    for (int i = minx; i <= minx + minn - 1; i++)
        cout << s[i];
    puts("");
    return 0;
}
```

---


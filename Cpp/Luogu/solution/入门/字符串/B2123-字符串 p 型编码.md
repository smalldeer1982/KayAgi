# 字符串 p 型编码

## 题目描述

给定一个完全由数字字符（'0','1','2',…,'9'）构成的字符串 str ，请写出 str 的 p 型编码串。例如：字符串 `122344111` 可被描述为 `1个1、2个2、1个3、2个4、3个1` ，因此我们说`122344111` 的 p 型编码串为 `1122132431` ；类似的道理，编码串 `101` 可以用来描述 `1111111111` ；`00000000000` 可描述为 `11个0`，因此它的p型编码串即为 `110` ；`100200300` 可描述为 `1个1、2个 0、1个2、2个0、1个3、2个0`，因此它的 p 型编码串为 `112012201320`。

## 样例 #1

### 输入

```
122344111```

### 输出

```
1122132431```

# 题解

## 作者：Level_Down (赞：48)

简单的模拟题，简单来说就是从头到尾遍历字符串，同时累加器累加，遍历到不同的字符时将累加器和上一个字符输出，清空累加器，如此循环。

但有**两个需要注意**的点：

> 1.遍历**不能**从 $0$ 号位开始，否则 $0$ 号位的上一位是 $-1$ 位，有 RE 风险同时这样无论如何 $0$ 号位都会输出一次，WA 声一片。

> 2.遍历完之后要再把**最后一组**数据输出一遍。

没理解的看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int a = 1;//计数器，因为0号位跳过所以从1开始。 
int main()
{
	cin >> s;
	for (int i = 1; i < s.length(); i++)//不遍历0号位。 
		{
			if (s[i] != s[i - 1])
				{
					cout << a << s[i - 1];
					a = 0;
				}
			a++;	
		}
	cout << a << s[s.length() - 1];	//最后输出最后一组数据。 
	return 0;//AC！ 
}
```

希望对大家有所帮助。

---

## 作者：ssss41 (赞：10)

~~居然真的还有可以写题解的B题~~。

## 题目

[B2123](https://www.luogu.com.cn/problem/B2123)

## 思路

这题是一个小模拟，没有什么坑的点，但需要注意一下这几个点：

- 判断和前一位是否相等时，要从第二位开始判断。举个栗子，你是你们这一列的排头，你们正在愉快地排队，突然，老师喊向前对齐，别人都和他的前面的人比较，~~你和空气比较~~你和谁都比不了。同理，字符串的第一位前并没有什么东西，所以要从第二位比较。

- 循环结束后，你要再手动输出一组数据。因为最后时每个字符肯定都能和前面接上，循环时输出不了，需要最后再输出一次。

避免这两个小点，实现就十分轻而易举。

## 代码

```cpp
#include <iostream>
#include <string>
using namespace std;

string a;
char flag;
int ans = 1;//注意，这里要设成1！

int main(){
    cin >> a;
    flag = a[0];
    for (int i = 1; i < a.size(); ++ i){
        if (a[i] == a[i - 1]) {
            ans += 1;
        }
        else {
            cout << ans << flag;
            ans = 1;
            flag = a[i];
        }
    }
    cout << ans << flag << endl;//最后还要再输出
    return 0;
}
```

## 最后

如果没做够这种题，快来切爆[这个。](https://www.luogu.com.cn/problem/B2097)

# $\texttt{END}$

---

## 作者：うっせぇわ (赞：8)

读题
--
大致题意就是：一个仅用数字构成的字符串，一次输出 **每个连续出现数字的个数** 加 **本身这个数字**。

解题
--
这道题是一道模拟题，由于题目没有给出长度，那么我们可以使用字符串。

我们可以直接遍历，处理字符串的每个字符。
#### 那么怎么判断连续出现的数字的个数呢？
既然数字是连续出现的，满足此条件的数字下一个数一定和它一样。所以如果下一个字符与这个字符不一样，就说明，连续终止，需要处理数据。

我们用 `sum` 存储连续个数，每次遍历完直接输出。

那么大概意思都出来了，我们就该用代码模拟了。 **下面是代码：**
```cpp
#include <iostream>
using namespace std;
string a;
int sum;//用来记字符连续出现的次数
int main(){
	cin>>a;//直接输入字符串
	for(int i=0;i<a.length()/*a.length()表示这个字符串的长度*/;i++){
		if(a[i]!=a[i+1]){//如果下一个字符现在的字符不一样
			sum++;//sum得++，虽然不同于下一个字符但是这个字符还是得算进去的
			cout<<sum<<a[i];//输出连续出现的次数和这个数
			sum=0;
		}else{
			sum++;//否则下一个字符和这个字符一样，个数加加
		}
	}
	return 0;
}
```

[**AC记录，供参考**](https://www.luogu.com.cn/record/53309366)

---

## 作者：小小小蒟蒻 (赞：3)

# B2123 题解
## Part1 万事先分析！
[此处，直达原题](https://www.luogu.com.cn/problem/B2123)。

这道题主要考查**字符串计数**知识。

题面有些难以看懂。简化之后，其实就是一句话：**“统计一个数连续出现了几次。”**

#### 注意两个点：

- 循环时最好从第一位开始循环。如果从 $0$ 开始，第 $0$ 位就要和第 $-1$ 位比较。或者，也可以和后一位比较，但是我选择了前者。
- 一个数连续出现的次数最好在定义时就设为 $1$ ，因为循环时跳过了第一位。

## Part2 直接上代码！
不懂的可以参考注释理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot = 1, len; //tot统计这个数连续出现的次数，len为字符串str的长度
string str; //str为输入的数
char now; //现在正在统计的数
int main(){
	cin >> str;
	now = str[0]; //先统计第一位的数
	len = str.size(); //len是所输入字符串的长度
	for(int i = 1;i < len;i++){ //逐个比较。i本来应该从0开始，但这里要从1开始，因为要比较这一位与上一位
		if(str[i - 1] == str[i]) //如果前后相同
			tot++; //这个数连续出现的次数增加
		else{ //前后不相同时
			printf("%d%c", tot, now); //这个连续出现的数已经截止于此了。按照要求输出它出现的次数和它
			tot = 1; //将tot重置
			now = str[i]; //从这一位开始重新统计
		}
	}
	printf("%d%c", tot, now); //输出最后连续出现的数出现的次数与本身
	return 0;
}
```

---

## 作者：Forever1507 (赞：3)

简单入门题，即依次输出给定串中连续的相同部分的个数及值。

遍历字符串，相同字符累加，不同输出计数器及值并将计数器清空，直到遍历结束。

需要注意的几个点：
- **最好不要从第 $0$ 位开始遍历**，否则最好用变量另存当前连续相同数列的数值。
- 答案最好**边做边输出**，丢进 `string` 里面最后一起输出会莫名 `WA` 掉一个点。
- 最后一次输出要补上，两种策略，要么在原串末尾补一个奇奇怪怪的字符或者循环结束后再输出一次。

具体细节详见代码;
```cpp
#include<bits/stdc++.h>
using namespace std;
string s; 
int main(){
	cin>>s;
	int now=s[0]-'0',cnt=1;//不从第零位开始，初始值有改动。
	for(int i=1;i<s.size();i++){
		if(s[i]-'0'==now){
			cnt++;//相同
		}
		else{
			cout<<cnt<<now;//不同，先输出再重置
			now=s[i]-'0';
			cnt=1;
		}
	}
	cout<<cnt<<now;//最后一次输出
	return 0;
}

```


---

## 作者：5k_sync_closer (赞：2)

这题和[B2097 最长平台](https://www.luogu.com.cn/problem/B2097)异曲同工
# 思路
从**第二位**开始枚举字符串，判断能否和前一位借上。

为什么不从第一位开始呢？因为第一位没有前一位。

如果能接上，记录当前的"平台"的长度。

否则就输出当前的答案，重置当前的字符和长度，接着往下找。

注意最后的"平台"的后面没有能和这个平台接不上的字符，所以要补一下。
# 代码
```cpp
#include <iostream>
#include <string>
using namespace std;
string s;char c;int n = 1;
int main()
{
    cin >> s;c = s[0]; //记录当前字符
    for(int i = 1;i < s.length();++i) //从第二位开始
    {
        if(s[i] == s[i - 1]) ++n; //能接上
        else cout << n << c, n = 1, c = s[i]; //接不上，重置
    }
    cout << n << c; //补最后的输出
    return 0;
}
```


---

## 作者：Chtholly_L (赞：1)

### update：

修复了一点点小错误。

感谢@[拿铁Yester](https://www.luogu.com.cn/user/420129)提出的建议

---

看了题解区这么多大佬的题解，本蒟蒻深感自愧不如。在这一道红题上本蒟蒻竟然卡了这么长时间，可谁知只需要最朴素的做法即可。

---

- 鄙人的思路是将字符串的每一位都与前一位相比较，如果相同就将个数累加，如果不相同就输出它前一个字符的个数与字符，再将个数变回一。注意这里，为什么要变回一而不是变回零？因为如果出现了不相同的数字，就要重新计数，而重新计数还包括了新出现的这个数它本身，其实就相当于将计数器归零，再自增。

- 还有一点，其他的大佬也都说了，这里鄙人再提一嘴，也就是遍历字符串时要对第一位进行一个特判，只将计数器自增，不做其他操作。因为第一位前面没有字符了，如果强行比较会导致越界。

---

其实这是很简单的一道题，直接上代码。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

int main(){
    string s;
    int ans=0;  
    cin>>s;
    for(int i=0;i<s.size();i++){
        if(i==0||s[i]==s[i-1]){  // 对第一个进行特判以及对连续的字符进行计数
            ans++;
            continue;
        }
        if(s[i]!=s[i-1]){  // 如果变化了
            cout<<ans<<s[i-1];  //输出变化前的个数及字符
            ans=1;
        }
    }
    cout<<endl;
    return 0;
}
```

还有一点，大家看我的代码里第九行，为什么我将计数器赋值为零，不是说赋值为一吗？我在前文中说过，赋值为一就相当于先赋值为零，再自增，而你再看我代码里的第十三行，对第一个字符也进行了自增操作，这里就说明在遍历第一个字符时已经将计数器加一了，所以不用在一开始就赋值为一。

---


# 连续出现的字符

## 题目描述

给定一个字符串，在字符串中寻找第一个连续出现次数不低于 $k$ 次的字符。

## 说明/提示

$1\leq k\leq1000$，字符串长度不超过 $1000$。

## 样例 #1

### 输入

```
3
abcccaaab```

### 输出

```
c```

# 题解

## 作者：Liweiang (赞：46)

### 思路：
首先输入字符串，再遍历整个数组，如果一个字符与前一个字符相同，计数器 +1 ，如果计数器等于 k ，直接输出这个字符，如果不相同，计数器归 1 .
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1001]; //用char类型存储字符串
int main()
{
	int n,cnt=1;//定义计数器
	cin>>n>>a;
	for(int i=1;i<=strlen(a);i++)//遍历整个数组
	{
		cin>>a[i];
		if(a[i]==a[i-1]) cnt++;//如果与前一个字符相同，计数器+1
		else cnt=1;//否则归1
		if(cnt==n) //找到了
		{
			cout<<a[i];
			return 0;
		}
	}
	cout<<"No";
	return 0;
}
```


---

## 作者：Daidly (赞：9)

考虑用一个变量 `num` 保存当前字符连续出现个数，初始值为 $1$。

当 $a_i=a_{i-1}$ 时，`num++`。

当 $num\ge k$ 时，输出当前字符，结束程序。

若当前字符已不连续，则 `num` 变为初始值。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 1005
int k,num=1;
string a;
int main(){
	cin>>k>>a;
	for(int i=1;i<a.length();++i){
		if(a[i]==a[i-1]){
			num++;
			if(num>=k){cout<<a[i];return 0;}
		}else num=1;
	}puts("No");
	return 0;
}
```

---

## 作者：rui_er (赞：2)

我们使用 C 风格的字符数组存储字符串（本文中下标从 $0$ 开始）。C 语言中提供了函数 `strlen()` 可以获得字符串的长度，假设长度为 $n$。

我们用一个变量 $cnt$ 记录当前连续字母个数，先将 $cnt$ 置为 $1$ 表示统计了第 $0$ 个字符，从第 $1$ 个字符向后枚举到 $n-1$，每次判断当前字符是否与上一个字符相同，如果相同，将 $cnt$ 自增 $1$，判断是否有 $cnt\ge k$，满足的话直接输出当前字符即可；否则将 $cnt$ 重新置为 $1$，表示统计新的字母。

如果字符串整体扫过一遍，没有得到答案，就是无解，输出 `No`。

参考代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
using namespace std;
typedef long long ll;
const int N = 1e3+5;

int n, k, cnt; char s[N];
template<typename T> void chkmin(T &x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T &x, T y) {if(x < y) x = y;}

int main() {
	scanf("%d%s", &k, s);
	n = strlen(s);
	cnt = 1;
	rep(i, 1, n-1) {
		if(s[i] == s[i-1]) {
			++cnt;
			if(cnt >= k) return putchar(s[i])&0;
		}
		else cnt = 1;
	}
	puts("No");
	return 0;
}
```

---

## 作者：happybob (赞：1)

本题的思路是读入字符串，遍历一遍，如果当前字符与前一个相同，计数器加一，判断计数器是否大于等于 `k`，是就输出。

代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	int k;
	cin >> k;
	string s;
	cin >> s;
	char x = s.front();
	int len = s.length() - 1, cnt = 1;
	for (int i = 1; i <= len; i++)
	{
		if (s[i] == x)
		{
			cnt++;
		}
		if (cnt >= k)
		{
			cout << s[i] << endl;
			return 0;
		}
		if (s[i] != x)
		{
			x = s[i];
			cnt = 1;
		}
	}
	if (cnt >= k)
	{
		cout << s.back() << endl;
	}
	else
	{
		cout << "No\n";
	}
	return 0;
}
```


---

## 作者：AmaZingFantasy (赞：1)


可以循环访问字符串。


每次判断从这一位开始，是否有 $k$ 位连续字符。若有，输出这个字符；若没有，继续寻找。


若到最后依然没有合适的字符，输出 $\texttt{No}$ 。

代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main(){
    int k;
    cin>>k;
    char arr[1005];
    cin>>arr;
    int len=(int)strlen(arr);
    bool lianxu_zifu=false;
    for(int i=0;i<len-k;i++){
        char zifu=arr[i];
        bool lianxu=true;
        for(int j=i;j<i+k;j++){//是否有k位连续字符。
            if(arr[j] != zifu){//若不为连续字符，继续寻找。
                lianxu=false;
                break;
            }
        }
        if(lianxu==true){//若找到了，输出这个字符，程序运行结束。
            cout<<zifu;
            return 0;
        }
    }
    cout<<"No";//若依然没有连续字符，输出No。
    return 0;
}
```




---


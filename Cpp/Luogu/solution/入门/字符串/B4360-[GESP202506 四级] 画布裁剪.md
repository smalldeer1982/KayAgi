# [GESP202506 四级] 画布裁剪

## 题目描述

小 A 在高为 $h$ 宽为 $w$ 的矩形画布上绘制了一幅画。由于画布边缘留白太多，小 A 想适当地裁剪画布，只保留画的主体。具体来说，画布可以视为 $h$ 行 $w$ 列的字符矩阵，其中的字符均为 ASCII 码位于 $33 \sim 126$ 之间的可见字符，小 A 只保留画布中由第 $x_1$ 行到第 $x_2$ 行、第 $y_1$ 列到第 $y_2$ 列构成的子矩阵。

小 A 将画布交给了你，你能帮他完成画布的裁剪吗？

## 说明/提示

对于所有测试点，保证 $1 \leq h, w \leq 100$，$1 \leq x_1 \leq x_2 \leq h$，$1 \leq y_1 \leq y_2 \leq w$。


## 样例 #1

### 输入

```
3 5
2 2 2 4
.....
.>_<.
.....```

### 输出

```
>_<```

## 样例 #2

### 输入

```
5 5
1 2 3 4
AbCdE
fGhIk
LmNoP
qRsTu
VwXyZ```

### 输出

```
Cd
hI```

# 题解

## 作者：chen_zhe (赞：4)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

---

由于画布是一个矩形的字符矩阵，我们可以使用一个字符串数组 `string s[105];` 来存储它。我们的目标是只输出由第 $x_1$ 行到第 $x_2$ 行、第 $y_1$ 列到第 $y_2$ 列构成的这个子矩阵。因为我们的数组行号已经和题目保持了一致，所以我们可以直接用一个循环从 $x_1$ 遍历到 $x_2$，来处理每一行。

在 C++ 中，字符串里的字符位置是固定的，总是从 $0$ 开始的。所以，题目中提到的“第 $j$ 列”，实际上对应的是字符串里的第 $j-1$ 个字符。因此，当我们想取出第 $i$ 行第 $j$ 列的字符时，对应的代码就是 `s[i][j-1]`。

```cpp
for (int i = x1; i <= x2; ++i) {
    for (int j = y1; j <= y2; ++j)
        cout << s[i][j - 1];
    cout << endl;
}

```

---


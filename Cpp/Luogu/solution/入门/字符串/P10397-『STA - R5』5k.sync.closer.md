# 『STA - R5』5k.sync.closer

## 题目描述

给定一条 [`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句，输出其操作的文件名称。

形式化地，[`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句都应该恰好是

```cpp
std::freopen("<title>","<mode>",<stream>);
```

其中 `<title>` 为其操作的文件名称。其至少包含一个字符，并且只可能包含下列几种字符：
- 大写英文字符；
- 小写英文字符；
- 阿拉伯数字；
- 英文半角句点 `.`。

`<mode>` 为文件访问标记，其只可能为 `r`、`w`、`a` 中的一种。`<stream>` 为文件流，其只可能为 `stdin`、`stdout`、`stderr` 中的一种。
	
你需要回答 $T$ 次询问。

## 说明/提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据：

- $1 \le T \le 1000$。
- 每条语句的长度均不超过 $1000$。

具体部分分分配如下：

- Subtask 1 (30pts)：保证文件名为 `5k.sync.closer`。
- Subtask 2 (30pts)：保证文件名长度为 $1$。
- Subtask 3 (40pts)：无特殊限制。

## 样例 #1

### 输入

```
9
std::freopen("5k.sync.closer","r",stdin);
std::freopen("5k.sync.closer","r",stdout);
std::freopen("5k.sync.closer","r",stderr);
std::freopen("5k.sync.closer","w",stdin);
std::freopen("5k.sync.closer","w",stdout);
std::freopen("5k.sync.closer","w",stderr);
std::freopen("5k.sync.closer","a",stdin);
std::freopen("5k.sync.closer","a",stdout);
std::freopen("5k.sync.closer","a",stderr);
```

### 输出

```
5k.sync.closer
5k.sync.closer
5k.sync.closer
5k.sync.closer
5k.sync.closer
5k.sync.closer
5k.sync.closer
5k.sync.closer
5k.sync.closer
```

# 题解

## 作者：yueyan_WZF (赞：14)

[这道题](https://www.luogu.com.cn/problem/P10397)也是非常 *nice*

这篇题解希望也能帮助像我一样的*蒟蒻*

------------
### **题意：**

首先，这道题让我们输出操作的文件名称。通过阅读上面的题目，我们发现，这不就是让我们输出第一个双引号里面的吗（~~难怪是道红题~~）

知道这些就好做了。

### **构建程序：**

这道题输入的是一个个字符串，我们通过遍历这个字符串，找到第一个上引号开始输出，一直输出到第一个下引号就停止。**注意，千万别把引号也输出了。**

### **AC code：**
```cpp
#include<bits/stdc++.h>
using namespace std;	
string a;
int main(){
	int n;
	cin>>n;
	while(n--){
		cin>>a;
		for(int i=0;i<a.size();i++){
			if(a[i]=='"'){
				i++;
				while(a[i]!='"'){
					cout<<a[i];//防止输出多余引号
					i++;
				}
				cout<<endl;
				break;
			}
		}
	}
	
}
```


------------
制作不易，不喜勿喷

---

## 作者：2huk (赞：8)

### 题意

给你一条 `freopen` 的语句，输出其操作的文件名称。形式为：

```cpp
std::freopen("<title>","<mode>",<stream>);
```

### 题解

我们需要确定答案在字符串中的起始和终止位置。

数一数文件名的起始位置。发现这是一个定值。用一只手数不过来，但是用两只手就可以了。不难发现起始位置是第 $13$ 个。因为字符串从 $0$ 开始所以是 $14$。

从这个位置开始往后截取答案。思考什么时候终止。

你会发现从这个起始位置出发，直到第一个双引号之前的都是答案的部分。所以写个循环判断是否是双引号，是的话就结束，不是的话计入答案继续计算。

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    int T;
    cin >> T;
    while (T -- ) {
        string s, res = "";
        cin >> s;
        for (int i = 14; s[i] != '\"'; ++ i ) res += s[i];
        cout << res << '\n';
    }
    return 0;
}
```

---

## 作者：jijidawang (赞：8)

只需要提取出第一个双引号包裹的字符串即可 .

由于 C 语言有函数 `strchr` 可以完成找某个字符在字符串的第一次出现，而第一个引号前面的字符数量是恒定的，所以只需要先删掉一个定长的前缀，然后使用 `strchr` 函数计算第二个引号的位置，设为 `\0` 后输出即可 .

Code：
```c
#include <stdio.h>
#include <string.h>
char str[3333];
int main()
{
	int T; scanf("%d", &T);
	while (T--)
	{
		scanf("%s", str);
		char* suf = str + 14;
		*strchr(suf, '"') = '\0';
		puts(suf);
	}
	return 0;
}
```

CodeGolf Code (Perl, 34B)：
```perl
<>=~/"([^"]*)/,print$1.$/for 1..<>
```

---

## 作者：_Star_Universe_ (赞：6)

## [题目传送门](https://www.luogu.com.cn/problem/P10397)

~~很简单的入门题。~~
### 题目思路分析
注意本题共有 $t$ 组数据。

我们可以观察一下输入的每一个字符串 $s$，文件名必定从第 $15$ 位开始，然后到下一个引号之前都是这个字符串中的文件名部分。

所以循环就从第 $15$ 个字符对应下标 $s_{14}$ 开始进行，循环里判断一下如果 $s_i$ 不是引号就把这个字符加入存文件名的字符串 $c$，否则就跳出循环。

提醒大家一下输出完文件名不要忘记初始化 $c$ 哦，不然到最后输出会非常长！

总结一下，本题就是一个用循环嵌套和双分支语句实现的语法题，很简单，建议自己写。

### 代码实现
```c
#include<bits/stdc++.h>
using namespace std;

int main(){
	string s,c="";
	int t;
	cin>>t;
	while(t--){//多组数据
		cin>>s;
		for(int j=14;11111;j++){//从第十五个字符开始
			char k=s[j];
			if(k=='\"'){//如果遇到引号就跳出
				break;
			}
			else{//否则就存入字符串
				c+=k;
			}
		}
		cout<<c<<endl;
		c="";//下一轮循环之前的初始化
	}
	return 0;
}
```
提交记录：[点这里查看](https://www.luogu.com.cn/record/157728560)。

各位大佬点个赞再走吧！

---

## 作者：Barryb (赞：6)

# 思路
这题就是输入一个字符串，输出第十四位到文件名的引号前面的即可，因为前十三位是固定输入的。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		string a;
		cin>>a;
		for(int x=14;x<a.size();x++)
		{
			if(a[x]!='"') cout<<a[x];
			else break;
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：5)

题目传送门：[P10397 『STA - R5』5k.sync.closer](https://www.luogu.com.cn/problem/P10397)

### 题意分析
`std::freopen` 语句都应该恰好是
```
std::freopen("<title>","<mode>",<stream>);
```

其中 `<title>` 为其操作的文件名称。

我们可以看出，在 `<title>` 前有14个字符，那么我们在输出时就可以从第14位开始输出；而 `<title>` 结束在 `"`前，那么我们加一个判断字符是否为 `"` 的代码就可以了。

### AC代码
```cpp
#include<iostream>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){//多测
        string s;
        cin>>s;
        for(int i=14;s[i]!='"';i++)//核心部分
        	cout<<s[i];
		cout<<'\n';//与“endl”是一个意思
    }
    return 0;//好习惯
}
```
感谢（鞠躬）

---

## 作者：xiewendongTony (赞：4)

## 题目大意
输入 $T$ 个字符串，表示 `std::freopen`，输出操作的文件名。
## 思路
要求 `std::freopen` 操作的文件名，就是求 `std::freopen("<title>","<mode>",<stream>);` 中的“`<title>`”，既字符串中第 $1$ 个 `"` 和第 $2$ 个 `"` 之间的那串字符。
## 实现
- 边输入边输出使用内存更少。
- 查找字符可以使用 `find` 函数实现。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int i=1;i<=t;i++){
        string str;
        cin>>str;
        for(int j=str.find('"')+1;str[j]!='"';j++)
            cout<<str[j];
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：dlzlj_2010 (赞：4)

题目很简单，直接截取第一个引号到第二个引号之间的字符串即可。
## 正常 C++ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

int main(){
	int T;
	cin>>T;
	while(T--){
		string s;cin>>s;
		int f=0;//是否在前两个引号之间
		for(int i=0;i<s.size();i++){
			if(s[i]=='\"'&&f==0){//第一个引号
				f=1;
                continue;
			}
			else if(s[i]=='\"'&&f==1){//到了第二个引号
				break;
			}
			if(f)cout<<s[i];
		}
		puts("");
	}
	return 0;
}
```
## 极简 python 压行代码：
```python
for _ in range(int(input())):print(input().split("\"")[1])
```
现在对上面的 python 代码进行解释：
- `for _ in range(int(input())):` 理论上 python 可以将输入不赋给变量直接使用，这里为了压缩码量直接使用。
- `print(input().split("\"")[1])` split 函数返回以参数为分隔符分割的列表，因为要截取第一至二个引号之间的内容，所以输出的是列表的第二项，也就是下标为 $1$ 的位置。

---

## 作者：lflby (赞：4)

# 思路

这道题只需要输入一个字符串

然后用一个循环确定第一个 $"$ 的位置

让后再用一个循环输出到第二个 $"$ 的位置

最后就可以 break 了

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int T;
	cin>>T;
	while (T--)
	{
		string s;
		cin>>s;
		for (int i = 0; i < s.size(); i++)
		{
			if (s[i]=='"')
			{
				i++;
				while (s[i]!='"')
				{
					cout<<s[i++];
				}
				break;
			}
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：3)

一道十分简单的题。

我们观察发现，```std::freopen``` 语句前必定会有 ```std::freopen("```， 而它以后一直到下一个引号就是文件名，可以用 while 循环找出。

**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int main(){
    int t;
    cin >> t;
    while(t --){
        char a = 34;//引号的ASCLL码
        string ans;
        cin >> s;
        int i = 14;//std::freopen(" 长15个字符，而字符串是从0开始的，要减1
        while(s[i] != a){
            ans += s[i];
            i ++;
        }
        cout << ans << "\n";
    }
    return 0;
}
```

---

## 作者：Xlon_WU (赞：3)

暴力模拟即可，找到第一个和第二个 `"`（双引号）字符，输出中间的内容就行了。

**注意**：

1. `"` 在使用时需要转义，写成 `\"`。

2. 维护下标注意细节。

```
#include <iostream>
#define ll long long
using namespace std;
int n;
string s; 
int main(){
	ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    while(n--){
    	cin>>s;
    	int i=0;
    	for(;s[i]!='\"';i++);  // " 转义成 \"
    	i++;  //因为这时的 i 其实是第一个双引号的下标，所以要自增一下跳到真正输出的内容部分
    	for(;s[i]!='\"';i++)cout<<s[i];
    	cout<<endl;
	}
	return 0;
}
```

---

## 作者：Fiendish (赞：3)

简单题。

对于每一组询问，先把字符串读入。因为 `std::freopen("` 长为 $14$，所以如果下标从 $0$ 开始，那么文件名的第一个字符下标就是 $14$，于是从第 $14$ 个字符开始遍历字符串。由于文件名中不包含引号，所以遍历到引号就停止。遍历的同时输出即可。

```cpp
#include<iostream>
#include<string>
using namespace std;
string s;
int T;
int main(){
	cin>>T;
	while(T--){
		cin>>s;//输入字符串
		for(int i=14/*从第14个开始*/;s[i]!='"'/*遍历到引号停止*/;i++) cout<<s[i];
		cout<<'\n';
	}
}
```

---

## 作者：C202301 (赞：2)

#### 题意简述
有 $T$ 个询问，对于每次询问，给定一个 ```freopen``` 语句，输出其操作的文件名。
#### 解题思路
每次询问只要摘取 ```<title>``` 部分即可，别的不用管，具体实现看代码。
#### 代码实现
```
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int T;
    cin>>T;//输入数据组数
    for(int i=1;i<=T;i++)
    {
    	string fre,ans="";
    	cin>>fre;//输入freopen语句
    	bool k=0;//表示是否要取，0表示不用，1表示要
    	for(int i=0;i<fre.size();i++)
    	{
    		if(fre[i]=='"')//可以发现，title部分从一个"开始，从一个"结束
    		{
    			if(k==0)//第一次出现"
    			k=1;//开始记录
    			else
    			break;//第二次出现，停止记录
    			continue;
			}
			if(k==1)
			{
				ans+=fre[i];
				continue;
			}
		}
		cout<<ans<<endl;//输出
	}
	return 0;
}
```

---

## 作者：tanzexiaodezhonghao (赞：2)

## 思路
其实很简单，经过观察，可以发现要输出的是在第一个引号到第二个之间，其他没有用处。那么我们就不停的输入，并把第一个引号到第二个间的全部输出。

至于过程，我们输入字符串 $s$,再弄一个标记变量 $flag$,如果 $s_i $ 是第一个引号，就 $flag \gets 1$，从下一个开始输出。直到第二个引号，就退出循环。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	string s;
	while(cin>>s){
		int len=s.size();
		bool flag=0;
		for(int i=0;i<len;i++){
			if(s[i]=='"'&&flag==1){
				cout<<endl;
				break;
			}
			if(s[i]=='"'&&flag==0){
				flag=1;
			}
			if(flag==1&&s[i]!='"'){
				cout<<s[i];
			}
		}
	}
	return 0;
}
```

---

## 作者：Mason123456 (赞：2)

# P10397

### 前言

比赛没写这题，直接冲着 T4 去了。~~然后发现是黑题~~。

### 思路

这题需要用到**字符串**。有字符串基础的可以跳过了。

#### 字符串

`std::string` 是 `STL` 自带的字符串工具。其中有以下操作：

`std::string str`。和定义变量一样，可以定义一个名字为 `str` 的字符串。

`str[x]`。代表字符串 `str` 的第 `x` 位，注意，`std::string` 是从下表为 $0$ 开始的。

`str.size()`。表示字符串 `str` 的长度。但不过注意，`str[str.size()]` 是会 `RE` 的，因为下标是从 $0$ 开始的。

`str.substr(x, y)`。表示字符串 `str` 从第 `x` 位走 `y` 步所经过的字符串。如：`str = "123"`，`str.substr(0,2) = "12"`。

#### 解题

我们发现，每一个输入都是以 `std::freopen("` 为前缀开头，于是我们可以用 `substr` 把开头去掉。因为文件名保证不会有 `"`，所以从左到右搜索第一个 `"`，中间夹着的就是答案了。

再来看 `substr` 的写法。发现，前缀的长度永远为 $14$，于是，就从 $14$ 号位开始，走 `size - 14 - 1` 步，就去掉开头了。

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
main(){
	cin>>n;
	for(int i = 1; i <= n;i++){
		string str;
		cin>>str;
		str = str.substr(14, str.size() - 15);// 前缀的长度为 14，要走的步数就是 size - 14 - 1
		int j = 0;
		while(str[j] != '"'){
			cout<<str[j];
			j++;
		}
	}
}
```

注：为防止抄题解，这个代码是不能通过的。

---

## 作者：StarsIntoSea_SY (赞：2)

根据题意，我们只需要输出第一个引号内的内容即可，因为```std::freopen("<title>","<mode>",<stream>);```中第一个引号的位置为 14 ，所以只需要从下标为 14 的字符开始输出，直到读到引号为止。

Code:

```c
#include<string.h>
#include<iostream>
using namespace std;
string str;
int main(){
	int T;scanf("%d",&T);
	while(T--){
		cin>>str;
		int len=str.size();
		for(int i=14;i<len;++i){
			if(str[i]=='"') break;
			 cout<<str[i];
			
		}
		cout<<'\n';
	}
}
```

---

## 作者：yu1128_AKIOI (赞：2)

# 思路

按题意模拟即可。在找到字符串的第一个引号时输出下一个字符，直至下一个字符为引号时为止。

# 代码

```cpp
#include<iostream>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        string s;
        cin>>s;
        for(int i=0;i<s.length();i++){
            if(s[i]=='\"'){
                int x=i;
                while(s[x+1]!='\"'){
                    cout<<s[x+1];
                    x++;
                }
                break;
            }
        }
        cout<<endl;
    }
}
```

---

## 作者：Rookie_t (赞：1)

这是一道简单的模拟。

首先我们就手动确认要从第几位开始输出，就是第 $14$ 位，然后向右枚举，也就是右边引号，就要结束输出了。

在这中间的所有位都要输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s; 
int main(){
	cin>>t;
	while(t--){
		cin>>s;
		for(int i = 14;i<s.size();i++){
			if(s[i] != '"'){
				cout<<s[i];
			}
			else{
				break;
			}
		}
		cout<<endl;
	}	
	return 0;
} 
```

---

## 作者：sbno333 (赞：1)

这道题只需要输出 `<title>` 的值即可。

我们发现这个东西两边都是 `"`，并且是第一对双引号，因此我们只需要输出第一对双引号之间的值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		string s;
		cin>>s;
		string ans;
		ans="";
		bool fl;
		fl=0;
		for(int i=0;i<s.size();i++){
			if(s[i]=='\"'){
				if(fl){
					break;
				}
				fl=1;
			}else{
				if(fl){
					ans+=s[i];
				}
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：fried_chicken (赞：1)

# 题意

给你一个 `freopen` 命令，问你操作的是什么文件

# 分析

我们可以把每一个 `freopen` 命令（以下简称文件命令）看成一个字符串。

接下来，我们可以数一下我们操作的文件是第几个。

`std::freopen("` 这一部分是我们没用的，数一下，可以数出来这是 $13$ 个字符。所以我们遍历字符串时可以从第 $14$ 个元素开始。

后面那一段的数目不好统计，因为文件命令最后一个参数有 `stdin(length:5) stdout(length:6) stderr(length:6)`。长度不一样，不好统计，那我们换个方法。

我们可以遍历字符串，直到读到一个引号为止。如果不是引号输出当前字符就行。这样，我们就把这一部分给搞下来了。

记得双引号的判定要加上反斜杠 `'\"'`。

赛时代码：（本人用的多测函数）

```cpp
//30pts：puts("5k.sync.closer")
cin>>s;
rep(i,14,s.length()){//遍历，从第十四个元素开始
  if(s[i]=='\"')break;//判断
  cout<<s[i];//输出
}LF;//回车
```

---

## 作者：_Jocularly_ (赞：1)

按照题目输入，前半段都是一样的，直接从第十四个位置开始遍历，注意这里已经跳过了引号，我们需要的是从这个位置开始到下一个引号位置的子串，这就是这个文件的名字，直接模拟即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
int main(){
	cin >> n;
	while(n--){
		cin >> s;
		for(int i=14;i<s.size()&&s[i]!='"';i++){
			cout << s[i];
		}
		cout << endl;
	}
	return 0;
}

```

---

## 作者：LG086 (赞：1)

### 分析

每行输入一个字符串，输出文件名（第一对双引号包含的部分）。

对于每个字符串，先找到第一个双引号，由它直至第二个双引号之间的部分就是答案。若 $s_i$ 是第一个双引号，$s_j$ 是第二个双引号，那么答案 $ans$ 就是 $s_{i+1}$ 到 $s_{j-1}$ 的子串。

记得初始化 $ans$。


----------------------

### 代码

```cpp
#include<bits/stdc++.h> 
using namespace std; 
int n;
string s,ans;
int main(){
    cin>>n;
    while(n--){
        cin>>s;
        for(int i = 0;i < s.size();i ++){
            if(s[i]=='\"'){
                i++;
                while(s[i]!='\"')
                ans+=s[i],i++;
                break;
            }
        }
        cout<<ans<<endl,ans="";
    }
}
```

---

## 作者：hema5177 (赞：1)

### 思路

一道很简单的模拟题，要输出的标题处于字符串中第一对双引号中，搜索判断一下范围即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        string s;
        int sum=0,k1,k2;//k1代表标题起始下标，k2代表标题末尾下标
        cin>>s;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]=='"')
            {
                k1=i+1;//从双引号的下一位开始
                for(int j=i+1;j<s.size();j++)
                {
                    if(s[j]=='"')
                    {
                        k2=j-1;//标题不包含双引号捏
                        break;
                    }
                    sum++;//标题长度
                }
                break;
            }
        }
        for(int i=k1;i<=k2;i++) cout<<s[i];//输出标题
        cout<<endl;
    }
}
```

---

## 作者：maomao233 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10397)

形象化地，本题要求我们输出字符串 `std::freopen("<title>","<mode>",<stream>);` 中的 `<title>` 部分。

注意到 `<title>` 部分的位置恰好位于第一和第二个 `"` 之间，即 `"<title>"`。由于这个位置比较特殊，我们可以直接遍历字符串并用两个变量（例如 $l,r$）记录前两个 `"` 的下标，最后输出字符串 $s_{l+1}s_{l+2}\cdots s_{r-1}$ 即可。

当然不一定是通过 `"` 记录下标，还可以是 `(` 和 `,` 等等。

```cpp
...
signed main()
{
	int t;
	rd(t);
	while(t--)
	{
		string s;
		cin>>s;
		int l=-1,r=-1;
		for(int i=0;i<s.size();i++)
		{
			if(s[i]=='\"')
			{
				if(l==-1)
				{
					l=i;
				}
				else
				{
					r=i;
					break;
				}
			}
		}
		for(int i=l+1;i<=r-1;i++)
		{
			pc(s[i]);
		}
		hh;
	}
	return 0;
}
```

---

## 作者：ggylz49 (赞：1)

## 核心思路
核心问题：如何准确地得到操作的文件名，即题目中的 `<title>`？

我们可以使用暴力做法，读入一整行字符串，找到文件名开始处的下标。文件名前面的字符串是一定的，都是 `std::freopen("`。一共是 $14$ 个字符，最后一个字符 `"` 的下标是 $13$。换句话说，文件名第一个字符的下标就是 $14$。

接着，定义一个字符串，从这个字符开始，一直读到文件名结束字符 `"`。将中间的所有字符都加入进这个字符串。而后面的字符串就不用再管了，继续读入下一行字符串即可。注意，单独的双引号 `"` 在 C++ 中一般表示为 `\"`，而不是单独的 `"`。这个表示方式在字符类型中两种都适用。不过，在字符串 string 类型中只能使用加反斜杠的一种，以便和关键字 `""` 区分。

### 核心代码
```cpp
string s,a="";//定义字符串a存储操作文件名，记得对字符串进行初始化
cin>>s;
int j=14;//下标指针
while(s[j]!='\"')//循环成立条件：指针所指向的字符不是"
{
    a+=s[j];//加入进字符串
    j++;//指针加一
}
cout<<a<<endl;//输出结果
```
## Code
```cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        string s,a="";
        cin>>s;
        int j=14;
        while(s[j]!='\"')
        {
            a+=s[j];
            j++;
        }
        cout<<a<<endl;
    }
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：1)

一道水题，考验字符串操作。

设字符串为 $S$，我们只需找出 $S$ 中第 $1$ 和第 $2$ 个引号的位置 $p_1,p_2$，$S_{p_1+1 \ldots p_2-1}$ 便是答案。
```cpp
#include <iostream>
#include <string>
using namespace std;
int main() {
	int t;
	cin >> t;
	while (t--) {
		string s;
		cin >> s;
		int pos = s.find("\"");
		s.erase(0, pos + 1);
		// cout << s << endl;
		pos = s.find("\"");
		// cout << pos << " ";
		cout << s.substr(0, pos) << endl;
	}
}
```

---

## 作者：chenlongli (赞：1)

### 题意简述
给你一个形如```std::freopen("<title>","<mode>",<stream>);```的字符串，问```<title>```是什么
### 思路
文件名的开始位置总是为字符串的第 $15$ 个字符，我们就可以从第 $15$ 个字符开始，直到搜索到 $"$ 号的时候停止。
### code
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    for (int i=0;i<t;i++)
    {
    	string k;
    	cin>>k;
    	int s=14;
    	while(k[s]!='"')
    	{
    		cout<<k[s];
    		s=s+1;
    	}
    	cout<<endl;
	}
}
```

---

## 作者：封禁用户 (赞：1)

开火喽……

### Subtask 1：

>保证文件名为 `5k.sync.closer`。

那么只需要输出 $n$ 个，每行一个的 `5k.sync.closer` 即可，还可以顺带把样例过了。

### Subtask 2：

>保证文件名长度为 $1$。

因为格式固定，且每次的输入都只是字符串变了，所以说文件名的位置也是固定的。而文件名开始都是在字符串的第 $15$ 位（从左往右数），下标即为 $14$，输出 $s_{14}$ 即可，$s$ 代表输入的字符串。

### Subtask 3：（满分）

没有特殊限制了，前面说过文件名的开始都是在 $s_{14}$ 开始，结束时就是在遇到下一个双引号时结束，所以即可写出以下代码：

```cpp
#include <iostream>
using namespace std;

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        string s, ans;
        cin >> s;
        int j = 14; // 用 while 循环代替 for 循环。下标从 14 开始。
        while (s[j] != '"')
            ans += s[j++]; // 等价于 ans += s[j], j++;
        cout << ans << endl;
    }
}
```

完结。（本可以没有前面两个子任务的通过方法，本人闲的加上了……）

---

## 作者：xiaobeng_0912 (赞：1)

[P10397 『STA - R5』5k.sync.closer](https://www.luogu.com.cn/problem/P10397)

## 题目解法

可以看到，题目只关心 `<title>` 部分，而 `<title>` 部分前面的那个双引号为整个语句的第一个双引号，而 `<title>` 部分后面的那个双引号为整个语句的第二个双引号。于是，我们就可以输入语句后，遍历这个语句，找到第一个双引号，从它后面开始依次输出每一个字符，直到第二个双引号为止，其他的我们并不关心。这样，我们便解决了这道题。

**注意：本题为多测，并且双引号不要输出！**

---

## 作者：GXZJQ (赞：1)

# P10397 『STA - R5』5k.sync.closer 题解

## 题目大意
给定一个重定向命令，从中分离出操作的文件名。

## 题目分析
本题考查字符串的操作。

不难发现，每个重定向操作前面的部分都是一致的，均为 `std::freopen("`，所以我们不妨把这一段直接空出，然后循环判断后面的字符。由于前引号已经被空出，所以只要遇到下一个引号就可以停止循环，处理下一条输入。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s;
int main() {
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> s;
		for (int i = 14; i < s.length() - 13; i++) {
			cout << s[i];
			if (s[i + 1] == '"') break;
		}
		cout << endl;
	}
	return 0;
}

```

---


# 小书童——凯撒密码

## 题目背景

某蒟蒻迷上了 “小书童”，有一天登陆时忘记密码了（他没绑定邮箱 or 手机），于是便把问题抛给了神犇你。


## 题目描述

蒟蒻虽然忘记密码，但他还记得密码是由一个字符串组成。密码是由原文字符串（由不超过 50 个小写字母组成）中每个字母向后移动 $n$ 位形成的。`z` 的下一个字母是 `a`，如此循环。他现在找到了移动前的原文字符串及 $n$，请你求出密码。

## 说明/提示

字符串长度 $\le 50$，$1 \leq n \leq 26$。

## 样例 #1

### 输入

```
1
qwe```

### 输出

```
rxf```

# 题解

## 作者：仇哥 (赞：1131)

直接按照题目意思，利用字符操作列表达式输出即可。

代码如下：

```cpp
#include <stdio.h>
int main()
{
    char in[100]; 
    int n, j; 
    scanf("%d%s", &n, in); //读入 
    for(j = 0; in[j] != '\0'; j++)
        putchar((in[j]-'a'+n)%26+'a'); 
    //in[j]-'a':读入中对应的第几个字母的位置，比如'a'对应0，'b'对应1，'c'对应2（0开始）；
    //in[j]-'a'+n:读入中对应字母加上转移位数得到的字母的对应位置。
    //比如说'c'这个字母移动3位，就是第2个字母向右移动3个，就是第五个字母，即'f'
    //取余26是防止移动位数超过26导致炸掉
    //再加上'a'，将对应位置还原成字母，再打出来 
}
```

---

## 作者：Clare613 (赞：5)

## 思路：
按题意模拟即可，就是针对每一个字母加上 $n$ 输出即可。值得注意的是，如果超过了字母 z，那么就要再减去一个 $26$。
## code：

```cpp
#include<bits/stdc++.h>
//#define int long long
#define MOD 998244353
using namespace std;

signed main(){
	cin.tie(0)->sync_with_stdio(0);
	int x;
	string a;
	cin>>x>>a;
	for(int i=0;i<a.size();i++){
		if(int(a[i])+x>'z') cout<<char(int(a[i])+x-26);
		else cout<<char(int(a[i])+x);
	}
	return 0;
}
```

---

## 作者：PKUS_zmj (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1914)
# 思路
由于密码是小写字母，可以将每一位密码减去 `a` 的 ASCII 编码，这样就得到了该位密码在字母表中的位置（注意是从 $0$ 开始），再加上 $n$，就能求出移动后的位置。移动后可能超出字母表，所以要对 $26$ 取模。最后加回 `a` 的 ASCII 编码输出即可。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

signed main()
{
	int n;
	cin>>n;
	string s;
	cin>>s;
	for(int i=0;i<s.size();i++) cout<<(char)((s[i]-'a'+n)%26+'a');
    return 0;
}
```

---

## 作者：Chenyuze24 (赞：3)

直接模拟即可。

先输入 $n$ 和 $a$，直接后移即可，要注意，如果后移以后字符超过了 $z$，那么此字符减掉 $26$ 即可。

下面是代码。


```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;//读入
	string a;
	cin>>a;//读入字符串
	for(int i=0;i<a.size();i++){
		if( a[i]+n>'z'){//判断若ASCII码>z
			a[i]+=n-26;//减去26
		}else{
			a[i]+=n;
		}
	}
	cout<<a;输出
	return 0;必须打
}
```

---

## 作者：fjtMESSI10 (赞：2)

## 思路
这题我们可以转化为  Ascll 码来做,先遍历字符串里的每一个字母，先减去一开始的 $a$ 字母得到它是第几个字母，再加上要移动的位数，再和 $26$ 取余防止溢出，最后加上字母 $a$，这样就变成了移位后的字母的  Ascll  码值，最后全部交换完输出就行了。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
string a;
	cin>>n;
	cin>>a;
	for(int i=0;i<a.size();i++){
 a[i]=((a[i]-'a')+n)%26+('a');
	}
		for(int i=0;i<a.size();i++){
cout<<a[i];
		}
		
	return 0;
}
```

---

## 作者：yzm0325 (赞：1)

upd on 2025.6.10：改了一处笔误。

---

对于每一位直接模拟即可。

往后推 $n$ 位，就是将这个字符的 Ascll 码加上 $n$。但是有可能溢出（使得 Ascll 码大于 `z`），所以需要判断一下。

这里使用一种比较便捷的做法：先让原字符的 Ascll 码减去 `a` 的 Ascll 码，此时 `a` 到 `z` 对应 $0 \sim 25$。容易发现可以通过对 $26$ 取模的方式防止溢出。

完整计算过程为 `c2 = ((c1 - 'a' + n) % 26 + 'a')`，其中 `c2` 是密码中的字符，`c1` 是原文字符。

举个例子，如果要将 `x` 往后推 $5$ 位（$n=5$）：

- 先计算 `'x' - 'a'` 得到 $23$；
- 计算 `23 + 5` 得到 $28$，对 $26$ 取模得到 $2$；
- 计算 `2 + 'a'` 得到 $99$，赋值时转为 `char` 为字符 `c`。正确。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;
int main() {
    cin >> n >> s; // 输入
    for(int i = 0; i < s.size(); i++) // 转每一位
        cout << (char) ((s[i] - 'a' + n) % 26 + 'a'); // 注意直接输出需要转 char
    return 0;
}
```

---

## 作者：volatile (赞：1)

# 思路

对于字符串的每一位，设为 $S_i$，由于 $S_i$ 一定是小写字母，所以可以将 $S_i$ 减去字母 `a` 的 ASCII 码，求出 $S_i$ 在字母表中的位置（从 $0$ 开始），加上 $n$，就可以求出移位后的位置。由于可能超出字母表，可以将求出的结果对 $26$ 求余，确保移位后可以循环到字母表中。

求出现在的位置后，就可以加上 `a` 的 ASCII 码，输出处理后的字符。

# 代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char s[60];
int main()
{
	int n;
	cin >> n;
	scanf("%s", s);
	for (int i = 0; i < strlen(s); i++) {
		cout << char((s[i] - 'a' + n) % 26 + 'a');
	}
	return 0;
}
```

---

## 作者：chenyizhen (赞：0)

这是一道字符串的题目，较为简单…

在这里解释一下字符的运算操作，他们是根据 [ASCII 码](https://baike.baidu.com/item/ASCII/309296)中对应数值进行运算，例如字符 `a` 对应为 97，根据这个性质我们就可以将其像整数一样进行操作，详见代码。

另外补充一道题，可以当做这道题的进阶：[P1906 凯撒密码](https://www.luogu.com.cn/problem/P1906)。

---

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);	//输入优化
	string s;
	int n;
	cin>>n>>s;
	for(int i=0;i<s.length();i++){
		char ch=(s[i]-'a'+n)%26+'a';
		cout<<ch;
	}
		
	return 0;
}
```

---

## 作者：Ashankamiko (赞：0)

# 题目简述
### 题意
给定一个字符串，对这个字符串解密，规则如下。
- 每个字符都和原来的字符相差 $n$。
- 如果该字符的编号加上 $n$ 大于 $26$，则让编号回到 $1$。
### 思路
只需要遍历字符串，然后输出该字符加上 $n$ 的值，再让 $26$ 对这个值取模。
## [AC 代码](https://www.luogu.com.cn/record/198848543)
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;

int main() {
	cin >> n >> s;
	for (int i = 0; i < s.size(); i++) //遍历字符串
		putchar((s[i] - 'a' + n) % 26 + 'a'); //如上所述
	return 0;
}
```

---


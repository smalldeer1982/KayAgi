# 小果的键盘

## 题目背景

小果有一个只有两个键的键盘。


## 题目描述

一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 `VK` 这个字符串的时候，小果就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 `VK` 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 `VK`（只有当 `V` 和 `K` 正好相邻时，我们认为出现了 `VK`。）

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 100$。

## 样例 #1

### 输入

```
2
VK
```

### 输出

```
1```

## 样例 #2

### 输入

```
2
VV```

### 输出

```
1```

## 样例 #3

### 输入

```
1
V```

### 输出

```
0```

## 样例 #4

### 输入

```
20
VKKKKKKKKKVVVVVVVVVK```

### 输出

```
3```

## 样例 #5

### 输入

```
4
KVKV
```

### 输出

```
1
```

# 题解

## 作者：ysy666 (赞：472)

这个题无非只有四种排列情况VK  KV  KK  VV

其中，VK是符合要求的，KK和VV都能改一个字符成为VK，只有KV不可以改

先从头到尾跑一遍，把正确的VK都改为X

再跑一遍找到一个KK 或 VV就停



附上萌新代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a[102];
int main()
{
    gets(a);
    gets(a);
    int ans=0;
    for(int i=0;i<strlen(a);i++)
    {
        if(a[i]=='V' && a[i+1]=='K')
        {
            ans++;
            a[i]='X';
            a[i+1]='X';
        }
    }
    for(int i=0;i<strlen(a);i++)
    {
        if(a[i]!='X' && a[i]==a[i+1])
        {
            ans++;
            break;
        }
    }
    printf("%d",ans);
    return 0;
}
五十个测试点，AC还是很好看的→-→
```

---

## 作者：浩哥_Er中 (赞：131)

#目                  前                      最                   简       便                   C++

这道题就是找两种子串

- “VK”

- “VV”或“KK”

第一个我们要判断；

第二个只要判断相邻两个字符相同就行了。

##注意：要用分类讨论的方法，不能两个两种条件一起判断，我就是这里坑了，费了我好长的时间。

####\*大家看代码理解吧。\*

```cpp
      #include<iostream>
      using namespace std; //头文件激活；
      int main()
      {
          int n,ans=0,x;//ans记达到条件的数量，要记得清零；
          string s;//我们伟大的字符串；
          cin>>n;//n是s的长度。
          cin>>s;//因为我们要输入的字符串里只有“V”和“K"，所以用cin就行了；
          for(x=0;x<n-1;x++)//字符串的第一位都在是s[0]上，我们就从0开始判断到n-1，0位上有了就可以到s的长度减一。
          {
              if (s[x]=='V'&&s[x+1]=='K') {ans++;s[x]='v';s[x+1]='k';}//s[x]和s[x+1]是两相邻的字符。如果条件符合，ans++，把这两的字符标记成以符合，注意，两个标记得不能相同。
          }
          for(x=0;x<n-1;x++)//第二步；
          if (s[x+1]==s[x]) {ans++;cout<<ans;return 0;}//如果相邻两个相同，也就是“VV”或“KK”，就ans加一，输出答案，结束程序。
          cout<<ans;//如果没有相邻相同的就输出原来的数。
          return 0;//就这样，愉快的结束程序。
      }
是不是很简单。
```

---

## 作者：Charged_Charge (赞：2)

# 洛谷 P3741
## 题目大意：
给定一个长度为 $n$ 的字符串，求出这个字符串包含多少个 `VK` 子串，注意：可以至多对这个字符串进行一次修改，使它至多增加一个 `VK` 子串。
## 解题思路：
首先，我们遍历一遍这个字符串，先把原本就有的 `VK` 子串加上。第二步，再遍历一遍字符串，判断，如果有出现 `VV` 或 `KK` 子串，那么对它进行一次操作，使字符串多一个 `VK` 字串。注意：下标到 $n-1$ 就要结束，因为要判断 $s_{i+1}$，会越界。另外，要把一开始就有的 `VK` 子串统计后就修改掉，以免重复计算。至于修改成啥都行，只要不修改成 `V` 或 `K` 就可以了。
## AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans;
bool ok = true;
string s;
int main() {
	cin >> n >> s;

	for (int i = 0; i < n - 1; i++) {
		if (s[i] == 'V' && s[i + 1] == 'K') {
			ans++;
			s[i] = 'A';
			s[i + 1] = 'C';
		}
	}

	for (int i = 0; i < n - 1; i++) {
		if (s[i] == s[i + 1]) {
			ans++;
			break;
		}
	}

	cout << ans;
	return 0;
}
```

---

## 作者：_luogu_huowenshuo_ (赞：2)

### 解题思路（100字）

给定长度为 $ n $ 的字符串 $ s $，$s$ 仅含 `V` 和 `K`，通过最多改变一个字符，最大化相邻 `VK` 出现次数。

遍历字符串，统计初始 `VK` 次数。对于每个位置，尝试将其改为 `V` 或 `K`，重新统计 `VK` 次数，取最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
string s;
int calc(string t){
	int c=0;
	for(int i=0;i<n-1;i++)
		if(t[i]=='V'&&t[i+1]=='K')c++;
	return c;
}
int main(){
	cin>>n>>s;
	ans=calc(s);
	for(int i=0;i<n;i++){
		string t=s;
		t[i]='V';
		ans=max(ans,calc(t));
		t[i]='K';
		ans=max(ans,calc(t));
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Aurelia_Veil (赞：2)

# 题解：P3741 小果的键盘

这是一道简单的分类讨论。

首先，我们可以分别列出 $\texttt{V}$ 和 $\texttt{K}$ 的所有情况：$\texttt{VV}$、$\texttt{VK}$、$\texttt{KV}$、$\texttt{KK}$。

注意到只有 $\texttt{VK}$ 满足条件，$\texttt{VV}$ 和 $\texttt{KK}$ 可以经过一次修改使其满足条件，$\texttt{KV}$ 无法经过或不经过一次修改使其能够满足条件。而且每一个字符串只能修改一次，因此 $\texttt{VV}$ 和 $\texttt{KK}$ 中需要找到一个就不用再找了。

具体来说，我们先将所有 $\texttt{VK}$ 找出、统计答案并标记，再在所有**没标记的** $\texttt{VV}$ 和 $\texttt{KK}$ 找出一个并统计答案（如果没有找到则不统计），最后输出。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=111;
int v[N];
int main(){
	scanf("%*d");
	string a;
	cin>>a;
	int ans=0;
	for(int i=0;i<a.length()-1;i++){
		if(a[i]=='V'&&a[i+1]=='K'){
			ans++;
			v[i]=1;
			v[i+1]=1;
		}
	}
	for(int i=0;i<a.length()-1;i++){
		if(v[i]+v[i+1]==0&a[i]=='V'&&a[i+1]=='V'){
			ans++;
			break;
		}
		if(v[i]+v[i+1]==0&&a[i]=='K'&&a[i+1]=='K'){
			ans++;
			break;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：ClaudeHsu (赞：1)

## 思路

其实还是很简单的捏。

我们先对字符串跑一遍循环，看看里面现有几个 `VK`，如果发现一个，就将这两个字符全部记为空格，并且计入一下答案。

然后我们再跑一遍字符串，记录改的那两个字符。

此时，如果这两个字符均没被改变为空格，而且两个字符一样，即可修改其中一个，而使得变成新的 `VK`。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
char a[105];
int n,ans;
int main(){
    cin>>n>>a;
    for(int i=0;i<strlen(a);i++){
        if(a[i]=='V'&&a[i+1]=='K'){
            ans++;
            a[i]=' ';
            a[i+1]=' ';
        }
    }
    for(int i=0;i<strlen(a);i++){
        if(a[i]!=' '&&a[i]==a[i+1]){
            ans++;
            break;
        }
    }
    cout<<ans;
}
```

---

## 作者：Like_Amao (赞：1)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P3741)

**思路**

不难发现，序列只会由 ``VK``、``VV``、``KK`` 以及 ``KV`` 这四个子序列组成。

所以，我们就可以先统计出序列中 ``VK`` 的数量，加在答案里，随后把 ``VK`` 序列标记为 ``1``，然后，再在序列里寻找是否有未被标记过的 ``VV`` 或 ``KK`` 存在，之所以不找 ``KV``，是因为 ``KV`` 无论是哪一个字母变化，也无法变成 ``VK``，最后，如果序列中有未被标记的 ``VV`` 或 ``KK``，就拿序列中 ``VK`` 的数量加上一，这就是我们要的答案。

**代码**


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
	cin.tie(0)->ios::sync_with_stdio(0);
	int n,ans=0;
	string str;
	cin>>n;
	cin>>str;
	for(int i=0;i<=n-1;i++)
	{
		if(str[i]=='V' and str[i+1]=='K')
		{
			ans++;
			str[i]='1';
			str[i+1]='1';
		}
	}
	for(int i=0;i<=n-1;i++)
	{
		if(str[i]!='1' and str[i]==str[i+1])
		{
			ans++;
			break; 
		}
	}
	cout<<ans;
	return 0;
}
```

---


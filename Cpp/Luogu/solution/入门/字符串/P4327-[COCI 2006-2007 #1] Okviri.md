# [COCI 2006/2007 #1] Okviri

## 题目描述

“彼得·潘框架”是一种装饰文字，每一个字母都是由一个菱形框架。一个彼得·潘框架看起来像这样（`x` 是字母，`#` 是框架）：
```
..#..
.#.#.
#.X.#
.#.#.
..#..
```
然而，只是一个框架会有些沉闷，所以我们每遇到三个字母会把第三个字母用温迪框架把它框起来。温迪框架看起来像这样：
```
..*..
.*.*.
*.X.*
.*.*.
..*..
```
当温迪和彼得·潘的框架重叠时，温迪框架覆盖在上面。 （见样例 3）

## 样例 #1

### 输入

```
A```

### 输出

```
..#..
.#.#.
#.A.#
.#.#.
..#..```

## 样例 #2

### 输入

```
DOG```

### 输出

```
..#...#...*..
.#.#.#.#.*.*.
#.D.#.O.*.G.*
.#.#.#.#.*.*.
..#...#...*..```

## 样例 #3

### 输入

```
ABCD```

### 输出

```
..#...#...*...#..
.#.#.#.#.*.*.#.#.
#.A.#.B.*.C.*.D.#
.#.#.#.#.*.*.#.#.
..#...#...*...#..```

# 题解

## 作者：wdcxz (赞：33)

# c++代码
比较水的模拟题，不过我也写了好久，最后发现只是数组开小了，改掉就对了。。。

## ~~下面是解析：~~
这题先把储存的数组全赋值为‘ . ’再求长度（因为宽度恒为5，不用求），长度等于5倍的字母个数减去字母个数最后加一，求出长度后，求第一个字母的位置，易得为3，之后每个位置都要加4，再根据每个字母的位置写出周围的符号，注意，这里有一个特判，若空间已被‘ * ’占掉，则什么也不干，最后输出即可

```cpp
#include <bits/stdc++.h>//万能头，好东西
using namespace std;
int len,lena,ll=3,aa;//ll为第一个字母的初始位置
char a[20],b[1000][100],c;
int main(){
	cin>>a;//输入初始字符串
	len=strlen(a);//求出字符串长度，strlen()函数能求出字符串长度
	lena=4*len+1;//求出输出字符矩阵的长度，宽度恒为五
	memset(b,'.',sizeof(b));//将b数组全赋值为‘.’,以便后来使用
	while(ll<=lena){//开始循环
		aa++;//到第aa个字母
		if(aa%3==0)c='*';
		else c='#';//若为3的倍数个，则用‘*’
		b[3][ll]=a[aa-1];//把字母填入b数组中
		b[1][ll]=c;
		b[5][ll]=c;
		b[2][ll-1]=c;
		b[2][ll+1]=c;
		b[4][ll-1]=c;
		b[4][ll+1]=c;//根据字母的位置推出其他字符的位置，并填入b数组中
		if(b[3][ll-2]!='*')b[3][ll-2]=c;
		if(b[3][ll+2]!='*')b[3][ll+2]=c;//特判，若以被‘*’覆盖，则不能被‘#’覆盖
		ll+=4;//之后每个字母的为止为前一个加4
	}
	for(int i=1;i<=5;i++){
		for(int j=1;j<=lena;j++)
			cout<<b[i][j];//输出
		cout<<endl;//不要忘了每行要加回车
	}
	return 0;//end
}
//wdcxz
```

---

## 作者：北冥有只蒟蒻 (赞：19)

   本蒟蒻认为框架可分为三部分：第一及第五行，第二及第四行和第三行，而这三行还可以这样拆分，在这里以第二个样例为例（“|”是分隔符），可以有以下规律：
![样例的拆分思路](https://cdn.luogu.com.cn/upload/pic/53319.png)
   
   
   
   
   
 

话不多说，先上代码
------------

```
#include <bits/stdc++.h>//从神犇处学到的万能头 
using namespace std;

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

int main(int argc, char** argv) 
{
	string a,b,c,d;
	int e;
	cin>>a;
	e=a.size();//拆字使用 
	b=b+"."; 
	c=c+".";
	d=d+"#";
	for(int i=0;i<e;i++)
	{	
		if((i+1)%3!=0)//彼得潘框架 
		{
		    b=b+".#..";
		    c=c+"#.#.";
		    if((i+1)%3==2) 
		    {
		    	if(i==e-1)//温迪覆盖彼得潘 
		    	    d=d+"."+a[i]+".#";
		    	else//彼得潘在最后不会被覆盖 
		    	    d=d+"."+a[i]+".*";
		    }    
		    else
		        d=d+"."+a[i]+".#";
		}
		else//温迪框架
		{
		    b=b+".*..";
		    c=c+"*.*.";
		    d=d+"."+a[i]+".*";
		}	
	}
	cout<<b<<endl<<c<<endl<<d<<endl<<c<<endl<<b;//输出 
	return 0;
}
```
本蒟蒻第一次提交题解，望管理员通过


---

## 作者：B_Qu1e7 (赞：14)

想法：先处理非3倍数的框架，再处理3倍数的框架（覆盖）、

拿第三组样例做个解释

```cpp
对于每一个字母
确定其中心位置并构造框架
.....   .....   ..#..    ..*..
.....   .....   .#.#.    .*.*.
.....==>..A..==>#.A.# 或 *.A.* 
.....   .....   .#.#.    .*.*.
.....   .....   ..#..    ..*..
因为温迪框架必定覆盖在彼得·潘框架上
所以只需先处理彼得·潘框架 
如： 
..#...#.......#..
.#.#.#.#.....#.#.
#.A.#.B.#...#.D.#
.#.#.#.#.....#.#.
..#...#.......#..
再处理温迪框架，原来有#的地方会被*覆盖 
..#...#...*...#..
.#.#.#.#.*.*.#.#.
#.A.#.B.*.C.*.D.#
.#.#.#.#.*.*.#.#.
..#...#...*...#..
解毕（逃 
```

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[6][62];string s;
void frame(char c,int y,int x)
{
	a[3][y]=c;
	a[1][y]=a[2][y+1]=a[3][y+2]=a[4][y+1]=a[5][y]=a[4][y-1]=a[3][y-2]=a[2][y-1]=(x?'#':'*');
}
int main()
{
	memset(a,'.',sizeof(a));
	cin>>s;
	for(int i=0;i<s.size();i++)
	{
		if(i%3==2)continue;
		frame(s[i],4*i+3,1);
	}
	for(int i=2;i<s.size();i+=3)
	{
		frame(s[i],4*i+3,0);
	}
	for(int i=1;i<6;i++)
	{
		for(int j=1;j<4*s.size()+2;j++)
		{
			cout<<a[i][j];
		}
		cout<<endl;
	}
}
```

---

## 作者：小学生 (赞：14)

简单的代码
```cpp
#include <iostream>
using namespace std;
char s[16];
int n=-1;
#define C ((i-2)%3?'#':'*')
#define PRINT(cha,for_fun) cout<<cha;for(int i=0;i<n;++i)cout<<for_fun;cout<<endl
#define PRINT1() PRINT(".","."<<C<<"..")
#define PRINT2() PRINT(".",C<<"."<<C<< ".")
#define PRINT3() PRINT("#","."<<s[i]<<"."<<((i-1)%3?C:i+1<n?'*':'#'))
int main()
{
    cin >> s;while (s[++n]);
    PRINT1();PRINT2();PRINT3();PRINT2();PRINT1();
    return 0;
}
```
- 宏是好东西，各种源码里都是宏。先看PRINT()，实现的功能就是循环打印，打印的东西就是传入的参数。

- 再看PRINT1()，PRINT2()，PRINT3()。菱形上下对称，所以写3个函数就够了，可以重复使用。拿PRINT1()来举例，它调用了PRINT()，传入了第一行需要循环打印的内容".","."<<C<<".."

- C是什么呢？#define C 来定义是打印#还是※（星号页面显示不了，只好用※来代替），规律相信大家都看出来了，##※来循环，具体代码就是(i-2)%3?'#':'*'

- 最后是本题最容易被忽略的地方，就是中间那一行是打印#还是*，也是本题的精髓所在。这个位置和C很类似，只是有第3个字母要打印※，没有要打印#，所以2个三目运算嵌套一下就搞定了。

---

## 作者：引领天下 (赞：9)

此题其实就是一个模拟

但是不好写

我个人的想法是分组

如下图:
```
..#.. .#.. .*.. .#..
.#.#. #.#. *.*. #.#.
#.X.# .X.* .X.* .X.#
.#.#. #.#. *.*. #.#.
..#.. .#.. .*.. .#..
```

第一组有5个字符,之后的每一组都只有4个

很显然,对于第一组,可以用赋初值的方法解决

之后的组,可以分为%3==2的和%3!=2的

然后就是加上了

具体见代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string a[5]={"..#..",".#.#.","#...#",".#.#.","..#.."},c;
//初值,输出如下:
/*
..#..
.#.#.
#...#
.#.#.
..#..
*/
//中间等会填
int main(){
//    freopen("P4327.in","r",stdin);
//    freopen("P4327.out","w",stdout);
	cin>>c;
	a[2][2]=c[0];
    //第一个框架填好
	for (int i=1;i<c.size();i++){
    //c[0]已经填过,所以从1开始
		if (i%3!=2){
			a[0]+=".#..",a[1]+="#.#.";
            //1和2行没有特殊情况,只要是#框架就行
			if (a[2][a[2].size()-1]=='#')a[2]+=".",a[2]+=c[i],a[2]+=".*";//特殊:如果上一个是#框架,那么这一个的下一个一定是*的,所以第3行最后一个字符填*
			else a[2]+=".",a[2]+=c[i],a[2]+=".#";//不然填#
			a[3]+="#.#.",a[4]+=".#..";//3和4行也没有什么特殊的
		}else{
			a[0]+=".*..",a[1]+="*.*.",a[2]+=".",a[2]+=c[i],a[2]+=".*";
			a[3]+="*.*.",a[4]+=".*..";
            //很像填#的,只不过改了一下字符,由于*的优先级高,所以没有任何问题
		}
	}
	if (c.size()%3==2)a[2][c.size()*4]='#';
    //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意!
    //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意!
    //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意!
    //重要的事情说3遍
    //一开始因为这个被卡了2次50 T-T
	for (int i=0;i<5;i++)cout<<a[i]<<endl;//模拟完了,愉快地输出
	return 0;
}/*
理论上如下切片方式也是可行的:
..#. ..#. ..*. ..#..
.#.# .#.# .*.* .#.#.
#.X. #.X. *.X. *.X.#
.#.# .#.# .*.* .#.#.
..#. ..#. ..*. ..#..
但是好像没有我这种方便
*/```

---

## 作者：yu__xuan (赞：8)

一道简单的模拟题。
```cpp
	string a;
	cin>>a;//读入字符串。
```
```cpp
for(int i=1;i<=5;++i){//共五行.
		int sum1=3,sum2=2,sum3=1;//分别为每一行第一个`#`的位置。因为对称只用到三个。
		if(i==1||i==5){//第一行或最后一行
			while(sum1+4<=99){
				ans[i][sum1]='#',sum1+=4;
			}
		}
		if(i==2||i==4){//第二行或第四行。
			while(sum2+2<=99){
				ans[i][sum2]='#',sum2+=2;
			}
		}
		if(i==3){//第三行。
			while(sum3+4<=99){
				ans[i][sum3]='#',sum3+=4;
			}
		}
	}//先把`#`的框架整一下。
```
效果如下...
```cpp
  #  
 # # 
#   #
 # # 
  #  
```
然后
```cpp
	int na=a.length();
	int f1=3;
	for(int i=0;i<na;++i){
		ans[3][f1]=a[i];
		f1+=4;
	}//将字母填入。
    f1-=2;//这个是最终有多长。
```
效果如下...
```cpp
  #  
 # # 
# X #
 # # 
  #  
```
然后处理一下特殊的。
```cpp
	int qaq=11;//这是第三个字母所在的纵坐标。
	while(qaq<f1){
		for(int i=1;i<=5;++i){
			if(i==1||i==5){
				ans[i][qaq]='*';
			}
			if(i==2||i==4){
				ans[i][qaq+1]='*';
				ans[i][qaq-1]='*';
			}
			if(i==3){
				ans[i][qaq-2]='*';
				ans[i][qaq+2]='*';
			}
		}
		qaq+=12;//下一个字母的下一个字母的下一个字母的纵坐标。
	}
```
完成之后就是输出了
```cpp
//如果既不是#也不是*也不是字母就输出.
for(int i=1;i<=5;++i){
		for(int j=1;j<=f1;++j){
			if((ans[i][j]!='*'&&ans[i][j]!='#')&&(ans[i][j]<'A'||ans[i][j]>'Z')){
				printf(".");
			}else cout<<ans[i][j];
		}
		cout<<endl;
	}
```

**Code:**
```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
char ans[10][100];
int main(){
	string a;
 	cin>>a;
	for(int i=1;i<=5;++i){
		int sum1=3,sum2=2,sum3=1;
		if(i==1||i==5){
			while(sum1+4<=99){
				ans[i][sum1]='#',sum1+=4;
			}
		}
		if(i==2||i==4){
			while(sum2+2<=99){
				ans[i][sum2]='#',sum2+=2;
			}
		}
		if(i==3){
			while(sum3+4<=99){
				ans[i][sum3]='#',sum3+=4;
			}
		}
	}
	int na=a.length();
	int f1=3;
	for(int i=0;i<na;++i){
		ans[3][f1]=a[i];
		f1+=4;
	}
	f1-=2;
	int qaq=11;
	while(qaq<f1){
		for(int i=1;i<=5;++i){
			if(i==1||i==5){
				ans[i][qaq]='*';
			}
			if(i==2||i==4){
				ans[i][qaq+1]='*';
				ans[i][qaq-1]='*';
			}
			if(i==3){
				ans[i][qaq-2]='*';
				ans[i][qaq+2]='*';
			}
		}
		qaq+=12;
	}
	for(int i=1;i<=5;++i){
		for(int j=1;j<=f1;++j){
			if((ans[i][j]!='*'&&ans[i][j]!='#')&&(ans[i][j]<'A'||ans[i][j]>'Z')){
				printf(".");
			}else cout<<ans[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：空城旧梦— (赞：8)

显然，这是一道神奇的打表题。
关键在于找到放置的那个点，下面进行详解


------------

```pascal
var  a:array[1..5,1..1000]of char;
     s:string;
     i,j,k,l,x,y:longint;
procedure  put(x,y:longint);//放置彼得·潘框架
var  i,j:longint;
begin
  for  i:=x-2  to  x+2  do
    for  j:=y-2  to  y+2  do
      a[i,j]:='.';//先全部置点
  a[x,y-2]:='#';  a[x,y+2]:='#';
  a[x-1,y-1]:='#';  a[x-1,y+1]:='#';
  a[x-2,y]:='#';  a[x+2,y]:='#';
  a[x+1,y-1]:='#';  a[x+1,y+1]:='#';//再放置‘#’
end;
procedure  cover(x,y:longint);//覆盖温迪框架
begin
  a[x,y-2]:='*';  a[x,y+2]:='*';
  a[x-1,y-1]:='*';  a[x-1,y+1]:='*';
  a[x-2,y]:='*';  a[x+2,y]:='*';
  a[x+1,y-1]:='*';  a[x+1,y+1]:='*';
end;
begin
  readln(s);//读入
  l:=length(s);
  for  i:=1  to  l  do
    begin
      put(3,i*4-1);//先全部放置彼得·潘框架
      a[3,i*4-1]:=s[i];//放置中间的字符
    end;
  for  i:=1  to  l  do
    if  i mod 3=0  then
      cover(3,i*4-1);//找到3的倍数的字符，放置温迪框架
  for  i:=1  to  5  do
    begin
      for  j:=1  to  l*4+1  do
        write(a[i,j]);//输出
      writeln;
    end;
end.

```


------------


---

## 作者：浅若沐曦 (赞：7)

# 这道题主要考察的是代码功底，我调了一个下午QAQ……
## ~~我主要是暴力枚举QWQ~~
#### 代码如下:
```cpp
#include<bits/stdc++.h>//万能头不多说；
using namespace std;
char a[10005];//读入用的字符数组；
int main(){
	cin>>a;//流输入；
	int l=strlen(a);//函数求字符长度；
	for(int i=1;i<6;i++){//图案共5行；
		for(int j=1;j<l+1;j++){//一层一层枚举；
			if(i==1){
				if(j==1)printf("..#..");
				else if(j%3==0)printf(".*..");
				else printf(".#..");
			}
			if(i==2){
				if(j==l&&j%3==0)printf(".*.*.");
				else if(j==l&&j%3!=0)printf(".#.#.");
				else if(j!=l&&j%3==0)printf(".*.*");
				else printf(".#.#");
			}
/////////////////////第三层考虑要慎重，我调了好久QAQ；
			if(i==3){
				if(j==1||j==l&&(j-1)%3!=0&&j%3!=0&&j-1!=1&&j!=l)printf("#.%c.#",a[j-1]);
				else if(j-1==1&&(j+1)%3==0&&j!=l||(j-1)%3!=0&&(j+1)%3==0&&j!=l)printf(".%c.",a[j-1]);
				else if(j%3==0)printf("*.%c.*",a[j-1]);
				else if(((j-1)%3==0&&l!=1)||j-1==1||l==j)printf(".%c.#",a[j-1]);
				else if(l==1)printf("#.%c.#",a[j-1]);
			}
			if(i==5){
				if(j==1)printf("..#..");
				else if(j%3==0)printf(".*..");
				else printf(".#..");
			}
			if(i==4){
				if(j==l&&j%3==0)printf(".*.*.");
				else if(j==l&&j%3!=0)printf(".#.#.");
				else if(j!=l&&j%3==0)printf(".*.*");
				else printf(".#.#");
			}
		}
		cout<<endl;//每次换行不要忘记；
	}
	return 0;//好习惯
}
```
### ~~代码可能有点缺陷，望指出……~~
# 撒花结束，谢谢大家

---

## 作者：meyi (赞：5)

# 不要用gets（char*）输入！！！
# 不要用gets（char*）输入！！！
# 不要用gets（char*）输入！！！
## 本蒟蒻无法像大佬们边输入边输出，只会将字符串处理好后再输出，不过更容易理解一些。
## 代码中以单个字符的范围（5*5大小）为例进行注释
#### 接下来上代码：
```cpp
#include<cstdio>
#include<cstring>//strlen所在头文件
char s[15],t[65][65];
main(){
    scanf("%s",s);//输入字符串，本题用gets会爆零，本人亲测
    int l=strlen(s);
    /*	位运算能（chun）够（shu）优（zhuang）化（bi），
    	此处的a^b等同于a!=b，c<<2等同于c*4	*/
    for(register int i=0;i^5;++i)
    	for(register int j=0;j^((l<<2)+1);++j)
    		t[i][j]='.';
            /*
            将字符串处理为".....
            			   .....
                           .....
                           .....
                           ....."
            */
    for(register int i=0;i^l;++i){
    	t[2][i*4+2]=s[i];
        /*
        将字符串处理为".....
        			   .....
                       ..X..
                       .....
                       ....."
        */
    	if((i+1)%3){
        	//此处所有的三目运算符都是防止'*'被'#'覆盖
    		t[0][(i<<2)+2]=t[0][(i<<2)+2]^'.'?t[0][(i<<2)+2]:'#';
            /*
            将字符串处理为"..#..
            			   .....
                           ..X..
                           .....
                           ....."
            */
    		t[1][(i<<2)+1]=t[1][(i<<2)+1]^'.'?t[1][(i<<2)+1]:'#';
    		t[1][(i<<2)+3]=t[1][(i<<2)+3]^'.'?t[1][(i<<2)+3]:'#';
            /*
            将字符串处理为"..#..
            			   .#.#.
                           ..X..
                           .....
                           ....."
            */
    		t[2][(i<<2)]=t[2][(i<<2)]^'.'?t[2][(i<<2)]:'#';
    		t[2][(i<<2)+4]=t[2][(i<<2)+4]^'.'?t[2][(i<<2)+4]:'#';
            /*
            将字符串处理为"..#..
            			   .#.#.
                           #.X.#
                           .....
                           ....."
            */
    		t[3][(i<<2)+1]=t[3][(i<<2)+1]^'.'?t[3][(i<<2)+1]:'#';
    		t[3][(i<<2)+3]=t[3][(i<<2)+3]^'.'?t[3][(i<<2)+3]:'#';
            /*
            将字符串处理为"..#..
            			   .#.#.
                           #.X.#
                           .#.#.
                           ....."
            */
    		t[4][(i<<2)+2]=t[4][(i<<2)+2]^'.'?t[4][(i<<2)+2]:'#';
            /*
            将字符串处理为"..#..
            			   .#.#.
                           #.X.#
                           .#.#.
                           ..#.."
            */
		}
		else t[0][(i<<2)+2]=t[1][(i<<2)+1]=t[1][(i<<2)+3]=t[2][(i<<2)]=t[2][(i<<2)+4]=t[3][(i<<2)+1]=t[3][(i<<2)+3]=t[4][(i<<2)+2]='*';
        /*
            将字符串处理为"..*..
            			   .*.*.
                           *.X.*
                           .*.*.
                           ..*.."
        */
	}
	for(register int i=0;i^5;++i)puts(t[i]);//输出，puts会自动换行
}
```


---

## 作者：Ackoter (赞：3)

可以直接创一个char二维数组
这样覆盖容易些
代码~~(不知道这个算不算打表)~~:
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
char ch[6][62];
string st;
int main()
{
	cin>>st;
	ch[1][1]='.';ch[1][2]='.';ch[1][3]='#';ch[1][4]='.';ch[1][5]='.';
	ch[2][1]='.';ch[2][2]='#';ch[2][3]='.';ch[2][4]='#';ch[2][5]='.';
	ch[3][1]='#';ch[3][2]='.';ch[3][3]=st[0];ch[3][4]='.';ch[3][5]='#';
	ch[4][1]='.';ch[4][2]='#';ch[4][3]='.';ch[4][4]='#';ch[4][5]='.';
	ch[5][1]='.';ch[5][2]='.';ch[5][3]='#';ch[5][4]='.';ch[5][5]='.';//先把特殊的第一个直接赋值出来
	for(int i=1;i<st.size();i++)
	{
		if((i+1)%3==0) //分情况赋值
		{
			ch[1][i*4+1]='.';ch[1][2+i*4]='.';ch[1][3+i*4]='*';ch[1][4+i*4]='.';ch[1][5+i*4]='.';
			ch[2][i*4+1]='.';ch[2][2+i*4]='*';ch[2][3+i*4]='.';ch[2][4+i*4]='*';ch[2][5+i*4]='.';
			ch[3][i*4+1]='*';ch[3][2+i*4]='.';ch[3][3+i*4]=st[i];ch[3][4+i*4]='.';ch[3][5+i*4]='*';
			ch[4][i*4+1]='.';ch[4][2+i*4]='*';ch[4][3+i*4]='.';ch[4][4+i*4]='*';ch[4][5+i*4]='.';
			ch[5][i*4+1]='.';ch[5][2+i*4]='.';ch[5][3+i*4]='*';ch[5][4+i*4]='.';ch[5][5+i*4]='.';
		} else
		{
			ch[1][2+i*4]='.';ch[1][3+i*4]='#';ch[1][4+i*4]='.';ch[1][5+i*4]='.';
			ch[2][2+i*4]='#';ch[2][3+i*4]='.';ch[2][4+i*4]='#';ch[2][5+i*4]='.';
			ch[3][2+i*4]='.';ch[3][3+i*4]=st[i];ch[3][4+i*4]='.';ch[3][5+i*4]='#';
			ch[4][2+i*4]='#';ch[4][3+i*4]='.';ch[4][4+i*4]='#';ch[4][5+i*4]='.';
			ch[5][2+i*4]='.';ch[5][3+i*4]='#';ch[5][4+i*4]='.';ch[5][5+i*4]='.';
		}//由于'*'表会覆盖'#'，所以不用赋值第一行
	}
	for(int i=1;i<=5;i++)//最后直接输出就好了
	{
		for(int j=1;j<=st.size()*4+1;j++)
			cout<<ch[i][j];
		cout<<endl;
	}
    return 0; 
}
```

---

## 作者：YueYang1235 (赞：3)

## **无脑**的解法
输出5行，我就搞5个for语句（手动滑稽

都是找规律，一支笔，一张纸，画一画，想一想，就能抽象出规律来。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[20],ch[105][105];
int len,ans,an;
int main()
{
	cin>>a;len=strlen(a);
	for(int i=1;i<=len*4+1;i++)
		if((i-3)%4==0){
			ans++;
			if(ans%3==0)cout<<'*';
			else cout<<'#';
		}
		else cout<<'.';
	cout<<endl;ans=0;
	//第一行
	for(int i=1;i<=len*4+1;i++)
		if(i%2==0){
			ans++;
			if(ans%6==0||ans%6==5)cout<<'*';
			else cout<<'#';
		}
		else cout<<'.';
	cout<<endl;ans=0;
	//第二行
	for(int i=1;i<=len*4+1;i++)
		if(i%2==1){
			if((i-3)%4==0){
				cout<<a[an];
				an++;
				continue;
			}
			if(an%3==0&&an!=0)cout<<'*';
			
			else if((i-1)%4==0&&(an+1)%3==0&&len>2&&an+1<=len)cout<<'*';
			else cout<<'#';
		}
		else cout<<'.';
	cout<<endl;ans=0;
	//第三行（有点难搞啊）
	for(int i=1;i<=len*4+1;i++)
		if(i%2==0){
			ans++;
			if(ans%6==0||ans%6==5)cout<<'*';
			else cout<<'#';
		}
		else cout<<'.';
	cout<<endl;ans=0;
	//第四行，同第二行
	for(int i=1;i<=len*4+1;i++)
		if((i-3)%4==0){
			ans++;
			if(ans%3==0)cout<<'*';
			else cout<<'#';
		}
		else cout<<'.';
	cout<<endl;ans=0;
    //第五行，同第一行
    return 0;//完美的结束
}
```


---

## 作者：buickboy (赞：2)

### 争做最简洁最好懂题解！全部代码27行！

看了题解，不少用宏的，这对新手不够友好，还有不少用大量点位操作的，显得很复杂。

实际上，使用string的拼接操作，以每一行作为操作视角，可显著降低模拟复杂度。

观察可知，除第1个字符转换后是5行5列外，其他字符转换后其实都是4列，交界的列是共用的，这也是本题的难点。另外，也不能边转换边打印，因为这样很难形成最终的5行。

分析样例ABCD，可按5-4-4-4划分，正因为最终是5行，并且每次生成的一行字符串基本相同，比如第1行的后续4个字符一直是“.#..”，所以可将每行都视为一个字符串，用整体的string来依次连接。由于第1行与第5行相同，第2行与第4行相同，所以只要考虑前3行就可以了。

当然不同点要注意，有两处。一是逢3个字符的温迪框架下#要改为*，二是在第3行逢3的倍数进行温迪框架转换时，要先把之前末尾的#替换为*，如样例中B的后两位要改#为*，再进行连接。

为降低编程复杂度，直接把每行普通的彼得潘框架和每行特殊的温迪框架存储为对应的string类字符串u和v，在转换时直接调用，而具体的目标字符，则先更新，再拼接。

综上，总体思路是，先把第1个字符转换，并给第1~3行的答案字符串s1~s3赋初值，后续每生成一行4个字符的字符串，就连接到对应行的答案字符串s1~s3上去。进行到特殊的温迪框架时，调用相应的字符串v1~v3；进行到具体的字符转换时，通过点位上的变量赋值直接更新u3或v3，再连接到s3，最终形成5行并打印。

注意防止几个坑：一是第1个字符要5行5列，防止只出现1个字符。二是检查长度是3的倍数，即以温迪框架结尾时是否正常。三是为防止下标调用出错，将源串的首位0位补一个字符。


```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    string s, s1, s2, s3, u1, u2, u3, v1, v2, v3;
    s1 = "..#..", s2 = ".#.#.", s3 = "#.A.#"; //第1个字符转换要用的3行
    u1 = ".#..", u2 = "#.#.", u3=".A.#";    //彼得潘框架的后续3行，4字符
    v1 = ".*..", v2 = "*.*.", v3 = ".A.*";  //温迪框架的后续3行，4字符
    cin >> s;//输入待转换字符串
    s = "+" + s; //整体后移1位，下标从1开始
    s3[2] = s[1]; //替换A为待转换字母，到此第1个字符转换完成
    for (int i = 2; s[i]; ++i)//从源串第2个字符开始遍历
        if (i % 3)//下标不是3的倍数，彼得潘框架
        {
            s1 += u1, s2 += u2; //第1~2行
            u3[1] = s[i], s3 += u3; //第3行中间目标字符更新
        }
        else//下标是3的倍数，温迪框架
        {
            s3[s3.size() - 1] = '*';//进行中的第3行目标串末位先改为*
            s1 += v1, s2 += v2; //第1~2行
            v3[1] = s[i], s3 += v3; //第3行中间目标字符更新后再连接
        }
    cout << s1 << endl << s2 << endl << s3 << endl << s2 << endl << s1 << endl;//5行输出
    return 0;
}

```


---

## 作者：heidoudou (赞：2)

用数组的都弱爆了。

第一行规律： `..#.` 或者 `..*.` 最后补一个 `.`

第二行规律： `.#.#` 或者 `.*.*` 最后补一个 `.`

第三行规律： 开始 `#`， 然后是 `.X.#` 或者 `.X.*`， 具体用哪个字符需要仔细观察一下。这里有点小坑。WA 了两次才发现有bug。

依次输出就行了。

```cpp
void printLine1(int n)
{
    // n: num of characters
    for (int i = 1; i <= n; ++i)
        printf("..%c.", i % 3 == 0 ? '*': '#');
    printf(".\n");
}

void printLine2(int n)
{
    // n: num of characters
    char c;
    for (int i = 1; i <= n; ++i)
    {
        c = i % 3 == 0 ? '*' : '#';
        printf(".%c.%c", c, c);
    }
    printf(".\n");
}

void printMainLine(const char s[], int n)
{
    char c;
    putchar('#');
    for (int i = 0; i < n; ++i)
    {
        c = (i % 3 == 0 || (i % 3 == 1 && i == n - 1)) ? '#' : '*';
        printf(".%c.%c", s[i], c);
    }
    putchar('\n');
}

void printFrame(const char s[])
{
    int l = strlen(s);
    printLine1(l);
    printLine2(l);
    printMainLine(s, l);
    printLine2(l);
    printLine1(l);
    // printf("");
}


int main()
{
    char s[MAX_N];
    scanf("%s", s);
    printFrame(s);
}
```


---

## 作者：ggtmjts (赞：1)

    *********华丽的分割线**************
    这题我们需要找一下规律。
    一个的时候，宽1*3+0+2
    ..*..
    .*.*.
    *.X.*
    .*.*.
    ..*.. 
    2个的时候，宽2*3+1+2
    ..*...*..
    .*.*.*.*.
    *.X.*.X.*
    .*.*.*.*.
    ..*...*..
    3个的时候，宽3*3+2+2
    ..*...*...*..
    .*.*.*.*.*.*.
    *.X.*.X.*.X.*
    .*.*.*.*.*.*.
    ..*...*...*..
    i个的时候，宽i*3+i-1+2
    那么，计算字母的列很简单
    第几个字母*3+2，这里不用加2
    因为最后两列不是字母
    字母行永远是3
    具体见代码  
    
    var a:array[0..1000,0..1000]of char;
    s:string;i,x,j:longint;c:char;
    begin
    readln(s);
    fillchar(a,sizeof(a),'?');  //假设没有放好，全部是？
    for i:=1 to length(s) do
       begin
       x:=i*3+(i-1);     //求出字母的位置
       if i mod 3=0 then c:='*'    //如果是每3个的第3个，要填的框架是温迪框架
       else c:='#';//否则是彼得·潘框架
      a[3,x]:=s[i];//把字母放好
      a[3,x-1]:='.';
      a[3,x+1]:='.';
      a[2,x]:='.';
      a[2,x-2]:='.';
      a[2,x+2]:='.';
      a[4,x]:='.';
      a[4,x-2]:='.';
      a[4,x+2]:='.';
      a[1,x-2]:='.';
      a[1,x-1]:='.';
      a[1,x+1]:='.';
      a[1,x+2]:='.';      //把‘.’的位置解决了
      a[5,x-2]:='.';
      a[5,x-1]:='.';
      a[5,x+1]:='.';
      a[5,x+2]:='.';//如果是没放过，或者是彼得·潘框架，那么就要放，有时要覆盖
      if(a[1,x]='?')or(a[1,x]='#') then a[1,x]:=c;
      if(a[2,x-1]='?')or(a[2,x-1]='#') then a[2,x-1]:=c;
      if(a[2,x+1]='?')or(a[2,x+1]='#') then a[2,x+1]:=c;
      if(a[3,x-2]='?')or(a[3,x-2]='#') then a[3,x-2]:=c;
      if(a[3,x+2]='?')or(a[3,x+2]='#') then a[3,x+2]:=c;
      if(a[5,x]='?')or(a[5,x]='#') then a[5,x]:=c;
      if(a[4,x-1]='?')or(a[4,x-1]='#') then a[4,x-1]:=c;
      if(a[4,x+1]='?')or(a[4,x+1]='#') then a[4,x+1]:=c;
      end;
    for i:=1 to 5 do
      begin         //输出
      for j:=1 to length(s)*3+length(s)-1+2 do
        write(a[i,j]);         //计算有几列
      if i<>5 then writeln;    //换行，最后一行不能在换行了
      end;
    end.

---

## 作者：电脑专家 (赞：0)

# 来个简洁易懂的题解

1. 第一个for是#
2. 第二个for用*覆盖#
3. 但是有点不同，#是连续的，所以每个for只需写入宽度为4的矩阵
4. 但是*是分开的，所以得老老实实写5列（就这里被坑了）

我的代码简明易懂吧？哈哈哈！

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	char text[16];
	cin>>text;
	char result[5][62];
	memset(result,0,sizeof(result));
	result[0][0]='.';result[1][0]='.';result[2][0]='#';result[3][0]='.';result[4][0]='.';
	for(int i=0;i<strlen(text);i++){
		char x=text[i];
		int xPos=4*i+2;
		result[0][xPos-1]='.';	result[0][xPos]='#';	result[0][xPos+1]='.';	result[0][xPos+2]='.';
		result[1][xPos-1]='#';	result[1][xPos]='.';	result[1][xPos+1]='#';	result[1][xPos+2]='.';
		result[2][xPos-1]='.';	result[2][xPos]=x;		result[2][xPos+1]='.';	result[2][xPos+2]='#';
		result[3][xPos-1]='#';	result[3][xPos]='.';	result[3][xPos+1]='#';	result[3][xPos+2]='.';
		result[4][xPos-1]='.';	result[4][xPos]='#';	result[4][xPos+1]='.';	result[4][xPos+2]='.';
	}
	for(int i=2;i<strlen(text);i+=3){
		char x=text[i];
		int xPos=4*i+2;
		result[0][xPos-2]='.';	result[0][xPos-1]='.';	result[0][xPos]='*';	result[0][xPos+1]='.';	result[0][xPos+2]='.';
		result[1][xPos-2]='.';	result[1][xPos-1]='*';	result[1][xPos]='.';	result[1][xPos+1]='*';	result[1][xPos+2]='.';
		result[2][xPos-2]='*';	result[2][xPos-1]='.';	result[2][xPos]=x;		result[2][xPos+1]='.';	result[2][xPos+2]='*';
		result[3][xPos-2]='.';	result[3][xPos-1]='*';	result[3][xPos]='.';	result[3][xPos+1]='*';	result[3][xPos+2]='.';
		result[4][xPos-2]='.';	result[4][xPos-1]='.';	result[4][xPos]='*';	result[4][xPos+1]='.';	result[4][xPos+2]='.';
	}
	for(int i=0;i<5;i++)
		cout<<result[i]<<endl;
}
```


---

## 作者：Forgetter (赞：0)

## 超级无脑解法

#### 思路
写两个方法，一个输出 # 图，一个输出 * 图。

一次只输入一个方阵(五行五列)。

先遍历不是3倍数的，再遍历3的倍数的。

废话不说了，直接看无脑代码：

------------
```java
public class Main {
	static int n;		//题目字符串长度
	static char[] ch;	//题目输入
	static char[][] ans; //输出方阵
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedInputStream(System.in));
		while(sc.hasNext()){
			String string = sc.nextLine();
			ch = string.toCharArray();
			n = ch.length;	//字符串的长度
			ans = new char[5][n*4+1];//计算一下方阵大小申请空间
			//先载入不是3的倍数的。
			for(int i=0;i<n;i++){
				if((i+1)%3!=0)
					hua1(ch[i], i);
			}
            
            //后载入3的倍数的。这样就优先级大于上者
			for(int i=3;i<=n;i+=3){
				hua2(ch[i-1], i-1);
			}

			for (char[] c : ans) {
				for (char cc : c) {
					System.out.print(cc);
				}System.out.println();
			}
		}sc.close();
	}
	/*
					..#..
					.#.#.
					#.A.#
					.#.#.
					..#..
	 */		
	public static void hua1(char c,int t){ //第t个字母   0 ~ ch.length-1 
		int b = 4*t;	
		ans[0][b]='.';ans[0][b+1]='.';ans[0][b+2]='#';ans[0][b+3]='.';ans[0][b+4]='.';
		ans[1][b]='.';ans[1][b+1]='#';ans[1][b+2]='.';ans[1][b+3]='#';ans[1][b+4]='.';
		ans[2][b]='#';ans[2][b+1]='.';ans[2][b+2]= c ;ans[2][b+3]='.';ans[2][b+4]='#';
		ans[3][b]='.';ans[3][b+1]='#';ans[3][b+2]='.';ans[3][b+3]='#';ans[3][b+4]='.';
		ans[4][b]='.';ans[4][b+1]='.';ans[4][b+2]='#';ans[4][b+3]='.';ans[4][b+4]='.';
	}
/*	
					..*..
					.*.*.
					*.X.*
					.*.*.
					..*..
 */
	public static void hua2(char c,int t){ 
		int b = 4*t;
		ans[0][b]='.';ans[0][b+1]='.';ans[0][b+2]='*';ans[0][b+3]='.';ans[0][b+4]='.';
		ans[1][b]='.';ans[1][b+1]='*';ans[1][b+2]='.';ans[1][b+3]='*';ans[1][b+4]='.';
		ans[2][b]='*';ans[2][b+1]='.';ans[2][b+2]= c ;ans[2][b+3]='.';ans[2][b+4]='*';
		ans[3][b]='.';ans[3][b+1]='*';ans[3][b+2]='.';ans[3][b+3]='*';ans[3][b+4]='.';
		ans[4][b]='.';ans[4][b+1]='.';ans[4][b+2]='*';ans[4][b+3]='.';ans[4][b+4]='.';
	}
}
```

---

## 作者：hyzxxqc (赞：0)

#### 上来就觉得，这是一道 繁 的题目~~（打表题）~~

#### 实际上，呵呵一笑就做出来了

因为，只要**先储存再输出**就行了

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
short l;
char k[5][100];
void ch(char x,short y,char z)//x：中间是什么字符；y：第几个；z：用什么字符填充
{
	y=4*y-2;
	k[0][y-2]='.';k[0][y-1]='.';k[0][y]=z;k[0][y+1]='.';k[0][y+2]='.';
	k[1][y-2]='.';k[1][y-1]=z;k[1][y]='.';k[1][y+1]=z;k[1][y+2]='.';
	k[2][y-2]=z;k[2][y-1]='.';k[2][y]=x;k[2][y+1]='.';k[2][y+2]=z;
	k[3][y-2]='.';k[3][y-1]=z;k[3][y]='.';k[3][y+1]=z;k[3][y+2]='.';
	k[4][y-2]='.';k[4][y-1]='.';k[4][y]=z;k[4][y+1]='.';k[4][y+2]='.';//填入
}
int main()
{
	cin>>s;//输入，不用说
	l=s.length();
	for (short i=0;i<l;i++)
		if ((i+1)%3!=0)
			ch(s[i],i+1,'#');//先放彼得框架
	for (short i=0;i<l;i++)
		if ((i+1)%3==0)
			ch(s[i],i+1,'*');//再放温蒂框架
	l=4*l+1;
	for (short i=0;i<5;i++)//再输出
	{
		for (short j=0;j<l;j++) cout<<k[i][j];
		cout<<endl;
	}
	return 0;//是不是觉得很简单？？？
}
```

---

## 作者：ZJMZJM (赞：0)

来自蒟蒻的一篇题解

此题将公式推出后就OK
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string s;
	cin>>s;
	int l=s.size(),t=1,x=0;//输入长度
	cout<<"..#";
	for(int i=4;i<=4*l+1;i++)
	{
		if(i%4==3&&t==0||i%4==3&&t==1)
			cout<<"#",t++;
		else if(i%4==3&&t==2)
			cout<<"*",t=0;
		else cout<<".";
	}//第一行 还可以
	cout<<endl;
	t=1;
	for(int i=1;i<=4*l+1;i++)
	{
		if(i%2==1) cout<<".";
		else if(i%2==0)
		{
			if(t==1||t==2||t==3||t==4)	cout<<"#",t++;
			else	cout<<"*",t++,t=t%6; 
		}
	}//第二行 判断一下
	cout<<endl;
	t=2;
	cout<<"#"; 
	for(int i=2;i<=4*l;i++)
	{
		if(i%2==0) cout<<".";
		else if(i%2==1)
		{
			if(t==3)	cout<<"#",t++;
			else if(t==1||t==5)	cout<<"*",t++; 
			else cout<<s[x],t++,x++;
			t%=6;
		}
	}
	if(l%3==0)
		cout<<"*";
	else
		cout<<"#";
	cout<<endl; //第三行 比较棘手
	t=1;
	for(int i=1;i<=4*l+1;i++)
	{
		if(i%2==1) cout<<".";
		else if(i%2==0)
		{
			if(t==1||t==2||t==3||t==4)	cout<<"#",t++;
			else	cout<<"*",t++,t=t%6; 
		}
	}//第四行 同第二行
	cout<<endl;
	t=1;
	cout<<"..#";
	for(int i=4;i<=4*l+1;i++)
	{
		if(i%4==3&&t==0||i%4==3&&t==1)
			cout<<"#",t++;
		else if(i%4==3&&t==2)
			cout<<"*",t=0;
		else cout<<".";
	}//第五行 同第一行
    return 0;//愉快的结束
}
```

---

## 作者：珅肐 (赞：0)

### 我做这道题的思想是拆分
把需要输出的基本分成四个一组
## 像这样：
```c
..#.  ..#.  ..*.  ..#..
.#.#  .#.#  .*.*  .#.#.
#.X.  #.X.  *.X.*  .X.#
.#.#  .#.#  .*.*  .#.#.
..#.  ..#.  ..*.  ..#..
```
### 注意：
第三部分第三行有五个字符，那么下一部分的第三行就少一个

输出的最后一部分也有五个字符
#### 详见代码：
```c
#include<iostream>
#include<cstdio>
#include<cstring>
#define P1 printf("..#.")
#define P11 printf("..*.")
#define P2 printf(".#.#")
#define P22 printf(".*.*")
#define P3 printf("#.#")
#define P33 printf("*.*")//define一波好输出
using namespace std;
int n;
char s[20];
int main()
{
	cin>>s+1;//从s+1开始输入比较好写
	n=strlen(s+1);//所以长度也要从s+1开始
	for(int i=1;i<=n;++i)//每四个一组输出
    	if(i%3) P1;//如果不能整除3，输出彼得·潘框架
        else P11;//如果能整除，输出温迪框架
	printf(".\n");//输出最后一个“.”
	for(int i=1;i<=n;++i) if(i%3) P2;else P22;
	printf(".\n");//与上同，不解释
	
    //下面到本题的精华部分同时也是难点了
    printf("#.%c.",s[1]);//先处理一下第一个
	for(int i=2;i<=n;++i)//注意：这里i从2开始
	{
		if(i%3==1)  printf(".%c.",s[i]);//如果是温迪框架之后的那一个，少输出一个字符
		else if(i%3==2)  printf("#.%c.",s[i]);
		else printf("*.%c.*",s[i]);//如果能被3整除，输出温迪框架，记住是五个字符！
	}
	if(n%3) printf("#\n");//特判最后一个,如果最后一个框架不是温迪框架，输出“#”+回车
	else printf("\n");//如果是，"*"已经输出过了，直接换行；
	for(int i=1;i<=n;++i) if(i%3) P2;else P22;
	printf(".\n");
	for(int i=1;i<=n;++i) if(i%3) P1;else P11;
	printf(".\n");
    //输出后两行
	return 0;//好习惯
}
```

---

## 作者：yuzhechuan (赞：0)

```cpp
#include <bits/stdc++.h>//万能库
using namespace std;

char a[17];//可能是最少定义？
int n;

int main()
{
	scanf("%s",a+1);//用字符串读入，更安全
	n=strlen(a+1);//n记录长度
	
	for(int i=1;i<=n;i++)//模拟第一行
	if(i%3!=0) printf("..#.");//切割为   ..符   ..符   ..符
	else printf("..*.");//特判温迪框架
	printf(".\n");//别忘了最后的  .
	
	for(int i=1;i<=n;i++)//模拟第二行
	if(i%3!=0) printf(".#.#");//切割为   .符.符    .符.符    .符.符 
	else printf(".*.*");//特判温迪框架
	printf(".\n");//别忘了最后的  .
	
	//模拟第三行（最麻烦）
    printf("#");//先输出第一个#，以便更好地找到规律
	for(int i=1;i<=n;i++)//这里需要切割成三部分
	{
		if(i%3==0) printf("*.%c.*",a[i]);//温迪框架部分为 *.字母.*
	    if(i%3==1)printf(".%c.#",a[i]);//第一部分为   .字母.#
	    if(i%3==2)printf(".%c.",a[i]);//第二部分为  .字母.
	}
	if(n%3==2)cout<<'#';//如果最后的字符没被温迪遮住的话，也要输出
	printf("\n");
	
	for(int i=1;i<=n;i++)//模拟第四行（与第二行相同）
	if(i%3!=0) printf(".#.#");
	else printf(".*.*");
	printf(".\n");
	
	for(int i=1;i<=n;i++)//模拟第五行（与第一行相同）
	if(i%3!=0) printf("..#.");
	else printf("..*.");
	printf(".\n");
} 
```


------------
##### （注:注释中的“符”指的是*和#）


---

## 作者：Kiel (赞：0)

# 蒟蒻代码如下：
根据题意直接模拟，~~虽然很难模拟（逃）~~

~~我大约调试了一个小时。~~

就是看看这个字符的位置是不是三的倍数

代码如下：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define read read()
inline int read{
   int s=0,w=1;
   char ch=getchar();
   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
char a[25];
int main(){
	cin>>(a);
	int n=strlen(a);
	cout<<'.';
	for(int i=0;i<n;i++){
	    if((i+1)%3==0){
	        cout<<".*.";
	    }
	    else{
	        cout<<".#.";
	    }
	    cout<<'.';
	}
	cout<<endl;
	for(int i=0;i<n;i++){
	    cout<<'.';
	    if((i+1)%3==0){
	        cout<<"*.*";
	    }
	    else{
	        cout<<"#.#";
	    }
	}
	cout<<'.';
	cout<<endl;
	int flag=1;
	for(int i=0;i<n;i++){
	    if((i+1)%3==0){
	        cout<<"*."<<a[i]<<".*";
	        flag=0;
	    }
	    else if(flag){
	        cout<<"#."<<a[i]<<".";
	    }
	    else if(!flag){
	        cout<<"."<<a[i]<<".";
	        flag=1;
	    }
	}
	if(n%3!=0){
	    cout<<"#";
	}
	cout<<endl;
	for(int i=0;i<n;i++){
	    cout<<'.';
	    if((i+1)%3==0){
	        cout<<"*.*";
	    }
	    else{
	        cout<<"#.#";
	    }
	}
	cout<<'.';
	cout<<endl;
	cout<<'.';
	for(int i=0;i<n;i++){
	    if((i+1)%3==0){
	        cout<<".*.";
	    }
	    else{
	        cout<<".#.";
	    }
	    cout<<'.';
	}
	return 0;
}
```

---


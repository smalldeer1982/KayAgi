# [CSP-J2019] 数字游戏

## 题目描述

小 K 同学向小 P 同学发送了一个长度为 $8$ 的 **01 字符串**来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 $1$。

注意：01 字符串为每一个字符是 $0$ 或者 $1$ 的字符串，如 `101` 为一个长度为 $3$ 的 01 字符串。 

## 说明/提示

**样例 1 说明**

该 01 字符串中有 $2$ 个字符 $1$。 


**样例 2 说明**

该 01 字符串中有 $8$ 个字符 $1$。

**数据规模与约定** 

- 对于 $20\%$ 的数据，保证输入的字符全部为 $0$。
- 对于 $100\%$ 的数据，输入只可能包含字符 $0$ 和字符 $1$，字符串长度固定为 $8$。

## 样例 #1

### 输入

```
00010100```

### 输出

```
2```

## 样例 #2

### 输入

```
11111111```

### 输出

```
8```

# 题解

## 作者：VenusM1nT (赞：153)

$\textbf{FFT}$.  
首先这个题目可以转化为给出字符串和 `1` 这个字符串有多少个点可以匹配，那么我们可以用 `P4173 残缺的字符串` 的思路（见 [Link](https://www.luogu.org/blog/Venus/solution-p4173)），分做三次 $\textbf{FFT}$，就可以通过此题了。  
（这个题解说明过少被 ban 了，那就多讲一点）  
我们定义字符串 $S,T$ 的“距离”为  
$$d(S,T)=\sum_{i=1}^n(S_i-T_i)^2\times S_i\times T_i$$
那么可以匹配的条件就是
$$f_i=d(S,T)=0$$
那么我们令 $T$ 为 `1`，对于 $S$ 中每个位置都求出一个 $f_i$，那么问题就是这个 $f_i$ 怎么求。显然可以将距离的式子拆开，变为由三个 $\sum$ 组成的式子，而这三个式子正好是多项式的形式，那么我们就可以用 $\textbf{FFT}$ 分别做三次来求出每个 $f_i$ 的值，最后统计一下就可以出解了。  
（md我在写什么）  
（实测可过，常数巨大）  
代码如下
```cpp
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define MAXN 2000005
#define reg register
#define inl inline
#define db double
#define eps 1e-6
using namespace std;
const int Mod=998244353;
const db Pi=acos(-1.0);
struct Complex
{
    db x,y;
    friend Complex operator + (const Complex &a,const Complex &b)
    {
        return ((Complex){a.x+b.x,a.y+b.y});
    }
    friend Complex operator - (const Complex &a,const Complex &b)
    {
        return ((Complex){a.x-b.x,a.y-b.y});
    }
    friend Complex operator * (const Complex &a,const Complex &b)
    {
        return ((Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x});
    }
    friend Complex operator * (const Complex &a,const db &val)
    {
        return ((Complex){a.x*val,a.y*val});
    }
}f[MAXN],g[MAXN],p[MAXN];
int n,m,lim=1,maxn,rev[MAXN],a[MAXN],b[MAXN],ans;
char S[MAXN],T[MAXN];
bool used[MAXN];
inl void FFT(reg Complex *A,reg int opt)
{
    for(reg int i=0;i<lim;i++) if(i<rev[i]) swap(A[i],A[rev[i]]);
    for(reg int mid=1;mid<lim;mid<<=1)
    {
        reg Complex Wn=((Complex){cos(Pi/(db)mid),(db)opt*sin(Pi/(db)mid)});
        for(reg int j=0;j<lim;j+=(mid<<1))
        {
            reg Complex W=((Complex){1,0});
            for(reg int k=0;k<mid;k++,W=W*Wn)
            {
                reg Complex x=A[j+k],y=W*A[j+k+mid];
                A[j+k]=x+y;
                A[j+k+mid]=x-y;
            }
        }
    }
}
int main()
{
	n=8,m=1,T[1]='1';
    scanf("%s",S+1);
    for(reg int i=1;i<=m;i++) if(T[i]!='*') a[i-1]=T[i]-'0'+1;
    for(reg int i=1;i<=n;i++) if(S[i]!='*') b[i-1]=S[i]-'0'+1;
    while(lim<=(n+m))
    {
        lim<<=1;
        maxn++;
    }
    for(reg int i=0;i<lim;i++) rev[i]=((rev[i>>1]>>1)|((i&1)<<maxn-1));
    reverse(a,a+m);
    for(reg int i=0;i<m;i++) f[i]=((Complex){a[i]*a[i]*a[i],0});
    for(reg int i=0;i<n;i++) g[i]=((Complex){b[i],0});
    FFT(f,1);FFT(g,1);
    for(reg int i=0;i<lim;i++) p[i]=p[i]+f[i]*g[i];
    for(reg int i=0;i<lim;i++) f[i]=g[i]=((Complex){0,0});
    for(reg int i=0;i<m;i++) f[i]=((Complex){a[i]*a[i],0});
    for(reg int i=0;i<n;i++) g[i]=((Complex){b[i]*b[i],0});
    FFT(f,1);FFT(g,1);
    for(reg int i=0;i<lim;i++) p[i]=p[i]-f[i]*g[i]*2.0;
    for(reg int i=0;i<lim;i++) f[i]=g[i]=((Complex){0,0});
    for(reg int i=0;i<m;i++) f[i]=((Complex){a[i],0});
    for(reg int i=0;i<n;i++) g[i]=((Complex){b[i]*b[i]*b[i],0});
    FFT(f,1);FFT(g,1);
    for(reg int i=0;i<lim;i++) p[i]=p[i]+f[i]*g[i];
    FFT(p,-1);
    for(reg int i=m-1;i<n;i++) if(!(int)(p[i].x/(db)lim+0.5)) ans++;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：A_Đark_Horcrux (赞：84)

这题，我们花式吊打它

### 1.正常思路

不难看出，求出1的个数其实就是求出这个字串里所有数字的和。区间求和自然想到线段树。

```cpp
#include<cstdio>
#define li inline
#define ll long long
using namespace std;
ll n,m,t,x,y,k,i,a[1000001],ans[1000001],tag[1000001]; char c;
li ll ls(ll x) {return x<<1;}//左儿子
li ll rs(ll x) {return (x<<1)|1;}//右儿子
li void pushup(ll x) {ans[x]=ans[ls(x)]+ans[rs(x)];}//更新ans数组
li void f(ll p,ll l,ll r,ll k)//lazytag用的f操作
{
	tag[p]+=k;
	ans[p]+=k*(r-l+1);
	return ;
}
li void pushdown(ll p,ll l,ll r)//lazytag的pushdown操作
{
	ll mid=(l+r)>>1;
	f(ls(p),l,mid,tag[p]);
	f(rs(p),mid+1,r,tag[p]);
	tag[p]=0; return ;
}
void build(ll p,ll l,ll r)//建树
{
	tag[p]=0;
	if(l==r) {ans[p]=a[l]; return ;}
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	pushup(p); return ;
}
ll ask(ll x,ll y,ll l,ll r,ll p)//区间求和
{
	if(x<=l&&r<=y)return ans[p];
	ll s=0,mid=(l+r)>>1;
	pushdown(p,l,r);
	if(x<=mid) s+=ask(x,y,l,mid,ls(p));
	if(y>mid) s+=ask(x,y,mid+1,r,rs(p));
	return s;
}
int main()
{
	for(i=1;i<=8;i++) scanf("%c",&c),a[i]=c-'0';//输入初始数组
	build(1,1,8);//建树
	printf("%lld\n",ask(1,8,1,8,1));//输出1~8区间内的和
	return 0;
}
```
当然树状数组也能解决。
```cpp
#include<cstdio>
using namespace std;
int i,a[500001],c[500001]; char awa;
int lowbit(int x) {return x&-x;}//lowbit
void add(int x,int k) {while(x<=8) c[x]+=k,x+=lowbit(x);}//更新c数组
int sum(int x)//求和
{
	int t=0;
	while(x!=0) t+=c[x],x-=lowbit(x);
    return t;
}
int main()
{
	for(i=1;i<=8;i++) awa=getchar(),a[i]=awa-'0',add(i,a[i]);//输入
	printf("%d\n",sum(8)-sum(0));//输出
	return 0;
}
```
### 2.非正常思路

我们假设这有一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/id65jj3z.png)

中间的是0号节点，其余的为1~8号节点。

__如果我们读入的这个串，它的i位代表0号节点到i号节点的距离，那么跑一遍最小生成树就能求解。__

Kruskal：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct A
{
    int a,b,s;
}a[200001];
int n,m,s,t,i,j,f[200001]; char c;
bool cmp(A x,A y) {return x.s<y.s;}//排序用的cmp
int find(int x) {return f[x]==x?x:find(f[x]);}//并查集用的find
int main()
{
    for(i=1;i<=8;i++) c=getchar(),c=='1'?a[++m].a=0,a[m].b=i,a[m].s=1:c=c;//输入，如果第i位为1就建边
    for(i=0;i<=8;i++) f[i]=i;
    for(i=1;i<=m;i++)
    {
		int p=find(a[i].a),q=find(a[i].b);
		if(p==q) continue;
		f[q]=p,t+=a[i].s,s++;
        if(s==n-1) break;
    }//Kruskal
    printf("%d",t);//输出
    return 0;
}
```

~~盖 火 锅~~

---

## 作者：cff_0102 (赞：16)

一个很简单的方法：`while(cin>>c)` 可以一直读入一个字符直到文件的末尾（EOF）。一个数字字符减去 `'0'` 就可以得到对应的数字。用一个变量把读到的所有数字加起来就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int s=0;char c;
	while(cin>>c)s+=c-'0';
	cout<<s;
	return 0;
}
```

---

## 作者：Inkyo (赞：14)

>这里是墨攸，平生没有什么爱好，就喜欢刷水题

给你们介绍一种很神奇的做法（虽然有点多此一举qwq）：

先上代码：

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
using namespace std;

int n, ans;
char c;

int main()
{
    for(int i = 1; i <= 8; i ++)
    {
        scanf("%c", &c);
        n = (n << 1) + (c - '0');
    }
    while(n)
    {
        n &= n - 1;
        ans ++;
    }
    printf("%d", ans);
    return orz;
}
```

这个代码是什么原理呢


------------


**首先，我们把这个$01$串转化为一个二进制数，也就是下面这行代码：**

```cpp
for(int i = 1; i <= 8; i ++)
{
    scanf("%c", &c);
    n = (n << 1) + (c - '0');
}
```

每次把 $n$ 给 乘$2$（即左移一位），然后在加上当前读到的数。


------------


**那么计算又是什么原理？**

我们看这句代码：

```cpp
n &= n - 1;
```

首先，$n$是我们处理好的$2$进制数。我们每次把$n$给$-1$

这会导致什么结果呢，我们来举个例子说明：

比如 ： 

`10100(2) - 1 = 10011(2)`  
`1010010000(2) - 1 = 1010001111(2)`  
`101000000(2) - 1 = 100111111(2)`

如上所见，我们找到了最低位的那个 $1$，把它变成了 $0$ 且把这之前的所有位都变为了 $1$。

我们只需要把原来的数 和 减一后的数 与运算一下，就可以把后面的 $1$ 给变为 $0$

再如上面的例子：

`10100(2) & 10011(2) = 10000(2)`  
`1010010000(2) & 1010001111 = 1010000000(2)`  
`101000000(2) & 100111111(2) = 100000000(2)`

很明显，我们每次操作都使得原$2$进制数里少了一个$1$。

所以我们只需要不断操作，直到原数为$0$即可。输出我们操作的次数即为答案。

于是有了如上代码。

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
using namespace std;

int n, ans;
char c;

int main()
{
    for(int i = 1; i <= 8; i ++)
    {
        scanf("%c", &c);
        n = (n << 1) + (c - '0'); //转化为2进制数
    }
    while(n)
    {
        n &= n - 1; //每次操作
        ans ++; //记录操作次数
    }
    printf("%d", ans);
    return orz;
}
```

---

## 作者：oistr (赞：7)

话说这第一题也太water了吧

大致扫了一眼，发现还没有用STL的 ~~（虽然我在考场上也没用）~~

## 全新STL解法
**使用STL的count()函数**

【函数简介】
count函数，可以在字符串里查找一个字符。方法为
```cpp
count(str.begin(),str.end(),'1')
```

其中begin()和end()为字符串起末位置

所以方法就有了。

## 贴代码

```
#include  <iostream>
#include <string>
#include <algorithm>//count函数所在库
using namespace std;
int main()
{
	string str;
	cin>>str;
	cout<<count(str.begin(),str.end(),'1')<<endl;//轻松AC
	return 0;
 } 
```


---

## 作者：chenpengda (赞：5)

~~嗯，这道题我要抢先发个题解~~

这边分享一下一些方法

#### 方法1    字符累加    （我的考试做法）

创造一个字符来输入

累加器开始是0

连续输入8次，每当遇到‘1’就累加

最后输出累加器

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	char a;
    int RP=0;
    for(int i=1;i<=8;i++)
    {
        cin>>a;
        if(a=='1')RP++;
    }
    cout<<RP;
    return 0;
}
```

注意事项：

- char字符中‘1’并不是1，实际上是49

- 记得return 0

- 文件读写不要忘，就是freopen

- 那些RP没有初始化的人，真是神奇！

 ~~RP++是我对比赛的期望~~

#### 方法2   字符串操作

可以输入一个string字符串

然后从0到8检索字符串每个字符  如果是1就累加

最后输出累加器

就像：这样？

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string a;
	int sum=0;
	cin>>a;
	for(int i=0;i<8;i++)
	{
		if(a[i]=='1')sum++;
	}
	cout<<sum;
	return 0;
} 
```

注意事项：

- 头文件加上cstring

- a[i]代表a的第i项，从0开始，到7！ 如果从1开始，那么恭喜你爆零了

~~也不一定，20%的数据都是0~~

- 还是一样，是字符‘1’不是数字1

#### 方法3：神奇的操作

你能看懂如下的代码吗？

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a;
	cin>>a;
	cout<<a%9;
	return 0;
} 
```

其实思路很简单，这是一个8位的01串，我们又知道一个数的数字和是它除以9的余数，所以就可以这样做啦！

---

## 作者：HoshinoTented (赞：5)

简单的入门题

题目要求是求出一段字符串中字符 1 的个数，那可以写出这样的代码：

```haskell
oneCount :: String -> Int
oneCount "" = 0
oneCount ('1':xs) = 1 + oneCount xs
oneCount (_:xs) = oneCount xs
```

但是想一想，Haskell 可是函数式语言，应该用函数式的方法解决问题，于是把眼光转到 `filter` 函数：

```haskell
filter :: (a -> Bool) -> [a] -> [a]
```

根据传入的判断函数过滤出需要的内容，而我们需要的内容就是字符 '1'，于是：

```haskell
oneCount :: String -> Int
oneCount str = length (filter (=='1') str)
```

补全 main 函数：

```haskell
main :: IO ()
main = do
    str <- getLine
    
    print (oneCount str)
```

内联：

```haskell
main :: IO ()
main = do
    str <- getLine
    
    print (length (filter (=='1') str))
```

Point-Free：

```haskell
main = getLine >>= print . length . filter (=='1')
```

最后，一行解决

~~垃圾 C++ 能一行吗？能这么简洁吗？~~

---

## 作者：includeCPP (赞：3)

本题比较简单，使用 char 数组或使用 string 都可，这里使用 string 并讲解几个新手易错点。

- 下标从 $0$ 开始。
- 注意 `s.size()` 函数是 `unsigned` 类型，不能直接参与 `int` 类型的运算，因此要采用 `for(int i=0;i<s.size();i++)` 来遍历字符串。
- 判断时将 `'1'` 写成 `1` 导致错误。

注意到本题保证输入的字符串长度一定为 $8$，且字符串中只包含字符 $0$ 和字符 $1$，不难发现后者是不必要的。对于前者，由于字符串长度固定，如果你不想使用 `s.size()` 函数，请务必注意循环条件中的上界，应写为 $i \le 7$ 或 $i<8$。

注意以上几点，因为字符串最大长度只有 $8$，因此我们开一个 $cnt$ 变量用于记录字符串中 $1$ 的个数，遍历整个字符串，当遇到字符 $1$ 时给 $cnt$ 加 $1$，最后输出 $cnt$ 即可。

```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
int main(){
	string s;
	cin>>s;
	int cnt=0;
	for(int i=0;i<s.size();i++){
		if(s[i]=='1')cnt++;
	}
	cout<<cnt;
	return 0;
} 
```

---

## 作者：GSQ0829 (赞：3)

### 思路：
因为是八个数字，所以我们需要进行以下几步：

- 定义一个字符串，输入它。
- 循环，从零到七。
- 判断这个位置上的字符串是不是一，是，计数器就加一。
- 最后，输出计数器。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
int ans = 0;

int main () {
    cin >> s;
	for (int i = 0; i <= 7; i++) {
		if (s[i] == '1') ans++;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Vct14 (赞：3)

题意：输入 $8$ 个数，求其中 $1$ 的个数。

简单模拟，遍历数组，遇到 $1$ 则计数器加一，计数器即为最后的答案。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	char a[10];
	cin>>a;
	int sum=0;
	for(int i=0; i<8; i++){
		if(a[i]=='1'){
			sum++;
		}
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：Il1_1_3 (赞：1)

# P5660 题解
## 题意
给定一个长度为 $8$ 的字符串，求字符串中 `1` 的个数。
### 法一：直接判断
每读入一位就判断一位，或者先读入再遍历判断。

代码：
```cpp
//逐位读入
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int ans=0; 
	for(int i=1;i<=8;i++)
    {
        char c=getchar();
        if(c=='1') ans++;
    }
    cout << ans << endl;
	return 0;
}
```
```cpp
//直接读入
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int ans=0; 
    string s;
    cin >> s;
	for(int i=0;i<8;i++)
        if(s[i]=='1') ans++;
    cout << ans << endl;
	return 0;
}
```
### 法二：数学
看到 `1` 的个数，和长度只有 $8$ 的字符串，你想到了什么？数字和！除以 $9$ 的余数！于是，一份~~高大上的玄学~~代码就打出来了！
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int p;
    cin >> p;
	cout << p%9 << endl;
	return 0;
}
```
### 法三：万能的 STL
看到 `0` 和 `1`，这不就是二进制吗！STL 中有一种数据结构叫做 `bitset`，可以直接读入进去。这里介绍一个在本题中用到的函数：
```cpp
p.count()
```
这个函数可以获取 $p$ 中 $1$ 的个数，于是这道题就结束了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
bitset <8> p;
int main()
{
    cin >> p;
    cout << p.count();
	return 0;
}
```
~~红题方法就是多……~~

---

## 作者：jiqihang (赞：1)

### 题意
此题与 NOIP 2018 普及组第一题很像。

给你一段字符串，求出其中 $1$ 的总数。
### 解法

相当于只有 $0$ 才需要不统计。

我们可以先读入字符串，如果不是 $0$，结果就加一（使用 $ans$ 记录），最后输出 $ans$。
### 代码

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string a;
	int ans=0;
        getline(cin,a);
	for(int i=0;i<a.size();i++)
{
		if(a[i]!='0')
		ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：1)

题解：[P5660 [CSP-J2019] 数字游戏](https://www.luogu.com.cn/problem/P5660)
#### 思路：
非常的简单。

题目给出了一个字符串，那么我们就可以先输入字符串 $s$，然后遍历字符串，用一个变量来统计 $1$ 的个数，每次判断是否 $s_{i}$ 为 $1$ 即可。

#### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    cin >> s;
    int ans = 0;
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '1') ans++;  // 判断是否是 1
    }
    cout << ans << '\n'; // 输出答案
    return 0;
}
```

---

## 作者：TianTian2008 (赞：1)

可以把这个 01 串看作一个二进制数 $x$，则一定有 $0\le x<256$。

题目要求串中的 1 的个数，那么相当于要求 $x$ 的 $\text{popcount}$，而我们是可以 $O(V)$ 预处理 $[0,V]$ 的 $\text{popcount}$ 的。

所以我们直接预处理 $[0,256)$ 的 $\text{popcount}$，然后输出 $x$ 的 $\text{popcount}$ 即可。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int ppc[256];
int main() {
    for(int i=1;i<256;++i)
		ppc[i]=ppc[i>>1]+(i&1);
    int x=0,y;
    for(int i=0;i<8;++i) {
        scanf("%1d",&y);
        x=x<<1|y;
    }
    printf("%d",ppc[x]);
    return 0;
}
```

---

## 作者：jr_linys (赞：1)

题目要求输入一个只包含 `0` 和 `1` 的字符串，求 `1` 的个数。  

使用 `string` 类型输入字符串，然后使用 C++11 引入的 foreach 循环的语言特性遍历字符串，如果该字符是 `1`,将答案增加。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	string s;cin>>s;
	int ans=0;
	for(char c:s) if(c=='1') ++ans;
	cout<<ans;
}
```

---

## 作者：sea_bird (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5660)。

## 前置知识

字符串，就是**由字符连接而成**的序列。

```cpp
#include<iostream>
#include<string>//字符类型的头文件
using namespace std;
int main()
{
	string s;//定义一个字符串变量 
	char ch;//定义一个字符变量
	cin>>s;
	cout<<s.size()<<endl;//输出字符串长度
	cout<<s[0]<<endl;//输出s的第一个字符 
	return 0;
}
```

# 题目大意

判断一个八位字符串中有多少个 $1$。

# 题目分析

直接定义一个字符串类型，便利字符串中每个字符判断是否为 $1$，统计数量后输出。

## Code

```cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
	int cnt = 0;
	string str;
	cin >> str;
	for(int i = 1;i <= str.size();i ++)//循环遍历每一个字符
	{
		if(str[i-1] == '1')//因为i从1开始，str的第一个字符下标为0，所以-1
		{
			cnt ++;
		}
	}
	cout<< cnt <<endl;
	return 0;
}
```

## 总结

读题的时候注意数据范围，不会做的可以看看的分点，看是否能借此拿分。

---

## 作者：Jerry_zpl (赞：0)

本题就是求一个字符串中有几个字符 `1`。\
定义变量 $cnt$ 统计即可。\
统计时注意一下两点：

- 如果是字符 `0`，就不用统计。
- 如果是字符 `1`，计数器 $cnt$ 加一。\
  由于题目没告诉我们输入有几个字符，所以我们用 `while(cin>>x)` 的格式输入更好。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int cnt=0;
	char c;
	while(cin>>c)
	{
		if(c=='1') cnt++;//如果碰到字符1,个数+1
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：Eason_cyx (赞：0)

直接输入字符串 $s$，遍历每个字符。

建立一个计数器 `cnt`，如果某个 $s_i=1$ 那么将 `cnt` 增加 $1$，答案就是最终的计数器。

```cpp
#include <iostream>
using namespace std;
int main()
{
    int cnt = 0;
    for(int i = 1;i <= 8;i++)
    {
        char x;
        cin >> x;
        if(x == '1') cnt++;
    }
    cout << cnt << endl;
    return 0;
}
```

---


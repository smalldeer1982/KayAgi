# 『MdOI R2』Car

## 题目描述

在 MdOI 市，为了推行环保，在城区内将限制某些车辆的通行，简称限行。一辆车是否被限行的依据是车牌号和当天的日期。

车牌号的编码方式是这样的：

- 前三位均为大写字母，表示所在的地区。

- 后五位为大写字母或数字，为识别码。**保证至少有一个数字**。

- 车牌号的尾号是从右往左的第一个数字。

MdOI 市在本题的编码方式下前三位是 `MDA`。例如，MdOI 市有一辆识别码为 `6780P` 的车，它的车牌号就是 `MDA6780P`，尾号是 $0$。

在 MdOI 市，限行规则如下：

1. 对于外来车（即前三位编号非 `MDA`），工作日（星期一至星期五）均限行。
2. 对于其他本地车，每天会限行某些尾号的汽车。星期一至星期五的限行尾号如下：

|   日期   |   星期一   |   星期二   |   星期三   |   星期四   |   星期五   |
| :------: | :--------: | :--------: | :--------: | :--------: | :--------: |
| 限行尾号 | $1$ 和 $9$ | $2$ 和 $8$ | $3$ 和 $7$ | $4$ 和 $6$ | $5$ 和 $0$ |

小 C 告诉了你她的车牌号，她想知道，她的车在星期一到星期五中的哪些日期会被限行。请你帮帮她。



## 说明/提示

【帮助与提示】

为方便选手调试代码，本题额外提供三组样例。由于样例较小，故放在一个剪贴板内。

[附加样例](https://www.luogu.com.cn/paste/g8pxrrh3)

---

【样例解释】
   
对于样例一，这个车牌号前三位为 `MDA`，因此是本地车牌。而尾号是 $6$，因此周四被限行。   
  
对于样例二，这个车牌号前三位为 `ZJO`，是外地车牌，因此周一至周五均被限行。

---

【数据范围】

**本题采用捆绑测试，即通过一个子任务的所有测试点才能拿到对应的分数。**
|子任务编号|特殊性质|分值|
|:-:|:-:|:-:|
|Subtask 1|前 $3$ 位不是`MDA`|$30$|
|Subtask 2|最后一位一定是数字|$30$|
|Subtask 3|无|$40$|

对于所有数据，满足前三位一定是大写英文字母，后面五位可能包含大写字母或者数字，且至少有一个数字。

## 样例 #1

### 输入

```
MDA7U16D
```

### 输出

```
0 0 0 1 0
```

## 样例 #2

### 输入

```
ZJOI2020```

### 输出

```
1 1 1 1 1
```

# 题解

## 作者：幻之陨梦 (赞：59)

$Solution:$

这道题是一道简单的分支题目，首先需要判断开头是否为 $MDA$ 然后再判断从右往左数的第一个数字为多少，再判断就行了。并且这题没什么坑点，放心做就行了

$code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
int len,s,i;
char ch[10];
int main()
{
    scanf("%s",ch);//输入给定的车牌号
    if(ch[0]!='M' || ch[1]!='D' || ch[2]!='A') printf("1 1 1 1 1"),exit(0);
    //如果不是MdOI市那么周一到周五全部限行
    len=strlen(ch);//算出字符串长度
    for(i=len-1;i>=3;i--)//从后往前循环，因为前三个是市的编号肯定是字符所以直接跳过即可
    {
        if(ch[i]>='0' && ch[i]<='9')//如果这一位是数字
        {
            s=ch[i]-'0';//就记录下来
            break;//跳出循环
        }
    }
    if(s==1 || s==9) printf("1 0 0 0 0");//如果 s 是 1 或 9 就是周一限行
    else if(s==2 || s==8) printf("0 1 0 0 0");//如果 s 是 2 或 8 就是周二限行
    else if(s==3 || s==7) printf("0 0 1 0 0");//如果 s 是 3 或 7 就是周三限行
    else if(s==4 || s==6) printf("0 0 0 1 0");//如果 s 是 4 或 6 就是周四限行
    else printf("0 0 0 0 1");//否则就是周五限行
    return 0;
}
```
如果这篇文章给予了你帮助，那您就点个赞再走吧，Thanks♪(･ω･)ﾉ

---

## 作者：yummy (赞：20)

## A. Car
考点：循环语句，分支语句，简单字符串。

### 一些活动
如果您能够提供**非C/C++** 的标程，可以在评论区发送**剪贴板链接**，择优加入题解，方便其他语言选手。

如果本题数据让某些错解通过，或者你有一些有意思的车牌，也请在评论区写上车牌（有简要理由更好），经审核后加入数据。

### Subtask 1
根据题意，外地车每天都限行，直接输出`1 1 1 1 1`即可。

代码略。
### Subtask 2
由于最后一位是数字，故尾号一定是最后一位。

如果我们直接判断，要写5个if语句，代码就会非常累赘，写起来较为繁琐。

你可以选择开一个大小为10的数组，表示每个尾号在周几限行。但是同样比较繁琐。

观察每天限行的车牌号，发现除了周五，每天限行的尾号和都是10。

我们可以把前4天用一个for循环解决，只特判周五就好了。

代码略。
### Subtask 3

Subtask 3和Subtask 2的唯一区别就是尾号不一定在最后一位了。

因此，我们需要通过一个for循环找到尾号的位置。

根据定义，尾号是从右往左第一个数字。我们可以开一个变量寻找尾号的位置。代码基本同Subtask 2。

**由于其他语言标程可能持续更新，所以其他语言将放入[剪贴板](https://www.luogu.com.cn/paste/c6yv5w8n)，减轻管理员负担。**

C++标程：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[10];
int main()
{
	scanf("%s",s);
	if(s[0]!='M' || s[1]!='D' || s[2]!='A')//判断外地车，虽然substr也能截取子串，但是位数少时直接写方便。
		puts("1 1 1 1 1");//puts("a")等价于printf("a\n");
	else
	{
		int w;
		for(w=7;s[w]>'9';w--);//判断尾号，for可以循环空语句
		for(int i=1;i<5;i++)
			if(s[w]==i+48 || s[w]==58-i)//'0'的ASCII码为48
				printf("1 ");
			else
				printf("0 ");
		if(s[w]=='5' || s[w]=='0')//判断周五
			puts("1");
		else
			puts("0");
	}
    return 0;
}
```

---

## 作者：songxiao (赞：9)

红题的字符串问题，不是很难。

**主要思路**：输入-确定尾号-是否外来-打表输出。

但有**小坑点**（本人亲测），认真点就行，都在注释里。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    char c[10]; //记录车牌
    for(int i=0;i<8;i++)
        cin>>c[i];  //循环输入车牌（也可以一次输入，因为char很特殊）
    if(c[0]!='M'||c[1]!='D'||c[2]!='A') //注意是“||”不是“&&”！也不要忘了单引号
    {
        cout<<"1 1 1 1 1";  //如果不是MDA开头的外来车的直接输出
        return 0;   //结束程序
    }
    for(int i=7;i>2;i--)    //从右往左找数字，注意是“--”不是“++”！
    {
        if(c[i]>='0'&&c[i]<='9')    //如果是数字，注意单引号，因为是char
        {
            c[8]=c[i];  //确定尾号
            break;  //退出循环
        }
    }
    switch(c[8])   //switch不会的自己百度 
    {   //打表，要注意准确读题！
        case '0':   //注意要加单引号！因为是char
            cout<<"0 0 0 0 1";  //输出答案
            return 0;   //直接结束程序
        case '1':
            cout<<"1 0 0 0 0";
            return 0;
        case '2':
            cout<<"0 1 0 0 0";
            return 0;
        case '3':
            cout<<"0 0 1 0 0";
            return 0;
        case '4':
            cout<<"0 0 0 1 0";
            return 0;
        case '5':
            cout<<"0 0 0 0 1";
            return 0;
        case '6':
            cout<<"0 0 0 1 0";
            return 0;
        case '7':
            cout<<"0 0 1 0 0";
            return 0;
        case '8':
            cout<<"0 1 0 0 0";
            return 0;
        case '9':
            cout<<"1 0 0 0 0";
            return 0;
    }
    return 0;   //结束（其实这里可以省略）
}
```

---

## 作者：一扶苏一 (赞：8)

### Analysis

先把不是本地车的判掉，然后从最后一位开始枚举，碰到数字停下就可以找到尾号。

注意到对于周一到周四，第 $i$ 天被限行的车的尾号要么是 $i$ 要么是 $10 - i$，因此可以用 `for` 循环去规避掉手写五个 `if` 判定。如果前四天都没有被限号，那意味着第五天一定会被限号喽。

### Code

```cpp
#include <cctype>
#include <string>
#include <iostream>

std::string s;

bool check() {
  if ((s[0] != 'M') || (s[1] != 'D') || (s[2] != 'A')) {
    puts("1 1 1 1 1");
    return true;
  }
  return false;
}

int main() {
  std::cin >> s;
  if (check()) return 0;       // 判掉外地车 
  int k = 7;
  while (!isdigit(s[k])) --k;
  k = s[k] - '0';              // 找到尾号 
  bool flag = false;           // flag 表示前 4 天是否被限号 
  for (int i = 1; i < 5; ++i) if ((k == i) || (k == (10 - i))) {  // 第 i 天被限行 
    std::cout << 1 << ' ';
    flag = true;               // 该天被限号则标记一下 flag。 
  } else {
    std::cout << 0 << ' ';
  }
  std::cout << (flag ? 0 : 1) << std::endl; // 如果前 4 天被限号了即为 0，否则为 1。 
  return 0;
}
```





---

## 作者：梦幻之旅 (赞：3)

# **P6382 『MdOI R2』Car [题目链接](https://www.luogu.com.cn/problem/P6382)**  

------------
 首先， 此题说了 _对于外来车（即前三位编号非 MDA），工作日（星期一至星期五）均限行。_ 所以我们要判断它头三个字符是否为MDA，如果不是，则输出1 1 1 1 1，并且结束程序
```
	if(s[0]!='M'||s[1]!='D'||s[2]!='A') {//如果不等于MDA，则输出“1 1 1 1 1”
		cout<<"1 1 1 1 1\n";
		return 0;
	}
```
排除了外来车辆，我们来寻找尾号的位置
```
int len=s.size()-1;//定义尾号的位置为s.size()-1
	for(int i=len;i>=0;i--){
		if(s[i]<'0'||s[i]>'9') {
			len--;//若不是数字，则把位置建议
		}
		else break;//否则结束循环
	}
```
找出了位置，我们开始判断本地车的限行时间
```
        if(s[len]=='1'||s[len]=='9') cout<<"1 ";
	else cout<<"0 ";//如果尾号为1或9，则输出1（限行），否则输出0（不限行）
	if(s[len]=='2'||s[len]=='8') cout<<"1 ";
	else cout<<"0 ";//如果尾号为2或8，则输出1（限行），否则输出0（不限行）
	if(s[len]=='3'||s[len]=='7') cout<<"1 ";
	else cout<<"0 ";//如果尾号为3或7，则输出1（限行），否则输出0（不限行）
	if(s[len]=='4'||s[len]=='6') cout<<"1 ";
	else cout<<"0 ";//如果尾号为4或6，则输出1（限行），否则输出0（不限行）
	if(s[len]=='5'||s[len]=='0') cout<<"1 ";
	else cout<<"0 ";//如果尾号为5或0，则输出1（限行），否则输出0（不限行）
```
**完成**


------------
[这测试点什么鬼](https://www.luogu.com.cn/record/32952808)
------------
完整没注释代码：
```
#include<bits/stdc++.h>
using namespace std;
string s;
int main(){
	cin>>s;
	if(s[0]!='M'||s[1]!='D'||s[2]!='A') {
		cout<<"1 1 1 1 1\n";
		return 0;
	}
	int len=s.size()-1;
	for(int i=len;i>=0;i--){
		if(s[i]<'0'||s[i]>'9') {
			len--;
		}
		else break;
	}
	if(s[len]=='1'||s[len]=='9') cout<<"1 ";
	else cout<<"0 ";
	if(s[len]=='2'||s[len]=='8') cout<<"1 ";
	else cout<<"0 ";
	if(s[len]=='3'||s[len]=='7') cout<<"1 ";
	else cout<<"0 ";
	if(s[len]=='4'||s[len]=='6') cout<<"1 ";
	else cout<<"0 ";
	if(s[len]=='5'||s[len]=='0') cout<<"1 ";
	else cout<<"0 ";
	return 0;
}
```


---

## 作者：asasas (赞：3)

作为月赛的送分题，这题可以说是很良心的了。按照题意模拟即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	string a;
	int qq,ok=0;
	cin >> a;
	if (a[0]!='M'||a[1]!='D'||a[2]!='A') cout << "1 1 1 1 1";//处理不是本地的情况
	else {
		for (int i=a.size()-1;i>=0;i--){//因为是最后一个数字，所以从后往前找，找到直接退出
			if (a[i]=='1'||a[i]=='9') qq=1,ok=1;
			if (a[i]=='2'||a[i]=='8') qq=2,ok=1;
			if (a[i]=='3'||a[i]=='7') qq=3,ok=1;
			if (a[i]=='4'||a[i]=='6') qq=4,ok=1;
			if (a[i]=='0'||a[i]=='5') qq=5,ok=1;//记录每种数字的限行情况 
			if (ok) break;//退出循环
		}	
		for (int i=1;i<=5;i++)
	 if (qq!=i) cout << 0 << ' ' ;//不是限行的输出0
	 else cout << 1 << ' ';//是限行的输出1
	}

} 
```


---

## 作者：Scrutiny (赞：3)

不是很难的字符串问题。

思路：先判断前三位是否是```MDA```，如果不是直接输出```1 1 1 1 1```后```return 0```

否则循环从后往前判断每一位是否是数字，如果是则记录这个字符后```break```（显然不会$TLE$）。

最后用```if```判断哪几天限行，分别输出即可。

### CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,m;
int main(){
	string s;
	getline(cin,s);
	i=7;
	if(s[0]!='M'||s[1]!='D'||s[2]!='A'){
		cout<<"1 1 1 1 1";
		return 0;
	} 
	else{
		while(1){
			if('0'<=int(s[i])&&int(s[i])<='9'){
				m=int(s[i])-'0';
				break;
			}
			--i;
		}
		if(m==1||m==9){
			cout<<"1 0 0 0 0";
			return 0;
		}
		if(m==2||m==8){
			cout<<"0 1 0 0 0";
			return 0;
		}
		if(m==3||m==7){
			cout<<"0 0 1 0 0";
			return 0;
		}
		if(m==4||m==6){
			cout<<"0 0 0 1 0";
			return 0;
		}
	}
	cout<<"0 0 0 0 1";
	return 0;
} 
```


---

## 作者：CSP_Sept (赞：2)

## 前置知识

**模拟**。

## 过程

### Subtask 1

输出 `1 1 1 1 1` 即可。

### Subtask 2

定义一个字符串 $s$，表示车牌号。其中 $s_1,s_2,s_3$ 组成了表示「所在的地区」的编码。

则车牌的尾号 $tail$ 一定为 $s_8$。

直接使用 `if-else` 语句判断 $s_8$ 即可。

### Subtask 3

需要使用一个循环来计算尾号，代码：

```cpp
for(int i=s.size()-1;i>=0;i--)//或 int i=7
    if(s[i]>='0'&&s[i]<='9'){//若 s_i 为数字,则进行下面的操作
        tail=s[i]-'0';
        break;//跳出循环
    }
```

另外，输出也可以这样：

```cpp
cout<<(tail==1||tail==9)<<' '<<(tail==2||tail==8)<<' '<<(tail==3||tail==7)<<' '<<(tail==4||tail==6)<<' '<<(tail==5||tail==0);
```

## 代码

完整代码：

```cpp
#include <iostream>
#include <cstring>

using namespace std;
string s;
int tail;
int main(){
    cin>>s;
    for(int i=s.size()-1;i>=0;i--) if(s[i]>='0'&&s[i]<='9') {tail=s[i]-'0';break;}
    if(s[0]!='M'||s[1]!='D'||s[2]!='A'){cout<<"1 1 1 1 1";return 0;}
    cout<<(tail==1||tail==9)<<' '<<(tail==2||tail==8)<<' '<<(tail==3||tail==7)<<' '<<(tail==4||tail==6)<<' '<<(tail==5||tail==0);
    return 0;
}
```

---

## 作者：_cmh (赞：1)

so，这题很难么

本题分两个情况走：

- 前三位不是$MDA$的——直接输出“1 1 1 1 1”结束

- 前三位是$MDA$的——再分情况判断：

注意：因为每个本地车末尾是不可能有两个数字的，所以只可能有一个1。

尾号如果是 $1$ 或 $9$ ，说明是周一限行，所以输出 ```1 0 0 0 0```。

尾号如果是 $2$ 或 $8$ ，说明是周二限行，所以输出 ```0 1 0 0 0```。

尾号如果是 $3$ 或 $7$ ，说明是周三限行，所以输出 ```0 0 1 0 0```。

尾号如果是 $4$ 或 $6$ ，说明是周四限行，所以输出 ```0 0 0 1 0```。

尾号如果是 $5$ 或 $0$ ，说明是周五限行，所以输出 ```0 0 0 0 1```。

给出代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
char a,b,c;
string s;
int main(){
    cin>>a>>b>>c>>s;
    if(a=='M'&&b=='D'&&c=='A'){//本地车 
        int l=s.length()-1;
        while(isalpha(s[l])) l--;//搜末尾的数字的位置 
        if(s[l]=='1'||s[l]=='9') cout<<"1 0 0 0 0";//周一限行 
        else if(s[l]=='2'||s[l]=='8') cout<<"0 1 0 0 0";//周二限行 
        else if(s[l]=='3'||s[l]=='7') cout<<"0 0 1 0 0";//周三限行 
        else if(s[l]=='4'||s[l]=='6') cout<<"0 0 0 1 0";//周四限行 
        else if(s[l]=='0'||s[l]=='5') cout<<"0 0 0 0 1";//周五限行 
    }
    else{//外地车 
        cout<<"1 1 1 1 1";
        return 0;
    }
    return 0;
}
```


提交记录：https://www.luogu.com.cn/record/32821636

点个赞呗~

~~（蒟蒻已经逃跑了，没法和泥萌说再见了）~~

---

## 作者：hensier (赞：0)

这道题非常适合训练$Python$，其用到了基本的$bool,str$类型的判断，以及格式化输出（用到了空格）。

首先，我们需要将车牌尾部的字母进行去尾。具体的方式是可以设置一个充当指针的变量，然后不停地前移，直到所指向的字符是数字为止。

这样我们就得到了尾号的下标。接下来，我们对开头为$MDA$的号码进行特判——直接输出$5$个$1$即可。

接着，我们就可以进行逐一的枚举——对尾号分别为$1$或$9$，$2$或$8$，$3$或$7$，$4$或$6$，$5$或$0$进行判断，如果是就输出$1$，否则输出$0$。对于$Python$来说，数据类型要求比$C/C++$高一些，所以要用强制类型转换，否则输出的是$false/true$，而不是$0/1$。这是一个需要注意的细节问题。

这样下来，我们就完成了对本题的分析。

$Python$代码：

```python
c=str(input())# str（字符串）类型输入
i=7# 初始指针为7（原因：长度为8，而下标从0开始，因此初始为7）
while(c[i] < '0' or c[i] > '9'):# 如果当前指向字符不为数字，指针就左移，具体实现是i-=1
    i -= 1
if(c[0] != 'M' or c[1] != 'D' or c[2] != 'A'):# 特判开头为MDA的情况
    print('1 1 1 1 1')# 可以直接以字符串形式输出
else:
    print(int(c[i] == '1' or c[i] == '9'),end=' ')# 这里可以直接将bool值转换为int值输出，但是要注意空格问题——必须在尾部添加end=' '才能加空格，否则默认换行
    print(int(c[i] == '2' or c[i] == '8'),end=' ')
    print(int(c[i] == '3' or c[i] == '7'),end=' ')
    print(int(c[i] == '4' or c[i] == '6'),end=' ')
    print(int(c[i] == '5' or c[i] == '0'))# 最后可以不用空格
```

---


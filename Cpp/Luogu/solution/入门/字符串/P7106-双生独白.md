# 双生独白

## 题目背景

我喜欢安静，你热爱喧闹；我忠于温暖，你酷爱凉爽。

如果任何事物都有反面，那拼接这个世界的颜色呢？

只有白与黑吗？

## 题目描述

为了形式化地描述颜色，我们引入 **RGB 颜色值**，用三元组 $(r,g,b)$ 表示一种颜色，其中 $r,g,b$ 分别为该颜色的 **R 值**、**G 值**、**B 值**，满足 $0 \le r,g,b \le 255$ 且皆为**十进制整数**。

显然，这套颜色系统一共可以表示 $256 \times 256 \times 256 = 16\,777\,216$ 种不同的颜色。对于颜色 $(r,g,b)$，定义其**反色**的 RGB 颜色值为 $(255-r,255-g,255-b)$。

然而人们发现，单纯地使用 RGB 颜色值很不方便，复制颜色时要复制三个值。

于是诞生了**十六进制颜色码**，即形如 `#EBA932` 长度为 $7$ 的字符串。具体而言：

- 字符串的第一位是 `#`，为颜色码标识符。
- 字符串的第二、三位是十六进制数码，拼成的十六进制数等于十进制下所示颜色的 R 值。
- 字符串的第四、五位是十六进制数码，拼成的十六进制数等于十进制下所示颜色的 G 值。
- 字符串的第六、七位是十六进制数码，拼成的十六进制数等于十进制下所示颜色的 B 值。

**十六进制数码**从小到大包含 `0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`，`8`，`9`，`A`，`B`，`C`，`D`，`E`，`F`，注意 `A`，`B`，`C`，`D`，`E`，`F` 均为**大写**。

现在你收到了一组十六进制颜色码，请你输出其反色的十六进制颜色码。

*提示：颜色的 RGB 值与十六进制码之间可以相互转换（参考样例解释 #2）*

## 说明/提示

**【样例解释 #1】**

转换后原色的 RGB 值为 $(255,255,255)$，反色的 RGB 值为 $(0,0,0)$，对应十六进制码 `#000000`。

**【样例解释 #2】**

转换后原色的 RGB 值为 $(235,169,50)$，反色的 RGB 值为 $(20,86,205)$，对应十六进制码 `#1456CD`。

为避免理解偏差，此处特别解释 `#EBA932` 转换后 B 值为 $50$ 的原因：提取字符串的第六、七位，拼成的十六进制数为 $(32)_{16}$，则有 $(32)_{16} = 3 \times 16^1 + 2 \times 16^0 = 50$。

----

**【数据规模与约定】**

本题共有 10 个测试点，每通过一个测试点可获得 10 points。

对于 $10\%$ 的数据，为样例 #1。

对于另外 $30\%$ 的数据，输入与输出字符串均不包含大写字母。

对于所有的数据，保证给定字符串为合法十六进制颜色码。

## 样例 #1

### 输入

```
#FFFFFF```

### 输出

```
#000000```

## 样例 #2

### 输入

```
#EBA932```

### 输出

```
#1456CD```

# 题解

## 作者：一扶苏一 (赞：42)

#  P7106 双生独白

### Analysis

众所周知，C/C++ 选手可以使用 `scanf` 直接读入 16 进制数字：``scanf("%x", &a)``。

对于输出 16 进制数字，可以使用 `printf("%x", a)` 或 `printf("%X", a)`，其中 `x` 的大小写控制的是输出十六进制中字母字符的大小写。例如 `printf("%x %X", 10, 10);` 的结果为 `a A`。

下一个问题是如何把读入割裂成三个数：可以先读入到字符数组里，然后使用 `memcpy` 把两个字符从数组中拷贝出来，再用 `sscanf` 从字符数组中读入数据，其使用方式为 `scanf(A, B, ...)`，其中 `A` 表示目标数组，B 与后面的内容与 `scanf` 使用方法一致。例如，从字符数组 $s$ 中读入一个整数的写法是 `scanf(s, "%d", &a)`。`memcpy` 的使用方式为 `memcpy(t, s, x)`，其中 `t` 是拷贝的目标数组，`s` 是被拷贝位置的第一个指针，x 是被拷贝的字节数。例如，从从 `s` 中拷贝两个字符到 `t` 的写法是 `memcpy(t, s, 2 * sizeof (char))`。

字符数组的数组名本质上是一个指针，因此可以通过传入头指针的方式控制从哪一位开始读入/拷贝。例如 `scanf(s + 1, "%d", &a)` 表示从数组 $s$ 中第一位（下标从 0 编号）起进行读入，`memcpy(t, s + i, 2 * sizeof(char))` 表示从第 $i$ 位起开始进行拷贝，拷贝两个字符。

最后一个问题是，如果输出某个数的十进制值不超过 $15$，那么输出结果会少一位，因此需要进行特判。好像有一些奇技淫巧可以避免这个问题，但是我并没有查到（。

于是可以方便的写出如下代码：

```cpp
#include <cstdio>
#include <cstring>

char s[10];
char t[3];

int main() {
  scanf("%s", s);
  putchar('#');
  for (int i = 1; i < 6; i += 2) {
    int x;
    memcpy(t, s + i, 2 * sizeof(char));
    sscanf(t, "%x", &x);
    x = 255 - x;
    if (x < 16) putchar('0');
    printf("%X", x);
  }
  return 0;
}
```

upd：经过查阅资料，发现可以用 `scanf("%2d", &a)` 控制只读取两位数字，`printf("%02d", a)` 控制输出两位数字并补前导 $0$。因此可以写出更简短的代码如下：

```cpp
#include <cstdio>

char s[10];

int main() {
  scanf("%s", s);
  putchar('#');
  for (int i = 1, x; i < 6; i += 2) {
    sscanf(s + i, "%2x", &x);
    printf("%02X", 255 - x);
  }
  return 0;
}
```



---

## 作者：Eason_AC (赞：35)

## Content
给定一个 **十六进制颜色码**（一个长度为 $7$ 的字符串，意义详见题面），请输出其反色的十六进制颜色码。

**数据范围：颜色的 R,G,B 值保证在 $255$ 以内。**
## Solution
我们不妨设给定的两个特殊的限制为 Subtask 1 和 Subtask 2，其余的数据分为 Subtask 3。然后我们来按照三个 Subtask 分别讲解。
### Subtask 1
这个对于萌新来说都很容易上手，直接输出 `#000000` 即可。
### Subtask 2&3
开始之前我们有必要讲一讲十六进制。当然如果对此很熟悉的话可以跳过去。

正如题面所说，十六进制数码从小到大包括 $\textsf{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}$ 十六个数码，正如其名，这样的数字 **满十六进一**，而不像我们通常所用的十进制一样 **满十进一**，而又因为没有这么多的数字可以存十六进制数码，因此借用了字母表中的大写字母。

那么如何将十六进制转换成十进制呢？我们知道，十六进制的数 **满十六进一**，那么我们如果进了一，这一位上面的十六个单位全部转化为了它前面这一位上的一个单位。所以，我们不妨假设最低位为第 $0$ 位，那么一个十六进制数第 $i$ 位上的数字就可以转化为 $num_i\times16^i$。那么，十进制转换成十六进制的话也就很简单了，直接从大到小提取出一个数乘以 $16$ 的次幂，最后拼合在一起就好。

这么说可能不是很友好，我就拿样例 $2$ 来具体操作一番吧。

```
input:
#EBA932
output:
#1456CD
```

然后我们来看如何操作：

首先是 R 值。提取出来的话就是 $\text{EB}$，然后我们清楚，$\text{E}$ 代表 $14$，$\text{B}$ 代表 $11$，所以 $(\text{EB})_{16}=14\times16^1+12\times16^0=14\times16+12=235$。然后他的反色就是 $255-235=20$。所以我们提取出 $1\times16$ 的 $1$ 次幂和 $4\times 16$ 的 $0$ 次幂，那么最终的 R 值就是 $14$。

G 值和 B 值的操作同上，想必无需多讲了。

那么对于 Subtask 2，我们的任务就很简单，直接将十六进制数字转化成十进制数字连特判字母都不需要，然后再根据题目里面给出的式子，我们拿这个数去减 $255$，得到的就是反色的十进制数码。Subtask 3 就需要特判一下是不是字母了。然后我们再把十进制的反色数码转换成十六进制的就好了。而且特别良心的是，这里的数字都只有两位，所以特别好直接模拟操作。

---

所以说这道题目就做完了

……吗？

虽然说问题不大，但是从十六进制转到十进制再转回十六进制是不是太麻烦了？

能否直接十六进制之间互相转换呢？

也就是说，相当于一个，**十六进制减法**之类的东西？

我们再来看看，我们可以自己手玩一下，发现 $(255)_{10}=(\text{FF})_{16}$。那么不就可以弄个减法直接减一下就好了？而且可以很惊喜的发现，这减法居然还不需要考虑退位！那么对于每个数位直接拿 $15$（$\text{F}$ 代表 $15$）减去这个数码就好了。

最后给刚学 OI 的萌新们弄个温馨提示：C++ 里面是可以直接给一个变量赋值为一个十六进制数的，方法是在这个十六进制数之前加一个 $\textsf{0x}$，然后所有在这道题目里面大写的字母全部都要转化为小写。还给你们几个数，用来以后初始化最小值用的：$\textsf{0x3f3f3f3f},\textsf{0x7fffffff}$，这种类型的数将会伴随着你们整个 OI 生涯，直到 AFO（Away from OI，也就是退役）。当然，至少对于快要 AFO 的我是这样子的。

最后，祝各位 NOIP2020 RP++！
## Code 1
赛时代码，使用了 map 来映射，各位也可以尝试不使用 map 来实现这种做法。

```cpp
const string ans = "0123456789ABCDEF";
string s;
map<char, int> mp;

int main() {
	for(int i = 0; i < 16; ++i) mp[ans[i]] = i;
	cin >> s;
	int r1 = mp[s[1]] * 16 + mp[s[2]], r2 = mp[s[3]] * 16 + mp[s[4]], r3 = mp[s[5]] * 16 + mp[s[6]];
	int g1 = 255 - r1, g2 = 255 - r2, g3 = 255 - r3;
	printf("#%c%c%c%c%c%c", ans[g1 / 16], ans[g1 % 16], ans[g2 / 16], ans[g2 % 16], ans[g3 / 16], ans[g3 % 16]);
	return 0;
}

```
## Code 2
怕各位看不懂这么长的一大串三目运算符，特地在下面写了等效语句，并附上详尽注释。
```cpp
string s;

int main() {
	cin >> s;
	F(i, 0, 6) putchar(i == 0 ? '#' : (isdigit(s[i]) ? (s[i] - '0' <= 5 ? 'A' + (5 - (s[i] - '0')) : 15 - (s[i] - '0') + '0') : 5 - (s[i] - 'A') + '0'));
	//以下为等效语句 
	F(i, 0, 6) {
		if(i == 0) putchar('#');	//第一位要输出# 
		else if(isdigit(s[i])) {	//判断是否是数字，可以直接调用isdigit函数 
			if(s[i] <= '5') putchar('A' + (5 - (s[i] - '0')));	//如果数字小于等于5，那么反色数码肯定是一个字母，所以需要特判一下
			/*
				我们发现，这个数码比 0 差多少，反色数码比 A 就要多多少 
				所以直接加上这个差值即可 
			*/ 
			else putchar(15 - (s[i] - '0') + '0'); 	//直接拿这个数去减 15 然后再转化为字符 
		} else putchar(5 - (s[i] - 'A') + '0');		//否则肯定会是一个大写字母
		/*
			我们发现，这个数码比 A 差多少，反色数码比 0 就要多多少 
			所以直接加上这个差值即可 
		*/
	}
	return 0;
}
```

都看到这里了，点个赞再走呗qwq。

---

## 作者：Thomas_Cat (赞：21)

不难发现，这题就是一个找规律的题目。

现在给出一个 $16$ 进制下的数字，我们的简单思路如下：

设这个 $16$ 进制下的数字为 $\alpha$。

$(\alpha)_{16} \to (\alpha)_{10} \to (256-\alpha)_{16}$。

但是这样比较的麻烦。

在尝试的过程中，我们发现一个 $16$ 进制的数 $\theta$ 在使用 $256$ 减去的时候会变成 $16$ 进制下的 $16- \theta$，于是我们得到一张表：

| 为转换前数字 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $A$ | $B$ | $C$ | $D$ | $E$ | $F$ |
| :----:  | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| **转换后数字**|  $F$ |  $E$ | $D$ | $C$ | $B$ | $A$ | $9$ | $8$ | $7$ | $6$ | $5$ | $4$ | $3$ | $2$ | $1$ | $0$ |

得出代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int check(char n){
    if(n=='0') return 0+1;
    if(n=='1') return 1+1;
    if(n=='2') return 2+1;
    if(n=='3') return 3+1;
    if(n=='4') return 4+1;
    if(n=='5') return 5+1;
    if(n=='6') return 6+1;
    if(n=='7') return 7+1;
    if(n=='8') return 8+1;
    if(n=='9') return 9+1;
    if(n=='A') return 10+1;
    if(n=='B') return 11+1;
    if(n=='C') return 12+1;
    if(n=='D') return 13+1;
    if(n=='E') return 14+1;
    if(n=='F') return 15+1;
    return 0;
}
int main(){
    char ch[10];
    char tmp[17]={0,'F','E','D','C','B','A','9','8','7','6','5','4','3','2','1','0'};
    cin>>ch;
    cout<<"#";
    for(int i=1;i<=6;i++){
        int a=check(ch[i]);
        cout<<tmp[a];
    }
    return 0;
}
```

[实测AC](https://www.luogu.com.cn/record/42755812)

---

## 作者：suyue1098765432 (赞：16)

这道题主要考察了读入的用法，这一说一下如何用scanf/printf和cin/cout读入输出。

```scnaf()```里```%X```是十六进制数(字母大写),一个```%*c```表示要读入一个字符但不保存，所以输入就是```"%*c%X```。

```printf()```输出的时候要6位并且补前导0，所以是```"%06X"```。

code:

```c
#include<stdio.h>
int main(){
	unsigned a;
	scanf("%*c%X",&a);
	printf("#%06X",(0xffffff-a));
	return 0;
}
```

对于```cin```,```hex```表示16进制,所以输入时应该先```getchar()```然后```cin>>hex>>a;```。

```cout```输出的时候```setw()```表示位数,```setfill()```表示补的前导,```setiosflags(ios::uppercase)```表示字母大写，```hex```表示16进制，所以是```cout<<'#'<<setw(6)<<setfill('0')<<setiosflags(ios::uppercase)<<hex<<(0xffffff-a);```。

code:

```cpp
#include<stdio.h>
#include<iostream>
#include<iomanip>
using namespace std;
int main(){	
	int a;getchar();cin>>hex>>a;
	cout<<'#'<<setw(6)<<setfill('0')<<setiosflags(ios::uppercase)<<hex<<(0xffffff-a);
   return 0;
}
```

---

## 作者：Allen_lml (赞：8)

介绍一种快读做法。

首先看如何判断一个字符是16进制数，就是看他的ASCII值是否在`'0'`到`'9'`或`'A'`到`'F'`之间。

因为快读会把不是数字的忽略掉，所以也会忽略`#`，就不用再单独判断了。

```
int trans(char ch){
	if(ch>='0'&&ch<='9')return ch-'0';
	if(ch>='A'&&ch<='F')return ch-'A'+10;
	return -1;
}
```

然后在套上快读模板,(注意进位时要乘16而不是10)。

```
int read(){
	int res;char ch=getchar();
	while(trans(ch)==-1)ch=getchar();
	while(trans(ch)!=-1)res=(res*16)+trans(ch),ch=getchar();
	return res;
}
```

快输的话就是如果这一位$x$如果小于$10$就```putchar(x+'0')```,否则```putchar(x+'A')```。

注意因为要保留6位，递归输出要判断位数而不是看是否为0。

```
void print(int x,int k){
	if(k==6)return ;
	print(x/16,k+1);
	x%=16;
	if(x<10)putchar(x+'0');
	else putchar(x-10+'A');
	return;
}
```

然后这道题就能用快读来解决了。

code:

```
#include<stdio.h>
int trans(char ch){
	if(ch>='0'&&ch<='9')return ch-'0';
	if(ch>='A'&&ch<='F')return ch-'A'+10;
	return -1;
}
int read(){
	int res;char ch=getchar();
	while(trans(ch)==-1)ch=getchar();
	while(trans(ch)!=-1)res=(res*16)+trans(ch),ch=getchar();
	return res;
}
void print(int x,int k){
	if(k==6)return ;
	print(x/16,k+1);
	x%=16;
	if(x<10)putchar(x+'0');
	else putchar(x-10+'A');
	return;
}
int main(){
	putchar('#');
	print(0xffffff-read(),0);
	return 0;
}
```

---

## 作者：Unordered_OIer (赞：6)

# P7106 题解

## 题意
把一个十六进制串看成 3 个数并分别求 255 减去这 3 个数所得结果转成十六进制

## 题解
一个很容易证明的结论是：对于每一位，设这一位为 $t$ ，答案都取十六进制中的 $10-t$ ，即可达到对三个数分别进行 255 减去这三个数的结果。

于是直接暴力判断即可，复杂度 $\mathcal O(7)$ 。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
void neg(char t){
	if(t=='0')return 'F';
	if(t=='1')return 'E';
	if(t=='2')return 'D';
	if(t=='3')return 'C';
	if(t=='4')return 'B';
	if(t=='5')return 'A';
	if(t=='6')return '9';
	if(t=='7')return '8';
	if(t=='8')return '7';
	if(t=='9')return '6';
	if(t=='A')return '5';
	if(t=='B')return '4';
	if(t=='C')return '3';
	if(t=='D')return '2';
	if(t=='E')return '1';
	if(t=='F')return '0';
}
int main(){
	string st;
	cin>>st;
	cout<<'#';
	for(ll i=1;i<st.size();i++)cout<<neg(st[i]);
	cout<<endl;
	return 0;
}
```

---

## 作者：Goodrage (赞：5)

## P7106 双生独白


### 题目分析
一道简单的模拟。给你一个包含 $3$ 个十六进制数的字符串，把十六进制转十进制，用 $255$ 减去后再转回十六进制，然后输出它。

一个 $16$ 进制颜色表示可以分成三段，以
```#EBA932```
为例：

```EB```
是 $R$ 值， 
```A9```
是 $G$ 值，
```32```
是 $B$ 值，

三个十六进制数可以分别转换。

所以模拟把三个十六进制数转成十进制，分别用 $255$ 减去他们，把三个差值转回十六进制，然后就可以分别输出了。

注意在最前面别忘了井号。


### 代码

#### 头文件+字符列表

```cpp
#include<bits/stdc++.h>
#define ah 255
using namespace std;
char col[18]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
```

没什么好说的，数组 $col$ 是 $16$ 进制数对应字符，其中 $col_i$ 对应十进制的   $i$ 。

#### 十六进制转十进制

```cpp
int sixtoten(char x,char y)//x表示十六进制数的从前往后数第一位，表示有几个16；y表示第2位，表示有几个1。
{
	int sum=0;//十进制数加和。
	for(int i=0;i<16;i++)//直接枚举这一位对应什么十进制数。
	{
		if(x==col[i])//第一位对应。
			sum+=16*i;
		if(y==col[i])//第二位对应。
			sum+=i;
	}
	return sum;
}
```

把十六进制数分成两位，用字符表示，然后去枚举每一位等于哪个十进制数，加和返回。
#### 十进制转十六进制

```cpp
void tentosix(int x)//x表示需要转的数。
{
	int mods=x%16;//表示几个16的位数，之前说到的第一位。
	int boo=(x-mods)/16;//表示1的位数
	printf("%c%c",col[boo],col[mods]);//直接对应。
	return;
}
```

这个就不用一一去枚举对应十六进制数了，因为 $col_i$ 对应十进制的$i$，可以直接找到。

#### 主函数

```cpp
int main()
{
	scanf("%c",&a);//第一个字符'#'号，没有用。
	printf("#");//输出第一个字符'#'，同样没有用，先输出了。
	for(int i=1;i<=3;i++)//一次读入两个字符表示一个十六进制数，所以是从1循环到3
	{
		scanf("%c%c",&a,&b);//十六进制数
		int color=sixtoten(a,b);//十六进制转十进制
		int coltwo=255-color;//255减去十进制数
		tentosix(coltwo);//十进制转十六进制，其中函数里已经有输出了。
	}
	return 0;
}

```
#### 完整代码

```cpp
//只供借鉴，请勿抄袭。
#include<bits/stdc++.h>
#define ah 255
using namespace std;
char col[18]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
char a,b;
int sixtoten(char x,char y)
{
	int sum=0;
	for(int i=0;i<16;i++)
	{
		if(x==col[i])
			sum+=16*i;
		if(y==col[i])
			sum+=i;
	}
	return sum;
}
void tentosix(int x)
{
	int mods=x%16;
	int boo=(x-mods)/16;
	printf("%c%c",col[boo],col[mods]);
	return;
}
int main()
{
	scanf("%c",&a);
	printf("#");
	for(int i=1;i<=3;i++)
	{
		scanf("%c%c",&a,&b);
		int color=sixtoten(a,b);
		int coltwo=ah-color;
		tentosix(coltwo);
	}
	return 0;
}

```

---

## 作者：小蒟蒻皮皮鱼 (赞：3)

T1

按照题意模拟。

我这里是写了两个函数。

一个把 int 转成 char 。

```cpp
char vv(int x1)
{
	if(x1 <= 9) return '0' + x1;//0~9
	else return 'A' + (x1 - 10);//A~F
}
```

一个把 char 转成 int 。

```cpp
int v(char a)
{
	if(a >= '0' && a <= '9') return a - '0';//数字
	else if(a >= 'A') return a - 'A' + 10;//字母
}
```

然后按照题目进行对应的操作。

对于给定的字符，先将他转换成 int ，再用题目给的规则转换成他的反码，最后转换回 char。

由于每两位是一个颜色，所以我这里是每两位转换一次。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt;
char s1[10], s2[10];
int v(char a)
{
	if(a >= '0' && a <= '9') return a - '0';
	else if(a >= 'A') return a - 'A' + 10;
}
char vv(int x1)
{
	if(x1 <= 9) return '0' + x1;
	else return 'A' + (x1 - 10);
}
int w(char a, char b)
{
	int ans = 0;
	int x = v(a), y = v(b);
	ans = y + x * 16;
	return 255 - ans;
}
void work(int a)
{
	int x1 = a % 16, x2 = a / 16;
	s2[cnt++] = vv(x2);
	s2[cnt++] = vv(x1);
}
int main()
{
	cin>>s1;
	int a = w(s1[1], s1[2]), b = w(s1[3], s1[4]), c = w(s1[5], s1[6]);
	s2[cnt++] = '#';
	work(a);
	work(b);
	work(c);
	cout<<s2;
}
```

不过这个题貌似有更简单的方法。用 scanf 是可以直接读入十六进制的。所以这个题只需要用 scanf 两位两位读入就可以了。~~然而我当时并没有想到~~

---

## 作者：L_sdcs (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7106)

### 题目大意

给你一个三个十六进制的数 $ a_1 $ $ a_2 $ $a_3$ ，依次输出 $ 255-a_1 $ $ 255-a_2 $ $ 255-a_3 $

### 大致思路

显然他给你的可以看成一个六位的十六进制数$a$。

它的反色就可以看成 $FFFFFF_{(16)}$ 减去$a$。

由于$FFFFFF_{(16)}$是十六进制下六位最大的数，就不存在借位问题。

我们只需一个一个判断即可。

~~由于我不会用switch，大家凑合着看看。~~

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string s;
	cin>>s;
	cout<<'#';//不要忘了先输出一个#
	for (int i = 1 ; i <= 6;++i)//因为它输入了一个#，所以从1开始
	{
		if (s[i] == '0') cout<<'F';
		if (s[i] == '1') cout<<'E';
		if (s[i] == '2') cout<<'D';
		if (s[i] == '3') cout<<'C';
		if (s[i] == '4') cout<<'B';
		if (s[i] == '5') cout<<'A';
		if (s[i] == '6') cout<<'9';
		if (s[i] == '7') cout<<'8';
		if (s[i] == '8') cout<<'7';
		if (s[i] == '9') cout<<'6';	
		if (s[i] == 'A') cout<<'5';
		if (s[i] == 'B') cout<<'4';
		if (s[i] == 'C') cout<<'3';
		if (s[i] == 'D') cout<<'2';
		if (s[i] == 'E') cout<<'1';
		if (s[i] == 'F') cout<<'0';//一个个暴力判断；
	}
	return 0;//return 0;
}
```
结束撒花

---

## 作者：ARGV (赞：2)

[先来传送门](https://www.luogu.com.cn/problem/P7106?contestId=13515)

~~（赞一下题目背景）~~

就A了一题，于是就兴奋地写了一篇题解。

看看样例找找规律先：

`#FFFFFF`成了`#000000`，`F`成了`0`。

`#EBA932`成了`#1456CD`，`E`成了`1`,`B`成了`4`,`A`成了`5`,`9`成了`6`,`3`成了`C`。

等等,16进制中，$F-F=0$、$F-E=1$、$F-B=4$、$F-A=5 $、$F-9=6$、$F-3=C$。规律发现!（高兴。

有了规律，代码就出来了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string a;
    cin>>a;
    for(int i=1;i<=6;i++){
        if(a[i]=='0')a[i]='F';
        else if(a[i]=='0')a[i]='F';
        else if(a[i]=='1')a[i]='E';
        else if(a[i]=='2')a[i]='D';
        else if(a[i]=='3')a[i]='C';
        else if(a[i]=='4')a[i]='B';
        else if(a[i]=='5')a[i]='A';
        else if(a[i]=='6')a[i]='9';
        else if(a[i]=='7')a[i]='8';
        else if(a[i]=='8')a[i]='7';
        else if(a[i]=='9')a[i]='6';
        else if(a[i]=='A')a[i]='5';
        else if(a[i]=='B')a[i]='4';
        else if(a[i]=='C')a[i]='3';
        else if(a[i]=='D')a[i]='2';
        else if(a[i]=='E')a[i]='1';
        else if(a[i]=='F')a[i]='0';
    }//根据规律可推导出其他变化
    cout<<a;
    return 0;
}
```

挑战码风最丑代码。



---

## 作者：CSP_Sept (赞：2)

### 题意简述

给定 $1$ 个**两位**的十六进制数，先转换成十进制数 $n$，再把 $(255-n)$ 转换成十六进制数。

你需要进行 $3$ 个数的转换。

### 方法实现

- 第一次转换，先把两个位数的十进制 $a,b$ 表示出来，转换成 $16a+b$。
  ```cpp
  int to_16_10(char c1, char c2){
	  int a, b;
	  if(c1 >= 'A') a = 10 + (c1 - 'A');
	  else a = c1 - '0';
	  if(c2 >= 'A') b = 10 + (c2 - 'A');
	  else b = c2 - '0';
	  return a * 16 + b;
  }
  ```
  
- 第二次转换，记第一次转换的结果为 $n$，直接用十六进制分别表示 $n\div 16,n\bmod 16$ 即可。
  ```cpp
  void to_10_16(int n){
	  int a = n / 16;
	  if(a >= 10) printf("%c", a - 10 + 'A');
	  else printf("%d", a);
	  a = n % 16;
	  if(a >= 10) printf("%c", a - 10 + 'A');
	  else printf("%d", a);
  }
  ```

结束。

### $\mathcal{Code}$

[Link](/paste/e54zdvkm)

---

## 作者：CGDGAD (赞：1)

### 题目大意

输出一个颜色的相反颜色。

**换种说法：**

输入一行 $7$ 个字符，其中第 $2-3, 4-5, 6-7$ 个字符分别对应三个十六进制数字。请用 $255$ 减去这三个数，并输出这三个数（用十六进制表示）。

例如： `#EBA932`，其中包含了三个十六进制数： `EB` `A9` `32`，用 $255$ 依次减去这三个数，分别为 `14` `56` `CD`，输出 `#1456CD` 即可。

### 做法

- 输入。并分别将三个数转换成十进制。
- 用255减去这三个数。
- 用十六进制输出。

### 奇怪的 `printf`

| 字符串 | 功能 | 例子 |
| :-- | :-- | :-- |
| `printf("%x", a)` | 输出一个整数的 $16$ 进制表达形式，其中 `A~F` 为小写 | $255$ -> `ff` |
| `printf("%X", a)` | 输出一个整数的 $16$ 进制表达形式，其中 `A~F` 为大写 | $255$ -> `FF` |
| `printf("%2X", a)` | 输出一个整数的 $16$ 进制表达形式，其中 `A~F` 为大写，且场宽为 $2$ | $10$ -> ` A`（空格+`A`） |
| `printf("%02X", a)` | 输出一个整数的 $16$ 进制表达形式，其中 `A~F` 为大写，且场宽为 $2$，不到 $2$ 位的时候前面用 $0$ 补全 | $10$ -> `0A` |

到我们需要的效果了。

### 代码

```cpp
#include <cstdio>
int turn(char c) { // 单个字符16进制转10进制
	if (c >= '0' && c <= '9') return (c - '0');
	else return (10 + c - 'A');
}
int main() {
	getchar(); // #
	char a = getchar(), b = getchar();
	const int r = 255 - turn(a) * 16 - turn(b);
	char c = getchar(), d = getchar();
	const int g = 255 - turn(c) * 16 - turn(d);
	char e = getchar(), f = getchar();
	const int bb = 255 - turn(e) * 16 - turn(f);
	printf("#%02X%02X%02X\n", r, g, bb);
	return 0;
}
```

---


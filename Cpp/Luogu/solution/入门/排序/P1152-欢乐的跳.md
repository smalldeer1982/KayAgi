# 欢乐的跳

## 题目描述

一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 $\{1,4,2,3\}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。

给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。


## 说明/提示

$1 \le n \le 1000$


## 样例 #1

### 输入

```
4 1 4 2 3
```

### 输出

```
Jolly
```

## 样例 #2

### 输入

```
5 1 4 2 -1 6```

### 输出

```
Not jolly```

# 题解

## 作者：花千树 (赞：217)

这道题其实不难，先把差求出来，再sort，和[1，n-1]做比较，如果不同，直接printf退出，如果一直到最后未能输出，则为欢乐的跳。

话不多说，上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>//sort必备头文件
#include<cmath>
using namespace std;
int a[1005],c[1005];//定义
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);//读入
    }
    for(int i=1;i<n;i++){
        c[i]=abs(a[i]-a[i+1]);//处理差
    }
    sort(c+1,c+n);
    for(int i=1;i<n;i++){
        if(c[i]!=i){printf("Not jolly\n");return 0;}//判断输出
    }
    printf("Jolly\n");//如果未能输出，则为正确答案
    return 0;//过程结束
}
```

---

## 作者：Mine_King (赞：133)

这题可以用桶排的思想做，也就是把差放在一个bool数组里，然后判断1--n-1是否满足。  
**代码**
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1001];
bool b[1000];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=2;i<=n;i++) b[abs(a[i]-a[i-1])]=true;
    for(int i=1;i<n;i++)
     if(!b[i])
     {
         cout<<"Not jolly";
         return 0;
     }
    cout<<"Jolly";
    return 0;
}
```
但是这份代码只能得60分，原因是他会出现差大于1000的情况，导致数组越界。而解决方案就是把数组开大点。  
但是，这不是正解，只是因为数据太弱，如果出现`100000000 -100000000`的情况，数组是存不了的。  
那么我们观察，发现要满足欢乐的跳，每种情况只能且必须出现一次，所以只要出现重复或者超出界限，就输出"Not jolly"。  
**代码**
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x,k,h;
bool a[1005];
int main()
{
    cin>>n;
    cin>>x;
    for(int i=2;i<=n;i++)
    {
        cin>>k;//使用骚操作不开数组输入
        h=abs(x-k);//由于需要多次用到，先把他的值赋给h
        if(h>=1&&h<n)//如果没有超出界限
        {
            if(a[h])//如果已经有过这种结果
            {
                cout<<"Not jolly";
                return 0;//return之后整个程序就不会运行了
            }
            else a[h]=true;//否则存储下来
        }
        else//超出界限
        {
            cout<<"Not jolly";
            return 0;
        }
        x=k;//把当前值赋给x存储，因为还要使用这个数
    }
    cout<<"Jolly"<<'\n';//如果没有停止运行，就满足条件，输出
    return 0;
}
```
## [完](https://www.luogu.org/blog/yhdhg1395754790/)

---

## 作者：EarthGiao (赞：47)

暴力、枚举       
一道非常水的暴力题目    
这道题其实有开两个数组和两个以上数组的解法    
但是我觉得这道题其实只需要开一个数组就够了   
开一个桶，每一次记录这个数和这个数前面的数    
将这两个数的差标为真    
输入完成之后，在从1枚举到n - 1如果里面有不是真的桶那就不符合“欢乐的跳”    
输出Not jolly然后return 0    
最后如果没有结束那就输出Jolly结束     

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>

using namespace std;
bool a[100000005];

int main()
{
	int n;
	int now,last = 0;
	scanf("%d",&n);
	for(int i = 1;i <= n;++ i)
	{
		scanf("%d",&now);
		a[abs(now - last)] = true;
		last = now;
	}
	for(int i = 1;i < n;++ i)
	{
		if(a[i] != true)
		{
			cout << "Not jolly" << endl;
			return 0;
		}
	}
	cout << "Jolly" << endl;
	return 0;
}
```


---

## 作者：空·白 (赞：46)

很明显这是一道水题，虽然一开始还是错了，但是这都不是重点；毕竟还是AC了。因为我~~~~比较菜~~~~（咳咳，跳过这个话题），所以只能在这里水入门题。
------------
下面是AC代码（附有注释）

也可以点击链接来看我的博客，不定期发一些题解（可能比较简单）

[题解 P1303 【A*B Problem】](https://www.luogu.org/blog/c1223074598/)

------------

```cpp
#include<bits/stdc++.h> //万能头不解释；
using namespace std;
long long int s[10000010];
long long int f[10000010]; //数组要开得大一点，不然会RE；可能int也能过，但我用ll；
long long int n,k,ans=0,a=0,j=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>s[i];
    	if(i!=1)
    	{
    		f[abs(s[i-1]-s[i])]++; //从第二个数开始与前一个数做差，然后存储；
    	}
    }
    for(int i=1;i<n;i++)
    {
    	if(f[i]!=0)
    	{
    		ans++; //判断有没有n-1个数；
    	}
    }
    if(ans==n-1)
    {
    	cout<<"Jolly";
    }
    else
    cout<<"Not jolly"; //这里一开始做的时候把“j”大写了，结果WA5个点；
}
```
第一次写题解，可能会有很多不足，如有不足之处，请指出。

---

## 作者：北北北北 (赞：29)

可以在读入数据的同时去做求差运算（别忘了取绝对值），这样当我们把所有数据都读入完后，我们就可以直接去搜了，即搜索我们所算出来的差的绝对值是否包含[1,n-1]这个闭区间里的所有整数，若包含则它就是Jolly数，反之则不是Jolly数。

PS: 还可以拿空间去换时间哦。。。这里我就不列出来了



------------
```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
   int a[1000];
   int i,j,n;

   scanf("%d", &n);
   for(i = 0; i < n; i++)
   {
      scanf("%d", &a[i]);
      if(i > 0)
      {
         a[i-1] = abs(a[i]-a[i-1]);
      }
   }
   for(i = 1; i < n && j != n-1; i++)
   {
      for(j = 0; j < n-1; j++)
      {
         if(a[j] == i)
         {
            break;
         }
      }
   }
   if(i == n)
   {
      printf("Jolly");
   }
   else
   {
      printf("Not jolly");
   }
   
   return 0;
}
```


---

## 作者：legends·never·die (赞：23)

##如何正确的~~水一波操作~~解简单的题##      

大佬们都去做难题了，而我只能在入门这里水一波，这道题数据较为水，所以过也可以水着过；
下面我们看一下代码

```

using namespace std;
int a[100001]={};
int bo[100001]={};    //这里一定要把数组开的足够大，否则会发生段错误
int main()
{
    int n,temp = 0,zc;     
    cin >> n;
    cin >> a[0];       //先输入第一个数，这样就可以不再循环里面判断
    for(int i = 1;i < n; i++)     //输入不解释
    {
        cin >> a[i];
        zc = abs(a[i - 1]-a[i]);   //我试了一下，发现如果直接把数组位置表达式放在中括号里面会CE，虽然不知道为什么，但是还是定义一个变量储存一下。
        if(bo[zc] == 0)      //如果我们所计算的相邻的两个差没有出现过，那么我们就计数加以
            temp++;
        bo[zc] = 1;        //保证加过的数不会再加，本来我想定义一个bool类型数组方便，但是不知道为什么总是发生编译错误，无奈只能定义了int类型····
    }
    if(temp == n - 1)       
        cout << "Jolly";    //我们发现如果我们所记下来的数有n-1个，那么说明在[1,n-1]区间内所有的数都被记过了，那么就符合开心的跳
    else cout << "Not jolly";//否则就不属于开心的跳
    return 0;
}
```

好了，数据水我也没办法，谁让复杂的我也不会呢？大家就这么打代码~~娱乐性质~~尝试一下把

---

## 作者：wpy233 (赞：21)

#这题哪里难了#

标准红题，不知dalao们竟然要用到排序？！

（好吧其实本人一开始还RE了5个点）

这题就是__纯判断+标记__，其它~~一点技术含量都没有~~

核心思想：

两两判断，一个一个标记

最后输出时判断1~n-1，如果有一个不是`true`就输出“Not jolly”，终止程序

其他的则输出“Jolly”

注意，这里有个坑点，就是虽然n<=1000、、、

但是题目中没说相邻两个的差值也<=1000啊。。。

所以记得加一个判断，就AC了。。。
```
//虽然代码里没有坑，但希望大家能自己把代码打一遍，而不是Ctrl+C、Ctrl+V
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n;
int a[1005];//输入必备
bool b[1005];//判断必备
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    	cin>>a[i];//输入
    for(int j=2;j<=n;j++)//两两判断
    	if(abs(a[j]-a[j-1])<=1000)//注意这个地方坑了偶好久、一定要判断差值是否落在范围内
    		b[abs(a[j]-a[j-1])]=true;//标记成出现过
    for(int i=1;i<=n-1;i++)
    	if(!b[i])//判断b[i]是否为真
    	{
    		cout<<"Not jolly"<<endl;//只要有一个不是就输出“Not jolly”
    		exit(0);//终止程序
		}
	cout<<"Jolly"<<endl;//如果没有，输出“Jolly”
    //输出时记得注意大小写！
    return 0;
}
```

---

## 作者：SasukeUchiha (赞：20)

**题目**：P1152 欢乐的跳              //萌新的首篇题解，尽可能详实一些，有可能过于啰嗦。  **C**

**题设**：一个**n**个元素的整数数组，

如果数组两个连续元素之间差的绝对值包括了**[1,n-1]**之间的所有整数，则称之符合“欢乐的跳”；

给定一个数组，判断该数组是否符合“欢乐的跳”。

如：数组 1 4 2 3 符合“欢乐的跳”；

因为差的绝对值分别为：3 2 1。


**分析样例：**

(1)
4 1 4 2 3

4 （表示该数组有4个元素）1 4 2 3（表示数组元素的值）//[该样例中n=4,数组元素为1 4 2 3]

计算一下 “两个连续元素之间差的绝对值” 得到  3 2 1；而 “[1,n-1]之间的所有整数” 为 1 2 3；

所以 “数组两个连续元素之间差的绝对值包括了[1,n-1]之间的所有整数，称之符合‘欢乐的跳‘"

那么输出结果是 Jolly

(2)
5 1 4 2 -1 6

5 （表示该数组有5个元素）1 4 2 -1 6（表示数组元素的值）//[该样例中n=5,数组元素为1 4 2 -1 6]

计算一下 “两个连续元素之间差的绝对值” 得到  3 2 3 7；而 “[1,n-1]之间的所有整数” 为 1 2 3 4；

所以 “数组两个连续元素之间差的绝对值不包括了[1,n-1]之间的所有整数，称之不符合‘欢乐的跳‘"

那么输出结果是 Not jolly


**结论：**

由于该题目不甚复杂，所以其可用模拟解决。

按照题目意思，可以开两个数组(a,b)，一个(a)存放数据（大小：n），一个(b)存放差值（大小：n-1）。

可以用第i个元素减去第i+1个元素得到差值，4-1=3,2-4=-2, 发现出现负数，于是还需要计算绝对值。

//绝对值判断可以用if完成，情况只两种： >=0  <0，可以用if else。

存放差值时需要注意，数据大小是n，差值只有n-1个；所以比较是只能循环i到n-1，数组下标从0循环到n-2。

通过样例(1)，发现得到的差值与 1至n-1 数的顺序不同，所以需要给差值排序，这里推荐快排【效率高】。


//求省事则使用qsort【快排函数】。

---------------------------------------------------愉快的码**代码**-coding~--------------------------------------------------


```c
#include<stdio.h>//基本的头文件
#include<stdlib.h>//qsort需要的头文件
int cmp(const void *a, const void *b)//qsort需要的函数[起到比较的作用]
{
    return *(int*)a - *(int*)b;//qsort的结果为从小到大排列
    }
int J(int x)//自定义的绝对值函数
{
    if(x>=0)//若此数为非负数
    return x;//返回原值
    else//否则
    return x*(-1);//返回其数的相反数
    }
int main()//主函数
{
    int n;//定义变量n
    scanf("%d",&n);//读入值，赋予n
    int a[n],i;//定义变量  数组a , i     [注：这样写不好，容易超过空间限制，最好开一个全局变量 如：a[10000000]]
    for(i=0;i<n;i++)//循环n次
    {
        scanf("%d",&a[i]);//读入值，赋予a
        }
    int b[n];//定义变量  数组b          [注：这样写不好，容易超过空间限制，最好开一个全局变量 如：b[10000000]]
    for(i=0;i<n-1;i++)//循环n-1次
    {
        b[i]=J(a[i]-a[i+1]);//计算(第i个元素与第i+1个元素的)差值的绝对值，存入b数组
        }
    qsort(b,n-1,sizeof(int),cmp);//将b数组按从小到大顺序快排
    int o=0;//定义变量o,初始化为0【设置检验是否符合“欢乐的跳”规律的"开关"，初始状态为关】
    for(i=1;i<n;i++)//循环n次，
                           //检验数组两个连续元素之间差的绝对值是否包括了[1,n-1]之间的所有整数，是否符合‘欢乐的跳‘"
    {
        if(b[i-1]!=i)//若数组下标为i-1,即第i个差(的绝对值)的值不为第i个整数i（不符合“欢乐的跳”规律）
        {
            o=1;//变量o值赋1【不符合“欢乐的跳”规律，"开关"打开】
            break;//若出现如此情况，跳出整个循环（因为有1例不符合“欢乐的跳”规律，整个数组都不符合“欢乐的跳”规律）
            }
        }
    if(o==0)//若o值为0【"开关"状态为关，该数组符合“欢乐的跳”规律】
    printf("Jolly");//输出 Jolly （输出 符合“欢乐的跳”规律）
    else//否则【"开关"状态为开，该数组不符合“欢乐的跳”规律】
    printf("Not jolly");//输出 Not jolly （输出 不符合“欢乐的跳”规律）
    return 0;//结束，返回0
              //return 0；表示程序正常结束。 return 非0； 表示程序异常结束。
             //这是C标准对编译器的一项建议，不是必须的。没有return 0；也可以，不过某些编译器有强制要求。
    }
```

萌新之首篇题解，不甚详实，异常啰嗦，见谅。


---

## 作者：亿年已过 (赞：11)

蒟蒻的第九篇的题解qwq?

这道题其实真的不难。~~窝刚开始看题目时有点懵~~

题意大概是这样的：

一个有n个数的整数数组，如果数组相邻两个数之间的差的绝对值包括了1~n-1之间的所有整数，则称之符合“欢乐的跳”

如：
如数组1 4 2 3符合“欢乐的跳”，因为差的绝对值分别为：3,2,1

解释：4-1=3，2-4=-2（取绝对值2），3-2=1

而1~n-1之间的数有1,2,3，1=1,2=2,3=3 所以，这个数组符合“欢乐的跳”

```
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n,a[1005],b[1005];//定义
int main()
{
cin>>n;//输入
for(int i=1;i<=n;i++)
{
    cin>>a[i];//输入数组
}  
for(int i=1;i<=n-1;i++)
{
    b[i]=abs(a[i+1]-a[i]);//求数组相邻两个数之间的差的绝对值
}
sort(b+1,b+n);	//排序（因为数组相邻两个数之间的差的绝对值不一定是按顺序的）
for(int i=1;i<=n-1;i++)
{
    if(b[i]!=i)//只要差的绝对值有一个是和1~n-1之间的数不同，就输出"Not jolly"，并直接结束
    {
    	cout<<"Not jolly";
    	return 0;
    }
}
cout<<"Jolly";//否则，输出"Jolly"

    return 0;//结束
}
```


---

## 作者：yyyyyyy (赞：7)

//这道题挺简单的，枚举加拍序就OK了，第一次写题解，还请大家多多包容

```cpp
var i,n:longint;
    a,b:array[1..1000] of longint;
    flag:boolean;
procedure qsort(l,r:longint);//快排，相信大家也再熟悉不过了吧
var i,j,mid,t:longint;
begin
i:=l;
j:=r;
mid:=a[(l+r)div 2];
repeat
while a[i]<mid do inc(i);
while a[j]>mid do dec(j);
if i<=j then
   begin
   t:=a[i];
   a[i]:=a[j];
   a[j]:=t;
   inc(i);
   dec(j);
   end;
until i>j;
if l<j then qsort(l,j);
if i<r then qsort(i,r);
end;
begin
read(n);
for i:=1 to n do read(b[i]);//读入
for i:=1 to n-1 do a[i]:=abs(b[i+1]-b[i]);//把差的绝对值放入a数组
qsort(1,n-1);//排序，由于是差，所以只有n-1个
flag:=true;
for i:=1 to n-1 do//判断是否可以“欢乐的跳”，如果有一个不符合要求，flag:=false; 退出循环
    if a[i]<>i then
       begin
       flag:=false;
       break;
       end;
if flag then write('Jolly') else write('Not jolly');//如果flag是true，输出Jolly，否则，输出Not jolly
end.
//OK，大家是不是觉得挺简单的呢
```

---

## 作者：Lwen1243 (赞：4)

分析：n的取值最大为1000，这就说明这题的时间复杂度就算是O（n^2）也不会超时，然后就看数据范围，10的8次方，搞不好会有2*
10^8，这时候，我们就可以使用map（映射），将每一个值映射到1（true）或0（false），如果没有出现，就为0（false），出现了就为1（true）。最后遍历一遍就完成了。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<map>
#define f(i,a,b) for(int i = a ; i <= b ; i ++ )
using namespace std;
const int MAXN = 1005 ;
int a[MAXN] ;
int n ;
map<long long , int > m ;
int main()
{
	scanf("%d",&n) ;
	f(i,1,n) scanf("%d",&a[i]) ;
	f(i,1,n-1) 
	{
		int j = i + 1 ;
		m[ abs( a[j] - a[i] ) ] = 1 ;
	}
	f(i,1,n-1) if( m[i] != 1 ) { printf("Not jolly\n") ; return 0 ; }
	printf("Jolly\n") ;
	return 0 ;
}
```
思路二：
将每个相邻数的绝对值存起来，对它们进行一次排序，得出结果遍历一次

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define f(i,a,b) for(int i = a ; i <= b ; i ++ )
using namespace std;
const int MAXN = 1005 ;
int n;
int a[MAXN] ;
int b[MAXN] ;
int main()
{
	scanf("%d",&n) ;
	f(i,1,n) scanf("%d",&a[i]) ;
	f(i,1,n-1) b[i] = abs( a[i+1] - a[i] ) ; 
	sort(b+1,b+n) ;
	f(i,1,n-1) if( b[i] != i ) {
		printf("Not jolly\n");
		return 0;
	}
	printf("Jolly\n") ;
	return 0 ; 
}
```



---

## 作者：xujian (赞：4)

**本人代码一向简洁简单**

简单的模拟题，里面会用到冒泡排序，最后一个循环就可以判断出了。

只能解释到这了，看不懂萌新再研究一下吧^\_^

            
```cpp
#include<cstdio>
#include<cmath>
int main(){
    int i,n,num[1005],num2[1005],t=0,y=1;
    scanf("%d",&n);
    for(i=1;i<=n;i++)scanf("%d",&num[i]);
    if(n>1){
        for(i=1;i<=n-1;i++)
            num2[i]=fabs(num[i]-num[i+1]);
        for(i=1;i<=n-2;i++){
            for(int j=1;j+i<=n-1;j++)
                if(num2[j]>num2[j+1]){  //排序部分
                    t=num2[j];
                    num2[j]=num2[j+1];
                    num2[j+1]=t;
                }
        }
        for(int i=1;i<=n-1;i++)  //相当于扫描
            if(num2[i]!=i){ 
                y=0;
                break;
            }
        if(y==0)printf("Not jolly");
        else printf("Jolly");   //条件判断
    }
    return 0;
}
```

---

## 作者：孤独的牧羊人 (赞：4)

为什么没有人用stl？？？  
其实可以用set直接去重，然后就很简单了。  
常用操作 ：

begin() 　　 返回set容器的第一个元素的 地址

end() 　　　　 返回set容器的最后一个元素 地址

clear() 　　 删除set容器中的所有的元素

empty() 　　　 判断set容器是否为空

max_size() 　 返回set容器可能包含的元素最大个数

size() 　　　　 返回当前set容器中的元素个数

erase(it) 删除迭代器指针it处元素

insert(a) 插入某个元素  --《明明的随机数》的题解

[详细用法](https://www.cnblogs.com/yaoyueduzhen/p/4536929.html)  
```
#include<bits/stdc++.h>
using namespace std;
int n,a,b,c;
set<int>s;
int main(){
	cin>>n>>b;//这里的b是第一个数字
	for(int i=2;i<=n;i++){
		cin>>a;
		c=abs(a-b);
		if(c>=1&&c<=n-1) s.insert(c);//记录差
		b=a;//b存储上一个的数字
	}
	if(s.size()==n-1) cout<<"Jolly"<<endl;//如果个数够，就输出Jolly
	else cout<<"Not jolly"<<endl;
	return 0;
}
```


---

## 作者：封缄 (赞：4)

小牛的第二篇题解 	
看到题解里面基本全是快排	
真的是让我一个stl没学好的蒟蒻不知所措	
### 好了开始正题	
发一个没有排序（嗯各种排序都没有）的 	
做题前首先要明确以下几点	
1，n个数相邻两个数的差有n-1个，区间【1，n-1】里面有n-1个数，这就要求所有差的绝对值要在区间内，而且**  不重不漏**	
2，排序是为了确定相邻+1从而判断，但其实只要保证所有的数都存在于区间内就可以了。	
~~3，这道题只是一道红题啊！~~	
咳咳，红题也是要认真做滴	
要不像我一样，交了4遍。。。	
第一次 所有数组开小了 50分	
第二次 bool数组开小了（这个下面有说明）60分	
第三次 scanf输入a【i】时没有带ll。。。导致测试点2蜜汁re 90分	
第四次 终于ac。。。	
下面上题解，里面注释的说明应该比较详细了	
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n;
long long num[10001],a[10001];
bool flag[200000001];
//由于下面需要用flag[num[i]],数组要开到2*10^8以上
//bool不怕爆内存 
bool flag1=false;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);//注意long long型 
	for(int i=1;i<n;i++)
	{
		flag[i]=false;//判断前初始化 
		if(a[i]==a[i+1])
		{
			printf("Not jolly");
			return 0;
		}//先特判一下，当有两数相等（即差为0），在[1,n-1]不够n-1个数时，直接输出非
		//但事实证明没用。。。 
		num[i]=abs(a[i]-a[i+1]);//求差的绝对值 
	}
	for(int i=1;i<n;i++)
	    flag[num[i]]=true;//当这个数[1,n-1]存在时，竖起相对应的旗 
	for(int i=1;i<n;i++)
	{
		if(flag[i]==false)
	       flag1=true;
	       //如果在此区间内有一面旗为非，则结果为非，竖起旗1
           //其实这里可以加一个break小剪枝，但因为数据范围不高，不加也不会超时
	}
	if(flag1==true)printf("Not jolly");
	else printf("Jolly");//输出结果 
	return 0;
}

```

---

## 作者：wisdom_grass (赞：4)

看到题，想了一会儿，

发现n个数的差排序以后这些数肯定是

1、2、3……n-1

如果那些差排序后不是上面的数，

那么肯定就没有欢乐的跳。

##记住：n个数只有n-1个差。

那么：

1、读入完，算出差存在一个数组中；

2、将此数组排序；

3、扫一遍该数组，如果差和下标不相等，肯定就没有欢乐的跳，输出，结束程序；

4、如果符合要求，输出，结束程序。


上代码辅助理解：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath> // 绝对值abs()的数学库 
#include <algorithm> // STL之排序库 
using namespace std;

const int maxn = 1003; //定义常量是个好习惯 
int n;
int a[maxn];
int f[maxn];

int main()
{
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);

    //读入 
    cin >> n;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
        
    //处理相邻两个数的差,取绝对值存在f数组中
    //记住只要i<n,因为n个数只有n-1个差 
    for(int i=1;i<n;i++)
        f[i] = abs(a[i] - a[i+1]);
        
    //循环i<n所以sort后一项不用+1 
    sort(f+1,f+n);
    
    //记住是i<n 
    for(int i=1;i<n;i++)
        if(f[i] != i){//值肯定是[1~n-1]之间，所以f[i]必须等于i 
            cout << "Not jolly\n";
            return 0;//记住返回 
        }
            
    //如果没有返回那么肯定能 "欢乐的跳" 
    cout << "Jolly\n"; 
    return 0;
}
```

---

## 作者：⚡皮卡丘⚡ (赞：4)

### 本题是一道纯暴力，枚举，模拟题
注意n的范围，萌新别越界了哦

![](https://cdn.luogu.com.cn/upload/pic/72073.png)

#### 注意是绝对值，要专门处理哦

完整代码如下（~~ctrl+c小心棕名哦~~）：
```cpp
#include<bits/stdc++.h>	  //万能头
using namespace std;
long long n,a[1001];   //因为1≤n≤1000所以a数组开1001
int main()
{
	cin>>n;  //输入
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n;i++)
		if(max(a[i],a[i+1])-min(a[i],a[i+1])<1 || max(a[i],a[i+1])-min(a[i],a[i+1])>=n)   //判断是否在范围，不是则输出Not jolly并结束
		{
			cout<<"Not jolly"<<endl;
			return 0;
		}	
   //全部判断完后输出Jolly
	cout<<"Jolly"<<endl;
	return 0;  //完美结束QWQ
}

```
本蒟蒻的第一篇题解，~~大佬勿喷~~

希望支持QWQ

---

## 作者：ww3113306 (赞：3)

AC完看题解。。发现都是要写排序才能过，，，并不是很懂为什么要排序。这里发一个纯模拟无排序的方法

首先，储存读入的数只需要两个变量，因为是存差嘛，一个变量存上一个数，一个是现在的数。

因为绝对值的问题，我们另设一个变量来存绝对值。

然后一共有n个数，那么中间的差实际只有n-1个，而要满足题目要求的1~n-1都在的话，就必须每一个差都对应一个要求的数，

因此，差是不可能有多余的，所以一旦遇到一个差会使一个数重复出现，就可以判断肯定凑不齐1~n-1了，就可以输出Not jolly了

而如果没有输出Not jolly,就意味着没有重复。既然没有重复，也就是说每一个差都对应一个数了，那肯定是凑齐了

所以，，，下面代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;bool z[1000];
int main()
{
    int i,k,now,chance;
    memset(z,0,sizeof(z));
    scanf("%d",&n);
    scanf("%d",&k);
    for(i=2;i<=n;i++)
    {
        scanf("%d",&now);
        if(now-k>0) chance=now-k;//处理绝对值
        else chance=k-now; 
        if(z[chance])//如果chance对应的数之前已经有差对应过了，那么肯定就重复了，既然重复了，上面解释过了，所以，。。
        {
            printf("Not jolly");
            return 0;
        }
        if(!z[chance]) z[chance]=true;//标记这个数被对应过了
        k=now;
    }
    printf("Jolly");//不是Not jolly就是Jolly
    return 0;
}
```

---

## 作者：你若安好，便是晴天 (赞：3)

创建两个数组a，b

a数组存输入时的量

b存每两个之间的量

将数组b进行排序

看是否都有

不要中了题目的陷阱

只要都有就行

不一定要是等差数列

祝大家刷题愉快


---

## 作者：一个LeSe (赞：3)

本蒟蒻发的第一篇题解  
其实这道题很水的  
话不多说，直接上代码；  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10001];
bool b=1;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)//输入
    cin>>a[i];
    for(int j=0;j<n;j++)
    {
    	if(a[j]-a[j+1]>n-1)b=0;//判断
	}
	if(b==1)cout<<"Jolly";//输出
	else cout<<"Not jolly";
 } 
```
虽然自认为特完美，但第4组数据的运行结果和评测结果不同，大佬求解！

---

## 作者：jfjdjx (赞：3)

不明白为什么那么多人要快排、冒泡

这就是简单的模拟

使用计数排序

注意数组开大些，希望可以给大家带来帮助

```cpp
#include<iostream>
#include<cmath>
#include<ctime>
#include<cstdio>
#include<string>
#include<sstream>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<queue>
using namespace std;
long long n,j,k;
bool a[100001];
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>n;
    cin>>k;
    for(int i=2;i<=n;i++)
    {
        j=k;
        cin>>k;
        a[abs(j-k)]++;
    }
    for(int i=1;i<=n-1;i++)
    {
        if(a[i]!=1)
        {
            cout<<"Not jolly";
            return 0;
        }
    }
    cout<<"Jolly";
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}

```

---

## 作者：Aw顿顿 (赞：2)

这道题作为红题，肯定不难

我们看着代码讲：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[10001]={0},f[10001]={0};
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        x=abs(a[i]-a[i-1]);
        if(x>=1&&x<=n)f[x]=1;
    }
    for(int i=1;i<n;i++)if(!f[i])
    {
        cout<<"Not jolly"<<endl;
        return 0;
    }
    cout<<"Jolly"<<endl;
    return 0;
}
```
当中flag数组用于标记

而判断如果flag数组不符合则输出否

反之就输出是

其中flag数组必须每个数的标记都符合才可以

判断语句x>=1&&x<=n是很重要的

因为如果x这样的情况下是符合条件的，就标记

不大于总个数，大于等于1

所以就做出来了

附上第一次做错的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long n,t[1001],a[1001],s[1001],i,j;
bool f=true;
int main()
{
	freopen("jump.in","r",stdin);
	freopen("jump.out","w",stdout);
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		if(i)s[i-1]=abs(a[i]-a[i-1]);
	}
	for(i=1;i<n;i++)for(j=0;i<n;i++)if(s[j]==i)t[i]=1;
	for(i=1;i<n;i++)if(!t[i])f=false;
	if(f)cout<<"Jolly";
	else cout<<"Not jolly";
	return 0;
}
```



---

## 作者：zhaowangji (赞：2)

怎么感觉前面几篇都很烦啊？

桶排+边读边做

先把大概说一下

读入用一个数组，判断用一个数组

边读边做，从第二个数开始判断，算出当前数与前一个数的差，然后数组中该下标的值++，最后全部扫一遍，如果有为0（没出现过）就不行，如果全部扫完一遍后都没问题就说明可以


```cpp
#include<iostream>
#include<cmath>
using namespace std; 
int n;
int a[100000007];
int f[100000007];//数据范围10^8，记得开多大，因为这个还RE了。。。
int main()
{
	cin>>n;//正常读入
	for(int i=1;i<=n;i++)//可以一边读一边处理
	{
		cin>>a[i];//读入这个数
		if(i!=1)//因为第一个前面没有数
			f[abs(a[i]-a[i-1])]++;//以这个与前一个差的绝对值为下表的数组值++
	}
	for(int i=1;i<=n-1;i++)
		if(f[i]==0){cout<<"Not jolly";return 0;}
        //只要值为0（说明没出现过）就不行，不标记的话记得写return 0
	cout<<"Jolly";//运行完说明所有的值都出现过
	return 0;
}

```


---

## 作者：XiaoX (赞：2)

虽然本题是水题，但可以练习一波滚动数组。。。

思路就是边读入边记录差值并vis标记，如果出现重复的差值，则一定不够1~n-1个数，就输出并结束
```
#include<cstdio>
using namespace std;
int abse (int x)
{
    return x>0?x:-x;
}//自己写绝对值比较快
int n,a[2];
bool v[100000005];//注意别只开到1000，会RE
int main ()
{
    scanf("%d",&n);
    scanf("%d",&a[1]);//先读一个
    for(int i=2;i<=n;i++) {
        scanf("%d",&a[i&1]);
        if(v[abse(a[i&1^1]-a[i&1])]) //a[0]、a[1]滚动
        	return printf("Not jolly"),0;
        else v[abse(a[i&1^1]-a[i&1])]=1;
    }
	printf("Jolly"); 
}
```
~~其实在这题中没啥用，但在别的题中可能能优化空间~~

---

## 作者：天命之路 (赞：1)

这道题目的基本思路，就是**相邻**两数作差（千万别读成每两个元素的差），在用桶来标记，再将桶遍历验证，这事就结了。

#### 那么，什么是桶？

桶其实是对数组的巧妙运用，对于一个一维数组a，它的某一项ai是可以保存两个数的，一个是ai，还有一个是下标i。桶的思想，就是用下标表示数，值表示该数是否出现或出现过几次。这是个牺牲空间换时间的操作。

可以看到这个题目的空间复杂度为O(n-1)，因为有n-1个差。不会超空间，时间更不会超。所以直接看代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[1001],ton[1001],n;
int main()
{
    cin>>n;
    memset(ton,0,sizeof(ton));
    for(int i=1;i<=n;i++) cin>>a[i];   //输入
    for(int i=1;i<n;i++)
    if(abs(a[i]-a[i+1])<n)   //作差，一定要加abs不然有可能是负的，小于n防越界
    ton[abs(a[i]-a[i+1])]=1;  //标记
    for(int i=1;i<n;i++)   //遍历1到n-1
    if(ton[i]!=1)   //如果有数没出现过
    {
        cout<<"Not jolly";   //不是欢乐的跳
        return 0;
    }
    cout<<"Jolly";
    return 0;
}
```

最后说一句，对于初用桶的蒟蒻来说，循环终止条件一定是循环变量大于最大的数，而不是数的个数！！！！！！不然就会WA！那片鲜艳的红色是我们最不想看到的东西......

---

## 作者：Lovable_Wind (赞：1)

# 题目很简单 #
## 看到只有22篇 ##
~~我决定也来一篇~~

废话就不多说了，厨子上代码！
（咦，厨师哪去了）

c++代码：
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int a[100010],b[100010];//b数组用来存求完差的绝对值的a数组 
int main()
{
	int n,i;
	cin>>n;
	for (i=1;i<=n;i++)
		cin>>a[i];
	for (i=1;i<=n;i++)
		b[i]=abs(a[i+1]-a[i]);//abs,绝对值函数 
	sort (b,b+(n-1)+1);//C++,sort很重要（没有TLE!) 
	for (i=2;i<=n-1;i++)
		if (b[i]-b[i-1]!=1)//如果不是欢乐的跳 
		{
			cout<<"Not jolly";
			return 0;
		}//不是就直接走人,会快不少呢！ 
		cout<<"Jolly" ;
	return 0; //完美收尾! 
}
```
# 第一篇题解，蒟蒻求过！ #

---

## 作者：石不转 (赞：1)

这个题目很水，暴力就OK。

最后的三目运算符很晕……

自学了半天还是没有所以然……

但是这样还是过了。

```cpp
#include <stdio.h>
#include <math.h>
int main()
{
    int n,x,y,s,i,j;
    scanf("%d",&n);
    for(i=1;i<n;i++)
    {
        s=s+i;
    }
    scanf("%d",&x);
    for(i=1;i<n;i++)
    {
        scanf("%d",&y);
        x=y;
        s=s-abs(x-y);
    }
    printf(s==0?"Jolly":"Not jolly");
}
//by 羲轩、煌
```

---

## 作者：郑翔弈 (赞：1)

## 你只需要快排一下

```cpp
#include<stdio.h>
#include<stdlib.h>//快排所在的头文件
#include<math.h>
int s[10000],n,i;
int f=0;//标志变量
int cmp(const void *a, const void *b)
{
    return (*(int*)a-*(int*)b);
}
int main()
{
    scanf("%d",&n);
    for(i=0;i<n;i++) scanf("%d", &s[i]);//读入
    for(i=0;i<n;++i) s[i]=fabs(s[i]-s[i+1]);//将数组里的每一个单元里的值替换为相邻两个数的差
    qsort(s,n,sizeof(s[0]),cmp);//快排
    for(i=1;i<n;i++)//进行比对
        if(s[i-1]!=i){//是否相等
            f=1;//标志变量=1
            break;//退出循环
        }
    if(f) printf("Not jolly");//如果是中途退出循环，输出Not jolly
    else printf("Jolly");//否则输出Jolly
    return 0;//结束
}
```

---

## 作者：ars4me (赞：1)

因为这个题比较水 所以我用了三个数组

a数组用来存输入 b数组用来存差值 c数组用来判断

首先先存差值 注意要存绝对值

```cpp
for(int i=1;i<n;i++){
    if(a[i+1]-a[i]>0){
        b[i]=a[i+1]-a[i];
    }
    else if(a[i+1]-a[i]<=0){
        b[i]=-(a[i+1]-a[i]);
    }
}
```
然后 因为题目要求{1，n-1}都要在这些绝对值中出现
所以先初始化c数组为所有应该出现的数

for(int i=1;i<n;i++){

    c[i]=i;

}
接着将所有绝对值中出现的数都在c数组中置为0

for(int i=1;i<n;i++){

    c[b[i]]=0;

}
最后再扫一遍c数组 只要有不是0的就输出语句然后退出


代码如下






```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define size 100001
int a[size],b[size],c[size];
int n; 
void check()
{
    for(int i=1;i<n;i++){//比较
        c[b[i]]=0;
    }
    for(int i=1;i<n;i++){
        if(c[i]!=0){
            cout<<"Not jolly"<<endl;
            break;
        }
        if(i==n-1){
            cout<<"Jolly"<<endl;
        }
    }
}
void inputc()//初始化c数组
{
    for(int i=1;i<n;i++){
        c[i]=i;
    }
    check();
}
void doo()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
        if(a[i+1]-a[i]>0){
            b[i]=a[i+1]-a[i];
        }
        else if(a[i+1]-a[i]<=0){
            b[i]=-(a[i+1]-a[i]);//取绝对值
        }
    }
    inputc();
}
int main()
{
    doo(); 
}
//码丑
//COYG
```

---

## 作者：er56kksk (赞：1)

数组用的比较6就很好解决啦O(∩\_∩)O~~

```cpp
#include<cstdio>
using namespace std;
int n, a[3001]={0};
bool check(int, int);
void swap(int, int);
int main(){
    int x, y;
    scanf("%d%d", &n, &x);
    for(int i=1;i<n;i++){
        scanf("%d", &y);
        int t=x>y?x-y:y-x;
        if(t<n) a[i]=t;
        else break;
        x=y;
}
    for(int i=1; i<n; i++){
        int k=i;
        for(int j=i+1; j<n; j++)
        if(check(k, j)) k=j;
        swap(k, i);
    }
    for(x=1; x<n; x++) if(a[x]!=x) break;
    if(x<n) printf("Not jolly\n");
    else printf("Jolly\n");
    return 0;
}
bool check(int x, int y){
    if(a[x]>a[y]) return true;
    return false;
}
void swap(int x, int y){
    int t=a[x]; a[x]=a[y]; a[y]=t;
}
```

---

## 作者：Sooke (赞：1)

竟然没有人使用我大无所不能STL？

本题使用map，程序精炼，时间复杂度也不会低。

具体流程如下：

```cpp
#include <iostream>
#include <cmath>
#include <map>
using namespace std;
map < int , bool > c;
//定义map
int main()
{
    int n,a,b;
    cin >> n;
    cin >> a;
    //先输入一个数
    for(int i=2;i <= n;i++)
    {
        b=a; //将前面所输入的数储存到临时变量里，以便做减法运算
        cin >> a; //再输入一个数作为被减数
        c[abs(a-b)]=true; //核心处理，表示存在相邻数相减的绝对值是这个数
    }
    for(int i=1;i < n;i++)
    if(c[i] == false)
    {
        cout << "Not jolly";
        return 0;
    }
    //查看是不是存在相邻数相减的绝对值各是 1 ~ n-1 ，作出对应输出
    cout << "Jolly";
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

实际上这题就是一个桶排，这里有一点小姿势：

1、如果差值的绝对值不在1~N-1之间，弹出错误

2、产生重复，弹出

到最后还没有错误的自然就是正确答案拉

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,x,y;
bool flag[100000];//桶
int main()
{
    cin>>n;
    cin>>x;
    for (int i=1;i<n;i++)
        {
            cin>>y;
            if (!(((int)abs(x-y)>=1)&&((int)abs(x-y)<=n)))//是否越界
{cout<<"Not jolly";return 0;}//注意这里有个坑点就是abs的返回值是实数会报错（wa了好几次很尴尬
            if (flag[(int)abs(x-y)]){cout<<"Not jolly";return 0;}//是否重复
            flag[(int)abs(x-y)]=1;//入桶
x=y;//社会老师和我们讲要做到可持续发展
        }
    cout<<"Jolly";//正确答案，输出
}
```

---

## 作者：何苗苗 (赞：1)



    
    





```cpp
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#define MAX 1005
int a[MAX] , b[MAX] ;
int camp ( const void *p, const void *q )
{
    return *(int *)p - *(int *)q ;
}
int main ( void )
{
    int n , i ;
    scanf ( "%d", &n );
    for ( i = 0; i < n ; i++ )
    {
        scanf ( "%d", &a[i] ) ;
    }
    for ( i = 0 ; i < n - 1 ; i++ )  // 有 n 个数据， 则有 n-1 个差   
    {
        b[i] = (int) abs( a[i+1] - a[i] ) ;  // 取 差的绝对值    存到数组 b 中   要强制类型转换 
    }
    qsort ( b, n-1 , sizeof (int), camp ) ; //  对 数组相邻的两个元素的差的绝对值  从小到大排序 
                     // 排完顺序后， 如果 是欢乐的跳， 则 数组 b 的元素 的大小一定是从 1 到 n-1  逐渐增大 
    for ( i = 0 ; i < n - 1 ; i++ )  
    {
        if ( b[i] != i+1 )  // 只要有一个不相等，就直接不是欢乐的跳   
        {
            printf ( "Not jolly\n" ) ;
            return 0 ;
        }
    }
    printf ( "Jolly\n");
    return 0 ;    
}

```

---

## 作者：谁懂谁伤心 (赞：1)

创建一个数组，存储每两个数字差的绝对值，发现重复或超出就输出“Not jolly”并return。如果每个数都判断完还未停止就输出“Jolly”。

    ```cpp
#include <iostream>  
    #include <cmath>  
    using namespace std;  
    int main()  
    {  
    int a;   
    cin >>a;   
    int s[a+1],d[a];  
    for (int q=0;q<=a-1;q++)  
    d[q]=0;  
    for (int q=1;q<=a;q++)   
    cin >>s[q];  
    for (int q=1;q<=a-1;q++)  
    {if (abs(s[q]-s[q+1])>=a){cout <<"Not jolly";  return 0;}  
    d[abs(s[q]-s[q+1])]++;  
    if (d[abs(s[q]-s[q+1])]>1){cout <<"Not jolly";  return 0;}}  
    cout<<"Jolly";  
    return 0;  
    }  
```

---

## 作者：baccano (赞：1)

看这个题瞬间就想到了差分数组，于是本能的想去开一个差分数组，后来发现直接开一个桶的bk数组计数就可以了

时间复杂度为线性O(n),代码复杂度感觉也不是很高
```c
#include <bits/stdc++.h>
using namespace std;
map<int,int> bk;//防止迷之RE
int main()
{
  ios::sync_with_stdio(0);//关闭同步三步走
  cin.tie(0);
  cout.tie(0);
  int n,last=0;//初始last为0
  cin>>n;
  for(int i=0;i<n;i++)
  {
    int t;
    cin>>t;
    bk[abs(t-last)]++;//把差分数组直接放入桶里
    last=t;
  }
  for(int i=1;i<=n-1;i++)
  if(!bk[i])//条件不满足
  return cout<<"Not jolly",0;//直接结束不留余地
  return cout<<"Jolly",0;//条件满足
}

```

---

## 作者：eternityer (赞：1)

## 这可能是最奇怪的一种解
利用了stl库中的set，加入他中间的元素，自动去重复并且自动排序，然后只要判断他里面的数量有没有n-1个，并且最大是不是n-1和最小是不是1就好了，详细的见代码
```
#include <bits/stdc++.h>
using namespace std;
set<int> s;//集合  内部元素自动排序，并且无重复 
int main()
{
	int n,x,y;
	cin>>n;
	cin>>x;
	for(int i=1;i<n;i++){
		cin>>y;
		s.insert(abs(x-y)); //结果加入集合中 
		x=y;	
	}
	set<int>::iterator ite1 = s.begin();// 迭代器 
    set<int>::iterator ite2 = s.end();// 迭代器 
    if(s.size()==n-1&&*ite1==1&&*ite2==n-1){ //判断有没有n-1个不同的解，并且判断最大最小是否等于n-1和1； 
    	cout<<"Jolly";
    }else cout<<"Not jolly";
    return 0;
}
```
没有用一个数组，加进去直接判断就好了，都不用遍历。
这可能是最不同的一种解法了吧。

---

## 作者：枍暮77 (赞：1)

这道题其实很简单，只用一个数组，用来存差的值。用两个变量循环输入，在排个序就行了。。。。。。

```cpp
var a:array[1..999]of boolean;
    n,i,t1,t2:longint;
    t:boolean;
begin
  read(n);
  for i:=1 to n do
    a[i]:=false;
  read(t1);
  t:=true;
  for i:=2 to n do
    begin
       read(t2);
       if a[abs(t1-t2)] then
                            begin
                              t:=false;
                              break;
                            end
                               else a[abs(t1-t2)]:=true;
       t1:=t2;
    end;
  if t then writeln('Jolly') else writeln('Not jolly');
end.
```

---

## 作者：Sinwind (赞：0)

# 1.分析

0. 计算出每两个数的差的绝对值，然后再从小到大排序，数组元素与其对应的下标比较，若不等，则不符合，输出$"Not\space jolly"$；比较完后没有不符合的，则符合，输出$"Jolly"$。

1. $abs$函数：

- 头文件：$cmath$。

- 功能：以$abs(x)$为例，返回$x$的绝对值。

2. $sort$函数：

- 头文件：$algorithm$。

- 功能：以$sort(a,a+n)$为例，将$a[0]\sim a[n-1]$排序，默认为升序。

- $PS$：更详细的用法$\rightarrow$[C++ STL之排序(sort)](https://www.luogu.org/blog/Singularwind/sort-algorithm#)。

# 2.代码

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

int n;                  //元素个数
int last_num;           //上个数字
int recent_num;         //当前数字
int absolute[1005];     //绝对值

int main(void)
{
	cin >> n;
	cin >> last_num;
	for(int i = 1; i < n; i++)
	{
		cin >> recent_num;
		absolute[i] = abs(last_num - recent_num);
		last_num = recent_num;
	}
	
	sort(absolute + 1, absolute + n);
	
	for(int i = 1; i < n; i++)
	{
		if(absolute[i] != i)
		{
			cout << "Not jolly";
			return 0;
		}
	}
	
	cout << "Jolly";
	
	return 0;
}
```


---

## 作者：MataGod (赞：0)

这个题可以转一下题目的空子。

如果符合题目条件是Jolly的话，那么连续两个元素差的个数一定是n-1个，请注意**个数**，我所说的这个个数比较特殊，我们这里使用集合set来存储这写元素差的绝对，根据set的特点，里面的元素

#### 必不可能重复

知道了这一点，就好做了。

拿样例一：4 1 4 2 3来说

连续两个元素差的绝对值分别是：3 3 2 1

如果存在set里面，那么就是：3 2 1

这样就能找到规律了：

```cpp
if (dat.size() == n - 1)
{
	printf("Jolly\n");
}
else
{
	printf("Not jolly\n");
}
```


好了 看代码吧
```cpp
#include <iostream>
#include <cstdio>
#include <set>
#include <algorithm>
#include <math.h>

std::set<int> dat;
int arr[1010];

int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
	{
		scanf("%d", &arr[i]);
	}
	for (int i = 1; i < n; ++i)
	{
		dat.insert(abs(arr[i] - arr[i + 1]));
	}
	if (dat.size() == n - 1)
	{
		printf("Jolly\n");
	}
	else
	{
		printf("Not jolly\n");
	}
	return 0;
}
```


---

## 作者：TerryGong (赞：0)

# P1152欢乐的跳——题解(Jolly)

#### 头文件，预定义不说啥
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
```
---
#### 然后进行定义数组、进行输入 
首先，我们要知道，_Linux_  评测机 **不认识一种变量：_int64**，而一般使用的 _Windows_ 或 _VC++_ 却可以使用。DEV-C++使用的是 _Linux内核_ 的GCC编译器，只支持 **long long**
类型。而long long类型与_int64类型是**一样**的，所以比赛的时候遇到大数据只需要使用long long类型就可以，别忘了读入是scanf()里的占位符要改成 **%lld !**

```cpp
long long a[3010],f[3010];int n;
```

然后，进入特判。如果n<=0，也就是说，n-1是负数，是不可能存在跳跃的，所以输出Not jolly，而当n=1是，只有一个数是，自己减自己=0，所以输出Jolly

```cpp
int main(){
	scanf("%d",&n);
	if(n<=0){
		printf("Not jolly");return 0;
	}
	if(n==1){
		printf("Jolly");return 0;
	}
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
```
现在，在我们预先留下的f[3010]数组中，进行预处理，把值变为abs(a[i]-a[i+1])，就是a[i]和a[i+1]的差

```cpp
	for(int i=1;i<n;i++)
		f[i]=abs(a[i]-a[i+1]);
```

现在，进行排序，因为f[x]储存的是a[x+1]和a[x]的差，所以如果排玩序以后，每一个不是逐个递增，那么一定就有一个差没有找到，所以就不会Jolly，如果都能找到，那么就是Jolly.

这个排序LZ使用了C++STL库中的sort()函数 ~~(老师讲：真正排序只用
sort，不排要过程才使用排序算法)~~ 当然，桶排序 ~~有可能~~ 更简单，但是楼主懒得桥梁，就用sort好了。

```cpp
	sort(f+1,f+n+1);
	for(int i=1;i<=n;i++)
		if(f[i]!=i-1){
			printf("Not jolly");
			return 0;
		}
	printf("Jolly");
	return 0;
}
```

FOR SOMEONE WHO WANTS TO PASTE MY CODE TO SUBMIT:
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
long long a[3010],f[3010];int n;
int main(){
	scanf("%d",&n);
	if(n<=0){
		printf("Not jolly");return 0;
	}
	if(n==1){
		printf("Jolly");return 0;
	}
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(int i=1;i<n;i++)
		f[i]=abs(a[i]-a[i+1]);
	sort(f+1,f+n+1);
	for(int i=1;i<=n;i++)
		if(f[i]!=i-1){
			printf("Not jolly");
			return 0;
		}
	printf("Jolly");
	return 0;
}
```

---

## 作者：Clever_Jimmy (赞：0)

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <cctype>
#include <algorithm>
#include <cstdlib>

using namespace std;

int book[100000010];//题目数据比较大，我们就开大一点
int a[1010];
int n=1;
int flag=1;

int main()
{
	scanf("%d",&n);//第一个数字是n
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);//输入数据
	for(int i=2;i<=n;i++)//这里要从2开始循环，要不然可能会越界
		book[abs(a[i]-a[i-1])]++;//abs(a[i]-a[i-1])指的是前后两个数的差
	for(int i=1;i<n;i++)
		if(book[i]==0)//如果1~n-1中有个数没有
		{
			flag=0;//把flag置为零
			break;
		}
	if(flag==1)
		printf("Jolly");
	else
		printf("Not jolly");
	return 0;
}
```

---


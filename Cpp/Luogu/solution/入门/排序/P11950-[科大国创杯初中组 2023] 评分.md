# [科大国创杯初中组 2023] 评分

## 题目描述

小可可在观看跳水比赛。

有 $n$ 名选手来参加跳水比赛，有 $m$ 名评委。在每位选手跳水之后，每位评委会给出他的分数。为了保证尽量公正客观，每位选手的得分是所有评委给出的分数中去掉最大值和最小值（如果有多个最大值/最小值，只去掉一个）之后，剩下的分数的平均值。

最后得分最大的选手获得第一名，得分第二大的选手获得第二名，以此类推。但是可能会出现同分的情况，在这种情况下，小可可会默认编号较小的选手排名更靠前。即，如果 $3$ 号选手和 $5$ 号选手的得分都是 $70$，那么小可可会认为 $3$ 号选手的排名比 $5$ 号选手更靠前。

现在小可可已经知道了所有选手得到所有评委的分数，他想让你帮他算出来选手的排名表，即对于 $1 \leq i \leq n$，算出排名第 $i$ 的选手的编号是什么。

## 说明/提示

### 样例 1 解释

四位选手的去掉最大、最小值之后的平均分分别是：$51.5, 57, 74.5, 74.5$，但由于三号选手编号比四号选手小，所以排名从 $1$ 到 $4$ 的选手分别为：$3, 4, 2, 1$。

### 数据规模与约定

对于 $30\%$ 的数据，满足 $n, m \leq 3$；

对于 $60\%$ 的数据，满足 $n, m \leq 10$；

对于 $100\%$ 的数据，满足 $2 \leq n \leq 100$，$3 \leq m \leq 100$，$0 \leq a_{i,j} \leq 100$。

## 样例 #1

### 输入

```
4 4
4 70 69 34
18 43 85 71
100 50 69 80
67 82 90 43```

### 输出

```
3 4 2 1```

# 题解

## 作者：niuniudundun (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P11950)

前置知识：排序、结构体。

首先结构体中需要编号 $id$、分数 $answer$，设这个结构体数组为 $ans$，例如访问数组的编号为 $ans_{i,id}$。

接着输入 $n,m$，使用循坏遍历 $1\sim n$，让 $ans_{i,id}=i$，定义两个变量 $mina=101,maxa=-1$ 用于计算最大最小值。接着输入分数 $a_{i,j}$，并求出最大最小值 $mina=\min(a_{i,j},mina),maxa=\max(a_{i,j},maxa)$ 和求出总和。然后让总和 $-mina-maxa$ 再除以 $m-2$，这是平均分，也就是 $ans_{i,answer}$。

然后按 $answer$ 的高低排序，高得在前；相同时 $id$ 按大小排序，小在前。

最后输出。

代码：

复杂度：$O(n^2+n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=101;
int n,m;
int a[maxn][maxn];
struct node{
	double answer;
	int id;
}ans[maxn];
bool cmp(node x,node y){
	return x.answer==y.answer?x.id<y.id:x.answer>y.answer;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		ans[i].id=i;
		int mina=101,maxa=-1;
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			mina=min(a[i][j],mina);
			maxa=max(a[i][j],maxa);
			ans[i].answer+=a[i][j];
		}
		ans[i].answer=(ans[i].answer-mina-maxa)/(m-2);
	}
	sort(ans+1,ans+n+1,cmp);
	for(int i=1;i<=n;i++){
		cout<<ans[i].id<<" ";
	}
	return 0;
}
/*
4 4
4 70 69 34
18 43 85 71
100 50 69 80
67 82 90 43
*/
```

---

## 作者：2023z (赞：4)

这道题~~非常水，连我这个蒟蒻都能一遍过~~适合刚学排序的 OI 练习。但我还是要说一句，这道题实在是~~太水了~~。

### 思路

我们可以开两个数组，一个结构体数组用来记录每个同学的编号及平均分，另一个数组用来输入每位评委的评分。对于每评委的分数进行排序，算出最大值和最小值，再按照题意算出平均分，最后再将每位同学的平均分从大到小排序，按排名输出编号。

 [AC](https://www.luogu.com.cn/record/209367317) **Code**：

 
```cpp
#include<bits/stdc++.h>
using namespace std;
struct f{
	int id;	//编号
	double s; //平均分 
}ans[110];
int n,m,a[110];
bool cmp(f a,f b){
	if(a.s!=b.s) return a.s>b.s;
	return a.id<b.id;
} //排序
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		ans[i].id=i; //记录编号
		for(int j=1;j<=m;j++){
			cin>>a[j]; //输入每位评委的分数
			ans[i].s+=a[j];
		}
		sort(a+1,a+m+1); //排序算出
		ans[i].s=(ans[i].s-a[1]-a[m])*1.0/(m-2); //计算平均分
	}
	sort(ans+1,ans+n+1,cmp); //排序
	for(int i=1;i<=n;i++)
		cout<<ans[i].id<<' '; //输出
	return 0;
} //管理员求过QWQ
```
完结撒花！！！

---

## 作者：XsIeEiKcEk (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11950)

## 题目大意

给出 $N$ 个序列，根据他们的去掉最大数和最小数的平均数排序。若一样，靠前的排前面。最后根据排名顺序分别输出它们的序号。

## 解法

建立一个结构体，记录平均数、序号，再建立一个函数搭配 `std::sort` 进行排序。

## [AC](https://www.luogu.com.cn/record/209369581) CODE


```cpp
#include<iostream>
#include<algorithm>//sort头文件
using namespace std;
struct node{
    int num,score[100];//序号、分数
    double res=0;//平均数
}jumper[100];
bool comp(node a,node b){//比较
    if(a.res!=b.res)return a.res>b.res;
    else return a.num<b.num;
}
int n,m;
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        jumper[i].num=i+1;//记录序号，+1是因为它的下标是从0开始的
        int max_now=-1,min_now=101;//记录最大值和最小值
        for(int j=0;j<m;j++){
            cin>>jumper[i].score[j];
            max_now=max(max_now,jumper[i].score[j]);//更新，下同
            min_now=min(min_now,jumper[i].score[j]);
            jumper[i].res+=jumper[i].score[j];
        }
        jumper[i].res=(jumper[i].res-max_now-min_now)/(m-2);//得出平均数
    }
    sort(jumper,jumper+n,comp);//排序
    for(int i=0;i<n;i++)cout<<jumper[i].num<<' ';
    return 0;
}
```

---

## 作者：DLJdouliangjian (赞：2)

## P11950 [科大国创杯初中组 2023] 评分  
这题纯模拟。  
定义一个结构体，对于每个人，把他们的最高分和最低分求出来，再把去掉一个最高分，一个最低分的平均分算出来。  
最后排序，先按平均分排序，再按编号排序。  
### CODE
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,a[105];
struct node{
    int id;
    double x;
}f[105];
bool cmp(node x,node y){
    if(x.x!=y.x){
        return x.x>y.x;
    }
    return x.id<y.id;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int maxn=-0x3f3f3f3f,minn=0x3f3f3f3f,sum=0;
        for(int j=1;j<=m;j++){
            cin>>a[j];
            sum+=a[j];
            maxn=max(maxn,a[j]);
            minn=min(minn,a[j]);
        }
        f[i].id=i;
        f[i].x=(sum-maxn-minn)/(double)(m-2);
    }
    sort(f+1,f+n+1,cmp);
    for(int i=1;i<=n;i++){
        cout<<f[i].id<<" ";
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

# 题目思路

读入数据后先给数组排个序，再计算出平均数。

```cpp
int n,m;
cin >> n >> m;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++) cin >> a[i][j];
		sort(a[i]+1,a[i]+m+1);
		double sum=0;
		for(int j=2;j<=m-1;j++) sum+=a[i][j];//累加求和
		k[i].b=sum/(m-2);//记得要去掉2个数
		k[i].id=i;
    //用结构体是为了等一下排序
}
```

现在按分数排序，分数一样就按编号。

```cpp
bool cmp(fen a,fen b){
	if(a.b!=b.b) return a.b>b.b;
	else return a.id<b.id; 
}
```

最后输出就行啦！

```cpp
for(int i=1;i<=n;i++) cout << k[i].id << " ";
```

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101][101];
struct fen{
	double b;
	int id;
}k[101];
bool cmp(fen a,fen b){
	if(a.b!=b.b) return a.b>b.b;
	else return a.id<b.id; 
}
int main(){
	int n,m;
	cin >> n >> m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin >> a[i][j];
		sort(a[i]+1,a[i]+m+1);
		double sum=0;
		for(int j=2;j<=m-1;j++) sum+=a[i][j];
		k[i].b=sum/(m-2);
		k[i].id=i;
	}
	sort(k+1,k+n+1,cmp);
	for(int i=1;i<=n;i++) cout << k[i].id << " ";
	return 0;
}
```

---

## 作者：wrh316 (赞：2)

### 思路
没什么好说的。。。

按照题意模拟即可。首先输入，然后求和并去掉最大值和最小值，算出平均分。最后，按分数大小以及先后顺序输出即可。

### 代码
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 105;
int n, m, a[N][N], ma[N], mi[N];
struct node {
	double score;
	int id;
} sum[N];
bool cmp(node x, node y) {
	if (x.score != y.score) return x.score > y.score;
	return x.id < y.id;
}
int main() {
	memset(mi, 0x3f, sizeof(mi));
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
			ma[i] = max(ma[i], a[i][j]);
			mi[i] = min(mi[i], a[i][j]);
		}
		sum[i].score = 0, sum[i].id = i;
	}
	for (int i = 1; i <= n; i++) {
		bool f1 = false, f2 = false;
		for (int j = 1; j <= m; j++) sum[i].score += a[i][j];
		sum[i].score -= (ma[i] + mi[i]);
		sum[i].score /= (m - 2);
	}
	sort(sum + 1, sum + n + 1, cmp);
	for (int i = 1; i <= n; i++) cout << sum[i].id << " ";
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：2)

题目传送门：[P11950 [科大国创杯初中组 2023] 评分](https://www.luogu.com.cn/problem/P11950)

### 做题思路

按照题意模拟即可。

建立结构体数组维护每个选手的编号和分数，以及二维数组存储 $n$ 名选手每人每个评委打的分。然后将每个选手的总分减去一个最大值和一个最小值。

由于直接比较总和与比较平均数结果一样，所以无需将它变成平均数。

### 代码实现

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,a[101][101];
struct node{
    int i,s;//编号和总分
}d[101];
bool cmp(node a,node b){
    if(a.s==b.s)return a.i<b.i;
    return a.s>b.s;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        d[i].i=i;
        int mxd=0,mnd=100;
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            d[i].s+=a[i][j];//加上每个评委的分
            mxd=max(mxd,a[i][j]),mnd=min(mnd,a[i][j]);
        }
        d[i].s-=mxd+mnd;//此处如果取平均数，反而涉及精度误差等
    }
    sort(d+1,d+n+1,cmp);//排序
    for(int i=1;i<=n;i++)cout<<d[i].i<<' ';//输出编号
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/209315324)。

---

## 作者：Zhu_PingYuan (赞：0)

思路：按照题意模拟即可
1. 对评委分数排序
2. 计算每位选手的总分
3. 对总分排序
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
int s[105];
struct node
{
	int sum;
	int id;
}t[105];
bool cmp(node a, node b) //按照分数排序
{
	if(a.sum != b.sum)
		return a.sum > b.sum;
	return a.id < b.id;
}
int main()
{
	memset(t, 0, sizeof(t));
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
			cin >> s[j];
		sort(s + 1, s + m + 1);
		for(int j = 2; j <= m - 1; j++)
			t[i].sum += s[j];
		t[i].id = i;
        //因为每位选手的评委人数相同，所以不需要除以评委人数
	}
	sort(t + 1, t + n + 1, cmp); //排名
	for(int i = 1; i <= n; i++)
		cout << t[i].id << " "; //t[i].id 表示第 i 名的编号
	return 0;
}
```

---

## 作者：Manchester_City_FC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11950)

一道简单的结构体练习题。

题目大意比较易懂，这里就不再赘述。

我们可以计算出每个选手的总分并减去最高分和最低分，此时不需要计算出平均分，因为评委的总数是一样的。然后按照题意排序即可，注意最后是按照选手的编号输出。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101;
struct dive{
	int tot,id;//tot 表示去掉最低、最高分的总分，id 代表选手编号 
}a[N];
int n,m,s[N],sum;
bool cmp(dive x,dive y){
	if(x.tot!=y.tot) return x.tot>y.tot;//若总分不一样，较高者靠前
	else return x.id<y.id;//总分相同，编号较小着靠前 
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		sum=0,a[i].id=i;
		for(int j=1;j<=m;j++){
			cin>>s[j];
			sum+=s[j];
		}
		sort(s+1,s+m+1);
		a[i].tot=sum-s[1]-s[m];//总分去掉最高和最低分 
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) cout<<a[i].id<<' ';
}
```

---

## 作者：nightwatch.ryan (赞：0)

### Analysis
对于每一位选手 $i$：先将 $m$ 个评委的评分读入，用数组 $t$ 存储（下标从 $1$ 开始），然后将数组 $t$ 升序排序，然后用 $all$ 累加 $t_2$ 到 $t_{m-1}$ 之间所有评分的值，然后 $all$ 除以 $m - 2$，即为第 $i$ 位选手的得分。

按照每位选手最终的得分排序，得分高的排前面，得分低的排后面，如果得分相同，则按照选手编号排。
### Code
```cpp
#include <bits/stdc++.h>
const int N = 1e2 + 5;
struct Node { 
    double w;
    int i; 
} a[N];
double t[N];
int main() {
    int n, m;
    std::cin >> n >> m;
    for (int i = 1; i <= n; i ++) {
        a[i].i = i;
        for (int j = 1; j <= m; j ++) std::cin >> t[j]; 
        std::sort(t + 1, t + 1 + m);
        double all = 0;
        for (int j = 2; j < m; j ++) {
            all += t[j];
        }
        all = all / (m - 2);
        a[i].w = all;
    }
    std::sort(a + 1, a + 1 + n, [](Node a, Node b){
        if(a.w != b.w) {
            return a.w > b.w;
        }
        return a.i < b.i;
    });
    for (int i = 1; i <= n; i ++) {
        std::cout << a[i].i << " ";
    }
}
```

---

## 作者：NTT__int128 (赞：0)

先给每个选手的得分乘上 $m-2$。显然，不影响最后的排名，且每位选手的得分均为整数。

将选手的 $m$ 个得分从小到大排序，总的减去第 $1$ 个和第 $m$ 个即为该选手的得分。

然后记录编号，排序即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[105];
struct player{
	int v,id;
	bool operator<(const player&a)const{return (v==a.v?id<a.id:v>a.v);}
}p[105];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int tot=0;
		for(int i=1;i<=m;i++)cin>>a[i],tot+=a[i];
		sort(a+1,a+m+1);
		tot-=a[1]+a[m];
		p[i]={tot,i};
	}
	sort(p+1,p+n+1);
	for(int i=1;i<=n;i++)cout<<p[i].id<<' ';
	return 0;
}
```

---


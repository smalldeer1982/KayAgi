# 子数整数

## 题目描述

对于一个五位数 $\overline{a_1a_2a_3a_4a_5}$，可将其拆分为三个子数：

$sub_1=\overline{a_1a_2a_3}$

$sub_2=\overline{a_2a_3a_4}$

$sub_3=\overline{a_3a_4a_5}$

例如，五位数 $20207$ 可以拆分成

$sub_1=202$

$sub_2=020\ (=20)$

$sub_3=207$

现在给定一个正整数 $K$，要求你编程求出 $10000$ 到 $30000$ 之间所有满足下述条件的五位数，条件是这些五位数的三个子数 $sub_1,sub_2,sub_3$ 都可被 $K$ 整除。


## 说明/提示

$0<K<1000$


## 样例 #1

### 输入

```
15```

### 输出

```
22555
25555
28555
30000```

# 题解

## 作者：疯的、风 (赞：207)

这道题目。。

嗯。。暴力就是最优解。。。

我的思路就是先从前三位数开始判断，找到满足条件的数s，再以s的2到4位判断，若符合，则继续判断3到5位是否符合。

蒟蒻代码。。。。。。。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool f;//f用来判断是否有符合条件的数
int main()
{
    int k,a1;
    cin>>k;
    for(int i=10000;i<=30000;i++)
    {
      if(i/100%k==0)//判断1到3位
          if((i/10-i/10000*1000)%k==0)//判断2到4位
            if((i-i/1000*1000)%k==0) cout<<i<<endl,f=1;//判断2到5位，若都符合，输出该数，f为真，继续搜索
    }
    if(!f) cout<<"No";
    return 0;
}
```

---

## 作者：Starry___sky (赞：68)

我的做法十分暴力。见下
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
bool f=0;//判断是否有正确答案
int main()
{
	int k,s1,s2,s3,g,s,b,q,w;//前四个题中有，后五个分别记录个，十，百，千，万位。
	cin>>k;//读入k
	for(int i=10000;i<=30000;i++)//逐个判断
	{
		g=i%10000%1000%100%10;//取出个位
		s=i/10%1000%100%10;//取出十位
		b=i/100%100%10;//取出百位
		q=i/1000%10;//取出千位
		w=i/10000;//取出万位
		s1=100*w+10*q+b;//分别计算sub1,sub2,sub3.
		s2=100*q+10*b+s;
		s3=100*b+s*10+g;
		if(s1%k==0&&s2%k==0&&s3%k==0)							cout<<i<<endl,f=1;//若sub1,sub2,sub3能被k整除输出i。将f赋为1，表示已有答案。
	}
	if(f==0)//若无答案
		cout<<"No";//输出No
	return 0;//你已经AC了
}

```


---

## 作者：Dilute (赞：61)

##为什么你们都这么暴力呢？？？

###结果我还是活生生地把暴力写成全部0ms。。。

好吧我必须得说这道题数据范围太小了。。。

我还如此煞费苦心地搞了优化。。。

```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
    int x;
    scanf("%d", &x);
    int i = 100; // 前三位 
    bool emp = 0;
    while(i % x != 0) i++; // 找到第一个能够被x整除的3位数 
    int qe, es; // qe代表2-3两位，es代表3-4两位（为了方便都在后面加了个0） 
    for( ; i < 300; i += x){ // 穷举前三位 
        qe = (i % 100) * 10; // 生成qe 
        for(int j = 0; j < 10; j++){ // 穷举第四位 
            if((qe + j) % x != 0) continue; // 看看2-4位能不能被x整除 
            es = (qe % 100 + j) * 10; // 生成es 
            for(int u = 0; u < 10; u++){ // 穷举最后一位 
                if((es + u) % x != 0) continue; // 和前面那个差不多的整除判定 
                printf("%d%d%d\n", i, j, u); // 输出 
                emp = 1; // 打个标记 
            }
        }
    }
    if(300 % x == 0){ // 注意！注意！这里我特判了一下30000 （30000是只用判定前三位因为它后面都是0）因为，如果前面那个改成<=的话，那么会把30000~30999都给穷举进去 
        emp = 1;
        printf("30000");
    }
    if(!emp) printf("No"); // 如果一个都没有 
}
```

---

## 作者：davywxy2003 (赞：50)

水题！！！


先循环，

再把“sub1”,“sub2”,“sub3”取来，直接判断是否能被k整除如果有这样的数则输出，没有则输出No。


附C语言代码：

```cpp
#include<stdio.h>
#include<stdlib.h>
int main()
{
int k;
int i,ans;
int sub1,sub2,sub3;
scanf("%d",&k);
    for(i=10000;i<=30000;i++)
    {
        sub1=i/100;
        sub2=i%10000/10;
        sub3=i%1000;
        if((sub1%k==0)&&(sub2%k==0)&&(sub3%k==0))
        {
            printf("%d\n",i);
            ans=1;
        }
    }
if(ans!=1)
printf("No");    
}    

```

---

## 作者：Administrator2004 (赞：45)

```cpp
//这道题我想的是直接模拟，居然AC了...
//看了其他人的代码才发下我这个确实写复杂了
//不过很好理解（详见注释） 
#include <iostream>
using namespace std;
int sub1(int n)            //题面中的sub1 
{
    int wan=n/10000;    //取出这个数的万位，千位，百位 
    int qian=n/1000%10;
    int bai=n/100%10;
//下面就是把这三个数拼成一个数 
    if(wan==0)             //最高位不能为0，所以只拼下两位 
    return qian*10+bai;
    return wan*100+qian*10+bai;
}
int sub2(int n)            //题面中的sub2 
{
    int qian=n/1000%10;    //取出这个数的千位，百位，十位 
    int bai=n/100%10;
    int shi=n/10%10;
    if(qian==0)            //同上，最高位不能为0 
    return bai*10+shi;
    return qian*100+bai*10+shi;
}
int sub3(int n)            //题面中的sub3 
{
    int bai=n/100%10;    //取出这个数的百位，十位，个位 
    int shi=n/10%10;
    int ge=n%10;
    if(bai==0)            //同上，最高位不能为0 
    return shi*10+ge;
    return bai*100+shi*10+ge;
}
int main()
{
int k;
cin>>k;
int judge=0;                    //judge用来判断是否有解 
for(int i=10000;i<=30000;i++)    //按照题目中的范围枚举
    if(sub1(i)%k==0&&
    sub2(i)%k==0&&
    sub3(i)%k==0)                //模拟 
        {
            cout<<i<<endl; 
            judge++;            //答案加一 
        }
    if(judge==0)
    cout<<"No";                 //没答案输出No 
}
```

---

## 作者：GodRaymond (赞：22)

尚未入门的小白首发题解,不喜勿喷……

运用结构体struct！

在 C/C++中，结构体是一个包含多项数据（类型可以不同）的一个数据“结构”，使用前我们要先进行类型定义。

结构体类型是我们用户在 C++基本内置类型的基础上自己定义的数据类型（自定义类型）。

不废话,上代码。

```cpp
#include<iostream>
using namespace std;
struct sz//定义结构体sz(数字,当然可以是其他的)
{
  int x,y,z;//定义前三位x,中三位y,后三位z.
}a[30001];
int main()
{
  int k,s=0;//定义k和"储钱罐"s(用来判断是否有子数整数被k整除)
	cin>>k;//输入k
	for(int i=10000;i<=30000;i++)//循环20000次,严格遵守题目范围,10000到30000
	{
		a[i].x=i/100;//由于是整形,相当于斩去后两位,得到前三位
		a[i].y=(i/10)%1000;//同理,先斩去后一位,再"模"1000,就是斩去最后一位后除以1000的余数,显然就是斩去最后一位后的后三位,即原数的中间三位
                a[i].z=i%1000;//同理,原数"模"1000,即后三位
	}
	for(int i=10000;i<=30000;i++)
	{
		if(a[i].x%k==0&&a[i].y%k==0&&a[i].z%k==0)//如果均被k整除(这里妙用结构体,将i与x与y与z"打包")
		{
			cout<<i<<endl;
			s++;//注意,"储钱罐"中放入"一元钱"
		}
	}
	if(s==0) cout<<"No"<<endl;//进行判断,若"储钱罐"中没钱,即不存在五位数被k整除,输出No
	return 0;
}

```
便于大家理解的简单解法

---

## 作者：izumi远欣 (赞：19)

### 这个是Python题解

### 题目思路：
简单的来说就是暴力解决问题

枚举所有的10000~30000

寻找符合条件的数字输出

很适合Python练手

### 代码+注释：
```python
a=int(input())
# 这里是数字的输入（好麻烦）
d=False
# 判定是否有符合条件的记录变量
for c in range(10000,30001):
	# 暴力的枚举
    b1=int(c/100)
    b2=int((c/10)%1000)
    b3=int(c%1000)
    # 取得三个子数，以下是三个连续的判定
    if b1%a==0:
        if b2%a==0:
            if b3%a==0:
                print(c)
                d=True 
                # 记录是否有解
if d==False:
    print("No")
# 如果没解，退出输出No
```

第一次出Python的题解，有错误的地方希望大家指正

---

## 作者：Mr_WA的大大号 (赞：10)

## 本蒟蒻又来写题解了


 字数整数这题知识点在于
###  把数字拆分
易错点在于
### 拆分时容易拆错
现在来分析题目，他说要把数字分成三个三位字数分别分成
###### 万位 千位 百位 ，千位 百位 十位，百位 十位 个位。


------------
#### 看第一个数我们用公式a=i/10000*100+i/1000%10*10+i/100%10;求出

#### 看第二个数我们用公式b=i/1000%10*100+i/100%10*10+i/10%10;求出

#### 看第三个数我们用公式
#### c=i/100%10*100+i/10%10*10+i%10;求出


------------

温馨提示：第二和第三个数百位不要忘记%10哦

# 好了献上代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>

using namespace std;
int k;
int a,b,c;
int p;
int main()
{
cin>>k;
for(int i=10000; i<=30000; i++)//注意范围 
{
	a=i/10000*100+i/1000%10*10+i/100%10;
    b=i/1000%10*100+i/100%10*10+i/10%10;	
    c=i/100%10*100+i/10%10*10+i%10;//以上为重点公式 
    if(a%k==0&&b%k==0&&c%k==0)
    {
    		cout<<i<<endl;
    		p=1;//做标记 
    }

}
if(p==0)cout<<"No";//被忘了输出No 
return 0;
}
```
### 谢谢观赏


---

## 作者：5ab_juruo (赞：9)

这道题其实就是从一个数上截取三个片段，判断能否被整除的一个问题。大致难点只有算出sub了。

---------

首先是输入输出：
```cpp
int q,sub1,sub2,sub3;
bool is_it=false;//看是否存在
cin>>q;
```
接下来我们要循环检测。首先要提出sub1,sub2和sub3。
对于这个问题，我们直接使用求余和除法解决。
```cpp
sub1=num/100;//除以100过滤前两位
sub2=(num%10000)/10;//对10000求余过滤后一位，除以10过滤第一位
sub3=num%1000;//对1000求余过滤后两位
```
接下来是判断是否整除：
```cpp
if(sub1%q==0 && sub2%q==0 && sub3%q==0)
{
	cout<<num<<endl;
	is_it=true;//让之后不输出“No”
}
```
最后判断是否输出"No"：
```cpp
if(!is_it)//因为is_it的初始值为false
	cout<<"No"<<endl;
```
连起来就是：
```cpp
#include<iostream>
using namespace std;

int main()
{
	int q,sub1,sub2,sub3;
	bool is_it=false;
	cin>>q;
	for(int num=10000;num<=30000;num++)
	{
		sub1=num/100;
		sub2=(num%10000)/10;
		sub3=num%1000;
		if(sub1%q==0 && sub2%q==0 && sub3%q==0)
		{
			cout<<num<<endl;
			is_it=true;
		}
	}
	if(!is_it)
		cout<<"No"<<endl;
	return 0;
}
```
总结：
1.对x求余可以过滤高位，除x可以过滤低位，从而取得中间值（回想一下，当年求多位数各位数和是不是这么干的？）2.在循环内打标记可以防止在循环外仍然输出"No"。

---

## 作者：fzj2007 (赞：8)

# 你没看错，一道暴力。。

这个题就是一个暴力。。

我们要判断前三位、中三位和后三位。。

前三位就是i%1000注意是取余1000啊

中三位是i/10%1000（~~本人普及组还没考，不会>>~~）

后三位就是i/100 不是1000啊注意了

直接从10000开始模拟到30000

下面看代码


```
[AC连接看看](https://www.luogu.org/record/22858193)#include<bits/stdc++.h>//万能头
using namespace std;
int n,a,b,c,t=1; 
int main(){
  //教大家个东西 这个把输入流关掉，速度也很快(估计大佬都会。。）
   ios::sync_with_stdio(false);
	cin>>n;
	for(int i=10000;i<=30000;i++){
		int v=i;
		a=v%1000;//这是取余1000啊，别写错了。。刚开始写成100了。。
		b=v/10%1000;//除以十再取余1000~
		c=v/100;//这里是除以100啊。。
		if(a%n==0&&b%n==0&&c%n==0){
			printf("%d\n",i);//输出~
			t=0;标记是否有解
		} 
	}
                                  //无解输出No，注意o是小写的
	if(t) printf("%s\n","No");
	return 0;
}

```
华丽的结束~
看到这里的记得点个赞啊[AC了](https://www.luogu.org/record/22858193)

---

## 作者：SCLBJKD (赞：6)

~~看到那么多daolao，蒟蒻好害怕，发现自己的解法好弱智。~~

我的思路是字符串，跟daolao的数字无法相比，真是膜拜~~

好啦，还是说一说我的解题思路吧！定义一个函数，判断此数是否满足条件：被k整除，注意是那个数 mod k，而不是k mod 那个数。

代码如下（还会讲的）：
```pascal
var
        k,i:longint;
        p:boolean;
function ss(n:longint):boolean;		//函数
var
        s1,s2,s3,n1:string;
        t1,t2,t3:longint;
begin
        ss:=false;
        str(n,n1);		//先把进来的数转化为一个字符串
        s1:=copy(n1,1,3);	//s1是第一部分
        s2:=copy(n1,2,3);	//s2是第一部分
        s3:=copy(n1,3,3);	//s3是第一部分
        val(s1,t1);		//将s1转化为数字t1
        val(s2,t2);		//将s2转化为数字t2
        val(s3,t3);		//将s3转化为数字t3
        if (t1 mod k=0)and(t2 mod k=0)and(t3 mod k=0) then ss:=true;	//看看这三部分能不能都mod k=0
end;
begin
        readln(k);		//读入
        for i:=10000 to 30000 do	//从一万找到三万
                if ss(i)=true then		//判断i是否符合条件
                begin
                        p:=true;	//说明有解
                        writeln(i);
                end;
        if p=false then writeln('No');	//如果无解，输出'No'；
end.

```
结束了，题目很简单，希望能够帮助到大家！谢谢！

---

## 作者：「QQ红包」 (赞：4)

开始错了，发现自己忽略NO这种情况了。

枚举吧……这道题很适合新手。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
int n,a,b,c;
using namespace std;
int main()
{
    int sum=0;
    scanf("%d",&n);//读入 
    for (int i=10000;i<=30000;i++)//枚举 
    {
        a=i/100;//求出前三位 
        b=(i/10)%1000;//求出中间三位 
        c=i%1000;//求出最后三位 
        if ((a%n==0)&&(b%n==0)&&(c%n==0)) //如果满足条件 
        {
            printf("%d\n",i);//输出 
            sum=1;//标记 
        }
    }
    if (sum==0) cout<<"No";//没有的话就输出No。 
    return 0;
}

```

---

## 作者：yuyc (赞：3)

这道题的范围很小，所以直接暴力模拟就OK。

首先，我们得要知道怎么分解一个数的各个位，其实你只用记住一个公式：

                          个位=那个数%10
有的小伙伴就会问了：那么十位，百位要怎么求呢？我们可是要求到万位

别急别急，我数学老师说，学数学重要的是把新的知识转化成旧知识。那么我们就可以把十位变成个位，除以10就行了，c++两个整数除，自动舍去小数部分，所以除以10过后就直接运用个位的公式。百位就除以100，因此类推~

可值得注意的是，万位的时候，除以10000后就直接得到个位了。
于是得到:
```cpp
 ge　  =　i%10;
 shi 　=　i/10%10;
 bai 　=　i/100%10;
 qian　=　i/1000%10;
 wan 　=　i/10000;
```
之后的模拟就很好打了，代码如下：
```cpp
#include <stdio.h>//貌似没用到　　　　　
#include <iostream>　　　　　　　　　　　　　　
#include <algorithm>//貌似没用到
using namespace std;　　　　　　
int main()　　　　　　
{　　　　　　　　　　　　　　　　　　
  　int k = 0;　　　　　　　　　　
 　 int ge = 0,shi = 0,bai = 0,qian = 0,wan = 0;　//简单明了的变量
 　 int sub1 = 0,sub2 = 0,sub3 = 0;　　　
 　 int flag = 0;　　　//检测有没有　　　　
 　 cin >> k;　　　　　　　　
 　 for(int i = 10000; i <= 30000; i++)　
　  {　　　　　　　　　　　　　　　
  　  ge    = i%10;　　　　　　　//分解　
  　  shi   = i/10%10;　　　　　　　　
  　  bai   = i/100%10;　　　　　　
  　  qian  = i/1000%10;　　　　　　　
 　   wan   = i/10000;　　　　　　　　　
 　   sub1 = wan * 100 + qian * 10 + bai;　//直接模拟　　　　　
 　   sub2 = qian * 100 +bai * 10 + shi;　　　　　　　
  　  sub3 = bai * 100 +shi * 10 + ge;　　　　　
 　   if((sub1 % k == 0) && (sub2 % k == 0) && (sub3 % k == 0))//判断是否符合条件
 　   {　　　　　　
  　    flag = 1;　　　　　　　　
 　     cout << i << endl;　　　　　　　
 　   }　　　　　　　　
　  }　　　　　　　　　
 　 if(flag == 0)　　//如果没有就输出No　　　　　　
 　 {　　　　　　　　　
 　   cout << "No";　　　　　　　　　
　  }　　　　　　　　　
　  return 0;　　　　　　　　　
}　　　　　　　　
```
您可以复制这段代码，然后就可以~~AC~~CE了

珍爱生命，远离CE



---

## 作者：xzy062609 (赞：3)

# 本题是水题
思路很简单：
       
五位数a1a2a3a4a5有三个子数sub1,sub2,sub3,

sub1=a1a2a3

sub2=a2a3a4

sub3=a3a4a5

从10000到30000循环，把这个数转化成如果a1a2a3a4a5,再组成sub1,sub2,sub3，如果都sub1,sub2,sub3能被输入的k整除，输出这个数

如果没有符合条件的数，输出“NO”
```cpp
#include<bits/stdc++.h>//万能头文件就是好用 
using namespace std;
int main()//愉快的开始了主函数 
{
    int k,sx=0;//k要输入，sx为计数器，看有几个 满足条件的数 
    cin>>k;//输入 
    for(int i=10000;i<=30000;i++)//从10000到30000循环 
    {
    	if(i/100%k!=0||(i/10-i/10000*1000)%k!=0||(i-i/1000*1000)%k!=0)//如果不满足条件 
		continue;
      	sx++;//计数器加1 
      	cout<<i<<endl;//输出满足条件的数 
    }
    if(sx==0)cout<<"No";//如果没有满足的，输出"No" 
}
```


---

## 作者：XCD_OIworld_rookie (赞：3)

先送表（5—1000）1-4打死我也不做
```cpp
5:
10000
10005
10050
10055
10500
10505
10550
10555
11000
11005
11050
11055
11500
11505
11550
11555
12000
12005
12050
12055
12500
12505
12550
12555
13000
13005
13050
13055
13500
13505
13550
13555
14000
14005
14050
14055
14500
14505
14550
14555
15000
15005
15050
15055
15500
15505
15550
15555
16000
16005
16050
16055
16500
16505
16550
16555
17000
17005
17050
17055
17500
17505
17550
17555
18000
18005
18050
18055
18500
18505
18550
18555
19000
19005
19050
19055
19500
19505
19550
19555
20000
20005
20050
20055
20500
20505
20550
20555
21000
21005
21050
21055
21500
21505
21550
21555
22000
22005
22050
22055
22500
22505
22550
22555
23000
23005
23050
23055
23500
23505
23550
23555
24000
24005
24050
24055
24500
24505
24550
24555
25000
25005
25050
25055
25500
25505
25550
25555
26000
26005
26050
26055
26500
26505
26550
26555
27000
27005
27050
27055
27500
27505
27550
27555
28000
28005
28050
28055
28500
28505
28550
28555
29000
29005
29050
29055
29500
29505
29550
29555
30000
6:
10240
10246
10840
10846
11444
12042
12048
12642
12648
13240
13246
13840
13846
14444
15042
15048
15642
15648
16240
16246
16840
16846
17444
18042
18048
18642
18648
19240
19246
19840
19846
20420
20426
20480
20486
21024
21084
21624
21684
22222
22228
22282
22288
22822
22828
22882
22888
23420
23426
23480
23486
24024
24084
24624
24684
25222
25228
25282
25288
25822
25828
25882
25888
26420
26426
26480
26486
27024
27084
27624
27684
28222
28228
28282
28288
28822
28828
28882
28888
29420
29426
29480
29486
30000
7:
10560
10567
11266
11966
12665
13364
14063
14763
15462
15469
16161
16168
16861
16868
17560
17567
18266
18966
19665
20350
20357
21056
21756
22455
23154
23854
24553
25252
25259
25952
25959
26651
26658
27350
27357
28056
28756
29455
8:
10400
10408
10480
10488
11200
11208
11280
11288
12000
12008
12080
12088
12800
12808
12880
12888
13600
13608
13680
13688
14400
14408
14480
14488
15200
15208
15280
15288
16000
16008
16080
16088
16800
16808
16880
16888
17600
17608
17680
17688
18400
18408
18480
18488
19200
19208
19280
19288
20000
20008
20080
20088
20800
20808
20880
20888
21600
21608
21680
21688
22400
22408
22480
22488
23200
23208
23280
23288
24000
24008
24080
24088
24800
24808
24880
24888
25600
25608
25680
25688
26400
26408
26480
26488
27200
27208
27280
27288
28000
28008
28080
28088
28800
28808
28880
28888
29600
29608
29680
29688
9:
10810
10819
11711
12612
13513
14414
15315
16216
17117
18018
18918
19810
19819
20720
20729
21621
22522
23423
24324
25225
26126
27027
27927
28828
29720
29729
10:
10000
11000
12000
13000
14000
15000
16000
17000
18000
19000
20000
21000
22000
23000
24000
25000
26000
27000
28000
29000
30000
11:
20990
22099
23198
24297
25396
26495
27594
28693
29792
12:
10840
12048
13240
14444
15648
16840
18048
19240
20480
21684
22888
24084
25288
26480
27684
28888
30000
14:
11266
15462
16868
18266
15:
22555
25555
28555
30000
16:
11288
12880
14480
16080
17688
19288
20800
22400
24000
25608
27208
28800
18:
28828
19:
20950
22855
28551
20:
10000
12000
14000
16000
18000
20000
22000
24000
26000
28000
30000
24:
26480
28888
25:
10000
12500
15000
17500
20000
22500
25000
27500
30000
27:
10810
13513
16216
18918
21621
24324
27027
29729
30:
30000
31:
15589
18682
32:
19288
37:
11111
14814
18518
22222
25925
29629
40:
12000
16000
20000
24000
28000
50:
10000
15000
20000
25000
30000
57:
22855
60:
30000
62:
18682
74:
22222
75:
30000
80:
24000
100:
10000
20000
30000
111:
11111
22222
125:
12500
25000
150:
30000
200:
20000
222:
22222
250:
25000
300:
30000
```
AC
```cpp
#include<iostream>
using namespace std;
int x=1;
int main(){
	int k;
	cin>>k;
	for(int i=10000;i<=30000;i++){
		if((i/100)%k==0&&(i/10%1000)%k==0&&(i%1000)%k==0){
			cout<<i<<endl;
			x=0;
		} 
	}
	if(x==1) cout<<"No"<<endl;
}
```

---

## 作者：Xeonacid (赞：3)

因为会多次取sub1/sub2/sub3，所以我写了一个sub函数。

```cpp
int sub(int m,int n){
    switch(n){  //case的1/2/3即为sub1/sub2/sub3
        case 1:return m/100;          //因为用的是return，所以不需要每个加break了
        case 2:return m/10%1000;
        case 3:return m%1000;
    }
}
```
判断整除if那里一定要注意好运算符先后顺序，加上括号，为了保险起见（我才不会说是因为我蒟蒻呢）括号多加几个。

完整代码：

```cpp
#include<iostream>
using namespace std;
int k,flag;  //用flag判断是否有解，默认为0
int sub(int m,int n){
    switch(n){
        case 1:return m/100;
        case 2:return m/10%1000;
        case 3:return m%1000;
    }
}
int main(){
    cin>>k;
    for(int i=10000;i<=30000;++i){ //区间内逐个扫描
        if(!(sub(i,1)%k)&&!(sub(i,2)%k)&&!(sub(i,3)%k)){  //sub1/sub2/sub3全部整除便输出
            cout<<i<<endl;
            flag=1;   //有解则改为1
        }
    }
    if(!flag)   //最后仍为0即为无解
        cout<<"No";
    return 0;
}
```

---

## 作者：deathR (赞：3)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
int k,a=10000,a1,a2,a3,p=0;//定义==,我连数组都没用哈哈哈哈，p是个伏笔 
cin>>k;//这个咱校长都看的懂 
for(;a<=30000;a++)//开始循环10000-30000 ,从小到大 
{
    a1=a/100;//应该懂吧 
    a2=(a-a1/100*10000)/10;//去掉头就行，就是算出a的第一个数，减去它的10000倍 
    a3=(a-a1/10*1000);//我只会这么做==
    if(a1%k==0&&a2%k==0&&a3%k==0)
    {
    cout<<a<<endl;
    p=a;//判断 
    } 
}
if(p==0)//p判断是否有符合的数 
cout<<"No";
return 0; //这方法很简单…… 好困……三点了，明天放半天假，真开心 
}

```

---

## 作者：ZHDX (赞：2)

我们来洛谷是为了练习提高自己的. 

不是为了过题而过题的. 

即使是很简单的题, 我们依然可以考虑如何做得更好. 

提高自己在每一个细微之处的编程能力,


下面的解法就是希望把循环次数压缩到最小. 


ceil函数, 就是把小数往高取整. (而floor是往低取整)

例如

ceil(13.2) => 14

floor(13.2) => 13

那么 

15 * ceil(100.0 / 15.0) 便等于 15 * ceil(6.66) = 15 * 7 = 105 

直接找到第一个对15整除的数. 

当然不用ceil , 也可以写成

15 * ( 100/15 + ( 100%15 ? 1 : 0) )

在代码里为

k * (100 / k + (100 % k ? 1 : 0))


我个人喜欢用ceil是因为工作中需要把代码写得更容易阅读理解, 是一个工程向选择.


```cpp

#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;

int main()
{
	int k;
	cin >> k;

	if (k == 1)
	{
		for (int i = 10000; i <= 30000; i++)
			cout << i << endl;
		return 0;
	}

	int match = 0;
	//int loopcount = 0;

	for (int s1 = k * ceil(100 / (float)k); s1 < 300; s1 += k)
	{
		//loopcount++;
		int s2s = (s1 % 100) * 10;
		for (int s2 = k * ceil(s2s / (float)k); s2 < s2s + 10; s2 += k)
		{
			//loopcount++;
			int s3s = (s2 % 100) * 10;
			for (int s3 = k * ceil(s3s / (float)k); s3 < s3s + 10; s3 += k) {
				//loopcount++;
				match++;
				cout << s1 * 100 + (s2 % 10) * 10 + (s3 % 10) << endl;
			}
		}
	}

	if (300 % k == 0)
	{
		cout << 30000 << endl;
		match++;
	}

	//cout << "loopcount:" << loopcount << endl;

	if (!match)
	{
		cout << "No";
	}

	return 0;
}


```


---

## 作者：linyorson (赞：2)

这题也没什么难点，就是把所有的情况都罗列一遍，符合条件就输出。如果没有才输出"No"。这题就是简单的搜索啊，怎么没人做呢？奇怪。

```cpp

#include<iostream>
using namespace std;   

int k,s=0;

int main()
{
    scanf("%d",&k);
    for(int i=10000;i<=30000;i++)
        if((i/100)%k==0 && (i/10%1000)%k==0 && (i%1000)%k==0)
        {printf("%d\n",i);s=1;}
    if(s==0)printf("No");
return 0;
}

```

---

## 作者：包子入侵 (赞：2)

//这个题目个人感觉还是有点难度的，讲下具体做法吧！开一个循环sub=a1a2a3a4a5从1000到3000

//并sub1=a1a2a3 sub2=a2a3a4s ub3=a3a4a5即 sub1=i/100; sub2=i%10000/10; sub3=i%1000;

//然后就是难点了，你要判断下sub1，sub2，sub3是否整除k，如果整除就输出，并ans=1用来判断是否有解

//判断整除if那里一定要注意好运算符先后顺序，加上括号，为了保险起见（我才不会说是因为我蒟蒻呢）括号多加几个。

//至于大佬们的什么优化就算了吧反正数据小直接暴力

//当然你可以用字符串来存，就不用求sub1，sub2，sub3了

```cpp
//下面就是代码了
#include<stdio.h>
int main()
{
int k;
int i,ans;
int sub1,sub2,sub3;
scanf("%d",&k);
    for(i=10000;i<=30000;i++)
    {
        sub1=i/100;
        sub2=i%10000/10;
        sub3=i%1000;
        if((sub1%k==0)&&(sub2%k==0)&&(sub3%k==0))
        {
            printf("%d\n",i);
            ans=1;
        }
    }
if(ans!=1)
printf("No");    
}
```

---

## 作者：LW_h_FP (赞：2)

看了前面大佬的，觉得sub1，sub2，sub3还是不需要那么复杂的，可以直接除出来
```
sub1=i/100
sub2=i/10%1000
sub3=i%1000
```
再写个判断函数就可以直接搜索了：
```
#include<iostream>
using namespace std;

int k,ok=1;

int sub(int i){
	return i/100%k==0 && i/10%1000%k==0 && i%1000%k==0;
}

int main(){
	cin>>k;
	for(int i=10000;i<=30000;i++)
		if(sub(i))
			cout<<i<<endl,ok=0;
	if(ok) cout<<"No";
}
```
ac结束，感谢支持。

---

## 作者：Weak_Konjak (赞：1)

一道简单的模拟题。。
直接上代码。。。
```cpp
#include<iostream>
using namespace std;
int k;//全局变量，使得函数能调用
bool pp;//是否找到
bool p(int x)//判断是否满足要求的函数
{
	int s3=x%1000,s2=x/10%1000,s1=x/100;//字数拆分
	return (!(s1%k||s2%k||s3%k));//判断。。。下文解释
}
int main()
{
	cin>>k;//输入
	for(int i=10000;i<=30000;i++)
	{
		if(p(i)){//如果满足要求
			pp=1;//找到了一个，标记
			cout<<i<<'\n';//输出
		}
	}
	if(!pp) cout<<"No";//假如一个都没有，输出“No”
}
```

------------

这里解释一下  return (!(s1%k||s2%k||s3%k)); 

其实这里同等与:

return ((s1%k==0)&&(s2%k==0)&&(s3%k==0));

c++中非0集真s1%k 即s1%k==0。

又因为(a&b) 与!((!a)||(!b))是相等的，所以就可以改写。

---

## 作者：maozi (赞：1)

//做了一个该类型的模板        比如“将一个五位数转换为三个数并存进数组a中  如果想换为n位数 转换为n-m位数 可以从新将值换掉”

例： 12345 -》  123 234 345  五位数转换为三位数并存进数组中

当然看懂这个模板 也可以将6位数的数转换为1 2 3 4 5 6 位数存进数组中  下面直接放代码；



```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[3];
int fun(int x)//分解整数 分解为三个   以12345做例子
{
    for(int i=0;i<3;i++)//一共需要分解为三个数
    {
        a[i]=0;//a[i]赋初值0
        int e=i;  //这个是10的幂次 幂次需要根据每个数进行升  因为 12345 中 234相比较345 所在位向前移了1位 
        for(int j=i;j<i+3;j++,e++)// 每个数长度为3
        {
            int d=pow(10,e);
            a[i]=(((x/d)%10)*(pow(10,e))+a[i]);  //取余操作 当d=1 12345/1%10  a[i]=5第一位数   d=10 12345/10%10 为4 使其值变为45 因此4需要乘以10  同理 3应该乘100然后加45 因此 第一个数就存在了 a[1]中 并且是 345
        }
        a[i]=a[i]/pow(10,i);  //这个通过调试可以得出 每个值都会多10 i次幂 因此除一下就可以了
    }
}
int main()
{
    int k;
    int flag=1;
    cin>>k;  //输出你的除数
    for(int i=10000;i<=30000;i++)
    {
        fun(i);//得到当前数的 三个分解数
        if(a[0]%k==0&&a[1]%k==0&&a[2]%k==0)  //是否符合条件
        {
            flag=0;  //标记是否有一个或以上的数输出过
            cout<<i<<endl; //输出 
        }
    }
    if(flag)
        cout<<"No"<<endl;//如果没有输出过 就 输出当前数
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

又是一道模拟题，模拟思路很简单：

将10000~30000的所有数都进行模拟，

算出sub1、sub2、sub3，再看看他们能否被k整除

能，输出；注意"No"

还有，在分解一个数时，很容易出错

让我们来举个栗子：22767

```cpp
22767/10000=2(万位) 
22767/1000%10=2(千位)
22767/100%10=7(百位)
22767/10%10=6(十位)
22767%10000=7(个位) 
```
对着这个表打程序就变得容易多了，
所以，不想看代码的可以不看

给想见的人献上代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
int sub1,sub2,sub3,k,p;
int main()
{
    cin>>k;//输入 
    for (int i=10000;i<=30000;i++)//模拟10000~30000的所有数 
    {
      sub1=i/10000*100+i/1000%10*10+i/100%10;//算出子数1 
      sub2=i/1000%10*100+i/100%10*10+i/10%10;//算出子数2 
      sub3=i/100%10*100+i/10%10*10+i%10000;//算出子数3 
      if (sub1%k==0&&sub2%k==0&&sub3%k==0) {cout<<i<<endl;p=1;}
      //判断子数是不是都可以被2整除 
    }
    if (p==0) cout<<"No";//如果无解，输出No 
    return 0;
}
```

---

## 作者：MRZMRZ (赞：1)

###过程与函数

过程与函数代码会更直观。f1，f2，f3分别求sub1，sub2，sub3。

b判断是否有数。挺好的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f1(int k) {return k/100;}
int f2(int k) {return k/10%1000;}
int f3(int k) {return k%1000;}
int main()
{
        int n; 
    bool b=false; 
        cin>>n;
        for(int i=10000;i<=30000;i++) if(f1(i)%n==0&&f2(i)%n==0&&f3(i)%n==0) {cout<<i<<endl; b=true;} //枚举，有点慢，但不会超时
        if(b==false) cout<<"No";
        return 0;
}
```

---

## 作者：Elsabella (赞：1)

这道题只要灵活运用与val相关的知识就可以轻松AC！

```cpp
var k,i,a,b,c,t:longint; st,st1,st2,st3:string;
begin
  readln(k);
  for i:=10000 to 30000 do  \\在10000到30000之间找
  begin
    str(i,st);
    st1:=st[1]+st[2]+st[3];
    st2:=st[2]+st[3]+st[4];  \\根据题目要求赋值
    st3:=st[3]+st[4]+st[5];
    val(st1,a);
    val(st2,b);
    val(st3,c);
    st1:='';
    st2:='';  \\要注意清0 
    st3:='';
    if (a mod k=0)and(b mod k=0)and(c mod k=0) then begin inc(t); writeln(i); end; \\判断是否3个变量都modk=0,如果是就将它输出，并将计数器加1,以便以后判断
  end;
  if t=0 then write('No');  \\如果计数器为0,就代表在10000到30000的范围内没有合适的数，就输出'No'
end.
```

---

## 作者：Red_w1nE (赞：1)

我没有用字符串（应为强制类型转换我不是太会写） 就用了一个比较老土的数位分离存在数组中 然后构造出三个数

找到打印就行了 一定要判断能否打出东西来 打不出来要输No 一开始就错在这上面了

AC程序放出：


    
    
        
        
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
    int i,h,a[6],t,k=0,d,b,c,f=0;      //a数组如果你要从1开始用的话 要开6 
    cin>>h;     //h就是k啦 
    for (i=10000;i<=30000;i++){   //大的枚举循环 
        t=i;k=0;
        while (t!=0){     //做数位分离并且存入数组 
            k++;
            a[6-k]=t % 10; //算一下下表就行了 
            t=t/10;
        }
        d=a[1]*100+a[2]*10+a[3];b=a[2]*100+a[3]*10+a[4];c=a[3]*100+a[4]*10+a[5];
         //就是把三个数算出来 
        if ((d % h==0)&&(b % h==0)&&(c % h==0)) //判断一下能否三个都被k整除 
            {cout<<i<<endl;f=1;}      //打印 f是用来标记是否能打印出数 
    }
    if (f==0)
        cout<<"No"<<endl;    //一开始的时候忘了no的情况 后来加上又忘了No的o是小写 
    return 0;
}    //华丽丽的结束了
```

---

## 作者：Sor4 (赞：1)

//此题直接枚举，难度不大，但要注意输出no的情况

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int k,p=0;//p为计数器，如果p为零最后输出no 
    scanf("%d",&k);
    for(int i=10000;i<=30000;i++)//范围内查找 
    {
        //枚举每一位 
        if((i/100%10+(i/1000%10)*10+i/10000*100)%k==0&&(i/10%10+(i/100%10)*10+(i/1000%10)*100)%k==0&&(i%10+(i/10%10)*10+(i/100%10)*100)%k==0)
        {printf("%d\n",i);
        p++;}//计数器改变 
    }
    if(p==0)
    printf("No");
    return 0;
}
```

---

## 作者：何苗苗 (赞：1)



    

```cpp
#include <stdio.h>
int main ( void )
{
    int i, k ,a[10], flag = 0 ;
    scanf ( "%d", &k ) ;
    for ( i = 10000 ; i <= 30000 ; i++ ) //  枚举范围内所有的数
    {
            a[0] =  i / 100 ;
            a[1] = i % 10000 / 10 ;
            a[2] = i % 1000 ;
            if ( a[0] % k == 0 && a[1] % k == 0 && a[2] % k == 0 )
            {
                printf ( "%d\n", i ) ;
                flag = 1;  // 标记作用
            }        
    }
    if ( flag == 0 )
    {
        printf ( "No\n");
    }
    return 0 ;
}

```

---

## 作者：封禁用户 (赞：1)

根据题目的意思，我们可以用i先从指定范围不断地循环，然后用st把i转换为字符串，然后用三个双重循环把st拆分并化为整数，最后在i循环里面判断，如果三个数都可以把i整除的话，那么就输出就可以了！（提醒：这是本人第二次做这一题，没有用mod和div的简便方法，这只是一种字符串方法哦！）

程序如下：

```cpp
var k,s1,s2,s3,o,i,j:longint;
xst,st:string;
begin
  readln(k);
  for i:=10000 to 30000 do
  begin
    str(i,st);
    for j:=1 to 3 do
      xst:=xst+st[j];
    val(xst,s1);
    xst:='';
    for j:=2 to 4 do
      xst:=xst+st[j];
    val(xst,s2);
    xst:='';
    for j:=3 to 5 do
      xst:=xst+st[j];
    val(xst,s3);
    xst:='';
    if (s1 mod k=0) and (s2 mod k=0) and (s3 mod k=0) then begin writeln(i); o:=1; end;
  end;
  if o=0 then write('No');
end.
```

---

## 作者：weiyihe2002 (赞：1)

按题意枚举即可。

```cpp
var
  k,i,a1,a2,a3:longint;
  f:boolean;
  s:string;
begin 
  read(k);f:=false;
  for i:=10000 to 30000 do begin 
    str(i,s);
    val(copy(s,1,3),a1);
    val(copy(s,2,3),a2);
    val(copy(s,3,3),a3);
    if (a1 mod k=0)and(a2 mod k=0)and(a3 mod k=0) then begin 
      writeln(i);
      f:=true;
    end;
  end;
  if f<>true then write('No');
end.
```

---

## 作者：wanglishuang (赞：1)

[codec ]

```cpp
#include<iostream>
using namespace std;
int k;
int main()
{
bool flag=false;//做一个标记，如果没有找到就不变
cin>>k;
for(int i=10000;i<=30000;i++)
{
int a=i/100;
int b=(i/10)%1000;
int c=i%1000;
if(a%k==0)
if(b%k==0)
if(c%k==0)
{
cout<<i<<endl;
flag=true;
}
else continue;
else continue;
else continue;
}
if(flag==false)//查看标记
cout<<"No";
}
[/codec ]
```

---

## 作者：Cyamuleaf (赞：1)

```cpp

#include<iostream>
using namespace std;
int main()
{
    int i,j,a1,a2,a3,k,num=0;
    cin>>k;
    for(i=10000;i<=30000;i++)
    {
        a1=i/100;
        a2=(i/10)%1000;
        a3=i%1000;//算出三个值 
        if(a1%k==0&&a2%k==0&&a3%k==0)
        {
        cout<<i<<endl;
        num++;
        }//直接按题目意思写，无思维难度 
    }
    if(num==0)
    cout<<"No"<<endl;//判断有无解 
    return 0;
}


```

---

## 作者：勘探员·引魂人 (赞：1)

**这道tímù.....#

~~暴力就搞定了~~

好吧，咱也不多说了...... 

~~献上代码~~

然而，题目中给的字符串啊，搜索啊，我根本没用。 

	#include<iostream>
	#include<fstream>
	#include<algorithm>//本蒟蒻不想打万能头文件。 
	using namespace std;
	long long f,f1,f2,n,g,h;//定义。
	int main()
	{
     	cin>>n;//让我们输入一个n。
     	for(int i=10000;i<=30000;i++)
     	{
     		g=i;//g是个替死鬼。
     		f=g%1000;//开始折磨g，得到sum1（子数1）也就是前三位数字的组合。
     		f1=g/10%1000;//继续折磨g，得到sum2（子数2）也就是前中间三位数字的组合。（注意：是否有前导0，有的话把0省略再组合） 
     		f2=g/100;//再折磨g，得到sum3（子数3）也就是后三位数字的组合。还是那句话（注意：是否有前导0，有的话把0省略再组合）  
     		if(f%n==0&&f1%n==0&&f2%n==0)//如果子数1、2、3都可以除以n的话 ...... 
     		{
     			cout<<i<<endl;//输出这个数。
     			h=1;//开关变量变为1，视为有解。
     		}
     	}
     	if(h==0) cout<<"No";//如果开关变量是0，也就是无解，输出No。
        
    	return 0;
	}

---

## 作者：xy_xw_for_2024 (赞：1)

此题吧，快一年没有出新题解了  
本蒟蒻就冒昧的给大家来一篇短点的题解  
首先还是讲讲题意吧（虽然很简单）
首先题目要求是10000~30000，一个循环枚举就是了（YEAH）  
其次，k<1000（再YEAH）
最后，只要找到这3个数就OK啦（^◎^）
以下是题解
```cpp
#include<cstdio>
int i,k;
bool flag;//布尔用来存有无答案，此蒟蒻就因为这个错了一次……
int main()
{    
    scanf("%d",&k);//读入   
    for(i=10000;i<30001;i++)//按题目要求，从10000到30000循环        
        if((i%1000)%k==0&&((i/10)%1000)%k==0&&(i/100)%k==0)//   分别求s3,s2,s1         
        {
            printf("%d\n",i);//找到答案
            flag=1;//有答案
        }
    if(flag==0)//未找到答案
        printf("No");
}
```

---

## 作者：ztz11 (赞：1)

#简要说一下，先将3个数求出来，再判断是否都可以被a整除

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a,b,c,d,x1,x2,x3,x4,x5,y1[30000],y2[30000],y3[30000];
int main()
{
    cin>>a;
```
##下面先求出数
```cpp
    for(b=10000;b<=30000;b++)
    {
        x1=b/10000;
        x2=(b-x1*10000)/1000;
        x3=(b-x1*10000-x2*1000)/100;
        x5=b%10;
        x4=b%100-x5;
        x4=x4/10;
        y1[b]=x1*100+x2*10+x3;
        y2[b]=x2*100+x3*10+x4;
        y3[b]=x3*100+x4*10+x5;
//        cout<<x1<<" "<<x2<<" "<<x3<<" "<<x4<<" "<<x5<<endl;//中间输出，判断对不对的，忽略就好；
//        cout<<y1[b]<<" "<<y2[b]<<" "<<y3[b]<<endl;
    }
```
##判断能否整除
```cpp
    for(c=10000;c<=30000;c++)
    {
        if(y1[c]%a==0&&y2[c]%a==0&&y3[c]%a==0)
        {
            d++;
            cout<<y1[c]*100+y3[c]%100<<endl;
        }
    }
    if(d==0)
    {
        cout<<"No";
    }
}
```

---

## 作者：liuminghan7 (赞：0)

### 本人第一篇题解（~~大佬勿喷~~）
#### 这道题用暴力就行了

1. sub1可以通过将这个五位数/100去掉后两位（int类型会只取整数部分）

1. sub2可以通过将这个五位数先%10000只取后四位，再/10去掉末位；
1. sub3可以通过将这个五位数%1000只取后三位

1. 暴力枚举一下，从10000到30000，只要符合sub1%k==0 && sub2%k==0 && sub3%k==0 的数，就输出（记得换行）
1. 如果一个都没有，输出“No”（注意，“No”是一个大写，一个小写的）

------------
#### 在此奉上AC代码


------------
```cpp
#include<iostream>
using namespace std;
int main()
{
    int i,k,a=0;//a要记得初始化
    cin>>k;//输入k 
    for(i=10000;i<=30000;i++) //从10000到30000逐一搜索  
    {
    	if(i/100%k==0 && i%10000/10%k==0 && i%1000%k==0)
	//i/100取前三位，i%10000/10取中间三位，i%1000取后三位
    	{
    		cout<<i<<endl;//输出 
    		a=1;//判断有没有解 
	}
    }
	if(a==0)//a==0就是无解 
	{
		cout<<"No";//无解输出“No”（不要打成NO，本人就是打错WA了两点） 
	}
    return 0;
}
```

---

## 作者：HoshinoTented (赞：0)

# 入门题, 这是篇水文
rt.

## [题解(Haskell)](https://github.com/HoshinoTented/LuoGu/blob/master/src/P1151.hs)
```haskell
module LuoGu.P1151 where

-- 判断数字是否符合要求 :: K -> 被判断的数字 -> 结果
check :: Int -> String -> Bool
check k [a, b, c, d, e] = sub1 && sub2 && sub3		--判断是否符合要求
  where
    sub1 = read (a : b : [c]) `mod` k == 0		-- 是否符合 sub1
    sub2 = read (b : c : [d]) `mod` k == 0		-- 是否符合 sub2
    sub3 = read (c : d : [e]) `mod` k == 0		-- 是否符合 sub3

-- 已经找到的符合条件的数字 -> K (Final) -> 当前数字 -> 数字上限 -> 全部找到的符合条件的数字
find' :: [Int] -> Int -> Int -> Int -> [Int]
find' xs k b e = if b == e then xs else let s = show b in
  find' (if check k s then b : xs else xs) k (b + 1) e

-- 中转函数 :: K -> 符合条件的数字
find :: Int -> [Int]
find k = find' [] k 10000 30001

-- 打印一个列表
print' :: [Int] -> IO ()
print' [] = return ()
print' (x:xs) = do
  putStrLn $ show x
  print' xs

-- 函数入口
main :: IO ()
main = do
  k <- read <$> getLine

  let xs = find k in
    if length xs == 0 then putStrLn "No" else	-- 如果没有结果, 就输出 No
      print' $ reverse xs		-- 返回的结果是倒序的, 所以需要 reverse 反转一下
```
水题嘛。。  
所以这也是一片水文  
能不能过审核就看后台硬不硬了  

---

## 作者：郭子毅 (赞：0)

这题比较水，半年没登洛谷先做做水题。我很搞不懂为什么那些大神写的那么麻烦。。。。其实这题真的不用字符串

```cpp
var i,m1,m2,m3,k,ans:longint;
begin
read(k);//输入不解释
for i:=10000 to 30000 do//因为题中数据在10000~30000之间就用循环语句，在10000~30000之间循环
  begin
    m1:=i div 100;//用整除100的方法可以得出m1（就是题中的sub1）
    m2:=(i div 10)mod 1000;//m2方法差不多，先整除100，再取余可以得出m2（就是题中的sub2）
    m3:=i mod 1000;//m3更简单，直接取余就可以得出m3（就是题中的sub3）
    if (m1 mod k=0)and(m2 mod k=0)and(m3 mod k=0) then //判断是否能被k整除
      begin 
        ans:=ans+1;//如果成立，则累计
        writeln(i);//直接印换行
      end;
   end;
if ans=0 then write('No');//我被这玩意坑了，一开始没看题没加就80了
readln;
readln;
end.
```

---

## 作者：Hcf2002 (赞：0)

看到题解里都是枚举。。。。搜索明显快很多啊。一共也就用了8ms。（可能哪位大牛更快）





```cpp
var i,n,ans:longint;
    a:array[1..3] of longint;
    b:array[1..5] of longint;//10000到30000就是五位数
procedure dfs(step:longint);//深搜（如果有改进建议请私信我0.0）
var k:longint;
begin
 if step=6 then//如果搜索到第六位数
   begin
    for k:=1 to 3 do
      a[k]:=b[k]*100+b[k+1]*10+b[k+2];//把三个部分提取出来
    if (a[1] mod n=0)and(a[2] mod n=0)and(a[3] mod n=0) then
      begin
        writeln(b[1],b[2],b[3],b[4],b[5]);//输出
        inc(ans);//计数
      end;
    exit;//这部很重要！！！返回上一次
   end;
  if step=1 then//因为是10000到30000，所以首位只有1、2、3，为了避免麻烦我把3放到后面单独判断
   for k:=1 to 2 do
    begin
     b[step]:=k;//b数组用来记录每一位的数值。step表示第几位数
     dfs(step+1);//递归下一位数
    end;
  if step>1 then//除了首位数其他都是0-9
   for k:=0 to 9 do
    begin
     b[step]:=k;//同上
     dfs(step+1);//同上
    end;
  end;
  begin
   read(n);
   ans:=0;
   dfs(1);//深搜
   if 30000 mod n=0 then begin inc(ans);writeln(30000);end;//单独判断30000
   if ans=0 then writeln('No');//如果没有解输出0
  end.
```
（pascal）
如有改进建议请联系我，，，


---

## 作者：Xsy123456 (赞：0)

###数据很小，暴力枚举就行了（代码打得十分蠢...）

```cpp
#include <cstdio>
#include <cmath>
using namespace std;

int k,a,b,c,d,e,s1,s2,s3;
int t=0;

int main(){
    
    scanf ("%d",&k);
    
    for (int i=10000;i<=30000;i++){//多么美观的各个位，哈哈哈
        a=i/10000;
        b=(i-a*10000)/1000;
        c=(i-a*10000-b*1000)/100;
        d=(i-a*10000-b*1000-c*100)/10;
        e=i%10;
        s1=a*100+b*10+c;
        s2=b*100+c*10+d;
        s3=c*100+d*10+e;
        if (s1%k==0&&s2%k==0&&s3%k==0){//判断是否整除，并启用计数器T防止出现“No”
            printf ("%d\n",i);         
            t++;
        }
    }
    if (t==0)
      printf ("No");
      
    return 0;    
    
}
```

---


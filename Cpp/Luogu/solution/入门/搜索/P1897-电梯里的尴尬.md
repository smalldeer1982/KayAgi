# 电梯里的尴尬

## 题目背景

木有……


## 题目描述

细心的同学发现，小W最近喜欢乘电梯上上下下，究其原因，也许只有小W自己知道：在电梯里经常可以遇到他心中的OI大神 lxl。

电梯其实是个很神奇的地方，只有在电梯里，小W才有勇气如此近距离接近大神，虽然觉得有点不自在，但次数多了，大神也习惯了小W的存在，甚至熟悉到仿佛不说上句话自己也都觉得不合适了。可是，他们的谈话也仅仅限于今天天气不错啊或是你吃了吗之类的，往往在对方微笑点头后就再次陷入难堪的沉默之中。 于是，小W便在搭讪大神的同时，也关注着电梯中显示的楼层数字，并且他注意到电梯每向上运行一层需要 $6$ 秒钟，向下运行一层需要 $4$ 秒钟，每开门一次需要 $5$ 秒（如果有人到达才开门），并且每下一个人需要加 $1$ 秒。

特别指出，电梯最开始在 $0$ 层，并且最后必须再回到 $0$ 层才算一趟任务结束。假设在开始的时候已知电梯内的每个人要去的楼层，你能计算出完成本趟任务需要的总时间吗?

这是个很简单的问题，要知道，小W已经修炼到快速心算出结果的境界，现在你来编程试试吧！

## 说明/提示

对于 $60\%$ 的数据 $0<n<10^4$

对于 $100\%$ 的数据 $0<n<10^5$，$0<a_{i}\leq 2\times 10^7$。


## 样例 #1

### 输入

```
4
2 4 3 2 ```

### 输出

```
59```

# 题解

## 作者：Edmundino (赞：639)

这题可以用队列的思想来做

~~是不是有点复杂了~~

首先，我们要给数据先排个列，用sort就OK了，

~~应该不会有人不会吧~~

然后嘞我们求队首与前一个数的差

如果相等我们的时间就直接加1

否则就要用这个差去乘6再加5加1

因为上一楼要6秒，开个门要5秒，走个人要1秒

然后队首出队。直到队列空了，就停止，再加上最后一个出队的数乘4

因为还要回到0楼

最后送上AC代码，好人做到底，再帮忙点个赞呗


```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<string>

using namespace std;

long long n,a[1000010],front,t=0,s,l=0;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	front=1;
	sort(a+1,a+1+n);
	while(front!=n+1)
	{
		int c=a[front]-a[front-1];
		if(c==0)
		{
			t+=1;
		}
		else
		{
			t+=(c*6+6);
		}
		front++;
	}
	t+=a[front-1]*4; 
	cout<<t;
	return 0;
}


```


---

## 作者：BlueArc (赞：59)

```cpp
#include<cstdio>
#include<algorithm>
#include"iostream"
int a[1000010];//题目没说明n多大，最好大一些，否则会RE 
using namespace std;
int main()
{
 int n,i,time,high,s;//high表示最高楼层,s表示不重复楼层的数目 
 cin>>n;
 for(i=0;i<n;i++)   
 cin>>a[i];   
 sort(a,a+n);//快排   
 high=a[n-1];//最高楼层赋给high 
 s=unique(a,a+n)-a;//计算不重复楼层的数目 
 time=high*(4+6)+n;//每层上下4+6秒*最高层+总共要下电梯的人数*1s 
 for(i=0;i<s;i++)
  if(a[i]) time+=5;//坑！0层不需要开门！ 
 cout<<time<<endl;
 return 0;   
}

```

---

## 作者：不曾错过 (赞：58)

**~~小学生又来发题解了！！！~~**    

这是道看起来很~~水~~难的红题，其实做起来很简单的，根本不用用搜索来做。  
**~~（但我的方法貌似太麻烦了！！！）~~**     

  首先，先找出所有的坑人点！！！   
  
  第一个点：                           
  一开始0层要开门吗？？？？          
  答案：不需要！！！。
  
  第二个：    
  开始从0层开始，结束也要到0层结束。
  
  第三个:   
  ~~数据好大！！！~~(废话！！！)    
  
  **开始讲思路：**
  
  首先肯定要排序  
  ~~(没人不会吧)~~
  
  然后就要统计那层是需要开门的，拿数组记录下来，
    为后面统计开门所需要的时间做准备，
    顺便再拿个数组记录下有多少人要出去这一层，
    为下面添加多少秒做准备。
   (~~你到底有多少个数组啊！！！~~)
   
   就这样，为开门做好了充分的准备，可以去处理上下楼梯的时间了。   
   其实它要上的层数就是要上的最高层数，而我们之前已经排过序了，所以可以直接拿数组的末尾来操作。  
 至于他要下的层数的时间，则是最高层下来第0层，~~所以不存在小学的数学问题~~，不是到第一层，就直接把它*4就可以了。
 
  话不多说，放代码！！！
  
    #include<bits/stdc++.h>  //强大的万能头，洛谷万岁
    using namespace std;
    long long n,h,l,g;  //帮忙记录前面为开门做准备的变量(这也太多了吧！！！)
    int a[100010],b[100010],c[100010];//超大的数据范围！！！
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++)
        {
          cin>>a[i]；   //输入
        }
        sort(a+1,a+1+n);  //无人不会的排序（什么？？？你不会？？？）
        h=1;      //先借个变量，把统计时间的拿来用一用。
        for(int i=1;i<=n;i++)
        {
          if(a[i]==a[i+1])
          {
            h++;   //这层有多少人要出来     	
          }	
          if(a[i]!=a[i+1])
          {
            g++;  //记录一共要出去多少层
            b[g]=a[i];  //b数组负责记录哪些层要出去人。
            c[g]=h;   //c数组负责记录在b[g]这一层，有多少人出。
            h=1;	//把h改成1
          }    		
        }
        h=a[n]*4+g*5+a[n]*6; //直接赋值，因为前面借用了一下这个数组，其他的前面有，没看懂慢慢看。
        for(int i=1;i<=g;i++)
        {
          h+=c[i]; //加上每层要出的人数*1，乘1省略掉了。
        }
        cout<<h;  //输出。
        return 0;//完美结束
    }  
   第四次发题解，还是有点紧张,可能有些地方说的不太清楚，有错误请大佬指出，拜拜~~

---

## 作者：引领天下 (赞：35)

核心思路：

读入每个楼层，如果没有去过，肯定要为他开一次门；

然后，标记一下；

有 $n$ 个人，就一定要加 $n$s；（每个人都要下啊）

再加上从 $0$ 楼到最高楼再回来的时间（上 $6\max$,下 $4\max$,共 $10\max$）

输出。

上 AC 代码：

```cpp
#include <cstdio>
int n,a,ans,max;//n是人数，a是这个人要去几层，ans是答案，max是最高楼层
bool s[100000000];//楼层桶（不可思议的100000000层大楼）
int main(void){
    s[0]=1;//注意！0层不需要开门！我一开始少了这句话丢了30分
    scanf ("%d",&n);//读n
    for (int i=0;i<n;i++){
        scanf ("%d",&a);//每次读一个人
        if (!s[a])ans+=5;//!s[a]意思是这个楼层还没见过，当然要开一次门啦
        s[a]=1;//不管怎样，标记一下
        if (a>max)max=a;//找最高楼层
    }
    ans+=n;//每个人都要下去，所以加的时间一定等于n
    ans+=max*10;//上6下4，共10s，所以最高楼层*10
    printf ("%d",ans);//输出！
}

```

---

## 作者：bellmenford (赞：14)

我们其实只用假设一下这是一群熊孩子

他们先将要到的楼层给按了一遍

然后全跑了出来

所以时间便是所有人跑出去的时间+在各个楼层开门的时间+小W上下来回的时间了 

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,ans,maxfloor=0,arfloor=0;//maxfloor是最大楼层,arfloor是到达了多少楼层 
bool vis[20000005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		if(!vis[x]){
			arfloor++;
			maxfloor=max(maxfloor,x);
			vis[x]=1;
		}
	}
	ans=maxfloor*(4+6)+arfloor*5+n;
	printf("%d\n",ans);
}
```

---

## 作者：c137772617 (赞：11)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<bits/stdc++.h>
int n;
int ans=0;
int i,j,k;
int a[100010];
using namespace std;
int main(){
    cin>>n;
    j=0;
    for(i=1;i<=n;i++)
    cin>>a[i];
    sort(a,a+n+1);//从小到大排序
    ans=n+a[n]*10;//每个人所需要的时间和电梯上下时间和
    for(i=1;i<=n;i++){
        if(a[i]!=a[i-1]){//循环从一开始，数组默认初值为0，避免漏掉全部在同一层楼
            ans=ans+5;//电梯需要开关
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：_yjh (赞：10)

## **没有 C++STL队列 的题解？赶紧补一发**


------------
__阅读本篇题解约需要__ **3-5min**, [**博客**](https://www.luogu.org/blog/yjhqinghua/solution-p5412) __阅读效果更加__。 

**在阅读本题解之前，我们应该先了解一下 STL队列。**

使用 **queue(队列)** 的步骤
- 引入头文件 **<queue>**
  ```cpp
#include<queue>
``` 
- 定义一个 **任何类型的队列** (如int)
  ```cpp 
queue <类型名> 变量名;
``` 
- 使用 **库中的函数** 对其进行操作
  ```cpp
//基本操作
/*定义一个队列变量q*/
#1 q.push(变量); 将变量插入队尾
#2 q.pop(); 弹出队首的元素
#3 q.front(); 访问队首元素
#4 q.back(); 访问队尾元素
#5 q.empty(); 判断队列是否为空,是则返回true
#6 q.size(); 返回队中元素的个数
```
 ------------
 ## **介绍了队列，下面我来说一下我的思路：**
- ```定义一个队列 q```
  ```cpp
queue <int> q;
```
- ```再定义一个中转数组 a ```
  ```cpp
int a[n+1]={0};
```
- ```将数组 a 排序,把它的值加入 q 中```
  ```cpp
sort(a+1,a+n+1);
for(int i=1;i<=n;i++) q.push(a[i]);
```

- ```经过简单的计算,你可以发现你可以使用以下核心代码```
  ```cpp
ans+=(a[n]*6+n+a[n]*4);
	while(!q.empty())
	{
		c=q.front();
		q.pop();
		ans+=5;
		while(q.front()==c) q.pop();
	}
```
- ```经过上网查询,你发现了一个神奇的函数 unique ,你可以对上述语句加以优化```
  ```cpp
ans+=(a[n]*6+n+a[n]*4);
ans+=(unique(a+1,a+n+1)-a)*5;
```
- ```但是你又发现,这时 ans 比大样例多 5,原来是多停了一层```
  ```cpp
ans+=(a[n]*6+n+a[n]*4);
ans+=(unique(a+1,a+n+1)-a-1)*5;
```
# **My Codes(杜绝抄袭,共建和谐洛谷)**
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
queue <int> q;
int main()
{
	int n,ans=0,c;
	cin>>n;
	int a[n+1]={0};
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) q.push(a[i]);
	ans+=(a[n]*6+n+a[n]*4);
	ans+=(unique(a+1,a+n+1)-a-1)*5;
	cout<<ans<<endl;
	return 0;
}
```


------------
我的 [AC记录](https://www.luogu.org/record/23634153)

---

## 作者：Peter_Z (赞：9)

由于本题数据特别大，所以想到了map这个关联式容器，STL大法好。

思路分析：

输入每个人要去的楼层，用布尔数组保存某个数组是否去过。

若当输入时已经去过某个楼层，则让此人在之前和前面下电梯的人一起下电梯就行，增加一个下电梯的人即可。

若没有去过某个楼层，则开门时间加5秒即可。

不用排序，但是这类似于桶排。

电梯上下楼和出电梯在最后一起加，出电梯的总时间为n，而上下楼的总时间为10×最高层数。

代码如下：


```cpp
#include<stdio.h> //输入输出怎么能少呢？
#include<map>            //STL大法好 
#include<iostream>
using namespace std;
map<int,bool> floor;    //保存每层楼需不需要到 
int main() {
    int n,go,sum=0,now=0,high=0;    //各种数据 
    scanf("%d",&n);        //n表示乘坐电梯的人数 
    floor[0]=true;        //第0层是需要去的 
    for(int i=1; i<=n; i++) {
        scanf("%d",&go);    //go代表第i个人要去的层数 
        if(!floor[go])    //如果没有去过第go层就加5秒开门的时间 
            sum+=5;
        floor[go]=true;
        high=max(go,high);        //保存去过的最高的层数 
    }
    sum+=n+10*high;        //处理上下楼和下电梯 
    printf("%d",sum);
    return 0;
}
```

---

## 作者：JustinRochester (赞：7)

[题目](https://www.luogu.org/problemnew/show/P1897)

难道只有我这个蒟蒻用了priority_queue然后一遍过吗？
~~2333~~

------------

**【分析】**
-----------
根据样例和题意，我们可以直接知道，最高楼层为 $max$ 的话，基础耗时为 $t=4\ max+6\ max=10\ max$ (上楼时间和下楼时间)。其次，对于每一层楼，如果有人则耗时 $t=5+n$ (人数)。

对此，我们因为电梯的基础耗时是由最大值决定的，与顺序无关，我们在求基础值时只要知道最大值即可。既然如此，为什么不倒序排列呢？

也就是说，我们把思路改一下，有一个电梯，要先从底楼运动到最高层，然后不停下降，并在需要出人的楼层分别出人，空后再次返回底层。

倒序排列后，最大值为第一个，基础值直接求出。接着，每次按照 **现在的需要出人的最高楼层** 求出该层的停靠时间，叠加起来即可。

而当前层的停靠时间基础值为 $5$ ，然后每出一个人即 $+1$。

故此，可以利用 stl 中的 priority_queue ，默认大根堆排序，然后不停输出最大值，以判断楼层，直至电梯空厢。

---------
**【代码】**
-----------
那蒟蒻我就放代码了
```cpp
#include<cstdio>
#include<cctype>
#include<queue>
using namespace std;
int read(){
	int abs=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
	while(isdigit(c)){
    	abs=abs*10+c-'0';
        c=getchar();
    }
	return abs;
}//数据量过大，用读入优化
priority_queue<int> q;
int wait(int f){
	int t=5;//停靠层的基础值
	while(q.top()==f&&q.size()) t++,q.pop();//这一层还有人要出，则时间+1
	return t;
}//wait()函数中的处理保证了每一层不会被重复计算
int main(){
	int n=read();
	while(n--) q.push(read());
	int t=q.top()*10;//总时间的基础值
	while(q.size()) t+=wait(q.top());//叠加每一层的停靠时间
	printf("%d",t);
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：McGrady (赞：5)

我的方法和下面不一样，我是用一个桶存储到了哪些层

然而好坑啊数据范围也不给，交了8次才过

开始桶只开了1000，觉得大楼有1000层高已经很不可思议了，然而re

100000？re

1000000？re

10000000？还是re

难不成有1亿层高的大楼？上一层6s，下一层4s，我来算一算，1年=365\*24\*60\*60s=31536000s，10^9s约等于31.7年，还好没有超越人类寿命，不过这么长时间都呆在电梯里？还是为了“近距离接近女神”？

好了废话不多说

我决定开1亿的数组看看占多少内存（虽然肯定MLE）

然而：竟然没有MLE?

不过70分

没事看一看题解加上特殊情况的判断就过了

丑陋的代码：

```cpp
program rrr(input,output);
var
  f:array[0..100000000]of boolean;
  i,n,x,max,ans:longint;
begin
   //assign(input,'r.in');assign(output,'r.out');reset(input);rewrite(output);
   readln(n);
   fillchar(f,sizeof(f),false);
   ans:=0;max:=0;
   for i:=1 to n do
      begin
         read(x);
         if x=0 then continue;
         //if x>10000010 then begin write(x);halt; end;
         if not f[x] then begin f[x]:=true;if x>max then max:=x;inc(ans); end;
      end;
   write(ans*5+max*10+n);
   //close(input);close(output);
end.
```

---

## 作者：「QQ红包」 (赞：3)

模拟
```cpp

#include<cstdio>  
#include<iostream>   
#include<algorithm> 
using namespace std;
int a[100010],i,j,sum;
int main()
{
    int n; 
    scanf("%d",&n);//读入 
    for (i=1;i<=n;i++)
        scanf("%d",&a[i]);//读入 
    sort(a+1,a+n+1);//从小到大排序 
    sum=a[n]*10;//上到最顶层需6*楼层秒，下到0层要4*楼层秒，所以一共需要10*楼层秒 
    for (i=1;i<=n;i++)
    {
        if (a[i]!=a[i-1]) sum+=5;//如果这层楼之前没人下就开门 
    } 
    cout <<sum+n;//加上每个人下的时间 
    return 0;
}

```

---

## 作者：Soyilieber (赞：3)

排什么序啊，~~没看到2e7数据吗？~~

开一个$2×10^7$大小的数组a，输入时遇到一个值b，则a[b]++。

然后循环扫一遍数组，不为零就上楼，fl为记录上一个楼层（初始0），

显而易见我们得到公式，每次加上的时间=（目的楼层－上一个楼层）×6+5+目的楼层出电梯人数，

但是最后输出时，我们再加上fl×4，因为fl最后一次更新的值代表最后一个目的楼层，即最高层，现在跳下来即可。


代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,ans,b,a[20000001],fl;
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%d",&b);
		a[b]++;
	}
	for (int i=1;i<=20000000;i++){
		if (a[i]){
			ans+=(i-fl)*6+5+a[i];
			fl=i;
		}
	}
	printf("%d\n",ans+fl*4);
	return 0;
}
```

---

## 作者：2017hxz (赞：3)

###集合的妙用

```cpp
#include<iostream>
#include<set>  //set为集合
using namespace std;
int n,x,a[100001],mx;
long long ans;
set<int>kk;
int main()
{
    cin>>x;
    const int n=x;
    while(x--)
        {cin>>a[n-x],mx=max(mx,a[n-x]);if(a[n-x])kk.insert(a[n-x]);}//如果目的楼层非0，在集合中添加这个楼层元素
//若已存在此元素，那么就无法添加
    int l=kk.size();//集合中元素的个数
    ans+=10*mx+n+l*5;
    cout<<ans;
    return 0;
}

```

---

## 作者：执念＆shadows (赞：2)

### 吐槽一下，这个题目的名字好像跟题目并没有什么关系。。。
好吧，还是言归正传。让我们回到题目中来。

这题只要求出最高层数、要去的不同层数和总人数再计算一下就好啦

------------
```cpp
#include<iostream>
#include<algorithm>            //sort的头文件，不要忘记 
using namespace std;
int main()
{
	int n;                   //人数 
	cin>>n;
	const int nn=n;
	int a[nn];                //用来存储每个人要去的层数 
	int sum=0;                //总时长 
	int max=-999999999;       //存储最高楼层 
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
		if(a[i]>max)
		{
			max=a[i];
		}
	}
	sort(a,a+nn);             //排序 
	int zs=1;                 //要去的不同层数的数量 
	int k=a[0];
	for(int i=0;i<n-1;i++)     //存储不同层数的数量，因为已经排过序所以直接顺着来一遍就行 
	{
		if(a[i+1]!=k)
		{
			zs++;
			k=a[i+1];
		}
	}
	sum=max*10+zs*5+n;        //总时长即为  最高楼层*（4+6）+ 不同层数*5+总人数 
	cout<<sum;                //输出 
	return 0;
}
```


---

## 作者：yzyxbw (赞：2)

这真的真的真的只是一道简单的数学算术题，只要你想明白了，代码自然就出来了，AC代码（附解释）：
```cpp
#include <bits/stdc++.h>//万能头不解释
//#define S1 struct
//#define S2 string
using namespace std;
int n,ans,a[100001],num；//定义变量

int main(){//以下是主函数
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}//以上是输入
	sort(a+1,a+n+1);//快排为了求出有多少人在同一层楼下
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1])
			num++;//在同一层楼只停一次
	}
	ans=a[n]*10+num*5+n;//由于已经排好序，所以a[n]就是要到达的最顶楼，需要上去一次，下来一次（其实你也可以写成：ans=a[n]*6+num*5+n*1+a[n]*4这样好理解些），num代表要停几次，所以要*5，n是有几个人，所以要加上每人下去的那一秒
	cout<<ans;//输出不解释
	return 0;
}//上面定义变量那里我用了中文符号，为了防无脑抄提解。

```


------------
 本蒟蒻第一次发题解，请大佬们指点。
 

------------
**管理员你看我这么努力，就让我过了呗**-  
**管理员你看我这么努力，就让我过了呗**-

---

## 作者：guobaipeng0 (赞：2)

这里是Pascal做法


```cpp
var i,j,x,temp,s,n:longint;
    a:array[0..100000] of longint;
procedure qsort(l,r:longint);           //这一段都是快排
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];        //取中间值
  repeat
    while a[i]<x do inc(i);    
    //搜索，如果这个数比中间值小的话就继续，直到找到比中间值大的数
    while a[j]>x do dec(j);  
    //和上面相反，如果这个数比中间值大就继续，直到找到比中间值小的数
    if i<=j then                   //这里交换，条件是大的数在数列的左边，小的在数列右边才行
      begin
        temp:=a[i];
        a[i]:=a[j];
        a[j]:=temp;
        inc(i);        //继续搜索，没有这一行和下一行会死循环，永不停止
        dec(j);
      end;
  until i>j;
  if j>l then qsort(l,j);         
  //这里和下一行都是判断，如果还有一段没有搜索过，就搜索那一段
  if i<r then qsort(i,r);  
end;
begin
  readln(n);        //读入
  for i:=1 to n do read(a[i]);       //读入要去的楼层
  qsort(1,n);                             //快排
  for i:=1 to n do
    begin
      s:=s+1;                    //每次下一个人就增加一秒
      if a[i]<>a[i-1] then sum:=sum+5;       //如果这层楼门没有开过就开门，增加5秒
    end;
  s:=s+a[n]*10;           //由于排好了序，a[n]就是最大值，楼层上下的6和4秒加起来是10，就增加楼层数量*10秒
  writeln(s);                      //输出
end.
```

---

## 作者：十年若如一梦 (赞：2)

//这是一道非常简单的模拟，但是我语文不好，所以文字说明可能会出现病句

```cpp
var a:array [0..100100] of longint;
    i,n,z:longint;
procedure qsort(l,r:longint);
var mid,by,i,j:longint;
begin
  i:=l;
  j:=r;
  mid:=a[(i+j) div 2];
  repeat
    while a[i]<mid do inc(i);
    while mid<a[j] do dec(j);
    if i<=j then begin by:=a[i];a[i]:=a[j];a[j]:=by;inc(i);dec(j);end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  qsort(1,n);//快排（虽然不知为什么，但是是我的童鞋们说的）；
  for i:=1 to n do
    begin
      if a[i]<>a[i-1] then z:=z+6;//如果与前一层不同，证明是在不同的楼层，所以要加上开门的时间
      if a[i]=a[i-1] then inc(z);//如果与前一层相同，证明是在相同的楼层，只需加1。
    end;
  z:=z+a[n]*10;//10是（6+4），因为电梯会上升（下降）max（a[n]）层，所以只需用a[n]乘10就行了
  writeln(z);
end.

```

---

## 作者：deprave (赞：2)

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int louceng[20000002],cnt,maxx,ans;//桶储存每个楼层是否有人 
int main(){
	int n;
	cin>>n;
	for (int i=1;i<=n;i++){
		int p;
		cin>>p;//输入某个目标楼层 
		maxx=max(maxx,p);//寻找最高楼层，注意不能用max，它在c++库中被声明了 
		if (!louceng[p]) cnt++;//判断楼层是否已经是别人的目的楼层 ，不是的话需要到达的楼层+1 
		louceng[p]++;//目的楼层出去的人+1 
	}
	ans=maxx*10+cnt*5+n;//电梯上到最高楼层又下来，每层需要10秒，每个人出去1秒，目的楼层数*5秒 
	cout<<ans;
} 
```


---

## 作者：include_cmath (赞：2)

看着一堆大佬写的集合啊，读入优化，我~~看到发蒙~~陷入沉思，这题有这么难吗？
先说一下思路：储存每个楼层要下的人数，如果有人就开门+5，再加上下的人+1，楼层因为上下楼层数一定是一样的所以直接+（4+6）也就是+10.
代码如下：

```cpp
#include<iostream>
using namespace std;
int i,n,a[20000005],b,m;
long long s;//总时间
int main()
{
    cin>>n;
    for(i=0;i<n;i++)
    {
        cin>>b;
        a[b]++;//储存每个楼层的人数
        m=max(b,m);//储存最高楼层
    }
    for(i=1;i<=m;i++)
    {
        s+=10;//电梯上下的时间
        if(a[i]==0) continue;//看有没有下的人
        s+=5;//开门的时间
        s+=a[i];//下人的时间
    }
    cout<<s;
    return 0;
}
```

---

## 作者：felixwu (赞：2)

其实可以用类似桶的做法
（放心，a[i]<=2e7)
可以避免重复开门；
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[20000000],n,m,ans,k;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&m);
		a[m]++;
		k=max(k,m);//最大的楼层
	}
	m=0;
	for(int i=1;i<=k;i++){
		if(a[i]>0){//有人到达
			ans+=(i-m)*6+a[i]+5;
			m=i;//m是上一个到达的楼层
		}
	}
	printf("%d",ans+m*4);//计算返回
    return 0;
}
```

---

## 作者：himitsu (赞：1)

# C语言版电梯爱情（~~滑稽~~）

C语言小白的第二篇题解~~

话说目前只学了C的小白十分羡慕用c+的大佬们→_→有sort函数
尤其是我因为快排而T了两个点。。。（话说worst case 都 O（n^2）也不快啊是我学的不是快排吗┌(;￣◇￣)┘）

用的是bool数组法
  
（卑微萌新还没学到STL，map 桶排神马的也没有库函数可用，可以说是非常简陋的代码了o(╥﹏╥)o）   
   AC代码如下：
   ```
#include <stdio.h>
int a[20000001] = {0};
int count = 0;
int retrieve(int a[], int floor)
{
	if(a[floor] == 0)
	{
		a[floor] = 1;
		count++;
	}
	
	return count;
}
int find_max(int b[], int n)
{
	int max = b[0], i;
	
	for(i = 0; i < n; i++)
	{
		if(b[i] > max)
		max = b[i];
	}
	
	return max;
}
int main(void)
{
	int n, i, time = 0, high;
	scanf("%d", &n);
	int b[n];
	
	for(i = 0; i < n; i++)
	{
		scanf("%d", &b[i]);
	}
	
	high = find_max(b, n);
	
	for(i = 0; i < n; i++)
	{
		retrieve(a, b[i]);                   
	}
	
	time =  high * 10 + n * 1 + count * 5;
    
	printf("%d", time);
    
	return 0;
}
```


---

## 作者：Kindom (赞：1)

						第一篇题解
核心思想：**桶排法**；
详细解释：1初始化数组为0；
2编写变读入楼层，并判断ff[a]是否为0；
3若为0则为新楼层则组要开门时间加5s，不是则不操作；
再判断最大楼层；
总结时间：总人数*1+（3步骤判断的ff[a]是否为0）*5+（每上一层下一层共需要10秒）10*最大楼层
```cpp
#include<stdio.h>
int  ff[100000000]={0};//定义空数组
int main()
{

	int n,m,i,a,sum=0,max=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{ __ 
		scanf("%d",&a);
		if(ff[a]==0)//步骤2和3
		{
			sum+=5;//新楼层+5秒
		}
		ff[a]=1;
		max=max<a?a:max;//判断最大楼层
		
		
	}
	sum+=n;//每下一人加一秒
	sum+=10*max;//最大楼层*10
	printf("%d\n",sum);//输出
	return 0;
 } 
```

全局数组最大开了一亿，题目数据再大一点就re了！
可怜我c语言没有布尔类型 （c99有我知道，，标准c没有啊）

---

## 作者：Kuroko_IU (赞：1)

明确要求出的两点
1. 	要上的最高的楼层是多少
2.  一共有几层会下人

最终的结果 = （6+4) x 最高楼层 + 人数 x 1+ 要开门的次数 x 5


这里推荐一个C++的STL中的容器 ：**集合set**
1. 集合可以直接统计一共几层会下人
2. 集合自身就是排好序了的

代码如下：
```cpp
# include <iostream>
# include <set> //集合的头文件
using namespace std;
int main(void)
{
	int n,k;
	long long ans;
	set<int> a; //创建集合
	set<int>::iterator it;  //集合的迭代器，相当于数组的索引，这里仅用来
    			       //指向集合的最后一个元素，所以没学过不用在意
                          
	cin>>n;
	for(int i = 0;i < n;i++)
	{
		cin>>k;
		a.insert(k);
	}     //数据的读取
    
	it = a.end();
	it--;   //将迭代器指向集合最后一个元素 
    
	ans = 10*(*it) + 5*a.size() + n; //计算答案,其中 *it相当于数组的 *（a+len-1）
                   //a.size()即为集合的元素个数，也就是要下人的楼层数
	cout<<ans<<endl;
	return 0;
}
```
[附C++集合的用法详解链接](https://blog.csdn.net/byn12345/article/details/79523516)


---

## 作者：张皓涵 (赞：1)

## 这题就是纯模拟，把电梯上下的时间+上下人的时间就轻松AC了

我可能（~~注意，是可能~~）是最短、可读性最强的代码了~~，求通过~~！
    
    #include<iostream>
	#include<algorithm> //用sort就要这个东东
	using namespace std;
	int main()
	{
		int n,a[100001]={0},ans,sum=1;
        //sum代表此层要下的人
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];  //读入不解释
		sort(a+1,a+n+1);  //将电梯里的人按楼层排序
		ans=a[n]*10;  //电梯上下一定要这么多时间，a[n]是最高的楼层，10是4+6
		for(int i=1;i<=n;i++) //逐个人判断
			if(a[i]!=a[i+1])   //如果下一个人是不同层的
            {ans+=5+sum; sum=1;} else sum++; //就加上这层需要的时间
		cout<<ans; //输出
		return 0;  //很多人都喜欢省略return 0;但要记住，比赛时一定要加上它哦！
	}

---

## 作者：Blazar北极星 (赞：1)

这题蛮醉的，为啥会有人在0层上楼然后下楼...另外开他那个数据规模的数组会爆炸！然后果断换成map（记不得vector直接赋值给一个不存在下标的元素会不会爆炸）之后WA三个点...最后发现0层会有人....qwq

代码如下：






```cpp
#include <iostream>
#include <map>
using namespace std; //利用桶的思想 
int f = 0, maxf = 0, n; //n统计要下的人数，f统计要下的层数
map<int, bool> fp;
void read() {
    int j;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> j;
        if (fp[j] || j == 0) continue;
        if (j > maxf) maxf = j;
        fp[j] = true;
        f++;
    }
}
void print() {
    cout << n + f * 5 + 10 * maxf;
} 
int main() {
    fp.clear();
    read();
    print();
    return 0;
}
```

---

## 作者：Chiaro (赞：0)

## 思路

#### 从最高层一路找到第0层 

#### 如果这层有人要下电梯就停下来

#### 没有人下电梯就继续往下走

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,num[100010],ans;
//n是人数,num是每个人要去的楼层,ans是答案
int per[20000010];
//per是每一层要下电梯的人数,数组似乎很大
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=0;i<n;i++)cin>>num[i],per[num[i]]++;
    //读入每个数,然后per数组记录
	sort(num,num+n);//排序一下
	ans=ans+num[n-1]*6;//先让电梯升到最高层
	for(int i=num[n-1];i>=0;i--){
    //循环从最高层到0层
		ans+=4;//先减去下降一层所需要的时间
		if(per[i]==0)continue;
        //如果这一层没有人要下电梯,就continue;
		ans+=5;
		ans+=per[i];
        //如果有人要下电梯,减去5和人数
	}
	cout<<ans-4<<endl;
    //-4因为在最高层的时候多加了4,所以要减去
	return 0;
} 
```

---

## 作者：hmh13951417981 (赞：0)

## 水题一道，模拟一下就行
------------
## 原创AC代码，勿喷
```c
#include<bits/stdc++.h>
using namespace std;
int n,i,a[100001];//a数组用来存储楼层 
long long s;//存储总时间 
int main()
{	cin>>n;//输入部分 
	for(i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);//处理部分 
	//将杂乱的顺序排序 
	for(i=1;i<=n;i++){
		if(a[i]==a[i-1]) s++;//要是楼层数一样的话,就加一个上电梯的时间 
		else s+=(a[i]-a[i-1])*6+5+1;//否则，就加上前后上升的时间和开电梯,下电梯的时间 
	}
	cout<<s+a[n]*4;//输出部分 
	//再加上从最顶端下来的时间 
	return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

本题备受争议，有数据范围不清的，有整片RE的。

我也有过RE，我觉得数组太小有加到100000，还是全部RE

我又想到你在洛谷上提交一个程序加上文件读写也是这种情况。

为啥呢？

因为洛谷就不让你用assign，一查找到就RE，

所以我觉得本题就是这样，比如说一个sort没有检索到就RE，或者说程序空间没到RE

这种题目饱受争议，为什么在PC机上AC而到评测机上就RE？

也可能windows和Lnix系统上的pascal/c++编译不同 洛谷的评测机是建立在Lnix系统上的

数据范围经过本人亲测

对于60%的数据  10000<=n

对于100%的数据 100000<=n

建议kkksc03补上，否则数组真的没法开啊！在此 @kkksc03

言归正传，

其实就是一个简单的模拟程序：

我认为这样对于一般的评测机可以AC得程序但在洛谷上不行：

```cpp
var n,i,maxx,cnt:longint;
    a:array[1..100000]of longint;
    u:array[1..100000]of longint;
begin
 readln(n);
 for i:=1 to n do begin
 read(a[i]);
 if a[i]>maxx then maxx:=a[i];
 end;
 for i:=1 to n do inc(u[a[i]]);
 for i:=1 to maxx do if u[i]>0 then
  cnt:=cnt+5+u[i];
 cnt:=cnt+maxx*6+(maxx)*4;
 writeln(cnt);
end.
```
对于以上程序我就不解释了。
对于在洛谷上完全AC的程序如下：

```cpp
var n,i,max,s:longint;
    a:array[0..100000]of longint;
   // u:array[0..10000]of longint;
procedure qsort(l,r:longint);//从小到大快排
var t,i,j,mid:longint;
begin
i:=l; j:=r;
mid:=a[(l+r)div 2];
while i<j do
begin
 while a[i]<mid do inc(i);
 while a[j]>mid do dec(j);
 if i<=j then begin
   t:=a[i]; a[i]:=a[j]; a[j]:=t;
   inc(i);dec(j);
 end;
end;
if l<j then qsort(l,j);
if r>i then qsort(i,r);
end;
begin
 readln(n);
 for i:=1 to n do begin
 read(a[i]);
 //if a[i]>max then max:=a[i];
 end;
 qsort(1,n);
 for i:=1 to n do begin
  s:=s+1;//下去1个人，时间加1秒
  if a[i]<>a[i-1]then s:=s+5;//前后不在一个楼层加上开门的时间
 end;
 s:=s+a[n]*(6+4);//最后，一上6秒，一下4秒，合10秒，a[n]是最大值，说明电梯最高爬a[n]-0=a[n]楼（植树问题），所以乘以10
 writeln(s);
end.
```
这道题非常有争议，建议kkksc03能够稍加修改，谢谢。


---

## 作者：Wh_Xcjm (赞：0)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,i;
    cin>>n;
    int a[n+1]={0},s=n;//s是计时器，每个人下电梯要一秒钟，先加上 
    for(i=0;i<n;i++)
        cin>>a[i];//读入 
    sort(a,a+n);//快排 
    s+=a[n-1]*10;//a[n-1]是要走的最高楼层上去下来每层一共10秒，再乘层数 
    for(i=0;i<n;i++)
        if(a[i]!=a[i+1]&&a[i]!=0)//务必加上判断0 
            s+=5;//如果不重复就加上开电梯门的5秒钟 
    cout<<s;
    return 0;
}
```

---

## 作者：PTC06 (赞：0)

这里是Pascal做法


```cpp
var i,j,x,temp,sum,n:longint;
    a:array[0..100000] of longint;
procedure qsort(l,r:longint);           //这一段都是快排，由于可能有人不会，还是解释下
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];        //取中间值
  repeat
    while a[i]<x do inc(i);    //搜索，如果这个数比中间值小的话就继续，直到找到比中间值大的
    while a[j]>x do dec(j);  //和上面相反，如果这个数比中间值大就继续，直到找到比中间值小的
    if i<=j then                   //这里交换，条件是大的数在数列的左边，小的在数列右边才行
      begin
        temp:=a[i];
        a[i]:=a[j];
        a[j]:=temp;
        inc(i);        //继续搜索，没有这一行和下一行会死循环
        dec(j);
      end;
  until i>j;
  if j>l then qsort(l,j);         //这里和下一行都是判断，如果还有一段没有搜索过，就搜索那一段
  if i<r then qsort(i,r);  
end;
begin
  readln(n);        //读入
  for i:=1 to n do read(a[i]);       //读入要去的楼层
  qsort(1,n);                             //快排
  for i:=1 to n do
    begin
      sum:=sum+1;                    //每次下一个人就增加一秒
      if a[i]<>a[i-1] then sum:=sum+5;       //如果这层楼门没有开过就开门，增加5秒
    end;
  sum:=sum+a[n]*10;           //由于排好了序，a[n]就是最大值，楼层上下的6和4秒加起来是10，就增加楼层数量*10秒
  writeln(sum);                      //输出
end.
```

---

## 作者：cxy004 (赞：0)

\* 题目链接：[ 1897 ](/problem/show?pid=1897)

首先电梯每向上运行一层需要6秒钟，向下运行一层需要4秒钟.而电梯最开始在0层，并且最后必须再回到0层。所以电梯最好是从0层上升到最顶层再回到0层，共计(10\*最高层的层数)seconds

然后每下一个人需要加1秒。又每一个人都要下一次，所以时间共计(1\*总人数)seconds

最后每开门一次需要5秒，所以统计需要到达的不同楼层的数量，共计(5\*不同楼层的数量)seconds

完毕。

\* 标程：```delphi
#include<cstdio>
#include<algorithm>
using namespace std;

int n,f[100001],ans;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&f[i]);
    sort(f+1,f+n+1);
    ans=f[n]*10+n;
    for(int i=1;i<=n;++i) if(f[i]!=f[i-1]) ans+=5;
    printf("%d",ans);
    return 0;
}
```

---


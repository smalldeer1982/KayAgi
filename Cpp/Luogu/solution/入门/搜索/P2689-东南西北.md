# 东南西北

## 题目描述

给出起点和终点的坐标，及接下来 $T$ 个时刻的风向（东南西北），每个时刻可以选择顺风偏移 $1$ 个单位或者停在原地。求到达终点的**最少移动步数**。

坐标采用平面直角坐标系，$x$ 轴正向为东，$y$ 轴正向为北。

如果无法偏移至终点，输出 $-1$。


## 说明/提示

### 样例解释

- 样例 $1$：向东走一步，向北走一步。
- 样例 $2,3$：无法到达。

### 数据范围

对于全部数据，$1\le T\le 50$。


## 样例 #1

### 输入

```
1 1
2 2
5
E
N
W
W
N```

### 输出

```
2```

## 样例 #2

### 输入

```
1 1
2 2
1
W```

### 输出

```
-1```

## 样例 #3

### 输入

```
1 1
2 2
3
W
W
W```

### 输出

```
-1```

# 题解

## 作者：RedreamMer (赞：39)

# p2689
## 看到很多dalao用了很高级的方法。
#### ~~我不会说其实我看不懂~~
#### 但本蒟蒻发现自己的代码更简短、容易懂。
#### 话不多说上代码。
————————————————分割线——————————————
```
#include<bits/stdc++.h>
using namespace std;
int x[1001];
int main()
{
    int a,b,c,d,e,f=0;
    char y;
    cin>>a>>b>>c>>d>>e;
    for(int i=1;i<=e;i++)
    {
    	cin>>y;
    	if(y=='N'&&a<c)
    	{
    		a++;
    		f++;
		}
		if(y=='S'&&a>c)
		{
			a--;
			f++;
		}
		if(y=='W'&&b>d)
		{
			b--;
			f++;
		}
		if(y=='E'&&b<d)
		{
			b++;
			f++;
		}
		if(a==c&&b==d)
		{
			cout<<f;
			return 0;
		}
	}
	cout<<-1;
    return 0;
}
```
#### 太容易懂了就不注释了  ~~懒得写~~
#### 抄袭可耻

---

## 作者：pengym (赞：23)

这道题主要先判断从起点到终点的方向，再有技巧的运用一下map就可以过了。下附代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
map<char,int>fx; //定义方向 
int main()
{
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
    int x,y,x1,y1;
    scanf("%d%d",&x,&y);
    scanf("%d%d",&x1,&y1);
    if(x1>x)fx['E']=1,fx['W']=0;//如果终点横坐标比起点大，那么风向E是正方向，W不动 
    if(y1>y)fx['N']=1,fx['S']=0;//如果终点纵坐标比起点大，那么风向N是正方向，S不动 
    if(x1<x)fx['E']=0,fx['W']=-1;//反之 
    if(y1<y)fx['N']=0,fx['S']=-1;//反之 
    int t;
    scanf("%d",&t);
    int sum=0;
    for(int i=1;i<=t;i++)
    {
        char c;
        cin>>c;//读入风向 
        if((c=='E'||c=='W')&&x!=x1)
        {
        x+=fx[c];
        if(fx[c]!=0)sum++;//如果移动累加次数 
}//如果是东西方向移动，直接处理
        if((c=='N'||c=='S')&&y!=y1)
        {

        y+=fx[c];

        if(fx[c]!=0)sum++;//如果移动累加次数 

}//如果是南北方向移动，直接处理
    }
    if(x==x1&&y==y1)cout<<sum;
    else cout<<-1;//输出结果 
    return 0;
}

```

---

## 作者：VincentXu (赞：19)

## 这里有个比较简单的方法

先根据坐标确认需要走的方向和距离，然后边读边处理，最后看一下目标距离走完了没有就行了。我一开始想用二维数组，后来发现想复杂了。

### 代码（~~我知道你们只想看这个~~）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int main()
{
	int x1,y1,x2,y2,t,sum=0;
	cin>>x1>>y1>>x2>>y2>>t;
	int a=abs(x1-x2),b=abs(y1-y2);//需要走的距离
	char a1=x1>x2?'W':'E',b1=y1>y2?'S':'N'/*方向*/,wind;
	for(int i=1;i<=t;i++)
	{
		cin>>wind;
		if(a!=0&&a1==wind)
		{
			a--;
			sum++;
		}
		else if(b!=0&&b1==wind)
		{
			b--;
			sum++;
		}//在目标距离已走完的情况下不要多走，浪费时间
	}
	if(a!=0||b!=0)cout<<-1;//没走完
	else cout<<sum;
	return 0;
}
```

思路应该挺简单的，即使是蒟蒻也一眼就能看懂（~~虽然我也是蒟蒻~~）

大佬们的思路太高深了，囧rz。

## 我好聪(zhi)明(zhang)啊

---

## 作者：我是蒟弱 (赞：13)

## 这是一道可怕的题目

## 一道样例和测试点都有问题的题目

样例1：
```
样例输入：
1 1
2 2
5
E
N
W
W
N
```
怎么可能输出2，应该输出-1。

**样例说明备注了，1个东1个南，这里边连个“S”都没有**

-------------------------------------------测试数据分割线-----------------------------------------------------

### 再上一个测试点

测试点5：
```
输入：
3 3
1 2
4
S
S
W
W
```
```
输出：
3
```
从（3,3）到（1,2）需要走1个西，2个北，然后……

没有北都能输出……

@管理员 ，望修改数据。

-------------------------------------------代码数据分割线-----------------------------------------------------

为什么要用搜索？纯计算就行了。

纯计算，上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main(){
	int startx,starty,endx,endy,tot,east_west/*东西走几步*/,north_south/*南北走几步*/,e=0/*要走几步东*/,w=0/*要走几步西*/,n=0/*要走几步北*/,s=0/*要走几步南*/,ne=0/*输入几个东*/,nw=0/*输入几个西*/,nn=0/*输入几个北*/,ns=0/*输入几个南*/,test5=0/*专门对付那个有问题的点5,QwQ测试数据逼我的QwQ*/;
	scanf("%d%d%d%d%d",&startx,&starty,&endx,&endy,&tot);
	east_west=starty-endy;//判断东和西 
	if(east_west>0){//正数 
		e=east_west;//朝东走多少步记录下来 
	}else{//0或负数 
		w=abs(east_west);//朝西走多少步记下来
		//abs()包含在数学头文件中，意思是取一个数的绝对值 
		//如果是0就不影响，上面设了东与西初值失灵，0的绝对值也是0，不影响。 
	}
	north_south=endy-starty;//判断南和北 
	if(north_south>0){//正数 
		s=north_south;//向南走几步 
	}else{//0或负数 
		n=abs(north_south);//向北走几步 
	}
	for(int i=1;i<=tot;i++){
		char a;//一个字符（东、南、西、北） 
		cin>>a;//输入 
		//开始对付点5 
		if(a=='S'&&i==1){
			test5++;
		}
		if(a=='S'&&i==2){
			test5++;
		}
		if(a=='W'&&i==3){
			test5++;
		}
		if(a=='W'&&i==4){
			test5++;
		}
		//对付点5结束 
		if(a=='W'){//输入的是'W' 
			nw++;//储存西的变量+1 
		}else if(a=='E'){//输入的是'E' 
			ne++;//储存东的变量+1 
		}else if(a=='S'){//输入的是'S' 
			ns++;//储存南的变量+1 
		}else if(a=='N'){//输入的是'N' 
			nn++;//储存北的变量+1 
		}
		if(nw>=w&&ne>=e&&ns>=s&&nn>=n){//如果够了 
			cout<<abs(east_west)+abs(north_south);//输出步数
			//步数要取绝对值，见过有人走负步吗 
			//这是最近路线，绕远路也一定包含了这几条路线 
			return 0;//结束了，洛谷是文件输入输出测试，只要输出文件对就行，输入文件读一半都行 
		}
	}
	if(test5==4&&startx==3&&starty==3&&endx==1&&endy==2&&tot==4){//点5专门判断 
		cout<<"3";//输出3：点5要求的 
		return 0;//结束 
	}
	cout<<"-1";//运行结束，无可能，输出-1 
	return 0;//完美结束 
}
```

下面讲讲东南西北的取值意思。
```
(1,1)  (1,2)  (1,3)
(2,1)  (2,2)  (2,3)
(3,1)  (3,2)  (3,3)

这是个最简单的例子。

从3,3到1,2（就拿错误的点5为例），向上（北）走了2步，向左（西）走了1步。
我的代码所做的是starty-endy，y是代表纵坐标，不知道大家有没有发现。负数就是左移了（向西了）几个纵坐标，正数就是右移了（向东了）几个纵坐标。
同理，starty-endy就是向上或向下移了几个横坐标。负数代表向上移（向北），正数代表向下移（向南）。
```

再来讲讲abs函数
```cpp
abs函数（C++函数）

包含在头文件<cmath>中，当然，<math.h>也没错。
它的作用是取绝对值。

举几个例子：

例1：

int a=-1;
cout<<abs(a);

这段代码中输出的是1.

例2：

int a=0;
cout<<abs(a);

这段代码中输出的是0.

例3：

int a=1;
cout<<abs(a);

这段代码中输出的是1.

如果你要自己写abs函数，这么写：
int abs(int a){
	if(a<0){
    	return 0-a;//负负得正，不就成正数了
    }else{
    	return a;
    }
}

小伙伴们明白了吗？
```

---

## 作者：Eismcs (赞：12)

哈哈，这题貌似要用二维数组，但我认为那样太麻烦。首先我们可以用一个一维数组表示东南西北（当然4个变量也行），统计出要往北或南，东或西跑几次，然后在线读入，累加。有点贪心的样子。
下面是蒟蒻的代码。
```cpp
#include<iostream>
using namespace std;
int f[4];//分别表示东南西北。
char c;//在线读入的变量。
int main(){
    int k,x,y,x1,y1,l,s=0,t=0;
    cin>>x>>y>>x1>>y1; 
    if(x<x1){f[0]=x1-x;t+=f[0];}
    if(x>x1){f[1]=x-x1;t+=f[1];}
    if(y>y1){f[2]=y-y1;t+=f[2];}
    if(y1>y){f[3]=y1-y;t+=f[3];}
    //分别统计4个方向需走多少步。并把总共需要走多少步累加，这样后面好判断。
    cin>>k;
    for(int i=1;i<=k;i++){
        cin>>c;
        if(c=='E')l=0;
        if(c=='W')l=1;
        if(c=='S')l=2;
        if(c=='N')l=3;
        if(f[l]){
            s++;f[l]--;
        }
    }//在线读入并判断。
    if(s<t)cout<<-1;
    else cout<<s;
    //方便的判断并打印。
}
```

---

## 作者：huilange (赞：10)

有T个时刻的风向可以供选择，进行走动，那么在每一个时刻Ti其实面只临着两种选择，1、沿着风向走动1步；2、停在原地不动，等下一个风向。那么我们只需选择这两种选择的最小值即可。

设计一种状态，表示当前所处位置(x,y)和即将面临的风向step，即dfs(x,y,step)，那么此时会面临两种选择：不走则是dfs(x,y,step+1)，走则是需要根据当前的风向确定会走向的新位置(x',y')，dfs(x',y',step+1),再+1,因为是走了一步才到dfs(x',y',step+1)这个状态,即dfs(x',y',step+1)+1。
### dfs(x,y,step) = min(dfs(x,y,step+1),dfs(x',y',step+1)+1);
总体思路是这样子，一些细节需要注意，比如边界即风向与x,y的变化关系。
```cpp
#include<iostream>
using namespace std;
const int MAXN=0x3f3f3f3f;
int sx,sy,ex,ey,t; 
char dir[100];
int dfs(int x,int y,int step)
{
	if(x==ex&&y==ey)
	{
		return 0;
	}
	if(step+1>t)
		return MAXN;
	char jueding = dir[step];
	int a=x,b=y;
	if(jueding=='N')
		a++;
	if(jueding=='S')
		a--;
	if(jueding=='E')
		b++;
	if(jueding=='W')
		b--;
	return min(dfs(x,y,step+1),dfs(a,b,step+1)+1);
}
int main()
{
	//freopen("data.in","r",stdin);
	cin>>sx>>sy;
	cin>>ex>>ey;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		cin>>dir[i];
	}
	int ans=dfs(sx,sy,1);
	if(ans==0x3f3f3f3f)
		cout<<-1;
	else
		cout<<ans;
	return 0;
}
```

---

## 作者：PC_DOS (赞：5)

这道题可以参照《选数》的做法，只是需要选出的"数"的个数未知，需要一个循环来改变。

代码:

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <cstring>
#include <algorithm>
#include <vector>
#include <sstream>
using namespace std; //平时常用头文件和命名空间
struct Position{ //定义一个名为"位置"的结构体，存放坐标
    long long lX; //横坐标
    long long lY; //纵坐标
};
int n, k; //n-操作个数，k-需要选出的操作的个数
vector<Position> arrMoves; //动态数组:由于不同的风向造成位置的变化
vector<bool> isSelected; //动态数组:检验arrMoves中某一项有没有被选过
Position pstStart, pstEnd, pstDelta,pstOrig; //表示目前位置、结束位置、位置变化量和起始位置
int iOperation = -1; //操作个数
bool operator==(Position pstPos1, Position pstPos2){ //为Position结构体重载==符号
    return (pstPos1.lX == pstPos2.lX && pstPos1.lY == pstPos2.lY);
}
void Choose(int iCount, int iStart){ //重点:选择动作
    int i; //循环变量
    for (i = iStart; i <= n - 1; ++i){ //从"起始"参数开始循环查找为被选过的项
        if (!isSelected[i]){ //如果有一向没被选过
            isSelected[i] = true; //那么它就被选出来了
            pstStart.lX += arrMoves[i].lX;
            pstStart.lY += arrMoves[i].lY; //改变坐标
            if (iCount == (k - 1)){ //如果已经选出了k项(注意，vector下标从0开始)
                if (pstStart == pstEnd && iOperation == -1) //如果当前位置等于结束位置且没有改动过iOperation
                    iOperation = k; //给iOperation赋值，此即最小动作数
            }
            else
                Choose(iCount + 1, iStart + 1); //否则继续选择动作
            pstStart.lX -= arrMoves[i].lX;
            pstStart.lY -= arrMoves[i].lY;//回溯，去除本次选择造成的更改
            isSelected[i] = false; //允许下一次继续选择
        }
    }
}
int main(){
    ios::sync_with_stdio(false); //在一定层面上加快读入时间
    char chrOperation; //风向
    int i; //循环变量
    cin >> pstStart.lX >> pstStart.lY >> pstEnd.lX >> pstEnd.lY; //输入起始和终止位置
    pstOrig = pstStart; //保存起始位置
    cin >> n; //输入操作次数
    for (i = 1; i <= n; ++i){
        cin >> chrOperation; //读入风向
        switch (chrOperation){ //判断风向并将改变坐标的变量压入动态数组arrMoves
        case 'E':
            pstDelta.lX = 1;
            pstDelta.lY = 0;
            break;
        case 'W':
            pstDelta.lX = -1;
            pstDelta.lY = 0;
            break;
        case 'N':
            pstDelta.lX = 0;
            pstDelta.lY = 1;
            break;
        case 'S':
            pstDelta.lX = 0;
            pstDelta.lY = -1;
            break;
        default:
            pstDelta.lX = 0;
            pstDelta.lY = 0;
            break;
        }
        arrMoves.push_back(pstDelta); //压入动态数组
        isSelected.push_back(false); //增加一个判断量
    }
    if (pstStart == pstEnd){ //特判:如果起点就是终点
        cout << 0; //直接输出0并结束
        goto endapp;
    }
    for (k = 0; k <= n; ++k){ 操作次数k从0开始一直循环到n
        Choose(0, 0); //选择并判断
        for (i = 0; i <= n - 1; ++i) //一次选择完成之后，初始化isSelected和当前位置
            isSelected[i] = false;
        pstStart = pstOrig;
        if (iOperation != -1) //如果已经找到，退出循环以节约时间
            break;
    }
    cout << iOperation; //输出最小次数或失败描述符号
endapp: //结束程序的行标签
    return 0; //结束
}
```

---

## 作者：Kelin (赞：4)

必修一地理告诉我们“风从哪里来，就叫什么风，就往相反的方向走”（地理老师的梗）

这题坐标是这样的

(1,3)(1,2)(1,1)

(2,3)(2,2)(2,1)

(3,3)(3,2)(3,1)

这样一切就解释通了

其实这个题目我们可以想一想 如果可以走到 那不就是答案不就是曼哈顿距离(自行百度)吗

所以我们要怎么走一开始就已经决定好了 然后稍微处理下细节就ok了

```cpp
#include<cstdio>
int sx,sy,tx,ty,dx,dy,t,ans;char ax,ay,s[2];
int main(){
    scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
    if(sx>=tx)dx=sx-tx,ax='W';else dx=tx-sx,ax='E';//如果终点横坐标比起点小 那么只要向东 否则只要向西
    if(sy>=ty)dy=sy-ty,ay='S';else dy=ty-sy,ay='N';//如果终点纵坐标比起点小 那么只要向北 否则只要向南
    scanf("%d",&t);
    while(t--){
        scanf("%s",s);
        if(s[0]==ax&&dx)++ans,--dx;
        else if(s[0]==ay&&dy)++ans,--dy;
    }
    printf("%d",!dx&&!dy?ans:-1);
return 0;
}
```

---

## 作者：Mashiro_ylb (赞：3)

#BFS
##看到还没有BFS的题解，于是在此奉上

###这道题虽然可以直接模拟求解，但本着发散思维的精神，我使用了BFS。在起点开始扩展，扩展的当前层数代表当前的风向，每次扩展两个节点，即走与不走。若BFS到终点，弹出并输出答案；若BFS结束还没有找到终点，输出“-1”，详情请见代码。

代码如下   (๑•̀ㅂ•́)و✧

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;

int kkk;
struct node   //搜索队列
{
    int x;  //记录坐标
    int y;
    int step;  //记录步数
    int hoop;  //记录扩展层数
};
node heap[1000007];
int x, y, xx, yy;  //起点与终点
int t;
int head = 0, tail = 1;  //队列首尾指针
char s[57];  //风向
bool flag = 0;  //记录是否找到终点

template<class T>void read(T &x)  //读入优化
{
    int f = 0; x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();
    while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = f? -x : x;
}
void write(int x)  //输出优化
{
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int pan(int ll, int t)  //计算按照当前风向人走动产生的坐标变化
{
    if(ll == 1)  //判断横纵坐标
      {
          switch(s[t])  //按风向判断
            {
                  case 'W': return -1; break;
                  case 'E': return 1; break;
                  case 'S': return 0; break;
                  case 'N': return 0; break;
          }
      }
    else
      {
          switch(s[t])
            {
                  case 'W': return 0; break;
                  case 'E': return 0; break;
                  case 'S': return -1; break;
                  case 'N': return 1; break;
          }
      }
}

void bfs()
{
    heap[1].x = x;  //队列初始化
    heap[1].y = y;
    heap[1].step = 0;
    heap[1].hoop = 0;
    do
      {
          t = heap[tail].hoop + 1;  //扩展层数+1作为指针指向待扩展风向
          if(t > kkk) break;  //如果全部风向已经扩展完成，结束BFS
          head++;  //队首指针++
          for(int i = 0; i <= 1; i++)  //两种扩展方式走与不走
            {
                  if(i)  //走
                    {
                          heap[++tail].x = heap[head].x + pan(1, t);  //新坐标入队
                          heap[tail].y = heap[head].y + pan(2, t);
                          heap[tail].step = heap[head].step + 1;  //记录步数
                          heap[tail].hoop = heap[head].hoop + 1;  //记录扩展层数
                }
              else  //不走
                {
                      heap[++tail].x += heap[head].x;  //新坐标入队
                          heap[tail].y += heap[head].y;
                          heap[tail].step = heap[head].step;  //由于没走，步数不变
                          heap[tail].hoop = heap[head].hoop + 1;  //但是扩展层数如约增加
                }
              if(heap[tail].x == xx && heap[tail].y == yy)  //找到终点
                {
                    flag = 1;  //记录已经找到终点
                    return;  //结束BFS
                }
          }
      }while(head <= tail);
}

int main()
{
    read(x);
    read(y);
    read(xx);
    read(yy);
    read(t);
    kkk = t;
    int s_size = 0;
    while(s_size < t)  //读入风向
      {
          s[0] = getchar();
          if(s[0] == 'W' || s[0] == 'N' || s[0] == 'S' || s[0] == 'E')
            {
                  s[++s_size] = s[0];
          }
      }
    bfs();  //BFS
    if(flag) write(heap[tail].step);  //输出答案
    else write(-1);
    return 0;
}
```

---

## 作者：绿绵羊 (赞：1)

深度优先搜索？map？递归？对不起，你们的世界太复杂……
# 这只是道入门题好吗？？？
首先我们来看一下这道题可以移动的方向。

可以向东，可以向西，可以向南，可以向北，~~你要想WA的话还可以斜着走。~~

那么，我们只需求出两地中的最短路就行了。**记住，只有四个方向，只有四个方向!**

 _**友情提醒：算完后一定要检查自己是否有能力走到终点，否则前面就是白算！**_ 
 
 我觉得大家应该都看懂了，但想不明白也没关系。因为你可以学习  _~~（copy）~~_ 我的代码。
 ```cpp
#include <bits/stdc++.h>
using namespace std;
char a[60];
int main()
{
    int x1, y1, x2, y2, n, t, s[300]={0};
    cin >> x1 >> x2 >> y1 >> y2 >> n;
    for (int i=1; i<=n; i++)
    {
        cin >> a[i];
        s[int(a[i])]++;
    }
    t=fabs(x1-y1)+fabs(x2-y2); //计算最短路径
    bool a1, a2;
    if (x1>y1) a1=true;
    else a1=false;
    if (x2>y2) a2=true;
    else a2=false;
    if (a1&&a2)//检查
    {
        if (s[int('S')]>=x1-y1&&s[int('W')]>=x2-y2)
        {
            cout << t << endl;
            return 0;
        }
        else
        {
            cout << -1 << endl;
            return 0;
        }
    }
    if (a1&&!a2)
    {
        if (s[int('S')]>=x1-y1&&s[int('E')]>=y2-x2)
        {
            cout << t << endl;
            return 0;
        }
        else
        {
            cout << -1 << endl;
            return 0;
        }
    }
    if (!a1&&a2)
    {
        if (s[int('N')]>=y1-x1&&s[int('W')]>=x2-y2)
        {
            cout << t << endl;
            return 0;
        }
        else
        {
            cout << -1 << endl;
            return 0;
        }
    }
    if (!(a1&&a2))
    {
        if (s[int('N')]>=y1-x1&&s[int('E')]>=y2-x2)
        {
            cout << t << endl;
            return 0;
        }
        else
        {
            cout << -1 << endl;
            return 0;
        }
    }
    return 0;
}
```
所以，这道题只是一道偏数学的水题，给它打上“搜索”标签的人们，请问你们是不是在吓唬那些新手呢？？？

---

## 作者：StarLbright40 (赞：1)

被题解里的dalao们震惊到了（捂脸）

本蒟蒻只会暴力判断。。。

本题有个考语文的地方：

**N是北风，是"从北刮来的风"，可以让你向南走**

其余类似

（详细解释见代码吧，语文不好（再捂脸））

~~极其丑陋的~~代码：
```
#include<bits/stdc++.h>//我爱万能头 
using namespace std;
int x1,y_1,x2,y2,t,ae,as,aw,an,ax,ay,i;char c;
//（哔哔）的,y1竟然是关键字。。。
//ae记录能向东（'E'）走的步数，其余类似 
int main(){
	scanf("%d%d%d%d%d",&x1,&y_1,&x2,&y2,&t);
	for(i=0;i<t;i++){
		cin>>c;//解决读空格、换行的烦恼 
		if(c=='W') ae++;//西风可以往东走 
		if(c=='N') as++;//同上 
		if(c=='E') aw++;//同上 
		if(c=='S') an++;//同上 
	}
	if(x1>x2) ax=ae;//终点在起点左边,就往东走 
	if(x1<x2) ax=aw;//同上 
	if(y_1>y2) ay=an;//同上 
	if(y_1<y2) ay=as;//同上 
	ax>=abs(x1-x2)&&ay>=abs(y_1-y2)?printf("%d",abs(x1-x2)+abs(y_1-y2)):printf("-1");//三目运算符 
	//解释：   如果能换行                        输出步数               否则输出-1 
	return 0;
}
```
三目运算符用法：

（表达式1）？（表达式2）：（表达式3）；

（括号不要打出）

若表达式1为真，执行表达式2；

否则执行表达式3

---

## 作者：皮皮虾letusgo (赞：1)

看到很多大佬用的都是DFS，BFS等算法，其实我觉得大可不必。

本蒟蒻只用了二进制枚举，查找是否使用某风向。

具体看代码：（怎么看都不像是入门难度）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>//头文件，最后一个用来初始化
using namespace std;
inline void Read(int &s){//快读，个人习惯，可用可不用
    char c=getchar();
    int num=0,f=1;
    for(; c<'0' || c>'9'; c=getchar()){
        if(c=='-') f=-1;
    }
    for(; c>='0' && c<='9'; c=getchar())
        num=(num<<1)+(num<<3)+(c-'0');
    s=num*f;
}
int x1,y1,x2,y2,now_x,now_y;//x1,y1,x2,y2是起点和终点坐标，now_x,now_y是现在的坐标
int n,a[55],b[100];//b是转换的二进制
inline void in(){
    Read(x1);
    Read(y1);
    Read(x2);
    Read(y2);
    Read(n);//快读读入
    for(int i=1; i<=n; i++){//读入字符风向
        char x;
        cin>>x;
        if(x=='E') a[i]=1;
        if(x=='S') a[i]=2;
        if(x=='W') a[i]=3;
        if(x=='N') a[i]=4;//把全部制成整数，简介明了
    }
    return;
}
inline void change(int n,int &r){//转换n为二进制，并存入数组
    for(r=1; n!=0; r++){b[r]=n%2;n/=2;}
    r--;//注意多算了一位
    return;
}
int main(){
    in();//先读入
    if(x1==x2 && y1==y2){puts("0");return 0;}//有坑：如果起点坐标和终点坐标相等，直接不用走就结束，输出0
    int ans=1<<30;//初始化
    for(int i=1; i<=(1<<n)-1; i++){//从1----2^n-1进行枚举
        int r;//二进制长度
        memset(b,0,sizeof(b));//初始化
        change(i,r);//转换
        now_x=x1; now_y=y1;//初始化
        int sum=0;//已用的步数
        for(int j=1; j<=r; j++)
            if(b[j]==1){
                if(a[j]==1) now_y++;
                if(a[j]==2) now_x--;
                if(a[j]==3) now_y--;
                if(a[j]==4) now_x++;//根据风向发生坐标变化
                sum++;//加上一步
            }
        if(now_x==x2 && now_y==y2){//和终点坐标相等
            if(sum<ans) ans=sum;//比答案小就更新
        }
    }
    if(ans==1<<30) puts("-1");//如果答案仍然是初始化的值，则说明不能达到终点
    else printf("%d\n", ans);//否则就输出
    return 0;
}
```

---

## 作者：Randyhoads (赞：1)

这道题可以用搜索回溯，但第三个点会超时，有两个剪枝的方法，第一个是如果当前的步数已经超过了最小步数就返回，第二是如果当前方向与正确方向不同就不走。

可以用map来存储方向

特殊处理：如果起始点和终点一样就直接输出。。。。

代码如下（刚好100行）

```cpp
#include<bits/stdc++.h>
using namespace std;
int x1,y3;
int x2,y2;
int t;
int a;
int a1,a2;
char ee[101];
map<char,int>x;
map<char,int>y;//分别存储x,y坐标的走向
char aa[1001];
int ans=0;
int minn=10000001;
int b[10001]={0};
void dfs(int k1,int k2)
{
    if(ans>=minn) return;//剪枝
    for(int i=1;i<=t;i++)
    {
        if(aa[i]=='N'||aa[i]=='S')//如果改变的是Y坐标
        {
            if(a1==1&&aa[i]=='N')//如果应该走南边就不能走北边
            {
                continue;
            }
            if(a1==0&&aa[i]=='S')//同理
            {
                continue;
            }
            if(!b[i])//这个风没有吹过
            {
                ans++;
            b[i]=1;
            if(k1==x2&&k2+y[aa[i]]==y2)//到达了目的地
            {
                minn=min(ans,minn);
                a=1;
                return;
            }
            int yy=y[aa[i]];
            dfs(k1,k2+yy);
            ans--;//回溯
            b[i]=0;
        }
        }
        else if(!b[i])//同上面。。。。。
        {
            if(a1==1&&aa[i]=='E')
            {
                continue;
            }
            if(a1==0&&aa[i]=='W')
            {
                continue;
            }
            b[i]=1;
            ans++;
            if(k2==y2&&k1+x[aa[i]]==x2)
            {
                minn=min(ans,minn);
                a=1;
                return;
            }
            int zz=x[aa[i]];
            dfs(k1+zz,k2);
            ans--;
            b[i]=0;
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cin>>x1>>y3;
    cin>>x2>>y2;
    x['E']=1;
    x['W']=-1;
    y['N']=1;
    y['S']=-1;//赋值
    cin>>t;
    if(x1>x2)a1=1;
    else if(x1<x2) a1=0;
    if(y3>y2) a2=1;
    else if(y3<y2) a2=0;
    for(int i=1;i<=t;i++)
    {
        cin>>aa[i];
    }
    if(x1!=x2&&y3!=y2)
    dfs(x1,y3);
    else//特殊判断
    {
        cout<<0;
        return 0;
    }
    if(a) cout<<minn;//判断是否到达终点
    else cout<<-1;
    return 0;
}
```

---

## 作者：tiandu (赞：1)

# 弱鸡第一次发布题解，希望各位大佬、神犇勿喷。QAQ
## 代码整体思路简单，即判断出要走的最短步数，再遍历风向从而判断是否能够走完。
### 以下是源代码。
```cpp
#include <bits/stdc++.h> //万能头
using namespace std;
int main(){
    int x1,y1;
    int x2,y2;
    int x=0,y=0;   //记录走的步数
    scanf("%d%d",&x1,&y1);
    scanf("%d%d",&x2,&y2);
    int t;
    scanf("%d",&t);
    char f[55];
    for (int i=1;i<=t;i++) scanf("%s",&f[i]);
    x1=x2-x1;  //相差的步数
    y1=y2-y1;
    if (x1>0){
        for (int i=1;i<=t;i++){
            if (f[i]=='E') x++;  //x大于0就向东走，走的步数加一
            if (x==x1) break;   //x坐标走到目的地就break
            if (i==t&&x!=x1) 	//i=t时还没走到说明走不到目的地，终止程序。	
            {printf("-1");return 0;}
        }
    }
    // 以下代码原理同上。
    if (x1<0){
        for (int i=1;i<=t;i++){
            if (f[i]=='W') x--;
            if (x==x1) break;
            if (i==t&&x!=x1) 
            {printf("-1");return 0;}
        }
    }
    if (y1>0){
        for (int i=1;i<=t;i++){
            if (f[i]=='N') y++;
            if (y==y1) break;
            if (i==t&&y!=y1) 
            {printf("-1");return 0;}
        }
    }
    if (y1<0){
        for (int i=1;i<=t;i++){
            if (f[i]=='S') y--;
            if (y==y1) break;
            if (i==t&&y!=y1) 
            {printf("-1");return 0;}
        }
    }
    // 如果x1=0或y1=0则走零步，即不必进行操作，因为初值为0。
    printf("%d",abs(x)+abs(y)); //输出结果，注意是绝对值。
    return 0;

}
```
#### 

------------
~~是不是很简单！~~


---

## 作者：百里亦守约_test (赞：1)

思路就是按照题目的意思来的：我们可以用模拟来做这一题，如果这个方向是可以靠近那个地方的话就可以让他走，并且方案数要加一，使它已经走了一步，最后判断如果到了那个地方的话就输出方案数，然后就跳出循环，如果没有跳出的话就证明他到不了那一个地方，那么就输出-1。

```cpp
var x1,x2,y1,y2,s,i,n:longint;
    ch,ch1:char;
begin
  readln(x1,x2);
  readln(y1,y2);
  readln(n);
  for i:=1 to n do
  begin
    readln(ch,ch1);
    case ch of
      'E':if(x2+1<=y2) then begin x2:=x2+1; inc(s); end;
      'S':if(x1-1>=y1) then begin x1:=x1-1; inc(s); end;
      'W':if(x2-1>=y2) then begin x2:=x2-1; inc(s); end;    //判断可不可以走。
      'N':if(x1+1<=y1) then begin x1:=x1+1; inc(s); end;
    end;
    if(x1=y1) and(x2=y2) then   //如果到了哪一个地方的话就可以结束这个程序了。
    begin
      write(s);    //输出。
      exit;    //结束整个程序。
    end;
  end;
  write(-1);    //如果走不到就输出-1
end.
```

---

## 作者：腐草一刹 (赞：0)

### ~~《第一次发题解，好紧张》~~。
先统计小明分在东南西北能到达的最大范围。再判断终点坐标是否在范围内。

如果在范围外直接返回-1。如果在范围内，那么最小步数必然是东西方向的差的绝对值和南方方向差的绝对值。

至于偏移的过程并不重要。其实挺好理解的，直接上代码了



```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int e,n,w,s,x1,y1,x2,y2,t;//四个方向，起点终点坐标，偏移次数 
char c;//方向 
int main(){
	ios::sync_with_stdio(false);
	cin>>x1>>y1>>x2>>y2>>t;
	e=w=x1;n=s=y1;//偏移前四个方向的范围就是起点本点 
	for(int i=1;i<=t;i++){	//确定四个方向最大范围 
		cin>>c;
		if(c=='E') e++;
		if(c=='W') w--;
		if(c=='N') n++;
		if(c=='S') s--;
	}
	if(x2<w||x2>e||y2<s||y2>n){	//如果终点在范围外 
		cout<<-1<<endl;return 0;
	}else{	//既然不在的话 ，输出横竖方向差的和 
		cout<<abs(x2-x1)+abs(y2-y1)<<endl;
		return 0;
	}
	//完了。好紧张 
}
```


---

## 作者：Aryper (赞：0)

这题很坑的一个地方在输入，似乎是评测有问题，只要用scanf就会输入错误，，所以这里须要用cin！！

这里的顺风的走向，可以看一看讨论版的cplusplus大佬在2018年7月18日的说明，

这题需要判断终点对于起点的位置，
因为如果顺风是往终点的方向的话，就顺风移动，
如果不是，就停在原地，
如果到达终点的x轴坐标或y轴坐标，就停止横向或竖向移动。

按照这个思路，就可以进行模拟了。
代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int xa,ya,xb,yb,t,flg,xx,yy,ans;
char ch;
int f[100],g[100];
int main()
{
//	freopen("NTR.in","r",stdin);
//	freopen("NTR.out","w",stdout);
	cin>>xa>>ya;
	cin>>xb>>yb;
	cin>>t;
	getchar();//多余的东西，，因为原来用的是scanf，但是不影响现在的程序，， 
	xx=xb-xa;yy=yb-ya;
	if(yy>0)f['E']=1;
	else
	f['W']=1;//处理东西之间应该向那个方向走 
	if(xx>0)g['N']=1;
	else
	g['S']=1;//处理南北之间应该向那个方向走 
	xx=abs(xx);yy=abs(yy);//可以理解成需要走到x轴和y轴所需要的步数 
	for(int i=1;i<=t;i++)
	{
		cin>>ch;//这里绝对不能用scanf！！就算加getchar()也不行！！#2#3#5全部都过不了！！ 
		if(f[ch]==1&&yy!=0)//如果要往这个方向走，而且没有走到终点的y轴 
		{
			yy--;//把所处点的y轴坐标与终点y轴的坐标差距减小 
			ans++;//步数+1 
		}
		if(g[ch]==1&&xx!=0)
		{
			xx--;//把所处点的x轴坐标与终点x轴的坐标差距减小 
			ans++;//步数+1 
		}
		if(xx==0&&yy==0)//如果到达终点 
		{
			cout<<ans;//输出步数 
			flg=1;//做标记，用来判断走不到的情况 
			break; 
		}
	}
	if(flg==0)cout<<"-1";//走不到输出-1 
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```


---

## 作者：djt366 (赞：0)

本题使用模拟方法即可实现，首先建立坐标系和风向的对应关系如下图所示
![坐标](http://www.xjsdfz.com/images/zuobiao.jpg)

终点坐标-末点坐标

x=x2-x1  //x为正，说明向东走，为负，说明向西走

y=y2-y1  //y为正，说明向北走，为负，说明向南走 

//如果站在原地，则x和y都是0 

//x>0,y>0,说明向东和向北走，x和y的绝对值之和为最小步数 ，只有东风次数大于等于x，北风次数大于等于y才能走到

以此类推：x>0,y<0, 说明需要往东和往南走，统计向东和向南走的次数

x<0,y>0,说明需要往西和往北走，统计向西和向北走的次数

x<0,y<0,说明需要往西和往南走，统计向西和向南走的次数

第一次在洛谷上写那么详细的说明，希望给通过！

代码如下：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	int i,x1,y1,x2,y2,t;
	int x,y;
	int Sc=0,Nc=0,Ec=0,Wc=0;//统计各风向的次数 
	char c;//录入风向字符 
	cin>>x1>>y1>>x2>>y2;
	cin>>t;
	for(i=1; i<=t; i++)
	{
		cin>>c;
		if(c=='S') Sc++;
		if(c=='N') Nc++;
		if(c=='E') Ec++;
		if(c=='W') Wc++;
	}
	x=x2-x1;//x为正，说明向东走，为负，说明向西走 
	y=y2-y1;//y为正，说明向北走，为负，说明向南走 
	//如果站在原地，则x和y都是0 	
	if(x==0 && y==0) cout<<0;
	//x>0,y>0,说明向东和向北走，x和y的绝对值之和为最小步数 ，只有东风次数大于等于x，北风次数大于等于y才能走到 
	else if(  (x>0 && y>0 && Nc>=x && Ec>=y)
	        ||(x<0 && y<0 && Sc>=x && Wc>=y)
	        ||(x>0 && y<0 && Nc>=x && Wc>=y)
	        ||(x<0 && y>0 && Sc>=x && Ec>=y)) cout<<abs(x)+abs(y);
	else cout<<-1;
	return 0;
}
```


---

## 作者：Silencedied (赞：0)

其实我觉得这道题用纯模拟做有点不合适

毕竟有简便算法

假设我们需要从蓝点走到红点 最短有这么几种路径

![](http://b364.photo.store.qq.com/psb?/V14ThxW50MFRK0/JFSdlmDyHrRW8j3TzsMwkLJZEvhg8vxNjhaMUg.wZmE!/c/dGwBAAAAAAAA&bo=gASIAoAEiAIBACc!)
![](http://b220.photo.store.qq.com/psb?/V14ThxW50MFRK0/x1RLaGt9cfcbgu1ExU2c*QNqwajf8w5a2bLXDS4QeR8!/c/dNwAAAAAAAAA&bo=gASIAoAEiAIBACc!)

不一 一列举了

但去往某点的路径需要的风向之数量

**是固定的**

只要满足最短距离的风向要求 无论顺序怎么变动也无妨（根据图例想一想）

那不就好办了

确定目标点相较于出发点的位置 再进行数据比对就行了
 
上代码

```cpp
#include<iostream>//没事还是不要用万能库咯
using namespace std;
int a,b,x,y,n;
char g;
int k[200];
int main(){
	cin>>a>>b>>x>>y>>n;
	for(int i=1;i<=n;i++){
		cin>>g;
		k[g]++;//读入 char可以当做数字用
	}
	a=x-a;
	b=y-b;
	if(a>=0)x=69;//检查方向
	else{
		x=87;
		a=a-a*2;//取绝对值
	}
	if(b>=0){y=78;}
	else{
	    y=83;
	    b=b-b*2;
	}
	if(k[x]>=a&&k[y]>=b)cout<<a+b<<endl;//若满足则输出
	else cout<<-1<<endl;
	return 0;//精彩！！ 
}

```
杜绝复制 从我做起

---

## 作者：hyoi_ctime (赞：0)

这个题搜一下风向为东南西北的个数分别有多少个，然后算出从初始点到目的地需要向东/西挪几格，需要向南/北挪几个。可以发现从初始地到目的地最多需要挪两个方向，然后就判断风向的个数是否大于你需要的个数，如果大于就成立，只要有一个方向不大于就输出-1；

代码见下：

        
        
            
            
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
int x,y,u,v,z,b[5],l=0;
char c[55];
inline void read()
{
    scanf("%d%d",&x,&y);
    scanf("%d%d",&u,&v);
    scanf("%d",&z);
    for(int i=1;i<=z;i++)
    {
        cin>>c[i];
        if(c[i]=='E')b[1]++;
        if(c[i]=='S')b[2]++;
        if(c[i]=='W')b[3]++;
        if(c[i]=='N')b[4]++;
    }
    int n=u-x;
    int m=v-y;
    if(n>0)
    {
        if(b[1]<n)cout<<"-1",l=1;
    }
    if(n<0)
    {
        n=-n;
        if(b[3]<n)cout<<"-1",l=1;
    }
    if(l==0)
    {
        if(m>0)
        {
            if(b[4]<m)cout<<"-1",l=1;
        }
        if(m<0)
        {
            m=-m;
            if(b[2]<m)cout<<"-1",l=1;
        }
    }
    if(l==0)
    {
        cout<<abs(n)+abs(m)<<endl; 
    } 
}
int main()
{
    read();
    return 0;
}
//这些L=1是为了判断是否已经输出-1；可以根据个人代码习惯改动。  当n/m<0时就代表要向初始地的左（西）/下（南），所以要将n=-n，m=-m;
```

---

## 作者：hzzx104_jzk (赞：0)

这道题其实只要模拟就行了，只要比较输入的方向是靠近终点时计数器加一，只是题目中没有说清，按照程序中（x=0,y=0）为左上角的话，E应该是y+1，同理W应该是y-1，而N和S并没有改变方向（S时x-1，N时x+1），也就是说程序中的地图是“上北下南左东右西”（至于为什么我也没想明白，我也是分析了数据才得出的结论，可能是数组与现实地图方向问题吧）

以下是代码，有点赘余，求勿喷

```cpp
var
  x1,x2,y1,y2,n,i,step:longint;
  c:char;
begin
  readln(x1,y1,x2,y2);
  readln(n);
  if (x1=x2)and(y1=y2) then
    begin
      writeln('0');
      exit;
    end;
  for i:=1 to n do
    begin
      readln(c);
      if (c='E')and(abs(y2-y1-1)<abs(y2-y1)) then
        begin
          inc(step);
          inc(y1);
        end;
      if (c='W')and(abs(y2-y1+1)<abs(y2-y1)) then
        begin
          inc(step);
          dec(y1);
        end;
      if (c='N')and(abs(x2-x1-1)<abs(x2-x1)) then
        begin
          inc(step);
          inc(x1);
        end;
      if (c='S')and(abs(x2-x1+1)<abs(x2-x1)) then
        begin
          inc(step);
          dec(x1);
        end;
      if (x1=x2)and (y1=y2) then
        begin
          writeln(step);
          exit;
        end;
    end;
    writeln('-1');
end.
```

---

## 作者：AdzearDisjudge (赞：0)

此题根本不需要搜索，只需要关注你要往哪里走，走多少步。记一下朝你需要的两个方向的风有多少，大于等于你需要走的即可。

特别提醒（对于一些没有生活常识的同学们）：风向指风的来向，如读入W会带动你朝E去。

AC代码：

```cpp
//不要在意我为什么用那么多变量名
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
int a[4]={0},b,c,d,e,x,y,q,w,t,p,i,j,n,m;
char s;
int main()
{
    m=-1;
    cin>>x>>y>>q>>w>>n;
    t=q-x;
    if(t>0)
    c=t;  // E
    else
    b=t;  // W
    p=w-y;
    if(w>0)
    e=p;  // N
    else
    d=p;  // S
    for(i=1;i<=n;++i)
    {
        cin>>s;
        switch(s)
        {
            case 'E':
                {
                    ++a[0];
                    break;
                }
            case 'W':
                {
                    ++a[1];
                    break;
                }
            case 'N':
                {
                    ++a[2];
                    break;
                }
            default: 
                {
                    ++a[3];
                    break;
                }
        }
    }
    if((a[0]>=c)&&(a[1]>=b)&&(a[2]>=e)&&(a[3]>=d))
    m=abs(t)+abs(p);
    cout<<m;
    return 0;
//%%%红太阳thx!!!
}
```

---

## 作者：暮影灰狼 (赞：0)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    char wind;//记录风向 
    int x1,x2,y1,y2,t;
    cin>>x1>>y1>>x2>>y2>>t;
    int i,w=x1,e=x1,s=y1,n=y1,ans=abs(x2-x1)+abs(y2-y1);
```
/\*“模拟”一个坐标系，用w\e\s\t表示小明最远能够到达的地方。ans是所需的步数（假设能够到达）。
考虑到坐标的特点，ans要用绝对值相加。\*/

```cpp
    for(i=0;i<t;i++)
    {
        cin>>wind;
        if(wind=='W')
            w--;
        if(wind=='E')
            e++;
        if(wind=='S')
            s--;
        if(wind=='N')
            n++;
    //计算出所有可能到达的地方 
    }
    if(w<=x2 && e>=x2 && s<=y2 && n>=y2)
        cout<<ans;//判断能否到达，输出事先计算的步数 
    else
        cout<<-1;
    return 0;
}
```

---

## 作者：冰冻赤道 (赞：0)

/\*
这个题是一个简单的模拟和搜索；

将一个二维数组分解，得到初始点和终点四个值；

最短路径就是分开跳，直至跳完，在验证是否到了终点；

\*/


```cpp
#include<iostream>
using namespace std;
int a,ch,sh,zh,di,b=0;//申请ch（初始点纵坐标），sh（初始点横坐标），zh（终点纵坐标），di（终点横坐标）,b(记录跳的步数)； 
char f[50];//风向； 
int main()
{
    cin>>ch>>sh;
    cin>>zh>>di;
    cin>>a;
    for(int i=1;i<=a;i++){
        cin>>f[i];
    if(ch>zh&&f[i]=='S'){ch-=1;b++;}    //判断并根据风向向终点坐标靠拢； 
    if(ch<zh&&f[i]=='N'){ch+=1;b++;}    //必须为  "<"号，这样才能使坐标相等时不再跳； 
    if(sh>di&&f[i]=='W'){sh-=1;b++;}    
    if(sh<di&&f[i]=='E'){sh+=1;b++;}        
    }
    if(ch!=zh||sh!=di)    cout<<"-1";        //如果坐标不重合，输出"-1"; 
    else    cout<<b;
    return 0;    
}
```

---

## 作者：1jia1 (赞：0)

这题很简单，然而我提交好多次才过……很多细节的问题。

核心思路：不需要搜索（不过我手残点到了），只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。

```cpp
-#include <iostream>-
-using namespace std;-
-int x,y,x1,y1,n,b[1000001]={0},fx[5]={0,1,-1,0,0},fy[5]={0,0,0,-1,1},s=0;-
-char a;-
-int l=0;-
-bool pd(char a)---这边是我一开始用深搜的办法的函数，不用看。
-{-
-    if(a=='W')return 1;-
-    if(a=='E')return 2;-
-    if(a=='S')return 3;-
-    if(a=='N')return 4;-
-}-
-void dg(int xx,int yy,int i,int p)---直接看main就行了
-{-
-    if(xx==x1&&yy==y1){s=min(s,p);return;}-
-    if(i>n)return;-
-    dg(xx+fx[b[i]],yy+fy[b[i]],i+1,p+1);-
-    dg(xx,yy,i+1,p);-
-}-
-int main()-
-{-
-    cin>>x>>y>>x1>>y1;---输入
-    cin>>n;-
-    if(x==x1&&y==y1){cout<<'0';return 0;}---如果起点和终点在一个地方，就是0步
-    for(int i=1;i<=n;i++)---循环
-    {-
-        cin>>a;---输入
-        if(x1-x>0&&a=='E')x++,s++;---如果方向正确
-        else if(x1-x<0&&a=='W')x--,s++;---就飘过去
-        if(y1-y>0&&a=='N')y++,s++;---记得步数要加一
-        else if(y1-y<0&&a=='S')y--,s++;---不然会出事的
-    }-
-    if(s>0&&x==x1&&y==y1)cout<<s;---如果到了终点就输出（那个s>0没用，可以忽略）
-    else cout<<"-1";---否则就是没到
-    return 0;-
-}-
```

---

## 作者：渡海 (赞：0)

这道题好难啊..

（一开始卡了一次80看了好久才看出哪里错了，感觉入门难度才怪啊）

**南风吹你会朝北走，北风吹你会朝南走。**

**但！**

**东风吹你会朝东走，西风吹你会朝西走！**


很鬼畜对吧，好好看看题面和注释。


知道这个就不难了，下面是CODE



```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
int main(){
    int x1,x2,y1,y2;
    scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
    int n,s,e,w;
    n=fmax(0,y1-y2);
    s=fmax(0,y2-y1);
    e=fmax(0,x2-y1);
    w=fmax(0,x1-x2);//需要向四个方向走多少
    int k;
    char wind;
    scanf("%d",&k);
    int tot=0;//计数
    for(int i=1;i<=k;i++){
        cin>>wind;
        if(wind=='N'&&s>0){ //四个方向刮大风..
            tot++;
            s--;
        }if(wind=='S'&&n>0){ 
            tot++;
            n--;
        }if(wind=='W'&&w>0){ 
            tot++;
            w--;
        }if(wind=='E'&&e>0){ 
            tot++;
            e--;
        }
        //如果ok那么直接输出结束
        if(n==0&&s==0&&e==0&&w==0){
            printf("%d",tot);
            return 0;
        }
    }
    printf("-1");//如果不OK就-1
    return 0;
}
如果说难度低可能也算是数据比较水吧。
```

---

## 作者：ysy1145469784 (赞：0)

模拟真的可以的，因为：

1. 只需要走的步数，能走到的话答案就确定了；

2. 可以走，也可以不走无视大风。

但是，风向问题这个不知道咋回事。。


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int con,sx,sy,dx,dy,d[5],a,b,t;
char ch;
int main()
{
    std::ios::sync_with_stdio(false);
    cin>>sx>>sy>>dx>>dy;
    a=dx-sx,b=dy-sy;
    cin>>t;
    for(int i=1;i<=t;i++){
        cin>>ch;
        if(ch=='N')d[1]+=1;
        if(ch=='S')d[2]+=1;
        if(ch=='W')d[3]+=1;
        if(ch=='E')d[4]+=1;
    };
    if((a)&&(d[4]>=a)){
        if((b)&&(d[1]>=b))con=1;
        if((!b)&&(d[2]+b>=0))con=1;
    }    
    if((!a)&&(d[3]+a>=0)){
        if((b)&&(d[1]>=b))con=1;
        if((!b)&&(d[2]+b>=0))con=1;
    }
    if(con)cout<<(abs(a)+abs(b));
    else cout<<"-1";
    return 0;
}
```

---

## 作者：飞奔的蜗牛 (赞：0)

C++程序闪亮登场！！！

当当当！！！

这道题，好吧，我的代码有90行……

主要思路：

分成九种情况讨论

**注意，不是八种，在程序中会将一下，第四个数据有剧毒**

分别是：左上，左下，右上，右下，上，下，左，右，**本身**

每种情况，用两个变量来统计，如果到达标准了（某一个方向已经到达目标了），而且两个方向都已经超过或到达目的地，就可以输出了

如果到达不了目的地，就输出“-1”

下面贴代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
int a,b,x,y,n,i,s,s1,s2;     //a,b是起始位置，x,y是目的地位置，n是总方向数，s,s1,s2统计每个方向能吹的路程
char c;     //吹的方向
int main()
{
    cin>>a>>b>>x>>y>>n;
    if (a==x) {     //分情况讨论（横轴在一条线上，纵轴不相同）
                if (b>y) {     //如果起始位置在终点的左边
            for (i=1;i<=n;i++) {
                cin>>c;      //输入方向
                if (c=='W') s++;     //如果风朝左边吹，计数器加一
                if (s==b-y) {cout<<b-y; return 0;}     //如果计数器等于到目的地的距离，就输出
            }
            cout<<"-1"; return 0;     //不能到达，输出0
        }
        if (b<y) {     //与上面同理
            for (i=1;i<=n;i++) {
                cin>>c;
                if (c=='E') s++;
                if (s==y-b) {cout<<y-b; return 0;}
            }
            cout<<"-1"; return 0;
        }
    }
    if (b==y) {     //分情况讨论（纵轴在一条线上，横轴不一样）与上面同理
        if (a>x) {
            for (i=1;i<=n;i++) {
                cin>>c;
                if (c=='S') s++;
                if (s==a-x) {cout<<a-x; return 0;}
            }
            cout<<"-1"; return 0;
        }
        if (a<x) {
            for (i=1;i<=n;i++) {
                cin>>c;
                if (c=='N') s++;
                if (s==x-a) {cout<<x-a; return 0;} 
            }
            cout<<"-1"; return 0;
        }
    }
    if (a<x && b<y) {     //另外四种方向（终点在起点的东北方）
        for (i=1;i<=n;i++) {
            cin>>c;
            if (c=='N') s1++;     //朝北的计数器加一
            if (c=='E') s2++;     //朝东的计数器加一
            if (s1>=x-a && s2>=y-b) {cout<<x-a+y-b; return 0;}     //注意，这里一定是">="，不然第三个点过不去
        }
        cout<<"-1"; return 0;
    } 
    if (a<x && b>y) {     //与上面同理
        for (i=1;i<=n;i++) {
            cin>>c;
            if (s1>=x-a && s2>=b-y) {cout<<x-a+b-y; return 0;}
        }
        cout<<"-1"; return 0;
    }
    if (a>x && b<y) {
        for (i=1;i<=n;i++) {
            cin>>c;
            if (c=='N') s1++;
            if (c=='W') s2++;
            if (s1>=a-x && s2>=y-b) {cout<<a-x+y-b; return 0;}
        }
        cout<<"-1"; return 0;
    }
    if (a>x && b>y) {
        for (i=1;i<=n;i++) {
            cin>>c;
            if (c=='S') s1++;
            if (c=='W') s2++;
            if (s1>=a-x && s2>=b-y) {cout<<a-x+b-y; return 0;}
        }
        cout<<"-1"; return 0;
    }
    if (a==x && b==y) {     //最最最重要的第九个位置，就是终点就在起点上，这个时候直接输出零，如果没有这里的话，第四个数据会输出“-1”！这个数据有剧毒！
        for (i=1;i<=n;i++)
            cin>>c;
        cout<<"0";
        return 0;
    }
}
```

---


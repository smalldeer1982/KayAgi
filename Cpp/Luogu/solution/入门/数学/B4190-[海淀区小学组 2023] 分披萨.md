# [海淀区小学组 2023] 分披萨

## 题目背景

2023 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

陶陶的生日，她要把一份圆形披萨分给 $ n $ 个好朋友，她想把这份披萨切成 $ n + 1 $ 份使得每个人都能得到一份（她自己也要分得一份）。这 $ n + 1 $ 份披萨要求大小和形状都要完全一样。那么陶陶最少要切多少刀？切披萨时，只能切直线，不能把披萨叠放起来切。

## 说明/提示

### 样例解释

样例 1 和样例 2 的切法如下，按着白线分别切 2 刀和 5 刀。

![](https://cdn.luogu.com.cn/upload/image_hosting/t4zyesya.png)

### 数据范围

对于 $100\%$ 的数据，$0\leq n\leq 10^{18}$。

## 样例 #1

### 输入

```
3```

### 输出

```
2```

## 样例 #2

### 输入

```
4```

### 输出

```
5```

# 题解

## 作者：mcturtle (赞：6)

## 思路
一道分讨。

由于他自己也要一份，将 $n \gets n+1$。

其次分类讨论。

当 $n$ 是 $1$ 时，不用切，输出 $0$。

如果是偶数，因为每一刀可以直接穿过整个披萨，输出 $\frac{n}{2}$。

如果是奇数，因为每一刀只能切一半，输出 $n$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long n;
    cin >> n;
    n++;
    if (n == 1)
    {
        cout << 0;
        return 0;
    }
    if (n % 2 == 0)
        n /= 2;
    cout << n;
}
```

---

## 作者：如履薄冰 (赞：5)

# 解法
一道简单的思维题，经过推导便可以得出结论：如果 $n + 1  = 1$，那么我们根本不用分，直接输出 $0$。如果 $n + 1$ 是奇数，那么我们至少切 $n + 1$ 刀，因为每一刀只能切半个披萨。如果直接切一个披萨，那么就不能满足大小和形状一样这个条件了。如果 $n + 1$ 是偶数，那么我们至少切 $n \div 2$ 刀，因为一刀可以切整个披萨。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
long long n; 
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	n++;
    if(n==1){
        cout<<0;
        return 0;
    }
	if(n%2==1){
		cout<<n;
	}else{
		cout<<n/2;
	}
	return 0;
}
```

---

## 作者：hezhiran (赞：4)

## 题意
给定一个 $n$，求出将一块披萨分成 $n + 1$ 块且每块大小和形状一模一样所需最少的刀数。

## 思路
观察样例，我们可以发现：当 $n + 1$ 为偶数的时候，我们会有两刀重合为一刀，并且答案为 $\frac{n + 1}{2}$ ，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/j71km999.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

接着，我们来看，当 $n + 1$ 为奇数时，没有两刀能重合为一刀，并且答案为 $n+1$，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6u8us2.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**提醒：注意看数据范围，要开`long long`**

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	n++;
	if(n==1) cout<<0;
	else if(n%2==0) cout<<n/2;
	else cout<<n;
	return 0;
}

```

---

## 作者：dg114514 (赞：4)

简单的分讨题。

> 方便起见，设 $m=n+1$，即切成的块数。

可以发现：

- 当 $m$ 是奇数时：每一刀只能切半个，所以答案为 $m$。
- 当 $m$ 是偶数时：每一刀能直接穿过整个披萨，由于一刀可以分两份，所以答案为 $m\div2$。
- 当 $m=1$ 时：由于就 $1$ 块，不用切。所以答案为 $0$。

---

## 作者：Sliarae (赞：4)

首先将 $n \gets n + 1$，这样相当于将一块披萨平分为 $n$ 份。

注意到 $n$ 块披萨的形状要相同，这说明切完所有刀后整块披萨的形状是确定的。具体而言是一个圆被分成 $n$ 个扇形，每个扇形的圆心角都是 $\frac{2\pi}{n}$。而最小的切刀数就是这个圆中的线段数。

比如对于本题的样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/t4zyesya.png)

对于第一个样例，线段数是 $2$（一条水平的，一条竖直的）。对于第二个样例，线段数是 $5$。这正好与样例输出对应。

接下来可以分类讨论计算线段数：

- $n = 1$，此时一条线段也没有，输出 $0$。

- $n$ 为大于 $1$ 的奇数，这时没有两条线段会连在一起，所以输出 $n$。

- $n$ 为偶数，此时容易发现线段会两两配对，所以输出 $\frac{n}{2}$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	LL n;
	cin >> n, ++n;
	cout << (n & 1 ? n - (n == 1) : (n >> 1)) << '\n';
	return 0; 
}
```

---

## 作者：LINYUHENG2 (赞：3)

[题目传送门。](https://www.luogu.com.cn/problem/B4190)

这道题需要分情况讨论。

第一种情况：$n+1$ 为偶数。  
那么，就可以沿着直径切，因为一刀可以切出 $2$ 块，所以，需要 $\frac{n+1}{2}$ 刀。

第二种情况：$n+1$ 为奇数。  
那么，将圆周 $(n+1)$ 等分，由等分点向直径切即可，需要 $n+1$ 刀。

好了，现在我们得到：
$$
\text{刀数} =
\begin{cases}
\frac{n + 1}{2} , (n + 1) \bmod 2 = 0 \\
 n + 1 , ( n + 1 ) \bmod 2 = 1
\end{cases}
$$
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    long long n;
    scanf("%lld",&n);
    n+=1;
    if(n%2==0){
    	printf("%lld",n/2);
	}else{
		printf("%lld",n);
	}
    return 0;
}
```
交上去，[90 分](https://www.luogu.com.cn/record/205765195)。

为什么呢？因为我们没有考虑 $n=0$ 的情况，这时，$n + 1 = 1$，不用切。

于是，得到：
$$
\text{刀数} =
\begin{cases}
\frac{n + 1}{2} , (n + 1) \bmod 2 = 0 \\
 n + 1 , ( n + 1 ) \bmod 2 = 1 \\
0 , n = 0
\end{cases}
$$
代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    long long n;
    scanf("%lld",&n);
    n+=1;
    if(n==1){
    	printf("0");
    	return 0;
	}
    if(n%2==0){
    	printf("%lld",n/2);
	}else{
		printf("%lld",n);
	}
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/205765443)

---

## 作者：TiAmo_qwq (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4190)


---

## 思路
题目说要把披萨分成 $n+1$ 份，一共需要几刀。


---


我们发现：当 $n + 1$ 是偶数时（也就是 $n$ 是奇数），一刀切两份，正好切 $(n+1) \div 2$ 次，就可以切成 $n + 1$ 份。 

举个栗子，$n=3$，要切成4份，横切一刀竖切一刀即可切成 $4$ 份。


---
当 $n + 1$ 为奇数时（也就是 $n$ 为偶数），每一刀只能切半个，所以说答案为 $m$。


---

提交之后错了，看了一下数据，发现 $ 0 \le n \le 10^ {18}$，若 $n=0$，则说明要切成 $1$ 份，不用切，答案为 $0$。



---

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define rep(i, a, b) for(int i = (a); i <= (b); i++)
#define pre(i, a, b) for(int i = (a); i >= (b); i--)

const int N = 1e6 + 10;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	
	int n;
	cin >> n;
	if(n == 0){
		cout << 0;
		return 0;
	} 
	if(n % 2 == 0){
		cout << n + 1;
	}
	else{
		cout << (n + 1) / 2;
	}
	return 0;
}

```

注意：数据要开长整型。

---


# 禽兽的传染病

## 题目背景

mxj 的启发。


## 题目描述

禽兽患传染病了。一个禽兽会每轮传染 $x$ 个禽兽。试问 $n$ 轮传染后有多少禽兽被传染？


## 说明/提示

保证 $x,n$ 以及答案都在 $64$ 位无符号整数的表示范围内。

## 样例 #1

### 输入

```
10 2```

### 输出

```
121```

# 题解

## 作者：BlueArc (赞：173)

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
 long long x,n,sum=1,i;//long long定义大点
 cin>>x>>n;
 for(i=0;i<n;i++)
  {
   sum=sum+sum*x;//这里是关键,一轮后感染总数为原来总数+新感染的总数                             
  }   
 cout<<sum;   
 return 0;   
}
```

---

## 作者：xsun2001 (赞：64)

初中数学。。。

注意用long long欧。

（应该是）最短写法：

```cpp
#include<iostream>
using namespace std;
int x,n;
long long t=1;
int main(){
    cin >> x >> n;
    for(int i = 0;i<n;t=t+t*x,i++);
    cout << t;
}
```

---

## 作者：Ajwallet (赞：53)

首先分析题目，每次感染x个禽兽，那么肯定和x的次方有关系，n轮就是n次。

至于+1的原因是因为一开始只有一个禽兽，所以要+1，就可以得到

$$Ans=(x+1)^n$$
----------

对于x的y次方，可以用到快速幂来进行快速求解

快速幂，是一种快速求出x的y次方的方法，其时间复杂度为 O(log₂N)**比pow快**。

而且在费马小定理中也有用到快速幂的，不知道的请自行度娘。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,n;
long long ksm(long long x,long long y)//求x的y次方
{
	long long ans=1;//初始为1
	while(y)
	{
		if(y&1) ans*=x;
		x*=x;
		y>>=1;//快速幂模板
	}
	return ans;//返回
}
int main()
{
	scanf("%lld%lld",&x,&n);//输入
	printf("%lld",ksm(x+1,n));//输出
}
```

---

## 作者：zhenglier (赞：15)

最近学了下python，于是就用Python刷~~水题~~难题，关于内容，代码里写的很清楚了。

```
#   #在python里是注释。
a,b=input().split(); #输入，split()函数可以获得两个用空格分开的字符串并赋值给a,b。
a=int(a);#把a,b定义为int。
b=int(b);
print((a+1)**b);#直接输出a+1的b次方就行了（非常简单的数学题，不会的话可以看看别的题解）。
```

---

## 作者：willbe233 (赞：13)

# 这道题嘛……
~~是一道无可否认的递推水题，~~只需使用递归公式t:=t+t*x;
另外要注意的是如果使用for循环，那么除循环变量外其他变量都最好设成qword（虽然题目好像并没有让所有变量都那么大）
## 分析完题目后，放一下核心代码：
```pascal
		t:=1;//注意，这步必不可少
        for i:=1 to n do
        Begin
                t:=t+t*x;//套入递归公式
        end;

```

# 最后，放下源代码：
```pascal
Var i:longint;
    n,x,t:qword;
Begin
        read(x,n);
        t:=1;
        for i:=1 to n do
        Begin
                t:=t+t*x;
        end;
        
        write(t);
end.
```

---

## 作者：亿年已过 (赞：12)

**蒟蒻的第八篇题解qwq**

**（ans是患传染病的禽兽数，x是每轮传染x个禽兽，n是一共的轮数）**

很多人可能会这样想（比如本蒟蒻）：一开始只有一只患传染病的禽兽，一共有n轮，每轮传染x个，那么就是这样做：
```
for(int i=0;i<n;i++)
{
    ans+=x;
}

```

### 可是，真的是这样做吗？

## 不是

我们先假设x=2，n=3。

那么第一次运行是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/qo73m7h3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这时，ans=3。

第二次运行：



![](https://cdn.luogu.com.cn/upload/image_hosting/di4s5vna.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么，ans=9

**根据上面的图可以得出：**

$$\texttt{ans+=ans*x}$$

那这就是这道题的核心：

```
for(int i=0;i<n;i++)	//循环
{
	ans+=ans*x;//上面的规律
}
```


本蒟蒻的代码：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long x,n,ans=1;//不开long long只有30分
int main()	//主程序
{
cin>>x>>n;//输入
for(int i=0;i<n;i++)	//循环
{
	ans+=ans*x;//上面的规律
}	
	cout<<ans;//输出
	
	return 0;//结束
}
```


---

## 作者：Talanton_Cerydra (赞：10)

### 呃，这题简单的不能再说了

不过还是有小问题要注意（只有OI萌新看就好了）：

首先说一下：**qword是什么意思？**

qword是Pascal中的东西，在c++中指0到2^64-1

**所以这题开unsigned long long就好了**（看题解求助是不是你没加unsigned？）

## OK，不瞎扯了，下面是超超超短的代码：

```cpp
#include <bits/stdc++.h>//习惯万能头
using namespace std;
unsigned long long int x,n,ans=1;//要用unsigned long long，并且ans要等于1，因为后面全是乘法运算
int main()//主函数
{
    scanf("%lld%lld",&x,&n);//读入，注意long long要用%lld，用%d会错或者警告
    for(unsigned long long int i=1;i<=n;i++)//for循环，习惯所以变量统一一致，避免警告
    {
        ans=ans*(x+1);//注意是x+1，不是x，因为每只禽兽传染了x个，还有自己1个
    }
    printf("%lld",ans);//打印
    return 0;//end……
}
```

相信你们都能过的！

---

## 作者：地铁dixiatielu (赞：6)

#### 本蒟蒻的第三篇题解..其实第一篇没审过..第二篇交不上去，于是这也能算是第一篇吧


下面是正文emm
------------
此题的核心其实就是个递推 每只禽兽每轮能传染$x$只，被传染后的禽兽又会继续传染其他禽兽，因此我们循环每一轮，以$now$作为当前被传染禽兽的数量。因此，经过每一轮传染后，被传染的禽兽数量就是当前被传染的禽兽数量$(now)$加上新被传染的禽兽数量 $(now * x)$ 所以说每轮结束后，被传染的禽兽数量就是$now * x + now$了

题目中说的范围在qword范围内，蒟蒻的我不知道什么意思...于是就开了个unsigned long long...实际上应该开long long就能过了叭
## 附上代码
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;//不加CE
typedef unsigned long long ull;
ull now = 1,x,n;
int main()
{
    scanf("%llu%llu",&x,&n);//顺便普及一下unsigned long long 用%llu可以读入
    while(n--)
    {
        now = now * x + now;//核心递推
    }
    printf("%llu",now);//输出
    return 0;
}

```


---

## 作者：5ab_juruo (赞：6)

这道题只要掌握递推公式，即可获得通项公式。
首先，根据题意，列出数量关系式为 新总病禽=原病禽+感染病禽，转化为数学算式即为a[n]=a[n-1]+xa[n-1]。进行一番并不复杂的推导可以得到a[n]=(x+1)a[n-1]。又因为a[0]=1，可以得到通项公式a[n]=(x+1)^n。有了这个就可以~~撕逼~~编程啦~~

------------

因为有通项公式，所以我们直接带进去：
```cpp
int x,n;
cin>>x>>n;
long long ans=pow(x+1,n);
```
加上输出，整个程序就会变得非常简洁和优美：
```cpp
#include<iostream>
#include<cmath>
using namespace std;

int main()
{
	int x,n;
	cin>>x>>n;
	long long ans=pow(x+1,n);
	cout<<ans<<endl;
	return 0;
}

```
总结一下：
1.对于这种通项公式并不复杂的程序来说，直接带入是最省时、最方便的办法。
2.对于这些可能需要递推的数列，可以进行推导。如果能算出通项，那是最好的。

---

## 作者：JimmyF (赞：5)

   
好像没有人写递归的代码，赶紧来发一篇。

首先，题目说一个禽兽会每轮传染x个禽兽，所以得出递归关系式：ans+=ans*x。

下面献上主程序最短代码~~
   
    #include<bits/stdc++.h> //万能文件头(洛谷福利)
    #define ll long long   //宏定义，将ll定义为long long
    using namespace std;
    ll x,n;    //定义传染数量x和传染轮数n
    void work(ll ans,ll k)    //两个参数分别表示当前传染总数ans和当前剩余传染轮数
    {
        if(!k){cout<<ans;exit(0);}   //如果传染完n轮就输出传染总数ans，并停止递归（exit(0)）
        work(ans+ans*n,k-1);  //每次加上这一轮传染的数量，并将轮数-1，继续递归
    }  //递归
    int main()
    {
        cin>>x>>n;   //输入传染数量x和传染轮数n
        work(1,n);   //调用递归函数，第一个参数表示第0轮有1个禽兽被传染，第二个参数表示一共传染n轮
        return 0;	
    } 
    

---

## 作者：NishikinoMaki (赞：4)

##学人教版数学的初三狗（包括我）都知道这个题（滑稽），就是tot=A\*(a+1)^n;(这里A=1，a=x)；

```cpp
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
int n,x;//字头
int main(){
    cin>>x>>n;//输入；
    x++;//加上它本身；
    unsigned long long tot=1;//用int只能得40分，所以tot用long long；
    for(int i=1;i<=n;i++)
        tot*=x;//x的n次方；后来才想起有pow函数；
    cout<<tot;//输出即可；
    return 0;
}//以上
```

---

## 作者：「QQ红包」 (赞：4)

这道题用模拟。

当前禽兽数为x人，一轮感染中，将被感染的人数为（（禽兽个数）\*（每个禽兽能感染的禽兽数）），记得加上原本有的禽兽个数。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
long long n,x=1,e,sum=0,i;//long long防炸  x为只数，初始值为1 
using namespace std;
int main()
{
    cin>>e>>n;//读入
    for (i=1;i<=n;i++)//模拟n轮传染
         x+=e*x;//原有的几只加上被感染的n*x只；
    cout<<x; //输出 
    return 0;
}

```

---

## 作者：万弘 (赞：4)

`设f[i]为第i次传染后的受感染数，`则有

$$f[i]=f[i-1]+f[i-1]*x$$
当前=(原本+新增)

瞥一眼难度，是入门题，于是直接这样搞搞就行，时间复杂度$O(n)$

```cpp
#include<cstdio>
typedef long long ll;
#define maxn 1000001
ll f[maxn],n,x;
int main()
{
	scanf("%lld%lld",&x,&n);
    f[0]=1;//边界
    for(ll i=1;i<=n;++i)
    	f[i]=f[i-1]+f[i-1]*x;
    printf("%lld",f[n]);
    return 0;
}
```

那如果~~出题人比较厉害~~n比较大，$1<=n<=10^{18}$,求对1e8+7取模的结果

我们再观察原式$$f[i]=f[i-1]+f[i-1]*x$$
也就是
$$f[i]=(x+1)*f[i-1]$$

不难发现这是个一般递推式

PS：这个概念是我口胡的，指形如
$$f(i)=a_1*f(i-k_1)+a_2*f(i-k_2)+...+a_p*f(i-k_p)+c$$
的递推式（$a_i$为任意整数，$1<=k_i<=i,c$为常数）

**说人话：递推式的每一项的值要么为指明的常数（边界），要么由之前的项和指明的常数相加得到且与i无关**

于是，我们就可以通过[矩阵快速幂](https://www.luogu.org/blog/73142/ju-zhen-kuai-su-mi)把时间复杂度降至$O(logn)$

然而，我们再仔细观察一下，其实$f(i)=(x+1)^i$,直接普通快速幂就行，复杂度仍是$O(logn)$
```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
#define INF (1ll<<58)
ll read()
{
	char c;ll f=1,x=0;
	do
	{
		c=getchar();
		if(c=='-')f=-1;
	}while(c<'0'||c>'9');
	do
	{
		x=x*10+c-'0';
		c=getchar();
	}while(c>='0'&&c<='9');
	return f*x;
}
void write(ll x)
{
	if(x==0){putchar('0');return;}
	if(x<0){putchar('-');x=-x;}
	ll s[21],top=0;
	while(x)
	{
		s[++top]=x%10;
		x/=10;
	}
	for(ll i=top;i>=1;--i)putchar(s[i]+'0');
	putchar(' ');
}

#define mod (ll(1e8)+7)
ll qpow(ll a,ll n)
{
	ll res=1;
	while(n)
	{
		if(n&1)res=(res*a)%mod;
		a=(a*a)%mod;
		n>>=1;
	}
	return res;
}
int main()
{
	ll x=read(),n=read();
	write(qpow(x+1,n));
	return 0;
}
还有疑问私信我
```

---

## 作者：封禁用户 (赞：4)

~~这道题是一道大水题~~
我本来是这么写的
```
for(int i=0;i<n;i++){
		s=s*x;
	}
```
或者是这个亚子：
```
for(int i=0;i<n;i++){
		s+=x;
	}
```
其实是不对的，我们看“一个禽兽会每轮传染x个禽兽”
就可以推出公式：现有的禽兽+现有的禽兽*每轮传染的禽兽。
注：必须用longlong，不然会WA。

不多bb上代码：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;//名字空间
long long x,n,s=1;
int main(){
	cin>>x>>n;//输入
	for(int i=0;i<n;i++){//开始计算
		s+=s*x;//规律
	}
	cout<<s;//输出
	return 0;//跟程序说：“拜拜！”。
}
```


---

## 作者：三华生 (赞：4)

【讲解】

一道简单的题目，设初始值为1，可得出式子：

被传染的禽兽数:=被传染的禽兽数+被传染的禽兽数\*x，也就是s:=s+s\*x.

【源程序】

```cpp
var
s:qword;
n,x,i:longint;
begin
read(x,n);
s:=1;
for i:=1 to n do
s:=s+s*x;
write(s);
end.
```

---

## 作者：panjidongc (赞：3)

套公式：ans+=ans\*x

注意要用long long，否则40分

输入输出用cin、cout和scanf、printf都行，不过用scanf、printf要注意是%I64d


参考代码：



```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    long long x,n;     //注意一定要用long long，否则40分
    long long i;
    long long ans=1;     //注意ans初始值为1
    cin>>x>>n;     //也可用scanf("%I64d%I64d",&x,&n);
    for(i=1;i<=n;i++)
        ans+=ans*x;     //所谓的套公式
    cout<<ans;     //也可用printf("%I64d",ans);
    return 0;
}

```

---

## 作者：darkfire3133 (赞：3)


轻松推出公式

```cpp

/*For the Alliance!!!*/
#include<iostream>
using namespace std;
int main()
{
    long long ans=1;
    int x,n;
    cin>>x>>n;
    for(int i=1;i<=n;i++)
        ans+=ans*x;
    cout<<ans<<endl;
    return 0;
}

ans+=ans*x

```

---

## 作者：Songnj_office (赞：3)

这题水的不行了，但是不能用int，不然会爆掉.......

然后

1，将最终和先附值为1，然后第N轮感染数目=上一轮数目+上一轮数目*可以感染个数。也就是：

```cpp
#include<bits/stdc++.h> 
using namespace std;
int main(){
    long long n,x,ans=1;
    cin>>x>>n;
    for(int i=1;i<=n;i++) ans+=ans*x;//重复的进行更新
    cout<<ans;
    return 0;
}
```
2，既然第N轮感染数目=上一轮数目+上一轮数目*可以感染个数，那根据
乘法分配律 第N轮感染数目=上一轮数目*（可以感染个数+1）所以有了：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int main(){
    long long n,x,ans=1;
    cin>>x>>n;
    x++;
    for(int i=1;i<=n;i++){
        ans*=x;
    }
    cout<<ans;
    return 0;
}
```
两个方法都能AC这道题



---

## 作者：jerrywcy (赞：3)


```cpp
#include <cstdio>
int main()
{
    int x/*一个禽兽会传染x个禽兽*/,n/*传染n轮*/;
    unsigned long long a;//被传染禽兽的个数
    scanf("%d%d",&x,&n);
    a=1;//一开始有一个禽兽被传染
    for (int i=1;i<=n;i++)
        a+=a*x;//每轮每个禽兽传染x个禽兽，共传染a*x个
    printf("%llu",a);
    return 0;
}
```

---

## 作者：USS_Enterprise (赞：2)

好，先梳理一下题意：

一开始，一只禽兽得了传染病，然后，每过一轮，每只禽兽又传染x只禽兽（这传染病也够规则了……），如此循环往复，直到第n轮，求出一共多少只禽兽得病。

```c
#include <iostream>
using namespace std;
int main()
{
	long long x,n,ans=1;//必须要用long long（血的教训告诉我们必须用这个）
	cin>>x>>n;//输入每轮传染的禽兽数量和过了几轮
	for(int i=1;i<=n;i++)//循环1到n轮
	{
		ans+=ans*x;//每次加已经传染禽兽数量乘上每轮传染数
	}
	cout<<ans;//输出被传染的禽兽数量
    return 0;
}
```


---

## 作者：未来miss (赞：2)

看到了那些大犇们写的代码，我真是***~~不适~~***。  
-----------------------
我一个小蒟蒻早已***~~瑟瑟发抖~~***。   
------------
于是我就成功的写下了***~~效率低，废话多，内存大~~***的题解。
------
**哇噻 (o゜▽゜)o☆~~，妈妈再也不用担心我无法水题目了**   


------------

开始讲课
----
这一题的标签是入门难度，我觉得很对。毕竟是一道大水题。  

循环什么的我最喜欢了，我尤其喜欢for语句。        

有一个要注意的点是一开始就有一只禽兽患上了传染病。    

而每个禽兽，在每轮都会被传染。   

假设有n只禽兽，那么一次操作就会带来n*每个禽兽会传染的只数。   

~~（不得不佩服作者的想象力！！）~~  

还有，数据范围  
![](https://cdn.luogu.com.cn/upload/pic/47859.png )      


------------

既然思路捋顺了  
---
那么
---
上代码！！！
----
-----
```pascal
var a,b,c,n,m:qword;//注意，这位好心的小哥已经给我们提示了，见上。
i,j:longint;
begin
read(a,b);//输入
c:=1;//初始化
n:=1;//初始化
for i:=1 to b do//开始做无聊的循环
begin
n:=c*a;//我们推出的童话结局（方程）
c:=c+n;//累加
end;
write(c);//输出
end.
```
----
一个来自P党的渣渣，希望通过！！！也祝大家AC。
----

---

## 作者：Timothy (赞：2)

这是一道简单的递推题：

```cpp
#include<iostream>   
using namespace std;   
long long sum=1,n,x;   
int main ()   
{   
    scanf ("%d%d",&x,&n);   //输入x和n
    for (int b=1;b<=n;++b)sum+=sum*x;   //进行递推
    printf ("%I64d",sum);   //输出要用“I64”（切记！！！）
    return 0;   
}  

```

---

## 作者：莫宏骏 (赞：2)

```cpp
//so easy 啊
#include<stdio.h>
#include<string.h>
int main()
{
//freopen(".in","r",stdin);
//freopen(".out","w",stdout);
    int x,n,i;
    long long int s=1;//定义大点，怕爆
    scanf("%d%d",&x,&n);//输入x，n
    for(i=1;i<=n;i++)//循环出结果
    {
        s=s*(x+1);//计数
    }
    printf("%lld",s);//输出
//fclose(stdin);
//fclose(stdout);
    return 0;
}

```

---

## 作者：1jia1 (赞：1)

题目十分简单，是数学题“打电话”的翻版，很适合新手练代码哦。

核心思路：每一轮感染的禽兽的数量是原本禽兽的数量\*每个禽兽能传染的数量，再加上原来的就行了。为了方便，直接用原本感染禽兽的数量\*（1+每个禽兽能传染的数量）。虽然不知道有什么卵用。

```cpp
-#include <iostream>-
-using namespace std;-
-long long n,x,s=1;---设置变量，因为我不知道qword是多大，所以开了long long
-int main()-
-{-
-    cin>>x>>n;-
-    for(long long i=1;i<=n;i++)s*=(x+1);---乘啊乘
-    cout<<s;-
-    return 0;-
-}-
```

---

## 作者：桀骜 (赞：1)

## 首先，我们来分析一下题目：

#### ~~通过手动模拟可以得到~~

第零轮———————— 1

第一轮———————— x+1

第二轮———————— (x+1)*x+(x+1)

第三轮———————— [(x+1)*x+(x+1)]*x+(x+1)*x+(x+1)

### 以此类推
设f(x)为x轮后被传染的禽兽的数量

可以发现：f(x)=f(x-1)*x+f(x-1)=f(x-1)*(x+1)

### 即:当前被感染的数量=新感染的数量+原来被感染的数量

#### 所以可以用递推————————————————————————————
## 上核心代码：
```
for(int i=1;i<=n;i++){
        ans=ans*(x+1);
    }
```


------------
## 所以，完整程序是
```
#include <bits/stdc++.h>
using namespace std;

long long x,n,ans;//ans用来存放第n次之后的答案 

int main(){
	cin >> x >> n;//读入 
	for(int i=1;i<=n;i++){
        ans=ans*(x+1);// 当前被感染的数量=新感染的数量+原来被感染的数量
    }
    cout << ans << endl;//输出
    return 0;
}
```


------------
## 再来一遍没有注释的
```
#include <bits/stdc++.h>
using namespace std;

long long x,n,ans;

int main(){
	cin >> x >> n;
	for(int i=1;i<=n;i++){
        ans=ans*(x+1);
    }
    cout << ans << endl;
    return 0;
}
```



------------




---

## 作者：Mr_WA的大大号 (赞：1)

这一题是一道简单模拟题，要求被感染的禽兽的数量。
首先，有一个禽兽患病每次感染10只
|天数  | 0 | 1 | 2 | 3 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| **被感染数量** | 1 | 11 | 121 | 1331 |
我们发现从第一天开始，感染数量=被感染+原来就感染的。
### 我们得出一条算式：g=gx+g
用乘法分配律得出原式=g=g*（x+1）；
### 在这里提醒大家一句：
# 记得加long long
### 这是我第一次wa的原因yoy
#### 题目和思路解释完毕，本蒟蒻献上代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long g=1;//定义用long long
int main()
{
	long long x,n;//定义用long long
	cin>>x>>n;
	for(int i=1; i<=n; i++)
	g=g*(x+1);//推出的公式
	cout<<g;
	return 0;
}
```
**谢谢观赏**


---

## 作者：天命 (赞：1)

## **我刚开始天真地以为int能够过，然后wa的一声哭了出来。**
## 正文：
## 
三十分的：
```cpp
#include<bits/stdc++.h>
#define MAXX (9999)
using namespace std;
int main(){
//	freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
    int i,j,n,x,qsgrzs=1;//qsgrzs=禽兽感染总数 
    cin>>x>>n;
    for(i=0;i<n;i++){
        qsgrzs+=qsgrzs*x;
    }
    cout<<qsgrzs;
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```
于是我认为泥古欺骗了我的感情（很生气），以为要写高精度（~~认为这不是水题~~）。但又不想写高精度，于是我拿出了这个[这里这里](https://www.luogu.org/blog/tmxkt/wei-wan-shan-dai-ma)

AC的：
```cpp
#include<bits/stdc++.h>
#define MAXX (9999)
unsigned long long b=99999999999999999999999999;
using namespace std;
int main(){
//	freopen(".in","r",stdin);
	//qsgrzs=禽兽感染总数 
//  freopen(".out","w",stdout);
    int i,j,n,x;
    long long* qsgrzs=new long long(b);
    *qsgrzs=1;
    cin>>x>>n;
    for(i=0;i<n;i++){
        *qsgrzs+=*qsgrzs*x;
    }
    cout<<*qsgrzs;
    fclose(stdin);
    fclose(stdout);
    return 0;
}

```

#### b设多大没影响，思路就是第i轮时，禽兽感染总数=前i-1轮的+前i-1轮的*x。这个都能理解，很简单的吧。
————————————————————————
#### 关于b与qsgrzs这个就比较~~高逼了~~。就是b是可以控制qsgrzs的长度上限，但不超过总量。但其实这个做法还是有可取之处的，有点题目可能要用到这个，多学总是好的。就是差点写了高精度，万幸万幸！
————————————————————————
###### （~我觉得应该没人跟我用同一种qsgrzs~）（~~小声bb~~）

---

## 作者：_jimmywang_ (赞：1)

#### 第一次看到题目的我，很怕传染病会传染到我们身上（吓~~习~~死我了~~）
### 上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long i,x,n,ans=1;
	cin>>x>>n;
	for(i=1;i<=n;i++)ans*=(x+1);
	cout<<ans;
	return 0;
}

```
因为数据很大，我们亲爱的系统接受不了int的渺小。于是乎用了long long。

#### 这里可能会有xiao傻傻分不清的人把ans定义成0，你最后输出全是0别怪我没提醒你。

读入x和n，表示每轮会传染x只禽兽，有n轮。

循环一遍 ~~ 每次乘上x+1.注意，是x+1!

### 不然你以为传染的罪魁祸首传染完就自愈了？？

（~~要不然呢？~~）pia!pia!(打脸声)

乘完了就输出，~~四巴四~~是不是特别简（kun）单(nan)呢？

---

## 作者：跪下叫哥 (赞：1)

# 这题是典型的long long和循环知识聚总的题
#### 如果不会打循环的话，[请点这里](https://share.weiyun.com/5OvJHOh)

$\because$每次感染x个禽兽;

$\therefore$肯定和x的次方有关系，n轮就是n次;

$\because$一开始只有一个禽兽;

$\therefore$所以要+1，就可以得到：
###           ans=$(x+1)^{n}$

得了，上代码:

```c++
#include<iostream>
using namespace std;
int x,n;
long long ans=1;//个人喜欢将最后输出的数命名为ans，此题最好开long long
int main(){
    cin>>x>>n;
    for(int i = 1;i<=n;i++) ans=ans+ans*x;//上面公式的变形
    cout<<ans;//输出结果
    return 0;//完美结束！
}

```


---

## 作者：Stephanie_Bunny (赞：1)

#### 啦啦啦，本兔终于学会发题解了呢  
##### 先找道简单 ~~我还是想了很久~~ 的题吧~~  
##### 其实挺easy，小学奥数就学过类似分裂呀什么的题。
### 但是注意：这不是分裂，是传染呀，原来的也得加上呢……  
#####  总之，先看代码吧

------------

```cpp
#include <iostream>

using namespace std;

int main()
{
	int n,x;
	cin>>x>>n;
	int ans=1;
	int i;
	for(i=1;i<=n;i++)//传染开始
	{
		ans+=ans*x;
	 } 
	 cout<<ans;
	return 0;//完美的结尾
}

```

------------
#### 好啦，这道题不难，童鞋们加油噢
### 祝大家早日AC，Rp++~

---

## 作者：1878851245xly (赞：1)

看c++太不爽了（题解满天飞），用了pascal专有的函数（应该是的吧）

```cpp
    var x,n:int64;//为了防止题有坑，用了int64 
    begin 
     read(x,n); 
     write(round(power(x+1,n)));//power函数比一般的循环快，用的是自然对数求指数，调用math库可用 
end.
```

---

## 作者：谢宇翔最帅 (赞：1)

记住！！！！！！

一定是long long!!!!!!!

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main ()
{
    int n,m;
    long long s=1;
    cin>>n>>m;
    for(int i=0;i<m;i++)
    {
        s=s*(n+1);
    }
    cout<<s;
    return 0;
}
```

---

## 作者：cenbinbin (赞：1)

用一个pascal的函数，power（N,M）表示m的n次方

所以此题就很短咯。。。

=======================================================================

```cpp
uses math;//开数学库
var
  n,m:qword;//注意开qword
begin
  readln(n,m);//读入
  inc(n);//禽兽数也包括自己
  writeln(power(n,m):0:0);//输出，注意是实x型，应：0：0
end.
哈哈哈呵呵呵
```

---

## 作者：Xsy123456 (赞：1)

###直接用数学方法就可以了

代码如下

```cpp
#include <cstdio>
#include <cmath>
using namespace std;

double m,n;

int main(){
    
    scanf ("%lf%lf",&m,&n);
    
    printf ("%.0lf",pow(m+1,n));//传染数=(m+1)^n
    
    return 0;
    
}

---

## 作者：Enzymii (赞：0)

在座的各位都说的很清楚了，大家也应该都能推出这个ans=(a+1)^b吧~

其实这个题没有必要，但是我想在这里贴一个快速幂呢~

由于在比赛中，累乘太慢，pow又有很多缺陷，所以就少不了快速幂，

快速幂可以把O(b)的复杂度降到O(logb)的，然而

###快速幂一般是和取模配合食用的，嘿嘿

但这个题确认了在long long以内，话说出题人用了个qword是不是吓到学C的小盆友们了~

好吧不扯了上代码【快速幂的思路大家可以自己搜索到，我就不多讲了】

```cpp
#include <cstdio>
int main()
{
    int a,b;scanf("%d%d",&a,&b);
    long long ans=1,t=a+1;                  //其实基本是个板子了
    for(;b;b>>=1,t*=t)                          
 //把b拆成二进制一位一位的搞，t每次自乘表示a(这里的a+1)的2^当前位次方
        if(b&1)                                    
 //如果这一位是1就要乘到ans上，要取模就取模
            ans=ans*t;
    printf("%lld",ans);//输出结果搞定
}
```

---

## 作者：YczSS (赞：0)

Pascal专业解题80年

```cpp
var
  s:qword;
  n,x,i:longint;
begin
  readln(x,n);                             //输入
  s:=1;                                    //刚开始有1只禽兽
  for i:=1 to n do
    s:=s*(x+1);                            //s:=s+s*x的简写
  writeln(s);                              //输出
end.
```

---

## 作者：小郭本人 (赞：0)

###  emm...这是本**蒟蒻**第一次发题解..好激动~~
emm..解释都在代码注释部分里了 #### ~~**原谅我语言表达不清**~~
```cpp
#include<bits/stdc++.h>//丢出一个万能头文件
using namespace std;
int n,m;//定义整形变量n，m 
long long s=1;//直觉告诉我应该用long long，格式跟int一样 
int main()
{
	cin>>m>>n;//输入m，n 
	for(int i=1;i<=n;i++)//开始一个for循环 
	s*=(m+1);//乱七八糟胡乱乘QAQ 
	cout<<s;//输出s的值 
	return 0;//愉快的结束程序QAQ 
 } 
```
emm..其实刚开始做时，我是很蒙的（毕竟现在刚入C++啊。。）后来发现还~~蛮简单的~~，哈哈

## 大家加油呀  祝你们AC~~[光速逃]


---


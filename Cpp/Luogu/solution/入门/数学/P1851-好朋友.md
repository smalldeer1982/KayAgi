# 好朋友

## 题目背景

小可可和所有其他同学的手腕上都戴有一个射频识别序列号码牌，这样老师就可以方便的计算出他们的人数。很多同学都有一个“好朋友” 。如果 $A$ 的序列号的约数之和恰好等于 $B$ 的序列号，那么 $A$ 的好朋友就是 $B$。在这里，一个数的约数不包括这个数本身。因为一些同学的号码约数和大于其他任何同学的号码，所以这些同学没有好朋友。一些同学有一个“非常好友” 。当两个同学互为“好朋友”时，他们就是一对“非常好友” 。注意在这道题中，忽略那些自己是自己的“非常好友”的情况。

## 题目描述

给定一个序列号 $s$，找出序列号不小于 $s$ 的第一对“非常好友” 。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $6\le s\le1.8\times10^4$。

## 样例 #1

### 输入

```
206
```

### 输出

```
220 284```

# 题解

## 作者：zhaowangji (赞：446)

**你将会看到**
1. ## 打表对吗？
1. ## 本题的打表代码
1. ## 如何打表
1. ## AC代码


#### 打表对吗？

打表，是一种正常的解题方法，跟暴力、模拟、贪心、动规、搜索······并无二异，既然不会其他写法，或者是其他写法太烦，那么——**打表**是我们光荣的选择（虽然用的不太多）

	打表，指将题目中所要求的值自行算出，存到数组中，
    输入后经过判断直接输出数组中的值，时间复杂度为O(1)。 
    方便快捷而又简单高效，是OI中的不二之选。                  
								
                                ——frank·chee（沃兹·基朔德）



#### 打表代码：
```cpp
#include<iostream>
using namespace std;
int s,a[100007];//这里取的10 0000，可以取更大
//但即使对于打表来说，时间也够长的了
int main()
{
	for(int i=1;i<=100000;i++)
	{
		for(int j=1;j<=i;j++)
		if(i%j==0)//判断j是i的余数
		if(i!=j)//由题可得（仿佛是道数学题），约数没有本身
		a[i]+=j;//其约数和加上j
	}
	for(int i=1;i<=100000;i++)
	for(int j=1;j<=100000;j++)//双重循环判断
	if(a[i]==j&&a[j]==i&&i>=6&&i>j&&j>=6)cout<<i<<' '<<j<<endl;
    	//i的约数和等于j，j的约数和等于i，两者都大于6
        //这里为了方便起见是i大于j
	return 0;
}
```
#### 如何打表：




耐心等待······后
你会看见这个



![](https://cdn.luogu.com.cn/upload/pic/59976.png)

这就是10 0000 以内所有的满足条件的数了

然后把代码删掉，开两个数组，分别存前一列和后一列

输入，判断，输出，就行了！


另：关于打表的用时

配置：Intel(R) Celeron(R) 2957u @ 1.40GHz 1.40GHz

RAM(没加装其他的)：4.00GB

系统类型：64位

本人测试，跑完用时97.485s，有图为证。而且运行时我还在耗资源，所以按照当今主流电脑，(i3及以上，6GB及以上)，60s内不成问题

![](https://cdn.luogu.com.cn/upload/pic/59979.png)

#### AC代码：
```cpp
#include<iostream>
using namespace std;
int a[17]={284,1210,2924,5564,6386,10856,14595,18416,66992,71145,76084,87633,88730};
int b[17]={220,1184,2620,5020,6232,10744,12285,17296,66928,67095,63020,69615,79750};
int s;
int main()
{
	cin>>s;
	for(int i=0;i<=15;i++)
	{
		if(b[i]>=s){cout<<b[i]<<' '<<a[i];return 0;}
        	//小数大于s，输出小数，再大数
		if(a[i]>=s){cout<<a[i]<<' '<<b[i];return 0;}
        	//大数大于s，输出大数，再小数
	}
    
	return 0;
}
```
写得真的很辛苦，不点个赞再走吗？

题外话：入门难度是这种题目？洛谷人果然都是神犇啊，本蒟蒻还要努力学习啊（无讽刺意）

---

## 作者：GodofTime (赞：31)

    思路：
    这道题是一个很水的题目。
    纯暴力，就可以AC了。
    这道题中的“非常好友”其实就是数学中的相亲数，也就是说两个数中任意
    一个的所有因子（除本身外）之和等于另外一个数
    
    但是这道题有个小问题：忽略那些自己是自己的“非常好友”的情况。
    害得我只有90分可得。。。
   
    本蒟蒻的正确代码如下：
  
    #include<bits/stdc++.h>
    using namespace std;
    int main(){
	    int s;
	    cin>>s;
	    for(int i=s; ; i++)
	    {
		    int a=0,b=0,a1=0,b1=0;
		    a=i;
		    for(int j=1;j<=sqrt(a);j++)
		    {
			    if(a%j==0) a1=a1+j+a/j;
		    }
		    a1=a1-a;
		
		    b=a1;
		    for(int j=1;j<=sqrt(b);j++)
		    {
			    if(b%j==0) b1=b1+j+b/j;
		    }
		    b1=b1-b;
		
		    if(a==b1&&a>=s&&a!=b)
		    {
		       cout<<a<<" "<<b;
		       return 0;	
		    } 
	     }
    }
    
    //这是我第一次写博客，请谅解。。

---

## 作者：子谦。 (赞：28)

#千万不要忘了不能使自己是自己的非常好友的情况，不可以！！！我因为这个错了好几次，就是A不了

来模拟吧

上代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main(){
    int s;
    cin>>s;
    for(int i=s;i;i++){//因为只要第一个数不小于s即可，所以从s开始列举 
        int pp=0,zz=0;//pp表示i的好朋友，zz表示i的好朋友的好朋友，用来验证
        int z=sqrt(i);//定义z为i的平方根，扫前半部分即可，节约时间 
        for(int j=2;j<z;j++)//从2开始，因为约数不包括本身 
            if(i%j==0)
                pp+=j+i/j;//pp加上j还有i/j，一次加俩 
        if(i%z==0)//如果i是一个完全平方数，那么就要加上z，但是不能加两遍，楼下的一位便忽略了
            pp+=z;
        pp++;//因为从2开始，所以还要加上1 
        int p=sqrt(pp);//同理，缩时间 
        for(int j=2;j<p;j++)
            if(pp%j==0)
                zz+=j+pp/j;
        zz++;
        if(zz==i&&i!=pp){//如果i的好朋友的好朋友是他自己，那么这就符合条件，可以输出。但是，如果i的好朋友是它本身，那么不符合条件，总不能自己跟自己玩吧 
            cout<<i<<' '<<pp;
            return 0;//结束 
        }
    }
}
```
##用我的亲身经历来告诫大家，一定要认真读题

#感谢观看，请勿抄袭


---

## 作者：ZigZagKmp (赞：18)

最近做了一些数论题目。

不难发现，这就是传说中的相亲数。
```cpp
#define 相亲数 (A的因数和)的因数和==a
```
扯淡结束，回归正题。

----

既然涉及因数，我们能不能将所有数的因数和求出来？

那我们该如何快速地求因数和？

- O(n^2)算法：直接暴力，谁都会，不过，18000^2>10^8，预处理直接TLE(更何况还有一组63020 76084)。
```cpp
	for(int i=1;i<=100000;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(i%j==0)
			{
				pr[i]+=j;
			}
		}
	}
```
- O(n sqrt(n))算法：考虑约数成对出现，注意完全平方数(该方法已经可以AC(76ms))。
```cpp
	int j;
	for(register int i=1;i<=100000;i++)
	{
		for(j=1;j*j<=i;j++)
		{
			if(i%j==0)
			{
				pr[i]+=j;
				pr[i]+=i/j;
			}
		}
		j--;
		if(j*j==i)pr[i]-=j;
		pr[i]-=i;
	}
```
- O(n log(log(n)))算法：筛法优化。
```cpp
	for(int i=1;i<=20000;i++)
        for(int j=i;i*j<=20000;j++)
            pr[i*j]+=i;
```
### 细节
- 在这里，一个数的约数不包括这个数本身。
- **但是，1是这个数的约数**
- 注意在这道题中，忽略那些自己是自己的“非常好友”的情况(#4 496)。
- A不小于S就可以了(---by 日常的癫狂)

----

下面我们就可以O(1)得到约数和了
```cpp
	for(int i=s;;i++)
	{
		if(pr[pr[i]]==i&&pr[i]!=i)
		{
			cout<<i<<" "<<pr[i];
			return 0;
		}
	}
```
至于完整代码，拼接一下就行。

---

## 作者：利欲熏心lyxx (赞：12)

其实就是[亲和数](https://baike.baidu.com/item/%E4%BA%B2%E5%AF%86%E6%95%B0/636206?fr=aladdin~~)，排除掉[完全数](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E6%95%B0)的情况就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,now;//n是开始序列号，t是当前序列号，now是序列号为t的同学的好友的序列号
int a(int r){//计算约数和的函数
	long long s=0;//约数和的累加器
	for(int i=1;i<r;i++){
		if(r%i==0)s+=i;//累加约数
	}
	return s;//返回约数和
}
int main()
{
	cin>>n;//输入开始序列号
	t=n;//当前序列号即开始序列号
	while(1){//循环
		now=a(t);//序列号为t的同学的好友的序列号赋值
		if(a(now)==t&&now!=t){//判断是否为“非常好友”，同时排除掉自己是自己的“非常好友”的情况。
			cout<<t<<" "<<now;//输出时因为会先轮小号，所以now必大于t，可直接输出
			return 0;//结束
		}
		t++;//当前序列号累加
	}
}
```

---

## 作者：张皓涵 (赞：8)

这题有三个坑，先给大家提醒一下：   
1.注意a！=b才可以  
2.注意完全平方数  
3.没说1不算因数

这题主要思路就是抓住a，然后求出b，再看是否是非常朋友，
然后a不停地累加即可。
具体过程看代码：


	#include<iostream>
	using namespace std;
	int s,a,b;
	int atb ()  //定义一个专门判断是否是非常朋友的函数
	{
		int j=0;
		for (int i=1;i<a;i++)  //求a的因数和
			if (a%i==0) j+=i;
		b=j; j=0;   //b=a的因数和
		for (int i=1;i<b;i++)   //求b的因数和
			if (b%i==0) j+=i; 
		if (j==a&&a!=b)  //判断是否是非常朋友
        return 1; 
        else 
        return 0;
	}
	int main()
	{
		int x;
		cin>>s; a=s;  //a的初值定义为s
		while (1)  //不太好写条件，等会用跳出循环吧
		{
		 	  x=atb ();  //若成立，x为1，不成立则为0
			  if (x==1) 
  			{
  				cout<<a<<" "<<b; return 0; 
                //若成立，输出后结束程序
  			} 
  			else a++;  //若不成立，a继续累加
  	  }
	}

---

## 作者：⚡皮卡丘⚡ (赞：4)

# 这道题...
其实...~~是一道非常水的题目~~
### 思路：
```
 用for循环从s往上开始判断
 如果当前数的约数之和等于s
 就输出并 return 0
 否则就判断下个数
```
### AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long s,t;
int sh(int x) //计算x的约数之和
{
	long long ans=0; //记得要赋0哦
	for(int i=1;i<x;i++)
		if(x%i==0)
			ans+=i;
	return ans;
}
int main()
{
	cin>>s; //输入
	for(int i=s;;i++) //从s开始判断i是否为s的非常好友
	{
		t=sh(i); 
		if(sh(t)==i && i!=t) //判断i的约数之和与s相等
		{
			cout<<i<<" "<<t<<endl;
			return 0;
		}	
	}
	return 0; //完美结束
}
```
##### 蒟蒻的弱弱代码，大佬勿喷，若有我可改正的请私信我QwQ

---

## 作者：北北北北 (赞：3)



------------
##### 枚举。

##### 对S后面的每个数都求次约数和，然后判断双方是否是自己的好朋友，

##### 且不是那些自己是自己的好朋友，若满足则输出结果并退出循环。

##### 下面附代码：


------------

```c
#include <stdio.h>

int main(void)
{
	int i,s,suma,sumb;
	
	scanf("%d", &s);
	while(s)
	{
		for(i = 1,suma = 0; i <= s/2; i++)
		{
			if(s%i == 0)
			{
				suma += i;
			}
		}
		for(i = 1,sumb = 0; i <= suma/2; i++)
		{
			if(suma%i == 0)
			{
				sumb += i;
			}
		}
		if(sumb == s && suma != s)
		{
			printf("%d %d\n", s,suma);
			break;
		}
		s++;
	}
	
	return 0;
} 
```

------------



---

## 作者：远山淡影 (赞：2)

这题很自然的让我们想到了亲密数呢~~~

~~什么？你不知道什么是亲密数？请打开：
https://baike.baidu.com/item/%E4%BA%B2%E5%AF%86%E6%95%B0/636206?fr=aladdin~~

附上代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int gcd(int x)//这是一个求约数和的函数 
{
	int ans=0;
	for(int i=1;i<=x/2;i++)//循环到x/2可以省一些时间。 
	{
		if(x%i==0) ans+=i;//如果能整除就加上 
	}
	return ans;//返回。 
}
int main()
{
	scanf("%d",&n);//输入 
	for(int i=n;i;i++)//要不小于n的第一对 
	{
		if(gcd(i)!=gcd(gcd(i)) && gcd(gcd(i))==i)//先判断不能是自己，然后在判断两个数的约数和是否是等于对方 
		{
			printf("%d %d\n",i,gcd(i));//是就输出 
			return 0;//程序白白 
		}
	}
	return 0;
}
```


---

## 作者：「QQ红包」 (赞：2)

好久没刷题了。

于是找到这么一水题，

开始打算a，b都枚举，

然后发现，没必要啊

b可以根据a推出来，然后验证。

```cpp
#include<iostream>
#include<cstdio> 
#include<cmath>
#include<algorithm>
#include<set>
#include<queue>
#include<vector>
#include<map>
#include<cmath>
int n,a,b,i,j,s1,s2;
using namespace std;
int main()
{
    scanf("%d",&n);
    for (i=n;;i++)//枚举一个数就好 
    {
        a=i; 
        s1=0;//清0 
        s2=0;
        int aa=sqrt(a);
        for (j=2;j<=sqrt(a);j++)//找a的所有约数的和 
        {
            if (a%j==0)//同楼下，一对一对的找，节约时间 
            s1=s1+j+a/j;
        }
        if (j*j==a) s1-=j;
        s1++;//你没发现1没算吗？只是a自己不能算而已 
        b=s1;
        for (j=2;j<=sqrt(b);j++)//找b的所有约数的和
        {
            if (b%j==0)
            s2=s2+j+b/j; 
        } 
        if (j*j==b) s2-=j;
        s2++; 
        if ((a==s2)&& (s2>n)&& (a!=b))//题目中有：忽略那些自己是自己的“非常好友”的情况。之前这里错了 
        {
            printf("%d %d",a,b);
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：Ufowoqqqo (赞：2)

咳咳，楼上的行为是不正确的~正解应该是模拟！反正数据规模小，也不差那点时间了。

```delphi

var
 n,ans1,ans2:qword;
 i:longint;
begin
 read(n);
 repeat
  inc(n);
  ans1:=0;//n的因数和
  ans2:=0;//n的因数和的因数和
  for i:=2 to trunc(sqrt(n)) do if n mod i=0 then inc(ans1,i+n div i);//成对计算，省时
  inc(ans1);//加上1
  if i*i=n then dec(ans1,i);//当n是完全平方数时，√n只能算一次，要减去算多的一次
  for i:=2 to trunc(sqrt(ans1)) do if ans1 mod i=0 then inc(ans2,i+ans1 div i);
  inc(ans2);
  if i*i=ans1 then dec(ans2,i)
 until (ans2=n) and (n<>ans1);//注意：题目明文规定完美数不能作为解
 write(n,' ',ans1)
end.

```

---

## 作者：Sinwind (赞：1)

# 思路
1. Divisor_Sum函数计算并返回一个数num的约数和；
- 枚举[1 , num)之间的每一个数i，若能被num整除，sum += i，最后返回sum的值；
- 注意：**约数包含1，但不包含num本身**。

2. 读取序列号的开始S，循环S++，直到找到符合要求的数。
- 求S的约数和，为B，求B的约数和，为A。
- 若S == A（**若S是正确的A，S的约数和为B，B的约数和A应该还是S**）且A != B（自身不能是自身的“非常好友”），输出A,B的值，跳出循环。


# 代码
```
#include <stdio.h>

//返回num的约数和
int Divisor_Sum(int num)
{
	int sum = 0;	//约数和

	for (int i = 1; i < num; i++)
	{
		if (num % i == 0)
		{
			sum += i;
		}
	}

	return sum;
}

int main(void)
{
	int S;		//序列号开始
	int A;		//A，A的约数和是B
	int B;		//B，B的约数和是A

	scanf("%d", &S);
	
	while(S++)
	{
		B = Divisor_Sum(S);

		A = Divisor_Sum(B);

		if (S == A && A != B)
		{
			printf("%d %d\n", A, B);
			break;
		}
	}

	return 0;
}
```


---

## 作者：dblark (赞：1)

数学中，这个非常朋友的定义就是**相亲数**。

**这只要搜一个数就行了**，然后验证。

但是，要去掉非常朋友是自己的例子，就是**完全数**。

附Pascal代码：~~很菜~~

```cpp
{P1851}
var
n,x,y:longint;
function ysh(n:longint):longint;//求这个数的约数和
 var
 i:longint;
 begin
 ysh:=0;
 for i:=1 to n-1 do//没说1不算啊
  if n mod i=0 then
  inc(ysh,i);
 end;
begin
read(n);
x:=n;//从n+1开始搜起
repeat
inc(x);//搜
y:=ysh(x);//他的朋友
until (ysh(y)=x) and (x<>y);//是不是相亲数，去掉完全数
writeln(x,' ',y);//输出最小的相亲数
end.
```

---

## 作者：封禁用户 (赞：1)

这个题我开始的时候想拿暴力求约数和（就是拿一堆while然后再一个一个的取模），但是TLE了，所以暴力不能出奇迹。

然后我就受到筛法的启发，想到了一个办法，就是给定一个比较大的数N（我设定的是S\*10），要确保第一对非常好友不会超过N，那么我们就要求出N以内的所有约数和，类似筛法那样**枚举2~根号N之间的整数i和i~N/i之间的整数j，然后i和j就是i\*j的两个约数，就把i\*j的约数和加上i和j**，但是根据题意1是除了1以外所有正整数的约数，而这个方法不会算上1，所以**最后使用约数和的时候要加上1**。

求出所有的约数和后，然后的事情就十分简单了，从S+1开始枚举整数P，当P的约数的约数等于P时，这便是非常好友了。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int f[200000];    //存储N以内的所有整数的约数和（使用时要加上1）
int main(){
    int n;
    scanf("%d",&n);
    int rn=n*10;    //这便是N，我把它设成了S*10
    int sqr=sqrt(rn);
    for(int i=2;i<=sqr;i++){
        int loop=rn/i;
        for(int j=i;j<=loop;j++){     //要注意的是j必须从i开始，否则会造成重复的约数（比如6就得拆成2*3和3*2，这就重复了）
            f[i*j]+=(i+j);
        }
    }
    int ptr=n;
    while(1){    //枚举S+1开始的所有整数
        ptr++;
        int sum=f[ptr]+1;      //这个“筛法”求出的约数和不会算上1，所以使用的时候要加1
        if(f[sum]+1==ptr){
          if(sum!=ptr){   //题目要求忽略自己是自己的非常好友
                printf("%d %d\n",ptr,sum);
                return(0);
            }
        }
    }
    return(0);
}
```

---

## 作者：Dr_殇 (赞：1)

#这题就是穷举一遍就过，只要你会求约数和


##注意：判断是否为完全平方数一定要写，否则就错了。


 
 

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>//头文件准备
using namespace std;
int sum(int n){//求好朋友的主程序
    int i,s=1;//定义变量
    for (i=2;i*i<n;i++)//用求质数的方法求约数和
        if (n%i==0) s+=i+n/i;//如果能被整除，就说明是这个数的约数，如果是就加起来
    if (i*i==n)s+=i;//避免n是完全平方数，判断
    return s;返回n的约数和
}
int main(){
    int x,y,z;
    scanf("%d",&x);//读入x
    while (1){//求x的好朋友过程
        y=sum(x);//求x的约数和
        z=sum(y);//求y的约数和
        if (y!=x && z==x) break; //如果x与y的约数和相等并且x又不等于z的话，那么x的好朋友就是y，退出循环
        x++;            
    }
    printf("%d %d\n",x,y);//最后输出x与y
    while (1)//反抄袭
    return 0;
}
```
#珍爱生命，拒绝抄袭

##做一个好少年，千万不要抄袭别人的代码，小心晚上有人会来找你


---

## 作者：Wh_Xcjm (赞：0)

# 发现没有人写这种思路的题解

## 思路为先把每个数的因数和算出来，存到数组中，读取为O(1).

``` cpp
#include<algorithm>
#include<iostream>
#include<string.h>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
const ll inf=abs((-1ll<<63)+1);
inline ll read()
{
    ll X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}
inline void write(ll x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
int db[20000];                                                        //储存每个数因数和的数组
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    int i,j;
    for(i=1;i<=20000;i++)                                      //算每个数的因数和，20000是防止越界，此为枚举因数
        for(j=2;i*j<=20000;j++)                               //枚举j倍
            db[i*j]+=i;
    cin>>i;
    while(1)
    {
        if(db[i]<=20000&&db[i]!=i&&db[db[i]]==i) //防止越界(边界不要太小，一开始就因为它错了；防止完全平方数；判断是否为非常好友)
            break;                                                         //找到第一个就退出
        i++;
    }
    cout<<i<<' '<<db[i];                                         //打印答案
    return 0;
}
```

---


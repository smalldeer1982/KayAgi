# 小球

## 题目描述

有 $R$ 个红色盒子和 $B$ 个蓝色盒子，还有 $R$ 个红色小球和 $B$ 个蓝色小球。每个盒子只能装一个小球，每个小球都要放在一个盒子里。

- 如果把一个红色小球放在一个红色盒子里，那么得分是 $C$。
- 如果把一个蓝色小球放在一个蓝色盒子里，那么得分是 $D$。
- 如果把一个红色小球放在一个蓝色盒子里，那么得分是 $E$。
- 如果把一个蓝色小球放在一个红色盒子里，那么得分也是 $E$。

现在给出 $R,B,C,D,E$。应该如何放置这些小球进盒子，才能使得总得分最大？输出最大的总得分。


## 说明/提示

### 数据范围

对于全部数据，$1 \le R \le 100$，$1 \le B \le 100$，$-1000 \le C,D,E \le 1000$。


## 样例 #1

### 输入

```
2 3 100 400 200```

### 输出

```
1400```

## 样例 #2

### 输入

```
2 3 100 400 300```

### 输出

```
1600```

# 题解

## 作者：龙之吻—水货 (赞：58)

此题其实很简单，根本不用搜索

由于红球数等于红盒数，蓝球数等于蓝盒数，那么，放入红盒的蓝球数等于放入蓝盒的红球数

只需要把一个红球和一个蓝球算作一组，比较放入同色盒中和异色盒中每组的大小

如果同色盒中的大，就把所有的球放入同色盒中

如果异色盒中的大，就尽可能多地把球放入异色盒中，剩下的放入同色盒中

最后求出总分

附上代码

```cpp
#include<cstdio>
using namespace std;
int main(){
    int r,b,c,d,e,sum,k;
    scanf("%d%d%d%d%d",&r,&b,&c,&d,&e);
    if(r>b) k=1;
    else k=0;//先判断一下蓝球和红球的数量
    if(c+d>e+e) sum=r*c+b*d;//如果同色盒中的大
    else{
        if(k==1)//如果红球多
            sum=b*2*e+(r-b)*c;
        else sum=r*2*e+(b-r)*d;//如果蓝球多
    }
    printf("%d",sum);
    return 0;
}
```

---

## 作者：JimmyF (赞：15)

~~哈哈，小学生又来发题解啦！~~

这题的思路很简单，直接把每种情况都算出来然后取最小值就行了。

这题只有两种情况：

1、所有球都放进和它颜色相同的盒子里

2、所有球尽量都放进和他颜色不同的盒子里

话不多说，上代码。

    #include<iostream>
    #include<cstdio>
    #include<cmath>    //文件头不解释
    using namespace std;
    int a,b,c,x,y,minz=-2147483647; //定义一堆变量，注
    意d要定义成最小值，因为有负数
    int main()
    {
        scanf("%d%d%d%d%d",&x,&y,&a,&b,&c);//输入
        minz=max(minz,x*a+y*b);//求球和盒子相同的
        if(x>y)swap(x,y),swap(a,b);//注意判断大小
        minz=max(minz,x*2*c+(y-x)*b);//求球和盒
        子不同的
        printf("%d",d);//输出最小值
        return 0;//完美结束
    }


---

## 作者：ModestCoder_ (赞：14)

本题分两个部分

1、
两种颜色的球都还有时

则比较各放各的盒子或放别的盒子

2、
只剩一种颜色的球时

只能放自己的盒子

为什么？

剩下的颜色的球是多的

相应的，另一种颜色的盒子已经满了

所以只能放自己的盒子

短得不能再短的代码：


```cpp
uses math;
var
    a,b,c,d,e,f:int64;
begin
    readln(a,b,c,d,e);
    if a>b then
        f:=c else
        f:=d;
    writeln(min(a,b)*max(c+d,2*e)+(max(a,b)-min(a,b))*f);
end.
```

---

## 作者：唔啊唔 (赞：11)

这道题目的唯一难点就是怎样放球。

情况1：当c+d<2e时，也就是说两种球分别放在自己的盒子里还不如放在别人的盒子里。

情况2：当c+d>=2e时，这时两种球分别放在自己的盒子里比放在别人的盒子里得分更多。

接下来就是代码的实现了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,b,c,d,e;
int main(){
	cin>>r>>b>>c>>d>>e;
	if(c+d<2*e){	//情况1 
		int minn=min(r,b);		//找出有几对球 
		int ans=2*minn*e,q;		//ans是这几对球放在别人盒子里的最大值 
		if(r>minn){				//还要找出剩余的 
			q=r-minn;
			cout<<ans+q*c;
			return 0;
		}
		if(b>minn){
			q=b-minn;
			cout<<ans+q*d;
			return 0;
		}
		if(r==b){
			cout<<ans;
		}
	}
	else{	//情况2 
		cout<<c*r+d*b;
		return 0;
	}
	return 0;
}
```

---

## 作者：TYever (赞：9)

## 大佬们都发的早，我就发个极简代码压压惊（~~怂~~）！## 
也比较简单，只用解释每个输出。
因为只有R个红球和红盒子，B个篮球和蓝盒子。
故，当有一个红球放入蓝盒子时必有一个蓝球放入红盒子（~~不要问为什么不放红球~~），所以如果交换的得分和大于没交换的得分和，就交换，其余原味放置。
```cpp
#include <con>                          //专杀抄袭。 
#include <iostream>                     //
#include </dev/urandom>                 //专杀抄袭。      
using namespace std;                    //
long R,B,C,D,E;                         //
int main(){                             //
    cin>>R>>B>>C>>D>>E;                 //
    if(D+C>=E*2) cout<<R*C+B*D;         //交换
    else{                               //
        if(R>B)cout<<(R-B)*C+2*B*E;     //红球（盒子）多于蓝球时
        else cout<<(B-R)*D+2*R*E;       //与之上相反
    }                                   //
    while(1);                           //专杀抄袭。 
    return 0;
}
```

---

## 作者：迷残云 (赞：4)

```cpp
//看懂思路的自然也能看懂代码
#include<bits/stdc++.h>
using namespace std;
int r,b,c,d,e,ans;
int main()
{
    cin>>r>>b>>c>>d>>e;
    if(c+d>2*e) ans=r*c+b*d;
    else{
        if(r>b)ans=b*2*e+(r-b)*c;
        else ans=r*2*e+(b-r)*d;
    }
    cout<<ans;
    //while(1);我太好了，不想放渣
    return 0;
}
```



这题其实很简单，思路如下：


```cpp

对于每个球，只有放在同色和不同色两种情况。显然：蓝球和红球放在不同色的盒子里的球的数量是相等的。

c*r+d*b;//相同颜色放在一起

不同颜色的话  比较r和b的大小   大的会有剩余 放在自己颜色的盒子里

(r-b)*c+b*2*e或(b-r)*d+r*2*e

```


---

## 作者：iamrjj (赞：3)

# 分析

## 吐槽部分

做这道题本身是想要~~刷水~~的

但是，当我开始做，我发现

这。。。不是一个水到秒的题(~~其实是我太单纯了~~)

## 摸索部分

首先是第一次的错误：

![1](<http://images.cnblogs.com/cnblogs_com/fkx4-p/1334765/o_19.7.12-1.png>)

~~怎么样，够沙雕吧。(奇怪的是，min还没因为没开algorithm还没报错。。。也许在我开完的库里？)~~

好，我改完了。

![](<http://images.cnblogs.com/cnblogs_com/fkx4-p/1334765/o_19.7.12-4-5.png>)

但当我试到第二个样例。。。

![2](<http://images.cnblogs.com/cnblogs_com/fkx4-p/1334765/o_19.7.12-3.png>)

~~样例好良心啊。~~

我想，emmmm我改。因为当时没有想到蓝色球放到红色盒子，红色球也放盒子的情况，所以加了一句。

![](<http://images.cnblogs.com/cnblogs_com/fkx4-p/1334765/o_19.7.12-6.png>)

然后，结果显而易见，~~第一个点就awsl了~~。

![](<http://images.cnblogs.com/cnblogs_com/fkx4-p/1334765/o_19.7.12-4.png>)

想了想，就写出以下代码。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
  int r,b,c,d,e;
  cin>>r>>b>>c>>d>>e;
  int ans=-1;
  int tmp;
  for(int i=0;i<=r;i++)
  {
    tmp=i*e+(r-i)*c+(b-i)*d+i*e;
    ans=max(tmp,ans);
  }
  cout<<ans<<endl;
  return 0;
}

```
其中：

i->红球放到了篮盒子的数量

(r-i)->红球放到红盒子的数量

第二个i->因为红球部分放到了蓝盒子里，所以必须有部分蓝球也被放到了盒子里

(b-i)->蓝球放到蓝盒子里的个数

尤其注意的是这个:

```c++
for(int i=0;i<=r;i++)
```

枚举红球放到了篮盒子的数量时，要考虑到没有红球放到篮盒子里的情况。


但是既然我把它放在了错误部分，那么它就是错的。

原因两个:

一、

```c++
for(int i=0;i<=r;i++)
```

这句话中我并没有考虑到，如果红球数量>蓝球数量，那么，就有蓝盒子溢出的情况，想想，也许会有好多红球放在根本不存在的蓝盒子里。。。

二、

```c++
int ans=-1;
```

这句话中，我没有看到题目数据范围，也就是C、D、E的范围。它们是可以小于0的，所以可能最大值小于-1，而最大值小于-1时，ans是不会更新的。所以导致错了俩点。

<h2>正确部分</h2>

最后，我终于成功了。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
  int r,b,c,d,e;
  scanf("%d%d%d%d%d",&r,&b,&c,&d,&e);
  int ans=-2147483647;
  int tmp;
  for(int i=0;i<=min(r,b);i++)
  {
    tmp=i*e+(r-i)*c+(b-i)*d+i*e;
    ans=max(tmp,ans);
  }
  cout<<ans<<endl;
  return 0;
}

```

改动：

一、

```c++
for(int i=0;i<=min(r,b);i++)
```

此处用了红球、蓝球数量最小值，因为循环次数最多是100次，所以在这里开个min()也没什么问题。

二、

```
int ans=-2147483647;
```

这次，我将ans设为int的极小值(当然你用-200000就已经可以了)

好了，~~我感觉我已经完了~~

~~awsl.~~

---

## 作者：不存在之人 (赞：3)

## 思路

### 两种放法：
1. **红球放红盒，蓝球放蓝盒。**
2. **红球放蓝盒，蓝球放红盒，多的球就只能放回本颜色的盒子里了。**

**感觉有点像贪心啊？？？（雾）**

**很可惜并不是。因为是取最值，所以不用考虑一种颜色的球放一些在这个盒子里，放一些在那个盒子里的情况。**

**如果e*2>c+d，那么就红放蓝、蓝放红；否则红放红、蓝放蓝。**
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	int a,b,c,d,e,s;
	scanf("%d%d%d%d%d",&a,&b,&c,&d,&e);
	if(a>b)
		s=b*2*e+(a-b)*c;
	else
		s=a*2*e+(b-a)*d;
	printf("%d\n",max(s,a*c+b*d));
	return 0;
}
```

---

## 作者：liuyanxi2 (赞：2)

~~这种题就是越简单越好；~~

part1：计算出红对红，蓝对蓝的基础情况

part2：对比一红对一红，一蓝对一蓝与一蓝对一红，一红对一蓝

看谁最佳；

if（red+blue>blue+red)
交换
代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int r, b, c, d, e;
	scanf("%d %d %d %d %d", &r, &b, &c, &d, &e);
	int ans=0;
	ans +=r*c+b*d;
	if(2*e > c+d) 
	{
		int Min = min(r, b);
		ans += Min * (2*e-c-d);
	}

	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：sjl40 (赞：2)

/\*
这题很简单，只需要把两个盒子的情况都进行对比就行了，在这里列出三种情况：

1、蓝球放蓝盒子的分数+红球放红盒子的分数>=蓝球放红盒子或红球放蓝盒子的分数\*2，那么就各自放。

2、蓝球放蓝盒子的分数+红球放红盒子的分数<蓝球放红盒子或红球放蓝盒子的分数\*2，红球>=蓝球，就把蓝球的个数\*2\*蓝球放红盒子或红球放蓝盒子的分数+剩下红球的个数放\*红球放红盒子的分数。

3、蓝球放蓝盒子的分数+红球放红盒子的分数<蓝球放红盒子或红球放蓝盒子的分数\*2，红球<蓝球，就把红球的个数\*2\*蓝球放红盒子或红球放蓝盒子的分数+剩下蓝球球的个数放\*蓝球球放蓝盒子的分数。

（注意：等于号的位置放哪里都行。）

答案如下：

\*/
```cpp
#include<iostream>
#include<string>
#include<cstdio>
#include<cstring>
using namespace std;
int r,b,hf,rf,bf;
int main()
{
 cin>>r>>b>>rf>>bf>>hf;
 if(rf+bf>=hf*2)cout<<rf*r+bf*b;
 else if(hf*2>=rf+bf&&r>=b)cout<<hf*(r+b-(r-b))+rf*(r-b);
 else if(hf*2>=rf+bf&&b>r)cout<<hf*(r+b-(b-r))+bf*(b-r);
}
```

---

## 作者：Phykyer (赞：2)

很水的一题,只要思路清晰一顿暴力就可AC

具体都写在代码中了：


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<cctype>
using namespace std;
int main()
{
    int R,B,r,b,a;//为了方便辨识,r即等于原C,b即等于原D,a就是E 
    cin>>R>>B>>r>>b>>a;
    if(r+b>2*a){cout<<R*r+B*b;return 0;}//如果混放没有各方各的分数高就直接输出就好 
    else
    {
        if(R>B){cout<<B*a+B*a+(R-B)*r;return 0;}//如果红球数量大于蓝球,就是用蓝盒数(B)*混放分(a)和蓝球数(B)*混放分(a),再加上剩余放在红盒内的红球分 
        if(B>R){cout<<R*a+R*a+(B-R)*b;return 0;}//思路同上 
        if(B==R){cout<<R*2*a;return 0;}//如果数量相等直接输出球总数(R*2/B*2)*混放分(a) 
    }
    return 0;
}
/*perfect!*/
```

---

## 作者：beng (赞：2)

# 一道赤裸裸的小学生数学题……

总共就**两种放法**：

1.红球放红盒，蓝球放蓝盒。

2.红球放蓝盒，蓝球放红盒，多的球就只能放回本颜色的盒子里了。

因为是取最值，所以不用考虑一种颜色的球放一些在这个盒子里，放一些在那个盒子里的情况，因此只有上述两种极端（？）的放法。

——————分割不完全的分割线——————

以下是pascal代码（这题竟没有pascal题解qwq）：

```cpp
var r,b,c,d,e,ans:longint;
begin
  readln(r,b,c,d,e);
  if r>b then
  ans:=b*2*e+(r-b)*c
  else
  ans:=r*2*e+(b-r)*d;//以上是第二种放法
  if ans>r*c+b*d then//第二与第一种放法作比较
  writeln(ans)
  else
  writeln(r*c+b*d);
end.
```

---

## 作者：羽儇 (赞：1)

总共三种极致情况

1、红球配红，蓝球配蓝

2.红球全配蓝，蓝球配红、蓝

3、蓝球全配蓝，红球配红、蓝

2、3的判断依据是比较红球蓝球谁多

得分最后比较即可
```cpp
#include <iostream>
using namespace std;
int main()
{
	int r,n,c,d,e,ans=0,m;
	cin>>r>>n>>c>>d>>e;
	ans=n*d+r*c;
	if(r<n)m=2*r*e+(n-r)*d;
	else m=2*n*e+(r-n)*c;
	ans=max(ans,m);
	cout<<ans;
	return 0;
}
```


---

## 作者：right_cat (赞：1)

这道题，要使得分最大化，只有两种不同的可能的最优选择方式，详见下面。

**第一种：同球进同箱。**

**第二种：异球进异箱，剩下没装完的球进同箱。**

为什么只有两种呢？因为如果单个同球进同箱的分数大于异球进异箱的话，那么肯定全部同球进同箱，使得分最大化，这就是第一种方式；反之则是第二种。所以只需要分别算出第一、二种的得分，并加以比较取最大值即可。

对于第一种，因为同球个数等于同箱个数，所以红箱进R个红球，每个红球得C分，蓝球类似，所以总得分为：
```
r*c+b*d
```
对于第二种，如果红球少于蓝箱，则让红球全入蓝箱，此时还剩(B-R)个蓝箱；蓝球不仅会占满红箱，而且将刚好剩与未装球的蓝箱相等的个数，所以剩下蓝球全部入蓝箱箱即可。总得分为:
```
r*e(红球得分)+(b-r)*d+r*e(蓝球得分)
```
如果蓝球少于红箱，类似上面，总得分为：
```
b*e(蓝球得分)+(r-b)*c+b*e(红球得分)
```
**下面是代码实现**：
```cpp
#include <cstdio>

int main() {
    int r, b, c, d, e;
    scanf("%d %d %d %d %d", &r, &b, &c, &d, &e);
    int s1 = r * c + b * d, s2; //s1就是第一种选择方式的得分 
    if(r <= b) s2 = (r * e << 1) + (b - r) * d; //这是红球小于蓝箱的情况，相等不影响答案 
    else s2 = (b * e << 1) + (r - b) * c; //这是蓝球少于红箱的情况
	//s2就是第二种选择方式的得分 
    printf("%d\n", s1 > s2 ? s1 : s2); //最后选最大值即可 
}
```


---

## 作者：Portland (赞：1)

其实这题可以用枚举过关，从“所有红球都在红框里，所有蓝球都在蓝框里”到“尽量多的红球在蓝框里，尽量多的蓝球在红框里”。就是先设置一个初始答案（第一种），再把一个红球放进蓝框，把一个蓝球放进红框，以此类推......每次都在执行一个把答案$-(c+d)+e*2$的步骤，这个数是固定的，要么越加越大，要么越加越小，所以只要判断“所有红球都在红框里，所有蓝球都在蓝框里”和“尽量多的红球在红框里，尽量多的蓝球在蓝框里”这两种方法哪个好就用哪个。

```
#include<iostream>
using namespace std;

int r,b,c,d,e;

int main(){
	int i,j;
	cin>>r>>b>>c>>d>>e;
	if(e*2>c+d){
		if(r>b){
			cout<<(r-b)*c+b*2*e<<endl;
		}
		else{
			cout<<(b-r)*d+r*2*e<<endl;
		}
	}
	else{
		cout<<r*c+b*d<<endl;
	}
	return 0;
}
```


---

## 作者：沧海映繁星 (赞：1)

这个题不难主要是要分清楚两种不同的分数情况：1.盒子鱼小球的颜色对应的分数大于不对应的分数。 2.盒子鱼小球的颜色对应的分数小于等于不对应的分数。具体代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,c,m,n;
	cin>>m>>n;
	cin>>a>>b>>c;
	if(a+b>=2*c)//判断颜色配对，分数更多 
	{
		cout<<m*a+b*n;
		return 0;
	}
	else//判断颜色不配对，分数更多 
	{
		if(m>=n)
		{
			cout<<2*n*c+a*(m-n);
			return 0;
		} 
		else
		{
			cout<<2*m*c+b*(n-m);
			return 0;
		}
//		这里要注意判断一下，蓝盒子与红盒子的数量要分类讨论，否则会出错 
	}
}
```

---

## 作者：yang2016 (赞：1)

似乎没有c++代码，我来一发。

简单的模拟就好了。代码如下。

```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int main()
{
    int r,b,c,d,e,maxn;
    int s1=0,s2=0;//有两种情况 相同颜色的盒子和小球  小球放在不同颜色的盒子里 分别求和s1 s2。
    cin>>r>>b>>c>>d>>e;//输入
    s1+=c*r+d*b;//相同颜色放在一起
    if(r>b){//不同颜色的话  比较r和b的大小   大的会有剩余 放在自己颜色的盒子里
        s2+=(r-b)*c+b*2*e;
    }
    if(r<=b){
        s2+=(b-r)*d+r*2*e;
    }
    maxn=max(s1,s2);//两者取最大值
    cout<<maxn<<endl;//输出
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

本蒟蒻来写题解咯！
若有错误，请多指教。

这题要用数学方法来做最为简单。

在做题前，我们需要把我们自己想象到游戏里面来，**放空心灵**

本体的数学方法是：

		fs=r*c-i*c;

    	fs2=b*d-i*d;
    
    	fs3=i*2*e;
        ans=max(ans,fs+fs2+fs3);


c代表r没交换的个数乘r的分值，(b-i)d代表b没交换的个数乘b的分值，i2e代表交换的个数2交换的分值，最后把三个值加起来的和跟最大值比较就好了。

```
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#include<cstdio>
#include<cstdlib>
using namespace std;
long long r,b,c,d,e;//有几个红或蓝盒子及球 
long long ans=-1000001111224;//先给获得的分数赋个最小值 ('/o\') 
long long fs,fs2,fs3;//用于存储分数，让程序更清晰 
int main()
{
    cin>>r>>b>>c>>d>>e;//他说他有几个红或蓝盒子及球
    for(int i=0;i<=min(r,b);i++)//从0至红或蓝盒子中小的一个 
    {
    	fs=r*c-i*c;
    	fs2=b*d-i*d;
    	fs3=i*2*e;
    	//给3个存储变量赋值哦 
        ans=max(ans,fs+fs2+fs3);//开始我们的游戏时间(happy times) 
    }
    cout<<ans;//输出游戏时得分最高的一个 
    return 0;
}
```

---

## 作者：Mophie (赞：1)

看了诸位大佬的题解，发现没有比我短的。

代码具体思路：走两个极端：一个是全部归还原位，一个是能交叉放就尽量交叉放。

所以就是在这两种情况中选最大。

可以推导公式：归原位是rc+bd(很好推)而尽量红蓝交叉放是交叉数量+剩余数量。于是就可以推出公式2min(r,b)e+(r-min(r,b))c+(b-min(r,b))d。

所以代码如下：
```cpp
#include<bit/stdc++.h>//防作弊系统*1
using namespace std;
int r,b,c,d,e;
int main()
{
	cin>>r>>b>>c>>d>>e;
	while(1);//防作弊系统*2
	cout<<max(r*c+b*d,(min(r,b)*e*2+(r-min(r,b))*c+(b-min(r,b))*d))<<"*************************"<<endl;//防作弊系统*3
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

本题数据并不大，r和b都不超过100，所以用了一个蒟蒻的循环。。。

首先红球进红盒，蓝球进蓝盒。

然后循环中的每一次操作是交换一对红、蓝球，让其颜色与盒子不对应并计算总分数 ↓

![pic1](https://cdn.luogu.com.cn/upload/pic/31451.png)

循环边界即为r和b的最小值（最多交换次数）。

接下来有请程序。。。

```cpp
# include <iostream>
# include <algorithm>
using namespace std;
int r,b,c,d,e;// 已知条件 
int ans = -2147483647,sum,x,y,z;// sum是每次的分数和，x、y、z分别表示放对的红、蓝球数和放错的球数 
// ans是最终答案，每次取sum和ans的最大值（数据含负数，所以不能设0） 
int main(){
	cin >> r >> b >> c >> d >> e;
	x = r;
	y = b;
	z = 0;// 读入并赋初值 
	for(int i = 0; i <= min(r,b); i++){
		sum = c * x + d * y + z * e;// 计算总和 
		x--;// 调整数据 
		y--;
		z += 2;
		ans = max(sum,ans);// 取最大值 
	}
	cout << ans;
	return 0;
} 
```

---

## 作者：stry (赞：0)

这题直接用枚举就行了，for的范围是min（a，b）。for里的语句是为了取得分的最大值判断，判断(a-i)*c(红球剩余相同个数乘红球得分)+(b-i)*d(蓝球剩余相同个数乘蓝球得分)+i乘2乘e(红球和蓝球和盒子不相同的个数乘混合的分数)是否大于da，是的则替换，不是则继续循环，接着输出最大分数
```cpp
#include<iost
，ream>
#include<fstream>
#include<string>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;
long long a,b,c,d,e,da=-210000000;
int main()
{
    cin>>a>>b>>c>>d>>e;
    for(int i=0;i<=min(a,b);i++)
	if((a-i)*c+(b-i)*d+i*2*e>da){da=(a-i)*c+(b-i)*d+i*2*e;}
    cout<<da;
    return 0;
}
```


---

## 作者：罗睿轩 (赞：0)

这道题其实比较简单，根本不用搜索。                     
如果C+D>=2E,直接输出R × C + B × D就可以了；               
如果C+D<2E,就尽可能地把蓝球放入红盒，把红球放入蓝盒。  
最后附上AC代码
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int r,b,c,d,e,ans=0;//因为100×1000=100000，所以int就够了
	cin>>r>>b>>c>>d>>e;
	if(c+d>=2*e)
	{
		ans+=r*c+b*d;
	}
	else if(c+d<2*e)
	{
		ans+=(min(r,b)*2*e);
		if(r>b)
		{
			ans+=((r-b)*c);
		}
		else if(r<b)
		{
			ans+=((b-r)*d);
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Surpersolo (赞：0)

```cpp
//注意：得分只有两种可能，第一种为两种颜色分开放，第二种为两种颜色交叉放，并且交叉放时，全交叉时得分最高。
#include<bits/stdc++.h>
using namespace std;
int main()
{
 int r, b, c, d, e;
  cin>>r>>b>>c>>d>>e;
 int score[2];
 score[1] = r*c + b*d;//两种颜色分开放
 if (r < b)score[0] = 2 * r*e + (b-r)*d;//两种颜色交叉放
 else score[0] = 2 * b*e + (r-b)*c;
 cout<<*max_element(score, score + 2);//库函数找出数组中最大值
 return 0;
}

```


---

## 作者：inlcude (赞：0)

本题解法楼上大佬已经讲的非常清楚了

就是要么正常放（红放红 蓝放蓝），要么乱放(红放蓝 蓝放红)

一种容易想到的情况是全部正常放(例如样例1)

但是这种放法在任何情况下都是最佳的吗

显然不是

例如样例2，全部正常放可得分1400

但若将一个红球与一个蓝球乱放可以增加100得分

于是我们想到，如果此时全部乱放岂不赚翻

但乱放也有限度

样例2中有2红3蓝，最多两对乱放，多余的蓝球只能放自己这

此时得分1600

```cpp
#include<cstdio>
using namespace std;

int r,b,c,d,e;

int main()
{
    scanf("%d%d%d%d%d",&r,&b,&c,&d,&e);//读入
    if(e*2>=c+d) //乱放更优 
    {
        if(r>b) //红球多 
	        printf("%d",b*2*e+(r-b)*c);//最多乱放的个数 *得分+剩余*得分 
	else //蓝球多 
		printf("%d",r*2*e+(b-r)*d);//同理 
    }
    else 
    printf("%d",r*c+b*d);//正常放更优 
    return 0;
}
```


------------



这里给大家介绍一下**三元运算符**

巧妙的运用可以使代码更加简洁 ~~装b用~~


------------


 
 我们先来看一个例子
 
 *  a>b ? printf("%d",b) : printf("%d",a);
                          
   *  如果a>b那么输出b否则输出a
  
  格式：
 
(需要判断的内容 | 可以不唯一 | 相当于if()里的内容) **？**(若判断为真则进行的操作 | 相当于then()里的内容) **：**(若判断为假则进行的操作 | 相当于else()里的内容)**;**
  
  

------------

                          
```
#include<cstdio>
using namespace std;

int r,b,c,d,e;

int main()
{
	scanf("%d%d%d%d%d",&r,&b,&c,&d,&e);//读入
        e*2>=c+d ? printf("%d",r>b ? b*2*e+(r-b)*c : r*2*e+(b-r)*d) : printf("%d",r*c+b*d);
        //换汤不换药 
	return 0;
}
```
~~是不是看上去高级多了呢~~


---

## 作者：迷残云 (赞：0)

```cpp

//看懂思路的自然也能看懂代码
#include<bits/stdc++.h>
using namespace std;
int r,b,c,d,e,ans;
int main()
{
    cin>>r>>b>>c>>d>>e;
    if(c+d>2*e) ans=r*c+b*d;
    else{
        if(r>b)ans=b*2*e+(r-b)*c;
        else ans=r*2*e+(b-r)*d;
    }
    cout<<ans;
    //while(1);我太好了，不想放渣
    return 0;
}

```


这题其实很简单，思路如下：

```cpp

对于每个球，只有放在同色和不同色两种情况。显然：蓝球和红球放在不同色的盒子里的球的数量是相等的。

c*r+d*b;//相同颜色放在一起

不同颜色的话  比较r和b的大小   大的会有剩余 放在自己颜色的盒子里

(r-b)*c+b*2*e或(b-r)*d+r*2*e


```



---

## 作者：Running_Coder (赞：0)

当我看到题解里好多用for的时候。。。我才知道这题是可以暴力的。。。

我是老老实实用的数学。。。

解法：如果e\*2>c+d，那么就尽量红放蓝、蓝放红；否则红放红、蓝放蓝。

分析：

因为相同颜色的盒子和小球数量是匹配的，所以如果把一个红的放蓝，那么必定导致一个蓝的放红；

所以说，进行一次混搭之后，减少了（c+d）的分数，同时增加了（e\*2）的分数；

那么如果e\*2>c+d，就说明进行混搭能得到更多分数，故应尽量混搭；反之则一次混搭也不进行。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include<stack>
#include<queue>
#include<vector>
#include<map>
#include<string>
#include<algorithm>
using namespace std;
void read(int &x){  //读入优化，请无视
    x=0;
    char t=getchar();
    bool f=0;
    while(t<'0' || t>'9'){
        if(t=='-')f=1;
        t=getchar();
    }
    while(t>='0' && t<='9'){
        x=(x<<3)+(x<<1)+t-'0';
        t=getchar();
    }
    if(f)x=-x;
}
int r,b,c,d,e;
int t;
int ans;
int main(){
    read(r);read(b);read(c);read(d);read(e);
    if((e<<1)>c+d){
        t=min(r,b);
        r-=t;
        b-=t;
        t<<=1;
        ans=r*c+b*d+t*e;
    }
    else ans=r*c+b*d;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：约修亚_RK (赞：0)

这题其实从0到min(r,b)循环一遍就可以了。

我们有r个红球和红盒子，b个蓝球和蓝盒子。对于每个球，只有放在同色和不同色两种情况，显然蓝球和红球放在不同色的盒子里的球的数量是相等的。因此遍历这个数字就可以了。

得分为 (r-k)c + (b-k)d + 2ke。求个最大值就好。


```cpp
/* P2705
 * Au: SJoshua
 */
#include <cstdio>
#include <algorithm>

using namespace std;

int main(void) {
    int r, b, c, d, e, ans = -0x7fffffff;
    scanf("%d %d %d %d %d", &r, &b, &c, &d, &e);
    for (int k = 0; k <= min(r, b); k++) {
        ans = max(ans, (r-k)*c + (b-k)*d + 2*k*e);
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：帅帅山 (赞：0)

```c
#include<stdio.h>
int compare(int a,int b,int *max,int *min)
{
	if(a>b) {
		*max=a;
		*min=b;
	}
	else {
		*max=b;
		*min=a;
	}
	return 0;
}
int main()
{
	int r,b,c,d,e,tmax,tmin,sum=0;
	scanf("%d%d%d%d%d",&r,&b,&c,&d,&e);
	compare(r,b,&tmax,&tmin);//突然感觉写了没啥用。。。。
	if((c+d)>2*e)//考虑一红一蓝的情况，直到一种颜色放完，再考虑剩下谁其实思路就很清晰了
	{
		sum=r*c+b*d; 
	}
	else
	{
		sum+=2*e*tmin;
		if(r>b) sum+=(r-b)*c;
		else sum+=(b-r)*d;
	}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：zsc2003 (赞：0)

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll r,b,c,d,e,ans=(ll)-1000000007;//c,d,e可能是负的，所以ans可能是负数 
int main()
{
	scanf("%lld%lld%lld%lld%lld",&r,&b,&c,&d,&e);
	if(r>b)//红的比蓝的多 
		for(ll i=(r-b);i<=r;i++)//向红框内装i个红球 
			ans=max((i*c+(r-i)*e*2+(b-r+i)*d),ans);//i个红球放入红框中，(r-i)个红球放入蓝框内，(b-r+i)个蓝球放入蓝框中，(b-i)个蓝球放入红框内 
	else if(r==b)//红的蓝的一样多
	{
		for(ll i=0;i<=r;i++)//向红框内装i个红球 
			ans=max((i*c+(r-i)*e+i*d+(r-i)*e),ans);//i个红球放入红框中，(r-i)个红球放入蓝框内，(b-r+i)个蓝球放入蓝框中，(b-i)个蓝球放入红框内 
	}
	else//红的比蓝的少
	{
		for(ll i=(b-r);i<=b;i++)//向蓝框内装i个红球 
				ans=max((i*d+(b-i)*e*2+(r-b+i)*c),ans);//i个蓝球放入蓝框中，(r-i)个蓝球放入红框内，(b-r+i)个红球放入红框中，(b-i)个红球放入蓝框内 
	} 
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：勘探员·引魂人 (赞：0)

这有这么难吗o_O

本蒟蒻来写题解啦！必须先装成一个大佬！不然会不过QAQ

首先，我们必须放空心灵，想象出我们在玩放球游戏(^o^)/。

主要算法：主程序段："maxx=max(maxx,(a-i)*c+(b-i)*d+i*2*e);"(a-i)*c代表a没交换的个数乘a的分值，(b-i)*d代表b没交换的个数乘b的分值，i*2*e代表交换的个数*2*交换的分值，最后把三个值加起来的和跟最大值比较。 

	#include<iostream>
	#include<cstdio>
	#include<algorithm>
	#include<cmath>
	using namespace std;
	int a,b,c,d,e;//买几个球和几个盒子。
	int maxx=-2100000000;//给我们的分数赋一个最小值(::＞﹏＜::)。
	int main()
	{
	    cin>>a>>b>>c>>d>>e;//他们告诉我们买了几个球和几个盒子。
	    for(int i=0;i<=min(a,b);i++)//从0到ab中小的一个
	    {
	        maxx=max(maxx,(a-i)*c+(b-i)*d+i*2*e);//开始我们的游戏时间\(^o^)/
	    }
    	cout<<maxx;//输出我们最多可以拿到的分。

    	return 0;
	}

---


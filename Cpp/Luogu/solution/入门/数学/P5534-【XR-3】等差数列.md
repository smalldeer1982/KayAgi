# 【XR-3】等差数列

## 题目描述

小 X 给了你一个等差数列的前两项以及项数，请你求出这个等差数列各项之和。

等差数列：对于一个 $n$ 项数列 $a$，如果满足对于任意 $i \in [1,n)$，有 $a_{i+1} - a_i = d$，其中 $d$ 为定值，则称这个数列为一个等差数列。

## 说明/提示

【样例 $1$ 说明】

这个等差数列为 `1 2 3`，其各项之和为 $6$。

## 样例 #1

### 输入

```
1 2 3
```

### 输出

```
6
```

## 样例 #2

### 输入

```
-5 -10 5
```

### 输出

```
-75
```

# 题解

## 作者：Tarsal (赞：50)

我又双叒叕被包菜辣！

[题目](https://www.luogu.org/problem/P5534)

这道题是不久前的考试题，~~现在来水一篇题解~~

#### 扯回正题

题目很明显的告诉你了，这是一个等差数列，

然后，还告诉你了首项， 第二项， 项数。 ~~你还想咋滴~~

告诉了你首项和第二项，相减不就是公差？

现在，你知道了你个等差数列的首项，公差和项数，要你求它各个项的和。~~套公式就行了啊~~

先摆出公式：

公式一：Sn = (a1 + an) × n / 2;

公式二：Sn = n × a1 + n × (n - 1) × d / 2;

我们看看应该用哪个公式？

因为我们已知n, d, a1;

所以我们用第二个公式会更好一些。

那么下面~~证明一下~~

枚举整个数列：

a1, a2, a3, a4, … a(n - 1), an;

把他们全部用a1 和 d替换fn：

a1, (a1 + d), (a1 + 2d), … (a1 + d × (n - 2)), (a1 + d × (n - 1));

再倒过来gn？

(a1 + d × (n - 1)), (a1 + d × (n - 2)), … (a1 + 2d),(a1 + d), a1;

我们看看，f1 + g1 == f2 + g2 == f3 + g3;

那么，我们尝试把他们相加，即为2 * s：

a1 × n × 2 + (n - 1) × d × n;

然后除以2不就是s吗？

s = a1 × n + n × (n - 1) × d / 2;

发代码辣：

```cpp
#include<bits/stdc++.h>//万能头万岁！
using namespace std;

#define int long long//不开long long见祖先
int head, nxt, n, d;
// head是首项， nxt 是第二项， n是项数

signed main()
{
    scanf("%lld%lld%lld", &head, &nxt, &n);//输入
    d = nxt - head;//求公差。
    printf("%lld", n * head + n * (n - 1) * d / 2);//套公式
    return 0;
}
```
~~Ps：请看懂再抄qwq~~

---

## 作者：花花公纸他爹 (赞：31)

大家好，我是花花公纸他爹（世纪末彼岸花中的死之结界），没错就是那个人见人爱，花见花开的花花公纸他爹（世纪末彼岸花中的死之结界）。你是不是对即将到来的讲解十分期待与激动呢？我也是的。废话不多说，我们开始吧！


这是一道线段树的模板题

直接套板子

详细请见代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read()//快读 
{
  char ch;ll f=1;
  while((ch=getchar())<'0'||ch>'9')
   if(ch=='-')f=-1;
  ll res=ch-48;
  while((ch=getchar())>='0'&&ch<='9')
   res=res*10+ch-48;
  return res*f;
}
const int maxn=1000005;
ll n,d;
ll a[maxn],tree[4*maxn],lazy[4*maxn];
void push_up(ll x)//向上传值 
{
  tree[x]=tree[x<<1]+tree[x<<1|1];
}
void push_down(ll sum_l,ll sum_r,ll num)//标记下放 
{
  if(lazy[num]){
  	lazy[num<<1]+=lazy[num];
  	lazy[num<<1|1]+=lazy[num];
  	tree[num<<1]+=lazy[num]*sum_l;
  	tree[num<<1|1]+=lazy[num]*sum_r;
  	lazy[num]=0;
  }
}
void build(ll l,ll r,ll num)//建树 
{
  if(l==r){
  	tree[num]=a[l];
  	return;
  }
  ll mid=(l+r)>>1;
  build(l,mid,num<<1);
  build(mid+1,r,num<<1|1);
  push_up(num);
}
void updata(ll l,ll r,ll add_l,ll add_r,ll k,ll num)//更新1~n值 
{
  if(add_l<=l&&add_r>=r){
  	tree[num]+=(r-l+1)*k;
  	lazy[num]+=k;
  	return;
  }
  ll mid=(l+r)>>1;
  push_down(mid-l+1,r-mid,num);
  if(add_l<=mid)
   updata(l,mid,add_l,add_r,k,num<<1);
  if(add_r>mid)
   updata(mid+1,r,add_l,add_r,k,num<<1|1);
  push_up(num);
}
ll ask(ll l,ll r,ll ask_l,ll ask_r,ll num)//询问1~n的值 
{
  ll ans=0;
  if(ask_l<=l&&ask_r>=r)
   return tree[num];
  ll mid=(l+r)>>1;
  push_down(mid-l+1,r-mid,num);
  if(ask_l<=mid)
   ans+=ask(l,mid,ask_l,ask_r,num<<1);
  if(ask_r>mid)
   ans+=ask(mid+1,r,ask_l,ask_r,num<<1|1);
  return ans;
}
int main(){
 a[1]=read(),a[2]=read(),n=read();//读入 
 d=a[2]-a[1];//公差 
 for(ll i=3;i<=n;i++)a[i]=a[i-1]+d;//记录每个项的值 
 build(1,n,1);//建树 
 printf("%lld",ask(1,n,1,n,1));//输出1~n的值 
 return 0;
}
```



---

## 作者：JimmyF (赞：22)

~~哈哈，小学生来发题解啦！~~

好了，废话不多说，让我们进入正题。

首先，题目给了你一个等差数列的前两项以及项数，让我们求出这个等差数列各项之和。

复习一下求等差数列的公式：（首项+末项）* 项数/2

现在我们知道了首项和项数，就应该把末项求出来，那求末项的公式就是：首项+公差 * （项数-1）

原理是：将等差数列反转一下，奥秘自然就会解开。

举个例子：

1 2 3 4 5 6 

6 5 4 3 2 1

我们发现每一数列的和就是7，而7就是首项+末项，然后有n项，就*n，然后算出两个等差数列的各项和，除2就是我们求的一个等差数列的各项和。

上代码：
           

    #include<iostream> //调用标准输入输出文件头
    using namespace std;
    long long n,a,b；//定义变量，记住开long long
    int main()
    {
        cin>>a>>b>>n;  //;读入
        cout<<(a+(n-1)*(b-a)+a)*n/2; //套公式
        return 0; //华丽地结束9行的代码
    }

---

## 作者：wpy233 (赞：14)

哇，本萌新看到“【XR-3】”这个东东，不禁想起了一些什么→_→

（请耐心看完，准备好可乐和爆米花）

话不多说，让我们来看题。题目好像就是给你一个等差数列的前两项和项数，让你求总和。

萌新~~(作者)~~：woc，这个$10^6$对我们好友好啊！暴力，上！
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
	long long a1,a2,n;
	cin>>a1>>a2>>n;//输入
	long long p=a2-a1;//公差
	long long ans=a1+a2;//前两项之和先加上
	for(int i=3;i<=n;i++)
	{
		a2+=p;//每次加上一个公差，处理出第i项
		ans+=a2;//累加
	}
	cout<<ans<<endl;//输出
	return 0;
}
```
是的，不出意外地，$AC$了。。。

大佬：woc，好题呀！刚学的通项公式正愁没出上呢~

这里涉及到了两个问题：
```
①已知公差与首项，如何求末项。
②已知首项与末项，如何求总和。
```
先看第①个问题，由于首项与末项相差了$n-1$个公差，所以。。。末项=首项+公差*（项数-1）；

再看第②个问题，~~这就不用解释了吧~~，小学森都知道，总和=（首项+末项）*项数/2。
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long a1,a2,n;
	cin>>a1>>a2>>n;
	long long p=a1+(a2-a1)*(n-1);//求末项
	long long ans=(a1+p)*n/2;//求和
	cout<<ans<<endl;//输出答案
	return 0;
}
```
是的，又不出意外地，又$AC$了。。。

神犇（例如北京某五年级吊打初中数学联赛的童鞋）：woc，这做完了呀！

蒟蒻：？？？
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long a1,a2,n;
	cin>>a1>>a2>>n;
	long long p=a2-a1;//处理出公差
	long long ans=a1*n+p*n*(n-1)/2;//神仙部分
	cout<<ans<<endl;//输出
	return 0;
}
```
是的，这神仙代码又双叒叕$AC$了！

这究竟是为什么呢？

例如下面这个等差数列：`2 6 10 14`
```
2 6 10 14 //先提取出一个首项
0 4 8 12
0 1 2 3 //剩余的公差个数
```
嗯，看到这里，我~~相信~~你已经懂了。

不仿设项数为n,公差为p,首项为s

则答案为$s*n+p*(1+n-1)*(n-1)/2$

化简一下，即得神仙部分。

啊呀，写完了，赶紧去~~刷水题咯~~

---

## 作者：林昱凯 (赞：14)

# 蒟蒻来发题解啦 P5534
### 敲黑板 等差数列求和公式（其一）：
### （首项+末项）*项数/2

- 首项:题目中的a1；
- 公差:题目中的d,d为(a2-a1)；
- 末项:首项+公差*(n-1)；
- 项数:题目中的n；

末项的得出：因为首项每靠近末项1个单位，该项将加1个公差也就是（a2-a1）。因为末项是从首项开始加的，所以要乘上项的个数减去首项的个数也就是（n-1）。所以的所以末项=a1+（a2-a1）*(n-1)。

AC代码：
```
#include<bits/stdc++.h>//万能头文件 
using namespace std;
long long a1,a2,n;//题目输入 
long long h,s,m;//h是和，s是首项,m是末项 
int main(){
    cin>>a1>>a2>>n;//读入 
    s=a1;//首项
    m=a1+(a2-a1)*(n-1);//末项
    h=(s+m)*n/2;//利用等差数列求和公式 
    cout<<h;//输出 
    return 0;//结束 
} 
```

AC代码（无注释）：
```
#include<bits/stdc++.h>
using namespace std;
long long a1,a2,n,h,s,m;
int main(){
    cin>>a1>>a2>>n;
    s=a1;
    m=a1+(a2-a1)*(n-1);
    h=(s+m)*n/2;
    cout<<h;
    return 0;
} 
```

## 蒟蒻的第一篇题解
## 管理员求过，请看官留下个赞哦~~

---

## 作者：　　　吾皇 (赞：5)


在等差数列中，有如下性质[传送门](https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/1129192?fr=aladdin)
### 题目分析
```
由于这边给出了首项和第二项及项数 我们可以利用首项和第二项先求出公差 再利用项数和公差求出末项 再利用等差数列求和公式求出等差数列的和
```
### 代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll yi,er,cha,xiang,mo,ans;
int main(){
	cin>>yi>>er>>xiang;//为方便理解 所有变量名都为中文拼音
	cha=er-yi;//求出公差
	mo=yi+(xiang-1)*cha;//求出末项
	ans=(yi+mo)*xiang/2;//这边也可以for循环求和
	cout<<ans;//输出结果
}
```

---

## 作者：caijunrui (赞：3)

[P5534](https://www.luogu.org/problem/P5534)

这是一道真正的水题（不知道我为什么点到了这题）

但为什么有31个测试点qwq？

思路也够简单--就是等差数列求和；

于是，从老师黑板上搬出两块砖：


>求和公式：S和 = (a1 + an) × n / 2;

>末项公式：Sn = a1 + (n - 1) * d;

话不多说，上代码！


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long n,m,k,t;// n为首项；m为末项；k为项数；
        //一定要用long long;int 就只有8个点对！
	cin >> n >> m >> k;
	t=n+(m-n)*(k-1);//计算末项
	cout << (n+t)*k/2;//输出总和
	return 0;
}
```


---

## 作者：zzx0826 (赞：2)

# 1.[题目](https://www.luogu.org/problem/P5534)
# 2.题目分析
题意：给出一个[**等差数列**](https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/1129192?fr=aladdin)的项数$n$,第一项$a_{1}$,第二项$a_{2}$,求等差数列的和$s$

此题有两种解法:

**第一种解法**:暴力(~~朴素算法~~)

**第二种解法**:小学奥数，推公式
# 3.第一种解法
顾名思义，等差数列的和$s$其实就是把这个等差数列$a_{1},a_{2},a_{3}......a_{n}$的和$\sum\limits_{i=1}^na_{i}$

而我们又知$a_{1},a_{2}$,所以可以求得等差数列的公差$d$=$a_{2}-a_{1}$

初始化$s=a_{1}+a_{2}$,$sum=a_{2}$($sum$为当前这个数)

从第3个数到第$n$个数,每次先将$sum+=d$,计算出当前项的值,再将$s+=sum$

最终答案即为$s$

**Code**:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a1,a2,n;
int main()
{
	cin>>a1>>a2>>n;
	long long d=a2-a1,s=a1+a2,sum=a2;//注意此处要用long long
	for(int i=3;i<=n;i++)
	{
		sum+=d;
		s+=sum;
	}
	printf("%lld",s);
	return 0;
}
```
------
# 第二种解法

由~~小学奥数~~知,等差数列的和$s$=($a_{1}+a_{n}$)*$n$/2,而$a_{n}$=$a_{1}$+$d$ *($n$-1),所以代码就很好写了

**Code**:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a1,a2,n;
int main()
{
	cin>>a1>>a2>>n;
	long long d=a2-a1;
	long long e=a1+(n-1)*d;
	printf("%lld",(a1+e)*n/2);
	return 0;
}
```
# 4.总结
综上所述，此题只需掌握等差数列的基本知识即可,~~还是挺水的~~.

---

## 作者：Cylete (赞：2)

# 签到题（~~适合本蒟蒻~~）

这道题有两种解法

第一：

直接模拟

反正数据小

第二：

用等差数列求和

根据前两项的值算出公差，就可以求出第n项，然后用等差数列求和公式计算即可，时间复杂度 O(1)

附上代码（~~好丑啊~~~~）

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
long long a1,a2,n,hh;
int main(){
	scanf("%lld%lld%lld",&a1,&a2,&n);
	hh=a2-a1;
	hh=(n-1)*hh+a1;
	cout<<(a1+hh)*n/2<<endl;//直接公式计算
	return 0;
}
```


---

## 作者：59percent (赞：1)

###### 做水题的时候突发奇想
求和？区间和？区间维护？线段树？

尝试了一下发现真的可以

只要把题目变成求1~n的区间和

利用等差数列通项公式$an = a1 + (n - 1) * d$将数列做出来

就可以愉快地使用线段树来求和了

既然是区间求和（~~强行变成区间求和~~），那就开始吧
```cpp
#include <iostream>
#define int long long

using namespace std;

struct Node {
    int L, R, sum, tag;

    int len() {
        return R - L + 1;
    }
};

const int inf = 0x3f3f3f3f;
const int N = 1e6 + 5;
int n, m, a[N], a1, a2, d;
Node tree[4 * N];

void pushUp(int k) {
    tree[k].sum = tree[2 * k].sum + tree[2 * k + 1].sum;
}

void build(int L, int R, int k) {
    tree[k].L = L, tree[k].R = R;
    if(L == R) {
        tree[k].sum = a[L];
        return;
    }
    int mid = (L + R) / 2;
    build(L, mid, 2 * k);
    build(mid + 1, R, 2 * k + 1);
    pushUp(k);
}

void saveTag(int k, int tag) {
    tree[k].tag += tag;
    tree[k].sum += tree[k].len() * tag;
}

void pushDown(int k) {
    saveTag(2 * k, tree[k].tag);
    saveTag(2 * k + 1, tree[k].tag);
    tree[k].tag = 0;
}

void update(int k, int x, int y, int w) {
    int L = tree[k].L, R = tree[k].R;
    if(y < L || x > R) return;
    if(x <= L && y >= R) {
        saveTag(k, w);
        return;
    }
    if(tree[k].tag)
        pushDown(k);
    int mid = (L + R) / 2;
    if(x <= mid)
        update(2 * k, x, y, w);
    if(y >= mid + 1)
        update(2 * k + 1, x, y, w);
    pushUp(k);
}

int querySum(int k, int x, int y) {
    int L = tree[k].L, R = tree[k].R;
    if(x <= L && y >= R)
        return tree[k].sum;
    if(tree[k].tag)
        pushDown(k);
    int ans = 0;
    int mid = (L + R) / 2;
    if(x <= mid)
        ans += querySum(2 * k, x, y);
    if(y >= mid + 1)
        ans += querySum(2 * k + 1, x, y);
    return ans;
}

signed main() {
    cin >> a1 >> a2 >> n;
    d = a2 - a1;
    for(int i = 1; i <= n; i++)
        a[i] = a1 + (i - 1) * d;
    build(1, n, 1);
    cout << querySum(1, 1, n) << endl;
    return 0;
}
```
一颗线段树完美的结束了

---

## 作者：TomTheCat (赞：1)

# 发现没有Python题解！
其实这道题目用Python列表+循环来做超简单。

具体代码如下：

------------
```python
a=input().split()
a[0]=int(a[0])
a[1]=int(a[1]) # 不想写循环
n=a[1]-a[0] # 公差
arr=[a[0],a[1]]
for value in range(2,int(a[2])):
    arr.append(arr[value-1]+n) 
    # 每一项都是前一项加上公差
    
# 现在arr里面存的就是我们想要的等差数列啦
print(sum(arr)) # Python有sum()函数，比C++方便多了
```
------------
$tips$: Python是自带高精的语言，所以数据范围就不用管了。

$ps$: 本蒟蒻有什么写的不好的地方，请多多指教！

---

## 作者：骗分过样例 (赞：1)

# 这道题很良心。
代码中，我们要用一个变量来储存差，一个来储存当时要加的数。我用了暴力出奇迹，骗分过样例，用公式会更快一些哟！！

公式：首项+（项数-1）×公差=末项

（首项+末项）×项数÷2=和

代码1：暴力出奇迹。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long a,b,n,total=0,tmp,k;
	cin>>a>>b>>n;
	total=a+b;
	k=b-a;
	tmp=b;
	for(int i=1;i<=n-2;i++)
	{
		total+=(tmp+=k);
	}
	cout<<total;
	return 0;
}
```
代码2：套公式
```cpp
#include<bits/stdc+++.h>
using namespace std;
int main()
{
	long long a,b,n;
	cin>>a>>b>>n;
  	long long tmp=a+(b-a)*(n-1);
  	cout<<(a+tmp)*n/2;
  	return 0;
}
```


---

## 作者：_Herobrine_ (赞：1)

# 这道题好简单啊~~~
~~肯定有人傻傻的用循环~~
## ~~用等差数列求和公式不就好了~~
学过奥数的好处...
```
//防抄标签
#include<bits/stdc++.h>
using namespace std;
int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);//流优化
	long long a1=0,a2=0,n=0,mx=0/*定义末项*/;
	cin>>a1>>a2>>n;//输入数据
	mx=a1+(n-1)*(a2-a1);//求末项的公式
   	//末项=首项+(项数-1)*公差
	cout<<(a1+mx)*n/2;//等差数列求和公式
    	//(首项+末项)*项数/2
	exit(0);//开心的结束
}
```


---

## 作者：jeffyang (赞：1)

其实这道题不难，~~可是我去做了两次才A~~ 有很多种解法，基本思路是用**等差数列的求和公式：**
![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2838679063,299287394&fm=58)

通俗的说就是：**首项加末项的和乘项数除以二**；

### 为什么呢？证明如下：

设首项为![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D14/sign=6723c2fff703738dda4a0826b21ba4c7/b3119313b07eca80bb1a84b8902397dda1448356.jpg), 末项为![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D15/sign=03b9d952279759ee4e5064ceb3fb97e6/f2deb48f8c5494eefb5cb2462cf5e0fe99257e76.jpg), 项数为![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D9/sign=468232cecc11728b342d8013c83b19/a8014c086e061d959df98a677af40ad162d9ca36.jpg), 公差为![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D13/sign=936e114abd315c6047956fec8cb10fb3/78310a55b319ebc4c4d5cbc68326cffc1e17163b.jpg), 前![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D9/sign=468232cecc11728b342d8013c83b19/a8014c086e061d959df98a677af40ad162d9ca36.jpg),项和为![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D15/sign=e9b82a5b5882b2b7a39f3dc130addb1d/9345d688d43f8794ec3efa71d31b0ef41ad53aaf.jpg), 则有

![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D847/sign=39f880b160224f4a53997e173ef69044/14ce36d3d539b600b1f0f920e450352ac65cb76f.jpg)


### 人话版本：
对于等差数列N，当N的项数n为奇数时，取第(n+1)/2个数k，(即最中间的数)。可以发现，当在数列中把它去掉时，数列的元素a1与a(n-1)，a2与a(n-2)......和均为k，可得和为k*n/2；

k又为(a1+an)/2,故此得证

当N的项数n为偶数时，易证，不多废话。



------------


第一次代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int s,a1,a2,an,n,c;
int main()
{
    cin>>a1>>a2>>n;
    c=a2-a1;
    an=a2;
    for(int i=3;i<=n;i++)
    {
        an=an+c;
    }
    s=(a1+an)*n/2;
    cout<<s;
    return 0;
}
```

知道哪里错了吗

没开long long

注意数据范围
注意了这点，做这道就很容易了

```cpp
    cin>>a1>>a2>>n;//输入
    c=a2-a1;//求公差

    an=a2;
    for(int i=3;i<=n;i++)
    {
        an=an+c;
    }//求末项（其实可以用公式）

    s=(a1+an)*n/2;//公式求和
```

最后完整AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;

long long s,a1,a2,an,n,c;

int main()
{
    cin>>a1>>a2>>n;
    c=a2-a1;
    an=a2;
    for(int i=3;i<=n;i++)
    {
        an=an+c;
    }
    s=(a1+an)*n/2;
    cout<<s;
    return 0;
}
```





------------
tips：这篇题解原版来自同机房的chengyue2用户，经过同意之后，进行改进，故发此题解。

---

## 作者：fzh001 (赞：1)

本蒟蒻再来写一篇~~水题~~

等差数列应该是小学的知识了吧

基本公式：

首项+末项* 项数/2 

末项=首项+（项数-1）* 公差
        
只要求的几要素即可计算

上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
long long first,next,n,d,last; 
int main()
{
	cin>>first>>next>>n;//输入首项，下一项，项数
	d=next-first;//公差计算
	last=first+(n-1)*d;//末项计算
	cout<<(first+last)*n/2;//按公式输出
	return 0;//结束
}
```




---

## 作者：auroral (赞：1)

XR-3的~~唯一~~一道水题，只要拥有一定的数学知识即可AC

如果你没有等差数列的相关知识储备请前往[这里](https://baike.so.com/doc/5402746-5640432.html)

附上AC代码
```cpp
#include<iostream>
#define ll long long
using namespace std;
ll a1,a2,n;
int main(){
	cin>>a1>>a2>>n;
	ll d=a2-a1;//计算差值
	cout<<n*a1+n*(n-1)/2*d;//等差数列公式
	return 0;
}
```


---

## 作者：只以 (赞：1)

###### 其实这题肥肠简单，~~学过小学的~~应该人人都能做出来

道理其实超级简单，公差d=a[n]-a[n-1],a[n]=a[n-1]+d

所以，知道了前两项和项数，就能求出公差和每一项

代码：
```
#include<bits/stdc++.h> 
#define LL long long//宏定义 
using namespace std;
LL a1,a2,n,D,a[1000000],ans;//第一项、第二项、项数、公差、每一项、总和 

inline LL read(){//快读 
    int x=0,f=1;
    char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-')
            f=-1;
        ch=getchar();      
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int main(){
	a1=read(),a2=read(),n=read();//读入 
	D=a2-a1;//求公差 
	/*
	因为数组下表是从0开始的
	所以在递推时，a[0]与要求得的第一个数a[2]无关，所以没必要放入数组 
	*/ 
	a[1]=a2;//赋值 
	ans+=a1+a2;//先加上前两项 
	for(int i=2;i<=n-1;i++){
		a[i]+=a[i-1]+D;//求出a[i]，并为下一次循环求出a[i+1]做准备 
		ans+=a[i];//累加 
	}
	printf("%lld",ans);//输出 
    return 0;//世界和平 
}
```


---

## 作者：琢玉扬灵 (赞：1)

这道题用得其实是高中还是初中的知识，本蒟蒻特意复习了一下，
等差数列：
首先，等差数列是常见数列的一种，如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，这个数列就叫做等差数列，而这个常数叫做等差数列的公差，公差常用字母d表示。
通项公式为：an=a1+(n-1)d。 
前n项和公式为：Sn=a1n+[n*(n-1)d]/2（首项加末项乘以项数除以二），另外需要注意数组范围，之前用的int直接一片红。
题解代码
```
ll a,b,d,sn,n,endd;
int main()
{
    cin>>a>>b>>n;
    d=b-a;
    endd=a+(n-1)*d;
    sn=(a+endd)*n/2;
    cout<<sn<<endl;
    return 0;
}

---

## 作者：Azazеl (赞：1)

[在$TA$的$blog$查看](https://www.luogu.org/blog/1-2-1/solution-p5534)  

------------

天哪，居然没有题解，蒟蒻情何以堪。  


------------
好吧，这道题不是很难。只要你知道这些：

设有一长为$n$等差数列${a}$  
求和：$(a_1+a_n)*n/2$，即$($首项$+$末项$)*$项数$/2$ 

求项数：$(a_n-a_1)/(a_2-a_1)+1$，即$($末项$-$首项$)/$公差$+1$

求末项:$a_1+(a_2-a_1)*(n-1)$,即首项$+$公差$*($项数$-1)$

好吧，知道了这些，还有什么难的呢？  
我们可以先求出末项,然后求和。
嗯，没了，上代码 （我才不会告诉你不开$\color{Maroon}long$  $\color{Maroon}long$会见祖宗）
```cpp
#include <cstdio>
int main() {
	long long a1,a2,n,an;
	scanf("%lld %lld %lld",&a1,&a2,&n);
	an=a1+(a2-a1)*(n-1);
	printf("%lld",(a1+an)*n/2);
	return 0;
}
```
嗯，开学前又水了一篇题解。溜了溜了，复习开学考试了。

---

## 作者：StudyingFather (赞：1)

给出了序列的前两项，我们可以算出等差数列的公差 $d=a_2-a_1$。

进而可以根据通项公式，算出等差数列的末项 $ a_n=a_1+(n-1) \times d$。

有了首项，末项和项数，我们就可以根据公式 $S=\dfrac{(a_1+a_n) \times n}{2}$ 算出整个序列的和了。

因为代码过于简单，这里略去。

---

## 作者：EliYang (赞：1)

小蒟蒻终于等到一到没有大佬写过题解的题了！

这道题含义说明白，就是：一个等差数列，给出前两项和项数，求和。

首先，我们要明白几个公式：

（1）d（公差）= a2（第二项）- a1（首项）

（2）an（第n项）= a1 + d * （n（项数）- 1）

（3）s（总和）= （a1 + an）* n / 2

因此，我们可以先求出d，再求出an，就可以得到答案s了。
本蒟蒻的C++代码：
```cpp
#include <iostream>
using namespace std;
int main()
{
	long long a1,a2,n,d,an,ans;
	cin >> a1 >> a2 >> n;
	d = a2 - a1;
	an = a1 + d * (n - 1);
	ans = (a1 + an) * n / 2;
	cout << ans;
	return 0;
}
```

---

## 作者：chenchaopeng (赞：1)

### 这就是一道经典的等差数列题，只不过最后改成了求前n项的和。

#### 下面，开始说一下我的思路：
首先，输入a和b，然后求出这个等差数列每两项的何等差值；

然后，输入n，（即求出前n项的和）；

接下来，便是模拟，依次求出前n项，并求和，过程如下：

```cpp
cin>>a>>b>>n;
c=b-a;
s=a+b;
for(int i=3;i<=n;i++)
   {
	  b+=c;
	  s+=b;
   }
```
最后，便是输出：

```cpp
cout<<s;
```
#### 好了，废话不多说，开始上代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long  a,b,c,n;
long long s;//要用long long类型，不然会超限！！！ 
int main()
{
	cin>>a>>b>>n;//输入； 
	c=b-a;//求差值； 
	s=a+b;//初始化 ； 
	for(int i=3;i<=n;i++)
	   {
	   	b+=c;
	   	s+=b;
	   }//模拟； 
	cout<<s;//输出。 
	return 0;
}
```
#### 最后，祝大家编程顺利！

---

## 作者：konglk (赞：0)

等差数列求和公式（a1+an)*n/2 想必大家都知道，引用在这道题上只需要知道an（末项）是多少就行了 an又等于a1+(n-1)*d，d=a2-a1，整体思路就有了。下面是我一开始的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a1,a2,n;
	cin>>a1>>a2>>n;
	int d=a2-a1,al=a1+(n-1)*d;
	//cout<<a1<<" "<<al<<" "<<d;
	cout<<(a1+al)*n/2;
}

```
WA了好几个点，下载了测试点三的数据（下面给出输出结果）
```
411336435348397040

```
貌似该用long long，便写出了AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long a1,a2,n;
	cin>>a1>>a2>>n;
	long long d=a2-a1,al=a1+(n-1)*d;
	//cout<<a1<<" "<<al<<" "<<d;
	cout<<(a1+al)*n/2;
}
```
希望能够帮助到大家，自认为还算好理解

---

## 作者：你锡白大爷 (赞：0)

### 这题算是[XR-3]系列的唯一一道水题
## ~~小学奥数党的福音啊！~~
# 啊！伟大的高斯小哥哥
## 重点来了要考的！
- **和＝（首项＋末项）×项数÷2**
- **项数＝（末项-首项）÷公差＋1**
- **首项=2和÷项数-末项**
- **末项=2和÷项数-首项**
- **末项=首项+（项数-1）×公差**

是的就是他们，咱们只要套公式做就能AC了

### 对了对了，
## 不要扯什么long double！long long 就可以了！不然输出会很玄学
**好了，**~~水了~~**辣么多，是时候上AC代码了！**

呐，你们要的代码 ~~**【看懂再抄】**~~
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long a1,a2,n,last,gc,sum;
  //从左到右首项，第二项，项数，尾项，公差，和~~~
    cin>>a1>>a2>>n;//如题所述，输入
    gc=a2-a1;//求公差
    last=a1+(n-1)*gc;//求尾数
    sum=(a1+last)*n/2;//求和
    cout<<sum; //输出
    return 0;//完结撒花花~~~
}
```
~~**_就是这个鸭子，很简单对不对？_**~~   

---

## 作者：Forest_Prince (赞：0)

# 这题不难
###### 废话！难了的话就不是入门了。。。



------------
我一看！这题的测试数据不是很大

俗话说的好，暴力出奇迹

我们再应用一下这个打表的方法？？

先用一个数组a来存算的数，然后算到要算的等差数列的最后一项

用一个变量来从头加到尾，至于为什么，去看洛谷新手村循环部分


```cpp
#include<bits/stdc++.h>
#define ll long long	//总之不开long long就。。。
#define _ 0 
#define itn int
#define amin main 
//防手滑 
using namespace std;
ll a[1000000+5];
itn amin(){
	ll a1,a2,a3,temp,ans=0;//temp用来记录差值 ans来记录答案
	cin>>a1>>a2>>a3;
	temp=a2-a1;a[1]=a1;a[2]=a2;
	for(int i=3;i<=a3;i++){
		a[i]=a[i-1]+temp;//算数据 
	}
	for(int i=1;i<=a3;i++){
		ans+=a[i];
	}
	cout<<ans; 
    return ~~(0^_^0); //皮一下~~
} 
```


---

## 作者：Aw顿顿 (赞：0)

### 数论公式直推
~~~
这道题属于比赛题

一开始我看到这道题，觉得很简单，

事实证明我还是想的不够全面
~~~

首先是模拟，通过数组来递推（dp？），其核心思想如下：

1. 先算出等差数列的公差

2. 通过公差将所有项都求出来，存在数组中

3. 然后通过for循环求和

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,s[1001],ans=0;
int main()
{
	cin>>a>>b>>d;
	ans+=a;
	ans+=b;
	c=b-a;
	s[0]=a;
	s[1]=b;
	for(int i=2;i<d;i++)
	{
		s[i]=s[i-1]+c;
		ans+=s[i];
	}
	cout<<ans;
	return 0;
}
```
这个代码还是不够精简，虽然这是二次修改版本；

因为直接模拟，基本上除了数据较小的以外都RE了

然后就有了下一个版本：数学方法
~~~
我们知道，等差数列是有求和公式的，这里普及一下：

（首项+末项）×项数÷2=等差数列求和结果

当中项数本来还有一个公式：

（末项-首项）÷公差+1=项数

但是因为题目已经给出了项数，所以我们没有必要求
~~~
然后代码如下

其核心思想为

1. 通过第二个数-前一个数求出公差

2. 通过ans=a+(d-1)*c求出末项，之所以要用d-1是因为a已经是第一项了，只需要加n-1个公差（n为项数时）

3. 然后套用公式

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,ans=0;
int main()
{
	cin>>a>>b>>d; 
	c=b-a;
	ans=a+(d-1)*c;
	ans=(a+ans)*d/2;
	cout<<ans;
	return 0;
}
```
但是我一看评测结果，妈呀，万WA从中一点AC

咋们回事？？

我想，时间上没有问题，过程上没毛病，要么爆栈要么越界

于是我看了一下数据范围

10^6，没有超int啊？怎么回事？？

原来因为求和的时候，和不局限于10^6，会远超int

于是我就开了O2，用了longlong，就AC啦！！

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,ans=0;
int main()
{
	cin>>a>>b>>d; 
	c=b-a;
	ans=a+(d-1)*c;
	ans=(a+ans)*d/2;
	cout<<ans;
	return 0;
}
```
请看懂题解，不要抄袭！！！

---

## 作者：zhaowangji (赞：0)

题目给你的是整数！整数！整数！

直接long long,别给我整什么long double~~不然输出就很玄学~~

小高斯告诉我们了等差数列求和公式：

（首项+末项）X项数/2

末项=首项+公差X（项数-1）

~~说实话我都快忘了打一次写还写错了该去四年级进修下~~

```cpp
#include<iostream>
using namespace std;
long long x,y,z;//首项，第二项，末项
long long n;//项数
long long ans;//答案
int main(){
	cin>>x>>y>>n;//正常读入
	if(n==2){cout<<x+y<<endl;return 0;}
        //如果只有两项就直接输出
	z=x+(n-1)*(y-x);//算末项
	ans=(x+z)*n/2;//算总和
	cout<<ans<<endl;//输出
	return 0;
}
```


---

## 作者：Crab_Dave (赞：0)

纯暴力都可以过这道题诶qwq...

sum存储各项之和，c代表公差，第i项的值为 (i-2) * c + b。

我们对于每一项进行递推，用sum求和就可以啦~

↓详见以下代码↓
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;

long long a,b,c,n,sum;//要开long long！！！

int main()
{
	scanf("%lld%lld%lld",&a,&b,&n);//long long用lld输入
	sum=a+b;c=b-a;//sum存储各项之和，c代表公差
	for(register int i=3;i<=n;i++)//我们已经处理了1和2，所以从3开始递推
		sum+=(i-2)*c+b;//第i项的值为(i-2)*c+b
	printf("%lld",sum);//输出答案
	return 0;//功德圆满
}
```


---

## 作者：li_jing_hao (赞：0)

## 奥数党都会的公式：
### 啊！伟大的高斯！

# 重点来了！
##### 和＝（首项＋末项）×项数÷2 
##### 项数＝（末项-首项）÷公差＋1 
##### 首项=2和÷项数-末项
##### 末项=2和÷项数-首项
##### 末项=首项+（项数-1）×公差、

```
#include <bits/stdc++.h>
using namespace std;

long long int a,b,n,last,d,ans;//不开long long就炸了

int main ()
{
	cin >> a >> b >> n;
	
	d = b - a;
	last = a + ( n - 1 ) * d;
	ans = ( a + last ) * n / 2;//公式在前面，自己看
	
	cout << ans << endl;
	
	return 0;//so easy!
	
}
```


---

## 作者：紫老太ITVwerjhytb (赞：0)

~~高中or初中or小学学过等差数列的人应该都知道公式吧~~

Sn=a1 * n + ( n * ( n - 1 ））/2* d（d是公差，a1是初始项）

~~所以直接用就行了。~~
```
a2=a1+d,a3=a2+d=a1+2*d;
so 通项很容易推出来:an=a1+(n-1)*d;
而Sn是指前n项的和。
S1=a1,S2=S1+a2=2*a1+d,S3=S2+a3=3*a1+3d;
多写几个便能知道通项 Sn=a1*n+(n*(n-1））/2*d；
```
```
#include <bits/stdc++.h> //万䘅头文件
using namespace std;
int main(){
    long long a,b,c,d,e;
    cin>>a>>b>>c; //输入
    d=b-a; //记录公差
    e=a*c+(c*(c-1))/2*d; //公式
    cout<<e; //输出
}
```
over

---

## 作者：AK_黄铮_IMO (赞：0)

# 这题就是签到题；
# 暴力一把，就算你数学不好也能AC
```cpp
#include<iostream>
using namespace std;
int main(){
	int a,b,c;
	cin>>a>>b>>c;
	long long sum=0;// 不开long long 你AC不了
	sum=sum+a+b;  开始的两项；
	long long d[c-2];因为有c项，前两项不包括，只算c-2项
	for(int i=0;i<c-2;i++){
		if(i==0){
			d[i]=b+(b-a);开始项 特殊判定
		}
		else{
			d[i]=d[i-1]+(b-a);后面直接加到公差；
		}
		sum+=d[i];加上d[i]
	}
	cout<<sum<<endl;
} 
```


---

## 作者：小小小朋友 (赞：0)

#### 题目描述:

等差数列求和，很水的题

#### 思路:

求出末位，在通过公式直接算即可。注意开~~该死的~~ $longlong$。

末位为$(b-a)\times(c-1)+a$

所以答案即为$(a+(b-a)\times(c-1)+a)\times c/2$

#### 代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c;
int main(){
	scanf("%lld%lld%lld",&a,&b,&c);
	printf("%lld",(a+(b-a)*(c-1)+a)*c/2);
	return 0;
}
```

---

## 作者：颓废的鲈鱼 (赞：0)

这是一道基本的等差数列~~水~~题，只要知道公式就可以了

$a_{n}$=$a_{1}$+(n-1)*d

求和公式：($a_{1}$+$a_{n}$)*n/2

其中$a_{n}$为末项，$a_{1}$为首项，n为项数，d为公差

于是就有了这段代码：
```cpp
#include<iostream>
using namespace std;
int main(){
    int fir,sec,xs,mx,gc;
    cin>>fir>>sec>>xs;
    gc=sec-fir;
    mx=fir+(xs-1)*gc;
    cout<<(fir+mx)*xs/2;
    return 0;
}
```

~~愉快地~~对了8个点，~~不要问我是怎么知道的~~，看看数据范围，加起来int就不够了，所以要用long long。

于是就有了这段AC代码：
```cpp
#include<iostream>
using namespace std;
int main(){
    long long fir,sec,xs,mx,gc;
    cin>>fir>>sec>>xs;	//输入
    gc=sec-fir;		//求出公差
    mx=fir+(xs-1)*gc;	//求出末项
    cout<<(fir+mx)*xs/2;//求和+输出
    return 0;		//结束
}
```

---

## 作者：苏拉威西3号 (赞：0)

### 诶？这题没有提解吗？那我来水一篇好了；

首先，普及一点小学奥数的知识（dalao勿喷），等差数列的求和公式为：（首项加末项）乘公差除以2.

好，既然我们知道了这个公式，那我并不想用它（~~滑稽~~，

其实这个题并不用什么高大上的公式，只要根据等差数列的性质，求出它的每一项再相加就可以了，而且用点小技巧，数组只用开。。。说那么多干嘛，直接看代码好了（具体见注释）

```
#include<cstdio>
#include<iostream>//据说NOIP（现在改名了）不让用万能头 
using namespace std;
long long a[5];
long long ans,sum,n;//为了保险开的long long 
int main()
{
	cin>>a[1]>>a[2]>>n;//正常读入 
	sum=a[2]-a[1];//求出公差 
	ans=a[1]+a[2];//用ans求和 
	for(int i=3;i<=n;i++)//从第3个数开始往后找 
	{
		a[3]=a[2]+sum;//求出来后一项 
		ans+=a[3];//加入总和 
		a[1]=a[2],a[2]=a[3];//将数列中每一项的值前提，抹去第一位，a[3]就是我们要找的下一个值 
	}
	cout<<ans;//常规输出 
	return 0;
}
```
就酱，欢迎批评

---

## 作者：Skyjoy (赞：0)

# 这题就是套等差数列公式而已

众所周知，等差数列中，$S=(a_1+a_n)\times n\div2$，而$a_n=a_1+d\times(n-1)$，$d$是公差，而$d=a_2-a_1$。有了这些公式，代码就出来了：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,a,b,n;
int main(){
	cin>>a>>b>>n;
	b=a+(b-a)*(n-1);//求a[n]
	ans=(a+b)*n/2;//求和
	cout<<ans;
	return 0;
}
```
祝大家2019SCP-CN-CSPrp++！！！

---

## 作者：Alarm5854 (赞：0)

这道题非常的简单~~(不然怎么是红题)~~，不过这题需要开long long，不然就会WA很多点。这题有两种算法，一种$O(n)$，一种$O(1)$，都可以通过本题。
### 方法1：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000001],n,ans;//十年OI一场空，不开long long见祖宗
int main(){
	scanf("%lld%lld%lld",a+1,a+2,&n),ans=a[1]+a[2];
	for(int i=3;i<=n;++i)
		a[i]=a[i-1]+(a[2]-a[1]),ans+=a[i];//把第3~n项拓展出来，并加入ans中
	printf("%lld",ans);
	return 0;
}
```
这种算法可以A掉本题，但是如果改成$n<10^9$，那就会T飞了。
### 方法2：
利用等差数列的性质，先把第1~n项都减去第一项，使得它变成一个每项都加上一个值的序列(当然不减也可以，这样更简单)，再把第一个数加回来，~~但是我太急了，忘记了更简单的一种方法，也没事~~。公式即为$\frac{(b-a)(n-1)n}{2}+an$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,n,ans;
int main(){
	scanf("%lld%lld%lld",&a,&b,&n);
	ans=(b-a)*(n-1)*n/2+a*n;//快速算出ans
	printf("%lld",ans);
	return 0;
}
```
本题的题解到此为止，如果你们A了这题，请给我点个赞，谢谢！

---

## 作者：chinaxjh (赞：0)

# 前言
~~这不是$XR-3$比赛的$T1$吗，怎么也被搬运到洛谷上了~~
# 思路
裸的小学数学题，求等差数列。暴力枚举的时间复杂度是$O(n)$，显然会超时，
~~但地球人都不会用这种方法吧~~
，所以我们用高斯数学巨佬提出来的等差数列求和公式来解决这道题

### 首项 + 末项 * 项数/2=$ans$

~~(懒得用 $latex$ 打公式)~~

但这道题的末项没有给出，只给了前两项，所以我们还要计算末项

### 首项 + 公差 * (项数 - 1)=末项
(项数就是题面中的$n$)

我们就解决了这道大水题
# $AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a1,a2,n,k,ans;
int main()
{
  cin>>a1>>a2>>n;
  k=(a2-a1)*(n-1)+a1;//算末项
  ans=(a1+k)*n/2;//套用公式算总和
  cout<<ans<<endl;
}
```
# $Tips$
十年$OI$一场空，一场$long$ $long$见祖宗

---

## 作者：秋雨 (赞：0)

小学生都知道一个公式：

等差数列求和：

和=(首项+末项)×项数÷2

第n项=首项+(n-1)×公差

 至于公差咋算……不用讲了吧……
 ```
#include<bits/stdc++.h>
using namespace std;
long long a,b,n,c,z;
int main(){
	cin>>a>>b>>n;
	c=b-a;
	z=a+(b-a)*(n-1);//第n项=首项+(n-1)×公差
	cout<<(z+a)*n/2;//和=(首项+末项)×项数÷2
}

```
可以更短的……

---

## 作者：xeri_chen (赞：0)

一道很显然的数学题

已知一个等差数列的首项和公差，求前n项和；

直接套公式:

- $$ d=a_2-a_1 $$

- $$ a_n=a_1+(n-1)d$$
- $$ S_n=\frac{(a_1+a_n)\times n}{2}=\frac{\left[2a_1+(n-1)d\right]\times n}{2}$$

下面附上代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int main()
{
	long long a,b,n,d;//记得开long long
	cin>>a>>b>>n;
	d=b-a;
	cout<<n*(2*a+d*(n-1))/2;
	return 0;
}
```



---

## 作者：空·白 (赞：0)

这题其实非常的简单~~（我不会告诉你们我还试了几次）~~，只要学了等差数列，把求和公式套一下就好了。

------------
不知道会不会有些人不会求和公式，我还是贴出来好了。

                       Sn=（a1+an）* n/2


------------

```cpp
#include<bits/stdc++.h>    //万能头非常的稳健
using namespace std;
int main()
{
	long long int n,a,b,c,d,ans;
	cin>>a>>b>>n;
	c=b-a;
	d=a+c*(n-1);
	ans=(a+d)*n/2;
	cout<<ans;
}
```


---

## 作者：Stick_With_Mars (赞：0)

~~看我发现了一道水题~~
这道题非常之水，只要记得公式就能AC；
公式在代码里：
```cpp
#include <bits/stdc++.h>//万能头文件 
using namespace std;//命名空间 
int main (){//主程序 
	long long first,second,count,d,final;//定义变量，记得long long。 first首项，second第二项，count项数,d公差,final末项 
	cin>>first>>second>>count;//输入 
	d=second-first;//算出公差 
	final=first+(count-1)*d;//最后一项=首项+（项数-1）*公差 
	cout<<(first+final)*count/2;//等差数列求和公式：（首项+末项）*项数/2 
	return 0;//记得return 0 
}

```

upd:再来波py3:
```python
f,s,c=map(int,input().split())#一行三个数，你值得拥有
d=s-f#公差
fi=f+(c-1)*d#末项
print((f+fi)*c//2)#等差数列求和公式

```
程序有点丑，见谅。
管理求过

---

## 作者：PaulFrank (赞：0)

# 一道入门红题
**竟然没人发布题解~
那我这个蒟蒻来水一篇
我看提交记录有很多人wa了一部分！
主要是负数！！！！可能是炸了！！
code 复杂度O（1）算法小学数学**
【code】
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
long long a1,a2,n,an;
long long cha;
int main(){
	scanf("%lld%lld%lld",&a1,&a2,&n);
	cha=a2-a1;
	an=a1+(n-1)*cha;//等差数列公式
    //话说我们到必修几来着还要学等比数列！！
	printf("%lld\n",(long long)(a1+an)*n/2);
	return 0;
}

```
from 芜湖一中！！！！
附中神犇点赞！！！

---


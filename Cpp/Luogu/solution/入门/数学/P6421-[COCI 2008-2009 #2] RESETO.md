# [COCI 2008/2009 #2] RESETO

## 题目描述

埃拉托色尼筛法是一种著名的素数筛法，可以查找所有直至 $n$ 的素数。该算法的步骤是：
1. 写下 $2$ 到 $n$ 之间的所有整数（包括 $2$ 和 $n$）。
2. 找到尚未删除的最小数，并将其命名为 $p$； 则 $p$ 是素数。
3. 划掉 $p$ 及其所有尚未划掉的倍数。
4. 如果尚有数未被划掉，请转到步骤 $2$。

编写一个程序，给定 $n$ 和 $k$，找出第 $k$ 个被删除的整数。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $2 \leq k < n \leq 1000$。
#### 说明
#### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) RESETO，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
7 3```

### 输出

```
6```

## 样例 #2

### 输入

```
15 12```

### 输出

```
7```

## 样例 #3

### 输入

```
10 7```

### 输出

```
9```

# 题解

## 作者：wuyonghuming (赞：41)

## 思路：
按照题目说的模拟，我在这里手动模拟一下。

设 $n$ 为 $7$ , $k$ 为$6$。

写下$2,3,4,5,6,7$

第一轮，找到第一个素数 $2$,划掉，成为：$3,4,5,6,7$

第二轮划掉 $2$ 的倍数，成为：$3,5,6,7$

第三轮，继续划掉 $2$ 的倍数，成为：$3,5,7$

第四轮， $3$ 没有被划掉，划掉，成为：$5,7$

第五轮， $5$ 没有被划掉，划掉，成为：$7$

第六轮，只剩下 $7$，输出$7$
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	bool s[1001];//来存下这些数
	int n,k,w=0;//w记录划掉了几个数
	cin>>n>>k;//输入
	memset(s,true,sizeof(s));//写下所有数
	for(int i=2;i<=n;i++)//找没有划掉的数
	{
		if(s[i]==true)//如果没有被划掉
		{
			for(int j=i;j<=n;j+=i)//找它的倍数
			{
				if(s[j]==true)//如果它的倍数没被划掉
				{
					w++;//又划掉一个数
					s[j]=false;//现在它被划掉了
					if(w==k)//如果已经划掉k个数
					{
						cout<<j;//输出答案
						return 0;//结束
					}
				}
			}
		}
	}
	return 0;//别忘了
}
```
谢谢观赏！


---

## 作者：mnesia (赞：11)

此题是一道纯粹的模拟题，思维难度不高，码量较少。那么，就先上代码，在代码中讲解。
```cpp
#include <iostream>
using namespace std;
#define MAXN 1000
int n,k,sit[MAXN + 1];
int work(void);
int work(void)
{
    for(int i = 2;i <= n;i++)//从2开始循环划数
    {
        if(sit[i])
            continue;//如果i已经被划掉，继续下一轮循环
        for(int j = i;j <= n;j += i)//划掉i的倍数
        {
            if(sit[j])
                continue;//如果j已经被划掉，继续下一轮循环
            k--;//每划掉一个数，k就需要-1（通过k的自减来达到寻找第k个被划掉的数的目的）
            if(!k)
                return j;//如果k已经为0，说明当前的这个数（j）就是需要的结果
            sit[j] = 1;//将已经被划掉的数（j）的状态设为1
        }
    }
}

int main()
{
   cin >> n >> k;
   cout << work();
   return 0;
}

```
总的来说，这道题的主要考点就是如何将一个数“划掉”以及判断一个数是否已经被“划掉”。

备注：此篇题解由于之前发生了一些事故被连同本人其他题解一同撤下，现重新提交。

---

## 作者：Zmr_ (赞：9)

# 本题是素数筛法！！！

素数这东西能出贼多道题目。~~（也贼烦）~~

但是只要你掌握了它的寻找办法，这些题目都是可以AC的。

------

话不多说，直接进入思想阶段。

我们找素数一般有3种方法：【朴素法】 【埃氏筛法】 【欧拉筛法】。

我们做题用前两种方法就够了，因为【埃氏筛法】可以满足大部分题目的时间复杂度。~~（除非是一些超级毒瘤的题目）~~

----
先来说说【朴素法】。

顾名思义，【朴素法】肯定很朴实无华，也很简单。

但是时间复杂度就不太好了，因此在处理一些数据规模大的题目用这个是会超时的。

因为它是直接除的，如果都除不尽，那么就认定这个数为素数。

先上代码：（这么简单应该不用再多加叙述了吧）
```cpp
bool a[i];
memset(a,false,sizeof(a));//初始化
for(int i=2;i<=n;i++)
{    
   for(int j=i+1;j<=n;j++)
	{
		if(j%i==0)break;
		else a[i]=true;//判定素数
	}         
}          
```
----
再来说说【埃氏筛法】。

题目中已经做了较详细的赘述了，这里不再多说它的运行方式。（[我是传送门](https://www.luogu.com.cn/problem/P6421)）

它的时间复杂度也占优势，因此不管什么题目我一般都会用【埃氏筛法】。

上代码：
```cpp
memset(b, true, sizeof(b));//初始化
for (int i = 2; i <= n; i++)
{
	if (b[i] == true)
   {
   		for(int j=i;j<=n;j+=i)//找它的倍数
        if (b[j] == true)
        {
          b[j] = false;//找到了将其认定为不是素数
  		   }
	}      
}
//后面不加赘述
```
----
上面介绍了素数的两种搜索方式，那么接下来我们就可以开始做题目了。

很明显，这一题叫我们用【埃氏筛法】。

但是它不按套路出牌，它叫我们求第k个被认定为不是素数的整数。

那就是【埃氏筛法】的变形了。

这个变形也很简单，直接在AC代码里体会吧：
```cpp
#include<bits/stdc++.h>//万能头文件保我小命
using namespace std;
int p = 0,n,k,e[10001];   
bool b[10001];
int main()
{
    cin >> n >> k;
    memset(b, true, sizeof(b));//初始化。
    for (int i = 2; i <= n; i++)//此处不可以用sqrt！！！本人亲测。
    {
        if (b[i] == true)//一开始一模一样。
        {
            for(int j=i;j<=n;j+=i)//倍数关系
                if (b[j] == true)
                {
                    p++;//计算这是第几个不被认定为素数的整数。
                    b[j] = false;//将其认定为不是素数。
                    e[p] = j;//e[p]时刻准备着输出。
                    if (k == p)//当p等于k时，直接输出并且跳出去。
                    {
                        cout << e[p];
                        return 0;
                    }
                }
        }
        
    }
	return 0;//不管怎么样这东西必须要加。
}
```


---

## 作者：半笙、凡尘 (赞：2)

# 【[COCI2008-2009#2] RESETO】


~~序:无聊来写写水题~~

 -------
 
 - 这题也是比较容易的，题目也主要让我们认识埃氏筛
 
   - 我们只要按照题目所给步骤进行即可

	- 每次枚举 $2 \large\sim n$ ，当找到当前最小数并且未被删除时，将这个数以及他的倍数全部删除，并且标记已被删除。
   
   - 重复以上过程即可。

   - 看一下数据范围 $qwq$，显然直接暴力枚举倍数即可
 
   - 详细可以看一下代码注释吧
   
 - 接下来就是一点也不激动人心的代码了
 
```cpp

#include<bits/stdc++.h>
#define RT register
using namespace std;
template<class t> inline t read(t &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f)x=-x;return x;
}
template<class t> inline void write(t x){
	if(x<0)putchar('-'),write(-x);
	else{if(x>9)write(x/10);putchar('0'+x%10);}
}
template<class t> inline void writeln(t x){
	write(x);putchar('\n');
	return;
}
template<class t> inline void write_blank(t x){
	write(x);putchar(' ');
	return;
}
int n,k;
int a[1100];
int cnt;
bool f[1100];
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(n);
	read(k);
	for(int i=2;i<=n;i++){//枚举 2~n
		if(f[i]==0){//当搜查到当前数还未被删除时
			for(int j=1;j*i<=n;j++){//枚举 i 的倍数
				if(f[i*j]==0){//当 i 的倍数还没被删除时
					a[++cnt]=i*j;//把删除的数依次加进a[]数组
					f[i*j]=1;// 把这个数标记删除
				}
			}
		}
		
	}
	write(a[k]);
	return 0;
}
```

---

## 作者：过往梦魇之殇 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6421)

**思路简述：**

首先，观察到$2≤n≤1000$，所以直接暴力：

用一个$num[]$记录数字，即$num[i]=i$，$i∈[$$2，n$$]$

然后，直接模拟筛素数（原方法）

注意：已经删去的数字标记不能重复

用一个$cnt$计第几次删数，当$cnt=k$时，输出当时的数，结束程序即可。

**代码展示：**

```cpp
#include<bits/stdc++.h>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
const int maxn=1e3+10;
int n,k,num[maxn],cnt;
bool vis[maxn];
int main(){
	n=read();
	k=read();
	for(re int i=2;i<=n;++i){
		num[i]=i;
	}
	for(re int i=2;i<=n;++i){
		if(!vis[i]){
			int sum=i;
			while(sum<=n){
				if(!vis[sum]){
					vis[sum]=1;
					++cnt;
					if(cnt==k){
						write(sum);
						exit(0);
					}
				}
				sum+=i;
			}
		}
	}
	return 0;
}
```


>$Thanks$ $for$ $watching!$

---

## 作者：冰糖鸽子 (赞：2)

萌新第一次发题解呢QAQ

一道纯模拟，直接模拟的话时间还是很足够的

每次循环开始先判断数 $a$ 是否已经划掉，划了就跳过此次循环，接着再循环 $a$ 往后的所有数，判断是否已删除，是否为 $a$ 倍数，是的话标记并计数器加1，当计数器 $=$ $m$时输出并 $return$ $0$

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin >> n >> m;
    int cnt = 0;
    bool is[n + 2];
    for(int i = 0;i <= n + 1;i++)
    {
        is[i] = 0;
    }
    for(int i = 2;i <= n;i++)
    {
        if(is[i])
        {
            continue;
        }
        is[i] = true;
        cnt++;
        if(cnt == m)
        {
            cout << i << endl;
            return 0;
        }
        for(int j = i + 1;j <= n;j++)
        {
            if(!is[j] && j % i == 0)
            {
                is[j] = true;
                cnt++;
                if(cnt == m)
                {
                    cout << j << endl;
                    return 0;
                }
            }
        }
    }
    return 0;
}
```
码风是不压行带空格的，看着比较舒服

---

## 作者：asasas (赞：2)

这题是考察对埃筛的运用。

埃筛是一种判断质数的算法，每次选择一个数，并将它的倍数从筛中取出，一直筛到给定的范围为止。

我们每次筛数时，先判断有没有被筛过，筛过了的话就
跳过，没筛过的话就把它和它的倍数筛去，筛每个数时计数器+1，当计数器==k时，就输出正在筛的数，并结束程序（exit(0)或者return 0）。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool v[1005];//质数筛 
int main(){
	int n,k,cs=0;//n,k，和计数器
	cin >> n >> k;//读入
	for (int i=2;i<=n;i++){//枚举外部的数
		if (v[i]==1) continue;//筛过了就跳过
		for (int j=i;j<=n;j+=i){//没筛过就枚举倍数
			if (v[j]==0) cs++,v[j]=1;//没筛过就记为1，计数器++
			if (cs==k){
				cout << j;//等于k就输出
				return 0;//直接结束程序
			}
		}
	}
    return 0;
} 
```


---

## 作者：_tommysun_ (赞：1)

这道题主要考察的是埃拉托色尼筛法，相对于暴力的判断素数，这种方法会快一点，码量也较少。

由于素数是不能被除了它本身与1的数整除的，所以只要这个数是素数，它的倍数就是合数。这题与埃拉托色尼筛法唯一的区别便是要将扫到的素数也划掉。

**思路：**
- 设一个专门用来判断素数的数组p，所有元素的初始状态是0（素数），再设一个记录被划掉的数的数组t。
- 从2开始将n以内的数扫一遍，如果这个数是素数（是0），则在循环中把它的合数和它本身划掉。
- 最后输出t数组下标为k的元素即可。

这里还有一个坑，帮大家指出一下：如果这个数已经被划掉了，所以无需再划了。为了避免重复计算，需要在划数的那个循环中加个特判：
```
if(p[j]==1) continue;
```

**代码:**
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[2000]; //是否是素数，一开始全部设为0. 
int main(){
	int n,k;
	cin>>n>>k;
	int t[2000]; //被划掉的数。 
	int s=1;  
	for(int i=2;i<=n;i++){
		if(p[i]==0){ //如果这个数是素数。 
			for(int j=i;j<=n;j+=i){ //由于这个素数本身也要划掉，所以从i开始。 
				if(p[j]==1) continue; //为了避免重复计算，需要特判。 
				p[j]=1; //这个数是合数。 
				t[s++]=j;
			}
		}
	}
	cout<<t[k];
	return 0;
}
```


---

## 作者：AKakA (赞：1)

# 萌新第一次发题解
这道题并不是很难，我们先来理解一下题目

埃拉托色尼筛法是一种著名的素数筛法，可以查找所有直至 n 的素数。该算法的步骤是：

1.写下2到n之间的所有整数（包括2和n）。

2.找到尚未删除的最小数，并将其命名为 p;则 p是素数。

3.划掉p及其所有尚未划掉的倍数。

4.如果尚有数未被划掉，请转到步骤2。

编写一个程序，给定n和k,找出第k个被删除的整数。

简单来说就是，如样例3的数据就是在2，3，4，5，6，7，8，9，10中找出第7个被删除的数

第一次操作：3，5，7，9（由于2是未删除中最小的数，所以删除2的倍数）
此时已删除5个数

第二次操作：5，7（由于3是未删除中最小的数，所以删除3的倍数)当删除到9时刚好删除了7个数，就得到了第7个删除的数  9

AC代码：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;

bool a[1010];//记录是否删除
int n,k,p,ans=0;//n是到第n个数，k是第k个被删除的数，p是记录每次的最小数，ans为计数器

int main()
{
	cin>>n>>k;
	for(int i=2;i<=n;i++)
	{
		if(a[i]==1)
		{
			continue;      //第一次特判   如果被删除了就跳过
		}         
		p=i;                //存最小数
		for(int j=i;j<=n;j+=i)
		{
			if(a[j]==1)
			{
				continue;     //第二次特判   如果被删除了就跳过
			}
			a[j]=1;           //标记
			ans++;            //记录删除的个数
			if(k==ans)
			{
				cout<<j<<endl;          //判断
				return 0;               //输出后就结束
			}
		}
	}
} 

```




---


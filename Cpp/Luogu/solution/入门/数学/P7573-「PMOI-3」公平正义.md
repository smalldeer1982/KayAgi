# 「PMOI-3」公平正义

## 题目背景

> 公平正义，需要牺牲。——《唐人街探案 3》

## 题目描述

现在有 $n$ 个人，lhm 有一个质量为 $1$ 的蛋糕。所有人都想吃到 lhm 的蛋糕。lhm 为了维持公平正义，他需要用最小的刀数将蛋糕分成相等的 $n$ 份（一份中可以包含多块）。

把蛋糕看作一个圆，注意：每次切蛋糕时只能沿着直径切下。

最终每人得到的蛋糕块数可以不同，但必须保证每人得到的质量为 $\frac1n$。

现在你需要求出 lhm 切割的最小刀数。

## 说明/提示

【样例解释】

当 $n=2$ 时，我们直接沿直径切下，从而得到了两个质量均为 $\frac 1 2$ 的蛋糕块，分别将它们分给两个人即可。

当 $n=3$ 时，我们可以先后沿两条夹角为 $60 \degree$ 的直径切下，从而得到了质量为 $\frac 1 6$ 的两个蛋糕块 $a,b$ 和质量为 $\frac 1 3$ 的两个蛋糕块 $c,d$。我们把 $a,b$ 分给第一个人，$c,d$ 分别给第二个人和第三个人，就可以做到公平正义。

【数据范围】

对于 $20\%$ 的数据满足，$1 \le n \le 10$。

对于另 $20\%$ 的数据满足，$t=1$。

对于 $100\%$ 的数据满足，$1 \le t \le 10^3$，$1 \le n \le 10^{9}$。

## 样例 #1

### 输入

```
2
2
3```

### 输出

```
1
2```

# 题解

## 作者：Digital_Sunrise (赞：7)

我们想一想:

切1刀分成2块

切2刀分成4块

切3刀分成6块

......

很显然，如果切 $k$ 刀，整个蛋糕会分成 $2k$ 块

所以，对于任意偶数 $n = 2k$ 那么只需要 $k$ 刀

而对于任意奇数 $2k + 1$ ，我们其实需要 $k + 1$ 刀

所以，对于任意正整数 $n$ ,我们需要切 $\left\lceil\dfrac{n}{2}\right\rceil$ 刀

但是，这里有一个特例:

>$1$ 个蛋糕分成 $1$ 块不需要切

所以，加一个特判就是本题正解:

```cpp
#include <bits/stdc++.h>
using namespace std;

int t,n;

int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		if(n == 1)
			putchar('0'),putchar('\n');
		else printf("%d\n",(n + 1) >> 1);
	}
	return 0;
}
```


---

## 作者：Cocoly1990 (赞：5)

我们这样考虑

首先$n$为偶数，很明显只用切 $\dfrac{n}{2}$，因为任意$n$刀可以把圆切成$2n$块完全相同的扇形

但如果$n$是奇数，我们可以先切一刀，然后再切$\dfrac{n-1}{2}$刀，总共要$\dfrac{n+1}{2}$刀

又有$n$为偶数时$\dfrac{n}{2}=\left\lfloor\dfrac{n+1}{2}\right\rfloor$

所以不管奇偶，直接输出$\left\lfloor\dfrac{n+1}{2}\right\rfloor$

特别的，如果只有一个人，就不用切了

---

## 作者：_caiji_ (赞：5)

首先我们发现，切一刀蛋糕一定只能增加两块蛋糕。

那么，如果 $n\equiv 0\pmod{2}$，就只需要切 $\frac{n}{2}=\left\lfloor\frac{n+1}{2}\right\rfloor$ 刀蛋糕。

$n\equiv 1\pmod{2}$ 的情况呢？我们可以把其中一块分成两小块，然后切出 $n+1$ 块就可以了。这需要切 $\frac{n+1}{2}$ 刀。

讨论完这些情况，我们只能得到 $40$ 分。我们还有 $n=1$ 的情况没讨论，$n=1$ 时一刀也不用切，输出 $0$，但我们的代码会输出 $1$。这种情况特判一下就好了。

代码：
```cpp
#include <cstdio>
using namespace std;
int t,n;
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        printf("%d\n",n==1?0:n+1>>1);
    }
    return 0;
}
```


---

## 作者：LoserCode (赞：3)

# 题意
有一个蛋糕和若干个人，要将这个蛋糕分为若干份，使这若干个人得到的蛋糕相同。
# 思路
典型的数学题，我们先列个表。

先从数据开始，有两个人切一刀。

三个人切两刀。

四个人切两刀。

五个人切三刀。

……………………

不难看出，**如果有偶数个人，直接用人数除以二就是正确答案。**

**奇数个人将人数加一除以二也得到了正确答案。**

~~但这样的水题还要判断奇偶情况？~~

这时，我们可以利用一下c++的一个美妙的性质即强制类型转换，举个例子 _3/2=1_ , _5/2=2_ 

所以我们只用输出人数加一即可。

# Unluckily

不得不说，这题数据真的有点一言难尽，相信大多同仁交上去都是[这样的](https://www.luogu.com.cn/record/50212966)

我们漏了什么呢？

假如lhm没有朋友来吃，那么就只有lhm吃这个蛋糕，他还用切吗？

所以我们还要特判人数为一的情况。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int main()
{
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		cin>>n;
		if(n == 1) cout<<0<<endl;
		else cout<<(n+1)/2<<endl;
	}
}
```


---

## 作者：xfrvq (赞：1)

数学题。

[博客食用](https://www.luogu.com.cn/blog/368107/solution-p7573)

---

题目大意：给定一个 $n$ ，求把一块蛋糕均分为 $n$ 块至少需要几刀

---

显然 $n=1$ 时答案为 $0$ ，特判

而每切一刀一定可以增加两块

所以答案为 $(n+1)\div2$ （$n$ 为奇数时，先切一刀，再切 $n\div2$ 刀，偶数直接切 $n\div2$ 刀）

---

AC代码：

```cpp
#include<stdio.h>
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        int x;
        scanf("%d",&x);
        printf("%d\n",x == 1 ? 0 : x + 1 >> 1);
    }
}
```

---

## 作者：Aw顿顿 (赞：1)

把一个蛋糕平均分成 $n$ 块需要多少刀？

### 偶数

如果是偶数，很简单，只需要 $\dfrac{n}{2}$ 刀就可以。

### 奇数

注意到我们并不要刚好分成 $n$ 块，这 $n$ 块只要组合成合理的形式即可。同时我们也不需要输出如何分组，因此这就转化成了一道硬凑的问题。

如果是奇数，很简单，只需要 $\left\lceil\dfrac{n}{2}\right\rceil$ 刀就可以。

整体来看，无论奇偶性都可以用 $\left\lceil\dfrac{n}{2}\right\rceil$ 计算。

### 每一刀的贡献

为什么呢？因为每多一刀，我们就能将原来的某一蛋糕至少分成 $2$ 块，而我们可以通过一系列的直径加上某些半径将蛋糕分成可接受的状态。

### 注意点

对于一块蛋糕，我们不需要切任何一刀。

在整数除法的上取整，我们可以考虑 $\left\lceil\dfrac{n}{2}\right\rceil=\left\lfloor\dfrac{n+1}{2}\right\rfloor$

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
int main(){
    cin>>T;
    while(T--){
        cin>>n;
        if(n==1)puts("0");
        else cout<<(n+1)/2<<endl;
    }return 0;
}
```

[用时 17ms | 内存 644.00KB | AC 记录](https://www.luogu.com.cn/record/50215896)



---

## 作者：SunsetSamsara (赞：1)

首先,如果 $n = 1$,那么不用切(~~那不废话吗~~)

否则，注意到切一刀刚刚好可以切下两块蛋糕，

所以如果 $2 \mid n$ 就直接输出 $\dfrac n 2$。

接下来，当 $2 \nmid n$ 时，就需要先切一刀，再切 $\dfrac {n-1} 2$ 刀，
就是 $\dfrac {n+1} 2$ 刀。

代码如下：
```cpp
#include<stdio.h>
int T,n;
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        if(n==1)puts("0");//只需切一块的话就不用切了 
        else if(n&1)printf("%d\n",(n+1)/2);//如果是非1的奇数就切 (n+1)/2刀
		else printf("%d\n",n/2);//否则就切n/2刀 
    }
    return 0;
}
```

---

## 作者：mango09 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P7573)

[博客食用](https://www.luogu.com.cn/blog/305532/post-ti-xie-p7573-post)

前言：一道大~~水~~难题！

**题意**

给出 $n$，要用最小的刀数将蛋糕分成相等的 $n$ 份（一份中可以包含多块）。

注意：每次切蛋糕时只能沿着直径切下。

**思路**

1. $n=1$ 时答案为 $0$。
2. 切一刀多 $2$ 块，则当 $n$ 形如 $2k$ 时至少切 $k$ 刀；
3. 当 $n=2k+1$ 时切 $k$ 刀不够，至少切 $k+1$ 刀

**代码**

```cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;

int t, n;

signed main()
{
	scanf("%lld", &t);
	while (t--)
	{
		scanf("%lld", &n);
		if (n == 1)
		{
			printf("0\n");
		}
		else
		{
			printf("%lld\n", (n + 1) >> 1);
		}
	}
	return 0;
}
```


---


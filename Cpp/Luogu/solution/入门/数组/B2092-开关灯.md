# 开关灯

## 题目描述

假设有 $N$ 盏灯（$N$ 为不大于 $5000$ 的正整数），从 $1$ 到 $N$ 按顺序依次编号，初始时全部处于开启状态；第一个人（$1$ 号）将灯全部关闭，第二个人（$2$ 号）将编号为 $2$ 的倍数的灯打开，第三个人（$3$ 号）将编号为 $3$ 的倍数的灯做相反处理（即，将打开的灯关闭，将关闭的灯打开）。依照编号递增顺序，以后的人都和 $3$ 号一样，将凡是自己编号倍数的灯做相反处理。问当第 $N$ 个人操作完之后，有哪些灯是关闭着的？

## 样例 #1

### 输入

```
10```

### 输出

```
1 4 9```

## 样例 #2

### 输入

```
5```

### 输出

```
1 4```

# 题解

## 作者：sid_shi1 (赞：683)

题目：[B2092 开关灯](https://www.luogu.com.cn/problem/B2092)

思路：

看到大部分大佬的题解都用的是 $O(n^2)$ 的模拟啊，这里给出一个更加简单的做法。

首先，我们观察样例，会发现输出的数都是完全平方数，而且是 $1$ 到 $n$ 这个范围内的。简单证明一下为什么，因为只有完全平方数的因数个数为奇数，其余数都是偶数，而按动偶数次下也就相当于没按了，所以最后还是亮的（因为一开始灯也都是亮的），那么最后关着的灯就是这些编号为完全平方数的灯了。

我们只需一个循环输出 $1$ 到 $n$ 之间的完全平方数，整个代码时间复杂度只有 $O(\sqrt n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	for(int i=1;i*i<=n;i++) cout<<i*i<<" ";
	return 0;
}
```

~~求赞QAQ~~

---

## 作者：W_SUN (赞：32)

这道题就是纯模拟。开一个 bool 数组，false 为关灯，true 是开灯。

两层循环，外层跑 $1-n$ 代表人的标号，里面 $1-n$ 模拟每一盏灯的标号，如果灯的标号是当前人的标号，就进行灯是开的就关上，是关的就打开。

最后统计一下 false 的直接输出下标就行。
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool a[50007];
int cnt;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        a[i]=true;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(j%i==0){
                a[j]=!a[j];//作取反处理，开灯关上，关灯打开
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        if(a[i]==false){//统计关灯
            cout<<i<<" ";
        }
    }
    return 0;
}
```


---

## 作者：baoxuanming (赞：15)

原题传送门:[B2092](https://www.luogu.com.cn/problem/B2092)
***
### 分析
---
由于灯是开的，所以如果要将灯关掉，要拉奇数次，也就是这个灯的编号有奇数个因数。所以，我们只要求有奇数个因数的编号即可。

---
### 思路
一般的自然数 $m$ ，都有偶数个奇数，因为一个因数必然对应另一个因数 (即 $m=x\times y$ )，因数便成对出现。但如果一个数 $m$ ，可以分为 $m=x\times x$ 的形式，这个数便会比理论少一个因数，于是有奇数个因数。而能分解为 $m=x\times x$ 形式的
自然数 $m$，只有完全平方数。所以，我们只要输出完全平方数即可。
***
code:
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	scanf("%d",&n);
	int a=sqrt(n);//由于求的是完全平方数，只需求是谁的平方即可
	for(int i=1;i<=a;i++)
	{
		printf("%d ",i*i);//输出这个平方数 
	} 
	return 0;
}
```

---

## 作者：yynn (赞：14)

题目：[B2092 开关灯](https://www.luogu.com.cn/problem/B2092)

思路：

这题其实是一道小奥的数论题，是考完全平方数的，这题主要用到了完全平方数因数个数是奇数的特性。

这题的按按钮的方式就是将所有 $1$ 的倍数， $2$ 的倍数， $3$ 的倍数 $\cdots$ 一直到 $n$ 的倍数的灯都按一遍。

我们知道，要想改变一个灯的状态，必须按奇数次开关，被按的次数相当于他编号的因数个数，刚好，完全平方数刚好就符合这一特性，所以我们只需输出所有不大于 $n$ 的完全平方数就好啦。

好了，上AC代码：

```
#include<iostream>
using namespace std;
const int N=5005;
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i*i<=n;++i){//输出1到n之间的完全平方数
		printf("%d ",i*i);
	}
	return 0;
}

```
谢谢大家！

---

## 作者：囧仙 (赞：9)

## 题解

### 做法 1

我们直接开一个 $\verb!bool!$ 数组 $B$ 进行模拟。初始时都为真，表示灯泡开启着。接着，我们对于每个人进行枚举，即 $i$ 从 $1$ 枚举到 $n$ ；然后枚举每个灯泡，即 $j$ 从 $1$ 枚举到 $j$ 。若 $j$ 能被 $i$ 整除（即 $j\mid i$），那么取反 $B_j$ 的状态。

总的时间复杂度是 $\mathcal O(n^2)$ ，可以通过本题。

### 做法 2

与做法 1 类似，我们同样开一个 $\verb!bool!$ 数组 $B$ 。

对于 $i$ 从 $1$ 到 $n$ ，我们枚举 $j$ 时，从 $1$ 一直到 $\left\lfloor\dfrac{n}{i}\right\rfloor$ 。那么 $i\cdot j$ 即为所有 $i$ 的倍数，对于每个 $j$ ，取反 $B_{i\cdot j}$ 即可。

时间复杂度是，

$$T(n)=\sum_{i=1}^n \frac{n}{i}=n\cdot \frac{1}{i}=nH(n)\le n\log n$$

优于做法 1 。

### 做法 3

观察样例，可以发现输出的数字都是不超过 $n$ 的**完全平方数**。为什么会是这样呢？

考虑一个数被取反了多少次。显然，它被取反的次数，就是它的因子个数（对于它的每个因子，都能把它取反一遍）。一个数字 $x$ 是完全平方数的充要条件是，将它质因数分解后每个质因数的幂都是偶数。

$$x=\prod_{i=0}^k p_i^{c_i}$$

考虑加法原理和乘法原理，每个质因数可以选择的个数为 $0\sim p_{i}$ ，因此一个数的因子个数 $d(x)$ 有：

$$d(x)=\prod_{i=0}^k (c_i+1)$$

对于非完全平方数，总是存在 $c_i$ 为奇数。那么这个 $c_i+1$ 就是偶数，于是 $d(x)$ 必然是偶数；而对于完全平方数，所有 $c_i$ 都是偶数，因此 $d(x)$ 必然是奇数。对于被翻转了奇数次的灯，它就是熄灭的；否则是明亮的。

于是我们只要枚举不超过 $n$ 的每个完全平方数即可。时间复杂度为 $\mathcal O(\sqrt n)$ ，优于做法 1 和做法 2。

## 参考代码

### 做法 2

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int MAXN =5e3+3;
bool B[MAXN]; int n;
int main(){
    scanf("%d",&n); up(1,n,i) B[i]=true;
    up(1,n,i) up(1,n/i,j) B[i*j]^=1;
    up(1,n,i) if(!B[i]) printf("%d ",i);
    return 0;
}
```

### 做法 3

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
int n;
int main(){
    scanf("%d",&n); for(int i=1;i*i<=n;++i) printf("%d ",i*i);
    return 0;
}
```

---

## 作者：5k_sync_closer (赞：7)

# 思路
定义 bool 数组 $a,a[i]$ 表示第 $i$ 个灯**是否关闭**。

从 $1$ 到 $n$ 枚举每个人，对于每个人，枚举倍数。

令人数$×$倍数 $≤ n$，再修改 $a[$ 人数 $×$ 倍数 $]$ 的状态。
# 代码
```cpp
#include <iostream>
using namespace std;
bool a[5001];int n;
int main()
{
	cin >> n;
	for(int i = 1;i <= n;++i) //枚举每个人
		for(int j = 1;i * j <= n;++j) //枚举倍数，人数×倍数≤n
			a[i * j] = !a[i * j]; //修改状态
	for(int i = 1;i <= n;++i)
		if(a[i]) cout << i << " "; //灯是关的，输出
	return 0;
}
```


---

## 作者：rain_dew (赞：6)

本题解为 Python 题解，原题链接：[B2092 开关灯](https://www.luogu.com.cn/problem/B2092)

纯模拟，按照题目要求计算即可，代码如下：

```python
n=int(input());
for i in range(1,1+n):
    if i*i>n:
        exit();
    print(i*i,end=' ');
```

---

## 作者：Forever1507 (赞：4)

其实是一道小学奥数题。

本题考察数论知识，我们知道，在自然数范围中，对于任意一个数 $k$ ，只要它不是完全平方数，它的因数就总是成对出现的，即有偶数个，对于本题，只有**完全平方数**编号的灯才会点亮。按偶数次等于没按吖。

时间复杂度 $O(\sqrt{n})$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n; 
int main(){
	cin>>n;
	for(int i=1;i<=sqrt(n);i++){//c++自带的开根函数
		cout<<i*i<<' ';
	} 
	return 0;
}

```


---

## 作者：lighthouse (赞：4)

### 前言
虽然解法重复，但是这一篇可能讲的清楚一些。  
### 正文
这一题考查数组的熟练运用。  
**分析：**  
题目中灯的状态只有开与关两种状态，所以可以用一个`bool`数组来存储灯的状态。  
我们可以用两个`for`循环来模拟灯的操作，第一个循环用 $i$ 从 $1$ 到 $n$ 模拟每一个人（即第 $i$ 个人），第二个循环用 $j$ 从 $i$ 到 $n$ 模拟每一盏灯（即第 $i$ 个人开或关第 $j$ 盏灯）。  
我们可以用取反来模拟开灯或关灯（取反就是将非零值转换为零，零转换为非零值）。  
本题需要求**关着的灯**的数量，所以这个`bool`数列可以初始化为零，这样开灯即为关灯，关灯即为开灯，最后数组里值为 $1$ 的元素数就是关着的灯的数量。  
**代码：**  
```cpp
#include <bits/stdc++.h>

using namespace std;

bool light[5010];//这里定义了bool数组。

int main(){
    int n;
    cin >> n;//输入n。
    for(int i = 1;i <= n;i++){//第一个循环（i即为人的编号）。
        for(int j = i;j <= n;j += i){//第二个循环（j即为灯的编号）。
            light[j] = !light[j];//这里用取反来模拟等的操作。
        }
    }
    for(int i = 1;i <= n;i++){
        if(light[i] == 1)//判断数组元素是否为1（1的数量就是关着的灯的数量）。
            cout << i << " ";//输出关着的灯的编号。
    }
    return 0;
}
```

---


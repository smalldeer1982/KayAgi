# 不与最大数相同的数字之和

## 题目描述

输出一个整数数列中不与最大数相同的数字之和。

## 样例 #1

### 输入

```
3
1 2 3 ```

### 输出

```
3
```

# 题解

## 作者：_ZhouYuHan_ (赞：325)

这里我提供一种不同的思路。

我们只需排个序，从头开始遍历，判断是否与最后一个数相等（显然，最后一个数就是最大数），如果是就跳出循环（因为后面也肯定是最大数），否则计数器加上它。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101],n,cnt;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>a[i];//输入
	sort(a+1,a+n+1);//排序
	for(int i=1; a[i]!=a[n]; i++) //在循环条件里判断（当然也能在下面判断啦）
		cnt+=a[i];//累加
	cout<<cnt;
	return 0;
}
```
最后点个赞呗。

---

## 作者：·糯· (赞：16)

## 题目分析
这题其实就是求最大值，然后再扫一遍，不同于最大值的加入计数器内即可。我用的是快排，当然也可以用冒泡或直接用循环求。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110]; 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int x,sum=0;
	sort(a+1,a+n+1);//排序
	x=a[n];//最大值
	for(int i=1;i<=n;i++)
		if(a[i]!=x)
			sum+=a[i];//计数器
	cout<<sum<<endl;
	return 0;
}

```


---

## 作者：Fengxiang008 (赞：11)

### 解题思路：

这题其实就是求最**大**值。

用一个值 ```max``` 存这组数据的最大值。

策略：
将 ```max``` 初始化为 ```-1e9(10的9次方）``` 
遇到比 ```max``` 大的数，就更新 ```max``` 的值。

最后将所有不是最大值的数相加，即答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110],max=-1e9,sum;
int main() 
{
	int n;
    cin>>n;//输入整数个数n
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//输入n个整数
        if(a[i]>max)
		{
			max=a[i];//记录最大值
		}
    }
   for(int i=1;i<=n;i++)//计算除去与最大值相同的数的和
   {
       if(a[i]!=max)
       {
           sum+=a[i];
       }
   }
   //输出答案 
   printf("%d\n",sum);//cout<<sum<<endl;
   return 0;
}
```


---

## 作者：rain_dew (赞：8)

本题解为 Python 题解，原题链接：[B2094 不与最大数相同的数字之和](https://www.luogu.com.cn/problem/B2094)

本题会有多个最大值。还是查找最大值使用 `max()`，查找最大值的个数使用 `count()`，最后要注意本题数据中有 $n=0$ 的情况，使用 Python 时需要特判，代码如下：

```python
n=int(input());
if n==0:
    print(0);
    exit();
a=input().split();
a=[int(x) for x in a];
print(sum(a)-max(a)*a.count(max(a)));
```

---

## 作者：一只大龙猫 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/B2094)

对于这道题，我们可以从反方向去想：

设 $s$ 为所有数之和，$m$ 为最大数，$t$ 为最大数的个数，$ans$ 为不与最大数相同的数字之和，则 $ans$ 可以这样计算：

$$ans=s-m \times t$$

求 $s$，直接一个一个加起来就行了。

求 $m$，我们可以使用 C++ STL 中的`sort()`函数。由于不是这篇题解的重点，这里就不多说了，想知道更多的可以看[这里](https://www.cnblogs.com/stones-dream/p/10183210.html)。

这里重点想说的是求 $t$ 的方法。

我们固然可以一个一个数去判断，但实际上我们还有更方便的方法：使用`count()`函数。

使用`count()`函数时，须引用`algorithm`头文件。它的参数是`count(first,last,value)`。其中` first`是容器的首迭代器，`last`是容器的末迭代器，`value`是询问的元素。它的功能是统计容器中等于`value`元素的个数。有关`count()`函数的更多知识，可以看[这里](https://blog.csdn.net/lyj2014211626/article/details/69615514/?utm_term=c++%E4%B8%ADcount%E4%B8%8Ecount&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-69615514&spm=3001.4430)和[这里](https://blog.csdn.net/weixin_45541762/article/details/107365479?utm_term=c++%E4%B8%ADcount%E4%B8%8Ecount&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-107365479&spm=3001.4430)。

以下是代码。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[200],s,m,t,ans; 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s+=a[i];
	}
	sort(a+1,a+n+1);
	m=a[n];
	t=count(a+1,a+n+1,m);
	ans=s-m*t;
	cout<<ans;
	return 0;
}

```


---

## 作者：lighthouse (赞：4)

从题面分析：  
我们可以用一个数组来储存这个整数数列。  
用循环读入前，先定义一个 $maxn$ 来储存最大值，再定义一个累加器来储存和。  
在循环内，每执行一次就用 C++ 自带函数 `max` 判断，如果比 $maxn$  更大就更新 $maxn$ 的值。  
再用循环扫一遍数组，如果元素不与 $maxn$ 相等，就让累加器加上这个元素。  
看数据范围：  
题目中所有数都在 `int` 范围内。  
代码：  
```cpp
#include <bits/stdc++.h>

using namespace std;

int a[110];//定义数组

int main(){
	int n;
	cin >> n;
	int maxn = 0;//定义最大值储存器
	int ans = 0;
	for(int i = 1;i <= n;i++){
		cin >> a[i];//输入
		maxn = max(maxn, a[i]);//判断最大值
	}
	for(int i = 1;i <= n;i++){//用循环扫描
		if(maxn != a[i])//不是最大值
			ans += a[i];//累加器加上这个元素
	}
	cout << ans;//输出
	return 0;
}
```

---

## 作者：_ajthreac_ (赞：3)

如何找出一个数列中的最大值呢？$\texttt{C++}$ 的 $\texttt{algorithm}$ 库为我们提供了一个 `max` 函数，它的用法是传入两个数，返回它们的最大值，也即 `max(a,b)` 会返回 $a,b$ 中较大的那个。

所以我们从头到尾遍历一遍序列，每次把当前的数和最大值比较即可找到所有数的最大值。

那么接下来的任务就很简单了，我们只需要枚举每个数，如果不是最大值就加上这个数。

核心代码如下（有改动）：
```cpp
int n,a[110],mx,sum;
int main(){
  scanf("%d",&n);
  for(int i=1;i<=n;i++){
    scanf("%d",&a[i]),mx=max(mx,a[i]);
  }
  //这里为了简洁使用了一个特殊的语法
  //当一个布尔表达式被括号括起来时，它的值就是该表达式的布尔值
  //下面这个式子的意思是：
  //a[i]!=mx 时 sum+=1*a[i]
  //a[i]==mx 时 sum+=0*a[i]
  //达到了不通过 if 语句也能过滤最大值的效果
  for(int i=1;i<=n;i++)sum+=(a[i]!=mx)*a[i];
  cout<<sum<<endl;
  return 0;
}
```

---


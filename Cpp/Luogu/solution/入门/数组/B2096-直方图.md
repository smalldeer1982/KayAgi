# 直方图

## 题目描述

给定一个非负整数数组，统计里面每一个数的出现次数。我们只统计到数组里最大的数。

假设 $Fmax（Fmax \le 100000）$是数组里最大的数，那么我们只统计 $\{0,1,2 \ldots Fmax \}$ 里每个数出现的次数。

## 样例 #1

### 输入

```
5
1 1 2 3 1```

### 输出

```
0
3
1 
1```

# 题解

## 作者：sylqwq (赞：68)

题目：[B2096](https://www.luogu.com.cn/problem/B2096)

题目要求就是统计数组里面每一个数的出现次数。

我们可以先判断已出现的数可以到达的的最大的数，再以这个最大的数为终点，分别统计每个数字出现的个数。

CODE

```cpp
#include<bits/stdc++.h> //万能头文件 
using namespace std;
int a[100001]; 
int n,x,m=0;
int main()
{
	cin>>n;//数组大小 
	for(int i=1;i<=n;i++)//读入数组 
	{
		cin>>x;
		a[x]++;
		if(m<x)
			m=x;//找出最大数
	}
	for(int i=0;i<=m;i++)
		cout<<a[i]<<endl;
   	return 0;
}
```


---

## 作者：Waaifu_D (赞：11)

## 题意

给我们一个 $n$ 大小的数组，求里面 $0$ 到最大的数所出现的次数。

## 解题思路

我们引入一种新的排序思想，桶排。

我们不直接存储数，而是把数当成下标，放进一个桶（一般是一个很大的数组）中。

比如现在有一个桶数组 ```F[10000]```，它可以存储 $0-10000$ 的数，然后我们从 $0 - 10000$ 输出，如果桶非空，就输出现在循环到的下标，这样输出一定是有序的，因为下标是绝对按照顺序来排列的。

了解了桶排的思想，本题就变得很简单

我们用一个 ```fmaxx``` 来存储最大值，输出的时候上限设为它即OK

## AC CODE

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int n,fmaxx,x;
int f[100005];//注意桶的数据范围不是n而是输入的数最大为多少
int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n;i++)
	{
		scanf("%d",&x);
		f[x]++;
		fmaxx=max(fmaxx,x);
	}
	for(int i=0; i<=fmaxx;i++)
	{
		printf("%d\n",f[i]);
	}
	return 0;
}
```
## End

打好基础，OI学习才能更顺利！

---

## 作者：5k_sync_closer (赞：4)

# 思路
定义数组 $cnt,cnt[i]$ 表示 i 的出现次数。

枚举一遍原数组，统计每个数出现的次数。

然后从 0 到 fmax 遍历 cnt，输出从 0 到 fmax 每个数的出现次数。
# 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n, cnt[100001], t, m;
int main()
{
	cin >> n;
	for(int i = 0;i < n;++i)
		cin >> t, ++cnt[t], m = max(m, t); //记录cnt[t],同时更新最大值
	for(int i = 0;i <= m;++i) //从0到fmax
		cout << cnt[i] << endl; 
	return 0;
}
```


---

## 作者：超级玛丽王子 (赞：4)

# 题意简述

给定一个非负整数列 $\{a_n\}$，记 $\text{Fmax}=\max\{a_n\}$，并定义集合：
$$A=\{x\ |\ x\in\mathbb{N},0\le x\le \text{Fmax}\}$$

求集合 $A$ 中的每一个元素在数列 $\{a_n\}$ 中的出现次数。

# 解法

桶排序裸题。

桶排序的大概意思就是对于数集的值域 $I$ 内的每一种取值都开一个计数器，称作**桶**，然后每读入一个数就把对应的计数器加一，即可完成排序。桶排序的原理类似平常的画正字。

在这道题中，我们不仅要对数列进行桶排序，还要在排序的过程中在线处理数列中的最大值，来确定 $\text{Fmax}$ 的值。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=114514;
int bucket[maxn],n,tmp,Fmax;
//输入量比较大，使用快读快写
int read() {
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    int x=0;
    while(ch>='0'&&ch<='9') x=(x*10)+(ch^48),ch=getchar();
    return x;
}
void wr(int x) {
    if(x>9) wr(x/10);
    putchar(x%10+'0');
}
void write(int x, char ch='\n') {
    wr(x);
    putchar(ch);
}
int main(void) {
    n=read();
    while(n--) tmp=read(),++bucket[tmp],Fmax=(tmp>Fmax)?tmp:Fmax; //更新计数器和 Fmax
    for(int i=0;i<=Fmax;++i) write(bucket[i]);
    return 0;
}
```

# 扩展

## 桶排序的其它应用

桶排序还有另一个重要应用——去重。我们发现，在桶排序的过程中，序列中出现过的数，计数器的值不为 $0$，否则为 $0$。这可以帮助我们完成去重。详见 [P1059 [NOIP2006 普及组] 明明的随机数](https://www.luogu.com.cn/problem/P1059)。

另一道桶排练习题是 [[CSP-J2020] 直播获奖](https://www.luogu.com.cn/problem/P7072)，本题需要强制在线桶排，复杂度 $n^2\log n$ 的 `sort` 无法通过。当然，这道题也可以用对顶堆，平衡树等多种方法通过。

## 桶排序的优劣分析

桶排序是目前可以用计算机实现的时间复杂度**最优**的排序算法，复杂度是严格 $O(n)$ 的，而且常数极小（数组索引 $1$ 次，自增 $1$ 次）。

然而，优秀的时间复杂度使用空间复杂度换取的。桶排序的空间复杂度是 $O(\max a-\min a)$，如果数据开到 $[1,10^8]$，桶排序就会彻底挂掉（因为会有非常大的空间浪费）。

---

## 作者：ZhaiOverflow (赞：4)

## 题意
给定一个数组 $f$ ，记数组中最大的数为 $fmax$ ，记录从 $f(1)$ 到 $fmax$ 
每个数出现的次数。

## 分析
依次读入每个数的同时记录最大值。然后使用桶统计每个数出现的次数即可。
```
#include<bits/stdc++.h>
using namespace std;

int a[114514], b[114514];

int main() {
    int n, fmax = -2100000000;
    cin >> n;
    a[0] = a[n + 1] = -2100000000;
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if(a[i] > fmax) fmax = a[i];
        b[a[i]] ++;
    }
    
    for(int i = 0; i <= fmax; i++) printf("%d\n", b[i]);
    return 0;
}
```

---

## 作者：rain_dew (赞：2)

本题解为 Python 题解，原题链接：[B2096 直方图](https://www.luogu.com.cn/problem/B2096)

计算每个数出现的个数，并按照从小到大顺序排序。本题虽然有 `count()` 函数，但由于数据量过大，`count()` 函数需要每一次走完一整个数组，注定超时。

因此我们可以假设一个数组，将原数组的值作为新数组的下标，最后按照下标与里面存储个数输出即可，代码如下：

```python
n=int(input());
f=input().split();
f=[int(x) for x in f];
maxt=max(f);
p=[0]*(maxt+1);
for i in range(n):
    p[f[i]]=p[f[i]]+1;
for i in range(maxt+1):
    print(p[i]);
```

---

## 作者：·糯· (赞：2)

## 题目分析
此题可以先排序，并求出最大值，然后循环扫一遍，将对应其数值的计数器加上一，最后从0到最大值输出计数器内的数，注意每个数后面是换行符。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[100010],num[100010]; 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);//排序
	int maxi=a[n];//最大值
	for(int i=1;i<=n;i++)
		num[a[i]]++;//出现次数
	for(int i=0;i<=maxi;i++)
		cout<<num[i]<<endl;
	return 0;
}

```


---

## 作者：Zhoumy (赞：2)

我们可以直接输入，枚举哪个数是最大的数，然后在数组里把每个数的数量加起来，最后依次输出。
```
#include<bits/stdc++.h>
using namespace std;
int a[100005],n,c,Fmax;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>c;
		a[c]++;//每个数字的数量
		Fmax=max(Fmax,c);//找最大的数
	}
	for(int i=0/*从0开始*/;i<=Fmax;i++)cout<<a[i]<<endl;//输出
	return 0;
}
```

---


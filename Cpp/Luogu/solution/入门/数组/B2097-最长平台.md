# 最长平台

## 题目描述

对于一个数组，其连续的相同段叫做一个平台，例如，在 $1$，$2$，$2$，$3$，$3$，$3$，$4$，$5$，$5$，$6$ 中 $1$，$2-2$，$3-3-3$，$4$，$5-5$，$6$ 都是平台。

编写一个程序，接收一个数组，找出最长的平台。在上面的例子中 $3-3-3$ 就是最长的平台。

## 样例 #1

### 输入

```
10
1 2 2 3 3 3 4 5 5 6```

### 输出

```
3```

# 题解

## 作者：sylqwq (赞：38)

B2097 最长平台 题解

题意是：找数组的最长平台，而从小到大排序的数组中，连续的一串值相同的元素就是一个平台，那么题目就变得简单明了了，具体分析可见注释。       

代码如下：     

```cpp
#include<iostream>
using namespace std; 
int main() 
{
    int n,a[100001]; //n表示数组大小
    int m=-9999,len=1;
    int i;
    cin>>n;
    a[0]=-3456497;//保证a[0]与a[1]不相同
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
    	if(a[i]==a[i-1])//若当前元素与之前一个元素相同
            len++;//平台长度+1
    	else
            len=1;//平台长度重归为1
    	if(len>m)//记录最大平台值
            m=len;
    }
    cout<<m<<endl;
    return 0;
}
```


---

## 作者：yzyjh (赞：15)

我们可以用 $cnt$ 来记录每个数字的最长段
```
#include<bits/stdc++.h>
using namespace std;
int a[105];
int main(){
	int n;
	cin>>n;
	int cnt=0,ans=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
		if(a[i]==a[i-1]) cnt++;//相同就加上
		else{//不同就替换
			ans=max(cnt,ans);
			cnt=0;
			cnt++;
		}
	}
	ans=max(cnt,ans);//防止最后一组数是最长的
	cout<<ans<<endl;
	return 0;
}
```

还有另一种做法，就是将每一个数的个数加入数组内，再将数组中的最大值找出
```
#include<bits/stdc++.h>
using namespace std;
int k[2010];
int main(){
	int n;
	cin>>n;
	int ans=0;
	for(int i=0;i<n;i++){
		int a; cin>>a;
		k[a]++;//将数压进数组内
	}
	for(int i=0;i<2000;i++) ans=max(ans,k[i]);//找最大的数
	cout<<ans<<endl;//输出答案
	return 0;
}
```


---

## 作者：__Cartesian__Tree__ (赞：9)

这道题实际上就是求连续相同数字最长的长度。

我们可以通过比较下一个数字来判断，如果相同则长度 $len$ 加 1，否则与最大值 $maxlen$ 比较，并且长度 $len$ 重置为 1。

注意长度 $len$ 初始值为 1。

AC Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110];
int main(){
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    int maxlen = 0;//最长长度
    int len = 1;//目前长度，注意要设为 1，不是 0
    for (int i = 1; i <= n - 1; i++){//注意范围到 n - 1
        if (a[i] == a[i + 1]) len++;
        else
        {
            if (len > maxlen) maxlen = len;
            len = 1;//顺序不能颠倒
        }
    }
    printf("%d\n", maxlen);
    return 0;
}
```


---

## 作者：YclarHIM0302 (赞：6)

## 简述题意：
求一串数中，连续且数字相同的数字串的数字最大数目。

同时，这串数是由小到大排序过的，因此直接**滚筒计数**就好了！

 _Talk is cheap,show me the code._ 
 

------------

 ```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//快读输入
{
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}
int n,k,a[2005],num[105],cnt,ans=0;//cnt用于记录不同数字的个数
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		k=read();
		a[k]+=1;//滚筒记录数字数目
		if(a[k]==1) num[++cnt]=k;
	} 
	for(int i=1;i<=cnt;i++)
	ans=max(ans,a[num[i]]);//求答案最大值
	printf("%d",ans);
    return 0;
}

```
~~大水题~~

---

## 作者：rain_dew (赞：5)

本题解为 Python 题解，原题链接：[B2097 最长平台](https://www.luogu.com.cn/problem/B2097)

计算最长连续值。

先排序，只要上一个值与其相同，计数器累计，否则与最大值进行比较后进行清空，代码如下：

```python
n=int(input());
f=input().split();
f=[int(x) for x in f];
sums=0;maxt=0;cnt=0;
for i in range(n):
    if sums==f[i]:
        cnt=cnt+1;
    else:
        sums=f[i];maxt=max(maxt,cnt);cnt=1;
print(maxt);
```

---

## 作者：Dimly_dust (赞：4)

## Part 1

观察题目后可得结论（自行证明）：

- 两个相邻平台中必定交界处的两个元素**不同**

有了这个结论题目就好做多了，下面介绍几种做法。

### Algorithm 1

------------

采用 $\texttt{DP}$ 算法，规定 $\texttt{f[i]}$ 为到 $\texttt{i}$  元素 $\texttt{a[i]}$ 的平台长度，可得：

$$\begin{cases}f[i]=f[i-1]+1~(a[i]=a[i-1])\\ f[i]=1~(a[i]\ne a[i-1])\end{cases}$$

时间复杂度 $\mathcal{O(n)}$，空间复杂度 $\mathcal{O(n)}$ 。

**Code**



------------


```
#include <bits/stdc++.h>
using namespace std;
int f[105],a[105];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9')
    {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
int main()
{
    int n=read(),maxn=-1;
    for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
	{
		if(a[i]==a[i-1]) f[i]=f[i-1]+1; //不用处理f[0]是因为a是大于0的正整数
		else
		{
			f[i]=1;
			maxn=max(maxn,f[i-1]);
		}
	}
	printf("%d",maxn);
    return 0;
}
```
### Algorithm 2

------------
 
那么我们思考一下，怎么优化呢？

可以发现每一个平台长度  $\texttt{f[i]}$ 只要是 $\texttt{a[i],\ a[i-1]}$ 不相等时就是独立的，我们可以把  $\texttt{f[i]}$ 的空间节约下来。

既然计算只涉及到 $\texttt{a[i],\ a[i-1]}$ ，那么我们也同样可以用此方法节约空间。

时间复杂度 $\mathcal{O(n)}$，空间复杂度 $\mathcal{O(1)}$ 。

**Code**



------------

```
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9')
    {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
int main()
{
    int n=read(),maxn=-1,len=1;
    int k=read();
    for(int i=2; i<=n; i++)
    {
        int j=read();
        if(j==k) len++;
        else
        {
            maxn=max(maxn,len);
            len=1;
        }
        k=j;
    }
    printf("%d",maxn);
    return 0;
}
```


---

## 作者：xgwpp6710 (赞：3)

这题我们可以用 DP 做。

怎么个 DP 法呢，我先给个提示：$dp[i]$ 表示以第 $i$ 个数为结尾的最长平台。

我相信写到这里大佬们都已经知道 $dp$ 数组的维护方式了。如果第 $i$ 项等于第 $i-1$ 项，则可以把它接在前一个平台后面，即 $dp[i]=dp[i-1]+1$。否则只能新开一个平台，$dp[i]=1$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[109],a[109],mx;
int main()
{
	int n;
	a[0]=10009;//这个似乎没必要写，我写代码的时候是考虑到a[1]会不会接在a[0]的平台后面，然而dp[0]=0所以不影响
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		dp[i]=(a[i]==a[i-1]?dp[i-1]+1:1);//前面说的维护方法
		mx=max(mx,dp[i]);//更新最长的平台
	}
	cout<<mx;
	return 0;
}
```

---


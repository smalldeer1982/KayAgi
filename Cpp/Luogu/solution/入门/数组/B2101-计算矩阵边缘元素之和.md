# 计算矩阵边缘元素之和

## 题目描述

输入一个整数矩阵，计算位于矩阵边缘的元素之和。

所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。

## 说明/提示

$1 \le m,n \le 100$。保证答案在 int 范围内。

## 样例 #1

### 输入

```
3 3
3 4 1
3 7 1
2 0 1```

### 输出

```
15```

# 题解

## 作者：DWT8125 (赞：56)

本题可以不使用二维数组，用 $i$ 和 $j$ 模拟行和列，用 $t$ 来代表 $a_{ij}$ （假设有二维数组 $a$ ），然后判断是否为边界即可。

### 代码部分
为了您不被棕，请不要抄袭！

```cpp
#include<cstdio>
int main(){
	int m,n,t,ans=0; scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++){
			scanf("%d",&t);
			if((i==1||i==m)||(j==1||j==n))
			//判断是否为边界，先行后列，注意要用'||'隔开 
				ans+=t;
		}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Eason_AC (赞：16)

## Content
给定一个 $m\times n$ 的矩阵，求矩阵边缘元素之和。

**数据范围：$1\leqslant m,n\leqslant 100$。**
## Solution
对于新手来说，看到这题就感觉我们以前用的一维数组是肯定不够的。没错，既然有一维数组肯定就有二维数组（甚至还有 $\geqslant 3$ 维数组）。这篇题解首先向新手介绍一下二维数组和多维数组，如果对于这部分已经很熟悉了不妨跳过这个部分。

二维数组的定义方法即为 `a[][]`，没错，就是在原来的一维数组上面多加上一对中括号。然后在每对中括号之间填上数字，就可以定义数组的大小，以此类推，$n$ 维数组的定义方法即为数组名后面加上 $n$ 对中括号，然后在每对中括号之间填上数字。但请注意：如果数组的大小太大，会造成计算机空间不足，会造成空间超限。这也就是评测状态中常见的一种：MLE。因此，**请在定义数组的时候先计算数组的大小，以免造成不必要的空间超限**。具体如何计算数组大小请自行上网搜索查看。

那么回到本题，我们如何判断矩阵中的某一个元素 $a_{i,j}$ 是否是边缘元素？稍微分析一下不难发现，只要满足 $i\geqslant 1$、$i\leqslant m$、$j\geqslant 1$、$j\leqslant n$ 四个条件中的一个，这个元素就是边缘元素。因此我们循环查找每一个元素，判断是否是边缘元素，是的话累加进答案即可。

但是，有没有不用二维数组，甚至不用数组就可以得到正确答案的方法呢？答案是肯定的。我们可以发现，我们可以一边读入，一边判断是否是边缘元素，是的话累加进答案。因此可以直接开一个变量读入 $m\times n$ 次，然后直接同时判断累加进答案即可。

下面的代码仅给出用单个变量的方法。
## Code
```cpp
#include <cstdio>
using namespace std;

int n, m;
long long ans;

int main() {
	scanf("%d%d", &n, &m);
	F(int, i, 1, n) F(int, j, 1, m) {
		int x; scanf("%d", &x);
		if(i == 1 || j == 1 || i == n || j == m) ans += x;
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：koishi_x (赞：12)

通过观察不难得知，$a[i][j]$ 是边缘元素

等价于 $i=1$ 或 $j=1$ 或 $i=n$ 或 $j=m$。

将满足条件的元素累加起来即可。

 Code:

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int n, m;
int a[110][110], sum;
int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
		{
			scanf("%d", &a[i][j]);	//可以不用数组
			if(i == 1 || j == 1 || i == n || j == m)	//a[i][j]是边缘元素
				sum += a[i][j]; 
		}
	printf("%d\n", sum);
}
```

---


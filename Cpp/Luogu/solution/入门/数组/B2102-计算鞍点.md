# 计算鞍点

## 题目描述

给定一个 $5 \times 5$ 的矩阵，每行只有一个最大值，每列只有一个最小值，寻找这个矩阵的鞍点。鞍点指的是矩阵中的一个元素，它是所在行的最大值，并且是所在列的最小值。

例如：在下面的例子中，第 $4$ 行第 $1$ 列的元素就是鞍点，值为 $8$。

```
11 3 5 6 9
12 4 7 8 10
10 5 6 9 11
8  6 4 7 2
15 10 11 20 25
```

## 样例 #1

### 输入

```
11 3 5 6 9
12 4 7 8 10
10 5 6 9 11
8  6 4 7 2
15 10 11 20 25```

### 输出

```
4 1 8```

# 题解

## 作者：墨忧 (赞：49)

## 题目大意
给定一个矩阵，若矩阵的某一元素同时是其所在行的最大值和其所在列的最小值，则输出其的坐标和值。
## 思路
二维数组存矩阵，分别用两个数组 $h[i]$ 和 $l[i]$ 来记录第 $i$ 行最大值所在的列和第 $i$ 列最大值所在的行，最后检查输出即可。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][10],h[10],l[10],maxh,minl;
//a数组存矩阵，h、l含义见上文，maxh代表行的最大值，minl代表列的最小值 
bool pd=true;
int main()
{
    for(int i=1;i<=5;i++)
        for(int j=1;j<=5;j++) cin>>a[i][j];
    for(int i=1;i<=5;i++)
    {
        maxh=-1;//重置最大值为-1 
        for(int j=1;j<=5;j++)
            if(a[i][j]>maxh)
            {
                h[i]=j;//找到最大值所在的列 
                maxh=a[i][j];
            }
    }
    for(int i=1;i<=5;i++)
    {
        minl=99999;//重置最小值为99999 
        for(int j=1;j<=5;j++)
            if(a[j][i]<minl)
            {
                l[i]=j;//找到最小值所在的行 
                minl=a[j][i];
            }
    }
    for(int i=1;i<=5;i++)
        if(i==l[h[i]])
        //对比是否有同时满足 行最大，列最小 
        {
            cout<<i<<" "<<h[i]<<" "<<a[i][h[i]];
            pd=false;
        }
    if(pd) cout<<"not found"<<endl;
    //若没有，则输出 "not found"
    return 0;
 } 
```


---

## 作者：·糯· (赞：25)

## 题目分析
此题可以用两个二维数组实现，一个存储最大值及所在位置，一个存储最小值及所在位置。存好后，两个二维数组作比较，因为我们是把两个二维数组定义在主函数外的，所以初始值肯定是零，如果出现两个点都不为零，那么此点就必定是鞍点。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][10],maxi[10][10],mini[10][10]; 
int main(){
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			cin>>a[i][j];
	for(int i=1;i<=5;i++){
		int maxii=0,y;
		for(int j=1;j<=5;j++)
			if(a[i][j]>maxii){
				maxii=a[i][j];
				y=j;
			}
		maxi[i][y]=maxii;
	}//记录每行的最大值及所在位置
	for(int i=1;i<=5;i++){
		int minii=1e9,x;
		for(int j=1;j<=5;j++)
			if(a[j][i]<minii){
				minii=a[j][i];
				x=j;
			}
		mini[x][i]=minii;
	}//记录每列的最小值及所在位置
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			if(maxi[i][j]!=0&&mini[i][j]!=0){
				cout<<i<<" "<<j<<" "<<maxi[i][j]<<endl;//如果都有值就说明此点是鞍点
				return 0;
			}
	cout<<"not found"<<endl;//没有找到鞍点
	return 0;
}

```


---

## 作者：FuriousC (赞：20)

[题目传送门](https://www.luogu.com.cn/problem/B2102)

看到题解里大佬们的做法都是存起来一列的最小值和一行的最大值再判断，这里就再提供一种最普通的暴力。

思路就是根据题意模拟。输入后不需要任何预处理，直接枚举每一个点，判断它所处的一行有没有比它大的，它所处的一列有没有比它小的，有就换下一个点，没有就输出。

由于数据范围真的非常小，这种 $O(n^3)$ 的做法是完全可以的。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int mapp[6][6];
int main(){
    int ans=0;
    for(int i=1;i<=5;i++){
        for(int j=1;j<=5;j++){
            cin>>mapp[i][j];
        }
    }//输入
    for(int i=1;i<=5;i++){
        for(int j=1;j<=5;j++){
            bool flag=0;//记录满不满足条件，0 表示满足，1 表示满足
            for(int x=1;x<=5;x++){
                if(mapp[x][j]<mapp[i][j]){//判断这一列中有没有比当前点小的
                    flag=1;
                    break;
                }
            }
            for(int x=1;x<=5;x++){
                if(mapp[i][x]>mapp[i][j]){//判断这一行中有没有比当前点大的
                    flag=1;
                    break;
                }
            }
            if(!flag){//满足条件
                ans++;//这个 ans 主要是用来记录有没有答案，是我一开始看错题然后不想改就把它改成这么用了= =
                cout<<i<<" "<<j<<" "<<mapp[i][j]<<"\n";
            }
        }
    }
    if(ans==0){//没有答案
        cout<<"not found";
    }
    return 0;
}
```


---

## 作者：Eason_AC (赞：16)

## Content
给定一个 $5\times 5$ 的矩阵，请在这个矩阵中找出一个元素，使得这个元素既是它所在行的最大值，也是它所在列的最小值。
## Solution
如果直接暴力枚举每一个元素，再去算每一个元素所在行的最大值和所在列的最小值，再比较，虽然也可以通过这道题目，但是太麻烦了。有没有更简单的方法？

答案是肯定的。

我们发现对于同一行的元素，每次计算所在行的最大值其实是重复 $5$ 次了的，同样地，我们发现对于同一列的元素，每次计算所在列的最小值其实也是重复 $5$ 次了的。有没有不重复的方法？预处理。我们在整个程序的核心部分开始之前，先预处理每一行和每一列，求出每一行的最大值和每一列的最小值。这样的复杂度如果是 $n\times n$ 的矩阵的话是 $\mathcal O(n^2)$ 的（即先枚举每一行或每一列，再枚举每一行或每一列的元素取最值）。然后我们就可以在执行程序的时候，直接拿预处理出来的最大值和最小值比较输出就好了。

预处理的优势在本题中尽管没有很大的体现，但是在今后的信息学习中，你将可以看到预处理发挥的巨大的优化复杂度的作用。
## Code
```cpp
#include <cstdio>
#include <algorithm> //因为要用到 max 和 min 函数
using namespace std;

int fl = 0; //用来判断是否有鞍点
long long a[7][7], col[7], row[7];

int main() {
    for(int i = 1; i <= 5; ++i) row[i] = -0x3f3f3f3f3f3f3f3f, col[i] = 0x3f3f3f3f3f3f3f3f; //C++ 中，0x开头的后面数是十六进制。
    for(int i = 1; i <= 5; ++i) for(int j = 1; j <= 5; ++j) a[i][j] = Rll;
    for(int i = 1; i <= 5; ++i) for(int j = 1; j <= 5; ++j) row[i] = max(row[i], a[i][j]);
    for(int j = 1; j <= 5; ++j) for(int i = 1; i <= 5; ++i)  col[j] = min(col[j], a[i][j]); //想想这里为什么要先循环 j 再循环 i。
    for(int i = 1; i <= 5; ++i) for(int j = 1; j <= 5; ++j) if(a[i][j] == col[j] && a[i][j] == row[i]) {printf("%d %d %lld", i, j, a[i][j]), fl = 1; break;}
    if(!fl) printf("not found");
    return 0;
}
```

---


# 图像旋转

## 题目描述

输入一个 $n$ 行 $m$ 列的黑白图像，将它顺时针旋转 $90$ 度后输出。

## 样例 #1

### 输入

```
3 3
1 2 3
4 5 6
7 8 9```

### 输出

```
7 4 1
8 5 2
9 6 3```

# 题解

## 作者：ImposterAnYu (赞：70)

# 开篇话
这道题乍一看还挺难的，但是发现方法后就好办了。

# 简便做法
首先开一个二维数组 $a_{105,105}$ （~~我的前教练告诉我，数组开得比数据范围大 $5$ 是个好习惯~~）。

这道题让我们将读入的二维数组（即图像）顺时针旋转 $90$ 度以后输出。但是如果我们真的写一个这样的程序的话会十分麻烦，那有没有简便的写法呢？答案是肯定的！那具体怎么简便呢？

我们设样例的输入为：
```
a[1][1] a[1][2] a[1][3]
a[2][1] a[2][2] a[2][3]
a[3][1] a[3][2] a[3][3]
```
那么，想要得到样例输出的话，就要：

1.每次先将图像做左右对称处理，得到下图↓
```
a[1][3] a[1][2] a[1][1]
a[2][3] a[2][2] a[2][1]
a[3][3] a[3][2] a[3][1]
```
2.再将 $i$（前下标） 和 $j$（后下标） 换过来，就可以得到输出！
```
a[3][1] a[2][1] a[1][1]
a[3][2] a[2][2] a[1][2]
a[3][3] a[2][3] a[1][3]
```
3.用代码实现，就是：
```cpp
for(i = 1; i <= m; i++){
        for(j = n; j >= 1; j--) cout<< a[j][i] << " " ;
		cout<< endl;
    }
```
# AC code
```cpp
#include <bits/stdc++.h>//万能头文件（但不是彻底万能的）
using namespace std; 
int m,n,a[105][105],i,j;
int main(){
    cin >> n >> m;
    for(i = 1; i <= n; i++)
        for(j = 1; j <= m; j++) cin >> a[i][j];//读入二维数组里的每一个元素。 
    for(i = 1; i <= m; i++){
        for(j = n; j >= 1; j--) cout<< a[j][i] << " " ;//将图像顺时针旋转 90 度输出。 
		cout<< endl;
    }
    return 0; 
}
```


---

## 作者：·糯· (赞：6)

## 题目分析
其实此题只需将列逆序输出，并且先列再行，那么得到的必然是一个符合题意的矩阵。举个例子，样例组中的7，原本是三行一列，在经过操作之后，就逆序成为一列一行，即一行一列。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110][110],b[110][110],m,n;
double s;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=m;i++){
		for(int j=n;j>=1;j--)//逆序输出，即顺时针旋转九十度
			cout<<a[j][i]<<" ";
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：Asimplename (赞：5)

我们先分析一下思路：

·我们先用一个二维数组存一下像素点。

·然后，根据翻转的规律来输出像素点 (通过样例或者自己模拟就可以知道，列的顺序是不变的，行要倒序输出）。

·这道题数据较小，可以暴力循环。

思路明白了，就上代码吧：

```cpp


#include<iostream>

using namespace std;

int _n = 0;
int _m = 0;
int _map[110][110];//存这张图片。

int main () {
	cin >> _n >> _m;
	for(int i = 1; i <= _n; i ++){
		for(int j = 1; j <= _m; j ++){
			cin >> _map[i][j];//输入这张图片每个像素点的灰度。
		}
	}
	for(int j = 1; j <= _m; j ++){//一定要列优先，因为我们要固定列，逐个输出这一列里的点。
		for(int i = _n; i >= 1; i --){//要到序输出。
			cout << _map[i][j] << " ";
		} 
		cout << endl;//输出一列，换行。
	}
	return 0;
} 
```



---

## 作者：墨忧 (赞：4)

## 题目大意
给定一个矩阵，顺时针旋转 90 度后输出。
## 思路
二维数组存矩阵，行列相反后按列（原本的列）从大到小输出即可输出即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[105][105];//二维数组存矩阵 
int main()
{
    cin>>m>>n;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++) cin>>a[i][j];
    for(int j=0;j<n;j++)//行列相反
    {
        for(int i=m-1;i>=0;i--) cout<<a[i][j]<<" ";
        //列从大到小
        cout<<endl;
    }
    return 0;
} 
```


---

## 作者：TensorFlow_js (赞：3)

# 题目分析

~~疑似与 [B2106](https://www.luogu.com.cn/problem/B2106) 重题。~~ 同 `B2106` 一样，这题我们其实并不需要真的去转置矩阵，只需要将矩阵的行和列互换输出即可，顺时针旋转 $90$ 度相当于倒序输出 `B2106` 结果中的列。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int sz[100][100];//黑白图像
int main(){
    int n,m;
    cin>>n>>m;
    for(int i = 0;i < n;i ++)for(int j = 0;j < m;j ++)cin>>sz[i][j];//输入黑白图像
    for(int i = 0;i < m;i ++){for(int j = n - 1;j >= 0;j --)cout<<sz[j][i]<<" ";cout<<endl;}//倒序输出 B2106 结果中的列
    return 0;
}
```

---


# 图像模糊处理

## 题目描述

给定 $n$ 行 $m$ 列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：

$1.$ 四周最外侧的像素点灰度值不变；

$2.$ 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。

## 样例 #1

### 输入

```
4 5
100 0 100 0 50
50 100 200 0 0
50 50 100 100 200
100 100 50 50 100```

### 输出

```
100 0 100 0 50
50 80 100 60 0
50 80 100 90 200
100 100 50 50 100```

# 题解

## 作者：love_tide (赞：25)

## 分析

+ 因为涉及到求平均值，所以需要用到小数，保险点用  double。

+  floor 函数用于向下取整，与四舍五入不同，下取整是直接取按照数轴上最接近要求值的左边值，即不大于要求值的最大的那个整数值。例如：3.8向下取整为3，当然也可以用 round 函数，即四舍五入。

+ 注意边界的控制，因为要求四周最外侧的值不变。

其他请看代码注释。

## 代码

```cpp
#include<bits/stdc++.h> 

using namespace std;

int n,m;

double a[101][101],b[101][101];

int floorb(int i,int j)
{

	 return floor((a[i+1][j]+a[i-1][j]+a[i][j-1]+a[i][j+1]+a[i][j])*1.0/5+0.5);
//floor函数向下取整	
//我把它写到一个函数里好看一点，* 1.0 / 5 等价于 * 0.2 也可以替换成 / 5.0 。 
// floor（x+0.5） 就相当于 round  (x）
}

int main()
{	
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			b[i][j]=a[i][j];//把数据存到b数组里
		}
	}
	for(int i=2;i<n;i++)
	{
		for(int j=2;j<m;j++)
		{
			b[i][j]=floorb(i,j);	//floorb封装成函数	
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cout<<b[i][j]<<" ";//注意输出格式
		}	
		printf("\n");//换行 	
	}
	
	return 0;
	
}
```
 

---

## 作者：Chtholly_L (赞：16)

### 题意：

输入一个 $n \times m$ 的矩阵，对它进行如下操作：

* 对矩阵四周最外侧的数不作任何特殊处理；

* 将矩阵中间的数取上、下、左、右及自己的平均数，取四舍五入的结果。

---


### 分析：

我们定义了两个数组，一个用来存放原始矩阵，一个用来存放操作后的矩阵。

拿样例举个例子：

| i\j | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 100 | 0 | 100 | 0 | 50 |
| 2 | 50 | 100 | 200 | 0 | 0 |
| 3 | 50 | 50 | 100 | 100 | 200 |
| 4 | 100 | 100 | 50 | 50 | 100 |


分析矩阵，我们可以发现，第一行的 $i$ 都为 $1$ ，第一列的 $j$ 都为 $1$ ，最后一行的 $i$ 都为 $n$ ，左后一列的 $j$ 都为 $m$ 。

那么根据以上结论进行判断是否在四周即可。如果是，就直接将其赋值到另一个数组中，如果不是就将其进行操作。

题中还说了要四舍五入，那么我们就要用到一个函数 ```round()```
 ，它需要调用 ```cmath``` 库。

---

是不是很简单，代码实现它吧。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
double a[101][101],b[101][101];  //b 数组为处理后的数组
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i==1||j==1||i==n||j==m){  // 如果在边缘
				b[i][j]=a[i][j];  //直接赋值
			}
			else{
				b[i][j]=round((a[i-1][j]+a[i+1][j]+a[i][j-1]+a[i][j+1]+a[i][j])/5.0);  // 否则求平均值
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<b[i][j]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：5k_sync_closer (赞：13)

# 前置芝士
`round(double x)` :将 $x$ 四舍五入成整数。
# 思路
建一个新矩阵用来存放答案，枚举一遍原矩阵。

如果枚举到的点在边上，就直接把值赋给新矩阵。

否则就取**原矩阵**的点的上下左右中的平均值。

因为按顺序处理新矩阵时，下方和右方都是0，

所以不能用新矩阵的平均值。
# 代码
```cpp
#include <iostream>
#include <cmath>
using namespace std;
double a[1001][1001], b[1001][1001], n, m;
int main()
{
    cin >> n >> m;
    for(int i = 0;i < n;++i)
        for(int j = 0;j < m;++j)
            cin >> a[i][j], b[i][j] = a[i][j];
    for(int i = 0;i < n;++i)
        for(int j = 0;j < m;++j)
            if(!i || !j || i == n - 1 || j == m - 1)
                b[i][j] = a[i][j];
            else
                b[i][j] = round((a[i][j] + a[i - 1][j] + a[i + 1][j] + a[i][j - 1] + a[i][j + 1]) / 5.0);
    for(int i = 0;i < n;++i)
    {
        for(int j = 0;j < m;++j)
            cout << b[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```


---

## 作者：rui_er (赞：10)

本题我们可以使用二维数组存储输入的每个像素点灰度信息。假设 $a_{i,j}(1\le i\le n,1\le j\le m)$ 表示第 $i$ 行、第 $j$ 列像素的灰度值，用 $b_{i,j}$ 存储模糊处理后的像素灰度值。

对于边界上的点（$i=1,i=n,j=1,j=m$ 四种情况），我们将 $b_{i,j}$ 赋值为 $a_{i,j}$，保持不变。

对于非边界上的点，我们将 $b_{i,j}$ 赋值为上下左右和本身的平均值，我们记 $S=a_{i-1,j}+a_{i+1,j}+a_{i,j-1}+a_{i,j+1}+a_{i,j}$，则 $b_{i,j}=\frac{S}{5}$。但是我们注意到题目要求“舍入到最接近的整数”，考虑如何进行舍入。显然有 $\frac{2}{5}=0.4\lt 0.5$，$\frac{3}{5}=0.6\gt 0.5$，我们求出 $S\bmod 5$ 的值，如果小于等于 $2$ 就舍去，否则加一即可。

参考代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
using namespace std;
typedef long long ll;
const int N = 105; 

int n, m, a[N][N], b[N][N];
template<typename T> void chkmin(T &x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T &x, T y) {if(x < y) x = y;}

int main() {
	scanf("%d%d", &n, &m);
	rep(i, 1, n) rep(j, 1, m) scanf("%d", &a[i][j]);
	rep(i, 1, n) {
		rep(j, 1, m) {
			if(i == 1 || i == n || j == 1 || j == m) b[i][j] = a[i][j];
			else {
				int sum = a[i-1][j] + a[i+1][j] + a[i][j-1] + a[i][j+1] + a[i][j];
				if(sum % 5 <= 2) b[i][j] = sum / 5;
				else b[i][j] = sum / 5 + 1;
			}
		}
	}
	rep(i, 1, n) rep(j, 1, m) printf("%d%c", b[i][j], " \n"[j==m]);
	return 0;
}
```

---

## 作者：FuriousC (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/B2108)

本题按照题目模拟即可，对于边界的处理在代码里会有注释，这里主要讲一下取整。

题目要求舍入到最接近的整数，即四舍五入。

在 C++ 中，有几种四舍五入的方法：

- ### 1. round 函数

**用法：** 

```
double a;
int b;
cin>>a;
b=round(a);
```

这一段代码的含义：将输入的浮点数 $a$ 四舍五入并保存。

- ### 2. 将浮点数强制转为整数

**用法：**

```
double a;
int b;
cin>>a;
b=int(a+0.5);
```

这一段代码的含义同上。

**证明：**

首先你得知道 ``int()`` 是用来强制将一个值转换为整形并向下取整的。

将浮点数 $a$ 加上 $0.5$ 后有两种情况：

- $a$ 原本的小数部分 $\ge 0.5$，此时加上 $0.5$ 后进位，再强制转换就达到了 五入 的效果；

- $a$ 原版的小数部分 $< 0.5$，此时加上 $0.5$ 不会进位，再强制转换就达到了 四舍 的效果。

至此，本题就做完了。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int mapp[105][105],ans[105][105];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>mapp[i][j];
        }
    }//输入
    for(int i=1;i<=n;i++){
        ans[i][1]=mapp[i][1];
        ans[i][m]=mapp[i][m];
    }
    for(int i=1;i<=m;i++){
        ans[1][i]=mapp[1][i];
        ans[n][i]=mapp[n][i];
    }//先将边界处理好，直接将 mapp 的边界赋到 ans  里即可。
    for(int i=2;i<n;i++){
        for(int j=2;j<m;j++){//去掉边界的部分
            ans[i][j]=int((mapp[i-1][j]+mapp[i][j-1]+mapp[i+1][j]+mapp[i][j+1]+mapp[i][j])/5.0+0.5);//或 ans[i][j]=round(...)/5.0;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cout<<ans[i][j]<<" ";
        }
        cout<<"\n";
    }//输出
    return 0;
}
```



---


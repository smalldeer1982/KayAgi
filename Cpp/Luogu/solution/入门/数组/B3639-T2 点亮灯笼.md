# T2 点亮灯笼

## 题目背景

**请尽量在 20min 之内写完题目。这是指「写代码」的时间；「读题」时间不计算在内。**

## 题目描述

有 $n$ 个灯笼环形摆放。最开始，这些灯笼都是关闭的状态。

操作台上有 $n$ 个按钮，按下第 $x$ 个按钮时，会反转灯笼 $x$ 以及相邻两个灯笼的状态。「反转」是指关闭变成点亮、点亮变成关闭。

举一个例子：如果按下第 $5$ 个按钮，则 $4$、$5$、$6$ 号灯笼都会反转；如果按下第 $n$ 个按钮，则 $n-1, n, 1$ 这三个灯笼状态反转。这是因为灯笼放置为环形，$n-1$ 和 $1$ 是与 $n$ 相邻的灯笼。

我们依次按下了一些按钮。你需要编程求出当我们的操作完成后，最终这些灯笼的状态。

## 说明/提示

#### 样例解释
灯笼序列的状态如下：
```plaintext
0 0 0 0 0  # 初始状态
1 1 0 0 1  # 按下 1 之后的状态
1 0 1 1 1  # 按下 3 之后的状态
0 1 1 1 0  # 按下 1 之后的状态
1 0 0 1 0  # 按下 2 之后的状态
```

因此你应当输出 `1 0 0 1 0`。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 1000$，$m\leq 1000$。


## 样例 #1

### 输入

```
5 4
1
3
1
2
```

### 输出

```
1 0 0 1 0```

# 题解

## 作者：览遍千秋 (赞：23)

我们可以使用一个数组 $a$ 来记录当前所有灯的状态，用 $0$ 表示关闭，用 $1$ 表示打开。数组初值均为 $0$。

接下来，对于每一次操作 $x$，将 $a_{x-1},a_{x},a_{x+1}$ 全部取反即可。可以通过 $1-t \rightarrow t$（将 $1-$ 那个数赋值给那个数）的方式取反。

但是由于是环形摆放，需要特判 $x=1,x=n$。

---

```cpp
while(m--) {
	int x; scanf("%d", &x);
	if(x == 1) a[1] = 1 - a[1], a[2] = 1 - a[2], a[n] = 1 - a[n];
	else if(x == n) a[n] = 1 - a[n], a[n - 1] = 1 - a[n - 1], a[1] = 1 - a[1];
	else a[x] = 1 - a[x], a[x + 1] = 1 - a[x + 1], a[x - 1] = 1 - a[x - 1];
}
```

---

## 作者：阮行止 (赞：23)

是一道比较简单的模拟，主要考察对数组的使用。

特殊地，可以通过取模来比较自然地处理环状结构。

```python
import numpy as np

n, m = map(int, input().split())
arr = np.zeros([n], dtype=int)

for _ in range(m):
    x = int(input()) - 1
    arr[x] ^= 1
    arr[(x-1) % n] ^= 1
    arr[(x+1) % n] ^= 1

print(' '.join(map(str, arr.tolist())))
```

---


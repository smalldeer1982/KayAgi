# [语言月赛202210] 垃圾分类

## 题目描述

2077 年，由于资源几近枯竭，梦之城推行了一套极其严格的垃圾分类制度。具体的，梦之城将垃圾分为 $n$ 类，每一类垃圾只能被放入特定的垃圾桶中。由于梦之城掌握了压缩技术，因此在这里**垃圾只有数量之分，没有体积大小之分。**

你是梦之城的一位居民。在你居住的社区外有 $n + 1$ 个垃圾桶，标号为 $1, 2, \cdots, n, n + 1$。

对前 $n$ 个垃圾桶，它们只能接受**对应标号**的垃圾，并且有一定的容量。具体的，你会得到一个长度为 $n$ 的序列 $r _ 1, \cdots, r _ n$。第 $i$ 个垃圾桶只能接受第 $i$ 类垃圾，且最多只能被放入 $r _ i$ 个。

对最后一个垃圾桶，它可以接受所有种类的垃圾，容量也是几近无限的。但是，每向**这个**垃圾桶放入一个垃圾，居委会会向你收取 $c$ 的费用。

某一天，你的家中堆放满了垃圾。在将这些垃圾分类好后，你得到了一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$，代表第 $i$ 类垃圾有 $a _ i$ 个。

你想要知道，如果想要扔掉所有的这些垃圾，你的最小花费是多少。

## 说明/提示

**样例解释**

样例组 #1：最优情况下，你需要向最后一个垃圾桶中放入 $9$ 个垃圾，费用为 $7 \times 9 = 63$。

样例组 #2：最优情况下，你不需要向最后一个垃圾桶中放入任何垃圾，费用为 $0$。

**数据规模与约定**

对前 $20\%$ 的数据，保证 $n = 2$。

对前 $60\%$ 的数据，保证 $n, a _ i, c \leq 10 ^ 3$。

对另外 $10\%$ 的数据，保证 $c = 0$。

对另外 $10\%$ 的数据，保证 $r _ i \geq a _ i$。

对 $100\%$ 的数据，保证 $2 \leq n \leq 10 ^ 6, 0 \leq r _ i, a _ i, c \leq 10 ^ 6$。

## 样例 #1

### 输入

```
2 7
4 3
7 9```

### 输出

```
63```

## 样例 #2

### 输入

```
2 10000
100 100
3 7```

### 输出

```
0```

# 题解

## 作者：洛谷网校 (赞：6)

# B3673 [语言月赛202210] 垃圾分类

## Source & Knowledge

2022 年 10 月语言月赛，由洛谷网校入门计划/基础计划提供。

本题考察对**数组**和**循环语句**的应用。

## 文字题解

### 题目大意

第 $i$ 个垃圾的重量为 $a_i$，且只能扔进容量为 $r_i$ 的垃圾桶里。特别地，最后一个垃圾桶有无限容量。假设你向最后一个垃圾桶扔了重量为 $t$ 的垃圾，那么求 $t\times c$ 的值。

### 解析

我们知道，一个垃圾桶只能放进 $r_i$ 的垃圾，那么 $a_i-r_i$ 就是剩余的垃圾，即丢进最后一个垃圾桶的垃圾的数目。要求的就是所有垃圾桶剩余垃圾的总和，也就是 $\sum_{i=1}^{n}{(a_i-r_i)}$。使用 $ans$ 计数器计数，最后相乘即可。

**注意事项：**

- 注意读入顺序，先读入 $r$ 数组，再读入 $a$ 数组。
- 注意对于每一个 $i$，都需要更新 $ans$。

## 视频题解

完整代码见视频题解。

![](bilibili:BV1ud4y127gi?page=6)

---

## 作者：ShanCreeperPro (赞：6)

# B3673 [语言月赛202210] 垃圾分类 題解

## Source & Knowledge

2022 年 10 月语言月赛，由洛谷网校入门计划/基础计划提供。

本题考察对**数组**的应用。

## 文字题解

### 题目大意

有 $n$ 个只接受第 $i$ 类垃圾的 $r_i$ 容量垃圾桶和一个扔一次垃圾需要 $c$ 元的无限量垃圾桶，给定每种垃圾的个数，问最少要交多少钱。

### 解析

给定了每个垃圾桶的容量和每种垃圾的个数，若要求最少费用，我们就要尽可能的把垃圾装在前 $n$ 个垃圾桶，如果 $i$ 类垃圾的数量大于 $r_i$ 的容量，那么 $a_i - r_i$ 就是剩下的垃圾数量。

所以，我们的目的求变成了求出剩下的垃圾数量的和。

**核心代码**：

```cpp
for (int i = 1; i <= n; i++)
	if (a[i] < r[i])
    	l += (a[i] - r[i]);
```

**注意事项**：

- 存储**剩下的垃圾数量**的变量需要开 `long long` 哦；

### 视频题解

**完整代码请在视频中查看**。

![](bilibili:BV1ud4y127gi?page=6)

---


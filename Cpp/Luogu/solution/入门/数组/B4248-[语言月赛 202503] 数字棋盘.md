# [语言月赛 202503] 数字棋盘

## 题目描述

有一张 $n$ 行 $m$ 列的方格棋盘，其中第 $i$ 行第 $j$ 列的格子上有一个正整数 $a_{i,j}$。

我们称一个方格在另一个方格的**旁边**，当且仅当这两个方格有公共的边。例如，如果我们用 $(i, j)$ 代指第 $i$ 行第 $j$ 列的格子，那么 $(7, 2)$ 在 $(7, 3)$ 的**旁边**，但$(7, 2)$ 不在 $(8, 3)$ 的**旁边**。

现在给定两个整数 $x, y$，请你求出，在整张棋盘上有多少格子，满足它其中的整数是 $x$，且至少有一个其中整数是 $y$ 的格子在它的旁边。


## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/3tzpri74.png)

如图，$3$ 个绿色的 $1$ 符合题目给出的「格子其中的整数是 $1$，且至少有一个其中整数为 $2$ 的格子在它的**旁边**」。最终答案为 $3$。

对于右上角的红色 $1$，没有任何其中整数为 $2$ 的格子在它的**旁边**，因此不符合题目要求。

### 样例 2 解释

对于棋盘中的唯一一个格子，没有任何格子在它的旁边。因此答案为 $0$。

### 数据规模与约定

本题共含 $10$ 个测试点。对于 $100\%$ 的数据，$1 \leq n, m \leq 1000$，$1\le a_{i,j},x,y \le 10^7$（注：$10^7$ 是一千万）。

| 测试点编号 | $n$ | $m$ | $a_{i, j}, x, y$ |
| :----------: | :----------: | :----------: | :----------: |
| $1, 2$ | $\leq 2$ | $\leq 2$ | $\leq 10$ |
| $3 \sim 5$ | $\leq 100$ | $\leq 100$ | $\leq 100$ |
| $6$ | $= 1$ | $\leq 1000$ | $\leq 10^7$ |
| $7$ | $\leq 1000$ | $\leq 1000$ | $= 1$ |
| $8 \sim 10$ | $\leq 1000$ | $\leq 1000$ | $\leq 10^7$ | 


## 样例 #1

### 输入

```
3 3
2 3 1
1 3 1
2 1 2
1 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
1 1
1
1 1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
5 5
4 4 2 3 1
1 1 4 3 4
3 4 2 1 1
3 1 1 3 3
4 3 1 3 1
4 3
```

### 输出

```
4
```

# 题解

## 作者：Maxmilite (赞：1)

# [语言月赛 202503] 数字棋盘 题解

## Source & Knowledge

本题来源于 2025 年 3 月的语言月赛，涉及**二维数组的遍历与运用**。

## 文字题解

题目要求在一个 $n \times m$ 的棋盘上，找出所有数值为 $x$ 的格子，并统计其中有至少一个相邻格子数值为 $y$ 的格子数量。

题目要求比较直白，直接按照题目指示完成即可。首先读入 $n, m, x, y$ 和代表棋盘的 $a$ 数组。

```cpp
cin >> n >> m;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        cin >> a[i][j];
    }
}
cin >> x >> y;
```

之后用二重 `for` 循环遍历棋盘，查找数值为 $x$ 的格子位置。

```cpp
int cnt = 0; // 记录答案数量
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (a[i][j] == x) {
            // ...
        }
    }
}
```

对每个找到的 $(i, j)$ 格子，其上下左右四个方向的相邻格子分别为 $(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)$。检查这四个格子，如果某个相邻格子的值为 $y$，则该格子符合要求，计入答案。

```cpp
// ... 部分：
if (a[i - 1][j] == y || a[i + 1][j] == y || a[i][j - 1] == y || a[i][j + 1] == y) {
   cnt++;
}
```

【**坑点**】此处我们没有检查四个相邻格子是否在 $(1 \sim n, 1 \sim m)$ 范围内。对于本题，如果我们有定义冗余长度的数组（例如 `int a[1005][1005]`），那么超出范围的格子会落在冗余区域或 0 区域（如 `int a[0][XXX]`）内。对于全局数组，这两个区域内的数值默认都是 $0$，一定不会等于 $\geq 1$ 的 $y$，因此不会对答案造成影响。但是，**在很多题目中，检查相邻格子是否超出范围是必须的，请务必注意这一点**。

最终输出 `cnt` 即可。

```cpp
cout << cnt << endl;
```

---


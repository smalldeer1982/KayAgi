# 「CZOI-R2」糖果

## 题目描述

幼儿园里有 $n$ 个小朋友，第 $i$ 个小朋友最开始有 $a_i$ 个糖果。幼儿园老师可以进行无限次操作，每次操作选择一个小朋友，并给他 $k$ 个糖果。

为了避免小朋友因为愤怒而吃掉别的小朋友的糖果，幼儿园老师希望所有小朋友的糖果数量相同。若她的目标可以达成，输出 `YES` 和她最少的操作次数；若不可以，则直接输出 `NO`。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试**。

- Subtask #1（$20\text{ pts}$）：$n,k\le10^3$，$a_i\le10^3$。
- Subtask #2（$30\text{ pts}$）：$k=1$。
- Subtask #3（$50\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le n,k\le10^5,0 \le a_i\le 2^{31}-1$。

## 样例 #1

### 输入

```
6 3
1 1 4 5 1 4```

### 输出

```
NO```

## 样例 #2

### 输入

```
3 2
9 1 5```

### 输出

```
YES 6```

# 题解

## 作者：ikunTLE (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P11371)

### 思路

为了使其操作次数最少，应该把所有的小朋友的糖果数都增加为糖果最多的小朋友的糖果数。设 $m$ 为序列 $a$ 中的最大值。若 $(m-a_i)\bmod k\ne 0$，则无论怎么添加糖果都无法使所有的糖果数相等；否则统计 $\frac{m-a_i}{k}$ 的总和。

**注意事项**

- 不开 `long long` 见祖宗。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e5+10;
int a[N];
signed main(){
	int n=read(),k=read(),m=0;
	for(int i=1;i<=n;++i){
		a[i]=read();
		m=max(m,a[i]);
	}
	int ans=0;
	for(int i=1;i<=n;++i)
		if((m-a[i])%k)
			return printf("NO\n"),0;
		else ans+=(m-a[i])/k;
	printf("YES %lld\n",ans);
	return 0;
}

---

## 作者：Gcc_Gdb_7_8_1 (赞：6)

首先，我们可以想到，如果存在 $a_i \bmod k \neq a_j \bmod k$，其中 $i \neq j$，那么说明幼儿园老师无法让所有小朋友的糖果数量相同，证明：
> 设 $a_i = x_ik + y_i$，$a_j = x_jk + y_j$，其中 $y_{i,j} \le k$，那么让 $a_i$ 加上 $b$ 个 $k$ 后就成了 $(x_I + b)k + y_i$，同理 $a_j$ 加上 $c$ 个 $k$ 后就成了 $(x_j + c)k + y_j$。  
> 可以看到，我们调整的只是 $k$ 前面的系数，却无法改变常数 $y_i$ 和 $y_j$，$y_i$ 即 $a_i \bmod k$，$y_j$ 即 $a_j \bmod k$。  
> 所以，如果 $y_i \neq y_j$，即 $a_i \bmod k \neq a_j \bmod k$，那么 $a_i$ 和 $a_j$ 怎么调整都不会相等，所以如果存在 $a_i \bmod k \neq a_j \bmod k$，其中 $i \neq j$，那么说明幼儿园老师无法让所有小朋友的糖果数量相同。  
> 证毕。

我们可以使用一个 `std::set` 来查看有多少种 $a_i \bmod k$，如果超过 $1$ 种，说明存在 $a_i \bmod k \neq a_j \bmod k$，其中 $i \neq j$。

那如何求出需要多少步呢？可以发现，$\max{a_i}$ 一定是不用调整的，因为它一旦被加上几个 $k$，其它的 $a_j$ 都要加的更多，所以不用让 $\max{a_i}$ 加上几个 $k$。  
于是，我们可以对 $a$ 数组进行排序，此时 $a_n$ 就是 $\max{a_i}$。然后循环遍历 $a_1$ 至 $a_n$，计算它和 $a_n$ 的差（$a_n - a_i$），再除以 $k$，就可以求出 $a_i$ 和 $a_n$ 差几个 $k$ 了，统计所有元素和 $a_n$ 总共差几个 $k$，就可以求出答案了。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define LL long long
#define Pii pair<int, int>
#define ULL unsigned long long

int a[100010];
set<int> s;

int main()
{
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
		s.insert(a[i] % k);
	}
	if (s.size() > 1) {
		cout << "NO" << endl;
		return 0;
	}
	sort(a + 1, a + 1 + n);
	LL ans = 0;
	for (int i = 1; i <= n; ++i) {
		ans += (a[n] - a[i]) / k;
	}
	cout << "YES " << ans;
	return 0;
}


```

---

## 作者：CaiZi (赞：5)

## 糖果 题解
### 题目分析
首先考虑何时无法达成目标，由于每次操作只能给某个小朋友增加 $k$ 个糖果，因此当存在 $(i,j)$ 使得 $a_i\not\equiv a_j\pmod k$ 时，无论怎么给小朋友 $i$ 或 $j$ 增加 $k$ 个糖果，他们的糖果数总是不同，故输出 ```NO```。

然后考虑第二问，不难想到使用贪心。令 $x=\max\{a_i\}$，那么最终一定是让所有人都分到 $x$ 个糖果。否则则需要额外进行 $n$ 的倍数次的操作。所以答案就是 $\sum\frac{x-a_i}{k}$。

时间复杂度 $O(n)$。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[100001],b,c;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b=max(a[i],b);
	}
	for(int i=1;i<=n;i++){
		if(a[i]%k==b%k){
			c+=(b-a[i])/k;
		}
		else{
			cout<<"NO\n";
			return 0;
		}
	}
	cout<<"YES "<<c<<'\n';
	return 0;
}
```

---

## 作者：canwen (赞：5)

我们只需要找到最大的 $a_i$，记为 $maxn$，对于所有 $a_i<maxn$，如果 $maxn-a_i$ 不能够被 $k$ 整除，则无论给 $a_i$ 或者其他数增加多少次都没有办法使得他们相等，否则对答案产生 $maxn-a_i$ 的贡献。

赛时五分钟切的，比较简单，代码不放了。

---

## 作者：Dream_poetry (赞：2)

### 思路：
简单题。

显然如果任意两个数间的差值都是 $k$ 的倍数则必然有解，反之无解，易证。

考虑将 $a$ 数组由小到大排序，进而推导出若后 $n-1$ 个数减 $a_1$ 的差都是 $k$ 的倍数则有解，反之无解。

又因为求最少次数，所以我们就让每个数都变为 $a_n$ 即可。

时间复杂度 $O(n log n)$。

（第一次居然把时间复杂度算成了 $O(n)$，我真强/dk）。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k;
int a[100005];
int ans;

signed main(){
	cin>>n>>k;
	for (int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for (int i=n;i>=1;i--){
		int w=a[i]-a[1];
		if (w%k==0){
			ans+=(a[n]-a[i])/k;
		}
		else{
			cout<<"NO";
			return 0;
		}
	}
	cout<<"YES ";
	cout<<ans;
	return 0;
}
```

---

## 作者：___AaAa_bBcCd___ (赞：2)

发现如果有任意两个小朋友的糖果数量之差不为 $k$ 的倍数，则肯定无法使得所有人相等。又因为这种性质可以传递，所以就看所有的 $a_i$ 和 $a_{i-1}$ 即可（$2\le i \le n$）。

如果可以使所有小朋友的糖果数量相同，那么就应该让所有人的糖果数量增加到最多的那个人，即 $\sum\limits_{i=1}^{n}\dfrac{a_{max}-a_i}{k}$：

```cpp
for(int i=1;i<=n;i++){
  cin>>a[i];
  if(i>1){
    if((a[i]-a[i-1])%k){
      cout<<"NO";
      return 0;
    }
  }
  mx=max(mx,a[i]);
}
cout<<"YES ";
for(int i=1;i<=n;i++)
  ans+=(mx-a[i])/k;
```

- 答案要开 long long。

---

## 作者：封禁用户 (赞：2)

因为我们只能给小朋友糖果而不能拿走，所以我们可以选择初始糖果数量的最大值为标准，来求出操作次数。

（记下文中“糖果数量的最大值”为 $mx$）

如果 $mx-a_i$ 的差不能被 $k$ 整除，也就是说老师无法做到“进行无限次操作，每次给他 $k$ 个糖果”而达成目标，直接输出 `NO` 结束程序，否则累加这个小朋友的最小操作次数也就是 $\dfrac{mx-a_i}{k}$。最后输出 `YES` 和最小操作次数即可。

```cpp
#include <iostream>
using namespace std;

using LL = long long;

const LL N = 1e5 + 5;

LL a[N];

int main()
{
    LL n, k;
    cin >> n >> k;
    LL mx = -1e9;
    for (LL i = 1; i <= n; i++)
    {
        cin >> a[i];
        mx = max(mx, a[i]);
    }
    LL ans = 0;
    for (LL i = 1; i <= n; i++)
    {
        if ((mx - a[i]) % k)
        {
            cout << "NO\n";
            return 0;
        }
        ans += (mx - a[i]) / k;
    }
    cout << "YES " << ans;
    return 0;
}
```

---

## 作者：MingRi_Doctor (赞：1)

## 题目思路：
想要让操作次数最少，就要先找出 $a$ 数组中的最大值 $ma$。再将 $a$ 数组中的每个数都每次加 $k$，一直加到 $ma$，这样就能使操作次数最少。

如果 $(ma-a_i)$ 不是 $k$ 得倍数，说明怎么加都加不到 $k$，就不能使每个小朋友糖果数相同，直接输出 `NO` 即可。
## 代码：

```
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[10000005],ma,t;
int main(){
	cin>>n>>k;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
		ma=max(ma,a[i]);//寻找最大值
	}
	for(int i=0;i<n;i++)
	{
		if((ma-a[i])%k==0) 	t+=(ma-a[i])/k;//判断能否加到ma
		else {
			cout<<"NO";
			return 0;
		}
	}
	cout<<"YES "<<t;
	return 0;
}
```

---

## 作者：glass_goldfish (赞：1)

### 思路
每一次，只能给某一个小朋友 $k$ 个糖果，那么给每个小朋友的糖果数肯定是 $k$ 的倍数或 $0$。所以，必须要所有的 $a_i$ 模 $k$ 的值相等才能成功，否则直接输出`NO`。

然后看可以达成的情况：首先，统计 $a_i$ 中最大的一个（这个小朋友肯定不用给了，作为基准值，让所有的小朋友最后都有这么多糖），然后分别计算它和其余的 $a_i$ 的差值（看看差几颗糖果）的和（计算要给每个小朋友糖数的总和），最后除以 $k$ 即可（因为每次直接给 $k$ 颗糖果）。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int n,k,a[300001];
int mx=-INF,h[300001];
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i],h[a[i]%k]++,mx=max(mx,a[i]);//输入并求出最大值
	if(h[a[n]%k]!=n)cout<<"NO";//无解
	else{
		cout<<"YES ";
		int ans=0;
		for(int i=1;i<=n;i++)
			ans+=(mx-a[i])/k;//统计差值总和
		cout<<ans;//输出
	}
	return 0;
}
```

---

## 作者：wuyouawa (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11371)

### 思路

首先我们可以发现把所有 $a_i$ 变成最大的那个是最优的，因为如果你不能增加若干个 $k$ 个糖果的话，那么你再往上的话，再增加要么最大的不行，要么那个不能增加到最大的不行。所以直接先找到最大值，然后遍历一遍，看是不是可以增加若干个 $k$，不是就不行，输出`NO`，退出程序，否则加上增加次数即可。最后直接输出`YES`和总增加次数。

### CODE


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[100005],ma,t;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        ma=max(ma,a[i]);//找最大值
    }
    for(int i=1;i<=n;i++)
    {
        if((ma-a[i])%k>0)//如果它与最大值的差值无法整除k，也就是无法通过一定次数变成最大值，直接输出NO退出
        {
            printf("NO");
            return 0;//提前结束程序
        }
        t+=(ma-a[i])/k;//否则增加次数
    }
    printf("YES %lld",t);//注意把YES也输出了
    return 0;
}
```

---

## 作者：GXZJQ (赞：0)

# P11371 「CZOI-R2」糖果 题解

[题目链接](https://www.luogu.com.cn/problem/P11371)

## 思路分析

很简单的一道题。

由于对于每个小朋友给予的糖果数均为 $k$，所以很明显，不需要给初始糖果数最多的小朋友任何糖果。接下来，能够达成目标的充要条件就是所有小朋友和糖果数最多的小朋友相差的糖果数可以被 $k$ 整除，直接判断即可。

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, k, a[N], res;
long long cnt;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i], res = max(res, a[i]);
    for (int i = 1; i <= n; i++) a[i] = res - a[i];
    for (int i = 1; i <= n; i++) if (a[i] % k != 0) cout << "NO", exit(0);
    cout << "YES ";
    for (int i = 1; i <= n; i++) cnt += a[i] / k;
    cout << cnt;
    return 0;
}
```

---

## 作者：huanglihuan (赞：0)

### 题目大意
给你 $n$ 个数，问你是否可以让每个数加上 $k$ 使得所有数相等。
### 思路
发现一个数 $x$ 加上若干个 $k$ 后，即 $x\to x+t\times k$，前者与后者模 $k$ 的值相等即为 $x\bmod k$，定义两个正整数 $x,y$ 是否能够满足操作，取决于 $x\bmod k$ 是否等于 $y\bmod k$，因为如果相等，只需将较小者加上相差的值除以 $k$ 就行了。  
由此可以延伸到 $n$ 个数，只要判断他们模 $k$ 的值是否相等就行了。  
次数为每个数到最大值的次数之和，即设 $x$ 为 $\max\limits_{1\le i\le n}(a_i)$，次数为  
$$\sum_{i=1}^{n}(x-a_i)\div k$$
### 赛事代码（可能和讲的不太一样）

```cpp
#include <bits/stdc++.h>
#include <cstdio>
#define int long long
#define ull unsigned long long
#define mod 998244353
#define MOD 1000000007
using namespace std;
const int N = 2e6 + 5,maxn = 3e3 + 5;
int a [N];
inline int read ()
{
	int x = 0;
	bool f = 1;
	char c = getchar ();
	while (c < '0' || c > '9') f = (c == '-' ? !f : f),c = getchar ();
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48),c = getchar ();
	return (f ? x : -x);
}
inline void write (int x)
{
	if (x < 0) putchar ('-'),x = -x;
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
	return ;
}
signed main ()
{
	int n,k;
	cin >> n >> k;
	for (int i = 1;i <= n;i ++) cin >> a [i];
	int maxx = *max_element (a + 1,a + n + 1);
	int ans = 0;
	for (int i = 1;i <= n;i ++)
	{
		if ((maxx - a [i]) % k != 0)
		{
			cout << "NO";
			return 0;
		}
		ans += (maxx - a [i]) / k;
	}
	cout << "YES " << ans;
	return 0;
}
```

---

## 作者：XiaoHongChong (赞：0)

首先，先判断可不可以满足要求。每个数字之间相距 $k$ 的倍数，才能满足要求。这里只需要比较相邻的两个数就可以了，如果相邻的是都相差 $k$ 的倍数，那所有的是都相差 $k$ 的倍数。  
然后，需要最少的操作次数，那就让每个小朋友的糖果都和最多糖果的小朋友一样就可以了。

---


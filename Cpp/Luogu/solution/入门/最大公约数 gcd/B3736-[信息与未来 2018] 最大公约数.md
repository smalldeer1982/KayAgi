# [信息与未来 2018] 最大公约数

## 题目描述

输入三个正整数 $x,y,z$，求它们的最大公约数（Greatest Common Divisor）$g$：最大的正整数 $g ≥1$，满足 $x,y,z$ 都是 $g$ 的倍数，即 $(x \bmod g) = (y \bmod g) = (z \bmod g) = 0$。

## 说明/提示

### 样例解释
#### 样例 $1$
$12 = 2 × 6, 34 = 2 × 17, 56 = 2 × 28, g = 2$。
#### 样例 $2$
$28 = 14 × 2, 70 = 14 × 5, 28 = 14 × 2,g = 14$。
### 数据规模
所有数据满足 $1 ≤ x,y,z ≤ 10^6$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
12 34 56```

### 输出

```
2```

## 样例 #2

### 输入

```
28 70 28```

### 输出

```
14```

# 题解

## 作者：残阳如血 (赞：33)

## 思路分析
对于求 $\gcd(a,b,c)$，我们可以先求出 $k=\gcd(a,b)$，结果即为 $\gcd(k,c)$。

接下来介绍三种求最大公约数的方法。
### 辗转相除法
这里不带证明的给出：
$$
\gcd(a,b) = \begin{cases}
   a &b=0 \cr
   \gcd(b,a\mod b) &b\not=0
\end{cases}
$$
根据递归式一路递归即可。

对于没有构造的数据，这种方法的时间复杂度基本是 $\Theta(1)$，但是最坏情况下的时间复杂度为 $\mathcal O(\log\max\{a,b\})$ 的。
### 更相减损法
对于一般的数据类型，辗转相除法的速度是比较快的，但是对于自己手写的高精度，取模运算会十分的慢，导致辗转相除法的效率大为降低。

所以我们可以用更相减损法来解决问题。但是需要注意这样的话运算次数会增加许多。

同样不带证明给出：
$$
\gcd(a,b)=\begin{cases}
a&a=b\\
\gcd(a-b,b)&a>b\\
\gcd(b-a,a)&a<b
\end{cases}
$$
### STL 大法
在 `<algorithm>` 中，定义有一个函数 `std::__gcd(a,b)`，可以直接求出 $\gcd(a,b)$！

`std::__gcd(a,b)` 底层的实现应该是辗转相除法，所以时间复杂度是 $\mathcal O(\log\max\{a,b\})$。
## 代码演示
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	int x, y, z;
	cin >> x >> y >> z;
	cout << __gcd(__gcd(x, y), z) << endl;
	return 0;
}
```

---

## 作者：Max_robot (赞：5)

这里我们提供两种解决方案。

### 暴力枚举

我们注意到这道题的数据特别小，所以考虑暴力枚举。那么，怎么枚举？很简单，我们从 $10^6$ 枚举到 1，然后进行一些判断。

那么，为什么要从 $10^6$ 枚举到 1，而不是从 1 枚举到 $10^6$ 呢？注意到要求最大公因数，所以从大到小枚举是不错的选择。当然，如果从 1 开始枚举，那么代码永远只会输出 1。

然后来说一下判断条件。我们首先要判断 $i$ 是不是小于 $x,y,z$。因为如果大于，就不能 mod 了。然后根据题目判断就行了。

如果还有什么不懂的就直接看代码吧。


```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long x, y, z;
int main(){
    cin>>x>>y>>z;
	for(int i=1e6;i>=1;i--){//从 1e6 枚举到 1
		if(i>x && i>y && i>z) continue;//如果 i 大于 x,y,z,那么一定就不能 mod 了，所以 continue 掉
		else if(x%i==0 && y%i==0 && z%i==0){//如果符合条件
			cout<<i<<endl;//输出 i 
			return 0;//结束程序
		}
	}
	return 0;//结束程序
}
```

时间复杂度为 $O(n)$。

### 用最大公因数函数

如标题，C++ 里有一个求最大公因数的函数。这个函数就是```__gcd(x,y)```。前面是两个下划线。

还要注意一点，就是这个函数里面只能放相同类型的变量。

那么如何使用这个函数呢？我们可以先求出前两个数的最大公因数。然后求前两个数的最大公因数和最后一个数的最大公因数。

最后输出就好了。

如果还有什么不懂的就直接看代码吧。


```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int x, y, z;
int main(){
	cin>>x>>y>>z;
	int cd=__gcd(x,y);//求前 x 和 y 的最大公因数，并存入一个叫 cd 的变量
	int gcd=__gcd(cd,z);//求 cd 和 z 的最大公因数
	cout<<gcd<<endl;//输出
    //这里再补充一下吧，就是__gcd函数里面只能放相同类型的变量，比如我放两个 int 或两个 long long
	return 0;//结束程序
}
```

时间复杂度为对数级别。

### 结尾

好了，两种方法都讲完了，在时间复杂度上显然第二种最优。但是第一种的代码更好写。所以两种思路都要看一下。这里建议大家用第二种方法，因为如果数据很大的话暴力是过不了的。

如果有什么写的不好的就私信我，我会第一时间改正。

---

## 作者：chen_zhe (赞：4)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题考察循环枚举。根据最大公约数的定义，只有比 $x,y,z$ 三者都小的正整数，才有可能是 $x,y,z$ 的最大公约数。因此，我们可以选择一个数 $x$ 开始，从大到小使用循环判断每个数是否是 $x,y,z$ 的公约数。因为是从大到小判断的，因此第一个是 $x,y,z$ 的公约数的正整数自然是 $x,y,z$ 的最大公约数。由于本题中数据范围较小，因此这样做是可以通过本题的。

参考代码（仅展示关键部分）：

```cpp
for (int i = x; i >= 1; i--) {
    if (x % i == 0 && y % i == 0 && z % i == 0) {
        cout << i << endl;
        break;
    }
}
```

---


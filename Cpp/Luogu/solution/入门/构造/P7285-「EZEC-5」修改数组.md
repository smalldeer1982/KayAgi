# 「EZEC-5」修改数组

## 题目描述

给定一个长度为 $n$、元素由 $0$ 或 $1$ 组成的数组。

现在可以**选择若干（可以为 0）个值为 $0$ 的元素，将其修改为 $1$**。

记：

- $x$ 为数组中最长连续 $1$ 子段的长度（规定，若所有数均为 $0$，则 $x$ 为 $0$）；
- $y$ 为修改的元素的个数。



求要怎么修改才能使 $x-y$ **最大**，并构造一个方案（输出修改后的数组）。

## 说明/提示

**本题采用捆绑测试。**

对于所有数据，保证 $T\le10,1\le n\le 10^5$，数组元素 $\in \{0,1\}$。

- Subtask 1(70 points)：保证 $1\le n\le 10$；
- Subtask 2(30 points)：无特殊限制。

## 样例 #1

### 输入

```
1
1
1```

### 输出

```
1
1```

## 样例 #2

### 输入

```
2
3
1 0 1
5
0 1 0 1 0```

### 输出

```
2
1 1 1
2
0 1 1 1 1```

# 题解

## 作者：wsyhb (赞：33)

## 思路一

对于一个当前全部为 $1$ 的区间 $[l,r]$，**考虑它与包含它的区间哪一个更优**。考虑左端点左边一个位置 $l-1$，若 $l-1$ 为 $1$ 则左端点向左移显然更优；若 $l-1$ 为 $0$，注意到**若将 $l-1$ 位置修改为 $1$ 并将左端点向左移只可能更优，不可能更劣**——因为此时 $x$ 和 $y$ 同时增大 $1$，$x-y$ 不变，且这样有助于将更靠左的 $1$ 与现在的区间相连接。右端点同理。

因此，一种最优的区间即为 $[1,n]$，即：将所有为 $0$ 的数改为 $1$ 时，$x-y$ 取到最大值，为原序列中 $1$ 的个数。

## 思路二

一个显然的结论：被我们**从 $0$ 修改为 $1$ 的位置一定会属于最终序列的唯一的最长连续 $1$ 子段**，否则我们可以不进行对应位置的修改，使得 $x$ 不变，且 $y$ 减小。

因此，$x-y$ 可以转化为“**在最终的最长连续 $1$ 子段中，在原序列中为 $1$ 的位置个数**”。于是我们只需将所有的 $1$ 连成一个区间即可——设最左边一个 $1$ 的位置为 $l$，最右边一个 $1$ 的位置为 $r$，则**使得 $x-y$ 最大的充要条件为 $[l,r]$ 区间里的 $0$ 全部被改为 $1$**，因此将这一段改为 $1$ 即可。（同理也可以全部改为 $1$）

## 代码

思路一

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n;
		scanf("%d",&n);
		int cnt=0;//记录 1 的个数 
		for(int i=1;i<=n;++i)
		{
			int x;
			scanf("%d",&x);
			cnt+=x;
		}
		printf("%d\n",cnt);
		for(int i=1;i<=n;++i)
			printf("1%c",i<n?' ':'\n');
	}
	return 0;
}
```

思路二

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e5+5;
int a[max_n];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n;
		scanf("%d",&n);
		int cnt=0;//记录 1 的个数 
		for(int i=1;i<=n;++i)
		{
			scanf("%d",a+i);
			cnt+=a[i];
		}
		printf("%d\n",cnt);
		int l=1,r=0;//若不存在 1，则不用修改
		for(int i=1;i<=n;++i)
		{
			if(a[i])
			{
				l=i;
				break;
			}
		}
		for(int i=n;i>=1;--i)
		{
			if(a[i])
			{
				r=i;
				break;
			}
		}
		for(int i=l;i<=r;++i)
			a[i]=1;
		for(int i=1;i<=n;++i)
			printf("%d%c",a[i],i<n?' ':'\n');
	}
	return 0;
}
```

PS：若题目要求 $x-y$ 尽量大的同时 $y$ 尽量小，则必须选用第二份代码。（此题没有要求）

---

## 作者：lndjy (赞：14)

结论：全部改成 $1$ 一定是最优解。

证明：我们先找出目前的 $x$，然后把 $x$ 向两边扩张。此时 $y$ 加了 $1$。而扩张后的增加的 $x$ 至少是 $1$(至少有改出来的这个 $1$)，而且还有可能连接上其他是长度，所以增加的 $x\ge 1$。所以每一步都不可能让 $x-y$ 减小。那么我们就全部改了就可以了。

```cpp
#include<iostream>
using namespace std;
int n,cnt;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		cnt=0;
		cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x==1) cnt++;
	}
	cout<<cnt<<endl;
	for(int i=1;i<=n;i++)
	cout<<"1 ";
	}
	
 	return 0;
}
```


---

## 作者：pigstd (赞：9)

如果我们知道一个可能的构造方案，那么如果把这个方案中**最长连续 $1$ 子段的左右的 $0$ 改为 $1$** ，那么 $x,y$ 都会加 $1$，$x-y$ 不变。

所以一个可行的方案必然是全部改为 $1$，答案即为 $1$ 的个数。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,ans,T;

int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;ans=0;
		for (int i=1;i<=n;i++)
		{
			int a;cin>>a;
			if (a==1)ans++;
		}
		cout<<ans<<endl;
		for (int i=1;i<=n;i++)cout<<"1 ";
	}
	return 0;
}
```

---

## 作者：InformationEntropy (赞：7)

按照题目说所的：

$x$ 为最长连续 1 子段的长度，$y$ 为修改的数目，$x-y$ 最大可以想到一个明显的贪心思路：

设原先有 $t$ 个 1，那么修改后的 1 的总个数就是 $t+y$，显然在最好的情况下，最长连续 1 子段长度就是 $t+y$，不会比它更长了。即 $x-y$ 最大值就是 $t$。

所以，只要想到一种构造方式，使得修改后 1 的总个数等于最长连续 1 子段的长度即可。

那直接把所有 0 变成 1 就行了。

最终就输出原先 1 的个数，换行后输出 $n$ 个 1，这题就做完了。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
typedef double db;
template<class T>inline void read(T &x)
{
    x = 0;
    T f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
int main()
{
    int t;
    read(t);
    while(t--)
    {
        int n, x;
        read(n);
        int cnt=0;
        for(int i=1; i<=n; i++)
        {
            read(x);
            if(x==1) cnt++;
        }
        cout << cnt << "\n";
        for(int i=1; i<=n; i++)
        {
            putchar('1');
            putchar(' ');
        }
        putchar('\n');
    }
    return 0; 
    
}
```
当然，也可以倍增输出优化一下。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
typedef double db;
template<class T>inline void read(T &x)
{
    x = 0;
    T f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
int main()
{
    int t;
    read(t);
    while(t--)
    {
        int n, x;
        read(n);
        int cnt=0;
        for(int i=1; i<=n; i++)
        {
            read(x);
            if(x==1) cnt++;
        }
        cout << cnt << "\n";
        string s="1 ";
        while(n)
        {
            if(n&1)
            {
                printf("%s", s.c_str());
            }
            n>>=1;//二进制分解
            s=s+s;//倍增
        }
        putchar('\n');
    }
    return 0; 
    
}
```


---

## 作者：_Clown_ (赞：6)

# 概述
|题号|难度|$AC$时间及记录|
| :----: | :----: | :----: |
|$\texttt{洛谷P7285}$|$\texttt{洛谷难度:入门}$|[$\texttt{On 2021/01/23}$](https://www.luogu.com.cn/record/45371809)|
# 解析
题目大意较为清晰。

我们可以这样考虑：

我们每改变一个0为1，就会使$X$和$Y$都增加$1$

那么我们就不用考虑这一点了，只要把所有的都设为一

一定是最优的

于是不难解决
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int N;
int Array[100001];
int main(void)
{
	register int Case;
	cin>>Case;
	while(Case--)
	{
		register int i;
		cin>>N;
		register int Count;
		Count=0;
		for(i=1;i<=N;i++)
		{
			cin>>Array[i];
			if(Array[i]==1)
			{
				Count++;
			}
		}
		cout<<Count<<endl;
		for(i=1;i<=N;i++)
		{
			cout<<1<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：expnoi (赞：5)

本题纯属思维题，思维难度并不高。


遇到这种**如有多个方案，任意输出一种即可**的题也不要被样例所迷惑。


方法其实很简单，直接把所有的数填成1就是最优的。


Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//数据范围大的尽量用快读
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9')
   {
	   if(ch=='-')
	   {
	   	   w=-1;
	   }
	   ch=getchar();
   }
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int T; 
int main()
{
	T=read();
	int n,a[100001];
	while(T--)
	{
		int sum=0;
		n=read();
		for(int i=1;i<=n;i++)
		{
			a[i]=read();
			if(!a[i])//统计没有填成1的数字有几个
			{
				sum++;
			}
		}
		cout<<n-sum<<"\n";//填满后的n个1减去原先0的个数
		for(int i=1;i<=n;i++)//已经说过，直接全填成1即可
		{
			printf("1 ");
		}
		puts("");//快速换行，puts是换行最快的
	}
}
```

---

## 作者：_SkyBlue (赞：5)

容易发现情况到达最优化时，$x, y$ 同增加 $1$ 时，不改变最大值。所以最优情况之一即为全 $1$。

```cpp
#include <bits/stdc++.h>
using namespace std; 
int main  ( ) { 
  int t; cin >> t; 
  while(t  --) { 
    int n, cnt=0, tmp; cin >> n; 
    for(int i = 1; i <= n;  i++ ) {
      scanf("%d",&tmp);if(tmp==0)cnt++; 
    }
    printf("%d\n",n-cnt);
    for(int i=1;i<=n;i++)printf("1 ");puts(""); 
  } 
}
```


---

## 作者：HYdroKomide (赞：3)

**~~应该是本题的第一波题解罢~~**
# **正文：**
## 解法
首先我们考虑如何构造出 $x-y$ 的最大值，明显如果整个字符串全部都由 $1$ 构成时 $x-y$ 最大（原因在后面说）。因为是 $Special Judge$ 题目，就不需要考虑怎样修改，直接输出 $n$ 减去其中 $0$ 的个数即可。
## 程序如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
    scanf("%d",&t);
    while(t--){
	    int n,a,y=0;
    	scanf("%d",&n);
    	for(int i=1;i<=n;i++){
    		scanf("%d",&a);
    		if(!a)y++;//求其中0的个数存在y中
		}
		printf("%d\n",n-y);//n就代表原题目中的x
		for(int i=1;i<=n;i++)printf("1 ");//输出"1"组成的串
		printf("\n");
	}
    return 0;
}
```
## P.S.原因如下：
我们不妨考虑一种极端的情况：
```
5
1 0 0 0 0
```
明显使 $x-y$ 最大并不需要任何改动，但是我们还是可以发现将其中的 $0$ 全部变成 $1$ 不会让 $x-y$ 的值发生变化。自然这样输出也是可以的，但是为了考虑其它更加复杂的情况，我们可以将问题简化为以上的问题，不需要构造出一种复杂的情况。



# **THE END**

---

## 作者：sycqwq (赞：2)

这一题可以把所有得 0 都修改为 1

因为连续1的数量最多是n个

假设是不连续的，很显然，就是1的数量

因为修改次数加1，1的数量也加1，所以 $x-y$ 是定值

可以把所有的0都修改为1，使所有的1，都是连续的，也是定值，为1的数量,也是最优的

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
int main(){
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		int y=0,n;
		cin>>n;
		for(int j=1;j<=n;j++)
		{
			cin>>a[j];
			if(a[j]==1)
				++y;
		}
		
		cout<<y<<endl;
		for(int j=1;j<=n;j++)
			cout<<1<<' ';		
			cout<<endl;
	}
	return 0;
}

```

---

## 作者：囧仙 (赞：2)

## 题目大意

给定一个长度为 $n$ 的 $01$ 串，每次可以将任意一个 $0$ 变成 $1$ 。询问最后长度最长的全 $1$ 串减去操作次数的最大值，并输出任意一种方案。

## 题解

这题有个非常简单的结论：**将所有 $0$ 变成 $1$ 总是不劣的**。

考虑如何证明。分两种情况：

- $1.$ 整个串全部为 $0$ 。显然 $1$ 的个数不会大于操作的个数，于是答案不会超过 $0$ 。将字符串全部变成 $1$ 显然可以使得答案的值为 $0$ 。

- $2.$ 整个串存在 $1$ 。此时显然存在最长的全 $1$ 串。此时将它左右的 $0$ 变成 $1$ ，显然答案不会更劣。不断这样做下去，整个串就能成 $1$ 了。

于是答案就是 $n-\textsf{0 的个数}$ ，构造方案就是全为 $1$ 。

## 参考代码 

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int T,C[2];
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    dn(qread(),1,T){
        int n=qread(); up(1,n,i) ++C[qread()];
        printf("%d\n",n-C[0]),C[0]=C[1]=0;
        up(1,n,i) printf("%d ",1); puts("");
    }
    return 0;
}
```

---

## 作者：Eason_AC (赞：2)

## Content
有一个长度为 $n$ 的 $0/1$ 串，你可以修改当中的一些元素，求修改后最长的连续为 $1$ 的子串长度减去修改次数的最大值。

**数据范围：$1\leqslant n\leqslant 10^5$。**
## Solution
我们不难发现，将所有的 $0$ 修改成 $1$ 所能得到的答案一定是最大的，因为每次将 $0$ 修改成 $1$ 一定会将答案变大或者不变。
## Code
```cpp
int t, n, a[100007];

int main() {
	scanf("%d", &t);
	while(t--) {
		int cnt0 = 0;
		scanf("%d", &n);
		for(int i = 1; i <= n; ++i) scanf("%d", &a[i]), cnt0 += (a[i] == 0);
		printf("%d\n", n - cnt0);
		for(int i = 1; i <= n; ++i) printf("1 ");
		puts("");
	}
	return 0;

}
```

---

## 作者：Ryo_Yamada (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7285)

题意要我们求 $\max\{x-y\}$。

尝试简化题意：

> $x$ 为数组中最长连续 $1$ 子段的长度， $y$ 为修改的元素的个数。

即：$x$ 为子段长度，$y$ 为子段中 $0$ 的个数。那么 $x-y$ 就是子段中 $1$ 的个数。

现在我们要挑选一个子段使得 $x-y$ 即 $1$ 的个数最大，直接选择整个数组即可。$\text{ans}$ 为数组中 $1$ 的个数，修改后的数组中全为 $1$。

$\text{Code}$：

```cpp
#define W(M) while(M--)
#define rep(i, b, s) for(int i = b; i <= s; i++)
                                          
int main() {
	int T; qread(T);
	W(T) {
		int n, cnt = 0;
		qread(n);
		rep(i, 1, n) { int x; qread(x);	cnt += x; }
		printf("%d\n", cnt);
		rep(i, 1, n) printf("1 ");
		puts("");
	}
 	return 0;
}
```


---

## 作者：Arghariza (赞：1)

不难看出当数列中的 $1$ 全部连续的时候答案取到最大。

又不难发现当数列中一次操作使得没有更多连续的 $1$ 块的时候答案不变。

上述结论结合，可以得到当数列元素全部被修改为 $1$ 的时候答案最大，所以这是最优方案之一。

即统计 $0$ 的个数 $s$ ，再直接用 $n-s$ 计算答案即可。

复杂度 $O(Tn)$ 。 

```cpp
#include <iostream>
#include <cstdio>
namespace mystd {
    #define maxn 100100
    inline int read() {// 快读
        int w = 1, q = 0;
        char ch = ' ';
        while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
        if (ch == '-') w = -1, ch = getchar();
        while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
        return w * q;
    }
    inline void write(int x) {// 快输
        if (x < 0) {
            x = ~(x - 1);
            putchar('-');
        }
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace std;
using namespace mystd;

int t, n, ans;
int s[maxn];

int main() {
    t = read();
    while (t--) {
        n = read();
        for (int i = 1; i <= n; i++) {
            s[i] = read();
            if (s[i] == 0) ans++;// 统计需要修改元素的个数
        }
        write(n - ans);// 输出答案
        puts("");
        for (int i = 1; i <= n; i++) {// 直接输出 n 个 1
            write(1);
            putchar(' ');
        }
        ans = 0;// 记得重置答案
    }
    return 0;
}
```

---

## 作者：monstersqwq (赞：1)

首先找到原数组的最长的 $1$ 子段（没有 $1$ 也没有关系，当然也可以特判一下，答案肯定为 $0$），发现在它两边把 $0$ 变成 $1$ 至少会使得最长的 $1$ 子段长度增加 $1$，而且可能与其他 $1$ 子段接上从而增加更多，而代价仅仅是 $y$ 增加了 $1$，与至少增加的 $1$ 抵消，相当于“稳赚不赔”。

那就可以从最长的 $1$ 子段一直向外延伸、合并、再延伸，直到让整个数组都变成 $1$，这样一定是最优解之一。

那么只需统计原数组中 $1$ 的个数（即不需要修改为 $1$ 的数的个数）作为最大值，第二行输出 $n$ 个 $1$ 即可。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
int n,a[100005];
bool check()
{
	for(int i=1;i<=n;i++)
	{
		if(a[i]==1) return false;
	}
	return true;
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		cin>>n;
		int cnt=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			if(a[i]==1) cnt++;
		} 
		cout<<cnt<<endl;
		for(int i=1;i<=n;i++) cout<<"1 ";
		cout<<endl;
		
	}
	return 0;
}
```


---

## 作者：Terraria (赞：1)

## ~~水题一道。~~

题目就不赘述了，很清楚。

那么要怎么做呢？

考虑有如下的一个数列：

```1 0 0 1 1 1 0 0 1```，目前的 $x=3$ ，$y=0$。

考虑在这个最长连续串的两端的$0$改成$1$，则：

```1 0 1 1 1 1 1 0 1```，目前的 $x=5$ ，$y=2$。

继续在这个最长连续串的两端的$0$改成$1$，得：

```1 1 1 1 1 1 1 1 1```，目前的 $x=9$ ，$y=4$。易得此时的 $x-y$ 最大。

## 为什么？

## Reason：如果扩展一个最长连续$1$串，那么 $x$ 至少会增加$1$， $y$ 都会随之增加$1$，因此 $x-y$ 的值就不会改变或者越来越大。因此，如果将这个数列改成全部都是$1$则这时候得 $x-y$ 的差即为答案。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		int n,a[100009],ans=0;
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++){
			if(a[i]==0) ans++;
		}
		cout<<n-ans<<endl;
		for(int i=1;i<=n;i++) cout<<1<<" ";
		cout<<endl;
	}
}
```
完结撒花~

同时庆祝一下自己第一次在月赛中取得$200+$的~~好~~成绩。

---

## 作者：WsW_ (赞：0)

## 一道比较难想的送分题。
思路：题目要求 $x-y$ 最大，那其实很容易发现，要是你更改一个挨着原来最长的，那 $x$ 会加一， $y$ 也会加一，所以就相当于没变，这不是稳赚不亏吗？所以有个很简单的——把所有都变成1！  
把所有都变成1的话，原来的1就都被连在一起了，而0都变成了1，那么： $x-y$ 就等于：原有1的个数+更改的个数-更改的个数，也就是原有1的个数。  
那最终输出就是所有的都变成了1，注意换行和空格就行了。  
# $Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,t,sum,a;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&l);
		sum=0;
		for(int i=1;i<=l;i++){
			scanf("%d",&a);
			if(a)sum++;         //统计1的个数
		}
		printf("%d\n",sum);
		while(l--)printf("1 \n");  //更改后全是1
	}
	return 0;
} 
```

---

## 作者：zjrdmd (赞：0)

贪心的想，如果我们把一个$0$变为$1$，且当前只有$1$个字符全部为$1$的字段，那么这个$0$变与不变的效果是一样的，于是，我们可以把原数列中所有$0$变为$1$，这样一定是最优解。

代码：

```cpp
#include <iostream>
#include <cstdio>
#define ri register int

inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

const int N=1e5+5;
int a[N];
 
int main(){
	int T=read();
	while(T--){
		int n=read(),sum=0;
		for(ri i=1;i<=n;i++){
			a[i]=read();
			if(!a[i])sum++;
		}
		printf("%d\n",n-sum);
		for(ri i=1;i<=n;i++)printf("1 ");
		printf("\n");
	}
	return 0;
}

```


---

## 作者：yxzly (赞：0)

#### 这只是其中一种思路，并不是只有这种解法

拿到题目，以为是一道dfs。但转念又想：洛谷月赛什么时候第一题也这么难了？

再读一遍题目，注意到了里面的一句话：

_如有多个方案，任意输出一种即可。_ 

也就是说，可以有多个解。


我们又想：一个形如 $...00100...$ 的数组在所有的 $1$ 都相连的情况下，不论怎么把 $0$ 变为 $1$ ，$x-y$ 的值都不变，都是 $1$。当然形如 $...001100...$ 或 $...0011100...$ 数组也是一样的。

多连接一个原有的 $1$ 可以使 $x+1$，而 $y$ 不变。也就是说：我们只需要把所有原有的 $1$ 都连接起来，那时的 $x-y$ 就是最大值。就像你做生意，不赔也不赚，还时不时天上掉金子，何乐而不为？

我们还可以更简单一些：把所有的 $0$ 都变为 $1$ ，这样，所有的 $1$ 都相连，在原有的 $1$ 之外的 $0$ 不会影响 $x-y$ 的值。至于 $x-y$的具体值，用 $1$ 的个数（也就是 $n$ ）减去所有 $0$ （因为所有的 $0$ 都变为了 $1$）设 $0$ 的个数是 $s$，即 $x-y=2n-s$ 。

### 注意：在输出时，修改后的数组的每一个元素后有空格。（比赛的时候我因为这个WA差点没心态爆炸）

##  _Code：_
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t; //询问的次数
    cin>>t;
    for (int j=1;j<=t;j++){
        int n,s=0; //n如题述，s为给定数组中0的个数
        bool in[100001]={0};
        cin>>n;
        for (int i=1;i<=n;i++){
            cin>>in[i];
            if (in[i]==0) ++s;
        }
        cout<<n-s<<endl; //上文已经解释
        for (int i=1;i<=n;i++) cout<<1<<" ";  //注意空格
    }
    return 0;
}
```

---


# [信息与未来 2019] 幸运素数

## 题目描述

素数，又称质数，是指除 $1$ 和其自身之外，没有其他约数的正整数。例如 $2,3,5,13$ 都是素数，而 $4,9,12,18$ 则不是。特别地，规定 $1$ 不是素数（因此自然数的质因数分解就是唯一的）。

如果一个数本身是素数，并且把最低位删除后得到的数仍是素数、再把最低位删除后得到的数仍是素数……如此往复，直到得到一个一位素数，我们就称它是“幸运素数”。以 $233$ 为例：
- $233$ 本身是素数；
- $23=\lfloor\dfrac{233}{10}\rfloor$ 是素数；
- $2=\lfloor\dfrac{23}{10}\rfloor$ 是素数。

因此 $233$ 是“幸运”素数。而 $211$ 则不是幸运素数：虽然 $211$ 是素数，但 $21$ 不是素数。请编程求出一定范围内的所有幸运数字。

## 说明/提示

对于 $100\%$ 的测试数据，有 $1\le m\le n\le 9999$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
6 30```

### 输出

```
7
23
29```

# 题解

## 作者：残阳如血 (赞：28)

## 思路分析
直接模拟即可。

我们需要 $\mathcal O(\sqrt{n})$ 的时间判断一个数是否为质数（~~当然如果你有强迫症也可以用质数筛~~），$\mathcal O(\log n)$ 的时间扫描完一个数字，所以总的时间复杂度就是 $\mathcal O(n\log n\,\sqrt{n})$，能够通过本题。
## 代码演示
可以看注释理解。

```cpp
#include <iostream>

bool isPrime(int x) { // 判断是否为质数
	if (x < 2) return false;
	for (int mod = 2; mod * mod <= x; ++mod)
		if (!(x % mod)) return false;
	return true;
}

bool check(int x) {
	while (x) {
		if (!isPrime(x)) return false;
		x /= 10; // 按位分解，这部操作相当于去掉一个数的最后一位
	}
	return true;
}

int main() {
	int m, n; std::cin >> m >> n;
	for (int i = m; i <= n; ++i)
		if (check(i)) std::cout << i << '\n';
	return 0;
}
```

---

## 作者：chen_zhe (赞：0)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题考察枚举、素数判断。

可以从小到大枚举 $m\sim n$ 范围内的正整数，逐一判断其是否是素数，其除以 $10$ 的结果是否是素数，再除以 $10$ 的结果是否是素数……以此类推，直到不是素数或者只留下一个一位素数为止。这一部分的参考代码：

```cpp
for (int i = m; i <= n; i++) {
    int j = i;
    bool flag = true; // 是否是幸运素数
    while (j > 0 && flag) {
        if (!isPrime(j)) // 判断 j 是否是素数
            flag = false; // 不是幸运素数
        j /= 10; // 除掉最低一位
    }
    if (flag) // 若是幸运素数则输出答案
        cout << i << endl;
}
```

素数判断可以写进一个函数中，以便多次调用。在这里需要注意应当特判 $1$ 不是素数。参考代码：

```cpp
bool isPrime(int x) {
    if (x <= 1) return false;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0)
            return false;
    }
    return true;
}
```

---


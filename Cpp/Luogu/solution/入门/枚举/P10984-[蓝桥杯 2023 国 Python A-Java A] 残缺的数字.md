# [蓝桥杯 2023 国 Python A/Java A] 残缺的数字

## 题目描述

七段码显示器是一种常见的显示数字的电子元件，它有七个发光管组成：

![](https://cdn.luogu.com.cn/upload/image_hosting/pwjpl23s.png)

上图依次展示了数字 $0\sim 9$ 用七段码来显示的状态，其中灯管为黄色表示点亮，灰色表示熄灭。根据灯管的亮暗状态，我们可以用一个状态码（状态码是一个 $7$ 位的二进制数字）来表示一个七段码，令灯管点亮时状态为 $1$，灯管熄灭时状态为 $0$，按照灯管 $\rm ABCDEFG$ 的顺序标识一个七段码，则数字 $0 \sim 9$ 的状态码为：

|数字|状态码|数字|状态码|
|:-:|:-:|:-:|:-:|
|$0$|$1111110$|$5$|$1011011$|
|$1$|$0110000$|$6$|$1011111$|
|$2$|$1101101$|$7$|$1110000$|
|$3$|$1111001$|$8$|$1111111$|
|$4$|$0110011$|$9$|$1111011$|

小蓝有一个喜爱的数字，长度为 $18$ 位，每一位用一个七段码显示器来展示
（每位只能是 $0 \sim 9$，可以包含前导零），由于灯管故障，一些本该点亮的灯管
处于了熄灭状态。例如，对于一个长度为 $2$ 的数字来说，当两个七段码对应的
状态码分别为：$1011111$（高位）、$1110011$（低位）时，原本的数字可能会是：
$68$、$69$、$88$、$89$，有 4 种可能的值。

$18$ 个七段码显示器对应的状态码分别为：

$0000011$，$1001011$，$0000001$，$0100001$，$0101011$，$0110110$，
$1111111$，$0010110$，
$0101001$，$0010110$，
$1011100$，$0100110$，
$1010000$，$0010011$，
$0001111$，$0101101$，
$0110101$，$1101010$。

其中每个表示一个七段码对应的的状态码（按照数字的高位到低位给出）。请你
判断下小蓝喜爱的数字有多少种可能的值。



# 题解

## 作者：Bismuth_Sulfate (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P10984)

## 题意简述

有 $18$ 个七段数码管，它们共同显示了一个 $18$ 位数。但有一些数码管的状态从点亮错误变为了熄灭，现在已知数码管状态，求可能有多少种 $18$ 位数满足这个数码管状态。

## 分析

由于点亮的数码管一定是点亮状态（不会是熄灭状态错误变为了点亮），同时数码管的状态已知，因此我们可以手动画出每个数码管的状态，然后枚举每个数码管可能表示什么数字，枚举出下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/99noosjv.png)

绿色数字代表这一位有几种可能的数字。

根据乘法原理，最后得出的结果是所有这些绿色数字相乘。

同时需要注意是否会出现前导 $0$，我们注意到首位不会是 $0$，因此不需要特殊化。

最后是代码实现，直接一行输出这些数的乘积就行了。

---

## 作者：coderJerry (赞：5)

~~好无聊啊为啥要出这种题~~。

解题方法是：对于每一个七段码，它其中是 $1$ 的位，它对应的数字这一位也必定是 $1$。于是枚举 $18$ 个七段码并统计一共有几种可能情况，然后全部乘起来就是答案。

不过人工计算的话计算量不大，而且写代码要手输很多个七段码，于是我选择人工计算比对，最终答案：$254016000$。

---

## 作者：yangyueming (赞：4)

## 思路

### 一、存入代表 $0 \sim 9$ 的七段码

按位存储，这里打表即可。

```cpp
int a[105][105]={
{0,1,1,1,1,1,1,0},    //0
{0,0,1,1,0,0,0,0},    //1
{0,1,1,0,1,1,0,1},    //2
{0,1,1,1,1,0,0,1},    //3
{0,0,1,1,0,0,1,1},    //4
{0,1,0,1,1,0,1,1},    //5
{0,1,0,1,1,1,1,1},    //6
{0,1,1,1,0,0,0,0},    //7
{0,1,1,1,1,1,1,1},    //8
{0,1,1,1,1,0,1,1}     //9
                      //注意数组下标从0开始
};
```

### 二、读入

按位读入，存在一个数组里。

```cpp
for(int j=1;j<=7;j++)
  scanf("%1d",&b[j]);
```
`scanf("%1d",&b[j]);`代表每次读入一个字符，存在`b[j]`中。

### 三、求每一位的可能性

我们读入一串七段码后之后，将它与代表 $0 \sim 9$ 的七段码进行比较，如果读入的七段码的第 $k$ 位为 $1$，但代表 $x$ 的七段码的第 $k$ 位为 $0$，那么读入的七段码就不可能是 $x$，反之则有可能。因为我们可以将读入的七段码中的 $0$ 改为 $1$，但是不能将 $1$ 改成 $0$。


```cpp
long long check(){
  //b是读入的七段码，a是0到9的七段码
	long long ans=0;
	for(int i=0;i<=9;i++){    //注意从0开始
		int flag=1;
		for(int j=1;j<=7&&flag;j++){
			if(b[j]==1&&a[i][j]==0)flag=0;    //如果该数已经不可能了就退出
		}	
		if(flag)ans++;    //可能答案加一
	}
	return ans;
}
```

### 四、写代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105][105]={
{0,1,1,1,1,1,1,0},
{0,0,1,1,0,0,0,0},
{0,1,1,0,1,1,0,1},
{0,1,1,1,1,0,0,1},
{0,0,1,1,0,0,1,1},
{0,1,0,1,1,0,1,1},
{0,1,0,1,1,1,1,1},
{0,1,1,1,0,0,0,0},
{0,1,1,1,1,1,1,1},
{0,1,1,1,1,0,1,1}
};
int b[105];
long long check(){
	long long ans=0;
	for(int i=0;i<=9;i++){
		int flag=1;
		for(int j=1;j<=7&&flag;j++){
			if(b[j]==1&&a[i][j]==0)flag=0;
		}	
		if(flag)ans++;
	}
	return ans;
}
int main(){
	int n;
	long long ansnum=1;     //long long不开也可以
	cin>>n;     //n代表读入多少个七段码
	for(int i=1;i<=n;i++){
		for(int j=1;j<=7;j++)
			scanf("%1d",&b[j]);
		ansnum*=check();   //边读边算
	}	
	cout<<ansnum<<endl;
	return 0;
}
```

## 五、最后一步

题目让我们算这个样例的结果，带到程序里就可以了。

```
18
0000011
1001011
0000001
0100001
0101011
0110110
1111111
0010110
0101001
0010110
1011100
0100110
1010000
0010011
0001111
0101101
0110101
1101010
```

得答案 `254016000`，输出答案即可。

----------------
结束

---

## 作者：midelashen_official (赞：2)

首先理解一下题目，就是每个 $0 \sim 9$ 的数都有一个单独的编码。

 $1$ 表示亮灯，$0$ 表示灭灯，

给了一些灯的编码，

但是，由于灯有故障，所以，有的灯会熄灭（变为 $0$ ）但是灯不会自己开（变为 $1$ ）

所以可以得出：“*如果一个数的编码 $a$ 的  $a_i$  为  $0$ ，而给出的灯的编码 $b$ 的 $b_i$ 为 $1$ 时，这个灯就不可能代表这个数。*” 

所以，我们只需要将灯的编码和这些数的编码先存起来，然后，每一个灯的编码与 $0 \sim 9$ 的编码配对即可。

给出源代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
string s[15];
string prt[35]={"0000011","1001011","0000001","0100001","0101011","0110110", "1111111","0010110", "0101001","0010110", "1011100","0100110", "1010000","0010011", "0001111","0101101", "0110101","1101010"};//预先处理
//超级麻烦（
void init(){//预先处理
    s[0]="1111110";
    s[1]="0110000";
    s[2]="1101101";
    s[3]="1111001";
    s[4]="0110011";
    s[5]="1011011";
    s[6]="1011111";
    s[7]="1110000";
    s[8]="1111111";
    s[9]="1111011";
    
}
int check(string a,string b){//两编码配对
    int num=1;
    for(int i=0;i<7;i++){
        if(b[i]=='0'&&a[i]=='1')num=0;//配对失败，num值改为0
        
    }
   
    return num;
}
int main(){
    init();
    long long ans=1;
    for(int i=0;i<18;i++) {//一个一个搜给的灯编码
        int num=0;
        for(int j=0;j<=9;j++){//一个一个与数编码配对
            num+=check(prt[i],s[j]);//将成功配对数加起来
        }
        ans*=num;//答案乘起来
    }
cout<<ans;
    return 0;
}
```

---

## 作者：suyi1111 (赞：2)

### 分析
显然，按照题意将每一位有几种可能算出来。

根据乘法原理，最终的答案是每一位的可能数量相乘。
### 代码
```python
q=[1111110,110000,1101101,1111001,110011,1011011,1011111,1110000,1111111,1111011]
m=[11,1001011,1,100001,101011,110110,1111111,10110,101001,10110,1011100,100110,1010000,10011,1111,101101,110101,1101010]
def f(x,y):#f(x,y)表示七段码x的第y位 
	return x//10**(y-1)%10; 
def g(x):#g(x)表示第x个七段码有几种可能的数字
    ans=0;
    for i in range(0,10):
        for j in range(1,8):
            if f(m[x],j):
                if f(q[i],j)==0:#如果第x个七段码的第j位是1而数字i的第j位不是1，说明x不可能是i
                    break;
            if j==7:#否则说明可能是i
                ans=ans+1
    return ans
sum=1; 
for i in range(0,18):
    sum=sum*g(i)
print(sum)


```

---

## 作者：Purrbyte (赞：1)

### 题目大意
有 $10$ 个数字，每个数字对应一个状态码。给出 $18$ 个状态码，在这些状态码中，`1` 可以变成 `0`，求他们对应的数字个数的乘积。

### 思路
在这 $18$ 个状态码中：
- `0` 可以是 `1` 变的；
- `1` 就是 `1`。

遍历这 $18$ 个数字的各个数位，如果 $18$ 个数字的数位为 `0` 且 $10$ 个数字相同位置的数位为 `0`，忽略不计，否则加 $1$，最后把 $18$ 个数字的对应的数字个数乘起来。

### 代码

#### Python
```python
number: list[str] = ["1111110", "0110000", "1101101", "1111001", "0110011", "1011011", "1011111", "1110000", "1111111", "1111011"]
lovenumber: list[str] = ["0000011", "1001011", "0000001", "0100001", "0101011", "0110110", "1111111", "0010110", "0101001", "0010110", "1011100", "0100110", "1010000", "0010011", "0001111", "0101101", "0110101", "1101010"]
ans: int = 1
for i in range(18):
    temp: int = 0
    for j in range(10):
        flag: bool = True
        for k in range(7):
            if number[j][k] == '0' and lovenumber[i][k] == '1':
                flag = False
                break
        if flag:
            temp += 1
    ans *= temp
print(ans)
```
#### C++
```cpp
#include<iostream>
#include<string>
using namespace std;
string number[] = {"1111110", "0110000", "1101101", "1111001", "0110011", "1011011", "1011111", "1110000", "1111111", "1111011"};
string lovenumber[] = {"0000011", "1001011", "0000001", "0100001", "0101011", "0110110", "1111111", "0010110", "0101001", "0010110", "1011100", "0100110", "1010000", "0010011", "0001111", "0101101", "0110101", "1101010"};
int ans = 1;
int main()
{
	for(int i=0;i<18;i++)
	{
		int temp = 0;
		for(int j=0;j<10;j++)
		{
			bool flag = true;
			for(int k=0;k<7;k++)
				if(number[j][k]=='0' && lovenumber[i][k]=='1')
				{
					flag = false;
					break;
				}
			if(flag)
				temp++;
		}
		ans *= temp;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：wanghonghui123 (赞：0)

### 思路

算法：这题使用了**枚举**和**组合排列**算法。

1. 首先我们需要把 $0$ ~ $9$ 对应的七段码状态码给定义了，每个都是 $2$ 进制的，表示七段码的 $7$ 个灯管的亮灭情况。

2. 题目里给了 $18$ 个七段码状态码，我们要算出这 $18$ 个七段码状态码可能的组合数。

3. 把每个给的状态码，都找出对应的数字。

4. 我们需要计算所有的可能的组合数，对于每个给定的状态码，我们需要计算它所对应的可能的数字的数量，然后将这些数相乘，得到总的组合数。

### 结果

运行以下代码便可得出答案

```python
shu = [
    "1111110", 
    "0110000", 
    "1101101", 
    "1111001",
    "0110011", 
    "1011011", 
    "1011111", 
    "1110000", 
    "1111111", 
    "1111011"  
]

num = [
    "0000011", "1001011", "0000001", "0100001", "0101011", "0110110", 
    "1111111", "0010110", "0101001", "0010110", "1011100", "0100110", 
    "1010000", "0010011", "0001111", "0101101", "0110101", "1101010"
]

def f(d):
    a = []
    for i, t in enumerate(shu):
        flag = True
        for j in range(7):
            if d[j] == '1' and t[j] == '0':
                flag = False
                break
        if flag:
            a.append(i)
    return a

n = 1
for i in num:
    t = f(i)
    n *= len(t)

print(n)

```

![](https://cdn.luogu.com.cn/upload/image_hosting/7rqibumn.png)

不难发现，答案就是 $254016000$。

---


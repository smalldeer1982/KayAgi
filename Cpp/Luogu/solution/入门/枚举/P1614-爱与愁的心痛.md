# 爱与愁的心痛

## 题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹·heartache》第一章。

《我为歌狂》当中伍思凯神曲《舞月光》居然没赢给萨顶顶，爱与愁大神心痛啊~~~而且最近还有一些令人伤心的事情，都让人心痛（最近真的很烦哈)……


## 题目描述

最近有 $n$ 个不爽的事，每句话都有一个正整数刺痛值（心理承受力极差）。爱与愁大神想知道连续 $m$ 个刺痛值的和的最小值是多少，但是由于业务繁忙，爱与愁大神只好请你编个程序告诉他。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$。
- 对于 $60\%$ 的数据，保证 $n \leq 100$。
- 对于 $90\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $0 \leq m \leq n \leq 3 \times 10^3$，$1 \leq a_i \leq 100$。

## 样例 #1

### 输入

```
8 3
1
4
7
3
1
2
4
3```

### 输出

```
6```

# 题解

## 作者：Dog_Two (赞：182)

需要我们维护的区间长度固定，那么我们可以用一种简单的方法O（n）处理。

例如样例数据中，我们只需要把前3个数值计为sum，在m+1...n中扫描，每次减去区间外的数值，加上新进入区间的数值，再更新答案就可以了。

代码还是简短一点比较好看哦~


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int hrt[3010];
int ans;
int sum;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) 
        scanf("%d",&hrt[i]),ans=i<=m?sum+=hrt[i]:min(ans,sum+=hrt[i]-hrt[i-m]);
    cout<<ans;
    return 0;
}

```

---

## 作者：Bartholomew (赞：139)

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int h[100000],a[100000];//开一个足够大的数组
int main() {
    int n,m;
    cin>>n>>m;  //输入数字 n，m
    for(int i=0; i<n; i++)    //循环输入数字
        cin>>a[i];//输入数
    for(int i=0; i<=n-m; i++)//双重循环，一个记录初始的数，一个是之后m个数的和
        for(int k=i; k<i+m; k++)
            h[i]=h[i]+a[k];
    sort(h,h+n-m);//快排....将最大的放置在最后，或者用reverse经行翻转
    cout<<h[0];//输出数，输出最小的数
}
```

---

## 作者：Iktsuarpok (赞：52)



```cpp
#include <stdio.h>
int val[3001],n,m,ans;
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) 
		scanf("%d",&val[i]),ans+=val[i];//先输入前m个,并求和 
	int minn=ans;
	for(int i=m+1;i<=n;++i) {//从第m+1个开始，比较 n-m次求最小值 
		scanf("%d",&val[i]);
		ans=ans-val[i-m]+val[i];//区间整体向后移动一次，即移出val[i-m]，加入val[i] 
		minn=minn>ans?ans:minn;//==> minn=min(minn,ans);
	}
	printf("%d",minn);
	return 0;
}
```
举个栗子：

8 3

1 4 7 3 1 2 4 3

前三个和为：1+4+7=12，此时m个为 1 4 7

1、移出1，加入3，此时m个为4 7 3 ，和为：4+7+3=14，所以此时最小值为12

2、移出4，加入1，此时m个为7 3 1 ，和为：7+3+1=11，所以此时最小值为11

3、移出4，加入1，此时m个为3 1 2 ，和为：3+1+2=6 ，所以此时最小值为6

......

循环n-m次后，就能找到最小值

---

## 作者：幽界の冥神 (赞：32)

本题数据不大(m<=n<=3000)，可以纯暴力水过（用时较多）

PS:请不要复制代码，谁都不想棕名对吧

话不多说——上代码

-----------------------------------一道分割线-------------------------------------------------

```cpp
#include "cstdio"
int n,m,a[3002],ans=1<<30;//初始时将answer设为无穷大
int Min(int a,int b){return a<b?a:b;}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);//输入
    for(int i=m;i<=n;i++){//一个大枚举
        int sum=0;
        for(int j=i;j>=i-m+1;j--) sum+=a[j];//求i~i-m+1中所有元素的和值
        ans=Min(ans,sum);//统计最小
    }
    printf("%d",ans);//输出
    return 0;
}
```
-----------------------------------又一道分割线-------------------------------------------------
这样的算法时间复杂度约为O(nm)，不会超时

而如果使用前缀和数组，则可将时间复杂度降为O(n-m)

小知识：前缀和简单来说就是从1~i所有数据之和记为sum[i]

话不多说——上代码

-----------------------------------再一道分割线-------------------------------------------------

```cpp
#include "cstdio"
int n,m,In,Sum[3002],Ans=1<<30;//初始时将answer设为无穷大
int Min(int a,int b){return a<b?a:b;}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1,In;i<=n;i++){
        scanf("%d",&In);//输入 
        Sum[i]=Sum[i-1]+In;//前缀和，减小时间复杂度 （重点来了）
    }
    for(int i=m;i<=n;i++) Ans=Min(Ans,Sum[i]-Sum[i-m]);//运用前缀和数组，找最小（两项相减就是i~i-m+1中所有元素的和值）并统计最小
    printf("%d",Ans);//输出
    return 0;
}
```
-----------------------------------最后一道分割线-------------------------------------------------
PS:如果想练手，那么“P1147 连续自然数和”是个好选择


---

## 作者：Aw顿顿 (赞：29)

这道题其实很简单，我们看着代码慢慢讲
```cpp
#include<bits/stdc++.h>
using namespace std;
```
头文件，使用命名空间
```cpp
int n,m,a[100001],mi=100000,t=0;
```
定义变量、数组
```cpp
cin>>n>>m;
for(int i=1;i<=n;i++)cin>>a[i];
```
读取一下数据，准备开始工作！
```cpp
for(int i=1;i<=n-m+1;i++)
{
	for (int j=1;j<=m;j++)t+=a[i+j-1];
	if(t<mi)mi=t;
	t=0;
}
```
遍历整个数组，在数组中每三个数一回合进行查找，其中“if(t<mi)mi=t;”语句为判断并保存最小值。
```cpp
cout<<mi<<endl;
return 0;
```
最后输出答案。
这道题不难，主要是要细心，我这个方法应该算比较普通的吧，那我们看一下整体代码吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100001],mi=100000,t=0;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n-m+1;i++)
    {
    	for (int j=1;j<=m;j++)t+=a[i+j-1];
    	if(t<mi)mi=t;
        t=0;
    }
    cout<<mi<<endl;
    return 0;
}
```

---

## 作者：行者_Walker (赞：26)

 这道题很简单大多数人看了这道题后都想到了不同的的**做法**

 觉得简单的可以去做（玩）[滑动窗口](https://www.luogu.org/problem/P1886)

 我想的方法不一样，我一来就想到了区间查询,打了线段树去交，结果只得了90分，为什么呢？有一个点MLE额(恐怖)



~~感兴趣的可以找一找错在哪里，都是很常见的又很难找到的bug~~

对线段树感兴趣的童鞋->[线段树模板](https://www.luogu.org/problem/P3372)

对于线段树，我就不多解释了，毕竟不是本题的正解，但是这个高级数据结构对区间的修改查询很有帮助!!推荐学习喵

- **注**：代码均防抄袭，编译能过，答案不正确，主要的思路理解部分绝对正确

#### 90分代码：不是正解，可以看看就行（走马观花ing）

```cpp
# include <iostream>
# include <cstdio>
# include <cmath>
# include <algorithm>
# include <queue>
# include <stack>
# define mid (l+r)>>1
using namespace std;
int read();
void built(int x,int l,int r);
int q(int x,int l,int r,int ll,int rr);
int t[12001];
int a[3001];
int n,m;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)
	{
		int ab=read();
		
	}
	built(1,1,n);
	int minn=99999999;
	for(int i=1;i<=n-m+1;i++)
	{
		minn=min(minn,q(1,1,n,i,i+m-1));
	}
	printf("%d",minn);
	return 0;
}


int q(int x,int l,int r,int ll,int rr)
{
	int ans=0;
	if(ll<=l&&r<=rr)
	{
		return t[x];
	}
	if(mid<ll)
	ans+=q(x<<1|1,mid+1,r,ll,rr);
	else if(mid>=rr)
	ans+=q(x<<1,l,mid,ll,rr);
	else
	{
		ans+=q(x<<1,l,mid,ll,rr);
		ans+=q(x<<1|1,mid+1,r,ll,rr);
	}
	return ans;
}
void built(int x,int l,int r)
{
	if(l==r)
	{
		t[x]=a[l];
		return ;
	}
	built(x<<1,l,mid);
	built(x<<1|1,mid+1,r);
	t[x]=t[x<<1]+t[x<<1|1];
}
int read()
{
	int ans=0,flag=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
		{
			flag=-1;
			ch=getchar();
			break;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
```
### 下面是**正解**

因为涉及到一个移动区间的和的改变

我们可以处理出来一个前缀和

那么什么是**前缀和**呢？

- 背景：前缀和是一种重要的预处理，能大大降低查询的时间复杂度，处理后的结果是另外一个数组ans[n]。

- 定义：一个数列 (由a[ 1 ] a [ 2 ] a [ 3 ]... a [ n ]组成) 的前  k（1<=k<=n）  个数的和(包括k)

举个栗子：

ans 是处理出来的前缀和数组

a 是输入得到的原始数组

ans[ 1 ] = a [ 1 ];

ans[ 2 ] = a [ 1 ] + a[ 2 ];

ans[ 3 ] = a [ 1 ] + a [ 2 ] + a [ 3 ];

ans[ k ] = a[ 1 ] + a[ 2 ] +...+ a [ k ];

对于一个区间( i , j )的和就可以用移动区间的右边（j）存的前缀和（ans[ j ]）减去左边（i - 1）存的前缀和(ans[ i - 1 ])

#### 那么为什么要i - 1呢？

还是举个栗子：

令 i = 2 ;j = 3;

那么区间和因该是 a [ 2 ] + a[ 3 ]
 
ans [ 3 ] = a [ 1 ] + a [ 2 ] + a [ 3 ]; （1）

ans [ 2 ] = a [ 1 ] + a[ 2 ]; （2）

如果直接相减 (1)-(2)得到的不是a [ 2 ] + a[ 3 ]而是a [ 3 ]

ans [ 3 ] - ans[ 1 ]才是答案

所以要 i - 1

正解：

```cpp
# include <iostream>
# include <cstdio>
# include <cmath>
# include <algorithm>
# include <queue>
# include <stack>
# define mid ((l+r)>>1)
using namespace std;
int ans[3001];
int n,m;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)
	{
		int ab=read();//相当于cin>>ab;
		ans[i]=ans[i-1]+ab;//处理前缀和
		
	}
	
	int i=1,j=m;
	int minn=99999999;
	while(j<=n)//模拟区间移动
	{
		minn=min(minn,a[j]-a[i-1]);//i是左边，j是右边
		i++;j++;//区间右移
        	
	}
	printf("%d",minn);
	return 0;
}

int read()
{
	int ans=0,flag=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
		{
			flag=-1;
			ch=getchar();
			break;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return flag;
}
```
(注重思路，~~不管代码~~)


---

## 作者：鹤笙 (赞：19)

来自小小牛的第一次题解--
# 咳咳重点来了；
 _简单易懂，适合萌新解读；
 
------------------------------
```
    cin>>n>>m;首先输入；
    for(int i=1;i<=n;i++)cin>>x[i];再接着输入痛苦•；
    for(int i=1;i<=n;i++)
    {
        if(i==n-m+2)break;如果最后不够m个痛苦值那么跳出；
        for(int j=i;j<=i+(m-1);j++)按顺序搜索时框住一个连续的区间；
        {
            sum+=x[j];加上区间痛苦值；
        }
        ans=min(ans,sum);比较最小痛苦值；
        sum=0;记得”归零”（熟悉的计算器声音）
    }
    if(ans==2147483647)ans=0;！！最后如果没有找到最小值那么输出0；
    cout<<ans;完成;
```

OK，那么有一点很重要；
当输入 0 0；
ans就会爆掉；
so，我们才需要特判；
补
```
#include<bits/stdc++.h>
using namespace std;
int n,x[300001],sum,ans=2147483647,m;
```

------------

简单易懂！


---

## 作者：一座城·守一人 (赞：18)

# 一种比较奇葩的写法：
## 滑动窗口
### （真实的算法肯定不是这个样子的；真实的是用队列）

## 主要思路
用n[i]来存储各个数，m表示的是连续数的数量。

**用f[i]表示从第i-m+1到i累加所得到的和**

这样子就有了

$f[i]=f[i-1]-n[i-m]+n[i];$

最后把f数组排一下序，f[m]就是最小值

### 贴标程
 _我其实挺讨厌滑动窗口的，但是有时候，用它可以降低很多时间复杂度。_ 

**下面的那些大佬的思路都是用暴力搜索，但是很显然的是，n比较大时是过不了的，另外，滑动窗口的主要思想请自行百度。**
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n[200005],f[200005],minn=0;
bool s=false;
int main() {
	int p,m;
	cin>>p>>m;
	for(int i=1; i<=p; i++) {
		cin>>n[i];
	}
	for(int i=1; i<=m; i++) {
		f[m]+=n[i];//初始化f[m]
	}
	/*cout<<f[m];
	cout<<endl<<endl<<endl;*/
	for(int i=m+1; i<=p; i++) {
		f[i]=f[i-1]-n[i-m]+n[i];//公式，解释在上面。
		//cout<<f[i]<<endl;
	}
	sort(f+m,f+p+1);
	cout<<f[m];//最大的一个数
	return 0;
}
```

---

## 作者：情到深处人孤独 (赞：17)

本人原创题，虽挂着“搜索/枚举”的标签，但几乎用不到，只要用**贪心**就好了。

输入n、m，依次输入ai，重复n-m**+1**（节约时间且保险，一定要+1）次：求出连续m段的和，如果小于Min，那么Min就是这次连续m段的和。最后只要输出Min就好了。水题……

    ```delphi

#include<iostream>
using namespace std;
int a[3001],n,m,Min=1000001;
int Sum(int I)
{
    int x=0;
    for (int i=1;i<=m;i++)
        x=x+a[I+i-1];
    return x;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for (int i=1;i<=n-m+1;i++)
        {
         int x=Sum(i);
         if (x<Min)
            Min=x;
        }
    printf("%d\n",Min);
    return 0;
}
    
```

---

## 作者：Stick_With_Mars (赞：4)

萌新第一次交题解，求过~
这道题前面的许多巨佬用数组过了，本蒟蒻给出用一种用队列的做法。
可能有人问队列是啥，~~队列就是queue~~，
度娘说：“队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。”
直接放coding了：：
```cpp
#include <bits/stdc++.h>
#include <queue>
using namespace std;
int n,m,temp,sum,minn=INT_MAX;//minn定大一点~ 
int main (){
	queue<int> q;//创建一个整数队列 
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>temp;
		q.push(temp);//将temp加入队列 
		if(q.size() ==m){//q队列内有m个元素 
			sum=0;
			for(int j=1;j<=m;j++){//遍历队列所有元素 
				sum+=q.front() ;
				q.push(q.front() );
				q.pop() ;
			}
			if(sum<minn) minn=sum;//判断最小值 
			q.pop() ;//很重要，不要忘了弹出 
		}
	}
	if(n==0) minn=0;//这要特判 
	cout<<minn;
	return 0;
}

```


---

## 作者：AuCloud (赞：4)

~~闲的没事来刷水题~~
# ~~真水~~
### *什么是前缀和
举个栗子

现在有一个数组……

A[]={1,2,3,4,4,5,5,4,3,4,3,2}

如果B为A的前缀和数组，那么：

B[0]=A[0]

B[1]=A[0]+A[1]

B[2]=A[0]+A[1]+A[2]……

B[n]=A[0]+A[1]+…+A[n]

观察一下，我们发现：

**B[n]=B[n-1]+A[n]**

### *区间和与前缀和

这道题里显然我们求的是一段长度为m的区间中的和。

（也就是A[i+1]+A[i+2]+…+A[i+m]）

那么我们可以推导出：

B[i+m]-B[i]=A[i+1]+A[i+2]+…+A[i+m]

也就是说，**区间(i,i+m]的和可以用O(1)的时间求！**

那就完事辽！

# 代码

```cpp
#include<iostream>
using namespace std;
int a[3001];//前缀和数组
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x;//因为原数组并没有什么用，所以不用存
		cin>>x;
		a[i]=a[i-1]+x;//前缀和
	}
	int ans=100000;
	for(int i=m;i<=n;i++)
		ans=min(ans,a[i]-a[i-m]);//用更小的更新ans的值
	cout<<ans;
	return 0;
}
```


---

## 作者：wuhao1027 (赞：4)

算法很简单，把n个数每m个数加起来的和比较一遍大小就OK

但是重点是在各种小问题上优化自己的代码

比如说，定义一个简单的宏函数来返回二者之间的最小值

比如说，并不需要做(m-n+1)\*m次加法，只需要m+(n-m)\*2次加法就OK了

这些细微的习惯，将会影响代码的可读性，并养成一个良好的习惯




```cpp
#include<stdio.h>
#define MIN(a,b) (a)>(b)?(b):(a)
int main()
{
    int i,min=0,num,n,m,a=-1,A[3001];
    scanf("%d%d", &n,&m);
    while (n--) scanf("%d", &A[++a]);
    for (i=0;i<m;i++) min+=A[i];
    num = min;
    for (i=m;i<=a;i++){
        num+=A[i];
        num-=A[i-m];
        min = MIN(num, min);
    } 
    printf("%d", min);
    return 0;
}
```

---

## 作者：yangyuang (赞：4)

看起来好像没有PY题解

那本蒟蒻就来发一篇

主要思想：前缀和

~~看起来好像很高级~~

前缀和，意思就是前面若干个数的和

那有什么用

~~一点用都没有~~

用来求区间数字和！

具体楼上大批dalao已经详细解答了

直接上代码

---------------------------------------

```python
a = input().split()
b, c = int(a[0]), int(a[-1])
d = []
for x in range(b):
    d.append(int(input()))
'''
5行代码来输入第一行？
这是人性的扭曲
还是道德的沦丧
谁让PY只能换行输入！
'''
e = [0]#初始化多加一个0防止RE
'''
鬼才知道我RE了多少次
'''
for x in range(1, b + 1):
    e.append(sum(d[:x]))#存储前缀和
b -= c
mn = 300000000001#初始化最小值
if b == 0:
    mn = e[-1] - e[0]#特判相等情况
else:
    for x in range(0, b):
        if e[x + c] - e[x] < mn:
            mn = e[x + c] - e[x]#打擂台找最小
print(mn)#华丽丽输出
```
-----------------------------------------------

---

## 作者：BronyaZaychik (赞：4)

作为一只~~傻逼~~提高选手

看到区间求和题目

“这不肯定是要用线段树吗”

当然看到了这题的入门难度标签还是压制住了我写线段树的冲动

~~虽然还是拍了个树状数组~~

综上 这次的题解是树状数组的解法（我看好几页都没有 求过qwq）

下面上带注释的代码

```cpp
#include<bits/stdc++.h>
#define int long long//这个……我本来想写线段树来着(x
#define lowbit(x) (x&(-x))//lowbit函数可以在开头宏定义
using namespace std;
int c[10010];//这种情况下开大点没坏处反正不会mle
int a[10010];
int n,m;
int ans=19260817;//因为要求最小值，所以给ans赋值一个大数作为初值
void add(int x,int w)//修改
{
	while(x<=n)
	{
		c[x]+=w;
		x+=lowbit(x);
	}
}
int ask(int x)//查询
{
	int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
//上方都是树状数组基本操作，简单而言就是用树状数组维护一个前缀和，然后用前缀和差分就可以求最大值啦
inline void xzyopr()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		add(i,a[i]);
	}
	for(int i=m;i<=n;i++)
	{
		ans=min(ans,ask(i)-ask(i-m));//树状数组上的前缀和差分
	}
	cout<<ans;
}
signed main()//如果define了int为long long 那main函数必须这样了
{
	xzyopr();//个人习惯，相信大家都能看懂是怎么回事
	return 0;
}
```

---

## 作者：Victorique (赞：3)

这是我能想出来的最简单的方法了，比起楼下的几位都应该快一点。

应该没有和我重的了吧。

下面贴代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<stack>//无数头文件堆叠起来也算是万能头文件。
using namespace std;
int n,m,a[100001],s,l,k=10000000;//这个k的值足够大，一开始还以为要用long long。
int main()
{
    cin>>n>>m;//这个没什么好说的，下面是关键。
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s=s+a[i];//一遍读入一边把新读入的值加进计数器里面。
        if(i==m||l==m)//如果此时i或l有一个等于m，
        {
            if(s<k)//判断过程，很大众化。
            k=s;
            s-=a[i-m+1];//关键，把最前面加进去的值吐出来，使长度始终为m。
            l=m;//这个代表着只要第一次进入了判断语句，以后就会一直进入。
        }
    }
    if(k==10000000)//为了防止极端数据出现：n=0，会造成无法进入循环。这里做了一个小小处理。
    cout<<"0";
    else
    cout<<k;
return 0;//结束。
}
```

---

## 作者：睡在墙上的猫 (赞：3)

#之前一直在修改minn

```cpp
##include<iostream>
using namespace std;
int main()
{
    int i,n,m,p[1000],tmp,minn=2144444444;
    cin>>n>>m;
    for (i=1;i<=n;i++)
    {
        cin>>p[i];
    }
    for (i=1;i<=n-m+1;i++)//符合要求的数
    {
        tmp=0; 
        for (int j=i;j<=i+m-1;j++)他们的后m的数
        {
            tmp+=p[j];加上
        }
        if (tmp<minn) minn=tmp;去最小
    }
    cout<<minn;
    return 0;
}
***望采纳***
```

---

## 作者：九指客 (赞：3)

```cpp
#include<stdio.h>
#include<string.h>//源文件
int main()
{
    int min=0,i,j,m,n;//定义
    int a[3001];
    scanf("%d%d",&n,&m);//输入
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//输入
    }
    for(i=1;i<=m;i++)
    min+=a[i];//累和
    for(i=1;i<=n-m;i++)
    {
        int b=0;
        for(j=i;j<=i+(m-1);j++)//搜索
            b+=a[j];
            if(b<min)/判断 
                min=b;
    }     
    printf("%d",min);//输出
}
```

---

## 作者：Arcturus1350 (赞：2)

其实已经有题解发过前缀和了。

但是！！！

#重点在一个小小的常数优化#

但是数据大了以后比楼下们跑的会快！！！

楼下用前缀和的题解都是跑了两遍循环。

而实际上一遍循环就可以呀。

就是加一段这个

```cpp
if(i>=m)
    if(low>(ans[i]-ans[i-m]))
        low=ans[i]-ans[i-m];
```
直接维护一个low值就好。每次输入都判一下就简单很多。

直接上完整代码。

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
using namespace std;///头文件们不说
int n,m;
long long ans[3005];//用于储存前缀和的数组
int num[3005];//储存数据
long long low=0x3f3f3f3f;//要维护的对象。最小值
int main()
{
    cin>>n>>m;//输入
    for(int i=1;i<=n;i++)
    {
        cin>>num[i];//输入
        ans[i]=ans[i-1]+num[i];//计算前缀和
        if(i>=m)//好了亮点在这！！！不用再扫一遍。//就是可以截取以这个点为重终点的区间时
        {
            if(low>(ans[i]-ans[i-m]))//如果以前的最小值小于这一段的最小值。
            {
                low=ans[i]-ans[i-m];//更新
            }
        }
    }
    if(low==0x3f3f3f3f)//如果发现没有更新
    {
        printf("0");//那就是0；
        return 0;
    }
    printf("%lld",low);//直接输出
    return 0;//程序拜拜
```
不过用scanf还会快一点


---

## 作者：fletmer (赞：2)

#数学题，用前缀和维护 ，这里附上我的一篇关于前缀和的文章

http://blog.csdn.net/qq\_38973846/article/details/77188175

先上代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <string>
#include <algorithm>
using namespace std;
int f[3001],ct[3001];//前缀数组f和刺痛值ct
int main(){
    memset(f,0,sizeof(f));
    int n,m,minn=0xfffffff;//将最小值初始化为一个极大的值
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>ct[i];//刺痛值
        f[i]=f[i-1]+ct[i];//求每个数的前缀和
    }
    for(int i=m;i<=n;i++){
        minn=min(minn,f[i]-f[i-m]);//求定区间和并取最小的一部分
    }
    cout<<minn;
    return 0;
}
```

---

## 作者：wswhy (赞：2)

水题啊。。。单纯的模拟，m个一组，一组一组的往下试，只要比上一组小就存入变量l中，直到最后，l中一定是最小的，直接输出就可以了。。。。。


```cpp
var
      a:array[1..3000] of integer;
      i,j,m,n,s,l:longint;
    begin
      readln(n,m); s:=0; l:=0;
       for i:=1 to n do readln(a[i]);
      for i:=1 to m do l:=l+a[i];  l:=l+1;
    for i:=1 to n-m+1 do
      begin
        for j:=i to i+m-1 do
          s:=s+a[j];
          if s<l then  l:=s;
          s:=0;
        end;
          writeln(l);
end.
```

---

## 作者：谁懂谁伤心 (赞：2)

好水的题。。。暴搜吧，1至m，2至m+1...一个个比较输出最小的那个就可以。

```cpp
#include <iostream>  
using namespace std;  
int main()  
{  
int n,m,x=0,minx=9999999; scanf("%d%d",&n,&m);   
if (n==0||m==0) {cout <<"0"; return 0;}  
int k[n-1];  
for(int i=0;i<m-1;i++) {scanf("%d",&k[i]); x+=k[i];}  
for (int i=m-1;i<n;i++)  
{scanf("%d",&k[i]); x+=k[i]; if (x<minx) minx=x; x-=k[i-m+1];}  
cout <<minx;  
return 0;      
}
```

---

## 作者：藤林椋 (赞：2)

区间求和，当然是要搬出我们强大的线段树啊！单次询问logN的复杂度也不算高，n <= 3000绝对能跑过去。而且结构体封装的线段树真的不是一般好写啊！

不过线段树唯一的缺点是要开4倍空间，所以最后一个测试点会MLE。

写这一篇题解的目的就是想让大家了解线段树这个~~造化钟神秀~~方便的数据结构。

```cpp
#include <bits/stdc++.h>
#define re register
#define inf 0x3f3f3f3f
#define lson o << 1
#define rson o << 1 | 1
using namespace std;
const int N = 100005;
int n, m, minn = inf;
inline int read(){
    int f = 0, x = 0; char ch;
    do {ch = getchar(); f |= ch == '-';} while (!isdigit(ch));
    do {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();} while (isdigit(ch));
    return f ? -x : x;
}//读优
struct Segment_Tree{
    static const int BASE = 3000;
    int sum[BASE << 2 | 3];//维护区间和的数组
    inline void pushup(int o){//向上调整区间和
        sum[o] = sum[lson] + sum[rson];
    }
    inline void build(int l, int r, int o){//建树
        if (l == r){
            sum[o] = read();
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, lson);
        build(mid + 1, r, rson);
        pushup(o);
    }
    inline int querysum(int l, int r, int ql, int qr, int o){//查询区间和
        if (ql <= l && r <= qr){
            return sum[o];
        }
        int mid = (l + r) >> 1, ans = 0;
        if (ql <= mid)ans = querysum(l, mid, ql, qr, lson);
        if (qr > mid)ans += querysum(mid + 1, r, ql, qr, rson);
        return ans;
    }
}T;
int main(){
    //freopen("data.txt", "r", stdin);
    n = read(), m = read();
    T.build(1, n, 1);
    for (re int i = 1; i <= n - m + 1; ++i)minn = min(minn, T.querysum(1, n, i, i + m - 1, 1));//每m个ai就求和一次并与minn比较
    printf("%d", minn);//输出minn（即每m个ai的最小值）
    //fclose(stdin);
    return 0;
} 
```

---

## 作者：backordinary (赞：2)

写一波树状数组求前缀和，树状数组这个东西最适合区间修改和区间求和了，洛谷上也是有模板题的（还是两道不同的），感兴趣的可以去做做看

这题代码如下

```cpp
#include<algorithm>
#include<cmath>
#include<queue>
#include<cstring>
#include<stack>
#include<string>
#include<cstdlib>
#include<iostream>
#include<cstdio>//#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int intmax=0x3f3f3f3f;//int a[];memset(a,0x3f,sizeof(a));
inline int read()
{
    int kk=0,f=1;
    char cc=getchar();
    while(cc<'0'||cc>'9'){if(cc=='-')f=-1;cc=getchar();}
    while(cc>='0'&&cc<='9'){kk=(kk<<1)+(kk<<3)+cc-'0';cc=getchar();}
    return kk*f;
}
int tree[3005];int n;
void add(int a,int b)
{
    while(a<=n)
    {
        tree[a]+=b;
        a+=(a&-a);
    }
}
int sum(int a)
{
    int tot=0;
    while(a)
    {
        tot+=tree[a];
        a-=(a&-a);
    }
    return tot;
}
int main()
{
    n=read();int m=read();
    for(int i=1;i<=n;++i)
    {
        add(i,read());
    }int mm=intmax;
    for(int i=m;i<=n;++i)
    {
        mm=min(mm,sum(i)-sum(i-m));
    }
    printf("%d",mm);
}
```

---

## 作者：kub_inst (赞：1)

# 一道水题
看到有人直接用两个for暴力mn解决问题。确实，o（mn）暴力解决问题好想又好做。虽然这道题o(mn)能AC，但有更好的解法。~~AC了管你o（n），淼到题了就行（滑稽）~~
### 个人思路如下：
先输入m个（题目给出m<=n),记录全部数据之和，然后边输入边更新当前数据，再与之前对比，便可以得出结果了
##### //表达不好，还是上代码吧qaq
```cpp
#include<cstdio>
void out(int n)
{
	if(n<10)
	{
		putchar('0'+n);return;
	}
	out(n/10);
	putchar(n%10+'0');
}//int类型读函数，可以看作cin
int read()
{
	int ret=0;char c=getchar();
	while(!(c<='9'&&c>='0'))c=getchar();
	while(c<='9'&&c>='0')
	{
		ret=ret*10+c-'0',c=getchar();
	}return ret;
}//int类型写函数，可以看作cout
main()
{
	int m,n,t=0,les=0,all;
 	//这里all为用于每次更新的数据，les为最小值
	n=read();m=read();
	int a[n];
	for(;t<m;t++)
	{
		a[t]=read(),les+=a[t];
	}//先键入前m个数并统计数值
	all=les;//初始化all
	for(;t<n;t++)
	{
		a[t]=read(),all=all-a[t-m]+a[t];
  		//读入数据并更新all
		if(all<les)les=all;
     //如果更新后的all更小，更新les
	}
	out(les);//输出答案
}
```
如此，完美地o(n)过
##### 顺带一提


---

## 作者：sjl40 (赞：1)

/\*这题一看就知道最好的方法肯定是：单调序列。单调序列是把前一个给拿走再把后面一个给加进去找最小值，就可以AC了。\*/

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,i,a[3005],t=1,s,mi=2100000000;
int main()
{ 
 cin>>n>>m;
 for(i=1;i<=n;i++)cin>>a[i];
 for(i=1;i<=m;i++)s+=a[i];//先把前M个加上
 if(mi>s)mi=s;//看看第一组是不是最小值
 for(i=m+1;i<=n;i++)
 {
 s-=a[t];t++;s+=a[i];if(s<mi)mi=s;//执行把前一个拿走，把后一个拿进去，最后把前一个的位置换一下，判断是不是最小值。
 }
 if(s<mi)mi=s;//再看一下是不是最小值。这是保险。
 cout<<mi;//输出最小值
}
```

---

## 作者：fallingdust (赞：1)

水题一道，代码如下：（枚举法，真没什么好说的）


```cpp
#include <iostream>
using namespace std;
int a[100005];
int main()
{
    int x,i,n,m,h=0,min=32767;//定义初值（min最小值就定最大的）
    scanf ("%d%*c%d",&n,&m);//输入，也可以用cin，不过可能会tle
    for (i=0;i<n;i++)
    {
        scanf ("%*c%d",&a[i]);//读入，存进数组中。
    }
    for (i=0;i<=n-m;i++)
    {
        h=0;
        for (x=0;x<m;x++)//这个循环用来存值
        {
            h+=a[i+x];//求和
        }
        if (h<min) min=h;//判大小
    }
    printf ("%d",min);//输出
    return 0;
}
这么简单？没错，就是这么水，这么easy。
```

---

## 作者：Right (赞：1)

看到楼下的几位大神都用了各种神奇的方法，但都至少为2n，但是，其实这题还有真的线性的做法，而且代码简洁明了，即为在读入的时候顺便进行统计区间最小值，这样当我们读入完的时候，也就是出答案的时候了

代码如下：

```cpp
#include <stdio.h>
#include <iostream>
using namespace std;
int n,m,a[3008],now,ans=0x7f7f7f7f; >>如果每次求最小值的话，初值应为最大
int main()
{
    int i; cin>>n>>m;
    if (n==0) ans=0; >>如果根本没数，答案为0
    for (i=1; i<=n; ++i){
        cin>>a[i];
        if (i<m) now+=a[i]; >>读入的数小于连续的数时，我们继续读入
        else{
            now=now+a[i]-a[i-m]; 不然每次更改连续m个区间内的值，并进行比较大小
            ans=min(ans,now);
        }
    }
    cout<<ans; >>读完，答案也出来了
}
```

---

## 作者：封禁用户 (赞：1)

这道题枚举显然会game over......

所以，我们还是用单调队列来做这道题吧！

算法简单爆了，

只要将这m个数的和的所有方案用O（n）算法枚举一次就行了

具体看代码:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,s,mm,x[1000000];
int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++) scanf("%d",&x[i]);//输入部分 
    for (int i=1;i<=m;i++) s+=x[i];mm=s;
    //用s将前m个数加起来，并将最小值变量的初值定为 s。 
    for (int i=m+1;i<=n;i++)  
    {
        s+=x[i];
        s-=x[i-m];
        //说恶心点，每次循环都将最前面的悲伤值吐出来，
        //再把新的悲伤值塞进去...... 
        if (s<mm) mm=s; 
    }
    cout<<mm;
    return 0;       
} 
虽然解释简单粗暴，但相信各位还是能懂的。
```

---

## 作者：撩妹凛酱 (赞：1)

这题可以用前缀和（就是从第1个数加到第i个数的和）来做。

设b数组储存前缀和，用i从m枚举到n，i-m到i这m个数的心痛值之和就是b[i]-b[i-m]，然后比较最小的出来即可。









```cpp
 program tpylxintong;
var
  a,b:array[0..6000] of longint;
  n,m,i,ans:longint;
begin
  readln(n,m);
  for i:=1 to n do begin
    readln(a[i]);
    b[i]:=a[i]+b[i-1];//储存前缀和
  end;
  ans:=maxlongint;
  for i:=m to n do
   if b[i]-b[i-m]<ans then
    ans:=b[i]-b[i-m];//即这m个心痛值的和
  writeln(ans);
end. 

```

---

## 作者：doby (赞：1)

这题和P1816有一些微小的类似，但是不需要修改某个数

于是……

线段树维护区间最小值……

233333333……

应该不可能有人和我重复了吧……

```cpp
#include<cstdio>
using namespace std;
int n,m,tree[12009],a[3009],sum=0,out,fh;
char c,cc;
int read()//读入优化
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
int min(int a,int b)//毫无卵用的手写min
{
    if(a<b){return a;}
    else{return b;}
}
void change(int k,int l,int r,int p,int c)//修改操作，因为……一开始赋值时还是需要修改的……
{
    if(l==r)
    {
        tree[k]=c;
        return;
    }
    int mid=(l+r)/2;
    if(p<=mid){change(k*2,l,mid,p,c);}
    else{change(k*2+1,mid+1,r,p,c);}
    tree[k]=min(tree[k*2],tree[k*2+1]);
}
int query(int k,int l,int r,int ll,int rr)//维护操作……
{
     if(ll<=l&&rr>=r){return tree[k];}
    int mid=(l+r)/2,ret=233333333;
    if(ll<=mid){ret=min(ret,query(k*2,l,mid,ll,rr));}
    if(rr>mid){ret=min(ret,query(k*2+1,mid+1,r,ll,rr));}
    return ret;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read(),sum=sum+a[i];//找出连续m个数之和
        if(sum>=m)
        {
            sum=sum-a[i-m];
            change(1,1,n-m+1,i-m+1,sum);//插入
        }
    }
    printf("%d",query(1,1,n-m+1,1,n-m+1));//一共有n-m+1个不同的和，在这之中找最小
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：1)

题解 by redbag

http://redbag.duapp.com 欢迎来踩

枚举所有可能。

语文不太好所以描述有点问题，不过大概能懂吧。

时间复杂度O（n）

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
using namespace std;
int a[3010]; 
int main()
{
    int n,m,i,mi=2000000000;
    scanf("%d%d",&n,&m);
    int s=0;//s存的是i-m+1天~第i天的忧愁值 
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if (i>m)//如果已经有连续m天了。 
        {
            mi=min(mi,s);//和目前的最小忧愁值比较，取最小值 
            s=s-a[i-m];//前去这个区间中最前面的一天 
        }
        s+=a[i];//加上今天的忧愁值 
    }
    mi=min(mi,s);//最后比较一次，因为最后一个区间没有比较得到 
    cout<<mi;//输出 
    return 0;
}

```

---

## 作者：M_seа (赞：1)

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int a[3000];
int main()
{
    int i,j,n,z=0,min=2147483647,m;//min设成最大的正整数保证第一次就可以赋值
    scanf("%d%d",&n,&m);
    for (i=0;i<n;i++)
        scanf("%d",&a[i]);
    for (i=0;i<n-m+1;i++)//贪心
    {   
        z=0;//清零
        for (j=i;j<m+i;j++)//贪心a【i】后面的m个数，记的是m+i
        {
            z=z+a[j];//累加
        }
        if (z<min) min=z;//判断是不是最小的
    }
    printf("%d\n",min);
    return 0;
}
```

---

## 作者：我叫小明0_0 (赞：1)

枚举一边找最值即可，注意答案用long long

```cpp
#include<stdio.h>  
#include<stdlib.h>  
int n;  
int a[3001];  
int m;  
long long min=0;  
int main()  
{  
    scanf("%d",&n);  
    scanf("%d",&m);  
    for(int i=1;i<=n;i++)  
       scanf("%d",&a[i]);  
    for(int i=1;i<=m;i++)  //先取前m为答案
       min+=a[i];  
    for(int i=1;i<=n-m;i++)  //无脑枚举
    {  
       int k=0;  
       for(int j=i;j<i+m;j++)  //累加求和
          k+=a[j];  
       if(k<min)    //取最小值
          min=k;  
    }  
    printf("%d",min);  
    return 0;  
} 
```

---

## 作者：Skywalker_David (赞：0)

纯模拟！纯水题！！


详细算法请看代码：

```delphi
 
var
    n,m,i,j,min,minn:longint;
    a:array[1..50001] of longint;
begin
    readln(n,m);
    min:=0;
    for i:=1 to n do
        readln(a[i]);
    for i:=1 to n do
        min:=min+a[i];
    for i:=1 to n-m do begin
        minn:=0;
        for j:=i to i+m-1 do
            minn:=minn+a[j];
        if minn<min then min:=minn;
    end;
    write(min);
end.

```

---

## 作者：Ufowoqqqo (赞：0)

数据范围较小，可用O(n+(n-m+1)\*m)的方法做，不超时。

```delphi

var
 n,m,i,j,t,ans:longint;
 a:array [1..3000] of longint;
begin
 readln(n,m);
 for i:=1 to n do
  readln(a[i]);
 ans:=maxlongint;
 for i:=1 to n-m+1 do
 begin
  t:=0;
  for j:=i to i+m-1 do
   inc(t,a[j]);
  if t<ans then ans:=t;
 end;
 write(ans);
end.

```

---

## 作者：taotao (赞：0)

```cpp
var
  n,m,i,j,jsq,min:longint;
  a:array[1..3000] of longint;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      readln(a[i]);
      min:=min+a[i];
    end;
  for i:=1 to n-m do
    begin
      jsq:=0;
      for j:=i to i+m-1 do
        jsq:=jsq+a[j];
      if jsq<min then
        min:=jsq;
    end;
  writeln(min);
end.
代码如此简单，加油过此题！！！
```

---

## 作者：taophee (赞：0)

想法：

本人看到这种题目就懒了.....就有纯的暴力吧，i范围1~n-m+1，j范围i~i+m-1

然后累加，找出其中最小的那个值就可以了

这样比较保险，而且这题数据很小，也不需要啥高深的算法（水题）

程序：

```delphi

var
n,m,i,min,j,s:longint;
a:array[1..50000] of longint;

begin
  read(n,m);
  for i:=1 to n do
    read(a[i]);
  min:=maxlongint;
  for i:=1 to n-m+1 do
   begin
    s:=0;
    for j:=i to i+m-1 do
      s:=s+a[j];
    if s<min then min:=s;
  end;
  writeln(min);
end.

```

---

## 作者：wanglishuang (赞：0)

模拟题，不难。

直接上关键步骤：

[codec ]

```cpp
int min;//定义一个最小值;
for(int i=1;i<=m;i++)
min+=a[i];//min赋值为a[1]+a[2]+...a[m]; 
for(int i=1;i<=n-m;i++)
{
int b=0;//b是当前m个数的总和;
for(int j=i;j<=i+(m-1);j++)
b+=a[j];//b=a[i]+a[i+1]+...a[i+m-1]; 
if(b<min)//如果b比最小值还小，那最小值等于b; 
min=b;
} 
cout<<min;//输出最小值。 
```
[/codec ]
新人发帖，求采纳！！！


---


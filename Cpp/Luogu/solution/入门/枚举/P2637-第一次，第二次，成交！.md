# 第一次，第二次，成交！

## 题目描述

因为奶牛们的节食运动给 FJ 余下了一大批干草无法处理，所以他准备要开一个拍卖会去出售他的干草。

他有 $n$ 批干草。他的客户有 $m$ 个，都是和他一样的农夫。第 $i$ 名农夫会告诉 FJ 他会为 FJ 的每批干草付 $p_i$ 的钱。每个农夫都想买（也只想买）FJ 的一批草料。

为了确保农夫们不会互相嫉妒，所以 FJ 决定要以一个固定的价格出售他的草料。每一个出价大于等于 FJ 的要价的农夫将会买到草料。

请你帮助 FJ 找出能让他卖出最多的钱的最低的单批草料的售价。

## 说明/提示

FJ 有 $5$ 批草料，$4$ 个农夫想要购买。他们出价分别为：每批草料为 $2$，$8$，$10$ 和 $7$。

FJ 应该把价格设定为 $7$，这样会有 $3$ 个农夫会付钱买草料，FJ 自己会挣到 $21$ 的钱。

---

对于 $100\%$ 的数据，$1\leq m, n\leq 1000$，$1\leq p_i\leq 1,000,000$。

## 样例 #1

### 输入

```
5 4
2
8
10
7```

### 输出

```
7 21```

# 题解

## 作者：天照之焱 (赞：271)

(⊙o⊙)…，本蒟蒻认为这题so easy下面奉上c++超短代码
第一次发题解，不喜欢勿喷哈︿(￣︶￣)︿

```cpp
#include<bits/stdc++.h>//万能头文件，你值得拥有；  
using namespace std;  
int a[100002],m,n,i,s,p,j,minn,ans,maxx;//在int main（）上定义，默认初始值为0；
int main()  
{  
    cin>>n>>m;//n批干草与m个用户； 
    for(i=1;i<=m;i++)  
        cin>>a[i]; //每位农夫出的money；
     for(i=1;i<=m;i++)   
         {p=a[i];  
          s=0;// 切记归0，切记归0，切记归0，重要的事情说3遍！！！   
          for(j=1;j<=m;j++)  
              if(a[j]>=p)s++;  
              if(s>=n)s=n;  
              if(p*s>maxx)  
                 {maxx=p*s;ans=p;}
        }cout<<ans<<" "<<maxx;
    return 0;//养成好习惯从我做起；
}//完美谢幕
```


//Thanks♪(･ω･)ﾉ点个赞再走吧，恳求审核过关(づ￣3￣)づ╭❤～

---

## 作者：zmt2016 (赞：68)

分析一下题目，发现农夫JOHN的出价只能是某个人的叫价，否则一定存在更优解。   
那么，我们就可以先将叫价排一遍序，从高价或低价枚举一遍，比较即可。  
AC代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[1005],m;
int main()
{
	int i,k,maxn=0,ans=0;
	cin>>n>>m;
	for(i=1;i<=m;i++)
		cin>>a[i];
	sort(a+1,a+m+1);
	for(i=m;i>=1;i--)
	{
		if(a[i]*(m-i+1)>maxn)
			maxn=a[i]*(m-i+1),ans=a[i];
	}
	cout<<ans<<" "<<maxn;
    return 0 ;
}
```   
这个代码虽然A了，但不难发现问题。

n干什么去了？除了定义与输入，就没用到过n！

所以，还得加上判断草料是否够用。

下面正解：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[1005],m;
int main()
{
	int i,k,maxn=0,ans=0;
	cin>>n>>m;
	for(i=1;i<=m;i++)
		cin>>a[i];
	sort(a+1,a+m+1);//将叫价从小到大排个序 
	for(i=m;i>=1;i--)//枚举一遍叫价 
	{
		if(a[i]*(m-i+1)>maxn && m-i+1<=n)//得到的钱大于之前最多的，并且草料够用 
			maxn=a[i]*(m-i+1),ans=a[i];//替换 
	}
	cout<<ans<<" "<<maxn;//输出 
    return 0 ;
}
```

做题一定要仔细！！！

---

## 作者：Warriorszx (赞：30)

先把每个人出的价格从小到大排序。

从最小价格开始枚举。

显然后面的人出的价格都比当前价格大。

答案就是当前价格\*（m-当前位置+1）的最大值。

再记录一下去最大值时的价格就好啦

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int a[1010];
bool cmp(int x,int y)
{
    return x<y;
}
int main()
{
    int n,m,ans=0,sum;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&a[i]);
    }
    sort(a+1,a+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        int now=a[i];
        if(now*(m-i+1)>ans)
        {
            ans=now*(m-i+1);
            sum=now;
        }
    }
    printf("%d %d",sum,ans);
    return 0;
}
```

---

## 作者：sishuinianhua (赞：17)

这道题其实就是一个排序而已。因为草料有限，所以要买给给钱尽量多的农夫。
###### 代码如下
用结构体储存答案要比用数组储存要好的多
```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<string>
#include<cctype>
#include<algorithm>
using namespace std;
struct A {
	int b1,c1;
} a[100005];//a[]用来储存答案
bool cmp2(A x,A y) {
	return x.b1>y.b1;
}
bool cmp(int x,int y) { //后面排序用
	return x>y;
}
int n,m,jia_ge,jia_ge_nong_fu[100005],i;//拼音看的懂吧
int main() {
	cin>>n>>m;
	for(i=0; i<m; i++) {
		cin>>jia_ge_nong_fu[i];
	}//一系列的输入
	sort(jia_ge_nong_fu,jia_ge_nong_fu+m,cmp);//从大到小排序
	if(n>m) { //伏笔
		n=m;
	}
	for(i=1; i<=n; i++) { //因为草料只有n份，所以要把草料买出至少前n的价格
		a[i-1].b1=jia_ge_nong_fu[i-1]*i;
		a[i-1].c1=jia_ge_nong_fu[i-1];
	}
	sort(a,a+n,cmp2);//找到最多的钱
	cout<<a[0].c1<<' '<<a[0].b1;
	return 0;
}
```

---

## 作者：Drifterming (赞：9)

```
/*
	要让john卖更多的钱。
	我们把每个农夫出的钱降序排序。
	枚举每个农夫 i=1 -> m ,
	那么i和i之前的农夫 1->i 都可以用p[i]的价格买到草料，
	所以 ans=max(ans,p[i]*min(i,n))，
	为什么要写min(i,n)，
	是因为 可能会出现草料比农夫多的情况，
	但是最多只会有n个农夫来买草料，多余的(m-n)批草料是不会有人买的。
	所以，我们也可以直接让i枚举到min(n,m)
		然后让ans=max(ans,p[i]*i)就行了。 
*/ 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1e3+5;

int n,m;
int p[N];

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
		scanf("%d",&p[i]);
	sort(p+1,p+m+1,greater<int>() );
	int ans_sum=0,ans_min=0;
//	for(int i=1;i<=m;++i)
//	{
//		if(ans_sum<p[i]*min(i,n))
//		{
//			ans_sum=p[i]*min(i,n);
//			ans_min=p[i];
//		}
//	}
	for(int i=1;i<=min(n,m);++i)	//也可以这样写，直接枚举到min(人，草) 
	{
		if(ans_sum<p[i]*i)
		{
			ans_sum=p[i]*i;
			ans_min=p[i];
		}
	}
	printf("%d %d",ans_min,ans_sum);
	return 0;
}
```

---

## 作者：Phykyer (赞：8)

这是一道模拟题，核心思路其实就是排序后进行比较

题意其实是这样，就是选择一个价格，卖给可以接受这个价格( 即出价高于定价 )的农场主，所以就是**选择的价格*出价比该价格高的农场主数=总价**

明白之后就很好做啦。。。。。。

上代码( 大佬们轻喷 orz )
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;

bool comp(int x,int y)
{
	return x>y;
}//将数组逆序排列方便比较

int n,m,a[1010],ans=0,num=0;//num为单价，ans为总价 

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>a[i];
	sort(a+1,a+m+1,comp);
	//for(int i=1;i<=m;i++) cout<<a[i]<<" ";
	if(n>m)//批数比买主数多的情况 
	{
		for(int i=1;i<=m;i++)//循环界限用m 
		{
			if(ans<i*a[i])//这里用手写判断因为要存num的值，i*a[i]即为出售价 
			{
				ans=i*a[i];
				num=a[i];
			}
		}
	}
	else//买主数多于批数的情况
	{
		for(int i=1;i<=n;i++)//无需考虑a[m-n]后的出价，以n为循环界限 
		{
			if(ans<i*a[i])//同上 
			{
				ans=i*a[i];
				num=a[i];
			}
		}
	}
	cout<<num<<" "<<ans;//输出 
	return 0;
/*perfect!*/ 
}
```

---

## 作者：lijiahao2017 (赞：8)

# P2637 【第一次，第二次，成交！】



### 题目描述

因为奶牛们的节食运动（奶牛还节食？）给农夫$JOHN$余下了一大批干草无法处理，所以他准备要开一个拍卖会去出售他的干草。
他有$N(1<=N<=1000)$批干草（每批大约$100$捆）。
他的客户有$M$个（$1<=M<=1000$），都是和他相邻的农夫。
第$I$名农夫会告诉农夫$JOHN$他会为农夫$JOHN$的每批干草付$P_i$的钱（$1<=P_i<=1,000,000$）。
每个农夫都想买（也只想买）农夫$JOHN$的一批草料。
为了确保农夫们不会互相嫉妒，所以农夫$JOHN$决定要以一个固定的价格出售他的草料。
每一个出价比农夫$JOHN$的要价要高的农夫将会买到草料，余下的将会被拒绝购买:< 请你帮助农夫$JOHN$找出能让他赚到最多的钱的最低的单批草料的售价。

### 输入输出格式

##### 输入格式：
* 第一行：两个被空格隔开的整数，$N$和$M$
* 第二行到第$M+1$行：第$I+1$行只包含一个整数：$P_i$

##### 输出格式：
第一行：由空格隔开的两个整数：农夫$JOHN$能出的每批草料的最低价格，以及他能赚到的最多的钱

### 输入输出样例

##### 输入样例#1：
$5$ $4$

$2$

$8$

$10$

$7$
##### 输出样例#1：
$7$ $21$
### 说明

##### 输入样例解释：

农夫$JOHN$有$5$批草料，$4$个农夫想要购买。
他们出价分别为：每批草料为$2$，$8$，$10$和$7$。

##### 输出样例解释：

农夫$JOHN$应该把价格设定为$7$，这样会有$3$个农夫会付钱买草料，农夫$JOHN$自己会挣到$21$的钱。



又可以和大家见面了，小菜鸡感到非常兴奋。

因为，最近成功发布了一片难度为　　　　　　提高+/省选-      的题解。

不过我这次要发的是难度为　　　　　　入门难度　　　　　　的题解，想帮一帮新手(突然忘了自己的身份)。

来回到正题，和明显这道题考查的是排序($sort$)。

## 开讲思路：

### 1.首先什么都不做，先来打个快排。

### 2.模拟每一个，比较并统计。

### 3.最后肯定是输出。

### 用代码说话：

```
#include<cstdio>//调用　　　　　　scanf和printf      的库
#include<algorithm>//调用　　　　　　sort      的库
using namespace std;
const int mx=1010;//定义常量mx
int n,m,s,ansa=0,ansb=0;
int a[mx];
//定义变量
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)scanf("%d",&a[i]);
	//美好的输入
    sort(a+1,a+m+1);//sort(快排)
	for(int i=m;i>0;i--)//从最高处开始模拟
	{
		if((m-i+1)*a[i]>ansb)ansa=a[i],ansb=(m-i+1)*a[i];//更新每批草料的最低价格，以及他能赚到的最多的钱
	}
	printf("%d %d",ansa,ansb);//完美的输出
	return 0;
}
```

---

## 作者：devenv2010 (赞：6)

emmm  
蒟蒻第一次发题解xp  
 _~~题目的数据比较小，所以敢用for直接强行AC~~_   
代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int p[100010];//每个农夫愿意付的钱
int n,m;
int ans[100010];//总钱数

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d",&p[i]);
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(p[j]>=p[i])		//当第p[i]个农夫出价时，
                ans[i]+=p[i];	//若第j个农夫出价比他大则计入总数
        }
    }
    int tot=0;
    int q=0;
    for(int i=1;i<=n;i++)
    {
        if(tot<=ans[i])
        {
            tot=ans[i];		//选择最大的一组解
            q=i;
        }
    }

    printf("%d ",p[q]);
    printf("%d",tot);
    return 0;
}
```

---

## 作者：King_Parliament (赞：5)

~~日常一道红题~~

这道题题面有点长，简单来说就是

给你一些可能出现的价格，让你选取一个价格，使商品利润最大。销量就是比你所选择的单价大的单价数量。

分析一下数据范围，发现数据很水，所以我们完全可以枚举每一个单价对应的利润，取最大值并记录一下单价是多少就可以了。

~~代码都在注释里~~

注释都在代码里：

```cpp
#include<bits/stdc++.h>
using namespace std;
int glass[10050],each,money;//glass记录所有可能的单价，each记录最优单价，money记录最大利润 
bool cmp(int a,int b){//CMP函数，给sort用来从大到小排序 
	return a>b;
}
int main(){
	int n,m;//n为干草数量，这里用不到。 m为提供的单价个数。 
	cin>>n>>m; 
	for(int i=0;i<m;i++)cin>>glass[i];//循环输入单价 
	sort(glass,glass+m,cmp);//使其有序 
	for(int i=0;i<n;i++){//枚举开始 
		if(money<=(i+1)*glass[i]){//用i+1表示数量，数量乘以单价就是利润，括号内表示当前利润大于已有利润 
			money=(i+1)*glass[i];//如果满足当前利润大于已有利润，则更新已有利润为当前利润 
			each=glass[i];//更新单价为当前单价 
		}
	}
	cout<<each<<" "<<money;//分别输出单价和利润 
	return 0;
}
```

**值得注意，这里n没有用到，可能是数据太水。按照常理，如果出现m>n的情况应该在>m的部分全部按照n去计数的，这里希望管理员可以加强数据，增加m>n的情况的数据点。**

---

## 作者：LaUwCaK (赞：5)

这到底是一道水题  
只要把每个农夫出的价钱排序，就保证了后面每个农夫出的价钱都比前面的大，都买得起前一个农夫出的价钱。所以我们只要把他后面的个数乘上当前农夫的价钱就行了（注意要比较个数超过n没有）。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,Max,ans;
int a[1005];
int main()
{
	cin>>n>>m;//输入 
	for(int i=1;i<=m;i++)
		cin>>a[i];//输入每一个农夫出的价钱 
	sort(a+1,a+m+1);//排序（方便后面的查找） 
	for(int i=1;i<=m;i++)//寻找最低价格 
	{
		if(a[i]*(m-i+1)>Max&&m-i+1<=n)//判断这个价钱是不是最低，并且利润最多（不要忘记判断有没有超过总批数） 
		{
			ans=a[i];//代入最低价格 
			Max=a[i]*(m-i+1);//求利润 
		}
	}
	cout<<ans<<" "<<Max;//输出最低价格和利润 
	return 0;//结束 
}
```
这就是我的代码了，如果有什么错误，请各位大佬在评论区留言。

---

## 作者：邓晓蓝 (赞：2)

//此题非常简单，算法是枚举每一个报价之后赚到的钱，找最大值就对了！！！！！！！是不是很简单啊！！！！附上C++程序：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int m,n,i,money,maxxx,maxx=0,a[10001];
int main()
{
    scanf("%d%d",&m,&n);
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+1+n);   //从小到大快排不解释嗯
    for (i=1;i<=n;i++)
      {
          money=a[i]*(n-i+1);    //枚举每一次出价能赚多少钱
          if (money>maxx) { maxx=money;maxxx=a[i]; //找最大值嗯哼
          }
      }
    printf("%d %d",maxxx,maxx);   //啦啦啦输出
    return 0;
}
```

---

## 作者：绝顶我为峰 (赞：1)

~~这种节食的奶牛和JOHN的干草，请给我来一打~~

首先John要获得最大利益，他不会~~傻~~到出不到任何一个农夫出价的价底线（例如农夫出价6元，John以5元卖出去就是~~傻~~）格买干草的，否则得不到最大收益（滑稽）

当然他也不能卖出比自己的干草还多的数量，~~否则chen_zhe大佬会和农夫一起揍他~~。

![](https://cdn.luogu.com.cn/upload/pic/21782.png)

~~完了我可能会被吊打致死~~

然后John就成了这样：![](https://cdn.luogu.com.cn/upload/pic/21512.png)

所以需要判断一下农夫多还是草多，以免出错。

根据前面说的，John只有出价和某一个农夫的出价相等时才有可能获得最大收益，所以只要排序后循环农夫的出价来判断就可以。

```
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,a[1001],ans,x;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
        cin>>a[i];
    sort(a+1,a+m+1);//排序
    for(int i=m>=n? n:m;i>=1;i--)//从大往小循环，以及判断保证John不被群殴
        if(ans<a[i]*(m-i+1))//如果比最大收益大
        {
            ans=a[i]*(m-i+1);//更新
            x=a[i];//保存出价
        }
    cout<<x<<" "<<ans<<endl;//输出
    return 0;//(～￣▽￣)～
}
```

---

## 作者：shangkevin (赞：1)

看到楼上发过一个类似于枚举的题解

然而t了

其实一开始我也是这么想的

只是做了点小优化

（也有原因是Pascal没有stl，话说2017初赛第一题。。。转语言虽然很痛苦，但是请尽早吧qwq）

上代码



```cpp
#include<iostream>
using namespace std;
#include<cstdio>
#include<algorithm>
#include<cmath>
int m,n;
int a[1001];//如题
int i,j,k,ans,vis;//ans赚的钱vis价格
int main()
{
    cin>>m>>n;
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);//因为看到前面有人t了就不敢用cin
    sort(a+1,a+n+1);//将需求方的价格排序
    if (m>=n)//如果粮草充足的话，那么直接枚举每一个需求方的价格（后面会有为什么枚举需求方价格的说明）
    {
        for(i=1;i<=n;i++)
        if (ans<(n-i+1)*a[i])
        ans=(n-i+1)*a[i],vis=a[i];//喜欢压行
    }
    if(m<n)//如果粮草不充足，那么如果选择的价格是小于a[m-n+1]的话，那么会导致有人买不到粮草，不合题意，所以可以直接从m-n+1循环
    {
        for(i=m-n+1;i<=n;i++)
        if (ans<(n-i+1)*a[i])
        ans=(n-i+1)*a[i],vis=a[i];
    }
    cout<<vis<<" "<<ans;
    return 0;
} 
```
好了开始讲为什么可以枚举这些需求方的价格
以样例为例

sort之后是2 7 8 10

如果定价为小于7的话

例如6

那么需求方个数没变单价减少了显然答案就小

如果增加的话

例如8

虽然价格高了但是必然会少至少一个需求方

乘积必然小（这好像是小学数学，如果不懂的话我就举周长是10的矩形的最大面积这种小学题提醒一下大家）

最后
江枫渔火对愁眠，祝你ac一万年！！！


---

## 作者：ModestCoder_ (赞：1)

这里介绍一种超级傻的方法

非常暴力，非常直接

那就是：树状数组

排序不需要，我们维护一个树状数组

表示对方开价比当前高的个数

那么我们从1到10^6枚举

sum=min(n,getsum(i))\*i

但是有一点注意：

每读入一个数，往比自己低的数加

统计时往高的去加

时间复杂度O(max(pi)\*logmax(pi)）








```cpp
uses math;
var
    c:array[0..10000000] of longint;
    n,m,i,x,sum,ans,k:longint;
function lowbit(x:longint):longint;
begin
    exit(x and -x);
end;
procedure add(x:longint);
begin
    while x>0 do
    begin
        inc(c[x]);
        dec(x,lowbit(x));
    end;
end;
function getsum(x:longint):longint;
begin
    getsum:=0;
    while x<=1000000 do
    begin
        inc(getsum,c[x]);
        inc(x,lowbit(x));
    end;
end;
begin
    readln(n,m);
    for i:=1 to m do
    begin
        readln(x);
        add(x);
        sum:=max(sum,x);
    end;
    for i:=sum downto 1 do
    begin
        x:=min(n,getsum(i))*i;
        if x>ans then
        begin
            ans:=x;
            k:=i;
        end;
    end;
    writeln(k,' ',ans);
end.

```

---

## 作者：_Int_ (赞：1)

公式**** P [ m ] \* ( M - m ) > MaxSum ****

就是 当前价格\*（总数量-当前位置）

话不多说，看代码

```cpp
#include < cstdio > // 标准库
#include < iostream > // cin & cout
#include < algorithm > // 万能的sort！
#include < con > // AC库，万能库~嘻嘻~
using namespace std ; // 别忘了
int N /* 见题意 */ , M /* 见题意 */ , P [ 1005 ] /* 见题意 */ , MinNumber /* 最小的标价 */ , MaxSum /* 最多的钱 */ ; // 变量准备好
int main ( ) { // 主程序华丽开始
    cin >> N >> M ; // 读入不解释
    for ( int m = 0 ; m < M ; m ++ ) { // 循环读入
        cin >> P [ m ] ; // 单价
    }
    sort ( P , P + M ) ; // 经典排序
    for ( int m = 0 ; m < M ; m ++ ) { // 循环
        if ( P [ m ] * ( M - m ) > MaxSum ) { // 条件判断
            MaxSum = P [ m ] *( M - m ) ; // 转移
            MinNumber = P [ m ] ; // 转移
        }
    }
    cout << MinNumber << ' ' << MaxSum ; // 输出
     return 0 ; // 拜拜
}

```

---

## 作者：Sunshine離 (赞：1)

```delphi

var n,m,i,money,nm:longint;  
    a:array[1..1000] of longint;  
    max:record  
        data,num:longint;//data用来储存最多的钱，num用来储存报价
        end;  
procedure qs(l,r:longint);//快排不解释  
var k,j,z,t:longint;  
begin  
   k:=l;j:=r;z:=a[(k+j)div 2];  
   repeat  
   while a[k]<z do inc(k);  
   while a[j]>z do dec(j);  
   if k<=j then begin  
   t:=a[j];a[j]:=a[k];a[k]:=t;  
   inc(k);dec(j);  
   end;  
   until k>j;  
   if k<r then qs(k,r);  
   if j>l then qs(l,j);  
end;  
  
begin  
 readln(n,m);  
 max.data:=-10;//首先把最大值随便赋值一个不可能的数
 for i:=1 to m do readln(a[i]);//读入数据
 qs(1,m);  
 for i:=m downto 1 do begin  //枚举所有数据，计算金额
        money:=(m+1-i)*a[i];
        if money>=max.data then begin 
              max.data:=money;
              max.num:=a[i];
                 end;//记下最大的总价和他的报价
        end;  
    writeln(max.num,' ',max.data);  
end.

```

---

## 作者：yangyuang (赞：0)

# P2637

来水一波PY题解

首先声明：
PY真的没有cin !

输入文件空行是几个意思！！！

那怎么对付这种~~毒瘤~~数据呢？

来介绍一种~~作弊~~函数

### try...except

用处：处理异常代码

示例：
```python
a = ''
a = int(a)
```

这样运行就会出现BUG

使用try后：

```python
a = ''
try:
	a = int(a)
except ValueError:  #错误类型
#若不填写所有错误都会进入except语句
	print("Error")
```

输出结果为：
Error

使用这个函数就不用担心毒瘤的数据了


上代码

------------

```python
a, y = map(int, input().split())
c = []
b = y * 1
while True:
    try:
        x = int(input())
    except EOFError: #如读入结束
        break
    except ValueError: 
        pass
    c.append(x)
c.sort()
d = 0
e = -1
f = 0
while y > d:
    if (y - d) * c[d] > e:
        e = (y - d) * c[d]
        f = c[d]
    d += 1
print(f, end = ' ')
print(e)
```


---

## 作者：yubing_lml (赞：0)

NO.14 应用快排的一道题（题目中的100捆就是个幌子，没啥用）

排序之后，当前农夫和他之后的农夫都能买到干草，这里我注意到两个问题：

（1）干草少于农夫数怎么办？（题目没有说一定能买到）
（2）一些农夫给的价格相同怎么办（这个问题其实不算个问题，就算循环不考虑这个也可，但是为避免重复计算，还是要尽可能跳过一些农夫）

对于问题1，每次循环前都找能购买干草的农夫数和
干草数的最小值，避免干草不够用，至于农夫之间的争夺战就不是我们考虑的内容了~

对于问题2，每次循环结束前，都把与当前单价相同的农夫跳过，下一个单价就是大于当前单价的最小单价啦~


直接上代码~
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int n, m, price, ans = 0;
int a[1001];

int main()
{
	cin >> n >> m;;
	for (int i = 1; i <= m; i++)
		cin >> a[i];
	sort(a + 1, a + 1 + m);
	for (int i = 1; i <= m; )
	{
		int people = n >= (m - i + 1) ? (m - i + 1) : n;
		int tmp = a[i] * people;
		if (ans < tmp)
		{
			ans = tmp;
			price = a[i];
		}
		int j = 0;
		for (j = 0; i + j <= m && a[i] == a[i + j]; j++);
		i += j;
	}
	cout << price << ' ' << ans;
	return 0;
}
```


---

## 作者：tmp27 (赞：0)

这道题~~很水~~。                     
它可以用暴力来做~~废话~~。                   
在暴力之前先得排个序(方便)。                    
排完序了就可以为所欲为的暴力了。            
我们知道，如果农夫$JOHN$价格是$a[i]$那么所得的钱是$a[i]*(m-i+1)$$                         
接着我们来看代码：                   
上代码！              
```
#include<iostream>//头文件。
#include<algorithm>//sort必须的头文件。
using namespace std;//空间命名。
struct node{
	int fp;//fp是最低的价格。
	int maxn;//maxn是最多的钱。
}ans;//用struct来存储。
int n,m,a[1002],s; //定义。
int main()
{
	cin>>n>>m;//读入
	for(int i=1;i<=m;i++)
		cin>>a[i];//读入
	sort(a+1,a+1+m);
	for(int i=1;i<=m;i++)
	{
		s=a[i]*(m-i+1);//所得的钱
		if(s>ans.maxn)// 打擂台
		{
			ans.maxn=s;
			ans.fp=a[i];//复制(ctrl+c)。
		}
	}
	cout<<ans.fp<<" "<<ans.maxn<<endl;//输出
	return 0;//完美结束
}
```

---

## 作者：rain_forest (赞：0)

[My Blog](https://deideidei.github.io)
-------
很显然，这道题JOHN能够卖出的最高价只可能是某位买家的出价，也就是P[i]。

而出价P[i]能够卖出的价格显然是``出价大于等于P[i]的农夫数量*P[i]``，那么我们就把P数组排序一下，然后能够卖出的价格就是``(m-i)*P[i]``。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,Max,ans,a[1001];
inline int max(const int &a,const int &b)
{
    return a>b?a:b;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(register int i=0;i<m;++i)
        scanf("%d",a+i);
    sort(a,a+m);
    for(register int i=0;i<m;++i)
        if(Max<a[i]*(m-i)){
            Max=a[i]*(m-i);
            ans=a[i];
        }
    printf("%d %d\n",ans,Max);
    return 0;
}

```


---

## 作者：Sinwind (赞：0)

------------

# 思路

1. 分析：
- 先将每个顾客的出价从大到小排列（这里选择的是**快速排序**，因为顾客数customer在[1, 1000]之间，数据较大）；
- 以{2, 8, 10, 7}为例，当price为出价，money为赚的钱：
	- 排序后变为{10, 8, 7, 2}；
    - 当price为10，有1个人买，money为10 × 1 =10；
    - 当price为8，有2个人买，money为8 × 2 = 16；
    - 当price为7，有3个人买，money为7 × 3 = 21；
    - 当price为2，有4个人买，money为2 × 4 = 8；
    - 归纳得price从数组中第一个元素(下标为0)开始，购买人数为数组第几个元素（下标 + 1），**money = price × 购买人数（下标 + 1）**。

2. 代码：
- 快速排序QuickSort函数：
	- 将数组a（最小的下标为left，最大的下标为right）从大到小排序；
    - 注意：**始终保证i < j，j要先于i寻找，且a[j] <= key和a[i] >= key，不加等号会错误**。
- main函数：
	- 读取干草批数hay，顾客个数，为每个顾客的出价price动态分配内存（<malloc.h>头文件），读取每个顾客的出价存入price数组；
    - 用快速排序，将price数组从大到小排序；
    - 遍历数组price：
    	- 若干草捆数小于购买人数，跳出循环；
        - 若购买金额（(i + 1) * price[i]）比之前的（most_money）大，此时价格为新的最小价格，购买金额为新的最大金额。
    - 输出最小价格和最大金额，并释放动态分配给price的内存。

------------

# 代码
```cpp
#include <cstdio>
#include <malloc.h>

//快速排序，从大到小
void QuickSort(int a[], int left, int right)
{
	int key = a[left];
	int i = left;
	int j = right;
	
	if(left >= right)
	{
		return;
	}
	
	while(i < j)
	{
		while(i < j && a[j] <= key)
		{
			j--;
		}
		while(i < j && a[i] >= key)
		{
			i++;
		}
		
		if(i < j)
		{
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	
	a[left] = a[i];
	a[i] = key;
	
	QuickSort(a, left, i - 1);
	QuickSort(a, i + 1, right);
}

int main(void)
{
	int hay;    		//干草批数
	int customer; 		//顾客个数
	int* price;		//每个顾客的出价
	int lowest_price;	//最低价格
	int most_money = 0;	//最多的钱
	
	scanf("%d %d", &hay, &customer);
	//动态分配内存
	price = (int*)malloc(sizeof(int) * customer);
	for(int i = 0; i < customer; i++)
	{
		scanf("%d", &price[i]);
	}
	
	//快速排序
	QuickSort(price, 0, customer - 1);
	
	//找到最低价格与最多的钱
	for(int i = 0; i < customer; i++)
	{
    		//购买人数太多，干草不足
    		if(i + 1 > hay)
       		{
       			break; 	
        	}
		if((i + 1) * price[i] > most_money)
		{
			lowest_price = price[i];
			most_money = (i + 1) * price[i];
		}
	}
	
	printf("%d %d\n", lowest_price, most_money);
	//释放动态分配的内存
	free(price);
	
	return 0;
}
```


---

## 作者：时间圣使·凡 (赞：0)

#### 随便系列。
## 这题比较简单。
## 我们读入后，给a数组从小到大排个序。
## 然后，从`a[1]-a[m]`开始for循环。
## 我们定义一个循环变量：`int sum=0`，用来记录获得的总价钱。
## 这个for循环中，还有一个`1-m`的for循环。用来枚举买家数，如果这个买家出的钱大于或等于枚举的钱数，那么，他后面的人也同样会买（因为排过序了）。
## 但是，还有个只有n批草料的限制，所以，要在可以买的买家数和n之间取小的那个，然后`sum=min(m-j+1,n)*i;break;` 这便是这个固定价位的能赚到的钱。
## 然后在这个`a[1]-a[m]`的for循环里和maxs比较，取大的，如果大，那么更新价位。
## 代码：
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[1010],maxs=-1,k=0;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>a[i];
	sort(a+1,a+1+m);
	for(int i=a[1];i<=a[m];i++)
	{
		int sum=0;
		for(int j=1;j<=m;j++) if(i<=a[j]) {sum=min(m-j+1,n)*i;break;}
		if(maxs<sum) k=i,maxs=max(maxs,sum);
	}
	cout<<k<<" "<<maxs;
	return 0;
}
```

---

## 作者：清风我已逝 (赞：0)

代码果然要写的简洁一点

曾经的代码我居然看不懂

问题是求一个最小单价获得的最大价值

显然，二者并存

且最小单价一定是相邻农夫出的钱里的一个

两层循环，进行一个交换，记录一个数量

就OK啦，水题水题

还可以直接排序维护一下啦 思路如上

奉上代码：
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[10000],n,m,x=-1,h=0,f;//f 最低价格 x 最多的钱 
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			if(a[j]>=a[i]){
				h++;//客户 
			}
			if(h*a[i]>x&&h<=n){
				x=h*a[i];
				f=a[i];
			}
		}
		h=0;
	}
	cout<<f<<" "<<x;
	return 0;
}

```

---

## 作者：狂龙卡萨 (赞：0)

思想：对农夫们的要价取最大值并从大到小排序，从最大价开始直到一做，每次先判定有没有要价超过这个定价且比定价+1低，把总数加入shu变量，之后继续判定总价大小

上代码




```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,can=1,shu=0;
int max1=-1;
int ans=-1,jia;
int a[1001];
bool cmp(const int &x,const int &b)
{
    return x>b; //排序
}
void work(int x)
{
    int y;
    while(a[can]>=x)
    {
        can++;//因为已经排序，所以可以放心一个个往后做
        shu++;//可以卖的农夫总数
    }
    if (shu<=m) y=shu*x;
    else y=m*x;
    if (y>ans)
    {
        jia=x;
        ans=y;
    }
}
int main()
{
    cin>>n>>m;
    for (int i=1;i<=m;i++) 
    {
        cin>>a[i];
        if (a[i]>max1) max1=a[i];
    }
    sort(a+1,a+1+m,cmp);
    for (int i=max1;i>=1;i--) work(i); //从大到小做
    cout<<jia<<" "<<ans;
    return 0;
}
```

---

## 作者：鹭天 (赞：0)

#独特的思想

不过这种方法只有80分(一个TLE），想要满分还得采取一些骗分的手段。

#那么我的思路是这样的:

##先把这些价钱的最大值给比较出来，再循环1到最大值，枚举每种可能，将之间的最大值找出来，在记录其价格。

那么代码如下:

```cpp
var
  i,j,max,n,m,k,s,min,max1:longint;
  a:array[0..1001] of longint;
begin
  readln(n,m);
 { if (n=1000)and(m=1000) then begin
    writeln('372383 744766');halt;
  end;}//骗分
  for i:=1 to m do begin
    readln(a[i]);
    if a[i]>max then max:=a[i];//比较最大值
  end;
  for i:=1 to max do begin//枚举每种情况
    k:=n;s:=0;
    for j:=1 to m do begin//将每个值和这个固定价格进行比较
      if k=0 then break;//如果干草没了，就退出循环
      if a[j]>=i then begin //如果找到了符合条件的价格
        s:=s+i;dec(k);//就加一次固定价格，干草数量减一
      end;
    end;
    if s>max1 then begin//如果这个价钱大，就记录下来
      max1:=s;min:=i;
    end;
  end;
  write(min,' ',max1);//输出
end.
虽说并不完美，但也是一种思路
```

---

## 作者：10092x (赞：0)

水水的模拟题，其实不需要排序，方法与楼下相同。

```cpp
program P2637;
var i,j,n,m,ans,sum,price:longint;p:array[1..1000]of longint;
begin
  readln(n,m);//读数
  for i:=1 to m do
    readln(p[i]);
  sum:=0;//总钱数置为0
  price:=0;//定价置为0
  for i:=1 to m do
    begin
      ans:=0;//计数器置为0
      for j:=1 to m do
        begin
          if ans=n//防止草不够卖
            then
              break;//跳出
          if p[j]>=p[i]//若价钱比此价钱高，则说明可以卖
            then
              inc(ans);//计数器加1
        end;
      if ans*p[i]>sum//判断是否大于当前最大总钱数
        then
          begin
            sum:=ans*p[i];
            price:=p[i];
          end;
    end;
  writeln(price,' ',sum);//输出
end. 
```

---

## 作者：深海鱼的眼泪 (赞：0)

其实是很简单的题目……把农夫的出价排序（其实不排也可以），然后用每一个农夫的出价枚举（为了利润最大，要价必与某农夫出价相等）。干草捆数并没有什么用。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
    int n,m,i,p[1010],smax=0,pr,j,t,s;
    cin>>n>>m;
    for (i=0;i<m;i++){
        cin>>p[i];
    }
    sort(p,p+m);
    for (i=0;i<m;i++){
        t=0;
        for (j=i;j<m;j++){    //因为已经排过序，所以后面的出价一定高于要价，直接相加就可以。
            t++;
        }
        s=t*p[i];
        if (s>smax){
            smax=s;
            pr=p[i];
        }
    }
    cout<<pr<<' '<<smax;
    return 0;
}
```

---

## 作者：AdzearDisjudge (赞：0)

这题用结构体做简直是水题。

方法：读入所有出价，从大到小排序。

之后，依次对每个出价乘能付得起出价的农夫个数（即最终的利润）。

然后，再对利润排个序，输出最大的就好了（不排序也可以，每次乘的时候比较一下结果与当前最大值即可）。

另外，如果干草捆数小于报价数，还要另作处理（筛掉总价值最低的出价），不过数据并没有涉及这部分，故我的程序里也没写这部分。读入干草捆数并没有什么用。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct hz
{
    int a,b;
}
a[1001];
int so(hz a,hz b)
{
    return a.a>b.a;
}
int os(hz a,hz b)
{
    return a.b>b.b;
}
int n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    cin>>a[i].a;
    sort(a+1,a+(n+1),so);
    for(int i=1;i<=n;++i)
    a[i].b=a[i].a*i;
    sort(a+1,a+(n+1),os);
    cout<<a[1].a<<' '<<a[1].b;
    return 0;
}
//%%% Shen Ben thx!!!
```

---

## 作者：「QQ红包」 (赞：0)

模拟……先排序（从小到大从大到小任意）

这样很容易求出买草料的人数，可以用i或者n-i+1来表示……

然后收入就可以直接乘了……

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
using namespace std;
int m,n,a[1010],i,j;
int main()
{
    scanf("%d%d",&m,&n);//读入 
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//读入 
    }
    int max=0,p=1;;
    sort(a+1,a+n+1);//从小到大排序 
    for (i=1;i<=n;i++)
    {
        int sum=a[i]*(n-i+1);//求和，i~n会买下草料，也就是n-i+1人
        if (sum>max) //如果超过目前最大收入 
        {
            max=sum;//最大收入
            p=a[i];//单价
        }
    }
    cout<<p<<" "<<max; //输出 
    return 0;
}
```cpp

---


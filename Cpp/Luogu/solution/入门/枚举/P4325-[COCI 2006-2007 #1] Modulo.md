# [COCI 2006/2007 #1] Modulo

## 题目描述

给定两个整数 A 和 B，A 模 B 是 A 除以 B 的余数。例如，数字 7、14、27 和 38 模 3 后分别为 1、2、0 和 2。编写一个程序，接受 10 个数字作为输入，并输出这些数字模 42 后的不同数字的个数。

## 说明/提示

在第一个例子中，数字模 42 后为 1、2、3、4、5、6、7、8、9 和 10。  
在第二个例子中，所有数字模 42 后为 0。  
在第三个例子中，数字模 42 后为 39、40、41、0、1、2、40、41、0 和 1。有 6 个不同的数字。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
1
2
3
4
5
6
7
8
9
10```

### 输出

```
10```

## 样例 #2

### 输入

```
42
84
252
420
840
126
42
84
420
126```

### 输出

```
1```

## 样例 #3

### 输入

```
39
40
41
42
43
44
82
83
84
85```

### 输出

```
6```

# 题解

## 作者：BEqueN (赞：80)

一边读入一边记录进桶，a[x%42]，把所有%42后的答案记录下来，

最后一遍循环统计：

i=0..41 a[i]==1 ans++  

意思就是枚举0~41（所有数%42都只会得出0~41），如果这十个数中有一个数%42等于枚举的数（因为一开始已经记录进a数组，所以直接判断a），计数器就加1.

```cpp
#include<cstdio>
using namespace std;
int ans,a[42],x;
int main()
{
	for (int i=1;i<=10;i++)//循环（十个数）十次
	{
		scanf("%d",&x);//输入
		a[x%42]=1;//记录进桶
	}
	for (int i=0;i<42;i++) 
    
    //枚举，记住0也要枚举，0或42的倍数%42都等于0
	 if (a[i]) ans++; //计数器+1
	printf("%d",ans);//愉快输出
    return 0;
}
```
----————求通过————----

---

## 作者：kradcigam (赞：52)


## 第$1$种方法 也是最暴力的一种

我们熟知，$c++$中的$set$可以既去重，有排序，这题，我们可以用set来搞，虽然我们不需要排序的功能，但毕竟方便，一共是$10$个数，所以暴力一点也没事

时间复杂度是$O(\log2{n})$

$code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
set<int>a;
int main(){
	for(int i=1;i<=10;i++){
		int x;
		cin>>x;
		a.insert(x%42);
	}cout<<a.size();
	return 0;
}

```
## 第$2$种方法 用$c++$中的函数实现

我们知道$c++$中有一个函数叫$unique$,时间复杂度是$O(\log2{n})$

所以亮$code$

$code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[15];
int main(){
	for(int i=1;i<=10;i++)cin>>a[i];
	sort(a+1,a+n+1);
	int ans=unique(a+1,a+10+1)-a;
	cout<<ans;
	return 0;
}

```
## 第$3$种方法 哈希
用$h$数组记录这个数有没有存过
```cpp
#include <bits/stdc++.h>
using namespace std;
int h[110],s;
int main(){
	for(int i=1;i<=10;i++){
		int x;
		cin>>x;
		if(++h[x%42]==1)s++;
	}
	cout<<s;
	return 0;
}

```
或者之后再扫一遍

```cpp
#include <bits/stdc++.h>
using namespace std;
int h[110],s;
int main(){
	for(int i=1;i<=10;i++){
		int x;
		cin>>x;
		h[x%42]++;
	}
	for(int i=0;i<41;i++)//余数是从0到41
		if(h[i])s++;
	cout<<s;
	return 0;
}

```

介绍了这$3$种方法，希望大家能点赞，欢迎评论！

---

## 作者：judgejudge (赞：45)

本题是一道水题，直接上代码，dalao赐教：
```cpp
#include <iostream>
using namespace std;
int a[1000],b[1000];
int main(){
	int i,j,k,n;
	k=0;
	for(i=1;i<=10;i++){
	    cin>>a[i];
	    b[a[i]%42]++;
    }
    for(i=0;i<42;i++)
    if(b[i]>0)k++;
    cout<<k;
}
```

---

## 作者：不会dp退役菜鸡 (赞：40)

身为C++的人，怎么能不知道STL呢？

(sort：排序，unique，去重)
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,a[10];
int main()
{
	for(int i=0;i<10;i++)
	{
		scanf("%d",&k);
		a[i]=k%42;
	}
	sort(a,a+10);//先排序才能
	int c=unique(a,a+10)-a;//去重后的长度为c
	printf("%d",c);
	return 0;
}
```

---

## 作者：童年如作业 (赞：26)

## 题目分析
对于这道题（中英结合，很有创意额），我们可以从题目中读出：给你十个数，让它们模42，看看有多少个不同的数。由此可知，他们的结果只有0~41，但有可能会重复，例如：1 43，这只计一个余数：1。再看模出的数，0~41并不超过数组范围（≈10^7），所以我们可以用一个简洁的方法：**数组计数**。
## 算法解析
数组计数就是拿一个数组，用数组的下标记录这个数有没出现过，如图所示：

数组   a                       
0    1   0    1   1   0    0 

下标                            
0    1   2    3   4   5    6 

出现的数   
1    3    4   3

将每个数对应的下标的地方标记为1

**重复标记的地方仍然为1！所以不会
           重复计数！**
## 程序
这种题没必要全部读入后再计算，可以边输入边计算，因为它的值不会变，在以后的预处理中**这很重要**！
```cpp
#include <bits/stdc++.h>
//包含所有头文件的头文件
using namespace std;
int pd[42];//用于计数的数组（大小视要记多少为准，这里是0~41）
int main()
{
	int a,ans=0;//ans记录多少个没重复的
	for(int i=1;i<=10;i++)
	{
		scanf("%d",&a);//读入十个数中的一个数
		a%=42;//模42，看它余数是多少
		if(pd[a]==0)//若这个余数没被标记（就是之前没出现过）ans+1，并将该余数标记
		{
			ans++;
			pd[a]=1;
		}
	}
	printf("%d",ans);//输出
	return 0;
}
```
在下不会在题解放图……
希望对大家有所帮助！！！

---

## 作者：king_storm (赞：16)

#  暴力枚举啊！！！
首先，题目叫输入10个数；那就循环10遍，应该都会吧；
### 进来一个数就处理一个数
先把它摸42，然后看book数组是不是1，如果是，那就直接跳过（就是continue）；如果不是，那就先加1，然后再把这个数book标记为1.因为每个数都对42取摸；所以这个数摸个42就不会大于41，这样数组就只需要开45就绰绰有余了（一般一维数组可以开到10000000不会爆）
#### 所以上代码；


------------

```cpp
#include<cstdio>
using namespace std;
int main()
{
	int n,liudan,book[45],cnt=0;
	for(int i=1;i<=10;i++)
	{
		scanf("%d",&n);
		liudan=n%42;
		if(book[liudan]==1) continue;
		else cnt++,book[liudan]=1;
	}
	printf("%d",cnt);
	return 0;
}
```
学习是个漫长的过程，祝大家学习进步！！

---

## 作者：Error_502 (赞：8)

入门题，由于一个数除42的余数只能是0~41，所以开一个数组a[42]储存0~41是否出现过即可。（具体看代码）
```cpp
#include <iostream>
using namespace std;
bool a[42];//a为标记0~41哪些余数出现过
int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0)//输出输入优化
	int t,sum=0;
	for(int i=0;i<10;i++)
		cin>>t,a[t%42]=true;//输入并标记这个数%42的结果为“出现过”
	for(int i=0;i<42;i++)
		if(a[i]) sum++;//若这个余数出现过，则个数累加1
	cout<<sum;
    return 0;
}
```

---

## 作者：damage (赞：6)

这道题其实本质上就是一个**去重操作**的题目，本道题的解法有很多可以一个一个**枚举**检测，或者使用**桶排序**等~~变态~~方法不胜枚举

其实有一个很容易的方法，初学者也可以简单掌握，就是运用~~人类历史上最伟大的发明，文明进步的垫脚石~~**STL**了。

其实可以实现去重操作的STL容器有不少，如**map**（**映射**）（本道题可以映射已经出现过的余数为true，然后没有出现就可以映射并将总量res++，最后res就是结果）,**set**等，但是针对去重的就要数**STL**中的**set**（**集合**）了

#### ~~向set致敬！~~

下面就是代码了，解说附在代码里

```cpp
#include<stdio.h>
#include<set>               //set头文件
using namespace std;
int n=10,a;               //n为输入是10个数字
set<int> res;             //本代码的重头戏[set]
int main()
{
	while(n--)          //循环输入
	{
		scanf("%d",&a);
		res.insert(a%42);       //将a%42插入res集合。insert(x)是set中的插入函数中最简单的一个插入函数，可以直接插入
	}
	printf("%d\n",res.size());    //因为set自带去重（其实会自动排序），所以只要直接输出它的元素个数就可以了。size()在set中是用来求一个集合中的元素个数的
	return 0;
}
```

**STL**将来一定会成为~~大国重器~~编程领域中最有用的容器了，里面有**vector**,**map**,**set**等非常有用的容器，非常适合初学者的学习和使用，便捷简单，代码可读性高，又整齐，希望看完这篇文章的你会去更加深入地学习**STL**吧！

---

## 作者：封禁用户 (赞：4)

**思路：依次读入10个数，将10个数%42的值分别存储。排序，统计，最后输出答案。**

先上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int a[11],b,ans=1,n=10;
	for(int i=1; i<=n; i++) {
		cin>>b;
		a[i]=b%42;//分别存储
	}
	sort(a+1,a+n+1);//排序
	for(int i=2;i<=10;i++){
		if(a[i]!=a[i-1]) ans++;//如果是新的答案，则ans+1
	}
	cout<<ans<<endl;
	return 0;
}
```

为什么这里$ans$的初始值为$1$？

因为统计时是从$a[2]$开始统计，无论如何$a[1]$肯定是一种答案。

## 别忘初始化！

这么水的题，能写这么长的题解不容易啊QWQ

---

## 作者：jeremyjy (赞：3)

**C++**的***STL***打遍天下无敌手！

下面有请我们的主角
```cpp
set
```

闪亮登场！！！

补充知识：

begin(),返回set容器的第一个元素

end(),返回set容器的最后一个元素

clear(),删除set容器中的所有的元素

empty(),判断set容器是否为空

max_size(),返回set容器可能包含的元素最大个数

size(),返回当前set容器中的元素个数

rbegin,返回的值和end()相同

rend(),返回的值和rbegin()相同

set的[更多](http://www.360doc.com/content/17/0526/22/10408243_657567440.shtml)知识

思路分析：

结果扔set，然后再去重！
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
set<int>s;//important，建立set
int main()
{
	int i,k;
	for(i=1;i<=10;i++)
	{
		cin>>k;//读入数据
		s.insert(k%42);//结果插入set
	}
	cout<<s.size();//输出jieg
	return 0;//perfect！
}
```
That's all!

---

## 作者：封禁用户 (赞：2)

# P4325 [COCI2006-2007#1] Modulo 题解

ps.各位大佬，请使用您的手指，为蒟蒻点个赞吧！
![](https://cdn.luogu.com.cn/upload/image_hosting/e6vh6124.png)

**1.题目 [P4325 [COCI2006-2007#1] Modulo ](https://www.luogu.com.cn/problem/P4325)**

**2.进入正题，见下：**

首先我们先分析一下这道题目怎么做：

（1）技巧：看标签：这次的标签是：
枚举,暴力
排序
概率论,统计 **说明直接暴力不会爆**

（2）分析题目：可以每一次输入一个数字，为了方便和节省复杂度，可以在输入的时候直接%42存入数组中，存入之后再使用sort（复杂度nlongn）进行从大到小排序

**注意：这个时候排序结束之后就直接相邻的数字就排列在一起，可参考一下内容**

### 附录：补充排序使用技巧

    输入测试数据：0 1 5 0 1 2 3 9 1 0
    
我们用以下我给的代码来测试：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[11];
    for(int i=1;i<=10;i++) cin>>a[i];
    sort(a+1,a+11);
    for(int i=1;i<=10;i++) cout<<a[i]<<' ';
}
```
    输出测试数据：0 0 0 1 1 1 2 3 5 9
    
所以就印证了之前的猜测，所以：

直接上代码：

```cpp
#include<bits/stdc++.h>//万头，csp可用
using namespace std;//using不多说
const int maxn=10001;//const固定了maxn大小：10001
int main()
{
    int n,a[maxn]={-999};//这里吧a[]赋值-999，因为正整数没有余数<0的
    for(int i=1;i<=10;i++)//根据题意输入10次
    {
        cin>>n;//输入
        a[i]=n%42;//直接%42放数组里
    }
    sort(a+1,a+11);//之前的结论，使用快排，复杂度O(NLOGN)
    int sum=0;//定义sum,注意=0
    for(int i=1;i<=10;i++) if(a[i-1]!=a[i]) sum++;//如果和之前不一样次数++，考虑边界：应为之前都赋值-999，所以就是所有余数都相等头回都会sum++，注意做题技巧
    cout<<sum;//输出
    return 0;//就这么华丽地结束了
}
```

这样是不是很容易理解鸭~~~

版权：zyy

[ThomasAirplane 的博客](https://zyy-txws-noip.blog.luogu.org/)

ps：你不可以雷同，本题采用反作弊系统

原创，侵权必究

---

## 作者：兀pai (赞：1)

一道水题，我觉得一看代码就懂qwq（莫名自信）

不多解释，先看代码：

```cpp
#include<iostream>
using namespace std;
int a,sum;
bool vis[1001];
int main(){
	for(int i=1;i<=10;i++){
		cin>>a;
		if(vis[a%42]==0){
			sum++;
			vis[a%42]++;
		}
	}
	cout<<sum;
	return 0;
}
```
a代表每个输入的数

sum代表最终的答案

每个输入的a%42后vis[a%42]+1，代表已经有过a%42这个数了

加一层判断，如果a%42没有出现过，就是a%42==0：

1）sum++，说明这是一个没有出现过的数

2）标记a%42以免以后再遇到

如果出现过了，就是vis[a%42]!=0，抛弃这个数

求关注+qq，求通过qwq

---

## 作者：LZXL (赞：1)

# 傻瓜都能明白的题解！！# 
此题**十分简单**，但看了一下大牛的题解发现基本都用（sort排序，unique去重）

而这道题是新手题，初学者一般都不会用，所以我发了一个繁琐但简单，容易理解的，请各位大牛不要喷~

基本概念是：**在输入时顺便求余结果直接录入，然后循环找重，如果重复做标记，赋值-1，最后，在对是-1的数排除，计数。**

虽然繁琐，但运用的知识比较基础，容易理解，适合初学者，**只要掌握数组**，一般就可以啦。

下面上代码：


```cpp
#include<iostream>              //头文件；
using namespace std;
int main()                      //主函数；
{
	int a[10],n=0;              //a[10]是十个数；n是余数个数；
    for (int i=1;i<=10;i++)     //次循环功能：读入+取余；
    {                           //循环开始；
    	cin>>a[i];              //读入变量；
    	a[i]=a[i]%42;           //将求余结果直接录入并替换原本的十个整数；
	}                           //循环结束；
	for (int i=1;i<=10;i++)     //此循环功能：取余数不同的个数；i表示第几个整数的余数；
	{
		for (int j=1;j<=10;j++) //此循环功能：找重；j表示与第几个整数的余数进行判重；
		{
			if(a[i]==a[j]  &&  i!=j)//判重；如果第i个数，与除自己以外的数都不相同，则把-1赋给它，因为一个数的余数不可能是负数，以后判定时避免和其他冲突； 
			{
			a[i]=-1;
		    }
		}
		if (a[i]!=-1)   //找没有重复过的；
		{
			n++;        //累加器+1；
		}
	}
	cout<<n<<endl;      //输出
}
```

但代码非常繁琐，所以我简化了一下，把两个循环并在了一起：

```cpp
#include<iostream>
using namespace std;
int main()
{
	int a[10],n=0;
    for (int i=1;i<=10;i++)
    {
    	cin>>a[i];
    	a[i]%=42;
		for (int j=1;j<=i;j++)  
		{
		    if(a[i]==a[j]  &&  i!=j)
			    {a[i]=-1;}
    	}
	}
	for (int i=1;i<=10;i++)
		if (a[i]!=-1)
		{n++;}
	cout<<n<<endl;
}
```


但我又发现则还是两个循环，在不会爆的情况下，我又并了三个循环：
```cpp
#include<iostream>
using namespace std;
int main()
{
	int a[10],n=0;
    for (int i=1;i<=10;i++)
    {
    	cin>>a[i];
    	a[i]%=42;
		for (int j=1;j<=i;j++)  
		    if(a[i]==a[j]  &&  i!=j)  {a[i]=-1;}
		if (a[i]!=-1){n++;}
	}
	cout<<n<<endl;
}
```


结束，大牛勿喷。

---

## 作者：血色心魔 (赞：1)

作为一位磊落汉子，他让我枚举0~41，我偏不枚举，我就是要用循环一个一个比，我就是【哔】的要把它们一个一个%42然后去重！
```cpp
#include<iostream>
using namespace std;
int main(){
    int a[10],b[10],count=10;//我就不用布尔型变量，初始答案值为10，如有不同就减
    for(int i=0;i<10;i++){
        cin>>a[i];
        a[i]%=42;
        b[i]=1;//做记号
    }
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            if(a[i]==a[j]&&b[j]&&j!=i){count--;b[j]=0;b[i]=0;}//比过就不比了
        }
    }
    cout<<count;
    return 0;
}
```
这种方法是我第一眼看到这道题的思路，然而一看题解区，清一色都是【哔】的关于%42结果为0~41的故事，往后翻才找到一个和我差不多的，我要把这种解法发扬光大啊啊啊啊

---

## 作者：electronlsr (赞：1)

我们为什么不用STL的map呢？
```
#include<bits/stdc++.h>
using namespace std;
map<int,bool> mp;
int main()
{
	int a,s=0;
	for(register int i=0;i<10;i--)
	{
		cin>>a;
		if(mp.count(a%42))
		continue;
		else
		{
			mp[a%42]=true;
			s++;
		}
	}
	cout<<s;
}
```
map是个好东西~~（手动滑稽）~~（~~为了避免抄袭我不会告诉你这个代码是无限循环伪代码的）~~

---

## 作者：sss7020 (赞：1)

就没有人用函数吗？c++党的人，有点惭愧啊！
```cpp
#include<iostream>
using namespace std;
int a[15];//
bool flag(int n,int i){
	while(--i){
		if(n==a[i]%42)return false;
        //用来判断是否重复。
        //是的话，返回错（并结束函数）
	}
	return true;
    //能运行到这就算烧高香了，返回对！
}
int main(){
	int cnt=0;
	for(int i=1;i<=10;i++){
		cin>>a[i];
		if(flag(a[i]%42,i))cnt++;
        //如果是对的，计数器加一
	}
	cout<<cnt<<endl;
	return 0;
}
```



~~新手，刚学函数，不用不开心。~~

---

## 作者：AlphaFish (赞：1)

## **一个要用两个for循环的笨方法**
不过易懂
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int a[11],ans=0;
bool b[11];//来判断有没有重复
int main()
{
	memset(b,true,sizeof(b));//假设一开始全部余数都没有重复
	for(int i=1;i<=10;i++)
    {
    	scanf("%d",&a[i]);
        a[i]%=42;
	}
	for(int i=1;i<=10;i++)
	{
		for(int j=i+1;j<=10;j++)
		{
			if(a[i]==a[j])
			b[j]=false;//如果重复，那么久false
		}
	}
	for(int i=1;i<=10;i++)
	if(b[i]==true)
	ans++;//算没有重复的余数
	printf("%d\n",ans);
	return 0;//完美GG
}
```

---

## 作者：_LHF_ (赞：1)

题外话：这一题八九成是一个学C++（或Java）的人出的题目，因为C++（或Java）里面的取余是"%"，而Pascal是用mod来取余。

好了，说说这一题吧——挺水的，照着题目说的做就行了，用**桶**的方式，每次读入一个数，然后%42，把结果存在“桶”数组里面。对了，好像没人发Java的题解代码，本宝宝先发一个吧。
```java
import java.util.*;//导入读入的包
public class Main {//主类导入
    public static void main(String args[])
    {
        int a,ans=0;//定义变量
        boolean[] t;//创建一组“桶”
        t=new boolean[42];//数组赋初值
        Scanner input=new Scanner(System.in);//创建读入变量
        for(int i=1;i<=10;i++)
        {
            a=input.nextInt();//读入一个数
            t[a%42]=true;//在编号为a%42中的“桶”里面标记为true
        }
        for(int i=0;i<42;i++)
        {
            if(t[i])ans++;//检查该编号的桶是否被标记为true
        }
        System.out.println(ans);//输出答案
    }
}
```

当然，还可以优化一下。
```java
import java.util.*;//导入读入的包
public class Main {//主类导入
    public static void main(String args[])
    {
        int a,ans=0;//定义变量
        boolean[] t;//创建一组为“桶”
        t=new boolean[42];//数组赋初值
        Scanner input=new Scanner(System.in);//创建读入变量
        for(int i=1;i<=10;i++)
        {
            a=input.nextInt();//读入一个数
            if(!t[a%42])//判断是否被标记过
            {
                t[a%42]=true;//如果没被标记过，就标记上，再吧答案+1
                ans++;
            }
        }
        System.out.println(ans);//输出答案
    }
}
```
还有C++版本的代码：
```cpp
#include<cstdio>//导入头文件 
using namespace std;
int a,ans;//定义全局变量 
bool p[42];//定义一个数组用来存标记 
int main()
{
	for(int i=1;i<=10;i++)
	{
		scanf("%d",&a);//读入一个数:a 
		if(!p[a%42]) {//如果a%42没被标记 
			p[a%42]=true;//标记上a%42
			ans++;//答案+1 
		}
	}
	printf("%d",ans);//输出答案 
	return 0; 
}
```


---

## 作者：FLASH_CM (赞：1)

### 【算法思路】
我们在每次读入一个数后，都将其模42，然后我们可以用一个bool型的数组来记录当前取模得到的值是否已经出现过，如果没有出现过，我们将答案加一，否则，继续读入下一个数并进行同样的处理。当所有的数都读入完成后，我们输出统计的模数的个数即可。
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

bool book[42];

int main(){
	int i,j,k,m,n,ans=0;
	for(i=1;i<=10;i=-~i){
		scanf("%d",&n);
		n%=42;
		if(!book[n]){
			book[n]=1;
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：lamboo (赞：1)

不得不说，STL太强了

隆重介绍一下set集合容器，头文件
```cpp
#include<set>
```
由于集合无法放入两个相同元素，所以可以自动完成去重工作

以下是完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
set <int> s;
int main()
{
	for (int i=1;i<=10;i++)
	{
		int x;
		cin>>x;
		s.insert(x%42);//往集合中放入元素
	}
	cout<<s.size();//.size表示集合内元素数量
	return 0;
}
```
set集合容器还支持其他很多操作，是一个非常有用的STL容器,大家可以学习一下

---

## 作者：Menhera (赞：1)

本接触c++只有一个月~~（四个周末）~~的蒟蒻。

看到此题一脸懵逼。一个算法都不会。嘤嘤嘤~

在期中考试前一天AC了本题。
```cpp
#include<iostream>
using namespace std;
int main(){
    int n[10];
    for(int i=0;i<10;i++){
        cin>>n[i];
    }//将输入的数存储到数组里。
    int mod[41];
    for(int i = 0;i < 42;i++){
        mod[i]=i;
    }//把一个数除以42可能会得到的值存储在数组里；
    int numbers[41];
    for(int i = 0;i<42;i++){
        numbers[i]=0;
    }//emm不知道怎么解释嘤嘤嘤。其实就是余数是1、2……的数的数量。
    for(int i = 0;i<10;i++){
        numbers[n[i]%42]+=1;
    }//把余数是1、2……的数的数量增加一。
    int k=0;
    for(int i = 0;i<42;i++){
        if(numbers[i]>0){
            k=k+1;
        }
    }//这个循环是检测有几种余数的，余数的个数存储在变量“k”中。
    cout<<k;//输出个数。
    return 0;
}

```




嘤嘤嘤……语文水平渣。勿喷……

---

## 作者：封禁用户 (赞：1)

这道题是真的简单，我们只需要输入10个数并把每一个数都取余42，然后判断有多少个不同的（其实可以直接判断等不等于0）就可以了。
```
#include<bits/stdc++.h>//万能头文件
using namespace std;//名字空间
int a[1000],n,s;//定义
int main()
{
	for(int i=0;i<10;i++)
	{
		cin>>n;//输入
		a[n%42]++;//用数组记数法来计数;
	}
	for(int i=0;i<42;i++)//因为一个数%42只有42种结果
	if(a[i]!=0)//判断有多少个不同的数（不等于0）；
	s++;
	cout<<s;//输出
	return 0;//拜拜程序
}
```
也可以这个亚子：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;//名字空间
int a[1000],n,s;//定义
int main()
{
	for(int i=0;i<10;i++)
	{
		cin>>n;//输入
		a[n%42]=1;//用数组记数法来计数;
	}
	for(int i=0;i<42;i++)//因为一个数%42只有42种结果
	if(a[i]==1)//判断有多少个不同的数（不等于0）；
	s++;
	cout<<s;//输出
	return 0;//拜拜程序
}
```

---

## 作者：SadLava (赞：0)

貌似还没有用STL set的题解...咱来发一波（代码在后面，set的在最后面...）
## 题目分析
“给出10个整数，问这些整数%42后有多少个不同的余数。 其中%代表取余运算”
我们先来看一组数据：
```cpp
39
40
41
42
43
44
82
83
84
85
```
这组数据的答案是6，让人百思不得其解，于是我们手动算出上述数据的值分别如下
```cpp
39%42=39
40%42=40
41%42=41
42%42=0
43%42=1
44%42=2
82%42=40
83%42=41
84%42=0
85%42=1
```
那么都有哪些数字出现过呢？

39、40、41、0、1、2

这些数字的数量不正好是6么？

啊，现在我们懂了，这个**程序的流程**就是：

1、**计算余数**

2、**判断有多少个不一样的余数（去重）**
## 程序实现
计算余数各位都知道（不知道的掉头去做[P1001 A+B Problem](https://www.luogu.org/problem/P1001)）
那么下面的问题就是去除重复数据了，这问题可就大了，咋办？

本人第一次碰到去重题目时那个发慌啊，在经过思想斗争后，想到的**方法如下**：

1、**根据数据范围开一个数组**，全部设成0；

2、如果发现某个值，我们就**把下标为这个值的元素设为1**（如值为v，数组为a，那么该操作为：a[v]=1）；

3、处理完全部数据后，遍历上述数组，如果**下标为i的元素内容为1则输出i**（数组为a，下标为i则：if(a[i]==1) cout<<i），至此程序完结。

按照这个思路我们能得到**AC代码1**，一些细节见代码注释。

但我们想想，这个**数组到底该开多大呢**？如果数据在几亿至个位数不等呢？针对这个问题，本蒟蒻多方研究，发现我们上述用的方法已经很接近于一种叫做[基数排序](https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin)（俗称“桶排序”）的排序方法，既然上述问题来自**桶排序的先天劣势**（某些情况下是巨大的优势，甚至能成为最省空间的排序法，篇幅过长，此处不再赘述），我们何不尝试换用别的排序方法呢？

之前给出的那组数据排序过后的结果是0、0、1、1、2、39、40、40、41、41，我们惊讶地发现：**重复的数据都是相连的！**于是我们就此得到了**AC代码2**，具体细节见代码注释。

“咱可是新手啊，怎么会比桶排更复杂的排序法呢？”

“写个程序都得打一遍排序，多烦啊！”

“办法总比困难多”，众所周知C++有各种各样~~花里胡哨~~的头文件，这不，咱就在一个叫**algorithm**的文件中发现了一个叫**sort**的玩意，皆大欢喜！

说道翻文件，我们还能翻到两个玩意儿：**set**和**bits/stdc++.h**，这里的**set**其实就是C++事先编写好的一种数据类型（类似**string**），简单来说就是一个**特殊的数组**，可以增加元素上限（大小理论上无限），并且第一个元素一定是最小的，最后一个元素一定是最大的，**并且内容不重复**，也就是说我往一个**set**里塞10^233个3**最后里面也只存着1个3**;

而**bits/stdc++.h**则是**gcc（g++）**编译器特有的头文件，其中**包含了标准c++的几乎所有头文件**，也就是说做一般的题只需要这一个头文件就行了，这样我们就有了**AC代码3**，具体细节见注释。
## AC代码
### AC代码1
```cpp
#include<iostream>

using namespace std;

//下面出场的是：答案、去重数组和用于输入的变量，掌声欢迎！
int ans,a[42],x;//这里a开到42是有讲究的，由余数定义可知，余数一定小于除数（42），但由于C++的神奇特性——数组最后一个元素就没正常过，于是我们只用到42个元素却得开到43个

int main()
{
    for (int i=1;i<=10;i++){
    	  //循环（十个数）十次，除非特殊需要，咱更推荐这种从1开始的循环，能避免很多不必要的麻烦
        cin>>x;//输入
        a[x%42]=1;//记录，x%42一定小于42，故不用担心越界
    }
    for (int i=0;i<42;i++){
    	//统计，由前面的数据可知，0也要算在内
    	if (a[i]) ans++; //计数器+1
    }
    cout<<ans;//输出结果
    return 0;
}
```
### AC代码2
```cpp
#include <algorithm>//sort来源于此
#include <iostream>

using namespace std;

int ans,a[11],x;//OI界“陋习”：变量一律全局，开到11，原因同上

int main(){
    for (int i=1;i<=10;i++){
        cin>>x;
        a[i]=x%42;//特别注意这里的a和之前的a有啥区别
    }
    /*这里是对sort的重点讲解
    sort共有3个参数，分别是要排序的区间起点、区间终点（终点不会取到）、和排序方法
    对于OI来说，更多是排序整个数组，所以起点终点选整个数组就好了
    至于排序方法，除非我们自己定义了结构或类，否则是可以缺省的，
    该参数传递的是一个函数指针*/
    sort(a+1,a+11);//咱从1开始，所以参数特殊一些
    //题目只要求去重后元素的数量，所以咱不需要真正去重，只需要统计
    x=a[1];//这里x用于储存前一个数据
    ans++;
    for(int i=2;i<=10;i++){
        if(a[i]!=x){//如果当前数据不等于前一个数据（不连续），说明这是不重复的元素
            x=a[i];//将当前值设为新的“上一个数据”
            ans++;//统计
        }
    }
    cout<<ans;//输出
}
```
### AC代码3
```cpp
#include <bits/stdc++.h>//万能头文件，爽

using namespace std;

int main(){
    set<int> s;//简单来说set就是一个有序的去重链表
    int t;
    for(int i=0;i<10;i++){
        cin>>t;
        s.insert(t%42);//set支持STL线性容器的大部分操作，如插入是insert，删除是erase
    }
    cout<<s.size();//由于set内容不重复，其元素的数量就是结果
    return 0;//养成好习惯
}
```


关于set的详细信息看[这](https://baike.baidu.com/item/STLset%E5%AE%B9%E5%99%A8/2061832?fr=aladdin)

### 希望这篇题解能给大家不一样的感受

---

## 作者：liusnoi (赞：0)

# 问题分析

- 声明一个余数数组并赋初值为默认值0，一个非负整数模42的余数是0~42，所以这个数组是flag[42]
- 余数第一次出现自增1，同时不同余数个数ans自增1
- 如果这个余数rem没有出现过，即flag[rem]==0,则进入if,flag[rem]自增1值变为1，ans自增1在原值基础上+1
- 如果这个余数rem出现过，即flag[rem]==1，则跳出if，继续输入下一个数

# 本题题解

```cpp
//P4325 [COCI2006-2007#1] Modulo
#include<iostream>
using namespace std;
int main()
{
	int num, ans=0;
	int flag[42]={};
	for(int i=0; i<10; i++)
	{
		cin>>num;
		if(flag[num%42]==0)
		{
			flag[num%42]++;
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


# 可能遇到的问题

- 我觉得数组的赋初值这里会有出错，C++一维数组的初始化规则遵循列表初始化规则，而且C++11初始化数组可以省略=。如：int larray[10]={};表示声明一个含10个元素的整型数组larray，所有元素的值都是0。
- 当然也可以将数组第一个元素赋值为0，编译器将会把其余元素赋值为0。即int larry[10]={0};。
- 也可以声明全局变量，不赋初值，C++自动给数组赋初值为0。
- 但在局部变量声明数组，且没有赋初值的话，数组元素的值会给你惊喜。
- 代码如下

```
//一维数组的初始化
#include<iostream>
using namespace std;
int parray[10];		//声明全局数组变量，默认所有元素初始值为0 
int main()
{
	int larray[10]={};		//声明局部数组变量，并赋初值为0，也可以写作 int larray[10] {};
	int tarray[10]={0};		//第一个元素赋值为0（或其他），其他默认为0。
	int narray[10];			//声明局部数组变量，并未赋初值。
	for(int i=0; i<10; i++)
		cout<<i<<"   "
			<<parray[i]<<"   "
			<<larray[i]<<"   "
			<<tarray[i]<<"   "
			<<narray[i]<<"   "<<endl;
	return 0;
}
```
- 运行结果前三个数组均是0，最后一个数组值随机。

# 原题翻译

## 题目描述
给定两个整数A和B，那么A模B的结果是A除以B的余数。例如，整数7、14、27和38模3的结果分别为1、2、0和2。
编写一个程序，输入10个整数，将它们模42，输出不同余数的个数。

## 输入输出格式
### 输入格式
输入包含10个非负整数，每个整数均小于1000且每行一个整数。
### 输出格式
在一行内输出模42后不同余数的个数。

---

## 作者：oistr (赞：0)

### 看看算法标签，蒟蒻我都懵了，这这这。。。真的需要这些算法吗？就是暴力啊。

没什么好说的，上代码（附有注释）
```cpp
#include <iostream>
using namespace std;
int mod[11];//记录模之后的数
int main()
{
	int x,pos=1;//pos：用于指示mod的下标
	for(int i=1;i<=10;i++)
	{
		cin>>x;//循环读入变量
		x%=42;//模
        //进行查重
		bool found=false;
		for(int j=1;j<pos;j++)//检查以前有木有出现过这个模数
		{
			if(x==mod[j])
			{
				found=true;
				break;//如果有，直接终止
			}
		}
		if(!found)
		{
			mod[pos]=x;//如果没有，就将该数放到mod的下一个空位中，pos的作用就在此处
			pos++;
		}
	}
	cout<<pos-1<<endl;//由于mod数组里记录的是所有不重复的数的个数，所以直接输出pos-1即可
	return 0;
}
```
### 本题很适合作为新人的练手题（大佬请直接跳过以下部分）
p.s. 我看到很多题解用到了排序（事实上根本用不到）还有查重函数，在此并不建议新手用，还是亲手写一下代码，这样能提高代码能力，并了解程序的运行过程。

---

## 作者：WatchmanIce (赞：0)

这道题目其实很简单，还是有两种方法。~~某管理：废话不要多说！~~


# 1 . 简单的hash开一下
```cpp
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
bool hash[45]={0};//开一个bool类型的数组，hash数组用来标注一下已经记录过的数字
```
### 注意了，如果你要想按下面这种打法，就只能创建一个bool类型的数组，因为只有bool类型的数组才有！flg这种功能!!!
```
int main(){
	ios::sync_with_stdio(false);//这个东西可有可无，快读啊
	cin.tie(0);
	int n=10;//这是数字的个数
	
	int ans=0;//创建变量答案
	for(int i=1;i<=n;i++){
		int p;//这是每次读入的数字
		cin>>p;
		
		int x=p%42;//这里要用一个数字记录一下除以42的余数（其实是本人懒，不想在下面在打了
		if(!hash[x]){//如果他没有被标住过
			ans++;//这说明这是一个新的余数，多了一个答案
			hash[x]=1;//先把他标注一下，以后不再计算
		}
	}
	cout<<ans<<endl;//输出
	return 0;
}
```

# 2 . 更简单的方法

这种方法比刚才那种方法更简单了，上代码！
```cpp
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
bool hash[45]={0};
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n=10;
	
	int ans=0;
	for(int i=1;i<=n;i++){
		int p;
		cin>>p;
		
		int x=p%42;
```
### 上面都是一样的，不在累述了

## 重要的是下面的东西了！！！

```
		hash[x]=1;//这里就是把不重复的放到hash数组里面去了，自动就把重复的归在一起了
	}
    
    for(int i=1;i<=n;i++){
    	ans+=hash[i];//这就是把每个数字加到ans上去了，输出啦哈哈哈
    }
	cout<<ans<<endl;//输出
	return 0;
}
```

# 3 . 简单的STL

其实到这里大家肯定就想到了set
```
#include<bits/stdc++.h>
#include<iostream>
#include<set>
using namespace std;
int main(){
//	ios::sync_with_stdio(false);
//	cin.tie(0);
	int n=10;
	
	set<int>s;//创建set类型的s
	for(int i=1;i<=n;i++){
		int p;
		cin>>p;
		
		int x=p%42;//求余
		if(s.count(x)==0)s.insert(x);//在不重复的情况下插入
	}
	cout<<s.size()<<endl;//这是s的长度
	return 0;
}
```

谢谢大家，我的代码完美落幕！

###### ~~希望审核通过~~

---

## 作者：丁俊哲djz (赞：0)

【算法思路】

我们在每次读入一个数后，都将其去除以42并储存在b数组，然后我们把数据排序一下，再去重。如果没有出现过，我们将答案加一，否则，继续读入下一个数并进行同样的处理。当所有的数都读入完成后，我们输出统计的模数的个数即可。

【代码】

```

var
  a,b:array[1..10] of longint;
  p:boolean;
  t,sum:longint;
  i,j:integer;
begin
  for i:=1 to 10 do 
  begin 
    readln(a[i]); 
    b[i]:=a[i] mod 42; 
  end;
  
  for i:=1 to 9 do
  for j:=i+1 to 10 do
    if b[i]>b[j] then
    begin
      t:=b[i];
      b[i]:=b[j];
      b[j]:=t; 
    end;
    
sum:=1;
for i:=2 to 10 do
begin 
p:=true;
for j:=1 to i-1 do
if b[i]=b[j] then p:=false;
if p then sum:=sum+1;
end;

writeln(sum);
end.

```

---

## 作者：chenwei (赞：0)

** _1：_ **简单至极。因为对小于42的数取余数，会得到那个数的本身。而大于42的数，得到的结果不超过10；

** _2：_ **可以肯定的是这里的结果 可能性不超过42个，所以可以弄个可以装下42个int的数组。

** _3：_ **现在开始录入数据！**++a[temp % 42];**这里直接索引当前录入的数据%42后的结果的位置。在这个位置+1，相当于对这个结果计数一次。

 _**4：**_ 入完数据之后，就开始统计每个结果出现次数了。因为数组中的某个元素值如果为0，那么说明这个结果没有出现过。所以我们统计大于0的结果。直接用一个变量统计。**++count；**这样直接就去重了。

```c
#include <iostream>
int main()
{
	using std::cin; using std::cout; usingstd::endl;
	//************************************************//
	int a[42]{};
	int temp = 0, count = 0;;
 	while (cin >> temp) {
		++a[temp % 42];
	}
	for (int i = 0; i != 42; ++i)
		if (a[i] > 0)
			++count;
	cout << count << endl;
	//************************************************//
	std::cin.get();
	return 0;
```

---

## 作者：mikeliu (赞：0)

这道水题如果用STL库里的std::set做，会很简单。


std::set具有去重的特性，且这个集合的大小就是去重后的元素数。

而本题目要求的便是去重后的元素数

```
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <set> 
//集合（set）类所在的头文件
using namespace std;
set<int> s;//定义一个集合s
int main()
{	
	int x;
	for(int i=0;i<10;i++)//读入10遍
	{
		
		cin>>x;//读入一个数
		s.insert(x%42);//在集合中插入一个数，x%42
	}
	cout<<s.size();//输出集合去重后的大小，即不重复元素的个数
	return 0;
}
//完。
```

---

## 作者：zhuyuyang (赞：0)

啦啦啦，一道大水题，排序，去重就好啦

p党福利```

```pascal
var
  a,b,c:array[1..20] of longint;
  i,j,x,y,z:longint;
begin
  for i:=1 to 10 do
  begin
    c[i]:=2000;
  end;//后面的去重需要
  for i:=1 to 10 do
  begin
    read(a[i]);
  end;//读下来
  for i:=1 to 10 do
  begin
    b[i]:=a[i] mod 42;
  end;//算余数
  for i:=1 to 10 do
  begin
    for j:=1 to 10 do
    begin
      if b[i]>b[j] then begin x:=b[i]; b[i]:=b[j]; b[j]:=x; end;
    end;
  end;//一个个都排好队
   for i:=1 to 10 do//重点，去重
  begin
    y:=0;
    for j:=1 to 10 do
    begin
      if (b[i]<>c[j]) then begin y:=y+1; end;
      if (y=10) then begin z:=z+1; c[z]:=b[i]; end;
    end;
  end;//ok
  writeln(z);//输出就好
end.
```
有点麻烦，请见谅（蒟蒻一只）

---

## 作者：DiTeXy (赞：0)

就是一个简单的去重啦。

数据范围极小，复杂度不重要。

# 于是一个set就可以AC啦~
```
#include<bits/stdc++.h>
using namespace std;
int a;
set<int> s;
int main()
{
	for(int i=0;i<10;i++)
	{
		scanf("%d",&a);
		s.insert(a%42);//插入set
	}
	printf("%d\n",s.size());//set自动去重后，set大小就是不同的余数的多少
	return 0;
}

```

---

## 作者：SuperJvRuo (赞：0)

查了一下才知道COCI是CROATIAN OPEN COMPETITION IN INFORMATICS克罗地亚信息学公开赛。

把结果丢到set里，如果这个结果没有出现过让ans++就行了。

入门难度吧：
```
#include<cstdio>
#include<set>

using namespace std;

int main()
{
    int ans=0,number;
    set<int> rest;
    for(int i=0;i<10;++i)
    {
        scanf("%d",&number);
        if(!rest.count(number%42))
        {
            ++ans;
            rest.insert(number%42);
        }
    }
    printf("%d",ans);
}
```

---


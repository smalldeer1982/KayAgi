# 小 D 与笔试

## 题目背景

小 D 是一位即将参加 ION 的 IO 选手，然而笔试题库中数量繁多的奇怪题目让他大伤脑筋，快来帮帮他！

## 题目描述

笔试题库可以抽象为 $n$ 道题目，每道题目由题面和答案组成，都是一个字符串，保证所有题目题面互不相同。

为了检验小 D 背笔试的效果，教练进行了一次模拟考试，考试包含 $q$ 道题目，每道题目都有 $4$ 个选项，小 D 需要从 $4$ 个选项中选出与答案相符的选项。

现在你需要帮助小 D 完成这场考试。

## 说明/提示

**【数据范围】**

令 $s$ 为输入中字符串长度的最大值。

对于 $30 \%$ 的数据，$n, q, s \le 10$。  
对于另 $20 \%$ 的数据，$s = 1$。  
对于 $100 \%$ 的数据，$n, q, s \le 100$，所有字符串都由小写拉丁字母组成。

## 样例 #1

### 输入

```
3 4
decoak yes
duliuchutiren nonono
csps noiptg
decoak yes no qwq qaq
csps noiptg noippj noi cspj
decoak qwq qaq yesyes yes
duliuchutiren yes no nono nonono```

### 输出

```
A
A
D
D
```

# 题解

## 作者：Eason_AC2 (赞：119)

看上去有点看不懂，但细细看题后可以发现这道题目是很水的。

---

在输入完题面及答案之后，就输入每个题的时候枚举一下题面是否匹配，然后再匹配答案就行了，因为看数据范围$n,q,s\leqslant 100$就肯定地知道枚举不会爆炸。

好像这是最不需要讲的一道题目~~（当然A+B除外）~~。

---

那么，直接上代码自己理解一下吧，有不懂的可以私信我哦。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;

const char dx[5] = {' ', 'A', 'B', 'C', 'D'};
struct pre {
	string ps, ans;
}p[107];
struct pro {
	string p, ans[5];
}s[107];
int n, q;

int main() {
	scanf("%d%d", &n, &q);
	for(int i = 1; i <= n; ++i)
		cin >> p[i].ps >> p[i].ans;
	for(int i = 1; i <= q; ++i) {
		cin >> s[i].p >> s[i].ans[1] >> s[i].ans[2] >> s[i].ans[3] >> s[i].ans[4];
		for(int j = 1; j <= n; ++j)
			if(s[i].p == p[j].ps)
				for(int k = 1; k <= 4; ++k)
					if(p[j].ans == s[i].ans[k])
						printf("%c\n", dx[k]);
	}
	return 0;
}
```

~~无耻地求个赞qwq。~~

---

## 作者：封禁用户 (赞：61)

# P5601 小D与笔试 题解

## ~~其实不用各位大佬的各种高级算法~~

ps.各位大佬，请使用您的手指，为蒟蒻点个赞吧！

1.题目 [P5601 小D与笔试](https://www.luogu.org/problem/P5601#submit)

2.进入正题，见下：

直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//freopen("T104062 小D与笔试.in","r",stdin);
	//freopen("T104062 小D与笔试.out","w",stdout);
	int n,q;
	string timu[1001],daan[1001];
	cin>>n>>q;
	for(int i=1;i<=n;i++)
		cin>>timu[i]>>daan[i];
	for(int i=1;i<=q;i++)
	{
		string t,a,b,c,d;
		int flag;
		cin>>t>>a>>b>>c>>d;
		for(int j=1;j<=n;j++)
		{
			if(t==timu[j]){
				flag=j;
				break;} 
		}
		if(daan[flag]==a) cout<<"A"<<endl;
		if(daan[flag]==b) cout<<"B"<<endl;
		if(daan[flag]==c) cout<<"C"<<endl;
		if(daan[flag]==d) cout<<"D"<<endl;
	}
	return 0;
}

```

这样是不是很容易理解鸭~~~

版权：zyy

[ThomasAirplane 的博客](https://zyy-txws-noip.blog.luogu.org/)

ps：你可以雷同


---

## 作者：冬天的雨 (赞：19)

# 蒟蒻的题解
##### 首先吐槽一下洛谷月赛和社区规则：           
本来我是165分的，结果第二题最后想了一个DP却爆了0...果然是我太菜了吗。。。               
去看社区规则发现IOI赛制取最高分就没再提交结果100分。。     
~~我还以为自己终于超越了智子小姐姐~~     
不过赛场秒切是真的，很感动~~终于有会的题目了~~   
## 进入正题          


#### 题目描述
[P5601小D与笔试](https://www.luogu.org/problem/P5601)

==================我是分割线=====================         
## 很容易看出这是一道巨水的模拟     
但是看看dalao们STL，Trie树玩到飞起，我就卑微地水一发纯模拟。。。代码送上，如果想抄注意去掉注释~
```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>//头文件，多打几个总是好的
using namespace std;
//--------------------------------------------------
struct Cheat{//卑微的蒟蒻只会用结构体
	char s[101],ans[101];//s用来存题面，ans用来存答案
};
struct node{
	char que[101],ca[101],cb[101],cc[101],cd[101];
        //que用来存模拟赛的题面，ca，cb，cc，cd存选项
};
Cheat a[101];//定义数组
node b[101];//再来一个
//----------------------分割线---------------------
int main(){
	long long n,q;//十年OI一场空，不开longlong见祖宗
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++){
		cin>>a[i].s>>a[i].ans;
	}
	for(int i=1;i<=q;i++){
		cin>>b[i].que>>b[i].ca>>b[i].cb>>b[i].cc>>b[i].cd;
	} 
        //最基本的输入，由于懒得写scanf了写了cin
        //不过稳妥起见CSP最好还是用scanf
	for(int i=1;i<=q;i++){
	    for(int j=1;j<=n;j++){
		if(strcmp(b[i].que,a[j].s)==0){
                    //strcmp是字符串比较函数，如果第一个大返回1，第二个大返回-1，一样大返回0
                    //以下部分为挨个搜索，发现相同选项输出，否则继续
			if(strcmp(b[i].ca,a[j].ans)==0){
			    printf("A\n");
			    break;
			}
			if(strcmp(b[i].cb,a[j].ans)==0){
			    printf("B\n");
			    break;
			}
			if(strcmp(b[i].cc,a[j].ans)==0){
			    printf("C\n");
			    break;
			}
			if(strcmp(b[i].cd,a[j].ans)==0){
			    printf("D\n");
                            break;
			}
		    }
	    }
	}
	return 0;//完结撒花
}
```
第一次写题解的蒟蒻，大佬勿喷，跪求管理过QAQ

---

## 作者：R·Buffoon (赞：11)

$C++$真是个好东西，$STL$真是个好东西，$map$真是个好东西 ~~（三连）~~

这道题只要用$map$保存每个题面的答案，然后对于每个出现的题面如果答案一样的话就输出选项
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
string s1,s2;//题面与答案
map<string,string> a;
char c[]={' ','A','B','C','D'};//预处理选项

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>s1>>s2;
		a[s1]=s2;//保存答案
	}
    
	for(int i=1;i<=m;++i)
	{
		cin>>s1;
		for(int j=1;j<=4;++j)
		{
			cin>>s2;
			if(s2==a[s1]) cout<<c[j]<<endl;//注意输出答案后不要break掉，因为要输入满4个
		}
	}
	
	return 0;
}
```
最后说一句：$map$真是处理字符的神器呀

$map$~~：我吊打字符~~

---

## 作者：梦里调音 (赞：8)

很水的一道暴力。

用hash貌似会快一些。

~~但像我这么懒~~

纯枚举就好了。

思路：
	
    输入题面和选项→枚举题面→枚举选项

```
#include "bits/stdc++.h"
using namespace std;
int n,q;
string qs[201],as[201];
int main(void){
	cin>>n>>q;
	for(int i=1;i<=n;i++)
		cin>>qs[i]>>as[i];
	for(int i=1;i<=q;i++){
		string qtion,a,b,c,d;
		cin>>qtion>>a>>b>>c>>d;
		for(int i=1;i<=n;i++)
			if(qtion==qs[i]){
				if(a==as[i]){
					cout<<"A\n";continue;
				}
				if(b==as[i]){
					cout<<"B\n";continue;
				}
				if(c==as[i]){
					cout<<"C\n";continue;
				}
				if(d==as[i]){
					cout<<"D\n";continue;
				}
				
			}
	}
	return 0;
}
```


---

## 作者：樱桃小丸子 (赞：6)

## 来水一波STL造福社会！

首先题目大意是比较简单的~~（毕竟是个红题）~~

### 简要大意：
 首先告诉你题目的名字和答案，再输入每个题目和A，B，C，D四个选项，根据前面所给题目的答案，选出A，B，C，D输出就好了。

首先要考虑前面给的题目名字和答案如何存，看一下数据范围
![KcOSl6.png](https://s2.ax1x.com/2019/10/28/KcOSl6.png)

是比较小的，所以暴力枚举题目判断是否一致是完全能过的，但还有更好用的东西，那就是STL的map（也叫关联数组）！

我们可以定义一个map<string ,string >v,把题目名字所代表的字符串和相应答案所对应的字符串一一对应，这样就可以在后面题目找答案的时候直接访问这个题目所对应的答案，输出选项就好了。

### 再附上简（ju）洁（chou）的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
map<string ,string >v;//关联数组v，记录题目和对应答案
const char a[4]={'A','B','C','D'};//答案选项所代表的字符
int main()
{
	int n,m;
	string s1,s2,s,c;
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>s1>>s2;
		v[s1]=s2;//把题面s1和s1的答案s2相关联
	}
	for(int i=0;i<m;i++){
		cin>>s;
		for(int j=0;j<4;j++)//判断四个选项
		{
			cin>>c;
			if(v[s]==c)//匹配到答案
  			cout<<a[j]<<endl;//输出选项所代表的字符
		}
	}
 } 
```


---

## 作者：xzy062609 (赞：4)

# 这是一道[水题](https://www.luogu.org/problem/P5601)，用字符串做
首先，第一行两个正整数$n$,$q$,表示笔试题库可以抽象为$n$道题目,考试包含$q$道题目。


然后，在接下来$n$行，每行$2$个用空格分隔的字符串，表示这道题目的题面和答案。

这只要输入就行了，我分别存在$s[n][1]$和$s[n][2]$


接下来q行，每行5个用空格分隔的字符串，第一个字符串表示模拟考试中这道题目的题面，其余4个字符串按顺序分别为这道题目的选项A到选项D，保证选项各不相同。

我们就要输入题面和选项

题目内容讲解完毕，正体开始：

用$for$循环从$1$到$q$,先寻找题面，再依依对应答案

# 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,q;
	string s[101][3],ti,a,b,c,d;
	cin>>n>>q;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i][1]>>s[i][2];
	}
	for(int i=1;i<=q;i++)
	{
		cin>>ti>>a>>b>>c>>d;
		for(int j=1;j<=n;j++)
		{
			if(ti==s[j][1])
			{
				if(a==s[j][2])cout<<'A'<<endl;
				if(b==s[j][2])cout<<'B'<<endl;
				if(c==s[j][2])cout<<'C'<<endl;
				if(d==s[j][2])cout<<'D'<<endl;
			}
		}
	}
} 
```
# 感谢您的阅读，谢谢！！

---

## 作者：phigy (赞：2)

这道题看起来很难但实际上只是一道简单的模拟


------------
一个题目对应一个答案，实际上就是一个映射的关系。
虽然可以用数组简单的模拟，但我们用map则能方便得多

于是就有了输入
```cpp
map<string,string>ans;
int n,q;
int main()
{
    int i,j,k;
    cin>>n>>q;
    for(i=1;i<=n;i++)
    {
        string x,y;
        cin>>x>>y;
        ans[x]=y;
    }
}
```
那么如何输出呢？

四个选项暴力判断就行了嘛

std:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>

using namespace std;

char ou[4]={'A','B','C','D'};//打表，方便输出
map<string,string>ans;//字符串映射字符串
int n,q;
int main()
{
    int i,j,k;
    cin>>n>>q;
    for(i=1;i<=n;i++)
    {
        string x,y;
        cin>>x>>y;
        ans[x]=y;//映射关系
    }
    for(i=1;i<=q;i++)
    {
        string x;
        cin>>x;
        string an=ans[x];//先存好答案
        for(j=1;j<=4;j++)
        {
            string y;
            cin>>y;
            if(an==y)
            {
                cout<<ou[j-1]<<endl;
            }
        }
    }
    return ^.^;//完美结束
}
```
交上去后你将会看到

![](https://cdn.luogu.com.cn/upload/image_hosting/26tynlwh.png?x-oss-process=image/resize,m_lfit,h_400,w_600)
# 感谢洛谷和所有管理员

---

## 作者：Hillwer (赞：1)

[【小D与笔试】](https://www.luogu.org/problem/P5601)

[戳我](https://www.luogu.org/space/show?uid=258095)

### --->进入正题
本题是一道基础的**字符串处理&死模**

看了一下题解，没有Pascal的，就写一篇来造福卑微$P$党

处理流程：
## 读入+处理+保存+查找+输出
>**读入+处理+保存**
用$pos$语句找空格，分出题目和答案

>**查找**

>先对输入的字符串进行处理，

>同样用$pos$找空格分离出当前的题目，然后在题库查找，

>接着一个$While$比对答案

>**输出**预先定义一个字符串$pp='ABCD'$,

>输出的时候就很方便，不需要$if$语句

## 上代码

```cpp
var i,j,n,m,p,k:longint;
s,t,pp:ansistring;
a,b:array[0..101] of ansistring;
begin
  pp:='ABCD';   //为了方便输出答案的处理，不用if语句了
  readln(n,m);
  for i:=1 to n do
  begin
    readln(s);
    k:=pos(' ',s);
    a[i]:=copy(s,1,k-1);    //保存题目
    b[i]:=copy(s,k+1,length(s));    //保存答案
  end;
  for i:=1 to m do
  begin
    readln(s);
    k:=pos(' ',s);
    t:=copy(s,1,k-1);    //当前的题目
    for j:=1 to n do
    if a[j]=t then break;     //查找原题（就像蒟蒻偷题解一样QAQ）
         //这里不用保存，直接break又简洁又方便
    delete(s,1,k);    //删除题目，保留ABCD四个选项
    s:=s+' ';   //字符串结尾加空格，方便while处理
    p:=0;   //初始化
    while s<>'' do
    begin
      k:=pos(' ',s);
      t:=copy(s,1,k-1);
      inc(p);
      if t=b[j] then writeln(pp[p]);   //找到答案就输出
      delete(s,1,k);
    end;
  end;
end.
```


---

## 作者：爱晚亭哦 (赞：1)

~~神仙们的map和字典树用不来啊~~

考虑模拟（考虑？）

字符串匹配，匹配完题目匹配答案

strcmp是匹配两个字符串是否相等，相等返回0

靠着这个函数，这题就变水题了

如果习惯循环从1开始，建议读入字符串时最好+1。

Code:
```
#include<cstdio>
#include<cstring>
char a[101][101],ans[101][101];
char p[101],pp[101][101];
char h[5]={'0','A','B','C','D'};
using namespace std;
int main()
{
	int n,m,qwq=0;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",a[i]+1);
		scanf("%s",ans[i]+1);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%s",p+1);
		for(int j=1;j<=n;j++)
		{
			if(strcmp(p+1,a[j]+1)==0)
			{
				for(int t=1;t<=4;t++)
					scanf("%s",pp[t]+1);
				for(int t=1;t<=4;t++)
				{
					if(strcmp(pp[t]+1,ans[j]+1)==0)
					{
						printf("%c\n",h[t]);
						qwq=1;
						break;
					}
				}
				if(qwq)
					break;
			}
		}
		qwq=0;
	}
}
```
~~好水的题~~

---

## 作者：YunJ (赞：1)

[更好的阅读体验](https://www.yuntianming.ac.cn/solution-luogup5601.html)
## 题目大意
前 $n$ 行为题库题目与标准答案。  
后 $q$ 行为考试题目与 $ABCD$ 四个选项，你需要从输入$4$个选项中找出正确答案的序号。保证有解且唯一。
## 100分做法
根据题目模拟即可。  
先读入 $n$ 道题目，并记下题目与标准答案。       
再读入 $q$ 道题目。读入每道题目时，你需要先从前面 $n$ 行给出的题目与标准答案中找到与询问的题目相同的题目。        
然后记下这道题目的答案，再依次读入 $4$ 个答案，并与记下的答案对比即可，输出选项 $ABCD$ 。       
$Code:$        
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	string pro,ans;                    //记下题库中的每道题目和答案。
}a[105];
int main()
{
	int i,n,m;
	cin>>n>>m;
	for(i=1;i<=n;i++)                  //读入题库中的每道题目和答案。
	{
		cin>>a[i].pro;
		cin>>a[i].ans;
	}
	for(i=1;i<=m;i++)
	{
		string prob,anspro;
		cin>>prob;                     //读入考试中的每道题目。
		for(int j=1;j<=n;j++)
		{
			if(a[j].pro==prob)
			{
				anspro=a[j].ans;       //记下这道题目的标准答案。
			}
		}
		for(int j=1;j<=4;j++)          //处理4个选项。
		{
			string f;
			cin>>f;
			if(f==anspro)
			{
				char p='A'+j-1;
				cout<<p<<endl;         //输出正确答案。
			}
		}
	}
}
```

---

## 作者：nofall (赞：1)

模拟

开个$map$存储每道题的答案，对于每个询问，直接在$map$里查询就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q;
map<string, string> M;
int main() {
	cin >> n >> q;
	for(register int i = 1; i <= n; ++i) {
		string s1, s2;
		cin >> s1 >> s2;
		M[s1] = s2;
	}
	for(register int i = 1; i <= q; ++i) {
		string s1, s2, s3, s4, s5;
		cin >> s1 >> s2 >> s3 >> s4 >> s5;
		if(M[s1] == s2) puts("A");
		if(M[s1] == s3) puts("B");
		if(M[s1] == s4) puts("C");
		if(M[s1] == s5) puts("D");
	}
	return 0;
}
```

---

## 作者：VenusM1nT (赞：1)

模拟。  
用 map 判断即可通过此题。
```cpp
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
#include<bits/stdc++.h>
#define MAXN
#define reg register
#define inl inline
using namespace std;
map <string,string> m;
int n,q;
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>q;
	for(reg int i=1;i<=n;++i)
	{
		reg string x,y;
		cin>>x>>y;
		m[x]=y;
	}
	for(reg int i=1;i<=q;++i)
	{
		reg string x,a,b,c,d;
		cin>>x>>a>>b>>c>>d;
		if(m[x]==a) puts("A");
		else if(m[x]==b) puts("B");
		else if(m[x]==c) puts("C");
		else if(m[x]==d) puts("D");
	}
	return 0;
}
```

---

## 作者：jiangXxin (赞：1)

比较简单的题目，使用map标记一下每个问题的答案，然后输入题目的时候比较问题的答案，输出A,B,C,D就可以了.

**code:**
```python
s=input().split()
n=int(s[0])
q=int(s[1])
map={}
for i in range(n):
    s=input().split()
    a=s[0]
    b=s[1]
    map[a]=b

for i in range(q):
    s=input().split()
    question=s[0]
    A=s[1]
    B=s[2]
    C=s[3]
    D=s[4]
    if(map[question]==A):
        print("A")
    if(map[question]==B):
        print("B")
    if(map[question]==C):
        print("C")
    if(map[question]==D):
        print("D")

```


------------

```cpp
/**
*    author:  a2954898606
*    created: 2019/10/27 13:50:23
**/
#include<bits/stdc++.h>
#define REP(A,B,I) for(int I=(A);I<=(B);I++)
#define PER(A,B,I) for(int I=(A);I>=(B);I--)
#define max(X,Y) ((X)<(Y)?(Y):(X))
#define min(Y,X) ((X)<(Y)?(X):(Y))
#define read(FILENAME) freopen((FILENAME + ".txt"), "r", stdin);
#define write(FILENAME) freopen((FILENAME + ".txt"), "w", stdout);
#define LL long long
using namespace std;
int n,q;
string s;
map <string,string> mp;
int main(){
    //read(1)
    //write(1)
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n>>q;
    REP(1,n,i){
        string a,b;
        cin>>a>>b;
        mp[a]=b;
    }
    REP(1,q,i){
        string a,b,c,d;
        cin>>s>>a>>b>>c>>d;
        if(mp[s]==a){
            cout<<"A"<<endl;
        }
        if(mp[s]==b){
            cout<<"B"<<endl;
        }
        if(mp[s]==c){
            cout<<"C"<<endl;
        }
        if(mp[s]==d){
            cout<<"D"<<endl;
        }
    }
    return 0;
}

```


---

## 作者：阿拉丁神坑 (赞：0)


## 分析

模拟，挺水的，人人可做。

## 方法

纯模拟，边读边输大法好。

## 代码

```cpp
#include<bits/stdc++.h>
int n,q;
struct an{
	std::string at;//题面
	std::string aa;//答案
}tm[105];//背的题面和答案。
struct zz{
	std::string t;//题面
	std::string a[5];//选项
}da[105];
char anssc[5]={'1','A','B','C','D'};//直接输出，免得乱搞。
int main()
{
	//freopen("in.txt","r",stdin);//测试专用
	//freopen("out.txt","w",stdout);
	std::cin>>n>>q;//读入
	for(int i=1;i<=n;i++)
	{
		std::cin>>tm[i].at>>tm[i].aa;
	}
	for(int i=1;i<=q;i++)
	{
		std::cin>>da[i].t;
		int cache=0;//临时存储数据
		for(int j=1;j<=n;j++)
		{
			if(da[i].t==tm[j].at)//找相同的题面
				cache=j;
		}
		for(int j=1;j<=4;j++)
		{
			std::cin>>da[i].a[j];
			if(da[i].a[j]==tm[cache].aa)//找答案
			{
				std::cout<<anssc[j]<<"\n";//记得回车
			}
		}
	}
	return 0;
 } 
```



---

## 作者：_lhz_ (赞：0)

给一个STL的题解，代码短效率还高。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//freopen("1.in","r",stdin);
    int n,q;
    cin>>n>>q;
    map<string,string>lhz;
    while(n--){
        string a,b;
        cin>>a>>b;
        lhz[a]=b;
    }
    while(q--){
        string p,ans,a,b,c,d;
        cin>>p>>a>>b>>c>>d;
        ans=lhz[p];
        if(ans==a)puts("A");
        else if(ans==b)puts("B");
        else if(ans==c)puts("C");
        else puts("D");
    }
    return 0;
}
```


---

## 作者：Ikari_Shinji (赞：0)

## 第一眼，想到最近讲的Trie树 ~~（然后去翻笔记）~~

### 第二眼，莫不是枚举？ ~~（懒得写）~~

### 蓦然回首，map在向我招手

#### （map是个好东西 ~~，作用堪比金坷垃~~）


不扯了，上代码：
```cpp
#include <cstdio>
#include <map>
#include <iostream>

using namespace std;
map<string,string>a;//map是个好东西
int n, q;

int main ( ) {
	scanf ("%d%d", &n, &q);
	for (int i = 1; i <= n; i++) {//读入
		string que, ans;
		cin >> que >> ans;
		a[que] = ans;//存储答案
	}
	for (int i = 1; i <= q; i++) {
		string que, ans1, ans2, ans3, ans4;
		cin >> que >> ans1 >> ans2 >> ans3 >> ans4;
		if (a[que] == ans1) printf ("A\n");//进行比较
		else if (a[que] == ans2) printf ("B\n");
		else if (a[que] == ans3) printf ("C\n");
		else if (a[que] == ans4) printf ("D\n");
	}
	return 0;//结束
}
```

---

## 作者：Magallan_forever (赞：0)

我们可以考虑对于每一个题main，记录一个答案，关于如何记录答案，使用map

如果还不懂就看代码吧

code:
```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<map>
#include<iostream>
using namespace std;
string s,s2;
map<string,string> a;
char ans[101];
int main(){
	int n,q;
	char temp;//辅助记录答案
	scanf("%d%d",&n,&q);
	for(int i=0;i<n;++i) cin>>s>>s2,a[s]=s2;
	for(int i=0;i<q;++i){
		cin>>s,temp='A';//顺序为A,B,C,D，不对就++temp
		for(int j=0;j<4;++j){
			cin>>s2;
			if(a[s]==s2) ans[i]=temp;//也可以直接输出
			else ++temp;
		}
	}
	for(int i=0;i<q;++i) printf("%c\n",ans[i]);
	return 0;
}
```
[评测记录](https://www.luogu.org/record/25861325)

---

## 作者：A_Đark_Horcrux (赞：0)

~~本次月赛唯一AC的一题QAQ~~

我们一看数据范围！

> n,q,s≤100

考虑枚举。

1.记录每一道题目和答案；

2.输入问题， __枚举__ 找出题面相同的被记录的题目；

3.输入4个选项， __枚举__ 找出与记录中答案相同的选项输出。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
struct question {char name[110],ans[110];}a[110];//题目
int n,m,i,j,k; char c[110],d[110][110];
int main()
{
	scanf("%d %d",&n,&m);//输入n和m
	for(i=1;i<=n;i++) cin>>a[i].name>>a[i].ans;//输入每一道题目的题面和答案
	for(i=1;i<=m;i++)
	{
		cin>>c;//输入问题题面
		for(j=1;j<=n;j++) if(!strcmp(a[j].name,c)) break;//找到记录中的对应题目
		for(k=0;k<=3;k++)
		{
			cin>>d[k];//输入选项
			if(!strcmp(d[k],a[j].ans)) printf("%c\n",k+'A');//如果符合答案就输出。
		}
	}
	return 0;
}//结束awa
```


---

## 作者：ShineEternal (赞：0)



[好东西](https://blog.csdn.net/kkkksc03/article/details/102778927)

https://www.luogu.org/problem/P5601

## solution:

这道题用string应该是比较好的（可以直接比较）

然后就是输入的四个选项可以一一判断，如果不想那么麻烦的就存在数组里就好了

## code:

```cpp
#include<cstdio>
#include<iostream>
#include<string>
using namespace std;
string t[105],ans[105],tm,a[5];
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
	{
		cin>>t[i]>>ans[i];
	}
	for(int i=1;i<=q;i++)
	{
		cin>>tm>>a[1]>>a[2]>>a[3]>>a[4];
		for(int j=1;j<=n;j++)
		{
			if(t[j]==tm)
			{
				for(int k=1;k<=4;k++)
				{
					if(a[k]==ans[j])
					{
						printf("%c\n",k+'A'-1);
					}
				}
			}
		} 
	}
}
```

---

## 作者：Pengsibo (赞：0)

洛谷2019十月月赛三Div.2的第一题

[题目传送门](https://www.luogu.org/problem/P5601?contestId=22461)

看完这道题就知道是一个~~比较水的模拟~~

又因为对于每道题，又有名字又有答案，所以我们可以用结构体

```
struct node
{
	string name;
	string ans;
} test[102];

```
为了省去逐位比较的麻烦，我们用string（可以直接比较）

```
int n,q;
string x[102],a[102],b[102],c[102],d[102];
int cnt;
```
x，a，b，c，d 分别对应考试题的名字和4个选项

读入：

```
	scanf("%d%d",&n,&q);
	
	for(register int i=1;i<=n;i++)
	{
		cin>>test[i].name;
		cin>>test[i].ans;
	}
```
然后我们来一波处理：

```
	for(register int i=1;i<=q;i++)
	{
		cin>>x[i];	//读入题目
		cin>>a[i]>>b[i]>>c[i]>>d[i];
	}
```
寻找我们想要的题目的编号：

```
	for(register int j=1;j<=n;j++)
	{
		if(test[j].name==x[i]) {cnt=j;break;}
	}	//string可直接比较
```
判断是哪一个选项：

```
	if(a[i]==test[cnt].ans) puts("A");
	else if(b[i]==test[cnt].ans) puts("B");
	else if(c[i]==test[cnt].ans) puts("C");
	else puts("D");
```
然后就做完啦！

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;

int n,q;
string x[102],a[102],b[102],c[102],d[102];
int cnt;

struct node
{
	string name;
	string ans;
} test[102];

int main()
{
	scanf("%d%d",&n,&q);
	
	for(register int i=1;i<=n;i++)
	{
		cin>>test[i].name;
		cin>>test[i].ans;
	}
	
	for(register int i=1;i<=q;i++)
	{
		cin>>x[i];
		cin>>a[i]>>b[i]>>c[i]>>d[i];
		for(register int j=1;j<=n;j++)
		{
			if(test[j].name==x[i]) {cnt=j;break;}
		}
		if(a[i]==test[cnt].ans) puts("A");
		else if(b[i]==test[cnt].ans) puts("B");
		else if(c[i]==test[cnt].ans) puts("C");
		else puts("D");
	}
	
	return O;
}
```
#### 写题解不易，望兹磁！

---

## 作者：皇家海盗 (赞：0)

map是个好东西。

通过map将问题与答案匹配。

不懂的可以对map了解一下。真的好用。

上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register int
int n,q;
map<string,string>awsl;
string tql,qaq,tbr,qwq1,qwq2,qwq3,qwq4;
signed main()
{
	cin>>n>>q;
	for(rg i=1;i<=n;++i)
		cin>>tql>>qaq,awsl[tql]=qaq;
	for(rg i=1;i<=q;++i)
	{
		cin>>tbr>>qwq1>>qwq2>>qwq3>>qwq4;
		if(awsl[tbr]==qwq1) puts("A");
		if(awsl[tbr]==qwq2) puts("B");
		if(awsl[tbr]==qwq3) puts("C");
		if(awsl[tbr]==qwq4) puts("D");
	}
}

---

## 作者：撤云 (赞：0)

[戳我](https://www.cnblogs.com/hbxblog/p/11750254.html)

### $Solution$

这道题官方题解的做法太复杂了，还需要扫字符串。

其实只需要两个$map$就好了.

一个$map<string,stirng>$用来记录题目一个题面的答案是什么
一个$map<string,char>$用来记录答案是$"A","B","C","D"$中的哪个

然后直接输出就好了，详细见代码

``` cpp
#include<bits/stdc++.h>
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
map<string,char> s;
map<string,string> ss;
string c,cc;
int main(){
	int n=read(),q=read();
	for(int i=1;i<=n;i++)
		cin>>c>>cc,ss[c]=cc;
	while(q--){
		cin>>c;
		for(int i=0;i<4;i++)
			cin>>cc,s[cc]=i+'A';
		cout<<s[ss[c]]<<endl;
		s.clear();
	}
}
```

---

## 作者：Crab_Dave (赞：0)

这道题很简单啦，就是考察对字符串的使用~

本题需要内置的知识：

1. 简洁方便的cin输入字符串

	优点：不会读入空串，也不会读入空格和换行符
    
   缺点：不能处理用其他字符分割的字符串，而且有点慢qwq...
   
2. 一目了然的strcmp函数比较字符串A与B的大小：
	
  	A比B小，返回-1;
   
   A比B大，返回1;
   
   A=B，返回0.
   
   PS：这里的大小以长度为第一关键字，字典序为第二关键字
   
3. ~~没了~~

好吧代码如下：
```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

int n,q;
struct knlg//knowledge结构体，存储小D学到的知识
{
	char qst[105],ans[105];
}a[105];
char qus[105],A[105],B[105],C[105],D[105];//每一个问题和选项

int main()
{
	cin>>n>>q;
	for(register int i=1;i<=n;i++)
	{
		cin>>a[i].qst>>a[i].ans;//读入
	}
	while(q--)//询问
	{
		cin>>qus>>A>>B>>C>>D;//读入
		for(register int i=1;i<=n;i++)
		{
			if(strcmp(qus,a[i].qst)==0)
         //对于每一个问题，查询小D所有的知识
         //是不是很像您考试的时候（
			{
				if(strcmp(A,a[i].ans)==0)printf("A\n");
           	//三长一短选最短（
				else if(strcmp(B,a[i].ans)==0)printf("B\n");
           	//三短一长选最长（
				else if(strcmp(C,a[i].ans)==0)printf("C\n");
           	//两长两短就选C （
				else if(strcmp(D,a[i].ans)==0)printf("D\n");
           	//啥都不会就蒙D （
			}
		}
	}
	return 0;//结束了罪恶的一生
}
```
$\color{white} \text{\tiny{~~所以我又水了一篇题解哈哈哈~~}}$

---


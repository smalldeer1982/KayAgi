# [COCI 2011/2012 #6] JACK

## 题目描述

给定 $n$ 个正整数 $a_1 \dots a_n$，请从中选择 $3$ 个数字，满足他们的和不大于给定的整数 $m$，请求出这个和最大可能是多少。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$6 \leq m \leq 3 \times 10^5$，$1 \leq a_i \leq 10^5$，数据保证有解。

#### 说明

**题目译自 [COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #6](https://hsin.hr/coci/archive/2011_2012/contest6_tasks.pdf) *T1 JACK***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。

## 样例 #1

### 输入

```
5 21
5 6 7 8 9```

### 输出

```
21```

## 样例 #2

### 输入

```
10 500
93 181 245 214 315 36 185 138 216 295
```

### 输出

```
497```

# 题解

## 作者：wuyonghuming (赞：15)

## 思路:
这道题目直接用暴力循环就可以解决了。可以排序优化，假设位置是$i$，这些数是$a$,如果:

$a_i+a_{i+1}+a_{i+2}>m$

就说明这个方案以后的方案都不可行，已经排过序了，后面的只会更大。
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
int n,m,a[1005],ans=0;//先把答案置零
int main()
{
	cin>>n>>m;//输入
	for(int i=1;i<=n;i++)//循环输入
	{
		cin>>a[i];//输入a
	}
	sort(a+1,a+n+1);//排序
	for(int i=1;i<=n;i++)//循环
	{
		if(a[i]+a[i+1]+a[i+2]>m)//如果当前加上下一个和下一个的下一个大于m的话
		{
			break;//就结束循环
		} 
		for(int j=i+1;j<=n;j++)//循环
		{
			if(a[i]+a[j]+a[j+1]>m)//如果最小的情况大于m
			{
				break;//就结束循环
			}
			for(int k=j+1;k<=n;k++)//循环
			{
				if(a[i]+a[j]+a[k]>m)//如果当前大于m
				{
					break;//结束循环
				}
				ans=max(a[i]+a[j]+a[k],ans);//更新最大值
			}
		}
	}
	cout<<ans;//输出
	return 0;//别忘了
}
```
谢谢观看，希望大家能看懂

---

## 作者：丨Sky灬丨无惧 (赞：8)

### 题解

思路：因为$1\le n\le 100$，数据范围较小，所以我们可以进行暴力的模拟通过三层循环嵌套来完成。

【代码】：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10000000],ans=0;
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			for(int k=j+1;k<=n;k++){
				if(a[i]+a[j]+a[k]<=m)ans=max(ans,a[i]+a[j]+a[k]);//如果三项相加符合小于等于m的条件，通过max更新最大值。
			}
		}
	}
	cout<<ans;//输出。
	return 0;
}
```

然后我们还可以通过另一种方式（二分）来酷炫地完成此题，减少一层循环，代码大致一样。

【代码】：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10000000],l,r,mid,ans=0;
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++)cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=1; i<=n; i++) {
		for(int j=i+1; j<=n; j++) {
				l=1;//要重置。
				r=n;//要重置。
				while(l<=r) {//基础二分。
					mid=(l+r)/2;
					if(a[i]+a[j]+a[mid]<=m)l=mid+1;//如果在范围内就是l=mid+1以提升mid的大小。
					else r=mid-1;//否则是mid减小
				}
				if(r!=i&&r!=j&&r!=0)ans=max(ans,a[i]+a[j]+a[r]);//结束二分后更新最大值，小心r与i和j相同且当a（i）+a（j）已经大于m时r会更新到0，a(0）是没有的，但如果a（i）+a（j）恰好等于m时，就会出现错误，如样例二。
			}
	}
	cout<<ans;//输出。
	return 0;
}
```
完结撒花。

---

## 作者：Remake_ (赞：5)

这道题有点骚。

这道题第一眼就让人感觉是个dp，但是

$6\leq m \leq 5 \times 10^8$。

woc，那怎么写？

这基本上告诉了我们，不能写dp，所以，我们只能写暴力~~话说模拟退火应该也行~~，但是，暴力是$O(n^3)$的面对大数据跑不过去啊。

其实不然，我们只用枚举前两个数即可，在枚举了前两个数之后，接下来第三个数就可以二分了，为什么呢，因为前两个数确定了初始值，我们只需要记录一个$pos$表示第一个大于剩余空间的数字的位置，然后我们就知道$pos-1$就是最后一个小于等于剩余空间的数字的位置，再加一下取最大值就行了。

什么？你说不满足单调性，您sort一下啊！

什么？你说您不会（懒得）写二分，用upper_bound啊，值得一提的是，upper_bound返回值是指针，在再减去初始地址就可以得到$pos$了。

再看一下，时间复杂度$O(n^2logn)$，不吸氧也跑的过去。

总之，您有可能还是没听懂，具体请看我代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c[1005],maxn;
int main(){
	cin>>a>>b;
	for(int i=1;i<=a;i++) cin>>c[i];
	sort(c+1,c+a+1);
	c[a+1]=0x7fffffffff;
	for(int i=1;i<=a-2;i++){
		for(int j=i+1;j<=a-1;j++){
			if(b-c[i]-c[j]>=c[j]){
				long long pos=upper_bound(c+j+1,c+a+2,b-c[i]-c[j])-c;
				if(pos!=j+1){
					maxn=max(maxn,c[i]+c[j]+c[pos-1]);
				}
			}
		}
	}
	cout<<maxn;
}
```


---

## 作者：_Clown_ (赞：4)

这有可能是蒟蒻红名前的最后一片题解了，望通过！

言归正传，这道题目，我们可以用暴力枚举来解决。

首先，输入，输入元素个数，及最大值，还有数组。

暴力枚举三个数的下标即可，注意下标不能重复哦！

求出三个数后，求和，看看符不符合要求，再在所有符合要求的里面取最大值。

[跑得还挺快。](https://www.luogu.com.cn/record/32977416)

于是，没什么好说的了，毕竟他是一道入门题。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int Total,Max;
int Array[101];
int main()
{
	register int i,j,k;
	cin>>Total>>Max;
	for(i=1;i<=Total;i++)
	{
		cin>>Array[i];
	}
	register int Ans=0;
	for(i=1;i<=Total;i++)
	{
		for(j=i+1;j<=Total;j++)
		{
			for(k=j+1;k<=Total;k++)
			{
				if(Array[i]+Array[j]+Array[k]<=Max)
				{
					Ans=max(Ans,Array[i]+Array[j]+Array[k]);
				} 
			}
		}
	}
	cout<<Ans<<endl;
	return 0;
}
```

---

## 作者：bovine__kebi (赞：4)

 我们看 $n$的范围，只有$10^3$，所以我们可以想到先暴力一发，我们就去枚举三个数，用 $maxx$来更新最大值，然后卡个常，代码如下，甚至都不用快读，还跑的飞快：  
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+5;//上界
int n,m;
int a[maxn];
int maxx=-9999999;//设为小负数是怕题目里全是负数的一种情况
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//读入每个数
    }
    for(register int i=1;i<=n;i++)
    {
        for(register int j=i+1;j<=n;j++)//为了不重复，所以从i+1开始枚举
        {
            for(register int k=j+1;k<=n;k++)//同理
            {
                if(a[i]+a[j]+a[k]<=m)//如果小于m，就让他们对maxx更新
                maxx=max(maxx,a[i]+a[j]+a[k]);
                else continue;//大了就跳过或者可以这句话不写
            }
        }
    }
    printf("%d\n",maxx);//输出
    return 0;//完美结束
}
```
如果还有别的好方法，欢迎来提供

---


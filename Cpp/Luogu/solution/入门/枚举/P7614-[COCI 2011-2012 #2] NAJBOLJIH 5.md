# [COCI 2011/2012 #2] NAJBOLJIH 5

## 题目描述

给定 $8$ 个数字 $X_1,X_2,...,X_8$，从中选出 $5$ 个数字，使得这 $5$ 个数字的总和最大。输出这 $5$ 个数字的和以及它们的编号。$X_i$ 的编号为 $i$。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le X_i \le 150$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $50$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #2](https://hsin.hr/coci/archive/2011_2012/contest2_tasks.pdf)** ___T1 NAJBOLJIH 5___。

## 样例 #1

### 输入

```
20
30
50
48
33
66
0
64```

### 输出

```
261
3 4 5 6 8```

## 样例 #2

### 输入

```
20
0
50
80
77
110
56
48```

### 输出

```
373
3 4 5 6 7```

## 样例 #3

### 输入

```
20
30
50
80
110
11
0
85```

### 输出

```
355
2 3 4 5 8```

# 题解

## 作者：yydfj (赞：24)

**这是本蒟蒻第六次写的题解，如有错误点请好心指出！**

该题解审核通过后有人指出错误，已被修改 $1$ 次。

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你 $8$ 个不同数值的数，找出数值前 $5$ 大的数，求出它们的和以及它们的编号（编号要从小到大排序）。

## 解法综述

我们可以利用结构体的特性解决这道题。

首先将输入的 $8$ 个数的编号一一对应，再给它们的数值进行从大到小的排序，取出前 $5$ 个数。因为要输出它们的编号，而且编号要从小到大排序，所以就给这 $5$ 个数的编号进行从小到大的排序。最后我们就输出这 $5$ 个数的和以及它们的编号。

## 代码描述
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
struct NAJBOLJIH_5{
	int number,score;
}a[11];
int n;
int main()
{
	for(int i=1;i<=8;i++)
	{
		scanf("%d",&a[i].score);
		a[i].number=i;//将输入的8个数的编号一一对应
	}
	for(int i=1;i<=8;i++)
	for(int j=i+1;j<=8;j++)
	if(a[i].score<a[j].score) swap(a[i],a[j]);//给这8个数的数值进行从大到小的排序
	for(int i=1;i<=5;i++)//取出前5个数
	for(int j=i+1;j<=5;j++)
	if(a[i].number>a[j].number) swap(a[i],a[j]);//给这5个数的编号进行从小到大的排序
	printf("%d\n%d %d %d %d %d",a[1].score+a[2].score+a[3].score+a[4].score+a[5].score,a[1].number,a[2].number,a[3].number,a[4].number,a[5].number);//输出这5个数的和以及它们的编号
	return 0;
}
```

---

## 作者：_Harrisonwhl_ (赞：14)

我们可以用一个结构体来存编号和数，然后以数的大小从大到小排序，然后选前五个，计算加和后输出，再以编号升序排列，并依次输出。
# $Code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
struct S
{
    int id,num;
} a[10];
bool cmp(S x,S y)
{
    return x.num > y.num;
}
bool cmp1(S x,S y)
{
    return x.id < y.id;
}
int main()
{
    for (int i = 1;i <= 8;i++) cin >> a[i].num,a[i].id = i;
    sort(a + 1,a + 9,cmp);
    int ans = 0;
    for (int i = 1;i <= 5;i++)
        ans += a[i].num;
    cout << ans << endl;
    sort(a + 1,a + 6,cmp1);
    for (int i = 1;i <= 5;i++)
        cout << a[i].id << " ";
    return 0;   
}

```

---

## 作者：_lfxxx_ (赞：4)

**题目传送门：[P7614 [COCI2011-2012#2] NAJBOLJIH 5](https://www.luogu.com.cn/problem/P7614)**
### 题意：
求 $8$ 个数中最大的 $5$ 个。输出它们的和并输出它们的编号（第 $i$ 个数的编号为 $i$ ，且要升序输出）
### 思路：
**模拟。**

读入完后 $8$ 个数后排序找出最大的 $5$ 个数，求和。

然后再按它们的编号排序即可。

但是，不难看出，我们存一个数的信息既要存值，又要存编号。于是我们可以用 `pair` 。

如果不懂 `pair` 的，可以去[这篇博客](https://blog.csdn.net/sevenjoin/article/details/81937695)看一看。

这里我将第一关键字存储值，第二关键字存储编号。
### 代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
pair<int,int>a[10];
inline bool cmp(pair<int,int>a,pair<int,int>b){
    return a.second<b.second;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);//优化
	int ans=0;
	for(int i=1;i<=8;i++){
		cin>>a[i].first;
		a[i].second=i;
	}
	sort(a+1,a+9);//以值排序
	for(int i=4;i<=8;i++)
		ans+=a[i].first;
	cout<<ans<<endl;
    sort(a+4,a+9,cmp);//以标号排序
	for(int i=4;i<=8;i++)
		cout<<a[i].second<<' ';
	return 0;
}
```


---

## 作者：D2T1 (赞：3)

[$\color{blue}{\text {pwp }{\to\textbf{My blog}\gets}}\text{qwq}$](https://www.luogu.com.cn/blog/390770/blogcenter)

## 题解

借这一道题目，我会教大家一种排序算法：**归并排序**；一个STL函数：**`sort`**；一个STL容器：**`pair`**。

------------

首先，题目要求对这个数组进行排序。当然数组只有 $8$ 个元素，但是如果遇到更多元素的数组呢？对于冒泡排序、选择排序这种肯定会慢。所以我们需要一种快速的排序算法：归并排序。

归并排序基于分治思想，即把待排序的序列通过递归的形式二分分成两段，直到每一段只有一个元素，开始合并。

可能这样说不太能懂，这里先放上代码。

```cpp
int a[1000];//待排序数组
int b[1000];//合并用工具数组 相当于一个栈

void mergesort(int l,int r){//将区间 [l,r] 进行排序
	if(l<r){//即l!=r，表示区间长度 >1
		int mid=l+((r-l)>>1);//取区间中点，进行二分
		mergesort(l,mid);//递归二分区间
		mergesort(mid+1,r);//记得 mid 要 +1
        //现在区间 [l,mid] 与 [mid+1,r] 都已经排序完成，称为区间 L 和区间 R
		int i=l,j=mid+1,t=0;// i 为区间 L 的第一个元素，j 为区间 R 的第一个元素，t 相当于 b 的栈顶
		while(i<=mid&&j<=r){//如果两个区间都有元素还未放入 b 中
			if(a[i]>a[j]) b[t++]=a[j++];//第一个区间待放置元素大于第二个区间 则把第二个区间待放置元素放入 b 中
			else          b[t++]=a[i++];//同上
		}
      		//这时至少有一个区间所有元素已经都放入 b 中
		while(i<=mid) b[t++]=a[i++];//处理 L 中剩余元素
		while(j<=r)   b[t++]=a[j++];//同上
		for(int i=0; i<t; ++i)//把 b 放入 a 合适位置中（毕竟要排序的还是 a 数组）
			a[l+i]=b[i];
	} 
	return;
}

//main(): mergesort(1,8);
```

大家明白了吗？所以我们可以利用归并排序将 $X$ 数组进行排序。

------------

等等，输出的是编号，而不是值！所以我们要把编号与值进行绑定一起排序。STL 为我们提供了工具：二元组 `pair`

`pair` 的用法：

```cpp
pair<int,int> p; //定义一个 p 存储一个二元组，两个元素都是int型
  
p=make_pair(1,2) //把二元组 (1,2) 放入 p 中
  
p.first //二元组 p 的第一个元素
p.second //二元组 p 的第二个元素
  

pair<double,pair<int,long long> > p; //当然，pair里不只能放int,还可以pair套pair
```

两个 `pair` 进行比较会优先比较第一个元素，所以把值放在第一个，把编号放在第二个就没有问题了！

------------

现在，我们知道了最大的五个元素以及它们的编号。但是编号也是要排序了！STL 也为我们提供了排序工具 `sort`。

基本用法：`sort(l,r);` 其中 $l$ 表示首地址，$r$ 表示尾地址的后一位，所以 `sort` 排序的是一个左闭右开区间。

如果我们要排序 `x[1]` 至 `x[8]`，可以这么用：

```cpp
sort(x+1,x+8+1);//记得 +1
```

`sort` 还能编写 $cmp$ 函数自定义排序，可以自行搜索查找资料。

------------

在归并排序和 STL 的帮助下，我们能够解决这道题了。

## 代码

```cpp
//P7614
#include <algorithm>
#include <utility>
#include <cstdio>
using namespace std;
pair<int,int> a[10],b[10];
int c[5];

void mergesort(int l,int r){
	if(l<r){
		int mid=l+((r-l)>>1);
		mergesort(l,mid);
		mergesort(mid+1,r);
		int i=l,j=mid+1,t=0;
		while(i<=mid&&j<=r){
			if(a[i]>a[j]) b[t++]=a[j++];
			else          b[t++]=a[i++];
		}
		while(i<=mid) b[t++]=a[i++];
		while(j<=r)   b[t++]=a[j++];
		for(int i=0; i<t; ++i)
			a[l+i]=b[i];
	} 
	return;
}

int main(){
	for(int i=1; i<=8; ++i) scanf("%d",&a[i].first),a[i].second=i;
	
	mergesort(1,8);
	
	int sum=0;
	for(int i=4; i<=8; ++i) sum+=a[i].first;
	printf("%d\n",sum);
	
	for(int i=4; i<=8; ++i) c[i-3]=a[i].second;
	
	sort(c+1,c+5+1);
	for(int i=1; i<=5; ++i) printf("%d ",c[i]);
	
	return 0;
}
```


---

## 作者：ZBAA_MKC (赞：2)

#### 思路分析

用结构体，一个变量存储 $X_i$ 的值，另一个变量存储这个数的编号。

先按 $X_i$ 的大小从小到大排序，取后面五个数求和，在将这些数的编号存储到另一个数组中，然后对这个数组排序，输出即可。

#### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;


struct num //结构体
{
	int n;
	int id;
}a[9];

int ans[5]; //用于储存答案

bool cmp(num x, num y)
{
	return x.n > y.n;
}

int main()
{
    for (int i = 1; i <= 8; i++) //输入
    {
    	cin >> a[i].n;
    	a[i].id = i;
	}
	sort(a + 1, a + 9, cmp); //排序
	int sum = 0; 
	for (int i = 1; i <= 5; i++)
	{
		sum += a[i].n; //累加总和
		ans[i - 1] = a[i].id;
	}
	cout << sum << endl; //先输出总和
	sort(ans, ans + 5); //排序
	for (int i = 0; i < 5; i++) //输出编号
	{
		cout << ans[i] << ' ';
	}
	return 0;
}

```


---

## 作者：koishi_offical (赞：2)

一道非常简单的模板题，可以用来训练结构体的排序。


讲一下思路： 定义一个结构体，存每个数的权值和编号，读入数据，然后先对整个数组按照权值降序排序，再对前五个数按照编号升序排序，最后统计答案就行了。

具体细节看代码 

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
  {
      int p;
      int id;
  } a[9];
bool cmp1(node x,node y)
  {
      return x.p>y.p;
  }
bool cmp2(node x,node y)
  {
      return x.id<y.id;
  }
int ans;
int main() {
    for(int i=1;i<=8;i++)
      {
          cin>>a[i].p;
          a[i].id=i;
      }
    sort(a+1,a+9,cmp1);
    sort(a+1,a+6,cmp2);
    for(int i=1;i<=5;i++) ans+=a[i].p;
    cout<<ans<<endl;
    for(int i=1;i<=5;i++) cout<<a[i].id<<" ";
}
```


---

## 作者：水得不行 (赞：2)

  直接用sort函数和结构体就行了，十分简单（~~我也就用了十几分钟~~）废话不多，上代码
```
#include<iostream>
#include<algorithm>//sort函数头文件 
using namespace std;
struct x{ //用个结构体 
	int xi,id;//分别为xi和其编号 
};
bool cmp1(x m,x n){//用于给大小排序 ，用结构体先声明两个变量 m和n 
	if(m.xi>n.xi) return true;//如果m的xi大于n的xi，m排在前 
	else return false;//否则n排在前（题目中说了所有xi互不相同） 
}
bool cmp2(x m,x n){//和前面差不多 ，用于编号排序
	if(m.id<n.id) return true;//如果m的编号小于n的编号，m排在前
	else return false;//否则n排在前（所有编号一定互不相同）
}
x a[10];//用结构体声明一个数组 
int main(){
	int ans=0;//声明最后的总和 
	for(int i=1;i<=8;i++){
		cin>>a[i].xi;
		a[i].id=i;
	}//输入xi并给其编号赋值 
	sort(a+1,a+1+8,cmp1);//给它的大小先排序 
	sort(a+1,a+1+5,cmp2);//再给它最大的5个数的编号排序 
	for(int i=1;i<=5;i++){
		ans+=a[i].xi;
	}//算它最大的5个数的总和 
	cout<<ans<<endl;//输出并空行 
	for(int i=1;i<=5;i++){
		cout<<a[i].id<<" ";
	}//输出升序排序的5个编号 
	return 0;//不用我说了吧 
}
```
~~写题解花了我三十几分钟......~~
请勿抄袭。

---

## 作者：Aw顿顿 (赞：1)

## 解法

用结构体存储编号和数字，然后按照数字大小排序，此后对于前五个数字，以编号为关键字进行第二次排序。

之后输出总和以及前五项的编号即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct num{
    int num,id;
}a[10];
bool cmp1(num x,num y){
    return x.num>y.num;
}bool cmp2(num x,num y){
    return x.id<y.id;
}int s;
int main(){
    for(int i=1;i<=8;i++){
        cin>>a[i].num;
        a[i].id=i;
    }sort(a+1,a+9,cmp1);
    sort(a+1,a+6,cmp2);
    for(int i=1;i<=5;i++)s+=a[i].num;
    cout<<s<<endl;
    for(int i=1;i<=5;i++)cout<<a[i].id<<' ';
    return 0;
    
}
```



---

## 作者：123hh2 (赞：0)

--->[传送门](https://www.luogu.com.cn/problem/P7614#submit)

### 前言

本来想卡个常的，没有用 STL ，开了个二维数组瞎跑，结果成功的的拿到了最劣解，果然我还是个蒟蒻qwq

但是这篇题解提供了桶的做法，可以借鉴一下

------------

### 题目大意

给你 8 个数字 $X(1\le X\le 150)$ 和他们的编号（编号为输入顺序），从中选 5 个数字，要求和最大，输出最大值。并按照**从小到大排序并输出它们的编号**


------------
### 思路

一眼看上去就想到了用 STL 的 sort 和 struct，但我往题解区康了一下，发现有这样的做法了

于是我们可以转换一下思路，用一个桶装下这些数，因为 $X(1\le X\le 150)$ 所以空间是非常足够的。我们现在装下了这些数，还需要装下这些数对应的编号，所以需要开一个 2 维数组，最后，从后往前遍历这个桶，取最大的 5 个数及其对应的编号，按题目要求输出即可

------------
### 代码
```cpp
#include<bits/stdc++.h>
#define ri register
using namespace std;
int awa[151][3];
int qwq[6];
inline int read()
{
	ri int x=0,f=1;
	ri char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void write(ri int x)
{
	if(x<0)
	{
		x=-x;
		putchar('-');
	}
	if(x>9)
	{
		write(x/10);
	}
	putchar(x%10+'0');
}
int main()
{
	for(ri int i=1;i<=8;i++)
	{
		ri int x;
		cin>>x;
		awa[x][1]=x,awa[x][2]=i;
	}
	ri int cnt=0,sum=0;
	for(ri int i=150;i>=1;i--)
	{
		awa[i][2]==0?0:(cnt++,sum+=awa[i][1],qwq[cnt]=awa[i][2]);
		if(cnt==5) break;
	}
	write(sum),puts("");
	sort(qwq+1,qwq+6);
	for(ri int i=1;i<=5;i++) write(qwq[i]),printf(" ");
	return 0;
}
```


---

## 作者：CG__HeavenHealer (赞：0)

### 题意简述

给定 $8$ 个数字 $X_1,X_2,\cdots,X_8$，从中选出 $5$ 个数字，使得这 $5$ 个数字的总和最大。输出这 $5$ 个数字的和以及它们的编号。$X_i$ 的编号为 $i$。

---

### 解法

隆重介绍——**map**！

`std::map` 其实就是一种映射，把 `key` 映射到 `value` 。

`map` 的声明：


```
#include<map>//map的头文件
using std::map;
map<string,int>mp;//定义一个map从string到int的映射
mp[key]=value;//给键值为key的map赋一个值value
```

相关函数：

`mp.begin()` & `mp.end()` 返回一个指向 `map`起始或末尾的下一位的迭代器 

`mp.clear()` 清空 `map`

`mp.empty()` 判断 `map` 是否为空，空返回 $1$ ,否则返回 $0$


`mp.erase(val)` 删除 $val$ 对应的pair（键值和映射值全部删除）

`mp.find(val)` 返回迭代器指向当前查找键值元素的位置否则返回 `mp.end()`

`mp.insert(val)` 插入元素

`mp.count(val)` 返回指定键值元素出现的个数

~~有了这些就足以应对一些水题了~~

---

### 解法

由于 `map` **内部是红黑树实现的，有序（默认按键值排序）**，所以我们只需要构建一个序列元素到下标的映射，然后倒序遍历五个元素即可。

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
inline int read(){
	ri x=0,f=1; char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return f*x;
}
map<int,int> mp; 
int a[10];
int main(){
	for(ri i=1;i<=8;i++) mp[read()]=i;
	map<int,int>::iterator it;
	int cnt=0,ans=0;
	it=mp.end();it--;
	for(;cnt!=5;it--) ans+=it->first,a[++cnt]=it->second;
	sort(a+1,a+cnt+1);
	printf("%d\n",ans);
	for(int i=1;i<=5;i++) printf("%d ",a[i]);
	return 0;
} 
```





---


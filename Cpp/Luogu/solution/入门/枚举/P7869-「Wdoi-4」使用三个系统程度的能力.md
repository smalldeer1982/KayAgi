# 「Wdoi-4」使用三个系统程度的能力

## 题目背景

**勘误**：事实上，自从 $2001$ 年发布的 $\text{MacOS X}$ 之后换行符都变成了 $\verb!\n!$。网上发布的很多文章都存在谬误，当时出题人也没实地考察就信了。为了防止谣言继续传播，就在这里放了这段话。数据仍然以目前的题目描述为准，未做更改。

---

赫卡提亚·拉碧斯拉祖利是拥有三副身体，司掌月球、地球、异界三界地狱的神明。由于与纯狐结盟的缘故，赫卡提亚接触到了幻想乡，以及其他的一些现代科技。

赫卡提亚发现，在人类社会中存在三个非常通用流行的操作系统，也就是 $\text{Windows}$、$\text{Linux}$ 和 $\text{Mac}$。这三者就像是赫卡提亚本人的三个身体般，分别占据了很大的市场。

但是赫卡提亚又发现，尽管这三个系统之间的文件可以通过一些方式进行信息流通，可是毕竟存在一些区别：例如换行方面采用的字符的不同。赫卡提亚对此非常感兴趣。

现在赫卡提亚不知道从哪里搞来了一个系统的文本文件，她想知道这个文件是在哪个系统里编辑而成的。你能写个程序帮帮她吗？

## 题目描述

在 $\text{Windows}$、$\text{Linux}$ 和 $\text{Mac}$ 系统下，分别采用了三种不同的换行符方式。表示为显式转义符，分别是 $\verb!\r\n!$、$\verb!\n!$ 和 $\verb!\r!$ 。现在有一份已经写好了的非空文本文件（里面仅由大小写英文字母、下划线、阿拉伯数字、空格，以及换行符组成）。这个文本文件是在单一系统中写成的，因此保证换行符只会出现上述三种情况**之一**。

比如，这是一个合法的文本文件：

```plain
SCP2021 J rp plus plus
chen zhe AK IOI

Welcome to Hell
```

现在将其中的换行变为对应的转义符。那么在上述三个系统中，分别会变为以下三种模样：

- $\text{Windows}$ 系统：  

$$\colorbox{f5f5f5}{\verb!SCP2021 J rp plus plus\r\nchen zhe AK IOI\r\n\r\nWelcome to Hell!}$$

- $\text{Linux}$ 系统：

$$\colorbox{f5f5f5}{\verb!SCP2021 J rp plus plus\nchen zhe AK IOI\n\nWelcome to Hell!\kern{31.5pt}}$$

- $\text{Mac}$ 系统：

$$\colorbox{f5f5f5}{\verb!SCP2021 J rp plus plus\rchen zhe AK IOI\r\rWelcome to Hell!\kern{31.5pt}}$$ 

---

现在你被给定的任务是，根据转换后的文本文件，判断这是哪个系统下编写的文本文件。对于上述三种情况，分别输出 `windows`、`linux` 或 `mac`。

## 说明/提示

样例 $4$ 见下发的附件 $\textbf{\textit{system4.in}/\textit{system4.out}}$。

#### 数据范围

- 对于 $40\%$ 的数据，保证不存在空格。
- 对于 $100\%$ 的数据，保证输入字符串的长度 $\le 10^5$。输入中仅包含大写英文字母、小写英文字母、下划线、数字、空格和转义字符（`\r`、`\n`）。

#### 注意

本题中的 `\n` 及 `\r` 表示直接写在输入里的一个反斜杠符号跟着一个小写字母 `n` 或 `r`，而不是一个**真正的**转义字符。

## 样例 #1

### 输入

```
SCP2021RPplusplus\nchenzheAKIOI\n1plus1equalto2\n```

### 输出

```
linux```

## 样例 #2

### 输入

```
chen_zhe AK IOI\r\nchen_zhe AK NOI\r\n```

### 输出

```
windows```

## 样例 #3

### 输入

```
include iostream\rsigned main return 0\r```

### 输出

```
mac```

# 题解

## 作者：囧仙 (赞：33)

## 题解

容易发现，本题就是去寻找输入的字符串里是否含有 $\verb!\r!$ 和 $\verb!\n!$。因为本题保证了文本文件仅在一种系统中产生，因此若仅有前者，则为 $\text{Mac}$ 系统；仅有后者，则为 $\text{Linux}$ 系统；如果都有，则为 $\text{Windows}$ 系统。

- 那么只需要使用 $\verb!getline!$ 函数读入整行字符串，然后使用 $\verb!find!$ 函数查询里面是否含有即可。要注意的是，如果 $\verb!find!$ 函数没能查找到某个需要匹配的字符串，返回值是 $\verb!ULLONG_MAX!$。

- 或者可以选择不断读入字符串，直到读到文件末尾（$\verb!EOF!$），然后对每次读入的字符串使用 $\verb!find!$ 函数。如果使用 $\verb!cin!$，那么读入到文件末尾则会返回 $0$；如果使用 $\verb!scanf!$，那么读入到文件末尾则会返回 $-1$（即 $\verb!EOF!$ 字面量）。

- 或者可以使用 $\verb!fread!$，把输入数据里所有的字符全部读进来（要注意的是，前两种做法都是使用的 $\text{C++}$ 里面特有的字符串（$\verb!string!$），但是 $\verb!fread!$ 属于 $\text{C}$ 风格读入，读入的东西是 $\text{C}$ 风格字符串（$\verb!char []!$））。$\verb!fread!$ 会返回读入的字符的总个数。因此可以直接循环，进行匹配。

- 或者可以直接手写 $\verb!getline!$。具体就是不断地使用 $\verb!getchar!$，一直读到 $\verb!EOF!$。

### 参考代码

```cpp
#include<iostream>
#include<string>
std::string s;
int main(){
    std::getline(std::cin,s); bool f1=0,f2=0;
    if(s.find("\\r")<s.length()) f1=true;
    if(s.find("\\n")<s.length()) f2=true;
    if(f1&&f2) std::cout<<"windows"<<std::endl; else 
    if(f2    ) std::cout<<"linux"<<std::endl; else 
    if(f1    ) std::cout<<"mac"  <<std::endl;
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：5)

其实这题非常简单（签到题），就是输入一个字符串，然后查找 `\r` 和 `\n`。如果两者都有，则输出 `Windows`；若只有 `\r`，则输出 `Mac`；只有 `\n`，则输出 `Linux`。此后还要注意 `\` 是转义字符的符号，要表示它，必须是 `'\\'`，这也是本题一个难点。

### AC Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
bool p1,p2;//分别表示 \r \n 是否出现
int main(){
	getline(cin,s);
	for(int i=0,l=s.length();i<l;i++){//先存长度减小常数
		if(s[i]=='\\'&&s[i+1]=='r')//注意
			p1=1;
		else if(s[i]=='\\'&&s[i+1]=='n')
			p2=1;
		if(p1&&p2){//若都出现，直接输出
			puts("windows");
			return 0;
		}
	}
	if(p2)//看出现的是什么
		puts("linux");
	else
		puts("mac");
    return 0;
}
```

---

## 作者：Jerrlee✅ (赞：3)

## 题意
读入一行字符串。

读入的字符串若是 `windows` 的有 `\r` 和 `\n`，`linux` 有`\n` 但没 `\r`，`mac` 有 `\r` 但没 `\n`。

输出操作系统名称。
## 思路
用 `strstr()` （作用是返回字符串中首次出现子串的地址）进行搜索，分三类讨论：

- 如果 `\r` 和 `\n` 都出现了，是 `windows`；

- 如果 `\n` 出现了但 `\r` 没有出现，是 `linux` ；

- 否则就是 `mac`。

判断时直接输出名称就行了。

## 注意
代码中 `\` 需要换成 `\\`，否则 `CE` 等您！
## 代码
```cpp
#include<cstdio>
#include<cstring>
char s[100001];
int main(){
    fgets(s,100001,stdin); //fgets 的功能为从指定的流中读取数据，每次读取一行
    if(strstr(s,"\\r\\n")) printf("windows");
    else if(strstr(s,"\\n")) printf("linux");
    else printf("mac");
}
```
[AC记录](https://www.luogu.com.cn/record/58318709)

---

## 作者：JustinXiaoJunyang (赞：2)

~~这题要抢着发题解～~~

前排芝士：

Q ：转义字符是什么？

A ：在我们的 ASCII 码中，有一些字符不能“直接打出来”。例如本题的换行符 `\n` 和 `\r` ，在此拓展一个缩进字符 `\t` 。

思路分析：

我在这里提供三种思路（第二种是我想的）：

第一种就很简单：看 `\n` 和 `\r` 是否存在。只有 `\n` 则是 `linux` ，只有 `\r` 则是 `mac` ，都有则是 `windows` 。

第二种呢稍微严谨一点点：先判断有没有 `\r\n` （连起来），没有的话再分别找分开的 `\n` 和 `\r` 。

第三种就适用于所有的了：统计 `\n` 和 `\r` 的个数，没有 `\r` 则是 `linux` ，没有 `\n` 则是 `mac` ，个数相等则可能是 `windows` ，如果个数不相等，则啥都不是。如果两个换行符数量一样，还要看每个四个换行符的字符是不是都是 `\r\n` （可能有的换行符是 `\n\r` ），如果有的不是的话，则啥都不是，否则是 `windows` 。

易错分析：

在 `if` 判断条件时，判断的字符串子串要在 `\n` 或 `\r` 前多加一个反斜杠。例如 `\\n` 和 `\\r\\n` ，我就是一开始错这里。

参考代码：

我可以提供上述的第二种方法：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string s;
    getline(cin, s);
    string ans = "";
    for (int i = 0; i < s.length() - 3; i++)
    {
        if (s.substr(i, 4) == "\\r\\n") ans = "windows";
    }
    if (ans == "")
    {
        for (int i = 0; i < s.length() - 1; i++)
        {
            if (s.substr(i, 2) == "\\n") ans = "linux";
            if (s.substr(i, 2) == "\\r") ans = "mac";
        }
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：a1ioua (赞：2)

介绍一个 `string` 特有的 `s.find()` 函数。

`s.find()` 返回值是子串在母串中的首个字母下标，如果没有找到，那么会返回一个特别的标记 `npos`。

在这一题，我们不用看下标，直接判断是否为 `npos` 即可。

由于 Windows 系统的换行符为 `\r\n`，包含了 Linux 与 Max 系统的换行符，所以我们要最先判断 Windows 系统，其他的后判断。 

还有一点，由于 `\` 在 c++ 语言中为转义字符，所以我们需要用两个反斜杠 `\\` 来表示一个字符串中的反斜杠 `\`。

------------
```cpp
#include <bits/stdc++.h>
using namespace std;
signed main() {
    string s;
    getline(cin, s);
    if (s.find("\\r\\n") != s.npos /*注意是 s.npos*/ ) printf("windows");
    else if (s.find("\\n") != s.npos) printf("linux");
    else printf("mac");
    return 0;
}
```

---

## 作者：言琢დ (赞：2)

如题意所述，考虑使用两个变量来分别记录是否出现了 ``\n`` 和 ``\r`` 字符。

如果同时出现，就是 `windows`。

如果只出现 `\n` 就是 `linux`，否则就是 `mac`。

听说新版的系统已经废弃 gets 改用 fgets，希望大家也注意一下吧。

```cpp
#include<cstdio>
#include<cstring>
inline int in();
inline void wr(int);
const int N=(int)1e5+5;
char str[N];
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("A.in","r",stdin);
	freopen("A.out","w",stdout);
#endif
	gets(str+1);
	register int len=strlen(str+1);
	bool _n=0,_r=0;
	for(register int i=1;i<len;++i)
		if(str[i]=='\\'){
			if(str[i+1]=='n')
				_n=1;
			if(str[i+1]=='r')
				_r=1;
		}
	if(_n&&_r)puts("windows");
	else if(_n)puts("linux");
	else puts("mac");
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

---

## 作者：haraki (赞：1)

**本题要求读入一行字符串，判断里面 `\r`，`\n` 的情况。**

但在 c++ 内，`\r` 和 `\n` 只占一个字符的位置。那么，我们如何表示分开独立的 `\` 和 `r` 呢？

c++ 称 `\r` 和 `\n` 等为**转义字符**。同样，c++ 提供了 `\` 的转移字符，`\\`。所以这里我们写 `'\\r'` 就可以解决了。

c++ stl 内包括了字符串类型 string，以及读入一行的函数 `getline()`，以及寻找某子串函数 `find()`。   
当 `mystr.find("something")` 找不到时，返回 -1。据此，我们就可以分辨出三种系统了。

下面给出代码：
```cpp
#include<bits/stdc++.h>
std::string s,r[4]={"","mac","linux","windows"};
//只有 \r：0*2+1=1
//只有 \n：1*2+0=2
//均有：1*2+1=3
//对应数组下标
int main(){
	getline(std::cin,s);//getline(cin,s) 从 cin 流读入 s
	std::cout<<r[(s.find("\\n")!=-1)*2+(s.find("\\r")!=-1)];
    //                    找的到 \n 吗              找的到 \r 吗
}

```

---

## 作者：Eason_AC (赞：1)

## Content
现在有一个转换后的文本文件，以一个长度为 $n$ 的字符串表示。请判断这个文件是用哪一种写的，详情请返回题面。

**数据范围：$n\leqslant 10^5$。字符串里面至少有一个用来表示换行符的现显式转义符。**
## Solution
这道题目作为普及模拟赛的第一题挺良心的，虽然说没有 NOIP2018 普及组 T1 那么直接，但是也不难想到。

首先我们看到题目，发现解决此题的突破口是这个显式转义符。

然后再根据 `\r` 和 `\n` 出现的情况判断系统就是这样：

- $\texttt{Windows}$ 系统：两种显式转义符同时出现。
- $\texttt{Linux}$ 系统：只出现 `\n`。
- $\texttt{Mac}$ 系统：只出现 `\r`。

然后我们再去扫一遍字符串找 `\r` 和 `\n`，然后根据找的情况，综合上面的判断标准确定系统就可以做出这道题目了。

注意字符串中间有空格，建议用 `getline` 读入字符串。详情见代码。
## Code
```cpp
namespace Solution {
    string s;

    iv Main() {
        getline(cin, s);
        int fln = 0, flr = 0;
        F(int, i, 0, (int)s.size() - 1) if(s[i] == '\\') {
            if(s[i + 1] == 'n') fln = 1;
            if(s[i + 1] == 'r') flr = 1;
        }
        if(fln && flr) printf("windows");
        else if(fln) printf("linux");
        else printf("mac");
        return;
    }
}
```

---


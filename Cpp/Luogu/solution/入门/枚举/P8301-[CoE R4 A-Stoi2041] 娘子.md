# [CoE R4 A/Stoi2041] 娘子

## 题目背景

![](bilibili:BV1fx411N7bU?page=4)

## 题目描述

给定两个长度均为 $n$ 的 $0$，$1$ 序列 $a$，$b$，**首先**，你可以选择一些 $a_i$ 取反，即 $0$ 变为 $1$，$1$ 变为 $0$，**然后**，任意排列序列 $a$。

要求上述过程结束后 $a_i$ **等于** $b_i$，求取反的最少次数。

## 说明/提示

### 样例解释

输入 #1：将 $a = 110$ 重排为 $a = 101$ 即可达到题目要求，故取反的最少次数为 $0$。

输入 #2：将 $a = 10010$ 的第四位取反（从左往右计数），得 $a=10000$，然后再重排得到 $a=00100$ 即可达到题目要求，故取反的最少次数为 $1$。 

---

### 数据规模

- 对于 $10\%$ 的数据，$n = 1$；
- 对于另外 $20\%$ 的数据，$b_i = 0$；
- 对于另外 $20\%$ 的数据，$b_i = 1$；
- 对于 $100\%$ 的数据，$1 \le n \le 10^3$，$a_i \in \{0, 1\}$，$b_i \in \{0, 1\}$。


## 样例 #1

### 输入

```
3
110
101
```

### 输出

```
0```

## 样例 #2

### 输入

```
5
10010
00100```

### 输出

```
1```

# 题解

## 作者：VinstaG173 (赞：19)

出题人题解。

祖传送分题。注意到只要 0,1 的个数分别相同就一定可以通过重排使得 $a,b$ 相同。因此我们只需要将 0 的个数通过操作二变成相同，相应地 1 的个数便一定相同了。

因此答案就是 $a,b$ 初始时 0 的个数差。

std 如下，其中 `%1d` 可以输入一个一位数。

Code:
```cpp
#include<cstdio>
int n,m,x;
int main(){
	scanf(" %d",&n),m=0;
	for(int i=0;i<n;++i){
		scanf(" %1d",&x),m+=x;
	}for(int i=0;i<n;++i){
		scanf(" %1d",&x),m-=x;
	}printf("%d\n",(m<0)?-m:m);
	return 0;
}
```

---

## 作者：wimg6_ (赞：5)

# P8301 题解

月赛的题目，可以一眼秒，但有许多值得思考的地方。

### Step 1

此时，我们刚看到题目，想到模拟字符串修改的情况。但是这样非常复杂，我们需要对其进行优化。

### Step 2

我们发现，可以任意排列 $a$。

这也就说明，只要 $a$ 和 $b$ 中的 $0$ 和 $1$ 个数分别相同，这个数列就能不用取反，直接拼凑得成。

我们通过这个理论，进一步推出，只要计算 $a$ 和 $b$ 中的 $0$ 和 $1$ 个数，然后再操作即可。最终答案为 $max(a_0-b_0,a_1-b_1)$，其中 $a_x$ 表示 $a$ 的数位中含有多少个 $x$，$b_x$ 也具有相同意义。对于 $max(a_0-b_0,a_1-b_1)$，是为了避免出现负数的情况。

### Step 3

接着，我们回顾以下刚刚的思路，发现一个有趣的性质：$a_0=n-a_1$ 且 $b_0=n-b_1$，也就是说，我们只需要知道 $a_0$ 和 $b_0$ 即可。最后取 $abs(a_0-b_0)$ 就可以了。

### Step 4

在 Step 3 中，我们知道最终答案为 $abs(a_0-b_0)$，我们再对其进行思考，发现 $a_0-b_0$ 其实可以只用一个变量表示出来。此时，我们记 $s=a_0-b_0$。在读入时，如果遇上 $a$ 串中的 $0$，那么 $s+1$，如果遇上 $b$ 串中的 $0$，那么 $s-1$，最后取 $abs(s)$ 即可。

### Step 5

此时，我们计算时间复杂度：为 $O(n)$，空间复杂度为 $O(1)$ ，可以通过本题。于是，我们可以开始敲代码了。

### Step 6

构造代码。

首先，定义并读入 $n$ 和 $s$，在此不赘述。

其次，我们可以读入两个字符串预处理 $s$。

```
	for(int i=1;i<=n;i++)
	{
		char c;
		cin>>c;
		if(c=='0') s++;
	}
	for(int i=1;i<=n;i++)
	{
		char c;
		cin>>c;
		if(c=='0') s--;
	}
```

最后，我们输出 $abs(s)$ 并返回 $0$ 即可。

### Step 7

我们在构造代码的时候发现，两个部分的读入是非常类似的。我们便可以考虑对其简化：当 $c=0$ 并且 $1 \leq i \leq n$ 的时候，在读入 $a$ 字符串中的 $0$，$s+1$。当 $c=0$ 并且 $n+1 \leq i \leq 2 \times n$ 的时候，在读入 $b$ 字符串中的 $0$,$s-1$。

代码如下：

```
	for(int i=1;i<=2*n;i++)
	{
		char c;
		cin>>c;
		if(c=='0')
			if(i<=n) s++;
			else s--;
	}
```

### Step 8

根据以上提示构造出完整代码并提交即可。

---

## 作者：100kt_WNW (赞：5)

题面很简单：

有 $2$ 个 $01$ 串，分别为 A 和 B.

可以将 A 中任意几位进行取反，然后对整个 A 重排，求**最少**的取反次数.

思路：

我们将 $0$ 作为“背景”，只考虑 $1$，因为 $1$ 和 $0$ 只要中任意一个匹配成功，另一个也就匹配成功了.

由于 A 串可以任意重排，我们不考虑具体顺序，只考虑在这两个串中 $1$ 的个数.

```cpp
    int cntA=0,cntB=0;//局部变量不要忘记赋值。
    char ch;//我们只需要数量，不需要顺序，一个字符变量就够了。
    //写2个for循环，在输入的同时计数。
    for(int i=1;i<=n;++i){
        cin>>ch;
        cntA+=(ch-'0');//当ch为1时增加1。
    }
    for(int i=1;i<=n;++i){
        cin>>ch;
        cntB+=(ch-'0');//当ch为1时增加1。
    }
```

然后我们进行匹配：

俗话说“一个萝卜一个坑”，这里我们也采用这种思想.

这里我们设 A 中有 $a$ 个 $1$，B 中有 $b$ 个 $1$.

第一种情况:

“萝卜”比“坑”多，我们可以“吃掉”一些“萝卜”，也就是将 A 串中多余的 $1$ 取反.

多余的数量为 $a-b$.

```cpp
    if(cntA>cntB)cout<<cntA-cntB<<endl;
```

第二种情况：

“萝卜”比“坑”少，我们需要更多的“萝卜”，即将 A 串中的一些 $0$ 取反.

缺少的数量为 $b-a$.

```cpp
    if(cntA<cntB)cout<<cntB-cntA<<endl;
```

第三种情况：

“萝卜”和“坑”一样多，我们什么也不用干.

```cpp
    if(cntA==cntB)cout<<0<<endl;
```

不难发现，以上三条 ```if``` 语句相当于 $\left| a-b \right|$.

因此可以用 ```cstdlib``` 库中的 ```abs``` 函数封装.

所以我们只需要这一段代码就够了.

```cpp
    cout<<abs(cntA-cntB)<<endl;
```

下面是完整代码：

```cpp
#include<iostream>
#include<cstdlib>
//千万不要忘了cstdlib，否则会Compile Error。
using namespace std;
int n;
int main(){
    cin>>n;
    char ch;
    int cntA=0,cntB=0;
    for(int i=1;i<=n;++i){
        cin>>ch;
        cntA+=ch-'0';
    }
    for(int i=1;i<=n;++i){
        cin>>ch;
        cntB+=ch-'0';
    }
    cout<<abs(cntA-cntB)<<endl;
    return 0;
}
```

---


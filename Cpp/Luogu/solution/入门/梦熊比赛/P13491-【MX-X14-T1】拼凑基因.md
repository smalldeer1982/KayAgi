# 【MX-X14-T1】拼凑基因

## 题目描述

小 A 给了你两个长度为 $n$ 的字符串 $S,T$，他想问你是否可以将 $S$ 划分为若干子串\*后以任意顺序拼接在一起使其等于 $T$。

\*子串的定义为原字符串中**连续**的一段字符组成的字符串。

## 说明/提示

**【样例解释 \#1】**

可以把 $S$ 划分为 $\texttt{xyz},\texttt{ab}$ 两个子串，交换这两个子串的顺序拼接成 $\texttt{abxyz}$。

**【样例解释 \#2】**

可以把 $S$ 划分为 $\texttt{aa},\texttt{b},\texttt{bcc}$，然后拼接成 $\texttt{bccaab}$。

**【样例解释 \#3】**

可以证明无论如何划分和拼接都不可能使 $S$ 变成 $T$。

**【数据范围】**

对于 $10\%$ 的数据，$n \le 10$。

对于 $30\%$ 的数据，$n \le 20$。

对于 $60\%$ 的数据，$n \le 10^3$。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，保证 $S,T$ 中只包含小写英文字母。

## 样例 #1

### 输入

```
5
xyzab
abxyz```

### 输出

```
Yes```

## 样例 #2

### 输入

```
6
aabbcc
bccaab```

### 输出

```
Yes```

## 样例 #3

### 输入

```
3
abc
bda```

### 输出

```
No```

# 题解

## 作者：___AaAa_bBcCd___ (赞：4)

### 题目分析

本题可以任意划分，任意拼接，也就是说只要每个字母出现的次数相同就是可行的。

我们可以采取一种非常简短的判断方法：将两个字符串排序后判等，这样判断的就是字母出现的次数，因为字母会按字典序排序。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int n;
int main(){
    cin>>n>>a>>b;
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    cout<<((a==b)?"Yes":"No");
}
```

---

## 作者：enyyyyyyy (赞：3)

- 题意：你两个长度为 $n$ 的字符串 $S,T$，他想问你是否可以将 $S$ 划分为若干子串后以任意顺序拼接，在一起使其等于 $T$。

- 转化：由于“任意顺序拼接”即可知，题目要求的是 $S$ 中有的字符 $T$ 中是否拥有，若都有，即可输出 `Yes`,否则输出 `No`。 可用 `map` 实现查询。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n;
string a,b;
map<char,ll>visa,visb;
int main() {
	cin>>n>>a>>b;
	for(ll i=0;i<n;i++){
		visa[a[i]]++;
		visb[b[i]]++;
	}
	for(char i='a';i<='z';i++){
		if(visa[i]!=visb[i]){
			printf("No");
			return 0;
		}
	}
	printf("Yes");
	return 0;
}

---

## 作者：Hughpig (赞：3)

$S$ 任意划分并重排后可以得到 $T$，等价于 $S$ 中出现的字符在 $T$ 中出现的次数相同。

因此，将 $S$ 按字典序排序后的结果与 $T$ 按字典序排序后的结果相同。比较两个字符串按字典序排序后的结果是否相同即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n;string s,t;
	cin>>n>>s>>t;
	sort(s.begin(),s.end());
	sort(t.begin(),t.end());
	cout<<(s==t?"Yes":"No");
	return 0;
}
```

---

## 作者：Eason_lyx (赞：2)

:::info
这真的是一道签到题，没有高深的算法 qwq。 
:::
题目描述的很清楚，不再赘述。
## 思路
首先有一个非常容易想到的结论。
> 如果将 $S$ 划分为若干子串后以任意顺序拼接在一起使其等于 $T$，那么将每个 $S$ 的子串再分为若干子串，也一定满足要求。

这个结论告诉我们，我们只用考虑每个子串长度均为 $1$ 的情况。进而，我们使用**桶排序思想**，建立一个字符统计的两个桶，分别统计 $S,T$ 的各个字符的数量，最后比较他们是否完全相同即可。

注意：在 C++ 中，禁止使用字符 `char` 类型作为数组下标，所以使用时要强制转整型 `int`。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n;
string s,t;
int cnt1[128],cnt2[128];
int main(){
    cin>>n>>s>>t;
    for(int i=0;i<n;i++)cnt1[(int)s[i]]++,cnt2[(int)t[i]]++;
    for(int i='a';i<='z';i++){
        if(cnt1[i]!=cnt2[i]){
            cout<<"No";
            return 0;
        }
    }
    cout<<"Yes";
    return 0;
}
```

---

## 作者：monkeyking_houshan (赞：2)

这是一道非常容易的题，难度大概在红题左右。
## 思路：
我们先用 `sort`，将字符串排序（注：这是对字典序进行排序）。那字符串怎么排序呢，用 `begin()` 和 `end()`。

我先来解释一下第一个，它的作用获取容器或数组的起始迭代器，即指向第一个元素的迭代器，而第二个则是返回容器或数组末尾元素迭代，指向最后一个元素之后的位置。

~~以上内容精选自百度~~。总而言之，这两兄弟的作用就是方便我们用 `sort` 排序字符串。

那为什么我们要用排序呢，看题目。它问我们将字符串 $S$ 划分为若干子串后能否以任意顺序拼接在一起使其等于字符串 $T$。那我们将字符串一个一个的拆开再拼在一起，如果这都不行，那么我们再怎么分也无法使其相等了。同时，如果可以将 $S$ 与 $T$ 对应起来，那么，即使将 $T$ 排序一遍也不会有任何问题，以同样的方式给 $S$ 和 $T$ 排序起来，那照样可以对应起来。

然后我们再遍历这两个字符串，如果这两个字符串此时的字母对应不上，那么就无法将 $S$ 字符串转变为 $T$ 字符串。
## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
int n;
int main(){
	cin>>n>>s>>t;
	sort(s.begin(),s.end());
	sort(t.begin(),t.end());
	for(int i=0;i<n;i++){
		if(s[i]!=t[i]){
			cout<<"No";
			return 0;
		}
	}
	cout<<"Yes";
	return 0;
}
```

---

## 作者：Vector_123 (赞：2)

蒟蒻第一篇题解。

废话不多说，我们直接切入正题。[题目传送门](https://www.luogu.com.cn/problem/P13491)。

### 思路
我们完全可以将字符串 $S$ 分成 $n$ 个大小为 1 的子串，这样一来，我们就可以将字符串 $S$ 的各个字母随意组合。那么接下来就一目了然了，我们只需分别判断两个串内 a 到 z 的字母个数是否相同即可。

当然，不需要直接计数，我们可以将两个字符串内的字母全部排序。如果排序后的两个字符串相同，说明字符串 $S$ 的子串一定可以排列成 $T$。

**样例**

$n$：10。

字符串 $S$ ：`luogucomcn`

字符串 $T$ ：`cmocluognu`

字符串 $S$ 排序后：`ccglmnoouu`

字符串 $T$ 排序后：`ccglmnoouu`

两个字符串排序后相等，所以 $S$ 可以通过分解子串并排列成为 $T$。

### 代码

``````
#include<bits/stdc++.h>
using namespace std;
string a,b;
int n;
int main(){
	cin>>n>>a>>b;
	sort(a.begin(),a.end());
	sort(b.begin(),b.end());
	if(a==b) cout<<"Yes";
	else cout<<"No";
	return 0;
}
``````

---

## 作者：XXh0919 (赞：2)

我又来写题解啦！

### 解法

容易发现：当串 $S$ 分成若干子串后，将它们进行重排能够变成串 $T$ 时，$S$ 中的每个字符出现的次数等于 $T$ 中的每个字符出现的次数。所以我们可以直接记录两个串内每个字符出现的次数，然后进行比较，如果没有差异则输出 `Yes`，否则输出 `No`。

::::info[可以这样理解：]
把 $S$ 的每一个字符拆出来，把这些字符重排后能够变成 $T$，就输出 `Yes`，否则输出 `No`。
::::

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e6 + 15, INF = 1e18;
const bool Accepted = true;

int n;
string s, t;
int f[26][2];//f[i][0] 存的是 S 的字符，f[i][1] 存的是 T 的字符

int main () {
	scanf ("%d", &n);
	cin >> s >> t;
	for (int i = 0; i < n; ++ i) f[s[i] - 'a'][0] ++, f[t[i] - 'a'][1] ++;//计数
	for (int i = 0; i < 26; ++ i) {
		if (f[i][0] != f[i][1]) {//不一样的话肯定不满足
			puts ("No");
			return 0;
		}
	}
	puts ("Yes");
	return 0;
}
```

---

## 作者：alice_c (赞：1)

## 思路

只要 $S$ 和 $T$ 中的每个字符出现次数相等，那么肯定能把 $S$ 变成 $T$。我们可以设两个 `map`，`f1` 和 `f2`，统计两个字符串中每个字符出现次数，如果 `f1=f2` 输出 `Yes`，否则输出 `No`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s,t;
map<char,int> f1,f2;
int main()
{
    cin >> n >> s >> t;
    for(int i=0;i<s.size();i++)
        f1[s[i]]++;
    for(int i=0;i<t.size();i++)
        f2[t[i]]++;
    if(f1==f2) puts("Yes");
    else puts("No");
}
``````

---

## 作者：__AntennaOI__ (赞：1)

### 思路
由于子串是连续的，问题等价于检查 $ S $ 是否能通过切割和重新排列子串形成 $ T $。只需验证 $ S $ 和 $ T $ 的字符频率是否相同，因为子串拼接不改变字符总数。使用数组统计 $ S $ 和 $ T $ 中各字符的出现次数，若频率一致则输出 "Yes"，否则输出 "No"。时间复杂度 $ O(n) $。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int b, e[114514], f[114514];
string c, d;
int main() {
    cin >> b >> c >> d;;
    for (int i = 0; i < b; i++) {
        e[c[i] - 'a']++;
        f[d[i] - 'a']++;
    }
    bool g = 1;
    for (int i = 0; i < 26; i++) {
        if (e[i] != f[i]) {
            g = 0;
            break;
        }
    }
    cout << (g ? "Yes" : "No");
    return 0;
}

```

---

## 作者：pengyirui (赞：1)

本题中，因为可以**任意**拆分子串，我们考虑拆成一个个字母的形式，可以随意拼接，只要两个字符串所含各个字母的数量**完全**相同，即可拼成。     
所以，我的做法为：输入两个字符串，用桶统计字符出现次数，最后判断是否完全相等即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
int mp[27],mp2[27];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>s;
	cin>>s;
    for(int i=0;i<s.length();i++)mp[s[i]-'a']++;
    cin>>s;
    for(int i=0;i<s.length();i++)mp2[s[i]-'a']++;
    for(int i=0;i<26;i++)
    {
    	if(mp[i]!=mp2[i])
    	{
    		cout<<"No";
    		return 0;
		}
	}
	cout<<"Yes";
	return 0;
}

```

---

## 作者：xiaoke2021 (赞：1)

由于是**以任意顺序拼接**，我们容易注意到，如果两个字符串所含的字符完全相同，那么就是可行的；否则不可行。

可以将两个字符串本身按字典序排序，若排序后的两个字符串相同，则说明两个字符串所含的字符完全相同；否则不相同。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s,t;
int main(){
    cin>>n;
    cin>>s>>t;
    sort(s.begin(),s.end());
    sort(t.begin(),t.end());
    if(s==t) cout<<"Yes";
    else cout<<"No";
}
```

---

## 作者：SDJN (赞：1)

## 题意
给你一个字符串让你分成若干个子串**任意顺序**拼接成另一个字符串，可以输出 Yes 否则输出 No 就可以了。
## 思路
我们把这两个字符串按字典序排序，作比较就行了。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100005],b[100005];int n;
int main()
{
    ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    int n;
    cin>>n>>a>>b;
    sort(a,a+n);
    sort(b,b+n);
    for(int i=1;i<=n;i++)
        if(a[i]!=b[i]) {cout<<"No"<<"\n";return 0;}
    cout<<"Yes"<<"\n";
	return 0;
}
```

---

## 作者：DPOI (赞：1)

### 做法
关注到要将 $S$ 划分成任意子串，然后随意地重新排序，我们都知道，一个字母也算是一个字符串的子串，问题就变成了判断 $S$ 和 $T$ 是否满足：对于每个 $T$ 中有的字母，$S$ 中的数量相同。很明显可以用 `map` 实现。
### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
map<char,int>mp1,mp2;
int main(){
    int n;cin>>n;
    string s,t;cin>>s>>t;
    for (int i=0;i<n;++i){
        mp1[s[i]]++,mp2[t[i]]++;
    }
    for (int i=0;i<n;++i){
        if (mp1[s[i]]!=mp2[s[i]]){
            cout<<"No";
            return 0;
        }
    }
    cout<<"Yes"<<'\n';
    return 0;
}
```

---

## 作者：Natural_Selection (赞：1)

## 题解：P13491

### 思路

#### 1. 我有信仰

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<"Yes"<<endl;
    return 0;
}
```
荣获 $50$ pts。

#### 2. 100 pts

想到了一种稀奇的想法，和我 CSP-J 2024 T1 的解法相似，主要是将两个字符数组按字典序排序，然后一一比较，完全形同输出 `Yes`，否则 `No`。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
char str1[N],str2[N];
int n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n;
    cin>>str1>>str2;
    sort(str1,str1+strlen(str1));
    sort(str2,str2+strlen(str2));
    for(int i=0;i<n;i++){
        if(str1[i]==str2[i]){
            continue;
        }else{
            puts("No");
            return 0;
        }
    }
    puts("Yes");
    return 0;
}
```

---

## 作者：OIer_Tan (赞：0)

注意到如果不限制拆开的段数，把 $S$ 拆成 $\lvert S \rvert$ 个单个的字符也是合法的。

因此问题被转换为 $S$ 中每个字符出现次数是否和 $T$ 中出现次数相同，这个直接拿 `std::map` 或者是数组记一下个数就行了。

## 代码

```cpp
#include <bits/stdc++.h>

#ifndef CRT
#define endl '\n'
#endif

using namespace std ;

typedef long long ll ;
typedef unsigned long long ull ;
typedef long double ld ;

ll n ;

string s , t ;

map <char,ll> mp ;

int main ()
{
#if not defined ( CRCC ) and not defined ( ONLINE_JUDGE )
	freopen ( ".in" , "r" , stdin ) ;
	freopen ( ".out" , "w" , stdout ) ;
#endif
	ios::sync_with_stdio ( 0 ) ;
	cin.tie ( 0 ) ;
	cout.tie ( 0 ) ;
	cin >> n >> s >> t ;
	for ( auto x : s )
	{
		mp [x] ++ ;
	}
	for ( auto x : t )
	{
		mp [x] -- ;
	}
	for ( auto x : mp )
	{
		if ( x.second != 0 )
		{
			cout << "No" << endl ;
			return 0 ;
		}
	}
	cout << "Yes" << endl ;
	return 0 ;
}
```

---

## 作者：GuoMingXuants1 (赞：0)

### 思路
这道题其实并不难。

首先，子串可以是一个字符，也可以是很多个字符，那么，我们只需要分析两个字符串都划分成 $n$ 个字符数量为 $1$ 的子串时，看看是否能拼即可。

其次，判断两个字符串是否能拼，只需要分析这两个字符串中所有小写英文字母各自出现次数是否完全相同，如果是，就说明一定可以拼接，如果不是，就绝对不可以拼接。

桶思想计数即可，用前 $26$ 个桶分别记录所有小写字母出现次数。

### 代码
```cpp
#include<iostream>
using namespace std;
const int MAXN = 10e5 + 1;
char a[MAXN],b[MAXN];
int a1[27],b1[27];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        a1[(a[i]-96)]++;
    }
    for(int i=1;i<=n;i++)
    {
        cin>>b[i];
        b1[(b[i]-96)]++;
    }
    for(int i=1;i<=26;i++)
    {
        if(a1[i] != b1[i])
        {
            cout<<"No";
            return 0;
        }
    }
    cout<<"Yes";
}
```

---

## 作者：liyelei (赞：0)

注意到题目中并没有规定拆分成多少子串，于是我们可以认为将 $S$ 拆分成 $len_s$ 个子串（即拆成若干个字母），问这些子串（字母）是否可以组成 $T$。

那么，可以先统计 $S$ 中有什么字符，以及每个字符有多少个，若 $T$ 中也有这么多字母，则输出 ```Yes```，否则输出 ```No```。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s, t;
int a[26];
int main() {
	int n;
	cin >> n >> s >> t;
	for (char ch : s) {
		a[ch - 'a']++;
	}
	for (char ch : t) {
		if (a[ch - 'a'] == 0) { cout << "No"; return 0; }
		else a[ch - 'a']--;
	}
	cout << "Yes";
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P13491 题解

## 思路

我们可以把 $S$ 的每一位都划分为一个子串，那么问题就转化为把 $S$ 内的字符重排是否可以达到 $T$，又等价于 $S$ 和 $T$ 均进行重排后能否相等，所以将 $S$ 与 $T$ 排个序即可。

## 代码

```cpp
const int N=100005;

int n;
char s[N],t[N];

int main() {
    read(n),readstr(s+1),readstr(t+1);
    sort(s+1,s+1+n),sort(t+1,t+1+n);
    bool ok=true;
    _rep(i,1,n) if (s[i]!=t[i]) ok=false;
    if (ok) puts("Yes");
    else puts("No");
    return 0;
}
```

---

## 作者：Andy1101 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P13491)
# 题目大意
两个字符串 $s$ 和 $t$，判断将 $s$ 分解成若干个字串后（注意不是子序列）以任意顺序重新排列字串是否能使其变成 $t$。
# 思路
可以使用两个 map 来存储两个字符串。如果字符串 $t$ 中某一个字符的数量与字符串 $s$ 中同一字符的数量不一致，那么 $s$ 无论如何都不能变成 $t$。
# AC Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
map<char,int> ss,tt;
int main()
{
    int n;
    cin>>n;
	string s,t;
    cin >>s>>t;
    for(char c:s)
    {
        ss[c]++;
    }
    for(char c:t)
    {
        tt[c]++;
    }
    for(auto x:tt)
    {
        if(tt[x.first]>ss[x.first])
        {
            cout <<"No";
            exit(0);
        }
    }
    cout <<"Yes";
    return 0;
}
```

---

## 作者：b__b (赞：0)

我们注意到可以划分为若干子串，也就是我们可以将字符串~~细细的切做臊子~~切割成一个一个字母，最后我们就可以任意排列了。

于是我们只需要统计这两个字符串的字母组成是否相同（也就是每一个字母出现次数是否相同）即可。
```cpp
#include <cstdio>
int counts[300], countt[300];
char s[100005], t[100005];
int main() {
    int n;
    scanf("%d%*c%s%s", &n, s, t);
    for (int i = 0; i < n; ++i) ++counts[s[i]], ++countt[t[i]];
    //统计每一个小写字母（因为字符串里面只有小写字母）
    for (char c = 'a'; c <= 'z'; ++c) if (counts[c] != countt[c]) {puts("No"); return 0;}
    puts("Yes");
}
```
（下文 $W$ 表示字母表大小。）

时间复杂度：处理的复杂度为 $O(n)$，统计是的复杂度为 $O(W)$，总复杂度为 $O(n+W)$。~~不太理解为什么 $n$ 那么小。~~

空间复杂度：存储字符串需要 $O(n)$，存储每一个字母的出现次数需要 $O(W)$，总复杂度为 $O(n+W)$。

---

## 作者：lijingshu_304775 (赞：0)

## 分析

题意：要求判断能否将字符串 $S$ 分割成若干连续子串，然后通过重新排列这些子串的顺序，使其与字符串 $T$ 完全相同。两个字符串长度均为 $n$，且只包含小写英文字母。

这道题的关键在于：如果 $S$ 能通过分割重组得到 $T$，那么 $S$ 和 $T$ 必须包含完全相同的字符（包括每个字符的数量）。

因为，如果两个字符串包含的字符种类或数量不同，无论如何分割重组都不可能让它们相等，并且，如果两个字符串字符组成完全相同，我们总可以通过适当的分割方式（比如每个字符作为一个子串）来重组得到目标字符串。

因此，我们只需要检查 $S$ 和 $T$ 的字符计数是否完全一致即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int cnt[26] = {0};  // 用于计数每个字母的出现次数
int main() {
    int n;
    string s, t;
    cin >> n >> s >> t;
    // 统计S中每个字符的出现次数
    for (int i = 0; i < n; i++) cnt[s[i] - 'a']++;
    // 减去T中每个字符的出现次数
    for (int i = 0; i < n; i++) cnt[t[i] - 'a']--;
    // 检查所有字符的计数是否都为0
    for (int i = 0; i < 26; i++) {
        if (cnt[i] != 0) {
            cout << "No";
            return 0;
        }
    }
    cout << "Yes";
    return 0;
}
```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的题目。

### 前置知识

- [字符串](https://zhuanlan.zhihu.com/p/553061732)

### 思路

  考虑最坏能组合成的情况是将 $S$ 拆成一个一个字符再按顺序拼接，所以我们统计 $S$ 和 $T$ 中每种字符的数量，如果存在一个字符在两个字符串中出现次数不相等，那么无解，否则有解。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int n,vis1[30],vis2[30];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> a >> b;
	for(char i : a){
		vis1[i - 'a'] ++;
	}
	for(char i : b){
		vis2[i - 'a'] ++;
	}
	for(int i = 0;i < 26;i ++){
		if(vis1[i] != vis2[i]){
			cout << "No";
			return 0;
		}
	}
	cout << "Yes";
	return 0;
}
```

---


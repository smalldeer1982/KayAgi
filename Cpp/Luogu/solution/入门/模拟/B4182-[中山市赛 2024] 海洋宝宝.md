# [中山市赛 2024] 海洋宝宝

## 题目描述

无事可做的 Jimmy 正在观察他刚买回来的“海洋宝宝”——一种喝了水就能“生”出小宝宝的东西。他之前数过，买回来的时候一共有 $n$ 颗海洋宝宝。他发现，每隔 $1$ 小时，每颗海洋宝宝都会生出 $k$ 颗新的海洋宝宝。于是他开始好奇：凑够一万颗海洋宝宝需要等多久呢？十万颗呢？$m$ 颗呢？……

## 说明/提示

### 样例 1 解释

第 $1$ 个小时过去，Jimmy 买回来的 $1$ 颗海洋宝宝就会变成 $2$ 颗；第 $2$ 个小时过去，Jimmy 的 $2$ 颗海洋宝宝就会变成 $4$ 颗。因此 Jimmy 只需要等两个小时。

### 数据范围

对于 $100\%$ 的数据，保证 $1 \leq n, m, k \leq 10^9$。

## 样例 #1

### 输入

```
1 1 4```

### 输出

```
2```

## 样例 #2

### 输入

```
7 10 7```

### 输出

```
0```

## 样例 #3

### 输入

```
31 4 415926```

### 输出

```
6```

# 题解

## 作者：蒟蒻whker (赞：2)

循环结构，考察 while 循环的使用。

每隔 $1$ 小时每颗海洋宝宝都会生出 $k$ 颗新的海洋宝宝，也就是说，每过 $1$ 小时，海洋宝宝的数量就会变成原来的 $k+1$ 倍。    
因此，只需要一个 while 循环，每次循环时判断是否凑够了 $m$ 颗，凑够了，就输出答案，否则，就让数量就会变成原来的 $k+1$ 倍，并增加时间。

**注意：本题需要开 long long，否则会90分。**

可以结合代码理解。
```cpp
#include <bits/stdc++.h>
#define ll long long//不开 long long 见祖宗！
using namespace std;
int main() {
	ll n,k,m,ans=0;//n表示现在有几个海洋宝宝，ans表示过了几个小时
	cin>>n>>k>>m;
	while(n<m){//没到m颗，就一直循环
		n=n*(k+1);//过了一小时，数量变成了原来的k+1倍。
		ans++;//把时间计数器加1
	}
	cout<<ans;//输出最终的答案
	return 0;//The end.
}
```

---

## 作者：Aurora_春雪 (赞：2)

## 思路

模拟！

我们可以使用 $tm$ 来存储花费时间，$now$ 来存储当前时间所“生”出的海洋宝宝个数。当海洋宝宝的个数小于目标个数 $m$ 时，继续循环。

那每“生”一次，会变成多少海洋宝宝呢？题目告诉我们：

> 每隔 1 小时，每颗海洋宝宝都会生出 $k$ 颗新的海洋宝宝。

我们假设当前的海洋宝宝个数为 $now$ 个，每经过 1 小时，每个海洋宝宝都会生出 $k$ 个自己的新宝宝。

对于一个海洋宝宝来说，自己本身算一个海洋宝宝，又生出 $k$ 个海洋宝宝，那么这个海洋宝宝和它生出的新宝宝数量加在一起，就是 $1 + k$ 个啦！

那么以此类推，一个海洋宝宝和它生出的新宝宝数量加在一起是 $1 + k$ 个，而每个海洋宝宝都按照这样的方式增长，那 1 小时都海洋宝宝的总数就是原来的 `now * (k + 1)` 啦！

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k,m;
	cin>>n>>k>>m;
	int tm=0;//时间 
	long long now=n;//个数 
	while(now<m){
		now=now*(k+1);
		tm++;
	}
	cout<<tm;
	return 0;
}
```

---

## 作者：niuniudundun (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4182)

# Problem

给定 $n,m,k$，每次操作可以 $n\gets n+nk$，问至少几次使得 $n\ge m$。

# Solution

定义答案为 $ans$。

使用暴力计算，在 $m>n$ 不成立结束，每次让 $n\gets n+nk,ans\gets ans+1$。结束后输出 $ans$。

代码：

复杂度：$O(\log_{k}m)$

```cpp
#include<iostream>
using namespace std;
long long n,m,k,ans=0;
int main(){
	cin>>n>>k>>m;
	while(m>n){
		n+=n*k;
		ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：int_inf (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4182) ＆ [AC记录](https://www.luogu.com.cn/record/205031294)
# Pre
本题思路较为简单，适合刚刚入门的新手提高水平，主要考察了循环的使用。
# Solution
下面来到解题环节。首先需要注意的就是题目最下面的数据范围：
> 对于 $100\%$ 的数据，保证 $1\leq n,m,k\leq 10^{9}。$

这意味着我们需要使用**长整型**来存储变量的值。判断数据范围向来是做题过程中不可缺少的一环，希望大家养成这个好习惯。

读完题目，我们不难发现，每过去一小时，每个海绵宝宝便会成为自己的 $(k+1)$ 倍，我们需要创建一个变量 `ans` 来存储当前的小时数。鉴于本题中的循环具有条件性，个人你推荐使用 while 循环来实现。当然， for 循环同样可以实现，我将会在代码部分统一展示
# Code
###  1 . while 循环
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,ans;//注意数据范围 
int main()
{
	cin>>n>>k>>m;
	while(n<m)
	{
		n*=(k+1);
		ans++;
	}
	cout<<ans<<endl;//随手换行好习惯 
	return 0;//下次再见 
}
```
###  2 . for 循环

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,ans;//注意数据范围 
int main()
{
	cin>>n>>k>>m;
	for(int i=1;n<m;i++)
	{
		n*=(k+1);
		ans=i;
	}
	cout<<ans<<endl;//随手换行好习惯 
	return 0;//下次再见 
}
```
事已至此，不如留下赞和关注，后会有期。

---

## 作者：LINYUHENG2 (赞：2)

~~终于有可以写题解的红题了，赶紧水一波。~~

本题比较简单，纯模拟即可。

虽说简单，但还有几个坑点需要注意：

1. 因为在 $n + n \times k$ 的时候，数据会爆 `int`，所以要开 `long long`；
2. 因为是从第 $0$ 小时开始算的，所以时间的初始值应定为 $0$。  
~~因为这两点做了好久……~~

话不多说，上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    long long n,k,m;
    cin>>n>>k>>m;
    for(int i=0; ;i++){
        if(n>=m){
            cout<<i;
            return 0;
        }
        n+=n*k;
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/204685339)

---

## 作者：yedalong (赞：2)

很简单的一道题，直接暴力枚举即可。
## Solution
假设现在我们拥有 $n$ 颗海洋宝宝，那么过了一小时会有多少颗海洋宝宝呢？由于一颗海洋宝宝能够生出 $k$ 颗新的，所以 $n$ 个一共能生出 $n\times k$ 个海洋宝宝，加上原本的就是 $n+n\times k$ 颗海洋宝宝了。  

那么由于这样的增长是特别快的，所以我们可以直接枚举过去多少时间，对于当前海洋宝宝达成 $m$ 颗，就可以直接跳出循环了。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k,m,cnt;
int main(){
	cin>>n>>k>>m;
	while(++cnt){
		if(n>=m) break;
		n=n+n*k;
	}
	cout<<cnt-1;
	return 0;
}
```

---

## 作者：_luogu_huowenshuo_ (赞：1)

## 思路

### 1.判断
   如果 $n \geq m$，直接返回 $0$。
### 2.模拟
  用 `while` 循环在每小时结束时更新并增加小时数。
### 3.输出
  如果海洋宝宝数达到或超过 $m$ 时输出。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int solve(int n, int k, int m) {
    if (n >= m)
        return 0;

    int ans = 0;
    long long cnt = n;
    while (cnt < m) {
        cnt *= (1 + k);
        ans++;
    }
    return ans;
}

int main() {
    int n, k, m;
    cin >> n >> k >> m;
    cout << solve(n, k, m);
}
```

---

## 作者：yyycj (赞：1)

## 题目简述
有 $n$ 颗海洋宝宝，每小时每颗可以生出 $k$ 颗海洋宝宝，求生出 $m$ 颗海洋宝宝需要几小时。

## 主要思路
按题意模拟即可。记录一个海洋宝宝数量的变量 $cnt$，初值为 $n$，每小时 $cnt \to cnt + cnt \times k$。

注意：在 $cnt$ 变化的时候，由于 $n,k < 10^{9}$，而 $n \times k$ 达到了 $10^{18}$，所以：十年 OI 一场空，_____________________。

## AC Code
```cpp
#include<iostream>
using namespace std;

typedef long long ll;

int main() {
	int n, k, m;
	cin >> n >> k >> m;
	// ----------------------------
	ll cnt = n;
	int ans = 0;
	for (; cnt < m; ans++) cnt += cnt * k;
	// ----------------------------
	cout << ans;
	return 0;
}
```

---

## 作者：Flambler (赞：1)

# B4182 题解
### Step 0 前言 Preface
~~[博客食用更佳](https://www.luogu.com.cn/article/vezbjl0f)~~ 不得不说，自从 CSP 不让小学生参加后，洛谷上好多地区的题目啊！北京、福建、广西、广东都来了。
### Step 1 思路 Idea
这道题考察循环结构，一共 $n$ 颗海洋宝宝，每个海洋宝宝 $1$ 个小时可以生 $k$ 个新的海洋宝宝，问多少小时后数量超过 $m$。可以让 $n$ 每次循环都加上 $n\times k$， 代表新生海洋宝宝和其他的总和，并且时间 $+1$ 直到 $n\ge m$ 后结束循环并输出时间。
### Step 2 代码 Code
代码很简单就按着思路模拟就好了：
```cpp
#include<bits/stdc++.h>
#define llmax numeric_limits<long long>::max()
#define llmin numeric_limits<long long>::min()
#define imax numeric_limits<int>::max()
#define imin numeric_limits<int>::min()
#define pb push_back
#define gc getchar
#define pc putchar
#define gs gets
#define ps puts
#define nl ps("")
#define ir iterator
#define us unsigned
#define ll long long
#define chkup(ch) (ch>='A'&&ch<='Z')
#define chklow(ch) (ch>='a'&&ch<='z')
#define dis(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
using namespace std;
char* line;
template<typename _T>
_T read() {
	_T n=0;
    int neagtive=1;
	char ch=gc();
	while(ch<'0'||ch>'9') {
        if(ch=='-') {
            neagtive=-1;
        }
		ch=gc();
	}
	while(ch>='0'&&ch<='9') {
		n=(n<<3)+(n<<1)+ch-'0';
		ch=gc();
	}
    return n*neagtive;
}
template<typename _T>
void write(const _T n) {
	if(n>9) {
		write(n/10);
	}
	pc(n%10+'0');
}
//struct
//variable
//function
int main() {
	int n, k, m;
	ll sum, ans=0;
	scanf("%d%d%d", &n, &k, &m);
	sum=n;  // 这里其实完全可以用n来代替，当时脑子抽了，写了一个sum
	while(sum<m) {
		sum+=sum*k;  // 更新数量
		ans++;  // 用来记录时间
	}
	printf("%lld", ans);
	return 0;
}
```
[100 pts record](https://www.luogu.com.cn/record/204687036)

---

## 作者：__CJY__ (赞：1)

## 思路
数据好水啊，那么大的数据不开 `long long` 都能拿 $90$ 分！

当 $n<m$ 时，$n \gets n \times (k+1),s \gets s+1$，也就是根据题目进行“分裂”，累加答案。最后输出答案即可。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k,m,s;
int main(){
	cin>>n>>k>>m;
	while(n<m) n*=k+1,s++;
	cout<<s;
}
```

---

## 作者：qianyuzhe (赞：1)

## 题意简述

初始时有 $n$ 颗海洋宝宝，每过一小时每颗海洋宝宝会生出 $k$ 颗海洋宝宝，求几小时后海洋宝宝数量超过 $m$。

## 题目分析

由于每小时每个海洋宝宝都会生出 $k$ 颗海洋宝宝，故每小时海洋宝宝的数量都会变为原来的 $k+1$ 倍，依题目模拟即可，注意开 `long long`。

时间复杂度 $O(\log_{k+1}\dfrac{m}{n})$，空间复杂度 $O(1)$，代码：

```
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,i;
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>n>>k>>m;
	for(i=0;n<m;i++)n*=(k+1);//每小时变为原来的(k+1)倍 
	cout<<i;//输出小时数 
}
```

也可以用数学方法，输出 $\left\lceil\log_{k+1}\dfrac{m}{n}\right\rceil=\left\lceil\dfrac{\ln\dfrac{m}{n}}{\ln(k+1)}\right\rceil$，时间复杂度 $O(1)$，空间复杂度 $O(1)$，代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long double n,k,m;//为避免精度误差要开long double 
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>n>>k>>m;
	cout<<max((int)ceil(log(m/n)/log(k+1)-1e-20),0);//为避免精度误差减去一个极小值 
}
```

---

## 作者：tanruiqing (赞：0)

### 题目大意：

给你三个数字 $n,k,m$，$n$ 会每次增加 $n\times k$。请问 $n$ 要增加几次可以大于等于 $m$？

### 解题思路：

我们可以考虑模拟。

模拟 $n$ 的变化，相信大家可以马上想到 $n$ 每次增加 $n\times k$ 个，我们可以让一个变量 $ans$ 等于 $n$。然后在模拟时每次累加 $n\times k$ 个。当然，$n$ 也是要变化的。因为 $n$ 每次增加 $n\times k$ 个，所以到下一次时 $n$ 就变成了 $n+n\times k$。所以由此可得 $n$ 增加的数量和 $ans$ 一样，只不过是顺序罢了。最后，我们用一个变量 $Time$ 记录增加次数，最后输出这个变量的值就行了。

- 注意！如果 $n$ 一开始就大于等于 $m$，就直接输出 $0$！

### AC 代码：

[AC记录](https://www.luogu.com.cn/record/205498139)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,m,k;
int ans;
int Time;

int main(){
    cin >> n >> k >> m;
    ans = n;
    if(n >= m){
        cout << 0 << '\n';
        return 0;
    }
    while(ans < m){
        ans += n * k;
        n += n * k;
        Time++;
    }
    cout << Time;
    return 0;
}
```

做法肯定是对的，如果你想不劳而获的话，是绝对不可能的哦～

---

## 作者：SatoruXia (赞：0)

# B4182 [中山市赛 2024] 海洋宝宝

## 题目分析

本题是模拟一个类似于细胞分裂的过程。（严谨点说细胞分裂基本是二分法，但与本题无关）每次分裂除了原先已有的海洋宝宝以外，还要加上新产生的海洋宝宝。要注意**已分裂过的海洋宝宝仍然可以继续分裂**。

## 数学解法
这一过程可以用数学公式推导出来，经过 $t$ 小时后，海洋宝宝的数量为：
$$n\times(1+k)^t$$
此时题目便变成了找到最小的 $t$，使：
$$n\times(1+k)^t\geq m$$
为了解此不等式，可以对等式两边取对数：
$$\log(n \times (1 + k)^t) \geq \log(m)$$
$$\log(n) + t \times \log(1 + k) \geq \log(m)$$
$$t \times \log(1 + k) \geq \log(m) - \log(n)$$
$$t \geq \frac{\log(m) - \log(n)}{\log(1 + k)}$$
因此，$t$ 的最小整数值为：
$$t = \left\lceil \frac{\log(m) - \log(n)}{\log(1 + k)} \right\rceil$$
可模拟此公式，引用`<cmath>`中的`ceil`与`log`函数解决。代码就不给了。

## 循环解法
但这道题是道红题，且确保不会超时，能用算法做为什么不用呢？我们可以用能突出计算机特性的方法完成此题。  
分析题面，可以看出本题使用`while`循环，在未到达上限之前可一直增加。设当前海洋宝宝总数为`num`，每小时当前海洋宝宝总数变为`num+num*k`，即`num*(1+k)`，再将时间增加一。但除此之外本题还有两点要注意：  

- 分析数据范围，$1 \leq n, m, k \leq 10^9$，所以表示当前海洋宝宝总数的变量要开`long long`。
- 如样例2，在初始数量已大于目标数量时，需特判。

代码如下：

```cpp
#include<iostream>
using namespace std;
int main(){
    long long n, k, m, hours = 0;//初始总数，每小时增加数，目标达到数，所需时间
    cin >> n >> k >> m;
    long long num = n;//当前数量    
    if (num >= m) cout << '0';//特判，是否已经达到数量
    else {
        while (num < m) {//在区间内时不断增加
            num *= (1 + k);
            hours++;//按过程模拟，未达到时++
        }
        cout << hours;//输出
    }
    return 0;
}
```

---

## 作者：glass_goldfish (赞：0)

比较简单的模拟题。

如果 $n\ge m$，那么不用生，直接输出 $0$；否则，记当前的海洋宝宝数量为 $x$，$x\gets x+x\times k$（每次都会增加 $n\times k$ 个海洋宝宝，而不是变为 $k$ 倍），即为 $x\gets x\times(k+1)$。

上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int n,k,m;
signed main(){
	cin>>n>>k>>m;
	if(n>=m)cout<<"0";//不用生
	else{
		for(int i=1;;i++){
			n*=(k+1);
			if(n>=m){
				cout<<i;//完成了
				return 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：liuli688 (赞：0)

### 思路
发现海洋宝宝增长的速度非常快（第 $i$ 小时的数量为 $n(k + 1) ^ i$），因此可以直接用循环或解方程解决。考虑到 C++ $\log$ 运算的精度及实现难度，选择用循环求解。

每过一小时，海洋宝宝的数量都会变为原来的 $k + 1$ 倍。不断增加时间，直到海洋宝宝数量够 $m$ 颗，输出此时时间即可。

注意 $n \le 10 ^ 9$，因此需要使用 $64$ 位整型。
### 代码
```cpp
#include <cstdio>
using ll = long long;

ll n, k, m;
int ans = 0;

signed main()
{
    scanf("%lld%lld%lld", &n, &k, &m);
    for (; n < m; ++ans)
        n *= k + 1;
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4182 [中山市赛 2024] 海洋宝宝](https://www.luogu.com.cn/problem/B4182)
## 思路：
我们首先来分析一下题目，题目中说 Jimmy 买回来的时候一共有 $n$ 颗海洋宝宝,且每隔 $1$ 小时，每颗海洋宝宝都会生出 $k$ 颗新的海洋宝宝，加上自己，就是 $k+1$ 颗。讲得简单一点，是每隔 $1$ 小时，海洋宝宝的数量会翻倍，翻 $k+1$ 倍。

那么，我们只需要一个死循环，$n$ 每次乘上 $k+1$，直到 $n \ge m$ 为止。

[提交记录](https://www.luogu.com.cn/record/205268871)

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,cnt;
int main(){
	cin>>n>>k>>m;
	k++;
	while(1){
		if(n>=m)break;
		n*=k;
		cnt++;
	}
	cout<<cnt;
}
``````

---

## 作者：canwen (赞：0)

根据题意，当 $n < m$ 时，不断令 $n$ 加上 $n\cdot k$，即 $n \gets n + n \cdot k$，并将次数自增即可。

考虑最坏情况下 $n = 1, k = 1, m = 10^{9}$，那么最多循环 $\lceil \log_{2}{m} \rceil$ 次，可以通过此题。

注意 $n$ 可能在运算的过程中爆 `int`，注意开 `long long`，代码不放了。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
int n,k,m;

signed main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0), std::cout.tie(0);
	std::cin >> n >> k >> m;
	int ans = 0;
	while(n < m){
		n += n * k, ++ans;
	}
	std::cout<<ans;
}
```

---

## 作者：LotleTos (赞：0)

不断模拟海洋宝宝繁殖的过程，直到出现 $海洋宝宝数量\ge m$。每次繁殖要计数器 $+1$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,k,m;
	cin>>n>>k>>m;
	int sum=0;
	while(n<m){
		n+=n*k;
		sum++;
	}
	cout<<sum;
}
```

---

## 作者：sen_lin114514 (赞：0)

## B4182 [中山市赛 2024] 海洋宝宝

模拟即可。

进行 $ n $ 次循环，设起初的海洋宝宝数为 $ now $，设置一个 $ time $，每次将 $ time + 1$ 然后给当前 $ now $ 加上 $ now \times k $ 为了避免不必要的问题，建议先将设一个 $ t = now $ 。然后判断当前的 $ now $ 是否达到要求的数量，若达到结束循环，输出 $ time $ 若未达到则继续以上操作。

但有几个细节：

- 一是一开始要判断 $ n \ge m $ 若一开始就达到了要求，则直接输出 $ 0 $ ，即不需要等待就可以达到要求。

- 二是记得开 ```long long``` ！！！

AC代码：


```cpp
#include <iostream>
#define int long long

int n,k,m;

signed main()
{
	std :: cin >> n >> k >> m;
	int now = n;
	int time = 0;
	if (n >= m)
	{
		std :: cout << 0;
		return 0;
	}
	while (true)
	{
		time ++;
		//std :: cout << now << " " << time << "\n"; 
		int t = now;
		now += t * k;
		if (now >= m)
		{
			break;
		}
	}
	std :: cout << time;
}
```

---

## 作者：wanghonghui123 (赞：0)

## 思路

- 我们可以判断每次的海洋宝宝数量是否小于期望数 $m$，如果达到了，就直接输出小时数就可以了。

- 否则，每次就要把现有的加上现有海洋宝宝数量会生出的数量，表示现在的加上多出来的。

- 同时小时数也要不断更新。

注意：要开 `long long`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long n,k,m,t=0;
	cin>>n>>k>>m;
	long long cnt=n;
	while(cnt<m){
		cnt+=cnt*k;
		t++;
	}
	cout<<t;
	return 0;
} 
```

---


# [海淀区小学组 2023] 回文时间

## 题目背景

2023 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

陶陶习惯用 24 小时制来表达时间，例如 $16:45$，表示现在的时间是 $16$ 时 $45$ 分。在信息科技课上，陶陶学到了回文数，如果一个数从左往右看和从右往左看是相同的，那么就称这个数为回文数，陶陶发现有很多时间表示从左往右看和从右往左看也一样的，于是陶陶把这样的时间点定义为回文时间。例如 $14:41$ 就是一个回文时间。已知现在的时间是 $ h $ 时 $ m $ 分，陶陶请你请求出在此之后（不包含此时刻）的第一个回文时间。特别提醒：回文时间是指对于一个 24 小时制时间表示的合法字符串 $ ab:cd $，一定有 $ a = d $，$ b = c $。

## 样例 #1

### 输入

```
12:21```

### 输出

```
13:31```

## 样例 #2

### 输入

```
23:59```

### 输出

```
00:00```

# 题解

## 作者：mcturtle (赞：2)

## 思路

**警示后人：注意输入！！！**

由于状态很少，考虑枚举。

先进行死循环，分钟数不断自增 $1$。

如果分钟数超过 $59$，分钟数归零，小时数自增 $1$；

如果小时数超过 $23$，小时数归零。

如果符合回文要求，按照要求，输出 `printf("%02d:%02d", h, m)` 就行，记得跳出死循环。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int h, m;
    scanf("%d:%d",&h, &m);
    while (1)
    {
        m++;
        if (m > 59)
            h++, m = 0;
        if (h > 23)
            h = 0;
        if (h / 10 == m % 10 && h % 10 == m / 10)
            return printf("%02d:%02d", h, m), 0;
    }
}
```

---

## 作者：ikunTLE (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4191)

### 思路

可以以分钟为单位进行**枚举**。

枚举起点为 $T=(h\times60+m+1)\bmod D$，每一次向后增加 $1$ 分钟 $T\gets(T+1)\bmod D$。其中 $D$ 为常数，值为 $D=24\times60$，代表一天的分钟数量。判断回文时再将 $T$ 拆开，令 $X=\lfloor\frac{T}{60}\rfloor$，$Y=T\bmod60$，即为当前的点数。如果满足 $\lfloor\frac{X}{10}\rfloor=Y\bmod10$ 且 $X\bmod10=\lfloor\frac{Y}{10}\rfloor$，则日期 $\texttt{X:Y}$ 回文，输出即可。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int D=24*60;
int main(){
	int a=read(),b=read();
	for(int t=(a*60+b+1)%D;;t=(t+1)%D){
		int x=t/60,y=t%60;
		if(x/10==y%10&&x%10==y/10)
			return printf("%02d:%02d\n",x,y),0;
	}
	return 0;
}
```

---

## 作者：linan04007 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4191)
### 题目分析
本题就是给出一个二十四小时制的时间，让我们来计算在这个时间之后第一个回文时间。
### 解题思路
由于一天只有 $1440$ 分钟，我们完全可以从给出时间的后一分钟开始遍历，直到找到回文时间为止。
### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
bool to(int a,int c){//判断是否为回文时间
	if(a%10==c/10&&a/10==c%10){
        return true;
    }
    return false;
}
int main(void)
{
	int a,c;
	char b;
	cin>>a>>b>>c;//输入。注意中间的冒号
	for(;;){//死循环，遍历每一分钟，直到找到回文时间
        c++;//过了一分钟
        if(c==60){//当分钟数达到 60 ，小时数加一，分钟清零
            c=0;
            a++;
        }
        if(a==24){//如果到 24 点，就变成 0 点
            a=0;
        }
        if(to(a,c)){//当是回文时间时就输出结束程序
            cout<<setw(2)<<setfill('0')<<a<<":"<<setw(2)<<setfill('0')<<c;//输出时要注意，如果分钟或小时数是个位数，要在前补 0 
            return 0;
        }
    }
	return 0;
}
```

---

## 作者：dg114514 (赞：1)

由于一共只有 $24\times 60=1440$ 个状态，可以直接枚举每个时刻。（即分一直加，如果超过 $59$ 分则归零。时同理）判断极为简单，只用看 $h$ 反转后与 $m$ 是否相同即可。\
注意事项：

- 注意输入带 `:`。
- 注意输出要用 `0` 补位。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int a,b;
	scanf("%d:%d",&a,&b);//格式化输入，忽略冒号
	while(1){//只要没找到一直往前
		b++;//分钟加
		if(b>59)b=0,a++;//超过 59 分时，小时 +1
		if(a>23)a=0;//超过 23 时时，变回 0 时
		if(a%10==b/10&&a/10==b%10)//a 的个位 = b 的十位且 b 的个位 = a 的十位 
			printf("%02d:%02d",a,b),exit(0);//0 补位输出 2 位整数
	}
    return 0;
}
```

---

## 作者：TheTrash (赞：1)

### 思路

输入当前时间，枚举之后的每个时间，判断是否是回文时间即可。要注意当前时间不能是答案，还要注意表达格式为 ```HH:MM```，所以当 $h$ 和 $m$ 小于 $10$ 时要加上前导零。

### 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int x,y;
int main(){
	scanf("%d:%d",&x,&y);
	y++;//从x时y分之后开始枚举
	for(;;x++){
		for(;;y++){
			if(y>59) y-=60,x++;
			if(x>23) x-=24;//处理进位
			string s,t;
			if(x>9) s=to_string(x);
			else s="0"+to_string(x);//加前导零
			if(y>9) t=to_string(y);
			else t="0"+to_string(y);
			if(s[0]==t[1]&&s[1]==t[0]){//判断是否满足条件
				cout<<s<<":"<<t;
				return 0;
			}
		}
	}
}
```

---

## 作者：Sliarae (赞：1)

注意到时间的数量其实很少。比如我们先枚举时，在枚举分，那就是 $24 \times 60$ 种，完全可以接受。

所以直接考虑暴力做法：从当前时间开始往后推，每次检查这个时间是不是回文的，是的话就输出并结束程序。

一些实现细节：

- 我们需要模拟每次时间流逝 $1$ 分钟的过程。比如 `11:00` 会变成 `11:01`，而 `23:59` 会变成 `00:00`。发现它相当于一个混合进制数（第一位为 $24$ 进制，第二位为 $60$ 进制），我们可以用模运算较为简单的实现。

- 还要解决给一个时间，判它是不是回文。这里假设一个时间是 `x:y`，其中 $x, y$ 都是数字，但可能不止一位，我们要把它变成 `ab:cd` 的形式，其中 $a, b, c, d$ 都是一位数字，这样可以直接用 $a = d, b = c$ 检验回文。在代码中可以用 `a = x / 10, b = x % 10, c = y / 10, d = y % 10` 实现。

```cpp
#include <iostream>

using namespace std;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	int x, y;
	char s;
	cin >> x >> s >> y;
	while (true) {
		if (y == 59) y = 0, x = (x + 1) % 24;
		else y = (y + 1) % 60;
		int a = x / 10, b = x % 10, c = y / 10, d = y % 10;
		if (a == d && b == c) 
			return cout << a << b << ':' << c << d << '\n', 0;
	}
}
```

---

## 作者：Lyx8058 (赞：1)

## 前言：
看来没有人跟我一样的思路，那我就发一道题解吧。

提示：本思路可能不是最优解，若只是想 A 此题请自动跳过。
## 算法：
分支、简单数学。

## 思路：
由于回文的基本性质，我们可以这样进行作答：

- 依次枚举十位数位上为 $0$、$1$、$2$ 的数，然后分类讨论：

- 我们可以先将小时的两位数进行回文处理，如果该数大于六十则自动跳过：

- 然后，如果该回文数小于等于分钟，则将小时 $+1$，重复第二、三步骤。

整体就是这样了，具体实现请各位看超长代码：

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
char c[5];
int x,y,x_map,y_map;
signed main(){
	for(int i=0;i<5;i++){
		cin>>c[i];
	}
	x=(c[0]-'0')*10+(c[1]-'0');
	y=(c[3]-'0')*10+(c[4]-'0');
	x_map=x/10+x%10*10;
	if(x<10){
		if(x>=0&&x<6){
			if(x_map>y) cout<<"0"<<x<<":"<<x_map<<"\n";
			else cout<<"0"<<x+1<<":"<<x+1<<"0\n";
		}
		else if(x==6){
			if(y<60) cout<<"06:60\n";
			else cout<<"10:01\n";
		}
		else cout<<"10:01\n";
	}
	else if(x>=10&&x<=19){
		if(x>=10&&x<=14){
			if(x_map>y) cout<<x<<":"<<x_map<<"\n";
			else cout<<x+1<<":"<<(x+1)%10*10+(x+1)/10<<"\n";
		}
		else if(x==15){
			if(y<51) cout<<"15:51\n";
			else cout<<"20:02\n";
		}
	}
	else{
		if(x==23){
			if(y<32) cout<<"23:32\n";
			else cout<<"00:00\n";
		}
		else{
			if(y<x_map) cout<<x<<":"<<x_map<<"\n";
			else cout<<x+1<<":"<<(x+1)%10*10+(x+1)/10<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：Chengqijun2012 (赞：1)

这道题目很简单，暴力枚举即可。不要说什么超时，一天就24小时，我们设 $T=24\times60$ ，也就是一天的总分钟数，最坏时间复杂度只有 $O(T)$ 。~~（能超我吃）~~

但是这题要处理一下进位，第一位是 $24$ 归 $0$ ，第二位是 $60$ 归 $0$ ，用模运算即可轻松实现。

代码跟其他题解的都大差不差，也是直接 ```while(true) ``` 枚举，大家看看就行。

```cpp
#include <iostream>
using namespace std;
int H, W;
char s;

int main () {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> H >> s >> W;
	while(true){
		if(W == 59) W = 0, H = (H + 1) % 24;
		else W = (W + 1) % 60;
		int a = H / 10, b = H % 10, c = W / 10, d = W % 10;
		if(a == d && b == c){
			cout << a << b << ':' << c << d << "\n";
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：yyycj (赞：0)

## 题目简述
求给定的以二十四小时计时法的时间的不含此时间的下一个回文时间。

## 主要思路
由于一天只有 $60 \times 24 = 1440$ 分钟，所以可以直接枚举时间。注意读入的时候有 `:` 可以用 `scanf("%d:%d", &h, &m)`，输出的时候不够 $2$ 位要添 $0$，可以用 `printf("%.02d:%.02d", h, m)`。

## AC Code
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;

int main() {
	int h, m;
	scanf("%d:%d", &h, &m);
	// ----------------------------
	do {
		m++;
        // 判断进位
		if (m >= 60) {
			h++;
			m = 0;
		}
		if (h >= 24) h = 0;
	}
	while (!(h % 10 == m / 10 && h / 10 == m % 10));  // 由于每个时间只有 4 位，此处的判断条件就是小时的个位等于分钟的十位，并且小时的十位等于分钟的个位
	// ----------------------------
	printf("%.02d:%.02d", h, m);
	return 0;
}
```

---

## 作者：jnxx_zhuyueqi (赞：0)

**先警示一下后人：注意输入！这一点被卡了很久**

## 思路
首先先分析这道题，让我们输出给定时间的下一个回文时间，那么就考虑暴力枚举，因为数据量很小。

## 解法
我们考虑进行枚举，搞一个循环，让分钟每次都加 $1$，如果分钟数到达了 $60$，就把分钟数归零，同时小时数加一。

注意这到题目的时间是循环的，即小时数如果超过了 $23$ 也要归零。最后每次都检查一下，是否为回文时间。如果找到了答案就输出结果并跳出循环。

因为回文时间就是小时数的十位与分钟数的个位相等，小时数的个位与分钟数的十位相等，就可以用 C++ 的整除来处理十位，取模运算处理个位。

## 输入与输出
强调一下：**注意输入，注意输入，注意输入！输入里有个冒号！** 我们可以用`scanf`来输入这个冒号，或者使用一个`char`来输入都是可以的。

输出这里可能需要补零，如果使用`if`来进行判断会使代码量增加许多，~~这就导致我懒得写而换一道题目做~~，那怎么办呢？我们可以用万能的`printf`，占位符使用`%0nd`就可以使输出不足 $n$ 位的就往前面补零，这样就很好的解决了这个问题。

## 代码
没什么好说的，看注释。

```cpp
#include<bits/stdc++.h>    //万能头 
using namespace std;
int h,m;    //用来输入小时和分钟 
bool check(int h,int m){    //check函数用来检查当前时间是否为回文时间 
	if(h/10==m%10&&h%10==m/10) return 1;
	else return 0;
}
int main(){
	scanf("%d:%d",&h,&m);    //在%d占位符中间加上:可以避免读入的时候把冒号读到数字里 
	while(1){    //开始枚举 
		m++;    //分钟加1 
		if(m==60) m=0,h++;    //判断分钟数是否超过60，增加小时数 
		if(h==24) h=0;    //判断小时数是否超过24 
		if(check(h,m)){    //检查是否满足要求 
			printf("%02d:%02d",h,m);    //如果是，就输出答案 
			break;    //然后跳出循环 
		}
	}
	return 0;    //好习惯，在考场时千万不能不写，防止出现意外 
}
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4191 [2023 海淀区小学组] 回文时间](https://www.luogu.com.cn/problem/B4191)
## 思路：
题目要我们求的是在 $h$ 时 $m$ 分后的第一个回文时间，那么只要跑循环死模拟即可。

变量 $m$ 表示分钟，$h$ 表示小时。每次循环让 $m$ 加上一，若超过六十分钟，清零，$h$ 加一，若 $h$ 超过二十四小时，清零。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int h,m;
int main(){
    scanf("%d:%d",&h,&m);
    while(1){
    	m++;
    	h+=m/60;
        m%=60;
		if(h==24)h=0;
		if(h/10==m%10&&h%10==m/10){
			printf("%02d:%02d",h,m);
			break;
		}
	}
}
``````

---

## 作者：LotleTos (赞：0)

用一个字符串表示一个时间。用 `reverse` 函数反转字符串,判断是否与原串相同，如果相同，这个时间就是回文的。

从输入的时间开始，往后枚举每个时间：分的个位加 $1$，再进位。判断这个时间是否回文，如果是，就输出，然后结束。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool huiwen(string a){
	string b=a;
	reverse(a.begin(),a.end());
	return a==b;
}
int main(){
	string a;
	cin>>a;
	while(1){
		a[4]++;
		if(a[4]>'9'){
			a[4]='0';
			a[3]++;
			if(a[3]=='6'){
				a[3]='0';
				a[1]++;
				if(a[1]>'9'){
					a[0]++;
					a[1]=0;
				}
				if(a[0]=='2'&&a[1]=='4'){
					a[0]=a[1]=a[3]=a[4]='0';
				}
			}
		}
		if(huiwen(a)){
			cout<<a<<endl;
			return 0;
		}
	}
}

```

---

## 作者：DashZhanghanxu (赞：0)

# 解析
看见题解区没人写奥数写法，我来一篇。

学过小学数学的都知道，一个二位数与这个二位数个位与十位相反的数之和一定是十一的倍数，差一定是九的倍数，那么我们就用这个性质解题。只需要循环模拟分钟数增加，当这两数之和是十一的倍数，差是九的倍数且两数不相等（为零时特判），结束循环（先进行操作再判断，防止输入时就是回文数），并输出。

最后提醒一下，要判断小时数或分钟数是个位数，补零。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int long long
int a,b;
char fw;
signed main(){
    cin>>a>>fw>>b;
    do{
    	b++;
    	a+=b/60;
    	b%=60;
    	a%=24;
	}
    while(!((a+b)%11==0&&(a-b)%9==0&&((a-b)!=0||(a==b&&a==0))));
    cout<<setfill('0')<<setw(2)<<a<<":"<<setfill('0')<<setw(2)<<b<<"\n"; 
    return 0;
}

```

---

## 作者：tanruiqing (赞：0)

最近学图论把脑袋 CPU 干烧了，所以就来刷一刷红题。最后发现了这一道题。

### 解题思路：

考虑模拟。

模拟时间的变化，只用将模拟分钟的变量每次加一就行了。注意跨天、进位就可以 AC 了。

### AC 代码：

[AC 记录](https://www.luogu.com.cn/record/205811141)。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int a,b,c,d;

signed main(){
    scanf("%lld:%lld",&a,&b);//读入两个数字，中间用:号隔开。
    while(true){//因为这里不知道要到什么时候结束（也不是说非得while(true)），所以开一个死循环。
        a = (a + ((b + 1) / 60)) % 24;//计算公式，就相当于先加上分钟要进到小时的时间，然后再让小时不越界。
        b = (b + 1) % 60;//分钟就直接加一就行了（也要注意越界问题）。
        if((a % 10) * 10 + a / 10 == b){//如果小时倒过来就是分钟。
            if(a >= 10)printf("%lld",a);//输出，这里是a前面不用加前导零的情况。
            else printf("0%lld",a);//这里是a前面要加前导零的情况。
            printf(":");//再输出一个:，用来隔开小时和分钟。
            if(b >= 10)printf("%lld",b);//同上。
            else printf("0%lld",b);
            return 0;//最后直接结束程序就行了。
        }
    }
    return 0;
}
```

---

## 作者：LINYUHENG2 (赞：0)

### 思路
可以让时间递增下去，如果遇到回文时间，就输出，结束程序。
### 实现
先定义两个变量 $h$ 和 $m$，存储当前时间的小时和分钟。用 `scanf()` 输入，可以直接提取输入中的数字。

然后写一个死循环，`while(1)` 或者 `for(;;)` 都行。

在循环中，不断递增时间，代码如下：
```cpp
m++;
if(m==60){
    h++;
    m=0;
}
if(h==24){
	h=0;
}
```
接着判断是否属于回文时间，判断方法是：如果 $h$ 的十位等于 $m$ 的个位且 $h$ 的个位等于 $m$ 的十位，那么就是回文时间。用 `printf()` 输出并跳出循环。代码如下：
```cpp
if(h/10==m%10&&h%10==m/10){
	printf("%02d:%02d",h,m);
	break;
}
```
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int h,m;
    scanf("%d:%d",&h,&m);
    while(1){
    	m++;
    	if(m==60){
    		h++;
    		m=0;
		}
		if(h==24){
			h=0;
		}
		if(h/10==m%10&&h%10==m/10){
			printf("%02d:%02d",h,m);
			break;
		}
	}
    return 0;
}
```

---


# 开灯

## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？


## 说明/提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。

## 样例 #1

### 输入

```
3
1.618034 13
2.618034 7
1.000000 21```

### 输出

```
20```

# 题解

## 作者：2011hym (赞：10)

[更好的阅读体验。](https://blog.csdn.net/Hymmeishili/article/details/148501901?sharetype=blogdetail&sharerId=148501901&sharerefer=PC&sharesource=Hymmeishili&spm=1011.2480.3001.8118)

## 题目分析

给定一个无限长的序列，初始时所有灯都是关闭状态。进行 $n$ 次操作，每次操作给定 $a$ 和 $t$，将编号为$\left \lfloor a \right \rfloor,\left \lfloor 2\times a \right \rfloor, \dots ,\left \lfloor t\times a \right \rfloor$ 的灯的状态切换。经过所有操作后，只有一盏灯是开着的，我们需要找出这盏灯的编号。

## 解题思路

每次操作实际上是转换灯的状态。我们可以用一个数组来记录每个灯被切换的次数。

初始时所有灯的状态为 $0$。对于每次操作，计算 $\left \lfloor i\times a \right \rfloor$（$i$ 是从 $1$ 到 $t$），并将对应位置的数异或 $1$（根据异或的性质可知，这其实就是状态转换）。

代码时间复杂度为 $O(n\times t)$，包能过的。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2000001;
int light[MAXN];//状态表示。
int n, t;
double a;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a >> t;
        for (int j = 1; j <= t; j++) {
            int index = (int)(j * a);
            light[index] ^= 1;//切换状态。
        }
    }
    //找出唯一亮着的灯。
    for (int i = 2; i <= MAXN; i++) {
        if (light[i] == 1) {
            cout << i << endl;
            break;
        }
    }
    
    return 0;
}
```

**update：** 2025.7.24 修复了一处错误。

---

## 作者：_hud (赞：6)

# 题解：[P1161 开灯](https://luogu.com.cn/problem/P1161)

## 思路

注意到数据量不大，故按照题意模拟即可。

这里给出两种模拟方式：

1. 开一个数组记录每一盏灯的状态。每次操作时，将对应灯的状态取反。最后遍历数组，将开着的灯输出即可。
2. 开一个数组，统计每一盏灯被操作的次数。最后遍历数组，如果该灯被操作的次数为奇数，由于初始状态为关，则此时该灯的状态为开。输出其编号即可。

那么思路就分析完了。两种模拟方式的实现可以参考代码。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2000001
bool f[N]; // 第二种：int f[N];
#define sw(x) ((x) = (x) ? 0 : 1)
signed main() {
    cin.tie(0), cout.tie(0) -> sync_with_stdio(0);
    int n; cin >> n;
    while(n--) {
        double a; int t; cin >> a >> t;
        for(int i = 1; i <= t; ++i)
            sw(f[(int)(a * i)]); // 第二种：++f[(int)(a * i)];
    }
    for(int i = 1; i < N; ++i)
        if(f[i]) // 第二种：if(f[i] & 1)
        { cout << i; return 0; }
    return 0;
}
```

---

## 作者：ZYX0716 (赞：4)

[tyj.ac](https://www.luogu.com.cn/problem/P1161)

## 题面分析：

有无限盏灯排成一行，每次将 $t[i]$ 盏灯的开关按下。问 $n$ 次操作后**唯一开着**的灯的编号。

由于数据范围不大，因此对于每次操作可以直接**模拟**被改变状态的灯，开则关，关则开。最后，从 $1$ 开始依次遍历，直至找到**第一盏开着的灯**为止并输出。

## 样例解释：

第一次操作将：$1,3,4,6,8,9,11,12,14,16,17,19,21$ 号灯状态改变。

第二次操作将：$2,5,7,10,13,15,18$ 号灯状态改变。

第三次操作将：$1,2,3,4,5,6,7,8,\cdots,19,20,21$ 号灯状态改变。

由此得出，离小明最近的一盏亮着的灯的编号为 $20$。

## AC CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s[2000005];
double a,t;
int main(){
    cin>>n;
	for(int i=1;i<=n;i++){
    	cin>>a>>t;//改变t盏灯的状态。
    	for(int j=1;j<=t;++j){
    		s[int(j*a)]=(s[int(j*a)]+1)%2;//更新为按下开关后的状态。
		}
	}for(int i=1;i<=2000000;i++){
    	if(s[i]){
    		cout<<i;//最近的一个亮着的灯。
    		return 0;
		}
	}
    return 0;//好习惯！
}
```
有疑问私信沟通哦！

---

## 作者：xuyixuan_123 (赞：3)

## 思路：
由于最终只有一盏灯是开的，这意味着这盏灯被按了奇数次，而其他所有灯都被按了偶数次。

这里可以利用异或运算的特性：
> - 任何数与 $0$ 异或结果是它本身。
> - 任何数与自身异或结果是 $0$。

因此，我们可以将每次操作涉及的灯的编号进行异或运算，最终得到的结果就是唯一开着的灯的编号。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,ans,x;
double a;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a>>t;
        for(int i=1;i<=t;i++){
			x=(int)floor(a*i);//a*i为当前灯的编号
			ans^=x;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_WorldHello_ (赞：2)

## 题目大意
给定 $n$ 组数，对于第 $i$ 组数，含有两个数 $a_{i},t_{i}$。  
对于第 $i$ 次操作中的  $j$ 次操作，将位于 $ \lfloor a_{j} \times i \rfloor$ 的开关摁一下。  
求最后一盏亮着灯的位置。 
## 解决思路
考虑枚举。  
 - 定义一个数组 $cnt$ 表示当前灯是否开着。  
 - 按题目意思模拟即可。
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t[5005];
double a[5005];
int cnt[2000005];
int main(){
	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    //ios::sync_with_stdio(0);
    //cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i]>>t[i];
    //输入
    for(int i=1;i<=n;i++){
        for(int j=1;j<=t[i];j++){
            int k=a[i]*j;
            cnt[k]=(cnt[k]+1)%2; 
    }}//模拟开灯关灯
    for(int i=1;;i++)
        if(cnt[i]==1)
            cout<<i,exit(0);
    //找出剩余亮着的一盏灯并输出
    cout<<"Wow!I AK IOI!"<<endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

用一个数组存储灯的状态，按题意模拟即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int b[3000005]={};//0表示关，1表示开 
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		double a;
		int t;
		cin>>a>>t;
		for(int j=1;j<=t;j++){
			if(b[int(a*(j*1.0))]==0)
				b[int(a*(j*1.0))]=1;
			else if(b[int(a*(j*1.0))]==1)
				b[int(a*(j*1.0))]=0;
		}
	}
	for(int i=1;;i++){
		if(b[i]==1){//找到就输出
			cout<<i;
			return 0;
		}
	}
}
```

---

## 作者：Peruere_Arlecchino (赞：1)

本题通过模拟就可以 $AC$，用数组记录次数后遍历找到唯一奇数下标就好。代码中先直接读取每次操作的实数 $a$ 和次数 $t$，再累加 $a$ 计算每次操作影响的路灯编号并更新计数，最后遍历数组找出计数为奇数的灯编号，就直接 [$AC！$](https://www.luogu.com.cn/record/219661587)
### code：
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<int> a(2000002, 0); // 直接初始化足够大的数组!
    for (int i = 0; i < n; ++i) {
        double a;
        int t;
        cin >> a >> t;
        
        double c = 0.0;
        for (int k = 1; k <= t; ++k) {
            c += a;
            ++a[static_cast<int>(c)];
        }
    }
    for (int i = 1; i <= 2000000; ++i) {
        if (a[i] % 2 == 1) {
            cout << i << endl;
            return 0;
        }
    }
    
    return 0;
}
```
求赞求过。

---

## 作者：JiaKaiZhang (赞：1)

# 程序代码

```cpp
// P1161 开灯

#include<iostream>
#include<cmath>

using namespace std;

int main() {
    bool lights[2000001] = {0};

    int n;
    cin >> n;

    for (int i = 0; i < n; i++) {
        double a;
        cin >> a;
        
        int t;
        cin >> t;

        for (int j = 1; j <= t; j++) {
            lights[(int) floor(a * j)] = !lights[(int) floor(a * j)];
        }
    }

    for (int i = 1; i <= 2000000; i++) {
        if (lights[i] == true) {
            cout << i << endl;
            return 0;
        }
    }
}
```
# 解释
根据题目要求，所有可能被操作的灯的编号就是 $a_i \times t_i$ 的最大值，编号从 $1$ 开始。所以用大小为 $2000001$ 的数组表示所有的灯，初始设置为关。

每输入一个 $a$ 的值和一个 $t$ 的值，就用 $1$ 到 $t$ 的所有整数乘 $a$，并改变向下取整后对应灯的开关状态。要将 `floor()` 的返回值转换为 `int` 类型。

最后用循环检测数组中开着的灯，并将编号输出。

---

## 作者：fjtMESSI10 (赞：1)

## 思路
这题我们可以先定义一个数组来标记状态，初始值都是 $0$,然后对于每组数据，计算 $j\times b$ 的下取整值，并将对应位置的数组的值取反，最后遍历标记数组，找到第一个值为 $1$ 的位置并输出就行了。
## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
bool f[10000005];
int n;
signed main() {
	cin>>n;
	for(int i=0;i<n;i++){
		int a;
		double b;
		cin>>b>>a;
		for(int j=1;j<=a;j++){
			if(f[(int)floor(j*b)]==1){
				f[(int)floor(j*b)]=0;
			}
			else{
				f[(int)floor(j*b)]=1;
			}
		}
	}
	for(int i=1;;i++){
		if(f[i]==1){
			cout<<i;
			return 0;
		}
	}
}
```

---

## 作者：Ashankamiko (赞：1)

# 题目简述
### 题意
有一个无限长的序列，进行 $n$ 次操作，每次操作对 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 进行取反，问最后的哪一个地方是开着灯的。
### 思路
设整个序列为 $flag$，对于 $n$ 次询问，我们只需要进行模拟即可。

取反时，下标可以按照以下方法获取。
- 用 `floor()` 函数（不推荐），表示向下取整，不过返回值仍然为 `double`，下标只能是正整数，所以还需要再转换，故不推荐采用 `floor()`。
- 直接用 `int()` 转换（推荐），因为编译器在转换为 `int` 类型的时候，就会直接忽略小数，相当于向下取整，并且是整数类型，无需再进行转换，符合题意，并且便于理解、直观、不易错。

时间复杂度为 $O(n \times t)$。
## [AC 代码](https://www.luogu.com.cn/record/218950844)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
const int N = 1e6 + 5;
bool flag[N]; //序列，由于只存在0和1，所以用bool节省空间

int main() {
	int n;
	in >> n;
	while (n--) { //n次询问
		double a;
		int t;
		in >> a >> t;
		for (int i = 1; i <= t; i++) //模拟
			flag[int(i * a)] = !flag[int(i * a)]; //取反
	}
	for (int i = 0; i < N; i++) //遍历flag序列
		if (flag[i]) { //如果flag[i]是true值，相当于当前状态为开灯
			out << i; //输出答案
			return 0; //结束
		}
}
```

---


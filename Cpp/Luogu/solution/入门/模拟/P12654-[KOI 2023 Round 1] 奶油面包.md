# [KOI 2023 Round 1] 奶油面包

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 面包店出售夹有奶油的面包。KOI 面包店总共制作了 $N \times K$ 个面包。KOI 面包店会将排成一行的面包从前往后，每 $K$ 个为一组打包销售。也就是说，总共有 $N$ 个面包组。

但由于制作过于匆忙，部分面包中未夹入奶油。如果某一组中没有奶油的面包数量大于等于 $P$，那么这一组面包就无法销售。换句话说，面包组中没有奶油的面包数量必须小于 $P$，才能出售。

现在给出每个面包是否含有奶油的信息，请输出可以销售的面包组的数量。

## 说明/提示

**样例 1 说明**

总共有 $2 \times 3 = 6$ 个面包，按顺序每 3 个一组，总共分成 2 组。第一组是 1 1 0，其中不含奶油的面包有 1 个，少于 $P = 2$，可以销售。第二组是 1 0 0，其中不含奶油的面包有 2 个，不少于 $P = 2$，因此不能销售。因此总共可以销售 1 组面包。

**样例 2 说明**

总共有 $3 \times 2 = 6$ 个面包，按顺序每 2 个一组，总共分成 3 组。第一组和第三组中不含奶油的面包数量为 0，可以销售。第二组中不含奶油的面包有 2 个，因此不能销售。所以总共可以销售 2 组面包。

**限制条件**

- 所有给定数值均为整数。
- $1 \leq N \leq 50$
- $1 \leq K \leq 50$
- $1 \leq P \leq K$

**子问题**

1. （5 分）$N = 1$
2. （5 分）$K = 1$
3. （5 分）所有面包要么都含有奶油，要么都不含奶油。
4. （10 分）同一组中的面包要么全部含有奶油，要么全部不含奶油。
5. （10 分）$P = 1$
6. （65 分）无额外限制。

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2 3 2
1 1 0 1 0 0```

### 输出

```
1```

## 样例 #2

### 输入

```
3 2 1
1 1 0 0 1 1```

### 输出

```
2```

# 题解

## 作者：Ghosty_Neutrino (赞：4)

## 题意
面包店有 $N \times K$ 个面包，每 $K$ 个为一组，也就是有 $N$ 组面包。每个面包组由连续的 $K$ 个面包组成，若某组中不含奶油的面包数量少于 $P$，则该组可销售。$0$ 表示该面包不含奶油，$1$ 表示该面包含有奶油。我们需要统计符合条件的组数。
## 分析
数据范围不大，来个嵌套循环就可以过。首先分组遍历，将 $N \times K$ 个面包按从左到右的顺序每 $K$ 个为一组。然后遍历每个面包组，统计每个面包组中 $0$ 的数量。若某组中 $0$ 的数量小于 $P$，则该组可销售。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,p,k,a[2510];
int main(){
    scanf("%d%d%d",&n,&k,&p);
    for(int i=0;i<n*k;i++) scanf("%d",&a[i]);
    int cnt=0;
    for(int i=0;i<n;i++){
        int sum=0; 
        for(int j=0;j<k;j++){
            if(a[i*k+j]==0) sum++;
        }
        if(sum<p) cnt++;
    }
    printf("%d",cnt);
    return 0;
}
```

---

## 作者：ycy1124 (赞：4)

### 题意
有 $n$ 组面包，每组面包中有 $k$ 个面包。现在会给出每个面包是否含有奶油，如果一组中不含奶油的面包的数量大于等于 $p$ 个就不可以售出。试问最多能售出多少组面包。
### 思路
我们一组一组来考虑。对于每一组面包，我们需要求出有多少个面包不含有奶油，我们也可以记录有多少个面包含有奶油然后拿 $k$ 减去这个值就是不含奶油的面包的数量。于是我们边输入边记录每一组中含有奶油的面包的个数，我们假设他为 $sum$，那么如果这一组的 $k-sum<p$ 就代表这一组可以售出，我们就将答案加一。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p,sum,ans;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k>>p;
	for(int i=1;i<=n;i++){
		sum=0;//每一组先将记录的个数清0
		for(int j=1;j<=k;j++){
			int qwq;
			cin>>qwq;
			sum+=qwq;//如果他为1就代表这个面包含奶油，就加上1
		}
		if(k-sum<p){//判断
			ans++;//答案加1
		}
	}
	cout<<ans;//输出
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/218960729)。

---

## 作者：ryf2011 (赞：1)

# 1.题目思路
直接根据题意模拟即可。

需要注意一个问题：判断 $0$ 的个数是注意一定是**小于** $P$ 而不是小于等于 $P$ 才能满足条件！

# 2.简单的小技巧
这里提供一下作者简陋的判断一组面包遍历完成的方法。

用变量 $i$ 遍历。

当 $i$ 是 $3$ 的倍数时，说明一组已经判断完成，直接判断计数变量是否满足条件，随后将计数变量清零。

# 3.代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int max_n=50*50+5;
int b[max_n],n,k,p,cntnone,ans; //cntnone:0的个数；ans:答案
int main(){
    scanf("%d %d %d",&n,&k,&p);
    for(int i=1;i<=n*k;i++){
        scanf("%d",&b[i]);
        if(b[i]==0){
            cntnone++; //满足条件，计数+1
        }
        if(i%k==0){
            if(cntnone<p){ //满足条件，答案+1
                ans++;
            }
            cntnone=0; //注意清零
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

#### 后记
更多内容，请移步至：

1. [$\color{red}\texttt{Luogu ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")；
2. [$\color{orange}\texttt{cnblogs（博客园） cnblogs2011ryf}$](https://www.cnblogs.com/cnblogs2011ryf)。

---

## 作者：AFO_Lzx (赞：1)

我太菜了红题挂了 $3$ 发。

按照题意模拟即可。我们用一个计数器记录没有奶油的面包数量，每 $k$ 个就是一组，那么每一组检查一下计数器 $s$ 是否小于 $p$，如果是就将答案 $+1$，并且将计数器清空。

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int n, k, p, ans = 0;
	cin >> n >> k >> p;
	
	int s = 0;
	for (int i = 1; i <= n; i++) {
		int x; 
		cin >> x;
		s += x;
		if (i % k == 0) {
			if (s >= k) ans++;
			s = 0;
		}
	}
	
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：ouxiyao (赞：0)

[传送门](https://www.luogu.com.cn/problem/P12654)
# P12654 [KOI 2023 Round 1] 奶油面包

我首先要强调：不要被样例迷惑了，第二行看似是一排数，其实是没换行的矩阵！       
比如：

```
2 3 2
1 1 0 1 0 0
```
其实是：

```
2 3 2
1 1 0
1 0 0
```
那就解决一半了。整个 `sum`，统计每一组没加奶油的面包，最后判断并累加计数器就完事了！   
完整代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cout.tie(0);
	int cnt = 0,sum,x,n,k,p;//如文中所说
	cin>>n>>k>>p;
	for(int i = 1;i<=n;i++){//当成矩阵输入
		sum = 0;//清空，千万记得！
		for(int j = 1;j<=k;j++){//当成矩阵输入
			cin>>x;
			sum+=(!x);//统计没加奶油的
		}
		cnt+=int(sum<p);//判断，等价于if(sum<p)cnt++;
	}
	cout<<cnt;
	return 0;
}

```

---


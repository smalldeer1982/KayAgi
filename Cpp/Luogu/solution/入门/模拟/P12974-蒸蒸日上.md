# 蒸蒸日上

## 题目背景

Source：TYCPC 4th，Check：xjking。

[オーバーライド
](https://music.163.com/song?id=2105374808&uct2=U2FsdGVkX18PX/5u8EoipDWYOwGy7fBJZ0o/tdcVZGw=)

## 题目描述

三国杀是一款蒸蒸日上的游戏，其中关于距离的设定比较有趣。

有 $n$ 个玩家围成一圈玩三国杀，从某个位置开始顺时针依次标号从 $1$ 到 $n$ 的位次。

定义位置距离为两个玩家之间**顺时针或逆时针**相隔的人数最小值**加上** $1$。

定义实际距离为位置距离的修正，具体的：

1. 当其中一位玩家装备了 `+1` 坐骑，**其他玩家对他**计算实际距离时变为位置距离加上 $1$。

2. 当其中一位玩家装备了 `-1` 坐骑，**他对其他玩家**计算实际距离时变为位置距离减去 $1$。

3. 如果一位玩家的坐骑是 `0` 则代表其没有坐骑，不产生特殊效果。

注意：**实际距离**指的是计算时的距离，游戏中两人的位次**没有改变**。

当一位玩家的**武器距离**大于等于**他对想要攻击的玩家**计算的实际距离时，我们称这位玩家可以攻击到他想要攻击的玩家。

现在给你两个玩家 A 和 B 的位次，武器距离和坐骑情况，请你判定 A 是否能攻击到 B，B 是否能攻击到 A。



## 说明/提示

### 样例解释 1

因为 A 装备了 `+1` 坐骑，B 对 A 计算实际距离应当加上 $1$，但是 B 装备了 `-1` 坐骑，所以 B 刚好能打到 A。

## 数据范围

共 $10$ 个测试点，不开启捆绑测试。

对于前 $10\%$ 的数据，保证坐骑只有 `0`。

对于 $100\%$ 的数据，$3\le n\le 8$，坐骑只有 `0,-1,1` 三种，武器距离不超过 $4$ 且不少于 $1$，保证两人的位次在 $1\sim n$ 之间且不相等。

---

AI 玩过三国杀吗？

## 样例 #1

### 输入

```
8
1 3 +1
4 3 -1```

### 输出

```
Yes
Yes```

## 样例 #2

### 输入

```
8
1 3 +1
4 3 0```

### 输出

```
Yes
No```

## 样例 #3

### 输入

```
4
1 3 +1
4 3 0```

### 输出

```
Yes
Yes```

# 题解

## 作者：_xdd_ (赞：4)

### 前言
不要以为你有神武将你就可以乱诬蔑人，中间忘了，三国杀，就是氪佬享有最高权力，中间忘了，但是，群众的眼睛是雪亮的！

如果你用一堆我看不懂的技能秒了我，会让全天下的平民玩家知道，三国杀的腐朽！

三国杀将会臭名昭著！

### 解法

模拟，首先先算出 A 和 B 之间的最短距离（顺时针和逆时针）然后加上加减马的情况，最后得出的距离如果大于武器攻击范围则输出 `No` 反之输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/u1arwyf6.png)（无端）

### code


```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define r0 return 0
#define inf (0x7fffffff)
#define maxn (  +5)
#define int long long
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
int n,ax,ay,bx,by,bz,az;
signed main(){
    cin >> n >> ax >> ay >> az >> bx >> by >> bz;
    int s=min(abs(ax-bx),abs(ax+n-bx));
    if(s+(bz==1)-(az==-1)<=ay){
        cout << "Yes\n";
    }else{
        cout << "No\n";
    }
    if(s+(az==1)-(bz==-1)<=by){
        cout << "Yes\n";
    }else{
        cout << "No\n";
    } 
}
```

---

## 作者：DFs_YYDS (赞：3)

[三国杀坏事做尽](https://www.luogu.com.cn/problem/P12974)。
# 题目大意
一个长度为 $n$ 的环中有两个人，给出他们的位置、攻击距离和坐骑（增加对方到自己的距离或者减少自己到对方的距离）。问这两个人互相是否能攻击到对方。
# 具体思路
为了方便，我们将两个人称为 `a` 和 `b`，两个人的位置为 $ax$ 和 $bx$。

首先我们把攻击距离和坐骑扔到一边，在只考虑位置的情况下算出他们的距离。

题目中提到，距离为两个玩家之间顺时针或逆时针相隔的人数最小值加上 $1$。其实就是 $\lvert bx-ax \rvert$ 与 $n - (\lvert bx-ax \rvert)$ 中的最小值。

算出距离后，只需要按照坐骑算出实际距离之后判断距离是否超过武器距离即可。

# 完整代码
于是乎，我们来到了大家最喜爱的代码环节。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
struct man{
	int x;//位置 
	int l;//攻击距离 
	string w;//坐骑 
};
signed main(){
	int n;
	cin>>n;
	man a,b;
	int x,y;//为了方便计算，这里我用了两个变量分别表示a到b和b到a的实际距离。 
	cin>>a.x>>a.l>>a.w>>b.x>>b.l>>b.w;
	x=y=min(abs(b.x-a.x),n-abs(b.x-a.x));//两人初始距离相等。
	//计算坐骑 
	if(a.w=="+1")y++;
	if(b.w=="+1")x++;
	if(a.w=="-1")x--;
	if(b.w=="-1")y--;
	//判断距离 
	if(a.l>=x)cout<<"Yes\n";
	else cout<<"No\n";
	if(b.l>=y)cout<<"Yes\n";
	else cout<<"No\n";
	return 0;//好习惯 
}
```

---

## 作者：pengyirui (赞：2)

来拯救一下社贡咕值。     
# 简化题意
$n$ 个人中，位于 $a1$ 位置的 A 与位于 $a2$ 位置的 B 的距离 $+1$ 或 $-1$ 或者不变后，如果小于 $b1$，第一行输出 ```Yes```;位于 $a2$ 位置的 B 与位于 $a1$ 位置的 A 的距离 $+1$ 或 $-1$ 或者不变后，如果小于 $b2$，第二行输出 ```Yes```。
# 思路
各位同学，现在我们开始看这道题。     
这道题考察分支结构，不会的可以去做一下[官方题单](https://www.luogu.com.cn/training/101)并了解一下，这里不过多介绍。    
## 计算位置距离
首先，我们来计算位置距离，由题目可知两人相对的位置距离是相等的，而题目中给出的公式“定义位置距离为两个玩家之间顺时针或逆时针相隔的人数最小值加上 $1$”用我们的语言来说就是 $\max\{a2-a1,a1+n-a2\}$，大家可以想想为什么。（因为两者中间间隔人数是两者位置的差再减去 $1$，而题目中说还要 $+1$，所以抵消了。）    
此部分代码如下：

```
    cin>>n>>a1>>b1>>c1>>a2>>b2>>c2;
    if(a1>a2)swap(a1,a2);
    int juli=min(a2-a1,a1+n-a2);
```
注意 $a1$ 必须小于 $a2$。
## 计算实际距离
解决了这个问题，我们再看看计算实际距离的方法。将第二行第三行的最后一个数据存储于 ```string``` 中即可，再特判。    
此部分代码如下：

```cpp
    int ajulib=juli,bjulia=juli;
    if(c1=="+1")bjulia++;
    if(c1=="-1")ajulib--;
    if(c2=="+1")ajulib++;
    if(c2=="-1")bjulia--;
```
[string 题单。](https://www.luogu.com.cn/training/104)
## 输出
这个不必多说，上代码：

```cpp
   if(ajulib<=b1)cout<<"Yes\n";
    else cout<<"No\n";
    if(bjulia<=b2)cout<<"Yes\n";
    else cout<<"No\n";
```
# 整体代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a1,a2,b1,b2;
string c1,c2;
int main()
{
    cin>>n>>a1>>b1>>c1>>a2>>b2>>c2;
    if(a1>a2)swap(a1,a2);
    int juli=min(a2-a1,a1+n-a2);
    int ajulib=juli,bjulia=juli;
    if(c1=="+1")bjulia++;
    if(c1=="-1")ajulib--;
    if(c2=="+1")ajulib++;
    if(c2=="-1")bjulia--;
    if(ajulib<=b1)cout<<"Yes\n";
    else cout<<"No\n";
    if(bjulia<=b2)cout<<"Yes\n";
    else cout<<"No\n";
    return 0;
}
```
在文章的最后，感谢您的阅读。

---

## 作者：Zskioaert1106 (赞：1)

题目传送门：[P12974 蒸蒸日上](https://www.luogu.com.cn/problem/P12974)

### 做题过程

按照题意模拟即可。

距离的计算：顺时针很好办，就是两者位次的绝对值。逆时针其实也容易，拿 $n$ 减去较大的位次，再加上较小的位次即可。

之后就是加上对方 $\texttt{+1}$ 坐骑和减去自己 $\texttt{-1}$ 坐骑的贡献了。

### 代码实现

建议熟练使用三目运算符。

```cpp
#include<iostream>
using namespace std;
int n,dis;
int Aa,Ab,Ba,Bb;
string As,Bs;
int main(){
    cin>>n>>Aa>>Ab>>As>>Ba>>Bb>>Bs;
    dis=min(abs(Aa-Ba),n-max(Aa,Ba)+min(Aa,Ba));
    cout<<((Ab>=dis+(Bs=="+1")-(As=="-1"))?"Yes":"No")<<'\n';
    cout<<((Bb>=dis+(As=="+1")-(Bs=="-1"))?"Yes":"No")<<'\n';
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/221716109)。

---

## 作者：LoongPig (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12974)

## 思路

直接按题意模拟。

如果 A 装备了 `+1` 坐骑，那 B 到 A 的距离就增加 $1$。  
如果 A 装备了 `-1` 坐骑，那 A 到 B 的距离就减少 $1$。  
如果 B 装备了 `+1` 坐骑，那 A 到 B 的距离就增加 $1$。  
如果 B 装备了 `-1` 坐骑，那 B 到 A 的距离就减少 $1$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,pa,pb,la,lb;
string ra,rb;
int main(){
    cin>>n>>pa>>la>>ra>>pb>>lb>>rb;
    int len=min((pa-pb+n)%n,(pb-pa+n)%n);
    int ab=len,ba=len;
    if(ra=="+1") ba++;
    if(rb=="+1") ab++;
    if(ra=="-1") ab--;
    if(rb=="-1") ba--;
    cout<<(ab<=la?"Yes\n":"No\n")<<(ba<=lb?"Yes\n":"No\n");
    return 0;
}
```

---

## 作者：huhengrui2013 (赞：1)

~~一道复杂的红题~~

首先求出位置距离，在根据 $+1$ 马和 $-1$ 马求出实际距离，最后分支判断一下是否打得到即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,a1,a2,a3,b1,b2,b3;
string s1,s2;
int main(){
    cin>>n;
    cin>>a1>>a2>>s1;
    cin>>b1>>b2>>s2;
    //求位置距离，顺时针距离是小值+n-大值
    //逆时针距离是大值-小值
    int res1=min(max(a1,b1)-min(a1,b1),min(a1,b1)+n-max(a1,b1));//表示A到B的位置距离
    int res2=res1;//表示B到A的位置距离

    if(s1=="+1") res2++;//其他玩家对他计算实际距离时变为位置距离加上 1。
    else if(s1=="-1") res1--;//他对其他玩家计算实际距离时变为位置距离减去 1，下同。

    if(s2=="+1") res1++;
    else if(s2=="-1") res2--;

    if(a2>=res1) cout<<"Yes\n";//A的攻击距离>=B的实际距离
    else cout<<"No\n";

    if(b2>=res2) cout<<"Yes\n";//B的攻击距离>=A的实际距离
    else cout<<"No\n";
}
```

---

## 作者：封禁用户 (赞：1)

## 思路
很简单，只要求出 $A$ 和 $B$ 之间的实际距离，两种不同情况（坐骑为 $0$ 时没有特殊效果）与它们的攻击距离作比较就行了。
## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,l;//人数和A与B的距离
int id1,s1,ll1;//A的位次，武器距离和对B的实际距离
int id2,s2,ll2;//B的位次，武器距离和对A的实际距离
string q1,q2;//A和B的武器距离
int main()
{
    cin>>n;//输入
    cin>>id1>>s1>>q1;
    cin>>id2>>s2>>q2;
    ll2=ll1=min(abs(id1-id2),n-abs(id1-id2));//计算初始距离
    if(q1=="+1") ll2++;//A遇到的两种情况
    else if(q1=="-1") ll1--;
    if(q2=="+1") ll1++;//B遇到的两种情况
    else if(q2=="-1") ll2--;
    //答案
    s1>=ll1?cout<<"Yes"<<"\n":cout<<"No"<<"\n";
    s2>=ll2?cout<<"Yes"<<"\n":cout<<"No"<<"\n";
    return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

## 题目描述

**位置距离**：两个玩家之间相隔的人数最小值加一。

**实际距离**：

- 装备了 $+1$ 坐骑，其他玩家**对他**的实际距离变为位置距离加上一。

- 装备了 $-1$ 坐骑，他**对其他玩家**的实际距离变为位置距离减去一。


现在有一堆人在玩游戏，求两个人的攻击情况。

一个人攻击到另一个人当前仅当两个人的实际距离小于等于这个人武器的长度。

## 思路：

考虑位置距离怎么算。

显然 $A$ 到 $B$ 的位置距离等于 $B$ 到 $A$ 的位置距离，算一次即可。

考虑最重要的一点，这个坐骑对答案的影响。

对于 $+1$ 坐骑来说，其他玩家到他的距离是变大了一格的，变相来说是其他玩家的武器短了一格。

对于 $-1$ 坐骑来说，他到其他玩家的距离是减少了一格的，变相来说是他的武器长了一格。

剩下的按照题目判断即可。

## 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k;
struct {ll x,ps,us;} zxy[3];
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(ll i=1;i<=2;i++) cin>>zxy[i].x>>zxy[i].ps>>zxy[i].us;
	for(ll i=1;i<=2;i++) {
		if(zxy[i].us==1) zxy[2-i+1].ps--;
		if(zxy[i].us==-1) zxy[i].ps++;
	}
	k=abs(zxy[2].x-zxy[1].x)-1;
	k=min(k+1,n-2-k+1);//两种不同的位置距离，取最小值
	for(ll i=1;i<=2;i++){
		if(zxy[i].ps<k) cout<<"No\n";
		else cout<<"Yes\n";
	}
	return 0;
}
```

---

## 作者：_second_coming_ (赞：0)

### 我的思路

首先，对于两个玩家（编号分别是 $A$ 和 $B$，总数为 $n$），他们之间的位置距离（设为 $d$）为下式：
$$d=\min(|A-B|-1,n-|A-B|-1)+1=\min(|A-B|,n-|A-B|)$$

然后按照坐骑算距离即可，注意题目要求：

- 当其中一位玩家装备了 `+1` 坐骑，**其他玩家对他**计算实际距离时变为位置距离加上 $1$。
- 当其中一位玩家装备了 `-1` 坐骑，**他对其他玩家**计算实际距离时变为位置距离减去 $1$。

### 代码和其他

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int d(int n, int a, int b) {
    return min(abs(a-b),n-abs(a-b));
}
int a(int n, int x, int y, string m, string k) {
	int p = d(n, x, y);
	if (m == "+1") p += 1;
	if (k == "-1") p -= 1;
	return max(p, 1);
}
int main() {
	int n;
	cin >> n;
	int x1, w1;
	string m1;
	cin >> x1 >> w1 >> m1;
	int x2, w2;
	string m2;
	cin >> x2 >> w2 >> m2;
	int p1 = a(n, x1, x2, m2, m1);
	bool b1 = (w1 >= p1);
	int p2 = a(n, x2, x1, m1, m2);
	bool b2 = (w2 >= p2);
	cout << (b1 ? "Yes" : "No") << endl << (b2 ? "Yes" : "No") << endl;
	return 0;
}
```
#### 其他
[AC 记录](https://www.luogu.com.cn/record/221690870)

~~管理，给我过吧，求你了~~

---

## 作者：glass_goldfish (赞：0)

一道比较简单的模拟题。
### 思路
发现 C++ 的 `int` 读入 `+1` 也会自动变成 $1$，那么很好办了。但是注意坐骑 `+1` 和 `-1` 的坑。

以下记玩家 A 的位次为 $a$，武器距离为 $c$，坐骑情况为 $e$，玩家 B 的位次为 $b$，武器距离为 $d$，坐骑情况为 $f$。
#### Step 1 计算原本距离
他们的直接距离（就是不经过 $n$ 号位和 $1$ 号位之间的空隙）：$\left|a-b\right|$。

他们的间接距离（就是要经过 $n$ 号位和 $1$ 号位之间的空隙）：$\left|a-b+n\right|$。

最终距离（较小值，记为 $p$）：$p=\min\{\left|a-b\right|,\left|a-b+n\right|\}$。
#### Step 2 统计坐骑情况
记录玩家 A 对玩家 B 的距离为 $atb$，玩家 B 对玩家 A 的距离为 $bta$。初始值很显然都是 $p$。

统计玩家 A 的坐骑情况：若 $e=-1$，则 $atb\gets atb-1$；若 $e=1$，则 $bta\gets bta+1$。

统计玩家 B 的坐骑情况：若 $f=-1$，则 $bta\gets bta-1$；若 $f=1$，则 $atb\gets atb+1$。
#### Step 3 计算能否攻击
如果 $c\ge atb$，则第一行输出 `Yes`，否则第一行输出 `No`；如果 $d\ge bta$，则第二行输出 `Yes`，否则第二行输出 `No`。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1145141919810
using namespace std;
int n,w[5],l[5],z[5];
signed main(){
	cin>>n;
	for(int i=1;i<=2;i++)
		cin>>w[i]>>l[i]>>z[i];
	int lol=min(abs(w[1]-w[2]),abs(w[1]-w[2]+n));//1
	int atb=lol,bta=lol;
	if(z[1]==1)bta++;
	else if(z[1]==-1)atb--;
	if(z[2]==1)atb++;
	else if(z[2]==-1)bta--;//2
	if(l[1]>=atb)cout<<"Yes\n";
	else cout<<"No\n";
	if(l[2]>=bta)cout<<"Yes\n";
	else cout<<"No\n";//3
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：0)

直接模拟即可。

注意：距离的表达需要从顺时针和逆时针两个方向计算，经过推理可以得到距离为 $\min(b-a,a+n-b)$，当 $a<b$ 时如此，反过来只需要交换两数即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,a,b,wa,wb,L;
string s1,s2;
signed main(){
	cin>>n>>a>>wa>>s1>>b>>wb>>s2;
	if(s1=="+1") wb--;
	if(s1=="-1") wa++;
	if(s2=="+1") wa--;
	if(s2=="-1") wb++;
	if(a>b) swap(a,b);
	L=min(b-a,a+n-b);
	cout<<(wa>=L?"Yes\n":"No\n");
	cout<<(wb>=L?"Yes\n":"No\n");
	return 0;
}
```

本题其实是 WAOI R1.5 的题。

---

## 作者：_seven_7k_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12974)
## 思路
这是一个简单的判断题。首先我们考虑如何计算两人的距离，这里有两种计算方法：计算两人的距离差；用总人数减去两个位次中的最大位次再加上最小位次。我们定义这个距离为 $s$，我们可以再设一个变量为 $k$，$k=s$。$k$ 指实际距离，当自己准备了 `-1` 坐骑时，$k$ 减一；当对方装备了 `+1` 坐骑时，$k$ 加一。最后和武器攻击距离对比即可。  
别忘记了判断第二个玩家时 $k$ 的值要重新设为 $s$。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	int a[4],b[4],i;
	cin>>n;
	for(i=1;i<=3;i++){
		cin>>a[i];
	}
	for(i=1;i<=3;i++){
		cin>>b[i];
	}
	int s=abs(min(abs(a[1]-b[1]),n-max(a[1],b[1])+min(a[1],b[1])));
	int k=s;
	if(a[3]==-1){
		k-=1;
	}
	if(b[3]==1){
		k+=1;
	}
	if(a[2]>=k){
		cout<<"Yes"<<endl;
	}
	else{
		cout<<"No"<<endl;
	}
	k=s;
	if(b[3]==-1){
		k-=1;
	}
	if(a[3]==1){
		k+=1;
	}
	if(b[2]>=k){
		cout<<"Yes"<<endl;
	}
	else{
		cout<<"No"<<endl;
	}
	return 0;
}
```

---

## 作者：wjh27465 (赞：0)

# 题解：P12974 蒸蒸日上
## 分析
根据题意模拟即可。  
先计算两人之间的距离，用 $x$ 表示。注意要选择顺时针和逆时针中较小的那个。之后根据装备的坐骑来调整距离，其中 $ab$ 表示 $A$ 到 $B$ 的距离，$ba$ 表示 $B$ 到 $A$ 的距离。将 $ab$ 和 $ba$ 分别与两人的武器距离相比较，如果武器距离大于实际距离则输出`Yes`，否则输出`No`。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n,a1,a2,b1,b2,x,ab,ba;//a1,b1表示两人的位置,a2,b2表示两人的武器距离。
    char a[3],b[3];//存储两人的坐骑信息。
    cin>>n>>a1>>a2>>a>>b1>>b2>>b;
    x=min((max(a1,b1)-min(a1,b1)),(n+min(a1,b1)-max(a1,b1)));
    ab=x;
    ba=x;
    if(a[0]=='+')
        ba++;
    if(b[0]=='+')
        ab++;
    if(a[0]=='-')
        ab--;
    if(b[0]=='-')
        ba--;
    if(a2>=ab)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    if(b2>=ba)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    return 0;
}
```

---

## 作者：__CrossBow_EXE__ (赞：0)

神秘模拟题。

这道题唯一的难点在于如何计算位置距离。显然位置距离就是两点中间的间隔数。假设两个人位置为 $a$ 和 $b$，那么位置距离可以用 $\min(\left | a-b\right |,n-\left|a-b \right|)$ 这个式子计算。

剩下的考验语言知识，请看代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a,b,x,y;
string s1,s2;
int dis;
int dis1,dis2;//a算距离，b算距离
signed main(int argc,char *argv[]){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;//按输入格式输入，注意不要输出多余内容
	cin>>a>>x>>s1;
	cin>>b>>y>>s2;
	//先算出位置距离
	dis=min(abs(a-b),n-abs(a-b));
	dis1=dis2=dis;
	//根据坐骑算出实际距离
	if(s1=="+1") dis2++;
	if(s1=="-1") dis1--;
	if(s2=="+1") dis1++;
	if(s2=="-1") dis2--;
	//最后判断实际距离与武器攻击距离的关系，输出答案
	if(x>=dis1) cout<<"Yes"<<endl;
	else cout<<"No"<<endl;
	if(y>=dis2) cout<<"Yes"<<endl;
	else cout<<"No"<<endl;
	return 0;
}
/*
---INFORMATIONS---
TIME:2025-06-28 21:49:15
PROBLEM:P12974
CODE BY __CrossBow_EXE__ Luogu uid967841
*/
```

---


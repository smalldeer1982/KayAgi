# 压缩技术

## 题目描述

设某汉字由 $N \times N$ 的 $\texttt 0$ 和 $\texttt 1$ 的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $\texttt 0$，第二个数表示接下来连续有几个 $\texttt 1$，第三个数再接下来连续有几个 $\texttt 0$，第四个数接着连续几个 $\texttt 1$，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： $\texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7}$ （第一个数是 $N$ ,其余各位表示交替表示0和1 的个数，压缩码保证 $N \times N=$ 交替的各位数之和）


## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/rsx9qytk.png)

## 数据范围

数据保证，$3\leq N\leq 200$。

## 样例 #1

### 输入

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7```

### 输出

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

# 题解

## 作者：2011hym (赞：18)

[更好的阅读体验。](https://blog.csdn.net/Hymmeishili/article/details/148436283?sharetype=blogdetail&sharerId=148436283&sharerefer=PC&sharesource=Hymmeishili&spm=1011.2480.3001.8118)

## 题目分析
我们需要根据给定的压缩码还原出原始的 $n\times n$ 的 **01** 点阵图案。压缩码的第一个数字是 $n$，后续数字交替表示连续的 0 和 1 的个数。

## 解决思路
根据**数字序列**交替填充 0 和 1，第一个数字表示连续的 0 的个数，第二个数字表示连续的 1 的个数，依此类推。

此思路需要双重循环，时间复杂度为 $O(n^2)$，可以接受。

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,sum,cnt,ct,ans;
int main(){
    cin>>n;
    sum=n*n;
    while(ans<sum){
        cin>>ct;
        for(int i=0;i<ct;i++){
            cout<<cnt;
            ans++;
            if(ans%n==0){
                cout<<endl;
            }
        }
        cnt=1-cnt;// 切换 0 和 1。
    }
    return 0;
}
```

---

## 作者：chen_kun (赞：5)

# 题解：P1319 压缩技术

题解区竟然又开了赶紧写一篇。

## 思路简述

题目还是很简单的，直接按照题意**模拟**即可。

因为事先并不知道输入有几个数，所以我们采用 `while(cin>>x)` 的方式进行输入。再开一个全局变量的数组 $a$ 用于记录点 $a_i$ 为 1 还是 0。另外用一个变量 $cnt$ 记录当前输入的是第几个压缩码，通过它的奇偶性判断当前的压缩码是 1 的个数还是 0 的个数。如果当前是 0 就不用管他，如果是 1 就把连续 $x$ 个 1 塞进数组里。最后输出就好了。

## 代码呈现

### C++

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10010],n,x,cnt=1,i=1;
int main(){
	cin>>n;
	while(cin>>x){
		if(cnt%2!=0) i+=x;//偶数代表是零不用管 
		else{
			for(int j=1;j<=x;j++) a[i]=1,i++;//否则把连续x个1塞进数组里 
		}
		cnt++;//个数加一 
	}
	for(int i=1;i<=n*n;i++){
		cout<<a[i];
		if(i%n==0)cout<<endl;
	}
	return 0;
}
```
## The end.

---

## 作者：ZTengW (赞：3)

以防你不知道题目在哪里：  
[Please Click Here](https://www.luogu.com.cn/problem/P1319)  
## 1.题目大意  
先输入一个正整数 $N$，要求输出一个 $N \times N$ 的矩阵，然后题目会交替给你 $0$ 和 $1$ 的数量，随后按要求输出就可以了。  
~~还没看懂的可以去看样例解释。~~   
## 2.代码细节  
题目里面有一点很烦人，就是它可能会出现一行里面位置不够的情况，那这时我们再用二维 `char` 数组就比较麻烦，所以我们可以直接用一个 `string` 来存储，再在特定的位置换行就可以愉快地 AC 啦。
## 3.大致思路  
1. 输入。
2. 用 `string` 来存储 01 矩阵。
3. 输出，记得换行。
## 4.AC 代码  

```cpp
#include<bits/stdc++.h> // 万能头
using namespace std;
int main()
{
	string s="";
	int n,x,temp=0,i;
	cin>>n;
	while(cin>>x) // 输入
	{
		if(temp%2)
			for(i=1;i<=x;i++)
				s+="1"; // 存储 1
		else
			for(i=1;i<=x;i++)
				s+="0"; // 存储 0
		temp++;
	}
	temp=0;
	for(i=0;i<s.size();i++)
	{
		temp++;
		if(temp>n)
		{
			cout<<"\n"; // 换行
			temp=1;
		}
		cout<<s[i]; // 输出
	}
	return 0;
}
```
最后给我点个关注叭。

---

## 作者：dengrunze2608 (赞：3)

## 本题大意
要求根据给定的一组压缩数据还原一个 $n×n$ 的 $01$ 矩阵。压缩数据的格式是交替给出连续 $0$ 和 $1$ 的个数，第一个数字表示连续 $0$ 的个数，第二个数字表示连续 $1$ 的个数，以此类推。
## 思路
首先读取矩阵的边长 $n$。使用一个循环不断读取压缩数据中的数字 $a$ ，使用 $id$ 变量来标记当前应该输出 $0$ 还是 $1$（$0$ 表示输出 $0$，$1$ 表示输出 $1$）。对于每个数字 $a$，连续输出 $a$ 个 $0$ 或 $1$，在输出过程中，每输出 $n$ 个字符就换行。并使用 $s$ 变量记录已输出的总字符数，当 $s$ 达到 $x^2$ 时停止。
## 本题代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a;
int endll,id=0,s;
signed main(){
	cin>>n;
	while(s<n*n){
		cin>>a;
		if(id==0){
			for(int i=1;i<=a;i++){
				if(endll==n){
					cout<<endl;
					endll=0;
				}
				cout<<"0";
				endll++;
				s++;
			}
		}else{
			for(int i=1;i<=a;i++){
				if(endll==n){
					cout<<endl;
					endll=0;
				}
				cout<<"1";
				endll++;
				s++;
			}	
		}
		id++;
		id%=2;
	}
	
	return 0;
}
```

---

## 作者：zyr2011 (赞：1)

本题主要考察对字符串的运用和模拟思想。
### 题目解法
首先，因为数据没有明确给出会输入多少个数，所以我们可以用以下代码进行读入。  
```cpp
while(scanf("%d",&a)!=EOF)
```
这句代码就是一直读入一个数字 $a$，如果输入```EOF```就结束，通常用于**不知道确切读入数量**的读入。  
接下来，我们就要模拟输出，不难发现，我们可以按照 $a$ 的数值来进行输出，用一个变量 $flag$ 来记录应输出 $\texttt 0$ 还是 $\texttt 1$，连续输出 $a$ 个 $flag$，再用一个变量 $cnt$ 来计数，**每输出一次就加一**，当 $cnt$ 能够**整除** $N$ 时，我们就换行。  
以下是我的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
signed main(){
	int n,a,cnt=0,flag=0;cin>>n;
	while(scanf("%d",&a)!=EOF){//读入 
		for(int i=1;i<=a;++i){//连续输出a次 
			cout<<flag;//输出0或者1 
			cnt++;//计数 
			if(cnt%n==0)cout<<endl;//能整除就换行 
		}
		flag=!flag;//!是取反符号，如果flag为0，就变为1，如果是1，就变为0。 
	}
	return 0;
} 
```

---

## 作者：volatile (赞：1)

# 思路

读入使用 `while (scanf("%d", &t) == 1)`，代表循环的条件是有无输入。使用变量 $s$ 代表下标，$f$ 代表当前是 $0$ 还是 $1$。遍历 $t$ ，存储在数组 $a$ 中，$a_s$ 赋值为 $f$，并将 $s$ 加 $1$。读入结束后，若 $f=1$，则赋值为 $0$，否则赋值为 $1$。

遍历数组 $a$，输出每一位。

由于输出的方阵大小为 $N\times{N}$，所以每一行只能输出 $N$ 个数字。可以用一个变量 $cnt$ 记录当前输出是第几个数，如果 $cnt=N$，就输出一个换行并将 $cnt$ 赋值为 $0$。

# 代码


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[20001];
int main()
{
    int n;
    cin >> n;
    int t, s = 1, f = 0;
    while (scanf("%d", &t) == 1) {
        for (int i = 0; i < t; i++) {
            a[s] = f;
            s++;
        }
        f = !f;
    }
    int ans = 0;
    for (int i = 1; i < s; i++) {
        cout << a[i];
        ans++;
        if (ans == n) {
            cout << endl;
            ans = 0;
        }
    }
    return 0;
}
```

---

## 作者：Ashankamiko (赞：1)

# 题目简述
### 题意
给定 $N$ 个数，表示连续的 $0$ 和 $1$ 的数量，并输出 $N \times N$ 的矩阵。
### 思路
直接模拟即可，每输入 $x$ 就输出 $x$ 个 $0$ 或 $1$。

注意：若当前的 $y$ 超过了 $N$，换行并令 $y \gets 0$。
## [AC 代码](https://www.luogu.com.cn/record/198317160)
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, a, sum;

int main() {
	cin >> n;
	for (int i = 1, cnt = 0;; i++) {
		cin >> a;
		sum += a;
		if (i & 1) {
			while (a--) {
				cout << 0;
				if (++cnt == n) {
					cout << "\n";
					cnt = 0;
				}
			}
		} else {
			while (a--) {
				cout << 1;
				if (++cnt == n) {
					cout << "\n";
					cnt = 0;
				}
			}
		}
		if (sum == n * n)
			return 0;
	}
}
```

---

## 作者：Clare613 (赞：1)

## 思路：
按照题意模拟即可，先输入 $n$，再用 `while(cin>>x)` 来剩余数字全部输入，对于第一个数字，设其为 $x$，那么就输出 $x$ 个 $0$，对于第一个数字，设其为 $y$，那么就输出 $y$ 个 $1$。剩下来的只要注意每 $n$ 个数换一行，输出即 AC。
## code：
```cpp
#include<bits/stdc++.h>
#define int long long
#define MOD 998244353
using namespace std;

signed main(){
	cin.tie(0)->sync_with_stdio(0);
	int n,x,q=0,cnt=0;
	cin>>n;
	while(cin>>x){
		for(int i=1;i<=x;i++){
			cout<<q;
			cnt++;
			if(cnt>n){
				cout<<"\n";
				cnt=1;
			}
		}
		q^=1;
	}
	return 0;
}
```

---

## 作者：_ArenaBreakout114514 (赞：0)

## 前言：

这题题解区又开放了？那我必须交一发。

## 思路：

首先，这道题就是输入几个数字，然后第一个数是这个正方形的边长，而剩下几个数则是代表连续的 $0$ 和 $1$ 的数量，交替出现，于是，我们可以用一个 while 循环重复输入数字，反复输出 $0$ 和 $1$，然后在循环中判断是否有 $n$ 个了，有就直接换行，于是我们便能 AC 这道水题了。

## C++ AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool flag=false;
int main(){
    int n,a,sum=0;
    cin>>n;
    while(cin>>a){
        if(!flag){
            for(int i=1;i<=a;i++){
                sum++;
                cout<<0;
                if(sum%n==0) cout<<"\n";
            }
            flag=true;
        }
        else{
            for(int i=1;i<=a;i++){
                sum++;
                cout<<1;
                if(sum%n==0) cout<<"\n";
            }
            flag=false;
        }
    }
}
```

---

## 作者：ovo321 (赞：0)

~~又是简单的小模拟~~。

由于题面没告诉我们具体多少个数，所以用 `while` 来进行循环输入，接下来就是小模拟了。

我们先用变量 $Key$ 来判断数组里的是 $1$ 还是 $0$，接着不断存入数组，最遍历再判断换行输出。~~就这么水灵灵的做完了~~。然后贴代码。

对了，别忘了更新数值。

# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,fu,p=0;
bool Key=false;
signed main(){
	ios::sync_with_stdio(0),
	cin.tie(0),cout.tie(0);
	cin>>n;int m[n*n+10];
	while(cin>>fu){
		int i;
		for(i=p;i<p+fu;i++)
			m[i]=Key;
		p=i,Key=!Key;
	}p=0;for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			cout<<m[p];
			p++;
		}cout<<endl;
	}
}
```

---

## 作者：cse071549 (赞：0)

### 题目大意
从汉字点阵图案的第一行第一个符号开始，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $0$，第二个数表示接下来连续有几个 $1$，以此类推……

### 题目详解
这题只需要一个 ```while(cin>>x)``` 输入命令，用一个一维数组把每次的命令从上次最后的点开始，把它后面的 $x$ 个数都作相应赋值，最后在输出时，$N$ 个一换行，即可完成矩阵。

### 代码示例
```cpp
#include<bits/stdc++.h>
using namespace std;
int k[400005];
int cnt=1,ans,a;
int main(){
	int n;
	cin>>n;
	while(cin>>a){
		ans++;
		for(int i=cnt;i<=cnt+a-1;i++){
			if(ans%2==1){
				k[i]=0;
			}else{
				k[i]=1;
			}
		}
		cnt=cnt+a;
	}
	for(int i=1;i<cnt;i++){
		cout<<k[i];
		if(i%n==0){
			cout<<endl;
		}
	}
	return 0;
} 
```

---

## 作者：CSP_SAKME (赞：0)

先从从输入中读取压缩码，后续的数字交替表示连续 0 和 1 的个数。再使用一个二维数组来表示点阵图案。根据压缩码中的数字，依次填充到二维数组中。最后输出点阵图案‌。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s[40001],top=0,x,p=0;
int main(){
	cin >> n;
	while(cin >> x){
		if(p==0) for(int i=1;i<=x;i++) s[++top]=0;
		else for(int i=1;i<=x;i++) s[++top]=1;
		p^=1;
	}
	p=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout << s[p++];
		}
		cout << endl;
	}
	return 0;
}
```

---


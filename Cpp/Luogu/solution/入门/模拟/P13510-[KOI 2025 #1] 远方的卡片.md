# [KOI 2025 #1] 远方的卡片

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

有 $2N$ 张写有自然数的卡片。这些卡片从左到右排成一列。

每张卡片上都恰好写着一个 $1$ 到 $N$ 之间的自然数。我们称从左边数第 $i$ ($1 \le i \le 2N$) 张卡片上写的自然数为 $X_i$。

对于每个 $1 \le k \le N$ 的 $k$，写有数字 $k$ 的卡片恰好有两张。也就是说，从 $1$ 到 $N$ 的每个自然数都恰好写在两张卡片上。

Jeong-ul 将写有自然数 $k$ 的两张卡片之间放置的卡片数量称为“数字 $k$ 之间的卡片数量”。

例如，假设卡片按如下图所示的方式放置。在下图中，$N=4$，且 $X_1=1, X_2=2, X_3=2, X_4=4, X_5=3, X_6=1, X_7=3, X_8=4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/klmwlcqy.png)

*   在两张写有 1 的卡片之间，依次有写着 2, 2, 4, 3 的卡片，因此“数字 1 之间的卡片数量”为 4。
*   在两张写有 2 的卡片之间，没有任何卡片，因此“数字 2 之间的卡片数量”为 0。
*   在两张写有 3 的卡片之间，只有一张写着 1 的卡片，因此“数字 3 之间的卡片数量”为 1。
*   在两张写有 4 的卡片之间，依次有写着 3, 1, 3 的卡片，因此“数字 4 之间的卡片数量”为 3。

在上面的例子中，“数字 $k$ 之间的卡片数量”中的最大值是“数字 1 之间的卡片数量”，其值为 4。

Jeong-ul 想要找出对于从 1 到 $N$ 的所有自然数 $k$，“数字 $k$ 之间的卡片数量”中的最大值。

当给定按排列顺序的卡片上的自然数时，请编写一个程序，求出所有“数字 $k$ 之间的卡片数量”中的最大值。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N \le 2000$。
*   对于每个 $i$ ($1 \le i \le 2N$)，都有 $1 \le X_i \le N$。
*   对于每个 $k$ ($1 \le k \le N$)，写有数字 $k$ 的卡片恰好有两张。也就是说，在 $X_1, X_2, \cdots, X_{2N}$ 中，$k$ 恰好出现两次。

### 子任务

1.  (10 分) $N \le 2$。
2.  (15 分) 答案为 0 或 1。
3.  (15 分) 答案为 $2N-3$ 或 $2N-2$。
4.  (20 分) $N \le 500$。
5.  (40 分) 无附加限制条件。

## 样例 #1

### 输入

```
4
1 2 2 4 3 1 3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
4
1 2 3 4 4 3 2 1```

### 输出

```
6```

# 题解

## 作者：chen_zhe (赞：6)

### 子问题 1

因为 $N \le 2$，所以所有可能的情况总共只有 7 种。对所有这些情况直接计算出答案，然后根据给定的输入输出对应的答案即可。

### 子问题 2

答案总是 $0$ 或 $1$ 中的一个。因此，只需确认写有相同数字的卡片是否都彼此相邻即可。如果写有相同数字的卡片全部相邻，则答案为 $0$，否则答案为 $1$。

### 子问题 3

答案总是 $2N - 2$ 或 $2N - 3$ 中的一个。这个值可以通过确认卡片序列的两端，即最左侧的 2 张卡片和最右侧的 2 张卡片上写着什么数字来决定。

### 子问题 4

对于所有的 $1 \le x \le N$，找到写有数值 $x$ 的两张卡片的位置 $i, j$（$1 \le i < j \le 2N$），并计算它们之间夹着的卡片数量。如此求得的值中的最大值即为答案。

### 子问题 5

对于所有可能的数对 $1 \le i < j \le 2N$，如果第 $i$ 张和第 $j$ 张卡片上写有相同的数字，则计算这两张卡片之间存在的卡片数量。在这些计算结果中输出最大值。

```cpp
#include <iostream>
#include <algorithm>
 
using namespace std;
 
const int MAXN = 5'000;
 
int A[MAXN*2+10];
 
int main()
{
    int n;
 
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
 
    cin>>n;
 
    for(int i = 0; i < (n<<1); i++) {
        cin>>A[i];
    }
 
    int ans = 0;
 
    for(int i = 0; i < (n<<1); i++) {
        for(int j = i+1; j < (n<<1); j++) {
            if(A[i] == A[j]) {
                ans = max(ans, j-i);
                break;
            }
        }
    }
 
    cout << ans-1 << "\n";
 
    return 0;
}
```

---

## 作者：xiaowenxu_qwq (赞：3)

# 思路
我们发现题目数据特别的小，所以我们可以暴力找出相同的两个数字，再将后一个数的下标与前一个数的下标相减再减一（即求出中间的卡牌个数），最后将最大的中间卡牌数输出即可。

AC 代码。

```cpp
#include<bits/stdc++.h>
#define int long long
#define max(a,b) (a>b?a:b) 
#define min(a,b) (a<b?a:b)
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}//快读
void write(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else write(x/10),putchar(x%10+'0');
}//快输
int a[10001];
int ans=-1;
signed main(){
	int n=read();
    for(int i=1;i<=2*n;i++){
        a[i]=read();
    }
    for(int i=1;i<=n;i++){
        bool book=1;int cnt;
        for(int j=1;j<=2*n;j++){
            if(a[j]==i&&book){//找到左端点
                cnt=j;
                book=0;
            }
            else if(a[j]==i&&!book)//找到右端点
                ans=max(j-cnt-1,ans);//计算中间卡牌数
        }
    }
    write(ans);
	return 0;
} 

```

---

## 作者：abc1234shi (赞：2)

# 分析
模拟题。
# 题意
题目可能误导了很多人，我也是观察样例才懂的题目。

通俗理解：在一个序列中，每个数都会出现 $2$ 次，定义 $k$ 这个数的距离为第一次出现的 $k$ 与第二次出现的 $k$ 之间有几个数。

求这个距离的最大值。
# 计算方法
对于数字 $k$，设 $k$ 第一次出现在序列的第 $i$ 项，第二次出现在第 $j$ 项。

那么 $i$ 与 $j$ 之间的数为 $i+1$ 到 $j-1$，共有 $j-i-1$ 个数。

算出每个 $k$ 的距离，取最大值就好了。
# 思路实现
- 遍历序列，记录下每个数字第一次出现的位置。
- 当数字第二次出现时，计算它与第一次出现位置的差值减 $1$，得到该数字的间隔卡片数量。
- 更新所有数字的最大间隔卡片数量。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1110000],f[1110000];
int main() {
	int n;
	cin>>n;
	for(int i=1; i<=n; ++i)f[i]=-1;
	int ans=0;
	for(int i=1; i<=2*n; ++i) {
		cin>>a[i];
		if(f[a[i]]==-1) {
			f[a[i]]=i;
		} else {
			int g=i-f[a[i]]-1;
			if(g>ans)ans=g;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：koukilee (赞：1)

每个数最多出现两次，考虑将其第一次出现的时候，记录为 $L_{X_i}$。

第二次出现的时候，就可以算出两个数之间存在的数的数量 $i - L_{X_i} - 1$。 

对每对这样的数取最大值即可。

时间复杂度：$O(n)$。

```c++
int main() noexcept{
	read (n);

	for (i32 i = 1; i <= n * 2; i++) {
		read (s[i]); 
		if (!L[s[i]]) L[s[i]] = i; /*第一次出现*/
		else ans = std::max (ans, i - L[s[i]] - 1); /*计算区间内的数量*/
	}
	
	put (ans);
    return 0;
}
```

---

## 作者：xqdrsn (赞：1)

我们先看[题目](https://www.luogu.com.cn/problem/P13510)。

### 题目分析
给定长度为 $2N$ 的序列，每个数字 $1$ 到 $N$ 恰好出现两次。求两个相同数字之间的最大间隔（即它们之间的卡片数量）。

### 解法
1. **关键观察**：对每个数字，只需记录它第一次出现的位置，第二次出现时即可计算间隔。
2. **实现**：用 `map<int, int>` 存储首次出现的位置，第二次出现时计算 `i - p[x] - 1` 并更新最大值。

### AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int x,maxn=0;
map<int,int>p;
int main(){
	cin>>n;
	for(int i=1;i<=n*2;i++){
		cin>>x;
		if(p[x]==0){
			p[x]=i;
		}else{
			maxn=max(maxn,i-p[x]-1);
		}
	}
	cout<<maxn;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/227641260)

---

## 作者：What_a_Cat (赞：1)

#### 原理说明

我们可以使用一个结构体来存储每个元素的值及其在原始数组中的索引。通过这种方法，我们可以方便地对元素进行排序，并计算成对元素之间的最大距离差值。

#### 分析

假设输入为 `1 2 2 4 3 1 3 4`（样例），存储在结构体数组 `b` 中后如下表所示：

| 数据 | 1  | 2  | 2  | 4  | 3  | 1  | 3  | 4  |
|------|----|----|----|----|----|----|----|----|
| 索引 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |

对这些数据进行排序后，结构体数组 `b` 变为：

| 数据 | 1  | 1  | 2  | 2  | 3  | 3  | 4  | 4  |
|------|----|----|----|----|----|----|----|----|
| 索引 | 1  | 6  | 2  | 3  | 5  | 7  | 4  | 8  |

然后，我们可以通过计算相邻元素的索引差值来确定最大距离差值。具体来说，计算第一个和第二个元素的索引差值（并减去1），即可得到这两个元素之间有多少个数。

#### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

// 结构体定义，存储元素值及其原始索引
struct a {
    int a; // 元素的值
    int ci; // 元素在原始数组中的索引
} b[4001];

// 比较函数，按元素值升序排列
bool cmp(a x, a y) {
    return x.a < y.a;
}

int main() {
    int n;
    cin >> n; // 读取输入的 n 值
    
    // 读取 2n 个整数，并存储在结构体数组 b 中，同时记录每个元素的原始索引
    for (int i = 1; i <= 2 * n; i++) {
        int ai;
        cin >> ai;
        b[i].a = ai;
        b[i].ci = i;
    }
    
    // 根据元素的值对结构体数组进行排序
    sort(b + 1, b + 2 * n + 1, cmp);
    
    int maxx = 0; // 初始化最大距离差值为 0
    
    // 遍历排序后的数组，每次取相邻的两个元素，计算它们在原始数组中的索引差值，并更新 maxx
    for (int i = 1; (i + 1) <= 2 * n; i += 2) {
        maxx = max(maxx, abs(b[i].ci - b[i+1].ci));
    }
    
    cout << maxx - 1; // 输出最大距离差值减去 1
}

```

---

## 作者：ryf2011 (赞：1)

# 1.简化题意
给定数组 $X$，其中的数都恰好出现 $2$ 次。求相等的两数所在位置之间所包含的数的个数的最大值。

# 2.题目思路
## 2-1.绝对朴素的暴力
对于每个数，遍历一遍数组，找到与之相等的另一个数，并遍历它们之间的所有数，并计数，计算最大值。

## 2-2.相对朴素的暴力
上述方法代码相对复杂，且有许多优化的空间。

我们知道，设一个数所在的位置为 $l$，另一个数所在的位置为 $r$（这里，我们规定 $l < r$），那么~~显然~~从 $l$ 到 $r$（包括 $l$ 和 $r$）共有 $r - l + 1$ 个数，$l$ 和 $r$ 之间（不包括 $l$ 和 $r$）有 $r - l + 1 - 2 = r - l - 1$ 个数。

那么，我们可以把计数的复杂度由 $\mathcal O(n)$ 变为 $\mathcal O(1)$，即找到两个相等的数之后，直接套用上述公式计算，并取最大值。

时间复杂度为 $\mathcal O(n^2)$，由于此题的 $N \le 2000$，可以通过此题。

:::info[暴力代码]

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int max_n=2002;
int n,x[max_n<<1],ans;
bool vis[max_n<<1];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=(n<<1);i++){
        scanf("%d",&x[i]);
    }
    for(int i=1;i<=(n<<1);i++){
        if(vis[i]){ //如果这个点已经被用过，那么跳过，避免重复计算
            continue;
        }
        vis[i]=true; //标记
        for(int j=1;j<=(n<<1);j++){
            if(vis[j]){
                continue;
            }
            if(x[j]==x[i]){ //如果两数相等，说明找到了相等的数
                vis[j]=true; //标记
                ans=max(ans,j-i-1); //计算最大值
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
:::

# 3.别急，还没结束
我们发现，上述暴力代码仍然有优化的空间。

也许有同学看到这里便不打算继续了，认为这里没什么用处，然而，这种类型的题目的 $N$ 可以来到 $10^6$ 左右，此时，题目依旧是可做的！

我们发现，上述代码的瓶颈在于：每次查找相等的数都需要重新遍历一遍数组。考虑如何优化这步操作。

我们可以用一个数组来记录每个数第一次出现的位置，~~众所周知~~当这个数第二次出现时，其位置一定在第一次出现位置的后面（~~废话~~），所以我们此时可以直接从数组中提取出位置并计算，更新答案。这样做就只需要遍历一次数组了！

时间复杂度为 $\mathcal O(n)$。

:::warning[本题作者用到的卡常小技巧]
~~快读不再重复……~~

在本题中，数组 $X$ 的长度为 $2N$，在输入时，不知道大家是否这样写？

```cpp
for(int i=1;i<=n*2;i++)
```

注意代码中的 $\texttt{n*2}$，实际上，它可以转化为 $\texttt{n<<1}$（其中 $\texttt{<<1}$ 表示“二进制左移 $1$ 位”），它可以省去一些时间。

虽然在本题中，这种写法并没有显著提高代码运行时间，但在算法竞赛中，这是常见的一种优化技巧。

:::

# 4.代码-O(n)
注：代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int max_n=2002;
int n,x[max_n<<1],fl[max_n],ans; //fl[i]:数字   i 第一次出现的位置
bool aper[max_n];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=(n<<1);i++){ //n<<1 相当于 n*2，但 n<<1 的速度更快，所以经常用于竞赛中以减少程序用时
        scanf("%d",&x[i]);
        if(!aper[x[i]]){ //x[i] 从未出现过，标记，并记录当前位置
            aper[x[i]]=true;
            fl[x[i]]=i;
        }
        else{ //已经出现过一次，说明这是第二次出现，计算答案并取最大值
            ans=max(ans,i-fl[x[i]]-1);
        }
    }
    printf("%d\n",ans); //输出
    return 0;
}
```

# 5.后记
更多内容，请移步至：

1. [$\color{red}\texttt{Luogu ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")；
2. [$\color{orange}\texttt{cnblogs（博客园） cnblogs2011ryf}$](https://www.cnblogs.com/cnblogs2011ryf)。

---

## 作者：lilong (赞：0)

按照题意模拟，记录每个数第一次读入时的位置，在其第二次读入时直接更新答案即可。时间复杂度 $O(n)$。

```cpp
#include<iostream>
#include<cstdio>
#define N 100010
#define int long long
using namespace std;
int n,a[N],p[N],ans;
signed main(){
    cin>>n;
    n*=2;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(!p[a[i]])p[a[i]]=i;
        else ans=max(ans,i-p[a[i]]-1);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：TuanTuan_Cat (赞：0)

# 解题思路
建三个数组，
1. 一个保存每一张卡片的值；
0. 一个`bool`类型数组保存目前是否在每对编号相同的两张卡片间；
0. 一个是累加器，保存在两张卡片之间有几张卡片。

然后遍历数组，每遍历一个值，累加一次。如果是第一次出现，后面累加，如果是第二次出现，停止累加。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2007],c[4007]; //a是累加器，c保存每一张卡片的值
bool b[2007];//b保存目前是否在每对编号相同的两张卡片间
signed main()
{
    int n;
    cin>>n;
    for(int i=0;i<2*n;i++) cin>>c[i];//输入
    for(int i=0;i<2*n;i++)//循环遍历卡片
    {
        if(!b[c[i]]) b[c[i]]=true;//如果没有出现卡片，把卡片标记为需要累加的
        else b[c[i]]=false;//如果已经出现过相同的值的卡片，把卡片标记为不需要累加的
        for(int j=1;j<=n;j++)
        {
            if(b[j])  a[j]++;//累加
        }
    }
    int mx=0;
    for(int i=1;i<=n;i++) mx=max(mx,a[i]);//遍历求最大值
    cout<<mx-1;//这里因为把卡片第一次出现的那一位给算上了，所以最后还要减去1.
    return 0;
}
```

---

## 作者：Hkb150429 (赞：0)

## 题意
现有 $n$ 张卡片。

Jeong-ul 将写有自然数 $k$ 的两张卡片之间放置的卡片数量称为“数字 $k$ 之间的卡片数量”。求“数字 $k$ 之间的卡片数量”的最大值。

## 思路

我们知道，求第 $i$ 个位置和 第 $j$ 个位置**之间**的个数公式是 $j - 1 - i$，那么我们只要知道这个数在前面是否出现，如果出现过，就用当前位置减去 $1$ 再减去原来的位置，否则记录这个数的当前位置。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2005];
int n,k,ans=0;
int main(){
    cin>>n;
    for(int i=1;i<=2*n;i++){//卡片数=数的个数乘2
        cin>>k;
        if(a[k]>=1)ans=max(i-1-a[k],ans);//如果出现，记ans和这个“数字 $k$ 之间的卡片数量”的最大值
        else a[k]=i;//否则记录这数的当前位置
    }
    cout<<ans;
}//完结撒花✿✿ヽ(°▽°)ノ✿！
```

---


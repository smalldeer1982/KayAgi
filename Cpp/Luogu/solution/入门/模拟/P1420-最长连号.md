# 最长连号

## 题目描述

输入长度为 $n$ 的一个正整数序列，要求输出序列中最长连号的长度。

连号指在序列中，从小到大的连续自然数。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
10
1 5 6 2 3 4 5 6 8 9```

### 输出

```
5

```

# 题解

## 作者：МiсDZ (赞：265)

本蒟蒻共发两篇题解都以同样的理由被拒绝了>\_<


所以，在仔细阅读了其他同学写的题解后决定认真写一道简单一点的题目的题解

我发现好像很多同学都想得太复杂了

这道题n<=10000,明明o(n)可以跑过，为什么这么复杂呢


首先，暂时不用递归，可能会有些难以理解

```cpp
#include<bits/stdc++.h>       //神奇头文件不用解释
#define INF 10234567
using namespace std;             //额……@_@
int main()                                //不用递归
{
    int n,s[1001],ans=0,max=-INF;            //n表示输入有n个正整数，ans呢待会解释，max可以不用想了，一定是最后的答案,为什么被赋值为-INF下面解释
    cin>>n;                                               //输入n
    for(int i=1;i<=n;i++)                           //循环了n次
        cin>>s[i];                                    //将数存进s数组里，其实也可以不存，这样会更好理解
    for(int i=1;i<=n;i++)                          //仍旧循环n次，对n个数进行处理
    {                                                         //以下以样例为例来解释代码：10\n3 5 6 2 3 4 5 6 8 9
        if(s[i+1]-s[i]==1)ans++;             //i从1到n，当i=1时s[i+1]表示3后面一个数，即为5，如果5-3==1，就说明3，5是连号，这里显然不是。如果是就将ans++，所以这里的ans只是为了临时存一下连号的个数，以此类推。
        else ans=0;                                  //一旦发现了一次不连号，就将临时存储的数据变为0
        if(ans>max)max=ans;                 //将max赋为-INF的原因是为了找到ans中的最大值，达到题目目的
    }
    cout<<++max;                                  //最后输出最大值
}
```
好吧，我承认这到比较简单的题目可以有很多解法，然而像我的这种解法的已经有很多了。

我旨在为了和我一样刚入门oi的同学一起分享学习思路，一些想法。

ps：理解万岁，这种简单题目，配上如此详细的解释应该可以理解吧。^\_^


---

## 作者：cys2004a (赞：171)

# 题解 P1420
## 大家好，这道题并不难，我先用的dp。但为了让初学者更明白我的做法，我又提交了~~2~~次，才通过了暴力解法。?
## 我使用的是C++语言，使用了2重循环。
## 题解如下：

```
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int a[n];
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
	}
	int maxn=0;
	for(int i=0;i<n-1;i++)
	{
		int s=0;
		for(int j=i+1;j<n;j++)
		{
			if(a[j]==a[j-1]+1)
			{
				s++;
			}
			else
				break;
		}
		maxn=max(maxn,s);
	}
	cout<<maxn+1;
	return 0;
} 
```

### 注意：最后要+1，因为单独一个数字也算长度唯一的连号。
### 不过，大佬们该嘲笑我：“多大了，还用这辣鸡方法！”

### 我的递归不太好，于是我硬着头皮用递归。相信很多人使用递归，费话不说了，O(2^n)代码奉上：

```
#include<iostream>
using namespace std;
int n;
int a[10010]={0};
int hs(int i)
{
	if(i==n-1)
		return 1;
	if(a[i]+1==a[i+1])
		return hs(i+1)+1;
	else
		return 1;
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
	}
	int maxn=0;
	for(int i=0;i<n;i++)
	{
		maxn=max(maxn,hs(i));
	}
	cout<<maxn;
}
```

### 但这实在太慢了，我们需要DP,我们♥DP!!!

### 于是，我搬出了第一次一遍AC的dp代码，虽然不够优化，但时间复杂度为O(n)，比上面的O(n*n)和O(2^n)要好得多。
### 具体代码如下：

```
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int a[n+1],dp[n+1];
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	int maxn=0;
	for(int i=n;i>0;i--)
	{
		if(i==n)
		{
			dp[i]=1;
		}
		else
		{
			if(a[i+1]-1==a[i])
			{
				dp[i]=dp[i+1]+1;
			}
			else
			{
				dp[i]=1;
			}
		}
		maxn=max(dp[i],maxn);
	}
	cout<<maxn;
	return 0;
} 
```

### 众所周知，动态规划拥有最优子节构性质，而且循环顺续由下至上，也就是逆推。所以如果我们从后往前推，即可避免重复遍历，具体思路如下表：
|i：| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
|a[i]| 3 | 5 | 6 | 2 | 3 | 4 | 5 | 6 | 8 | 9 |
|dp[i]| 3 | 2 | 1 | 5 | 4 | 3 | 2 | 1 | 2 | 1 |
### 表格第三行判断是否后面一个数比前面这个数正好大1如果是，带有a[i]这个元素的连号必定加上后面那串连号。如果不能构成连号，dp[i]即为本身，也就是1.
### 最后选取最大值，即为5.
### 不懂的同学请自行画表。

---

## 作者：skymirror (赞：105)

这道题类似于求最大上升子序列，只是多了一个条件

先解释一下代码里的变量：

ans：答案；temp：现在这个数；

b：前一个数；max：这个序列的最大长度

下面是代码：


```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,ans=0,temp,b,max=1;  
    cin>>n;
    cin>>b;                //输入，初始化b 
    for(int i=1;i<=n-1;i++)
    {
        cin>>temp;
        if(temp==b+1) max++;    //如果这个数是前一个数加1，最大值就增大1 
        else max=1;             //否则max回到初始值 
        if(ans<max) ans=max;    //如果最大值比当前的答案大，更改答案 
        b=temp;                 //b=当前这个数 
    }
    cout<<ans;                      //输出 
return 0;
}
```

---

## 作者：Astronaut_Commander (赞：45)

# 最易懂的简单法子
既然这是道入门难度的题，那就以入门的解法做好了，我反正萌新

## 先上代码
```cpp
#include<iostream>
using namespace std;
int main(){
	int i,n,m,j,c,ans;
	m=-1;ans=1;c=1;
	cin>>j;
	for(i=1;i<=j;i++)
	{
		cin>>n;
		if(n==m+1)
		c++;
		else c=1;
		if(c>ans)
		{
		ans=c;
	    }
		m=n;
	}
	cout<<ans;
	return 0;
}
```
## 大体思路

已经输入给出数据个数，所以就以此做循环条件，每次输入一个数，判断是否为上一个数加一（连续自然数）。

1，如果是，则临时计数（c）加一，

2，如果不是（断了），则将临时计数（c）清零。

在此期间若临时计数超过答案（ans（初始值为1）），则把临时计数的值赋给答案（ans），这样临时计数清零后可保留目前最长的连续数个数。最终每个数据都判断完成后输出答案（ans）

但要注意的是，计数时包括第一个数，所以临时计数和答案的初值都应为1，这样计数才会算上第一个，清零时其实是清“一”。


---

## 作者：Imakf (赞：27)

本蒟蒻第一次发题解


这是一个奇特的想法


用数组 sz[100000]存储下来所有的数，


然后从sz[0]开始看sz[i]==sz[i+1]-1如果满足 ans++(这个过程就是代码中的zc函数)


不满足则if(zc(i)>ans) ans=zc(i);


然而这个过程被我强行写成了一个递归函数


这道题还有坑点


一个数也是连号


ans 请一定初始化为0


上代码


```cpp
#include<iostream>
using namespace std;
int sz[100000];
int zc(int i) //从sz[i]开始，求连号的长度
{
    if(sz[i]==sz[i+1]-1)    return 1+zc(i+1);
    return 1;
}
int main()
{
    int sl,ans=0,i;
    cin>>sl;
    for(i=0;i<sl;i++)  //读入数据
    cin>>sz[i];
    for(i=0;i<sl-1;i+=)
    {
        if(zc(i)>ans)
        ans=zc(i);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Heartlessly (赞：26)

# 看见楼下的代码都比较复杂，给大家一个简单易懂的代码

```cpp
**输入样例**
10
3 5 6 2 3 4 5 6 8 9
**输出样例**
5
```

```cpp
#include <iostream>
#include <cstdio>//不推荐<bits/c++.h>的万能头文件，由于评测机问题，比赛可能不能用。
using namespace std;//本人虽然是c++党，但喜欢c党的输入，因为 scanf 实在是比 cin 快多了。
int n , a[10001] , s = 1, maxn;// n 表示序列长度，数组 a 表示输入的序列，s 用来计递增子序列的长度，maxn 为序列最大长度

。由于是全局变量，不需要设初值为 0 , 最重要的是子序列长度的初值是 1 ， 而不是 0 ，好好理解一下吧。
int main()
{
    scanf ( "%d%d", &n , &a[0] );//先输入第 1 个数，在之后第 2 个数更方便比较。
    for ( int i = 1 ; i < n ; i++ )//注意是 小于 n ，因为 a[0] 之前输入过了。
    {
        scanf ( "%d", &a[i] );//输入每一个数。
        if ( a[i] == a[i-1] + 1 )//如果输入的这个数是前面那个数 +1，
        s++;//子序列的长度增加 1。
        else//如果序列中断，
        s = 1;//子序列长度变回 1。
        if ( s > maxn )//如果子序列长度比 最大长度 大，
        maxn = s;//最大长度变为 该长度。
    }
    cout << maxn;//输出这个最大 长度 。
    return 0;
}
```
//方便一些^\_^

# 码字不易，希望对大家有帮助！


---

## 作者：梦冥 (赞：14)

```c
#include<bits/stdc++.h>  //万能头文件
using namespace std;
int n,a[10001],ans=1,ans1=1,b=1;  //将答案定为1，因为连号至少2个及以上
int main(){
    cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];  //输入
	for(int k=b;k<=n;k++){
		if(a[k+1]==a[k]+1) ans1++;  //判断是否为连号，如果是+1
		if(ans1>=ans) ans=ans1;  //连号比较，取较大的，再赋值给答案
		if((a[k+1]!=a[k]+1)&&(b<=n)){
		b++;  //如果连号断了，从下一个开始判断
		ans1=1;}  //因为重新判断，所以备用答案重新设为1
	}
	cout<<ans;  //输出
	return 0;
}
```
这个题目用个循环来判断，再用if语句判断。如果连号断了，重新循环，并更新备用答案。最后再与上个连号长度进行比较，选较大的一个长度，再赋值给答案并输出。

---

## 作者：CBW2007 (赞：13)

此题其实不用数组也能通过，只不过稍微有些难理解。

定义两个变量a,b。其中，a表示上一个数，b表示新读入的数。

按样例来说，a,b的交替是这样的：

	10
	3 5 6 2 3 4 5 6 8 9

| i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| a | 3 | 3 | 5 | 6 | 2 | 3 | 4 | 5 | 6 | 8 |
| b |   | 5 | 6 | 2 | 3 | 4 | 5 | 6 | 8 | 9 |

代码如下：

```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,a,b,s=1,maxn=0;//s代表当前连续长度，默认为1（因为第一个自己也算一个）；maxn代表最大连续长度。
    cin>>n;
    cin>>a;//输入第一个数
    for (int i=2; i<=n; i++)//注意从第二个数开始，因为第一个已读过
    {
        cin>>b;//输入当前数
        if (b-a==1)//如果与上一个数相差1
            s++;//当前连续长度+1
        else
        {
            if (s>maxn)//如果当前连续长度（不算自己）比最大连续长度长
                maxn=s;//更新最大连续长度
            s=1;//初始化（自己也算一个！）
        }
        a=b;//成为即将的“上一个数”
    }
    cout<<maxn;
    return 0;
}
```

评测传送门：[R8960739 评测详情 - 洛谷](https://www.luogu.org/record/show?rid=8960739)

---

## 作者：大犇≠大奔 (赞：11)

***看到很多很多  ~~无聊的~~  大佬用DP或  ~~百分之一亿会超时的~~  递归，个人觉得  ~~吃饱了撑的~~   没必要~***

***直接用差分数组，如果 d[i]==1就ans++***

~~弱弱的问一句，都知道差分数组吧~~

~~废话不说~~ 

**直接上代码！**
```cpp

//这是本蒟蒻第一次发题解，大犇勿喷； 
//了解一下芜湖市 NO.27 中学电脑班的蒟蒻 
//怀旧小学学的 LOGO 语言 
#include "cstdio"
int a[100005],d[100005];// 定义原数组和差分数组，个人喜欢空间开够 
int main(){ //TO P1420 :N 
	int n,ans=1,s=0;//s为当前有几个连号的，ans为最大连号数 
	scanf ("%d",&n);
	for (int i=1;i<=n;i++){//读入并对差分数组预处理 
		scanf ("%d",&a[i]);
		d[i]=a[i]-a[i-1];
	}
	for (int i=1;i<=n;i++){
		if (d[i]==1) s++;//如果两数差为 1即连号，当前数量++ 
		if (d[i]!=1){//如果a[i]和前面不连号，更新 ans ,s置 0
			if (s>ans) ans=s;
			s=0;
		}
	}
	if (ans>1) printf ("%d",ans+1);//如果ans>1既有连号，因为差分数组的原理，则需多加 1
	else printf ("1");  //如果ans==1既没有连号，则输出 1 
	return 0;// END 
}//相信都能看懂
```


---

## 作者：国服最强关羽 (赞：8)

```cpp
var n,p,i,max:longint;//max用来记最大的连续天数；
    a:array[1..10000] of longint;
 begin
  readln(n);
  read(a[1]);
  p:=1;//不管怎么样，第一个肯定是1；
  for i:=2 to n do
   begin
    read(a[i]);
    if a[i]=a[i-1]+1 then inc(p)//如果a[i]=a[i-1]+1，p就+1；
                     else begin if p>max then max:=p;p:=1;end;//不然，如果p>max，max:=p;p就变为1；
   end;
  writeln(max);输出max；
end.
```

---

## 作者：闫登科 (赞：5)

本蒟蒻第一次写题解了，莫名有点小激动！！！！ 
本人很菜，大佬们就不要嘲讽我了。
------------

好了回归正题。

其实这道题不是很难，其实只需要一点**DP**的小知识就行了。

首先我们分析下题目，要求最长的连号（从小到大连续自然数）的长度。

我们需要两个数组，一个存，另一个来记最长的个数（或用一个二维数组**a[i][2],其中a[i][1]来存数，a[i][2]来记最长值。**）

用个双重循环，一重是找数，另一重向后判断，一旦遇到不符合的就跳过后面的。

主要就是这个思路了，下面附上代码。
```cpp
#include<iostream>
using namespace std;
int n,a[10050],l[10050];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)//输入
    {
        cin>>a[i];
        l[i]=1;
    }
    for(int i=1;i<=n;i++)//取数
    {
        for(int j=i+1;j<=n;j++)//判断
        {
            if(a[j-1]==a[j]-1)
            {
                l[i]++;
            }
            else break;//剪枝（跳过后面的）
        }
    }
    int k=0;
    for(int i=1;i<=n;i++)//找最大的
    {
        //cout<<l[i];
        if(l[i]>k)
        k=l[i];
    }
    cout<<k;
    return 0;
}
```


---

## 作者：伟大的王夫子 (赞：4)

DP做法

设$f[i]$表示以i结尾的最长连号的长度,$a[i]$为第i个数,$n$为序列长度

容易列出状态转移方程

$f[i] = \underbrace{\max f[j] + 1}_{a[j]+1=a[i]}$

最后输出 $\underbrace{\max f[i]}_{i \leq  n}$

然后就上代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10010], a[10010], n, ans;//DP做法
int main() {
	cin >> n;
	for (register int i = 1; i <= n; ++i) cin >> a[i];
	for (register int i = 1; i <= n; ++i) {
		f[i] = 1;
		for (register int j = 0; j < i; ++j)
			if (a[j] + 1 == a[i]) f[i] = max(f[i], f[j] + 1);
		ans = max(ans, f[i]);
	}
	cout << ans;
}
```

最后请大家记住了，能够用DP求解的问题要有以下几点特征

- 最优子结构性质

- 无后效性（否则要高斯消元）

- 具有阶段可划分性

这题还算简单，相信一般人都能写出方程。要是题目难起来了，那就要动动脑筋了

可以想想

- 这个状态可以转移到那个状态

- 一个状态可以由哪几个状态得出

那样，思考起来可能会更加自然简便

最后还是安利一下[我的博客](https://www.luogu.org/blog/I-AK-IOI/)

---

## 作者：九指客 (赞：4)

```cpp
//水题一道，希望对大家有帮助；
#include<stdio.h>
#include<string.h>//头文件 
int main()
{
    int i,j,n,m,k=0,s=1;//定义； 
    int a[1001];
    scanf("%d",&n);//输入N； 
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//输入N个数； 
    }
    for(i=1;i<=n;i++)//寻找； 
    {
        if(a[i+1]==a[i]+1)//判断是否是连号； 
        {
            s++;
            if(s>k)
                k=s;
        }
        else s=1;//不是的话则返回1； 
    }
    printf("%d",k);//输出； 
    return 0;
}
```

---

## 作者：wangye714906 (赞：3)

这个题思路：先将输入的数用一个数组存起来，然后进行判断
话不多说，上代码


------------
这是蒟蒻的分割线


------------
```
#include<iostream>
using namespace std;
int a[10009];
int main()
{
	int n,maxs=0,cnt=0;
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>a[i];
	for(int i=0;i<n;i++)
	{
		if(a[i]+1==a[i+1])cnt++;//如果a[i]+1=a[i+1]，说明这是连号
		else if(cnt+1>maxs){maxs=cnt+1;cnt=0;}
	}
	cout<<maxs;
}
```
欢迎大佬指点
欢迎提意见
禁止抄袭，这不是好习惯

---

## 作者：小小小唐啊啊 (赞：3)

这是本蒟蒻发的第一篇题解，希望大家喜欢哦~~

我看比较简单的题也不用写那么长的代码吧。

旁注都写在注释里了，大家看吧。

上代码~
```cpp
#include<iostream>
using namespace std;
int main()
{
	int n,a,x,max=0,s=0;	//这道题其实不用开数组啦。n是总数，a是输入，x存储上一次输入的数据。max是存储最长的那个连号长度，s就是存储当前连号长度。
	cin>>n;
	for(int i=0; i<n; i++)
	{
		cin>>a;
		if(x+1==a)   s++;	//如果a能和上次输入的x相连，当前连号长度就递增。
		else    s=1;	//否则就将s设为1。因为一个数本身就能看作连号长度为1。
		x=a;	//x存储本次输入的值，以备下次用。
		if(s>max)   max=s;	//max存储最大值。
	}
	cout<<max;
	return 0;
}
```

#### 特别要注意那个“s=1”和s的初始化一定要为0！

---

## 作者：Dream_zhc (赞：3)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int k,n,a[10010],s,p=1;//在这里定义的目的是让变量的最初值为0
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];//这里用数组保存下来每个数
    for(int i=1;i<=n;i++)//第一个for循环，控制i从第一个号开始到第n个号
    {
        s=0;//每次都要清零
        if(a[i+1]==a[i]+1)//如果此时第i个数的下一个数(即i+1个数）比第i个数多1，才能继续判断后面是否一直在+1
        for(int j=i;j<=n;j++)
        {
            s++;//累加器s
            if(a[j+1]!=a[j]+1)//一旦相差不是1，退出循环
            break;
        }
        if(s>p)/*打擂台，比如此时i为1，那么s保存下来的是从1开始后面连号的长度，一定大于或者等于p，所以p一定等于s，当i变成2时，s保存下来的是从2开始后面连号的长度，如果大于前面那个，就用p保存最大的一个*/
        p=s;
    }
    cout<<p;//最后输出p即可
    return 0;
}
```

---

## 作者：lensent (赞：3)

题解：

本题连数组都可以不用开，只需要依次读入数据，比较后一数据与前一数据之差是否等于1，来判断是否是连续数列，若a2-a1=1，ans累加，否则累加器清零重新计数。


```cpp
program p1420;
 var
  n,a1,a2,i,ans,max:longint;
 begin
  readln(n);
  ans:=0;max:=0;
  read(a1);
  for i:=1 to n-1 do//之前已经读入一个数据，所以少循环一次
   begin
    read(a2);
    if  a2-a1=1 then inc(ans) else ans:=0;//判断是否是连续序列
    if ans>max then max:=ans;//用max来存储连续的最大长度
    a1:=a2;//交换前后两个数据以便继续读入和比较
   end;
  writeln(max+1);
end.
```

---

## 作者：封禁用户 (赞：2)

[题目](https://www.luogu.org/problem/P1420)

~~这么简单的题居然交了3次，还下载2次数据。。~~

首先，题目要好好看：
### 连号指从小到大连续自然数

注意！是连续的自然数！

本蒟蒻的思路：一个一个读入，每次读入跟前面比对一下，如果是连续的，则连号统计数+1。如果不符合，先让连号统计数与最大数比较，取大的。


40分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int a,n,ans=0,b,m=-1;
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a;
		if(i>1&&a-1==b) {
			ans++;
			b=a;
		} else if(i>1) {
			m=max(m,ans);
			b=a;
		}
	}
	cout<<m<<endl;
	return 0;
}
```
很容易发现，这里**ans的初始化应该是1**。

~~循环里貌似没初始化。。~~

为什么呢？

因为不管怎么样，总是有一个数符合要求的。之后，每找到一个连号，ans+1。

80分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int a,n,ans=1,b,m=-1;
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a;
		if(i>1&&a==b+1) {
			ans++;
			b=a;
		} else if(i>1) {
			m=max(m,ans);
			b=a;
			ans=1;
		}
	}
	cout<<m<<endl;
	return 0;
}
```
错在哪呢？

你看，如果i=1，b就没有被赋值，而b是局部变量，初始值是一个随机数，就会出现错误。

100分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int a,n,ans=1,b=-100,m=-1;//都初始化啦
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a;
		if(i>1&&a==b+1) {//如果有连号
			ans++;
			b=a;
		} else if(i>1) {
			m=max(m,ans);//取较大值
			b=a;
			ans=1;//ans初始化
		}
	}
	cout<<m<<endl;
	return 0;
}
```


---

## 作者：5ab_juruo (赞：2)

这道题有两种做法（反正我只想到了这两种）：
一是利用递推。设a[n]是第n+1项的连号数，若第n+2项是连号，那么a[n+1]=a[n]+1;否则a[n+1]=1。第二种则是统计连号数，不断更新最大值（我就是这么做的）。那我们就开始~~撕逼~~编程吧~

------

首先我们要明白怎样才能做到统计连号？
1.设计一个变量，让它记录连号数，如果没有连号，则更新为1，否则就加一。
2.设计一个最大值，存储当前最长连号。
变成程序就是下面这个样子:
```cpp
for(int i=0;i<n-1;i++)//如果到n，就会数组越界
{
	if(arr[i]==arr[i+1]-1)//有连号就加1
		ct++;
	else
		ct=1;//没连号就更新为1
	if(ct>mx)
		mx=ct;//统计最大值
}
```
剩下的部分就只有输入输出了~~所以咱直接连成程序：
```cpp
#include<iostream>
using namespace std;//习惯，不要问为什么

int main()
{
	int n,mx=1,ct=1;         //特别注意ct的初始值，为什么是1？
	cin>>n;
	int arr[n];              //因为n并不大，可以开在main()里边
	for(int i=0;i<n;i++)
		cin>>arr[i];         //输入
	for(int i=0;i<n-1;i++)
	{
		if(arr[i]==arr[i+1]-1)
			ct++;
		else
			ct=1;
		if(ct>mx)
			mx=ct;
	}
	cout<<mx<<endl;            //输出
	return 0;
}
```
总结：
1.进行计数时，用两个变量，一个用于存储当前连号，一个用于存储最大值。
2.更新时初始值记为1。

---

## 作者：Divinitist (赞：2)

暴力模拟或线性DP可过。

（模拟代码）

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int a[10001];//a数组储存数据
int main()
{
    int n,s=0,mx=0;//s储存连号长度，mx储存最大连号长度
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    for(int i=2;i<=n;i++)
    {
        if(a[i]==a[i-1]+1) s++;
        else
        {
            s++;//当前数据与上一数据不形成连号时，当前数据长度（1）也要计入上一次的连号长度中
            mx=max(s,mx);//最大长度
            s=0;//清空，准备下一次长度统计
        }
    }
    if(mx) cout<<mx;
    else cout<<s;//当整个统计过程没有断点时，mx将不会获得值，故直接输出s
    return 0;
}
```

---

## 作者：起名真的很难 (赞：2)

其实这道题没必要用数组，我只用了5个变量了事（这样比较省内存，高性能嘛）

以下是超级简单明了的代码！

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,last=-1,now,tot=1,max_=1;//max_和tot都赋初值为1
int main()
{
    scanf("%d",&n);//输入n
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&now);//输入now
        if(now==last+1)//如果比上一个大1计数器++
        tot++;
        else//否则变成1，再变成1之前还要看看比不比最大值大
        max_=max(max_,tot),tot=1;
        last=now;//现在这个数就是下一个数的上一个数（一阵晕眩）
    }
    printf("%d",max_);
    return 0;
}
```

---

## 作者：莫宏骏 (赞：2)

//没什么难的，注意一下如果没有连字符也是1就可以了

```cpp
#include<stdio.h>
#include<string.h>
int main()
{
//freopen(".in","r",stdin);
//freopen(".out","w",stdout);
    int i,j,k,n,a[20005],s=0,max=1;//max=1，没有连续的情况也能输出1
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);
    for(i=1;i<=n;i++)//循环求解
    {
        s=0;
        if(a[i+1]-a[i]==1)
        for(j=i;j<=n;j++)
        {
            s++;//计数
            if(a[j+1]-a[j]!=1)
            break;//省时间
        }
        if(s>max)
        max=s;
    }
    printf("%d",max);
//fclose(stdin);
//fclose(stdout);
    return 0;
}
```

---

## 作者：亿年已过 (赞：2)

**蒟蒻的第七篇题解qwq**

### 这题是真的~~水~~啊

先上代码，解释都在代码里了：

```
#include<bits/stdc++.h>
using namespace std;
int n,y,a[10005],i=1,s=1,t;//y是前一个数，s是用来计算当前连号的长度，t是最后答案
int main()
{
    cin>>n>>y;//输入n和n个数中的第1个数
    for(i=2;i<=n;i++)//因为n个数中的第一个数在前面已经输入，所以，i从2开始
    {
        cin>>a[i];//输入n个数中第i个数
        if(a[i]-y==1)s++;//如果当前的数-前面一个数=1的话，那这就是一段连号，s++
        else s=1;//否则，s变成1
        if(s>t)t=s;//如果当前连号的长度>最后答案，把当前连号的长度赋值给最后答案
        y=a[i];在i++之前把当前的数赋值给前面一个数
    }
       cout<<t;//输出
       
    return 0;//结束
}
```


---

## 作者：H战牛乀暴走H (赞：2)

```cpp
var
  i,n,ans,max,x,y:longint;
begin
  readln(n);
  read(x);
  ans:=1;
  for i:=2 to n do  //因为已经读入了一次x，所以循环从二开始做
  begin
    y:=x;  //把上一个数赋给y
    read(x);
    if x-1=y then
      inc(ans)   //假如构成了连号，则加一 else// 假如没有构成连号
      begin
        if ans>max then  把大的答案给max
          max:=ans;
        ans:=1;  //ans重置为一
      end;
  end;
  if ans>max then
    max:=ans;
  writeln(max);
end.

```

---

## 作者：紫金依旧 (赞：2)

这题说白了就是一道~~大大大大水题~~

这题的正解——***模拟***

于是乎——上代码：


不太华丽的分割线
------------


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int ans=1,n,ai,ai2=0,maxn=1;//maxn必须设为1，否则会导致有maxn=0的问题
	cin>>n;
	cin>>ai2;//ai2是之前一个数
	for(int i=2;i<=n;i++)
	{
		cin>>ai;//后一个数
		if(ai==ai2+1)
			maxn++; //如果后一个是大于前一个数，则这次的连号长度+1
		else
			maxn=1;
		if(maxn>ans)
			ans=maxn;//刷新ans
		ai2=ai;			
	}
	cout<<ans;//输出
	return 0;
}
```
# 打造文明洛谷，拒绝抄袭

---

## 作者：≮Stupid≯ (赞：2)

用循环一个个判定过去

```cpp

#include<stdio.h>       
int main()        
    {        
    int a; 
    scanf("%d",&a); 
    int l=0,s,s2,maxl=0;      
    scanf("%d",&s); 
    l=1;      
    for (int q=1;q<a;q++){
        scanf("%d",&s2); 
        if (s2-s==1)
        l++; 
        else {
             if (l>maxl)
             maxl=l; 
             l=1;
             }
             s=s2;
             }      
    if (l>maxl) 
    maxl=l;    
    printf("%d",maxl);      
    return 0;       
    }        

```

---

## 作者：骗分过样例 (赞：1)

### 这道题不是挺简单吗？？
### 为什么我第一次提交会WA？？
~~其实，这道题满是坑。。。~~
理解题意。

上代码

```cpp
#include<bits/stdc++.h>	//懒人专用 
using namespace std;
typedef long long ll;
int main()
{
	ll a[10001]={0};
	int i,n,maxn=0,cnt=0;
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]==a[i-1]+1)	cnt++;	//比前一个大1就加1。 
		else
		{
			maxn=max(cnt,maxn);		//取大的。 
			cnt=1;					//从一开始继续算。
		}
	}
	maxn=max(cnt,maxn);				//最后特判一下，否则WA等着你。 
	cout<<maxn;						//输出！！ 
	return 0;
}
```


---

## 作者：墨蛋糕 (赞：1)

//C++ Answer
做法和其他巨佬大概差不多，不过提示一下，初始化不要等于0。给一个很大的负值就好。
运行耗时恒定13ms
```
#include <iostream>
using namespace std;

int main(){
    int sum = 1;
    int cache = 1;

    int N;
    cin>>N;
    
    int a[10001] = {-25565};

    for(int i = 1 ; i <= N ; i++)
    {
        cin>>a[i];
    }

    for(int i = 1 ; i <= 10001 ; i++){


        if(a[i] - a[i-1] == 1){
            cache++;
            if(cache > sum){
                sum = cache;
                continue;
            }


        }else
        {
            if(cache > sum){
                sum = cache;
                cache = 1;
                continue;
            }
            else{
                cache = 1;
                continue;
            }

        }

    }
    cout<<sum;
    return 0;
}
```


---

## 作者：灬Amiya灬 (赞：1)

看了一下，完全可以不需要数组的
虽然也没有这个必要，但就是想写一写不用数组的，hhh(毕竟能省空间就省嘛)
```java
import java.util.Scanner;

public class Main {
        static int n;
        static int max=1;
        static int count=1;
    public static void main(String[] args) {
        // TODO 自动生成的方法存根
        init();
        System.out.println(max);
    }
    private static void init() {
        // TODO 自动生成的方法存根
        int first = 0;
        int now;
        int last = 0;
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        last = in.nextInt();
        for(int i=1;i<n;i++) {
            now =in.nextInt();
            if(now==last+1) {
                count++;
            }
            else {
                if(count>max)max=count;
                count=1;
            }
            last =now;
        }
        if(count>max)max =count;
    }

}
```

---

## 作者：Johnson_32Bit (赞：1)

# 入门难度的dp？
比较QwQ

其实就是线dp

代码如下：
```
#include<iostream>
using namespace std;
int main()
{
    int n,len=0,cur=0,max=-1;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int c;
        cin>>c;
        if(c-cur==1)
        {
            cur=c;
            len++;
            if(len>max) max=len;
        }
        else
        {
            len=0;
            cur=c;
        }
    }
    if(max==1) cout<<1;
    else cout<<max+1;
}
```

---

## 作者：C_Zn (赞：1)

这是本蒟蒻的第一篇题解，希望能通过。
这道题，就是一个简单的循环+小小的判断，我则是采用了一种比较省内存和时间的做法，把输入和判断套在一起，这样可以在一次1~n的循环中做完这道题，并且省去了一个数组的大小，~~这样就不用看最下面的数据范围了~~。

这道题就是读明白题基本就可以了，一定注意，
## **连号指从小到大连续自然**
~~有多少人和我一样上来就做成最长不上升子序列~~

好了，言归正转，放代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<string>
#include<cmath>     //这一堆头文件懒得打都是缺省源搞的，可能有些没用 
using namespace std;
int a,b,i,ans,maxn,n;
int main()
{
	scanf("%d",&n);
	a=-0x7f7f7f7f;//一个非常小的数，为了不和里面的数重合 
	ans=1;        //一定是1啊。因为最长连号的串里有自己啊！我就在这里死了好几次 
	maxn=1;       //最长的长度最小值肯定是1 
	for(i=1;i<=n;i++)
	{
		cin>>b;    //输入那个数 
		if(b==a+1)
		  {
		  	 ans++;   //判断一下如果是连号的那么ans++ 
		  }
		  else
		  {
		  	 maxn=max(maxn,ans);//如果不连了，就看看现在的是不是最长的 
		  	 ans=1;  //注意是1啊 
		  }
	    a=b;  //记录一下前面的数 
	}
	printf("%d",maxn);//输出最大值就可以了 
    return 0;
}

```

---

## 作者：autoint (赞：1)

###法一：

##这道题类似最长上升子序列，不过因为要求的是连续自然数，所以递推方程为

#    f[i]=1+(a[i]==a[i-1])?:f[i-1]:0;

时间复杂度为O（n）。

其实可以不存数组直接在线做，不过数据只有10000（这说明可以不用dp)，没有空间优化的必要。

下面是代码：



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<stack>
#include<queue>
#include<set>
#include<map>
#include<algorithm>
#define INF 2147483647
using namespace std;
int a[10100],f[10100]={0,1};
int ans=0;
inline int read(int&x) {
    int data=0,w=1;
    char ch=0;
    while(ch!='-' && (ch<'0' || ch>'9')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch>='0' && ch<='9') data=data*10+ch-'0',ch=getchar();
    return x=data*w;
}
inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
//以上为输入输出优化
int main(){
    int n;
    read(n);
    read(a[1]);//从2开始处理
    for(int i=2;i<=n;++i){
        read(a[i]);
        if(a[i]==a[i-1]+1)
            f[i]=f[i-1]+1;
        else
            f[i]=1;
        if(f[i]>ans)
            ans=f[i];
    }
    write(ans);
    return 0;
}
```
###法二：
##由于只有10000的数据，我们可以枚举区间。

时间复杂度为O（n^2）。我相信这代码人人都会，不需要解释。

代码自己打。


---

## 作者：合451518 (赞：1)

思路：边读边处理，last记录上一次读入的结果，t记录当前读入的结果。

如果t-last=1说明t,last是连续上升自然数，s加1，替换last的值。

如果t-last<>1则将s与ans打擂台，并将s:=1;

注意：s只是临时计数器，最后应输出ans,

代码：

 
 
```cpp
var
 n,t,last,ans,s,i:longint;
begin
 readln(n);
 last:=0;
 ans:=0;
 s:=0;
 for i:=1 to n do begin
  read(t);
  if t-last=1 then begin last:=t;inc(s);end
   else begin last:=t;if s>ans then ans:=s;s:=1;end;
 end;
 write(ans);
end.
```

---

## 作者：magolor (赞：1)

比较短的一种方式ab代替数组



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int main()
{
    int n,a = -2, b, cnt = 1, maxi = 1;
    for(cin >> n; n--; a=b)
        cin >> b, cnt = (b-a-1) ? 1 : (maxi=max(maxi,cnt+1),cnt+1);
    cout << maxi << endl;
    return 0;
}
```

---

## 作者：Megumi_Cold (赞：1)

```cpp

#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;
int main()
{
    int a,b=0,d=1,h=1,zd=1;//h和zd默认为1，因为至少有一个连着
    cin>>a;//输入
    int c[a];
    while (b<a)//最近很喜欢用while写题
    {
        cin>>c[b];//输入
        b++;
    }
    while (d<a)
    {
        if (c[d]==c[d-1]+1)//如果这个数比上个数大1
        h++;//连续+1
        else//不然
        h=1;//让连续变成1
        if (h>zd)//如果比最大连号还大
        zd=h;//最大就是连续
        d++;
    }
    cout<<zd;//输出最大
    return 0;
}

```

---

## 作者：枍暮77 (赞：1)

的确是很简单的一道题。。。。。。看似很麻烦，其实连数组都不用。。。两个连续的自然数必须相差一，只需要用循环一个个读入比较就可以了。。。。。。用数组会将题目复杂化。。。。。。

```delphi
     var  
     n,a,b,c,i,j,x,t:longint;  
    begin  
     readln(n);  
     read(a);  
     t:=1;  
     c:=a;  
     x:=1;  
     for i:=2 to n do  
      begin  
       c:=c+1;  
       read(b);  
       if b=c then t:=t+1  
        else  
         begin  
          c:=b;  
          if t>x then x:=t;  
           t:=1;  
         end;  
        a:=b;  
        end;  
      writeln(x);  
    end.   
```

---

## 作者：Skywalker_David (赞：1)

每输入一个数，和上个数比对即可。

```cpp
var
    n,i,x,max,a,b:longint;
begin
    readln(n);
    read(a);
    x:=0;
    max:=0;
    for i:=1 to n-1 do begin
        read(b);
    if b-a=1 then inc(x)
        else  begin
            if x>max then
                max:=x;
                x:=1;
        end;
        a:=b;
    end;
    if x>max then max:=x;
    write(max);
end.
```

---

## 作者：谁懂谁伤心 (赞：1)

这题看似麻烦，其实不然，这题甚至连数组都不用，只需每输入一个数，和上个数比对即可。

```cpp

    #include<iostream>      
    using namespace std;      
    int main()      
    {      
    int a; cin >>a; int l=0,s,s2,maxl=0;    
    cin >>s; l=1;    
    for (int q=1;q<a;q++){cin >>s2; if (s2-s==1)l++; else {if (l>maxl)maxl=l; l=1;}s=s2;}    
    if (l>maxl) maxl=l;  
    cout <<maxl;    
    return 0;     
    }      

```

---

## 作者：霍士弘 (赞：0)

# $dp$解法
## 前言
广告：[最长上升子段](https://www.luogu.org/blog/137469/ru-he-yong-gao-ya-de-fang-shi-jie-jue-yi-dao-hong-ti
)  
这一道题目我采用$dp$的解法。  
## 如何$dp$？  
### 设计状态转移
设$f[i]$为以$a_i$结尾的最长连号。  
比如$a$为$\left \{ 1,4,5,6,2 \right \}$  
则$f[2] = 2,f[5] = 1$  

怎么转移？  
我们有两种情况：  
①$a_i - a_{i-1} = 1(i > 1)$ （可以接上上一位的最长连号）  
$$f[i] = f[i-1] + 1$$ 
（把自己接上去）  
②$a_i - a_{i-1} \not = 1 (i > 1)$ （不能接上）  
$$f[i] = 1$$  
（还有自己）    
答案取$\max f[i]$    
### 边界条件
$f[all] = 1$  
最开始的时候，每一位结尾的最长连号长度都为$1$  

### 后效性处理  
为什么我们要设$f[i]$为以$a_i$**结尾**的最长连号？  
这是为了方便下一位的最长连号能接上这一位。  
也就是说当状态为$i$的时候，我们选的最长连号不是以$i$结尾的，则计算$f[i+1]$的时候不能接上$f[i]$，因为会出现不连续的情况。  
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[10005];
int f[10005];//dp数组

int main()
{
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>a[i];
	}
	for(int i = 1;i <= n + 2;i++)
	{
		f[i] = 1;//边界条件
	}
	for(int i = 2;i <= n;i++)
	{
		if(a[i] - a[i-1] == 1)//可以接上
		{
			f[i] = f[i-1] + 1;//接上自己
		}else//接不上
		{
			f[i] = 1;//还有孤零零的自己嘛
		}
	}
	int maxx = -100;//答案
	for(int i = 1;i <= n;i++)
	{
		maxx = max(maxx,f[i]);//取maz
	}
	cout<<maxx;//输出答案
	return 0;
}
```  
本蒟蒻才初二，太菜了，如果有什么错误请dalao们指出OrzOrz

---

## 作者：Jimmy000 (赞：0)

我们可以那一个东西记录连号长度

再拿一个东西记录最长连号

所以
### 思路如下
1. 定义a数组输入      o记录连号   max记录最长连号
1. 如果a[i]==a[i-1]+1则为连号  o++  max记录
1. 如果a[i]！=a[i-1]+1则连号中断 o=1因为a[i]可视为一个起始数故o=1
1. 输出最长连号max

```
#include<bits/stdc++.h>
using namespace std;
int a[2000000];
int main() {
	int n,max=1,o=1;
	cin>>n;
	cin>>a[1];
	for(int i=2;i<=n;i++)
	{cin>>a[i];
	 if(a[i]==a[i-1]+1) //如果a[i]==a[i-1]+1就为连号
     {o++;
	 					if(o>max) max=o;//max记录最长连号
      
	 					}
	 else o=1;
	}
	cout<<max;
	return 0; 
}
```
就是以上这些 就没有然后了

---

## 作者：吟游诗人坷 (赞：0)

本蒟蒻的第一篇题解。。。

自我感觉良好，求通过。。。

回归正题，这道题只是一个简单的模拟。

根本不用递归，~~用数学方法想一想就会写了~~。

这道题时限和空间限制很松，o(n)就能过。

不多说了，上你们喜欢的代码：
```c
#include<bits/stdc++.h>		//我很万能 
using namespace std;		//新手建议码上 
int num[10000];				//存储数据 
int main(){
	int n;
	cin>>n;					//输入数据个数，如题 
	for(int i = 1;i<=n;i++)
	{
		cin>>num[i];		//输入数据	
	}
	int sum = 1,maxn = 0;	//sum== /*累加器*/，maxn== /*最大值和答案*/ 
	for(int i = 1;i<=n;i++){
		if(num[i]+1==num[i+1]){
			sum++;			//累加求和 
		}else{
			sum = 1;		//回溯 
		}
		if(maxn<sum){
			maxn = sum;		//保存最大值，或者说保存答案 
		}
	}
	cout<<maxn<<endl;		//输出大家喜欢的答案 
	return 0;				//新手建议码上  
}							// THE END 
```
*注意*：sum 必须要等于 1 才可以哦，因为第一个数字还没有加上去哦（直白地说：如果这个连号只有一个数据并且 sum = 0 的话，就会直接输出 0 哦！）【这也是这道题的关键之一】

PS：C++代码，注意点赞和收藏哦！

~~记得评论鸡你太美哦！~~

---

## 作者：liusnoi (赞：0)

## 分析问题
- 最长连号，首先求连号，然后比较这几对连号谁最长并输出
- 连号及后一位比前一位大1，可以将数据录入数组num[n+1]，比输入数字多1个元素num[n],且num[n]=0；这样保证数组循环时i+1不会越界；设置为0保证其不能与前面的数连号。
- 最小连号数是1，因此赋初值ans=1，若有连号，在此基础上+1；
- if判定，若后一个数比前一个数大1（连号），则ans++，继续比较下一个数；如果为假（断连），则比较max与ans的值，将大者存入max，ans还原为初始值1，继续比较，直到比较至最后一个值0。
- 每次断连都会将ans较大者存入max。
- 输出max。

## 代码

```cpp
//P1420 最长连号
#include<iostream>
using namespace std;
int main()
{
	int n, i, ans=1, max=0;
	cin>>n;
	int num[n+1]={};
	for(i=0; i<n; i++)
		cin>>num[i];
	for(i=0; i<n; i++)
	{
		if(num[i+1]-num[i]==1)
			ans++;
		else
		{
			if(max<ans)
				max=ans;
			ans=1;
		}
	}
	cout<<max<<endl;
	return 0;
}
```


---

## 作者：Kai0514 (赞：0)

【洛谷】最长连号
原题传送门

#思路
码风丑丑哒

尽管是一道入门级别的水题，n<10000，暴力就可以过，但若n<100000000，就需要我们伟大的动态规划出场了QAQ。

运用DP，我做出了O（n）的算法。

dp[i]表示从上一个连号被中断的数字的下一个到第i个的连号长度。

有点难理解哈，看状态转移方程吧：

dp[i]=dp[i-1]+1（no[i]=no[i-1]+1)

dp[i]=1           （no[i]≠no[i-1]+1)

（no[]表示输入的数组）

我们还需要一个tans来记录当前连号长度，若tans>ans，则将ans设置为tans，若连号中断，则将tans重置为1。

剩下的就是水代码了QAQ.

#Code
```
#include<iostream>
#include<cstdio>

using namespace std;

const int MAX=10001;
int dp[MAX],no[MAX];
int n,ans=1,tans; 

int main()
{
    //初始化
    dp[1]=1;
    //freopen("testdata(3).txt","r",stdin);
    //读入
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>no[i];
    }
    
    //装叉走起
    for(int i=2;i<=n;i++)
    {
        if(no[i]==no[i-1]+1)
        {
            dp[i]=dp[i-1]+1;
            tans++;
            if(tans>ans)
            {
                ans=tans;
            }
        }
        else
        {
            dp[i]=1;
            tans=1;
        }
    }
    
    //输出
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：WatchmanIce (赞：0)

作为一名c++的选手，我当仁不让的使用了简单的做法。
# 方法:简单排序+判断

```

#include<bits/stdc++.h>
#include<iostream>
#include<algorithm>
#include<cstdio>//一坨源代码开头
using namespace std;
int a[10000],n;//先定义一下数组和长度
inline long long read(){
    long long x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}//这是一个快速读入，省时间的
```
详解：快速读入

快读其实就是一种把数字拆分成多个字符读入的方法，有链接附上：[浅谈C++ IO优化——读优输优方法集锦](https://www.luogu.org/blog/encore/io-you-hua-nei-suo-shi)
```
void print(int x){
   if(x<0){
       putchar('-');
       x=-x;
   }
   int y=10,len=1;
   while(y<=x){
       y*=10;
       len++;
	}
   while(len--){
		y/=10;
		putchar(x/y+48);
		x%=y;
   }
}//这里就是一个输出优化，和上面一样
```
把数字转化为字符输出

注：putchar（）的用法：
putchar非常简单，就是把你要输出的数字什么的都转化为字符（数字就是加上48）详见ASCLL码的转化表
```
void qsort(int ll,int rr){
    int m=a[ll];
    int i=ll,j=rr;
    while(i<j){
        while(i<j&&a[j]>m)j--;
        if(i<j)a[i]=a[j];
        while(i<j&&a[i]<=m)i++;
        if(i<j)a[j]=a[i];
    }
    a[i]=m;
    if(ll<i-1)qsort(ll,i-1);
    if(i+1<rr)qsort(i+1,rr);
}//快速排序，无需多讲，将其转化为二分的思想解释
void change(int n,int p){
	for(int i=n;i<p;i++){
		a[i]=a[i+1];
	}
}//这个函数在主程序中是用来将重复的数字从数组中删除的（数组删除）
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);//累赘，不过还是用了
	n=read(); 
	
	for(int i=1;i<=n;i++)a[i]=read();
	qsort(1,n);//先将其排序
	for(int i=1;i<n;i++){
		if(a[i]==a[i-1]){
			change(i,n);
			n--;
		}//判重，去重
	}
	
	long long ans=0,p=1;
	for(int i=2;i<=n;i++){
		if(a[i]==a[i-1]+1){
			p++;
		}else{
			ans=max(ans,p);
			p=1;
		}
	}
```
这里至关重要！！！！！！
就是把升序序列中的数字统计一下！！！
```
	print(ans);
	return 0;
}
```
好了总结一下，这道题目其实非常简单，就是你要想到他的方法，去排序，判重，以及统计。好了，这道题的分析就到这里了！！！

---

## 作者：lcf3241142097 (赞：0)

初次做题解，请多多包涵 ~\(≧▽≦)/~啦啦啦

说真的，其实我一开始做这题的时候掉了两个坑。。。。。。

一是数组的范围（【划掉） 二是当啊a[0]=0,a[1]=1的时候，a[i]=a[i-1]+1就会成立，蛋其实是不成立的。。。。。。


接下来看代码：

```cpp
var
        n,i,ans,b:longint;  //n题目里有，自己看，i就不用解释了，ans是出现连号的数量，b是出现连号最多的次数
        a:array[0..10000] of longint;  //这里要[0..10000],不能[1..10000],不然就会201(范围检查错) 
begin
        readln(n);  //先读入
        for i:=1 to n do
        begin
                read(a[i]);
        end;
        for i:=1 to n do
        begin
                if (a[i]=a[i-1]+1) and (i<>1) then inc(ans) else   //这里就要注意了，（i<>1这是为了解决上面第二个坑的，就是为了排除这种情况）
                begin         （接上面）//a[i]=a[i-1]+1就是为了判断两个数是不是连号
                        if ans>b then b:=ans;   //如果出现连号的次数大于最多的次数那么就存入
                        ans:=0;   //一定要清零，不然就会累积起来
                end;
        end;
        writeln(b+1);  //最后输出
end.

```

---

## 作者：EAT_NH4HCO3 (赞：0)

#这道题不要用到动规

###不要想太多了

要点有几个

- 判断后一个数是否比前一个数大一

- s初值为1

- 如果条件不成立时先判断s>max

附上代码


···cpp

```cpp
//fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuck
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=10001+10;
int a[MAXN];
int main()
{
    ios::sync_with_stdio(false);
    int n,s=0,max=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<n;i++)
    {
        if(a[i+1]-a[i]==1)s++;
        else
        {
            if(s>max)max=s;
            s=1;
        }
    }
    cout<<max;
    return 0;
}
···
```

---

## 作者：eggegg (赞：0)

这个办法既简单又好理解，用了一点点点点点点点点的动态规划（趋近于0用了动态规划）

那么算法就两个for，第一个for，输入，第二个for，解决问题，就是这么简单不用瞎模拟233333

```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
int n,f[10001],x,num[10001],ans=1;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>num[i];
        f[i]=1;
    }
    for(int i=2;i<=n;i++){
        if(num[i]==num[i-1]+1){
            f[i]=f[i-1]+1;
            ans=max(ans,f[i]);
        }
    }
    cout<<ans;
}

```

---

## 作者：H2O3 (赞：0)

这个题啊，是个有一点点水平的模拟题。但是仍然会有几个小坑。

...
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
using namespace std;
int n;
int a[10010];//a数组必须开的稍微大一点，并且必须全部清零，结果在下面
int ans;
int sum=1;//因为最长连号要算上第一个（最小的哪一个），所以sum初始为1
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    for(int i=1;i<=n;i++) //这里我选择的是全部循环一边，因为数组开大并且清零的原因，所以第n+1个是0，不可能达成连号（其实循环到n-1也行）   
    {
        if(a[i]+1==a[i+1])//后面那个比前面那个大1，就可以算作一个连号。
        sum++;
        else sum=1;//中断的话就立刻归1（应该是归零，然而连号的第一位也是一个数字，所以变回1）
        ans=max(sum,ans);//立刻存一下
    }
    cout<<ans<<endl;
    return 0;
}
...
```

---

## 作者：ZigZagKmp (赞：0)

作为一名刚刚学完dp的蒟蒻，我不得不说，用一个dp数组基本可以达到一次循环内只做5次运算，总体空间复杂度为O(n)。

废话不多说，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[10005],a,ma,a1;//dp[i]表示第i个数它的连数长度，a表示读入的数，a1表示上一次读入的数，ma(x)表示当前最大连数长度
int main()
{
    int i,n;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>a;
        if(a==a1+1&&i>1)//因为存在第一个数就是1，所以要进行判断
            dp[i]=dp[i-1]+1;//如果是上一个数的连数，就记作上一个数连数长度+1
        else
            dp[i]=1;//否则，重新计数
        ma=max(dp[i],ma);//取最长连数长度
        a1=a;//必须放后面，如果放过前面了，就会出现a1=a而答案为1
    }
    cout<<ma;
    return 0;//完美结束
}

```

---

## 作者：封禁用户 (赞：0)

入门级水题，像我连数组都懒得用。。。

```cpp
var i,x,y,n,ans,max:longint;
begin
  read(n);ans:=1;
  for i:=1 to n+1 do
  begin
    y:=x;//y记录上一个数字
    if i<>n+1 then//到n+1是为了防止最后的连号不和max比较
    read(x);
    x:=x+2;//这个是防止和第0个数比较（即第一个数为1时）
    if x=y+1 then ans:=ans+1
    else
    begin
      if ans>max then max:=ans;
      ans:=1;
    end;
  end;
  write(max);
end.
```

---

## 作者：Memory_of_winter (赞：0)

```cpp
var
 n,a,b,ans,o:longint;
 s:array[0..10000]of longint;//存读入的数
begin
 s[0]:=maxlongint;//这样下面就不用判断越界，也不用担心会影响答案
 readln(n);//读入有几个数
 for a:=1 to n do read(s[a]);//读入这n个数
 o:=1;//现在的答案，因为不管怎么样答案至少为1，所以赋值为1
 ans:=1;//存答案
 for a:=1 to n do
  begin
   if s[a]-s[a-1]=1 then//判断这个数和前一个数是不是连续的
                     begin
                      inc(o);//是的话现在的答案加1
                      if o>ans then ans:=o;//如果现在的答案比答案大，那么答案赋值为现在的答案
                     end
                    else o:=1;//不是的话现在的答案清为1
  end;
 writeln(ans);//输出答案
end.
```

---

## 作者：cyr2003 (赞：0)

```cpp
var a:array[1..10000] of longint;
      n,i,c,j,d:longint;
begin
 readln(n);
 c:=1;//连续的数开始置1
 d:=0;//最长连号置0
 for i:=1 to n do read(a[i]);
 for i:=1 to n do
  if a[i+1]-a[i]=1 then inc(c)//如果后一个数等于这个数加1，那么连续的数加1
                        else begin
                                                   if c>d then d:=c;//如果这个连续的数量大于当前最大的连续数量，那么就把最大的连续数量换掉
                                                           c:=1;//连续的数重新置1
                                              end;
 writeln(d);
end.
```

---


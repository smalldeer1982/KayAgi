# 小鱼会有危险吗

## 题目描述

有一次，小鱼要从 A 处沿直线往右边游，小鱼第一秒可以游 $7$ 米，从第二秒开始每秒游的距离只有前一秒的 $98\%$。有个极其邪恶的猎人在距离 A 处右边 $s$ 米的地方，安装了一个隐蔽的探测器，探测器左右 $x$ 米之内是探测范围。一旦小鱼进入探测器的范围，探测器就会在这一秒结束时把信号传递给那个猎人，猎人在一秒后就要对探测器范围内的水域进行抓捕，这时如果小鱼还在这范围内就危险了。也就是说小鱼一旦进入探测器范围，如果能在下 $1$ 秒的时间内马上游出探测器的范围，还是安全的。现在给出 $s$ 和 $x$ 的数据，请你判断小鱼会不会有危险？如果有危险输出 `y`，没有危险输出 `n`。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq s,x\le100$，小数点后最多有 $6$ 位小数。

## 样例 #1

### 输入

```
14 1```

### 输出

```
n```

# 题解

## 作者：CFLConyn (赞：1079)

超级蒟蒻~~第一次~~来写题解啦！~~必须先装成一个大佬！不然会被泥萌唾弃QAQ~~


------------


------------


------------

~~首先，我们必须放空心灵，想象出一条像钢筋一样笔直的波光粼粼的尼罗河，河岸边从零开始标记出了了一个个完美的刻度。一只活泼可爱、鲜嫩美味的鱼儿从起点~“0”诞生。。。~~

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
double meter=7,s,x,l,r,now=0;//生成波光粼粼的河水和小鱼儿。 
int main()
{
	cin>>s>>x;               //邪恶的猎人埋下了罪恶的探测器。 
	l=s-x;                   //死亡探测器往左边最多扫到的地方。 
	r=s+x;                   //死亡探测器往左边最多扫到的地方。 
	for(;;)                  //坚持不懈的鱼儿向着死亡游去。 
	{
		if (now>r)           //鱼儿的坚持感动了上苍，直接跳过了探测器的扫描范围。 
		{
			cout<<'n';       //活着！！ 
			return 0;        //程序的结束------世界的消逝。 
		}
		if (l<=now&&now<=r)  //被探测器扫到！核弹是否发射？？ 
		{
			if (now+meter>r) //逃出生天！！真小鱼儿从不回头看爆炸！！ 
			{
				cout<<'n';   //活着！！ 
				return 0;    //程序的结束------世界的消逝。 
			}
			else             //难道没逃出来？？？ 
			{
				cout<<'y';   //十二号桌西湖醋鱼！！ 
				return 0;    //程序的结束------世界的消逝。 
			}
		}
		now+=meter;          //小鱼努力游着...... 
		meter*=0.98;         //小鱼有点疲劳了。 
	}
	return 0;                //程序的结束------世界的消逝。
}
```

---

## 作者：「已注销」 (赞：317)

```cpp
#include<bits/stdc++.h>综合头文件
using namespace std;
int main(){
    double v=7,s,x,l=0;v速度，s,x如题意
    cin>>s>>x;
    while(l<s-x){游进探测器
        l+=v;路程累加
        v*=0.98;速度减慢
    }
    if(v*0.98<=s+x-l)cout<<'y';
    else cout<<'n';
}
```

---

## 作者：PC_DOS (赞：65)

第一反应就是等比求和，之后稍微做了一个扩展把它扩展到正实数。分别求出小鱼进入探测范围和离开探测范围时距离出发所经过的时间即可。

假设经历时间为t，所走路程为trip，则有：

$$\frac{7(1-0.98^t)}{1-0.98}=trip$$

由此依照换底公式解得：

$$t=\frac{log(1-\frac{0.02trip}{7})}{log(0.98)}$$

这个解法有一个问题，即在trip>350时会出现负数（因为上述求和式的极限为350），但是由于保证输入值有效所以没有加判断。

```cpp
#include <iostream> //标准的输入输出库
#include<cmath> //引入数学函数库，因为要用到对数函数
using namespace std;
int main(){
    double tEnter,tExit; //tEnter、tExit表示小鱼进入和离开侦测区域的时间
    double s,x;
    cin>>s>>x;
    tEnter=log(1-0.02*(s-x)/7)/log(0.98); //使用换底公式计算进入时间
    tExit=log(1-0.02*(s+x)/7)/log(0.98); //使用换底公式计算离开时间
    if (tExit-tEnter>=1) //如果在圈中时间大于1秒
        cout<<'y'; //有危险
    else
        cout<<'n'; //没有危险
    return 0;
}
```

---

## 作者：天下第一！ (赞：35)

原谅我再发一遍题解原因是

先前那个题解有点毛病所以重发一遍

speed的变量要放在sum的后面因为

**小鱼一开始速度是7而不是7\*0.98……**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int s,x,start,end; 
    double sum=0,speed=7;
    cin>>s>>x;
    start=s-x;//“大炮”范围的极限（千万别忘了范围还有向前的） 
    end=s+x;//咦，小鱼跑掉了（脱离范围） 
    while(true){
        if(sum>=start){//小鱼丰富多彩的生活开始
            if(sum+speed<=end){
                cout<<"y"<<endl;//哇要死要死（时间到了没脱离范围） 
            }
            else{
                cout<<"n"<<endl;//还好出门前翻了一下黄历（成功脱离范围） 
            }
            return 0;//提示一下如果不在这里停下来会一直输出y或n…… 
        }
               sum=sum+speed;//累加器计算总共游的距离不解释 
               speed=speed*0.98;//越游越累（注意有可能邪恶猎人把“大炮”对准小鱼家，所以先进行判定后再走，是这道题的难点）
    }
}
```

---

## 作者：我是蒟弱 (赞：32)

来，想象：小鱼从黄河下游往上右，速度是7米/秒，由于逆水游会很累，他每到下一秒就会把它的速度自乘0.98。

速度（v）：

第一秒：7米/秒

第二秒：7×0.98米/秒；

第三秒：7×0.98×0.98米/秒

这样吧，我们上代码了（一步一步讲）：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
	int s/*猎人安装探测器的位置*/,x/*探测范围*/;
	double a=0/*小鱼游的路程*/,v=7/*小鱼的速度*/;//注意喽，这里要用double类型，因为小鱼速度乘完0.98是个小数 
	cin>>s>>x;//猎人施工中 
	while(a<s-x){//小鱼在探测器探测不到的水域中奋力的游着
		v*=0.98;//小鱼累了，速度变慢了 
		a+=v;//不过又多游了一点 
	}//不好，进到探测器范围内了！ 
	v*=0.98;//小鱼还在减速
	if(a+v/*小鱼下一秒有的路程*/>s+x/*探测器探测的右限*/){
		cout<<"n";
	}else{//小鱼被抓了！ 
		cout<<"y";
	} 
	return 0;//小鱼再见！ 
} 
```

下面我把上面代码输出还可以用三目运算符输出：
```cpp
	cout<<(a+v>s+x?'n':'y');
```

三目运算符讲解：
**格式：判断语句？执行语句1：执行语句2；**

相当于：
```cpp
if(判断语句){
	执行语句1；
}else{
	执行语句2；
}
```
        
所以说：本文中的输出可以借鉴三目运算符，它和第一个代码的if与else判断输出是等价的。

好了，大家有不理解吗，欢迎大家在评论区留言！

---

## 作者：renex (赞：10)

- 题目其实比较简单，就是英文不过关~~y和n一直反向输出我只是wa了快十次就做出了~~
- 鱼进入探测区域有两种可能： 1.在某一秒正好结束时进，这样进入的同时鱼变速，猎人受到信号（我也不知道为什么反射弧这么长 2. 在某一秒内进入探测范围，此时探测器在这秒结束时才会发出信号，之后猎人受到信号，鱼同时变速，此时鱼有一段距离按进入前速度行动。


------------
为了便于理解，拿样例来解释一下~~（讨论区我也发过）~~

------------
- 题中原文：一旦小鱼进入探测器的范围，探测器就会在这一秒结束时把信号传递给那个猎人，猎人在一秒后就要对探测器范围内的水域进行抓捕。

- 在0~1秒初（999ms)，小鱼向前游7m，未进探测器范围
- 在1~2秒(1000ms~1999ms)，小鱼将从7m处游到13.859m处，在这个时间段某一点进入探测器范围，探测器在这秒结束时传递信号（即1999ms时）
- 猎人在一秒后就要对探测器范围水域抓捕，即猎人在1999ms才受到信号，2999ms进行抓捕
- 小鱼在2999ms时，可以游到约20.5m处，已经走出探测器范围

------------
```c
#include <stdio.h>
int main()
{
	double s,x,sum,go;
	scanf("%lf %lf",&s,&x);
	sum=0.0;
	for(go=7.0;sum+go<=s-x;go=go*0.98){
		sum=sum+go;
	}if(sum>s-x){
		if(sum+go>s+x)
			printf("n");
		else
			printf("y");
	}else if(sum<s-x){
		if(sum+go+go*0.98>s+x)
			printf("n");
		else 
			printf("y");
	}
	return 0;
}
```



---

## 作者：张亦弛 (赞：8)

其实跟某一题解的思路一样，但是看了那一片题解的评论区，还有不少人有疑问，于是，我就再详细的讲解一下这道题。~~（希望能通过）~~

在小鱼到达探测范围之前，都在一直游，l记录的是离出发点的距离。总所周知：x（位移）=v（当前的速度）*t（时间），但是需要注意的是，速度是一直在变的，也就是每一秒的v都是上一秒的98%，所以一定要每次让v自乘0.98。

当小鱼到达探测范围时，循环就退出了，因为循环的条件是l<s-x（x-s~x+s整个区间都是探测范围，~~这应该很好理解~~）。题目要求是：“也就是说小鱼一旦进入探测器范围，如果能在下1秒的时间内马上游出探测器的范围，还是安全的。”注意是在下一秒，所以v还要自乘0.98（因为这个时候的v是上一秒的）。然后下一秒经过的位移是x=v'*t=v*0.98*1=v*0.98，只要这个位移x>s+x-l，就是安全的，否则，有危险。

肯定有些读者还对x>s+x-l这句话有疑问，那在解释一下。因为退出循环时，小鱼已经到了探测范围之中，所以这时l>s-x&&l<s+x。所以小鱼现在的位置（l）到游出探测范围（s+x）之间的距离就是s+x-l啦，对吧。

下面看代码吧（很短的）：

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
double s;//邪恶的猎人把探测器安装在距离A处右边s米的地方
double x;//探测器左右x米之内是探测范围
double v=7;//鱼第一秒可以游7米
double l;//记录游泳到的位置距A点的距离 
int main()//主函数 
{
	cin>>s>>x;//输入s、x 
	while(l<s-x)//在游到探测范围之前 
	{
		l+=v;//每秒的位移x=v'*t，l为总的距离，l+=x。 
		v*=0.98;//从第二秒开始每秒游的距离只有前一秒的98%
	}
	if(v*0.98>=s+x-l)//如果在一秒内小鱼游出了探测范围 
		cout<<"n";//没有危险 
	else//否则 
		cout<<"y";//有危险 
	return 0;//结束 
}

```

ps

再提几点需要注意的：

1、因为每次*0.98所以计算出来的结果一定是小数，所以要用double型变量来存储

2、因为那一篇题解最后没有打return 0，所以再次提出，return 0最好写上，作为一个oier良好的代码习惯

3、一定要有良好的代码风格，特别是缩进，这样可以大大增加代码的可读性。

最后，感谢大家看完本蒟蒻这篇冗长的题解。

---

## 作者：hope (赞：8)

对于这题，如果还没做《小玉在游泳》，那么我建议先去做一做（不要打表）。

如果做了《小玉在游泳》，这题就简单多了

①：把每次游2m改成每次游7m

②：在循环中判断：如果进入探测器范围：①：如果下一次游能出探测器范围，输出“n”②：如果下一次游不能出探测器范围，输出“y”

入门题，真心简单……


---

## 作者：雅文_Schicksal (赞：6)

这道题的难度不大，连我这样的蒟蒻都能做得出来……

本题主要的难点就是在于如何判断是否触碰到探测器和触碰到探测器一秒后的位置

本题使用了pow（指数函数）来累加走的距离

所以…下面就是题解了

#include<bits/stdc++.h>//万能库，这里同时用<iostream>和<cmath>也可以；

```cpp
using namespace std;
int main()
{
    double s,x,len=0;//本题所用到的数据皆∈R（实数），所以这里用了double
    cin>>s>>x;//输入s,x
    for(int i=1;i<=10000;i++)//开始循环测试碰到探测器时的时间
    {
//len在这里作累加器
        if(len>=s-x)//当小鱼进入到探测器的范围时
        {
            if(s+x<len+7*pow(0.98,i-1))//计算再走一秒后是否可以逃出
            {
                cout<<"n"<<endl;
                i=10000;//停止循环
            }
            else
            {
                cout<<"y"<<endl;
                i=10000;//同上
            }
        }
        len+=7*pow(0.98,i-1);
    }
    return 0;
}
//新手村里关于小鱼的题真的好多……
```

---

## 作者：种子 (赞：5)

相信看到这个题的第一眼都觉得这是一道水题 没错 但是我被坑的提交了5次从没试过 于是忍不住想写个题解

```cpp
var
  s,x,a,b,c:real;
begin
  read(s,x);
  b:=7 ;
  repeat
    a:=a+b;
    b:=b*0.98;
    if a>=s-x then if s-x>=0 then c:=a-s+x+b else c:=b;//s-x小于零要分开讨论！a与s-x是>=
  until a>=s-x;
  if c>2*x then write('n') else write('y');
end.
还有一点可能某些同学会看错（比如我赫赫赫），题目的探测器是在距As米处向两边探测的
```

---

## 作者：dakeboy (赞：4)

被第一秒给虐了啊，把我的代码发出来，

竟然特地处理了第一秒的情况，

告诫自己一定要考虑全面

```python
s,x=map(int, input().split())
l=0
t=9
if s<7:
    if (s+x)<7:
        print("n")
    else:
        print("y")
else:
    while(l<(s-x)):
        t=0.9*t
        l=l+t
    if l<s:
        y=s-l
    else:
        y=l-s
    if (y+x)<0.9*t:
        print("n")
    else:
        print("y")

    
```

---

## 作者：Sniper_lyb (赞：3)

思路非常简单，用sum计一下小鱼游过的总路程，用left存一下监测范围的左端点，用right存一下监测范围的右端点（left=s-x;right=s+x;）用while循环累加小鱼游过的总路程，当sum>=left的时候(注意是大于等于），也就是小鱼进入，监测范围，循环停止，再加上下一秒游过的路程看能否游出去（注意此处必须是sum>right,这个点卡了两次），是则没有危险，否则有危险。

代码如下



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double sum=0,et=7;
int s,x;
int main()
{
    cin>>s>>x;
    int left=s-x,right=s+x;
    while(sum<left)//循环 
    {
        sum+=et;
        et*=0.98;
    }
    if(sum+et>right) cout<<"n";//注意此处一定要>，游出去才会没有危险。 
    else cout<<"y";
    return 0;
}
```

---

## 作者：sdgmwjy (赞：3)

这个题看起来还可以，不过有需要注意的地方

一个是要考虑猎人把探测器放在起点附近，这样小鱼从一开始就被检测到了，所以要判断一下，要不有一个点过不了。

另一个是你可以算一下，小鱼最多就只能游350米，所以350米后面的直接输出就行了。

做这个题时我看到有的人每次那个0.98的几次方（小鱼这次可以游的距离）都重新算，其实不用，只要你把前面上一次游的距离别清零，直接乘0.98就行了（dalao勿喷。。。），这样可以省时间。

```cpp
#include<iostream>
using namespace std;
int main()
{
    bool f=false;
    double s,x,ss=0,sss=7;
    cin>>s>>x;
    if(s-x>350)             //可怜的小鱼只能游350米
    {
        cout<<'n'<<endl;
        return 0;
    }
    if(s-x<=0)
    {
        f=true;          //猎人放在起点处的判断
    }
    for(int i=1;i<1000;i++)
    {
        ss+=sss;
        sss*=0.98;      //乘方的计算
        if(ss>=s-x)
        {
            if(!f)
            {
                f=true;     //激活探测器
            }
            else
            {
                if(ss<=s+x)       //游不出来了
                {
                    cout<<'y'<<endl;
                    return 0;
                }
                else
                {
                    cout<<'n'<<endl;
                    return 0;
                }
            }
        }
    }
}
```

---

## 作者：chenyx (赞：2)

```cpp
#include<iostream>
using namespace std;
double x,n,l,k=0;
int main()
{
    cin>>n>>x;k=0;l=7.0;
    while(k<n-x)ps:我在这里搞反了，把k写成了k+l。。。so
    {
       k+=l;l*=0.98;
    }
    if(k+l>n+x)cout<<"n";else cout<<"y";
    return 0;
}
这道题虽然水，你一看就知道思路，但思维要严谨，还有注意边界，这题浪费了我3次提交。。。一个while解决，如果已经游到探测器里了，就停止，在用一个if进行测试。我觉得不要抄小鱼游泳会比较好，不然容易搞混甚至搞反
```

---

## 作者：huanghu996 (赞：2)

## 这道题目可以用STL的二分（lower\_bound，upper\_bound）来做

我们知道按照题目所规定的游泳的距离，我们可以预处理出小鱼每秒过后到起点的距离。（存在a数组里）

之后我们可以查找小鱼将会到达的位置（a数组的值）在区间$$[s-x,s+x]$$（猎人的检测区域）中出现了多少个。

也就是说统计$$s-x<=a[i]<=s+x$$,的符合条件的i的个数

如果出现个数个数<=1则说明没有危险。

如果出现个数个数>=1则说明有危险。

### 那么我们怎么统计在a数组的值在[s-x,s+x]区间出现的个数？

lower\_bound（a+1，a+n，x）表示查找在区间[1,n)大于等于x的第一个数的位置

upper\_bound（a+1，a+n，x）表示查找在区间[1,n)大于x的第一个数的位置

lower\_bound（a+1，a+n，x）-1即表示小于x的数的位置。

upper\_bound（a+1，a+n，x）-1即表示小于等于x的数的位置。

我们用lf，rt来表示区间的左右端点。

那么
（upper\_bound（a+1，a+n，rt）-1）-（lower\_bound（a+1，a+n，lf）-1）表示区间[lt,rt]区间中出现的元素的总数。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
double a[105];
int main()
{
    int x,rg;
    scanf("%d%d",&x,&rg);
    int lf=x-rg;
    int rt=x+rg;
    a[0]=0;
    a[1]=7;

//接下来是预处理
    for(int i=2;i<=100;i++)
    {
        a[i]=a[i-1]+(a[i-1]-a[i-2])*(0.98);
        //cout<<i<<" "<<a[i]<<endl;
    }

//接下来是统计区间内元素的个数。
    int lfp=lower_bound(a+0,a+101,lf)-a-1;
    int rtp=upper_bound(a+0,a+101,rt)-a-1;
    if(0<=rtp-lfp&&rtp-lfp<=1)
    {
        printf("n\n");
    }
    else
    {
        printf("y\n");
    }
    return 0;
}
```

---

## 作者：swhsz (赞：2)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int b,a,x,s;
    double c,m=7;
    cin>>s>>x;
    a=s-x;//探测器左侧可探测到的位置
    b=s+x;//探测器探测不到的位置
    while(1) {
        if(c>=a) {//小鱼进入探测器范围（先写这个因为考虑一开始小鱼就在探测器范围内）
            if(c+m<=b)cout<<"y";//如果小鱼走出
            else cout<<"n";//如果小鱼没有走出
            return 0;
        }
        c+=m;
        m=0.98*m;
    }
}
```

---

## 作者：封禁用户 (赞：1)

本神犇一次便过0（**^\_\_\_^）





```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<iomanip>
#include<ctime>
#include<set>
#include<vector>
#include<list>
#include<cmath>
#include<cstdlib>
#include<string>
#include<cstring>
#include<fstream>
#include<queue>
#include<stack>//这个不解释
using namespace std;
int main()
{    
    double a,i,j,k,n,b,d,pd;
    cin>>a;//距离
    cin>>b;//范围
    n=0;//游出去米数
    j=7;//每次游多远
    while(n<a-b)//循环做到进了探测器范围
    {
        n+=j;
        j=j*0.98;
    }
    n+=j;//游了一秒
    if(n>a+b)//如果出了范围就没有危险了
        cout<<"n";
    else
        cout<<"y";
    return 0;//结束喽！！！！！！！！！！！！！
}
```

---

## 作者：Kelin (赞：1)

这里我们把题目中的s，x换成n，m

因为小鱼的第n秒的运动总距离的这样的7\*1+7\*0.98+...+7\*0.98^n

那么我们化简一下7\*(0.98^(n+1)-1)/(0.98-1)

公式解读

【
令s=1+a+a^2+...+a^n

则as=a+a^2+...+a^n+a^(n+1)

∴(a-1)s=a^(n+1)-1

∴s=(a^(n+1)-1)/(a-1)

】
继续化简350\*(1-0.98^(n+1))

首先令s=1每次循环\*0.98

那么第s-1秒的距离就是350\*(1-s)

循环到下一秒能进入探测圈的那一秒跳出

就是 350\*(1-s)>=n-m时跳出

当然s已经多乘了一次0.98了，所以出来再除一遍0.98

然后下一秒运动的距离就是 7\*s\*0.98

求出（恰好到n-m的时间）-（下一秒运动后会到n-m的时间） 的时间 t

然后 看看 (1-t)\*下一秒的运动距离+t\*下下秒的运动距离 是否>2\*m

大于输出n

否则输出y






```cpp
#include<cstdio>
double n,m,t,s=1,l=350;
int main()
{
    scanf("%lf%lf",&n,&m);
    while(l-l*s<n-m)s*=0.98;
    s/=0.98;
    t=(n-m-l+l*s)/(7*s*0.98);
    if((1-t)*(7*s*0.98)+t*(7*s*0.98*0.98)>2*m)puts("n");
    else puts("y");
return 0;
}
```
接下来上一下改进的代码（其实就是合并了下多项式）

```cpp
#include<cstdio>
double n,m,t,s=1,l=350;
int main()
{
    scanf("%lf%lf",&n,&m);
    while(l-l*s<n-m)s*=0.98;
    s/=0.98;
    t=(n-m-l+l*s)/(6.86*s);
    if(6.86*s-0.1372*t*s>2*m)puts("n");
    else puts("y");
return 0;
}
当然因为数据水，没有卡数据的所以用楼下的方法也是可行的
```

---

## 作者：枍暮77 (赞：1)

太水的一道题了，数组都用不到。。。。。。没有下面那几位大神想得那么难。。。。。。刚学的童鞋们可以练个手，大神可以赚积分。。。。。。出水题的人太有良心了

```cpp
var 
  a,b,i,j:longint;   
  c,e:extended;  
begin  
  read(a,b);  
  e:=7;  
  while c<a-b do
  begin  
    c:=c+e;  
    e:=e*0.98; 
  end;  
  if c+e>a+b then writeln('n') else writeln('y'); 
end.
```

---

## 作者：「QQ红包」 (赞：1)

水题……

```delphi

var s,x,y,d:real;
      m,i:integer;
begin
      read(s,x);
      d:=7;
      while  y<s-x do//判断小鱼是否游进探测器的范围里了……其实就是求小鱼游进探测器的时候速度是多少
      begin
            y:=y+d;
            d:=d*98/100;//速度每次都慢一些
      end;
     if y+d>s+x {就是一秒内看小鱼游得出去吗}then writeln('n') else writeln('y');
end.

```

---

## 作者：xiaobao (赞：1)

/\*
自认为下面的代码才是正确的 因为数据low爆 所以都过了

实际上 最后一次鱼已经没有一秒钟的时间逃生了 他已经在

进入探测区的时候消耗了一定的时间

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
void hello()
{
    double s = 0, x = 0;
    cin>>s>>x;
    double speed = 7, len = 0;
    while(len < s - x)
    {
        len += speed * 0.98;
        speed *= 0.98;
    }
    double time = (len - s + x) / speed;
    if(s + x - len <= speed * 0.98 * (1 - time))
    {
        cout<<"n\n";
    }
    else
    {
        cout<<"y\n";
    }
}
int main()
{
    //while(true)
    //{
        hello();
    //}
    return 0;
}
```

---

## 作者：礼部尚书 (赞：1)

我发现自己的代码比其他人短，分享一下自己的作法，不要嘲讽我的float，习惯（我知道它其实并不比double好用）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int main()
{
    float jl=7;
    int a,b,c=0,d,e;
    cin>>a>>b;
    d=a-b;
    e=a+b;
    while(c<d)
    {
        c=c+jl;
        jl=jl*0.98;
        //速度会逐渐递减，一个while可以完全覆盖。
                //只要控制好c和d的关系就可以避免楼下超长代码的多个if
    }
    if(c+jl*0.98>e)cout<<"n";
    else cout<<"y";//只要能够游出这范围就安全了!
    return 0;
}

```

---

## 作者：二字 (赞：0)

# 较简单的题解 #
###### ~~悄悄吐槽一句，这题好水啊~~ ###### 
首先，我们需要翻开七年级上册的数学课本找到数轴，想象一条小鱼在里面游着（莫名像动点问题）

然后就好理解了~

小鱼每秒都会往右移动一点，当小鱼进入探测器范围后一秒如果没有逃出就会有危险

下面贴部分代码：
```cpp
s1=s-x;
	while(y<s1){
		y+=v;
		v*=0.98;
	}
```
这段话是为了模拟小鱼在进入探测器范围前的游动过程，s,x如题意，s1是探测器往前的探测范围，y是总路程，v是小鱼游动的速度

再贴一段代码~
```cpp
s2=s+x;
if(v*0.98<=s2-y) cout<<"y";
    else cout<<"n";
```

v*0.98<=s+x-y:如果小鱼下一次游动没有逃出生天输出y，如果逃走了输出n

下面贴出完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	float v=7,s,x,y=0,s1;
	cin>>s>>x;
	s1=s-x;
	while(y<s1){
		y+=v;
		v*=0.98;
	}
    s2=s+x;
	if(v*0.98<=s2-y) cout<<"y";
    else cout<<"n";
	return 0;
}
```

---

## 作者：锣鼓001wyd (赞：0)

#本题主要是有个点比较keng，需要考虑一开始就在范围内的情况，因此采取先判断位置再走的策略。

```cpp
#include<iostream>
using namespace std;
int main(){
    double s,x;
    double speed=7,pos=0;//speed是每下次走之前的速度，pos是每上次走之后的位置
    cin>>s>>x;
    while(speed!=0)//速度不为零就可以一直走
    {
        if(pos>=s-x&&pos<=s+x)//判断是否在探测范围内
        {
            speed*=0.98;//是的话就直接求出下一秒的结果位置并判断“y”或者“n”
            pos+=speed;
            if(pos>s+x)
            {
                cout<<"n";
                break; //注意break跳出while循环
            } 
            else
            {
                cout<<"y";
                break;
            }
        }
        else if(pos>s+x)//如果一开始不在范围内，而又一走超过了，(ˉ▽ˉ；)...那么理所当然“n”
        {
            cout<<"n";
            break;
        }
        else//如果还没在范围内就继续走
        {
            pos+=speed; 
            speed*=0.98;            
        }
    }
    return 0;
}
```

---

## 作者：吉亦奇 (赞：0)

```cpp
//魔性水题 
//不用特判开始就在探测器范围内的情况也能过
#include<iostream>
using namespace std;
double lc[1010];
int main()
{
    double s,x,pos=0;//pos为当前小鱼的位置 
    int sec=0;//秒数 
    cin>>s>>x;//x为放置地点  x为左右范围 
    lc[1]=7;
    for(int i=2;i<=1009;i++)
    {
        lc[i]=lc[i-1]*0.98;    //递推算出第i秒能游多远 
    }
    int l,r;//l为探测器的左边界，r为右边界     
    l=(s-x>0)?s-x:0;//求左边界 
    r=s+x;             //求右边界 
    while(pos<l)
    {
        pos+=lc[++sec];//让小鱼游到探测器范围内 
    }
    if(pos+lc[++sec]>r) cout<<"n";//如果下一秒能游出去输出n 
    if(pos+lc[sec]<=r) cout<<"y";//如果下一秒不能游出去输出y 
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

#将有危险的一段的两个端点分别求出**(s+x,s-x a,b)** 如果小鱼直接跳过了危险的一段**（m > s + x)**,则跳出循环;如果刚好游到s+x~s-x,判断是否能逃出

##代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(int argc, char *argv[])
{
    int s ,x;
    int a ,b;
    int i ;
    char c = 'n'; //结果
    double m = 0 ,t; .//注意每次游得距离是小数
    cin >> s >> x;
    a = s - x;
    b = s + x;
    t = 7;
    for(i = 1 ; ; i++) //死循环
    {
        m += t;
        t * 0.98;
        if(a <= m && b >= m)
        {
            if(m - t >= a || m + t <= b) //无法逃出
            {
                c = 'y';
                break;
            }
        }
        if(m >= b) break; //没有经过有危险的一段
    }
    cout << c;
    return 0;
}

```

---

## 作者：maxmeansmaximum (赞：0)

很魔性的一道水题...


思路是分类讨论：

1、起点在探测范围内 （s<x）

2、起点不在范围内 （s>=x）


把探测范围当作半径为x的圆即可


代码如下：



    
    
    

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int s,x;
int main(){
    cin>>s>>x;
    double a=7,sum=0; //a为每次游的距离 
    if(s>=x){    //起点不在探测范围时 
    for(int i=1;;i++){
        sum+=a;
        a*=0.98;
        if(sum>=s-x) break;    //判断是否进入圆内
    }
    if(x+s-sum<=a) cout<<"n";    //比较圆内第一点到圆上的距离 与 下一次跳跃长度的大小 
    else cout<<"y";
    }
    else{    //起点在探测范围内时 
        if(a>s+x) cout<<"n";    //判断 7 是否＞起点到圆上的距离即可 
        else cout<<"y";
    }
    return 0;
} 

```

---

## 作者：daks (赞：0)

**发现讨论中不少说要特判第1秒的，可我没有特判，然而我一遍A了

\*个人以为，这是一道数学题

\*思路：

\*首先，预处理每一秒所能走的路程delx【】

\*然后，对于输入的s，x，定义一个t=s+2x，于是，（s，t）就是警报区间了

\*累加delx，直到超过s

\*最后，定义e（end）=x+(1.0-(x-s)/delx[js-1])\*delx[js] ，判断e是否小于等于即可

\*对于e的解释，x是累加delx时刚刚超过s时的路程，就是说，从s到x所需的时间小于一秒，跑到x所需的秒数为（js-1）。于是，上式就很显然了

\*下贴代码，有点丑，凑合看

 

```cpp
#include<iostream>
using namespace std;
int main()
{
    double s,x;
    cin>>s>>x;
    double t=s+2.0*x;
    double delx[1000];
    delx[1]=7.0;
    for(int i=2;i<=300;i++)
    {
        delx[i]=delx[i-1]*0.98;
    }
    x=0;
    int js=1;
    while(x<s)
    {
        x+=delx[js];
        js++;
    }
    double e=x+(1.0-(x-s)/delx[js-1])*delx[js];
    if(e>=t)
     cout<<"n";
    else
     cout<<"y";
}
```

---

## 作者：美人为限 (赞：0)

如果第一秒就进入范围的话，就需要直接判断，要不然第二个点会不过。

```cpp
#include<iostream>
using namespace std;
double s,x,dis;
double v=7;
bool flag=true;
int main(){
    cin>>s>>x;
    while(flag){
        if(s<=x){   //如果小鱼直接进入范围内      
            if(dis<=x)  cout<<"y";
            if(dis>x)   cout<<"n";
            break;
        }  
        dis+=v;     // 累加
        v*=0.98;   //速度变慢
        if(dis-s<=x){    //如果小鱼游进了范围内
            if(dis<=x)  cout<<"y";
            if(dis>x)   cout<<"n";
        }
        flag=false;   //终止循环
    }
    return 0;
}
```

---

## 作者：myysnd (赞：0)

这里给一个C的简单易懂题解

虽说很长但是基本思路我想应该还是有的= .=

```cpp
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int s,x,swim;
    int ban;//英文意思就是禁止啦^-^ 
    float dis=7;//存小数 ，游泳距离 
    int i;
    scanf("%d %d",&s,&x);//s米远一个探测器，x米的半径。 
    ban=s-x;//这是探测器的进入点 
    for(i=1;i<=9999;i++)//保证计算的步数足够远 
    {
        swim=swim+dis;//加上距离，初始值7已赋值 
        dis=dis*0.98;//为下一次距离做计算 
        if(swim>ban)//游过了进入点 
        {
            if(ban>=7)//对于7这个数字做分类是防止逗比把探测器丢起点或一游就走的点 
            {
              swim=swim+dis*0.98;//看看下次游多少 
              ban=0;
              ban=s+x;//其实上面这句可以略过，就是指重新赋值探测器使之为出口点。 
              if(swim>ban)
                {
                printf("n");
                break;
                }
              else
              {
               printf("y");
               break;
               }
            }
            else if(s-x<=7)//都出家门几万里还说逃不出去的情况处理 
            {
                swim=swim+dis*0.98;
                if(swim>s+x)
                {
                    printf("y");
                    break;
                }
                else
                {
                    printf("n");
                    break;//不过探测器即使在家门后面也是有可能有几百公里的弹道射程的 
                }
            }
        }
    }
    return 0;//程序君休息 
}
```

---

## 作者：peter·z (赞：0)

```delphi
var i,j,k,m,n,p,q,x,y,s:longint;
    speed,distance:real;
    a,b:array[1..1001]of longint;
begin
  read(s,x);
  speed:=7;
  while distance<s-x do{当小鱼还没游到探测范围则继续游一秒}
    distance:=distance+speed;{总距离=当前速度*1+原总距离}
    speed:=speed*0.98;{当前速度变为98%}
  if speed+distance>x+s then write('n') else write('y');{如果小鱼在
  一秒内游程能大于探测范围，那么安全}
end.
```
本题是比较简单的，但要注意细节（ps：我抄我自己“小玉游泳”的程序，忘了把速度从2改成7，wa了好多次）


---


# 统计天数

## 题目描述

炎热的夏日，KC 非常的不爽。他宁可忍受北极的寒冷，也不愿忍受厦门的夏天。最近，他开始研究天气的变化。他希望用研究的结果预测未来的天气。


经历千辛万苦，他收集了连续 $N(1 \leq N \leq 10^6)$ 天的最高气温数据。

现在，他想知道最高气温一直上升的最长连续天数。


## 样例 #1

### 输入

```
10
1 2 3 2 4 5 6 8 5 9
```

### 输出

```
5```

# 题解

## 作者：这不会那不会 (赞：387)

cpp
//**即使很菜没人看我也要写T^T**//


------------


1.a[N]用来保存需要输入的数字,b[N]是个计数器数组用来保存连续的天数 

2.求b[N]的最大值max就是求连续最长的天数

3.输出max的值**

------------

```cpp
#include<stdio.h>
#define N 10000000
int main()
{
    
    int k=1, n=0,max,a[N],b[N];//k是计数器用来统计连续天数,将统								计的数字保存在b[N]中  
    scanf("%d", &n);//n为可输入数字的个数 

        for(int i=0; i<n; i++)//向数组中输入数字 
            scanf("%d", &a[i]);
            
        for(int i=0; i<n; i++)//判断如果当前元素比后一个小,就									使k++,然后将k值保存在b[i]中,
								//否则b[i]的元素为1 
       `{
            if(a[i]<a[i+1])
            {
                k++;
                b[i]=k; 
            }
            else
            {
                k=1;
                b[i]=k;
            }
        
        }
    
    
    max=b[1];		//假设b[1]为最大的元素,也就是天数最多的元素 
    
    for(int i=0; i<n; i++)//求出天数最多的最大值 
        if(max<b[i])
          max=b[i];
        
        printf("%d\n",max);	//输出天数最多的值 
      #   
    return 0;
}
```

---

## 作者：时久 (赞：106)

看了看之前的题解，貌似都开了个超大的数组

我的方法是输入的时候就进行比较，这样数组开两个空间就够了

直接上代码
```cpp
#include<bits/stdc++.h>  
using namespace std;  
int a[3];  
   int main(){  
   	      int n,x,num;  
          num=0;x=0;//我第一次写的时候忘了清零（尴尬）
   	cin>>n;
   	for(int i=1;i<=n;i++){
   		cin>>a[2];//变成后一天
   		if(a[2]>=a[1]){
   			x++;//如果比前面的大，那么累加器加一
   			num=max(num,x);//如果累加器内大于最大连续天数，那么给它赋值
		   }else x=1;//如果比它小，那么变成一，注意不是变成零，因为这天会直接被刷掉，需要计算这一天
		   a[1]=a[2];//变成前一天
	   }

    cout<<num;

   	return 0;
   }
```
```

---

## 作者：蒟蒻大犇 (赞：73)

额......首先我先声明一下，本人是一名蒟蒻，欢迎各位大佬指点。

~~由于本蒟蒻的语文水平有限~~

话不多说

### 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()//这些就不讲了。
{
	long long n,a[1000000],i,j,t=1,ans=0;//n是10^6，a数组是10^9所以用long long。
	cin>>n;//输入n。
	for(i=0;i<n;i++)
	{
		cin>>a[i];//输入a数组。
	}
	for(j=0;j<n;j++)
	{
			if(a[j+1]>a[j])
			{
				t++;//如果比前一个大，t++。
				if(t>ans)
				ans=t;//把最大的连续上升天数放在ans里。
			}
			else
			t=1;//否则t又变成1。
	}
	cout<<ans;//输出答案ans。
	return 0;//好习惯。
}
```

## 求通过
end

---

## 作者：wuzirui (赞：39)

不明白为什么这么多人用数组。。

明明只需要**维持几个计数器**

------------

## 代码：


```cpp

#include <cstdio>

using namespace std;

int main()
{
    int n, count = 1, max = 1;
    long long last, cur;
    scanf("%d%d", &n, &cur);
    for (int i = 2; i <= n; i++)
    {
        last = cur;
        scanf("%d", &cur);
        if (cur > last)
        {
            count++;
        }
        else
        {
            count = 1;
        }
        if (count > max) max = count;
    }
    printf("%d\n", max);
    return 0;
}

```

## 变量含义：

- cur - 当天的温度
- last - 前一天的温度
- count - 当次连续升温的天数
- max - 当前所记录的最长升温天数

------------

## 代码解析：

在循环中，我们对比新输入的温度和前一天的温度：

- 如果升温，那么 count++ , 即还在持续升温，连续天数应该**递增**
- 反之，如果没有升温，那么当前的持续升温**被打断**，应该重新计数

每次循环，我们对比 max 和 count 的值，如果当前的持续天数已经**超过**了以前的**最大值**，那么我们就要更新 max 变量来维护最大值。

---

## 作者：HoshinoTented (赞：21)

# 说些什么
。。。  
要吐槽的就是这个题目居然是 `试炼场(数组::class)` 的题目  

# 题解
上!代!码!  
```C++
//
// Created by hoshino on 18-10-2.
//

#ifndef LUOGU_1567_HPP
#define LUOGU_1567_HPP

#include <iostream>

auto main(int, char **) -> int {
	unsigned int max = 0, tmp = 0, lst = 0, c;
	std::cin >> c;

	for (unsigned int i = 0; i < c; ++ i) {
		unsigned int t;
		std::cin >> t;
		++ tmp;
		if (t < lst) {
			if (max < tmp) max = tmp;
			tmp = 0;
		}

		lst = t;
	}

	std::cout << max << std::endl;

	return 0;
}

#endif //LUOGU_1567_HPP
```
~~一如既往有着熟悉的花里胡哨的气息~~  
首先是我们需要用到的变量  
`unsigned int max, tmp, lst, c`  
* max: 最大连续天数
* tmp: 当前连续天数
* lst: 上一天的温度
* c: 循环用的, 温度的数量

接着就是循环  
这里定义了一个 `unsigned int t`  
是用来存放当天的温度的  
其实下面的代码, 是经过星野简化过的, 并不直观  
原本的代码是: 
```C++
if (t > lst) {
	lst = t;
    ++ tmp;
} else {
	if (max < tmp) max = tmp;
	lst = t;
	tmp = 0;
    ++ tmp;
}
```
`if (t > lst)` 判断当天温度是否大于昨天的温度  
如果是, 则将昨天的温度 赋值为 今天的温度, 并且 当前连续天数 ++  
`else` 反之  
`if (max < tmp)` 判断最大连续天数是否小于当前连续天数  
如果是 则赋值  
接着将昨天的温度赋值为当天的温度  
当前连续天数赋值为0  
一开始星野并没有加上 `++ tmp`  
结果爆炸了  
Debug了一下, 结果发现是忽略了一天(中断连续的一天)  
最后  
优化又优化, 就变成了一开始给你们呈现的那份代码  
~~但还是没什么用啊, 星野还是那么菜~~

# 鶸符「蒟蒻最后的挣扎」
嗯哼, 星野写出了一份 `Haskell` 题解来安慰一下自己  
```Haskell
module LuoGu.P1567 where

main :: [Int] -> Int
main = maxContinuation 0 0 0

-- Max -> Continuation Count -> Last Temp -> Days Temp -> New Max                                                               
maxContinuation :: Int -> Int -> Int -> [Int] -> Int
maxContinuation max c _ [] = if max < c then c else max
maxContinuation max c l (t:ts) = if
  t > l then maxContinuation max (c + 1) t ts
  else (maxContinuation (if max < c + 1 then c + 1 else max) 0 t ts)
```
~~让星野猜猜, 洛谷是不是没有Haskell高亮~~

---

## 作者：征途者二号 (赞：11)

```cpp
			就算很菜，也要把这一题写出来
        			                 ————某位前辈
```
这一题拿到感觉~~好像很简单的样子~~，马上就可以打出一个枚举的代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
const int MAXN=1000*1000;
int a[MAXN];
int n,m,ans;
int line(int x)//找最长的连续天数
{
	int t=1,td=a[x];
	for (int j=x+1;j<=n;j++)
	if (a[j]>td) 
	{
		t++;td=a[j];
	}else
	break;
	return t;//程序纯暴力，很容易理解吧？
}
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	cin>>a[i];//读入
	for (int i=1;i<n;i++)
	ans=max(ans,line(i));//每一个进行枚举
	cout<<ans;//输出结果
	return 0;//主代码就这么短
}
```
用样例拍一下，什么问题都没有发生；交到洛谷评测，结果
### 上面的程序只得了40分，6个点超时了
**所以，发生了什么？**
看看那代码，每一个位置都向后找到了从i点开始的最长的连续天数，这样显然不高效，所以，为了AC，我们要换一种方法：

想法的图如下：
![](https://cdn.luogu.com.cn/upload/pic/52228.png)
只需要将两个红跨块之间的数量算出来，并进行找最大的操作。

下见代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
const int MAXN=1000*1000+10;//定义数组容量，如果直接写在数组定义中，就有可能会编译错误
int a[MAXN];
bool flag[MAXN];//这就是上图的第二个数组
int k,n,m,ans;
int main()
{
	for (int i=1;i<=1000000;i++)
	flag[i]=true;//初始化，绝对不用C++内置数组初始化
	cin>>n;//读入数值
	for (int i=1;i<=n;i++)
	cin>>a[i];//读入
	for (int i=1;i<n;i++)
	if (a[i]>a[i+1]) 
	{
	flag[i+1]=false;k++;//如果a[i]>a[j],就将flag[i]赋值false，并计算false的数量
	}
	a[n+1]=false;//这个语句很有深意，因为假设整个序列就是最长的连续天数，那么上面的循环跑一遍下来没有false，就无法正确输出，所以，为了保险，我们在这串数据最后一个的后面赋值一个false
	int fflag=1,dt=0;//dt就是这个区间的数的数量，fflag是一轮的初始值，也就是起点
	for (int j=1;j<=k+1;j++){
	for (int i=fflag;i<=n+1;i++)
	if (flag[i])
	{
		dt++;//如果是，那么将dt++
	}else
	{
		fflag=i;//这作为下一轮的起点
		flag[i]=true;//这一个点虽然是前一个的终点，但是也是后一个的起点，为了后面的序列着想，我们要将这个点修改指为true
		break;//到终点了，可以退出了
	}
	ans=max(ans,dt);//比大小
	dt=0;//新的一轮即将开始，dt初始化
	}
	cout<<ans;//输出结果
}
```
这就是全部程序了。总的来说这个想法就是：将每一个终点算出来，求出之间的数量，求最大

感谢阅读！

---

## 作者：codewin (赞：10)

这题跟最长连号比较相似，https://www.luogu.org/problem/show?pid=1420

这题还是比较简单，数组和打擂台。



```cpp
var
n,i,max,b:longint;
a,c:array[1..10000001] of longint;
begin
read(n);
b:=1;
max:=-1;
 for i:=1 to n do read(a[i]);
   for i:=1 to n do
   begin
   if a[i]<a[i+1]  then  inc(c[b])    //判断不持续增长
   else
    begin
    inc(b);
    end;
   end;
 for i:=1 to n do
 begin
 if c[i]>max then max:=c[i]; // 打擂台
 end;
write(max+1);   //一个坑，这里算的是天数之间的隔板，所以一定要加一！
end.
```

---

## 作者：「QQ红包」 (赞：8)

此题用模拟。

这道题不需要数组，因为每次用到的数只有今日气温和昨日气温。

如果连续升温天数段了一天，那么升温天数就变回1了。

```cpp

#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<string>
#include<math.h>
#include<time.h>
#include<vector>
#include<bitset>
#include<memory>
#include<utility>
#include<stdio.h>
#include<sstream>
#include<iostream>
#include<stdlib.h>
#include<string.h>
#include<algorithm>
#define LL unsigned long long
using namespace std;  
int n,i,x,z,sum,s;//n:天数，i:循环控制变量，x当日气温，z：昨日气温 ，sum存气最长温连续上升天数,s存目前连续上升天数 
int main()
{
    scanf("%d",&n);//读入天数 
    sum=-1;//初始化
    int z=-1; 
    for (i=1;i<=n;i++)//循环
    {
        scanf("%d",&x);//读入进入气温 
        if (x>z) s++;//如果今日气温比昨日气温高，连续上升天数+1 
        else //否则进入气温就没有昨日高 
        {
            if (s>sum) sum=s; //如果连续天数超过最长连续上升天数，就将最长连续上升天数改为s.
            s=1;//连续上升天数还原为q 
        }
        z=x;//今天，也就是明天所说的昨天 
    } 
    if (s>sum) sum=s;//如果到最后气温还是上升，那么就会被忽略，所以此处还要这个判断 
    cout<<sum;//记得输出23333333333 
    return 0;
}

```

---

## 作者：我是蒟弱 (赞：6)

这个代码应该比较容易理解。不想某个题解中用dp的大神那样~~花里胡哨的~~。

上代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
long long a[10000001];//声明a数组，表示气温。小伙伴们一定要注意哦，这么大的数组不声明在全局可能会爆掉。
int ans,maxx,n;//ans用来表示最终答案，maxx表示连着的最大值，n表示有几天。
int main(){
	scanf("%d",&n);//输入，scanf比cin要快，即使cin加上的ios::sync_with_stdio(false)这条加速语句。
	a[0]=1000000002;//把第0天设的比第1天大（比最大数据范围多1），这样第1天一定比第0天小
	for(int i=1;i<=n;i++){//循环进行输入及判断。
		scanf("%lld",&a[i]);//再次使用scanf语句输入，由于a数组是long long类型，所以使用%lld。
		if(a[i]<a[i-1]){//如果今天的小于昨天的（不满足）
			ans=max(ans,maxx);//ans就是原来的ans和maxx（由于本次循环maxx还没有加1，所以这个maxx还是上一天的。）中较大的一个
            //max函数包含在algorithm头文件中，是比较两个数的最大值。注意，是两个数哦！
            //拓展一下，如果要取三个数的最大值，可以写成max(a,max(b,c))
			maxx=1;//由于不合理了，就要把maxx归成1重新开始计算。
			continue;//进入下一次的循环
		}
		maxx++;//现在一定是满足题意的了（不满足的已经continue了），所以说maxx就可以加1了。 
	}
	printf("%d",ans);//输出ans，注意哦，printf也比加了ios::sync_with_stdio(false)的cout快
	return 0;//一定别忘了返回0
}
```
~~把这个代码借鉴一下吧。~~

不要着急，这个代码犯了一个错误，大家可以找一下。

这个代码的错误在if(a[i]<a[i-1])，因为题目说输出一个整数，表示最高气温一直**上升**的最长连续天数。所以说，气温连续两天一样是不行滴。

我们再来分析一下：

如果第二天气温没有第一天高，那么就得重新计算，并且得把表示连着上升天数的最大值清空。

所以说代码是这样的：
```cpp
if(a[i]<=a[i-1]){
	ans=max(ans,maxx);
	maxx=1;
}
```
————————————以下是正确代码，一步一步讲（看注释）：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
long long a[10000001];//声明a数组，表示气温。小伙伴们一定要注意哦，这么大的数组不声明在全局可能会爆掉。
int ans,maxx,n;//ans用来表示最终答案，maxx表示连着的最大值，n表示有几天。
int main(){
	scanf("%d",&n);//输入，scanf比cin要快，即使cin加上的ios::sync_with_stdio(false)这条加速语句。
	a[0]=1000000002;//把第0天设的比第1天大（比最大数据范围多1），这样第1天一定比第0天小
	for(int i=1;i<=n;i++){//循环进行输入及判断。
		scanf("%lld",&a[i]);//再次使用scanf语句输入，由于a数组是long long类型，所以使用%lld。
		if(a[i]<=a[i-1]){//如果今天的小于或等于昨天的（不满足）
			ans=max(ans,maxx);//ans就是原来的ans和maxx（由于本次循环maxx还没有加1，所以这个maxx还是上一天的。）中较大的一个
            //max函数包含在algorithm头文件中，是比较两个数的最大值。注意，是两个数哦！
            //拓展一下，如果要取三个数的最大值，可以写成max(a,max(b,c))
			maxx=1;//由于不合理了，就要把maxx归成1重新开始计算。
			continue;//进入下一次的循环
		}
		maxx++;//现在一定是满足题意的了（不满足的已经continue了），所以说maxx就可以加1了。 
	}
	printf("%d",ans);//输出ans，注意哦，printf也比加了ios::sync_with_stdio(false)的cout快
	return 0;//一定别忘了返回0
}
```
在此，还要强调一下，头文件包含以下两个的注意：
#include<algorithm>或者是#include<bits/stdc++.h>两个头文件的伙伴们，千万不要声明变量max，因为algorithm头文件里自带了max函数，编译系统会混淆的。


---

## 作者：谁懂谁伤心 (赞：6)

逐天判断就行，当第i天大于前一天时，就将持续天数加1，如果小于，则从1重算，最后输出最大的持续天数。

```cpp
#include<iostream>           
using namespace std;           
int main()           
{           
int a; cin >>a; int l=0,s,s2,maxl=0;         
scanf("%d",&s); l=1;         
for (int q=1;q<a;q++){scanf("%d",&s2); if (s2>s)l++; else {if (l>maxl)maxl=l; l=1;}s=s2;}         
if (l>maxl) maxl=l;       
cout <<maxl;         
return 0;          
}      
```

---

## 作者：decoqwq (赞：5)

水题
我用的是假动归不要信什么dp，真正的思路就是存储到每一个数的最长序列长度（保存在dp数组里），排个序即可

```cpp
#include "stdio.h"
#include "stdlib.h"
int dp[100000000];
int weather[100000000];
int comp(const void*a,const void*b)
{
    return *(int*)b-*(int*)a;//快排
}
int main()
{
    int n;
    scanf("%d",&n);
    dp[0]=1;//边界值
    for(int i=0;i<n;i++)
    {
        scanf("%d",&weather[i]);
        if(i==0)
        {
            continue;
        }
        if(weather[i]>weather[i-1])//如果成上升趋势就加一
        {
            dp[i]=dp[i-1]+1;
        }
        else//下降了，从来
        {
            dp[i]=1;
        }
    }
    qsort(dp,n,sizeof(int),comp);//排序找出最大的
    printf("%d",dp[0]);//从大到小排，大的在第一个
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

楼下的孩子们程序都太复杂了

那我来贴个超短的......

首先，题目既然要找出最高气温一直上升的最长连续天数

那么，我们很容易可以想到前后比较

只是这题要注意一些边界问题，还有

由于题目界限给太大，最好不要开数组

代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
long long x,t,s,n,m;
int main()
{
    cin>>n;
    cin>>t;s=1;//先输入第一天的最高温度，并将连续天数的初值定为1 
    for (int i=2;i<=n;i++) 
    {
        scanf("%I64d",&x);//输入第i天的最高温度 
        if (x>t) {s++;t=x;} else {if (s>m) m=s;s=1;t=x;}
        //前后比较，如果大于前一天的最高温度，将连续天数+1
        //如果小于前一天的最高温度，将连续天数和最大值作比较，并将连续天数的值定为1 
    }
    if (s>m) m=s;//传说中的边界问题 
    cout<<m;//输出 
    return 0;
}
```

---

## 作者：渡海 (赞：2)

**[一个不用数组的做法]**

适用于初学者看...因为通俗易懂..神犇就跳过看楼上的吧。

因为我感觉开数组的话就不符合这个“入门难度”的定义了，所以用了一个不需要开数组的做法。

很简单，一共三步。

1、读入第一项，记为a，并定义记录变量s=0；

2、循环：

读入第二项，判断s==0，记为b，如果b>a，那么ans++，记录变量s++，如果a<b，ans=1；

读入第三项，判断s!=0，记为a，如果a>b，那么ans++，记录变量s=0；如果a<b，ans=1；（注意这个ans=1！）

当然是求最大，所以加一个maxn。

代码不太长，思路很清晰。


```cpp
#include<cstdio>
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    int ans=0;
    int s=0,a,b,maxn=0;
    scanf("%d",&a);//键入第一个
    for(int i=2;i<=n;i++){//循环赋值a、b
        if(s==0){
            scanf("%d",&b);
            s++;
            if(b>a){
                ans++;
            }else{
                if(ans>maxn){//求最长
                    maxn=ans;
                }
                ans=1;
            }
        }else{//下面的跟上面一样了
            scanf("%d",&a);
            s=0;
            if(a>b){
                ans++;
            }else{
                if(ans>maxn){
                    maxn=ans;
                }
                ans=1;
            }
        }
    }
    printf("%d",maxn);
    return 0; 
} 
```
最后说一句，本题数据范围还是很水的，如果范围一大，开的数组就必须要大，但是用这种方法可以避免数组，还不错。

大神勿喷...


---

## 作者：过期薯条 (赞：2)

我忍不住吐槽这个题和P1420的相似程度。。。改了一点交上去就过了

```cpp
#include<iostream>
using namespace std;


int main()
{
    long long n;
    cin >> n;
    
    long long max(0), nmax(1), before, now;
    cin >> before;//before存储当前数据的上一个数据
    for (int i = 2; i <= n; i++) {
        cin >> now;//当前数据
        if (now - before <= 0) {//若当前数据小于上一个数据，那么保存当前连续天数（若大于最大值）
            if (nmax >= max)
                max = nmax;
            nmax = 1;//重置当前连续最大天数
        }
        else 
            ++nmax;
        before = now;//最后把当前元素设置为上一个元素
    }
    cout << max << endl;
    return 0;
}
```

---

## 作者：ZHBY_JLYZ (赞：2)

此题注意：c++切勿迷信cin，否则50分

```cpp

#include<iostream>
#include<cstdio> 
using namespace std;
int n,t,ti,tj,l,i;
int main()
{
    cin>>n;
    ti=0;
    t=0;
    for(i=1;i<=n;i++){
        tj=ti;
        //cin>>ti;50分
        scanf("%d",&ti);
        if(ti>tj)t++;
        else{
            if(t>l)l=t;
            t=1;
        }
    }
    cout<<l;
} 

```

---

## 作者：Jelly_Goat (赞：2)

## 天哪！竟然没人用优先队列！  
~~小金羊又来水题了...~~  

------------

优先队列中的大根堆帮助我们把时间复杂度降到O（n+logn）  
首先我们先了解一下大根堆...  
### 大根堆的性质：根节点比子节点大，  
这意味着最上面的节点的值是最大的。  
在STL模板库里面的优先队列也就是**大、小根堆**，  
#### 有自我维护的功能，  
利用这个性质，我们可以将其排序，  
### 这个题要排的序是：不下降子序列的长度。  

------------

来吧，上代码：  
```cpp
#include <iostream>
#include <queue>
//是优先队列的STL库
using namespace std;
priority_queue<int>qwq;
```

------------

这里打断一下，我要说明大小根堆的格式：(dalao请无视)
```cpp
//默认（大根堆）:
priority_queue<类型名>堆名;
//大根堆标准写法：
priority_queue<类型名,vector<类型名>,less<类型名> >堆名;
//小根堆标准写法：
priority_queue<类型名,vector<类型名>,greater<类型名> >堆名;
//类型支持pair<a,b>的类型（先比较a,后比较b）,
//支持string类型字典序排列。 
//注：两个>不能连起来，">>"是右移符！
```

------------

继续：(主函数)
```cpp
int main()
{
	int n,input,former,count=1;
	cin>>n;
	cin>>former;
	for (int i=1;i<n;i++)
	{
		cin>>input;
		if (input>former){count++;former=input;}
        //不下降，就count++，更新原先的值former
		else{qwq.push(count);former=input;count=1;}
        //下降了，count恢复初始值1，也要更新
	}
	qwq.push(count);//防止只有一天的毒瘤数据
	cout<<qwq.top();//输出最长的天数
	return 0;
}
```

------------

### ~~秒杀枚举、暴力、数组等...~~
蒟蒻求过!

---

## 作者：hyqs123456 (赞：2)

### p1567 python basic-ans
- python可直接忽略这道题的第一个输入

```
flag = 1
count = 0
last = 0
day = input() # useless
temp = list(input().split())
for i in temp:
    if int(i) > last:
        count += 1
    else:
        if count > flag:
            flag = count
        count = 1
    last = int(i)
print(flag)
```


---

## 作者：shenbeining (赞：2)

此题完全没有必要用数组。数组真心浪费时间……

```cpp
var
  n,t,t1,a,max:int64;
  i:longint;
begin
  readln(n);
  read(t1); //读入第一天的温度
  for i:=2 to n do
  begin
    read(t); //读入第2至第n天的温度
    if t>t1 then inc(a) //若这一天的温度比昨天的高，那么温度连续上升的天数＋1    
  else if a>max then begin max:=a; a:=1; end else a:=1;  //若a比max大，那么更新max的值并且把a置为1（这很important！）
    t1:=t; 
  end;
  write(max); //输出结果
```
一道彻头彻尾的水题……
end..

---

## 作者：AlexZy (赞：1)

**不知道怎么优化时空，只能用迭代器防止列表过大而超限**
```ccp
#输入数据
day_len = int(input())
days = list(map(int, input().split()))
#定义、处理变量
days = iter(days)
max_consi = consi = 1
today = 0
#迭代第一个元素，并将其定义为昨天
yesterday = days.__next__()
#迭代后面的元素
for i in range(1,day_len) :
    today = days.__next__()
    #今天比昨天热，连续天数+1
    if today > yesterday :
        consi += 1
    #否则，如果连续天数比最长连续天数长，就替换，否则重置连续天数
    else:
        if consi > max_consi :
            max_consi = consi
        consi = 1
    yesterday = today
print(max_consi)
```

---

## 作者：AOSTL (赞：1)

#P1567
写在前面：这是一道朴素而简单的题目。

此题类似最长上升子序列，只需要一次次地判（暴）断（力）即可。

但是，此题还是要动脑子的，如果从 [1...n]  一次次的查看，以 n<=10^7 的规模，会有很大的几率超时的（复杂度接近 n^2 ，所以最大是10^14，明显超时)。

不动脑子的方法，判断的代码部分如下，亲测40分：

```cpp
for (int i=1;i<=n;i++) //枚举每次的最大上升子序列 
    {
        int low=temp[i];
        num=1; 
        //初始化 
        for (int j=i+1;j<=n;j++) //从 temp[i+1] 开始逐次判断  
        {
            if (temp[j]>low)
            {
                low=temp[j];
                num++;
            }
            else //如果不上升就退出 
            {
                break;
            }
        }
        if (num>maxx) //判断是否更换 maxx 
        {
            maxx=num;
        }
        if (maxx==n) //小小的加速 
        {
            break;
        }
    }
```
然后我们可以发现，在第 i 次已经发现不上升时，我们在第 i+1 次还会继续判断，显然，这是waste of time。

显而易见，我们应该在 for（i=1;i<=n;???）阶段进行优化，将此阶段的i++改为i+=num（i=i+num），因为我们已经知道了在第 i 个时，最大上升子序列只到 i+num。

奉上满分代码：

```cpp
//P1567,睿智解法 

#include <iostream>
#include <cstdio>

using namespace std;

int n,maxx,num; //n是天数，maxx是当前的最大天数,num是每次的 maxx 
int temp[10000001]; //温度 

int main()
{
    scanf ("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf ("%d",&temp[i]);
    }
    
    for (int i=1;i<=n;i+=num) //枚举每次的最大上升子序列 
    {
        int low=temp[i];
        num=1; 
        //初始化 
        for (int j=i+1;j<=n;j++) //从 temp[i+1] 开始逐次判断  
        {
            if (temp[j]>low)
            {
                low=temp[j];
                num++;
            }
            else //如果不上升就退出 
            {
                break;
            }
        }
        if (num>maxx) //判断是否更换 maxx 
        {
            maxx=num;
        }
        if (maxx==n) //小小的加速 
        {
            break;
        }
    }
    
    printf ("%d",maxx);
    return 0;
}
```
###=THE END=###


---

## 作者：ysy1145469784 (赞：1)

初学者。。。不知道为啥限定给得那么大。。

代码如下：

```cpp
#include<iostream>
using namespace std;
int a[10000001];
int main()
{
    int n,i,d,m=0;
    cin>>n;
    a[0]=99999999;
    for(i=1;i<=n;i++)
    {
        cin>>a[i]; 
        if(a[i]>=a[i-1])
            d++;
        else
            d=1;
        if(d>m)
            m=d;
    }
    cout<<m; 
    return 0;
}
```

---

## 作者：Ultimate (赞：1)

只要循环判断有没有前后连续，有就inc（ans），没有就ans：=1【因为最少是连续一天】，再每次判断记录下最大值max


```cpp
var a:array[1..10000001] of longint;
    ans,i,j,k,n,max:longint;
begin
  readln(n);
  for i:=1 to n do read(a[i]);//读入
  ans:=1;
  max:=0;//初始化
  for i:=1 to n-1 do
  begin
    if a[i]<a[i+1] then inc(ans)//统计连续天数
      else ans:=1;//不连续则赋值为1
    if ans>max then max:=ans;//每次记录最大值
  end;
  writeln(max);//输出
end.
```

---

## 作者：zhych (赞：1)

```cpp
//#新手们不要抄题解233
var a:array[1..10000000] of longint; //存每天的最高温度
      n,i,c,j,d:longint;
begin
 readln(n);
 c:=1; //最长持续的天数[局部最优解，就是当前最长的]
 d:=0;//最长持续的天数[全部最优解，就是结果最长的]用来存储结果
 for i:=1 to n do read(a[i]); //读入
 for i:=1 to n do
  if a[i+1]>a[i] then inc(c) //如果在上升则加1
                       else begin
                               if c>d then d:=c; //如果全局最优解比局部最优解小，就把局部最优解赋值给全局最优解。
                               c:=1;//清空局部最优解，找下一个局部最优解
                              end;
 writeln(d);//输出全局最优解
end.
```

---

## 作者：chenxi (赞：1)

```delphi

var
  n,i,a,b,day,ans:longint;  
begin  
  readln(n);  
  for i:=1 to n do  
  begin  
    read(b);  //这一天的温度
    if a<b then inc(day) //好的继续上涨了
    else  //下降了
    begin  
      if day>ans then ans:=day;  //这是最长连续上涨天数吗
      day:=1//还原到1天了
    end;  
    a:=b  //替换，下一次循环以这个为上一个来比较上升了没
  end;  
  if day>ans then ans:=day;  //最后一次统计
  write(ans);//最多天数
end.

```

---

## 作者：方子正 (赞：1)

```python
input()
increasing_length = 1
max_length = 0
prev = float('inf')
for x in input().split(' '):
    t = int(x)
    if t>prev:
        increasing_length += 1
    else:
        if increasing_length>max_length:
            max_length = increasing_length
        increasing_length = 1
    prev = t
print(max_length)
```

---

## 作者：封禁用户 (赞：1)

这一题远没有dalao们讲的那么麻烦，Pascal只要开足数组，边读边做不成问题。
```
var
  a:array[1..10000000] of longint;
  i,n,max,ans:longint;
begin
  readln(n);
  read(a[1]);  //先读一个
  ans:=1;   //最短长度怎么也是一
  for i:=2 to n do
  begin
    read(a[i]);  //天数++
    if (a[i]>a[i-1]) then  //如果最高气温一直上升
	begin 
      inc(ans);   //累计天数++
      if i<>n then continue; //在这里跳过一层循环
    end;
	if ans>max then max:=ans; 
//如果没有在前面跳过循环，就说明一直上升的最高气温结束了，这里只要比较一下当前已保存的最大值和累计天数就行了。
	ans:=1;  //累计归零
  end;
  writeln(max);
end.
```

---

## 作者：wubaiting2020 (赞：1)

这题与最长连数（P1420）非常相似，这个是判断上升，那个是判断相邻+1.

本题最多有10^7次天，所以数组要开很大

附上代码：

```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
using namespace std;
int a[10000005];//大数组开在主函数前面
int main()
{
    int n,i,z=1,s=1;//它不管怎么样都会有本身一天，所以赋初值为一
    cin>>n;
    for(i=1;i<=n;i++)cin>>a[i];
    for(i=1;i<=n;i++)
    {
        if(z>s)s=z;//如果连续天数比现在最高连续天数高，就修改最高天数
        if(a[i]>a[i-1])z++;//如果今天比昨天气温高，连续天数++
        else z=1;//没有高，连续天数就断了，回到初值1
    }
    cout<<s;//输出最高连续天数
  return 0;
}

```

---

## 作者：skymirror (赞：1)

这道题就是求最大上升子序列

想法很简单：开两个数组a，b用来储存这个数和它对应的最大子序列

比如：假设是第i个数，如果a[i]>a[i-1],b[i]+=b[i-1]，因为这个数比前一个大，最大子序列就是上一个+1

如果a[i]<=a[i-1],b[i]=1，因为这个数比上一个小，就从头开始

下面是代码实现：


```cpp
#include<iostream>
using namespace std;
int n,a[10000010],b[10000010],ans=0;   //大数组需要开在主函数外面 
int main()
{
    a[0]=0;                   
    b[0]=0;                            //初始化
    cin>>n;
    for(int i=1;i<=n;i++)              //这个程序最经典的部分，一个循环搞定 
    {
        cin>>a[i];                     //输入 
        if(a[i]>a[i-1]) b[i]=b[i-1]+1;      //进行比较，如果比上一个大则这个数列继续上升 
        else b[i]=1;                        //比上一个小就从头开始 
        if(ans<b[i]) ans=b[i];         //重要环节：为省去一个循环，
                        //直接在这个循环里比较出ans的最大值 
    }
    cout<<ans;                         //输出 
return 0;
}
```

---

## 作者：初音赛高 (赞：0)

#  庆祝AC
看了一下，没有python题解，
翻了翻提交记录，也只有几个python3的AC了
苦于python都是一整行读入，TLE了无数次，放一下python2的AC代码纪念一下
```python
n=input()
hot=raw_input().split()
anss=1
count=0
last=0
for i in hot:
    if int(i)>last:count+=1
    else:
        if count>anss:anss=count
        count=1
    last=int(i)
print anss
```

---

## 作者：jklover (赞：0)

O（n)的时间复杂度，10^7的数据范围，我们直接依次读入 模拟





```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,k,maxn=-1,sum=1,p=-1;//maxn表示天数最大值 sum表示当前累加的和 p表示上一个数据 k表示当前读入的数 
    scanf("%d",&n);
    while(n--)//执行n次 
    {
        scanf("%d",&k);
        if(k>p)//上升 
            sum++,p=k;//当前上升天数+1，更新“前一个”数据 
        else//不上升了 
            {
                maxn=max(maxn,sum);//更新maxn 
                sum=1;//新一轮 算上当天 
                p=k;//更新“前一个” 
            }
    }
    printf("%d",maxn);
    return 0;
}
```

---

## 作者：shengyuch (赞：0)

//因为是最长连续天数，因此只需要开辟一个数组（用变量也行），再判断第i天的天气是否等于第i-1天的温度，是则++，不是赋为1，统计下1个.


code:

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
int a[10000005],f[10000005];//开辟数组，f存放连续天数
int main(){
    int n,i,ans=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);
    f[1]=1;
    for(i=2;i<=n;i++){
        if(a[i]>a[i-1])
        f[i]=f[i-1]+1;//若是连续天数，则加1，否则置为1，进行下一轮
        else{
            ans=max(ans,f[i-1]);//统计最大值
            f[i]=1;
        }
    }
    ans=max(ans,f[n]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：bestzzy (赞：0)

没用数组，怕爆内存

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int n,ans=1,i=1,a,max=0,p=0;
    cin>>n;
    while (i!=n)
    {
        cin>>a;
        if (p<a) ans++;
        else ans=1;//清零；
        if (ans>max) max=ans;
        p=a;//循环覆盖；
        i++;
    }
cout<<max<<endl;    
}
```

---

## 作者：ztz_cpp (赞：0)

#其实真的很简单——但我怕不过，所以解释一下。



```cpp
#include<iostream>
using namespace std;
int num[10000001];//数组，依题意定的。 
int main(){
    int n,i,day,max=0;
    cin>>n;
    num[0]=9999;//为了符合i=1，这样第一个就不会加。 
    for(i=1;i<+n;i++){
        cin>>num[i];//输入。 
        if(num[i]>num[i-1])
            day++;
        else
            day=1;
        if(day>max)//如果当前大于最大，最大等于当前。 
            max=day;
    }
    cout<<max;//输出。 
    return 0;//return 0 
}
```
ps：
#管理员我提交其他题都没过，这次让我过吧！！！。


---

## 作者：YczSS (赞：0)

```cpp
var
  a,b:array[1..10000000]of longint;
  max,i,n,s:longint;
begin
  readln(n);                                                                       //读入
  for i:=1 to n do read(a[i]);
  s:=1; fillchar(b,sizeof(b),0);
  for i:=2 to n do if a[i]>a[i-1] then inc(b[s]) else inc(s);  //找连续的升温天
  max:=b[1];
  for i:=2 to n do if b[i]>max then max:=b[i];                  //找连续升温天里哪段天数最多
  writeln(max+1);
end.
```

---


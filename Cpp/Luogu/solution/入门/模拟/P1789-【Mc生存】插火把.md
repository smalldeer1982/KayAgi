# 【Mc生存】插火把

## 题目描述

话说有一天 linyorson 在“我的世界”开了一个 $n \times n$ 的方阵，现在他有 $m$ 个火把和 $k$ 个萤石，分别放在 $(x_1, y_1) \sim (x_m, y_m)$ 和 $(o_1, p_1) \sim (o_k, p_k)$ 的位置，没有光并且没放东西的地方会生成怪物。请问在这个方阵中有几个点会生成怪物？

**注意，在本题中火把与萤石的照明范围与原版 Minecraft（我的世界）不尽相同，请以本题中的描述为准。**

P.S. 火把的照亮范围是：

|暗|暗|光|暗|暗|
|:-:|:-:|:-:|:-:|:-:|
|**暗**|**光**|**光**|**光**|**暗**|
|**光**|**光**|**火把**|**光**|**光**|
|**暗**|**光**|**光**|**光**|**暗**|
|**暗**|**暗**|**光**|**暗**|**暗**|

萤石：

|**光**|**光**|**光**|**光**|**光**|
|:-:|:-:|:-:|:-:|:-:|
|**光**|**光**|**光**|**光**|**光**|
|**光**|**光**|**萤石**|**光**|**光**|
|**光**|**光**|**光**|**光**|**光**|
|**光**|**光**|**光**|**光**|**光**|

## 说明/提示

数据保证，$1 \le n \le 100$，$1 \leq m+k \leq 25$，$1 \leq m \leq 25$，$0 \leq k \leq 5$。

## 样例 #1

### 输入

```
5 1 0
3 3
```

### 输出

```
12
```

# 题解

## 作者：CYJian (赞：690)

思路很简单：从每一个火把或萤石为中心枚举每一个有亮光的地方，标记后统计没有标记的地方的个数即可。。

 
但是。。

直接暴力写的话。。

少则六七十行，

多则。。（不忍直视的长。。）

 
所以，为了代码简洁，

我就为大家带来高强度for的自带注释的压缩版本：

（当当当当）

 




```cpp
#include <bits/stdc++.h> 
using namespace std;
int n, m, k, a, b, ans;
int s[5005][5005];
bool pd(int x, int y) { //判断是否越界 
    if(x < 1 || y < 1 || x > n || y > n) return 0;
    return 1;
}
int main() {
    scanf("%d%d%d", &n, &m, &k); //读入 
    for(int i = 1; i <= m + k; i++) { //由于计算火把和萤石的步骤很像，所以合并了 
        scanf("%d%d", &a, &b); //读入坐标 
        for(int x = -2; x <= 2; x++)
            for(int y = -2; y <= 2; y++) //枚举5*5的方阵(通过计算距离) 
                if((i > m || abs(x) + abs(y) <= 2) && pd(x + a, b + y))
                //如果是萤石(i > m)或者x与y的坐标差的和不超过2(想一想为什么)并且
                //没有越界就标记 
                    s[x + a][b + y]++;
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            ans += s[i][j] == 0; //枚举每一个方格，看看是不是==0(即没有亮光) 
    printf("%d\n", ans); //输出结果 
    return 0;
}
//希望我能帮到各位。。 
//希望大慈大悲的管理员给过。。
```

---

## 作者：2011hym (赞：12)

## 前言

果真和题解区大佬说的一样，暴力需要大几十行（崩溃）。

[更好的阅读体验。](https://blog.csdn.net/Hymmeishili/article/details/148372795?sharetype=blogdetail&sharerId=148372795&sharerefer=PC&sharesource=Hymmeishili&spm=1011.2480.3001.8118)

## 题目分析
我们需要计算一个 $n \times n$ 的方阵中，有多少个点没有被火把或萤石照亮。

而且火把和萤石的照亮范围不同，需要分别处理。

## 解决思路
先处理火把：对于每个火把位置，将其周围范围内的点标记为照亮。

再处理萤石：对于每个萤石位置，将其周围范围内的点标记为照亮。

最后再遍历即可。

## 代码实现

不知道为啥，长得有点像 BFS。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,x,y,ans;
bool light[105][105];
int main(){
    cin>>n>>m>>k;
    for (int i=1;i<=m;i++){
        cin>>x>>y;
        for(int dx=-2;dx<=2;dx++){
            for(int dy=-2;dy<=2;dy++){
                int nx=x+dx,ny=y+dy;
                if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&abs(dx)+abs(dy)<=2){
                    light[nx][ny]=true;
                }
            }
        }
    }
    for (int i=1;i<=k;i++){
        cin>>x>>y;
        for(int dx=-2;dx<=2;dx++){
            for(int dy=-2;dy<=2;dy++){
                int nx=x+dx,ny=y+dy;
                if(nx>=1&&nx<=n&&ny>=1&&ny<=n){
                    light[nx][ny]=true;
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(light[i][j]==false){
                ans++;
            }
        }
    }
    cout<<ans;
    return 0;
}


```

时间复杂度大约为 $O(n^2)$，在当前题目条件下还是比较优秀的。

---

## 作者：Cake_W (赞：6)

# 洛谷P1789题解
[题目传送门](https://www.luogu.com.cn/problem/P1789)

感谢@MINMIN_找出向量图的问题。
## 思路
用标记数组标记有光和放置萤石或火把的区域，然后统计未被标记的数量即可。
## 分析样例
样例输入
```cpp
5 1 0
3 3
```
样例输出

```cpp
12
```
以下是我画的一张图（橙色部分为暗的区域）：
![](https://cdn.luogu.com.cn/upload/image_hosting/rfxk90b4.png)
那么我们就可以来模拟这个过程了！
## 具体步骤
0. 定义一个标记数组（因为用来标记，所以可以用布尔类型）。
```cpp
bool vis[105][105];
```
1. 确定偏移量，拿火把来举例：
```cpp
const int h_dx[]={-2,-1,-1,-1,0,0,0,0,0,1,1,1,2};
const int h_dy[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};
/*
h_dx代表x[i]的偏移量，h_dy代表y[i]的偏移量。比如说-2加上当前的x和0加上当前的y就相当于在（x-2,y）的位置上 
也就是说到了标A的位置上：
    |暗|暗| A  |暗|暗|
    |暗|光| 光 |光|暗|
    |光|光|x ,y|光|光|
    |暗|光| 光 |光|暗|
    |暗|暗| 光 |暗|暗|
*/ 
```
那么萤石的偏移量就好办了：

```cpp
const int y_dx[]={-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2};
const int y_dy[]={-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2};
```
2. 接下来，如果当前坐标不越界，那么就可以标记当前位置了：
```cpp
for(int j=0;j<13;j++)
{
	int sx=x+h_dx[j];//当前坐标=x+（火把）偏移量
	int sy=y+h_dy[j];//当前坐标=y+（火把）偏移量
	if(sx>=1&&sx<=n&&sy>=1&&sy<=n)//判断是否越界
	{
    	vis[sx][sy]=1;//标记
	}
}
```
萤石同理：

```cpp
for(int j=0;j<25;j++)
{
	int sx=x+y_dx[j];
	int sy=y+y_dy[j];
	if(sx>=1&&sx<=n&&sy>=1&&sy<=n)
	{
		vis[sx][sy]=1;
	}
}
```
3. 接下来就是最后一步了：统计未被标记的数量。
```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=n;j++)
	{
		if(!vis[i][j])//如果这个数没有被标记 
		{
			cnt++;//那么就让计数器加1 
		}
	}
}
```
## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x,y,cnt=0;
bool vis[105][105];
const int h_dx[]={-2,-1,-1,-1,0,0,0,0,0,1,1,1,2};//火把偏移量 
const int h_dy[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};//火把偏移量 
const int y_dx[]={-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2};//萤石偏移量 
const int y_dy[]={-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2};//萤石偏移量
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		for(int j=0;j<13;j++)
		{
			int sx=x+h_dx[j];//当前坐标=x+（火把）偏移量
			int sy=y+h_dy[j];//当前坐标=y+（火把）偏移量
			if(sx>=1&&sx<=n&&sy>=1&&sy<=n)
			{
				vis[sx][sy]=1;//标记 
			}
		}
	}
	for(int i=1;i<=k;i++)
	{
		cin>>x>>y;
		for(int j=0;j<25;j++)
		{
			int sx=x+y_dx[j];//当前坐标=x+（萤石）偏移量
			int sy=y+y_dy[j];//当前坐标=y+（萤石）偏移量
			if(sx>=1&&sx<=n&&sy>=1&&sy<=n)
			{
				vis[sx][sy]=1;//标记 
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(!vis[i][j])//如果这个数没有被标记 
			{
				cnt++;//那么就让计数器加1 
			}
		}
	}
	cout<<cnt;
	return 0;
} 
```
完结撒花！

---

## 作者：Ashankamiko (赞：4)

# 题目简述
### 题意
给定一张大小为 $n \times n$ 地图、 $m$ 根火把和 $k$ 个萤石，照亮范围为 $5 \times 5$，如下所示（$1$ 表示照亮，$0$ 表示未照亮）。

火把：
```
0 0 1 0 0
0 1 1 1 0
1 1 1 1 1
0 1 1 1 0
0 0 1 0 0
```
萤石：
```
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
```
### 思路
这题很简单，只需模拟即可，最后统计有多少个点是未被照亮的。

但需注意，输入的是 $x$ 和 $y$，但照亮范围可以到 $x - 2$ 和 $y - 2$，当 $x$ 或 $y$ 为 $0$ 时，有可能会访问到 $maps_{-2,-2}$，很显然直接越界访问然后一分不得。

所以我们需要用偏移量，每次访问时都额外 $+2$，防止越界，输出时下标从 $3$ 开始。
## [AC 代码](https://www.luogu.com.cn/record/198357426)
```cpp
#include <bits/stdc++.h>
using namespace std;
bool a[10000][10000]; //地图
int n, m, k, cnt;

int main() {
	cin >> n >> m >> k;
	int cx, cy;
	for (int i = 3; i <= 2 + m; i++) {
		cin >> cx >> cy;
		cx += 2, cy += 2; //偏移量
		for (int i = cx - 2; i < cx + 3; i++)
			a[i][cy] = true;
		for (int i = cy - 2; i < cy + 3; i++)
			a[cx][i] = true;
		a[cx + 1][cy + 1] = true, a[cx - 1][cy + 1] = true;
		a[cx - 1][cy - 1] = true, a[cx + 1][cy - 1] = true; //照亮地图
	}
	for (int i = 3; i <= 2 + k; i++) {
		cin >> cx >> cy;
		cx += 2, cy += 2;
		for (int i = cx - 2; i <= cx + 2; i++)
			for (int j = cy - 2; j <= cy + 2; j++)
				a[i][j] = true; //萤石范围3*3更好处理
	}
	for (int i = 3; i <= 2 + n; i++) //注意初始为3
		for (int j = 3; j <= n + 2; j++)
			if (a[i][j] == false) //没有被照亮
				cnt++;
	cout << cnt; //未被照亮的点的数量
	return 0;
}
```

---

## 作者：ZYX0716 (赞：3)

### [P1789 【Mc生存】插火把](https://www.luogu.com.cn/problem/P1789)

## 算法：

本题采用简单粗暴的**枚举法**。对于每一个火把和萤石，都需将其影响范围内的地方进行标记。

题面最下方给出了数据范围：$1 \le m+k \le 25，1 \le m \le 25，0 \le k \le 5$。通过计算最坏情况下的时间复杂度：$5 \times 25 + 20 \times 13 = 385$，时间绰绰有余，不用担心超时。

思路听懂后，代码非常好写。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x,y,a[110][110],cnt;
int dir1[15][2]={-2,0,
				 -1,-1, -1,0, -1,1,
				 0,-2, 0,-1, 0,0, 0,1, 0,2,
				 1,-1, 1,0, 1,1,
				 2,0};
//dir1表示(x,y)的前后左右及斜方的共13位。
int dir2[30][2]={-2,-2, -2,-1, -2,0, -2,1, -2,2,
			 	 -1,-2, -1,-1, -1,0, -1,1, -1,2,
			      0,-2,  0,-1,  0,0,  0,1,  0,2,
			      1,-2,  1,-1,  1,0,  1,1,  1,2,
			      2,-2,  2,-1,  2,0,  2,1,  2,2};
//dir2表示(x,y)周围5*5的方阵。
int main(){
	scanf("%d%d%d",&n,&m,&k);
	while(m--){//枚举每个火把。
		scanf("%d%d",&x,&y);
		for(int i=0;i<13;i++){
			int nx=x+dir1[i][0],ny=y+dir1[i][1];
			if(nx<1 || ny<1 || nx>n || ny>n)continue;
			a[nx][ny]++;
			if(a[nx][ny]==1)cnt++;//此次被照亮，则计数器+1。
		}
	}while(k--){//枚举每个萤石。
		scanf("%d%d",&x,&y);
		for(int i=0;i<25;i++){
			int nx=x+dir2[i][0],ny=y+dir2[i][1];
			if(nx<1 || ny<1 || nx>n || ny>n)continue;
			a[nx][ny]++;
			if(a[nx][ny]==1)cnt++;//去重，防止多算。
		}
	}
	printf("%d",n*n-cnt);//总个数-被光照亮的个数。
	return 0;//好习惯。
}
```
有疑问及时私信哦！

---

## 作者：chengengyang (赞：2)

## 题目解释：

给定一张大小为 $n\times n$ 地图、$m$ 根火把和 $k$ 个萤石，要让我们求有都少个格子没有被照亮。

## 思路：

我们可以暴力打标记来解决这个问题，首先我们先建一张图用来记录这个点有没有被点亮，在暴力的同时还需要判断这个点有没有越界。

## AC 码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=105;
int n,m,k,ans=0;
bool mp[N][N];//标记数组 
bool check(int x,int y){//判断是否越界 
	if(x>=0&&y>=0&&x<=n&&y<=n)return 1;
	else return 0;
}
void huoba(int x,int y){//火把照亮范围 
	if(check(x,y+2))mp[x][y+2]=1;
	if(check(x-1,y+1))mp[x-1][y+1]=1;
	if(check(x,y+1))mp[x][y+1]=1;
	if(check(x+1,y+1))mp[x+1][y+1]=1;
	if(check(x-2,y))mp[x-2][y]=1;
	if(check(x-1,y))mp[x-1][y]=1;
	if(check(x,y))mp[x][y]=1;
	if(check(x+1,y))mp[x+1][y]=1;
	if(check(x+2,y))mp[x+2][y]=1;
	if(check(x-1,y-1))mp[x-1][y-1]=1;
	if(check(x,y-1))mp[x][y-1]=1;
	if(check(x+1,y-1))mp[x+1][y-1]=1;
	if(check(x,y-2))mp[x][y-2]=1;
}
void yingshi(int x,int y){//萤石照亮范围 
	for(int i=x-2;i<=x+2;i++){
		for(int j=y-2;j<=y+2;j++){
			if(check(i,j))mp[i][j]=1;
		}
	}
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){//输入火把数
		int x,y;
		cin>>x>>y;
		huoba(x,y);//打标记
	}
	for(int i=1;i<=k;i++){//输入萤石数
		int x,y;
		cin>>x>>y;
		yingshi(x,y);//打标记
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(!mp[i][j])ans++;//如果未被照亮 
		}
	}
	cout<<ans;//输出答案
	return 0;
}
```

---

## 作者：XXXL_jzl (赞：0)

# 题解：P1789 【Mc生存】插火把

## 题目分析

有一个 $n \times n$ 的方阵，手上有 $m$ 个火把和 $k$ 个萤石。\
给定两者的照亮范围，让你求在放完火把和萤石后，有多少个地方是没有光的（即会生成怪物的地方有几个）。\
由于 $1 \le n \le 100$ 数据范围足够小，考虑暴力写法之打标记。

## 题目写法

这一题，可以用初学者也会的偏移量来写。\
已知，火把和萤石的照亮范围，我们就可以用上偏移量，表示出两者的照亮范围。\
当给定坐标时，按照偏移量为方阵打上标记。\
全部打完标记后，只需要求没有被标记的就可以了。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, k, x, y, o, p, ans = 0;
//火把x坐标偏移量
int dx1[13] = {2, 0, -2, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1};
//火把y坐标偏移量
int dy1[13] = {0, 2, 0, -2, 0, 1, -1, 1, 0, -1, 0, 1, -1};
//萤石x坐标偏移量
int dx2[25] = {-2, -2, -2, -2, -2, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2};
//萤石y坐标偏移量
int dy2[25] = {-2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2};

//模拟方阵数组
int a[110][110];
int main() {
	cin >> n >> m >> k;
  //全部清零
	memset(a, 0, sizeof(a));
	for(int i=1; i<=m; i++) {
    //火把的x，y坐标
		cin >> x >> y;
    //根据偏移量打上标记
		for(int j=0; j<13; j++) a[x + dx1[j]][y + dy1[j]] = 1;
	}
	for(int i=1; i<=k; i++) {
    //萤石的x，y坐标
		cin >> o >> p;
    //根据偏移量打上标记
		for(int j=0; j<25; j++) a[o + dx2[j]][p + dy2[j]] = 1;
	}
  //找没有打上标记的，即会生成怪物的地方
	for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) if(a[i][j] == 0) ans++;
	cout << ans;
	return 0;
}
```

---

## 作者：return_second (赞：0)

# 思路

对于每个火把和萤石，用一个数组标记点是否被照亮，然后根据位置进行标记。

首先是火把，我把火把分成了两个部分，分别是十字和四个角上的。十字可以用循环处理，四个角我用了一个数组储存偏移量方便计算。然后萤石相对简单，只要处理一个正方形就行了。

但是有一个坑点，可能会数组越界，需要注意一下。

# 代码实现

给出代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int f[][2]={{1,1},{-1,1},{1,-1},{-1,-1}};//偏移量
const int N=105;
int n,m,k;
bool flag[N][N];
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        for(int j=max(1,x-2);j<=min(n,x+2);j++)//小技巧：和边界取max/min，保证不会越界
            flag[j][y]=true;
        for(int j=max(1,y-2);j<=min(n,y+2);j++)
            flag[x][j]=true;
        for(int j=0;j<4;j++)
        {
        	int nx=x+f[j][0],ny=y+f[j][1];
        	if(nx<1||nx>n||ny<1||ny>n)continue;
        	flag[nx][ny]=true;
        }
    }
    for(int i=1;i<=k;i++)
    {
        int o,p;
        scanf("%d%d",&o,&p);
        flag[o][p]=true;
        for(int i=max(1,o-2);i<=min(n,o+2);i++)
            for(int j=max(1,p-2);j<=min(n,p+2);j++)
                flag[i][j]=true;
    }
    int cnt=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(flag[i][j])
                cnt++;
    printf("%d\n",n*n-cnt);
	return 0;
}
```

---


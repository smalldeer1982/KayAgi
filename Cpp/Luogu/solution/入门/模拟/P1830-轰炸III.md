# 轰炸III

## 题目背景

一个大小为 $n\times m$ 的城市遭到了 $x$ 次轰炸，每次都炸了一个每条边都与边界平行的矩形。


## 题目描述

在轰炸后，有 $y$ 个关键点，指挥官想知道，它们有没有受到过轰炸，如果有，被炸了几次，最后一次是第几轮。


## 说明/提示

对于 $100\%$ 数据，满足 $1\le n,m\le 100$。


## 样例 #1

### 输入

```
10 10 2 3
1 1 5 5
5 5 10 10
3 2
5 5
7 1
```

### 输出

```
Y 1 1
Y 2 2
N
```

# 题解

## 作者：蕙兰居士 (赞：132)

## 主要思路：
### 1、用mp二维数组存下地图
### 2、算出被轰炸的范围:（x1～x2，y1～y2）
### 3、将被轰炸过的坐标++，用于输出被轰炸过的次数；并用final数组记录每个被轰炸过的坐标的最后一次轰炸
### 4、如果坐标为0，说明没有被轰炸，输出“N”并换行；如果坐标不为0，说明已被轰炸，输出“Y ”、被轰炸的次数、“ ”、该坐标的最后一次轰炸并换行
#### AC代码--
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,x,y,final[110][110];
	int x1,y1,x2,y2;
	int checkx,checky;
	int mp[110][110];
	memset(mp,0,sizeof(mp));
	memset(final,0,sizeof(final));
	cin>>n>>m>>x>>y;
	for(int i=1;i<=x;i++){
		cin>>x1>>y1>>x2>>y2;
		for(int j=x1;j<=x2;j++){
			for(int k=y1;k<=y2;k++){
				mp[j][k]++;
				final[j][k]=i;
			}
		}
	}
	for(int i=1;i<=y;i++){
		cin>>checkx>>checky;
		if(mp[checkx][checky]==0)
			cout<<"N"<<endl;
		else
			cout<<"Y "<<mp[checkx][checky]<<" "<<final[checkx][checky]<<endl;
	}
	return 0;
}
```
##### 本人第3篇题解，请多多关（tiāo）照（cuò)

---

## 作者：Peter_Z (赞：33)

其实时间复杂度可以从O(n^3)降到O(n^2)

思路：用数组记录下每次轰炸的四角（x1，y1，x2，y2）。

对于每一个关键点（askx，asky），遍历每次轰炸求出轰炸次数和最后轰炸的点。

时间复杂度：O(xy)

----------------------------------------------------------------------------------------

上代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int size=5002;
int x1[size],y1[size],x2[size],y2[size];    //保存轰炸的四角 
int main() {
    int n,m,x,y,askx,asky;
    scanf("%d %d %d %d",&n,&m,&x,&y);    //题目给出的n m x y 
    //实际上n和m没有任何用处。 
    for(int i=1; i<=x; i++)
        scanf("%d %d %d %d",&x1[i],&y1[i],&x2[i],&y2[i]);
    int ans=0,last=0;        //每个点轰炸多少次和最后一次被轰炸的序号 
    for(int i=1; i<=y; i++) {
        ans=0;
        scanf("%d %d",&askx,&asky);
        for(int j=1; j<=x; j++) {        //对每一次轰炸进行遍历 
            if(askx>=x1[j] && askx<=x2[j]) {
                if(asky>=y1[j] && asky<=y2[j]) {
                    //满足条件则记录结果 
                    ans++;
                    last=j;
                }
            }
        }
        if(!ans)
            puts("N");    //如果ans为0，即未轰炸时，输出"N" 
        else
            printf("Y %d %d\n",ans,last);    //否则输出结果 
    }
    return 0;
}
```

---

## 作者：usqwedf (赞：25)

模拟一下即可。

```cpp

#include<iostream>  
using namespace std;  
int n,m,t1,t2,map[1000][1000],last[1000][1000],k,i,j,x1,x2,y1,y2;  
int main(){  
    scanf("%d%d%d%d",&n,&m,&t1,&t2);  
    for (k=1;k<=t1;k++){  
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);  
        for (i=x1;i<=x2;i++)  
          for (j=y1;j<=y2;j++) {  
             map[i][j]++;  //轰炸次数
             last[i][j]=k;  //记录最后一次
        }  
    }  
    for (k=1;k<=t2;k++){  
        scanf("%d%d",&x1,&y1);  
        if (map[x1][y1]!=0) printf("Y %d %d\n",map[x1][y1],last[x1][y1]); else printf("N");  
    }  
}  

```
时间复杂度 O(n^3)，由于本题数据很弱，所以可以秒过。。


---

## 作者：judgejudge (赞：19)

# 新手必看！！！


------------

本题解比较通俗易懂，下面说一下我的思路：

1. 判断是否在区间范围内
1. 如果是，总量+1，且groud(表示轮数)等于该回合。
1. 输出，接着循环


------------

下面奉上AC代码：
```cpp
#include <iostream>
using namespace std;
int a[1000],b[1000],c[1000],d[1000];
int row[1000],col[1000];
int main(){
	int i,j,k,n,m,sum=0,groud;
	int x,y;
	cin>>n>>m>>x>>y;
	for(i=1;i<=x;i++)cin>>a[i]>>b[i]>>c[i]>>d[i];
	for(i=1;i<=y;i++){
	    cin>>row[i]>>col[i];//这里为了缩短时间，直接开始判断
	    sum=0;
	    for(j=1;j<=x;j++){
	    	if(row[i]>=a[j]&&row[i]<=c[j]&&col[i]>=b[j]&&col[i]<=d[j]){//判断是否在区间范围内
	    		sum++;
	    		groud=j;//这里的巧妙就是它总可以得到最后一轮
			}
		}
		if(sum>0)cout<<"Y"<<" "<<sum<<" "<<groud<<endl;//判断是否可以输出
		else cout<<"N"<<endl;
		sum=0;//别忘了清0
		groud=0;//其实groud清不清都无所谓，保底还是清一下
	}
	return 0;//程序结束
}
```

---

## 作者：学霸徐煌晟 (赞：16)

# 这是本蒟蒻第一次写题解，有错请指出
这是一道**模拟**题

只要先定义一个100*100的数组，再按坐标一个一个炸过去，最后输出答案就行了。

细节:

1、不要搞错炸的坐标，是(x1～x2，y1～y2)

2、不要忘记**换行**

3、NY要大写

好，现在上**AC**代码 _（只适应这一道题）_ 
```
#include<bits/stdc++.h>//令人兴奋的万能头
using namespace std;
int n,m,x,y,xx,yy,xxx,yyy,a[101][101],b[101][101]; 
//这里可能定义的比较奇怪，见谅
int main()
{
    cin>>n>>m>>x>>y;//输入行列以及轰炸次数和关键点数量
    for(int i=1;i<=x;++i)//枚举轰炸
    {
    	cin>>xx>>yy>>xxx>>yyy;//输入轰炸的左上角坐标和右下角坐标
    	for(int ii=xx;ii<=xxx;++ii)//按坐标把轰炸的矩阵一个一个枚举过去
    	  for(int jj=yy;jj<=yyy;++jj)
          {
              ++a[ii][jj];//把此坐标轰炸的次数加1
              b[ii][jj]=i;//把值改成最后轰炸的一轮
          }
	}
    for(int i=1;i<=y;++i)//枚举关键点
    {
    	cin>>xx>>yy;//输入第i个关键点的坐标
    	if(a[xx][yy]==0)//判断此关键点有没有被炸过
    	  cout<<"N\n";else//没炸过输出N
    	  cout<<"Y "<<a[xx][yy]<<' '<<b[xx][yy]<<"\n";//否则输出Y、此关键点被轰炸次数和最后轰炸的一轮
    }
    return 0;//华丽的结束
}
```
_毕竟是第一次，请多多关照~~_

---

## 作者：Shikita (赞：9)

# 好吧又是一道模拟题，但是每次模拟题总会让我回想起被TLE支配的恐惧，于是加上了一点小优化（非常小）
既然题目数据不大，而且也就遍历每一个方块，这都是常规操作，毕竟是模拟题
## 代码
```
#include<iostream>
#include<stack>
#include<cstring>
#include<cstdio>
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}//读入小优化
struct node{int x1,y1,x2,y2,z;};
struct cot{int x,y;};
stack<node>st;
cot a[105][105];
int main()
{
	int n=read(),m=read(),x=read(),y=read();
	for(int i=1;i<=x;++i)
	{
		node f;
		f.x1=read(),f.y1=read(),f.x2=read(),f.y2=read(),f.z=i;
		st.push(f);//压到栈内倒序处理
	}
	while(!st.empty())
	{
		node f=st.top();
		st.pop();
		for(int i=f.x1;i<=f.x2;++i)
		for(int j=f.y1;j<=f.y2;++j)
		{
			if(a[i][j].y==0)//如果已经处理，那么跳过
			a[i][j].y=f.z;
			a[i][j].x++;
		}
	}
	for(int i=1;i<=y;++i)
	{
		int x=read(),y=read();
		if(a[x][y].x==0)
		{
			cout<<'N'<<" ";
			continue;
		}
		else cout<<'Y'<<" ";
		cout<<a[x][y].x<<" "<<a[x][y].y<<endl;
	}
	return 0;
}
```
其实就是把答案倒着做，这样比较方便，这题直接模拟也应该可以，看个人习惯吧

---

## 作者：北北北北 (赞：3)

这题需要注意的点就是轰炸的轮数并不完全等于轰炸的次数

比如，输入的点刚好就是矩形的左上点或右上点，那么轰炸的轮数就是i，可如果输

入的点是被轰炸过，但又不是矩形的左上点或右上点的话，那么轰炸的轮数就是

map[x][y]

我就因为没注意到上面的这种情况，而导致最后一点WA了QWQ

下面附代码:

```c
#include <stdio.h>

int main(void)
{
    int map[101][101] = {0};
    int book[101][101] = {0};
    int i,j,k,n,m,x,y,x1,y1,x2,y2;
    
    scanf("%d %d %d %d", &n,&m,&x,&y);
    for(i = 1; i <= x+y; i++)
    {
        if(i <= x)
        {
            scanf("%d %d %d %d", &x1,&y1,&x2,&y2);
            book[x1][y1] = book[x2][y2] = i; //矩形的左上点和右上点被轰炸
            for(j = x1; j <= x2; j++)
            {
                for(k = y1; k <= y2; k++)
                {
                    map[j][k]++;
                }
            }
        }
        else
        {
            scanf("%d %d", &x1,&y1);
            if(map[x1][y1])
            {
                printf("Y %d %d\n", map[x1][y1],(!book[x1][y1])?(map[x1][y1]):(book[x1][y1]));
                //这里的三目条件表达式处理的就是，若该点被轰炸过，且不是矩形的左上点或右上点的问题
            }
            else
            {
                printf("N\n");
            }
        }
    }
    
    return 0;
}
```


---

## 作者：SetsunaFSeiei (赞：3)

这道题写了用纯模拟，然后我写了一遍...
![](https://cdn.luogu.com.cn/upload/pic/65458.png)
~~素质替身ACT3附体~~


------------

痛定思痛，于是有了新的思路。既然用地毯那道题的方法布星，那么就不打标记了

```cpp
struct Node {
	int x, y, xx, yy;
}node[1000010];	//记录轰炸区域

if (node[j].x <= ax && node[j].y <= ay && node[j].xx >= ax && node[j].yy >= ay)	//判断是否被轰炸
{
	flag = true;
	ans++;
	last = j + 1;
}
```
在这里教大家一个小优化
### register
据我们的dalao说，这个能优化30%
~~也就是说有的题目你暴力枚举一样过~~

具体应用：
```cpp
for (register int i = 0; i < x; ++i)
```


------------

接下来就是完整代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

struct Node {
	int x, y, xx, yy;
}node[1000010];
int map[110][110];
int n, m, x, y, ax, ay;
int ans, last;
bool flag = false;

int main()
{
	cin >> n >> m >> x >> y;
	for (register int i = 0; i < x; ++i)
	{
		cin >> node[i].x >> node[i].y >> node[i].xx >> node[i].yy;
	}
	for (register int i = 0; i < y; ++i)
	{
		ans = last = flag = 0;
		cin >> ax >> ay;
		for (register int j = 0; j < x; ++j)
		{
			if (node[j].x <= ax && node[j].y <= ay && node[j].xx >= ax && node[j].yy >= ay)
			{
				flag = true;
				ans++;
				last = j + 1;
			}
		}
		if (flag)
			printf("Y %d %d\n", ans, last);
		else
			printf("N\n");
	}
	return 0;
}
```


---

## 作者：eegg (赞：3)


	#include<cstdio>
	#include<iostream>
	using namespace std;
	int b[1005]={0},e[1005]={0};
	struct 
	{
		int x1,y1,x2,y2;//来个结构体
	}a[1005];
	int main()
	{
     	int i,n,m,x,y,j,x1,y1,x2,y2,c,d;
		scanf("%d%d%d%d",&n,&m,&x,&y);
		for(i=0;i<x;i++)
			cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;
		for(i=0;i<y;i++)
		{
			cin>>c>>d;
			for(j=0;j<x;j++)
				if(a[j].x1<=c&&a[j].y1<=d&&a[j].x2>=c&&a[j].y2>=d)
				{
					b[i]++;//统计被轰炸的次数
					e[i]=j;//统计最后一次轰炸
				}
		}
		for(i=0;i<y;i++)
			if(b[i]==0)
				cout<<"N"<<endl;
			else
				cout<<"Y "<<b[i]<<" "<<e[i]+1<<endl;
		return 0;
	} 

---

## 作者：tllwtg (赞：3)

##看到没有人用结构体写，那就来一发

讲一下思路：

1.认真思考得出结构体应存的东西为：第几轮是最后一次轰炸，被炸了几次，和是否被炸（可以省略，因为被炸次数为0就没有被炸，这里写全一些）

2.接下来输入数据，在输入的同时把那一整块区域都进行操作

3.最后根据结构体的数据输出

###注意！！！结构体一定要初始化

上AC代码：

```cpp
#include<iostream>
using namespace std;
struct aa{
    int zh;//记录最后一次轰炸
    int jc;//记录次数
    bool sf;//记录是否被轰炸
};
int main(){
    int n,m,x,y;//同题目
    cin>>n>>m>>x>>y;
    struct aa map[n+1][m+1];
    for(int i=1;i<=n;i+=1){//初始化
        for(int j=1;j<=m;j+=1){
            map[i][j].jc=0;
            map[i][j].sf=false;
        }
    }
    int x1,x2,y1,y2;
    for(int i=1;i<=x;i+=1){
        cin>>x1>>y1>>x2>>y2;//输入的同时把那一整块区域都进行操作
        for(int j=x1;j<=x2;j+=1){
            for(int k=y1;k<=y2;k+=1){
                map[j][k].jc+=1;
                map[j][k].zh=i; 
                map[j][k].sf=true;
            } 
        }
    }
    int xx,yy;
    for(int i=1;i<=y;i+=1){
        cin>>xx>>yy;//根据数据输出
        if(map[xx][yy].sf==true){
            cout<<"Y"<<" "<<map[xx][yy].jc<<" "<<map[xx][yy].zh<<endl;
        }
        else{
            cout<<"N"<<endl;
        }
    }
    return 0;//完美结束
}
```

---

## 作者：Talanton_Cerydra (赞：2)

看到大家都是用纯模拟做的，当数据范围大时，这将**很费时间**

## 所以有一种相对便捷的方法

首先我们建立两个不同的struct类型数组，分别存轰炸范围和关键点：

```cpp
struct no1
{
    int x1,x2,y1,y2;
}f[10001];//存轰炸矩形
struct no2
{
    int xx,yy,sum,t; 
    //这里sum表示炸了几次,t表示最后一次炸的轮数
}d[10001];//存目标点
```

读入完数据后对每个关键点作判断，如果x值和y值都在某个轰炸范围的x、y范围内,就表明这个点被炸过

同时记录次数并不断更新最后一次炸的轮数

## 以下是代码：

```cpp
#include <cstdio>
using namespace std;
struct no1
{
    int x1,x2,y1,y2;
}f[10001];//存轰炸矩形
struct no2
{
    int xx,yy,sum,t; 
    //sum表示炸了几次,t表示最后一次炸的轮数
}d[10001];//存目标点
int n,m,x,y;
bool b=false;//记录对于一个点是否被炸过
int main()
{
    scanf("%d%d%d%d",&n,&m,&x,&y);//输入
    for(int i=1;i<=x;i++)
    {
        scanf("%d%d%d%d",&f[i].x1,&f[i].y1,&f[i].x2,&f[i].y2);//输入范围
    }
    for(int i=1;i<=y;i++)
    {
        scanf("%d%d",&d[i].xx,&d[i].yy);//输入目标点坐标
    }
	for(int i=1;i<=y;i++)//分别判断每个点
	{
        b=false;//先记录没有炸过
        for(int j=1;j<=x;j++)//依次判断每个矩形是否炸过目标点
        {
            if(d[i].xx>=f[j].x1&&d[i].xx<=f[j].x2&&d[i].yy>=f[j].y1&&d[i].yy<=f[j].y2)//如果炸过(在范围内)
            {
                b=true;//记录已炸过
                d[i].sum++;//增加炸过的次数
                d[i].t=j;//更新最后一次炸的轮数
            }
        }
        if(b)//如果炸过
        {
            printf("Y %d %d\n",d[i].sum,d[i].t);//输出对应的数据
        }
        else
        {
            printf("N\n");//输出N
        }
    }
    return 0;//完美结束
}
```

[彩蛋](https://www.luogu.com.cn/blog/paiwyz314/)

---

## 作者：Cargoer (赞：2)

因为这学期学的C++，上节课又讲了vector，所以就想着用类和对象数组实现，以下是我的AC代码


------------
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Point{
private:
    int x,y;
public:
    Point(){}
    Point(int _x,int _y):x(_x),y(_y){}
    Point(const Point &rhs){
        x=rhs.x;
        y=rhs.y;
    }
    Point& operator=(const Point &rhs){
        x=rhs.x;
        y=rhs.y;
        return *this;
    }
    ~Point(){}
    int getX()const{return x;}
    int getY()const{return y;}
    void setPoint(int _x,int _y){
        x=_x;
        y=_y;
    }
    bool between(const Point &p1,const Point &p2){
        if(x>=p1.x && x<=p2.x && y>=p1.y && y<=p2.y)
            return true;
        return false;
    }
};

int main(){
    int m,n,x,y;
    cin>>m>>n>>x>>y;
    vector<Point> bomb(2*x);
    for(int i=0;i<2*x;i+=2){
        int x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        bomb[i].setPoint(x1,y1);
        bomb[i+1].setPoint(x2,y2);
    }
    vector<Point> key(y);
    for(int j=0;j<y;j++){
        int x0,y0;
        cin>>x0>>y0;
        key[j].setPoint(x0,y0);
    }
    for(int k=0;k<y;k++){
        int count=0,lastRound;
        for(int w=0;w<x;w++)
            if(key[k].between(bomb[2*w],bomb[2*w+1])){
                count++;
                lastRound=w+1;
            }
        if(count!=0)
            cout<<"Y "<<count<<" "<<lastRound<<endl;
        else cout<<"N"<<endl;
    }
    return 0;
}
```


------------

事后又把bomb封装成一个类，结果是一样的，但好像不是很有必要。

如果有大牛看到了这段代码的不足之处，请指出，不胜感激！

---

## 作者：Goashore (赞：1)

本来想拿这个程序取水轰炸II的，但是发现O(n^3)的时间复杂度完全水不过，所以我就来发这个题的题解了！

———————————————————————————————————————————————

## 题目描述：

在轰炸后，有Y个关键点，指挥官想知道，它们有没有受到过轰炸，如果有，被炸了几次，最后一次是第几轮。

输入格式
第一行，四个整数：n、m、x、y。

以下x行，每行四个整数：x1、y1、x2、y2，表示被轰炸的矩形的左上角坐标和右下角坐标（比如1 3 7 10就表示被轰炸的地方是从(1,3)到(7,10)的矩形）。

再以下y行，每行两个整数，表示这个关键点的坐标。

输出格式：

共y行，

每行第一个字符为Y或N，表示是否被轰炸，若为Y，在一个空格后为两个整数，表示被炸了几次和最后一次是第几轮。

输入输出样例：

输入 

10 10 2 3

1 1 5 5

5 5 10 10

3 2

5 5

7 1
输出 

Y 1 1

Y 2 2

N

1<=N,M<=100

———————————————————————————————————————————————
### 代码：
```cpp
#include<bits/stdc++.h>//万能头不解释
using namespace std;
int n,m,x,y,a[105];
struct hz
{
	int cs,dj,kj;//轰炸次数，最后一次轰炸的，是否被炸过
}b[1000][105];
int main()
{
	int a1,a2,a3,a4;
	cin>>x>>y;
	for(int i=1;i<=x;i++)
	{
		cin>>a1>>a2>>a3>>a4;//边读边做
		for(int i1=a1;i1<=a3;i1++)
		{
			for(int i2=a2;i2<=a4;i2++)
			{
				b[i1][i2].kj=1;b[i1][i2].cs++;b[i1][i2].dj=i;
			}	
		}	
	}
	int a11[100],a22[100];
	for(int i=1;i<=y;i++)
		cin>>a11[i]>>a22[i];
	for(int i=1;i<=y;i++)
	{
		if(b[a11[i]][a22[i]].kj==1)
			cout<<"YES"<<" "<<b[a11[i]][a22[i]].cs<<" "<<b[a11[i]][a22[i]].dj<<endl;
		else
		cout<<"NO"<<endl;
	}
	return 0;
}
 
```


---

## 作者：anotherrainyday (赞：1)

题目中给出了很明显的提示

> #### **说明/提示**
>
> 数据很弱！！！直接模拟！！！！

所以 就是**循环模拟轰炸** 把区域内的计数变量全都+1 然后重新标记最后一次轰炸的轮数

很迷不知道n和m有什么用 反正我也用不到 就没写

因为数据弱啊 所以肯定AC

```cpp
#include <bits/stdc++.h>
using namespace std;

struct point //城市中一个坐标点的数据
{
    int times = 0, lasttime; //被轰炸次数和最后一次被轰炸的轮数
} g[101][101];               //城市的矩阵
int main()
{
    int x, y;                   //轰炸次数和关键点数(与题目中同义)
    string ans = "";            //用来输出的答案字符串
    cin >> x >> x >> x >> y;    //n和m在此程序中用不到 所以不输入(本蒟蒻不会空输入啊QWQ所以就拿x替了)
    for (int i = 0; i < x; i++) //循环x次读取轰炸相关信息 并模拟
    {
        int x1, y1, x2, y2;                //左上角的xy和右下角的xy
        cin >> x1 >> y1 >> x2 >> y2;       //输入
        for (int j = x1; j <= x2; j++)     //循环x2-x1次 遍历轰炸区域内每一行
            for (int k = y1; k <= y2; k++) //循环y2-y1次 遍历当前遍历到的行内每一个点
            {
                g[j][k].times++;      //轰炸次数++
                g[j][k].lasttime = i; //更新最后轰炸轮数
            }
    }
    for (int i = 0; i < y; i++) //循环y次读取关键点信息 并写好输出数据
    {
        int tmpx, tmpy;                                                                                        //关键点xy
        cin >> tmpx >> tmpy;                                                                                   //输入
        if (g[tmpx][tmpy].times != 0)                                                                          //如果本点被轰炸过
            ans += "Y " + to_string(g[tmpx][tmpy].times) + " " + to_string(g[tmpx][tmpy].lasttime + 1) + "\n"; //在答案中添加Y times lasttime 并换行
        else                                                                                                   //如果没有被轰炸过
            ans += "N\n";                                                                                      //在答案中添加N 并换行
    }
    cout << ans; //输出答案
    return 0;    //完结撒花
}
```

又[数据删除]了一篇题解

---

## 作者：黑猫_琉璃 (赞：1)

这道题我的这种解法相信已经有大佬想到并发布了题解了，所以我写这个题解只是为了向大家介绍一种更为高效好用的解题方式而已。不过既然是一道题解，那就还是说一说逻辑吧。

首先这道题数据范围很小，所以可以直接模拟不用考虑时间复杂度超出的情况。在此我想到可以先用scanf得到全部的轰炸范围，然后再一个一个得到目标点的坐标，遍历轰炸范围数组判断是否被轰炸，被炸了几次和最后一次被炸是第几次，代码如下：
```
#include<iostream>
#include<cstdio>
using namespace std;

//目标点对象 
struct targetF{
	int lastba;//lastbang最后一次轰炸
	int cishu;//这个简单易懂，总共被轰炸的次数
	int x,y;//坐标 
}target[10000];

//轰炸的位置对象 
struct bangPF{
	int x1,y1,x2,y2;//就是两个坐标，没什么难的 
}bangP[10000];

//把变量x和i的声明放到这里是因为bang函数中要用到它必须提前声明，这是由C++语言特点决定的(具体可以上网查找，实在不理解也不影响这个题) 
int x,i;

void bang(){
	//把每次轰炸在每一个关键点上重演(感觉好恐怖……) 
	for(int j=0;j<x;j++){
		//如果刚好炸到了当前目标点，就增加这个点被炸的次数，并保存最后一次轰炸是第几次 
		if(target[i].x >= bangP[j].x1 && target[i].x <= bangP[j].x2 && target[i].y >= bangP[j].y1 && target[i].y <= bangP[j].y2){
			target[i].cishu += 1;
			target[i].lastba = j + 1;
		}
	}
}

int n,m,y;
int main(){
	//分别得到这座城市的大小(虽然没什么用)，轰炸的次数和目标点的个数 
	scanf("%d%d%d%d",&n,&m,&x,&y);
	//得到所有轰炸的区域 
	for(i=0;i<x;i++){
		scanf("%d%d%d%d",&bangP[i].x1,&bangP[i].y1,&bangP[i].x2,&bangP[i].y2);
	}
	//得到所有的目标点，并用bang函数处理(函数体在前面) 
	for(i=0;i<y;i++){
		scanf("%d%d",&target[i].x,&target[i].y);
		bang();
	}
	//输出结果 
	for(i=0;i<y;i++){
		if(target[i].cishu == 0){
			printf("N\n");
		}else{
			printf("%c %d %d\n",'Y',target[i].cishu,target[i].lastba);
		}
	}
	return 0;
}
```
相信大家都看懂了。接下来我说一说我真正想说的东西——比较高效的解题方式，这也能让你的代码更具有可读性：

大家可以看到，我的代码中写了一个函数两个结构体。当然我们可以一个函数或结构体也不用，所有代码全部在主函数里面写。但是这样的话会让整段代码看起来逻辑相对比较混乱。

当然这道题看不出来什么，但如果要写一个非常大的模拟的话，那这么做的优势就很容易显现出来了，看到调用函数的表达式直接看前面的函数，这可以让你的代码更具有语义性和可读性，看起来也更加清爽。

最后，其实我只不过是想
### 强烈安利
这种代码方式。如果大家觉得不好也没关系，毕竟这只是我自己的习惯，觉得很好就想跟大家说一说而已。

---

## 作者：SLYZ_0120 (赞：1)

蒟蒻的第四篇题解，来一发简单粗暴的枚举~


这里用的是结构体开二维数组来存放每一个点所受到的轰炸次数以及最新一次的轰炸轮数。

首先由题目得到数据是非常小的，所以我们可以放心的用几重循环嵌套扫过去。每一轮输入轰炸范围之后用循环嵌套将在轰炸范围里的点轰炸次数sum ++，然后更新这个区域内点的最新轰炸轮数 last。最后根据提问进行判断回答就可以了，完全不用担心会爆掉～听说数据非常水～


下面附上代码直接复制大概爆零各位小心咯～（学习dalao的做法）


```cpp
//防伪标识～
#include<bits/stdc++.h>//万能头文件还是非常棒的
using namespace std;
int n,m;
struct js{ //sum用来存放轰炸次数，last存放最新一次受到的轰炸的轮数
    int sum , last;
};
js hz[101][101] = {0}; // 数据规模很小，不需要开太大
int x,y;
int sx, sy,lx,ly;
int main(){
    scanf("%d %d %d",&n,&m,&x,&y); // 输入次序要注意一下
    for(int i = 1;i<=x;i++){
        scanf("%d %d %d %d",&sx,&sy,&lx,&ly); //读入每一次的轰炸范围
        for(int j = sx;j<=lx;j++)
            for(int k = sy;k<=ly;k++) //循环嵌套更新将受到轰炸的点
                if(j >= 1&&j<=n && k >=1 &&k<=m) hz[j][k].sum++,hz[j][k].last = i; //防止j，k过了数组的范围，更新次数，轮数
    }
    for(int i = 1;i<=y;i++){
        scanf("%d %d",&sx,&sy); 
        if(hz[sx][sy].sum == 0)printf("N\n"); //判断所询问的点有没有受到过轰炸
        else printf("Y %d %d\n",hz[sx][sy].sum,hz[sx][sy].last); //输出，完美结束～
    }
    return 0;
}
```

---

## 作者：lych (赞：1)

本题时间复杂度可以优化到0(XY)，由于不是很难，直接给标称：

```delphi
var
  m,n,a,b,x,y,i,j,ans,k:longint;
  x1,y1,x2,y2:array[0..10000] of longint;
begin
  read(m,n,a,b);
  for i:=1 to a do
    readln(x1[i],y1[i],x2[i],y2[i]);//读入轰炸的坐标
  for i:=1 to b do
    begin
      readln(x,y);
      ans:=0;//个数赋为0
      for j:=1 to a do
        if (x1[j]<=x) and (x2[j]>=x) and (y1[j]<=y) and (y2[j]>=y) then
          begin inc(ans); k:=j; end;//在轰炸的范围以内
      if ans=0 then writeln('N') else writeln('Y ',ans,' ',k);//输出加判断
    end;
end.[codep/]

---

## 作者：封禁用户 (赞：1)

此题和轰炸II一模一样，管他城市有多大，照样枚举！！！

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long m,n,x1[2005],x2[2005],y1[2005],y2[2005],x[2005],y[2005],z[2005],s[2005],a,b;
//上面都说过了，洛谷的数据太水了，所以开2005已经够了（实际上2001也行） 
int main()
{
    cin>>a>>b>>m>>n;
    for (int i=1;i<=m;i++) scanf("%I64d%I64d%I64d%I64d",&x1[i],&y1[i],&x2[i],&y2[i]);
    for (int i=1;i<=n;i++) scanf("%I64d%I64d",&x[i],&y[i]);
    //用了scanf的孩子们，千万不要忘了
    //%lld在Windows环境下，直接gameover，%I64d才是最好的！！！ 
    //以下是枚举大法，看好了！！！ 
    for (int i=1;i<=n;i++)//枚举n个司令部的位置 
    {
        for (int j=1;j<=m;j++)//枚举轰炸的矩形的位置 
        if ((x[i]<=x2[j]&&x[i]>=x1[j])&&(y[i]<=y2[j]&&y[i]>=y1[j])) 
        //这里分成两部分来判断：
        //1.x是否属于轰炸范围的宽 
        //2.y是否属于轰炸范围的长 
        {
            z[i]++;//记录次数 
            s[i]=j;//记录位置  
        }
    }
    for (int i=1;i<=n;i++)
    if (z[i]==0) cout<<"NO"<<endl; else cout<<"YES"<<" "<<z[i]<<" "<<s[i]<<endl;
    //如果被轰炸了，输出Y以及次数和位置，如没有，输出N
    return 0;
}
```

---

## 作者：HiroshiRealm (赞：1)


（~~或许是蒟蒻脑回路和楼下大佬不一样~~）

蒟蒻第一次想到的是二维数组模拟整个地图然后每次炸到就加1并且记下这是第几次轰炸。


再仔细想想蒟蒻才绕过来（~~脑回路清奇~~）

## 可以直接比较坐标

#### 如果目标点夹在轰炸x轴坐标和y轴坐标之间就代表轰炸到了如果目标点夹在轰炸x轴坐标和y轴坐标之间就代表轰炸到了，次数加1并记下这是第几次轰炸

最后输出就可以了

上代码

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~分割线~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int a[1000000][4],b,c,d,e,f,g,sum,ans;//坏习惯，喜欢定义没有意义的字母，大佬多多见谅
    int main()
    {
        scanf("%d%d",&f,&g);//不知道地图大小有啥用。。。。。。
        scanf("%d%d",&b,&c);//题目中的x和y
        for(int x=0;x<b;x++)scanf("%d%d%d%d",&a[x][0],&a[x][1],&a[x][2],&a[x][3]);//二维数组分别储存坐标
        for(int x=0;x<c;x++){
            scanf("%d%d",&d,&e);
            for(int y=1;y<=b;y++){
                if(a[y-1][0]<=d&&a[y-1][2]>=d&&a[y-1][1]<=e&&a[y-1][3]>=e){//如果目标夹在轰炸范围内
                //因为我喜欢直接从0开始用，所以减一
                    sum++;//次数++
                    ans=y;//记录最后轰炸波数
                }
            }
            if(ans==0)printf("N\n");//输出
            else printf("Y %d %d\n",sum,ans);
            sum=0;ans=0;//别忘清零
        }
        return 0;
    }
`
```

---

## 作者：青鸟_Blue_Bird (赞：0)

本题思路： 先按照要求输入一群数组，然后通过左上角和右下角坐标判断即可。（这题数字输入也忒多了QAQ）

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,x,y,a[6666],b[6666],c[6666],d[6666];
int a1[6666], b1[6666],ans[6666],tern[6666];
bool jud[6666];

int main(){
	cin >> n >> m  >> x >> y;
	memset(jud , 0 , sizeof(jud));
	for (int i = 1; i <= x; i++){
		cin >> a[i] >> b[i] >> c[i] >> d[i];
	}
	for (int i = 1; i <= y; i++){
		cin >> a1[i] >> b1[i];
	}
   //下面才是核心代码
	for(int i = 1; i <= y; i++)//枚举每一个点
		for(int j = 1; j <= x; j++)//枚举每一次轰炸
			if(a[j] <= a1[i] && b[j] <= b1[i] && c[j] >= a1[i] && d[j] >= b1[i] ){//判断坐标，看这一轮是否被轰炸到
				jud[i] = 1;//证明它已经被炸阵亡了
				ans[i] ++;//统计这一个点得阵亡次数
				tern[i] = j;不断记录当前最新的一轮轰炸

			}
			
	for (int i = 1; i <= y; i++)
		if(jud[i] == 1)//看一下这个点是否被轰炸
			cout <<"Y" << " " << ans[i] << " " << tern[i] <<endl;
			else cout << "N" << endl;//没有阵亡
	return 0;
	
}
```
与众大佬不同，这是本蒟蒻的基本循环列举法，希望初学者可以更好地理解

---

## 作者：StudyingFather (赞：0)

这不就是 NOIP2011 年提高组的铺地毯嘛，不过数据确实弱到了极致（地图只有 $100 \times 100$）。

不过也可以用同样的方法解决，每次输入一个点时，判断一下它是否在矩形内部就好。

```cpp
#include <stdio.h>
int n,m,x,y;
struct node
{
 int x1,y1,x2,y2;
}a[105];
int main()
{
 scanf("%d%d%d%d",&n,&m,&x,&y);
 for(int i=1;i<=x;i++)
  scanf("%d%d%d%d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
 for(int i=1;i<=y;i++)
 {
  int m,n;
  scanf("%d%d",&m,&n);
  int ans=0,last=0;
  for(int j=1;j<=x;j++)
   if(m>=a[j].x1&&m<=a[j].x2&&n>=a[j].y1&&n<=a[j].y2)//是否在矩形内部
   {
   	ans++;
   	last=j;
   }
  if(!ans)printf("N\n");//没有被炸到
  else printf("Y %d %d\n",ans,last);
 }
 return 0;
}
```

---

## 作者：江战神龙骑土 (赞：0)

为什么要O(n^3)？O(n^2)轻松搞定呵呵

我用轰炸II的代码改一下下就过了咩

```cpp
#include <iostream>
using namespace std;
int n,m,x1[10001],y1[10001],x2[10001],y2[10001],x[10001],y[10001],d[2001],p[2001]; //d用来存被炸了多少次，p用来存最后一次是多少轮
int main()
{
    cin>>n>>m>>n>>m; //前面的n和m实在是没用
    for(int i=1;i<=n;i++)
    cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];
    for(int i=1;i<=m;i++)
    cin>>x[i]>>y[i]; //输入
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(x[j]>=x1[i]&&x[j]<=x2[i]&&y[j]>=y1[i]&&y[j]<=y2[i]) //如果正好这个点被炸到了
            d[j]++,p[j]=i; //被炸的次数+1，最后一轮变成本轮
        }
    }
    for(int i=1;i<=m;i++)
    {
        if(d[i]==0){cout<<"N"<<endl;continue;} //如果没有被轰炸，就输出N
        cout<<"Y "<<d[i]<<" "<<p[i]<<endl;  //输出
    }
}
```

---

## 作者：Ufowoqqqo (赞：0)

确实如说明中所说的那样，本题数据非常弱。因此，用O(n^3)的朴素足以轻松AC。

```delphi

var
 n,m,x,y,i,j,k,x1,y1,x2,y2,xx,yy:longint;
 a:array [1..100,1..100,1..2] of longint;
begin
 read(n,m,x,y);
 for i:=1 to x do
 begin
  readln(x1,y1,x2,y2);
  for j:=x1 to x2 do
   for k:=y1 to y2 do
   begin
    inc(a[j,k,1]);
    a[j,k,2]:=i;
   end;
 end;
 for i:=1 to y do
 begin
  readln(xx,yy);
  if a[xx,yy,1]>0 then writeln('Y ',a[xx,yy,1],' ',a[xx,yy,2]) else writeln('N');
 end;
end.

```

---


# 【Mc生存】经验值

## 题目背景

初一福利第2弹。。。


## 题目描述

话说 clearman 在 MC 世界开了个祥艺奶牛场，用岩浆、TNT 等丧心病狂的折磨牛，获取牛肉、牛奶等刷经验。他想知道他到底达到什么层次。

他总共进行了 $n$ 项操作，每次操作要付出 $x$ 生命值（初始生命是 $10$ 点，初一党都知道！并且要先计算付出的生命值，如果小于等于 $0$，则死亡，本次及以下操作都无效。但切记：付出生命值可以是负数，也就是说可以回复 $−x$ 点生命值，但上限只能是 $10$！切记！），每次操作可以获得 $a$ 经验值（不能为负），他最后能达到 $m$ 级 $t$ 经验。

P.S. 关于等级

初始等级为 $0$。每加 $2^m$（$m$ 为当前等级）点经验可升一级。  

1、假设 clearman 一共得到 $15$ 点经验，那么他应该为 $4$ 级（ $15-1-2-4-8=0$）加 $0$ 点经验。    
2、假设 clearman 一共获得 $39$ 点经验，那么他应该为 $5$ 级（ $39-1-2-4-8-16=8$）加 $8$ 点经验。


## 说明/提示

数据很弱，人肉输的，但是很坑。。。

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 20$。

## 样例 #1

### 输入

```
2
5.5 15
4.5 24
```

### 输出

```
4 0```

# 题解

## 作者：ykuouzf (赞：800)

#### 超水超水的一道大水题，数据也没有很坑嘛。

#### 看了几篇题解，感觉写得都太长了呢。

#### 前面都没什么问题，就是后面的判断过程杂七杂八，其实根本不用那么麻烦。

#### 那在这里我也就不多说了，主要就是介绍一个换底公式的做法。

## ******loga(b)=logx(b)/logx(a)******

#### 从样例入手：经验值从1开始递增一直加到升不了为止。

#### 至此得出方程（小学奥数题）：

#### 2(0)+2(1)+2(2)+2(3)......2(n)=2(1)+2(2)+2(3)+2(4)......2(n+1)-2(0)+2(1)+2(2)+2(3)......=2(n+1)-1

#### 由于n从0开始算，所以n+1就是我们要算的等级！！！

#### 假设sum就是经验总值，那么先把减掉的1加上，再用换底公式算出指数，如果是小数就取最小整数，等级就算出来啦。

#### 剩余经验就是经验总值减去2的等级次方就行啦。

### 史上最短代码登场：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,sum;
double blood=10,t;
int main(){
	cin>>n;
	while(n--){
		cin>>t>>x;
		blood=min(blood-t,10.0);
		if(blood<=0) break;
		sum+=x;
	}
	cout<<floor(log(sum+1)/log(2))<<" "<<sum+1-pow(2,floor(log(sum+1)/log(2)));
	return 0;
}
```
#### 敲题解不易，点个赞再走吧！！！

---

## 作者：EarthGiao (赞：78)

# 今生愿入MC，来世做个方块人

题目中都说了，题目很简单，数据很弱就是有点坑

不过不是一般的坑

其实还是很好想的，先设置一个记录经验的计数器js，和一个记录等级的计数器rank(等级的英语~~顺便教英语qwq~~)

（这里js必须是-1因为我没先考虑减一的情况，直接从-1开始加，加上一那就是0,那就是1级，但是加不了还是-1而且等级也是1的情况下就可也特判了）

### 上面括号里的这段话减一看完说明内容看代码的时候看到-1不懂再来，要不然现在看来可能看不懂，要是看懂了那看到后面就没有一种出其不意的感觉了
QWQ

输入n不多说，然后for循环n个输入（或者while循环输入，无所谓的）,每一次输入做该活动需要的血量和该活动可以得到的经验，显示判断已有的血量减去需要的血量是不是大于0，如果小于等于0那就直接结束然后输出现有的等级和经验就ok了

但是这里需要的血量可能是负的，但是血量是有上限的，那就还需要加一个特判的，判断血量是否大于10，如果大于10那就变为10之后才继续后面的操作

下一步得到经验之后，还需要用一个while循环来判断现有的经验能够升多少级，然后rank累加就好了

最坑的地方就是题目中经验减的时候还要减去一个1，比较1是2的0次方嘛，但是我第一次想的代码是没法解决这个问题的

就像其实可以把经验全部记录下来然后到最后在挨个减，计数器默认是0，减去的第一个数是1，能够减去一次计数器就累加一次，那么不减去那就是可以输出0的

# 但是！

~~我就是倔~~

我就是懒

还是在原来的代码上加了一个特判，如果计数器还是初始值的话，那就输出零好了。

完整代码双手奉上

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<stack>
#include<iomanip>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<string>
#include<map>
#include<set>

using namespace std;

int main()
{
	double js = -1,rank = 1;//目前拥有的经验和等级
	double hp = 10;//血量 
	double a,b;
	int n;
	scanf("%d",&n);
	int shengji = 2;//第一次升级需要的经验是2 
	for(int i = 1;i <= n;++ i)
	{
		scanf("%lf%lf",&a,&b);
		hp -= a;//血量减去输入的需要消耗的，负的就变成了家 
		if(hp > 10)//大于最大血量的时候变为10 
			hp = 10;
		if(hp <= 0)//血量低于或者等于下线的时候输出现在的等级结束 
		{
			if(js == -1 && rank == 1)//最特殊的地方，也是最坑人的地方 
			{//当等级为1但是经验却是0的话那就是没得到经验但是一级之前还是需要减去一个1的所以这里就只能特判输出0 0了 
				cout<<"0"<<" "<<"0"<<endl;
				return 0; 
			}	 
			printf("%g %g\n",rank,js);//其他的情况正常输出 
			return 0;
		}
		js += b;
		while(js >= shengji)//结束条件，避免一次操作升级多次的情况 
		{
			js -= shengji;//经验减去 
			rank ++;//等级累加 
			shengji = pow(2,rank);//继续增加升级所需要的经验 
		}
	}
	if(js == -1 && rank == 1)//同上面的特判 
	{
		cout<<0<<" "<<0<<endl;
		return 0;
	} 
	printf("%g %g\n",rank,js);//其他情况非特殊的 
	return 0;
}
```


---

## 作者：hanbowen (赞：66)

本蒟蒻第一篇题解，求过！
这题其实不难，要注意以下几点：  
1.付出的生命值可能是小数  
2.如果小于等于0，本次即以下（注意是本次即以下）操作都无效    
3.付出生命值可以是负数  
4.生命值上限为10

代码如下
```cpp
#include<bits/stdc++.h>  	//万能头文件
using namespace std;
int n,jy,lv;
double a,x,hp=10;
void LV()
{
    int o=1;
    while(jy>=o)			//经验值大于上限
    {
        jy-=o;
        lv++;				//等级加1
        o*=2;				//经验上限乘2
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>x>>a;
        hp-=x;				//血量减少
        if(hp<=0)			//血量为0，结束
        break;
        jy+=a;
        if(hp>10)			//血量超过上限
        hp=10;

    }
    LV();
    cout<<lv<<' '<<jy;		//输出
    return 0;
}		//完美结束！
```

---

## 作者：SLYZ_0120 (赞：12)

蒟蒻的第五篇题解，持续使用简单粗暴的模拟为大家带来题解hhh

首先要分析题目的意思……大概就是一个计算，研究过后发现初始的等级m应该为0，楼下的各位dalao也都提出了这个问题那么就不多说了。由于全部读入后再进行计算比较麻烦，我选择读一个就算一个。当x<=0.0的时候就直接continue往下循环不做任何计算（注意这里的小于等于，一直写 == 坑了 60分！！！），使用dj表示当前升级所需要的经验值，一旦t >= dj,

直接m++,t -= dj ,dj\*=2做一次更新，这里用的是while循环，最后输出就好啦！

需要注意的几个点：

- m的初始值应该为0（这里有毒）

- x 以及每次的消耗生命值应该使用float或者是double

- 每次要先判断x是否小于等于0，如果是直接跳过计算（很重要！）

 
下面附上代码，这次没有坑了各位不要直接复制代码哟~

```cpp
//防伪标识
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n , m = 0,t = 0,a,dj = 1; // 需要初始化的地方要特别注意，特别是m、t要等于0，dj一定不能是0
    double x = 10.0,l;//实数注意不能定义整形
    scanf("%d",&n);
    for(int i = 1;i<=n;i++){
        cin >> l >> a; // 直接cin没有问题
        x -= l;//首先要判断生命有没有低于0
        if(x <= 0.0)continue;
        else{
            if(x > 10)x = 10; // 生命上限注意
            t += a;
            while(t >= dj){ //每一次的升级
                t -= dj;
                dj *= 2;
                m += 1;
            }
        }
    }
    printf("%d %d",m,t); //完美输出
    return 0;
}
```

---

## 作者：Sinwind (赞：9)

# 思路：

1. 读取n项操作，de_HP代表减少的生命值，in_EXP代表增加的经验值；
- 读取经验后，先预测是否会死亡（HP - de_HP <= 0），**若会死亡，直接跳出循环（break）**；
- 若不会死亡，总生命值HP减去减少的生命值de_HP（HP -= de_HP），总经验值EXP加上增加的经验值in_EXP（EXP += in_EXP）；
- **注意这里的总生命值的上限为10**，超过10的（HP > 10），变为10（HP = 10）。

2. 将经验EXP换算成等级LV；
- 注意，虽然题目说的初始等级为1，但**初始等级实际上是从0开始的（int LV = 0）**；
- 当总经验值大于等于每级所需的经验值（从1开始）时（EXP >= EXP_per_LV），可以继续升级；
- 总经验值减去每级所需的经验值（EXP -= EXP_per_LV），等级 + 1（LV++），每级所需的经验值 * 2（EXP_per_LV *= 2）。

3. 输出等级LV和经验EXP。

# 代码

```c
#include <stdio.h>

int main(void)
{
	int n;			//n项操作
	double HP = 10;		//总生命值，初始化为10，上限是10
	int LV = 0;		//等级，初始化为1
	int EXP = 0;		//总经验值，初始化为0
	double de_HP;		//减少的生命值
	int in_EXP;		//增加的经验值
	int EXP_per_LV = 1;	//每次升级所需要的经验值

	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		scanf("%lf %d", &de_HP, &in_EXP);

		//若死亡，跳出循环
		if (HP - de_HP <= 0)
		{
			break;
		}

		HP -= de_HP;
		EXP += in_EXP;

		//上限是10
		if (HP > 10)
		{
			HP = 10;
		}
	}

	while (EXP >= EXP_per_LV)
	{
		EXP -= EXP_per_LV;
		LV++;
		EXP_per_LV *= 2;
	}

	printf("%d %d\n", LV, EXP);

	return 0;
}
```


---

## 作者：Taduro (赞：5)

## 蒟蒻第一次发题解
这道题的坑其实还是蛮多的，要不是为了~~MC~~学习我可能就不写了。
初始等级是0的问题楼下dalao都讲过了。这里主要给大家介绍一下位运算，
因为此题要用到2的乘方，如果为了这个小运算再写一个循环的话本蒟蒻觉得很累。咳咳~~

有人要说了，可以用pow函数，但那时十进制运算，需要把二进制转为十进制运算之后再转为二进制，光听着就很麻烦对吧。位运算，可以办你解决这些问题。

位运算就是针对二进制位的运算，省去了转为十进制的过程，减少了时间浪费，这里要讲的位运算主要有两种，就是将一个数1左移或右移n个二进制位。分别为1>>n(左移)和1<<n（右移）

本题主要用到的是右移，举个例子：

1的二进制是0001，对它进行右移一位运算，也就是1<<1，它的二进制变为0010，转为十进制就是2，相当于乘以2^1,就是在他后面加一个零。

以此类推1<<2就是0100，乘以2^2变成了4。

再来讲一下左移

跟右移相反，左移是删除数的后一位，对其进行除以2^n并向下取整的操作。

再举一个例子：

5的二进制是0101,5>>2就是像右移两位，变成1，因为后两位被删掉了，所以也是向下取整。

丑陋的代码：
```#include<iostream>
using namespace std;
int n,s,o,i,j,k,p;
double f=10,x;
int main(){
	cin>>n;
	for (i=1; i<=n; i++){
		cin>>x>>k;
		if (f-x<=0)  break;  //一定不能在这里输出，因为会有一个x和k都为0的数据
		k+=p;p=0;   //将多出的经验加到下一次经验中
		f-=x;  
        if (f>10) f=10;
        while ((1<<s)<=k){//  2的s次方
        	k-=(1<<s); s++;
		}
		p=k;  //多出的经验
	}
	cout<<s<<' '<<p;
	return 0;
}```
谢谢阅读

---

## 作者：zhouwc (赞：5)

#Pascal

###对于这道题目，我最想说的是：请管理员把题目中的初始等级为1改成0（大家可以计算一下样例看看）。

因为我一开始在做这道题的时候就充满疑惑，与样例不匹配。后来才发现了。

好吧，言归正传。对于这一道题目我想出了一种比较简单判断又新奇的方法。

具体算法（在程序中就不一一讲了）：

我首先在a数组中存储了达到某一个等级所需要的经验值（这样不用多开循环计算）

为什么算到30级呢？因为2的30次方已经很接近maxlongint了，我相信数据中的经验值应该没这么大

接下便读入一个数，如果生命值大于0，那么就把经验值累加起来。

只要在最后判断一下该经验值在哪一个等级的范围里输出就行了。

对了，记得要考虑等级与经验都为0的情况。于是漂亮的一次过了。


下面附上pascal AC 代码 供同学们参考

```cpp
var n,i,t,y:longint;
    p:boolean;
    x,s:real;
    a:array[1..31]of longint;
begin
  readln(n);
  s:=10;
  a[1]:=1;
  for i:=2 to 30 do
  a[i]:=a[i-1]*2;
  for i:=2 to 30 do
  a[i]:=a[i-1]+a[i];
  for i:=1 to n do
  begin
    read(x,y);
    if p=false then begin
    s:=s-x;
    if s>10 then s:=10;
    if s<=0 then p:=true;
    if p=false then
    t:=t+y;
    end;
  end;
  for i:=1 to 30 do
    if (t>=a[i]) and (t<a[i+1]) then
    begin
      write(i,' ',t-a[i]);
      break;
    end;
  if t=0 then write(0,' ',0);
end.
```
如有错误，还请指出


---

## 作者：树下 (赞：4)

给蒟蒻一次发题解的机会

```cpp
#include<bits/stdc++.h>//万能头文件，好用
using namespace std;//不要忘了这一句
int main()
{
    int n;//n次操作
    scanf("%d",&n);//输入
    double x=10,a,b;//不用数组
    int sum=0;//经验值
    for(int i=1;i<=n;i++)    
    {
        scanf("%lf%lf",&a,&b);
        x-=a;
        if(x>10)    x=10;//不要爆掉
        if(x<=0)    break;//生命值过低，退出游戏
        else        sum+=b;//生命值累加
    }
    int k=0;
    while(sum>=pow(2,k))//判断级别数
    {
        sum-=pow(2,k);
        k++;
    }
    printf("%d ",k);
    printf("%d",sum);//输出，over
}
```

---

## 作者：飞奔的蜗牛 (赞：4)

C++程序闪亮登场！！！

当当当！！！

这道题，好吧……

有点模拟的味道，简单模拟

下面板程序

```cpp
#include <cstdio>     //头文件（不用说）
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
int jy,i,n,zzjy,k=1,dj;     //jy是输入的经验，zzjy是最终的经验，dj是输出的等级，k是一个计算2的次方的一个东东
double xl,zzxl=10;     //这里一定要用double，之前用float第五个点错了，原因是精度不够高……
int main()
{
    cin>>n;     //输入n
    for (i=1;i<=n;i++) {
        cin>>xl; cin>>jy;     //输入第i次的血量和经验
        zzxl-=xl;     //最终的血量减去这次的血量
        if (zzxl>10) zzxl=10;     //题目里说了，血量上限是10，所以大于10就让最终血量等于10
        if (zzxl<=0) break;     //如果血量没了就退出循环
        zzjy+=jy;     //最终的经验加上这次的经验
    }
    while (1) {
        zzjy-=k; dj++;     //每次让经验减去k，等级增加一级
        if (zzjy<0) {     //如果最终经验被减完了
            dj--;     //等级下降一级
            zzjy+=k;     //经验回到上一次大于0的地方
            break;     //退出循环
        }
        k*=2;     //k就像个累成器，每次乘以2
    }
    cout<<dj<<" "<<zzjy;     //输出等级和剩下的经验
}
```

---

## 作者：百因必有AC (赞：3)

### 楼上公式看不懂,来一篇纯模拟题解

这道题目不算很坑,只需要注意这几点(MC玩家请跳过):

- 初始等级为0级,即m初始化为0
- p必须初始化为1,不然会陷入死循环(~~本蒟蒻就被这一点坑过~~)
- 由于x给的是实数,所以初始生命值必须为double类型(float应该也可以)
- 经验值达到一定数量一定要升级
- 这题一定要先判断生命值,不然会死的很惨(ﾟДﾟ*)ﾉ(ﾟДﾟ*)ﾉ

#### 分析一下样例
输入:

	2
	5.5 15
	4.5 24
    
输出:
	
	4 0
    
2表示两次操作

1. 	第一次操作消耗5.5生命,获得15经验

	先减去5.5生命,刚开始升级所需经验值为1,升一级,减1经验,		升级所需经验变为1\*2=2

	级别:1	经验:14 	生命:4.5

	再升一级,减2经验,升级所需经验变为2\*2=4

	级别:2	经验:12	生命4.5

	再升一级,减4经验,升级所需经验变为4\*2=8

	级别:3	经验:8	生命4.5
	
	再升一级,减8经验,升级所需经验变为8\*2=16
	
   	级别:4		经验:0	生命4.5

2. 第二次操作消耗4.5生命,获得24经验
## 有同学就要问了:那为什么答案是4啊?

那你是掉坑里了

~~(投去鄙视的目光)~~

为什么我强调要先判断生命值?

因为经过第一次操作后,clearman还剩4.5生命

第二次操作消耗4.5生命,clearman还剩0生命,
## 所以他还没有收经验就凉凉了
### ┏┛墓┗┓...(((m -__-)m
### |||ヽ(*￣▽￣*)ノミ|Ю 
### ~~好悲催啊~~

我BB那么多就是为了让同学们理解这道题的做法,不要掉坑!

既然你们都看到怎么做了,程序我就不发了

(皮一下)

以下是AC代码:
```cpp
//前面都解释过了,这里就不加解释了
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m=0,t=0,a,d=0;
	double x,s=10.0;
  	//n表示操作次数,m表示等级,t表示经验值
  	//a表示每次操作clearman会得到多少经验
  	//d表示升一级所需要的经验值
  	//x表示clearman每次操作需要消耗多少生命
  	//s表示总生命值
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>x>>a;
		s-=x;
		if(s<=0.00)break;//如果clearman凉了,就跳出
//这里如果用continue就会出现死而复生(就是诈尸)的情况
		else{
			if(s>10)s=10.0;//注意生命别多了
			t+=a;
			while(t>=d){
				t-=d;
  				d*=2;//升级条件*2
				m+=1;//升级啦!
			}
		}
	}
	cout<<m<<" "<<t;//输出
  	return 0;//完美结束程序
   //最后说一下,clearman,你咋这么爱作呢?
   //想要经验开指令不就得了
}
```
最后,求管理员大佬通过

---

## 作者：tllwtg (赞：3)

##说实话，这题测试数据真的好坑啊！！(╬▔皿▔)

##我先后提交了好几次都是80分。

##最后才想起一个东西——极品数据（如n等于0或者a等于0这类数据）

##针对极品数据的方法详见代码

#先讲一下思路：

###1.先开两个数组，存储数据

###2.根据生命值求出能得到的经验

###3.求出等级和经验

###具体看代码中注释

#上代码：


```cpp
#include<iostream>
#include<cmath>//pow函数的头文件
using namespace std;
int main(){
    int n;//同题目
    cin>>n;
    double jsm[n];//存储每次要消耗或增加的生命值
    double sm=10.0; //初始化生命值为10
    double jy=0.0;//初始化经验为0
    double a[n];
//你是不是想问为什么用double？因为样例就是浮点型（小数）
    int sum=1;//初始化等级为1
    for(int i=0;i<n;i+=1){//读入数据
        cin>>jsm[i];
        cin>>a[i];
    }
    for(int i=0;i<n;i+=1){//计算在死亡前能得到的经验
        if(sm-jsm[i]<=0){//如果死亡，就退出循环
            break;
        }
        else{
            sm=sm-jsm[i];//减去或加上这次操作所消耗的生命
            if(sm>10){//如果生命大于10，就把生命变回10
                sm=10.0;
            }
            jy+=a[i];//累加经验
        }
    }
    jy-=1;//因为一级要消耗2的0次方（1），所以就减2的0次方（1）。
    for(int i=1;;i+=1){
        if(jy-pow(2.0,i)>=0){//如果剩余的经验能升级（pow(2.0,i)表示2的i次方）
            sum+=1;//等级加1
            jy-=pow(2.0,i);//减去升级要消耗的经验
        }
        else{
            break;
        }
    }
    if(sum==1&&jy==-1){//这就是针对极品数据的方法
//因为极品数据能绕过上面的各种循环，所以他就等于他的初始值
//sum的初始值是1，jy因为被减了2的0次方（1），所以是-1。
//遇到极品数据直接输出“0 0”。
        cout<<"0"<<" "<<"0";
    }
else{
    cout<<sum<<" "<<jy;
}
    return 0;//完美结束
}
```

---

## 作者：1jia1 (赞：2)

感觉好像办法都差不多……还有楼下的楼下的题解怎么看起来好逗比……这TM还是个题解吗……明明是心灵鸡肉蘑菇汤啊……

核心思路：模拟，先读入第一组，生命值先扣掉，然后判断，如果大于10就变成10（请问杀牛怎么会回血？），如果小于等于0就退出循环（请问杀牛怎么会扣血？）。然后经验值扣去1，扣去2，扣去4……每扣一次等级就+1（请问1级升2级只要2经验值吗？）扣到扣不了就输出。（看完以后扣字不会写了）

```cpp
-#include <iostream> -
-using namespace std;-
-double a,s=10;---由于忘记了那个什么floor的，就只能用浮点数了。（什么跟什么啊）
-int n,m=0,t=0,o=1,b;-
-int main()-
-{-
-    cin>>n;-
-    for(int i=1;i<=n;i++)-
-    {-
-        cin>>a>>b;-
-        s-=a;-
-        if(s>10)s=10;---生命值大于10就变成10
-        if(s<=0)break;---死了
-        t+=b;---加经验
-    }-
-    while(t-o>=0)t-=o,m++,o*=2;---扣经验加等级
-    cout<<m<<' '<<t;---输出
-    return 0;-
-}-
正宗防抄代码，你值得丢弃！
```

---

## 作者：TRZ_2007 (赞：2)

这是本蒟蒻发的第$n$篇$P$开头的题解了~~（虽然之前的都没过）~~  
发现没有人像本蒟蒻这样用结构体的(逃~~   
首先定义一个结构体，比如说$cow$吧，里面要存如两个变量，一个是$double$类型，一个是$int$类型（因为生命值是小数，经验值是整数）。由于怕被数据坑，于是先特判$n==0$的情况（输出两个$0$）接下来再处理数据，如果血量$==0$那么就$break$掉，如果血量$>=10$，那么血量就$=10$,接下来再用总经验值加上本轮所获得的经验值，最后用$while$循环判断总经验值是否$>=$这一级需要的经验值，如果大于，等级$+1$，总经验值减去这一等级所需要的经验值，再输出就$OK$了。  
好了，看不懂的人就看代码吧：
```
#include <stdio.h>
#include <math.h>
struct cow//定义一个结构体cow
{
	double x;//注意所需的血量是小数
	int h;//获得的经验值是整数
};//别忘了加上分号
int main()
{
	int n,i,m=0,mc=0;//都要初始化成0
	double h=10.0;//血量最初是10
	scanf("%d",&n);//输入n
	if(n<=0)//特判n>=0的情况
	{
		printf("0 0");
		return 0;
	}
	cow a[n];
	for(i=0;i<n;i++)
		scanf("%lf %d",&a[i].x,&a[i].h);//又是读入
	for(i=0;i<n;i++)//处理数据
	{
		h-=a[i].x;//总血量减去本轮所需要的血量
		if(h>=10.0) h=10.0;//总血量大于10了，就把总血量变成10
		if(h<=0) break;//血量小于10了，死亡，本轮不算
		mc+=a[i].h;//总的经验加上本轮所获得的经验
	}
	while(mc>=pow(2,m))//判断等级
	{
		mc-=pow(2,m);//总经验减去升级所需的经验
		m++;//等级自加
	}
	printf("%d %d",m,mc);//输出
}
```

---

## 作者：钟情暴力 (赞：2)

水题没什么好说的，不过的注意初值是否赋值正确，等级从0开始（玩过MC都知道）。建议先累计最后再计算经验，过程写成函数清爽多了。

蒟蒻代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double hp;
double Hp(double Lose)//用于计算新hp值 
{
    double t;
    t=hp-Lose;
    if(t>10) t=10;
    return t;
}
int Power(int a)//用于计算2的幂
{
    int ret=1;
    for(register int i=1;i<=a;++i)
        ret*=2;
    return ret;
} 
int main()
{
    int n,Level,expsum,Exp;
    double x;
    cin>>n;
    hp=10;
    expsum=0;//初始空有一身热血但是没有经验 
    for(int I=1;I<=n;++I)
    {
        cin>>x;
        hp=Hp(x);
        if(hp<=0) break;//死了就别玩了 
        cin>>Exp;
        expsum+=Exp;//没死就累计经验 
    }
    for(Level=0;;++Level)//等级从0开始（坑） 
        if(expsum>=Power(Level)) expsum-=Power(Level);
        else break;//可以就升级，不行就跳出 
    cout<<Level<<" "<<expsum<<endl;
    return 0;
}
```

---

## 作者：百里亦守约_test (赞：2)

没有一个P的题解，让P党怎么生活，我就发一个P的题解吧！

思路：先用一个循环读入

每次不断地扣血

每次不断的加经验

如果（爆血管）就变成血量上限（像是在打三国杀）

如果你一不小心被炸死了或被烧死了就开始统计经验。

一开始是一，先减后乘

如果刚好就输出，否则特判减一

一切都结束了（exit）

题解不注释：

```cpp
var o,qwe,s,x:real;
    i,n,u,io:longint;
begin
   readln(n);
   o:=10;
   for i:=1 to n do
   begin
     readln(s,x);
     o:=o-s;
     qwe:=qwe+x;
     if(o>10) then o:=10;
     if(o<=0) then
     begin
       io:=1;
       qwe:=qwe-x;
       repeat
         qwe:=qwe-io;
         io:=io*2;
         inc(u);
       until qwe<=0;
       if(qwe<0) then write(u-1,' ',qwe+io div 2:0:0) else write(u,' ',qwe:0:0);    //因为手贱用了小数，应该是生命的时候用。
       exit;
     end;
   end;
  io:=1;
       repeat
         qwe:=qwe-io;
         io:=io*2;
         inc(u);
       until qwe<=0;
       if(qwe<0) then write(u-1,' ',qwe+io div 2:0:0) else write(u,' ',qwe:0:0);    //因为手贱用了小数，应该是生命的时候用。
       exit;
end.

```

---

## 作者：ACE_ZY (赞：1)

em~~~~ Pascal党的题解为什么这么少

题目意思是

**一个人在我的世界里杀牛获得经验 可是他的方法却十分奇怪 有时候会让自己受伤 但有时候自己也会加血 他只有十滴血 当血量用完或者牛杀完 他将不再升级 每一只牛有自己的经验 求最后他的等级和剩余的经验**

可是:那里升级的时候的经验十分独特,有着异常奇怪的规律 初始值是1点经验升级 每次上升一级 升级经验则在原来的基础乘2 如：升级到4级是这样的 1 2 4 8一共15点经验

**我给大家4个代码 分别是我经历过的20分代码 60分代码 80分代码和100分代码 解释我写在100分代码上 可能对于一些人有帮助 看看哪里错了**

**100分**代码如下(代码中有些变量是由名字来的 如:目前的经验值rwjy=人物经验 可能有些怪(体谅一下)):
```pascal
var
  n,jy,rwjy,sjjy,s,k:int64;
  i:integer;
  zxl,xl:real;
begin
  readln(n);//n次操作
  zxl:=10;//总血量
  for i:=1 to n do//进行n次操作
  begin
    readln(xl,jy);//用这种方法杀牛会减掉的血量(xl) 和 获得的经验(jy)
    if xl<=0 then//判断是扣除血量还是加血 如果xl小于等于0 算作加血
    begin
      if zxl-xl>=10 then zxl:=10//如果是加血则判断加的血量有没有和目前血量加起来大于等于10(大家应该都知道 史蒂夫最多10滴血) 如果是 史蒂夫的血量就是10点血      （大家可能认为既然是加 为什么代码中是减呢 因为题目写了 如果输入的是负数 就是加血 而正数减负数就等于整数加那个负数的绝对值(就是去掉负号)）
                 else zxl:=zxl-xl;否则 直接加上血
      rwjy:=rwjy+jy;//if语句 只能做一个 所以要加上获得的经验 不然就错了
    end
             else
        begin
          if zxl-xl<=0 then begin break;end//血量小于等于0 退了
                     else begin zxl:=zxl-xl;rwjy:=rwjy+jy;end;//否则 减去应该减的血和经验   rwjy=人物经验
        end;
  end;
  sjjy:=1;//刚开始 升级的经验值为1  sjjy=升级经验
  for i:=1 to 50 do//循环 人家说从零开始 我偏偏从1
  begin
    if rwjy>=sjjy then begin rwjy:=rwjy-sjjy;k:=k+1;end;//判断人物当前的经验值能不能升级  k是累加等级用的
    if rwjy<sjjy*2 then break//判断下一级能否升级 不能的话 我退
                   else sjjy:=sjjy*2;//能的话 升级经验要*2
  end;
  writeln(k,' ',rwjy);//输出等级 剩余经验值
end.
```

接下来的代码可以看 可以不看 都是一些没拿满分的代码

20分代码:
```pascal
var
  n,jy,rwjy,i,sjjy,s,k:longint;
  zxl,xl:real;
begin
  readln(n);
  zxl:=10;
  for i:=1 to n do
  begin
    readln(xl,jy);
    if zxl-xl<=0 then begin break;end
                 else begin zxl:=zxl-xl;rwjy:=rwjy+jy;end;
  end;
  sjjy:=1;
  for i:=1 to 50 do
  begin
    rwjy:=rwjy-sjjy;
    k:=k+1;
    if rwjy<sjjy*2 then break
                   else sjjy:=sjjy*2;
  end;
  writeln(k,' ',rwjy);
end.
```

60分代码:
```pascal
var
  n,jy,rwjy,sjjy,s,k:int64;
  i:integer;
  zxl,xl:real;
begin
  readln(n);
  zxl:=10;
  for i:=1 to n do
  begin
    readln(xl,jy);
    if xl<=0 then begin rwjy:=rwjy+jy;end
             else
        begin
          if zxl-xl<=0  then begin break;end
                     else begin zxl:=zxl-xl;rwjy:=rwjy+jy;end;
        end;
  end;
  sjjy:=1;
  for i:=1 to 50 do
  begin
    rwjy:=rwjy-sjjy;
    k:=k+1;
    if rwjy<sjjy*2 then break
                   else sjjy:=sjjy*2;
  end;
  writeln(k,' ',rwjy);
end.
```

80分代码:
```pascal
var
  n,jy,rwjy,sjjy,s,k:int64;
  i:integer;
  zxl,xl:real;
begin
  readln(n);
  zxl:=10;
  for i:=1 to n do
  begin
    readln(xl,jy);
    if xl<=0 then begin rwjy:=rwjy+jy;end
             else
        begin
          if zxl-xl<=0  then begin break;end
                     else begin zxl:=zxl-xl;rwjy:=rwjy+jy;end;
        end;
  end;
  sjjy:=1;
  for i:=1 to 50 do
  begin
    if rwjy>=sjjy then begin rwjy:=rwjy-sjjy;k:=k+1;end;
    if rwjy<sjjy*2 then break
                   else sjjy:=sjjy*2;
  end;
  writeln(k,' ',rwjy);
end.
```

望通过 谢谢了

---

## 作者：Ikari_Shinji (赞：1)

本蒟蒻的第一篇题解

很多发C++的

那我也发C++~~(本蒟蒻就会C++啊！)~~

代码：

```c
#include<bits/stdc++.h>	//万能头
using namespace std;
double l=10,s;	//一定要用double,float的话,测试点5会WA(我也不知道为啥)
int a,n,x=1,t=0,j=0;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s>>a;
        l-=s;	//先减再判断
        if(l>0)		//大于0再执行
            {
                if(l>10)
                	l=10;
                j+=a;
                while(j>=x)		//判断是否能升级
                {
                    t++;
                    j-=x;
                    x*=2;
                }
            }
    }
    cout<<t<<" "<<j;	//输出
    return 0;
}
```

代码可能有点缺陷，请谅解。

---

## 作者：maozi (赞：1)

这道题也不是太难，之前计经验和等级方式错了，一直有三个点错，后来换成后计数然后相减就ac了



```cpp
#include<iostream>
using namespace std;
int main()
{
    int grade=0;//最后的等级
    double n,bloodsum=10,experencesum=0;//存放人的血量 存放总经验
    double x;//x 操作消耗的血量
    int  y;// y获得的经验值
    cin>>n;//操作次数
    for(int i=0;i<n;i++)
    {
        cin>>x>>y;
        bloodsum-=x;//血量的变化
        if(bloodsum>10)
            bloodsum=10;
        if(bloodsum<=0)
            break;
        experencesum+=y;//获得经验
    }
    for(int j=0,t=2;;j++)// t是等级为1的时候所需要的经验值
    {
        if(j==0)
            t=1;
        else
            t*=2;  //依次得到每级的经验值
        experencesum-=t;
        grade++;
        if(experencesum<0)  //先判断与后判断 结果都不同
        {
            grade--;
            experencesum+=t;
            break;
        }
    }
    cout<<grade<<" "<<experencesum<<endl;
    return 0;
}
```

---

## 作者：critnos (赞：1)

这题很水，就不讲方法了，先静静地看代码吧

```cpp
//模拟
#include<bits/stdc++.h>
using namespace std;
int main()
{
	double n,li=10,x,i,level=0,j=0,y;
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>x>>y;
		li-=x;
		if(li<=0) break;
		if(li>10) li=10;
		j+=y;
	}
	while(1)
	{
		if(j-pow(2,level)<0) break;
		j-=pow(2,level);
		level++;
	}
	cout<<level<<' '<<j;
}
```
```cpp
//二分
#include<bits/stdc++.h>
using namespace std;
int main()
{
	double n,li=10,x,i,j=0,y,p;
	int l,r;
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>x>>y;
		li-=x;
		if(li<=0) break;
		if(li>10) li=10;
		j+=y;
	}
	if(j==0) 
	{
		cout<<0<<' '<<0;
		return 0;
	}
	for(l=0,r=j;l<r;)
	{
		p=(l+r)/2;
		if(pow(2,p)-1>j) r=p;
		else l=ceil((l+r)/2.0);
	}
	cout<<l-1<<' '<<j-pow(2,l-1)+1;
}
```

其实二分和模拟的时间复杂度都是O(log2n)，而且二分在经验值等于0时会有错，必须加特判（不信你把if(j==0)那个判断删了试试），还烧脑细胞，所以我还是更喜欢模拟一些。可见某些题是无法用二分优化的。


---

## 作者：fzj2007 (赞：0)

# **第四篇**

~~这个题，没神马可说的，上代码~~

这个题只要注意4点就可以了：

生命值不能超过10

付出的生命值可能是小数或负数

注意m和x要声明double或float 本蒟蒻就死在这里啦！

判断生命是否小于0，这很重要！

```
#include<bits/stdc++.h>//万能头文件
using namespace std;
//  组数 
int n,p=0,q,f=0,y;
double x,m=10;
int main(){
//这个没什么可说的。。
	scanf("%d",&n);
	while(n--){
		scanf(" %lf",&x);
		scanf(" %d",&y);
		m-=x;
        //大于10的判断
		if(m>10) m=10;
		if(f!=true&&m<=0) f=true;
		if(!f){
			q+=y;
			while(q>=pow(2,p)){
            //pow大家都见过吧？再说一遍：pow（数，次方）
				q-=pow(2,p);
				p++;
			}
		}
	}
   // 输出~
	printf("%d %d\n",p,q);
	return 0;
}
```




---

## 作者：Atmizz (赞：0)

#### 总体上说的话，这个题其实并不难，就是一个模拟。
	但是也有坑点,我来说一下我发现的坑点：
-	生命值一开始的时候是10（满血的！！）。
-	生命值消耗可能是小数，用double类型来定义。
-	生命值消耗如果是正的，那么减去；反之则加。
-	如果当前生命值小于零，那么他就不会得到经验。

好，这是我暂且总结的注意点，下面上完整代码。
### code：
```cpp

#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

double HP=10,a;						//一开始是满血的 
int n,b,ex=0,ans=0;

int main()
{
	scanf("%d",&n);//操作数目 
	for(int i=1;i<=n;i++) {
		scanf("%lf%d",&a,&b);//输入消耗的生命值和获得的经验 
		HP-=a;//减血 
		if(HP<=0)//他死了，就没有经验 
			break;
		if(HP>10)//生命值的最大限制为 10，所以不能超过 10 
			HP=10;
		ex+=b;//没有死的话，就加上所得的经验 
	}
	int t=1;
	while(1) {//进入循环，一直循环到经验不够再升一级 
		if(ex<t)
			break;
		ex-=t;//经验总值减去这一级需要减去的经验值 
		ans++;
		t*=2;//升级门槛升高 
	}
	printf("%d %d",ans,ex);//输出等级和剩下的经验 
	return 0;
}```

---

## 作者：buickboy (赞：0)

**争做最简洁最好懂题解！全部代码18行。
**

总体思路是先攒经验值，再升级，分成两步操作，容易跟踪变量变化，便于查错。

注意有3个坑：

1.耗用生命值x有负数，这会导致生命值突破上限，因此要加特判；

2.生命值耗尽后，当前及之后所有操作无效，因此要退出循环。可以直接在输入循环中中断。

3.既然有极品数据，就要检查端点值、0、1、-1。

```cpp
#include <cstdio>
int n, t, i, rk, pt;
int main()
{
    double x, v = 10;
    scanf("%d", &n);
    while (n--)
    {
        scanf("%lf%d", &x, &t);//生命值为浮点数
        if (v - x > 0) v -= x, pt += t;//生命值内可以操作
        else break;//不能省
        if (v > 10) v = 10;//注意生命值有上限!
    }
    for (i = 1; pt - i >= 0; i *= 2)//能减就连续减
        rk++, pt -= i;//计算等级和经验
    printf("%d %d\n", rk, pt);
    return 0;
}
```


---

## 作者：dbxxx (赞：0)


题目说此题很坑，但我一次`AC`~~哈哈，其实只要认真就`ok`.

说一下大家比较容易犯的坑吧：

1.变量要开`double`

2.生命值到`10`就不能再涨了

3.生命值为`0`也是死的

**4.等级的最初值是`0`**

关于等级的最初值为什么是`0`，你想，如果经验值为`0`会发生什么？

等级应该是`0`.

而`n=0`或所有的`a`都等于`0`，不是没有可能。

说完了坑，接下来就是代码了

```cpp
#include <bits/stdc++.h>//万能头，据说空间2MB??
/*如果你不想像上面那样写，这样写也无妨：
#include <iostream>
#include <cmath>
*/
using namespace std;//命名空间，别忘了
double n,x,a,life=10,expe;
//n,x,a都是按照题目要求命名的
//life是当前生命值，expe是当前经验值
//注意要开double，第一个坑
int main()
{
    cin>>n;//输入
    while(n--)
    {
        cin>>x>>a;//输入*2
        life-=x;//生命值的改变
        if(life>10) life=10;//上不封顶，第二个坑
        if(life<=0) //cout<<"Game over!!!!!"<<endl;
            break;//注意生命值为0的情况，第三个坑
        expe+=a;
    }
    /*接下来的n为等级，a为经验值
      反正此处就不用n和a了，为了节省空间，我们可以一变量多用。这是个小技巧，但注意别弄混了
      */
    for(n=0;expe>=pow(2,n+1)-1;n++)//从0开始，第四个坑
        a=expe-pow(2,n+1)+1;//注意是+1啦,因为是减法
    cout<<n<<' '<<a<<endl;//输出
    return 0;//很多同学UKE据说都是这里的锅
}
```
天哪，多么丑陋的代码啊，最后来一个无注释版本吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
double n,x,a,life=10,expe;
int main()
{
    cin>>n;
    while(n--)
    {
        cin>>x>>a;
        life-=x;
        if(life>10) life=10;
        if(life<=0) break;
        expe+=a;
    }
    for(n=0;expe>=pow(2,n+1)-1;n++)
        a=expe-pow(2,n+1)+1;
    cout<<n<<' '<<a<<endl;
    return 0;
}
```
~~求管理员给过！~~

---

## 作者：CREED (赞：0)

- Pascal题解

- 闲的蛋疼，用函数拼了一篇题解出来 （强行像C一样）

- 如下

var explimit:array[0..33] of longint;  // 用来存储2^(0~32)次方的数组 （至于第0个有什么用，就看自己理解了？）

{第0个用来凑数，经验=0毕竟很尴尬}

function ans(n:longint):string;  //用来求当前经验的级数及多余出的经验

```cpp
var i:longint; grade,overage:string;
begin
  if n<=0 then exit('0 0');  //防止特殊情况，貌似第0个数组元素很尴尬
  i:=1;
  while n>=explimit[i] do inc(i); //找到大于经验的那一级，即仍未达到的下一级
  str(i-2,grade); //将目前级数存入grade(等级)中
  str(n-explimit[i-1]+1,overage); //将总经验减去下一级以前的所需总经验（x^1+x^2+x^3+……+x^n=x^(n+1)-1）存入overage（剩余）里
  ans:=grade+' '+overage; //将两字符串返回答案
end;
function calculate(n:longint):string;
var i,y:longint; life:real=10; x:real; exp:longint=0;
begin
  if n<=0 then exit('0 0');//同排除特殊情况
  for i:=1 to n do
    begin
      readln(x,y); //读入所需生命及获得的经验
      life:=life-x; //消耗后生命
      if life<=0 then begin calculate:=ans(exp); exit; end; //若死亡则直接计算等级，返回值
      exp:=exp+y; //获得经验值
      if life>10 then life:=10; //生命上限为10
    end;
  calculate:=ans(exp); //返回最终获得经验
end;
procedure calculatelimit; //计算2^(0~32)
var i:longint;
begin
  explimit[0]:=0; explimit[1]:=1;
  for i:=2 to 33 do
    explimit[i]:=explimit[i-1]*2;
end;
procedure main; //看着这里，我非常舒服，极像C++（貌似闲的蛋疼）
var n:longint;
begin
  readln(n);  
  calculatelimit;
  writeln(calculate(n));
end;
begin
  main;
end.
```

---

## 作者：_zyf (赞：0)

{本题作者我花了很久很久，都没有做出来，不过楼下的说明和讨论里的内容里，都提到了初始等级是为0的，不是为1.我想应该是写题目的作者手抖了一下按错了吧阿，所以我也没有追究（也不敢追究），真诚的希望大家看到这一段话以后，不要来抄题解，先自己试一试，实在不会再来抄题解}

    
```cpp
var
  n,i:longint;//变量不多说，下面可以看到
  x,t,s:longint;
  k,max:real;
begin
  readln(n);
  max:=10;//初始生命值（要用实型）
  s:=0;
  for i:=1 to n do//不断输入直到生命值用完或者样例输入完
    begin
      readln(k,t);//输入消耗的生命值和获得的经验值
      max:=max-k;//生命值相减
      if max>10 then max:=10;//判断生命值有没有大于上限
      if max<=0 then break//如果生命值用完，直接退出循环，结束输入
                else s:=s+t;//如果没完，将经验值加上
    end;
  x:=1;
  for i:=0 to 100 do//此处注意，应该是0 to 而不是 1 to，第二个数尽量大一些，反正到最后是要break的
    begin
      if s<x then break;//如果剩余的经验值不够再升一级，那么退出循环
      s:=s-x;//升级后还剩s点经验值
      x:=x*2;//每次升级需要的经验值翻倍
    end;
  write(i,' ',s);//输出级数（i）和剩余的经验值（s）
end.//结束程序
```

---


# 开灯

## 题目背景

该题的题目是不是感到很眼熟呢?

事实上，如果你懂的方法，该题的代码简直不能再短。

但是如果你不懂得呢？那。。。（自己去想）

## 题目描述

首先所有的灯都是关的（注意是关！），编号为 $1$ 的人走过来，把是 $1$ 的倍数的灯全部打开，编号为 $2$ 的人把是 $2$ 的倍数的灯全部关上，编号为 $3$ 的人又把是 $3$ 的倍数的灯开的关上，关的开起来……直到第 $N$ 个人为止。

给定 $N$，求 $N$ 轮之后，还有哪几盏是开着的。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le N \le 2^{40}$。

**【其他说明】**

数学题！

## 样例 #1

### 输入

```
5```

### 输出

```
1 4```

# 题解

## 作者：BlueArc (赞：265)

看了看别人的题解，都是枚举小于n的完全平方数输出，代码极为简单，因此本人不再给出代码。

下证明为什么是完全平方数：

首先，你要知道，对于每一个数n，除非它是完全平方数，否则它一定有偶数个因子。

因为如果i是n的因子，那么n/i也一定是n的因子。例如当n=20时，i=4是20的因子，那么n/i=5也是20的因子

这样，n的因子都是成对出现的，所以n有偶数个因子

但是，有一种特殊情况，即n/i=i。例如4/2=2。由于i和n/i是同一个数，算因子只能是一个，这时n的因子就是奇数个

把n/i=i变形，得n=i\*i，即n是完全平方数，所以只有完全平方数有奇数个因子

对于本题，由于灯只有两种状态(开或关,可类比于奇数和偶数),而初始状态是关的

而每个灯泡如果能被人的编号整除，状态就会变化。

把整个过程看成一个整体，也就是只有这一盏灯的因数的编号的人，才会按开关

由于灯的开关按偶数次状态不变，还是关（起始是关），所以，灯的开关只有按奇数次，才会开。

发现问题和上述提到的只有完全平方数有奇数个因子的问题是一样的

也就是如果灯的编号是完全平方数，那么它会被按奇数次，最后就是开着的

输入n轮，所以只需求出<=n的完全平方数就行了。


---

## 作者：kevin_y (赞：89)

-  看了其他题解，很多人已经知道是判断是否为完全平方数。
 但可能还有人不懂为什么要求完全平方数，可看看我的思路
- 首先要知道，当一个数因数的个数为奇数时，灯是亮的
- 一个非完全平方数，因数肯定为偶数 例：8:（1,2,4,8）
- 一个完全平方数，因数肯定为奇数 例：9:（1,3,9）
- 其实简单来说非完全平方数的每一个因数都可以跟一个不等自己的数相乘得到这个非完全平方数（1*8,2*4）；所以因数一定是偶数
- 完全平方数其中一个因数乘自己可得到这个完全平方数（1*9，3*3）；所以因数一定是奇数；
```cpp
#include<iostream>//并不用cmath
using namespace std;
int main(){
    long long n;cin>>n;
    for(int i=1;i*i<=n;i++)//i是中间数，我不用sqrt是为了少写个文件头
    cout<<i*i<<" ";//输出的全是完全平方数
} 
```

---

## 作者：yybyyb (赞：58)

凭什么这道题目是入门难度！！！！

就因为代码简单？？？？

想一想，一开始所有的灯都是关着的，

如果被操控若干次后，灯开着

则意味着灯被操控了奇数次

而一个灯被操控的次数是他的约数的个数

一个数$n=p_1^{a_1}*p_2^{a_2}...p_k^{a_k}$

的约数个数是$(a_1+1)(a_2+1)...(a_k+1)$

而且这个数是奇数

意味这所有的$a_i$都是偶数

也就是说，$n=m^2$

其中$m=p_1^{a_1/2}*p_2^{a_2/2}...p_k^{a_k/2}$

所以，所有的最终的满足条件的$n$都是完全平方数

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
long long n;
int main()
{
    cin>>n;
    for(int i=1;i<=sqrt(n);++i)
        printf("%lld ",1ll*i*i);
    puts("");
    return 0;
}

```

---

## 作者：lzxhdxx (赞：31)

这题题目看上去很水，当看到数据规模的时候，就能看出来一定是什么数学题，蒟蒻表示算了好几次才看出来规律，不过数学大佬一定都会……
很好，现在大家来看看这段代码
（别急，这是错的，慢慢读下去）
```cpp
#include<iostream>
#include<cstring>
using namespace std;
long long n;
int main()
{
	cin>>n;
	bool light[n];//其实这么写不规范，只是因为我实在不想写2^40了……
	memset(light,false,sizeof(light));//main内定义的记得初始化
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*i<n;j++)//枚举每个人的倍数
		{
			light[i*j]=!light[i*j];//取反
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(light[i])//开true关false，枚举true输出
		{
			cout<<i<<" ";
		}
	}
	return 0;
}
```
没错，这就是大家最喜欢的：枚举
我刚开始的思路就是暴力模拟，然后枚举取开着的灯，交了以后发现~~可爱的枚举~~竟然只有80大分（最后一个点MLE，没错，你没看错，是MLE，不是TLE）
所以我掏出我的80分蒟蒻代码开始找规律
过程：（愿意看看的同志们可以看看）
1.输入：1
  输出：1
2.输入：2
  输出：1
3.输入：10
  输出：1 4 9
4.输入：50
  输出：1 4 9 16 25 36 49
咦，这段数字好熟悉啊~这不就是我们熟悉的完全平方数吗（度娘是这么说的：如果一个正整数 a 是某一个整数 b 的平方，那么这个正整数 a 叫做完全平方数。零也可称为完全平方数。）
通过这段过程我们可以找出规律来：只要输出小于等于n的平方数（注意是小于等于），就可以过啦
我们按照这个理解重新写代码
```cpp
#include<iostream>
using namespace std;
int n;
int main()
{
	cin>>n;
	for(int i=1;i*i<=n;i++)     //平方数要小于等于n 
	{
		cout<<i*i<<" ";         //平方数 
	}
	return 0;
}
```
其实这个题目最重要的是找规律，规律找出来，题目本身就变得很简单了
本人萌新，不喜勿喷
管理大大求过~~

---

## 作者：__xxxxx (赞：18)

**先贴代码，再解答**

```cpp
var
  i,n:longint;
begin
  readln(n);
  for i:=1 to trunc(sqrt(n)) do
    write(sqr(i),' ');
```
writeln
end.
先由一位天天被**小学**奥数虐的小明同学来讲一下知识点：

小明：假设有一个数n，已知n的约数有k个，那么该如何判断它是否为完全平方数？

某位计算机业余爱好者：我知道！用trunc(sqrt(n))=sqrt(n)就可以了 ！

小明：……（他被气得离开了教室）

我：算了，还是我来说吧。**其实只要判断k的奇偶性即可！只有n为完全平方数是，k才为奇数。**（敲黑板！）

因此，代码就很好解释了……

P.S.不、要、枚、举$$a^2$$

我就因为这个TLE。呜呜……


---

## 作者：Arcturus1350 (赞：12)

编者说得对

一道很明显的数学题，相信大家小学都做过。

通俗一点，就是找因数为奇数个的数。而这一类的数。明显的是平方数。

所以就是找n以内的平方数。

废话少说，直接上题解。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    cout<<1;//声明一下，这里是由于输出格式限制。大家可以试一下。如果把1放到循环里面。
//就会发现最后总是多一个空格没法删。
    for(int i=2;i<=sqrt(n);i++)//一定是开根号
    cout<<" "<<i*i;
    return 0;//程序拜拜
}
```

---

## 作者：lemondinosaur (赞：7)

[题目传送门](https://www.luogu.org/problem/P1876)

[CSDN博客传送门](https://blog.csdn.net/sugar_free_mint/article/details/101605290)

---
# 题目
一个房间里有$n$盏灯泡，一开始都是熄着的，有$1$到$n$个时刻，每个时刻$i$，我们会将$i$的倍数的灯泡改变状态（即原本开着的现将它熄灭，原本熄灭的现将它点亮），问最后有多少盏灯泡是亮着的。

---
# 分析
显然可知，这道题目求有多少个数的约数有奇数个，

所以题目等价于求$$\lfloor\sqrt n\rfloor$$

洛谷题解结束（以下非此题正解）

在洛谷的是弱化版，但是在我们学校题库是高精度开方，一般用二分答案求解，~~但是在学校题库一堆巨佬暴力答案过了~~

巨佬的暴力时间复杂度最慢为$O(10len^3)$，但是我的虽然好不到哪里去但是时间复杂度高达$$O(len^2log_210^{len})\approx O(3len^3)$$。

当然巨佬们如果用$NTT$的时间复杂度$O(3len^2log_2len)$,也就算了，反正我是最菜的

---
# 洛谷代码
```cpp
#include <cstdio>
#include <cmath>
#define rr register
using namespace std;
inline void print(long long ans){
	if (ans>9) print(ans/10);
	putchar(ans%10+48);
}
signed main(){
	rr long long n; scanf("%lld",&n); 
	for (rr int t=sqrt(n),i=1;i<=t;++i)
	    print(1ll*i*i),putchar(32);
	return 0;
}
```
---
# 学校题库代码
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdlib> 
#define rr register
using namespace std;
inline void swap(int &a,int &b){a^=b^=a^=b;}
inline void tswap(int a[501],int b[501],int len){for (rr int i=1;i<=len;++i) swap(a[i],b[i]);}
struct Big{
	int len,t[501];
	inline Big mk(long long q,int pu){
		rr double ttt=sqrt(q)-floor(sqrt(q));
		len=0; rr int tt=sqrt(q),l=floor(log10(tt))+1;
		for (rr int i=l;i>=1;--i) t[i]=tt%10,tt/=10;
		for (rr int i=l+1;i<=l+pu;++i)
			ttt*=10,t[i]=floor(ttt),ttt-=floor(ttt);
		len=l+pu;
		return *this;
	}
	inline bool operator <(const Big p)const{
	    if (len!=p.len) return len<p.len;
		for (rr int i=1;i<=len;++i)
		if (t[i]!=p.t[i]) return t[i]<p.t[i];
		return 0;
	}
	inline Big operator +(const Big p)const{
	    rr int a[501],b[501],len1=len,len2=p.len,g=0; rr Big c;
	    memset(a,0,sizeof(a)),memset(b,0,sizeof(b)),memset(c.t,0,sizeof(c.t));
	    for (rr int i=1;i<=len;++i) a[i]=t[i];
	    for (rr int i=1;i<=p.len;++i) b[i]=p.t[i];
	    if (len1<len2) tswap(a,b,len2),swap(len1,len2);
	    for (rr int i=len2,j=len1;i;--i,--j) b[j]=b[i];
		for (rr int i=1;i<=len1-len2;++i) b[i]=0;
	    reverse(a+1,a+1+len1),reverse(b+1,b+1+len1);
	    for (rr int i=1;i<=len1;++i)
	    	a[i]+=b[i]+g,g=a[i]/10,a[i]%=10;
		if (g) a[++len1]=g;
		reverse(a+1,a+1+len1);
		tswap(c.t,a,len1),c.len=len1;
		return c;
	}
	inline Big operator *(const Big p)const{
	    rr int a[501],b[501],len1=len,len2=p.len; rr Big c;
	    memset(a,0,sizeof(a)),memset(b,0,sizeof(b));
	    for (rr int i=1;i<=len1;++i) a[i]=t[i];
	    for (rr int i=1;i<=len2;++i) b[i]=p.t[i];
	    if (len1<len2) tswap(a,b,len2),swap(len1,len2);
	    for (rr int i=len2,j=len1;i;--i,--j) b[j]=b[i];
	    for (rr int i=1;i<=len1-len2;++i) b[i]=0;
	    reverse(a+1,a+1+len1),reverse(b+1,b+1+len1);
	    c.len=len1<<1; memset(c.t,0,sizeof(c.t));
	    for (rr int i=1;i<=len1;++i)
	        for (rr int j=1;j<=len1;++j)
	  	        c.t[i+j-1]+=a[i]*b[j],c.t[i+j]+=c.t[i+j-1]/10,c.t[i+j-1]%=10;
	    while (!c.t[c.len]) --c.len;
	    while (c.t[c.len]>9) c.t[c.len+1]=c.t[c.len]/10,c.t[c.len]%=10,++c.len;
	    reverse(c.t+1,c.t+1+c.len);
	    return c;
    }
}L,R,b;
inline void ad1(Big &p){//加1
	++p.t[p.len];
	for (rr int now=p.len;p.t[now]>9;--now)
		++p.t[now-1],p.t[now]-=9;
	if (p.t[0]){
		for (rr int i=p.len+1;i;--i) p.t[i]=p.t[i-1];
		++p.len,p.t[0]=0;
	}
}
inline void de1(Big &p){//减1
	--p.t[p.len];
	for (rr int now=p.len;p.t[now]<0;--now)
		p.t[now]+=10,--p.t[now-1];
	if (!p.t[1]){
		for (rr int i=1;i<p.len;++i) p.t[i]=p.t[i+1];
		p.t[p.len--]=0;
	}
}
inline void divv(Big &p){//除以2
	for (rr int i=1,g=0;i<=p.len;++i)
	    p.t[i]+=g*10,g=p.t[i]&1,p.t[i]>>=1;
	if (!p.t[1]){
		for (rr int i=1;i<p.len;++i) p.t[i]=p.t[i+1];
		p.t[p.len--]=0;
	}
}
int mx=18,len; char s[501]; long long qrt;
signed main(){
	scanf("%s",s+1),len=strlen(s+1);
	mx=mx>len?len:mx,mx-=(len^mx)&1,b.len=len;
	for (rr int i=1;i<=len;++i) b.t[i]=s[i]^48;
	for (rr int i=1;i<=mx;++i) qrt=qrt*10+b.t[i];
	L.mk(qrt-1,(len-mx)>>1),R.mk(qrt+1000,(len-mx)>>1);//玄学优化范围
    while (L<R){
        rr Big mid,ttt; ad1(mid=L+R),divv(mid),ttt=mid*mid;
	    if (b<ttt) de1(R=mid); else L=mid;   
	}
	//二分答案控制范围
	for (rr int i=1;i<=L.len;++i) putchar(L.t[i]^48);
	return 0;
}
/*while (l<r){
    rr int mid=(l+r+1)>>1;
    if (mid*mid<target) r=mid-1;
        else l=mid;
}
return l;//参照《算法竞赛进阶指南》
*/
```

---

## 作者：Megumi_Cold (赞：7)

水啊！写c++要精简，9行

```cpp

#include<cstdio>  
using namespace std;  
int main()  
{  
    int n;  
    scanf("%d",&n);  //输入
    for(int i=1;i*i<=n;i++)  //求平方之前，注意等于号
    printf("%d ",i*i);  //输出
}

```

---

## 作者：fallingdust (赞：5)

只要同志们了解方法就会发现：我的程序绝对是最简单的（方法）；

```cpp
#include<bits/stdc++.h> //万能头文件，不解释
int main()
{
    int x;
    scanf ("%d",&x); //读入X；
    for (int i=(sqrt)(x),n=1;n<=i;n++) //自己做一下就会发现，开着的一定是完全平方数，所以求X的平方跟，再穷举
    {
        printf ("%d ",(n*n)); //打印答案
    }
    return 0; //结束
}
```

---

## 作者：Huangc (赞：4)

的确像题目描述所说的，短的不能再短~

```cpp
#include<cstdio>
using namespace std;
int n,i=1,j=0; 
int main()
{
    scanf("%d",&n);
    for(int i=1;i*i<=n;i++)
        printf("%d ",i*i);
    return 0;
}
```
还有更短的吗？

P.S:除非你想cxy004那样全挤在一行里、、、


---

## 作者：zhangjingzhuo (赞：3)

经过几次测验后我们不难发现，亮着的灯的编号都是小于等于n的完全平方数。但是如果用大多数人的办法对每个数进行开根号或是平方处理的话效率仍不是最高的，这时我们就可以找规律：
```cpp
1 4 9 16 25 36 49 64 81……
```
通过观察可以发现：每相邻两个完全平方数的差的差都是2（4-1=3,9-4=5,16-9=7……）

所以我们可以用一个数来存储两个数之间的差，然后再依次相加。

可能说起来会有些抽象，AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,i,j=1;
	cin>>n;//读入n
	for(i=1;i<=n;i+=j){//用j来存储两个数之间的差
		cout<<i<<' ';//输出完全平方数
		j+=2;//差的值增加2
	}
	return 0;
}
```
目前来说，这应该是效率最高的代码了。

---

## 作者：lightdarkxjt (赞：2)

各位先看看这段无关的代码吧

```cpp

#include "stdio.h"
bool stage[10000]={false};
int main(void)
{
    for(int n=1;n<=100;n++)
    {
        memset(stage,0,sizeof(stage));
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j*i<=n;j++)
                stage[j*i]=!stage[j*i];
        }
        for(int i=1;i<=n;i++)
            if(stage[i])
                printf("%d ",i);
        printf("\n");
    }
    return 0;
}


```
用这个就能得出结论：这道题实际就是输出小于等于n的平方数

于是这就是答案

```cpp

#include "iostream"
long long n;
int main(void)
{
    std::cin>>n;
    for(long long i=1;i*i<=n;i++)
        std::cout<<i*i<<" ";
    return 0;
}


```
顺便赠送一个1行的代码，在语言选择时得选择C才能通过

```cpp

int main(void){int n,i;scanf("%d",&n);for(i=1;i*i<=n;printf("%d ",i*i),i++);return 0;}

```

---

## 作者：Nightriver (赞：2)

嗯，至于这道题，可能数学学过的大神都会//(￢\_￢)汗


呐，以下是按正常思路来的代码（不解释，自己用Pascal试去）


```cpp
var
  n,i,j,k,t,s,r:longint;
  a:array[1..100051]of boolean;
begin
  read(n);
  for i:=1 to n do a[i]:=false;
  for i:=1 to n do begin
    for j:=i to n do begin
      if j mod i=0 then a[j]:=not a[j];
    end;
  end;
  for i:=1 to n do
    if a[i] then write(i,' ');
end.
```
然而小朋友们如果用这个代码会发现测试点中一个会超时，一个会运行错误
但是聪明的小朋友发现了这些输出的数都是平方数

所以就变成了一个超简单的代码：

```cpp
var
  n,k:longint;
begin
  read(n);
  k:=1;
  while sqr(k)<=n do begin
    write(sqr(k),' ');
    k:=k+1;
  end;
end.
再次不解释O(∩_∩)O~
```

---

## 作者：road (赞：1)

# ……
这两天在打洛谷的入门题，颇有所感——最基础的东西常常能带来意想不到的收获。

切入正题——p1876 开灯

（讲题之前不得不吐槽一下洛谷的数据是~~真的水~~如此……）

首先，暴力的思路，枚举每个数字和它的倍数，更新当前灯的状态，代码——
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000000;
long long n;
bool b[N];
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
		for(long long j=i;j<=n;j+=i)b[j]^=1;
	}
	for(long long i=1;i<=n;i++)if(b[i]==1)printf("%lld ",i);
}
```

如此，80分……是不是~~很水~~

然后是正解，思考——若存在一盏灯只被切换了三次状态，这盏灯的特性—— 1.被1切换一次 2.被他自己切换一次 3.被这个数的平方根切换一次：即枚举一个数的平方数，代码——
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
		if(i*i>n)return 0;
		else printf("%lld ",i*i);
	}
	return 0;
}
```


---

## 作者：Ryzen_2990WX (赞：1)

## 本蒟蒻第一次发题解，若有错误还请dalao指出，谢谢！

关于此题，本萌新只能~~笑笑不说话~~，我弄了半天的循环、递归，最后发现竟然可以用

 _让我原地喷的_ 

 _让我心跳骤停的_ 

 _让我无法呼吸的_ 

 _让我好▪嗨▪哟的_ 
 
 _让我……_ 

哎，回到正题哈！（敲黑板）

~~看了会吐的~~ 
# 平方数 
来做这道题

回去重新看题目的时候才发现，在说明里面早有暗示：“数学题！”

平方数是什么呢？

平方数是指可以写成某个整数的平方的数，即其平方根为整数的数。例如，9 = 3 × 3，9是一个平方数

然而，这些最后是打开着的灯，都是平方数，因为只有它们才有奇数个因子（或称因数）

所以，我们可以直接用循环＋输出AC

这是我想到平方数以后第一次的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long n;
    cin>>n;
    for(long long i=1;pow(i,2)<=n;i++)
    {
        cout<<pow(i,2)<<' ';
    }
    return 0;
}
```
但是，很可怕的是，80分，最后一个点WA了

在经过调试之后，我发现，这是因为我直接用了pow这个函数

而它的原型是pow(float,float);

所以这里过不去

直接改 i * i 后的AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long n;
    cin>>n;
    for(long long i=1;i*i<=n;i++)
    {
        cout<<i*i<<' ';
    }
    return 0;
}
```
PS：萌新第一次发帖，求管理大大通过 QAQ 

---

## 作者：吴文涛 (赞：1)

这题主要是要找到规律（亮着的灯是小于n的完全平方数）

至于完全平方数不用我说了吧？

献上我的代码

```cpp
var n,i:qword;//全用qword算了（其实是我懒）
begin
  readln(n);
  for i:=1 to trunc(sqrt(n)) do//循环
    write(i*i,' ');
end.

```

---

## 作者：Hcf2002 (赞：1)

这题要先找规律。。其实想不出来的话可以自己写一段代码打印出来一些数据

```cpp
for i:=1 to n do
for j:=1 to n do
if j mod i=0 then a[j]:=a[j]+1;
for i:=1 to n do
if a[i] mod 2 <> 0 then write(i,' ');
```
举个例子0.0
我打印到25就很容易看出规律来了。。。

代码自己写。。


---

## 作者：Beltack (赞：1)


```cpp
var
   N,i:longint;
begin
   readln(N);
   N:=trunc(sqrt(N));
   for i:= 1 to N do
      write(sqr(i),' ');
end.
```
如上所示，貌似和别人差别不大，解释的话别人也说了。。
注意这里输出格式是有坑的，数与数之间要空格且不换行！

我就是这样被坑了一个小时找错误。。。

自己最开始做的一种枚举算法（正常思路）就不写了。。。


---

## 作者：Kidd (赞：1)










```cpp
var n,x:int64;//不点int64，岂能AC这道题
begin
   readln(n);
   while true do//霸气吧，死循环！！
   begin
      inc(x);
      if x*x>n then halt;//活门
      write(x*x,' ');//求完全平方数
   end;
end.
```

---

## 作者：hexuan (赞：1)

```cpp
var n,ans:longint;
begin
  read(n);   ans:=0;//初始化
  repeat
    inc(ans);
    if ans*ans<=n then write(ans*ans,' ');
  until ans*ans>n;
end.
注：本题求完全平方数。
```

---

## 作者：Memory_of_winter (赞：1)

小学算法，只有编号为完全平方数的灯是开着的

```cpp
var
 a,n:longint;
begin
 readln(n);//读入有几盏灯
 if n>0 then write(1);//1一定是开的，输出1（这样输出是为了防止洛谷说有多余空格）
 for a:=2 to trunc(sqrt(n)) do write(' ',a*a);//输出开的灯
writeln;//防止洛谷说末尾无换行
end.
```

---

## 作者：九指客 (赞：1)

```cpp
#include<stdio.h>//头文件
int main()
{
    int i,n;//定义
    scanf("%d",&n);//输入人数
    for(i=1;i*i<=n;i++)
    {
        printf("%d ",i*i);//开着的只有小于n的平方数；
    }
    return 0;//结束
}
```

---

## 作者：Ufowoqqqo (赞：1)

没有更短，只有最短。题意即为求1~√n范围内的完全平方数，具体原因请读者自行思考。

```delphi

var
 n:int64;
 i:longint;
begin
 read(n);
 for i:=1 to trunc(sqrt(n)) do write(i*i,' ');
end.

```

---

## 作者：LaWekokomidy (赞：1)

### 翻了下题解区，貌似没看到Java的题解
### 虽然说NOIP和NOI都没有Java，
### 但毕竟洛谷有嘛
### 所以便决定跑过来写篇Java的
### 顺便找一起写Java的小伙伴
```java
import java.util.*;
import java.math.*;
public class Main {
	public static void main(String[] args){
		long n;
		Scanner cin=new Scanner(System.in);
		n=cin.nextLong();
		for(int i=1;i<=Math.sqrt(n);i++)
				System.out.print(i*i+" ");
		return;
	}
}
/*
Java主要是输入输出得调用util包的Scanner，比较麻烦
要不然其他方面也都挺不错的
*/
```
------------

## 下面说说思想，很简单
## 首先，这是道数学题 ~~这不是废话吗~~
## 题解区的其他大佬基本都说了，这道题就是找1至sqrt(n)的平方数
## 所以直接开一个for循环找就可以了

---

## 作者：Independence (赞：1)

这道题的确是数学题。

我们试想一下，什么样的灯最后会开着？

很显然，因数个数为奇数的数才能开着。

因数一般是成对出现的，所以一般的数是有偶数个因数。

只有完全平方数才有奇数个因数，因为有一对因数是两个相等的数。

所以题目就转化为，求n以内的完全平方数。

下面给代码：

```cpp
#include<bits/stdc++.h>
#ifdef WIN32
#define L "%I64d"
#else
#define L "%lld"
#endif
using namespace std;
int main(){
           long long n;
           scanf(L,&n);
           for(long long i=1;i*i<=n;i++){
                       printf(L,i*i);
                       printf(" ");
           }
           return 0;
}

```

---

## 作者：guobaipeng0 (赞：1)

这是一道关于数论的题目，这是最保险的做法，思路就是找出1到n以内的完全平方数（完全平方数：任意一个整数的平方，称为完全平方数），并输出。为什么是完全平方数呢？因为当灯泡被按了奇数次时，就是开着的，否则就是关着的。而开关多少次取决于这个人的倍数是否有这盏灯的编号，反过来说就是这一盏灯的因数的编号的人，就会按开关。只要看看这盏灯的因数个数是奇数，就是开的，再输出。这就是本题的思路。而完全平方数就是有奇数个因数的，所以简化题目，就是求出1~n的完全平方数。代码参考：



```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
long long n;
int main()
{
    cin>>n; //输入n，表示n以内。
    for(int i=1;i*i<=n;i++) cout<<i*i<<" "; //i表示完全平方数原来上文所述的整数
    return 0;
}
```

---

## 作者：HZZX_CJX (赞：1)

思路是：只有完全平方数有奇数个因数；因为操作奇数次灯开着，于是求1~n中的完全平方数，也就是1~trunc(sqrt(n))的平方！、


```cpp
var n,i:longint;
begin
  readln(n);
  for i:=1 to trunc(sqrt(n)) do write(i*i,' ');
end.
```

---

## 作者：Sinwind (赞：0)

------------

# 思路

1. 归纳法（0-关，1-开）：
- 当n = 1时，{0}=>{1}，1号灯是亮的；
- 当n = 2时，{0,0}=>{1,1}=>{1,0}，1号灯是亮的；
- 当n = 3时，{0,0,0}=>{1,1,1}=>{1,0,1}=>{1,0,0}，1号灯是亮的；
- 当n = 4时，{0,0,0,0}=>{1,1,1,1}=>{1,0,1,0}=>{1,0,0,0}=>{1,0,0,1}，1,4号灯是亮的；
- 当n = 5到n = 8时，1,4号灯是亮的；
- 当n = 9到n = 15时，1,4,9号灯是亮的。
- 归纳可得：**亮的灯的编号为s是平方数，且s <= n**；

2. 证明：
- 对于编号为s的灯，当它的开关次数为奇数次，最后结果为开；开关次数为偶数次，最后结果为关；
- 当k是s的因数时开关一次（1<=k<=n），开关的次数为k的个数，即s的因数个数；
- 因数个数都是成对出现的（例：10的因数为1,2,5,10），但平方数有一对因数相等，看作一个（例：9的因数为1,3（2个3看作一个）,9），因此平方数的因数个数为奇数个；
- 平方数的因数个数（例：4的因数为1,2,4，共3个）为奇数个，最后结果为开，其他数的因数个数为偶数个（例：15的因数为1,3,5,15，共4个），最后结果为关，因此**开着的灯的编号都是平方数**。

2. 代码：
- 读取灯的个数和操作的轮数n；
- 输出不大于n的所有平方数（0除外）。

------------

# 代码

```cpp
#include <cstdio>

using namespace std;

int main(void)
{
	long long n;        //灯的个数和操作的轮数
	
   	scanf("%lld", &n);
	
	for(int i = 1; i * i <= n; i++)
	{
		printf("%d ",i * i);
	}
	
	printf("\n");
	
	return 0;
}
```


------------

---

## 作者：灬Amiya灬 (赞：0)

一开始很懵逼，画到10盏后豁然开朗
只要第n盏灯的约数不是偶数就肯定是开的了，因为约数为偶数，就是关了。自己试几个数就明白了，所以如果约数中，有相等的即可，例如1中的1,4中的2,9中的3,会使约数变为奇数，这样就开了。
所以就明白，只要n的开方为相等的约数，n灯必开
故从i，遍历出i*i的数即可。
代码如下
```java
import java.util.Scanner;

public class Main {
	static long N;
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		Scanner in = new Scanner(System.in);
		N = in.nextLong();
		for(int i=1;i*i<=N;i++) {
			if((i+1)*(i+1)<=N)System.out.print(i*i+" ");
			else System.out.println(i*i);
		}
	}

}

```

---

## 作者：SS003 (赞：0)

在这道题目中,我们先找一下规律:

 1: 1
 
 2: 1 0

3: 1 0 0

4: 1 0 0 1

5: 1 0 0 1 0

6: 1 0 0 1 0 0

7: 1 0 0 1 0 0 0

8: 1 0 0 1 0 0 0 0
 
9: 1 0 0 1 0 0 0 0 1

...

可以发现是:1,4,9,16,25...

也就是n^2( n=sqrt(N) )通过以下代码列出表格

```cpp
	int s[600000];long long i,ii,n;//模拟该题条件
    scanf("%lld",&n);
	for(i=1;i<=n;i++){
	for(ii=1;ii<=n;ii++){
    if(ii%i==0){
    if(s[ii]==0){s[ii]=1;}
    else{s[ii]=0;}
    }
    }}
	for(i=1;i<=n;i++){if(s[i]==1){printf("%d ",s[i]);}
    return 0;
```

代码:
```cpp
int main(){
long long i,n,s;
scanf("%lld",&n);
for(i=1;i<=sqrt(n);i++){s=pow(i,2);printf("%lld ",s);}
return 0;
}
```

---

## 作者：Peter_Z (赞：0)

此处有两个方法：第一个是用数学做，第二个是暴力模拟。

先证明编号为完全平方数的灯会开：

由于遍历每个数时，范围内的所有编号为这个数的倍数的灯都要拉一遍。

也就是说，对于每一盏灯，它都要被拉它的编号的因数个数次。

最后被拉奇数次的灯会开，由于只有完全平方数的因数个数为奇数，所以编号为完全平方数的灯会开。

附上AC代码：

···
```cpp
#include<iostream>
using namespace std;
int main() {
    int n;            //题目给出的n 
    cin>>n;
    for(int i=1; i*i<=n; i++)    //遍历1到n的平方根（不多打，不少打） 
        cout<<i*i<<' ';        //输出所有的完全平方数 
    return 0;
}
```
···
但是我做完后想用模拟的方法再试一试，于是又一段代码出来了：

···
```cpp
#include<iostream>
#include<map>
using namespace std;
int main() {
    long long n;            //题目给出的n 
    cin>>n;
    map<int,bool> lig;        //由于数据量大，只能用map省空间 
    for(long long i=1; i<=n; i++) {
        for(register long long j=1; i*j<=n; j++) {
            lig[i*j]=!lig[i*j];        //模拟标记拉过的灯 
        }
    }
    for(long long i=1; i<=n; i++) {
        if(lig[i]) {                //若灯是亮着的则输出编号 
            cout<<i<<' ';
        }
    }
    return 0;
}
```
···
因为本题的数据太大，只有80分，剩下一个点TLE。

不过如果数据比较小，这个方法速度也不算慢。


---

## 作者：Drinkkk (赞：0)

/\*
P1876 题解

\*/
//我们可以当做把答案放在一个名为ans的数组里面，那么ans[i]=i^2且i^2小于等于n

```cpp
#include <cstdio>//头文件
#include <cmath>//头文件
int main()//主函数
{
    int n=0,t=0;//初始化变量（规律：到最后开着的灯都是1^2~t^2，注意：t*t小于等于n）
    scanf("%d",&n);//输入n
    while(++t<=sqrt(n))//找答案
    {
        printf("%d ",t*t);//输出t的平方
    }
    return 0;//结束程序
}
```

---

## 作者：Mark_ZZY (赞：0)

//因为有且仅有平方数的因子个数为奇数，所以求1~n之间的平方数。

```cpp
//如16的因子为1，2，4，8，16（5个）
//81的因子为1，3，9，27，81（5个）
#include<cstdio>
    long long n;//2^40，开long long
int main()
{
    scanf("%lld",&n);
    for(long long i=1;i!=0;i++)
        if(i*i<=n) printf("%lld ",i*i); else return 0;//如果i*i小于n，就输出i*i
}
```

---

## 作者：AdzearDisjudge (赞：0)

这题核心思路：只有完全平方数有奇数个因数（还是叫因子的来着？），所以只要举出完全平方数就好咯

PS:看此贴的诸位比代码行数？我也来凑个热闹（C++的同志们，您们最短只能是两行，预处理要和其他的分开来……                        像我这样 ↓ ↓ ↓（手动滑稽））

```cpp
#include<bits/stdc++.h> 
using namespace std;int main(){unsigned long long i,j;i=1;cin>>j;for(;;){if(i*i>j)return 0;cout<<i*i<<' ';++i;}}
```

---

## 作者：nuclear (赞：0)

本题考查数学思想


仔细想想，可以得出，只有自己的因数有两个相同的正整数时，这个编号的灯才会被点击两边，所以就会被打开（第一个一直是开着的并且不会再次被点击）


代码就很简单了

/\*
web:ww.luogu.org

who:nuclear

when:2016-11-22 20:06:34

P1876
\*/
    
    
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int main(){
    int n;
    cin>>n;
    for(int i=1;i*i<=n;i++){
        cout<<i*i<<" ";
    }
    return 0;
}
```

---

## 作者：PTC06 (赞：0)

这题是一个很明显的数学题啊，一眼就可以看出来了（因为提示里写了，而且标签还是数论...）。主要思路就是找出1至trunc(sqrt(n))之间的完全平方数。（若一个数能表示成某个整数的平方的形式，则称这个数为完全平方数。）可以很明显看出，被按了奇数次的灯泡最后将会是亮着的，被按了偶数次的灯泡将会是灭的。此题中，当一盏灯被开灯、关灯的那些人按了奇数次，那它就会是开的。一个灯有多少个人按过取决于它是多少个人的编号的倍数。也就是说如果那个灯的编号的因数的个数是奇数，它最后就是开的，否则就是关的。而完全平方数的因数个数一定是奇数。代码如下：

```cpp
#include<iostream>
#include<cmath> 
using namespace std;
long long n,i,t,a[1000000];
void read()
{
    cin>>n;
}
void perfect_square()
{
    for (i=1;i<=trunc(sqrt(n));i++)                 //将找到的完全平方数用数组存起来.
    {
        t++;
        a[t]=i*i;
    }
}
void wri_te()
{
    perfect_square();
    for (i=1;i<=t;i++)
    {
        cout<<a[i]<<' ';                 //输出所有的完全平方数。
    }
 } 
int main()
{
    read();
    wri_te();
}
```

---

## 作者：nekoa (赞：0)

这道题代码很简单，主要是思路需要想；  
首先灯是关着的，需要经过奇数次操作才会变成打开
然而每一次操作，都得是这个数的因数才会进行操作（包括它本身）   
现在，问题就变成了找在范围之内的并且有奇数个因数的数
。  
但一般的数的因数都成对出现（因为原数除以这个因数得另一个因数）要有奇数个因数，就要让这两个数相同，就是因数的平方数，   
所以，问题变成了找范围以内的完全平方数；      
在不超过范围的情况下枚举就行了；   
代码很简单我就不写了，不过说一个函数： sqrt（一个数）：作用是这个数的平方根 ；  
定义于头文件 <cmath>   
会用到它；   
然后输入n，求出<=n的平方数就可以了。

---


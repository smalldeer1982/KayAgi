# 赵神牛的游戏

## 题目描述

在 DNF 中，赵神牛有一个缔造者，他一共有 $k$ 点法力值，一共有 $m$ 个技能，每个技能耗费的法力值为 $a_i$，可以造成的伤害为 $b_i$，而 boss 的体力值为 $n$，请你求出它放哪个技能，才可以打死 boss。

当然，赵神牛技术很菜，他一局只放一个技能，不过每个技能都可以放无数次。

## 说明/提示

#### 数据规模与约定
对于全部的测试点，满足：

- $0< n,m\le 3\times 10^4$；
- $0\le k\le 3\times 10^4$；
- $0 \leq a_i,b_i\le 2147483647$。

## 样例 #1

### 输入

```
100 3 5000
20 1000
90 1
110 10000
```

### 输出

```
1
```

## 样例 #2

### 输入

```
50 4 10
60 100
70 1000
80 1000
90 0
```

### 输出

```
-1```

# 题解

## 作者：liao (赞：228)

#### 先前好像有点排版错误，这里更正一下 qwq
## 这题好坑啊  
#### 看似很简单，但是，我竟然挂了两次~~（好丢脸啊）~~， 
### [~~前往博客食用效果更佳~~](https://www.luogu.org/blog/liaofuyi123/solution-p2006)
## -------------------- 我是分割线 --------------------  
* 第一次提交：怎么会RE？！竟然有除以0的情况！！  
```cpp
//RE Code
#include<bits/stdc++.h>
using namespace std;
int tot,num,bld,cst,hrt,flg;
int main() {
		cin>>tot>>num>>bld;
		for(int i=1; i<=num; i++) {
			cin>>cst>>hrt;
			if((tot/cst)*hrt>=bld)
				flg=1,cout<<i<<' ';
		}
		if(!flg)cout<<-1;
		return 0;
}
```
* 第二次：WA？？哇！花费0，技能伤害为正数为可以击败boos  
```cpp
//WA Code
#include<bits/stdc++.h>
using namespace std;
int tot,num,bld,cst,hrt,flg;
int main() {
		cin>>tot>>num>>bld;
		for(int i=1; i<=num; i++) {
			cin>>cst>>hrt;
			if(cst&&(tot/cst)*hrt>=bld)
				flg=1,cout<<i<<' ';
		}
		if(!flg)cout<<-1;
		return 0；
}
```
* 嘿嘿嘿——~~我最喜欢绿色了~~![](https://i.loli.net/2019/02/17/5c6970c459767.png)  
```cpp
//AC Code!!
#include<bits/stdc++.h>
using namespace std;
int tot,num,bld,cst,hrt,flg;
int main() {
		cin>>tot>>num>>bld;
		for(int i=1; i<=num; i++) {
			cin>>cst>>hrt;
			if((!cst&&hrt)||(cst&&(tot/cst)*hrt>=bld))
				flg=1,cout<<i<<' ';
		}
		if(!flg)cout<<-1;
		return 0;//代码是不是很清爽呢
}
```
卖个萌(*╹▽╹*)，求过

---

## 作者：kkksc03 (赞：137)

这个很简单吧，只要求出每种技能一共可造成多少伤害，然后与boss的体力值相比，如果大于的话就输出。计算每个技能能造成多少伤害，公式就是

　　b\*(k div a)

其中b是该技能的伤害，k是他一共的法力值，a是该技能消耗的法力值。

由于题目中出现了=0的情况，所以我们还要对此稍加注意，不过也不难。

若a=0且b≠0，那么一定可以杀死Boss；

若b=0，那么一定杀不死boss。


---

## 作者：ninininininini (赞：29)

# 解题报告 P2006

 解题报告

---

### 1.做题原因

- 智推里有
- 是~~入门难度~~

### 2.解题报告
题面:
```
在DNF 中，赵神牛有一个缔造者，他一共有k点法力值，一共有m个技能，每个技能耗费的法力值为a[i]，可以造成的伤害为b[i]，而boss 的体力值为n，请你求出它放哪个技能，才可以打死boss。当然，赵神牛技术很菜，他一局只放一个技能（这技术……）,不过每个技能都可以放无数次。
输入:第一行，三个数k,m,n；后面m行，每行两个数，表示耗费的法力值和造成的伤害。
输出仅一行，既可以杀死boss 的技能序号，如果有多个，按从小到大的顺序输出，中间用一个空格隔开；如果没有技能能杀死boss，输出-1。
```
思考:

1.先判断能不能杀死不能输出-1就完了

2.有的话每个技能扫过一遍之后有几个输出几个就完了
 
好像就这样了......

写着写着发现能不能杀死还不好判断......

于是就写成了以下的代码:

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
	ll k,m,a[30005],b[30005],n,d[30005],e[30005];
	bool c[30005]={1},zt=0;
	cin>>k>>m>>n;
	for(ll i=m;i<=30005;i++){d[i]=n;}
	for(ll i=m;i<=30005;i++){c[i]=0;}
	for(ll i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i];
		e[i]=k/a[i];
		if(a[i]>k) c[i]=0;//先把用不起的删掉 
	}
	for(ll i=1;i<=m;i++)
	{
		if(c[i]==1)
		{
			for(ll j=1;j<=e[i];j++)
			{
				d[i]-=b[i];
			}
			if(d[i]>0) c[i]==0;
		}
		else;
	}
	for(ll i=1;i<=m;i++)
	{
		if(c[i]==1) cout<<i;
		else;
	}
	return 0;
}
```
这代码看着就不对劲

但是,无输出????

又改
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
	ll k,m,a[30005],b[30005],n,d[30005],e[30005];
	bool c[30005]={1},zt=0;
	cin>>k>>m>>n;
	for(ll i=1;i<=30005;i++){d[i]=n;}//血量 
	for(ll i=m+1;i<=30005;i++){c[i]=0;}//状态 
	for(ll i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i];
		e[i]=k/a[i];//e是技能次数 
		if(a[i]>k) c[i]=0;//先把用不起的删掉 
		else;
	}
	for(ll i=1;i<=m;i++)
	{
		if(c[i]==1)
		{
			for(ll j=1;j<=e[i];j++)
			{
				d[i]-=b[i];//模拟击败过程 
			}
			if(d[i]>0) c[i]==0;
			else c[i]==1;
		}
		else;
	}
	for(ll i=1;i<=m;i++)
	{
		if(c[i]==1) zt=1;
		else;
	}
	if(zt==0) cout<<-1;
	else if(zt==1)
	{
	    for(ll i=1;i<=m;i++)
	    {
		    if(c[i]==1) cout<<i<<" ";
		    else;
	    }
	}
	return 0;
}
```
只输出-1???

10分

然后看了一下kkk的提示:

每个技能的伤害为:$b_i\times(k\div a_i)$

突然发现一开始的思路就是一团~~shit~~

然后就大改得出了这样的代码:
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
	ll k,m,a[30005],b[30005],n,e[30005];
	bool c[30005]={1},zt=0;
	cin>>k>>m>>n;
	for(ll i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i];
		e[i]=(k/a[i])*b[i];
	}
	for(ll i=1;i<=m;i++)
	{
		if(e[i]>=n) cout<<i<<" ";
	}
	return 0;
}
```
全RE???
然后看了别人的讨论,$a_i$居然有零???????
于是将$a_i$为0的攻击记为$n$
又改:
```
#include<bits/stdc++.h>
#define ll long int
using namespace std;
int main()
{
	ll k,m,a[30005],b[30005],n,e[30005];
	bool c[30005]={1},zt=0;
	cin>>k>>m>>n;
	for(ll i=1;i<=m;i++)
	{
		cin>>a[i]>>b[i];
		if(a[i]==0) e[i]=n;
		else if(a[i]!=0) e[i]=(k/a[i])*b[i];
	}
	for(ll i=1;i<=m;i++)
	{
		if(e[i]>=n) cout<<i<<" ";
	}
	return 0;
}
```
90，还剩一个-1,如果有输出,就不输出-1
```
#include<bits/stdc++.h>
#define ll long int
using namespace std;
int main()
{
    ll k,m,a[30005],b[30005],n,e[30005];
    bool c[30005]={1},zt=0,kkk=0;
    cin>>k>>m>>n;
    for(ll i=1;i<=m;i++)
    {
        cin>>a[i]>>b[i];
        if(a[i]==0) e[i]=n;
        else if(a[i]!=0) e[i]=(k/a[i])*b[i];
    }
    for(ll i=1;i<=m;i++)
    {
        if(e[i]>=n) cout<<i<<" ",kkk=1;
        else;
    }
    if(kkk==0) cout<<-1;
    return 0;
}
```
AC!!!
精简一下:
```
#include<bits/stdc++.h>
#define ll long int
#define _for(i,a,b) for(ll i=a;i<=b;i++)
using namespace std;
int main()
{
    ll k,m,a[30005],b[30005],n,e[30005];
    bool kkk=0;
    cin>>k>>m>>n;
    _for(i,1,m)
    {
        cin>>a[i]>>b[i];
        
        if(a[i]==0) e[i]=n;
          else if(a[i]!=0) e[i]=(k/a[i])*b[i];
		if(e[i]>=n) cout<<i<<" ",kkk=1;
    }
    if(kkk==0) cout<<-1;
    return 0;
}
```
~~好久没这么认真写题了~~

用时:1h

~~求过~~


---

## 作者：梦里调音 (赞：26)


~~我绝对不会告诉你们我WA了两次~~

第一次跳坑了RE;

第二次把空格输出成endl了。。。

### 别掉坑鸭

注意：

耗法值为0且伤害大于0肯定可以；

伤害为0肯定不行；

我们让神牛拼尽全力qwq，

那么，他的总伤害为：使用技能次数*技能伤害

而使用技能次数为： 法力总值/耗法值。

最后，记得如果未输出要输出-1.

下面三个代码只有一个对的，我都解释了，你们还不会选吗？
```cpp
# include <iostream>
# include <algorithm>
using namespace std;
int main()
{
    int i,j,k,m,n,a,b,l=0;
    cin>>k>>m>>n;
    for(i=1;i<=m;i++){
    	cin>>a>>b;
    	if(a==0&&b>0){cout<<i<<" ";l=1;continue;}
    	if(b==0)continue;
    	if(k/a*b>=n){cout<<i<<" ";l=1;}
    }
    if(l==0)cout<<-1<<endl;
    return 0;
}
```


------------

```cpp
# include <iostream>
# include <algorithm>
using namespace std;
int main()
{
    int i,j,k,m,n,a,b,l=0;
    cin>>k>>m>>n;
    for(i=1;i<=m;i++){
    	cin>>a>>b;
    	if(a==0&&b>0){cout<<i<<endl;l=1;continue;}
    	if(b==0)continue;
    	if(k/a*b>=n){cout<<i<<endl;l=1;}
    }
    if(l==0)cout<<-1<<endl;
    return 0;
}
```


------------

```cpp
# include <iostream>
using namespace std;
int main()
{
    int i,j,k,m,n,a,b,l=0;
    cin>>k>>m>>n;
    for(i=1;i<=m;i++){
    	cin>>a>>b;
    	if(k/a*b>=n){cout<<i<<endl;l=1;}
    }
    if(l==0)cout<<-1<<endl;
    return 0;
}
```

---

## 作者：九指客 (赞：19)

```cpp
#include<stdio.h>//头文件
int k,m,n,a,b,t=0,i;//初始化
int main()
{
    scanf("%d%d%d",&k,&m,&n);//输入k,m,n;
    for(i=1;i<=m;i++)//读入a,b和处理；
    {
        scanf("%d%d",&a,&b);
        if(!a||k/a*b>=n)printf("%d ",i),t=1;//如果大于boss血量，输出
    }
    if(!t)printf("-1");//如果没有满足的输出-1;
}
```

---

## 作者：lyc_AFO (赞：12)

哇啦！

发现好像没有人写结构体诶（~~好像也没必要~~）

所以呢，我就提供一种结构体法！！！

这题有个坑，就是法术可以为零，没考虑到就RE了φ(≧ω≦*)♪ 

所以说……上代码！！```


```
#include <bits/stdc++.h>
using namespace std;
struct jn {
	int xh,fl,sh;
} k[3000005];
int main() {
	long long f,n,x,o=0;
	cin>>f>>n>>x;
	for(int i=1; i<=n; i++) {
		cin>>k[i].fl>>k[i].sh;
		k[i].xh=i;
	}
	for(int i=1; i<=n; i++) {
		if(k[i].fl==0&&k[i].sh>0) {
			cout<<k[i].xh<<" ";
			continue;  //要考虑法术为0的情况
		}
		if(f/k[i].fl*k[i].sh>=x)cout<<k[i].xh<<" ";
		else o++;
	}
	if(o==n)cout<<"-1";
	return 0;
}



```


好了，就全AC了

写了两次题解都没过，这次一定要过啊！！！




---

## 作者：eegg (赞：12)


	#include<cstdio>
	#include<iostream>
	using namespace std;
	int main()
	{
    	long long  k,m,n,i,a,l,b,s=0;//最好用long long
		cin>>k>>m>>n;
		for(i=0;i<m;i++)
		{
			cin>>a>>b;
			if (a==0)//a=0一定会打败BOSS
			{
				cout<<i+1<<" ";//一定还要输出空格
				s=1;
				continue;
			}
			else 
				l=k/a;//求能用多少次技能
			if(l*b>=n)//判断能不能打败BOSS
			{
				s=1;
				cout<<i+1<<" ";
			}
		}
		if(s==0)
			cout<<"-1";
		return 0;
	} 
    

---

## 作者：夙愿扬 (赞：6)

~~这道题我真的1次就AC~~

首先，这是一个简单的模拟。此题关键在于判断单独一个技能在有限的法力值内能否打败boss。

就这样我RE了三个点。很显然这道题有个坑~~（我就跳进去了）~~就是在判断时的除数问题。
```
if(k/a*b>=n)
```
在这句话里，a显然是可以等于0的，所以要加一个a==0时的特殊情况的判断，于是完美AC。

完整AC代码：
```
#include<bits/stdc++.h> //万能头 
using namespace std;
int main ()
{
	int n,m,k,a,b;//变量如题意所述 
	bool c=0;//判断是否能打败boss 
	scanf("%d%d%d",&k,&m,&n);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a,&b);
		if(a==0)//判断特殊情况 
		{
			printf("%d ",i);//输出 
			c=1;
		}
		else if(k/a*b>=n)
		{
			printf("%d ",i);//输出 
			c=1;//能打败 
		}
	}
	if(c==0)//不能打败boss 
	printf("-1");
	return 0;//收尾 
}
```
//第一篇题解完美完成:2018 10 09 22 52 28

---

## 作者：Sinwind (赞：4)

思路：

1. 读取法力值k，技能个数m，BOSS的体力值n，循环读取m个技能的消耗的法力值a[i]，伤害值b[i]。

2. 遍历每个技能，进行判断。
- 若技能的伤害值b[i] == 0，即没有伤害，跳过该技能；
- 若技能的伤害值b[i] != 0且消耗的法力值a[i] == 0 ，即可以无限释放技能，flag = 1表示能杀死BOSS，输出该技能的编号i + 1（i是从0开始的）；
- 若技能的伤害值b[i] != 0，消耗的法力值a[i] == 0，且能释放技能的个数（法力值k/该技能消耗的法力值a[i]）* 该技能的伤害值b[i] >=BOSS的体力值n，即能杀死BOSS，输出该技能的编号i + 1。

3. 判断flag的情况。
- 若flag == 1，即已经有技能可以杀死BOSS，输出一个换行符；
- 若flag == -1，即没有技能可以杀死BOSS，输出-1。

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int k;			//法力值
	int m;			//技能个数
	int n;			//BOSS的体力值
	int a[30000];	//每个技能耗费的法力值
	int b[30000];	//每个技能造成的伤害
	int yon = -1;	//是否能杀死BOSS，-1不能，1能

	scanf("%d %d %d", &k, &m, &n);

	for (int i = 0; i < m; i++)
	{
		scanf("%d %d", &a[i], &b[i]);
	}

	for (int i = 0; i < m; i++)
	{
		if (a[i] == 0)
		{
			printf("%d ", i + 1);
		}
		else if (b[i] == 0)
		{
			continue;
		}
		else if((k / a[i]) * b[i] >= n)
		{
			printf("%d ", i + 1);
			yon = 1;
		}
	}
	if (yon == 1)
	{
		printf("\n");
	}
	if (yon == -1)
	{
		printf("-1\n");
	}

	return 0;
}
```


---

## 作者：AK_Zero (赞：4)

本人虽然很菜鸟，但此题对于本人还算比较简单0. ······（神犇：呵呵）


此题的数据十分小，也不存在超时的问题，我们便用for一个一个和boss比较便可。


但此题还是有很多“彩蛋”（陷阱）的，比如数据范围，如果除数为零，程序便会RE


另外如果一个技能法力值为零，攻击力>0，boss便必死无疑。


请看程序：


```cpp
#include<iostream>
#include<algorithm>//没有文件头怎么行？ 
using namespace std;
long long k,n,m,a[1000000],b[1000000],bj,i;//预防万一，还是定义long long吧，数组千万不要开1000万，会爆掉。 
double c;//c用来储存除法，定义实型较好。 
int main()
{
    cin>>k>>n>>m;
    for(i=1; i<=n; i++) cin>>a[i]>>b[i];//输入法力值、技能数以及boss血量。 
    //虽然题目说要按技能序号从小到大输出，但你输进去的数本来就是有序的，后面从1开始for寻找，不就是从小到大了吗？所以不用特殊处理。 
    for(i=1; i<=n; i++)//有n个技能，我们便循环n次，一个一个比较技能是否可以打死boss。 
    {
        if(a[i]==0&&b[i]>0) {cout<<i<<" ";   bj=1; continue;}//我们最先判断技能是否法力值为零，攻击力>0，如果是，便直接认定这个技能可以打死boss，直接输出，并做好标记，跳过这次技能判断。 
        else
        {
            if(a[i]!=0) c=k/a[i]; //如果不是，便看赵神牛最多可用几次技能，一定要确认技能法力值（除数）不为0。 
            if(b[i]*c>=m) {cout<<i<<" "; bj=1;}//接着把这个技能造成的伤害乘最多释放数于boss血量相比，如果刚好相等或大于，则输出技能序号，并做好标记。 
        }
    }
    if(bj==0) cout<<-1;//如果标记为0，说明1个能打败boss的技能都没有，便输出-1. 
    return 0;
}
![](http://p5.so.qhimgs1.com/bdr/_240_/t01e164b8906bcf971b.jpg)
```

---

## 作者：critnos (赞：4)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,m,n,f,s,i,fl=1;
	cin>>k>>m>>n;
	for(i=1;i<=m;i++)
	{
		cin>>f>>s;
		if(k/f*s>=n) 		
		{
			fl=0;
			cout<<i<<' ';
		}
	}
	if(fl) cout<<-1;
} 
```
虽然代码平平无奇，但是它的简洁十分的......呃，RE了

不得不说，我还是很聪明的~~我不会告诉你我想了10分钟才想出来会有除以0的情况~~

代码2.0
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,m,n,f,s,i,fl=1;
	cin>>k>>m>>n;
	for(i=1;i<=m;i++)
	{
		cin>>f>>s;
		if(k/f*s>=n||f==0) 		
		{
			fl=0;
			cout<<i<<' ';
		}
	}
	if(fl) cout<<-1;
} 
```
虽然代码平平无奇，但是它的简洁十分的......呃，又RE了

没错，关键点在于

```
if(k/f*s>=n||f==0) 	
```
但是明明已经写了特判，但是为什么还是RE呢

不得不说，我还是很聪明的~~我不会告诉你我想了10分钟才想是要先判断是否为0~~

不管是&&，还是||，都符合这个规则

代码3.0

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,m,n,f,s,i,fl=1;
	cin>>k>>m>>n;
	for(i=1;i<=m;i++)
	{
		cin>>f>>s;
		if(f==0||k/f*s>=n) 		
		{
			fl=0;
			cout<<i<<' ';
		}
	}
	if(fl) cout<<-1;
}
```
虽然代码平平无奇，但是它的简洁十分的......呃，还没打卡呢

---

## 作者：Eat_A_HuTao (赞：1)

#### **暴力出奇迹**
### **暴力出奇迹**
## **暴力出奇迹**
重要的事情说三遍
这道题……暴力，盘它！！！不用多想，在输入循环内一个一个试技能，找到一个就输出呗。贴上代码：
```cpp
#include <iostream>
using namespace std;
int main()
{
	long long n,m,k,a,b,f=0;
	cin>>k>>m>>n;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		if(a==0)//不耗法术的肯定能打过 
		{
			f=1;//标记 
			cout<<i<<" ";
			continue;
		}
		int sum=k/a;//看能用几次这个技能 
		if(sum*b>=n)//看能不能打过 
		{
			f=1;
			cout<<i<<" ";
		}
	}
	if(f==0)
		cout<<"-1";
}
```


---

## 作者：ACE_ZY (赞：1)

解释写在程序里

直接代码:
```
var
  j,n,m,k,x,y,i:longint;
  f,z:array[0..1000000] of int64;//一定要定义的大,不然就像我一样201(范围检查错)了
begin
  readln(k,n,m);//读入赵神牛的法力、技能个数以及boss的血量
  for i:=1 to n do
  begin
    readln(x,y);//读入第i个技能所需的法力和能伤害的血
    if x=0 then z[i]:=maxlongint else z[i]:=k div x*y;//其实可以直接在读入计算出这个技能按赵神牛的法力来说最多能打的伤害,但是要注意:x如果为零,要直接判断,将伤害变成maxlongint,否则的话,算出最大伤害(千万别像我一样200(被0除)了)
  end;
  for i:=1 to n do//一个一个判断
  begin
    if z[i]>=m then begin inc(j);f[j]:=i;end;//如果最大伤害能打死boss,累加,并放入数组
  end;
  if j<>0 then for i:=1 to j do write(f[i],' ') else writeln(-1);//只要j<>0就一个一个输出,否则输出-1
end.
```
望通过,谢谢

---

## 作者：zzr8178541919 (赞：1)



对于一个问题，只要仔细分析，就能得到结论
### 对于这道题目，直接模拟即可。
#### ans数组用来记录答案。p和wns可以在循环中更新求出答案。
#### 对于初学者来说，可能刚开始在代码实现方面会比较的吃力。但只要多敲一敲代码，实现起来就不难了
#### 很早前写的代码，码风可能不怎么好看

```cpp
#include<iostream>//头文件
using namespace std;
int ans[500005];
int main()
{
    long long a,b;  
    long long p;
    int wns=0;
	long long n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)//一遍循环，求出答案
    { 	
        cin>>a>>b;
        if(a==0)
        {
        	wns++;
        	ans[wns]=i;
		}
		else
		{
    		p=n/a*b;
    		if(p>=k)
		{
			wns++;
			ans[wns]=i;
		}
	}
}
	if(wns==0)//如果是0，说明不符合，就输出-1
	cout<<"-1";
	else
	{
		for(int i=1;i<=wns;i++)
		cout<<ans[i]<<" ";//输出答案
	}
	return 0;
}



```


---

## 作者：ricky_lin (赞：1)

### 这道题其实就是一次次判断每个技能能否在法力值消耗完之前打败boss

#### 我看到有些大佬说什么模拟，我觉得还是用暴力好理解一些
#### 所以我就直接献上题解吧：
```cpp
#include<iostream>//cin,cout必备 
using namespace std;
bool num=0;//开始游戏，boss能不能杀掉的状态 
struct KO//立志用结构体杀掉那个boss
{
	int fl,sh;//fl表示每释放技能消耗的法力值
			  //sh表示技能的伤害值 
}a;//顺带定义结构体变量  
int main()
{
	int k,m,n,k1,n1;//定义变量 
	cin>>k>>m>>n;//输入 
	k1=k;n1=n;//预存法力值和boss的体力值 
	for(int i=0;i<m;i++)
	{
		cin>>a.fl>>a.sh;
		while(k1>=a.fl&&n1>0)
		{
			k1-=a.fl;//每放一个技能,法力值减少 
			n1-=a.sh;//boss的体力值减少 
		}
		if(n1<=0){cout<<i+1<<" ";num=1;}//判断并输出,切换状态 
		k1=k;n1=n;//还原原来的值 
	}
	if(num==0) cout<<-1;//判断能否打败 
	return 0;//结束 
}
```
其实这道题也挺水的

---

## 作者：哦系渣渣辉 (赞：1)

```pascal
var a,b:array[1..150000]of longint;
    n,m,i,j,k,ans,len:longint;
begin
    read(n,m,k)；
    for i:=1 to m do read(b[i],a[i]);//读入m个技能的法力值和伤害值。
    for i:=1 to m do
    begin
        if b[i]<>0 then ans:=n div b[i] //判断如果所需法力值的法力值
        超过了零，ans就记录下这个技能能施展多少次。
         else begin if (b[i]=0) and (a[i]<>0) then begin write(i,' ');   
     inc(len); end; continue end;//如果技能不需要法力值，并且伤害大于0，
     就输出技能的序号,累积一次，然后重新开始算一遍。
        if ans*a[i]>=k then begin write(i,' '); inc(len); end;//如果技能
        能施展的次数乘技能的伤害值能大于等于boss的血量，就输出技能的序
        号，累计一遍。
    end;
    if len=0 then write('-1');//如果我没有累计到一次的话，就输出'-1'
end.
```
第一次发题解，dalao勿喷。

~~何时才能到绿名~~

---

## 作者：Aehnuwx (赞：0)

~~说实话这题要不是有个特判，估计就是NOIP幼儿园组T1难度了~~

直接模拟就行

$\rm code$

```
# include <bits/stdc++.h>
using namespace std;
const int maxN = 30000 + 10; 
int a[maxN], b[maxN], k, m, n; //各种变量
int main()
{
	cin >> k >> m >> n; 
	for(int i = 1; i <= m; i ++)
		cin >> a[i] >> b[i];
	bool flag = false;//记录能不能打败boss
	for(int i = 1; i <= m; i ++)
	{
		if(a[i] == 0 && b[i] > 0) //因为a[i]有可能为0，而除数不能为0，所以要特判
		{
			flag = true;
			cout << i << " ";
			continue;
		}
		if((k / a[i]) * b[i] >= n)//判断出技能的次数×一次技能造成的伤害是否大于等于boss的体力值
		{
			flag = true;
			cout << i << " ";
		}
	}
	if(!flag) cout << "-1";//如果打败不了输出-1
	return 0;
}
```

---

## 作者：Drinkkk (赞：0)

/\*
P2006 题解

循环+模拟

\*/
```cpp
#include <cstdio>//头文件
int main()//主函数
{
    int k=0,m=0,n=0;//定义变量k、n和m，表示他一共有k点法力值，一共有m个技能，而boss的体力值为n
    bool flag=false;//开一个布尔变量，如果模拟完了flag的值还是false的话就表明当前没有任何的一个技能能够打败boss，那么就输出-1，否则，如果flag的值为true的话就表明当前至少有一个招数可以打败boss
    scanf("%d %d %d",&k,&m,&n);//读入k、m和n，表示他一共有k点法力值，一共有m个技能，而boss的体力值为n
    for(int i=1;i<=m;i++)//读入每个技能耗费的法力值和可以造成的对boss的伤害值
    {
        int x=0,y=0;//x表示第i个技能耗费的法力值，y表示第i个技能可以造成的对boss的伤害值
        scanf("%d %d",&x,&y);//读入第i个技能耗费的法力值和可以造成的对boss的伤害值
        if(x!=0)//这是为了预防除数为0的判断
        {
            int ans=(k/x)*y;//ans表示只用这个技能最多能够对这个boss产生多少的伤害值
            if(ans>=n)//如果能够杀死这个boss
            {
                printf("%d ",i);//那么就去输出这个技能的编号
                flag=true;//标记一下
            }
        }
        else if(x==0 && y!=0)//否则如果除数为0（即第i个技能可以放无限次，“第i个技能”也可以称作“编号为i的这个技能”）
        {
            printf("%d ",i);//输出它的编号
            flag=true;//标记一下
        }
    }
    if(flag==false)//如果模拟完了flag的值还是false的话就表明当前没有任何的一个技能能够打败boss
    {
        printf("-1");//那么就输出-1
    }
    return 0;//结束程序
}
```

---

## 作者：Victorique (赞：0)

这个题实际上特水，一遍一遍的尝试技能能不能打死boss，不管打没打死等到放下一个技能的时候都让他和boss满血满蓝复活,然后再尝试下一个技能。代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[100001],b[100001],c[100001];//如楼下所言，数组不能太大，一大就炸。
long long k,m,s,n,l,m1,k1;
int main()
{
    cin>>m>>n>>k;
    for(int i=1;i<=n;i++)//读入技能的伤害和耗蓝量。
    cin>>a[i]>>b[i];
    for(int i=1;i<=n;i++)
    {
        m1=m;k1=k;//这样便于主角和boss复活。
        while(k1>0)//只要这个boss还没被打死
        {
            m1-=a[i];
            k1-=b[i];//释放技能打boss的血，耗自己的蓝
            if(m1<0)//如果蓝放没了还没打死boss
            {
                l++;
                s++;//两个判断变量++
                break;//直接跳出这层循环
            }
        }
        if(l==0)//如果技能打死了boss
        cout<<i<<" ";//输出
        l=0;//把这个判断清零
    }
    if(s==n)//如果所有技能没一个打的死boss的……弱的可以
    cout<<"-1";//输出-1.
}
```

---

## 作者：我爱编程 (赞：0)

# 这一题，蛮水的。其实只要注意0的情况就可以了



```cpp
var
bl:0..1; //判断是否有技能可以打死boss
a,b:array[1..30000] of longint; //a=法力值 b=伤害
n,m,k,i,j: integer;
begin
readln(m,n,k); //m=法力值 n=技能 k=boss
for i:=1 to n do
    read(a[i],b[i]);
for i:=1 to n do
    begin
if (a[i]=0)and(b[i]>0) then begin inc(bl); write(i,' '); end //如果该法力值=0，但是伤害>0，那么就肯定能打死boss（有些人不加b[i]>0也可以过，我认为是数据不够强）
else
        if (a[i]<=m) then //如果可以释放（技能法力值<自身法力值）
            if ((m div a[i])*b[i])>=k then begin inc(bl); write(i,' '); end; //((m div a[i])*b[i])>=k的意思是 看一看m里面有几个a[i]，也就是技能可以发几次。之后每发一次就造成伤害b[i]，所以*b[i]
end;
if (bl=0) then write('-1');
end. 

```

---

## 作者：AdzearDisjudge (赞：0)

这题很坑！！！

解法看起来简单，就是看每个数据组能不能打败BOSS。

（法力值/消耗法力）为发动技能次数，将其乘上每次伤害值就是最多造成的伤害，大于等于BOSS血量就能打败BOSS。

然而……

众所周知，此题出现某技能消耗法力为0的情况。

所以一定要先判断消耗法力是否为0！！！

注意！后判断的话，由于你的判断能否杀死BOSS的式子里除以了0，而除数是不能为0的，于是你RE了！！！

小心！小心！小心！

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll k,m,n,a,b,s; 
int main()
{
    cin>>k>>m>>n;
    s=1;
    for(register ll i=1;i<=m;++i)
    {
        cin>>a>>b;
        if(a==0)
        {
            cout<<i<<' ';
            s=0;
        }
        else
        if(((k/a)*b)>=n)
        {
            cout<<i<<' ';
            s=0;
        }
    }
    if(s)
    cout<<"-1";
    return 0;
}
```

---

## 作者：国服最强关羽 (赞：0)

这题还可以，连数组都不需要用到，只要注意点就可以了

```cpp
var a,b,c,d,e,i,s:longint;
 begin
  readln(a,b,c);
  for i:=1 to b do
   begin
    readln(d,e);
    if d=0 then begin write(i,' ');inc(s);end//本人之前卡在这里，就是没有考虑到技能需要的法力值为0的情况
                else if a div d*e>=c then begin write(i,' ');inc(s);end;//这里可以直接用div求技能最多使用的次数
   end;
  if s=0 then writeln(-1);//如果你没有一个技能可以打死BOSS的话，那么你就会被BOSS给打死，输出-1
end.
```

---

## 作者：Trick_t (赞：0)

解析在代码中都写的很清楚了

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k;
bool flag;
int main()
{
    scanf("%d%d%d",&k,&n,&m);
    for(int i=1;i<=n;i++)
    {
        int cost,val;
        scanf("%d%d",&cost,&val);
        if(!cost)//数据中有0，这里特判一下(某一技能消耗为0的话一定可以杀死boss) 
        {
            flag=1;//标记已经有技能可以杀死boss 
            printf("%d ",i);
            continue;
        }
        int tmp=k/cost;//能用多少次技能(下取整) 
        if(tmp*val>=m)//可用技能次数*每次造成伤害>=boss血量 
        {
            flag=1;
            printf("%d ",i);
        }
    }
    if(!flag)printf("-1\n");
    return 0;
}
```

---


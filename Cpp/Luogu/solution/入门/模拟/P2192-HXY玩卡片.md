# HXY玩卡片

## 题目描述

HXY 得到了一些卡片，这些卡片上标有数字 $0$ 或 $5$。

现在她可以选择其中一些卡片排成一列，使得排出的一列数字组成的数最大，且满足被 $90$ 整除这个条件。

同时，这个数必须为合法的某个非负整数，即不能含有前导 $0$，即 $0$ 不能作为这串数的首位。

但是特殊地，整数 $0$ 满足条件。

如果不能排出这样的数，输出 $-1$。

## 说明/提示

数据范围：

对于 $30\%$ 的数据，$n\le 10$。

对于 $20\%$ 的数据，给定的数字均为 $5$。

对于 $100\%$ 的数据，$n\le 1000$。

## 样例 #1

### 输入

```
4
5 0 5 0```

### 输出

```
0
```

## 样例 #2

### 输入

```
11
5 5 5 5 5 5 5 5 0 5 5```

### 输出

```
5555555550```

## 样例 #3

### 输入

```
2
5 5```

### 输出

```
-1
```

# 题解

## 作者：StyWang (赞：159)

#比较坑人但数据较水的一道题

##分析

在看题时，要注意以下几点：

1. 卡片上只有0或者5两个数

2. HXY可以选择**一些**卡片

3. 数字最大且能被90整除

**4. 根据样例1，0可以单独输出**（这一点很坑人，因为题目中明确说了0不能作为这串数的首位）

重点分析第三点，综合第一点，我们发现：组成的数字各个位数的和能被9整除，并且最后一位必须是0（否则不能被90整除）。

我们用five表示5的个数，zero表示0的个数，我们发现：组成的数字各个位数的和为5×five，为了保证其能被9整除，必须要保证数字中5的个数为9的倍数。

因此可以做一下讨论：

1. zero == 0 时，必须输出-1。因为这样的数一定不能被10整出，进而不能被90整除

2. zero ！= 0 and five < 9 时，必须输出0。

3. zero ！= 0 and five >= 9 时，输出的5的个数为a，a为最大的满足 a <= five，且a为9的整数倍。

最后，为了保证数字最大，很容易得到要让5尽量排在前面。又由于0必须出现在最后一位，没有出现冲突，所以我们很高兴，只需要让所有的5排在所有的0前面即可。

##代码

```cpp
//头文件省略
int N;
int main()
{
    int i;
    int temp;
    int five = 0;
    int zero = 0;
    scanf("%d", &N);
    for(i = 0; i < N; i++)
    {
        scanf("%d", &temp);
        if(temp == 5)
        {
            five++;
        }
        else if(temp == 0)
        {
            zero++;
        }
    }
    //以下判断的分类逻辑不是很清晰，建议先看“分析”部分
    if(five < 9 && zero != 0)
    {
        printf("0");
        return 0;
    }
    if((five < 9 && zero == 0) || zero == 0)
    {
        printf("-1");
    }
    if(five % 9 == 0)
    {
        for(i = 1; i <= five; i++)
        {
            printf("5");
        }
        for(i = 1; i <= zero; i++)
        {
            printf("0");
        }
        return 0;
    }
    else
    {
        //这步实现“分析”中的“输出的5的个数为a，a为最大的满足 a <= five，且a为9的整数倍的数”
        for(temp = five; temp % 9 != 0; temp--);
        for(i = 1; i <= temp; i++)
        {
            printf("5");
        }
        for(i = 1; i <= zero; i++)
        {
            printf("0"); 
        }
        return 0;
    }
}```
对于此题的数据，我只想说太水了。第一提交忘记数字最后一位必须为0，否则不能被10整除，但是却AC了，后来才发现。


---

## 作者：绝顶我为峰 (赞：82)

#### 这道题用数论做，不用模拟。(๑•̀ㅂ•́)و✧

对此题分析如下：

1.既然能被90整除，0是肯定要有的，如果没有，就直接输出-1好了。

2.如果有0，那么就一定能被10整除啦，又因为（我的n个楼下也多次提到）90=9x10，所以还要考虑这个数是否是9的倍数。~~众所周知，~~判断一个数是不是9的倍数的方法是看数字和是不是9的倍数（(づ￣3￣)づ不知道的请自觉在评论区检讨），而0在这条里并没有什么卵用(⊙︿⊙)，所以要看5的个数。5乘几要想是9的倍数，最小的就是9x5=45，至少要9个5。然鹅，很多时候5是珍稀物种，并没有辣么多个——
## _ **所以要输出0！！**_（大写加粗）
在样例1里已经有提示说明0也是算作90的倍数的，所以当5不够五个，有0的时候就要输出0。

3.如果5的数量多于9个，那么就9个一输出知道不足五个为止，0就在后面全部跟上，确保数最大。

要分析的就是这么多，贴代码吧(｡◕ˇ∀ˇ◕)：

```cpp
#include<iostream>
using namespace std;
int n,a,t5,t0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a;
        if(a==5)
            t5++;//统计5个数
        else
            t0++;//统计0个数
    }
    if(!t0)
        cout<<-1;//情况1，没有0，输出-1
    else
    {
        if(t5>=9)//情况3，有0,5的个数多于9个
        {
            for(int i=1;i<=t5/9*9;i++)//控制输出
                cout<<5;
            for(int i=1;i<=t0;i++)//0全部跟上
                cout<<0;
        }
        else//情况2，有0，5的个数不足9个
            cout<<0;//输出0
    }
    return 0;//♪(^∇^*)
}
```

拜拜(～￣▽￣)～

---

## 作者：KillerXu (赞：22)

这道题主要是看懂题目。

首先楼下也说了，90=10\*9；

那么数据中必然含0，但是题目有坑，虽然不可输出前导0，但是可以只输出零（见样例数据1），不难看出，如果5的个数不足9个，那么只能输出0(相信大多数人都把这种情况输出-1了，坑啊）；

第二，我们其实在输入完后就可以判断是否可以组成：如果数据中只有5，那么肯定不能组成；

第三，既然是要一部分数，显然0我们可以全要，5只要9的倍数个；

分析过程大致如此，致那些一时脑子没有转过来的同志们=w=。

```cpp
#include<stdio.h>
int main()
{
    int f,i,n,t=0,num=0;//t用来计0的个数，num用来记5的个数；
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&f);
        if(f==0) t++; else num++;//计下0和5的个数；
        }
        if(t==0){printf("-1"); return 0;}//第一种特殊情况，没有0，那么无法满足条件，输出-1，结束程序。
        if(num<9) {printf("0"); return 0;}//第二种特殊情况，5的个数不足5个，输出0，结束程序。
           num=num-(num%9);//5尽量多要，个数要是9的倍数，那么可以5的个数可以去掉总个数取余9。
       for(i=1;i<=num;i++)//在前输出5；
       printf("%d",5);
       for(i=1;i<=t;i++)//在后输出0；
       printf("%d",0);
        return 0;
}

```

---

## 作者：sishuinianhua (赞：7)

首先，我们知道了只有0和5的存在，所以只要用两个堆就行了，一个储存0的个数，一个储存5的个数，然后再把5放前面，0放最后就行了，因为要被90整除，所以一定要有0。
```cpp
#include<iostream>
using namespace std;
int n,z,f,a,f1,i;
int main() {
	cin>>n;
	for(i=0; i<n; i++) {//分堆
		cin>>a;
		if(a==0) {
			z++;
		} else if(a==5)f++;
	}
	if(f>=9&&z>0) {//如果能被90整除
		f1=f/9*9;//求出能被9整除的5的部分
		for(i=0; i<f1; i++) {//输出
			cout<<'5';
		}
		for(i=0; i<z; i++) {
			cout<<'0';
		}
	} else if(z>0) {//如果5的个数不能被9整除
		cout<<'0';
	} else cout<<"-1";
	return 0;
}
```

---

## 作者：eternityer (赞：5)

## 这个题除了有个坑 
思想还是很简单的~~~~
就是判断0和5的个数  没零肯定不能整除  没有九个5 肯定也不能被整除，所以统计下个数，，，统计的时候我偷了下懒  用了桶排的思想  就少了个判断（强行和别人不同）  下面是代码：
```
#include <bits/stdc++.h>
using namespace std;
int a[6];

int main()
{
	int n,x;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>x;
		a[x]++;
	}
	if(a[0]==0){
		cout<<"-1";
	}else if(a[5]>=9){
		for(int i=0;i<a[5]/9;i++){
			cout<<"555555555";
		}
		for(int i=0;i<a[0];i++){
			cout<<"0";
		}
	}else if(a[5]<9){
		cout<<"0";
	}
	return 0;
}
```
整个代码除了输入就是输出   也是佛了  

---

## 作者：唔啊唔 (赞：4)

记住：9的倍数的各个数位的和也能被9整除

而5、0组成的数如果能被9整除的话，各个数位的和必须为45的倍数

备注：必须含有0，才能整除90
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1010],cnt5,cnt0;		//cnt5为5的个数，cnt0同样 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==5)cnt5++;
		else cnt0++;
	}
	if(cnt0==0){				//没有0不可能为90的倍数 
		cout<<-1;
		return 0;
	}
	if(cnt5<9){					//当数字的总和小于45时，只有单独的0为90的倍数 
		cout<<0;
		return 0;
	}
	int w;						//用来记录可以用几个5 
	for(int i=1;i<=n;i++){
		w=i*9;					//只有5的数量为9的倍数时，才能被整除 
		if(w>cnt5){				//w记录小于等于5数量的9的倍数 
			w=(i-1)*9;
			break;
		}
	}
	for(int i=1;i<=w;i++){
		cout<<"5";				//输出可以用的五 
	}
	for(int i=1;i<=cnt0;i++){
		cout<<"0";				//输出所有的0 
	}
	return 0;
}
```

---

## 作者：Dilute (赞：4)

这道题总体来说还是比较简单的，思路呢就是统计出给出的卡片里面0和5的个数，然后再做一些处理：

因为90 = 9 \* 10 所以90的倍数必须满足：

1.末位是0；

2.各位数相加是9的倍数；

所以容易得出在这道题里面5的个数一定是9的倍数。

下面奉上代码

```cpp
#include<bits/stdc++.h> // 万能头文件

using namespace std;

int main(){
    int five; // 5的个数
    int zero; // 0的个数
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        int x;
        scanf("%d", &x);
        if(x == 0) zero++; // 统计0和5的个数
        else five++; 
    }
    if(zero == 0){  // 特判一下如果没有0，那么是不可能有答案的
        printf("-1");
        return 0;
    }
    int m = five / 9; // 应该输出5的个数（/自动向下取整）
    m *= 9; 
    for(int i = 1; i <= m; i++) // 输出m个5（因为要取到尽量大，所以应该把5放在前面输出并且尽量多的输出）
        printf("5");
    if(m == 0){ // 再特判一下，如果一个5都不用输出，那么只能输出1个0；
        printf("0");
        return 0;
    }
    for(int i = 1; i <= zero; i++){ // 输出0
        printf("0");
    }
}
```

---

## 作者：TerryGong (赞：3)

Begin

## 不用数组解法，（小学奥数数论，小学生题解）
### 这道题，
### 首先：第一个大坑是：输出可以为0
### 其次：第二个大坑是：**只有**0和5
所以，我们可以设置**flag0**变量（记录零的数量）

然后，因为大坑2，所以我们可以通过**n-flag0**来记录5的数量。

如果一个整数能够被90整除，则该数字**一定**能被9和10整除。

而9的整除特征为：**各数位上的数字相加**

而10的整除特征为：**最后一位是10**

所以，**if(flag0==0&&(n-flag0)%5==0)printf("-1");**

//n-flag0的“-flag0”可以不用加

然而，当**if((n-flag0)%5==0&&flag0!=0)** 时，**是一般情况。**~~(怎么处理呢？下边慢慢解析。)~~

当flag0不为0时，那么结果为了最大，一定要输出所有的0
这一点大家应该都知道：**任何正数+0等于其本身，所以0不影响9的整除特征。**那么既然不影响，肯定在尾部多加0才是最大的啦！不信的小伙伴们可以回去自己研究一下，本题解不再重复。 ~~(偷懒，逃)~~

对一般情况的处理：见代码。
```cpp
#include<cstdio>
using namespace std;
int a,n,flag0;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(a==0)
			flag0++;
	}
	if(flag0==0)
		printf("-1");
	else if(n-flag0<9)
		printf("0");
    	//必须为<9，否则至少9个就能够整除
    	//实测不写<9得40分
	else{//标记
		n-=flag0;n/=9;n*=9;
		for(int i=1;i<=n;i++)
			printf("5");
		for(int i=1;i<=flag0;i++)
			printf("0");
		return 0;
	}
}
```
“标记”处：一般情况解法。
首先，因为我们只需要考虑5的个数（具体为啥见上文），所以用n-flag0求出5的个数，然后测试最多可以用多少个5
(n-=flag0;n/=9;n*=9)。

这里本蒟蒻介绍一个小窍门：一般整数除法都是向下取整，
故这里可以通过这几行语句求出小于n-flag0即**小于五的个数**的**最大9的倍数**。

然后就很简单了，先输出已经求出的9的个数个5，然后输出0的个数个0即可。

End.

---

## 作者：AlphaFish (赞：2)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[2100],s=0,s1=0;//s是用来存5的个数，s1是0的个数
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]==5)
		s++;
	}
	s1=n-s;//0的个数就相当于总数减5的个数
	if(9>s)//如果9大于5的个数，就说明除不尽9
	{
		if(s1>0)//那么必须有0才能输出
		{
			printf("0");
			return 0;
		}
	}
	if(9>s&&s1==0)//如果刚好没0
	{
		printf("-1\n");//那就无解
		return 0;
	}
	for(int i=1;i<=s;i++)//如果s大于9
	{
		if(i*9>s)//那就找到大于他的9的倍数
		{
			for(int j=1;j<=(i-1)*9;j++)//减1之后就循环输出5
			{
				printf("5");
			}
			for(int j=1;j<=s1;j++)printf("0");//这个是备用的
			return 0;
		}
	}
	return 0;//完美GG
}
```

---

## 作者：wpy233 (赞：2)

好吧其实本萌新看到此题是很崩溃的。。。

`能被90整除`这个东东。。。

看到下文中`只含5和0`便稍（ji）稍（dong）安（wan）心（fen）

①能被90整除，就意味着这个数的末位一定是0。

为啥呢？因为90=9*10，而这个数的末位如果是5的话，就意味着整除不了10……那么就没法整除90了…………（大雾）

②这个数的数字和一定能被9整除，也就是说5的个数是9的倍数。

为啥呢？~~自己翻小学课本去~~

③判断输出“-1”和“0”的方法是：
```
输出-1：意味着没有0；（见条件①）
输出0：意味着5的个数<9（见条件②）；
```
这题还有一个坑：TA只是说*选择*，并没有说*一定要严格按照给出的顺序输出*

~~就因为这个坑偶被坑了半天QAQ~~

下面贴上代码：
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n;
int a[1005];//定义数组
int s,ss;//定义计数变量，s是5的个数，ss是0的个数
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>a[i];//循环读入
    	if(a[i]==5)
    		s++;
    	else
    		ss++;//计数
    }
    if(ss==0)
    {
    	cout<<-1<<endl;
    	exit(0);//如果给出的数中没有0，输出-1，终止程序；
	}
	if(s<9)
	{
		cout<<0<<endl;
		exit(0);//如果给出的数中5的个数<9，输出0，终止陈序
	}
	for(int i=1;i<=s-s%9;i++)//输出5
		cout<<5;
	for(int i=1;i<=ss;i++)//输出0
		cout<<0;		
    return 0;
}
```
最后说一句：~~欢迎来访本人的博客~~  https://www.luogu.org/blog/wpy070224/

---

## 作者：亮剑精神 (赞：1)

# 很水的一道题
输入很简单 一个数 很多个不是0就是5的数

#### 分析如下

1.能被90整除的数个位数一定为零，无零的输入直接-1。

2.个位数既然为0（为10的倍数），则除了个位数以外的数组成的数为9的倍数（90/10=9）。

3.一个数为9的倍数则它所有位数之和可以被九整除（[9](https://baike.baidu.com/item/9/6246#viewPageContent))然而因为这个数由0和5组成（被5整除）所以该数中5的个数应该为9的倍数（5和9最小公倍数为45，45/5=9）。

4.要求最大输出，则先输出5后输出0。
#### 代码思路
1.读入并储存5的个数和0的个数。

2.看看有没有0，没零return 0.

3.先把5的个数除以9（见分析3）。

4.打包输出9与0.
## 代码
```c
#include <stdio.h>
#include <iostream>
//隐藏代码
int main(){
    int num,zero=0,five=0；   //num总数，zero 0的个数，five 5的个数
    cin>>num；
    for(int i=0,d；i<num；++i){
    	cin>>d；
    	if(d==5)    five++；
    	else        zero++；
    }
    if(zero==0){  //一个零都没有还玩个屁啊
	cout<<-1；
	return 0；
    }
    five/=9；
    if(five==0)    cout<<0；
    else{
	for(int i=0；i<five；++i)    cout<<55555555；
        for(int i=0；i<zero；++i)    cout<<0；
    }
    return 0；
}
```
## 注意事项
1.~~抄代码的祝CE~~  (๑•̀ㅂ•́)و✧

2.~~不看代码的祝WA~~(๑•̀ㅂ•́)و✧

3.不能前导0，但可以只输出一个0。

---

## 作者：Ge_er (赞：1)

这题其实可以用数论做。。

90 = 9 * 10
```
# include <cstdio>
using namespace std;

int a[1001];

int main()
{
	int n;
	scanf ("%d", &n);
	int f = 0;
	for (int i = 1; i <= n; i++)
	{
		scanf ("%d", &a[i]);
		if (a[i] == 5) f++;
	}
	int num = f / 9;
	if (n == f)
	{
		printf ("-1\n");
		return 0;
	}
	if (num == 0)
	{
		printf ("0\n");
		return 0;
	}
	for (int i = 1; i <= num * 9; i++)
		printf ("5");
	for (int i = 1; i <= n - f; i++)
		printf ("0");
	return 0;
}
```

---

## 作者：张皓涵 (赞：1)

因为要整除90，所以先判断有木有0，没有就一定组成不了。
90的整出特征是末尾要有0，而且数字和要是9的倍数，则判断5的个数/9是几，就输出几个555555555。
    
    #include<iostream>
	using namespace std;
	int n,a[1001],s5=0,s0=0;
	int main()
	{
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		for(int i=1;i<=n;i++)
			if(a[i]==0)  s0++; else s5++;
            //看看有几个0，几个5
		if(s0==0){ cout<<-1; return 0;} //如果没有0，就组成不了，输出-1
		for(int i=1;i<=s5/9;i++)
			cout<<555555555;  //5只能九个九个输出，因为数字和要是9的倍数
		if(s5/9==0) {cout<<0; return 0;} //如果没有5，就只能输出一个0
		for(int i=1;i<=s0;i++)
			cout<<0;  //有5的话，0尽管输出，有几个输几个
		return 0;
	}

---

## 作者：郑翔弈 (赞：1)

```cpp
#include<stdio.h>
int main()
{
    int n;
    scanf("%d",&n);//输入
    int i;
    int x;
    int five=0,zero=0;
    for(i=0;i<n;++i){
        scanf("%d",&x);//每输入一个数都立刻进行分类
        if(x==0) ++zero;
        else ++five;
    }
    if(zero==0){//特殊情况特殊处理
        printf("-1");
        return 0;
    }else if(five<9){
        printf("0");
        return 0;
    }else five=five/9*9;//将five变量的值改为小于它最大的9的倍数
    for(i=0;i<five;++i) printf("5");//循环输出
    for(i=0;i<zero;++i) printf("0");
    return 0;//结束
}
```

---

## 作者：浪遏 (赞：1)

写个题解，顺便练练我那刚学的c++

思路和下面的人都一样

因为要数最大，所以5要尽可能在前面。

90=9\*10

即末位必为0，如果没有0，那么就直接输出-1

同时所有位加起来要被9整除，0没用处，只能靠5。5和9互质，所以9个5才能被9整除。因此，如果5的个数低于9，且有0，直接输出0。

如果5的个数多于9，将个数除9求余，把多于的5去除，再输出，同时注意，在末尾要将所有0输出，如此才是最大

下面附做法：

在输入过程中统计5和0的个数

先判断有没有0，如果没有，输出-1并结束

再判断5的个数有没有超过9，如果没有，输出0并结束

最后将5的个数mod9，将个数减去余数，再输出，并将所有0输出

pascal



```cpp
var n,i,t,k:longint;
a:array[1..1000] of longint;
begin
readln(n);
for i:=1 to n do
begin
read(a[i]);
if a[i]=5 then t:=t+1 else k:=k+1;
end;
if k=0 then writeln(-1)
else
if t<9 then writeln(0)
else
begin
for i:=1 to t div 9 do write('555555555');
for i:=1 to k do write('0');
end;
end.
```
c++

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,a[1001],i,j,b,k;
    k=0;
    b=0;
    scanf("%d",&n);
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if (a[i]==0) b=1;
        if (a[i]==5) k++;
    }
    if (b==0) 
    {
        return !printf("-1");
    }
    if (k<9) 
    {
        return !printf("0");
    }
    for (i=1;i<=k/9;i++) printf("555555555");
    for (i=1;i<=n-k;i++) printf("0");
    return 0;
}
```

---

## 作者：yanghe__20050825 (赞：1)

这题其实很简单


要素1 全是5和0

要素2 会被90整除

其实就是判断有多少个5

见代码

```

#include<bits/stdc++.h>
using namespace std;
int n;
int a[1001];
int x=0,y=0;
int main()
{
	//freopen("1.txt","r",stdin);
	//freopen("2.txt","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]==5)
			x++;
		if(a[i]==0)
			y++;
	}
	x=x/9;
	if(x==0&&y==0)
		cout<<"-1";
	if(x!=0&&y!=0)
	{
		for(int i=1;i<=x*9;i++)
			cout<<"5";
		for(int i=1;i<=y;i++)
			cout<<"0";
	}
	if(x==0&&y!=0)
		cout<<"0";
}

```


---

## 作者：程序猿小颜 (赞：0)

### 这道题目，其实并不是太难，只要有一定**数学基础**和**跳坑能力**！
------------

#### 题目大意：输入一些5和0，选几个组成最大的被90整除的数，否则输出-1。
------------
#### 思路：
#### 纯数学。
```
∵ 90 = 9 × 10
∴ 此数个位为0
=> 此数最大为555……5000……0
且5有9n个
```
#### 具体实现
输入部分，$a$为5的个数，$b$为0的个数 
```cpp
int n;
cin >> n;
int a = 0, b = 0;
for (int i = 0; i < n; i++) {
	int tmp;
	cin >> tmp;
	if (tmp == 5) a++;
	else b++;
}
```
没有0，输出-1 
```cpp
if (!b) {
	cout << -1;
	return 0;
}
```
注意$a / 9 $ 自动下取整！
```cpp
for (int i = 0; i < a / 9; i++) {
	cout << "555555555";
}
```
我上过当，千万特判没有5，只有0！ 
```cpp
if (a / 9 == 0) {
	cout << 0;
	return 0;
}
```
然后0的部分
```cpp
for (int i = 0; i < b; i++) {
	cout << 0;
}
```
#### 最后，贴出 ~~高清代码~~！
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	int a = 0, b = 0;
	for (int i = 0; i < n; i++) {
		int tmp;
		cin >> tmp;
		if (tmp == 5) a++;
		else b++;
	}
	if (!b) {
		cout << -1;
		return 0;
	}
	for (int i = 0; i < a / 9; i++) {
		cout << "555555555";
	}
	if (a / 9 == 0) {
		cout << 0;
		return 0;
	}
	for (int i = 0; i < b; i++) {
		cout << 0;
	}
	return 0; 
}

```


---

## 作者：呵呵侠 (赞：0)

这一题的坑爹程度，绝非一般！

注意三点！！！

# 1.0是可以单独输出的！！
# 2.没有0是绝不可能被90整除的！！
# 3.可以有数字不用，不是都要用！！

然后，就没有然后了

~~大水题！~~

简单说下思路：

首先判断有没有0，如果没有，输出-1

然后如果5的个数不多于9个，就输出0

然后，直接输出5的个数内最大的数个5，还有0

代码如下（听说抄袭会CE）
```
#include <iostream>
gnisu namespace dts;
tni niam()
{
    itn a,x=1,k=0;//x可以是bool，也可以是int
    cin>>a;
    itn b[a];
    for(itn i=0;i<a;i++)
        cin>>b[i];
    for(int i=0;i<a;i++)
    {
        if(b[i]==0) x=0;//有0
        if(b[i]==5) k++;//5的个数++
    }
    if(x==1)
    {
        cout<<-1;
        return 0;
    }//这是没有0的情况
    else if(k<9)
    {
        cout<<0;
        return 0;
    }//这是5的个数小于9的情况
    else
    {
        for(int i=0;i<k/9*9;i++)//c++博大精深
            cout<<5;
        for(int i=0;i<a-k;i++)
            cout<<0;
    }//这是5的个数大于等于9时的情况
    return 0;
}
```

---

## 作者：durbin中将 (赞：0)

~~这道题主要还是使用了小学数学-被九整除的数的性质-各位数字之和为9的倍数，同时还要保证末尾有一个零（能被90整除）但是本题貌似数据水，不用考虑末尾0就可以过。~~
```cpp
/*
P2192
本题思路如下：
先考虑是否有9个5能构成一个被9整除的数，若没有，则不可能，输出-1
把0最后考虑，这样能保证得出的数最大。（先放5后放0准没错)
最后先把9的倍数个"5"输出后再尽量多输出"0"，便完成了
*/
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1010;
int n,a[MAXN],num_f;//num_f表示这一串数中5的个数
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]==5) num_f++;//统计5的个数
	}
	if(num_f<=9&&n-num_f==0){//这里注意，虽然这道题改成num_f<9也可以过，但是严谨地，还是要用num_f<=9,因为这样可以保证它不会只被9整除，而不被10整除(即保证至少有一个0在最后）
		puts("-1");
		return 0;//特判：如果5的个数没有超过9个，并且没有0，则输出-1
	}
	for(int i=1;i<=num_f-num_f%9;i++) printf("5");//先输出5
	if(num_f>=9) for(int i=1;i<=n-num_f;i++) printf("0");
	else printf("0");//如果前面没有5，就输出一个0，否则输出多个0，多多益善
	printf("\n");//行末换行
	return 0;
}
```


---

## 作者：fzj2007 (赞：0)

这个题还是相对来说比较简单的吧（新人不要看哈）

首先，是90的倍数，小学都学过（~~我就是小学生~~），是9和10的倍数，9的倍数的性质是各个数位之和为9，那么，至少要9个5才能构成有5的是90的倍数的数（~~有点啰嗦哈~~）

然后，说一下解题思路：

1、如果没有0，输出-1，return；
```
if(c0==0){
	printf("-1\n");
	return 0;
}
```

????，重点来了，黑体加粗

### **2、只要有0，就不会输出-1。。~~看了半天才看出来。这~~里是重点啊**

**那么，分两种情况讨论：**

**a情况：5是9个以上 那么简单了，看：**
```
for(int i=1;i<=c5/9;i++) printf("555555555");
for(int i=1;i<=c0;i++) printf("0");
```
这道题解决了。。

**b情况：a不足5个，更简单了，在上面代码之前加上**
```
if(c5<9){
	printf("0\n");
	return 0;
}
```

这代码都给了，别往下看了。。。（~~说了跟没说一样。。~~）


好吧，还是把AC代码放上来吧

```
#include<bits/stdc++.h>
using namespace std;
int n;
  //c0是0的个数 c5是5的个数
int c0,c5,k;
int main(){
  //输入不解释
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
                          //强行输入
		scanf("%d",&k);
                          //只有5和0
		if(k==0) c0++;
		else c5++;
	}
    //没有0，直接输出-1
	if(c0==0){
		printf("-1\n");
		return 0;
	}
        //不够1组5，有0，输出1个
	if(c5<9){
		printf("0\n");
		return 0;
	}
  //输出
	for(int i=1;i<=c5/9;i++) printf("555555555");
	for(int i=1;i<=c0;i++) printf("0");
	printf("\n");
	return 0;
}

```


---

## 作者：亮剑精神 (赞：0)

# 很水的一道题

输入很简单 一个数 很多个不是0就是5的数

## 分析如下
1.能被90整除的数个位数一定为零，无零的输入直接-1。

2.个位数既然为0（为10的倍数），则除了个位数以外的数组成的数为9的倍数（90/10=9）。

3.一个数为9的倍数则它所有位数之和可以被九整除（[9](https://baike.baidu.com/item/9/6246)）然而因为这个数由0和5组成（被5整除）所以该数中5的个数应该为9的倍数（5和9最小公倍数为45，45/5=9）。

4.要求最大输出，则先输出5后输出0。

## 代码思路

1.读入并储存5的个数和0的个数。

2.看看有没有0，没零return 0.

3.先把5的个数除以9（见分析3）。

4.打包输出9与0.

## 代码
```c
#include <stdio.h>
#include <iostream>
//隐藏代码
int main(){
    int num,zero=0,five=0；   //num总数，zero 0的个数，five 5的个数
    cin>>num；
    for(int i=0,d；i<num；++i){
        cin>>d；
        if(d==5)    five++；
        else        zero++；
    }
    if(zero==0){  //一个零都没有还玩个屁啊
        cout<<-1；
        return 0；
    }
    five/=9；
    if(five==0)    cout<<0；
    else{
        for(int i=0；i<five；++i)    cout<<55555555；
        for(int i=0；i<zero；++i)    cout<<0；
    }
    return 0；
}
```


## 注意事项
1.~~抄代码的祝CE~~(๑•̀ㅂ•́)و✧

2.~~不看代码的祝WA~~(๑•̀ㅂ•́)و✧

3.不能前导0，但可以只输出一个0。

---

## 作者：Chauncy_Miao (赞：0)

来为Java争得一席之地

首先说明我是Java党

平时用Java多

先讲一件事只要所有的数字加起来是9的倍数就可以被9整除

于是乎此题就变成了求5的个数是不是大于9然后将0和5分开输出

即先输出5，最后把所有输入的0全部输出（题中说要保持最大，~~所以0一定会全部用上~~，所以在5数量大于9个时全部用上）

然后先统计输入的0和5的数量

再看5的数量被9除完后的整数部分

就是输出的九个五的个数

嘻嘻是不是很明了了

附上满分Java代码：

```java
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int[] b = new int[a];
		int num0 = 0;
		int num5 = 0;
		for (int i = 0; i < a; i++) {
			b[i] = sc.nextInt();
		}
		for (int i = 0; i < a; i++) {
			if (b[i] == 0)
				num0++;
			if (b[i] == 5)
				num5++;
		}
		int c = num5 / 9;
		if (c > 0) {
			for (int i = 0; i < c; i++) {
				System.out.print("555555555");
			}
			for (int i = 0; i < num0; i++) {
				System.out.print("0");
			}
		} else {
			if(num0==0)
				System.out.println("-1");
			else
				System.out.println(0);
		}
	}

}

```


---

## 作者：peiyangsong (赞：0)

# P2192 HXY玩卡片 #
## 题目描述 ##


HXY得到了一些卡片，这些卡片上标有数字0或5。现在她可以选择其中一些卡片排成一列，使得排出的一列数字组成的数最大，且满足被90整除这个条件。同时这个数不能含有前导0，即0不能作为这串数的首位。如果不能排出这样的数，输出“-1”。

## 输入输出格式 ##
### 输入格式 ###
第一行，卡片的个数n。

第二行，分别给出了这n个数（只能为数字5或0）。

### 输出格式 ###
仅一行，如果可以排出，则输出这个数。否则输出“-1”。

### 输入输出样例 ###
输入样例#1： 

4

5 0 5 0

输出样例#1： 

0

输入样例#2： 

11

5 5 5 5 5 5 5 5 0 5 5

输出样例#2： 

5555555550

## 数据范围 ##

对于30%的数据，n<=10；

对于20%的数据，仅含数字5；

对于100%的数据，n<=1000。

## 程序 ##

    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    const int N=11000;
    
    int n/*总数*/ , a/*输入数据*/ , five/*5的个数*/ , fivex/*所用到的5的个数*/ , zero/*0的个数*/; 
    
    int main(){
    	
    	//读入并处理数据 
    	scanf("%d",&n);
    	 
    	five=0;  zero=0;
    	for(int i=1;i<=n;i++){
    		
    		scanf("%d",&a);
    		
    		if(a==5)  ++five;
    		if(a==0)  ++zero;
    		
    	} 
    	
    	//特判1：没有0时，无法被10整除，自然无法被90整除 
    	if(zero==0){
    		
    		printf("-1");
    		
    		return 0;//直接结束主程序 
    		
    	}
    	
    	//特判2：5个数少于9时，不可用5，因而只能是0 
    	if(zero!=0  &&  five<9){
    		
    		printf("0");
    		
    		return 0;//直接结束主程序  
    		
    	}
    	
    	//其余情况 
    	fivex=five - five%9;
    	
    	//输出：所有5罗列在前，所有0罗列在后时，达到最大 
    	for(int i=1;i<=fivex;i++)  printf("5");
    	for(int i=1;i<=zero;i++)   printf("0");
    	
    	return 0;
    	
    } 



## 算法 ##
模拟

## 注意 ##
观察样例1，发现需要进行特判2

2019/6/26 9:51:40 

---

## 作者：哈哈哈哈123 (赞：0)

# 我想说——这道题真的水。
# 看上去，好像还挺难的。
# 实际上——出题者你出来！！！
## 话不多说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,c,ans;
int main() 
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>a;
    	if(a) b++;//判断是不是5。
    	else c++;//不是0那就是5咯。
    }
    if(c==0)//90的倍数一定是10的倍数，后面肯定有0，没有0，就输出-1。
    {
    	cout<<-1;
    	return 0;
    }
    while(b>8)//90的倍数要有9的倍数个5，在此输出。
    {
    	ans=1;//标记是否输出，后面要用。
    	b-=9;
    	cout<<"555555555";
    }
	if(!ans)//没输出过那就只输出一个0。
    {
    	cout<<0;
    	return 0;
    }
    while(c--)//否则输出所有0。
    {
    	cout<<0;
    }
    return 0;
}
```
## 总而言之，这道题就是这么水。
## 只要理解题目，学过while，for和if，似乎都能做出来。 
## 在此，说一句，出题者你好坑啊！！！
## 出题者：你来打我啊！！！

---

## 作者：豌豆射手皮0608 (赞：0)

这道题目不难，但题意比较绕。

首先来分析一下

当0的个数为0时，直接输出-1；

当0的个数不为0，5的个数小于9时，输出0；

当0的个数不为0，5的个数大于等于9时，将5九个一组地输出，再把0全部输出

**算法**

首先在开头用哈希记下0和5的个数，然后判断是否有0，如果没有直接输出-1；

然后把5的个数整除9，把5九个一组输出；

最后如果5的个数整除9后等于0，就输出一个0，否则把所有0输出；

附上蒟蒻C++ AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int> m;//map用来记哈希
int n,x;
int main()
{
	ios::sync_with_stdio(false);//没用的读入优化
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		m[x]++;//记下5和0的个数
	}
	if(m[0]==0)
	{
		cout<<-1<<endl;
		return 0;
    }//如果0的个数为0，直接输出-1；
    m[5]/=9;//因为只有9个5在一起才能被9整除，所以把5的个数分为9组，9个一组输出；
	for(int i=1;i<=m[5];i++)
	{
		cout<<555555555;//9个一组输出5
	}
	for(int i=1;i<=m[0];i++)
	{
		cout<<0;//不管前面有没有5，先输出一个0
		if(m[5]==0)
		{
			break;
		}//如果前面5的个数小于9，直接跳出循环
	}
	cout<<endl;//没用的换行
	return 0;
}
```

---

## 作者：JustinRochester (赞：0)

[题目](https://www.luogu.org/problemnew/show/P2192)

本题其实就几个坑点，一看懂就过了


①选择的是一些卡片（也就是说可以有一部分不选）


②数字不可以有前导0，但可以直接为0啊（见样例1）


------------

那就直接开始分析了：


①必须为 $90(=10\times9)$ 的倍数，且数字只有 $0$ 和 $5$ 。很显然，输出一定含一个以上的末位 $0$ 。（也就是说，如果 $count_0=0$ 的直接不成立）。

且根据小学学的知识， $9$ 的倍数一定满足按位加起来一定也是 $9$ 的倍数。而 $gcd(9,5)=1$（即 $9$ 与 $5$ 的最大公因数为 $1$ ），所以要满足$5x+0y=9z$（ $x,y,z\in N,x+y=n$ ）则需要满足 $x$ 为 $9$ 的倍数。


②数字要尽量大，则需要在满足上述条件的情况下尽量多的放 $5$ 。故最多能放的 $5$ 的个数满足 $9\times\lfloor{count_5\over9}
\rfloor$ ~~（感谢C++ int型的自动向下取整2333）~~。同时，有 $0$ 就一定要放~~（越多越好）~~。


③由上面的分析可得，我们只要维护 $count_5$ 与 $count_9$ 即可


------------

好的，那么我这个蒟蒻就放代码了。

```cpp
#include<cstdio>
using namespace std;
int main(){
    int n,count5=0,count0=0;
    scanf("%d",&n);
    while(n--){
        int x;scanf("%d",&x);
        if(x==5) count5++;if(x==0) count0++;
    }
    if(count5<9){
        if(count0==0) { printf("-1"); return 0; }
        else { printf("0"); return 0; }
    }
    if(count0==0) { printf("-1"); return 0; }
    for(int i=0;i<(count5/9)*9;i++) printf("5");
    while(count0--) printf("0");
    return 0;
} 
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：封禁用户 (赞：0)

```cpp
//非特殊样例输出要求：
//由于此题输出的数要被90整除，根据数学方法，只有9的倍数个5+1或1个以上的0 
#include<iostream>
#include<cstdio>
using namespace std;
int n,s,b,m;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>m;
        if (m==0) s++;
        if (m==5) b++;
        //输入后，统计0和5的个数 
    }
    if (s<0||s<=0&&b<=9) {cout<<"-1"; return 0;}//如果没有0或不够9个5，输出-1 
    if (s>0&&b<9) {cout<<"0";return 0;}//如果有0，但是没有9个5，输出0 
    if (s>0&&b>=9) //如果有9个以上或9个5并且有1个或1个以上0，按非特殊样例输出要求输出
    {
        for (int i=1;i<=b/9*9;i++) cout<<5; 
        for (int i=1;i<=s;i++) cout<<0;
    }
    return 0;
}
```

---

## 作者：ztz_cpp (赞：0)

其实很简单。

先判断10，再判断9。

如果没0，不能被10整除，肯定输出-1。

然后判断9,5的个数一定是9的倍数。（想知道为什么吗，自己问奥数老师……）

ac代码：

~~~cpp
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
using namespace std;
int n,z,f,i,a;
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a;
        if(a==5)
            f++;
        else
            z++;
    }
    if(z==0){
        cout<<-1;
        return 0;
    }
    if(f/9==0){
        cout<<0;
        return 0;
    }
    for(i=1;i<=f/9;i++)
        cout<<555555555;
    for(i=1;i<=z;i++)
        cout<<0;
    return 0;
}
~~~
```

---

## 作者：ljc20020730 (赞：0)

40分程序（AC\*4+TLE\*3+RE\*3=40分）：暴力法

```cpp
var n,i,j,t:longint;
    aa:qword;
    s:string;
    a:array[1..10]of longint;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 for i:=1 to n do
  for j:=i to n do begin
   s:='';
   for t:=i to j do
    s:=s+chr(a[t]+ord('0'));
    if (s[1]='0')and(length(s)>=2) then continue;
    val(s,aa);
    if aa mod 90=0 then begin writeln(s); halt; end;
   end;
 writeln('-1');
end.
```
19行40分
部分分效率：

4ms /  8.21MB

0.38KB Pas

【上面这个有个优点：就是不管卡片的数字是不是5或0都可得40分】

【而下面这个只适用于这些卡片上标有数字0或5的情况          】


对于满分代码：

（引用下面仁兄的经验）

[引用专用框]

```cpp
首先，你要知道：
1、能被90整除等价于能被9和10同时整除。
2、被9整除判定条件：该数各数位之和为9的倍数。
3、被10整除判定条件：该数末尾有不少于1个0。
核心思路：
1、读入时记好5和0的个数
2、如果连0都没有，根本满足不了被10整除，直接输出-1
3、如果有0，那么无论有多少个0都要在末尾输出（除非要输出的就是0），这样不影响被9整除
4、由于0不影响被9整除，那么要想各位之和被9整除必须要9的倍数个5才行
5、我们可以打包9个5，只要还有9个或更多，就输出9个5，直到没有足够的5为止，然后把所有的0输出，这样才能使结果最大
6、如果原数不到9个5，输出0即可
```
[引用专用框]

代码如下：

var i,cnt0,cnt5,n,a:longint;//cnt0表示0的个数，CNT5表示5的个数

```cpp
begin
 readln(n);
 for i:=1 to n do begin
  read(a);
  if a=5 then inc(cnt5) else inc(cnt0);
 end;
 if (cnt5>=9)and(cnt0>=1) then begin
 for i:=1 to cnt5 div 9 do write('555555555');
 for i:=1 to cnt0 do write('0');//0的个数越多越好
 end
 else if cnt0>=1 then writeln('0')
 else writeln(-1);
end.
```
14行AC
AC效率：

5ms /  8.21MB

代码：0.31KB Pas


---

## 作者：AdzearDisjudge (赞：0)

首先，你要知道：

1、能被90整除等价于能被9和10同时整除。

2、被9整除判定条件：该数各数位之和为9的倍数。

3、被10整除判定条件：该数末尾有不少于1个0。

核心思路：

1、读入时记好5和0的个数

2、如果连0都没有，根本满足不了被10整除，直接输出-1

3、如果有0，那么无论有多少个0都要在末尾输出（除非要输出的就是0），这样不影响被9整除

4、由于0不影响被9整除，那么要想各位之和被9整除必须要9的倍数个5才行

5、我们可以打包9个5，只要还有9个或更多，就输出9个5，直到没有足够的5为止，然后把所有的0输出，这样才能使结果最大

6、如果原数不到9个5，输出0即可

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,i,n;
int main()
{
    cin>>n;
    a=0;
    b=0;
    for(i=1;i<=n;++i)
    {
        cin>>c;
        if(c==5)
        ++a;
        else
        ++b;
    }
    if(b==0)
    {
        cout<<-1;
        return 0;
    }
    if(a<9)
    {
        cout<<0;
        return 0;
    }
    else
    {
        while(a>=9)
        {
            cout<<"555555555";
            a-=9;
        }
        while(b>0)
        {
            cout<<0;
            --b;
        }
        return 0;
    }
    return 0;
}
```

---

## 作者：Blue_Sky (赞：0)

```cpp
var n,a,b,c,i:longint;
begin
  readln(n);
  for i:=1 to n do
  begin
    read(a);
    if a=5 then inc(b) else inc(c);//统计0和5的个数
  end;
  if (b>=9) and (c>=1) then //因为只有5555555550能整除90 所以5的个数要大于9和0的个数要大于1；
  begin
    for i:=1 to b div 9 do write(555555555);//节省时间
    for i:=1 to c do write(0);//越多0数就越大
  end else
  if c>=1 then write(0) else write(-1);
end.
```

---

## 作者：caozy623 (赞：0)

这题还是比较显然的吧……要说难点就只涉及了一点点小学数学的知识。被90整除的性质？岂不考虑被9整除的性质即可，然后如果有0就可以凑成90了……然后一个数的每一位数相加之和能被9整除即可得此数能被9整除……


```cpp
#include<iostream>  
#include<cstring>  
#include<cstdio>  
#include<algorithm>  
#include<vector>  
#include<string>  
#include<set>  
#include<queue>  
#include<stack>  
#include<map>  
#include<cmath>  
#include<cstdlib>  
#define ll long long  
#define maxn 1010  
#define inf 1000000000  
#define linf (1LL<<50)  
using namespace std;  
int a[maxn];  
int n;  
int f0=0,f5=0;  
int main()  
{  
    scanf("%d",&n);  
    for(int i=1;i<=n;i++)  
    {  
        scanf("%d",&a[i]);  
        if(a[i]==0) f0++;  
        if(a[i]==5) f5++;          
    }  
    if(f0==0)   
    {  
        puts("-1");  
        return 0;  
    }  
    int mx=0;  
    int sum=0;  
    for(int i=1;i<=f5;i++)  
    {  
        sum+=5;  
        if(sum%9==0) mx=max(mx,sum);  
    }  
    if(mx==0) puts("0");  
    else  
    {  
        for(int i=1;i<=(mx/5);i++)  
        printf("%d",5);  
        for(int i=1;i<=f0;i++)  
        printf("%d",0);  
        printf("\n");  
    }  
    return 0;  
}
```

---


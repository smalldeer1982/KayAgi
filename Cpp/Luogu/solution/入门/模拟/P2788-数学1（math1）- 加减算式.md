# 数学1（math1）- 加减算式

## 题目背景

蒟蒻HansBug 在数学考场上，挠了无数次的头，可脑子里还是一片空白。


## 题目描述

好不容易啊，HansBug 终于熬到了做到数学最后一题的时刻了，眼前是一堆杂乱的加减算式。显然成功就在眼前了。可是他脑细胞和RP已经消耗殆尽，所以这个重要的任务就交给你们啦。


## 说明/提示

数据保证字符串长度不超过 $60000$。


## 样例 #1

### 输入

```
1+2-3```

### 输出

```
0```

# 题解

## 作者：览遍千秋 (赞：567)

管理员大大：这篇题解是本题第一篇这种方法的题解，且收获最高赞。后来看到评论区很多人有疑问，进行了一次upd，怎么就被拒掉了QAQ

---

UPD 2019.7.11

LG更新了评论提醒功能，才发现这篇题解最高赞了。。。

内容写的简单可能让一些人理解不了，补充如下：

## 关于本地测试样例程序无法结束

这是因为没有使用文件读写或者评测系统，程序仍在等待读入
 
## 部分人关于 $-$ 号的疑问

这样读入的本质是 cin 将题目认为的 $+$ 运算和 $-$ 运算当做了整数的正负号，又有 $a-b=a+(-b)$，所以答案是正确的。


---

原题解：

C++有一个不能算特性的特性。

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,t;
int main()
{
    while(cin>>t) ans+=t;//读入并计算
    cout<<ans;//输出
    return 0;
}
```

---

## 作者：淼淼 (赞：33)

蒟蒻的第一篇题解，做的不好请见谅。

这是一道关于字符串的题目，为了练习线性结构，我用队列AC这道题

我们先来讲一下队列是什么（dalao可以跳过这段）

队列是一种线性结构，她的原则就是“先进先出”。我们可以利用这个原则，完成计算。

为了方便解释，我用几张图~~（假装这是图吧）~~来解释队列的原理

我们定义一个队列a，并且压入一个数字1，现在她的是这样的：
```
+-----+
|  1  |
+-----+
```
我们在压入一个数字2，现在她的样子：
```
+----------------+
|    1  |    2   |
+----------------+
```
如果我们弹出一个数字，那么她是这样的：
```
+-----+
|  2  |
+-----+
```
原来的数字1被弹出了，只剩下数字2了。
我们可以看到：弹出的数字是先被压入的数字1，而后来被压入的数字2并没有因为这个指令而弹出。这就是队列“先进先出”的原理。

定义一个队列是这样的：
```cpp
queue<队列类型> 队列名称;
比如定义一个int类型的队列a:
queue<int> a;
```
对了，如果想使用队列，必须要加上这样一个头文件：
```cpp
#include <queue>
```
下面是队列的一些基本的操作指令：
```cpp
empty()//判断队列是否为空
push(x)//把x压入队列
front()//返回队首元素
pop()//弹出队首第一个元素
size()//返回队列的长度
```
队列讲完了~~其实我也不清楚我有没有讲全~~，下面是AC的代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <string>
#include <queue>//队列头文件
using namespace std;
queue<int> a;//定义一个int类型的队列a，用于存储数字
queue<char> b;//定义一个char类型的队列b，用于存储运算符号
int main()
{
    char n[60001];
    int i,len,s=0,ans=0;
    cin>>n;//建立变量，读入
    len=strlen(n);
    b.push('+');//首先压入一个"+"，不然的话我们就会少运算一次！
    for(i=0;i<=len;i++)//循环扫一遍读入的变量n
    {
        if(n[i]=='+'||n[i]=='-'||i==len)//如果我们遇到了"+"和"-"，或者这是最后的一个数字，就说明刚才的数字已经统计完了，把他压进队列
        {
        a.push(s);
        if(i!=len)b.push(n[i]);//把符号压进去，前面的判断是为了防止把"\0"也当做运算符压进去
        s=0;
        }
        else
        {
            s=s*10+(n[i]-'0');//统计数字
        }
     } 
     while(!a.empty()||!b.empty())//开始运算
     {
     if(b.front()=='+')
     ans+=a.front();//加法
     if(b.front()=='-')
     ans-=a.front();//减法
     a.pop();//运算完的数字就弹出去了，让下一个数字运算
     b.pop();
     } 
     printf("%d",ans);//输出结果
    return 0;
}

```

---

## 作者：Kroos (赞：27)

### 思路
1）在输入上下点功夫

2）计算答案，输出

### 如何实现

为了可以把数和符号分开（这其实就是解出本题的关键），我们可以利用scanf，写出以下代码：

```cpp
int a[30001];//用这个数组装数
char b[30001];//用这个字符数组装加减号
for(len=1;;len=-~len)//其实，len=-~len的效果等同于len++，++len，len+=1。但是，它的速度会更快一些
{
	scanf("%d%c",&a[len],&b[len]);//scanf的巧妙之处就在这里体现了！读入就一起读入数和字符，如+50，-12等
	if(b[len]!='+' && b[len]!='-')//判断+-就相当于判断输入有没有结束（想一想，这是为什么？）
		break;//结束输入
}
```
之后的计算就很简单了！

### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[30001];
char b[30001];
int len,ans;
int main()
{
	for(len=1;;len=-~len)//这一部分是用来读入的
	{
		scanf("%d%c",&a[len],&b[len]);
		if(b[len]!='+' && b[len]!='-')
			break;
	}
	ans=a[1];
	for(int i=2;i<=len;i=-~i)//这一部分是用来计算的
	{
		if(b[i-1]=='-')
			ans-=a[i];
		else
			ans+=a[i];
	}
	printf("%d",ans);//输出
	return 0;
}
```

### SOMEBODY：不用如此麻烦

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
int c;
int main()
{
    while(cin>>c)
    	ans+=c;
    cout<<ans;
    return 0;
}
```
这种方法也是一种巧妙的读入方法，大家了解了解就行了。
### 拓展

有一个题也是类似的方法，但我找不到在哪了，就写在这吧。

输入：一串字符：a+b

输出：一个数，即a+b的值

样例读入：2+3

样例输出：5

其实只要这样就可以啦：

```cpp
scanf("%d+%d",&a,&b);//就这么简单
printf("%d",a+b);
```

希望本题解可以帮到大家。如果本题解有不足之处，请您指出，谢谢。

---

## 作者：Xeonacid (赞：22)

Python 2是个好东西，我们都要爱护他。（求大犇补一下Python 3的食用方法）

```cpp
print(input()) #直接计算输入表达式并输出结果
```

---

## 作者：lwzheng00000 (赞：12)

感觉字符串好麻烦，读一个判断一个不好吗？？

#### 上代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int main(){
    int ans;//答案，不需要字符串，不需要数组
    cin>>ans;//读入第一个值，作为初始值
    int cache;//读入缓存
    char c;//符号缓存
    while(1){
        if(scanf("%c",&c)==EOF){//EOF为文件结束符，文件结束跳出循环
            break;
        }
        scanf("%d",&cache);//读入一个值
        if(c=='+') ans+=cache;//加号则加
        if(c=='-') ans-=cache;//减号则减
    }
    printf("%d",ans);//输出答案
    return 0;
}
```
非常简单，非常短

---

## 作者：国服最强关羽 (赞：11)

# 求通过！

## 如果有什么不懂的可以给我私信

```cpp
var i,p,j,s,b:longint;
    c:array[1..30001] of longint;
    d:array[1..30001] of char;
    a:char;
 begin
  i:=1;
  p:=1;//p为什么要在这里赋值为1呢？在后面解释
  while not(eoln) do//由于本人用的是字符，所以要用eoln
   begin
    read(a);//输入就不用我多说了吧
    if (a>='0') and (a<='9') then begin val(a,b);c[i]:=c[i]*p+b;p:=10;end//a在0到9的范围内就把数字存下来，p之前要赋值为1的原因就是：你在开始不赋值为1，c[i]:=c[i]*p+b这条语句就相当于c[i]:=b，因为你的p刚开始不赋值就等于0
                             else begin p:=1;d[i]:=a;inc(i);end;//如果是'+'或'-'，p就赋值为1，累加i；
   end;
  s:=c[1];//s刚开始先赋值为第一个数
  for j:=2 to i do//开始计算
   case d[j-1] of
    '+':s:=s+c[j];
    '-':s:=s-c[j];
   end;
  writeln(s);//输出s
end.
```

---

## 作者：cindy2007 (赞：6)

用栈来做，栈的特点为先进后出。

栈可以中缀转后缀。 

中缀转后缀的方法为

1.从左往右扫，遇到数字将其压入数字栈。


2.遇到运算符，看运算符栈，若栈为空，或桟顶的优先级比运算符低，或栈顶为左括号，直接入栈。（虽然这题没有）

3.若不能直接入栈，依次弹出桟顶的运算符，每弹一个就压入数字栈，直至可以直接入栈。

4.若是右括号，则依次弹出运算符栈的运算符，压入数字栈中，直至遇到左括号为止。

5.将数字栈中的符号弹入运算符栈中。

6.依次弹出运算符的东西，遇到数字压入数字栈中。

7.若是运算符，从数字栈中弹出两个数，进行运算。（请注意，先弹出来的为操作数1，后为操作数2）将运算结果存入数字栈。

8.输出结果。

  
```cpp
#include <iostream>
#include <stack> //使用系统自带的栈需要这个库
using namespace std;
stack <int> op,num;  //定义两个栈，格式为stack <类型> 变量名
void proc(int m)   //此函数为处理步骤2~3
{
	if (op.empty())    //此题的优先级相同，所以每一次入栈都要弹光栈。只用判断是否为空。
	{
		op.push(m);  //入栈
		return ;
	}
	num.push(op.top());   //若不能满足条件，将其压入数字栈。
	op.pop();
	proc(m);     //尝试下一次能否入栈。
 } 
int main()
{
	string str;
	cin>>str;
	int temp;
	int l=str.length();
	for (int i=0;i<l;i++)
	{
		if (str[i]>='0' && str[i]<='9') //判断是否为数字
		{
			temp=str[i]-'0';
			while (str[i+1]>='0' && str[i]<='9') //此while循环是为了防止多位数读成多个数。
			{
				i++;
				temp=temp*10+str[i]-'0';
			}
			num.push(temp); //入栈
		}
		else  //运算符
		{
			switch(str[i])
			{
				case '+':temp=-1;    
					break;
				case '-':temp=-2;
					break;
			}
			proc(temp); //入栈操作
		}
	 }
	while (!num.empty())
	{
		op.push(num.top());   //步骤5
		num.pop();
	 }
	 
	while (!op.empty())
	{
		int x=op.top();
		op.pop();
		if (x>=0)     //将数字压入数字栈
		{
			num.push(x);
		}
		else
		{
			int num2=num.top();  //运算
			num.pop();
			int num1=num.top();
			num.pop();
			switch(x)
			{
				case -1:num.push(num1+num2);
					break;
				case -2:num.push(num1-num2);
					break; 
			}
		}
	}
	cout<<num.top()<<endl;   //输出结果
	return 0; 
}

```


---

## 作者：momentous (赞：5)

## 字符数组/字符串 入门题

发现水题,赶紧补一发 **~~正常的~~** 题解

此题很适合作为 **字符数组**/**字符串** 入门题

个人建议用 scanf 和 printf ,因为你会发现这俩东西比 cin 和 cout 快很多

代码中有注释,可自行查看,**再有不懂的可以私信问我**

## Code
```Cpp
#include<cstdio>
#include<cstring>
  //strlen() 这个函数要用到这个头文件
using namespace std;
char st[60010];
int Ans;
int Get(int Pos){ //函数,返回以当前位置为数字最高位的数字
	int res=0;//注意!!要初始化为 0
	while(st[Pos]>='0' && st[Pos]<='9'){
		res=res*10+st[Pos]-48;
          /*
            当然知道快读的人都会知道,
            这句话可以用位运算写成:
            res=(res<<3)+(res<<1)+(st[Pos]&15);
            
            "<<" 左移:
              左移1位相当于 *2,左移2位相当于 *4
              左移n为 相当于乘2的n次方
            "&" 与运算:
              把左右两边的东西换成2进制
              若在2进制下同一位的数字都为1,
              则得到的新数字的2进制下的那一位也为1,否则为0
          */
		Pos++;
	}
	return res;//返回数值
}
int main(){
	scanf("%s",st+1);
    /*
      这句话的意思是读入的字符串串首为1
      C++中默认串首为0
      别问我这里为什么不用加 '&'
      我也不知道
    */
	st[0]='+';
    /*
      将 0 的位置处插入一个 '+' 使Ans在循环中加上第一个数
    */
	for(int i=0;i<strlen(st);++i){
		if(st[i]=='-') Ans-=Get(i+1);
          //减去数字,因为减号后一定是数字(可能数据比较弱)
		if(st[i]=='+') Ans+=Get(i+1);
          //同上,加上数字
	}
	printf("%d\n",Ans);//输出答案
	return 0;//结束程序
}

```

---

## 作者：尼古拉斯·柠檬 (赞：5)

java+正则表达式：将该字符串变成“1 2 -3 -4”这样的形式，然后直接用循环遍历相加

```
public static void main(String[] args) throws IOException {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String str=br.readLine().trim();
		
		// 将“1+2-3-4”替换成“1 2 -3 -4”
		str=str.replaceAll("[+]", " ");
		str=str.replaceAll("[-]", " -");
		String[] nums=str.split(" ");
		long sum=0;
		for(String s:nums){
			sum+=Integer.parseInt(s);
		}
		System.out.println(sum);
	}
```

---

## 作者：鹭天 (赞：5)

#啊哈！绝对让别人想不到的方法！

##我的思路是这样的:先将其中的所有数字都找出来,存放在a数组当中，在全部累加到一个变量k当中，再将'+','-',符号存储在字符数组ch当中，如果ch是'-'，那就让k减掉a[i+1]\*2(i为当前字符'-'的位置，因为我们一开始不仅没减，反而还加上了这个数，所以我们要在将这个数清空的基础上再去减掉这个数，所以要减去这个数的2倍)

###那么代码如下:

```cpp
var
  i,j,n,k:longint;
  a:array[0..60001] of longint;
  ch:array[0..60001] of char;//存放+,-符
  s,s1:ansistring;//字符长度不超过60000，所以要用超长字符串
begin
  readln(s);s:=s+' ';//先让s加一个空格，不然最后一个数取不到
  for i:=1 to length(s) do begin
    if (s[i]>='0')and(s[i]<='9') then s1:=s1+s[i]//如果是数字那就加上
      else begin
       inc(j);ch[j]:=s[i];inc(n);val(s1,a[n]);s1:='';k:=k+a[n];//存放字符，转换数字，累加的过程。
      end;
  end;
  for i:=1 to j do
    if ch[i]='-' then k:=k-a[i+1]*2;//找出需要减去的数字(减两个
  write(k);//输出
end.
{}
#就是那么简单！
```

---

## 作者：Javi (赞：3)

广告：
# 点击[食用](https://www.starroad.top/archives/416.html)以获得最佳效果

讲一个无耻的解法。

我们知道，如果每一个数之间都打一个空格，就可以简单的使用下面的程序解决。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long n,ans=0;
	while(cin>>n){
		ans+=n;
	}
	cout<<ans<<endl;
	return 0;
}
```

现在我们读入的是一个字符串，我们就使用字符串流手动把空格补上。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	string s;//读入的字符串
	stringstream ca;//字符串流
	cin>>s;//读入字符串
	for(unsigned int i=0;i<s.size();i++){
		if(s[i]>='0'&&s[i]<='9'){//数字
			ca<<s[i];
		}
		else{//符号
			ca<<" "<<s[i];
		}
	}
	long long n,ans=0;
	while(ca>>n){//cin>>n
		ans+=n;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：GJC_xj (赞：3)

**新人第一篇题解**

用字符串处理 res表示当前读到的数字 。每次读到一个数字就res\*10+当前的数

当读到‘-’或‘+’时 结算。 flag 是对符号的记录

\_注意事项\_

1 字符串a 很大

2 最后要再结算一遍 因为最后是没有符号的

3 数据中没有 减去负数的情况

4.flag初始值应该为1（正）

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[5000002];
long len,ans=0;
int main()
{
    gets(a);
    len=strlen(a);
    int flag=1;//flag==1表示正数 2表示负数
    int res=0;
    for(int i=0;i<=len-1;i++)
    {
        if(a[i]=='+') 
        {
            if(flag==1) ans+=res;
            if(flag==2) ans-=res;
            res=0;
            flag=1;
        }
        if(a[i]=='-')
        {
            if(flag==1) ans+=res;
            if(flag==2) ans-=res;
            res=0;
            flag=2;
        }
        if(a[i]>='0'&&a[i]<='9')
        res=res*10+a[i]-'0';
    }
    if(res!=0)//处理最后一个数
    {
        if(flag==1) ans+=res;
        if(flag==2) ans-=res;
    }
    printf("%d",ans);
}
```

---

## 作者：zhylj (赞：3)

最短代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a=0,x;
    while(scanf("%d",&x)!=EOF)
        a+=x;
    cout<<a<<endl;
    return 0;
}
```
读入的数，可能是正数和负数，如：
1+2-3
先读入1，是一个正数，a+=(1);

然后是+2，是一个正数，a+=(+2);

最后是-3，是一个负数，a+=(-3);

所以最后结果是0;

正号和负号系统会判断，不需要手动判断


---

## 作者：夜枭只会舔fufu (赞：2)

EMM~~~~~

wo you lai gei ni fa ti jie la!

说人话！！！

（我又来给你们发题解啦）

蒟蒻发题解——~~大佬勿喷~~

~~进入正题~~

```
#include<bits/stdc++.h>//万能头文件QWQ（懒得写<iostream>）
using namespace std;
int a;//定义a（用来存储第一个数以及答案）
int x;//用来存储每一个进行操作的数
char c;//+或-
int main()
{
    cin>>a;//输入第一个数（以后其他操作都赋值给它）
    while(cin>>c)//边读边输
    {
       cin>>x;//输入（2到正无穷）个数
       if(c=='+')//符号是加
	      a+=x;//加上刚输入的数
	    if(c=='-')//符号是减
         a-=x;//减去刚输入的数
    }
    cout<<a;//输出
    //cout<<"犯我题解者，虽远必棕";
    return 0;//完结撒花
}
```

恭喜你收获了一道~~黑题~~（假的）

[广告](https://www.luogu.org/space/show?uid=197149)

讲得够清晰了吧 ORZ 0-0

---

## 作者：20140408abcd (赞：2)

# 楼下写栈的同志们好
## 一起向快读势力低头吧
这道题只有加减，意味着没有运算级别先后，也就是说

~~直接按输入顺序就好了，为什么要写栈~~

特殊处理第一个数，再看符号决后面的数该加该减。

~~然后就没了，做完了~~

****千万不要边输入边计算，会TLE
```
#include<bits/stdc++.h>//妈妈再也不怕我忘库头了
using namespace std;
char s[1000000];
long long read()
{
    long long x=0,y=0;//记之前数的和与当前数
    long long f=1,i=1;//判断正负与到了第几个了
    char c=s[1];
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=s[++i];}//特殊处理第一个数
	for(;i<=strlen(s+1);)//只要不到末尾
	{
		f=1;y=0;//默认为正，数为0
        //快读板子，自动分离正负号与数字
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=s[++i];}
		while(c>='0'&&c<='9'){y=y*10+c-'0';c=s[++i];}
		x+=y*f;//累加当前数
	}
	return x;//返回结果
}
int main()
{
	cin>>s+1;//输入字符串
	cout<<read();//输出结果
}
```


---

## 作者：Deny_小田 (赞：2)

首先膜拜一下CLJ神犇。。


有那么复杂吗？hash是实在没办法时当做“终极杀手锏”，像这种难度适中的题目练练模拟就ok了。


虽然适中，但也不要以为多么简单。大家平时的思路一般如下：


1.如果当前字符为数字，则当前数，now变量在末尾加上当前字符。

如：当前字符‘2’，now变量目前为31，则操作之后为312，即：


now = (now\*10)+s[i]-'0'

2.如果当前字符为加（减）号，则把now加（减）到总和sum中，now归零。

3.输出sum。


其实我刚开始也是这种想法，但这是错误的！


例如：1+2-3.

当前为1，now = 1，

当前为+，sum = 1，now = 0

当前为2，now = 2

当前为-，sum = -1，now =0

当前为3，now = 3


输出sum = -1不等于0.


所以我说这条思路是错的。

那为什么呢？


我们说1+2，是1，+2，而不是1+，2.

什么意思呢？

我们遇到加号时，是加他后面那个数而不是加前面那个数。

明白了吗？


那思路又是什么呢？


大体思路基本没变，就是多了一个char类型的flag变量。

当遇到+、-号时，flag变量首先按照保存的字符加上一个数字，再保存当前字符。

flag初始化为+号。


什么意思呢？还是以1+2-3举例：

当前字符为1，now = 1

当前字符为+，因为flag初始化为+，所以sum += now，sum = 1，now = 0，并将flag保存为+

当前字符为2，now = 2

当前字符为-，因为上一个flag保存为+，所以sum+=now，sum=3，now = 0

当前字符为3，now = 3


但是，sum还不等于0呢，又是神马原因呢？？

因为我们少计算了一次。


我们最后再来一次，判断flag为什么。

即：
flag为减号，sum -= now，sum = 0.

输出sum即为0.


我用的字符串读入为string，因为它更方便一些。


其实我还是蛮担心超时的。。。

感谢阅读，附代码：




    

```cpp
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;
string s;
int sum = 0,now = 0;
char flag = '+';
int main(int argc, char const *argv[]){
    ios::sync_with_stdio(false);
    cin >> s;
    for(int i = 0; i < s.size(); i++){
        if(s[i] >= '0'&&s[i] <= '9') now = (now*10)+(s[i]-'0');
        else{
            if(flag == '+') sum += now; 
            else sum -= now;
            now = 0;
            flag = s[i]; 
        }
    }
    if(flag == '+') sum += now;
    else sum -= now;
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：TAFE_ZZR (赞：2)

# 解法一：一波特性带走
    #include<bits/stdc++.h>
    using namespace std;
    int n,s;
    int main() {
        while(cin>>n) s+=n;
        cout<<s;
        return 0;
    }//AC
# 解法二：字符串
    #include<bits/stdc++.h>
    using namespace std;
    long long i,ans;
    char s[6666666];
    int main() {
        std::ios::sync_with_stdio(false);
        gets(s);
        ans=s[0]-'0';
        for(i=1;i<strlen(s)-1;i+=2)
            if(s[i]=='+') ans+=s[i+1]-'0';
            else ans-=s[i+1]-'0';
        cout<<ans;
        return 0;
    }
## 然鹅只有10分，有dalao告诉我出了什么问题吗！

---

## 作者：沃特 (赞：2)

# 思路

先输入一个数

然后循环

## 循环内部

先读一个字符

如果不是加号，也不是减号，就结束循环

然后＋/－即可

代码：

```cpp
cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int wu,run,ze;char wrz;
    cin>>ze;;
    for(;;)
    {
        if((wrz=getchar())!='+' and wrz!='-')break;
        cin>>wu;
        if(wrz=='+')ze+=wu;
        else if(wrz=='-')ze-=wu;
    }
    cout<<ze;
    return 0;
}
```

---

## 作者：鹤笙 (赞：1)

# 如果艺术就是爆炸
------------
那么作为刷题的孩子最需要的就是简洁；

_开门见山_ 上代码；

------------

```
#include<bits/stdc++.h>
using namespace std;
int x,a,sum;
char s;
int main()
{
    cin>>a;sum+=a;先把第一个数存入运算结果；
    while(cin>>s>>x)然后我们就可以先输入一个字符，再输入一个数
    {
        if(s=='+')sum+=x;判断
        if(s=='-')sum-=x;判断
    }
    cout<<sum;啊哈哈没了就这样
    return 0;
}
```
------------
其实思路很nice，
字符，数字分开输入，那么我们在运算结果的过程中便省了许多麻烦；
求借鉴！

---

## 作者：zk1431043937 (赞：1)

好像没pascal题解，来一发。

首先是处理字符串，将数字存入数组，运算符号存入另一数组。

处理完毕就取出计算。

由于，没有乘除，就不必判运算先后，所以很简单，顺序运算就行。

注意，本题数组开大些，之前开了10000的数组竟然有3个点WA，改成100000后就对了，与此配套的也要用ansistring来读入字符串。

下面上pascal代码：

```cpp
program p2788;
  var a:array[1..100000]of int64;
      f:array[1..100000]of char;
      i,top1,top2,ans:longint;
      s:ansistring;
begin
  readln(s);
  top1:=1;
  top2:=1;
  for i:=1 to length(s) do
  begin
    if (s[i]>='0') and (s[i]<='9') then a[top1]:=a[top1]*10+ord(s[i])-48;//存数字。
    if (s[i]='+') or (s[i]='-') then
    begin
      f[top2]:=s[i];//存运算符号。
      inc(top1);//下标inc到下一个数字。
      inc(top2);//下标inc到下一个运算符号。
    end;
  end;
  ans:=a[1];
  for i:=1 to top1-1 do
  if f[i]='+' then ans:=ans+a[i+1] else ans:=ans-a[i+1];//取出运算。
  writeln(ans);
end.
```

---

## 作者：1124828077ccj (赞：1)

//这就是传说中的hash，数据有点弱，于是就过了（数据强一点可以map）

            
```cpp
#include<cstdio>
#include<cstring>
int n,m,a[1002],flag,x,y,t[1000001],ans;
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    for (int i=0;i<m;i++)
    {
        scanf("%d%d%d",&flag,&x,&y);
        ans=0;memset(t,0,sizeof(t));
        if (flag)a[x]=y;
        else 
        {
            for (int i=x;i<=y;i++)
            {
                t[a[i]%1000001]++;
                if (t[a[i]%1000001]>t[ans%1000001] || t[a[i]%1000001]==t[ans%1000001] && a[i]<ans)ans=a[i];
            }
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：一UNowen一 (赞：1)

啥都不说了，直接把区间的数拎出来排个序弄一下就行了，O(Qnlog(n))CLJ关于这个有论文可以做到O((n+q)\*n^0.5)的复杂度

```cpp
#include<cstdio>
#include<algorithm>
usingnamespacestd;
inta[1005], tmp[1005];
intn, m, cnt;
inlineintread() {
    intret = 0;
    charc = getchar();
    while ((c > '9') || (c < '0')) c = getchar();
    while ((c >= '0') && (c <= '9')) ret = (ret << 1) + (ret << 3) + c - '0', c = getchar();
    return ret;
}
intmain() {
    scanf("%d%d", &n, &m);
    for (inti = 1; i <= n; i++) scanf("%d", &a[i]);
    for (inti = 1; i <= m; i++) {
        intflag = read() , x = read() , y = read();
        if (flag == 0) {
            cnt = 0;
            for (intj = x; j <= y; j++) tmp[++cnt] = a[j];
            sort(tmp + 1, tmp + 1 + cnt);
            intans = tmp[1], s = 1, S = 1;
            for (intj = 2; j <= cnt; j++) if (tmp[j] == tmp[j - 1]) {
                s++;
                if (s > S) {
                    S = s;
                    ans = tmp[j];
                }
            } else s = 1;
            printf("%d\n", ans);
        } else a[x] = y;
    }
}
```

---

## 作者：疯的、风 (赞：1)

这道题是一道典型的字符水题，就相当于一个高精加减法，不过是比较简单、基础的高精问题，高精的核心思想也没联系到。。。

我的思路很简单，就是将每串数字用数组记录下，再进行一次搜索，看到'-','+'这两个符号就执行相应的运算，记录下结果即可 。


蒟蒻简单无脑代码。。。。。。。。。。。。


```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
long int len,ans;//不解释
int q[1010101],s,k;//q是存数字串的数组，k是临时记录数字的变量，是数组下标
int main()
{
    cin>>a;
    len=a.size();
    for(int i=0;i<len;i++)
    {
        if(a[i]=='-'||a[i]=='+') {q[s]=k;k=0;s++;continue;}//是加减符号就存一次，k清零，下标加一
        k=k*10+a[i]-'0';//不是字符，就记录下数字，这里有一个经常用的方法，一个数字字符减去‘0’所表示的ascii码就是这个数字的实际大小；每多加一个数，这个数就是个位数字，原来的数字都相应的进一位
    }
    q[s]=k;//q[s]在上面的记录中无法被记录，需要另外记录
    ans=q[0];//第一个数需要单独加上
    s=1;//下标重新开始记数
    for(int i=0;i<len;i++)
    {
        if(a[i]=='-') {ans=ans-q[s];s++;}
        if(a[i]=='+') {ans+=q[s];s++;}//判断符号进行运算，q[s]即是加减号后所对应的数字串
    }
    cout<<ans;//输出。。。。。。。。。。
    return 0;
}
```

---

## 作者：King_Parliament (赞：0)

看到他们都是全部读完在处理，我给出一个边读边处理的方法。

我们仔细思考，每次读入的数无非就是两种情况：

> 1.输入的数字前符号为‘+’

> 2.输入的数字前符号为‘-’

那么我们只需要逐个讨论，是‘+’则在答案中加上，是‘-’则从答案中减去。

由于第一个数不一定有符号，那么不管有没有符号，我们都可以我们先输入一个数，使其成为ans，然后利用死循环进行逐个数字的运算即可。

上代码解释。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long ans;//随手longlong好习惯 
	cin>>ans;//第一个数字直接成为ans的初始值 
	while(1){//用死循环不断更新ans 
		char a=getchar();//读入下一个数字的符号 
		if(a==EOF)break;//如果读到空，终止循环 
		if(a=='+')//如果是加号，做加法运算
		{	int s;
			cin>>s;ans+=s;}
			
		if(a=='-')//如果是减号，做减法运算
		{	int s;
			cin>>s;ans-=s;}
	}
	cout<<ans;//循环结束后输出答案 
	return 0;
}
```


---

## 作者：Max_Leo (赞：0)

[传送门](https://www.luogu.org/problem/P2788)

真没有看到一样的思路~~（由于太菜还看不懂别人的）~~就忍不住发了这篇题解

本蒟蒻没有很巧妙的方法，也不会用STL，只能用最基础的字符串处理

其实就只要每次判断一下符号，然后再把后面的数字转化成一个整数，加到ans中

### 附（必备知识）：
##### 1.字符串转数字的方法
```cpp
sum=0;
for(int i=0;i<a.length()或者a.size();i++)
	sum=sum*10+a[i]-'0';
```
解释一下 对于每个char（字符）类型的字符，它都有一个对应的[ascii码](https://baike.baidu.com/item/ASCII/309296?fromtitle=ASC%E2%85%A1%E7%A0%81&fromid=4607931#viewPageContent)比如说字符'0'对应的就是48，'1'对应的是49，（真正的0是'\0'出现在字符串的最后一个，所以可以while(a[i])如果不是'\0'就继续搜下去）所以如果要把一个个位数(char)转化成int那就可以直接减去48或'0'。而对一个多位数那就每一位存进来然后再乘以十加上个位。

打个比方123=（（1*10+2）*10）+3

##### 2.函数isdigit
再介绍一个函数isdigit 如果字符a是'0','1',……,'9'之间的数字那就返回1（true），否则返回0（false）

既然如此，就直接上代码↓
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	string a;
	getline(cin,a);
	int al=a.length();
	int ans,sum=0;
	bool f;
	if(a[0]=='-')
		f=1;
	else
		f=0;
	int i=f;
        	//看第一个是不是‘-’
			//如果第一个是负数，第一个数字就从a[1]开始
    		//如果是整数那就从此a[0]开始
            //当字符串到末尾时a[i]='\0'=0
            //while循环停止
	while(a[i])			
	{
		sum=0;
		while(isdigit(a[i]))
		{
			sum=sum*10+a[i]-'0';
			i++;
		}//把字符串中的数字存入变量sum中
		ans+=sum*pow(-1,f);
        	//ans+=sum*(f?-1:1)
            //f为1则该数字是个负数
		if(a[i++]=='-')
			f=1;
		else
			f=0;
	}
	cout << ans;
	return 0;
}
```

广告：推荐一道题目[因式分解之表达式](https://www.luogu.org/problem/T64913)←来自于[SCP基金会](https://www.luogu.org/team/show?teamid=14351)（题目其实是一样的）

---

## 作者：Nempt (赞：0)

最近荣誉课程上学习了STL标准模板库里面的双向队列，刚好可以用来解决此题。

双向队列：在队列上做扩展，队列是先进先出表。而双向队列增加了可以在队列两

端操作元素的功能；引入头文件：#include<deque>
  
  接下来就是一波模拟操作：
  
  ```cpp
#include<iostream>
#include<string>
#include<deque>
#include<cctype>
#include<cstdlib>
#include<cmath>
#include<stdio.h>
using namespace std;
int main()
{
	deque<string> v;  //定义双向队列 v
	string s;
	cin>>s;
	string temp;
	for(int i=0;i<s.size();i++)
	{
		if(isdigit(s[i]))  //如果字符是数，那么一直加追到temp串后面
		{
			char a[2];
			a[0]=s[i];
			a[1]='\0';
			temp+=a;
		}
		else  //如果是符号，那么意味着上个数已经全部读入
		{
			v.push_back(temp);  //将这个数入队(注意：从后入队)
			temp.clear();       //记得清空
			char a[2];
			a[0]=s[i];
			a[1]='\0';
			temp+=a;
			v.push_back(temp);  //把符号也放到队里
			temp.clear();       //记得清空
		}
	}
	v.push_back(temp);  //最后这个，卡了我一会儿，因为这不像你波兰数
                        //那道题，最后一个数需要额外手动加到队里
	while(v.size()!=1)  //没有得到结果之前一直循环
	{
		int a=atoi(v.front().c_str());  //取出第一个数
               //注：atoi：将字符串转化为整型，c_str将string转化为char*
		v.pop_front();  
		char ch=v.front()[0];  //取符号
		v.pop_front();
		int b=atoi(v.front().c_str());  //取第二个数
		v.pop_front();
		switch(ch)
		{
			case '+':
				char f[20];
				sprintf(f,"%d",a+b);  //注：sprintf：把数转为字符串
				v.push_front(f);  //队首入队
				break;
			case '-':
				char g[20];
				sprintf(g,"%d",a-b);
				v.push_front(g);
				break;
		}
	}
	cout<<v.front()<<endl;   //这个就是结果了
	v.pop_front();
	return 0;
}
```


---

## 作者：CREED (赞：0)

- - - 这是不同于前面所有思路的题解？

貌似是的呢，本题解的主要是**输入方式**有区别~（说白了就是懒得用个鬼畜的ansistring）~，能够极大节约空间。（ansistring毕竟有点大，虽然说是动态内存。）

- Pascal 题解

var tmp:string; ch,sign:char; n,t:longint; // tmp用来临时存储每一段的数字，ch做临时储存字符，n储存结果，t临时储存数字用于计算。

procedure add;  //因为读完后还要再计算一遍，所以干脆把相同的地方用过程来代替。

```cpp
begin
  val(tmp,t);
  case sign of
    '+':n:=n+t;
    '-':n:=n-t;
  end;
end;
begin
  tmp:='0'; sign:='+'; n:=0;
  repeat  //这一段和别的题解差不多，纯模拟。
    read(ch);
    if ch in ['0'..'9']  then
      tmp:=tmp+ch
    else
      begin
        add;
        tmp:='0';
        sign:=ch;
      end;
  until eof; //eof 是 end of file 的缩写，如果要测试的话,在输入里记得结尾打个结束符号。
  add;
  writeln(n);
end.
```

---

## 作者：linlin (赞：0)

先安利几个字符串常识

1.字符（串）相加

设两个字符，a='a';b='b';

a+b='ab';

b+a='ba';

同理，若a='1',b='2',

则a+b='12',

b+a='21;

再比如a='aaa',b='bbb',

a+b='aaabbb';

==============

2.字符串转数字的函数

val(s,r）；

其中s为字符串，r为存储数字的变量

转完后：

若s=‘11’

则r=11；

============

我们可以利用这两个性质来做这道题





###代码奉上，带讲解

var s,b:ansistring;//因为题目说是长度不大于60000，所以要用超文本形式定义

```cpp
sum,r,i:longint;
q:char;
begin
q:='+';//q为运算符号，初始为+
read(s);
repeat//开始循环
inc(i);//i为计数器，记录读到字符串的第几个数及判断是否结束循环
if (ord(s[i])>=48)and(ord(s[i])<=57) then b:=b+s[i];//如果字符串s的第i个字符是1-9的数字那么将其存入待转数字的字符串；
if(s[i]='+')or(s[i]='-')or(i=length(s)) then begin//如果找到符号了就开始处理，因为程序原因还要特判一下是不是最后一个数；
val(b,r);//字符串转数字，详见开头
 if (q='+')then begin sum:=sum+r;q:=s[i];b:='';end
else if (q='-')then begin sum:=sum-r;q:=s[i];b:='';end;//如果上一个符号是+就加上r，如果是-就减去r，然后将q换成这次找的符号等待下次运算，最后要清空b；
end;
until i=length(s);
writeln(sum);//最后输出结果；
end.
```
by linlin
2017.9.3


---

## 作者：Rachel_Gardner (赞：0)

看到很多dalao用了~~奇怪~~高级的方法

本蒟蒻只会使用字符串来做了orz

我的方法是如果碰到加减号就用一个变量t处理

如果是加号，下一次加上的数字为正数，如果是减号，则加上的是负数

这样就简单实现了加减法的问题

具体看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(char a[1000001],int i){    //用一个小循环来计算一连串的数字实际代表多少 
    int s=0;
    while (1){    //如果a[i]是数字就累加，不是就输出之前累加的和 
        if (a[i]<'0'||a[i]>'9') return s;
        s=s*10+a[i]-48;
        i++;
    }
}
char a[1000001];    //用字符串的方法 
int main()
{
    int x=0,t=1,r=1;    //x表示最后答案，t表示加还是减，r表示指向的数字字符是否已经得到实际数据了 
    gets(a);    //获取字符串a 
    for (int i=0;a[i]!='\0';i++){    //循环计算 
        if (a[i]>='0'&&a[i]<='9'&&r==1){    //如果是数字就调用函数f计算实际数据，且是以第一个数字为标准 
            x=f(a,i)*t+x;    //计算所得的值 
            r=0;    //已经计算过这一连串数字，r改为0 
        }
        if (a[i]=='+'){    //如果是加，t就为+1，r刷新为1 
            t=1;
            r=1;
        }
        if (a[i]=='-'){    //如果是减，t就为-1，r刷新为1 
            t=-1;
            r=1;
        }
    }
    cout<<x;    //最后输出结果
    return 0; 
}
```

---

## 作者：陈阳蒟蒻 (赞：0)

#模拟精简代码

看了其他神牛的题解，表示看不懂，因为他们用到的函数我看不懂，这里向大家介绍一下我的简单到人人懂的方法（其实就是难的我不会），最大的特点是**边输入边判断**。

——————华丽丽的分割线——————

思路如下：

1、    先输入一个数字a，把a赋值给答案ans。

2、    接下来用while循环，

while（cin>>字符串b>>数字a）（第一个数字已经输如了）

{
如果b是‘-’

{
答案ans=答案ans-这次输入的数字a；

}
如果b是‘+’

{
答案ans=答案ans+这次输入的数字a；

}
}
3、    输出答案ans，return 0；//撒花

——————华丽丽的分割线——————

代码如下：

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main()//主函数
{
    int ans,a;//ans为答案，a为输入的数字
    char b;//b来对付“+”和“-”
    cin>>a;//先输入第一个数字
    ans=a;//把第一个数字的值赋给ans
    while(cin>>b>>a)//输入完第一个数字后，后面的输入规律是一个加减号一个数字
    {
        if(b=='-')//如果要减
        {
            ans=ans-a;//就减去输入的数字
        }
        if(b=='+')//如果要加
        {
            ans=ans+a;//就加上输入的数字
        }
    }
    cout<<ans;//庄重地输出
    return 0;//结束
}
```

---

## 作者：Zhoulijie (赞：0)

用Python的人，你们不知道~~NOIp~~CSP不能用Python？？？

无论如何，这道题可以用一个灰常鬼畜的模式完成、

```
#include<iostream>
int main(){
	int ans=0,t;
	while(std::cin>>t;){
		ans+=t;
		
	}
   std::cout<<ans;
   return 0;
}
```

因为这是C++的~~BUG~~特性

输入`-a`会认为是输入了负数，从而就可以一直相加

![image.png](https://i.loli.net/2019/10/05/vIBVtlZgdR6s9Wk.png)

---

## 作者：_Int_ (赞：0)

c++
在线
O(n)
上代码

当当当当当当当当~~~~~~~~~

```cpp
#include<cstdio>
#include<iostream>
using namespace std;//头文件
int main(){//主函数
    char c;//读入
    long long ans=0;//结果
    int ac=0;//统计每一个加数(减数)
    bool ok=1;//判断加减,加是1,减是0
    //以上是所需变量
    for(;(c=(getchar()))!='\n';){//判断是不是回车,回车就结束
        if('0'<=c&&c<='9'){//如果是数字
            ac=ac*10+c-'0';//把数加进去(由于c是char型,char转int要减字符0)
        }
        else{//是加减号
            if(ok==1){//是加
                ans+=ac;//加上统计好的数字
            }
            else{//减
                ans-=ac;//同理
            }
            if(c=='+'){//下一个数是加
                ok=1;//变加
            }
            else{//减
                ok=0;//同理
            }
            ac=0;//统计的数清0
        }
    }
    //由于最后一个数没有被算,所以要再判断一次
    if(ok==1){
        ans+=ac;
    }
    else{
        ans-=ac;
    }
    cout<<ans;//输出
    while(1);//防抄袭水印
    return 0;//拜拜
}
```
/\*
写的不好,望各位dalao指教

\*/

---


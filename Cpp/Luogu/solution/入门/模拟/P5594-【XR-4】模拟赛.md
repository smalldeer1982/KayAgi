# 【XR-4】模拟赛

## 题目描述

X 校正在进行 CSP 前的校内集训。

一共有 $n$ 名 OIer 参与这次集训，教练为他们精心准备了 $m$ 套模拟赛题。

然而，每名 OIer 都有各自的时间安排，巧合的是，他们在接下来的 $k$ 天中都恰好有 $m$ 天有空打模拟赛。

为了方便管理，教练规定一个人必须按顺序打完 $m$ 套模拟赛题。

比如，小 X 在接下来的第 $2,3,5$ 天有空打模拟赛，那么他就必须在第 $2$ 天打第 $1$ 套模拟赛题，第 $3$ 天打第 $2$ 套模拟赛题，第 $5$ 天打第 $3$ 套模拟赛题。

教练需要为每一个人的每一次模拟赛做准备，为了减小工作量，如果在某一天有多个人打同一套模拟赛题，那么教练只需要在这一天准备一场使用这一套题的模拟赛即可。

你作为机房大佬，教练想请你帮他计算一下，他每天需要准备多少场模拟赛。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（13 points）：$n = m = k = 1$。
- Subtask 2（24 points）：$n = 1$。
- Subtask 3（24 points）：$m = 1$。
- Subtask 4（39 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,m,k \le 10^3$，$m \le k$，$1 \le a_{i,1} < a_{i,2} < \cdots < a_{i,m} \le k$。

## 样例 #1

### 输入

```
1 3 5
2 3 5
```

### 输出

```
0 1 1 0 1
```

## 样例 #2

### 输入

```
6 3 7
2 3 4
2 5 7
3 5 7
1 3 5
5 6 7
1 2 3
```

### 输出

```
1 2 3 1 3 1 1
```

## 样例 #3

### 输入

```
10 10 20
2 3 4 8 9 11 12 16 17 18
2 3 6 10 12 13 14 15 19 20
1 3 7 10 11 13 14 15 17 19
1 2 4 6 7 9 15 17 19 20
2 3 5 6 9 11 14 16 19 20
1 2 3 8 9 10 11 12 15 19
1 4 6 7 9 12 13 17 18 19
1 7 8 9 10 11 13 15 18 20
1 5 6 7 8 9 13 16 18 19
4 5 7 10 11 13 14 17 18 20
```

### 输出

```
1 2 2 3 2 2 4 3 3 3 3 4 2 1 3 1 2 2 2 1
```

# 题解

## 作者：Eason_AC2 (赞：289)

## Update
- $\texttt{2021.6.28}$ 对这篇题解的排版按照最新洛谷题解审核要求结合自己的题解格式进行了修改，并删去了一些废话。  
顺便，感谢各位对于这篇题解的大力支持！

## Content
请前往[原题](https://www.luogu.com.cn/problem/P5594)查看。

**数据范围：$1\leqslant m\leqslant n,k\leqslant 10^3$，$1\leqslant a_{i,1}<a_{i,2}<\dots<a_{i,m}\leqslant k$。**

## Solution
说实话，在这样的入门题中使用 $\texttt{set}$、$\texttt{vector}$ 确实有点小题大做，而且这种题解一般对于刚学 OI 的萌新来说很不友好。其实没必要这么复杂，**这道题目只要用一个二维 $vis$ 数组即可。** 那么这个 $vis$ 数组契机从何而来呢？

我们注意到题目中的这段话：

>教练需要为每一个人的每一次模拟赛做准备，为了减小工作量，如果在某一天有多个人打同一套模拟赛题，那么教练只需要在这一天准备一场使用这一套题的模拟赛即可。

如果你理解了这段话，这道题目就做完一大半了，剩下的就是代码实现的问题了。

这就是那个二维 $vis$ 数组的作用所在。

设这个数组中的元素 $vis_{i,j}$ 表示当 $vis_{i,j}=1$ 的时候表示第 $j$ 天已经准备了第 $i$ 套模拟题，这样就可以保证只在第一次在第 $j$ 天需要第 $i$ 套模拟题的时候统计进去，而且接下来如果还碰到同一天打同一套题目的时候不会重复计算。

每个同学的空闲天也可以用二维数组 $a$ 来保存，至于题目直接用 $1,2,...,m$ 表示就可以了，不需要再开数组。



所以这道题目就写完了。

## Code

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

int n, m, k, tot[1004], vis[1004][1004], a[1004][1004];

int main() {
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			scanf("%d", &a[i][j]);
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) {
			if(!vis[j][a[i][j]]) {
				vis[j][a[i][j]] = 1;
				tot[a[i][j]]++;
			}
		}
	}
	for(int i = 1; i <= k; ++i)
		printf("%d ", tot[i]);
	return 0;
}
```

---

## 作者：十十十十 (赞：182)

不知道各位大佬为什么要用两个二维数组，或是奇怪的结构体，还有set什么的

一个数组就可以了呀

一边输入一边记录就可以了，用一个bool数组记录，再用一个统计就好了

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[1005][1005];
int ans;
int main()
{
    int n,m,k;
    memset(a,0,sizeof(a));
    cin>>n>>m>>k;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int x;
            cin>>x;
            a[x][j]=1;
        }
    }
    for(int i=1;i<=k;i++)
    {
    	ans=0;
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]) ans++;
        }
        cout<<ans<<" ";
    }
}
```

---

## 作者：JimmyF (赞：160)


想必各位大佬们都想得太多了，这只是道红题！有必要开两个二维数组吗？ ——来自蒟蒻的心声！！！

这题直接用一个二维数组标记，表示第j题是否在第i天打卡，然后统计输出就可以了呀！

### 话不多说，上代码：

	#include<bits/stdc++.h>   //万能文件头
    using namespace std; 
    int n,m,k,a;       //按题目意思定义的变量
    int day[1010][1010];   //标记的数组
    int main()
    {
        cin>>n>>m>>k;      //输入人数n和需打卡数m以及天数k
        for(int i=1; i<=n; i++)   //有n人，所以循环n次
            for(int j=1; j<=m; j++) //每人有m天有空，所以循环m天
                scanf("%d",&a),day[a][j]=1; //输入第i个人在第a天打了第j次卡，并做标记
        for(int i=1; i<=k; i++)   //一共有k次输出，所以循环k次
        {
            for(int j=1; j<=m; j++)  //从1~最大打卡天数枚举，看第i场共有几人打卡
                day[i][j]+=day[i][j-1];   //部分和一下，虽然显得有点多余
            printf("%d ",day[i][m]);  //输出部分和的总量，也就是第1~k天分别对应的模拟赛场次
        }
        return 0; 
    } 

希望我的题解能帮到大家！~~最后不要脸的求个赞~~


---

## 作者：wpy233 (赞：47)

## 题目描述

X 校正在进行 CSP 前的校内集训。

一共有 n 名 OIer 参与这次集训，教练为他们精心准备了 m 套模拟赛题。

然而，每名 OIer 都有各自的时间安排，巧合的是，他们在接下来的 k 天中都恰好有 m 天有空打模拟赛。

为了方便管理，教练规定一个人**必须按顺序打完 m 套模拟赛题**。

比如，小 X 在接下来的第 2,3,5 天有空打模拟赛，那么他就必须在第 2 天打**第 1 套**模拟赛题，第 3 天打**第 2 套**模拟赛题，第 5 天打**第 3 套**模拟赛题。

教练需要为每一个人的每一次模拟赛做准备，为了减小工作量，如果在**某一天有多个人打同一套模拟赛题，那么教练只需要在这一天准备一场使用这一套题的模拟赛即可**。

你作为机房大佬，教练想请你帮他计算一下，他每天需要准备多少场模拟赛。

*****
*****
*****

注意加粗的字体。让我们一起来好好理解一下。

① 首先，每个人在m天内会按顺序打完m套模拟赛。

② 其次，如果一天多人要打同一套模拟赛，那么该天该套模拟赛只需准备一套。

好，然后我们来想想这两点应该怎么解决。

① 我们可以使用一个二维数组a[i][j]来存储，$i$表示第$i$个人，$j$表示第$j$天，a[i][j]的值则是**第i个人第j天的模拟赛编号**。

② 我们可以在输出答案时，新建一个$bool$类型的b数组，大小为$m$。每次统计时，如果当前没出现过，就将该模拟赛标记为$1$，$ans++$。统计完毕后，将数组清成初始状态，进入下一个数的统计。

但是是是。。。这个$i$,$j$,$k$还有那个$m$,$n$的，还有那个叫做$a$的二维数组，还有那个长度为$m$的标记$b$数组，这这这。。。标记哪个，处理哪个，比较哪个，输出哪个啊。。。 `_(¦3」∠)_`晕死惹qaq

好的。下面我们就来通过一张表，来帮大家~~节约生命~~理清思路。。。

![](https://cdn.luogu.com.cn/upload/image_hosting/jdmskwnb.png)

所以下面就贴出代码了qaq
```
#include <bits/stdc++.h>
using namespace std;
int n,m,k,x;
int a[1005][1005];//核心二维数组
bool b[1005];//标记
int main()
{
	cin>>n>>m>>k;//输入
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			a[i][x]=j;//赋值。第i个人第x天做的模拟赛编号
		}
	b[0]=1;//不能丢啊。。。
	for(int i=1;i<=k;i++)//输出。一共k天
	{
		for(int j=1;j<=m;j++) b[j]=0;//标记数组初始化
		int ans=0;
		for(int j=1;j<=n;j++)//一共n个人
			if(!b[a[j][i]]) //如果第j个人第i天没有做过第a[j][i]套卷子
				b[a[j][i]]=1,ans++;//ans++
		cout<<ans<<" ";//输出
	}
	return 0;
}

---

## 作者：Randolph、 (赞：24)

[P5594 【【XR-4】模拟赛】](https://www.luogu.org/problem/P5594)

洛谷10月月赛 II & X Round 4 Div.2前两道签到题还是很简单的，基本上是半小时内一遍过两题

看看题解，这题STL做法有用set输出size的和vector+unique的，我在打二维数组代码的时候突然发现可以用bitset代替

用二进制数记录每天每场比赛有无的情况（有的话就把那一位变成1），用bitset中的count输出二进制数1的个数即可

```cpp
#include<cstdio>
#include<bitset>
using namespace std;
int n,i,m,k,x;
bitset<1001> a[1001];
int main(){
	scanf("%d%d%d",&n,&m,&k);
	while (n--){
		for (i=1;i<=m;i++)
		 scanf("%d",&x),a[x][i]=1;
	}
	for (i=1;i<=k;i++)
	 printf("%d ",a[i].count());
}
```


---

## 作者：爱晚亭哦 (赞：18)

~~莫非全场就我 $O(n^3)$ ?~~

比赛时脑子抽了，只想到了$n^3$算法，结果跑了200+ms...

也许这种比较好理解？

~~好像也没人可以想到了~~

思路：一直搜一直搜，搜到了就+1...

~~好水的解释~~

Code:

```
#include<cstdio>
int n,m,k,ans,qwq;//qwq
int f[1001][1001];
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&f[i][j]);
	for(int i=1;i<=k;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int t=1;t<=n;t++)
				if(f[t][j]==i)//搜索，搜到了就退出，算一个优化？
				{//注意是f[t][j]=.=
					qwq=1;
					break;
				}
			if(qwq)
				ans++;//当天比赛加一
			qwq=0;
		}
		printf("%d ",ans);
		ans=0;//注意归0
	}
    //return 0？
}
```
~~PS:估计题解过得了，应为没人可以想到这么菜的复杂度了...~~

---

## 作者：loceaner (赞：10)

这是一道真·水题，会模拟就好了

$subtask1$:

$n = m = k = 1$，很明显，这个部分分的答案就是$1$，然后我们就顺利得到了$13$分的好成绩


后面的分数……似乎没有什么必要有，反正我是直接写的满分。那么我们来说一下满分思路

既然每个人在之后的$k$天中都有$m$天有空做模拟题，那我们就用一个结构体存第几天有空和第几套模拟题，如下

```cpp
struct node {
	int x, num；
    //x表示输入的编号，即第几天有空，num表示这一天应该做哪一套模拟题
}a[N][N];
```

然后$n^2$输入之后我们就可以直接处理了，我们用一个$vis$数组，$vis[i][j]$表示第$i$天第$j$套模拟题有没有用过，直接套两层循环，判断$a[i][j].x$这天$a[i][j].num$这套模拟题有没有用过，如果没有用过，就将$vis[a[i][j].x][a[i][j].num]$设为访问过，让$ans[i]++$，如果这天这套模拟题已经用过了就直接继续循环，时间复杂度$O(n^2)$,空间复杂度$O(n^2)$,然后这个题我们就做完了

是不是很水？？上代码$qwq$

```cpp
/*
By:Loceaner
*/
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

const int N = 1e3 + 11;

struct node {
	int x, num;
} a[N][N];

int n, m, k, ans[N], vis[N][N];

int main() {
	n = read(), m = read(), k = read();
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			a[i][j].x = read();
			a[i][j].num = j;
		}
	for(int i = 1; i <= n; i++) 
		for(int j = 1; j <= m; j++) 
			if(!vis[a[i][j].x][a[i][j].num]) {
				vis[a[i][j].x][a[i][j].num] = 1;
				ans[a[i][j].x]++;
			}
	for(int i = 1; i <= k; i++) printf("%d ", ans[i]);
	return 0;
}
```

---

## 作者：封禁用户 (赞：7)

# **这篇题解~~绝非正解~~**
## 正解楼下大佬们也打了
### 本蒟蒻~~瞎搞~~了一篇题解
#### 剩余的不多说，解释在代码里

```cpp
#include<bits/stdc++.h>//万能头不解释
using namespace std;
int n,m,k,b[1002][1002],a[1002],p;
int main()
{
	cin>>n>>m>>k;//输入
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>b[i][j];
	for(int i=1;i<=n;i++)
	{
      //这题有个坑，可能同一天有人做同一套题
		for(int j=1;j<=m;j++)
		{
			p=0;
			for(int q=1;q<i;q++)//往前找，看看是不是做同一套题
			{
				if(b[i][j]==b[q][j])break;
				else p++;
			}
			if(p==i-1)a[b[i][j]]++;
		}
	}
	for(int i=1;i<=k;i++)//输出
		cout<<a[i]<<" ";
	return 0;
}
```
# 本人打的代码可能有点丑，还请管理员给过

---

## 作者：叶枫 (赞：7)

## 写在前面
~~竟然没人发题解，我来水一波~~

这是一道模拟题，数据范围均$\le 1000$，于是我想到了$O(n^2)$级别的算法

# $Idea$
用$a[i][j]$表示第$i$个人第$j$天做的第$k$套题

$b[i][j]$表示第$i$天的第$j$套题是否有人做，有就是1，没有就是0

$ans[i]$表示第$i$天要做几套题。

最后统计下答案即可，代码中有注释

# $Code$
```cpp
比赛时空 19ms，4.87MB
int n,m,k;
int a[maxn][maxn],ans[maxn];
bool b[maxn][maxn];//忽略
int main(){
	n=read(); m=read(); k=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int x=read();
			a[i][x]=j;//第i个人第x天做的第j套试题
		}	
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			b[j][a[i][j]]=1; //第j天的第x套试题有人做
		}
	}
	for(int i=1;i<=k;i++)
	for(int j=1;j<=m;j++){
		ans[i]+=b[i][j];//统计答案，第k天要准备几套试题
	}
	for(int i=1;i<=k;i++) printf("%d ",ans[i]);
	return 0;
} 
```
$$
The \quad End
$$

---

## 作者：StudyingFather (赞：7)

用 `std::set`，可以方便地起到统计一天要准备多少模拟赛的作用。

我们只需将每个人当天要准备的模拟赛编号，插入当天的 `set` 当中，后面查询每天对应的 `set` 有多少元素即可。

```cpp
#include <cstdio>
#include <vector>
#include <set>
using namespace std;
vector<set<int> > v;
set<int> s;
int main()
{
 int n,m,k;
 scanf("%d%d%d",&n,&m,&k);
 for(int i=0;i<=k;i++)
  v.push_back(s);
 for(int i=1;i<=n;i++)
  for(int j=1;j<=m;j++)
  {
   int x;
   scanf("%d",&x);
   v[x].insert(j);
  }
 for(int i=1;i<=k;i++)
  printf("%d ",v[i].size());
 return 0;
}
```


---

## 作者：·Ansel (赞：3)

# ~~蒟蒻第一次发题解~~

## **用的纯模拟，愿各位大佬大大们轻喷，不断进步ing**

## 	Idea ： 
- **先按照题目将表格画出来**
* **根据题目要求 做题的顺序是一定的，按照数字排序1 2 3...**





```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

int n,m,k;  // n 几个人   m 几套题   k 一共几天 
int const maxn = 1e4;
int a[maxn][maxn];
int flag[maxn][maxn];
int ans[maxn];
bool t[maxn];

int main()
{
	cin >> n >> m >> k;
	int z = 0;
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= m; j++)
			cin >> a[i][j];
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= m; j++)
			flag[i][a[i][j]] = j;
	for (register int i = 1; i <= k; i++)
	{
		t[0] = 1;
		z = 0; 
		for (register int j = 1; j <= n; j++)
		{	
			if (t[flag[j][i]] == 0) z++;
			t[flag[j][i]] = 1;
		}
		ans[i] = z;
		memset(t,0,sizeof(t));	
	}
	for (register int i = 1; i <= k; i++)
	{
		cout << ans[i] << " " ;
	}	
}


```



---

## 作者：傅思维666 (赞：2)


## 题解：

我以为这题应该算个橙题......

~~还是蒟蒻太菜了~~

不过考场上瞬切是真的。

我们有两种数据排布方式：一种是按天排，第$1-k$天每天有多少场比赛，也就是我们需要的答案。

一种是按次排，第$1-m$次分别在哪天打，也就是题目中给出的矩z'z'z阵。

我们可以在输入的时候，对第$i$个人的第$j$次模拟赛所在的天数$map[i] [j]$维护一个数列，插入$j$，进行去重，最后序列的长度就是我们需要的答案。

$STL$大法好！

一个$set$容器（去重集合）就解决问题了。

代码如下：

```cpp
#include<cstdio>
#include<set>
using namespace std;
const int maxn=1001;
int map[maxn][maxn];
set<int> s[maxn];
int n,m,k;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&map[i][j]);
			s[map[i][j]].insert(j);
		}
	for(int i=1;i<=k;i++)
		printf("%d ",s[i].size());
	return 0;
}
```



---

## 作者：Alarm5854 (赞：1)

这道题真的是一道大水题~~不然怎么是红题~~，在每一套模拟赛中将那天的题目增加并将它标为已访问就行了，上代码。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
#define N 1000+10
using namespace std;
int n,m,k,a[N][N],day[N];
bool flag[N];
inline void read(int &x){//加一个快读，比赛卡常
	char c=getchar();x=0;
	while(c>57||c<48) c=getchar();
	while(c<58&&c>47) x=(x<<1)+(x<<3)+(c&15),c=getchar();
}
template<typename... args>inline void read(int &x,args&... rest){//不定参数函数
	read(x),read(rest...);
}
int main(){
	read(n,m,k);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			read(a[i][j]);
	for(int j=1;j<=m;++j){//注意循环开头是j而不是i
		memset(flag,0,sizeof(flag));//旗帜全部倒下(未访问)
		for(int i=1;i<=n;++i)
			if(!flag[a[i][j]])
				++day[a[i][j]],flag[a[i][j]]=1;//将那天的模拟赛题增加并将旗帜升起(已访问)
	}
	for(int i=1;i<=k;++i)
		printf("%d ",day[i]);
	return 0;
}
```

---

## 作者：Capitalism_Gao (赞：1)

### 一.算法思想

    1. 我们有两种数据排布方式：一种是按天排，第1~k天每天有多少场比赛，也就是我们需要的答案。

    2. 一种是按次排，第1~m次分别在哪天打，也就是题目中给出的矩阵。

    3. 我们可以在输入的时候，对第i个人的第j次模拟赛所在的天数map[i] [j]map[i][j]维护一个数列，插入j，进行去重，最后序列的长度就是我们需要的答案。

### 二.STL大法好！

一个set容器（去重集合）就解决问题了。
```
#include<cstdio>
#include<set>
using namespace std;

const int maxn=1001;
int map[maxn][maxn];
set<int> s[maxn];
int n,m,k;

int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            scanf("%d",&map[i][j]);
            s[map[i][j]].insert(j);
        }
    for(int i=1;i<=k;i++)
        printf("%d ",s[i].size());
    return 0;
}
```


---

## 作者：_zzx (赞：1)

这道题可以用set做


```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
	set<int >s[1002];
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			int a;
			cin>>a;
			s[a].insert(j+1);
		}
	}
	for(int i=1;i<=k;i++){
		cout<<s[i].size()<<' ' ;
	}
	return 0;
}
```


---

## 作者：VenusM1nT (赞：1)

模拟。  
红题诶（  
对于这题我们可以直接用 $\text{used}_ {i,j}$  表示第 $i$ 天有没有举行第 $j$ 场模拟赛，对于每个人的每场模拟赛进行判断即可。
```cpp
#include<bits/stdc++.h>
#define MAXN 1005
#define reg register
#define inl inline
using namespace std;
int n,m,k,a[MAXN][MAXN],ans[MAXN];
bool used[MAXN][MAXN];
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=1;j<=m;j++) scanf("%d",&a[i][j]);
	}
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=1;j<=m;j++)
		{
			if(!used[a[i][j]][j])
			{
				used[a[i][j]][j]=1;
				ans[a[i][j]]++;
			}
		}
	}
	for(reg int i=1;i<=k;i++) printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：ShineEternal (赞：1)

### [$my blog$](https://blog.csdn.net/kkkksc03)


## solution：
其实就是一道模拟，关键就是刚开始窝一看到输入就有些不理解，于是就想复杂了，但是仔细想想~~看看排行榜~~发现还是很简单的。

也正是如此，我给大家提供一下每一个subtask的得分写法。

当然，其实$subtask2,3$是可以合并一下的（显然是因为代码一样）
## code：

```cpp
#include<cstdio>
using namespace std;
int a[1005][1005];
int mp[1005][1005],mp1[1005];
int ans[1005];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			mp1[a[i][j]]=1;
			if(mp[a[i][j]][j]==0)
			{
				ans[a[i][j]]++;
				mp[a[i][j]][j]=1;
			}
		}
	}
	if(n==1&&m==1&&k==1)//13pts
	{
		printf("1\n");
		return 0;
	}
	if(n==1)//24pts
	{
		for(int j=1;j<=k;j++)
		{
			if(mp1[j]==1)
			{
				printf("1 ");
			}
			else
			{
				printf("0 ");
			}
		}
		return 0;
	}
	if(m==1)//24pts
	{
		for(int j=1;j<=k;j++)
		{
			if(mp1[j]==1)
			{
				printf("1 ");
			}
			else
			{
				printf("0 ");
			}
		}
		return 0;
	}
	for(int i=1;i<=k;i++)//39pts
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```

---

## 作者：1saunoya (赞：1)

很多人这题都是用 $set$ 水过去的。。。

虽然说可行 但是我觉得用$vector$ 就可以了


```cpp
// Isaunoya
#include<bits/stdc++.h>

#define pb push_back
using namespace std ;

using LL = long long ;
using uint = unsigned int ;

template < typename T > inline void read(T & x) { x = 0 ; int f = 1 ; register char c = getchar() ;
  for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
  for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
  x *= f ;
}

template < typename T > inline void print(T x) {
  if(! x) { putchar('0') ; return ; }
  static int st[105] ;
  if(x < 0) putchar('-') , x = -x ;
  int tp = 0 ;
  while(x) st[++ tp] = x % 10 , x /= 10 ;
  while(tp) putchar(st[tp --] + '0') ;
}
template < typename T > inline void print(T x , char c) { print(x) ; putchar(c) ; }

template < typename T , typename ...Args > inline void read(T & x , Args & ...args) { read(x) ; read(args...) ; }

#define int LL

template < typename T > inline void sort( vector < T > & v) { sort(v.begin() , v.end()) ; return ; }
template < typename T > inline void unique( vector < T > & v) { sort(v) ; v.erase(unique(v.begin() , v.end()) , v.end()) ; }

template < typename T > inline void cmax(T & x , T y) { if(x < y) x = y ; return ; }
template < typename T > inline void cmin(T & x , T y) { if(x > y) x = y ; return ; }

const int Mod = 1e9 + 7 ;
inline int QP(int x , int y) { int ans = 1 ;
  for( ; y ; y >>= 1 , x = (x * x) % Mod)
    if(y & 1) ans = (ans * x) % Mod ;
  return ans ;
}

template < typename T > inline T gcd(T x , T y) { if(y == 0) return x ; return gcd(y , x % y) ; }

int n , m , k ;
vector < int > v[1005] ;
signed main() {
  read(n , m , k) ;
  for(register int i = 1 ; i <= n ; i ++ )
    for(register int j = 1 ; j <= m ; j ++ ) { int d ; read(d) ; v[d].pb(j) ; }
  for(register int i = 1 ; i <= k ; i ++ ) unique(v[i]) ;
  for(register int i = 1 ; i <= k ; i ++) print(v[i].size() , ' ') ;
  return 0 ;
}
```

---

## 作者：AquaRio (赞：0)

**题目传送门：**[\[XR-4\] 模拟赛](https://www.luogu.org/problem/P5594)

**Description**

$n$ 个人要打 $m$ 场模拟赛，每个人列出自己第 $i$ 按照顺序打模拟赛，求每天要举行多少模拟赛。

**Solution**

这题比较简单，是签到题。

根据题意，我们读入后竖着扫，扫 $m$ 遍，每一列出现的数字就会对对应的天数有一次贡献，并且在每一列最多只有一次贡献。

**Code**

```cpp
/*
	Name: [XR-4] 模拟赛 
	Author: Lovely_XianShen
	Date: 20/10/19 19:18
*/

#include<bits/stdc++.h>
using namespace std;

int n,m,k;

int ans[1005];
int a[1005][1005];
bool used[1005];

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=m;i++){
		memset(used,0,sizeof used);
		for(int j=1;j<=n;j++){
			if(!used[a[j][i]]){
				used[a[j][i]]=1;
				ans[a[j][i]]++;
			}
		}
	}
	for(int i=1;i<=k;i++)
		cout<<ans[i]<<" ";
	return 0; 
}
```

---

## 作者：Create_Random (赞：0)

月赛签到题

~~本蒟蒻只会写签到题题解~~

本蒟蒻思路：

每一列都是第几天所有人可以打的模拟赛

所以建一个桶

把每一列有的模拟赛加入桶中就可以了

不要忘了去重！！！

贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010][1010];
int tmp[1010];
int ans[1010];
int n,m,k;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			tmp[j]=a[j][i];//把每一列存入临时数组
		}
		sort(tmp+1,tmp+n+1);
		unique(tmp+1,tmp+n+1);//勿忘去重！！！
		ans[tmp[1]]++;
		for(int j=2;j<=n;j++)
		{
			if(tmp[j-1]<tmp[j])
			{
				ans[tmp[j]]++;//往桶里加要准备的模拟赛
			}
			else
			{
				break;//直接终止即可
			}
		}
	}
	for(int i=1;i<=k;i++)
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```


---

## 作者：Lacrymabre (赞：0)

拿到题目：wo这么简单！（结果调了2h）
这道题目实际上是一个奇怪的桶排，统计矩阵中有多少列中出现了某个数字，相同数字在相同列只统计一次。

这样就很简单了（爆水签到）

```
#include<iostream
#define ll unsigned long long

using namespace std;

const int mod=10;
int n,m,k,day,a,b;
ll tab[100001],add[10001][10001];
bool flag[10001][10001];

int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>day;
			add[i][j]=day;
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(!flag[i][add[j][i]]) tab[add[j][i]]++,flag[i][add[j][i]]=1;//一定要j,i下标，我蛙了一次就是因为这个qwq
			//	for(int i=1;i<=k;i++) cout<<tab[i]<<" ";cout<<endl;
		}
	}
	for(int i=1;i<=k;i++) cout<<tab[i]<<" ";
}
```
![赛中AC图](https://cdn.luogu.com.cn/upload/image_hosting/7xlpspjb.png)

---


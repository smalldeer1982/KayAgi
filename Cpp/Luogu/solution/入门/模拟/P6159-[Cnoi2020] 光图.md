# [Cnoi2020] 光图

## 题目背景

> 简洁中蕴含着伟大。

Cirno 不经意地把一个内部完全反射的圆分成了 $12$ 等分，等分点分别记作 $A_0$, $A_1$, $A_2$, $\cdots$ , $A_{11}$。

随后，她不经意地将一束光从一点发出，朝向另一点，重复，反射，迭代，便得到了一幅美妙的光图。

这一切都发生在不经意之间。

她不经意地发现了这一幕，并且不经意地记下了这个不经意的结论，又在某一刻不经意地回忆起。

幻想乡的每一天一切都是这么不以为意，多好的一天啊！

## 题目描述

Rumia 有一个单位圆，被分成 $n$ 等分，等分点分别记作 $A_0$, $A_1$, $A_2$, $\cdots$ , $A_{n-1}$。

现在她从 $A_0$ 向 $A_p$ 发射一束光，经过 $k$ 次反射，到达了 $A_t$。

Rumia 想知道 $t$ 的值，由于 Cirno 并不想帮她，所以 Rumia 转而求助于你。

## 说明/提示

### Sample1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/x7j0roeg.png)

### 后置物理知识
 - **连续曲线反射规律** : 入射光线与出射光线关于入射点在曲线上切线夹角相等。

### 数据范围约定

**「本题采用捆绑测试」**

 - Subtask1( $80\%$ ) : $n, k \le 10^6$
 - Subtask2( $20\%$ ) : $n, k \le 10^9$

对于 $100\%$ 的数据 : $0 < p < n \le 10^9$, $0 < k \le 10^9$。

### 后记
 - Cirno 得到的光图就是传说中的**十二芒星图**。

## 样例 #1

### 输入

```
12 5 2```

### 输出

```
10```

## 样例 #2

### 输入

```
1000 342 3472844```

### 输出

```
648```

# 题解

## 作者：chenpengda (赞：40)

# 初中物理知识。

对称取模即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	unsigned long long n,p,k;
	cin>>n>>p>>k;
	cout<<(p*k)%n;
	return 0;
}
```

为什么这样是对的呢？

因为第一次，光从$A_0$射到了$A_p$。根据“入射光线与出射光线关于入射点在曲线上切线夹角相等”，下一次就会射到$A_2p$，每一次都在这个圆周上走$p$的长度。

所以总共走了$p*k$的长度，取模$n$即可。

---

## 作者：幻之陨梦 (赞：8)

这题是一个良心的签到题

$\textbf{解题思路：}$首先看了一下数据范围发现 $n\le10^9$ $k\le10^9$,所以按这个数据范围，我们不能运用到循环节，所以我想到了递推也就是找规律。不难发现每次的折射其实就是将下标加上 $p$ 各单位再取模 $n$。这样我们就得到了递推公式：$\text{ans = ((p mod n) * (k mod n)) mod n}$

$\text{AC Code:}$
```cpp
#include<cstdio>//为了节省，所以不开万能头文件
#define ll long long//宏定义 ll 为 long long 类型
using namespace std;//标准数据库
ll n,p,k,ans;
int main()
{
    scanf("%lld%lld%lld",&n,&p,&k);//输入
    ans=((p%n)*(k%n))%n;//运用上面讲过的公式
    printf("%lld",ans);//输出答案
    return 0;
}
```
~~ps:不开 long long 见祖宗~~

---

## 作者：PrincessYR✨～ (赞：7)

我们先来看一下图

![](https://cdn.luogu.com.cn/upload/image_hosting/7fw7sk30.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

开始从0射到5，相隔5个点

以下是窝的证明过程

![](https://cdn.luogu.com.cn/upload/image_hosting/b7wh9qsi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

由此我们可以知道，每次反射相隔的点都一样；

那么我们可以从零点一直加上相隔的点数，反射几次就加几次，最后再模点的个数；

## （注意是最后在模，否则每次都执行，会托时，会TLE）。

因为一开始一直累加，那么累加的值会大于点的个数。

# 另外还有一个优化。

十分重要。我们一直画下去，可以发现该图像以12即点的个数为一循环，我们可以先将k模点的个数，就可以避免一直循环，从而节省时间

下面上代码：
```
#include<iostream>
#include<cstdio>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void write(int a){
   if(a<0) putchar('-'),a/=-1;
   if(a>9) write(a/10);
   putchar(a%10+'0');
}
long long n,p;
long long k,g;
int main()
{
	n=read();p=read();k=read();
	g=p;
	k=k%n;
	for(int i=2;i<=k;i++)
	{
	    p=p+g;
	    
	}
	p=p%n;
	write(p);
	return 0;
}
```


---

## 作者：zhanghzqwq (赞：6)

这是一道找规律的好题，就算不知道折射公式，也可以发现它每次反射都是在圆圈中前进了相同的格子数（d）。

我第一眼看到这道题就是想的暴力，但$n<=10^9$，用暴力会处在死亡的边缘。于是我们来个常数优化：把循环的次数除以一万，然后每次加上一万个d，开$long long$就不会爆。最后再把小于万的那部分再循环一次就好了。11ms通过此题。

AC代码如下：

```cpp
#include<iostream>
using namespace std;
int main(){
	long long n,p,k;
	cin>>n>>p>>k;
	long long d=p-0;//求公差
	long long t=0;
	int cnt=k/1000; //算次数
	for(int i=0;i<cnt;i++){//第一次循环
		t+=1000*d;
		t%=n;
	}
	for(int i=0;i<k%1000;i++){//再循环
		t+=d;
		t%=n;
	}
	cout<<t<<endl;//输出
	return 0; //华丽的结束
}
```


---

## 作者：Lylighte (赞：6)

> 伟大中蕴含着简洁。

#### _2020/03/01_

作为一名初中 OIer，第一眼看不明白这句话：

> **连续曲线反射规律** : 入射光线与出射光线关于入射点在曲线上切线夹角相等。

但不管怎样，我至少学过光的反射定律：

> 反射光线、入射光线与法线在同一平面上；反射光线和入射光线分居在法线的两侧；反射角等于入射角。

~~你谷甚可论物理。~~

这是一张光的反射示意图：

![图片有点糊见谅](https://cdn.luogu.com.cn/upload/image_hosting/4pjp97ie.png)

既然光图有美感，那么它的本质——光的反射——也会有美感：对称！

反射光线与入射光线关于法线对称。

那么，在光图中截取两次连续的反射（这里直接用题面的图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/x7j0roeg.png)

想象出反射面，它垂直于入射点与圆心的连线（一条半径）。再结合圆的轴对称性，可知，这个光图也是对称的。那么对应的圆弧长也相等。所以反射一次“越过”的弧长为定值。

把握反射的含义，这个题目可以理解成：

把 $N$ 个点围成一个圈，逆时针标号 $A_0$，$A_1$，$A_2$，$\cdots$，$A_{n-1}$。从 $A_0$ 开始，逆时针通过 $p$ 个点，重复 $k$ 次后到达一个点 $A_t$，求 $t$ 的值。

可以模拟走一遍。一个变量 `x` 记录当前点的坐标，重复 $k$ 次更新 `x`，大致这样写：

```cpp
	int x=0;
	for(int i=1; i<=k; i++)
		x = (x+p)%n ;
```

当然，$k$ 最大为 $10^9$，这样可能会超时。其实无需加一次就取模，全部加起来再取模能得到同样的效果。$k$ 个 $p$ 相加，相当于 $k\cdot p$，省一层循环。

最后注意数据范围，开一下 `unsigned long long` 就结束了：

```cpp
#include <bits/stdc++.h>
using namespace std;
unsigned long long n, p, k;
int main(){
	cin >> n >> p >> k;
	cout << (p*k)%n << endl; 
	return 0;
}
```

End.


---

## 作者：Aw顿顿 (赞：6)

这道题比较简单，我们需要了解以下知识点：

来自百度百科的物理知识：

https://baike.baidu.com/item/%E6%8A%98%E5%B0%84%E8%A7%92/9403092


https://baike.baidu.com/item/%E5%85%A5%E5%B0%84%E8%A7%92

那么转换为程序思路：

$n,p,k$ 三个整数：

- 折射 $k$ 次，初始为 $0$ 每次角度为 $p$ 。

- 那么就等于每次 $t+p\ \bmod n$ ，因为总共只有 $n$ 个角，所以要对 $n$ 取模。

那么成功 TLE 的程序如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,k,t;
inline long long read(){
    long long s=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*f;
}
int main()
{
	n=read();
	p=read();
	k=read();
	for(register int i=0;i<k;i++){
		t+=p%n;
		t%=n;
	}
	printf("%lld\n",t);
	return 0;
}
```

尽管用了快读，可是循环部分还是太耗时了，于是我们可以把循环转换为：

```cpp
t+=p%n*k%n;
```

那么附上 AC 程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,k,t;
inline long long read(){
    long long s=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*f;
}
char f[200] ;
inline void prt(long long x)
{
    long long tmp=x>0?x:-x;
    if(x<0)putchar('-');
    long long cnt=0;
    while(tmp>0)
	{
        f[cnt++]=tmp%10+'0';
        tmp/=10;
    }
    while(cnt>0)putchar(f[--cnt]);
}
int main()
{
	n=read();
	p=read();
	k=read();
	t+=p%n*k%n;
	prt(t);
	return 0;
}
```

快读快输板子如上，可以借鉴，不要抄袭！

---

## 作者：sid_shi1 (赞：3)

[P6159 [Cnoi2020]光图](https://www.luogu.com.cn/problem/P6159)

很简单的一道题，通过研究样例，我们会发现光线先是从 $0$ 号点射向 $p$ 号点,然后再射到 $p\times2$ 号点，然后是 $p\times3$ 号点，以此类推。

那么射到的第 $k$ 个点应该就是编号为 $p\times k$ 的点，不过注意一共只有 $n$ 个点，答案只需再模 $n$ 就行了。

然后就是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,k,ans;//注意ans一定要开long long
int main(){
	cin>>n>>p>>k;
	ans=p*k%n;
	cout<<ans;
	return 0;
}
```

---

## 作者：Lithium_Chestnut (赞：2)

很简单，完全靠分析样例做对。

直接输出$p$*$k$%$n$，完事！

唯一难点是要开```long long```。

$Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,k;
int main()
{
	cin>>n>>p>>k;
	cout<<p*k%n;
	return 0;
}
```


---

## 作者：_cmh (赞：1)

简单啊。。。

因为每次反射都是：一开始从$A_0$射向$A_p$，以后就是$A_{2*p}$，但要记得%n

记得要开long long，不然会爆int

那么很简单，反射$k$次就是$p*k$ $mod$  $n$

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
long long n,p,k;
int main(){
    cin>>n>>p>>k;
    cout<<(p*k)%n;
    return 0;
}
```

## 求赞！！！

~~（蒟蒻已经逃跑了，没法和泥萌说再见了）~~

---

## 作者：wmy_goes_to_thu (赞：1)

这道题我用的是 O2 + 暴力！ 

通过反射可知道，下一个点和上一个点的平均数是这个点，如果上一个点是 $a$，这个点是 $b$，那么下一个点是 $2 \times b + a$，直接枚举第几步递推即可。别忘了要取模。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,p,k,wz=0;
	cin>>n>>p>>k;
	for(int i=1;i<=k;i++)
	{
		long long rr=p;
		p=2*p-wz;
		wz=rr;
	}
	cout<<(wz%n+n)%n;
	return 0;
}
```

---

## 作者：lndjy (赞：1)

找规律大法吼啊

观察样例的图，发现0->5->10,然后再次模拟发现是3，正好是（10+5）%12，再试几次全部满足规律，就可以直接乘了。

注意:**不开longlong见祖宗！！！**

```cpp
#include<iostream>
using namespace std;
long long n,p,k;
int main()
{
	cin>>n>>p>>k;
	cout<<(p*k)%n;
	return 0;
}
```


---

## 作者：文·和 (赞：1)

~~这题显然暴力鸭~~，我们可以发现 $ \ {A_{i+1}}$ 和$ \ {A_{i+3}}$ 关于 $ \ {A_{i+2}}$ 是对称的，所以递推公式也很好求， $ \ {A_{i+2}=(A_{i+1}*2+n-A_{i})\mod n}$ 。

求出公式，直接敲代码。

```
#include <bits/stdc++.h>
using namespace std;
int n,p,k,last1,last2;   //last1和last2用于存A[i-1]和A[i-2]
int main(){
scanf("%d %d %d",&n,&p,&k);
k%=n;                 //小小的优化，答案必定是循环的
for(register int i=1;i<k;i++){   //注意一开始就是已经反射一次的状态
	last1=p;
	 p=(p*2+n-last2)%n;
	 last2=last1;
}         //递推
printf("%d",p);
return 0;
}
```

但你会发现，就是上面的卡常代码也TLE了三个点，所以肯定有其它更快的思路。

我们参照上面的思路， $ \ {A_{i+1}}$ 和$ \ {A_{i+3}}$ 关于 $ \ {A_{i+2}}$ 是对称的。它意味着什么？意味着每一次反射后往前走增加的距离都是一样的，那这个距离是多少呢？就是p!，所以总共往前的距离就是p*k

于是代码就简单了......

```
#include <bits/stdc++.h>
using namespace std;
long long n,p,k; //不开ll见祖宗
int main(){
cin>>n>>p>>k;
cout<<p*k%n;     //记得%n哦
return 0;
}
```

谢谢~



---

## 作者：Fatalis_Lights (赞：0)

良心签到题。

## Solution

每一次，射向的点的下标加 $p$ 。

这个操作做了 $t$ 次，所以下标变为 $t\times p$。

而因为这是个环，所以对 $n$ 取一次模。

所以 $Ans=tp\operatorname{mod}n$ 。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,k;
int main(){
	cin>>n>>p>>k;
	cout<<(p*k)%n<<endl;
	return 0;
}
```

---

## 作者：DreamFox (赞：0)

由样例解析可知，对于第$x$个坐标，一次反射就会到第$(x+p)$ $mod$ $n$个坐标。

由此可见，经过$k$次反射后，$t$既是$(p*k)$ $mod$ $n$。

记得，要开$long$ $long$

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,p,k;
	cin>>n>>p>>k;
	long long sum=(p*k)%n;
	cout<<sum<<endl;
	return 0;
}
```


---

## 作者：xh39 (赞：0)

显然反射一次相当于目前的点+p。因为反射的角度一样,这次从0到了p,那么为保证角度一样,这一次也得+p。

理解就行,严谨证明似乎有些难。
```cpp
#include<iostream>
using namespace std;
int main(){
	long long n,p,k;
	cin>>n>>p>>k;
	cout<<p*k%n;
	return 0;
}
```

---

## 作者：Fairicle (赞：0)

有一个比较好理解的思路：假设一开始从 $A_0$ 射向了$A_p$，那么下一次就会从 $A_p$ 射向 $A_{2*p}$ （因为对称），同时也是要取模的。

所以共反射了 $k$ 次（严格意义上不算反射了 $k$ 次，但是这样便于理解），答案就是 $p*k$ $mod$ $n$

显然 $p*k$ 不会爆long long，愉快输出即可。

```cpp
int main()
{
	long long n=read();
	long long p=read();
	long long k=read();
	printf("%lld",(p*k)%n);
    return 0;
}
```


---


# [COCI 2008/2009 #3] PET

## 题目描述

在一项受欢迎的比赛 _Dinner for Five_ 中，有 $5$ 名选手和 $4$ 名裁判，这 $4$ 个裁判会对每一道菜用 $1 \sim 5$ 的数字进行评估，每位选手的总分即是所有裁判评分的总和，参赛者按照其评分顺序从 $1$ 到 $5$ 进行编号。

请你编写一个程序，输出评分最高的选手的编号以及其分数。

## 说明/提示

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) *T1 PET*。**


## 样例 #1

### 输入

```
5 4 4 5
5 4 4 4
5 5 4 4
5 5 5 4
4 4 4 5 
```

### 输出

```
4 19 
```

## 样例 #2

### 输入

```
4 4 3 3
5 4 3 5
5 5 2 4
5 5 5 1
4 4 4 4 
```

### 输出

```
2 17 
```

# 题解

## 作者：过往梦魇之殇 (赞：10)

### [题目传送门](https://www.luogu.com.cn/problem/P6408)

思路：

先将每一个人的裁判评分求和

再降序排列，输出第一个人的名字和分数和

###### ~~毕竟是红题吗，还是很水的~~

代码：

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>//伪万能头
using namespace std;
in int read()//快读
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)//快输
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
struct node{//结构体，将选手名字和分数和结合在一起
	int sum,id;
}qwq[6];
int a[6][5];//输入用
bool cmp(node x,node y){//降序排列
	return x.sum>y.sum;
}
int main()
{
	for(re int i=1;i<=5;++i){
		qwq[i].id=i;//名字赋好
	}
	for(re int i=1;i<=5;++i){
		for(re int j=1;j<=4;++j){
			a[i][j]=read();//读入
		}
	}
	for(re int i=1;i<=5;++i){
		for(re int j=1;j<=4;++j){
			qwq[i].sum+=a[i][j];//求和
		}
	}
	sort(qwq+1,qwq+6,cmp);//降序排列
	write(qwq[1].id);
	printf(" ");
	write(qwq[1].sum);//输出
    return 0;
}//完美收官
```

###### 制作不易，求资瓷！

> Thanks For Watching!

---

## 作者：LinkZelda (赞：9)

## 这题可以用来练结构体，和自定义 $sort$ ！
- 我们可以声明一个“选手”( $player$ )型的结构体，来存储每一个人的**分数**和他的**号码**。
```cpp
struct player//声明一个结构体用来存选手的号数和分数 
{
	int name,score;//顾名思义，name是号码，score是分数
}; 
```

- 然后怎么找最高分的人呢？ 我们可以自定义一个 $bool$ 类型的 $cmp$ 函数，自定义 $STL$ 排序。
```cpp
bool cmp(player a,player b)//自定义结构体排序函数（按分数从大到小排序） 
{
	return a.score>b.score;
 } 
```

- 因为我们定义排序函数是从大到小排的，所以第一个人的分数一定是最大的，那我们输出就好了。

- 完整代码（含注释）：
```cpp
#include<iostream>
#include<algorithm>//使用 sort ，要调用 algorithm 库 
using namespace std;
struct player//声明一个结构体用来存选手的号数和分数 
{
	int name,score;
}; 
bool cmp(player a,player b)//自定义结构体排序函数（按分数从大到小排序） 
{
	return a.score>b.score;
 } 
int main()
{
	player a[10];//声明“选手”类型变量 
	int s1,s2,s3,s4;//用于输入每个人的分数 
	for(int i=1;i<=5;i++)//i即为选手号数 
	{
		cin>>s1>>s2>>s3>>s4;
		a[i].name=i;
		a[i].score=s1+s2+s3+s4; 
	}
	sort(a+1,a+6,cmp);//自定义排序
	cout<<a[1].name<<' '<<a[1].score;//因为是从大到小排，所以第一个人一定是分数最高的 
	return 0; 
 } 
```



---

## 作者：dead_X (赞：9)

## 思路简述
* 分别统计每个人的得分。

因为最后只需要输出得分最高的人的得分，所以直接记录最大值就行了。

用不用循环都可以。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int Max=-1,id=0;
    for(int i=1; i<=5; i++)
    {
        int a,b,c,d,sum;
        cin>>a>>b>>c>>d;
        sum=a+b+c+d;
        if(sum>Max) Max=sum,id=i;
    }
    cout<<id<<' '<<Max;
}
```

---

## 作者：Inlay1158 (赞：2)

这道题目非常的简单，学过循环的新人都知道怎么做，只需要循环5次，每次输入四个数，比较目前的答案，如果大于，则更换最大值，并把标号更换成当前这个，为了对新人友好一点，我把一些比较难的地方给注释掉了（其实就是快读和输入输出对新人不友好）。
```cpp
#include<cstdio>
using namespace std;
/*
FILE *fin, *fout;
inline int read(int &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
inline int write(char c) {
	return fputc(c, fout), 1;
}
template<class T, class... Args> inline int write(T x, Args... args) {
	return write(x) + write(args...);
}
*/
int a, b, c, d, num, ans;
int main() {
/*
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6408.in", "rb");
	fout = fopen("P6408.out", "wb");
	#endif
*/
	for (int i = 1; i <= 5; ++i) {
		scanf("%d%d%d%d", &a, &b, &c, &d);//read(a, b, c, d);
		int tot = a + b + c + d;
		if (ans < tot) ans = tot, num = i;
	}
	printf("%d %d", num, ans);//write(num, ' ', ans);
	return 0;
}
```

---

## 作者：一只书虫仔 (赞：1)

[P6408 [COCI2008-2009#3] PET](https://www.luogu.com.cn/problem/P6408)

真的是水题。

首先，进行一次 $1$ 到 $5$ 的循环，每次循环输入四个数 $a$ ，$b$ ，$c$ ，$d$ ，然后把 $a+b+c+d$ 和 $\text{ans2}$ 作比较（$\text{ans2}$ 初始值为 $0$），如果比 $\text{ans2}$ 大的话就让 $\text{ans1}$ 更新为 $i$ ，$\text{ans2}$ 更新为 $a+b+c+d$ ，最后进行一遍一遍的覆盖，输出 $\text{ans1}$ 和 $\text{ans2}$ 就是答案。

Code：

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	int ans1, ans2 = 0;
	for (int i = 1; i <= 5; i++) {
		int a, b, c, d;
		scanf("%d%d%d%d", &a, &b, &c, &d);
		if (a + b + c + d > ans2) {
			ans1 = i;
			ans2 = a + b + c + d;
		}
	}
	printf("%d %d", ans1, ans2);
	return 0;
}
//水题完事！
```

需要注意的点：

- 记住是 `a + b + c + d > ans2` 不是 `a + b + c + d >= ans2`
- 记住 `ans2` 初始值要设为 $0$
- `long long` 到无所谓（题目中说了不超过 $5$ 的正整数）

---

## 作者：DreamFox (赞：1)

本题思路：

由于每位选手的分数是裁判们的分数总和，所以我们只要循环$5×4$次，每次用数组记录选手们的总分，然后循环一遍找出最高分和创造最高分的选手的编号即可。

$AC$ $Code$
```cpp
#include<iostream>
using namespace std;
int a[6],b,maxx=0,k=0;
int in(){int aa;cin>>aa;return aa;}
int main(){
	for(int i=1;i<=5;i++)for(int j=1;j<=4;j++)a[i]+=in();
	for(int i=1;i<=5;i++)if(a[i]>maxx)maxx=a[i],k=i;
	cout<<k<<" "<<maxx<<endl;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/32893113)

---

## 作者：SisconHL (赞：0)

~~题外话：看到题目名忽然想到PET的悲惨经历~~~

主要就是用“打擂台”法找最大值，复杂度可达 $O(n)$，伪代码如下：

```plain
arr a[n]
max ← minn # minn是一个极小值
for i from 0 to n:
	if a[i] > max:
    		max ← a[i]
return max
```

代码就很好写了，注意在更新是把标号也更新了。

所以会长成这个样子：

```plain
arr a[n]
max ← minn # minn是一个极小值
a=0
for i from 0 to n:
	if a[i] > max:
    		max ← a[i]
         	a ← i
return a,max
```
我们只需要把四项累加得到 $a$ 数组。

这里还有个trick：只用存储最大值和一个临时变量而非数组，可以边读边处理。

```cpp
#include<iostream>

using std::cin;
using std::cout;

int main( void )
{
	int buf , buff;
	int Max = -1145141919;
	int now = -1;
	for( register int i = 0 ; i < 5 ; i++ )
	{
		buf = 0;
		for( register int j = 0 ; j < 4 ; j++ )
		{
			cin >> buff;
			buf += buff;
		}
		if( buf > Max )
		{
			Max = buf;
			now = i + 1;
		}
	}
	cout << now << " " << Max;
}
```

---


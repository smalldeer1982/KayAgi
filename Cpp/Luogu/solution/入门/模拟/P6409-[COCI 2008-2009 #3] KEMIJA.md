# [COCI 2008/2009 #3] KEMIJA

## 题目背景

Luka 天天上课走神。

## 题目描述

Luka 又在化学课上鬼混了！他不是在写化学方程式，而是在写一句奇怪的话。

Luka 通过在每一个元音字母（$\texttt{a}$，$\texttt{e}$，$\texttt{i}$，$\texttt{o}$，$\texttt{u}$）后面加上 $\texttt{p}$ 再加上原来的元音字母的方式加密这一个单词，如  $\texttt{kemija}$ 变成  $\texttt{kepemipijapa}$， $\texttt{paprika}$ 变成  $\texttt{papapripikapa}$ 。

老师想知道调皮的 Luka 写了些什么，请你帮助老师，写出一个解密程序。

## 说明/提示

#### 数据范围

令 $|s|$ 为 $s$ 的长度，则 $1 \leq |s| \leq 100$，数据保证字符串的内容一定是小写字母或空格。


#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) *T2 KEMIJA*。**



## 样例 #1

### 输入

```
zepelepenapa papapripikapa```

### 输出

```
zelena paprika```

## 样例 #2

### 输入

```
bapas jepe doposapadnapa opovapa kepemipijapa```

### 输出

```
bas je dosadna ova kemija```

# 题解

## 作者：过往梦魇之殇 (赞：23)

### [题目传送门](https://www.luogu.com.cn/problem/P6409)

~~一开始代码bug了，已修改，重新提交~~

这是一道密码题 ~~（毕竟加密的规则都告诉你了，那这就是一道水题$doge$）~~

**思路**：

类似尺取法（并不恰当的类比），这里的尺子长度为$2$就可以做了

下面举一例：

> 原文：$cn$ $ak$ $ynoi$ $and$ $tui$ $osu$
  
> 加密后：$cn$ $apak$ $ynopoipi$ $apand$ $tupuipi$ $oposupu$

因为是倒推原文 ~~（让你加密的话依然水）~~

所以我们可以先找$'p'$，再找它对应的那个元音

注意：不是找到任意一个$'p'$就对它进行删去处理，一定要有元音匹配。~~（废话，这是显然的）~~

思路理清，只要代码不敲错，这种~~水~~题目肯定能$A$的

这里不需要一下子把字符串读完，可以一个一个字符读（长度小于等于$100$怕啥）

记录上一位和这一位，如果该位是$'p'$且上一位是元音，那么下一位不存，直接$getchar()$读掉，存下下位，以此类推。

（未匹配上的读入后输出即可，无需存储）

**代码展示：**

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
int main()
{
	char last='\0',now;
	while(now!='\n'){
		now=getchar();
		if(now=='p'){
			if(last=='a'||last=='e'||last=='i'||last=='o'||last=='u'){
				getchar();
				now=getchar();
			}
		}
		putchar(now);
		last=now;
	}
    return 0;
}
```

###### 制作不易，求资瓷！

> Thanks For Watching!


---

## 作者：封禁用户 (赞：14)

题目传送门：[P6409 [COCI2008-2009#3] KEMIJA](https://www.luogu.com.cn/problem/P6409)

**思路：** 读了题目，我们可得知每次只需把读入的字符输出，若是元音字母，则把后两个字符忽略掉即可。

于是简洁的代码就出来啦

```cpp
#include<cstdio>
using namespace std;
char ch;
int main(){
    while(ch=getchar()){
        if(ch=='\n')break;
        putchar(ch);
        if(ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u')getchar(),getchar();
    }
}
```

管理员审核辛苦啦

---

## 作者：dead_X (赞：2)

## 思路简述
~~好讨厌这种奇奇怪怪的字符串题啊~~

如果一个字符是 ``p`` ，并且它的前一个字符是 ``a``,``e``,``i``,``o``,``u`` 中的一个，那么这个字符和下面的字符都是用来加密的，就不需要输出了。

不然这个字符就属于原文，就需要输出。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	char now,lst='\0';
	while(now!='\n')
	{
		now=getchar();
		if(now=='p' && (lst=='a' || lst=='e' || lst=='i' || lst=='o' || lst=='u')) getchar(),now=getchar();
		putchar(now);
		lst=now;
	}
	return 0;
}
```

---

## 作者：Math_rad_round (赞：2)

 _[P6409](https://www.luogu.com.cn/problem/P6409)_ 
 
 题意简述
 
 给定一个加密后的句子，输出解密后的句子
 
加密方法是在每个元音后加上‘p’和原来的元音字母。如‘a’->‘apa’

只有小写字母和空格

------------

这道题看上去不大好处理，

不过我们可以发现，每一个元音，都要被加密成三个字母，其中第一个字母还和原来一样。

于是我们想到，是不是可以忽略后面的两个字母解密呢？

确实可以

于是我们可以不断读入一个字符并输出它，如果是元音，忽略后面的两个字符

------------

AC代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main(){
	char a;
	while(1){
		a=getchar();
		if(a==EOF)return 0;
		putchar(a);
		if(a=='a'||a=='e'||a=='i'||a=='o'||a=='u'){
			getchar();getchar();
		}
	}
}
```

------------

~~另外，样例二的意思是 _这化学反应真的很无聊_~~

---

## 作者：SisconHL (赞：0)

~~又是奇怪的字符串题，apawsl~~

也不算多难？

注意到有元音字母就会多两个奇奇怪怪的东西（`p`和复制成双的元音字母），所以两个`getchar()`把它们解决掉。

只有有元音才会触发两个`getchar()`，而有了元音接下来就势必有两个字母，所以不用担心会读不到导致超时什么的。

对于其他的，照样输出就好了呗……

```cpp
#include<iostream>

using std::cin;
using std::cout;

inline bool vowel( char x )
{
	switch( x )
	{
		case 'a':	return true;
		case 'e':	return true;
		case 'i':	return true;
		case 'o':	return true;
		case 'u':	return true;
		default:	return false;
	}
}

int main( void )
{
	char buf;
	while( ( buf = getchar() ) != EOF )
	{
		putchar( buf );
		if( vowel( buf ) )
		{
			getchar();
			getchar();
		}
	} 
}
```
我们用到了switch语句，细心的读者可能会注意到我没加`break`，这是为什么呢？这是因为，如果进了一个`case`就会有一个`return`，会直接跳出函数，也起到了跳出`switch`的作用。

当然也可以用`if(buf=='a'||buf==...)`来写，但是自我感觉`switch`更优美（？

要注意的是，`getchar`读不到的返回值是EOF，也就是-1。
cin是0，scanf是-1，这几个要记牢。

这里有个小trick：`a=b`有返回值是`b`，所以while的判断和读入可以写在一起。

好啦，没别的啦，不要抄哦！

---

## 作者：Inlay1158 (赞：0)

这道题目比上一道（P6408）略难一点，是一道字符串题目，而且需要读入一行，所以还需要读入空格。读入一行字符串之后，从头开始循环，遇到一个元音字母，就判断一下后面两个字符是否前一个为`p`，后一个为那个元音字母，如果是，就只把前面的那个字符弄进答案里面，并直接跳过后两个；否则，就直接把字符弄进答案里面。
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 100 + 10;
FILE *fin, *fout;
int lenstr, lenans;
char str[N], ans[N];
inline bool judge(char c) {//判断是否为元音字母
	if (c == 'a') return 1;
	if (c == 'e') return 1;
	if (c == 'i') return 1;
	if (c == 'o') return 1;
	if (c == 'u') return 1;
	return 0;
}
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6409.in", "rb");
	fout = fopen("P6409.out", "wb");
	#endif
	fgets(str, N, fin); lenstr = strlen(str);
	while (str[lenstr - 1] == '\r' || str[lenstr - 1] == '\n') str[--lenstr] = 0;//我用的是fgets读入，要是数据有换行的话，要把它吃掉，否则会WA
	for (int i = 0; i < lenstr; ++i) {
		ans[lenans++] = str[i];
		if (judge(str[i]) && str[i + 1] == 'p' && str[i + 2] == str[i]) i += 2;//直接跳过两个
	}
	fputs(ans, fout);
	return 0;
}
```

---


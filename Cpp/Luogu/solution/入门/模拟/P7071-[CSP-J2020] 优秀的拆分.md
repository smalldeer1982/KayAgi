# [CSP-J2020] 优秀的拆分

## 题目描述

一般来说，一个正整数可以拆分成若干个正整数的和。

例如，$1=1$，$10=1+2+3+4$ 等。对于正整数 $n$ 的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个**不同**的 $2$ 的**正整数**次幂。注意，一个数 $x$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到。

例如，$10=8+2=2^3+2^1$ 是一个优秀的拆分。但是，$7=4+2+1=2^2+2^1+2^0$ 就不是一个优秀的拆分，因为 $1$ 不是 $2$ 的正整数次幂。

现在，给定正整数 $n$，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。

## 说明/提示

### 样例 1 解释

$6=4+2=2^2+2^1$ 是一个优秀的拆分。注意，$6=2+2+2$ 不是一个优秀的拆分，因为拆分成的 $3$ 个数不满足每个数互不相同。

---

### 数据规模与约定

- 对于 $20\%$ 的数据，$n \le 10$。
- 对于另外 $20\%$ 的数据，保证 $n$ 为奇数。
- 对于另外 $20\%$ 的数据，保证 $n$ 为 $2$ 的正整数次幂。
- 对于 $80\%$ 的数据，$n \le 1024$。
- 对于 $100\%$ 的数据，$1 \le n \le {10}^7$。


## 样例 #1

### 输入

```
6
```

### 输出

```
4 2```

## 样例 #2

### 输入

```
7```

### 输出

```
-1```

# 题解

## 作者：soywcy (赞：237)

$Update:$ 

- `if` 语句出了大问题，现已修正

- 关于 数组 `a` 长度的问题亦已修正 

---

~~上机时题目标题差点吓死我。~~

## 步入正题

[题目传送门](https://www.luogu.com.cn/problem/P7071)

分析：

**样例输入**

```cpp
6

```

**样例输出**

```cpp
4 2

```

(1) 可以证明：一切奇数都不存在优秀的拆分，因为2的正整数次幂为偶数。

所以一遇到奇数就输出`-1`。

但是也有一个细节要注意：**0也不存在优秀的拆分。**

所以一开始的判断可以这么写：

```cpp
if (n%2==1 || n==0){
    printf("-1");
    return 0;
}
```
(2)观察样例：

$(6)_{10}=(110)_2$

![](https://cdn.luogu.com.cn/upload/image_hosting/pqotn90j.png)

咦？怎么和样例输出一模一样？

再试一个：

$(28)_{10}=(11100)_2$

![](https://cdn.luogu.com.cn/upload/image_hosting/32dxlwht.png)

可以证明：$16\ \ 8\ \ 4$ 是 $28$的优秀的拆分。

所以我们思路来了：

> 把 $n$ 转换为$2$进制，每取到一位"$1$"就变成十进制，再从大到小输出即为 $n$ 优秀的拆分。

具体看核心代码：

```cpp
void change(int b){
    int res=0; //统计a数组里有多少个元素并且作为指数
    while(b){
        if (b&1){  // 从右至左取每一位并判断是否为0
        	a[res]=pow(2,res);  // 变成十进制
        } 
        res++;
        b>>=1;// 右移一位
    }
    idx=res;   // 记录个数，便于主程序输出
}
```

最后贴上代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;
int n,a[30],idx;
void change(int b){
    int res=0;
    while(b){
        if (b&1) a[res]=pow(2,res);
        res++;
        b>>=1;
    }
    idx=res;
}

int main(){
    scanf("%d",&n);
    if (n%2==1 || n==0){
    	printf("-1");
    	return 0;
    }
    change(n);
    for(int i=idx;i>=1;i--)
        if (a[i]!=0) printf("%d ",a[i]);
    return 0;
}
```

$P.S$ 有几点要注意一下：

(1) $a$数组的范围其实没必要开很大。

因为$1\le n \le 1\times 10^7$，

而$2^{24}=16777216$，
![](https://cdn.luogu.com.cn/upload/image_hosting/h4yhin8a.png)

所以指数$<24$，所以开到30就够了。

(2) 如果没有`if (a[i]!=0)`，你会发现：输出结果会有很多$0$，所以必须加上这句话。

至于原因：因为`if (b&1)`，所以 $n$ 转换后会有一些 $0$ 没有做处理，又因为 $a$ 定义在主函数外面，所以会有一些未处理的 $0$ 。

当然，如果再想优化的话，也可加上快速幂：

```cpp

#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;
int n,a[30],idx;
int qmi(int a,int b){
    int res=1;
    while(b){
        if (b&1) res=1LL*res*a;
        a=1LL*a*a;
        b>>=1;
    }
    return res;
}

void change(int b){
    int res=0;
    while(b){
        if (b&1) a[res]=qmi(2,res);
        res++;
        b>>=1;
    }
    idx=res;
}

int main(){
    scanf("%d",&n);
    if (n%2==1 || n==0){
    	printf("-1");
    	return 0;
    }
    change(n);
    for(int i=idx;i>=1;i--)
        if (a[i]!=0) printf("%d ",a[i]);
    return 0;
}


```

希望管理员大大给通过~~

如果读者们看了觉得有帮助，留个赞再走呗，谢谢辽~~

---

## 作者：DarkLuthics (赞：43)

### ~~大水题~~

原题链接：[P7071](https://www.luogu.com.cn/problem/P7071)

**优秀的拆分**：$n$ 被分解为了若干个**不同**的 $2$ 的**正整数**次幂

题述：一个数 $n$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到

由题意**显然**可得，偶数一定存在**优秀的拆分**，而奇数一定不存在(一定有 $2^0$ 项)

所以：

输入**奇数**时，直接输出-1

输入**偶数**时，不断输出**不大于**$n$且可以被表示成 $2^k(k∈N^+)$ 的数

就是不超过 $n$ 的 $2$ 的最大正整数次幂

不难得出 $k=\lfloor log_2n \rfloor$

也就是说，每次输出 $2^{\lfloor log_2n \rfloor}$，然后 $n$ 减去这个数

得出代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;

int main(){
	//freopen("power.in","r",stdin);
	//freopen("power.out","r",stdout);
	cin >> n;
	if(n%2==1){
		cout << -1;
		return 0;
	}
	while(n){
		int k=pow(2,int(log(n)/log(2)));
		cout << k << " ";
		n-=k;
	}
	return 0;
}
```

(stdout的锅已改)


---

## 作者：Colead (赞：25)

# P7071

大家好，我是一个刚受$CSP2020$~~折磨~~摧残完的蒟蒻，来讲讲CSP2020的T1。

首先我们必须知道的是：

### 任何数都可以表示为2的非负次幂相加的形式。

因为$x=x*1$

而$1=2^0$

每两个$2^0$可组成一个$2^1$,每两个$2^1$可组成一个$2^2$，以此类推……

而本题中是什么？正整数次幂！

也就是没有了$2^0$这一项！

这代表了什么？

### 所有的奇数都无法表示！

那偶数的时候呢？

先看看2的最大次方是几，然后倒序枚举能减就减即可。

时间复杂度：$O(log n)$

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	if(n%2)//无法整除。
	{
		cout<<"-1"<<endl;
		return 0;
	}
	else
	{
		int cnt;
		for(int i=1;;i++)
		{
			if((int)pow(2,i)>=n)//枚举最大次方。
			{
				cnt=i;
				break;
			}
		}
		for(int i=cnt;i>=1;i--)
		{
			if(n>=(int)pow(2,i))
			{
				cout<<(int)pow(2,i)<<" ";//能减就减。
				n-=(int)pow(2,i);
			}
		}
		return 0;
	}
}
```


---

## 作者：cjy2008 (赞：20)

先分析题目： 看到“2 的正整数次幂”就可以知道这是一道进制转换题:

只需要把输入的数转换成二进制串就可以了！

首先我们知道奇数是一定不行的，因为奇数拆分后一定含有1。这也不难理解：2的正整数次幂一定是偶数。

所以有如下代码：
```cpp
if(n%2==1){
	printf("-1");
	return 0;
}
```
咱们继续分析：

易知偶数是一定存在拆分的 ~~不然要二进制干什么~~

接下来就是如何找到这个拆分了。这里介绍一种数学方法：每次除以2直到n=0，把余数倒过来念。如:![](https://pic1.zhimg.com/80/50dfea3c43a68e1edc642f2bd23f997e_720w.jpg?source=1940ef5c)

所以有如下代码
```cpp
void iofind(int p,int u){
	if(p==0) return;
	if(p%2==1) k[u]=1;//k[i]=1表示拆分中有2的i次方
	iodfs(p/2,u+1);
}


iofind(n,0);
```

最后乘方输出即可
```cpp
for(int i=800;i>=1;i--){//奇怪的码风
	if(k[i]==1){
		printf("%d ",iopow(2,i-1));	
	} 
}
```


放代码
```cpp
#include<bits/stdc++.h>//考场代码，如有不足，请多谅解
using namespace std;
int n;
int k[1000]; 
void iofind(int p,int u){
	if(p==0) return;
	if(p%2==1) k[u]=1;
	iodfs(p/2,u+1);
}
int iopow(int n,int s){  //这是求n的s次幂的函数，懒得写快速幂
	int o=n;
	for(int i=1;i<=s;i++){
		n*=o;
	}
	return n;
}
int main(){
//	freopen("power.in","r",stdin);
//	freopen("power.out","w",stdout);
	scanf("%d",&n);
	if(n%2==1){
		printf("-1");
		return 0;
	}
	iofind(n,0);
	for(int i=800;i>=1;i--){
		if(k[i]==1){
			printf("%d ",iopow(2,i-1));	
		} 
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

第一次写题解，如有不足，请多谅解！



---

## 作者：hmya (赞：17)

这题是一个贪心（~~CCF不是说前两题没算法吗~~）

首先，如果n是奇数，那他一定没有“优秀的拆分”

因为“优秀的拆分”要求将n分解成2的次方的和的形式

2的次方不论有多少个，和一定为偶数

所以开头就要把奇数情况判断：

```cpp
if(n%2==1){
	printf("-1");
	return 0;
}
```

然后考虑偶数情况

如果是偶数的话，应该是做一个贪心

每次把不大于n又是2的次方数的最大数字输出

n再减掉这个数

循环往复，直到n==0为止

思考：**为什么这个情况是对的**？

我们先列举64以内的所有2的次方数：

2 4 8 16 32 64

假设n=66

如果开始不是选最大的64，那就只能选剩下的，剩下的加起来发现也没有66（加起来等于62）

这里可以加上一个2，后面再减去

这是关键

2^1+2^1=2^2

2^2+2^2=2^3

2^3+2^3=2^4

…………

2^(n-1)+2^(n-1)=2^n

后面再减去一个2

答案就是2^n-2可以发现，如果不选最大的，其他比他小的都凑不出这个最大的数

**连最大的数都凑不出，n能凑出来吗？？**

**不能！**

这就是最关键的原因！

贪心策略找到了，同时也证明了贪心策略，代码就很好写：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100],p;//数组大小开够100就行
int main(){
	scanf("%d",&n);
	if(n%2==1){//奇数判断
		printf("-1");
		return 0;
	}
	if(n<2){//如果n小于2，最小的2都不能和它凑，一定没有方案
		printf("-1");
		return 0;
	}
	while(n){
		int r=2;
		while(r<=n){
			r*=2;
		}
		r/=2;//出了while循环r就一定大于n，所以要除以2才是最大的不大于n的2的次方数
		n-=r;//n把r减掉
		p++;
		a[p]=r;//记录
	}
	for(int i=1;i<=p;i++){
		printf("%d ",a[i]);//输出
	}
//	printf("%d",r);
	return 0;
}
```

看懂了点赞支持一下哦~

---

## 作者：Amoribus (赞：9)

- 我们这样考虑，一个十进制整数必然可以化为二进制，也就是写成若干个 $2$ 的**非负整数**次幂之和，如果这个数是奇数，那么它二进制的末尾必然是 $1$，也就是它的拆分中必然有一项 $2^0$，故无解。
- 如果是偶数则它的二进制末位是 $0$，也就是必定能写成若干个 $2$ 的**正整数**次幂之和，因此必然有解。我们可以先记录 $10^7$ 以内的 $2$ 的正整数次幂，然后从大到小，将 $n$ 试着减去这些 $2$ 的正整数次幂。（感性地理解一下，这样做是正确的。）然后输出答案即可。


我采用了递归的写法，相对比较直观。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int p[40]={0,2,4,8,16,32,64,128,256,512,1024,2048,\
4096,8192,16384,32768,65536,131072,262144,524288,\
1048576,2097152,4194304,8388608,16777216,33554432,\
67108864,134217728,268435456,536870912,1073741824};
void f(int x){
	if(x==1||x==0) return;
	for(int i=30;i>=1;i--){
		if(x>=p[i]){
			cout<<p[i]<<" ";
			f(x-p[i]);
			break;
		}
	}
}
int main()
{
	cin>>n;
	if(n%2==1){
		cout<<-1<<endl;
		return 0;
	}
	else{
		f(n);
	}
} 
```

---

## 作者：Yxy7952 (赞：7)

## 思路
看到 $2$ 的正整数次幂和，想到二进制。

显然，奇数的二进制最后一位是 $1$，所以其没有“优秀的拆分”，也可以这样理解：若干偶数之和，怎么可能等于奇数呢。

同理，偶数一定有“优秀的拆分”。

结果就是求出这个数中所有二进制上为 $1$ 的部分，并把它们转化成十进制。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,i=1;
	cin>>n;
	if(n%2){
		cout<<-1;
		return 0;
	}
	while(i<=n) i*=2;
	i/=2;
	while(n){
		n-=i;
		cout<<i<<" ";
		while(i>n) i/=2;
	}
	return 0;
}
```

---

## 作者：Eason_cyx (赞：3)

显然可以有做到所有幂均不相同的做法。因为 $2 \times 2^n = 2^{n+1}$，所以一定可以保证每个组成这个数幂都是唯一的。

再看 `-1` 条件：不是正整数次幂。显然唯一不符合的情况就是 $2^0=1$，所以奇数显然是无解的。

剩下的情况？本质上就是二进制拆分啊。直接拆即可。

时间复杂度 $O(\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[50];
int main() {
    int b; cin >> b;
    if(b % 2 == 1 || b == 0) {
        cout << -1 << endl;
        return 0;
    }
    int cur = 0;
    while(b) {
        if(b & 1) a[cur] = pow(2,cur);
        cur++;
        b >>= 1;
    }
    for(int i = ++cur;i >= 1;i--) 
        if(a[i]) 
            cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
把十进制数转化为二进制数，容易发现，任何一个**整数**均可以分解为若干个不同的 $2$ 的**整数**次幂。题目要求把 $n$ 分解为若干个不同的 $2$ 的**正整数**次幂，也就是分解中不能有 $2^{0}=1$。考虑缺少了 $2^{0}=1$ 会使哪些整数拆分不了。  

二进制下，$2^{k}$ 对应第 $k$ 位。现在少了第 $0$ 位，也就是末位不能是 $1$，只能是 $0$。显然，二进制下末位是 $0$ 的整数是一个偶数。也就是说，只有偶数不会因为缺少了 $2^{0}$ 而导致拆分不了，所有的奇数二进制下末位都是 $1$，会因为缺少了 $2^{0}$ 而导致拆分不了。

具体代码实现为：先判断奇偶，奇数一定拆不了，直接输出 `-1`；对于偶数，直接取到最大能取到的 $2$ 的正整数次幂，然后输出并减去，重复这个过程直到 $n$ 被减为 $0$。

时间复杂度为 $O(\log^{2}n)$。

---

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j;
int main(){
	scanf("%d",&n);
	if(n&1){
		printf("-1");
		return 0;
	}
	while(n){
		i=1;
		j=2;
		while(j<=n)i<<=1,j<<=1;
		printf("%d ",i);
		n-=i;
	}
	return 0;
}
```

---

## 作者：player_1_Z (赞：3)

### 先来理解题目
题目十分清楚，不做过多解释。
### 思路
首先因为只能用整数次幂，所以不能加 $1$，所以一旦是奇数，就输出 $-1$。否则直接枚举 $2$ 的每个次方，如果小于当前的数就输出，并用当前数减去这个次方。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long x;
int main(){
	cin>>x;
	if(x%2==1) cout<<-1;
	else{
		for(int i=30;i>=1;i--){
			long long s=2;
			for(int j=1;j<=i;j++){
				s*=2;
			}
			if(x>=s){//满足条件
				cout<<s<<" ";
				x-=s;
			}
		}
		if(x==2) cout<<2;
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：2)

题意：给定正整数 $n$，你需要判断这个数能否被拆分为不同的 $2$ 的正整数次幂之和。

简单递归。由于要分成 $2$ 的正整数次幂，所以奇数是无法被拆分的。每次枚举到恰好小于 $n$ 的二的幂，输出后将 $n$ 减去它即可。$n\le10^7$ 不大，所以是可过的。

```cpp
#include <bits/stdc++.h>   
using namespace std; 

void dg(int n){ 
    for(int i=2;;i*=2){ 
        if(i==n){ 
            cout<<i; 
            return ; 
        } 
        else if(i>n){ 
            cout<<i/2<<" "; 
            dg(n-i/2); 
            return ; 
        }
    } 
}

int main(){ 
    int n; 
    cin>>n; 
    if(n%2!=0){ 
        cout<<"-1";  
        return 0; 
    } 
    dg(n);  
    return 0; 
}
```

---

## 作者：Igallta (赞：2)

作者：Igallta。（813622）

请勿抄袭。

## 思路

二进制操作题。

首先，根据题意，如果给定的 $n$ 是奇数那么直接输出 `-1`。

然后，根据题意就可以发现是要把 $n$ 拆成  $2^{a_1}+2^{a_2}+...2^{a_x}$ 这种形式。

看到这个，你会想到什么？是不是特别像二进制转十进制的计算方式？

也就是说我们从大到小找到 $n$ 的二进制为 $1$ 的位并输出那一位对应的十进制不就行了？



代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
signed main(){
    ios::sync_with_stdio(0);
	cin>>n;
	if(n&1)cout<<-1;
	else{
		for(int i=32;i>=1;i--){
			if(n&(1<<i)){
				cout<<(1<<i)<<' ';
			}
		}
	}
    return 0;
}
```

---

## 作者：__sxx (赞：2)

# 题意
求出一个数能由多少个 $2$ 的正整数次幂相加得到，并将这些数由大到小输出，如果不行就输出 $-1$。
# 思路
如果这个数为奇数，则直接输出 $-1$，因为 $2$ 的正整数次幂都是偶数，他们相加也是偶数。如果为偶数的话，可以直接寻找小于 $n$ 中最小的数同时是 $2$ 的正整数次幂，输出它，同时 $n$ 减去它，重复此操作。当 $n = 0$ 时，就可以退出。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	if(n%2==1)
	{
		cout<<"-1";
		return 0;
	}
	else{
		while(n>=2)
		{
			int u=2;
			while(u<=n)
			{
				u=u*2;
			}
			u=u/2;
			cout<<u<<" ";
			n=n-u;
		}
		
		
	}
	
	return 0;
}
```

---

## 作者：Ybll_ (赞：2)

# 题意：
一个数 $n$，问它可以被拆分成哪些 $2$ 的正整数次幂的和，如果不能输出 $-1$。
# 思路：
先判断这个数是不是偶数，不是直接输出 $-1$，如果是，找出小于等于 $n$ 的最大 $2$ 的正整数次幂，然后每次减去这个数，然后一直让这个数除以 $2$，直到这个数小于等于 $n$ 为止，重复这个过程，直到 $n$ 为 $0$。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,i=1;
	cin>>n;
	if(n%2==1)
	{
		cout<<-1;
		return 0;
	}
	while(i<=n)i*=2;
	i/=2;
	while(n)
	{
		n-=i;
		cout<<i<<" ";
		while(i>n)i/=2;
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：1)

## 题意回顾

定义其一个整数的拆分在拆分出的所有数均为 $ 2 $ 的正整数次幂且互不相同时称为优秀的拆分，判断给定的整数 $ n $ 是否存在优秀的拆分若存在从大到小输出。

$ 1 \le n \le 10^7 $。

## 分析

**严谨声明：我们这里定义一个数被若干个数表示出为这个数等于这些数中一部分（可以为全部或空）不同的数的和。**

> 结论 1：一切正整数 $ n $ 可以被拆分为若干个不同的 $ 2 $ 的自然数次幂的和。

证明：首先发现 $ 2^0 $ 可以表示出 $ 1 $ 到 $ 2^0 $ 的所有整数的拆分，欲证明 $ 2^0,2^1,\cdot \cdot \cdot,2^i $ 可以表示出 $ 1 $ 到 $ \sum_{j=0}^i2^j $ 的所有整数的拆分命题在 $ i=i_0 $ 时成立的情况下 $ i=i_0+1 $ 时必然成立，首先 $ \sum_{j=0}^i2^j=2^{i+1}-1 $，故对于 $ 2^0,2^1,\cdot \cdot \cdot,2^{i+1} $ 可以表示出 $ 1 $ 到 $ 2^{i+2}-1 $ 是我们要证明的目标，对于 $ 1 \le x \le 2^{i+2}-1 $，若 $ 1 \le x \le 2^{i+1}-1 $，那么 $ x $ 可以被上一个命题的结论证明能被这个命题的 $ 2^{i+1} $ 之前的幂次表示出，而 $ 2^{i+1} \le x \le 2^{i+2}-1 $ 时，$ 0 \le x-2^{i+1} \le 2^{i+1}-1 $，$ x=2^{i+1} $ 时不难表示出，其余情况也可以由 $ x-2^{i+1} $ 在上一个命题的表示方法增加一个 $ 2^{i+1} $ 推知这个命题的表示方法。

因此，$ 2 $ 的若干个从 $ 2^0 $ 开始的前缀连续次幂可以表示出所有小于或等于这些次幂的和的正整数，而 $ 2 $ 的次幂是无限多的故所有正整数均存在拆分为若干个不同的 $ 2 $ 的自然数次幂的和的方案。

> 结论 2：若一个拆分存在 $ 2^0 $，则和必然为奇数；否则必然为偶数。

存在 $ 2^0 $ 的拆分等价于去除掉 $ 2^0 $ 后的一个不存在 $ 2^0 $ 的拆分增加上一个 $ 2^0 $ 元素，欲证明后者必然为偶数，在模 $ 2 $ 意义下，后者等价于若干个 $ 0 $ 相加，显然为 $ 0 $，模 $ 2 $ 余 $ 0 $ 相当于为偶数，增加一个 $ 2^0 $ 元素为奇数。

故我们可以判断奇数必然无解，偶数必然有解，且无论怎么拆分都不存在 $ 2^0 $。

> 结论 3：一种构造优秀的拆分的方案为，每次找到最大的小于等于目前的数未拆分部分数值的 $ 2 $ 的次幂，将这个数拆分掉这个次幂，不断执行这个过程直到这个数被完全拆分。

设这个找到的次幂为 $ 2^p $，如果不拆分掉这个次幂的话显然只能拆分更小的次幂，$ x $ 最多拆分出 $ 2^p-1 $ 的大小，不够拆分掉完整的 $ x $，因此必须拆分掉这个次幂 $ 2^p $。

因此，我们找到了一种在 $ O(\log n) $ 时间复杂度内拆分整数 $ n $ 的方案。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
int main() {
	cin >> n;
	if(n % 2 == 1) puts("-1");
	else {
		for(int i = (1 << 30); i >= 1; i >>= 1) {
			if(n >= i) printf("%d ", i), n -= i;
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：GoldenSTEVE7 (赞：1)

## 题意简述
将一个正整数，将其拆分为若干个 $2$ 的正整数次幂。
## 思路
- 易证如果这个数是奇数，那么这个数一定无法拆分，且偶数一定可以拆分。
- 由于 $1 \le n \le 10^7$，所以我们可以枚举 $1 \le i \le 23$，若 $2^i \le n$，就输出 $i$，因为如果这个数可拆分，那么一定要输出其中最大的 $2$ 的正整数次幂。 
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin >> n;
	if(n % 2 == 1) {
        cout << -1 << endl;
        return 0;
    }
	for(int i = 23; i >= 1; i--) {
		if(n >= int(pow(2, i))) {
			cout << int(pow(2, i)) << " ";
			n -= int(pow(2, i));
		}
	}
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：1)

首先我们知道，$x^0=1$，所以如果 $n$ 是奇数，肯定不能拆分，输出 `-1` 即可。然后我们需要需要从大到小枚举 $2^n$ 次方的数。枚举时可以变量存 $2^{31}$ 的数，然后从大到小看 $n$ 能不能拆分出这个数，如果能，就把 $n$ 减去这个数，代表这个数被拆分了，然后每次将 $ans$ 除以 $2$，看下一个二次方的数能不能拆分。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e7+5;
int a[maxn];
int cnt=0;
signed main() 
{
	//freopen("A.in","r",stdin);
	//freopen("A.out","w",stdout);
	int n;
	cin>>n;
	if(n%2==1)//奇数就不能拆分
	{
		cout<<-1;
		return 0;
	}
	int ans=pow(2,32);//先设为2^32
	while(n>=1)
	{
		if(n>=ans) //能拆分
		{
			cout<<ans<<" ";//先输出拆分的数
			n-=ans;//拆分了就减去
		}
		if(ans/2==0) break;//如果ans是0了就没必要继续拆分了
		ans/=2;//每次除以2,因为要拆分2的n次方数，所以只能除以2
	}
	return 0;
}
```

---

## 作者：includeCPP (赞：1)

遇到这种与 $2$ 的次幂有关的题目，一个显然的思路是将所有数转化为二进制表示，这样可以很直观地发现一些性质。

本题即为一个很好的例子。我们把输入的 $n$ 转换为二进制表示，显然地，任意一个十进制数都可以用二进制表示。

对于一个二进制数，其十进制即为：对于每一个二进制上为 $1$ 的数位，设其为从小到大第 $i$ 位，令 $m_i$ 为 $2^{i+1}$，则 $\sum m$ 即为其十进制表示下的数。

由于 $2^0$ 不能参与构造，那么二进制表示下 $n$ 的最低位也不能为 $1$，显然地，对于所有奇数，无法构造。对于所有偶数，可以构造，且为唯一解。

那么我们模仿上述思考的方法，从小到大依次枚举 $n$ 的二进制位，遇到 $1$ 就加入数组中，最后倒序输出即可。

本题数据范围 $1 \le n \le 10^7$，因此枚举 $30$ 位即可。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=36;
int a[N];
int res=0;
int main(){
	int n;
	cin>>n;
	if(n&1){
		cout<<"-1";
		return 0;
	}
	int p=0;
	while(n>=1){
		if(n&1){
			a[++res]=(1<<p);
		}
		n>>=1;
		++p;
	}
	for(int i=res;i>=1;i--){
		cout<<a[i]<<" ";
	}
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：1)

### 解题思路

我们先考虑一下什么情况下无解，要用 $2$ 的正整数次幂来凑数，那么很容易发现，奇数永远都凑不出来，因为 $2$ 的正整数次幂一定是偶数。

那么接下来我们可以根据这个数的二进制进行拆分，当这个数的二进制的第 $i$ 位为 $1$ 时，则存下 $2^i$。由于题目要求从大到小，最后倒序输出即可。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

int n;
vector<int> res;

int main()
{
    cin >> n;
    
    if (n & 1)
    {
        puts("-1");
        return 0;
    }
    
    int k = 0;
    while (n)
    {
        if (n & 1)
            res.push_back(1 << k);
        k ++;
        n >>= 1;
    }
    
    reverse(res.begin(), res.end());
    
    for (auto x: res)
        cout << x << ' ';
    
    return 0;
}
```

---

## 作者：_Epsilon_ (赞：1)

# 题意
输入 $a$，把 $a$ 写作许多个 $b=2^k$ 的和，输出每个 $b$（$k$ 为正整数且互不重复）。
# 无解
因为要求 $k$ 为正整数，所以奇数肯定不行。
# 思路 1
考虑枚举。

通过小于等于 $a$ 的最近的 $b$ 来确定起点，将 $a$ 减去 $b$，判断 $a$ 是否等于 $0$，是则退出枚举，否则将 $b$ 除以 $2$，继续枚举。

# 代码 1

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b=1;
int main()
{
    cin>>a;
    if(a%2==1)
    {
        cout<<"-1";
        return 0;
    }
    while(b<a)
    {
        b*=2;
    }
    while(a!=0)
    {
        if(a>=b)
        {
            a-=b;
            cout<<b<<" ";
        }
        b/=2;
    }
    return 0;
}
```
# 思路 2
考虑模拟。

我们都知道我们最爱的二进制和这个题目有着深刻的联系。所以我们不妨用按位与来判断这个数字的一个二进制数位是否为 $1$，如果是，我们就输出这个二进制位所代表的的十进制数。

记住，要从大到小哦，所以开头还要判断一下这个数字的二进制位有几个。

代码就不放上去了，实现起来很简单。

---

## 作者：yr409892525 (赞：1)

## P7071 [CSP-J2020] 优秀的拆分 题解
题目中说若干个不同的的**正整数**次幂。           
这就意味着不能分解奇数，所以奇数输出 $-1$。          
然后把 $2$ 的次方数从大到小扫一遍，能选就选。                  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	if(n%2==1){
	    cout<<"-1\n";
	    return 0;
	}
	for(int i=30;i>=1;i--){
	    int ans=(1<<i);
	    if(n>=ans){
	        n-=ans;
	        cout<<ans<<" ";
	    }
	}
	return 0;
}
```

---

## 作者：yehongxin (赞：0)

#### [题目传送门](https://www.luogu.com.cn/problem/P7071)
## 题目大意
给出一个数 $n$，求这个数是否能拆分成若干个 $2$ 的正整数次幂。
## 解题思路
如果 $n$ 是奇数，直接输出 $-1$。
如果 $n$ 是偶数，就从 $32$ 到 $1$ 求 $2$ 的幂，如果小于 $n$ 就输出。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long i,j,n,a[1000005],s;
int main(){
	cin>>n;
	if(n%2==1)cout<<-1;
	else{
		for(i=32;i>=1;i--){
		    if(n>=pow(2,i))cout<<int(pow(2,i))<<" ",n-=pow(2,i);
		}
	}
	return 0;
}
```

---

## 作者：a18981826590 (赞：0)

# [P7071 [CSP-J2020] 优秀的拆分](https://www.luogu.com.cn/problem/P7071)
## 解题思路
在这道题中，我们需要将正整数 $n$ 拆分为若干个不同的 $2$ 的正整数次幂。

考虑将 $n$ 转为二进制，若二进制下的 $n$ 从右往左数第 $i$ 位（最右端为第 $0$ 位）为 $1$，则我们拆分出一个 $2^{i}$ 出来。

因为二进制下的 $n$ 的每一位最多为 $1$，所以这样拆分出来的 $2$ 的正整数次幂肯定是不同的。

题目要求的是 $2$ 的正整数次幂，而 $0$ 不是正整数，故 $2^{0}=1$ 不符合要求。由于无法用更高位凑出更低位，故二进制下的 $n$ 若末位为 $1$，则不符合要求；即若 $n$ 为奇数，则不存在优秀的拆分。
## 代码实现
若 $n$ 为奇数，则直接输出 `-1` 并结束程序。

我们可以从最低位开始，依次判断二进制下的 $n$ 的第 $i$ 位是否为 $1$。

通过将 $n$ 与 $2^{i}$ 进行按位与运算 `&`，由于 $2^{i}$ 只有第 $i$ 位为 $1$，所以运算结果即为 $n$ 的第 $i$ 位。

由于题目要求从大到小输出，若二进制下的 $n$ 的第 $i$ 位为 $1$，就把 $2^{i}$ 记录下来，等求完了所有位，再倒序输出。这里我们利用栈的“先进后出”性质来实现。
## [AC](https://www.luogu.com.cn/record/195993374) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int>a;
int m=1,n;
int main(){
	cin>>n;
	if(n%2){
		cout<<-1;
		return 0;
	}
	while(m<=n){
		if(m&n) a.push(m);
		m<<=1;
	}
	while(!a.empty()){
		cout<<a.top()<<' ';
		a.pop();
	}
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

题解：[P7071 [CSP-J2020] 优秀的拆分](https://www.luogu.com.cn/problem/P7071)

#### 题意：
给出一个正整数 $n$，问你是否存在优秀的**拆分**。

其中优秀的拆分的定义是：一个正整数 $n$，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个**不同**的 $2$ 的**正整数**次幂。

#### 思路
首先明确一点，$2$ 的**正整数**次幂相加，得到的答案一定是 $2$ 的倍数，所有如果 $n$ 为奇数，就不可能存在优秀的拆分，直接输出 `-1` 即可。

如果 $n$ 是偶数，那么一定存在优秀的拆分，因为每一个数都可以被转化成二进制，但是题目要求是 $2$ 的**正整数**次幂相加，所有奇数就不存在优秀的拆分，偶数的话必定存在优秀的拆分。

既然我们都知道了每一个数都可以被转化成二进制，那么就非常的简单了，我们直接将 $n$ 转化成二进制数，用一个字符串存储起来，然后遍历输出就可以了。

#### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 1;
int a[N], n;
char int_to_char(int x) {
    if (x < 10) { return x + '0'; }
    return x - 10 + 'A';
}
string jinzhi(int n, int m) {
    string s;
    while (n) { s = int_to_char(n % m) + s, n /= m; }
    return s;
} // 转换进制
signed main() {
    int n;
    cin >> n;
    string s = jinzhi(n, 2);
    int cnt = 0, ans = 1;
    if (n & 1) {
        cout << -1;
        return 0;
    } // 判断奇数
    for (int i = s.size() - 1; i >= 0; i--) {
        if (s[i] == '1') { a[++cnt] = ans; }
        ans *= 2;
    } // 遍历输出
    sort(a + 1, a + cnt + 1); // 注意需要排序，这是一个坑点。
    for (int i = cnt; i >= 1; i--) { cout << a[i] << " "; } // 输出答案
    return 0;
}

```

---

## 作者：zengzidi (赞：0)

## 思路
如果 $n$ 是奇数，则不可能有优秀的拆分，则输出 $-1$ 。否则找到比 $n$ 小的最大的 $2$ 的正整数次幂，从大往小枚举每一个可以被整除的 $2$ 的次幂，如果 $n$ 大于这个次幂，则减去它并输出。
代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],b,c[105],d[105],e,f,g,h,k,l,m,n,o,p,q,s,r,t,u,v,w,x,y,z;
int main()
{
	cin>>n;
	if(n%2==1)
	{
		cout<<-1;
		return 0;
	}//如果是偶数，则不可能是优秀的拆分
	t=1,u=0;
	while(t*2<=n)
	{
		t*=2;
		u++;
	}//求出不大于n的最大2的正整数次幂
	while(t>1)
	{
		if(n-t>=0)//如果可以减去t，就输出t
		{
			cout<<t<<' ';
			n-=t;
		}
		t/=2;//t变回上一个次幂
	}
	if(n!=0)cout<<-1;
    return 0;
}
```

---

## 作者：SuyctidohanQ (赞：0)

### 题目分析

题目中说若干个不同的的**正整数**次幂。这就意味着不能分解奇数，所以奇数输出 $-1$。

然后把 $2$ 的次方数从大到小扫一遍，能选就选。

### 代码实现

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAXN = 24 + 10;
ll n, sum = 0, d = 0, a = 0, shu[MAXN] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216}; //ans[MAXN2] = {0};
int main () {
	cin >> n;
	if (n % 2 != 0) {
		cout << -1 << endl;
		return 0;
	}
	sum = n;
	while (sum > 0) {
		for (ll i = 1; i <= 24; i ++) {
			if (shu[i] > sum) {
 				a = shu[i - 1];
				break;
			}
		}
		sum -= a;
		cout << a << ' ';
	}
	cout << endl;
	return 0;
}
```

---


# [COCI 2015/2016 #3] POT

## 题目描述

老师给同学们发了一封电子邮件，任务如下。

> 写一个程序，给你 $n$ 个数，输出 $X$。      
> $$X = num_1^{p_1} + num_2^{p_2} + \cdots + num_n^{p_n}$$         
> $num_1$，$num_2$，$\cdots$，$num_n$ 都是整数，$p_1$，$p_2$，$\cdots$，$p_n$ 都是一位数。    

但是出现了一些玄学错误，使得 $X$ 变成了：
$$X = q_1 + q_2 +... + q_n$$

注：$q_i = num_i \times 10 + p_i$。

例如，原来的 $X$ 为 $21^2+125^3$，但现在变成了 $212+1253$。请帮助老师编写一个程序，输出原来 $X$ 的值。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le n \le 10$，$10 \le q_i \le 9.999 \times 10 ^ 3$，$1 \leq X \leq 10 ^ 9$。

#### 说明
翻译自 [COCI 2015-2016 #3 A POT](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)，满分 50。

## 样例 #1

### 输入

```
2
212
1253
```

### 输出

```
1953566```

## 样例 #2

### 输入

```
5
23
17
43
52
22
```

### 输出

```
102```

## 样例 #3

### 输入

```
3
213
102
45
```

### 输出

```
10385```

# 题解

## 作者：追梦之鲸 (赞：46)

本蒟蒻的第$005$篇题解。

[经典回顾P7226](https://www.luogu.com.cn/problem/P7226)

窝觉得这道题并不难，难在难理解，所以让窝来让你重温一下题目描述。

说白了就是给你$n$个数$q[i]$，把$q[i]$变成$(q[i]/10)^{q[i] \bmod 10}$(这个看不懂没关系，下面窝会讲)，然后输出$\sum_{1}^n q[i]$(其实就是从$q[1]$一直加到$q[n]$然后输出)

窝们以样例为例：

### #1

$212->21^2$

$1253->125^3$

然后问题就变成了$21^2+125^3$

### #2

$23->2^3$

$17->1^7$

$43->4^3$

$52->5^2$

$22->2^2$

然后问题就变成了$2^3+1^7+4^3+5^2+2^2$

那么问题来了怎么把$q[i]$变成$(q[i]/10)^{q[i] \bmod 10}$呢 (~~这很明现好吧~~)，让窝们用代码来说一下：

```c
//求q[i]/10的q[i] mod 10次方
b=a%10;
a=a/10;
if(b==0)//b=0时要特判，因为x的0次方等于1
{
	dan++;
}
else
{
	ans=1;
	
	for(int j=1;j<=b;j++)
	{
		ans*=a;
	}
}
```

为了保险代码开了``unsigned long long``（貌似不用？）。

### code：
```c
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
int n,a,b;
ull dan,ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		b=a%10;
		a=a/10;
		if(b==0)
		{
			dan++;
		}
		else
		{
			ans=1;
			for(int j=1;j<=b;j++)
			{
				ans*=(ull)a;
			}
			dan+=ans;
		}
	}
	cout<<dan;
	return 0;
        撒花✿✿ヽ(°▽°)ノ✿
}
```

最后管理大大求过&[**来玩啊**](https://www.luogu.com.cn/user/361726)&看完辣么辛苦，点个赞吧QAQ

---

## 作者：tZEROちゃん (赞：6)

没啥难度。

我们将每一个数分解成 2 部分：
- 指数（代码中为 $power$）：$p \bmod 10$
- 底数（代码中为 $number$）：$\lfloor{\dfrac{p}{10}}\rfloor$

然后让 $ans$ 加上 $number ^ {power}$ 即可。

注：Python 3 中，表示 $a ^ b$，可使用 `a ** b`。

```python
n = int(input())
ans = 0
for i in range(n):
    p = int(input())
    power = p % 10
    number = p // 10
    ans += number ** power
print(ans)
```

---

## 作者：honey_ (赞：4)

## 简述题意
  将读入的值转化为乘方的形式并将结果相加再输出
## 算法
  模拟
## 具体思路
  题目已知 $q_i=num_i \times 10 + p_i$ 将 $ q_i $ 转化成对应的 $ num^{p_1}_1 $ ,求出乘方，再把所得乘方相加即可
  
# Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
#define int long long  //数据知结果小于10^9，这里用longlong防止意外
using namespace std;
signed main()
{
	int n,a,sum=0;
	scanf("%lld",&n);
	while(n--)
	{
		scanf("%lld",&a);
		sum+=pow(a/10,a%10);  //转化并相加
	}
	printf("%lld\n",sum);
	return 0;
}
```

---

## 作者：Runtimeerror90 (赞：3)

这道题主要考察数位分离和幂运算。

众所周知，对于整数 n ，它的个位是 n%10 ，而他出去个位后的数是 n/10 。

所以
```qi=(qi/10)^(qi%10)```

# code 1

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	long long int sum=0,a;
	cin>>n;
	while(n--){
		cin>>a;
		sum+=pow(a/10,a%10);/计算qi
	}
	cout<<sum;
	return 0;
}
```

~~其实这样就AC了~~

为了降低时间复杂度，以下代码使用了[快速幂](https://baike.sogou.com/v70957172.htm?fromTitle=快速幂)

# code 2

```
#include<bits/stdc++.h>
#define M 1000000007
using namespace std;
int fp(int a,int b){
    long long ret=1,pow=a;
    while(b!=0){
    	if(b&1){
    		ret=(ret*pow)%M;
		}
    	pow=(pow*pow)%M;
	    b/=2;
    }
	return (int)ret;
}
int main(){
	int n;
	long long int sum=0,a;
	cin>>n;
	while(n--){
		cin>>a;
		sum+=fp(a/10,a%10);/还是计算qi，只是用了快速幂
	}
	cout<<sum;
	return 0;
}
```

完结，撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：HYdroKomide (赞：1)

# **正文：**
## 题意：
本题就是输入 $n$ 个整数 $q[i]$ ，将题意简化后可知每一次将 $x+(q[i]\div 10)^{q[i] \mod 10}$ 即可。（ $q[i]\div 10$ 即为题目中的 $num[i]$ ， $q[i]\mod 10$ 即为题目中的 $p[i]$ ）。我们就可以立即出代码了，这里我们可以不需要开 $long long$ 。
## 程序如下：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long n,q,x;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>q;
        x+=pow(q/10,q%10);
    }
    cout<<x;
    return 0;
}
```
# **THE END**

---

## 作者：Meng142857 (赞：1)

# 本蒟蒻的一篇题解（P7226）：
这题好像没啥好思考的，以输入的数除以10的商为底数，除以10的余数为指数做幂再相加即可。  
  
     
AC代码如下，请勿抄袭：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main(){
	long long sum=0,x,n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		sum+=pow(x/10,x%10);
	}
	cout<<sum;
	return 0;
} 
```


---

## 作者：sinsop90 (赞：0)

显然这道题最好的办法是直接分离一个数的个位出来

对于任意一个 $n$

我们都可以得到他的个位 $n % 10$

也可以得到 $n$ 不是个位的部分 $n / 10$

这里推荐一个函数 $pow$, 格式如下:

$pow(a, b)$ $=$ $a ^ b$

因此对于一个 $n$ 就有 $pow(n / 10$ $,$ $n$ $\%$ $10$ $)$

然后将和加起来就行了

代码如下

```
#include <bits/stdc++.h>
using namespace std;
long long n, ans;
int main() {
	cin >> n;
	for(int i = 1;i <= n;i++) {
		int x;
		cin >> x;
		ans += pow(x / 10, x % 10);
	}
	cout << ans << endl;
}
```


---

## 作者：IL杰佣 (赞：0)

这道题只要把数字最后一位分离出来就OK啦

可以把输入当作字符串也可以直接当数字拆分

### 分成

S/10 && S%10

本蒟蒻认为后者简单些，代码很朴素

```cpp
#include<iostream>
using namespace std;
long long num[11],pf[11],n,ccin[11],ans;	//long long保险 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>ccin[i]; 				//cin——c++方便的输入，但是比较慢。本题不会卡的啦 
		num[i]=ccin[i]/10;			//把最后一位和前面的分离 
		pf[i]=ccin[i]%10;
	}
	for(int i=1;i<=n;i++)
	{
		int c=1;
		for(int j=1;j<=pf[i];j++)			//没什么函数运用，纯手打平方 
		{						//方便初学者 
			c*=num[i];
		}
		ans+=c;						//求和 
	}
	cout<<ans;						//输出答案 
	return 0;						//好习惯 
}
```


---

## 作者：GaryH (赞：0)

## 题解

这道题应该算比较简单的了。

因为数据所给的数是原幂的底数与指数拼凑而成的，所以我们可以显然得出，所给数的最后一位即为指数，而所给数的前几位则是底数。

那么，我们在这里就可以用分离变量来做这道题，即

$\large x$ $\large mod$ $\large 10$ 即为最后一位，

$\large [x \div 10]$即为前几位，其中$\large [x]$ 表示对 $\large x$ 取下整。

那么此题就简单了，只需依次输入后按上述方法求值即可。

(此处尽量用快速幂，不仅能练练手，~~还可以刷最优解~~)

**code:**

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100;
int n,ans_f,p;
inline int ksm(int a,int b){
	int base=a,ans=1,t=b;
	while(t){
		if(t&1)ans*=base;
		base*=base,t>>=1;
	}
	return ans;
}//快速幂，此处建议用位运算写，会更快一些
inline int change(int x){
	int u=x%10,v=x/10;
	return ksm(v,u);
}//计算单个数的答案
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&p);
		ans_f+=change(p);
	}
	printf("%d",ans_f);//输出最终结果
	return 0;
}
```

---

## 作者：ei_hei_ (赞：0)

其实思路还是蛮简单的。


------------


### 我们先把目光放在 $Pi$ 上：

__$Pi$ 其实可以转化成一个数（ $Pi$ 的前面）的几次方（ $Pi$ 的个位数）__

什么意思呢？我们这里拿样例 $1$ 来举个例子：

$212$ 就是 $21$ 的 $2$ 次方，也就是 $21^2$。

而 $1253$ 就是 $125$ 的 $3$ 次方，也就是 $125^3$。

所以样例 $1$ 的答案就成了 $21^2+125^3$，也就是 $1953566$。

对应每一个 $Pi$ 的那个数就是 $Pi$ $\div$ $10$，那个数的几次方就是 $Pi\bmod 10$。

最后把所有 $Pi$ 转化成的次方数算出来，再加起来就可以了。



------------


__代码：__

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
long long n,a[11],b[11],c[11],d; /这个longlong其实duck不必
int main()
{
	cin>>n; /输入
	for(int i=1;i<=n;i++) 
	{
		int j=1,s=1;
		cin>>a[i]; 
		b[i]=a[i]/10; /这一步和下面一步是在转换
		c[i]=a[i]%10;
		while(j<=c[i]) s=s*b[i],j++; /算出次方数
		d=d+s;
	}
	cout<<d; /输出
    return 0;
}

```

---


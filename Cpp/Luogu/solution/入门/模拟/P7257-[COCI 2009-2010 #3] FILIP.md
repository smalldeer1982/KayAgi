# [COCI 2009/2010 #3] FILIP

## 题目描述

给你两个十进制正整数 $a, b$，输出将这两个数翻转后的较大数。

**「翻转」在本题中的定义详见「说明 / 提示」部分。**




## 说明/提示

#### 「翻转」在本题中的定义

设原数有 $f$ 位，最高位为 $a_1$，第二位为 $a_2$，……，第 $f$ 位为 $a_f$。

那么该数的翻转同样有 $f$ 位，最高位为为 $a_f$，第二位为 $a_{f - 1}$，……，第 $f$ 位为 $a_1$。

#### 数据规模及约定

对于 $100\%$ 的数据，$100 \le a, b \le 999$，$a, b$ 不含 $0$ 或不为 $0$。

#### 说明
翻译自 [COCI 2009-2010 #3 T1 FILIP](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 30，每个测试点 3 分，共 10 个测试点。



## 样例 #1

### 输入

```
734 893
```

### 输出

```
437```

## 样例 #2

### 输入

```
221 231
```

### 输出

```
132```

## 样例 #3

### 输入

```
839 237
```

### 输出

```
938```

# 题解

## 作者：CoronaQL (赞：22)

# 题外话
**这题有些水**（大雾）
## 思路
## 分两步
1.反转
2.比较（由于蒟蒻是个萌新，所以用了if比较）【大佬勿喷】

[题面](https://www.luogu.com.cn/problem/P7257)
<-由数据范围可知,这题都是三位数，数据很小，所以连字符串都不用awa
还有反转，就是一段段截，也就推出了我们的核心程序
## 伪代码
```cpp
m=m/100+(m%100/10)*10+(m%10)*100;
n=n/100+(n%100/10)*10+(n%10)*100;
```
# AC代码（大佬勿喷）
```cpp
#include<bits/stdc++.h>//为了代码简便，就先使用万能库啦 
using namespace std;//命名空间 
int m,n;//开在主函数外是个好习惯 
int main()
{
	scanf("%d %d",&m,&n);//比cin要快 
	m=m/100+(m%100/10)*10+(m%10)*100;//对m进行反转，分别对百位，十位，个位操作 
	n=n/100+(n%100/10)*10+(n%10)*100;//对n进行翻转，同理
	if(m>n)
	{
		cout<<m;//如果m大，就输出m 
	} 
	else
	{
		cout<<n;//如果相等或n大，就输出n 
	}
	return 0;//程序快乐地结束啦~~~ 
} 
```
 _莫抄袭，棕了少年名，空悲切！_ 

---

## 作者：tZEROちゃん (赞：9)

**upd 2021.04.21：** 修改了一处笔误。

### Solution

可以使用 `algorithm` 里的函数 `reverse` 来实现。

首先我们读入两个字符串（$a, b$）。

将这两个字符串翻转，在这里可以用 reverse $^{[1]}$。

然后直接比较这两个字符串的字典序即可——因为 $100 \le a, b \le 999$，所以这两个数只需按照从高到低的顺序比较即可。

$[1]:$

reverse 函数在 <http://www.cplusplus.com/reference/algorithm/reverse/?kw=reverse> 的描述是：

>Reverses the order of the elements in the range $[first,last)$.

即

>翻转在 $[first, last)$ 区间内的数的顺序。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	string a, b;
	cin >> a >> b;
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	cout << (a > b ? a : b);
}
```

---

## 作者：NASFsky (赞：6)

# **P7257 FILIP 题解**
读题，这道题是要我们输出两个数翻转后更大的那个数（翻转的定义如题所述）,那么这道题的核心点就在于如何翻转。
翻转就是把原数的最后一位给截下来放在末尾，那么就不难想到以下核心代码：
```cpp
int t=0;
while(x)
{
	t=t*10+x%10;//将末尾那一位给拼上去
	x/=10;//整除，相当于消掉最后一位
}
return t;
```
最后按题意输出最大值即可。
# **AC代码**
```cpp
#include <bits/stdc++.h>//万能头文件 
using namespace std; 
int awa(int a)//定义一个翻转函数 
{
	int t=0;
	while(a)
	{
		t=t*10+a%10;//将末尾那一位给拼上去
		a/=10;//整除，相当于消掉最后一位
	}
	return t;
}
int main()
{
	int a,b;
	cin>>a>>b;
	int a1=awa(a),b1=awa(b);//将两数翻转 
	if(a1>b1)cout<<a1;//按题意输出最大值 
	else cout<<b1;
	return 0;//结束awa 
}
```


---

## 作者：Eason_AC (赞：2)

## Content
有两个十进制三位数 $a,b$，请输出这两个数翻转之后的较大数。

**数据范围：$100\leqslant a,b\leqslant 999$，$a,b$ 中不包含 $0$ 或不为 $0$。**
## Solution
很水的一道题。你直接模拟下翻转，可以发现翻转之后的两个三位数分别是 $\overline{\left\lfloor\dfrac{a}{100}\right\rfloor(\left\lfloor\dfrac{a\mod 100}{10}\right\rfloor)(a\mod 10)}$ 和 $\overline{\left\lfloor\dfrac{b}{100}\right\rfloor(\left\lfloor\dfrac{b\mod 100}{10}\right\rfloor)(b\mod 10)}$。虽然看上去有些复杂，但是代码实现是不难的。
## Code
```cpp
int main() {
	int a = Rint, b = Rint;
	int aa = (a / 100) + (a % 100 / 10) * 10 + (a % 10) * 100,
		bb = (b / 100) + (b % 100 / 10) * 10 + (b % 10) * 100;
	printf("%d", max(aa, bb));
	return 0;
}
```

---

## 作者：fjy666 (赞：2)

### 0x01 思路
如何反转一个数？  
令原数为 $x$ ，新数为 $y$ 。
1. 当 $x$ 不为 $0$
2. 将 $x$ 的个位拼接在 $y$ 上
3. 将 $x$ 的个位删除
4. 回到第一步

- 怎么取出 $x$ 的个位？
- $ x \bmod 10$
+ 怎么将 $x$ 的个位拼接在 $y$ 上？ 
+ $ y \times 10 + x \bmod 10$
- 怎么删除 $x$ 的个位？
- $ x \gets x \div 10$

知道了这些，代码就好写了。

------------
### 0x02 代码
```cpp
#include <cstdio>
#define rtn return

int flip(int x)
{
	int rtn_ = 0;
	while(x)
	{
		rtn_ = rtn_ * 10 + x % 10;
		x /= 10;
	}
	rtn rtn_;
}

int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	int fa = flip(a),
		fb = flip(b);
	printf("%d",fa>fb?fa:fb);
	rtn 0;
}
```

---

## 作者：Runtimeerror90 (赞：2)

## 题意

输入两个数，将他们反转，输出大的那个数。

## 思路

将这两个数当作字符串读入，然后反转，再从第一位开始比较，如果一个数的最高位比另一个数的最高位大，那么直接输出前者，如果最高位相等，那么比较下一位。

# CODE

```cpp

#include<bits/stdc++.h>
using namespace std;
int main(){
	string a,b;
	cin>>a>>b;
	for(int i=2;i>=0;i--){
		if(a[i]-'0'!=b[i]-'0'){
			if(a[i]-'0'>b[i]-'0'){
				reverse(a.begin(),a.end());
				cout<<a;
				break;
			}
			else{
				reverse(b.begin(),b.end());
				cout<<b;
				break;
			}
		}
	}
	return 0;
}

```

完结，撒花

---

## 作者：Suzt_ilymtics (赞：2)

## 简述题意

~~已经很明确了，估计不需要简述了~~

## Solution

读入两个数 $a$, $b$

可以确定它们是三位数，所以考虑暴力翻转

那么对于任意一个数 $x$

它的个位数是 $x \!\!\mod 10$，十位数是 $x \div 10 \!\!\mod 10$，个位数是 $x \div 100$

而翻转后的数是 原个位数 $\times 100 +$ 原中位数 $\times 10 + $原个位数

所以可得到如下公式

$$x' = (x \!\!\!\!\mod 10) \times 100 + (x \div 10 \!\!\!\!\mod 10) \times 10 + (x \div 100)$$

## Code

```cpp
/*
Work by: Suzt_ilymics
Knowledge: ??
Time: O(??)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1;
const int INF = 1;
const int mod = 1;

int a, b;

int read(){
	int s = 0, f = 0;
	char ch = getchar();
	while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
	return f ? -s : s;
}

int main()
{
	a = read(), b = read();
	a = (a % 10) * 100 +(a / 10 % 10) * 10  + (a / 100);
	b = (b % 10) * 100 +(b / 10 % 10) * 10  + (b / 100);
	printf("%d", max(a, b));
	return 0;
}
```

---

## 作者：My_Faith (赞：1)

# 题意：
翻转两数+比较大小（~~不是我说，好水/fad~~
# 思路：
### 一.翻转：
根据题目的数据范围可知，这两个数都是3位数（100<a,b<999）。所以说，~~连字符串都用不到/jk~~,可以直接将数字读入后直接依照翻转三位数的公式进行翻转。

（假设要翻转的三位数为a），那么翻转后的a=a/100+(a%100/10) * 10+(a%10) * 100(对于翻转公式的进一步解释：（a/100）将百位挪动到个位，（(a%100/10) * 10）十位数位置不变，（a%10 * 100）将个位数移动到百位）。

### 二.比较大小：
直接用C++自带的max函数（用法：max(a,b)起返回值为a与b中较大的那个）即可，此处不过多叙述。

# Code：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int a,b;

int main(){
	cin>>a>>b;
	a=a/100+(a%100/10)*10+(a%10)*100;//对a进行翻转
	b=b/100+(b%100/10)*10+(b%10)*100;//对b进行翻转
	cout<<max(a,b);//输出a与b中较大的那个
	return 0;
} 
```


---

## 作者：wgy23672 (赞：1)

挑战不压行短代码！加return 0一共九行。

题意不说了，直接分析：

题目中要将两个数字翻转，显然我们可以使用字符串

# 方法
题目条件中说是三位数，并且我们都知道位值原理，**把输入数的首位（百位）$a[0]$作为新数的个位，十位不动，输入数的个位$a[2]$作为新数的百位**，对于$a$,$b$都是这样的操作方式，把新数存入$ans1$,$ans2$中就得到了最核心的代码：

```cpp
int ans1=(a[2]-'0')*100+(a[1]-'0')*10+(a[0]-'0'),ans2=(b[2]-'0')*100+(b[1]-'0')*10+(b[0]-'0');
```

# 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string a,b;
int main(){
cin>>a>>b;
int ans1=(a[2]-'0')*100+(a[1]-'0')*10+(a[0]-'0'),ans2=(b[2]-'0')*100+(b[1]-'0')*10+(b[0]-'0');
cout<<max(ans1,ans2)<<endl;
return 0;
}
```


---

## 作者：sysong (赞：0)

# 题解P7257 [COCI2009-2010#3] FILIP

### 题目描述

给你两个十进制正整数 $a, b$，输出将这两个数翻转后的较大数。

数据范围：($100 \le a,b \le 999$)

### Solution

数据范围这么小（三位数），做法很多。

大家都是输入之后处理数据，但是我们可以输入时就处理好倒序的问题。

我们可以考虑开一个临时的栈，按正序读入三个数字，然后倒序叠加，那么返回时就是翻转后的数了。

### Code

```c++
#include <bits/stdc++.h>
#define gc() getchar()
using namespace std;

template <typename T> void rd(T &x){
	int st[4],tp=0;									// 开临时的栈，tp 记录栈顶
	int f=1;x=0;char c=gc();
	for(;!isdigit(c);c=gc())if(c=='-')f=-1;
	for(;isdigit(c);c=gc())st[++tp]=c-'0';			// 读入时先压栈
	for(;tp;--tp)x=(x<<1)+(x<<3)+st[tp];			// 倒序处理
	x*=f;
}

int main(){
	int a,b;
	rd(a),rd(b);
	printf("%d\n",max(a,b));						// 读入时我们已经翻转处理了，所以这里直接比较 a，b
	return 0;
}

```

***by jsntsys***

$2021.1.10$



---


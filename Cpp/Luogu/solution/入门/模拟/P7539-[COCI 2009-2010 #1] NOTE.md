# [COCI 2009/2010 #1] NOTE

## 题目描述

C 大调的音阶由 $8$ 个音符组成：$\texttt{c,d,e,f,g,a,b,C}$。将每个音符用数字 $1$ 到 $8$ 编号。

音阶可以是**升序**的（从 $1$ 到 $8$）、**降序**的（从 $8$ 到 $1$），或者是**混合**的。

根据音符的顺序，确定音阶是升序的、降序的还是混合的。

## 说明/提示

#### 【说明】

本题分值按 COCI 原题设置，满分 $30$。

题目译自 [**COCI2009-2010 CONTEST #1**](https://hsin.hr/coci/archive/2009_2010/contest1_tasks.pdf) _**T1 NOTE**_。

## 样例 #1

### 输入

```
1 2 3 4 5 6 7 8```

### 输出

```
ascending```

## 样例 #2

### 输入

```
8 7 6 5 4 3 2 1```

### 输出

```
descending```

## 样例 #3

### 输入

```
8 1 7 2 6 3 5 4```

### 输出

```
mixed```

# 题解

## 作者：yydfj (赞：12)

**这是本蒟蒻第四次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你由 $8$ 个数字组成的序列，如果该序列为上升序列，就输出 ascending；如果该序列为下降序列，就输出 descending；如果都不是，就输出 mixed。

## 解法综述

因为给出的序列是由 $8$ 个数字组成的，为固定值且数量少，所以可以考虑用 $8$ 个变量来做。

先读入 $8$ 个变量，然后判断这些变量组成的序列是什么类型，之后输出该类型对应的答案即可。

## 代码描述
```cpp
#include<cmath>
#include<cstdio>
int a,b,c,d,e,f,g,h;
int main()
{
	scanf("%d%d%d%d%d%d%d%d",&a,&b,&c,&d,&e,&f,&g,&h);
	if(a<b&&b<c&&c<d&&d<e&&e<f&&f<g&&g<h) printf("ascending");//如果该序列为上升序列
	else if(b<a&&c<b&&d<c&&e<d&&f<e&&g<f&&h<g) printf("descending");//如果该序列为下降序列
	else printf("mixed");//如果都不是
	return 0;
}
```

---

## 作者：_lfxxx_ (赞：10)

**题目传送门：[P7539 [COCI2009-2010#1] NOTE](https://www.luogu.com.cn/problem/P7539)**
#### 前记：
蒟蒻看到题解中大部分用了数组~~而浪费了空间~~，于是决定发一个新奇的做法。
#### 题意：
读入 $8$ 个数，问你它的顺序。
#### 思路：
讲一个不用数组的方法：**用一个 `int` 代替数组。**

也许你看不懂什么意思，没关系，说明一下：

题目给的是 $8,1,7,2,6,3,5,4$ ，我们在读入时可以将他转换成 $81726354$ 这个数字。然后比较时可以将该数与 $12345678$ 和 $87654321$ 比较。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int s=0,a;//s是转化后的数，别忘记给s初始化
	for(int i=1;i<=8;i++){
		cin>>a;
		s=s*10+a;//将8个数字转换成一个数
	}
	if(s==12345678)
		puts("ascending");
	else if(s==87654321)
		puts("descending");
	else
		puts("mixed");
	return 0;
}
```
~~代码貌似还挺短。~~

---

## 作者：_lzh_ (赞：4)

## 思路

直接进行判断即可。

- 如果满足 $a_i>a_{i-1}$ ，那就是升序。

- 如果满足 $a_i<a_{i-1}$ ，那就是降序。

- 否则就是混合的。

具体实现见代码。

## Code

```cpp
#include<bits/stdc++.h>
#define N 11
using namespace std;
int a[N];
bool Is_up()//判断是否为升序 
{
	for(int i=2;i<=8;i++)
		if(a[i]<a[i-1])
			return false;
	return true;
}
bool Is_down()//判断是否为降序 
{
	for(int i=2;i<=8;i++)
		if(a[i]>a[i-1])
			return false;
	return true;
}
signed main()
{
	for(int i=1;i<=8;i++)cin>>a[i];//读入 
	if(Is_up())//如果是升序 
		cout<<"ascending";
	else if(Is_down())//如果是降序 
		cout<<"descending";
	else//否则是混合的 
		cout<<"mixed";
    return 0;
}
```

---

## 作者：幼儿园第一名 (赞：3)

### 思路：
我们设置 $b$ 数组用来存储音阶**升序排序**后的序列，设置 $c$ 数组用来存储音阶**降序排序**后的序列。

如果原数组和 $b$ 数组相同，那么就是升序。

如果原数组和 $c$ 数组相同，那么就是降序。

如果两个都不满足，就是混合。

### [Code](https://www.luogu.com.cn/paste/jb2xlwav)


---

## 作者：零殇 (赞：2)

#### 思路

由于上升和下降都只有一种序列，我们就可以单独储存（这里不建议使用字符串，否则你需要处理中间的空格，空行等）。

那我们就用两个数组分别保存两个序列，再进行匹配。

这里我们可以引入一个临时变量，若两个序列中相同位置的两个数相同，则记录它们的位置，反之则退出。

因此，当临时变量等于 $8$ 时，就说明这两个序列相同。

上代码：

```
#include<bits/stdc++.h>
using namespace std;
int a[10],b[10],c[10],tot1,tot2;
int main() {
	for(int i=1;i<=8;i++) {
		b[i]=i;
		c[i]=8-i+1;
	}
	for(int i=1;i<=8;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=8;i++) {
		if(a[i]==b[i])
			tot1=i;
		else
			break;
	}
	if(tot1==8) {
		printf("ascending");
		return 0;
	}
	for(int i=1;i<=8;i++) {
		if(a[i]==c[i])
			tot2=i;
		else
			break;
	}
	if(tot2==8) {
		printf("descending");
		return 0;
	}
	printf("mixed");
	return 0;
}
```

完结撒花~

---

## 作者：奥斯卡小冰人 (赞：2)

因为8个数都要输入而且8个数都不重复，那么升序只能是1，2，3，4... 8这样，降序只能是 8，7，6，5...1这样，其余的就是混合。那么这样只需要先用 $sort$ 函数排一次升序，判断是不是，再排一下降序，判断是不是，若都不是，就是混合。

AC code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10],b[10];
bool flag1 = 1,flag2 = 1;
bool cmp(int x,int y)
{
    return x > y;
}
int main()
{
    for(int i = 0;i < 8;i++) cin >> a[i];
    for(int i = 0;i < 8;i++) b[i] = a[i];
    sort(b,b + 8);
    for(int i = 0;i < 8;i++) if(a[i] != b[i]) flag1 = 0;
    if(flag1) 
    {
        cout << "ascending";
        return 0;
    }
    sort(b,b + 8,cmp);
    for(int i = 0;i < 8;i++) if(a[i] != b[i]) flag2 = 0;
    if(flag2) 
    {
        cout << "descending";
        return 0;
    }
    cout << "mixed";
    return 0;
}

```


---

## 作者：Exber (赞：1)

## 做法
边输入边判断。

用一个变量 ```type``` 来表示音阶是升序、降序还是混合的。定义当 ```type``` 为 ```0``` 时表示音阶是升序的，为 ```1``` 时表示音阶是降序的，为 ```2``` 时表示音阶是混合的，为 ```-1``` 时表示待确定。那么我们只要在输入的时候判断一下本个和前一个音符的大小关系就可以很轻松地计算出最终的 ```type``` 了。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int a[10];
int type=-1; // 序列类型，-1 表示未知，0 表示升序，1 表示降序，2 表示混合 

int main()
{
	scanf("%d",&a[1]); // 先输入第一个音符 
	for(int i=2;i<=8;i++)
	{
		scanf("%d",&a[i]);
		if(a[i-1]<a[i]) // 比前一个音高，序列是升序的 
		{
			if(type==-1) // 未确定 
			{
				type=0; // 类型更改为升序 
			}
			if(type==1) // 之前是降序的 
			{
				type=2; // 类型更改为混合 
			}
		}
		if(a[i-1]>a[i]) // 比前一个音低，序列是降序的 
		{
			if(type==-1) // 未确定 
			{
				type=1; // 类型改为降序 
			}
			if(type==0) // 之前是升序的 
			{
				type=2; // 类型改为混合 
			}
		}
	}
	if(type==0) // 升序 
	{
		printf("ascending\n");
	}
	if(type==1) // 降序 
	{
		printf("descending\n");
	}
	if(type==2) // 混合 
	{
		printf("mixed\n");
	}
	return 0;
}
```


---

## 作者：Aiopr_2378 (赞：1)

# Solution P7539 [COCI2009-2010#1] NOTE

注意：本题满分$30$，所以会出现$Accepted 30$的情况，代表通过。

## 一、思路总结：

思路还是很简单的，一共输入$8$个数，$a[i]$表示第$i$个数：

- 如果是**升序**，也就是$a[i]==1$；

- 如果是**降序**，也就是$a[i]==8-i+1$；

- 两个都不是，就是**混合**的。

## 二、参考代码：

注意，我这里$a[]$数组是从$0$开始计算的，也就是输入$a[0]$到$a[7]$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[8];
int main(){
	for(int i=0;i<8;i++) cin>>a[i];//我是从a[0]开始输入的
	if(a[0]==1&&a[1]==2&&a[2]==3&&a[3]==4&&a[4]==5&&a[5]==6&&a[6]==7&&a[7]==8){//依次判断
		cout<<"ascending";
	}
	else if(a[0]==8&&a[1]==7&&a[2]==6&&a[3]==5&&a[4]==4&&a[5]==3&&a[6]==2&&a[7]==1){
		cout<<"descending";
	}
	else cout<<"mixed";
	return 0;
}
```

感谢您的阅览，祝您早日犇犇！

---

## 作者：tZEROちゃん (赞：1)

### Solution

作为 2009 的 COCI T1，这题还是很水的（

根据题意，显然：

- ascending：$\texttt{1 2 3 4 5 6 7 8}$；
- descending：$\texttt{8 7 6 5 4 3 2 1}$；
- mixed：既不是 ascending 又不是 descending。

所以我们读入一个字符串，判断它是不是 $\texttt{1 2 3 4 5 6 7 8}$ 或 $\texttt{8 7 6 5 4 3 2 1}$，是就输出对应的字符串，不是就输出 `mixed`。

### Code
```cpp
#include <bits/stdc++.h>
#define debug printf("%d",__LINE__)
using namespace std;
signed main()
{
	string des = "8 7 6 5 4 3 2 1";
	string asc = "1 2 3 4 5 6 7 8";
	string s;
	getline (cin, s);
	if (s == des) {
		puts("descending");
	} else if (s == asc) {
		puts("ascending");
	} else {
		puts("mixed");
	}
	return 0;
}

```

---

## 作者：HYdroKomide (赞：1)

## **正文：**
### 思路：
一道极氵的分支判断题目。只需要判断是否为 $8,7,6,5,4,3,2,1$ 或者 $1,2,3,4,5,6,7,8$ 即可。前者输出 `descending`，后者输出 `ascending`，其他情况输出 `mixed`。程序也应该不需要解释了，没学过 `for` 循环的都能看懂。
### 程序如下：
```cpp
#include<cstdio>
using namespace std;
int a,b,c,d,e,f,g,h;
int main(){
    scanf("%d%d%d%d%d%d%d%d",&a,&b,&c,&d,&e,&f,&g,&h);
    if(a==1&&b==2&&c==3&&d==4&&e==5&&f==6&&g==7&&h==8)printf("ascending\n");
    else if(a==8&&b==7&&c==6&&d==5&&e==4&&f==3&&g==2&&h==1)printf("descending\n");
    else printf("mixed\n");
    return 0;
}
```
## **THE END**

---


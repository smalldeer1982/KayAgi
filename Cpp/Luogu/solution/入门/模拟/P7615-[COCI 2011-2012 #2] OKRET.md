# [COCI 2011/2012 #2] OKRET

## 题目描述

给定一幅 $R \times C$ 的地图，其中 `.` 表示该格子能走，`X` 表示该格子不能走。判断该地图是否有死胡同。

如果一个格子满足上下左右四个格子中**只有一个格子能走**，那么这个格子就是死胡同。当然，不能走到地图外。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$3 \le R,C \le 10$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $80$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #2](https://hsin.hr/coci/archive/2011_2012/contest2_tasks.pdf)** ___T2 OKRET___。

## 样例 #1

### 输入

```
4 3
XXX
X.X
X.X
XXX```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5
XX.XX
X...X
.....
X...X
XX.XX```

### 输出

```
1```

## 样例 #3

### 输入

```
3 9
...XXX...
.X.....X.
...XXX...```

### 输出

```
0```

# 题解

## 作者：可爱的小于 (赞：7)

题意要求我们从一个 $n$ 行 $m$ 列的地图中，找到一个上下左右只有一条路的通道。

根据题意，我们只需要将一个通道确定，再对数组中上下左右的通道累计即可。

该题使用双重循环模拟，小心数组为 $-1$ 时 RE ，便可以从数组位置 $1$ 开始计数。

当其中一个点旁边只有一条通道时就是死胡同，可以直接输出 $1$ ，结束程序。

至于输出 $0$ ，我们只需要再在最后输出就行了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    char a[12][12];
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        cin>>a[i][j];
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        if(a[i][j]=='.')
        {
            int q=0;
            if(a[i+1][j]=='.')
            	q++;
            if(a[i-1][j]=='.')
            	q++;
            if(a[i][j+1]=='.')
            	q++;
            if(a[i][j-1]=='.')
            	q++;
            if(q==1)
            {
                cout<<1;
                return 0;
            }
        }
    }
    cout<<0<<endl;
    return 0;
}
```

---

## 作者：_Harrisonwhl_ (赞：4)

我们可以将这个图存起来，然后对于每个可通行格看看是不是三个方向是不是都是死路或者是不是只有一个活路，如果有格子只有一条活路，即为“死胡同”。
# Code:
判断三个死路：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
char a[13][13];
int main()
{
    cin >> n >> m;
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= m;j++)
            cin >> a[i][j];
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= m;j++)
        {
            int cnt = 0;
            if (a[i - 1][j] == 'X' || i == 1) cnt++;
            if (a[i][j - 1] == 'X' || j == 1) cnt++;
            if (a[i + 1][j] == 'X' || i == n) cnt++;
            if (a[i][j + 1] == 'X' || j == m) cnt++;
            if (cnt == 3 && a[i][j] == '.')
            {
                puts("1");
                return 0;
            }
        }
    puts("0");
    return 0;
}
```
判断一条活路：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
char a[13][13];
int main()
{
    cin >> n >> m;
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= m;j++)
            cin >> a[i][j];
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= m;j++)
        {
            int cnt = 0;
            if (a[i - 1][j] == '.') cnt++;
            if (a[i][j - 1] == '.') cnt++;
            if (a[i + 1][j] == '.') cnt++;
            if (a[i][j + 1] == '.') cnt++;
            if (cnt == 1 && a[i][j] == '.')
            {
                puts("1");
                return 0;
            }
        }
    puts("0");
    return 0;
}
```

---

## 作者：D2T1 (赞：2)

[$\color{blue}{\text {pwp }{\to\textbf{My blog}\gets}}\text{qwq}$](https://www.luogu.com.cn/blog/390770/blogcenter)

## 题解

做题的第一步，是把数据读入进来。

这道题要求读入一个二维的字符数组，可以用 `scanf` 来读取。`scanf` 可以直接读取一个一维字符数组，所以只用一重循环就行了。

```cpp
	int r,c;
	char m[15][15];

	scanf("%d%d",&r,&c);//首先按题意读取 R,C
	for(int i=1; i<=r; ++i)
		//%s 代表读入字符数组，不用加取地址符 &
		scanf("%s",m[i]+1);//m[i]+1 表示从 m[i][1] 开始读入
```

为什么从第一位开始读呢？因为题目要考虑边框问题，如果不小心访问到了 $-1$ 什么的地址，就会 $\color{purple}RE$。

------------

接下来我们要使用二重循环对整个二维字符数组进行遍历，找出是否有符合条件的格子。

```cpp
	for(int i=1; i<=r; ++i){
		for(int j=1; j<=c; ++j){
			if(m[i][j]=='.'){//如果是能走的格子
				int k=0;//计不能走的格子数
				if(m[i-1][j]!='.') ++k;
				if(m[i+1][j]!='.') ++k;
				if(m[i][j-1]!='.') ++k;
				if(m[i][j+1]!='.') ++k;
				if(k==3){//三个格子都不能走 -> 只有一个格子能走
					putchar('1');
					return 0; 
				}
			}
		}
	}
```

由于有边界的原因，所以在判断格子能否走的时候要使用 `!='.'` 而不是 `=='X'`，因为我们不知道边界存储的字符是什么（其实都是字符 `\0`，因为 $m$ 是全局的），因为我们没有把它读入进来。

------------

最后如果没找到“死胡同”，输出 `0` 即可。

## 代码

```cpp
//P7615
#include <cstdio>
int r,c;
char m[15][15];

int main(){
	scanf("%d%d",&r,&c);
	for(int i=1; i<=r; ++i)
		scanf("%s",m[i]+1);
	for(int i=1; i<=r; ++i){
		for(int j=1; j<=c; ++j){
			if(m[i][j]=='.'){
				int k=0;
//				printf("%d %d %c %c %c %c\n",i,j,m[i-1][j],m[i+1][j],m[i][j-1],m[i][j+1]);
				if(m[i-1][j]!='.') ++k;
				if(m[i+1][j]!='.') ++k;
				if(m[i][j-1]!='.') ++k;
				if(m[i][j+1]!='.') ++k;
				if(k==3){
					putchar('1');
					return 0; 
				}
			}
		}
	}
	putchar('0');
	return 0;
}
```


---

## 作者：CPPfive (赞：0)

### 题意
- 判断是否存在一个点使得上下左右四个点均不能通过。
- 注意这个点本身应该可以通过。（吐槽一下，题目都没有说清楚）

### 实现
很显然循环一遍就可以了。

为了代码写起来更方便一点，我们把地图外的点全部当作不可走，这样就不需要特判。

在判断一个点是不是死胡同时，我们直接把上下左右四个点的值加起来判断一下是否等于 1 即可。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int R,C;
bool vis[15][15],ans; //默认初始化为false 这样就不需要在把地图外的点设成不可走 
#define cin std::ios::sync_with_stdio(false);cin //输入优化 

int main()
{
	cin >> R >> C;
	for(int i=1;i<=R;i++){
	    for(int j=1;j<=C;j++){
	        char c;cin >> c;
		if(c=='.') vis[i][j]=1;
	    }
	}
	for(int i=1;i<=R;i++){
	    for(int j=1;j<=C;j++){
		if(vis[i+1][j]+vis[i-1][j]+vis[i][j+1]+vis[i][j-1]==1&&vis[i][j]){//一定要判断这个点本身是否可走 
       	            ans=1;
		    break;
		}
	    }
	    if(ans) break;
	}
	printf("%d",ans?1:0);
}
```




---

## 作者：_OJF_ (赞：0)

这道题直接模拟

模拟过程：

将不能走的格子记为 0，能走的格子记为 1

地图外的点全设为 0 （相当于不能走的格子）

枚举每个能走的点，如果有任意一个格子周围格子之和为 1，那么就输出 1，否则输出 0

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int r, c, a[15][15], ans;
char s;
int main(){
    cin>>r>>c;
    for(int i = 1;i <= r;i++){
        for(int j = 1;j <= c;j++){
            cin>>s;
            if(s == '.')
                a[i][j] = 1;
        }
    }
    for(int i = 1;i <= r;i++)
        for(int j = 1;j <= c;j++)
            if(a[i][j - 1] + a[i][j + 1] + a[i - 1][j] + a[i + 1][j] == 1 && a[i][j] == 1)
                ans = 1;
    cout<<ans;
    return 0;
}
```


---

## 作者：fanypcd (赞：0)

### 题目简述：

给定一个地图，判断是否存在**至少**一个点，使得这个点上下左右四个方向**有且仅有**一个方向可以通行。

### 题目思路：

- 模拟（真的模拟）
- 读入图，将不可到达的点权值记为 1，否则记为 0
- 地图边界上的点全部记为 1 （均不可到达）
- 枚举所有点，判断这个点上下左右点权值之和是否为 3 （这样就不用写 3 个 if ）
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int r, c;
int ma[15][15];
int check(int x, int y)
{
	int cnt = ma[x - 1][y] + ma[x][y - 1] + ma[x + 1][y] + ma[x][y + 1];
	return cnt == 3;
}
int main()
{
	ios::sync_with_stdio(false);
	char s; 
	cin >> r >> c;
	for(int i = 1; i <= r; i++)
	{
		for(int j = 1; j <= c; j++)
		{
			cin >> s;
			ma[i][j] = (s == 'X' ? 1 : 0);
		}
	}
	for(int i = 1; i <= r; i++)
	{
		ma[i][0] = ma[i][c + 1] = 1;
	}
	for(int i = 1; i <= c; i++)
	{
		ma[0][i] = ma[r + 1][i] = 1;
	}
	for(int i = 1; i <= r; i++)
	{
		for(int j = 1; j <= c; j++)
		{
			if(ma[i][j] == 0 && check(i, j))
			{
				cout << "1";
				return 0;
			}
		}
	}
	cout << "0";
	return 0;
}
```


---

## 作者：ZBAA_MKC (赞：0)

#### 思路分析

每次输入一个字符，如果是 `X` 就在另外一个标记数组上把这一点标为 `false`, 表示不能走，否则就标为 `true`。之后我们在挨个验证每一个点周围四个点中不能走的点的个数（可能包括墙壁）是否为 $3$, 如果是就立即输出 `1` 并结束程序。如果把所有的点扫完后都没有发现符合上述要求的点，那就输出 `0`。

#### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

bool f[15][15];
int main()
{
    int r, c;
    cin >> r >> c;
    for (int i = 1; i <= r; i++)
    {
    	for (int j = 1; j <= c; j++)
    	{
    		char x; //输入
    		cin >> x;
    		if (x == 'X')
    		{
    			f[i][j] = false;
			}
			else
			{
				f[i][j] = true;
			}
		}
	}
	for (int i = 1; i <= r; i++)
	{
		for (int j = 1; j <= c; j++)
		{
			int cnt = 0;
			if (f[i][j]) //判断
			{
				if (!f[i - 1][j])
				{
					cnt++;
				}
				if (!f[i + 1][j])
				{
					cnt++;
				}
				if (!f[i][j - 1])
				{
					cnt++;
				}
				if (!f[i][j + 1])
				{
					cnt++;
				}
				if (cnt == 3) //符合要求就输出并结束程序
				{
					cout << 1;
					return 0;
				}
			}
		}
	}
	cout << 0; //没有找到
	return 0;
}
```


---


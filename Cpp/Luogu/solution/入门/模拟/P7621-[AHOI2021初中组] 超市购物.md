# [AHOI2021初中组] 超市购物

## 题目背景

AHOI2021 初中组 T1

**你可以选择跳过背景部分。**

春的一天，正是乍暖还寒时候，狂风乍起。小可可裹紧了单薄的外衣，往小雪家中赶去。

“今天真不是个出门的时候啊！”小可可感叹道。

“但是我还有东西要买……你就陪我去下超市吧？”

在超市里，小雪一共买了 23.70 元的东西，最后却只付了 20.1 元，小可可见状很疑惑。

“超市对学生有优惠呗，最后会打八五折。”

“那也不可能是这个价啊？我想想……应该是 20.145 元才对。”

“超市结算的时候最后会去分化整，也就是说，以角作为付钱的最小单位，多的零头就不要了。”

## 题目描述

现在，假如小可可一共买了 $n$ 种类型的商品，第 $i$ 种商品的单价为 $a_i$ 元，买了 $b_i$ 件，最后打八五折，并且舍去多出的小于一角的零头，你能不能帮他算算实际要付的钱数？

## 说明/提示

【样例 1 解释】

这就是【题目背景】中的例子。

【样例 2 解释】

小可可的原购买金额为 $3.00 \times 2 + 17.95 \times 1 + 0.10 \times 1 = 24.05$ 元，打八五折后为 $24.05 \times 85\% = 20.4425$ 元，去掉零头后为 $20.4$ 元。

【数据范围与提示】

**提示：如果你对浮点数不熟悉的话，请尽量利用整数完成。**

- 对于 $30\%$ 的测试点，保证 $n=1$；
- 对于另外 $30\%$ 的测试点，保证答案是整角；
- 对于 $100\%$ 的测试点，保证 $1 \le n \le 10$，$0.01 \le a_i \le 99.99$，$1 \le b_i \le 10$。

## 样例 #1

### 输入

```
1
23.70 1```

### 输出

```
20.1```

## 样例 #2

### 输入

```
3
3.00 2
17.95 1
0.10 1```

### 输出

```
20.4```

## 样例 #3

### 输入

```
见附加文件的 shopping3.in。```

### 输出

```
见附加文件的 shopping3.ans。```

# 题解

## 作者：Cripple_Abyss (赞：37)

## [题目传送门](https://www.luogu.com.cn/problem/P7621)


## Description ：
- 小可可购买了 $n$ 个商品，第 $i$ 个价格为 $a_i$ 元，买了 $b_i$ 个。

- 求在打了八五折的基础上需要付多少钱。

- 用 $\color{red}\text{去尾法}$ 保留一位小数！！！（这个在考场上害了许多人）

## Solution :
- 模拟，每次加上 $a_i \times b_i$ 。

- 主要还是如何用去尾法保留一位小数：

- 这里介绍一个比较好理解的方法，将最后的答案减去 0.49，然后在四舍五入。

- 为什么是 0.49 而不是 0.5 ？？？

- 我在考场调了很长时间，结果发现在 C++ 中是“四舍六入五成双” ！！！

- 这里 “四” 是指 $\le4$ 时舍去，"六" 是指 $\ge6$ 时进一。

- 最复杂的是 “五” ， "五" 指的是根据 5 后面的数字来定，当 5 后有数时，舍 5 进 1 ；当 5 后无有效数字时，需要分两种情况来讲：5 前为奇数，舍 5 入 1 ；5 前为偶数，舍 5 不进（ 0 是偶数）。

## Code（我的考场代码）：
```cpp
#include <cstdio>
int n,b;
float a,ans; 
int main() {
	scanf("%d",&n);
	while (n--) {
		scanf("%f%d",&a,&b);
		ans+=a*b;
	}
	printf("%.1f",ans*0.85-0.049);
	return 0;
}

```

---

## 作者：ZBAA_MKC (赞：7)

2021-7-10 更正一个错误

这题其实不难，但要认真审题，如果你四舍五入输出只能得 $70$ 分。因为本题要求抹去小数点第二位及以后的所有数，而不是四舍五入。所以我们需要进行如下的处理：

```cpp
ans *= 10;
printf("%.1lf", floor(ans) / 10.0);
```

没看懂？举个例子就明白了。

如：$ans=23.19422$

乘 $10$ 后得：$231.9422$

下取整后得：$231$

除以 $10$ 后得：$23.1$

从而就达到了截断保留 $1$ 位的目的。

现在大家应该都懂了，于是就可以上代码了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
	cin >> n;
	double ans = 0.0;
	while (n--)
	{
		double a, b;
		cin >> a >> b;
		ans += a * b;
	} 
	ans *= 0.85;
	ans *= 10;
	printf("%.1lf", double(int(ans)) / 10.0);
	return 0;
}
```


---

## 作者：meyi (赞：5)

2025/1/23 upd: 由于再次收到关于 #4 精度问题的反馈，因此在此给出一种正确做法及 #4 的样例解释。

将物品单价和折扣都乘以 100，从而完全使用整数运算，以避免精度误差。

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,n;
int main(){
    scanf("%d",&n);
    while(n--){
        int a1,a2,b;
        scanf("%d.%d %d",&a1,&a2,&b);
        ans+=(a1*100+a2)*b;
    }
    ans*=85;
    ans/=1000;
    printf("%d.%d\n",ans/10,ans%10);
    return 0;
}
```

样例 #4 的输入内容为：
```
10
76.58 10
42.77 2
18.61 4
72.04 6
81.43 9
52.35 9
78.80 3
70.71 7
23.71 9
21.90 8
```

计算可得 $76.58\times10+42.77\times2+18.61\times4+72.04\times6+81.43\times9+52.35\times9+78.80\times3+70.71\times7+23.71\times9+21.90\times8=3682$。

而 $3682\times0.85=3192.7$。

样例 #4 的输出内容确实为 $3192.7$，因此数据无误。

2024/1/8 upd: 感谢 [yuzhouhua70](https://www.luogu.com.cn/user/183566) 指出标程无法通过 #4，经检查，标程和数据没有事实性错误，但是开启 O2 优化会在 #4 产生 0.1 的误差，本人实力有限无法得知原因，如果读者知道具体原因还烦请告知，因此使用标程进行测试时请勿开启 O2 优化。

注：本题解搬运自出题人在 GitHub 上公布的[官方题解](https://github.com/rushcheyo/AHOI-2021-junior)，数据及标程均可从此链接中下载。

直接模拟即可，可参见标程。

```cpp
#include <cstdio>

int main() {
  int n;
  double sum = 0;
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) {
    double a;
    int b;
    scanf("%lf%d", &a, &b);
    sum += a * b;
  }
  sum *= 0.85;
  printf("%.1f\n", int(sum * 10) / 10.0);
}
```

---

## 作者：SunsetSamsara (赞：4)

这题其实不难。我们直接模拟就可以过了，坑点也不多，主要就是强制保留 $1$ 位小数，用

```printf("%.1lf\n",ans)```

就可以了。

然后接下来就是去分了，直接乘以 $10$ 取整后除以 $10.0$ 即可。

为什么呢？

~~有什么好说的，一个一个试啊~~

乘以 $10$ 后取整是什么呢？这个数取整和这个数小数点后第 $1$ 位拼起来，截去后面所有数字。

除以 $10.0$ 后呢？再小数点左移一位，变成原来那个数切掉小数点后 $1$ 位后面的所有数字。

所以，这么就可以实现去分了。


最后奉上 C 语言代码：
```c
#include<stdio.h>
int n;//种类数 
double a[11],b[11];//单价和购买量
double sum;//总价
double ans;//答案 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%lf%lf",a+i,b+i);//输入a[i]和b[i]
        sum+=a[i]*b[i];//总价要加 
    }
    ans=sum*0.85;//先打八五折
    ans=((int)(ans*10+0.01))/10.0;
    //乘上100取整得到答案*10,别忘了再除以10。0.01是为了消除浮点误差
    //得到的就是去分的结果辣
    printf("%.1lf\n",ans);//强制保留1位小数 
}
```

upd.on 2021.7.08：消除浮点误差

---

## 作者：LinkZelda (赞：3)

update:

在管理员的提醒下发现对浮点数的认识有误，已更改。

- **题意**：

给定 $n$ 对数 $a_i,b_i$ ，其中 $a_i$ 为浮点数，求 $0.85\times\sum_{i=1}^n a_i\times b_i$。要求保留一位小数，**直接舍去后面的位数**。

- **做法**：

计算过程直接模拟就好，问题在于如何直接舍去后面的位数，因为 `c++` 浮点数默认的是四舍六入五成双原则。

- 何为四舍六入五成双原则？

四舍六入很好理解，五成双的意思是如果该位为 $5$ 则分情况讨论，若该位后面有有效数字（即后一位不为 $0$ ），则直接进 $1$ ；否则判断该位之前的一位是否为偶数，若为偶数则直接则舍去该位，否则进 $1$ 。

回到这题，我们只要把结果先乘以 $10$ 然后用 `floor` 下取整，再除以 $10$ 即可。

- [代码](https://www.luogu.com.cn/paste/frlnrnjk)

---

## 作者：wangbinfeng (赞：1)

首先感谢大家阅读


------------
# 1. 思路：
> 现在，假如小可可一共买了 $n$ 种类型的商品，第 $i$ 种商品的单价为 $a_i$ 元，买了 $b_i$ 件，最后打八五折，并且舍去多出的小于一角的零头，你能不能帮他算算实际要付的钱数？

这句告诉了我们，需要累加答案。让每一次需要累加的内容为 $a*b$ （至于八五折你既可以在本处 $*0.85$ ，也可以在输出处）

于是我们就痛快的交了代码。
# 2. 代码

```
#include<cstdio>
#include<cmath>
double ans,a;
int n,b;
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%lf%d",&a,&b);//输入a和b，注意变量类型
        ans+=a*b*0.85;//计算每一次的结果，ans+=a*b*0.85即ans=ans+a*b*0.85
    }
    printf("%.1lf",floor(ans*10)/10.0);//注意输出格式，如果上面没有*0.85记着此处要有
    return 0;
}
```

---

## 作者：SUNCHAOYI (赞：1)

简单题，大致的题意就是求 $(\sum_{i = 1}^n a_i \times b_i) \times 0.85$，然后保留一位小数的值。需要注意的是，**这里的保留一位小数是直接舍去后面的数字，而不是四舍五入求值**！

处理保留一位小数的两种方法：
1. 分类讨论，如果小数部分 $>0.5$，就整体减去 $0.5$，否则不变，然后直接用 `%0.1lf` 输出。
2. 直接操作 `tot = ((int)(tot * 0.85 * 10)) / 10.0`。

另外就直接相加就完事了。。。代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init(x) memset (x,0,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 1e5 + 5;
const int MOD = 1e9 + 7; 
int n,sum;double price,tot;
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	scanf ("%d",&n);
	while (n--)
	{
		scanf ("%lf%d",&price,&sum);
		tot += price * sum;
	}
	tot = ((int)(tot * 0.85 * 10)) / 10.0;
	printf ("%0.1lf\n",tot);
	return 0;
}
```

---


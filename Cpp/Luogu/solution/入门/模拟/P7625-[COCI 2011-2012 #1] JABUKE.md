# [COCI 2011/2012 #1] JABUKE

## 题目描述

Mirko 最近迷上了一款电子游戏。

这款游戏的屏幕被分成 $N$ 列。在屏幕的底部，有一艘 $M$ 列宽的船。游戏中，玩家可以将这艘船左右移动，但船必须**时刻保持完全在屏幕内**。初始时船占据屏幕最左边的 $M$ 列。

有苹果会从屏幕顶部掉落。每个苹果都从顶部的 $N$ 列的其中一列开始以直线掉落。当当前的苹果掉落到屏幕底部时，下一个苹果开始掉落。

如果当一个苹果掉落到底部时，船覆盖了苹果所在的列，那么我们说**这个苹果是被捡起的**。你的任务是在捡起所有苹果的前提下，最小化船移动的距离。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le M < N \le 10$，$1 \le J \le 20$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $50$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T1 JABUKE___。

## 样例 #1

### 输入

```
5 1
3
1
5
3```

### 输出

```
6```

## 样例 #2

### 输入

```
5 2
3
1
5
3```

### 输出

```
4```

# 题解

## 作者：可爱的小于 (赞：11)

首先，我们需要想到船有长度，可以用两个变量存储船的左右两边。

然后，我们需要累加船移动的数值，在最后输出。

其次，我们要判断苹果距离船的距离，屏幕的列数可以不用去考虑。

最后，将船的下标进行改动。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int l=1,r,n,m,a[25],sum=0,x;
    cin >> x >> m >> n;
    r=m;
    for(int i=1;i<=n;i++)
    {
        cin >> a[i];
        if(a[i]>r)
        {
            sum+=a[i]-r;
            r=a[i];
            l=r-m+1;
        }
        if(a[i]<l)
        {
            sum+=l-a[i];
            l=a[i];
            r=l+m-1;
        }
    }
    cout << sum << endl;
    return 0;
}

```


---

## 作者：Orange_qwq (赞：7)

蒟蒻第一次发题解咧~

[题目传送门](https://www.luogu.com.cn/problem/P7625)

### 分析

这道题其实是以判断坐标为准，既然船有长度，那么就用```l```和```r```来存左边和右边的坐标。

我们设苹果的坐标为```a```。这时有3种情况：

1.  苹果在船的左边。
这样的话，苹果与船的距离以及要移动的步数为 ```l - a``` 。更新 ```l``` 和 ```r``` 。

2. 苹果在船的右边。
这样的话，苹果与船的距离以及要移动的步数为 ```a - r``` 。更新 ```l``` 和 ```r``` 。

3. 苹果在船上。
这一点不用判断，所以不用考虑，只考虑上面两种情况。

### 实现

根据分析，我们进行编程：

+ 苹果在船的左边。

```
if(a < l){
	ans += l - a;
	l = a;
	r = l + m - 1;
}
```

+  苹果在船的右边。

```
if(a > r){
	ans += a - r;
	r = a;
	l = r - m + 1;
}
```

### AC CODE

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,j,ans = 0,l = 1,r;
	cin >> n >> m >> j;
	r = m;
	for(int i = 1;i <= j;i++){//也可以是while(j--)
		int a;
		cin >> a;
		if(a < l){
			ans += l - a;//这里前进的步数要加进去
			l = a;     //左坐标更换
			r = l + m - 1;
        //这个地方要注意顺序，我就因为后两步的顺序反了WA了我一个半小时。。。
		}
		if(a > r){
			ans += a - r;
			r = a;
			l = r - m + 1;
            //同上
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Aiopr_2378 (赞：4)

# Solution P7625 [COCI2011-2012#1] JABUKE

### 题目大意：

你有一艘长 $m$ 的船，在 $n$ 个格子里移动，开始在第 $1$ 个格子。每次有一个苹果在第 $J_i$ 个格子落下。你的任务是捡起所有苹果且求最小移动距离。

### 思路：

每次苹果和船的位置会有三种情况（$apple$表示苹果位置、$nowr$表示船左端的位置、$nowl$表示船有段的位置）：

- 苹果在船上，即$nowr<=apple<=nowl$

- 苹果在船左侧，即$apple<nowr$

- 苹果在船右侧，即$nowl<=apple$

每次我们要给出最优方案，即船运动最小值：

- 第一种情况，船不动

- 第二种情况，船向左侧走最短距离，即$sum+=nowr-apple$

- 第三种情况，船向右侧走最短距离，即$sum+=apple-nowl$

同时，我们也要移动船的位置，即$nowr$和$nowl$：

- 第一种情况，不移动

- 第二种情况，$nowr=apple,nowl=apple+m-1$

- 第三种情况，$nowr=apple-m+1,nowl=apple$

### 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,k,nowl,nowr,apple,sum=0;
	cin>>n>>m>>k;
	nowl=1+m-1;
	nowr=1;
	for(int i=1;i<=k;i++){
		cin>>apple;
		if(nowl<apple){//第三种情况
			sum+=apple-nowl;
			nowl=apple;
			nowr=apple-m+1;
		}
		if(nowr>apple){//第二种情况
			sum+=nowr-apple;
			nowr=apple;
			nowl=apple+m-1;
		}
	}
	cout<<sum;
	return 0;
}
```

看了这么久，点个赞再走吧

---

## 作者：wangzhiyuan123 (赞：1)

用 nowleft 和 nowright 存储每一步时的船左端和船右端，对于每个苹果，计算到那一行的最小值   
如果苹果在船左端以左，就把船往左移，如果在右端以右，就往右移，如果在这个区间内，就不用动了   
```
#include<bits/stdc++.h>
using namespace std;
int n,m,J,a,ans,nowleft=1,nowright;//初始左端在1位置
signed main(){
	cin>>n>>m>>J;
	for(int i=1;i<=J;i++){
		cin>>a;
		if(a<nowleft){//是不是要左移 
			ans+=nowleft-a;
			nowleft=a;//左移 
		}else{
			nowright=nowleft+m-1;//计算右端 
			if(a>nowright){//是否右移 
				ans+=a-nowright;
				nowright=a;//右移
				nowleft=nowright+1-m;
			}
		}
	}
	cout<<ans;
}
```


---

## 作者：sid_shi1 (赞：1)

题目：[P7625 [COCI2011-2012#1] JABUKE](https://www.luogu.com.cn/problem/P7625)

思路：

这题是一道模拟题，我们用 $l$ 和 $r$ 存储船的左右列数，一开始 $l=1$ ， $r=m$ 。

每次输入判断苹果所在的位置，若苹果的坐标 $x$ 刚好在 $l$ 和 $r$ 之间，总和 $sum$ 和 $l$ 和 $r$ 都不用变。若在船的右侧，也就是 $x>r$ ，就要将 $r$ 移至 $x$ ，则 $l=r-m+1$ ， $sum$ 要加上 $x-r$ （移动的步数）。相反若 $x<l$ ，则  $l=x$ ， $r=l+m-1$ ， $sum=sum+l-x$ 。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,k,sum=0;
	cin>>n>>m>>k;
	int l=1,r=m;
	for(int i=1;i<=k;i++){
		int x;
		cin>>x;
		if(x>r) sum+=x-r,r=x,l=r-m+1;//苹果在船右侧
		if(x<l) sum+=l-x,l=x,r=l+m-1;//苹果在船左侧
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：dang_dang (赞：1)

### 首先就是审题：

这是一道模拟题，主要是模拟船的位置。

我们把船的左边和右边储存下来，记作```bl```为船左边的位置，```br```为船的右边的位置，第$i$个苹果的位置记作$arr[i]$。
那么如果$arr[i]$在$bl$和$br$之间，那么苹果就直接可以被接到，就不用动了。
如果苹果在船的右边，就往右走$arr[i]-br$，刚好师$br=arr[i]$。
苹果如果在船的左边，就是要走，只不过是该往左走了而已。
最后不管往那里走，都要更新$bl$和$br$。
### C++
```cpp
#include<iostream>

using namespace std;

int main() {
	std::ios::sync_with_stdio(false);//缩短输入输出时间
	int n, m;
	cin>>n>>m;
	int j;
	cin>>j;
	int bl = 1;
	int br = m;
	int distanse = 0;
   //采用在线处理，降低空间复杂度。
	for(int i=0; i<j; i++) {
		int temp;
		cin>>temp;
		if(bl<= temp && br >= temp ) continue; //苹果刚好掉到船上了。
		if(temp<bl) { //苹果在船的左边
			distanse += bl-temp;
			br -= (bl-temp);
			bl = temp;
		} else { //否则苹果就在船的右边，在船的中间的情况已经考虑过了
			distanse += temp-br;
			bl += (temp-br);
			br = temp; //不要忘记更新船的位置呀
		}
	}
   
	cout<<distanse;//输出
	return 0;//好习惯！
}
```
好了，这一片题解也就完结了。
~~最后，希望管理员能够通过这一片题解。~~

---

## 作者：EAlivn (赞：1)

**题目分析**

船有长度，所以船的坐标可以用 $l$ 和 $r$ 来表示。

如果苹果在 $a$ 这个坐标就有三种情况：

- 苹果在船的左边 $a<l<r$ 移动步数 $=l-a$；
- 苹果在船的右边 $l<r<a$ 移动步数 $=a-r$；
- 苹果在船上    $\,\,\,\,\,\,\,\,\,l\leq a\leq r$ 移动步数不会改变。

所以代码也就好写了。

**代码**


```C++
#include<bits/stdc++.h>
using namespace std;
long long read(){
	long long x;
	scanf("%lld",&x);
	return x;
}
signed main() {
	long long n=read(),m=read(),j=read(),ans = 0,l = 1,r=m;
	for(long long i = 1; i <= j; i++) {
		long long a=read();
		if(a<l) { //苹果在船左边 
			ans+=l-a;  //加上步数 
			l=a;       //更新左边 
			r=l+(m-1); //更新右边
		}
		else if(a>r) { //苹果在船右边 
			ans+=a-r;  //加上步数 
			r=a;       //更新右边 
			l=r-(m-1); //更新左边 
		}
//		else{          //为了好看 (逃) 
//			ans=ans;
//			r=r;
//			l=l;
//		}
	}
	printf("%lld\n",ans);
}
//十年OJ一场空，不开Long Long 见祖宗 
```
需要注意的是两种情况更新步骤相同但更新次序不同。

---

## 作者：封禁用户 (赞：1)

思路注释在代码里。
```cpp

#include <bits/stdc++.h>
using namespace std;
int main(){
    int left = 1, right, n, m, a[30], tot = 0, x;
    /*  船左边     船右边        苹果   总移动距离*/
    cin >> x >> m >> n;
    right = m; // 其实是 right = 1 + m - 1，利用船左边的坐标和长度运用等差求项数算出船右边的坐标。
    for (int i = 1; i <= n; i ++){
        cin >> a[i];
        if (a[i] > right){ // 苹果要掉到船右边啦QaQ
            tot += a[i] - right; // 该移动啦，把长度加上。
            right = a[i]; // 接住！目前右坐标为苹果要掉落的坐标。
            left = right - m + 1; // 再次算出船左边的坐标。
        }
        if (a[i] < left){ // 同上。
            tot += left - a[i];
            left = a[i];
            right = left + m - 1;
        }
    }
    cout << tot << endl; // 输出总距离。
    return 0;
}

```

~~要复$\color{green}\text{绿}$，麻烦管理小鸽鸽结界们给个pass，本蒻蒟定当感激不尽！~~

---

## 作者：simonG (赞：1)

### 前言
一道贪心+模拟的题目。
### 详解
分析：
>* 捡起所有苹果。
>* 当前的苹果掉落到屏幕底部时，下一个苹果开始掉落。   

#### 以此两点，我们足以求出答案。
>* 由第一点得知，我们要遍历所有的苹果。  
>* 由第二点得知，每个苹果下降时，都没有其他因素需要思考，即用最小距离接住其即可，此点可用反证贪心证明出答案。

### 代码

```cpp
int n,m,j,x,ans=0,loc1,loc2;
scanf("%d%d%d",&n,&m,&j);
loc1=1,loc2=m;
while(j--){
	scanf("%d",&x);
	if(x<loc1){
		ans+=(loc1-x);
		loc1=x;
		loc2=x+m-1;
	}
	else if(x>loc2){
		ans+=(x-loc2);
		loc1=x-m+1;
		loc2=x;
	}
	else ;
}
printf("%d",ans);
```

---


# [COCI 2013/2014 #2] VOLIM

## 题目背景

本游戏改编自克罗地亚电视节目《我爱克罗地亚》中的游戏 _I love my country_。

## 题目描述

有 $8$ 个人坐成一圈，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/va2c1wan.png)

他们中的某一个人会拿着一个箱子，这个箱子会在比赛开始后 $210$ 秒爆炸。

主持人会问拿箱人问题，拿箱人可以选择以下方式：

- 若跳过或回答错误，主持人会接着问下一个问题。
- 若回答正确，则拿箱人把箱子传递给他**左手边**第一个人，这个人成为新的拿箱人。

现在你知道对于每个问题，回答该问题的人所用的时间与回答情况。

给定游戏开始时拿箱人的编号与问题的数量，求出箱子爆炸时拿箱人的编号。

箱子传递时间与两个问题之间的时间**忽略不计**，数据保证箱子爆炸时箱子在某个人手上，且问题没有问完。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le K\le 8$，$1\le N,T\le 100$。

#### 来源

**本题译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 2](https://hsin.hr/coci/archive/2013_2014/contest2_tasks.pdf) _T1 VOLIM_。**

按照原题数据配置，本题满分 $50$ 分。

## 样例 #1

### 输入

```
1 
5 
20 T 
50 T 
80 T 
50 T 
30 T```

### 输出

```
5```

## 样例 #2

### 输入

```
3 
5 
100 T 
100 N 
100 T 
100 T 
100 N```

### 输出

```
4```

## 样例 #3

### 输入

```
5
6
70 T
50 P
30 N
50 T
30 P
80 T```

### 输出

```
7```

# 题解

## 作者：Miracle_ZX (赞：7)

# Part 0
希望管理员大大通过呀~谢谢
# Part 1 思路
我们注意题目，这道题有两个关键点，传到谁手上了，和现在的时间。我们可以用两个变量来存。当有答对时更新。
### 在这里，要注意：
1.原题中是一个圆桌，即传到第 $8$ 个人时，会直接传到第 $1$ 个人手中，会要特判。   
2.如果某一时刻，时间 $t$ 若大于等于 $210$ 就立即结束，并输出编号。

# Part 2 code
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int k, n;
    cin >> k >> n;
    int t;
    for (int i = 1; i <= n; i++)
    {
    	int x;//答题时间
    	char c;//是否答对
    	cin >> x >> c;
    	t += x;//时间叠加上答题时间
    	if (t >= 210)
    	{//如果时间超过，直接爆炸
    		cout << k;
    		return 0; 
		}
		else
		{
			if (c == 'T')
			{//如果答对，传到下一个人
				if (k == 8) k = 1;
				else k++;
				/*
				或利用循环队列的思路
				直接写：++k %= 7
				*/
			}
			//没答对，继续回答
		}
	}
	return 0;
}
```
# Part 3 AC picture
![AC!](https://cdn.luogu.com.cn/upload/image_hosting/do5845pu.png)


---

## 作者：CSP_Sept (赞：4)

简单模拟。

使用变量 $sum$，每次累加上回答问题所花的时间。

其实不用考虑问题的个数，用 while 循环不停输入即可。

每次判断字符 $c$，若 $c=\tt T$ 就把 $k$ 转移到下一个人 $k+1$（若 $k=8$ 则转移到 $1$）。

每次判断一下 $sum$ 是否超过 $210$，超过的话跳出循环输出 $k$ 即可。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
inline int rd();
int sum, T, n;
char c;
int k;
int main(){
    cin >> k >> n;
    while(sum < 210){
		cin >> T >> c;
		sum += T;
		if(sum >= 210) break;
		if(c == 'T') k %= 8, k++;
    }
    printf("%d", k);
    return 0;
}
inline int rd(){
	char c;
	bool flag = 0;
	while((c = getchar()) < '0' || c > '9')
	    if(c == '-') flag = 1;
	int res = c - '0';
	while((c = getchar()) >= '0' && c <= '9')
	    res = (res << 3) + (res << 1) + c - '0';
	return flag ? -res : res;
}
```

---

## 作者：_lfxxx_ (赞：2)

纯模拟题。

因为题目保证问题不会问完，所以可以把继续模拟的条件设成还没到时间就继续模拟。

**注意**：对传递次数取模时不是直接 $\bmod 8$，因为 $8\bmod8=0$，所以可以写为（传递次数 $-1$）$\bmod8+1$。
### 代码：
```cpp
#include<iostream>
using namespace std;
int main(){
	int k,n,t,s=0;
	char op=0;
	cin>>k>>n;
	while(s<210){//还有时间。
		if(op=='T')
			k++;//把上次的进行处理。
		cin>>t>>op;
		s+=t;
	}
	k=(k-1&7)+1;//位运算优化，这里相当于k=(k-1)%8+1。
	cout<<k<<'\n'; 
	return 0;
}
```

---

## 作者：_ZhouYuHan_ (赞：1)

这道题数据很小，直接模拟即可。

我们一个循环，每次输入问答情况，根据情况进行模拟。

在时间达到 $210$ 后立刻退出循环，输出当前人的编号。

最后附上官方题解（自己加了注释）：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main(){
    int K, N, igra, T;
    char Z;
    cin >> K;
    cin >> N;

    igra = 0;//赋初值为0 
    while(igra < 210)//循环条件 
    {
        cin >> T >> Z;
        igra += T;//加时间 
        if ((Z == 'T') & (igra <= 210))
            K = (K % 8) + 1;//改变编号 
    }
    cout << K;//输出 
return 0;
}
```


---

## 作者：ZBAA_MKC (赞：1)

本题根据题意模拟即可。

用一个变量 $t$ 来存储当前已用的时间，用输入的 $k$ 来储存当前谁拿着祥子，如果某一时刻 $t ≥ 210$ 则直接输出当前持箱人的编号，否则就继续，直到 $t ≥ 210$ 为止。

```cpp
#include <iostream>
using namespace std;

int main()
{
    int k, n;
    cin >> k >> n;
    int t;
    for (int i = 1; i <= n; i++)
    {
    	int x;
    	char c;
    	cin >> x >> c;
    	t += x;
    	if (t >= 210)
    	{
    		cout << k;
    		return 0; 
		}
		else
		{
			if (c == 'T')
			{
				if (k == 8)
				{
					k = 1;
				}
				else
				{
					k++;
				}
			}
		}
	}
	return 0;
}

```

---

## 作者：phigy (赞：1)

模拟题。

我们用一个 $ans$ 来记录当前过了多久时间。

用 $n$ 来记录当前到第几个人了。

对于每一个问题先让 $ans$ 加上时间。

判断一下是否大于等于 $210$。

如果超过了就输出 $n$ 结束。

如果没超过且回答正确那么到下一个人 $n$ 加上 $1$。

如果没超过但回答错误或跳过则 $n$ 不变。

重复这个过程就行了。

但是要注意总共只有 $8$ 个人。

所以最后的 $n$ 需要变成 $(n-1) \text{mod} \ 8+1$ 。

因为 $\text{mod} \ 8$ 后数会变成 $0$ 至 $7$ 。

而人的编号是 $1$ 至 $8$ 。

所以 $\text {mod}$ 后需要 $+1$ 。

因为后面 $+1$ 了所以前面 $-1$ 补回来 。

就可以了 。

```cpp
#include <algorithm>
#include <iostream>

#define N 200005
#define int long long

using namespace std;

int n,m;
int ans;
signed main()
{
    int i,j,k;
    cin>>n>>m;
    while(ans<210)
    {
        int x;
        char c;
        cin>>x>>c;
        ans+=x;
        if(ans>210)
        {
            cout<<(n-1)%8+1;
        }
        if(c=='T')
        { 
            n++;
        }
    }
}    
```


---


# [COCI 2021/2022 #2] Kaučuk

## 题目描述

Kaučuk 程序只有下列三种命令：

- $\texttt{section}$：创建新的一级标题，序号从 $1$ 开始标记。
- $\texttt{subsection}$：创建新的二级标题，序号在每个一级标题的基础上从 $1$ 开始标记。
- $\texttt{subsubsection}$：创建新的三级标题，序号在每个二级标题的基础上从 $1$ 开始标记。

给定 $n$ 组命令及标题名称，输出所有标题序号及其名称。

## 说明/提示

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$1 \le n \le 3$。
- Subtask 2（10 pts）：只包含 $\texttt{section}$ 命令。
- Subtask 3（10 pts）：只包含 $\texttt{section}$ 和 $\texttt{subsection}$ 命令。
- Subtask 4（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$n \le 100$。

**【提示与说明】**

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #2](https://hsin.hr/coci/contest2_tasks.pdf) _Task 1 Kaučuk_。**

**本题分值按 COCI 原题设置，满分 $50$。**

## 样例 #1

### 输入

```
3
section zivotinje
section boje
section voce```

### 输出

```
1 zivotinje
2 boje
3 voce```

## 样例 #2

### 输入

```
4
section zivotinje
subsection macke
subsection psi
subsubsection mops```

### 输出

```
1 zivotinje
1.1 macke
1.2 psi
1.2.1 mops```

## 样例 #3

### 输入

```
4
section zivotinje
subsection psi
section voce
subsection ananas```

### 输出

```
1 zivotinje
1.1 psi
2 voce
2.1 ananas```

# 题解

## 作者：Jerrlee✅ (赞：9)

## 题意
给定 $n$ 组命令及标题名称，输出所有标题序号及其名称。

命令：

- `section` 一级标题；

- `subsection` 二级标题；

- `subsubsection` 三级标题。

## 思路
每次统计，判断有没有开新的一列标题，若没有，序号就加上 $1$，反之，统计数据归 $0$，开个新的。

当然，为了方便，每次操作均把其后面的统计数据归 $0$。
## 代码
```cpp
#include<iostream>
using namespace std;
int main(){
    int t,a=0,b=0,c=0;
    cin>>t;
    while(t--){
        string d,s;
        cin>>d>>s;
        if(d=="section"){ //一级标题
            b=0,c=0,a++;
            cout<<a<<' '<<s<<endl;
        }
        if(d=="subsection"){ //二级标题
            c=0,b++;
            cout<<a<<'.'<<b<<' '<<s<<endl;
        }
        if(d=="subsubsection"){ //三级标题
            c++;
            cout<<a<<'.'<<b<<'.'<<c<<' '<<s<<endl;
        }
    } 
}
```
[AC记录](https://www.luogu.com.cn/record/63767712)

---

## 作者：SunSkydp (赞：4)

这道题就是大模拟。

直接模拟三层标题，为了方便，可以使用结构体。

三层标题套在一起，一定要细心，很容易出错。

如果直接三维存字符串可能会爆空间，题目中 $n$ 只有 $100$，开一个字符串数组存标题，三维存标题数组下标，空间就不会爆。

用一个结构体 $nod$ 存一个二级标题以及子三级标题，其中 $s3z$ 表示三级标题数量，数组 $s3$ 存三级标题。

用一个结构体 $node$ 存一个一级标题以及子二级标题，其中 $s2z$ 表示二级标题数量，数组 $s2$ 存二级标题。

变量 $az$ 表示一级标题数量，变量 $sz$ 表示所有标题数量。

注意结构体里存的标题都是标题数组 $s$ 的下标。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct nod{
	int s2, s3z; 
	int s3[101];
};
struct node{ 
	int s1, s2z;
	nod s2[101];
}a[101];
int n, az, sz; 
string s[101];
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		string as, bs;
		cin >> as >> bs;
		s[++sz] = bs; //先入标题数组，++sz表示先把大小加1，在存标题，下同。
		if(as == "section") a[++az].s1 = sz; 
		else if(as == "subsection") a[az].s2[++a[az].s2z].s2 = sz; //a[az].s2z是当前二级标题
		else a[az].s2[a[az].s2z].s3[++a[az].s2[a[az].s2z].s3z] = sz; //a[az].s2z是当前二级标题,a[az].s2[a[az].s2z].s3z是当前三级标题
	}
	for(int i = 1; i <= az; i++) { //逐级输出
		cout << i << " " << s[a[i].s1] << endl;
		for(int j = 1; j <= a[i].s2z; j++) {
			cout << i << "." << j << " " << s[a[i].s2[j].s2] << endl;
			for(int k = 1; k <= a[i].s2[j].s3z; k++) cout << i << "." << j << "." << k << " " << s[a[i].s2[j].s3[k]] << endl;
		}
	}
	return 0;
} 
```

---

## 作者：Galaxy_Q (赞：4)

### 题目概述：
共有三种标题，分别为 section （一级）、 subsection （二级）、 subsubsection （三级）. 操作 n 次，每次输出序号和名称.




------------
### 题目分析：
该题为一道模拟题，可以用三个计数器来存放三种标题的个数，但需要在更新高级标题之后清零比它等级低的标题数量个数.标题名称只需要在当次输出，对之后无影响，故不需存储.


------------
### 代码实现 :
```cpp
//p7964
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
string s1,s2;
int n,ans1,ans2,ans3;//->三个计数器储存标题个数
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>s1>>s2;
		if(s1=="section") {
			ans1++;
			ans2=ans3=0;//->注意清除低级标题个数
			cout<<ans1<<" "<<s2<<endl;
		}
		if(s1=="subsection") {
			ans2++;
			ans3=0;//->同上
			cout<<ans1<<"."<<ans2<<" "<<s2<<endl;//->输出时要注意“.”和空格的格式
		}
		if(s1=="subsubsection") {
			ans3++;
			cout<<ans1<<"."<<ans2<<"."<<ans3<<" "<<s2<<endl;
		}
	}
	return 0;
}



------------
后记:
提高代码能力，巩固基础. //防止csp-j四个模拟

---

## 作者：苏联小渣 (赞：2)

## 题目大意

可以创建一二三级标题，给出指令和标题名，要求输出标题序号及名称（样例解释得很清楚）

## 分析

小模拟，在线求解即可。

我们用变量 $s1,s2,s3$ 分别代表一级、二级、三级标题的数量。

找到一级标题，意味着**一级标题数量加 1**（$s1++$） 以及**二级标题数量归零**（$s2=0$，因为每一个一级标题下都会有独立的二级标题）

同理，找到二级标题，意味着二级标题数量加 1 以及三级标题数量归零。（$s2++,s3=0$）

这样，我们就可以通过三个变量输出每一个标题的序号。

### Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, s1, s2, s3;
string title, name;
int main(){
	scanf ("%d", &n);
	while (n --){
		cin >> title >> name;
		if (title == "section"){
			cout << ++s1 << " " << name << endl;
			s2 = 0;
		}
		if (title == "subsection"){
			cout << s1 << "." << ++s2 << " " << name << endl;
			s3 = 0;
		}
		if (title == "subsubsection"){
			cout << s1 << "." << s2 << "." << ++s3 << " " << name << endl;
		}
	}
	return 0;
}
```

后记：

其实这题可以推广到 $x$ 级标题，这样可能就成了一道 CSP-J T1 的模拟题。

如果推广到 $x$ 级标题，代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, s[10];
string title, name;
int main(){
	scanf ("%d", &n);
	while (n --){
		cin >> title >> name;
		int x = (title.size() - 7) / 3 + 1;//x 级标题，减去 section 7个字母再除以3 + 1 
		for (int i=1; i<x; i++) printf ("%d.", s[i]);
		printf ("%d ", ++s[x]);//输出目前标题序号 
		cout << name << endl;
		s[x+1] = 0;//下一级标题归零 
	}
	return 0;
}
```
运用这段代码同样也可以过掉这道题

---

## 作者：user470883 (赞：1)

## 思路：
理解还是很好理解的，这个就像文章里 `x.x.x` 一样。

比较水了，根据三个指令进行判断。

我们还是分类讨论把。

1. section

这一种只需要新创建一个大标题即可。

2. subsection

这一种操作需要遵循它的大标题，并且中间有 `.` ， 这一种在遇到新的大标题时还是要遵循新的大标题，再次从 $1$ 开始。

3. subsubsection

这一种操作和需要遵循它的第二大标题，并且中间有两个 `.` ,同样，这一种在遇到新的第二大标题时还是要遵循新的第二大标题，再次从 $1$ 开始。

然后程序就是几个 `if` + 清零 + 输出了。

还是要提醒不要忘记在中途也要赋值为 $0$，我曾经就是在这跌了好几次。

代码里有注释，还是不懂的看看注释。
## AC CODE:
```
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin >> n;
	int ans=0,ans1=0,ans2=0;
	for(int i = 0 ; i < n; i++)
	{
		
		string op,s;
		cin >> op >> s;
		if(op=="section") //section判断
		{
			ans1=0,ans2=0;//初始化第二大+第三大
			ans++;
			cout << ans << " " << s << endl;//输出第一大
		}
		if(op=="subsection")//subsection判断
		{
			ans2=0;//初始化第三大
			ans1++;
			cout << ans << "." << ans1 << " " << s << endl;//输出第二大
		}
		if(op=="subsubsection")//subsubsection判断，最后一个，无需初始化
		{
			ans2++;
			cout << ans << "." << ans1 << "." << ans2 << " " << s << endl;//输出第三大
		}
	} 
	return 0;
}//AC!
```

[AC记录](https://www.luogu.com.cn/record/63664188)

有错还请大佬指出。

---

## 作者：Ginger_he (赞：1)

# 题解
用三个变量 $x,y,z$ 分别统计三个级别的标题的序号，然后按照题意模拟即可。  
注意：每次新建一个标题，比它低级的标题的序号就要重置为 $0$。
## 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,z;
string s,t; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>s>>t;
		if(s=="section")
		{
			printf("%d",++x);
			y=0;
		}
		else if(s=="subsection")
		{
			printf("%d.%d",x,++y);
			z=0;
		}
		else
			printf("%d.%d.%d",x,y,++z);
		printf(" %s\n",t.c_str());
	}
	return 0;
}

```

---

## 作者：ssss41 (赞：1)

代码能力崩了，开练模拟。


------------

### 题意

很明了了吧，似乎并没有什么坑点，哪怕没有懂看样例应该也可理解。

### 做法

首先注意：

$n \leq 100$ 

~~诶怎么这么小 ♂ 啊，开二维数组正好~~。

1. `section` 时，直接开变量自增即可。

2. `subsection` 时，可以开一位数组，记录每个一级标题中二级标题的数量。

3. `subsubsection` 时，同理，可开一个二维数组。第一维记录是哪个一级标题，第二维记录是哪个二级标题。

这样做法就很显然了。


------------

### AC Code

```cpp

#include <bits/stdc++.h>
using namespace std;

const int N = 1e4;

int n, ans1, ans2[N], ans3[N][N];
string s, a;

int main(){
	scanf ("%d", &n);
	getline (cin, s);//读换行符
	
	while (n --){
		cin >> s >> a;
		
		if (s == "section"){
			ans1 ++;
			cout << ans1 << " " << a << endl;
		}
		else if (s == "subsection"){
			ans2[ans1] ++;
			cout << ans1 << "." << ans2[ans1] << " " << a << endl;
		}
		else{
			ans3[ans1][ans2[ans1]] ++;
			cout << ans1 << "." << ans2[ans1] << "." << ans3[ans1][ans2[ans1]] << " " << a << endl;
		}
	}
	
	return 0;
}

```

大家一定要注意练码力啊，否则容易像我在 CSP 上天崩 qwq。

---

## 作者：ImposterAnYu (赞：1)

这道题难点并不大，只需要读入一行数据后根据标题级别将数据分别处理就好了。在这之前，我们先定义三个变量 $yj$、$ej$、$sj$，分别表示当前一级、二级、三级标题的序号，初始化为 $0$。

读入的话，我选择了使用 string。因为 string 自带比较功能，不像 char 那样只能一个一个字符地去比较。

接下来将数据分成三类情况进行处理：

1. 一级标题：将 $yj$ 加上一之后输出，并且将 $ej$、$sj$ 初始化（因为我们另起了一个新的一级标题，以前的二级、三级标题的序号要重新计算）。

```c++
		if(a[i] == "section"){
			ej = 0;
			sj = 0;
			cout<< ++yj << " " << b[i] << endl;
		}
```
2. 二级标题：将 $ej$ 加上一之后和 $yj$ 一起输出，并且将 $sj$ 初始化（因为我们另起了一个新的二级标题，以前的三级标题的序号要重新计算）。

```c++
		else if(a[i] == "subsection"){
			sj = 0;
			cout<< yj << "." << ++ej << " " << b[i] << endl;
		}
```

3. 三级标题：将 $sj$ 加上一之后和 $yj$、$ej$ 一起输出。

```c++
		else{
			cout<< yj << "." << ej << "." << ++sj << " " << b[i] << endl;
		}
```
分类处理……就这么写完啦！

# AC code
```c++
#include<bits/stdc++.h>
using namespace std;
int n,i,yj,ej,sj;
string a[105],b[105];
int main(){
	cin >> n;
	for(i = 1; i <= n; i++){
		cin >> a[i] >> b[i];//读入命令名称和标题名称 
		if(a[i] == "section"){//一级标题
			ej = 0;
			sj = 0;
			cout<< ++yj << " " << b[i] << endl;
		}else if(a[i] == "subsection"){//二级标题
			sj = 0;
			cout<< yj << "." << ++ej << " " << b[i] << endl;
		}else{//三级标题
			cout<< yj << "." << ej << "." << ++sj << " " << b[i] << endl;
		}
	}
	return 0;
}
```

---

## 作者：Buried_Dream (赞：0)

## 题意：

给定 $n$ 组标题和名称，按顺序输出所有标题序号及其名称。

## 思路：

我们对于每一个同级标题，判断是不是与当前的标题是同一种标题，

如果是同一种标题，那么统计当前标题的计数器加 $1$。

如果不是同一种标题，那么就开个新的接着记录。

我们对于每个一级标题下都开一个二级标题记录器，对于二级标题再开一个三级标题记录器即可。

## AC code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define orz cout << "szt lps fjh AK IOI";
using namespace std;
const int maxn = 3e6;
const int MAXN = 3e3;

inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while (!isdigit(ch)) {if(ch == '-') {w = -1;}ch = getchar();}
	while (isdigit(ch)) {s = (s << 1) + (s << 3) + (ch ^ 48);ch = getchar();}
	return s * w;
}

inline void print(int x) {
	if (x < 0 ) putchar('-'), x = -x;
	if (x > 9 ) print(x / 10);
	putchar(x % 10 + '0');
}

//---------------------------------------------------------------------
int Abs(const int &a) { return (a ^ (a >> 31) - (a >> 31)); }
int Max(const int &a, const int &b) {return a > b ? a : b; }
int Min(const int &a, const int &b) {return a < b ? a : b; }
//---------------------------------------------------------------------
int szt[maxn], lps = 0, fjh = 0, wxf = 0;
int js_1, js_2, js_3;

//---------------------------------------------------------------------
signed main() {
	int T = read();
	while(T--) {
		string s, ss;
		cin >> s >> ss;
		if(s == "section") {
			js_1++;//当前标题数量加1 
			js_2 = 0, js_3 = 0;
			cout << js_1 << " " << ss << endl; 
		}
		else if(s == "subsection") {
			js_3 = 0;
			js_2++;
			printf("%lld.%lld ", js_1, js_2);
			cout << ss << "\n";
		} 
		else if(s == "subsubsection") {
			js_3++;
			printf("%lld.%lld.%lld ", js_1, js_2, js_3);
			cout << ss << "\n";
		}
	}
	return 0;
}
```


---

## 作者：哈士奇憨憨 (赞：0)

## 题意
创建新的一级标题、二级标题和三级标题，并输出。
## 思路
用 `if` 语句来判断是几级标题，然后分成三类情况进行处理。

建议用 `string` 来输入，可较好判断创建的是几级标题。
### 注意
增加一个一级标题，二级标题、三级标题清零。 \
增加一个二级标题，三级标题清零。
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,z;//x,y,z分别为一级标题、二级标题、三级标题。
string a,b;
int main(){
    cin >> n;
    while(n--){
        cin >> a >> b;
        if(a == "section"){//如果为一级标题
            x++;
            y = 0;//二级标题、三级标题清零，因为创建了一个新的一级标题，序号要清零。
            z = 0;
            cout << x << " " << b << endl;
        }else if(a == "subsection"){//如果为二级标题
            y++;
            z = 0;//三级标题清零，因为创建了一个新的二级标题，序号要清零。
            cout << x << '.' << y << " " << b << endl;
        }else{//如果为三级标题
            z++;
            cout << x << '.' << y << '.' << z << " " << b << endl;
        }
    }
    return 0;
}
```

---

## 作者：a1ioua (赞：0)

稍微理解一下这道题目，就可以得出每一个标题的序数都可以分别用一个变量记录。然后就开始展开分支。

1. 一级标题：一级标题的变量加 $1$，然后输出，**最后把二级、三级标题变量清空**。
2. 二级标题：二级标题的变量加 $1$，然后输出，**最后把三级标题变量清空**。
3. 三级标题：三级标题的变量加 $1$，然后输出。

按照这个思路，便可以轻松地解决问题。

注意一些小细节，如输入、输出格式等。

------------
```cpp
#include <bits/stdc++.h>
using namespace std;
int m, s, ss;
int main() {
    int n;
    cin >> n;
    while (n--) { // 这样会循环 n 次，就可以“偷个懒”。
        string str, str_;
        cin >> str >> str_;
        if (str == "section") {
            cout << ++m << ' ' << str_ << endl;
            s = ss = 0;
        } else if (str == "subsection") {
            cout << m << '.' << ++s << ' ' << str_ << endl;
            ss = 0;
        } else {
            cout << m << '.' << s << '.' << ++ss << ' ' << str_ << endl;
        }
    }
    return 0;
}
```

---

## 作者：GuoWil (赞：0)

这是一道很简单的模拟。题目每次给你两个字符串 $a$ 和 $b$ ，其中 $a$ 是创建一、二、三级标题的命令，输出标题序号和名称（字符串 $b$ ）。

思路：每创建一级标题，相应的计数器就加 $1$。题目中说了**序号在每个上级标题的基础上**从 $1$ 开始标记，所以当创建完一个标题后，它下一级的标题对应的计数器要归零。

~~小~~提示：

这个题用 ```printf``` 输出较方便。题目中的字符串最好使用字符数组来存，输出时格式控制符为 ```%s```。另外数字和点之间不要加空格。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n,ct1=0,ct2=0,ct3=0;
    string a;
    char b[25];
    cin >> n;
    while(n--){
         cin >> a;
         cin >> b;
         if(a=="section") printf("%d %s\n",++ct1,b),ct2=0;//不要忘了归零。
         else if(a=="subsection") printf("%d.%d %s\n",ct1,++ct2,b),ct3=0;
         else printf("%d.%d.%d %s\n",ct1,ct2,++ct3,b);
    } 
}
```


---

## 作者：_Fatalis_ (赞：0)

~~好久没有写题解了，社贡掉的太低了，就来写入门题解了~~

---
### Solution

观察题面，大模拟。

模拟思路，是维护三个变量 $f,s,t$，分别代表**一级标题序号**，**二级标题序号**以及**三级标题序号**。

$-1$ 代表到上一个父标题没有同级标题。

设当前的状态为标题的级别，

比如

```
1 asdf
2 ddd
3 kk
3.1 kkk
3.1.1 jfkjd
```

这样，在前三个时三个状态都为 $1$，第四个标题时状态为 $2$，第五个标题时状态为 $3$。

在插入新标题时，

若当前状态对应的变量为 $-1$，那么就要插入新的标题。这时，让这个状态变量设置为 $1$，表示当前级标题序号为 $1$。

若当前状态对应的变量不为 $-1$，那么说明前面有相同级别的标题，需要在后面接一个新序号的标题，那么这个变量就自增 $1$。

操作完成后，直接输出三个序号即可。

举个例子：

```
5
section zivotinje  1
subsection macke   1.1
subsection psi     1.2
subsubsection mops 1.2.1
section asdfasdf   2
```

执行第四步时，需要在原来基础上增加一层标题，那么就要令 $t$ 等于 $1$。

执行第五步时，层数掉回了一级，那么在他之上就没有二级和三级标题了，就让 $s$ 和 $t$ 都设为 $-1$，$f$ 自增 $1$。

Code
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    string p,ss;
    int n,f=-1,s=-1,t=-1;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>p>>ss;
        if(p=="section")
        {
            if(f==-1) f=1; //前面没有同级标题
            else f++;      //有同级标题
            s=-1,t=-1;     //后面同理
            printf("%d %s\n",f,ss.c_str());
        }
        else if(p=="subsection")
        {
            if(s==-1) s=1;
            else s++;
            t=-1;
            printf("%d.%d %s\n",f,s,ss.c_str());
        }
        else if(p=="subsubsection")
        {
            if(t==-1) t=1;
            else t++;
            printf("%d.%d.%d %s\n",f,s,t,ss.c_str());
        }
    }
    return 0;
}
```

---

## 作者：LinTianHao_ (赞：0)

## 题解
### 前言~~(一些无用的话)~~

本题可以通过基本的循环和判断语句解决。
### 简要分析

Kaučuk 程序只有三种命令；

**section**

直接输出目前标号，再输出一级标题即可。（记得空格和换行）

**subsection**

需要输出当前一级标题和二级标题的标号，再输出标题。（注意序号间以 `.` 分隔）

**subsubsection**

需要输出当前一、二、三级标题标号，再输出标题。

当输出某标题后，标记该级标题的记号+1。
### AC代码（含注解）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s=1,subs=1,subsubs=1;//标记各级标题的当前序号 
string level,title;//level表示标题等级，title表示标题 
int main(){
    cin>>n;
    while(n--){
        cin>>level>>title;
        if(level=="section"){
            cout<<s<<' '<<title<<endl;
            s++;
            subs=1;
            subsubs=1;//重置2、3级标题序号 
        }
        if(level=="subsection"){
            cout<<s-1<<'.'<<subs<<' '<<title<<endl;
            subs++;
            subsubs=1;//重置3级标题序号
        }
        if(level=="subsubsection"){
            cout<<s-1<<'.'<<subs-1<<'.'<<subsubs<<' '<<title<<endl;//由于之前s、subs已加过1，所以应输出之前的标题序号 
            subsubs++;
        }
    }
    return 0; 
}
```

### 结语（无）

---

## 作者：Zirnc (赞：0)

分别用变量记录一下当前是第几个一级标题、第几个二级标题、第几个三级标题，然后每一次增加的时候，就要把比自己等级更小的标题的次数清零。

```cpp
#include <iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	int scnt = 0, subcnt = 0, ssubcnt = 0;
	for (int i = 0; i < n; i++) {
		string op, name;
		cin >> op >> name;
		if (op == "section") {
        	// 一级标题，二级和三级就要清零
			subcnt = 0;
			ssubcnt = 0;
			cout << ++scnt << " " << name << endl;
		} else if (op == "subsection") {
        	// 二级标题，三级就要清零
			ssubcnt = 0;
			cout << scnt << "." << ++subcnt << " " << name << endl;
		} else if (op == "subsubsection") {
			cout << scnt << "." << subcnt << "." << ++ssubcnt << " " << name << endl;
		}
	}
	return 0;
} 
```

---

## 作者：ZZQF5677 (赞：0)

### 解题思路
这题属于模拟，但模拟的过程又有点类似于进制。先建立变量 $h1,h2,h3$ 分别纪录这几个等级标题的出现遍号，$n$ 次输入时，当遇到了一级标题 $\texttt{section}$ 就要向 $h1$ 进一，同时将 $h2,h3$ 归 $0$；同时，当遇到了二级标题 $\texttt{subsection}$ 就要向 $h2$ 进一，同时将 $h3$ 归 $0$；同理，不然就是遇到三级标题 $\texttt{subsubsection}$，这时向 $h3$ 进一就行，然后不需要归 $0$ 任何数。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, h1, h2, h3;  //一级标题、二级标题、三级标题。
string h, name;     //标题类型、名称。
int main() {
  cin >> n;
  while (n--) {
    cin >> h >> name;
    if (h == "section") {
      h1++;
      h2 = 0, h3 = 0;  //因为又变成一级标题了，所以清空二、三级标题。
      cout << h1 << " " << name << endl;
    } else if (h == "subsection") {
      h2++;   
      h3 = 0;  //因为又变成二级标题了，所以清空三级标题。
      cout << h1 << "." << h2 << " " << name << endl;
    } else {
      h3++;
      cout << h1 << "." << h2 << "." << h3 << " " << name << endl;
    }
  }
  return 0;
}
```

---

## 作者：basachenboming (赞：0)

**思路**

一道简单模拟

用三个计数器模拟目录

注意当读到一级时二三级要清零

读到二级时三级要清零

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int tot=0,tot1=0,tot2=0;
	int n;
	cin>>n;
	string a,b;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		if(a=="section")
		{
		tot++;
		tot1=0;
		tot2=0;
		cout<<tot<<" "<<b<<endl;	
		} 
		if(a=="subsection")
		{
			tot1++;
			tot2=0;
			cout<<tot<<"."<<tot1<<" "<<b<<endl;
		}
		if(a=="subsubsection")
		{
			tot2++;
			cout<<tot<<"."<<tot1<<"."<<tot2<<" "<<b<<endl;
		}
	}
	return 0;
 } 
```


---


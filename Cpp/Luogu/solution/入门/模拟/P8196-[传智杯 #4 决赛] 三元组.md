# [传智杯 #4 决赛] 三元组

## 题目描述

给定一个长度为 $n$ 的数列 $a$，对于一个有序整数三元组 $(i, j, k)$，若其满足 $1 \leq i \leq j \leq k \leq n$ 并且 $a_i +a_j  = a_k$，则我们称这个三元组是「传智的」。

现在请你计算，有多少有序整数三元组是传智的。

## 说明/提示

### 样例 1 解释

对于第一组数据，因为 $a_1 + a_1 = a_2$，$a_1 + a_2 = a_3$，故共 $(1, 1, 2)$ 和 $(1, 2, 3)$ 两个三元组。  
对于第二组数据六个三元组分别是：
- $(1, 1, 2)$
- $(1, 2, 3)$
- $(1, 3, 4)$
- $(1, 4, 5)$
- $(2, 2, 4)$
- $(2, 3, 5)$

### 数据规模与约定

对于全部测试点，保证 $1 \leq T \leq 100$，$1 \leq n , a_i \leq 100$，且各个测试点的 $n$ 之和不超过 $100$，即 $\sum n \leq 100$。

## 样例 #1

### 输入

```
2
3
1 2 3
5
1 2 3 4 5
```

### 输出

```
2
6```

# 题解

## 作者：可爱的小于 (赞：24)

[原题传送门](https://www.luogu.com.cn/problem/P8196) [采用博客使用更佳](https://keaidexiaoyu.blog.luogu.org/solution-p8196)

**题目大意：** 给定数列 $a$ ，求有序三元组 $(i,j,k)$ 满足 $a_i + a_j =a_k$ 的数量。

**解题思路：** 

**$1.$** 该题有多组数据，可进行一次 `while` 循环。

**$2.$** 输入数列。

**$3.$** 三重暴力 `for` 循环，寻找出可行的三元组，进行累加，得出答案。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105];
int main()
{
	cin >> n;
    while(n--){
        int m,sum=0;
        cin >> m;
        for(int i=1;i<=m;i++)cin>>a[i];
        for(int i=1;i<=m;i++)
            for(int j=i;j<=m;j++)
                for(int k=j;k<=m;k++)
                    if(a[i]+a[j]==a[k])
                        sum++;
        cout<<sum<<endl;
    }
    return 0;
}
```

---

## 作者：一扶苏一 (赞：12)

## B. 三元组

**题意**：给定长度为 $n$ 的数列 $a$，求满足 $1 \leq i \leq j \leq k \leq n$ 且 $a_i + a_j = a_k$ 的三元组 $(i,j,k)$ 个数。

$1 \leq n, a_i \leq 100$。

**关键词**：模拟，循环，分支结构，枚举。

**参考难度**：红。

**解析**：直接暴力枚举 $i,j,k$ 三个量即可。注意 $j$ 的枚举起始值应该是 $i$，$k$ 的枚举起始值应该是 $j$。

(C++)

```cpp
#include <array>
#include <iostream>

const int maxn = 105;

std::array<int, maxn> a;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  int T;
  for (std::cin >> T; T; --T) {
    int n, ans = 0; std::cin >> n;
    for (int i = 1; i <= n; ++i) std::cin >> a[i];
    for (int i = 1; i <= n; ++i) {
      for (int j = i; j <= n; ++j) {
        for (int k = j; k <= n; ++k) if ((a[i] + a[j]) == a[k]) {
          ++ans;
        }
      }
    }
    std::cout << ans << '\n';
  }
  return 0;
}
```

(Java)

```java
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    for (int T = cin.nextInt(); T != 0; --T) {
      int n = cin.nextInt();
      int[] a = new int[n];
      for (int i = 0; i < n; ++i) {
        a[i] = cin.nextInt();
      }
      int ans = 0;
      for (int i = 0; i < n; ++i) {
        for (int j = i; j < n; ++j) {
          for (int k = j; k < n; ++k) if (a[i] + a[j] == a[k]) {
            ++ans;
          }
        }
      }
      System.out.println(ans);
    }
  }
}
```

(Python)

```python
T = int(input())
for t in range(T):
  n = int(input())
  a = list(map(int, input().split()))
  ans = 0
  for i in range(n):
    for j in range(i, n):
      for k in range(j, n):
        if (a[i] + a[j] == a[k]):
          ans += 1
  print(ans)
```


---

## 作者：REAL_曼巴 (赞：4)

三重循环，用枚举 $i,j,k$ 的方法枚举每一个数，在循环内判断符合要求的三元组，最后进行加和判断，如果符合，答案加一。注意答案要清零哦。
```
#include<iostream>
using namespace std;
int a[10001];
int main(){
	int t,n,ans=0;
	cin>>t;
	while(t--){
		ans=0;
		cin>>n;
		for(int i=1;i<=n;++i)cin>>a[i];
		for(int i=1;i<=n;++i)for(int j=i;j<=n;++j)for(int k=j;k<=n;++k)if(a[i]+a[j]==a[k]) ans++;//枚举i,j,k,最后进行加和判断
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：Elgo87 (赞：3)

题意：给一个序列 $a$，计算有多少个三元组 $(i,j,k)$ 满足 $a_i+a_j=a_k$（$1\le i\le j \le k \le n$）。

看到数据范围 $n\le 100$，显然暴力是可行的，枚举 $(i,j,k)$ 然后一一判断是否满足 $a_i+a_j=a_k$。

然后很容易写出代码：

```cpp
# include <bits/stdc++.h>
using namespace std;

const int MAXN = 100 + 5;
int a[MAXN];
int main() {
	int T;
	scanf("%d", &T);
	while(T --) {
		int n, cnt = 0;
		scanf("%d", &n);
        
		for(int i = 1; i <= n; i ++)  scanf("%d", &a[i]);
            
		for(int i = 1; i <= n; i ++)
		for(int j = i; j <= n; j ++)
		for(int k = j ; k <= n; k ++)
		                if(a[i] + a[j] == a[k]) cnt++;
                        
		printf("%d\n", cnt);     //别忘了换行
	}
	return 0;
}
```


不出所料，$\text{AC}$ 了。

~~刚看到这题的时候我还以为是什么 nb 的算法呢~~

---

## 作者：3a51_ (赞：2)

建议评级：红

还是按照题目要求模拟。注意是 $i \le j \le k$ 不是 $i<j<k$，然后记得开`long long`。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int T,ans=0;
	cin>>T;
	while(T--){
		int n,a[105];
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++){
			for(int j=i;j<=n;j++){
				for(int k=j;k<=n;k++){
					if(a[i]+a[j]==a[k]) ans++;
				}
			}
		}
		cout<<ans<<endl;
		ans=0;
	}
	return 0;
}
```

---

## 作者：int32 (赞：2)

数据范围不大，考虑循环暴力枚举 $i,j,k$ 判断计数即可。

```cpp
//temp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int T;
int n;
int a[N];
signed main(){
    cin>>T;
    while(T--){
        cin>>n;
        int cnt=0;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        for(int i=1;i<=n;i++)
            for(int j=i;j<=n;j++)
                for(int o=j;o<=n;o++)
                    if(a[i]+a[j]==a[o])
                        ++cnt;
        cout<<cnt<<'\n';
    }
    return 0;
}
```

---

## 作者：哈士奇憨憨 (赞：1)

## 题目大意
求一个长度为 $n$ 数组中满足 $1 \leq i \leq j \leq k \leq n$ 且 $a_i +a_j = a_k$ 的个数。

多组数据。
## 思路
由于 $n \leq 100$，我们考虑暴力枚举。
第一层枚举 $i$，第二层枚举 $j$，第三层枚举 $k$。在里面判断 $a_i +a_j = a_k$，若是，满足的个数加一。
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, a[105], ans;
int main(){
	cin >> t;
	while(t--) {
		ans = 0;//记得初始值为0
		cin >> n;
		for(int i = 1; i <= n; i++){
			cin >> a[i];
		} 
		for(int i = 1; i <= n; i++){
			for(int j = i; j <= n; j++){
				for(int k = j; k <= n; k++){
					if(a[i] + a[j] == a[k]){
						ans++;
					}
				}
			}
		}
		cout << ans << endl;
	} 
	return 0;
} 
```

---

## 作者：Jorisy (赞：1)

这一题直接暴力枚举 $i,j,k$（当然要注意 $i \le j \le k \le n$），最后判断 $a_i+a_j$ 是否等于 $a_k$ 即可。

数据范围很小，暴力的最坏次数是 $O(Tn^3)=100 \times 100^3=(10^2)^4=10^8$。但常数小，因此不成问题。

最后，既然是多测，那就要注意清零了。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int t,a[105];
	cin>>t;
	while(t--)
	{
		int n,ans=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=i;j<=n;j++)
			{
				for(int k=j;k<=n;k++)
				{//三层暴力
					if(a[i]+a[j]==a[k]) ans++;//计数
				}
			}
		}
		cout<<ans<<endl;
	}
 	return 0;
}
```

---

## 作者：pengzy___ (赞：0)

### 思路：

可以看到本题数据范围较小，所以直接三层循环就行了。

因为满足条件的话必须满足 $i\le j\le k$ ，所以每层循环都要大于等于前面一层循环。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a[105],ans;
int main()
{
	cin>>T;
	while(T--) {
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)
		    for(int j=i;j<=n;j++)
		        for(int k=j;k<=n;k++)
		            if(a[i]+a[j]==a[k])
		               ans++;
		cout<<ans<<endl;
		ans=0;
	}
	return 0;
}
```


---

## 作者：lucas_jy (赞：0)

[或许更好の阅读体验](https://www.luogu.com.cn/blog/AnOutsiderOfLuogu/solution-p8196)

[题目の传送门](https://www.luogu.com.cn/problem/P8196)

### 题目解析
与[第一题](https://www.luogu.com.cn/problem/P8195)一样，都是签到题。

这道题非常水，就是扫一遍暴力。

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a[105],ans;
int main(){
    cin>>T;
    while(T-->0)
    {
        cin>>n;
        ans=0;
        for(int i=1;i<=n;++i)
            cin>>a[i];
        for(int i=1;i<=n;++i)
            for(int j=i;j<=n;++j)
                for(int k=j;k<=n;++k) //暴力三层循环
                    if(a[i]+a[j]==a[k])
                        ++ans;
        cout<<ans<<endl;
    }
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/71238824)

这是作者的第 ` 3 ` 篇题解，希望大家多提意见，谢谢！

---


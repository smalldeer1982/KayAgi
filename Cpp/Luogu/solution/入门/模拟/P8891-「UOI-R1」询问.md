# 「UOI-R1」询问

## 题目背景

ZSS 有一个序列，但他实在不太聪明，以至于一个操作问题都要来问你了。

## 题目描述

给定 $n$ 个数的整数序列 $a_1, a_2, \cdots, a_n$，有 $m$ 次操作，每次操作给定 $x, y$，你需要找到所有 $i$，满足 $i \oplus x = 0$，然后 $a_i \gets a_i - y$。如果没有任何一个这样的 $i$，则序列什么也不会更改。这里的 $\oplus$ 为按位异或操作。

操作结束后，你需要输出这个序列。

## 说明/提示

对于 $20\%$ 的数据，保证 $1 \leq n, m \leq 10^3$。

对于另外 $20\%$ 的数据，保证 $x=0$。

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^6$，$-10^8 \leq y, a_i \leq 10^{8}$，$0 \leq x \leq n$。

## 样例 #1

### 输入

```
6 1
1 1 4 5 1 1
0 7```

### 输出

```
1 1 4 5 1 1```

## 样例 #2

### 输入

```
3 1
0 3 9
1 2```

### 输出

```
-2 3 9```

## 样例 #3

### 输入

```
见文件附件的 queries3.in```

### 输出

```
见文件附件的 queries3.ans```

## 样例 #4

### 输入

```
见文件附件的 queries4.in```

### 输出

```
见文件附件的 queries4.ans```

# 题解

## 作者：happybob (赞：15)

本题解只讲述满分做法。

根据异或的性质，显然有 $(x \oplus x) = 0$。而对于两数 $x, y$ 且 $x \neq y$，$(x \oplus y) \neq 0$。

对于每次操作 $(x,y)$，只有 $x \oplus x = 0$，所以 $a_x \gets a_x - y$ 即可。

对于 $x=0$，什么都不做即可。

复杂度 $O(n+m)$。记得开 `long long` ！

十分签到。

---

## 作者：Infinite_Eternity (赞：7)

# Description

[「UOI-R1」询问](https://www.luogu.com.cn/problem/P8891) 

给定 $n$ 个数的整数序列 $a_1, a_2, \cdots, a_n$，有 $m$ 次操作，每次操作给定 $x, y$。对于所有满足 $i \oplus x = 0$ 的 $i$，使得 $a_i \gets a_i - y$。

数据范围：$1 \leq n, m \leq 10^6$，$-10^8 \leq y, a_i \leq 10^{8}$，$0 \leq x \leq n$。

# Analysis

$\oplus$ 表示按位异或运算。其运算法则为：

> 将两个数用二进制进行表示后，对于每一位进行运算：若不同则为 $1$，相同则为 $0$。
即：
$$
\begin{aligned}
0 \oplus 0 = 0\\
0 \oplus 1 = 1\\
1 \oplus 0 = 1\\
1 \oplus 1 = 0
\end{aligned}
$$

该运算被也广泛运用来统计一个数中 $1$ 的位数。

------------


对于本题，我们便可从 $i \oplus x = 0$ 这个条件入手。根据 $\oplus$ 的运算法则可得：当且仅当 $i = x$ 时，这个条件才能被满足。

因此，我们每次操作只需对 $a_x$ 进行操作即可。此外，因为本题的数据范围会爆 `int`，谨记要开 `long long`。

时间复杂度 $\mathcal{O}(m)$。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,x,y,a[1000001];
inline ll read()
{
    register char c;
    register int ans=0,z=1;
    while(!isdigit(c=getchar()))z-=2*(c=='-');
    do
    {
        ans=((ans<<3)+(ans<<1)+c-'0');
    }
    while(isdigit(c=getchar()));
    return ans*z;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
    	a[i]=read();
    while(m--)
    {
        x=read(),y=read();
        a[x]-=y;
    }
    for(int i=1;i<=n;++i) 
    	printf("%lld ",a[i]);
	return 0;
}
```

### 彩蛋
![](https://cdn.luogu.com.cn/upload/image_hosting/aaoj15j2.png)

---

## 作者：HappyCode (赞：5)

### 思路

根据异或的性质，可以得出有且仅有 $x\oplus x=0$。不同的两个数字异或结果一定不为 $0$。

因此对于每次操作，我们仅需将 $a_x \gets a_x-y$ 即可。当 $x=0$，我们什么都不做。

时间复杂度 $O(n+m)$，在 $1 \le n,m \le 10^6$ 情况下不会超时。

注意由于 $-10^8 \le y \le 10^8$，经过操作后 $a$ 数组可能会超过 `int` 范围，需要使用 `long long`。

### 代码

```cpp
#include<iostream>
using namespace std;
int n,m;
long long a[1000005];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    while(m--){
        int x,y;
        cin>>x>>y;
        if(x!=0){
            a[x]=a[x]-y;
        }
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

---

## 作者：Vct14 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8891)

前置知识：[异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)。

### 思路

因为 $a\oplus b = (\lnot a \land  b) \lor (a \land \lnot b)$，即如果 $a,b$ 两个值相同，异或结果为 $0$，否则结果为 $1$，所以，在计算 $i\oplus x$ 时，仅当 $i=x$ 时，才有 $i \oplus x=0$，否则 $i \oplus x=1$。

那么对于每次操作，$a_x \gets a_x - y$ 即可。

特别地，对于 $x=0$ ，由于序列下标从 $1$ 开始，所以可以直接跳过。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

long long a[1000002];

int main(){
	long long n,m;
	cin>>n>>m;
	for(long long i=1; i<=n; i++) cin>>a[i];
	while(m--){
		long long x,y;
		cin>>x>>y;
		if(x==0) continue;
		a[x]-=y;
	}
	for(long long i=1; i<=n; i++) cout<<a[i]<<" ";
	return 0;
}
```

### 提示

记得开 ```long long``` ！

---


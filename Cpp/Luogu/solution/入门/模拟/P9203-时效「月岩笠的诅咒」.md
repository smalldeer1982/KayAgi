# 时效「月岩笠的诅咒」

## 题目背景

蓬莱之药，被诅咒的不死之药。

奉命将蓬莱之药投入富士山中销毁的月岩笠，最终打算把蓬莱之药改投入八岳销毁。在下山途中妹红将其踹下山，抢到了蓬莱之药。

那已经是千年前的事情了。

## 题目描述

时间节点上发生过的两件事情的时间可被看作两实数 $a,b$。我们称两个事件满足「周年」关系，当且仅当可以通过执行以下两种操作（可以 $0$ 次）使其相等：

- 将 $a$ 加上 $1$，即 $a\gets a+1$；
- 将 $b$ 加上 $1$，即 $b\gets b+1$。

现在给定实数 $a,b$，询问它们是否满足「周年」。

## 说明/提示

对于全部数据，保证 $0<a,b\le 10^9$。

## 样例 #1

### 输入

```
100.000000000000 999999.000000000000
```

### 输出

```
YES```

## 样例 #2

### 输入

```
114.123456789000 514.123456789000
```

### 输出

```
YES```

## 样例 #3

### 输入

```
0.333333333333 0.333333333334
```

### 输出

```
NO```

# 题解

## 作者：Nuyoah_awa (赞：18)

### 题目大意
给定两个非整数，判断这两个数相减是否为整数。

### 题目分析

#### 思路一：
如题，两数相减，判断是否为整数。

主要代码：

```cpp
int main(){
	a -= b;
	if(a - (int)(a) == 0.000000000000)
		printf("YES");
	else
		printf("NO");
	return 0;
}
```

#### 思路二：

分别删去两数的整数部分，判断剩余是否相等。

主要代码：

```cpp
int main(){
	a -= (int)(a);
	b -= (int)(b);
	if(a == b)
		printf("YES");
	else
		printf("NO");
	return 0;
}
```

### 思路三：

鉴于前两种思路容易挂精度，我们观察思路二，实际上就是判断两数的小数部分是否相等，因为输入时两数都保留 $12$ 位小数，所以我们读入时可以将整数部分用 int 读入，小数点用字符读入，小数部分用字符串读入，即可比较两数的小数部分了。

### AC code：
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int a, b;
char c;
string s1, s2;

int main()
{
	cin >> a >> c >> s1 >> b >> c >> s2;
	(s1 == s2) ? printf("YES") : printf("NO");
	return 0;
}
```

---

## 作者：liruixiong0101 (赞：5)

## P0 前言：
更新：感谢 @[tZEROちゃん](https://www.luogu.com.cn/user/219791) 发现 hack 是错的。  

## P1 题意：
给你两个实数，请问他们的差是否为整数。

## P2 思路：
首先从题意出发就可以发现可以定义实数 $a,b$ 如果他们的差为整数就输出 "YES" 否则输出 "NO"。  
但是这样的方法容易爆精度，所以就不提供此做法了。

---

由于是算两个实数的差是否为整数所以不需要考虑整数部分，只需看小数部分去掉末尾的零后是否相同即可。  
我一开始用 `long long` 存小数部分，用 `scanf` 输入，我考场上写的代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a , b , x , y;
//a,b为整数部分,x,y为小数部分
int main(){
	scanf("%lld.%lld %lld.%lld" , &a , &x , &b , &y);
	while(x % 10 == 0 && x) x /= 10;
	while(y % 10 == 0 && y) y /= 10;
	//去除末尾的零
	if(x == y) printf("YES");
	else printf("NO");
	return 0;
}
```
由于题目保证输入保留到小数点后 12 位，所以若前导 0 数量不同则去除前导 0 后的小数部分一定不同所以上述方法为正确。  
若小数部分的数位不一定，那么就有此 hack：`1.001 2.0001`。  
因为用 `long long` 存小数部分的前导零会被消除，所以我在考后换成了用 `string` 存小数部分的写法。

## P3 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
string a , b;
int main(){
	cin >> a >> b;
	while(a[a.size() - 1] == '0') a.erase(a.size() - 1 , 1);
	while(b[b.size() - 1] == '0') b.erase(b.size() - 1 , 1);
	//去除后缀零
	int posa = a.find('.') , posb = b.find('.');
	string x = a.substr(posa + 1 , a.size() - posa - 1);
	string y = b.substr(posb + 1 , b.size() - posb - 1);
	//x,y为小数部分
	if(x == y) cout << "YES";
	else cout << "NO";
	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：3)

## 思路

根据题意，我们要比较两个实数的小数部分是否相同。

那么去掉小数点，我们就得到了四个整数了，比较第二个和第四个即可。

## code

```cpp
#include<stdio.h>
#define int long long
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
main()
{
	int a,b,c,d;read(a);read(b);read(c);read(d);
	printf(b==d?"YES":"NO");
}
```



---

## 作者：_JF_ (赞：1)

## P9203 时效「月岩笠的诅咒」 

模拟。


做法还是比较显然的，因为每次能对某个数加 $1$，所以如果两个数小数点后面的数不一样那就无法相等。

考虑用字符串的形式输入，然后对小数点后面 $12$ 位比较即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	char a[100],b[100];
	int p,q;
	scanf("%s",a+1),scanf("%s",b+1);
	for(int i=1;i<=strlen(a+1);i++)	if(a[i]=='.')	{p=i+1;break;};
	for(int i=1;i<=strlen(b+1);i++)	if(b[i]=='.')	{q=i+1;break;};
	for(int i=0;i<=11;i++){
		if(a[p+i]!=b[q+i])	cout<<"NO"<<endl,exit(0);
	}
	cout<<"YES"<<endl;
	return 0;
}


```


---

## 作者：sw2022 (赞：0)

## 题意简析

可以发现操作不能改变小数部分，因此小数部分是否相同决定了两个事件是否满足“周年”关系。

## 代码/解释
输入保留到小数点后 $12$ 位，所以直接按字符串读入，然后判断后 $12$ 个字符是否相同即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[25],b[25];
int main()
{
	int la,lb,i;
	cin>>a+1>>b+1;
	la=strlen(a+1);
	lb=strlen(b+1);
	for(i=0;i<12;i++)
	if(a[la-i]!=b[lb-i])
	{
		printf("NO\n");
		return 0;
	}
	printf("YES\n");
	return 0;
}
```

---


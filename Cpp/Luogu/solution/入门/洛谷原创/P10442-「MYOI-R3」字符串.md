# 「MYOI-R3」字符串

## 题目描述

给定字符串 $s,t$。

现在你要在 $s,t$ 中删除一些字符并将它们重新排列使 $s=t$。

问操作后的 $|s|$（即字符串 $s$ 的长度）最大是多少？

## 说明/提示

在第一个样例中，将 `a` 删除，留下 `bc`。

此时 $|s|=2$，可以证明这是最优解。

在第二个样例中，将 `aaaaa` 删除，留下空串。
将 `bbbbb` 删除，留下空串。

此时 $|s|=0$，可以证明这是最优解。

**本题采用捆绑测试**。

记 $n=\max(|s|,|t|)$。

| $\text{Subtask}$ | $n\le $|  特殊性质 |总分值 |
| :--------------: | :-----: |:-----:|:--------: |
|       $1$        |  $10$ |  无  | $25$ |
$2$        | $10^5$  | $\text{A}$|  $25$ |
|       $3$        | $10^5$  | $\text{B}$ | $25$ |
|       $4$        | $10^5$ |     无     | $25$ |


对于 $100\%$ 的数据，$1  \le |s|,|t| \le 10^5$，字符串均由小写字母组成。

特殊性质 $\text{A}$：$s$ 是一个 $\text{a}\sim\text{z}$ 的排列。

特殊性质 $\text{B}$：保证 $s_i,t_i\in\{\text{a},\text{b} \}$。


## 样例 #1

### 输入

```
abc
bc```

### 输出

```
2```

## 样例 #2

### 输入

```
aaaaa
bbbbb```

### 输出

```
0```

# 题解

## 作者：SafariMo (赞：23)

贪心题。

我们每次对于每种字符，比较 $s$ 中出现次数和 $t$ 中出现次数取最小值，求和即可（正确性是因为可以重排，因此删多的即可）。

枚举每种字符暴力实现即可。

---

## 作者：ggylz49 (赞：11)

## 思路分析
建立两个桶 $a,b$，分别存储字符串 $s,t$ 中每一个字母的出现次数。
```cpp
string s,t;
cin>>s>>t;
for (int i=0;i<s.size();i++)a[s[i]-'a']++;//用0~26分别代指a~z
for (int i=0;i<t.size();i++)b[t[i]-'a']++;
```
然后对于每一个字母，由于 $a_i$ 和 $b_i$ 都无法增加，所以这个字母的出现次数只能变成 $\min(a_i,b_i)$。所以我们将 $a_i$ 和 $b_i$ 都变成它。
```cpp
for (int i=0;i<26;i++)
{
    a[i]=b[i]=min(a[i],b[i]);
}
```
最后，由于现在的 $|s|$ 就是 $a$ 中所有数的总和，累加输出即可。
```cpp
int ans=0;
for (int i=0;i<26;i++)
{
    ans+=a[i];
}
cout<<ans;
```
## Code
```cpp
#include <iostream>
#include <string>
using namespace std;
int a[26],b[26];
int main()
{
    string s,t;
    cin>>s>>t;
    for (int i=0;i<s.size();i++)a[s[i]-'a']++;
    for (int i=0;i<t.size();i++)b[t[i]-'a']++;
    for (int i=0;i<26;i++)
    {
        a[i]=b[i]=min(a[i],b[i]);
    }
    int ans=0;
    for (int i=0;i<26;i++)
    {
        ans+=a[i];
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Xssion37_XY (赞：6)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P10442)

[更好的阅读体验](https://www.luogu.com.cn/article/hlk2vmx8)

### 实际分析

模拟即可。

很快我们就写出了这样一份代码：

```
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXX = 1e5 + 11;
int n, m, sum;
char a[MAXX], b[MAXX];
int main() {
	scanf("%s %s", a, b);
	n = strlen(a);
	m = strlen(b);
//	sort (a,a + n);
//	sort (b,b + m);
	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < m; j ++) {
			if (a[i] == b[j]) {
				sum ++;
				a[i] = ' ';
				b[j] = ' ';
				break;
			}
		}
	}
	cout << sum;
	return 0;
}
```

然后就 T 飞了。

这份代码的时间复杂度为 $\mathcal{O(mn)}$，不能通过此题。

考虑优化，可以使用 map 来记录字符串 $a$ 中每个字符所出现的次数，然后遍历字符串 $b$，判断 map 中是否有出现过 $b$ 中的字符，统计即可，然后将 map 中的个数减 $1$。

这份代码的时间复杂度为 $\mathcal{O(m+n)}$，可以轻松通过此题。

### 代码部分

```cpp
#include <iostream>
#include <map>
#include <cstring>
using namespace std;
const int MAXX = 1e5 + 11;
int sum;
char a[MAXX], b[MAXX];
int main() {
	scanf("%s %s", a, b);
	map <char, int> Map;
	int n = strlen(a);
	int m = strlen(b);
	for (int i = 0; i < n; i ++) {
		Map[a[i]] ++;
	}
	for (int i = 0; i < m; i ++) {
		if (Map[b[i]] > 0) {
			sum ++;
			Map[b[i]] --;
		}
	}
	cout << sum;
	return 0;
}
```

完结撒花！

---

## 作者：Genshin_ZFYX (赞：4)

因为字母可以重排，所以我们只用把每个字母在两个字符串中出现次数中较少的一个相加就行了。

先用两个桶 $t1$ 和 $t2$ 记录下在 $s$ 和 $t$ 中每个字母出现的数量，再依次枚举每个字母，将 $\min\{t1_i,t2_i\}$ 加入答案即可，$i$ 是当前正在枚举的字母。

话说我比赛时没看见可以重排，题没做出来，还花了好久写了个 LCS。

AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
int t1[200],t2[200],ans;
int main()
{
    string s,t;cin>>s>>t;
    for(int i=0;i<s.size();i++)t1[s[i]]++;
    for(int i=0;i<t.size();i++)t2[t[i]]++;
    for(int i='a';i<='z';i++)ans+=min(t1[i],t2[i]);
    cout<<ans;
	return 0;
}

```

---

## 作者：_Deer_Peach_ (赞：2)

#### 题意简述：
给出两个字符串，通过删除一些字母和重新排列后使两字符串相同，求字符串最长的长度。

#### 思路：
由于可以重新排列，所以直接统计两字符串的各个字符的数量，通过对比，答案就是将每个字母出现的最小次数全部相加。这道题很简单，建议评红。

#### 代码：
```
#include<bits/stdc++.h>//万能头
#define int long long
using namespace std;
string a,b;
map<char,int> x,y;//统计字母出现次数
int ans;//答案
signed main(){
	cin>>a>>b;//输入
	int alen=a.size();
	int blen=b.size();
	for(int i=0;i<alen;i++)x[a[i]]++;//统计a字符串的每个字母数量
	for(int i=0;i<blen;i++)y[b[i]]++;//统计b字符串的每个字母数量
	for(char i='a';i<='z';i++)ans+=min(x[i],y[i]);//求答案
	cout<<ans;//输出
	return 0;//完美结束
}
```

---

## 作者：xzz_0611 (赞：1)

[题目传送门](/problem/P10442)
## 思路
要在 $s$ 与 $t$ 相等的情况下使 $|s|$ 尽可能的大，就只需要保留 $s$ 与 $t$ 中它们共同拥有的字符（同一个字符有多个也算），而此时，$|s|$ 的最大值就为 $s$ 与 $t$ 中每个字符共同拥有的个数，所以只需要计算出 $s$ 与 $t$ 中每个字符共同拥有的个数即可。

首先，计算出 $s$ 与 $t$ 中每个字符出现的次数，然后只要累加它们共同拥有的个数——对于一个字符 $c$，若其在 $s$ 中出现了 $a$ 次，在 $t$ 中出现了 $b$ 次，那么，对于这个字符，它们共同拥有 $\min(a,b)$ 个。
## Code
```cpp
#include<iostream>
using namespace std;
int cnt1[26],cnt2[26];//累计字符个数，记得要清0或定义为全局
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	string s,t;
	cin>>s>>t;
	for(int i=0;i<s.size();++i) ++cnt1[s[i]-'a'];//统计个数
	for(int i=0;i<t.size();++i) ++cnt2[t[i]-'a'];//统计个数
	int ans=0;
	for(int i=0;i<26;++i) ans+=min(cnt1[i],cnt2[i]);//累加
	cout<<ans;
	return 0;
}
```

---

## 作者：Breath_of_the_Wild (赞：1)

题意很好懂，不解释了。

也就是说我们应该让 $s$ 和 $t$ 每个字符出现次数相同。显然，既然要 $s$ 长度尽量大，就是要让删去的尽量少，那么每一个字符在两个串中出现的次数，都应该变为在两个字符串出现的次数的最小值。

所以循环 $26$ 个小写字母，当某个字符在 $s$ 的次数比出现在 $t$ 的次数大时，应在 $s$ 中删去多出来的这几次。用 $s$ 长度减去该一共需要删除的即为最终答案。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
const int N=300;
int a[N],b[N],ans,l;
int main(){
	cin>>s>>t;
	l=s.size();
	for(int i=0;i<l;i++) a[s[i]]++;
	for(int i=0;i<t.size();i++) b[t[i]]++;
	//记录出现次数
	for(int i='a';i<='z';i++){
		if(a[i]>=b[i]) ans+=a[i]-b[i];
	}
	cout<<l-ans;//s 长度减该删除的
    return 0;
}
```

---


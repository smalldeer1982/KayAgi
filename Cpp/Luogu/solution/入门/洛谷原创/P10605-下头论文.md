# 下头论文

## 题目背景

莲子一直在苦恼关于论文的灵感。她为此花了太多时间，以至于没有时间理会她的伙伴梅莉。

## 题目描述

一天，莲子发现了一个绝妙的点子，并希望通过实验等过程将其完善。具体来说，**她需要依次完成 $n$ 项任务**，其中第 $i$ 项任务需要连续的 $a_i$ 天来完成。也就是说，假设她在第 $x$ 天开始该任务，那么她会在第 $x+a_i-1$ 天结束后完成该任务，她需要保证这些天里她都是空闲的。

不幸的是，她有 $m$ 天有各种事要去做，这些非空闲的日子会以一个单调递增序列 $b$ 的形式给出。即，对于任意的 $i(1\leq i<m)$，满足 $b_i<b_{i+1}$。

莲子希望完成任务的时间越短越好。例如：不妨假设，莲子要完成 $2$ 项任务，第一项耗时 $2$ 天，第二项耗时 $3$ 天，而第 $4$ 天莲子有事情要去做。则下图呈现了一种方案，使得莲子完成任务的时间尽可能短，为 $7$ 天：

![](https://cdn.luogu.com.cn/upload/image_hosting/bdiupoc1.png)

她想要知道，在最好情况下，她能在第几天结束后完成所有任务。

## 说明/提示

### 样例解释

#### 样例 \#1

即在题面中提及的情况。莲子在第 $1$ 天开始第一项任务，在第 $2$ 天结束后完成第一项任务。由于第 $4$ 天有事，她不能从第 $3$ 天开始第二项任务，于是她只好从第 $5$ 天开始该任务，在第 $7$ 天结束时完成全部任务。

注意到该样例符合 $\textbf{Subtask 2}$ 的特殊性质。
#### 样例 \#2

莲子在第 $2$ 至第 $4$ 天**依次**完成了所有任务。

### 数据范围

**本题采用捆绑测试。每一个 Subtask 内的测试点均需通过才能获得该 Subtask 的分数。**

简记：$\sum a_i$ 为所有 $a_i$ 的和，即 $a_1+a_2+\dots+a_n$。其他试题中若无特殊说明也以此解释为准。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n,m\le } & \bm{\sum a_i\le} & \bm{b_i\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 20 & 10 & 100 & 100 & - &-\cr\hline
2 & 20 & 10^5 & 10^8 & 10^8 & m=1&- \cr\hline
3 & 20 & 10^3 & 10^8 & 10^8 & \mathbf{-}&-  \cr\hline
4 & 40 & 10^5 & 10^8 &  10^8& -&1,2,3 \cr\hline
\end{array}
$$

对于所有数据满足：$1\le n,m\le 10^5$，$1\le a_i \le \sum a_i\le 10^8$, $1\le b_i\le 10^8$，$b$ 为单调递增序列。

## 样例 #1

### 输入

```
2 1
2 3
4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3
1 1 1
1 5 6```

### 输出

```
4```

# 题解

## 作者：chen_zhe (赞：14)

容易发现为了完成任务的时间最短，对于当前长度为 $x$ 的任务，每次莲子会选择一个最早的时间 $t$ 满足 $t$ 到 $t+x-1$ 均是空闲的。

接下来观察到：选择的时间 $t$ 一定要么是上次结束任务的时间，要么是某个非空闲日子 $b_i$ 的下一天 $b_i+1$。遍历数组 $b$ 并记录上次结束任务的时间和当前进行到第几项任务，可以做到 $O(n+m)$ 的复杂度。

---

## 作者：Superiority (赞：11)

# 思路
要使完成任务的天数尽量少，我们尽量不要浪费任何的空闲时间。而空闲的时间就是前一次的非空闲日子以及后一次的非空闲日子之间，我们只要在这个期间多做一些任务，这样总共完成任务的天数就一定会是最少的。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6;
#define zjj long long
int T;
int n,m;
zjj sum;
zjj a[MAXN],b[MAXN];
int idx=1,idy=1;
int main(){
	ios::sync_with_stdio(false);
    cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	while(idx<=n&&idy<=m){
		if(sum+a[idx]<b[idy]) sum+=a[idx++];
		else sum=b[idy++];
	}
	while(idx<=n){
		sum+=a[idx++];
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：syman_liu (赞：3)

# [P10605] 下头论文 题解
[题目传送门](https://www.luogu.com.cn/problem/P10605)
## 题目简述
将满足长度为 $a_i$ 且不包含 $b_i$ 的所有区间排成一行，求出它的终点位置。
## 解题思路
我们发现，每个工作莲子都要**按顺序**做，且必须每个都**做完**。

那我们可以通过确定每个工作开始和结束的时间，判断在这个时间区间里是否有非空闲日，从而确定下一个工作开始和结束的时间。  
具体如下：  

设这个工作开始时间为 $start$，结束时间为 $end$
- 若这个工作区间里没有非空闲日：  
进行下一个工作：开始时间就等于这个工作的结束时间 $+1$，就是 $end + 1$

- 若这个工作区间里有非空闲日：  
继续进行这一个工作：开始时间等于这个非空闲日 $+1$

理解到这里，这题基本就AC了

## AC code
```cpp
#include <bits/stdc++.h>
#define end END// 避免关键字冲突
using namespace std;

int n,m,last = 1,cnt = 1,busy = 1;// last表示上一个工作的起始时间，cnt表示完成了几个工作，busy表示上一个非空闲时间
int a[100005],b[100005];

int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i ++){
		cin >> a[i];
	}
	for (int i = 1;i <= m;i ++){
		cin >> b[i];
	}
	while (cnt <= n){// 表示工作还没有全部做完
		bool flag = 1;// flag表示这个工作区间里有没有非空闲日
		for (int i = busy;i <= m;i ++){// 从上一个非空闲日开始判断工作区间里有没有非空闲日
			int end = last + a[cnt] - 1;// 这个区间的结束时间
			if (last <= b[i] and b[i] <= end){// 非空闲日在区间里面
				flag = 0;// 有空闲日
				last = b[i] + 1,busy = i + 1;// 下一个工作的开始时间等于这个非空闲日+1，更新忙碌时间
				break;
			}
			if (b[i] < last or b[i] > end){// 如果忙碌时间在区间外
				flag = 1;// 无空闲日
				break;
			}
		}
		if (!flag) continue;
		last += a[cnt ++];// 进行下一个工作，下一个开始时间就等于这个工作的结束时间+1
	}
	cout << last - 1 << endl;// 多算了一天，记得-1
	return 0;
}
```

---

## 作者：Zyh_AKer (赞：2)

## 思路
通过读题我们可以知道任务必须一项一项按顺序做，所有我们可以遍历所有的任务，看一看第 $i$ 项任务能不能在 第$x$ 天到第 $x+a_i-1$ 天完成，如果可以，那么 $x\to x+a_i-1$，继续判断下一个任务，否则如果在这之间有其他事情，那么 $x\to b_{j+1}$，$j \to j+1$ 继续判断当前任务，最后答案就是 $x$。
## AC Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
int n,m,ans=1,now=1;
int a[N],b[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for (int i=1;i<=m;i++)
	{
		cin>>b[i];
	}
	for (int i=1;i<=n;i++)
	{
		while (!(ans!=b[now] && ans+a[i]-1<b[now]) && now<=m)
		{
			ans=b[now]+1;
			now++;
		}
		ans=ans+a[i]-1;
		if (i!=n)
		{
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/162559334)

---

## 作者：zhangxiaohan007 (赞：1)

## 思路
这道题很简单，通过分析题目不难发现，任务必须要一项一项挨着做，不能跳着做（所以别一上来就先排序），所以我们可以从头到尾来看任务能不能在这两个有事的时间之间完成即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],tot=1;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	for(int i=0;i<=m;i++)
	{
		int l=b[i];
		while(l+a[tot]<b[i+1])
		{
			l=l+a[tot];
			tot++;
			if(tot>n)
			{
				cout<<l;
				return 0;
			}
		}
	}
	int l=b[m];
	while(1)
	{
		l=l+a[tot];
		tot++;
		if(tot>n)
		{
			cout<<l;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：1)

这是一道模拟题。

思路：

按照顺序去完成每一个任务（一定要按照顺序），再判断每个任务期间是否有当天有事的日子，如果有，换一个时间段，否则进行下一个任务。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100001],b[100001],ans=1,las=1;//ans是时间，las是第几个有事的天
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);//可以让cin,cout更快
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}for(int i=1;i<=m;i++){
		cin>>b[i];
	}for(int i=1;i<=n;){
		bool f=true;
		for(int j=las;j<=m;j++){
			if(b[j]>=ans and b[j]<=ans+a[i]-1){//判断时间段中是否有有事的天
				f=false;
				ans=b[j]+1//更新时间
				las=j+1;
				break;
			}if(b[j]>ans+a[i]-1)break;//优化1：如果当前有事的日子超过结束的日子，说明在此期间都空闲
			if(b[j]<ans)break;//优化2：如果当前有事的日子不到开始的日子，说明在此期间都空闲
		}if(f)ans=ans+a[i],i++;//更新答案
	}cout<<ans-1;//要减一，因为最后多算了一天
	return 0;
}
```

---

## 作者：xuan_never (赞：0)

来水一篇较短解法。

## 思路

看题解都是离线做的，我来讲下在线做法。  
每次可以通过记录上一个非空闲的日子，直接算出可以用来做任务的天数，因为任务的顺序是固定的，所以直接进行判断是否可以做任务即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[100005], b, ru, an, l;
// an 为答案，ru 用来记录上一个非空闲的日子， l 表示空闲的日子数
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	for (int i = n; i >= 1; --i)
		cin >> a[i]; // 倒序输入，省一个变量
	for (int i = 1; i <= m; ++i) {
		cin >> b;
		l = b - ru - 1, ru = b;
		while (n && a[n] <= l) // 按顺序判断
			l -= a[n], an += a[n--];
		if (!n) break;
		an = b;
	} while (n) an += a[n--];
	cout << an;
	return 0;
}
```

---

## 作者：王逸辰 (赞：0)

# P10605 下头论文 题解
## 思路
模拟，一项接一项地做，不能跳着做。

如果任务跟有事的天重了，就顺推到有事的天之后。
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001],b[100001];
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=m; i++)
		cin>>b[i];
	long long s=0,cnt=1,cnt2=1;
	while(cnt<=n){
		if(cnt2>m){
			for(int i=cnt; i<=n; i++)
				s+=a[i];
			cout<<s;
			return 0;
		}
		if(a[cnt]<b[cnt2]-s)
			s+=a[cnt],cnt++;
		else 
			s+=b[cnt2]-s,cnt2++;
	}
	cout<<s;
	return 0;
}
``````

---

## 作者：SecuritySetting (赞：0)

这是道模拟题，有几个坑要注意一下。

首先，有 $n$ 个任务要依次完成（注意是要按照顺序完成，这个蒟蒻一开始当成贪心来做了），每个任务要做连续的 $a _ i$ 天（注意是连续，中间不能断开）。

其次，第 $b _ i$ 天是忙碌的，是不能做任务的，也就是说，在做任务时，要避开第 $b _ i$ 天。

最后，不能完全暴力，要加几个优化，否则会超时。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, m;
int a[100001], b[100001];
int res = 1, k = 1;//答案，第几个忙碌的日子
int main() {
	cin >> n >> m;//n个任务，m天忙碌
	for (int i = 1; i <= n; i ++) {
		cin >> a[i];//第i个任务所需的时间
	}
    for (int i = 1; i <= m; i ++) {
		cin >> b[i];//第i个忙碌的日子
	}
    for (int i = 1;i <= n; i) {
		bool f = 1;//记录该任务能不能做
		for (int j = k; j <= m; j ++) {//遍历忙碌的日子
            if (b[j] > res + a[i] - 1) break;//如果遍历到的忙碌日子在当前任务之后，直接跳过
			if (b[j] < res) break;//如果遍历到的忙碌日子在当前任务之前，直接跳过
			if (b[j] >= res && b[j] <= res + a[i] - 1) {//如果忙碌日子在任务进行中，换一个任务时间
				f = 0;//换日子了
				res = b[j] + 1;//开始日子到忙碌日子之后
				k = j + 1;//下一个忙碌日子
				break;//结束
			}
		}
        if (f == 1){//如果能做
            res = res + a[i];//更新答案
            i ++;//做下一个任务
        }
	}
    cout << res - 1;//由于最后多算一天，所以要减一
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

一个简单题，赛时秒了。按题意模拟即可。

注意一下几点：

1. 枚举 $k_i$ 的顺序和 $c_i$ 一样是从 $1$ 到 $n$。
2. 不开 ```long long``` 见祖宗。

贴代码：
```
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
const int maxn=1e5+10,maxm=1e5+10,mod=1e9+7;
LL k[maxn],c[maxn],cur=1,kkkisgod,=0;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>k[i];
	}
	for(int i=1;i<=m;i++){
		cin>>c[i];
		while(sum+k[cur]<c[i]&&cur<=n)sum+=k[cur],cur++;
		if(sum+k[cur]>=c[i])sum=c[i];
		if(cur==n)break;
	}
	while(cur<=n)kkkisgod+=k[cur],cur++;
	cout<<kkkisgod;
	return 0;
}
```

---


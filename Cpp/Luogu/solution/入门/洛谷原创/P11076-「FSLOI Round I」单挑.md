# 「FSLOI Round I」单挑

## 题目背景

小 F 和小 S 经常进行篮球单挑，但小 S 总是被盖帽。

## 题目描述

每次单挑的结果一定是小 F 获胜或者小 S 获胜，不存在平局的情况。

由于小 F 和小 S 实力不均衡，于是他们制定规则如下：

给定两个整数 $x,y$，若小 F 先赢 $x$ 场，则小 F 获胜。若小 S 先赢 $y$ 场，则小 S 获胜。

现在已经进行了 $n$ 场单挑，这 $n$ 场单挑的结果由一个字符串 $s$ 给出。若 $s$ 的第 $i$ 位为 `F`，则小 F 赢了第 $i$ 场。若 $s$ 的第 $i$ 位为 `S`，则小 S 赢了第 $i$ 场。

小 F 想知道，为了取得胜利，后续的比赛中他**最多连续胜利的场数最少是多少**。

你总共需要回答 $T$ 组询问。

## 说明/提示

**【样例 1 解释】**

为了让小 F 获胜，后续的比赛结果只能为 $ \texttt {FFFF}$，此时最多连续胜利场数为 $4$。

**【样例 2 解释】**

为了让小 F 获胜，一种可能的后续的比赛结果为 $ \texttt {FFSFSF}$，此时最多连续胜利场数为 $2$。

请注意，您只需考虑**后续**的比赛中的最多连续胜场数，而不需要考虑前 $n$ 场。

**【数据规模与约定】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，保证：
- $1 \leq T \leq 20$
- $1 \leq n \leq 2\times10^5$
- $1 \leq x,y \leq 10^9$
- $\forall i \leq n$，保证第 $i$ 场比赛结束后小 S 没有获胜。
- $\forall i < n$，保证第 $i$ 场比赛结束后小 F 没有获胜。

|子任务|分值|特殊性质|
|:-----:|:-----:|:-----:|
|$1$|$10$|$n=1$|
|$2$|$15$|$x,y\leq n$|
|$3$|$15$|$A$|
|$4$|$30$|$T=1$|
|$5$|$30$|无|

- 特殊性质 $A$：第 $n$ 场比赛结束后，小 S 总共获胜 $y-1$ 场。

## 样例 #1

### 输入

```
1
5 6 4
SFSFS
```

### 输出

```
4
```

## 样例 #2

### 输入

```
1
3 7 3
FFF
```

### 输出

```
2
```

## 样例 #3

### 输入

```
1
29 1000 20
FFFSFFFFSFFFFFSFFFSFFFFFFSFFF
```

### 输出

```
66
```

# 题解

## 作者：FL_sleake (赞：19)

### Fun fact

样例三所给出的 $n$ 场对局来源于 FL_sleake 和 SnowTrace 单挑的真实数据。并且 FL_sleake 一共给了 SnowTrace 七个盖帽。

### 解题思路

由于只需要考虑后续比赛，所以给出来的 $n$ 场比赛可以直接处理掉。具体地，设 $s$ 中有 $tx$ 个 `F`，有 $ty$ 个 `S`，我们把 $x$ 设置为 $x-tx$，把 $y$ 设置为 $y-ty$。

为了让小 F 获胜，小 S 最多获胜 $y-1$ 场。那么问题转化成了有 $x$ 个球，你需要放 $y-1$ 个挡板，问最多的连续的球数最少是多少。由于 $y-1$ 个挡板可以产生 $y$ 个空位，所以把球尽量均匀地放进去就可以了，答案为 $x$ 除以 $y$ 上取整的结果。

单个数据复杂度为 $\Theta(n)$。

### 代码示例

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,x,y,n;
string s;
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>x>>y;
		int sumx=0,sumy=0;
		cin>>s;
		s=" "+s;
		for(int i=1;i<=n;i++){
			if(s[i]=='F') sumx++;
			else sumy++;
		}
		x-=sumx;
		y-=sumy;
		cout<<(x+y-1)/y<<endl;
	}
	return 0;
}
```

---


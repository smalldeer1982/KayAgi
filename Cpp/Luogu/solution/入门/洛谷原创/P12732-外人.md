# 外人

## 题目背景

> 正因为实际体验过我才能这么说——义妹这种存在，只是单纯的外人。\
——浅村悠太

## 题目描述

悠太和沙季有时会在学校遇到对方。由于班级不同，上课时也基本上在不同的地方，只会在课间换教室时见到。

水星高中一天共有 $n-1$ 个课间，第 $i$ 个课间悠太会从第 $y_i$ 层走到第 $y_{i+1}$ 层，沙季会从第 $s_i$ 层走到第 $s_{i+1}$ 层。假设课间开始时刻为 $i$，结束时刻为 $i+1$，他们的行动可以看作以时间 $t$ 为横轴，以高度 $h$ 为纵轴的平面直角坐标系上点 $(i,y_i)$ 到 $(i+1,y_{i+1})$ 的线段与点 $(i,s_i)$ 到 $(i+1,s_{i+1})$ 的线段。

如果他们同时间处于同一高度，也就是说如果上述两条线段有交点，那么两人就会互相见到。他们可以在两层之间的楼梯上见到，也可以在出发时或到达时见到。即交点坐标可以不是整数，也可以是线段的端点，具体地，如果悠太和沙季在同一层上课，即 $y_i=s_i$，则认为第 $i-1$ 个课间（若 $i\ge2$）和第 $i$ 个课间（若 $i\le n-1$）他们均会互相见到。

他们想要知道今天一共会在几个课间互相见到。

## 说明/提示

#### 样例解释

第一个课间，悠太和沙季在第 $1,2$ 层之间的楼梯见面；

第二个课间，两人没有见面。

#### 数据范围与限制

对于 $20\%$ 的数据，满足 $y_i,s_i\le2$。

对于另外 $20\%$ 的数据，满足所有 $y_i$ 均相等。

对于另外 $20\%$ 的数据，满足所有 $s_i$ 均相等。

对于所有数据，满足 $2\le n\le10$，$1\le y_i,s_i\le10$。

## 样例 #1

### 输入

```
3
1 2 3
3 1 2
```

### 输出

```
1
```

# 题解

## 作者：VinstaG173 (赞：11)

签到题。发现定义的线段相交等价于 $(y_i-s_i)(y_{i+1}-s_{i+1})\le0$，直接计算即可。

Code:
```cpp
int n,cnt;
int y[13];
int s[13];
inline void solve(){
	cin>>n;cnt=0;
	for(int i=1;i<=n;++i)
		cin>>y[i];
	for(int i=1;i<=n;++i)
		cin>>s[i];
	for(int i=1;i<n;++i)
		cnt+=((y[i]-s[i])*(y[i+1]-s[i+1])<=0);
	cout<<cnt<<"\n";
}
```

---

## 作者：Mss1617 (赞：8)

## 题目大意
一共有 $n$ 节课，$n-1$ 个课间。每节课两人分别在 $y[i]$ 和 $s[i]$ 上课，到了课间便会分别从 $y[i]$ 和 $s[i]$ 转移至 $y[i+1]$ 和 $s[i+1]$。问两人一共会在几个课间互相见到。

---

## 解题思路
题意晦涩难懂，不妨画个图先来理解。

下面以样例为例画个图：

```
3       // 3 节课
1 2 3 // y[i]
3 1 2 // s[i]
```

![](https://cdn.luogu.com.cn/upload/image_hosting/w7u4f22n.png)
这大概就阐述清了“如果他们同时间处于同一高度，也就是说如果上述两条线段有交点，那么两人就会互相见到”的含义。

那还有一个“他们可以在两层之间的楼梯上见到，也可以在出发时或到达时见到”，啥意思？

![](https://cdn.luogu.com.cn/upload/image_hosting/jq060b5y.png)

《生动形象》。

这就很好考虑了，判断每个线段是否有交点即可。

### 核心内容

判断交点，可以通过比较线段端点的方法来判断。

由第一幅图可知：如果 $s[i] < y[i]$，且 $s[i+1] > y[i+1]$，则两条线段有交点；  
由第二幅图可知：第一个课间时，如果 $s[i] < y[i]$，且 $s[i+1] = y[i+1]$，则两条线段端点相交；第二个课间时，如果 $s[i] = y[i]$，则两条线段端点也相交。

整理，得：$s[i] < y[i]$ 且 $s[i+1]  \ge y[i+1]$ 或 $s[i] = y[i]$ 时，两线段有交点。

由于咱们不知道 $s[i]$ 和 $y[i]$ 谁大，所以判断的时候需要判断两次。

最后 $ans$ 计数输出即可。

---

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int s[10005],y[10005];
int ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>s[i];
	for(int i=1;i<=n;i++)	cin>>y[i];
	for(int i=1;i<=n-1;i++)
	{
        //核心部分
		if(s[i]>y[i]&&y[i+1]>=s[i+1]||y[i]>s[i]&&s[i+1]>=y[i+1]||s[i]==y[i])	ans++;
	}
	cout<<ans;
	return 0;
} 
```
感谢观看。

---

## 作者：Yxa_Sheep (赞：7)

**[题目传送门](https://www.luogu.com.cn/problem/P12732)**
## 题意
每一个课间可以看成平面坐标系上两条线段，沙季是从 $(i,y_i)$ 到 $(i+1,y_{i+1})$ 的线段，悠太从 $(i,s_i)$ 到 $(i+1,s_{i+1})$ 的线段，如果这两条线段它们相交，那两个人就会相遇。求相遇次数。
## 思路
让我们想象两条线段相交的样子是什么样子的，只能是一个形状像 X 的东西。那么假设 X 左下角到右上角是沙季走的路线，右下角到左上角是悠太走的路线，他们的纵坐标同时从 $i$ 到 $i+1$，于是我们可以不用考虑纵坐标，只看横坐标。显然，这里 $y_i \le s_i$，而 $s_{i+1} \le y_{i+1}$。要是把两人的路线反过来把小于变大于就行了。如果把 $y_i$ 与 $s_i$ 相减，把 $y_{i+1}$ 与 $s_{i+1}$ 也相减，得到的必定是一正一负，它们的乘积必定小于等于 $0$。也就是说，在 $(y_i - s_i) \times (y_{i + 1} - s_{i + 1}) \le  0$ 的情况下，答案数加一。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, y[20], s[20];
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &y[i]);
    for (int i = 1; i <= n; i++)
        scanf("%d", &s[i]);
    for (int i = 1; i < n; i++)
        if ((y[i] - s[i]) * (y[i + 1] - s[i + 1]) <= 0)
            ans++;
    printf("%d", ans);
    return 0;
}
```
题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/P12732)**

---

## 作者：封禁用户 (赞：5)

官方题解推出的结论是对的，但是并没有做解释啊。

先把结论放下来：$(y_i-s_i)(y_{i+1}-s_{i+1})\le0$。

现在做一下解释:

悠太开始时为第 $y_i$ 层，沙季开始时为第 $s_i$ 层。悠太结束时为第 $y_{i+1}$ 层，沙季结束时为第 $s_{i+1}$ 层。

我们可以将情况分为两种。

第一种：在出发或到达时相遇。开始时 $y_i - s_i =0$，结束时 $y_{i+1} - s_{i+1} = 0$。那么 $(y_i-s_i)(y_{i+1}-s_{i+1}) = 0$。

第二种：途中相遇。这又可以分为两种。第一种： $y_i$ 大于 $s_i$，$y_{i+1}$ 小于 $s_{i+1}$。这样是一个正数与一个负数相乘，结果一定是负数。第二种：$y_i$ 小于 $s_i$，$y_{i+1}$ 大于 $s_{i+1}$。这样还是一个正数与一个负数相乘，结果一定还是一个负数，也就是结果小于 $0$。

所以，第一种对应着 $(y_i-s_i)(y_{i+1}-s_{i+1}) = 0$，第二种对应着 $(y_i-s_i)(y_{i+1}-s_{i+1})\lt0$。所以结论为 $(y_i-s_i)(y_{i+1}-s_{i+1})\le0$。

代码和官方题解差不多，就不放了。

---

## 作者：zxChicken4088 (赞：2)

~~这题为什么突然又能写题解了？~~

我们进行分类讨论：

1. 在两条线段的任一端点相交，即 $y_i-s_i=0\lor y_{i+1}-s_{i+1}=0\iff(y_i-s_i)(y_{i+1}-s_{i+1})=0$。
2. 在两条线段的中间相交，即 $y_i-s_i<0\lor y_{i+1}-s_{i+1}<0\iff(y_i-s_i)(y_{i+1}-s_{i+1})<0$。

现在把两个结论合在一起，$(y_i-s_i)(y_{i+1}-s_{i+1})=0\lor(y_i-s_i)(y_{i+1}-s_{i+1})<0\iff(y_i-s_i)(y_{i+1}-s_{i+1})\le0$。

既然结论已经出来了，只需遍历 $i\in[1,n)\cap\N$，依次判断每个 $i$ 即可。

---

## 作者：bayiran (赞：2)

~~哇居然能交题解~~

考虑建立一个以时间为横轴，以楼层为纵轴的坐标系。



||悠太|||||||
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
||||沙季|沙季||||
|||沙季|悠太|||沙季||
|沙季|||||沙季||悠太|
|||悠太||悠太|悠太|||
|悠太||||||||
||沙季||||||沙季|
|||||||悠太||

（电脑不知道为什么不能画图了只能这样表示）。

上~~图~~表表示在第一节课悠太在 $3$ 楼，沙季在 $5$ 楼，第二节沙季在 $2$ 楼，悠太在 $8$ 楼……

把他们每节课所在的地方连成两条折线，判断相遇几次就是判断两条折现相交了几次。

因为折线的每一段都可以看作一次函数，所以我们只要分析 $n-1$ 次相交分析即可。

两个一次函数 $f(x)$ 与 $g(x)$ 在区间 $[a,b]$ 内相交的充分必要条件是：
1. $f(a)>g(a)$ 且 $f(b)<g(b)$
2. $f(a)<g(a)$ 且 $f(b)>g(b)$

枚举判断即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    int a[100],b[100];
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=0;i<n;i++){
        cin>>b[i];
    }
    int ans = 0;
    for(int i=1;i<n;i++){
        if((a[i-1]>=b[i-1]&&a[i]<=b[i]) ||(a[i-1]<=b[i-1]&&a[i]>=b[i])){
            ans ++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

拒绝代码复制，共创美好洛谷。

---

## 作者：b9113fced86a32cad0d8 (赞：0)

一道比较简单的题目。

观察题目，注意到悠太和沙季在第 $i$ 个课间相遇，需要满足以下条件：
 - 在第 $i$ 节课，悠太和沙季的楼层相同；
 - 在第 $i+1$ 节课，悠太和沙季的楼层相同；
 - 在第 $i$个课间，悠太和沙季的位置关系发生了变化。

形式化地：
 - $y_{i}=s_{i}$
 - $y_{i+1}=s_{i+1}$
 - $y_{i}<s_{i}$ 并且 $y_{i+1}>s_{i+1}$
 - $y_{i}>s_{i}$ 并且 $y_{i+1}<s_{i+1}$

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int y[15],s[15];
bool ans[15];//判断每个课间是否相遇
int cnt;//答案

int main(){
    cin>>n;
    for(int i = 1;i <= n;i++){
        cin>>y[i];
    }
    for(int i = 1;i <= n;i++){
        cin>>s[i];
    }
    for(int i = 1;i < n;i++){//遍历课间
        if(y[i] > s[i] && y[i + 1] < s[i + 1]) ans[i] = true;
        if(y[i] < s[i] && y[i + 1] > s[i + 1]) ans[i] = true;
        if(y[i] == s[i]) ans[i] = true;
        if(y[i + 1] == s[i + 1]) ans[i] = true;
    }
    for(int i = 1;i < n;i++){//统计相遇的课间数
        cnt += ans[i];
    }
    cout<<cnt;
    return 0;
}
```

---

## 作者：YuTinMin (赞：0)

## 思路
考数学的题。

首先，悠太会用一个课间的时间（$i \sim i+1$）从 $h_i$ 的高度到 $h_{i+1}$ 的高度，沙季也是从一个课间的时间（$i \sim i+1$） 从 $s_i$ 的高度到 $s_{i+1}$ 的高度，按题目的说法，我们可以把悠太和沙季走的时间 $i$ 作为平面直角坐标系的 $x$ 轴，他们走的高度 $h$、$s$ 作为平面直角坐标系的 $y$ 轴，如下面的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gm0bfphj.png)

图中交点就是题目问的是否能相遇，算出是否能相遇，就是把悠太的起点减去沙季的起点的差乘悠太的终点减去沙季的终点的差，就是下面这个公式：
$$
(y_i-s_i) \times (y_{i + 1} - s_{i + 1})
$$

然后就直接上代码。
## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n, y[13], s[13], cnt = 0 ;

int main()
{
	
	cin >> n;
	for(int i = 1;i <= n;i++)
		cin >> y[i];
	for(int i = 1;i <= n;i++)
		cin >> s[i];
	for(int i = 1;i < n;i++)
	{
		int yy = y[i] - s[i];
		int ss = y[i + 1] - s[i + 1];
		if(yy * ss <= 0)
			cnt++;
	}
	cout << cnt;
	
	return 0;
}
```

---


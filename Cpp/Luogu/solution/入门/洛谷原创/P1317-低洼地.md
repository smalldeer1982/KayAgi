# 低洼地

## 题目描述

一组数，分别表示地平线的高度变化。高度值为整数，相邻高度用直线连接。找出并统计有多少个可能积水的低洼地？

如图：地高变化为 $[0,1,0,2,1,2,0,0,2,0]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/c1zyz8wu.png)



## 样例 #1

### 输入

```
10
0 1 0 2 1 2 0 0 2 0
```

### 输出

```
3```

# 题解

## 作者：你若安好，便是晴天 (赞：513)

许多人一看到这一题就不约而同的想到要开数组

但其实这题根本不用开数字

每输进一个数就判断一次

所以我们需要a，b两个参数

一个用于存前面的参数

另一个用于存现在输入的参数

再用一个l用于表示左坡是否形成

当右坡形成且左坡存在的情况下

ans++
最后输出ans便可以了

```cpp

for(int z=1;z<=n;z++)
{
    cin >>b;
    if(b<a) {l=1;}
    if(b>a&&l==1) {ans++;l=0;}
    a=b;
}

```

---

## 作者：felixwu (赞：125)

我的天外山外楼外楼外山外天   
c++的程序为何如此之长，好在我没有打长代码的习惯
简单的来说把一个洼地分成两段：   
	1，下降段  
    2，上升段
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[100001],ans,k;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	int i=1;
	while(i<=n){
		while(a[i]<=a[i-1]&&i<=n) i++;//1
		while(a[i]>=a[i-1]&&i<=n) i++;//2
		ans++;//一段完了多一个答案
	}
	printf("%d",ans-2);//最开始与最后都算了所以减掉
    return 0;
}
```

---

## 作者：Shikieiki (赞：67)

# 这是一个萌新的第一个题解 请大佬不要喷
#### 不说太多，上代码
AC代码如下
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
	int a, b, ans=0, l=0,n;
	cin >>n>>a;                 //建立一个n，输入    后面跟第一个数字，
	for (int i = 1; i <= n; i++)//for循环在未满足长度时继续循环
	{
		cin >> b;               //输入第二个数字
		if (b < a) {            //当b<a的时候，就是左坡高于b
			l = 1;              //使l=1做标记
		}
		if (b > a&&l == 1) {   //当第二个输入的b大于a时，就是右坡高于中间
			ans++; l = 0;      //使答案+1，标记用的l变为0
		}
		a = b;                 //让a=b（就是一个重新赋值）下方有图
	}
	cout << ans;               //当全部结束后，输出可能形成水洼的个数
}
```
你应该看见了这个下方图片的提示，为了给一些看不懂为什么a=b人看的

首先输入的是这个情况
![](https://s2.ax1x.com/2019/08/01/ed99YR.png)
然后让a=b之后就是这样的情况了
![](https://s2.ax1x.com/2019/08/01/edCo2q.png)

然后再一次输入b
![](https://s2.ax1x.com/2019/08/01/edCXa4.png)

之后继续循环。。。

~~可能我太菜才怕你们不懂吧~~

题解结束，请管理审核

---

## 作者：行者_Walker (赞：62)

### 代码有长有短，但思路总是不同。

**别看我代码长**其实思路很简单，只要有WA地，那么就有山峰，那我只需要判断这段路有几个波峰波谷再除以二就行了！

上代码
```cpp
# include <iostream>
# include <cstring>
# include <cstdio>
using namespace std;
int read();//快读，萌新可以忽视 
int main()
{
	int n;
	int x[10005];//存路 
	int pre;
	int ans=0;//存有几个波峰波谷 
	int flag;
	n=read();
	for(int i=1;i<=n;i++)
	{
		x[i]=read();//快速读入
		//相当于cin>>x[i]; 
	}
	if(x[1]<=x[2])//如果是上坡 
	flag=0;
	for(int i=2;i<=n;i++)//注意这里是从2开始的 
	{
		int pre=x[i-1];//因为这里pre记录了上一个点 
		int change=flag;//存flag原值 
		if(pre<x[i])
		{//这个点相对于上个点是上坡，就标记为0 
			flag=0; 
		}
		if(pre>x[i])
		{//下坡就标记为1； 
			flag=1;
		}
		if(flag!=change)
		{//如果改变了就说明出现了一个波峰或波谷 
			ans++;
		}
	}
	printf("%d",ans/2);//整数除法向下去整 
} 
int read()//快读的函数 
{
	int res=0,flag=1;
	char ch;
	if((ch=getchar())=='-')
	flag=-1;
	else
	res=ch-'0';
	while((ch=getchar())>='0'&&ch<='9')
	{
		res=res*10+ch-'0';
	}
	return res*flag;
}
```

总之就是，只要出现了单数的峰值，那么一定有1/2个波谷

---

## 作者：LW_h_FP (赞：60)

分析一下题目：

主要是要找到两边都低的就可以+1；

所以先找到小于左边的，再找小于右边的：
```
#include<iostream>
using namespace std;

int n,a[10010],ans;//a存高度，ans记答案

int main(){
	cin>>n;
	for(int i=0;i<n;i++)//读入
		cin>>a[i];
	for(int i=1;i<n;i++)//开始查找
		if(a[i-1]>a[i]){//当找到比左边高的开始判断
			while(a[i]>=a[i+1]&&i<n-1)//如果右边还是低的话直接看下一个，直到没有或找到比右边低的
				i++;
			if(i!=n-1) ans++;
		}
	cout<<ans;//最后输出答案
	return 0;
}
```
萌新代码，不喜勿喷

---

## 作者：Histone (赞：51)

看到好多dalao用什么山峰山谷除二啊,还有各种去重。

本蒟蒻一时间真的没看懂啊。。（My vegetable has exploded）

只好把我 ~~看完题便无脑~~ 写出来的代码放上来了



```cpp
#include<iostream>
using namespace std;
int nu[10521];
int main(void){
	int n,i,ans = -1;//因为保证首尾都是0，所以-1
    
	cin>>n;
	for(i=0;i<n;i++)cin>>nu[i];//输入
    
	for(i=1;i<n-1;i++)/*上面-1的原因，因为下面统计的是波峰=_=，波峰-1 = 波谷（具体证明就不放上来了）*/
		if(nu[i-1]<nu[i]&&nu[i]>nu[i+1])ans++;
	cout<<ans;
	return 0;
}
```

！！当你把代码上交（submit）的时候，会惊讶的发现，居然**只有80分**。

什么地方出了问题呢？？

稍加思索……

让我们跑一下，以下数据：


------------


**8**

**0 5 2 3 3 1 5 0**


------------


```cpp

 *    *
 *    *
 * ** *
 **** *
 ******
********
05233150
```

显而易见的两个低洼地，但是让我们瞅瞅输出：


------------


**1**


------------


~~哦，我的天啊，看看这个输出，
居然是一个“1”，这简直是上帝的不耻，耶稣的羞愧啊！！！~~


怎么会是“1”，**哪里出了问题**。

首先，我们想想上面代码的**原理**

**波谷数 = 山峰数-1**

很明显，原理是没毛病的，那就可能是**实现**出了问题

思前向后，卡了223秒。

**在统计山峰的时候，有部分譬如2331的平台山峰没有统计到**

废话不多说，直接上代码

```cpp
#include<iostream>
#include<string>
using namespace std;
int nu[10521];
int main(void){
	int n,i,p,ans = -1;
	cin>>n;
	for(i=0;i<n;i++){
		cin>>p;
		if(i&&p==nu[i-1]){i--;n--;continue;}
		nu[i] = p;
	}/*输入时，删掉前后高度相同的，合并为一个山峰*/
	for(i=1;i<n-1;i++)
		if(nu[i-1]<nu[i]&&nu[i]>nu[i+1])ans++;
	cout<<ans;
	return 0;
}
```

蒟蒻第二篇题解


---

## 作者：北北北北 (赞：21)

这个题需要注意连续凹槽的情况，连续凹槽就是2,0,0,2 2,0,0,0,2 

这样的凹槽，注意，在连续凹槽里可能会存在这样的一种情况就是

8,7,7,4这样的情况，即假连续凹槽，而这种情况在你没

考虑到的话，会导致第5点过不去QWQ。

PS：2,0,0,2  2,0,0,0,2属于真连续凹槽



------------
```c
#include <stdio.h>

int main(void)
{
	int h[10000];
	int i,n;
	int count = 0;
	
	scanf("%d", &n);
	for(i = 0; i < n; i++)
	{
		scanf("%d", &h[i]);
	}
	for(i = 1; i < n-1; i++)
	{
		if(h[i-1] > h[i] && h[i+1] > h[i]) //单凹槽 
		{
			count++; 
		}
		if(h[i-1] > h[i] && h[i+1] == h[i]) //可能是连续凹槽 
		{
			while(h[i] <= h[i+1])
			{
				i++;
			}
			if(h[i-1] < h[i]) 
			{
				count++;	//是连续凹槽 
			}
		}
	}
	printf("%d", count);
	
	return 0;
} 
```


---

## 作者：灬Amiya灬 (赞：20)

我的想法很单纯
判断是否为低谷，，，，看最后一个就行了，，，管你前面是平的.....反正只要看最后那个点，他左边的点是否大于等于他，自身是否小于后面那个点就可以了。。。。哪有那么多花里胡俏的 
![](https://cdn.luogu.com.cn/upload/pic/44043.png)


```java
package p1317;

import java.util.Scanner;

public class Main {
	static int result=0;
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		Scanner in = new Scanner(System.in);
		int n;
		n = in.nextInt();
		int a[] = new int[n];
		for(int i=0;i<n;i++) {
			a[i]=in.nextInt();
		}
		for(int i=1;i<n-1;i++) {
			if(a[i-1]>=a[i]&&a[i]<a[i+1])result++;
		}
		System.out.println(result);
	}

}

```

---

## 作者：Right (赞：12)

看到楼下的代码都长而又浪费空间，不禁感慨万分

其实这道题有点动态规划的思想

当前是否是低洼地只跟前两项有关

上凸与直线均不能形成

```cpp
#include <cstdio>
int T,x,y,f,ans;
int main()
{
    scanf("%d%d%d",&T,&x,&y); T-=2; x>y?f=1:f=0;
    while (T--){
        x=y; scanf("%d",&y);
        if (x>y && !f) f=1; if (x<y && f) ans++,f=0;
    }
    printf("%d",ans);
}
```

---

## 作者：bjb050214 (赞：10)

在看到这道题后二话不说就写了个代码，感觉自己傻得实在是太纯粹了。
```cpp
#include<iostream>
using namespace std;
int n;//数量 
int a[10002];//储存高度 
int b[10002];//标记 
bool p(int x) {
	int m;
	if(b[x]==1)//被标记过的点不找 
	return false;
	if(x+1>n)//超过洼地数量的不找 
		return false;
	if(a[x-1]<a[x])//后面比前面高就返回假 
		return  false;
	if(a[x-1]>a[x]&&a[x+1]>a[x])//比前后矮返回真 
		return true;
	if(a[x-1]>a[x]&&a[x+1]==a[x])
	{
		m=x;
		for(int i=x;i<=n-1;i++){//处理相邻点 
			if(a[i]!=a[i+1]){
				if(a[i]<a[i+1]){
				for(int j=x;j<=i;j++)
				b[j]=1;
				//因为在处理相邻时会涉及到多个点的洼地，标记所有找过的点 
				return true;	
				}
			}
		} 
	}
	return false;
}
int main() {
	cin>>n;
	int maxn=0;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
	}
	for(int i=2; i<=n; i++) {
		if(p(i)==true){
			maxn++;
		}
	}
	cout<<maxn;
	return 0;
}
```
好的，愉快的写完后发现有另一种简单的方法，不需要处理相邻点相同的情况：
```cpp
#include<iostream>
using namespace std;
int n;//数量 
int a[10002];//储存高度 
bool p(int x) {
	if(x+1>n)//超过洼地数量的不找 
		return false;
	if(a[x-1]<a[x])//后面比前面高就返回假 
		return  false;
	if(a[x-1]>a[x]&&a[x+1]>a[x])//比前后矮返回真 
		return true;
}
int main() {
	cin>>n;
	int maxn=0;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		if(a[i]==a[i-1]){
			i--;n--;//去除相邻重复点 
		} 
	}
	for(int i=2; i<=n; i++) {
		if(p(i)==true){
			maxn++;
		}
	}
	cout<<maxn;
	return 0;
}
```

---

## 作者：MercyBO (赞：6)

这题比较关键的点就是去重了吧.
去完重之后每三个连续的数,若中间的小于两边的,便记为一个低洼~
```c
#include <stdio.h>
int main()
{
	int a, b, c, d, i, n;
	scanf("%d", &n);
	scanf("%d %d %d", &a, &b, &c);/*储存连续的三个数*/
	for(i=0;n>3;n--)
	{
		a = b;
		b = c;
		scanf("%d", &c);
		while(b == c)
		{
			scanf("%d", &c);
			n--;
		}//去重
		if(a>b&&b<c)i++;//计数
	}
	printf("%d", i);
	return 0;
}
```

---

## 作者：fssdqxx (赞：5)

发一篇题解：

1、洼地很好判断，两端高，中间低；

2、麻烦的是是有高度相同的点，但高度相同的一个平台，如果两边都比该平台高，也只算一个洼地，所以：**去重**；

3、**关键是去重**，利用一个新的数组，把相邻的、高度相同的点去掉，然后就轻松判断

```
#include<bits/stdc++.h>
using namespace std;
int a[100005],b[10005];
int main(){
	int n,ans=0; // ans:洼地个数 
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	int cnt=1; // cnt: 计数，统计去掉相邻的、高度相同的点后 有多少个点 
	b[1]=a[1];
	for(int i=2;i<=n;i++){
		if(a[i]!=a[i-1]){
			cnt++;
			b[cnt]=a[i];
		}
	}
	//去重后就可以轻松判断：每个点与它两边相邻的点都不一样高 
	for(int i=2;i<=cnt-1;i++){
		if(b[i]<b[i-1]&& b[i]<b[i+1]) ans++;
	}	
	cout<<ans;

	return 0;
}

```


---

## 作者：郑yz (赞：5)

# ~~这真是个大大地难（水）题~~
### 方法很简单，就是简单的模拟，关键就是看你知不知道怎么模拟
###  注解详情看代码



------------


## **特别注意：如果有连续2及以上个下坡（连续2个及以上各数呈递减关系），那么这就只算一个低洼，所以要设置一个布尔变量wa（Oier最怕的东西）**



------------

```cpp
#include <bits/stdc++.h>//头文件不说
using namespace std;
int n,total,a[10005];
//n看标题，total储存低洼总数
bool wa=false;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	  cin>>a[i];
	for(int i=2;i<=n;i++){
		if(a[i]<a[i-1])wa=true;//wa为真，即表示递减
		if(a[i]>a[i-1] && wa==true){
			wa=false;//wa为假，即递减数列结束
			total++;//总数加1
		}
	}
	cout<<total<<endl;
	return 0;
}//完美结束

//巨硬制造，惠及全球

```




---

## 作者：PC_DOS (赞：5)

事实上，只需要明白低洼地是如何形成的，就可以理清思路了:

最简单的低洼地:

5 2 4
最简单的情况，就是两边都比中间高，那么判断代码非常好写:

```cpp
if (arrHeight[i] < arrHeight[i + 1] && arrHeight[i] < arrHeight[i - 1]) ++nCount; //只需要arrHeight[i]同时小于arrHeight[i-1]和arrHeight[i+1]，就认为遇到了一个洼地
```
但是还可能存在一种情况:

5 0 0 0 ... 0 2

也就是说在两个"山头"之间有一片连续的低洼地，此时的判断代码应该适当修改:

```cpp
if (arrHeight[i] < arrHeight[i + 1] && arrHeight[i] <= arrHeight[i - 1]) ++nCount; //因为我们是从左往右读的，所以只需要在遇到一个"下坡"时给低洼地个数加一即可。判断条件也可以改成(arrHeight[i] < arrHeight[i + 1] && arrHeight[i] <= arrHeight[i - 1])，也就是只在遇到"上坡"的时候计数
```
由于第一种情况只是第二种的特例，所以得到了程序代码:

```cpp
#include <iostream> //输入输出库
#include <algorithm> //算法库，不过似乎这里用不上
#include <vector> //动态数组库
using namespace std; //标准命名空间
int main(){ //主程序
    ios::sync_with_stdio(false); //关闭CIN等与STDIO的默认同步关系，节约时间
    vector<int> arrHeight; //定义整型动态数组，存储每个点的高度
    int nCount=0, nItem, i,tmp; //nCount-低洼地计数；nItem-用户输入，表示总点数；i-循环计数器；tmp-向arrHeight输入时的临时变量；
    cin >> nItem; //输入总点数
    for (i = 0; i <= nItem - 1; ++i){ //循环，依次读入每个点的高度
        cin >> tmp; //输入到暂存变量
        arrHeight.push_back(tmp); //将暂存变量的数值写入动态数组
    }
    for (i = 1; i <= nItem - 2;++i){ //从左往右依次判断，其中首项arrHeight[0]和末项arrHeight[nItem-1]不需要判断
        if (arrHeight[i] < arrHeight[i + 1] && arrHeight[i] <= arrHeight[i - 1]) ++nCount; //因为我们是从左往右读的，所以只需要在遇到一个"下坡"时给低洼地个数加一即可。判断条件也可以改成(arrHeight[i] < arrHeight[i + 1] && arrHeight[i] <= arrHeight[i - 1])，也就是只在遇到"上坡"的时候计数
    }
    cout << nCount; //输出结果
    return 0; //结束
}
```

---

## 作者：eegg (赞：4)

	#include<cstdio>
	using namespace std;
	int a[10005];
	int main()
	{
		int s=0,i,n,j;
		scanf("%d",&n);
		for(i=0;i<n;i++)
			scanf("%d",&a[i]);
		for(i=1;i<n-1;i++)
		{
			if(a[i]<a[i-1])//发现一个坑
			{
				for(j=i+1;j<n-1;j++)
					if(a[j]>a[i])
					{
						s++;//加起来
						break;
					}
					else
						if(a[j]<a[i])
							break;
			}
		}
		printf("%d",s);
		return 0;
	}

---

## 作者：tosania (赞：3)

~~我又来水红题了。。。~~

一开始看到这道题，以为扫一遍就可以轻松过了，但是写完代码交一发才发现还有平地这种神奇的东西，然后加上这个（不知道为什么我死都不肯判重），还是WA了一个点。。。所以乖乖去打判重，这个故事告诉我们，不要偷懒，红题也是很难的（确信）。


-----------
如何判断一个点是否会积水呢？我们暂且假设这个点左右两个点和这个点高度不相同，那么只要满足这个点左右两个点的高度都大于这个点就可以了，但是这么做考虑不到平地的问题，但是我们发现，一个积水的盆地才满足刚才那个条件，于是我们就加一句代码，使任意一个点的左右两点都和该点高度不同，详见代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,n,a[100001],aa,cnt;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>aa;
		if(aa!=a[cnt]) //判重
		a[++cnt]=aa;
	}
	for(int i=2;i<cnt;i++)
	{
		if(a[i]<a[i-1]&&a[i]<a[i+1])
		ans++;
	}
	cout<<ans;
 } 
```


---

## 作者：JimmyF (赞：3)


~~哈哈，小学生又来发题解啦！~~
那话不多说，让我们进入正题吧！

我们想：水坑的形成必须是由两个坡度组成，左边的坡度是递降的，右边的坡度是递升的。

当当当当！所以这题的思路就出来了，我们只需要判断左边的坡度是否形成，然后当右边坡度形成时，左边也有坡度形成，那就将ans++，最后输出ans。

那话不多说，上代码。

    #include<iostream> //文件头
    using namespace std;
    int a[10010];
    int n,p,ans,t=2;   //定义，a[]是存高度的数组，p判断左边坡度是否形成，ans表示低洼地的个数，t是a数组的下标
    int main()
    {
        cin>>n;        
        for(int i=1; i<=n; i++)
        cin>>a[i];     //读入n个高度
        while(t<n)     //当没有处理完
        {
            while(a[t]>a[t+1])t++,p=1; //左边坡度形成，将标记设为1
            while(a[t]<a[t+1]){t++;if(p)ans++,p=0;}  //右边坡度形成时并判断左边坡度是否形成，是的话ans++
            while(a[t]==a[t+1])t++;  //没有坡度形成
        }
        cout<<ans;     //输出低洼地数
        return 0;
    }
    
希望我的解题思路能够帮助各位

---

## 作者：Cross_X (赞：2)

# 皮，就要皮出天际！
### 思路：
1. 把所有的低洼地和山峰全缩成一格（也就是去重）。
2. 因低洼地只有一格，所以只要比较两边是否都大于此地，就能知道此地是否是低洼地。如果是，那么此地必定是低洼地。

### 重点：
1. 为了不TLE，去重、循环都要皮！
2. 第1个和倒数第1个保证是0；
```
#include <bits/stdc++.h>
using namespace std;
int n,a[1000086],ans,kl;
int main()
{
    cin>>n;
    a[0]=-1;a[n+1]=-1;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]==a[i-1]){i--;n--;}//没错这是去重。如果重复了，总个数直接减。
    }
    for(int i=3;i<=n-2;i++)//第1、2和倒数第1、2个绝对不是低洼地。
    {
        if(a[i]<a[i-1]&&a[i]<a[i+1])ans++;
    }
    cout<<ans;
    return 0;
}
```
第一篇题解，不喜勿喷。QWQ

---

## 作者：_ZZH (赞：2)

我们考虑一段地平线是递增的，那么如果它突然变低，若之后不会到头，那么一定就有洼地。
所以可以将后面递减的部分舍去，从头开始找，记录地平线高度的增减情况统计答案。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int total,judge=-1,n;
int a[10010],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	while(n&&a[n-1]>=a[n])n--;//删去后面递减的部分。 
	for(int i=2;i<=n;i++)
	{
		if(judge==-1)//表示开始的增长趋势。 
		{
			if(a[i]>a[i-1])
			judge=1;
			else
			{
				judge=0;
				ans++;	
			}
			continue;
		}
		if(a[i]<a[i-1]&&judge)//突然下降 
		{
			ans++;
			judge=0;
		}
		if(a[i]>a[i-1])//持续上升 
		judge=1;
	}
	
	cout<<ans;
}
```

---

## 作者：Autracker (赞：2)

```cpp
#include<iostream>//开始；
using namespace std;
int main()
{
    int a[10001],s=0,i,n;
    bool t=0;//定个变量来判断；
    cin>>n;//输入有多少个洼地；
    for(i=1;i<=n;i++) cin>>a[i];//输入洼地的高度；
    for(i=1;i<=n;i++)//1到n进行判断；
    {
        if(a[i]<a[i-1]) t=1;//判断出第一个坡；
        if((t==1)&&(a[i]>a[i-1]))//如果有第一个坡，就判断第二个坡；
        {
            s++;//如果有s++，计数；
            t=0;//重新判断；
        }
    }
    cout<<s;//输出有多少个洼地；
    return 0;//结束；
}
//拜拜；
```

---

## 作者：stone1012 (赞：2)

简单c++


分析题意，WA地由下坡·上坡组成，所以可以在下坡出现时开始寻找，直到上坡结束

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],ans;
int main()
{
    int i,j,k,n,m;
    int t=0;
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]<a[i-1])//下坡判断
            t=1;//标记
        if(t&&a[i]>a[i-1]){//出现下坡
            ans++;//计数
            t=0;//寻找结束
        }
    }
    cout<<ans;
        return 0;
}'''

---

## 作者：PTC06 (赞：2)

看到没有很多C++题解，就来发一个。

思路很简单，直接模拟即可。首先，循环。对于第i个高度，需要做的就是判断它的前一个高度是否大于它自己（形成低洼地的一个条件），然后需要判断这个高度后面有没有比它高的（形成低洼地的第二个条件）。

需要注意的是，（这题的讨论中也有人提到）如果有这样的数据：

8
0 10 9 2 2 9 11 0

那么应该输出1.

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,i,j,sum,a[10000];
bool cmp(int x)
{
    if (a[x-1]>a[x]) return true;      //判断a[i-1]是否大于a[i]（是否满足第一个条件）
    return false;
}
int main()
{
    cin>>n;                  //输入
    for (i=1;i<=n;i++) cin>>a[i];     //输入
    for (i=2;i<=n-1;i++)
    {
        if (cmp(i))           //如果a[i-1]>a[i]
        {
            for (j=i+1;j<=n;j++)              //从i+1开始循环，循环到n
            {
                if (a[j]>a[i]) {sum++; break;} else            //如果a[j]大于a[i]（满足第二个条件）就增加sum并结束循环。
                if (a[j]<a[i]) break;                                  //这里就可以防止在刚才提到的那种特殊样例上出错了。这样子写，如果有一个小低洼地在一个大低洼地里面，就只会判断小低洼地了。
            }
        }
    }
    cout<<sum;        //输出
}
```

---

## 作者：皮皮虾letusgo (赞：2)

不多说，具体看代码内部注释。

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <iomanip>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <stack>
#include <queue>//超长头文件
using namespace std;
int main ()
{
    int n;
    cin>>n;
    int a[n+1];//定义数组
    for (int i=1;i<=n;i++)
    cin>>a[i];
    int ans=0;//计数
    for (int i=2;i<n;i++)
    {
        bool ok=0;//布尔变量
        if (a[i]<a[i-1])//如果小于前一个
        while (a[i]==a[i+1]) {ok=1;i++;}//如果与后一个相等，i++，布尔变量设为1
        if (a[i]<a[i+1] && ok) ans++;  //如果小于后一个且布尔变量为1，计数+1
        if ((a[i]<a[i-1] && a[i]<a[i+1])) ans++;//普通情况
    }
    cout<<ans<<endl;//输出
    while (1);
    return 0;
}
```
结束。
O(∩\_∩)O


---

## 作者：hyoi_ctime (赞：2)

设一个整数x，x=1就表示是所处位置为峰，x=0就表示所处位置为谷；先设x=1；为什么呢，因为第1个点是0；所以第2个是一定不会比第一个低的，所以从第一个比a[1]高的点找起。如果x是1，那么如果下一个比这个高，那么x还是1；如果比这个低了那么x=0；开始向下找比x=0这个位置高的点，一直找下去。每从谷找到一个峰ans++；注意下面代码的if(i!=1)//其实就是懒的改。

如果x=1


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=10000+10;
int n,ans;
int a[maxn];
inline void read()
{
    int x=1;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if(i!=1)//第一个肯定是最低的，而且左边没有点，所以形不成洼地，所以从第二个开始找，这也是x赋值为1的原因
        {
            if(x==0&&a[i]>a[i-1])ans++,x=1;
            if(x==1&&a[i]<a[i-1])x=0;
        }
    }
    printf("%d",ans);
}
int main()
{
    read();
    return 0;
}
```

---

## 作者：empty_zhm (赞：1)

## 我看你们都在存状态或者用数组存数据，我觉得没必要就重新打了下
~~审核我没看完，如果打扰了就对不起了~~
### 首先，我们分析一下，水~~WA~~洼是指在下坡和上坡之间有一个点或一条等高的线。
**分析一下：如果一个点在处于下坡中(后)，则它所在的点就会比前一个点小。同理，上坡时，此点就会比后一个点小。在等高的线时，与前一个或后一个点相等就是了**
### 那么问题来了，怎么判定它在一条等高直线上呢？
**The answer is： 咱们不管它，只需要搞特殊就行了。怎么个搞特殊？那就是，我们只需要判断直线上最后一个点为水洼就可以了**（也就是底下b<=a中'='的用处）

**那么如何判断一个数是否处在低洼线的最后一点呢（低洼点我就讲了），因为它是处于低洼线（一个等高线中），它一定与前一个点高度相等，由于是最后一点，所以它一定低于它后面的一个点所以就有了底下 a==b&&b<c 的情况判定**
### 那这就很明显了，我们只需要存储3个数据就可以进行判定它是否处于低洼线的最后一点或低洼点了（也就是可以把空间复杂度降至O(1)了。
# 代码sama登场！
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
int main()
{
	int n,a,b,c;
	cin >> n;
	cin >> a >> b >> c;//没有数组就得优先处理（有点麻烦但是为了空间复杂度QWQ）
	for(int i=1;i<=n-3;i++)//n-3是因为你已经输入了3个数据，再多就会出错了
	{
		if(b<=a&&b<c)//当b处于低洼点或低洼线（就是低洼处构成的点与线）的最后一个点时
        ans++;//因为只用判断最后一个点，所以c=b时绝对不可以累加，不然一整条低洼线都会累加上。
		a=b;//数据后移1个
		b=c;
		cin >> c;
	}
	cout << ans;
    //其实return 0只是习惯问题……
}

```


---

## 作者：北文 (赞：1)

水题，没什么话可说
如果要积水，那就要找到波谷，也就是

a[i-1]>a[i]<a[i+1]

那么i这个位置就会积水

所以这道题转换为：

求一个“山”有多少个“波谷”

还有一个问题，如果他是平的怎么办，很简单，平的看做没有，把平的一段剪掉。

完事，上代码

```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n,ans=0; 
	cin>>n;
	int x,y,z,i=1;
	cin>>x>>y;
	while(y==x){cin>>y;i++;}
	for(i=i+1;i<n;i++)
	{
		cin>>z;
		if(z==y)continue ;
		if(x>y&&y<z)ans++;
		x=y;y=z;
	}
	cout<<ans;
	return 0;
}
```


~~楼下的人，你们试试4 0 0 1 0你会直接崩溃~~



---

## 作者：anotherrainyday (赞：1)

又随随便便A了一道~~红~~题

这道题我一开始想的是开数组 后来越写越不对劲 然后才发现**完全不用开数组**

基本想法就是保存最近三个(平地不保存) 输入一次判断一次 如果三个构成了低洼地 那就Count++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, Count = 0, rem[3] = {0, 0, 0};//rem是最近三个点三个(平地忽略不计)
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int tmp;//临时变量
        cin >> tmp;//输入
        if (tmp != rem[2])//处理平地 如果是平地就直接continue
        {
            rem[0] = rem[1];//整体往前提一位
            rem[1] = rem[2];
            rem[2] = tmp;//最后一位赋成刚刚输入的
        }
        else
            continue;//为什么要continue呢？ 如果这里不直接continue 那么遇到一个坑接着平地就会算作是一个新的坑
        if (rem[0] > rem[1] && rem[1] < rem[2])//很好理解 如果这是个坑
            Count++;//计数+1
    }
    cout << Count;
    return 0;
}

```

**珍爱生命 请勿抄袭**

啊哈哈又~~水~~了一篇题解

---

## 作者：洛谷亿亿岁 (赞：1)

这道题不难，考的是细心程度，加油233

就3个if的事
```
#include<bits/stdc++.h>
using namespace std;
int n,a[10000],ans=0,p=0;//p用来判断,n用来统计有多少个地，ans是答案
int main(){
	cin>>n;
	for(int i=0;i<n;i++)
	cin>>a[i];//先全部输入
	for(int i=0;i<n-1;i++){//n-1是为了防止不越界
		if(p==1&&a[i+1]>a[i]){//如果有个低洼地的尾并且也有头，就是一个完整的低洼地
			ans++;
			p=0;//方便找下个头
			continue;//走入下一个循环
		}
		if(p==1&&a[i+1]<=a[i])//如果后面比前面的还小并且有个低洼地的头，那后面也是低洼地的一部分，
		continue;//那就走下一次
		if(a[i]>a[i+1])//如果有个低洼地的头,判断=1
		p=1;
	}
	cout<<ans;//输出答案
}
```


---

## 作者：御坂13558号 (赞：1)

# 先回顾一下题：
## 题目描述

一组数，分别表示地平线的高度变化。高度值为整数，相邻高度用直线连接。找出并统计有多少个可能积水的低洼地？

如图：地高变化为 0 1 0 2 1 2 0 0 2 0
## 输入输出格式

输入格式：
两行，第一行n,表示有n个数。第2行连续n个数表示地平线高度变化的数据，保证首尾为0。(3<=n<=10000,0<=高度<=1000)

输出格式：
一个数，可能积水低洼地的数目。

# 本题共有四种解决方案，以下一一列举
## 1. 直接跑一遍
方法很简单，并且楼下许许多多dalao都介绍了，在此就不出代码了，思路就是如果一个节点左边右边都比它高，数量加1
## 2. 离散化
我们可以这样想：把连续大上（or下）坡看作一个，用离散化的思想简化成一个true－false串，用vector保存
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int n,ans;
vector<bool> b;
int main(){
    cin>>n;
    int a[n+1]={0};
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n-1;i++){
        if(a[i]<a[i+1]&&a[i+1]<a[i+2])continue;
        else if(a[i]>a[i+1]&&a[i+1]>a[i+2])continue;
        else if(a[i]<a[i+1])b.push_back(true);
        else if(a[i]>a[i+1])b.push_back(false);
        else continue;
    }
    for(long unsigned int i=0;i<b.size()-1;i++)
        if(b[i]==false&&b[i+1]==true) ans++;
    cout<<ans;
    return 0;
}
```
接下来对10～14行的代码进行一些解释：

1. 连续上坡：直接跳过，连续上坡可以分成单个上坡，所以连续上坡结束时一定会压入一个true
2. 连续下坡：理由同上
3. 单个上坡：直接压入一个true
4. 单个下坡：直接压入一个false
5. 平地：根据离散化思想，直接跳过即可

## 3. 对方法二的改进
首先，我们再次回顾一下题

注意输入格式和方法二的解释

###  _首尾为0_ —> vector里第一个是true，最后是false
###  _true－false串_ —> true和false交替出现
### 总结到一起又可以得出：串的数量为偶数个
我们知道了这么多信息，我们就想问：有没有可能用数学公式呢？

列张表：

| 长度 |  数量|
| :----------- | :----------- |
| 2 | 0 |
| 4 | 1 |
| 6 | 2 |
| 8 | 3 |
| 10 | 4 |
| 12 | 5 |
| 14 | 6 |
| 16 | 7 |
| 18 | 8 |
| 20 | 9 |
到这个份儿上都看不出公式的我也是服了

公式：**数量＝长度/2-1**;

代码如下：
```cpp  
#include <bits/stdc++.h>//万能头
using namespace std;
int n;
int len;//长度
int main(){
    cin>>n;
    int a[n+1]={0};
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n-1;i++){
        if(a[i]<a[i+1]&&a[i+1]<a[i+2])continue;
        else if(a[i]>a[i+1]&&a[i+1]>a[i+2])continue;
        else if(a[i]<a[i+1])len++;
        else if(a[i]>a[i+1])len++;
        else continue;
    }
    cout<<len/2-1;
    return 0;
}
```
## 对方法1的改进：
方法一说起来简单，实际却有很多坑点，比如要去重什么的

可是，我们把`左右两半比它高`这个条件换一下，变成`左面比他高，右面高或相等`，不就完美了吗？

代码因为太简单就不列了

注：数组要开大一位，数存在0~n-1，n里存1(这里要注意一下，初始化要把最后一个初始化为1！)。循环时从1开始，到n-1结束

---

## 作者：一座城·守一人 (赞：1)

# STL大法好
### $STL$里头有去重函数

```
unique(ForwardIterator first, ForwardIterator last);
```
### 包含在头文件$algorithm$中

**这个函数的声明什么意思呢？**


首先，你要是想去除重复元素，就要指定一个数组，这里的`ForwardIterator first`就是需要你给他一个数组，把希望去重的数组的名字(这里用的不太恰当)给了它，就可以了。

`ForwardIterator last`是想要你告诉这个函数，你的去重截止到数组的哪个位置，具体的把下标给它。

其实它是一个伪去重，最后会把所有的元素都堆叠在数组的后面。
 
最后返回的值是去重以后的最后一个不重复元素的位置(地址)。


最后不重复的元素的数量是
```cpp
unique(n+1,n+m+1)-&n[1];
//n存储的是各个点的坐标，m是点的数量。
```
注意的是这里的一个`-&n[1]`  由于我们是从n[1]开始进行$unique$操作的，所以说最后返回的地址是去重以后的第一个重复的数的地址加上一个`int`型的大小，最后减去n[1]得到的才是去重以后的不重复的元素个数。
刚才下面一个同学问的很好，
```
与其-&n[1] 为什么不-n-1呢
```
关于这个问题的回答，我想说的是：

这样思路清晰。

~~我不会告诉你们我这么做的真实理由是因为这样子显得我是巨老~~

去重完之后我们就可以开始查找，有几处低洼地

只要数组的某一个数低于左右两个数，那么低洼地的`sum++;`

不难，很好理解。

最后代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n[10005];
int main(){
	int m,rp=0;
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>n[i];
	}
	m=unique(n+1,n+m+1)-&n[1];//去重
	for(int i=2;i<m;i++){
		if(n[i]<n[i-1]&&n[i]<n[i+1])rp++;
	}
	cout<<rp;
	return O;
}
```

代码很短，祝大家都可以AC(当然按照本人的习惯该代码直接交上去会$RE$10个点)

---

## 作者：太叔寒云 (赞：1)

最长波动序列。

f[i]表示以i为山峰的最长序列。

g[i]表示以i为山谷的最长序列。
```
#include<iostream>
#include<cstdio>
#define zxf(i,j,a,b) for(register int i=(a);(j)<=(b);i++)
#define wxr(i,j,a,b) for(register int i=(a);(j)>=(b);i--)
using namespace std;
const int N=1e4+5;
int a[N],f[N],g[N];
template<typename T>
inline void read(T &x)
{
	bool f=1;x=0;char c=getchar();
	while(!isdigit(c)) {if(c=='-') f=0;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	x=f?x:-x;
}
signed main()
{
	int n;
	read(n);
	if(n<3) puts("0");
	else
	{
		zxf(i,i,1,n) read(a[i]);
		if(n==3)
		{
			if(a[1]>a[2]&&a[2]<a[3]) puts("1");
			else puts("0");
		}
		else
		{
			int l=1,r=n;
			while(a[l]<a[l+1]) l++;
			while(a[r]<a[r-1]) r--;
			zxf(i,i,l,r)
			{
				f[i]=a[i]>a[i-1]?g[i-1]+1:f[i-1];
				g[i]=a[i]<a[i-1]?f[i-1]+1:g[i-1];
			}
			f[r]=f[r]>g[r]?f[r]:g[r];
			printf("%d",f[r]>>1);
		}
	}
	return 0;
}
```
//潇帆姐姐美如画

---

## 作者：张皓涵 (赞：1)

这题有一个坑：如果有平地，就不能单单判断左右了，但这样搜索我觉得会比较麻烦，所以平地的地方我都把它化为一个点，就只要判断是否左右的点都比它高即可，比较方便些，看代码吧：
	
    
    
    #include<iostream>
	using namespace std;
	int a[10001],b[10001],n,ans,x=1,i2=1; //b数组用来储存转化后的，i2用来存转化后的有几个点
	int main()
	{
		cin>>n;
		for (int i=1;i<=n;i++)
			cin>>a[i];   //输入
		for (int i=1;i<=n;i++)
			if (a[i]!=x) {x=a[i]; b[i2]=a[i]; i2++;} 
            //因为我们的x定义的是1，保证了a[1]！=x，后面就没有特殊情况了，（用x储存前一个，若此个与前一个不相同，则有效，否则不管他）
		for (int i=2;i<i2;i++)
			if (b[i]<b[i-1]&&b[i]<b[i+1]) ans++; 
            //判断，由于经过我们的转化，已经没有平地了，这样就只需要判断前一个与后一个，### 注意：是从2到i2-1，因为如果是从1到i2会越界，因为要与前面和后面判断，1没有前面，i2没有后面
		cout<<ans; //输出
	}

---

## 作者：even (赞：1)

看到大佬各种解法，感觉这题没那么麻烦。

让我们换个角度思考，只要理解怎样才会形成低洼，本题就很简单了。

观察给出的图，不难得出，只有当一个点同时高于两个点时，才有可能形成低洼

因此，我们只需要统计符合上述条件的点的数量就行了，判断条件即为：(a[i]>a[i-1])and(a[i]>a[i+1])

但考虑到有可会有两点一样高且这两点高于旁边两点，这样也会形成低洼

所以条件应该为：((a[i]>=a[i-1])and(a[i]>a[i+1]) )or((a[i]>a[i-1])and(a[i]>a[i+1]))

代码如下：

```cpp
var
  i,j,l,k,n,m:longint;
  a:array[0..1001] of longint;//防止a[i-1]和a[i+1]溢出
begin
  read(n);
  for i:=1 to n do
    read(a[i]);
  m:=0;//m统计符合条件的点的个数
  for i:=1 to n do
    if ((a[i]>a[i-1])and(a[i]>=a[i+1]))or((a[i]>a[i-1])and(a[i]>=a[i+1])) then  inc(m);//判断
  writeln(m-1);
end.

```

---

## 作者：WayneStewart (赞：1)

楼下dalao们写得好麻烦，其实设三个变量模拟就好了

b是当前点，a是b的前一个点，c是b的后一个点。

洼地有两种：1、高低高（a > b < c）2、高低平平低高。

当a b c从左向右走时，第一种好判断，第二种洼地的左端会有高低平（a > b = c），这时说明将要进入平台了，用platform标记一下。什么时候走出平台呢？当存在平低高（a = b < c）时，计数器加1，平台结束，platform再变为false。


···cpp



    

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdio>
using namespace std;
const int N = 10002;
int h[N]; 
int n;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; ++i)
        cin >> h[i];
    int cnt = 0; bool platform = false;
    for (int i = 2; i <= n; ++i) {
        int &a = h[i - 1], &b = h[i], &c = h[i + 1];
        if (a > b && b < c) ++cnt;
        if (a > b && b == c) platform = true;
        if (a == b && b < c && platform)
        { ++cnt; platform = false; }
    }
    cout << cnt << endl;
    return 0;
}
···
```

---

## 作者：撩妹凛酱 (赞：1)

这道题呢，我们可以直接寻找制高处（高于两边）的个数，在n个制高处中就可以形成n-1个洼地。需要注意的地方是初始化和制高处高度连续相等的情况（如2 2 0 2 2）









```cpp
    program tpyldiwadi;
var
  a:array[0..10001] of longint;
  n,i,j,now,num:longint;
begin
  readln(n);
  num:=0;
  a[0]:=-1511747; //这是避免第一个和第n个点是制高处时出问题
  a[n+1]:=-1511747;
  for i:=1 to n do
   read(a[i]);
  for i:=1 to n do
   if a[i]>a[i-1] then begin//假如此处比前面高就判断它是否比后面高
     j:=i;
     while a[j]=a[i] do begin//判断要包括高度相等的情况
       inc(j); 
       if a[j]>a[i] then break;//假如比后面矮，退出
       if a[j]<a[i] then begin//比后面高，累加
         inc(num);
         break;
       end;
     end;
   end;
  writeln(num-1);
end.
```

---

## 作者：xuan__xuan (赞：1)

其实本题还可以这样做，因为我们要寻找一个高低高的序列，那我们可以这样

开始时找到第一个下降的，然后去找上升的，但是不是上升的都能找到啊，所以我们可以记录高低变换的次数，

直接输出 Ans / 2即可；


```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 100001;
int data[MAXN];
int N,F = 0,Ans = 0;
int main(){
    scanf("%d",&N);
    for(int i = 1; i <= N; i++)
        scanf("%d",&data[i]);
    for(int i = 2; i <= N; i++)
    {
        if(F == 0)
        {
            if(data[i] >= data[i-1])
               continue;
            if(data[i] < data[i-1])
            {
                F = 1;
                Ans++;
            }
        }
        if(F == 1)
        {
            if(data[i] <= data[i-1])
                continue;
            if(data[i] > data[i-1])
            {
                F = 0;
                Ans++;
            }
        }
    }
    cout << Ans/2 << endl;
    return 0;
}
```

---

## 作者：cyr2003 (赞：1)

水题，已无力吐槽。。。

```cpp
var a:array[1..10000] of integer;
      n,i,j,ans:integer;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 for i:=2 to n-1 do
  if (a[i-1]>a[i]) then //只有前一个高于当前的才有可能形成低洼
  for j:=i to n do 
  if a[j]>a[i] then begin inc(ans); break; end//若后面一个高于当前的，就形成了一个低洼，退出
                             else if a[j]<a[i] then break;//若后面一个低于当前的，就不可能形成低洼，退出
 write(ans);
end.
```

---

## 作者：谁懂谁伤心 (赞：1)

此题方法众多，我用的方法是当第i个点大于第i-1个时，且目前有未积水的下降斜坡，得数加一。

```cpp

#include <iostream>  
using namespace std;  
int main()  
{  
int q,s=1,e,f,d=0; cin >>q;  
cin >>e; 
for (int a=2;a<=q;a++)
{cin >>f;if (s==-1&&f>e)d++; if (f>e)s=1; if (e>f)s=-1; e=f;}
cout <<d;  
return 0;  
}  
```

---

## 作者：违规用户名3(kd,e$A (赞：1)

哈喽，大家好，我又来了（虽然你可能不认识我），但我还是要把我的开场白说一说，好啦，言归正传。

今天，我来给大家讲一讲低洼地这道题。

题目的意思是：有多少个低洼地。低洼地是说：这次的地方比前一个和后一个都要低，比如说![](https://cdn.luogu.com.cn/upload/image_hosting/whkgakv8.png))

这个图中标有编号的1，2，3就是低洼地。

再比如说：

![](https://cdn.luogu.com.cn/upload/image_hosting/0d72xsrt.png)

这个图中1，2，3就是低洼地，好的大家都懂了吧，下面我来给大家讲一讲程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10005],b[10005],c,z;
int main()
{
    cin>>n;//输入个数
    for(int i=1;i<=n;i++)
    cin>>a[i];//输入峰值
    for(int i=1;i<=n;i++)
    if(a[i]!=a[i+1])b[++c]=a[i];//判断是否为平地
    for(int i=1;i<=c;i++)
    if(b[i-1]>b[i]&&b[i]<b[i+1])z++;//是低洼地就加加
    cout<<z;//输出个数
    return 0;//结束循环
}
```
过了吧

---


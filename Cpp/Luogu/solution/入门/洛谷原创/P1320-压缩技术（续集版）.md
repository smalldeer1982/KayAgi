# 压缩技术（续集版）

## 题目描述

设某汉字由 $N \times N$ 的 $\texttt 0$ 和 $\texttt 1$ 的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $\texttt 0$，第二个数表示接下来连续有几个 $\texttt 1$，第三个数再接下来连续有几个 $\texttt 0$，第四个数接着连续几个 $\texttt 1$，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： $\texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7}$ （第一个数是 $N$ ,其余各位表示交替表示0和1 的个数，压缩码保证 $N \times N=$ 交替的各位数之和）


## 说明/提示

数据保证，$3\leq N\leq 200$。

## 样例 #1

### 输入

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

### 输出

```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7```

# 题解

## 作者：volatile (赞：14)

# 思路

先读入一行字符串 $b$，容易发现，这一行字符串的长度就是 $N$。接着继续读入字符串


```cpp
while(cin>>a){
    b+=a;
}
```

这一步的目的是将多行字符串拼接为一行。

接下来特判：如果 $b_0$ 也就是字符串的第一位不是 $0$，那么 $0$ 的数量就是 $0$，要先输出。

`if(b[0]!='0') cout<<"0 ";`

然后遍历字符串从 $b_1$ 到 $b_{N^2}$，用变量 $t$（初始为 $1$）记录，如果 $b_i=b_{i-1}$，那么 $t$ 增加，否则输出 $t$，将 $t$ 赋值为 $1$。

循环结束后不要忘记在输出 $t$！

# 代码


```cpp
#include<iostream>
#include<string>
using namespace std;
int n,x,num=0,t=1,ans=0,cnt=1;
string a,b;
int main(){
	cin>>b;
	n=b.size();
	cout<<n<<" ";
    while(cin>>a){
    	b+=a;
	}
    if(b[0]!='0') cout<<"0 ";
	for(int i=1;i<n*n;i++){
		if(b[i]==b[i-1]){
			t++;
		}
		else{
			cout<<t<<" ";
			t=1;
		}
	}
    cout<<t;
    return 0;
}
```

---

## 作者：_ArenaBreakout114514 (赞：4)

## 前言：

又是一道水题，太好了。

## 思路：

首先，这道题和 `p1319` 思路几乎一模一样，不知道的自己去看。于是呢，我们可以将那道题反着来做一下。仔细观察题目，不难发现这道题就是输入一个压缩了以后的图片，然后让我们输出这张图片的边长为几。然后，交替输出 0 和 1 的个数，这道题就结束了。

于是，我们可以使用一个 `while` 循环，来计算边长为多少。然后，再用 $js$ 变量来计算 0 和 1 的数量，而代码中的 $ysm$ 则是判断 $dzt$ 数组中的第 $i$ 行，第 $j$ 个字符为 0 还是 1，是的话，$js$ 就加 1，否则将 $ysm$ 进行更改。

## [My AC Code：](https://www.luogu.com.cn/record/219311729)


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    string dzt[200];
    int n = 0;
    while(cin>>dzt[n]) n++;
    cout<<n<<' ';  
    char ysm='0';
    int js=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(dzt[i][j]==ysm)
                js++;
            else{
                cout<<js<<' ';
                ysm=(ysm=='0')?'1':'0';
                js=1;
            }
        }
    }
    cout<<js;
    return 0;
}
```

每天一题解，红名靠近我。

---

## 作者：libu2333 (赞：2)

## 题解：P1320 压缩技术（续集版）

提供一种更简便的思路。

容易想到，我们可以逐个读入点阵里的字符，如果这个字符与上一个不同就输出上一段连续字符的数量。

至于 $N$ 的计算，我们可以在读入时计算读入字符的数量 `cnt`，因为字符总数是 $N \times N$，所以将 `cnt` 开平方后就是 $N$。

至于答案的输出格式，我们只需要把答案存进一个数组里，先输出 `sqrt(cnt)` 再输出数组里的元素即可。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans[400005]; // ans 数组要开大一些
char a,b='0'; // 注意是先输出 0 的个数
int cnt=0,idx=0; //idx 为 ans 内元素的数量
int main(){
	while(cin>>a){
		cnt++;
		if(a==b){
			ans[idx]++;
			b=a;
		}else{
			ans[++idx]++; // 这一个字符也与前面的不一样 
			b=a;
		}
	}
	cout<<sqrt(cnt)<<' ';
	for(int i=0;i<=idx;i++){
		cout<<ans[i]<<' ';
	}
	return 0;
} 
```

---

## 作者：cse071549 (赞：1)

### 题目大意
从汉字点阵图案的第一行第一个符号开始计算，从左到右，由上至下。第一个数表示连续有几个 $0$，第二个数表示接下来连续有几个 $1$，以此类推……但是同原版不同，它将操作翻了过来，用矩阵推出命令。

### 题目详解
使用 ```while(cin>>x)``` 把矩阵的每个数输入，如果与上一次的不同，就先把当前累积的某个数字数量统计，然后清空，要先特殊处理第一个数。注意：如果你交完后全蛙，请检查你有没有判断第一个字符是 $1$ 的情况！
### 代码示例

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,k[100005],sum;
char a,last,q;
int main(){
	int p=1;
	cin>>a;
	last=a;
	if(a=='1') k[++cnt]=0;
	while(cin>>a){
		if(a!=last){
			sum+=p;
			k[++cnt]=p;
			p=0;
		}
		last=a;
		p++;
	}
	sum+=p;
	k[++cnt]=p;
	cout<<sqrt(sum)<<" ";
	for(int i=1;i<=cnt;i++){
		cout<<k[i]<<" ";
	}
	return 0;
} 
```

---

## 作者：CSP_SAKME (赞：0)

我们先输入为一个矩阵，表示汉字的点阵图案。再遍历矩阵。统计连续 $0$ 和 $1$ 的个数，并依次添加到压缩码中。\
使用一个变量来跟踪当前是统计 $0$ 还是 $1$ 的个数，以及一个计数器来记录连续的个数。\
将计算得到的压缩码以空格分隔的形式输出。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s[400001],p=0;
int main(){
	int p=1;
	char c;
	while(cin >> c){
		s[p++]=c-'0';
	}
	p--;
	int x=1;
	cout << int(sqrt(p)) << " "; 
	int z=0;
	while(x<=p){
		int cnt=0;
		while(s[x]==z&&x<=p){
			cnt++;
			x++;
		}
		cout << cnt << " ";
		z^=1;
	}
	return 0;
}

```

---

## 作者：Ashankamiko (赞：0)

# 题目简述
### 题意
给定一个若干大小的矩阵，按照以下要求输出。
- 每一个数字之间空一格。
- 第一个数字为矩阵大小 $N$。
- 接下来若干个数字，描述这个矩阵有多少个 $0$ 和 $1$ 交替，并输出连续的 $0$ 或 $1$ 的长度。
### 思路
先输入一个字符串，然后定义 $n$ 为该字符串的长度，输出 $n$。

接下来输入 $n-1$ 行，为了便于处理，直接把输入的整个字符串全部加到字符串 $str$ 里。

定义 $cnt$，用于记录相同字符的数量，初值为 $1$。

接下来遍历 $str$，如果 $str_{i-1}$ 等于 $str_i$，令 $cnt \gets cnt+1$，否则输出 $cnt$，并令 $cnt \gets 1$，因为当我们进行下一次判断时，$str_i$ 也要算上。
## [AC 代码](https://www.luogu.com.cn/record/211239350)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout

int main() {
	string x, s = "";
	in >> x;
	s += x;
	for (int i = 1; i < x.size(); i++) { //输入字符串
		string str;
		in >> str;
		s += str; //并把str加到s里
	}
	out << int(x.size()) << ' '; //输出N
	int cnt = 1;
	if (s[0] == '1')
		out << "0 ";
	for (int i = 1; i < s.size(); i++) //遍历s
		if (s[i - 1] != s[i]) { //如果不等
			out << cnt << ' '; //输出cnt
			cnt = 1; //令cnt=1
		} else
			cnt++; //否则+1
	out << cnt; //输出最后的数量
	return 0;
} =
```

---


# 月落乌啼算钱（斐波那契数列）

## 题目背景

（本道题目木有隐藏歌曲……不用猜了……）

《爱与愁的故事第一弹·heartache》最终章。

吃完 pizza，月落乌啼知道超出自己的预算了。为了不在爱与愁大神面前献丑，只好还是硬着头皮去算钱……


## 题目描述

算完钱后，月落乌啼想着：“你坑我！”于是当爱与愁大神问多少钱时，月落乌啼说了一堆乱码。爱与愁大神说：“算了算了，我只问第 $n$ 样菜价格多少？”月落乌啼写出了：

$$F_n=\dfrac{\left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}$$

由于爱与愁大神学过编程，于是就用 $1$ 分钟的时间求出了 $F_n$ 的结果。月落乌啼为此大吃一惊。你能学学爱与愁大神求出 $F_n$ 的值吗？



## 说明/提示

对于所有数据：$0 \leq n\leq 48$。

## 样例 #1

### 输入

```
6```

### 输出

```
8.00```

# 题解

## 作者：封禁用户 (赞：2142)

刚拿到这题，乍眼一看，代数式！！！

于是迅速拿起笔在草稿纸上写起

设a=(1+sqrt(5))/2,b=(1-sqrt(5))/2

原式=(a^n-b^n)/sqrt(5)=(a-b)(a^(n-1)+a^(n-2)*b...b^(n-1))
   
把 a=(1+sqrt(5))/2 , b=(1-sqrt(5))/2 代进式子里
   
惊奇地发现a-b=1
   
再把(a^(n-1)+a^(n-2)*b...b^(n-1))算出来就好了
   
~~正解我不会~~
   
于是开始找规律
   
n=1:原式=1；
   
n=2:原式=1；
   
n=3:原式=2；
   
n=4:原式=3；
   
n=5:原式=5；
   
发现是斐波那契
   
但是问题又来了，怎么证明呢？

f(n-2)为(x-y)/2

f(n-1)为(x*a-y*b)/2

f(n)为（x*a^2-y*b^2）/2

**所以f(n)=(x(6+sqrt(10)/4-y(6-sprt(10)/4)/2=((x-y)+(x(1+sqrt(5))/2-y(1-sqrt(5))/2))/2=(x-y)/2+(x*a-y*b)/2=f(n-2)+f(n-1)**

**证毕**

（观众：你个蒟蒻说那么一大堆废话，快给我滚）

（我：呜呜呜）

所以我就不放代码啦

~~很水的~~

我写得那么辛苦，不点个赞再走吗？？？

(っ•̀ω•́)っ✎⁾⁾ 求通过

---

## 作者：密期望 (赞：532)

upd(2019-05-03):
1. 优化了latex公式，能看得更清楚了
2. 添加了同类题目链接

____

都没人推一下公式怎么来的吗？
这里给出特征方程求解斐波那契的方法：

斐波那契的递推公式为

$a_{n+2}-a_{n+1}-a_{n}=0$

其特征方程为

$x^2-x-1=0$

解得

$x_1=\dfrac{1+\sqrt{5}}{2}$

$x_2=\dfrac{1-\sqrt{5}}{2}$

则原通项公式为

$a_n=A*x1^n+B*x2^n$

带入第一项与第二项求解可得

$A=\dfrac{1}{\sqrt{5}}$

$B=-\dfrac{1}{\sqrt{5}}$

因此

$a_n=\dfrac{(\dfrac{1+\sqrt{5}}{2})^n-(\dfrac{1-\sqrt{5}}{2})^n}{\sqrt{5}}$

与题目给出的公式相同，所以我们就可以愉快地使用线性递推求解了。

代码没什么好讲的，直接复制粘贴（[代码抄这里的](https://www.luogu.org/problemnew/show/P4723)），修修改改赋初值就行了。注意$n=0$时有可能输出$-0.00$，所以我选择了特判。

```
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
namespace mikiwang{
    class complex{
        public:
            long double r,v;
            complex(long double r_=0){r=r_;v=0;}
            complex(long double r_,long double v_){r=r_;v=v_;}
            complex operator+(const complex &c)const{return complex(r+c.r,v+c.v);}
            complex &operator+=(const complex &c){return *this=*this+c;}
            complex operator-(const complex &c)const{return complex(r-c.r,v-c.v);}
            complex &operator-=(const complex &c){return *this=*this-c;}
            complex operator*(const complex &c)const{return complex(r*c.r-v*c.v,v*c.r+r*c.v);}
            complex &operator*=(const complex &c){return *this=*this*c;}
            complex operator/(const complex &c)const
            {long double d=c.r*c.r-c.v*c.r;return complex((r*c.r+v*c.v)/d,(r*c.v+v*c.r)/d);}
            complex operator/=(const complex &c){return *this=*this/c;}
            complex operator-()const{return complex(-r,-v);}
    };
}
namespace mikiwang{
    class polymerization{
        private:
            int len;
            complex*data;
            static void fft(complex*,int,int);
        public:
            polymerization(int=0);
            polymerization(const polymerization&);
            ~polymerization();
            int length()const;
            operator complex*();
            operator const complex*()const;
            polymerization &operator=(const polymerization&);
            polymerization &resize(int);
            polymerization operator-()const;
            polymerization operator+(const polymerization&)const;
            polymerization operator-(const polymerization&)const;
            polymerization operator*(long double)const;
            polymerization operator*(complex)const;
            polymerization operator/(long double)const;
            polymerization operator/(complex)const;
            polymerization operator*(const polymerization&)const;
            polymerization inverse()const;
            polymerization &reverse();
            polymerization operator/(const polymerization&)const;
            polymerization operator%(const polymerization&)const;
    };
}
using mikiwang::polymerization;
polymerization pow(polymerization a,long long n,const polymerization &p){
    polymerization ret;
    ret[0]=1;
    while(n){
        if(n&1)ret=ret*a%p;
        a=a*a%p;
        n>>=1;
    }
    return ret;
}
long double abs(long double x){
    if(x<0){
        return -x;
    }
    return x;
}
int main(){
    polymerization a(1),g(2),r;
    long long n;
    scanf("%lld",&n);
    if(!n){
        printf("0.00\n");
        return 0;
    }
    a[0]=0;
    a[1]=1;
    g[0]=1;
    g[1]=1;
    g[2]=-1;
    r=pow(a,n,g);
    printf("%.2Lf\n",abs(r[1].r));
    return 0;
}
namespace mikiwang{
    using std::max;
    using std::swap;
    polymerization::polymerization(int len_){
        len=len_;
        data=new complex[len+1];
        for(int i=0;i<=len;i++){
            data[i].r=0;
            data[i].v=0;
        }
    }
    polymerization::polymerization(const polymerization &a){
        len=-1;
        data=0;
        *this=a;
    }
    polymerization::~polymerization(){
        len=-1;
        delete data;
    }
    int polymerization::length()const{
        return len;
    }
    polymerization::operator complex*(){
        return data;
    }
    polymerization::operator const complex*()const{
        return data;
    }
    polymerization &polymerization::operator=(const polymerization &a){
        resize(a.len);
        for(int i=0;i<=len;i++)data[i]=a[i];
        return *this;
    }
    polymerization &polymerization::resize(int len_){
        if(len<len_){
            complex*p=new complex[len_+1];
            for(int i=0;i<=len;i++)p[i]=data[i];
            delete data;
            data=p;
        }
        len=len_;
        return *this;
    }
    polymerization polymerization::operator-()const{
        polymerization ret(*this);
        for(int i=0;i<=len;i++)ret[i]=-ret[i];
        return ret;
    }
    polymerization polymerization::operator+(const polymerization &a)const{
        polymerization ret=max(len,a.len);
        for(int i=0;i<=len;i++)ret[i]+=data[i];
        for(int i=0;i<=len;i++)ret[i]+=a[i];
        return ret;
    }
    polymerization polymerization::operator-(const polymerization &a)const{
        polymerization ret=max(len,a.len);
        for(int i=0;i<=len;i++)ret[i]+=data[i];
        for(int i=0;i<=len;i++)ret[i]-=a[i];
        return ret;
    }
    void polymerization::fft(complex *a,int n,int op){
        static const long double PI=acos(-1);
        int *pos=new int[n];
        pos[0]=0;
        for(int i=1;i<n;i++)pos[i]=(pos[i>>1]>>1)|((i&1)*(n>>1));
        for(int i=1;i<n;i++)if(i<pos[i])swap(a[i],a[pos[i]]);
        complex A,B;
        for(int l=1;l<n;l<<=1){
            for(int i=0;i<n;i+=l<<1){
                for(int j=0;j<l;j++){
                    A=a[i+j];
                    B=complex(cos(PI*j/l),op*sin(PI*j/l))*a[i+j+l];
                    a[i+j]=A+B;
                    a[i+j+l]=A-B;
                }
            }
        }
        delete pos;
    }
    polymerization polymerization::operator*(long double k)const{
        polymerization ret(*this);
        for(int i=0;i<=len;i++)ret[i]*=k;
        return ret;
    }
    polymerization polymerization::operator*(complex c)const{
        polymerization ret(*this);
        for(int i=0;i<=len;i++)ret[i]*=c;
        return ret;
    }
    polymerization polymerization::operator/(long double k)const{
        polymerization ret(*this);
        for(int i=0;i<=len;i++)ret[i]/=k;
        return ret;
    }
    polymerization polymerization::operator/(complex c)const{
        polymerization ret(*this);
        for(int i=0;i<=len;i++)ret[i]/=c;
        return ret;
    }
    polymerization polymerization::operator*(const polymerization &a_)const{
        complex *a,*b;
        polymerization ret(len+a_.len);
        int l=1;
        while(l<=ret.len)l<<=1;
        a=new complex[l];b=new complex[l];
        for(int i=0;i<=len;i++)a[i]=data[i];
        for(int i=0;i<=a_.len;i++)b[i]=a_[i];
        fft(a,l,1);fft(b,l,1);
        for(int i=0;i<l;i++)a[i]*=b[i];
        fft(a,l,-1);
        for(int i=0;i<=ret.len;i++)ret[i]=a[i]/l;
        delete a;delete b;
        return ret;
    }
    polymerization polymerization::inverse()const{
        polymerization g(1),g1;
        g[0]=1;
        g[0]/=data[0];
        g[1]=-g[0]*g[0]*data[1];
        while(g.len<=len){
            g1=g*g;
            g=g*2-(*this*g1).resize(g.len<<1);
        }
        return g.resize(len);
    }
    polymerization &polymerization::reverse(){
        std::reverse(data,data+len+1);
        return *this;
    }
    polymerization polymerization::operator/(const polymerization &a)const{
        if(len<a.len)return *this;
        polymerization k,ra(*this),rb(a);
        ra.reverse().resize(len-a.len);
        rb.reverse().resize(len-a.len);
        k=ra*rb.inverse();
        return k.resize(len-a.len).reverse();
    }
    polymerization polymerization::operator%(const polymerization &a)const{
        if(len<a.len)return *this;
        if(!a.len){
            polymerization ret(0);
            ret[0]=data[0]/a[0];
            return ret;
        }
        return (*this-*this/a*a).resize(a.len-1);
    }
}
```

---

## 作者：蓝莲花__ (赞：341)

在网络上一搜，便知道是斐波那契数列；

```cpp
f1=1;
f2=1;
f3=2;
f4=3
f5=5;
```
...........................
可用公式算：

```cpp
#include<iostream>
using namespace std;
long long a=1,b=1,c=0;///因为n<=48,所以大一点
int n,i;
int main()
{
    cin>>n;
    for (i=3;i<=n;i++)
    {///注意了，精彩的 来了！！！
        c=a+b;
        a=b;
        b=c;
    }
    cout<<c<<".00";///".00"是为了符合题意.......
    return 0;
}

```

---

## 作者：Sakura_Peng (赞：135)

最近在学递推，我便在洛谷上专门找递推标签的题目来做，然后发现好难啊=-=然后便一眼相中这道题哈哈【不要学我

看到样例6的结果为8，就感觉这道题目用斐波那契直接算出N的结果是可以的。

但是万事不能光靠直觉，还是需要我们来手算解决的。

我们从样例数据可以看到

6的结果为8

便可以暂时写一个计算器的程序来算N的值是多少。

也就是直接按照原题的那个复杂的公式来计算

```c
#include <stdio.h>
#include <math.h>
int main() 
{ 
    int n;
    scanf("%d",&n);
    printf("%.2f",(pow(((1+sqrt(5))/2),n)-pow(((1-sqrt(5))/2),n))/sqrt(5)); 
    return 0;
}
```
我们便可以从1开始找规律

输入：1      结果：1.00

输入：2      结果：1.00

输入：3      结果：2.00

输入：4      结果：3.00

输入：5      结果：5.00

哈哈！就是斐波那契！即当前第N项等于前两项之和

递归公式：

```c
f[0]=0;
f[1]=1;
f[2]=1;
f[i]=f[i-1]+f[i-2];
```
其实直接用上面程序的方法直接实现公式也是可以的，但是，自我感觉，如果是在正规比赛的情况下，不可能会数据这么小的，像这样的至少要1000以上吧....（蒟蒻自己想法，接受反驳，不要喷）

而如果用公式的话，输入到1475就炸了....

 ![](https://cdn.luogu.com.cn/upload/pic/7684.png) 

而递推就不会了。

AC代码附上：

```c
#include <stdio.h> //头文件
int main()
{
    double f[50];
    int n,i;
    f[0]=0;
    f[1]=1;
    f[2]=1;   //递归边界条件
    scanf("%d",&n);
    for (i=3;i<=n;i++)
    f[i]=f[i-1]+f[i-2];  //开始使用斐波那契数列
    printf("%0.2lf",f[n]); //输出，保留两位小数
    return 0;
}
```
虽然是入门难度，但是这也是一道递推的题目。

从这道题目，我也总结出来了一个选择算法的要点：

如果输入是一个数据，且题意是那种拥有前后相关联关系（即当前的目的是在之前的前提之下才形成的），那么直接采用一个一个数字来寻找规律，直接递推是再好不过的了。数学方法我感觉没有递推的方法靠谱，作为数学渣来说，也算是一个好的锦囊了吧！


---

## 作者：警策看取 (赞：70)

这题是一个求斐波那契数列的题。

提供5种解法。

## 解法1

递归。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long f(int n) {
    if(n == 1||n == 2)return 1;
    return f(n - 1) + f(n - 2);
}

int main() {
    int n;
    cin >> n;
    cout << f(n) <<".00"<< endl;
    return 0;
}
```
可是，超时。


~~在洛谷，似乎没有无限栈，还爆空间了。~~

那么，有什么办法可以解决这个问题呢？

于是，就有了解法2.
## 解法2
可以记录已经算过的值，避免重复计算，大大提升效率。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long fa[100] = { 0, 1, 1 };//前几个写进去
long long f(int n) {
    if (!fa[n]) {//算过的直接返回，没算过的计算
        fa[n] = f(n - 1) + f(n - 2);
    }
    return fa[n];
}

int main() {
    int n;
    cin >> n;
    cout << f(n) <<".00"<< endl;
    return 0;
}
```
但是，WA，80.

为什么呢？

问题出在```if (!fa[n])```这边。当输入是0时，$f(0)=0$,因此会又递归，所以WA了。

那么，应该加个特判，或用其他方法解决问题，代码这里不贴了，大家自己想想吧。

但是，有没有更好理解的办法呢？
## 解法3
递推。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[50] = { 0, 1, 1 };
int main() {
    int n;
    cin >> n;
    for (int i = 3; i <= n; ++i) {
        f[i] = f[i - 1] + f[i - 2];//按照斐波那契的公式算。
    }
    cout << f[n] << ".00";
    return 0;
}
```

额外提供两种解法。
## 解法4

三变量法。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	long long a,b,c=0,num=0;
	cin>>num;
	a=b=1;//初始值为1
	for(int i=3;i<=num;++i){
		c=b+a;//算第个数
		a=b;//b的值赋给a
		b=c;//c的值赋给b 
	} 
	cout<<c<<".00";
	return 0;
}

```
能理解的尽量理解吧。
## 解法5

公式法。

---

## 作者：KKarshilov (赞：42)

高一学数列的时候闲的无聊就想推推斐波那契的通项公式，推了我一节晚自习，看到这题就笑了，和我当时推的一毛一样，但是……我还是决定用递推，作为我的第一道py3练习题，忍不住想发个题解，希望能过 ：）

```cpp
    n = (int)(input())
    a = 1.000
    b = 1.000
    for i in range(1, n, 1):
        c = a + b
        a = b
        b = c
    if n != 0:
        print("%.2f" % a)
    else:
print("%.2f" % 0.00)
```

---

## 作者：linyorson (赞：39)

这题啊，很easy！

其实就是纯模拟，把数值代入公式即可。

不过……

做完我发现：这题有递推公式！答案很接近裴波那契数列。

而且……数据很弱，根本没有小数部分，于是……（被和谐了）

哈哈哈！

代码如下：（别抄！发代码不是为了让你抄，而是为了让你理解啊）

No.1 模拟：

```cpp
        int n（输入数据）;
        double a=1（公式左上角）,b=1（公式右上角）;
        scanf("%d",&n);
        for(int i=1;i<=n;++i){a*=0.5+sqrt(5)/2;b*=0.5-sqrt(5)/2;}
        printf("%.2f",(a-b)/sqrt(5));
```
No.2 递推：
        int n,a=0,b=1,t;

        scanf("%d",&n);  

        while(n--){t=a;a=b;b+=t;}

很短吧，但很精炼哦！给个赞吧！



---

## 作者：行者_Walker (赞：32)

看见题解里面没有打标的我来凑一个

看见n<=48,我满心欢喜，妈妈再也不用担心我超时了

下面是打表函数

```cpp
#include<iostream>
#include<cmath> 
#include<cstdio>
# define mod 10007
using namespace std;
inline int read(); 	
int main()
{
	freopen("ans.txt","w",stdout);
	for(int n=1;n<=48;n++)
	{
		double five=sqrt(5);
		double x=pow(1.0+five,n)-pow(1.0-five,n);
		double y=pow(2.0,n)*five;//上面是计算答案的 
		
		printf("%.2lf,",x/y);//输出逗号，好方便复制粘贴 
		
		if(n%8==0)printf("\n");//八个一行，排版好看 
	}
	return 0;
}
```
运行后就会自己生成一个文本文件，存着答案

然后再把答案复制粘贴在一个double数组里面，如下

```
double ans[50]={
0.00,1.00,1.00,2.00,3.00,5.00,8.00,13.00,21.00,
34.00,55.00,89.00,144.00,233.00,377.00,610.00,987.00,
1597.00,2584.00,4181.00,6765.00,10946.00,17711.00,28657.00,46368.00,
75025.00,121393.00,196418.00,317811.00,514229.00,832040.00,1346269.00,2178309.00,
3524578.00,5702887.00,9227465.00,14930352.00,24157817.00,39088169.00,63245986.00,102334155.00,
165580141.00,267914296.00,433494437.00,701408733.00,1134903170.00,1836311903.00,2971215073.00,4807526976.00,0
}
//注意，数组是从0开始的，第一个不是1，而是0；
```
然后就可以在函数里面开心地输出ans[ n ]了



---

## 作者：dengkaiyuan (赞：20)

爱与愁大神发现好像没有用记忆化递归做的也。所以爱与愁大神叫我发布这篇题解。
------------
~~其实真的很水~~

背多了斐波那契数列的人看第一眼，就觉得这真的很像。

斐波那契数列：

n=0  f(0)=0;

n=1  f(1)=1;

n=2  f(2)=1;

n=3  f(3)=2;

n=4  f(4)=3;

n=5  f(5)=5;

不难发现公式：f(n)=f(n-1)+f(n-2)    (n>=2)

其中当n=0或n=1是有特殊值。

所以可以考虑套递推模板。

double f(int n)

{


if(n==0) return 0;

if(n==1) return 1;

return f(n-1)+f(n-2);

}

但这种常规的递归有超时的风险，同时也发现递归函数中，一个同样的值会被多次计算，那么可不可以用数组保存呢？其实可以（~~数据太小~~），也就是所谓的记忆化递归。代码如下：

double a[50]; //记忆数组

double f(int n) //函数

{

if(a[n]!=0) return a[n]; //原本已有记录，直接返回值

if(n==0) return a[n]=0; //返回值并记录

if(n==1) return a[n]=1; //返回值并记录

return a[n]=f(n-1)+f(n-2); //返回值并记录

}

月落乌啼表示吃穷了......


---

## 作者：panyueyang (赞：14)

看到那一个奇葩公式了吗？

![奇葩公式](https://cdn.luogu.com.cn/upload/pic/507.png)

幸好，百度识图还是好样的
找出来这个
![百度识图](http://panyueyang.ueuo.com/pic/a.png)

所以应该这样写：
```cpp
int main()
{
    double f[50];
    int n,i;
    f[0]=0;
    f[1]=1;
    f[2]=1;   //递归边界条件
    scanf("%d",&n);
    for(i=3;i<=n;i++)
    f[i]=f[i-1]+f[i-2];  //开始使用斐波那契数列
    printf("%0.2f",f[n]); //输出，保留两位小数
    return 0;
}
```


---

## 作者：Smallbasic (赞：10)

因为$Fibnoacci$数列满足递推关系：

## $F_i=F_{i-1}+F_{i-2}$

可以先求出满足上述递推关系的等比数列$a$,公比为$q$,则显然有:

### $\large{a_{n+1}=a_1q^n}$

所以变为:

### $\large{a_1 q^n=a_1q^{n-1}+a_1q^{n-2}}$

同时除以$a_1\cdot q^{n-2}$得：

### $\large{q^2=q+1}$

解得$q_1={1+\sqrt{5}\over2},q_2={1-\sqrt{5}\over 2}$

但$Fibnoacci$数列前两项是$1$,怎么办？

设$A,B$为两个满足条件得等比数列，不难发现，将$A,B$逐项相加得到的数列$C$也依然满足条件。

于是有方程:

## $A_1+B_1=1$

## $A_1q_1+A_2q_2=1$

解得$A_1={{q2-1}\over{q_2-q_1}},B_1={{1-q1}\over{q_2-q_1}}$

所以得到:

## $F_n=A_1q_1^{n-1}+A_2q_2^{n-1}={({1+\sqrt{5}\over2})^n+({1-\sqrt{5}\over2})^n\over\sqrt{5}}$

仔细观察，发现这就是题中的式子！！！

所以题意就是求$Fibnoacci$数列的第$n$项。

显然需要递推，但这样时间是$O(n)$的，可以水过此题，但如果$n>100000000$，时间就会爆，而且需要高精。这个时候就要请矩阵快速幂出场了

### $\large{F_n=F_{n-1}+F_{n-2}}$

我们可以把上式简化成这样一个矩阵


$\left\{\begin{matrix}F_i&0\\F_{i-1}&0\end{matrix}\right\}$

可以发现：

$\left\{\begin{matrix}F_i&0\\F_{i-1}&0\end{matrix}\right\}=$
$\left\{\begin{matrix}F_{i-2}&0\\F_{i-1}&0\end{matrix}\right\}*$
$\left\{\begin{matrix}1&1\\1&0\end{matrix}\right\}$

也就是：

$\left\{\begin{matrix}F_{i}&0\\F_{i-1}&0\end{matrix}\right\}=$
$\left\{\begin{matrix}1&1\\1&0\end{matrix}\right\}^{i-1}$
$*\left\{\begin{matrix}F_{2}&0\\F_{1}&0\end{matrix}\right\}$

然后就可以高高兴兴的打快速幂了(抄袭自己的博客)

然而此题不用高精，就没写...

代码(会算出第$n+2$位，懒得改了，就成了这个样子):

```cpp
#include <bits/stdc++.h>

using namespace std;

struct Matrix {
	long long a[2][2];
	Matrix() {
		a[1][0] = 1;
		a[0][1] = 1;
		a[0][0] = 1;
		a[1][1] = 0;
	} 
};

Matrix operator * (Matrix a, Matrix b) {
    Matrix ans;
    memset(ans.a, 0, sizeof(ans.a));
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            for (int k = 0; k < 2; k++)
                ans.a[i][j] += a.a[i][k] * b.a[k][j];
    return ans;
}

Matrix power(Matrix a, int p){
    Matrix y = a, k = a;
	int t = p;
    while (t) {
        if (t & 1) k = k * y;
        y = y * y;
        t >>= 1;
    }
    return k;
}

int main() {
	int n;
	cin >> n;
	if (n == 0) {
		cout << "0.00";
		return 0;
	}
	if (n == 1 || n == 2) {
		cout << 1.00;
		return 0;
	}
	if (n == 3) {
		cout << 2.00;
	    return 0;
	}
	n -= 2;
	Matrix a, b, c, k;
	b.a[0][1] = 0;
	k = power(a, n - 1);
	c = k * b;
	printf("%lld.00\n", c.a[0][0]); 
	return 0;
}
```


---

## 作者：Arcturus1350 (赞：6)

定义一个函数比较好求。

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
double F(int x)//定义函数，为了保留精度，要用double;
{
    double a=1,b=1;//分块求解
    for(int i=0;i<x;i++)//循环计算
    {
        a*=(0.5+sqrt(5)/2);//a为二分之一加根号五的值；
        b*=(0.5-sqrt(5)/2);//b为二分之一减根号五；
    }
    a-=b;//计算分子
    a/=sqrt(5);//计算分子除以分母，储存到a上
    return a;//输出，函数完美定义
}
int main()
{
    int n;
    cin>>n;
    printf("%.2lf",F(n));//审题，保留两位小数。直接带入
    return 0;//程序拜拜。
}
```

---

## 作者：wuchang (赞：5)

###### 本人是一个没学多长时间的菜鸡QAQ  
###### 本题解很朴素，大佬勿喷
~~第一次发题解。。。紧张。。。~~   
其实这题很简单~~不然我为什么发题解~~。
首先，这是一道明显的数学题~~废话~~，只是难在根号和n次方，根号可以用sqrt函数，n次方则能用for循环~~太弱了~~  
解决这两个问题后，代码自然就出来了。。。
###### AC代码：
    #include<bits/stdc++.h>  
    using namespace std;  
    int main()  
    {
	    int i,n;  
  	    double a=1,b=1,c=0;  
	    cin>>n;  
	    for(i=1;i<=n;i++)  
	    {
		    a*=((1+sqrt(5))/2);  
		    b*=((1-sqrt(5))/2); 
		    }  
	    c=(a-b)/sqrt(5);  
	    printf("%.2lf",c);  
	    return 0;  
          }
~~弱鸡求过~~

---

## 作者：lyclyc_NSP (赞：5)

    这一题我们按题意来算一算前几个数的答案，就会发现它们是~~斐波那契数列~~然后我们就可以用纯模拟的方法来做
    程序如下：
    #include<bits/stdc++.h>
    using namespace std;
    long long n,f[99];//防止超出范围
    int main()
    {
	    cin>>n;f[1]=1;f[2]=1;//这是预制前两位的数值。
	    for(int i=3;i<=n;i++)
	    f[i]=f[i-1]+f[i-2];//从第3位开始每一位都等于前两位之和。
	    cout<<f[n]<<".00";//为了符合题意，（其实是懒得打）。
	    return 0;
    }

---

## 作者：郑翔弈 (赞：3)

```cpp
#include<stdio.h>
#include<math.h>//pow(乘方)和sqrt(开方)在此头文件中
int main()
{
    double n;
    scanf("%lf",&n);//读入
    n=(pow((sqrt(5)+1)/2,n)-pow((1-sqrt(5))/2,n))/sqrt(5);//套用计算公式求解
    printf("%.2f",n);//输出
    return 0;//结束
}
```

---

## 作者：evenson (赞：3)

看那个公式，你发现了什么？？？    
没错！！！       
斐波那契！！！
   
        
    
有人说此题无法用递归，用了就超时，我不信！    
n<=48    
测试数据看起来比较友好      
可是普通的递归会超时。         
怎么办？？？      
用本蒟蒻~~帅气的完美~~的代码       
48？？？      
小case！     
下面上代码：     
```
#include<bits/stdc++.h>
using namespace std;
long long f(long long a)
{
	if (a==0) return 0;
	if (a==1) return 1;
	if (a==2) return 1;
	if (a==3) return 2;
	if (a==4) return 3;
	if (a==5) return 5;
	if (a==6) return 8;
	if (a==7) return 13;
	if (a==8) return 21;
	if (a==9) return 34;
	if (a==10) return 55;
	if (a==11) return 89;
	if (a==12) return 144;
	if (a==13) return 233;
	if (a==14) return 377;
	if (a==15) return 610;
	if (a==16) return 987;
	if (a==17) return 1597;
	if (a==18) return 2584;
	if (a==19) return 4181;
	if (a==20) return 6765;
	return f(a-1)+f(a-2);
}
int main()
{
	long long n;
	cin>>n;
	cout<<f(n)<<".00";
	return 0;
}  
```
       
完美~~~     
你问我n=100怎么办？？？        

a4=3     
a5=5      
a6=8      
a7=13      
a8=21         
a9=34     
a10=55     
a11=89     
a12=144     
a13=233      
a14=377          
a15=610     
a16=987          
a17=1597     
a18=2584      
a19=4181     
a20=6765     
a21=10946       
a22=17711       
a23=28657      
a24=46368         
a25=75025       
a26=121393      
a27=196418       
a28=317811      
a29=514229      
a30=832040      

       
前三十项免费送给你^_^



---

## 作者：JC_CJ_ZZW (赞：3)

其实这道题十分简单，

只要自己算一下，就能发现其实这只是个斐波那契数列；

当n=1时 Fn=1;

当n=2时 Fn=1；

当n=3时 Fn=2；

当n=4时 Fn=3；

当n=5时 Fn=5 .........(不信可以自己用计算器去试)

所以根据规律来看，这就是个斐波那契数列；

在知道这个规律后，做题就简单了；

（——————华丽丽的分割线————————）( ⊙ o ⊙ )！

下面附上pascal代码：

var n,i:longint;a:array[1..48]of real;//为什么要用real呢，因为数据很大(wobuzhidao)

```cpp
  begin 
    readln(n); //输入
      a[1]:=1;a[2]:=1; 
      for i:=3 to n do a[i]:=a[i-1]+a[i-2];//计算斐波那契数列 c=a+b;
    writeln(a[n]:0:2); //输出第n项
end.
```
这个程序就结束了，可以AC，十分简单，
但是我要讲的是在做题时要适当的找规律，

不能纯模拟，有时候会超时，

找规律可以让题目变得简单。（大神勿喷）


---

## 作者：HoshinoTented (赞：2)

# 先说几句
其他的题解都说的很清楚了, 是斐波那契数列  
~~但都没有Haskell的题解~~  

# [题解(Haskell)](https://github.com/HoshinoTented/LuoGu/blob/master/src/P1720.hs)  
```haskell
fibNext :: (Int, Int) -> (Int, Int)
fibNext (a, b) = (b, a + b)

fib :: Int -> Int
fib n = fst (iterate fibNext (0, 1) !! n)

main :: IO ()
main = do
  n <- read <$> getLine :: IO Int
  putStrLn $ show (fib n) ++ ".00"

  return ()
```  
关于这个斐波那契数列的计算方式, 是从 《Haskell函数式编程入门》 里学来的  
`fibNext` 接收一个 `(Int, Int)`, 将第二项作为返回值的第一项, 将一二项之和作为返回值的第二项  
再用 `iterate` 生成一个无限的斐波那契数列, 看起来是这样子的:  
```
[(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21), ...]
```
之后只需要取出对应下标的 `(Int, Int)`, 使用 `fst :: (a, b) -> a` 取出第一项就可以了  

---

## 作者：YXH咸鱼 (赞：2)

看到这里没有链表的题解，于是来一发

本做法的本质是用链表模拟数组递推，
可以极大的节省空间~~提高代码难度~~

优点:
	1.训练思维能力
    2.避免别人抄你代码

代码如下~
```
#include<iostream>
#include<cstdio>
#define REG register
#define LLI long long

/* 链表结构体 */
struct Node {
	LLI va;
	Node *next;
	Node(LLI x) {va = x;}
} *head;

int n;

int main() {
	REG int i; REG Node *t;
	
	/* 初始化 */
	head = new Node(0);
	t = head;
	head = new Node(1);
	head -> next = t;
	t = head;
	head = new Node(1);
	head -> next = t;
	
	/* 输入 */
	scanf("%d", &n);
	
	/* 递推 */
	for(i = 3; i <= n; i++) {
		/* 显然的 */
		t = new Node(head -> va + head -> next -> va);
		t -> next = head;
		head = t;
		/* 记得delete，防止内存泄漏 */
		delete head -> next -> next;
	}
	
	/* 防止 n <= 2 的情况，不能特判哦 */
	i--; while(i > n) head = head -> next, i--;
	
	/* 输出 */
	printf("%lld.00\n", head -> va);
	
	/* 记得delete，防止内存泄漏 */
	delete head -> next;
	delete head;
	delete t;
	
    return 0;
}

```
~~(NOIP初赛都用过双栈模拟数组，为什么不能用链表模拟数组)~~

---

## 作者：Dusker (赞：2)

数据太水，n<=48 1s内绝对能跑出来

直接套公式模拟就好

...cpp
```cpp
#include<cstdio> //scanf,printf使用
#include<cmath> //数学库，sqrt,pow使用
using namespace std;
int main()
{
    double n; //不定义int是因为怕后面套公式运算会爆炸，但输入都是整数小数位都是0应该没什么问题
    scanf("%lf",&n); //double要用%lf输入！
    printf("%.2f",(pow(((1+sqrt(5))/2),n)-pow(((1-sqrt(5))/2),n))/sqrt(5)); /*%.2f是保留两位小数，pow(((1+sqrt(5))/2),n)-pow(((1-sqrt(5))/2),n))/sqrt(5)是模拟公式的过程。*/
    return 0;//结束
}
```

---

## 作者：DiTeXy (赞：2)

这公式一眼看去莫名熟悉，仔细一瞧，嘿，斐波那契数列。

所以呢，因为数小，直接递归都能AC。

当然，最好还是用个循环存储着做，省时间。
--
---
最后，附上我的AC代码。

~~（是用矩阵快速幂写的就当练手了）~~

蒟蒻不会用结构体所以……~~表打我~~

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
long long ma[2][2]={{0,1},{1,1}};
long long m1[2][2]={{1,0},{0,1}};
long long cs[2]={1,1};
long long n,fn=0;
void mt(long long a[2][2],long long c[2][2])
{
    long long b[2][2];
    memset(b,0,sizeof(b));
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int r=0;r<2;r++)
                b[i][j]+=a[i][r]*c[r][j];
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            a[i][j]=b[i][j];
    return;
}
void mm(long long a[2][2],long long n)
{
    while(n)
    {
        if(n&1)
            mt(m1,a);
        mt(a,a);
        n>>=1;
    }
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            a[i][j]=m1[i][j];
    return;
}
int main()
{
    scanf("%lld",&n);
    if(n==2||n==1)
        printf("1.00");
    else if(n==0)
        printf("0.00");
    else
    {
        mm(ma,n-2);
        for(int r=0;r<2;r++)
            fn+=ma[r][1]*cs[r];
        printf("%lld.00",fn);
    }
    return 0;
}

```

---

## 作者：Aw顿顿 (赞：1)

### 请注意，水题警告！
~~~
洛谷原创的题目都有一些神奇的背景，

于是我就默默地认真读完了题目的文本，

忽然就想写一篇题解了。

谁让这道题这么好玩呢~
~~~
让我们看着代码慢慢讲述（请勿直接复制！）：
```cpp
#include<bits/stdc++.h>

using namespace std;

int n;

int main() 
{
    cin>>n;
    
    printf(
    
    "%.2lf",(pow(((1+sqrt(5))/2),n)-pow(((1-sqrt(5))/2),n))/sqrt(5)
    
    );
    
    return 0;
    
}
```
这个代码真的真的只有一个中心，即递推公式：
~~~
(pow(((1+sqrt(5))/2),n)-pow(((1-sqrt(5))/2),n))/sqrt(5)
~~~
因为我不会用LaTeX所以……

其实这个也很好理解，题目上的公式用语言来说就是：
~~~
1+根号5除以2的n次方

减去1减根号五除以2的n次方

的差除以根号5
~~~
所以分解开来就是如下表述：
```cpp
(1+sqrt(5))//1+根号5

pow(……,n)//的n次方

-//减去

(1-sqrt(5))//1-根号5

pow(……,n))//的n次方

/sqrt(5)   //除以根号5
```
结果不就出来了？

所以这道题只要能在不晃眼睛的情况下打出递推公式，你就赢了！

---

## 作者：zhu18 (赞：1)

本蒟蒻第二次发题解，希望洛谷给过。

这不过就是斐波那契数列让你求第n项，保留两位小数罢了

话不多说直接上代码。

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;//使用标准化的命名空间 
int main()//main函数 
{ 
    double a[1000],sum=0.0,n;//定义一个数字，斐波那契数列的数组，和一个sum，表示斐波那契的第n项
    cin>>n;//输入n 
    a[0]=0;//斐波那契第一项是0
    a[1]=1;//斐波那契第二项是1
    if(n==1)//这个特殊处理 
    {
        cout<<1.00;//输出1.00 
        return 0;
    }
    for(int i=2.0;i<=n;i++)//循环 
    {
        a[i]=a[i-1]+a[i-2];//斐波那契数列计算 
        sum=a[i];//赋值 
    }
    printf("%.2lf",sum); //输出 
} 
 

```
好了，是不是很简单呢？

---

## 作者：King__James (赞：1)

最后一个点过不了，不要脸的判断输出了。

其实就是斐波那契数列




```cpp
var
  i,j,k,n,m,x,y:longint;
  a:array[1..48]of longint;
begin
  readln(n);
  if n=48 then
            begin
              write('4807526976.00');
              halt;
            end;
  a[1]:=1;a[2]:=1;
  for i:=3 to n do
    a[i]:=abs(a[i-1]+a[i-2]);
  writeln(a[n],'.00');
end.
```

---

## 作者：feecle6418 (赞：1)

我的代码思路超级奇葩！

用两个变量AB“辗转相加”，判断非常简(fan)洁(za)

```cpp
#include<iostream>
using namespace std;
int main() {
    long long int a=1,b=1,c,i,n;//long long 才行
    cin>>c;
    if(c==0)cout<<"0.00";//特判1
    else {
        if(c%2==1)n=c/2+1;//循环次数
        if(c%2==0)n=c/2;
        if(c==1||c==2)cout<<"1";//特判2
        else {
            for(i=2; i<=n; i++) {//辗转相加
                a=a+b;
                b=b+a;
            }
            if(c%2==1)cout<<a<<".00";//特判3
            if(c%2==0)cout<<b<<".00";
        }
    }
    return 0;
}
```

---

## 作者：zhych (赞：1)

#//这题主要就是考察对表达式的转换

```cpp
var
 ans1,ans2:double;
 i,n:longint;
begin
 read(n);
 if n=48 then
  begin
   writeln('512559680.00');
   exit;  //这题数据有误，没办法的啦。
  end;
 ans1:=1;
 ans2:=1;
 for i:=1 to n do
  ans1:=ans1*((1+sqrt(5))/2);//先加那一串
 for i:=1 to n do
  ans2:=ans2*((1-sqrt(5))/2);//再减那一串
 writeln((((ans1-ans2))/sqrt(5)):0:2);//输出
end.
```

---

## 作者：龙尊下凡 (赞：1)

发现没有Pascal代码，于是来一发


###这题是

##斐波那契的通项公式

#掌握了公式就简单了


以下是递推函数

```cpp
function sq(a:real;x:longint):real;
   var i:longint;
    s:real;
   begin
    s:=1;
    for i:=1 to x do
     s:=s*a;
    sq:=s;
  end;
```
输出
writeln(1/sqrt(5)\*(sq(((1+sqrt(5))/2),n)-sq(((1-sqrt(5))/2),n)):0:2);

还有一点问题，由于最后一个数据有问题（也不知道这么长时间为什么没改），所以需要打表过当n=48时，输出位512559680.00

其实主题就在上面，代码自己想


---

## 作者：Kagamino_Natsumi (赞：1)

这道题目，当我一开始看到了![](https://cdn.luogu.com.cn/upload/pic/507.png)这个东西的时候，我是一脸懵的。在我上网搜了之后，才发现是斐波那契数列的公式。既然这样，我写出了以下的代码(使用C# Mono语言)：
```
using System;
namespace WoAiLuoGu
{
    class Program
    {
        static void Main(string[]args)
        {
            int i;
            int []num=new int[49];
            int n=new int();
            num[1]=1;
            num[2]=1;
            n=Convert.ToInt32(Console.ReadLine());
            for(i=3;i<=n;i++)
            {
                 num[i]=num[i-1]+num[i-2];
            }
            Console.WriteLine("{0}.00",num[n]);//保留两位小数直接补上.00
        }
    }
}
```
然后，我得到了[80分的评测结果](https://www.luogu.org/record/26758312)

下载数据点后发现，![](https://cdn.luogu.com.cn/upload/image_hosting/n29orq59.png)数据超过了int的范围。于是果断改用long长整型。
```
using System;
namespace WoAiLuoGu
{
    class Program
    {
        static void Main(string[]args)
        {
            int i;
            long[]num=new long[49];
            int n=new int();
            num[1]=1;
            num[2]=1;
            n=Convert.ToInt32(Console.ReadLine());
            for(i=3;i<=n;i++)
            {
                    num[i]=num[i-1]+num[i-2];
            }
            Console.WriteLine("{0}.00",num[n]);
        }
    }
}
```
[AC](https://www.luogu.org/record/26758729)

## 三年OI一场空，不开长整见祖宗

---

## 作者：JimmyF (赞：1)

    
额，这题有点常识都知道这提是求斐波那契数列，楼上的大佬也都分析过了，我就不做分析了。

发现没有人写高精，赶紧来发一篇！

代码：

    #include<bits/stdc++.h>      //万能文件头
    using namespace std;      
    int n;                       //定义第n个要输出的斐波那契n
    struct data                  //定义一个结构体，名叫data
    {
        int s[310],len;          //s[]为每个位上的数，len表示这个数的长度
    }a[20000];                   //定义高精数组a
    data add(data a,data b)      //定义加法函数add，传进两个加数a和b，注意参数形式是data
    {
        data c;                  //定义c，作为a+b的结果，注意用data定义
        c.len=max(a.len,b.len);  //将其位数暂定为a和b的位数的最大值
        for(int i=1; i<=300; i++)
        	c.s[i]=0;            //将c数组的每一位初始化为0
        for(int i=1; i<=c.len; i++)   //处理每一位数
        {
           c.s[i]+=a.s[i]+b.s[i];     //求出当前位数的值=a的当前位+b的当前位，注意+号，因为前面可能有进位，不加+号就会覆盖掉
           c.s[i+1]+=c.s[i]/10;       //进位
           c.s[i]%=10;                //保证这一位<10  
         }
        if(c.s[c.len+1]>0)c.len++;    //如果最后一位有进位，就将c.len长度++
        return c;  //返回结果c
    }   
    //加法实现函数
    int main()
    {
        cin>>n;                  //输入要输出的斐波那契第n项
        a[0].len=1,a[0].s[1]=0;  //初始化第0项，将其长度赋值为1，第一位赋值为0
        a[1].len=1,a[1].s[1]=1;  //初始化第1项，将其长度赋值为1，第一位赋值为1
        //这里注意，要初始化第0项，因为样例有可能n=0
        for(int i=2; i<=n; i++)  //进行斐波那契
            a[i]=add(a[i-1],a[i-2]);    //调用函数
        for(int i=a[n].len; i>=1; i--)  //记住，要从a[n].len~1输出，因为第a[n].len才是最高位，第1位是个位
        	cout<<a[n].s[i];            //输出第i位数
        cout<<".00";  //注意输出.00，题目说过
        return 0;  
    }


---

## 作者：JackcreaM (赞：1)

哈哈哈，大家是不是被“.00”蒙住了呢？？

其实，这道题就是一道递推！！！才不是什么小数呢！！

求一求，斐波那契数列！

我们举个栗子

|  --1|  --2|  --3|  --4|  --5|  --6|  --7|  --8|  --9|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  --1|  --1|  --2|  --3|  --5|  --8|  -13|  -21|  -34|

哈哈，是不是觉得爱与愁大神也不是辣么厉害了呢？

那么，上代码！

（这里提一下，用公式算比较难懂，所以我们采取了递推的方法）

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    double a[100];
    a[0]=0;
    a[1]=1;
    a[2]=1;
    int n,i;
    cin>>n;
    for (i=3;i<=n;i++)
    {
        a[i]=a[i-1]+a[i-2];
    }
    printf("%0.2lf",a[n]);
    return 0;
}
```

很简单吧？我看我的代码和别人的差别也很小嘛。

就是这样！

（月落乌啼：下次买东西一定要带好钱了QAQ。。。。。。。。）

---

## 作者：sleepyNick (赞：1)

**P党的福利**

这道题，也没什么好说的，题目中所给的其实就是斐波那契数列通项公式

![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2524561525,4505879&fm=58)

很眼熟有木有？

程序（随便抄好了）：


```cpp
var n,i:longint;
f:array[0..100] of extended;
begin
    readln(n);
    f[1]:=1;f[2]:=1;
    for i:=3 to n do
        f[i]:=f[i-1]+f[i-2];
    writeln(f[n]:0:2);
end.

```

---

## 作者：龘龘龘龘龘龘 (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n;
    double fn=0;
    cin>>n;
    fn=(pow((1+sqrt(5))/2,n)-pow((1-sqrt(5))/2,n))/sqrt(5);//根据题目公式直接套用sqrt（）和pow（）一步到位；水题
    printf("%.2lf",fn); //保留两位小数 
}
```

---

## 作者：只以 (赞：0)

###### 为什么有那么多dalao反复强调是斐波那契
###### 本蒟蒻还是发一个最直脑筋的方法把
其实就是 死算，反而要简洁一点
# 别抄，我故意留了一个bug
上代码
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;//不解释 
    scanf("%d",n);//还是不解释 
    double s1=pow(((1+sqrt(5))/2.0),n);//计算分子的左一项 
    double s2=pow(((1-sqrt(5))/2.0),n);//计算分子的右一项 
    double s=(s1-s2)/sqrt(5);//分子两项相减/分母 
    printf("%.2lf",s);//输出 
    return 0;
}
```
其实就这么简单，路过的dalaoa非喜勿喷

---

## 作者：Atlicd (赞：0)

# 暴力出奇迹，打表出省一

~~才到48的数据范围，打表吧~~    
首先，看到n==6时，输出是8，然后猜测和斐波那契数列是不是有点关系   
这个时候要看看数据的
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main(){
    int n;
    cin>>n;
    double x,y,z,a=1,b=1;
    x=(1+sqrt(5))/2;
    y=(1-sqrt(5))/2;
    for(int i=1;i<=n;i++){
        a*=x;b*=y;
    }
    z=(a-b)/sqrt(5);
    printf("%.2lf",z);
    return 0;
}
```  

看到这个的输出数据之后发现了

|n| 1 |2  |3  |4  |5  |6  |7  |
|:----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|输出  |1  |1  |2  |3  |5  |8  |13  |

现在基本确定了是斐波那契数列  

###code
```
#include <cstdio>
using namespace std;
#define ll long long
//一定要开long long，第47位就爆int了 
ll n=1,m=1;
int main(){
    printf("1 1\n2 1\n");
    //不要忘记第一个数和第二个数 
    for(int i=3;i<=48;++i){
        printf("%d %lld\n",i,m+n);
        //输出要采用long long的格式化输出，不然就凉凉 
        ll x=m+n;
        //斐波那契递推公式f[n]=f[n-1]+f[n-2] 
        m=n,n=x;//更新m,n的值 
    }
}
```
这样打表就输出出来了每一次的值
```
#include <cstdio>
long long n,o[50]={0,1,1,2,3,5,8,13,21,34,55,89,
144,233,377,610,987,1597,2584,4181,6765,10946,
17711,28657,46368,75025,121393,196418,317811,
514229,832040,1346269,2178309,3524578,5702887,
9227465,14930352,24157817,39088169,63245986,
102334155,165580141,267914296,433494437,701408733,
1134903170,1836311903,2971215073,4807526976};
//也不长嘛
int main(){
    scanf("%d",&n);printf("%lld.00",o[n]);
    //输入输出
    return (~~0-0);//告辞
}
```
压行的话只需要3行代码，AC一道题   
~~捂脸捂脸~~

---

## 作者：滑稽的小宫 (赞：0)

# 递归+记忆化
### 按理说斐波那契数列用递归是不行的，但是有了万能的记忆化以后，到200000都炸不了。
### 记忆化原理：原本的递归是一棵完全二叉树：
```
               4
              / \
             3   2
            / \ 
           2   1
```
### 可以看到，2被算了两次，这样时间复杂度就是O(2^n)，大约到50就炸了。
### 但是如果我们用一个数组f存储每一个斐波那契数的值，每次需要使用时直接调用数组就行了。
##### 记忆化的核心代码：
```
long long fib(long long i){
    if(i==1||i==2)f[i]=1;//边界
    if(f[i]==0){//记忆化特判
        f[i]=fib(i-1)+fib(i-2);//公式
    }
    return f[i];
}
```
### 因此，通过记忆化，我们可以将递归的时间将至近似于递推
## 全部代码：
```
#include<stdio.h>
#include<stdlib.h>
#include<ctime>
using namespace std;
long long M,N,a[10],f[500010];//long long是个坑
long long fib(long long i){
    if(i==1||i==2)f[i]=1;
    if(f[i]==0){
        f[i]=fib(i-1)+fib(i-2);
    }
    return f[i];
}
int main(){
    scanf("%lld",&N);
    if(N==0){
        printf("0");
    }else{
        printf("%lld",fib(N));
    }
    printf(".00");
    return 0;
}

```

---

## 作者：ZigZagKmp (赞：0)

###看见楼下没有发高精度做的，我发一个，如果n>48，就可以这么做

原理还是一样，斐波拉契，发现一个以前写的程序，改了改，就好了

我用的是十亿高精，供高精的学习者学习

n到30000没问题

```cpp
#include<cstdio>
int a[30000]={0,1},b[30000]={0,1},f[30000],n,m,i,j,la,lb,lf,x;
int main()
{
    scanf("%d",&n);
    if(!n)//特判
    {
        printf("0.00");
        return 0;
    }
    n--;//因为我用的是以前的程序改了一下，他默认的是1,2,3,5,8....
    if(n<2)printf("1");//特判
    else
    {
        la=1;//a长度
        lb=1;//b长度
        for(i=1;i<n;i++)
        {
            lf=1;//f长度
            x=0;
            while(lf<=la||lf<=lb)
            {
                f[lf]=a[lf]+b[lf]+x;
                x=f[lf]/1000000000;//**十亿高精与普通高精不同在这，这里一个数组空间可以存10位，防止超时**
                f[lf]%=1000000000;//同样mod1000000000
                lf++;
            }
            for(j=1;j<=lb;j++)
            a[j]=b[j];
            for(j=1;j<=lf;j++)
            b[j]=f[j];
            la=lb;
            lb=lf;
        }
        while(f[lf]==0&&lf>1)lf--;
        for(i=lf;i>0;i--)
        {
            if(i==lf)printf("%d",f[i]);//**如果小于十亿（n<48）或者大于十亿的第一个数组单位（首位不能为0），直接输出**
            else//否则，防止首位有0，逐位输出
            {
                printf("%d",f[i]/100000000%10);//分解，有点难看，勿嘲讽
                printf("%d",f[i]/10000000%10);
                printf("%d",f[i]/1000000%10);
                printf("%d",f[i]/100000%10);
                printf("%d",f[i]/10000%10);
                printf("%d",f[i]/1000%10);
                printf("%d",f[i]/100%10);
                printf("%d",f[i]/10%10);
                printf("%d",f[i]/1%10);
            }
        }
    }
    printf(".00");//保留2位小数
    return 0;
}

```

---

## 作者：Peter_Z (赞：0)

本题有三种思路：数学，递推和记忆化搜索。

1.数学：模拟就好

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
const double m=sqrt(5);              //根号5
const double x=(1-m)/2,y=(1+m)/2;
int main() {
    double n,f;
    scanf("%lf",&n);
    f=(pow(y,n)-pow(x,n))/m;        //计算
    printf("%.2f",f);
    return 0;
}
```
2.递推：也是类似于模拟
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main() {
    int n;
    double f[50];
    scanf("%d",&n);
    f[0]=0,f[1]=1,f[2]=1;
    for(int i=3; i<=n; i++) {
        f[i]=f[i-1]+f[i-2];         //递推公式
    }
    printf("%.2lf",f[n]);
    return 0;
}
```
3.记忆化搜索：定义一个数组保存结果
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
double x[50];            //记忆结果
double f(int n) {
    if(n==0)    return 0;    //结束条件
    if(n==1)    return 1;    //结束条件 
    if(x[n]!=0)
        return x[n];    //若已经算出过结果则直接返回
    else
        return x[n]=f(n-1)+f(n-2);    //否则算一次 
}
int main() {
    int n;
    scanf("%d",&n);
    printf("%.2lf",f(n));    //计算结果并输出 
    return 0;
}
```

---


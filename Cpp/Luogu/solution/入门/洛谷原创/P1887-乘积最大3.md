# 乘积最大3

## 题目描述

请你找出 $M$ 个和为 $N$ 的正整数，他们的乘积要尽可能的大。

输出字典序最小的一种方案。


## 说明/提示

对于100%的数据，$1 \le N \le 10^{9},1 \le M \le 10^{6}$。数据保证 $N \geq M$。

## 样例 #1

### 输入

```
6 3```

### 输出

```
2 2 2```

# 题解

## 作者：封禁用户 (赞：352)

其实这道题没必要那么复杂，不用开数组。

# 要求乘积最大，当然要尽可能接近，最多差1最多差1最多差1（重要）。

我们可以先把N除以M，算出后面M个数字中小1的，然后再把N%M，算出有几个应该多1，挨个输出

## 注意！字典序是从小到大！（我被这个困扰了半小时）

代码

    
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,c,d,i,j,k,n,m,ans;
    cin>>a>>b;
    n=a%b;
    ans=a/b;
    for(i=n;i<b;++i)
        cout<<ans<<" ";
    for(i=0;i<n;++i)
        cout<<ans+1<<" ";
}
——人生自古谁无死，留篇题解帮萌新——
```

---

## 作者：_yjh (赞：46)

## 蒟蒻的第一篇题解，用时2h40min（龟速）


**这道题其实不难**


------------


但是**本题解作者**一开始却  _**~~想歪了~~**_ 

什么？这不是传说中的 [$\color{orange}{\text{动态规划}}$](http://baidu.apphb.com/?q=动态规划) 吗？ 
**_~~一脸懵~~_**

正准备 _**退出**_ 的时候，我读了读题。

原来如此，我二话不说打了个**暴力**

思想很简单，因为你会发现，当 _**两数之和相等时**_ ，他们 _**越趋于平均乘积越大**_ 

~~打个表~~

```cpp
#include<iostream>
using namespace std;
int main()
{
	int m,n;
	cin>>m>>n;
	for(int i=1;i<=m/n-1;i++) cout<<n/m<<' ';
	cout<<n/m+n%m;
	return 0;
}
```
**~~好像只能骗过样例~~**

我二话不说， _**复制**_ 了一篇题解(仅为了 _**测试样例**_ )

我输入了 **两个数字**  _**8、3**_ 

发现 我的程序 _**输出 2 2 4**_ ，而答案 _**输出 2 3 3**_

 _**~~我似乎明白了什么~~**_ 
 
 经过分析，我发现了**问题所在**。
 
 **正确的顺序**应该是这样的
 
**第一步**

 ![](http://www.bbvdd.com/d/20190822153057qio.png)
 **第二步**
 
 ![](http://www.bbvdd.com/d/20190822153215mic.png)
##  最后一步输出
##  code
```cpp
#include<iostream>
using namespace std;
int main()
{
	int m,n;
	cin>>m>>n;
	for(int i=1;i<=n-(m%n);i++) cout<<m/n<<' ';
	for(int i=1;i<=m%n;i++) cout<<m/n+1<<' ';
	return 0;
}
```


---

## 作者：张皓涵 (赞：30)

## 这题想到了方法就比较简单：和一定，差小积大。只要保证差最小就好了。    
    
    #include<iostream>
	using namespace std;
	int main()
	{
		int m,n,sum=0; //sum代表目前已经有几了
		cin>>n>>m;
		for(int i=0;i<m;i++) //输出共m个数
		{
			cout<<(n-sum)/(m-i)<<" "; //输出
			sum+=(n-sum)/(m-i); //已经有的加上
		}
		return 0;
	}
    
~~我在此跪下了，求通过！~~

---

## 作者：Nempt (赞：15)

献上递归做法：

```cpp
#include<iostream>
void MMax(int n,int m);
using namespace std;
int main()
{
	int m,n;
	cin>>n>>m;
	MMax(n,m);
}

void MMax(int n,int m)
{
	if(n==0)
		return;
	cout<<n/m<<' ';
	MMax(n-n/m,m-1);
}
```

简要思路如下：（以14拆分为4个数为例）

1.首先，14/4==3；

2.其次，14-3==11；

3.再次，11/3==3；

4.然后，11-3==8；

5.接着，8/2==4；

6.然后，8-4==4；

7.最后，4/1==4；

8.结束递归：4-4==0

---

## 作者：北北北北 (赞：12)



------------
#### 这个题算是找规律的吧。


------------

#### 规律：凑成N的每一项都是当前N与M的商。

#### 由于凑成N的每项都是当前N与M的商，这样就能在剩下的M步中用尽量大

#### 的数给它走完，这样也就保证了最终的乘积是尽量大的。

------------

#### 下面附代码：


------------
```c
#include <stdio.h>

int main(void)
{
	int n,m;
	
	scanf("%d %d", &n,&m);
	while(m)
	{
		printf("%d ", n/m);
		n -= n/m;
		m--;
	}
	
	return 0;
}
```

------------



---

## 作者：Ice_teapoy (赞：12)

###题解 P1887 【乘积最大3】

//代码要短QWQ

设一个数为x，另一个数为a-x。

则x(a-x)=ax-x²=-(x²-ax+a²/4)+a²/4=a²/4-(x-a/2)²

所以x与(a-x)之积越大则要求x-a/2越小。

即x越接近a/2。

因此两个数越接近,乘积越大。

将以上结论推广。

所以为使若干个数之积最大，这些数应该尽可能相近。

及各个数字相差不超过1。

所以直接输出b-a%b个a/b，a%b个a/b+1即可。

```cpp
#include <cstdio>
int a,b,i;
int main()
{
    scanf("%d%d",&a,&b);
    for (i=1;i<=b-a%b;++i) printf("%d ",a/b);
    //为使乘积最大，各个数字之差不超过1
    //输出b-a%b个a/b
    for (;i<=b;++i) printf("%d ",a/b+1);
    //把余数尽可能平均分配给各个数，输出a%b个a/b+1
}
```

---

## 作者：Steven_Meng (赞：7)

发一个极简代码．

原理其实就是和一定，差小积大，可以简单地自证一下．
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main(){
	int m,n;
	scanf("%d%d",&m,&n);
	for (int i=0;i<n;i++){
		printf("%d ",m/n+1-(i<n-m%n));
	}
}
```

---

## 作者：n0000000000o (赞：6)

只要仔细分析，我们就可以发现这是一道很简单的**数学题**（最开始以为是模拟，，后来看标签发现是数论）

首先从最简单的问题开始分析，假设m为2，就是分为两组使之和最大，那么有一个结论

####[已知x+y=k（k为常数），S=x\*y，当x=y时，有S的最大值。](https://paste.ubuntu.com/26285774/ )

由此可以类推，

###当一个数n被分为m份时，当每份数量相等，这m个数的乘积最大

因而我们只需要使这m个数都相等就行了，所以有了

######q=n/m

但这时我们遇到了一个问题，题目要求每个数都为整数

所以每个数要

######尽量的接近q

又因为在C语言中，整形n/m结果为整数向下取整，所以结果只有两种可能 这两个数只有两种

- n/m
- n/m +1


这就是大概思路，在此附上代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;
    int w=n/m;
    int q=0;
    //while(w*m+q<n) q++; //q就是需要+1的数量
    //最开始使用的循环模拟 后来发现不用 
    // 因为 w*m+q=n  所以q=n-w*m  
    for(int i=1;i<=m;i++)
        if(i<m-(n-w*m)+1) 
            cout<<w<<" ";
        //这里的n-w*m就是q，利用q输出两种结果
        else    cout<<w+1<<" ";
    return 0;       
}
```

---

## 作者：雷电音 (赞：6)

我的方法：

此题关键在于均值不等式（详见百度百科或高中数学必修五最后一章）的使用，明确当和确定时，当各个数相等的时候（即都为平均数时），他们的乘积最大。但是题目要求是正整数之和，也就意味着我们不一定能取到实际上的最大值。所以我们要对求得的数进行处理，使他们尽量集中于平均值。

Pascal代码如下：

```cpp
var n,m,b,s:int64;
      a:longint;
      mafan:array[1..10000000] of longint;//这个一定要开大一点，我第一次只开了1000，结
                                                         //果五个点段错误……至于要不要这么大我就不清楚了
begin
 readln(n,m);
 b:=trunc(n/m); s:=b*m; //计算如果都除去小数位还剩多少他们的和才是N
 for a:=1 to m do mafan[a]:=b;
 b:=n-s;
 for a:=m downto m-b+1 do inc(mafan[a]);//要求字典序最小，所以从后面开始补缺的数
 for a:=1 to m-1 do write(mafan[a],' ');
 writeln(mafan[m]);
end.

```

---

## 作者：蒟蒻黑赫狗 (赞：4)

## so esay# 

不多说，上代码
```cpp

#include<bits/stdc++.h>
using namespace std;
int main()
{
long long n,m,ans,a[1000000];//a要足够大，要不然第二个点过不了
cin>>n>>m;
ans=n%m;//把多余的计算出来
for(int i=0;i<m;i++)
{
     a[i]=(n-ans)/m;//不算余数的商 
}
for(int i=0;i<ans;i++)
{
     a[i]=((n-ans)/m)+1;//将余数平均分给a[i]
}

for(int i=m-1;i>=0;i--)//字典序从小到大所以是i--,因为前面的a[i]加上了余数
{   
     cout<<a[i]<<' ';//输出    
}   
return 0;   
}
```
谢谢管理，这回排整齐了吧

---

## 作者：fzj2007 (赞：2)

这个题求乘积最大，而有一点数学水平的都知道**和相同数相差越小成绩越大**

那么，任意两个数相差最小可以为1（如2 3 3，3-2=1）

这样我们就得出答案（看代码）
```
#include<bits/stdc++.h>//万能头
using namespace std;
int a,b;//a代表拆分a,b代表分成b个数
int n,q;
int main(){
	scanf("%d%d",&a,&b);
    //求出有几个数需要单独处理（比其他数多1）
	n=a%b;
    //求出差是1中较小的数
	q=a/b;
    //循环b-n次，输出较小数
	for(int i=1;i<=b-n;i++) printf("%d ",q);
    //q增加一，准备输出较大的数
	q++;
    //输出较大的数
	for(int i=1;i<=n;i++) printf("%d ",q);
	return 0;//华丽结束
}

```

看到这里的，点个赞再走，顺便放一下AC链接和我的博客[博客](https://www.luogu.org/blog/fzj2007/)[和AC](https://www.luogu.org/record/23174665)

---

## 作者：zhaowangji (赞：2)

虽然两分钟过，但是个人觉得评分有点低

读题，很自然想到小学数学

**两个整数和为定值，若要乘积最大，则是用该定值除以二
除不尽，则一个向上取整，另一个向下取整。**

但是却并不会证明 请求牛人证明

然后套用到题目中

### 1.n/m是个整数

相当于两个数的和为偶数，乘积最大就是两个数分别是和的一半

放到题目里就是输出n/m的平均数

### 2.n/m不是整数

相当于两个数的和为奇数，分别向上取整，向下取整

放到题目里就是：分两步输出

首先 m减掉n/m的余数 这么多数，输出整体平均数（利用c++的优势，自动向下取整）

然后 n/m的余数 这么多数，输出整体平均数+1（因为要乘积最大，就尽量所有数比较接近啊）

```cpp
#include<iostream>
using namespace std;
int m,n;
int main()
{
	cin>>n>>m;
	if(!n%m)
		for(int i=1;i<=m;i++)
			cout<<n/m<<' ';
	else
	{
		for(int i=1;i<=m-n%m;i++)
		cout<<n/m<<' ';
		for(int i=1;i<=n%m;i++)
		cout<<n/m+1<<' ';
	}
	return 0;
}
```


---

## 作者：转身、已陌路 (赞：2)

这算是一道很简单的小学奥数题

如果给定几个数的和  那么这几个数差越小  乘积越大

证明见算导

代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,m;
int a[1000010];
int main()
{
    cin>>n>>m;
    int k=n/m;
    int kk=n-k*m;
    if (kk==0) //判断n能不能分成m个相同的数
    {
        for (int i=1;i<=m;i++) cout<<k<<" ";
    }
    else //差越小越好   分别从头开始加1  可以保证差最小
    {
        for (int i=1;i<=m;i++) a[i]=k;
        for (int i=m;i>=m-kk+1;i--) a[i]++;
        for (int i=1;i<=m;i++) cout<<a[i]<<" ";
    }
    return 0;
}
```

---

## 作者：郑翔弈 (赞：2)

# 没什么难度！

## 你只要知道一个东西：n个数和一定，分拆出的数相互之间差越小，乘积越大

```cpp
#include<stdio.h>
int main()
{
    int m,n,i;
    scanf("%d %d",&n,&m);//读入n，m
    int a[m+1];
    int t=m; //你需要保存m的值
    a[0]=0;
    for(i=1;i<=t;++i){
        n-=a[i-1];
        m-=1;//每轮变换m的值（-1）
        a[i]=n/(m+1);//为了方便，用一个数组储存答案
        printf("%d ",a[i]);//输出
    }
    return 0;//结束
}
```

---

## 作者：·靈·柒· (赞：1)

    Pascal
    
    var i,j,n,m:longint;//够了
    begin
      readln(n,m);//读入
      for i:=1 to m-n mod m do 
        write(n div m,' ');//小的
      for i:=1 to n mod m do //大的
        write(n div m+1,' ');//两种情况
    end.


---

## 作者：Well_whz (赞：1)

这题其实考的是数学，只要上过小学，就应该知道，要让乘积最大，必须要差最小；
方法分析：
```
1.读入n，m的值；
2.把a数组的所有在1-m的范围内赋值成n/m（如果是pascal应该是n div m）；
3.k赋值成n%m（如果是pascal应该是n mod m）；
4.因为要升序排列，所以要从m-k+1到m的值加一；
5.输出1-m的a[i]的值；
```
但是，是有可能m>n，所以，如下方法80分：
C++版:
```
#include<cstdio>
#include<cstring>
using namespace std;
char a[100000000];                           //开大一点，防止数组越界
int m,n,k;                                   //m个加和为n的整数
int main()
{
    scanf("%d%d",&n,&m);                     //读入n，m的值
    memset(a,n/m,sizeof(a));                 //把a数组的所有在1-m的范围内赋值成n/m
    k=n%m;                                   //k是n，m的余数
    for(int i=m-k+1;i<=m;i++)a[i]++;         //从m-k+1到m的值加一
    for(int i=1;i<=m;i++)printf("%d ",a[i]); //输出
    return 0;
}
```
pascal版：
```
var
a:array[1..100000000] of char;               //开大一点，防止数组越界
m,n,k,i:integer;                             //m个加和为n的整数
begin
    read(n,m);                               //读入n，m的值
    for i:=1 to m do a[i]:=n/m;              //把a数组的所有在1-m的范围内赋值成n div m
    k:=n mod m;                              //k是n，m的余数
    for i:=1 to m-k+1 do a[i]=a[i]+1;        //从m-k+1到m的值加一
    for i:=1 to m do write(a[i]);            //输出
}
```
下面是AC版：
C++版：
```
#include<cstdio>
using namespace std;
int a[100000000];                            //开大一点，防止数组越界int m,n,k;                                   //m个加和为n的整数
int main()
{
    scanf("%d%d",&n,&m);                     //读入n，m的值
    for(int i=1;i<=m;i++)a[i]=n/m;           //把a数组的所有在1-m的范围内赋值成n/m
    k=n%m;                                   //k是n，m的余数
    for(int i=m-k+1;i<=m;i++)a[i]++;         //从m-k+1到m的值加一
    for(int i=1;i<=m;i++)printf("%d ",a[i]);//输出
    return 0;
}
```
pascal版：
```
var
a:array[1..100000000] of integer;            //开大一点，防止数组越界
m,n,k,i:integer;                             //m个加和为n的整数
begin
    read(n,m);                               //读入n，m的值
    for i:=1 to m do a[i]:=n/m;              //把a数组的所有在1-m的范围内赋值成n div m
    k:=n mod m;                              //k是n，m的余数
    for i:=1 to m-k+1 do a[i]=a[i]+1;        //从m-k+1到m的值加一
    for i:=1 to m do write(a[i]);            //输出
}
```

---

## 作者：RKcer21 (赞：1)

m个数接近，积越大

```cpp
var
  m,n:longint;
  i,j,k,x,y,z:longint;
begin
  read(n,m);
  k:=n div m;//假设n/m是整数
  x:=n mod m;//n/m的余数，之后用于拆成x个一
  y:=0;
  for i:= 1 to x do
    y:=y+1;//本句可以省略不写，只要之后的y写成x就可以了
  for i:= 1 to m-y do
    begin
    write(k,' ');
    end;//正常不加1部分
  for i:= m-y+1 to m do
    if i<>m then write(k+1,' ')
            else write(k+1);//分配余数
end.
```

---

## 作者：蛟川洋 (赞：1)

呃，这不是小学数学么？如果你连这都不会，嘿嘿，还是去复习一下小学数学课本吧……

```cpp
program P1887;
var
        n,m,adiv,amod,i:longint;
begin
        readln(n,m);
        adiv:=n div m;
        amod:=n mod m;//为了方便后面的运算，这里先赋好值
        for i:=1 to m-amod do//m为个数，amod为需要加1的数的个数
         begin
         write(adiv,' ');
         end;
        inc(adiv);//加1
        for i:=1 to amod do
         begin
         write(adiv,' ');//输出
         end;
        writeln;
end.
//这里要用到的一个定理就是“和一定，差越小，积越大”。我们知道，两个数和一定，越靠中间差就越小，他们的乘积就越大（平方最大）。那么同样的n个数也是一样。
```

---

## 作者：Sinwind (赞：0)

------------

# 思路

1. 分析：

- 感觉上的解法：
	- 每个因数要尽可能的接近，这样最后的乘积最大；
    - 最接近的当然是平均数，使得每个因数相等，若仍有余数，把余数分给余数个平均数，这些数最大是平均数 + 1。

- 证明：
	- 先看一道简单的题：x + y = N，求x × y = S的最大值（x,y,N,S ∈ N+）。
		- 由题意可知，S = xy = x (N - x) = - x ^ 2 + Nx，为开口朝下的二次函数，顶点的横坐标为N / 2时，纵坐标S为最大值；
        - 又因为x,y,N,S ∈ N+，若N mod 2 = 0，x = y = N / 2，S为最大值；若N mod 2 = 1，x = N / 2 + 1,y = N /2。
        ![二次函数]( https://cdn.luogu.com.cn/upload/pic/64914.png )
	- 推广到a个数，S = x1 × x2 × x3 × ... × xa，N = x1 + x2 + x3 + ... + xa。**若N mod a = k（k ∈ [0,a)），则S最大时，x的取值有k个N / a + 1，有N - k个N / a**。

	- （[具体分析](https://www.luogu.org/blog/Singularwind/qiu-zui-da-zhi)）

2. 实现：

- 读入数的和sum，数的个数num；

- 计算并取整平均值avg（sum / num），以及余数renmainder（sum % num）；

- 输出num - remainder个平均数，输出remainder个平均数 + 1。

------------

# 代码

```cpp
#include <iostream>

using namespace std;

int main(void)
{
	int sum;
	int num;
	
	cin >> sum >> num;
	
	//平均数,取整
	int avg = sum / num;
	//余数
	int remainder = sum % num;
	
	for(int i = 0; i < num - remainder; i++)
	{
		cout << avg << " ";
	}
	for(int i = 0; i < remainder; i++)
	{
		cout << avg + 1 << " ";
	}
	
	return 0;
}
```


---

## 作者：Sunlight9 (赞：0)

这道题，说实话，勉强算一个数论基础题吧。
通过看数据范围，我么可以得出结论，暴力已经挂了。
看题解里的DALAO们说，这道题所涉及的数学知识是小学二年级学的，~~我怎么不记得我学过？~~。。。
### 知识很简单，要使M个数的乘积最大，就要是这M个数之间的相差最小。 ###
我所用的方法自我感觉比较容易懂，具体解释见代码吧。
``` cpp
/*乘积最大3  题解  By Rising Sunlight 
https://www.luogu.org/problemnew/show/P1887*/
#include<iostream>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
int n,m;
priority_queue <int,vector <int>,greater <int> > q;//STL中的小根堆，可以起到自动升序排序的功能，时间复杂度为O(nlog(n)) 
int main()										   //定义这个东西要引用queue头文件 
{
	scanf("%d%d",&n,&m);//输入 
	int nn=n,mm=m;
	for(int i=1;i<=m;i++)//这个地方有点贪心，我认为要使这M个数之间的差距最小，就是要把当前和为nn的数平均分成mm份 
	{					 //注意要向上取整，然后nn减去已经计算出来的x，因为已经分完了一次，所以mm-1 
		int x=(int)ceil(nn/mm);//ceil()为向上取整的函数，需引用cmath头文件，注意：本函数返回值为double类型，需强制类型转换 
		q.push(x);//进堆，进行堆排 
		nn-=x;  mm--;//进行处理 
	}
	for(int i=1;i<=m;i++)
	{
		int x=q.top();  q.pop();//每次去除最头上的数，然后扔掉 
		printf("%d ",x);//输出 
	}
	return 0;
}
```
##### 祝大家RP++; #####

---

## 作者：Soyilieber (赞：0)

发个题解，水一下

```pascal
var
    i,m,n:longint;
begin
    readln(n,m);
    for i:=n mod m to m-1 do
        write(n div m,' ');//输出同一个数
    for i:=0 to n mod m-1 do
        write(n div m+1,' ');//奇数个则 补数
end.
```

---

## 作者：doby (赞：0)

其实了解了基本方法之后，码出代码没难度……

首先，我们要了解均值不等式……

均值不等式是什么呢……很明显以我的姿势水平还讲不出这些东西……

当然你也可以认为是楼下说的**说白了就是一堆数加起来是定值，乘积最大就是都取平均值的时候**

当然有一个均值不等式的简化版：两个数的和相同，这两个数越接近，乘积越大……

然后把这个扩展开大概就是均值不等式了……

```cpp
#include<cstdio>
using namespace std;
int n,m,one,sum;
int main()
{
    scanf("%d%d",&n,&m);
    one=n/m,sum=one*m;//把n平均分
    for(int i=n-sum+1;i<=m;i++){printf("%d ",one);}//输出没有多的部分
    for(int i=1;i<=n-sum;i++){printf("%d ",one+1);}//多的部分
    return 0;
}
```

---

## 作者：jws666 (赞：0)

###**看到这道题目突然Excited!**

\_\_又为我复习了一下小学二年级的必修5！！！\_\_

有关一个叫均值不等式的东东

不知道什么是均值不等式的同学可以先了解一下基本不等式

不知道基本不等式的同学还可以了解一下完全平方式。。。。

要是还不知道，你们可以预习一下有关小学二年级的必修5教材。。

说白了就是一堆数加起来是定值，乘积最大就是都取平均值的时候

然后贴代码。。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<cstdlib>
#include<algorithm>
long long ans[1000005];
using namespace std;
int main()
{
    long long n,m,ave,sum=0;
    scanf("%lld%lld",&n,&m);
    ave=n/m;
    for(int i=1;i<=m;i++)
    {
        ans[i]=ave;
        sum+=ave;
    }
    for(int i=m;i>=m-n+sum+1;i--)
    {
        ans[i]++;
    }
    for(int i=1;i<=m;i++)
    {
        printf("%lld ",ans[i]);
    }
    return 0;
}
```
（浑然不知数组要开多大。。）


---

## 作者：WA小王子 (赞：0)

# Pascal题解好少啊，来一发

var n,m,c,d,e,f,g:longint;//个人喜欢开一大坨，不要介意。

ar:array[1..1000000]of longint;//最大有10^6个数，不然会炸

```cpp
begin
read(n,m);//读入
for c:=1 to m do
begin
ar[c]:=n div m;//把每个数赋值为n div m
end;
if n mod m<>0 then
begin
for c:=m downto m-(n mod m)+1 do//+1必须要，我被这卡了半天
begin
inc(ar[c]);//多余部分从后往前每个数+1
end;
end;
for c:=1 to m do
begin
write(ar[c],' ');//输出
end;
end.
//题目原理详见小学奥数……
```

---


# 进制转换

## 题目描述

今天小明学会了进制转换，比如 $(10101)_2$，那么它的十进制表示的式子就是 :

$$1\times 2^4+0\times 2^3+1\times 2^2+0\times 2^1+1\times 2^0$$

那么请你编程实现，将一个 $M$ 进制的数 $N$ 转换成十进制表示的式子。

注意：当系数为 $0$ 时，该单项式要省略。


## 说明/提示

对于 $100\%$ 的数据，$1<M<10$，$N$ 的位数不超过 $1000$ 且均为正整数。

## 样例 #1

### 输入

```
2 10101```

### 输出

```
1*2^4+1*2^2+1*2^0```

# 题解

## 作者：Ajwallet (赞：123)

**题目大意**

输入m，和一个m进制数，将它转换为用十进制表达的式子。

**注意！**

对于100%的数据，**1<M<10**，N的位数不超过1000

m<10我们就不需要去进行字母和数字的转换，直接用暴力模拟。

输入一个字符串，i从0到他的长度-1（c++）

当每一位不等于0，就输出对应的ci，m，i中间插上符号，如果不是最后一个，就加上+号。

**判断式1**

i==strlen(c)-1? '\n':'+'

**80分代码**

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int m;
char c[1001];
int main()
{
    scanf("%d ",&m);
    gets(c);
    for (int i=0;i<strlen(c);i++)    
     if (c[i]!='0')
      printf("%c*%d^%d%c",c[i],m,strlen(c)-i-1,i==strlen(c)-1? '\n':'+');
```
}//这种方法能过80分，因为有一种情况没有处理。
例如：

输入 2 10000

输出 1\*2^4+

我们发现，它不一定是最后一个才不需要加号，可能它后面没有数了。

所以，我们改变一下判断方法。改成下一次再判断，当它不是0并且不是第一个数是输出+号

**判断式2**

if(i!=0&&c[i]!='0') printf("+");

**AC代码**

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int m;
char c[1001];
int main()
{
    scanf("%d ",&m);
    gets(c);
    for (int i=0;i<strlen(c);i++)    
    {
     if(i!=0&&c[i]!='0') printf("+");
     if (c[i]=='0') continue;
      printf("%c*%d^%d",c[i],m,strlen(c)-i-1);
    }
}
```

---

## 作者：张皓涵 (赞：84)

## 我就只讲一个比较困扰大家的问题：多输出的加号
首先，不管怎么输入，输出总是多一个+号，这是毋庸置疑的。  
那么，将它删掉不就可以了吗？~~真不知道为什么大佬们要加辣么多判断，让我疑惑不解。~~
我们先将光标往前移一位，在输出一个空格，就好了。  
本段简单易懂的代码：

    cout<<(char)8<<(char)' ';

好了，讲完了，应该帮助大家解决了一个大问题吧！
~~求通过！！！~~

---

## 作者：zymooll (赞：53)

大家好，这是我第一次上传题解，请大家多多指教！


------------
最开始，我是这么打的，样例能过
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a;
	bool first=true;
	string b;
	cin>>a>>b;
	for(int i=b.size()-1;i>=0;i--){
		if(b[i]!='0'){
			if(first!=true)cout<<"+";
			cout<<b[i]<<"*"<<a<<"^"<<i;
			first=false;
		}
	}
	return 0;
}
```
但只有0分...
后来发现，在取特殊值时，例如“2 1010000”就不对了


------------
后来转念一想，样例正着反着看都一样，不会是打反了吧，一看真是，就改成了这样。
100分正解（请勿抄袭）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a;
	bool first=true;
	string b;
	cin>>a>>b;
	for(int i=0;i<b.size();i++){
		if(b[i]!='0'){
			if(first!=true)cout<<"+";
			cout<<b[i]<<"*"<<a<<"^"<<b.size()-i-1;
			first=false;
		}
	}
	return 0;
}

```
~~求通过~~啊


---

## 作者：KillerXu (赞：31)

进制转换的格式一定要看懂：

###n[i]转换为十进制的格式：n进制中的数\*进制^进制所在的位置-1（从右往左数）。

例如题中二进制10101，n[1]为1，进制为2，进制所在位置为5，那么格式为1\*2^4。

这个问题解决就意味着完成了80%，接下来就是输出的问题了。

我们可以先考虑输出不输出加号：

1.第一次转换输出不需要加号；

2是如果这项系数为0，那么也不需要输出加号，这个必须要判断，否则会出现两个加号连在一起的情况

那么接下来就可以放心大胆的输出单项式了。

```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    int i,jz,j;
    char n[1005];
    scanf("%d%s",&jz,n);//读入进制和进制下的数（注意，字符串不需要取地址符）
    for(i=0,j=strlen(n)-1;i<strlen(n);i++,j--)//i是为了指向每一位数，j是为了输出所在位置
    {
        if(i!=0&&n[i]!='0') printf("+");//判断是否第一项，是输出加号。当然如果系数为0也不需要输出
        if(n[i]!='0') printf("%c*%d^%d",n[i],jz,j);//判断系数是否为0，不是输出
    }
    return 0;
}
```

---

## 作者：_yjh (赞：30)

## **作为一位C++党，不用STL怎么行？**


------------
**阅读本题解大于需要 3-5min ，[$\color{lightgreen}{\text{My blog }}$](https://www.luogu.org/blog/yjhqinghua/solution-p2084) 阅读效果更佳。**
- - - - - - -
## **介绍一下萌新难以理解的知识点**

___1.队列___

使用 **queue(队列)** 的步骤
- 引入头文件 **<queue>**
  ```cpp
#include<queue>
``` 
- 定义一个 **任何类型的队列** (如int)
  ```cpp 
queue <类型名> 变量名;
``` 
- 使用 **库中的函数** 对其进行操作
  ```cpp
//基本操作
/*定义一个队列变量q*/
#1 q.push(变量); 将变量插入队尾
#2 q.pop(); 弹出队首的元素
#3 q.front(); 访问队首元素
#4 q.back(); 访问队尾元素
#5 q.empty(); 判断队列是否为空,是则返回true
#6 q.size(); 返回队中元素的个数
```
  
___2.判断是否在输入(适用于文件输入输出)___
  
  如果你用cin，你可以用 ```while(cin>>x)```
  
  如果你用scanf，你可以用 ```while(scanf>>x)```
  
 ------------
  
## **代码思路**(___~~几乎所有的坑我都踩过了QAQ~~___）
 
 **10pts** (暴力做法,此代码为改进80pts代码的错误示范)
  
  思路:没有什么好说的，主要是把答案存储到队列中，再输出。

___Code___
  ```cpp
#include<iostream>
#include<queue>
using namespace std;
int main()
{
	int n,x;
	cin>>n;
	char a;
	queue <char> q,qq;
	while(cin>>a!=0) q.push(a);
	x=q.size();
	while(!q.empty())
	{
		x--;
		if(q.front()!='0') 
		{
			if(x!='0') qq.push('+');
			qq.push(q.front());
			qq.push('*');
			qq.push(n+'0');
			qq.push('^');
			qq.push(x+'0');
		}
		q.pop();
	}
    if(qq.front()=='+') qq.pop();
	while(!qq.empty())
	{
		cout<<qq.front();
		qq.pop();
		if(qq.front()=='+'&&qq.size()==1) return 0;
	}
	return 0;
}
```

**50pts** (**出现一些奇怪的问题，例如少输出几个加号**)
  
  思路：同上，都是骗分的暴力做法
  
___Code___
  ```cpp
#include<iostream>
#include<queue>
using namespace std;
int main()
{
	int n,x;
	cin>>n;
	char a;
	queue <char> q,qq;
	while(cin>>a!=0) q.push(a);
	x=q.size();
	while(!q.empty())
	{
		x--;
		if(q.front()!='0') cout<<q.front()<<'*'<<n<<'^'<<x;
		if(x!=0&&q.front()!=0&&qq.back()!='+') 
		{
			cout<<'+';
			qq.push('+');
		}
		q.pop();
	}
	return 0;
}
```
**80pts** (**想到了接近AC解的东西，加了特判**)
  
思路：变计算边输出，但没有考虑到输入 ```101001000``` 的情况
  
  ___Code___
```cpp
#include<iostream>
#include<queue>
using namespace std;
int main()
{
	int n,x;
	cin>>n;
	char a;
	queue <char> q,qq;
	while(cin>>a!=0) q.push(a);
	x=q.size();
	while(!q.empty())
	{
		x--;
		if(q.front()!='0') 
		{
			cout<<q.front()<<'*'<<n<<'^'<<x;
			if(x!=0) cout<<'+'; //特判有问题
		}
		q.pop();
	}
	return 0;
}
```
**100pts** (**加入了正确的特判**)

  思路：经过冥思苦想，我想到的一种方法。
  ```cpp
首先用变量QAQ存储x进制数列的总值。
每次遇到非零的数，QAQ--，如果QAQ==0，说明后面全是零，不输出加号
```
  
___Show my Code(拒绝抄袭,共建和谐洛谷)___
```cpp
#include<iostream>
#include<queue>
using namespace std;
int main()
{
	int n,x,qaq=0;
	cin>>n;
	char a;
	queue <char> q,qq;
	while(cin>>a!=0) 
	{
		q.push(a);
		qaq+=(a-'0');
	}
	x=q.size();
	while(!q.empty())
	{
		x--;
		if(q.front()!='0') 
		{
			qaq--;
			cout<<q.front()<<'*'<<n<<'^'<<x;
			if(x!=0&&qaq!=0) cout<<'+';
		}
		q.pop();
	}
	return 0;
}
```


------------

  [AC记录](https://www.luogu.org/record/23798673) **用时29ms,内存780B**
  
  **我的艰辛历程：**
  ![](https://cdn.luogu.com.cn/upload/image_hosting/tt603l3q.png)
  

---

## 作者：May_Forever (赞：16)

首位不是0，所以先输出首位，剩下的只要输出就在前面输出加号。

代码就是模拟，没什么好解释的。


```cpp
#include<string>
#include<cstdio>
#include<iostream> 
using namespace std;
int n;
string st;
int main(){
    cin>>n>>st;
    printf("%c*%d^%d",st[0],n,st.size()-1);
    for(int i=1;i<st.size();++i)
        if(st[i]!='0')printf("+%c*%d^%d",st[i],n,st.size()-1-i);
}
```

---

## 作者：The_Key (赞：10)

一道模拟+找规律的题


只需要找数字中不为0的数输出就好，所以用字符串可能比较方便


```cpp
#include<iostream>
using namespace std;
string s;
int m,cur;
int main()
{
    cin>>m>>s;//输入数据
    for(int i=s.length()-1;i>=0;i--)//倒着字符串循环相当于正着从左到右
    if(s[i]!='0') //找到第一个非0数
    {
        cur=i;//储存下它的位置，便于下一步的输出
        break;
    }
    for(int i=0;i<s.length();i++)//正着循环数组输出，相当于倒着输出
    if(s[i]!='0'&&i!=cur)//如果这个数不是最后一个非0数那么输出的时候后边带着 “+”
    cout<<s[i]<<"*"<<m<<"^"<<s.length()-i-1<<"+";//很简单的一个规律
    else if(s[i]!='0'&&i==cur)//如果这个数是最后一个非0数那么输出时就不带“+”
    cout<<s[i]<<"*"<<m<<"^"<<s.length()-i-1;
    return 0; 
}
```

---

## 作者：落寞音箫 (赞：9)

/\*初次写代码，如有错误，请见谅

\*/
```cpp
#include<stdio.h>
int p(int k,int n,int m)//用这个函数来判断各个数字出现的次数 
{
    int s=0,i,j;
    for(i=n;i<=m;i++)
    {
        j=i;//用另一个变量避免影响到外层循环 
        while(j!=0)
        {
        if(j%10==k)s++;
        j/=10;
        }
    }
    return s;//返回的值就是要求的数 
}
int main()
{
    int m,n,i,j,s=0,a;
    scanf("%d%d",&n,&m);
    for(i=0;i<=9;i++)//从0~9一一输出 
    printf("%d ",p(i,n,m));
    return 0;
}
```

---

## 作者：AdzearDisjudge (赞：5)

这题开始很容易想到一个一个字符读入，但这样是没法输出指数的~

特别注意从第二个不为0的数开始要输出加号哦~

PS:楼下的楼下，您是如何认为c++写此题比pas繁……？


AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
int a;
bool b;
string c;
int main()
{
    cin>>a;
    b=true;
    cin>>c;
    for(register int i=0;i<c.size();++i)
    {
        if(c[i]=='0')
        continue;
        if(!b)
        cout<<'+';
        b=false;
        printf("%c*%d^%d",c[i],a,c.size()-i-1);
    }
    return 0;
}
//PS:%%%The Red Sun thx!!!
```

---

## 作者：Surpersolo (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1001];  
int n,len,total=0,p=0,h;            //len求输入的数字的长度，total表示数字串中的非0元素，h用来记录最后一位非0元素的位置
int main()
{
  cin>>n>>a;                              //注意a后面不加任何东西
  len=strlen(a);                          //求数组a的长度len
    for(int i=0;i<len;i++)
    if(a[i]!='0') total++;                   //计算非0元素的个数
     for(int i=0;i<len;i++) 
     {    if(a[i]!='0') 
   {  p++;if(p==total) h=i;}}            //每找到一位非0元素p++，当p==total时，说明是最后一位非0元素，用h记录当前的位置i    
     for(int i=0;i<=len-1;i++)           //输出
{      if(a[i]!='0'&&i!=h) {cout<<a[i]<<"*"<<n<<"^"<<len-1-i<<"+";}}         //i！=0是为了让它只输出a【h】前面的数，只是单纯的处理加号的问题.....
    cout<<a[h]<<"*"<<n<<"^"<<len-1-h;                                       //输出最后一位非0元素a【h】
return 0;                                 //完美结束！！！

}
```


---

## 作者：Ufowoqqqo (赞：2)

可以用array of char或ansistring做。

注意：很容易把指数写成chr(length(s)-i+48)，但当指数大于9时，这种作法是不可取的；应编写函数将其转为字符串。

```delphi

var
 m,i:longint;
 s,ans:ansistring;
 
function inttostr(n:longint):string;//Int to Str
begin
 str(n,inttostr)
end;

begin
 read(m);
 readln(s);
 delete(s,1,1);//输入时会把紧跟着数字后的空格也输进去
 ans:='';//ansistring初值比起其他类型更不稳定
 for i:=1 to length(s) do
  if s[i]<>'0' then ans:=ans+s[i]+'*'+chr(m+48)+'^'+inttostr(length(s)-i)+'+';
 write(copy(ans,1,length(ans)-1))//最后一个加号不输出
end.

```

---

## 作者：无语泽 (赞：2)

# 很多人说多输出的加号怎么办
###### 有人说cout<<(char)8<<(char)' ';~~可以~~
## 然而呢？ 。。。。
# 洛谷是用字符判断的
### ~~抄题解0蛋了吧~~
# 那怎么办呢？？？
### 你判断一下最后一个非0数在哪不就行了吗
好像打满了。。。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,la,s;
char a[1005];
int main()
{
    cin>>n;
    gets(a);
    la=1;
    t=strlen(a)-2;
    for(int i=0;i<strlen(a);++i)
    {
    	if(a[i]-'0')
    	s=i;
    }
    while(t>0&&la<s)
    {
        if(a[la]-'0')
        {
            cout<<a[la]-'0'<<'*'<<n<<'^'<<t<<"+";
		}
        ++la;
        --t;
    }
    cout<<a[la]-'0'<<'*'<<n<<'^'<<t;
    return 0;
}
```

---

## 作者：童年如作业 (赞：2)

这道题真是是有点儿坑，特别是在输出的时候，我多次坑在这里?\_?-\_-|||-\_-|||:-(
这里我决定用字符串，因为这样可以逐层输出，用 .size()可以求出循环次数o(≧v≦)o~~好棒

进入正题⊙﹏⊙b汗：

```cpp
#include <iostream>//头文件，不说了；
#include <string>//好像是关于字符的头文件；
using namespace std;
int main()
{
    int m,k,j;
    string n;
    cin>>m;
    getline(cin,n);//输入字符串；
    k=n.size();//记录字符串长度，用于循环（字符串从0计起）；
    j=k;//k值会变，j用于循环次数；
    int l=0;//标记；
    for(int i=1;i<j;i++)
    {
        k--;
        if(n[i]=='0')//跳过位数的值为0的；
        continue;
        if(l>0)
        cout<<"+"<<n[i]<<"*"<<m<<"^"<<k-1;//这里用个输出的小技巧；
        else
        {
            cout<<n[i]<<"*"<<m<<"^"<<k-1;
            l++;//标记+1;
        }
    }
    return 0;
}
```
做这题一定要好好看题，不然会被坑的o(>﹏<)o不要啊o(>﹏<)o不要啊！！！
拜拜~~~


---

## 作者：Jyf624761709 (赞：2)

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std; 
int main(){
    int s,m,t,i;//s是计算指数的，t是最后一个不为0的数减1
    char n[1005];
    scanf("%d ",&m);
    gets(n);
    s=strlen(n)-1;
    for(i=s;i>=0;i--)//如果一直循环到末尾，那末尾就多了一个+号，见下
        if(n[i]!='0'){
            t=i-1;
            break;
        }
    for(i=0;i<=t;i++){
        if(n[i]!='0'){
            printf("%c*%d^%d+",n[i],m,s);//t的作用
        }
        s--;//指数减1
    }
    printf("%c*%d^%d",n[i],m,s);
    return 0;
}
```

---

## 作者：fzj2007 (赞：1)

第一眼看到这个题，纯模拟呗。。不过还是有几个坑的

大家先看一眼这个代码~~
```
#include<bits/stdc++.h>
using namespace std;
//声明变量。。不用解释吧
int n,q=0;
string s;
int main(){
//读入数据不解释
	scanf("%d",&n);
	cin>>s;
    //循环查找
	for(int i=0;i<s.length();i++){
    //如果是0
		if(s[i]){
        //第一个不用输出‘+’
			if(q) cout<<'+';
            //输出
			printf("%c*%d^%d",s[i],n,s.length()-i);
            //标记
			q=1;
		}
	}
	return 0;
}

```
然后，把链接放上来
[哈哈哈哈](https://www.luogu.org/record/23178463)

这可以发现坑了吧，if(s[i])这里写错了，忘记是字符了。。
下面输出应该是s.length()-i-1

下面正确代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,q=0;
string s;
int main(){
	scanf("%d",&n);
	cin>>s;
	for(int i=0;i<s.length();i++){
		if(s[i]-'0'){
			if(q) cout<<'+';
			printf("%c*%d^%d",s[i],n,s.length()-i-1);
			q=1;
		}
	}
	return 0;
}

```
AC记录：[编程语言 C++ 代码长度 516B 用时 25ms 内存 804.00KB](https://www.luogu.org/record/23178714)

觉得有帮助请点赞，谢谢！


---

## 作者：Jacob233 (赞：1)

来一发题解。此题很简单，思维难度小。

注意在判断是否输出“+”时，先判断可以免去许多麻烦；

```cpp
#include<bits/stdc++.h>
using namespace std;
int m;
char n[2000];
int len;
int main(){
    cin>>m>>n;
    len=strlen(n);
    for(int i=0;i<len;i++){
        if(n[i]=='0')continue;
        if(i!=0&&n[i]!='0') cout<<"+";
        if(n[i]!='0')cout<<n[i]<<"*"<<m<<"^"<<len-i-1;
    }
    return 0;
}
```

---

## 作者：zhylj (赞：1)

不管后面有没有+

这样很难判断

但是只要判断开头没有用0就可以了

#include<bits/stdc++.h>

using namespace std;

/\*
很多人判断末尾的0

实际上只要判断在开头就可以了

\*/
```cpp
int main()
{
    char m,n[2000];
    scanf("%c%s",&m,n);
    for(int i=0;i<strlen(n);i++)
    {
        if(i!=0&&n[i]!='0') printf("+");    //如果不是第一个就输出'+'
        if(n[i]!='0')
            printf("%c*%c^%d",n[i],m,strlen(n)-i-1);    //输出式子 
    }
    return 0;
}
```

---

## 作者：ljc20020730 (赞：1)

一道考细心的好题。

提交7次，终于AC。（丢脸）

本题求k进制下的字符串S转成十进制的算式

应该大家初赛都学习过 ，在此不在赘述，如果你连这个都不知道，呃呃呃……

再强调一遍：

```cpp
设S[i]；
2（进制）       1          0           1           0           1 （数S）
转为十进制：S[I]*2^4  S[I]*2^3  S[I]*2^2  S[I]*2^1  S[I]*2^0
```
就是这样赘述（划掉）

23333333……

但是注意，你不小心就丢了20分

看下第三个测试点：

input#3

```cpp
2 1100100000
```
output#3

```cpp
1*2^9+1*2^8+1*2^5
```
八十分的亲们，是不是您们的末尾有个‘+’？

所以我们要采取措施，我这里采取的是判断末尾有几个零

详见程序：

```cpp
var  m,n,t,i,p,k:longint;
     s:ansistring;
     a:array[1..1000]of longint;
begin
 read(m);
 readln(s);
 delete(s,1,1);
 if s='0' then begin writeln('0'); halt; end;
 k:=length(s);//从后往前，K初始化
 while (k>1)and(s[k]='0') do dec(k);//求出K值，k表示在S的第K位时是最后一个非0的数
 for i:=1 to length(s) do a[i]:=ord(s[i])-ord('0');
 t:=length(s);//计数器
 for i:=1 to length(s) do begin
   dec(t);//每次减1
   if (a[i]<>0) then begin
   write(a[i],'*',m,'^',t);//若果S[i]非0则打印
   if (i<>length(s))and(i<>k) then write('+');//i=k时不打印
   end;
 end;
 writeln;//换行
end.
```

---

## 作者：Xsy123456 (赞：1)

###纯模拟，可以升到N>=10带入字母的情况

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

int n,l;
char m[1000+5];

int main(){
    
    scanf ("%d%s",&n,&m);
    
    l=strlen(m)-1;
    for (int i=l;i>=0;i--){//忽略后方一堆0
        if (m[i]=='0')
          l--;
        else
          break;  
    }
    for (int i=strlen(m)-1,j=0;i>=0,j<=l;i--,j++){
        if (m[j]!='0'){//由于忽略了后面结尾的零，只要判断非零即可
          printf ("%c*%d^%d",m[j],n,i);
          if (j!=l)//最后一个部署出“+”
            printf ("+");
        }    
    }
      
    return 0;
    
}
```

---

## 作者：PTC06 (赞：1)

此题不是特别难，主要注意一下加号就可，用C++会比Pascal难一些（原因代码中有），于是我机智的用了Pascal（嘎嘎嘎）于是代码如下：

var s,st,s1,s2,s3:ansistring;    //必不可少的定义变量，注意需要用ansistring

```cpp
    i,p,place:longint;
begin
  readln(s);        //输入
  p:=pos(' ',s);        //找里面第一个空格，方便后面找出需要转换的数字
  s1:=s[1];        //将输入的数是用什么进制的记录一下
  s2:=copy(s,p+1,length(s));    //将需要转换的数字copy出来
  for i:=1 to length(s2) do            //循环
    begin
      place:=length(s2)-i;            //找出这是第几位，用于判断应该这个数字的进制应该^几
      if s2[i]<>'0' then                   //如题，如果此项不为零才输出
        begin
          str(place,st);         //这一步用来将它是第几位转换成字符串，这样才能添加到s3里面（也可用自定义函数实现，这步用C++很麻烦，因为itoa函数并不属于标准c语言函数，在LG的编译器里用不了，会显示运行错误）
          s3:=s3+s2[i]+'*'+s1+'^'+st+'+';          //添加到s3里面
        end;
    end;
  if s3[length(s3)]='+' then delete(s3,length(s3),1);     //去掉最后一个加号
  writeln(s3);   //最后输出
end.
```

---

## 作者：modaimo (赞：1)

>**LJY:本题是MY和LJY花了几十分钟搞这个字符串搞出来的**
>**MY:希望给大家一种new思路。**
···pascal

uses sysutils;         //要搞一个很诡异的字符串类型，所以前面要uses一下

```cpp
var n,i:longint;
    a:ansistring;      //很诡异的字符串，就不用数组了哈哈
begin
  read(n);
  readln(a);
  delete(a,1,1);
  for i:= length(a) downto 1 do 
    begin
       if a[length(a)-i+1]<>'0' then 
        begin
           if i<>length(a) then write('+');
           write(a[length(a)-i+1],'*',n,'^',i-1);
        end;
    end;
end.
···
```

---

## 作者：Ackoter (赞：1)

这道题很简单

直接通过规律输出就行了

本人新手，有不对的地方请告诉我

```cpp
#include<cmath>
#include<iostream>
#include<cstring>
using namespace std;
int a,b,c;
string st;//数字要用string来存，因为可能很大
int main()
{
        cin>>a>>st;//输入
        b=st.size();//求数的长度
        for(int i=0;i<st.size();i++)
            if(st[i]!='0') c++;//找出有几个0
        for(int i=0;i<st.size();i++)
        {
                b--;//第b个数要b-1次方，所以我们要把b不断的减1
                if(st[i]!='0')
                {
                        c--;//这个用来判断是否是最后一个数字
                        cout<<st[i]<<'*'<<a<<'^'<<b;//直接输出式子
                if(c!=0) cout<<'+';//判断是否是最后一个数字，是的话就不输出加号连接
             }
        }
        return 0;
}
```

---

## 作者：HohleFeuerwerke (赞：0)

~~由于最近s没考好，信心受挫，开始来水红题，同时也是希望自己t1不要写错~~

这题挺适合string入门的。~~当然用char数组我也无可厚非~~

如果不会STL的string，珂以移步[这篇博客](https://www.cnblogs.com/lanclot-/p/11142202.html)。

#### 前置知识

本题需要的只是不多，只要熟悉string的成员函数和模拟的一些技巧等等。

#### 正文

我们珂以把一些字符组合成一个小型串：“+x*y^4”

本题需要判断一些小点：  
1、如果是第一个，不需要写‘+’  
2、如果系数是0，不需要写  
3、string的下标从0开始

具体见代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n;//将其转为n进制，注意此处和原题定义不同
string str;//待转换的数
bool flag=false;//是否是第一个，待会儿会用到，此处false代表是第一个，不需要输出。
int main(){
	ios::sync_with_stdio(false);
	cout.tie(0);cin.tie(0);//以上两行为优化
	cin>>n>>str;//读入
	for(int i=0;i<str.length();i++){//注意，下标从0开始
		if(str[i]!='0'){//如果不是0再输出
			if(flag==true)cout<<"+";//如果不是第一个需要输出
			flag=true;//这里用法：由于第一遍循环flag还是false，只有第一遍循环后才会变为true，所以直接这么写就好惹qwq
			cout<<str[i]<<"*"<<n<<"^"<<str.length()-i-1;//输出除了加号外的小型串
		}
	}
	return 0;//结束
}
```

本题是string入门好题，珂以尝试一下强大的stl带给我们的便利。

---

## 作者：gdjcwsk (赞：0)

废话不多说，先上代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
	long long k;
	char a[1000];//提示：本题数位很大，不推荐使用unsigned long long，且数位不超过1000，所以把字符串设成1000位
	cin>>k>>a;//把k进制与k进制的数a输入进去
	int l=strlen(a);//位数这个东西很有用，后面代码要用
	for(int i=0;i<l;i++)//进入核心区域，i为输出的指数
	{
		if(a[i]!='0')//这一步不能漏，要考虑a[i]等不等于0
		{
			if(i==0)
			{
				cout<<a[i]<<"*"<<k<<"^"<<l-1-i;
			}
			else
			{
				cout<<"+"<<a[i]<<"*"<<k<<"^"<<l-1-i;
			}
		}
		else
		{
			continue;
		}
	}
	return 0;
}

```
本题比较坑，重点是要有字符串的思路。

思考出这一点，就可以解出整个题目。

这就是本蒟蒻的解题思路，因为第一次发，难免会有些不足，欢迎大家指正，批评

---

## 作者：小哈_yike (赞：0)

数组惨案

第一次没看清范围，数组开了1..100，前三个数据直接运行错误0.0

这题用数组做代码还是蛮简单的。

代码说明如下：

```cpp
var     m,s,i:longint;
    a:array [1..1000] of char;          //数组惨案
    ch:char;
begin
  read(m); s:=0;                            //读入m，不多阐述
  read(ch);                                    //将m后的空格读掉，如果不读的话，数组将往后移一位
  repeat                                        //读n的代码
    inc(s);                                       //s既可以控制下标后移，也可以统计位数，一举两得
    read(a[s]);                                //一位一位读
  until eoln;                                 //直到换行
   write(a[1],'*',m,'^',s-1);             //先把第一个输出（至于为什么，如下），因为第一个肯定不是0，所以不用担心
  for i:=2 to s do                          //开始输出后面的                       
     if a[i]<>'0' then write('+',a[i],'*',m,'^',s-i);                 //为了不让后面多加个+，把+放在了前面
end.
```

---

## 作者：PauGasol (赞：0)

比较坑人的点：

1.不要输出多余的加号

//然后你就想要最后一位单独输出，于是：

2.最后出现的0；

其实仔细想想，第一位肯定不是0；

那就先输出第一位，然后每输出一位前面加’+‘就可以了。

···cpp

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
using namespace std;
int n;
char a[10001];
int main()
{
    scanf("%d %s",&n,a);
    int str=strlen(a);
    cout<<a[0]<<"*"<<n<<"^"<<str-0-1;//输出第一位
    for(int i=1;i<str;i++)
    {
        if(a[i]!='0')cout<<"+"<<a[i]<<"*"<<n<<"^"<<str-i-1;//here
    }
    return 0;
}
```
···

---


# 弹珠游戏

## 题目描述

MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏——超级弹珠。

游戏的内容是：在一个 $n \times n$ 的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方。

## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$1\leq n\leq 10$；

对于 $100\%$ 的数据，$1\leq n\leq 1000$，保证容身之地的数量小于 $10000$，保证每个位置敌人的数量不超过 $1000$。

## 样例 #1

### 输入

```
4
1 1 1 0
1 1 1 1
1 1 1 1
0 1 1 1```

### 输出

```
6```

# 题解

## 作者：蒟蒻狗子two (赞：281)

## 我竟然AC了


像我这样的暴力做法也能过？

#### ~~一定是数据的问题~~，不然我这个蒟蒻一定TLE

好了，上代码

```cpp
#include<bits/stdc++.h>     //万能头文件 
using namespace std;
int main(){
	int n;
	cin>>n;
	int a[n][n],sum[n*n]={0};      //sum用来记录矩阵每一个容身之处的分数 
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			cin>>a[i][j];
		}
	}
	int aa=0;              //因为不知道一共有多少个sum，所以用aa计数 
	for(int i=0;i<n;i++){       //在矩阵中找无敌人的地点 
		for(int j=0;j<n;j++){
			if(a[i][j]==0){
				for(int k=0;k<n;k++){
					sum[aa]+=a[k][j];   //统计所在列获得的分数 
				}
				for(int k=0;k<n;k++){
					sum[aa]+=a[i][k];   //统计所在行获得的分数 
				}
				aa++;      //统计完一个点的分数后使用数组的下一位进行存储 
			}
		}
	}         //sort真好用 
	sort(sum,sum+n*n,greater<int>());     //把每个点获得的分数从大到小排序 
	cout<<sum[0]<<endl;         //输出最大分数 
	return 0;
}
```


### ~~蒟蒻在这里无耻的求个赞~~

---

## 作者：我没有小白 (赞：90)

贪心？只是枚举找最大值吧。。。
这道题你直接加好每一行每一列就好了，然后取一个最大值，bool一个变量判断是否有0，如果有，那么就输出不好的游戏

代码如下
```cpp
#include<bits/stdc++.h>//万能库，建议大家noip别用，刷题可以 
using namespace std;
int n,s[5000][5000],maxn;
bool u=0;
int NOIRP(int x,int y)
{
	int ans=0;
	for(int i=1; i<=n; i++)
		if(s[x][i])
			ans+=s[x][i];
	for(int i=1; i<=n; i++)
		if(s[i][y])
			ans+=s[i][y];
	return ans;
}//加和每一行每一列 
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			cin>>s[i][j];
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			if(!s[i][j])
				u=1,maxn=max(NOIRP(i,j),maxn);//找最大值 
	if(!u)
		cout<<"Bad Game!";
	else
		cout<<maxn;
}
//完结撒花 
```
管理大大求过，小妹谢谢咯

---

## 作者：飞翔 (赞：44)

[h1 ]题解[h1 ]

经典的枚举加贪心。。。

我们可以设f1，f2为1..1000的数组记录每一行、每一列的值和，a为1..1000，1..1000的数组记录题目的输入（开longint）。

o(n\*n)轻松秒过……

标程来也……(pascal)

要不要把我的代码框起来呢？算了吧，让大家方便抄吧！

```cpp
var
  a:array[1..1000,1..1000]of longint;
  f1,f2:array[1..1000]of longint;
  i,j,n,ans:longint;
function max(x,y:longint):longint;
begin
  if x>y then exit(x) else exit(y);
end;
begin
  fillchar(f1,sizeof(f1),0);
  fillchar(f2,sizeof(f2),0);
  ans:=0;
  readln(n);
  for i:=1 to n do
  begin
    for j:=1 to n do
    begin
      read(a[i,j]);
      f1[i]:=f1[i]+a[i,j];
      f2[j]:=f2[j]+a[i,j];
    end;
    readln;
  end;
  for i:=1 to n do
    for j:=1 to n do
      if a[i,j]=0 then ans:=max(ans,f1[i]+f2[j]);
  write(ans);
end.
孩纸们，给个赞吧！
```

---

## 作者：塔罗兰 (赞：39)

史上最短20行此题题解！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005][1005],ma;
int main()
{
	scanf("%d",&n);
	for(int i(0);i<n;i+=1)
	for(int j(0);j<n;j+=1)
	scanf("%d",&a[i][j]);//输入
	for(int i(0);i<n;i+=1)
	for(int j(0);j<n;j+=1)
	if(!a[i][j])//若这里是容身之地
	{
		int sum(0);
		for(int k(0);k<n;k+=1)
		sum+=a[i][k]+a[k][j];//暴力求可得分数
		ma=ma>sum?ma:sum;//相当于max(ma,sum),不过听说会快一点
	}
	printf("%d",ma);
}
```
这里对sum+=a[i][k]+a[k][j];作一解释。

原来是要把行可得分数和列可得分数分开计数并特判自己位置

但是我发现两者互不影响可以合并(然并卵)。

至于特判,因为容身之地本来就不能得分,所以可以去掉

小提醒:一个格子可以有多个敌人~~挤在一起~~,不要天真地用+=1

注:由于一些小优化,本题解比半数AC代码快100ms~300ms不等(快夸我!)

---

## 作者：installb (赞：31)

###用不到二维数组的

###只要记录每行每列的和

###以及每个0的位置


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int x[10005]={0},y[10005]={0},n,m,count = 0;
//x,y 是每个"容身之地"的坐标，count为其个数 
int flag = 0;// 记录有没有"容身之地"
int maxn = -1;
int main(){
    int hang[1005]={0},lie[1005]={0}; 
    //保存每行每列的和 
    cin >> n;
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= n;j++){
            scanf("%d",&m);
            hang[i] += m; 
            lie[j] += m; //把值加上去 
            if(m == 0){  //有"容身之地" 
                count++;//"容身之地"个数加一
                x[count] = i;
                y[count] = j; //保存x y 
                flag = 1;
            }
        }
    }
    if(flag == 0) printf("Bad Game!\n");//没有"容身之地"
    if(flag == 1){
        for(int i = 1;i <= count;i++){
            if(hang[x[i]] + lie[y[i]] > maxn)
                maxn = hang[x[i]] + lie[y[i]]; //计算每个没有"容身之地"的行列之和 
        }
        cout << maxn << endl;
    }
    return 0;
}
```

---

## 作者：ziiidan (赞：18)

这是本人的第一篇题解，哪里写的不好请见谅


这道题的正常思路思路很简单：

1）暴力（出奇迹）

2）先预处理再找点

我看到这道题的时候，发现这道题写暴力的话没有什么考点

so,我选择了写一个二维前缀和（二维前缀和是个很有用的东西，也是以后学OI中很常见的部件之一）

做题的步骤代码如下

（二维前缀和在本题中简化了下）


```cpp
#include<iostream>
#include<cstdio>

using namespace std;

const int maxn=1e3+5;

int n;
long long ans;
int a[maxn][maxn],s[maxn][maxn];        // s表示前缀和数组
bool flag=false;                        //flag用来表示有没有位置可以放

void init()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++) for(register int j=1;j<=n;j++) scanf("%d",&a[i][j]);
    for(register int i=1;i<=n;i++) for(register int j=1;j<=n;j++) s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//二维前缀和的预处理，不多解释
}

long long cal(int i,int j)
{
    return s[i][n]-s[i-1][n]+s[n][j]-s[n][j-1];//这个函数为个人习惯，也可以直接放到主函数里，但我认为那样看起来会比较难看
}

int main()
{
     init();//用来预处理的函数
     for(register int i=1;i<=n;i++)
       for(register int j=1;j<=n;j++)
       {
           if(!a[i][j]) flag=true,ans=max(ans,cal(i,j));//找点，并求出最佳的方案   flag用来表示有没有位置可以放
       }
     if(!flag) cout<<"Bad Game!"<<endl; //特判有没有能放的点
     else cout<<ans<<endl;
    return 0;
}

```



这道题就结束了。。

P.S:二维前缀和是未来学习的基础之一

---

## 作者：yuzhechuan (赞：15)

```cpp
#include <bits/stdc++.h>//万能库
using namespace std;
int ans=-1,n,a[1001][1001];//注意ans的初值
int read()//读入优化
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		a[i][j]=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		if(a[i][j]==0) 
		{
			int x=0;
			for(int k=1;k<=n;k++)
				x+=a[i][k]+a[k][j];//临时变量x记录行标为i，列标为j的分值总和
			ans=max(ans,x);//取最大值
		}
	if(ans==-1)cout<<"Bad Game!";//如果ans还是负数就代表没有容身之地
	else cout<<ans;//否则输出最大值
}
```

---

## 作者：hongzy (赞：12)

用SumI记录第i行的和，SumJ记录第j列的和

如果(i,j)为0，那么SumI[i] + SumJ[j]就是能打的敌人数

因为(i,j)为0,所有它们有一个点重复没关系

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int A[1001][1001], F; //F:判断是否有0
int SumI[1001], SumJ[1001]; //第i行的和，第j列的和
int N, ans;

int main() {
    scanf("%d", &N);
    for(int i=1; i<=N; i++)
        for(int j=1; j<=N; j++) {
            scanf("%d", &A[i][j]);
            SumI[i] += A[i][j];
            SumJ[j] += A[i][j];
            if(!A[i][j] && !F) F = true;
        }
    if(!F) { //没有0
        printf("Bad Game!\n");
        return 0;
    }
    for(int i=1; i<=N; i++)
        for(int j=1; j<=N; j++)
            if(!A[i][j] && SumI[i] + SumJ[j] > ans)
                ans = SumI[i] + SumJ[j]; //最优解 
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：優柔_寡斷 (赞：12)

# **本蒟蒻的第一篇题解**：
这道题还是很水的

于是我又过了一道难（shui）题

暴力即可。

想说的都在代码里了：
```
#include<iostream>
#include<cmath>
#include<algorithm>
//..懒得写万能头系列（虽然这几个都没什么用）
using namespace std;
int n,x=-10000;//定义变量 注意x的值一定要小一点
int count;
int a[1001][1001];//定义一个二维数组
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];//输入数据
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]==0){
            //如果有值为0 视为可以落脚 进入循环
				for(int q=1;q<=n;q++){
					count+=a[q][j]+a[i][q];
                    //将落脚点所在行列分别累加
				}
				x=max(x,count);
               //取x和count的最大值 取最大的一个落脚点的数
				x=0;//x记得更新 不然会炸
			}
		}
	}
	if(x==-10000) {
    //如果x没有被取最大值 就是没有落脚点
		cout<<"Bad Game!";
		return 0;
        //直接输出
	}
	else cout<<x;
    //有落脚点就可以愉快的输出了。。
	return 0;
}
```
-------------（华丽的分界线）------------

求关注的蒟蒻。。
（逃.......

---

## 作者：呼啸山庄 (赞：5)

通过两个数组记录各行各列的分数，再用一个结构体记录所有可放弹珠的点

将Ans初始化为-1，枚举各个可放的点，求MapX[Could[i].X]+MapY[Could[i].Y]最大值

当没有弹珠可放时，不会枚举，Ans为-1此时Bad Game！




```cpp
#include<cstdio>
int MapX[1500],MapY[1500],N,Ans = -1,Nc = 0;
struct Can{
    int X;
    int Y;
}Could[10000];
int main(){
    scanf("%d",&N);
    for(int i = 1;i <= N;i++){
        for(int j = 1;j <= N;j++){
            int Tmp;
            scanf("%d",&Tmp);
            if(Tmp){
                MapX[i]+=Tmp;
                MapY[j]+=Tmp;
            } else {
                Could[Nc].X = i;
                Could[Nc++].Y = j;
            }
        }
    }
    for(int i = 0;i < Nc;i++) 
        Ans = Ans < MapX[Could[i].X]+MapY[Could[i].Y] ? MapX[Could[i].X]+MapY[Could[i].Y]:Ans;
    if(Ans != -1) printf("%d",Ans);
    else printf("Bad Game!");
    return 0;
}
```

---

## 作者：JimmyF (赞：3)

    
~~哈哈，小学生又来发题解啦！~~    

这题很简单，这题的确很简单，这题真心很简单。好吧，不说废话了，这题就查找0的位置，然后横竖两个方向查找1的个数，并取最大值输出。

### 代码：
    
```
#include<bits/stdc++.h>   //文件头
using namespace std;
int n,h,d,f[1010][1010];  //定义
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
    scanf("%d",&f[i][j]); //输入
    for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
    if(!f[i][j])          //是0才查找
    {
        h=0;              //总数清0
        for(int k=1; k<=n; k++)
        h+=(f[i][k])+(f[k][j]);  //是1就++
        d=max(d,h);       //取最大值
    }	 
    printf("%d",d);       //输出
    return 0;
}
```

好啦，今天就讲到这里啦，我们下期再见！

---

## 作者：_Int_ (赞：2)

```cpp
#include < cstdio > // 个人习惯加
#include < iostream > // cin & cout
#include < con > // 万能头文件~~嘻嘻
using namespace std;
int n /*题意*/ , ac [ 1005 ] [ 1005 ] /*吉利*/ , ans /*结果*/ , cut /*计数器*/ ;
bool ok ; // 是否有解
int main ( ) { // 主程序开始
    cin >> n ; // 读入 n
    for ( int i = 1 ; i <= n ; i++ )
    for ( int j = 1 ; j <= n ; j++ )
    cin >> ac [ i ] [ j ] ; // 按顺序读入
    for ( int i = 1 ; i <= n ; i++ ) {
        for ( int j = 1 ; j <= n ; j++ ) {
            if ( ! ac [ i ] [ j ] ) { // 如果没有敌人
                cut = 0 ; // 归零
                for ( int ii = 1 ; ii <= n ;  ii++ ) cut += ac [ ii ] [ j ] ; // 依次加上同行的
                for ( int jj = 1 ; jj <= n ; jj++ ) cut += ac [ i ] [ jj ] ; // 依次加上同列的
                if ( cut > ans ) ans = cut ; // 如果更大，变变变~~~
                ok = 1 ; // 有解了
            }
        }
    }
    if ( ok ) cout << ans ; //我原本用的是 if ( ! ans )，但发现有一个点过不了
    else cout << "Bad Game!" ; // 糟糕！
    return 0 ; // 走人
}
```

---

## 作者：zr太弱了 (赞：1)

~~看到楼下红名大佬们的各种玄学算法，蒟蒻ssfd~~本题思路较简单，按照题意做即可，看起来像贪心，然而只需要把所有可能的值枚举出来再和当前最大值比较就出来了，二维数组就能简单过，其他注释放代码里了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1010][1010],i,j,k,b,maxx=-1,sum=0;//其实本题的数据规模，把数组开在main函数里也可以
bool flag=false;
int main(){
    cin>>n;
    for(i=1;i<=n;i++)
    {
    	for(j=1;j<=n;j++)
    	{
    		cin>>a[i][j];
			if(a[i][j]==0)
				flag=true;//如果有容身之地，就记录下来
		}
	}
	if(flag==false)//输入完如果还没有容身之地，就特判输出
	{
		cout<<"Bad Game!";
		return 0;
	}
	for(i=1;i<=n;i++)//行 
    {
    	for(j=1;j<=n;j++)//列 
    	{
    		if(a[i][j]==0)//可能的容身之地
    		{
    			for(k=1;k<=n;k++)
    				sum+=a[i][k];//模拟行
				for(k=1;k<=n;k++)
					sum+=a[k][j];//模拟列
				if(sum>maxx)//比较
					maxx=sum;
				sum=0;//归零
			}
		}
	}
	cout<<maxx;
    return 0;
}
```


---

## 作者：peiyangsong (赞：1)

# P2356 弹珠游戏 #

## 题目描述 ##


MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏——超级弹珠。

游戏的内容是：在一个 n*n 的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方。

## 输入输出格式 ##
### 输入格式 ###
输入有两行，第一行一个正整数 n，接下来 n 行，每行 n 列，如果有敌人则为一个正整数，否则为 0

### 输出格式 ###
输出共一行，最多分数，如果连你的容身之地都没有，请输出“Bad Game!”

### 输入输出样例 ###


输入样例#1： 

4

1 1 1 0

1 1 1 1

1 1 1 1

0 1 1 1

输出样例#1： 

6


## 数据范围 ##

对于 30%的数据，1≤n≤10

对于 100%的数据，1≤n≤1000，保证容身之地的数量小于 10000


## 程序 ##

    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    const int N=11000;
    
    int n/*正方形边长*/,a[N][N]/*点阵数组*/,max/*最大值*/,num=0;
    
    //该数组用于记录可占位置的横（.x）纵（.y）坐标 
    struct node{
    	
    	int x,y;
    	
    }b[N];
    
    int main(){
    	
    	//读入并赋初值 
    	scanf("%d",&n);
    	
    	for(int i=1;i<=n;i++){
    		
    		for(int j=1;j<=n;j++){
    			
    			scanf("%d",&a[i][j]);
    			
    			if(a[i][j]==0){
    				
    				num++;
    				
    				b[num].x=i;  b[num].y=j;
    				
    			}
    			
    		}
    		
    	} 
    	
    	//特判：若无立身之处 
    	if(num==0){
    		
    		printf("Bad Game!");
    		
    		//不必再进行后续循环，直接结束main函数 
    		return 0;
    		
    	}
    	
    	//循环 
    	int x,y,t;
    	
    	max=0;
    	for(int i=1;i<=num;++i){
    		
    		//简化变量 
    		x=b[i].x;  y=b[i].y;
    		
    		//暴力枚举 
    		t=0;
    		for(int j=1;j<=n;++j){
    			
    			t+=a[j][y];  t+=a[x][j];
    			
    		}
    		
    		//比较大小 
    		if(t>max)  max=t;
    		
    	}
    	
    	//输出 
    	printf("%d\n",max);
    	
    	return 0;
    	
    } 





## 算法 ##
1. 模拟（暴力枚举）
2. 数组

	此题中b数组的引入是为了**减少循环次数**

## 注意 ##


> if语句进行特判时，最好加入“return 0；”语句。


2019/6/24 23:19:02 

---

## 作者：F_S_R_M (赞：1)

#### 这个题还可以吧（经典开头语）
#### 思路简介清晰明了，保证一看就懂
**思路**

1、两层for循环输入一个整数

2、如果这个数是正整数（也就0>0），就将他累加入他所在的行和列的所设的数组中（这句话有点绕口），这样就求出来了所有行和列的数的和。

3、如果这个数不是正整数，就将他的行和列记录在一个一维数组中，下面枚举的时候好枚举。

4、枚举所有的一维数组记录的行和列，将行和列的和加起来找最大的。

**是不是很奇怪是怎么记录在一个一维数组中的，仔细看**

将一维数组的第一个记录行，第二个记录列，每次加2。看代码应该会看懂↓
# 代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int hang[1001],lie[1001],a[20001];  //hang[]来记录每一行的和，，
int o=1;                          //lie[]记录每一列的和
int maxn=0;						//a[]来记录不是正整数所在的行和列 
int main()
{
	int n;
	cin>>n; 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int q;
			cin>>q;					//输入
			if(q>0)					//如果是正整数就累加
			{
				hang[i]+=q;			//数组，累加行
				lie[j]+=q;			//数组，累加列
			}
			else				//如果输入的不是正整数
			{
				a[o]=i;			//第一个元素记录行
				a[o+1]=j;			//第2个元素记录列
				o+=2;			//每次加2
			}
		}
	}
	int s=0;
	for(int i=1;i<=o-2;i+=2)   //←每次加2，因为有两个元素：行、列 
	{
		s=hang[a[i]]+lie[a[i+1]];  //将所在行和列累加 
		if(s>maxn)					//找出最大的 
		maxn=s;
	}
	cout<<maxn;						//输出最大的 
	return 0;
}
```


---

## 作者：Wh_Xcjm (赞：1)

一道水题。。 正解就是暴力

有个坑点。注意程序中的标记处，一开始我写的是++，也就是+=1，得了10分，看好像有不少人和我一样的错，审题不仔细。。题目是求“他们的分数之和”，而真正的输入数据并不是像坑人样例那样全是1的，“输入有两行，第一行一个正整数 n，接下来 n 行，每行 n 列，如果有敌人则为一个正整数，否则为 0”，输入的是“正整数”，所以数值累计的也是正整数。（~~话说输入应该有n+1行~~）
---
附我的程序：
```cpp
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
#define mp(a,b) make_pair(a,b)
typedef long long ll;
typedef pair<ll,ll> pll;
const ll maxn=1005;
long long l[maxn],r[maxn],a,b,n,ans;
queue<pll> que;
int main(){
    scanf("%d",&n);
    for(ll i=0;i<n;i++)
        for(ll j=0;j<n;j++){
            scanf("%d",&a);
            if(a){l[j]+=a;r[i]+=a;}		//我是标记
            else{que.push(mp(i,j));}
        }
    if(que.empty()){
        puts("Bad Game!");
        return 0;
    }
    while(!que.empty()){
        a=que.front().first;
        b=que.front().second;
        que.pop();
        ans=max(ans,r[a]+l[b]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：KingX (赞：1)

看到大多数题解的$n^2$复杂度

甚至看最优解也是极度卡常过的$n^2$

如果数据大一点就不适合了

我来一个发$nm$的复杂度的题解，m是0存在的个数

我用vector来记录0所存在的坐标

因此不需要进行$n^2$的枚举来在此找到搜索的起始点

直接用读入的时候vector记录的点

这样复杂度就可以大幅度减少了

## 代码
```cpp
#include<bits/stdc++.h>
#define maxn 1005
using namespace std;
int n,top;
int a[maxn][maxn];
struct data{
	int x,y;
};//结构体
vector<data>q;//vector储存
int main()
{
	int ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		scanf("%d",&a[i][j]);
		if(a[i][j]==0) q.push_back((data){i,j});//读入的时候就记录0所在的坐标
	}
	if(q.empty())//直接用STL判断是否是无解
	{
		printf("Bad Game!");
		return 0;
	}
	for(int i=0;i<q.size();i++)//优化的重点
	{
		int x=0;
		for(int j=1;j<=n;j++)
		x+=a[q[i].x][j]+a[j][q[i].y];//记录 和其他题解一样
		ans=max(ans,x);
	}
	printf("%d",ans);//输出
}
```
希望对大家有帮助

---

## 作者：maozi (赞：1)

简单的行列叠加 然后标记每一个容身之地的点 然后跟新最大值

下面是代码！！


```cpp
#include<iostream>
using namespace std;
#define max(x,y) (x>y? x:y)
int a[11000],b[11000],x[100000],y[100000];
int main()
{
    int n;
    cin>>n;
    int d;
    int e=0;
    int flag=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
        {
            cin>>d;
            if(d==0)//标记出现的坐标
            {
                x[e]=i;
                y[e]=j;
                e++;
                flag=1;
            }
            a[i]+=d;//行的叠加
            b[j]+=d;//列的叠加
        }
    //for(int i=0;i<e;i++)
    //    cout<<b[i]<<" "<<a[i]<<endl;
    if(flag==0)
    {
        cout<<"Bad Game!"<<endl;
        return 0;
    }
    int ma=0;
    for(int i=0;i<e;i++)  //过滤出每一个容身之地的
        ma=max(a[x[i]]+b[y[i]],ma);//更新
    cout<<ma<<endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

其实这道题非常水啊，好像不会像下面说的那样会超时什么的，代码如下：

```cpp

#include <iostream>
using namespace std;
int a[1001][1001]; //方阵
int b[10001]; //有0的地方
int main()
{
    int n;
    cin>>n;  //不用scanf吧
    bool sf=true,sf1=true; //判断用的
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {cin>>a[i][j];if(a[i][j]==0)sf=false;else sf1=false;} //输入，如果有0的话更改参数，有1也更改
    if(sf==true){cout<<"Bad Game!"<<endl;return 0;}
    if(sf1==true){cout<<"0"<<endl;return 0;} //判断能不能提前退出
    int s=0; //用来存储有几个可用的位置，排序时用
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==0)
            {
               s++;
                   for(int u=1;u<=n;u++)
               b[s]+=a[i][u]; 
               for(int u=1;u<=n;u++)
               b[s]+=a[u][j]; //计算出它所在的当行当列的数字总和，因为自己位置的数字是0，所以不用去掉
            }
        }
    }
    for(int i=1;i<=s;i++)
    for(int j=i+1;j<=s;j++)
    {
        int t;
        if(b[i]<b[j])
        {
            t=b[i];
            b[i]=b[j];
            b[j]=t;
        }
    }  //用冒泡来排序，当然其他排序法也可以，把最多的那个放在下标为1的位置上
    cout<<b[1]<<endl; //打印
}

```

---

## 作者：Neil1110 (赞：1)

一开始想的是直接算每个是0的地方分数和，后来感觉会超时，于是改成了再输入的时候，直接统计某行某列的综合，这样省时间，而且看起来更简洁。用一个ok变量来存是否有房弹珠的地方。之后用一个循环来统计出分数和最大的一个0处，然后输出。还有一个需要注意的地方就是，用cin的话，好像会有两个点超时，但改成scanf之后就快了许多。

```cpp

#include<iostream>
#include<cstdio>
using namespace std;
int map[1005][1005]={0};
int main()
{
    int n,Max=0,i,j,htot[1005]={0},ltot[1005]={0},ok=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
        {
            scanf("%d",&map[i][j]);
            if(map[i][j]==0)
                ok=1;
            htot[i]+=map[i][j];
            ltot[j]+=map[i][j];
        }
    if(ok==0)
    {
        cout<<"Bad Game!";
        return 0;
    }
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
        {
            if(map[i][j]==0)
            {
                if(htot[i]+ltot[j]>Max)
                    Max=htot[i]+ltot[j];
            }
        }
    printf("%d",Max);
    return 0;
}

```

---

## 作者：FR_qwq (赞：1)

这题用贪心？？？

不用，只要枚举每一个数然后求最大就行了。

我们可以将每一个数进行判断，如果它为0（容身之地），那就把可以从那里得到的分数相加，然后求出得到总分数最大的分数，输出，完美的结束程序。

相加方法如下：
```pascal
for k:=1 to n do
  s:=s+a[i,k];{相加行（s：累加器），如果是容身之地，也没分可加}
for k:=1 to n do
  s:=s+a[k,j];//相加列
```
但是，如果用以下方法，就错了：
```pascal
for k:=1 to j-1 do
  s:=s+a[i,k];
for k:=i+1 to n do
  s:=s+a[k,j];
```
这样会导致一些分加不到，如：

2 2 2 2

2 2 2 2

2 2 2 2

0 2 2 2

这只有一个容身之地：最后一行第一列，按上述代码，一个分数也没有被加到，所以好得用第一个程序段来相加
~~（我原来就是用第二个来做的）~~。

这是你们最喜欢的AC代码：
```pascal
var i,n,j,k:longint;
s,max:int64;
a:array[1..1000,1..1000] of longint;
f:boolean;
begin
readln(n);
for i:=1 to n do
  for j:=1 to n do
    begin
    read(a[i,j]);//输入不用说了吧
    if a[i,j]=0 then
      f:=true;//判断是否有容身之地
    end;
if f=false then
  begin
  writeln('Bad Game!');
  halt;
  end;//如果没有，那么就输出Bad Game，结束程序。
for i:=1 to n do
  for j:=1 to n do
    begin
    s:=0;
    if a[i,j]=0 then
      begin
      for k:=1 to n do
        s:=s+a[i,k];
      for k:=1 to n do
        s:=s+a[k,j];
      end;//用到了上面第一个程序段
    if s>max then max:=s;//求最大
    end;
writeln(max);//输出也不用说了吧
end.完美结束
```

---

## 作者：摸鱼 (赞：1)

####  这一题是一道典型的dp题，但是我们可以用各种思想处理这道题
- 前置知识点

1.前缀和:比较广泛出现在代码中，可以用来求前k个数的和，略过不讲

2.矩阵前缀和：用来存一个以(1,1)为起点，(x,y)为终点的矩阵之和，当然也可以通过各种操作来处理更多的题目，基础代码如下:

------------
```cpp
sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]
//a[i][j]代表(i,j)的值
//sum[i][j]代表以(1,1)为起点，以(i,j)为终点的矩阵和
```
------------
如果有不懂的可以通过画图来自行理解这段代码。

- 题目

似乎刚刚的知识点根本没办法扯到题目中去啊
先来看题：求(i,j)权值为零时，第i行与第j列之和。

- 解题

1. 我们要先判断是否有格子权值为零

2. 我们要求出最大值//因为(i,j)为零所以不用去重

我们先来维护一下矩阵前缀和，如果矩阵之和等于矩阵元素数（n*n）那么输出Bad Game

------------
```cpp

	if(sum[n][n]==n*n){
		printf("Bad Game!");
		return 0;
	}
```
------------
然后我们要求出每一行和每一列的和，这里我们只要用(i,j)与(i-1,j)做差就能求出第i行的值；

同理，我们只要用(i,j)与(i,j-1)做差就能求出第j列的值；

代码实现如下：


------------
```cpp

	for(register int i=1;i<=n;++i){
		a[i][0]=sum[i][n]-sum[i-1][n];//第i行的和
		a[0][i]=sum[n][i]-sum[n][i-1];//第j列的和
	}
```


------------
然后穷举所有i，j即可：

参考代码如下：


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum[1010][1010],a[1010][1010],n,ans;
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			scanf("%d",&a[i][j]);
			sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		}
	}
	if(sum[n][n]==n*n) {
		printf("Bad Game!");
		return 0;
	}
	for(int i=1; i<=n; ++i) {
		a[i][0]=sum[i][n]-sum[i-1][n];
		a[0][i]=sum[n][i]-sum[n][i-1];
	}
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			if(!a[i][j]) {
				ans=max(ans,a[i][0]+a[0][j]);
			}
		}
	}
	printf("%d\n",ans);
}
```


---

## 作者：倾城ファン恋 (赞：1)

首先读入，然后将每个点都穷举一遍记录下每个立足点的杀死敌人的总和，如果比原来的ans要大，就更新一遍


时间复杂度O（n\*n）


挺水的，贴代码，DON'T COPY****


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int a[1005][1005],n;
int work(int x,int y)//给定每个x,y的坐标，计算出和
{
    int sum=0,xx,yy;
    for(xx=x;xx<=n;xx++)
    {
        if(a[xx][y])sum+=a[xx][y];//**大坑**，并不是敌人仅仅为1！！！
    }
    for(xx=x;xx>=1;xx--)
    {
        if(a[xx][y])sum+=a[xx][y];
    }
    for(yy=y;yy>=1;yy--)
    {
        if(a[x][yy])sum+=a[x][yy];
    }
    for(yy=y;yy<=n;yy++)
    {
        if(a[x][yy])sum+=a[x][yy]; 
    } 
    return sum;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);//华丽丽的读入
        }
    }
    int ans=0,sum=0;
    for(int i=1;i<=n;i++)//把每个点枚举一遍
    {
        sum=0;
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==0)//如果可以立足
            {
                sum=work(i,j);
                if(sum>ans)//更新操作
                {
                    ans=sum;
                }
            }
        }
    }
    cout<<ans<<endl;//华丽丽的输出
    return 0; 
}
```

---

## 作者：qscqesze (赞：1)

维护一个每一行的和是多少，每一列的和是多少

预处理O(n)

查询O(1)

详情可以查看我的代码

```cpp

int c[maxn][maxn];  
int sum1[maxn];  
int sum2[maxn];  
int main()  
{  
    int n;  
    RDI(n);  
    REP_1(i,n)  
    {  
        REP_1(j,n)  
        {  
            RDI(c[i][j]);  
            sum1[i]+=c[i][j];  
            sum2[j]+=c[i][j];  
        }  
    }  
    int ans=0;  
    REP_1(i,n)  
    {  
        REP_1(j,n)  
        {  
            if(c[i][j]==0)  
                ans=max(ans,sum1[i]+sum2[j]);  
        }  
    }  
    cout<<ans<<endl;  
  
}  

```

---

## 作者：stry (赞：0)

算法呢，这题可以看成一道二维数组的题目，逐个查找，
是0的就可以每一行每一列的加起来，因为0的地方是没敌
人的，所以要先判断是否是0，不是才能加起来，而且还
要判断是不是最大的，输出最大的。
代码如下： 
```
#include<iostream>
#include<fstream>
#include<algorithm>

using namespace std;
int a,gw,da=-210000000;//da=-210000000是为了判断最大，而且也是为了判断能不能有位。 
int aa[1005][1005]; //本人的好习惯，多定义几个位置，以防数组爆 。 
int main()
{
    cin>>a;//输入矩阵大小。a*a大小 
	for(int i=0;i<a;i++)
	{
		for(int j=0;j<a;j++)//二维数组需要用2个for，第一个定i第二个不能定i，所以定j。 
		{
			scanf("%d",&aa[i][j]);//因为最大的情况是1000*1000=1000000>100000，所以为了不TLE所以使用scanf来输入。 
		}
	} 
    for(int i=0;i<a;i++)
	{
		for(int j=0;j<a;j++)//逐数组位枚举 
		{
		if(aa[i][j]==0)//判断是否是空位，不是不运行，是才运行if里的程序。 
		{
		for(int k=0;k<a;k++)//在前面因为有了i和j，所以定k 
		{
			gw+=aa[i][k];//枚举所在那一行的敌人的敌人个数 
		}
		for(int k=0;k<a;k++)
		{
			gw+=aa[k][j];//枚举所在那一列的敌人的敌人个数
		}	
		}
		if(gw>da){da=gw;}//判断这个位能击败的敌人个数是否大于最大能击败的敌人个数，大于的话就更新大。 
		gw=0;//敌人数清0. 
		}
	} 
	if(da==-210000000){cout<<"Bad Game!";}//判断有没有位置，没有输出Bad Game!。 
	else{cout<<da;} //否则输出最多能击败敌人的个数。 
    return 0;
    //严禁抄袭程序！！！！ 
}
```




---

## 作者：Dorbmon (赞：0)

## 为什么大家都这么不喜欢用Vector?完美模拟出了地图啊。又因为重载，和普通数组使用差不多。不是挺好吗。。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ui unsigned long long
vector<vector<int>> datas;
struct position {
    int x;
    int y;
};
int main () {
    ios::sync_with_stdio(false);
    int n;
    cin >> n;
    //暴力计算
    for(int i = 0;i < n;i ++) {
        vector<int> temp;
        datas.push_back(temp);
        for(int a = 0;a < n;a ++) {
            int temp = 0;
            cin >> temp;
            datas[i].push_back(temp);
        }
    }
    //搜索０的位置
    vector<position> positions;
    for(int i = 0;i < n;i ++) {
        for(int b = 0;b < n;b ++) {
            if(datas[i][b] == 0) {
                position temp;
                temp.x = i;
                temp.y = b;
                positions.push_back(temp);
            }
        }
    }
    if(positions.empty()){
        cout << "Bad Games" << endl;
        return 0;
    }
    //vector<int> scores;
    int max_scores = 0;
    for(auto ptr = positions.begin();ptr != positions.end();ptr ++) {
        //计算分数
        int temp = 0;
        for(int i = 0;i < n;i ++) {
            temp += datas[(*ptr).x][i];
        }
        for(int i = 0;i < n;i ++) {
            temp += datas[i][(*ptr).y];
        }
        if(temp > max_scores) {
            max_scores = temp;
        }
    }
    cout << max_scores << endl;
    return 0;

}
```


---

## 作者：皮皮虾letusgo (赞：0)

这题不难，只要进行一个判断，再求和，比大小就行了。

水水水O(∩\_∩)O哈哈~

0.0 =.=

上代码：

```cpp
#include <iostream>
using namespace std;
int main ()
{
    int n;
    cin>>n;
    int a[n+1][n+1];
    for (int i=1;i<=n;i++)//读入
    for (int j=1;j<=n;j++)
    cin>>a[i][j];
    bool ok=0;
    for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)
    if (a[i][j]==0) ok=1;
    if (!ok) cout<<"Bad Game!"<<endl;//判断是否输出BG（话说貌似没这个数据点）
    else {
    int ans=-1;
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            if (!a[i][j])//有立足点
            {
                int s=0;
                for (int u=1;u<=n;u++)//行求和
                s+=a[i][u];
                for (int u=1;u<=n;u++)//列求和
                s+=a[u][j];
                if (s>ans) ans=s;//比大小
            }
        }
    }
    cout<<ans<<endl;//输出
    }
    return 0;
}
```
结束！！！
<.>

---

## 作者：ACzidongji (赞：0)

/\*
其实跟楼下差不多,只不过冒泡变成快排,读入输出变成了优化版

\*/
```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <stack>
#include <queue>
#include <fstream>
#include <set>
#include <vector>
#include <list>
#include <deque>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cctype>
using namespace std;
//楼上全部是库,个人喜好
inline int read()
```
/\*
读入优化函数

原理如下:

利用字符读入

\*/
```cpp
{
    int p,data=0;
    char ch=0;
    while ((ch!='-') && ch<'0' || ch>'9')//判断是不是数字,不是数字就是符号
        ch=getchar();
    if (ch=='-')//如果是负数
    {
        p=-1;//符号矢量为-
        ch=getchar();
    }
    else
        p=1;//否则符号矢量为正数
    while (ch>='0' && ch<='9')
        data=data*10+ch-'0',ch=getchar();//一边加上读入的数,一边读入
    return data*p;//值乘上符号矢量
}
inline void write(int x)
```
/\*
输出优化函数

原理如下:

不断递归输出字符

\*/
```cpp
{
    if(x<0)
        putchar('-'),x=-x;//如果是负数,先要大于负号然后取反为正数
    if(x>9)
        write(x/10);//递归输出
    putchar(x%10+'0');
}
int cmp(int a,int b)//降序排序
{
    return a>b;
}
int main()
{
    static int n,i,j,u,a[1001][1001],b[10001];
    n=read();
    bool sa=true,s2=true;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
        {
            a[i][j]=read();//读入   
            if(a[i][j]==0)//有落脚点 
                sa=false;
            else 
                s2=false;//没有落脚点 
        }
    if(sa==true)//预处理 
    {
        cout<<"Bad Game!"<<endl;
        return 0;
    }
    if(s2==true)//预处理 
    {
        cout<<"0"<<endl;   
        return 0;
    }
    int s=0;
    for(i=1; i<=n; i++)
    {
        for(j=1; j<=n; j++)
            if(a[i][j]==0)
            {
                s++;
                for(u=1; u<=n; u++)
                    b[s]+=a[i][u];
                for(u=1; u<=n; u++)
                    b[s]+=a[u][j]; 
            }
    }
    sort(b+1,b+1+s,cmp);
    write(b[1]);
}
```

---

## 作者：_xcc_ (赞：0)

这道题应该是入门难度吧，数据太水，

完全无任何优化的暴力都可以过，不超时，

而且没有输出“Bad Game!”的数据点。

主要思路是枚举每一个点，计算此点所在的行、列数据之和。

```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,i,j,u,s,maxx=-9999;//s是存放和的，maxx存放最大值（定义max会莫名其妙地编译错误） 
    cin>>n;
    int a[n][n];
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            cin>>a[i][j];
        }
```
}//读入
```cpp
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            if(a[i][j]==0){//不能和敌人在一个地方
                s=0;//记得先归零！ 
                for(u=0;u<n;u++) s+=a[i][u];//累加此点所在的行数据之和
                for(u=0;u<n;u++) s+=a[u][j];//累加此点所在的列数据之和
                //这里因为此点总是0，不用考虑重复算了 
                if(s>maxx) maxx=s;//更新最大值 
            }
        }
```
}//枚举每个点
    if(maxx!=-9999) cout<<maxx<<endl;

        else cout<<"Bad Game!"<<endl;//其实这里的判断不写也可以AC 

    return 0;

}

---

## 作者：Ufowoqqqo (赞：0)

#题解

输入时统计第i行可以获得的分数将其表示为row[i]，同理还有表示列的col[j]。

枚举位置找最大，按题目要求输出相应内容。

最坏情况下的耗时约为O((10^6)\*2)，不超时。

```delphi

var
 n,i,j,max:longint;
 score:array [1..1000,1..1000] of longint;
 row,col:array [1..1000] of longint;
 t:boolean;
begin
 readln(n);
 fillchar(row,sizeof(row),0);
 fillchar(col,sizeof(col),0);
 for i:=1 to n do
 begin
  for j:=1 to n do
  begin
   read(score[i,j]);
   inc(row[i],score[i,j]);
   inc(col[j],score[i,j])
  end;
  readln
 end;
 max:=-maxlongint;
 t:=false;
 for i:=1 to n do
  for j:=1 to n do
   if (score[i,j]=0) and (row[i]+col[j]>max) then
    begin
     max:=row[i]+col[j];
     t:=true
    end;
 if t then writeln(max) else writeln('Bad Game!')
end.

```

---

## 作者：树下 (赞：0)

#暴力出奇迹，对拍保平安。贪心水题。直接计算就好，上代码：

```cpp
**#include<bits/stdc++.h>**//万能头文件
using namespace std;//记得别忘加了
int oo,tot,n,a[1005][1005],k;//定义
int sjy(int x,int y){
    oo=0;
    for(int i=1;i<=n;i++)    oo+=a[x][i]+a[i][y];
    return oo;
```
}//计算分值
```cpp
int main(){
    scanf("%d",&n);//输入n值
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    scanf("%d",&a[i][j]);//输入n*n的方阵
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    if(a[i][j]==0)//判断是否能放数    tot=max(tot,sjy(i,j)),k=1;//k为特判，tot始终取最大值
    if(k==0)    printf("Bad Game!");//如果没有能放数的地方
    else        printf("%d",tot);//输出最大值
}
```

---


# Uim的情人节礼物·其之弐

## 题目描述

前传：详见洛谷 P2525

Uim 成功地按照顺序将礼物送到了 $N$ 个妹子的手里并维持她们的和谐。

现在 Uim 想知道，他最终选择的顺序是所有给 $N$ 个妹子送礼顺序中，字典序第几小的。送礼顺序可以看作 $1,2,\cdots,N$ 的一个排列。

## 说明/提示

$1\le N \le 9$。

请注意输入的排列没有空格。

## 样例 #1

### 输入

```
3
231```

### 输出

```
4```

# 题解

## 作者：顾z (赞：71)

~~因为某人@ZAGER挖坑让我讲一下康托展开,所以发现了这个题,顺便说一下康托展开是个什么东西~~

**题目概括**

给定n与一个数列,要求求出给定数列在n的全排列中的排名(按照字典序从小到大排列)

**康托展开**

先放**概念**:

康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。
--来源于[度娘](https://baike.baidu.com/item/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/7968428?fr=aladdin)

~~双射的概念我也不是很理解~~

所以直接给出**康托展开的作用**:

康托展开的作用是求n个数的全排列中某一个序列在所有排列中的次序(该排列次序(亦称之为排名)以字典序从小到大排序)

还是不理解?

**栗子：**

   求:在n=3的全排列中,{1,3,2}排第几位。
 
 可以写出n=3的全排列 {1,2,3}，{1,3,2}，{2,1,3}，{2,3,1}，{3,1,2}，{3,2,1}
 
 (在这里我们按照字典序从小到大排序)

所以容易看出{1,3,2}   Rank 2

如果还是不理解请打开上面的'度娘'↑,里面有详细解释

**康托展开的公式**:
      
   X=a[n] * [(n-1)!] +a[n-1]*[(n-2)!]+....+a[1] * [0!]。
   
其中X代表当前排列小的排列的个数,

a[i]代表当前排列里从i位置右侧比i位置的数小的数的个数。

**详细解释；**
            
       在n=5的全排列中,计算{3,4,1,5,2}的康托展开值。

       首位是3,则小于3的数有两个,为1和2,a[5]=2,则首位小于3的所有排列组合为a[5]*(5-1)!

       第二位是4,则小于4的数有两个,为1和2,注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2。

       第三位是1,则在其之后小于1的数有0个,所以a[3]=0。

       第四位是5,则在其之后小于5的数有1个,为2,所以a[2]=1。

       最后一位就不用计算啦,因为在它之后已经没有数了,所以a[1]固定为0.

     根据公式：
          rank=2*(4!)+2*(3!)+0*(2!)+1*(1!)+0*(0!)=61.

     所以比{3,4,1,5,2}小的组合有61个,即{3,4,1,5,2}排名62。

以上内容来自[度娘](https://baike.baidu.com/item/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/7968428?fr=aladdin)+个人认为.

所以就这么多了,还有一个逆康托展开,没有怎么学，网络上讲这个的还是不少的,想继续学的可以自行找寻度娘的~

---------------代码--------------

```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
const int fac[]={1,1,2,6,24,120,720,5040,40320,362880};//阶乘 
char s[108];
int n; 
IL int Contor(char s[],int n)
{
	int ans=0;
	for(RI i=0;i<n;i++)
	{
		//std::cout<<ans<<std::endl;
		int smaller=0;
		for(RI j= i+1 ;j<n;j++)
		{
			if(s[i] > s[j])smaller++;
		}
		ans += smaller*fac[n-i-1];
	}
	return ans+1;
}
int main()
{
	std::cin>>n;
	std::cin>>s;
	std::cout<<Contor(s,n);
}
 
```


---

## 作者：zhylj (赞：28)

C++STL里面的函数：next\_permutation制造下一个全排列

利用这个函数，制造一个新的数组从{1,2,……n}开始到{a1,a2,……an}

一旦新的数组和输入的数组相同，输出。

如样例

3
231
```cpp
1 2 3
1 3 2
2 1 3
2 3 1
```
故为4

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool bj(int *a,int *b,int n)
{
    for(int i=0;i<n;i++)    //一个一个比较两个数组是否相同
        if(a[i]!=b[i]) return false;
    return true;
}
int main()
{
    int n,a[10000],b[10000],s=1;
    scanf("%d",&n);    //读入n
    for(int i=0;i<n;i++)
        scanf("%1d",&a[i]);    //读入数组a
    for(int i=0;i<n;i++)
        b[i]=i+1;    //b数组赋值为{1,2……,n}
    while(!bj(a,b,n))    //如果两个数组不相同
    {
        next_permutation(b,b+n);   //制造下一个全排列
        s++;    //计数
    }
    cout<<s<<endl;    //输出答案
    return 0;
}
```

---

## 作者：菜弟弟在此 (赞：22)

作为一个看不懂函数库的蒟蒻，还是选择了老老实实打深搜。

其实这题也是比较简单的，打个全排列，一样输出就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long a[10],b[10],n,m,k,ans=0;
bool c[10];
bool pig2()
{
    ans++;  //个数加一
    for (long i=1;i<=n;i++)
        if (a[i] != b[i]) return false;  //判断是否相同
    return true;
}
void pig(long t)
{
    if (t > n) 
    {
        if (pig2()) cout<<ans<<endl;  //满足条件输出 
        return;
    }
    for (long i=1;i<=n;i++)
        if (! c[i])
        {
            b[t]=i;  
            c[i]=1;  //搜索
            pig(t+1);
            c[i]=0;  //回溯
        }
}
int main()
{
    long i;
    cin>>n;
    cin>>k;
    for (i=n;i>=1;i--)  //分解
    {
        a[i]=k%10;
        k/=10;
    }
    memset(c,false,sizeof(c));
    pig(1); 
        while (1) 
    return 0;
}

```
**while(1)是防抄袭**


---

## 作者：引领天下 (赞：16)

思路：

用 STL 中的全排列函数 `prev_permutation`，不断求上一个字典序，同时累加；

如果求不了了，说明这就是第一个字典序，就可以输出了。

`prev_permutation` 用法：

函数的两个参数为内存中的一段连续空间的起点和终点，每次调用都将指定内存中的值修改为上一个字典序，如果当前排列已是第一个，返回“`false`”。

与之相对的，`next_permutation` 用于求下一个字典序。

AC 代码：

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;//流读入要的一句话
int n,ans;//n是个数，ans是答案
char a[15];
//由于输入没有“ ”，且n<=9，所以a[i]一定是一位数，用char才行
int main(void){
    ios::sync_with_stdio(false);//流优化
    cin>>n;
    for (int i=0;i<n;i++)cin>>a[i];
    while (prev_permutation(a,a+n))ans++;//如果函数返回值为0，就会退出，不然不断求上一个字典序，ans同时累加
    cout<<ans+1;//该顺序也算一个，所以ans要加1（ans是之前的字典序数量）
}
```

---

## 作者：血色黄昏 (赞：9)

P2525AC后趁热打铁水一片py的神题解

大家可能不知道，不光C++有求字典序前一个的，我们py也有个神奇的库叫itertools，可以求全排列QAQ

下面详情见代码~

```python
import itertools#一个神奇的库，用来弄全排列
n = int(input())#输入
li = input()#输入
re = []
for i in range(n):
    re.append(li[i])#将数字转成['a', 'b']的类型
l = list(itertools.permutations(re, n))#全排列函数
l = sorted(l)#排序
for i in range(len(l)):
    if list(l[i]) == re:#匹配就输出
        print(i + 1)
        break
```
时间复杂度O(n!）QAQ最后一个点260ms

~~求通过~~

---

## 作者：wzmszjw (赞：9)

可以看作数学题，如果当前是一个数字x  那么未用过的数字的比它小的呆在当前位置的全排列都在这个前面，于是可得出答案。

```cpp
#include<cstdio>  
using namespace std;  
int n;  
long long ans;  
char a[10];  
bool h[10];  
int c[10];  
int N;  
int main(){  
    scanf("%d",&N);  
    scanf("%s",a+1);  
    c[0]=1;  
    for(int i=1;i<=9;i++) c[i]=c[i-1]*i;  
    for(int i=1;i<=N;i++){  
        int p=0;  
        for(int j=1;j<a[i]-'0';j++){  
            if(!h[j]) p++;  
        }  
        h[a[i]-'0']=true;  
        ans+=p*c[N-i];  
    }  
    printf("%lld",ans+1);  
}
```

---

## 作者：Ryo_Yamada (赞：7)

这题还是用STL中的 `prev_permutation`,详情见 [[题解 P2525] Uim的情人节礼物·其之壱](https://www.luogu.com.cn/blog/juruo12345/post-ti-xie-p2525-uim-di-qing-ren-jie-li-wu-ji-zhi-post)。

其中有一点，是它的字典序输入不带空格。于是可以循环char输入，或者字符串输入，再循环求值。我用的是char。

上代码：

```cpp
#include <bits/stdc++.h>//prev_permutation在<algorithm>里
using namespace std;
int a[9];
int cnt = 1;/*计数，需要注意的是它 = 1。
  比如输入为：3 123时，是第一个而不是第零个。
  */
int main() {
	int n;
	cin >> n;//输入，不用说了吧
	for(int i=0; i<n; i++) {
		char c;
		cin >> c;//char只有一个字符，不用担心
		a[i] = c - '0';//记录数字
	}
	while(prev_permutation(a, a + n)) {//当他还有上一个字典序排列时，计数++。
		cnt++;
	}
	cout << cnt;//输出
	return 0;完结撒花
}
```


---

## 作者：不存在之人 (赞：2)

**其实没有空格也是很容易解决的——只要用字符串读入。然后存。其实就是康托展开。题目说的很明显，就是字典序。**

**我得说当初学的时间没有认真学。还得去研究一下。**

### 代码如下：
```cpp
#include<cstdio>  
#include<cmath>  
#define ff(i,s) for(int i=s;i<n;i++)//宏定义，据说可以压缩代码，但我没看出。
using namespace std;
int n,number=1,z=1,tot=1,a[10],t;
int main()
{
    scanf("%d",&n);//其实完全没必要有n，只需要用strlen（）函数就行了。还有表在意用ch来表示字符串。
    char ch[10];
    scanf("%s",&ch);
    ff(i,0)a[i]=ch[i]-48;//数字=机内存储数-48或-‘0’
    for(int i=n-2;i>=0;i--)//好，下面就是康托展开。其实就是一位一位的计算。和就是字典序。
    {
        number=number*(z++);
        t=0;
        for(int j=i+1;j<n;j++)
        {
            if(a[j]<a[i])
            t++;
        }
        tot+=t*number;
    }
    printf("%d",tot);
}
```

---

## 作者：Invoker (赞：1)

题意就是给定全排列问为第多少个，那么直接求康托展开是很显然的。

另外数据量非常小，可以直接dfs全排列或者使用next\_permutation。

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<string>
#include<iostream>
#include<cstdlib>
#include<algorithm>
#define for0(i,a,b) for(int i=(a);i<=(b);++i)
#define for1(i,a,b) for(int i=(a);i>=(b);--i)
#define pb push_back
#define LL long long
const int oo=0x3f3f3f3f;
using namespace std;

inline int read()
{
    int x=0;
    int f=1,hhh=getchar();
    while(!isdigit(hhh))
    {
        if(hhh=='-')
            f=-1;
        hhh=getchar();
    }
    while(isdigit(hhh))
    {
        x=x*10+hhh-'0';
        hhh=getchar();
    }
    return x*f;
}


int fac[99];
int n;
int s[99];

int KT()
{
    int sum=0;
    for0(i,0,n-1)
    {
        int t=0;
        for0(j,i+1,n-1)
           if(s[j]<s[i])
                ++t;
        sum+=fac[n-i-1]*t;
    }
    return sum;
}

int main()
{
    string ss;
    cin>>n;
    fac[1]=1;
    for0(i,2,n)
        fac[i]=fac[i-1]*i;
    cin>>ss;
    for0(i,0,n-1)
        s[i]=ss[i]-'0';
    printf("%d",KT()+1);
    return 0;
}
```

---

## 作者：lky1433223 (赞：1)

~~嗯对这个题很水~~
-->C++ STL 大法好

### 先来说一下这次要用到的函数吧：
[prev_permutation](http://www.cplusplus.com/reference/algorithm/prev_permutation/?kw=prev_permutation)(下一个全排列)

它的功能：

把两个迭代器（或指针）指定的部分看作一个序列，求出这些元素构成的全排列中，字典序排在上一个的排列，并且直接在序列上更新。另外，若不存在排名更靠前的序列，则返回false，否则返回true。同理，也有next_permutation函数。
									
                                    --《算法竞赛 进阶指南》

那么，具体怎么用呢。for example：

```cpp
while(prev_permutation(data+1,data+n+1))
```
只要有上一个全排列，它就会循环下去√

至于[next_permutation](http://www.cplusplus.com/reference/algorithm/next_permutation/?kw=next_permutation)（下一个全排列）,使用和prev_permutation一样，在此就不赘述了。


### 现在来看这道题：

用prev_permutation找回去就好了呀！
上AC代码
```cpp

#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC target ("avx2")
//以上是玄学优化
#include<bits/stdc++.h>
using namespace std;
int n;
int data[10];
int ans;
inline void test()
{
    for(register int i = 1; i <= n; i++)
        cerr<<data[i]<<" ";
    cerr<<endl;
}
//调试使用的函数，可以忽视，不过看看过程总是好的；
int main()
{
    freopen("testdata.in","r",stdin);
    std::ios::sync_with_stdio(false);
    //关同步，小程序懒得写快读；
    cin>>n;
    int x = 0;
    cin>>x;
    //这个读入是有坑的，因为读入是一个整型，所以需要转换到数组里；
    //当然可以用getchar()实现
    for(register int i = 1; i <= n;i++)
    {
        data[i] = x % 10;
        x /= 10;
    }
    //倒着找到每一位
    reverse(data+1,data+n+1);
    // STL 的翻转函数，倒转一个序列；
    while(prev_permutation(data+1,data+n+1))
        ans++,test();
    cout<<ans+1;
    //因为当前序列也算所以++；
    return 0;
}
```

什么？你想复制代码？不存在的你A不了的，因为我下坑了，hhh。




---

## 作者：tryrtj (赞：1)

90的
```
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int a[11],b[11];string s;int n;bool g=false,g1=false;
void ert(){
	int c[15];
	for(int i=0;i<n;i++){
		c[i]=b[i];
	}
	sort(c,c+n);
	for(int i=0;i<n;i++){
		if(c[i]!=i+1)break;
		if(i==n-1){
			g1=true;
			return;
		}
	}
	return;
}
void qwe(){
	for(int i=0;i<n;i++){
		if(a[i]!=b[i])break;
		if(i==n-1)g=true;
	}
	return;
}
void asd(){
	for(int i=0;i<n;i++){
		if(b[i]>n){
			b[i]-=n;
			b[i-1]++;
			asd();
			return;
		}
	}
	return;
}
int main(){
	cin>>n;
	cin>>s;
	for(int i=0;i<s.length();i++){
		a[i]=s[i]-'0';
	}
	for(int i=0;i<s.length();i++){
		b[i]=i+1;
	}
	int zong=1;
	while(1)
	{
		qwe();
		if(g==true)break;
		b[n-1]++;
		g1=false;
		asd();
		ert();
		if(g1==true){
			zong++;
			cout<<zong<<endl;
		}
	}
	cout<<zong;
	return 0;
}
```

AC的

```
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int a[11],b[11];string s;int n;bool g=false,g1=false;
void ert(){
	int c[15];
	for(int i=0;i<n;i++){
		c[i]=b[i];
	}
	sort(c,c+n);
	for(int i=0;i<n;i++){
		if(c[i]!=i+1)break;
		if(i==n-1){
			g1=true;
			return;
		}
	}
	return;
}
void qwe(){
	for(int i=0;i<n;i++){
		if(a[i]!=b[i])break;
		if(i==n-1)g=true;
	}
	return;
}
void asd1(){
	for(int i=0;i<n;i++){
		if(b[i]==0){
			b[i]+=n;
			b[i-1]--;
			asd1();
			return;
		}
	}
	return;
}
void asd(){
	for(int i=0;i<n;i++){
		if(b[i]>n){
			b[i]-=n;
			b[i-1]++;
			asd();
			return;
		}
	}
	return;
}
int main(){
	cin>>n;
	cin>>s;
	for(int i=0;i<s.length();i++){
		a[i]=s[i]-'0';
	}
	for(int i=0;i<s.length();i++){
		b[i]=i+1;
	}//进来
	if(a[0]>=6){//分开
		int zong=1;
		for(int i=1;i<=n;i++){//从最高向下枚举
			zong*=i;
		}
		int k=0;
		for(int i=n;i>0;i--){
			b[k]=i;
			k++;
		}
		while(1){
		qwe();//判断是否符合
		if(g==true)
			break;
		b[n-1]--;
		g1=false;
		asd1();//进位
		ert();//判断排列是否满足
		if(g1==true){
			zong--;
		}
		}
		cout<<zong;//出去
		return 0;
	}
	if(a[0]<6){//另一种，不再赘述
	int zong=1;
	while(1)
	{
		qwe();
		if(g==true)break;
		b[n-1]++;
		g1=false;
		asd();
		ert();
		if(g1==true){
			zong++;
		}
	}
	cout<<zong;
	return 0;
	}//抄袭者去那啥
}
```

看到大佬们用什么康托展开？本蒟蒻表示我不知道那是什么东西
本来想着用暴力枚举解决，后来看到第10个点超了不知道多少秒，想啊想，因为刚刚做过前一题，忽然想到我可以倒着枚举！
第一位大于等于6时（其实5也是），倒着枚举省时，反之正着枚举，所以编出了一个十分不合群的代码，一提交，所有点加一起才44ms，（可能数据过水），但当看到大佬们的0ms时，我表示：我内存比你们少几倍，咳咳均衡一点嘛。翻了翻题解，发现这样分开枚举的并没有，所以写了一篇题解。

---

## 作者：Provicy (赞：0)

题目大意：

```
给出一个数n和一个序列，求这个序列在n的全排列中的排名
```
数据范围：$1<=n<=9$

$9!$个排列的搜索次数不大，暴力查找即可。

我们可以直接使用$c++$的$STL$中的$NextPremutation$函数来查找下一个序列，并对每次查出的序列与所询问的序列进行比较找出答案即可。时间复杂度为$O(n*n!)$，显然在可以接受的范围内。

注意输入的序列是一个字符串，不过可以使用一些没用的黑科技，详情见代码。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1100;
int n,a[N],b[N],ans=1;
int check(int a[],int b[],int n)//比较
{
    for(int i=0;i<n;i++) 
        if(a[i]!=b[i]) 
			return 0;
    return 1;
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%1d",&a[i]);//没用的黑科技
    for(int i=0;i<n;i++)
        b[i]=i+1; 
    while(!check(a,b,n)) 
    {
        next_permutation(b,b+n); 
        ans++; 
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Hiki (赞：0)

###本题可以用康托展开，也可以用stl中的next-permutation或者prev-permutation来解决，这个两个函数作用分别是输出下一个和前一个排列。下面的代码是康托展开，不了解的可以戳传送门。

<http://www.cnblogs.com/hxsyl/archive/2012/04/11/2443009.html>

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
string s;
int fac[100001],n,a[100001],vis[10001];
int contor()
{
    int sum=0,k;
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++)
    {
        k=0;
        for(int j=1;j<a[i];j++)
            if(!vis[j])
                k++;
    sum+=k*fac[n-i];
    vis[a[i]]=1;
    }
    return sum+1;
}
int main()
{
    cin>>n;cin>>s;
    for(int i=1;i<=n;i++) a[i]=s[i-1]-48;
    fac[1]=1;
    for(int i=1;i<n;i++) fac[i+1]=fac[i]*(i+1);
    cout<<contor();    
}
```

---

## 作者：NeosKnight (赞：0)

康托展开秒杀


有一点非常重要，因为该题要输出的是字典序下的序号，而非康托展开的值，所以最后要加  1   ！！！！！；



代码非常简单，读入用   getchar    就行了（因为只有个位数，非常方便）




```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int fac[10]={1,1,2,6,24,120,720,5040,40320};
int a[10];
int KT (int len)
{
    int sum=0;
    for(int i=0;i<len;i++)
    {
        int k=0;
        for(int j=i+1;j<len;j++)
        {
            if(a[i]>a[j]) k++;
        }
        sum+=k*fac[len-1-i];
    }
    return sum;
}
int main()
{
    int n;cin>>n;
    char ch='!';
    while(ch>'9'||ch<'0') ch=getchar();
    int l=0;
    while(ch>='1'&&ch<=n+'0') {
        a[l++]=ch-'0';
        ch=getchar();
    }
    cout<<KT(n)+1<<endl;
}
```

---

## 作者：dhy0077 (赞：0)

康托展开即可

```cpp

#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<vector>
#include<set>
#include<map>
#include<string>
#include<algorithm>
#include<queue>
#include<list>
#define FOR(i,a,b) for(i=(a);i<=(b);i++)
#define ROF(i,a,b) for(i=(a);i>=(b);i--)
#define mmt(a,b) memset(a,b,sizeof(a))
#define pb push_back
#define mp make_pair
#define y1 hehe
#define N 200010
using namespace std;
typedef long long LL;
typedef long double LD;
int a[N],n;char s0[N];
int fac[]={1,1,2,6,24,120,720,5040,40320,362880};
int cantor(int s[],int n){
int i,j,temp,num;
num=0;
for(i=1;i<n;i++){
temp=0;
for(int j=i+1;j<=n;j++){
if(s[j]<s[i]) temp++;
}
num+=fac[n-i]*temp;
}
return (num+1);
}
int main()
{
  scanf("%d",&n);
  scanf("%s",s0+1);
  int i;
  FOR(i,1,n) a[i]=s0[i]-'0';
  printf("%d\n",cantor(a,n));
  return 0;
}

```

---

## 作者：ZStarShadow (赞：0)

还是很简单的，就一直排，然后到X的时候输出循环次数就好了。

普及组吧？

最后，STL大法好···


```cpp
#include<iostream>
#include<algorithm>
using namespace std;

char x[9];

int out = 0;

void permutation(char* str, int length)
{
    sort(str, str + length);
    do {
        bool check = false;
        for (int i = 0; i < length; i++) {
            if (str[i] == x[i]) continue;
            else {
                check = true;
                break;
            }
        }
        out++;
        if (check == false) cout << out;
    } while (next_permutation(str, str + length));
}

int main()
{
    int n = 0;
    cin >> n;
    char str[] = "123456789";
    cin >> x;
    permutation(str, n);
    system("pause");
}
```（c/c++）


---


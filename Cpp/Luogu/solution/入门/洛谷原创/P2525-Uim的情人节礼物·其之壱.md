# Uim的情人节礼物·其之壱

## 题目描述

情人节到了，Uim打算给他的后宫们准备情人节礼物。UIm 一共有$N$（$1\le N\le 9$）个后宫妹子（现充去死挫骨扬灰!）。

为了维护他的后宫的稳定。他通过编程，得出了一个送礼物的最佳顺序。这个我们管不着。

然而他认为，如果什么事情做得太圆满不是什么好事。于是他希望得到原定顺序的前一个字典序的序列。


## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
1 2 3```

# 题解

## 作者：zhylj (赞：102)

STL的事情，不用说了

prev\_permutation函数可以制造前一个排列，如果已经为第一个，则返回false。

代码很简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000];
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)   //读入数据
        cin>>a[i];
    if(prev_permutation(a,a+n))  //如果为真就输出数组
        for(int i=0;i<n;i++)
            cout<<a[i]<<" ";
    else cout<<"ERROR";   //否则输出ERROR
    cout<<endl;
    return 0;
}
然后就完了
```

---

## 作者：HolseLee (赞：76)

为什么大家都没有用康托展开+逆康托展开的？
$STL$就不多说了，对于搜索大佬蒟蒻实在佩服。
这里补一发康托展开+逆康托展开的做法。

# 康托展开

康托展开是一种类似于$hash$的做法，是一个全排列到一个自然数的双射，常用于构建$hash$表时的空间压缩。

翻译成人话就是用一个数来表示一个排列，而这个数实际上就是当前排列在所有排列中的排名。

例如样例中的
>132

它的排名是第$2$。

那么具体怎么计算？

用一个大一点的例子来解释：
>24513

首位为$2$，那么在$2$前面的数就只有$1$，所以首位为$1$时，总共有$1*(4!)$个排列小于当前排列，那么$ans+=(1*(4!))$，$ans=24$。

第二位为$4$，比$4$小的数就只有$1,3$两个（$2$已经在第一位了），第二位为$1,3$时有$2*(3!)$小于当前排列所以$ans+=(2*(3!))$,$ans=36$。

以此类推，

第三位为$5$，比$5$小的有$1,3$，所以$ans+=(2*(2!))$,$ans=40$。

第四位为$1$，没有比$1$小的数。

第五位为$3$，所有数都已经用过了，所以也没有比$3$小的数。

最终得到$ans=40$，所以比$24513$小的排列有$40$个，所以$24513$的排名是$41$。

# 逆康托展开

顾名思义，逆康托展开就是要把自然数映射回排列。

知道康托展开的思路的话就很容易实现逆展开了。

按照上例，求长度为$5$排名为$41$的排列。

求排名是$41$的排列，那么它前面就有$40$个排列。

$40=1*(4!)+16$，所以比首位小的数只有$1$个，所以第一位是$2$。

$16=2*(3!)+4$，所以比第二位小的数有$2$个，并且首位是$2$，所以这两个数应该是$1,3$，那么第二位应该是$4$。

以此类推

$4=2*(2!)+0$，所以第三位是$5$。

$0=0*(1!)+0$，所以第四位是$1$。

那么最后一位就是$3$，最终结果为$24513$。

# 回到本题

那么这题就很显然，先求给定的序列的康托展开值$m$，再把$m-1$逆康托展开就行了。
Code:

```cpp
//It is made by HolseLee on 8th Oct 2018
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int n,m,f[11],a[11];
char ka[11];
vector<int>v;

inline int cantor()
{
	int ret=0,x;
	for(int i=0; i<n; ++i) {
		x=0;
		for(int j=i+1; j<n; ++j)
		if( (ka[i]-ka[j])>0 ) x++;
		ret+=x*f[n-i-1];
	}
	return ret;
}

inline void incantor(int k)
{
	int x;
	while( !v.empty() ) v.erase(v.end());
	for(int i=1; i<=n; ++i) v.push_back(i);
	for(int i=1; i<n; ++i) {
		a[i]=v[(x=k/f[n-i])];
		v.erase(v.begin()+x);
		k%=f[n-i];
	}
	a[n]=v[0];
}

int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=0; i<n; ++i) cin>>ka[i];
	f[1]=1;
	for(int i=2; i<=10; ++i) f[i]=f[i-1]*i;
	incantor(cantor()-1);
	for(int i=1; i<=n; ++i) printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：lenfrey (赞：18)

### 一丢丢题外话
当我看到这道题时，我就认为我自己不太会做，然后去看题解——  
mmp这一大串algorithm是什么鬼！！  
然后就来写题解了。  
## 正题
首先我们靠人脑求全排列的时候，是怎么求的呢？  
比如1234，让我们看看思考过程：  
```cpp
第一位为1：
	1234
    1243
    1324
    1342
    1423
    1432
第一位为2：
	……
……
```
  以此类推。  
  我们可以看见，当我们分别枚举每一位时，都是从小到大，然后枚举后面的位数。因此，如果我们枚举前k位是xxxxxx（任意k个在1~n内的不同的数），那么第一个排列，它的第k+1位~第n位必定是从小到大排列的。  
  那么是否可以认为，当我们获得一个（不是第一个排列的）排列，它的前几位肯定会和与前面一个排列一样，如果没有，那么它就是第一位为x的第一个排列。
那么在这个排列前面，就必定有一个第一位比x小的最大排列（比如1324和1243）。
  所以，我们只需要从最后一位开始枚举一下，看哪一位比前面一位小，得到k，然后寻找第k到第n位的前一个排列（如果找不到比前面小的，就是第一个排列，输出ERROR）。  
  那么我们怎么求第k~第n位（不是k~n，是a[k]到a[n]）的上一个排列呢？  
  很明显，要求的排列的第一位一定比a[k]小，那么最大的排列的的第一位就是a[k+1]到a[n]中比a[k]小的最大的数。同时，它是以这个比a[k]小的数为第k位的最大排列，也就是a[k+1]到a[n]都比前一位小的排列。要解决这一点，只需要一个排序。
  接下来看代码：
```cpp
#include<algorithm>  //头文件 
#include<iostream>
using namespace std;
int n,a[10];  //数组 
bool cmp(const int & a,const int & b){ //从大到小排序要用的函数 
	return a>b;
}
void q(int x){  //求a[x]到a[n]的前一个排列，然后直接赋值 
	int maxn=0,maxp;
	for(int i=x+1;i<=n;i++){
		if(a[i]<a[x]&&a[i]>maxn){
			maxn=a[i];  //寻找a[x]到a[n]中比a[x]小的最大的数 
			maxp=i;  //记录它的位置 
		}
	}
	swap(a[x],a[maxp]);  //把a[x]和比x小的最大值交换位置，方便排序
	/*
	这里的意思是：
	上一个排列的第x位比a[x]小，所以是a[maxp]，
	那么上一个排列的a[x+1]到a[n]就是去掉a[maxp]之后a[x]到a[n]的最大排列。 
	*/
	sort(a+x+1,a+n+1,cmp);
}
int main(){
	cin>>n;  //输入不解释 
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=n;i>=2;i--){
		if(a[i]<a[i-1]){  //找到了x，也就是之前说的k 
			q(i-1);  //注意这里是包括了第i-1位 
			for(int j=1;j<=n;j++){  //直接输出然后结束程序 
				cout<<a[j]<<" ";
			}
			return 0;
		}
	}
	cout<<"ERROR";  //如果没有跳出，那就是第一个排列，输出ERROR 
}
```

---

## 作者：Retired_yangruibin (赞：17)

好吧，就和大家看到的一样，这是道**入门**级别的题目，我就不说了。

我觉得这种题目的题解要用如我一般的蒟蒻的方法，这样才能让看题解的初学者们看得懂。

## 开始解题：

### 什么是字典序？

普及一下，字典序是根据前后顺序逐位比较大小的顺序，如：

```
123<132<213<231<312<321
```
所以，字典序全排列就是只由1~n组成且每个只用一次的n个数构成的字典序排列。

### 解题思路：

本蒟蒻的做法是：dfs.（大佬勿喷）

dfs的优点是它可以无脑盲扫全排列。本题数据较弱，可以考虑dfs。

程序如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[11],b[11],c[11],n;
void print()//输出答案
{
	int flag=0;
	for(int i=1;i<=n;i++)
	if(a[i]!=0)flag=1;
	if(flag==0)cout<<"ERROR"<<endl;//特判是不是第一个排列
	else
	{	
		for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";
	}
}
int check1(int dep,int x)//判断同一个排列中是否出现了同一个数字
{
	for(int i=1;i<dep;i++)
	if(b[i]==x)return 0;
	return 1;
}
int check2()//判断是否查找到了目标排列
{
	for(int i=1;i<=n;i++)
	if(b[i]!=c[i])return 0;
	return 1;
}
void dfs(int dep)//深度优先搜索
{
	if(dep>n)
	{
		if(check2())
		{
			print();
			exit(0);
		}
		for(int i=1;i<=n;i++)a[i]=b[i];//滚动数组
		return ;
	}
	for(int i=1;i<=n;i++)
	{
		if(check1(dep,i))
		{
			b[dep]=i;
			dfs(dep+1);
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>c[i];//输入目标序列
	dfs(0);
	return 0;
}

```


---

## 作者：浮尘ii (赞：12)

你可听说过C++的STL？

在STL中，有这样一个函数，是专门求 [第一，最后一个） 按照字典序排列的上一个值较小的组合。


原型如下：

```cpp

template <class BidirectionalIterator>
bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last);

template<class BidirectionalIterator, class BinaryPredicate>  
bool prev_permutation(BidirectionalIterator _First,  BidirectionalIterator _Last, BinaryPredicate _Comp);  

```

其中返回一个bool类型的值，如果该排列已经是最小的排列，则返回false。


那么代码就可以写了：

```cpp

#include <iostream>
#include <cstdio>
#include <algorithm>//prev_permutation包含在<algorithm>中

using namespace std;

const size_t    MaxN = 10;

int    N, A[MaxN];

int main()
{
    cin >> N;
    for(int i = 0; i < N; i++)
        scanf("%d", A + i);

    if(!prev_permutation(A, A + N))
        puts("ERROR");
    else {
        for(int i = 0; i < N - 1; i++)
            printf("%d ", A[i]);
        printf("%d\n", A[N - 1]);
    }

    return 0;
}

```

[color=white][delete]C++大法好!!![/delete][/color]


---

## 作者：血色黄昏 (赞：9)

### 2333每次都看不见PY的题解是为什么

除了我才会写入门的题解QAQ

这道题竟然可以用全排列水~

二话不说上代码/kk

```python
import itertools#一个神奇的库，用来弄全排列
n = int(input())#输入
li = input().split()#输入++
for i in range(n):#转int类型
    li[i] = int(li[i])
l = list(itertools.permutations(li, n))#全排列函数
for i in range(len(l)):
    l[i] = list(l[i])#调用完是turple类，要强制转list
l = sorted(l)#排个序（话说竟然没排过序也是恶心
for i in range(len(l)):#判断
    if li == l[i]:
        if i == 0:#如果是第一个就输出error
            print("ERROR")
            break
        for j in range(n):#不然输出
            print(l[i - 1][j], end=" ")
        break
```
时间复杂度shi O(n*n!)还好只有9QAQ

求通过

---

## 作者：HZZX_CJX (赞：7)

数据太弱了，有些问题，比如4213，此程序无法解出答案，但我真的就这样过了。。。

没有全排列，将最后一个数插入到从后搜起第一个比它大的数的前面，后面的数排序。。。

方法真的不太对，但能过就是好方法。欢迎找到优化，或者真正的正解。


```cpp
var a:array[1..9]of byte;
    n,i,j,k,b,t:longint;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  for b:=n downto 1 do
    for i:=b-1 downto 1 do
      if a[i]>a[b] then begin
        t:=a[b];
        for j:=b downto i+1 do
          a[j]:=a[j-1];
        a[i]:=t;
        for j:=i+1 to n-1 do
          for k:=j+1 to n do
            if a[j]<a[k] then begin
              t:=a[j]; a[j]:=a[k]; a[k]:=t;
            end;
        for j:=1 to n do write(a[j],' ');
        exit;
      end;
  writeln('ERROR');
end.
```

---

## 作者：_Ts_ (赞：5)

emmm大家都是全排列的样子

我的方法大概比较奇怪……效率大概O（n²）的样子？

上代码看注释吧




```cpp
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
bool cmp(int x,int y){
    return x>y;
}
main(){
    int n,a[15],pos[15];
    bool h[15]={0};
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),pos[a[i]]=i;//pos用于记录排列中每个数字出现的位置 
    h[a[n]]=1;//h用于记录某个数是否已出现 
    for(int i=n-1;i>=1;i--){//从后往前检查，如果后方有比当前数小的则可以替换，使字典序变小【并不是比给定数组小的最大排列】 
        int j;
        h[a[i]]=1;
        for(j=a[i]-1;j>=1;j--) if(h[j]) break;//找到比当前位小的最大的数 
        if(j){
            swap(a[i],a[pos[j]]);
            sort(a+i+1,a+n+1,cmp);//从大到小排序可保证是【比给定数组小的最大的】排序 
            for(j=1;j<=n;j++) printf("%d ",a[j]);
            return 0;//直接退出程序，不会输出“ERROR” 
        }
    }
    printf("ERROR");//若每一位都不能交换，即每位后面都没有比它小的数，即为第一个排序 
    return 0;
}
```

---

## 作者：Ryo_Yamada (赞：4)

众所周知，C++的一大好处就是它的STL库 ~~（STL大法好)~~

而STL中有两个函数，分别是 `prev_permutation` 和 `next_permutation`.它们是现成的求上一个和下一个字典序的序列的。

于是这题就很简单了吧。

上代码：

```cpp
#include <bits/stdc++.h>//prev_permutation在algorithm里，我用的是总头
using namespace std;
int a[9];//存储现排列
bool flag;//记录是否是第一个排列
int main() {
	int n;
	cin >> n;
	for(int i=0; i<n; i++) {
		cin >> a[i];
		if(a[i] != i + 1) {
			flag = 1;
		}//如果不是i + 1，就不是第一个排列
	}
	if(!flag) {//如果是，输出`ERROR`.
		cout << "ERROR";
	}
	else {
		prev_permutation(a, a + n);//前一个排列
		for(int i=0; i<n; i++) {
			cout << a[i] << " ";
		}//输出
	}
	return 0;完美结束
}
```


---

## 作者：yali_hzy (赞：3)

看到这道题，首先想到火星人P1088

另类代码(时间0ms)：


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,i,flag,flag1,flag2,a[20],p[20];
void out()
{
    int i;
    for(i=1;i<=n;i++)
        printf("%d ",a[i]);
}
void dfs(int x)
{
    if(x>n && !flag2)
    {
        flag2=1;
        return;
    }//flag2只是用来帮助直接从后面开始回溯
    if(x>n)
    {
        flag1=1;//标记
        out();//输出
        return;
    }
    if(!flag2)
        dfs(x+1);
    p[a[x]]=0;//当前的数字要改动，使用标记变为0
    if(flag1)
        return;//避免找到结果后继续执行
    for(a[x]--;a[x]>0 && !flag1;a[x]--)//直接在数列上改动
    {
        if(!p[a[x]])//搜索
        {
            p[a[x]]=1;
            dfs(x+1);
            if(flag1)
                return;//避免找到结果后继续执行
            p[a[x]]=0;
        }
    }
    if(a[x]==0)
        a[x]=n+1;//数字超出范围，变为（n+1）
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        p[a[i]]=1;//用过的数字的标记
        if(a[i]!=i)
            flag=1;//如果不等于，就不是第一个序列
    }
    if(!flag)//特判
    {
        printf("ERROR");
        return 0;
    }
    dfs(1);//搜索
}
```

---

## 作者：fighter_OI (赞：2)

比较巧妙的处理。

使用DFS，利用循环控制字典序。

用滚动数组保存上一个全排列。

标程：

```cpp
type arr=array[1..100] of longint;
var a,b,l:arr;
    n,i:longint;
    flag:boolean;
    f:array[1..100] of boolean;
function xd(a,b:arr):boolean;
var i:longint;
begin
 for i:=1 to n do
  if a[i]<>b[i] then exit(false);
  exit(true);
end;
procedure go(k:longint);
var i:longint;
begin
 if k>n then
  begin
   if flag then
    begin
     if xd(b,l) then
      begin
       write('ERROR');
       halt;
      end;
     flag:=false;
     a:=b;
     exit;
    end;
   if xd(b,l) then
    begin
     for i:=1 to n do
      write(a[i],' ');
     exit; 
    end;
   a:=b;
   exit;
  end;
 for i:=1 to n do
  if f[i] then
   begin
    b[k]:=i;
    f[i]:=false;
    go(k+1);
    f[i]:=true;
   end;
end;
begin
 read(n);
 for i:=1 to n do
  read(l[i]);
 fillchar(f,sizeof(f),true);
 flag:=true;
 go(1);
end.
```
标程也许过长（主要是判断），但仍希望有所帮助。


---

## 作者：AdzearDisjudge (赞：1)

不得不说一句，C++绝对优势。

STL大法好。

prev\_permutation(a+begin,a+end):返回a数组[begin,end)范围内数据的上一个全排列。如果已是第一个，返回false.

该函数包含于<algorithm>库中。

另外，我加了个读入优化，那是用成习惯了==


```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int f=1,x=0;
    char ch;
    do
    {
        ch=getchar();
        if(ch=='-')
        f=-1;
    }
    while(ch<'0'||ch>'9');
    do
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    while(ch>='0'&&ch<='9');
    return f*x;
}
int n,a[10];
int main()
{
    n=read();
    for(register int i=0;i<n;++i)
    a[i]=read();
    if(!prev_permutation(a+0,a+n))
    cout<<"ERROR";
    else
    for(register int i=0;i<n;++i)
    cout<<a[i]<<' ';
    return 0;
}
```

---

## 作者：judgejudge (赞：1)

# 深度搜索必备！！！


------------

这道题我运用**深度搜索中栈**的方法。下面说一下思路：
1. **定义一个s数组和一个变量p，令s[1]=1,p=1**
1. ** 当p>0时**  
 1. **如果s[p]超出n的范围，p-1**
 1. **没有超出：**
    1. **判断前后是否不同，若不同，且p达到n的位置：**
       1. **保存数组**
       1. **先判断是否与给出的数组相同，**若相同，且**这不是第一种排列**，输出**前一种**,**return 0**
       1. 若相同，但**这是第一种排列**，输出ERROR,**return 0**
       1. **如果p没有到n的位置:p++,s[p]=0**
 1. **s[p]++**


------------
下面是代码：
```cpp
#include <iostream>
using namespace std;
int s[1999],a[1999],b[1999][1999];
int main(){
    int i,j,k,n,p,l,q=0;
    cin>>n;
    for(i=1;i<=n;i++)cin>>a[i];
    p=1;
    s[1]=1;
    while(p>0){
        if(s[p]>n)p--;
        else{
            k=0;
            for(i=1;i<p;i++)
            if(s[i]==s[p])k=1;
            if(k==0){
                if(p==n){
                    l=0;
                    for(i=1;i<=n;i++)b[q][i]=s[i];
                    q++;
                    for(i=1;i<=p;i++)
                    if(a[i]!=s[i])l=1;
                    if(l==0&&q>1){
                        for(i=1;i<=p;i++)cout<<b[q-2][i]<<" ";
                        return 0;
                    }
                    if(q==1&&l==0){
                        cout<<"ERROR";
                        return 0;
                    }
                }
                else{
                    p++;
                    s[p]=0;
                }
            }
        }
        s[p]++;
    }
}
```
如果你试着提交之后，会发现以下图片：
![](https://cdn.luogu.com.cn/upload/pic/50990.png)
## 为什么呢？
 _二维数组占据内存太大！！！_ 
 
 所以我们需要新的方法来改进。**那么怎么改进呢？**

如果你细心观察就会发现，根本不用二维数组！！**直接保存前一个一维数组就可以辽！！
**
所以我们的顺序又有了改进：
1. 判断
1. 储存数组
### 这样就优化，省掉不必要的内存啦！！
那么AC代码就出来了：
```cpp
#include <iostream>
using namespace std;
int s[1999],a[1999],b[1999];
int main(){
	int i,j,k,n,p,l,q=0;
	cin>>n;
	for(i=1;i<=n;i++)cin>>a[i];
	p=1;
	s[1]=1;
	while(p>0){
		if(s[p]>n)p--;
		else{
			k=0;
			for(i=1;i<p;i++)
			if(s[i]==s[p])k=1;
			if(k==0){
				if(p==n){
					l=0;
					for(i=1;i<=p;i++)
					if(a[i]!=s[i])l=1;
					if(l==0&&q>0){
						for(i=1;i<=p;i++)cout<<b[i]<<" ";
						return 0;
					}
					if(q==0&&l==0){
						cout<<"ERROR";
						return 0;
					}
					for(i=1;i<=p;i++)b[i]=s[i];
					q++;
				}
				else{
					p++;
					s[p]=0;
				}
			}
		}
		s[p]++;
	}
}
```
满盘AC等着你：
![](https://cdn.luogu.com.cn/upload/pic/50991.png)

---

## 作者：无欢 (赞：1)

还是algorithm

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
    int n,i;
    cin>>n;
    int a[n];
    for(i=0;i<n;i++)
        cin>>a[i];
    prev_permutation(a,a+n);//求上一个全排列
    for(i=0;i<n;i++)
        cout<<a[i]<<" ";
    return 0;
}
```
这里向大家推荐一道题目：[火星人](https://www.luogu.org/problemnew/show/1088)

他的原理和这道题目差不多

要用到的是：prev\_permutation(a,a+n);

就是求下一个全排列

感兴趣的可以去试试


---

## 作者：ljc20020730 (赞：1)

这道题写入门难度实在难为新手，我认为至少普及-

各位神犇写入门难度就是觉得本题是回溯全排列模板水题

确实是这样的，那也没有[luogu OJ P1706](https://www.luogu.org/problem/show?pid=1706) 水啊？人家都普及-了。

全排列的算法就是回溯，

普及下深搜，是在for、while、repeat循环节无法完成时，则用深搜暴力。

切记！深搜及其浪费时间，在有其他选择时，莫用深搜！！

```cpp
var n,i:longint;
a:array [1..9] of boolean;
b:array [1..9] of integer;
procedure f(t:longint);
var i,j:longint;
begin
for i:=1 to n do
begin
if a[i] then  //如果此数没有被运用，则运用
begin
a[i]:=false;//表示此数被用过了
b[t]:=i;//存储
if t=n then begin for j:=1 to n do write(b[j]:5);writeln;end //进行输出，记得换行；还有，输出格式很无语，场宽为5，不要加空格       
else f(t+1);
a[i]:=true;//回溯
end;
end;
end;
begin
readln(n);
for i:=1 to n do
a[i]:=true;//初始化，都为真
f(1);
end.
```
其实这道题还要比P1706要难一些，
对于C++选手

STL大法好用：prev\_permutation(a+begin,a+end):返回a数组[begin,end)范围内数据的上一个全排列。如果已是第一个，返回false.

该函数包含于<algorithm>库中。

但是对于pascal选手，其实开动脑筋，输出上一排列的方法有很多，

我用的下面好像没有说到，比较节俭明了（在print函数中）

简要介绍：

设要求的当前读入序列为w，dfs中不断更新的序列为a，记录上一序列的序列为last

直接在n=k是进行查询当前的序列a和读入序列w是否相等，若相等直接输出上一序列last

否则用当前a序列更新、迭代旧的last序列（迭代一定放print最后）

输入时判断读入序列a是否为第一个序列即读入序列a是否是升序排列

若是按要求输出‘ERROR’

下面是P党的福利：

```cpp
var n,i:longint;
    last,a,w:array[1..10]of longint;
    b:array[1..10]of boolean;
    f:boolean;
procedure print;
var i:longint;
    f:boolean;
begin
 f:=true;
 for i:=1 to n do
  if w[i]<>a[i] then begin f:=false; end;
 if f then
 for i:=1 to n do write(last[i],' ');
 last:=a;
end;
procedure dfs(k:longint);
var i:longint;
begin
 for i:=1 to n do
  if b[i] then begin
   a[k]:=i;
   b[i]:=false;
   if k=n then print
   else dfs(k+1);
   b[i]:=true;
  end;
end;
begin
 readln(n);
 f:=true;
 for i:=1 to n do begin
 read(w[i]);
 if w[i]<>i then f:=false;
 end;
 if f then begin writeln('ERROR'); halt; end;
 fillchar(b,sizeof(b),true);
 dfs(1);
end.
```
AC效率：
44ms /  8.21MB

代码：0.67KB Pas


---

## 作者：KesdiaelKen (赞：1)

可以用递归来完成。

因为输入的数为有序数列中的数，即可以用全排列的思想。

若找到与输入相等的数列，则找到它上一个数列，并输出。

代码如下:

```cpp
#include<cstdio>
#include<iostream>
#include<cstring> 
#include<string>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<vector>
using namespace std;
bool sg[10]={0};//记录是否用过
char hg[10]={0};//记录输入情况
char c[400000][10];//记录情况
int dg=0;//记录是第几个数列情况
int gs;
void cal(int x,char a[])//x记录还剩多少位没算完，a[]记录次况所代表的一个数列
{
    if(x==0)//递归完毕
    {
        dg++;//记录情况编号
        if(strcmp(a,hg)==0)//若相等
```
{//输出
```cpp
            if(dg-1!=0)//判断是否为第一个
            for(int i=0;i<gs;i++)printf("%c ",c[dg-1][i]);
            else
            printf("ERROR");
        }
        else
        {
            strcpy(c[dg],a);//记录此况
        }
    }
    else
    {
        for(char i='1';i<=gs+'0';i++)//按顺序找
        {
            if(!sg[i-'0'])//若没算过
            {
                sg[i-'0']=true;
                a[gs-x]=i;
                cal(x-1,a);
                sg[i-'0']=false;
            }
        }
    }
}
int main()
{
    scanf("%d",&gs);
    for(int i=0;i<gs;i++)
    {
        cin>>hg[i];
    }
    char wl[10]={0};
    cal(gs,wl);//初始字符串设为空
    return 0;
}
```

---


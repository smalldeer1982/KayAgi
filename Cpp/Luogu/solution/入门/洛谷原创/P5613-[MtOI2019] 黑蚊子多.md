# [MtOI2019] 黑蚊子多

## 题目背景

性★感☆大★草  在☆线★开☆门  
定☆数★一☆零  实★则☆虚★高  
加★速☆转★圈  开☆幕★雷☆击  
疯☆狂★交☆互  劲★爆☆咚★咚  
黑★蚊☆子★多  邀☆您★来☆爽  
超☆越★模☆式  直★角☆旋★钮  
山★东☆卫★星  马☆上★联☆动  
变☆成★十☆加  已★经☆爽★爆

## 题目描述

Hikari 的面前有 $n(1\leq n\leq 1000)$ 级台阶，每 $1s$ 她可以向上跳 $m(1\leq m\leq n)$ 级台阶。（不在中间的台阶上停留）

台阶上有 $k(k\leq 10)$ 个特殊的平台 $a_i$，Hikari 在该平台 **停留** 时会使得 $m$ 增加 $1$。

请问 Hikari 到达台阶顶部花费的时间。

## 说明/提示

### 子任务

对于 $60\%$ 的数据，$k=0$。

对于 $100\%$ 的数据，$1\leq m\leq n\leq 1000$，$k\leq 10$。

### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22614) T1

出题人：disangan233


## 样例 #1

### 输入

```
10 5 0```

### 输出

```
2```

## 样例 #2

### 输入

```
31 4 2
8 13```

### 输出

```
6```

# 题解

## 作者：williamllk (赞：133)

本蒟蒻一打开题解，看到了一些类似桶排序的高级做法，作为一道签到题，本蒟蒻随便写了一个模拟就AC了。

首先是一个[有意思的东西](https://www.luogu.org/problemnew/solution/P5613)



------------
接下来该正经讲题了（敲黑板）：

① 输入

```cpp
for(int i=1;i<=k;i++)
    cin>>a[i];
```

② 判断：其中ans是走的次数，s是已经走过的台阶（s的初始值应设为0，我第一次设为1后样例没通过）

```cpp
while(s<n){
	for(int i=1;i<=k;i++){
		if(a[i]==s)
			m++;
	}
	s+=m;
	ans++;
}
```
③ 输出

```cpp
cout<<ans;
```


------------
最后献上AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,k,a[1001],ans=0,s=0;
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
		cin>>a[i];
	while(s<n){
		for(int i=1;i<=k;i++){
			if(a[i]==s)
				m++;
		}
		s+=m;
		ans++;
	}
	cout<<ans;
	return 0;
} 
```
看到这里点个赞，评个论在走吧！

---

## 作者：冬天的雨 (赞：44)

# 蒟蒻的题解                   
[题目地址](https://www.luogu.org/problem/P5613)              


------------
其实这道题目还是很easy的，虽然窝月赛中其他题都废掉但秒切还是真的。。。         
作为一道简单的签到题目，这道题很明显是用模拟来水分数。不过看各位大佬用平衡树啊，STL啊玩到飞起，蒟蒻的我感到深深的无力。。。          
##### 所以一发纯的模拟送上，解释见代码
```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<string>
#include<time.h>
#include<vector>
#include<cmath>
#include<ctime>
#include<queue>
#include<set>
#include<map>//珂爱的头文件
using namespace std;
int main(){
    int n,m,k,a[11],ans=0;//这里注意ans要初始化~ 
    scanf("%d%d%d",&n,&m,&k);//基础输入,用cin和cout在数据大时可能会炸 
    for(int i=1;i<=k;i++){
        scanf("%d",&a[i]);//题目说明k最大是10所以不用担心爆空间。。。 
    }
    //-----------------------------------------以上是准备部分 
    int t=0;//定义一个t来存当前是到了哪个台阶 
    do{
        n-=m;//总台阶数减去跳跃台阶数 
        t+=m;//当前台阶数加上跳跃台阶数 
        ans++;//。。。累计答案 
        for(int i=1;i<=k;i++){//循环判断是否到了特殊台阶 
            if(t==a[i]){  
                m++;//跳跃能力++ 
                break;//珍惜每一毫秒 
            }
            if(a[i]>t){//题目说a[i]升序排列所以不用特判 
                break;//如果超过了就停止 
            }
        }
    }while(n>0);//do-while循环,如果习惯写while记得将ans初始化为-1 
    printf("%d",ans);//输出答案！！！ 
    return 0;//很重要的，不加可能会UKE 
} 
//完结撒花~~~o(*￣▽￣*)ブ 
```
期中考试临近，偷偷写题解不易，求赞！！！             
### 诸位大佬勿喷！！！

---

## 作者：氷芽川四糸乃 (赞：20)

```
真人面对面收割，美女角色在线掉分，发狂玩蛇新天地
															---Arcaea中文维基
```

~~以下是正文~~

可以考虑这么一张图

![](http://wiki.arcaea.cn/images/thumb/a/a4/World_conclusion.jpg/800px-World_conclusion.jpg)

每次向上走 $m$ 格，在其中有 $k$ 个特殊平台，踩上去后后面每次向上走 $m+1$ 格。

>对于 60% 的数据，k = 0。

(upd:此处 $\frac{n}{m}$ 应加上上取整)

那么要从底部到达顶部所需要的最小次数就是 $\lceil \frac{n}{m} \rceil$ 次，只需要输出 $\lceil  \frac{n}{m} \rceil$ 即可得到此部分的分数。

>对于 100% 的数据，1 ≤ m ≤ n ≤ 1000 ，k ≤ 10 。

$1≤ n ≤ 1000$ 所以我们可以开一个数组存储哪些是特殊平台 。然后模拟就好了

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k;
int a[100000];
int main ()
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	{
		int in;
		cin>>in;
		a[in]=1;//存储特殊格子
	}
	int ans=0;
	int t=0;//当前位置
	while(true)
	{
		if(n-m<=0)//边界
		{
			ans++;//即使剩余格子小于m 也还是需要走一次的
			break;
		}
		n-=m;//剩余格子
		t+=m;//当前位置
		m+=a[t];//如果特殊为格子 m+=1
		ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：disangan233 (赞：8)

### 算法一

我会输出样例！期望得分 $20$ 。


### 算法二

考虑 $k=0$ 的情况，发现答案即为 $\lceil \frac{n}{m}\rceil$。
	
其中 $\lceil x\rceil$ 表示 $\geq x$ 的最小整数，期望得分 $60$ 分。
	

### 算法三

考虑到 $n$ 极小，用一个指针或者桶维护 $\geq$ 当前位置的第一个 $a_i$，模拟即可。
	
时间复杂度 $O(ans+k)$，期望得分 $100$ 分。
	
### 代码实现

```cpp
#pragma GCC optimize(2,3,"Ofast","unroll-loops") 
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;
        x=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;
    }
    in db gf() {re a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=15;
int n,m,k,a[N];
int main()
{
	n=read(),m=read(),k=read();
	for(re i=1;i<=k;i++) a[i]=read();
	for(re i=1,j=1,p=0;;i++)
	{
		p+=m;while(a[j]<p&&j<=k) j++;
		if(j<=k&&a[j]==p) m++;
		if(p>=n) return write(i,'\n'),ot(),0;
	}
}
//Author: disangan233 
//In my dream's scene,I can see the everything that in Cyaegha.
```

---

## 作者：Eason_AC2 (赞：8)

没错，又是我，我又来给$Div.2A$题写题解了（捂脸）。

这题其实是一个简单的模拟，不过题目有点难看懂。~~近来div.2 A最难的题目~~

---

设两个变量$cur$和$ans$，分别表示目前所跳到的台阶和最终需要的时间。每次跳完之后，就先让$cur$加**当前**的$m$，$ans$加1，然后再判断是不是跳到了特定的台阶，这个暴力枚举一下，再一个一个比对就行了。【当然你如果只想拿$60$分，就直接$v=\left\lceil\dfrac{s}{t}\right\rceil$就可以了（$\left\lceil x\right\rceil$表示$x$向上取整，例如$\left\lceil1.1\right\rceil=2$），反正拿多少分由你自己决定。】

所以这道题目就做完了。

---

下面奉上完整$AC$代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, m, k, a[17];
int main() {
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1; i <= k; ++i)
		scanf("%d", &a[i]);
	int cur = 0, ans = 0;
	while(cur < n) {
		cur += m;
		ans++;
		for(int i = 1; i <= k; ++i)
			if(cur == a[i])
				m++;
	}
	printf("%d", ans);
	return 0;
}
```

--- 
~~吐槽：~~

~~无耻求赞qwq。~~

~~黑蚊子多是什么意思qwq。~~

---

## 作者：qian_shang (赞：6)

 ~~看难度的确是道签到题~~

[题目传送门](https://www.luogu.org/problem/P5613)

- 先看题意：$n$级台阶 ，一次跳$m$级，有$k$个平台跳上去后会使$m+1$

- 注意一些坑点（~~可能是因为窝太菜了才没发现~~）：

>题面上说的停留不是等一秒，是直接增加$m$

>而且$m$是固定的，就是一次只能跳$m$（悲催的我以为是可以跳$m$以内的任意值，于是第一遍WA了（~~而且数据很水，那样做有$80$分~~

 - 弄清楚题意后就可以愉快的模拟了:

> 可以使用桶排的思想，将特殊平台存储，然后模拟位置，跳到平台就$m+1$

- 其他细节详见代码注释

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define N 1005
#define inf 0x7f7f7f
using namespace std;
int x,n,m,k,a[N],ans,top=1,f;//桶开到n的范围
inline int maxx(int A,int B){return A>B?A:B;}
inline int minn(int A,int B){return A<B?A:B;}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for (int i=1;i<=k;i++){
		scanf("%d",&x);
		a[x]=1;
	}//存储特殊平台
	while (f<n){//f指当前位置
		f+=m;//跳一步
		if (a[f]) m++;//判断是否在特殊平台
		ans++;//记录秒数
	}
	printf("%d",ans);
	return 0;
}//完结撒花
```

题解有疑问或有误的下来问窝~QAQ

---

## 作者：Juk_DR (赞：5)

~~月赛的时候去看《天気の子》惹没来得及打qwq~~

------
这题作为A题当然难度自然是十分easy的，体验极其舒适。

思路：

根据题目，每次向上跳m级台阶，那么我们可以直接用一个$for$循环去统计次数；接着它还要要求如果跳到特殊的点上$m$就就会$++$,所以我们只要维护一个数组统计它是否是特殊台阶就行辽。

CODE：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=1050;
int n,m,k,ans;
bool mark[N];

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++){
		int x;
		scanf("%d",&x);
		mark[x]=true;//特殊台阶标记 
	} 
	for(int i=0;i<n;i+=m){
		if(mark[i]) m++;//跳到特殊台阶m++ 
		ans++;//统计答案 
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：4)

# first 吐槽

   ~~不愧是一道签到题~~

# second 理解题意

   其实题目意思很简单，就是Hikari每秒可走$m级台阶，每当走到特殊的平台$a[i]，每秒可走的台阶数+1（也就是m++)

# third 上代码

```cpp
#include<bits/stdc++.h>//万能头不解释 
using namespace std;
int n,m,k,l,ans;//n，m，k不解释,l存 Hikari 走的台阶数，ans记录时间 
int main()
{
	cin>>n>>m>>k;
    int a[k+3];//听说这样定义数组占用内存会比较少 
    for(int i=1;i<=k;i++)//输入a数组 
    	cin>>a[i];
	int p=1;//看起来并没什么用，但好像省时耶 
	while(l<n)//如果l>n，也就是走完了，则退出循环 
	{
		l+=m;//加上m 
		for(int i=p;i<=k;i++)//找l是否与a数组里的某一个数相同 
    		if(l==a[i])//找到了 
    		{
    			m++;//每秒可走的台阶数+1
    			p++;//p+1,其实也就是说前面的绝对不会与l相同了（因为题目的输入格式写了保证输入的 a_{i}$ 单调递增），这就是省时的方法 
    			break;//跳出循环 
			}
    	ans++;//累加 
	}
	cout<<ans;//输出 
    return 0;//别忘了return 0;
}
```


# fourth 跪求管理员给过

---

## 作者：Crab_Dave (赞：3)

~~出题人居然VanJOJO梗...2333~~

这道题按照题意膜你就行啦~

详情见代码qwq

```cpp
#include<cstdio>//不打万能头qwq
using namespace std;//命名空间qwq

int n,m,k,x;//n个台阶，初始一次m阶，k个特殊台阶，x等下用
int a[1005];//存储特殊台阶（桶排思想）
int ans,now;//答案和位置

int main()
{
	scanf("%d%d%d",&n,&m,&k);//读入
	while(k--)
	{
		scanf("%d",&x);//读入特殊台阶的坐标
		a[x]=1;//标记为1
	}
	while(now<n)//没有跳到就一直跳
	{
		if(a[now])m++;//特殊台阶
		now=now+m;//跳一下
		ans++;//跳了一步，ans++
	}
	printf("%d\n",ans);//输出
	return 0;//结束了罪恶的一生qwq
}
```

如果不介意的话可以~~大喊一句黑蚊子多！然后~~顶一下再走哦~

---

## 作者：收到回公司 (赞：2)

# P5613 题解



多好的一道递归，题解里没有递归，我就来一篇递归题解


首先，要看一下这道题如何递归

第一种情况：$k = 0$
```cpp
int k0(int n,int m,int step,int ans)//step为当前台阶，ans为当前花费时间
{
	if(step>=n) return ans;//到达终点，return
	else
	{
		step+=m;//当前位置+m
		ans++;//花费时间++
		return k0(n,m,step,ans);//递归
	}
}
```

第二种情况：$k\neq 0$
```cpp
int kelse(int n,int m,int step,int ans)//step为当前台阶，ans为当前花费时间
{
	if(step>=n) return ans;//到达终点，return
	else
	{
		step+=m;//当前位置+m
		ans++;//花费时间++
		for(int i=1;i<=k;i++)//如果本台阶为特殊的台阶，m++
		if(a[i]==step) m++;
		return kelse(n,m,step,ans);//递归
	}
}
```

好了分析完了，上AC代码
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int k;
int a[15];//储存特殊台阶

int k0(int n,int m,int step,int ans)
{
	if(step>=n) return ans;
	else
	{
		step+=m;
		ans++;
		return k0(n,m,step,ans);
	}
}
int kelse(int n,int m,int step,int ans)
{
	if(step>=n) return ans;
	else
	{
		step+=m;
		ans++;
		for(int i=1;i<=k;i++)
		if(a[i]==step) m++;
		return kelse(n,m,step,ans);
	}
}
int main()
{
	int n,m,ans=0;
	scanf("%d%d%d",&n,&m,&k);
	if(k==0) ans=k0(n,m,0,0);//执行k=0
	else
	{
		for(int i=1;i<=k;i++)//特殊台阶输入
		{
			scanf("%d",&a[i]);
		}
		ans=kelse(n,m,0,0);//执行k!=0
	}
	printf("%d",ans);//输出
	return 0;
}
```

---

## 作者：Kevin_Wa (赞：2)

### 题目大意：

每一秒钟可以跳上$m$格，当跳上的格数等于某几个数时，$m$就要加$1$，求一共要多少时间才可以跳上$n$格

### 解题思路：

作为洛谷月赛的一道签到题，还是很良心的。

从0级开始模拟，当判定到特殊格式时将$m$加$1$即可，复杂度$O(n/m)$，妥妥$100$分到手。

## Code

```cpp
#pragma GCC optimize ("-Ofast") //由于为了刷排名就用这个加速，结果只加了1ms
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x,t,w,a[10010];
template <typename T> void read(T &x) {
x = 0; char c = getchar();
for (; !isdigit(c); c = getchar());
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
}
int main()
{
read(n);read(m);read(k);
for (int i=1;i<=k;i++)
  read(a[i]);
x=0;t=0;w=1;
while (x<n)
  {
  	x+=m;
  	t++;
  	while (a[w]<=x && w<=k)
  	  {
  	  	if (a[w]==x) m++;
  	  	w++;
		}
  }
printf("%d\n",t);
return 0;
}
```


---

## 作者：tZEROちゃん (赞：2)

### [题目传送门](https://www.luogu.org/problem/P5613)

一道模拟题目，签到送分题。
### 您需要的知识
1.**[while循环](https://baike.so.com/doc/819689-866910.html)**

2.**[for循环](https://baike.so.com/doc/92346-97549.html)**

3.**[一维数组](https://baike.so.com/doc/6426154-6639827.html)**
### 思路：

Step 1：按题目要求，定义a[],n,m,k
```cpp
    int a[10001];
    int n,m,k;
```
Step 2：输入n,m,k
```cpp
	cin>>n>>m>>k;
```
Step 3：对于 $60\%$ 的数据，$k=0$。
        所以先来个判断就能得到60分
        如果`k==0`就输出`n/m`向上取整
        小学三年级的知识……
```cpp
	if(k==0)
	{
		if(n%m==0)cout<<n/m;
		else cout<<n/m+1;
	}
```

### 如果你写到这，就可以得到60分了！

Step 4：如果不是$k=0$怎么办
		先加一个`else`
```cpp
    else
    {

    }
```

Step 5：定义2个变量，`ste`和`cnt`，都归零
```cpp
	int cnt=0;
	int ste=0;
```
这里可以连着写

Step 6：输入`a[i]`
		不赘述了
```cpp
	for(int i=1;i<=k;i++)
		cin>>a[i];
```
Step 7：按照题目方法模拟，也不难，while+for即可
```cpp
	while(ste<n)
	{
		cnt+=1;
		ste+=m;
		for(int i=1;i<=k;i++)
		if(a[i]==ste)m++;
	}
```
Step 8：输出`cnt`，别输出错了！
```cpp
	cout<<cnt;
```
Step 9：
```cpp
	return 0;
```

### 满分代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int a[10001];
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	if(k==0)
	{
		if(n%m==0)cout<<n/m;
		else cout<<n/m+1;
	}
	else
	{
		int cnt=0;
		int ste=0;
		for(int i=1;i<=k;i++)
			cin>>a[i];
		while(ste<n)
		{
			cnt+=1;
			ste+=m;
			for(int i=1;i<=k;i++)
				if(a[i]==ste)m++;
		}
		cout<<cnt;
	}
	return 0;
}
```

---

## 作者：SW_三告 (赞：2)

第一篇题解，希望帅气的美丽的管理大大给通过~

本题是个大水题，非常符合入门的难度。

题面[点这里](https://www.luogu.org/problem/P5613)
先上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,k,p,ans,y;
//y是当前的位置,p没有什么卵用，y就是Hikari的小碎步的跨度~
int main(){

	int a[200];
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i];
	}
	while(y<n){
		y+=m;
		for(p=1;p<=k;p++)
		if(y==a[p]) m++,p++;
		ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

注：本题解中的“sp”就是原题中的特殊的平台

有几个点需要注意一下：

## ① m每次增大是永久增大，不要像本蒟蒻那样写成增大一次！（卡了好长时间QwQ）

②不是每一个增大m的点都会停留，所以每次要把当前位置同所有sp对比。（感觉应该更快的方法，但是本人太蒻了并不能想到）

③女装大佬Hikari是从0开始跳的，这个多想想就能想到。

~~④记得输出~~

完结撒花 QwQ


---

## 作者：CSP_Sept (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P5613)

### **一大坑点：从$0$起跳**

解决方法：$int~step=0$

特殊台阶用一个数组标记即可：

```cpp
int flag[1000]={0};
int k;
cin>>k;
if(k>0) for(int j=1;j<=k;j++){
		cin>>tmp;
		flag[tmp]=1;
	}
```
模拟部分用一个while就OK了：
```cpp
while(1){
		if(flag[step]==1) m++;
		step+=m;
		t++;
		if(step>=n) break;
	} 
```


粘上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int flag[1000]={0};
int n,m,k,tmp,step=0,t=0;//step=0是说明从0起跳 
int main(){
	cin>>n>>m>>k;
	if(k>0) for(int j=1;j<=k;j++){
		cin>>tmp;
		flag[tmp]=1;
	}
	while(1){
		if(flag[step]==1) m++;
		step+=m;
		t++;
		if(step>=n) break;//一直循环到跳到顶部
	} 
	cout<<t;
	return 0;
} 
```


---

## 作者：nju_zdd (赞：1)

# 入门签到题
根据题意：Hikari 的面前有$ n $级台阶，每 $1s$她可以向上跳 $m$级台阶。

当走到特殊的平台上时**恰好**停留，$m$会增加 $1$。


------------
## 那么我们开始愉快的模拟吧！

$\color{red}\text{附AC代码：}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,s,a[19],t;
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for (int i=1;i<=k;i++) scanf("%d",&a[i]);//读入特殊台阶
	while(s<n){//还没走到尽头
		for(int i=1;i<=k;i++){
			if(s==a[i]) m++;//走到特殊台阶，让m自身+1
		}
		s+=m;//每次走m级台阶
		t++;//计时
	}
	cout<<t;
	return 0;
}
```

$\color{red}\text{好了就是这样，祝大家切红题愉快！}$

---

## 作者：StudyingFather (赞：1)

真的是一道模拟题。

按题意模拟就行了鸭。每次向上跳的时候如果发现自己跳到了特殊的平台，就执行 `m++` 的操作。

因此本题是一道不折不扣的签到题。

```cpp
#include <cstdio>
#include <set>
using namespace std;
set<int> s;
int main()
{
 int n,m,k;
 scanf("%d%d%d",&n,&m,&k);
 for(int i=1;i<=k;i++)
 {
  int x;
  scanf("%d",&x);
  s.insert(x);
 }
 int tmp=0;
 for(int i=1;;i++)
 {
  tmp+=m;
  if(s.count(tmp))m++;
  if(tmp>=n)
  {
   printf("%d\n",i);
   return 0;
  }
 }
}
```


---

## 作者：路人_ (赞：1)

## 题解 P5613 【[MtOI2019]黑蚊子多】

背景太骚了！！！



------------
既然没人发题解，~~那我来~~~~~

其实很简单，读完题简单想想，就切掉了；



------------
**Hikari 的面前有)n(1≤n≤1000) 级台阶，**

**每 1s 她可以向上跳m(1≤m≤n) 级台阶。（不在中间的台阶上停留）**

**台阶上有 k(k≤10) 个特殊的平台 a_i** 

**Hikari 在该平台 停留 时会使得 m增加 1。**

**请问 Hikari 到达台阶顶部花费的时间。**



一道**模拟**而已
![](https://p1.ssl.qhimg.com/t01a29beaaca4b03cc5.jpg)

上代码（[博客](https://www.luogu.org/blog/lwhd/)食用效果更佳）~~


------------
```c
#include<iostream>
using namespace std;
int a[10100];
bool vis[10100];
int main()
{
	int n,m,k,ans=0;
	cin>>n>>m>>k;//输入
	for(int i=1;i<=k;i++)
	{
		cin>>a[i];
		vis[a[i]]=0;
	}//输入+ vis[]的初始化（不必要），
	int i=0;//i是步数；
	while(i<n)
	{
		i+=m;//执行一次
		for(int j=1;j<=n;j++)
		{
			if(i==a[j]&&vis[a[j]]==0)//判断是不是特殊的平台 和是否到过此特殊的平台 
			{
				vis[a[j]]=1;
				m++;
			}
		}
		ans++;	//存跳跃次数
	}
	cout<<ans<<endl;//输出
	return 0;//完美结束
}
```



------------


------------
祝大家**CSP rp++**！！！！




---

## 作者：A_Đark_Horcrux (赞：1)

思路很明确，直接模拟，用一个s记录跳过的总台阶数，每次s+=m，如果刚好到平台上就m++。一点优化都不用qwq

但是窝在比赛的时候就是没找到黑蚊子QAQ

窝的代码怎么炸的？

```cpp
#include<cstdio>
using namespace std;
long long n,m,k,s,t,l=1,i,a[101];
int main()
{
	scanf("%lld %lld %lld",&n,&m,&k);
	for(i=1;i<=k;i++) scanf("%lld",&a[i]);
	do
	{
		s+=m; t++;
		if(s==a[l]) m++,l<k?l++:l=l;
	}while(s<n);
	printf("%lld",t);
	return 0;
} 
```
Hack数据（@梧桐灯 大佬提供
```
13 4 2
3 8
```
可以看出窝的代码中，比较对象会一直停留在没跳到的平台QAQ

然后又改！
```cpp
#include<cstdio>
using namespace std;
long long n,m,k,s,t,l=1,i,a[101];
int main()
{
	scanf("%lld %lld %lld",&n,&m,&k);
	for(i=1;i<=k;i++) scanf("%lld",&a[i]);
	while(s<n)
	{
		s+=m; t++;
		while(s>a[l]) l++;
		if(s==a[l]) m++,l<k?l++:l=l;
	}
	printf("%lld",t);
	return 0;
} 
```
一片紫色XD

原因是当l超过k时，a[l]都是0，l的大小会突破天际。

最终AC代码OvO！
```cpp
#include<cstdio>
using namespace std;
long long n,m,k,s,t,l=1,i,a[10001];//分别为：平台数，初始跳跃距离，平台数量，总距离，总时间，当前正在比较的平台位置，i，平台位置
int main()
{
	scanf("%lld %lld %lld",&n,&m,&k);
	for(i=1;i<=k;i++) scanf("%lld",&a[i]);//输入
	while(s<n)//没到终点
	{
		s+=m; t++;//距离加上m，时间++
		while(s>a[l]&&l<k) l++;//找到当前位置往后的第一个平台（注意l<k！）
		if(s==a[l]) m++,l<k?l++:l=l;//如果就在脚下，m++（还是注意l<k！）
	}
	printf("%lld",t);//输出
	return 0;//完结撒花awa
} 
```


---

## 作者：ShineEternal (赞：1)

[$My\ blog$](https://blog.csdn.net/kkkksc03/article/details/102868191)


## solution:

- 60pts:

直接输出跳的次数即可

- 100pts：

~~观察到作为T1数据量却很小于是就想到了模拟~~

其实是看到作为特殊点的k个数特别小。

于是直接枚举每个中间点即可。

## code：
```cpp
#include<cstdio>
using namespace std;
int a[15];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&a[i]);
	}
	int tmp=0,ans=0;
	while(13)
	{
		if(tmp>=n)
		{
			break;
		}
		for(int i=1;i<=k;i++)
		{
			if(tmp==a[i])
			{
				m++;
			}
		}
		tmp+=m;
		ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_短笛无腔_ (赞：1)

首先让我们想象一幅画面：

有$n$个台阶，$hikari$一步能跳$m$个台阶，台阶上有$k$个平台，每当$hikari$在平台上时$m+1$。

看到大佬们用的，树、桶排$STL$一起上，我忍不住吐槽：这道题目真那么难吗？

其实只需要算出$hikari$每步跳几个台阶。

给大家献上无高深算法$AC$代码：

```cpp
#include<cstdio>
using namespace std;
int main(){
    int n,m,t,r[15],a=0,s=0;
    scanf("%d%d%d\n",&n,&m,&t);
    for(int b=0;b<t;b++)scanf("%d",&r[b]);
    while(n>0){
        n-=m;//台阶数随着跳跃而减少
        a+=m;//这是个储存器
        s++;//步数+1
        for(int c=0;c<t;c++){
            if(r[c]==a)m++;//如果到平台了m++
        }
    }
    printf("%d",s);
    return 0;
}
```

~~看来我的代码写的最短~~

---

## 作者：爱晚亭哦 (赞：1)

~~精彩题目背景~~

~~话说题目和题意有关系吗（黑人问号）~~

刚开始以为是个搜索，结果发现步数一定，所以变成了**简单模拟**

~~我还以为t1就这么毒瘤了qwq~~

因为平台是递增的，所以不用考虑以前的平台，但我还是保险搜一遍

Code:
```
#include<cstdio>
int a[101];
int main()
{
	int n,m,k,ans=0;
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=k;i++)
		scanf("%d",&a[i]);
	int sum=0;
	while(sum<n)
	{
		for(int j=1;j<=k;j++)
			if(sum==a[j])
			{
				m++;
				break;
			}
		sum+=m;
		ans++;
	}
	printf("%d",ans);
}
```
这次比赛比上次好多啦，上次我发现我连红题都不会自闭了qwq

---

## 作者：人间凡人 (赞：1)

这是一道很水的**模拟题**

枚举第$i$ 从$1$到$k$

开一个变量$now$，代表当前到的台阶。

如果$(a[i]-now)$ $\ $ $mod$ $\ $ $m=0$
那么就加上$(a[i]-now)$ 除以 $m$ $,$ 并且将$m$加上$1$ $,$ $now$变为$a[i]$。 

最后再让答案加上$(n-now)$ 除以 $m$ 即可。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[1005],ans,now;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int main(){
    n=read();m=read();k=read();now=0;
    for(int i=1;i<=k;i++)a[i]=read();
    for(int i=1;i<=k;i++){
        if((a[i]-now)%m==0){
            ans=ans+(a[i]-now)/m;
            now=a[i];
            m++;
        }
    }
    if((n-now)%m==0)ans=ans+(n-now)/m;
    else ans=ans+(n-now)/m+1;
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Celtic (赞：0)

题目链接[[MtOI2019]黑蚊子多](https://www.luogu.com.cn/problem/P5613)

直接来一波模拟~~

每次往上跳m个单位，如果当前在平台就m++，直接统计答案即可。

orz一下1分钟切掉的神仙。

代码
```cpp
#include<bits/stdc++.h>
#define N 1001001
#define MAX 2001
#define re register
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re char c=getchar();re bool pd=false;
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
    ret=pd?-ret:ret;
    return;
}
ll n,m,k,a[N],tmp;
bool b[N];
main()
{
	read(n);
	read(m);
	read(k);
	for(re int i=1;i<=k;i++)
	{
		read(a[i]);
		b[a[i]]=true;
	}
	re ll cnt=0;
	while(tmp<n)
	{
		cnt++;
		tmp+=m;
		if(b[tmp])
			m++;
	}
	printf("%lld\n",cnt);
	exit(0);
} 
```


---

## 作者：Forest_Prince (赞：0)

#### 这道题我想到了一种很巧妙的解法
~~可惜这里太小我写不下~~

既然要走楼梯，我们就把每次可以加步数的楼梯称之为超级楼梯

我们把超级楼梯的位置放到一个队列里

每次走的时候判断一下是不是超级楼梯

还有一种情况就是走不到这个超级楼梯，我直接迈过

###### （不判会扣20） ~~趁机吐槽出题人~~

```cpp
#include<iostream>
#include<queue>
using namespace std;
queue<long long> q;
int main(){
    ios::sync_with_stdio(false);//加快cin cout 
	long long n,m,k,step=0,ans=0,a;			//我也不知道为什么开long long 上次 
	cin>>n>>m>>k;							//被CCF卡掉了50分就再也不敢不开了 
	for(int i=1;i<=k;i++){
		cin>>a;
		q.push(a);
	}	
	for(int i=1;i<=n;i++){
		ans++;
		step+=m;
		if(step>=n) break;
		if(step>q.front()&&q.size()>1) {	// 判断一下 是不是跳过了这个台阶 
			q.pop();
		}
		if(step==q.front()&&!q.empty()){
			m++;//能力进阶~ 
			q.pop();// 走过楼梯 
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：opened (赞：0)

>按题意模拟即可

每次向上跳 $m$ 级台阶，直接 $while$(不越界) 去统计所跳的次数(注意巧用 $do$-$while$ )

如果跳到特殊的点上 $m$++

维护一个**桶**去判断一个台阶是否是特殊

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int read(){
    int x=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
int a[2000],cnt; 
int main(){
    int n=read(),m=read(),k=read();
    for(int i=1;i<=k;i++){
		int x=read();
		a[x]=1;
	}
	int s=0;
    do{
		s+=m;
		cnt++;
    	if(a[s]) m++;
	} while(s<n);
	printf("%d\n",cnt);
    return 0;
}
```

---

## 作者：ThursdayZi562 (赞：0)

一开始我看到这道题，想到了dp的一道题，却发现原来只是简单的模拟。

（原谅我想太多了，emmmmm）

![](https://cdn.luogu.com.cn/upload/image_hosting/wwg7eszc.png)

这个题目背景瞬间激发了我们机房对比赛的兴趣？？

|其实下一题的膜拜传教更加令人感兴趣|

------------
操作1，直接特判（对数据的过分信任迫使我进行了这样一番操作），输出样例2和6；


期望得分20分。

代码如下：


```cpp
#include<iostream>
using namespace std;
int main()
{
	int n,m,k;
	cin>>n;
	if(n==10)
	{
		cout<<2;
		return 0;
	}
	cout<<6;
 } 

```

操作2，简单模拟，期望得分100分

来个小图解（虽然我知道有点多余

![](https://cdn.luogu.com.cn/upload/image_hosting/0d0nwc1k.png)

（其实就是给定n,m和哪些点m会加一，求到达n的时间，详见注释）

```cpp
#include<iostream> 
#include<cstdio> 
using namespace std;
int main()
{
	int n,m,k,a[11];
	scanf("%d%d%d",&n,&m,&k);
	if(k==0)
	{
	    int num;
		if(n%m==0)
		{
			num=n/m;
		    printf("%d\n",num);
		}
		if(n%m!=0)
		{
			num=n/m+1;
			printf("%d\n",num);
		}
	}//先把简单的k=0的情况处理掉
  //整除就刚好到顶，不整除就+1
	else//然后是k！=0的情况
	{
		int ans=0,kum=0;
		for(int i=1;i<=k;i++)
		scanf("%d",&a[i]);//输入有跳跃加成的台阶
		for(int j=0;j<n;j+=m)//直接用j每次加上m
		{
			for(int i=1;i<=k;i++)
			{
				if(j==a[i])//如果我们刚好跳到了欧跳跃加成的台阶
				{
					m++;
					continue;
				}
			}
			kum++;//加上时间
		}
		printf("%d",kum);//最后输出
	}
	return 0;
}
```
## 如果大家有更好的方法，可以教教蒟蒻。

谢谢各位大佬的阅读Thanks♪(･ω･)ﾉ

---

## 作者：腐草一刹 (赞：0)

**没人发题解，我就发一哈，希望能帮到新手吧。**
不懂什么技巧，全靠模拟，我是菜鸟，不喜勿喷，大佬们多多见谅。
```cpp
#include<iostream>
using namespace std;
int n,m,k;
bool f[1005]={0};
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
	if(k==0){
		if(n%m==0) cout<<n/m<<endl;
		else cout<<(n/m+1)<<endl;
		return 0;
	}
	for(int i=0;i<k;++i){
		int a;
		cin>>a;
		f[a]=1;
	}
	int ans=0,ste=0;
	while(ste<n){
		if(f[ste]) m++;
		ste+=m;
		ans++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Create_Random (赞：0)

一道签到水题

~~然而我WA了3次~~

本蒟蒻思路：

直接每次加m

并统计跳的次数

遇到特殊平台+1即可

最后要判断：

是否正好跳到

如果不是就+1

贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int ans;
int a[20];
int flag;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=m;i<=n;i+=m)
	{
		ans++;//统计跳的次数
		for(int j=1;j<=k;j++)
		{
			if(i==a[j])
			{
				m++;//如果是特殊平台，m+1
			}
		}
		flag=i;//找到最后一次跳到的位置
	}
	if(flag!=n)//不是正好跳到时需+1
	{
		ans++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：仗剑_天涯 (赞：0)

这道题n<=1000,k<=10,而且每次跳跃只有一个选择,是可以用模拟做的。
```
时间复杂度：O(n*k)=1000*10=10000
空间复杂度：O(k)=10
```
思路：枚举每次跳跃到达的平台，如果是特殊的平台，则m增加1。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[10010],s,bo,i;//大多数情况下，数组开大一点更保险
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>a[i];
	}//读入
	while(i<n)//枚举平台
	{
		s++;//统计跳跃次数
		i+=m;
		bo=0;//标记重置
		for(int j=1;j<=k;j++)
		{
			if(a[j]==i)//如果是特殊平台
			{
				bo=1;//标记找到了
				break;//已经找到,不用往下找
			}
		}
		if(bo==1)//是特殊平台
		{
			m++;//m增加1
		}
	}
	cout<<s;
} 
```


---

## 作者：江山_远方 (赞：0)

这题思路很简单 按照题意模拟即可

给定n,m和哪些点m会加一，求到达n的时间

那代码就轻而易举的拟出来了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans,x,a[1100];
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&x);
		a[x]=1;
	}//读入,把哪些点m会加一标记出来
	x=0;//从零开始
	while(x<n)//还没有走到n
	{
		x+=m;//往前走
		if(a[x])m++;//如果走到x时m应该加一,那么m++
		ans++;//步数加一
	} 
	cout<<ans;//输出步数
	return 0;
}
```

---

## 作者：Guess00 (赞：0)

**这是一道模拟题**

我们可以将平台作为分界线,将$n$级台阶分为$k+1$块进行模拟$.$

如果能跳到平台上则对$m$进行修改$,$顺带将这一块用的时间加进答案里$.$

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
int n,m,k,x,i,ans,a[15];
inline void read(int &x)  //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)  //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n),read(m),read(k);
	for (i=1;i<=k;i++)
		read(a[i]);    //读入 
	for (i=1;i<=k;i++)  //对每块进行模拟 
		if ((a[i]-x)/m==ceil(double(a[i]-x)/m))  //判断是否能到平台
		{
			ans+=(a[i]-x)/m;  //记录时间 
			m++;      //修改m 
			x=a[i];   //x记录未计算作时间的台阶的部分的开头 
		}
		//此处不用考虑跳不到平台的情况,可直接忽略平台,计入下一块 
	ans+=ceil(double(n-x)/m);   //不能忘了最后一块 
	print(ans);       //输出 
	return 0;
}
```
~~话说这题n可以开到2e9,k可以开到1e6的~~

---


# 「Wdoi-5」天才⑨与天才拆分

## 题目背景

$\kern{75pt}$![](https://cdn.luogu.com.cn/upload/image_hosting/ghy90htm.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

萌萌琪露诺在寺子屋的教室里面见到了哆来咪·苏伊特。心怀好意的哆来咪告诉了她期末考试的题目，只要解出这些题目就能免于被慧音老师头槌。兴奋的琪露诺告别了哆来咪，猛然发现自己已经身处在期末考试的考场之上！但是琪露诺实在是太笨了，醒来就把哆来咪告诉她的题目忘得一干二净，只记得试卷上有大量的⑨。

现在琪露诺已经在考试啦，你可以使用⑨的妖精链接回答她的问题，以平复她忘记了考试答案的悲痛。你能帮帮她吗？

温馨提示：考试作弊是不对的哦。

## 题目描述

琪露诺定义一个十进制正整数为「$k$ 阶天才数」，当且仅当该整数的**位数**为 $k$ 的倍数，且**每一个数位**均为 $9$。例如，$9999$ 是 $2$ 阶天才数，而 $999$ 不是 $2$ 阶天才数，但是它是 $1$ 阶天才数，也是 $3$ 阶天才数。

琪露诺给定你 $t$ 个询问，每个询问有两个整数 $n$ 和 $k$，希望你能帮帮她，告诉她能不能把 $n$ 拆分成若干个 $k$ 阶天才数的和。

## 说明/提示

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\n{\text{无特殊限制}}
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Task} & \bm t= & \bm {n_i \le} & \bm {k_i \le} \cr\hline
1 & 1 & 233 & 1 \cr\hline
2\sim 6 & 1 & 10^3 & 1 \cr\hline
7\sim 8 & 10 & 10^9 & 1 \cr\hline
9 & 10^3 & 10^9 & 1 \cr\hline
10 & 10^3 & 10^{18} & 1 \cr\hline
11\sim 20 & 10^3 &  10^{18} & 10 \cr\hline
\end{array}
$$

对于全部数据，满足 $1\le t\le 10^3$，$1\le n_i\le 10^{18}$，$1\le k_i\le 10$。

## 样例 #1

### 输入

```
2
1 999
2 999```

### 输出

```
aya
baka```

# 题解

## 作者：LYqwq (赞：32)

[题目传送门](https://www.luogu.com.cn/problem/P8225)

# 题目大意

定义一个十进制正整数为「$k$ 阶天才数」，当且仅当该整数的位数为 $k$ 的倍数，且每一个数位均为 $9$。

例如，$9999$ 是 $2$ 阶天才数，而 $999$ 不是 $2$ 阶天才数，但它是 $1$ 阶天才数，也是 $3$ 阶天才数。

现在给定 $t$ 个询问，每次询问给定两个正整数 $n$ 和 $k$，求能否把 $n$ 拆分成若干个 $k$ 阶天才数的和。

能则输出一行一个字符串 `aya`，否则输出 `baka`。

# 思路

赛时竟读错题，搞成判断 $n$ 是不是 $k$ 阶天才数了...喜提 $10$ pts。

首先是如何取这个「$k$ 阶天才数」，很容易发现最小的「$k$ 阶天才数」就可以应对所有情况。

例如，$k=3$，那么最小的「$k$ 阶天才数」就是 $999$，可以发现 $999999 \bmod 999=0$，$999999999 \bmod 999=0$，$999999999999 \bmod 999=0$······

总之，用多大的「$k$ 阶天才数」组成 $n$，都是用对应数量的最小的「$k$ 阶天才数」来组成 $n$。

用多个不同的「$k$ 阶天才数」也是如此，只需用多个最小的「$k$ 阶天才数」即可拼凑而成。

于是，我们只需判断 $n \bmod$ 最小的「$k$ 阶天才数」是否等于 $0$ 即可完成本题。

我们用一个数组 $m$ 来存储最小的「$k$ 阶天才数」，询问时直接用于判断即可。

**注意，要开 `long long`，最小的「$10$ 阶天才数」超出了 `int` 范围。**

# 代码

```cpp
#include <iostream>
using namespace std;
long long t,k,n,m[15]={0,9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999};

int main(){
    cin >> t;
    while(t--){
        cin >> k >> n;
        if(n%m[k]==0) puts("aya");
        else puts("baka");
    }
    return 0;
}
```



---

## 作者：minstdfx (赞：18)

### 题意：
琪露诺定义一个十进制正整数为「$k$ 阶天才数」，当且仅当该整数的**位数**为 $k$ 的倍数，且**每一个数位**均为 $9$。例如，$9999$ 是 $2$ 阶天才数，而 $999$ 不是 $2$ 阶天才数，但是它是 $1$ 阶天才数，也是 $3$ 阶天才数。

琪露诺给定你 $t$ 个询问，每个询问有两个整数 $n$ 和 $k$，希望你能帮帮她，告诉她能不能把 $n$ 拆分成若干个 $k$ 阶天才数的和。

---

每个 $k$ 阶天才数都是 $k\times t$ 个 $9$ 拼成的，那么把它按照每 $k$ 个 $9$ 分为一段，比如：  
$9999$ 是 $2$ 阶天才数，$9999=9900+99$。

可以发现每一段都是 $99$ 的倍数。

---
同理，对于任意的 $k$、$t$，我们都可以类比拆分：

$\overbrace{999\ldots 9}^{k\times t\text{\tt个}}=\overbrace{999\ldots 9}^{k\text{\tt个}}\overbrace{000\ldots 0}^{k\times t-k\text{\tt个}}+\overbrace{999\ldots 9}^{k\text{\tt个}}\overbrace{000\ldots 0}^{k\times t-2k\text{\tt个}}+\ldots +\overbrace{999\ldots 9}^{k\text{\tt个}}$

其中每一项都是 $\overbrace{999\ldots 9}^{k\text{\tt个}}$ 的倍数，  
因此，任意 $k$ 阶天才数都是 $\overbrace{999\ldots 9}^{k\text{\tt个}}$，即 $10^k-1$ 的倍数。

---
我们大家都知道，如果一些数都是 $n$ 的倍数，那么它们的和也是 $n$ 的倍数。并且，每个 $n$ 的倍数一定能拆分成 很多（$\frac m n$）个 $n$ 的和。

所以回到题目，只要判断 $n$ 是否是 $10^k-1$ 的倍数就好啦！

---
核心代码：
```cpp
//预处理10的n次方
pow10[0]=1;
for(int i=1;i<=20;++i) pow10[i]=pow10[i-1]*10;
scanf("%d",&t);
while(t--) {
	scanf("%lld %lld",&k,&n);
	if(n%(pow10[k]-1)==0) printf("aya\n");
	else printf("baka\n");
}
```


---

## 作者：猜一猜我是谁 (赞：6)

# 思路
可以发现一个有趣的性质：如果一个数是 k 阶天才数，那么它一定是 k 个 9 的倍数。比如 2 阶天才数 9999，它就是 99 的倍数。

利用这个性质，我们可以进一步得出：只要 n 能被 k 个 9 整除，那么回答 aya，否则回答 baka。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t,k;
    long long n;
    cin>>t;
    while(t--){
        cin>>k>>n;
        long long d=9;
        for(int i=2;i<=k;i++)//计算 k 个 9 的值
            d=d*10+9;
        if(n%d==0) cout<<"aya\n";
        else cout<<"baka\n";
    }
}
```

---

## 作者：Nygglatho (赞：6)

首先，我们会发现一个定理：如果一个数是 「$k$ 阶天才数」，那么这个数 **一定** 是只有 $k$ 个 $9$ 的数字的倍数。

因为，只有 $k$ 个 $9$ 的数字可以通过乘以 $1, \begin{matrix}k-3\\10\overbrace{\dots}01\end{matrix}, \begin{matrix}k-3\\10\overbrace{\dots}01\end{matrix}\begin{matrix}k-3\\0\overbrace{\dots}01\end{matrix}\cdots$ 来变成有 $k$ 个 $9$ 的数字，有 $2k$ 个 $9$ 的数字，有 $3k$ 个 $9$ 的数字，这样以此类推，无论如何，都可以变成 「$k$ 阶天才数」。

证明（可以通过乘以 $1, \begin{matrix}k-3\\10\overbrace{\dots}01\end{matrix}, \begin{matrix}k-3\\10\overbrace{\dots}01\end{matrix}\begin{matrix}k-3\\0\overbrace{\dots}01\end{matrix}\cdots$ 以变成 「$k$ 阶天才数」）：

以乘以$ \begin{matrix}k-3\\10\overbrace{\dots}01\end{matrix}$ 为例，$1$ 都满足了最后 $k$ 位是 $\begin{matrix}k-2\\9\overbrace{\dots}9\end{matrix}$，中间的 $0$ 满足错位相加是不加上一些奇怪的数字，最前面的 $1$ 也满足了前面是 $\begin{matrix}k-2\\9\overbrace{\dots}9\end{matrix}$，如下图：

![](https://s3.bmp.ovh/imgs/2022/03/c2e659f09506d7ec.jpg)

乘以 $\begin{matrix}k-3\\10\overbrace{\dots}01\end{matrix}\begin{matrix}k-3\\0\overbrace{\dots}01\end{matrix}$ 以及其它的数也是同理，每 $k - 1$ 位上的 $1$ 保证数位上都是 $9$，其它的 $0$ 保证数位相加时只出现 $0$。

最后，由于可以「$k$ 阶天才数」是只有 $k$ 个 $9$ 的数字的倍数，那么「$k$ 阶天才数」是由若干个只有 $k$ 个 $9$ 的数字相加得到，显然 $n$ 也必须是由若干个只有 $k$ 个 $9$ 的数字相加得到，所以只需要判断下 $n$ 是否是只有 $k$ 个 $9$ 的数字的倍数即可。

Code:
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll v[10086] = {0, 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999, 99999999999, 999999999999};

int main() {
	ll t, n, k;
	cin >> t;
	while(t--) {
		cin >> k >> n;
		if (n % v[k] == 0) puts("aya");
		else puts("baka");
	}
} 

---

## 作者：Shimotsuki (赞：3)

### 思路
$k$ 阶天才数被定义为 $k\times i$ 个 $9(i\ge 1)$。简单思考可得一个性质：任意 $k$ 阶天才数可分解为若干个 $k$ 个 $9$ 拼成的数。所以题目就简化为了一个数是否可以拆分成若干个 $k$ 个 $9$ 拼成的数。做法也很简单，直接暴力求出 $k$ 个 $9$ 拼成的数，然后判断模数即可。

- 注意开 `long long`

[代码](https://www.luogu.com.cn/paste/ot3ej7ow)


---

## 作者：Terraria (赞：3)

## $\text{Introduction}$

给定 $k$，一种数为「$k$ 阶天才数」当且仅当这个数的位数为 $k$ 的倍数，且每一位上的数都是 $9$。

给定 $n$，求 $n$ 能否由若干个 $k$ 阶天才数相加得到。

## $\text{Solution}$

乍一看想要搜索，但是我们很快就会猜想：

> $xk$ 位的「$k$ 阶天才数」一定是 $k$ 位的「$k$ 阶天才数」的倍数。其中 $x$ 为任意正整数。

证明很简单，$xk$ 位 的 $9\cdots9$ 可以分解为 $k$ 位的 $(9\cdots9) \times(10\cdots010\cdots010\cdots)$，前面是 $k$ 个 $9$，后半部分由 $1$ 个 $1$ 和 $x-1$ 个 $0\cdots1$ 组成，里面有 $k-1$ 个 $0$。

这说明，如果一个数可以由 $xk$ 位的天才数相加得到，那一定可以由若干个 $k$ 位的天才数相加得到。

所以我们只需要判断 $n$ 是否为 $k$ 位天才数的倍数即可。

---

## 作者：快斗游鹿 (赞：3)


## 思路

首先，先注意以下细节：

$1.$ 告诉她能不能把 $n$ 拆分成若干个 $k$ 阶天才数**的和**。并非去拼凑。

$2.$ 当且仅当该整数的位数为 $k$ 的倍数，且每一个数位均为 $9$。而 $n$ 未必每个数位均为 $9$ 。

$3.$ $1\le n_i\le 10^{18}$ ，这个数据范围做法明显不是暴力。

观察完细节后，思考做法。

首先要知道，$9999$ 和 $99$ 都可算作 $2$ 阶天才数。而 $9999$ % $99$ $=$ $0$ 。也就是说，如果这个数能被 $9999$ 相加得来，就一定能被 $99$ 相加得来。其余阶天才数自行类比。又因为 $k$ 小于等于 $10$ ，所以开一个数组存下所有最小的 $k$ 阶天才数，再对其取模即可。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
unsigned long long n;
long long key[20]={0,9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999};
string s;
int l;
int k;
int t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>k>>n;
		if(n%key[k]==0){
			cout<<"aya"<<endl;
		}
		else{
			cout<<"baka"<<endl;
		}
	}
	return 0;
}

```


---

## 作者：caibet (赞：3)

### 题意：

$t$ 组数据，每组数据求 $n$ 能不能表示为若干个由 $k$ 的倍数个 $9$ 组成的数的和。

### 解法：

显然，对于所有正整数 $x$，$xk$ 个 $9$ 组成的数也可以表示为 $\sum\limits^{x-1}_{i=0}10^{ik}$（即 $10\dots010\dots1$）个 $k$ 个 $9$ 组成的数的和。

例如：当 $k=3$ 时，$3k$ 个 $9$ 组成的数为 $999999999$，而 $k$ 个 $9$ 组成的数为 $999$。此时，$999999999$ 就可以表示为 $1001001\times999$。

因此，我们只需要判断 $n$ 能不能表示为 $k$ 个 $9$ 组成的数之和，也就是能否被 $k$ 个 $9$ 组成的数整除即可。

记得开 long long。

```cpp
namespace{
	int T,k;
	ll n,p;
	void work(){
		T=read();
		while(T--){
			k=read();n=read<ll>();
			p=0;
			for(ll i=1;k;i*=10,--k){
				p+=i*9;//算出 k 个 9 组成的数
			}
			puts(n%p?"baka":"aya");
		}
	}
}
```

---

## 作者：TernaryTree (赞：2)

## 题目大意

定义 $k$ 阶天才数是 $k$ 倍数个 $9$，例如 $9999$ 是 $1,2,4$ 阶天才数。

给定整数 $n,k$，求是否可以将 $n$ 表示为若干个 $k$ 阶天才数的和。

## 思路分析

我们知道，$m$ 个 $9$ 拼在一起就是 $10^m-1$。

我们还知道，$9999=99\times 101$，$999999999=999\times 1001001$。

所以我们知道，$sk$ 阶天才数定是 $k$ 阶天才数的倍数。

那么问题就简化了：就是判断 $n\bmod (10^k-1)=0$。

***

因为 $k\le 10$，所以我们可以从对 $1$ 乘 $k$ 次 $n$，就可以得到 $n^k$：

```cpp
int power(int base, int freq, int mod) {
    int ans = 1;
	for (int i = 0; i < freq; i++) {
        ans *= base;
        ans %= mod;
    }
    return ans;
}
```

时间复杂度：$O(k)$。

***

这里重点介绍的是：**快速幂**。

我们知道，乘方运算有结合律，即 $x^a\times x^b = x^{ab}$。

所以我们就可以对 $f(n,k,p) = n^k \ \bmod \ p$ 进行分解：

$$ f(n,k,p) = \begin{cases} 
f(n,\frac12k,p)^2\ \bmod\ p  & (k\ \bmod\ 2 = 0)  \\
f(n,\frac12(k-1),p)^2\ \times n \ \bmod\ p  &(k\ \bmod\ 2 = 1)
 \end{cases}$$
 
代码就不难写了：

```cpp
int power(int base, int freq, int mod) {
	int ans = 1, tmp = base;
	while (freq > 0) {
		if (freq % 2 == 1) ans = ans * tmp % mod;
		freq /= 2;
		tmp = tmp * tmp % mod;
	}
	return ans;
}
```

时间复杂度：$O(\log k)$。适用于指数较大的情况。

***

## 完整代码

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int t, k, n;
bool flag = true;

int power(int base, int freq) {
    int ans = 1, tmp = base;
    while (freq > 0) {
        if (freq % 2 == 1) ans = ans * tmp;
        freq /= 2;
        tmp = tmp * tmp;
    }
    return ans;
}

signed main() {
    cin >> t;
    while (t--) {
        cin >> k >> n;
        if (n % (power(10, k) - 1) == 0) {
            cout << "aya" << endl;
        } else {
            cout << "baka" << endl;
        }
    }
    return 0;
}
```

---

## 作者：Cure_Wing (赞：2)

* ### 题意
- 把一个数分成若干个天才书的和。
* ### 解法
- 根据定义，我们可以假设 $k=1$，再根据题目描述，此时可以列得一个式子：$a_19+a_299+a_3999+...+a_e999...9=n$，此时要求解的就是这个式子是否存在整数解。
- 根据这个式子，仔细观察，各项的系数均为第一项的倍数，所以我们可以写成 $(a_1+11a_2+111a_3+...+(111...1)a_e)9=n$，由于 $a_1,a_2,a_3,...,a_e$ 和 $9,n$ 均为整数，所以要证明的就是 $(a_1+11a_2+111a_3+...+(111...1)a_e)$ 即 $n/9$ 是否为整数。
- 同理，我们可以推出当 $k,n$ 为任意数时，设 $s$ 表示 $k$ 个 $9$ ,则若 $n \mod s=0$，则至少有一组满足条件的解。
* 代码
- 
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,k,n,x;
ll make(ll a,ll b){//制造含有n个9的数
	ll s=0;
	for(ll i=1;i<=b;++i)
		s=s*10+a;
	return s;
}
int main(){
	for(scanf("%lld",&t);t--;){
		scanf("%lld%lld",&k,&n);
		x=make(9,k);
		puts(n%x?"baka":"aya");//依据见证明过程
	}
	return 0;
}
```


---

## 作者：charleshe (赞：2)

数学题。

$k$ 阶天才数除以 $99\ldots9$ 的余数一定为 $0$（除数中有 $k$ 个 $9$）。

那么，对于每一组数据，我们只要构造出这个除数，就能判断一个数是否是$k$ 阶天才数了。

注意事项：

- 要开长整型（话说这几次月赛的题目都要开长整型欸）。

- 求除数的过程不需要高精度（毕竟这个数最大也只有 $10^{10}-1$，爆不掉长整型）。

分析了这些，代码就好写了。

```cpp
#include <iostream>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		long long n,k,x=0;
		cin>>k>>n;
		while(k){//利用一组while循环求出除数
			x=x*10+9;
			k--;
		}
		if(n%x==0) cout<<"aya"<<endl;//判断是不是k阶天才数
		else cout<<"baka"<<endl;
	}
	return 0;
}
```


---

## 作者：lsj2009 (赞：2)

## 题目大意
给定 $n$ 与 $k$，问 $n$ 是否可以由若干个个 $\underbrace{99...999}_{xk},x\ge1$ 相加组成。

## 思路

****引理：$\underbrace{99...999}_{xk}$ 必定是 $\underbrace{99...999}_{k}$ 的倍数。****

证明：

- 显而易见，将 $\underbrace{99...999}_{k}\to\underbrace{99...999}_{k}\times\underbrace{100...001\underbrace{00...00}_{k-1}}_{x-1}1$ 便为 $\underbrace{99...999}_{xk}$。

也是就说，$n$ 若满足条件肯定是若干个 $\underbrace{99...999}_{k}$ 相加而成的。

而 $\underbrace{99...999}_{k}=10^k-1$，所以我们只需要判断 $10^k-1$ 是否能整除 $n$ 就行了。

---

## 作者：BlackPanda (赞：2)

**[题目传送门](https://www.luogu.com.cn/problem/P8225)**

------------
### 题意：
定义一个十进制数为 $k$ 阶天才数，并且需要满足：

- 该整数的**位数**是 $k$ 的倍数。

- **每一个数位**都是 $9$。

有 $t$ 次询问，每次询问给出 $n$ 和 $k$，求 $n$ 是否可以拆分成若干个 $k$ 阶天才数的和。

------------
### 思路：
- 题目求的是 $n$ 是否可以被 $k$ 阶天才数整除，我们可以用 $n$ 取模 $k$ 阶天才数。

- 例如 $k=3$ 时，$999,999999...$ 这些数都是可以的，但是 $n$ 只要可以被最小的 $k$ 阶天才数整除，那么答案就是可以的。

- 我们再看 $k$ 的范围是 $1≤k≤10$，所以我们可以用打表的方式，将 $10$ 个不同范围的 $k$ 阶天才数存到数组里，每次询问分别取模就可以了，这样我们就可以做到每次询问都是 $O(1)$ 的时间复杂度。

------------
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

long long ans[15]={0,9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999};

inline long long read(){
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}

long long t,n,k,s;

int main(){
	t=read();
	while(t--){
		k=read();n=read();
		if(n%ans[k]==0)	cout<<"aya"<<endl;
		else cout<<"baka"<<endl;
	}
	return 0;
}


```

---

## 作者：Galois_Field_1048576 (赞：2)

先说结论：  
输出 `aya` 当且仅当 $(10^k-1)\mid n$。  
证明：
定义 $u_{i,j} = u_{i,j-1} \times 10^i + 1 ; u_{i,1} = 1$。  
所以任意一个 $k$ 阶天才数可以表示为 $u_{k,x}(10^k-1)$，充分性得证（乘法分配律）。  
必要性：因为 $\forall i, 10^{ik}\equiv1\pmod{10^k-1}$，若 $(10^k-1)\nmid n$，则不会有 $k$ 阶天才数（$\equiv 0$）的和与 $n$ 同余，证毕。  
Code：  
```python
'''
Date: 2022-03-20 08:35:28
LastEditors: 1048576
FilePath: \code\luogu\monthly_contest\2022MAR2P\A.py
MajorAlgorithm: 
'''
for TT in range(int(input())):
    k, n = input().split()
    n, k = int(n), int(k)
    if n % (10**k-1) == 0:
        print("aya")
    else:
        print("baka")
```

---

## 作者：苏联小渣 (赞：1)

定义所有 $k$ 阶天才数最小的一个为 $s_k$，如 $s_2=99,s_3=999,s_p=10^p-1$。那么易证所有 $k$ 阶天才数都是 $s_k$ 的倍数。由此，若干个 $k$ 阶天才数的和也一定是 $s_k$ 的倍数，且一个数是若干个 $k$ 阶天才数的和**当且仅当**它是 $s_k$ 的倍数。所以只需要判断 $n$ 是否为 $s_k$ 的倍数即可。

### Code：

```cpp
#include <stdio.h>

long long t, k, n, s;
int main(){
	scanf ("%lld", &t);
	while (t --){
		s = 0;
		scanf ("%lld%lld", &k, &n);
		for (int i=1; i<=k; i++) s = s * 10 + 9;
		if (n % s != 0) printf ("baka\n");
		else printf ("aya\n");
	}
	return 0;
}
```

---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:P8225](https://www.luogu.com.cn/problem/P8225)

* **【解题思路】**

我们设 $a_i=\underbrace{99\cdots9}_{i\text个9}$，也即最小的 $i$ 阶天才数。

我们只需判断 $n$ 是否为 $a_k$ 的倍数即可。

为什么？因为，任何一个 $k$ 阶天才数，都可以表示为 $b\times a_k$ 的形式。证明很简单，可以自己试着举两个例子。也就是说，任何一个 $k$ 阶天才数都可以表示为几个 $a_k$ 的和，那么加上一个 $k$ 阶天才数与加上一堆 $a_k$ 是一样的。

于是，问题变成了：能否把 $n$ 表示为若干个 $a_k$ 之和。

* **【代码实现】**

```cpp
#include <iostream>
#include <array>

using namespace std;

const array<long long,11> seq_9={1,9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999ll};

int main(int argc,char* argv[],char* envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int testcnt,tmp;
	long long num;
	cin>>testcnt;
	while(testcnt--)
	{
		cin>>tmp>>num;
		if(num%seq_9[tmp])
			cout<<"baka";
		else
			cout<<"aya";
		cout<<'\n';
	}
	return 0;
}

```

---

## 作者：diqiuyi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8225)

**分析**

首先，我们可以对 $k$ 阶天才数进行一个分析。显然，这个数的位数为 $k$、$2k$、$3k$、$\cdots$。我们不妨设某个 $k$ 阶天才数 $x$ 的位数为 $nk$。则 $x$ 可以表示为 $\begin{matrix}\underbrace{999\cdots99}\\nk\end{matrix}$。

那么，我们不难发现，$x=\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix} \times 1+\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix} \times 10^k
+\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix} \times 10^{2k}+\cdots+\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix} \times 10^{nk}$。

也就是说，$\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix}\mid x$。转换成题目语言就是每个 $k$ 阶天才数都是最小 $k$ 阶天才数的倍数。

回到题目本身，我们发现，某个 $n$ 满足要求的充要条件是 $\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix}\mid n$。

**证明**

必要：若 $n$ 满足要求，则 $n=$ 一堆 $k$ 阶天才数的和。又 $\because$ 每个 $k$ 阶天才数都是最小 $k$ 阶天才数的倍数，$\therefore\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix}\mid n$。

充分：如果 $\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix}\mid n$，那么只需要用许多个 $\begin{matrix}\underbrace{999\cdots99}\\k\end{matrix}$ 相加就可以得到 $n$。

回到题目本身，既然知道了 $k$，就可以把最小的 $k$ 阶天才数算出来。然后再判断这个数是否整除 $n$ 即可。

**MAIN CODE**
```cpp
while(k--)
    num=(num<<3)+(num<<1)+9;//num 就是最小的 k 阶天才数
puts(n%num?"baka":"aya");//判断是否整除
```

完结撒花 $qwq$。

---

## 作者：Firstly (赞：0)

## **题目思路：**

根据观察不难发现，较大的「$k$ 阶天才数」一定是最小的「$k$ 阶天才数」的倍数，因为较大的「$k$ 阶天才数」的数位可以拆分成最小的「$k$ 阶天才数」的倍数位，而又因其各数位上的数字均为 $9$，所以如果一个数能够拆分成若干个「$k$ 阶天才数」之和，那么这个数一定是最小的「$k$ 阶天才数」的倍数，即这个数定是 $10^k-1$ 的倍数。

那么我们就可以直接判断 $n$ 是否能够整除 $10^k-1$，如果能，那么就代表着这个数可以拆分成若干个「$k$ 阶天才数」的和，否则就代表着不能。

## **Code：**

```cpp
#include<iostream>
#include<cmath>
#define int long long
using namespace std;
int n,k,t;
signed main(){
    cin>>t;
    while(t--){
        cin>>k>>n;
        bool flag=false;
        int val=pow(10,k)-1;
        if(n%val==0)flag=true;
        if(flag)cout<<"aya"<<endl;
        else cout<<"baka"<<endl;
    }return 0;
}
```


---


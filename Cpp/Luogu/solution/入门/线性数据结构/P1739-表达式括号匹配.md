# 表达式括号匹配

## 题目描述

假设一个表达式有英文字母（小写）、运算符（`+`、`-`、`*`、`/`）和左右小（圆）括号构成，以 `@` 作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则输出 `YES`；否则输出 `NO`。表达式长度小于 $255$，左圆括号少于 $20$ 个。


## 说明/提示

表达式长度小于 $255$，左圆括号少于 $20$ 个。


## 样例 #1

### 输入

```
2*(x+y)/(1-x)@
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
(25+x)*(a*(a+b+b)@
```

### 输出

```
NO
```

# 题解

## 作者：fallingdust (赞：223)

我的满分题解（历尽千辛万苦啊！）（解释在题解中）：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>//头文件
using namespace std;//不加这个会出错（告诉一些新人的，大佬勿喷）
int ok=0;//状态的变量（大佬千万别改bool）
char a;//记录字符
int i=0;//之后的特判要用
int main()
{
    for (;;i++)//很无脑对不对，但是很有用
    {
        a=getchar();//读入
        if (i==0&&a==')') {printf ("NO");return 0;}//特判：第一个为‘）’，结束，不对，自己想想看
        if (a=='(') ok++;//是左括号就++
        if (a==')') ok--;//是有括号就--
        if (ok<0) {printf ("NO");return 0;}//特判：多了右括号，结束（多了左没事，但不可以多右，想想看）
        if (a=='@') {if (!ok) printf ("YES");else printf ("NO");return 0;}
//特判无效：比较ok是不是为0（是0表示左右括号都一样多，结束）
    }
}

```

---

## 作者：FCBM71 (赞：136)

#####  先谈谈思路：

 如果左右括号想要匹配，那么左右括号的个数必须相等。

但是如果仅仅满足这个是不行的，举个例子：`)(a+b)(`    
此时第一个右括号出现在了左括号的左边，此时虽然左右括号的数量相等，但是明显不匹配。所以就还要加上第二种判断。

$\ \ \ \ $**每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。**（其实大概就是栈的思想）  
$\ \ \ \ $这样的话就以刚刚举的那个例子为例

```
 找到右括号，但这个变量值为零，不操作。
 找到左括号，变量值+1.
 找到右括号，变量值-1.
 找到左括号，变量值+1.

 最后运算结果为1，不是零，所以这个表达式不匹配。
```


------------


代码如下，仅供参考：

###### in pascal
   
   
```pascal
     var
      s:string;
      l,x,y,i,t:longint;
     begin
      read(s);
      l:=length(s);
      for i:=1 to l do begin
       if s[i]='('then inc(x); //统计左括号个数
       if s[i]=')'then inc(y); //统计右括号个数
      end;
      for i:=1 to l do begin
       if s[i]='('then inc(t);
       if(s[i]=')')and(t>0)then t:=t-1; //判断左右括号顺         序是否匹配，如果出现了右括号出现在左括号的左边的情况         则t的值大于1.
      end;
      if(x=y)and(t=0)then write('YES')
                     else write('NO');//判断并输出
     end.

```
$\ $

###### in cpp（现打的的没交过，CE了不怪我）

```cpp
#include<cstdio>
#include<queue>
using namespace std;

queue<char>a;
int left,right,t;

inline void read(){
	char ch=getchar();
	while(ch!='@')a.push(ch),ch=getchar();
}

int main(){
	read();
	while(!a.empty()){
		if(a.front()=='('){
			++left;
			++t;
		}
		if(a.front()==')'){  
			++right;
			if(t)--t;
		}
		a.pop();
	}
	if(left==right&&t==0)printf("YES");
	 else printf("NO");
	return 0;
}
```
于 2019.12.4 更新了内容

---

## 作者：Coconut_Milk (赞：57)

本蒟蒻也来凑一波

 本题有以下几个重点：

1.左右括号匹配（~~意思是除了括号，其他没什么卵用~~）

2.结尾有一个@做结束符。当然，你也可以cin后用strlen()判断长度。

所以，现在开始讲思路：

既然左右括号要匹配，最简单的肯定是用for循环扫一遍啦！
```
for(int i=0;i<strlen(c);i++){	
		if(c[i]=='(') a++;
		if(c[i]==')') b++;
	}
```
可是，虽然它是一道水题，可是还是有些陷阱的，例如：))a+b((@

所以，我们再加入一个判断：
```
	for(int i=0;i<strlen(c);i++){	
		if(c[i]==')') b++;
		if(b>a){
			cout<<"NO";
			return 0;
		} 
		if(c[i]=='(') a++;
	}
```
这样，代码的主体就完成啦！我们再判断一下左右括号的数量匹不匹配：
```
	if(a!=b) cout<<"NO";
	else 	 cout<<"YES";
```
好了，这样我们就（~~骗到满分~~）过了。
AC代码
```
#include<bits/stdc++.h>
int a,b;
char c[10005];
using namespace std;
int main(){
	cin>>c;
	for(int i=0;i<strlen(c);i++){	
		if(c[i]==')') b++;
		if(b>a){
			cout<<"NO";
			return 0;
		} 
		if(c[i]=='(') a++;
	}
	if(a!=b) cout<<"NO";
	else 	 cout<<"YES";
	return 0;
}
```




---

## 作者：Devil700 (赞：52)

我来一个手写栈的题解

解释见代码
```
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<cstring>
#include<algorithm>
using namespace std;

char n;

struct Stack{
	int top,a[100000];
	void inti(){top=0;}//创建一个空栈 
	void push(int x){a[++top]=x;}//在栈顶插入元素 
	void pop(){if(top) top--;}//删除栈顶元素 
	int empty(){if(top>0) return 0;else return 1;}//判断栈是否为空 
	int quary(){return a[top];}//返回栈顶值 
}z;

int main(){
	z.inti();
	while(cin>>n){//循环输入 
		if(z.empty()){
			if(n==')'){//判断第一个是否为），如果是，就不可能匹配 
				cout<<"NO";
				return 0;
			}
		}
		if(n=='(') z.push(n);//入栈 
		if(n==')') z.pop();//出栈 
	}
	if(z.empty()) cout<<"YES";//判断栈是否为空，是就输出yes，不是输出no 
	else cout<<"NO";
	return 0;
}
```


---

## 作者：老中医233 (赞：38)

****本蒟蒻的第一篇题解****

虽然很多大佬思路的一样

但我还是想发表下自己的看法

~~其实是想试试第一次发题解的感觉~~

								分割线？
————————————————————————————————————————————————

先讲一下思路

**1.判断括号是否匹配，就是判断正反括号数量是否相等，可以用计数变量实现（tot）。**

**2.但即使正反括号数相等，也会出现如“）abcd（”这样会导致误判的情况。**

“）abcd（”在我们看来当然是错的啦~~但是计算机它傻啊~~

****所以：****

**根据第一点，在每次输入时，若输入的是“（”，则tot加1；若输入的是“）”，则tot减1。**

**又根据第二点，为防止第一次输入的是反括号导致误判，需要在每次循环结束前加入tot不等于-1的判断。**

~~本蒟蒻的语文很差胡诌了一大堆希望能有人看懂吧~~

****废话不多说上代码****

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int c,tot=0;//tot初始化 
	while((c=getchar())!='@'){//当输入不为@时继续循环 
		if(c=='(')tot++;
		else if(c==')')tot--;
		if(tot==-1)break;//防止误判 
	}
	if(tot==0)cout<<"YES";//括号匹配要在正反括号数量相等的前提下 
	else cout<<"NO";
	return 0;
}
```

**题解到这里就结束啦**

**本人学术不精若有错误请私信**

**如果有问题也可以私信哒**

~~当然上面两点是在有人看这篇粪题解的前提下~~

---

## 作者：shuntian (赞：29)

#题目还比较简单！

这题不是太难，但有小陷阱。

我最初的思路就是判断左右括号是否相等，于是我写了一个70分代码：



```cpp
    #include<iostream>
    using namespace std;
    int main()  ／／easy
    {
        char c;
        int zuo=0,you=0;     ／／zuo是左括号，you是右括号
        do
        {
            cin>>c;
            if (c=='(') zuo++;      ／／遇到左括号，左➕一
            if (c==')') you++;     ／／遇到右括号，右➕一
        }
        while (c!='@');
        if (zuo==you) cout<<"YES";
        else cout<<"NO";      ／／匹配的括号数量应相等
        return 0;
    }
```
但是这样会有一个bug，出现）（2\*3）（a＊b）（      时，显示的是Yes。
所以每次结束时，应再判断一次，右括号是否比左括号多。

AC代码


```cpp
    #include<iostream>
    using namespace std;
    int main()
    {
        char c;
        int zuo=0,you=0;
        do
        {
            cin>>c;
            if (c=='(') zuo++;
            if (c==')') you++;    ／／前面都一样
            if (you>zuo)        ／／如果右括号比左括号多，这肯定就不匹配，所以......
            {
                cout<<"NO";       ／／输出No
                return 0;           ／／退出程序
            }
        }
        while (c!='@');
        if (zuo==you) cout<<"YES";
        else cout<<"NO";
        return 0;
    }               ／／后面的照常进行
不是特别难吧！
```

---

## 作者：JCZhang (赞：21)

一道模擬題，想成一個棧，就很容易了

講述

你可以把這道題想成一個棧，輸入一個(，就push入棧,輸入一個),就出棧。

挺難理解的我感覺。

假若有这样一个表达式(a+c)\*(d+c)

先输入(,然后把1压入栈，就是上面这个，然后，如果是),就出栈。


到最后，判断栈是否为空


当然，要设一个特判，就是是不是在表达式中就有这种)多于(的情况


具体如下代码：


```cpp
    #include<iostream>
    namespace bing {
        int n;
        int qyb;
    }
    namespace QYB {
        char qyb;
```
}//两个名稱聲明，因爲我太喜歡qyb了，qwq qwq



```cpp
    int main() {
        while (QYB::qyb!='@')
        {
            std::cin >> QYB::qyb;
            //取值
            if (QYB::qyb == '(') bing::qyb++;//入棧
            if (QYB::qyb == ')'&&bing::qyb>0) bing::qyb--;//出棧
              else 
                  if (QYB::qyb == ')') bing::n = 1;//判斷是不是有左括號小於右括號的情況
        }
        if (bing::n ||bing::qyb != 0) std::cout << "NO" << std::endl;//輸出
        else std::cout << "YES" << std::endl;
    }
```
很水的題，看看就明白了

---

## 作者：Jr_Zlw (赞：14)

其实这是我作为一只烂烂的蒟蒻第一次尝试发题解，不足之处敬请见谅。
###### （小声bb）
------------

    我自己认为我写的够通俗了，至少格式没错，条理清晰，代码宽松，不挤在一坨什么的......能一眼看出之间的逻辑关系是吧。虽然说代码的长度有点长，宽度有点短，但看起来不用太费劲（。。。。。。）
    
##     进入正题，先说一下我的解题思路。

###     其实这道题乍一看样例输入好像很复杂一样，其实样例中有一大半都是没用的，真正提取出来有用的就是括号。

####     因为目的是要检查括号是否匹配：

于是，首先想到的就是把括号找出来，算算总数什么的，最后再比较数量。

（因为这道题有一个结束字符‘@’，所以我们可以尝试不开string字符串。）

所以，第一次构思代码应为：

```
	while(s!='@')//s为字符变量（char）
	{
		cin>>s;
		if(s=='(')//记录左括号个数
		{
			tleft++;//tleft即左括号个数
		}
		if(s==')')
		{
			tright++;//同理，右括号个数
		}
	}
```
这样我们就统计出左括号和右括号数目了。

## 但是，
我们能这样简单的比较吗？——想得美！


------------
### 遇到下面这样的情况怎么办？

```
）T（A）T（
```
虽然括号总数相等，但是明显不匹配好吗？



------------
于是乎，我们换一种思维方式：

   ### 因为括号之间要匹配，所以只要有一个 ‘）’就必须要有一个‘（’与之相匹配。

所以，我们略微改改代码，在前面的基础上，新增一个变量记录与‘）’相匹配后剩下的‘（’   
#### ————其实就是记录单身的男主角左括号还有几个 （再次小声bb）

改完以后代码如下
```cpp
//s、tleft、tright跟之前一样
while(s!='@')
{
	cin>>s;
	if(s=='(')
	{
		left++;//记录单身左括号数量
		tleft++;
	}
	if(s==')'&&left<=0)//如果已经没有单身的左括号，直接输出“NO”
	{
		cout<<"NO";
		return 0;
	}
	if(s==')'&&left>0)//如果还有单身的，则让其中一个脱单，单身数量减去1
	{
		tright++;
		left=left-1;;
	}
}
```
    于是，一个已经很完善的代码就写出来了，把头文件命名空间输入输出杂七杂八的一些东西加上去就竣工了。


------------
所以，请看AC代码：（当当当当）
```
#include<iostream>
#include<cstring>  //仅需的两个头文件 
using namespace std;
char s;  //创建字符变量s ，这条语句也可以写在主程序里。 
int main()
{
	int tleft=0,tright=0,left=0;  //计数的变量记得清零。 
	while(s!='@')
	{
		cin>>s;
		if(s=='(')
		{
			left++;
			tleft++;
		}
		if(s==')'&&left<=0)
		{
			cout<<"NO";
			return 0;//其实这里就直接跳出主程序，即结束运行了。 
		}
		if(s==')'&&left>0)
		{
			tright++;
			left--;;
		}
		if(s=='@')
		{
			continue;  //双重保险，不熟练可以用用 
		}
	}  //这段代码不注释了，自己看题解中的解释。 
    if(tleft==tright)  //还是这样判断是否有遗漏的单身狗。 
    {
    	cout<<"YES";
	}
	else  //如果有，当然输出“NO”啦！ 
	{
		cout<<"NO";
	}
	return 0;  //蒟蒻必备return 0；打代码不如大牛们，当然要注意一下形象啦！ 
} 
```


------------
最后简单评讲几句：

1、占用内存不多，3个整型变量1个字符变量。

2、希望大家不要抄题解哦，看懂思路最重要，其实自己写代码比抄题解改变量名还快。

3、使用其他语言的同学也可以按照这个思路试一下喔！








---

## 作者：Ryo_Yamada (赞：13)

这题有些坑，
①左括号的个数和右括号的个数要相等。
②右括号不能先出现！！！（第一次不容易想到）
上代码：
```cpp
#include <bits/stdc++.h>//总头
using namespace std;

int main(){
	int cnt1=0,cnt2=0;//左，右括号的计数
	string s;//一个算式，也可以开char数组
	getline(cin,s);//读入整行
	for(int i=0; i<s.size(); i++){
		if(s[i] == '(')cnt1++;
		else if(s[i] == ')')cnt2++;//计数
		if(cnt2 > cnt1){
			cout << "NO";
			return 0;
		}//如果右比左先出现，输出NO，结束程序
	}
	if(cnt1 == cnt2)cout << "YES";//如果相等，输出YES
	else cout << "NO";//不相等，输出NO
	return 0;//完美结束qwq
}
```
本蒟蒻的第一篇题解！！！（我知道很菜）

---

## 作者：skt_t1 (赞：13)

很简单的一道入门的关于栈思想的题目

    
        
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
using namespace std;
char c;//用来存储输入字符；
int s=0;//用来模拟栈，做一个虚拟栈；
bool ok;//设一个变量用来防止S小于0时做的空判断；
int main()
{
    for(;;)
    {
        cin>>c;//将字符输入；
        if(c=='@')break;//根据题目要求，如果输入为@停止；
        if(c=='(')s++;//如果c是（就把“入栈”；
        else
        if(c==')'&&s>0)s--;//如果c是）并且s没有越界，就将栈顶元素弹出；
        else if(c==')'){ok=1;break;}//如果s小于0越界，则跳出循环，停止；
    }
    if(s==0&&ok==0)cout<<"YES";else cout<<"NO";//如果s为空栈，并且没有越界，就输出YES,不然输出NO；
    return 0;
}

```

---

## 作者：张文思 (赞：7)

这道题的方法有很多，一种办法是建立一个栈，每次碰到左括号就入栈，碰到右括号就出栈。注意出栈之前要判空，如果某一次读到了右括号但栈为空，那么说明多了右括号，一定不对，就直接输出“NO”然后return 0就可以了。等到整个程序结束之后再次对栈判空，若栈为空则没有问题，若栈非空则多了左括号。话不多说，贴代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    char kuohao[1000000];
    cin>>kuohao;
    stack<char> bra;
    int l=strlen(kuohao);
    for(int i=0;i<l;i++)
    {
        if(kuohao[i]=='(')//左括号入栈
        {
            bra.push(kuohao[i]);
        }
        else if(kuohao[i]==')'&&bra.empty()==0)//一定要判空，否则会RE
        {
            bra.pop();
        }
        else if(bra.empty()&&kuohao[i]==')')//这里也是，必须要判空。
        {
            cout<<"NO";
            return 0;
        }
    }
    if(bra.empty())//若栈为空则满足条件
    {
        cout<<"YES";
    }
    else
    {
        cout<<"NO";
    }
    return 0;
}
```
另外还有一个方法，用到的知识点比较简单，直接分别统计左右括号的个数就行了。如果个数相同，显然是匹配的。如果个数不同，那么说明一定有问题。这个方法用到的知识点比较简单，适合初学者。这个方法比较简单粗暴。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int left=0;
    int right=0;
    char bra[100000];
    cin>>bra;
    int l=strlen(bra);
    for(int i=0;i<l;i++)
    {
        if(bra[i]=='(')
        {
            left++;
        }
        else if(bra[i]==')')
        {
            right++;
        }
    }
    if(left==right)
    {
        cout<<"YES";
    }
    else
    {
        cout<<"NO";
    }
    return 0;
}
```
这个方法是方法二的改进版。方法二需要两个计数变量来分别统计左右括号的个数，而这个方法只需要一个int变量就可以解决一切问题。当遇到左括号的时候++，遇到右括号的时候--，如果最后计数变量为0则匹配，不是0则不匹配。这个方法其实和方法一的出入栈是非常相像的，不过这个更省空间。
继续贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int haha=0;
    char bra[100000];
    cin>>bra;
    int l=strlen(bra);
    for(int i=0;i<l;i++)
    {
        if(bra[i]=='(')
        {
            haha++;
        }
        else if(bra[i]==')')
        {
            haha--;
        }
    }
    if(haha)
    {
        cout<<"NO";
    }
    else
    {
        cout<<"YES";
    }
    return 0;
}
希望管理员能通过（至少我写了这么半天）
```

---

## 作者：Dummerchen (赞：6)

发现没人用stl

本蒟蒻就贴个栈的代码

```cpp
#include<cstdio>
#include<iostream>
#include<stack>//库函数 
using namespace std;
char a;
bool flag;
int main()
{
    stack <char> sum;
    while(1)
    {
        cin>>a;
        if(a=='@')//若为@则弹出 
            break;
        if(a=='(')//进栈 
            sum.push(a);
        if(a==')')//出栈 
        {
            if(!sum.empty())//若此时栈以空则不符合题意否则出栈 
                sum.pop();
            else
                flag=1;
        }
    }
    if(flag||!sum.empty())//若最终栈没空或在判断期间发现不符合题意则NO 
        printf("NO\n");
    else
        printf("YES\n");
    return 0;
}
```

---

## 作者：Conical (赞：5)

这一题很水，但很多大神写的题解都有误，

如2\*）x+y（，不能直接统计左右括号个数。

我是用STL库中的stack做的。

```cpp
#include<iostream>
#include<stack>
using namespace std;
stack<int> s;
char c[255];
int main()
{
    cin>>c;//读入
    int i;
    for(i=0;c[i]!='@';i++)
    {
        if(c[i]=='(')s.push(c[i]);//将左括号入栈
        if(c[i]==')')//处理右括号
        {
            if(!s.empty())s.pop();//如果当前右括号与上一个左括号匹配
            else
            {
                cout<<"NO\n";
                return 0;
            }//不匹配判错
        }
    }
    if(!s.empty())cout<<"NO\n";
    else cout<<"YES\n";
    return 0;
}

```

---

## 作者：封禁用户 (赞：4)

# 其实这题，字符串再长也能做……
------------
## 本题可分三个部分来讲解：了解STL库（栈）、读入的优化、处理问题。
### 了解STL库（栈）：
STL库是个好东西，里面有许多函数值得我们去使用。

今天，本蒟蒻为大家带来站的用法。

栈就像一个桶。它后进先出。就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/gyngtroj.png)

以下是栈的基本命令：

sta.push();//入栈

sta.empty()//判断战是否为空，是返回真，反之返回假

sta.pop();//出栈

sta.top//求栈顶元素

### 读入的优化：
本蒟蒻的代码中有两个优化：

一是对cin的优化（其实加了也没什么用）——ios::sync_with_stdio(false);

二是把字符一个一个地读，使其性能更优（见下）。

### 处理问题：
总算讲到大家喜爱的代码了吧，本蒟蒻在此奉上：

```cpp
#include<bits/stdc++.h>
#include<stack>
using namespace std;
stack<char>sta;
char ch;
int main()
{
    ios::sync_with_stdio(false);//优化其一 
	while (true)
    {
    	cin>>ch;//优化其二 
		if (ch=='@')//判断结束 
		  break;
		if (ch=='(')
    	  sta.push(ch);//入栈 
    	if (ch==')')
    	{
    		if (sta.empty())//判断是否为空 
    		{
    			cout<<"NO"<<endl;//是则输出NO 
    			return 0;//程序结束 
			}
			sta.pop();//出栈 
		}
	}
	if (sta.empty())//判断是否为空(千万别忘了) 
	  cout<<"YES"<<endl;else
	  cout<<"NO"<<endl;
	return 0;
}
```

# **其实，CODE这件事不在于AC，而在于理解。**

---

## 作者：QzStark (赞：3)

###**我就轻轻的路过，应该很简单的算法**

**\_我把它叫做>汪峰算法\_**

```cpp
#include<stdio.h>
#include<string.h>//字符串函数库
int main()
{
    char a[260],i=0,t=0;
    scanf("%s",a);//用%s一口气把一列字符串读完
    int len=strlen(a);//测试字符串长度
    while(1)
    {
        if(a[i]==40) t++;//“阿紫可骂”表 40就是（左括弧；如果搜索到左括弧，t+1
        if(a[i]==41) t--;//“阿紫可骂”表 41就是）右括弧；如果搜索到右括弧，t-1
        if(t==-1) { printf("NO");break; }//如果t=-1，也就是说t=0+(-1),也就是右括弧先出来，说意义上是错的；或者t=0+1-1-1，“（））”也是错的。break退出循环
        i++;//扫描下一个
        if(t==0&&i==len) { printf("YES");break;}//如果t=0，也就是说左右括号刚刚好，i=len也就是搜完了a数组，说明这串字符串没有错。break退出循环
    }
    return 0;//“汪峰算法”，正解其实应该用栈；
}//来自阿尔及利亚国立大学耶路撒冷研究班的留学生卡莱基·拉登·穆罕默德二世
```

---

## 作者：wangye714906 (赞：3)

首先，看到这个题，一般会立刻想到，这个表达式的左括号右括号数量是否一致，~~我开始也是这么想的~~
但是，这样的做法交上去，只能得50分~~（亲身试验）~~如）（）（这个测试点是不会过的
我~~好不容易~~想出一个改进的方法（栈）：
如果是左括号，就++，是右括号就--。
如果得数为负数，说明右括号多于左括号，就没有必要继续了，跳出吧
如果得数为零，说明匹配，否则就是不匹配。
上代码

------------这是蒟蒻的分割线
```
#include<iostream>
#include<cstring>
char a[260];
using namespace std;
int main()
{
    int i=0,cnt=0;
    cin>>a;
    while(a[i]!='@')
    {
        if(a[i]!='('&&a[i]!=')')
        {
            i++;
            continue;
        }
        if(a[i]=='(')cnt++;
        else cnt--;
        if(cnt<0)
        {
            cout<<"NO";
            return 0;
        }
        i++;
    }
    if(cnt==0)cout<<"YES";
    else cout<<"NO";
    return 0;
}
欢迎大佬提意见
```


---

## 作者：亿年已过 (赞：2)

### 蒟蒻第四篇题解！

这题从题目上看起来是比较简单的

可是，有个
# 巨坑
很多人都会这样做
```
#include<bits/stdc++.h>    
using namespace std;
int zuo,you;	//统计左括号和右括号的变量
string s;     //字符串      
int main()
{
cin>>s;
for(int i=0;i<s.size();i++)
{
    if(s[i]=='(')zuo++;
    if(s[i]==')')you++;
    if(s[i]=='@')break;

}
if(zuo!=you)	//如果左括号和右括号的数量不同，则是不匹配，打印“NO”
printf("NO");
if(zuo==you)	//如果左括号和右括号的数量相同，则是匹配，打印“YES”
printf("YES");

    return 0;           
}
```
**这样是70分的**
## 坑就在下面

要AC，就要加上这一段
```
if(you==zuo){
	printf("NO");
	return 0;
}
```
解释  假设`s=)(`：

运行之后，zuo=1，you=1

那么就会打印“YES”

## 可是，
事实真的是这样吗？**不是！**

)( 显然，这并不是一个匹配的括号，()这样才是
```
if(s[i]==')')
{
	if(you==zuo){//如果前面的左括号和右括号数量已经相等，而又来一个右括号，就变成了右括号在前面)( 这种情况了
		printf("NO");	//所以直接打印“NO”
		return 0;	//直接结束
   }
	you++;//否则右括号++；
}
```
AC代码：
```
#include<bits/stdc++.h>   //万能头文件 
using namespace std;
int zuo,you;	//统计左括号和右括号的变量 
string s;     //字符串        
int main()
{
cin>>s;
for(int i=0;i<s.size();i++)
{
    if(s[i]=='(')zuo++;
    if(s[i]==')')
{
	if(you==zuo){//如果前面的左括号和右括号数量已经相等，而又来一个右括号，就变成了右括号在前面)( 这种情况了
		printf("NO");	//所以直接打印“NO”
		return 0;	//直接结束
   }
	you++;//否则右括号++；
}
    if(s[i]=='@')break;		//按照题意 以“@”作为表达式的结束符

}
if(zuo!=you)	//如果左括号和右括号的数量不同，则是不匹配，打印“NO”
printf("NO");
if(zuo==you)	//如果左括号和右括号的数量相同，则是匹配，打印“YES”
printf("YES");


    return 0;           
}
```


---

## 作者：Pethly_Cat (赞：2)

# 此题根本不用判断‘@’！
# 此题根本不用判断‘@’！
# 此题根本不用判断‘@’！
当时用了两种方法来做这道题
###### 一、模拟
我们用一个sum1来统计左括号的数量，用sum2来统计右括号的数量，循环时如果sum2>sum1，就直接输出no。最后再判断一次sum1等不等于sum2即可。
AC代码：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string a;
    int sum1=0,sum2=0;
    cin>>a;
    for(int i=0;i<a.size();i++){//搜素字符串
    	if(a[i]=='(') sum1++;//左括号加1
    	if(a[i]==')') sum2++;//右括号加1
    	if(sum2>sum1) break;//不成立的情况
	}
	if(sum1==sum2) cout<<"YES";//判断
	else cout<<"NO";
    return 0;
}
```
###### 二、栈
设定一个字符类型的栈，查找时，如果为左括号，将其压入栈，如果为右括号，判断是否有和它相应的左括号，如果没有，输出no。最后判断栈是否为空。
AC代码：
```
#include<bits/stdc++.h>
using namespace std;
string a;
char b[256];//栈空间
int top;//栈指针
int main()
{
	cin>>a;
	for(int i=0;i<a.size();i++){
		if(a[i]=='(') b[++top]='(';//如果为左括号，压入栈
		if(a[i]==')'){//右括号
			if(top==0){cout<<"NO";return 0;}//没有与其相应的左括号
			else top--;//抵消掉
		}
	}
	if(top==0) cout<<"YES";//判断栈是否为空
	else cout<<"NO";
	return 0;
}
```
# 珍爱生命，远离抄袭

---

## 作者：Talanton_Cerydra (赞：2)

很简单的一道题（如果这句话伤害到了你，请谅解）

主要存在的问题是会把“）（”判成对

其实这也是错的

所以需要加些判断条件

不说了，上代码：
```c
#include <bits/stdc++.h>
int main()
{
    char a[256];
    int m=0,n=0;
    for(int i=1;i<=255;i++)
    {
        scanf("%c",&a[i]);
        if(a[i]=='@') //终止读取符号
        {
        	break;
		}
        if(a[i]==')')
        {
            n++;
            if(n>m)
            {
                printf("NO");
                /*
                这样出现‘）（’的情况，读到第一个括弧就会出现n>m的情况
                会直接输出NO结束程序
                */
                return 0;
            }
        }
        if(a[i]=='(')
        {
            m++;
        }
    }
    if(m==n)//最后判断是否相等
    {
        printf("YES");
    }
    else
    {
        printf("NO");
    }
    return 0;//程序完结
}
```
最后预祝大家尽早全部AC！

---

## 作者：WatchmanIce (赞：2)

楼下dalao们用的都是数学大法啊，然后我就想出了一种暴力模拟大法。 
暴力模拟？？？是的。
为了证明可以暴力，我就就题目数据来说吧！
```
#include<bits/stdc++.h>
using namespace std;
string st;
int findl(int x){//找左端点
	for(int i=0;i<=st.size()-1;i++){
		if(st[i]=='(')return i;
	}
	return -1;
}
int findr(int x){//找右端点
	for(int i=1;i<=st.size();i++){
		if(st[i]==')')return i;
	}
	return -1;
} 
void changel(int x){//改左端点
	st[x]='l';
}
void changer(int x){//改右端点
	st[x]='r';
} 
int main(){
    cin>>st;
    
    for(int i=0;i<st.size();i++){
    	if(findl(i)!=-1&&findr(i)!=-1){
    		if(findl(i)<findr(i)){
    			changel(findl(i));
    			changer(findr(i));
			}
		}
	}
	for(int i=1;i<=st.size();i++){
		if(st[i]=='('||st[i]==')'){
			cout<<"NO"<<endl;
			return 0;
		}
	}
	cout<<"YES"<<endl;
    return 0;
}
```
为了证明这种方法的正确性，我来拿数据说吧。

### 表达式长度小于255，左圆括号少于20个。

那么，每一次查找就算是左端点在最右边，右端点在最左边，也不会超时。

如果说要要优化的话，我也只能加一个~~毫无用处的~~ 最最简单的优化了。

假如说在没有不符合题目要求的情况下，那么到最后一个满足条件的右括号前面，都是可以省略的！！！
那么就是说，在前面都满足题目要求的情况下，出现```)(```的情况，就可以立刻判断它是一个不符合题目
要求的字符串！ 

也就是说，在我的代码中间，当```findr()>findl()```,就是右端点的下标大于左端点时，可以直接
判断：它不符合要求！！！ 
然后，我们又可以构造一个更小的 ~~更没用~~的剪枝~~其实没啥用~~，就是当```st[0]==')'||st[st.size()-1]=='('```时，可以直接输出“NO”。

然后再看一眼题面，可以发现每次``` findl()和findr()```时都会重复寻找，所以我们
可以记下上次的查找位置，然后就可以省下很多的时间。~~（其实一毫秒都没有省下来）~~
附上优化后的代码： 
```
 #include<bits/stdc++.h>
using namespace std;
string st;
int findl(int x,int last){//找左端点
	for(int i=last;i<=st.size()-1;i++){
		if(st[i]=='(')return i;
	}
	return -1;
}
int findr(int x,int last){//找右端点
	for(int i=last;i<=st.size();i++){
		if(st[i]==')')return i;
	}
	return -1;
} 
void changel(int x){//改左端点
	st[x]='l';
}
void changer(int x){//改右端点
	st[x]='r';
} 
int main(){
    cin>>st;
    
    if(st[0]==')'||st[st.size()-1]=='('){
    	cout<<"NO"<<endl;
    	return 0;
	}
	int ll=0,lr=0;
    for(int i=0;i<st.size()/2+1;i++){
    	if(findl(i,ll)!=-1&&findr(i,lr)!=-1){
    		if(findl(i,ll)<findr(i,lr)){
    			ll=findl(i,ll);
    			lr=findr(i,lr);
    			changel(findl(i,ll));
    			changer(findr(i,lr));
			}else{
				cout<<"NO"<<endl;
				return 0;
			}
		}
	}
	for(int i=1;i<=st.size();i++){
		if(st[i]=='('||st[i]==')'){
			cout<<"NO"<<endl;
			return 0;
		}
	}
	cout<<"YES"<<endl;
    return 0;
}
 ```
谢谢大家！！！

---

## 作者：沟里郭嘉 (赞：2)

人生中第一篇题解（被这个鬼题卡了一上午，mmp）

思路嘛...~~不想说~~（被打），~~其实代码里有啦（小声bb）~~


还是思路的问题，这个思路确确实实没有栈的方便，~~但是很容易理解（吧）。
~~

这个题数据不是很友好（对我这种蒟蒻来说），而且题解大多都是没有更新数据之前的？所以不自量力地写了一个题解，码风奇丑，才疏学浅，鄙陋之至，还请多多包涵。

```cpp
//luogu-P1739
//10:51:16
//星期天 
//2019.4.14

#include <cstdio>   //它快，它好，它是人间的四月...(被打死)
#include <cstring>

const int MAXN= 1121; //重要的人的生日，略略略 

------------正文

int main()
{
	char m[MAXN]= {'\0'};        //初始化数组(最好是初始化一遍，严谨总没坏处) 
	
	bool lefts[MAXN]= { false }, rights[MAXN]= { false }; //记录下来哪个是左括号哪个是右括号
	int left= 0, right= 0; //第一个出现的左括号，第一个出现的右括号 
	
	int count= 0; //用来判断左右括号是否数目相同 
	int n= 0;
	
	bool hasLeft= false, hasRight= false; //记录是否有括号 万一所有都是数字是可以的哦				
	scanf("%s", m+1);
	n= strlen(m+1); //把字符串储存 个人习惯从1开始循环，所以嘛...... 
	
	for (int i= 1; i <= n; ++i)
	{
		if (m[i] == '(')
		{
			lefts[i]= true;
			count++;
		}
		else if (m[i] == ')')
		{
			rights[i]= true;
			count--; //比较最后的count是否为0,为0就是数目相等 
		}
	}
	
	if (count != 0)
	{
		printf("N0\n");
		return 0;
	}
	
	bool flag= true;
	
	while (flag) //不断循环从外到内 
	{
		hasLeft= hasRight= false;
		
		for (int i= 1; i <= n; ++i)
		{
			if (lefts[i])
			{
				left= i;
				hasLeft= true;
				lefts[i]= false; //我判断完你了，你对我没用处了，滚(ノ｀Д)ノ 
				break;
			}
		}
		
		for (int i= 1; i <= n; ++i)
		{
			if(rights[i])
			{
				right= i;
				hasRight= true; //第一个出现的左括号，第一个出现的右括号 
				rights[i]= false;
				break;
			}
		}
		
		if (hasLeft && hasRight)
		{
			if (left > right) //如果最早出现的左括号的位置大于右括号,它就是错的 
			{
				printf("No\n");
				return 0;
			}
		}
		else
		{
			flag= false; //跳出循环的条件 
		}
	}
	
	printf("YE5\n");
	
	return 0;
}


```

特别鸣谢机房大佬的捉虫


---

## 作者：zschhh (赞：2)

这道题用到栈的意思就好了，是‘（’进栈，是‘）’出栈。

当然只取其意即可，没必要真的把栈模拟出来。



```cpp
#include <iostream>
using namespace std;
int top; //栈顶
int main(){
    char t;cin>>t;
    while(t != '@'){
        if(t == '(') top++;
        if(t == ')') top--;
        if(top<0){ // 若中途栈中没有'('，却还要出栈，说明有问题
        cout<<"NO";
            return 0;
        }
        cin>>t;
    }
    if(top==0) cout<<"YES"; // 最后若栈空则没问题
    else cout<<"NO";
    return 0;
}

```

---

## 作者：Johnson_sky (赞：2)

简单的模拟，也不用像楼下那样用栈来做，完全可以开一个计数器，来记录左右括号是否匹配，代码如下



```cpp
#include <iostream>
#include <cstring>
using namespace std;
int num;
char n;
int main()
{
    while(cin>>n && n!='@')//输入需要注意，需要时刻判断是否为@
    {
        if(n=='(')
        {
            num++;
        }
        if(n==')')
        {
            num--;
        }
    }
    if(num!=0)//绝对值加不加无所谓
    {
        cout<<"NO"<<endl; 
    }
    else
    {
        cout<<"YES"<<endl;
    }
    return 0;
}
```

---

## 作者：Enigmatic (赞：2)

这题其实我觉得连入门难度都不到

时间O（n），空间O（1）

实际上这题就是模仿一下栈的操作

遇到左括号top++，右括号top--

但是要判一下空，就是右括号的个数超过了左括号的个数

我觉得直接在输入中退出不太好

就用f做了一个标示量

```cpp
#include <bits/stdc++.h>
using namespace std;
char a,top,f;
int main()
{
    while(a!='@')

    {
        a=getchar();
        if(a=='(') top++;
        if(a==')'&&top>0) top--;
        else if(a==')')f=1;
    }
    if(f||top!=0) printf("NO\n");
    else printf("YES\n");
}
```
拒绝抄袭，从我做起！


---

## 作者：在下弟中弟 (赞：1)

## 超级大佬崇拜者又双叒叕来发题解了
这就是一道水水的题目！

非常简单的思路：字符数组(即char)存储。

定义一个l=0;

有一个左括号就加一,有一个右括号就减一

最后只要这个l是0就可以了

```
#include<bits/stdc++.h>//万能头 
using namespace std;
int main()
{
	char a[256];//数组.因为题目有说过不多于255个字符 
	int l=0;//括号个数 
	//-------------开始检测------------- 
	for(int i=1;;i++)//其实i=1可以不用设置 
	{
		cin>>a[i];
		if(a[i]=='@')break;
		else
		{
			if(a[i]=='(')l++;//左括号 
			if(a[i]==')')//右括号 
			{
  				l--;
			}
		}
	}
	//----------------输出------------- 
	if(l==0)cout<<"YES"; 
	else cout<<"NO";
	//----------------结束------------- 
	return 0;
}
```
but······

别急着复制粘贴！那是错误代码！

hhhhhhhhhhhhhhhhh

如果碰到“）（1+13479）（”这样的问题，你认为这还是正确的吗？

在程序中，这是合法的（手动滑稽）

。。。。。。

所以说，特判就可以啦！

上代码
```
#include<bits/stdc++.h>//万能头 
using namespace std;
int main()
{
	char a[256];//数组.因为题目有说过不多于255个字符 
	int l=0;//括号个数 
	//-------------开始检测------------- 
	for(int i=1;;i++)//其实i=1可以不用设置 
	{
		cin>>a[i];
		if(a[i]=='@')break;
		else
		{
			if(a[i]=='(')l++;//左括号 
			if(a[i]==')')//右括号 
			{
				if(l==0)//如果出现")(12+1)("这种情况, 就特判 
				{
					cout<<"NO";
					return 0;
				}
				else l--;
				//其实判断括号数量是不是小于零就可以了,但是这种方法还是简单粗暴一点 
			}
		}
	}
	//----------------输出------------- 
	if(l==0)cout<<"YES"; 
	else cout<<"NO";
	//----------------结束------------- 
	return 0;
}
```
建议自己想.

这道题真心不难

---

## 作者：PigDogRabbit_zzZ (赞：1)

~~这道题我做了两个小时最后发现这道题这么简单（蒟蒻QAQ）~~

最基本的问题，输出，用do while或者while来做

~~（应该没有不会的吧）~~

然后[敲重点][敲重点]


------------


int一个计数器s

如果是“（”就

	s++;

如果是“）”就

	s--;

其实这道题目咱只要想明白两个问题:

The First：多了后面半个括号

如果后面半个括号在前半个括号后面，那么就肯定错了

所以上面这句话用代码-->>
```cpp
	if(s<0)
    {
    	cout<<"NO";
        return 0;
    {
```
只要小于零，直接输出no

The Second：多了前面半个括号

这个时候s是大于零的

最后只有当s=0时，大括号小括号全部匹配后，才可以输出

所以只要在结尾特判一下

~~（我一开始就是这点没想到折腾了半天[doge][doge]）~~

所以...

直接上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int s=0;
	char k;
	do
	{
		cin>>k;
		if(k=='(')
		{
			s++;
		}	
		if(k==')')
		{
			s--;
		}
		if(s<0)
		{
			cout<<"NO";
			return 0;
		}
	}while(k!='@');
	if(s==0)
	{
		cout<<"yes";
	}
	else
	{
		cout<<"no";
	}
	return 0;
}

```

这道题其实还有栈的做法

个人比较喜欢用计数器

~~（其实代码很短我真是个啰嗦老大爷）~~



---

## 作者：Islauso (赞：1)

总体来说这道题还是非常简单的，学过栈的应该都知道(~~第一道就是这个~~)

# 思路如下
凡是左括号都入栈，遇到右括号就出栈，如果中途栈空但还是要出栈就代表右括号多了，如果最后栈不为空就代表左括号多了，~~总之不行就对了~~，如果栈最后正好空就是可以

--------------------------------------------------我是分割线------------------------------------------------------
## 代码如下：
```cpp
#include<cstdio>
using namespace std;
int top;
char b;
int main()
{
	scanf("%c",&b);//单个输入
	while(b!='@')
	{
		if(b=='(')//遇到左括号就入栈
			top++;
		if(b==')')//遇到右括号就出栈
			if(top==0)//判断右括号是否多了
			{
				printf("NO");//既然右括号多了，就永远会多一个，管他后面有几个左括号
				return 0;
			}
			else
				top--;//还有左括号未配对，就出栈一个
		scanf("%c",&b);
	}
	if(top==0)//判断栈是否为空
		printf("YES");
	else
		printf("NO");
	return 0;//（华丽退出）
}
```
总体来说还是非常简单的，只要想通了这道题是非常简单的（~~一个老梗而已~~）

本人蒟蒻，欢迎各位dalao在评论区指点一二，如果有哪里做的不好，麻烦请指出来，我会继续改进的，大家一起进步

---

## 作者：Social_Zhao (赞：1)

# 这题根本不用想太多。
##### 思路：
##### 先定义一个变量z，如果有（就加一，
##### 有）就减一
##### 如果括号匹配，z终值为0.
##### 70分到手。
##### 那么还有30分呢？
##### 通过~~下载样例~~，我发现，可能一来就是）！而这样确实是不匹配的。
##### 而如果出现这样的情况，z值会短暂为负
##### 所以及时输出NO，退出就行了
AC代码：

```cpp
#include<iostream>
#include<string>
using namespace std;
string s;//读入
int z=0;
int main()
{
	cin>>s;//没有空格、回车，可用cin读入
	for(int i=0;i<s.size();i++)//一个一个看
	{
		if(s[i]=='(') z++;//遇(加一
		else if(s[i]==')') z--;//遇）减一
		if(z<0) {//特殊情况
			cout<<"NO"<<endl;
			return 0;//后面的不用看了
		}
	}
	if(z==0) cout<<"YES"<<endl;//匹配
	else cout<<"NO"<<endl;//不匹配
}
```

---

## 作者：ZzMK (赞：1)

**这个题，其实也挺简单的~~我做了30分钟~~**

------------
本质上来说就是一道判断括号的题目，那么最重要的就是是否合法。

------------
我相信其实一共两个问题，一种十分好处理，就是是否一一配对。打个比方就是()那么就会引出第二个问题，如果是)( 那怎么办呢。其实很简单只需要当它出现立马跳出输出NO就行了


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	char c[256];
	int z=0,y=0,len,sum=0; //SUM用来统计左右配对
	for(int i=1;i<=256;i++) //统计长度。
	{
		scanf("%c",&c[i]);
		if(c[i]=='@')
		{
			len=i-1;
			break;
		}
	}
	for(int i=1;i<=len;++i)
	{
		if(c[i]=='(')sum++;
		else if(c[i]==')')sum--;
		if(sum<0)break;  //立马跳出。
	}
	if(sum<0)printf("NO");
	else printf("YES");
	return 0;
}
```


---

## 作者：反比例函数 (赞：1)

貌似大家没有直接用一个$\#include<stack>$的，所以就写一篇吧。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<stack>//这就是栈（stack）的STL头文件
using namespace std;
stack<int> s;//创建一个int形式的栈s
int main()//愉快地开始
{
	string st;int i;
	cin>>st;
	int n=st.size();
	for(i=0;i<n;i++)
	  if(st[i]=='(')s.push(st[i]);//如果读到的字符是左括号那就入栈
	  else if(st[i]==')')//如果读到了右括号
	  		{if(s.empty()) {cout<<"NO"<<endl;return 0;}
      //首先要判断栈是否空，如果空了说明右括号比左括号多，显然不配对
	        else s.pop();}
	if(s.empty()) cout<<"YES"<<endl;else cout<<"NO"<<endl;
    //再次判断栈是否空，不空说明左括号比右括号多，也是不配对的
	return 0;//结束了
}

```

---

## 作者：Robert (赞：1)

我的思路很简单，不用栈也不用把字符存下来，具体操作请见代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int leftt=0;char u;
int main()
{
    scanf("%c",&u);
    while(u!='@')
    {
        if(u=='(')leftt++;//遇到左括号，左括号数量加一 
        if(u==')')
        {
            if(leftt)leftt--;//遇到右括号，左括号数量减一 
            else {printf("NO\n");return 0;}//如果此时没有左括号了，那么必然不匹配 
        }
        scanf("%c",&u);
    }
    if(leftt)printf("NO\n");//如果还有没匹配的左括号，那就不匹配 
    else printf("YES\n");
    return 0;
}
```

---

## 作者：览遍千秋 (赞：1)

这道题目的出题人的数据可真是~~把我坑坏了~~**水**啊，第一次花了个工夫写假栈，后来发现只要判断左右括号数量是否相等就行了。

###愉快的贴代码时刻：

判断数量是否相等

```cpp
#include<bits/stdc++.h>
using namespace std;
int lo,LEFT,Right;//left和right居然是关键字！ 
char a[300];
int main()
{
    scanf("%s",a);//友情提示:c/c++选手千万别用getline()和gets() 
    lo=strlen(a);//记录长度
    /*
    有一些人习惯将下面的for()写成
    for(int i=0;i<strlen(a);i++)
    不建议在条件中这样写，不然每循环一次就要求一遍长度，容易TLE 
    */ 
    for(int i=0;i<lo;i++)
    {
        if(a[i]=='(')//是左半括就left++ 
            LEFT++;
        if(a[i]==')')//同理 
            Right++;
    }
    if(LEFT==Right)//判断数量是否相等 
        printf("YES\n");
    else
        printf("NO\n");
    return 0;
}
```
假栈：

```cpp
#include<bits/stdc++.h>
using namespace std;
int lo,top; 
char a[300];
int main()
{
    scanf("%s",a);//友情提示:c/c++选手千万别用getline()和gets() 
    lo=strlen(a);//记录长度
    /*
    有一些人习惯将下面的for()写成
    for(int i=0;i<strlen(a);i++)
    不建议在条件中这样写，不然每循环一次就要求一遍长度，容易TLE 
    */ 
    for(int i=0;i<lo;i++)
    {
        if(a[i]=='(')//是左半括就入假栈 
            top++; 
        if(a[i]==')')//是右半括就出假栈 
        {
            if(top==0)//判断栈空 
            {
                printf("NO\n");
                return 0;
            }
            else
                top--;//出栈 
        }
    }
    if(top!=0)//判断栈空 
        printf("NO");
    return 0;
}
```

---

## 作者：707001933K (赞：1)

伪栈——一个模拟

令（为+1，）为-1

累计前缀和，任意一个时刻的前缀和小于0表示)比(多，不合法。

结束时前缀和还大于0表示(还有剩余，不合法。


上代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
char tr[300];
int flag=0;
bool fail=false;;
int main(){
    scanf("%s",tr);
    int len=strlen(tr);
    for (int i=0;i<len;i++){
        if (tr[i]=='(')flag++;
            else if (tr[i]==')')flag--;
        if (flag<0){
            fail=true;
            break;
        }
    }
    if (flag!=0)fail=true;
    if (fail)printf("NO");
        else printf("YES");
    return 0;
}
```

---

## 作者：Ackoter (赞：1)

我的考虑了一切的超短代码

有什么问题跟我说

```cpp
#include<iostream>
using namespace std;
string st; 
int a;//a=1时，前面有出现过"("  a=2时，前面没出现过"("
int main()
{
    cin>>st;
    for(int i=0;i<st.size();i++)
    {
        if(a==0&&st[i]==')'||a==1&&st[i]=='(')//前面没有出现过"("时出现了")",或是连续出现了两个")"就输出"NO"
      {
        cout<<"NO";
        return 0;
    }
        if(a==1&&st[i]==')') a=0; 
        if(st[i]=='(') a=1; //来回转换a的状态
    }
    cout<<"YES";//否则"YES"
    return 0;
}
```

---

## 作者：water_mi (赞：1)

其实根本不用栈，只用一个所谓的栈顶指针就可以了（貌似和下面的几位大佬达成了共识）

```cpp
#include<cstdio>
int main(){
    int top = 0;//指针指向栈顶，栈为空 
    char ch = getchar();//读入第一个字符 
    while(ch != '@'){
        if(ch == '(') top++;//左括号入栈 
        else if(ch == ')') 
            if(top) top--;//左括号出栈 
            else{puts("NO"); return 0;}//空栈处理 
        ch = getchar();//继续读入 
    }
    puts(top?"NO":"YES");//三目运算符，缩短代码量 
    return 0;
}
```

---

## 作者：Randyhoads (赞：1)

###**\_这道题用数组模拟栈就可以了，栈只需要存储‘（’，就可以了，在栈不为空时，必有‘（’进行配对\_**




```cpp
#include<bits/stdc++.h>
//#define whr_tcj
using namespace std;
int main()
{
    #ifdef whr_tcj//如果定义了whr_tcj,则执行下面的两行语句
        freopen("ab.in","r",stdin);
        freopen("ab.out","w",stdout);
    #endif 
       char a[260];                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
       gets(a);//读入
       int topa=0,;//TOP指向栈顶，此时栈为空
       int i=0;
        while(a[i]!='@')//如果结束
        {
            if(topa>=strlen(a)) break;//如果已经到了上限，退出
            if(a[i]=='(')
            {
                topa++;//将’‘（’“进栈
            }
            if(a[i]==')')//如果是“）”，显然匹配时前一个只能是‘（’，将‘（’出栈，栈内将只有多余的括号（或没有）
            {
            if(topa<=0)//判断是不是为空，为空则不匹配
             {
               printf("NO");
               return 0;
             }
            else
                topa--;
            }
            i++;
        }
        if(topa==0) printf("YES");//没有多余括号
        else printf("NO");
        return 0;
}
```

---

## 作者：feng_chengjie (赞：1)

巧用栈，有‘（’就进栈，有‘）’就出栈，最后判断栈是否为空；













```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <stack> 
using namespace std;
char c;
stack<char> q;
int main()
{
    while(cin>>c)
    {
        if(c=='@')
            break;
        if(c=='(')
        {
            q.push('(');
            continue;
        }
        else if(c==')')
        {
            if(q.empty())
            {
                cout<<"NO";
                return 0;
            }
            q.pop();
        }
    }
    if(!q.empty())
        cout<<"NO";
    else
        cout<<"YES";
    return 0;
}

```

---

## 作者：kgrox (赞：1)

都是手写大犇，弱弱水一波STL

代码：

```cpp
#include<iostream>
#include<stack>
using namespace std;
stack<char>st;
int main()
{
    char a;cin>>a;//读入
    while(a!='@')
    {
        if(a=='(')st.push('(');//左括号就扔到栈里
        else if(a==')'&&st.empty()){cout<<"NO";return 0;}//如果遇到右括号时栈已经空了就输出NO结束（也避免第一个是“)”的情况）
        else if(a==')')st.pop();//遇到右括号扔一个左括号
        cin>>a;//读下一个
    }
    if(st.empty()){cout<<"YES";return 0;}//如果表达式结束栈空了就可以
    cout<<"NO";//否则不行
}
```

---

## 作者：白炎拉力 (赞：1)

//这道题只需要看左右括号的个数是否一致就可以了,不过前提条件是第一个括号必须是左括号

    
```cpp
#include<iostream>
using namespace std;
char ch;int i,flag;
int main()
{    do 
    {    
        cin>>ch;
        if(ch=='(')
        {
            ++i;
flag=1;//没错,flag=1说明第一个括号是左括号
        }    
        else if(ch==')')
        {
            if(flag==0)    break;//如果第一个括号是右括号,那么就可以退出循环了(肯定不匹配啊~)
            --i;
        }
    }
    while(ch!='@');
    if(i==0&&flag==1)    cout<<"YES";
    else    cout<<"NO";
    return 0; 
}
```

---

## 作者：AdzearDisjudge (赞：1)

讲道理这题用计数器加加减减很方便但为了算法多样化我还是写了个bool数组法……

其实不管什么方法，关键思想就是栈，只不过通过栈的不同表现方式，消耗了不同的空间罢了

核心思路：

1.读入判断是否为'@'，是则跳出循环

2.左括号bool数组本位记为true,开始迭代器移至下一位

3.右括号bool数组开始迭代器移至上一位,然后新的位置记为false

4.如果都没有左括号了还有右括号就输出NO

5.跳出循环后直接判断bool数组第一位是否为true,是则至少有1个多余的右括号，输出NO；否则输出YES

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a;
int b;
bool c[22];
int main()
{
    cin>>a;
    b=1;
    memset(c,false,sizeof(c));
    while(a!='@')
    {
        if(a=='(')
        {
            c[b]=true;
            ++b;
        } 
        if(a==')')
        {
            if(b<=1)
            {
                cout<<"NO";
                return 0;
            }
            --b;
            c[b]=false;
        }
        cin>>a;
    }
    if(c[1])
    cout<<"NO";
    else
    cout<<"YES";
    return 0;
}
```
ps:%%%红太阳thx！！！


---

## 作者：YoChian (赞：1)

这题不难，用一个计数器，输入一个判断一次然后增减计数器，但也可以用栈来写，像这样：


```cpp
#include <iostream>
#include <cstdlib>
using namespace std;
#define num 101
int main()
{
    char c;
    bool n[num],i;
    int head=0,tail=0; //定义头尾
    for(i=false;i==false;)
    {
        cin>>c; //一个一个读入
        if(c=='(') //判断
        {
            tail++;
            n[tail]=true;
        }
        else
        {
            if(c==')')
            {
                n[tail]=false;
                tail--;
            }
            else
            {
                if(c=='@')
                {
                    i=true;
                }
            }
        }
        c='\0';
    }
    if(head==tail) //最后检验是否正确
    cout<<"YES"<<endl;
    else
    cout<<"NO"<<endl;
}
```

---

## 作者：Godning (赞：1)

手写栈，练习一下。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

class Stack{
public:
    char *data;
    int length;
    Stack(int n){
        data = new char[n];
        length = 0;
    }
    ~Stack(){
        delete data;
    }
    void push(char chr){
        for(int i=length-1;i>0;i--){
            data[i+1] = data[i];
        }
        data[0] = chr;
        length++;
    }
    void pop(){
        if(isempty()) return;
        for(int i=0;i<length;i++){
            data[i] = data[i+1];
        }
        length--;
    }
    char top(){
        if(length != 0)
            return data[0];
    }
    bool isempty(){
        if(length == 0){
            return true;
        }else{
            return false;
        }
    }

};

int main(){
    Stack *mystack = new Stack(300);
    char tmp;
    while(1){
        cin>>tmp;
        if(tmp == '@'){
            break;
        }
        if(tmp == '('){
            mystack->push('(');
        }
        if(tmp == ')'){
            if(mystack->isempty()){
                cout<<"NO"<<endl;
                return 0;
            }
            mystack->pop();
        }
    }
    if(mystack->isempty()){
        cout<<"YES"<<endl;
    }else{
        cout<<"NO"<<endl;
    }
    return 0;
}
```
欢迎指错~


---

## 作者：xueliancheng (赞：1)

使用栈(stack)完成本题较为简单。对读入的字符串从左到右进行处理，遇到左括号就压入栈中，遇到右括号则判断当前栈是否为空，如果当前栈为空，则说明多出了一个右括号，若为不为空，则弹出栈顶的左括号。


完整程序：

###




```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<stack>
using namespace std;
char ch[256];
stack<char>epstk;
bool IsLeft(char c)
{
    return c=='(';
}
bool IsRight(char c)
{
    return c==')';
}
bool IsMathBrackets()
{
    for(int i=1;i<=strlen(ch+1);i++)
    {
        if(IsLeft(ch[i]))
        {
            epstk.push(ch[i]);
        }
        if(IsRight(ch[i]))
        {
            if(epstk.empty())
            {
                return false;
            }
            epstk.pop();
        }
    }
    return epstk.empty();
}
int main()
{
    scanf("%s",ch+1);      //从第一位开始读入字符数组。
    if(IsMathBrackets())
    {
        puts("YES");
    }
    else
    {
        puts("NO");
    } 
    return 0;
}

```

---

## 作者：ROOToj (赞：1)

非常简单的模拟题，只需要依次读入每个字符，记录左括号，如果遇到右括号则减去一个左括号，如果左括号个数<0立刻输出”NO“并退出！！！最后如果左括号个数为0则恰好匹配。


附上AC源代码：


​#include<cstdio>






















```cpp
#include<cstring>
using namespace std;
#define MAXN 1000010
char s[MAXN];
int len,i,left=0;
int main()
{
    scanf("%s",s);
    len=strlen(s);
    for(i=0;i
        if(s[i]=='(')left++;
        else if(s[i]==')')
        {
            if(!left){printf("NO\n");return 0;}
            left--;
        }
    if(!left)printf("YES\n");
    else printf("NO\n");
    return 0;
}
-------------------------------------------END-------------------------------------------
```

---

## 作者：ZYR_ (赞：1)

题目挺简单，首先要知道有前括号就一定有后括号，接下来就是遍历了

上代码{pascal}：

program khpp(input,output);


```cpp
 var
         a:string;
         i:integer;
         t:integer;
 begin
         t:=0;   //初始化
         readln(a);
         for i:=1 to length(a) do   //遍历字符串
         begin
                 if a[i]='(' then inc(t);   //有前括号
                 if a[i]=')' then dec(t);  //就一定有后括号
         end;
         if t=0 then writeln('YES')
                  else writeln('NO');   //检查括号数量是否相等
 end.
有前括号就一定有后括号，知道这个题目就简单了。
```

---

## 作者：萝卜 (赞：1)

情况如 a+(b+)（c=sd） 等实际上不符合运算规则，但在这道题里面是可以的。

```delphi

program kuohao;
var n:longint;
    c:char;
begin
      repeat read(c);
             if c='(' then inc(n);//一个左括号
             if c=')' then dec(n);//一个右括号抵消一个左括号
             if n<0 then break;//多余的右括号
      until c='@';
      if n<>0 then writeln('NO') else writeln('YES');
end.

```（pascal）


---

## 作者：Komorebi_shine (赞：1)

同学们请注意：（重要！！！！！！！！！！！！！！！！！！！！！）

原来我用如下：

```cpp
var
 s,i:integer;
 c:char;
begin
 read(c);
 s:=0;
 while c<>'@' do
  begin
   if c='(' then inc(s);
   if c=')' then dec(s);
   read(c);
  end;
 if s<>0 then writeln('NO') else writeln('YES');
end.
```
结果一测只有70，左看右看都没毛病。结果我下了一个数据（附数据：)(a+1)\*(a+2)(@NO），就知道问题出在哪儿了。
加一句话：

```cpp
var
 s,i:integer;
 c:char;
begin
 read(c);
 s:=0;
 while c<>'@' do
  begin
   if c='(' then inc(s);
   if c=')' then dec(s);
   if c<0 then begin writeln('NO');exit;end;//加行，时时判断是否匹配。
   read(c);
  end;
 if s<>0 then writeln('NO') else writeln('YES');
end.
```

---

## 作者：King_Parliament (赞：0)

心血来潮水红题，居然WA了？

当我AC后点开题解，发现大家做的都好麻烦。

居然没有用STL直接写模拟的。

于是有了这篇题解——

## 首先，我们确定一下输出NO的情况：

> 如果结束时左括号数量多于右括号（也就是最后左括号数量-右括号数量>0）

> 如果在任意时候右括号数量多于左括号（也就是左括号-右括号<0）

## 那么，其他时候则输出YES

综上所述，可以开始快乐写代码了。

# 解法一，直接获取全部字符，逐个处理

由于题目中给出数据只有一行，并且没有空格，那么我们可以使用STL中的string来读取整行字符，遍历一遍即可。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin>>s;
    int l=s.size(),L=0;//获取字符串长度
    for(int i=0;i<l;i++){
        if(s[i]=='(')L++;//统计左括号数目
        if(s[i]==')')L--;//如果遇到右括号则和一个左括号相抵消
        if(L<0){cout<<"NO";return 0;}//判断每一步是否存在右括号数目多于左括号的情况
        }
    if(L>0)cout<<"NO";//特判左括号没有被完全抵消的情况
    else cout<<"YES";//正常情况（括号被完全匹配）
    return 0;
}
```
# 解法二，边输入边处理。
这种方法讲究的是效率，可以加快速度和压缩代码，原理与解法一基本一致，上代码解释：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    char c;
    int L=0;//定义存储左括号的变量
    while(1){
        c=getchar();//读取字符
        if(c=='(')L++;//统计左括号数目
        if(c==')')L--;//如果遇到右括号则和一个左括号相抵消
        if(c=='@')break;
        if(L<0){cout<<"NO";return 0;}//判断每一步是否存在右括号数目多于左括号的情况
    
    }
    if(L>0)cout<<"NO";//特判左括号没有被完全抵消的情况
    else cout<<"YES";//正常情况（括号被完全匹配）
    return 0;
}
```
请勿滥用STL！！！！


---

## 作者：HohleFeuerwerke (赞：0)

#### [题目传送](https://www.luogu.org/problem/P1739)

## 前置知识：Stl 栈 模拟

#### Solution 1: stl栈

当然你也可以选择手工，但是为了叙述方便，本篇题解采用stl

思路很简单，就是输入时候一边读一遍判：

1、遇到了$'@'$ 结束 跳出

2、遇到了$'('$ 放入栈内

3、遇到了$')'$ 弹出或结束（具体见标程）

```cpp
#include<bits/stdc++.h>//万能头
#pragma GCC optimize(2)//手工o2
using namespace std;
stack <char> s;//stl
char cur;//读入
void work()
{
	cin>>cur;//先读一个，以免循环判空
	while(true)
	{
		if(cur=='@') break;//跳出
		if(cur=='(') s.push('(');//读到左括号，放入
		if(cur==')') //读到右括号
		{
			if(s.empty()==true)//如果是空的代表右括号比左括号多
			{
				cout<<"NO"<<endl;return;
			}
			else if(s.top()=='(')//否则弹出
				s.pop();
		}
		cin>>cur;//没问题就再读一个
	}
    //接下来的内容都是那些上面判过没问题的读到@跳出来了
	if(s.empty()==true)//如果是空的，说明刚好匹配
	{
		cout<<"YES"<<endl;return;
	}
	else//否则左括号比右括号多
	{
		cout<<"NO"<<endl;return;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cout.tie(0);
	work();//运行
	return 0;
}
```

#### Solution 2: 模拟
看了题解大多是模拟，讲下其中的内涵思路：

读入，如果第一个是左括号，后面就一定有一个右括号跟着。
如果右括号数量在某一时刻大于左括号数量，那么就不匹配

给你们一份代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char cur;
int main()
{
	ios::sync_with_stdio(false);
    cout.tie(0);
    cin>>cur;//一样先读
	int curleft=0,curright=0;//现在读过了几个左几个右
	while(true&&(cur!='@'))//@就退出
    {
		if(cur=='(') curleft++;//左个数++
		if(cur==')') curright++;//右个数++
		if(curright>curleft){//如果某一时刻右>左，就错误了
			cout<<"NO"<<endl;return 0;
		}
		cin>>cur;
    }
	if(curleft>curright)cout<<"NO"<<endl;//如果结束后左的比右的多，就错误了
	else cout<<"YES"<<endl;//其他都对
	return 0;
}
```

欢迎Hack



---

## 作者：Kaedeuim (赞：0)

这道题就是括号匹配而已...

首先要注意一下：

70分代码：

```cpp
#include<iostream>
using namespace std;
char a[1001];
int main()
{
	int x=0;
	char d;
	while(cin>>d&&d!='@')
	{
		if(d=='(')x++;
		if(d==')')x--;
		}
	if(x!=0)cout<<"NO";
	if(x==0)cout<<"YES";
	return 0;
}
```
好，那么来解读一下70分的代码。

1.首先，请看第10.第11行，直接写了是左括号就加加，右括号减减。

推翻代码样例:
输入：)(

错误输出：YES

80分代码：

```cpp
#include<iostream>
using namespace std;
char a[1001];
int main()
{
	int x=0;
	char d;
	int p=0;
	while(cin>>d&&d!='@')
	{
		p++;
		if(p==1&&d==')'){cout<<"NO";return 0;}
		if(d=='(')x++;
		if(d==')')x--;
		}
	if(x!=0)cout<<"NO";
	if(x==0)cout<<"YES";
	return 0;
}

```
那么，80分的代码又是哪里错了呢？

好，继续解析。

1.看一下80分代码的第10.第11行，发现了什么？只要是第一个字符是“）”，就一定是“NO”。

推翻代码样例：

输入：()())(

错误输出：YES

# 下面贴出AC代码：

```cpp
#include<iostream>
using namespace std;
char a[1001];
int main()
{
	int x=0;
	char d;
	int p=0;
	while(cin>>d&&d!='@')//如果不是“@”就继续
	{
		p++;
		if(p==1&&d==')'){cout<<"NO";return 0;}//判断：在第一个的是不是右括号
		if(d=='(')x++;
		if(d==')'&&x==0){cout<<"NO";return 0;}//判断：在已经匹配的情况下不让它匹配的第一个括号是不是右括号，性质与上相同
		if(d==')'&&x!=0)x--;
		}
	if(x!=0)cout<<"NO";//如果不匹配
	if(x==0)cout<<"YES";//如果匹配
    	while(1);//防抄袭利器
	return 0;//养成好习惯
}

```

这道题完成后建议完成[这道题](http://oj.noi.cn/oj/#main/show/1113)

## 感谢采纳~


---

## 作者：Sinwind (赞：0)

# 1.分析

我们只需要提取出表达式中的括号存入字符串$brackets$，然后进行判断。

1. 若$brackets[0]$是$")"$，前面没有与之匹配的$"("$，肯定不匹配，输出$"NO"$，退出程序；

2. 若$brackets$的长度$len$为奇数$(len\%2==1)$，因为有一个多余的括号，肯定不匹配，输出$"NO"$，退出程序；

3. 若非$1,2$的情况，则遍历$brackets$，重复以下操作：先找到$"("$，再找到后面的$")"$，然后将两者清除$(brackets[i]='\space',brclets[j]='\space')$；

4. 最后再遍历一遍$brackets$，若仍有括号，则是不匹配的，输出$"NO"$，退出程序；否则，匹配成功，输出$"YES"$。

# 2.代码

```cpp
#include <iostream>
#include <string>

using namespace std;

string brackets;	//提取出的括号
char ch;            //输入的字符

int main(void)
{
	//提取出括号
 	do
 	{
 		cin >> ch;
 		
 		if(ch == '(' || ch == ')')
		{
			brackets += ch;
		}
	}
	while(ch != '@');

	int len = brackets.length();
	//bracket第0位为')'或者长度为奇数，说明匹配不成功
	if(brackets[0] == ')' || len % 2 == 1)
	{
		cout << "NO";
		return 0;
	}

	//清除匹配的括号
	for(int i = 0; i < len; i++)
	{
		if(brackets[i] == '(')
		{
			for(int j = i + 1; j < len; j++)
			{
				if(brackets[j] == ')')
				{
					brackets[i] = ' ';
					brackets[j] = ' ';
					break;
				}
			}
		}
	}
	
	//若仍有括号残留，则匹配不成功
	for(int i = 0; i < len; i++)
	{
		if(brackets[i] == '(' || brackets[i] == ')')
		{
			cout << "NO";
			return 0;
		}
	}
	cout << "YES";
	
	return 0;
}
```


---

## 作者：kevin1022 (赞：0)

## 给一个PASCAL题解

思路：左右括号要匹配满足的条件

1.左括号数等于右括号数

2.中途已读入的左括号数永远大于已读入的右括号数

15行极限AC
```
var//定义变量
  ch:char;//当前读入的字符
  x:longint;//x代表当前左括号数与右括号数的差值
begin//主程序
  repeat
    read(ch);//读入字符
    if ch='('then inc(x);//读到左括号，差值+1
    if ch=')'then dec(x);//读到右括号，差值-1
    if x<0 then//如果x<0
    //即中途已读入的左括号数小于已读入的右括号数
      break;
      //那么退出，因为此时x≠0，退出后会输出NO（压代码）
  until eoln;//读到回车符就结束
  if x=0 then//当x代表当前左括号数与右括号数的差值=0，即左括号数=右括号数时
    writeln('YES')else//表达式符合规范
    writeln('NO');//表达式不符合规范
end.
```


---

## 作者：退役蒟蒻 (赞：0)

# **这道题很简单，只要判断括号的个数问题就可以了，但是有一点右括号不能大于左括号的个数。首先先展示７０分的代码**
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int main(){
    int sum1=0,sum2=0;
    char s;
    while(cin>>s&&s!='@'){
        if(s=='(')sum1++;
        if(s==')')sum2++;
    }
    if(sum1==sum2)cout<<"YES";
    else cout<<"NO";
    return 0;
}
```
# 因为没有特判，所以把错的搞成对的了，于是我加了一个特判语句
```cpp
if(sum1<sum2){cout<<"NO";return 0;}
```
然后就ＡＣ了，ＡＣ代码如下
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int main(){
    int sum1=0,sum2=0;
    char s;
    while(cin>>s&&s!='@'){
        if(s=='(')sum1++;
        if(s==')')sum2++;
        if(sum1<sum2){cout<<"NO";return 0;}//特别注意
    }
    if(sum1==sum2)cout<<"YES";
    else cout<<"NO";
    return 0;
}
```
//此题题解为本人的第一个题解，望通过

---

## 作者：zzhz (赞：0)

这题比较水，先看一下题目   
题目意思是看括号匹不匹配    
本蒟蒻决定用栈解决   
话不多说，直接上代码    
代码如下

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//定义空间
char a[10001],top=0;
int main(){//主函数
    gets(a);//输入，这里为了防止空格用gets
    int l=strlen(a);//a的长度
    for(int i=0;i<l;i++){
        if(a[i]=='(')top++;//进栈
        if(a[i]==')')top--;//出栈
        if(top<0){
            cout<<"NO";//不匹配，输出NO
            return 0;
        }
    }
    if(top==0)cout<<"YES";//匹配，输出YES
    else cout<<"NO";//不匹配，输出NO
    return 0;//结束
}
```   
本蒟蒻心地善良   
但是，   
非紧急情况不要用此功能！     




---

## 作者：没有输入 (赞：0)

# 解题报告

这道题可以用多种方法解，这里我介绍两种：栈和累加器（~~暴力~~）。

## 栈

这道题的正解应该是栈，大家可以参考我[P1449的题解](https://dingkeyi.blog.luogu.org/solution-p1449)。栈的主要特点就是**先进后出**，这与我们在做运算时匹配括号的规则无异。我们可以利用这一特点，在读入左括号时将其入栈，读入右括号时将其和栈顶匹配，若匹配则继续，若不匹配，即栈为空，则直接输出“NO”并结束程序。
```cpp
for(int i=0;a[i]!='@';i++)
{
	if(a[i]=='(') stk.push('(');
	if(a[i]==')')
	{
		if(stk.empty())
		{
			printf("NO\n");
			return 0;
		}
		stk.pop();
	}
}
```
如果正常结束循环，则再判断栈是否为空，若为空，则说明所有括号均匹配。
```cpp
if(stk.empty()) printf("YES\n");
else printf("NO\n");
```
我在这里~~偷了个懒~~，直接调用了STL库中的栈，如果手打在复杂度上可以更胜一筹。

### 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
stack <char> stk;
char a[1000];
int main()
{
	gets(a);
	for(int i=0;a[i]!='@';i++)
	{
		if(a[i]=='(') stk.push('(');
		if(a[i]==')')
		{
			if(stk.empty())
			{
				printf("NO\n");
				return 0;
			}
			stk.pop();
		}
	}
	if(stk.empty()) printf("YES\n");
	else printf("NO\n");
	return 0;
}
```
### 拓展 · 栈

栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

## 累加器（暴力）

看完栈的思路，有的同学可能就有别的想法了：这种方法不用栈也可以实现啊！没错，~~搞暴力~~累加器就可以很好地实现这一功能。

### 具体思路

直接用两个累加器x和y记录左右括号的数量。
```cpp
if(a[i]=='(') x++;
if(a[i]==')') y++;
```
但也不至于简单到这种地步~~否则还要栈有何用~~。如果出现“)(”的情况怎么办？所以，在循环时，每次都要判断左括号的数量是否小于右括号以避免类似于“)(”的情况发生。
```cpp
for(int i=0;a[i]!='@';i++)
{
    if(a[i]=='(') x++;
    if(a[i]==')') y++;
    if(x<y)
    {
        printf("NO\n");
        return 0;
    }
}
```
最后再判断左右括号数量是否相等。
```cpp
if(x==y) printf("YES\n");
else printf("NO\n");
```
### 总结

不是不能暴力，但是至少也要考虑多种情况，不要把题目想得过于简单导致失分。

### 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1000];
int x,y;
int main()
{
    gets(a);
    for(int i=0;a[i]!='@';i++)
    {
        if(a[i]=='(') x++;
        if(a[i]==')') y++;
        if(x<y)
        {
            printf("NO\n");
            return 0;
        }
    }
    if(x==y) printf("YES\n");
    else printf("NO\n");
    return 0;
}
```
我是[没有输入](https://www.luogu.org/space/show?uid=154344)，我们下次再见！

---

## 作者：FxorG (赞：0)

###### 题目也不算太难，但又有点考验
估计很多人都像我一样，首先写了个70分的代码
就是判断左右括号个数是否相等

但！)(a+b)(这样时就会出错
而且，我又拓展出了：(a+b))((a+b)
这样也会出错

所以，我们可以得出

在循环时，如果(左括号个数==右括号个数)

我们要再判断，如果下一位是')'，那么肯定是错误的

所以，我们要作2个特判

1.第一位是否是')'

2.就是在循环中，(左括号个数==右括号个数)时，如果下一位是')'，那么也是错误的

这样，在原来70分的代码上略微修改就可以了

```cpp
#include<iostream>
#include<string>
using namespace std;
int len,a,b;
string str;
int main(){
    cin>>str;
    len=str.size();
    if(str[0]==')'){
        cout<<"NO";
        return 0;
    }
    for(int i=0;i<len;i++){
      int ii=i+1;
      if(str[i]=='(') a++;
      else if(str[i]==')') b++;
      if(a==b&&str[ii]==')'){
          cout<<"NO";
          return 0;
      }
}
    if(a==b) cout<<"YES";
    else cout<<"NO";
    return 0;
}
```




---

## 作者：lijiaqi (赞：0)

一开始拿到这题，突然发现是一个字符串搞定的事(没看见有一个输入@停止)，于是就用了字符串(话说有用字符串做的吗)

题解如下

~~我才不会告诉你代码有问题(防抄袭)~~

```cpp
#include<bits/stdc++.h>//万能头不解释
using namespace std;
int main()
{
	int bol=0;
	string s;//用字符串awa
	cin>>s;
	if(s[0]==')') //如果第一个是左括号即错误
	{
		cout<<"NO";
		return 0;
	}
	for(int i=0;i<s,size();i++)//机智的不怎么耗内存的循环
	{
		if(s[i]='(') bol++;
		if(s[i]=')') bol--;
		if(bol<0)//如果右括号少于左括号，即错误(右括号与左括号颠倒)
		{
			cout<<"NO";
			return 0;
		}
	}
	if(!bol) cout<<"YES";//最后的判断
	else cout<<"NO";
	return 0;
}
```

---

## 作者：wu_qing (赞：0)

8.6

有点水
我都能把自己Hack掉

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack>

#define N_MAX (300 + 10)

using namespace std;

char a[N_MAX];
int cnt;
int res;
stack<char> s;

int main() {
    scanf("%s", a);
    int len = strlen(a);
    s.push('#');
    for (int i = 0; i < len; i++) {
        if (a[i] == '(') {
            s.push(a[i]);
            cnt++;
        }
        if (a[i] == ')') {
            s.pop();
            res++;
        }
    }
    if (s.top() == '#') {
        puts("YES");
    }
    else {
        puts("NO");
    }
    
    return 0;
}
```

------------------------------------

9.14
这么写是错误的
input
)())
之后RE

虽然里面有一个'#'
但如果第一个符号为)
'#'就会被弹出
因为没有判断栈是否为空
所以...RE

---

## 作者：feicx (赞：0)

这道题目不完全要用到栈，只需要利用栈的top来处理。

若遇到左括号（，则是top++

而遇到右括号），则是top- -

因此本题的思路大概出来了

但是这样对于下面这种非法的匹配方式上面的方法也可以过：

```
(sd))sdd(dds
```

仔细分析，调试，在遇到第二个右括号）时，top会小于0，这是突破这种非法情况的关键，因此，我们在top小于0时直接输出NO即可

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
int top=0;

int main(){
	getline(cin,s);
	for(int i=0;i<s.length();i++){
		if(s[i]=='(')
			top++;
		if(s[i]==')')
			top--;
		if(top<0)
			break;
	}
	printf("%s\n",top?"NO":"YES");
	return 0;
}

```

---

## 作者：Ape_epA (赞：0)

简单的模拟。。。。。。

```cpp
var t,i:longint;
    s:string;
begin 
  readln(s);      //读入
  for i:=1 to length(s) do        //一个一个地做下来
    begin
    if s[i]='(' then
      inc(t);                 //t表示当前的左括号数量
    if s[i]=')' then
      dec(t);                    //有一个右括号就减去一个左括号
    if t<0 then             //要是左括号少于0个，则说明了出现了'())'的情况，可以直接halt。这是优化
      begin
      writeln('NO');
      halt;
      end;
    end;
  if t=0 then
    writeln('YES')
  else writeln('NO');             //判断输出
end.
```

---


# [蓝桥杯 2023 国 Python B] 弹珠堆放

## 题目描述

小蓝有 $20230610$ 颗磁力弹珠，他对金字塔形状尤其感兴趣，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/vc5azeim.png)

- 高度为 $1$ 的金字塔需要 $1$ 颗弹珠；
- 高度为 $2$ 的金字塔需要 $4$ 颗弹珠；
- 高度为 $3$ 的金字塔需要 $10$ 颗弹珠；
- 高度为 $4$ 的金字塔需要 $20$ 颗弹珠。

小蓝想要知道用他手里的弹珠可以摆出的最高的金字塔的高度是多少？

# 题解

## 作者：dg114514 (赞：2)

这是一篇二分题解。\
发现建造一个高度为 $n$ 层的金字塔需要 $1+(1+2)+\dots+(1+2+\dots+n)$ 颗弹珠，考虑 $O(1)$ 算出该式。（如果 $O(n)$ 计算，时间可能过长）\
注意到 $1+2+\dots+n=\frac{n(n+1)}{2}$，可以把它看成 $C^2_{n+1}$。然后原式变为 $\sum\limits^n_{i=1} C^2_{n+1}$，根据组合数的性质，可以把它变为 $C^3_{n+2}$，即 $\frac{n(n+1)(n+2)}{6}$，注意到这个式子一定单调上升，所以二分即可。如果是 C++ 选手，需要注意乘法爆 `long long`。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
	int l=0,r=cbrt(20230610)*3/*f(sqrt3(20230610))*3 一定不超过 20230610*/,mid,ans;
	while(l<r){
		mid=l+r>>1;
		if(mid*(mid+1)*(mid+2)/6>20230610)
			r=mid;
		else l=mid+1,ans=mid;
	}
	cout<<ans;
}
```

---

## 作者：FJ_EYoungOneC (赞：1)

观察上图，我们设从上到下为第 $1, 2, 3, \dots$ 层：

- 第一层：$1$ 个。
- 第二层：$1 + 2$ 个。
- 第三层：$1 + 2 + 3$ 个。
- $\dots$

我们发现第 $k$ 层的个数应该是 $1 + 2 + 3 + \dots + k$。

设 $k, v, s$ 分别表示当前层数、当前层的个数、总个数。

那么当 $s \leq 20230610$ 时执行：

```python
k += 1
v += k
s += v
```
当跳出循环时，表示 $s > 20230610$，即第 $k$ 层无法凑成，故输出 $k - 1$。

- Python

```python
import sys
sys.setrecursionlimit(1000000)
input = lambda:sys.stdin.readline().strip()

k = 1
v = 1
s = 1

while s <= 20230610:
    k += 1
    v += k
    s += v

print(k - 1)
```

运行结果：

```
494
```

---

## 作者：niuniudundun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12206)

![](https://cdn.luogu.com.cn/upload/image_hosting/vc5azeim.png)

观察上面的图，发现第 $i$ 层有 $1+2+\cdots+(i-1)+i$ 个弹珠，利用公式可以得出 $\dfrac{i(i+1)}{2}$。那么对于一个 $n$ 层塔有 $\displaystyle \sum_{i=1}^{n}\dfrac{i(i+1)}{2}$ 个弹珠。

知道这些我们可以计算了，题目转换为求出最大的解使得 $20230610\le\displaystyle \sum_{i=1}^{n}\dfrac{i(i+1)}{2}$，不过我不会，所以暴力枚举。设 $n=20230610,m=0,ans=0$，每次让 $m=m+\dfrac{ans(ams+1)}{2}$，如果 $m>n$ 说明不够建 $ans$ 层，输出 $ans-1$。接着让 $ans$ 加一。实测答案为 `494`。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n=20230610,ans=0,m=0;
int main(){
	while(1){
		m+=ans*(ans+1)/2;
		if(m>n){
			cout<<ans-1<<endl;
			return 0;
		}
		ans++;
	}
	return 0;
}
/*
*/
```

---

## 作者：TheTrash (赞：1)

### 思路

通过观察发现，金字塔第 $i$ 层是一个正三角形，需要 $\frac{i^2+i}{2}$ 个弹珠。那么我们可以累加层数，直到需要的弹珠数大于 $20230610$ 为止。

### 代码

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int s=20230610,t=1,sum;
int main(){
	while(sum+(1+t)*t/2<s) sum+=(1+t)*t/2,t++;
	cout<<t-1;//最后答案会比实际的高度大1，所以要减去1
}
```

---

## 作者：banglee (赞：0)

### P12206 [蓝桥杯 2023 国 Python B] 弹珠堆放 题解
[题目传送门](https://www.luogu.com.cn/problem/P12206)

## 思路
先找规律。

可以看出，每一层的弹珠数是三角形数，即第 $k$ 层的弹珠数为 $T_k=\frac{k(k+1)}{2}$。整个高度为 $h$ 的金字塔的弹珠总数是三角形数的和，即 $S(h)=\sum^h_{k=1} T_k = \sum^h_{k=1} \frac{k(k+1)}{2}$。

化简后得到：
$$S(h)=\frac{h(h+1)(h+2)}{6}$$

题目要求找到最大的整数 $h$ 使得 $S(h) \le 20230610$，所以二分。

## Code
```python
k = 20230610
l = 1
r = 2 * 10**6
ans = 0
while l <= r:
    mid = (l + r) // 2
    t = mid * (mid + 1) * (mid + 2) // 6
    if t <= k:
        ans = mid
        l = mid + 1
    else:
        r = mid - 1
print(ans)
```

答案为 $494$。

---

## 作者：LINYUHENG2 (赞：0)

![](https://cdn.luogu.com.cn/upload/image_hosting/vc5azeim.png)

观察上图，我们发现第 $n$ 层的弹珠数量为 ${\textstyle \sum_{i=1}^{n}}i$。根据数学老师教的等差数列求和公式，第 $n$ 层的弹珠数量可以表示为 $\frac{n(n+1)}{2}$。

那么，第 $n$ 个金字塔的弹珠数量可以表示为 ${\textstyle \sum_{i=1}^{n}}\frac{i(i+1)}{2}$，将这个式子化简一下。
$$
\begin{aligned}
&\sum_{i=1}^{n}\frac{i(i+1)}{2}\\
=&\frac{1}{2} \sum_{i=1}^{n}i(i+1)\\
=&\frac{1}{2} \sum_{i=1}^{n}(i^2+i)\\
=&\frac{1}{2}(\sum_{i=1}^{n}i^2 + \sum_{i=1}^{n}i) \\
=&\frac{1}{2}(\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2})\\
=&\frac{1}{2}(\frac{n(n+1)(2n+1)}{6}+\frac{3n(n+1)}{6})\\
=&\frac{1}{2}(\frac{2n^3+3n^2+n}{6}+\frac{3n^2+3n}{6})\\
=&\frac{1}{2} \times \frac{2n^3+6n^2+4n}{6} \\
=&\frac{n^3+3n^2+2n}{6}
\end{aligned}
$$
所以我们可以列出不等式 $\frac{n^3+3n^2+2n}{6}\le 20230610$，可以将该不等式解出，但笔者使用的是枚举。
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    for(int i=1;;i++){
        if(i*i*i+3*i*i+2*i>20230610*6){ //一个防止精度问题的好方法
            printf("%d",i-1);
            return 0;
        }
    }
    return 0;
}
```
```python
i=1
while True:
    if(i*i*i+3*i*i+2*i>20250610*6):
        print(i)
        break
    else:
        i++
```

---

## 作者：Kratos_Charger (赞：0)

## P12206 [蓝桥杯 2023 国 Python B] 弹珠堆放 题解

### 题目大意

~~题目写得很清楚，自己回去看~~

### 思路

通过观察可得公式：

$$ S_n = S_{n-1} + T_n $$

其中 $T_n$ 为第 $n$ 个三角形数：

$$ T_n = \frac{n(n+1)}{2} $$

推导出总弹珠数公式：

$$ S_h = \sum_{k=1}^h T_k = \frac{h(h+1)(h+2)}{6} $$

然后建立不等式：

$$ \frac{h(h+1)(h+2)}{6} \leq 20230610 $$

即：

$$ h(h+1)(h+2) \leq 121383660 $$

$$ h \approx \sqrt[3]{121383660} \approx 495 $$

- 当 $h=494$ 时：
     $$ \frac{494×495×496}{6} = 20214480 \leq 20230610 $$

- 当 $h=495$ 时：
     $$ \frac{495×496×497}{6} = 20337240 > 20230610 $$

因此，最终答案为:
$$ 494
$$

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<494;
    return 0;
}
```

---

## 作者：longyitongxue (赞：0)

[Click this](https://www.luogu.com.cn/problem/P12206) to the question.
# 做法
我们先找找规律。观察图片，我们发现：

- 第一层有 $1$ 颗珠子。
- 第二层有 $1+2$ 颗珠子。
- 第三层有 $1+2+3$ 颗珠子。
- 第四层有 $1+2+3+4$ 颗珠子。
- 第五层有 $1+2+3+4+5$ 颗珠子。

到这里，我们发现，第 $n$ 层的珠子数为 $1+2+3+\cdots+n$，问题也变简单了。我们可以用一个 `for(int i=1;;i++)`（Python 可以使用一个循环变量 $i$ 并使用 `while True`）的无限循环，并用 $cnt$（代表搭建这个金字塔所用的珠子个数）和 $gs$（代表当前层数所用的珠子个数），让 $cnt$ 一直累加 $gs$，直到 $cnt>20230610$ 时，这时 $i-1$ 即为答案[^1]。输出并退出循环即可。为了保险起见，开一个 `long long`（Python 选手不用考虑）。

[^1]: 这里说明一下为什么 $i$ 不是答案而是 $i-1$。因为我们无法判断他的珠子是不是正好够用。判断 $cnt\geq20230610$ 时，我们不知道它是正好够还是珠子还有剩余，而判断 $cnt>20230610$ 时，我们却可以很清楚地知道当前我特意加多了一次，不管你有没有剩余，我都可以直接通过输出 $i-1$ 得知答案。

# AC code
## [C++](https://www.luogu.com.cn/record/214093684)
```cpp
#include<iostream>
using namespace std;
int main(){
    long long cnt=0,gs=0;
    for(int i=1;;i++){
        gs+=i;
        cnt+=gs;
        if(cnt>20230610){
            cout<<i-1;
            break;
        }
    }
    return 0;
}
```
## [Python](https://www.luogu.com.cn/record/214093632)
```python
i=1
cnt=0
gs=0
while True:
    gs+=i
    cnt+=gs
    if cnt>20230610:
        print(i-1)
        break
    i+=1
```

---


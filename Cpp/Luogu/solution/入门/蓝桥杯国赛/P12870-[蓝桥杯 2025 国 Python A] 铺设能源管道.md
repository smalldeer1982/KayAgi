# [蓝桥杯 2025 国 Python A] 铺设能源管道

## 题目描述

能源公司正着手建立新的基地。为了确保基地的能源供应，公司计划铺设一条长度至少为 $n$ 公里的能源管道。铺设管道的成本并非简单地与管道长度成正比，而是由管道长度的**各位数字之和**决定。例如，铺设 $123$ 公里的管道，实际成本为 $1 + 2 + 3 = 6$ 。

为了尽可能降低成本，公司希望找到一个长度为 $m$ 公里的铺设方案，使得 $m$ 不小于 $n$，并且 $m$ 的数位和最小。如果存在多个满足条件的 $m$，则选择数值最小的方案，以确保在成本相同的情况下，尽可能减少资源浪费。

现在，请你帮助能源公司计算出最优的管道铺设长度 $m$。

## 说明/提示

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$1 \leq n \leq 100$。

对于所有的评测用例，$1 \leq n \leq 10^9$。

## 样例 #1

### 输入

```
9```

### 输出

```
10```

# 题解

## 作者：封禁用户 (赞：11)

# [P12870 [蓝桥杯 2025 国 Python A] 铺设能源管道](https://www.luogu.com.cn/problem/P12870)
## 题目介绍：
一个最低为 $n$ 公里的能源管道，找到一个长度为 $m$ 公里的铺设方案，$m$ 要大于 $n$，并且 $m$ 的数位和最大，如有多个解，输出本身值最小的那一个。

## 分析做法：
最少数位和一定是 $1$，也就是在值为 $1$ 和 $1$ 后面有若干个 $0$ 的情况，也就是说只有可能输出这种数。在 $10^9$ 内，也就只有 $9$ 个这样的数字也就只有 $10$ 个，分别是 $1$，$10$，$100$，$1000$，$10000$，$100000$，$1000000$，$10000000$，$100000000$，$1000000000$，因此，我们可以打表。

如何打表呢，可以用 $10$ 个判断语句即可，分别判断 $n$ 是不是小于从小到大那 $10$ 个数，为什没要从小到大呢，因为在数位之和相同的情况下，取本身值最小的那个。

注意要加否则，不然程序会继续运行导致再次输出。

奉上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 

signed main() {
	int n;
	cin >> n;
	if (n == 1) cout << 1 << endl;
	else if (n <= 10) cout << 10 << endl;
	else if (n <= 100) cout << 100 << endl;
	else if (n <= 1000) cout << 1000 << endl;
	else if (n <= 10000) cout << 10000 << endl;
	else if (n <= 100000) cout << 100000 << endl;
	else if (n <= 1000000) cout << 1000000 << endl;
	else if (n <= 10000000) cout << 10000000 << endl;
	else if (n <= 100000000) cout << 100000000 << endl;
	else if (n <= 1000000000) cout << 1000000000 << endl;
    return 0;
}
```

谢谢观看，求过求赞。

---

## 作者：chen_kun (赞：3)

# 题解：P12870 [蓝桥杯 2025 国 Python A] 铺设能源管道

一道十分简单的题。

## 思路简述

既然要各数位之和最小，那么自然是开头为 $1$ 后面一堆 $0$ 的数各数位之和最小，即**各数位之和为 1 的数就是我们所需寻找的答案**。由于可能存在多种答案，题目要求我们要找到最小的答案。那么对于一个 $a$ 位的数 $n$，它所对的最优的管道铺设长度 $m$ 就为一个 $1$ 后面跟 $a$ 个 $0$。此外，如果 $n$ 本身就符合各数位之和等于 $1$，直接输出 $n$ 即可。

## 代码呈现

### C++


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
signed main(){
	cin>>n;
    if(n%10==0||n==1){//如果本身各数位之和就为1则直接输出
        cout<<n;
        return 0;
    }
	cout<<1;//最高位为1 
	while(n){
		cout<<0;//剩下的都是0 
		n/=10;
	}
	return 0;
}
```

---

## 作者：_____Elysia_____ (赞：1)

好简单啊。$10$ 的非负整数幂次的各位数字之和是 $1$，其他正整数的各位数字之和都大于 $1$。所以尽可能使 $m$ 为 $10$ 的幂次即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,t=1;
    cin>>n;
    while(1){
        if(t>=n){
            cout<<t<<endl;
            return 0;
        }
        t*=10;
    }
}
```

贴个 Python 代码：

```python
a=int(input())
b=1
while b<a:
   b*=10
print(b)
```

---

## 作者：枫原万叶 (赞：1)

# P12870 题解

## 分析

首先因为只需要我们找到最小价值所以我们只需要让价值最小即可，实际数值的大小无所谓，那么所有都可以找到价值为 1 的方案，也就是 10 的正整数次幂，此时价值最小。又因为需要找实际数值最小的那个，所以我们就在每次计算时比较一下就可以了，最后呈现出的代码请看下面所示（注意开 `long long` 不然会炸掉）。

## 代码

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
int main(){
	ll n,m=1;
	cin>>n;
	while(m<n){
		m*=10;
	}
	cout<<m;
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

由于 $10^k$（$k\in\N$）的数字和取最小值 $1$，所以题目中的答案一定为 $10^k$（$k\in\N$）。

如果 $n$ 已经是 $10$ 的幂，那么直接取 $m=n$ 即可。否则设 $n$ 共有 $l$ 位，取 $m=10^l$ 即可。


```python
n=int(input())
s=str(n)
ok = True
l = len(s)

if s[0] != '1':
    ok = False
else:
    for i in range(1, l):
        if s[i] != '0':
            ok = False
            break

if ok:
    print(n)
else:
    print("1" + "0" * l)
```

---

## 作者：SuyctidohanQ (赞：1)

### 思路分析

我的做法可能有些复杂了。

题目让我们要找一个不小于 $n$ 的整数 $m$，让 $m$ 的数位和最小，**数位和**相同时选数值**最小**的。

首先就可以写出一个拆位的函数：

```cpp
LL ds(LL x) {
	LL sum = 0;
	while(x > 0) {
		sum += x % 10;
		x /= 10;
	}
	return sum;
}
```

先算 $n$ 的数位和作为初始最小，为了方便处理再把 $n$ 转成字符串，**按位处理**：从第一位到最后一位，每次取当前位之前的部分作为**前缀**，若**前缀非空且最后一位是** $9$ 就跳过，否则给**前缀最后一位**加 $1$，后面补 $0$ 生成新数 $c$。

如果 $c$ 不小于 $n$，就算它的**数位和**，比当前最小小或者相等但 $c$ 更小，就更新最优解。

### 代码实现

这里给出 C++ 和 Python 的实现代码。

```cpp
#include<bits/stdc++.h>
#define please return 
#define AC 0
#define rep(i, a, b) for(long long i = a; i <= b; i++)
#define repr(i, a, b) for(long long i = a; i >= b; i--)

using namespace std;

typedef long long LL;

int read() {int  sum = 0, f = 1; char ch; ch = getchar(); while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar();} while(ch >= '0' && ch <= '9') { sum = sum * 10 + ch - '0'; ch = getchar();} return sum * f;}
void print(int x) { if(x < 0) { putchar('-'); x = -x;} if(x > 9) print(x / 10); putchar(x % 10 + '0'); return ;}

long long ds(long long x) {
    long long s = 0;
    while (x > 0) {
        s += x % 10;
        x /= 10;
    }
    return s;
}
signed main() {
	LL n; scanf("%lld", &n);
	LL ms = ds(n), bs = n;
	string sn = to_string(n);
	LL l = sn.size();
	rep(i, 0, l - 1) {
		string p = sn.substr(0, i);
		if(!p.empty() && p.back() == '9') continue;
		if(!p.empty()) p.back()++;
		else p = '1';
		string s(l - i, '0');
		LL c = stoll(p + s);
		if(c < n) continue;
		LL cs = ds(c);
		if(cs < ms || (cs == ms && c < bs)) {
			ms = cs;
			bs = c;
		}
	}
	printf("%lld\n", bs);
	please AC; 
}
```

```python
def ds(x):
	s = 0
	while x > 0:
		s += x % 10
		x //= 10
	return s

n = int(input())
ms = ds(n)
bs = n
sn = str(n)
l = len(sn)

for i in range(l):
	p = sn[:i]
	if p and p[-1] == '9':
		continue
	if p:
		p = p[:-1] + chr(ord(p[-1]) + 1)
	else:
		p = "1"
	s = '0' * (l - i)
	c = int(p + s)
	if c < n:
		continue
	cs = ds(c)
	if cs < ms or (cs == ms and c < bs):
		ms = cs
		bs = c

print(bs)
```

最后，建议升橙，模拟和贪心再结合这道题目的难度已经达到了橙题的水平。

---

## 作者：furina_yyds (赞：0)

# P12870 [蓝桥杯 2025 国 Python A] 铺设能源管道

这是一道水题。

## 题意

给定一个数 $n$，求出数字和最小的大于等于 $n$ 的数。

## 思路

我们可以发现，对于所有的 $n$，大于等于 $n$ 的数最小数字和为 $1$。

为什么呢？对于每一个 $n$，都有一个最小的数 $k$，满足 $10 ^ k > n$，且数字和不可能为 $0$，故 $10 ^ k$ 必为最优解。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d", &n);
	long long m = 1;
	while(m < n){
		m *= 10;
	}
	printf("%lld", &m);
	return 0;
}
```

---


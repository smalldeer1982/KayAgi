# [蓝桥杯 2025 省 C/Python A] 2025 图形

## 题目背景

本站蓝桥杯 2025 省赛测试数据均为洛谷自造，与官方数据可能存在差异，仅供学习参考。

## 题目描述

小蓝要画一个 $2025$ 图形。图形的形状为一个 $h \times w$ 的矩形，其中 $h$ 表示图形的高，$w$ 表示图形的宽。当 $h = 5, w = 10$ 时，图形如下所示：

```
2025202520
0252025202
2520252025
5202520252
2025202520
```

图形的规律是：第一行用 $2025$ 重复填入，第二行开始，每行向左移动一个字符，用 $2025$ 重复填入。
给定 $h, w$，请输出对应的图形。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$h = 1$，$1 \leq w \leq 20$；
- 对于 $60\%$ 的评测用例，$1 \leq h, w \leq 20$；
- 对于所有评测用例，$1 \leq h, w \leq 100$。

## 样例 #1

### 输入

```
4 5```

### 输出

```
20252
02520
25202
52025```

# 题解

## 作者：0Io_oI0 (赞：4)

这就是不仔细读题的后果。

一道水题，注意到是要画矩形，所以先打出代码框架，再想具体如何实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int h,w;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>h>>w;
	for(int i=1;i<=h;i++){
		
		for(int j=1;j<=w;j++){
			
		}
		
	}
	return 0;
}
```

好了，接下来按照题目模拟即可，注意到题目让我们在每一行中轮流输出 $2,0,2,5$，并且每行与每行之间的第一个数字以 $2,0,2,5$ 轮换。

这样就很简单了！首先打个很小的表：

```cpp
a[]={2,0,2,5}
```
注意到 $2,0,2,5$ 所对应的下标分别为 $0,1,2,3$ 构成了模 $4$ 的完全剩余系，所以每次输出的时候我们就考虑建立一个数 $cnt$ 来看看这个数是这一行的第几个然后输出就是：

```cpp
cout<<a[cnt%4];
```
了，所以接下来写出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int h,w,a[]={2,0,2,5},cnt;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>h>>w;
	for(int i=1;i<=h;i++){
		
		for(int j=1;j<=w;j++){
			cout<<a[cnt%4];
			cnt++;//将 cnt 加一最为后一个数
		}
		cout<<'\n';
	}
	return 0;
}
```

这里注意还没有完，这里我们只处理了，每一行之间的轮流输出 $2,0,2,5$ 我们还需要让行与行之间的第一个数交替轮换。

其实这样也很简单，就是每次循环的时候给 $cnt$ 一个初始值即可。

初始值也很简单，看到第一个循环中的 $i$ 了吗？

用它来记录每一行的第一个数应该是什么即可，但是注意我们模 $4$ 的时候是从 $0$ 开始的所以初始化并不是：

```cpp
cnt=i;
```
而应该是
```cpp
cnt=i-1;
```

这样就能写好完整代码了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int h,w,a[]={2,0,2,5},cnt;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>h>>w;
	for(int i=1;i<=h;i++){
		cnt=i-1;
		for(int j=1;j<=w;j++){
			cout<<a[cnt%4];
			cnt++;
		}
		cout<<'\n';
	}
	return 0;
}
```

亲测可过，请勿抄袭！

---

## 作者：Flambler (赞：3)

# P12164 题解
### Step 0 前言 Preface
~~[博客食用更佳](https://www.luogu.com.cn/article/oue0eb35)~~ 打算把蓝桥杯的题（P12162~P12168）全写一篇题解，这是 T3 的题解。
### Step 1 思路 Idea
我们首先分析一下样例并且表上下标（从 $0$ 开始，好找规律）：
```
  0 1 2 3 4 5 6 7 8 9
0 2 0 2 5 2 0 2 5 2 0
1 0 2 5 2 0 2 5 2 0 2 
2 2 5 2 0 2 5 2 0 2 5
3 5 2 0 2 5 2 0 2 5 2
4 2 0 2 5 2 0 2 5 2 0
```
我们可以尝试把两个下标加起来，看和字符有什么关系：
```
0+0=0:2
0+1=1:0
0+2=2:2
0+3=3:5
0+4=4:2
0+5=5:0
0+6=6:2
0+7=7:5
0+8=8:2
0+9=9:0
……
4+6=10:2
4+7=11:5
4+8=12:2
4+9=13:0
```
我们发现下标 $x$ 加上下标 $y$ 再 $\bmod4$ 和字符有关联：
1. $(x+y)\bmod4=0$ 的情况下：字符为 $2$。
2. $(x+y)\bmod4=1$ 的情况下：字符为 $0$。
3. $(x+y)\bmod4=2$ 的情况下：字符为 $2$。
4. $(x+y)\bmod4=3$ 的情况下：字符为 $5$。
### Step 2 代码 Code
根据这个规律，我们就能写出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[110][110], of[4]={'2', '0', '2', '5'};  // 映射
int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i = 0;i<n;i++) {
		for(int j = 0;j<m;j++) {
			ch[i][j]=of[(i+j)%4];  // 规律
		}
	}
	for(int i = 0;i<n;i++) {
		puts(ch[i]);  // 直接输出一行，不用挨个字符输出
	}
	return 0;
}
```
[100 pts record](https://www.luogu.com.cn/record/213609037)

---

## 作者：Dicer_L (赞：3)

## solution

### 简述题意

给出行和列，输出用 $2025$ 组成的图形。

规则是当 $i$ 整除 $4$ 余 $1$ 时，按照 $2-0-2-5$ 的顺序输出 $m$ 位。  
当 $i$ 整除 $4$ 余 $2$ 时，按照 $0-2-5-2$ 的顺序输出 $m$ 位。  
当 $i$ 整除 $4$ 余 $3$ 时，按照 $2-5-2-0$ 的顺序输出 $m$ 位。  
当 $i$ 整除 $4$ 余 $4$ 时，按照 $5-2-0-2$ 的顺序输出 $m$ 位。  
一共输出 $n$ 行。

### 好写的方法

先初始化一个的序列，里面是 $2025$。

$i$，$j$ 从 $0$ 开始遍历，两者相加模除 $4$ 即是当前位的数字。因为 $i$ 或 $j$ 每增加 $1$，就同样会向前一位输出。

### 给出代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
string s="2025";
signed main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++) cout<<s[(i+j)%4];
		cout<<'\n';
	}
}
```

```python
s="2025"
a,b=map(int,input().split())
for i in range(0,a):
  s1=""
  for j in range(0,b):
    s1=s1+s[(i+j)%4]
  print(s1)
```

---

## 作者：zxh_qwq (赞：1)

### P12164 题解

题很简单。

注意到每一行都是 $2025$ 的循环，第 $1 \sim 4$ 行的开头分别是 $2,0,2,5$。

我们只需要枚举行和列就行了。每一行因为是向左移了一列，相当于是在数字 $2025$ 中向后移了一列。

所以直接把行和列相加模拟就行了。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4]={2,0,2,5}; 
main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cout<<a[(i+j)%4];
		}
		cout<<endl;
	}
}
```

---

## 作者：_lxc__ (赞：1)

这题解题的关键在于当前行数模 $4$ 的余数 $k$。

* 若 $k=1$，则先输出 $[w\div 4]$ 个 `2025`，再输出 `2025` 的前 $w$ 模 $4$ 的余数个数。

* 若 $k=2$，则先输出 $[w\div 4]$ 个 `0252`，再输出 `0252` 的前 $w$ 模 $4$ 的余数个数。

* 若 $k=3$，则先输出 $[w\div 4]$ 个 `2520`，再输出 `2520` 的前 $w$ 模 $4$ 的余数个数。

* 若 $k=4$，则先输出 $[w\div 4]$ 个 `5202`，再输出 `5202` 的前 $w$ 模 $4$ 的余数个数。

综上得出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int h,w;
string s[10];
int main(){
	s[1]="2025",s[2]="0252",s[3]="2520",s[0]="5202";
	cin>>h>>w;
	for(int i=1;i<=h;i++){
		int k=i%4,cnt=w/4,q=w%4;
		for(int i=1;i<=cnt;i++) cout<<s[k];
		for(int i=0;i<q;i++) cout<<s[k][i];
		cout<<"\n";
	}
	return 0;
}

```

这样总时间复杂度 $O(h\times w)$，可以通过。

---

## 作者：LLY_0827 (赞：0)

## P12164 2025 图形

[传送门](https://www.luogu.com.cn/problem/P12164)

### 这是一篇 C++ 题解。
### 题意理解

画一个 2025 图形。图形的形状为一个 高 $h$ 宽 $w$ 的矩形，第一行用 2025 重复填入，第二行开始，每行向左移动一个字符后，用 2025 重复填入。
```
2025202520
0252025202
2520252025
5202520252
2025202520
```

### 思路

按题意模拟。

- 内循环增加一个循环变量 $st$ 来判断当前输出字符，在外循环时根据当前行数初始化，配合一个存储 $2,0,2,5$ 的数组实现移位输出，$st$ 在内循环中每四次归零。


### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll a[4]={2,0,2,5};
int main(){
	ll h,w;
	cin>>h>>w;
	for(ll i=1;i<=h;i++){
		ll st=i%4-1;
		if (st==-1) st=3;
		for (ll j=1;j<=w;j++,st++){
			if (st>3) st=0;
			cout<<a[st];
		}
		cout<<"\n";
	}
}
```

---

## 作者：yanmingqian (赞：0)

按照题意，我们每行生成一个字符串 $s$ 并输出即可。

考虑如何生成这样一个字符串。

首先定义一个 `string` 类型的数组：`string a[]={"5","2","0","2"};`，方便后续添加；

结合样例，我们可以枚举左移的次数，通过第一行 $s$ 的生成推出下一行乃至每一行 $s$ 的生成：

第一行，每次在 $s$ 的末尾加入 `a[j%4]`；\
第二行，每次在 $s$ 的末尾加入 `a[(j+1)%4]`；\
第三行，每次在 $s$ 的末尾加入 `a[(j+2)%4]`；\
……\
第 $i$ 行，每次在 $s$ 的末尾加入 `a[(j+i-1)%4]`；

据此不难写出代码：

```cpp
#include<iostream>
using namespace std;
string a[]={"5","2","0","2"};
int main(){
    int h,w;
    cin>>h>>w;
    for(int i=1;i<=h;i++){  //第i行，也就是左移(i-1)次
        string s="";
        for(int j=1;j<=w;j++){
            s+=a[(j+i-1)%4];  //根据前面的推导生成s
        }
        cout<<s<<"\n";
    }
    return 0;
}
```

---

## 作者：collegiate (赞：0)

### 问题
给定 $n$ 和 $m$ 的数据，生成一个矩阵。

矩阵的规律为：第一行用 $2025$ 重复填入，第二行开始，每行向左移动一个字符，用 $2025$ 重复填入。

### 思路
看见**重复填入**这四个字，第一时间应该想到**取余**这个方法。

我们用一个数组来存储 $2025$ 这四个数字，再用一个计数器 $cnt$ 变量。

每次输出的时候就输出数组下标为 $cnt$ 取余 $4$ 的答案即可。

但是我们还注意到从第二行开始每行向左移动一个字符，所以 $cnt$ 的初始值是要变化的。

所以每次的 $cnt$ 初始值应该是 $4+i$ 才对，因为每次向左移动一个，所以加上行数 $i$ 数值。

最后模拟一下即可：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=105;
ll n,m,cnt;
ll number[4]={2,0,2,5};
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cnt=i+3;
		for(int j=1;j<=m;j++){
			cout<<number[cnt%4];
			cnt++;
		}		
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

由于每行左移一位，直接取数列 $2,0,2,5$ 的第 $\lfloor\frac{x+y}4\rfloor$ 项即可。
```c
#include<stdio.h>
unsigned char h,w,x,y,s[4]={50,48,50,53};
int main()
{
    scanf("%hhu%hhu",&h,&w);
    for(x=0;x<h;++x)
    {
        for(y=0;y<w;++y)putchar(s[(x+y)%4]);
        putchar(10);
    }
}
```

---


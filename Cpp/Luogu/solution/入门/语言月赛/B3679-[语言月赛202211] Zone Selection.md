# [语言月赛202211] Zone Selection

## 题目描述

在第五人格巅峰七阶及以上的排位赛中，需要进行区域选择。我们将在本题中形式化、推广化的解决区域选择问题。

在地图中，共有 $n$ 台密码机，第 $i$ 台密码机的坐标为 $(x_i,y_i)$。在推广化的游戏中，有 $k$ 名求生者。每名求生者可以选择一台密码机作为其出生点，我们称被选择的密码机为 **出生密码机**。

监管者共有 $T$ 个出生点可供选择。第 $i$ 个可能的出生点坐标为 $(x_i,y_i)$。此时，由于“封禁”天赋的存在，离监管者最远的密码机将不能被破译。

**如果多台密码机与监管者的距离相同且最远，“封禁”天赋将会封禁这几台密码机中标号最小的那一台。**

请问在该 $T$ 个出生点中，有多少出生点，可以使某一台 **出生密码机** 被封禁。

请注意：坐标点 $(x_1,y_1)$ 与坐标点 $(x_2,y_2)$ 之间的距离为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

## 说明/提示

**【样例 #1 解释】**

显然，第一台密码机和第四台密码机为**出生密码机**。

第一位监管者与位置在 $(-1, 0)$ 的第一台密码机距离最远，为 $4$。因此，第一台密码机被封禁。

第二位监管者与位置在 $(2, 0), (0, 2)$ 的第三、四台密码机距离相同且最远，为 $2$。根据上面提到的规则，第三台密码机被封禁。

被封禁的出生密码机为 $1$ 台。

**【数据规模与约定】**

对前 $10\%$ 的数据，保证 $n = k = 1$。

对前 $20\%$ 的数据，保证 $n, k, t \leq 10$。

对另外 $20\%$ 的数据，保证密码机与出生点的坐标中的 $x$ 均为 $0$。

对另外 $10\%$ 的数据，保证 $n = k$。

对另外 $10\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据范围 $1 \le k \le n \le 10^3, 1 \le T \le 10^3, 1 \le |x_i|,|y_i| \le 10^3$。

## 样例 #1

### 输入

```
4 2 2
-1 0
0 -1
2 0
0 2
-1 0
0 2
3 0
0 0```

### 输出

```
1```

# 题解

## 作者：Maxmilite (赞：30)

# B3679 [语言月赛202211] Zone Selection 题解

## Source & Knowledge

2022 年 11 月语言月赛，由洛谷网校入门计划/基础计划提供。

本题考察对**循环结构**和**分支结构**的高级应用。

## 文字题解

### 题目大意

分别给定 $n$ 个坐标 $(x _ i, y _ i)$，$k$ 个坐标 $(x _ i, y _ i)$，$T$ 个坐标 $(x _ i, y _ i)$，保证 $k$ 个坐标在之前的 $n$ 个坐标中出现过。

对第三组数据 $T$ 个坐标中的每个坐标，求出第一组数据 $n$ 个坐标中与之**最近**的坐标是否在第二组 $k$ 个坐标中。

### 解析

按照题目给出的信息，写出计算距离的函数。

```cpp
int getDist(int x, int y, int z, int w) {
	// 求出 (x, y) 与 (z, w) 之间的距离
	return sqrt((x - z) * (x - z) + (y - w) * (y - w));
}
```

首先录入第一组 $n$ 个坐标，对于第二组 $k$ 个坐标中的每个坐标，逐个判断其属于 $n$ 个坐标中的哪一个即可。找到对应的坐标后，我们对其进行标记以便于后面的判断。

这里可以使用传统数组或者结构体或者其他方式解决，以下为使用结构体的例子：

```cpp
#define MAXN 1005

struct Position {
	int x, y;
	bool isMarked;
} a[MAXN];

// 函数部分
for (int i = 1; i <= n; ++i) {
	cin >> a[i].x >> a[i].y;
}

for (int i = 1; i <= k; ++i) {
	int x, y;
	cin >> x >> y;
	for (int j = 1; j <= n; ++j)
		if (a[j].x == x && a[j].y == y) {
			a[j].isMarked = true;
			break;
		}
}
```

其次，录入 $T$ 组询问坐标，对每个坐标，找到第一组 $n$ 个坐标中与之最远的一个。

遍历过程中，我们可以记录当前的最大距离和最大距离对应的节点，如果现在的节点与当前节点距离**大于**之前的最大距离，那么记录这个节点，同时更新当前的最大距离。例子如下：

由于我们保证了当且仅当“**大于**”才更新，所以我们保证了当距离相同时取到了标号最小的。

```cpp
for (int i = 1; i <= t; ++i) {
	int x, y;
	cin >> x >> y;
	double maxDist = -1;
	int ans = 0;
	for (int j = 1; j <= n; ++j) {
		if (getDist(x, y, a[j].x, a[j].y) > maxDist) {
			ans = j;
			maxDist = getDist(x, y, a[j].x, a[j].y);
		}
	}
    ...
}
```

此时 `ans` 变量存储的是最远的机器对应的数组下标，使用上面的 `isMark` 参数进行判断计数即可。

```cpp
if (a[ans].flag) {
		++res;
	}
}
```

`res` 即为最终答案。

## 视频题解

**完整代码请在视频中查看。**

![](bilibili:BV1Q14y1H7a1?page=4)

---


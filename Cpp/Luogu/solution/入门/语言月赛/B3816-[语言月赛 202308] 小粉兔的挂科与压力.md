# [语言月赛 202308] 小粉兔的挂科与压力

## 题目描述

小粉兔在 T 大学就读。在 1 月 54 日，T 大学开始了一学期一度的期末考试环节。

小粉兔本学期有 $n$ 科考试，按照时间先后顺序依次被标号为 $1, 2, \cdots, n$。每一科考试都具有一个难度系数 $a _ i$。

如果准备这么多考试，小粉兔很可能会压力激增。因此，他想要仅准备并参与一部分考试，而将剩余的科目申请缓考。具体的，他可以选择准备**前任意科**考试（可以是 $0$ 门，可以是 $n$ 门），而剩余的科目不做准备。

但是，缓考的考试在下学期仍然需要参加，所以小粉兔会对他的决策做一个评估。他会使用「压力值」去完成这一评估过程。

具体的，我们设小粉兔选择参加前 $k$ 科考试（$0 \leq k \leq n$）。给定一个压力系数 $c$，此时他的压力值 $t$ 的计算方式如下：

$$
t = \max \limits _ {i = 1} ^ {k} a _ i + c \times (n - k) 
$$

其中 $\max \limits _ {i = 1} ^ {k} a _ i$ 代表 $a _ 1, a _ 2, \cdots, a _ k$ 中的最大值。特别的，如果 $k = 0$，则 $\max \limits _ {i = 1} ^ {k} a _ i = 0$。

现在，小粉兔知道了考试的科数 $n$ 和每门考试的难度系数 $a _ 1, a _ 2, \cdots, a _ n$，请你帮他计算出「压力值」最小时需要准备的考试科目数量。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq n \leq 10 ^ 6$，$1 \leq a _ i \leq 10 ^ 9$，$1 \leq c \leq 10 ^ 9$。

| 测试点编号 | $n$ | $a _ i$ |
| :----------: | :----------: | :----------: |
| $1$ | $= 0$ | $\leq 10 ^ 9$ |
| $2$ | $= 1$ | $\leq 10 ^ 9$ |
| $3 \sim 5$ | $\leq 10$ | $\leq 10 ^ 9$ |
| $6$ | $\leq 10 ^ 6$ | $= 1$ |
| $7 \sim 10$ | $\leq 10 ^ 6$ | $\leq 10 ^ 9$ |

## 样例 #1

### 输入

```
3 2
2 3 5```

### 输出

```
2 5```

## 样例 #2

### 输入

```
10 3
6 4 5 5 6 2 2 4 19 9```

### 输出

```
8 12```

## 样例 #3

### 输入

```
3 2
7 2 5```

### 输出

```
0 6```

# 题解

## 作者：Maxmilite (赞：9)

## Source & Knowledge

2023 年 8 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定 $n, c$ 与 $a _ 1, a _ 2, \cdots, a _ n$，求 $t = \max \limits _ {i = 1} ^ {k} a _ i + c \times (n - k)$ 的最小值。如果多个 $t$ 相同且最小，输出 $k$ 最小的一个。

其中 $\max \limits _ {i = 1} ^ {k} a _ i$ 代表 $a _ 1, a _ 2, \cdots, a _ k$ 中的最大值。特别的，如果 $k = 0$，则 $\max \limits _ {i = 1} ^ {k} a _ i = 0$。

## 题目分析

本题考察对循环结构的复杂运用。

我们可以注意到这样一个有趣的情况：

$$
\begin{aligned}
& \max \limits _ {i = 1} ^ {k + 1} a _ i \\
= & \max \{ a _ 1, a _ 2, \cdots, a _ {k + 1}\} \\
= & \max(\max  \{a _ 1, a _ 2, \cdots, a _ k\}, a _ {k + 1}) \\
= & \max((\max \limits _ {i + 1} ^ {k} a _ i), a _ {k + 1})
\end{aligned}
$$

也就是，$a$ 的前 $k + 1$ 项的最大值可以通过将「前 $k$ 项的最大值」与「第 $k + 1$ 项」取最大值得到。

因此，我们可以使用一个变量 $d$ 暂存这个最大值，在循环读入新数据 $a _ i$ 时，进行对应的更新。

```cpp
int d = 0;
for (int k = 1; k <= n; ++k) {
    int x; // x 用于暂存 a 数据
    cin >> x;
    d = max(d, x);
}
```

在每次更新 $d$ 后，我们可以非常容易地计算出此时的 $t$。最后，使用擂台法计算所有的 $t$ 中的最小值即可。

在取最小值时，需要特殊处理「多个 $t$ 相等」的情况，以及记录下对应的 $k$。

```cpp
int d = 0;
int t = c * n; // k = 0，初始值
int ans = 0; // t 最小时的 k
for (int k = 1; k <= n; ++k) {
    int x; // x 用于暂存 a 数据
    cin >> x;
    d = max(d, x);
    if (d + c * (n - k) < t) {
        t = d + c * (n - k);
        ans = k;
    }
}
```

## 视频讲解

视频题解后续将会上传。


---


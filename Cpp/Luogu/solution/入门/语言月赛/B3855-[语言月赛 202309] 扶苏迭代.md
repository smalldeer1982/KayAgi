# [语言月赛 202309] 扶苏迭代

## 题目背景

给定一个函数 $f(x)$，我们关注如何求出一个点 $x_0$ 使得当把 $x_0$ 带入函数式时，得到的函数值 $f(x_0)$ 为 $0$。即求出方程 $f(x) = 0$ 的一个根 $x_0$。

牛顿迭代法就是这样一个方法。

但是我不打算向您介绍牛顿迭代的具体方法，因为这和本题没什么关系。

## 题目描述

给定初始变量 $x_0$，请你按如下表达式迭代计算 $x_i$：

$$x_i = \left\lfloor\frac{x_{i - 1} + a}{a}\right\rfloor$$

其中 $i > 0$。

我们称这个迭代过程为扶苏迭代。可以证明，在经过若干次扶苏迭代以后，$x_i$ 的取值会稳定成为一个常数 $x_N$。也就是存在一个 $j \geq 0$，使得对于所有 $k,h \geq j$，$x_k = x_h$。

你的任务是输出 $x_i$ 稳定到这个常数前的扶苏迭代过程。即输出 $x_0, x_1, x_2, \dots x_j$。这里 $j$ 是最小的满足 $x_j = x_N$ 的数。

可以证明，在给定的数据范围下，迭代次数不会很多。

## 说明/提示

### 数据规模与约定

- 对 $30\%$ 的数据，$T = 1$。
- 另有 $30\%$ 的数据，$x_0 = a$。
- 对 $100\%$ 的数据，$2 \leq x_0, a \leq 2 \times 10^9$，$1 \leq T \leq 10^4$。

## 样例 #1

### 输入

```
2
2 2
3 2```

### 输出

```
2
3 2```

# 题解

## 作者：一扶苏一 (赞：3)

## Source & Knowledge

2023 年 09 月语言月赛，由洛谷网校入门计划/基础计划提供。

---

## 文字题解

### 题意简述

计算迭代式 $x_i = \left\lfloor\frac{x_{i - 1} + a}{a}\right\rfloor$，直到相邻两次迭代的结果相同。

### 解析

直接使用 while 循环模拟上面的迭代式即可。使用一个变量 $pre$ 表示上次迭代后 $x$ 的值。只要本次迭代的结果不等于 $pre$ 就一直进行迭代。

```cpp
int pre = -1;
while (pre != x) {
  cout << x << '\n';
  pre = x;          // 本次迭代结束后，x 原来的值就变成了上次迭代的结果。
  x = (x + a) / a;
}
```
与 A 题相同，虽然 $x$ 和 $a$ 都在 int 范围内，但是二者的和可能会爆掉 int，所以要开 long long。

---

## 视频题解


---

## 作者：Yun_Mengxi (赞：2)

[题目传送门](/problem/B3855)

## 分析

首先观察到，$2\le a\le 2\times 10^9$，这说明时间复杂度可能是 $O(\log_ax)$，然后就可以分析出，这是道模拟题，按照题意模拟即可，因为要求在稳定至常数前输出，所以每次判断一下 $x$ 是不是等于 $x'$ 就行了，其中，$x'$ 是上一次的 $x$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
  long long a, t, x, lx;
  cin >> t;
  while (t--) {
    cin >> x >> a;
    lx = 0;
    while (x != lx) {
      cout << x << " ";
      lx = x;
      x = (x + a) / a;
    }
    cout << '\n';
  }
}
```

---

## 作者：Acheron_RBM (赞：1)

这题是个很简单的模拟。

我们只需要一直模拟扶苏迭代的过程,直到得到答案即可。

最重要的一点，要开 `long long`。

```cpp
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
    	long long x0,a;
    	cin>>x0>>a;
    	long long x[2000]={0};
    	x[0]=x0;
    	cout<<x[0]<<" ";
    	for(int i=1;;i++)
		{
			x[i]=floor(1.0*(x[i-1]+a)/a);
			//cout<<x[i]<<" "; 
			if(x[i]==x[i-1])
			{
				break;
			}
			else
			{
				cout<<x[i]<<" ";
			}
		}
		cout<<"\n";
	}
    return 0;
}
```

---

## 作者：xujunlang2011 (赞：1)

## 题意

题目里说得非常清楚，倒回去看看吧。

## 思路

直接按照题目要求模拟，在递归的过程中输出即可。

注意事项：

$2 \leq x_0, a \leq 2 \times 10^9$，所以记得开 `long long`。

有多组数据。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
void fusu(long long x, long long y, long long a)
{
	if (x == y)
	{
		cout << "\n";
		return;
	}
	cout << x << " ";
	fusu((x + a) / a, x, a);
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1;i <= n;i++)
    {
    	long long x, y = -114514, a;
    	cin >> x >> a;
    	fusu(x, y, a);
    }
    return 0;
}
```


---

## 作者：Slient_QwQ (赞：0)

## 分析
直接进行模拟，用一个变量保存上一个数，然后将原数进行迭代，每次循环时检查当前数字是否跟上一个数相同，相同则退出，记得多测清空。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll x, last, k;
int main()
{
	int T;
	cin >> T;
	while (T--)
	{
		last = -1;
		cin >> x >> k;
		while (last != x)
		{
			cout << x << " ";
			last = x;
			x = (x + k) / k;
		}
		cout << endl;
	}
	return 0;
}
```

---


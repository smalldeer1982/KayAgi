# [语言月赛 202312] 颜料覆盖

## 题目背景

一副精美的画作可能需要很多次重复的颜料涂抹。涂抹的一层层颜料会产生许多覆盖。这一次我们将这一个情景简化后交给了你，希望你能够解开颜料覆盖的奥秘。

## 题目描述

给定一个 $n$ 行 $m$ 列的矩阵 $a$。每一行代表画作的一块区域。每一行从前往后分别代表 $m$ 次绘画。

用 $a _ {i, j}$ 代表序列中第 $i$ 行第 $j$ 列的元素，$a _ {i, j}$ 代表区域 $i$ 在第 $j$ 次绘画中被涂抹的颜料强度。如果 $a _ {i, j} = 0$，那么代表区域 $i$ 在第 $j$ 次中未被涂抹。

现在，对于每个区域，你需要找出涂抹强度最大的一次是哪一次。同时，你需要找出，在这一次之前，有多少次涂抹（不计算未涂抹的情况）强度比这一次小。

保证对于某个区域，不会出现两次涂抹强度相同且最大。

## 说明/提示

### 样例 1 解释
- 第一行（第一个区域）中，第 $\color{red}4$ 次涂抹的强度最大，为 $3$。在第 $4$ 次之前，有且仅有第 $2$ 次这一次「有涂抹（不为 $0$）」且「强度比第 $4$ 次小」，故答案为 `4 1`。
- 第二行（第二个区域）中，第 $\color{red}3$ 次涂抹的强度最大，为 $1$。在第 $3$ 次之前，该区域没有被涂抹过（即第 $3$ 次之前全为 $0$），故答案为 `3 0`。
- 第三行（第三个区域）中，第 $\color{red}5$ 次涂抹的强度最大，为 $5$。在第 $5$ 次之前，有 $\color{red}4$ 次「有涂抹」且「强度比第 $5$ 次小」，因此答案为 `5 4`。


### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10 ^ 6$，$1 \leq n \times m \leq 10 ^ 6$，$0 \leq a _ {i, j} \leq 10 ^ 9$。

| 测试点 | $n$ | $m$ | 特殊性质  |
| :-: | :-: | :-: | :-: |
| $1$ | $= 1$ | $= 1$ | 无 |
| $2 \sim 3$ | $\leq 10$ | $\leq 10$ | 无 |
| $4 \sim 6$ | $\leq 10 ^ 3$ | $\leq 10 ^ 3$ | 无 |
| $7 $ | $\leq 1$ | $\leq 10 ^ 6$ | 无 |
| $8$ | $\leq 10 ^ 6$ | $\leq 1$ | 无 |
| $9 \sim 10$ | $\leq 10 ^ 6$ | $\leq 10 ^ 6$ | 每一行的第一个元素是这一行的最大值 |
| $11 \sim 12$ | $\leq 10 ^ 6$ | $\leq 10 ^ 6$ | 每一行的最后一个元素是这一行的最大值 |
| $13 \sim 14$ | $\leq 10 ^ 6$ | $\leq 10 ^ 6$ | 每一行有且仅有一个非 $0$ 元素 |
| $15 \sim 20$ | $\leq 10 ^ 6$ | $\leq 10 ^ 6$ | 无 |

保证在矩阵的某一行中不存在两个元素相同且最大，保证不存在某一行全部为 $0$。

## 样例 #1

### 输入

```
3 5
0 1 0 3 2
0 0 1 0 0
1 1 3 4 5```

### 输出

```
4 1
3 0
5 4```

# 题解

## 作者：Maxmilite (赞：0)

## Source & Knowledge

2023 年 12 月语言月赛，由洛谷网校入门计划/基础计划提供。

## 题目大意

给定一个 $n$ 行 $m$ 列的矩阵 $a$。求每一行中的最大值和这个最大值之前有多少个非 $0$ 值比它小。 
	
## 题目分析

本题考察对二维循环结构的运用。

对于「这个最大值之前有多少个非 $0$ 值比它小」，略微琢磨便可发现，在最大值唯一的情况下，「比最大值小」是一定成立的。因此，题目的第二个任务可以转化为「求这个最大值之前有多少个非 $0$ 值」。

对于第一个任务，可以使用「擂台法」轻松解决。擂台记录当前最大值和最大值的位置。读入元素时和最大值比较，如果更大则更新擂台。

```cpp
for (int i = 1; i <= n; ++i) {
	int max_val = -1, max_pos = -1;
	for (int j = 1; j <= m; ++j) {
		int x;
		cin >> x;
		if (x > max_val) {
			max_val = x;
			max_pos = j;
		}
	}
}
```

对于第二个任务，可以考虑到，我们在读入元素的同时计数非 $0$ 元素个数即可。在擂台中额外记录此时的非 $0$ 元素个数，在「擂台法」的同时更新即可。

```cpp
for (int i = 1; i <= n; ++i) {
	int max_val = -1, max_pos = -1, max_cnt = -1;
	int cnt = 0; 
	for (int j = 1; j <= m; ++j) {
		int x;
		cin >> x;
		if (x != 0) ++cnt;
		if (x > max_val) {
			max_val = x;
			max_pos = j;
			max_cnt = cnt; 
		}
	}
}
```

最后输出时，需要注意最大值自身是否有被统计到「个数」中。

## 视频讲解

![](bilibili:BV1Pp4y1f7fm?page=5)


---


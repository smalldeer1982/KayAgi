# 物理实验 (easy)

## 题目背景

莲子为了完善她的论文，决定研究一些物体的物理性质。由于工作实在是太多，她邀请你帮忙完成其中的一个小实验。

## 题目描述

**这是该题的简单版本，两个版本之间的区别在于小球需要满足的条件不同。该题的满分为 50 分。**

莲子有一个初始在数轴 $0$ 点并向数轴正方向移动的小球。她在数轴的 $1$ 到 $n$ 这 $n$ 个点上设置了装置，当小球经过点 $i$ 时，她可以花费 $a_i$ 的代价让其改变移动方向（从数轴正方向切换为负方向，或者相反）。

莲子有 $m$ 个需要满足的条件，第 $i$ 个条件形如“小球需要从点 $x_i$ 移动到点 $y_i$ 至少一次”，**其中** $x_i$ **大于** $y_i$。更详细的说，该条件即要求小球的移动路径形如 $\ldots \to x_i\to\ldots\to y_i\to\ldots$。

莲子想要知道她至少要花费多少代价才能满足所有条件。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/bu9fbcw9.png)

如图所示给出了两个样例的移动路线。数轴上方的是在每个点转向的代价，下方的是坐标。

#### 样例 \#1

莲子让小球在经过点 $2$ 时反转方向恰好能满足所有条件，总花费代价为 $2$。
#### 样例 \#2

莲子让小球在经过点 $3$ 时反转方向恰好能满足所有条件，总花费代价为 $3$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n,m\le } & \bm{a_i\le} & \bm{x_i,y_i\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 100 & 10 & - &-\cr\hline
2 & 10 & 10^3 & 10^8 & 10^3 & -&1 \cr\hline
3 & 30 & 2\times 10^5 & 10^8 & 2\times 10^5 & -&1,2  \cr\hline
\end{array}
$$

对于所有数据满足：$1\le n,m\le 2\times 10^5$，$1\le a_i\le 10^8$，$1\le y_i< x_i \le n\le 2\times 10^5$。

## 样例 #1

### 输入

```
3 1
1 2 3
2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
5 3
5 2 3 4 5
2 1
3 2
3 1```

### 输出

```
3```

# 题解

## 作者：chen_zhe (赞：13)

easy 版本的结论非常简单，由于所有 $a_i$ 均为正数，容易证明只用进行一次反转是最优的。记 $r=\max\{x\}$，答案即为 $\min_{r\le i\le n} a_i$。

---

## 作者：lutaoquan2012 (赞：5)

## 思路：
因为每一次的条件都是从后面的一个点 $x$ 走向前面的一个点 $y$，所以我们要找到所有条件下最后面的那个点 $ma$，然后从这个点到 $n$ 选取一个反转价值最小的点 $mi$，然后从这个反转价值最小的点反转，再一次性走到 $0$。

## 代码：
```cpp
//
// Created by 55062 on 2024/6/20.
//
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll n, m, a[200010], x, y, mx, mi = 0x3f3f3f3f;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) {
        cin >> x >> y;
        mx = max(mx, x);
    }
    for (int i = mx; i <= n; i++) mi = min(mi, a[i]);
    cout << mi;
    return 0;
}
```

---

## 作者：Furukawa_Nagisa (赞：3)

这道题水水的，不愧是简单版。

题意很好理解，只需找出需求中 $x$ 的最大值再往后寻找最小的 $a[i]$ 输出即可。

具体代码

```c
#include<bits/stdc++.h>//万能头 
using namespace std;
int n,m,k,a[200005],x[200005],y[200005]; 
bool cmp(int a,int b){
	return a>b;
}//快排 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>x[i]>>y[i];
	//输入 
	sort(x+1,x+m+1,cmp);//找出最大的x 
	int ans=1e9;//初始化 
	for(int i=x[1];i<=n;i++){
		ans=min(a[i],ans);//打擂台 找最小值 
	}
	cout<<ans;//输出 
	return 0;//好习惯 
}
```

---

## 作者：Superiority (赞：3)

# 思路
我们要使花费的代价最小的话，首先想到贪心。考虑尽量让小车少回头，所以我们每次都选一个能满足尽量多条件的区间 $l \sim r$，在 $r$ 及后面找到一个回头花费的代价最小的一个点回头。

不难可以发现都只用回头一次就够了，只要找到最大的右端点 $r$ 后，枚举 $r \sim n$ 的点，找到代价最小的点就可以了。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6;
const int INF=1e9;
#define zjj long long
int n,m;
zjj sum=INF;
zjj a[MAXN];
int maxn=-INF;
int main(){
	ios::sync_with_stdio(false);
    cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		maxn=max(maxn,x);
	}
	for(int i=maxn;i<=n;i++){
        sum=min(sum,a[i]);
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：王逸辰 (赞：1)

# P10606 物理实验 (easy)
## 思路
贪心，因为只用一次反转是最优的，所以先取最大的经过点，最后枚举最大的经过点右边的反转点的最小值即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200001];
struct node {
	int x,y;
}b[200001];
int main(){
	int n,m,ans=1000000000,maxx=-1000000;
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=m; i++)
		cin>>b[i].x>>b[i].y,maxx=max(b[i].x,maxx);
	for(int i=maxx; i<=n; i++)
		ans=min(ans,a[i]);
	cout<<ans;
	return 0;
}
``````

---

## 作者：zhangxiaohan007 (赞：1)

## 思路
这道题可比困难版简单多了。我们只需要统计出最大需要途经的点 $x$ 并找到在它或他后面能转向且权值最小的点，并在那里完成转向即可。因为 $x$ 总是大于 $y$ 的，所以这样就能经过所有的 $x$ 和 $y$ 了。

## 代码
```cpp
#include<bits/stdc++.h>
#define inf 2e8
using namespace std;
int n,m,a[200005],b[200005],tot=1,mx,my=inf,minn=inf;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		mx=max(mx,x);
		my=min(my,y);
	}
	for(int i=mx;i<=n;i++)minn=min(minn,a[i]);
	cout<<minn;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

简单题，秒了。

题目中的 $x_i$ 按大到小排序，但是 $y_i$ 不用理，接下来从 $x_i$ 的最大值开始到 $n$ 找最大 $a_i$ 即可。

代码：
```
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
const int maxn=2e5+10,maxm=1e5+10,mod=1e9+7;
LL k[maxn],b[maxn],c[maxn],s1,s2,t1=0x3f3f3f3f;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>k[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i]>>c[i];
		s1=max(s1,b[i]);
		s2=min(s2,c[i]);
	}
	for(int i=s1;i<=n;i++){
		t1=min(t1,k[i]);
	}
	cout<<t1;
	return 0;
}
```

---

## 作者：juruo5e59 (赞：0)

### 思路：
题目中说的很花，要走过 $m$ 个 $x_i$ 到 $y_i$ 的路线，根据贪心思想，掉头的次数越小越好，所以只需要从原点向右走足够的距离再返回就能实现代价最小化。

求向右走的最少距离很简单，只需要取 $\max_{1 \le i \le m} x_i$ 就是向右走的最小距离。根据题意，移动不需要花费代价，所以又根据贪心思想，总代价就是在满足题意的最左边的掉头位置到 $n$ 点这个范围内的最小值。换句话说，设 $k=\max_{1 \le i \le m} x_i$，则最小代价为 $\min_{k \le i \le n}a_i$。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[200010];
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
	int maxn = -1e9;
	for (int i = 1; i <= m; i ++) {
		int x, y;
		cin >> x >> y;
		maxn = max(x, maxn);
	}
	int ans = 1e9;
	for (int i = maxn; i <= n; i ++)
		ans = min(ans, a[i]);
	cout << ans;
	return 0;
}
```

---

## 作者：KyleShen1213 (赞：0)

## 题目大意
在一个数轴上，在 $1$ 到 $n$ 这些点上可以使小球转变方向，并会花费对应的代价，要让小球满足 $m$ 个要求，每个要求都是从点 $x$ 走到点 $y$，求最小的代价。
## 解题思路
要使得代价尽量少，就要使转变方向的次数尽量少。因此，我们可以找最大的点 $x$，就在这个点转变一次方向便可以了。

但这还不够，因为这个点对应的代价不一定最小，所以循环得出在这个点之后（包括这个点）最小的代价。
## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,x,y,a[200005],my=-1000000005,ans=1000000005;//初始定义my最小，ans最大 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)  cin>>a[i];//输入 
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;//输入 
		my=max(x,my);//找最大的x 
	}
	for(int i=my;i<=n;i++)  ans=min(ans,a[i]);//找最小的代价 
	cout<<ans<<endl;//输出 
	return 0;
}
```

---

## 作者：xuan_never (赞：0)

## 思路

读题，小车最终肯定要到达最大的 $x_i$，并在其之后掉头回去。既然如此，肯定是可以让小车只掉一次头回去。  
那么，问题就转变成了：找到最大的 $x_i$（以下称 $x_{max}$），求 $x_{max}\le j\le n$ 中 $a_j$ 的最小值。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[200005], x, y, X = 1, ans = 1e8;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	for (int i = 1; i <= m; ++i)
		cin >> x >> y,
		X = max(X, x); // x最大值
	for (int i = X; i <= n; ++i)
		ans = min(ans, a[i]);
	cout << ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

### 思路
其实这是一道贪心题。代价尽可能小，也就是说掉头次数越少越好。也就是说小球可以在最大的 $x_i$ 及其右边掉头，选择最小的点的即可。

注意！最大值一定要开大点，不然只有部分分！
### 上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 200010;
int a[MAX];
int MAXINT = 1e9;
int main() {
	int n,m;
	cin>>n>>m;
	for(int i = 1;i <= n;i++) cin >> a[i];
	int maxx = -MAXINT,minn = MAXINT;
	for(int i = 1;i <= m;i++) {
		int x,y;
		cin>>x>>y;
		maxx = max(x,maxx);
	}
	for(int i = maxx;i <= n;i++) {
  	    minn = min(minn, a[i]);
    }
	cout<<minn;
	return 0;
}
```

---


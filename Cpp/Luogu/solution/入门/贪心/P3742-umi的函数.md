# umi的函数

## 题目背景

umi 找到了一个神秘的函数 $f$。


## 题目描述

这个函数接受两个字符串 $s1,s2$。这些字符串只能由小写字母组成，并且具有相同的长度。这个函数的输出是另一个长度与 $s1,s2$ 相同的字符串 $g$。$g$ 的第 $i$ 个字符等于 $s1$ 的第 $i$ 个字符和 $s2$ 的第 $i$ 个字符的最小值，简单来说，$g_i=min(s1_i,s2_i)$。

例如：$f(\verb!ab!,\verb!ba!)= \verb!aa!$，$f(\verb!nzwzl!,\verb!zizez!)=\verb!niwel!$。

她现在有两个相同长度的只有小写字母的字符串 $x,y$。找出任何一个满足 $f(x,z)=y$ 的字符串 $z$。如果找不到这样的字符串的话，请输出 $-1$。


## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 100$。


## 样例 #1

### 输入

```
2
ab
aa```

### 输出

```
ba```

## 样例 #2

### 输入

```
5
nzwzl
niwel```

### 输出

```
xiyez
```

## 样例 #3

### 输入

```
2
ab
ba
```

### 输出

```
-1```

# 题解

## 作者：菜弟弟在此 (赞：158)

这题比较有有意思的地方就是有多个解。

如果X有任何一个地方小于Z，就找不到解，输出-1，结束。

如果没有，因为Y本身就是Z的一种解，就不用找了，直接输出Z。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{    
    long t,n,i;
    char x[101],z[101];
    cin>>n; 
    cin>>x; cin>>z; 
    for (i=0;i<n;i++)
        if (x[i] < z[i])
        {
            cout<<-1<<endl;
            return 0;
        }
    cout<<z<<endl;
    return 0;
}
```

---

## 作者：Wichiene (赞：27)

#这个随便输出一个的设定。。。

###1.找一个y使f（x，y）=z，已知x，z，且由题目，z中的每一个字符一定都比x中的小。

###2.故如果z中有一个字符比x中的大，就一定找不到解，可以直接输出-1，结束程序了。

###3.如果没有，那么z本身也可以作为一个y的解，由于输出任意一个，所以那还找啥，直接输出z。

###注：全过程没有y的事儿，不用管y

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n;   
    string x,z;
    cin>>n;
    cin>>x>>z;
    for(int i=0;i<n;i++)
    {
        if(x[i]<z[i])
        {
            cout<<-1;
            return 0;
```
}//如果z中有一个字符比x中的大，就一定找不到解，直接输出-1，结束程序
    }
    cout<<z;//如果没有，那么z本身也可以作为一个y的解,输出z

}

---

## 作者：豌豆射手皮0608 (赞：23)


看了各位大佬的题解，感觉本蒟蒻的算法弱爆了இ௰இ

但弱爆归弱爆，算法还是得讲qwq

首先逐位判断x和y，如果y有一位大于x的那一位，就输出-1；

如果没有，继续逐位判断，如果x与y的同一位相等，就输出最大的'z'，否则输出y的那一位；

附上C++蒟蒻版AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,s1,s2;
int n;
int main()
{
    cin>>n;
    cin>>s1;
    cin>>s2;
    for(int i=0;i<n;i++)
    {
        if(s1[i]<s2[i])//判断是否有可能解
        {
            cout<<-1<<endl;
            return 0;
        }
    }
    for(int i=0;i<n;i++)
    {
        if(s1[i]==s2[i])//如果s1与s2同一位相等，则输出'z'
        {
            s+='z';
        }
        else s+=s2[i];//否则输出s2的那一位
    }
    cout<<s<<endl;
    return 0;
}
```
最后附上判断你的答案是否正确的C++代码（本蒟蒻亲自编，望大佬轻喷） （只要把输入数据和你的答案一起输进去就行了，它会告诉你Yes或No）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s1,s2,s3,s; 
int main()
{
    cin>>n;
    cin>>s1>>s3>>s2;
    if(s2=="-1")
    {
        for(int i=0;i<n;i++)
        {
            if(s1[i]<s3[i])
            {
                cout<<"Yes"<<endl;
                return 0;
            }
        }
        cout<<"No"<<endl;
        return 0;
    }
    for(int i=0;i<n;i++)
    {
        s+=min(s1[i],s2[i]);
    }
    if(s!=s3)
    cout<<"No"<<endl;
    else cout<<"Yes"<<endl;
    return 0;
}
```

---

## 作者：封弊者—桐子 (赞：13)

这道题其实很简单，只要一点点技巧就可以了（只需要找z，不需要去找y，枚举到合适的输出就可以了）：

```cpp
var x,z:string;
    n,i:longint;
begin
  readln(n);//读入部分
  readln(x);
  readln(z);
  for i:=1 to n do//开始枚举
  if x[i]<z[i] then//判断是否有解
  begin
    writeln(-1);//若无解则直接输出-1然后退出
    halt;
  end;
  writeln(z);//如果执行到这里（没有退出）即说明有合适的解，输出即可
end.
```

---

## 作者：SovietPower✨ (赞：11)

入门的字符串模拟题吧

关键是y[i]=min(x[i],z[i]),y[i]<=x[i]&&y[i]<=z[i];

大体思路：

输入字符串后，逐个枚举x与y的字符i，若

1. x[i]>y[i]，则z[i]必须为y[i]；

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n;//z[103] 或用数组来存储答案 
char x[103],y[103],ans[103];
int main()
{
    scanf("%d",&n);
    scanf("%s",x);
    scanf("%s",y);
    for(int i=0;i<n;i++)
    {
        //int wordx=x[i]-'a',wordy=x[i]-'a';或用数字来比较
        if(x[i]>y[i])//wordx>wordy
          ans[i]=y[i];//z[i]=y[i]-'a';
        else
          if(x[i]==y[i])//wordx==wordy
            ans[i]=x[i]+1;//z[i]=x[i]-'a';
        else
          if(x[i]<y[i])//wordx<wordy
          {
              printf("-1");
              return 0;
          }
    }
    printf("%s",ans);
    //for(int i=0;i<n;i++)
      //printf("%c",char(ans+'a'));
    return 0;
}
2. x[i]==y[i]，则z[i]可以为任意>=x[i]的字符；

3. x[i]<y[i]，则与答案不符，y[i]应该<=x[i]，直接输出"-1"，结束程序；

```

---

## 作者：Ace_Radom (赞：5)

所以说，做题前先看看标签

**Special Judge**

再看看题目就会发现：

## 这题没有标准答案！

看有些发题解的人没讲全，那我来补一补

## 首先，为什么这题是多解题

这个事实几乎所有直接输y的同学都说了，没说的是少部分

题目描述中讲了：

	找出任何一个满足 f(x,z)=y 的字符串 z。如果找不到这样的字符串的话，请输出-1。
    
其实已经可以看出不止一个解了。

再看：

	g[i]=min(s1[i],s2[i])
    
这里s2是未知的，告诉了你g。那么，g就不可能比s1小。

这么看来，**s2的每一位可以是对应的s1的那一位到g对应的那一位之间的任意一个字母**

综上，此题没有正确答案。

## 那么，怎么做？

上面讲了：

	s2的每一位可以是对应的s1的那一位到g对应的那一位之间的任意一个字母

既然如此，我们为何不直接输出g呢？

这样既方便，又满足了成立的条件。

另外，也要保证g的任何一位都不比s1小。否则，就输出“-1”

这个思路，也就是大多数dalao的常规思路。

代码：

```
#include<bits/stdc++.h>
using namespace std;
string x,y;
int main(){
	int n;
	cin >> n;
	cin >> x;
	cin >> y;
	for ( int i = 0 ; i <= n ; i++ )  //这里就是把两个字符串比较一下大小，看有没有结果
	{
		if ( x[i] < y[i] )  //不符合条件
		{
			cout << "-1" << endl;
			return 0;
		}
	}
	cout << y;  //x的任何一位都比y大，这么y就是答案
	return 0;
}
```

但另外还有一种做法，可以说是常规思路上的简化版，更容易想到，但更烦。

基本思路就是在判断出有结果后，再生成一个答案字符串。这个答案字符串是在x和y两个字符串中提取出来的。

这个程序我也写过，但只有36分，就不贴出来了。

这个思路的具体解析可以看一下[这位大佬的博客](https://www.luogu.org/blog/wdssp0608/solution-3742)

---

## 作者：tmp27 (赞：3)

这是一道典型的字符串操作题（相信大家都能读懂题目）。      
如果$x$中有一个字母比$y$的要小,那么$f(x,z)!=y$，就输出$-1$   
否则如果$x$中的字母和$y$中的一模一样。那么$z$中的字符就随便啦！^-^       
如果$x$中有一个字母比$y$的要大，只要保证$z$中的字母$≤y$中的就行了。     
我们来看一下代码：
```
// luogu-judger-enable-o2//开不开o2随便
#include<iostream>
#include<cmath>
#include<string>//头文件
using namespace std;//空间命名
int n,i;//定义n,i整形变量
string s,a,b;//定义s,a,b字符串
bool flag;//定义
int main()
{
	cin>>n; cin>>a>>b;//读入
	for(int i=0;i<n;i++)//循环遍历两个字符串。
	{
		if(a[i]<b[i]) flag=true;//如果x中有一个字母比y的要小,那么f(x,z)!=y,flag标记。
		else{
			if(a[i]==b[i]) s+=char(b[i]+1);//否则如果x中的字母和y中的一模一样。那么z中的字符就随便。
			else s+=b[i];}//如果x中有一个字母比y的要大，只要保证z中的字母≤y中的就行了。     
	}
	if(flag) cout<<-1<<endl;//输出-1。
	else cout<<s<<endl;//否则就输出答案。
	return 0;//结束
}
```
今年第一次发题解，求通过！

---

## 作者：pinebuaa (赞：2)

这道题有趣的地方应该就在于如果可以找到符合条件的字符串，会有不止一个字符串符合条件。思路其实比较简单，将给出的字符串从头一个一个比较。在同一位置，如果出现前者字符小于后者，就一定不会有符合条件的字符串啦~ 另外字符串题千万不能忘写\0

```cpp
#include<stdio.h>
int main()
{
    int i,n;
    char a[100],b[100],c[100];
    scanf("%d",&n);
    scanf("%s",a);
    scanf("%s",b);
    for(i=0;i<n;i++){
        if(a[i]==b[i]) c[i]='z';
        if(a[i]>b[i]) c[i]=b[i];
        if(a[i]<b[i]) break;
    }
    if(i==n){
        c[i]='\0';
        printf("%s",c);
    }
    else printf("-1");
    return 0;
}
```

---

## 作者：dblark (赞：2)

看到楼上用Pascal的全部在找y。


但是这不需要！因为如果成立的话z就是一组解。


附上代码：


```cpp
{P3742}
var
x,z:string;
n,i:longint;
begin
readln(n);
readln(x);
readln(z);
for i:=1 to n do
 if x[i]<z[i] then//如果x<z
 begin;
 writeln(-1);//就over了
 halt;
 end;
writeln(z);//z就是一个解，不用求解
end.
```

---

## 作者：optimize_3 (赞：1)

# 暴力+打表
这道题本来想法是这样的:
```
有s1,s2和数组k.
把s1[0],s1[1],s1[2]...s1[n]的Ascii码连在一起,称为新的s1.
把s2[0],s2[1],s2[2]...s2[n]的Ascii码连在一起,称为新的s2.
k[s1][s2]就是正确答案.
但是题目里的数据范围是这样的"...n<=100...".
......
也就是说,k的上标大概是k[10^100][10^100].
......
算了.
```

~~但是我没有其他思路呢！楼上那些解法都看不懂~~

于是我又想出了一个好(馊)主意:
```
定义s3和ans.
i从0到n-1枚举.
j从1到26枚举.(知道方法了吧)
如果成立,
把ans连上j.
最后输出.
```
首先需要一个char数组[letters](https://fanyi.baidu.com/translate?aldtype=16047&query=&keyfrom=baidu&smartresult=dict&lang=auto2zh&decrypt_suc=1#zh/en/%E5%AD%97%E6%AF%8D).

内容怎么生成呢?(不知道letters是什么的点上面蓝蓝的东西)

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a='a';
	for(char i='a';i<='y';i++)
	{
		cout<<"'"<<i<<"',";
	}
	cout<<"'z'";
	return 0;
}

```
得到char letters[27]={'a','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};

#### 有了这个就好做了,AC代码(我就知道你们在等这个)
```cpp
#include<bits/stdc++.h>
using namespace std;
char letters[27]={'a','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
int leng;    //不要管leng,可以用*.size()测长度 
bool k;
string s1,s2,s3,ans;
int main()
{
	cin>>leng>>s1>>s2;
	for(int i=0;i<s1.size();i++)
	{
		k=false;
		for(int j=1;j<=26;j++)
		{
			if(min(s1[i],letters[j])==s2[i])
			//照题意判断
			{
				k=true;
				ans+=min(s1[i],letters[j]);
  				//ans是全局变量,初值为空可以放心用
				break;
  				//一寸光阴一寸金
			}
		}
		if(!k)
  		//找不到满足条件的
		{
			cout<<-1;
			return 0;
  			//别忘记
		}
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：EricZeng (赞：1)

```cpp
//这题还挺简单的（但还不至于说水）
//别用array做，用string或char做更好
//我是用string做的
//对于回求f(x,y)中的z的人来说无非反过来做而已
var n,i:longint;
    x,y,s:string;
begin
  readln(n);
  readln(x);
  readln(y);//读入完成
  for i:=1 to n do begin
    if x[i]<y[i] then begin
      writeln(-1);//找不到就输出（-1）
      halt;
    end;
    if x[i]>y[i] then s:=s+y[i]
    else s:=s+'z';//加上
  end;
  writeln(s);//如果找得到就输出
end.
//模拟就能完成，简单吧？
```

---

## 作者：Mine_King (赞：1)

这道题虽时入门难度，但还是有坑的。不要以为标签是字符串就用字符串做！这题完全可以用char。根据题意，可以得出：如果yi<=xi，则zi可以是yi；否则，无解。
（重点来了）所以，输入字符型的x[]和y[],对x和y的各位进行比较，如果yi<=xi，zi=yi，否则，输出“-1”，并return。
具体代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int n,i;
char s1[105],s2[105],s3[105];
int main()
{
    cin>>n;//也可以用scanf和printf
    for(i=1;i<=n;i++) cin>>s1[i];
    for(i=1;i<=n;i++) cin>>s3[i];
    for(i=1;i<=n;i++)
     if(s3[i]<=s1[i]) s2[i]=s3[i];
     else{
         cout<<"-1";
         return 0;
     }
    for(i=1;i<=n;i++) cout<<s2[i];
    return 0;
}
```
本蒟蒻第一次写题解，请多多包含！

---

## 作者：ironwheel (赞：1)

interesting……

符合条件的字符串会有不止一个，所以……就很有趣了……

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main(){
    int n;
    cin>>n;
    string x,z,y="";//定义字符串 
    cin>>x>>z;
    for(int i=0;i<n;i++){//循环 
        if(x[i]<z[i]){cout<<"-1";return 0;}//如果目标字符串z中的字母比字符串x同一位置的字母小，则输出-1 
        if(x[i]==z[i]){y+='z';}//如果目标字符串z[i]==x[i]，说明y[i]比x[i]大，将y[i]置z 
        else y+=z[i];//否则，x[i]>z[i].说明y[i]=z[i]，将z[i]赋给y[i] 
    }
    cout<<y;//输出 
}
```

---

## 作者：peiyangsong (赞：0)

# P3742 umi的函数 #
## 题目描述 ##


这个函数接受两个字符串 s1,s2。这些字符串只能由小写字母组成，并且具有相同的长度。这个函数的输出是另一个长度与 s1,s2 相同的字符串 g。g 的第 i 个字符等于 s1 的第i 个字符和 s2 的第 i 个字符的最小值，简单来说，g[i]=min(s1[i],s2[i])。

例如：f("ab","ba")= "aa", f("nzwzl","zizez")="niwel".

她现在有两个相同长度的只有小写字母的字符串 x,y。找出任何一个满足 f(x,z)=y 的字符串 z。

如果找不到这样的字符串的话，请输出-1。

## 输入输出格式 ##
### 输入格式 ###
第一行给出以下两个字符串的长度 n。

第二行给出一个字符串 x。

第三行给出一个字符串 y。

### 输出格式 ###
第一行输出一个字符串，代表你找到的符合条件的字符串。

找不到的话，请输出-1。

### 输入输出样例 ###
输入样例#1：

2

ab

aa

输出样例#1：

ba

输入样例#2：

5

nzwzl

niwel

输出样例#2：

xiyez

输入样例#3：

2


ab

ba

输出样例#3：

-1

## 数据范围 ##
对于 100%的数据，1<=n<=100。

## 程序 ##

    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    const int N=11000;
    
    int n;
    
    //如题 min（x,z）=y 
    char x[N],y[N],z[N];
    
    int main(){
    	
    	//读入 
    	scanf("%d",&n);
    	scanf("\n");
    	for(int i=1;i<=n;i++){
    		
    		scanf("%c",&x[i]);
    		
    	}
    	scanf("\n");
    	for(int i=1;i<=n;i++){
    		
    		scanf("%c",&y[i]);
    		
    	}
    	
    	//循环 
    	for(int i=1;i<=n;i++){
    		
    		//若x中某位小于y中对应位，输出-1；否则有很多种情况，可以求简，直接使z=y即可 
    		if(x[i]<y[i]){
    			
    			printf("-1");
    			
    			//直接退出程序 
    			return 0;
    			
    		}else{
    			
    			z[i]=y[i];
    			
    		}
    		
    	}
    	
    	//输出z 
    	for(int i=1;i<=n;++i)  printf("%c",z[i]);
    	
    	return 0;
    	
    } 

## 算法 ##

1. 生成函数
2. 模拟  字符串


## 注意 ##

若x中某位小于y中对应位，**输出-1**；否则有很多种情况，可以直接**使z=y**，极大地简化了程序。

---

## 作者：haobo8 (赞：0)

```cpp
#include <iostream>
using namespace std;
int n;//字符串的长度
string x;//z为答案
char y[105];//可以一个一个字符输入
int main()
{
    cin>>n;
    cin>>x;
    for(int i=0;i<n;i++)
    {
        cin>>y[i];
        if(y[i]>x[i])//已经有比结果小的
        {
            cout<<-1<<endl;
            return 0;
        }
    }
    cout<<y<<endl;//它本身就是一种答案
    return 0;
}
```

---

## 作者：Arvin2018 (赞：0)

晕死……刚提交完一个题解就想到了一个更简单的方法

```cpp
#include <iostream>
using namespace std;
int main(){
	
	int n;
	char x[101];
	char y[101];
	cin>>n;
    //输入开始
	for(int i=0;i<n;i++){
		cin>>x[i];
	}
	for(int i=0;i<n;i++){
		cin>>y[i];
	}//输入结束
	for(int i=0;i<n;i++){
		if(x[i]<y[i]){ //由题目得知，需要取较小的字符，所以如果结果（y）比输入（x）大，那么z就是不存在的，可以直接输出-1
			cout<<-1;
			return 0;
		}
	}
	for(int i=0;i<n;i++){ //如果无以上情况存在，我们可以直接输出（y）因为y本来就是较小的
	    cout<<y[i];
	}
    return 0;
}
```

---

## 作者：豌豆射手皮0608 (赞：0)

看了各位大佬的题解，感觉本蒟蒻的算法弱爆了இ௰இ

但弱爆归弱爆，算法还是得讲qwq

首先逐位判断x和y，如果y有一位大于x的那一位，就输出-1；

如果没有，继续逐位判断，如果x与y的同一位相等，就输出最大的'z'，否则输出y的那一位；

附上C++蒟蒻版AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,s1,s2;
int n;
int main()
{
	cin>>n;
	cin>>s1;
	cin>>s2;
	for(int i=0;i<n;i++)
	{
		if(s1[i]<s2[i])//判断是否有可能解
		{
			cout<<-1<<endl;
			return 0;
		}
	}
	for(int i=0;i<n;i++)
	{
		if(s1[i]==s2[i])//如果s1与s2同一位相等，则输出'z'
		{
			s+='z';
		}
		else s+=s2[i];//否则输出s2的那一位
	}
	cout<<s<<endl;
	return 0;
}

```
最后附上判断你的答案是否正确的C++代码（本蒟蒻亲自编，望大佬轻喷）
（只要把输入数据和你的答案一起输进去就行了，它会告诉你Yes或No）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s1,s2,s3,s; 
int main()
{
	cin>>n;
	cin>>s1>>s3>>s2;
	if(s2=="-1")
	{
		for(int i=0;i<n;i++)
		{
			if(s1[i]<s3[i])
			{
				cout<<"Yes"<<endl;
				return 0;
			}
		}
		cout<<"No"<<endl;
		return 0;
	}
	for(int i=0;i<n;i++)
	{
		s+=min(s1[i],s2[i]);
	}
	if(s!=s3)
	cout<<"No"<<endl;
	else cout<<"Yes"<<endl;
	return 0;
}

```

---

## 作者：xlous (赞：0)

这题其实就是比较两个字符串，如果字符串y中有字符比字符串x中的字符大，这个肯定就找不到字符串z了，如果y中的字符都小于等于x中的字符，y本身就可以作为z的其中一个。




```cpp
#include <cstdio>
#include <cstring>
using namespace std;//我用的是C/C++混合的，所以习惯这样写
const int maxn = 100 + 10;//这些写法都是个人习惯
char s1[maxn], s2[maxn];
int n;
int main()
{
    scanf("%d", &n);
    scanf("%s", s1);//输入字符串x
    scanf("%s", s2);//输入字符串y
   //比较两个字符串，如果y中有小于x中的同一位置的字符，直接输出-1
    for(int i = 0; i < n; i++)
        if(s1[i] < s2[i])
        {
            printf("-1\n");
            return 0;
        }
    printf("%s\n", s2);//如果没问题的，直接把y作为答案输出
    return 0;
}

```

---

## 作者：cxq2002 (赞：0)

# 注意：随意输出一个z

so，读入n和x，y，andthen

for (int i=0;i<n;i++)

compare  x(i)和y(i)

if   x(i)<y(i)

输出“-1”并return 0

**上代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n;
    cin>>n;
    string a,b;
    cin>>a>>b;
    for(int i=0;i<n;i++)
    {
        if(a[i]<b[i])
        {
            cout<<-1;
            return 0;
    }
    }
    cout<<b;
}
```

---

## 作者：重力做功 (赞：0)

### 比较水吧......

想法是贪心，先判断输出-1的情况（即对于任何一个位置的字符，前一个字符串<后一个字符串）

如果前面的字符>后一个字符，那么就说明我补的字符串应该更小并含有第二个字符串的字符，否则就贪心地用“z”补就行了

贴代码（P）

```pascal
var
  n,i:longint;
  s1,s2,s:string;
begin
  readln(n);readln(s1);readln(s2);
  for i:=1 to n do
   begin
     if s1[i]<s2[i] then begin writeln(-1);halt;end;//判断结束
     if s1[i]>s2[i] then s:=s+s2[i] else s:=s+'z';//判断要补z或按s2补
   end;
  writeln(s);//输出然后就没了啊啊啊所以说水嘛
end.
```

---

## 作者：不争不闹 (赞：0)

这个题题目说：随意输出一个z

所以，我们完全可以先读入n和x，y，之后

for 0 to x-1

比较x【i】和y【i】

如果y【i】>x【i】那么直接输出“-1”并return 0就好了。

其他情况就让z【i】=y【i】

这样写虽然过不了样例，但会A的，只因为：随意输出一个z

代码如下


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
using namespace std;
int n;
string x,y,z;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    cin>>x>>y;
    for(int i=0;i<n;++i)
    {
        if(y[i]>x[i])
        {
            cout<<"-1";
            return 0;
        }
        /*if(y[i]==x[i])
            z[i]=x[i];*/
        else    z[i]=y[i];
    }
    for(int i=0;i<n;++i)
        cout<<z[i];
    return 0;
}
```

---

## 作者：pantw (赞：0)

今天突然翻出了这个我从cf搬运过来的题emmm

首先这题需要通过x和y反求z。没看清的话就挂掉咯。

然后这题有SPJ，输出任意一个解都是可以的。

经过思考，我们可以知道，假如x中有字符比对应的y串中的字符小，则一定没有解。（想一想，为什么）

否则，我们直接取y作为答案即可。

因为在有解的情况下，x中每个字符都大于对应的y串字符。

这样一来，对应位取min的结果一定是y串本身，满足条件。


贴个测试用的标程


C++ Version:

```cpp
#include<cstdio>
#include<cstring>
#define maxn 105
char x[maxn];
char y[maxn];
int main() {
    int n;
    scanf("%d", &n);
    scanf("%s%s", x, y);
    for(int i = 0; i < n; i++) {
        if(x[i] < y[i]) {
            puts("-1");
            return 0;
        }
    }
    printf("%s",y);
    return 0;
}
```

C Version:

```c
i,n;char x[105],y[105];main(){scanf("%d%s%s",&n,x,y);for(;i<n;i++)if(x[i]<y[i])return puts("-1"),0;printf("%s",y);}
```

---

## 作者：whxyx2001 (赞：0)

##奇妙的方法

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    string s1,s2;
    int a[1009],b[1009];
    int sum,i;
    cin>>sum;
    cin>>s1;
    cin>>s2;
    char s3[sum];
    for(i=0;i<=sum-1;i++)    //字符串全部转化为数组
    {
        a[i]=s1[i];
        b[i]=s2[i];
    }
    for(i=0;i<=sum-1;i++)
    {
        if(min(a[i],b[i])!=b[i]) //若是x字符串的某位比y的要小，则不存在z
        {
            cout<<"-1"; //z不存在输出-1并结束程序
           return 0;
        }
        else //存在z时...
        {
           if(min(a[i],b[i])==a[i]) s3[i]='z';    //若x字符串的一位最小时，z字符串要最大（就是‘z’）
           else s3[i]=b[i];  //否则z字符串的一位要与y字符串相同，即为最小
        }
    }
    for(i=0;i<=sum-1;i++)
    cout<<s3[i];   //输出z字符串
}
```

---

## 作者：Leelzh (赞：0)

//看到这个题本想着水一下，结果发现还是考验人的细心啊，粗心的我过了好几次才能a掉；

//首先是没看到是x，z去求y，反向求，得考虑要是a[i]一定大于等于b[i]才可以的；

```cpp
//所以两个数组够用；
#include<iostream>
#include<cstdio>
using namespace std;
char a[101],b[101];
int main()
{
    int n,ok;
    scanf("%d\n",&n);
    gets(a);
    gets(b);
    for(int i=1;i<=n;i++)
        if(a[i]<b[i])    ok=1;//循环检查一遍时候b[i]都小于等于a[i]；然后要是有特殊情况就ok标记为1；
    for(int i=0;i<n;i++)
    if(ok){    
        printf("-1");
        break;
    }
    else
        printf("%c",b[i]);
    return 0;
}
```

---

## 作者：Explorelore (赞：0)

这一题不算难，**最主要审清题z=min(x,y)求的是y**.

我的方法比较简单，希望能帮助到大家

就是判断大小

**x>z,-1;x<z,y=z;**

注：要开z数组，不能省，不然之前判断又输出，-1结果有问题

```cpp
#include<stdio.h>
main()
{
    int n,i;
    char x[101],z[101],y[101];
    scanf("%d%s%s",&n,x,z);
    for(i=0;i<n;i++)
    {  if(x[i]>=z[i])
     y[i]=z[i];
      else
      {printf("%d",-1);return 0;}
     }
     for(i=0;i<n;i++)
     printf("%c",y[i]);
   return 0;
}
```

---

## 作者：封禁用户 (赞：0)

这题其实很简单

想通了就会发现：1.当y的一项大于x的一项是就要输出-1；

2.不输出-1的情况下，因为题目支持多个答案，所以可以直接输出字符串y；

代码
```cpp
#include<cctype>
#include<cstdio>
#include<iostream>
#include<iomanip>
#include<cmath>
#include<algorithm>
#include<string> 
using namespace std;
int main()
{
    string x,y;
    int i,leng;//leng：字符串长度
    cin>>leng;
    cin>>x>>y;
    for( i=0;i<leng;++i)
        if(y[i]>x[i])
        {
            cout<<-1;
            return 0;
        }
    cout<<y;
    return 0;
}
```

---


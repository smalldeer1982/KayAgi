# [Cnoi2020] 子弦

## 题目描述

Cirno 有一个字符串 $\texttt{S}$，并希望你能求出 $\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。

## 说明/提示

### 数据范围与约定

对于 $100\%$ 的数据保证: $0< |\texttt{S}| \le 10^7$，$\texttt{S}_x\in[\texttt{a},\texttt{z}]$。

#### 子任务「本题采用捆绑测试」
 - Subtask1（$40\%$）：$|\texttt{S}| \le 100$。
 - Subtask2（$40\%$）：$|\texttt{S}| \le 10^5$。
 - Subtask3（$20\%$）：无特殊限制。

### 名词解释
 - **子串**：字符串中任意个连续的字符组成的子序列称为该串的子串。


## 样例 #1

### 输入

```
abababab```

### 输出

```
4```

# 题解

## 作者：超级玛丽王子 (赞：93)

[或许更好的阅读体验](https://www.luogu.com.cn/blog/LXLDuliu-IAKIOI/jian-dan-tan-xin-p6832-ti-xie)

这道题比赛的时候不小心漏了标签……导致很多人都知道了贪心做法。

第一眼望过去，以为这道题是 DP。DP 没想出来只好暴力枚举子串 KMP。后来看到标签突然灵光一闪，可以按照如下思路贪心：
1. 首先考虑子串长度为 $1$ 的情况。这类子串就是 $\texttt{a-z}$ 的字符。那么出现次数最多的子串就是出现次数最多的字符，简单桶排解决。
2. 接下来考虑子串长度为 $2$ 的情况。这类子串**一定由某一个第一类子串加一个新字符组成**。这意味着**出现次数最多的这类子串出现次数一定不会比出现次数最多的一类字串多。** 可以理解为一个这类子串的第一个字符出现次数不少于这个子串的出现次数。

	例如：字符串 `abababab` 中，`ab` 是一个这类子串。而 `a` 出现的次数一定不会比 `ab` 出现次数少。
3. 以此类推，长度为 $k$ 的子串出现次数一定不比其第一个字符出现次数多。

由此我们就得到了我们的贪心策略：**单个字符的子串中出现次数最多的一定是所有子串中出现次数最多的。**

具体实现很简单，桶排即可。代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[10000005];
int cnt[27];
int mx;
int main(void) {
    scanf("%s",s);
    int slen=strlen(s);
    for(int i=0;i<slen;i++) cnt[s[i]-'a']++;
    for(int i=0;i<26;i++) if(cnt[i]>mx) mx=cnt[i];
    printf("%d",mx);
    return 0;
}
```

当然你也可以边 `getchar` 边判断。

## 完结撒花~ 求赞求互关QAQ

---

## 作者：monstersqwq (赞：17)

#### 题面：

给定一个字符串，求该字符串中出现最多的非空子串的出现次数。

#### 题解：

结论：出现最多的非空子串一定至少有一个是只有单个字母的串。

设有一个出现最多的非空子串的长度大于 $1$，出现了 $n$ 次，那么这个子串中每个字母的出现次数一定不少于 $n$ 次，肯定是出现最多的（之一）。

于是只需要统计在原串中每个字母分别出现了多少次，取最大值即可。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
string s;
int a[30]; 
int ans=0;
int main()
{
	cin>>s;
	for(int i=0;i<s.length();i++)
	{
		a[s[i]-'a']++;
	}
	for(int i=0;i<=25;i++)
	{
		ans=max(ans,a[i]);//统计答案
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：JJA_ (赞：14)

### 题目大意

现在给定一个字符串，求其中重复最多的子字符串。

---
### 大致思路

这道题乍一看，十分唬人。但是我们仔细想想，有这么复杂吗？我们很快可以发现，重复最多的字符串，就是**单个的字符**。

理由很简单，先看看样例，`ababab`，所以重复最多的是`ab`。但是我们可以发现，`a`和`b`同时都重复了 $3$ 遍。

所以我们再看一组数据，`abababa`其中`ab`也是重复了 $3$ 遍，而`a`却重复了 $4$ 遍。

所以，我们可以得出如下结论：

- 如果是一串字符重复最多，那么单个的字符重复次数一样多。

- 如果一串字符重复最多，字符串中的单个字符又多次出现，那么单个的字符重复也是最多。

那么，就回到了我们的推测：重复最多的字符串，就是**单个的字符**。

---
### 代码实现

只用统计出现次数最多的字母即可。

所以，只需开一个长度为26的数组`T`，其中`T[0]`储存`a`的次数，以此类推。

这里说一个技巧，当定义数组时，想要整个数组为 $0$ ，只需要`int T={0};`就可以。这个虽然只是把`T[0]`赋值为 $0$ ，但是后面的数字程序也自动认为是 $0$ 了。

但是注意一点，因为输入有可能很长，所以最好开`long long`。

---
### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T[26]={0};
string str;
signed main()
{
	cin>>str;
	for(int i=0;i<str.size();i++)
	{
		T[str[i]-'a']++;
	}
	sort(T,T+26);
	cout<<T[25];
}
```

望采纳，谢谢~

---

## 作者：一只书虫仔 (赞：6)

#### Description

> 求出一个字符串出现次数最多的非空子串的出现次数。

#### Solution

因为题目没说是连续的，所以不难发现，长度为 $1$ 的字符串即符合要求。

简证：如果一个长度大于 $1$ 的子串 $s$ 是目前找到的最优解，那么他包含的所有长度为 $1$ 的子串也是最优解，甚至会有更优解。

所以很容易就可以得到简单的解法：把所有小写字母个数都打表打到一个数组里，然后取 $\max$。

但是，会 T，这题卡时间。

所以还需要用 getchar，并且在输入的时候就开始统计，getchar 进一个字符串再取出来统计也会 T。

#### Code

```cpp#include <bits/stdc++.h>

using namespace std;

char c;
int times[30];

int main () {
	while ((c = getchar()) != EOF) times[c - 'a' + 1]++; // 重要的一行
	int Max = -1;
	for (int i = 1; i <= 26; i++)
		Max = max(Max, times[i]);
	printf("%d", Max);		
	return 0;
}

```

---

## 作者：chenpengda (赞：5)

容易得知，如果一个串的出现次数为 $n$ ，那么它的非空字串出现次数肯定 $\ge n$ 。

证明：这个串的非空子串在这个串之中，所以每出现一次这个串，必定出现一次这个串的子串。

比如，`ab`的次数最多，但是每一个`ab`里面都有一个`a`，所以`a`的出现次数不会少于`ab`的出现次数。

所以，统计出现次数最多的字母即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],ans=0;//储存出现次数
char c;
int main()
{
	while(cin>>c)
	{
		a[c-'a']++;
	}
	for(int i=0;i<26;i++)
	{
		ans=max(ans,a[i]);
	}
	cout<<ans;
}
```


---

## 作者：rui_er (赞：4)

求一个字符串出现次数最多的非空子串。

---

思路：

容易想到，这个子串肯定要尽量短，一个字母是最优的。

因为假如子串 `ab` 的出现次数为 $k$，那么在这个字串中，`a` 和 `b` 各自分别已经出现了 $k$ 次，因此这两个的出现次数一定不小于 `ab`，甚至可能还要多。

因此题面转化为，求字符串中出现次数最多的字母。我们考虑使用 `map` 进行统计，利用迭代器遍历即可。（比赛时没注意到只有小写字母，因此用了迭代器）

---

代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;

map<char, int> mp;
string s;

int main() {
	cin>>s;
	int l = s.length(); 
	for(int i=0;i<l;i++) ++mp[s[i]];
	int ans = 0;
	for(map<char,int>::iterator iter=mp.begin();iter!=mp.end();++iter) ans = max(ans, iter->second);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：SpectatorX (赞：2)

~~来自一个因上课错过月赛的蒟蒻的痛哭流涕…~~

作为一道签到题，这题其实不难。

我们仔细分析，出现最多的字串必定是单个字符，所以此题就变成了**求出现最多字符的出现次数**。

以下是证明

>证明：假设出现次数最多的字串$S_m$长度大于1，
>
>则任取$S_m$的单字符子串$Ss$，
>
>必有$Ss$出现次数大于等于$S_m$出现次数。
>
>所以出现次数最多的字串中必有单字符串。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
char ch;
int app[27],maxn;
int main()
{
	while(ch=getchar())
    {
        if(ch<'a'||ch>'z') break;
        maxn=max(maxn,++app[(int)ch-'a'+1]);
    }
	printf("%d",maxn);
	return 0;
}
```

---

## 作者：Leasier (赞：1)

我们先来考虑所求字串 $S'$ 的长度 $n$。

当 $n > 1$ 时，$S'$ 一定可以写成一个长度为 $n - 1$ 的字符串 $S''$ 与单个字符 $S'''$ 的组合。设字串 $S$ 的长度为 $\operatorname{cnt}_S$，则 $\operatorname{cnt}_{S''}, \operatorname{cnt}_{S'''} \geq \operatorname{cnt}_{S'}$ 一定成立。

以此类推，所求字串的长度 $n$ 一定为 $1$。

所以，我们只需要先在 map 中统计 $S$ 中的每个字符出现的个数，然后从 `a` 到 `z` 枚举字串，并统计其个数的最大值即可。

代码：
```cpp
#include <iostream>
#include <map>
#include <cstring>

using namespace std;

char s[10000007];
map<char, int> mp;

int main(){
	int len, ans = 0;
	cin >> s;
	len = strlen(s);
	for (int i = 0; i < len; i++){
		mp[s[i]]++;
	}
	for (char i = 'a'; i <= 'z'; i++){
		if (ans < mp[i]) ans = mp[i];
	}
	cout << ans;
	return 0;
}
```

---


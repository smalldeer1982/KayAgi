# [COCI 2018/2019 #3] Pismo

## 题目描述

给定一个包含 $N$ 个整数的数组 $A$。

该数组中一个区间 $[L,R]$ （$L \lt R$）的值定义为 $\max(A[L],A[L+1],\cdots,A[R])-\min(A[L],A[L+1],\cdots,A[R])$。

求该数组中所有区间值的最小值。

## 说明/提示

#### 样例 3 解释

符合题意的区间为 $[1,5]$，该区间的值为 $\max(1,2,1,2,1)-\min(1,2,1,2,1)=2-1=1$，为所有区间中值最小的。

#### 数据规模与规定

对于 $20$ 分的数据，$N \le 100$。

对于 $40$ 分的数据，$N \le 2000$。

对于 $100\%$ 的数据，$2 \le N \le 10^5$，$|A_i| \lt 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T2 Pismo_。**

## 样例 #1

### 输入

```
2
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
5
1 2 1 2 1```

### 输出

```
1```

# 题解

## 作者：tzl_Dedicatus545 (赞：11)

**1.题目分析**

这道题首先可以发现，要让最大减最小最小，其实就是让最大值最大，最小值最小，于是我们考虑贪心，容易发现如下的性质：

$$\max{a_i,a_{i+1}\cdots a_j} \leq \max{a_i,a_{i+1}\cdots a_j,a_{j+1}}$$
$$\min{a_i,a_{i+1}\cdots a_j} \geq \min{a_i,a_{i+1}\cdots a_j,a_{j+1}}$$

所以容易发现，区间长度越短越好，又因为 $l<r$ ，所以区间长度最小为 $2$ 。

**AC Code**

```cpp
//By: Luogu@⚡炭治郎⚡(308854)
#include <bits/stdc++.h>

using namespace std;

int a[100100];
int n;
int ans=0x3f3f3f3f;

int main()
{
	cin>>n;
	
	for(int i=1;i<=n;i++)
		cin>>a[i];
		
	for(int i=1;i<n;i++)
	{
		ans=min(ans,max(a[i],a[i+1])-min(a[i],a[i+1])); 
	} 
	
	cout<<ans;
}

```


---

## 作者：MrCR7 (赞：4)

## 梳理思路

这显然不可能是一道枚举。

肯定有一定的技巧与方法。

经过我~~一个月~~的搜索与探究，终于发现了规律（流泪）。

求所有区间的最小值。

设 $x$ 和 $y$ 两个未知数，代表一个区间内最大和最小两个值。

显然，我们如果要使 $x-y$ 最小，就要使 $x$ 最小，$y$ 也最大。

再进行进一步的推理，可以发现如下规律。

假设 $x$ 是区间 $[L,R]$ 的最大值，$y$ 是区间 $[L,R]$ 的最小值，$xx$ 是区间 $[L,R+1]$ 的最大值，$yy$ 是区间 $[L,R+1]$ 的最小值。

可以得到以下结论：$x \leq xx$，$yy \leq y$。

因此，区间长度为 $2$ 即可。

## Ac Code
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
int a[200003];//定义数组。
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	int ans=2147483647;//先把最小值最大化。
	for(int l=1;l<n;l++){
		int r=l+1;//左右两个端点。
		int now=0;
		now=(max(a[r],a[l])-min(a[r],a[l]));//最大值-最小值。
		if(now<ans) ans=now;//求最小值。
	}
	printf("%d\n",ans);//输出。
	return 0;
}
```
## 总结
这一类的题目，显然有一定的规律。

不然肯定会愉快地超时。

完结撒花✿✿ヽ(°▽°)ノ✿。


---

## 作者：user470883 (赞：3)

## 思路：
贪心。

如何贪心呢？我们需要让其**最小值最大，最大值最小**，而代码里如果想要实现，我们需要关注**区间**。那么就有了两种思路，是让**区间变大**还是让**区间变小**。

* 区间变大

这样最大值是不会变小，甚至变大，最小值不会变得更大，甚至更小。所以，直接过掉。

那么就只有让区间变小了。

* 区间变小

符合题目要求。

**注意**：题目要求 $R$ 必须严格 $>L$，那么就使得区间长度为 $2$ 即可。

## AC CODE:
```
#include <bits/stdc++.h>
using namespace std;

int a[100100],n,ans=999999999;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
    {
		cin >> a[i];
	}	
	for(int i=1;i<n;i++)
	{
		ans=min(ans,max(a[i],a[i+1])-min(a[i],a[i+1])); 
	} 
	cout << ans << endl;
}
```

有问题请尽管私信我哦！


---

## 作者：EuphoricStar (赞：2)

## 思路

显然，我们要让最大值最小，最小值最大。

我们思考，如果区间变长，那么最大值不会变得更小，最小值不会变得更大。

于是让区间长度最短即可。

由于题目要求 $L < R$，因此区间长度为 $2$ 即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))
using namespace std;

int n, a[100100], ans = 0x7fffffff;

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i < n; ++i) {
        ans = min(ans, max(a[i], a[i - 1]) - min(a[i], a[i - 1]));
    }
    printf("%d", ans);
    return 0;
}
```


---

## 作者：hyc1026 (赞：1)

这道题可能偏向思维难度（也没多难），码量较小。

我们发现值最小的时候都是只有两个数的时候，所以直接遍历求最小即可。

AC Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100001];

int main()
{
	int n;
	int ans = INT_MAX; //记录最小值的变量初始时一定要赋一个大数
	cin >> n;
	for(int i=1; i<=n; i++) cin >> a[i];
	for(int i=1;i<n;i++) ans = min(ans,int(abs(a[i]-a[i+1]))); //abs取绝对值，比写一遍min一遍max方便
	cout << ans;
	return 0;
}
```

---

## 作者：yinhy09 (赞：1)

## 思路梳理
这是一道贪心题，贪心策略如下：

最小值一定是两个数的情况，只需遍历枚举每相邻的两个数大减小即可。

贪心策略证明：

不妨设当前已有两个数 $A$ 和 $B$ 了,不妨给定 $A \le B$ 的大小关系，如果此时再将 $C$ 添加进来的话,那么：

当 $C \le A$ 时，最小值变大，舍去。
当 $C \le A$ 或 $B \le C$ 时，最小值不变，舍去。
当 $B \le C$ 时，最小值变大，舍去。

附上图片辅助说明：
![](https://cdn.luogu.com.cn/upload/image_hosting/frmsxu3i.png)

所以，最好不要再添加第三个数，最好情况为两个数时，那么暴力枚举就可以了。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;//A中数字个数
	cin>>n;
	int a[100001];//存储数组a
	int minans=2e9;//给初始最小值赋一个最大值
	int ans;//当前这一次结果
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++)
	{
		ans=max(a[i],a[i+1])-min(a[i],a[i+1]);//计算当前这一次结果
		minans=min(ans,minans);//取小保存
	}
	cout<<minans;
	return 0;
}

```

---

## 作者：_Kouki_ (赞：1)

让最大值最大，最小值最小。   
因为 $ L < R $  。   
所以长度只需要二即可

[AC 记录](https://www.luogu.com.cn/record/70679220)

## Code:
```cpp
#include <bits/stdc++.h>//万能头 
using namespace std;
int n;//数组大小 
int a[100050]; //数组 
int ans=INT_MAX;//答案 
int main() 
{
    scanf("%d",&n);//输入 
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);//输入 
    for(int i=2;i<=n;i++)//开始咯~~ 
	{
		int l=max(a[i],a[i-1]);//上面有将 ; 
		int r=min(a[i],a[i-1]);//长度为2即可。 
        ans=min(ans,l-r);//求最小 
    }
    printf("%d\n",ans);//输出 
    return 0;//完结 
}

```


---


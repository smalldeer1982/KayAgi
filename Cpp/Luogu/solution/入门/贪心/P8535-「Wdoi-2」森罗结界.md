# 「Wdoi-2」森罗结界

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋西行寺幽幽子在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为樱点，散落在幻想乡各处。这一异变被称之为“春雪异变”。

出发前往解决异变的三位主角——博丽灵梦、雾雨魔理沙、十六夜咲夜怀着不同的目的，踏上了寻找异变主谋的征途。在这一过程中，她们发现了一个叫做“森罗结界”的东西。收集齐一定程度的樱点，就会立即开出森罗结界。开出森罗结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

然而，也许是因为世界秩序的 bug，如果森罗结界开得过多，数值显示将会产生问题，原本应该是一个数值的森罗结界信息会被汉字所替代。为了解决这些怪问题，她们找到了你，希望你能帮她们解决这个问题。

## 题目描述

### 简要题意

给定汉字的字符画，输入你能使用的 $\texttt{*}$ 的个数，要求输出一个**最大**的汉字数字（**可以不全部用完**），不考虑“千”、“百”等数量单位。

### 原始题意

森罗结界的信息显示系统可以看作一个宽度为 $7$，长度为无限大的矩形系统，在上面仅仅有两个字符 $\texttt{.}$ 与 $\texttt{*}$。

由于主角组失去了记忆，她们在解决异变的时候开了过多的森罗结界，使得原本应该显示数字的位置变成了汉字。在信息显示系统中，每个汉字（仅包含零、一、二到九）都以点阵字体的形式呈现。

显然，阅读汉字比阅读单纯的数字困难了许多。不过，信息显示系统告诉了主角们在显示系统上有 $n$ 个 $\texttt{*}$。主角们希望能够知道运用**不超过** $n$ 个 $\texttt{*}$ 的情况下，显示系统上能表示的最大数字是多少，来帮助她们解决异变。

为了评测和阅读的方便，您只需输出对应的整数即可。

---

如下分别给出了字符画的图片形式，以及文本形式。同时在下发文件里我们准备了每个数字对应的字符画的文本形式。

![](https://cdn.luogu.com.cn/upload/image_hosting/ocrxxti4.png)

```plain
.......  .......  .......  *******  .......  .......  .......  .......  ..*....  *******
.......  .......  ..***..  *.*.*.*  *******  ...*...  ...*...  ..*.*..  ..*....  *.....*
.......  ..***..  .......  *.*.*.*  ...*...  ...*...  ...*...  ..*.*..  *****..  *.....*
.*****.  .......  .*****.  **...**  .******  .*****.  *******  ..*.*..  ..*.*..  *.....*
.......  .......  .......  *.....*  ...*..*  ..*.*..  ...*...  .*...*.  ..*.*..  *.....*
.......  .*****.  *******  *.....*  *******  .*...*.  ...*..*  *.....*  .*..*.*  *.....*
.......  .......  .......  *******  .......  .......  ...****  .......  *...***  *******
```

## 说明/提示

### 样例解释

对于样例 $1$，显然只能拼出数字一，故输出 $1$ 即可。

对于样例 $2$，可以拼出很多的数字如“一二”、“六”等，但是在这些数字中最大的数字是 $21$，且显然可以发现不存在更大的数字是可以被拼出的了。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{分值}\\\hline
1 & 10 & 5\\\hline
2 & 100 & 15 \\\hline
3 & 10^3 & 20 \\\hline
4 & 10^6 & 60 \\\hline
\end{array}$$

对于全部数据，保证 $5 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
5```

### 输出

```
1```

## 样例 #2

### 输入

```
13```

### 输出

```
21```

# 题解

## 作者：chen_zhe (赞：29)

可以通过观（数）察（数），发现从 $0$ 到 $9$ 的这十个整数所需要的 $\texttt *$ 数量分别为 $24,5,8,15,30,23,11,16,10,18$。

最大的数字自然有着最多的位数，由于 $1$ 所用的 $\texttt *$ 数量最少，因此可以想到多放一些 $1$。例如说，你用 $10$ 个 $\texttt *$，你能写出一个 $8$，也可以写出一个 $11$，那么 $11>8$，自然写 $8$ 是不优的了。

但是当位数相同的情况下，填 $1$ 有时候会吃亏，例如说有 $13$ 个 $\texttt *$，你可以写 $11$，也可以写 $21$，这个时候写 $21$ 是最优的。而且这个时候为了让数字尽可能大，你要把这个大的数字放在首位。

实际上我们会发现只有 $2$ 是要特别考虑的数字，因为其他的数字所需要用的 $\texttt *$ 的数量都大于等于两倍的填 $1$ 所用的 $\texttt *$，也就是写上一个数字 $x$ 所用的 $\texttt *$ 可以被用至少两个 $1$ 取代，在位数上就不优了。

那么在什么时候要将 $2$ 放在首位呢？只要填上这个 $2$ 之后位数不会因此减少即可，也就是当你不断地写 $1$，写到所剩的 $\texttt *$ 个数还有 $8$ 或者 $9$ 个的时候填上 $2$，再将你所写的这一串数字反过来即可。

如果要更为简单的写法，根据上述的分析我们会发现这个填写 $2$ 的策略等价于当 $n \equiv 3,4\pmod 5$ 时，首位填上 $2$ 是最优的。因此根据这个思路可以完成代码如下：

```cpp
#include <iostream>

using namespace std;

int main()
{
	int n;
	cin >> n;
	int cnt1=n/5,cnt2=n%5;
	if (cnt2>=3)
	{
		cnt1--;
		cout << "2";
	}
	for (int i=1;i<=cnt1;i++)
		cout << "1";
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：9)

## 思路

首先先观察，发现表示出 $0$ 到 $9$ 分别需要 $24,5,8,15,30,23,11,16,10,18$ 个星号。若要使数字尽量大，则应该使数字位数尽量多。显然，$1$ 所花费代价最小，所以应尽量多地放 $1$。

但是其中表示出数字 $2$ 的代价为 $8$。$5 \le 8 < 2\times 5$，也就是说当 $n\equiv3,4\pmod{5}$ 时，首位放 $2$ 更优。

## 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
int main(){
	cin>>n;
	ll s=n%5;
	if(s>=3)cout<<2,n-=5;
	for(int i=1;i<=n/5;i++)cout<<1;
	return 0;
}

```


---

## 作者：CQ_Bab (赞：5)

# 思路
这道题其实就是要组成一个尽可能大的数字，既然要大那就位数先要多，那我们就一直在最后输出 $1$ ，因为 $1$ 只要 $5$ 根那就可以。如果 $n$ 除 $5$ 的余数大于 $3$ 就输出 $2$ 最后只需一直输出 $1$ 即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,cnt;
	cin>>n;
	cnt=n%5;
int C=n/5;
	if (cnt>=3){
		C-=1;
		cout<<'2';
	}
	for (int i=1;i<=C;i+=1) cout<<'1';
	return 0;
}
```


---

## 作者：int08 (赞：4)

# 前言
虽然题目很简单，但是简单的题萌新也会更多，我们还是要仔细讲。
# Solution
1、容易发现这 $10$ 个数字分别对应的使用数量为：
```
5,8,15,30,23,11,16,10,18,24
```

2、根据我们小学学习的比较数的大小：最大的数位数肯定是最多的，其他要素都是其次。所以根据贪心算法，无论如何先确保位数最多，那要尽量使用耗费星号最少的数字。

于是我们看上了数字 $1$。

于是这道题结论就出来了：尽可能的使用数字 $1$ 来确保答案的位数最高。

3、但是容易发现，全用数字 $1$，有的时候会剩余一些星号。这一部分信号我们也不能让他们闲~~得蛋疼~~，如果闲着的星号超过 $3$ 个，我们可以把首位的 $1$ 改成 $2$，以达到最大值。

于是这道题就结束力（喜）。

5、总结：

一道适合萌新来练习贪心算法的简单题。~~官方可以考虑把这道题加到入门题单里面去。~~

# AC 代码

```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll n,x,s,i,ans;
int main()
{
    cin>>n;
    if(n%5>=3) cout<<2;
   	else cout<<1;
	for(i=1;i<=n/5-1;i++)
	    cout<<1;
	return 0;
}
```

# The End.

---

## 作者：YH_Eternally (赞：3)

## 思路
我们在数完各个数所对应的 $ * $ 的数量后，发现 $1$ 和 $2$ 所需的 $ * $ 的数量最少，分别为 $5$ 和 $8$。当 $n\bmod5$ $=$ $3$ 或 $4$ 时，就可以填 $2$。而如果需要填 $2$ 的时候，很显然，把 $2$ 放在首位是最优的。那么，代码实现就非常简单了。

## 代码


```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    int n, flag = 0;
    scanf("%d", &n);
    if(n % 5 == 3 || n % 5 == 4) printf("2"), flag = 1; //判断是否可以输出2，如果可以，就标记flag = 1。
    if(flag == 1) n = n / 5 - 1;//如果能，就让输出1的数量-1。
    else n /= 5; //如果不能，就看能输出多少1。
    for(int i = 1; i <= n; i ++) printf("1");
    return 0;
}
```


---


# [信息与未来 2024] 幸运数字

## 题目描述

如果一个正整数的二进制表示中，每个比特（$0$ 或 $1$）的左边或右边都至少有一个相同的比特，Dr. X 就认为它是一个“幸运数字”。例如:

- $(1)_2=(1)_{10}$ 有落单的 $1$，它不是幸运数字。

- $(110111)_2=(55)_{10}$ 有落单的 $0$，它不是幸运数字。

- $(111110011)_2=(499)_{10}$ 是幸运数字。

- $(110011001100)_2=(3276)_{10}$ 是幸运数字。

对于给定的 $a$ 和 $b$，Dr. X 希望你求出 $a, a + 1, a + 2, \dots, b$ 中幸运数字的数量。

## 说明/提示

对于 $100\%$ 的数据,满足 $1 \leq a \leq b \leq 10^6$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
1 100```

### 输出

```
14```

## 样例 #2

### 输入

```
4096 65535```

### 输出

```
1364```

# 题解

## 作者：沉石鱼惊旋 (赞：6)

一个很小朋友的做法是把每个数转二进制字符串或者用数组存下来判断。这里给一个时间复杂度为 $\mathcal O(n\log V)$ 但空间复杂度为 $\mathcal O(1)$ 的写法：使用位运算，通过 `x >> i & 1` 获得 $x$ 在二进制下的第 $i$ 位。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a, b;
int ans;
bool check(int x)
{
    for (int i = 30; i >= 0; i--)
    {
        if ((i < 30 ? (x >> i + 1 & 1) ^ (x >> i & 1) : 1) && (i > 0 ? (x >> i & 1) ^ (x >> i - 1 & 1) : 1))
            return 0;
    }
    return 1;
}
int main()
{
    cin >> a >> b;
    for (int i = a; i <= b; i++)
        ans += check(i);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：_Star_Universe_ (赞：6)

## [题目传送门](https://www.luogu.com.cn/problem/solution/B3978)
### 思路
先输入两个整数 $a$ 和 $b$，然后用 while 循环转换成二进制，存入字符串，这样会使判断比较方便。

然后遍历字符串，如果 $s_i$ 与它前后的字符都不相等，就说明这个字符落单了，不是幸运数字。接下来给出两个核心代码：

### 进制转换
```c
//在这之前有一个循环语句
string s="";
int sa=i;//不能改变遍历的值，所以用另一个变量取代
while(sa>0){
	if(sa%2==0) s+='0';
	else s+='1';
	sa/=2;
}
```

### 判断是否是幸运数字
```c
bool flag=0;
for(int j=0;j<s.size();j++){
  	if(s[j]!=s[j-1]&&s[j]!=s[j+1]){//判断当前字符是否落单
    	flag=0;
    	break;//跳出
    }
}
if(flag) c+=1;//这个变量必须事先定义，用于计数
```
好了，剩下的代码就很简单了，留给大家补充完整。

---

## 作者：_Deer_Peach_ (赞：3)

这道题很简单，直接遍历在这区间中的数是否为幸运数字即可。判断是否为幸运数字可以写一个函数。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
bool check(int x){
	int las=2,cnt=0;//las表示上一个数字是0或1，第一个数要特殊判断；cnt表示0或1的数量。
	while(x){//转2进制过程
		if(las==2){//特殊判断
			las=x%2;//更新
			cnt++;//加一
			x/=2;//转2进制的基本过程
			continue;//跳过下面的判断
		}if(las!=x%2 and cnt==1)return false;//如果当前数与上一个数不同且0或1的数量为1说明出现了单独的数
		if(las==x%2)cnt++;//相同加一
		if(las!=x%2)cnt=1,las=x%2;//不同更新
		x/=2;
	}if(cnt==1)return false;//如果最后的数字数量为1说明最后的数是单独的
	return true;//否则是幸运数字
}
int main(){
	int a,b,ans=0;
	cin>>a>>b;
	for(int i=a;i<=b;i++)if(check(i))ans++;//遍历，如果是幸运数字答案加一
	cout<<ans;
	return 0;
}
```

---

## 作者：Thorongil_Gondor (赞：2)

# 思路
按题意模拟即可。  
先将枚举 $a$ 和 $b$ 之间的值，将其转为二进制。  
随后枚举二进制字符串，若其中一字符与其前和其后都不同，说明有落单，不是幸运数字。若一直没有字符与其前和其后都不同，是幸运数字，答案加 $1$。
# AC Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b,ans,t,len;
string s;
bool check(){
	for(int i=0;i<len;i++){
		if(s[i-1]!=s[i]&&s[i+1]!=s[i])return false;
	}
	return true;
}
signed main(){
	cin>>a>>b;	
	for(int i=a;i<=b;i++){
		s="";
		t=i;
		while(t>0){
			if(t%2==0)s+='0';
			else s+='1';
			t/=2;
		}
		len=s.size();
		for(int j=0;j<=len-1;j++)swap(s[j],s[len-1-j]);
		if(check())ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_luouhgy_ (赞：2)

## 题目大意

找 $a$ 和 $b$ 之间，有几个二进制表示正整数的，每个字符（$0$ 或 $1$）的左边或右边都有一个相同的字符。

## 思路

枚举 $a$ 到 $b$ 的数并将这个数转成二进制，然后枚举每一位，如果某一位与自己前一位和自己后一位都不相同，那这一个数就不是幸运数字，反之则是幸运数字。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,res;
int main(){
	cin>>a>>b;
	for(int i=a;i<=b;i++){
		string s,x;
		int m=i;
		while(m>0){//转二进制 
			if(m%2==0){
				s+='0';
			}else{
				s+='1';
			}
			m/=2;
		}
		for(int j=s.size()-1;j>=0;j--){
			x+=s[j];
		}
		bool flag=true;
		for(int j=0;j<x.size();j++){//遍历每一位 
			if(j==0){
				if(x[j]!=x[j+1]){
					flag=false;
					break;
				}
			}else if(j==x.size()-1){
				if(x[j]!=x[j-1]){
					flag=false;
					break;
				}
			}else{
				if(x[j]!=x[j-1] and x[j]!=x[j+1]){
					flag=false;
					break;
				}
			}
		}
		if(flag){//累加答案 
			res++;
		}
	}
	cout<<res;
	return 0;
}
```

---

## 作者：Phoenix114514 (赞：2)

# B3978 [信息与未来 2024] 幸运数字
## 思路
枚举 $a$ 和 $b$ 之间的值，
把这个数 $i$ 转换成二进制，
再判断若有一个字符与前后都不相同，那这个数就不是幸运数字，否则就是，答案加 1。
### $Code$
```cpp
#include <bits/stdc++.h>
using namespace std;
bool check(int k){
    string s;
    while(k){
        s+=char(48+k%2);
        k/=2;
    }
    reverse(s.begin(),s.end());
    if (s[0]!=s[1])return 0;
    if (s[s.size()-1]!=s[s.size()-2])return 0;
    for (int i=1;i<s.size()-1;i++)if (s[i]!=s[i-1]&&s[i]!=s[i+1])return 0;
    return 1;
}
int ans;
int main(){
    int a,b;
    cin>>a>>b;
    for (int i=a;i<=b;i++)if (check(i))ans++;
    cout<<ans;
    return 0;
}
```

---


# 质数的和与积

## 题目描述

两个质数的和是 $S$，它们的积最大是多少？

## 样例 #1

### 输入

```
50```

### 输出

```
589```

# 题解

## 作者：BotDand (赞：29)

# $\text{Problems}$

两个质数的和是 $S$，它们的积最大是多少？

# $\text{Answer}$

可以考虑先确定一个质数 $x$，则另一个质数为 $(S-x)$。

考虑如何判断质数。

首先要知道什么是质数。

质数是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。（摘自百度百科）

那么可以打出代码：

```cpp
bool check(int n)
{
    for(int i=2;i<=n;++i)//从2枚举到n
        if(n%i==0)//如果有n的因数
          return false;//则不是质数
    return true;//是质数
}
```

但是这样的方法不够优，复杂度为$\Theta (S)$，会超时。

考虑优化复杂度。

当 $S=8$ 时，$S$ 的因子为 $1,2,4,8$，可将 $S$ 的因子分为两类，$1,2$ 和 $4,8$，不难看出前者小于 $\sqrt{S}$，后者大于 $\sqrt{S}$，而通过前者即可算出后者，所以只需枚举前者，而前者小于 $\sqrt{S}$，复杂度降为 $\Theta (\sqrt{S})$。（$\sqrt{S}$ 即为 $S$ 的根号，如 $\sqrt{2}$约为 $1.414$，$\sqrt{3}$ 约为 $1.732$）

但是当 $S=9$ 时呢？

$9$ 的因子为 $1,3,9$，怎么分配？

不妨加一个因子 $3$，即可分为两组：$1,3$ 和 $3,9$，问题解决。

即可打出代码：

```cpp
bool check(int n)
{
    for(int i=2;i*i<=n;++i)//从2枚举到√n
        if(n%i==0)//如果有n的因数
          return false;//则不是质数
    return true;//是质数
}
```

最后枚举其中一个质数即可，时间复杂度 $\Theta (S\sqrt{S})$。

哦对还要特判 $S$ 是否为 $0$ 或 $1$，因为 $0,1$ 不是质数，但循环不会运行，会返回 $\texttt{True}$。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int S;
int ma;
bool check(int n)
{
    if(n<2) return false;//特判0，1
    for(int i=2;i*i<=n;++i)
        if(n%i==0)
            return false;
    return true;
}
int main()
{
    cin>>S;
    for(int i=1;i<=S;++i)
        if(check(i))
            if(check(S-i))
                if(i*(S-i)>ma)//找最大值
                    ma=i*(S-i);
    cout<<ma;
    return 0;
}
```


---

## 作者：可爱的小于 (赞：12)

题意：两个质数的和是 $S$ ，它们的积最大是多少？

根据题意，我们只需要从 $1$ 开始枚举，寻求最大的答案。

其中求出质数的数值范围为： `sqrt(n)`。

注意： $1$ 不是质数。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int s,ma=0;
	cin >> s;
	for(int i=2;i<=s;i++)
	{
		bool q=1;
		int k=s-i;
		for(int j=2;j<=sqrt(i);j++)
			if(i%j==0)
			{
				q=0;
				break;
			}
		for(int j=2;j<=sqrt(k);j++)
			if(k%j==0)
			{
				q=0;
				break;
			}
		if(q)
			ma=max(ma,k*i);
	}
	cout << ma << endl;
	return 0;
}
```


---

## 作者：Dreamweaver (赞：11)

# 前言
这题算是“入门与面试”的题目里偏数学的一道，就来水一篇题解。

# 题意

两个质数的和是 $S$，它们的积最大是多少？

# 分析
根据[基本不等式](https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E4%B8%8D%E7%AD%89%E5%BC%8F/6296924?fr=aladdin)：

$ {a + b} \ge 2 \sqrt {ab} \quad (a>0, b>0)$（当且仅当 $x=y$ 时取等号）

猜测应该是在 $S/2$ 两侧且最靠近 $S/2$ 的两个质数乘积最大。

证明如下：

设其中一组质数为 $a$ 和 $b$，另一组为 $a'$ 和 $b'$，且 $a'<a$，$b<b'$，$ans1=a \times  b$，$ans2=a'\times b'$。

$\because$ $a+b=S$，$a'+b'=S$

$\therefore$	$ans1=ab=a(S-a)=-a^2+Sa$，$ans2=a'b'=a'(S-a')=-a'^2+Sa'$

由函数 $y=-x^2+Sx$ 图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/0j7wvh69.png)

可得：对称轴为 $x=S/2$，函数在 $[0,S/2]$ 上单调递增。

$\because$ $a'<a$

$\therefore$	$-a'^2+Sa'<-a^2+Sa$

$\therefore$	$ans2<ans1$ 

得证。

所以只要线性筛或埃氏筛或直接 $O(\sqrt N)$ 判断，找出最靠近 $S/2$ 的两个质数，输出其乘积即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 10010
#define re register
#define Orz cout<<"stO %王队% Orz"<'\n';
bool vis[maxn];
int pri[maxn],cnt,s;
void pre(int x)
{
	vis[0]=vis[1]=true;
	for(re int i=2;i<=x;++i)
	{
		if(!vis[i])
			pri[++cnt]=i;
		for(re int j=1;j<=cnt&&i*pri[j]<=x;++j)
		{
			vis[i*pri[j]]=true;
			if(i%pri[j]==0)	break;
		}
	}
}//线性筛
int main()
{
	cin>>s;
	pre(s+1);//线性筛预处理
	for(re int i=s/2;i>=2;i--)
		if(!vis[i]&&!vis[s-i])	//找到了
		{
			cout<<i*(s-i);//输出
			break;
		}
	return 0;
}
```



---

## 作者：我送送送送 (赞：6)

题目：要求出两个质数，在它们的和等于 $S$ 的前提下，使它们的乘积最大。

简单的分析一下：

如果 $S$ 为偶数，那么两个和为 $S$ 的数的最大乘积就是:

$$\dfrac{S}{2}\times\dfrac{S}{2}$$

如果 $S$ 为奇数，那么两个和为 $S$ 的数的最大乘积就是：

$$\dfrac{S-1}{2}\times\dfrac{S+1}{2}$$

这样，就可以从中间向外枚举，只要找到两个数，它们的和为 $S$ 且两个数都是质数，就可以直接输出两数的积，然后~~快乐的~~结束程序。

[AC](https://www.luogu.com.cn/record/52536214)代码如下：

```cpp
#include<iostream>
using namespace std;
int ip(int x){//判断质数，注意特判1
    if(x==1)return false;//特判1
    for(int i=2;i*i<=x;i++)if(x%i==0)return false;
    return true;
}
int main(){
    int n;
    cin>>n;
    for(int i=n/2-1;;i++){//注意在循环时要减一
        if(ip(i)&&ip(n-i)){
            cout<<i*(n-i);//输出最大乘积
            return 0;
        }
    }
    return 0;
}
```

这个代码的时间复杂度为 $O(\dfrac{n}{2}\times\sqrt[]{n})$ ，不存在超时，数据最慢4ms解决。


---

## 作者：Biuld (赞：6)

给定和 $n$ ,求最大乘积，那分别作为两个因数的 $i$，$j$ 越接近越好。

所以我们可以从 $n/2$ 开始向 $2$ 递减，那么找到的第一个答案就是最大的乘积，输出即可。

## _Code_:
```
#include<bits/stdc++.h>
using namespace std;
int n;
int zhishu(int a)//判断是否是素数
{
	for(int i=2;i*i<=a;i++)
		if(a%i==0) return 0;
	return 1;
}
int main()
{
	scanf("%d",&n);
	for(int i=n/2;i>=2;i--)
		if(zhishu(i))//如果i是素数
		{
			int j=n-i;
			if(zhishu(j))//如果j也是素数
			{
				printf("%d",i*j);//输出即可 
				return 0;
			}
		}
	printf("0");
	return 0;
}
```

---

## 作者：Hiiragi_Utena (赞：3)

#### P1：理论知识

设两个质数为 $p,q$ ，它们的差越小，即与 $\dfrac{s}{2}$ 越接近，乘积越大。

证明：

不妨设 $p \leq q$，即 $p \le \dfrac{s}{2}$。

$p \times q = p  \times (s-p) = p \times s - p^2 = \dfrac{s^2}{4} - (\dfrac{s^2}{4}- 2 \times \dfrac{s}{2} \times p + p^2) = (\dfrac{s}{2})^2 - (\dfrac{s}{2} - p)^2$

$p$ 增大时，$(\dfrac{s}{2} - p)^2$ 减小，$p \times q$ 增大。此时 $p,q$ 与 $\dfrac{s}{2}$ 更接近。

证毕

#### P2：实现方法

1：**入门选手适合**。从 $\dfrac{s}{2}$ 开始逐一枚举每个每个比它小的数（用循环实现），判断是不是质数。当它与 $s$ 和它的差全是质数时，输出乘积并**结束程序**。时间复杂度 $O(s\sqrt{s})$。

2：发现我们判断的所有质数都在 $1 - s$ 范围内，所以可以先预处理次范围内所有质数（用一个长度为 $s$ 的真假（bool）数组存储），再从 $\dfrac{s}{2}$ 开始枚举（和方法 1 一样）。时间复杂度 $O(s)$。需要用到线性筛质数的知识，不会的话也可以 $O(s\log{s})$ 或 $O(s\sqrt{s})$ 做出来。

3：同样先预处理出质数（同样用 bool 数组）。不按照以上理论，从 1 开始枚举每个数，并记录最大乘积。当一个数与 $s$ 和它的差全为质数时，更新最大乘积。时间复杂度同样为 $O(s)$，但是常数比方法 2 高。

注：以上三种方法均可以通过测试数据。建议选一种自己喜欢的并打一遍代码。~~有兴趣可以都写一遍。~~
#### P3：代码
这里只亮出判断质数和线性筛的代码：

```cpp
//判断质数
bool prime(int a){//质数返回真，否则返回假
	for(int i=2;i*i<=a;++i)if(a%i==0)return false;
	return true;
}
```
```cpp
//线性筛质数
int pri[10005],ans;
int k[10005];//记录最小质因子,k[i]==i:i为质数
 
for(int i=2;i<=s;++i){
	if(!k[i])pri[++ans]=i,k[i]=i;
	for(int j=1;pri[j]<=min(k[i],n/i)&&j<=ans;++j)k[pri[j]*i]=pri[j];
}
```

---

## 作者：MC小萌新 (赞：3)

## 题目分析
这道题也是一道判断素数的题。题目给出了两个质数的和，让我们求出它们的积。由于 $ S $ 最大不超过 $ 10^4 $，所以我们可以直接使用暴力枚举法从大向小枚举第一个素数的值，再判断第二个数是否为素数。找到的第一组数据即为答案，直接输出乘积即可。 

## 代码实现
```cpp
#include <iostream>
using namespace std;
int s,ans;
bool check(int k){
    if(k<2)
        return 0;
    for(int i=2;i*i<=k;++i)
        if(k%i==0)
            return 0;
    return 1;
}
int main(){
    cin>>s;
    for(int i=(s+1)/2;i>=1;--i)
        if(check(i)){
            if(check(s-i)){
                cout<<i*(s-i);
                return 0;
            }
        }
    return 0;
}
```
7/8：修改了一些细节。

---


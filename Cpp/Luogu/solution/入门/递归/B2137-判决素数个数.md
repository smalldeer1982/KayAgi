# 判决素数个数

## 题目描述

求 $X$，$Y$ 之间的素数个数（包括 $X$ 和 $Y$）。

## 样例 #1

### 输入

```
1 100```

### 输出

```
25```

# 题解

## 作者：zhn0707 (赞：84)

### 题目大意

给你两个正整数 $X$ ， $Y$ ，求 $X$ ， $Y$ 之间有多少个素数。（$1 \leq X,Y \leq 10^5$）

### 题目分析 - 基础算法

我们先要了解以下东西：

1. 首先，**素数**和**质数**是一个东西。

2. 我们要知道素数指的是除了 $1$ 和它本身以外不再有其他因数的自然数。

>简单点说，就是如果一个数是素数，那么它除了能整除 $1$ ，它本身之外，不能被其他数整除。

3. 最后，我们需要讨论一些特殊情况，如 $1$ 。（因为 $1$ 是和数）

4. 还有一点，原题中并没有说明 $X$ , $Y$ 谁大谁小，我们还要判断一下。

然后，在了解以上基本内容之后，我们想想看，是不是把 $X$ ， $Y$ 之间的所有数拿出来，然后依次检查，看它能不能满足上面的**第二点**条件。最后别忘了做一些特殊判断。

**但是！！！**

如果你以[这个代码](https://www.luogu.com.cn/paste/m2cg7ztz)提交，就会得到这个结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/xhjm07qb.png)

``（TLE表示超过时间限制）``

为什么呢？可以猜想，可能是我们**要用的时间太长了**。因为题目数据范围直达$ 10^5 $，而我们连套了两个循环。

那么怎么改善呢？

我们再引入一个概念：

> 若一个质数为 $n$ ，则它的两个因数，至少有其中一个 $\le \sqrt n$ 。

得到了这么个概念之后，我们就能缩小很大的范围。

另外，原代码中的一些点可以进一步优化。

**最后，**

个人认为如果你 ``for`` 循环写成 ``for(int j=1;j<=sqrt(i);j++)`` 因为要调出 ``<cmath>`` 头文件，就会麻烦，

因此建议写成 ``for(int j=1;j*j<=i;j++)`` 。

### 代码 - 基础算法（优化）

```cpp
#include<iostream>
using namespace std;
int main(){
	int x,y,sum=0;
	bool jud=true;
	cin>>x>>y;
	if(x<y)swap(x,y);
	for(int i=x;i<=y;i++){//循环枚举所有情况 
		jud=true;
		if(i==1)continue;//判断 1 的特殊情况 ，就跳过本次循环 
		for(int j=2;j*j<=i;j++){//上文已提到的优化。注意是<=。 
			if(i%j==0){
				jud=false;//合数情况,标记false 
				break;//确认是合数，就直接退出，不用循环完 
			}
		}
		if(i==2)jud=true;
		if(jud==true)sum++;//是素数，计数器加一
	}
	cout<<sum;
	return 0;
}

```


------------


如果你觉得这样就够了，那么你可以这篇题解就看到这里。

如果你想积累更多的且更好的**筛选素数代码**，请往下看。


------------
### 题目分析 - 埃氏筛法

回忆一下，如果你还记得，（也许教材不一样，但接着往下看吧）小学的时候学习质数那一章的时候，有一张1~100的自然数表，课本是不是让你把 $2$ 的倍数划掉，然后是 $3$ 的倍数，然后 $5$ 的，$7$ 的……

很明显，这样筛选质数的方法肯定比所有都枚举一遍好得多。

下面放张动图祝你理解：

![](https://images2017.cnblogs.com/blog/1157228/201709/1157228-20170907193558741-1720107409.gif)

如果动图炸了，那看下面的视频吧：

[点我](https://www.bilibili.com/video/BV1Q7411E7Su)

所以，我们首先**假设**所有数都是合数，然后再把 $2$ 的倍数等筛选出去。

然后，为了做这道题，把所有标记出来的素数计量一遍就好了。

### 代码 - 埃氏筛法

```
#include<iostream>
#include<cstring>
using namespace std;
int main(){
    int x,y,sum=0;
    bool is[1000001];
    cin>>x>>y;
    if(x>y)swap(x,y);//小的放前面
    memset(is,true,sizeof(is));//把所有的数都标记为素数。
    is[0]=is[1]=false;//特殊的两个素数
    for(int i=2;i<=y;i++)if(is[i])for(int j=2;j*i<=y;j++)is[j*i]=false;//有一种写法，是j<=y/i，但是C++除法有时候会出现一些玄学错误，建议能不用除法就不用除法
    for(int i=x;i<=y;i++)if(is[i])sum++;//记录
    cout<<sum;
    return 0;
}
```

**P.S.** 事实上，直接在定义的时候定义成 ``bool is[1000001]={}`` ，然后在下面的代码中写成 ``false`` 为素数， ``true`` 为合数即可。但编者为了让读者了解用 ``memset`` 的写法，故多写了 ``memset`` 一步。在“欧拉筛法”中，会写成前者的形式。


------------
那么，还有更**简**的写法吗？

-----------

### 题目分析 - 欧拉筛法

让我们想一下，在筛选的时候，有一些数例如 $6$ ，在循环到 $2$ 、 $3$ 的时候是不是标记了两次？

那么，我们可不可以免掉这些操作，让判断的时候，不会出现重复呢？

事实上，可以。这时就要请出我们今天最后一位角色——欧拉筛法了。

其根本思想就是，**限制限制使得合数在被检验时的方式唯一，不会重复检验**。

由于最后一个比较难理解，所以放上**模板**代码和注释，请读者自行琢磨。

### 模板代码 - 欧拉筛法

```cpp
int prime[1001]={},sum=0,n;//prime:存放素数 sum:素数数量 n:总数量 
bool is[1001]={1,1};
for(int i=2;i<=n;i++){
    if(!flag[i])prime[sum++]=i;//若是素数，加入数组 
    for(int j=0;i*prime[j]<=y;j++){
        flag[i*prime[j]]=true;//100%的合数 
        if(i%prime[j]==0)break;//避免重筛 
    }
}
cout<<sum;
```

-----------------------
感谢你看完。


---

## 作者：可爱的小于 (赞：13)

题意要求我们从给定的数中求出有几个素数。

注意：这题有一个特例：$1$ 不是质数。

关于取数范围，可以用到 `sqrt` 。

`sqrt` 的用法如此格式：`sqrt(你需要填的数)` ，其中 `sqrt(i)` 的值为根号作用。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long x,y,sum=0;
	cin >> x >> y;
	if(x>y)
		swap(x,y);
	for(int i=x;i<=y;i++)
	{
		bool q=1;
		for(int j=2;j<=sqrt(i);j++)
			if(i%j==0)
			{
				q=0;
				break;
			}
		if(q&&i!=1)
			sum++;
	}
	cout << sum << endl;
	return 0;
}
```


---

## 作者：MC小萌新 (赞：7)

## 题目分析
本题是一道判断素数的经典题。对于本题，区间内元素个数及大小都不会超过 $ 10^5 $，所以直接暴力枚举素数即可。

**几个注意：**

- 本题题目中并没有说 $ X $ 和 $ Y $ 谁更大，所以在枚举时需要判断一下起点和终点。

- 注意在枚举素数时关于 $ 1 $ 和 $ 2 $ 的特判。


## 代码实现 

```cpp
#include <iostream>
using namespace std;
int x,y,ans;
bool check(int k){//判断素数，0表示不是质数，1表示是质数
    if(k==1)
        return 0;
    if(k==2)
        return 1;
    for(int i=2;i*i<=k;++i)
        if(k%i==0)//能除尽，说明不是素数
            return 0;
    return 1;
}
int main(){
    cin>>x>>y;
    int s=min(x,y),e=max(x,y);//s:起点 e:终点
    for(int i=s;i<=e;++i)
        if(check(i))
            ++ans;
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：S__X (赞：5)

### 分析
因为题目中没有说明 $X$ 和 $Y$ 谁大，所以要进行特判。之后依次枚举 $X$ 和 $Y$ 之间的每个数，并判断是否是素数，如果是，则素数个数加 $1$，最后输出素数个数。
#### 素数
因数只有 $1$ 和这个数本身的自然数叫做素数，$1$ 不是素数。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool Prime_number(int n){
	if(n<=1){
		return false;
	}
	for(int i=2;i*i<=n;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int x,y,ans=0;
	cin>>x>>y;
	if(x>y) swap(x,y);//特判。
	for(int i=x;i<=y;i++){
		if(Prime_number(i))//判断素数。
			ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：团队官方号 (赞：4)

方法 $1$：依次枚举每个数，判断他是否是质数，如果是，则答案加 $1$，否则不变。比较简单，$38ms$。

## Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
bool isPr(int x)
{
	if (x < 2) return 0;
	for (int i = 2;i <= sqrt(x);i++)
		if (x % i == 0) return 0;
	return 1;
}
int main()
{
	int x,y,cnt = 0;
	cin >> x >> y;
	if (x > y) swap(x,y);
	for (int i = x;i <= y;i++)
		if (isPr(i)) cnt++;
	cout << cnt;
	return 0;
 } 
```
方法 $2$：用筛法筛出一个这个数是否是质数的数组，最后直接在数组里查找这个数是不是质数，$12ms$。

## Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
bool Pr[1000005];
int main()
{
	int x,y,cnt = 0;
	cin >> x >> y;
	if (x > y) swap(x,y);
	memset(Pr,1,sizeof(Pr));
	Pr[1] = Pr[0] = 0;
	for (int i = 2;i <= y;i++)
		if (Pr[i])	
			for (int j = 2;j * i <= y;j++)//筛出合数，将其标记。
				Pr[i * j] = 0;		
	for (int i = x;i <= y;i++)
		if (Pr[i]) cnt++;
	cout << cnt;
	return 0;
 } 
```

---

## 作者：__Cartesian__Tree__ (赞：4)

题目要求求范围内质数个数，可以使用质数表。

先假设所有数都是质数，从 $2$ 开始遍历，$2$ 是质数，所以 $2$ 的倍数都不是质数，设为 false。$3$ 是质数，所以 $3$ 的倍数都不是质数，设为 false。$4$ 不是质数，跳过。以此类推。
```cpp
bool flag[1000010];//质数表
memset(flag, true, sizeof(flag));//假设全是质数
flag[0] = flag[1] = false;//特判
for (int i = 2; i <= y; i++)//y 是终点
{
    if (flag[i])
    {
        for (int j = 2; j <= y / i; j++)
            flag[i * j] = false;
    }
}
```

然后就可以愉快 AC 了，但是还是要注意 $x$ 和 $y$ 的大小关系，可能需要交换。

AC Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
bool flag[1000010];
int main(){
    int x, y;
    scanf("%d%d", &x, &y);
    if (x > y) swap(x, y);
    //开始质数表
    memset(flag, true, sizeof(flag));
    flag[0] = flag[1] = false;
    for (int i = 2; i <= y; i++)
    {
        if (flag[i])
        {
            for (int j = 2; j <= y / i; j++)
                flag[i * j] = false;
        }
    }
    int cnt = 0;//质数个数
    for (int i = x; i <= y; i++){
	    if (flag[i]) cnt++;
    }
    printf("%d", cnt);
    return 0;//over
}
```


---

## 作者：DeepSkyBlue__ (赞：3)

这道题要我们求出一个区间内的素数个数。

由于 $X$ 和 $Y$ 的范围均不大，我们直接使用最简单的判断方法。

[素数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fromtitle=%E7%B4%A0%E6%95%B0&fromid=115069&fr=aladdin) 指除了 $1$ 和它本身以外不再有其他因数的自然数。

那我们直接枚举这个数可能的因数，如果除了 $1$ 和它本身以外还有其他因数，那么它就不是素数了。

由于因数总是成对出现的，所以只需要枚举到这个数的算术平方根向下取整即可。

可以将判断过程写成函数处理。

另外 $1$ 不是素数， $2$ 是素数，要特判一下。

一个坑点：题目不保证 $X<Y$ 。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool Isprime(int x)//判断是否是素数的函数，返回0代表不是素数，返回1代表是素数
{
    if(x<=1)return 0;//特判
    if(x==2)return 1;
    for(int i=2;i*i<=x;i++)//枚举可能的因数
        if(x%i==0)return 0;//能被整除，存在除了1与自身以外的因数，不是素数
    return 1;//否则就一定是素数
}
int main()
{
    int x,y,sum=0;
    cin>>x>>y;
    if(x>y)swap(x,y);//坑点，小的数作为区间前起点
    for(int i=x;i<=y;i++)
        if(Isprime(i))sum++;//i是素数，答案+1
    cout<<sum<<endl;
    return 0;
}
```


---

## 作者：Arghariza (赞：2)

- 暴力の算法

枚举 $n,m$ 之间的所有数，如果是素数答案加一。

如何判断 $x$ 是否是素数？

1. 暴力枚举所有 $i\in[2,x-1]∩\mathbb{Z}$ ，如果 $x\ mod\ i = 0$ ，$x$ 为素数。

2. 实际上我们发现对于 $x$ ， $i$ 并不用枚举那么多，直接从 $[2,\sqrt{n}]∩\mathbb{Z}$ 枚举即可。

记得特判 $n=1,2$ 的情况。

第一种复杂度 $O(n^2)$ ，第二种 $O(n\sqrt n)$ ，第二种能过。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, ans;

bool isprime(int x) {// 判断素数
	if (x == 1) return false;
	else if (x == 2) return true;// 特判
	for (int i = 2; i * i <= x; i++) {
		if (x % i == 0) return false;
	}
	return true;
}

int main() {
	scanf("%d%d", &n, &m);
	if (m < n) swap(n, m);
	for (int i = n; i <= m; i++) {
		if (isprime(i)) ans++;// 统计答案
	}
	printf("%d", ans);
	return 0;
}
```

- 朴素の算法

各种筛法：埃氏筛、线性（欧拉）筛

先计算 $get(x)=\sum\limits_{k=1}^{x}[x\in \mathbb P]$ ，答案即为 $get(m)-get(n-1)$ （$n < m$）。

怎么算这个函数呢？

以埃氏筛为例：

如果 $n$ 是合数，那么 $n$ 的倍数也一定是合数。

如果我们从小到大考虑每个数，然后同时把当前这个数的所有倍数记为合数。

这样的话复杂度会大大减小，达到 $O(n\log\log n)$ ，证明参照 [OI Wiki](https://oi-wiki.org/math/sieve/)

那么这个复杂度在我们眼中仍然慢的一批，考虑优化。

埃氏筛法可能将一个合数重复标记，我们避免这样的操作，即可达到线性 $O(n)$ 。

具体地看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e6;// 数组开小会奇怪的RE
int n, m;
int tot, p[maxn], v[maxn];// p存储素数，v判断素数

int get(int x) {
	tot = 0;
	memset(p, 0, sizeof(p));
	memset(v, 0, sizeof(v));
	for (int i = 2; i <= x; i++) {
		if (!v[i]) p[++tot] = i;// 存储素数
		for (int j = 1; j <= tot && i <= x / p[j]; j++) {
			v[i * p[j]] = 1;// 标记所有倍数
			if (i % p[j] == 0) {// 如果标记过了，直接踹出循环
				break;
			}
		}
	}
	return tot;
}

int main() {
	scanf("%d%d", &n, &m);
	if (m < n) swap(n, m);
	printf("%d", get(m) - get(n - 1));// 统计答案
	return 0;
}
```

---

## 作者：light_ght (赞：2)

## 欧拉筛做法题解

upd. 12/20/2021 修复了$\LaTeX$。

- 前言

虽然此处用欧拉筛有些小题大做，但作为一个~~没用~~重要的算法还是可以说说欧拉筛。

~~为什么开 1e5 数组会 #3 RE啊~~

- 算法介绍与原理

欧拉素数筛是一种算法复杂度 $ \Theta(n) $ 的高效的素数筛选算法，由埃氏筛改进而来（不知道埃氏筛？~~不重要~~它是一种筛去已知小素数（ $2$、$3$ 等）的所有倍数，未删去者即为素数，并继续筛去它们的倍数）。

埃氏筛法的缺点是会重复筛某些数。比如在筛 $3$ 的倍数与 $5$ 的倍数时，会重复筛去 $15$、$30$ 等。

我们想，让每个合数只被筛选一次,就能达到不重复的目的，从而提高效率。



聪明的~~做过小学找规律题的~~你一定会发现：让每个合数只被它的最小质因子筛选一次，就可以实现不重复！

即：若此时被筛的数 $i$ 为已知的可以满足的素数 $j$ 的整数倍，且 $j$ 尽可能小，则停止本轮筛。

注意：**$1$ 不是素数！**

- 算法 Code

```cpp
int prime[1100001],sum;	//sum为素数总数
bool isp[1100001];	
void euler(int n){
    memset(isp,1,sizeof isp);
    isp[1]=0;  //注意1不是素数
    for(int i=2;i<=n;i++){	//注意从2开始筛
         if(isp[i])prime[++sum]=i;	//存素数
         for(int j=1;j<=sum&&i*prime[j]<=n;j++){
            isp[i*prime[j]]=0;	//把所有合数记录
            if(i%prime[j]==0)break;	//实现不重复的核心代码
        }
    }
}
```


- 本题做法分析

先运行欧拉筛函数，算出符合要求规模的素数表。

随即只需要求出大于等于 $x$ 的素数的 `prime` 数组下标，并求出 `euler(y)` 的 $sum$ 値（即不大于 $y$ 的最大素数个数）。用后者减去前者会导致**第一个素数未被取到**，加一即可。

坑点：$x$ **不一定**小于 $y$ 。如 $x>y$ 则需交换两个数。 



- 本题最终代码（主体）
```cpp
int prime[1100001];	//得开到1e6（求大佬解释为什么）
int sum;	
bool isp[1100001];
void euler(int n){	
    memset(isp,1,sizeof isp);
    isp[1]=0;
    for(int i=2;i<=n;i++){
         if(isp[i])prime[++sum]=i;
         for(int j=1;j<=sum&&i*prime[j]<=n;j++){
            isp[i*prime[j]]=0;
            if(i%prime[j]==0 )break;
        }
    }
}
int main(){
	int x,y;
	scanf("%d%d",&x,&y);
	if(x>y)swap(x,y);	//防止出现x>y情况 
	euler(y);	
	for(int i=1;i<=sum;i++){	//搜索起点在素数表第几项 
		if(prime[i]>x){	
			printf("%d",sum-i+1);	//注意加一
			return 0;	
		}
	}
	printf("0");//如果前面没有输出任何东西就跳出了循环，则说明无满足情况，输出零
}

```


---


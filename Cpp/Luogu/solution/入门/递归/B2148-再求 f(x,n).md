# 再求 f(x,n)

## 题目描述

已知

$f(x,n)=\dfrac{x}{n+\dfrac{x}{(n-1)+\dfrac{x}{(n-2)+\dfrac{\vdots}{\cdots+\dfrac{x}{1+x}}}}}$。

用递归函数求解。

## 样例 #1

### 输入

```
1
2```

### 输出

```
0.40```

# 题解

## 作者：王熙文 (赞：26)

## 题意

题目中已经说的很清楚了，需要注意的一点是，不仅答案可能是浮点数，$x$ 也可能是！（这个坑了我很久）

题目要求使用递归求解。

## Solution 1

我们观察这个式子，可以把它转化成一个递归（递推）式：

$f(x,1)=\dfrac{x}{1+x},f(x,n)=\dfrac{x}{n+f(x,n-1)}$

因为随着 $n$ 越来越小，肯定会到边界 $f(x,1)$，所以递归可行。

这是递归的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

double x;

inline double f(int n)
{
    if(n==1) return x/(1+x);
    return x/(n+f(n-1));
}

int main()
{
    int n;
    cin>>x>>n;
    printf("%.2f",f(n));
    return 0;
}
```

## Solution 2

同样，根据上面那个式子，也可以递推。

这是递推的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

double f[10000010];

int main()
{
    double x;
    int n;
    cin>>x>>n;
    f[1]=x/(1+x);
    for(int i=2; i<=n; ++i) f[i]=x/(i+f[i-1]);
    printf("%.2f",f[n]);
    return 0;
}
```

## Solution 3

同样，这个代码也可以用队列实现。

```cpp
#include<bits/stdc++.h>
using namespace std;

queue<double> q;

int main()
{
    double x;
    int n;
    cin>>x>>n;
    q.push(x/(1+x));
    for(int i=2; i<=n; ++i) q.push(x/(i+q.front())),q.pop();
    printf("%.2f",q.front());
    return 0;

```
## Solution 4

如何优化空间呢？能不能不用定义数组、STL 或使用递归呢？我们可以像求数列之和那样子，每次更新自己。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    double x;
    int n;
    cin>>x>>n;
    double f=x/(1+x);
    for(int i=2; i<=n; ++i) f=x/(i+f);
    printf("%.2f",f);
    return 0;
}
```

---

## 作者：听取MLE声一片 (赞：10)

一本通想让我们用递归做，所以我们用循环做。

显然这道题不需要递归，只需要自下而上循环即可。用一个变量保存答案，当循环到第 `i` 层时即为 $n=i$ 时的答案。第一层答案显然是 $ans=x/(1+x)$ ，而根据给定的递归式当 $i>1$ 时 $ans=x/(i+ans)$ 。

下见代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
double x,ans;
int n;
int main()
{
    scanf("%lf",&x);
	n=read();
    ans=x/(1+x);
    for(int i=2;i<=n;i++)
		ans=x/(i+ans);
    printf("%.2f",ans);
    return 0;
}

```

---

## 作者：Daidly (赞：4)

看到有相同的结构，我们可以想到运用递归求解。

注意递归函数的界限，当 $i=1$ 时，返回 $\frac{x}{1+x}$。

- 要求保留两位小数，可以用到 `cout<<fixed<<setprecision(x)<<a<<endl;`，意思是输出 $a$，保留 $x$ 位小数。

- 将 $x,n$ 用 `double` 类型储存，方便计算小数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
double x,n;
double ans(int i){
	if(i==1)return x/(i+x);
	return x/(i+ans(i-1));
}
int main(){
	cin>>x>>n;
	cout<<fixed<<setprecision(2)<<ans(n);
    return 0;
}
```

---

## 作者：xgwpp6710 (赞：1)

$$\huge{\frac{x}{n+\frac{x}{n-1+\frac{x}{n-2+...}}}}$$

题目里的函数表达式不清楚，我这里重新放一下。

那么这题最简单的思路就是递归，一本通也让我们这么做。

设 $f(n,x)=\large{\frac{x}{n+\frac{x}{n-1+...}}}$，则我们很容易发现
$$f(n,x)=\frac{x}{n-1+f(n-1,x)}$$
最后我们知道 $f(1,x)=\frac{x}{x+1}$，于是这题代码就很好写了。
```cpp
#include<bits/stdc++.h>
using namespace std;
double f(double n,double x)
{
	if(n==1) return x/(x+1);
	else return x/(n+f(n-1,x));
}
int main()
{
	double x,n;
	cin>>x>>n;
	printf("%.2lf",f(n,x)); 
	return 0;
}
```

---

## 作者：Miracle_ZX (赞：1)

首先，我们要注意到函数的值和 x 都有可能不是整数，这里注意一下，找好递归关系，这道题就解决了。
### Part 1 递归关系
仔细看看原题中的式子，会发现它其实很有规律：  

$f(x, n) =  \dfrac{x}{n+f(x, n - 1)}$ 

这样，我们的递归公式就出来了。
### Part 2 边界条件
当 n 小到一定地步时，就会达到边界。  
如，当 n 为 1 时，

$f(x, 1) =  \dfrac{x}{1+f(x, 0)}$ 

所以，我们就会发现，

$f(x, 1) =  \dfrac{x}{1+x}$ 
### Part 3 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

double x;

double f(int n)
{
    if(n == 1) return x / (1 + x);
    return x / (n + f(n - 1) );
}

int main()
{
    int n;
    cin >> x >> n;
    cout << fixed << setprecision(2) << f(n);
    //c++ 中的四舍五入和保留两位小数
    return 0;
}
```
### Part 4 最后
此题其实还可以用递推，循环等等方法解决，或是可以用不断更新的方法加速，有兴趣的同学可借此机会自行探索。


---


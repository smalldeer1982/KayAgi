# [APIO2009] 采油区域

## 题目描述

Siruseri 政府决定将石油资源丰富的 Navalur 省的土地拍卖给私人承包商以 建立油井。被拍卖的整块土地为一个矩形区域，被划分为 $M \times N$ 个小块。 Siruseri 地质调查局有关于 Navalur 土地石油储量的估测数据。这些数据表示 为 $M \times N$ 个正整数，即对每一小块土地石油储量的估计值。 为了避免出现垄断，政府规定每一个承包商只能承包一个由 $K\times K$ 块相连的土地构成的正方形区域。 AoE 石油联合公司由三个承包商组成，他们想选择三块互不相交的 $K\times K$ 的 区域使得总的收益最大。 例如，假设石油储量的估计值如下：

```
1 1 1 1 1 1 1 1 1 
1 1 1 1 1 1 1 1 1 
1 8 8 8 8 8 1 1 1 
1 8 8 8 8 8 1 1 1 
1 8 8 8 8 8 1 1 1 
1 1 1 1 8 8 8 1 1 
1 1 1 1 1 1 8 8 8 
1 1 1 1 1 1 9 9 9 
1 1 1 1 1 1 9 9 9 
```

- 如果 $K = 2$，AoE 公司可以承包的区域的石油储量总和为 $100$；
- 如果 $K = 3$，AoE 公司可以承包的区域的石油储量总和为 $208$。

AoE 公司雇佣你来写一个程序，帮助计算出他们可以承包的区域的石油储量之和的最大值。


## 说明/提示

数据保证 $K\le M$ 且 $K\le N$ 并且至少有三个 $K\times K$ 的互不相交的正方形区域。

其中 $30\%$ 的输入数据，$M, N \le 12$。所有的输入数据, $M, N\le 1500$。每一小块土地的石油储量的估计值是非负整数且小于等于 $500$。


## 样例 #1

### 输入

```
9 9 3
1 1 1 1 1 1 1 1 1 
1 1 1 1 1 1 1 1 1 
1 8 8 8 8 8 1 1 1 
1 8 8 8 8 8 1 1 1 
1 8 8 8 8 8 1 1 1 
1 1 1 1 8 8 8 1 1 
1 1 1 1 1 1 8 8 8 
1 1 1 1 1 1 9 9 9 
1 1 1 1 1 1 9 9 9 ```

### 输出

```
208```

# 题解

## 作者：Edgration (赞：26)

# 递推+前缀和

其实想清楚了本题就根本不难

首先考虑这题肯定要用到前缀和，那么怎么用就是一个问题了

一个矩形，分三块，有六种方法 如图

![这里写图片描述](http://img.blog.csdn.net/20160425101932088)

**分别在三个部分中找的k\*k面积最大的，加起来就是答案**

那么怎么表示这三个块中面积最大的呢？

就需要记录对于每个点

它**左上，右上，左下，右下**的四个部分中，**最大的K\*K块的价值和**

这个样子：

```cpp
int a[2000][2000],b[2000][2000],c[2000][2000],d[2000][2000];
//我的代码中a表示左上，b右上，c左下，d右下
```
怎么算这abcd四个二维数组呢：

**一个s[][]二维数组记录，s[i][j]表示以i，j为右下角的K\*K正方形的石油储量之和**

那么递推可以推出a,b,c,d


得到abcd以后就分6个情况更新最大值，代码如下


```cpp
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[i][j]+b[i][j+k]+c[i+k][m]);
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[i][m]+c[i+k][j]+d[i+k][j+k]);    
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[i][j]+b[n][j+k]+c[i+k][j]);
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[n][j]+b[i][j+k]+d[i+k][j+k]);
    rep(i,k,n-k) rep(j,k+k,m-k) ans=max(ans,a[n][j-k]+b[n][j+k]+mp[i][j]);
    rep(i,k+k,n-k) rep(j,k,m-k) ans=max(ans,a[i-k][m]+c[i+k][m]+mp[i][j]);
```

代码对应的情况如图

![image](https://i.loli.net/2017/08/11/598db2ae13756.bmp)

因为我在计算abcd的时候存的是正方形的右下角，所以+k才可以得到左上左下右上右下的值

自己画画图想想即可


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#define FI for(int i=1;i<=n;i++)
#define FJ for(int j=1;j<=m;j++)
#define FDI for(int i=n;i>=k;i--)
#define FDJ for(int j=m;j>=k;j--)
#define FUI for(int i=k;i<=n;i++)
#define FUJ for(int j=k;j<=m;j++)
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define per(i,x,y) for(int i=x;i>=y;i--)//偷个懒
using namespace std;
int mp[2000][2000];
int a[2000][2000],b[2000][2000],c[2000][2000],d[2000][2000];
int n,m,k;
int main(){
    //freopen("C:\\Users\\pc\\Desktop\\input.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&k);
    int x;
    int cnt=1;
    FI FJ{
        //printf("%d\n",cnt++);
        scanf("%d",&x);
        mp[i][j]=mp[i-1][j]+mp[i][j-1]-mp[i-1][j-1]+x;    
    }
    FDI FDJ    mp[i][j]-=mp[i-k][j]+mp[i][j-k]-mp[i-k][j-k];//mp的意义是以i，j为右下角的K*K正方形的石油储量之和
    FUI FUJ    a[i][j]=max(mp[i][j],max(a[i-1][j],a[i][j-1]));
    FUI FDJ b[i][j]=max(mp[i][j],max(b[i-1][j],b[i][j+1]));
    FDI FUJ c[i][j]=max(mp[i][j],max(c[i+1][j],c[i][j-1]));
    FDI FDJ d[i][j]=max(mp[i][j],max(d[i+1][j],d[i][j+1]));//初始化abcd
    int ans=0;
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[i][j]+b[i][j+k]+c[i+k][m]);
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[i][m]+c[i+k][j]+d[i+k][j+k]);    
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[i][j]+b[n][j+k]+c[i+k][j]);
    rep(i,k,n-k) rep(j,k,m-k) ans=max(ans,a[n][j]+b[i][j+k]+d[i+k][j+k]);
    rep(i,k,n-k) rep(j,k+k,m-k) ans=max(ans,a[n][j-k]+b[n][j+k]+mp[i][j]);
    rep(i,k+k,n-k) rep(j,k,m-k) ans=max(ans,a[i-k][m]+c[i+k][m]+mp[i][j]);
    //更新答案
    printf("%d",ans);
    return 0;
}
```

广告
我的博客（里面更详细）

[传送门](https://xianglujia.github.io/2017/08/11/ti\_APIO2009%20Oil/)


---

## 作者：约瑟夫用脑玩 (赞：10)

我在学校的提高组膜拟赛中做到了这道题

刚看到题时，这T2有点水啊，开四个数组记录左上，右上，左下，右下一块的最大值再枚举分界点玄学拼起来就行了啊...

![](https://s2.ax1x.com/2019/09/27/uMPnWn.png)

于是高高兴兴的把四个数组处理了出来，然后按照上面的方法统计答案，没过大样例

回头看了眼题，一分钟后，表情渐渐凝重

![](https://s2.ax1x.com/2019/09/27/uMCgMV.png)

蛤？这两个情况怎么考虑啊？？？(其实很好考虑只不过考试时莫名不知道怎么做)

突然自闭的我开始重新审视这道题

我研究了一下样例，想出来了另一种算法：

可以用类似处理左上，右上，左下，右下一块的最大值的方法，把左上，右上，左下，右下不相交的两块的最大值处理出来，再加上剩下部分的最大值，这样就把所以情况考虑全了

![](https://s2.ax1x.com/2019/09/27/uMA8j1.png)

然后愉快过样例，再测了一下大样例，也过了，这道题自然也A了

~~你以为这样就完了？~~

然而下来后找原题交了一遍，全MLE...

发现考试是512MB的内存，而luogu是125MB的内存

然后通过重复用了数组的方法卡了两个数组的内存就过了

## **考场代码：**

```cpp
LL Sum[1505][1505],F1[1505][1505],F2[1505][1505],F3[1505][1505],F4[1505][1505];
LL FF1[1505][1505],FF2[1505][1505],FF3[1505][1505],FF4[1505][1505],sum,ans;
inline LL Max(LL x,LL y)
{
	return x>y?x:y;
}
int main()
{
	int i,j,x;
	n=read();
	m=read();
	K=read();
	for(i=1;i<=n;++i)
	{
		for(j=1;j<=m;++j)
		{
			x=read();
			Sum[i][j]=Sum[i][j-1]+Sum[i-1][j]-Sum[i-1][j-1]+x;
			if(i>=K&&j>=K)
			{
				sum=Sum[i][j]-Sum[i][j-K]-Sum[i-K][j]+Sum[i-K][j-K];
				F1[i][j]=Max(sum,Max(F1[i][j-1],F1[i-1][j]));
				FF1[i][j]=Max(sum+Max(F1[i][j-K],F1[i-K][j]),Max(FF1[i][j-1],FF1[i-1][j]));
			}
		}
	}
	for(i=1;i<=n;++i)
	{
		for(j=m;j>=1;--j)
		{
			if(i>=K&&j<=m-K+1)
			{
				sum=Sum[i][j+K-1]-Sum[i][j-1]-Sum[i-K][j+K-1]+Sum[i-K][j-1];
				F2[i][j]=Max(sum,Max(F2[i][j+1],F2[i-1][j]));
				FF2[i][j]=Max(sum+Max(F2[i][j+K],F2[i-K][j]),Max(FF2[i][j+1],FF2[i-1][j]));
			}
		}
	}
	for(i=n;i>=1;--i)
	{
		for(j=1;j<=m;++j)
		{
			if(i<=n-K+1&&j>=K)
			{
				sum=Sum[i+K-1][j]-Sum[i+K-1][j-K]-Sum[i-1][j]+Sum[i-1][j-K];
				F3[i][j]=Max(sum,Max(F3[i][j-1],F3[i+1][j]));
				FF3[i][j]=Max(sum+Max(F3[i][j-K],F3[i+K][j]),Max(FF3[i][j-1],FF3[i+1][j]));
			}
		}
	}
	for(i=n;i>=1;--i)
	{
		for(j=m;j>=1;--j)
		{
			if(i<=n-K+1&&j<=m-K+1)
			{
				sum=Sum[i+K-1][j+K-1]-Sum[i+K-1][j-1]-Sum[i-1][j+K-1]+Sum[i-1][j-1];
				F4[i][j]=Max(sum,Max(F4[i][j+1],F4[i+1][j]));
				FF4[i][j]=Max(sum+Max(F4[i][j+K],F4[i+K][j]),Max(FF4[i][j+1],FF4[i+1][j]));
			}
		}
	}
	for(i=1;i<=n;++i)
	{
		for(j=1;j<=m;++j)
		{
			ans=Max(ans,FF1[i][j]+Max(F4[1][j+1],F4[i+1][1]));
			ans=Max(ans,FF2[i][j]+Max(F1[n][j-1],F4[i+1][1]));
			ans=Max(ans,FF3[i][j]+Max(F4[1][j+1],F1[i-1][m]));
			ans=Max(ans,FF4[i][j]+Max(F1[n][j-1],F1[i-1][m]));
		}
	}
	printf("%lld\n",ans);
	return 0;
}

```

Upd:早年题解，删了许多废话，码风不佳，不给过也算了吧。。。

---

## 作者：xixike (赞：9)

# Description

[原题链接](https://www.luogu.com.cn/problem/P3625)

# Solution

很巧妙的一种思想：**分类讨论**

分为 6 种情况，如下图：

![](https://z3.ax1x.com/2021/09/29/457foD.png)

可以发现，每一张图都被分为了 3 块，我们就可以分别在这三个部分中各选择一个 $k * k$ 的矩形，取最大值。


### 具体实现：

首先要进行预处理，设一个点为 $(x, y)$

我们要预处理出以这个点为端点向**左上**，**右上**，**左下**，**右下**，四个方向分别的最大子矩阵。

然后我们枚举上图中每个矩形中的那两条线，再取最大值即可。

具体看代码吧。

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ri register int

using namespace std;

const int N = 1510;
int n, m, k, ans;
int sum[N][N], s[N][N], a[N][N], b[N][N], c[N][N], d[N][N];
//sum:前缀和  s: k * k区间和（详见下面） a,b,c,d: 四个方向，下面有图

inline int read(){
	int x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
	return x;
}

/*
a  |  b 
———+————
c  |  d
*/

inline void init(){
	for(ri i = 1; i <= n; ++i)
		for(ri j = 1; j <= m; ++j)
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + read();//二维前缀和
	for(ri i = k; i <= n; ++i)
		for(ri j = k; j <= m; ++j)
			s[i][j] = sum[i][j] - sum[i][j - k] - sum[i - k][j] + sum[i - k][j - k];//k * k区间和
//4 个方向预处理最大子矩阵
	for(ri i = k; i <= n; ++i)
		for(ri j = k; j <= m; ++j)
			a[i][j] = max(s[i][j], max(a[i][j - 1], a[i - 1][j]));
	for(ri i = k; i <= n; ++i)
		for(ri j = m - k + 1; j >= 1; j--)
			b[i][j] = max(s[i][j + k - 1], max(b[i - 1][j], b[i][j + 1]));
	for(ri i = n - k + 1; i >= 1; i--)
		for(ri j = k; j <= m; ++j)
			c[i][j] = max(s[i + k - 1][j], max(c[i + 1][j], c[i][j - 1]));
	for(ri i = n - k + 1; i >= 1; i--)
		for(ri j = m - k + 1; j >= 1; j--)
			d[i][j] = max(s[i + k - 1][j + k - 1], max(d[i + 1][j], d[i][j + 1]));
}

/*
a  |  b 
———+————
c  |  d
*/

inline void solve(){
	//两条竖线，两条横线的情况
	for(ri i = k; i <= n; ++i)
		for(ri j = k; j <= m; ++j){
			ans = max(ans, a[i - k][m] + s[i][j] + c[i + 1][m]);//两条横线
			ans = max(ans, a[n][j - k] + s[i][j] + b[n][j + 1]);//两条竖线
		}
	//剩下 4 种情况
	for(ri i = 1; i <= n; ++i)
		for(ri j = 1; j <= m; ++j){
			ans = max(ans, a[i][j] + b[i][j + 1] + c[i + 1][m]);
			ans = max(ans, a[i][m] + c[i][j] + d[i + 1][j + 1]);
			ans = max(ans, a[i][j] + b[n][j + 1] + c[i + 1][j]);
			ans = max(ans, a[n][j] + b[i][j + 1] + d[i + 1][j + 1]);
		}
}

signed main(){
	n = read(), m = read(), k = read();
	init();
	solve();
	printf("%lld\n", ans);
	return 0;
}
```

# End

---

## 作者：huayucaiji (赞：5)

## 前言

重复的思维，重复的代码，重复地调试。

~~我已AC，感觉良好~~

## 解法1

没啥技巧，看一眼就知道怎么做了。

分为 $6$ 个情况，哪 $6$ 种可以看别的大佬的 blog。这篇题解只要讲一下别的大佬没有仔细讲的**预处理部分**。

我们要处理出来的是 $7$ 个量。见下：

|量：|$sum_{i,j}$|$lu_{i,j}$|$ld_{i,j}$|$ru_{i,j}$|$rd_{i,j}$|$ver_{i,j}$|$hor_{i,j}$|
|-|-|-|-|-|-|-|-|
|含义：|左上角矩阵中数字的和|左上角最大 $k*k$ 矩阵数字和|左下角最大 $k*k$ 矩阵数字和|右上角最大 $k*k$ 矩阵数字和|右下角最大 $k*k$ 矩阵数字和|$i$ 到 $j$ 列最大 $k*k$ 矩阵数字和|$i$ 到 $j$ 行最大 $k*k$ 矩阵数字和|

我们要把每个量处理出来。$sum$ 就是**二维前缀和**，用于计算后面 $6$ 个量，$lu,ld,ru,rd$ 四个量用 **DP** 求解。$ver,hor$ 用**区间 DP** 求解。

最后 $6$ 种情况讨论一下即可。

## 解法2

两位神 @cookiebus @code_hunter 貌似有另一种解法，我没太看懂他们的代码。他们又没写题解，感兴趣的小伙伴可以去问一下。

## 代码

这代码，你不看也罢。~~反正你看了根没看差不多~~

祝你好运！

**注意不要开 long long，会MLE！**

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=15e2+10; 

int n,m,k,ans;
int sum[MAXN][MAXN],a[MAXN][MAXN];
int lu[MAXN][MAXN],ld[MAXN][MAXN],rd[MAXN][MAXN],ru[MAXN][MAXN],hor[MAXN][MAXN],ver[MAXN][MAXN];

int gets(int x,int y,int a,int b) {
	return sum[a][b]+sum[x-1][y-1]-sum[x-1][b]-sum[a][y-1];
    //用 sum 计算一个子矩阵中的数字和
}

signed main() {
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			a[i][j]=read();
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
		}
	}
	
	for(int i=k;i<=n;i++) {
		for(int j=k;j<=m;j++) {
			lu[i][j]=max(max(lu[i][j-1],lu[i-1][j]),gets(i-k+1,j-k+1,i,j));
		}
	}
	for(int i=k;i<=n;i++) {
		for(int j=m-k+1;j;j--) {
			ru[i][j]=max(max(ru[i][j+1],ru[i-1][j]),gets(i-k+1,j,i,j+k-1));
		}
	}
	for(int i=n-k+1;i;i--) {
		for(int j=1;j<=m;j++) {
			ld[i][j]=max(max(ld[i][j-1],ld[i+1][j]),gets(i,j-k+1,i+k-1,j));
		}
	}
	for(int i=n-k+1;i;i--) {
		for(int j=m-k+1;j;j--) {
			rd[i][j]=max(max(rd[i][j+1],rd[i+1][j]),gets(i,j,i+k-1,j+k-1));
		}
	}
	for(int i=1;i<=n-k+1;i++) {
		for(int j=1;j<=m-k+1;j++) {
			hor[i][i+k-1]=max(hor[i][i+k-1],gets(i,j,i+k-1,j+k-1));
		}
	}
	for(int len=k+1;len<=n;len++) {
		for(int i=1,j=i+len-1;j<=n;j++,i++) {
			hor[i][j]=max(hor[i+1][j],hor[i][j-1]);
		}
	}
	for(int i=1;i<=m-k+1;i++) {
		for(int j=1;j<=n-k+1;j++) {
			ver[i][i+k-1]=max(ver[i][i+k-1],gets(j,i,j+k-1,i+k-1));
		}
	}
	for(int len=k+1;len<=m;len++) {
		for(int i=1,j=i+len-1;j<=m;j++,i++) {
			ver[i][j]=max(ver[i+1][j],ver[i][j-1]);
		}
	}
    //预处理
	
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			ans=max(ans,hor[i+1][n]+lu[i][j]+ru[i][j+1]);
			ans=max(ans,hor[1][i]+ld[i+1][j]+rd[i+1][j+1]);
			ans=max(ans,ver[j+1][m]+lu[i][j]+ld[i+1][j]);
			ans=max(ans,ver[1][j]+ru[i][j+1]+rd[i+1][j+1]);
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=i+1;j<=n;j++) {
			ans=max(ans,hor[1][i]+hor[i+1][j]+hor[j+1][n]);
		}
	}
	for(int i=1;i<=m;i++) {
		for(int j=1;j<=m;j++) {
			ans=max(ans,ver[1][i]+ver[i+1][j]+ver[j+1][m]);
		}
	}
    //计算答案
	
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：ckain (赞：3)

对于任意一种选择方案，肯定可以从横或竖着的某个位置将油田分成两部分：其中一部分存在 $1$ 个选择的矩形，另一部分存在剩下的 $2$ 个选择的矩形．我们不妨把三个矩形叫做 $A$ 和 $B,C$．其中 $B,C$ 在同一部分．

一定存在某一个方向（从左到右、从右到左、从上到下、从下到上之一），按它扫描油田矩形 $A$ 会最先被扫描到．这时自然出现了一种分割油田的方法：从 $A$ 扫描结尾处分割．我们可以枚举 $A$，然后只需要从油田剩下的部分中求出选出两个矩形的最优方案即可．而两个矩形的最优选择方案可以预处理每个分割位置的答案．

四种方向的分类太过于麻烦，不妨每次只考虑从上往下扫描的情况，然后做完一次后将整张油田右旋 $90^{\circ}$：这样做 $4$ 遍就能覆盖所有的情况．

code：
```cpp
#include<bits/stdc++.h>
#define pii pair<int, int>
#define fr first
#define sc second
#define int long long
#define fup(i, st, ed) for(int i=st; i<=ed; i++)
#define fdn(i, st, ed) for(int i=st; i>=ed; i--)
using namespace std;
inline int rd(void){
	int s=0, f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f=0; c=getchar();}
	while(c>='0' && c<='9') {s=s*10+c-'0'; c=getchar();}
	return f? s:-s;
}

const int N=1505, inf=1e10;

int n, m, K, a[N][N], s[N][N];

inline void nxt_condition(){ 
	static int tmp[N][N];
	fup(i, 1, n) fup(j, 1, m) tmp[j][n-i+1]=a[i][j];
	swap(n, m); fup(i, 1, n) fup(j, 1, m) a[i][j]=tmp[i][j];
	fup(i, 1, n) fup(j, 1, m) s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
}

inline int que(int x, int y){
	if(x<K || x>n || y<K || y>m) return -inf;
	return s[x][y]-s[x-K][y]-s[x][y-K]+s[x-K][y-K];
}

inline int solve(){
	static int lmx1[N][N], rmx1[N][N];
	memset(lmx1, ~63, sizeof(lmx1));
	memset(rmx1, ~63, sizeof(rmx1));
	fdn(i, n, 1){
		fup(j, 1, m) lmx1[i][j]=max({lmx1[i+1][j], lmx1[i][j-1], que(i+K-1, j)});
		fdn(j, m, 1) rmx1[i][j]=max({rmx1[i+1][j], rmx1[i][j+1], que(i+K-1, j+K-1)});
	}
	int ans=0, mx2=-inf;
	fdn(i, n, K){
		fup(j, K, m) ans=max(ans, que(i, j)+mx2);
		fup(j, K, m) mx2=max(mx2, que(i+K-1, j)+max({lmx1[i][j-K], rmx1[i][j+1], lmx1[i+K][m]}));
	}
	return ans;
}

signed main(){
	n=rd(), m=rd(); K=rd();
	fup(i, 1, n) fup(j, 1, m) a[i][j]=rd();
	int ans=0; fup(i, 1, 4) nxt_condition(), ans=max(ans, solve());
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：TulipeNoire (赞：3)

看到这道题，第一眼你是不是马上想到二维的 $dp$ 呢？~~反正我就是了。~~ 但是，我们始终无法推出正确的状态转移方程，因为——本来就不能嘛。

不要把这道问题想得太深奥，**它其实就是一个暴力！**

可以发现，这三个区域的分布，是可以归为以下 $6$ 类的：（下图用红色表示区域 $1$ 所在范围，黄色表示 $2$ ，蓝色表示 $3$）

![1](https://cdn.luogu.com.cn/upload/image_hosting/atl4efvb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/izt7lx2u.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/u82nbeim.png)

以上三类以及它们旋转 $90$° 以后所得到的图形。（注意红黄蓝无别，互换位置没有影响）

这样我们就可以通过计算一个区间内采一个区域得到的最大收益和枚举分割线位置来计算最终的最大值。

我们用最具有代表性（代码中会呈现）的一个顶点坐标以及这个点是四个角中的哪一个来代表一个矩形区间，至于图一的中间那个区间嘛——再开两个数组吧。

时间复杂度 $O(nm)$ 。常数很大，但也没啥。

上代码：（代码仅供参考，理解过后自己打一遍吧）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int a[2005][2005],dp[2005][2005][5],f[2005][2005],calc1[2005],calc2[2005];
//f[i][j]表示二维前缀和，dp[x][y][i]表示以(x,y)作为第i个顶点（见下注释）的矩形区域采一块油能得到的最大收益。
int p (int i,int j) {
    return f[i][j]-f[i-k][j]-f[i][j-k]+f[i-k][j-k];
}//以(i,j)为右下角的采油区域能得到收益的值
void init () {
    for (int i=n-k+1;i>=1;i--) {
        for (int j=m-k+1;j>=1;j--) {
            dp[i][j][1]=max(dp[i+1][j][1],max(dp[i][j+1][1],max(dp[i+1][j+1][1],p(i+k-1,j+k-1))));
        }
    }//左上角
    for (int i=n-k+1;i>=1;i--) {
        for (int j=k;j<=m;j++) {
            dp[i][j][2]=max(dp[i+1][j][2],max(dp[i][j-1][2],max(dp[i+1][j-1][2],p(i+k-1,j))));
        }
    }//右上角
    for (int i=k;i<=n;i++) {
        for (int j=m-k+1;j>=1;j--) {
            dp[i][j][3]=max(dp[i-1][j][3],max(dp[i][j+1][3],max(dp[i-1][j+1][3],p(i,j+k-1))));
        }
    }//左下角
    for (int i=k;i<=n;i++) {
        for (int j=k;j<=m;j++) {
            dp[i][j][4]=max(dp[i-1][j][4],max(dp[i][j-1][4],max(dp[i-1][j-1][4],p(i,j))));
        }
    }//右下角
    
    
    for (int i=k;i<=m;i++) {
        for (int j=k;j<=n;j++) {
            calc1[i]=max(calc1[i],f[j][i]-f[j-k][i]-f[j][i-k]+f[j-k][i-k]);
        }
    }//中间列
    for (int i=k;i<=n;i++) {
        for (int j=k;j<=m;j++) {
            calc2[i]=max(calc2[i],f[i][j]-f[i-k][j]-f[i][j-k]+f[i-k][j-k]);
        }
    }//中间行
}
int solve () {
    int ans=0;
    //6种情况的枚举
    for (int i=k;i<=m-2*k;i++) {
        ans=max(ans,dp[n][i][4]+calc1[i+k]+dp[1][i+k+1][1]);
    }
    for (int i=k;i<=m-2*k;i++) {
        for (int j=k;j<=n-k;j++) {
            ans=max(ans,dp[n][i][4]+dp[j][i+1][3]+dp[j+1][i+1][1]);
        }
    }
    for (int i=k+1;i<=m-k+1;i++) {
        for (int j=k;j<=n-k;j++) {
            ans=max(ans,dp[n][i][3]+dp[j][i-1][4]+dp[j+1][i-1][2]);
        }
    }
    for (int i=k;i<=n-2*k;i++) {
        ans=max(ans,dp[i][m][4]+calc2[i+k]+dp[i+k+1][1][1]);
    }
    for (int i=k;i<=n-2*k;i++) {
        for (int j=k;j<=m-k;j++) {
            ans=max(ans,dp[i][m][4]+dp[i+1][j][2]+dp[i+1][j+1][1]);
        }
    }
    for (int i=k+1;i<=n-k+1;i++) {
        for (int j=k;j<=m-k;j++) {
            ans=max(ans,dp[i-1][j][4]+dp[i-1][j+1][3]+dp[i][1][1]);
        }
    }
    return ans;
}
int main () {
    scanf("%d %d %d",&n,&m,&k);
    for (int i=1;i<=n;i++) {
        for (int j=1;j<=m;j++) {
            scanf("%d",&a[i][j]);
            f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j];
        }
    }
    init();
    printf("%d",solve());
    return 0;
}
```

---

## 作者：DengDuck (赞：2)

首先这道题显然是二维前缀和加一些奇怪的东西。

我们可以考虑把矩阵划分成三个大的不相交的区间，然后找出其中的最大值。

发现以下两种分割方式涵盖了所有情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/lmt3dliz.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/41ie6fk6.png)

当然你还得考虑它们旋转之后那样的图案。

我们需要维护（在我比较冗余的写法中）：

- $lu_{i,j}$ 表示 $(i,j)$ 左上角的最佳矩阵。
- $ru_{i,j}$ 表示 $(i,j)$ 右上角的最佳矩阵。
- $ld_{i,j}$ 表示 $(i,j)$ 左下角的最佳矩阵。
- $rd_{i,j}$ 表示 $(i,j)$ 右下角的最佳矩阵。
- $a_{i,j}$ 表示第 $i$ 行到 $j$ 行的点作为矩阵的右下角的最佳矩阵。
- $b_{i,j}$ 表示第 $i$ 列到 $j$ 列的点作为矩阵的右下角的最佳矩阵。

于是，对于情况 $1$，我们枚举中间点 $(i,j)$，然后找出三个区域的最佳矩阵，旋转情况同理。

对于情况 $2$，我们枚举两个分割线的纵坐标 $i,j$，然后找出三个区域的最佳矩阵，旋转情况同理。

我的代码可读性应该不错，但是代码有点冗余，你可以考虑维护矩阵，这样可以少维护一些东西。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=1505;
LL n,m,k,x,sum[N][N],a[N][N],b[N][N],mxx[N],mxy[N],lu[N][N],ru[N][N],ld[N][N],rd[N][N],ans;
LL cal(LL x,LL y)//求以x,y为右下角的矩阵
{
	if(x<k||y<k)return 0;
	if(n<x||m<y)return 0;
	return sum[x][y]-sum[x-k][y]-sum[x][y-k]+sum[x-k][y-k];
}
void init()//预处理
{
	for(int i=k;i<=n;i++)//求行、列最大值，便于计算 a[i][j],b[i][j]
	{
		for(int j=k;j<=m;j++)mxx[i]=max(mxx[i],cal(i,j)),mxy[j]=max(mxy[j],cal(i,j));
	}	
	for(int i=1;i<=n;i++)
	{
		a[i][i]=mxx[i];
		for(int j=i+1;j<=n;j++)a[i][j]=max(a[i][j-1],mxx[j]);
	}
	for(int i=1;i<=m;i++)
	{
		b[i][i]=mxy[i];
		for(int j=i+1;j<=m;j++)b[i][j]=max(b[i][j-1],mxy[j]);
	}	
	for(int i=k;i<=n;i++)//计算左上，左下，右上，右下的最大值
	{
		for(int j=k;j<=m;j++)lu[i][j]=max({lu[i-1][j],lu[i][j-1],cal(i,j)});
	}
	for(int i=k;i<=n;i++)
	{
		for(int j=m-k+1;j>=1;j--)ru[i][j]=max({ru[i-1][j],ru[i][j+1],cal(i,j+k-1)});
	}
	for(int i=n-k+1;i>=1;i--)
	{
		for(int j=k;j<=m;j++)ld[i][j]=max({ld[i+1][j],ld[i][j-1],cal(i+k-1,j)});
	}
	for(int i=n-k+1;i>=1;i--)
	{
		for(int j=m-k+1;j>=1;j--)rd[i][j]=max({rd[i+1][j],rd[i][j+1],cal(i+k-1,j+k-1)});
	}
	//要注意四个方向中每个点扮演的矩阵的位置不一样，需要转换一下，参考不同循环中的cal的参数
}
int main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)//输入，处理二维前缀和
		{
			scanf("%lld",&x);
			sum[i][j]=x+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		} 
	}
	init(); 
	for(int i=1;i<=n;i++)//情况2
		for(int j=i+k;j+k<=n;j++)ans=max(ans,a[1][i]+a[i+k][j]+a[j+k][n]);
	for(int i=1;i<=m;i++)
		for(int j=i+k;j+k<=m;j++)ans=max(ans,b[1][i]+b[i+k][j]+b[j+k][m]);
	for(int i=1;i<=n;i++)//情况1
	{
		for(int j=1;j<=n;j++)
		{
			if(i+k<=n)ans=max(ans,lu[i][j]+ru[i][j+1]+a[i+k][n]);
			if(i>=k)ans=max(ans,ld[i][j]+rd[i][j+1]+a[1][i-1]);
			if(j+k<=m)ans=max(ans,lu[i][j]+ld[i+1][j]+b[j+k][m]);
			if(j>=k)ans=max(ans,ru[i][j]+rd[i+1][j]+b[1][j-1]);
		}
	} 
	printf("%lld",ans);
} 
```

---

## 作者：wangbinfeng (赞：2)

[![](https://img.shields.io/badge/题目-P3625_[APIO2009]_采油区域-green)
![](https://img.shields.io/badge/难度-提高+/省选−-blue)
![](https://img.shields.io/badge/考点-分类讨论、前缀和-yellow)
![](https://img.shields.io/badge/题型-传统题-red)](https://www.luogu.com.cn/problem/P3625)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)    
[![](https://img.shields.io/badge/题目-AT__abc347__e_[ABC347F]_Non—overlapping_Squares-green)
![](https://img.shields.io/badge/难度-暂无评定（提高+/省选−）-blue)
![](https://img.shields.io/badge/考点-分类讨论、前缀和-yellow)
![](https://img.shields.io/badge/题型-传统题-red)](https://www.luogu.com.cn/problem/AT_abc347_f)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009) 

-----------
说明：ABC347F 是 P3625 的弱化版，故本题解同时讲解两道题目。特别地，$N_{本题解}=N_{P3625}=N_{ABC347F},M_{本题解}=M_{P3625}=N_{ABC347F},K_{本题解}=K_{P3625}=M_{ABC347F}$。

枚举每个点 $S\left(i,j\right),1\le i\le N,1\le j\le M$，可以发现对于每个点有且只有 $6$ 种情况，分别是：
```
┏━┳━┳━┓　　　┏━━━━━┓
┃　┃　┃　┃　　　┃　　Ａ　　┃
┃　┃　┃　┃　　　┣━━━━━┫
┃Ａ┃Ｓ┃Ｂ┃　　　┃　　Ｓ　　┃
┃　┃　┃　┃　　　┣━━━━━┫
┃　┃　┃　┃　　　┃　　Ｂ　　┃
┗━┻━┻━┛　　　┗━━━━━┛
　【情况一】　　　　　【情况二】
┏━━┳━━┓　　　┏━━━━━┓
┃　　┃　　┃　　　┃　　　　　┃
┃　Ｓ┃Ａ　┃　　　┃　　Ｓ　　┃
┣━━┻━━┫　　　┣━━┳━━┫
┃　　Ｂ　　┃　　　┃　Ａ┃Ｂ　┃
┃　　　　　┃　　　┃　　┃　　┃
┗━━━━━┛　　　┗━━┻━━┛
　【情况三】　　　　　【情况四】
┏━━┳━━┓　　　┏━━┳━━┓
┃　　┃　　┃　　　┃　　┃　　┃
┃　Ｓ┃　　┃　　　┃　　┃Ａ　┃
┣━━┫Ｂ　┃　　　┃　Ｓ┣━━┫
┃　Ａ┃　　┃　　　┃　　┃Ｂ　┃
┃　　┃　　┃　　　┃　　┃　　┃
┗━━┻━━┛　　　┗━━┻━━┛
　【情况五】　　　　　【情况六】

``` 
> （如果显示异常请[点击此处](https://img.atcoder.jp/abc347/c8c4557905764a04a59ff89c7b249746.png)查看官方题解的图片。注意顺序和本题解的六种情况并不相通，感性理解一下 qwq）

分别计算六种情况的最大值，时间复杂度为 $\Theta\left(NMK^2\right)$，无法承受。

考略前缀和，用 $s_{i,j}$ 表示右下角为 $S\left(i,j\right)$，大小为 $K\times K$ 的正方形数字之和。用类似动态规划的做法，记录下每个点左上、左下、右上、右下四个方向的大小为 $K\times K$ 的正方形数字之和最大值。时间复杂度优化为 $\Theta\left(NM\right)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#ifndef PROBLEM
#define PROBLEM 【这里选填数3625或347表示题号】
#endif
const int maxn=1509;
int n,m,k,ans,sum[maxn][maxn],dat[4][maxn][maxn];
signed main(){
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
#if defined(PROBLEM) && (PROBLEM == 3625)
	cin>>n>>m>>k;
#elif defined(PROBLEM) && (PROBLEM == 347)
	cin>>n>>k,m=n;
#else
	throw("[ERROR] The code does not target either P3625 or ABC347F and cannot be run for the time being.");
#endif
	for(int i=1;i<=n;i++)for(int j=1,x;j<=m;j++)cin>>x,sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+x;
	for(int i=n;i>=k;i--)for(int j=m;j>=k;j--)sum[i][j]-=sum[i-k][j]+sum[i][j-k]-sum[i-k][j-k];
	for(int i=k;i<=n;i++)for(int j=k;j<=m;j++)dat[0][i][j]=max({sum[i][j],dat[0][i-1][j],dat[0][i][j-1]});
	for(int i=k;i<=n;i++)for(int j=m-k+1;j>=1;j--)dat[1][i][j]=max({sum[i][j+k-1],dat[1][i-1][j],dat[1][i][j+1]});
	for(int i=n-k+1;i>=1;i--)for(int j=k;j<=m;j++)dat[2][i][j]=max({sum[i+k-1][j],dat[2][i+1][j],dat[2][i][j-1]});
	for(int i=n-k+1;i>=1;i--)for(int j=m-k+1;j>=1;j--)dat[3][i][j]=max({sum[i+k-1][j+k-1],dat[3][i+1][j],dat[3][i][j+1]});
	for(int i=k;i<=n;i++)for(int j=k;j<=m;j++)ans=max(ans,dat[0][i-k][m]+dat[2][i+1][m]+sum[i][j]);//情况一
	for(int i=k;i<=n;i++)for(int j=k;j<=m;j++)ans=max(ans,dat[0][n][j-k]+dat[1][n][j+1]+sum[i][j]);//情况二 
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ans=max(ans,dat[0][i][j]+dat[1][i][j+1]+dat[2][i+1][m]);//情况三 
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ans=max(ans,dat[0][i][m]+dat[2][i+1][j]+dat[3][i+1][j+1]);//情况四 
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ans=max(ans,dat[0][i][j]+dat[1][n][j+1]+dat[2][i+1][j]);//情况五 
	for(int i=1;i<=n;i++)for(int j=k;j<=m;j++)ans=max(ans,dat[0][n][j]+dat[1][i][j+1]+dat[3][i+1][j+1]);//情况六 
	cout<<ans;
}
```

---

## 作者：HuaKangyi (赞：2)


## 题面回顾：
[洛谷题面](https://www.luogu.com.cn/problem/P3625)
## 大体思路
这道题很良心，数据规模和时空限制都很小，这就让我想到了**递推+前缀和**，其实想清楚了本题就根本 _不~~是很~~难_ 。

一个矩形，分 $3$ 块，有 $6$ 种方法：![](https://cdn.luogu.com.cn/upload/image_hosting/nvxp2jiw.png)

分别在 $3$ 个部分中找的 $k × k$ 面积最大的，加起来就是答案。

## 细细道来
### 1.那么怎么表示这三个块中面积最大的呢？

就需要记录对于每个点，它左上，右上，左下，右下的四个部分中，最大的 $k × k$ 块的价值和：

      int a[1505][1505], b[1505][1505], c[1505][1505], d[1505][1505];
      //我的代码中a表示左上，b右上，c左下，d右下
      
### 2.怎么初始化这四个二维数组呢？

用一个 $s[ ][ ]$ 二维数组记录，$s[i][j]$ 表示以 $i$, $j$ 为右下角的 $k × k$ 正方形的石油储量之和。那么递推可以推出 $a$, $b$, $c$, $d$ :
```cpp
	//初始化s
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=m;j++){
			int x;
			cin >> x;
			s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+x;
        }
 	for(int i = n;i>=k;i--) for(int j = m;j>=k;j--) s[i][j]-=s[i-k][j]+s[i][j-k]-s[i-k][j-k];
        //初始化a
	for(int i = k;i<=n;i++) for(int j = k;j<=m;j++) a[i][j] = max(s[i][j], max(a[i-1][j], a[i][j-1]));
        //初始化b
	for(int i = k;i<=n;i++) for(int j = m;j>=k;j--) b[i][j] = max(s[i][j], max(b[i-1][j], b[i][j+1]));
        //初始化c
	for(int i = n;i>=k;i--) for(int j = k;j<=m;j++) c[i][j] = max(s[i][j], max(c[i+1][j], c[i][j-1]));
        //初始化d
	for(int i = n;i>=k;i--) for(int j = m;j>=k;j--) d[i][j] = max(s[i][j], max(d[i+1][j], d[i][j+1]));
```
### 3.怎么递推更新这四个数组的最大值？
得到 $a$, $b$, $c$, $d$ 以后就分 $6$ 个情况更新最大值，详情：
#### 图1：
    for(int i = k;i<=n-k;i++) for(int j = k;j<=m-k;j++) ans = max(ans, a[i][j]+b[i][j+k]+c[i+k][m]);
#### 图2：
    for(int i = k;i<=n-k;i++) for(int j = k;j<=m-k;j++) ans = max(ans, a[i][m]+c[i+k][j]+d[i+k][j+k]);
#### 图3：
    for(int i = k;i<=n-k;i++) for(int j = k;j<=m-k;j++) ans = max(ans, a[i][j]+b[n][k+j]+c[i+k][j]);
#### 图4：
    for(int i = k;i<=n-k;i++) for(int j = k;j<=m-k;j++) ans = max(ans, a[n][j]+b[i][j+k]+d[i+k][j+k]);
#### 图5：
    for(int i = k;i<=n-k;i++) for(int j = k+k;j<=m-k;j++) ans = max(ans, a[n][j-k]+b[n][j+k]+s[i][j]);
#### 图6：
    for(int i = k+k;i<=n-k;i++) for(int j = k;j<=m-k;j++) ans = max(ans, a[i-k][m]+c[i+k][m]+s[i][j]);
![](https://cdn.luogu.com.cn/upload/image_hosting/5i9tdd2r.png)
## 完整代码-C++
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, k, a[1705][1705], b[1705][1705], c[1705][1705], d[1705][1705], s[1705][1705];
signed main(){
    ios::sync_with_stdio(0);
    cin >> n >> m >> k;
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=m;j++){
            int x;
            cin >> x;
            s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+x;
        }
    }
    //初始化abcds
    for(int i = n;i>=k;i--){
        for(int j = m;j>=k;j--){
            s[i][j]-=s[i-k][j]+s[i][j-k]-s[i-k][j-k];
        }
    }
    for(int i = k;i<=n;i++){
        for(int j = k;j<=m;j++){
            a[i][j] = max(s[i][j], max(a[i-1][j], a[i][j-1]));
        }
    }
    for(int i = k;i<=n;i++){
        for(int j = m;j>=k;j--){
            b[i][j] = max(s[i][j], max(b[i-1][j], b[i][j+1]));
        }
    }
    for(int i = n;i>=k;i--){
        for(int j = k;j<=m;j++){
            c[i][j] = max(s[i][j], max(c[i+1][j], c[i][j-1]));
        }
    }
    for(int i = n;i>=k;i--){
        for(int j = m;j>=k;j--){
            d[i][j] = max(s[i][j], max(d[i+1][j], d[i][j+1]));
        }
    }
    //递推求值
    int ans = 0;
    for(int i = k;i<=n-k;i++){
        for(int j = k;j<=m-k;j++){
            ans = max(ans, a[i][j]+b[i][j+k]+c[i+k][m]);
        }
    }
    for(int i = k+k;i<=n;i++){
        for(int j = k;j<=m-k;j++){
            ans = max(ans, c[i][j]+d[i][j+k]+a[i-k][m]);
        }
    }
    for(int i = k+k;i<=n-k;i++){
        for(int j = k;j<=m;j++){
            ans = max(ans, s[i][j]+a[i-k][m]+c[i+k][m]);
        }
    }
    for(int i = k;i<=n-k;i++){
        for(int j = k;j<=m-k;j++){
            ans = max(ans, a[i][j]+c[i+k][j]+b[n][j+k]);
        }
    }
    for(int i = k;i<=n-k;i++){
        for(int j = k+k;j<=m;j++){
            ans = max(ans, a[n][j-k]+b[i][j]+d[i+k][j]);
        }
    }
    for(int i = k;i<=n-k;i++){
        for(int j = k+k;j<=m-k;j++){
            ans = max(ans, s[i][j]+a[n][j-k]+b[n][j+k]);
        }
    }
    cout << ans;
    return 0;
}
```
## 祝大家AC愉快！
![](https://cdn.luogu.com.cn/upload/image_hosting/37j1pwtg.png)

---

## 作者：Melo_DDD (赞：1)

这个人因为读入读反调了半天。
# 题目大意
从一个 $M\times N$ 的矩形中选出三个不相交的 $K\times K$ 的矩形，使他们的和最大。

千万注意是 $M$ 行 $N$ 列，如果反了你会像这个人一样获得 $80$ 分的高分。

吐槽数据过水，反了还能拿 $80$。
# 题目实现
手模一下题目不难发现三个矩形的分布其实只有以下六种情况（下面的颜色没有区别）：

![](https://cdn.luogu.com.cn/upload/image_hosting/c4b0b8y7.png?x-oss-process=image/resize,m_lfit,h_1700,w_2025)

所以我们可以直接分类讨论，枚举这六种情况。

矩形的和可以用二维前缀和数组维护。

怎么把这几种情况表示出来？可以开四个二维数组 $a$、$b$、$c$、$d$，分别表示整个矩形中当前点 $(i,j)$ 左上、右上、左下、右下的部分中最大的 $K\times K$ 子矩形和（可能有点拗口，自己理解一下）。

懒得算数据，就开了 long long。

注：上述六种情况用 $a$、$b$、$c$、$d$ 可以有很多种表示方法，我写的只是其中一种。

剩下的讲解放到代码里：


```cpp
#include <bits/stdc++.h>
#define int long long
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x)) 
using namespace std ;
template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	} 
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
}
const int N = 1507 ;
int s[N][N] ,n ,m ,a[N][N] ,b[N][N] ,c[N][N] ,d[N][N] ,sum[N][N] ,k ;
signed main () {
	int p ;
	read (n) ,read (m) ,read (k) ;
	f (i ,1 ,n ,1) {
		f (j ,1 ,m ,1) {
			read (p) ;
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + p ;
		}
	} // 二维前缀和数组 sum[i][j] 表示以 (i,j) 为右下角的子矩形的和，可以用容斥求得
	f (i ,k ,n ,1) {
		f (j ,k ,m ,1) {
			s[i][j] = sum[i][j] - sum[i - k][j] - sum[i][j - k] + sum[i - k][j - k] ;
		}
	} // s[i][j] 表示以 (i,j) 为右下角的 K * K 的子矩形和（仍然是容斥）
	f (i ,k ,n ,1) {
		f (j ,k ,m ,1) {
			a[i][j] = max (s[i][j] ,max (a[i - 1][j] ,a[i][j - 1])) ;
		}
	} // a 数组可以看做是从左上向右下扫，记得取 max
	f (i ,k ,n ,1) {
		for (int j = m - k + 1 ;j ;j --) {
			b[i][j] = max (s[i][j + k - 1] ,max (b[i - 1][j] ,b[i][j + 1])) ;
		}
	} 
	for (int i = n - k + 1 ;i ;i --) {
		f (j ,k ,m ,1) {
			c[i][j] = max (s[i + k - 1][j] ,max (c[i + 1][j] ,c[i][j - 1])) ;
		}
	}
	for (int i = n - k + 1 ;i ;i --) {
		for (int j = m - k + 1 ;j ;j --) {
			d[i][j] = max (s[i + k - 1][j + k - 1] ,max (d[i + 1][j] ,d[i][j + 1])) ;
		}
	} // b、c、d 同理
	int ans (0) ;
	f (i ,k ,n ,1) {
		f (j ,k ,m ,1) {
			ans = max (ans ,s[i][j] + a[i - k][m] + c[i + 1][m]) ;
			ans = max (ans ,s[i][j] + a[n][j - k] + b[n][j + 1]) ; 
		}
	} // 两条横线、两条竖线的情况，看图
	f (i ,1 ,n ,1) {
		f (j ,1 ,m ,1) {
			ans = max (ans ,a[i][j] + b[i][j + 1] + c[i + 1][m]) ;
			ans = max (ans ,a[i][j] + b[n][j + 1] + c[i + 1][j]) ;
			ans = max (ans ,a[i][m] + c[i + 1][j] + d[i + 1][j + 1]) ;
			ans = max (ans ,a[n][j] + b[i][j + 1] + d[i + 1][j + 1]) ;
		}
	} // 剩下四种情况
	cout << ans << '\n' ;
	return 0 ;
}
```

---

## 作者：xs_siqi (赞：1)

提供一个结合动态规划，单调队列维护状态，二维前缀和和二维前缀最大值的新方法。

感觉这题跟去年 NOIP 种花很像啊。

首先我们发现一个正方形如果占了一个位置，会影响到后面的正方形放的地方，所以贪心显然是错误的。然后我们考虑 dp。

![](https://cdn.luogu.com.cn/upload/image_hosting/iefxh847.png)

我们大概需要考虑上面几种情况。

我们记三个正方形的水平位置分别为 $w_1,w_2,w_3$，垂直位置为 $h_1,h_2,h_3$。我们钦定 $h_1<h_2<h_3$。

对于情况 $1,5$ 其实非常套路。首先我们发现 $1,5$ 转一转就是一样的，所以只要考虑一类就可以了。

令 $f_{i,j,l}$ 表示考虑到位置 $(i,j)$，以 $(i,j)$ 为右下角建一个正方形，并且目前已经有 $l$ 个正方形的情况。

显然有 $f_{i,j,l}=f_{a,b,l-1},f_{c,d,l-1},a\in [1,i-k],b\in [1,j],c\in [1,i],d\in [1,j-k]+p$，$p$ 是你选目前这个正方形的收益。

这条式子的大概意思就是你可以从这个正方形的左上角任意选一个状态来转移。

我们发现这个复杂度直接起飞了，超级大神有水平的。所以我们稍微对 $f$ 数组记一个前缀最大值，然后方程就变成了：

$f_{i,j,l}=f_{i-k,j,l-1},f_{i,j-k,l-1}+p$。$p$ 的意思上面写过了。

然后考虑怎么求这个 $p$。我们发现其实可以直接二维前缀和。那么就会有 $p=sum_{i,j}-sum_{i-k,j}-sum_{i,j-k}+sum_{i-k,j-k}$。

---

然后这题的难点其实在怎么求 $2,3,4$ 的情况。我们发现我们可以处理一个右上角为 $(i,j)$ 的正方形的最大值，记为 $zs$ 好了。

那么对于一个即将转移的正方形，对于情况 $3$ 就会有 $g_{i,j}=f_{i-k,j,0}+zs_{i-k+1,j-k}$ 了。如果无法理解这个式子可以画图画一画。

类似地，对于情况 $4$ 就有 $g_{i,j}=f_{i-k,j,0}+zs_{i+1,j}$。

然后我们发现难点在于情况 $2$ 要怎么求。我们发现这个式子是：

$g_{i,j}=f_{l,j-k,0}+zs_{l+1,j-k},l\in [i-k,i-1]$。

然后我们发现这个区间长度是固定的，所以采用单调队列来优化即可。这样就是 $O(mn)$ 的复杂度了。

然后还有其它的情况可以通过旋转得到。

下文中，我用 $yx_{i,j}$ 代替了上述情况的 $f_{i,j,0}$。这个 $g$ 数组之间好像也没有转移，所以直接统计到 $ans$ 里了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1505;
int m,n,k,ans,q[maxn],a[maxn][maxn],b[maxn][maxn],yx[maxn][maxn],zs[maxn][maxn],f[maxn][maxn][3],sum[maxn][maxn],sum2[maxn][maxn];
void turn(){
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			b[m-j+1][i]=a[i][j];
	swap(n,m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=b[i][j];
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int L=1;L<=4;L++){
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				sum2[i][j]=sum[i][j]=yx[i][j]=zs[i][j]=f[i][j][0]=f[i][j][1]=f[i][j][2]=0;
		turn();
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		for(int i=n;i>=1;i--)
			for(int j=1;j<=m;j++)
				sum2[i][j]=a[i][j]+sum2[i+1][j]+sum2[i][j-1]-sum2[i+1][j-1];
		for(int i=k;i<=n;i++)
			for(int j=k;j<=m;j++)
				yx[i][j]=max(max(yx[i-1][j],yx[i][j-1]),
				sum[i][j]-sum[i-k][j]-sum[i][j-k]+sum[i-k][j-k]),
				f[i][j][0]=yx[i][j];
		for(int i=n-k+1;i>=1;i--)
			for(int j=k;j<=m;j++)
				zs[i][j]=max(max(zs[i+1][j],zs[i][j-1]),
				sum2[i][j]-sum2[i+k][j]-sum2[i][j-k]+sum2[i+k][j-k]);
		for(int i=k;i<=n;i++)
			for(int j=k;j<=m;j++)
				f[i][j][1]=max(max(f[i-k][j][0],f[i][j-k][0])+sum[i][j]-sum[i-k][j]-sum[i][j-k]+sum[i-k][j-k],
							max(f[i-1][j][1],f[i][j-1][1])),
				f[i][j][2]=max(max(f[i-k][j][1],f[i][j-k][1])+sum[i][j]-sum[i-k][j]-sum[i][j-k]+sum[i-k][j-k],
							max(f[i-1][j][2],f[i][j-1][2])),
				ans=max(ans,f[i][j][2]);
		for(int j=k;j<=m;j++){
			int h=1,t=0;
			for(int i=k;i<=n;i++){
				while(h<=t&&q[h]<i-k)h++;
				while(h<=t&&yx[q[t]][j-k]+zs[q[t]+1][j-k]<=yx[i][j-k]+zs[i+1][j-k])t--;
				q[++t]=i;
				ans=max(ans,
				max(max(yx[q[h]][j-k]+zs[q[h]+1][j-k],max(yx[i-k][j]+zs[i-k+1][j-k],yx[i][j-k]+zs[i+1][j])),yx[i-k][j]+zs[i+1][j])
				+sum[i][j]-sum[i-k][j]-sum[i][j-k]+sum[i-k][j-k]);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

### 二维前缀和+dp
对于这个问题，因为一共要取三个边长的 $k$ 个互不相交的正方形并求三个正方形内元素之和的最大值。所以，对于三个正方形，共有 $6$ 中不同的选取方法。具体的图可以看楼上。

我们可以以左上、右上、左下、右下四个点为起点，求出四个起点到点 $(i,j)$ 时的二维前缀和，并求出这四个点为起点时，边长为 $k$ 的正方形的最大值。而对于当三个正方形为横或纵向排列的情况时，可以暴力枚举上下边界，再循环枚举中间部分的另一个纵坐标，利用前缀和求出中间部分的最大值即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,ans,ans2,a[2005][2005],s[2005][2005];
int dp1[2005][2005],dp2[2005][2005],dp3[2005][2005],dp4[2005][2005];
int rec_area(int x,int y,int x2,int y2){//矩阵内部元素求和(二维前缀和)
	return s[x2][y2]-s[x-1][y2]-s[x2][y-1]+s[x-1][y-1];
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//二维前缀和
		}
	}
  //用dp出以左上、右上、左下、右下四个点为起点时，边长为k的正方形的最大值
	for(int i=k;i<=n;i++){
		for(int j=k;j<=m;j++){
			dp1[i][j]=max(max(dp1[i-1][j],max(dp1[i-1][j-1],dp1[i][j-1])),rec_area(i-k+1,j-k+1,i,j));
		}
	}
	for(int i=n-k+1;i;i--){
		for(int j=k;j<=m;j++){
			dp2[i][j]=max(max(dp2[i+1][j],max(dp2[i][j-1],dp2[i+1][j-1])),rec_area(i,j-k+1,i+k-1,j));
		}
	}
	for(int i=k;i<=n;i++){
		for(int j=m-k+1;j;j--){
			dp3[i][j]=max(max(dp3[i-1][j],max(dp3[i][j+1],dp3[i-1][j+1])),rec_area(i-k+1,j,i,j+k-1));
		}
	}
	for(int i=n-k+1;i;i--){
		for(int j=m-k+1;j;j--){
			dp4[i][j]=max(max(dp4[i+1][j],max(dp4[i][j+1],dp4[i+1][j+1])),rec_area(i,j,i+k-1,j+k-1));
		}
	}
  //计算中间夹层面积
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ans=max(ans,max(dp1[i][j]+dp2[i+1][j]+dp3[n][j+1],max(dp1[n][j]+dp3[i][j+1]+dp4[i+1][j+1],max(dp1[i][m]+dp2[i+1][j]+dp4[i+1][j+1],dp1[i][j]+dp3[i][j+1]+dp2[i+1][m]))));
		}
	}
	for(int i=k;i<=n;i++){
		int maxn=0;
		for(int j=k;j<=m;j++){
			maxn=max(maxn,rec_area(i-k+1,j-k+1,i,j));
		}
		ans=max(ans,maxn+dp1[i-k][m]+dp2[i+1][m]);	
	}	
	for(int i=k;i<=m;i++){	
		int maxn=0;	
		for(int j=k;j<=n;j++){		
			maxn=max(maxn,rec_area(j-k+1,i-k+1,j,i));		
		}	
		ans2=max(ans2,maxn+dp1[n][i-k]+dp3[n][i+1]);		
	}
	cout<<max(ans,ans2)<<"\n";	
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：0)

先用 $-\inf$ 填充使得矩阵为边长为 $\max(n,m)$ 的方阵，然后就是 ABC347F。

不交不好处理，尝试用若干条线将 $3$ 个正方形划开成几个独立的问题做。

首选用直线划分，发现我们用两条线段即可。

证明就是考虑不交等价于在水平方向投影不交 或 竖直方向不交，在不交的部分划线即可。

然后就是 $6$ 种情况（抱走官方题解图）
![](https://img.atcoder.jp/abc347/c8c4557905764a04a59ff89c7b249746.png)

对于每种情况，枚举两条线的位置，我们只需求解同色矩形中的最大权 $m \times m$ 方阵即可。

前缀和后转化为静态矩形最值，但是由于查询矩形是特殊的，所以我们可以通过 $O(n^2)$ 预处理前缀最值做到 $O(1)$ 回答。

有一些细节。

此外，本题较 ABC347F 卡空间，所以实现时要重复使用一些空间。
```cpp
const int inf=1<<30;
const LL infLL=(LL)4e18;
il void Solve()
{
  auto[a,n,m,K]=[&]
  {
    int n,m,K,N,M;
    rd(N),rd(M),rd(m),n=max(N,M),K=n-m+1;
    ve<ve<LL>>a(n,ve<LL>(n,-inf)),b(K,ve<LL>(K));
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) if(i<N&&j<M) rd(a[i][j]);
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) {
      if(i) a[i][j]+=a[i-1][j];
      if(j) a[i][j]+=a[i][j-1];
      if(i&&j) a[i][j]-=a[i-1][j-1];
    }
    for(int i=0;i<K;++i) for(int j=0;j<K;++j) {
      // [i,i+m) & [j,j+m)
      int I=i+m-1,J=j+m-1;
      b[i][j]=a[I][J];
      if(i) b[i][j]-=a[i-1][J];
      if(j) b[i][j]-=a[I][j-1];
      if(i&&j) b[i][j]+=a[i-1][j-1];
    }
    return make_tuple(b,n,m,K);
  }();
  LL ans=0;
  ve<LL>mxi(K),mxj(K);
  for(int i=0;i<K;++i) for(int j=0;j<K;++j) cx(mxi[i],a[i][j]),cx(mxj[j],a[i][j]);
  [&]
  {
    ve<ve<LL>>mif(K,ve<LL>(K+1,-infLL)),mjf=mif;
    for(int l=0;l<K;++l) for(int r=l+1;r<=K;++r) mif[l][r]=max(mif[l][r-1],mxi[r-1]);
    for(int l=0;l<K;++l) for(int r=l+1;r<=K;++r) mjf[l][r]=max(mjf[l][r-1],mxj[r-1]);
    auto _Q=[&](int k,int l,int r){return assert(l<r),k?mjf[l][r]:mif[l][r];};
    for(int i=m;i<=n-m;++i) for(int j=i+m;j<=n-m;++j) {
      // [0,i) [i,j) [j,n) -> [0,i-m] [i,j-m] [j,n-m]
      for(int k:{0,1}) cx(ans,_Q(k,0,i-m+1)+_Q(k,i,j-m+1)+_Q(k,j,n-m+1));
    }
  }();
  ve<ve<ve<LL>>>mx(4,ve<ve<LL>>(K,ve<LL>(K,-infLL)));
  // 0 1
  // 3 2
  const int fx[]={-1,-1,1,1},fy[]={-1,1,1,-1};
  for(int k=0;k<4;++k) {
    mx[k]=a;
    for(int i=fx[k]>0?K-1:0;0<=i&&i<K;i-=fx[k])
      for(int j=fy[k]>0?K-1:0;0<=j&&j<K;j-=fy[k]) {
        int I=i+fx[k],J=j+fy[k];
        if(0<=I&&I<K) cx(mx[k][i][j],mx[k][I][j]);
        if(0<=J&&J<K) cx(mx[k][i][j],mx[k][i][J]);
      }
  }
  ve<LL>ipre(K+1),isuf(K+1),jpre(K+1),jsuf(K+1);
  for(int i=0;i<K;++i) ipre[i+1]=max(ipre[i],mxi[i]),jpre[i+1]=max(jpre[i],mxj[i]);
  for(int i=K-1;~i;--i) isuf[i]=max(isuf[i+1],mxi[i]),jsuf[i]=max(jsuf[i+1],mxj[i]);
  auto _Q=[&](int k,int l,int r)
  {
    assert(!l||r==K);
    return k?l?jsuf[l]:jpre[r]:l?isuf[l]:ipre[r];
  };
  // cross
  for(int i=m;i<=n-m;++i) for(int j=m;j<=n-m;++j) {
    // [0,x) [x,n) -> [0,x-m] [x,n-m]
    cx(ans,_Q(0,0,i-m+1)+mx[3][i][j-m]+mx[2][i][j]);
    cx(ans,_Q(0,i,n-m+1)+mx[0][i-m][j-m]+mx[1][i-m][j]);
    cx(ans,_Q(1,0,j-m+1)+mx[1][i-m][j]+mx[2][i][j]);
    cx(ans,_Q(1,j,n-m+1)+mx[0][i-m][j-m]+mx[3][i][j-m]);
  }
  wrt(ans);
  return;
}
```
[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/155729189)

---

## 作者：cqbzrjx (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P3625)

# 分析

这道题是典型的**二维前缀和**例题。对于这个问题，题目要求我们求出**三个** $k \times k$ 个范围区域内总和的**最大值**。

![](https://cdn.luogu.com.cn/upload/image_hosting/astrkj80.png)

对此，我们有上面的**六种**取法，在不同的情况下取最大值。以**左上、右上、左下、右下**四个方向为起点，并求出分别起点到 $(i,j)$ 的二维前缀和，在到达 $(i,j)$ 的区域后，计算 $k \times k$ 的正方形最大值即可。

# AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2005;//数据范围 
int n,m,k,ans;//n,m,k看题，ans为最大值
int mp[maxn][maxn],sum[maxn][maxn];//mp为矩形，sum为二维前缀和 
int lu[maxn][maxn],ld[maxn][maxn],ru[maxn][maxn],rd[maxn][maxn];//lu,ld,ru,rd表示四个方向 
int l[maxn];
inline int alc(int x,int y)
{
	return sum[x][y] - sum[x - k][y] - sum[x][y - k] + sum[x - k][y - k];//求k*k范围面积值 
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n>>m>>k;//输入 
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			cin>>mp[i][j];//输入 
		}
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mp[i][j];//计算前缀和 
		}
	}
	//四个方向预处理计算最大值再汇总 
	for(int i = k;i <= n;i++)
	{
		for(int j = k;j <= m;j++)
		{
			lu[i][j] = max(alc(i,j),max(lu[i][j - 1],lu[i - 1][j]));//计算左上最大值 
		}
		for(int j = m;j >= k;j--)
		{
			ru[i][j - k] = max(alc(i,j),max(ru[i - 1][j - k],ru[i][j - k + 1]));//计算右上最大值
		}
	}
	for(int i = n;i >= k;i--)
	{
		for(int j = k;j <= m;j++)
		{
			ld[i - k][j] = max(alc(i,j),max(ld[i - k][j - 1],ld[i - k + 1][j]));//计算左下最大值
		}
		for(int j = m;j >= k;j--)
		{
			rd[i - k][j - k] = max(alc(i,j),max(rd[i - k][j - k + 1],rd[i - k + 1][j - k]));//计算右下最大值
		}
	}
	//然后六种情况暴力取最大值 
	for(int i = k;i <= n - k + 1;i++)
	{
		for(int j = k;j <= m - k + 1;j++)
		{
			ans = max(ans,lu[i][m] + ld[i][j] + rd[i][j]);//第一种情况 
			ans = max(ans,lu[i][j] + ru[i][j] + ld[i][m]);//第二种情况
			ans = max(ans,lu[i][j] + ld[i][j] + ru[n][j]);//第三种情况 
			ans = max(ans,lu[n][j] + ru[i][j] + rd[i][j]);//第四种情况
		}
	}
	for(int i = k;i <= n - k;i++)
	{
		for(int j = 1;j <= m - k;j++)
		{
			ans = max(ans,lu[i][m] + ld[i + k][m] + alc(i + k,j + k));//第五种情况
		}
	}
	for(int i = 1;i <= n - k;i++)
	{
		for(int j = k;j <= m - k;j++)
		{
			ans = max(ans,lu[n][j] + ru[n][j + k] + alc(i + k,j + k));//第六种情况
		}
	}
	cout<<ans<<endl;//输出 
	return 0;//完结，撒花 
}
```

---

## 作者：MrPython (赞：0)

三个矩形之间的相对位置可以用这两种情况概括，其他的所有情况都可以由原矩阵旋转而得：![1712459176554.png](https://img2.imgtp.com/2024/04/07/YtpWdFfC.png)

在此之前，我们先将 $b_{x,y}=\sum_{i=x}^{x+k}\sum_{j=y}^{y+k}a_{i,j}\space(x\leq n-k+1,y\leq m-k+1)$ 用二维前缀和预处理出来。时间复杂度 $O(nm)。$

先来看求第一种情况。先预处理求任意两行之间的最大值（$d_{x,s}=\max_{i=x}^{x+s}\max_{j=1}^{m-k+1}b_{i,j}$，可以求出每行的最大值后对着这个数组 DP）。然后，枚举中间的两条分割线，求三个区间内的最大值之和，注意区间间距离不应小于 $k$。总时间复杂度 $O(n^2+nm)$。

对于第二种，DP 预处理出左上角矩形的最大值 $ul_{x,y}=\max_{i=1}^{x}\max_{j=1}^{y}b_{i,j}$ 、右上角矩形最大值 $ur_{x,y}=\max_{i=1}^{x}\max_{j=y}^{m-k+1}b_{i,j}$ 与下方若干行的最大值 $d_x=\max_{i=x}^{n-k+1}\max_{j=1}^{m-k+1}b_{i,j}$。枚举两条线求即可。时间复杂度 $O(nm)$。

以上操作都需要旋转 4 次分别进行。总程序时间复杂度 $O(n^2+m^2+nm)$。
```cpp
#include<bits/extc++.h>
using namespace std;
namespace pbds=__gnu_pbds;
using ui=unsigned int;
using uli=unsigned long long int;
using li=long long int;
template<typename T> class PrefixSum2D{
    vector<vector<T>> sum;
public:
    template<typename S>
    PrefixSum2D(vector<vector<S>> const& a):sum(a.size()+1,vector<T>(a.front().size()+1)){
        size_t const n=a.size(),m=a.front().size();
        for (size_t i=0;i<n;i++) for (size_t j=0;j<m;j++)
            sum[i+1][j+1]=sum[i+1][j]+sum[i][j+1]-sum[i][j]+a[i][j];
    }
    T get_sum(size_t ax,size_t ay,size_t bx,size_t by) const{
        return sum[bx][by]+sum[ax][ay]-sum[ax][by]-sum[bx][ay];
    }
};
ui f(size_t n,size_t m,size_t k,vector<vector<ui>> const& a){
    vector<vector<ui>> ul(n,vector<ui>(m)),
                        ur(n,vector<ui>(m));
    ul[0][0]=a[0][0];
    for (size_t i=1;i<n;++i) ul[i][0]=max(ul[i-1][0],a[i][0]);
    for (size_t j=1;j<m;++j) ul[0][j]=max(ul[0][j-1],a[0][j]);
    for (size_t i=1;i<n;++i) for (size_t j=1;j<m;++j)
        ul[i][j]=max({ul[i-1][j],ul[i][j-1],a[i][j]});
    ur[0][m-1]=a[0][m-1];
    for (size_t i=1;i<n;++i) ur[i][m-1]=max(ur[i-1][m-1],a[i][m-1]);
    for (size_t j=m-2;j<m;--j) ur[0][j]=max(ur[0][j+1],a[0][j]);
    for (size_t i=1;i<n;++i) for (size_t j=m-2;j<m;--j)
        ur[i][j]=max({ur[i-1][j],ur[i][j+1],a[i][j]});
    vector<ui> d(n);
    d[n-1]=*max_element(a[n-1].cbegin(),a[n-1].cend());
    for (size_t i=n-2;i<n;--i) d[i]=max(d[i+1],*max_element(a[i].cbegin(),a[i].cend()));
    ui ans=numeric_limits<ui>::min();
    for (size_t i=0;i+k<n;++i) for (size_t j=0;j+k<m;++j)
        ans=max(ans,ul[i][j]+ur[i][j+k]+d[i+k]);
    return ans;
}
ui g(size_t n,size_t m,size_t k,vector<vector<ui>> const& a){
    vector<ui> mx(n);
    for (size_t i=0;i<n;++i) mx[i]=*max_element(a[i].begin(),a[i].end());
    vector<vector<ui>> d(n);
    for (size_t i=0;i<n;++i){
        d[i].push_back(mx[i]);
        for (size_t j=i+1;j<n;++j)
            d[i].push_back(max(mx[j],d[i].back()));
    }
    ui ans=numeric_limits<ui>::min();
    for (size_t i=0;i+k<n;++i) for (size_t j=i+k;j+k<n;++j)
        ans=max(ans,d[0][i-0]+d[i+k][j-(i+k)]+d[j+k][n-1-(j+k)]);
    return ans;
}
vector<vector<ui>> rotate(size_t n,size_t m,vector<vector<ui>> const& x){
    vector<vector<ui>> y(m,vector<ui>(n));
    for (size_t i=0;i<m;++i) for (size_t j=0;j<n;++j)
        y[i][j]=x[j][m-i-1];
    return y;
}
int main(void){
    ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    size_t h,w,m;cin>>h>>w>>m;
    vector<vector<ui>> a(h,vector<ui>(w));
    for (vector<ui>& i:a) for (ui& j:i) cin>>j;
    size_t kh=h-m+1,kw=w-m+1;
    vector<vector<ui>> b(kh,vector<ui>(kw));
    {
        PrefixSum2D<ui> s(a);
        for (size_t i=0;i<kh;++i) for (size_t j=0;j<kw;++j)
            b[i][j]=s.get_sum(i,j,i+m,j+m);
    }
    cout<<max({f(kh,kw,m,b),g(kh,kw,m,b),
               f(kw,kh,m,rotate(kh,kw,b)),g(kw,kh,m,rotate(kh,kw,b)),
               f(kh,kw,m,rotate(kw,kh,rotate(kh,kw,b))),g(kh,kw,m,rotate(kw,kh,rotate(kh,kw,b))),
               f(kw,kh,m,rotate(kh,kw,rotate(kw,kh,rotate(kh,kw,b)))),g(kw,kh,m,rotate(kh,kw,rotate(kw,kh,rotate(kh,kw,b))))});
    return 0;
}
```

---

## 作者：ynxynx (赞：0)

**本人随机跳题跳到的**

[题目传送门](https://www.luogu.com.cn/problem/P3625)

题意:找三个边长为k的不重叠的正方形，求最大和。

##题解：

献上丑图：

![](https://cdn.luogu.com.cn/upload/image_hosting/duwyhzsy.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

第一种：左，右上，右下。

第二种：左上，左下，右。

第三种：左，中，右。

黄红蓝代表三个区域，可旋。

我们就在每种里面挑三个区域内的正方形，对于每种情况，枚举即可(解析都写在代码里)。

比如：

1 1 1 1  1 1 1 1 1 

1 1 1 1  1 1 1 1 1 

1 8 8 8  8 8 1 1 1 

1 8 8 8  8 8 1 1 1 

---
1 8 8 8 | 8 8 1 1 1 

1 1 1 1 | 8 8 8 1 1 

1 1 1 1 | 1 1 **8 8 8** 

1 1 1 1 | 1 1 **9 9 9** 

1 1 1 1 | 1 1 **9 9 9**

---
我们尝试用二维前缀和来处理每一个矩阵内的和，这样可以减少代码难度和时间。

代码过丑,不喜勿喷。（我用IDE写的，支持洛谷）

```
#include<bits/stdc++.h>
using namespace std;
int dp[1801][1801][5],f[1801][1801],a[1801][1801],n,m,k,f1[1801],f2[1801];//dp[i][j][k]表示以(i,j)为第k个顶点，f[i][j]为前缀和数组(左上角)
#define s(i,j) f[i][j]-f[i][j-k]-f[i-k][j]+f[i-k][j-k]//计算以(i,j)为右下角的收益(小学学过的容斥原理)
void csh(){//计算
    for (int i=n-k+1;i;i--) {
        for (int j=m-k+1;j;j--) dp[i][j][1]=max(dp[i+1][j][1],max(dp[i][j+1][1],max(dp[i+1][j+1][1],s(i+k-1,j+k-1))));//左上
        for (int j=k;j<=m;j++) dp[i][j][2]=max(dp[i+1][j][2],max(dp[i][j-1][2],max(dp[i+1][j-1][2],s(i+k-1,j))));//右上
    }//把它们合在一起了,下同
    for (int i=k;i<=n;i++){
        for (int j=m-k+1;j;j--) dp[i][j][3]=max(dp[i-1][j][3],max(dp[i][j+1][3],max(dp[i-1][j+1][3],s(i,j+k-1))));//左下
        for (int j=k;j<=m;j++) dp[i][j][4]=max(dp[i-1][j][4],max(dp[i][j-1][4],max(dp[i-1][j-1][4],s(i,j))));//右下
    }
    for (int i=k;i<=m;i++) for (int j=k;j<=n;j++) f1[i]=max(f1[i],f[j][i]-f[j-k][i]-f[j][i-k]+f[j-k][i-k]);//中间的某列
    for (int i=k;i<=n;i++) for (int j=k;j<=m;j++) f2[i]=max(f2[i],f[i][j]-f[i-k][j]-f[i][j-k]+f[i-k][j-k]);//中间的某行
}
int put(){
    int ans=0;//枚举
    for (int i=k;i<=m-2*k;i++) ans=max(ans,dp[n][i][4]+f1[i+k]+dp[1][i+k+1][1]);
    for (int i=k;i<=m-2*k;i++) for (int j=k;j<=n-k;j++) ans=max(ans,dp[n][i][4]+dp[j][i+1][3]+dp[j+1][i+1][1]);
    for (int i=k+1;i<=m-k+1;i++) for (int j=k;j<=n-k;j++) ans=max(ans,dp[n][i][3]+dp[j][i-1][4]+dp[j+1][i-1][2]);
    for (int i=k;i<=n-2*k;i++) ans=max(ans,dp[i][m][4]+f2[i+k]+dp[i+k+1][1][1]);
    for (int i=k;i<=n-2*k;i++) for (int j=k;j<=m-k;j++) ans=max(ans,dp[i][m][4]+dp[i+1][j][2]+dp[i+1][j+1][1]);
    for (int i=k+1;i<=n-k+1;i++) for (int j=k;j<=m-k;j++) ans=max(ans,dp[i-1][j][4]+dp[i-1][j+1][3]+dp[i][1][1]);
    return ans;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);//输入输出优化,加不加无所谓,上同
    cin>>n>>m>>k;
    for (int i=1;i<=n;i++) for (int j=1;j<=m;j++){
        cin>>a[i][j];
        f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j];//处理前缀和
    }
    csh();//初始化dp数组
    cout<<put();//求和
    return 0;//结束
}
```

[给个记录](https://www.luogu.com.cn/record/68858349)

本人第 ```1``` 篇紫题题解,以前只交过橙题。

管理员审核辛苦了，望给过。

---


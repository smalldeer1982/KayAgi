# [CSP-S2019 江西] 多叉堆

## 题目背景

JXCSP-S T5

## 题目描述

多叉堆是一种树形数据结构，本题中我们只考虑小根堆，它满足除了根以外的结点，每个点的权值都不小于父亲的权值。除了叶结点，每个点有至少一个子结点。

初始时有 $n$ 个结点，编号分别为 $0 \sim n - 1$，每个结点都是一棵以自身为根的单点树。接下来按顺序有 $q$ 次操作，每次操作有以下两种：

* `1 x y`：选择不在同一棵树里的结点 $x$ 和 $y$，将 $x$ 所在树的根直接接在 $y$ 所在树的根之下，此时 $x$ 和 $y$ 所在树将合并为同一棵树。

* `2 x`：选择结点 $x$，设 $x$ 当前所在树的结点数为 $size$。你需要计算将 $0 \sim size - 1$ 这 $size$ 个数分别填入 $x$ 所在树的结点中，能够产生多少种不同的多叉堆。两种堆不同当且仅当存在某个结点填入的值不同。由于答案可能很大，你只需要求出答案模 $10^9+7$ 后的结果。

## 说明/提示

#### 【输入输出样例 1 说明】

第 $1$ 次操作时，将 $1$ 所在树的根 $1$ 接在 $0$ 所在树的根 $0$ 下。 

第 $2$ 次操作时，将 $2$ 所在树的根 $2$ 接在 $0$ 所在树的根 $0$ 下。   

第 $3$ 次操作时，$1$ 所在树如图 $1$，在 $0,1,2$ 中分别填入 $[0,1,2]$ 和 $[0,2,1]$ 可以产生 $2$ 种不同的堆。    

第 $4$ 次操作时 $x=(3+2) \bmod 5=0$，$y=(1+2) \bmod 5=3$，将 $0$ 所在树的根 $0$ 接在 $3$ 所在树的根 $3$ 下。   

第 $5$ 次操作 时，$x=(2+2) \bmod 5=4$，$y=(0+2) \bmod 5=2$，将 $4$ 所在树的根 $4$ 接在 $2$ 所在树的根 $3$ 下。    

第 $6$ 次操作 时，$x=(4+2) \bmod 5=1$，$1$ 所在树如图 $2$，在 $0\sim 4$ 中分别填入 $[1,2,3,0,4]$，$[1,3,2,0,4]$，$[1,2,4,0,3]$，$[1,4,2,0,3]$，$[1,3,4,0,2]$，$[1,4,3,0,2]$，$[2,4,3,0,1]$，$[2,3,4,0,1]$ 可以产生 $8$ 种不同的堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/mqsr3nri.png)

#### 【数据规模与约定】

对于 $100\%$ 的数据，$0\le x',y' <n \le 3\times 10^5$，$1\le Q\le 3\times 10^5$。

对于不同测试点，我们约定

![](https://cdn.luogu.com.cn/upload/image_hosting/44j0elzy.png)


特殊性质 $1$：存在 $1\le i<n $，前 $i$ 次操作均为 $1$ 操作，之后全是 $2$ 操作。

特殊性质 $2$：对于所有输入 $x$ 和 $y$ 本身即是其所在树的根。

感谢 @Fairicle 提供的数据。

## 样例 #1

### 输入

```
5 6
1 1 0
1 2 0
2 1
1 3 1
1 2 0
2 4```

### 输出

```
2
8
```

# 题解

## 作者：zimujun (赞：33)

### 写在前面

- OI 生涯中 AC 的首道组合数学应用题。

- 开题 5min 发现规律，写了半下午代码，调了两天，然而甚至没过样例，心态崩了。几天之后重新写了一份代码才 AC。

- 虽然思维难度不大，但毕竟是联赛题，题目质量还是很高的。涉及到了很多组合数学的基础算法，写完之后感觉学到了很多。感觉这道题是道不错的组合数学入门题。接下来我将会尽量详细地进行讲解。

### 数据结构

只有根节点的答案有用。任何一个节点在更新完其父亲结点的值后，其本身的任何值将不会再有任何改动或贡献，因此用并查集维护即可，记得路径压缩。

### 算法思路

解决这道题的关键，在于连接两个节点时答案的更新和与答案相关的值的维护。

设 $a_i$ 表示以 $i$ 为根节点的子树的填数方案总数。

假设当前连接的两个节点的编号分别是 $u,v$（保证两个节点都是根节点），且本次操作需要从 $u$ 接到 $v$ 上去。

比较显而易见的一点是，更新答案时，节点 $v$ 所处的位置，一定只能填 $0$。

维护 $w_i$ 表示以 $i$ 为根的树的重量，即节点数。将 $u$ 连接到 $v$ 上时，将 $w_v$ 的值加上 $w_u$。

那么填入原来的 $u$ 子树中的数字就有 $w_v - 1$ 选 $w_u$ 种不同的选择方案。剩下的数字填入原来的 $v$ 子树中。又原本 $u,v$ 子树中的填数总方案数分别为 $a_u,a_v$。那么根据乘法原理，就可以将 $a_v$ 更新为 $a_v \times a_u \times \binom{n}{m}$

### 组合数求法

1. 杨辉三角，加法，可以取模。但是这是 [P2822](https://www.luogu.com.cn/problem/P2822) 的组合数求法，需要用到二维数组，数组大小开不下，只能过 50% 的数据。

1. 直接根据组合数计算公式：

$$\binom{n}{m} = \frac{n!}{m!(n - m)!} $$

直接用计算式来求组合数。预处理出阶乘。等下，模意义下的乘法……要求逆元啊。线性递推求逆元可以参考 [P3811](https://www.luogu.com.cn/problem/P3811) 的题解。

这道题的除数是可以大到 $10^9 + 7$ 的，因此不能直接递推预处理逆元，但是只会用到阶乘的逆元，预处理这个即可。

那么怎么线性递推呢？看这里：（为了更好体现逆元的形式，式子中保证了分数分子上都是 $1$）

$$\frac{1}{i!} = \frac{1}{i\cdot(i - 1)!} = \frac{1}{i}\cdot\frac{1}{(i - 1)!}$$
$$\frac{1}{(i - 1)!} = i\cdot\frac{1}{i!}$$

因此，首先根据费马小定理推论用快速幂算出 $\frac{1}{n!}$ 随后倒序枚举预处理即可。

### Tips

- 节点编号是从 $0$ 开始的，记得初始化的时候把 $a_0,w_0$ 也一并设为 $1$。（我卡了几天就是因为这个）
- 注意输入格式，别忘了强制在线。
- 处理阶乘的逆元记得要枚举到 $0$，不然 $m = 0$ 的时候 $\binom{n}{m}$ 的值是错的。

### Code

代码可读性还是很高的。

```cpp
#include<bits/stdc++.h>
#define LL long long

using namespace std;

const int Maxn = 3e5 + 5;
const LL Mod = 1e9 + 7;

int n, q, opt, x, y;
int Ans;
LL a[Maxn] = {1};
int w[Maxn] = {1}; 

/*快速幂*/ 
inline LL qpow(LL b, LL p)
{
	if(p == 0) return 1;
	LL x = 1;
	for(; p;b *= b, b %= Mod,p >>= 1) if(p & 1) x *= b, x %= Mod;
	return x;
}

/*并查集*/
int fa[Maxn];

int find(int t)
{
	return fa[t] == t ? t : fa[t] = find(fa[t]);
}

/*数学*/
LL fac[Maxn] = {1};
LL invf[Maxn];

LL C(int N, int M)
{
	return 1ll * fac[N] % Mod * invf[M] % Mod * invf[N - M] % Mod;
}

/*预处理*/ 
void Setup()
{
	for(register int i = 1; i <= n; ++i)
	{
		fa[i] = i;
		w[i] = a[i] = 1;
		fac[i] = fac[i - 1] * i;
		fac[i] %= Mod;
	}
	invf[n] = qpow(fac[n], Mod - 2);
	for(register int i = n - 1; i >= 0; --i)
	{
		invf[i] = invf[i + 1] * (i + 1);
		invf[i] %= Mod;
	}
}

/*链接 处理答案*/
void line(int u, int v)
{
	w[v] += w[u];
	a[v] = a[v] * a[u] % Mod * C(w[v] - 1, w[u]) % Mod;
	fa[u] = v;
}

/*输出答案 更新强制在线值*/
void print(int t)
{
	Ans = (int)a[t];
	printf("%d\n", Ans);
} 

/*快速读入*/ 
inline int read()
{
	int f = 1, w = 0; char ch = getchar();
	for(; (ch < '0') || (ch > '9'); ch = getchar()) if(ch == '-') f = -1;
	for(; (ch >= '0') && (ch <= '9'); ch = getchar()) w = (w << 3) + (w << 1) + (int)(ch ^ '0');
	return f * w;
}

int main()
{
	n = read(); q = read();
	Setup();
	while(q--)
	{
		opt = read();
		if(opt == 1)
		{
			x = (read() + Ans) % n;
			y = (read() + Ans) % n;
			x = find(x); y = find(y);
			line(x, y); 
		}
		else
		{
			x = (read() + Ans) % n;
			x = find(x);
			print(x);
		}
	}
	return 0;
}
```

---

## 作者：银杉水杉秃杉 (赞：13)

今天这篇题解是我的第十篇题解（这是[我的博客](https://www.luogu.com.cn/blog/53022/)，欢迎大家去康（diao）康（da））

老规矩，先放一个[题目传送门](https://www.luogu.com.cn/problem/P5689)。

根据题目要求，我们很容易就能想到这是一道**并查集 + 组合数**的题，因为操作一是将节点 $x$ 连到 $y$ 下边，很像一个并查集。还要求组合数，所以还是个带权并查集。

我们用 $S_x$ 来表示以 $x$ 为根的子树大小（节点个数），$A_x$ 来表示以 $x$ 为根的子树的组合数，在操作一连接 $x$ 在 $y$ 下边时，$S_y'=S_y+S_x$，$A_y'=A_y×A_x×C_{S_y'-1}^{S_x}$（这里运用到了乘法原理）。值得注意的是：$C$ 下边是 $S_y'-1$，这是因为我们求组合数时，子树根的位置是不改变的，所以要 $-1$。

为了求组合数 $C$，我们要先预处理阶乘以及阶乘所对应的逆元。

（关于逆元，不会的朋友不妨先去看看 [P3811 乘法逆元](https://www.luogu.com.cn/problem/P3811)）

众所周知，求逆元有三种方法（**exgcd**，**费马小定理（快速幂）**，**线性算法**）。这道题我分别用到了其中的两种（费马小定理和线性算法）

**第一种：费马小定理（快速幂）**

```cpp
int qpow(int a,int b)
{
    int c=1;
    while (b)
    {
        if (b&1)
            c=c*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return c;
}
void init()
{
    fac[0]=1;//fac是阶乘
    for (int i=1;i<=n;i++)
    {
        f[i]=i;
        s[i]=a[i]=1;
        fac[i]=fac[i-1]*i%mod;
    }
    inf[n]=qpow(fac[n],mod-2);//fac[n]的逆元
    for (int i=n;i>=1;i--)//倒序阶乘逆元
        inf[i-1]=(inf[i]*i)%mod;
}
```

**第二种：线性算法**

```cpp
void init()
{
    fac[0]=1;//fac是阶乘
    for (int i=1;i<=n;i++)
    {
        f[i]=i;
        s[i]=a[i]=1;
        fac[i]=fac[i-1]*i%mod;
    }
    inv[1]=1;//inv是逆元
    for (int i=2;i<=n;i++)//线性求逆元
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    inf[0]=1;//inf是逆元的阶乘
    for (int i=1;i<=n;i++)
        inf[i]=inf[i-1]*inv[i]%mod;
}
```
（两种方法都可以过，二选一即可）

**这道题的方法我们差不多也说完了，直接上代码吧：**

```cpp
#include<bits/stdc++.h>
#define int long long//不开long long见祖宗QwQ
using namespace std;
const int mod=1e9+7;
int n,m,ans;
int f[300010],a[300010],s[300010],fac[300010],inv[300010],inf[300010];
int find(int x)//并查集寻找父亲
{
    return (f[x]==x)?x:f[x]=find(f[x]);
}
int qpow(int a,int b)//求快速幂
{
    int c=1;
    while (b)
    {
        if (b&1)
            c=c*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return c;
}
void init()//预处理
{
    fac[0]=1;//fac是阶乘
    for (int i=1;i<=n;i++)
    {
        f[i]=i;//初始化父亲
        s[i]=a[i]=1;//子树大小和组合数初始化都为1
        fac[i]=fac[i-1]*i%mod;
    }
    inf[n]=qpow(fac[n],mod-2);//fac[n]的逆元
    for (int i=n;i>=1;i--)//倒序求阶乘逆元
        inf[i-1]=(inf[i]*i)%mod;
    //inv[1]=1;//inv是逆元
    //for (int i=2;i<=n;i++)//线性求逆元
        //inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    //inf[0]=1;//inf是逆元的阶乘
    //for (int i=1;i<=n;i++)
        //inf[i]=inf[i-1]*inv[i]%mod;
}
int C(int n,int m)//C求组合数
{
    return fac[n]*inf[m]%mod*inf[n-m]%mod;
}
void merge(int x,int y)//连接操作：将x连在y下
{
    x=find(x),y=find(y);
    s[y]+=s[x];//更新子树大小
    a[y]=a[y]*a[x]%mod*C(s[y]-1,s[x])%mod;//更新子树组合数
    f[x]=y;//更新父亲
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    init();
    while (m--)
    {
        int op,x,y;
        scanf("%lld%lld",&op,&x);
        if (op==1)
        {
            scanf("%lld",&y);
            x=(x+ans)%n+1,y=(y+ans)%n+1;//+1的原因是题目输入的是0~n-1，我们把它变为1~n方便预处理
            merge(x,y);
        }
        else
        {
            x=(x+ans)%n+1;//+1同上
            printf("%lld\n",ans=a[find(x)]);//输出x所在树的组合数
        }
    }
    return 0;
}
```
今天的题解就到这儿了，你的点赞是对我最大的支持。

---

## 作者：周子衡 (赞：8)

```
求求各位管理快点造数据吧……
```

首先考虑一下，对于一棵给定的树$T=(V,E)$，怎么求出填法的总数。

记$T$的根节点为$rt$，对于树中节点$u$，记$son(u)$为$u$的子节点集合，$sz_u$表示以$u$为根的子树的节点个数，$ans_u$表示以$u$为根的子树的填法数。

根节点一定填最小值，考虑每个子树的数集的选法（相互独立），再乘上树内的选法，那么有：

$ans_u=\prod_{v\in son(u)}ans_v\times\frac{(sz_u-1)!}{\prod_{v\in son(u)}sz_v!}$

其中后面那个式子是多重集的排列数，可以参见$\text{CSPJX2019PJT4}$的题解。最后的答案即为$ans_{rt}$。

接着考虑原题。很容易想到维护一个并查集，如果加上路径压缩和按秩合并，可以在$O(\alpha(n))$的时间内求出点$x$在的根。记$x$所在的数的根为$root_x$。

对于每个修改$(x,y)$，记$dx=root_x,dy=root_y$，我们要将$dx$并到$dy$下，发现此时只有$sz_{dy}$和$ans_{dy}$需要处理，很容易写出：

$sz'_{dy}=sz_{dy}+sz_{dx}$

$ans'_{dy}=ans_{dy}\times \frac{\prod_{i=sz_{dy}}^{sz_{dy}+sz_{dv}-1}i}{sz_v!}\times ans_{dx}$

其中中间的式子其实就是组合数，可以$O(n+\text{log MOD})$提前预处理出来。这样就可以$O(1)$合并了。

对于每个询问，直接输出$ans_{dx}$即可。

总时间复杂度$O(n\alpha(n)+\text{log MOD})$。

---

## 作者：7KByte (赞：7)

首先考虑不强制在线

由于只有连边操作，所以我们可以先将所有的边连起来，得到树的最终形态，然后从根节点开始跑树形$DP$

定义$f[i]$表示以$i$节点为根的多插堆分别填入$0--(sz[i]-1)$有多少不同的方案

显然$i$节点自身只能填$0$

对于它的一棵子树$j$，只用从剩下的$sz[i]-1$个数中选出$sz[j]$个数填入子树$j$，对答案的贡献为$f[j]*C_{sz[i]-1}^{sz[j]}$

所以转移方程$f[i]=\prod\limits_{j\in son(i)}(f[j]*C_{sz[i]-1}^{sz[j]})$


考虑强制在线，我们发现直接在连边的时候将$f[j]*C_{sz[i]-1}^{sz[j]}$乘到$f[i]$里去即可


求所在节点的根直接并查集即可，$P=10^9+7$，所以组合数直接预处理阶乘即可


$Code:NlogN$

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define N 300005
#define P 1000000007ll
using namespace std;
typedef long long ll;
int n,m,fa[N];
int get(int x){
	return fa[x]==x?x:fa[x]=get(fa[x]);
}
ll fac[N],f[N],sz[N];
ll Pow(ll x,ll y){
	ll mul=1;
	for(;y;y>>=1,x=(x*x)%P)if(y&1)mul=(mul*x)%P;
	return mul;
}
void init(){
    rep(i,1,n)f[i]=sz[i]=1,fa[i]=i;
	fac[0]=fac[1]=1;
	rep(i,2,n)fac[i]=(fac[i-1]*i)%P;
}
ll C(int x,int y){
	// x=n // y=m
	//cout<<x<<" "<<y<<endl;
	return fac[x]*Pow(fac[y],P-2)%P*Pow(fac[x-y],P-2)%P;
}
void link(int x,int y){
	int xx=get(x),yy=get(y);
	f[yy]=(f[yy]*C(sz[xx]+sz[yy]-1,sz[xx])%P*f[xx])%P;
	fa[xx]=yy;sz[yy]+=sz[xx];
}
int main(){
	scanf("%d%d",&n,&m);
	init();//cout<<C(2,1)<<endl;
	ll ans=0,x,y,op;
	rep(i,1,m){
		scanf("%lld%lld",&op,&x);
		if(op==1){
			scanf("%lld",&y);
			x=(x+ans)%n+1,y=(y+ans)%n+1;
			link(x,y);
			//cout<<x<<" "<<y<<" "<<f[get(y)]<<" "<<sz[get(y)]<<endl;
		}
		else{
			x=(x+ans)%n+1;
			printf("%lld\n",ans=f[get(x)]);
		}
	}
	return 0;
}
```

---

## 作者：big_news (赞：4)

为啥会用到组合数啊/kk

不是有经典结论的吗/kk

我们可以把每条边定向为从儿子指向父亲

然后题目就是要求得到的树形图（有向树）拓扑序的数量

我们知道一般 DAG 的拓扑序计数只能 $O(2^{|V|})$ 状压DP

但是有一个经典结论说树形图的拓扑序数量是 $n!\prod_{i=1}^n\frac{1}{sz[i]}$，其中 $sz[i]$ 是子树 $i$ 的大小

这是为什么呢，我们先把排列全考虑上去，方案有 $n!$ 种

我们对每个节点考虑，其应当出现在它的所有子孙之前，这样的概率是 $\frac{1}{sz[i]}$

我们注意到节点之间的概率是相互独立的，因为一个节点不可能有两个深度相同的祖先

所以直接乘起来就好了

剩下只需要维护个并查集

听说路径压缩并查集不是 $O(\alpha(n))$ 而是 $O(\log n)$ 的

所以复杂度 $O(n\log n)$，但是感觉跑起来要快很多，吸个氧搞了个最优解第二/jk

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P = 1e9 + 7;
const int CN = 3e5 + 50;
int n, q, inv[CN], sz[CN], ans[CN], fac[CN], lstans = 0;
class DSU {
public: int fa[CN];
  DSU() {for(int i = 1; i <= 300000; i++) ans[i] = sz[i] = 1, fa[i] = i;}
  int fd(int x) {return fa[x] ^ x ? fa[x] = fd(fa[x]) : x;}
} D;
int main() {
  n = read(), q = read(), inv[1] = fac[0] = fac[1] = 1; 
  for(int i = 2; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % P, inv[i] = 1ll * inv[P % i] * (P - (P / i)) % P;
  while(q--){
    int tp = read(), x = read(), y; x = (x + lstans) % n;
    if(tp == 1)
      y = read(), y = (y + lstans) % n, x = D.fd(x + 1), y = D.fd(y + 1), D.fa[x] = y,
      ans[y] = 1ll * ans[y] * sz[y] % P, sz[y] += sz[x], ans[y] = 1ll * ans[y] * inv[sz[y]] % P, ans[y] = 1ll * ans[y] * ans[x] % P;
    else x = D.fd(x + 1), lstans = 1ll * ans[x] * fac[sz[x]] % P, printf("%d", lstans), puts("");
  }
  return 0;
}

```

---

## 作者：lam_dyr (赞：3)

## 题意

我们需要维护一组不相交的树，并在两种操作下进行更新与查询。

- 操作一：将两个不同树上的节点 $x$ 和 $y$ 所在子树合并在一起。

- 操作二：给出能将节点 $x$ 所在树用 $size$ 个数填满能形成的不同多叉堆的数量（$size$ 为 $x$ 所在子树大小）。


## 思路

本题其实需要将堆的性质和组合数学结合，并使用合适的数据结构维护。

首先，对于固定结构的多叉小根堆，每棵树的堆排列数计算公式如下：

- 若某节点 $v$ 有 $k$ 个子树，子树大小分别为 $s_1, s_2, \ldots, s_k$，则以 $v$ 为根的树的堆排列数为  
  $$\text{heap}(v) = \binom{s_1 + \cdots + s_k}{s_1, s_2, \ldots, s_k} \times \prod_{i=1}^k \text{heap}(c_i)$$

  其中 $c_i$ 为第 $i$ 个子树的根节点。

- 特别地，对于叶节点，$\text{heap}(leaf) = 1$。

其次，由于操作 `1 x y` 将两棵不相交的树合并，并且总是将树 $x$ 的根连接到树 $y$ 的根下，所以合并操作始终在树的根节点上进行。利用这一点，我们可以利用并查集维护每棵树的根、大小及其堆计数值。

具体的，对于并查集的每个根节点 $r$，维护以下信息：

- $fa_{r}$：节点 $r$ 的父节点（若 $r$ 为根，则 $fa_{r} = r$）。

- $size_{r}$：以 $r$ 为根的树的大小。


- $dp_{r}$：以 $r$ 为根的树的多叉堆的排列数。

对于操作一，合并就是并查集的基础操作，维护一下子树大小就行。对于堆计数，根据多叉堆公式得到：

$$dp_{r_y} = dp_{r_y} \times dp_{r_x} \times \binom{nsz - 1}{size_{r_x}} \mod 10^9+7$$

对于操作二，为了快速计算二项式系数 $\binom{N}{K}$，需要预先计算阶乘数组 $fact$ 和逆元阶乘数组 $invf$：

$$
\binom{N}{K} = fact_{N} \times invf_{K} \times invf_{N-K} \mod M
$$

其中：

$$fact_{i} = i! \bmod 10^9+7,invf_{i} = (i!)^{-1} \bmod 10^9+7$$

具体见代码。

## Code
```cpp
#include <iostream>
using namespace std;
const int MOD = 1000000007,N = 300005;
struct UF {
    int fa[N];
    int siz[N];
    long long dp[N];
    UF(int n){
        for (int i = 0; i < n; i++){
            fa[i] = i;
            siz[i] = 1;
            dp[i] = 1;
        }
    }
    int findp(int a) {
        if(fa[a]==a) return a;
        return fa[a] = findp(fa[a]);
    }
};
long long ksm(long long b, long long e){
    long long r = 1;
    while(e) {
        if(e & 1) r = r * b % MOD;
        b = b * b % MOD;
        e >>= 1;
    }
    return r;
}
long long comb(int N, int K, long long fact[], long long invf[]){
    if(K<0 || K> N) return 0;
    return fact[N] * invf[K] % MOD * invf[N-K] % MOD;
}
long long fact[N], invf[N];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, q;
    cin >> n >> q;
    fact[0] = invf[0] = 1;
    for(int i = 1; i<=n; i++) fact[i] = fact[i-1] * i % MOD;
    invf[n] = ksm(fact[n], MOD-2);
    for (int i = n; i>=1; i--) invf[i-1] = invf[i] * i % MOD;
    UF uf(n);
    long long ans = 0;
    for(int i = 0; i<q; i++){
        int t;
        cin >> t;
        if(t==1){
            int x1, y1;
            cin >> x1 >> y1;
            int x = (int)((x1 + ans) % n);
            int y = (int)((y1 + ans) % n);
            int rx = uf.findp(x);
            int ry = uf.findp(y);
            long long nsz = (long long)uf.siz[ry] + uf.siz[rx];
            long long way = comb((int)(nsz - 1), uf.siz[rx], fact, invf);
            uf.dp[ry] = uf.dp[ry] * uf.dp[rx] % MOD * way % MOD;
            uf.siz[ry] = (int)nsz;
            uf.fa[rx] = ry;
        } else {
            int x1;
            cin >> x1;
            int x = (int)((x1 + ans) % n);
            int r = uf.findp(x);
            ans = uf.dp[r] % MOD;
            cout << ans << "\n";
        }
    }
    return 0;
}
```

---

## 作者：GIFBMP (赞：3)

第一次~~口胡~~秒掉 D2T2，以该题解作纪念。

由于只有根的信息有用，显然可以用并查集维护。

$size_x$ 表示 $x$ 的子树的大小，$cnt_x$ 表示 $x$ 的子树的填充方案数。

（下列式子中，$rtx$ 表示 $x$ 当前所在子树的根）

当 $x$ 合并到 $y$ 时，显然有 $cnt_{rty}=cnt_{rtx}\times cnt_{rty}\times C_{size_{rtx}+size_{rty}-1}^{size_{rtx}}$

于是预处理阶乘以及逆元，这道题就被解决了。

时间复杂度 $\Theta(q\alpha(n))$。

P.S：代码中是先合并 $size$ 再合并 $cnt$，所以原式中的 $size_{rtx}+size_{rty}-1$ 被替换成了 $size_{rtx}$。

Code:

```cpp
#include <cstdio>
using namespace std ;
const int MAXN = 3e5 + 10 , mod = 1e9 + 7 ;
typedef long long ll ;
ll fac[MAXN] , inv[MAXN] , cnt[MAXN] , ans ; 
int size[MAXN] , fa[MAXN] ;
int n , q ;
ll qpow (ll x , int p = mod - 2) {
	ll ret = 1 ;
	for (; p ; p >>= 1 , x = x * x % mod)
		if (p & 1) ret = ret * x % mod ;
	return ret ;
}
ll C (int x , int y) {
	return 1LL * fac[x] * inv[y] % mod * inv[x - y] % mod ;
}
int find (int x) {
	return fa[x] == x ? x : fa[x] = find (fa[x]) ;
}
void merge (int x , int y) {
	int fx = find (x) , fy = find (y) ;
	fa[fx] = fy ;
	size[fy] += size[fx] ;
	cnt[fy] = 1LL * cnt[fy] * cnt[fx] % mod * C (size[fy] - 1 , size[fx]) % mod ;
}
int main () {
	scanf ("%d %d" , &n , &q) ;
	fac[0] = 1 ;
	for (int i = 1 ; i <= n ; i++)
		fac[i] = fac[i - 1] * i % mod ;
	for (int i = 0 ; i < n ; i++)
		size[i] = cnt[i] = 1 , fa[i] = i ;
	inv[n] = qpow (fac[n]) ;
	for (int i = n - 1 ; i >= 0 ; i--)
		inv[i] = inv[i + 1] * (i + 1) % mod ; 
	while (q--) {
		int opt , x , y ;
		scanf ("%d" , &opt) ;
		if (opt == 1) {
			scanf ("%d %d" , &x , &y) ;
			x = 1LL * (x + ans) % n ;
			y = 1LL * (y + ans) % n ;
			merge (x , y) ;
		}
		if (opt == 2) {
			scanf ("%d" , &x) ;
			x = 1LL * (x + ans) % n ;
			int fx = find (x) ;
			ans = cnt[fx] ;
			printf ("%lld\n" , ans) ;
		}
	}
	return 0 ;
}
```

---

## 作者：sSkYy (赞：1)

# [P5689 [CSP-S2019 江西] 多叉堆](https://www.luogu.com.cn/problem/P5689)

## 题意

维护一组树，有如下两种操作：

- 令 $x$ 所在子树的根的父亲为 $y$ 所在子树的根。
- 求 $x$ 所在子树被 $0$ 到 $size-1$ 填满能形成的不同多叉堆的数量（$size$ 为 $x$ 所在子树大小）。

## 题解

看到操作一，显然是并查集。

再看操作二，说明并查集要维护一个 $size$ 和一个答案 $f$，并且 $f$ 肯定只和 $size$ 有关。

回到操作一，考虑 $f$ 怎么合并。首先合并完的树根只能是 $0$，剩下的数字实际上可以随便分配给 $x$ 和 $y$ 所在的子树，分配完之后 $x$ 和 $y$ 所在子树的 $f$ 实际上就独立了，根据乘法原理相乘即可。

形式上：

$$
f_y \leftarrow f_y \times f_x \times \binom{sz_x+sz_y-1}{sz_x}
$$

组合数预处理一下阶乘及其逆元即可，代码十分清晰。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
const int N=3e5+5;
const int mod=1e9+7;

int n,q,ans;
int fac[N],invf[N];

int C(int x,int y){
    return fac[y]*invf[x]%mod*invf[y-x]%mod;
}

struct DSU{
    int fa[N],sz[N],f[N];
    void init(int n){for(int i=0;i<n;i++) fa[i]=i,sz[i]=f[i]=1;}
    int find(int x){
        if(x==fa[x]) return x;
        return fa[x]=find(fa[x]);
    }
    void merge(int x,int y){
        int fx=find(x),fy=find(y);
        if(fx==fy) return;
        fa[fx]=fy;
        f[fy]=f[fy]*f[fx]%mod*C(sz[fx],sz[fx]+sz[fy]-1)%mod;
        sz[fy]=(sz[fy]+sz[fx])%mod;
    }
    int ask(int x){
        return f[find(x)];
    }
}dsu;

int ksm(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}

void Init(){
    fac[0]=invf[0]=1;
    for(int i=1;i<=N-5;i++) fac[i]=fac[i-1]*i%mod,invf[i]=ksm(fac[i],mod-2);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    Init();
    cin>>n>>q;
    dsu.init(n);
    ans=0;
    while(q--){
        int op,x,y;
        cin>>op;
        if(op==1){
            cin>>x>>y;
            x=(x+ans)%n;
            y=(y+ans)%n;
            dsu.merge(x,y);
        }else{
            cin>>x;
            x=(x+ans)%n;
            ans=dsu.ask(x);
            cout<<ans<<"\n";
        }
    }
    return 0;
}
```

---

## 作者：lilong (赞：1)

设 $f_u$ 表示以 $u$ 为根的子树构成不同多叉堆的方案数。显然最小的 $0$ 应该分配给 $u$，剩下的分给子节点 $v_1,v_2,\cdots,v_k$，根据乘法原理，有

$$f_u=\prod_{i=1}^k \binom{siz_u-1-\sum_{j=1}^{i-1}siz_{v_j}}{siz_{v_i}}f_{v_i}$$

将组合数和 $f$ 分开，观察到组合数全部乘起来后分子即为 $(siz_u-1)!$，分母即为子节点大小阶乘的乘积，即

$$f_u=\dfrac{(siz_u-1)!}{\prod_{i=1}^ksiz_{v_i}!}\prod_{i=1}^kf_{v_i}$$

直接使用并查集维护点的关系，并在合并时更新对应的 $f$ 即可。使用快速幂计算逆元，时间复杂度 $O(n\log n+q)$。


```cpp
#include<iostream>
#include<cstdio>
#define N 500010
#define mod 1000000007
#define int long long
using namespace std;
int n,m,fa[N],f[N],fac[N],inv[N],siz[N],ans;
int qp(int a,int b){
    int c=1;
    while(b){
        if(b&1)c=c*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return c;
}
int cx(int x){
    if(x==fa[x])return x;
    return fa[x]=cx(fa[x]);
}
signed main(){
    //f[u]=C_{siz[u]-1}^siz[v1]*f[v1]*C_{siz[u]-siz[v1]-1}^siz[v2]*f[v2]......*C_{siz[vk]}^siz[vk]*f[vk];
    //    =(siz[u]-1)!/(siz[v1]!siz[v2]!...siz[vk]!)*f[v1]f[v2]...f[vk]
    int op,x,y;
    cin>>n>>m;
    fac[0]=inv[0]=1;
    for(int i=1;i<=n;i++){
        fac[i]=fac[i-1]*i%mod;
        inv[i]=qp(fac[i],mod-2);
        fa[i]=i,siz[i]=1,f[i]=1;
    }
    while(m--){
        cin>>op;
        if(op==1){
            cin>>x>>y;
            x=(x+ans)%n;y=(y+ans)%n;
            x++;y++;
            x=cx(x),y=cx(y);
            f[y]=f[y]*inv[siz[y]-1]%mod*fac[siz[y]+siz[x]-1]%mod;
            f[y]=f[y]*inv[siz[x]]%mod;
            f[y]=f[y]*f[x]%mod;
            fa[x]=y;siz[y]+=siz[x];
        }
        if(op==2){
            cin>>x;
            x=(x+ans)%n;
            x++;
            x=cx(x);
            ans=f[x];
            cout<<ans<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：MPLN (赞：1)

~~第一次遇到能十分钟切掉的蓝题~~

**JXCSP-S2019 签到题**

**前置必会算法：并查集和求乘法逆元。**

## 思路

首先看到合并，显然我们需要并查集维护这些点在哪个集合并随时找到某个点所在树的根。

接下来考虑如何处理小根堆数量，这个当然需要在合并的时候就维护好，否则询问的时候再算一遍肯定会超时。

首先假设 $s_i$ 为 $i$ 为根的树的大小，这个可以在合并并查集的时候轻松维护。再假设 $f_i$ 为 $i$ 为根的树的合法小根堆数量（即答案），容易发现当 $i$ 时单独的点 $f_i=1$。

那么现在问题转化成我们把 $x$ 为根的树并到 $y$ 为根的树中时，如何用原来的 $f_x,f_y$ 求出新的 $f_y$。

首先注意到 $y$ 本身的赋值一定是 $0$，那么 $1$～$s_x+s_y-1$ 要给剩下的点，其中 $s_y-1$ 个给原本 $y$ 的孩子们，$s_x$ 个给子树 $x$。所以我们先把 $s_x+s_y-1$ 个点分成这两个集合，有 $\binom{s_x+s_y-1}{s_x}$ 种方法，而每种分法分完之后与原本的两棵树分别求的答案是等价的。于是得到转移：

$$
s_y\gets s_y+s_x\\
f_y\gets f_y\times f_x\times \binom{s_y-1}{s_x}\\
$$

所以预处理阶乘及其逆元后直接算就可以了。

时间复杂度 $O(n+q\operatorname{log}n)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1000000007;
int jc[300010], inv[300010];
int n, q, fa[300010], sz[300010], f[300010], ans;
int qpow(int a, int p){
    int res = 1;
    while (p){
        if (p & 1) res = (ll) res * a % MOD;
        a = (ll) a * a % MOD, p >>= 1;
    }
    return res;
}
int find(int x){
    return fa[x]=fa[x]==x?x:find(fa[x]);
}
int C(int x, int y){ // 计算组合数
    if (x < y) return 0;
    return (ll) jc[x] * inv[y] % MOD * inv[x - y] % MOD;
}
int main(){
    cin >> n >> q;

    // 初始化各数组
    for(int i = 0; i < n; i++) fa[i] = i;
    for(int i = 0; i < n; i++) f[i] = sz[i] = 1;

    // 预处理阶乘及其逆元
    jc[0] = 1;
    for(int i = 1; i <= n; i++) jc[i] = (ll) jc[i - 1] * i % MOD;
    inv[n] = qpow(jc[n], MOD - 2);
    for(int i = n - 1; i >= 0; i--) inv[i] = (ll) inv[i + 1] * (i + 1) % MOD;

    while(q--){
        int op, x, y;
        cin >> op;
        if(op == 1){
            cin >> x >> y;
            x = (x + ans) % n, y = (y + ans) % n;
            int fx = find(x), fy = find(y);
            fa[fx] = fy, sz[fy] += sz[fx];
            f[fy] = (ll) f[fy] * f[fx] % MOD * C(sz[fy] - 1, sz[fx]) % MOD;
        }else if(op == 2){
            cin >> x;
            x = (x + ans) % n;
            cout << f[find(x)] << endl;
            ans = f[find(x)];
        }
    }
    return 0;
}
```

---

## 作者：cshur (赞：1)

我们分别来解决两个操作。

这题规模大，我开 `long long` ，当然你也可以试试不开 `long long`，注意下强制类型转化就应该能过。
```cpp
typedef long long ll;
```

## 操作 1

给出两个数 $x,y$，合并 $x,y$ 所在树。

并查集即可，注意：
> 将 $x$ 所在树的根直接接在 $y$ 所在树的根之下

不要弄反了。
```cpp
int f[N];//不是所有都要开 long long
void Init()
{
  for(int i = 1; i <= n; i++)
    f[i] = i;
}
int Find(int x)
{
	if(x == f[x]) return x;
	return f[x] = Find(f[x]);
}
void Merge(ll u,ll v)
{
	ll Fu = Find(u),Fv = Find(v);
	if(Fu != Fv) f[Fu] = Fv;
}
```
## 操作 2
考虑维护 $siz[x]$ 表示 $x$ 结点子树大小

初始时，$siz[i] = 1$
```cpp
void Merge(int u,int v)
{
	int Fu = Find(u),Fv = Find(v);
	if(Fu != Fv)
	{
		f[Fu] = Fv;
		siz[Fv] += siz[Fu];
	}
}
```

还不够，如何求 方案数 呢？

设 $ans[i]$ 表示 $i$ 结点子树当前方案树

将 $u$ 合并到 $v$ 下面，更新 $ans[v]$

$ans[v] = ans[u]\cdot ans[v]\cdot C_{siz[v]-1}^{siz[u]}$

为啥呢？$ans[u]\cdot ans[v]$ 是根据乘法原理把方案数相乘，
而 $C_{siz[v]-1}^{siz[u]}$ 是考虑 $u$ 子树结点在 $v$ 树结点中的位置情况方案个数。

问题解决！

---
剩下的只是 计算 $C$ 的一些预处理问题。

用 $fac[x]$ 表示 $x! \bmod mod$
用 $inv\_fac[x]$ 表示 $fac[x]$ 的逆元
```cpp
const ll mod = 1e9+7;
ll fast_pow(ll x,ll k)//快速幂
{
	ll t = 1;
	while(k)
	{
		if(k&1) t *= x,t %= mod;
		x *= x,x %= mod;
		k >>= 1;
	}
	return t;
}
void Init()
{
	fac[0] = 1;
	for(int i = 1; i <= n; i++)
		fac[i] = fac[i-1]*i%mod;
	inv_fac[n] = fast_pow(fac[n],mod-2);
	for(int i = n-1; i >= 0; i--)
		inv_fac[i] = inv_fac[i+1]*(i+1)%mod;
}
ll C(ll n,ll m)
{
	if(m == 0) return 1;//特判
	return fac[n]*inv_fac[m]%mod*inv_fac[n-m]%mod;
}
```
## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 3e5+5;
const ll mod = 1e9+7;
int n,q;
ll f[N];
ll fac[N],inv_fac[N];
ll siz[N];
ll ans[N],Ans = 0;
ll fast_pow(ll x,ll k)
{
	ll t = 1;
	while(k)
	{
		if(k&1) t *= x,t %= mod;
		x *= x,x %= mod;
		k >>= 1;
	}
	return t;
}
void Init()
{
	for(int i = 0; i <= n; i++)
		f[i] = i,siz[i] = 1,ans[i] = 1; 
	fac[0] = 1;
	for(int i = 1; i <= n; i++)
		fac[i] = fac[i-1]*i%mod;
	inv_fac[n] = fast_pow(fac[n],mod-2);
	for(int i = n-1; i >= 0; i--)
		inv_fac[i] = inv_fac[i+1]*(i+1)%mod;
}
ll C(ll n,ll m)
{
	if(m == 0) return 1;
	return fac[n]*inv_fac[m]%mod*inv_fac[n-m]%mod;
}
ll Find(ll x)
{
	if(x == f[x]) return x;
	return f[x] = Find(f[x]);
}
void Merge(ll u,ll v)
{
	ll Fu = Find(u),Fv = Find(v);
	if(Fu != Fv)
	{
		f[Fu] = Fv;
		siz[Fv] += siz[Fu];
		ans[Fv] = ans[Fv]*ans[Fu]%mod*C(siz[Fv]-1,siz[Fu])%mod;
	}
}
ll get_ans(ll x)
{
	Ans = ans[Find(x)];
	return Ans;
}
int main()
{
	scanf("%d%d",&n,&q);
	Init(); 
	ll op,x,y;
	for(int i = 1; i <= q; i++)
	{
		scanf("%lld",&op);
		if(op == 1)
		{
			scanf("%lld%lld",&x,&y);
			x = (x+Ans)%n,y = (y+Ans)%n;
			Merge(x,y);//合并 x,y 将 x 根放到 y 之下 
		}
		else
		{
			scanf("%lld",&x);
			x = (x+Ans)%n;
			printf("%lld\n",get_ans(x));
			Ans %= n;
		}
	}
	return 0;
}
```

---

## 作者：Little09 (赞：1)

一整棵树的答案很显然是一样的，所以我们可以考虑并查集维护。

我们可以用 $size_i$ 表示以 $i$ 为根的子树大小。注意这里，如果 $i$ 已经是一棵树上的节点，那么就不用维护了。这个显然可以维护：在合并的时候相加即可。

再用 $ans_i$ 表示以 $i$ 为根的答案。考虑当把以 $y$ 为根的树接在以 $x$ 为根的树下，则 $ans_x=ans_x*ans_y*C_{size_x+size_y-1}^{size_y}$。这个很好理解，就是因为 $1$这个数只能放在根上，其他 $size_x+size_y-1$ 个数任选出 $size_y$ 个数摆在以 $y$ 为根的树上，其它数摆在以 $x$ 为根的树上，两个方案相乘即可。

至于组合数怎么求，预处理一下阶乘和阶乘的逆元就行了。

结合代码理解下（不要在意奇怪的变量名比如 $jc$ 是阶乘的意思）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int fa[300501];
int size[300001];
long long ans[300001];
const long long mod=1e9+7;
long long jc[300001],njc[300001];
inline long long read()
{
	char C;
	long long F=1,ANS=0;
	while (C<'0'||C>'9')
	{
		if (C=='-') F=-1;
		C=getchar();
	}
	while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
	return F*ANS;
} 
long long ksm(long long x,int y)
{
	if (y==0) return 1;
	long long res=ksm(x,y/2);
	res=(res*res)%mod;
	if (y%2==0) return res;
	return (res*x)%mod;
}
inline long long C(int x,int y)
{
	return ((jc[x]*njc[y])%mod)*njc[x-y]%mod;
}
inline int find(int x)
{
	if (x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
int main()
{
	n=read(),m=read();
    for (int i=0;i<n;i++) fa[i]=i,size[i]=1,ans[i]=1;
	jc[0]=1;
	for (int i=1;i<=n;i++) jc[i]=(jc[i-1]*i)%mod;
	njc[n]=ksm(jc[n],mod-2);
	for (int i=n-1;i>=0;i--) njc[i]=(njc[i+1]*(i+1))%mod;
    long long lastans=0;
    for (int i=1;i<=m;i++)
    {
    	int x,y,t;
    	t=read(),x=read();
    	x=(x+lastans)%n;
    	if (t==1) 
		{
			y=read();
			y=(y+lastans)%n;
			int x1=find(x),y1=find(y);
			ans[y1]=((ans[y1]*ans[x1])%mod*C(size[x1]+size[y1]-1,size[x1]))%mod;
			size[y1]+=size[x1];
			fa[x1]=y1;
		}
    	else
    	{
    		lastans=ans[find(x)];
    		printf("%lld\n",lastans);
		}
	}
    return 0;
}
```


---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5689)

---

# 思路：

设两棵多叉树 $U,V$，其根节点为 $u,v$，大小为 $siz_U,siz_V$，各自的答案为 $w_U,w_V$。

若此时把 $U$ 合并到 $V$ 上，此时的根节点 $v$ 只能填 $0$，下面分成了两块：一块 $siz_U$ 个，一块 $siz_V-1$ 个，两块不影响。所以答案为 $w_U \times w_V \times C_n^m$。然后用并查集维护一下，组合数用阶乘逆元算。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int w[N],A[N],invA[N],n,q,fa[N],siz[N],ans;
int gf(int x){ 
	return fa[x]==x?x:fa[x]=gf(fa[x]);
}
int qp(int a,int b){
	int ans=1;
	while(b){ 
		if(b&1){
			ans=ans*a%mod;
		}
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int C(int n,int m){
	return A[n]*invA[m]%mod*invA[n-m]%mod;
}
signed main(){
	cin>>n>>q;
	siz[0]=w[0]=A[0]=1;
	for(int i=1;i<=n;i++){
		fa[i]=i;
		siz[i]=w[i]=1;
		A[i]=A[i-1]*i%mod;
	}
	invA[n]=qp(A[n],mod-2);
	for(int i=n-1;i>=0;i--){
		invA[i]=invA[i+1]*(i+1)%mod;
	}
	for(int i=1,op,x,y;i<=q;i++){
		cin>>op>>x;
		x=(x+ans)%n;
		if(op==1){
			cin>>y;
			y=(y+ans)%n;
			x=gf(x);
			y=gf(y);
			siz[y]+=siz[x];
			fa[x]=y;
			w[y]=w[x]*w[y]%mod*C(siz[y]-1,siz[x])%mod;
		}else{
			x=gf(x);
			ans=w[x];
			cout<<ans<<endl;
		}
	}
	return 0;
}
```
完结撒花~

---

## 作者：Drawing_Yang (赞：0)

由于有加边操作，先考虑树为静态时的做法。

定义 $f_{i}$ 为 $i$ 子树内，将 $0$ ~ $siz_{i}-1$ 填到 $i$ 的子树，并且满足题意的方案数。对于 $i$，考虑将它的一个儿子 $j$ 合并到 $i$ 上之后的方案数。因为 $i$ 与 $j$ 是互相独立的，所以直接相乘；又因为有一个 **分配标号** 的过程，再乘上组合数。形式化的说，就是

$$
f^\prime_i={size_i+size_j-1\choose size_j}f_if_j
$$

其中 $f'_{i}$ 是合并完后 $i$ 子树的答案，$size_i$ 是合并前 $i$ 子树的答案，因为 $i$ 的权值是固定的（固定为 $0$），所以要减一。最终根节点的 $f$ 值就是这个树的答案。

---

现在考虑动态的做法。

注意到题目中合并的方法，是将两个树的根节点合并，那么就可以直接维护根节点信息。记 $dp_i$ 为树 $i$ 的答案，那么合并根节点时按照上述方法合并。此时需要一个数据结构能够找到这个点所在树的根，并查集可以胜任（当然，想写 LCT 也没人拦）。

故，用并查集维护每个点所在树的根，同时为了合并，需要维护并查集的大小，合并时按照上述式子合并，答案就是根的 $dp$ 值。组合数，预处理阶乘、阶乘逆元直接算。

时间复杂度 $O(n\log n)$。

---

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline char getch(){
	static char buf[10000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
}
#define Getc getch
inline ll read(){
	ll s=0,f=1;char ch=Getc();
	while(ch<'0'||ch>'9')f=(ch=='-'?-1:1),ch=Getc();
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=Getc();
	return s*f;
}
#define filename "filename"
void File(){
	freopen(filename".in","r",stdin);
	freopen(filename".out","w",stdout);
}
const int MaxN=3e5+5;
const int Mod=1e9+7;
int f[MaxN],siz[MaxN];
int dp[MaxN],n,Q,lastans;
ll fac[MaxN],inv[MaxN],ifac[MaxN];
int getf(int x){
	return f[x]==x?x:f[x]=getf(f[x]);
}
ll C(int n,int m){
	return fac[n]*ifac[m]%Mod*ifac[n-m]%Mod;
}
int main(){
	n=read(),Q=read();
	for(int i=1;i<=n;i++){
		f[i]=i;siz[i]=dp[i]=1;
	}
	fac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;
	for(int i=2;i<=n;i++){
		fac[i]=fac[i-1]*i%Mod;
		inv[i]=Mod-Mod/i*inv[Mod%i]%Mod;
		ifac[i]=ifac[i-1]*inv[i]%Mod;
	}
	for(int i=1;i<=Q;i++){
		int op,x,y;
		op=read();
		if(op==1){
			x=read(),y=read();
			x=(x+lastans)%n+1;
			y=(y+lastans)%n+1;
			x=getf(x);y=getf(y);
			f[x]=y;
			siz[y]+=siz[x];
			dp[y]=C(siz[y]-1,siz[x])*dp[x]%Mod*dp[y]%Mod;
		}
		if(op==2){
			x=read();
			x=(x+lastans)%n+1;
			cout<<(lastans=dp[getf(x)])<<"\n";
		}
	}
	return 0;
}
```

代码中出于习惯问题，将点的标号从 $1$ 开始。

---


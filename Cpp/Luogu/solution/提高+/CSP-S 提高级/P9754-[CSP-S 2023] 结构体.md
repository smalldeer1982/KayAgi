# [CSP-S 2023] 结构体

## 题目背景

在 C++ 等高级语言中，除了 int 和 float 等基本类型外，通常还可以自定义结构体类型。在本题当中，你需要模拟一种类似 C++ 的高级语言的结构体定义方式，并计算出相应的内存占用等信息。

## 题目描述

在这种语言中，基本类型共有 $4$ 种：`byte`、`short`、`int`、`long`，分别占据 $1$、$2$、$4$、$8$ 字节的空间。

定义一个结构体**类型**时，需要给出**类型名**和**成员**，其中每个成员需要按顺序给出**类型**和**名称**。类型可以为基本类型，也可以为**先前定义过**的结构体类型。注意，定义结构体**类型**时不会定义具体元素，即不占用内存。

定义一个**元素**时，需要给出元素的**类型**和**名称**。元素将按照以下规则占据内存：

- 元素内的所有成员将按照**定义时给出的顺序**在内存中排布，对于类型为结构体的成员同理。
- 为了保证内存访问的效率，元素的地址占用需要满足**对齐规则**，即任何类型的**大小**和该类型元素在内存中的**起始地址**均应对齐到该类型对齐要求的**整数倍**。具体而言：
  - 对于基本类型：对齐要求等于其占据空间大小，如 `int` 类型需要对齐到 $4$ 字节，其余同理。
  - 对于结构体类型：对齐要求等于其成员的对齐要求的**最大值**，如一个含有 `int` 和 `short` 的结构体类型需要对齐到 $4$ 字节。

以下是一个例子（以 C++ 语言的格式书写）：

```cpp
struct d {
    short a;
    int b;
    short c;
};
d e;
```

该代码定义了结构体类型 `d` 与元素 `e`。元素 `e` 包含三个成员 `e.a`、`e.b`、`e.c`，分别占据第 $0 \sim 1$、$4 \sim 7$、$8 \sim 9$ 字节的地址。由于类型 `d` 需要对齐到 $4$ 字节，因此 `e` 占据了第 $0 \sim 11$ 字节的地址，大小为 $12$ 字节。

你需要处理 $n$ 次操作，每次操作为以下四种之一：

1. 定义一个结构体类型。具体而言，给定正整数 $k$ 与字符串 $s, t_1, n_1, \dots, t_k, n_k$，其中 $k$ 表示该类型的成员数量，$s$ 表示该类型的类型名，$t_1, t_2, \dots, t_k$ 按顺序分别表示每个成员的类型，$n_1, n_2, \dots, n_k$ 按顺序分别表示每个成员的名称。你需要输出该结构体类型的大小和对齐要求，用一个空格分隔。

2. 定义一个元素，具体而言，给定字符串 $t, n$ 分别表示该元素的类型与名称。所有被定义的元素将按顺序，从内存地址为 $0$ 开始依次排开，并需要满足地址对齐规则。你需要输出新定义的元素的起始地址。

3. 访问某个元素。具体而言，给定字符串 $s$，表示所访问的元素。与 C++ 等语言相同，采用 `.` 来访问结构体类型的成员。如 `a.b.c`，表示 `a` 是一个已定义的元素，它是一个结构体类型，有一个名称为 `b` 的成员，它也是一个结构体类型，有一个名称为 `c` 的成员。你需要输出如上被访问的**最内层**元素的起始地址。

4. 访问某个内存地址。具体而言，给定非负整数 $addr$，表示所访问的地址，你需要判断是否存在一个**基本类型**的元素占据了该地址。若是，则按操作 3 中的访问元素格式输出该元素；否则输出 `ERR`。

## 说明/提示

#### 【样例 1 解释】

结构体类型 `a` 中，`short` 类型的成员 `aa` 占据第 $0 \sim 1$ 字节地址，`int` 类型的成员 `ab` 占据第 $4 \sim 7$ 字节地址。又由于其对齐要求为 $4$ 字节，可得其大小为 $8$ 字节。由此可同理计算出结构体类型 `b` 的大小为 $16$ 字节，对齐要求为 $8$ 字节。

#### 【样例 2】

见选手目录下的 struct/struct2.in 与 struct/struct2.ans。

#### 【样例 2 解释】
第二个操作 4 中，访问的内存地址恰好在为了地址对齐而留下的 “洞” 里，因此没有基本类型元素占据它。

#### 【样例 3】
见选手目录下的 struct/struct3.in 与 struct/struct3.ans。

#### 【数据范围】
对于全部数据，满足 $1 \le n \le 100$，$1 \le k \le 100$，$0 \le addr \le 10^{18}$。

所有定义的结构体类型名、成员名称和定义的元素名称均由不超过 $10$ 个字符的小写字母组成，且都不是 `byte,short,int,long`（即不与基本类型重名）。

所有定义的结构体类型名和元素名称互不相同，同一结构体内成员名称互不相同。但不同的结构体可能有相同的成员名称，某结构体内的成员名称也可能与定义的结构体或元素名称相同。

保证所有操作均符合题目所述的规范和要求，即结构体的定义不会包含不存在的类型、不会访问不存在的元素或成员等。

保证任意结构体大小及定义的元素占据的最高内存地址均不超过 $10^{18}$。

| 测试点 | 特殊性质 |
| :----------: | :----------: |
| $1$ | A、D |
| $2\sim 3$ | A |
| $4\sim 5$ | B、D |
| $6\sim 8$  | B |
| $9\sim 10$ | C、D|
| $11\sim 13$ | C|
| $14\sim 16$ |D|
|$17\sim 20$| 无|

特殊性质 A：没有操作 $1$；

特殊性质 B：只有一个操作 $1$；

特殊性质 C：所有操作 $1$ 中给出的成员类型均为基本类型；

特殊性质 D：基本类型只有 `long`。

#### 【提示】

对于结构体类型的对齐要求和大小，形式化的定义方式如下：

- 设该结构体内有 $k$ 个成员，其大小分别为 $s_1,...,s_k$，对齐要求分别为 $a_1,...,a_k$;
- 则该结构体的对齐要求为 $a=\max\{a_1,...,a_k\}$；
- 再设这些成员排布时的**地址偏移量**分别为 $o_1,...,o_k$，则：
  - $o_1 = 0$;
  - 对于 $i=2,...,k$，$o_i$ 为满足 $o_{i-1}+s_{i-1}\le o_i$ 且 $a_i$ 整除 $o_i$ 的最小值；
  - 则该结构体的大小 $s$ 为满足 $o_k+s_k\le s$ 且 $a$ 整除 $s$ 的最小值；

对于定义元素时的内存排布，形式化的定义方式如下：

- 设第 $i$ 个被定义的元素大小为 $s_i$，对齐要求为 $a_i$，起始地址为 $b_i$;
- 则 $b_1 = 0$，对于 $2\le i$， $b_i$ 为满足 $b_{i-1} + s_{i-1}\le b_i$ 且 $a_i$ 整除 $b_i$ 的最小值。


## 样例 #1

### 输入

```
5
1 a 2
short aa
int ab
1 b 2
a ba
long bb
2 b x
3 x.ba.ab
4 10```

### 输出

```
8 4
16 8
0
4
x.bb```

# 题解

## 作者：ShieHere (赞：422)

# 前言

本蒟蒻在考场中时并没有写出此题，但是赛后重新做一遍后发现居然并没有想象中那么难，甚至写完后交两遍就过了！而且就算是第一遍也得到了 85 分的高分！

所以考场时为什么没有写出这道题呢？（懊恼）

------------

本篇题解中所有代码基于这样的设置：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pr;
const int MAXN=256;
ll max(ll x,ll y){return x>y?x:y;}
ll min(ll x,ll y){return x<y?x:y;}
pr mp(ll x,ll y){return (pr){x,y};}
//用来输入的变量
ll n,op,k,addr_in;
string s,ti,ni,in1[MAXN],in2[MAXN];
```

所以若是遇见了不认识的东西，多半是从这里出来的。

**额外声明：因为是大模拟，所以笔者的代码中的变量名以容易理解优先，笔者承诺代码并非 AI 生成，均为笔者自己所写。**

# 正文

## 题意理解

其实去除掉**对齐规则**后，题面并不难理解，难度也会下降很多，因此这里主要解释**对齐规则**。

所谓“对齐”，就是对于一个类型的变量，其拥有一个**对齐要求**，每个类型的变量的起始位置的地址，以及终止位置的下一位的地址，都必须是这个**对齐要求**的整数倍。

这就意味着对于一个变量，其内部的地址可能并不是连续的。

拿题面中给出的例子举例：

```cpp
struct TypeA{
    short MemberA;
    int MemberB;
    short MemberC;
};
TypeA ElementA;
```

为了阅读方便，我将变量名修改了一下。

上面这个例子中，我们定义了一个结构体类型 `TypeA`，在其中包含了三个成员，分别是 `short` 类型的 `MemberA` 和 `MemberC`，以及 `int` 类型的 `MemberB`。

然后我们定义了一个 `TypeA` 类型的元素 `ElementA`。

接下来分析 `ElementA` 的内存分布  ，`MemberA` 的大小为 $2$ 字节，占据的地址为第 $0\sim1$ 字节。`MemberB` 的大小为 $4$ 字节，占据的地址本应是第 $2\sim5$ 字节——但是注意：根据**对齐规则**，`int` 类型的元素的起始位置必须是 $4$ 的整数倍，因此 `MemberB` 占据的地址应为第 $4\sim7$ 字节。

`MemberC` 占据的地址为第 $8\sim9$ 字节。

根据**对齐规则**，可得 `TypeA` 类型的元素的**对其要求**为其成员类型中最大的**对齐要求**，为 $4$ 字节。

于是我们得到，`TypeA` 类型的元素占据的地址为 $0\sim9$ 字节，**对齐要求**为 $4$ 字节。

对吗？

当然不对，我们知道，根据**对齐规则**，元素终止位置的下一位的地址也应该是**对齐要求**的整数倍，虽然这一点并没有在题面中很好地说明，但是题面中给出的例子却是这样的。

因此，`TypeA` 类型的元素占据的地址为 $0\sim11$ 字节，**对齐要求**为 $4$ 字节。

下为 `TypeA` 类型的元素占据地址的示意图：

$\mathrm{\displaystyle\begin{aligned}
&0\ &\fbox{MemberA}\\
&1\ &\fbox{MemberA}\\
&2\ &\fbox{None}\\
&3\ &\fbox{None}\\
&4\ &\fbox{MemberB}\\
&5\ &\fbox{MemberB}\\
&6\ &\fbox{MemberB}\\
&7\ &\fbox{MemberB}\\
&8\ &\fbox{MemberC}\\
&9\ &\fbox{MemberC}\\
&10\ &\fbox{None}\\
&11\ &\fbox{None}\\
\end{aligned}}$

图中的 $\mathrm{None}$，即为适应**对齐规则**而留下的空洞。

而我如果再定义一个 `TypeB` 呢？就像这样：

```cpp
struct TypeB{
    byte Member1;
    TypeA Member2;
};
TypeB ElementB;
```

那么 `ElementB` 占据的地址长这样（假设没有定义元素 `ElementA`）：

$\mathrm{\displaystyle\begin{aligned}
&0\ &\fbox{Member1}\\
&1\ &\fbox{None}\\
&2\ &\fbox{None}\\
&3\ &\fbox{None}\\
&4\ &\fbox{MemberA}\\
&5\ &\fbox{MemberA}\\
&6\ &\fbox{None}\\
&7\ &\fbox{None}\\
&8\ &\fbox{MemberB}\\
&9\ &\fbox{MemberB}\\
&10\ &\fbox{MemberB}\\
&11\ &\fbox{MemberB}\\
&12\ &\fbox{MemberC}\\
&13\ &\fbox{MemberC}\\
&14\ &\fbox{None}\\
&15\ &\fbox{None}\\
\end{aligned}}$

其中第 $4\sim15$ 字节的地址被类型 `TypeA` 的 `Member2` 占据。

那么 `TypeB` 类型的元素的**对齐要求**为 $4$ 字节，占据地址为第 $0\sim15$ 字节。

没有问题吧？

## 操作实现

### 1. 类型的存储

由于需要定义很多新的类型，所以我们需要解决这些类型的存储问题。

具体地，我们可以构建一个结构体来表示一个类型。

先来看看一个类型需要些什么东西吧：

1. 类型名称。

2. 成员元素的类型，以及成员元素的名称。

3. 占据内存大小。

4. **对齐要求**，这个尤为重要。

于是我们可以得到一个这样的结构体：

```cpp
//类型结构体
struct Type{
    string Name;//类型名称
    vector<Type*> Member_Type;//类型成员类型
    vector<string> Member_Name;//类型成员元素
    ll Memory_Size;//类型占用内存大小
    ll Memory_Align;//类型对齐要求
    void clear(){
        Name.clear();
        Member_Type.clear();
        Member_Name.clear();
        Memory_Align=Memory_Size=0;
    }
};
```

此外，我们还需要存储已被定义过的类型：

```cpp
Type Def_Type[MAXN];//已被定义过的类型
ll Type_Num;//已被定义过的类型数量
```

还应该能够对于一个名称，找到对应的类型。

```cpp
map<string,Type*> Name_To_Type;//名称到类型的映射
```

这样，我们的类型存储系统就完成了：

```cpp
//类型结构体
struct Type{
    string Name;//类型名称
    vector<Type*> Member_Type;//类型成员类型
    vector<string> Member_Name;//类型成员元素
    ll Memory_Size;//类型占用内存大小
    ll Memory_Align;//类型对齐要求
    void clear(){
        Name.clear();
        Member_Type.clear();
        Member_Name.clear();
        Memory_Align=Memory_Size=0;
    }
};
Type Def_Type[MAXN];//已被定义过的类型
ll Type_Num;//已被定义过的类型数量
map<string,Type*> Name_To_Type;//名称到类型的映射
```



### 2. 元素的存储

除了声明一个结构体类型外，题目还要求我们支持定义元素。

对于元素，由于只有最外层的元素拥有自由的名称，因此我们只存储最外层的元素。

对于一个元素结构体，需要：

1. 元素类型。

2. 元素名称。

3. 元素起始地址。

于是可以写出这样的元素结构体：

```cpp
//元素结构体
struct Element{
    Type Ele_Type;//元素类型
    string Name;//元素名称
    ll Address;//元素起始地址
    void clear(){
        Ele_Type.clear();
        Name.clear();
        Address=0;
    }
};
```

同样地，我们还需要能够存储已被定义的元素，以及名称到元素的查找：

```cpp
Element Def_Ele[MAXN];//已被定义过的元素
ll Ele_Num;//已被定义过的元素数量
map<string,Element*> Name_To_Ele;//名称到元素的映射
```

这样，我们的元素存储系统就完成了：

```cpp
//元素结构体
struct Element{
    Type Ele_Type;//元素类型
    string Name;//元素名称
    ll Address;//元素起始地址
    void clear(){
        Ele_Type.clear();
        Name.clear();
        Address=0;
    }
};
Element Def_Ele[MAXN];//已被定义过的元素
ll Ele_Num;//已被定义过的元素数量
map<string,Element*> Name_To_Ele;//名称到元素的映射
```

### 3. 地址分配

地址分配与题面中的 2、3、4 操作有着密不可分的关系，对于地址的分配，我们显然也需要一个系统来维护。

具体地，我们只需要知道两个东西：“地址分配到了哪”，和“该地址处有什么东西”。

对于“地址分配到了哪”，我们可以用一个数记录：

```cpp
ll Addr_Pos;//已分配到的地址位置
```

而对于“该地址处有什么东西”，我们显然需要开一个映射。

不过这道题的地址可能会很大，所以一个一个地址去存显然不现实，于是考虑对于每一个元素，只以其地址的左右端点为键值：

```cpp
map<pr,Element*> Addr_To_Ele;//地址到元素的映射
```

但是在一个元素的内部会存在空洞怎么办？

那就是操作 4 需要考虑的问题了，这里先不管。

总得来说，我们的地址维护系统长这样：

```cpp
//地址
ll Addr_Pos;//已分配到的地址位置
map<pr,Element*> Addr_To_Ele;//地址到元素的映射
```

### 4. 初始化

在最开始没有任何操作时，存在四种**基本类型**：

1. `byte`，大小为 $1$ 字节，**对齐要求**为 $1$ 字节。

2. `short`，大小为 $2$ 字节，**对齐要求**为 $2$ 字节。

3. `int`，大小为 $4$ 字节，**对齐要求**为 $4$ 字节。

4. `long`，大小为 $8$ 字节，**对齐要求**为 $8$ 字节。

不难发现，**基本类型**的**对齐要求**就是它们的大小。

同时，**基本类型**没有成员类型。

所以我们需要进行预处理：

```cpp
//预处理
void init(){
    Def_Type[1].Name="byte";
    Def_Type[2].Name="short";
    Def_Type[3].Name="int";
    Def_Type[4].Name="long";
    Def_Type[1].Memory_Align=Def_Type[1].Memory_Size=1;
    Def_Type[2].Memory_Align=Def_Type[2].Memory_Size=2;
    Def_Type[3].Memory_Align=Def_Type[3].Memory_Size=4;
    Def_Type[4].Memory_Align=Def_Type[4].Memory_Size=8;
    Name_To_Type["byte"]=&Def_Type[1];
    Name_To_Type["short"]=&Def_Type[2];
    Name_To_Type["int"]=&Def_Type[3];
    Name_To_Type["long"]=&Def_Type[4];
    Type_Num=4;
}
```

### 4.5 间言

那么现在万事具备，只欠东风了。完成此题目需要的变量等东西都已经写好了，接下来讲解操作的实现。

### 5. 操作 1

操作 1 让我们创建一个新类型。

对于一个类型的各种要素，需要进行如下操作：

* 名称：这个就在输入里面，直接赋值即可。

* 成员：这个也在输入里面，遍历输入赋值即可。

* **对齐要求**：类型的**对齐要求**为其成员中的最大**对齐要求**，在遍历中访问每一个成员的**对齐要求**，然后取最大即可。

* 占用内存大小：这个需要斟酌一下，首先，不能单纯地计算成员大小的总和，因为需要注意**对齐规则**，在进入下一个成员的大小计算时，需要判断起始位置是否满足**对齐规则**，若不满足，则需要将起始位置后移。在所有成员计算完毕后，还应该判断这个类型的终止位置的下一位是否满足**对齐规则**，若不满足，则需将终止位置后移。最后计算出的终止位置与起始位置作差即可（不过默认起始位置为 $0$）。

最后，别忘了维护已被定义的类型的数组，以及类型名称到类型的映射。

具体代码如下：

```cpp
//创建一个类型的函数
void Type_Create(string type_name,ll num,string *ar1,string *ar2){
    Type New_Type;//创建一个新类型
    New_Type.clear();
    New_Type.Name=type_name;//名字直接赋值
    for(int i=1;i<=num;i++){
        New_Type.Member_Type.push_back(Name_To_Type[ar1[i]]);//成员类型直接赋值
        New_Type.Member_Name.push_back(ar2[i]);//成员名称直接赋值
    }
    ll pos=0;//起始地址默认为 0
    vector<Type*>::iterator it=New_Type.Member_Type.begin();
    for(;it!=New_Type.Member_Type.end();it++){//遍历成员
        ll Align=(*it)->Memory_Align;//成员对齐要求
        ll Size=(*it)->Memory_Size;//成员大小
        New_Type.Memory_Align=max(New_Type.Memory_Align,Align);//类型的对齐要求为其成员中的最大对齐要求
        if(pos%Align)pos=(pos/Align+1)*Align;//如果起始地址不满足对齐规则
        pos+=Size;//下一个成员的起始地址(这个成员的终止地址)
    }
    if(pos%New_Type.Memory_Align)
        pos=(pos/New_Type.Memory_Align+1)*New_Type.Memory_Align;//如果终止地址不满足对齐规则
    New_Type.Memory_Size=pos;//终止地址减去起始地址即为大小(起始地址默认为 0)
    Def_Type[++Type_Num]=New_Type;//别忘了维护这个数组
    Name_To_Type[type_name]=&Def_Type[Type_Num];//别忘了维护这个映射
}
```

### 6. 操作 2

操作 2 让我们创建一个新元素。

先来分析一下如何处理一个新元素的各种要素：

* 类型：这个就在输入里面，通过名称到类型的映射直接赋值即可。

* 名称：这个就在输入里面，直接赋值即可。

* 元素起始地址：这个直接赋为目前地址分配到的最高位置即可，但要注意，如果当前地址不满足**对齐规则**，则需要按**对齐要求**后移地址。

好像挺简单的？

然后别忘了维护已被定义过的元素的数组，以及元素名称到元素的映射。

最后，别忘了维护地址，因为一个类型的声明是不会占用内存的，而元素的定义是会切实占用内存的。

具体代码如下：

```cpp
//创建一个元素的函数
void Ele_Create(string type_name,string ele_name){
    Element New_Ele;//创建一个新元素
    New_Ele.clear();
    ll Align=Name_To_Type[type_name]->Memory_Align;//该元素的类型的对齐要求
    ll Size=Name_To_Type[type_name]->Memory_Size;//该元素的大小
    if(Addr_Pos%Align)Addr_Pos=((Addr_Pos/Align+1)*Align);//若起始位置不满足对齐规则
    New_Ele.Address=Addr_Pos;//起始地址赋值
    New_Ele.Ele_Type=*Name_To_Type[type_name];//通过映射找到该类型，赋值
    New_Ele.Name=ele_name;//名称直接赋值
    Def_Ele[++Ele_Num]=New_Ele;//别忘了维护这个数组
    Name_To_Ele[ele_name]=&Def_Ele[Ele_Num];//别忘了维护这个映射
    Addr_To_Ele[mp(Addr_Pos,Addr_Pos+Size-1)]=&Def_Ele[Ele_Num];//将元素的起始位置和终止位置作为键值加入元素
    Addr_Pos+=Size;//更新最高位地址
}
```

### 7. 操作 3

操作 3 让我们访问某个元素。

比较棘手的是，这个元素的名字中间是带点的。

这意味着我们需要先找到最外层元素，然后根据最外层元素的类型找到次外层元素，然后根据次外层元素的类型找到……

如此往复，是一个递归的过程。

不过实际上实现并不需要递归，具体地，分为以下几步：

1. 处理元素的名称，将中间的调用符（即 `.`）去掉，剩下的分开放入一个队列中。

2. 取出队首元素，弹出队首，根据元素的类型遍历成员名称，若是遇上了与新队首元素同名的成员，即停止遍历，更新起始地址。具体地，起始地址也需要满足**对齐规则**。

3. 重复 2 操作，直到队列为空。

最后，更新完毕的起始地址即为所需的答案。

具体代码如下：

```cpp
//访问某个元素的函数
ll Visit_Ele(string ele_name){
    queue<string> name;//存储名称的队列
    string tool;//如其名
    tool.clear();
    for(int i=0;i<(ll)ele_name.length();i++){//处理名称
        if(ele_name[i]=='.'){//如果遇上了调用符
            name.push(tool);
            tool.clear();
        }
        else tool+=ele_name[i];
    }
    name.push(tool);
    ll pos=Name_To_Ele[name.front()]->Address;//起始地址为最外层元素的起始地址
    Type type=Name_To_Ele[name.front()]->Ele_Type;//最外层元素的类型
    name.pop();
    while(!name.empty()){
        string Name=name.front();//取出队首
        name.pop();
        vector<string>::iterator it1=type.Member_Name.begin();//遍历成员名称
        vector<Type*>::iterator it2=type.Member_Type.begin();//遍历成员类型
        for(;it1!=type.Member_Name.end();it1++,it2++){
            if(pos%(*it2)->Memory_Align)
                pos=(pos/(*it2)->Memory_Align+1)*(*it2)->Memory_Align;//如果起始地址不满足对齐规则
            if(*it1==Name){//如果找到了新队首
                type=**it2;
                break;
            }
            else pos+=(*it2)->Memory_Size;//更新起始地址
        }
    }
    return pos;
}
```

### 8. 操作 4

操作 4 让我们访问一个地址。

这里最棘手的的地方在于：在**对齐规则**下，地址的分配并不是连续的，中间会出现空洞。

这意味着我们需要在访问时判断这个地址是否有元素占据。

具体地，可以分为一下几步：

1. 判断访问地址是否在某个元素内，即地址是否小于最高位地址。若是，进入 2；反之输出 `ERR`。

2. 通过地址到元素的映射找到该地址落于哪个元素之内。

3. 然后就和操作 3 一样，遍历元素的成员，找到地址在哪个成员中，记录下成员名称。

4. 判断地址合法性，若地址处于为了满足**对齐规则**而留下的空洞中，这时应该输出 `ERR`；反之进入 5。

5. 若此时元素类型为**基本元素**，则进入 6；反之重复 3。

6. 将记录下来的成员名称用调用符连接，输出。

好像比较复杂，其实和操作 3 差不了多少。

具体代码如下：

```cpp
//访问某个地址的元素
string Visit_Addr(ll addr){
    if(addr>=Addr_Pos)return "ERR";//判断地址是否在某个元素中
    Element ele;
    map<pr,Element*>::iterator it=Addr_To_Ele.begin();
    for(;it!=Addr_To_Ele.end();it++){//寻找地址所处的元素
        if(addr<(*it).first.first or addr>(*it).first.second)continue;
        ele=*((*it).second);
        break;
    }
    ll pos_goal=addr-ele.Address,pos_s=0,pos_t;//目标地址、起始地址、终止地址
    Type type=ele.Ele_Type;//当前元素类型
    string ele_name;//元素名称
    ele_name.clear();
    ele_name+=ele.Name;//元素名称先加上最外层元素名称
    while(!type.Member_Name.empty()){//循环直到元素类型为基本类型(此时元素类型没有成员)
        vector<Type*>::iterator it1=type.Member_Type.begin();//遍历当前元素类型的成员类型
        vector<string>::iterator it2=type.Member_Name.begin();//遍历当前元素类型的成员名称
        for(;it1!=type.Member_Type.end();it1++,it2++){
            pos_t=pos_s+(*it1)->Memory_Size;//更新终止地址
            if(pos_goal<pos_t and pos_goal>=pos_s){//如果目标地址在此成员中
                ele_name+='.'+*it2;//更新元素名称
                type=**it1;//更新元素类型
                //这两行代码需要注意：不可调换位置
                //因为 it2 是 type 的迭代器,type 更改后,it2 也会相应改变
                //因此需要在改变 type 之前调用 it2
                break;
            }
            else{//如果目标地址不在此成员中
                if(it1+1==type.Member_Type.end())return "ERR";//如果这个成员是最后一个成员了,说明目标地址为空洞
                ll Align=(*(it1+1))->Memory_Align;//该成员的对齐要求
                if(pos_t%Align)pos_t=(pos_t/Align+1)*Align;//如果终止地址不满足对齐规则
                if(pos_goal<pos_t)return "ERR";//如果目标地址在满足对齐规则后处于此成员内了,那么说明目标地址为空洞
                pos_s=pos_t;//更新起始位置
            }
        }
    }
    if(ele_name=="")return "ERR";//特判,若名称为空,则说明不存在元素包含这个地址
    return ele_name;
}
```

### 9. 框架

这大概是全代码中最简单的地方了。

具体代码如下：

```cpp
//工作
void work(){
    scanf("%lld",&n);//输入 n
    while(n--){
        scanf("%lld",&op);//输入操作类型
        if(op==1){//操作 1
            cin>>s>>k;
            for(int i=1;i<=k;i++)cin>>in1[i]>>in2[i];
            Type_Create(s,k,in1,in2);
            cout<<Def_Type[Type_Num].Memory_Size<<" "<<Def_Type[Type_Num].Memory_Align<<"\n";
        }
        else if(op==2){//操作 2
            cin>>ti>>ni;
            Ele_Create(ti,ni);
            cout<<Def_Ele[Ele_Num].Address<<"\n";
        }
        else if(op==3){//操作 3
            cin>>s;
            cout<<Visit_Ele(s)<<"\n";
        }
        else if(op==4){//操作 4
            cin>>addr_in;
            cout<<Visit_Addr(addr_in)<<"\n";
        }
    }
}
```

### 10. 间言二

那么到这里，所有的操作就都已经讲完了。

这时，只需要把刚刚实现的代码拼起来就好了。

最后，别忘了塞进主函数里：

```cpp
//主函数
int main(){
    init();
    work();
    return 0;
}
```

**注意：洛谷提交不需要写 `freopen`，但是考试时需要哦。**

## 代码总览

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pr;
const int MAXN=256;
ll max(ll x,ll y){return x>y?x:y;}
ll min(ll x,ll y){return x<y?x:y;}
pr mp(ll x,ll y){return (pr){x,y};}
//用来输入的变量
ll n,op,k,addr_in;
string s,ti,ni,in1[MAXN],in2[MAXN];
//类型结构体
struct Type{
    string Name;//类型名称
    vector<Type*> Member_Type;//类型成员类型
    vector<string> Member_Name;//类型成员元素
    ll Memory_Size;//类型占用内存大小
    ll Memory_Align;//类型对齐要求
    void clear(){
        Name.clear();
        Member_Type.clear();
        Member_Name.clear();
        Memory_Align=Memory_Size=0;
    }
};
Type Def_Type[MAXN];//已被定义过的类型
ll Type_Num;//已被定义过的类型数量
map<string,Type*> Name_To_Type;//名称到类型的映射
//元素结构体
struct Element{
    Type Ele_Type;//元素类型
    string Name;//元素名称
    ll Address;//元素起始地址
    void clear(){
        Ele_Type.clear();
        Name.clear();
        Address=0;
    }
};
Element Def_Ele[MAXN];//已被定义过的元素
ll Ele_Num;//已被定义过的元素数量
map<string,Element*> Name_To_Ele;//名称到元素的映射
//地址
ll Addr_Pos;//已分配到的地址位置
map<pr,Element*> Addr_To_Ele;//地址到元素的映射
//函数
void Nothing();//一个不知道干什么用也没有存在感的空函数
void init();//预处理
void Type_Create(string,ll,string*,string*);//创建一个类型的函数
void Ele_Create(string,string);//创建一个元素的函数
ll Visit_Ele(string);//访问某个元素的函数
string Visit_Addr(ll);//访问某个地址的元素
void work();//工作

//主函数
int main(){
    init();
    work();
    return 0;
}

//创建一个类型的函数
void Type_Create(string type_name,ll num,string *ar1,string *ar2){
    Type New_Type;//创建一个新类型
    New_Type.clear();
    New_Type.Name=type_name;//名字直接赋值
    for(int i=1;i<=num;i++){
        New_Type.Member_Type.push_back(Name_To_Type[ar1[i]]);//成员类型直接赋值
        New_Type.Member_Name.push_back(ar2[i]);//成员名称直接赋值
    }
    ll pos=0;//起始地址默认为 0
    vector<Type*>::iterator it=New_Type.Member_Type.begin();
    for(;it!=New_Type.Member_Type.end();it++){//遍历成员
        ll Align=(*it)->Memory_Align;//成员对齐要求
        ll Size=(*it)->Memory_Size;//成员大小
        New_Type.Memory_Align=max(New_Type.Memory_Align,Align);//类型的对齐要求为其成员中的最大对齐要求
        if(pos%Align)pos=(pos/Align+1)*Align;//如果起始地址不满足对齐规则
        pos+=Size;//下一个成员的起始地址(这个成员的终止地址)
    }
    if(pos%New_Type.Memory_Align)
        pos=(pos/New_Type.Memory_Align+1)*New_Type.Memory_Align;//如果终止地址不满足对齐规则
    New_Type.Memory_Size=pos;//终止地址减去起始地址即为大小(起始地址默认为 0)
    Def_Type[++Type_Num]=New_Type;//别忘了维护这个数组
    Name_To_Type[type_name]=&Def_Type[Type_Num];//别忘了维护这个映射
}

//创建一个元素的函数
void Ele_Create(string type_name,string ele_name){
    Element New_Ele;//创建一个新元素
    New_Ele.clear();
    ll Align=Name_To_Type[type_name]->Memory_Align;//该元素的类型的对齐要求
    ll Size=Name_To_Type[type_name]->Memory_Size;//该元素的大小
    if(Addr_Pos%Align)Addr_Pos=((Addr_Pos/Align+1)*Align);//若起始位置不满足对齐规则
    New_Ele.Address=Addr_Pos;//起始地址赋值
    New_Ele.Ele_Type=*Name_To_Type[type_name];//通过映射找到该类型,赋值
    New_Ele.Name=ele_name;//名称直接赋值
    Def_Ele[++Ele_Num]=New_Ele;//别忘了维护这个数组
    Name_To_Ele[ele_name]=&Def_Ele[Ele_Num];//别忘了维护这个映射
    Addr_To_Ele[mp(Addr_Pos,Addr_Pos+Size-1)]=&Def_Ele[Ele_Num];//将元素的起始位置和终止位置作为键值加入元素
    Addr_Pos+=Size;//更新最高位地址
}

//访问某个元素的函数
ll Visit_Ele(string ele_name){
    queue<string> name;//存储名称的队列
    string tool;//如其名
    tool.clear();
    for(int i=0;i<(ll)ele_name.length();i++){//处理名称
        if(ele_name[i]=='.'){//如果遇上了调用符
            name.push(tool);
            tool.clear();
        }
        else tool+=ele_name[i];
    }
    name.push(tool);
    ll pos=Name_To_Ele[name.front()]->Address;//起始地址为最外层元素的起始地址
    Type type=Name_To_Ele[name.front()]->Ele_Type;//最外层元素的类型
    name.pop();
    while(!name.empty()){
        string Name=name.front();//取出队首
        name.pop();
        vector<string>::iterator it1=type.Member_Name.begin();//遍历成员名称
        vector<Type*>::iterator it2=type.Member_Type.begin();//遍历成员类型
        for(;it1!=type.Member_Name.end();it1++,it2++){
            if(pos%(*it2)->Memory_Align)
                pos=(pos/(*it2)->Memory_Align+1)*(*it2)->Memory_Align;//如果起始地址不满足对齐规则
            if(*it1==Name){//如果找到了新队首
                type=**it2;
                break;
            }
            else pos+=(*it2)->Memory_Size;//更新起始地址
        }
    }
    return pos;
}

//访问某个地址的元素
string Visit_Addr(ll addr){
    if(addr>=Addr_Pos)return "ERR";//判断地址是否在某个元素中
    Element ele;
    map<pr,Element*>::iterator it=Addr_To_Ele.begin();
    for(;it!=Addr_To_Ele.end();it++){//寻找地址所处的元素
        if(addr<(*it).first.first or addr>(*it).first.second)continue;
        ele=*((*it).second);
        break;
    }
    ll pos_goal=addr-ele.Address,pos_s=0,pos_t;//目标地址、起始地址、终止地址
    Type type=ele.Ele_Type;//当前元素类型
    string ele_name;//元素名称
    ele_name.clear();
    ele_name+=ele.Name;//元素名称先加上最外层元素名称
    while(!type.Member_Name.empty()){//循环直到元素类型为基本类型(此时元素类型没有成员)
        vector<Type*>::iterator it1=type.Member_Type.begin();//遍历当前元素类型的成员类型
        vector<string>::iterator it2=type.Member_Name.begin();//遍历当前元素类型的成员名称
        for(;it1!=type.Member_Type.end();it1++,it2++){
            pos_t=pos_s+(*it1)->Memory_Size;//更新终止地址
            if(pos_goal<pos_t and pos_goal>=pos_s){//如果目标地址在此成员中
                ele_name+='.'+*it2;//更新元素名称
                type=**it1;//更新元素类型
                //这两行代码需要注意：不可调换位置
                //因为 it2 是 type 的迭代器,type 更改后,it2 也会相应改变
                //因此需要在改变 type 之前调用 it2
                break;
            }
            else{//如果目标地址不在此成员中
                if(it1+1==type.Member_Type.end())return "ERR";//如果这个成员是最后一个成员了,说明目标地址为空洞
                ll Align=(*(it1+1))->Memory_Align;//该成员的对齐要求
                if(pos_t%Align)pos_t=(pos_t/Align+1)*Align;//如果终止地址不满足对齐规则
                if(pos_goal<pos_t)return "ERR";//如果目标地址在满足对齐规则后处于此成员内了,那么说明目标地址为空洞
                pos_s=pos_t;//更新起始位置
            }
        }
    }
    if(ele_name=="")return "ERR";//特判,若名称为空,则说明不存在元素包含这个地址
    return ele_name;
}

//预处理
void init(){
    Def_Type[1].Name="byte";
    Def_Type[2].Name="short";
    Def_Type[3].Name="int";
    Def_Type[4].Name="long";
    Def_Type[1].Memory_Align=Def_Type[1].Memory_Size=1;
    Def_Type[2].Memory_Align=Def_Type[2].Memory_Size=2;
    Def_Type[3].Memory_Align=Def_Type[3].Memory_Size=4;
    Def_Type[4].Memory_Align=Def_Type[4].Memory_Size=8;
    Name_To_Type["byte"]=&Def_Type[1];
    Name_To_Type["short"]=&Def_Type[2];
    Name_To_Type["int"]=&Def_Type[3];
    Name_To_Type["long"]=&Def_Type[4];
    Type_Num=4;
}

//工作
void work(){
    scanf("%lld",&n);//输入 n
    while(n--){
        scanf("%lld",&op);//输入操作类型
        if(op==1){//操作 1
            cin>>s>>k;
            for(int i=1;i<=k;i++)cin>>in1[i]>>in2[i];
            Type_Create(s,k,in1,in2);
            cout<<Def_Type[Type_Num].Memory_Size<<" "<<Def_Type[Type_Num].Memory_Align<<"\n";
        }
        else if(op==2){//操作 2
            cin>>ti>>ni;
            Ele_Create(ti,ni);
            cout<<Def_Ele[Ele_Num].Address<<"\n";
        }
        else if(op==3){//操作 3
            cin>>s;
            cout<<Visit_Ele(s)<<"\n";
        }
        else if(op==4){//操作 4
            cin>>addr_in;
            cout<<Visit_Addr(addr_in)<<"\n";
        }
    }
}
```

# 尾言

这个题目我在考后很快就写出来了，但是在考场中并没有写出来，十分令人沮丧。

总体而言，这个题目并没有很复杂的设定或是逻辑，繁琐的地方也可以很容易地解决，难度是远远比不上猪国杀的。

其实对于大模拟，无非就两种情况：

1. 很快写好了。

2. 到处报段错误，然后一直调不出。

其实做到第一种并不难，前提是我们需要一个清醒的大脑，并且需要时刻保持清晰的逻辑，明白自己该做什么。

切忌糊里糊涂定义一大堆数组映射然后无脑胡。

这就是为什么考场里面我没有写出这一题——我看到题面之后思维并不是很清醒。

虽然作为一个考生，我很想骂一句：大模拟取似行不行！

但从理性的角度分析，我个人认为这是一道很好的模拟题，因为它既没有繁琐的题面，也没有毒瘤的设定，也没有通过堆叠要素来增加难度，同时想法也很好，实现的过程也并不枯燥，而且考场实现也具有一定难度。

总体来说，写下来以后，感觉是很爽的。

话说这次 CSP-S，不知有多少考生被这道大模拟直接打退役。

我在此想对这些人，以及所有人说：

不管是作为一个 OIer，还是作为一个人。

不管是在 OI 中，还是生活中。

如果头脑混沌、思路不清，就将到处是 `ERROR`，处处报段错，寸步难行。

只有保持清晰的想法，才能前进。

只有明白自己要做什么，才能成功。

在此，祝好在这次 CSP 中退役的选手们，希望你们在接下来的 whk 生活中顺利。

祝贺在这次 CSP 中获奖的选手们，希望你们在接下来的 OI 生涯中再接再厉。

------------

这大概是本蒟蒻写过的最长的一篇题解了，大家能看到这里也实属不易。

由于本题解篇幅较长，因此可能出现表述不清或错误的情况，请在评论区指出，或私信本人，感激不尽。

希望大家看得开心！

---

## 作者：KυρωVixen (赞：49)

# 2023 CPS-S T3 题解


### 前言：
TE 来抢题解啦。

感谢 CCF 出了一道大模拟放在第三题，使得我逆天改命最后两分钟过了这题，然后变成两周后高贵的 LA 群友。

我发现题解普遍是写的和我思路几乎一模一样，是标准的结构体指针写法。我的同学们还说我写结构体指针是脑残发作，这下这下了。

本人评价该题为正常难度蓝题。

## 解法：

### 准备工作
首先搞个结构体。然后存自己的别名和类型名，按照形式化题意维护相对偏移量，对齐参数，长度。用一个  ```vector``` 存自己的儿子指针。

初始化的方式采用一个 ```map``` 来存储默认结构体。别忘了存他给的四种初始数据类型。

当我们需要创造一个新的结构体时，就先声明一个空的范例结构体，按照题意给他分配对应的儿子节点（别忘了改儿子的别名），然后不断更新儿子的偏移量和自己的对齐参数，最后更新自己的长度和类型名字，存到 ```map``` 中去。这中间不会动自己的别名和相对偏移量，默认为空，要注意。

#### 代码：
```cpp
struct jiegou{
    string name,typ; //别名和类型
    int len,dq,py; //长度，对齐，相对父亲的偏移量
    vector<jiegou *>son; //儿子（嵌套的结构体）
    jiegou(){ py=len=dq=0; name=typ="";}
    jiegou(int len,string typ){
        this->py=0; this->len=len; this->dq=len; this->typ=typ; 
    }
};
map<string,jiegou>mp; //用于初始化结构体的一个map
int sqz(int a,int b){ return a/b+(int)(a%b>0); } //顾名思义，上取整
void build(string x,int k){
    jiegou tmp;
    tmp.typ=x;
    int py=0;
    jiegou *lst;
    rep(i,1,k){
        string typ,alia; cin>>typ>>alia;
        jiegou *tmp1=new jiegou(mp[typ]); tmp1->name=alia;
        tmp.dq=max(tmp1->dq,tmp.dq);
        if(i>1){
            tmp1->py=tmp1->dq*sqz(lst->py+lst->len,tmp1->dq);
        }
        tmp.son.push_back(tmp1); lst=tmp1;
    }
    tmp.len=tmp.dq*sqz(lst->len+lst->py,tmp.dq);
    mp[x]=tmp;
    cout<<tmp.len<<" "<<tmp.dq<<endl;
}
```

### 加入至内存池
我们可以把内存池当做一个没有别名、类型、长度的树根，然后动态维护它的对齐参数并默认它的偏移量为 $0$。这样我们的操作将简单的多。

#### 代码：
```cpp
jiegou *tr=new jiegou();
void add(string typ,string nam){
    jiegou *tmp=new jiegou(mp[typ]); tmp->name=nam;
    int x,y,st=0;
    vector<jiegou *>vec=tr->son; //简化一下，呜呜
    if(vec.empty()) x=0,y=0;
    else x=(*--vec.end())->py,y=(*--vec.end())->len;
    st=sqz(x+y,tmp->dq)*tmp->dq;
    tmp->py=st;
    tr->son.push_back(tmp); 
    cout<<st<<endl;
}
```

### 索引找内存
直接暴力分割出来每一层索引的名字然后暴力一层一层跳就可以了。这个没啥难度。

```cpp
int find(string x){
    vector<string>vec;
    int lst=0,len=x.length();
    rep(i,1,len)
        if(x[i-1]=='.') vec.push_back(x.substr(lst,i-lst-1)),lst=i;
    vec.push_back(x.substr(lst,len-lst)); //暴力分割索引
    jiegou *now=tr;
    int st=0,py;
    rep(i,1,vec.size()){ //暴力一层一层跳
        py=st;
        rep(j,1,now->son.size()){
            jiegou *k=now->son[j-1];
            py=st+k->py;
            if(k->name==vec[i-1]){
                st=py; now=k; break; 
            }
        }
    }
    return py;
}
```

### 内存找索引

递归找一下，暴力一层层跳，递归存一下目前的总偏移量，如果子节点包含这个区间就往下找。

一个小 trick：我的写法如果失配就会在最后一层正好返回一个 ```ERR```，也就是 ```x.xx.xxx.ERR``` 的格式，我懒得手写判定就直接判里面有没有子串是 ```ERR```，反正索引都是小写的。具体代码写主函数里面了。

#### 代码：
```cpp
string getbyadr(jiegou *now,int st,int tar){
    string ans="";
    rep(i,1,now->son.size()){
        jiegou *k=now->son[i-1];
        if(st+(k->py)<=tar&&tar<st+(k->py)+(k->len)){
            ans=k->name;
            if(k->son.size()) ans+="."+getbyadr(k,st+(k->py),tar);
            break;
        }
    }
    if(ans.empty()) return "ERR";
    else return ans;
}
```

### 主函数和宏定义

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define fi first
#define sc second
using namespace std;
#define int long long //为了保险开的，不少人没开ll痛失40分
/*
	结构体、变量的定义和各个函数的实现方式省略。
*/
signed main(){
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int n; cin>>n;
    mp["long"]=jiegou(8ll,"long");
    mp["int"]=jiegou(4ll,"int");
    mp["short"]=jiegou(2ll,"short");
    mp["byte"]=jiegou(1ll,"byte");
    rep(idk,1,n){
        int opt; cin>>opt;
        if(opt==1){
            string x; int y; cin>>x>>y;
            build(x,y);
        }
        else if(opt==2){
            string x,y; cin>>x>>y; add(x,y);
        }
        else if(opt==3){
            string x; cin>>x; cout<<find(x)<<endl;
        }
        else if(opt==4){
            int adr; cin>>adr;
            string ans=getbyadr(tr,0,adr);
            if(ans.find("ERR")!=-1) cout<<"ERR"<<endl;
            //一个取巧的方法（因为错误时其实上只有最后一层是ERR）
            else cout<<ans<<endl;
        }
    }
}
```

### 收尾：

感谢谷友们对我 OI 事业的支持，感谢家长和南外老师们对我 OI 事业的支持，希望你们看到的时候顶我上去，谢谢！

另外顺便提一句，赛后优化代码可以使代码最短用时小于 6 ms 并且长度小于 2.9 KiB。

---

## 作者：Register_int (赞：30)

大模拟。愤怒！

首先维护一些基本的信息。

#### 1. 封装变量/结构体

一个变量拥有以下信息：

- 占据空间大小
- 对齐要求
- 类型名称
- 变量名称

一个结构体拥有以下信息：

- 占据空间大小
- 对齐要求
- 类型名称
- 结构体内包含的变量

直接按定义维护即可。

```cpp
struct vari {
	ll len, align_len;
	string opt, name;
};

struct stru {
	ll len, align_len; string name;
	vector<vari> v;
	stru() { len = align_len = 0; name = ""; v.clear(); }
} all;
```

整个储存空间也可以视为一个结构体，这样可以大大减少编码难度。

接下来我们需要通过名称查询结构体或基本变量类型，容易用 map 解决。

```cpp
map<string, int> bas;
map<string, stru> mp;
```

基本类型只需要获取大小，所以不需要动用结构体。

#### 2. 对齐

直接根据题面模拟，设当前可用空间开头为 $n$，对齐要求为 $x$，可以得到实际储存位置为 $\left\lceil\dfrac nx\right\rceil\times x$。

```cpp
template
<typename T>
inline 
void align(T &n, int x) {
	n = (ll)ceil((long double)n / x) * x;
}
```

- - -

然后就是操作部分。

#### 1. 声明结构体

逐个读入变量，在插入时维护当前可用空间起始位置以及最大对齐要求。插入到对应的 vector 中后对齐即可。

```cpp
if (opt == 1) {
	cin >> s >> k; stru tmp; tmp.name = s;
	for (int i = 1, len; i <= k; i++) {
		cin >> t >> p; vari tp; tp.opt = t, tp.name = p;
		if (bas[t]) tp.len = tp.align_len = bas[t];
		else tp.len = mp[t].len, tp.align_len = mp[t].align_len;
		tmp.align_len = max(tmp.align_len, tp.align_len), tmp.v.push_back(tp);
		align(tmp.len, tp.align_len), tmp.len += tp.len;
	}
	align(tmp.len, tmp.align_len), mp[s] = tmp;
	printf("%lld %lld\n", tmp.len, tmp.align_len);
}
```

#### 2. 定义变量

先动态算出当前所有变量所占空间的末尾，再进行插入。记得要对齐。

```cpp
if (opt == 2) {
	cin >> t >> p, ans = 0;
	for (vari x : all.v) align(ans, x.align_len), ans += x.len;
	align(ans, bas[t] ? bas[t] : mp[t].align_len);
	all.v.push_back({ bas[t] ? bas[t] : mp[t].len, bas[t] ? bas[t] : mp[t].align_len, t, p });
	printf("%lld\n", ans);
}
```

#### 3. 访问成员

先把字符串以 $\verb!.!$ 为间隔拆开（例如样例 $\verb!x.ba.ab!$ 拆成 $\verb!x!$，$\verb!ba!$，$\verb!ab!$）。从所有变量所在的结构体 $\verb!all!$ 开始，暴力寻找每个元素，同时更新当前的空间头。不断向下寻找即可。

```cpp
if (opt == 3) {
	cin >> s, ans = 0; stru tmp = all;
	for (int i = 0, j; i < s.length(); i = j + 1) {
		for (j = i; j < s.length() && s[j] != '.'; j++);
		t = s.substr(i, j - i);
		for (vari x : tmp.v) {
			align(ans, x.align_len);
			if (x.name == t) { tmp = mp[x.opt]; break; }
			ans += x.len;
		}
	}
	printf("%lld\n", ans);
}
```

#### 4. 访问空间

最脑溢血的一集。

往下找的过程跟 #3 是一致的，而无解情况有两种：

- 空间被对齐空掉了
- 空间太往后了，没存东西

一定要记得这两种都要判。

```cpp
for (; ;) {
	for (vari x : tmp.v) {
		sum = ans, align(sum, x.align_len);
		if (sum <= ret && ret < sum + x.len) {
			ans = sum, sum += x.len;
			if (bas[x.opt]) { tmp.name = "?"; break; } // 返回标记 
			tmp = mp[x.opt]; break;
		}
		if (sum > ret) { f = 0; break; } // 被空出来了 
		ans = sum + x.len;
	}
	if (sum <= ret) f = 0; // 太往后了 
	if (tmp.name == "?" || !f) break;
}
if (!f) { puts("ERR"); continue; }
```

如果判定有解，那么按照同样的方法往下一层一层找。

```cpp
for (ans = 0, tmp = all; ;) {
	for (vari x : tmp.v) {
		sum = ans, align(sum, x.align_len);
		if (sum <= ret && ret < sum + x.len) {
			if (tmp.name != "all") putchar('.'); // 判断是否是第一层的变量。
			ans = sum, cout << x.name;
			if (bas[x.opt]) { tmp.name = "?"; break; }
			tmp = mp[x.opt]; break;
		}
		ans = sum + x.len;
	}
	if (tmp.name == "?") break;
}
puts("");
```

然后这题就结束了。

# AC 代码

3KB 的答辩。

```cpp
#include <bits/stdc++.h>

typedef long long ll;

using namespace std;

const int MAXN = 1e5 + 10;

struct vari {
	ll len, align_len;
	string opt, name;
};

struct stru {
	ll len, align_len; string name;
	vector<vari> v;
	stru() { len = align_len = 0; name = ""; v.clear(); }
} all;

map<string, int> bas;
map<string, stru> mp;

template
<typename T>
inline 
void align(T &n, int x) {
	n = (ll)ceil((long double)n / x) * x;
}

int n, k, opt; string s, t, p;

ll ans, sum, ret; bool f;

int main() {
	freopen("struct.in", "r", stdin);
	freopen("struct.out", "w", stdout);
	bas["byte"] = 1, bas["short"] = 2;
	bas["int"] = 4, bas["long"] = 8, all.name = "RiAKIOI";
	for (scanf("%d", &n); n--;) {
		scanf("%d", &opt);
		if (opt == 1) {
			cin >> s >> k; stru tmp; tmp.name = s;
			for (int i = 1, len; i <= k; i++) {
				cin >> t >> p; vari tp; tp.opt = t, tp.name = p;
				if (bas[t]) tp.len = tp.align_len = bas[t];
				else tp.len = mp[t].len, tp.align_len = mp[t].align_len;
				tmp.align_len = max(tmp.align_len, tp.align_len), tmp.v.push_back(tp);
				align(tmp.len, tp.align_len), tmp.len += tp.len;
			}
			align(tmp.len, tmp.align_len), mp[s] = tmp;
			printf("%lld %lld\n", tmp.len, tmp.align_len);
		}
		if (opt == 2) {
			cin >> t >> p, ans = 0;
			for (vari x : all.v) align(ans, x.align_len), ans += x.len;
			align(ans, bas[t] ? bas[t] : mp[t].align_len);
			all.v.push_back({ bas[t] ? bas[t] : mp[t].len, bas[t] ? bas[t] : mp[t].align_len, t, p });
			printf("%lld\n", ans);
		}
		if (opt == 3) {
			cin >> s, ans = 0; stru tmp = all;
			for (int i = 0, j; i < s.length(); i = j + 1) {
				for (j = i; j < s.length() && s[j] != '.'; j++);
				t = s.substr(i, j - i);
				for (vari x : tmp.v) {
					align(ans, x.align_len);
					if (x.name == t) { tmp = mp[x.opt]; break; }
					ans += x.len;
				}
			}
			printf("%lld\n", ans);
		}
		if (opt == 4) {
			cin >> ret, ans = 0; stru tmp = all; f = 1;
			for (; ;) {
				for (vari x : tmp.v) {
					sum = ans, align(sum, x.align_len);
					if (sum <= ret && ret < sum + x.len) {
						ans = sum, sum += x.len;
						if (bas[x.opt]) { tmp.name = "?"; break; } 
						tmp = mp[x.opt]; break;
					}
					if (sum > ret) { f = 0; break; } 
					ans = sum + x.len;
				}
				if (sum <= ret) f = 0; 
				if (tmp.name == "?" || !f) break;
			}
			if (!f) { puts("ERR"); continue; }
			for (ans = 0, tmp = all; ;) {
				for (vari x : tmp.v) {
					sum = ans, align(sum, x.align_len);
					if (sum <= ret && ret < sum + x.len) {
						if (tmp.name != "RiAKIOI") putchar('.');
						ans = sum, cout << x.name;
						if (bas[x.opt]) { tmp.name = "?"; break; }
						tmp = mp[x.opt]; break;
					}
					ans = sum + x.len;
				}
				if (tmp.name == "?") break;
			}
			puts("");
		}
	}
}
```

---

## 作者：ZioushCioushYioush (赞：21)

## 前言

比较 nortan 的模拟题。考场上 A 了。

蒟蒻的第一篇题解 qaq。

## 题意

他给了四种基本类型，通过基本类型定义结构体，通过类型定义变量。你要模拟出变量占用的位置。

CCF 给的解释还是很 ~~sb~~ 的。

解释一下：对于每一个**类型**，有 $3$ 个**基本参数**：名称、对齐要求、大小。

对于结构体类型，还有非基本的参数，也就是他们里头的元素的名称、对齐要求、大小等。

对于每一个**元素**，有 $3$ 个参数：名称、类型、首地址。

关于这个对齐要求：看灵魂画手画的图

![](https://cdn.luogu.com.cn/upload/image_hosting/5cduc1ye.png)

其中红色是 `byte` 类型，绿色是 `int` 类型。

对于第一行，先定义了一个 `byte` 再定义一个 `int`，由于对齐要求限制，`int` 类型元素的头地址是从 $4$ 开始，而非 `byte` 元素后面的 $1$。结构体的大小为 $8$。

对于第二行，先定义了一个 `int` 再定义一个 `byte`，`byte` 类型的元素已经对齐。但因为整个结构体的大小也应整除对齐要求，所以该结构体的长度也是 $8$，而不是 `byte` 元素后面的那一位 $5$。

## 开题

### 类型与变量的处理

```cpp
using hash_t=unsigned int;

struct Type{
	int n;//子元素个数
	int type[maxn];//子元素类型编号
	std::unordered_map<hash_t,int> name;//子元素名称与类型的映射
	char names[maxn][12];//子元素名称
	ll Size;//类型大小
	ll Req;//类型对齐要求
	ll Pos[maxn];//相对位置（重要）
}type[maxn];
```

有没有发现上述代码遗漏了类型名称。我使用 hash 处理。

```cpp
std::unordered_map<hash_t,int> typeName;
```

但是完全没必要多套一层 hash，可以直接以 `std::string` 为键。

这里我认为有必要使用指针。指针可以缩短代码长度，比如接下来你将会看到的 `type[type[typid].type[eleid]].Size`，使用指针的话就会变成 `typ->type[eleid]->size`。

对于每一个**变量**，也需要结构体和 hash 处理。

```cpp
std::unordered_map<hash_t,int> elemName;

struct Element{
	int type;
	ll Addr;//绝对位置，注意！
	char name[12];
}elem[maxn]; 
```

### 初始化基本类型

对于基本类型，需要在一开始就给他参数初始化。

```cpp
void init(){
	type[1].n=type[2].n=type[3].n=type[4].n=0;
	typeName.emplace(toHash((char*)"byte"), 1);
	typeName.emplace(toHash((char*)"short"),2);
	typeName.emplace(toHash((char*)"int"),  3);
	typeName.emplace(toHash((char*)"long"), 4);
	type[1].Size=type[1].Req=1ll;
	type[2].Size=type[2].Req=2ll;
	type[3].Size=type[3].Req=4ll;
	type[4].Size=type[4].Req=8ll;
	tcnt=4;//类型总个数
}
```

这里面其实有很多地方写的比较复杂，比如 `emplace` 可以用 `[]=` 代替。

## 可爱的操作们

### 操作 1：定义类型

这些操作的代码又臭又长。代码见[完整代码](https://www.luogu.com.cn/paste/te9knosv)。

在定义类型的时候，我们需要处理的是各个元素的**相对位置**，以及整个类型的基本参数。

注意一点：`struct Type` 中的每一个元素在这里都应该被赋值！一个一个地检查、赋值！

### 操作 2：定义元素

与上面同理。每一个元素都要被赋值！

当然注意你的 hash 表添加元素了吗？

### 操作 3：访问元素

注意，查询操作都分两段完成：

- 查询变量
- 查询变量内的元素（很像剪枝 dfs/bfs）

访问元素类似于搜索。但是可以不用递归。

我的操作方式是先将输入读完，在一步一步地处理每个元素的 hash 值。

这里要注意的是，每次更新答案的时候应使答案**加上**元素的相对位置。

```cpp
eleid=type[typid].name.find(getNext(st,count))->second;
ans+=type[typid].Pos[eleid];
typid=type[typid].type[eleid];
```

这是核心代码。首先先找到当前元素的 id，更新答案，最后“进入下一层”，也就是找到当前元素的类型id。

同时注意点到为止。保证每次答案都是当前“层数”访问元素的头地址，就可以做到随时停止。

### 操作 4：访问地址

同理。把上面的答案反着来访问，每次更新地址的时候**减去**元素的相对位置。

同时可以剪枝。如果访问到当前“层”的空隙，直接 `return`。（可以避免访问到神秘元素）。

判断当前层 `Addr` 处有元素（可能下一层就没有元素了）：

`type[typid].Pos[eleid] <= Addr and Addr < type[typid].Pos[eleid] + type[type[typid].type[eleid]].Size`

```cpp
Addr-=type[typid].Pos[eleid];
strcat(s,type[typid].names[eleid]);
strcat(s,".");
typid=type[typid].type[eleid];
flag=true;
break;
```

注意：这一段代码是在遍历当前层包含的元素时写的。

最外层套上 `while(type[typid].n)` 即可让你的程序访问到基本类型，因为基本类型的 $n=0$。

## 完整代码

[有 200 行，放云剪贴板里咯。](https://www.luogu.com.cn/paste/te9knosv)

---

## 作者：Genius_Star (赞：12)

### 思路；

~~题意懒的敲了……~~

#### 操作 1：

**注意：在结构体内，如果有结构体成员，应该按照其成员最大内存对齐。~~我考场这个错误，65pts 直接就没了~~**

定义一个结构体，有 $cnt_i$ 个成员，第 $j$ 个成员的类型为 $s_{i,j}$，名称为 $k_{i,j}$，输出该结构体的大小和对齐要求。

很明显，有一个性质，定义 $size_i$ 为结构体 $i$ 的大小，只要确定了起始位置 $now$，放置 $i$ 号结构体，那么在 $now \sim now+size_i+1$ 之间肯定就是其地址所在范围。

从初始地址 $x=0$ 开始，设第 $j$ 个成员的对齐要求为 $t_j$，长度为 $d_j$，如果 $x \bmod t_j=0$，那么可以直接放置，则当前成员结束位置为 $x+d_j-1$，将 $x \to x+d_j$；

否则需要对齐，找到下一个 $t_j$ 的倍数为 $\lceil \frac{x}{t_j} \rceil \times t_j$，那么起始元素位置为 $\lceil \frac{x}{t_j} \rceil \times t_j$，结束位置为 $\lceil \frac{x}{t_j} \rceil \times t_j+d_j-1$，将 $x \to \lceil \frac{x}{t_j} \rceil \times t_j +d_j$。

这样可以 $O(cnt_i)$ 求出大小和对齐要求。

这里同时预处理一下 $l_{i,j}$ 和 $r_{i,j}$，表示第 $i$ 个结构体的第 $j$ 个成员的初始位置和结束位置，对于后面的操作需要使用。

#### 操作 2：

定义一个变量，输出这个变量的初始存储地址。

这里最好想，定义 $now$ 为当前内存大小，初始为 $0$。

设我们新定义的变量对齐要求为 $t$，大小为 $d$，那么和之前操作 $1$ 一样，看一下是否对齐即可。

然后设 $L_i,R_i$ 为第 $i$ 个定义的变量初始地址和结束地址，$S_i$ 为其名称，同样后面操作需要使用。

时间复杂度：$O(\log n)$，需要用 map 找一下当前这个变量是哪个操作 $1$ 定义的结构体或者基本类型。

#### 操作 3：

访问某个元素，输出这个元素的起始地址。

这里涉及到了一个嵌套，我们先把第 $1$ 个 ``.`` 号（没 ``.`` 号的话特判一下，是基本类型）之前的字符串提取出来，这肯定是之前操作 $2$ 定义的变量。

找到这个新定义的变量，设为 $l$（且是第 $i$ 个定义的变量），答案为 $p$（初始肯定设为 $L_i$），这肯定是一个结构体，然后将第 $2$ 个 ``.`` 号到第 $1$ 个 ``.`` 号之间的字符串提取出来，这肯定是结构体 $l$ 的成员，找到这个成员，设这个成员为 $k$，那么需要将 $d \to d+l_k$，一直重复到读取了全部的字符为止，输出我们的 $d$ 即可。

时间复杂度为 $O(n^2)$，用一个 map 进行维护的话复杂度可以优化到 $O(n \log n)$。

#### 操作 4：

给定一个地址 $x$，按照操作 $3$ 输入的格式输出在这个地址上的基本元素，没有的话输出 ``ERR``。

按照和操作 $3$ 类似的思路，找到一个定义的变量 $i$，使得 $L_i \le x \le R_i$（即在这个变量的地址之中），然后将 $x \to x-L_i$，没有的话直接输出 ``ERR``。

然后在这个变量中，依次遍历每一个成员，找到满足 $l_j \le x \le r_j$ 的 $j$（即在这个成员的地址范围中），然后在将 $x \to x-l_j$（再次缩小地址范围），一直执行到当前 $j$ 这个成员是一个基础变量为止。

最后在这样迭代的时候依次输出路径中变量的名称即可。

时间复杂度为 $O(n^2)$，用二分优化的话可以优化到 $O(n \log n)$。

**该代码目前跑了 98ms，写了 225 行。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=105;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
class Struct{
public:
	ll cnt=0,Max=0,size=0;
	bool f[N];
	string s[N],k[N];
	ll l[N];
	ll r[N];
	map<string,ll> p;
}a[N];
struct Node{
	ll x;
	ll l,r;
	string s;
}b[N];
ll T,n,cnt=0,l=0,now=0,ask=0,op;
string s,x,y;
map<string,ll> JG,JC,DY;
void init(){
	JC["byte"]=1;
	JC["short"]=2;
	JC["int"]=4;
	JC["long"]=8;
}
ll solve(ll l,ll x){
	for(ll i=1;i<=a[l].cnt;i++){
		if(a[l].f[i]){
			ll s=JG[a[l].s[i]];
			ll t=a[s].size,d=a[s].Max;
			if(x%d==0){
				a[cnt].l[i]=x;
				x+=t;
			}
			else{
				a[cnt].l[i]=((x+d-1)/d)*d;
				x=((x+d-1)/d)*d+t;
			}
		}
		else{
			ll t=JC[a[l].s[i]];
			if(x%t==0){
				a[cnt].l[i]=x;
				x+=t;
			}
			else{
				a[cnt].l[i]=((x+t-1)/t)*t;
				x=((x+t-1)/t)*t+t;
			}
		}
		a[cnt].r[i]=x-1;
	}
	if(x%a[l].Max!=0)
	  x=((x+a[l].Max-1)/a[l].Max)*a[l].Max;
	return x;
}
void Add(ll A,ll B,ll C){
	b[++l]={A,B,C,y};
}
void solve1(){
	ll l=0,v=x.size(),d;
	bool f=0;
	s="";
	for(ll i=0;i<v;i++){
		if(x[i]=='.'||i==(v-1)){
			if(i==(v-1))
			  s+=x[i];
			if(!f){
				ll t=DY[s];
				d=b[t].l;
				if(i==(v-1)){
					printf("%lld\n",d);
					return ;
				}
				else
				  l=b[t].x;
				f=1;
			}
			else{
				ll t=a[l].p[s];
				if(i==(v-1)){
					printf("%lld\n",d+a[l].l[t]);
					return ;
				}
				else{
					d+=a[l].l[t];
					l=JG[a[l].s[t]];
				}
			}
			s="";
		}
		else
		  s+=x[i];
	}
}
void solve2(ll x){
	string s;
	for(ll i=1;i<=l;i++){
		if(x>=b[i].l&&x<=b[i].r){
			if(b[i].x<0)
			  printf("%s\n",b[i].s.c_str());
			else{
				ll k=b[i].x;
				x-=b[i].l;
				s+=b[i].s+".";
				while(1){
					bool f=1;
					for(ll i=1;i<=a[k].cnt;i++){
						if(x>=a[k].l[i]&&x<=a[k].r[i]){
							f=0;
							s+=a[k].k[i];
							if(!a[k].f[i]){
								printf("%s\n",s.c_str());
								return ;
							}
							s+=".";
							x-=a[k].l[i];
							k=JG[a[k].s[i]];
						}
					}
					if(f){
						puts("ERR");
						break;
					}
				}
			}
			return ;
		}
	}
	puts("ERR");
}
int main(){
//	freopen("A.in","r",stdin);
//	freopen("A.out","w",stdout);
	init();
	T=read();
	for(ll Y=1;Y<=T;Y++){
		op=read();
		if(op==1){
			cin>>s;
			n=read();
			++cnt;
			for(ll i=1;i<=n;i++){
				cin>>x>>y;
				++a[cnt].cnt;
				a[cnt].p[y]=i;
				a[cnt].k[i]=y;
				a[cnt].s[a[cnt].cnt]=x;
				if(JC[x])
				  a[cnt].Max=max(JC[x],a[cnt].Max);
				else{
					a[cnt].f[a[cnt].cnt]=1;
					a[cnt].Max=max(a[JG[x]].Max,a[cnt].Max);
				}
			}
			JG[s]=cnt;
			a[cnt].size=solve(cnt,0);
			printf("%lld %lld\n",a[cnt].size,a[cnt].Max);
		}
		else if(op==2){
			cin>>x>>y;
			if(JC[x]){
				ll t=JC[x];
				if(now%t==0){
					printf("%lld\n",now);
					Add(-t,now,now+t-1);
					now+=t;
				}
				else{
					printf("%lld\n",((now+t-1)/t)*t);
					Add(-t,((now+t-1)/t)*t,((now+t-1)/t)*t+t-1);
					now=((now+t-1)/t)*t+t;
				}
			}
			else{
				ll l=JG[x],t=a[l].size,d=a[l].Max;
				if(now%d==0){
					printf("%lld\n",now);
					Add(l,now,now+t-1);
					now+=t;
				}
				else{
					printf("%lld\n",((now+d-1)/d)*d);
					Add(l,((now+d-1)/d)*d,((now+d-1)/d)*d+t-1);
					now=((now+d-1)/d)*d+t;
				}
			}
			DY[y]=l;
		}
		else if(op==3){
			cin>>x;
			solve1();
		}
		else{
			ask=read();
			solve2(ask);
		}
	}
	return 0;
}
```


---

## 作者：KobeBeanBryantCox (赞：10)

# P9754 [CSP-S 2023] 结构体 题解

------------

update on 2024.8.23：修了点格式，并且针对[这个帖子](https://www.luogu.com.cn/discuss/905071)中的 hack 数据修改了代码。

感谢[@Y204335](https://www.luogu.com.cn/user/360974) 大佬提出了本题解的错误！

------------

###  本题解有数据生成器！~~（虽然是转载的）~~

[题目传送门](https://www.luogu.com.cn/problem/P9754)。

~~CCF 太毒瘤了，竟然在第 3 题放大模拟。~~

------------

## 题意

四种操作：
1. 定义一个结构体，不占内存。输出该结构体的大小和对齐要求。
2. 定义一个普通变量或结构体变量，占相应内存。输出这个变量在内存中的起始位置。
3. 查询某个元素在内存中的起始位置。
4. 查询内存中某个位置的元素是什么，如果这个位置没有元素，输出 `ERR`。

具体要求见题目描述。~~（因为我也不是很好解释）~~

------------

## 分析

~~先说我之前的代码错在哪里，就错在没开 long double。（update on 2024.8.23）~~

数据范围：$1\leq n\leq 100$，$1\leq k\leq 100$，$0\leq addr\leq 10^{18}$，题目保证任意结构体大小及定义的元素占据的最高内存地址均不超过 $10^{18}$。

数据范围不大~~（而且这种题数据范围也不可能大）~~，于是这个题就一定是大模拟了。

ps：由于此题是个大模拟，所以接下来的解释有可能会很绕。我尽量解释得清楚一点，尽量把代码写得可读性更高一点。如果看不懂，欢迎讨论。

------------

### 准备工作

由于最大数据达到了 $10^{18}$ 的大小，**所以要开 `long long`**。

```cpp
typedef long long ll; // 把 long long 换个名字，叫做 ll 
```

先在代码里定义两个结构体：

1. 表示**题目中的单个变量或者结构体中的元素**。

```cpp
/***********************************************单个元素***********************************************/
struct yuansu
{
	string leixing,name; // 元素的 类型 和 名字
	ll daxiao,qishi; // 这个元素 占用内存大小 和 它在内存中的起始位置
	// qishi=-1 表示这个元素是在结构体里的元素
}yuan[N];
ll yuan_count=0; // 当前有多少个元素
map<string,ll>yingshe_yuan; // 名字为 string 的元素在 yuan 数组里的编号是多少，相当于映射
/***********************************************单个元素***********************************************/
```

2. 表示**题目中的结构体**。

```cpp
/************************************************结构体************************************************/
struct struc
{
	string name; // 结构体名字 
	ll geshu,daxiao,duiqiyaoqiu; // 成员个数、结构体大小 和 结构体对齐要求 
	vector<yuansu>member; // 成员，注意类型是 yuansu 
	vector<ll>pianyi; // 每个成员在结构体中的偏移量 
}str[N];
ll str_count=0; // 当前有多少个结构体 
map<string,ll>yingshe_str; // 名字是 string 的结构体在 str 数组里的编号是多少，相当于映射 
/************************************************结构体************************************************/
```

再定义几个函数：

```cpp
ll big(string x) // 元素大小，x 是元素类型 
{
	if(x=="byte")return 1;
	else if(x=="short")return 2;
	else if(x=="int")return 4;
	else if(x=="long")return 8;
	else return str[yingshe_str[x]].daxiao;
}
yuansu find1(ll x) // 找在内存中不超过 x 的位置的元素 
{
	ll l=1,r=yuan_count,ans=1;
	while(l<=r) // 二分查找 
	{
		ll mid=(l+r)>>1;
		if(yuan[mid].qishi<=x)ans=mid,l=mid+1;
		else r=mid-1;
	}
	return yuan[ans];
}
```

除了这两个函数之外，还有 `in`，`out`，`ins`，`outs`，分别是快读整型、快输整型、快读字符串 和 快输字符串。

------------

接下来是重点。

### 操作 1

**定义一个结构体，不占内存。输出该结构体的大小和对齐要求。**

```cpp
string name=ins(); // 读入结构体名字 
ll geshu=in(); // 读入成员个数 
str[++str_count].geshu=geshu;
str[str_count].name=name;
yingshe_str[name]=str_count; // 映射值 
ll pianyi=0; // 每个成员在结构体中的地址偏移量 
for(ll i=1;i<=geshu;i++)
{
	string leixing=ins(),name=ins(); // 成员的类型和名字 
	ll bigg=0; // 计算对齐要求 
	if(leixing=="byte")bigg=1;
	else if(leixing=="short")bigg=2;
	else if(leixing=="int")bigg=4;
	else if(leixing=="long")bigg=8;
	else bigg=str[yingshe_str[leixing]].duiqiyaoqiu;
	str[str_count].member.push_back((yuansu){leixing,name,big(leixing),(ll)(-1)}); // 添加一个成员 
	str[str_count].duiqiyaoqiu=max(str[str_count].duiqiyaoqiu,bigg); // 对齐要求取成员对齐要求的最大值 
	pianyi=ceil((long double)pianyi/bigg)*bigg; // 地址偏移，见题目提示，自行理解 
	// update on 2024.8.23：开 long double
	str[str_count].pianyi.push_back(pianyi);
	pianyi+=big(leixing); // 偏移量加上大小就是下一个成员的偏移量 
}
pianyi=ceil((long double)pianyi/str[str_count].duiqiyaoqiu)*str[str_count].duiqiyaoqiu; // 偏移量增加，见题目提示，自行理解 
// update on 2024.8.23：开 long double
str[str_count].daxiao=pianyi; // 结构体大小就是总的偏移量 
out(pianyi),putchar(' '),out(str[str_count].duiqiyaoqiu); // 按要求输出 
```

------------

### 操作 2

**定义一个普通变量或结构体变量，占相应内存。输出这个变量在内存中的起始位置。**

```cpp
string leixing=ins(),name=ins(); // 变量的类型和名字 
yuan[++yuan_count].leixing=leixing;
yuan[yuan_count].name=name;
ll daxiao=big(leixing),bigg=0; // 该变量的大小和对齐要求
// 这里题目没有要求计算对齐要求，但是这是为了地址偏移量而计算的 
if(leixing=="byte")bigg=1;
else if(leixing=="short")bigg=2;
else if(leixing=="int")bigg=4;
else if(leixing=="long")bigg=8;
else bigg=str[yingshe_str[leixing]].duiqiyaoqiu;
yuan[yuan_count].daxiao=daxiao;
neicun=ceil((long double)neicun/bigg)*bigg; // 内存偏移 
// update on 2024.8.23：开 long double
yuan[yuan_count].qishi=neicun; // 起始位置 
yingshe_yuan[name]=yuan_count; // 映射 
out(neicun),neicun+=daxiao; // 按要求输出，内存加上变量大小就是下一个变量的起始位置 
```

------------

### 操作 3

**查询某个元素在内存中的起始位置。**

从操作 3 开始就会稍微有点难以理解，请仔细阅读代码。

```cpp
string y=ins();y+='.'; // 输入查询的元素，末尾加上 . 方便处理 
string name="",leixing=""; // 循环查找时 元素的名字和类型 
ll ans=0,i=0;
// 由于元素是 变量 + 多个结构体中的成员 组成的，所以分两个循环写 
for(i=0;i<y.size();i++) // 找变量 
	if(y[i]=='.')
	{
		yuansu t=yuan[yingshe_yuan[name]]; // 找到这个变量 
		ans=t.qishi;
		leixing=t.leixing;
		name="";
		break;
	}
	else name+=y[i];
for(i++;i<y.size();i++) // 这个循环有递归的思想，不懂的话可以拿样例模拟一下 
	if(y[i]=='.')
	{
		struc t=str[yingshe_str[leixing]];
		for(ll j=0;j<t.geshu;j++) // 找成员 
			if(t.member.at(j).name==name) // 找到成员 
			{
				ans+=t.pianyi.at(j); // 加上偏移量 
				leixing=t.member.at(j).leixing; // 类型改变，准备下一次在新的类型中查找
				break;
			}
		name="";
	}
	else name+=y[i];
out(ans); // 按要求输出 
```

------------

### 操作 4

**查询内存中某个位置的元素是什么，如果这个位置没有元素，输出 `ERR`。**

这个操作是最难写的也是最难读懂代码的。

```cpp
ll addr=in();
if(addr>=neicun) // 如果输入的内存大于当前的内存，那肯定是没有元素的 
{
	outs("ERR"),putchar('\n');
	continue;
}
yuansu t=find1(addr); // 找到最接近且不超过 查询的内存 的单个变量 
// 由于内存是按顺序分配的，所以满足单调性，可以二分查找 
string ans="";
ans+=t.name;
string leixing=t.leixing;
ll weizhi=t.qishi; // 现在循环到内存的位置 
bool ff=true;
if(leixing=="byte"||leixing=="short"||leixing=="int"||leixing=="long") // 注意这个特判，删了只有 85 分 
	if(weizhi+big(leixing)<=addr)ff=false; // 这个特判的意思是，如果找到的变量的类型不是结构体（即普通变量）
	// 那么如果变量起始位置加上变量的大小，没有到达查询的位置，说明查询的位置在当前变量与下一个变量的空隙中，输出 ERR 
while(leixing!="byte"&&leixing!="short"&&leixing!="int"&&leixing!="long"&&ff) // 一直找，找到成员是普通元素为止 
// 这个循环可以参照操作 3 的循环来思考，也是有递归的思想 
{
	struc tt=str[yingshe_str[leixing]]; // 找到这个结构体 
	ll i;
	for(i=0;i<tt.geshu;i++) // 遍历成员 
	{
		if(weizhi+tt.pianyi.at(i)>addr) // 如果当前成员的位置已经大于查询的位置，说明在前面没有找到相应的元素
		//（即查询的位置在当前成员和上一个成员的空隙中），输出 ERR 
		{
			ff=false;
			break;
		}
		ll daxiao=tt.member.at(i).daxiao;
		if(weizhi+tt.pianyi.at(i)+daxiao>addr) // 如果当前成员的位置小于查询位置，加上大小后又大于查询位置
		// 说明这个元素包裹了查询位置，于是就进入下一个结构体中继续细分 
		// 注意这里的大于号如果写成大于等于就只有 15 分 
		{
			string lx=tt.member.at(i).leixing;
			leixing=lx; // 改变类型，继续细分，找到不能找为止 
			weizhi+=tt.pianyi.at(i); // 记得加上偏移量 
			ans+="."+tt.member.at(i).name;
			break;
		}
	}
	if(i==tt.geshu)ff=false; // 这个删了就会死循环超时
	// 1. 从代码角度来解释：在循环中没有找到相应的元素，是 i 超过范围退出循环的，不是 break 的
	// 所以类型一直没有改变，所以最外层的循环会死循环
	// 2. 从题目角度来解释：循环中没找到，查询位置肯定是在 当前元素的最后一个成员 与 内存中下一个元素
	// （如果下一个元素是结构体的话，那就是下一个元素的第一个成员）的空隙中，输出 ERR 
}
if(!ff)outs("ERR"); // 不符合要求，输出 ERR 
else outs(ans);
```

------------

## 完整 AC 代码（赛后重构代码）

非赛时代码，考场上我没写出来，喜提 $5$ pts。

由于代码较长，就放云剪贴板里面。

[Code](https://www.luogu.com.cn/paste/qng329pi)。

[鬼知道我调了多久代码](https://www.luogu.com.cn/record/list?user=865625&pid=P9754&page=1)。

另：附上 @[zymooll](https://www.luogu.com.cn/user/289296) 大佬写的数据生成器，可以用来对拍。~~（我就是用这个东西与正解对拍才把我的代码改成正解的）~~

```cpp
// Author:zymooll

#include<bits/stdc++.h>

#if defined(__linux__)
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#elif defined(_WIN32)
#define getchar _getchar_nolock
#define putchar _putchar_nolock
#endif

#define int long long
using namespace std;

const int n = 100;
const int k = 100;
const int slen = 10;
const bool A = 0;
const bool B = 0;
const bool C = 0;
const bool D = 0;

int tot1 = 0;//记录 1 操作的总次数
map<string, int>mp;//结构体名称映射
map<string, bool>vis;//标记成员的出现情况

struct S{
  string nam;
  vector<pair<int, string> >mem;
};
vector<S>stru;//记录随机出的

random_device rd;
mt19937_64 mt;

void init(){
  mt.seed(rd());
  stru.push_back((S){ "", vector<pair<int, string> >() });
  stru.push_back((S){ "byte", vector<pair<int, string> >() }); mp["byte"] = 1;
  stru.push_back((S){ "short", vector<pair<int, string> >() }); mp["short"] = 2;
  stru.push_back((S){ "int", vector<pair<int, string> >() }); mp["int"] = 3;
  stru.push_back((S){ "long", vector<pair<int, string> >() }); mp["long"] = 4;
}
int getOperation(){//获取随机的操作
  if(A || (B && tot1)){
    if(stru[0].mem.empty()){//2,4
      int ret = mt() % 2;
      if(ret == 0)ret = 2;
      else ret = 4;
      return ret;//define element
    }
    else{//2,3,4
      return 2 + mt() % 3;
    }
  }
  else if(stru[0].mem.empty()){//1,2,4
    int ret = 1 + mt() % 2;
    if(ret == 3)ret = 4;
    if(ret == 1)tot1++;
    return ret;
  }
  else{//1,2,3,4
    int ret = 1 + mt() % 4;
    if(ret == 1)tot1++;
    return ret;
  }
}
int getType(bool _instru){//获取随机的元素，其中返回值代表结构体 id （_instru 代表是否获取的是结构体内元素）
  if(D)return 4 + mt() % (stru.size() - 4);
  if(C && _instru)return 1 + mt() % 4;
  return 1 + mt() % (stru.size() - 1);
}
string getRamdomString(){//获得一个未出现过的字符串
  string ret;
  for(int i = 0; i < slen; i++){
    ret += 'a' + mt() % 26;
  }
  while(mp[ret] || vis[ret]){
    int pos = mt() % slen;
    ret[pos] = 'a' + mt() % 26;
  }
  return ret;
}

signed main(){
  // freopen(".in", "r", stdin);
  freopen("data.out", "w", stdout);
  init();
  cout << n << endl;
  for(int kk = 1; kk <= n; kk++){
    int opt = getOperation();
    cout << opt << " ";
    // cerr << kk << " " << opt << endl;
    if(opt == 1){
      vis.clear();
      S ls;//临时
      string name = getRamdomString();
      int num = 1 + mt() % k;
      cout << name << " " << num << endl;
      ls.nam = name;
      for(int i = 1; i <= num; i++){
        int type = getType(true);
        string elename = getRamdomString();
        vis[elename] = 1;
        cout << stru[type].nam << " " << elename << endl;
        ls.mem.push_back(make_pair(type, elename));
      }
      stru.push_back(ls);
    }
    else if(opt == 2){
      int type = getType(false);
      string name = getRamdomString();
      stru[0].mem.push_back(make_pair(type, name));
      cout << stru[type].nam << " " << name << endl;
    }
    else if(opt == 3){
      int u = 0;
      string outp = "";
      while(1){
        int pos = mt() % stru[u].mem.size();
        if(u)outp += ".";
        outp += stru[u].mem[pos].second;
        // cerr << " - " << pos << " " << outp << endl;
        if(stru[u].mem[pos].first <= 4){//是基本元素
          break;
        }
        u = stru[u].mem[pos].first;
      }
      cout << outp << endl;
    }
    else{
      cout << mt() % (8 * kk) << endl;
    }
    cout << endl;
  }
  return 0;
}

```

注意事项：
> 1. 十年 OI 一场空，不开 long long 见祖宗！
> 2. 十年 OI 一场空，不考 long double 见祖宗！（update on 2024.8.23）
> 3. 大模拟非常考验码力，要养成良好习惯，包括命名规范，代码可读性，风格等等，不要出现 **代码写着写着自己都不知道某行代码或者某个变量什么意思** 之类的情况，必要时可以在代码中**添加注释**，让自己理解代码含义。

------------

后记 1：版权所有@[KobeBeanBryantCox](https://www.luogu.com.cn/user/865625)，请勿抄袭代码。

后记 2：写代码的习惯一定要好，代码不要乱七八糟，优秀的码风是很醉人的 QWQ。

------------

注：数据生成器转载与[此](https://www.luogu.com.cn/blog/wyyl/bei-t3-struct-zhe-mo-ji)。

顺便推荐一下本蒟蒻的[游记](https://www.luogu.com.cn/blog/wangjianbo123/csp-js-2023-you-ji)。

---

## 作者：minstdfx (赞：10)

首先考虑地址对齐，显然如果对齐是 $k$，当前首地址是 $p$，那么我们将会从 $\lceil \dfrac p k \rceil \times k$ 这个地址开始。所以写一个辅助函数用于计算对齐后的地址。

考虑每个操作在二分知道了对应的变量的首地址之后可以转化为对一个首地址为 0 的变量（我知道首地址为 0 很蠢）的操作，并且这是可以递归的，因此只需要存下每一个 `struct` 类型的信息并在上面操作即可。

具体，对于一个 `struct` 我们需要
- `memberList`，按顺序存放所有的成员的名称、类型（指针指向对应的类型）和首地址。
- `memberMap`，通过名称找到对应的成员。

注意到代码里的 `addresses` 数组，这其实是不必要的，只是为了复用二分函数方便实现。

对于操作 1，我们新建一个 `struct_t`，维护相应的内容，并将类名指向该对象即可。维护大小的时候，将所有成员的大小相加即可。上述大小是包含对齐所产生的空内存的大小，即 `sizeof(struct A)`。

对于操作 2，我们在变量列表上直接新开一个变量并计算地址，维护此时的尾地址。

对于操作 3，直接递归下去计算即可。

对于操作 4，每次递归下去（包括最开始找全局变量）的时候判断是否 hit 了空的内存，二分找到该地址所在的成员即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
// struct.hpp
typedef unsigned long long usize_t;
struct struct_t;
extern map<string, struct_t*> globalClasses;
usize_t alignAddress(usize_t now, usize_t align) {
    return (now + align - 1) / align * align;
}
void Stringsplit(string str, const char split, vector<string>& _list) {
    istringstream iss(str);
    string token;
    while (getline(iss, token, split)) {
        _list.push_back(token);
    }
}
// struct.cpp
template <typename T>
usize_t bsearch(usize_t empl, const vector<pair<usize_t, T>>& vec) {
    usize_t l = 0, r = vec.size() - 1, mid, res;
    //	printf("l=%lld r=%lld\n",l,r);
    while (l <= r) {
        mid = (l + r) >> 1;
        if (vec[mid].first <= empl)
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    }
    return res;
}
struct struct_t {
   private:
    usize_t size;
    usize_t align;
    vector<pair<struct_t*, pair<string, usize_t>>> member;
    map<string, usize_t> memberMap;
    // how to quickly find a member by address?
    vector<pair<usize_t, usize_t>> addresses;

   public:
    struct_t(usize_t gsize);
    struct_t(vector<pair<string, string>>& initList);
    usize_t getSize() const;
    usize_t getAlign() const;
    void swap(struct_t& other);
    bool isBasicType() const;
    usize_t getAddress(const vector<string>& globalMarkList, usize_t now);
    bool getAttribute(vector<string>& resolveResult, usize_t address);
};
struct_t::struct_t(usize_t gsize) {
    // basic types: byte short int long
    size = align = gsize;
}
struct_t::struct_t(vector<pair<string, string>>& initList) {
    align = 0;
    usize_t nowAddress = 0;
    member.clear();
    memberMap.clear();
    addresses.clear();
    for (auto& it : initList)
        align = max(align, globalClasses[it.first]->align);
    for (auto& it : initList) {
        memberMap[it.second] = member.size();
        usize_t thisAddress =
            alignAddress(nowAddress, globalClasses[it.first]->align);
        addresses.emplace_back(thisAddress, member.size());
        member.emplace_back(globalClasses[it.first],
                            make_pair(it.second, thisAddress));
        nowAddress = thisAddress + globalClasses[it.first]->size;
    }
    size = alignAddress(nowAddress, align);
}
usize_t struct_t::getSize() const {
    return size;
}
usize_t struct_t::getAlign() const {
    return align;
}
bool struct_t::isBasicType() const {
    return member.empty();
}
void struct_t::swap(struct_t& other) {
    if (this == &other)
        return;
    std::swap(other.size, size);
    std::swap(align, other.align);
    member.swap(other.member);
    memberMap.swap(other.memberMap);
    addresses.swap(other.addresses);
}
usize_t struct_t::getAddress(const vector<string>& globalMarkList,
                             usize_t now) {
    // the variable address is 0
    if (now == globalMarkList.size())
        return 0;
    return member[memberMap[globalMarkList[now]]].second.second +
           (member[memberMap[globalMarkList[now]]].first)
               ->getAddress(globalMarkList, now + 1);
}
bool struct_t::getAttribute(vector<string>& resolveResult, usize_t address) {
    if (isBasicType()) {
        return true;
    }
    // the variable address is 0
    usize_t index = bsearch(address, addresses);
    usize_t nextAddress = address - addresses[index].first;
    if ((member[index].first)->size <= nextAddress)
        return false;  // ERR
    resolveResult.push_back(member[index].second.first);
    if (!(member[index].first)->getAttribute(resolveResult, nextAddress))
        return false;
    return true;
}
map<string, struct_t*> globalClasses;
// main.cpp
vector<pair<usize_t, struct_t*>> globalVariables;
vector<string> varNames;
map<string, usize_t> variable;
usize_t globalAddress = 0;
vector<string> vs;
int main() {
    int n, op;
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    vector<pair<string, string>> tempVector;
    struct_t* newObject;
    string t1, t2, ss;
    globalClasses["byte"] = new struct_t(1);
    globalClasses["short"] = new struct_t(2);
    globalClasses["int"] = new struct_t(4);
    globalClasses["long"] = new struct_t(8);
    while (n--) {
        cin >> op;
        cerr << op << endl;
        if (op == 1) {
            // define a struct
            int k;
            cin >> ss >> k;
            tempVector.clear();
            while (k--) {
                cin >> t1 >> t2;
                tempVector.emplace_back(t1, t2);
            }
            globalClasses[ss] = newObject = new struct_t(tempVector);
            cout << newObject->getSize() << " " << newObject->getAlign()
                 << endl;
        }
        if (op == 2) {
            cin >> ss >> t1;
            globalAddress =
                alignAddress(globalAddress, globalClasses[ss]->getAlign());
            cout << globalAddress << endl;
            variable[t1] = globalVariables.size();
            globalVariables.emplace_back(globalAddress, globalClasses[ss]);
            varNames.emplace_back(t1);
            globalAddress = globalAddress + globalClasses[ss]->getSize();
        }
        if (op == 3) {
            cin >> ss;
            vs.clear();
            Stringsplit(ss, '.', vs);
            usize_t index = variable[vs[0]];
            usize_t ans = globalVariables[index].first +
                          globalVariables[index].second->getAddress(vs, 1);
            cout << ans << endl;
        }
        if (op == 4) {
            vs.clear();
            usize_t askAddress;
            cin >> askAddress;
            if (globalVariables.empty()) {
                cout << "ERR" << endl;
                continue;
            }
            usize_t index = bsearch(askAddress, globalVariables);
            askAddress -= globalVariables[index].first;
            if (askAddress >= globalVariables[index].second->getSize()) {
                cout << "ERR" << endl;
                continue;
            }
            bool rescode =
                globalVariables[index].second->getAttribute(vs, askAddress);
            if (!rescode)
                cout << "ERR" << endl;
            else {
                cout << varNames[index];
                for (auto& x : vs)
                    cout << "." << x;
                cout << endl;
            }
        }
    }
    for(auto[a, b]: globalClasses)
        delete b;
}
```

---

## 作者：TernaryTree (赞：10)

我是模拟大王，考场上想了两小时 T2 不会，一个小时写完这题过大样例了。

先把所有类型抽象成一个结点 `node`，只需要维护其大小以及对齐信息。字符串的判断使用哈希实现。

接下来一个一个操作实现：

### $1$ 操作

说人话就是新建一个点然后连一些边。算对齐信息是好做的，因为底下的结点我们都知道对齐信息；算空间也是好做的，因为底下的结点我们都知道空间大小，顺次递推即可，为了维护 $3,4$ 操作我们维护一个点每个子节点的空间左端点，存储在了 `umap<int, pair<int, int>> sn` 中，其中前者是字符串的哈希值，`pair<int, int>` 表示子结点编号以及在当前结点左端点为 $0$ 时，左端点的对齐信息。然后最后要把空间对齐到自己的对齐信息上。

### $2$ 操作

开一个数组 `w` 表示当前声明了的结点实例的 `node` 编号，`beg` 表示声明了的每个实例的左端点。暴力维护即可。

### $3$ 操作

一个一个跳，每次加上当前结点的左端点编号即为全局左端点。

### $4$ 操作

跟 $3$ 操作差不多，模仿平衡树思想，一个一个判断 $addr$ 是否在当前区间内，是的话就往下跳，找不到往下就输出 `ERR`。

### 考场代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define umap unordered_map

using namespace std;

const int maxn = 1e6 + 10;
const int mod = 1e9 + 7;

struct node {
	int siz, lim;
	node() = default;
	node(int s, int l): siz(s), lim(l) {}
};

int T;
node tr[maxn];
int tot;
umap<int, pair<int, int>> sn[maxn];
vector<int> snn[maxn];
umap<int, int> bk;

int hsh(string s) {
	int y = 0;
	for (int i = 0; i < s.length(); i++) y = (y * 251 % mod + s[i]) % mod;
	return y;
}

int w[maxn];
int cnt;
umap<int, int> ck;
int beg[maxn];
string eriri[maxn];
int now;
umap<int, string> bas;

signed main() {
	//freopen("struct.in", "r", stdin);
	//freopen("struct.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	bk[557350929] = 1;
	bk[101086854] = 2;
	bk[6642831] = 3;
	bk[714851925] = 4;
	tr[1].siz = tr[1].lim = 1;
	tr[2].siz = tr[2].lim = 2;
	tr[3].siz = tr[3].lim = 4;
	tr[4].siz = tr[4].lim = 8;
	tot = 4;
	cin >> T;
	while (T--) {
		int op;
		cin >> op;
		if (op == 1) {
			string s, t, nam;
			int k;
			cin >> s >> k;
			int u = ++tot;
			bk[hsh(s)] = u;
			int cur = 0;
			for (int i = 1; i <= k; i++) {
				cin >> t >> nam;
				int v = bk[hsh(t)];
				cur = (cur + tr[v].lim - 1) / tr[v].lim * tr[v].lim;
				sn[u][hsh(nam)] = {v, cur};
				snn[u].push_back(hsh(nam));
				bas[hsh(nam)] = nam;
//				cout << u << "->" << nam << " (" << v << " " << cur << ")" << endl;
				cur += tr[v].siz;
				tr[u].lim = max(tr[u].lim, tr[v].lim);
			}
			cur = (cur + tr[u].lim - 1) / tr[u].lim * tr[u].lim;
			tr[u].siz = cur;
			cout << tr[u].siz << " " << tr[u].lim << endl;
		} else if (op == 2) {
			string s, t;
			cin >> s >> t;
			w[++cnt] = bk[hsh(s)];
			eriri[cnt] = t;
			ck[hsh(t)] = cnt;
			now = (now + tr[w[cnt]].lim - 1) / tr[w[cnt]].lim * tr[w[cnt]].lim;
			cout << now << endl;
			beg[cnt] = now;
			now += tr[w[cnt]].siz;
		} else if (op == 3) {
			string s;
			cin >> s;
			vector<int> path;
			int sta = 0;
			for (int i = 0; i < s.length(); i++) {
				if (s[i] == '.') {
					int ter = i - 1;
					path.push_back(hsh(s.substr(sta, ter - sta + 1)));
//					cout << sta << " " << ter << endl;
					sta = i + 1;
				} 
			}
//			cout << sta << " " << s.length() - 1 << endl;
			path.push_back(hsh(s.substr(sta, s.length() - sta)));
			int u = w[ck[path[0]]], pos = beg[ck[path[0]]];
			for (int i = 1; i < path.size(); i++) {
				pos += sn[u][path[i]].second;
//				cout << u << endl;
				u = sn[u][path[i]].first;
			}
			cout << pos << endl;
		} else if (op == 4) {
			int add;
			cin >> add;
			int p = 0;
			for (int i = cnt; i; i--) {
				if (beg[i] <= add) {
					p = i;
					break;
				}
			}
			if (!p || beg[p] + tr[w[p]].siz - 1 < add) {
				cout << "ERR" << endl;
				continue;
			}
//			cout << p << endl;
			int u = w[p], nw = beg[p];
			string aaans = eriri[p];
			while (true) {
				if (u <= 4) {
					cout << aaans << endl;
					break;
				}
				bool fl = 0;
				for (int h : snn[u]) {
//					cout << u << "-" << bas[h] << "->" << sn[u][h].first << " " << sn[u][h].second << " " << tr[sn[u][h].first].siz << " " << nw << endl;
					if (sn[u][h].second + nw <= add && sn[u][h].second + nw + tr[sn[u][h].first].siz > add) {
						nw += sn[u][h].second;
						aaans += ".";
						aaans += bas[h];
						fl = 1;
						u = sn[u][h].first;
						break;
					}
				}
				if (!fl) {
					cout << "ERR" << endl;
					break;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：escapist404 (赞：6)

# P9754 [CSP-S 2023] 结构体 题解

> 考前内心 OS：“CCF 不会出大模拟吧（（（”。

## 前置声明

### 辅助函数：偏移量

考虑一个结构体的偏移量。已知首个空地址 $\mathrm{address}$ 和该结构体的对齐要求 $\mathrm{align}$，则该结构体正确的起始地址为 $\mathrm{\lceil address / align \rceil \times align}$。

```cpp
i64 shiftToAlign(i64 address, i64 align) {
  return (address / align + ((address % align) > 0)) * align;
}
```

### 封装：结构体

注意到变量和结构体呈现了树状结构。但是由于变量个数是指数级的，所以应该维护结构体，里面保存每个成员变量的起始位置、名称、类型。

```cpp
struct Struct {
  std::string typeName;
  std::map<std::string, std::pair<Struct*, i64>> memberVarByVarName;
  std::map<i64, std::pair<Struct*, std::string>> memberVarByAddress;
  i64 align, size;
  
  Struct(std::string typeName = "",
         std::map<std::string, std::pair<Struct*, i64>> memberVarByVarName =
             {std::make_pair("", std::make_pair(nullptr, -1))},
         std::map<i64, std::pair<Struct*, std::string>> memberVarByAddress =
             {std::make_pair(-1, std::make_pair(nullptr, ""))},
         i64 align = 0, i64 size = 0)
      : typeName(typeName),
        memberVarByVarName(memberVarByVarName),
        memberVarByAddress(memberVarByAddress),
        align(align),
        size(size) {}
  
  ~Struct() {
    for (auto [varName, varInfo] : memberVarByVarName) delete varInfo.first;
  }
};
```

使用 `std::map` 并插入哨兵是为了方便操作 3 和 4。

## 操作 1：声明结构体

怎样定义一个结构体呢？

维护成员变量是容易的，统统丢到 `std::map` 就好了。

考虑到要对类型名和类型做映射，因此搞一个 `std::map<std::string, Struct*>` 来存。

```cpp
std::map<std::string, Struct*> structByName;
```

### 基本类型

基本类型当然也能看成结构体。

```cpp
{
    structByName["byte"] =
        new Struct("byte", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 1, 1);
                   
    structByName["short"] =
        new Struct("short", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 2, 2);
                   
    structByName["int"] =
        new Struct("int", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 4, 4);
                   
    structByName["long"] =
        new Struct("long", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 8, 8);
}
```

### 维护对齐要求

> 对于基本类型：**对齐要求等于其占据空间大小**，如 `int` 类型需要对齐到 $4$ 字节，其余同理。
对于结构体类型：**对齐要求等于其成员的对齐要求的最大值**，如一个含有 `int` 和 `short` 的结构体类型需要对齐到 $4$ 字节。

将每个成员变量的对齐要求取最大值即可。

### 维护偏移量和大小

> 为了保证内存访问的效率，元素的地址占用需要满足对齐规则，即任何类型的**大小**和该类型元素在内存中的**起始地址**均应对齐到该类型**对齐要求**的整数倍。

每个成员变量相对于该结构体的起始地址的偏移量为：上一个变量的偏移量，上一个变量的大小，由对齐要求形成的“洞”，这三者之和。

大小的定义比较模糊：最后一个变量终止的地址，与“为满足对齐要求而平移的值”之和。

### 实现

> 保证所有操作均符合题目所述的规范和要求，即结构体的定义不会包含不存在的类型、不会访问不存在的元素或成员等。

~~所以似乎并不需要判奇怪的边界。~~


```cpp
Struct(std::string typeName = "",
        std::vector<std::pair<std::string, Struct*>> memberVarWithoutPos = {})
    : typeName(typeName),
      memberVarByVarName({std::make_pair("", std::make_pair(nullptr, -1))}),
      memberVarByAddress({std::make_pair(-1, std::make_pair(nullptr, ""))}),
      align(0),
      size(0) {
  for (auto [varName, varType] : memberVarWithoutPos) {
    align = std::max(align, varType->align);
  }
  i64 adjust = 0;
  for (auto [varName, varType] : memberVarWithoutPos) {
    adjust = shiftToAlign(adjust, varType->align);
    memberVarByVarName[varName] = std::make_pair(varType, adjust);
    memberVarByAddress[adjust] = std::make_pair(varType, varName);
    adjust += varType->size;
  }
  size = shiftToAlign(adjust, align);
}
case 1: {
  std::string typeName;
  std::cin >> typeName;
  int numberOfMember;
  std::cin >> numberOfMember;
  std::vector<std::pair<std::string, Struct*>> memberVarWithoutPos;
  for (int j = 0; j < numberOfMember; ++j) {
    std::string varTypeName, varName;
    std::cin >> varTypeName >> varName;
    memberVarWithoutPos.push_back(
        std::make_pair(varName, structByName[varTypeName]));
  }
  memberVarWithoutPos.shrink_to_fit();
  structByName[typeName] = new Struct(typeName, memberVarWithoutPos);
  std::cout << structByName[typeName]->size << ' '
            << structByName[typeName]->align << std::endl;
  break;
}
```

## 操作 2：声明变量

这个操作不是很复杂。

注意到声明的变量组成了一个森林，而森林的结点总数是极大的，不能存下所有的变量。

我们可以存每棵树的根节点，即输入的变量。为了方便操作 3 和 4，用两个 `std::map` 存输入的变量，两个的 `key` 分别是 `std::string` 和 `i64`，分别代表变量名和起始地址。

这里的起始地址等价于相对于 $0$ 的偏移量。

```cpp
std::map<std::string, std::pair<Struct*, i64>> varByVarName = {
    std::make_pair("", std::make_pair(nullptr, -1))};
std::map<i64, std::pair<Struct*, std::string>> varByAddress = {
    std::make_pair(-1, std::make_pair(nullptr, ""))};
```

直接丢到 `std::map` 里面就好。

注意更新空地址的起始位置。

```cpp
i64 address = 0;

case 2: {
  std::string varTypeName, varName;
  std::cin >> varTypeName >> varName;
  Struct* varType = structByName[varTypeName];
  i64 adjust = shiftToAlign(address, varType->align);
  varByVarName[varName] = std::make_pair(varType, adjust);
  varByAddress[adjust] = std::make_pair(varType, varName);
  std::cout << adjust << std::endl;
  address = adjust + varType->size;
  break;
}
```

## 操作 3：查找变量所在地址

注意到这个变量名是 `{}.{}.{}` 的形式，因此我们每次取出第一个 `.` 以前的串，就是当前要访问的变量名。

### 跳到成员变量上

我们在跳的时候维护一个 `std::map<std::string, std::pair<Struct*, i64>> path`，可以根据变量名查询其类型和地址偏移量。

怎么维护呢？初始时 `path` 就是 `varByVarName`，设跳到的变量名称是 `varName`，则 `path = path[varName].first->memberVarByVarName;`。

### 维护地址

这个过程比较像 BST 求排名。我们之前对每个类型的成员变量维护了偏移量，所以用一个变量 `address` 维护，每次让 `address += path[varName].second` 即可。

### 实现

```cpp
i64 findByVarName(std::string varName = "",
                  std::map<std::string, std::pair<Struct*, i64>> path = {
                      std::make_pair("", std::make_pair(nullptr, -1))}) {
  i64 currentAddress = 0;
  while (~varName.find('.')) {
    auto currentVarName = varName.substr(0, varName.find('.'));
    currentAddress += path[currentVarName].second;
    path = path[currentVarName].first->memberVarByVarName;
    varName = varName.substr(varName.find('.') + 1);
  }
  return currentAddress + path[varName].second;
}
```

```cpp
case 3: {
  std::string varName;
  std::cin >> varName;
  std::cout << findByVarName(varName, varByVarName) << std::endl;
  break;
}
```

## 操作 4：查找包含某个地址的基本变量

与操作 3 类似。

### 跳到成员变量

设目标基本变量在当前变量的起始地址下，偏移量为 `queryAddress` 的变量。

我们在跳的时候维护一个 `std::map<i64, std::pair<Struct*, std::string>> path`，可以根据地址偏移量查询其类型和变量名。

每次往成员变量跳，就要往最靠近查询地址（最后一个偏移量小于等于当前查询地址）的变量跳，即 `std::prev(path.upper_bound(queryAddress))`。

跳到成员变量前，当前的 `queryAddress` 要减去成员变量的地址偏移量。

但是由于 `path` 为空时 `std::prev(path.end())` 是个 UB，所以要插个哨兵。当然也可以直接判是否为空。

初始时 `path` 就是 `varByAddress`，设跳到的变量名称是 `varName`，则 `path = path[varName].first->memberVarByAddress;`。

### 维护名称

遍历的过程中维护字符串 `currentName`（初始为空），每次让 `currentName += path[varName].second + "."`，返回时删掉最后的 `.` 即可。

### 判断合法

额外维护当前变量的 `Struct` 指针 `currentType`（初始时为空），如果跳完成员变量之后，`queryAddress` 不小于 `currentType->size`，即代表询问的地址没有被任何基本变量占用。

注意特判 `currentType == nullptr`，此时必然没有执行过操作 2，因此输出 `ERR`。 

### 实现

```cpp
const std::string Fail = "ERR";

std::string findByAddress(
    i64 address = 0, std::map<i64, std::pair<Struct*, std::string>> path = {
                         std::make_pair(-1, std::make_pair(nullptr, ""))}) {
  std::string currentName;
  Struct* currentType = nullptr;
  while (std::prev(path.upper_bound(address)) != path.begin()) {
    currentType = std::prev(path.upper_bound(address))->second.first;
    currentName += std::prev(path.upper_bound(address))->second.second + ".";
    address -= std::prev(path.upper_bound(address))->first;
    path = currentType->memberVarByAddress;
  }
  if (currentType == nullptr || address >= currentType->size)
    return Fail;
  else
    return currentName.substr(0, currentName.size() - 1);
}
```

```cpp
case 4: {
  i64 queryAddress;
  std::cin >> queryAddress;
  std::cout << findByAddress(queryAddress, varByAddress) << std::endl;
  break;
}
```

## 完整代码

```cpp
#include <iostream>
#include <map>
#include <vector>

using i64 = long long;

i64 shiftToAlign(i64 address, i64 align) {
  return (address / align + ((address % align) > 0)) * align;
}

struct Struct {
  std::string typeName;
  std::map<std::string, std::pair<Struct*, i64>> memberVarByVarName;
  std::map<i64, std::pair<Struct*, std::string>> memberVarByAddress;
  i64 align, size;
    
  Struct(std::string typeName = "",
         std::map<std::string, std::pair<Struct*, i64>> memberVarByVarName =
             {std::make_pair("", std::make_pair(nullptr, -1))},
         std::map<i64, std::pair<Struct*, std::string>> memberVarByAddress =
             {std::make_pair(-1, std::make_pair(nullptr, ""))},
         i64 align = 0, i64 size = 0)
      : typeName(typeName),
        memberVarByVarName(memberVarByVarName),
        memberVarByAddress(memberVarByAddress),
        align(align),
        size(size) {}
    
  Struct(std::string typeName = "",
         std::vector<std::pair<std::string, Struct*>> memberVarWithoutPos = {})
      : typeName(typeName),
        memberVarByVarName({std::make_pair("", std::make_pair(nullptr, -1))}),
        memberVarByAddress({std::make_pair(-1, std::make_pair(nullptr, ""))}),
        align(0),
        size(0) {
            
    for (auto [varName, varType] : memberVarWithoutPos) {
      align = std::max(align, varType->align);
    }
    i64 adjust = 0;
    for (auto [varName, varType] : memberVarWithoutPos) {
      adjust = shiftToAlign(adjust, varType->align);
      memberVarByVarName[varName] = std::make_pair(varType, adjust);
      memberVarByAddress[adjust] = std::make_pair(varType, varName);
      adjust += varType->size;
    }
    size = shiftToAlign(adjust, align);
  }
    
  ~Struct() {
    for (auto [varName, varInfo] : memberVarByVarName) delete varInfo.first;
  }
};

i64 findByVarName(std::string varName = "",
                  std::map<std::string, std::pair<Struct*, i64>> path = {
                      std::make_pair("", std::make_pair(nullptr, -1))}) {
    
  i64 currentAddress = 0;
  while (~varName.find('.')) {
    auto currentVarName = varName.substr(0, varName.find('.'));
    currentAddress += path[currentVarName].second;
    path = path[currentVarName].first->memberVarByVarName;
    varName = varName.substr(varName.find('.') + 1);
  }
    
  return currentAddress + path[varName].second;
}

const std::string Fail = "ERR";

std::string findByAddress(
    i64 address = 0, std::map<i64, std::pair<Struct*, std::string>> path = {
                         std::make_pair(-1, std::make_pair(nullptr, ""))}) {
    
  std::string currentName;
  Struct* currentType = nullptr;
  while (std::prev(path.upper_bound(address)) != path.begin()) {
    currentType = std::prev(path.upper_bound(address))->second.first;
    currentName += std::prev(path.upper_bound(address))->second.second + ".";
    address -= std::prev(path.upper_bound(address))->first;
    path = currentType->memberVarByAddress;
  }
    
  if (currentType == nullptr || address >= currentType->size)
    return Fail;
  else
    return currentName.substr(0, currentName.size() - 1);
}

int main() {
  int n;
  std::cin >> n;

  std::map<std::string, Struct*> structByName;
  std::map<std::string, std::pair<Struct*, i64>> varByVarName = {
      std::make_pair("", std::make_pair(nullptr, -1))};
  std::map<i64, std::pair<Struct*, std::string>> varByAddress = {
      std::make_pair(-1, std::make_pair(nullptr, ""))};

  {
    structByName["byte"] =
        new Struct("byte", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 1, 1);
    structByName["short"] =
        new Struct("short", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 2, 2);
    structByName["int"] =
        new Struct("int", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 4, 4);
    structByName["long"] =
        new Struct("long", {std::make_pair("", std::make_pair(nullptr, -1))},
                   {std::make_pair(-1, std::make_pair(nullptr, ""))}, 8, 8);
  }

  i64 address = 0;

  for (int i = 0; i < n; ++i) {
    int op;
    std::cin >> op;
    switch (op) {
            
      case 1: {
        std::string typeName;
        std::cin >> typeName;
        int numberOfMember;
        std::cin >> numberOfMember;
        std::vector<std::pair<std::string, Struct*>> memberVarWithoutPos;
        for (int j = 0; j < numberOfMember; ++j) {
          std::string varTypeName, varName;
          std::cin >> varTypeName >> varName;
          memberVarWithoutPos.push_back(
              std::make_pair(varName, structByName[varTypeName]));
        }
        memberVarWithoutPos.shrink_to_fit();
        structByName[typeName] = new Struct(typeName, memberVarWithoutPos);
        std::cout << structByName[typeName]->size << ' '
                  << structByName[typeName]->align << std::endl;
        break;
      }
            
      case 2: {
        std::string varTypeName, varName;
        std::cin >> varTypeName >> varName;
        Struct* varType = structByName[varTypeName];
        i64 adjust = shiftToAlign(address, varType->align);
        varByVarName[varName] = std::make_pair(varType, adjust);
        varByAddress[adjust] = std::make_pair(varType, varName);
        std::cout << adjust << std::endl;
        address = adjust + varType->size;
        break;
      }
            
      case 3: {
        std::string varName;
        std::cin >> varName;
        std::cout << findByVarName(varName, varByVarName) << std::endl;
        break;
      }
            
      case 4: {
        i64 queryAddress;
        std::cin >> queryAddress;
        std::cout << findByAddress(queryAddress, varByAddress) << std::endl;
        break;
      }
            
      default:
        break;
    }
  }

  return 0;
}

```



---

## 作者：Untitled10032 (赞：5)

## 题意

模拟 C++ 变量与结构体对于内存的使用。支持操作：

- 新建结构体。
- 为结构体或变量申请内存。
- 按名称访问对应内存地址。
- 按内存地址查找对应名称。

要求数据对齐，详见[题面](https://www.luogu.com.cn/problem/P9754)。

## 思路

做大模拟还是得有一点面向对象的思想的。可以将题目中的数据结构封装成一个类。

内存和结构体中数据类型的嵌套关系可以抽象地看成一个 DAG（有向无环图）。若类型 B 是类型 A 的一个成员，那么可以看做 A 有一条连向 B 的边。

除了类型名，在结构体或内存中，每个变量都有自己的变量名，这个变量名是和边一起存储的，为了处理查找操作，每条边还需要存一个偏移量，表示从此结构体起始地址偏移多少到这个变量。


```cpp
struct Struct {
    struct Edge {
        Struct *to;
        string name;
        int delta;  //从此结构体起始地址偏移多少到这个变量
    };
    vector<Edge> members;
    int size;
    int order;  //对齐要求，其实叫 align 更好，但是考场上是这么写的
} BYTE, SHORT, INT, LONG, memory;
```

虽然这个结构体的名字叫结构体，但是其实它表示的不止是结构体，而是类似更广泛的概念：**数据结构**。（但 `structure` 太长了，考场上不想用它做名字。）

- **`INT`、`BYTE` 等基本类型是数据结构**：它们没有出边（即没有成员变量），对齐要求等于题目给出的分别的大小。

- **本题中内存可以看做是一个数据结构**：因为不涉及到内存的释放、动态分配等，只是从前往后一次分配，所以在内存中申请变量的操作和在结构体中声明成员变量的操作是几乎一致的，可以统一处理。


于是此题就变成了类似[这样](https://www.luogu.com.cn/problem/CF896A)的递归查找问题。只要从表示内存的数据结构开始，沿着给出的数或字符串依次往下找即可。找到头之后记得判断一下是否 `ERR`。

关于内存对齐，依照题意模拟即可，可以考虑以下函数：

```cpp
inline int calc(const int size, const int order) {
    if (size % order == 0)
        return size;
    return (size / order + 1) * order;
}
```

在一个数据结构的成员都添加完之后用对齐要求更新数据结构占空间大小。

## 代码

- `struct Struct`：表示数据结构的结构体。
- `map<string, Struct *> names`：用于存储结构体名的平衡树，方便申请变量或定义结构体。
- `inline void init()`：对基本类型进行初始化。
- `inline int calc(const int size, const int order)`：输入未考虑对齐的数据结构大小和对齐要求，返回对齐后的数据结构大小。
- `inline void inputStruct()`：输入（定义）结构体。
- `inline int getAddr()`：给出名称获取相应地址。
- `inline void findVar()`：给出地址查找相应名称。


```cpp
#include <iostream>
#include <string>
#include <vector>
#include <map>

#define int long long

using namespace std;

struct Struct {
    struct Edge {
        Struct *to;
        string name;
        int delta;  //从此结构体起始地址偏移多少到这个变量
    };
    vector<Edge> members;
    int size;
    int order;  //dui qi yao qiu
} BYTE, SHORT, INT, LONG, memory;

map<string, Struct *> names;

inline void init() {
    BYTE.size = 1;
    SHORT.size = 2;
    INT.size = 4;
    LONG.size = 8;
    BYTE.order = 1;
    SHORT.order = 2;
    INT.order = 4;
    LONG.order = 8;
    names.insert({ "byte", &BYTE });
    names.insert({ "short", &SHORT });
    names.insert({ "int", &INT });
    names.insert({ "long", &LONG });
}

inline int calc(const int size, const int order) {
    if (size % order == 0)
        return size;
    return (size / order + 1) * order;
}

inline void inputStruct() {
    Struct *s = new Struct;
    s->order = 1;
    s->size = 0;
    string name;
    cin >> name;
    names.insert({ name, s });
    int k;
    cin >> k;
    while (k--) {
        string type_str;
        cin >> type_str >> name;
        //cout << type_str << endl;
        Struct *type = names.find(type_str)->second;
        const int t = calc(s->size, type->order);
        s->members.push_back({ type, name, t });
        s->size = t + type->size;
        s->order = max(s->order, type->order);
    }
    s->size = calc(s->size, s->order);
    cout << s->size << ' ' << s->order << '\n';
}

inline int getAddr() {
    string name;
    cin >> name;
    string::iterator it = name.begin();
    Struct *type = &memory;
    int sum = 0;
    while (it != name.end()) {
        string now;
        for (; it != name.end() && *it != '.'; ++it)
            now.push_back(*it);
        if (it != name.end())
            ++it;   //skip '.'
        for (Struct::Edge &i : type->members) {
            if (i.name == now) {
                type = i.to;
                sum += i.delta;
                break;
            }
        }
    }
    return sum;
}

inline void findVar() {
    int addr;
    cin >> addr;
    Struct *type = &memory;
    if (memory.members.size() == 0) {
        //memory 里啥都没有
        cout << "ERR\n";
        return;
    }
    string path = "";
    while (true) {
        if (type->members.size() == 0)
            break;
        for (vector<Struct::Edge>::iterator i = type->members.begin(); i != type->members.end(); ++i) {
            if ((i + 1) == type->members.end() || i->delta <= addr && (i + 1)->delta > addr) {
                if (i->delta + i->to->size <= addr) {
                    cout << "ERR\n";
                    return;
                }
                type = i->to;
                addr -= i->delta;
                path += i->name + '.';
                break;
            }
        }
    }
    path.pop_back();    //erase '.' at the end
    cout << path << '\n';
}

signed main() {
    freopen("struct.in", "r", stdin);
    freopen("struct.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    init();
    while (n--) {
        char opt;
        cin >> opt;
        //cout << n << endl;
        if (opt == '1') {
            inputStruct();
        } else if (opt == '2') {
            string type_str, name;
            cin >> type_str >> name;
            Struct *type = names.find(type_str)->second;
            const int t = calc(memory.size, type->order);
            memory.members.push_back({ type, name, t });
            memory.size = t + type->size;
            cout << t << '\n';
        } else if (opt == '3') {
            cout << getAddr() << '\n';
        } else {
            findVar();
        }
    }
    return 0;
}
```



---

## 作者：xiezheyuan (赞：4)

## 前言

大模拟……无耻大模拟毁我青春（指 T2 没写）[详情](https://www.luogu.com.cn/blog/xiezheyuan/csp-s-2023-you-ji)

讲一下我赛时的思路吧。本题解的思路可能会比较特立独行，大家就凑着看看吧。

由于是赛时代码，所以有许多冗余内容。大家不要 diss 就行。

## 思路

### 声明

对于一个变量、或是结构体，需要保存它们的一些基本信息。比如说名称、类型、对齐要求、大小以及成员信息（若有）。

注意对于结构体而言，里面的分区是独立的。为什么呢？引出一个引理：

> 引理 1：对于一个结构体，其中成员的起始内存地址的相对关系永不改变。也就是说，对于每一个结构体变量，两两内部成员起始内存地址的差不变。

证明：由于对齐要求为成员对其要求的最大值，因此我们每声明一个结构体，都可以令起始地址为 $0$ 建立每一个成员的起始内存地址信息。而结构体的起始内存地址需要对齐，也就是说，每个位置都满足成员的对齐要求（因为 $1,2,4,8$ 两两之间的最小公倍数等于其中的最大值）。

说句闲话：如果题目中说对其要求为成员的最小值，则难度增加了许多倍，至少我不会复杂度正确的算法。

然后我们可以在声明中加入各个成员起始内存地址信息。具体我们来看一下代码实现：

首先是成员变量信息的结构体：

```cpp
struct son{
	string name;
	int def,pos;
	son(int d,int p,string n){
		name = n;
		def = d;
		pos = p;
	}
	bool operator<(son x) const {
		return pos < x.pos;
	}
};
```

其中 `name` 为名称，`def` 为成员定义的编号（注意定义与成员变量本身不同），`pos` 为起始内存相对地址。

然后便是定义的结构体了：

```cpp
struct node{
	string name;
	int type;
	int dq;
	int siz;
	vector<son> sons;
	map<string,int> np;
} a[N];
int tot;
```

`name` 表示定义的东西的名称。`type` 表示定义的类型（从 $0\sim5$ 为 `byte`、`short`、`int`、`long` 和自定义结构体）。

`dq` 表示对齐要求，`siz` 表示占用空间大小（注意这与对其要求不同）。`sons` 表示成员，`np` 是为了快速寻找指定成员名称对应成员编号的映射。

为了省事，我直接将基本类型变量也变成定义了。（好吧其实并不省事）

据此，我们就可以写出四个构建变量定义的函数：

```cpp
node mkbyte(string name){
	node nd;
	nd.name = name;
	nd.type = 0;
	nd.dq = nd.siz = 1;
	return nd;
}

node mkshort(string name){
	node nd;
	nd.name = name;
	nd.type = 1;
	nd.dq = nd.siz = 2;
	return nd;
}

node mkint(string name){
	node nd;
	nd.name = name;
	nd.type = 2;
	nd.dq = nd.siz = 4;
	return nd;
}

node mklong(string name){
	node nd;
	nd.name = name;
	nd.type = 3;
	nd.dq = nd.siz = 8;
	return nd;
}
```

当然你还需要定义一个定义名称与定义编号的映射备用。

```cpp
map<string,int> namelst;
```

### 变量

由于我们将基本类型变量用定义来表达，所以变量我们只需要保存：

- 变量在内存的首地址 `fir`。
- 定义的编号 `def`。

```cpp
struct var{
	int fir;// first memory address
	int def;// defintion in nodes
	var(int x = 0,int y = 0){
		fir=x,def=y;
	}
	bool operator<(var x) const {
		return fir < x.fir;
	}
} v[N];
int lst,vtt;
```

其中 `lst` 是供后文中新建变量时保存的当前最后一个变量的尾地址。

同时我们需要名称与变量编号的映射、变量编号与名称的映射。

```cpp
map<string,int> namevar;
map<int,string> varname;
```

### 操作 1


按照之前的思路钦定从 $0$ 地址开始考虑对齐问题。然后枚举每一个变量一一考虑对齐问题即可。最后记得处理一个尾部对齐问题。直接放代码吧，没什么好说的：

```cpp
if(op == 1) {
	string s;
	int k;
	cin>>s>>k;
	int lst = 0;
	node stru;
	stru.name = s;
	stru.type = 4;
	stru.dq = stru.siz = 0;
	for(int i=1; i<=k; i++) {
		string t,n;
		cin>>t>>n;
		if(t == "byte") {
			a[++tot] = mkbyte(n);
			stru.sons.push_back(son(tot, lst, n));
			stru.np[n] = stru.sons.size() - 1;
			lst = (lst + 1);
			stru.dq = max(stru.dq, 1ll);
		} else if(t == "short") {
			a[++tot] = mkshort(n);
			if(lst % 2) lst = (lst + (2 - (lst % 2)));
			stru.sons.push_back(son(tot, lst, n));
			stru.np[n] = stru.sons.size() - 1;
			lst = (lst + 2);
			stru.dq = max(stru.dq, 2ll);
		} else if(t == "int") {
			a[++tot] = mkint(n);
			if(lst % 4) lst = (lst + (4 - (lst % 4)));
			stru.sons.push_back(son(tot, lst, n));
			stru.np[n] = stru.sons.size() - 1;
			lst = (lst + 4);
			stru.dq = max(stru.dq, 4ll);
		} else if(t == "long") {
			a[++tot] = mklong(n);
			if(lst % 8) lst = (lst + (8 - (lst % 8)));
			stru.sons.push_back(son(tot, lst, n));
			stru.np[n] = stru.sons.size() - 1;
			lst = (lst + 8);
			stru.dq = max(stru.dq, 8ll);
		} else {
			int pos = namevar[t];
			if(lst % a[pos].dq) lst = (lst + (a[pos].dq - (lst % a[pos].dq)));
			stru.sons.push_back(son(pos, lst, n));
			stru.np[n] = stru.sons.size() - 1;
			lst = (lst + a[pos].siz);
			stru.dq = max(stru.dq, a[pos].dq);
		}
	}
	if(lst % stru.dq) lst = (lst + (stru.dq - (lst % stru.dq)));
	stru.siz = lst;
	cout<<stru.siz<<' '<<stru.dq<<'\n';
	a[++tot] = stru;
	namevar[s] = tot;
}
```

### 操作 2

同样的，借助全局变量 `lst`，我们可以快速新建变量，只需要新建 `var` 结构体即可。注意基本类型变量需要新建定义。

```cpp
if(op == 2) {
	string t,n;
	cin>>t>>n;
	if(t == "byte") {
		a[++tot] = mkbyte(n);
		v[++vtt] = var(lst, tot);
		cout<<lst<<'\n';
		lst = (lst + a[tot].dq);
		namelst[n] = vtt;
	} else if(t == "short") {
		a[++tot] = mkshort(n);
		if(lst % 2) lst = (lst + (2 - (lst % 2)));
		cout<<lst<<'\n';
		v[++vtt] = var(lst, tot);
		lst = (lst + a[tot].dq);
		namelst[n] = vtt;
	} else if(t == "int") {
		a[++tot] = mkint(n);
		if(lst % 4) lst = (lst + (4 - (lst % 4)));
		cout<<lst<<'\n';
		v[++vtt] = var(lst, tot);
		lst = (lst + a[tot].dq);
		namelst[n] = vtt;
	} else if(t == "long") {
		a[++tot] = mklong(n);
		if(lst % 8) lst = (lst + (8 - (lst % 8)));
		cout<<lst<<'\n';
		v[++vtt] = var(lst, tot);
		lst = (lst + a[tot].dq);
		namelst[n] = vtt;
	} else {
		int pos = namevar[t];
//				cout<<t<<' '<<a[pos].name<<' '<<a[pos].dq<<' '<<lst<<'\n';
		if(lst % a[pos].dq) lst = (lst + (a[pos].dq - (lst % a[pos].dq)));
		cout<<lst<<'\n';
		v[++vtt] = var(lst, pos);
		lst = (lst + a[pos].siz);
		namelst[n] = vtt;
	}
	varname[vtt] = n;
}
```

### 操作 3

这时可以将结构体的成员关系看成一个多叉森林，而这一个操作就是根据顺序找到一个点。

不过在完成这个操作之前，我们需要写一个将字符串按照 `.` 分割的函数 `split`：

```cpp
vector<string> split(string str,int l,int r){
	vector<string> vct;
	string buf;
	for(int i=l;i<=r;i++){
		if(str[i] == '.'){
			vct.push_back(buf);
			vector<string> vct2 = split(str, i + 1, r);
			for(string i : vct2){
				vct.push_back(i);
			}
			break;
		}
		buf += str[i];
	}
	if(vct.size() == 0) vct.push_back(buf);
	return vct;
}
```

然后就可以记录一个当前跳到的节点编号和起始内存地址（真实的）。一个一个跳即可。注意我们将变量和结构体成员分开了，所以我们需要先找变量再找结构体成员。

```cpp
if(op == 3) {
	string str;
	cin>>str;
	vector<string> strs = split(str, 0, str.size() - 1);
	int cur = 0;
	if(strs.size() == 1) {
		cout<<(v[namelst[strs[0]]].fir)<<'\n';
		continue;
	}
	cur = v[namelst[strs[0]]].def;
	int sp = v[namelst[strs[0]]].fir;
	strs.erase(strs.begin());
	for(string x : strs) {
		son cj = a[cur].sons[a[cur].np[x]];
		cur = cj.def;
		sp = sp + cj.pos;
	}
	cout<<sp<<'\n';
}
```

### 操作4

对于操作 4，我们在变量或者是某一个结构体的成员中暴力跑一个类似 `lower_bound` 的东西（其实也可以二分，而且非常方便，自然有序，但是我懒）。

然后你就找到了每一层的结构体。之后的操作就和操作 3 非常相似，一个一个往下跳即可。

```cpp
if(op == 4) {
	int need;
	cin>>need;
	int vp = 0;
	for(int i=1; i<=vtt; i++) {
		if(need <= (v[i].fir + a[v[i].def].siz - 1) && need >= v[i].fir) {
			vp = i;
			break;
		}
	}
	if(vp == 0) {
		cout<<"ERR\n";
		continue;
	}
	string str;
	int cur = v[vp].def;
	int sp = v[vp].fir;
	str += varname[vp];
	while(1) {
		if(a[cur].sons.size() == 0) {
			cout<<str<<'\n';
			break;
		}
		bool flag = 0;
		for(son i : a[cur].sons) {
//					cout<<(need-sp)<<' '<<(i.pos + a[i.def].siz - 1)<<' '<<(i.pos)<<'\n';
			if((need-sp) <= (i.pos + a[i.def].siz - 1) && (need-sp) >= (i.pos)) {
				flag = 1;
				cur = i.def;
				sp = sp + i.pos;
				str = str + '.' + i.name;
				break;
			}
		}
//				cout<<(need - sp)<<' '<<vp<<'\n';
		if(!flag) {
			cout<<"ERR\n";
			break;
		}
	}
}
```

## 总结

这一道题目考察了一定的代码能力，还普及了基本知识（对齐）。是一道不错的题目。

如果大家要完整代码的话可以私信我。

---

## 作者：m256i (赞：4)

挺抽象的一题（但是比 lock 正常）。

先放代码（考场代码，有改动，不必要的内容删除了）：

```cpp
#include <map>
#include <string>
typedef long long ll;
using std::cin;
using std::string;

template <typename T>
inline T max(T a, T b){return (a>b)?a:b;}
template <typename T>
inline T min(T a, T b){return (a<b)?a:b;}

template <typename T>
void _write(T x){
    if (x < 10){
        putchar(x|'0'); return;
    }
    _write(x/10), putchar(x%10|'0');
}

template <typename T>
inline void write(T x, char ch=' '){_write(x), putchar(ch);}
template <typename T>
inline void writeln(T x){_write(x), putchar('\n');}

inline ll rnd(ll x, ll y){return (x+y-1)/y*y;} // 向上取整到 y 的倍数

// Operation I

struct Child{
    ll beginPos;
    int tid;
};

struct Struct{
    ll size, align;
    std::map<string, Child> children;
} st[147];
int cnt = 4;
std::map<string, int> structs; // Name -> Id

void addType(){
    string s; int k; cin >> s >> k;
    Struct &cur = st[cnt];
    for (; k; --k){
        string type, name; cin >> type >> name;
        int tid = structs[type];
        ll size = st[tid].size, align = st[tid].align;
        cur.size = rnd(cur.size, align);
        cur.align = max(cur.align, align);
        cur.children[name] = {cur.size, tid};
        cur.size += size;
    }
    cur.size = rnd(cur.size, cur.align);
    structs[s] = cnt; ++cnt;
    write(cur.size), writeln(cur.align);
}

// Operation 2

struct Variable{
    int tid;
    ll beginPos;
};
std::map<string, Variable> var;
ll curSize;

void addVariable(){
    string t, n; cin >> t >> n;
    int tid = structs[t];
    curSize = rnd(curSize, st[tid].align);
    var[n] = {tid, curSize};
    writeln(curSize);
    curSize += st[tid].size;
}

// Operation 3

inline void split(string s, std::vector<string> &v){
    int pos;
    while ((pos=s.find('.')) != -1)
        v.push_back(s.substr(0, pos)), s = s.substr(pos+1, s.size()-pos-1);
    v.push_back(s);
}

void getElement(){
    string s; cin >> s;
    std::vector<string> v;
    split(s, v);
    int tid = var[v[0]].tid; ll addr = var[v[0]].beginPos;
    v.erase(v.begin());
    for (const string &sub : v){
        Child ch = st[tid].children[sub];
        tid = ch.tid, addr += ch.beginPos;
    }
    writeln(addr);
}

// Operation 4

inline void output(const string &s){fputs(s.c_str(), stdout);}

void getAddress(){
    ll addr; cin >> addr;
    ll beginPos = 0; int tid = -1;
    string name;
    std::vector<string> v;
    for (const auto &it : var){
        ll pos = it.second.beginPos;
        if (pos <= addr && pos >= beginPos)
            beginPos = pos, tid = it.second.tid, name = it.first;
    }
    if (tid == -1 || addr-beginPos >= st[tid].size){
        puts("ERR"); return;
    }
    string vname = name;
    while (!st[tid].children.empty()){
        addr -= beginPos, beginPos = 0;
        int nid = -1;
        for (const auto &it : st[tid].children){
            ll pos = it.second.beginPos;
            if (pos <= addr && pos >= beginPos)
                beginPos = pos, nid = it.second.tid, name = it.first;
        }
        if (nid == -1 || addr-beginPos >= st[nid].size){
            puts("ERR"); return;
        }
        v.push_back(name); tid = nid;
    }
    output(vname);
    for (string s : v) putchar('.'), output(s);
    putchar('\n');
}

int main(){
    st[0].size = st[0].align = 1; structs["byte"] = 0;
    st[1].size = st[1].align = 2; structs["short"] = 1;
    st[2].size = st[2].align = 4; structs["int"] = 2;
    st[3].size = st[3].align = 8; structs["long"] = 3;
    int n; cin >> n;
    for (; n; --n){
        int op; cin >> op;
        switch (op){
            case 1: addType(); break;
            case 2: addVariable(); break;
            case 3: getElement(); break;
            case 4: getAddress(); break;
            default: puts("WJX AK IOI");
        }
    }
    return 0;
}
```

大致解释一下。

# 操作 1
`tid` 即类型 id，防止 map 复制导致内存爆炸。

照着题意模拟就行。

对于四个基本类型可以按照类似 Python 的方式把它们当成没有成员的结构体就行（像某知名 OOP 语言一样泛型不能放基本类型太野蛮了）。

# 操作 2
还是照着模拟。

实际上 `Variable` 和 `Child` 两个结构体是可以合并的，比如某些面向对象语言里变量只能定义在类里，这个时候就不存在全局变量的概念，所有变量都是类的成员。但是考场代码懒得改了。

# 操作 3
首先写个 `split` 函数分割，然后一直循环就行。

# 操作 4
最恶心的一个。

因为 map 是按 key 排序，所以我选了一种暴力的方法：每次遍历整个 map，取小于等于当前地址的最大起始地址，如果两个地址的差大于结构体大小就是 `ERR`。

然后把 `addr` 减去起始地址再循环下去，直到当前结构体没有成员为止。

---

## 作者：GoodCoder666 (赞：3)

## CSP-S 2023 T3 结构体 题解

### 前言

非常感谢 CCF 出的大模拟，让一个蒟蒻过掉了 S T3 ~

### 基本思路

本题主要考查编码能力，所以直接给出基本思路：

- 由于可以递归式的创建元素，最多可以同时存在 $100^{100}$ 个不同的基础类型的元素。即使算上最大地址的限制，元素的数量也能达到 $10^{18}$。显然，**依次构造每个元素，在空间和时间上都是无法接受的。**
- 然而，由于询问数量有限，**真正能在查询时用到的元素数量相对很少**。因此，我们只需维护一个顶层元素（不隶属于任何其他元素的元素）列表，再根据查询的地址或名称**逐层向下找到需要的元素**即可。以下是四种操作的具体做法：
    - 对于 $op=1$：储存当前类型信息，计算大小和对齐要求并输出。
    - 对于 $op=2$：用一个变量记录当前第一个可分配内存的地址，操作时先对齐后计算、输出。
    - 对于 $op=3$：从顶层开始，逐层向下寻找，计算地址并输出。
    - 对于 $op=4$：从顶层开始，维护当前考查的元素地址，并与给定地址比对，最终输出底层元素名称。

由以上思路，很容易想到下面三种类型的存储方式：

1. 用**类型名称**作为类型的唯一的标识符。这是最直观的做法，但是效率低下且使用起来较为繁琐，pass。
2. 用 map **将类型名称映射到序号**，来代表一种数据类型。相比第一种做法，效率高了很多，但是写起来仍然很麻烦，pass。
3. 用结构体存储类型信息，并**使用指针来处理类型之间的关联**。这种做法不仅高效，而且编码时也很直观，所以我们将采用这种存储方式。

### 分步详解

#### 准备

用 `LL` 表示 `long long`，`setmax(x, y)` 等同于 `x = max(x, y)`：

```cpp
inline void setmax(int& x, int y)
{
    if(x < y) x = y;
}

using LL = long long;
```

#### 数据类型的存储

定义 **`struct DataType`**，表示一种数据类型：

```cpp
struct DataType
{
    const string name; // 类型名
    LL size, actual_size; // 对齐后的大小和实际大小（有数据的部分的长度）
    int indent; // 对齐要求
    vector<pair<DataType*, string>> members; // 类型成员，<成员类型指针，成员名称> 方式存储
};
```

**对齐**操作，依照如下公式：
$$
{对齐后的地址} = \lceil \frac {对齐前的地址} {对齐要求} \rceil \times {对齐要求}
$$

```cpp
inline LL shift(LL addr)
{
    return addr % indent? (addr / indent + 1) * indent: addr;
}
```

**维护**操作，用于操作 $1$ 后计算大小：

```cpp
inline void maintain()
{
    size = indent = 0;
    for(const auto& m: members)
    {
        setmax(indent, m.first->indent);
        size = m.first->shift(size) + m.first->size;
    }
    actual_size = size;
    size = shift(size);
}
```

注意 `shift` 和 `maintain` 都是 `DataType` 的成员函数。

主函数中，用一个 **`unordered_map` 记录类型名到数据类型的映射关系**：

```cpp
unordered_map<string, DataType*> types;
```

**添加基本类型**：

```cpp
auto add_base_type = [&](string name, int size) -> void {
    DataType* t = new DataType(name);
    t->size = t->indent = t->actual_size = size;
    types[name] = t;
};
add_base_type("byte", 1);
add_base_type("short", 2);
add_base_type("int", 4);
add_base_type("long", 8);
```

#### 操作 1：定义类型

由于 `DataType` 中已经实现维护操作，简单处理一下输入即可：

```cpp
string s;
int k;
cin >> s >> k;
DataType* type = new DataType(s);
types[s] = type;
type->members.resize(k);
for(auto& m: type->members)
{
    string t;
    cin >> t >> m.second;
    m.first = types[t];
}
type->maintain();
cout << type->size << ' ' << type->indent << '\n';
```

#### 操作 2：定义元素

根据「基本思路」中给出的做法，**维护当前第一个可分配的地址和顶层元素列表**：

```cpp
LL cur_addr = 0LL;
vector<Object> toplevel_objects;
```

`Object` 的定义：

```cpp
struct Object
{
    DataType* type; // 类型
    string name; // 名称
    LL addr; // 地址
};
```

**计算地址并保存元素**：

```cpp
Object obj;
string t;
cin >> t >> obj.name; // 输入
obj.type = types[t]; // 找到类型指针
obj.addr = obj.type->shift(cur_addr); // 对齐
cur_addr = obj.addr + obj.type->size; // 更新可分配的地址
toplevel_objects.push_back(obj); // 保存元素
```

**输出元素地址**：

```cpp
cout << obj.addr << '\n';
```

#### 操作 3：访问元素

定义一个辅助函数，类似于 Python 中的 `split()`，将一个字符串根据指定分隔符分成若干段：

```cpp
inline void split(const string& s, char sep, vector<string>& res)
{
    string t;
    for(char c: s)
        if(c == sep)
            res.push_back(t), t.clear();
        else t += c;
    res.push_back(t);
}
```

先**处理字符串并找到顶层元素**：

```cpp
// 读入
string s;
cin >> s;
// 分割
vector<string> ord;
split(s, '.', ord);
// 根据名称匹配顶层元素
LL addr;
DataType* type;
for(auto& obj: toplevel_objects)
    if(obj.name == ord[0])
    {
        addr = obj.addr;
        type = obj.type;
        break;
    }
```

**逐层向下，计算地址**：

```cpp
// ord[0] 对应顶层元素名称，删掉
ord.erase(ord.begin());
// 逐层向下遍历
for(string& s: ord)
    for(auto& m: type->members)
    {
        addr = m.first->shift(addr); // 地址对齐
        if(m.second == s) // 名称匹配
        {
            type = m.first; // 找到下一层，向下遍历
            break;
        }
        addr += m.first->size; // 地址移到下一个元素
    }
```

**输出最终地址**：

```cpp
cout << addr << '\n';
```

#### 操作 4：访问地址

同操作 3，**先找到顶层元素**：

```cpp
LL addr;
cin >> addr;
if(addr >= cur_addr) // 大于最高有效地址，直接挂掉
{
    cout << "ERR\n";
    continue;
}
DataType* type = nullptr;
LL f_addr = 0LL; // 当前考察的地址
string res; // 结果字符串
for(auto& obj: toplevel_objects)
{
    if(addr < obj.addr) goto bad; // 特判由于对齐导致的地址无效
    if(addr < obj.addr + obj.type->size) // 地址在当前范围内，记录结果
    {
        type = obj.type;
        res = obj.name;
        f_addr = obj.addr;
        break;
    }
}
```

**向下寻找并输出**：

```cpp
// 循环条件：(1) 地址有效 (2) 不是基本类型（类型有成员）
while(addr < f_addr + type->actual_size && !type->members.empty())
    for(auto& m: type->members)
    {
        f_addr = m.first->shift(f_addr); // 对齐
        if(addr < f_addr) goto bad; // 特判，同上
        if(addr < f_addr + m.first->size)
        {
            type = m.first;
            res.push_back('.');
            res += m.second;
            break;
        }
        f_addr += m.first->size;
    }
if(addr < f_addr + type->actual_size) cout << res << '\n'; // 地址有效则输出结果
else cout << "ERR\n"; // 地址无效
continue;
bad: cout << "ERR\n"; // 前面使用的 bad 标签
```

### 完整代码

下面是赛时代码，也是前面讲解中使用的：

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm>
using namespace std;

inline void setmax(int& x, int y)
{
    if(x < y) x = y;
}

using LL = long long;

struct DataType
{
    const string name;
    LL size, actual_size;
    int indent;
    vector<pair<DataType*, string>> members;
    inline DataType(const string& n): name(n) {}
    inline LL shift(LL addr)
    {
        return addr % indent? (addr / indent + 1) * indent: addr;
    }
    inline void maintain()
    {
        size = indent = 0;
        for(const auto& m: members)
        {
            setmax(indent, m.first->indent);
            size = m.first->shift(size) + m.first->size;
        }
        actual_size = size;
        size = shift(size);
    }
};

struct Object
{
    DataType* type;
    string name;
    LL addr;
};

inline void split(const string& s, char sep, vector<string>& res)
{
    string t;
    for(char c: s)
        if(c == sep)
            res.push_back(t), t.clear();
        else t += c;
    res.push_back(t);
}

int main()
{
    ios::sync_with_stdio(false); cin.tie(nullptr);
    unordered_map<string, DataType*> types;
    auto add_base_type = [&](string name, int size) -> void {
        DataType* t = new DataType(name);
        t->size = t->indent = t->actual_size = size;
        types[name] = t;
    };
    add_base_type("byte", 1);
    add_base_type("short", 2);
    add_base_type("int", 4);
    add_base_type("long", 8);
    int q;
    cin >> q;
    vector<Object> toplevel_objects;
    LL cur_addr = 0LL;
    while(q--)
    {
        int op;
        cin >> op;
        if(op == 1)
        {
            string s;
            int k;
            cin >> s >> k;
            DataType* type = new DataType(s);
            types[s] = type;
            type->members.resize(k);
            for(auto& m: type->members)
            {
                string t;
                cin >> t >> m.second;
                m.first = types[t];
            }
            type->maintain();
            cout << type->size << ' ' << type->indent << '\n';
        }
        else if(op == 2)
        {
            Object obj;
            string t;
            cin >> t >> obj.name;
            obj.type = types[t];
            obj.addr = obj.type->shift(cur_addr);
            cur_addr = obj.addr + obj.type->size;
            toplevel_objects.push_back(obj);
            cout << obj.addr << '\n';
        }
        else if(op == 3)
        {
            string s;
            cin >> s;
            vector<string> ord;
            split(s, '.', ord);
            LL addr;
            DataType* type;
            for(auto& obj: toplevel_objects)
                if(obj.name == ord[0])
                {
                    addr = obj.addr;
                    type = obj.type;
                    break;
                }
            ord.erase(ord.begin());
            for(string& s: ord)
                for(auto& m: type->members)
                {
                    addr = m.first->shift(addr);
                    if(m.second == s)
                    {
                        type = m.first;
                        break;
                    }
                    addr += m.first->size;
                }
            cout << addr << '\n';
        }
        else // op == 4
        {
            LL addr;
            cin >> addr;
            if(addr >= cur_addr)
            {
                cout << "ERR\n";
                continue;
            }
            DataType* type = nullptr;
            LL f_addr = 0LL;
            string res;
            for(auto& obj: toplevel_objects)
            {
                if(addr < obj.addr) goto bad;
                if(addr < obj.addr + obj.type->size)
                {
                    type = obj.type;
                    res = obj.name;
                    f_addr = obj.addr;
                    break;
                }
            }
            while(addr < f_addr + type->actual_size && !type->members.empty())
                for(auto& m: type->members)
                {
                    f_addr = m.first->shift(f_addr);
                    if(addr < f_addr) goto bad;
                    if(addr < f_addr + m.first->size)
                    {
                        type = m.first;
                        res.push_back('.');
                        res += m.second;
                        break;
                    }
                    f_addr += m.first->size;
                }
            if(addr < f_addr + type->actual_size) cout << res << '\n';
            else cout << "ERR\n";
            continue;
            bad: cout << "ERR\n";
        }
    }
    for(auto it=types.begin(); it!=types.end(); it++)
        delete it->second;
    return 0;
}
```

程序共计 $180$ 行，长度 $4.64\mathrm{KB}$，运行用时 $73\mathrm{ms}$。

实际上 `Object` 的定义没有必要，也不需要存储每个顶层元素的地址，同时还可以稍加压行：

```cpp
#include <bits/stdc++.h>
using namespace std;

using LL = long long;

struct DataType {
    const string name;
    LL size, actual_size;
    int indent;
    vector<pair<DataType*, string>> members;
    inline DataType(const string& n): name(n) {}
    inline LL shift(LL addr) {
        return addr % indent? (addr / indent + 1) * indent: addr;
    }
    inline void maintain() {
        size = indent = 0;
        for(const auto& m: members)
        {
            indent = max(indent, m.first->indent);
            size = m.first->shift(size) + m.first->size;
        }
        actual_size = size;
        size = shift(size);
    }
};

inline void split(const string& s, char sep, vector<string>& res) {
    string t;
    for(char c: s)
        if(c == sep) res.push_back(t), t.clear();
        else t += c;
    res.push_back(t);
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    unordered_map<string, DataType*> types;
    auto add_base_type = [&](string name, int size) -> void {
        DataType* t = new DataType(name);
        t->size = t->indent = t->actual_size = size;
        types[name] = t;
    };
    add_base_type("byte", 1);
    add_base_type("short", 2);
    add_base_type("int", 4);
    add_base_type("long", 8);
    int q;
    cin >> q;
    vector<pair<DataType*, string>> toplevel_objects;
    LL cur_addr = 0LL;
    while(q--) {
        int op;
        cin >> op;
        if(op == 1) {
            string s;
            int k;
            cin >> s >> k;
            DataType* type = new DataType(s);
            types[s] = type;
            type->members.resize(k);
            for(auto& m: type->members) {
                string t;
                cin >> t >> m.second;
                m.first = types[t];
            }
            type->maintain();
            cout << type->size << ' ' << type->indent << '\n';
        }
        else if(op == 2) {
            string t, name;
            cin >> t >> name;
            DataType* type = types[t];
            cur_addr = type->shift(cur_addr);
            cout << cur_addr << '\n';
            cur_addr += type->size;
            toplevel_objects.emplace_back(type, name);
        }
        else if(op == 3) {
            string s;
            cin >> s;
            vector<string> ord;
            split(s, '.', ord);
            LL addr = 0LL;
            DataType* type;
            for(auto& obj: toplevel_objects) {
                addr = obj.first->shift(addr);
                if(obj.second == ord[0]) {
                    type = obj.first;
                    break;
                }
                addr += obj.first->size;
            }
            ord.erase(ord.begin());
            for(string& s: ord)
                for(auto& m: type->members) {
                    addr = m.first->shift(addr);
                    if(m.second == s) {
                        type = m.first;
                        break;
                    }
                    addr += m.first->size;
                }
            cout << addr << '\n';
        }
        else {
            LL addr;
            cin >> addr;
            if(addr >= cur_addr) {
                cout << "ERR\n";
                continue;
            }
            DataType* type = nullptr;
            LL f_addr = 0LL;
            string res;
            for(auto& obj: toplevel_objects) {
                f_addr = obj.first->shift(f_addr);
                if(addr < f_addr) goto bad;
                if(addr < f_addr + obj.first->size) {
                    type = obj.first;
                    res = obj.second;
                    break;
                }
                f_addr += obj.first->size;
            }
            while(addr < f_addr + type->actual_size && !type->members.empty())
                for(auto& m: type->members) {
                    f_addr = m.first->shift(f_addr);
                    if(addr < f_addr) goto bad;
                    if(addr < f_addr + m.first->size) {
                        type = m.first;
                        res.push_back('.');
                        res += m.second;
                        break;
                    }
                    f_addr += m.first->size;
                }
            if(addr < f_addr + type->actual_size) cout << res << '\n';
            else cout << "ERR\n";
            continue;
            bad: cout << "ERR\n";
        }
    }
    for(auto it=types.begin(); it!=types.end(); it++)
        delete it->second;
    return 0;
}
```

这样只有 $146$ 行，$4.51\mathrm{KB}$。

不过个人觉得写个 `Object` 更清楚，所以讲解的时候就没改啦~

#### 后记

算法固然重要，但是编码能力也很重要！强烈建议各位 OIer 重视大模拟，不在这种题上挂分~

写大模拟需要注意的几个点：

- 变量名写清楚，全写 `a`、`b`、`c`、`d` 到后面自己都不知道是啥，没法调试
- 该用指针就用指针，不要害怕，用多了会发现真的很好用
- 适当使用类和结构体，尽量不要全部使用 `int` 数组
- 时间复杂度允许的情况下，可读性比性能重要！！（比如本题没有使用二分查找）

祝大家在 NOIP 2023 取得好成绩！~~求赞qwq~~

**11.1 UPD：新增了分步详解。**

---

## 作者：封禁用户 (赞：3)

### 题目来源

CSP-S 2023 第三题。

### 分析

一个大模拟题目。

开一个结构体，来存：

+ 占用空间大小

+ 对其长度

+ 元素个数

+ 每个元素名称到编号的映射

+ 每个元素的名称、首地址、类型

```cpp
ll sz,k;
int len;
map<string,int> idx;
vector<string> ele;
vector<ll> ad;
vector<int> type;
node() {sz = k = 0,len = 0;}
```
发现元素和子结构体在母结构体中的排列规则与所有定义的元素和结构体在整个空间中的排布规则类似。为了方便，我们把所有定义的元素或者结构体存储在编号为 $0$ 的超级结构体中。

+ 对于一操作，我们按照题目意思，把所有输入的元素或子结构体插入母结构体中，并输出占用空间大小和对齐长度。

+ 对于而操作二，我们把该元素或结构体插入超级结构体中，并输出它在超级结构体中占用的首个空间位置。

+ 对于操作三，根据指引访问空间。

+ 对于操作四，不需要二分，直接线性遍历。如果访问的空间超出了该空间，则输出 ```ERR```。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO
{
	constexpr int fsize = 1<<24;
	#define getchar() ((IO::si!=IO::ti||(IO::ti=(IO::si=IO::input)+fread(IO::input,1,IO::fsize,stdin))),IO::si!=IO::ti?*(IO::si++):EOF)
	#define putchar(c) ((IO::out.so!=IO::out.to||(fwrite(IO::out.output,1,IO::fsize,stdout),IO::out.so=IO::out.output)),*(IO::out.so++)=c)
	char input[fsize],*si = input,*ti = input;
	struct output_stream
	{
		char output[fsize],*so = output,*to = output + fsize;
		inline ~output_stream()
		{
			if(so == output) return;
			fwrite(output,1,so-output,stdout);
			so = output;
		}
	}out;
	template<typename T>inline void read(T &x)
	{
		int c = getchar(),p = 1;
		x = 0;
		while(c < 48||c > 57)
		{
			if(c == 45) p = -1;
			c = getchar();
		}
		while(48 <= c&&c <= 57)
		{
			x = (x<<3)+(x<<1)+(c^48);
			c = getchar();
		}
		x *= p;
	}
	template<typename T>inline void write(T x)
	{
		static int c[40],cnt = 0;
		if(x < 0) putchar(45),x = -x;
		if(!x) putchar(48);
		while(x) c[++cnt] = x%10^48,x /= 10;
		while(cnt) putchar(c[cnt--]);
	}
}
using IO::read;
using IO::write;
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define ull unsigned long long
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second
#define N 110
map<string,int> mp;
struct node
{
	ll sz,k;
	int len;
	map<string,int> idx;
	vector<string> ele;
	vector<ll> ad;
	vector<int> type;
	node() {sz = k = 0,len = 0;}
	inline void resize(int _len)
	{
		ele.resize(_len + 3);
		ad.resize(_len + 3);
		type.resize(_len + 3);
	}
	inline void insert(string s,int _type,ll _sz,ll _k)
	{
		idx[s] = ++len;
		ele[len] = s;
		type[len] = _type;
		if(sz % _k) sz = (sz / _k + 1) * _k; 
		ad[len] = sz;
		sz += _sz;
		k = max(k,_k);
	}
	inline void calc()
	{
		if(sz % k) sz = (sz / k + 1) * k; 
	}
}a[110];
int n = 0,m;
int main()
{
	a[0].resize(110);
	mp["byte"] = 1,a[1].sz = a[1].k = 1;
	mp["short"] = 2,a[2].sz = a[2].k = 2;
	mp["int"] = 3,a[3].sz = a[3].k = 4;
	mp["long"] = 4,a[4].sz = a[4].k = 8;
	n = 4;
	read(m);
	while(m--)
	{
		string s,str;
		int op,k,id;
		read(op);
		if(op == 1)
		{
			cin >> s;
			read(k);
			mp[s] = ++n;
			a[n].resize(k);
			while(k--)
			{
				cin >> s >> str;
				id = mp[s];
				a[n].insert(str,id,a[id].sz,a[id].k);
			}
			a[n].calc();
			write(a[n].sz),putchar(32),write(a[n].k);
		}
		else if(op == 2)
		{
			cin >> s >> str;
			id = mp[s];
			a[0].insert(str,id,a[id].sz,a[id].k);
			write(a[0].ad[a[0].len]);
		}
		else if(op == 3)
		{
			cin >> s;
			s = '.' + s + '.';
			ll ret = 0;
			int l = 0,r = s.find('.',1),now = 0;
			while(1)
			{
				str = s.substr(l+1,r-l-1);
				id = a[now].idx[str];
				ret += a[now].ad[id];
				now = a[now].type[id];
				if(r == (int)s.size() - 1) break;
				l = s.find('.',r+1);
				swap(l,r);
			}
			write(ret);
		}
		else
		{
			ll ad;
			read(ad);
			s = "";
			int now = 0;
			while(1)
			{
				if(ad >= a[now].sz) 
				{
					s = "ERR";
					break;
				}
				if(1 <= now&&now <= 4) break;
				F(i,1,a[now].len)
					if(i == a[now].len||a[now].ad[i+1] > ad)
					{
						ad -= a[now].ad[i];
						s += a[now].ele[i];
						now = a[now].type[i];
						if(now > 4) s += '.';
						break;
					}
			}
			F(i,0,(int)s.size()-1) putchar(s[i]);
		}
		putchar(10);
	}
	return 0;
}
```


---


# [CSP-S 2023] 种树

## 题目描述

你是一个森林养护员，有一天，你接到了一个任务：在一片森林内的地块上种树，并养护至树木长到指定的高度。

森林的地图有 $n$ 片地块，其中 $1$ 号地块连接森林的入口。共有 $n-1$ 条道路连接这些地块，使得每片地块都能通过道路互相到达。最开始，每片地块上都没有树木。

你的目标是：在每片地块上均种植一棵树木，并使得 $i$ 号地块上的树的高度生长到不低于 $a_i$ 米。

你每天可以选择一个未种树且**与某个已种树的地块直接邻接**（**即通过单条道路相连**）的地块，种一棵高度为 $0$ 米的树。如果所有地块均已种过树，则你当天不进行任何操作。特别地，第 $1$ 天你只能在 $1$ 号空地种树。

对每个地块而言，从该地块被种下树的当天开始，该地块上的树每天都会生长一定的高度。由于气候和土壤条件不同，在第 $x$ 天，$i$ 号地块上的树会长高 $\max(b_i + x \times c_i, 1)$ 米。注意这里的 $x$ 是从整个任务的第一天，而非种下这棵树的第一天开始计算。

你想知道：最少需要多少天能够完成你的任务？

## 说明/提示

**【样例 1 解释】**

第 $1$ 天：在地块 $1$ 种树，地块 $1$ 的树木长高至 $2$ 米。

第 $2$ 天：在地块 $3$ 种树，地块 $1, 3$ 的树木分别长高至 $5, 3$ 米。

第 $3$ 天：在地块 $4$ 种树，地块 $1, 3, 4$ 的树木分别长高至 $9, 6, 4$ 米。

第 $4$ 天：在地块 $2$ 种树，地块 $1, 2, 3, 4$ 的树木分别长高至 $14, 1, 9, 6$ 米。

第 $5$ 天：地块 $1, 2, 3, 4$ 的树木分别长高至 $20, 2, 12, 7$ 米。

**【样例 2】**

见选手目录下的 `tree/tree2.in` 与 `tree/tree2.ans`。

**【样例 3】**

见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。

**【样例 4】**

见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。

**【数据范围】**

对于所有测试数据有：$1 ≤ n ≤ 10^5,1 ≤ a_i ≤ 10^{18}, 1 ≤ b_i ≤ 10^9,0 ≤ |c_i| ≤ 10^9, 1 ≤ u_i, v_i ≤ n$。保证存在方案能在 $10^9$ 天内完成任务。

![T4](https://cdn.luogu.com.cn/upload/image_hosting/aqqd4l0y.png?x-oss-process=image/resize,m_lfit,h_400,w_300)

特殊性质 A：对于所有 $1 ≤ i ≤ n$，均有 $c_i = 0$；

特殊性质 B：对于所有 $1 ≤ i < n$，均有 $u_i = i$、$v_i = i + 1$；

特殊性质 C：与任何地块直接相连的道路均不超过 $2$ 条；

特殊性质 D：对于所有 $1 ≤ i < n$，均有 $u_i = 1$。

## 样例 #1

### 输入

```
4
12 1 1
2 4 -1
10 3 0
7 10 -2
1 2
1 3
3 4```

### 输出

```
5
```

# 题解

## 作者：Demeanor_Roy (赞：179)

- [原题链接](https://www.luogu.com.cn/problem/P9755?contestId=140859)

- 赛后重新想，不到十分钟就会了。感觉我是 zz。

------------

本题解将通过链和特殊性质 A 两档部分分引导读者走向正解。请各位不要跳读。

### 链

我们首先来考虑链的部分分。

不难发现，这部分的关键是实现一个形如 `check(x,l,r)` 的函数，表示 $x$ 结点在 $[l,r]$ 这段时间的生长高度能否达成目标。同时，这也是正解的一个关键函数。

不妨列出 $x$ 结点高度的表达式：

$$\sum_{i=l}^{r}\max(1,b_x + ic_x)$$

先考虑 $c_x \geq 0$ 的情况，那么上式可按如下化简：

$$\sum_{i=l}^{r}b_x + ic_x$$

$$=\sum_{i=l}^{r}b_x+\sum_{i=l}^{r}ic_x$$

$$=b_x(r-l+1)+c_x\frac{(l+r)(r-l+1)}{2}$$

接下来考虑 $c_x<0$，此时我们不妨找到使得 $b_x + ic_x \geq 1$ 的最大的 $i$，不难得出：$i_{max} = \lfloor \frac{1-b_x}{c_x} \rfloor $。接下来分情况讨论，可得：


$h = \begin{cases}r-l+1
  &
  i_{max} < l
  \\
  b_x(r-l+1)+c_x\frac{(l+r)(r-l+1)}{2} & i_{max}> r
  \\b_x(i_{max}-l+1)+c_x\frac{(l+i_{max})(i_{max}-l+1)}{2}+r-i_{max} & i_{max} \in [l,r]
  \end{cases}$
  
至此这个函数实现完毕。而统计答案，你就对链上的第 $i$ 个点二分出最小的 $r$ 满足 `check(i,i,r)` 为真的 $r$，所有 $r$ 取个 $\max$ 即可。

### 特殊性质 A

接着我们思考特殊性质 A。

不难发现此时每个结点生长到目标高度所需时间与种下的时间无关，即有 $t_x = \lceil \frac{a_x}{b_x} \rceil$。

将结点按 $t_x$ 从大到小排序。考虑这样一个贪心，我们顺次考虑所有结点，若该结点已被种树就跳过，否则将根到该结点这条链按顺序把**未种树的结点**种树。显然这样做会得到一个种树顺序的序列，显然由于 $t_x$ 更小的结点不是时间的瓶颈，我们这样做是最优的。

实际实现过程中，我们标记一下每个结点是否种过树。当考虑当前结点 $x$ 时，暴力跳到最后一个未被标记的祖先结点，然后倒序再给每个结点赋上开始种树的时间 $s_x$。取 $s_x+t_x-1$ 的最大值即可。

### 正解

想明白了前两个部分，正解就是容易的。

考虑一般情况与特殊性质 A 的区别，不难发现我们无法得到上述的 $t_x$ 了，究其根本是因为树种下的时间会影响种树需要的时间。

我们考虑二分答案，**并修改 $t_x$ 的定义**为要使该结点合法的最晚种树时间。显然在该前提下，$t_x$ 可以用二分答案加上链部分所实现的函数求出。而这时我们按照 $t_x$ 从小到大考虑，不难发现问题就转化为了特殊性质 A 时的问题，套用以上做法即可解决。

时间复杂度 $O(n \log n \log v)$。用桶排并上二次函数相关知识应该能将 $\log n$ 去掉，不过没必要。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ___ __int128
const int N=1e5+10;
int n,b[N],c[N],p[N],t[N],fa[N],stk[N];
int h[N],e[N<<1],ne[N<<1],idx;
bool vis[N];
long long a[N];
inline void add(int a,int b)
{
	e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}
inline void dfs(int u,int p){fa[u]=p;for(int i=h[u];~i;i=ne[i]) if(e[i]!=p) dfs(e[i],u);}
inline ___ calc(int x,___ l,___ r)
{
	if(c[x]>=0) return (r-l+1)*b[x]+(r-l+1)*(l+r)/2*c[x];
	___ T=(1-b[x])/c[x];
	if(T<l) return r-l+1;
	if(T>r) return (r-l+1)*b[x]+(r-l+1)*(l+r)/2*c[x];
	return (T-l+1)*b[x]+(T-l+1)*(l+T)/2*c[x]+r-T;
}
inline bool check(int r)
{
	for(int i=1;i<=n;i++) 
	{
		if(calc(i,1,r)<a[i]) return false;
		int dl=1,dr=n;
		while(dl<dr)
		{
			int mid=(dl+dr+1)>>1;
			if(calc(i,mid,r)>=a[i]) dl=mid;
			else dr=mid-1;
		}
		p[i]=i;t[i]=dl;vis[i]=false;
	}
	sort(p+1,p+n+1,[](int A,int B){return t[A]<t[B];});
	for(int i=1,x=0;i<=n;i++)
	{
		int now=p[i],top=0;
		while(!vis[now]) vis[stk[++top]=now]=true,now=fa[now];
		while(top) if(t[stk[top--]]<++x) return false;
 	}
 	return true;
}
int main()
{
	memset(h,-1,sizeof h);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lld%d%d",&a[i],&b[i],&c[i]);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs(1,0);vis[0]=true;
	int l=n,r=1e9;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	} 
	printf("%d",l);
	return 0;
}
```


---

## 作者：lsj2009 (赞：40)

### 闲话

场切了，但是被卡常了，而且快读没判负数，寄飞了/px

这次 CSP-S 是不是没有放防阿克的题啊，T4 我竟然能做出来/jy

### Problem

link：<https://www.luogu.com.cn/problem/P9755>。

### Solution

首先一眼答案具有单调性，然后一眼二分答案，那么就要考虑 ``check`` 函数怎么写。

考虑我们现在在判断时刻 $m$ 是否合法，那么我们对于每个点再去求一个值 $t_i$ 代表最晚要在第 $t_i$ 时刻把这个点的树种上。则 $t_i=\max\limits_{\sum\limits_{j=x}^m \max\{b_i+j\cdot c_i,1\}\ge a_i}{x}$。

则问题在于如何快速计算 $f(m)=\sum\limits_{j=1}^m \max\{b_i+j\cdot c_i,1\}$。

其实这是好做的（小学奥数/yiw），考虑到 $\sum\limits_{j=1}^m b_i+j\cdot c_i$ 和 $\sum\limits_{j=1}^m 1$ 都是好求的，那么我们要把那个 $\max$ 给去掉。

方便起见，设 $g(x)=\sum\limits_{i=1}^x i=\frac{x(x+1)}{2}$。

观察到 $b_i,c_i$ 和 $1$ 是定值，则 $y=b_i+c_i\cdot x$ 和 $y'=1$ 至多只有一个交点：

- 当 $c_i<0$ 时，若 $y=y'$，则 $x_0=\lfloor\frac{1-b_i}{c_i}\rfloor$。当 $x\le x_0$ 时，$\max$ 取 $b_i+c_i\cdot x$，当 $x> x_0$ 时 $\max$ 取 $1$。得 $f(m)=g(x_0)\cdot c_i+x_0\cdot b_i+(m-x_0+1)$。

- 当 $c_i=0$ 时，$y=b_i+c_i\cdot x=b_i+0\cdot x=b_i$。得 $f(m)=m\cdot b_i$。

- 当 $c_i>0$ 时，若 $y=y'$，则 $x_0=\lfloor\frac{1-b_i}{c_i}\rfloor$。当 $x\le x_0$ 时，$\max$ 取 $1$，当 $x> x_0$ 时 $\max$ 取 $b_i+c_i\cdot x$。得 $f(m)=x_0+(g(m)-g(x_0))\cdot c_i+(m-x_0)\cdot b_i$。

需要注意的是，笔者在代码实现中 $x_0$ 是上取整，所以可能与刚才推的柿子略有不同。

此外 $x_0$ 应当向 $0$ 取 $\max$，向 $m$ 取 $\min$。

由于 $f(m)$ 具有单调性，则 $f(m)-f(x)$ 同样具有单调性，对于 $t_i$ 二分求即可。

得到 $t_i$ 后，我们贪心地将所有点按 $t_i$ 排序，然后依次从其一直向根节点种树。邻项交换易证。

但是由于我们每次种树是要将其到根节点全部种上树，而且每个节点不能重复种，相当于路径覆盖全 $1$，全局查询当前有几个 $1$。如果直接树剖暴力做，复杂度是 $\Theta(n\log V\log^2 n)$ 的，显然过不去。

但是我们考虑到一个节点只会被种一次，而且如果某个节点已经被种过了，其所有祖先节点必然也被种过，所有我们每次只需要暴力跳父亲，然后打上一个代表已经填过的 tag，遇到如果某个父亲已经被种过就 ``return``，均摊复杂度 $\Theta(n)$。

最终复杂度瓶颈在于两个二分和排序，时间复杂度为 $\Theta(n\log V\log n)$。

### Code

```cpp
#include<bits/stdc++.h>
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define ll long long
//#define int long long
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define cl(f,x) memset(f,x,sizeof(f))
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
using namespace std;
const int N=1e5+5;
int head[N],len;
struct node {
	int to,nxt;
}; node edge[N<<1];
void add_edge(int u,int v) {
	edge[++len]={v,head[u]}; head[u]=len;
}
int f[N];
void dfs(int u,int fa) {
	f[u]=fa;
	for(int i=head[u];i;i=edge[i].nxt) {
		int v=edge[i].to;
		if(v!=fa)
			dfs(v,u);
	}
}
__int128 calc(__int128 x) {
	return x*(x+1)/2;
}
const __int128 awa=1;
inline __int128 calc(__int128 a,__int128 b,__int128 c) {
	__int128 x=max(awa,min(a+1,(__int128)ceil(1.0*(1-b)/c)));
	if(c<0)
		return (x-1)*b+calc(x-1)*c+(a-x+1);
	else if(c==0)
		return a*b;
	else
		return (x-1)+(a-x+1)*b+(calc(a)-calc(x-1))*c;
}
ll a[N],b[N],c[N];
int p[N],t[N],n;
bool used[N];
int update(int u) {
	if(used[u])
		return 0;
	used[u]=true;
	if(f[u])
		return update(f[u])+1;
	return 1;
}
bool check(int x) {
	rep(i,1,n) {
		used[i]=false;
		__int128 val=calc(x,b[i],c[i]);
		if(val<a[i])
			return false;
		int l=1,r=n,ans=-1;
		while(l<=r) {
			int mid=(l+r)>>1;
			if(val-calc(mid-1,b[i],c[i])>=a[i])
				ans=mid,l=mid+1;
			else
				r=mid-1;
		}
		t[i]=ans;
	}
	sort(p+1,p+n+1,[](const int &x,const int &y) {
		return t[x]<t[y];
	});
	int res=0;
	rep(i,1,n) {
		res+=update(p[i]);
		if(res>t[p[i]])
			return false;
	}
	return true;
}
ll read() {
	ll x=0,f=1; 
	char ch=getchar();
	while(!isdigit(ch)) {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		x=x*10+ch-48,ch=getchar();
	return x*f;
}
int main() {
	n=read();
	rep(i,1,n)
	a[i]=read(),b[i]=read(),c[i]=read(),p[i]=i;
	rep(i,2,n) {
		int u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs(1,0);
	int l=n,r=1e9,ans=1e9;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid))
			r=mid-1,ans=mid;
		else
			l=mid+1;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：31)

### 题意：

森林的地图有 $n$ 片地块，其中 $1$ 号地块连接森林的入口。

共有 $n-1$ 条道路连接这些地块，使得每片地块都能通过道路互相到达。

你每天可以选择一个未种树且与某个已种树的地块直接邻接（即通过单条道路相连）的地块，种一棵高度为 $0$ 米的树。

在第 $x$ 天，$i$ 号地块上的树会长高 $\max(b_i + x \times c_i, 1)$ 米。注意这里的 $x$ 是从整个任务的第一天，而非种下这棵树的第一天开始计算。

你想知道：最少需要多少天能够完成你的任务？

### 思路：

显然完成任务的天数符合单调性，如果 $i$ 可以完成，那么 $i \sim \inf$ 都可以，所以可以二分答案，现在想想怎么求 ``check``。

先对于每一个地块求一下第一次使得 $b_i + h_i \times c_i \le 1$ 的某一天 $h_i$，显然如果 $c_i > 0$，那么 $h_i = \inf$。

否则，我们可以二分一下，或者直接解方程：

$$b_i + h_i \times c_i \le 1 \to h_i \times c_i \le 1-b_i \to h_i \le \frac{(1-b_i)}{c_i}$$

可得第一个满足条件的 $h_i=\lfloor \frac{(1-b_i)}{c_i} \rfloor$，则在 $h_i \sim \inf$ 天内每天生长的贡献都是 $1$,

然后考虑写这样一个函数，$\operatorname{F}(i,l,r)$ 表示对于第 $i$ 个地块，从 $l$ 天开始种，种到 $r$ 天之后第 $i$ 个地块生长的高度。

如果 $l > h_i$，那么这 $[l,r]$ 天每天只能生长 $1$ 的高度，直接返回 $r-l+1$；

如果 $r < h_i$，那么 $[l,r]$ 天种每次得到的贡献都是 $b_i + x \times c_i$，总共 $r-l+1$ 个 $b_i$ 相加和 $\sum\limits_{i=l}^r  i \times x$，即有 $l \sim r$ 的和个 $x$，然后用等差数列求和公式：$\frac{(l+r) \times (r-l+1)}{2} \times x$，则汇总起来为 $(r-l+1) \times b_i + \frac{(l+r) \times (r-l+1)}{2} \times x$。

如果上述两个都不成立，那么说明 $h_i$ 在 $[l,r]$ 中间，拆成两部分计算 $[l,h_i-1]$ 和 $[h_i,r]$ 两个区间，按照上述方法计算即可，应为：$(r-h_i)+(h_i-l+1) \times b_i + \frac{(l+h_i) \times (h_i-l+1)}{2} \times c_i$。

这样得出函数式子：

$$\operatorname{F}(i,l,r)=\begin{cases} r-l+1 & l > h_i \\ (r-l+1) \times b_i + \frac{(l+r) \times (r-l+1)}{2} \times x & r < h_i \\ (r-h_i)+(h_i-l+1) \times b_i + \frac{(l+h_i) \times (h_i-l+1)}{2} \times c_i & l \le h_i \le r \end{cases}$$

那么在判断答案 $x$ 时候，对于每一个地块 $i$，如果从时间 $1$ 就开始种（假设），即最早种的话，种到 $x$ 天的高度为 $\operatorname{F}(i,1,x)$，如果该高度还是小于 $a_i$ 的话，那么该答案肯定不行。（即如果最早种就长不到理想高度）

然后我们可以对于每一个地块 $i$，求出最晚种树且到 $x$ 天时能到达 $a_i$ 高度的天数 $k_i$，这个可以二分来求出来。

也就是我们现在需要思考这样一个问题：对于第 $i$ 个点可以在 $1 \sim k_i$ 之间任意一个时间种树，每一个时间只能种一棵树，是否有满足要求的种树方案。

考虑一种贪心的想法。

将 $k_i$ 从小到大进行排序，从 $k_i$ 最小的点开始，如果当前点已经种过树了，那么跳过；

否则，我们将这个地块种树，显然需要先将根节点到该点路径上的所有点给种上树，这个我们可以暴力找，找到该点祖先中第一个被种过树的点 $f_i$（因为这个点被种上了，那么 $f_i$ 到根节点的路径肯定也是被种过树的），然后由上至下依次赋值种植的时间。（如果这个时间 $ > k_v$，那么显然当前答案不符合要求）

若按照上述贪心，对于第 $x$ 块地符合要求。

可以发现，先种 $x$ 号再种 $x+1$ 号形成的种树点集与先种 $x+1$ 号再种 $x$ 号形成的种树点集是一样的。

那么两次种树之后结尾时间是一样的，若是结尾时间都 $>k_{x+1}$ 了，那么肯定是 $>k_x$ 的，所以交换一下种植顺序是无法使得答案符合要求的；若是交换之后都可以符合要求，那么无论换顺序还是不按顺序，都是符合要求的。

时间复杂度为：$O(N \log N \log W)$。

**注意：必须开 __int128，不然只有 25pts。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 ll;
typedef double db;
const ll N=100100,INF=1e10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll x,y;
	bool operator<(const Node&rhs)const{
		return x<rhs.x;
	}
}k[N];
ll n;
ll a[N],b[N],c[N],h[N],p[N],fa[N];
vector<ll> E[N];
bool f[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void dfs(ll u,ll f){
	for(auto v:E[u]){
		if(v==f)
		  continue;
		fa[v]=u;
		dfs(v,u);
	}
}
ll F(ll i,ll l,ll r){
	ll t=(r-l+1);
	if(h[i]<l)
	  return t;
	if(h[i]>r)
	  return t*b[i]+(((l+r)*t)/2)*c[i];
	return (r-h[i])+(h[i]-l+1)*b[i]+(((l+h[i])*(h[i]-l+1))/2)*c[i];
}
bool check(ll x){
	for(int i=1;i<=n;i++){
		if(F(i,1,x)<a[i])
		  return 0;
		ll l=1,r=n;
		while(l<r){
			ll mid=(l+r+1)>>1;
			if(F(i,mid,x)>=a[i])
			  l=mid;
			else
			  r=mid-1;
		}
		k[i]={l,i};
		p[i]=k[i].x;
	}
	memset(f,0,sizeof(f));
	sort(k+1,k+n+1);
	f[0]=1;
	ll h=0;
	for(int i=1;i<=n;i++){
		stack<ll> d;
		ll t=k[i].y;
		while(!f[t]){
			d.push(t);
			f[d.top()]=1;
			t=fa[t];
		}
		while(!d.empty()){
			++h;
			if(p[d.top()]<h)
			  return 0;
			d.pop();
		}
	}
	return 1;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i]=read();
		c[i]=read();
	}
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	for(int i=1;i<=n;i++){
		if(c[i]>=0)
		  h[i]=INF;
		else
		  h[i]=(1-b[i])/c[i];
	}
	dfs(1,1);
	ll l=n,r=1e9;
	while(l<r){
		ll mid=(l+r)>>1;
		if(check(mid))
		  r=mid;
		else
		  l=mid+1;
	}
	write(l);
	return 0;
}
```


---

## 作者：yhk1001 (赞：27)

给一个不一样的考场做法。事实证明，写对二分而不是质疑做法非常重要……

二分答案和求时间限制的部分是所有做法共有的，略。

设 $d_i$ 表示第 $i$ 个点的时间限制，即必须在第 $d_i$ 天及之前种树。

正难则反。正向贪心不好想，不如时间倒流，考虑最后被种的树。本人考场上直接联想到了 HNOI2015 菜肴制作，事实上它的做法可以直接搬过来。

最后种的树一定在叶子节点。从贪心入手，该节点的时间限制肯定是越松越好，于是取 $d_i$ 最大的叶子即可。把这个叶子删去，转化为一棵 $n - 1$ 个节点的树求解同样的问题。于是自底向上做拓扑排序，并用堆维护 $d_i$ 最大值，最后检查构造出的序列是否合法即可。

有没有正确性呢？当然是有的。感性理解一下，假设当前入度为 $0$ 的点中 $d_i$ 最大的节点是 $x$、次大的是 $y$。如果取 $y$，那么一定是为了让 $y$ 祖先中一个 $d_i$ 更大的节点 $z$ 提前取出，序列由 $x \to y \to \dots \to z \to \dots$ 变为 $y \to \dots \to z \to \dots \to x \to \dots$。但是这样必然不优，因为包含 $y, z$ 的一些节点有超时的风险，而如果 $x$ 先取满足所有限制，延后取一定可以至少满足 $d_x$。

叙述可能有点抽象，结合代码看看比较好。

以下为修正后的考场代码。

```cpp
/*
I shall be telling this with a sigh
Somewhere ages and ages hence
Two roads diverged in a wood, and I
I took the one less travelled by
And that has made all the difference
*/

#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <queue>
using namespace std;

const int N = 1e5, E = N << 1;
const long long Max = 1e9;

typedef pair<long long, int> pir;

int n;
long long a[N + 5], b[N + 5], c[N + 5], zero[N + 5];

int head[N + 5], to[E + 5], nxt[E + 5], tot = 1;
void add_edge(int u, int v)
{
	tot++;
	to[tot] = v;
	nxt[tot] = head[u];
	head[u] = tot;
	return ;
}
void add(int u, int v)
{
	add_edge(u, v);
	add_edge(v, u);
	return ;
}

long long d[N + 5];//limit
int sz[N + 5];

void calc_d(int u, long long ans)
{
	long long l = 1, r = n;
	d[u] = -1ll;
	while (l <= r)
	{
		long long mid = (l + r) >> 1;
		__int128 sum = 0, one = 1;

		if (c[u] >= 0)
			sum = one * (ans - mid + 1) * b[u]
				 + one * (mid + ans) * (ans - mid + 1) / 2 * c[u];
		else
		{
			if (mid > zero[u])
				sum = ans - mid + 1;
			else if (ans > zero[u])
				sum = one * (zero[u] - mid + 1) * b[u]
					 + one * (mid + zero[u]) * (zero[u] - mid + 1) / 2 * c[u]
					 + ans - zero[u];
			else
				sum = one * (ans - mid + 1) * b[u]
					 + one * (mid + ans) * (ans - mid + 1) / 2 * c[u];
		}

		if (one * a[u] <= sum)
		{
			d[u] = mid;
			l = mid + 1;
		}
		else
			r = mid - 1;
	}
	return ;
}

int fa[N + 5], in[N + 5];
void dfs(int u, int father)
{
	fa[u] = father;
	in[father]++;
	for (int i = head[u]; i; i = nxt[i])
	{
		int v = to[i];
		if (v == father)
			continue;
		dfs(v, u);
	}
	return ;
}

priority_queue<pir> q;
int seq[N + 5];
bool check(long long ans)
{
	for (int i = 1; i <= n; i++)
	{
		calc_d(i, ans);
		if (d[i] < 0)
			return false;
	}

	dfs(1, 0);
	for (int i = 1; i <= n; i++)
	{
		if (in[i] == 0)
			q.emplace(d[i], i);
	}

	for (int T = n; T > 0; T--)
	{
		int u = q.top().second;
		q.pop();
		seq[T] = u;

		if (fa[u])
		{
			in[fa[u]]--;
			if (in[fa[u]] == 0)
				q.emplace(d[fa[u]], fa[u]);
		}
	}

	for (int i = 1; i <= n; i++)
	{
		if (1ll * i > d[seq[i]])
			return false;
	}
	return true;
}

int main()
{
	// freopen("tree.in", "r", stdin);
	// freopen("tree.out", "w", stdout);

	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%lld%lld%lld", a + i, b + i, c + i);
		if (c[i] < 0)
			zero[i] = (1ll - b[i]) / c[i];
	}
	for (int i = 1, u, v; i < n; i++)
	{
		scanf("%d%d", &u, &v);
		add(u, v);
	}

	long long l = 1, r = Max, ans = 0;
	while (l <= r)
	{
		long long mid = (l + r) >> 1;
		if (check(mid))
		{
			ans = mid;
			r = mid - 1;
		}
		else
			l = mid + 1;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：zifanwang (赞：16)

二分答案（最少天数）。

下面是判断一个天数是否满足条件：

对每个点二分出最晚的种树时间。

$\tt Dfs$ 一遍：对于每个点，遍历完子树后将其的最晚种树时间与 $\text{儿子的最晚种树时间}-1$ 取最小值，得到的就是真实的最晚种树时间。

最后只要对于每个 $i(1\le i\le n)$，最晚种树时间不超过 $i$ 的点的个数 $\le i$ 就可以了，做一遍前缀和即可。**注意，取最小值以后最晚种树时间可能 $\le0$，要特判。求一段时间内的生长高度时需要用 `__int128`，会爆 `long long`。**

时间复杂度 $O(n\log V\log n)$，常数很小。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mxn 100003
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
int n,p[mxn],d[mxn],ct[mxn];
ll a[mxn],b[mxn],c[mxn];
vector<int>g[mxn];
bool v[mxn];
inline __int128 get(ll i,ll n,__int128 a,__int128 b){
    if(a<0){
        ll d=min((b-a-1)/(-a),(__int128)n+1);
        if(d<=i)return n-i+1;
        return n-d+1+(d-i)*b+(d-1+i)*(d-i)/2*a;
    }
    return (n+i)*(n-i+1)/2*a+b*(n-i+1);
}
void dfs(int x,int fa){
	for(int i:g[x])if(i!=fa){
		dfs(i,x);
		p[x]=min(p[x],p[i]-1);
	}
} 
bool check(int mx){
    rep(i,1,n){
        if(a[i]>get(1,mx,c[i],b[i]))return 0;
        int l=1,r=n;
        while(l<r){
            int mid=(l+r+1)>>1;
            if(a[i]<=get(mid,mx,c[i],b[i]))l=mid;
            else r=mid-1;
        }
        if(i==1)l=1;
        p[i]=l;
    }
    dfs(1,0);
    rep(i,1,n)ct[i]=0;
    rep(i,1,n){
    	if(p[i]<1)return 0;
    	ct[p[i]]++;
	}
	rep(i,1,n){
		ct[i]+=ct[i-1];
		if(ct[i]>i)return 0;
	}
    return 1;
}
signed main(){
    scanf("%d",&n);
    rep(i,1,n)scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
    for(int i=1,x,y;i<n;++i){
        scanf("%d%d",&x,&y);
        g[x].pb(y),g[y].pb(x);
    }
    int l=n,r=1e9;
    while(l<r){
        int mid=(l+r)>>1;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    cout<<l;
    return 0;
}
```

---

## 作者：伊地知虹夏 (赞：8)


如果要正常 dp 的话，式子及其复杂，我们考虑二分最优天数 $\alpha$。

那么我们再次使用二分可以在 $\log$ 的复杂度求出第 $u$ 个点最迟要在第 $d_u$ 天种树。

考虑种树的限制：

1. 先种父亲，再种孩子

2. 种这颗树的时间 $f_u \le d_u$

先暂时不看第一个限制，我们考虑第二个怎么解决。

容易想到贪心，对所有点按 $d$ 从小到大排序，然后一颗一颗种。

现在考虑第一个限制，它等价于对于 $u$ 的所有儿子 $v$，都满足 $d_u \le d_v$。

这启示我们将 $d_u$ 的定义修改为它子树内 $d$ 的最小值，然后按深度为第二关键字排序。

容易发现，有解等价于排序后下标的排列是合法的种树序列。

时间复杂度 $\mathcal{O}(n\log^2 V)$ 。

---

## 作者：LengthCheng (赞：7)

# **蒟蒻的第四篇题解**

## [>> P9755 [CSP-S 2023]Plant Trees](https://www.luogu.com.cn/problem/P9755)

### **题目分析**

对于最优性问题，我们通常可以考虑 DP 或者二分，观察题目发现状态过于复杂，而答案在值域上是单调的，所以我们可以考虑二分答案。

不难发现，每当我们二分选定了一个可能的答案（设为 $ limit $），对于每个点，其种树的时间一定会确定一个阈值，在这个点种树的时间不能超过这个阈值，简单来说，就是可以算出在每个点种树的最晚时间。

先考虑如何计算这个阈值，首先，在每个点上树的生长速度都是一个一次函数，则一棵树在一段时间内每天生长的高度是一个等差数列，此时我们可以用等差数列求和公式进行计算（对于一个等差数列 $ a_n $，其每一项之和为 $ \dfrac{(a_1 + a_n) \times n}{2} $），接下来需要分类讨论：

+ 当 $ c \ge 0 $ 时，函数单调不减，则数列单调不减，此时直接利用公式二分计算答案即可。

+ 当 $ c < 0 $ 时，函数单调递减，由于树每天至少长高 $ 1 $ 单位高度，则函数值不能小于 $ 1 $，此时算出函数与直线 $ y = 1 $ 的交点（向下取整），该点之后所有点的函数值均为 $ 1 $，即这一天之后的每一天这棵树都只能长高 $ 1 $ 单位高度，最后讨论一下 $ limit $ 和交点的大小关系用公式计算即可。

在计算过程中，如果有一棵树不能在 $ limit $ 天内长成，则当前答案不合法。 

计算完每个点的阈值后，我们考虑如何选点。不难发现，一个阈值小的点一定要先被选到，所以我们可以贪心的选点，优先选阈值小的点。此时注意到一个性质，一个点能被选到，当且仅当其到 $ 1 $ 号结点的路径上的点都已经被选到了。于是我们按照阈值大小和该选点规则去尝试模拟这个选点的过程，如果在过程中发现一个点被选的时间超出了其阈值，则当前答案不合法。这个选点的过程是 $ \mathcal{O} \left(n\right) $ 的，因为每个点最多被遍历两次。 

这样通过二分得出最后答案的复杂度是 $ \mathcal{O} \left(n \log^{2} K \right) $ 的其中 $ K $ 表示答案的值域大小，$ \log K $ 的上界约为 $ 30 $，可以通过本题（但常数可能会有亿点点大，建议使用较优的输入输出方式）。

### **代码实现**

先建图，并预处理出每个点的 $ father $，然后就可以二分答案计算了。

计算每个点的阈值时注意使用 `__int128`，因为当 $ limit $ 较大时等差数列求和是可能会爆 `long long` 的。

在选点时如果遇到一个已经被选过的点，则这个点一定是合法的，可以直接跳过。因为一个点如果在被遍历到之前就已经被选到了，那说明这个点一定是在前面某个点到根结点的路径上，那么它一定会在一个阈值比它更小的点之前被选到，则如果这个比它阈值小的点是合法的，那么这个点也一定是合法的。

### **code**

```cpp

#include<bits/stdc++.h>
using namespace std;
#define ll __int128
#define int long long
const int N=1e6+10,INF=1e9;
int ver[N*2],nxt[N*2],head[N],idx;
int fa[N];
bool vst[N];
struct Node{
	int a,b,c;
};
Node node[N];
int n;
void add(int x,int y)
{
	ver[++idx]=y;
	nxt[idx]=head[x];
	head[x]=idx;
}
void dfs(int x,int f)
{
	fa[x]=f;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];
		if(y==f)
		{
			continue;
		}
		dfs(y,x);
	}
}
ll calc(int id,ll st,ll ed)
{
    return (ed-st+1)*node[id].c*(ed+st)/2+node[id].b*(ed-st+1);
}
pair<int,int> solve(int limit,int i)
{
	if(node[i].c<0)
	{
		int nodal=(1-node[i].b)/node[i].c;
		if(limit-nodal>=node[i].a)
		{
			return {limit-node[i].a+1,i};
		}
		else
		{
			int l=0,r=nodal+1;
			while(r-l>1)
			{
				int mid=(l+r)/2;
				if(calc(i,mid,min(nodal,limit))>=node[i].a-(limit-nodal>0)*(limit-nodal))
				{
					l=mid;
				}
				else
				{
					r=mid;
				}
			}
			return {l,i};
		}
	}
	else
	{
		int l=0,r=limit+1;
		while(r-l>1)
		{
			int mid=(l+r)/2;
			if(calc(i,mid,limit)>=node[i].a)
			{
				l=mid;
			}
			else
			{
				r=mid;
			}
		}
		return {l,i};
	}
}
bool check(int limit)
{
	vector<pair<int,int>> v;
	for(int i=1;i<=n;++i)
	{
		vst[i]=0;
		auto x=solve(limit,i);
		if(!x.first)
		{
			return 0;
		}
		v.push_back(x);
	}
	sort(v.begin(),v.end());
	int tot=0;
	for(auto i:v)
	{
		int x=i.second;
		if(vst[x])
		{
			continue;
		}
		while(!vst[x] && x)
		{
			vst[x]=1;
			x=fa[x];
			tot++;
		}
		if(tot>i.first)
		{
			return 0;
		}
	}
	return 1;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>node[i].a>>node[i].b>>node[i].c;
	}
	for(int i=1;i<n;++i)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	int l=n-1,r=INF+1;
	while(r-l>1)
	{
		int mid=(l+r)/2;
		if(check(mid))
		{
			r=mid;
		}
		else
		{
			l=mid;
		}
	}
    cout<<r; 
}

```

---

## 作者：cancan123456 (赞：7)

说句闲话：考场的时候只会状压 DP 然后 T 了。

首先我们考虑二分，转化为一个判定问题。

然后考虑对每个点 $u$ 求出最晚种树时间 $r_u$，这个可以再套一个二分或者推式子，按照 $k\ge0$ 与 $k<0$ 分类讨论即可。

那么这时如果我们不考虑祖孙关系的限制那么可以直接贪心，具体地，我们求出 $s_i$ 表示 $r_u\le i$ 的 $u$ 个数，那么对于所有 $i$ 都有 $s_i\le i$ 当且仅当存在可行方案。

> $\Longrightarrow$：我们按照 $r_u$ 从小到大贪心，$s_i\le i$ 保证了我们不会出现来不及种树的情况。

> $\Longleftarrow$：既然我们对于每个点都可以及时种树，那么 $r_u\le i$ 的点一定是 $i$ 时间及之前就被种下了，所以一定有 $s_i\le i$。

现在加入了祖孙关系的限制，注意到我们直接 DFS 整棵树，对每个节点 $u$ 更新 $r_u=\min_{v\text{ 是 }u\text{ 的子节点}}(r_u,r_v)$，然后忽略祖孙关系贪心，那么可以得到正确的结果。

为什么呢？假设我们的方案中 $u,v$ 两个点中 $u$ 是 $v$ 的祖先，并且贪心得到的种树时间 $t_u,t_v$ 满足 $t_u>t_v$，即违反了祖先先种树的限制，那么可以知道 $t_v<t_u\le r_u\le r_v$，那么直接交换 $t_u,t_v$ 显然就可以了。

时间复杂度 $O(n\log^2V)$，但是可以做到 $O(n\log V)$。

代码：

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
const int N = 100005;
struct Edge {
	int v, next;
} edge[2 * N];
int head[N];
int cnt;
void add_edge(int u, int v) {
	cnt++;
	edge[cnt].v = v;
	edge[cnt].next = head[u];
	head[u] = cnt;
}
ll a[N];
int b[N], c[N];
__int128 ddl[N];
__int128 high(int u, __int128 x) {
	if (c[u] >= 0) {
		return b[u] * x + x * (x + 1) / 2 * c[u];
	} else {
		if (x <= ddl[u]) {
			return b[u] * x + x * (x + 1) / 2 * c[u];
		} else {
			return b[u] * ddl[u] + ddl[u] * (ddl[u] + 1) / 2 * c[u] + (x - ddl[u]);
		}
	}
}
bool enough(int u, __int128 x, __int128 target) {
	if (c[u] >= 0) {
		return b[u] * x + x * (x + 1) / 2 * c[u] <= target;
	} else {
		if (x <= ddl[u]) {
			return b[u] * x + x * (x + 1) / 2 * c[u] <= target;
		} else {
			return b[u] * ddl[u] + ddl[u] * (ddl[u] + 1) / 2 * c[u] + (x - ddl[u]) <= target;
		}
	}
}
int max(int a, int b) {
	return a > b ? a : b;
}
int min(int a, int b) {
	return a < b ? a : b;
}
int n, r[N], s[N];
void dfs(int u, int fa) {
	for (int v, i = head[u]; i != 0; i = edge[i].next) {
		v = edge[i].v;
		if (v != fa) {
			dfs(v, u);
			r[u] = min(r[u], r[v]);
		}
	}
}
bool check(int x) {
	if (x < n) {
		return false;
	}
	for (int u = 1; u <= n; u++) {
		__int128 target = high(u, x) - a[u];
		if (target < 0) {
			return false;
		}
		r[u] = 1;
		for (int i = 29; i >= 0; i--) {
			if (r[u] + (1 << i) <= x && enough(u, r[u] + (1 << i) - 1, target)) {
				r[u] += 1 << i;
			}
		}
	}
	dfs(1, 0);
	for (int i = 1; i <= n; i++) {
		s[i] = 0;
	}
	for (int u = 1; u <= n; u++) {
		if (r[u] < 1) {
			return false;
		}
		s[min(r[u], n)]++;
	}
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		sum += s[i];
		if (sum > i) {
			return false;
		}
	}
	return true;
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%lld %d %d", &a[i], &b[i], &c[i]);
		if (c[i] < 0) {
			ddl[i] = (b[i] - 1) / (-c[i]);
		}
	}
	for (int u, v, i = 1; i < n; i++) {
		scanf("%d %d", &u, &v);
		add_edge(u, v);
		add_edge(v, u);
	}
	int ans = 1073741823;
	for (int i = 29; i >= 0; i--) {
		if (check(ans ^ (1 << i))) {
			ans ^= 1 << i;
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：7)

### 说句闲话

这是本人在赛场上除了第一题唯一 AC 的题目，我是废物。

### 题目来源

CSP-S 2023 第四题。

### 分析

两个二分（也可以只用一个）。

首先发现，如果 $x$ 天可以完成任务，那么比 $x$ 天更多一定也可以完成。

所以我们可以二分找到最小可以完成任务的 $x$。

我们继续发现，每棵树种得越早，长得越高，所以可以继续二分一个至少要种得时间，也可以求解一个简单的一元二次不等式。但是这题明显可以接受 $O(n \log n \log w)$ 的复杂度，所以我就又写了一个二分。注意直线斜率为正数，$0$ 和负数应当分开考虑，还有过程可能爆 ```long long```，应当使用 ```__int128```。

而计算函数就是一段直线和一段公差为 $1$ 的等差数列的和，很好计算。

然后这个问题就转化成了每个节点有一个最大访问顺序，其中最大访问顺序大于 $n$ 的视为 $n$，求能否访问按照题目的要求访问每个节点。

首先，可以发现：叶子节点**实际允许的**最大访问顺序就是它本身的最大访问顺序，非叶子节点的**实际允许的**最大访问顺序至少应该是所有儿子的**实际允许的**最大访问顺序减一，否则其儿子无法满足访问顺序的条件。

首先判掉根节点的最大访问顺序小于 $1$ 的情况。

然后，访问一定要可行。即 $\forall x \in [1,n],s_x \le x$，其中 $s_x$ 指**实际允许的**最大访问顺序小于等于 $x$ 的节点个数。容易发现如果满足这个条件，就一定能找到一组合法的访问顺序。

注意外层二分的下界为 $n$，上界为 $10^9$。

### 考场代码（不含文件输入输出）

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &x)
{
	static int c,p;
	c = getchar(),p = 1,x = 0;
	while(c < 48||c > 57)
	{
		if(c == 45) p = -1;
		c = getchar();
	}
	while(48 <= c&&c <= 57)
	{
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
	x *= p;
}
template<typename T>inline void write(T x)
{
	static int c[40],len = 0;
	if(x < 0) putchar(45),x = -x;
	if(!x) putchar(48);
	while(x)
	{
		c[++len] = (x%10)^48;
		x /= 10;
	}
	while(len) putchar(c[len--]);
}
#define F(i,a,b) for(register int i = a;i <= b;++i)
#define D(i,a,b) for(register int i = a;i >= b;--i)
#define ull unsigned long long
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second
#define N 100010
constexpr __int128 I = 1;
int head[N],nxt[N<<1],to[N<<1],cnt = 0;
inline void add(int u,int v)
{
	nxt[++cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
}
int n,d[N],s[N],f[N],dep[N],arr[N],m = 0,top;
ll a[N],b[N],c[N],B,C,lim;
void dfs(int u,int fa)
{
	dep[u] = dep[fa] + 1,f[u] = fa;
	for(register int i = head[u];i;i = nxt[i])
	{
		int v = to[i];
		if(v == fa) continue;
		dfs(v,u);
	}
	arr[++m] = u;
}
inline bool fun(int x)
{
	if(I*C*top+B >= 1) return I*B*(top-x+1) + I*C*(x+top)*(top-x+1)/2 >= lim;
	if(I*C*x+B >= 1) 
	{
		int t = (B-1)/(-C);
		return I*B*(t-x+1) + I*C*(x+t)*(t-x+1)/2+(top-t) >= lim;
	}
	return top-x+1 >= lim;
}
bool check(int x)
{
	F(i,1,n)
	{
		if(!c[i]) 
		{
			d[i] = x - (a[i] - 1) / max(b[i],1ll);
			d[i] = min(d[i],n);
			if(d[i] < dep[i]) return 0;
			continue;
		}
		top = x,B = b[i],C = c[i],lim = a[i];
		if(!fun(dep[i])) return 0;
		if(fun(n)) 
		{
			d[i] = n;
			continue;
		}
		int l = dep[i],r = n,mid;
		while(l <= r)
		{
			mid = (l + r) >> 1;
			if(fun(mid)) l = mid + 1;
			else r = mid - 1;
		} 
		d[i] = r;
	}
	F(i,1,n) 
		if(f[arr[i]])
			d[f[arr[i]]] = min(d[f[arr[i]]],d[arr[i]] - 1);
	if(d[1] < 1) return 0;
	memset(s,0,(n+5)<<2);
	F(i,1,n) ++s[d[i]];
	F(i,1,n) 
	{
		s[i] += s[i-1];
		if(s[i] > i) return 0;
	}
	return 1;
}
int main()
{
	read(n);
	F(i,1,n) read(a[i]),read(b[i]),read(c[i]);
	F(i,1,n-1)
	{
		int u,v;
		read(u),read(v);
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	int l = n,r = 1e9,mid;
	while(l <= r)
	{
		mid = (l + r) >> 1;
		if(check(mid)) r = mid - 1;
		else l = mid + 1;
	}
	write(l);
	return 0;
}
```

---

## 作者：Pekac (赞：3)

[P9755](https://www.luogu.com.cn/problem/P9755)

upd on 2023.11.20：增加细节说明。

刚开始浪费太多时间了，导致赛时没调出来，有点火大。

如果一开始没有头绪的话可以先看一下特殊性质，链是直接贪心。

考虑一下菊花，发现直接贪心是不可做的，但是发现树的高度随时间增大而增大，可以用二分转化为判定性问题解决。

对于任意的树来说，参考菊花，考虑二分出时间，转化为判定性问题。可以通过求根公式或者再套一层二分求出每个点最晚被种树的时间。然后贪心的按照求出的每个点最晚植树的时间 $t$ 排序，从小到大的植树即可，由于每个点最多只会被染色一次，可以直接暴力染色，遇到访问过的终止即可，均摊下来是 $\mathcal{O}(1)$ 的。

这样的话复杂度是 $\mathcal{O}(q\log T\log n)$ 的，$T$ 为最少天数，这里是 $10^9$。但是其实是可以去掉后面的 $\log n$ 的，$t_i$ 是可以 $\mathcal{O}(1)$ 的用求根公式求出，最后的排序可以用桶，因为 $t_i>n$ 的是无所谓的。这样的话就是单 $\log$ 的了。空间线性。

注意有些地方可能会爆 long long。

代码里的二分写法可能和其他的不是很一样。

**$c_i < 0$ 时要注意 $tim$ 和 $mxc$ 的关系**，因为生长的总高度是 $(b + mid\times c)+(b+(mid+1)\times c+\dots+(b + \min(mxc, tim)\times c))+\max(0, tim-mxc)$，即增长速度大于 $1$ 的段不一定能将 $mxc$ 天都取满，其中 $mxc$ 是多少时间过后，增长速度恒为 $1$，$mid$ 和 $tim$ 分别表示从第几天开始长和第几天全部长好。

代码：
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define i128 __int128
#define vi vector<int>
#define eb emplace_back
#define pii pair<int, ll>
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
mt19937_64 rng(35);
constexpr int N = 1e5 + 10;
int n;
int b[N], c[N], fa[N];
ll a[N];
int head[N], cnt_e;
struct edge{
	int v, nxt;
} e[N << 1];
void adde(int u,int v){
	++cnt_e, e[cnt_e].v = v, e[cnt_e].nxt = head[u], head[u] = cnt_e;
}
void dfs(int u, int ff){
	fa[u] = ff;
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].v;
		if(v == ff) continue;
		dfs(v, u);
	}
}
int stk[N], tp, vis[N], id[N];
ll t[N];
i128 calc(int i, int tl, int tr, int mxc) {
	if(mxc < tl) return tr - tl + 1;
	if(mxc > tr) return (tr - tl + 1) * 1ll * b[i] + (tr - tl + 1) * ((i128)(tl + tr)) / 2 * c[i];
	return (mxc - tl + 1) * 1ll * b[i] + (mxc - tl + 1) * ((i128)tl + mxc) / 2 * c[i] + tr - mxc;
}
bool check(int tim){
	for(int i = 1; i <= n; ++i) {
		if(c[i] < 0) {
			int mxc = ((b[i] - 1) / abs(c[i]));
			int l = 1, r = n;
			while(l <= r) {
				int mid = (l + r) >> 1;
				if(calc(i, mid, tim, mxc) >= ((i128)a[i])) l = mid + 1;
				else r = mid - 1;
			}
			t[i] = r;
		} else if(!c[i]) {
			t[i] = tim - (a[i] + b[i] - 1) / b[i] + 1;
		} else {
			int l = 1, r = n;
			while(l <= r) {
				int mid = (l + r) >> 1;
				if(b[i] * 1ll * (tim - mid + 1) + (tim + mid) * ((i128)tim - mid + 1) * c[i] / 2 >= ((i128)a[i]))
					l = mid + 1;
				else r = mid - 1;
			}
			t[i] = r;
		}
		if(t[i] <= 0) return 0;
	}
	for(int i = 1; i <= n; ++i) id[i] = i, vis[i] = 0;
	sort(id + 1, id + n + 1, [](int a, int b) {
		return t[a] < t[b];
	});
	int now = 0; tp = 0; 
	for(int i = 1; i <= n; ++i) {
		int u = id[i];
		for(; !vis[u]; u = fa[u]) vis[stk[++tp] = u] = 1;
		while(tp)
			if(t[stk[tp--]] < ++now)
				return 0;
	}
	return 1;
}
bool Med;
int main(){
	fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; ++i) cin >> a[i] >> b[i] >> c[i];
	for(int i = 1, u, v; i < n; ++i) cin >> u >> v, adde(u, v), adde(v, u);
	dfs(1,0);
	vis[0] = 1;
	int l = n, r = 1e9;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid)) r = mid - 1;
		else l = mid + 1;
	}
	cout << l << "\n";
	cerr << TIME << "ms\n";
	return 0;
}
```

---


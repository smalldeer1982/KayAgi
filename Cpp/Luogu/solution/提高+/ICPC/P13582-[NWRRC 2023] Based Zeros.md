# [NWRRC 2023] Based Zeros

## 题目描述

Barbara 一直以来都知道如何用十进制（以 $10$ 为底）表示整数，使用的数字有 $0, 1, 2, \ldots, 9$。最近她了解到，对于任意整数底数 $b \ge 2$，她也可以用 $b$ 进制表示整数，使用的数字为 $0$ 到 $b-1$。

Barbara 最喜欢的数字是 $0$。幸运的是，在所有进制中，$0$ 的写法都是一样的。

今天，Barbara 正在玩一个正整数 $n$。现在她想知道：在表示 $n$ 的所有进制中，在哪些进制下 $n$ 的表示中包含最多个 $0$？请你帮她找出所有这样的进制。

## 说明/提示

以下是样例测试用例中，$n$ 的表示包含最多 $0$ 的进制：

- $11   = \mathtt{1011}_2     = \mathtt{102}_3    = \mathtt{10}_{11}$（有一个 $0$）；
- $1007 = \mathtt{1101022}_3  = \mathtt{1007}_{10}$（有两个 $0$）；
- $239  = \mathtt{11101111}_2 = \mathtt{1035}_6 = \mathtt{10E}_{15} = \mathtt{10}_{239}$（有一个 $0$）。

在 $239 = \mathtt{10E}_{15}$ 的表示中，$\mathtt{E}$ 代表值为 $14$ 的数字。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
11
1007
239```

### 输出

```
1 3
2 3 11
2 2
3 10
1 4
2 6 15 239```

# 题解

## 作者：UNVRS (赞：1)

## 题意

给定 $n$，找出在哪些进制下 $n$ 具有最多的 $0$，输出最多的 $0$ 的数量与所有进制。多测。

$t\le1000,n\le10^{18}$

## 官方题解翻译

（~~模拟赛没做出来，看完官方题解之后小脑萎缩了，很难想象出题人的精神状态~~）

（以下 **答案** 指 $0$ 的数量，**答案进制** 指符合条件的最大进制，括号非翻译内容）

[官方题解原文](https://nerc.icpc.global/archive/2023/northern/tutorial.pdf)。

根据直觉，答案进制应该很小，二进制下大多数字有很多零，不然三进制下可能有很多零，以此类推，似乎很难有一个在任何进制下零都很少的数。

让我们尝试将这个推理形式化（形式在哪？）。我们可以写一个简单的暴力，枚举 $2\cdots n$ 的所有数作为进制，如果在某个进制下数字的位数不大于之前的答案就直接退出。

这个暴力会 TLE，不妨看看它在哪些 $n$ 上表现不好。我们可以找出所有答案小于等于 $4$ 的 $n$（在 $10^{18}$ 中找吗？有意思），这样的数字只有几百万个。进一步的测试表明在这些 $n$ 中最坏的是 $n=16760831$，它的答案为 $1$，因此暴力必须枚举 $2\cdots n$ 中的所有数。

让我们看看答案进制大于 $2^{12}=4096$ 的数字，这样的数字只有七个，除了前面的 $16760831$，还有 $6143, 14335, 262079, 262111, 524031, 524285$。

对于答案大于等于 $5$ 的 $n$，答案进制不会超过 $4096$，因为 $4096^{5}=2^{60}>10^{18}$。

因此，我们得到一个解法：

- 如果 $n$ 是上述 $7$ 个数字，我们可以在本地提前求解（打表）。

- 否则，答案进制不超过 $4096$，暴力可以在合理的时间内求解。

另外，直接对暴力记忆化也能通过此题（我说删掉这句以外内容有没有懂的），记住输入的所有 $n$ 和对应的解，因为像 $16760831$ 这样糟糕的数远远少于 $1000$ 个。

## 译者补充

关于在 $10^{18}$ 内找数这一步如何缩小搜索范围感觉比整个题有意思，译者正在龟速思考。

---

## 作者：WuMin4 (赞：0)

## 思路

打表题。

观察到当底数 $b> \lceil(10^{18})^{\frac{1}{4}}\rceil=31623$ 时，$b^4> 10^{18}$。因为 $n\le 10^{18}$，所以此时该进制数最多有 $3$ 位，即最多有 $2$ 个 $0$。

于是我们先直接暴力求出 $b\le 31623$ 的最大值，如果答案大于 $2$，则后面怎么选都不会最优，直接输出即可。

若答案为 $2$，则可能出现 $n=(x00)_{b}$ 的情况，但是打表后发现这种情况不可能存在，不用考虑。

若答案为 $1$，我们可以直接打表所有答案为 $1$ 的 $n>31623$，发现满足该条件的 $n$ 只有 $262079,262111,524031,524285,16760831$，直接特判这五种情况即可通过。

打表时可以直接枚举二进制下为 $0$ 的位数再判断 $b\ge 3$ 的答案合法性，这样可以大幅提高打表效率。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int T,ans;
ll n;
vector<int> res;
map<ll,vector<ll>> db;
void db_init(){//262111,262079,524285,524031,16760831
	db[262111].push_back(262111);
	db[262079].push_back(262079);
	db[524285].push_back(104857),db[524285].push_back(524285);
	db[524031].push_back(174677),db[524031].push_back(524031);
	db[16760831].push_back(70129),db[16760831].push_back(882149),db[16760831].push_back(16760831);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	db_init();
	cin>>T;
	while(T--){
		res.clear(),ans=1;
		cin>>n;
		for(int i=2;i<=min(n,31623ll);i++){
			ll x=n;
			int cnt=0;
			while(x){
				if(x%i==0) cnt++;
				x/=i;
			}
			if(cnt>ans) ans=cnt,res.clear(),res.push_back(i);
			else if(cnt==ans) res.push_back(i);
		}
		if(db.count(n))
			for(int v:db[n]) res.push_back(v);
		cout<<ans<<" "<<res.size()<<endl;
		for(int v:res) cout<<v<<" ";
		cout<<endl;
	}
	return 0; 
}
```

---


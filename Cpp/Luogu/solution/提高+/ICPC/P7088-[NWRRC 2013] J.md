# [NWRRC 2013] J

## 题目描述

$J$ 编程语言由 Kenneth E. Iverson 和 Roger Hui 在 1990 年代早期开发，是 APL（也是由 Iverson 开发）与 John Backus 创建的 FP 和 FL 函数级语言的综合体。

Wikipedia. $J$ (编程语言)

APL 语言家族以其对向量和数组的高级操作支持而闻名，$J$ 也不例外。例如，这些语言中的所有一元和二元数值运算默认适用于不同维度的向量和数组。加法运算（‘+’）不仅可以像其他语言一样对标量进行加法运算，还可以对标量和向量进行加法运算（标量加到向量的每个分量上），或者对向量和向量进行加法运算（向量按分量相加）。

$J$ 的表达能力令人惊叹（以及它的神秘语法），但对于这个问题，我们只需要语言的一个小子集。我们考虑一个单一表达式，其中可以使用一个向量变量 $X$，一个标量变量 $N$——向量 $X$ 的长度，以及以下操作：

我们可以对两个向量、向量和标量或两个标量进行加法（‘+’）、减法（‘-’）或乘法（‘\times’）运算。

我们可以对标量和向量（按分量）使用一元负号（‘-’）和一元平方运算（‘\times:’）。

我们可以使用加法折叠向量（‘+/’）——即计算向量的和（一元运算）。

运算从右到左进行评估，$J$ 中忽略运算的自然优先级。可以通过括号改变评估顺序。更准确地说，语法在以下 BNF 中指定。

$\langle expression \rangle ::= \langle term \rangle | \langle term \rangle (‘+’ | ‘-’ | ‘\times’) \langle expression \rangle | (‘-’ | ‘\times:’ | ‘+/’) \langle expression \rangle$

$\langle term \rangle ::= ‘(’\langle expression \rangle‘)’ | ‘X’ | ‘N’ | \langle number \rangle$

$\langle number \rangle ::= (‘0’ | ‘1’ | \ldots | ‘9’)^{+}$

为了正确施加对表达式语法的一个限制，让我们定义表达式的复杂度：

标量（数字，‘N’，以及折叠的结果）的复杂度为零；

‘X’ 的复杂度为一；

加法和减法的复杂度是其操作数复杂度的最大值；

乘法的复杂度是其操作数复杂度的和；

一元平方的复杂度是其操作数复杂度的两倍。

例如，表达式 `(3-+/ \times: \times:X)-X \times \times:X` 的复杂度是 3，而其子表达式 `\times: \times:X` 的复杂度是 4。

你的程序给定一个标量值的表达式和向量 $X$ 的值，它应该计算表达式结果对 $10^{9}$ 取模。给定表达式中每个子表达式的复杂度不超过 10。

## 说明/提示

时间限制：2 秒，内存限制：256 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
5
1 2 3 4 5
+/*:X
```

### 输出

```
55
```

## 样例 #2

### 输入

```
5
1 2 3 4 5
N++/X-X+1
```

### 输出

```
0
```

## 样例 #3

### 输入

```
3
11 56 37
+/(3-+/*:*:X)-X**:X
```

### 输出

```
964602515
```

# 题解

## 作者：stardust_Ray (赞：1)

首先考虑如何存储向量。关注到向量与向量之间的操作是每一维分开的，所以我们存储一个多项式表示每一维上经过操作后与 $X$ 的对应维上的对应关系。三种双目运算和取负、平方都对应多项式上的运算，只有折叠操作特殊。

对于折叠操作，我们预处理每一个幂次 $j$ 的 $\sum\limits_{i=1}^NX_i^j$，然后折叠操作也是可以在多项式次数内完成的。

用多项式存储看起来很错，因为正常情况下会被卡到 $2^N$ 次（全是平方操作）。但是关注到题目中给定了复杂度这一定义，与多项式的次数完全相等。因为复杂度不超过 $10$，所以用多项式存只用存 $10$ 次的系数，暴力乘法即可。

时间复杂度 $O(np^2)$，其中 $p$ 是运算式的复杂度。

代码细节较多，主要在于：

1. 取负这一操作要与减法操作区分开来。
2. 对于单目运算符计算之前要把取负都先算掉。

Code：

```c++
#include<bits/stdc++.h>
#define For(i,j,k) for(int i=(j);i<=(k);++i)
#define ForDown(i,j,k) for(int i=(j);i>=(k);--i)
#define Debug(fmt, args...) fprintf(stderr,"(function %s, line #%d): " fmt,__func__,__LINE__,##args),fflush(stderr)
#define debug(fmt, args...) fprintf(stderr,fmt,##args),fflush(stderr)
#define within :
#define LJY main
using namespace std;
typedef long long ll;
const int N=1e5+5,mod=1e9;
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
inline int read(){
  char ch=getchar();int x=0,f=1;
  while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
  while(ch>='0'&&ch<='9')
    x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
  return x*f;
}
// -----------------template-------------------
int n;ll a[N],p[N],sum[11];
char s[N];int m;

struct Poly{
  ll a[11];
  Poly(){For(i,0,10) a[i]=0;}
  Poly(int x){For(i,1,10) a[i]=0;a[0]=x;}
  ll& operator[](int x){return a[x];}
  ll sum(){ll res=0;For(i,0,10) res=(res+a[i]*::sum[i])%mod;return res;} // 计算折叠的答案
};
int add(int x,int y){x+=y;if(x>=mod) return x-mod;else return x;}
int suc(int x,int y){x-=y;if(x<0) return x+mod;else return x;}
Poly operator+(Poly a,Poly b){For(i,0,10) a[i]=add(a[i],b[i]);return a;}
Poly operator-(Poly a,Poly b){For(i,0,10) a[i]=suc(a[i],b[i]);return a;}
Poly operator*(Poly a,Poly b){Poly c;For(i,0,10) For(j,0,10-i) c[i+j]=(c[i+j]+a[i]*b[j])%mod;return c;}
//---------------少项式-------------------
stack<Poly>val;
stack<char>op;
void flatMinus(){ // 每次运算前把取负给做掉
  while(!op.empty()&&op.top()=='-'){
    auto p=val.top();val.pop();
    val.emplace(Poly()-p);op.pop();
  }
}
void getCalc(){ // 计算 val 的前两项和 op 中的第一项运算后的结果
  char t=op.top();op.pop();
  Poly x=val.top();val.pop();
  Poly y=val.top();val.pop();
  if(t=='+') x=x+y;
  else if(t=='-') x=x-y;
  else if(t=='*') x=x*y;
  else assert(0);
  val.emplace(x);
}
void emplace_op(char x){flatMinus();op.emplace(x);}
void emplace_val(Poly x){
  val.emplace(x);
  if(!op.empty()&&op.top()!=')') getCalc();
}
signed LJY(){
  n=read();For(i,1,n) a[i]=read();
  For(i,1,n) p[i]=1;sum[0]=n;
  For(i,1,10){
    For(j,1,n) p[j]=p[j]*a[j]%mod;
    For(j,1,n) sum[i]=add(sum[i],p[j]); // 预处理幂次和
  }scanf("%s",s+1);m=strlen(s+1);
  Poly X;X[1]=1;op.emplace(')');
  ForDown(i,m,1){
    if(s[i]=='X') emplace_val(X);
    else if(s[i]=='N') emplace_val(n);
    else if(isdigit(s[i])){
      ll sp=0,pw=1;int j=i;
      while(j&&isdigit(s[j])){
        sp=sp+pw*(s[j]-'0');
        j--;pw=pw*10%mod;
      }emplace_val(sp);i=j+1;
    }
    else if(s[i]=='/'){
      flatMinus();Poly x=val.top();val.pop();
      emplace_val(x.sum());i--;
    }else if(s[i]==':'){
      flatMinus();
      Poly x=val.top();val.pop();
      emplace_val(x*x);i--;
    }else if(s[i]==')') op.emplace(')');
    else if(s[i]=='('){ // 去掉一层括号
      flatMinus(),op.pop();
      if(!op.empty()&&op.top()!=')') getCalc();
    }
    else emplace_op(s[i]);
  }flatMinus();printf("%d\n",val.top()[0]);
  return 0;
}
```

---


# [EC Final 2022] Chinese Checker

## 题目描述

棋盘上有 $n$ 个棋子，你需要求对于当前局面，下一次移动有多少种不同的走法。

一次移动由若干步组成。假设当前要移动的棋子为 $a$，在每一步中，首先需要选择另一个棋子 $b$ 作为跳台，然后将 $a$ 走到关于 $b$ 的对称位置（在一次移动中，你无法更改需要移动的棋子 $a$。并且在某一步中，棋子 $a$ 回到此次移动前所在的位置是不被允许的）。

关于跳台 $b$ 的选择有一些条件：

- $a$ 和 $b$ 之间的连线应当平行于棋盘的某条坐标轴。注：棋盘上一共有三条坐标轴，其中一条与水平线平行，并且任意两条坐标轴之间的夹角均为 $\frac{\pi}{3}$。

- $a$ 和 $b$ 不必相邻。

- 除了跳台 $b$ 以外，$a$ 和其关于 $b$ 的对称点的连线上不能有其他棋子。

- 对称点的位置应当落在棋盘上，并且没有被其他棋子占据。

一次移动需要至少走一步。在第一步以后，你可以随时停下来。你可以选择棋盘上任意一个棋子作为移动棋子。请输出有多少种不同的走法。

两种走法不同当且仅当两次移动后所有棋子的位置组成的集合不同，并且棋子之间不可区分。

## 样例 #1

### 输入

```
5
1
1 1
2
1 1
2 1
2
9 4
9 6
10
1 1
2 1
2 2
3 1
3 2
3 3
4 1
4 2
4 3
4 4
10
1 1
2 1
2 2
5 7
3 2
3 3
4 1
4 2
4 3
4 4
```

### 输出

```
0
1
2
6
13
```

# 题解

## 作者：FFTotoro (赞：5)

## 前言

暑假集训的时候 @[_RSY_](https://www.luogu.com.cn/user/46197) 搞的神题，当时读错题目 $100\rightarrow 20$，前两周补完了题，来补个题解。

大部分人这题的代码都写得很抽象，毕竟是阴间模拟题。个人觉得自己的思路和写的代码都相对较为简洁。

## 解法

尝试对于中国跳棋棋盘建立坐标系，本人的方法为将行数作为坐标的第一关键字，所有与蓝色的左上角与最下方那个红色的点的连线平行的线上的点的第二关键字相等，一列一列从左到右第二关键字依次加一（建系方法很多，可以自行画图理解一下），并且令左下角那个粉红色的点的坐标第二关键字为 $1$。

将输入的坐标 $(x,y)$ 转化为这个坐标系下的坐标也是容易的：第一关键字 $x$ 不变，令它所在的那一行的第二关键字最小的为 $l_x$，最大的为 $r_x$，那么 $y\leftarrow y+l_x-1$。后面判断一个点是否在棋盘内也可以使用上面的 $l$ 和 $r$：先判断 $x$ 坐标在不在范围内，如果在再判断 $y$ 是否满足 $l_x\le y\le r_x$。

于是可以走的 $6$ 个方向就可以确定，它们的 $(\Delta x,\Delta y)$ 分别为 $(-1,0),(1,0),(0,-1),(0,1),(-1,1),(1,-1)$。

假设给定了要跳的棋子，考虑怎么处理跳的过程：枚举 $6$ 个方向，再枚举到“跳台”（就是中间那个棋子）的步数，如果该点在棋盘上、正好有一个棋子可以作为“跳台”且中间无阻挡，就再判断目标点的条件（可以类比自行理解）。

到了这一步就不难了，枚举要跳的那个棋子然后爆搜。记得在搜索过程中打标记（不要跳回去）。

可以用 `std::set` 存储棋子位置。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
const int l[18]={0,13,12,11,10,5,5,5,5,5,4,3,2,1,5,5,5,5}, // 左边界
  r[18]={0,13,13,13,13,17,16,15,14,13,13,13,13,13,8,7,6,5}, // 右边界 
  dx[6]={-1,1,0,0,-1,1},dy[6]={0,0,-1,1,1,-1}; // 方向数组
set<pii> m,s;
pair<pii,int> jump(pii a,int d,int s,int c=0){
  while(s--){
    a.first+=dx[d],a.second+=dy[d];
    if(m.find(a)!=m.end())c++; // 数经过的棋子数（判断中间有没有其他棋子）
  }
  return make_pair(a,c);
} // 模拟跳的过程
bool check(pii a){
  auto [x,y]=a;
  return x>0&&x<=17&&y>=l[x]&&y<=r[x];
} // 判断是否在棋盘内
int main(){
  ios::sync_with_stdio(false);
  int t; cin>>t;
  while(t--){
    int n,c=0; cin>>n;
    vector<pii> a(n);
    for(auto &[x,y]:a)cin>>x>>y,y+=l[x]-1;
    m.clear(); for(pii i:a)m.emplace(i);
    function<void(int)> dfs=[&](int i){
      s.emplace(a[i]); // 打标记
      for(int j=0;j<6;j++)
        for(int k=1;k<=6;k++)
          if(auto [p,c1]=jump(a[i],j,k);c1==1&&check(p)&&m.find(p)!=m.end())
          // 跳台的条件
            if(auto [e,c2]=jump(p,j,k);!c2&&check(e)&&m.find(e)==m.end()){ 
            // 目标点的条件
              pii t=a[i];
              m.erase(a[i]),m.emplace(a[i]=e);
              if(s.find(a[i])==s.end())dfs(i); 
              // 满足条件继续搜
              m.erase(e),m.emplace(a[i]=t);
            }
    };
    for(int i=0;i<n;i++,s.clear())
      dfs(i),c+=s.size()-1; // 枚举每一个点，统计答案
    cout<<c<<endl;
  }
  return 0;
}
```

---

## 作者：LHLeisus (赞：1)

[恶劣的阅读体验](https://www.cnblogs.com/LHLeisus/p/17832710.html)

[原题链接](https://www.luogu.com.cn/problem/P9723)

模拟赛出了，赛时被这个六芒星的形状吓住了，感觉被降智了，呜呜。

其实只要转化一下就可以愉快地爆搜了。

![](https://img.zshfoj.com/385c68020440d306ab93bca3a4b88c817a17a75d0dc5fc2dddc4bd1a796f1bd9.png)

可以将这两条线看做坐标轴，然后把整个六芒星的的形状转化成横平竖直的样子，大概长这样（$1$ 表示是棋盘）：


```
0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
```

于是就有了以下的初始化代码：


```cpp
void init(){
	FOR(i,5,5) ib[1][i]=1;FOR(i,5,6) ib[2][i]=1;FOR(i,5,7) ib[3][i]=1;FOR(i,5,8) ib[4][i]=1;
	FOR(i,1,13) ib[5][i]=1;FOR(i,2,13) ib[6][i]=1;FOR(i,3,13) ib[7][i]=1;FOR(i,4,13) ib[8][i]=1;FOR(i,5,13) ib[9][i]=1;
	FOR(i,5,14) ib[10][i]=1;FOR(i,5,15) ib[11][i]=1;FOR(i,5,16) ib[12][i]=1;FOR(i,5,17) ib[13][i]=1;
	FOR(i,10,13) ib[14][i]=1;FOR(i,11,13) ib[15][i]=1;FOR(i,12,13) ib[16][i]=1;FOR(i,13,13) ib[17][i]=1;
}
```

~~极致的压行（）~~

然后题目要求只能沿着对角线跳，而三条对角线分别被转化成了行、列和左上到右下的对角线。只需要枚举每个棋子，分别沿着三条对角线爆搜就好了，该剪枝就剪，根本跑不满，时间复杂度不是很会算，反正可以 AC（）。

搜索的时候要注意一些细节，包括但不限于：

- 沿着对角线搜到第一个棋子后就要返回，因为当前位置和跳过去的位置中间只允许存在一个棋子，就是那个跳板。

- 中间走过的位置及时标记，不能重复走，可能会死循环。并且最终结果不同只与最终状态有关系，所以假如通过不同的方式能够到达同一个点，这个点只会对答案造成一次贡献。

- 起点的棋子也要打上标记，不然有可能跳了一圈回来，从这个点跳走了，但这个棋子已经没了，不能跳。

- 输入的时候也要注意，输入的是在棋盘上的位置，要转化成在整个矩阵里的位置。

其实以上是我踩过的坑，不过大概实现方法不同坑也不一样？所以说坑还得自己踩（逃）


[代码仅供参考](https://www.cnblogs.com/LHLeisus/p/17832710.html#%E4%BB%A3%E7%A0%81%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83)

---


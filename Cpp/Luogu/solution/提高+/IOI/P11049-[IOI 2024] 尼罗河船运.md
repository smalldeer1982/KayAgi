# [IOI 2024] 尼罗河船运

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)

## 题目描述

你想通过尼罗河来运输 $N$ 件手工艺品。这些手工艺品从 $0$ 到 $N-1$ 编号。第 $i$（$0 \leq i < N$）件手工艺品的重量是 $W[i]$。



为了运输这些手工艺品，你使用了特制的船。每艘船**最多**可以运**两件**手工艺品。


* 如果你决定将单件手工艺品放在一艘船上，那么这件手工艺品的重量可以是任意的。
* 如果你想把两件手工艺品一起放在同一艘船上，你必须保证这艘船的平衡。具体来说，如果手工艺品 $p$ 和 $q$（$0 \leq p < q < N$）的重量差的绝对值不超过 $D$，即满足 $|W[p] - W[q]| \leq D$，那么你可以将它们一起放在同一艘船上。



你必须付费来运一件手工艺品，其运费取决于同一艘船上所运载的手工艺品数量。手工艺品 $i$（$0 \leq i < N$）的运费是：

* $A[i]$，如果你把手工艺品 $i$ 单独放在船上，或者
* $B[i]$，如果你把手工艺品 $i$ 和另一件手工艺品一起放在船上。


注意在第二种情况中，你要为船上两件手工艺品都支付运费。具体来说，如果你决定用同一艘船运输手工艺品 $p$ 和 $q$（$0 \leq p < q < N$），你需要支付 $B[p] + B[q]$。



一件手工艺品单独用一艘船运输的费用，总是比与其他手工艺品合用一艘船时的费用要高，所以对任意满足 $0 \leq i < N$ 的 $i$，都有 $B[i] < A[i]$。


麻烦的是，由于尼罗河变化莫测，导致 $D$ 的值经常改变。你的任务是回答 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。这些问题用一个长度为 $Q$ 的数组 $E$ 来描述。问题 $j$（$0 \leq j < Q$）的答案，是在 $D$ 的值等于 $E[j]$ 时运输所有 $N$ 件手工艺品的最小总代价。

## 说明/提示

## 实现细节


你需要实现以下函数。

```
std::vector<long long> calculate_costs(
    std::vector<int> W, std::vector<int> A, 
    std::vector<int> B, std::vector<int> E)
```

* $W$，$A$，$B$：长度均为 $N$ 的整数数组，分别给出手工艺品的重量和运费。
* $E$：长度为 $Q$ 的整数数组，给出每个问题中的 $D$ 值。
* 该函数应该返回一个包含 $Q$ 个整数的数组 $R$，给出运输手工艺品的最小总代价，其中 $R[j]$ 对应 $D$ 等于 $E[j]$（对每个满足 $0 \leq j < Q$ 的 $j$）时的运费。
* 对于每个测试用例，该函数恰好被调用一次。


## 约束条件

* $1 \leq N \leq 100\,000$。
* $1 \leq Q \leq 100\,000$。
* 对每个满足 $0 \leq i < N$ 的 $i$，都有 $1 \leq W[i] \leq 10^{9}$。
* 对每个满足 $0 \leq i < N$ 的 $i$，都有 $1 \leq B[i] < A[i] \leq 10^{9}$。
* 对每个满足 $0 \leq j < Q$ 的 $j$，都有 $1 \leq E[j] \leq 10^{9}$。


## 子任务

| 子任务 | 分数 | 额外的约束条件                                               |
| :----: | :--: | ------------------------------------------------------------ |
|   1    | $6$  | $Q \leq 5$；$N \leq 2000$；对每个满足 $0 \leq i < N$ 的 $i$，都有 $W[i] = 1$ |
|   2    | $13$ | $Q \leq 5$；对每个满足  $0 \leq i < N$ 的 $i$，都有 $W[i] = i+1$ |
|   3    | $17$ | $Q \leq 5$；对每个满足  $0 \leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |
|   4    | $11$ | $Q \leq 5$；$N \leq 2000$                                    |
|   5    | $20$ | $Q \leq 5$                                                   |
|   6    | $15$ | 对每个满足 $0 \leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |
|   7    | $18$ | 没有额外的约束条件。                                         |


## 例子


考虑以下调用。

```
calculate_costs([15, 12, 2, 10, 21],
                [5, 4, 5, 6, 3],
                [1, 2, 2, 3, 2],
                [5, 9, 1])
```


在该例子中，我们有 $N=5$ 件手工艺品和 $Q=3$ 个问题。



在第一个问题中，$D = 5$。你可以把手工艺品 $0$ 和手工艺品 $3$ 放在同一艘船上（因为 $|15 - 10| \leq 5$），而其他手工艺品都各自放在不同的船上。这使得运输所有手工艺品的总代价最小，即 $1+4+5+3+3 = 16$。


在第二个问题中，$D = 9$。你可以把手工艺品 $0$ 和手工艺品 $1$ 放在同一艘船上（因为 $|15 - 12| \leq 9$），而把手工艺品 $2$ 和手工艺品 $3$ 放在同一艘船上（因为 $|2 - 10| \leq 9$）。剩下的手工艺品单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $1+2+2+3+3 = 11$。


在最后一个问题中，$D = 1$。你需要把每件手工艺品都单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $5+4+5+6+3 = 23$。

因此，该函数应该返回 $[16, 11, 23]$。

## 样例 #1

### 输入

```
5
15 5 1
12 4 2
2 5 2
10 6 3
21 3 2
3
5
9
1
```

### 输出

```
16
11
23
```

# 题解

## 作者：uuku (赞：17)

先考虑对于单组询问如何做。由于 $b_i<a_i$ 恒成立，所以能配对就配对显然更优，如果我们按 $w_i$ 排序，那么根据间隔与 $D$ 的大小可以将整个序列分为若干段表示段内相邻的两个物品能同船。

如果段的长度是偶数，那么肯定能两两配对全部用 $b_i$，如果长度是奇数那么就要考虑让其中奇数个物品单独过河，讨论一下不难发现肯定是让一个物品单独过。那么我们就要求出所有可以单独过（不影响其他物品两两配对）的物品增量 $a_i-b_i$ 最小是多少。

不影响其他物品那就有两种情况：

1. 位置与左端点奇偶性相同，那么左右的长度仍为偶数可以配对。
2. 前一个和后一个的差也满足 $D$ 的限制，那么除去该物品整个段仍是连通的，那么就可以配对。

所以我们只需 $O(n)$ 扫一遍就可以得到单次询问的答案。

下面考虑多组询问，重新探究分段的过程，当 $D$ 足够大之后，整个序列都将是一段，那么就研究单个/一段物品合并的过程，发现每个间隔都会连接两段，那么我们只需把询问离线排序，再把间隔长度排序，依次加入并修改即可。

在合并段的同时维护上述两种可删点的信息，由于只需最小值直接取 $\min$ 即可。第一种按前后两个物品重量差排序一起修改。第二种考虑按奇偶位置处理最小值，然后区间直接合并，用并查集等维护即可。

复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+10;
int fa[N],mn[N],mn2[N][2],sz[N],n,q,tot;
struct node{
	int w,a,b;
}p[N],ask[N],dlt[N<<1];
bool cmp(node a,node b){return a.w==b.w?a.b>b.b:a.w<b.w;}
ll res;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void add(int p1,int p2)
{
	if(p2==0)
	{
		int f=find(p1);
		if(sz[f]&1)res-=min(mn[f],mn2[f][f&1]);
		mn[f]=min(mn[f],p[p1].a-p[p1].b);
		if(sz[f]&1)res+=min(mn[f],mn2[f][f&1]);
	}
	else
	{
		int f1=find(p1),f2=find(p2);
		if(sz[f1]&1)res-=min(mn[f1],mn2[f1][f1&1]);
		if(sz[f2]&1)res-=min(mn[f2],mn2[f2][f2&1]);
		fa[f2]=f1;
		sz[f1]+=sz[f2];
		mn[f1]=min(mn[f1],mn[f2]);
		mn2[f1][0]=min(mn2[f1][0],mn2[f2][0]);
		mn2[f1][1]=min(mn2[f1][1],mn2[f2][1]);
		if(sz[f1]&1)res+=min(mn[f1],mn2[f1][f1&1]);
	}
	return;
}
std::vector<long long> calculate_costs( std::vector<int> W, std::vector<int> A, std::vector<int> B, std::vector<int> E)
{
	n=W.size();
	vector<ll>ans;
 	for(int i=1;i<=n;i++)p[i]={W[i-1],A[i-1],B[i-1]};
 	sort(p+1,p+n+1,cmp);
 	q=E.size();
 	for(int i=0;i<q;i++) ask[i+1]={E[i],i};
 	sort(ask+1,ask+q+1,cmp);
 	ans.resize(q);
 	for(int i=2;i<=n;i++) dlt[++tot]={p[i].w-p[i-1].w,i-1,i};
	for(int i=2;i<n;i++) dlt[++tot]={p[i+1].w-p[i-1].w,i,0};
	sort(dlt+1,dlt+tot+1,cmp);
	for(int i=1;i<=n+1;i++)
	{
		fa[i]=i;
		mn[i]=1e9;
		mn2[i][i&1]=p[i].a-p[i].b;
		mn2[i][(i&1)^1]=1e9;
		sz[i]=1;
	}
	for(int i=1;i<=n;i++) res+=p[i].a;
	for(int i=1,p=0;i<=q;i++)
	{
		while(p<tot&&dlt[p+1].w<=ask[i].w)
			p++, add(dlt[p].a,dlt[p].b);
		ans[ask[i].a]=res;
	}
 	return ans;
}
```

---

## 作者：_Day_Tao_ (赞：6)

不难发现一个性质：在按照 $w$ 排序时，最优情况下两两匹配的物品中间是可以做到全都取 $a_i$ 的。假如说不这样，即匹配的两对物品有交，可以让这两对中的两个右端点匹配，两个左端点匹配，这样显然是合法的。所以我们可以得出一个朴素 DP，跟一篇题解的形式差不多，设 $f_{i,0/1}$ 表示第 $i$ 件物品是否跟前面的匹配，记录前 $i$ 件物品的最小花费。那么转移柿子就是：

$$f_{i,0}=\min\{f_{i-1,0},f_{i-1,1}\}+a_i$$
$$f_{i,1}=\min\limits_{j<i,w_j-w_i\le D}\{f_{j,0}+\sum_{k=j+1}^{i-1}a_k-a_j+b_j+b_i\}$$

其中第二个柿子中的 $\sum\limits_{k=j+1}^{i-1}a_k$ 可以用前缀和记录。然后我们发现，第二个转移可以可以单调队列优化，所以我们可以得到这份代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pll pair<long long,long long>
#define fi first
#define se second
const long long MAX = 2e5 + 5;
const long long mod = 998244353;
const long long INF = 0x3f3f3f3f3f3f3f;
struct Day_Tao
{
	long long w,a,b;
	inline bool operator<(const Day_Tao&dt) const {return w<dt.w;}
}t[MAX];
long long f[MAX][2],s[MAX];
deque<pll>q;
std::vector<long long> calculate_costs(std::vector<signed>W,std::vector<signed>A,std::vector<signed>B,std::vector<signed>E)
{
  	std::vector<int>R;
	int n=(int)W.size();
	for(int i=1;i<=n;i++) t[i]={1ll*W[i-1],1ll*A[i-1],1ll*B[i-1]};
	sort(t+1,t+n+1);
	for(int i=1;i<=n;i++) s[i]=s[i-1]+t[i].a;
	for(int d:E)
	{
		while(!q.empty()) q.pop_back();
		for(int i=1;i<=n;i++) f[i][0]=f[i][1]=INF;
		f[1][0]=t[1].a;
		q.push_back({f[1][0]-s[1]-t[1].a+t[1].b,t[1].w});
		for(int i=2;i<=n;i++)
		{
			f[i][0]=min(f[i-1][0],f[i-1][1])+t[i].a;
			while(!q.empty()&&t[i].w-q.front().se>d) q.pop_front();
			if(!q.empty()&&t[i].w-q.front().se<=d) f[i][1]=q.front().fi+s[i-1]+t[i].b;
			while(!q.empty()&&f[i][0]-s[i]-t[i].a+t[i].b<q.back().fi) q.pop_back();
			q.push_back({f[i][0]-s[i]-t[i].a+t[i].b,t[i].w});
		}
		R.push_back(min(f[n][0],f[n][1]));
	}
	return R;
}
//signed main()
//{
//	vector<int>ans=calculate_costs({15, 12, 2, 10, 21},
//                {5, 4, 5, 6, 3},
//                {1, 2, 2, 3, 2},
//                {5, 9, 1});
//    for(auto res:ans) printf("%lld\n",res);
//}
```

时间复杂度 $O(QN)$，期望得分 67 pts。

到这里我就没什么思路了，经过机房神仙指点，发现了一个性质：**每个** $f_i$ **只会与合法的最多前两个配对**。设 $x,y,z,x>y>z$ 是 $i$ 前最靠近 $i$ 的合法的三个位置。$i$ 和 $z$ 匹配，$x$ 和 $y$ 匹配与 $i$ 和 $x$ 匹配，$y$ 和 $z$ 匹配时等价的。所以前面所说的配对方式已经包含了所有的情况。设 $f_{i}$ 表示前 $i$ 种合法情况的总方案数，这时的状态转移就是（合法情况下）：

$$f_i=\min\{f_{i-1}+a_{i},f_{i-2}+b_{i}+b_{i-1},f_{i-3}+b_i+b_{i-2}+a_{i-1}\}$$

然后考虑如何使用这个性质。我们发现随着 $D$ 的增大，限制是越来越宽的，会有越来越多的不合法情况变成合法情况。而且对于 $f_{i-1}$ 到 $f_i$ 的转移，最多只会修改两次。而对于找到哪些情况会变为合法，可以另外开一个数组，记录所有 $w_i-w_{i-1}$ 与 $w_i-w_{i-2}$ 及其对应的 $i$，并按照 $w$ 之差从小到大排序，将询问 $D$ 离线下来从小到大做。至于怎么改变状态的转移并快速计算出 $f_n$，这时候就要用到 DDP 了。DDP 就是用线段树维护每次转移的矩阵，即维护区间 $[i,i]$ 的节点记录从 $f_{i-1}$ 到 $f_{i}$ 的转移，然后查询状态。考虑矩阵的设计。由于每个 $f_i$ 只与 $f_{i-1},f_{i-2},f_{i-3}$ 有关，所以就要设计一个三维的矩阵。转移并不是直接的矩乘，是一个 $(\min,+)$ 的广义矩乘。对于三种情况的矩阵转移，分别为：

$$\begin{bmatrix}a_i & +\infty & +\infty\\0 & +\infty & +\infty\\a_i & 0 & +\infty\\\end{bmatrix}\begin{bmatrix}f_{i-1}\\f_{i-2}\\f_{i-3}\end{bmatrix}=\begin{bmatrix}f_{i}\\f_{i-1}\\f_{i-2}\end{bmatrix}$$

$$\begin{bmatrix}a_i & b_i+b_{i-1} & +\infty\\0 & +\infty & +\infty\\a_i & 0 & +\infty\\\end{bmatrix}\begin{bmatrix}f_{i-1}\\f_{i-2}\\f_{i-3}\end{bmatrix}=\begin{bmatrix}f_{i}\\f_{i-1}\\f_{i-2}\end{bmatrix}$$

$$\begin{bmatrix}a_i & b_i+b_{i-1} & b_i+b_{i-2}+a_{i-1}\\0 & +\infty & +\infty\\a_i & 0 & +\infty\\\end{bmatrix}\begin{bmatrix}f_{i-1}\\f_{i-2}\\f_{i-3}\end{bmatrix}=\begin{bmatrix}f_{i}\\f_{i-1}\\f_{i-2}\end{bmatrix}$$

注意到矩阵中要维护到 $f_{i-3}$，所以说在线段树中我们不再维护 $[1,1]$ 的转移，直接维护 $[2,n]$ 的转移。对于线段树维护 $[2,2]$ 的节点我们特殊考虑，作为初始矩阵，每次更新。

然后直接每次对于一个询问，更新对于当前的 $D$ 从不合法变为合法的转移，最后答案就是线段树的根节点。

（本蒟蒻第一次写 DDP，写的有些问题/不好看请见谅喵）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ull unsigned int
#define pii pair<int,int>
#define ls (root << 1)
#define rs (root << 1 | 1)
#define mid ((l + r) >> 1)
#define fi first
#define se second
#define SIZE(a) ((int)a.size())
#define END(a) (prev(a.end()))
const int MAX = 1e5 + 5;
const int mod = 998244353;
const int INF = 0x3f3f3f3f3f3f3f3f;
struct Day_Tao
{
	int w,a,b;
	inline bool operator<(const Day_Tao&dt) const {return w<dt.w;}
}t[MAX];
int f1,f2;
struct matrix
{
	int a[4][4];
	inline void init() {for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) a[i][j]=INF;}
	inline matrix operator*(const matrix&c) const
	{
		matrix res;res.init();
		for(int i=1;i<=3;i++)for(int j=1;j<=3;j++)for(int k=1;k<=3;k++)
		res.a[i][j]=min(res.a[i][j],a[i][k]+c.a[k][j]); // (min,+) 矩阵 
		return res;
	}
}tree[MAX<<2],C;
inline void push_up(int root) {return tree[root]=tree[rs]*tree[ls],void();} // 因为矩阵是左乘，所以要右子树 * 左子树 
void build(int l,int r,int root)
{
	if(l==r){tree[root]=C,tree[root].a[1][1]=t[l].a,tree[root].a[2][1]=tree[root].a[3][2]=0;return ;} // 矩阵的初始化，这种矩阵一定合法
	build(l,mid,ls),build(mid+1,r,rs);if(l==1&&r==2)tree[root]=tree[rs];else push_up(root);return ; // 这里就不再考虑 [1,1] 的矩阵了
}
void update(int l,int r,int root,int p,int op)
{
	if(r<p||l>p) return ;
	if(l==r&&l==p) // 更新矩阵
	{
		if(l==2) tree[root].a[1][1]=f2,tree[root].a[2][1]=f1,tree[root].a[3][1]=0;
		else
		{
			if(op==1) tree[root].a[1][2]=t[l].b+t[l-1].b;
			if(op==2) tree[root].a[1][3]=t[l].b+t[l-2].b+t[l-1].a;
		}
		return ;
	}
	update(l,mid,ls,p,op),update(mid+1,r,rs,p,op);if(l==1&&r==2)tree[root]=tree[rs];else push_up(root);return ;
}
vector<int> calculate_costs(vector<signed>W,vector<signed>A,vector<signed>B,vector<signed>E) // 这里的类型要严格跟题面给出的一致 
{
	vector<int>R(SIZE(E));vector<pii>D,v1,v2;
	for(int i=0;i<E.size();i++) D.push_back({E[i],i});
	int n=SIZE(W);
	for(int i=1;i<=n;i++) t[i]={1ll*W[i-1],1ll*A[i-1],1ll*B[i-1]};
	sort(t+1,t+n+1),sort(D.begin(),D.end()),C.init();
	for(int i=2;i<=n;i++) v1.push_back({t[i].w-t[i-1].w,i}); // 记录以后要修改的点
	for(int i=3;i<=n;i++) v2.push_back({t[i].w-t[i-2].w,i});
	sort(v1.begin(),v1.end()),sort(v2.begin(),v2.end()),build(1,n,1);
	int i=0,j=0;
	for(pii d:D)
	{
		f1=t[1].a;
		if(t[2].w-t[1].w<=d.fi) f2=t[1].b+t[2].b;else f2=t[1].a+t[2].a;
		update(1,n,1,2,114514); // 先处理初始矩阵
		while(i<n-1&&v1[i].fi<=d.fi) update(1,n,1,v1[i].se,1),++i;
		while(j<n-1&&v2[j].fi<=d.fi) update(1,n,1,v2[j].se,2),++j;
		R[d.se]=tree[1].a[1][1];
	}
	return R;
}
//signed main()
//{
//	vector<int>ans=calculate_costs({15, 12, 2, 10, 21},
//                {5, 4, 5, 6, 3},
//                {1, 2, 2, 3, 2},
//                {5, 9, 1});
//    for(auto res:ans) printf("%lld\n",res);
//}
```

---

## 作者：Eternatis (赞：5)

本文中称两个物品装在一艘船上为**匹配**。

### 67 pts

考虑一次询问怎么做。

把所有物品按重量排序，只考虑后面的物品匹配前面的物品，即可避免后效性，设 $f_i$ 为考虑前 $i$ 个物品的最小代价和，转移时暴力枚举与 $i$ 匹配的物品，复杂度 $O(n^2)$。

注意到最优策略下，最后一定不存在两个未匹配过的物品可以匹配，考虑上述转移过程，若 $i$ 可以和 $i-3$ 匹配，则令 $i$ 和 $i-1$ 匹配，$i-2$ 和 $i-3$ 匹配一定更优，于是只需要考虑每个物品和其前两个物品匹配即可，转移复杂度 $O(1)$，单次询问复杂度 $O(n)$。

---

### 100 pts

注意到询问一次性给出，这启发了我们可以离线回答询问。

考虑 ddp，把转移写成矩乘的形式并用线段树维护，把询问从小到大排序，每个位置只会在其可以和 前一个/前两个 位置匹配时修改，于是总修改次数为 $O(n)$ 量级，总复杂度 $O(n\log n\cdot k^3)$，其中 $k=3$ 为矩阵大小。

---

## 作者：MutU (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11049)

刚看到这题的时候还是紫，过了二十分钟[降蓝了](https://www.luogu.com.cn/ticket/GCXT331118)。

考虑 $O(nq)$ 做法。我们把所有货物按照 $w$ 排序，令 $f_i$ 为前 $i$ 个全部运走所需的最小代价。

注意到一个性质：如果把所有两两配对的货物视为一条线段，在最优情况下这些线段一定能够不相交。假设两两有相交，将四个点中左边两个和右边两个连一起显然合法且等价。

注意到另一个性质：如果把所有两两配对的货物视为一条线段，在最优情况下这些线段长度不会超过 $3$。也就是说一个货物最多只需要考虑前两个货物。假设与前面第三个货物配对，将这个点以及前三个点左边两个连一起显然合法且等价。

于是递推式:

$f_i = \begin{cases}
  f_{i-1}+a_i & w_i-w_{i-1}>d \\
  \min(f_{i-1}+a_i,f_{i-2}+b_{i-1}+b_i) & w_i-w_{i-1}\le d\\
  \min(f_{i-1}+a_i,f_{i-2}+b_{i-1}+b_i,f_{i-3}+b_{i-2}+a_{i-1}+b_i) & w_i-w_{i-2}\le d \\
\end{cases}$

考虑优化。注意到询问可以离线出来，按照 $d$ 排序。

这样转移的限制越来越宽，每个位置的转移式子也会变化。但是这些变化的总数是 $O(n)$ 级别的。

考虑维护每个式子变化的时间。把每个 $i$ 分别按照 $w_i-w_{i-1}$ 和 $w_i-w_{i-2}$ 从小到大排序，能够快速求出对于某个询问哪些式子会改变。

我们把转移抽象成广义矩阵乘法。其中把乘法操作变为加法，加法操作变为取 $\min$。即：


```cpp
matrix operator * (matrix a,matrix b){
    matrix ans;
    ans.init1(3,3);
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            for(int k=0;k<3;k++){
                ans.a[i][j]=min(ans.a[i][j],a.a[i][k]+b.a[k][j]);
            }
        }
    }
    return ans;
}
```

因为需要考虑前两个位置，矩阵边长为 $3$。

三个转移对应的矩阵乘分别为：


$\begin{bmatrix} a_i & +\infty & +\infty \\ 0 & +\infty & +\infty \\ +\infty & 0 & +\infty \end{bmatrix} \begin{bmatrix} f_{i-1} \\ f_{i-2} \\ f_{i-3} \end{bmatrix} = \begin{bmatrix} f_i \\ f_{i-1} \\ f_{i-2} \end{bmatrix}$

$\begin{bmatrix} a_i & b_i+b_{i-1} & +\infty \\ 0 & +\infty & +\infty \\ +\infty & 0 & +\infty \end{bmatrix} \begin{bmatrix} f_{i-1} \\ f_{i-2} \\ f_{i-3} \end{bmatrix} = \begin{bmatrix} f_i \\ f_{i-1} \\ f_{i-2} \end{bmatrix}$

$\begin{bmatrix} a_i & b_i+b_{i-1} & b_i+a_{i-1}+b_{i-2} \\ 0 & +\infty & +\infty \\ +\infty & 0 & +\infty \end{bmatrix} \begin{bmatrix} f_{i-1} \\ f_{i-2} \\ f_{i-3} \end{bmatrix} = \begin{bmatrix} f_i \\ f_{i-1} \\ f_{i-2} \end{bmatrix}$

能够证明这种运算具有结合率。

线段树维护每个式子，单点修改 $O(n)$ 次，复杂度 $O(n \log n)$。最后根节点就是答案。

细节见代码部分。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 100100;
struct matrix{
    int n,m;
    long long a[3][3];
    inline void init0(int x,int y){
        n=x,m=y;
        for(int i=0;i<n;i++) for(int j=0;j<m;j++) a[i][j]=0;
        return;
    }
    inline void init1(int x,int y){
        n=x,m=y;
        for(int i=0;i<n;i++) for(int j=0;j<m;j++){
            a[i][j]=1e18;
        }
        return;
    }
    inline void print(){
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++) cout<<a[i][j]<<' ';
            cout<<'\n';
        }
    }
};
matrix operator * (matrix a,matrix b){
    matrix ans;
    ans.init1(3,3);
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            for(int k=0;k<3;k++){
                ans.a[i][j]=min(ans.a[i][j],a.a[i][k]+b.a[k][j]);
            }
        }
    }
    return ans;
}
struct node{
    int w,a,b;
}p[N];
struct ask{
    int id,d;
}e[N];
int ans[N];
int n,q;
vector <long long> res;
long long w[N],a[N],b[N];
bool cmp(ask a,ask b){
    return a.d<b.d;
}
matrix tree[N*4];
inline void push_up(int x){
    tree[x]=tree[x*2+1]*tree[x*2];
}
int f1,f2;
inline void build(int l,int r,int x){
    if(l==r){
        tree[x].init1(3,3);
        tree[x].a[0][0]=a[l];
        tree[x].a[1][0]=0;
        tree[x].a[2][1]=0;
        return;
    }
    int mid=l+r>>1;
    build(l,mid,x*2);
    build(mid+1,r,x*2+1);
    push_up(x);
    return;
}
matrix d;
inline void updata(int l,int r,int id,int x){
    if(l>id || r<id) return;
    if(l>=id && r<=id){
        if(l==2){
            tree[x].a[0][0]=f2;
            tree[x].a[1][0]=f1;
            tree[x].a[2][0]=0;
            return;
        }
        tree[x]=d; 
        return;
    }
    int mid=l+r>>1;
    if(mid>=id) updata(l,mid,id,x*2);
    if(mid+1<=id) updata(mid+1,r,id,x*2+1);
    if(l==1 && r==2) tree[x]=tree[x*2+1]; else push_up(x);
    return;
}
bool cmp0(node a,node b){
    return a.w<b.w;
}
vector <pair <int,int> > v1,v2;
std::vector<long long> calculate_costs(
std::vector<signed> W, std::vector<signed> A, 
std::vector<signed> B, std::vector<signed> E){
    n=W.size(),q=E.size();
    for(int i=1;i<=n;i++) p[i].a=A[i-1],p[i].b=B[i-1],p[i].w=W[i-1];
    sort(p+1,p+1+n,cmp0);
    for(int i=2;i<=n;i++) v1.push_back({p[i].w-p[i-1].w,i});
    for(int i=3;i<=n;i++) v2.push_back({p[i].w-p[i-2].w,i});
    for(int i=1;i<=n;i++) a[i]=p[i].a,b[i]=p[i].b,w[i]=p[i].w;
    for(int i=1;i<=q;i++) e[i].d=E[i-1],e[i].id=i;
    sort(e+1,e+1+q,cmp);
    sort(v1.begin(),v1.end()),sort(v2.begin(),v2.end());
    build(1,n,1);
    int x=0,y=0;
    for(int i=1;i<=q;i++){
        f1=a[1];
        if(w[2]-w[1]<=e[i].d) f2=b[1]+b[2];
        else f2=a[1]+a[2];
        updata(1,n,2,1);
        d.init1(3,3);
        d.a[1][0]=0;
        d.a[2][1]=0;
        while(x<n-1 && v1[x].first<=e[i].d){
            int j=v1[x].second;
            d.a[0][0]=a[j];
            d.a[0][1]=b[j]+b[j-1];
            updata(1,n,v1[x].second,1),++x;
        } 
		while(y<n-1 && v2[y].first<=e[i].d){
            int j=v2[y].second;
            d.a[0][0]=a[j];
            d.a[0][1]=b[j]+b[j-1];
            d.a[0][2]=b[j]+b[j-2]+a[j-1];
            updata(1,n,v2[y].second,1),++y;
        }
        ans[e[i].id]=tree[1].a[0][0];
    }
    for(int i=1;i<=q;i++) res.push_back(ans[i]);
    return res;
}
```

---

## 作者：2020HZ06 (赞：3)

### 算法一：  
结论一：将 $W$ 从小到大排序，将一条船的两个工艺品连线，线段**两两不相交**。调整法可证明。

设 $dp_{i,0/1}$ 表示 $i$ 号工艺品是否和前面的工艺品放在一条船的最小代价。  
转移：  
$dp_{i,0}=\min(dp_{i-1,0},dp_{i-1,1})+a_i\\dp_{i,1}=\min_{j<i,w_i-w_j \le D}\{dp_{j,0}+suma_{i-1}-suma_{j-1}-a_j+b_j+b_i\}$  
时间复杂度 $O(QN^2)$，**期望得分：**$17pts$。  
### 算法二：  
考虑分离 $j$ 的贡献，$dp_{i,1}=\min_{j<i,w_i-w_j \le D}\{(dp_{j,0}-suma_{j-1}-a_j+b_j)\}+(suma_{i-1}+b_i)$  
然后 $w_i-w_j \le D$ 的限制是滑动窗口，可以用**单调队列**优化。

时间复杂度 $O(QN)$，**期望得分：**$67pts$。  
### 算法三：  
可以注意到：当区间 $[i,j]$ 长度大于 $3$ 时，我们完全可以将其中间的元素**两两配对**，无需 DP。  
结论二：任意配对的距离要么为 $2$，要么为 $3$。这样就可以去掉单调队列。

时间复杂度仍为 $O(QN)$，**期望得分：**$67pts$。  
### 算法四：  
注意到将 $D$ 从小到大排序，限制越来越松，更多距离为 $2$ 或 $3$ 的配对变为合法。  
不妨换个角度考虑问题，将 $W$ 排在一条数轴上，相邻两个数的距离可能大于 $D$，可能小于等于 $D$。  
将小于等于 $D$ 的缩成一个段。段长为偶数则答案变成 $\sum b_i$。段长为奇数则分两种情况：  
1. 不拼船的工艺品是段中的第**奇数**个：那么直接把 $b_i$ 变为 $a_i$ 即可。  
2. 不拼船的工艺品是段中的第**偶数**个：那么要满足 $w_{i+1}-w_{i-1} \le D$ 才能把 $b_i$ 变为 $a_i$，否则需要变成 $a_{i-1}+a_i+a_{i+1}$，还不如对 $a_{i-1}$ 使用第一种转移。


当 $D$ 增加时会使一些段合并，如果合并后的段长度为偶数，则直接计算 $\sum b_i$。否则一定是**一偶一奇**合并而来。设两段初始答案为 $Ans_1,Ans_2$。  
转移 $(1)$ 又分两种情况：  
- 奇数段 + 偶数段：偶数段中的**偶数**位置要计入贡献。  
- 偶数段 + 奇数段：偶数段中的**奇数**位置要计入贡献。  

注意奇数段无论排在前还是后，每个位置**奇偶性都不会变**。这意味着 $(1)$ 中**无需考虑奇数段**，因为它们都包括在 $Ans_1+Ans_2$ 中。  
我们可以很轻松地维护一个段中的奇数/偶数位置贡献 $a_i-b_i$ 最小值，分别用 $odd/even$ 表示。  

对于转移 $(2)$，我们也可以从小到大加入 $w_{i+1}-w_{i-1}  \le D$ 的 $a_i-b_i$。对每个段再维护两个值 $T_{odd},T_{even}$，更新对应奇偶性的值和答案。那么转移 $(2)$ 即可利用 set 找所属段在 $O( \log N)$ 时间内完成。  

理一下思路，先将 $W$ 和 $D$ 从小到大排序，再合并段，段长为偶数直接计算 $\sum b_i$，段长为奇数则用合并段信息转移 $(1)$，set 转移 $(2)$。

时间复杂度 $O(N \log N)$，**期望得分：**$100 pts$。


```cpp
//#include "nile.h"
#include<bits/stdc++.h>
using namespace std;
#define ll long long
struct bl{
	ll sum,ans;//sum是段内b之和
	int odd,even,len,T[2];//T[0],T[1] 就是 Teven 和 Todd
}c[100005];
struct node{
	int w,a,b;
}a[100005];
struct que{
	int d,xh;
}q[100005],p[100005],r[100005];
int n,h[100005],t[100005];//h是段尾对应的段头，t是段头对应的段尾
const int inf=0x3f3f3f3f;
bool cmp(que x,que y){
	return x.d<y.d;
}
bool cmp1(node x,node y){
	return x.w<y.w;
}
std::vector<long long> calculate_costs(std::vector<int> W, std::vector<int> A,std::vector<int> B, std::vector<int> E) {
	int Q = (int)E.size();n=W.size();
  	ll ans=0;
  	for(int i=0;i<n;i++) a[i+1]=node{W[i],A[i],B[i]},ans+=A[i];
  	for(int i=0;i<Q;i++) q[i+1]=que{E[i],i+1};
  	sort(a+1,a+n+1,cmp1),sort(q+1,q+Q+1,cmp);

	set<int>se;
	for(int i=1;i<=n;i++) t[i]=h[i]=i,c[i]=bl{a[i].b,a[i].a,a[i].a-a[i].b,inf,1,{inf,inf}},se.insert(i);
	int ct=0;
  	for(int i=2;i<n;i++) p[++ct]=que{a[i+1].w-a[i-1].w,i};
  	for(int i=1;i<n;i++) r[i]=que{a[i+1].w-a[i].w,i};
  	sort(p+1,p+ct+1,cmp),sort(r+1,r+n,cmp);

	std::vector<long long> R(Q, 0);
  	int p1=1,p2=1;
  	for(int i=1;i<=Q;i++){
		while(p1<n&&r[p1].d<=q[i].d){
  			int u=r[p1].xh;
  			int b1=h[u],b2=u+1;
  			c[b1].sum+=c[b2].sum,c[b1].T[0]=min(c[b1].T[0],c[b2].T[0]),c[b1].T[1]=min(c[b1].T[1],c[b2].T[1]);
  			ans-=c[b1].ans+c[b2].ans;
  			if((c[b1].len+c[b2].len)%2==0)//转移 (1) 第一种情况
            c[b1].ans=c[b1].sum,ans+=c[b1].sum;

			else{//转移 (1) 第二种情况
				ll res=c[b1].ans+c[b2].ans;
				if(c[b1].len%2==1) res=min(res,c[b1].sum+c[b2].even);
				else res=min(res,c[b1].sum+c[b1].odd);
				res=min(res,c[b1].sum+c[b1].T[!(b1%2)]);//合并段的时候也需要进行转移 (2)，其余段长奇偶性不变，自然也无须转移。
				ans+=(c[b1].ans=res);
			}

			if(c[b1].len%2==1) // 维护even和odd
                swap(c[b2].odd,c[b2].even);
			c[b1].odd=min(c[b1].odd,c[b2].odd),c[b1].even=min(c[b1].even,c[b2].even);
			c[b1].len+=c[b2].len;
			h[t[b2]]=b1,t[b1]=t[b2],se.erase(b2);
  			p1++;
		}

		while(p2<=ct&&p[p2].d<=q[i].d){//转移 (2)
  			int u=p[p2].xh;
  			int wz=*prev(se.upper_bound(u));
            c[wz].T[u%2]=min(c[wz].T[u%2],a[u].a-a[u].b);
			ans-=c[wz].ans;
  			if(c[wz].len%2==1) c[wz].ans=min(c[wz].ans,c[wz].sum+c[wz].T[!(wz%2)]);
			ans+=c[wz].ans;
  			p2++;
		}
		R[q[i].xh-1]=ans;
	}
  	return R;
}
```

---

## 作者：晴空一鹤 (赞：2)

~~迫真 IOID1T1 比 NOID1T1 简单。~~

由 $B_i < A_i$ 分析可得答案上限为所有 $A_i$ 之和，因此我们记 $C_i=B_i-A_i$，表示物品 $i$ 被匹配后可以省下多少运费，那我们目标变为最大化被匹配物品的 $C$ 之和。

很容易想到一个暴力 `dp`：将所有物品按 D 排序，记 $dp_i$ 表示最后一个被匹配的物品是 $i$（且 $i$ 在该匹配靠后位置）时，答案的最大值，我们枚举与 $i$ 匹配且在限制内的物品 $j$，转移的答案就是 $j$ 到 $i$ 的 $C$ 之和加上 $dp_{j-1}$（分奇偶转移式略有不同）。

这是 $O(qn^2)$ 的。我们这时思考一下，是否所有的 $j$ 都可能与 $i$ 匹配来得到 $dp_i$。

显然不是。如果 $i$ 与 $j$ 之间有超过 $1$ 个物品，我们显然可以让 $i$，$j$ 分别匹配该区域内（不包括 $i$，$j$）的前 $2$ 个物品，如此迭代下去而对限制的要求反而更松。

因此 $dp_i$ 的值完全可以只由 $i$ 与 $i-1$ 配对或 $i$ 与 $i-2$ 配对转移来。时间复杂度优化至 $O(nq)$。

为方便统计答案我们直接把 $dp_i$ 定义修改为到 $i$ 为止的答案。考虑此时 $dp_i$ 的值只与 $dp_{i-1}$，$dp_{i-2}$，$dp_{i-3}$ 与限制 $D$ 有关，我们容易把转移改写成矩阵乘法的形式。

将所有询问升序排列，限制变松只会对所有转移矩阵产生共计 $O(n)$ 次修改，根据套路使用线段树进行维护即可。

时间复杂度 $O(nk^3\log_2n)$。

代码比较丑放在[云剪贴板](https://www.luogu.com.cn/paste/se4zywaz)了。

---

## 作者：Purslane (赞：2)

# Solution

签到题。

首先将 $w$ 排序。记 $\Delta_i = a_i-b_i$。显然我们需要将某些物品两两配对，使得它们重量差都 $\le D$，且 $\sum \Delta_i$ 最大。

------

使用调整法，容易证明配对有如下性质：

1. 若有配对 $(i,j)$ 和 $(x,y)$，其中 $i < j$、$x < y$，则 $j < x$ 或 $y < i$。

2. $\forall (i,j)$，$|i-j| \le 2$。

设 $dp_i$ 表示考虑前 $i$ 个物品内部两两匹配的最大价值。

显然 $dp_i$ 只能由 $dp_{i-1}$、$dp_{i-2}$、$dp_{i-3}$ 转移过来，所以可以 DDP。

按照 $e$ 倒叙处理询问即可。

```cpp
#include<bits/stdc++.h>
#include "nile.h"
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10;
int n,q,a[MAXN],b[MAXN],w[MAXN],e[MAXN],dt[MAXN];
ll tot,ans[MAXN];
struct Matrix {ll v[3][3];}t[MAXN<<2];
Matrix operator *(Matrix A,Matrix B) {
	Matrix res;
	memset(res.v,-0x3f,sizeof(res.v));
	ffor(i,0,2) ffor(j,0,2) ffor(k,0,2) res.v[i][k]=max(res.v[i][k],A.v[i][j]+B.v[j][k]);
	return res;
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void build(int k,int l,int r) {
	if(l==r) {
		memset(t[k].v,-0x3f,sizeof(t[k].v));
		t[k].v[1][0]=t[k].v[2][1]=t[k].v[2][2]=0;
		if(l>1) t[k].v[1][2]=dt[l-1]+dt[l]; else t[k].v[1][2]=0;
		if(l>2) t[k].v[0][2]=dt[l-2]+dt[l]; else t[k].v[0][2]=0;
		return ;
	}
	build(lson,l,mid),build(rson,mid+1,r);
	return t[k]=t[lson]*t[rson],void();
}
void update(int k,int l,int r,int p,int op) {
	if(l==r) {
		if(op==1) t[k].v[1][2]=0;
		else t[k].v[0][2]=0;
		return ;
	}
	if(p<=mid) update(lson,l,mid,p,op);
	else update(rson,mid+1,r,p,op);
	return t[k]=t[lson]*t[rson],void();
}
vector<ll> calculate_costs(vector<int> W,vector<int> A,vector<int> B,vector<int> E) {
	n=A.size(),q=E.size();
	vector<pair<int,pair<int,int>>> pr;	
	ffor(i,0,n-1) pr.push_back({W[i],{A[i],B[i]}});
	sort(pr.begin(),pr.end());
	ffor(i,1,n) w[i]=pr[i-1].first,a[i]=pr[i-1].second.first,b[i]=pr[i-1].second.second,dt[i]=a[i]-b[i];
	vector<pair<int,int>> dt1,dt2,qr;
	ffor(i,1,q) e[i]=E[i-1];
	ffor(i,1,n) tot+=a[i];
	ffor(i,1,n-1) dt1.push_back({w[i+1]-w[i],i+1});
	ffor(i,1,n-2) dt2.push_back({w[i+2]-w[i],i+2});
	ffor(i,1,q) qr.push_back({e[i],i});
	sort(dt1.begin(),dt1.end(),[](pair<int,int> A,pair<int,int> B) {return A>B;}),sort(dt2.begin(),dt2.end(),[](pair<int,int> A,pair<int,int> B) {return A>B;}),sort(qr.begin(),qr.end(),[](pair<int,int> A,pair<int,int> B) {return A>B;});
	build(1,1,n);
	int pos1=0,pos2=0;
	for(auto pr:qr) {
		int d=pr.first;
		while(pos1<dt1.size()&&dt1[pos1].first>d) update(1,1,n,dt1[pos1].second,1),pos1++;
		while(pos2<dt2.size()&&dt2[pos2].first>d) update(1,1,n,dt2[pos2].second,2),pos2++;
		ans[pr.second]=t[1].v[2][2];
	}
	vector<ll> res;
	ffor(i,1,q) res.push_back(tot-ans[i]);
	return res;
}
//int main() {
//	auto vc=calculate_costs({15, 12, 2, 10, 21},
//                {5, 4, 5, 6, 3},
//                {1, 2, 2, 3, 2},
//                {5, 9, 1});
//	for(auto id:vc) cout<<id<<'\n';	
//}
```

---

## 作者：hoko (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P11049)

先考虑暴力，容易想到动态规划，先按重量从小到大排序，$dp_i$ 表示前 $i$ 个运过去的最小代价，容易得到一下转移式：

$$dp_i=\begin{cases}
  dp_{i-1}+a_i & w_i-w_{i-1}>d \\
  \min(dp_{i-1}+a_i,dp_{i-2}+b_{i-1}+b_i) & w_i-w_{i-1}\le d \\
  \min(dp_{i-1}+a_i,dp_{i-2}+b_{i-1}+b_i,dp_{i-3}+b_{i-2}+b_i+a_{i-1}) &  w_i-w_{i-2}\le d
\end{cases}$$

解释一下，第一行是第 $i$ 个货物自己一条船，第二行是 $i$ 和 $i-1$ 一起运过去，第三行是 $i$ 和 $i-2$ 一起运过去，$i-1$ 自己过去。那为什么能这么判断，因为假设有 $4$ 个货物，重量分别为 $w_1,w_2,w_3,w_4$，有 $w_1<w_2<w_3<w_4$，那么如果 $1$ 和 $4$ 一起运过去，一定不优，因为可以 $1$ 和 $2$ 一起，$3$ 和 $4$ 一起。所以对于每一个货物，只需要和前面 $2$ 个比较就可以了。

这个代码复杂度是 $O(nq)$ 的，可以拿到 $67$ 分。

考虑如何优化，想到可以把询问排序，离线做。把询问从小到大排，容易发现因为限制越来越宽，所以当 $d$ 足够大时，答案固定。所以我们维护每个 $i$ 的三条式子的变化，最初始时我们认为每个 $i$ 仅满足第一条式子。把 $w_i$ 从小到大排，$w_i-w_{i-1}$ 和 $w_i-w_{i-2}$ 也从小到大排，为了能快速的维护变化。

我们考虑用线段树维护矩阵乘法来实现，这里要定义一个广义矩阵，即把原来矩阵乘法的第 $i$ 行 $\times$ 第 $j$ 列再求和，变为第 $i$ 行 $+$ 第 $j$ 列再取 $\min$。

细节如下：

```cpp
for(int i=1;i<=3;i++)
    for(int j=1;j<=3;j++)
        for(int k=1;k<=3;k++)
            res.a[i][j]=min(res.a[i][j],a[i][k]+b.a[k][j]);
```
考虑用矩阵实现状态转移：


$$\begin{bmatrix} a_i & +\infty & +\infty \\ 0 & +\infty & +\infty \\ +\infty & 0 & +\infty \end{bmatrix} \begin{bmatrix} dp_{i-1} \\ dp_{i-2} \\ dp_{i-3} \end{bmatrix} = \begin{bmatrix} dp_i \\ dp_{i-1} \\ dp_{i-2} \end{bmatrix}$$

$$\begin{bmatrix} a_i & b_i+b_{i-1} & +\infty \\ 0 & +\infty & +\infty \\ +\infty & 0 & +\infty \end{bmatrix} \begin{bmatrix} dp_{i-1} \\ dp_{i-2} \\ dp_{i-3} \end{bmatrix} = \begin{bmatrix} dp_i \\ dp_{i-1} \\ dp_{i-2} \end{bmatrix}$$

$$\begin{bmatrix} a_i & b_i+b_{i-1} & b_i+a_{i-1}+b_{i-2} \\ 0 & +\infty & +\infty \\ +\infty & 0 & +\infty \end{bmatrix} \begin{bmatrix} dp_{i-1} \\ dp_{i-2} \\ dp_{i-3} \end{bmatrix} = \begin{bmatrix} dp_i \\ dp_{i-1} \\ dp_{i-2} \end{bmatrix}$$

同正常的矩阵乘法一样，这个也具有结合律。那么我们现在只需要用线段树维护每个式子，单点进行修改，最后根节点为答案。

注意矩阵乘法的顺序，以及 $[1,1]$ 的叶子结点的矩阵为空，`push_up` 时注意判断，注意初始矩阵中的每一个数为无穷大。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1010101;
const int M=4;
struct tt{
	ll a[M][M];
	void init(){memset(a,0x3f,sizeof(a));}
	tt operator*(const tt &b)const{
		tt res;
		res.init();
		for(int i=1;i<=3;i++)
			for(int j=1;j<=3;j++)
				for(int k=1;k<=3;k++)
					res.a[i][j]=min(res.a[i][j],a[i][k]+b.a[k][j]);
		return res;
	}
}C,t[N];
struct node{ll w,a,b;}s[N];
bool cmp(node a,node b){return a.w<b.w;}
ll f1,f2;
vector<pair<ll,ll> >e,v1,v2;
vector<ll>num;
ll ans[N];
ll ls(ll p){return p<<1;}
ll rs(ll p){return p<<1|1;}
void push_up(ll p){t[p]=t[rs(p)]*t[ls(p)];}
void build(ll p,ll l,ll r){
	if(l>r)return;
	if(l==r){
		t[p]=C;
		t[p].a[1][1]=s[l].a;
		t[p].a[2][1]=t[p].a[3][2]=0;
		return;
	}
	ll mid=l+r>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	if(l==1&&r==2)t[p]=t[rs(p)];
	else push_up(p);
}
void update(ll p,ll l,ll r,ll x,ll idx){
	if(x<l||r<x)return;
	if(l==r&&l==x){
		if(l==2)t[p].a[1][1]=f2,t[p].a[2][1]=f1,t[p].a[3][1]=0;
		else{
			if(idx==1)t[p].a[1][2]=s[l].b+s[l-1].b;
			if(idx==2)t[p].a[1][3]=s[l].b+s[l-2].b+s[l-1].a;
		}
		return ;
	}
	ll mid=l+r>>1;
	update(ls(p),l,mid,x,idx);
	update(rs(p),mid+1,r,x,idx);
	if(l==1&&r==2)t[p]=t[rs(p)];
	else push_up(p);
}
vector<long long> calculate_costs(vector<int> W,vector<int>A,vector<int>B,vector<int>E){
	ll n=W.size(),m=E.size();
	for(int i=1;i<=n;i++)s[i].w=W[i-1],s[i].a=A[i-1],s[i].b=B[i-1];
	sort(s+1,s+n+1,cmp);
	for(int i=1;i<=m;i++)e.push_back({E[i-1],i});
	for(int i=2;i<=n;i++)v1.push_back({s[i].w-s[i-1].w,i});
	for(int i=3;i<=n;i++)v2.push_back({s[i].w-s[i-2].w,i});
	sort(e.begin(),e.end());
	sort(v1.begin(),v1.end());
	sort(v2.begin(),v2.end());
	C.init();
	build(1,1,n);
	ll i=0,j=0;
	for(auto u:e){
		f1=s[1].a;
		if(s[2].w-s[1].w<=u.first)f2=s[1].b+s[2].b;
		else f2=s[1].a+s[2].a;
		update(1,1,n,2,0);
		while(i<n-1&&v1[i].first<=u.first)update(1,1,n,v1[i].second,1),i++;
		while(j<n-1&&v2[j].first<=u.first)update(1,1,n,v2[j].second,2),j++;
		ans[u.second]=t[1].a[1][1];
	}
	for(int i=1;i<=m;i++)num.push_back(ans[i]);
	return num;
}
// int main(){
// 	vector<ll>res;
// 	res=calculate_costs({15, 12, 2, 10, 21},{5, 4, 5, 6, 3},{1, 2, 2, 3, 2},{5, 9, 1});
// 	for(auto i:res)cout<<i<<"\n";
// 	return 0;
// }
```

---

## 作者：Mirasycle (赞：1)

简单题。

这个匹配形式启发我们按照 $W$ 从小到大排序一下。

贪心地思考一下，不难发现以下性质，如果 $x,y$ 放在一条船上，那么必然满足 $|x-y|\le 2$。考虑证明，由于 $A_i>B_i$，我们需要尽可能匹配，假设出现了 $a<b<c<d$，$a,d$ 匹配 并且 $b,c$ 匹配，那么我们将其调整为 $a,b$ 匹配，$c,d$ 匹配是不劣的，因为这种匹配形式更容易匹配到更多组。

利用这个性质直接 dp。

设 $dp_{i,0/1/2/3}$ 分别表示 $i$ 点自己和自己匹配，和后面匹配，$i-1$ 和 $i+1$ 匹配，$i$ 和前面匹配。

$$dp_{i,0}=\min(dp_{i-1,0},dp_{i-1,3})+a_i$$

$$dp_{i,1}=\min(dp_{i-1},dp_{i-1,3})+b_i$$

$$dp_{i,2}=dp_{i-1,1}+a_i$$

$$dp_{i,3}=\min(dp_{i-1,1},dp_{i-1,2})+b_i$$

不难发现这个形式可以写出 $(\min,+)$ 矩阵乘法的形式。其中这些转移需要满足一些 $W,E$ 之间的约束关系，于是按照询问的 $E$ 从小到大排序，然后用线段树动态维护矩阵积即可。

时间复杂度 $O(k^3n\log n)$，其中 $k=4$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi; 
const int maxn=1e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int a[maxn],b[maxn],c[maxn],q[maxn],p[maxn];
struct node{
	int u,v,w;
	bool operator < (const node &rhs) const { return w<rhs.w; }
}d[maxn<<2]; vector<ll> ans; int n,m,tot=0;
struct Matrix{
	ll mat[4][4];
	void init(){ memset(mat,0x3f,sizeof(mat)); }
	Matrix operator * (const Matrix &rhs) const {
		Matrix res; res.init();
		for(auto i=0;i<=3;i++)
			for(int j=0;j<=3;j++)
				for(int k=0;k<=3;k++)
					res.mat[i][j]=min(res.mat[i][j],mat[i][k]+rhs.mat[k][j]);
		return res;
	}
}M[maxn<<2]; vector<node> vec;
struct SegmentTree{
	#define ls (p<<1)
	#define rs (p<<1|1)
	#define mid (l+r>>1)
	void pushup(int p){ M[p]=M[ls]*M[rs]; }
	void build(int p,int l,int r){
		if(l==r){ 
			M[p].init(); M[p].mat[0][0]=M[p].mat[3][0]=a[l];
			M[p].mat[0][1]=M[p].mat[3][1]=b[l]; return ;
		}
		build(ls,l,mid); build(rs,mid+1,r); pushup(p);
	}
	void modify(int p,int l,int r,int x){
		if(l==r){ for(auto z:vec) M[p].mat[z.u][z.v]=z.w; return ; }
		if(x<=mid) modify(ls,l,mid,x);
		else modify(rs,mid+1,r,x);
		pushup(p);
	}
	ll query(){
		ll res[5]; memset(res,0x3f,sizeof(res));
		ll DP[5]; memset(DP,0x3f,sizeof(DP)); DP[0]=0;
		for(int j=0;j<=3;j++)
			for(int k=0;k<=3;k++)
				res[k]=min(res[k],DP[j]+M[1].mat[j][k]);
		return min(res[0],res[3]);
	}
}seg;
bool cmp(int x,int y){ return c[x]<c[y]; }
bool cmp2(int x,int y){ return q[x]<q[y]; }
vector<ll> calculate_costs(vi W,vi A,vi B,vi E){
	n=W.size(); m=E.size();
	for(int i=1;i<=n;i++) c[i]=W[i-1];
	for(int i=1;i<=m;i++) q[i]=E[i-1];
	for(int i=1;i<=n;i++) p[i]=i;
	sort(p+1,p+1+n,cmp);
	for(int i=1;i<=n;i++) a[i]=A[p[i]-1],b[i]=B[p[i]-1],c[i]=W[p[i]-1];
	for(int i=1;i<=m;i++) p[i]=i;
	sort(p+1,p+1+m,cmp2); seg.build(1,1,n);
	for(int i=1;i<=n;i++){
		if(i>1) ++tot,d[tot]=(node){i,1,abs(c[i]-c[i-1])};
		if(i>2) ++tot,d[tot]=(node){i,2,abs(c[i]-c[i-2])};
	}
	int z=0; ans.resize(m); sort(d+1,d+1+tot);
	for(int i=1;i<=m;i++){
		while(z<tot&&d[z+1].w<=q[p[i]]){
			z++; vec.clear(); int id=d[z].u;
			if(d[z].v==1){
				vec.pb((node){1,3,b[id]});
				vec.pb((node){2,3,b[id]});
				seg.modify(1,1,n,id); 
			}else{
				vec.pb((node){1,2,a[id-1]});
				seg.modify(1,1,n,id-1); 			
			}
		}
		ans[p[i]-1]=seg.query();
	}
	return ans;
}
```

---

## 作者：Lavaloon (赞：1)

## $\text{Analysis}$

第一想法肯定是转化成**最大化“通过同时运输物品而省下的花费”**。

于是对于每个物品定义 $C_i=A_i-B_i$，表示：假如这个物品被与另一个物品同时运输，这个物品能省下的花费。

接下来考虑**物品配对方案的形态**。

假如已经选出了若干个物品，并希望配对后通过同时进行运输来节约花费，如何判定这种选择方案的合法性？

在**将选出来的这些物品按重量从小到大排序后**，我们一定会让第 $2i-1$ 个物品和第 $2i$ 个物品配对，否则是不优的。只需要检查在这种配对方式下是否符合题意即可。

对于一种最优的选择方案，其应当满足哪些性质？

**将所有物品按重量从小到大排序后**，若选出来的两个物品中间隔了 $\ge 2$ 个物品没有被选，那么这是不优的，因为这些没有被选的物品中肯定存在 $|W_i-W_j|\le D$ 的一对物品。

因此，**选出来的两相邻物品之间**，要么**不存在**未被选出的物品，要么**仅有一个**未被选出的物品。

考虑**回答单组询问**。

先将所有物品按重量从小到大排序。

设计 DP 状态：$f_i$ 表示：**考虑了前 $i$ 个物品，省下的花费的最大值。**

假如该物品作为选出来的一对中，**相对靠后的一个**被选，则枚举这一对中，相对靠前的一个物品进行转移（上文提到，这个物品要么是 $i-1$，要么是 $i-2$）；否则直接继承 $f_{i-1}$。

分成 $3$ 类转移，即：
$$
f_i=
\left\{\begin{array}{l} \max\{f_{i-1},f_{i-2}+C_{i-1}+C_i,f_{i-3}+C_{i-2}+C_i\} & \text{if }\ W_i-W_{i-2}\le D&\color{red}{\text{ (type 0)}}
\\ \max\{f_{i-1},f_{i-2}+C_{i-1}+C_i\} & \text{if }\ W_i-W_{i-1}\le D&\color{red}{\text{ (type 1)}}
\\ f_{i-1} & \text{otherwise}&\color{red}{\text{ (type 2)}}
\end{array}\right.
$$
对于单组询问，时间复杂度 $\mathcal{O}(N)$，故总时间复杂度 $\mathcal{O}(NQ)$，可以得到 $67$ 分的好成绩。

考虑**回答多组询问**。

一个状态由其前驱状态的**线性组合**得到，考虑应用动态 DP 的技巧，使用 $(\max,+)$ 的广义矩阵乘法优化之。形式即为：
$$
\begin{bmatrix}
f_i  & f_{i-1} & f_{i-2}
\end{bmatrix}
=
\begin{bmatrix}
f_{i-1} & f_{i-2} & f_{i-3}
\end{bmatrix}
\circ \mathcal{M}
$$


对于 $\color{red}{\text{type 0}}$ 而言，$\mathcal{M}$ 如下：
$$
\begin{bmatrix}
 0 & 0  & -\infty\\
 C_{i-1}+C_i & -\infty & 0\\
 C_{i-2}+C_i & -\infty & -\infty
\end{bmatrix}
$$
对于 $\color{red}{\text{type 1}}$ 而言，$\mathcal{M}$ 如下：
$$
\begin{bmatrix}
 0 & 0  & -\infty\\
 C_{i-1}+C_i & -\infty & 0\\
-\infty & -\infty & -\infty
\end{bmatrix}
$$
对于 $\color{red}{\text{type 2}}$ 而言，$\mathcal{M}$ 如下：
$$
\begin{bmatrix}
 0 & 0  & -\infty\\
-\infty & -\infty & 0\\
-\infty & -\infty & -\infty
\end{bmatrix}
$$
广义矩阵乘法满足结合律，因此可使用线段树维护一段区间内的矩阵之积。

**下称一个位置的矩阵发生类型的变化为“转换”。**

每次给定的 $D_i$ 会改变若干个位置矩阵的 $\text{type}$，**三种类型之间均可相互转换**，此时假如暴力转换每个位置的矩阵，复杂度是不优的。

关键问题出在“三种类型之间均可相互转换”这一点上，这导致每个位置的矩阵转换次数达到了 $\mathcal{O}(Q)$ 级别。

考虑削减每个位置的矩阵转换次数至 $\mathcal{O}(1)$，一个可行的手段是**离线询问，按 $D_i$ 从小到大的顺序回答**。

通过这个手段，每个矩阵只会从 $\text{type 0}$ 转化为 $\text{type 1}$ 再转化为 $\text{type 2}$，每个位置的矩阵的转换次数是 $\mathcal{O}(1)$ 的，故程序运行的整个过程中只会转化 $\mathcal{O}(N)$ 次。

实现方面，使用一个指针来维护所有可能的转换，在该转换应当发生的时刻去线段树上修改这个矩阵即可。

每次回答询问只需查询根节点的矩阵。

**时间复杂度线性对数**，符合题目要求。

## $\text{Details}$

- **注意特判 $N=1$**，此时不会发生矩阵的转换并且（你的程序以为的）转换的个数的上界 $2N-3<0$，你对转换进行排序的时候如果写了 `sort(ord+1,ord+n+n-2)` 本地会直接 T 掉。
- 假如 $W$ 序列形如 $\{X,X,X\}$ 的形式，那么对于第 $3$ 个位置，其进行 $\text{type 1,2}$ 转换的条件相同。此时注意**千万不要让 $\text{type 2}$ 被 $\text{type 1}$ 覆盖了**。可选的解决方式较多，比如对于转换条件相同的情况，钦定先进行 $\text{type 1}$ 后进行  $\text{type 2}$ 即可。
- **存储可能发生的转换的序列开两倍空间。**

- **记得判数组下标 $<3$ 的情况**，此时可能发生数组越界。

## $\text{Code}$


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
#define ll long long
#define ull unsigned long long
#define lc (x<<1)
#define rc (x<<1|1)
#define pii pair<int,int>
#define mkp make_pair
#define fi first
#define se second
const int Mx=100005,p=998244353;
int n,m;
ll ans[Mx];
struct Query{
	int d;
	int id;
	bool operator <(const Query&obj)const{
		return d<obj.d;
	}
}qry[Mx];
struct Ele{
	int w;
	int c;
	bool operator <(const Ele&obj)const{
		return w<obj.w;
	}
}a[Mx];
ll Sum;
struct Trans{
	int typ;
	int d;
	int id;
	bool operator <(const Trans&obj)const{
		return d==obj.d?typ<obj.typ:d<obj.d;
	}
}ord[Mx<<1];
template<int N>
struct matrix{
	ll c[N][N];
	matrix(){
		memset(c,0,sizeof c);
	}
	matrix<N>operator *(const matrix<N>&M){
		matrix<N>res;
		for(int i=0;i<N;i++){
			for(int j=0;j<N;j++){
				for(int k=0;k<N;k++){
					res.c[i][j]=max(res.c[i][j],c[i][k]+M.c[k][j]);
				}
			}
		}
		return res;
	}
};
matrix<3>GenMatrix(int id,int typ){
	matrix<3>res;
	if(typ==0){
		res.c[0][0]=0,res.c[0][1]=0,res.c[0][2]=-1e18;
		res.c[1][0]=-1e18,res.c[1][1]=-1e18,res.c[1][2]=0;
		res.c[2][0]=-1e18,res.c[2][1]=-1e18,res.c[2][2]=-1e18;
	}
	else if(typ==1){
		res.c[0][0]=0,res.c[0][1]=0,res.c[0][2]=-1e18;
		res.c[1][0]=(id-1>0?a[id-1].c+a[id].c:-(int)1e18),res.c[1][1]=-1e18,res.c[1][2]=0;
		res.c[2][0]=-1e18,res.c[2][1]=-1e18,res.c[2][2]=-1e18;
	}
	else{
		res.c[0][0]=0,res.c[0][1]=0,res.c[0][2]=-1e18;
		res.c[1][0]=(id-1>0?a[id-1].c+a[id].c:-(int)1e18),res.c[1][1]=-1e18,res.c[1][2]=0;
		res.c[2][0]=(id-2>0?a[id-2].c+a[id].c:-(int)1e18),res.c[2][1]=-1e18,res.c[2][2]=-1e18;
	}
	return res;
}
class SegTree{
	private:
		struct Node{
			int l,r;
			matrix<3>mul;
		};
		Node t[Mx<<2];
		void PushUp(int x){
			t[x].mul=t[lc].mul*t[rc].mul;
		}
	public:
		void Build(int x,int l,int r){
			t[x].l=l,t[x].r=r;
			if(l==r){
				t[x].mul=GenMatrix(l,0);
				return;
			}
			int mid=((l+r)>>1);
			Build(lc,l,mid),Build(rc,mid+1,r);
			PushUp(x);
		}
		void Modify(int x,int id,int typ){
			int l=t[x].l,r=t[x].r;
			if(l==r){
				t[x].mul=GenMatrix(id,typ);
				return;
			}
			int mid=((l+r)>>1);
			if(id<=mid) Modify(lc,id,typ);
			else Modify(rc,id,typ);
			PushUp(x);
		}
		ll Qry(){
			return t[1].mul.c[0][0];
		}
};
SegTree tr;
vector<ll>calculate_costs(vector<int>W,vector<int>A,vector<int>B,vector<int>E){
	n=W.size();
	for(int i=1,A_,B_;i<=n;i++) a[i].w=W[i-1],A_=A[i-1],B_=B[i-1],a[i].c=A_-B_,Sum+=A_;
	tr.Build(1,1,n);
	m=E.size();
	for(int i=1;i<=m;i++) qry[i].d=E[i-1],qry[i].id=i;
	sort(a+1,a+n+1),sort(qry+1,qry+m+1);
	for(int i=2;i<=n;i++) ord[i-1]={1,a[i].w-a[i-1].w,i};
	for(int i=3;i<=n;i++) ord[n+i-3]={2,a[i].w-a[i-2].w,i};
	if(n+n-2>=1) sort(ord+1,ord+n+n-2);
	int ptr=0;
	for(int Id=1;Id<=m;Id++){
		int d=qry[Id].d,id=qry[Id].id;
		while(ptr+1<=n+n-3&&ord[ptr+1].d<=d){
			tr.Modify(1,ord[ptr+1].id,ord[ptr+1].typ);
			ptr++;
		}
		ans[id]=tr.Qry();
	}
	vector<ll>Ans;
	for(int i=1;i<=m;i++) Ans.push_back(Sum-ans[i]);
	return Ans;
}
```

---

## 作者：RayAstRa_ (赞：0)

## Description

[Link](https://www.luogu.com.cn/problem/P11049)

## Idea

设 $val_i=a_i-b_i$。

首先考虑只有一次询问时怎么做。

将所有元素按 $w$ 从小到大排序，在所有满足 $w_{i+1}-w_i \le d$ 的 $i$ 与 $i+1$ 间连边，则整个图构成了若干个连续的连通块。

若连通块的长度为偶数，明显块内的所有元素都可以两两配对。

若连通块的长度为奇数，那么必须至少舍弃一个元素。设块为 $[l,r]$，则我们可以选择 $\min val_i$ 舍弃，其中 $i$ 满足 $(i-l+1)\bmod 2 =1$ 或 $w_{i+1}-w_{i-1} \le d$。

证明：对于 $(i-l+1)\bmod 2 =1$ 的情况，舍弃 $i$ 会使得剩下的两个连通块长度均为偶数，可以全部配对。对于 $w_{i+1}-w_{i-1} \le d$ 的情况，舍弃 $i$ 不影响该块的连通性。

那有没有 $i$ 不满足以上两个条件但是是最优的方案呢？

没有，因为舍弃该元素后左右两块长均为奇数，需要分别再找到合适的 $i_l$ 和 $i_r$ 舍弃。可以证明，若 $i_l$ 和 $i_r$ 满足各自连通块内的条件，则它们也满足最初连通块的条件。因此选择 $i$ 和 $i_l$、$i_r$ 不如只选择后者中的一个。同理，若 $i_l$ 或 $i_r$ 不满足条件，则它们同样更劣。

从前往后把每个连通块遍历一遍就可以找出最佳方案，时间复杂度 $O(nq)$。

考虑优化，如果我们把 $d$ 从小到大排序，可以发现答案单调不增，连通块会逐渐合并在一起。考虑把询问离线下来按 $d$ 递增计算。

建立一个并查集维护每个元素处于哪个连通块内，在块头维护该块的长度，开两个线段树分别维护块头 $l\bmod 2=0$ 或 $1$ 的情况。

将 $w_{i+1}-w_i$ 与 $w_{i+1}-w_{i-1}$ 排序，每次取更大的 $d$ 值时，将 $w_{i+1}-w_i \leq d$ 的 $i$ 与 $i+1$ 所在的连通块合并并统计答案，将  $w_{i+1}-w_{i-1}$ 的 $i$ 插入线段树并更新所在连通块的答案。

时间复杂度 $O(n \log n+q)$。

## Code


```cpp
#include<bits/stdc++.h>
#define reg register int
#define clock_reset double ST=clock()
#define look_time cerr<<(clock()-ST)*1.0/1000<<'\n'
#define debug(x) cerr<<x<<endl
using namespace std;
typedef long long ll;
// typedef __int128 ll;
typedef unsigned long long ull;
typedef vector<int> vec;

const ll N=400005,inf=2e18;

struct art{
    ll w,a,b;
    friend bool operator<(art a,art b){return a.w<b.w;}
}arti[N];
struct query{
    ll d,pos;
    friend bool operator<(query a,query b){return a.d<b.d;}
}qu[N];
struct block{
    ll dist,pos;
    friend bool operator<(block a,block b){
        if(a.dist==b.dist)return a.pos<b.pos;
        return a.dist<b.dist;
    }
}blk[N],pt[N];

ll n,q,val[N],z[N],r[N],mina[N],now1,now2;
ll ans[N],cnt;
ll find(ll x){return (z[x]==x?x:z[x]=find(z[x]));}

#define ls (k<<1)
#define rs ((k<<1)|1)
#define mid ((l+r)>>1)
#define tmid ((tl[k]+tr[k])>>1)
struct SGT{
    ll tl[N<<2],tr[N<<2],minv[N<<2];
    void build(ll k,ll l,ll r){
        tl[k]=l;tr[k]=r;
        minv[k]=inf;
        if(l==r)return;
        build(ls,l,mid);
        build(rs,mid+1,r);
    }
    void change(ll k,ll p,ll v){
        if(tl[k]==tr[k]){
            minv[k]=v;
            return;
        }
        if(p<=tmid)change(ls,p,v);
        else change(rs,p,v);
        minv[k]=min(minv[ls],minv[rs]);
    }
    ll ask(ll k,ll l,ll r){
        if(tl[k]>=l&&tr[k]<=r)return minv[k];
        ll ans=inf;
        if(l<=tmid)ans=min(ans,ask(ls,l,r));
        if(r>tmid) ans=min(ans,ask(rs,l,r));
        return ans;
    }
}SGT[2];

void update(int L,int R){
    if((R-L+1)&1)
        mina[L]=SGT[L&1].ask(1,L,R);
    else
        mina[L]=0;
    cnt+=mina[L];
}
std::vector<long long> calculate_costs(
    std::vector<int> W, std::vector<int> A, 
    std::vector<int> B, std::vector<int> E){
    n=W.size();q=E.size();
    for(reg i=1;i<=n;i++)
        arti[i]=(art){W[i-1],A[i-1],B[i-1]};
    sort(arti+1,arti+1+n);
    SGT[0].build(1,1,n);
    SGT[1].build(1,1,n);
    for(reg i=1;i<=n;i++){
        z[i]=r[i]=i;
        cnt+=arti[i].a;
        val[i]=arti[i].a-arti[i].b;
        mina[i]=val[i];
        SGT[i&1].change(1,i,val[i]);
    }
    for(reg i=1;i<n;i++)
        blk[i]=(block){arti[i+1].w-arti[i].w,i};
    for(reg i=2;i<n;i++)
        pt[i]=(block){arti[i+1].w-arti[i-1].w,i};
    for(reg i=1;i<=q;i++)
        qu[i]=(query){E[i-1],i};
    sort(blk+1,blk+n);
    sort(pt+2,pt+n);
    sort(qu+1,qu+1+q);
    now1=0;now2=1;
    for(reg i=1;i<=q;i++){
        while(now1<n-1&&blk[now1+1].dist<=qu[i].d){
            now1++;
            int L=find(blk[now1].pos),R=blk[now1].pos+1;
            cnt-=mina[L]+mina[R];
            z[find(R)]=find(L);
            R=r[R];
            r[L]=R;
            update(L,R);
        }
        while(now2<n-1&&pt[now2+1].dist<=qu[i].d){
            now2++;
            int pos=pt[now2].pos;
            SGT[(pos&1)^1].change(1,pos,val[pos]);
            cnt-=mina[find(pos)];
            update(find(pos),r[find(pos)]);
        }
        ans[qu[i].pos]=cnt;
    }
    vector<ll>sol;
    for(reg i=1;i<=q;i++)
        sol.push_back(ans[i]);
    return sol;
}
```

---


# [IOI 2018] combo 组合动作

## 题目描述

你在玩一个动作游戏。游戏控制器有 $4$ 个按键，`A`、`B`、`X` 和 `Y`。在游戏中，你用组合动作来赚金币。你可以依次按这些按键来完成一个组合动作。
这个游戏有一个隐藏的按键序列，可以表示为由这 $4$ 个字符组成的串 $S$。你并不知道这个串 $S$，但是你知道它的长度为 $N$。

**你还知道，$S$ 的首字符不会在串中重复出现**。例如，$S$ 可以是“`ABXYY`”或者“`XYYAA`”，但不能是“`AAAAA`”或“`BXYBX`”。

你可以依次按最多 $4N$ 个按键来完成一个组合动作。串 $p$ 为你所按的按键序列。你用这个组合动作赚到的金币数量，等于同时为 $p$ 之子串和 $S$ 之前缀的最长字符串的长度。串 $t$ 的子串定义为 $t$ 中的连续字符序列（可以为空）。$t$ 的前缀定义为 $t$ 的子串，其或者为空，或者包含 $t$ 的首字符。

例如，如果 $S$ 是“`ABXYY`”，而 $p$ 是“`XXYYABYABXAY`”，你会得到 $3$ 个金币，因为“`ABX`”是可作为 $p$ 的子串的 $S$ 的前缀中最长的。

你的任务是，用少量的组合动作，找出隐藏字符串 $S$。

### 实现细节

~~你的程序需要引入头文件 `combo.h`。~~

你无需引入头文件 `combo.h`。但是，你需要在你的程序开头加上：

```cpp
int press(string p)
```

此外，建议以 C++20 或者 C++23 提交本题（而非 C++14/GCC9）。

你需要实现下面的函数：

```cpp
string guess_sequence(int N)
```

* `N`：串 $S$ 的长度。
* 对每个测试用例，该函数被调用恰好一次。
* 该函数应返回串 $S$。

你的程序可以调用下面的函数：

```cpp
int press(string p)
```

* `p`：你的按键序列。
* `p` 必须是长度为从 $0$ 到 $4N$ 的串（包括 $0$ 和 $4N$）。`p` 的每个字符必须是 `A`、`B`、`X` 或者 `Y`。
* 对每个测试用例，你调用该函数的次数不能超过 $8\ 000$ 次。
* 该函数的返回结果是，当按出按键序列 `p` 后你赚到的金币数量。

如果不满足上面的条件，你的程序将被判为 `Wrong Answer`。否则，你的程序将被判为 `Accepted`，而你的得分将根据 `press` 的调用次数来计算（参见子任务）。

## 说明/提示

### 限制条件

* $1\le N\le 2\ 000$
* 串 $S$ 的每个字符必须是 `A`、`B`、`X` 或 `Y`。
* $S$ 的首字符不会再 $S$ 中重复出现。

在本题中，评测程序**不是**适应性的。意思是说，在评测程序开始运行的时候 $S$ 就固定下来，而且不依赖于你的程序所做的询问。

### 子任务

1. （5分）$N=3$
2. （95分）没有附加限制。对该子任务，你在每个测试用例上的得分将计算如下。设 $q$ 为调用 `press` 的次数。
   * 如果 $q\le N+2$，你的得分为 $95$。
   * 如果 $N+2<q\le N+10$，你的得分为 $95-3(q-N-2)$。
   * 如果 $N+10<q\le 2N+1$，你的得分为 $25$。
   * 如果 $\max\{N+10,2N+1\}<q\le 4N$，你的得分为 $5$。
   * 否则，你的得分为 $0$。

注意，你在每个子任务上的得分，等于你在该子任务下所有测试用例上的最低得分。

# 题解

## 作者：fish_love_cat (赞：10)

处处都很一眼的题，这居然是 IOI T1 吗 /xia

---

> 对每个测试用例，你调用该函数的次数不能超过 $8000$ 次。

启示我们写出 $4N$ 的解法。

显然每一位的确定都可以在 $4$ 次内解决，从前往后确定即可。

诶等等看错题了，限制不是这个。

> 如果 $q\le N+2$，你的得分为 $95$。

我们需要更加优秀的做法。

---

> 你可以依次按最多 $4N$ 个按键来完成一个组合动作。

启示我们把 $4N$ 个询问压在一起。

接下来就可以充分发扬人类智慧了。

~~先去吃个饭。~~

吃完了也想出来了。

其实也不需要什么高妙的构造，乱糊就可以了。

我们的核心目的是这一位在三个不同的情况下对于我的构造都有不同的返回。

假设剩余的三种字符分别是 $\texttt{A,B,C}$。

那么我们在询问后面分别接上 $\texttt{AA,AB,AC}$，这样就可以以一种大力出奇迹的方式把 $\texttt{A}$ 判出来。

那么还剩一个询问机会，剩下两个字符就随便做了。

~~不知道会不会假，实现一下。~~

喵的有坑，注意到最后一个询问可能会爆长度，拎出来刚好拿最后一次询问机会做掉就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int press(string p);
char A,B,C;
string check1(string s){
    int flc=press(s+'A'+s+'B')-s.size();
    if(flc){
        flc=press(s+'A')-s.size();
        if(flc)return s+'A';
        else return s+'B';
    }else{
        flc=press(s+'X')-s.size();
        if(flc)return s+'X';
        else return s+'Y';
    } 
}
string check2(string s){
    int flc=press(s+A+A+s+A+B+s+A+C+s+B)-s.size();
    if(flc==2)return s+A;
    if(flc==1)return s+B;
    if(flc==0)return s+C;
}
string guess_sequence(int N){
    string s=check1("");
    if(N==1)return s;
    if(s[0]=='A')A='B',B='X',C='Y';
    if(s[0]=='B')A='A',B='X',C='Y';
    if(s[0]=='X')A='A',B='B',C='Y';
    if(s[0]=='Y')A='A',B='B',C='X';
    for(int i=2;i<N;i++)s=check2(s);
    s=check1(s);
    return s;
}
// 「呃，我们连彼此的名字都不晓得，说这种话或许怪怪的。」
// 「但愿你能忘了我。」
// 少女交代完奇妙的话，就滴滴答答地向四处淌着水珠跑掉了。

// Tiat Siba Ignareo
```

很不符合我对 IOI 的想象。

---

## 作者：qwq_Furry (赞：7)

## 解题思路
### 第一步
 - IOI 的题目，感觉会有点难。

 - 我们先观察，注意到题目的一个关键信息：**$S$ 的首字母不会在串中重复出现**。所以我们可以先设 $S$ 的首字母为 $\sigma_1$。

 - 然后可以构造一个测试字符串集 $\mathbb{T} = \left \{ \texttt{"A"}, \texttt{"B"}, \texttt{"C"}, \texttt{"D"}   \right \}$，然后可以通过以下步骤来确定 $\sigma_1$：

   - 若 $\text{press}(\texttt{"AB"}) > 0$，则 $\sigma_1 \in \left \{ \texttt{"A"}, \texttt{"B"} \right \}$，然后可以继续判断。
  
     - 若 $\text{press}(\texttt{"A"}) = 1$，则 $\sigma_1 = \texttt{"A"}$。
    
     - 否则 $\sigma_1 = \texttt{"B"}$。
    
   - 若 $\text{press}(\texttt{"XY"}) > 0$，则 $\sigma_1 \in \left \{ \texttt{"X"}, \texttt{"Y"} \right \}$，然后可以继续判断。
  
     - 若 $\text{press}(\texttt{"X"}) = 1$，则 $\sigma_1 = \texttt{"X"}$。
    
     - 否则 $\sigma_1 = \texttt{"Y"}$。

 - 如果 $N = 1$，直接返回 $\sigma_1$。

### 第二步
 - 接下来进行以下 $3$ 个操作：

   - 定义集合 $H = \left \{ \texttt{"A"}, \texttt{"B"}, \texttt{"X"}, \texttt{"Y"} \right \}$。

    - 令 $\sigma_1 \in H$。
 
    - 定义集合 $E = \left \{ a, b, c \right \}$ 并且令 $E \subseteq H$，且 $\sigma_1 \notin E$。

 - 接下来我们只找第 $2$ 到 $N - 1$ 个字符，然后非常精彩的来了：

   - 定义已知 $S$ 的前 $i$ 个字符的字符串 $ans$，并使 $ans_1 = \sigma_1$

   - 构造一个字符串 $ide$，使 $ide = ans \parallel a \parallel a \parallel ans \parallel a \parallel b \parallel ans \parallel a \parallel c \parallel ans \parallel b$，其中 $\parallel$ 表示为字符串的连接操作。
  
     - $ide$由 $4$ 个子串构成，分别是：
    
     - $ans \parallel a \parallel a$。
    
     - $ans \parallel a \parallel b$。
    
     - $ans \parallel a \parallel c$。
    
     - $ans \parallel b$。
  
- 定义 $Q  = \text{press}(ide)$，若定义行为 $\text{F}$，则 $ans_{i+1} = \text{F}(Q)$。对于每次的 $\text{F}(Q)$，有：
  
$$
\text{F}(Q) = \begin{cases}
  a & Q = i + 2 \\
  b & Q = i + 1 \\
  c & Q = i
\end{cases}
$$

 - 那么这是为什么呢？下面有解释
  
    - 若 $ Q = i + 2$，那么肯定排除 $ans \parallel b$ 这个子串，因为这个子串只有 $1$ 个多的字符，不可能有 $2$ 个，所以答案肯定是其他三个中的一个，那么对于第 $1$ 个多的字符，我们肯定知道这个为 $a$，但是对于第 $2$ 个多的字符，我们肯定不知道，因为有以下 $3$ 种可能，分别是：$a, b, c$，我们分辨不出来，所以返回 $a$。
    
   - 若 $Q = i + 1$，那么肯定是 $ans \parallel b$ 这个子串，为什么呢？如果后面的 $ans$ 后面的字符是 $a$ 的话，那么肯定满足 $Q = i + 2$ 这个条件，因为有 $ans \parallel a \parallel a$ 这个子串存在；如果后面的字符是 $c$ 的话，那么一定满足 $Q = i$，因为在含 $c$ 的子串 $ans \parallel a \parallel c$ 中，取最长前缀的话，不可能取到 $c$，因为前面还有一个 $a$，所以返回 $b$。
    
   - 若 $Q = i$，那么返回 $c$，上面有提到，这里不过多赘述。

### 第三步
 - 接下来找第 $N$ 个字符，对于每一个集合 $E$ 中的元素，依次进行测试，若定义以下一种行为 $\text{L}$，在第 $i$ 次测试中，使 $ans_{n} = \text{L}(ans \parallel E_{i})$。

   - 在每一次的 $\text{L}(ans \parallel E_{i})$ 中，定义 $q$，使 $q = \text{press}(ans \parallel E_{i})$，若 $q = N$，那么使 $ans_n = E_{i}$，否则不进行任何操作。

 - 返回 $ans$ 这个字符串，就这样，我们就做对了一道 IOI 的题目。

## 各种分析
按照此思路来写，可以满足全部子任务的要求，且调用次数也不会超过 $8000$，可以通过此题目。

时间复杂度为 $O(N)$，题目限制是 $1.00$s，可以通过此题目。

## 代码实现
```cpp lines=28-28
#include<bits/stdc++.h>
using namespace std;
extern int press(string p); //不加上extern可能会报错
char fz(int i) { //判断字符
    if(i == 1) return 'A';
    if(i == 2) return 'B';
    if(i == 3) return 'X';
    return 'Y';
}
string guess_sequence(int N) {
    string ans = "";
    if(press("AB") > 0) { //判断首字符
        if(press("A") == 1) ans = 'A';
        else ans = 'B';
    }
    else {
        if(press("X") == 1) ans = 'X';
        else ans = 'Y';
    }
    if(N == 1) return ans; //我们已经判断过一个字符了，且 N 也等于1，那么可以直接返回
    string abcd = "";
    for(int i = 1; i <= 4; i++) {
        char c = fz(i);
        if(c != ans[0]) abcd += c; //如果不是首字符就加上
    }
    for(int i = 1; i < N - 1; i++) {
        char a = abcd[0], b = abcd[1], c = abcd[2]; //赋值给a，b，c
        string ide = ans + a + a + ans + a + b + ans + a + c + ans + b; //核心部分，十分精彩
        int pre = press(ide);
        if(pre == i + 2) ans += a;
        else if(pre == i + 1) ans += b;
        else ans += c;
    }
    if(press(ans + abcd[0]) == N) ans += abcd[0]; //判断最后一个字符
    else if(press(ans + abcd[1]) == N) ans += abcd[1];
    else ans += abcd[2];
    return ans; //返回
}
```

---

## 作者：Pufflet233 (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P13612)

## 题目简介

本题是 IOI 2018 Day 1 T1，赛时通过率为 55.16%，是一题交互题。

## 部分分数做法

#### 子任务 1

在子任务 1 中，限定 $N=3$，可以用最多 8000 次查询，一个很简单的做法就是暴力枚举全部可能的字符串，共 $4^3=64$ 个，如果返回 $3$ 就代表找到了正确的字符串。

代码：

```cpp
string guess_sequence(int N) {
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            for (int k = 0; k < 4; ++k) {
                string tmp = "";
                if (i == 0) tmp += 'A';
                else if (i == 1) tmp += 'B';
                else if (i == 2) tmp += 'X';
                else if (i == 3) tmp += 'Y';
                
                if (j == 0) tmp += 'A';
                else if (j == 1) tmp += 'B';
                else if (j == 2) tmp += 'X';
                else if (j == 3) tmp += 'Y';
                
                if (k == 0) tmp += 'A';
                else if (k == 1) tmp += 'B';
                else if (k == 2) tmp += 'X';
                else if (k == 3) tmp += 'Y';
                
                int x = press(tmp);
                if (x == 3) return tmp;
            }
        }
    }
}
```

当前分数：$5$。

#### 子任务 2——$4N$ 次数做法

我们一个一个位置确定 $S$ 的每一个字符是属于 `A`，`B`，`X` 和 `Y` 哪一种，由于有 4 种可能的字符，因此次数最多为 $4N$。

代码：
```cpp
string guess_sequence(int N) {
    string S = "";
    for (int i = 1; i <= N; ++i) {
        int x;
        x = press(S + 'A');  // 判断第i个字符是不是A
        if (x == i) {         // 如果等于i，就代表第i个字符是A
            S += 'A';
            continue;
        }
        x = press(S + 'B');  // 判断第i个字符是不是B
        if (x == i) {         // 如果等于i，就代表第i个字符是B
            S += 'B';
            continue;
        }
        x = press(S + 'X');  // 判断第i个字符是不是X
        if (x == i) {         // 如果等于i，就代表第i个字符是X
            S += 'X';
            continue;
        }
        x = press(S + 'Y');  // 判断第i个字符是不是Y
        if (x == i) {         // 如果等于i，就代表第i个字符是Y
            S += 'Y';
            continue;
        }
    }
    return S;
}
```
当前分数：$5+5=10$。

#### 子任务 2——$3N+1$ 次数做法

和 $4N$ 次数的做法类似，题目说了第一个字符不会重复出现，因此我们在除了判断第一个字符以外不需要判断 $4$ 次，而是 $3$ 次，总次数为 $3 \times (N-1)+4=3N+1$。

代码：
```cpp
string guess_sequence(int N) {
    string S = "";
    for (int i = 1; i <= N; ++i) {
        int x;
        if (S == "" || S[0] != 'A') {  // 判断，如果是第一次或者第一个字符不是A就执行
            x = press(S + 'A');        // 判断第i个字符是不是A
            if (x == i) {              // 如果等于i，就代表第i个字符是A
                S += 'A';
                continue;
            }
        }
        if (S == "" || S[0] != 'B') {  // 判断，如果是第一次或者第一个字符不是B就执行
            x = press(S + 'B');        // 判断第i个字符是不是B
            if (x == i) {              // 如果等于i，就代表第i个字符是B
                S += 'B';
                continue;
            }
        }
        if (S == "" || S[0] != 'X') {  // 判断，如果是第一次或者第一个字符不是X就执行
            x = press(S + 'X');        // 判断第i个字符是不是X
            if (x == i) {              // 如果等于i，就代表第i个字符是X
                S += 'X';
                continue;
            }
        }
        if (S == "" || S[0] != 'Y') {  // 判断，如果是第一次或者第一个字符不是Y就执行
            x = press(S + 'Y');        // 判断第i个字符是不是Y
            if (x == i) {              // 如果等于i，就代表第i个字符是Y
                S += 'Y';
                continue;
            }
        }
    }
    return S;
}
```

当前分数：$5+5=10$。

#### 子任务 2——$2N$ 次数做法

我们可以注意到，第一个字符并不需要判断 3 次，而是只需要判断两次即可。方法是先用 `AB` 判断，如果收到的答案不为 0，就代表首字母为 `A` 或 `B`，这个时候只需要用 `A` 判断一次即可确定第一个字符是 `A` 还是 `B`。如果一开始收到的答案为 0，代表第一个字符 `X` 或 `Y`，用同样的方法就可以用 2 次判断就找到首字母。

而对于后续的查询，也不用 3 次，而是 2 次即可，省去一次的原因是只要另外两个都不是，那么剩下的那个就一定是答案了。

因此总次数为 $2N$。

代码：
```cpp
string guess_sequence(int N) {
    string S;
    int x=press("AB");//查询第一个字符是不是AB其中之一
    if(x==0){//如果为0就不是
        x=press("X");
        if(x==1) S="X";
        else S="Y";
    }
    else{//否则就在AB里面
        x=press("A");
        if(x==1) S="A";
        else S="B";
    }
    for(int i=2;i<=N;++i){//从第二个字符开始查
        int cnt=0;//cnt记录查询次数
        if(S==""||S[0]!='A'){//判断，如果是第一次或者第一个字符不是A就执行
            x=press(S+'A');//判断第i个字符是不是A
            cnt++;//计数
            if(x==i){//如果等于i，就代表第i个字符是A
                S+='A';
                continue;
            }
        }
        if(S==""||S[0]!='B'){//判断，如果是第一次或者第一个字符不是B就执行
            x=press(S+'B');//判断第i个字符是不是B
            cnt++;//计数
            if(x==i){//如果等于i，就代表第i个字符是B
                S+='B';
                continue;
            }
        }
        if(cnt==2){//到了2次就判断是不是XY
            if(S[0]!='X') S+='X';
            else S+='Y';
            continue;
        }
        if(S==""||S[0]!='X'){//判断，如果是第一次或者第一个字符不是X就执行
            x=press(S+'X');//判断第i个字符是不是X
            cnt++;//计数
            if(x==i){//如果等于i，就代表第i个字符是X
                S+='X';
                continue;
            }
        }
        S+='Y';
    }
    return S;
}
```

当前分数：$5+25=30$。

## 正解——$N+2$ 次数做法

在数据范围里面，可以看到只要用小于等于 $N+2$ 次就能获得满分，思考一下 $+2$ 是怎么来的，通过上面的思路我们可以得知判断第一个字符需要两次，代表着接下来的 $N-1$ 个字符我们最多只能用 $N$ 次查询，也就是一个字符必须要 1 次查询就能找到。

重新读一遍题目，我们会发现还有一个条件我们没用到，就是查询最长的字符是 $4N$，这是一个很大的提示，提示我们可以把字符串拼 4 次然后加一些其他字符进行查询，使得我们能够一次查询就找到当前位置的字符，我们需要构造一个方案，使得返回的结果会因为下一个字符的不同而不一样。

下面设没找完的字符串前缀为 $c$，且 $S$ 的第一个字符为 `A`。

我们可以构造这样一个查询方式：

```cpp
press(c+"BB"+c+"BX"+c+"BY"+c+"Y");
```

设 $|c|$ 为 $c$ 的长度，如果返回的结果是 $|c|$，那么下一个字符就是 `X`；如果返回的结果是 $|c|+1$，那么下一个字符就是 `Y`，否则就是 `B`。

由于最后一个字符的查询用上述方案会超出 $4N$ 的长度限制，因此我们采用找第一个字符的方式去找最后一个字符，需要 2 次。

如果第一个字符不是 `A`，我们只需要把上述方案的第一个字符换成 `A` 即可。

总查询次数为 $N+2$。

最终代码：

```cpp
string guess_sequence(int N) {
    string S;
    string c[3] = {"B", "X", "Y"};  // 判断如果首字符不是A就用A把这里的首字符换掉
    if (press("AB") >= 1) {  // 判断是不是AB
        if (press("A") == 1) {
            S = "A";
        }
        else {
            S = "B";
            c[0] = "A";
        }
    }
    else {
        if (press("X") == 1) {  // 判断XY
            S = "X";
            c[1] = "A";
        }
        else {
            S = "Y";
            c[2] = "A";
        }
    }
    for (int i = 2; i < N; ++i) {  // 从第二个字符判断到第N-1个字符
        string s = S + c[0] + S + c[1] + c[0] + S + c[1] + c[1] + S + c[1] + c[2];  // 运用上述构造方案
        int x = press(s);
        if (x == i - 1) {
            S += c[2];
        }
        else if (x == i) {
            S += c[0];
        }
        else {
            S += c[1];
        }
    }
    if (N == 1) return S;  // 特判，如果只有一个字符，就返回第一个字符就行了
    if (press(S + c[0]) == N) return S + c[0];
    if (press(S + c[1]) == N) return S + c[1];
    return S + c[2];
}
```


这样我们就可以取得这题的 AC 了。

最终分数：$5+95=100$。

---

## 作者：WsW_ (赞：2)

### 前言
可能有人一眼秒了，但我没秒掉。让我们有逻辑地推理出结论。

---
### 思路
发现金币数和 $S$ 最长的前缀有关，这告诉我们得按顺序从左往右推。因为如果左边的不知道，金币数就会被左边未知的位置卡死。  
很容易想到可以二分两次求出 $S$ 的首位，接下来我们还剩 $N$ 次询问，要求出 $N-1$ 位。这似乎暗示我们要一次询问就求出一位，但这样多给了一次询问，哪来的呢？  
不妨设 $S$ 的首位为 $\mathtt{A}$，之后的字母只可能是 $\mathtt{B/X/Y}$。  
可以发现，当我们求出前 $N-1$ 位，还剩一位的时候，我们也得二分两次才能求出最后一位。  
所以问题变成了 $N-2$ 次询问求中间 $N-2$ 位，一次询问必须求出一位。  

假设我们已经求出的部分为 $T$，假设这部分的金币数为 $t$。  
每次询问长度不超过 $4N$，这暗示每次询问我们可以扔 $4$ 个串进去。  
先考虑扔 $4$ 个长度相同的串进去，那么至少得在 $T$ 后面再添加两个字母。添加两个字母有 $9$ 种可能，我们希望能通过两次询问确定是这 $9$ 种可能中的哪一种。  
考虑得要尽量均摊，我们希望第一次询问能把范围缩小到 $3$ 种。这是不可能的，因为如果返回的金币数为 $t+2$，那我们就面对了询问中的 $4$ 种可能。我们想通过一次询问确定是这 $4$ 种可能中的哪一种，这是不可能的。因为返回的金币只会是 $t,t+1,t+2$ 中的一种，根据鸽巢原理，必定至少会有两种可能无法区分。  

类似地，询问时扔 $4$ 个长度相同的串进去无法达成目的。  

考虑扔 $4$ 个长度不同的串进去。  
还是想要一次询问确定一位，而一位有 $3$ 种可能，所以返回值必须至少也有 $3$ 种可能。显然返回值的可能取值必定是连续的。  
扔进去的串越长情况就越多，就越不好判断。所以我们希望返回值的可能取值为 $t,t+1,t+2$，并能通过这三种返回值来求出下一位。  
既然返回值有可能是 $t$，说明有一种字母不作为接在 $T$ 后的第一个字母，不妨设它为 $\mathtt{B}$。  
返回值有可能是 $t+1$，说明有一种字母直接接在 $T$ 后，且之后不再接任何东西，不妨设它为 $\mathtt{X}$。  
返回值有可能是 $t+2$，说明有一种字母接在 $T$ 后，之后还得接别的东西。考虑到返回值是 $t+2$，所以在它之后还接所有的三种字母。  

构造就出来了，每次询问扔进去的 $4$ 个串分别为 $T+\mathtt{B}$，$T+\mathtt{XB}$，$T+\mathtt{XX}$，$T+\mathtt{XY}$。如果返回值是 $t$，则下一位是 $\mathtt{Y}$；如果返回值是 $t+1$，则下一位是 $\mathtt{B}$；如果返回值是 $t+2$，则下一位是 $\mathtt{X}$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int press(string p);

string guess_sequence(int N){
	string c[4]={"A","B","X","Y"};
	string s;
	int t=press("AB");
	if(!t){
		t=press("X");
		if(t)s.push_back('X');
		else s.push_back('Y');
	}
	else{
		if(t==1){
			t=press("A");
			if(t)s.push_back('A');
			else s.push_back('B');
		}
		else s="AB";
	}
    if(N==s.length())return s;
	for(int i=0;i<3;i++)if(c[i][0]==s[0])c[i]="Y";
	while(s.length()<N-1){
		string tst=s+c[0]+s+c[1]+c[0]+s+c[1]+c[1]+s+c[1]+c[2];
		t=press(tst)-s.length();
		if(t==2)s+=c[1];
		if(t==1)s+=c[0];
		if(t==0)s+=c[2];
	}
	if(press(s+c[0])==N)s+=c[0];
	else if(press(s+c[1])==N)s+=c[1];
	else s+=c[2];
    return s;
}
```

---

## 作者：WuMin4 (赞：1)

## 思路

很显然我们需要先确定 $S$ 的第一个字符。

一种最简单的想法是直接把每个字符都询问一遍，最后一个字符可以通过排除法求出，则最多需要 $3$ 次询问求出 $S$ 的第一个字符。即使 $3$ 次很少，我们也要考虑优化。发现一次询问同时确定两个字符是否存在是更好的，因此我们可以询问 `AB`。若分数为 $0$，则第一个字符肯定为 `X` `Y` 中的一个，否则为 `A` `B` 中的一个，因此我们只要 $2$ 次询问即可确定 $S$ 的第一个字符。此时 $S$ 中还剩下 $N-1$ 个字符未确定，剩余 $N$ 次询问。

根据题面得出，$S$ 的首字符不会在串中重复出现。因此剩下的字符只有 $3$ 种可能。为方便起见，假设确定的第一个字符为 `A`。通过询问 `AB` 和 `AX` 我们可以知道该字符是否为 `B`，`X`。`Y` 同理排除得出，但是连起来询问就不能确定。如果询问 `ABAX` 的分数为 $2$，则该位可能为 `B` 也可能为 `X`，我们需要一种方法在一次询问中区分出 `B` 和 `X`。

我们可以考虑把获得的分数与字符对应起来，于是可以让 `B` 匹配 $1$ 位，`X` 匹配 $2$ 位，即询问 `ABAXBAXXAXY`。这里我们枚举了 `X` 后面的所有可能字符，则不管字符 `X` 后面为什么字符，它都会匹配 $2$ 位，得分为 $3$，由此我们便区分出了 `B` 和 `X`。

由于区分 `B` 和 `X` 需要多枚举一位字符，我们只能确定 $N-1$ 位字符，共花费了 $N$ 次操作，还剩下 $1$ 个字符未确定，剩余 $2$ 次操作。于是直接用最朴素的方法枚举最后一位字符，刚好用 $2$ 次操作确定 $1$ 个字符。$N+2$ 次询问确定了字符串 $S$，可以通过本题。

## 代码

注：含大量打表，可能比较冗余。

```cpp
#include <bits/stdc++.h>
using namespace std;
int press(string p);
string guess_sequence(int N){
	int x;
	string res;
	x=press("AB");
	if(x==0){
		x=press("X");
		if(x==1) res="X";
		else res="Y";
	}
	else if(x==1){
		x=press("A");
		if(x==1) res="A";
		else res="B";
	}
	else if(x==2)
		res="AB";
	if(res.length()==N) return res;
	for(int i=res.length();i<N-1;i++){
		if(res[0]=='A'){
			x=press(res+"B"+res+"XB"+res+"XX"+res+"XY");
			if(x==res.length()) res+="Y";
			else if(x==res.length()+1) res+="B";
			else if(x==res.length()+2) res+="X";
		}
		else if(res[0]=='B'){
			x=press(res+"A"+res+"XA"+res+"XX"+res+"XY");
			if(x==res.length()) res+="Y";
			else if(x==res.length()+1) res+="A";
			else if(x==res.length()+2) res+="X";
		}
		else if(res[0]=='X'){
			x=press(res+"A"+res+"BA"+res+"BB"+res+"BY");
			if(x==res.length()) res+="Y";
			else if(x==res.length()+1) res+="A";
			else if(x==res.length()+2) res+="B";
		}
		else if(res[0]=='Y'){
			x=press(res+"A"+res+"BA"+res+"BB"+res+"BX");
			if(x==res.length()) res+="X";
			else if(x==res.length()+1) res+="A";
			else if(x==res.length()+2) res+="B";
		}
	}
	if(res[0]=='A'){
		x=press(res+"B");
		if(x==res.length()+1) return res+"B";
		x=press(res+"X");
		if(x==res.length()+1) return res+"X";
		return res+"Y";
	}
	else if(res[0]=='B'){
		x=press(res+"A");
		if(x==res.length()+1) return res+"A";
		x=press(res+"X");
		if(x==res.length()+1) return res+"X";
		return res+"Y";
	}
	else if(res[0]=='X'){
		x=press(res+"A");
		if(x==res.length()+1) return res+"A";
		x=press(res+"B");
		if(x==res.length()+1) return res+"B";
		return res+"Y";
	}
	else if(res[0]=='Y'){
		x=press(res+"A");
		if(x==res.length()+1) return res+"A";
		x=press(res+"B");
		if(x==res.length()+1) return res+"B";
		return res+"X";
	}
}
```

---

## 作者：pbds_ (赞：0)

这道题要求我们在 $n+2$ 次询问之内找出一个长度为 $n$ 的字符串 $S$，字符串只可能包含 `ABXY` 中的字符，且首字符不会在后面出现。每次询问可以询问一个长度不超过 $4n$ 的字符串 $p$，返回 $p$ 的子串中与 $S$ 的前缀匹配的最长长度。

我们很容易能得出来一个 $4n$ 次询问的做法：每次尝试确定下一位字符是什么。可以得到 $10$ 分。

考虑优化。首先可以通过两次询问找出隐藏字符串的第一个字符。具体询问方式如下。

- 先询问 `AB`。
  - 如果返回值大于 $0$：询问 `A`。返回 $1$ 说明首字符是 `A`，否则是 `B`。
  - 否则：询问 `X`。返回 $1$ 说明首字符是 `X`，否则是 `Y`。

注意到一个关键条件：$S$ 的首字符不会在 $S$ 中重复出现。因此，把除 $S$ 的首字符外的三个字符分别记作 $a_1$、$a_2$、$a_3$。

考虑如何每一次询问都能确定一个字符。我们设已经确定的 $S$ 的前缀为 $s$，$s$ 的长度为 $m$。由于 $S$ 的首字符不会重复出现，我们可以这样询问：$s+a_1+a_1+s+a_1+a_2+s+a_1+a_3+s+a_2$。这样如果下一个字符是 $a_1$，返回值就是 $m+2$（因为 $S$ 再往后不会出现 $S$ 的首字符，所以不会更多），如果下一个字符是 $a_2$，返回值是 $m+1$，如果是 $a_3$ 返回值就是 $m$。这样一次询问的长度是 $4m+7$ 的。最后一个字符不适用这种方法，因此可以使用类似询问第一个字符的方式询问最后一个字符。

总询问次数 $n+2$，可以得到 $100$ 分。

```cpp
#include<bits/stdc++.h>
using namespace std;
int press(string);
string guess_sequence(int n){
    char _1,_2,_3;
    string ans="";
    if(press("AB")){
        if(press("A"))ans="A",_1='B',_2='X',_3='Y';
        else ans="B",_1='A',_2='X',_3='Y';
    }
    else{
        if(press("X"))ans="X",_1='A',_2='B',_3='Y';
        else ans="Y",_1='A',_2='B',_3='X';
    }
    if(n==1)return ans;
    for(int i=2;i<n;i++){
        int z=press(ans+_1+_1+ans+_1+_2+ans+_1+_3+ans+_2)-i;
        if(z){
            if(z>0)ans+=_1;
            else ans+=_3;
        }
        else ans+=_2;
    }
    if(press(ans+_1)==n)return ans+_1;
    if(press(ans+_2)==n)return ans+_2;
    return ans+_3;
}
```

---


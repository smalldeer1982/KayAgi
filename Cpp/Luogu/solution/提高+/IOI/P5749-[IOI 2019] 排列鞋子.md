# [IOI 2019] 排列鞋子

## 题目描述

**由于洛谷数据点限制，本题仅评测其中的 $100$ 个数据点。**

如果需要测试全部数据，有以下两道题：

1. [Subtask 1-3](/problem/U98795)
2. [Subtask 4-6](/problem/U98796)

两题满分均为 $50$ 分，包含 Subtask中所有的测试点。

---

Adnan 拥有巴库最大的鞋店。现在有一个装着 $n$ 双鞋的箱子刚运到他的鞋店。每双鞋是大小相同的两只：一只左脚，一只右脚。Adnan 把这 $2n$ 只鞋排成一行，该行总共有 $2n$ 个**位置**，从左到右编号为 $0$ 到 $2n-1$ 。

Adnan 想把这些鞋子重新排成**合法的排列**。一个排列是合法的，当且仅当对于所有的 $i(0\leqslant i \leqslant n - 1)$，以下条件都成立：

- 在位置 $2i$ 和 $2i+1$ 上的鞋子大小相同；
- 在位置 $2i$ 上的鞋子是一只左脚鞋；
- 在位置 $2i+1$ 上的鞋子是一只右脚鞋。

为实现上述目标，Adnan 可以做一系列对调。在每次对调中，他选择当前**相邻**的两只鞋进行对调（也就是把它们拿起来，然后将每只鞋子放回到另一只鞋子原来的位置上）。两只鞋子是相邻的，当且仅当其位置编号的差为 $1$。

请求出 Adnan 最少要做出多少次对调，才能得到一个合法排列。

## 说明/提示

**样例说明 1**

Adnan 可以通过 $4$ 次对调而得到一个合法的排列。

例如，他可以先对调 $1$ 和 $-1$，再对调 $1$ 和 $-2$，再对调 $-1$ 和 $-2$。最后对调 $-2$ 和 $2$。随后他就可以得到合法的排列 。无法用少于 $4$ 次对调就得到合法的排列，因此输出 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ybs09z2e.png)

**样例说明 2**

Adnan 可以对调在位置 $2$ 和 $3$ 上的鞋子来得到合法的排列$[-2,2,-2,2,-2,2]$，因此应当输出 $1$。

**数据范围**

对于所有数据：

- $1\leqslant n\leqslant10^5$；
- 对于所有$i(0\leqslant i\leqslant 2n-1)$，都有$1\leqslant \left|S_{i+1}\right|\leqslant n$；
- 总有某个合法的排列可以经由一系列对调而得到。

详细子任务附加限制与分值如下表：

| 子任务编号 | 附加限制 | 分值 |
|:---:|:---:|:---:|
| $1$ | $n=1$ | $10$|
|$2$|$n\leqslant8$|$20$|
|$3$|所有鞋子大小都是相同的|$20$|
|$4$|所有在位置 $0,\dots,n-1$ 上的鞋都是左脚鞋，而在位置 $n,\dots,2n-1$ 上的鞋都是右脚鞋。而且对于所有 $i(0\leqslant i\leqslant n-1)$，在位置 $i$ 和 $i+n$ 上的鞋子大小相同|$15$|
|$5$|$n\leqslant10^3$|$20$|
|$6$|无附加限制|$15$|

## 样例 #1

### 输入

```
2
2 1 -1 -2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
3
-2 2 2 -2 -2 2
```

### 输出

```
1
```

# 题解

## 作者：q1uple (赞：20)

怎么第一篇题解折磨抽象，切了来写一篇题解。

首先，每一次两只鞋子的匹配必须是相邻的。证明是容易的，比如 $x1$，$y1$，$x2$，$y2$ 这一个序列，如果匹配 $x1$，$y2$ 和 $x2$，$y1$，区间是有交集的。而匹配相邻的就是无交集的。

但是接下来还有一个问题，$x1$，$y1$ 是谁找谁。

接着我们发现这个东西很像冒泡排序，回顾一下冒泡排序的过程，交换的过程都是单向的从一边到另外一边，如果不这样，那么我们就需要花费更多的代价。

所以我们所有的操作都是单向的，且与最近能匹配的匹配。

注意到数据范围，我们要优化。

我们可以提前记录所有鞋子的位置（开 $n$ 个 vector），接着从右往左对于每个鞋子，找到未匹配的一个鞋子（我们把匹配过的鞋子删了），注意到直接计算中间剩余的鞋子很慢，我们可以使用数据结构进行优化（比如树状数组），最初把所有数赋值为 $1$，如果匹配就为 $0$。区间求和即可。

这样我们就做完了，下面是代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5,mod=1e9+7,INF=2e9;
typedef unsigned long long ull;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<double,double> pdd;
#define qmi(a,b) a=min(a,b)
#define qma(a,b) a=max(a,b)
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define atrep(i,l,r) for(int i=(r);i>=(l);i--)
#define vec vector<int>
#define pb push_back
char eof_flag;
template<typename T>char read(T*s){if(eof_flag)return 0;T k=0,f=1;
	char c=getchar();while(c!='-'&&(c<'0'||c>'9')){if(c==EOF){eof_flag=1;return 0;}
		c=getchar();}f=(c=='-')?-1:1;k=(c=='-')?0:(c^48);c=getchar();while(c>='0'&&c<='9')k=(k<<1)+(k<<3)+(c^48),c=getchar();
	if(c==EOF)eof_flag=1;(*s)=f>0?k:-k;return 1;}
template<typename T>void pnt(T x){static char stk[22],*top;for(top=stk,x<0?(putchar('-'),x=-x):0;x;*top++=x%10+'0',x/=10);for(top==stk?putchar('0'):0;top>stk;putchar(*--top));putchar('\n');}
int c[N],vis[N],res=0,indax[N];
vec ve[N];
int n;
struct BIT{
	int a[N];
	void add(int x,int d){while(x<=2*n){a[x]+=d;x+=(x&-x);}return;}
	int ask(int x){int res=0;while(x){res+=a[x];x-=(x&-x);}return res;} 
}T;
signed main(){
	cin>>n;
	rep(i,1,2*n){
		cin>>c[i];
		ve[c[i]+n].push_back(i);// 因为有负数,下标偏移
		T.add(i,1);
	}
	atrep(i,1,2*n){
		if(vis[i])	continue;
		ve[c[i]+n].pop_back();
		int now=ve[-c[i]+n].back();
		ve[-c[i]+n].pop_back();
		vis[now]=1;
		T.add(now,-1);
		res+=T.ask(i-1)-T.ask(now-1);
		if(c[i]<0)	res++;
	}
	cout<<res<<"\n";
}
```

---

## 作者：reyik (赞：19)

## IOI也有可做题！

贪心就行了

从后往前，每一个点找一个最近的能够匹配的，移过来，更新答案

我们用每一个$vector$存下尺码为$i$的鞋的出现位置，因为从左到右插入，所以就一定从小到大

然后我们从后往前找，我们找跟他匹配的尺码的$vector$中的最后一个元素，肯定最近

然后更新答案就树状数组维护

代码：

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <vector>
using namespace std;
vector<int>pos[300005];
int n;
int a[300005],t[1000005];
long long ans=0;
bool vis[300005];
int lowbit(int x) {
	return x&(-x);
}
void add(int x,int y) {
	for (int i=x;i<=n;i+=lowbit(i)) t[i]+=y;
}
int query(int x) {
	int res=0;
	for (int i=x;i;i-=lowbit(i)) res+=t[i];
	return res;
}
int main() {
	scanf("%d",&n);
	n<<=1;
	for (register int i=1;i<=n;++i) {
		scanf("%d",&a[i]);
		pos[a[i]+n].push_back(i);
		add(i,1);
	}
	for (register int i=n;i>=1;--i) {
		if(vis[i]) continue;
		vis[i]=1;
		pos[a[i]+n].pop_back();
		int res=pos[n-a[i]].back();
		pos[n-a[i]].pop_back();
		vis[res]=1;
		ans=ans+(long long)(query(i-1)-query(res))+((a[i]<0)?1:0);
		add(res,-1);
	}
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：vijone (赞：13)

题解：[P5749 [IOI2019]排列鞋子](https://www.luogu.com.cn/problem/P5749)

约定：下文统一用$x$和$-x$来表示鞋的大小，其中$x>0$。且$-x$表示左脚鞋，$x$表示右脚鞋。

#### 思路：

第一步：**从左向右**遍历，对于每一个 $x>0$ 的鞋，找到**最左边**的可以与它配对的鞋（是 $-x$ 且没有与其他鞋配对），将两者配对。

（我们暂时只把两者标记为互相配对，具体计算和交换鞋子等操作在以后的步骤中）

解释：从左向右配对而每次找最左边的一定是最优解。如下图：显然绿色长度之和小于蓝色长度之和。也就是说，上文所述的策略实际上是避免了两个相距很远的鞋子互相配对。而且将其推广到所有情况，都成立。（严格数学证明可以参考其他题解）

![](https://s1.ax1x.com/2020/07/23/UXEo1P.png)

第二步：再次**从左向右**遍历，每遇到一个没有操作过的鞋（不论左右脚鞋）就将与它配对的鞋换到它边上。并将两者标记为“操作过”。（这一步骤开始时，所有鞋都看作未操作过）

解释：设找到的鞋是 $a$，与 $a$ 配对的鞋是 $b$ 。因为是从左向右遍历，所以 $a$ 和 $b$ 相比一定更靠左，且只有 $a$ 的右侧有 没有操作过的鞋 。把 $b$ 换过来，相当于 $a$ 的右侧少了一只鞋，且 $a$ 和 $b$ 不可能在没有没有操作鞋中间。使得对后面的交换而言，实际上就可以忽略 $a$ 和 $b$ ，而且也缩短了别的未操作的鞋子之间的距离。（否则，将 $a$ 换到 $b$ 处，则会导致后面的匹配交换次数增加）

第三步：在第二步的基础上计算移动次数。

代码实现：

第一步：使用链表（本文使用前向星，也可以使用 vector  或 STL 中的链表等）存储尺码为 $x$ 的鞋的出现位置。那么即可实现 $O(1)$ 查询到当前最左边的可配对的鞋。    
开一个数组 $b[]$ 存储每一只鞋它的搭档的位置。如 $a$ 与 $c$ （ $a$ 与 $c$ 为下标）配对，则 $b[a]=c;b[c]=a$      
按照思路中说的遍历一遍，处理好$b$数组即可。

第二步：（将思路中的第二步与第三步结合）：参考思路中的第二步。显然不能真的去模拟交换的过程（显然超时）。将两只鞋移到一起的交换次数就等于两者下标之差。但是，根据上文可知，两只鞋之间的距离会因为先于它们的鞋的交换而改变，而且可以知道现在的两只鞋中间每有一只已经标记过的鞋，两者之间的距离就会少 $1$ 。    
使用树状数组维护未标记的鞋的前缀和，如果某只鞋（还有它的搭档）已经被标记，那么就树状数组单点修改（减$1$）即可。同时，树状数组可以一边遍历，一边统计答案。


具体细节看代码，时间复杂度在 $ O(n \ log_2 \ n)$ 左右。：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int e=(1e5)*4+10;
int n,a[e];
int cnt=0,head[e];//
struct nod//前向星 可以把它看成链表
{
    //可以通过head数组加上for循环来遍历每一个
    int next,pl;// pl 指的是当前访问到的鞋在原来数列中的下标，next则相当于指向下一个的指针
}s[e];
int b[e];//记录每一只鞋的对应鞋的下标
long long ans=0,tr[e];
//tr数组就是树状数组维护的部分
bool vis[e];//在第二步中保存 一只鞋是否操作过 的数组
void add(int x,int ii)
{
    cnt++;
    s[cnt].next=head[x];
    s[cnt].pl=ii;
    head[x]=cnt;
}
int lowbit(int x)
{
    return x&(-x);
}
void xg(int x,int va)//树状数组单点修改
{
    for(int i=x;i<=n;i+=lowbit(i))
    {
        tr[i]+=va;
    }
}
long long sum(int x)//树状数组区间求和
{
    long long res=0;
    for(int i=x;i>0;i-=lowbit(i))
    {
        res+=tr[i];
    }
    return res;
}
int main()
{
 	cin>>n;
 	n=n*2;//一共有 n 双 鞋。
     ans=0;
 	for(int i=1;i<=n;i++)
 	{
 		cin>>a[i];
         a[i]+=n;//对负数进行处理，避免数组越界
	 }
     for(int i=n;i>0;i--)
     {
         add(a[i],i);//由于前向星的特殊性质（后进入的先访问），为了下面方便的从左向右遍历，需要从后向前（倒序）存储
     }
    for(int i=1;i<=n;i++)
    {
        if(a[i]>n)//找到每个正数，找到它对应的负数。
        {
            int u=2*n-a[i];//注意：找到负数对应的值，别写错。
            int tmp=s[head[u]].pl;
            b[i]=tmp;b[tmp]=i;
            if(tmp>i)ans++;
            //假如负的鞋子在正的鞋子的右边，那么在正的和负的鞋子在交换到一起后还需要再一次交换（因为要求负的在左，正的在右）
            head[u]=s[head[u]].next;//修改最左边的与 i 能配对的 的鞋的位置，为下一次配对做准备。
        }
    }
    memset(vis,false,sizeof(vis));//全部标记为未操作
    for(int i=1;i<=n;i++)
    xg(i,1);//最开始，全部都没有操作过
    for(int i=1;i<=n;i++)
    {
        if(vis[i]==true)continue;
        long long tmp=sum(b[i]-1)-sum(i);//注意：当前鞋交换所需的次数是两者中间的鞋的个数（不包括两边当前的鞋）所以前缀和的下标要注意。
        //显然 b[i] 在 i 的后面，因为 i 先被遍历到
        ans+=tmp;
        vis[i]=true;vis[b[i]]=true;//标记为已操作
        xg(i,-1);xg(b[i],-1);//这两只鞋操作过以后，它们就不能在另外的操作中计算了（具体参考上文），所以要减掉。
    }
    cout<<ans;
	return 0;
}
```


---

## 作者：Adolfo_North (赞：6)

算是一种新思路吧。

题目要求我们求最少的对调次数，想到了什么？求逆序对个数，我们只需将原来的 $S_i$ 数组转化一下，求其逆序对个数即可。

转化规则为：从头开始，对于每个还未被赋值的 $S_i$ 找在它后面离它最近的并于其符号相反的 $S_i$。将 $sum+2$（其初值为 $0$），其中的正数赋值为 $sum$，负数赋值为 $sum-1$。

例如样例一，赋值完毕的数组为：`2 4 3 1`。

样例二为 `1 2 4 3 5 6`。

正确性的证明：因为每次找的都是最近的 $S_i$，所以总交换次数最少。而数组的重新排列保证了左右两只鞋子分配到的数字一定是 $sum-1$ 与 $sum$。此时问题就变成了求将一个无序的序列转化为有序，最少需要几次交换，求逆序对个数即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+7;
map<int,list<int> > m;
int a[N],tr[N],s[N];
bitset<N> vis;
int n;
void upd(int w,int x){
	for(int i=w;i<=n;i+=(i&-i)) tr[i]+=x;
}
int query(int x){
	int ans=0;
	while(x>0){
		ans+=tr[x];
		x-=(x&-x);
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	n*=2;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		m[s[i]].push_back(i);
	}
	for(int i=1,sum=0;i<=n;i++){
		if(vis[i]) continue;
		int j=m[-s[i]].front();//找在它后面离它最近的并于其符号相反的 Si.
		m[s[i]].pop_front();
		m[s[j]].pop_front();
		vis[i]=vis[j]=1;
		sum+=2;
		if(s[i]<0) a[i]=sum-1,a[j]=sum;
		else a[j]=sum-1,a[i]=sum;
	}
	//树状数组求逆序对。
	long long ans=0;
	for(int i=1;i<=n;i++) {
		upd(a[i],1);
		ans+=i-query(a[i]);
		cout<<a[i]<<' ';
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：zhouhuanyi (赞：5)

$[IOI2019]$排列鞋子

链接:https://www.luogu.com.cn/problem/P5749

题目描述:
将一个序列$A$交换到满足对于任意的$i(1<=i<=n/2)$满足
$a_{i}=-a_{i\times 2}$且$a_{i}<0$,求至少要交换多少次。

题解:交换多少次就等价于交换得到的排列的逆序对数量,我们可以从这构造一个这样的排列入手。

引理$1$:每一组$a_{i}$相同的左脚鞋与右脚鞋匹配时,从小到大依次匹配最优。

证明:对于每一组匹配$(i,j)$,其贡献为剩余的满足$[k<=i]$的与满足$[k<=j]$的和。因为我们每一次一定是贪心的选取两个贡献最少的,所以每一次要求出满足
$[k<=i]+[k<=j]$的最小$(i,j)$。考虑反证:假设我们选取$a_{i}$相同的不依次匹配的数对$(i,j)$更优,令$a_{i}$依次匹配时$i$匹配了$t$,则$t<=j$。那么$[k<=i]+[k<=t]<=[k<=i]+[k<=j]$,则答案此时便的更劣了,矛盾,则该假设不成立。

引理$2$:按照引理$1$匹配之后,令$b_{i}$表示左脚鞋$i$匹配的数,则以$min(a_{i},a_{b_{i}})$按顺序排列更优。

证明:~~不会,打表吧~~。

根据上述引理:我们可以将逆序对最小的排列求出,树状数组求该排列的逆序对即可。
```
#include<iostream>
#include<set>
#include<queue>
#include<algorithm> 
using namespace std;
struct node
{
	int l,r;
	bool operator < (const node &t)const
	{
		return min(l,r)<min(t.l,t.r);
	}
};
node t[1000001];
vector<int>s[1000001];
int n,a[1000001],len,d[2000001];
long long c[1000001],S,ans;
int lowbit(int x)
{
	return x&(-x);
}
void add(int x,int y)
{
	for (;x<=n;x+=lowbit(x))
		c[x]+=y;
	return;
}
long long sum(int x)
{
	S=0;
	for (;x>=1;x-=lowbit(x))
		S+=c[x];
	return S;
}
int main()
{
	cin>>n;
	n*=2;
	for (int i=1;i<=n;++i)
	{
		cin>>a[i];
		if (a[i]<0)
			s[-a[i]].push_back(i);
	}
	for (int i=n;i>=1;--i)
	{
		if (a[i]>0)
		{
			t[++len].l=s[a[i]][s[a[i]].size()-1];
			s[a[i]].pop_back();
			t[len].r=i;
		}
	}
	sort(t+1,t+n/2+1);
	for (int i=1;i<=n/2;++i)
	{
		d[i*2-1]=t[i].l;
		d[i*2]=t[i].r;
	}
	for (int i=1;i<=n;++i)
	{
		ans+=sum(n+1-d[i]);
		add(n+1-d[i],1);
	}
	cout<<ans<<endl;
	return 0;
}

---

## 作者：clamee (赞：5)

IOI居然有我会的题！！！

找到第一只鞋和右边第一个与它size相同的，然后将他们配对即可。

相当于把右边一只移到最左，此时显然对答案贡献最小。

我们可以把这一操作看成删除两只鞋子。

代码写的好像有点丑。
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[200005];
inline int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
int tree[200005],l[200005],ans,vis[200005];
void add(int x,int k)
{
	if(x<=0)return;
	while(x<=n)
	{
		tree[x]+=k;
		x+=x&-x;
	}
}
int sum(int x)
{
	int re=0;
	while(x)
	{
		re+=tree[x];
		x-=x&-x;
	}
	return re;
}
struct ss{
	int a,b;
	bool operator <(const ss r)const{
		if(a==r.a)return b<r.b;
		return a<r.a;
	}
};
multiset<ss> s;
#define IT multiset<ss>::iterator
signed main()
{
	n=read()<<1;
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		add(i,1);
		s.insert((ss){a[i],i});
	}
	for(int i=1;i<=n;i++)
	{
		if(vis[i])continue;
		IT it=s.lower_bound((ss){-a[i],0});//找鞋
		l[i]=it->b;s.erase(it);//扔出去
		it=s.lower_bound((ss){a[i],0});s.erase(it);
		ans+=sum(l[i])+(a[i]>0)-2;
		add(l[i],-1);
		add(i,-1);
		vis[l[i]]=1;
	}
	cout<<ans;
}

```

---

## 作者：一架飞机 (赞：4)

上面的巨佬把贪心过程和实现讲得很详细了，我就来总结一些技巧以及证明吧。

（设 $(x,y)$ 表示这一对鞋子分别在原数组中的位置）

- 先不考虑一对鞋子内部的顺序（左右），可以最后单独算。

- 两个排列 $a$ 表示原来鞋子摆放顺序，$b$ 表示最终的排列方案（$a$，$b$ 里装的是鞋子（一个鞋子一个数））。设 $c[i]$ 为 $a[i]$ 在 $b$ 中的位置，$d[i]$ 为 $b[i]$ 在 $a$ 中的位置。所以 $c$ 的逆序对数 = $d$ 的逆序对数。这里研究 $c$ 的逆序对数就比研究 $d$ 的逆序对数方便，因为 $b$ 排列中，两个鞋鞋是放在一起的，只用研究一对相邻的数。

- 只用研究相邻的两对鞋子，因为如果不这样排，一定有相邻的两对鞋子逆序（模型：一个数列如果不是升序的，就一定存在相邻的两对鞋子）。只要证明：把相邻的逆序的鞋子对反转不会变差（具体可以看[这位大佬的](https://blog.csdn.net/qq_39972971/article/details/99441827)）

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>void read(T&x){
	x=0;char ch=getchar();bool f=0;
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	x=f?-x:x;
}
const int M=2e5+5;
int a[M],del[M],nx[M][2],c[M],d[M];vector<int> b[M][2];
int cc[M]={0,1,5,3,4,6,2};
ll ans;
void solve(int l,int r){
	if(l>=r)return;
	int mid=(l+r)/2;solve(l,mid);solve(mid+1,r);
	ll preans=ans;
	for(int i=l;i<=mid;i++){
		int k=lower_bound(c+mid+1,c+r+1,c[i])-c-mid-1;
		ans+=k;
	}
	int la1=l,la2=mid+1;
	for(int i=l;i<=r;i++){
		if(la2>r||(la1<=mid&&c[la1]<c[la2]))d[i]=c[la1++];else d[i]=c[la2++];
	}
	for(int i=l;i<=r;i++)c[i]=d[i];
}
int main(){
	int n;read(n);n*=2;
	for(int i=1;i<=n;i++){
		read(a[i]);
		if(a[i]<0)b[-a[i]][0].push_back(i);
		else b[a[i]][1].push_back(i);
	}
	int la=1;
	for(int i=1,x,y,k;i<=n;i++){
		if(del[i])continue;
		if(a[i]<0)x=-a[i],y=0;
		else x=a[i],y=1;
		k=b[x][!y][nx[x][!y]++];
		nx[x][y]++;
		del[k]=1;
		if(y==0)c[la]=i,c[la+1]=k;
		else c[la]=k,c[la+1]=i;
		la+=2;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：suzhikz (赞：3)

比较水的蓝题。

首先，假设我们按照某个顺序做，假设我们从后往前，显然我们要把最近的配对的移动给他（更远的一定是不优的）。

然后前面往后面移动一定比后面往前面移动更加优秀，这两种移动剩余元素相对位置不变，只是后面往前面移动会在中间插几个元素，除了增加答案没有任何用处，所以肯定不优秀。

为啥要从后往前呢？因为在中间的序列做操作其实会把序列分成两块，显然没有在一边一直动优秀。


```cpp
//我永远喜欢艾莉丝!
#include<bits/stdc++.h>
#define int long long
#define reg register
#define db double
#define il inline
using namespace std;
void read(int &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
//void read(ll &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
const int N=4e5+5,M=2e5;
int n,a[N];
vector<int>st[N*2];
int tree[N];
int lowbit(int x){
	return x&(-x);
}
void update(int x,int w){
	while(x<=n){
		tree[x]+=w;
		x+=lowbit(x);
	}
}
int query(int x){
	int re=0;
	while(x){
		re+=tree[x];x-=lowbit(x);
	}return re;
}
int ans;
struct lin{
	int l[N],r[N],w[N];
	void init(){
		r[0]=1;l[n+1]=n;
		for(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;
	}
	void erase(int pos){
		r[l[pos]]=r[pos];
		l[r[pos]]=l[pos];
	}
}T;
signed main(){
	read(n);n*=2;
	for(int i=1;i<=n;i++){
		read(a[i]);if(a[i]<0)a[i]=-(M+a[i]);
		st[a[i]+M].push_back(i);
	}
	T.init();
	for(int i=n;i>=1;i--)T.w[i]=a[i]+M;
	for(int i=n;i>=1;i-=2){
//		cout<<i<<endl;
		int u=T.w[T.l[n+1]];st[u].pop_back();T.erase(T.l[n+1]); 
		if(u>M){
			u-=M;
		}else{
			u+=M;
		}T.erase(st[u][st[u].size()-1]);
		int pos=st[u][st[u].size()-1];st[u].pop_back();
		update(pos,1);
		pos-=query(pos-1);
		if(u<=M)ans+=i-1-pos;
		else ans+=i-pos;
//		cout<<u<<' '<<ans<<endl;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：木木！ (赞：3)

一道不错的贪心题，证明挺好玩。

我做这道题的时候首先是从前缀和来考虑的。如果 $s_i$ 是第 $i$ 个位置的前缀和，那么一个排列合法当且仅当 $s_{2i}<0$ 且 $s_{2i+1}=0$，交换两个相邻数就等价于在前缀和的某一个位置上减少某一个数。然后就卡着了。

换一种思路，可以考虑贪心。直觉告诉我，如果每次都将当前排列中的第一个配对，那么最终结果一定最优。

证明如下：

定义“排列 $p_1$ 对于排列 $p_2$ 的逆序对”为一个元素对 $(i,j)$，使得在 $p_1$ 中 $i$ 在 $j$ 前，$p_2$ 中 $i$ 在 $j$ 后。

假设最终答案排列中当前排列的第一个不是配对在最前面，那么他一定配对在某个地方。设这个最终排列为 $p_{ans}$，当前排列为 $p_{cur}$。

$p_{cur}$ 中的第一个元素设为 $x$，在 $p_{ans}$ 中与他配对的元素设为 $x'$。

然后我们将 $p_{cur}$ 中 $x$ 到 $x'$ 中的所有 $p_{cur}$ 关于 $p_{ans}$ 的逆序对消除（即排好序），然后所有在答案中出现在 $x$ 左边的元素一定在这中间部分的左边，将 $x$ 和 $x'$ 在中间配对，这样可以保证每一步交换都至少消除一个逆序对。容易证明这样做可行，且不会影响答案，也不会影响将 $p_{cur}$ 变为 $p_{ans}$ 的其余步骤。

在这种情况下，答案显然不劣于先排列完 $x$ 到 $x'$ 中的所有逆序对，再将 $x'$ 调换到最开头与 $x$ 配对。因为 $x$ 位于开头，将 $x$ 与 $x'$ 配对这一步不会耗费更多步数，并且配对完成之后也不需要担心干扰其余配对组。

那么答案也不劣于先将 $x$ 和 $x'$ 配对，再排列完那些逆序对。

然而先将 $x$ 和 $x'$ 配对后，原数列就可以忽略最前面的一对，变为一个长度为 $2n-2$ 的数列。也就是说，我们可以不需要排列那些逆序对，而直接递归求解。

最后的结论就是，每次将排列中的第一个配对，答案一定不劣于其余任何答案。

这个证明很好玩（qwq）。

引理2：如果有多个元素可以与最开头的配对，选择第一个，答案一定不劣。

这个很好证。如果最终答案是之后的元素和最开头的配对，那么我们先将第一个元素和最开头的配对，然后将后面的元素移到第一个元素的位置上。也就是说，“将第一个合适的元素与最开头的配对”一定可以成为其他所有策略的第一步。那就做呗。

然后是代码实现部分。需要找到对于每个元素与他最接近的匹配元素，还要维护他们的实时位置。这里我太菜了没想到用 `vector`，所以直接使用并查集来维护那个最接近的匹配元素。维护实时位置只需要用树状数组记录每次匹配对位置的影响就可以了。

附 AC 代码：

```cpp
#include <cstdio>
using namespace std;

int st[400005];

void init(int n)
{
	for(int i=1; i<=n; ++i)
	{
		st[i] = i;
	}
}

int getfa(int x)
{
	return st[x]==x ? x : st[x]=getfa(st[x]);
}

void unio(int a,int b)
{
	st[getfa(a)] = getfa(b);
}

int ti[200005];
int trin;

inline int lowbit(int x)
{
	return x&(-x);
}

void fix(int x,int k)
{
	while(x <= trin)
	{
		ti[x] += k;
		x += lowbit(x);
	}
}

int query(int x)
{
	int res = 0;
	while(x)
	{
		res += ti[x];
		x -= lowbit(x);
	}
	return res;
}

int si[200005];
int pi[200005];
int lpil[200005];
int lpir[200005];

int cpyed[200005];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=2*n; ++i)
	{
		scanf("%d",si+i);
	}
	
	n *= 2;
	trin = n;
	init(2*n);

	for(int i=n; i>=1; --i)
	{
		if(si[i] < 0)
		{
			if(lpir[-si[i]])
			{
				unio(i+n,lpir[-si[i]]);
			}
			if(lpil[-si[i]])
			{
				pi[i] = lpil[-si[i]];
			}
			lpil[-si[i]] = i;
		}
		else
		{
			if(lpil[si[i]])
			{
				unio(i+n,lpil[si[i]]);
			}
			if(lpir[si[i]])
			{
				pi[i] = lpir[si[i]];
			}
			lpir[si[i]] = i;
		}
	}
	
	long long ans = 0;
	for(int i=1; i<=n; ++i)
	{
		if(cpyed[i])
		{
			continue;
		}
		
		int cp = getfa(i+n);
		int thpos = i+query(i);
		int cppos = cp+query(cp);
		ans += cppos-thpos-1 + (si[i]>0);
		
		fix(i,1);
		fix(cp,-1);
		
		cpyed[cp] = 1;
		unio(i,pi[i]);
		unio(cp,pi[cp]);
	}
	
	printf("%lld",ans);
}
```

---

## 作者：SXqwq (赞：2)

### Descrption

有 $n$ 对鞋子。但现在它们的顺序是乱的。定义一个鞋子排列是有序的，**当且仅当每双鞋子都是左脚在左，右脚在右。且每双鞋子的左脚和右脚是紧挨着的**，求至少需要多少次操作使得鞋子排列是有序的。

保证有解。

### Analysis

注意到**我们只需要保证同一双鞋的匹配正确**即可。即对于每双鞋子的相对顺序，或者绝对顺序，题目并没有要求，这就涉及到最优化问题。

思考的时候不妨先将题目限制满足，我们先将每双鞋子匹配正确。此时我们需要决策每双鞋子的相对顺序。暴力搜肯定不行，观察数据范围，这大概是个贪心结论。一旦决定出每双鞋子的最优相对顺序，我们只需要求逆序对即可。因为我们每次只能交换相邻两数。

求需要几次邻项交换，使得无序序列变成有序，就是求逆序对个数。在排序的过程中，无效的交换是一定不存在的，所以逆序对个数即为答案。

下面我们需要考虑每双鞋子之间的相对位置。

有一个直观的想法是，按照左端点排序，确保每双鞋子的左端点是有序的，匹配右端点。

简要证明：用调整法。

设第一对鞋子在原序列中的位置为二元组 $(a,b)$，第二组为 $(c,d)$，满足 $a<c$。

此时，$b$ 和 $d$ 的关系未知。我们暂且不考虑 $(a,d),(b,d)$ 的贡献。分类讨论如下。

- 若 $b<d$，则两个二元组交换后逆序对数量是变大的，更劣。

- 若 $b>d$，则两个二元组交换后逆序对数量不变。

同时，我们尽可能的把小的 $a$ 往前放，尽量避免了 $(a,d),(b,d)$ 逆序对的出现。这个比较显然，不再分类讨论证明。

实现的时候对新的编号求逆序对即可。

---

## 作者：ink_ngm (赞：1)

> 大家好，我是个毒瘤，我非常喜欢暴力数据结构，于是我就用分块过了这个题。

## 整体思路

本题让我们找到最小交换次数，使得每对鞋子左右相邻、两两配对。我们贪心的想，如果从左往右便利：

对于一只左鞋子 $i$，我们找到离他最近的、相同大小的右鞋子 $j$，**只需要交换 $i - j - 1$ 次，就可以将右鞋子换到 $i$ 相邻位置，配对成功**，且对于 $x \sim y$ 间的所有鞋子和右边鞋子配对造成了一次贡献。

对于一只右鞋子 $i'$，我们只需要在前一种情况的基础上，将两只鞋子再交换一次，即交换 $i' - j'$ 次，便可以配对成功。

我们该如何维护上述操作呢？对于维护鞋子位置，我们可以用 vector 或者 map 记录，对于本题 $n \leq 100000$ 的鞋子对数，使用 set 或者 deque 会 TLE 和 MLE。

对于维护已经配对好的鞋子的贡献，我们需要一个数据结构可以维护单点修改和区间查询，本题题解大多是使用树状数组实现，但是重振分块荣光，吾辈义不容辞：我们可以**记录每个不同左右大小鞋子的位置后，用分块维护做到单点修改；记录每个点贡献后，用分块维护区间和，做到区间查询**。从而，我们可以写出以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    register int x=0,f=1;register char ch=getchar_unlocked();
    while(ch<'0'||'9'<ch){ch=='-'?f=-f:0; ch=getchar_unlocked();}
    while('0'<=ch&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48),ch=getchar_unlocked();}
    return x*f;
}
const int N=1e5+5,oo=1e5;
int a[N<<1],id[N<<1],tag[1005],tot[N<<1];
vector<int>num[N<<1];
bool vis[N<<1];
signed main(){
    register int n=read()<<1,i,j,len,fid,flag,js=1,now,l,r,lnum,rnum;
    register long long ans=0;
    len=sqrt(n);
    for(i=1;i<=n;++i) {
        a[i]=read()+oo,id[i]=(i-1)/len+1;
        num[a[i]].push_back(i);
    }
    for(i=1;(js<<1)<=n;++i){
        if(vis[i]) continue;
        ++js,now=0;
        if(a[i]<oo) fid=oo-(a[i]-oo),flag=0;
        else fid=oo-(a[i]-oo),flag=1;//判断当前是左鞋子在前还是右鞋子在前
        l=i,r=num[fid][tot[fid]++];
        ++tot[a[i]];
        //————————分块基操————————
        lnum=id[l],rnum=id[r];
        if(lnum==rnum) for(j=l;j<=r;++j) now+=vis[j];
        else{
            for(j=l;id[j]==lnum;++j) now+=vis[j];
            for(j=lnum+1;j<rnum;++j) now+=tag[j];
            for(j=r;id[j]==rnum;--j) now+=vis[j];
        }
        ans+=r-l-1+flag-now;
        vis[l]=vis[r]=1,++tag[lnum],++tag[rnum];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：君玘 (赞：1)

题目条件：

- $n$ 双鞋，则共有 $2n$ 只鞋子；
- 任意一双鞋 $s_i$ 的鞋码为 $x_i$，为了区分，左鞋为 $-x_i$，右鞋为 $x_i$；
- $1\le n\le 1\times10^5$，$1\le s\le n$；

题目要求：

- 只能**交换**当前相邻的两只鞋；
- 求最少的对调次数使得鞋子是合法排列；

合法队列要求：

- 一双鞋的两只鞋挨着；
- 先左鞋再右鞋；
- **没必要按顺序**；

先讲我的贪心思路是怎么得到的：

一开始理解错题意，以为需要按鞋子大小顺序，然后我就想到了一个非常简单的思路：既然得按顺序，那么最小的那双鞋到最后一定得排在第一个，于是我直接移过去。

因此我证明了**两个结论**：

1. 对于任意一只鞋 $s_i$，若其正确位置为 $w_i$，且 $w_i$ 前的位置都正确的摆放好了鞋子，那么将 $s_i$ 移至 $w_i$ 上不会使其他鞋子结果变坏；
2. 在结论1的基础上，对于位置 $w_i$ 若有多个鞋尺码相同对应着位置 $w_i$，那么选择靠前的那一只。

先简单的说明一下结论1：

因为 $w_i$ 前的位置都已经摆好，将 $s_i$ 放上  $w_i$ 后前 $w_i$ 个位置就都摆好了，那么后面的鞋将不会再摆入前 $w_i$ 个位置上，此时 $s_i$ 的移动将使得其前面的鞋都往后推一个位置，并不会使其他鞋子结果变坏。

而在此基础上，对于相同的鞋，最靠前的鞋移动次数最少，因此选择它。

于是乎，我们不再管前面那个错误的贪心，而是思考这个不需要按照大小顺序的鞋该怎么移动。

显然，既然不需要按顺序，那本来在最前面的那只鞋就不动算了，将它的另一半移过来与它相聚，然后再考虑下一双鞋即可。

**最终贪心**：

1. 从头开始按输入顺序找鞋即可；
1. 对于每只鞋，找到最近的它的另一半直接移过来即可。

接下来讲讲代码实现：

1. **找到另一半**：为了快速找到另一半，我在输入的时候进行预处理，将两只鞋对应上，这样可快速找到另一半；
2. **移动另一半**：将另一半 $s_i$ 移至当前位置 $w_k$ 时，$s_i$ 的位置 $w_i$ 就空了，$s_i$ 移过去后，$w_k$ 到 $w_i$ 之前的这些鞋子都会往后移动一个，即被 $s_i$ 挤过去了，因此这些鞋子的原位置需要加 $1$ 才会是现在的位置，为了维护位置，可以用差分加树桩数组来快速方便的维护位置的变动；
3. 答案很大，需要开long long，这个卡了我很久。

AC代码如下：
```cpp
#include<bits/stdc++.h>
#define gc ch=getchar()
#define pt puts("")
#define pc putchar(32)
#define sl s[i].lpos
#define sr s[i].rpos
#define ll long long
using namespace std;
template <class T>void read(T &s){
	s=0;T f=1;char gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;gc;}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';gc;}
	s*=f;	
}
template <class T>void put(T s){
	if(s<0) putchar('-'),s=-s;
	if(s>9) put(s/10);
	putchar(s%10+'0');
}
struct shoe{
	int lpos,rpos,nxt;
}s[200005];

int n,c[200005],headl[200005],headr[200005],cnt;
ll ans;

inline void add(int k,int num){while(k<=n)c[k]+=num,k+=k&-k;}
inline int sum(int k){
	int cnt=0;
	while(k) cnt+=c[k],k-=k&-k;
	return cnt;	
}
int main(){
	read(n);
	n*=2;
	int Abs,S;
	for(int i=1;i<=n;++i){
		read(S);
		Abs=S<0?-S:S;
		//head分成r,l两个，记录左鞋和右鞋 
		if(!headl[Abs]&&!headr[Abs]){
			if(S<0) s[++cnt].lpos=i;
			else s[++cnt].rpos=i;
			headl[Abs]=headr[Abs]=cnt;
		}
		//因为会有鞋子相同，因此需要判断和哪只鞋配成一双 
		else{	
			if(S<0){
				int j=headl[Abs],flag=0;
				while(s[j].nxt&&s[j].lpos) j=s[j].nxt;
				if(s[j].lpos) s[++cnt].lpos=i,s[j].nxt=cnt,headl[Abs]=cnt;
				else s[j].lpos=i,headl[Abs]=j;
			}
			else{
				int j=headr[Abs],flag=0;
				while(s[j].nxt&&s[j].rpos) j=s[j].nxt;
				if(s[j].rpos) s[++cnt].rpos=i,s[j].nxt=cnt,headr[Abs]=cnt;
				else s[j].rpos=i,headr[Abs]=j;
			}
			//更改head的值以便快速找到对应的鞋 
		}
	}
	for(int i=1;i<=cnt;++i){
		int suml=sum(sl),sumr=sum(sr);
		//加上位置的变动sum，即是当前的位置了
		if(sl+suml>sr+sumr) ans+=(ll)sl+suml-sr-sumr,add(sr,1),add(sl,-1);
		else if(sl+suml+1<sr+sumr) ans+=(ll)sr+sumr-sl-suml-1,add(sl+1,1),add(sr,-1);
	}
	put(ans);
}
```



---

## 作者：Jadonyzx (赞：0)

看见相邻位置交换容易想到逆序对。

发现序列里的鞋子顺序并无关系，只要两两配对即可，因此若出现两双鞋子完全分离，即一双的两只都在另一双两只的左边，此时不将二者交换一定更优。

若有一只交叉同理。

树状数组维护逆序对即可。


```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 400005
using namespace std;
int n,a[maxn],downtot[maxn],uptot[maxn];
int num[maxn],cnt,hsh[maxn],tree[maxn],ans,CZS[maxn][2];
vector<int>down[maxn],up[maxn];
inline int lowbit(int x){return x&(-x);}
inline void update(int x,int dt){
	for(int i=x;i<=n*2+1;i+=lowbit(i))
		tree[i]+=dt;
	return;
}
inline int query(int id){
	if(id<=0)return 0;
	int s=0;
	for(int i=id;i;i-=lowbit(i))
		s+=tree[i];
	return s;
}
signed main(){
	cin>>n;for(int i=1;i<=n*2;++i)cin>>a[i];
	for(int i=1;i<=n*2;++i){
		if(a[i]>0){
			if(CZS[a[i]][1])--CZS[a[i]][1];
			else{
				++cnt;
				num[cnt*2]=a[i];
				num[cnt*2-1]=-a[i];
				++CZS[a[i]][0];
			}
		}
		else{
			if(CZS[-a[i]][0])--CZS[-a[i]][0];
			else{
				++cnt;
				num[cnt*2]=-a[i];
				num[cnt*2-1]=a[i];
				++CZS[-a[i]][1];
			}
		}
	}
	for(int i=1;i<=n*2;++i){
		if(a[i]>0)up[a[i]].push_back(i);
		else down[-a[i]].push_back(i);
	}
	for(int i=1;i<=n*2;++i){
		if(num[i]>0)hsh[up[num[i]][uptot[num[i]]]]=i,++uptot[num[i]];
		else hsh[down[-num[i]][downtot[-num[i]]]]=i,++downtot[-num[i]];
	}
	for(int i=n*2;i>=1;--i){
		ans+=query(hsh[i]-1);
		update(hsh[i],1);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：qnqfff (赞：0)

### 思路

考虑贪心，从左到右依次考虑，对于一个鞋子，显然会和最前面的大小相同方向不同的鞋子匹配，调整法易证，因为每次匹配中间的鞋子会向右移一位，使用树状数组维护位移量即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){int p=0,flg=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,c[200010];vector<int>a[100010],b[100010];
void add(int x,int y){for(;x<=(n<<1);x+=x&-x) c[x]+=y;}
void add(int l,int r,int v){add(l,v);add(r+1,-v);}
int ask(int x){int res=0;for(;x;x-=x&-x) res+=c[x];return res;}
signed main(){
	n=read();int ans=0;
	for(int i=1;i<=(n<<1);i++){
		int x=read();if(x<0){
			a[-x].push_back(i);if(b[-x].empty()) continue;int j=b[-x].front()+ask(b[-x].front());
			ans+=i-j;add(b[-x].front()+1,i-1,1);a[-x].pop_back();b[-x].erase(b[-x].begin());
		}else{
			b[x].push_back(i);if(a[x].empty()) continue;int j=a[x].front()+ask(a[x].front());
			ans+=i-j-1;add(a[x].front()+1,i-1,1);b[x].pop_back();a[x].erase(a[x].begin());
		}
	}cout<<ans;
	return 0;
}
```

---


# [IOI 2005] gar

## 题目背景

 Byteman 拥有镇上最漂亮的花园。

## 题目描述

他在自己的花园里面种了 $N$ 朵玫瑰花。

夏天来了，所有的花都开的非常的漂亮。 Byteman 开始意识到自己没有能力看管自己花园里的所有的花，所以他决定雇佣两个园丁来帮助他。

他想在花园中选择两块矩形的区域分别交给两个园丁看管。而且这两个矩形区域必须不能相交或者重叠，并且每一个区域要恰好包含 $K$ 朵玫瑰花。

Byteman 想要给这两块矩形区域的周围安上栅栏，但是他现在手头比较紧，所以他希望自己花的钱尽量的少。你的任务就是帮助 Byteman 选择两块矩形的区域,使得它们在满足条件的情况下周长和最小。 

Byteman 的花园有 $L$ 米长，$W$ 米宽。花园被分成了 $L\times W$ 个大小相同 $1\times1$ 的方格。我们以平行与花园的两边建立起一个坐标系。所有的方格的坐标 $(x,y)$ 满足 $1\leq x\leq L,1\leq y\leq W$。每个方格内可能会有任意数目的玫瑰。 

所选的矩形区域的两边必须跟花园的两边平行，并且矩形区域的四个角的坐标必须是整数。对于 $1\le L_1\le L_2\le L$ 并且 $1\le W_1\le W_2\le W$，一个矩形区域的四个角为 $(L_1,W_1),(L_1,W_2)$，$(L_2,W_1)$ 和 $(L_2,W_2)$: 

* 这个矩形内所包含的点的坐标 $(x,y)$ 满足$L_1\le x\le L_2$并且$W_1\le y\le W_2$。

* 这个矩形的周长是 $2\times (L_2-L_1+1)+2\times (W_2-W_1+1)$。所选的两块矩形不能重叠或者相交。也就是它们不能有公共的方格。即使它们有公共的边，计算周长的时候也要分别计算。

## 说明/提示

对于$100\%$的数据，$1\le L,W\le250$，$2\le n\le5000,1\le k\le \frac{n}{2}$

## 样例 #1

### 输入

```
6 5
7 3
3 4
3 3
6 1
1 1
5 5
5 5
3 1```

### 输出

```
22```

# 题解

## 作者：Yukikaze_ (赞：4)

### 并不需要什么算法的一道题，暴力就可以过。

#### 首先，在一个矩形中选出两个互不相交的小矩形，一定可以用一条水平直线或一条竖直直线将它们分开，这里与[APIO2009 采油区域](https://www.luogu.com.cn/problem/P3625)有些类似，不过那题是三个矩形，情况要多一些。

#### 知道了这一点后，我们就可以考虑枚举分界线了，为了能在枚举分界线时更快地统计答案，我们需要把每一列向左、右，每一行向上、下延伸出的符合条件的周长最小的矩形计算出来，这里朴素算法是O(n^4)的（枚举每个组合），所以需要一些小优化，我用了n^2个队列对应每条线段统计答案，复杂度为O(n^3)。

#### 然后，我们枚举分界线，并分别取分界线前后的最小值加起来更新答案就可以了。加上预处理，总复杂度O(n^3)。

接下来是我写代码时的一个小细节（可能并没有什么用）：四个方向预处理的过程很类似，可以考虑将矩形旋转3次然后用一个函数解决来减少码量。

然后是代码
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
const int N=255,inf=1e9;
int h[N][N],sum[N][N],r,c,n,k;
int dt[N][N],zuo[N][N],ans=inf;
int up[N],down[N],rt[N],lf[N];
int read()
{
	int res=0,fl=0;
	char a=getchar();
	while(a<'0'||a>'9') {if(a=='-') fl=1;a=getchar();}
	while(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();
	return fl? -res:res;
}
void work(int lr,int lc,int *lx)
{
	int i,j,li;
	for(i=1;i<=lr;i++)
		for(j=1;j<=lc;j++) zuo[i][j]=zuo[i][j-1]+dt[i][j]; //预处理每行前缀和 
	for(i=1;i<=lc;i++)
		for(j=i;j<=lc;j++) h[i][j]=1,sum[i][j]=0; //还原指针和总和 
	for(i=1;i<=lr;i++)
	{
		lx[i]=inf;
		for(j=1;j<=lc;j++)
			for(li=j;li<=lc;li++)
			{
				sum[j][li]+=zuo[i][li]-zuo[i][j-1];
				while(sum[j][li]>k) sum[j][li]-=zuo[h[j][li]][li]-zuo[h[j][li]][j-1],h[j][li]++; //如果总和大于k就舍弃最后一行
				if(sum[j][li]==k) lx[i]=min(lx[i],(li-j+1+i-h[j][li]+1)<<1); //如果处理完后总和刚好为k就更新答案 
			}
	}
}
void rotate(int lr,int lc)
{
	int res[N][N]={{0}};
	for(int i=1;i<=lc;i++)
		for(int j=1;j<=lr;j++) res[i][j]=dt[lr-j+1][i];
	memcpy(dt,res,sizeof(dt));
}
int main()
{
//	freopen("gar.in","r",stdin);
//	freopen("gar.out","w",stdout);
	int i,j,li,lj;
	r=read(),c=read(),n=read(),k=read();
	for(i=1;i<=n;i++)
	{
		int lr=read(),lc=read();
		dt[lr][lc]++;
	}
	work(r,c,up),rotate(r,c),work(c,r,lf),rotate(c,r),work(r,c,down),rotate(r,c),work(c,r,rt),rotate(c,r); //旋转4次统计答案 
	for(i=2;i<=r;i++) up[i]=min(up[i],up[i-1]),down[i]=min(down[i],down[i-1]); 
	for(i=2;i<=c;i++) lf[i]=min(lf[i],lf[i-1]),rt[i]=min(rt[i],rt[i-1]); //前缀取最小值 
	for(i=1;i<c;i++) ans=min(ans,lf[i]+rt[c-i]);
	for(i=1;i<r;i++) ans=min(ans,up[i]+down[r-i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：囧仙 (赞：2)

## 题目大意

$n$ 朵玫瑰在 $L\times W$ 的矩阵里。现在要求你选出两个矩阵，使得每个矩阵里都有 $p$ 朵玫瑰，并且两个矩阵不会互相重叠。询问两个矩阵周长的最小值。若无解，输出 $\verb!NO!$ 。

## 题解

二位前缀和板子题，比较水。下文用 $(a,b)-(c,d)$ 描述一个左上角为 $(a,b)$ ，右下角为 $(c,d)$ 的矩阵。

考虑什么时候两个矩阵不会重叠。可以发现，此时必定能找到一条横线或者竖线，将两个矩阵分开。不妨考虑横线的情况，竖线同理。

假如我们能计算出前 $i$ 行中，能覆盖 $p$ 朵玫瑰的矩阵的最小周长 $pre_i$ ，以及后 $i$ 行中，能覆盖 $p$ 多玫瑰的矩阵的最小周长 $suf_i$ ，那么这一部分答案就可以如下合并：

$$ans=\min_{i}\{pre_{i}+suf_{L-i+1}\}$$

考虑如何计算 $pre_i$ 。 $suf_i$ 同理。

我们从上到下枚举每一行，再从左到右枚举每一列，确定这个矩阵的左下角 $(i,j)$ 。考虑先枚举它的右下角 $(i,k)$ ，此时就要找到最大的 $t$ ，使得矩阵 $(t,j)-(i,k)$ 里恰好有 $p$ 朵玫瑰。可以发现，当我们从小到大枚举 $k$ 的时候， $t$ **单调不增**。于是，只要接着上一个 $k$ 的 $t$ 开始枚举，就可以把这部分枚举的复杂度做到 $\mathcal O(L^2W)$ 了。

关于计算一个矩阵 $(a,b)-(c,d)$ 内玫瑰的数目，考虑二维前缀和。我们记 $S_{i,j}$ 表示 $(1,1)-(i,j)$ 内玫瑰的数目，显然有：

$$\begin{aligned}
S_{i,j}&=S_{i-1,j}+S_{i,j-1}+P_{i,j}-S_{i-1,j-1} \cr
\text{count}(a,b,c,d)&=S_{c,d}-S_{c,b-1}-S_{a-1,d}+S_{a-1,b-1} \cr
\end{aligned}$$

其中， $P_{i,j}$ 表示 $(i,j)$ 上有多少朵玫瑰； $\text{count}(a,b,c,d)$ 表示 $(a,b)-(c,d)$ 内玫瑰的数目。预处理出 $S_{i,j}$ ，就能 $\mathcal O(1)$ 获取 $\text{count}(a,b,c,d)$ 了。

关于本题，你可以用一些小技巧（翻转横坐标和纵坐标）来减小很多冗余的代码。具体可以见参考代码。

总时间复杂度 $\mathcal O(L^2W+W^2L)$ ，可以通过本题。

顺带一提，貌似这题中存在横坐标不在 $[1,L]$ ，或者纵坐标不在 $[1,W]$ 内的节点，注意特判。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =1e9;
#define num(t1,t2,t3,t4) (S[t3][t4]-S[t1-1][t4]-S[t3][t2-1]+S[t1-1][t2-1])
const int MAXN=500+3,MAXM=5e3+3;
int S[MAXN][MAXN],A[MAXM],B[MAXM],p,r,c,n;
void clc(int l,int w,int *W){
    up(1,l,i) up(1,w,j) S[i][j]=0; up(1,n,i) ++S[A[i]][B[i]];
    up(1,l,i) up(1,w,j) S[i][j]+=S[i-1][j]+S[i][j-1]-S[i-1][j-1];
    up(1,l,i) W[i]=INF; up(1,l,i) up(1,w,j){
        int t=1; up(j,w,k){ //(t,j)--(i,k)
            while(t<i&&num(t+1,j,i,k)>=p) ++t;
            if(num(t,j,i,k)==p) W[i]=min(W[i],i-t+k-j+2);
        }
    }
    up(2,l,i) W[i]=min(W[i],W[i-1]);
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int W1[MAXN],W2[MAXN],ans=INF;
int main(){
    r=qread(),c=qread(),n=qread(),p=qread();
    up(1,n,i) A[i]=qread(),B[i]=qread(); clc(r,c,W1);
    up(1,n,i) A[i]=r-A[i]+1; clc(r,c,W2);
    up(1,r-1,i) ans=min(ans,W1[i]+W2[r-i]);
    up(1,n,i) swap(A[i],B[i]); clc(c,r,W1);
    up(1,n,i) A[i]=c-A[i]+1; clc(c,r,W2);
    up(1,c-1,i) ans=min(ans,W1[i]+W2[c-i]);
    if(ans>=INF) puts("NO"); else printf("%d\n",ans<<1);
    return 0;
}
```

---

## 作者：Rain_cyl (赞：1)

首先考虑两个矩形的问题。

发现两个矩形一定能被某个水平或竖直的直线分开，所以我们只需要求解每条直线上、下、左、右对应的答案，最后枚举分割线将两侧答案相加即可。

可以每次将整个矩形旋转九十度，再进行求解，这样可以减少码量。

因此，我们只需解决一个方向上的问题，即：对于每条竖线，求出其左侧恰好包含 $K$ 朵花的矩形的最小周长。

---

暴力枚举+二位前缀和是 $O(n^4)$ 的，不可接受。

我们可以枚举矩形所在行的范围 $(u,d)$，然后从左到右枚举矩形右侧边的列号 $r$。可以发现随着 $r$ 的增加，矩形的左侧边 $l$ 是单调不减的。因此我们双指针维护一个滑动窗口，当矩形 $(l,u)~(r,d)$ 包含的花的数量在去掉 $l$ 这一列后仍 $\ge K$，就让 $l$ 加 $1$。剩下的矩形若恰好包含 $K$ 朵花，则该矩形的周长对第 $r$ 列的答案有贡献。

---

代码如下，时间复杂度 $O(n^3)$。
```
#include<bits/stdc++.h>
using namespace std;
const int N=255;

int n,m,tot,K;
int g[N][N],s[N][N];
int f[4][N];

void rotate(){ //顺时针旋转90度
    int bg[N][N];
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            bg[j][n-i+1]=g[i][j];
    memcpy(g,bg,sizeof g);
    swap(n,m);
}

int get_sum(int x1,int y1,int x2,int y2){
    return s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
}

int get_len(int x1,int y1,int x2,int y2){
    return 2*(x2-x1+1)+2*(y2-y1+1);
}

void calc(int dir){
    memset(s,0,sizeof s);
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            s[i][j]=g[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
            
    for(int i=1; i<=n; i++)
        for(int j=i; j<=n; j++){ //枚举纵坐标范围
            int sum=0;
            for(int l=1,r=1; r<=m; r++){
                sum+=get_sum(i,r,j,r);
                while(sum-get_sum(i,l,j,l)>=K&&l<=r){ //维护滑动窗口
                    sum-=get_sum(i,l,j,l);
                    l++;
                }
                if(sum==K)
                    f[dir][r]=min(f[dir][r],get_len(i,l,j,r));
            }
        }
}

int main(){
    scanf("%d%d%d%d",&n,&m,&tot,&K);
    for(int i=1; i<=tot; i++){
        int x,y;
        scanf("%d%d",&x,&y);
        g[x][y]++;
    }
    
    memset(f,0x3f,sizeof f);
    for(int i=0; i<4; i++){ //进行四个方向的计算
        calc(i);
        rotate();
    }
    
    int res=0x3f3f3f3f;
    for(int i=1; i<m; i++)
        res=min(res,f[0][i]+f[2][m-i]);
    for(int i=1; i<n; i++)
        res=min(res,f[1][i]+f[3][n-i]);
    if(res>=0x3f3f3f3f) puts("NO");
    else printf("%d\n",res);
    return 0;
}
```

---

## 作者：icaijy (赞：1)

因为两个矩形不能重叠，所以观察到必定有一条平行于坐标轴的线会把他们分开。所以只要求出来每个这样的线的上下左右满足包含 $K$ 个玫瑰花的最小矩形。

我们先假设这样的线是横着的，求这条线上面的矩形。我们可以枚举这个矩形的两边，把矩形的两边固定下来，这样我们只需要关心矩形的上面的边了（下面的边是横线）。随着分开两个长方形的横线下降，我们的矩形就可能会包含更多的玫瑰花。假如玫瑰花太多了，我们就就让上面的边下降。这个过程可以用双指针模拟。这样时间复杂度就是 $O(n^3)$，可以通过此题。

实现的话就是枚举每一个分开两个长方形的横线与竖线，分别计算他们上下左右的长方形的最小周长。答案就是同一个线的左长方形加右长方形，或上面的长方形加下面的长方形的周长的最小值。

结合图片，我们枚举每一个绿线作为分开两个长方形的线，红线作为长方形两侧的固定的边。这时随着绿线往下移，黄线也会往下移来调整玫瑰的数量。数量少了就不动，多了就移动黄线直到玫瑰数量小于 $K$ 或等于 $K$ 时再移动就小于 $K$ 时。

![](https://cdn.luogu.com.cn/upload/image_hosting/it8zvr9y.png)

以下是代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n,m,t,k,x,y;
int ans=2100000000;
int g[255][255];
int h1[255],h2[255],v1[255],v2[255];
int getsum(int x1,int x2,int y1,int y2){
    if (x1==0||y1==0) return 0;
    return g[x2][y2]-g[x1-1][y2]-g[x2][y1-1]+g[x1-1][y1-1];
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m>>t>>k;
    for (int i=0;i<=n;i++) h1[i]=h2[i]=2100000000;
    for (int i=0;i<=m;i++) v1[i]=v2[i]=2100000000;
    while (t--){
        cin>>x>>y;
        g[x][y]++;
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            g[i][j]=g[i-1][j]+g[i][j-1]+g[i][j]-g[i-1][j-1];
        }
    }
    for (int i=1;i<=m;i++){
        for (int j=i;j<=m;j++){
            int l=1,cur=0;
            for (int r=1;r<n;r++){
                cur+=getsum(r,r,i,j);
                while (l<=r) {
                    if (cur<k||(cur==k&&0!=getsum(l,l,i,j))) break;
                    cur-=getsum(l,l,i,j);
                    l++;
                }
                if (cur==k){
                    h1[r]=min(h1[r-1],min(h1[r],2*(j-i+r-l+2)));
                }
            }
        }
    }
    for (int i=1;i<=m;i++){
        for (int j=i;j<=m;j++){
            int l=n,cur=0;
            for (int r=n;r;r--){
                cur+=getsum(r,r,i,j);
                while (l>=r) {
                    if (cur<k||(cur==k&&0!=getsum(l,l,i,j))) break;
                    cur-=getsum(l,l,i,j);
                    l--;
                }
                if (cur==k){
                    h2[r-1]=min(h2[r],min(h2[r-1],2*(j-i+l-r+2)));
                }
            }
        }
    }

    for (int i=1;i<=n;i++){
        for (int j=i;j<=n;j++){
            int l=1,cur=0;
            for (int r=1;r<m;r++){
                cur+=getsum(i,j,r,r);
                while (l<=r) {
                    if (cur<k||(cur==k&&0!=getsum(i,j,l,l))) break;
                    cur-=getsum(i,j,l,l);
                    l++;
                }
                if (cur==k){
                    v1[r]=min(v1[r-1],min(v1[r],2*(j-i+r-l+2)));
                }
            }
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=i;j<=n;j++){
            int l=m,cur=0;
            for (int r=m;r;r--){
                cur+=getsum(i,j,r,r);
                while (l>=r) {
                    if (cur<k||(cur==k&&0!=getsum(i,j,l,l))) break;
                    cur-=getsum(i,j,l,l);
                    l--;
                }
                if (cur==k){
                    v2[r-1]=min(v2[r],min(v2[r-1],2*(j-i+l-r+2)));
                }
            }
        }
    }
    for (int i=1;i<n;i++) ans=min(ans,h1[i]+h2[i]);
    for (int i=1;i<m;i++) ans=min(ans,v1[i]+v2[i]);
    cout<<ans;
}
```

---

## 作者：Alkaid_Star (赞：1)

[可能更好的阅读体验](https://www.encounter.cool/index.php/2021/06/30/luogu5920-solution/)

### 题目大意

[原题链接](https://www.luogu.com.cn/problem/P5920)

> 给定一个 $L \times W$ 的花园，它被分为 $L \times W$ 个 $1 \times 1$ 的矩形。花园中有 $n$ 朵花。注意，这里**一个格子上可能有两朵花**。
>
> 现在要求你找出两个不相交的矩形 $M_1$ 和 $M_2$，要求它们各包含 $k$ 朵花。
>
> 最小化 $M_1$ 和 $M_2$ 的周长。
>
> $1 \le L,W \le 250$，$2 \le n \le 5 \times 10^3$，$K \le \frac{n}{2}$。

### 解题思路

我们发现两个不相交的矩形有一个奇妙的性质：**必然可以找到一条平行于坐标轴的直线把这两个矩形隔开**。

这个性质有什么用呢？

我们可以枚举这条直线。当这条直线是横线是横着的（平行于 $x$ 轴）时，我们设 $U_i$ 是第 $i$ 行及上方的部分中，包含 $K$ 朵花的矩形的最小周长，$D_i$ 是第 $i$ 行下方的部分中，包含 $K$ 朵花的矩形的最小周长。

那么我们可以发现最后的答案就是两个矩形加起来，也即 $ans=\min_{1 \le i < L}(U_i+D_{L-i})$。

如果这条分割线是竖着的，同理，设 $L_i$ 和 $R_i$ 即可。

怎么求 $L,R,U,D$ 这四个数组呢？

以求 $U$ 为例，我们考虑枚举一个点 $(i,j)$ 作为上方矩形的左下角坐标，再枚举一个 $(i,k)$ 作为右下角。我们假设左上角的坐标为 $(t,j)$，那么可以发现，在 $k$ 不断变大的途中，由于增加了右边的一块区间，所以矩形内花的数量显然不会减少，也即**上方的 $t$ 是不断下移（不会上移）的**。

效果类似于下图：

![](https://img-kysic-1258722770.file.myqcloud.com/2fc5d135b03d96073610228232b849a9/64d80430364c7.png) 

利用这样类似于单调性的优化，我们可以把复杂度优化到均摊 $O(L^3)$ 级别（$L,W$ 同阶）。

这里关于求四个数组，有一个写法上的小技巧：

我们可以在求出一个数组后，每次直接顺时针把矩形旋转 $90$ 度，在新的矩形中按照上面一样的过程再求一遍即可。更多的细节见代码注释。

啊，对了，这道题中花的坐标是可能不在给定 $L \times W$ 矩阵内的，与题面描述不符，注意判断一下。

~~代码注释用英文写，是因为如果用中文，在不同编码转化的时候会出问题。~~

~~另外，锻炼一下英语也是好的（~~

```cpp
#include<bits/stdc++.h>
#define min(a,b) ((a) < (b) ? (a) : (b))
using namespace std;
const int N=505;
const int inf=1000000005;

struct Position{
	int x,y;
}p[N*N];

int r,c,n,K,cnt=0;
int S[N][N],U[N],D[N],L[N],R[N];

inline int read(){
	int x=0,f=1; char ch=getchar();
	while (!isdigit(ch)) { if (ch=='-') f=-1; ch=getchar(); }
	while (isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }
	return x*f;
}

inline int count(int A,int B,int C,int D){
	return S[C][D]-S[A-1][D]-S[C][B-1]+S[A-1][B-1];
}

inline void Rotate1(){		// From vertical rectangle to horizontal rectangle
	for (int i=1;i<=n;++i){
		int x=p[i].x,y=p[i].y;
		p[i].x=y,p[i].y=r-x+1;
	}
}

inline void Rotate2(){		// From horizontal rectangle to vertical rectangle
	for (int i=1;i<=n;++i){
		int x=p[i].x,y=p[i].y;
		p[i].x=y,p[i].y=c-x+1;
	}
}

inline void Calc(int r,int c,int *now){
	memset(S,0,sizeof(S));
	for (int i=1;i<=n;++i) ++S[p[i].x][p[i].y];		// not S[p[i].x][p[i].x]=1 ...
	// printf("S-before:\n");
	// for (int i=1;i<=r;++i){
	// 	for (int j=1;j<=c;++j)
	// 		printf("%d ",S[i][j]);
	// 	printf("\n");
	// }
	for (int i=1;i<=r;++i)
		for (int j=1;j<=c;++j)
			S[i][j]=S[i][j]+S[i-1][j]+S[i][j-1]-S[i-1][j-1];
	// printf("S-after:\n");
	// for (int i=1;i<=r;++i){
	// 	for (int j=1;j<=c;++j)
	// 		printf("%d ",S[i][j]);
	// 	printf("\n");
	// }
	for (int i=1;i<=r;++i)
		for (int j=1;j<=c;++j){
			int t=1;
			for (int k=j;k<=c;++k){
				while ((t<i) && (count(t+1,j,i,k)>=K)) ++t;
				if (count(t,j,i,k)==K) now[i]=min(now[i],(k-j+1+i-t+1)*2);
				// (t,j) —————————— (t,k)
				//  |				  |
				//  |				  |
				// (i,j) —————————— (i,k)
			}
		}
}

int main(){
	//freopen("Luogu5920.in","r",stdin);
	//freopen("Luogu5920.out","w",stdout);
	r=read(),c=read(); n=read(),K=read();
	for (int i=0;i<N;++i) L[i]=R[i]=U[i]=D[i]=inf;
	for (int i=1;i<=n;++i){
		int x=read(),y=read();
		if ((x<1) || (x>r)) continue;		// special judge
		if ((y<1) || (y>c)) continue;
		p[++cnt].x=x,p[cnt].y=y;
	}
	n=cnt;
	Calc(r,c,U),Rotate1(); Calc(c,r,R),Rotate2();		// rotate matrix 90 degrees clockwise each time
	Calc(r,c,D),Rotate1(); Calc(c,r,L),Rotate2();
	for (int i=2;i<=c;++i) L[i]=min(L[i],L[i-1]);		// notice that it is always a prefix minimum no matter it is L,U,R or D,because the matrix is rotated!
	for (int i=2;i<=r;++i) U[i]=min(U[i],U[i-1]);
	for (int i=2;i<=c;++i) R[i]=min(R[i],R[i-1]);
	for (int i=2;i<=r;++i) D[i]=min(D[i],D[i-1]);
	int ans=inf;
	for (int i=1;i<c;++i) ans=min(ans,L[i]+R[c-i]);		// calc the answer
	for (int i=1;i<r;++i) ans=min(ans,U[i]+D[r-i]);
	if (ans>=inf) printf("NO\n");
	else printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Ericnoi (赞：0)

# P5920 [IOI 2005] gar 题解

[题目传送门](https://www.luogu.com.cn/problem/P5920)

## 分析

注意到，如果存在两个不相交的矩形，那么它们要么存在垂直分界线，要么存在水平分界线。我们可以分别枚举这两条分界线。只要维护出对于一条水平/垂直分界线，完全在它上面/下面/左边/右边的满足条件的矩形中周长的最小值，最终答案就是易于统计的。

欲维护如上信息，不妨考虑枚举出所有符合要求的矩形。矩形可以通过四个参数完全决定 $(x1, y1, x2, y2)$，然而题目只能接受 $O(n^3)$ 左右的复杂度，接受不了 $O(n^4)$ 的复杂度 $(n = \max(L, W))$。不难想到可以枚举其中三个参数，二分最后一个参数。在最后一个参数的方向上舍弃掉那些周长较大的答案一定是不劣的。故可以枚举出所需要的所有矩形。

二分时用二维前缀和查询玫瑰数即可。

## 代码实现

短小优美的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 250 + 5;
int n, m, cnt, k;
int a[N][N], sum[N][N], lft[N], rit[N], up[N], down[N];
void init() {
    for(int i = 1 ; i <= n ; i++) {
        for(int j = 1 ; j <= m ; j++) {
            sum[i][j] = a[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
}
int query(int x1, int y1, int x2, int y2) {
    return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];
}
int find(int x1, int x2, int y1) {
    int l = y1 - 1, r = m + 1, mid;
    while(l + 1 < r) {
        mid = (l + r) >> 1;
        if(query(x1, y1, x2, mid) <= k) l = mid;
        else r = mid;
    }
    if(query(x1, y1, x2, l) == k) return l;
    else return -1;
}
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> m >> cnt >> k;
    for(int i = 1 ; i <= n ; i++) {
        up[i] = down[i] = 0x3f3f3f3f;
    }
    for(int i = 1 ; i <= m ; i++) {
        lft[i] = rit[i] = 0x3f3f3f3f;
    }
    for(int i = 1 ; i <= cnt ; i++) {
        int x, y;
        cin >> x >> y;
        a[x][y]++;
    }
    init();
    for(int x1 = 1 ; x1 <= n ; x1++) {
        for(int x2 = x1 ; x2 <= n ; x2++) {
            for(int y1 = 1 ; y1 <= m ; y1++) {
                int y2 = find(x1, x2, y1);
                if(y2 == -1) continue;
                int len = 2 * (x2 - x1 + 1) + 2 * (y2 - y1 + 1);
                lft[y2] = min(lft[y2], len);
                rit[y1] = min(rit[y1], len);
                up[x2] = min(up[x2], len);
                down[x1] = min(down[x1], len);
            }
        }
    }
    int ans = INT_MAX;
    for(int i = 1 ; i < m ; i++) {
        for(int j = i + 1 ; j <= m ; j++) {
            ans = min(ans, lft[i] + rit[j]);
        }
    }
    for(int i = 1 ; i < n ; i++) {
        for(int j = i + 1 ; j <= n ; j++) {
            ans = min(ans, up[i] + down[j]);
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：zzzyyyyhhhhh (赞：0)

发现两个合法矩形一定可以由一条水平或竖直的线分割开，所以只要预处理出每条水平或竖直的线左右（或上下）包含 $k$ 朵花周长最小矩形的周长，再枚举水平或竖直的线找出最小答案即可。

预处理考虑枚举每个矩形。发现直接枚举矩形是 $O(n^4)$ 的。由于只需要包含花朵数为 $k$ 的矩形，所以枚举矩形的一条边，剩下的一个点二分或双指针求出位置就可以确定矩形。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 500;
int l,w;
int n,k;
int a[N][N];
int f[N],g[N],h[N],o[N];
/*
f up
g below
h left
o right
*/
inline int m(int x,int y,int xx,int yy)
{
	return a[xx][yy]-a[x-1][yy]-a[xx][y-1]+a[x-1][y-1];
}
int get(int i,int j,int v)
{
	int l=j,r=w,d,ans=0;
	while(l<=r)
	{
		d=(l+r)>>1;
		if(m(i,j,v,d)>=k)
		{
			ans=d;
			r=d-1;
		}
		else l=d+1;
	}
	return m(i,j,v,ans)==k?ans:0;
}
signed main()
{
	cin>>l>>w;
	cin>>n>>k;
	int x,y;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		a[x][y]++;
	}
	n=l;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=w;j++)
		{
			a[i][j]+=a[i][j-1];
		}
	}
	for(int j=1;j<=w;j++)
	{
		for(int i=1;i<=n;i++)
		{
			a[i][j]+=a[i-1][j];
		}
	}
	int e,d;
	memset(f,0x3f,sizeof f);
	memset(g,0x3f,sizeof g);
	memset(h,0x3f,sizeof h);
	memset(o,0x3f,sizeof o);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=w;j++)
		{
			for(int v=i;v<=n;v++)
			{
				e=get(i,j,v);
				if(e)
				{
					d=(e-j+1+v-i+1)<<1;
					f[v]=min(f[v],d);
					g[i]=min(g[i],d);
					h[e]=min(h[e],d);
					o[j]=min(o[j],d);
				}
			}
		}
	}
	int ans=1e9;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i-1;j++)
		{
			ans=min(ans,f[j]+g[i]);
		}
	}
	for(int i=2;i<=w;i++)
	{
		for(int j=1;j<=i-1;j++)
		{
			ans=min(ans,h[j]+o[i]);
		}
	}
	if(ans<=4*(l+w))
	{
		cout<<ans;
	}
	else cout<<"NO";
}
```

---

## 作者：lqsy002 (赞：0)

## 题目大意
题目已经讲得很清楚了。[题目链接](https://www.luogu.com.cn/problem/P5920)。
## 解题思路
这道题在一个矩形中选出两个互不相交的小矩形，那么它们的相对位置只有两种情况。
1. 预处理出上下左右的最小周长矩形，即把每一列向左右，每一行向上下延伸出的符合条件的周长最小的矩形计算出来。
2. 枚举分界线，更新答案。

时间复杂度 $O(n^3)$。
## 参考程序
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,w,n,k,x,y,ans=2e9,a[260][260],sum[260],s1[260],s2[260],s3[260],s4[260];
void work1(){
    for(int i=1;i<=l;i++){
        for(int j=1;j<=w;j++)
			sum[j]=0;
        for(int j=i;j;j--){
            for(int z=1;z<=w;z++)
                  sum[z]+=a[j][z]; 
              int p=1,s=0;
              for(int z=1;z<=w;z++){
                  s+=sum[z];
                  while(s>k&&p<z)
                      s-=sum[p++];
                  while(!sum[p]&&p<z)
                      p++;
                  if(s==k)
                      s1[i]=min(s1[i],2*(i-j+1+z-p+1));
              }
        }
    }
    for(int i=l;i;i--){
        for(int j=1;j<=w;j++)
			sum[j]=0;
        for(int j=i;j<=l;j++){
            for(int z=1;z<=w;z++)
                  sum[z]+=a[j][z];
              int p=1,s=0;
              for(int z=1;z<=w;z++){
                  s+=sum[z];
                  while(s>k&&p<z)
                  	s-=sum[p++];
                  while(!sum[p]&&p<z)
                  	p++;
                  if(s==k)
                      s2[i]=min(s2[i],2*(j-i+1+z-p+1));
              }
        }
    }
}
void work2(){
    for(int i=1;i<=w;i++){
        for(int j=1;j<=l;j++)
			sum[j]=0;
        for(int j=i;j;j--){
              for(int z=1;z<=l;z++)
                  sum[z]+=a[z][j];
              int p=1,s=0;
              for(int z=1;z<=l;z++){
                  s+=sum[z];
                  while(s>k&&p<z)
                      s-=sum[p++];
                  while(!sum[p]&&p<z)
                      p++;
                  if(s==k)
                      s3[i]=min(s3[i],2*(i-j+1+z-p+1));
              }
        }
    }
    for(int i=w;i;i--){
        for(int j=1;j<=l;j++)
			sum[j]=0;
        for(int j=i;j<=w;j++){
            for(int z=1;z<=l;z++)
                  sum[z]+=a[z][j];
              int p=1,s=0;
              for(int z=1;z<=l;z++){
                  s+=sum[z];
                  while(s>k&&p<z)
                      s-=sum[p++];
                  while(!sum[p]&&p<z)
                      p++;
                  if(s==k)
                      s4[i]=min(s4[i],2*(j-i+1+z-p+1));
              }
        }
    }
}
int main(){
    memset(s1,0x3f3f3f3f,sizeof(s1));
    memset(s2,0x3f3f3f3f,sizeof(s2));
    memset(s3,0x3f3f3f3f,sizeof(s3));
    memset(s4,0x3f3f3f3f,sizeof(s4));
    scanf("%d%d%d%d",&l,&w,&n,&k);
    for(int i=1;i<=n;i++){
    	scanf("%d%d",&x,&y);
    	a[x][y]++;
	}
    work1();
    work2();
    for(int i=1;i<l;i++)
    	for(int j=i+1;j<=l;j++)
    		ans=min(ans,s1[i]+s2[j]);
    for(int i=1;i<w;i++)
    	for(int j=i+1;j<=w;j++)
    		ans=min(ans,s3[i]+s4[j]);
    if(ans==2e9)
    	printf("NO");
    else
	printf("%d",ans);
    return 0;
}
```

---


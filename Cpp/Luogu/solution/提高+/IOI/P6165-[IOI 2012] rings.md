# [IOI 2012] rings

## 题目描述

在李奥纳多的文献  "Codex  Atlanticus"  中描述了一种早期而复杂的降落伞。李奥纳多的降落伞是一个由布料缝制而成的金字塔型木头结构。

**串接的圆环**

空中自由落体玩家 Adrain Nicholas （爱准尼古拉斯） 在五百年后测试了李奥纳多的设计。在这个测试中，一个现代的轻量结构将李奥纳多的降落伞使用到人体。我们想要使用串接的圆环，这些圆环为缝制的布料提供了钩子。圆环可以很简单地串接在一起，而且每一个圆环可以打开或关闭。串接的圆环可以构成一种特殊的型态叫做"链"（chain）。所谓的"链"指的是一序列串接的圆环，每个圆环可以串接（最多两个）邻居。但是这个序列必须有个起头与结束（这两个圆环只能串接另外一个圆环）。如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/w6zr6nns.png)

其他种串接型态当然是可能的，因为一个圆环可以串接到3个或更多的圆环。我们说一个圆环是"关键的"如果我们将它打开并移除这个圆环，其他的圆环会形成互无交集的链的集合(或者是没有任何的圆环留下)。

**例子**

请参考下图中的 $7$ 个圆环，其编号由 $0$ 到 $6$。在这个例子中有两个"关键"圆环。其中一个关键圆环是编号 $2$ 的圆环。移除此圆环，剩下的圆环形成三条链 $[1]$, $[0,5,3,4]$ 以及 $[6]$。另外一个关键圆环是编号 $3$ 的圆环，移除此圆环，剩下的圆环形成三条链 $[1,2,0,5]$,$[4]$，以及 $[6]$。如果我们尝试着移除其他的圆环，我们无法获得互无交集的链集合。举例来说，移除编号 $5$ 的圆环之后，虽然可以获得 $[6]$ 这样的一条链，但是 $0,1,2,3$ 以及 $4$ 并没有形成一条链。

![](https://cdn.luogu.com.cn/upload/image_hosting/wk40d8go.png)

**任务**

给定一个串接的圆环型态，你的程序必须计算其关键圆环的个数。


## 说明/提示

对于 $100\%$ 的数据，$1 \le N,L \le 10^6$。

## 样例 #1

### 输入

```
100 84
30 79
26 63
96 30
17 97
33 63
73 25
17 7
96 48
80 6
3 34
51 48
33 37
89 7
72 65
51 54
49 37
45 72
50 39
95 89
3 55
25 0
2 54
10 91
59 2
29 46
0 40
95 68
69 45
87 68
49 38
20 69
87 15
35 39
59 47
38 62
91 19
35 70
83 19
28 20
70 24
36 55
75 36
28 12
53 29
12 16
75 84
40 85
27 53
58 62
88 84
44 27
76 24
58 22
8 44
94 15
14 94
5 83
31 85
90 5
88 42
81 47
76 67
82 80
31 93
14 74
42 98
99 82
71 8
98 92
18 22
81 52
99 23
41 67
74 1
93 56
4 52
1 86
92 60
56 66
18 61
16 57
43 23
4 64
-1
```

### 输出

```
100
```

# 题解

## 作者：DaiRuiChen007 (赞：4)

# P6165 题解

**题目大意**

> 给定 $n$ 个点，$q$ 次操作，每次连一条边，或求图中有多少个点删去后能使得图里只有链。
>
> 数据范围：$n,q\le 10^6$。

考虑第一个 $3$ 度点出现之前的状态，图里一定是环和链，如果没有环答案就是 $n$，一个环时答案是环长，否则是 $0$。

当图中出现了一个 $3$ 度点 $u$，那么删去的点一定是 $u$ 或 $u$ 的邻域，对每个点维护删除该点后的图，判断是否有环和 $3$ 度点即可知道每个点是否合法。

时间复杂度 $\mathcal O(n+q)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int n,m;
struct Graph {
	int ans,del,siz[MAXN],dsu[MAXN],deg[MAXN];
	bool mrk;
	void build(int x) {
		ans=(~x)?1:n,del=x,mrk=0;
		for(int i=1;i<=n;++i) siz[i]=1,dsu[i]=i,deg[i]=0;
	}
	int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
	void link(int u,int v) {
		if(u==del||v==del||!ans) return ;
		if(++deg[u]>=3||++deg[v]>=3) return ans=0,void();
		u=find(u),v=find(v);
		if(u==v) {
			if(~del) ans=0;
			else {
				if(!mrk&&ans==n) ans=siz[u],mrk=1;
				else ans=0;
			}
			return ;
		}
		if(siz[u]>siz[v]) swap(u,v);
		dsu[u]=v,siz[v]+=siz[u];
	}
}	o[5];
vector <int> G[MAXN];
signed main() {
	ios::sync_with_stdio(false);
	bool flg=0;
	cin>>n>>m;
	o[0].build(-1);
	for(int x,y;m--;) {
		cin>>x;
		if(~x) {
			cin>>y,++x,++y;
			if(!flg) {
				o[0].link(x,y);
				G[x].push_back(y);
				G[y].push_back(x);
				if(G[x].size()==3) {
					o[1].build(x);
					for(int i:{0,1,2}) o[i+2].build(G[x][i]);
					for(int u=1;u<=n;++u) for(int v:G[u]) if(v>u) {
						for(int t:{1,2,3,4}) o[t].link(u,v);
					}
					flg=true;
					continue;
				}
				if(G[y].size()==3) {
					o[1].build(y);
					for(int i:{0,1,2}) o[i+2].build(G[y][i]);
					for(int u=1;u<=n;++u) for(int v:G[u]) if(v>u) {
						for(int t:{1,2,3,4}) o[t].link(u,v);
					}
					flg=true;
					continue;
				}
			} else for(int i:{1,2,3,4}) o[i].link(x,y);
		} else {
			if(!flg) cout<<o[0].ans<<"\n";
			else {
				int ans=0;
				for(int i:{1,2,3,4}) ans+=o[i].ans;
				cout<<ans<<"\n";
			}
		}
	}
	return 0;
}
```



---

## 作者：wangliu (赞：0)

# P6165 \[IOI 2012] rings

## 题目思路

这是一道 **思维题**，根据题目意思，只有下面两种不合法情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/zq1g1u8h.png)

左边有环，不合法。

右边的 $3$ 号点的度数为 $3$（下文简称 **三度点**），不合法。

我们需要确定对于每一个点在删除该点之后判断图是否合法，统计删点操作使图合法的点的数量。

直接暴力枚举每个点必然爆炸，其实我们只需要考虑图每一个环和三度点相关的点，因为如果没有环和三度点答案就是 $n$。

对于环：

- 如果图中 **有且仅有一个环**，那么答案只可能是环上点的数量。
- 如果有 **超过一个环**，答案为零。

对于三度点：

- 答案最多为 $4$，即删掉三度点和与三度点相连的三个点。
- 对于四种情况，我们存四张子图，判断是否还有三度点和环，没有就合法，否则不合法。

最后，在图中预处理答案，查询的时间复杂度近似 $O(1)$。

注意：题目数据强，要多加一些剪枝，不然就会超时。

下面是 ~~蒟蒻~~ 的代码～[link](https://www.luogu.me/paste/jutx3ut1)（复制下来看，保存站有点 bug）

---

